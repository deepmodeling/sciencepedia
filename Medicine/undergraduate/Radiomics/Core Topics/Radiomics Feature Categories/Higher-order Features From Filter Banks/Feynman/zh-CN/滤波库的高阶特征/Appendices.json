{
    "hands_on_practices": [
        {
            "introduction": "在应用诸如三维高斯-拉普拉斯（$LoG$）或小波等各向同性滤波器之前，一个关键的预处理步骤是确保图像数据本身是各向同性的。本练习将引导您量化当我们在各向异性的医学图像上直接应用各向同性滤波器时会遇到的两个核心问题：插值引入的模糊和尺度失配。通过这个实践，您将从物理原理出发，计算这些误差，从而深刻理解为何将体素重采样为各向同性是保证高阶特征可靠性的必要前提。",
            "id": "4543619",
            "problem": "您将实现一个在重采样至各向同性体素过程中，对插值引起的模糊进行基于物理的量化，并衡量在各向异性网格上直接应用各向同性滤波器时发生的尺度失配。其背景是影像组学，在该领域中，高阶特征是在应用了各向同性高斯拉普拉斯 (LoG) 和三维小波滤波器之后计算的，这两种滤波器都假设物理上的各向同性。\n\n将使用的基本原理：\n- 连续拉普拉斯算子是旋转不变的，而各向同性高斯拉普拉斯滤波器仅在采样网格是物理各向同性时才保留这种不变性。在各向异性网格上以体素单位应用各向同性核会导致与方向相关的有效尺度。\n- 采集过程可以近似为沿每个轴的矩形体素孔径的可分离卷积。宽度为 $w$（单位面积）的一维矩形函数的二阶中心矩（方差）为 $w^{2}/12$。\n- 在规则网格上的线性插值等效于使用可分离三角基函数（“帽”函数）进行重建。基底宽度为 $2w$（单位面积）的一维三角函数的方差为 $w^{2}/6$。\n- 当两个独立的模糊被近似为高斯核时，它们的卷积可被另一个高斯函数近似，其方差是各分量方差之和。这种高斯矩等效被广泛用于将模糊总结为单个尺度参数。\n- 对于三维可分离点扩散函数，一个各向同性的等效模糊半径可以通过各轴标准差的均方根来概括。\n\n您的程序必须为每个测试用例执行以下操作：\n1) 给定原始体素间距 $s_{x}$、$s_{y}$、$s_{z}$（单位为毫米），以及目标各向同性间距 $t$（单位为毫米，可能大于或小于每个 $s_{i}$），将每个轴上由插值引起的有效模糊建模为矩形体素孔径（宽度 $s_{i}$）和线性插值三角基函数（基底宽度 $2 s_{i}$）的卷积。使用高斯矩等效计算每个轴上的等效高斯标准差，记为 $\\sigma_{x}$、$\\sigma_{y}$、$\\sigma_{z}$（单位为毫米）。您必须分别从矩形核和三角核的方差 $s_{i}^{2}/12$ 和 $s_{i}^{2}/6$ 开始，将它们相加，然后取平方根以获得 $i \\in \\{x,y,z\\}$ 的 $\\sigma_{i}$。\n2) 计算各向同性等效模糊半径 $\\sigma_{\\mathrm{rms}}$（单位为毫米），公式如下\n$$\n\\sigma_{\\mathrm{rms}} \\;=\\; \\sqrt{\\dfrac{\\sigma_{x}^{2} + \\sigma_{y}^{2} + \\sigma_{z}^{2}}{3}} \\, .\n$$\n3) 假设一个预期物理尺度为 $\\sigma_{\\mathrm{phys}}$ 毫米的各向同性高斯拉普拉斯滤波器直接应用于各向异性网格，使用一个在各轴上保持不变的单一“体素尺度”参数（即，以体素单位计，各轴的高斯标准差相同）。如果这个“体素尺度”参数是根据最小间距 $s_{\\min} = \\min\\{s_{x}, s_{y}, s_{z}\\}$ 选择的，那么预期物理尺度在间距为 $s_{\\min}$ 的轴上是匹配的，但在其他轴上则不匹配。在这种简单的做法下，量化三轴上的最坏情况下的相对物理尺度误差（无量纲，以小数表示）：\n$$\n\\varepsilon \\;=\\; \\max_{i \\in \\{x,y,z\\}} \\left| \\dfrac{s_{i} - s_{\\min}}{s_{\\min}} \\right| \\, .\n$$\n这量化了为什么在应用各向同性 LoG 和三维小波滤波器之前建议重采样至各向同性体素：如果不进行重采样，有效的物理尺度将取决于 $s_{i}$。\n\n您的程序应为以下测试套件精确实现上述计算。所有间距和尺度单位均为毫米：\n- 测试用例 1：$s_{x} = 0.7$, $s_{y} = 0.7$, $s_{z} = 5.0$, $t = 1.0$, $\\sigma_{\\mathrm{phys}} = 1.5$。\n- 测试用例 2：$s_{x} = 1.0$, $s_{y} = 1.0$, $s_{z} = 1.0$, $t = 1.0$, $\\sigma_{\\mathrm{phys}} = 1.5$。\n- 测试用例 3：$s_{x} = 1.2$, $s_{y} = 1.2$, $s_{z} = 3.0$, $t = 0.8$, $\\sigma_{\\mathrm{phys}} = 1.5$。\n- 测试用例 4：$s_{x} = 0.8$, $s_{y} = 0.8$, $s_{z} = 0.8$, $t = 2.0$, $\\sigma_{\\mathrm{phys}} = 1.5$。\n\n对于每个测试用例，您的程序必须按以下顺序输出一个包含五个浮点数的列表，除最后一个是无量纲的外，所有数值均以毫米为单位表示：\n- $\\sigma_{x}$，\n- $\\sigma_{y}$，\n- $\\sigma_{z}$，\n- $\\sigma_{\\mathrm{rms}}$，\n- $\\varepsilon$。\n\n最终输出格式：\n- 生成单行输出，其中包含一个逗号分隔的各测试用例结果列表，每个测试用例的结果本身是一个用方括号括起来的逗号分隔列表。例如，包含两个测试用例的输出看起来像 $[ [a,b,c,d,e], [f,g,h,i,j] ]$，所有数字均为十进制表示法。\n- 将您打印的每个数值四舍五入到小数点后恰好 $6$ 位。",
            "solution": "问题陈述经过严格验证，具有科学依据，定义明确，客观，并且对于所要求的任务是完整的。它基于数字图像处理的既定原则及其在影像组学领域的应用。所提供的数据和公式是一致且充分的，足以推导出一个唯一的、有意义的解决方案。变量 $t$ 和 $\\sigma_{\\mathrm{phys}}$ 的存在，虽然在最终计算中未使用，但为问题的前提提供了必要的背景，并不构成矛盾或过度约束的情况。因此，该问题被认定为**有效**。\n\n解决方案基于所提供的物理和数学原理，通过分步实现指定的计算来展开。\n\n### 步骤 1：每轴有效模糊标准差 ($\\sigma_{i}$)\n\n该问题对原始的、可能为各向异性的成像网格上的有效模糊进行建模。这种模糊是两个不同过程的复合：数据采集（将连续信号采样为离散体素）和随后的线性插值（重采样的必要步骤）。这两个模糊过程被建模为卷积。在中心极限定理的影响下，信号处理的一项基本原则允许我们将这些模糊核近似为高斯函数，并通过将其方差相加来求得组合模糊的方差。\n\n1.  **采集模糊**：采集过程在矩形区域上对信号进行积分，这被建模为与可分离矩形函数的卷积。对于给定的轴 $i \\in \\{x, y, z\\}$，该矩形函数的宽度是体素间距 $s_i$。问题陈述指出，宽度为 $w$ 且单位面积的一维矩形函数具有 $w^2/12$ 的二阶中心矩（方差）。因此，沿轴 $i$ 由采集贡献的方差为 $\\text{var}_{\\text{acq}, i} = s_i^2/12$。\n\n2.  **插值模糊**：线性插值在数学上等同于与三角基函数（“帽”函数）的卷积。对于间距为 $s_i$ 的网格，相应的三角基函数的基底宽度为 $2s_i$。问题指定，基底宽度为 $2w$ 且单位面积的一维三角函数的方差为 $w^2/6$。因此，沿轴 $i$ 由线性插值贡献的方差为 $\\text{var}_{\\text{interp}, i} = s_i^2/6$。\n\n3.  **总方差和标准差**：根据卷积独立源的方差相加原理，沿轴 $i$ 的总有效方差 $\\sigma_i^2$ 是采集方差和插值方差之和：\n    $$\n    \\sigma_i^2 = \\text{var}_{\\text{acq}, i} + \\text{var}_{\\text{interp}, i} = \\frac{s_i^2}{12} + \\frac{s_i^2}{6} = \\frac{s_i^2}{12} + \\frac{2s_i^2}{12} = \\frac{3s_i^2}{12} = \\frac{s_i^2}{4}\n    $$\n    有效标准差 $\\sigma_i$ 是总方差的平方根：\n    $$\n    \\sigma_i = \\sqrt{\\frac{s_i^2}{4}} = \\frac{s_i}{2}\n    $$\n    对每个轴 $i \\in \\{x, y, z\\}$ 执行此计算，得出 $\\sigma_x$、$\\sigma_y$ 和 $\\sigma_z$。\n\n### 步骤 2：各向同性等效模糊半径 ($\\sigma_{\\mathrm{rms}}$)\n\n在处理可分离的各向异性点扩散函数 (PSF) 时，通常用单个各向同性值来概括其有效尺度。问题指定使用各轴标准差的均方根 (RMS)。这提供了一个旋转平均的模糊半径度量。\n\n给出的公式为：\n$$\n\\sigma_{\\mathrm{rms}} = \\sqrt{\\frac{\\sigma_{x}^{2} + \\sigma_{y}^{2} + \\sigma_{z}^{2}}{3}}\n$$\n将步骤 1 中 $\\sigma_i^2$ 的表达式代入，我们得到：\n$$\n\\sigma_{\\mathrm{rms}} = \\sqrt{\\frac{(s_x^2/4) + (s_y^2/4) + (s_z^2/4)}{3}} = \\sqrt{\\frac{s_x^2 + s_y^2 + s_z^2}{12}}\n$$\n该公式用于计算单一的各向同性等效模糊半径。\n\n### 步骤 3：最坏情况下的相对物理尺度误差 ($\\varepsilon$)\n\n该度量量化了影像组学中的一个关键问题：将为各向同性网格设计的滤波器直接应用于各向异性数据。一个各向同性滤波器，如三维高斯拉普拉斯滤波器，通常由一个以体素为单位的单一尺度参数 $\\sigma_{\\text{vox}}$ 定义。当此滤波器应用于具有物理间距 $s_x, s_y, s_z$ 的各向异性网格时，滤波器的有效物理尺度变为方向依赖的：$\\sigma_{\\text{phys}, i} = \\sigma_{\\text{vox}} \\cdot s_i$。\n\n问题描述了一种简单但常见的做法，即滤波器的基于体素的尺度 $\\sigma_{\\text{vox}}$ 被选择为在具有最高分辨率（即最小间距，$s_{\\min} = \\min\\{s_x, s_y, s_z\\}$）的轴上匹配所需的物理尺度 $\\sigma_{\\mathrm{phys}}$。这意味着 $\\sigma_{\\mathrm{phys}} = \\sigma_{\\text{vox}} \\cdot s_{\\min}$，或者 $\\sigma_{\\text{vox}} = \\sigma_{\\mathrm{phys}} / s_{\\min}$。\n\n沿任何其他轴 $i$ 的有效物理尺度则为 $\\sigma_{\\text{phys}, i} = \\sigma_{\\text{vox}} \\cdot s_i = (\\sigma_{\\mathrm{phys}} / s_{\\min}) \\cdot s_i$。这个有效尺度与预期物理尺度 $\\sigma_{\\mathrm{phys}}$ 之间的相对误差是：\n$$\n\\text{error}_i = \\frac{|\\sigma_{\\text{phys}, i} - \\sigma_{\\mathrm{phys}}|}{\\sigma_{\\mathrm{phys}}} = \\frac{|(\\sigma_{\\mathrm{phys}} / s_{\\min}) \\cdot s_i - \\sigma_{\\mathrm{phys}}|}{\\sigma_{\\mathrm{phys}}} = \\left| \\frac{s_i}{s_{\\min}} - 1 \\right| = \\left| \\frac{s_i - s_{\\min}}{s_{\\min}} \\right|\n$$\n量 $\\varepsilon$ 被定义为在所有三轴上该误差的最坏情况（最大值）：\n$$\n\\varepsilon = \\max_{i \\in \\{x,y,z\\}} \\left| \\frac{s_{i} - s_{\\min}}{s_{\\min}} \\right|\n$$\n此计算需要找到最小间距 $s_{\\min}$，然后为每个 $s_i$ 计算该表达式的值。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes radiomic metrics related to grid anisotropy for a suite of test cases.\n    \"\"\"\n    # Test cases: (s_x, s_y, s_z, t, sigma_phys) all in millimeters.\n    # The variables t and sigma_phys are provided for context as per the problem\n    # statement, but are not used in the specified calculations.\n    test_cases = [\n        (0.7, 0.7, 5.0, 1.0, 1.5),\n        (1.0, 1.0, 1.0, 1.0, 1.5),\n        (1.2, 1.2, 3.0, 0.8, 1.5),\n        (0.8, 0.8, 0.8, 2.0, 1.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        s_x, s_y, s_z, t, sigma_phys = case\n        spacings = np.array([s_x, s_y, s_z])\n\n        # Step 1: Calculate per-axis effective blur standard deviations (sigma_i).\n        # The total variance is the sum of acquisition (s_i^2/12) and linear\n        # interpolation (s_i^2/6) variances. Total variance = s_i^2/4.\n        # The standard deviation sigma_i is the square root, so sigma_i = s_i/2.\n        sigmas = spacings / 2.0\n        sigma_x, sigma_y, sigma_z = sigmas[0], sigmas[1], sigmas[2]\n\n        # Step 2: Calculate the isotropic equivalent blur radius (sigma_rms).\n        # sigma_rms = sqrt((sigma_x^2 + sigma_y^2 + sigma_z^2) / 3).\n        # This simplifies to sqrt((s_x^2 + s_y^2 + s_z^2) / 12).\n        sigma_rms = np.sqrt(np.sum(spacings**2) / 12.0)\n\n        # Step 3: Calculate the worst-case relative physical scale error (epsilon).\n        s_min = np.min(spacings)\n        if s_min == 0:\n            # Avoid division by zero, though not expected with problem data.\n            epsilon = 0.0\n        else:\n            relative_errors = np.abs((spacings - s_min) / s_min)\n            epsilon = np.max(relative_errors)\n\n        # Store the 5 required float values for the current test case.\n        case_results = [sigma_x, sigma_y, sigma_z, sigma_rms, epsilon]\n        all_results.append(case_results)\n\n    # Format the final output string according to the problem specification.\n    # Each sub-list is formatted as \"[n1,n2,n3,n4,n5]\" with numbers\n    # rounded to 6 decimal places. These are then joined into a main list.\n    # e.g., \"[[a,b,c,d,e],[f,g,h,i,j]]\"\n    formatted_rows = []\n    for row in all_results:\n        formatted_numbers = [f\"{num:.6f}\" for num in row]\n        formatted_rows.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output = f\"[{','.join(formatted_rows)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在保证了数据网格的各向同性后，下一步便是构建我们需要的滤波器。高斯-拉普拉斯（$LoG$）滤波器是检测不同尺度下斑点状结构的基础工具。本练习将带您从连续的数学定义出发，一步步构建一个符合物理原理的三维$LoG$离散核。您将学习如何基于能量标准来确定滤波器的大小，并评估其旋转对称性，以确保它在应用于离散数据时能够表现出预期的性能。",
            "id": "4543676",
            "problem": "您的任务是构建一个三维 ($3$D) 离散高斯-拉普拉斯 (LoG) 核，用于从各向同性体积图像中进行放射组学特征计算。您的程序必须实现一种有原则的方法来选择截断半径，以保持旋转对称性并控制截断尾部的能量损失。\n\n从以下基本定义和事实开始：\n\n- 标准差为 $\\sigma$ 的三维各向同性高斯函数是一个在 $\\mathbb{R}^{3}$ 上的径向对称函数 $G_{\\sigma}(\\mathbf{x})$，其中 $\\mathbf{x} \\in \\mathbb{R}^{3}$ 且 $r = \\|\\mathbf{x}\\|$，使得 $G_{\\sigma}(\\mathbf{x}) = a_{\\sigma} \\exp\\!\\left(-\\dfrac{r^{2}}{2\\sigma^{2}}\\right)$，其中 $a_{\\sigma} > 0$ 的选择需满足 $\\int_{\\mathbb{R}^{3}} G_{\\sigma}(\\mathbf{x}) \\, d\\mathbf{x} = 1$。\n- 高斯-拉普拉斯 (LoG) 函数由拉普拉斯算子 $\\nabla^{2}$ 作用于 $G_{\\sigma}$ 定义，即 $\\mathrm{LoG}_{\\sigma}(\\mathbf{x}) = \\nabla^{2} G_{\\sigma}(\\mathbf{x})$。在各向同性介质中，$\\mathrm{LoG}_{\\sigma}(\\mathbf{x})$ 是一个关于 $r$ 的径向函数。\n- 一个函数 $f$ 在 $\\mathbb{R}^{3}$ 上的能量平方（$L^{2}$ 范数的平方）为 $\\|f\\|_{2}^{2} = \\int_{\\mathbb{R}^{3}} |f(\\mathbf{x})|^{2} \\, d\\mathbf{x}$。对于一个径向函数 $f(r)$，其能量可简化为一个测度为 $4\\pi r^{2} \\, dr$ 的一维积分。\n- 在单位体素间距的各向同性采样中，一个径向对称的连续核 $k(r)$ 可以通过在整数偏移量 $(i,j,k)$ 处采样（其中 $r = \\sqrt{i^{2} + j^{2} + k^{2}}$）而被离散化到整数格点 $\\mathbb{Z}^{3}$ 上。\n\n您的任务是：\n\n- 对于每个给定的对 $(\\sigma,\\varepsilon)$（其中 $\\sigma > 0$ 且 $\\varepsilon \\in (0,1)$），确定最小的非负整数半径 $R$（单位为体素），使得半径为 $R$ 的球体之外的 LoG 能量平方的占比至多为 $\\varepsilon$。形式上，令 $L_{\\sigma}(r)$ 表示连续径向 LoG 函数。定义总能量 $E_{\\mathrm{tot}} = 4\\pi \\int_{0}^{\\infty} L_{\\sigma}(r)^{2} r^{2} \\, dr$ 和尾部能量 $E_{\\mathrm{tail}}(R) = 4\\pi \\int_{R}^{\\infty} L_{\\sigma}(r)^{2} r^{2} \\, dr$。选择最小的整数 $R \\ge 0$，使得 $E_{\\mathrm{tail}}(R)/E_{\\mathrm{tot}} \\le \\varepsilon$。截断的理由必须遵循此能量比率准则。\n- 通过在立方体 $[-R,R]^{3} \\cap \\mathbb{Z}^{3}$ 内的整数格点上对连续 $\\mathrm{LoG}_{\\sigma}$ 函数进行采样来构建离散核。通过减去采样核值的均值，以离散方式强制执行零和性质，使得离散和等于 $0$（在数值精度范围内）。由于减法在空间上是均匀的，这样做可以在保持旋转对称性的同时，在离散卷积中保留 LoG 的带通特性。\n- 按如下方式量化所构建的离散核的旋转对称性。通过宽度固定为 $\\Delta r = 0.5$（单位为体素）的径向区间，将采样点划分到不同的球壳中。对于每个球壳中的核值绝对值集合，计算其变异系数，定义为该球壳内绝对值的标准差除以其均值（仅在为防止除零错误时使用一个小的正常数）。报告所有包含至少 $6$ 个点的球壳中，这些球壳级变异系数的最大值。一个小的最大值意味着在球壳内（即径向距离相似但角度不同的点），核的量级几乎是恒定的，表明离散化后具有良好的旋转对称性。\n\n实现要求：\n\n- 程序必须使用上述连续能量比率准则来确定 $R$（而不是通过临时的启发式方法），然后对核进行采样，并计算上面定义的旋转对称性度量。\n- 您的程序不得读取任何输入。请使用以下 $(\\sigma,\\varepsilon)$ 对的测试套件：\n  - $(\\sigma,\\varepsilon) = (1.0, 10^{-3})$\n  - $(\\sigma,\\varepsilon) = (1.5, 10^{-4})$\n  - $(\\sigma,\\varepsilon) = (2.0, 10^{-6})$\n  - $(\\sigma,\\varepsilon) = (0.6, 10^{-3})$\n- 对于每个测试用例，输出一个包含以下内容的列表：\n  - 核的边长 $N = 2R + 1$（整数），\n  - 实现的连续尾部能量比率 $E_{\\mathrm{tail}}(R)/E_{\\mathrm{tot}}$（浮点数），\n  - 最大的球壳级变异系数（如上定义）（浮点数）。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的、以逗号分隔的列表。列表中的每个元素对应一个测试用例，其本身也是一个按上述顺序排列的列表。例如，最终输出应为形如 $[[N_{1},e_{1},v_{1}],[N_{2},e_{2},v_{2}],\\dots]$ 的单行。\n\n注：\n\n- 本问题不使用角度单位。\n- 除了离散网格所隐含的体素单位外，不涉及其他物理单位。\n- 程序中所有数值必须为标准浮点格式；上述数学描述使用的是精确的实值积分。",
            "solution": "该问题是适定的，有科学依据，并为获得唯一的、可验证的解提供了充分信息。我们接下来进行逐步推导和算法设计。\n\n### 第 1 部分：连续高斯-拉普拉斯 (LoG) 函数与能量准则\n\n第一步是推导三维高斯-拉普拉斯 (LoG) 函数的解析表达式，并构建基于能量的截断准则。\n\n**1.1. 三维各向同性高斯函数与 LoG 函数**\n\n问题将三维各向同性高斯函数定义为 $G_{\\sigma}(\\mathbf{x}) = a_{\\sigma} \\exp(-\\frac{r^2}{2\\sigma^2})$，其中 $r = \\|\\mathbf{x}\\| = \\sqrt{x^2+y^2+z^2}$。归一化常数 $a_{\\sigma}$ 由条件 $\\int_{\\mathbb{R}^3} G_{\\sigma}(\\mathbf{x}) \\, d\\mathbf{x} = 1$ 确定。在球坐标系下计算该积分可得：\n$$ \\int_{0}^{\\infty} a_{\\sigma} e^{-\\frac{r^2}{2\\sigma^2}} 4\\pi r^2 \\, dr = 1 $$\n标准的三维高斯积分为 $\\int_{\\mathbb{R}^3} e^{-\\|\\mathbf{x}\\|^2/(2\\sigma^2)} \\, d\\mathbf{x} = (2\\pi\\sigma^2)^{3/2}$。因此，$a_{\\sigma} (2\\pi\\sigma^2)^{3/2} = 1$，这意味着 $a_{\\sigma} = (2\\pi\\sigma^2)^{-3/2}$。归一化的高斯函数为：\n$$ G_{\\sigma}(r) = (2\\pi\\sigma^2)^{-3/2} \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right) $$\nLoG 定义为 $L_{\\sigma}(r) = \\nabla^2 G_{\\sigma}(r)$。对于一个径向函数 $f(r)$，其拉普拉斯算子为 $\\nabla^2 f(r) = f''(r) + \\frac{2}{r}f'(r)$。我们计算 $G_{\\sigma}(r)$ 的导数：\n$$ G'_{\\sigma}(r) = G_{\\sigma}(r) \\cdot \\left(-\\frac{r}{\\sigma^2}\\right) $$\n$$ G''_{\\sigma}(r) = G'_{\\sigma}(r) \\cdot \\left(-\\frac{r}{\\sigma^2}\\right) + G_{\\sigma}(r) \\cdot \\left(-\\frac{1}{\\sigma^2}\\right) = G_{\\sigma}(r)\\left(\\frac{r^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) $$\n将它们结合起来，LoG 函数为：\n$$ L_{\\sigma}(r) = \\nabla^2 G_{\\sigma}(r) = \\left(\\frac{r^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right)G_{\\sigma}(r) + \\frac{2}{r}\\left(-\\frac{r}{\\sigma^2}\\right)G_{\\sigma}(r) = \\left(\\frac{r^2}{\\sigma^4} - \\frac{3}{\\sigma^2}\\right)G_{\\sigma}(r) $$\n代入 $G_{\\sigma}(r)$ 的表达式：\n$$ L_{\\sigma}(r) = \\frac{1}{\\sigma^2}\\left(\\frac{r^2}{\\sigma^2} - 3\\right) (2\\pi\\sigma^2)^{-3/2} \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right) = \\frac{1}{(2\\pi)^{3/2}\\sigma^5}\\left(\\frac{r^2}{\\sigma^2} - 3\\right) \\exp\\left(-\\frac{r^2}{2\\sigma^2}\\right) $$\n\n**1.2. 能量截断准则**\n\n截断半径 $R$ 由 LoG 能量平方在尾部分布的占比决定。总能量为 $E_{\\mathrm{tot}} = \\int_{\\mathbb{R}^3} |L_{\\sigma}(\\mathbf{x})|^2 \\, d\\mathbf{x}$，对于径向函数，这变为：\n$$ E_{\\mathrm{tot}} = 4\\pi \\int_{0}^{\\infty} L_{\\sigma}(r)^2 r^2 \\, dr $$\n半径为 $R$ 的球体外部的尾部能量为：\n$$ E_{\\mathrm{tail}}(R) = 4\\pi \\int_{R}^{\\infty} L_{\\sigma}(r)^2 r^2 \\, dr $$\n条件是找到最小的整数 $R \\ge 0$，使得比率 $\\frac{E_{\\mathrm{tail}}(R)}{E_{\\mathrm{tot}}} \\le \\varepsilon$。用于这些能量计算的被积函数为 $L_{\\sigma}(r)^2 r^2$：\n$$ L_{\\sigma}(r)^2 r^2 = \\frac{1}{(2\\pi)^3 \\sigma^{10}} \\left(\\frac{r^2}{\\sigma^2} - 3\\right)^2 \\exp\\left(-\\frac{r^2}{\\sigma^2}\\right) r^2 $$\n常数前置因子 $\\frac{1}{(2\\pi)^3 \\sigma^{10}}$ 在能量比率中被抵消。因此，我们只需要考虑函数 $f(r, \\sigma) = \\left(\\frac{r^2}{\\sigma^2} - 3\\right)^2 \\exp\\left(-\\frac{r^2}{\\sigma^2}\\right) r^2$ 的积分：\n$$ \\frac{E_{\\mathrm{tail}}(R)}{E_{\\mathrm{tot}}} = \\frac{\\int_{R}^{\\infty} f(r, \\sigma) \\, dr}{\\int_{0}^{\\infty} f(r, \\sigma) \\, dr} \\le \\varepsilon $$\n这些积分没有简单的闭式反导数，最好使用数值积分方法进行计算。\n\n### 第 2 部分：算法流程\n\n**2.1. 寻找截断半径 $R$**\n\n对于每对 $(\\sigma, \\varepsilon)$，我们通过以下迭代搜索找到最小整数 $R$：\n1. 使用数值积分方法计算一次总能量积分 $I_{\\mathrm{tot}} = \\int_{0}^{\\infty} f(r, \\sigma) \\, dr$。\n2. 迭代整数半径 $R = 0, 1, 2, \\ldots$。\n3. 在每次迭代中，计算尾部能量积分 $I_{\\mathrm{tail}}(R) = \\int_{R}^{\\infty} f(r, \\sigma) \\, dr$。\n4. 计算能量比率 $e_R = I_{\\mathrm{tail}}(R) / I_{\\mathrm{tot}}$。\n5. 第一个满足 $e_R \\le \\varepsilon$ 的整数 $R$ 就是所求的截断半径。核的边长则为 $N = 2R + 1$。实现的能量比率为 $e_R$。\n\n**2.2. 构建离散核**\n\n根据确定的半径 $R$，通过在三维整数格点上对连续 LoG 函数进行采样来构建离散核。\n1. 定义点格 $(i, j, k)$，其中 $i, j, k \\in \\{-R, -R+1, \\ldots, R\\}$。\n2. 对于每个点，计算其到原点的欧几里得距离：$r_{ijk} = \\sqrt{i^2 + j^2 + k^2}$。\n3. 初始离散核值为 $K_{ijk} = L_{\\sigma}(r_{ijk})$。$L_{\\sigma}$ 中的任何整体缩放常数在此阶段都可以省略，因为它不影响后续的对称性计算。为保证数值稳定性，我们可以采样函数 $L'_{\\sigma}(r) = (\\frac{r^2}{\\sigma^2}-3)\\exp(-\\frac{r^2}{2\\sigma^2})$。\n4. 为强制执行零和性质（这是对应于导数的离散滤波器的一个关键方面），我们从每个元素中减去所有采样值的均值。设所有采样值的集合为 $\\{K_{ijk}\\}$。其均值为 $\\bar{K} = \\frac{1}{(2R+1)^3} \\sum_{i,j,k=-R}^R K_{ijk}$。\n5. 最终经过均值校正的核为 $K'_{ijk} = K_{ijk} - \\bar{K}$。现在其和 $\\sum_{i,j,k} K'_{ijk}$ 为零（在机器精度范围内）。\n\n**2.3. 量化旋转对称性**\n\n最终离散核 $K'$ 的旋转对称性通过分析其值在球壳内的变化来进行评估。\n1. 核点 $(i,j,k)$ 根据其半径 $r_{ijk}$ 被划分到不同的区间（bin）中。区间的固定宽度为 $\\Delta r = 0.5$，因此第 $m$ 个区间包含半径 $r \\in [m \\cdot \\Delta r, (m+1) \\cdot \\Delta r)$ 的点。\n2. 对于每个包含至少 6 个点的区间，我们计算该区间内核值绝对值集合 $\\{|K'_{ijk}|\\}$ 的变异系数 (CV)。\n3. 一个区间的 CV 定义为其值的标准差除以其均值。如果均值为零（这只在所有绝对值都为零时发生），则 CV 取为 0。\n4. 最终的对称性度量是在所有符合条件的区间中找到的最大 CV。较低的值表示更好的旋转对称性，因为在相似的径向距离上，核的量级更加恒定。\n\n这一全面的流程使我们能够构建一个有原则的 LoG 核，并客观地评估其离散旋转对称性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (1.0, 1e-3),\n        (1.5, 1e-4),\n        (2.0, 1e-6),\n        (0.6, 1e-3),\n    ]\n\n    all_results = []\n    for sigma, epsilon in test_cases:\n        # Part 1: Determine the truncation radius R\n        R, achieved_energy_ratio = find_truncation_radius(sigma, epsilon)\n        \n        # Part 2: Construct the discrete kernel\n        N = 2 * R + 1\n        coords = np.mgrid[-R:R+1, -R:R+1, -R:R+1].astype(np.float64)\n        radii = np.sqrt(coords[0]**2 + coords[1]**2 + coords[2]**2)\n\n        # We use the unnormalized LoG for sampling as constants do not affect CV.\n        # This is proportional to the full L_sigma(r) function.\n        # The form is (r^2/sigma^2 - 3) * exp(-r^2/(2*sigma^2))\n        r_sq_over_sigma_sq = (radii**2) / (sigma**2)\n        kernel = (r_sq_over_sigma_sq - 3.0) * np.exp(-0.5 * r_sq_over_sigma_sq)\n        \n        # Enforce zero-sum property\n        mean_corrected_kernel = kernel - np.mean(kernel)\n        \n        # Part 3: Quantify rotational symmetry\n        max_cv = calculate_rotational_symmetry(mean_corrected_kernel, radii)\n        \n        result_tuple = [N, achieved_energy_ratio, max_cv]\n        all_results.append(result_tuple)\n\n    # Final print statement in the exact required format.\n    # Produces a single line, e.g., [[N1,e1,v1],[N2,e2,v2],...]\n    result_str = \",\".join([f\"[{N},{e:.8f},{v:.8f}]\" for N, e, v in all_results])\n    print(f\"[{result_str}]\")\n\n\ndef find_truncation_radius(sigma, epsilon):\n    \"\"\"\n    Finds the smallest integer radius R satisfying the energy criterion.\n    \"\"\"\n    # Integrand for energy calculation, omitting constant factors that cancel.\n    def energy_integrand(r, s):\n        r_sq_over_s_sq = (r**2) / (s**2)\n        # The exponential term comes from squaring L_sigma, which has exp(-r^2/(2*sigma^2)).\n        # So L_sigma^2 has exp(-r^2/sigma^2).\n        return (r_sq_over_s_sq - 3.0)**2 * np.exp(-r_sq_over_s_sq) * r**2\n\n    # Calculate total energy once\n    total_energy, _ = integrate.quad(energy_integrand, 0, np.inf, args=(sigma,))\n\n    if total_energy == 0:\n        return 0, 1.0\n\n    R = 0\n    while True:\n        tail_energy, _ = integrate.quad(energy_integrand, R, np.inf, args=(sigma,))\n        ratio = tail_energy / total_energy if total_energy > 0 else 1.0\n        \n        if ratio = epsilon:\n            return R, ratio\n        R += 1\n        # Safety break for very large R\n        if R > 100:\n            # This should not be reached with typical inputs\n            raise RuntimeError(\"Exceeded maximum search radius for R.\")\n\n\ndef calculate_rotational_symmetry(kernel, radii):\n    \"\"\"\n    Calculates the maximum shell-wise coefficient of variation.\n    \"\"\"\n    delta_r = 0.5\n    \n    flat_radii = radii.flatten()\n    flat_abs_values = np.abs(kernel.flatten())\n    \n    # Determine the number of bins needed\n    max_radius = np.max(flat_radii) if flat_radii.size > 0 else 0\n    # Add one bin for safety, handles max_radius falling exactly on a bin edge.\n    num_bins = int(np.ceil(max_radius / delta_r)) + 1 \n    \n    bins = [[] for _ in range(num_bins)]\n    \n    for r, val in zip(flat_radii, flat_abs_values):\n        bin_idx = int(r / delta_r)\n        if bin_idx  num_bins:\n            bins[bin_idx].append(val)\n    \n    max_cv = 0.0\n    for shell_values in bins:\n        if len(shell_values) >= 6:\n            mean_val = np.mean(shell_values)\n            std_dev = np.std(shell_values)\n            \n            # Prevent division by zero, as specified.\n            if mean_val > 1e-12: # A small positive constant to check against\n                cv = std_dev / mean_val\n                if cv > max_cv:\n                    max_cv = cv\n    \n    return max_cv\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "应用滤波器组的最终目的是从滤波后的图像中提取定量的影像组学特征。小波变换作为一种强大的多尺度、多方向分析工具，正是一种典型的滤波器组。本练习将向您展示如何从多级小波分解的输出中提取能量和熵等高阶特征。通过这个过程，您将学会如何捕捉原始图像中不可见的复杂纹理信息，为目标区域生成一个信息丰富的多尺度特征签名。",
            "id": "4543681",
            "problem": "给定一个表示为实值矩阵的正方形二维感兴趣区域 (ROI) 图像，您需要使用标准正交、可分离的 Haar 基，通过离散小波变换计算多尺度放射组学纹理特征。目标是在每个分解层级上定义并计算子带能量和熵特征，然后跨层级聚合这些特征，以捕捉多尺度纹理签名。\n\n从以下基本原理开始：\n- 二维标准正交变换保持能量守恒，即如果变换是标准正交的，则系数的平方和等于输入像素的平方和。可分离 Haar 小波变换满足此性质。\n- 可分离 Haar 小波变换在每个层级上沿行和列应用一维低通和高通标准正交滤波器，并在每个维度上进行系数为 $2$ 的降采样。每个层级 $l$ 产生的子带是低-低近似子带 $LL_l$（用作下一级的输入）以及细节子带 $LH_l$、$HL_l$ 和 $HH_l$。\n- 对于总和为 $1$ 的非负值有限集合 $\\{p_k\\}$，以比特为单位的香农熵为 $H = - \\sum_k p_k \\log_2 p_k$，并约定 $0 \\log_2 0 = 0$。\n\n本问题中使用的定义：\n- 对于任何子带矩阵 $S$，其能量定义为 $E(S) = \\sum_{i,j} S_{i,j}^2$。\n- 对于任何子带矩阵 $S$，其熵 $H(S)$ 定义为其系数归一化能量分布的香农熵，即令 $p_{i,j} = S_{i,j}^2 / \\sum_{u,v} S_{u,v}^2$，并定义 $H(S) = - \\sum_{i,j} p_{i,j} \\log_2 p_{i,j}$，其中 $0 \\log_2 0$ 解释为 $0$。如果 $\\sum_{i,j} S_{i,j}^2 = 0$，则定义 $H(S) = 0$。\n\n跨层级聚合：\n- 设有 $L$ 个分解层级。对于每个层级 $l \\in \\{1,\\dots,L\\}$，计算每层细节能量 $E_l = E(LH_l) + E(HL_l) + E(HH_l)$。\n- 定义每层归一化细节能量为 $e_l = E_l \\big/ \\left(\\sum_{k=1}^{L} E_k\\right)$，并约定如果 $\\sum_{k=1}^{L} E_k = 0$，则 $e_l = 0$。\n- 定义每层平均熵为 $h_l = \\left(H(LH_l) + H(HL_l) + H(HH_l)\\right) / 3$。\n- 令总输入能量为 $E_{\\mathrm{tot}} = \\sum_{i,j} X_{i,j}^2$。定义全局细节能量分数为 $f = \\left(\\sum_{l=1}^{L} E_l\\right) / E_{\\mathrm{tot}}$。\n\n您的任务：\n- 实现一个函数，对 ROI 执行 $L$ 级二维 Haar 小波变换，并按上述定义计算 $\\{e_l\\}_{l=1}^{L}$、$\\{h_l\\}_{l=1}^{L}$ 和 $f$。\n- 对每个 ROI，输出一个向量，该向量串联了各层级的每层归一化细节能量和每层平均熵，最后是全局细节能量分数：\n  $$\\left[e_1, h_1, e_2, h_2, \\dots, e_L, h_L, f\\right].$$\n- 为实现标准化报告，将输出向量中的每个实数四舍五入到六位小数。\n\n假设与约束：\n- 所有 ROI 均为正方形，其边长可被 $2^L$ 整除，以支持 $L$ 级的抽取。\n- ROI 强度是无单位的实数。\n\n在程序内部实现的测试套件（无用户输入）：\n- 案例 $1$：一个 $8 \\times 8$ 的均匀 ROI，所有条目等于 $5.0$，$L=3$。\n- 案例 $2$：一个 $8 \\times 8$ 的棋盘格 ROI，条目为 $X_{i,j} = (-1)^{i+j}$，$i,j \\in \\{0,\\dots,7\\}$，$L = 3$。\n- 案例 $3$：一个 $8 \\times 8$ 的水平梯度 ROI，条目为 $X_{i,j} = j$，$i,j \\in \\{0,\\dots,7\\}$，$L = 3$。\n- 案例 $4$：一个 $8 \\times 8$ 的随机 ROI，从固定种子为 $0$ 的标准正态分布中抽取，即使用以种子 $0$ 初始化的伪随机数生成器生成 $X_{i,j} \\sim \\mathcal{N}(0,1)$，$L=3$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含每个案例结果的列表，每个结果是 $L=3$ 时的向量 $\\left[e_1, h_1, e_2, h_2, e_3, h_3, f\\right]$。数字必须四舍五入到六位小数。最后一行必须是格式完全如下的单个字符串：\n  \"[[v11,v12,...,v1,7],[v21,v22,...,v2,7],[v31,v32,...,v3,7],[v41,v42,...,v4,7]]\"\n其中 $v_{k,m}$ 表示案例 $k$ 的向量的第 $m$ 个元素。不应打印任何额外文本。",
            "solution": "该问题要求从表示为实数矩阵的二维感兴趣区域 (ROI) 中计算一组多尺度纹理特征。这些特征源自二维离散 Haar 小波变换的系数。该过程涉及信号分解、从每个分解层级的子带中提取特征，以及将这些特征聚合成最终的特征向量。该方法论基于小波分析和信息论的原理。\n\n首先，我们讨论核心变换：$L$ 级二维可分离标准正交 Haar 小波变换。Haar 基是最简单的小波基。其一维 (1D) 低通滤波器由系数 $[1/\\sqrt{2}, 1/\\sqrt{2}]$ 定义，高通滤波器由 $[1/\\sqrt{2}, -1/\\sqrt{2}]$ 定义。因子 $1/\\sqrt{2}$ 确保了变换是标准正交的，这一性质保证了能量守恒。对一个 $N \\times N$ 的输入矩阵 $X$ 进行单级可分离二维 (2D) 变换，过程分为两步：\n$1$. 对 $X$ 的每一行应用一维 Haar 变换。这将产生两个大小为 $N \\times (N/2)$ 的矩阵：一个包含低通（近似）系数，另一个包含高通（细节）系数。\n$2$. 接着，对这两个中间矩阵的每一列应用一维 Haar 变换。这将得到四个 $(N/2) \\times (N/2)$ 的子带矩阵：\n- $LL_1$：近似子带（行和列方向均为低通）。\n- $LH_1$：细节子带（行低通，列高通），捕捉水平特征。\n- $HL_1$：细节子带（行高通，列低通），捕捉垂直特征。\n- $HH_1$：细节子带（两个方向均为高通），捕捉对角线特征。\n\n对于 $L$ 级分解，此过程被递归应用。来自层级 $l$ 的近似子带 $LL_l$ 作为层级 $l+1$ 分解的输入。这种递归分解将图像分离成不同尺度（频率）的分量，其中层级 $l=1$ 对应最精细的细节（最高频率），而层级 $L$ 对应较粗糙的特征（较低频率）。问题规定输入 ROI 的尺寸是 $2^L$ 的倍数，确保了在每个维度上进行系数为 $2$ 的‘抽取’或降采样总是可行的。\n\n接下来，我们定义要从小波系数中提取的特征。对于任何子带矩阵 $S$，定义了两个基本量：\n- **能量**：子带的能量定义为其系数的平方和：$E(S) = \\sum_{i,j} S_{i,j}^2$。这衡量了包含在与 $S$ 对应的频带内的信号功率。\n- **熵**：子带的熵 $H(S)$ 定义为其系数的归一化能量分布的香农熵。我们构建一个概率分布 $\\{p_{i,j}\\}$，其中每个 $p_{i,j} = S_{i,j}^2 / E(S)$。熵则为 $H(S) = - \\sum_{i,j} p_{i,j} \\log_2 p_{i,j}$。该特征量化了子带内纹理的复杂性或随机性。低熵表明存在一个规则的模式，能量集中在少数几个系数中；而高熵则表示一个更复杂或不规则的纹理，能量分散在许多系数上。根据约定，如果 $E(S)=0$，则 $H(S)=0$。\n\n利用来自 $L$ 级分解的子带 $\\{LH_l, HL_l, HH_l\\}_{l=1}^L$，我们按规定计算聚合特征：\n$1$. **每层细节能量**，$E_l = E(LH_l) + E(HL_l) + E(HH_l)$：层级 $l$ 处所有细节分量的总能量。\n$2$. **每层归一化细节能量**，$e_l = E_l / \\sum_{k=1}^{L} E_k$：层级 $l$ 处的细节能量占总细节能量的比例。这创建了一个纹理能量如何在不同尺度上分布的签名。如果 $\\sum_{k=1}^{L} E_k = 0$，则 $e_l=0$。\n$3$. **每层平均熵**，$h_l = (H(LH_l) + H(HL_l) + H(HH_l)) / 3$：层级 $l$ 处细节子带的平均熵，捕捉了该尺度下的平均纹理复杂度。\n$4$. **全局细节能量分数**，$f = (\\sum_{l=1}^{L} E_l) / E_{\\mathrm{tot}}$：所有细节子带中的总能量与原始 ROI 总能量 $E_{\\mathrm{tot}} = \\sum_{i,j} X_{i,j}^2$ 的比率。这个值 $f$ 表示图像的整体“纹理度”。接近 $1$ 的值意味着图像纹理丰富或噪声较多，而接近 $0$ 的值则意味着图像平滑、均匀。\n\n处理给定 ROI 矩阵 $X$ 进行 $L$ 级分解的最终算法如下：\n$1$. 计算输入 ROI 的总能量 $E_{\\mathrm{tot}}$。\n$2$. 对 $X$ 执行 $L$ 级二维 Haar 小波变换，以获得从 $1$ 到 $L$ 的每个层级 $l$ 的细节子带集合 $\\{LH_l, HL_l, HH_l\\}$。\n$3$. 对于每个层级 $l \\in \\{1, \\dots, L\\}$，计算每层细节能量 $E_l$ 和每层平均熵 $h_l$。\n$4$. 将每层细节能量相加，得到总细节能量 $\\sum_k E_k$。\n$5$. 计算 $l \\in \\{1, \\dots, L\\}$ 的每层归一化细节能量 $e_l$。\n$6$. 计算全局细节能量分数 $f$。\n$7$. 将这些计算出的值串联成一个单一的特征向量：$[e_1, h_1, e_2, h_2, \\dots, e_L, h_L, f]$。\n$8$. 然后将此向量的每个元素四舍五入到六位小数以供报告。此过程将应用于问题陈述中指定的四个测试案例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dwt2d_haar_single_level(matrix):\n    \"\"\"\n    Performs a single level of 2D Haar wavelet decomposition.\n    \"\"\"\n    # Row-wise transform\n    mat_r_a = (matrix[:, 0::2] + matrix[:, 1::2]) / np.sqrt(2)\n    mat_r_d = (matrix[:, 0::2] - matrix[:, 1::2]) / np.sqrt(2)\n    \n    # Column-wise transform on the results of the row-wise transform\n    ll = (mat_r_a[0::2, :] + mat_r_a[1::2, :]) / np.sqrt(2)\n    hl = (mat_r_a[0::2, :] - mat_r_a[1::2, :]) / np.sqrt(2)\n    lh = (mat_r_d[0::2, :] + mat_r_d[1::2, :]) / np.sqrt(2)\n    hh = (mat_r_d[0::2, :] - mat_r_d[1::2, :]) / np.sqrt(2)\n    \n    return ll, lh, hl, hh\n\ndef dwt2d_haar_L_level(matrix, L):\n    \"\"\"\n    Performs an L-level 2D Haar wavelet decomposition.\n    \"\"\"\n    approx = matrix.astype(float)\n    details_per_level = []\n    for _ in range(L):\n        approx, lh, hl, hh = dwt2d_haar_single_level(approx)\n        details_per_level.append({'lh': lh, 'hl': hl, 'hh': hh})\n    return details_per_level\n\ndef subband_energy(S):\n    \"\"\"\n    Computes the energy of a subband matrix S.\n    \"\"\"\n    return np.sum(S**2)\n\ndef subband_entropy(S):\n    \"\"\"\n    Computes the Shannon entropy of the normalized energy distribution of S.\n    \"\"\"\n    E_S = subband_energy(S)\n    if E_S == 0:\n        return 0.0\n    \n    p = (S**2) / E_S\n    \n    # Filter out p_ij = 0 terms to avoid log2(0) situations.\n    non_zero_p = p[p > 0]\n    \n    # an empty array will sum to 0.0, handling the case where S is non-zero\n    # but contains only one non-zero element (p=1, H=0)\n    if non_zero_p.size == 0:\n        return 0.0\n\n    H = -np.sum(non_zero_p * np.log2(non_zero_p))\n    return H\n\ndef calculate_features(roi, L):\n    \"\"\"\n    Calculates the full feature vector for a given ROI and decomposition level L.\n    \"\"\"\n    # Total input energy\n    E_tot = subband_energy(roi.astype(float))\n\n    if E_tot == 0:  # Handle all-zero image\n        return [0.0] * (2 * L + 1)\n\n    # Perform L-level DWT\n    details_all_levels = dwt2d_haar_L_level(roi, L)\n    \n    # Per-level feature calculation\n    E_l_list = []\n    h_l_list = []\n    for l_idx in range(L):\n        details = details_all_levels[l_idx]\n        lh_l, hl_l, hh_l = details['lh'], details['hl'], details['hh']\n        \n        # Per-level detail energy\n        E_l = subband_energy(lh_l) + subband_energy(hl_l) + subband_energy(hh_l)\n        E_l_list.append(E_l)\n        \n        # Per-level mean entropy\n        H_lh = subband_entropy(lh_l)\n        H_hl = subband_entropy(hl_l)\n        H_hh = subband_entropy(hh_l)\n        h_l = (H_lh + H_hl + H_hh) / 3.0\n        h_l_list.append(h_l)\n        \n    # Total detail energy across all levels\n    E_detail = np.sum(E_l_list)\n    \n    # Per-level normalized detail energy\n    if E_detail == 0:\n        e_l_list = [0.0] * L\n    else:\n        e_l_list = [E_l / E_detail for E_l in E_l_list]\n        \n    # Global detail energy fraction\n    f = E_detail / E_tot\n    \n    # Assemble the final feature vector\n    feature_vector = []\n    for l in range(L):\n        feature_vector.append(e_l_list[l])\n        feature_vector.append(h_l_list[l])\n    feature_vector.append(f)\n    \n    return feature_vector\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute features, and print results.\n    \"\"\"\n    L = 3\n    test_cases = [\n        # Case 1: Uniform ROI\n        np.full((8, 8), 5.0),\n        # Case 2: Checkerboard ROI\n        np.array([[(-1)**(i+j) for j in range(8)] for i in range(8)]),\n        # Case 3: Horizontal gradient ROI\n        np.array([[j for j in range(8)] for i in range(8)]),\n        # Case 4: Random ROI from N(0,1) with fixed seed\n        np.random.default_rng(seed=0).normal(size=(8, 8))\n    ]\n\n    all_results = []\n    for case_roi in test_cases:\n        features = calculate_features(case_roi, L)\n        all_results.append(features)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for vec in all_results:\n        # Round each number and format to 6 decimal places\n        inner_list_str = '[' + ','.join([f'{x:.6f}' for x in vec]) + ']'\n        formatted_results.append(inner_list_str)\n    \n    final_output_string = '[' + ','.join(formatted_results) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}