{
    "hands_on_practices": [
        {
            "introduction": "Laws的高通滤波器有一个最基本的属性：其系数之和为零。这个特性意味着，当滤波器应用于图像中的均匀区域时，其响应应该接近于零。这项练习  提供了一种动手实践的方法，以数值方式验证这一关键原理。这不仅是任何纹理分析实现的基础“健全性检查”，也是理解滤波器如何在图像中区分均匀区域和纹理区域的第一步。",
            "id": "4565057",
            "problem": "在放射组学纹理分析中，Laws 纹理能量度量依赖于将图像与从一维 Laws 向量派生出的可分离高通掩模进行卷积，然后计算能量汇总统计量。高通掩模的一个基本属性是其所有掩模系数的总和为零。因此，当这种掩模与一个恒定图像进行卷积时，除了边界（可以通过使用有效卷积区域来消除）之外，其响应在各处都应接近于零。这个属性可以用来数值化地检测预处理错误，例如不正确的归一化或意外的偏移。\n\n从以下基本依据出发：\n- 离散图像 $I$ 和离散滤波器 $H$ 之间的二维（2D）离散卷积的定义，\n$$\n(I * H)[i,j] \\;=\\; \\sum_{p}\\sum_{q} I[i - p, j - q]\\, H[p, q],\n$$\n其中求和是在 $H$ 的有限支撑集上进行的。\n- 长度为 $5$ 的标准 Laws 一维（1D）向量，如下所示：\n$$\nL_5 = [\\,1,\\,4,\\,6,\\,4,\\,1\\,],\\quad\nE_5 = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,],\\quad\nS_5 = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,],\n$$\n$$\nW_5 = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,],\\quad\nR_5 = [\\,1,\\,-4,\\,6,\\,-4,\\,1\\,],\n$$\n以及通过两个一维向量的外积构建二维可分离掩模，\n$$\nH \\;=\\; u\\, v^{\\top},\n$$\n其中 $u, v \\in \\{L_5, E_5, S_5, W_5, R_5\\}$。\n\n你的任务是实现一个程序，该程序针对包含此类掩模和恒定图像的给定小型测试套件，对每个测试用例进行数值化验证，验证以下两个标准：\n- 零和属性：所有掩模系数总和的绝对值小于或等于指定的容差 $\\tau_s$。\n- 在恒定图像上的近零响应：当使用有效卷积将恒定图像 $I[i,j] = c$ 与掩模进行卷积时，定义为平均绝对响应的纹理能量，\n$$\nTE(I,H) \\;=\\; \\frac{1}{M} \\sum_{(i,j)\\in \\Omega_{\\text{valid}}} \\big| (I * H)[i,j] \\big|,\n$$\n小于或等于指定的容差 $\\tau_e$，其中 $\\Omega_{\\text{valid}}$ 表示有效卷积区域，$M$ 是其基数。\n\n对于每个测试用例，当且仅当上述两个标准都满足时，输出一个布尔值 true。程序必须通过指定的外积构造指示的二维掩模 $H$，可选择用一个标量因子对其进行缩放，并可选择通过一个小的加性值扰动单个系数以模拟预处理错误。然后，它必须将 $H$ 与指定大小和恒定水平 $c$ 的恒定图像进行卷积，计算有效区域上的 $TE(I,H)$，并评估这两个标准。\n\n实现以下测试套件。每个测试用例指定：\n- 从 $\\{L_5, E_5, S_5, W_5, R_5\\}$ 中选择的行向量 $u$ 和列向量 $v$\n- 用于乘以掩模的缩放因子 $s$\n- 一个可选的扰动三元组 $(i_p, j_p, \\delta)$，表示在缩放后应将 $\\delta$ 加到行索引为 $i_p$、列索引为 $j_p$（从零开始的索引）的单个掩模条目上\n- 一个 $N \\times N$ 恒定图像的图像大小 $N$\n- 图像的恒定水平 $c$\n- 容差 $\\tau_s$ 和 $\\tau_e$\n\n使用以下六个测试用例：\n1. $u = E_5$，$v = L_5$，$s = 1.0$，无扰动，$N = 64$，$c = 7.0$，$\\tau_s = 10^{-12}$，$\\tau_e = 10^{-12}$。\n2. $u = L_5$，$v = L_5$，$s = 1.0$，无扰动，$N = 32$，$c = 2.0$，$\\tau_s = 10^{-12}$，$\\tau_e = 10^{-12}$。\n3. $u = W_5$，$v = S_5$，$s = 3.0$，无扰动，$N = 48$，$c = 5.0$，$\\tau_s = 10^{-12}$，$\\tau_e = 10^{-12}$。\n4. $u = E_5$，$v = S_5$，$s = 1.0$，扰动 $(i_p, j_p, \\delta) = (2, 2, 10^{-6})$，$N = 40$，$c = 1.0$，$\\tau_s = 10^{-8}$，$\\tau_e = 10^{-8}$。\n5. $u = R_5$，$v = R_5$，$s = 1.0$，无扰动，$N = 5$，$c = 10.0$，$\\tau_s = 10^{-12}$，$\\tau_e = 10^{-12}$。\n6. $u = L_5$，$v = E_5$，$s = 1.0$，无扰动，$N = 64$，$c = 3.0$，$\\tau_s = 10^{-12}$，$\\tau_e = 10^{-12}$。\n\n实现细节：\n- 构造 $H = s \\cdot (u\\, v^{\\top})$，如果指定了扰动，则应用该扰动。\n- 使用有效卷积执行二维卷积以避免边界效应；只有有效部分对 $TE(I,H)$ 有贡献。\n- 所有计算都是无量纲的；不需要物理单位。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,\\dots,result_6]$），其中每个 $result_k$ 是按顺序对应于测试用例 $k$ 的布尔值。",
            "solution": "该问题要求对 Laws 纹理掩模的基本属性进行数值验证，特别是它们在应用于恒定图像时的行为。解决方案涉及实现一个基于数字信号处理和线性代数原理的算法。\n\nLaws 方法的基础在于一组长度为 $5$ 的一维（1D）向量。问题提供了标准集：\n$$L_5 = [\\,1,\\,4,\\,6,\\,4,\\,1\\,]$$\n$$E_5 = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,]$$\n$$S_5 = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,]$$\n$$W_5 = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,]$$\n$$R_5 = [\\,1,\\,-4,\\,6,\\,-4,\\,1\\,]$$\n\n这些向量可以根据其滤波特性进行分类。向量 $L_5$（Level）是一个低通平均滤波器。其他四个向量——$E_5$（Edge）、$S_5$（Spot）、$W_5$（Wave）和 $R_5$（Ripple）——是高通或带通滤波器，设计用于检测特定的纹理基元。这些高通滤波器的一个决定性特征是其系数之和为零。这可以通过直接求和来验证：\n$\\sum E_5 = -1 - 2 + 0 + 2 + 1 = 0$\n$\\sum S_5 = -1 + 0 + 2 + 0 - 1 = 0$\n$\\sum W_5 = -1 + 2 + 0 - 2 + 1 = 0$\n$\\sum R_5 = 1 - 4 + 6 - 4 + 1 = 0$\n相比之下，低通滤波器 $L_5$ 不具有此属性：$\\sum L_5 = 1 + 4 + 6 + 4 + 1 = 16$。\n\n二维（2D）可分离掩模 $H$ 是通过取两个一维向量 $u$ 和 $v$ 的外积来构造的：\n$$H = u v^\\top$$\n生成的二维掩模 $H$ 中所有系数的总和可以表示为：\n$$\\sum_{i,j} H[i, j] = \\sum_{i,j} u[i] v[j] = \\left(\\sum_i u[i]\\right) \\left(\\sum_j v[j]\\right)$$\n这个恒等式表明，如果其组成的一维向量 $u$ 或 $v$ 中至少有一个是零和的，那么二维掩模 $H$ 就是一个零和掩模。因此，任何由至少一个来自 $\\{E_5, S_5, W_5, R_5\\}$ 的向量构造的掩模都将是零和掩模。唯一导致非零和掩模的组合是 $L_5 L_5^\\top$。\n\n需要验证的核心原理是这些掩模对恒定输入的响应。考虑一个处处恒定的离散图像 $I$，即对于某个常数 $c$，$I[i,j] = c$。$I$ 与掩模 $H$ 的二维卷积由下式给出：\n$$(I * H)[i,j] = \\sum_{p}\\sum_{q} I[i - p, j - q] H[p, q]$$\n由于 $I$ 是恒定的，对于所有的 $p, q$，$I[i - p, j - q] = c$。因此，表达式简化为：\n$$(I * H)[i,j] = c \\left(\\sum_{p,q} H[p, q]\\right)$$\n如果 $H$ 是一个零和掩模，那么 $\\sum_{p,q} H[p, q] = 0$，并且对于所有输出像素 $(i,j)$，卷积的结果是 $(I * H)[i, j] = c \\cdot 0 = 0$。这对于‘有效’卷积区域是成立的，在该区域中，核 $H$ 完全包含在图像内部，从而避免任何边界效应。\n\n问题要求对这一属性进行数值验证，这需要进行两项检查，以考虑浮点不精确性和可能引入的误差。\n\n**标准1：掩模的零和属性。**\n此检查直接在给定的数值容差 $\\tau_s$ 内验证所构造的掩模 $H$ 是否为零和。一个掩模可能会受到扰动，例如，通过向其一个系数添加一个小值 $\\delta$。检查如下：\n$$\\left| \\sum_{i,j} H[i, j] \\right| \\le \\tau_s$$\n如果一个掩模由至少一个零和向量构成且未受扰动，其和在理想算术中将精确为 $0$。在浮点计算中，这个和应该非常接近 $0$。如果结果的总和超过容差，一个非零和掩模（如 $L_5 L_5^\\top$）或一个受扰动的零和掩模将很可能无法通过此项检查。\n\n**标准2：在恒定图像上的近零响应。**\n此检查验证零和属性的最终结果。纹理能量 $TE(I,H)$ 定义为有效卷积区域 $\\Omega_{\\text{valid}}$ 内的平均绝对响应：\n$$TE(I,H) = \\frac{1}{M} \\sum_{(i,j)\\in \\Omega_{\\text{valid}}} \\big| (I * H)[i,j] \\big| \\le \\tau_e$$\n其中 $M$ 是 $\\Omega_{\\text{valid}}$ 中的像素数。如果标准1成立且掩模和（接近）为零，则卷积输出 $(I * H)[i,j]$ 在各处也应（接近）为零。因此，纹理能量 $TE$ 应该非常小并满足此条件。\n\n每个测试用例的总体算法如下：\n1.  选择指定的一维向量 $u$ 和 $v$。\n2.  通过缩放外积构造二维掩模 $H$：$H = s \\cdot (u v^\\top)$。\n3.  如果指定了扰动 $(i_p, j_p, \\delta)$，则修改掩模：$H[i_p, j_p] \\leftarrow H[i_p, j_p] + \\delta$。\n4.  计算掩模系数的绝对和，并检查其是否在容差 $\\tau_s$ 之内。\n5.  生成值为 $c$ 的 $N \\times N$ 恒定图像。\n6.  对图像与掩模进行二维卷积，仅保留输出的‘有效’部分。\n7.  通过计算有效卷积输出的绝对值的平均值来计算纹理能量 $TE$。\n8.  检查纹理能量是否在容差 $\\tau_e$ 之内。\n9.  当且仅当两个检查（来自步骤4和8）都通过时，该测试用例的结果为 `True`。\n\n例如，在测试用例 2（$u=L_5, v=L_5$）中，掩模系数的和是 $s \\cdot (\\sum L_5) \\cdot (\\sum L_5) = 1.0 \\cdot 16 \\cdot 16 = 256$。由于 $|256|$ 不小于或等于 $\\tau_s=10^{-12}$，该用例未通过标准 1，最终结果为 `False`。相比之下，对于测试用例 1（$u=E_5, v=L_5$），系数的和为 $s \\cdot (\\sum E_5) \\cdot (\\sum L_5) = 1.0 \\cdot 0 \\cdot 16 = 0$。这通过了标准 1。随后与恒定图像的卷积产生了近零响应，通过了标准 2。因此，结果为 `True`。测试用例 4 引入了一个扰动 $\\delta=10^{-6}$，导致掩模和变为 $10^{-6}$，这大于容差 $\\tau_s=10^{-8}$，因此它未通过标准 1。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Validates Laws' texture masks against zero-sum and near-zero response properties.\n    \"\"\"\n    laws_vectors = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n    }\n\n    test_cases = [\n        {'u': 'E5', 'v': 'L5', 's': 1.0, 'pert': None, 'N': 64, 'c': 7.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'L5', 'v': 'L5', 's': 1.0, 'pert': None, 'N': 32, 'c': 2.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'W5', 'v': 'S5', 's': 3.0, 'pert': None, 'N': 48, 'c': 5.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'E5', 'v': 'S5', 's': 1.0, 'pert': (2, 2, 1e-6), 'N': 40, 'c': 1.0, 'tau_s': 1e-8, 'tau_e': 1e-8},\n        {'u': 'R5', 'v': 'R5', 's': 1.0, 'pert': None, 'N': 5, 'c': 10.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n        {'u': 'L5', 'v': 'E5', 's': 1.0, 'pert': None, 'N': 64, 'c': 3.0, 'tau_s': 1e-12, 'tau_e': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        u_vec = laws_vectors[case['u']]\n        v_vec = laws_vectors[case['v']]\n\n        # 1. Construct the 2D mask = s * (u v^T)\n        H = case['s'] * np.outer(u_vec, v_vec)\n\n        # 2. Apply optional perturbation\n        if case['pert']:\n            i_p, j_p, delta = case['pert']\n            H[i_p, j_p] += delta\n\n        # 3. Criterion 1: Verify the zero-sum property of the mask\n        mask_sum_abs = np.abs(np.sum(H))\n        criterion1_passed = mask_sum_abs = case['tau_s']\n\n        # 4. Create the constant image\n        image = np.full((case['N'], case['N']), case['c'], dtype=np.float64)\n\n        # 5. Perform 2D convolution with 'valid' mode\n        conv_output = convolve2d(image, H, mode='valid')\n\n        # 6. Criterion 2: Verify near-zero response\n        texture_energy = 0.0\n        if conv_output.size > 0:\n            texture_energy = np.mean(np.abs(conv_output))\n        \n        criterion2_passed = texture_energy = case['tau_e']\n\n        # The final result is true if and only if both criteria are satisfied.\n        results.append(criterion1_passed and criterion2_passed)\n\n    # Format the final output as a comma-separated list of booleans in a string\n    # Python's `str(bool)` converts True to \"True\" and False to \"False\"\n    # The problem asks for lowercase \"true\" and \"false\", so we adjust.\n    output_str = f\"[{','.join(str(r).lower() for r in results)}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在简单的空间域检查之后，我们可以通过更复杂的频率分析来进一步验证滤波器的性能。根据线性时不变（LSI）系统理论，我们可以通过滤波器的频率响应精确预测其对图像的影响。这项练习  要求你通过比较合成正弦图像的实际输出与基于滤波器频率增益的理论预测输出来测试你的滤波器实现，从而加深你对空间卷积和频域分析之间联系的理解。",
            "id": "4565096",
            "problem": "您的任务是基于线性移不变 (LSI) 系统的数学行为，为 Laws 滤波器实现设计一个正确性验证测试。在放射组学的纹理分析中，Laws 纹理能量度量 (TEM) 使用由一维核构建的小型、可分离的二维滤波器来凸显特定的纹理模式。您的测试必须在包含单个正弦分量的合成数据上验证，滤波后输出的振幅与滤波器在正弦波空间频率处的频率响应幅值相匹配。验证必须在循环卷积下进行以避免边界伪影，并且比较必须以数值形式表示。\n\n从以下基本定义开始：\n- 一个脉冲响应为 $h[n]$ 的线性移不变 (LSI) 系统，通过将输入信号 $x[n]$ 与 $h[n]$ 进行离散卷积来产生输出。\n- 对于长度为 $M$ 的掩模，有限脉冲响应 $h[n]$ 的离散时间傅里叶变换 (DTFT) 定义为 $H(\\omega) = \\sum_{n=0}^{M-1} h[n] e^{-j \\omega n}$，其中 $\\omega$ 是以弧度为单位的角频率。\n- 对于一个二维可分离掩模 $C = a b^{\\top}$，其中 $a$ 是沿 $y$ 轴应用的垂直分量，$b$ 是沿 $x$ 轴应用的水平分量，二维卷积等效于沿 $y$ 轴和 $x$ 轴的连续一维卷积。\n- 在 LSI 系统下，单位振幅的单频正弦输入在滤波后仍保持相同频率的正弦波形式，其振幅按系统在该频率下的频率响应幅值进行缩放。相位可能会改变，但不影响均方根 (RMS) 振幅。\n\n使用长度为 $5$ 的标准一维 Laws 向量：\n- $L5 = [1,4,6,4,1]$,\n- $E5 = [-1,-2,0,2,1]$,\n- $S5 = [-1,0,2,0,-1]$,\n- $W5 = [-1,2,0,-2,1]$,\n- $R5 = [1,-4,6,-4,1]$。\n\n从这些向量构建二维掩模 $C = a b^{\\top}$。处理一个大小为 $128 \\times 128$ 的合成图像 $I[x,y]$，其坐标为 $x \\in \\{0,1,\\dots,127\\}$ 和 $y \\in \\{0,1,\\dots,127\\}$。该图像应包含一个单位振幅的单一正弦波：\n$$\nI[x,y] = \\sin\\left(2\\pi\\left(\\frac{k_x}{128} x + \\frac{k_y}{128} y\\right) + \\phi\\right),\n$$\n其中 $k_x$ 和 $k_y$ 是以每图像维度的周期数表示的整数空间频率，$\\phi$ 是相位偏移。$\\phi$ 使用弧度单位。\n\n对于每个测试用例，按以下步骤进行：\n- 使用二维循环卷积将 $I[x,y]$ 与 $C$ 进行卷积，生成一个相同大小的输出 $O[x,y]$。\n- 通过 RMS 计算 $O[x,y]$ 的测量振幅：首先计算 $R = \\sqrt{\\frac{1}{128^2}\\sum_{x=0}^{127}\\sum_{y=0}^{127} O[x,y]^2}$，然后通过 $A_{\\text{meas}} = \\sqrt{2}\\,R$ 转换为正弦振幅。\n- 从第一性原理出发，基于一维核的 DTFT 和二维频率响应的可分离性，推导可分离掩模的预测振幅 $A_{\\text{pred}}$。使用在角频率 $\\omega_x = 2\\pi \\frac{k_x}{128}$ 和 $\\omega_y = 2\\pi \\frac{k_y}{128}$ 处的复频率响应的幅值。不要假定任何预先推导的快捷公式；从 DTFT 定义以及可分离卷积和 LSI 系统的性质来证明其构建过程。\n- 将每个用例的相对误差报告为浮点数：\n$$\ne = \\frac{\\left|A_{\\text{meas}} - A_{\\text{pred}}\\right|}{\\max\\left(10^{-12}, A_{\\text{pred}}\\right)}.\n$$\n\n设计包含以下六个测试用例的测试套件，这些用例共同探测低空间频率和高空间频率、方向选择性、可分离性和近奈奎斯特行为。在每个元组中，第一个元素是垂直核 $a$，第二个是水平核 $b$，然后是 $(k_x,k_y,\\phi)$：\n1. $(E5, L5, 8, 0, 0.0)$,\n2. $(L5, E5, 0, 8, 1.0)$,\n3. $(S5, S5, 32, 0, 0.5)$,\n4. $(R5, R5, 60, 60, 0.0)$,\n5. $(W5, L5, 1, 0, 0.0)$,\n6. $(E5, E5, 16, 16, 0.25)$.\n\n您的程序必须计算六个测试用例中每个用例的相对误差 $e$，并以确切的格式单行打印结果：\n- 一个用方括号括起来、由逗号分隔的六个浮点数的 Python 列表，例如 $[e_1,e_2,e_3,e_4,e_5,e_6]$。\n\n不允许使用外部输入或文件，所有角度必须以弧度为单位。程序必须使用二维循环卷积（边界环绕），并且只返回指定的单行输出。",
            "solution": "该问题是有效的，因为它提出了一个定义明确、科学上合理的任务，该任务基于数字信号处理的基本原理。其目标是通过将正弦输入的经验测量响应与从滤波器频率特性推导出的理论预测响应进行比较，来验证 Laws 纹理滤波器的实现。\n\n核心原理是，当线性移不变 (LSI) 系统受到正弦输入时，会产生一个相同频率的正弦输出。输出正弦波的振幅是输入振幅与系统在输入频率处的频率响应幅值的乘积。\n\n输入信号是一个单位振幅的二维正弦波：\n$$\nI[x,y] = \\sin\\left(2\\pi\\left(\\frac{k_x}{N} x + \\frac{k_y}{N} y\\right) + \\phi\\right)\n$$\n其中 $N=128$ 是图像维度。输入振幅为 $A_{\\text{in}} = 1$。角空间频率为 $\\omega_x = 2\\pi k_x/N$ 和 $\\omega_y = 2\\pi k_y/N$。\n\n滤波器是一个 $5 \\times 5$ 的可分离掩模 $C = a b^{\\top}$，其中 $a$ 是垂直核（沿 $y$ 轴应用），$b$ 是水平核（沿 $x$ 轴应用）。输出图像为 $O = I \\circledast C$，其中 $\\circledast$ 表示二维循环卷积。\n\n**1. 预测振幅 ($A_{\\text{pred}}$) 推导**\n\n根据 LSI 系统理论，输出信号的振幅 $A_{\\text{out}}$ 由以下公式给出：\n$$\nA_{\\text{out}} = A_{\\text{in}} \\cdot |H_C(\\omega_x, \\omega_y)|\n$$\n其中 $H_C(\\omega_x, \\omega_y)$ 是滤波器 $C$ 的二维频率响应。由于输入振幅 $A_{\\text{in}}$ 为 $1$，预测的输出振幅就是 $A_{\\text{pred}} = |H_C(\\omega_x, \\omega_y)|$。\n\n可分离滤波器的一个关键特性是，它们的二维频率响应是其构成核的一维频率响应的乘积。核 $a$ 沿垂直方向（$y$ 轴）应用，核 $b$ 沿水平方向（$x$ 轴）应用。因此，二维频率响应为：\n$$\nH_C(\\omega_x, \\omega_y) = H_b(\\omega_x) \\cdot H_a(\\omega_y)\n$$\n其中 $H_b(\\omega_x)$ 是核 $b$ 在频率 $\\omega_x$ 处的频率响应，而 $H_a(\\omega_y)$ 是核 $a$ 在频率 $\\omega_y$ 处的频率响应。\n\n因此，预测振幅为：\n$$\nA_{\\text{pred}} = |H_b(\\omega_x) \\cdot H_a(\\omega_y)| = |H_b(\\omega_x)| \\cdot |H_a(\\omega_y)|\n$$\n对于一个给定长度为 $M=5$ 的核 $h$，其一维频率响应 $H_h(\\omega)$ 使用问题中定义的离散时间傅里叶变换 (DTFT) 进行计算：\n$$\nH_h(\\omega) = \\sum_{n=0}^{M-1} h[n] e^{-j \\omega n}\n$$\n这里，$h[n]$ 是 Laws 向量的元素，索引从 $n=0$ 到 $n=4$。幅值 $|H_h(\\omega)|$ 通过取这个复数和的绝对值来计算。\n\n**2. 测量振幅 ($A_{\\text{meas}}$) 步骤**\n\n测量振幅是通过卷积输出凭经验确定的。\n首先，为每个测试用例生成 $128 \\times 128$ 的输入图像 $I[x,y]$。其次，将 $5 \\times 5$ 的滤波器核 $C$ 构建为垂直核 $a$ 和水平核 $b$ 的外积，即 $C = ab^{\\top}$。第三，通过对输入图像 $I$ 和核 $C$ 进行二维循环卷积来计算输出图像 $O[x,y]$。\n\n输出信号 $O[x,y]$ 将是一个形式为 $A_{\\text{meas}} \\sin(\\omega_x x + \\omega_y y + \\phi')$ 的正弦波。这种信号的均方根 (RMS) 值为 $R = A_{\\text{meas}}/\\sqrt{2}$。问题提供了计算离散输出图像 RMS 的公式：\n$$\nR = \\sqrt{\\frac{1}{N^2}\\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} O[x,y]^2}\n$$\n其中 $N=128$。通过重新整理 RMS 和振幅之间的关系，我们可以计算出测量振幅为：\n$$\nA_{\\text{meas}} = \\sqrt{2} \\cdot R\n$$\n\n**3. 误差计算**\n\n理论预测和经验测量通过相对误差 $e$ 进行比较：\n$$\ne = \\frac{\\left|A_{\\text{meas}} - A_{\\text{pred}}\\right|}{\\max\\left(10^{-12}, A_{\\text{pred}}\\right)}\n$$\n分母中的项 $\\max(10^{-12}, A_{\\text{pred}})$ 是一个保护措施，用于防止在滤波器预期完全消除输入正弦波（即 $A_{\\text{pred}} = 0$）的情况下出现除以零的错误。\n\n以下程序为六个指定的测试用例实现了这整个过程。它根据 DTFT 公式计算 $A_{\\text{pred}}$，通过循环卷积和 RMS 计算 $A_{\\text{meas}}$，最后计算每个用例的相对误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Solves the Laws' filter proof-of-correctness test.\n    \"\"\"\n    \n    # Define canonical one-dimensional Laws' vectors of length 5\n    LAWS_KERNELS = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n    }\n\n    # Define the test suite\n    test_cases = [\n        # (vertical_kernel, horizontal_kernel, (kx, ky, phi))\n        ('E5', 'L5', (8, 0, 0.0)),\n        ('L5', 'E5', (0, 8, 1.0)),\n        ('S5', 'S5', (32, 0, 0.5)),\n        ('R5', 'R5', (60, 60, 0.0)),\n        ('W5', 'L5', (1, 0, 0.0)),\n        ('E5', 'E5', (16, 16, 0.25)),\n    ]\n\n    def calc_freq_resp_mag(kernel, omega):\n        \"\"\"\n        Calculates the magnitude of the frequency response for a 1D kernel at a\n        given angular frequency, using the DTFT definition.\n        H(omega) = sum_{n=0}^{M-1} h[n] * exp(-j * omega * n)\n        \"\"\"\n        n_indices = np.arange(len(kernel))\n        complex_exponentials = np.exp(-1j * omega * n_indices)\n        H = np.sum(kernel * complex_exponentials)\n        return np.abs(H)\n\n    results = []\n    N = 128\n    x_coords = np.arange(N)\n    y_coords = np.arange(N)\n    xx, yy = np.meshgrid(x_coords, y_coords)\n\n    for case in test_cases:\n        a_name, b_name, params = case\n        kx, ky, phi = params\n        \n        a_kernel = LAWS_KERNELS[a_name]\n        b_kernel = LAWS_KERNELS[b_name]\n\n        # 1. Derive the predicted amplitude (A_pred) from first principles\n        omega_x = 2 * np.pi * kx / N\n        omega_y = 2 * np.pi * ky / N\n        \n        # Frequency response of vertical kernel 'a' at frequency 'omega_y'\n        pred_amp_a = calc_freq_resp_mag(a_kernel, omega_y)\n        # Frequency response of horizontal kernel 'b' at frequency 'omega_x'\n        pred_amp_b = calc_freq_resp_mag(b_kernel, omega_x)\n        \n        # A_pred for the separable 2D filter is the product of 1D responses\n        A_pred = pred_amp_a * pred_amp_b\n\n        # 2. Compute the measured amplitude (A_meas)\n        # Generate the synthetic image with a single sinusoidal component\n        I = np.sin(2 * np.pi * (kx * xx / N + ky * yy / N) + phi)\n\n        # Construct the 2D separable mask C = a * b^T\n        C_2D_kernel = np.outer(a_kernel, b_kernel)\n\n        # Perform 2D circular convolution to get the output image O\n        O = convolve2d(I, C_2D_kernel, boundary='wrap', mode='same')\n\n        # Compute RMS of the output, then convert to sinusoidal amplitude\n        R = np.sqrt(np.mean(np.square(O)))\n        A_meas = np.sqrt(2) * R\n\n        # 3. Report the relative error\n        error = np.abs(A_meas - A_pred) / np.maximum(1e-12, A_pred)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{r:.14f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了实现的正确性之后，我们来关注计算效率，这在放射组学等实际应用中至关重要。Laws滤波器的可分离特性为显著的计算优化提供了可能。这项练习  将指导你实现一种缓存策略，以避免在生成共享相同第一阶段核的多个掩模时进行冗余计算，并量化理论上的加速效果，展示对算法结构的深刻理解如何转化为更高效的代码。",
            "id": "4565070",
            "problem": "您被要求在放射组学的背景下，设计并分析一种使用可分离一维滤波器计算 Laws 纹理能量测度的计算策略。出发的基本点是可分离卷积的定义和一个简单的、基于操作的成本模型。一个 Laws 二维掩模由两个一维核的外积形成，可以通过两次连续的一维卷积来实现：一次沿水平方向，一次沿垂直方向。假设给定的五抽头 Laws 一维核为\n$$\\mathrm{L5} = [\\,1,\\,4,\\,6,\\,4,\\,1\\,],\\quad \\mathrm{E5} = [\\,-1,\\,-2,\\,0,\\,2,\\,1\\,],\\quad \\mathrm{S5} = [\\,-1,\\,0,\\,2,\\,0,\\,-1\\,],$$\n$$\\mathrm{R5} = [\\,1,\\,-4,\\,6,\\,-4,\\,1\\,],\\quad \\mathrm{W5} = [\\,-1,\\,2,\\,0,\\,-2,\\,1\\,].$$\n可分离卷积意味着，将一幅图像与由核 $a$ 和 $b$ 的外积形成的二维掩模进行卷积，等同于首先用核 $a$ 沿水平方向进行一维卷积，然后用核 $b$ 沿垂直方向进行一维卷积。设图像尺寸为 $H \\times W$。\n\n对于一维卷积过程，采用以下经过充分测试的成本模型：对于长度为 $k$ 的核，每个输出元素需要 $k$ 次乘法和 $k-1$ 次加法。请以此为基础出发点，推导您的方法并量化计算加速效果。\n\n您的任务是：\n- 提出并实现一种方法，该方法缓存中间的一维滤波图像，以避免在生成共享相同第一阶段核（第一次水平过程）的多个掩模时进行重复计算。实现两种方法：一种是为每个掩模重新计算两个过程的基线方法，另一种是为每个独特的第一阶段核重用水平过程的缓存方法。\n- 将每个掩模的 Laws 纹理能量计算为滤波后图像绝对值的全局平均值。在边界处使用对称反射，以使输出尺寸保持为 $H \\times W$。\n- 使用上述成本模型，推导并计算缓存方法相对于基线方法在每个测试用例中的理论加速因子。加速因子应表示为浮点数，严格根据一维卷积过程的次数和核长度 $k$ 定义，并且不得依赖于挂钟时间。\n\n设计一个包含四个案例的测试套件，以检验问题的不同方面：\n1. 一个通用案例，使用一个尺寸为 $64 \\times 64$ 的随机图像（确定性种子）和共享相同第一阶段核的掩模：$(\\mathrm{L5}, \\mathrm{E5})$、$(\\mathrm{L5}, \\mathrm{S5})$、$(\\mathrm{L5}, \\mathrm{W5})$。\n2. 一个边界尺寸的图像，尺寸为 $5 \\times 5$，强度恒定，使用掩模 $(\\mathrm{E5}, \\mathrm{L5})$、$(\\mathrm{E5}, \\mathrm{E5})$、$(\\mathrm{E5}, \\mathrm{S5})$、$(\\mathrm{E5}, \\mathrm{R5})$。\n3. 一个尺寸为 $32 \\times 48$ 的各向异性图像，由水平条纹组成，使用掩模 $(\\mathrm{E5}, \\mathrm{L5})$、$(\\mathrm{E5}, \\mathrm{E5})$、$(\\mathrm{E5}, \\mathrm{S5})$、$(\\mathrm{S5}, \\mathrm{E5})$。\n4. 一个尺寸为 $5 \\times 7$ 的小图像，具有简单梯度，使用掩模 $(\\mathrm{L5}, \\mathrm{L5})$、$(\\mathrm{L5}, \\mathrm{E5})$、$(\\mathrm{L5}, \\mathrm{S5})$、$(\\mathrm{L5}, \\mathrm{R5})$、$(\\mathrm{L5}, \\mathrm{W5})$。\n\n对于每个测试用例，您的程序必须：\n- 使用基线方法和缓存方法计算纹理能量，并验证它们在合理的容差范围内数值相等。\n- 使用成本模型和该测试用例的特定掩模集，计算并返回缓存方法相对于基线方法的理论加速因子。\n\n您的程序应生成单行输出，其中包含四个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表（例如，$s_i$），其中每个 $s_i$ 是作为浮点数的加速因子）。不涉及物理单位。不使用角度。不得出现百分比；所有量均以纯小数表示。最终输出行必须严格符合指定格式。",
            "solution": "该问题定义明确，具有科学依据，并且可通过计算验证。它探讨了一种标准优化技术——可分离卷积中中间结果的缓存——并将其应用于 Laws 纹理能量测度这一成熟领域。该问题提供了所有必要的定义、常数和清晰的成本模型，以便进行形式化的推导和实现。\n\n### 1. 可分离卷积原理\n\n一个尺寸为 $m \\times n$ 的二维（2D）滤波器核 $K$ 被称为可分离的，如果它可以表示为两个一维（1D）向量的外积，即一个尺寸为 $m \\times 1$ 的列向量 $a$ 和一个尺寸为 $1 \\times n$ 的行向量 $b$。\n$$K = a \\cdot b^T$$\n由于卷积的结合律，图像 $I$ 与可分离核 $K$ 的卷积（表示为 $I * K$）可以分解为两次连续的一维卷积：\n$$I * K = I * (a \\cdot b^T) = (I * a) * b^T$$\n在这里，$I * a$ 表示图像 $I$ 与垂直核 $a$ 的卷积（应用于每一列），而 $(...) * b^T$ 表示将得到的中间图像与水平核 $b$ 进行卷积（应用于每一行）。这个顺序可以交换。对于本问题，我们将第一遍定义为水平卷积，第二遍定义为垂直卷积。给定一个由核 $k_1$ 和 $k_2$ 的外积形成的二维掩模，滤波后的图像 $I_{\\text{filtered}}$ 计算如下：\n$$I_{\\text{intermediate}} = I * k_1^T \\quad (\\text{沿每行的一维卷积})$$\n$$I_{\\text{filtered}} = I_{\\text{intermediate}} * k_2 \\quad (\\text{沿每列的一维卷积})$$\n\n### 2. 计算成本模型与加速推导\n\n问题为单个一维卷积过程指定了一个成本模型。对于一个尺寸为 $N_{\\text{in}}$ 的输入和一个长度为 $k$ 的核，生成一个尺寸为 $N_{\\text{out}}$ 的输出，其中每个输出元素需要 $k$ 次乘法和 $k-1$ 次加法，总操作数为 $N_{\\text{out}} \\times (k + (k-1)) = N_{\\text{out}} \\times (2k-1)$。\n\n设图像尺寸为 $H \\times W$。边界处理模式为对称反射，因此输出尺寸保持为 $H \\times W$。\n\n- **水平一维卷积过程的成本（$C_{\\text{horiz}}$）：** 此操作应用于 $H$ 行。每行卷积产生 $W$ 个输出元素。\n$$C_{\\text{horiz}} = H \\times W \\times (2k - 1)$$\n- **垂直一维卷积过程的成本（$C_{\\text{vert}}$）：** 此操作应用于中间图像的 $W$ 列。每列卷积产生 $H$ 个输出元素。\n$$C_{\\text{vert}} = W \\times H \\times (2k - 1)$$\n成本是相同的：$C_{\\text{horiz}} = C_{\\text{vert}}$。使用可分离卷积生成一个滤波图像的总成本为 $C_{\\text{2D}} = C_{\\text{horiz}} + C_{\\text{vert}} = 2HW(2k-1)$。\n\n现在我们分析一组 $N$ 个掩模 $\\{(k_{1,i}, k_{2,i})\\}_{i=1}^N$ 的成本。设 $U$ 为这组掩模中唯一的第一阶段（水平）核的数量。所有核的长度均为 $k=5$。\n\n**基线方法成本（$Cost_{\\text{baseline}}$）：**\n基线方法为 $N$ 个掩模中的每一个重新计算水平和垂直过程。\n$$Cost_{\\text{baseline}} = \\sum_{i=1}^{N} (C_{\\text{horiz}} + C_{\\text{vert}}) = N \\times (C_{\\text{horiz}} + C_{\\text{vert}})$$\n$$Cost_{\\text{baseline}} = N \\times [HW(2k-1) + HW(2k-1)] = 2N \\cdot HW(2k-1)$$\n\n**缓存方法成本（$Cost_{\\text{cached}}$）：**\n缓存方法对每个唯一的水平核只计算一次水平过程。有 $U$ 个这样的唯一核。之后，它为总共 $N$ 个掩模中的每一个执行一次垂直过程。\n- 所有唯一水平过程的成本：$U \\times C_{\\text{horiz}} = U \\cdot HW(2k-1)$。\n- 所有垂直过程的成本：$N \\times C_{\\text{vert}} = N \\cdot HW(2k-1)$。\n$$Cost_{\\text{cached}} = (U \\cdot C_{\\text{horiz}}) + (N \\cdot C_{\\text{vert}}) = (U+N) \\cdot HW(2k-1)$$\n\n**理论加速因子（$S$）：**\n加速是基线成本与缓存成本的比率。\n$$S = \\frac{Cost_{\\text{baseline}}}{Cost_{\\text{cached}}} = \\frac{2N \\cdot HW(2k-1)}{(U+N) \\cdot HW(2k-1)}$$\n项 $HW(2k-1)$ 会被消去，从而得到一个仅依赖于掩模数量和唯一第一阶段核数量的通用加速公式：\n$$S = \\frac{2N}{U+N}$$\n\n### 3. 在测试用例上的应用\n\n提供的 Laws 核长度均为 $k=5$。加速因子 $S$ 与 $k$、$H$ 和 $W$ 无关。\n\n**案例 1:**\n- 掩模：$(\\mathrm{L5}, \\mathrm{E5})$、$(\\mathrm{L5}, \\mathrm{S5})$、$(\\mathrm{L5}, \\mathrm{W5})$\n- 总掩模数 $N=3$。\n- 唯一的第一阶段核：$\\{\\mathrm{L5}\\}$。因此，$U=1$。\n- 加速 $S_1 = \\frac{2 \\times 3}{1+3} = \\frac{6}{4} = 1.5$。\n\n**案例 2:**\n- 掩模：$(\\mathrm{E5}, \\mathrm{L5})$、$(\\mathrm{E5}, \\mathrm{E5})$、$(\\mathrm{E5}, \\mathrm{S5})$、$(\\mathrm{E5}, \\mathrm{R5})$\n- 总掩模数 $N=4$。\n- 唯一的第一阶段核：$\\{\\mathrm{E5}\\}$。因此，$U=1$。\n- 加速 $S_2 = \\frac{2 \\times 4}{1+4} = \\frac{8}{5} = 1.6$。\n\n**案例 3:**\n- 掩模：$(\\mathrm{E5}, \\mathrm{L5})$、$(\\mathrm{E5}, \\mathrm{E5})$、$(\\mathrm{E5}, \\mathrm{S5})$、$(\\mathrm{S5}, \\mathrm{E5})$\n- 总掩模数 $N=4$。\n- 唯一的第一阶段核：$\\{\\mathrm{E5}, \\mathrm{S5}\\}$。因此，$U=2$。\n- 加速 $S_3 = \\frac{2 \\times 4}{2+4} = \\frac{8}{6} = \\frac{4}{3} \\approx 1.333...$。\n\n**案例 4:**\n- 掩模：$(\\mathrm{L5}, \\mathrm{L5})$、$(\\mathrm{L5}, \\mathrm{E5})$、$(\\mathrm{L5}, \\mathrm{S5})$、$(\\mathrm{L5}, \\mathrm{R5})$、$(\\mathrm{L5}, \\mathrm{W5})$\n- 总掩模数 $N=5$。\n- 唯一的第一阶段核：$\\{\\mathrm{L5}\\}$。因此，$U=1$。\n- 加速 $S_4 = \\frac{2 \\times 5}{1+5} = \\frac{10}{6} = \\frac{5}{3} \\approx 1.666...$。\n\n### 4. 实现策略\n\n实现将包括两个主要函数，`baseline_method` 和 `cached_method`，它们为给定的掩模集和输入图像计算 Laws 纹理能量。\n\n- **卷积：** 使用 `scipy.ndimage.convolve1d` 执行一维卷积。水平过程由 `axis=1` 指定，垂直过程由 `axis=0` 指定。边界条件是 `mode='reflect'`，对应于对称反射，这确保滤波后的图像与输入具有相同的尺寸。\n- **基线方法：** 此方法遍历 $N$ 个掩模的列表。对于每个掩模，它顺序执行一次水平卷积，然后是一次垂直卷积，计算能量并存储它。\n- **缓存方法：** 此方法维护一个字典来存储唯一的水平卷积结果。它遍历 $N$ 个掩模的列表。对于每个掩模，它检查所需水平卷积的结果是否已在缓存中。如果不在，它会计算该结果并存储它。然后，它从缓存中检索（可能是新计算的）中间图像，并执行单次垂直卷积以获得最终的滤波图像。\n- **纹理能量：** 对于每个滤波图像，计算一个标量纹理能量值，即其像素绝对值的全局平均值，即 $E = \\frac{1}{HW} \\sum_{i=1}^{H} \\sum_{j=1}^{W} |I_{\\text{filtered}}(i,j)|$。\n- **验证：** 通过断言其生成的能量列表与基线方法生成的列表在元素上近似相等（使用一个小的容差）来验证缓存实现的数值正确性。\n- **最终结果：** 对于每个测试用例，计算并报告理论上推导出的加速 $S = \\frac{2N}{U+N}$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import convolve1d\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing Laws' texture energy and theoretical speedup.\n    \"\"\"\n    \n    # Define the 5-tap Laws' kernels\n    kernels = {\n        'L5': np.array([1, 4, 6, 4, 1], dtype=np.float64),\n        'E5': np.array([-1, -2, 0, 2, 1], dtype=np.float64),\n        'S5': np.array([-1, 0, 2, 0, -1], dtype=np.float64),\n        'R5': np.array([1, -4, 6, -4, 1], dtype=np.float64),\n        'W5': np.array([-1, 2, 0, -2, 1], dtype=np.float64),\n    }\n\n    # Normalize kernels to have a sum of zero, except for the smoothing kernel L5\n    for name, kernel in kernels.items():\n        if name != 'L5':\n            kernels[name] = kernel - np.mean(kernel)\n    kernels['L5'] = kernels['L5'] / np.sum(kernels['L5'])\n\n\n    def compute_energy(image):\n        \"\"\"Computes a single texture energy value for a filtered image.\"\"\"\n        return np.mean(np.abs(image))\n\n    def baseline_method(image, masks, kernels_map):\n        \"\"\"Computes energies by recomputing both passes for each mask.\"\"\"\n        energies = []\n        for k1_name, k2_name in masks:\n            k1 = kernels_map[k1_name]\n            k2 = kernels_map[k2_name]\n            \n            # Horizontal pass (on each row)\n            intermediate = convolve1d(image, k1, axis=1, mode='reflect')\n            \n            # Vertical pass (on each column)\n            filtered = convolve1d(intermediate, k2, axis=0, mode='reflect')\n            \n            energies.append(compute_energy(filtered))\n        return energies\n\n    def cached_method(image, masks, kernels_map):\n        \"\"\"Computes energies by caching results of the horizontal pass.\"\"\"\n        energies = []\n        intermediate_cache = {}\n        \n        for k1_name, k2_name in masks:\n            # Horizontal pass (with caching)\n            if k1_name not in intermediate_cache:\n                k1 = kernels_map[k1_name]\n                intermediate_cache[k1_name] = convolve1d(image, k1, axis=1, mode='reflect')\n            \n            intermediate = intermediate_cache[k1_name]\n            \n            # Vertical pass\n            k2 = kernels_map[k2_name]\n            filtered = convolve1d(intermediate, k2, axis=0, mode='reflect')\n            \n            energies.append(compute_energy(filtered))\n        return energies\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"image_gen\": lambda: np.random.default_rng(seed=42).random((64, 64)),\n            \"masks\": [('L5', 'E5'), ('L5', 'S5'), ('L5', 'W5')]\n        },\n        {\n            \"image_gen\": lambda: np.full((5, 5), 100.0, dtype=np.float64),\n            \"masks\": [('E5', 'L5'), ('E5', 'E5'), ('E5', 'S5'), ('E5', 'R5')]\n        },\n        {\n            \"image_gen\": lambda: (np.arange(32)[:, np.newaxis] % 2).astype(np.float64) * np.ones((32, 48)),\n            \"masks\": [('E5', 'L5'), ('E5', 'E5'), ('E5', 'S5'), ('S5', 'E5')]\n        },\n        {\n            \"image_gen\": lambda: np.arange(5 * 7, dtype=np.float64).reshape((5, 7)),\n            \"masks\": [('L5', 'L5'), ('L5', 'E5'), ('L5', 'S5'), ('L5', 'R5'), ('L5', 'W5')]\n        },\n    ]\n\n    speedup_results = []\n    for case in test_cases:\n        image = case[\"image_gen\"]()\n        masks = case[\"masks\"]\n\n        # Calculate N and U for the theoretical speedup formula\n        N = len(masks)\n        first_stage_kernels = [m[0] for m in masks]\n        U = len(set(first_stage_kernels))\n\n        # Compute the theoretical speedup factor\n        speedup = (2 * N) / (U + N)\n        speedup_results.append(speedup)\n\n        # Verification step: ensure both methods produce the same results\n        baseline_energies = baseline_method(image, masks, kernels)\n        cached_energies = cached_method(image, masks, kernels)\n        np.testing.assert_allclose(baseline_energies, cached_energies, rtol=1e-9, atol=1e-9)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, speedup_results))}]\")\n\nsolve()\n```"
        }
    ]
}