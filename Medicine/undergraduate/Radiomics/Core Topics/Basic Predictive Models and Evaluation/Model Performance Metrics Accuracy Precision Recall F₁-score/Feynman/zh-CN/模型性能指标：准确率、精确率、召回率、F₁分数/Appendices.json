{
    "hands_on_practices": [
        {
            "introduction": "本练习是评估分类器性能的基础。通过一个具体的放射组学场景，您将练习从基本计数（$TP$、$FP$、$FN$、$TN$）出发，重建混淆矩阵并验证其内部一致性。这个实践旨在巩固您对核心性能指标定义的理解，并为计算更复杂的指标（如 $F_1$ 分数）打下坚实的基础。",
            "id": "4551752",
            "problem": "在一个影像组学流程中，一个二元分类器被训练用于从医学影像中提取的手工设计的特征向量来识别恶性肿瘤。数据集包含 $N$ 名患者，其中 $M$ 名为恶性肿瘤患者。根据研究设计，数据集有 $N = 500$ 且 $M = 80$。训练好的模型在该数据集上进行评估，得出以下计数结果：真阳性 (TP) $ = 60$，假阳性 (FP) $ = 10$，假阴性 (FN) $ = 20$ 和 真阴性 (TN) $ = 410$。仅使用混淆矩阵、准确率（Accuracy）、精确率（Precision）、召回率（Recall）和 $F_1$分数（$F_1$）的核心定义，完成以下任务：\n\n1. 根据基本原理，将这四种计数解释为真实标签和模型预测之间的联合事件，并通过检查实际类别和预测类别的总和来重构混淆矩阵。\n2. 从类别流行率 $\\pi$（定义为数据集中恶性病例的比例）的定义出发，通过证明从给定的 $TP$、$FP$、$FN$ 和 $TN$ 计算出的流行率与从 $(M,N)$ 得知的流行率相匹配，来验证内部一致性。\n3. 仅使用基于精确率和召回率的定义，推导恶性类别的 $F_1$分数 ($F_1$)，并根据给定的计数计算其数值。\n\n将恶性类别 $F_1$分数的数值作为最终答案报告，以小数形式表示并四舍五入到四位有效数字。答案中不允许使用百分号。",
            "solution": "该问题要求在影像组学背景下，基于混淆矩阵提供的计数，对一个二元分类器的性能进行三部分分析。该分析涉及重构混淆矩阵、验证所提供数据的一致性以及推导 $F_1$分数。\n\n**第一部分：混淆矩阵的解释与重构**\n二元分类模型的基本结果根据真实标签（实际类别）与模型预测（预测类别）之间的比较，分为四种类型。在此背景下，“阳性”类别对应于恶性肿瘤。\n\n这四种计数解释如下：\n-   **真阳性 ($TP$)**：实际为恶性并被正确预测为恶性的病例数。给定值为 $TP = 60$。\n-   **假阳性 ($FP$)**：实际为非恶性但被错误预测为恶性的病例数。这也被称为第一类错误。给定值为 $FP = 10$。\n-   **假阴性 ($FN$)**：实际为恶性但被错误预测为非恶性的病例数。这也被称为第二类错误。给定值为 $FN = 20$。\n-   **真阴性 ($TN$)**：实际为非恶性并被正确预测为非恶性的病例数。给定值为 $TN = 410$。\n\n这些计数可以排列成一个 $2 \\times 2$ 的混淆矩阵，其中行通常代表实际类别，列代表预测类别。\n\n| | 预测为恶性 | 预测为非恶性 | 总计（实际） |\n|---|---|---|---|\n| **实际为恶性** | $TP = 60$ | $FN = 20$ | $P = 80$ |\n| **实际为非恶性**| $FP = 10$ | $TN = 410$ | $N_{neg} = 420$ |\n| **总计（预测）** | $P' = 70$ | $N'_{neg} = 430$ | $N = 500$ |\n\n我们检查各项总和，以确保与所提供的数据集参数保持内部一致性。\n-   实际恶性病例的总数是真阳性和假阴性的总和：\n    $$P_{actual} = TP + FN = 60 + 20 = 80$$\n    这与给定的恶性肿瘤患者数量 $M = 80$ 相符。\n-   实际非恶性病例的总数是假阳性和真阴性的总和：\n    $$N_{actual} = FP + TN = 10 + 410 = 420$$\n-   数据集中患者的总数是所有结果的总和：\n    $$N = TP + FP + FN + TN = 60 + 10 + 20 + 410 = 500$$\n    这与给定的患者总数 $N = 500$ 相符。\n沿行的总和以及总计均与问题陈述一致。\n\n**第二部分：流行率一致性的验证**\n类别流行率，用 $\\pi$ 表示，是整个数据集中阳性（恶性）病例的比例。可以使用所提供的信息通过两种方法计算。\n\n首先，使用研究设计参数 $M$ 和 $N$：\n流行率是恶性病例数与患者总数的比率。\n$$\\pi_{design} = \\frac{M}{N} = \\frac{80}{500} = \\frac{8}{50} = \\frac{4}{25} = 0.16$$\n\n其次，使用混淆矩阵的计数：\n流行率是所有实际阳性病例 ($TP + FN$) 与病例总数 ($TP + FP + FN + TN$) 的比率。\n$$\\pi_{counts} = \\frac{TP + FN}{TP + FP + FN + TN} = \\frac{60 + 20}{60 + 10 + 20 + 410} = \\frac{80}{500} = \\frac{4}{25} = 0.16$$\n\n由于 $\\pi_{design} = \\pi_{counts} = 0.16$，因此混淆矩阵的计数与指定的数据集构成完全一致。\n\n**第三部分：$F_1$分数的推导与计算**\n$F_1$分数定义为精确率和召回率的调和平均数。我们首先为恶性（阳性）类别定义这两个指标。\n\n-   **精确率 ($P$)**：在所有被预测为阳性的病例中，被正确识别为阳性的病例所占的比例。它从假阳性的角度衡量分类器的性能。\n    $$Precision = \\frac{TP}{TP + FP}$$\n-   **召回率 ($R$)**：在所有实际为阳性的病例中，被正确识别为阳性的病例所占的比例。它也被称为灵敏度或真阳性率，它从假阴性的角度衡量分类器的性能。\n    $$Recall = \\frac{TP}{TP + FN}$$\n\n$F_1$分数由以下公式给出：\n$$F_1 = 2 \\cdot \\frac{Precision \\cdot Recall}{Precision + Recall}$$\n将精确率和召回率用混淆矩阵计数的定义代入：\n$$F_1 = 2 \\cdot \\frac{\\left(\\frac{TP}{TP + FP}\\right) \\cdot \\left(\\frac{TP}{TP + FN}\\right)}{\\left(\\frac{TP}{TP + FP}\\right) + \\left(\\frac{TP}{TP + FN}\\right)}$$\n为简化起见，我们为主分式分母中的和式通分：\n$$F_1 = 2 \\cdot \\frac{\\frac{TP^2}{(TP + FP)(TP + FN)}}{\\frac{TP(TP + FN) + TP(TP + FP)}{(TP + FP)(TP + FN)}}$$\n从分子和分母中消去项 $(TP + FP)(TP + FN)$：\n$$F_1 = 2 \\cdot \\frac{TP^2}{TP(TP + FN) + TP(TP + FP)}$$\n从分母中提取公因式 $TP$：\n$$F_1 = 2 \\cdot \\frac{TP^2}{TP((TP + FN) + (TP + FP))}$$\n假设 $TP \\neq 0$，我们可以消去 $TP$：\n$$F_1 = \\frac{2 \\cdot TP}{(TP + FN) + (TP + FP)} = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN}$$\n这个最终表达式允许直接从基本计数计算 $F_1$分数。\n\n现在，我们代入给定的数值：$TP = 60$，$FP = 10$ 和 $FN = 20$。\n$$F_1 = \\frac{2 \\cdot 60}{2 \\cdot 60 + 10 + 20} = \\frac{120}{120 + 10 + 20} = \\frac{120}{150}$$\n化简分数：\n$$F_1 = \\frac{12}{15} = \\frac{4}{5} = 0.8$$\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。确切值为 $0.8$。为了用四位有效数字表示，我们将其写作 $0.8000$。",
            "answer": "$$\\boxed{0.8000}$$"
        },
        {
            "introduction": "模型性能并非一成不变，它会受到测试人群特征的显著影响，尤其是疾病患病率。本练习通过一个从病例对照研究到人群筛查的场景转换，引导您运用贝叶斯定理推导并计算阳性预测值（PPV）和阴性预测值（NPV）。这个实践将揭示患病率变化如何影响模型的实际应用价值，是理解和评估诊断测试性能的关键一步。",
            "id": "4551711",
            "problem": "一种基于胸部计算机断层扫描（CT）图像的纹理和形状特征衍生的放射组学分类器被用于评估其在检测早期肺部恶性肿瘤方面的性能。在一项病例-对照发展研究中，该分类器的灵敏度为 $0.85$，特异性为 $0.95$，研究中的患病率为 $0.10$。预期的部署环境是一个人群筛查项目，其目标患病率为 $0.02$。\n\n请仅使用基础的概率定义和经过充分检验的原理，即贝叶斯定理和全概率定律，从灵敏度 $P(T^{+}\\,|\\,D)$、特异性 $P(T^{-}\\,|\\,\\bar{D})$ 和患病率 $P(D)$ 的定义出发，其中 $D$ 表示事件“存在恶性肿瘤”，$\\bar{D}$ 是其补集，而 $T^{+}$/$T^{-}$表示分类器的阳性/阴性输出。以此为基础，推导阳性预测值（PPV；也称为精确率）$P(D\\,|\\,T^{+})$ 和阴性预测值（NPV）$P(\\bar{D}\\,|\\,T^{-})$ 作为灵敏度、特异性和患病率的函数表达式。计算在研究患病率 $0.10$ 和目标患病率 $0.02$ 下的PPV和NPV的数值，所有概率均以小数表示。\n\n最后，以四位有效数字的形式报告比率\n$$\n\\rho \\;=\\; \\frac{\\text{目标患病率下的PPV}}{\\text{研究患病率下的PPV}},\n$$\n作为你唯一的数值答案。无需单位。在你的推导过程中，简要解释在将放射组学模型从病例-对照研究部署到筛查人群的背景下，患病率的变化对PPV（精确率）、NPV、召回率（灵敏度）和$F_1$分数的影响。",
            "solution": "该问题具有科学依据，提法明确且客观。所有必要数据均已提供，任务是基于概率论的基本原理，对不同患病率下诊断测试的性能进行标准分析。我们开始进行推导和求解。\n\n设 $D$ 为存在恶性肿瘤的事件，$\\bar{D}$ 为其补集（不存在恶性肿瘤）。设 $T^{+}$ 和 $T^{-}$ 分别为分类器结果为阳性和阴性的事件。给定的量如下：\n- 灵敏度（$S_e$）：在患病条件下测试结果为阳性的概率，$S_e = P(T^{+}|D) = 0.85$。\n- 特异性（$S_p$）：在未患病条件下测试结果为阴性的概率，$S_p = P(T^{-}|\\bar{D}) = 0.95$。\n- 患病率（$p$）：患病的先验概率，$p = P(D)$。我们被给予两个值：$p_{study} = 0.10$ 和 $p_{target} = 0.02$。\n\n我们的目标是推导阳性预测值（PPV 或精确率）$P(D|T^{+})$ 和阴性预测值（NPV）$P(\\bar{D}|T^{-})$ 的表达式，然后计算它们在两种给定患病率下的值。\n\n首先，我们推导 PPV 的表达式 $P(D|T^{+})$。使用贝叶斯定理：\n$$P(D|T^{+}) = \\frac{P(T^{+}|D) P(D)}{P(T^{+})}$$\n分子包含灵敏度 $P(T^{+}|D) = S_e$ 和患病率 $P(D) = p$。分母 $P(T^{+})$ 是测试结果为阳性的总概率。我们使用全概率定律将其展开：\n$$P(T^{+}) = P(T^{+}|D)P(D) + P(T^{+}|\\bar{D})P(\\bar{D})$$\n我们可以使用给定的定义来表示此展开式中的各项：\n- $P(T^{+}|D) = S_e$\n- $P(D) = p$\n- $P(\\bar{D}) = 1 - P(D) = 1 - p$\n- $P(T^{+}|\\bar{D})$ 是假阳性率，即 $1 - P(T^{-}|\\bar{D}) = 1 - S_p$。\n\n将这些代入 $P(T^{+})$ 的展开式中：\n$$P(T^{+}) = S_e \\cdot p + (1 - S_p)(1 - p)$$\n现在，将此结果代回贝叶斯定理中 PPV 的表达式，得到其作为 $S_e$、$S_p$ 和 $p$ 的函数的一般形式：\n$$\\text{PPV} = P(D|T^{+}) = \\frac{S_e \\cdot p}{S_e \\cdot p + (1 - S_p)(1 - p)}$$\n\n接下来，我们推导 NPV 的表达式 $P(\\bar{D}|T^{-})$。同样，根据贝叶斯定理：\n$$P(\\bar{D}|T^{-}) = \\frac{P(T^{-}|\\bar{D}) P(\\bar{D})}{P(T^{-})}$$\n分子包含特异性 $P(T^{-}|\\bar{D}) = S_p$ 和未患病的概率 $P(\\bar{D}) = 1 - p$。分母 $P(T^{-})$ 是测试结果为阴性的总概率，使用全概率定律展开：\n$$P(T^{-}) = P(T^{-}|D)P(D) + P(T^{-}|\\bar{D})P(\\bar{D})$$\n我们确定各项：\n- $P(T^{-}|D)$ 是假阴性率，即 $1 - P(T^{+}|D) = 1 - S_e$。\n- $P(D) = p$\n- $P(T^{-}|\\bar{D}) = S_p$\n- $P(\\bar{D}) = 1 - p$\n\n将这些代入 $P(T^{-})$ 的展开式中：\n$$P(T^{-}) = (1 - S_e) \\cdot p + S_p(1 - p)$$\n并将此结果代回 NPV 的表达式中：\n$$\\text{NPV} = P(\\bar{D}|T^{-}) = \\frac{S_p (1 - p)}{(1 - S_e) \\cdot p + S_p(1 - p)}$$\n\n现在，我们计算两种情况下的数值。\n给定值为 $S_e = 0.85$ 和 $S_p = 0.95$。\n\n情况1：研究患病率，$p_{study} = 0.10$。\n$$\\text{PPV}_{study} = \\frac{0.85 \\cdot 0.10}{0.85 \\cdot 0.10 + (1 - 0.95)(1 - 0.10)} = \\frac{0.085}{0.085 + (0.05)(0.90)} = \\frac{0.085}{0.085 + 0.045} = \\frac{0.085}{0.130} = \\frac{17}{26} \\approx 0.6538$$\n$$\\text{NPV}_{study} = \\frac{0.95 \\cdot (1 - 0.10)}{(1 - 0.85) \\cdot 0.10 + 0.95 \\cdot (1 - 0.10)} = \\frac{0.95 \\cdot 0.90}{0.15 \\cdot 0.10 + 0.95 \\cdot 0.90} = \\frac{0.855}{0.015 + 0.855} = \\frac{0.855}{0.870} = \\frac{57}{58} \\approx 0.9828$$\n\n情况2：目标筛查患病率，$p_{target} = 0.02$。\n$$\\text{PPV}_{target} = \\frac{0.85 \\cdot 0.02}{0.85 \\cdot 0.02 + (1 - 0.95)(1 - 0.02)} = \\frac{0.017}{0.017 + (0.05)(0.98)} = \\frac{0.017}{0.017 + 0.049} = \\frac{0.017}{0.066} = \\frac{17}{66} \\approx 0.2576$$\n$$\\text{NPV}_{target} = \\frac{0.95 \\cdot (1 - 0.02)}{(1 - 0.85) \\cdot 0.02 + 0.95 \\cdot (1 - 0.02)} = \\frac{0.95 \\cdot 0.98}{0.15 \\cdot 0.02 + 0.95 \\cdot 0.98} = \\frac{0.931}{0.003 + 0.931} = \\frac{0.931}{0.934} \\approx 0.9968$$\n\n患病率从病例-对照研究环境（$p=0.10$）转变为人群筛查环境（$p=0.02$），这对分类器的性能指标产生了深远的影响：\n- **PPV（精确率）**：PPV 从约 $0.65$ 急剧下降到约 $0.26$。这是一个关键的观察结果。在低患病率环境中，阳性测试结果更有可能是假阳性。其临床意义是，大多数被分类器标记为阳性的个体实际上并未患病，这会导致不必要的后续检查、成本和患者焦虑。这种高假阳性负担是筛查项目的一个决定性挑战。\n- **NPV**：NPV 从约 $0.983$ 轻微增加到约 $0.997$。在低患病率环境中，阴性结果在排除疾病方面变得更加可靠。这是因为未患病的先验概率本身已经非常高。\n- **召回率（灵敏度）**：召回率定义为 $P(T^{+}|D)$，是分类器的一个内在属性，关系到其在疾病存在时检测到疾病的能力。它以真实状态 $D$ 为条件，因此与人群中的疾病患病率 $p$ 无关。它保持恒定在 $0.85$。\n- **$F_1$分数**：$F_1$分数是精确率（PPV）和召回率的调和平均数：$F_1 = 2 \\cdot \\frac{\\text{精确率} \\cdot \\text{召回率}}{\\text{精确率} + \\text{召回率}}$。由于召回率是恒定的，而精确率高度依赖于患病率，因此$F_1$分数也高度依赖于患病率。精确率的急剧下降导致$F_1$分数同样急剧下降，这表明当分类器转移到筛查环境时，其性能的整体平衡性出现了显著退化。\n\n最后，我们计算所需的比率 $\\rho$：\n$$\\rho \\;=\\; \\frac{\\text{目标患病率下的PPV}}{\\text{研究患病率下的PPV}} = \\frac{\\text{PPV}_{target}}{\\text{PPV}_{study}} = \\frac{17/66}{17/26} = \\frac{17}{66} \\cdot \\frac{26}{17} = \\frac{26}{66} = \\frac{13}{33}$$\n作为小数，$\\rho \\approx 0.393939...$。四舍五入到四位有效数字得到 $0.3939$。",
            "answer": "$$\n\\boxed{0.3939}\n$$"
        },
        {
            "introduction": "理论指标最终需要转化为实际决策。本练习模拟了一个真实的临床决策场景：您需要为一个概率分类器选择最佳决策阈值 $\\tau$，以在满足临床最低召回率和接诊能力限制的同时，最大化模型的精确率。这个动手编码实践旨在培养您在多重约束下进行优化决策的能力，将模型性能评估与实际工作流程相结合。",
            "id": "4551721",
            "problem": "您面临一个来自放射组学的二元分类场景，其中一个概率分类器为每个病例分配一个在闭区间 $[0,1]$ 内的恶性肿瘤评分。每周，诊所最多能执行 $C$ 次随访操作，并且每个被预测为阳性的病例都会触发一次随访。每周的放射科医生团队要求一个最低灵敏度水平，表示为最低召回率要求 $r_{\\min} \\in [0,1]$，以确保足够比例的实际恶性病例被标记进行随访。您的任务是选择一个单一决策阈值 $\\tau \\in [0,1]$，当且仅当一个病例的评分至少为 $\\tau$ 时，该病例被预测为阳性。\n\n您的程序必须确定一个能最大化精确率（precision）的 $\\tau$，同时满足每周随访能力和最低召回率的要求。形式上，对于每个候选阈值 $\\tau$，根据标准定义计算混淆矩阵的各项：真阳性 (TP)、假阳性 (FP)、真阴性 (TN) 和假阴性 (FN)。设 $N$ 为病例总数，$P$ 为实际阳性病例总数。性能指标定义如下，均以小数表示：\n- 准确率 (Accuracy)：$\\mathrm{Acc} = \\dfrac{\\mathrm{TP} + \\mathrm{TN}}{N}$。\n- 精确率 (Precision)：$\\mathrm{Prec} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$，约定当 $\\mathrm{TP} + \\mathrm{FP} = 0$ 时，$\\mathrm{Prec} = 0$。\n- 召回率 (Recall)：$\\mathrm{Rec} = \\dfrac{\\mathrm{TP}}{P}$，约定当 $P = 0$ 时，$\\mathrm{Rec} = 0$。\n- $F_1$ 分数 ($F_1$-score)：$\\mathrm{F}_1 = \\dfrac{2 \\cdot \\mathrm{Prec} \\cdot \\mathrm{Rec}}{\\mathrm{Prec} + \\mathrm{Rec}}$，约定当 $\\mathrm{Prec} + \\mathrm{Rec} = 0$ 时，$\\mathrm{F}_1 = 0$。\n\n一个阈值 $\\tau$ 是可行的，当且仅当同时满足以下两个条件：\n- 预测为阳性的病例数最多为每周能力上限 $C$，即 $\\mathrm{TP} + \\mathrm{FP} \\le C$。\n- 召回率满足最低要求，即 $\\mathrm{Rec} \\ge r_{\\min}$。\n\n在所有可行的阈值中，选择使 $\\mathrm{Prec}$ 最大化的那一个。如果精确率出现平局，则选择具有最高 $F_1$ 分数的阈值来打破平局。如果仍然存在平局，则选择最大的阈值 $\\tau$。如果没有阈值能同时满足两个可行性条件，则返回 $\\tau = -1$ 并将所有四个指标设为 $0$。\n\n使用以下测试套件。在所有案例中，一个病例被预测为阳性当且仅当其得分至少为 $\\tau$。所有数值答案必须以小数（而非百分比）表示。您的程序必须仅在每个数据集中观察到的唯一分数值集合上评估阈值。\n\n测试套件：\n- 案例 1：每周能力上限 $C = 20$，最低召回率 $r_{\\min} = 0.7$。$N = 30$ 个放射组学病例的评分和标签（每对为 $(\\text{评分}, \\text{标签})$）：\n  $\\{(0.95,1),(0.92,1),(0.90,1),(0.88,0),(0.86,1),(0.84,1),(0.82,0),(0.80,1),(0.78,0),(0.76,1),(0.74,1),(0.72,0),(0.70,1),(0.68,0),(0.66,1),(0.64,0),(0.62,0),(0.60,1),(0.58,0),(0.56,0),(0.54,1),(0.52,0),(0.50,0),(0.48,1),(0.46,0),(0.44,0),(0.42,0),(0.40,1),(0.38,0),(0.36,0)\\}$。\n- 案例 2：每周能力上限 $C = 5$，最低召回率 $r_{\\min} = 0.9$。$N = 20$ 个放射组学病例的评分和标签：\n  $\\{(0.99,1),(0.95,1),(0.93,1),(0.85,1),(0.80,1),(0.70,1),(0.60,0),(0.58,0),(0.55,0),(0.52,0),(0.50,0),(0.48,0),(0.46,0),(0.44,0),(0.42,0),(0.40,0),(0.38,0),(0.36,0),(0.34,0),(0.30,0)\\}$。\n- 案例 3：每周能力上限 $C = 3$，最低召回率 $r_{\\min} = 0.5$。$N = 12$ 个放射组学病例的评分和标签：\n  $\\{(0.96,1),(0.90,0),(0.88,1),(0.85,0),(0.80,1),(0.78,0),(0.60,1),(0.55,0),(0.52,0),(0.50,0),(0.40,0),(0.30,0)\\}$。\n\n最终输出格式：\n- 对于每个案例，输出一个列表 $[\\tau, \\mathrm{Acc}, \\mathrm{Prec}, \\mathrm{Rec}, \\mathrm{F}_1]$，其中每个值都四舍五入到恰好 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为由逗号分隔的列表所组成的列表，并用方括号括起来，例如 $[[\\cdot],[\\cdot],[\\cdot]]$。",
            "solution": "用户提供的问题被评估为有效。这是一个适定（well-posed）的优化问题，基于二元分类模型评估的标准原则。问题陈述是自包含的、客观的且科学上合理的。所有必要的数据、约束和定义都已提供，且没有内部矛盾。\n\n该问题要求为一个在放射组学上下文中使用的概率性二元分类器确定一个最优决策阈值 $\\tau$。目标是在满足两个操作约束条件（每周随访能力上限 $C$ 和表示为召回率（$\\mathrm{Rec}$）值的最低要求灵敏度水平 $r_{\\min}$）的情况下，最大化分类器的精确率（$\\mathrm{Prec}$）。\n\n解决方法论以结构化、分步骤的方式进行。\n\n1.  **问题形式化**\n    该任务是一个约束优化问题。我们必须找到一个阈值 $\\tau \\in [0,1]$ 来解决：\n    $$\n    \\underset{\\tau}{\\text{maximize}} \\quad \\mathrm{Prec}(\\tau)\n    $$\n    约束条件：\n    1.  能力约束：$\\mathrm{TP}(\\tau) + \\mathrm{FP}(\\tau) \\le C$\n    2.  召回率约束：$\\mathrm{Rec}(\\tau) \\ge r_{\\min}$\n\n    在多个阈值产生相同最大精确率的情况下，将执行一个打破平局的层级规则：\n    1.  选择具有最高 $\\mathrm{F}_1$ 分数的阈值。\n    2.  如果仍然存在平局，选择最大的阈值 $\\tau$。\n\n    $\\tau$ 的搜索空间被明确限制在数据集中存在的唯一放射组学评分集合内。\n\n2.  **候选阈值的系统性评估**\n    该方法的核心是在允许的候选阈值集合上进行穷举搜索。对于数据中观察到的每个唯一分数值，我们将其视为一个潜在的阈值 $\\tau$。\n\n    对于每个候选 $\\tau$，我们首先对所有 $N$ 个病例进行分类。如果一个病例的评分大于或等于 $\\tau$，则预测为阳性，否则为阴性。这使我们能够通过将预测结果与真实标签进行比较来构建一个混淆矩阵。该矩阵的元素是：\n    -   $\\mathrm{TP}(\\tau)$: 真阳性 (True Positives)（评分 $\\ge \\tau$ 且真实标签为 $1$）\n    -   $\\mathrm{FP}(\\tau)$: 假阳性 (False Positives)（评分 $\\ge \\tau$ 且真实标签为 $0$）\n    -   $\\mathrm{TN}(\\tau)$: 真阴性 (True Negatives)（评分 $ \\tau$ 且真实标签为 $0$）\n    -   $\\mathrm{FN}(\\tau)$: 假阴性 (False Negatives)（评分 $ \\tau$ 且真实标签为 $1$）\n\n3.  **性能指标计算**\n    使用混淆矩阵的值，我们为每个 $\\tau$ 计算所需的性能指标。设 $P = \\mathrm{TP} + \\mathrm{FN}$ 为数据集中实际阳性病例的总数。\n    -   **准确率 (Accuracy)**：$\\mathrm{Acc} = \\dfrac{\\mathrm{TP} + \\mathrm{TN}}{N}$\n    -   **精确率 (Precision)**：$\\mathrm{Prec} = \\dfrac{\\mathrm{TP}}{\\mathrm{TP} + \\mathrm{FP}}$。根据约定，如果分母 $\\mathrm{TP} + \\mathrm{FP} = 0$，则 $\\mathrm{Prec} = 0$。\n    -   **召回率 (Recall)**：$\\mathrm{Rec} = \\dfrac{\\mathrm{TP}}{P}$。根据约定，如果 $P=0$，则 $\\mathrm{Rec}=0$。\n    -   **$F_1$ 分数 ($F_1$-score)**：$\\mathrm{F}_1 = \\dfrac{2 \\cdot \\mathrm{Prec} \\cdot \\mathrm{Rec}}{\\mathrm{Prec} + \\mathrm{Rec}}$。根据约定，如果分母 $\\mathrm{Prec} + \\mathrm{Rec} = 0$，则 $\\mathrm{F}_1 = 0$。\n\n4.  **可行性分析**\n    每个候选阈值 $\\tau$ 及其相应的指标都将根据给定的两个约束进行可行性测试：\n    -   $\\mathrm{TP}(\\tau) + \\mathrm{FP}(\\tau) \\le C$\n    -   $\\mathrm{Rec}(\\tau) \\ge r_{\\min}$\n\n    一个阈值只有在同时满足这两个条件时才被视为有效解。所有这些可行解都会被收集起来，用于最终的选择步骤。\n\n5.  **最优解选择**\n    如果在评估所有候选阈值后，可行解集合为空，则可以断定不存在满足临床要求的解。在这种情况下，输出为 $\\tau = -1$，并且所有性能指标都设置为 $0$。\n\n    如果存在一个或多个可行解，则通过应用指定的层级标准来确定最优解。实现这一点的一种高效方法是对可行解集合进行排序。每个解由一个包含其指标的元组或结构表示，例如 $(\\mathrm{Prec}, \\mathrm{F}_1, \\tau)$。排序按 $\\mathrm{Prec}$ 的降序、然后按 $\\mathrm{F}_1$ 的降序、最后按 $\\tau$ 的降序进行。根据问题的规则，排序后列表中的第一个元素就是唯一的最优解。\n\n    每个测试案例的最终输出是一个包含最优阈值及其相关指标的列表：$[\\tau, \\mathrm{Acc}, \\mathrm{Prec}, \\mathrm{Rec}, \\mathrm{F}_1]$，其中每个值都按要求进行了数值格式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the threshold optimization problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        (\n            20, 0.7, \n            [\n                (0.95, 1), (0.92, 1), (0.90, 1), (0.88, 0), (0.86, 1), (0.84, 1), \n                (0.82, 0), (0.80, 1), (0.78, 0), (0.76, 1), (0.74, 1), (0.72, 0), \n                (0.70, 1), (0.68, 0), (0.66, 1), (0.64, 0), (0.62, 0), (0.60, 1), \n                (0.58, 0), (0.56, 0), (0.54, 1), (0.52, 0), (0.50, 0), (0.48, 1), \n                (0.46, 0), (0.44, 0), (0.42, 0), (0.40, 1), (0.38, 0), (0.36, 0)\n            ]\n        ),\n        (\n            5, 0.9, \n            [\n                (0.99, 1), (0.95, 1), (0.93, 1), (0.85, 1), (0.80, 1), (0.70, 1), \n                (0.60, 0), (0.58, 0), (0.55, 0), (0.52, 0), (0.50, 0), (0.48, 0), \n                (0.46, 0), (0.44, 0), (0.42, 0), (0.40, 0), (0.38, 0), (0.36, 0), \n                (0.34, 0), (0.30, 0)\n            ]\n        ),\n        (\n            3, 0.5, \n            [\n                (0.96, 1), (0.90, 0), (0.88, 1), (0.85, 0), (0.80, 1), (0.78, 0), \n                (0.60, 1), (0.55, 0), (0.52, 0), (0.50, 0), (0.40, 0), (0.30, 0)\n            ]\n        )\n    ]\n\n    all_results = []\n    for C, r_min, data in test_cases:\n        scores = np.array([d[0] for d in data])\n        labels = np.array([d[1] for d in data])\n        \n        N = len(labels)\n        P = np.sum(labels)\n        \n        # Per problem statement, evaluate only at unique score values.\n        unique_scores = np.unique(scores)\n        \n        feasible_solutions = []\n        \n        for tau in unique_scores:\n            predictions = (scores >= tau).astype(int)\n            TP = np.sum((predictions == 1)  (labels == 1))\n            FP = np.sum((predictions == 1)  (labels == 0))\n            \n            predicted_positives = TP + FP\n\n            if P == 0:\n                rec = 0.0\n            else:\n                rec = TP / P\n\n            # Check feasibility first.\n            is_feasible = (predicted_positives = C) and (rec >= r_min)\n\n            if is_feasible:\n                # Calculate remaining metrics only for feasible thresholds.\n                TN = np.sum((predictions == 0)  (labels == 0))\n                \n                if predicted_positives == 0:\n                    prec = 0.0\n                else:\n                    prec = TP / predicted_positives\n                \n                if (prec + rec) == 0:\n                    f1 = 0.0\n                else:\n                    f1 = 2 * prec * rec / (prec + rec)\n\n                acc = (TP + TN) / N\n                \n                # Store all metrics for this feasible solution.\n                feasible_solutions.append({\n                    'prec': prec, \n                    'f1': f1, \n                    'tau': tau, \n                    'acc': acc, \n                    'rec': rec\n                })\n        \n        if not feasible_solutions:\n            result = [-1.0, 0.0, 0.0, 0.0, 0.0]\n        else:\n            # Sort using a key that implements the hierarchical tie-breaking rules:\n            # 1. Maximize precision (sort by -prec)\n            # 2. Maximize F1-score (sort by -f1)\n            # 3. Maximize threshold tau (sort by -tau)\n            best_solution = sorted(feasible_solutions, key=lambda x: (-x['prec'], -x['f1'], -x['tau']))[0]\n            \n            result = [\n                best_solution['tau'],\n                best_solution['acc'],\n                best_solution['prec'],\n                best_solution['rec'],\n                best_solution['f1']\n            ]\n        \n        # Format the result list into the required string format with 6 decimal places.\n        formatted_result = f\"[{','.join([f'{v:.6f}' for v in result])}]\"\n        all_results.append(formatted_result)\n\n    # Print a single line with all results, as specified.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}