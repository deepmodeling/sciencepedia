{
    "hands_on_practices": [
        {
            "introduction": "在任何重采样流程中，首要任务是确定新的各向同性图像网格的尺寸。这个练习将指导你完成这一基本计算，其核心原则是在转换过程中保持物理视场（Field of View）不变，以避免数据丢失。通过这个实践 ，你将把重采样的抽象概念应用于具体的几何计算中，为后续的插值步骤奠定基础。",
            "id": "4548200",
            "problem": "一个计算机断层扫描（CT）容积被建模为潜在连续强度场 $f(\\mathbf{x})$ 的样本，其中 $\\mathbf{x} \\in \\mathbb{R}^{3}$ 表示空间位置。该容积在具有轴对齐间距 $(s_{x}, s_{y}, s_{z}) = (0.7\\,\\mathrm{mm}, 0.7\\,\\mathrm{mm}, 5.0\\,\\mathrm{mm})$ 和整数维度 $N_{x} \\times N_{y} \\times N_{z} = 512 \\times 512 \\times 100$ 的直角网格上采集。在放射组学预处理中，各向同性体素转换旨在获得一个在所有轴上具有相等间距的网格，并且该网格能够无损地覆盖相同的物理视场（FOV）。\n\n从沿轴 $i \\in \\{x,y,z\\}$ 的物理范围为 $L_{i} = N_{i} s_{i}$ 的基本采样关系出发，并遵循重采样应在保持FOV的同时避免混叠的原则，为实现 $1.0\\,\\mathrm{mm}$ 的各向同性间距，制定一个数学上精确的转换目标。您的目标必须包括：(i) 对目标间距的各向同性约束，(ii) 对重采样后网格范围的覆盖约束，以及 (iii) 一个在连续域上定义的、使用标准 $L^{2}$ 准则来量化插值引起的偏差的保真度项。\n\n然后，计算在重采样至 $1.0\\,\\mathrm{mm}$ 各向同性间距时满足您的覆盖约束的新整数网格维度，并计算重采样后网格的采样密度（单位体积内的体素数量）。\n\n以体素/立方毫米为单位表示最终的采样密度。您必须报告三个整数维度和采样密度。请勿在最终答案框中包含单位。本问题不要求四舍五入到指定数量的有效数字；在适用时报告精确整数。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、适定且客观的。它提出了医学图像处理（放射组学）中的一个标准任务，为得到唯一且有意义的解提供了所有必要的数据和约束。该问题没有任何使其无效的缺陷。\n\n任务有两部分：首先，为各向同性体素转换制定一个数学目标；其次，应用此公式计算特定CT容积的新网格维度和由此产生的采样密度。\n\n首先，我们制定转换目标。设原始CT容积由直角网格上的一组离散样本表示。该网格具有轴对齐间距 $(s_x, s_y, s_z)$ 和整数维度 $(N_x, N_y, N_z)$。这些样本取自一个潜在的连续强度场 $f(\\mathbf{x})$，其中 $\\mathbf{x} \\in \\mathbb{R}^3$。重采样过程旨在生成目标网格上的一组新样本，该目标网格具有各向同性间距 $(s'_x, s'_y, s'_z)$ 和新的整数维度 $(N'_x, N'_y, N'_z)$。转换目标基于三个原则：各向同性、覆盖范围和保真度。\n\n设 $s_{iso}$ 为期望的各向同性间距。设 $\\hat{f}(\\mathbf{x})$ 是通过某种插值方法从原始离散样本重建的连续场。目标是找到重采样网格参数和重建函数，以在满足几何约束的同时最小化插值误差。综合目标是：\n$$\n\\min_{N'_x, N'_y, N'_z, \\hat{f}} \\mathcal{E}\n$$\n受各向同性和覆盖约束，其中各组成部分定义如下：\n\n(i) 各向同性约束：此约束强制重采样后网格中的体素间距在所有维度上相等。目标各向同性间距给定为 $s_{iso} = 1.0\\,\\mathrm{mm}$。该约束表示为：\n$$\ns'_{x} = s'_{y} = s'_{z} = s_{iso}\n$$\n\n(ii) 覆盖约束：此约束确保原始扫描的物理体积或视场（FOV）被重采样后的网格完全包围，以防止边界处的数据丢失。沿轴 $i \\in \\{x, y, z\\}$ 的物理范围（FOV）由体素数量和体素间距的乘积给出，$L_i = N_i s_i$。对于重采样后的网格，其范围为 $L'_i = N'_i s'_i$。覆盖约束要求每个轴都满足 $L'_i \\ge L_i$。由于新维度 $N'_i$ 必须是整数，对于给定的目标间距 $s'_i$，此约束最紧凑的形式是选择满足不等式的最小整数 $N'_i$：\n$$\nN'_i \\ge \\frac{N_i s_i}{s'_i} \\implies N'_i = \\left\\lceil \\frac{N_i s_i}{s'_i} \\right\\rceil\n$$\n\n(iii) 保真度项：该项量化了重采样图像与真实潜在信号之间的偏差，这种偏差源于从离散样本重建连续函数的内在局限性。问题指定了一个 $L^2$ 准则。保真度误差 $\\mathcal{E}$ 是真实连续场 $f(\\mathbf{x})$ 与重建场 $\\hat{f}(\\mathbf{x})$ 在原始图像空间域 $\\Omega = [0, L_x] \\times [0, L_y] \\times [0, L_z]$ 上的积分平方差：\n$$\n\\mathcal{E} = \\int_{\\Omega} |f(\\mathbf{x}) - \\hat{f}(\\mathbf{x})|^2 \\, d\\mathbf{x}\n$$\n最小化该项对应于为给定的原始样本集和插值策略（例如，线性、三次样条等）找到最优的插值函数 $\\hat{f}$。\n\n现在，我们根据所提供的数据计算新的整数网格维度和采样密度。\n给定的原始参数是：\n- 间距：$(s_x, s_y, s_z) = (0.7\\,\\mathrm{mm}, 0.7\\,\\mathrm{mm}, 5.0\\,\\mathrm{mm})$\n- 维度：$(N_x, N_y, N_z) = (512, 512, 100)$\n目标各向同性间距为 $s_{iso} = 1.0\\,\\mathrm{mm}$，因此 $s'_x = s'_y = s'_z = 1.0\\,\\mathrm{mm}$。\n\n首先，我们计算原始CT容积每个轴的物理视场（FOV）：\n- $L_x = N_x s_x = 512 \\times 0.7\\,\\mathrm{mm} = 358.4\\,\\mathrm{mm}$\n- $L_y = N_y s_y = 512 \\times 0.7\\,\\mathrm{mm} = 358.4\\,\\mathrm{mm}$\n- $L_z = N_z s_z = 100 \\times 5.0\\,\\mathrm{mm} = 500.0\\,\\mathrm{mm}$\n\n接下来，我们应用覆盖约束来确定新的整数维度 $(N'_x, N'_y, N'_z)$。新维度必须足够大，以便用 $1.0\\,\\mathrm{mm}$ 的新间距覆盖原始FOV。我们使用向上取整函数（ceiling function）来确保完全覆盖。\n- $N'_x = \\left\\lceil \\frac{L_x}{s'_x} \\right\\rceil = \\left\\lceil \\frac{358.4\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 358.4 \\rceil = 359$\n- $N'_y = \\left\\lceil \\frac{L_y}{s'_y} \\right\\rceil = \\left\\lceil \\frac{358.4\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 358.4 \\rceil = 359$\n- $N'_z = \\left\\lceil \\frac{L_z}{s'_z} \\right\\rceil = \\left\\lceil \\frac{500.0\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 500.0 \\rceil = 500$\n因此，新的网格维度为 $359 \\times 359 \\times 500$。\n\n最后，我们计算重采样后网格的采样密度。采样密度 $\\rho'$ 定义为单位体积内的体素数量。这是重采样后网格中单个体素体积 $V'_{voxel}$ 的倒数。\n新的各向同性网格中单个体素的体积是：\n$$\nV'_{voxel} = s'_x \\times s'_y \\times s'_z = 1.0\\,\\mathrm{mm} \\times 1.0\\,\\mathrm{mm} \\times 1.0\\,\\mathrm{mm} = 1.0\\,\\mathrm{mm}^3\n$$\n最终的采样密度是：\n$$\n\\rho' = \\frac{1}{V'_{voxel}} = \\frac{1}{1.0\\,\\mathrm{mm}^3} = 1.0\\,\\mathrm{voxels}/\\mathrm{mm}^3\n$$\n所要求的值是新的维度 $(359, 359, 500)$ 和采样密度 $1.0$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n359 & 359 & 500 & 1.0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "确定了新的体素网格后，下一步是为每个新体素计算其强度值。这个练习  让你深入了解重采样过程的核心引擎：三线性插值。通过从第一性原理出发推导其公式，你将清晰地理解如何利用原始邻近体素的值来精确估算新位置的强度，这是处理像CT扫描这样的连续色调图像时的一项基本技术。",
            "id": "4548165",
            "problem": "通过计算机断层扫描（CT）获取的三维医学图像表示为一个在由体素构成的直角网格上采样的标量强度场 $I(x,y,z)$。在用于各向同性体素转换的放射组学预处理中，一个常见的步骤是通过在新的采样位置插值计算数值，将强度场重采样到各向同性网格上。考虑一个原始体素立方体，其八个角的强度标记为 $I_{000}$、$I_{100}$、$I_{010}$、$I_{110}$、$I_{001}$、$I_{101}$、$I_{011}$ 和 $I_{111}$，其中下标表示相对于该体素的局部坐标轴，在分数坐标 $(u,v,w)$ 处的角点，且 $u$、$v$ 和 $w$ 各自在 $\\{0,1\\}$ 中取值。假设强度场 $I(x,y,z)$ 在该体素内部沿每个坐标轴方向线性变化，并且在体素内部是连续的。\n\n从一维线性插值是匹配两个端点值的唯一线性函数这一定义出发，并使用体素内部的三维插值在各坐标轴上是可分的（因此沿每个轴的变化是独立线性的）这一物理模型，请从第一性原理出发，为体素内具有分数坐标 $(u,v,w)$（其中 $u,v,w \\in [0,1]$）的任意点上的插值强度 $I(u,v,w)$ 推导出一个闭式表达式。最终公式必须仅用 $u$、$v$、$w$ 和八个角点强度 $I_{000}$、$I_{100}$、$I_{010}$、$I_{110}$、$I_{001}$、$I_{101}$、$I_{011}$ 和 $I_{111}$ 表示。最终答案必须是单一的闭式解析表达式。无需进行数值计算或四舍五入。",
            "solution": "问题陈述经评估有效。它具有科学依据，定义明确且客观。它提出了计算科学和医学成像领域的一个标准问题——即从第一性原理推导三线性插值公式。提供了所有必要的信息和约束条件，并且没有歧义、矛盾或事实错误。任务是根据所给前提，形式化并执行一个数学推导。\n\n给出的基本原理是一维线性插值。对于一个函数 $f(x)$，已知其在两点的值为 $f(0) = y_0$ 和 $f(1) = y_1$，对点 $u \\in [0,1]$ 的唯一线性插值由下式给出：\n$$f(u) = y_0(1-u) + y_1 u$$\n该公式表示端点值的加权平均，其中权重是分数距离 $u$ 的线性函数。\n\n问题陈述指出，三维插值 $I(u,v,w)$ 在各坐标轴上是可分的。这意味着我们可以通过沿三个坐标轴（$u$、$v$ 和 $w$）中的每一个顺序应用一维线性插值来获得最终值。插值的顺序无关紧要；在本推导中，我们将按 $u$、$v$、$w$ 的顺序进行。\n\n设体素的八个角点强度为 $I_{000}$、$I_{100}$、$I_{010}$、$I_{110}$、$I_{001}$、$I_{101}$、$I_{011}$ 和 $I_{111}$，其中 $I_{ijk}$ 对应于分数坐标为 $(i,j,k)$（$i,j,k \\in \\{0,1\\}$）的角点的强度。我们寻求在任意点 $(u,v,w)$（其中 $u,v,w \\in [0,1]$）处的插值强度 $I(u,v,w)$。\n\n**第1步：沿u轴插值**\n\n我们首先沿 $u$ 轴执行四次线性插值，对应于与局部 $x$ 轴平行的立方体的四条边。\n\n1.  在 $I_{000}$ 和 $I_{100}$ 之间进行插值（沿 $v=0$ 和 $w=0$ 的边）：\n    $$I(u,0,0) = I_{000}(1-u) + I_{100}u$$\n2.  在 $I_{010}$ 和 $I_{110}$ 之间进行插值（沿 $v=1$ 和 $w=0$ 的边）：\n    $$I(u,1,0) = I_{010}(1-u) + I_{110}u$$\n3.  在 $I_{001}$ 和 $I_{101}$ 之间进行插值（沿 $v=0$ 和 $w=1$ 的边）：\n    $$I(u,0,1) = I_{001}(1-u) + I_{101}u$$\n4.  在 $I_{011}$ 和 $I_{111}$ 之间进行插值（沿 $v=1$ 和 $w=1$ 的边）：\n    $$I(u,1,1) = I_{011}(1-u) + I_{111}u$$\n\n为简洁起见，我们将这些中间值表示为 $I_{u00}$、$I_{u10}$、$I_{u01}$ 和 $I_{u11}$。\n\n**第2步：沿v轴插值**\n\n接下来，我们使用第1步中计算出的四个值沿 $v$ 轴进行插值。这些值位于分数距离 $u$ 处的一个平面上。我们执行两次线性插值。\n\n1.  在 $I(u,0,0)$ 和 $I(u,1,0)$ 之间进行插值（在 $w=0$ 的平面上）：\n    $$I(u,v,0) = I(u,0,0)(1-v) + I(u,1,0)v$$\n2.  在 $I(u,0,1)$ 和 $I(u,1,1)$ 之间进行插值（在 $w=1$ 的平面上）：\n    $$I(u,v,1) = I(u,0,1)(1-v) + I(u,1,1)v$$\n\n**第3步：沿w轴插值**\n\n最后，我们使用第2步中计算出的两个值沿 $w$ 轴进行一次插值。这两个值位于分数坐标 $(u,v)$ 处的一条直线上。\n\n$$I(u,v,w) = I(u,v,0)(1-w) + I(u,v,1)w$$\n\n**第4步：推导闭式表达式**\n\n为了得到最终的闭式表达式，我们将前面步骤中的表达式代入最终的方程。\n\n将第2步中 $I(u,v,0)$ 和 $I(u,v,1)$ 的表达式代入第3步的方程中：\n$$I(u,v,w) = [I(u,0,0)(1-v) + I(u,1,0)v](1-w) + [I(u,0,1)(1-v) + I(u,1,1)v]w$$\n\n现在，代入第1步中 $I(u,0,0)$、$I(u,1,0)$、$I(u,0,1)$ 和 $I(u,1,1)$ 的表达式：\n\\begin{align*}\nI(u,v,w) =  \\Big[ \\big(I_{000}(1-u) + I_{100}u\\big)(1-v) + \\big(I_{010}(1-u) + I_{110}u\\big)v \\Big](1-w) \\\\\n+  \\Big[ \\big(I_{001}(1-u) + I_{101}u\\big)(1-v) + \\big(I_{011}(1-u) + I_{111}u\\big)v \\Big]w\n\\end{align*}\n通过分配 $(1-w)$ 和 $w$ 来展开各项：\n\\begin{align*}\nI(u,v,w) =  \\big(I_{000}(1-u) + I_{100}u\\big)(1-v)(1-w) + \\big(I_{010}(1-u) + I_{110}u\\big)v(1-w) \\\\\n+  \\big(I_{001}(1-u) + I_{101}u\\big)(1-v)w + \\big(I_{011}(1-u) + I_{111}u\\big)vw\n\\end{align*}\n最后，我们展开所有乘积，并按八个角点强度 $I_{ijk}$ 对各项进行分组：\n\\begin{align*}\nI(u,v,w) =  \\ I_{000}(1-u)(1-v)(1-w) + I_{100}u(1-v)(1-w) \\\\\n+  \\ I_{010}(1-u)v(1-w) + I_{110}uv(1-w) \\\\\n+  \\ I_{001}(1-u)(1-v)w + I_{101}u(1-v)w \\\\\n+  \\ I_{011}(1-u)vw + I_{111}uvw\n\\end{align*}\n这就是三线性插值的闭式表达式。每个角点强度 $I_{ijk}$ 都由三个项的乘积加权。给定角点的权重是其对角方向的矩形子体积的体积，该子体积由点 $(u,v,w)$ 和穿过该点且平行于单位立方体各面的三个平面所定义。对于任何 $(u,v,w) \\in [0,1]^3$，这八个权重之和等于 $1$。\n例如，$I_{000}$ 的权重是 $(1-u)(1-v)(1-w)$，它在点 $(0,0,0)$ 处等于 $1$，如果 $u$、$v$ 或 $w$ 中任意一个为 $1$，则该权重为 $0$。相反，$I_{111}$ 的权重是 $uvw$，它在点 $(1,1,1)$ 处为 $1$，如果 $u$、$v$ 或 $w$ 中任意一个为 $0$，则该权重为 $0$。这与插值的物理和数学直觉相符。\n所要求的表达式是这八个加权项的总和。",
            "answer": "$$\n\\boxed{\nI(u,v,w) = I_{000}(1-u)(1-v)(1-w) + I_{100}u(1-v)(1-w) + I_{010}(1-u)v(1-w) + I_{110}uv(1-w) + I_{001}(1-u)(1-v)w + I_{101}u(1-v)w + I_{011}(1-u)vw + I_{111}uvw\n}\n$$"
        },
        {
            "introduction": "重采样不仅会影响图像本身，还会影响到基于图像的衍生数据，例如肿瘤分割区域。对于这类分类数据（标签掩模），必须使用不同的插值方法（如最近邻插值）以保持其类别属性。这个动手实践  提供了一个计算练习，指导你通过编程实现一个完整的重采样往返过程，并使用戴斯相似系数（Dice Similarity Coefficient）来量化此过程对分割结果引入的几何形变，这是放射组学流程中质量控制的关键一步。",
            "id": "4548194",
            "problem": "给定一个在各向异性体素网格上定义的三维标签体（一个分割掩码）。在放射组学（Radiomics）中，为了可复现的特征提取，通常需要将图像标准化为各向同性体素网格。标签重采样必须保留类别语义，因此应使用最近邻插值，而不是连续强度插值。您的任务是为标签体推导、实现并评估一种最近邻各向同性体素转换方法，然后通过计算原始标签与经过重采样到各向同性间距再映射回原始网格的标签之间的 Dice 相似系数（DSC），来量化分割发生的变化。\n\n从以下基本概念开始：\n- 体素网格是对连续空间的规则采样。如果原始网格的间距（单位：毫米）为 $(s_x,s_y,s_z)$，则整数索引为 $(i,j,k)$ 的体素中心位于世界坐标 $(x,y,z) = \\left((i+\\frac{1}{2})s_x, (j+\\frac{1}{2})s_y, (k+\\frac{1}{2})s_z\\right)$。\n- 最近邻重采样将世界坐标为 $(x_t,y_t,z_t)$ 的目标体素中心映射到源体素索引 $(i_s,j_s,k_s)$，该索引使得到源体素中心的欧几里得距离最小化。对于可分离的坐标轴和规则网格，这可以简化为 $i_s=\\mathrm{round}\\left(\\frac{x_t}{s_x}-\\frac{1}{2}\\right)$，$j_s=\\mathrm{round}\\left(\\frac{y_t}{s_y}-\\frac{1}{2}\\right)$ 和 $k_s=\\mathrm{round}\\left(\\frac{z_t}{s_z}-\\frac{1}{2}\\right)$，并需要裁剪到有效的索引范围内。\n- 两个标签集 $A$ 和 $B$ 之间的 Dice 相似系数（DSC）定义为\n$$\n\\mathrm{DSC}(A,B)=\\frac{2\\,|A\\cap B|}{|A|+|B|},\n$$\n约定当 $|A|=|B|=0$ 时，$\\mathrm{DSC}(A,B)=1$；当只有一个集合为空时，$\\mathrm{DSC}(A,B)=0$。\n\n实现以下步骤：\n1. 通过对一个连续的、轴对齐的椭球体进行采样来生成原始标签体。该椭球体在世界坐标中由以下公式定义：\n$$\n\\left(\\frac{x-c_x}{r_x}\\right)^2+\\left(\\frac{y-c_y}{r_y}\\right)^2+\\left(\\frac{z-c_z}{r_z}\\right)^2 \\le 1,\n$$\n其中 $(c_x,c_y,c_z)$ 是椭球中心的毫米坐标，$(r_x,r_y,r_z)$ 是其半轴（半径）的毫米长度。使用体素中心来评估是否包含在内。\n2. 通过最近邻插值计算原始标签到目标间距 $(s,s,s)$（单位：毫米）的各向同性重采样，同时保留原始视场。每个轴上的目标网格大小应根据原始物理范围 $L_\\alpha = N_\\alpha s_\\alpha$ 通过 $N'_\\alpha=\\mathrm{round}\\left(\\frac{L_\\alpha}{s}\\right)$ 确定，其中 $\\alpha \\in \\{x,y,z\\}$， $N_\\alpha$ 是原始体素在 $\\alpha$ 轴上的数量。\n3. 使用最近邻插值将各向同性标签映射回原始网格，以使两个标签都存在于同一个原始网格上。\n4. 计算原始标签和经过往返重采样的标签之间的 $\\mathrm{DSC}$，并将结果报告为四舍五入到六位小数的小数。\n\n物理单位：所有间距和几何参数均以毫米（$\\mathrm{mm}$）为单位指定。所有输出均表示为四舍五入到六位小数的小数。\n\n角度单位：不适用。\n\n您的程序必须评估以下测试套件，并生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[\\mathrm{result}_1,\\mathrm{result}_2,\\mathrm{result}_3]$。\n\n测试套件（正常路径、恒等边界、薄结构边缘、近边界混叠）：\n- 情况 $1$（各向异性到各向同性）：原始网格尺寸 $(N_x,N_y,N_z) = (64,48,16)$，原始间距 $(s_x,s_y,s_z) = (1.0\\,\\mathrm{mm}, 1.0\\,\\mathrm{mm}, 3.0\\,\\mathrm{mm})$，各向同性间距 $s=1.0\\,\\mathrm{mm}$，椭球中心 $(c_x,c_y,c_z)=\\left((32\\cdot 1.0)+2.0, (24\\cdot 1.0)-3.0, (8\\cdot 3.0)+1.5\\right)\\,\\mathrm{mm}$，椭球半径 $(r_x,r_y,r_z) = (20.0\\,\\mathrm{mm}, 12.0\\,\\mathrm{mm}, 18.0\\,\\mathrm{mm})$。\n- 情况 $2$（恒等）：原始网格尺寸 $(40,40,40)$，原始间距 $(1.5\\,\\mathrm{mm}, 1.5\\,\\mathrm{mm}, 1.5\\,\\mathrm{mm})$，各向同性间距 $s=1.5\\,\\mathrm{mm}$，椭球中心 $(c_x,c_y,c_z)=\\left((20\\cdot 1.5), (20\\cdot 1.5), (20\\cdot 1.5)\\right)\\,\\mathrm{mm}$，椭球半径 $(18.0\\,\\mathrm{mm}, 9.0\\,\\mathrm{mm}, 10.5\\,\\mathrm{mm})$。\n- 情况 $3$（沿 $z$ 轴的薄结构）：原始网格尺寸 $(80,80,30)$，原始间距 $(0.8\\,\\mathrm{mm}, 0.8\\,\\mathrm{mm}, 2.4\\,\\mathrm{mm})$，各向同性间距 $s=0.8\\,\\mathrm{mm}$，椭球中心 $(c_x,c_y,c_z)=\\left((40\\cdot 0.8), (40\\cdot 0.8), (15\\cdot 2.4)+1.2\\right)\\,\\mathrm{mm}$，椭球半径 $(12.0\\,\\mathrm{mm}, 10.0\\,\\mathrm{mm}, 1.2\\,\\mathrm{mm})$。\n- 情况 $4$（近边界混叠）：原始网格尺寸 $(50,30,25)$，原始间距 $(1.2\\,\\mathrm{mm}, 2.0\\,\\mathrm{mm}, 2.0\\,\\mathrm{mm})$，各向同性间距 $s=1.0\\,\\mathrm{mm}$，椭球中心 $(c_x,c_y,c_z) = (5.0\\,\\mathrm{mm}, 10.0\\,\\mathrm{mm}, 15.0\\,\\mathrm{mm})$，椭球半径 $(12.0\\,\\mathrm{mm}, 8.0\\,\\mathrm{mm}, 7.0\\,\\mathrm{mm})$。\n\n您的程序应生成单行输出，其中包含上述四种情况的 DSC 值，格式为方括号括起来的逗号分隔列表，每个值都四舍五入到六位小数，例如 $[\\dots]$。不应打印任何其他文本。",
            "solution": "该问题要求为一个三维标签体实现最近邻各向同性重采样过程，然后再将其重采样回原始网格（一次“往返”操作）。目标是使用 Dice 相似系数（DSC）来量化原始标签体与经过往返重采样的标签体之间的差异。\n\n该过程将针对四个不同的测试用例执行，每个用例都由网格维度、体素间距以及用于生成初始标签体的椭球参数定义。\n\n解决方案按照问题陈述中概述的四个主要步骤构建。\n\n### 步骤 1：生成原始标签体\n\n首先，我们必须创建初始的二值标签体，记为 $A$。该体在维度为 $(N_x, N_y, N_z)$、各向异性体素间距为 $(s_x, s_y, s_z)$ 的三维网格上定义。如果整数网格索引为 $(i, j, k)$ 的体素中心的坐标 $(x, y, z)$ 满足椭球方程，则该体素被视为标签的一部分（值为 $1$）：\n$$\n\\left(\\frac{x-c_x}{r_x}\\right)^2+\\left(\\frac{y-c_y}{r_y}\\right)^2+\\left(\\frac{z-c_z}{r_z}\\right)^2 \\le 1\n$$\n索引为 $(i, j, k)$ 的体素中心的世界坐标由以下公式给出：\n$$\nx = (i + 0.5)s_x, \\quad y = (j + 0.5)s_y, \\quad z = (k + 0.5)s_z\n$$\n为高效实现此步骤，我们可以生成三个坐标矩阵，分别对应网格中每个体素中心的 $x, y, z$ 世界坐标。然后，我们以矢量化的方式应用椭球不等式来生成三维布尔掩码。\n\n### 步骤 2：各向同性重采样（正向过程）\n\n原始标签体 $A$ 被重采样到一个具有统一各向同性间距 $s$ 的新网格上。新网格必须保留原始视场（FOV）。原始体在每个轴 $\\alpha \\in \\{x, y, z\\}$ 上的物理范围（FOV）是 $L_\\alpha = N_\\alpha s_\\alpha$。新的各向同性网格中的体素数量 $N'_\\alpha$ 由以下公式确定：\n$$\nN'_\\alpha = \\mathrm{round}\\left(\\frac{L_\\alpha}{s}\\right) = \\mathrm{round}\\left(\\frac{N_\\alpha s_\\alpha}{s}\\right)\n$$\n新网格的维度为 $(N'_x, N'_y, N'_z)$，间距为 $(s, s, s)$。\n\n为了填充这个新网格，我们使用最近邻插值。对于目标各向同性网格中索引为 $(i_t, j_t, k_t)$ 的每个体素，我们首先确定其世界坐标 $(x_t, y_t, z_t)$：\n$$\nx_t = (i_t + 0.5)s, \\quad y_t = (j_t + 0.5)s, \\quad z_t = (k_t + 0.5)s\n$$\n然后，我们找到原始（源）网格中最近体素的索引 $(i_s, j_s, k_s)$。问题中提供了此映射的公式，该公式源自最小化体素中心之间的欧几里得距离：\n$$\ni_s = \\mathrm{round}\\left(\\frac{x_t}{s_x} - 0.5\\right)\n$$\n$j_s$ 和 $k_s$ 有类似的公式。`round()` 函数被解释为标准四舍五入（四舍五入到最近的整数，0.5向上取整），可实现为 $\\lfloor v + 0.5 \\rfloor$。生成的索引必须裁剪到源网格的有效范围，即 $[0, N_\\alpha - 1]$ 内。目标体素的值随后被设置为计算出的索引所对应的源体素的值。此过程产生各向同性重采样后的标签体 $L_{iso}$。\n\n### 步骤 3：映射回原始网格（反向过程）\n\n接下来，将各向同性标签体 $L_{iso}$ 重采样回原始网格的几何结构（维度 $(N_x, N_y, N_z)$，间距 $(s_x, s_y, s_z)$）。这将创建经过往返重采样的标签体 $B$。该过程与步骤 2 相同，但网格的角色互换：\n-   源网格：维度为 $(N'_x, N'_y, N'_z)$、间距为 $(s, s, s)$ 的各向同性网格。\n-   目标网格：维度为 $(N_x, N_y, N_z)$、间距为 $(s_x, s_y, s_z)$ 的原始网格。\n\n对于目标（原始）网格中索引为 $(i_t, j_t, k_t)$ 的每个体素，我们找到其世界坐标 $(x_t, y_t, z_t) = ((i_t+0.5)s_x, \\dots)$。然后，我们使用以下公式将这些坐标映射到源（各向同性）网格中的最近邻索引 $(i_s, j_s, k_s)$：\n$$\ni_s = \\mathrm{round}\\left(\\frac{x_t}{s} - 0.5\\right)\n$$\n同样，索引需要被裁剪，并且将 $L_{iso}$ 中位于 $(i_s, j_s, k_s)$ 的值赋给 $B$ 中位于 $(i_t, j_t, k_t)$ 的体素。\n\n### 步骤 4：Dice 相似系数（DSC）计算\n\n最后，我们使用 Dice 相似系数来量化原始标签体 $A$ 和往返重采样后的体 $B$ 之间的变化：\n$$\n\\mathrm{DSC}(A,B) = \\frac{2 \\cdot |A \\cap B|}{|A| + |B|}\n$$\n其中 $|A|$ 表示标签 $A$ 中的体素数量（即其体积），$|A \\cap B|$ 是两个标签共有的体素数量。对于二值（0/1）数组，这些量可以如下计算：\n-   $|A| = \\sum A_{ijk}$\n-   $|B| = \\sum B_{ijk}$\n-   $|A \\cap B| = \\sum (A_{ijk} \\cdot B_{ijk})$\n\n根据问题的约定，当两个体都为空（$|A| + |B| = 0$）的特殊情况下，DSC 结果为 $1.0$。如果分母非零，则直接应用该公式。最终的 DSC 值四舍五入到六位小数。\n\n将这整个四步过程应用于提供的每个测试用例。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the isotropic voxel conversion problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (anisotropy to isotropy)\n        {\n            \"N_orig\": (64, 48, 16),\n            \"s_orig\": (1.0, 1.0, 3.0),\n            \"s_iso\": 1.0,\n            \"c\": ((32 * 1.0) + 2.0, (24 * 1.0) - 3.0, (8 * 3.0) + 1.5),\n            \"r\": (20.0, 12.0, 18.0),\n        },\n        # Case 2 (identity)\n        {\n            \"N_orig\": (40, 40, 40),\n            \"s_orig\": (1.5, 1.5, 1.5),\n            \"s_iso\": 1.5,\n            \"c\": ((20 * 1.5), (20 * 1.5), (20 * 1.5)),\n            \"r\": (18.0, 9.0, 10.5),\n        },\n        # Case 3 (thin structure along z)\n        {\n            \"N_orig\": (80, 80, 30),\n            \"s_orig\": (0.8, 0.8, 2.4),\n            \"s_iso\": 0.8,\n            \"c\": ((40 * 0.8), (40 * 0.8), (15 * 2.4) + 1.2),\n            \"r\": (12.0, 10.0, 1.2),\n        },\n        # Case 4 (near-boundary aliasing)\n        {\n            \"N_orig\": (50, 30, 25),\n            \"s_orig\": (1.2, 2.0, 2.0),\n            \"s_iso\": 1.0,\n            \"c\": (5.0, 10.0, 15.0),\n            \"r\": (12.0, 8.0, 7.0),\n        }\n    ]\n\n    results = []\n    \n    # Custom rounding function to implement floor(x + 0.5)\n    def custom_round(x):\n        return np.floor(x + 0.5).astype(int)\n\n    def resample_nearest_neighbor(source_volume, source_spacing, target_shape, target_spacing):\n        \"\"\"\n        Resamples a volume using nearest-neighbor interpolation.\n        \"\"\"\n        # Create grid of indices for the target volume\n        target_indices = np.mgrid[0:target_shape[0], 0:target_shape[1], 0:target_shape[2]]\n        \n        # Convert target indices to world coordinates\n        # (indices + 0.5) * spacing\n        target_coords = (target_indices.astype(float) + 0.5) * np.array(target_spacing).reshape(3, 1, 1, 1)\n\n        # Map target world coordinates to source continuous indices\n        # coord / spacing - 0.5\n        source_continuous_indices = target_coords / np.array(source_spacing).reshape(3, 1, 1, 1) - 0.5\n        \n        # Round to nearest integer indices\n        source_indices = custom_round(source_continuous_indices)\n\n        # Clip indices to be within the bounds of the source volume\n        source_indices[0] = np.clip(source_indices[0], 0, source_volume.shape[0] - 1)\n        source_indices[1] = np.clip(source_indices[1], 0, source_volume.shape[1] - 1)\n        source_indices[2] = np.clip(source_indices[2], 0, source_volume.shape[2] - 1)\n        \n        # Create target volume by indexing source volume\n        target_volume = source_volume[source_indices[0], source_indices[1], source_indices[2]]\n        \n        return target_volume\n\n    def calculate_dsc(label_a, label_b):\n        \"\"\"\n        Calculates the Dice Similarity Coefficient between two label volumes.\n        \"\"\"\n        intersection = np.sum(label_a * label_b)\n        sum_a = np.sum(label_a)\n        sum_b = np.sum(label_b)\n        \n        denominator = sum_a + sum_b\n        \n        if denominator == 0:\n            return 1.0  # Both masks are empty\n        else:\n            return 2.0 * intersection / denominator\n\n    for case in test_cases:\n        N_orig = case[\"N_orig\"]\n        s_orig = case[\"s_orig\"]\n        s_iso = case[\"s_iso\"]\n        center = case[\"c\"]\n        radii = case[\"r\"]\n\n        # Step 1: Generate original label volume\n        orig_indices = np.mgrid[0:N_orig[0], 0:N_orig[1], 0:N_orig[2]]\n        orig_coords = (orig_indices.astype(float) + 0.5) * np.array(s_orig).reshape(3, 1, 1, 1)\n        \n        ellipsoid_term = (\n            ((orig_coords[0] - center[0]) / radii[0])**2 +\n            ((orig_coords[1] - center[1]) / radii[1])**2 +\n            ((orig_coords[2] - center[2]) / radii[2])**2\n        )\n        original_label = (ellipsoid_term = 1).astype(np.uint8)\n\n        # Step 2: Resample to isotropic grid\n        L_alpha = np.array(N_orig) * np.array(s_orig)\n        N_iso = np.round(L_alpha / s_iso).astype(int)\n        \n        isotropic_label = resample_nearest_neighbor(\n            source_volume=original_label,\n            source_spacing=s_orig,\n            target_shape=N_iso,\n            target_spacing=(s_iso, s_iso, s_iso)\n        )\n\n        # Step 3: Map back to original grid\n        round_trip_label = resample_nearest_neighbor(\n            source_volume=isotropic_label,\n            source_spacing=(s_iso, s_iso, s_iso),\n            target_shape=N_orig,\n            target_spacing=s_orig\n        )\n\n        # Step 4: Compute DSC\n        dsc = calculate_dsc(original_label, round_trip_label)\n        results.append(f\"{dsc:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}