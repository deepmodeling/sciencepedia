{
    "hands_on_practices": [
        {
            "introduction": "U-Net架构的精髓在于其对称的编码器-解码器路径和跳跃连接。为了成功实现跳跃连接，精确计算并匹配各层特征图的维度至关重要。本练习  将引导你手动计算一个典型的U-Net在处理图像时，特征图尺寸如何逐层变化，从而加深对网络内部数据流的理解。",
            "id": "4535986",
            "problem": "一个放射组学流程使用U形卷积神经网络（U-Net）对二维医学图像进行自动病灶分割。考虑一个网络，其配置如下，输入空间尺寸为 $256 \\times 256$（高和宽）：\n\n- 收缩路径（编码器）：在两个层级中的每一级，应用两次核大小为 $3 \\times 3$、步幅为 $1$、零填充为 $0$（有效卷积）的二维卷积，然后进行一次核大小为 $2 \\times 2$、步幅为 $2$ 的最大池化。\n- 瓶颈层：应用两次核大小为 $3 \\times 3$、步幅为 $1$、零填充为 $0$ 的二维卷积。\n- 扩张路径（解码器）：在两个层级中的每一级，应用一次核大小为 $2 \\times 2$、步幅为 $2$、零填充为 $0$、输出填充为 $0$ 的转置卷积，然后将编码器的对应池化前特征图在中心裁剪以匹配空间维度后，（沿通道维度）进行拼接。每次拼接后，应用两次核大小为 $3 \\times 3$、步幅为 $1$、零填充为 $0$ 的二维卷积。\n- 输出头：应用一次核大小为 $1 \\times 1$、步幅为 $1$ 的二维卷积来生成分割的 logits。\n\n从离散卷积、离散最大池化和离散转置卷积输出的空间尺寸的标准定义出发，确定编码器、瓶颈层和解码器路径上每次操作后特征图的空间尺寸，并通过计算每个空间维度上必要的中心裁剪尺寸来验证两次跳跃连接处的维度一致性。最后，计算两次跳跃连接中总共裁剪的像素数（即，由于中心裁剪而从两个编码器特征图中移除的所有像素之和），并以一个无单位的整数形式报告该总数。",
            "solution": "该问题是有效的。这是一个关于U-Net架构的定义明确、有科学依据的问题，U-Net是深度学习中用于图像分割的标准模型。所有参数都已明确定义，任务是基于卷积神经网络操作的既定公式进行一系列计算。\n\n求解过程需要追踪特征图在网络中传播时的空间维度。我们首先定义所用每种类型层的输出尺寸公式。设输入特征图的空间尺寸为 $H_{\\text{in}} \\times W_{\\text{in}}$，输出为 $H_{\\text{out}} \\times W_{\\text{out}}$。为简化起见，由于操作是对称的，我们只展示一个维度 $H$ 的计算。\n\n1.  **二维卷积**：对于一个大小为 $K \\times K$ 的核，步幅为 $S$，填充为 $P$，输出维度为\n    $$H_{\\text{out}} = \\lfloor \\frac{H_{\\text{in}} + 2P - K}{S} \\rfloor + 1$$\n    在本例中，卷积被指定为“有效卷积”，意味着零填充（$P=0$），核大小为 $K=3$，步幅为 $S=1$。公式简化为 $H_{\\text{out}} = H_{\\text{in}} - 3 + 1 = H_{\\text{in}} - 2$。\n\n2.  **最大池化**：对于一个大小为 $K \\times K$ 的核，步幅为 $S$，输出维度为\n    $$H_{\\text{out}} = \\lfloor \\frac{H_{\\text{in}} - K}{S} \\rfloor + 1$$\n    在本例中，核大小为 $K=2$，步幅为 $S=2$。假设输入维度是偶数，公式简化为 $H_{\\text{out}} = \\frac{H_{\\text{in}}}{2}$。\n\n3.  **转置卷积**：对于一个大小为 $K \\times K$ 的核，步幅为 $S$，填充为 $P$，输出填充为 $O_p$，输出维度为\n    $$H_{\\text{out}} = (H_{\\text{in}} - 1)S - 2P + K + O_p$$\n    在本例中，$K=2$，$S=2$，$P=0$，且 $O_p=0$。公式简化为 $H_{\\text{out}} = (H_{\\text{in}} - 1) \\times 2 + 2 = 2H_{\\text{in}}$。\n\n我们现在从 $256 \\times 256$ 的输入开始，追踪网络中的空间维度变化。\n\n**收缩路径（编码器）**\n\n*   **编码器层级1：**\n    *   输入：$256 \\times 256$\n    *   第一次 $3 \\times 3$ 卷积：$256 - 2 = 254$。尺寸为 $254 \\times 254$。\n    *   第二次 $3 \\times 3$ 卷积：$254 - 2 = 252$。尺寸为 $252 \\times 252$。这是用于第一次跳跃连接的特征图，我们称其尺寸为 $S_1 = 252 \\times 252$。\n    *   $2 \\times 2$ 最大池化：$252 / 2 = 126$。尺寸为 $126 \\times 126$。\n\n*   **编码器层级2：**\n    *   输入：$126 \\times 126$\n    *   第一次 $3 \\times 3$ 卷积：$126 - 2 = 124$。尺寸为 $124 \\times 124$。\n    *   第二次 $3 \\times 3$ 卷积：$124 - 2 = 122$。尺寸为 $122 \\times 122$。这是用于第二次跳跃连接的特征图，我们称其尺寸为 $S_2 = 122 \\times 122$。\n    *   $2 \\times 2$ 最大池化：$122 / 2 = 61$。尺寸为 $61 \\times 61$。\n\n**瓶颈层**\n\n*   输入：$61 \\times 61$\n*   第一次 $3 \\times 3$ 卷积：$61 - 2 = 59$。尺寸为 $59 \\times 59$。\n*   第二次 $3 \\times 3$ 卷积：$59 - 2 = 57$。尺寸为 $57 \\times 57$。\n\n**扩张路径（解码器）**\n\n*   **解码器层级1：**\n    *   来自瓶颈层的输入：$57 \\times 57$\n    *   $2 \\times 2$ 转置卷积：$57 \\times 2 = 114$。尺寸为 $114 \\times 114$。这是上采样后的特征图。\n    *   **跳跃连接1（来自编码器层级2）：**为了进行拼接，来自编码器的特征图（$S_2 = 122 \\times 122$）必须被裁剪以匹配解码器的上采样图（$114 \\times 114$）。\n        *   每个维度的裁剪尺寸：$122 - 114 = 8$ 像素。\n        *   中心裁剪从四个边各移除 $8/2 = 4$ 像素。\n        *   从此特征图中移除的像素数：$(122 \\times 122) - (114 \\times 114) = 14884 - 12996 = 1888$。\n    *   拼接后，尺寸为 $114 \\times 114$。\n    *   第一次 $3 \\times 3$ 卷积：$114 - 2 = 112$。尺寸为 $112 \\times 112$。\n    *   第二次 $3 \\times 3$ 卷积：$112 - 2 = 110$。尺寸为 $110 \\times 110$。\n\n*   **解码器层级2：**\n    *   来自解码器层级1的输入：$110 \\times 110$\n    *   $2 \\times 2$ 转置卷积：$110 \\times 2 = 220$。尺寸为 $220 \\times 220$。这是上采样后的特征图。\n    *   **跳跃连接2（来自编码器层级1）：**为了进行拼接，来自编码器的特征图（$S_1 = 252 \\times 252$）必须被裁剪以匹配解码器的上采样图（$220 \\times 220$）。\n        *   每个维度的裁剪尺寸：$252 - 220 = 32$ 像素。\n        *   中心裁剪从四个边各移除 $32/2 = 16$ 像素。\n        *   从此特征图中移除的像素数：$(252 \\times 252) - (220 \\times 220) = 63504 - 48400 = 15104$。\n    *   拼接后，尺寸为 $220 \\times 220$。\n    *   第一次 $3 \\times 3$ 卷积：$220 - 2 = 218$。尺寸为 $218 \\times 218$。\n    *   第二次 $3 \\times 3$ 卷积：$218 - 2 = 216$。尺寸为 $216 \\times 216$。\n\n**输出头**\n\n*   输入：$216 \\times 216$\n*   $1 \\times 1$ 卷积（$K=1, S=1, P=0$）：$H_{\\text{out}} = (216 + 2 \\times 0 - 1) / 1 + 1 = 216$。尺寸保持为 $216 \\times 216$。\n\n**最终计算**\n\n问题要求计算两次跳跃连接中总共裁剪的像素数。我们将每次拼接步骤中移除的像素数相加。\n\n*   第一次跳跃连接（解码器层级1）裁剪的像素数：$1888$。\n*   第二次跳跃连接（解码器层级2）裁剪的像素数：$15104$。\n\n总裁剪像素数 = $1888 + 15104 = 16992$。",
            "answer": "$$\n\\boxed{16992}\n$$"
        },
        {
            "introduction": "模型生成分割结果后，我们必须有客观的方法来评估其优劣。本练习  将介绍在医学图像分割中广泛使用的关键性能指标，包括灵敏度、特异性和精确率。通过一个具体的计算案例，你将学会如何从混淆矩阵中推导这些指标，并理解它们与阈值选择及类别不平衡问题的关系。",
            "id": "4535965",
            "problem": "一个用于影像组学的生物医学图像分割流程使用U形卷积神经网络（U-Net）（一种卷积神经网络（CNN）），为一项二元任务（病灶与背景）生成逐体素的概率图。在对网络输出应用一个固定的概率阈值 $t$ 后，会得到一个预测的二进制掩模，并将其与手动的基准真相掩模进行比较，从而得出一个包含真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$）体素计数的混淆矩阵。假设一个轴向切片包含 $N = 100{,}000$ 个体素，基准真相中病灶的比例为 $p = 0.02$，因此有 $pN = 2{,}000$ 个病灶体素和 $(1 - p)N = 98{,}000$ 个背景体素。对于阈值 $t = 0.6$，假设得到的混淆矩阵为 $TP = 1{,}620$，$FP = 1{,}800$，$TN = 96{,}200$，$FN = 380$。\n\n使用从混淆矩阵中推导出的分割任务二元分类率的标准、基本原理定义，计算阈值 $t = 0.6$ 时的灵敏度、特异度和精确率。然后，从这些基本定义出发，并且不使用任何提供给你的快捷公式，解释改变阈值 $t$ 和改变比例 $p$ 如何影响这三个指标，强调它们定义中分母的作用，并在适当情况下以真实类别为条件进行说明。最后，将灵敏度和精确率的调和平均数作为你的单一数值结果报告，四舍五入到 $4$ 位有效数字。将结果表示为一个无量纲的十进制数。",
            "solution": "U形卷积神经网络（U-Net）为每个体素生成其属于病灶类别的概率。在 $t = 0.6$ 处进行阈值处理，得到一个预测的二进制掩模。混淆矩阵计数 $TP$、$FP$、$TN$ 和 $FN$ 总结了预测与基准真相之间的联合结果。\n\n根据分割中二元分类的基本原理，灵敏度（也称为真阳性率或召回率）衡量在体素确实是病灶的情况下，预测其为病灶的条件概率。特异度（真阴性率）衡量在体素确实是背景的情况下，预测其为背景的条件概率。精确率（阳性预测值）衡量在体素被预测为病灶的情况下，它确实是病灶的条件概率。这些指标使用混淆矩阵定义如下：\n- 灵敏度是条件概率 $P(\\hat{Y} = 1 \\mid Y = 1)$，经验上计算为被正确预测的真实病灶体素的比例：\n$$\n\\text{灵敏度} = \\frac{TP}{TP + FN}.\n$$\n- 特异度是条件概率 $P(\\hat{Y} = 0 \\mid Y = 0)$，计算为被正确预测的真实背景体素的比例：\n$$\n\\text{特异度} = \\frac{TN}{TN + FP}.\n$$\n- 精确率是条件概率 $P(Y = 1 \\mid \\hat{Y} = 1)$，计算为被预测为病灶的体素中，真实为病灶的体素的比例：\n$$\n\\text{精确率} = \\frac{TP}{TP + FP}.\n$$\n\n使用给定的计数 $TP = 1{,}620$，$FP = 1{,}800$，$TN = 96{,}200$ 和 $FN = 380$：\n1. 计算灵敏度：\n$$\n\\text{灵敏度} = \\frac{TP}{TP + FN} = \\frac{1{,}620}{1{,}620 + 380} = \\frac{1{,}620}{2{,}000} = \\frac{81}{100} = 0.81.\n$$\n2. 计算特异度：\n$$\n\\text{特异度} = \\frac{TN}{TN + FP} = \\frac{96{,}200}{96{,}200 + 1{,}800} = \\frac{96{,}200}{98{,}000} = \\frac{481}{490} \\approx 0.981632653\\ldots\n$$\n3. 计算精确率：\n$$\n\\text{精确率} = \\frac{TP}{TP + FP} = \\frac{1{,}620}{1{,}620 + 1{,}800} = \\frac{1{,}620}{3{,}420} = \\frac{9}{19} \\approx 0.473684210\\ldots\n$$\n\n对阈值 $t$ 的依赖性：\n- 阈值处理通过在体素的预测概率超过 $t$ 时将其声明为病灶，从而将概率映射到二元预测。随着 $t$ 减小，更多的体素被标记为病灶。根据上述定义：\n  - $TP$ 通常增加（更多真实病灶体素超过了较低的阈值），$FN$ 通常减少，因此分母 $TP + FN$ 由基准真相固定；因此，随着 $t$ 减小，灵敏度 $\\frac{TP}{TP + FN}$ 趋于增加。\n  - $FP$ 通常增加（更多背景体素错误地越过了较低的阈值），$TN$ 通常减少，因此随着 $t$ 减小，特异度 $\\frac{TN}{TN + FP}$ 趋于减少。\n  - 精确率 $\\frac{TP}{TP + FP}$ 随着 $t$ 的变化可能增加也可能减少，这取决于 $TP$ 的增加与 $FP$ 的增加之间的平衡。如果 $FP$ 的增长速度快于 $TP$，精确率会降低；如果 $TP$ 的增长速度快于 $FP$，精确率会增加。\n这些单调性之所以出现，是因为分母 $TP + FN$ 和 $TN + FP$ 由基准真相的类别大小固定，而分子则随着阈值引起的决策变化而变化。\n\n对比例 $p$ 的依赖性：\n- 令 $p = P(Y = 1)$ 表示病灶比例，$1 - p = P(Y = 0)$ 表示背景比例。对于一个在固定阈值 $t$ 下运行的给定分类器，定义真阳性率 $\\text{TPR} = P(\\hat{Y} = 1 \\mid Y = 1)$ 和假阳性率 $\\text{FPR} = P(\\hat{Y} = 1 \\mid Y = 0)$。那么，在总体期望上，\n$$\nTP \\approx pN \\cdot \\text{TPR}, \\quad FN \\approx pN \\cdot (1 - \\text{TPR}), \\quad FP \\approx (1 - p)N \\cdot \\text{FPR}, \\quad TN \\approx (1 - p)N \\cdot (1 - \\text{FPR}).\n$$\n因此，\n$$\n\\text{灵敏度} = \\frac{TP}{TP + FN} = \\frac{pN \\cdot \\text{TPR}}{pN \\cdot \\text{TPR} + pN \\cdot (1 - \\text{TPR})} = \\text{TPR},\n$$\n这与 $p$ 无关，因为分母 $TP + FN$ 的条件是 $Y = 1$（真实病灶类别）。类似地，\n$$\n\\text{特异度} = \\frac{TN}{TN + FP} = \\frac{(1 - p)N \\cdot (1 - \\text{FPR})}{(1 - p)N \\cdot (1 - \\text{FPR}) + (1 - p)N \\cdot \\text{FPR}} = 1 - \\text{FPR},\n$$\n这也与 $p$ 无关，因为分母 $TN + FP$ 的条件是 $Y = 0$（真实背景类别）。相比之下，精确率依赖于比例：\n$$\n\\text{精确率} = \\frac{TP}{TP + FP} = \\frac{p \\cdot \\text{TPR}}{p \\cdot \\text{TPR} + (1 - p) \\cdot \\text{FPR}},\n$$\n当 $\\text{TPR}$ 和 $\\text{FPR}$ 固定时，该值随 $p$ 的增加而增加。因此，精确率对类别比例敏感，而灵敏度和特异度则不敏感，这是因为它们的分母是以真实类别为条件的。\n\n最后，要求的单一数值结果是灵敏度和精确率的调和平均数。两个正数 $a$ 和 $b$ 的调和平均数 $H$ 定义为\n$$\nH = \\frac{2}{\\frac{1}{a} + \\frac{1}{b}} = \\frac{2ab}{a + b}.\n$$\n将 $a$ 设为灵敏度，$b$ 设为精确率：\n$$\na = \\frac{81}{100}, \\quad b = \\frac{9}{19}.\n$$\n计算\n$$\nH = \\frac{2ab}{a + b} = \\frac{2 \\cdot \\frac{81}{100} \\cdot \\frac{9}{19}}{\\frac{81}{100} + \\frac{9}{19}} = \\frac{\\frac{1458}{1900}}{\\frac{2439}{1900}} = \\frac{1458}{2439} = \\frac{162}{271} \\approx 0.597786\\ldots\n$$\n四舍五入到 $4$ 位有效数字，调和平均数为 $0.5978$。",
            "answer": "$$\\boxed{0.5978}$$"
        },
        {
            "introduction": "深度学习模型的原始输出往往不是最终的完美结果，通常需要进行后处理以提高实用性。本练习  模拟了放射组学中一个常见的后处理流程：连通域分析和体积滤波。你将学习如何识别分割掩码中的独立对象，并根据它们的物理体积滤除伪影，从而将原始的像素级预测转化为更具临床意义的区域。",
            "id": "4535929",
            "problem": "给定您一个由分割模型（如 U 形卷积神经网络 U-Net）生成的三维二值掩模。在放射学信息学（影像组学）中，一个常见的后处理步骤是根据连通分量的物理体积对其进行过滤，从而移除掩模中的虚假检测。该二值掩模可建模为一个离散场 $M \\in \\{0,1\\}^{N_x \\times N_y \\times N_z}$，其中 $N_x$、$N_y$ 和 $N_z$ 是正整数。该网格的体素间距为 $s = (s_x, s_y, s_z)$，单位为毫米 (mm)，其中 $s_x > 0$，$s_y > 0$，$s_z > 0$。\n\n使用的基本依据和核心定义：\n- 连通分量是相对于一个连通性参数 $c \\in \\{6,18,26\\}$ 定义的。对于 $c=6$，两个体素是连通的，当且仅当它们的索引在一个轴上相差为 $1$，而在另外两个轴上相等（曼哈顿距离为 $1$）。对于 $c=26$，两个体素是连通的，当且仅当它们索引之间的切比雪夫距离为 $1$。对于 $c=18$，连通性包括面邻接和边邻接的邻居，但不包括角邻接的邻居（即，所有切比雪夫距离为 $1$ 的邻居，除了那些三个轴索引同时改变的邻居）。\n- 单个物理体素的体积为 $v_{\\text{vox}} = s_x \\cdot s_y \\cdot s_z$，单位为 $\\text{mm}^3$。\n- 一个包含 $n$ 个体素的连通分量的物理体积为 $V_{\\text{mm}^3} = n \\cdot v_{\\text{vox}}$，单位为 $\\text{mm}^3$。\n- 使用经过充分验证的换算关系 $1\\,\\text{mL} = 1\\,\\text{cm}^3 = 1000\\,\\text{mm}^3$ 将 $\\text{mm}^3$ 转换为毫升 (mL)，因此 $V_{\\text{mL}} = V_{\\text{mm}^3}/1000$。\n\n您的任务是：\n- 根据指定的连通性 $c$ 计算每个掩模中的连通分量。\n- 使用给定的体素间距计算每个连通分量的物理体积（单位为毫升）。\n- 仅保留那些体积 $V_{\\text{mL}}$ 满足 $V_{\\min} \\leq V_{\\text{mL}} \\leq V_{\\max}$ 的分量，其中 $V_{\\min}$ 和 $V_{\\max}$ 以毫升 (mL) 为单位给出，且比较是包含性的。\n- 对于每个测试用例，报告保留的连通分量数量（一个整数）和总保留体积（一个浮点数），单位为毫升。将最终的总体积以毫升 (mL) 表示，并四舍五入到 $6$ 位小数。\n\n角度单位不适用。所有物理单位必须明确处理：间距以毫米 (mm) 为单位，体积必须以毫升 (mL) 报告。\n\n测试套件：\n使用以下掩模、间距、阈值和连通性。所有张量索引都是从零开始的。\n\n- 测试用例 $1$（正常路径）：\n  - 掩模形状：$(5,5,5)$。\n  - 体素间距：$s = (1,1,1)$ mm。\n  - 连通性：$c=6$。\n  - 分量：\n    - 分量 $\\mathcal{A}$：对于 $i \\in \\{0,1,2,3,4\\}$，设置 $M[i,0,0] = 1$（一条包含 $5$ 个体素的线）。\n    - 分量 $\\mathcal{B}$：对于 $x \\in \\{2,3,4\\}$、$y \\in \\{2,3\\}$、$z \\in \\{2,3\\}$，设置 $M[x,y,z] = 1$（一个 $3 \\times 2 \\times 2$ 的块，包含 $12$ 个体素）。\n  - 体积阈值（mL）：$V_{\\min} = 0.008$，$V_{\\max} = 0.015$。\n\n- 测试用例 $2$（各向异性间距和包含上界）：\n  - 掩模形状：$(8,8,6)$。\n  - 体素间距：$s = (0.5,0.5,2.0)$ mm。\n  - 连通性：$c=26$。\n  - 分量：\n    - 分量 $\\mathcal{C}$：对于 $x \\in \\{0,1,2,3,4\\}$、$y \\in \\{0,1,2,3,4\\}$、$z \\in \\{0,1,2,3\\}$，设置 $M[x,y,z] = 1$（一个 $5 \\times 5 \\times 4$ 的块，包含 $100$ 个体素）。\n    - 分量 $\\mathcal{D}$：对于 $x \\in \\{6,7\\}$、$y \\in \\{6,7\\}$、$z \\in \\{1,2,3,4,5\\}$，设置 $M[x,y,z] = 1$（一个 $2 \\times 2 \\times 5$ 的块，包含 $20$ 个体素）。\n  - 体积阈值（mL）：$V_{\\min} = 0.025$，$V_{\\max} = 0.050$。\n\n- 测试用例 $3$（阈值上的边界相等情况）：\n  - 掩模形状：$(5,5,5)$。\n  - 体素间距：$s = (1,1,1)$ mm。\n  - 连通性：$c=6$。\n  - 分量：\n    - 分量 $\\mathcal{E}$：对于 $x \\in \\{0,1,2\\}$、$y \\in \\{0,1,2\\}$、$z \\in \\{0\\}$，设置 $M[x,y,z] = 1$（一个 $3 \\times 3 \\times 1$ 的块，包含 $9$ 个体素）。\n    - 分量 $\\mathcal{F}$：对于 $x \\in \\{0,1\\}$、$y \\in \\{0,1,2,3,4\\}$、$z \\in \\{2\\}$，设置 $M[x,y,z] = 1$（一个 $2 \\times 5 \\times 1$ 的块，包含 $10$ 个体素）。\n  - 体积阈值（mL）：$V_{\\min} = 0.010$，$V_{\\max} = 0.010$。\n\n- 测试用例 $4$（空掩模边缘情况）：\n  - 掩模形状：$(4,4,4)$。\n  - 体素间距：$s = (1,1,1)$ mm。\n  - 连通性：$c=6$。\n  - 分量：无，即对于所有索引，$M[i,j,k] = 0$。\n  - 体积阈值（mL）：$V_{\\min} = 0.000$，$V_{\\max} = 100.000$。\n\n- 测试用例 $5$（$6$-连通性排除对角线邻接）：\n  - 掩模形状：$(3,3,3)$。\n  - 体素间距：$s = (1,1,1)$ mm。\n  - 连通性：$c=6$。\n  - 分量：设置 $M[0,0,0] = 1$ 和 $M[1,1,1] = 1$（两个对角线邻接的体素）。\n  - 体积阈值（mL）：$V_{\\min} = 0.001$，$V_{\\max} = 1.000$。\n\n- 测试用例 $6$（$26$-连通性包含对角线邻接）：\n  - 掩模形状：$(3,3,3)$。\n  - 体素间距：$s = (1,1,1)$ mm。\n  - 连通性：$c=26$。\n  - 分量：与测试用例 $5$ 中相同的体素位置。\n  - 体积阈值（mL）：$V_{\\min} = 0.001$，$V_{\\max} = 1.000$。\n\n最终输出规范：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个结果是形如 $[N_{\\text{retained}},V_{\\text{total\\_mL}}]$ 的包含两个元素的列表，其中 $N_{\\text{retained}}$ 是一个整数，$V_{\\text{total\\_mL}}$ 是一个四舍五入到 $6$ 位小数的浮点数。例如，输出格式为：$[[n_1,v_1],[n_2,v_2],\\dots]$。",
            "solution": "该问题要求实现一个标准的影像组学后处理工作流：根据三维二值掩模中连通分量的物理体积对其进行过滤。该解决方案包含几个不同的逻辑步骤：连通分量标记、计算每个分量的体积、根据体积阈值进行过滤以及汇总结果。\n\n首先，我们对输入进行形式化。对于每个测试用例，我们给定一个二值掩模 $M \\in \\{0,1\\}^{N_x \\times N_y \\times N_z}$、一个单位为毫米的体素间距向量 $s = (s_x, s_y, s_z)$、一个连通性参数 $c \\in \\{6, 18, 26\\}$，以及最小和最大体积阈值 $V_{\\min}$ 和 $V_{\\max}$（单位为毫升）。\n\n任务的核心是识别掩模 $M$ 内的连通分量。连通分量是一组前景体素（值为 $1$），其中每个体素都与该集合中的至少一个其他体素相连，并且该集合中的任何体素都不与集合外的任何体素相连。“连通”的定义取决于参数 $c$。我们为此任务使用一个标准算法：连通分量标记。`scipy.ndimage.label` 函数提供了一个健壮且高效的实现。连通性参数 $c$ 被映射到一个结构元素，该结构元素定义了用于连通性检查的邻域：\n- 对于 $c=6$（面连通性），如果两个体素沿一个轴相邻，则它们是邻居。这对应于 `scipy.ndimage.generate_binary_structure(3, 1)` 中的 `connectivity=1`。\n- 对于 $c=18$（面和边连通性），如果两个体素沿面或边相邻，则它们是邻居。这对应于 `scipy.ndimage.generate_binary_structure(3, 2)` 中的 `connectivity=2`。\n- 对于 $c=26$（面、边和角连通性），如果两个体素沿面、边或角相邻，则它们是邻居。这对应于 `scipy.ndimage.generate_binary_structure(3, 3)` 中的 `connectivity=3`。\n\n`label` 函数返回一个新的网格 `labeled_mask`，其中属于同一分量的所有体素都被赋予一个唯一的正整数标签，以及找到的分量总数 `num_features`。\n\n一旦分量被识别和标记，下一步是计算每个分量的物理体积。单个体素的物理体积由其尺寸的乘积给出：\n$$v_{\\text{vox}} = s_x \\cdot s_y \\cdot s_z \\quad [\\text{mm}^3]$$\n一个连通分量的体积是它包含的体素数 $n$ 乘以单个体素的体积。每个标记分量的体素数可以使用 `scipy.ndimage.sum` 高效地找到。因此，以立方毫米为单位的体积是：\n$$V_{\\text{mm}^3} = n \\cdot v_{\\text{vox}}$$\n问题要求体积以毫升 (mL) 为单位。使用给定的换算因子 $1\\,\\text{mL} = 1000\\,\\text{mm}^3$，体积为：\n$$V_{\\text{mL}} = \\frac{V_{\\text{mm}^3}}{1000} = \\frac{n \\cdot s_x \\cdot s_y \\cdot s_z}{1000}$$\n\n第三步是过滤。将每个分量计算出的体积 $V_{\\text{mL}}$ 与给定的阈值 $V_{\\min}$ 和 $V_{\\max}$ 进行比较。当且仅当一个分量的体积落在以下包含性范围内时，该分量才被保留：\n$$V_{\\min} \\leq V_{\\text{mL}} \\leq V_{\\max}$$\n\n最后，对于每个测试用例，我们汇总结果。我们计算保留的分量数量 $N_{\\text{retained}}$，并通过将所有保留分量的体积相加来计算它们的总体积 $V_{\\text{total\\_mL}}$。\n$$V_{\\text{total\\_mL}} = \\sum_{i \\in \\text{retained components}} V_{\\text{mL}, i}$$\n最终的总体积四舍五入到 $6$ 位小数。每个测试用例的结果是一对 $[N_{\\text{retained}}, V_{\\text{total\\_mL}}]$。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import label, sum as ndimage_sum, generate_binary_structure\n\ndef process_case(mask_shape, spacing, connectivity_c, components_def, V_min, V_max):\n    \"\"\"\n    Processes a single test case for connected component filtering.\n\n    Args:\n        mask_shape (tuple): The shape of the 3D mask (Nz, Ny, Nx).\n        spacing (tuple): The voxel spacing in mm (sx, sy, sz).\n        connectivity_c (int): The connectivity parameter (6, 18, or 26).\n        components_def (list): A list of tuples defining the components.\n        V_min (float): The minimum volume threshold in mL.\n        V_max (float): The maximum volume threshold in mL.\n\n    Returns:\n        list: A list containing [N_retained, V_total_mL].\n    \"\"\"\n    # Create the binary mask\n    mask = np.zeros(mask_shape, dtype=np.int8)\n    for comp_def in components_def:\n        x_range, y_range, z_range = comp_def\n        for x in x_range:\n            for y in y_range:\n                for z in z_range:\n                    # Using (z, y, x) indexing for numpy arrays\n                    mask[z, y, x] = 1\n\n    # Handle the empty mask case\n    if not np.any(mask):\n        return [0, 0.0]\n\n    # Define the structuring element for connectivity\n    # Scipy's connectivity mapping: 1 for faces (6-conn), 2 for faces+edges (18-conn), 3 for faces+edges+corners (26-conn)\n    if connectivity_c == 6:\n        structure = generate_binary_structure(3, 1)\n    elif connectivity_c == 18:\n        structure = generate_binary_structure(3, 2)\n    elif connectivity_c == 26:\n        structure = generate_binary_structure(3, 3)\n    else:\n        raise ValueError(\"Invalid connectivity parameter\")\n\n    # Perform connected component labeling\n    labeled_mask, num_features = label(mask, structure=structure)\n\n    # If no features found (despite mask not being empty, as a safeguard)\n    if num_features == 0:\n        return [0, 0.0]\n\n    # Get the size (number of voxels) of each component\n    # The labels are from 1 to num_features\n    component_labels = np.arange(1, num_features + 1)\n    component_sizes = ndimage_sum(mask, labeled_mask, component_labels)\n\n    # Calculate voxel volume and conversion factor to mL\n    s_x, s_y, s_z = spacing\n    v_vox_mm3 = s_x * s_y * s_z\n    mm3_to_ml = 1.0 / 1000.0\n\n    # Calculate volumes and filter\n    retained_volumes_ml = []\n    for size in component_sizes:\n        if isinstance(size, np.ndarray): # Handle case where ndimage_sum returns array\n            size = size.item()\n        \n        volume_mm3 = size * v_vox_mm3\n        volume_ml = volume_mm3 * mm3_to_ml\n        \n        if V_min = volume_ml = V_max:\n            retained_volumes_ml.append(volume_ml)\n\n    # Aggregate results\n    n_retained = len(retained_volumes_ml)\n    v_total_ml = sum(retained_volumes_ml)\n\n    return [n_retained, round(v_total_ml, 6)]\n\ndef solve():\n    # Note: Numpy indexing is (z, y, x) but problem statement uses (x, y, z).\n    # Mask shapes are given as (Nx, Ny, Nz), so numpy shape is (Nz, Ny, Nx).\n    test_cases = [\n        {\n            \"mask_shape\": (5, 5, 5), \"spacing\": (1.0, 1.0, 1.0), \"connectivity_c\": 6,\n            \"components_def\": [\n                (range(5), range(1), range(1)),  # Component A\n                (range(2, 5), range(2, 4), range(2, 4)), # Component B\n            ],\n            \"V_min\": 0.008, \"V_max\": 0.015\n        },\n        {\n            \"mask_shape\": (8, 8, 6), \"spacing\": (0.5, 0.5, 2.0), \"connectivity_c\": 26,\n            \"components_def\": [\n                (range(5), range(5), range(4)), # Component C\n                (range(6, 8), range(6, 8), range(1, 6)), # Component D\n            ],\n            \"V_min\": 0.025, \"V_max\": 0.050\n        },\n        {\n            \"mask_shape\": (5, 5, 5), \"spacing\": (1.0, 1.0, 1.0), \"connectivity_c\": 6,\n            \"components_def\": [\n                (range(3), range(3), range(1)), # Component E\n                (range(2), range(5), range(2, 3)), # Component F\n            ],\n            \"V_min\": 0.010, \"V_max\": 0.010\n        },\n        {\n            \"mask_shape\": (4, 4, 4), \"spacing\": (1.0, 1.0, 1.0), \"connectivity_c\": 6,\n            \"components_def\": [],\n            \"V_min\": 0.000, \"V_max\": 100.000\n        },\n        {\n            \"mask_shape\": (3, 3, 3), \"spacing\": (1.0, 1.0, 1.0), \"connectivity_c\": 6,\n            \"components_def\": [\n                (range(1), range(1), range(1)), # M[0,0,0]\n                (range(1, 2), range(1, 2), range(1, 2)), # M[1,1,1]\n            ],\n            \"V_min\": 0.001, \"V_max\": 1.000\n        },\n        {\n            \"mask_shape\": (3, 3, 3), \"spacing\": (1.0, 1.0, 1.0), \"connectivity_c\": 26,\n            \"components_def\": [\n                (range(1), range(1), range(1)), # M[0,0,0]\n                (range(1, 2), range(1, 2), range(1, 2)), # M[1,1,1]\n            ],\n            \"V_min\": 0.001, \"V_max\": 1.000\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters\n        # Reorder mask shape for numpy (Nz, Ny, Nx)\n        nx, ny, nz = case[\"mask_shape\"]\n        np_mask_shape = (nz, ny, nx)\n        \n        result = process_case(\n            np_mask_shape,\n            case[\"spacing\"],\n            case[\"connectivity_c\"],\n            case[\"components_def\"],\n            case[\"V_min\"],\n            case[\"V_max\"]\n        )\n        results.append(result)\n\n    # Format the final output string exactly as required\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}