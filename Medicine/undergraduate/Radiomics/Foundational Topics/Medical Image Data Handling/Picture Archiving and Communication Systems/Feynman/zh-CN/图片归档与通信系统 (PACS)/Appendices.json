{
    "hands_on_practices": [
        {
            "introduction": "在放射组学中，对医学图像的分析是在一个以患者为中心的三维坐标系中进行的，但图像数据本身是存储为体素网格。为了连接这两个空间，我们需要一个关键的数学工具——仿射变换。这个练习将指导你如何利用数字影像与通讯医学 (DICOM) 标准中的元数据，从头开始推导并计算出连接体素索引和患者物理坐标的仿射变换矩阵，这是实现空间精确定位和分析的基础。",
            "id": "4555353",
            "problem": "在图像存档与通信系统（PACS；Picture Archiving and Communication Systems）的存档中，一个放射组学工作流必须使用医学数字成像和通信（DICOM；Digital Imaging and Communications in Medicine）属性，将三维计算机断层扫描（CT；Computed Tomography）体数据中的体素索引映射到患者坐标。在DICOM患者坐标系中，坐标轴定义为左-后-上（LPS），即$x$轴指向患者的左侧，$y$轴指向患者的后方，$z$轴指向患者的上方。该CT序列对于一个代表性切片具有以下DICOM属性：\n- 像素间距 $(0028,0030)$ 为 $[0.80,\\,0.80]$ 毫米，其中第一个值是沿行方向的间距，第二个值是沿列方向的间距。\n- 切片厚度 $(0018,0050)$ 为 $1.5$ 毫米。\n- 图像方向（患者） $(0020,0037)$ 为 $\\left[\\frac{\\sqrt{3}}{2},\\,\\frac{1}{2},\\,0,\\,-\\frac{1}{2},\\,\\frac{\\sqrt{3}}{2},\\,0\\right]$，它分别给出了图像平面行轴和列轴的方向余弦。\n- 图像位置（患者） $(0020,0032)$ 对于第一张切片 $(k=0)$ 是 $\\left[-120,\\,-90,\\,-50\\right]$ 毫米，给出了零基索引 $(i,j,k)=(0,0,0)$ 处体素中心的患者空间坐标。\n\n假设图像平面坐标轴在LPS患者坐标系中构成一个标准正交基，并且切片间的方向由行和列方向向量通过右手定则得到的法向量给出。使用零基体素索引 $(i,j,k)$，其中 $i$ 沿图像列方向递增，$j$ 沿图像行方向递增，$k$ 随采集顺序中的切片编号递增。从第一性原理（坐标基、方向余弦和 $\\mathbb{R}^{3}$ 中的线性映射）出发，推导将齐次体素索引映射到齐次患者坐标的仿射变换，即求 $4\\times 4$ 矩阵 $A$，使得\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz \\\\\n1\n\\end{pmatrix}\n=\nA\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk \\\\\n1\n\\end{pmatrix}.\n$$\n以毫米为单位，将 $A$ 的元素按行主序报告为一个单行向量。使用精确的解析值，不要四舍五入。距离以毫米表示，如果在中间推理中出现角度，则酌情以弧度或度表示；最终报告的变换矩阵元素必须以毫米为单位。最终答案必须是完全按照指示呈现的单个解析表达式（矩阵元素的行向量）。",
            "solution": "用户希望求解仿射变换矩阵A，该矩阵将齐次体素索引 (i, j, k) 映射到齐次患者坐标 (x, y, z)。我的方法如下：\n\n1.  **问题验证：**\n    *   **步骤 1：提取已知条件：**\n        *   患者坐标系：左-后-上 (LPS)。\n        *   体素索引：$(i, j, k)$，零基。$i$ 沿列递增，$j$ 沿行递增，$k$ 沿切片递增。\n        *   像素间距 (0028,0030)：$[\\Delta j, \\Delta i] = [0.80, 0.80]$ 毫米。因此，行间距 $\\Delta j = 0.80$ 毫米，列间距 $\\Delta i = 0.80$ 毫米。\n        *   切片厚度 (0018,0050)：$\\Delta k = 1.5$ 毫米。\n        *   图像方向（患者）(0020,0037)：$[\\frac{\\sqrt{3}}{2}, \\frac{1}{2}, 0, -\\frac{1}{2}, \\frac{\\sqrt{3}}{2}, 0]$。这定义了行方向向量 $\\vec{F} = (\\frac{\\sqrt{3}}{2}, \\frac{1}{2}, 0)$ 和列方向向量 $\\vec{G} = (-\\frac{1}{2}, \\frac{\\sqrt{3}}{2}, 0)$。\n        *   图像位置（患者）(0020,0032)：对于体素 $(i, j, k) = (0, 0, 0)$，坐标为 $\\vec{P}_{000} = [-120, -90, -50]$ 毫米。\n        *   任务：求解方程 $\\begin{pmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix} = A \\begin{pmatrix} i \\\\ j \\\\ k \\\\ 1 \\end{pmatrix}$ 中的 $4 \\times 4$ 矩阵 $A$。\n    *   **步骤 2：使用提取的已知条件进行验证：**\n        *   该问题在科学上基于医学成像的DICOM标准和线性代数。所提供的值和概念在放射学和医学物理学中是标准的。\n        *   这个问题是适定的。构建变换矩阵所需的所有信息都已提供，并且目标已明确说明。\n        *   这个问题是客观的，使用了来自DICOM规范的精确、标准化的术语。\n        *   数据是一致的。例如，给定的方向向量 $\\vec{F}$ 和 $\\vec{G}$ 是单位向量并且相互正交，这符合图像平面标准正交基的要求。\n    *   **步骤 3：结论与行动：** 问题有效。我将继续进行求解。\n\n2.  **求解推导：**\n\n该问题要求推导一个 $4 \\times 4$ 的仿射变换矩阵 $A$，该矩阵将体素索引 $(i, j, k)$ 的齐次坐标映射到其在患者坐标系中的位置 $(x, y, z)$ 的齐次坐标。该变换定义为：\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz \\\\\n1\n\\end{pmatrix}\n=\nA\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk \\\\\n1\n\\end{pmatrix}\n$$\n矩阵 $A$ 的一般形式为：\n$$\nA =\n\\begin{pmatrix}\nM_{11}  M_{12}  M_{13}  T_x \\\\\nM_{21}  M_{22}  M_{23}  T_y \\\\\nM_{31}  M_{32}  M_{33}  T_z \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n其中，$3 \\times 3$ 子矩阵 $M$ 表示变换的缩放和旋转部分，向量 $\\vec{T} = (T_x, T_y, T_z)$ 表示平移部分。\n\n索引为 $(i, j, k)$ 的体素中心位置 $\\vec{P}(i, j, k) = (x, y, z)$ 可以表示为由索引缩放的基向量的线性组合，再加上一个对应于原点体素位置的偏移量。\n$$\n\\vec{P}(i,j,k) = \\vec{P}(0,0,0) + i \\cdot \\vec{d_i} + j \\cdot \\vec{d_j} + k \\cdot \\vec{d_k}\n$$\n这可以写成矩阵形式：\n$$\n\\begin{pmatrix}\nx \\\\\ny \\\\\nz\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n|  |  | \\\\\n\\vec{d_i}  \\vec{d_j}  \\vec{d_k} \\\\\n|  |  |\n\\end{pmatrix}\n\\begin{pmatrix}\ni \\\\\nj \\\\\nk\n\\end{pmatrix}\n+\n\\begin{pmatrix}\nP_{000,x} \\\\\nP_{000,y} \\\\\nP_{000,z}\n\\end{pmatrix}\n$$\n向量 $\\vec{d_i}$、$\\vec{d_j}$ 和 $\\vec{d_k}$ 是患者坐标系中分别对应体素索引 $i$、$j$ 和 $k$ 单位增量的位移向量。这些向量构成了矩阵 $A$ 的前三列。平移向量 $\\vec{T}$ 是原点体素 $\\vec{P}(0,0,0)$ 的坐标，构成了 $A$ 的第四列的前三个元素。\n\n我们现在将根据提供的DICOM属性确定这些向量。\n\n**1. 方向向量：**\nDICOM属性图像方向（患者） $(0020,0037)$ 提供了行轴和列轴的方向余弦。\n行方向向量 $\\vec{F}$ 对应于 $j$ 索引的增量。\n$$ \\vec{F} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} $$\n列方向向量 $\\vec{G}$ 对应于 $i$ 索引的增量。\n$$ \\vec{G} = \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} $$\n切片前进方向 $\\vec{H}$ 由行向量和列向量的叉积给出，$\\vec{H} = \\vec{F} \\times \\vec{G}$。\n$$ \\vec{H} = \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} \\times \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (\\frac{1}{2})(0) - (0)(\\frac{\\sqrt{3}}{2}) \\\\ (0)(-\\frac{1}{2}) - (\\frac{\\sqrt{3}}{2})(0) \\\\ (\\frac{\\sqrt{3}}{2})(\\frac{\\sqrt{3}}{2}) - (\\frac{1}{2})(-\\frac{1}{2}) \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{3}{4} + \\frac{1}{4} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} $$\n\n**2. 间距和缩放后的方向向量：**\n这些单位向量必须按各方向上体素之间的间距进行缩放。\n- $i$ 索引（列）的间距是像素间距的第二个值，$\\Delta i = 0.80 \\, \\text{mm} = \\frac{4}{5} \\, \\text{mm}$。\n- $j$ 索引（行）的间距是像素间距的第一个值，$\\Delta j = 0.80 \\, \\text{mm} = \\frac{4}{5} \\, \\text{mm}$。\n- $k$ 索引（切片）的间距是切片厚度，$\\Delta k = 1.5 \\, \\text{mm} = \\frac{3}{2} \\, \\text{mm}$。\n\n构成矩阵 $M$ 列的缩放向量是：\n- 对于索引 $i$：$\\vec{d_i} = \\Delta i \\cdot \\vec{G} = \\frac{4}{5} \\begin{pmatrix} -\\frac{1}{2} \\\\ \\frac{\\sqrt{3}}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} -\\frac{2}{5} \\\\ \\frac{2\\sqrt{3}}{5} \\\\ 0 \\end{pmatrix}$。这是 $M$ 的第一列。\n- 对于索引 $j$：$\\vec{d_j} = \\Delta j \\cdot \\vec{F} = \\frac{4}{5} \\begin{pmatrix} \\frac{\\sqrt{3}}{2} \\\\ \\frac{1}{2} \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} \\frac{2\\sqrt{3}}{5} \\\\ \\frac{2}{5} \\\\ 0 \\end{pmatrix}$。这是 $M$ 的第二列。\n- 对于索引 $k$：$\\vec{d_k} = \\Delta k \\cdot \\vec{H} = \\frac{3}{2} \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\\\ \\frac{3}{2} \\end{pmatrix}$。这是 $M$ 的第三列。\n\n**3. 平移向量：**\n平移向量 $\\vec{T}$ 由图像位置（患者）属性 $(0020,0032)$ 给出，该属性指定了体素 $(i,j,k)=(0,0,0)$ 中心的坐标。\n$$ \\vec{T} = \\vec{P}(0,0,0) = \\begin{pmatrix} -120 \\\\ -90 \\\\ -50 \\end{pmatrix} $$\n\n**4. 组装仿射矩阵A：**\n我们现在使用向量 $\\vec{d_i}$、$\\vec{d_j}$、$\\vec{d_k}$作为前三列，$\\vec{T}$ 作为第四列的平移部分，来组装 $4 \\times 4$ 矩阵 $A$。最后一行是 $[0, 0, 0, 1]$ 以完成齐次变换。\n$$\nA = \\begin{pmatrix}\n\\vec{d_i}  \\vec{d_j}  \\vec{d_k}  \\vec{T} \\\\\n0  0  0  1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n-\\frac{2}{5}  \\frac{2\\sqrt{3}}{5}  0  -120 \\\\\n\\frac{2\\sqrt{3}}{5}  \\frac{2}{5}  0  -90 \\\\\n0  0  \\frac{3}{2}  -50 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n题目要求按行主序给出该矩阵的十六个元素。\n各元素为：\n第1行：$[-\\frac{2}{5}, \\frac{2\\sqrt{3}}{5}, 0, -120]$\n第2行：$[\\frac{2\\sqrt{3}}{5}, \\frac{2}{5}, 0, -90]$\n第3行：$[0, 0, \\frac{3}{2}, -50]$\n第4行：$[0, 0, 0, 1]$\n将这些元素连接成一个单行向量，即构成最终答案。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-\\frac{2}{5}  \\frac{2\\sqrt{3}}{5}  0  -120  \\frac{2\\sqrt{3}}{5}  \\frac{2}{5}  0  -90  0  0  \\frac{3}{2}  -50  0  0  0  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在进行复杂的放射组学特征提取之前，确保输入数据的几何一致性是至关重要的一步。一个理想的 DICOM 图像序列，其所有切片都应具有统一的物理属性，例如像素间距、切片厚度和空间方向。本练习将让你亲手设计并实现一个“飞行前”一致性检查器，用以自动验证图像序列的几何完整性，这是防止后续分析中出现因数据不一致而导致错误的关键质量控制步骤。",
            "id": "4555330",
            "problem": "您的工作背景涉及影像组学中的医学影像存档与通信系统（PACS）和医学数字成像与通信（DICOM）。在特征提取之前，必须验证序列级别的几何一致性，以避免混合具有不兼容空间描述符的切片。一个序列是多个切片的集合。每个切片提供三个元数据元素：像素间距（两个值，分别表示行和列的间距，单位为毫米）、层厚（单位为毫米）以及图像方向（患者）（由六个实数组成，表示两个方向余弦向量，即行方向向量和列方向向量）。\n\n基本原理：\n- 在 DICOM 中，像素间距定义为图像平面上行和列方向上相邻像素中心之间的物理距离，单位为毫米。设切片 $i$ 的像素间距向量为 $\\mathbf{p}_i = \\left(p^{\\text{row}}_i, p^{\\text{col}}_i\\right)$，单位为毫米。\n- 层厚是名义上的切片宽度，单位为毫米，对于切片 $i$ 表示为 $t_i$。\n- 图像方向（患者）存储两个方向余弦：单位向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和 $\\mathbf{c}_i \\in \\mathbb{R}^3$，它们表示图像的行和列在患者坐标系中的方向。根据定义，$\\mathbf{r}_i$ 和 $\\mathbf{c}_i$ 应该是标准正交的，即 $\\lVert \\mathbf{r}_i \\rVert = 1$, $\\lVert \\mathbf{c}_i \\rVert = 1$ 且 $\\mathbf{r}_i \\cdot \\mathbf{c}_i = 0$。\n\n设计并实现一个序列的预检一致性检查器，如果违反以下任何条件，则标记为不一致：\n1. 跨切片的像素间距一致性：对于一个以毫米为单位的容差 $\\tau_{\\text{ps}}$，要求对所有切片 $i$ 都满足 $\\lVert \\mathbf{p}_i - \\mathbf{p}_0 \\rVert_{\\infty} \\le \\tau_{\\text{ps}}$，其中 $\\lVert \\cdot \\rVert_{\\infty}$ 是无穷范数，切片 0 是参考切片。\n2. 跨切片的层厚一致性：对于一个以毫米为单位的容差 $\\tau_{\\text{thick}}$，要求对所有切片 $i$ 都满足 $\\lvert t_i - t_0 \\rvert \\le \\tau_{\\text{thick}}$。\n3. 每个切片的图像方向（患者）标准正交性：对于一个无量纲的容差 $\\tau_{\\text{ortho}}$，要求对所有切片 $i$ 都满足 $\\lvert \\lVert \\mathbf{r}_i \\rVert - 1 \\rvert \\le \\tau_{\\text{ortho}}$、$\\lvert \\lVert \\mathbf{c}_i \\rVert - 1 \\rvert \\le \\tau_{\\text{ortho}}$ 和 $\\lvert \\mathbf{r}_i \\cdot \\mathbf{c}_i \\rvert \\le \\tau_{\\text{ortho}}$。\n4. 跨切片的图像方向（患者）一致性：对于一个无量纲的容差 $\\tau_{\\text{ori}}$，要求对所有切片 $i$ 满足以下条件之一：\n   $\\max\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i - \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}}$\n   或\n   $\\max\\left(\\lVert \\mathbf{r}_i + \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i + \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}}$，\n   这允许 $\\mathbf{r}$ 和 $\\mathbf{c}$ 同时发生符号翻转而不改变图像平面的方向。\n\n如果任何检查失败，则该序列必须被标记为不一致，否则为一致。将空序列视作不一致。\n\n使用以下容差：\n- $\\tau_{\\text{ps}} = 0.001$ 毫米，\n- $\\tau_{\\text{thick}} = 0.001$ 毫米，\n- $\\tau_{\\text{ortho}} = 0.001$，\n- $\\tau_{\\text{ori}} = 0.001$。\n\n测试套件：\n提供七个序列。每个切片由一个元组 $(\\mathbf{p}_i, t_i, \\mathbf{r}_i, \\mathbf{c}_i)$ 表示，其中 $\\mathbf{p}_i$ 是 $(p^{\\text{row}}_i, p^{\\text{col}}_i)$，单位为毫米；$t_i$ 的单位为毫米；$\\mathbf{r}_i$ 和 $\\mathbf{c}_i$ 是 $(x,y,z)$ 方向余弦。\n\n序列 1（一致，微小噪声在容差范围内）：\n- 切片 1：$\\mathbf{p}_1 = (0.7, 0.7)$， $t_1 = 2.5$， $\\mathbf{r}_1 = (1, 0, 0)$， $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (0.7000004, 0.7)$， $t_2 = 2.5000003$， $\\mathbf{r}_2 = (1, 0, 0)$， $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (0.7, 0.6999995)$， $t_3 = 2.5$， $\\mathbf{r}_3 = (1, 0, 0)$， $\\mathbf{c}_3 = (0, 1, 0)$。\n\n序列 2（像素间距不一致，一个切片超出容差）：\n- 切片 1：$\\mathbf{p}_1 = (0.7, 0.7)$， $t_1 = 2.5$， $\\mathbf{r}_1 = (1, 0, 0)$， $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (0.7009, 0.7)$， $t_2 = 2.5$， $\\mathbf{r}_2 = (1, 0, 0)$， $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (0.7, 0.702)$， $t_3 = 2.5$， $\\mathbf{r}_3 = (1, 0, 0)$， $\\mathbf{c}_3 = (0, 1, 0)$。\n\n序列 3（层厚不一致）：\n- 切片 1：$\\mathbf{p}_1 = (1.0, 1.0)$， $t_1 = 1.0$， $\\mathbf{r}_1 = (0, 1, 0)$， $\\mathbf{c}_1 = (1, 0, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (1.0, 1.0)$， $t_2 = 1.001$， $\\mathbf{r}_2 = (0, 1, 0)$， $\\mathbf{c}_2 = (1, 0, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (1.0, 1.0)$， $t_3 = 1.002$， $\\mathbf{r}_3 = (0, 1, 0)$， $\\mathbf{c}_3 = (1, 0, 0)$。\n\n序列 4（跨切片方向不一致）：\n- 切片 1：$\\mathbf{p}_1 = (0.9, 0.9)$， $t_1 = 3.0$， $\\mathbf{r}_1 = (1, 0, 0)$， $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (0.9, 0.9)$， $t_2 = 3.0$， $\\mathbf{r}_2 = (1, 0, 0)$， $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (0.9, 0.9)$， $t_3 = 3.0$， $\\mathbf{r}_3 = (1, 0, 0)$， $\\mathbf{c}_3 = (0, 0.999, 0.04472)$。\n\n序列 5（通过同时符号翻转实现方向一致）：\n- 切片 1：$\\mathbf{p}_1 = (0.8, 0.8)$， $t_1 = 4.0$， $\\mathbf{r}_1 = (1, 0, 0)$， $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (0.8, 0.8)$， $t_2 = 4.0$， $\\mathbf{r}_2 = (-1, 0, 0)$， $\\mathbf{c}_2 = (0, -1, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (0.8, 0.8)$， $t_3 = 4.0$， $\\mathbf{r}_3 = (-1, 0, 0)$， $\\mathbf{c}_3 = (0, -1, 0)$。\n\n序列 6（单切片，方向标准正交，根据定义跨切片一致）：\n- 切片 1：$\\mathbf{p}_1 = (0.6, 0.6)$， $t_1 = 5.0$， $\\mathbf{r}_1 = (0.70710678, 0.70710678, 0)$， $\\mathbf{c}_1 = (-0.70710678, 0.70710678, 0)$。\n\n序列 7（边界情况：像素间距差异恰好等于容差）：\n- 切片 1：$\\mathbf{p}_1 = (0.8, 0.8)$， $t_1 = 5.0$， $\\mathbf{r}_1 = (1, 0, 0)$， $\\mathbf{c}_1 = (0, 1, 0)$。\n- 切片 2：$\\mathbf{p}_2 = (0.801, 0.8)$， $t_2 = 5.0$， $\\mathbf{r}_2 = (1, 0, 0)$， $\\mathbf{c}_2 = (0, 1, 0)$。\n- 切片 3：$\\mathbf{p}_3 = (0.8, 0.799)$， $t_3 = 5.0$， $\\mathbf{r}_3 = (1, 0, 0)$， $\\mathbf{c}_3 = (0, 1, 0)$。\n\n程序行为要求：\n- 使用给定的容差实现上述四项检查。\n- 对于每个序列，输出一个布尔值：如果序列不一致（被标记），则为 $True$；如果一致，则为 $False$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $\\left[\\text{True},\\text{False},\\dots\\right]$）。由于布尔值没有单位，输出中不包含任何物理单位。\n\n您的程序不得读取任何输入，并且必须使用上面提供的、嵌入在代码中的测试套件值。程序必须确定性地运行，并以上述格式为七个序列生成布尔值。",
            "solution": "该问题要求设计并实现一个用于一系列医学图像的预检一致性检查器，特别是在影像组学中使用的 DICOM 标准背景下。一个序列只有当其所有组成切片都满足一组严格的几何标准时（无论是单个切片内部还是切片之间），才被视为一致。不一致的序列会被标记，以防止其用于后续的分析，因为这些分析要求高质量和同质性的数据。\n\n验证基于四项具体检查，任何一项失败都会导致整个序列被标记为不一致。该算法旨在系统地应用这些检查。\n\n首先，我们处理空序列的边缘情况。这样的序列不包含任何信息，并根据公理定义为不一致。对于非空序列，第一个切片（索引为 $i=0$）被指定为参考切片，所有其他切片都将与之比较以进行切片间的一致性检查。算法遍历序列中的每个切片，执行必要的检查。\n\n四项一致性检查的详细说明如下：\n\n1.  **图像方向（患者）标准正交性（切片内）**：这是最基本的检查，确保每个切片坐标系的几何完整性。对于每个切片 $i$，其行方向余弦向量 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和列方向余弦向量 $\\mathbf{c}_i \\in \\mathbb{R}^3$ 必须是标准正交的。此属性通过使用指定的容差 $\\tau_{\\text{ortho}}$ 的三个条件进行验证：\n    - 行向量必须是单位向量：$\\lvert \\lVert \\mathbf{r}_i \\rVert_2 - 1 \\rvert \\le \\tau_{\\text{ortho}}$，其中 $\\lVert \\cdot \\rVert_2$ 是欧几里得范数。\n    - 列向量必须是单位向量：$\\lvert \\lVert \\mathbf{c}_i \\rVert_2 - 1 \\rvert \\le \\tau_{\\text{ortho}}$。\n    - 行向量和列向量必须正交：$\\lvert \\mathbf{r}_i \\cdot \\mathbf{c}_i \\rvert \\le \\tau_{\\text{ortho}}$。\n    此检查对每个切片（包括参考切片）都执行。任何切片的失败都会立即使该序列无效。\n\n2.  **像素间距一致性（切片间）**：此检查确保平面内分辨率在整个序列中是均匀的。对于每个切片 $i$（其中 $i>0$），其像素间距向量 $\\mathbf{p}_i = (p^{\\text{row}}_i, p^{\\text{col}}_i)$ 与参考切片 $\\mathbf{p}_0$ 的像素间距向量进行比较。差异使用无穷范数（或最大范数）进行量化，$\\lVert \\mathbf{d} \\rVert_{\\infty} = \\max(\\lvert d_1 \\rvert, \\lvert d_2 \\rvert, \\dots)$。一致性的条件是：\n    $$ \\lVert \\mathbf{p}_i - \\mathbf{p}_0 \\rVert_{\\infty} \\le \\tau_{\\text{ps}} $$\n    其中 $\\tau_{\\text{ps}}$ 是像素间距容差。\n\n3.  **层厚一致性（切片间）**：这确保了整个序列中切片的厚度是恒定的。对于每个切片 $i$（其中 $i>0$），其厚度 $t_i$ 与参考厚度 $t_0$ 进行比较。条件是：\n    $$ \\lvert t_i - t_0 \\rvert \\le \\tau_{\\text{thick}} $$\n    其中 $\\tau_{\\text{thick}}$ 是层厚容差。\n\n4.  **图像方向（患者）一致性（切片间）**：此检查验证所有切片在空间上是否对齐于同一平面。任何切片 $i$（其中 $i>0$）的方向必须与参考切片 0 的方向匹配。允许一种特殊情况，即方向向量 $(\\mathbf{r}_i, \\mathbf{c}_i)$ 相对于参考向量 $(\\mathbf{r}_0, \\mathbf{c}_0)$ 同时翻转，即 $(\\mathbf{r}_i, \\mathbf{c}_i) \\approx (-\\mathbf{r}_0, -\\mathbf{c}_0)$，因为这代表相同的成像平面。该检查被表述为一个析取：如果一个切片的方向与参考方向几乎相同，或者与翻转后的参考方向几乎相同，则该切片是一致的。使用无穷范数进行向量比较，并设容差为 $\\tau_{\\text{ori}}$，条件是：\n    $$ \\max\\left(\\lVert \\mathbf{r}_i - \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i - \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}} \\quad \\lor \\quad \\max\\left(\\lVert \\mathbf{r}_i + \\mathbf{r}_0 \\rVert_{\\infty}, \\lVert \\mathbf{c}_i + \\mathbf{c}_0 \\rVert_{\\infty}\\right) \\le \\tau_{\\text{ori}} $$\n    如果这两个条件都不满足，则切片未通过此检查。\n\n实现过程会遍历整个序列。对于第一个切片（$i=0$），仅执行标准正交性检查。对于所有后续切片（$i>0$），执行所有四项检查。如果在任何点有任何检查失败，过程将终止，并将该序列标记为不一致（返回 `True`）。如果循环完成而没有任何失败，则该序列被视为一致（返回 `False`）。如果单切片序列通过了标准正交性检查，它就是一致的，因为切片间的比较不适用。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_series_consistency(series):\n    \"\"\"\n    Validates a DICOM series for geometric consistency.\n\n    Args:\n        series: A list of slices. Each slice is a tuple containing:\n                - p (np.array): Pixel spacing (row, col) in mm.\n                - t (float): Slice thickness in mm.\n                - r (np.array): Row direction cosine vector (x, y, z).\n                - c (np.array): Column direction cosine vector (x, y, z).\n\n    Returns:\n        bool: True if the series is inconsistent, False otherwise.\n    \"\"\"\n    # Define tolerances as per the problem statement\n    tau_ps = 0.001\n    tau_thick = 0.001\n    tau_ortho = 0.001\n    tau_ori = 0.001\n\n    # An empty series is inconsistent.\n    if not series:\n        return True\n\n    # Establish the first slice as the reference for inter-slice comparisons.\n    p0, t0, r0, c0 = series[0]\n\n    # Iterate through all slices to perform checks.\n    for i in range(len(series)):\n        pi, ti, ri, ci = series[i]\n\n        # Check 3: Image Orientation (Patient) orthonormality (for every slice).\n        # This check must pass for all slices, including the reference.\n        norm_r = np.linalg.norm(ri)\n        norm_c = np.linalg.norm(ci)\n        dot_rc = np.dot(ri, ci)\n\n        if (abs(norm_r - 1) > tau_ortho or\n            abs(norm_c - 1) > tau_ortho or\n            abs(dot_rc) > tau_ortho):\n            return True  # Inconsistent due to non-orthonormality.\n\n        # Inter-slice checks are only performed for slices after the reference slice (i > 0).\n        if i == 0:\n            continue\n\n        # Check 1: Pixel Spacing consistency\n        if np.linalg.norm(pi - p0, ord=np.inf) > tau_ps:\n            return True  # Inconsistent pixel spacing.\n\n        # Check 2: Slice Thickness consistency\n        if abs(ti - t0) > tau_thick:\n            return True  # Inconsistent slice thickness.\n\n        # Check 4: Image Orientation (Patient) consistency\n        # Check for same orientation\n        err_same = max(np.linalg.norm(ri - r0, ord=np.inf),\n                       np.linalg.norm(ci - c0, ord=np.inf))\n        \n        # Check for flipped orientation\n        err_flipped = max(np.linalg.norm(ri + r0, ord=np.inf),\n                          np.linalg.norm(ci + c0, ord=np.inf))\n        \n        # A slice is inconsistent if its orientation is neither same nor flipped.\n        if err_same > tau_ori and err_flipped > tau_ori:\n            return True  # Inconsistent orientation across slices.\n\n    # If all checks pass for all slices, the series is consistent.\n    return False\n\ndef solve():\n    \"\"\"\n    Defines the test suite and runs the consistency checker on each series.\n    \"\"\"\n    # Define the 7 test series from the problem statement.\n    # Each slice is a tuple: (pixel_spacing, slice_thickness, row_vector, col_vector)\n    test_cases = [\n        # Series 1 (consistent, small noise within tolerance)\n        [\n            (np.array([0.7, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7000004, 0.7]), 2.5000003, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7, 0.6999995]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n        # Series 2 (inconsistent pixel spacing)\n        [\n            (np.array([0.7, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7009, 0.7]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.7, 0.702]), 2.5, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n        # Series 3 (inconsistent slice thickness)\n        [\n            (np.array([1.0, 1.0]), 1.0, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n            (np.array([1.0, 1.0]), 1.001, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n            (np.array([1.0, 1.0]), 1.002, np.array([0.0, 1.0, 0.0]), np.array([1.0, 0.0, 0.0])),\n        ],\n        # Series 4 (inconsistent orientation across slices)\n        [\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.9, 0.9]), 3.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 0.999, 0.04472])),\n        ],\n        # Series 5 (consistent orientation via simultaneous sign flip)\n        [\n            (np.array([0.8, 0.8]), 4.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.8, 0.8]), 4.0, np.array([-1.0, 0.0, 0.0]), np.array([0.0, -1.0, 0.0])),\n            (np.array([0.8, 0.8]), 4.0, np.array([-1.0, 0.0, 0.0]), np.array([0.0, -1.0, 0.0])),\n        ],\n        # Series 6 (single slice, consistent by definition)\n        [\n            (np.array([0.6, 0.6]), 5.0, np.array([0.70710678, 0.70710678, 0.0]), np.array([-0.70710678, 0.70710678, 0.0])),\n        ],\n        # Series 7 (boundary case, consistent)\n        [\n            (np.array([0.8, 0.8]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.801, 0.8]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n            (np.array([0.8, 0.799]), 5.0, np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        ],\n    ]\n\n    # Calculate results for each test case.\n    results = [check_series_consistency(series) for series in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实的放射组学研究常常需要整合来自多个医疗机构的数据，而这些机构的数据标识规范可能存在巨大差异。简单的标识符（如检查号）由于存在重复使用、截断或应用不一致等问题，往往无法可靠地唯一标识一项检查。本练习模拟了一个常见且极具挑战性的数据协调难题，旨在促使你批判性地思考不同标识符的缺陷，并设计出一个安全、稳健的策略来构建一个稳定的研究队列，这对于开展可靠的多中心研究至关重要。",
            "id": "4555309",
            "problem": "一个放射组学联盟正在将来自 $3$ 家医院的计算机断層扫描研究聚合到一个单一的医学影像存档与通信系统 (PACS) 中。每个站点导出的医学数字成像与通信 (DICOM) 数据集具有以下特征。\n\n基本背景。在 DICOM 中，研究实例唯一标识符 (StudyInstanceUID) 是一种唯一标识符 (UID)，旨在每个研究全局唯一。而检查号 (Accession Number) 是由放射学信息系统 (RIS) 发布的影像检查申请的标识符，可能会跨时间或机构重复使用，并且可能因值表示 (Value Representation) 限制而被截断。去标识化流程可以保留、确定性地重新映射或非确定性地重新生成 UID。\n\n站点概况。站点 $A$ 分配的检查号 (Accession Number) 每年都会重复使用；DICOM 的检查号颁发者序列 (Issuer of Accession Number Sequence) 通常为空；去标识化过程会保留 StudyInstanceUID。站点 $B$ 使用长的字母数字检查号字符串；当写入 DICOM 时，它们会被截断至短字符串 (Short String) 的长度限制，导致冲突；去标识化过程以确定性的方式重新映射 StudyInstanceUID，并且在各次导出中保持一致。站点 $C$ 使用单个检查号 (Accession Number) 覆盖为期 $2$ 到 $3$ 天的多日方案，这些方案会产生多个研究（具有不同的 StudyInstanceUID）；对于同一底层研究，每次导出事件都会重新生成新的、非确定性的 StudyInstanceUID。在这 $3$ 个站点中，由于是可选填写，一些对象的检查号 (Accession Number) 字段为空。数据分两批到达，相隔数月；该联盟必须在批次内和批次间进行去重，并将标识符协调成一个适用于放射组学的稳定队列密钥。\n\n仅根据上述定义和实际的 DICOM/PACS 行为，哪种策略是在识别和协调跨机构和导出的唯一研究时最安全的，既能避免过度合并不相关的研究或拆分同一研究，又允许进行质量控制？\n\nA. 将检查号 (Accession Number) 在规范化大小写和去除标点后用作全局研究密钥，并通过与机构名称 (Institution Name) 串联来消除歧义。此方法倾向于临床申请的概念，并将统一相关的研究，同时避免因规范化导致的冲突。\n\nB. 在所有站点中将 StudyInstanceUID 用作全局研究密钥。对于导出时重映射会变化的站点 $C$，回退到使用 PatientID 来连接跨导出的同一研究的副本，因为患者在去标识化后是唯一且持久的。\n\nC. 使用复合键 $(\\text{source\\_site}, \\text{StudyInstanceUID})$ 作为批次内每个研究的主标识符。维护一个按站点划分的映射表，以便如果同一站点重新导出并更改了 StudyInstanceUID（如站点 $C$ 的情况），可以通过一个内容衍生的指纹 $H$ 来连接跨导出的研究。该指纹 $H$ 是根据每个实例的内容哈希值 $h$ 的多重集计算得出的，其中 $h$ 包括非个人健康信息的采集不变量和像素校验和（例如，串联每个实例的 Rows、Columns、Modality、Image Orientation 值以及 Pixel Data 的加密哈希值），并在哈希前进行排序。仅将检查号 (Accession Number) 用作辅助性质控属性，并在存在时考虑检查号颁发者序列 (Issuer of Accession Number Sequence)；绝不单纯基于检查号 (Accession Number) 进行合并。\n\nD. 由于重映射的可变性而丢棄 UID，并通过对检查号 (Accession Number) 和研究日期 (Study Date)（规范化为本地时间）进行聚类来识别研究，以便多日方案按日期边界拆分，同时保持同一临床申请的所有序列在各次导出中聚合在一起；这避免了与 UID 相关的不一致性。\n\n选择唯一的最佳选项。",
            "solution": "### 问题验证\n\n本节在提供解决方案之前，对问题陈述进行验证，这是一个强制性的先决条件。\n\n#### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n\n*   **目标：**为一个放射组学联盟，将来自 $3$ 家医院的计算机断层扫描 (CT) 研究聚合到一个单一的医学影像存档与通信系统 (PACS) 中。\n*   **机构：**站点 $A$、站点 $B$、站点 $C$。\n*   **数据交付：**数据分两批到达，相隔数月。\n*   **核心任务：**在批次内和批次间对研究进行去重，并将标识符协调成一个适用于放射组学的稳定队列密钥。\n*   **约束条件：**解决方案必须避免过度合并不相关的研究和拆分同一研究。它还必须允许进行质量控制。\n*   **DICOM 背景：**\n    *   `StudyInstanceUID`：旨在成为每个研究的全局唯一标识符 (UID)。\n    *   `Accession Number`：来自放射学信息系统 (RIS) 的影像检查申请的标识符。它可能会跨时间或机构重复使用，并且可能被截断。\n    *   `去标识化`：可以保留、确定性地重新映射或非确定性地重新生成 UID。\n*   **特定站点概况：**\n    *   **站点 $A$：**\n        *   `Accession Number` 每年都会重复使用。\n        *   `Issuer of Accession Number Sequence` 通常为空。\n        *   去标识化会保留 `StudyInstanceUID`。\n    *   **站点 $B$：**\n        *   长的字母数字 `Accession Number` 字符串被截断，导致冲突。\n        *   去标识化以确定性的方式重新映射 `StudyInstanceUID`，且在各次导出中保持一致。\n    *   **站点 $C$：**\n        *   单个 `Accession Number` 用于覆盖为期 $2$ 到 $3$ 天的多日方案，这些方案会生成多个不同的研究（每个研究都有一个唯一的 `StudyInstanceUID`）。\n        *   对于同一底层研究，每次导出时，去标识化都会重新生成新的、非确定性的 `StudyInstanceUID`。\n*   **通用情况：**在所有 $3$ 个站点中，一些 DICOM 对象的 `Accession Number` 字段为空。\n\n#### 步骤 2：使用提取的已知信息进行验证\n\n*   **科学依据：**该问题牢固地植根于医学信息学和数据工程领域。所描述的 DICOM 属性（`StudyInstanceUID`、`Accession Number`）、PACS 和去标识化流程的行为都非常真实，代表了多中心研究中常见的、有充分记录的挑战。\n*   **定义明确：**该问题定义明确。它提出了一个明确的目标（创建一个稳定的研究密钥），提供了具体的约束条件（不得过度合并/拆分），并详细说明了可用标识符的复杂行为。问题要求找到“最安全”的策略，其定义是遵守给定的约束条件。可以从可用选项中确定唯一的最佳实践。\n*   **客观性：**该问题使用医学影像信息学领域常见的精确、客观和技术性语言进行陈述。没有主观或基于意见的主张。\n*   **完整性与一致性：**该问题提供了足够的细节来系统地评估所提出的策略。每个站点的特征都是独特的，构成了一系列复杂但逻辑上一致的挑战，一个稳健的解决方案必须能够应对。设置中没有矛盾之处。例如，跨站点的 `StudyInstanceUID` 的不同行为（保留、确定性重映射、非确定性重新生成）是现实的场景。\n*   **现实性：**这个场景不仅是现实的，而且是研究联盟所面临的数据协调问题的典型代表。像 `Accession Number` 这样的标识符的不可靠性以及去标识化带来的复杂性是标准的关注点。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个科学上和技术上都合理的问题，它定义明确、客观且现实。我现在将继续进行解答。\n\n### 最优策略的推导\n\n目标是为所有站点和两个数据批次中的每个研究建立一个稳定、唯一的标识符。让我们分析一下主要可用标识符的适用性。\n\n1.  **`Accession Number` 的分析：**\n    *   在站点 $A$，它每年都会重复使用。单独使用 `Accession Number`，甚至与机构标识符结合使用 `($\\text{Site A}$, $\\text{Accession Number})$`，都会导致冲突和错误地合并不同年份的研究。\n    *   在站点 $B$，它被截断，导致冲突，即不同的原始检查号映射到相同的截断值。这将导致不相关研究的错误合并。\n    *   在站点 $C$，一个 `Accession Number` 与多个不同的研究相关联。将其用作密钥会导致严重的过度合并，将不同的研究混为一谈。\n    *   此外，该字段可能为空，使其无法用作主键。\n    *   **结论：** `Accession Number` 作为该联盟中唯一研究标识的主键是根本不可靠的。其使用必须限制在辅助性的、非决定性的角色，例如用于质量控制或手动审查。\n\n2.  **`StudyInstanceUID` 的分析：**\n    *   根据 DICOM 定义，这是预期的研究唯一标识符。\n    *   在站点 $A$，它被保留下来，使其成为来自该站点的研究的完美、稳定的密钥。\n    *   在站点 $B$，它被确定性地重新映射。这意味着对于一个给定的原始研究，重新映射的 `StudyInstanceUID` 在不同的导出（批次 $1$ 和批次 $2$）中始终相同。因此，它是聚合数据集中站点 $B$ 研究的稳定且唯一的标识符。\n    *   在站点 $C$，每次导出时它都会被非确定性地重新生成。这是关键的失败点。来自站点 $C$ 批次 $1$ 中的一个研究，在批次 $2$ 中重新导出时，将具有与完全相同的研究不同的 `StudyInstanceUID`。单靠 `StudyInstanceUID` 无法用于跨批次链接这些相同的研究。\n    *   **结论：** `StudyInstanceUID` 对于站点 $A$ 和 $B$ 是一个高度可靠的标识符，但对于站点 $C$ 的跨批次协调则失败。全局策略不能仅仅依赖它。\n\n3.  **综合一个稳健的策略：**\n    *   一个稳健的密钥必须能处理所有站点和批次。由于 `StudyInstanceUID` 在很大程度上是可靠的，策略应以此为基础，并配有 specific 机制来处理站点 $C$ 的失败情况。\n    *   为防止任何潜在的（尽管理论上不太可能）跨站点 UID 冲突，最安全的方法是使用复合键，例如 $(\\text{source\\_site}, \\text{StudyInstanceUID})$，作为初步标识符。\n    *   对于站点 $C$，要识别出批次 $2$ 中的研究与批次 $1$ 中的研究相同（尽管它们具有不同的 `StudyInstanceUID`），必须查看数据的*内容*。这需要为研究创建一个“指纹”或“内容哈希”，该哈希对于像 UID 重新生成这样的元数据更改是不变的。\n    *   一个研究的内容由其包含的图像（实例）集合定义。一个研究的稳健指纹，我们称之为 $H$，可以通过首先为每个实例生成一个哈希值 $h$，然后组合这些实例哈希值来计算得出。\n    *   实例哈希值 $h$ 应基于在给定的去标识化规则下不变的数据。这包括像素数据本身（可以使用像 SHA-256 这样的加密函数进行哈希）和非个人健康信息（PHI）的基本采集参数（例如，`Modality`、`Rows`、`Columns`、`Image Orientation`）。\n    *   为使研究级别的哈希 $H$ 具有确定性，实例哈希集合 $\\{h_1, h_2, ..., h_n\\}$ 必须以固定顺序组合。一种标准方法是在哈希整个序列之前对实例哈希进行排序：$H = \\text{hash}(\\text{sort}(\\{h_1, h_2, ..., h_n\\}))$。\n    *   最终策略将包括：\n        a. 对每个传入的研究，计算其内容哈希 $H$。\n        b. 维护一个映射表，将 $(\\text{source\\_site}, H)$ 链接到联盟的一个规范的、持久的研究标识符。\n        c. 对于站点 $A$ 和 $B$ , `StudyInstanceUID`是稳定的，可以用作主要识别手段，内容哈希 $H$ 则作为强大的验证工具。\n        d. 对于站点 $C$，内容哈希 $H$ 是链接两个批次中相同研究的*唯一*可靠方法。\n        e. `Accession Number` 应作为元数据存储以供手动审查，但绝不能用于自动合并逻辑。\n\n这个推导出的策略是在不过度合并或拆分研究的情况下处理指定条件的最安全、最稳健的方法。\n\n### 选项评估\n\n**A. 将检查号 (Accession Number) 在规范化大小写和去除标点后用作全局研究密钥，并通过与机构名称 (Institution Name) 串联来消除歧义。此方法倾向于临床申请的概念，并将统一相关的研究，同时避免因规范化导致的冲突。**\n\n这个选项存在根本性缺陷。它依赖于 `Accession Number`，而问题陈述明确指出该标识符不可靠：在站点 $A$ 重复使用，在站点 $B$ 因截断导致冲突，在站点 $C$ 代表多个研究。规范化不能解决截断、重用或一对多的关系。此策略将导致大规模的过度合并和错误的数据链接。\n\n**结论：** 错误。\n\n**B. 在所有站点中将 StudyInstanceUID 用作全局研究密钥。对于导出时重映射会变化的站点 $C$，回退到使用 PatientID 来连接跨导出的同一研究的副本，因为患者在去标识化后是唯一且持久的。**\n\n这个选项因两个主要原因而失败。首先，假设 `PatientID` 在去标识化后是持久且唯一的，这是不安全的，在多中心研究环境中通常是错误的；患者标识符通常是假名化的，且映射可能不稳定或不一致。其次，更关键的是，一个患者可以有多个不同的研究。使用 `PatientID` 来链接研究会错误地合并属于同一患者的所有研究，无法实现识别唯一*研究*的目标。例如，如果重新导出，患者的头部 CT 和腹部 CT 将被视为彼此的副本。\n\n**结论：** 错误。\n\n**C. 使用复合键 $(\\text{source\\_site}, \\text{StudyInstanceUID})$ 作为批次内每个研究的主标识符。维护一个按站点划分的映射表，以便如果同一站点重新导出并更改了 StudyInstanceUID（如站点 $C$ 的情况），可以通过一个内容衍生的指纹 $H$ 来连接跨导出的研究。该指纹 $H$ 是根据每个实例的内容哈希值 $h$ 的多重集计算得出的，其中 $h$ 包括非个人健康信息的采集不变量和像素校验和（例如，串联每个实例的 Rows、Columns、Modality、Image Orientation 值以及 Pixel Data 的加密哈希值），并在哈希前进行排序。仅将检查号 (Accession Number) 用作辅助性质控属性，并在存在时考虑检查号颁发者序列 (Issuer of Accession Number Sequence)；绝不单纯基于检查号 (Accession Number) 进行合并。**\n\n这个选项与从第一性原理推导出的稳健策略完全一致。它正确地识别了 `StudyInstanceUID` 和 `Accession Number` 的优缺点。它提议使用命名空间的 UID，这是一个好做法。最重要的是，它通过使用内容衍生的指纹 ($H$)，为问题中最困难的部分——跨批次协调站点 $C$ 的数据——提供了正确且技术上合理的解决方案。它还正确地将 `Accession Number` 降级为次要的、非合并的角色。此策略是最安全的，因为它对所描述的标识符相关问题具有最强的弹性。\n\n**结论：** 正确。\n\n**D. 由于重映射的可变性而丢棄 UID，并通过对检查号 (Accession Number) 和研究日期 (Study Date)（规范化为本地时间）进行聚类来识别研究，以便多日方案按日期边界拆分，同时保持同一临床申请的所有序列在各次导出中聚合在一起；这避免了与 UID 相关的不一致性。**\n\n这个选项很差。丢弃 `StudyInstanceUID` 是一个错误，因为它们对于站点 $A$ 和站点 $B$ 是完全有效的标识符。依赖 `Accession Number` 和 `Study Date` 是有问题的，因为站点 $B$ 存在截断问题，站点 $C$ 存在一对多问题。对于站点 $C$，“将同一临床申请的所有序列保持在一起”的目标与所需目标完全相反，因为它会合并不同的研究。按日期边界拆分是一种脆弱的启发式方法，很容易失败（例如，研究跨越午夜边界）。这种方法丢弃了可靠信息，并用不可靠的启发式方法取而代之。\n\n**结论：** 错误。",
            "answer": "$$\\boxed{C}$$"
        }
    ]
}