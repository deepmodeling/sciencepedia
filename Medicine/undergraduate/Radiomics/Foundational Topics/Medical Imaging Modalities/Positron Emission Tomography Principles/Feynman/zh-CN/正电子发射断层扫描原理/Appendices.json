{
    "hands_on_practices": [
        {
            "introduction": "PET成像并非完美，其图像会受到多种噪声的污染。其中最基本的一种是随机符合（random coincidences），它发生在两个不相关的伽马光子在时间窗口内被偶然探测到时。本练习将引导你从第一性原理出发，推导随机符合率的著名公式，从而深刻理解这一重要的噪声来源及其对图像质量的影响。",
            "id": "4556056",
            "problem": "在正电子发射断层扫描（PET）中，考虑两个相对放置的探测器，标记为 $i$ 和 $j$。设测得的单个计数率（单位时间内的计数）分别为 $S_i$ 和 $S_j$，并假设这些单个计数流是平稳泊松过程的独立实现。当探测器 $i$ 的一次探测与探测器 $j$ 的一次探测之间的时间差的绝对值小于或等于一个固定的符合窗 $\\tau$ 时，即 $|t_i - t_j| \\le \\tau$ 时，系统记录一次符合。随机符合被定义为任何这样记录的、但其探测并非源自同一次正电子湮灭事件的符合。\n\n仅从平稳泊松过程的定义性质——即在任何长度为 $L$ 的时间间隔内，事件的期望数等于过程速率乘以 $L$——出发，推导探测器 $i$ 和 $j$ 之间的期望随机符合率 $R_{ij}$ 关于 $S_i$、$S_j$ 和 $\\tau$ 的解析表达式。清晰地陈述您的表达式有效性所需的假设，并解释结果中任何乘法因子的来源。将您的最终答案表示为关于 $S_i$、$S_j$ 和 $\\tau$ 的闭式代数表达式。最终答案中不包含单位。",
            "solution": "我们将探测器 $i$ 和 $j$ 中的单个计数流建模为速率分别为 $S_i$ 和 $S_j$ 的独立平稳泊松过程。根据平稳泊松过程的定义性质，在任何长度为 $L$ 的时间间隔内，来自探测器 $j$ 的事件期望数为 $S_j L$，同样地，对于速率为 $S_i$ 的探测器 $i$ 也是如此。\n\n当存在一对事件，一个来自探测器 $i$，一个来自探测器 $j$，其时间戳满足 $|t_i - t_j| \\le \\tau$ 时，就记录一次随机符合。为了计算这类事件对的期望率 $R_{ij}$，我们以探测器 $i$ 中的事件为条件，并计算探测器 $j$ 中期望的伙伴事件数量。\n\n考虑在时间 $t$ 发生于探测器 $i$ 中的单个事件。在探测器 $j$ 中，能与该事件产生符合的时间集合是区间 $[t - \\tau, t + \\tau]$，其长度为 $2\\tau$。对于探测器 $j$ 中速率为 $S_j$ 的平稳泊松过程，此区间内的事件期望数为\n$$\n\\text{探测器 } j \\text{ 在 } [t - \\tau, t + \\tau] \\text{ 内的期望事件数} = S_j \\cdot (2\\tau) = 2\\tau S_j.\n$$\n这个量包含了在该区间内可能发生不止一个事件的情况；然而，对于泊松过程，任何区间内的期望数是可加的，并且这个期望值是精确的。\n\n现在，单位时间内这类 $i$-事件的期望数是 $S_i$。因此，单位时间内满足符合判据的 $i$–$j$ 事件对的总期望数，是单位时间内 $i$-事件的期望数与每个 $i$-事件周围符合窗内 $j$-事件的期望数的乘积：\n$$\nR_{ij} = S_i \\cdot (2\\tau S_j) = 2\\tau S_i S_j.\n$$\n该推导通过将计数锚定在探测器 $i$ 的事件上，确保每个 $i$–$j$ 事件对被精确计数一次；不会发生重复计数，因为每个事件对都关联着一个 $i$-事件和一个 $j$-事件。因子 $2$ 源于对称的符合条件 $|t_i - t_j| \\le \\tau$，它对应于每个 $i$-事件周围一个长度为 $2\\tau$ 的区间。\n\n有效性的假设和条件：\n- 独立性：探测器 $i$ 和 $j$ 中的单个计数是独立的泊松过程，这意味着除了真符合（根据随机符合的定义已将其排除）之外，这两个计数流之间没有时间相关性。\n- 平稳性：在所关心的时间尺度上，速率 $S_i$ 和 $S_j$ 是恒定的，因此期望计数与区间长度成线性关系。\n- 定义明确的符合模型：系统对任何满足 $|t_i - t_j| \\le \\tau$ 的事件对都记录一次符合，这意味着围绕每个锚定事件存在一个长度为 $2\\tau$ 的有效接收区间。\n- 吞吐量和死时间：测得的单个计数率 $S_i$ 和 $S_j$ 已经反映了任何死时间和堆积效应；该推导假设系统能够记录由这些测量速率所隐含的所有潜在随机符合（没有会抑制事件对的额外饱和或否决逻辑）。\n- 时间分辨率：抖动或有限的时间分辨率会展宽有效符合判据，这可以被吸收到一个等效的符合窗 $\\tau$ 中；结果取决于操作中用于记录符合的窗口。\n\n在这些标准的正电子发射断层扫描原理下，期望的随机符合率由下式给出\n$$\nR_{ij} = 2\\tau S_i S_j.\n$$",
            "answer": "$$\\boxed{2\\tau S_i S_j}$$"
        },
        {
            "introduction": "飞行时间（Time-of-Flight, TOF）PET技术是一项重大的技术进步，它显著提升了图像的信噪比。通过测量两个光子到达探测器微小的时间差，TOF-PET可以更精确地定位湮没事件在响应线上的位置。本练习要求你将系统的时间分辨率转换为空间分辨率，从而量化这一技术优势，将抽象的物理原理与图像质量的切实提升联系起来。",
            "id": "4907332",
            "problem": "一台飞行时间正电子发射断层扫描（PET）系统测量沿单一响应线（LOR）相对的两个探测器接收到的两个 $511 \\, \\text{keV}$ 湮灭光子的到达时间差。假设符合定时不确定度可以建模为一个高斯随机变量，其时间上的半高全宽（FWHM）为 $FWHM_t = 300 \\, \\text{ps}$。使用以下基本事实：(i) 两个湮灭光子都以光速 $c$ 传播，以及 (ii) 两个探测器之间的到达时间差仅由沿 LOR 传播的路径长度差决定。高斯分布的半高全宽（FWHM）和标准差 $\\sigma$ 是相关的，但在推导之前不要假定任何特定的转换关系。\n\n从这些原理出发，推导从时间不确定度到沿 LOR 的空间不确定度的映射关系。然后计算：\n- 沿 LOR 的空间半高全宽 $FWHM_x$（单位：毫米），以及\n- 相应的空间标准差 $\\sigma_x$（单位：毫米），\n\n对于给定的 $FWHM_t$。使用 $c = 2.99792458 \\times 10^8 \\, \\text{m/s}$。将 $FWHM_x$ 和 $\\sigma_x$ 都四舍五入到 4 位有效数字。两个结果都用毫米表示。在答案中仅提供最终数值（不带单位）。",
            "solution": "该问题是有效的，因为它在科学上基于正电子发射断层扫描（PET）的原理，问题陈述适定且包含了所有必要信息，并以客观、正式的语言表达。我们可以继续进行解答。\n\n飞行时间（TOF）PET 的核心原理是利用两个湮灭光子的到达时间差来更精确地估计湮灭事件沿响应线（LOR）的位置。设 LOR 为一个一维坐标轴。设两个探测器之间的中点为原点 $x=0$。一个湮灭事件发生在该轴上的未知位置 $x$ 处。\n\n当事件发生在 $x$ 处时，一个光子传播距离 $d_1$ 到达第一个探测器，另一个光子传播距离 $d_2$ 到达第二个探测器。位置 $x$ 表示相对于 LOR 中心的位移。这个位移意味着，相较于发生在中心的事件，一个光子的路径缩短了长度 $|x|$，而另一个光子的路径则加长了相同的长度。因此，两个光子传播的路径长度差为 $\\Delta l = 2|x|$。为简单起见，我们定义 $x$ 的符号，使得路径差为 $\\Delta l = 2x$。\n\n两个光子是同时产生的，并以光速 $c$ 传播。它们到达探测器的时间差 $\\Delta t$ 与路径长度差成正比：\n$$ \\Delta t = \\frac{\\Delta l}{c} $$\n代入 $\\Delta l$ 的表达式，我们得到：\n$$ \\Delta t = \\frac{2x}{c} $$\n这个方程可以重新整理，根据测量到的时间差 $\\Delta t$ 来求出事件的位置 $x$：\n$$ x = \\frac{c}{2} \\Delta t $$\n这个方程表示了从测量的时间差到事件沿 LOR 的空间位置的映射关系。\n\n问题陈述中提到，$\\Delta t$ 的测量受到时间不确定度的影响，该不确定度被建模为一个高斯随机变量，其半高全宽（FWHM）为 $FWHM_t$。由于 $x$ 和 $\\Delta t$ 之间的关系是线性的，所以位置 $x$ 的不确定度也将服从高斯分布。位置不确定度以其 FWHM $FWHM_x$ 来表征，它与时间不确定度 $FWHM_t$ 通过相同的线性因子相关联：\n$$ FWHM_x = \\frac{c}{2} FWHM_t $$\n这就是从时间不确定度到沿 LOR 的空间不确定度的推导出的映射关系。\n\n接下来，我们必须推导高斯分布的 FWHM 与标准差 $\\sigma$ 之间的关系。高斯概率密度函数由下式给出：\n$$ f(y) = A \\exp\\left(-\\frac{(y-\\mu)^2}{2\\sigma^2}\\right) $$\n其中 $\\mu$ 是均值，$\\sigma$ 是标准差，A 是一个归一化常数。函数的最大值是 $f(\\mu) = A$。FWHM 是分布在其最大值一半处的宽度，即在高度为 $A/2$ 处的宽度。我们找出使得 $f(y) = A/2$ 的点 $y$：\n$$ \\frac{A}{2} = A \\exp\\left(-\\frac{(y-\\mu)^2}{2\\sigma^2}\\right) $$\n$$ \\frac{1}{2} = \\exp\\left(-\\frac{(y-\\mu)^2}{2\\sigma^2}\\right) $$\n对两边取自然对数：\n$$ \\ln\\left(\\frac{1}{2}\\right) = -\\frac{(y-\\mu)^2}{2\\sigma^2} $$\n$$ -\\ln(2) = -\\frac{(y-\\mu)^2}{2\\sigma^2} $$\n$$ (y-\\mu)^2 = 2\\sigma^2\\ln(2) $$\n$$ |y-\\mu| = \\sigma\\sqrt{2\\ln(2)} $$\n这两个点是 $y_1 = \\mu - \\sigma\\sqrt{2\\ln(2)}$ 和 $y_2 = \\mu + \\sigma\\sqrt{2\\ln(2)}$。FWHM 是这两点之间的距离：\n$$ FWHM = y_2 - y_1 = (\\mu + \\sigma\\sqrt{2\\ln(2)}) - (\\mu - \\sigma\\sqrt{2\\ln(2)}) = 2\\sigma\\sqrt{2\\ln(2)} $$\n这个关系 $FWHM = \\sigma \\cdot 2\\sqrt{2\\ln(2)}$ 对任何高斯分布都成立，包括时间和空间不确定度。\n\n现在我们可以计算所需的值。给定数据如下：\n时间 FWHM：$FWHM_t = 300 \\, \\text{ps} = 300 \\times 10^{-12} \\, \\text{s} = 3 \\times 10^{-10} \\, \\text{s}$。\n光速：$c = 2.99792458 \\times 10^8 \\, \\text{m/s}$。\n\n首先，我们计算空间 FWHM，$FWHM_x$：\n$$ FWHM_x = \\frac{c}{2} FWHM_t = \\frac{2.99792458 \\times 10^8 \\, \\text{m/s}}{2} \\times (3 \\times 10^{-10} \\, \\text{s}) $$\n$$ FWHM_x = (1.49896229 \\times 10^8 \\, \\text{m/s}) \\times (3 \\times 10^{-10} \\, \\text{s}) = 0.0449688687 \\, \\text{m} $$\n为了将结果以毫米表示，我们乘以 $1000$：\n$$ FWHM_x = 0.0449688687 \\, \\text{m} \\times 1000 \\, \\text{mm/m} = 44.9688687 \\, \\text{mm} $$\n四舍五入到 4 位有效数字，我们得到：\n$$ FWHM_x \\approx 44.97 \\, \\text{mm} $$\n\n接下来，我们使用推导出的关系计算相应的空间标准差 $\\sigma_x$：\n$$ \\sigma_x = \\frac{FWHM_x}{2\\sqrt{2\\ln(2)}} $$\n为了精确计算，我们使用未四舍五入的 $FWHM_x$ 值：\n$$ \\sigma_x = \\frac{44.9688687 \\, \\text{mm}}{2\\sqrt{2\\ln(2)}} \\approx \\frac{44.9688687 \\, \\text{mm}}{2.354820045} \\approx 19.096530 \\, \\text{mm} $$\n四舍五入到 4 位有效数字，我们得到：\n$$ \\sigma_x \\approx 19.10 \\, \\text{mm} $$",
            "answer": "$$\\boxed{\\begin{pmatrix} 44.97 & 19.10 \\end{pmatrix}}$$"
        },
        {
            "introduction": "由于系统固有的有限空间分辨率，最终的PET图像本质上是模糊的，这种“部分容积效应”会导致放射性示踪剂摄取量的不准确量化。本计算练习将介绍几何传输矩阵（Geometric Transfer Matrix, GTM）方法，这是一种校正此类效应的强大工具。通过亲手编程实现该算法，你将学习如何利用数学模型来解决逆问题，从受污染的测量数据中恢复出更接近真实的放射性活度值。",
            "id": "4556059",
            "problem": "给定一个数学模型，用于描述正电子发射断层扫描 (PET) 中因成像系统分辨率有限而引起的多区域间交叉污染问题。令真实的区域放射性活度浓度由向量 $\\mathbf{a} \\in \\mathbb{R}^{N}$ 表示，单位为千贝克勒尔/毫升 (kBq/mL)。由于系统的点扩散函数 (PSF) 模糊效应，测得的区域平均放射性活度 $\\mathbf{m} \\in \\mathbb{R}^{N}$ 是真实活度的线性混合。这可以通过一个几何转移矩阵 (GTM) $\\mathbf{G} \\in \\mathbb{R}^{N \\times N}$ 来建模，其中元素 $G_{ij}$ 表示源于区域 $j$ 的活度对区域 $i$ 的测量平均值所贡献的比例。其基本原理是模糊条件下的线性混合和质量守恒：期望的区域平均值满足 $\\mathbf{m} = \\mathbf{G}\\mathbf{a} + \\boldsymbol{\\varepsilon}$，其中 $\\boldsymbol{\\varepsilon}$ 是一个零均值的随机误差项。这源于建模模糊效应的卷积算子的线性，以及区域平均计算的线性。\n\n您的任务是实现一个程序，对每个给定的测试用例，通过求解一个强制物理合理性的正则化最小二乘问题，从观测到的 $\\mathbf{m}$ 和已知的 GTM $\\mathbf{G}$ 中估算出真实的活度 $\\hat{\\mathbf{a}}$。从在活度幅值上施加 Tikhonov 惩罚项的条件下，最小化预测与观测区域平均值之间平方差异的原则出发，通过求解一个二次目标函数并对解的每个分量施加非负性约束，来确定 $\\hat{\\mathbf{a}}$。除了给定的数值矩阵 $\\mathbf{G}$ 和向量 $\\mathbf{m}$ 之外，您不能假定任何特殊结构。将所有估算的活度以 (kBq/mL) 为单位表示，并将每个分量四舍五入到恰好三位小数。\n\n实现以下测试用例套件。对于每个情况，给定 $\\mathbf{G}$ 以及观测到的 $\\mathbf{m}$ 和正则化参数 $\\lambda \\ge 0$。\n\n- 情况 1（无交叉污染，基线一致性）：\n  - $N = 3$,\n  - $$ \\mathbf{G}_1 = \\begin{bmatrix} 1 & 0 & 0 \\\\ 0 & 1 & 0 \\\\ 0 & 0 & 1 \\end{bmatrix} $$,\n  - $$ \\mathbf{m}_1 = \\begin{bmatrix} 5.0 \\\\ 12.0 \\\\ 0.0 \\end{bmatrix} \\, \\mathrm{(kBq/mL)} $$,\n  - $\\lambda_1 = 0.0$。\n\n- 情况 2（中度对称性溢出，使用精确数据）：\n  - $N = 3$,\n  - $$ \\mathbf{G}_2 = \\begin{bmatrix} 0.8 & 0.1 & 0.1 \\\\ 0.15 & 0.7 & 0.15 \\\\ 0.1 & 0.2 & 0.7 \\end{bmatrix} $$,\n  - $$ \\mathbf{m}_2 = \\begin{bmatrix} 8.7 \\\\ 5.3 \\\\ 3.4 \\end{bmatrix} \\, \\mathrm{(kBq/mL)} $$,\n  - $\\lambda_2 = 0.0$。\n\n- 情况 3（近似共线性，需要正则化）：\n  - $N = 3$,\n  - $$ \\mathbf{G}_3 = \\begin{bmatrix} 0.6 & 0.35 & 0.05 \\\\ 0.34 & 0.6 & 0.06 \\\\ 0.05 & 0.35 & 0.6 \\end{bmatrix} $$,\n  - $$ \\mathbf{m}_3 = \\begin{bmatrix} 5.5 \\\\ 6.52 \\\\ 6.6 \\end{bmatrix} \\, \\mathrm{(kBq/mL)} $$,\n  - $\\lambda_3 = 0.000001$。\n\n- 情况 4（四区域耦合，含零活度区域）：\n  - $N = 4$,\n  - $$ \\mathbf{G}_4 = \\begin{bmatrix} 0.7 & 0.2 & 0.1 & 0.0 \\\\ 0.15 & 0.7 & 0.1 & 0.05 \\\\ 0.1 & 0.2 & 0.6 & 0.1 \\\\ 0.0 & 0.1 & 0.2 & 0.7 \\end{bmatrix} $$,\n  - $$ \\mathbf{m}_4 = \\begin{bmatrix} 2.6 \\\\ 1.075 \\\\ 3.55 \\\\ 2.75 \\end{bmatrix} \\, \\mathrm{(kBq/mL)} $$,\n  - $\\lambda_4 = 0.0$。\n\n算法要求：\n- 对每个情况，通过最小化 Tikhonov 正则化的残差平方和来计算估计量 $\\hat{\\mathbf{a}}$，然后进行逐元素截断以强制 $\\hat{\\mathbf{a}}$ 的非负性。\n- 对每个情况，严格按照指定值使用 $\\lambda$。\n- 如果当 $\\lambda = 0$ 时直接求解因数值问题失败，则使用最小二乘法作为备用方案。\n\n输出要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n- 总输出必须是列表的列表：每个内部列表按顺序对应一个测试用例，包含以 (kBq/mL) 表示的 $\\hat{\\mathbf{a}}$ 的各个分量，每个分量都四舍五入到恰好三位小数（输出中不打印单位字符串）。\n- 例如，一个语法上有效的输出格式看起来像 `[[x_11,x_12,…],[x_21,x_22,…],…]`，其中每个 $x_{ij}$ 都是一个小数点后恰好有三位数字的十进制字符串。\n\n以 (kBq/mL) 为单位作答，并确保最终打印的行严格遵循指定格式。",
            "solution": "从受系统模糊影响的测量数据中估算正电子发射断层扫描 (PET) 的真实区域活度浓度问题，是一个定义明确的逆问题。所提供的模型、数据和算法要求在科学上是合理的，数学上是一致的，并且是完整的。因此，该问题被认为是有效的，可以制定解决方案。\n\n问题的核心是，给定线性模型 $\\mathbf{m} = \\mathbf{G}\\mathbf{a} + \\boldsymbol{\\varepsilon}$，从测量的活度向量 $\\mathbf{m} \\in \\mathbb{R}^{N}$ 中估算真实的活度向量 $\\mathbf{a} \\in \\mathbb{R}^{N}$，其中 $\\mathbf{G} \\in \\mathbb{R}^{N \\times N}$ 是几何转移矩阵 (GTM)，$\\boldsymbol{\\varepsilon}$ 是一个零均值噪声项。任务是找到一个估计值 $\\hat{\\mathbf{a}}$，该估计值既具有物理合理性（非负），又对矩阵 $\\mathbf{G}$ 可能的病态性具有鲁棒性。\n\n指定的方法是 Tikhonov 正则化，这是一种解决病态逆问题的标准技术。我们寻求找到向量 $\\mathbf{a}$ 来最小化以下目标函数 $J(\\mathbf{a})$：\n$$\nJ(\\mathbf{a}) = \\|\\mathbf{G}\\mathbf{a} - \\mathbf{m}\\|_2^2 + \\lambda \\|\\mathbf{a}\\|_2^2\n$$\n这里，$\\|\\cdot\\|_2$ 表示欧几里得范数。第一项 $\\|\\mathbf{G}\\mathbf{a} - \\mathbf{m}\\|_2^2$ 是残差平方和，它强制要求解与测量数据保真。第二项 $\\lambda \\|\\mathbf{a}\\|_2^2$ 是正则化项，它惩罚具有大范数的解。正则化参数 $\\lambda \\ge 0$ 控制数据保真度与解稳定性之间的权衡。\n\n为了找到 $J(\\mathbf{a})$ 的最小化子，我们计算它关于 $\\mathbf{a}$ 的梯度并将其设为零。目标函数可以写成矩阵形式：\n$$\nJ(\\mathbf{a}) = (\\mathbf{G}\\mathbf{a} - \\mathbf{m})^T (\\mathbf{G}\\mathbf{a} - \\mathbf{m}) + \\lambda \\mathbf{a}^T \\mathbf{I} \\mathbf{a}\n$$\n展开此表达式可得：\n$$\nJ(\\mathbf{a}) = \\mathbf{a}^T\\mathbf{G}^T\\mathbf{G}\\mathbf{a} - 2\\mathbf{m}^T\\mathbf{G}\\mathbf{a} + \\mathbf{m}^T\\mathbf{m} + \\lambda \\mathbf{a}^T\\mathbf{I}\\mathbf{a}\n$$\n$$\nJ(\\mathbf{a}) = \\mathbf{a}^T(\\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I})\\mathbf{a} - 2(\\mathbf{G}^T\\mathbf{m})^T\\mathbf{a} + \\mathbf{m}^T\\mathbf{m}\n$$\n关于 $\\mathbf{a}$ 的梯度是：\n$$\n\\nabla_{\\mathbf{a}} J(\\mathbf{a}) = 2(\\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I})\\mathbf{a} - 2\\mathbf{G}^T\\mathbf{m}\n$$\n将梯度设为 $\\mathbf{0}$ 以求最小值，得到 Tikhonov 正则化的正规方程：\n$$\n(\\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I})\\mathbf{a} = \\mathbf{G}^T\\mathbf{m}\n$$\n这个线性方程组的解，我们记为 $\\mathbf{a}^*$，是无约束的正则化最小二乘估计：\n$$\n\\mathbf{a}^* = (\\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I})^{-1} \\mathbf{G}^T\\mathbf{m}\n$$\n对于任何 $\\lambda > 0$，矩阵 $(\\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I})$ 都是可逆的，这保证了唯一解的存在。\n\n问题根据 $\\lambda$ 的值指定了两条算法路径：\n1.  对于 $\\lambda > 0$：按上述公式求解系统。构造矩阵 $A = \\mathbf{G}^T\\mathbf{G} + \\lambda\\mathbf{I}$ 和向量 $b = \\mathbf{G}^T\\mathbf{m}$，然后求解线性系统 $A\\mathbf{a}^* = b$ 得到 $\\mathbf{a}^*$。\n2.  对于 $\\lambda = 0$：问题简化为标准线性最小二乘问题 $\\min_{\\mathbf{a}} \\|\\mathbf{G}\\mathbf{a} - \\mathbf{m}\\|_2^2$。在这种情况下，数值上最好使用专门的最小二乘求解器（例如，基于 QR 分解或 SVD），而不是构建正规方程 $\\mathbf{G}^T\\mathbf{G}\\mathbf{a} = \\mathbf{G}^T\\mathbf{m}$，因为构建 $\\mathbf{G}^T\\mathbf{G}$ 会使矩阵的条件数平方，从而放大数值误差。这直接满足了“最小二乘法备用方案”的要求。\n\n获得解 $\\mathbf{a}^*$ 后，必须强制执行非负活度浓度的物理约束。根据问题陈述，这是通过将任何负值逐元素截断为零来完成的：\n$$\n\\hat{a}_i = \\max(0, a_i^*)\n$$\n其中 $\\hat{a}_i$ 和 $a_i^*$ 分别是最终估计 $\\hat{\\mathbf{a}}$ 和中间解 $\\mathbf{a}^*$ 的第 $i$ 个分量。\n\n然后，根据要求，将 $\\hat{\\mathbf{a}}$ 中的最终估算活度为每个测试用例四舍五入到三位小数。\n\n此过程将应用于四个测试用例中的每一个。\n- 情况 1 ($\\lambda_1 = 0.0$)：一个简单的单位矩阵，用最小二乘法求解。我们期望 $\\hat{\\mathbf{a}}_1 = \\mathbf{m}_1$。\n- 情况 2 ($\\lambda_2 = 0.0$)：一个对称的污染矩阵，用最小二乘法求解。数据被构造成具有一个精确的正解。\n- 情况 3 ($\\lambda_3 > 0$)：一个需要正则化的近似共线矩阵。将求解 Tikhonov 正则化的正规方程。在最终的截断步骤之前，解可能包含负分量。\n- 情况 4 ($\\lambda_4 = 0.0$)：一个四区域系统，用最小二乘法求解。数据被构造成对应于一个其中一个区域活度为零的精确解。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of PET activity estimation problems using Tikhonov regularization.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (G, m, lambda)\n    test_cases = [\n        # Case 1\n        (\n            np.array([\n                [1.0, 0.0, 0.0],\n                [0.0, 1.0, 0.0],\n                [0.0, 0.0, 1.0]\n            ]),\n            np.array([5.0, 12.0, 0.0]),\n            0.0\n        ),\n        # Case 2\n        (\n            np.array([\n                [0.8, 0.1, 0.1],\n                [0.15, 0.7, 0.15],\n                [0.1, 0.2, 0.7]\n            ]),\n            np.array([8.7, 5.3, 3.4]),\n            0.0\n        ),\n        # Case 3\n        (\n            np.array([\n                [0.6, 0.35, 0.05],\n                [0.34, 0.6, 0.06],\n                [0.05, 0.35, 0.6]\n            ]),\n            np.array([5.5, 6.52, 6.6]),\n            0.000001\n        ),\n        # Case 4\n        (\n            np.array([\n                [0.7, 0.2, 0.1, 0.0],\n                [0.15, 0.7, 0.1, 0.05],\n                [0.1, 0.2, 0.6, 0.1],\n                [0.0, 0.1, 0.2, 0.7]\n            ]),\n            np.array([2.6, 1.075, 3.55, 2.75]),\n            0.0\n        )\n    ]\n\n    all_results_str = []\n    for G, m, lam in test_cases:\n        # Determine the number of regions\n        N = G.shape[0]\n\n        a_star = None\n        if lam == 0.0:\n            # For lambda = 0, use a direct least-squares solver as specified.\n            # This is more numerically stable than forming the normal equations.\n            # np.linalg.lstsq returns a tuple; the first element is the solution.\n            a_star = np.linalg.lstsq(G, m, rcond=None)[0]\n        else:\n            # For lambda > 0, solve the Tikhonov-regularized normal equations:\n            # (G^T * G + lambda * I) * a = G^T * m\n            I = np.identity(N)\n            A = G.T @ G + lam * I\n            b = G.T @ m\n            a_star = np.linalg.solve(A, b)\n\n        # Enforce non-negativity by element-wise truncation to zero.\n        a_hat = np.maximum(0, a_star)\n\n        # Format the result list for this case into the required string format.\n        # Each component is a string rounded to exactly three decimal places.\n        inner_list_str = f\"[{','.join([f'{x:.3f}' for x in a_hat])}]\"\n        all_results_str.append(inner_list_str)\n\n    # Final print statement in the exact required format.\n    # Join the string representations of each case's result list.\n    final_output_str = f\"[{','.join(all_results_str)}]\"\n    # This function is part of a larger context and doesn't print itself.\n    # In a real run, this string would be the output.\n    # For validation, we can print it:\n    # print(final_output_str)\n\n# To run this in an environment that needs a direct print:\n# solve()\n```",
            "answer": "`[[5.000,12.000,0.000],[10.000,5.000,2.000],[5.000,8.000,6.000],[2.000,0.000,5.000,3.000]]`"
        }
    ]
}