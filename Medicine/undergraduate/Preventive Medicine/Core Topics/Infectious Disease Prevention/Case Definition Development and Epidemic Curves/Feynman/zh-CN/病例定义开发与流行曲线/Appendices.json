{
    "hands_on_practices": [
        {
            "introduction": "在流行病学调查中，病例定义是区分病例与非病例的基石。通常，我们不会只依赖单一的指标，而是会组合使用多种检测方法或临床标准。这个练习将带你探讨两种基本的组合策略——串联和并联检测——并计算它们如何影响最终病例定义的整体灵敏度（sensitivity）和特异度（specificity）。\n\n通过这个练习 ，你将掌握一个关键的权衡：串联检测（AND逻辑）以牺牲灵敏度为代价来提高特异度，以确保诊断的准确性；而并联检测（OR逻辑）则通过牺牲特异度来最大化灵敏度，以求发现所有可能的病例。",
            "id": "4507895",
            "problem": "一个呼吸道疫情调查小组正在制定一个病例定义，以构建每日新增病例的流行曲线。他们考虑采用一种双重检测算法，包括初步症状筛查，然后进行逆转录聚合酶链式反应 (RT-PCR) 检测。症状筛查的灵敏度为 $0.78$，特异度为 $0.65$，而 RT-PCR 的灵敏度为 $0.92$，特异度为 $0.98$。假设在给定疾病状态下，检测结果是条件独立的：对于患病个体，两次检测均为阳性的概率相乘；对于非患病个体，两次检测均为阳性的概率也相乘。\n\n正在考虑两种备选病例定义：\n- 串联（与）结构：仅当症状筛查和 RT-PCR 检测均为阳性时，才归类为病例。\n- 并联（或）结构：如果症状筛查或 RT-PCR 检测任一为阳性，则归类为病例。\n\n仅使用灵敏度和特异度作为正确分类的条件概率的核心定义以及所述的独立性假设，计算该双重检测算法在串联（与）和并联（或）结构下的联合灵敏度和联合特异度。请按以下顺序提供您的最终答案：串联灵敏度、串联特异度、并联灵敏度、并联特异度。请以小数形式表示您的答案（不要使用百分号），并四舍五入到四位有效数字。",
            "solution": "该问题要求计算一个双重检测算法在两种不同组合结构下（串联（与）和并联（或））的联合灵敏度和特异度。我们首先正式定义给定的参数，然后推导所需量的表达式。\n\n设 $D$ 为个体患病的事件，$D^c$ 为个体未患病的事件。设 $T_1$ 表示症状筛查，$T_2$ 表示 RT-PCR 检测。检测 $i$ 的阳性结果表示为 $T_i^+$，阴性结果表示为 $T_i^-$。\n\n一项检测的灵敏度是在个体患病的情况下检测结果为阳性的概率。一项检测的特异度是在个体未患病的情况下检测结果为阴性的概率。\n\n给定的灵敏度为：\n检测1的灵敏度：$S_1 = P(T_1^+ | D) = 0.78$\n检测2的灵敏度：$S_2 = P(T_2^+ | D) = 0.92$\n\n给定的特异度为：\n检测1的特异度：$C_1 = P(T_1^- | D^c) = 0.65$\n检测2的特异度：$C_2 = P(T_2^- | D^c) = 0.98$\n\n根据这些定义，我们可以推导出互补事件的概率：\n检测1的假阴性概率为 $P(T_1^- | D) = 1 - P(T_1^+|D) = 1 - S_1 = 1 - 0.78 = 0.22$。\n检测1的假阳性概率为 $P(T_1^+ | D^c) = 1 - P(T_1^-|D^c) = 1 - C_1 = 1 - 0.65 = 0.35$。\n检测2的假阴性概率为 $P(T_2^- | D) = 1 - P(T_2^+|D) = 1 - S_2 = 1 - 0.92 = 0.08$。\n检测2的假阳性概率为 $P(T_2^+ | D^c) = 1 - P(T_2^-|D^c) = 1 - C_2 = 1 - 0.98 = 0.02$。\n\n问题陈述了在给定疾病状态下，检测结果是条件独立的。这意味着对于 $T_1$ 的任何结果和 $T_2$ 的任何结果，它们在疾病状态下的联合条件概率是它们各自条件概率的乘积。例如，$P(T_1^+, T_2^+ | D) = P(T_1^+ | D) P(T_2^+ | D)$。\n\n**串联（与）结构**\n在串联结构中，当且仅当两次检测均为阳性时，个体才被归类为病例。如果事件 $T_1^+ \\cap T_2^+$ 发生，则总体检测结果为阳性。\n\n串联算法的联合灵敏度 $S_{serial}$ 是在个体患病的情况下，组合检测结果为阳性的概率：\n$$S_{serial} = P(T_1^+ \\cap T_2^+ | D)$$\n使用条件独立性假设：\n$$S_{serial} = P(T_1^+ | D) \\times P(T_2^+ | D) = S_1 \\times S_2$$\n代入给定值：\n$$S_{serial} = 0.78 \\times 0.92 = 0.7176$$\n\n串联算法的联合特异度 $C_{serial}$ 是在个体未患病的情况下，组合检测结果为阴性的概率。在串联算法中，阴性结果意味着并非两次检测都为阳性，即事件 $(T_1^+ \\cap T_2^+)^c = T_1^- \\cup T_2^-$。\n$$C_{serial} = P((T_1^+ \\cap T_2^+)^c | D^c) = 1 - P(T_1^+ \\cap T_2^+ | D^c)$$\n使用条件独立性假设：\n$$C_{serial} = 1 - \\left( P(T_1^+ | D^c) \\times P(T_2^+ | D^c) \\right) = 1 - (1 - C_1)(1 - C_2)$$\n代入给定值：\n$$C_{serial} = 1 - (1 - 0.65)(1 - 0.98) = 1 - (0.35)(0.02) = 1 - 0.007 = 0.993$$\n\n**并联（或）结构**\n在并联结构中，如果任一检测为阳性，则个体被归类为病例。如果事件 $T_1^+ \\cup T_2^+$ 发生，则总体检测结果为阳性。\n\n并联算法的联合灵敏度 $S_{parallel}$ 是在个体患病的情况下，组合检测结果为阳性的概率：\n$$S_{parallel} = P(T_1^+ \\cup T_2^+ | D)$$\n使用互补事件来计算这个概率更简单。“至少一个阳性”的互补事件是“两个都为阴性”，即 $(T_1^+ \\cup T_2^+)^c = T_1^- \\cap T_2^-$。\n$$S_{parallel} = 1 - P(T_1^- \\cap T_2^- | D)$$\n使用条件独立性假设：\n$$S_{parallel} = 1 - \\left( P(T_1^- | D) \\times P(T_2^- | D) \\right) = 1 - (1 - S_1)(1 - S_2)$$\n代入给定值：\n$$S_{parallel} = 1 - (1 - 0.78)(1 - 0.92) = 1 - (0.22)(0.08) = 1 - 0.0176 = 0.9824$$\n\n并联算法的联合特异度 $C_{parallel}$ 是在个体未患病的情况下，组合检测结果为阴性的概率。在并联算法中，阴性结果要求两次检测均为阴性，即事件 $T_1^- \\cap T_2^-$。\n$$C_{parallel} = P(T_1^- \\cap T_2^- | D^c)$$\n使用条件独立性假设：\n$$C_{parallel} = P(T_1^- | D^c) \\times P(T_2^- | D^c) = C_1 \\times C_2$$\n代入给定值：\n$$C_{parallel} = 0.65 \\times 0.98 = 0.637$$\n\n问题要求答案以小数形式表示，并四舍五入到四位有效数字。\n- 串联灵敏度：$S_{serial} = 0.7176$。这有四位有效数字。\n- 串联特异度：$C_{serial} = 0.993$。保留四位有效数字为 $0.9930$。\n- 并联灵敏度：$S_{parallel} = 0.9824$。这有四位有效数字。\n- 并联特异度：$C_{parallel} = 0.637$。保留四位有效数字为 $0.6370$。\n\n最终结果，按指定顺序（串联灵敏度、串联特异度、并联灵敏度、并联特异度）为 $0.7176$，$0.9930$，$0.9824$ 和 $0.6370$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.7176  0.9930  0.9824  0.6370\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "确立了病例定义后，下一步就是将其应用于原始数据（个案列表），并按时间汇总病例数，从而绘制出流行曲线。不同的病例定义——即使应用于完全相同的数据——也会产生形态各异的流行曲线。这个练习将让你亲手构建并量化比较两条由不同定义（一个严格，一个宽松）生成的流行曲线。\n\n通过这个实践 ，你将深刻体会到，流行曲线并非一个绝对的客观事实，而是通过特定病例定义这一“滤镜”观察到的疫情样貌。理解这一点对于批判性地解读和比较不同来源的监测数据至关重要。",
            "id": "4507891",
            "problem": "给定一个包含个体症状发作时间和代表临床与流行病学标准的二元属性的个案列表。您的任务是根据两种不同的病例定义构建流行曲线，使用归一化均方根误差比较它们随时间变化的形状，并报告每个测试用例的结果。此问题的科学基础是公共卫生监测中的病例定义概念以及作为新发病例按时间汇总计数的流行曲线。时间以天为单位，并表示为整数日期索引。您必须按天进行汇总，并将结果报告为保留六位小数的实数。\n\n定义与假设：\n- 流行曲线是在一个时间窗口内，满足给定病例定义的每日新发病例数的序列。给定一个包含发病时间的有限个案记录集，将时间窗口定义为给定个案列表中观察到的最小发病日到最大发病日（含）的范围。\n- 对于一个固定的时间窗口，其日期索引为 $t \\in \\{t_{\\min}, t_{\\min}+1, \\dots, t_{\\max}\\}$，令 $c_{A}(t)$ 和 $c_{B}(t)$ 表示在病例定义 A 和 B下的每日计数。\n- 均方根误差定义为\n$$\n\\mathrm{RMSE}(A,B) = \\sqrt{\\frac{1}{|T|} \\sum_{t \\in T} \\left(c_{A}(t) - c_{B}(t)\\right)^2},\n$$\n其中 $T$ 是窗口中所有日期的集合，而 $|T|$ 是天数。\n- 为了在无标度的基础上比较曲线，定义归一化常数\n$$\n\\mu = \\frac{1}{2}\\left(\\overline{c_{A}} + \\overline{c_{B}}\\right),\n$$\n其中 $\\overline{c_{A}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{A}(t)$ 且 $\\overline{c_{B}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{B}(t)$。\n- 则归一化均方根误差为\n$$\n\\mathrm{NRMSE}(A,B) =\n\\begin{cases}\n0,  \\text{if } \\mu = 0, \\\\[6pt]\n\\dfrac{\\mathrm{RMSE}(A,B)}{\\mu},  \\text{if } \\mu \\neq 0.\n\\end{cases}\n$$\n\n病例定义：\n- 病例定义 $A$（严格）：当且仅当同时出现发烧和咳嗽，并且至少存在实验室确诊或已知暴露史中的一项时，才纳入记录。使用二元变量 $F$（发烧）、$C$（咳嗽）、$S$（呼吸急促）、$L$（实验室确诊）和 $E$（已知暴露史），纳入规则为\n$$\nA: \\quad (F = 1) \\wedge (C = 1) \\wedge \\left((L = 1) \\vee (E = 1)\\right).\n$$\n- 病例定义 $B$（宽松）：当且仅当发烧、咳嗽或呼吸急促中至少存在一项，并且实验室确诊或已知暴露史中至少存在一项时，才纳入记录：\n$$\nB: \\quad \\left((F = 1) \\vee (C = 1) \\vee (S = 1)\\right) \\wedge \\left((L = 1) \\vee (E = 1)\\right).\n$$\n\n数据模型：\n- 个案列表中的每条记录都是一个形式为 $(d, F, C, S, L, E)$ 的元组，其中 $d$ 是以天为单位的整数发病日，$F, C, S, L, E \\in \\{0,1\\}$ 是二元指示符。\n- 时间单位是天。所有发病日 $d$ 都是以天为单位的整数。\n\n任务：\n- 对于每个提供的测试用例，在该测试用例的个案列表中，对从 $t_{\\min}$ 到 $t_{\\max}$（含）范围内的所有 $t$，通过计算每天 $t$ 包含的记录数来计算 $c_{A}(t)$ 和 $c_{B}(t)$。然后按上述定义计算 $\\mathrm{NRMSE}(A,B)$。\n- 将每个测试用例的最终结果表示为一个精确到六位小数的实数。\n\n测试套件：\n- 测试用例 $1$：\n  - 个案列表记录：\n    - $(0, 1, 1, 0, 1, 0)$\n    - $(0, 1, 0, 0, 1, 0)$\n    - $(1, 1, 1, 0, 0, 1)$\n    - $(1, 1, 0, 1, 0, 1)$\n    - $(2, 1, 1, 0, 0, 0)$\n    - $(2, 0, 1, 1, 1, 0)$\n    - $(3, 0, 0, 1, 0, 1)$\n    - $(3, 1, 1, 1, 1, 1)$\n    - $(4, 1, 1, 0, 1, 1)$\n    - $(5, 1, 1, 0, 0, 1)$\n    - $(6, 0, 0, 0, 1, 1)$\n    - $(7, 1, 0, 0, 0, 1)$\n    - $(8, 0, 1, 0, 1, 0)$\n    - $(9, 1, 1, 1, 0, 0)$\n- 测试用例 $2$：\n  - 个案列表记录：\n    - $(0, 1, 1, 0, 1, 0)$\n    - $(0, 1, 1, 0, 0, 1)$\n    - $(1, 1, 1, 0, 1, 1)$\n    - $(1, 0, 0, 1, 0, 0)$\n    - $(2, 1, 1, 0, 0, 0)$\n    - $(2, 1, 1, 1, 1, 1)$\n    - $(3, 0, 0, 0, 1, 1)$\n    - $(3, 1, 1, 0, 0, 1)$\n- 测试用例 $3$：\n  - 个案列表记录：\n    - $(5, 0, 1, 0, 1, 0)$\n- 测试用例 $4$：\n  - 个案列表记录：\n    - $(2, 0, 0, 0, 1, 1)$\n    - $(3, 1, 0, 0, 0, 0)$\n    - $(4, 0, 1, 1, 0, 0)$\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个值都精确到六位小数，并按测试用例 $1$、测试用例 $2$、测试用例 $3$、测试用例 $4$ 的顺序排列；例如，一个有效的格式是\n$$\n[\\text{value}_{1},\\text{value}_{2},\\text{value}_{3},\\text{value}_{4}].\n$$",
            "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于流行病学原理，特别是公共卫生监测、病例定义和流行曲线分析。该问题是适定的，提供了获得唯一且可验证解所需的所有必要定义、数据和数学公式。语言客观，结构逻辑清晰。\n\n解决方案是通过对每个测试用例执行一系列明确定义的计算步骤得出的。总体方法包括：\n1.  从提供的个案列表中确定监测时间窗口。\n2.  根据严格 (A) 和宽松 (B) 的病例定义对每个病例进行分类，并按天汇总计数，从而构建两条流行曲线 $c_A(t)$ 和 $c_B(t)$。\n3.  使用提供的公式计算两条曲线之间的归一化均方根误差 ($\\mathrm{NRMSE}$)。\n\n让我们详细说明这些步骤。\n\n**步骤1：确定时间窗口**\n对于每个测试用例，我们都得到一个记录的个案列表，其中每条记录都包含一个整数发病日 $d$。监测时间窗口 $T$ 是从观察到的最小发病日 $t_{\\min}$ 到最大发病日 $t_{\\max}$（含）的整数天数的集合。\n$$T = \\{t \\in \\mathbb{Z} \\mid t_{\\min} \\leq t \\leq t_{\\max}\\}$$\n该窗口的持续时间，即我们分析的时间点数量，为 $|T| = t_{\\max} - t_{\\min} + 1$。\n\n**步骤2：构建流行曲线**\n我们初始化两个向量 $c_A$ 和 $c_B$，它们代表每个定义下的每日病例数，长度为 $|T|$，所有元素都设置为 $0$。然后我们遍历个案列表中的每条记录 $(d, F, C, S, L, E)$。对于每条记录，我们评估对应于病例定义的两个布尔条件。\n\n严格病例定义 A 的条件是：\n$$ (F = 1) \\wedge (C = 1) \\wedge \\left((L = 1) \\vee (E = 1)\\right) $$\n宽松病例定义 B 的条件是：\n$$ \\left((F = 1) \\vee (C = 1) \\vee (S = 1)\\right) \\wedge \\left((L = 1) \\vee (E = 1)\\right) $$\n其中 $\\wedge$ 表示逻辑与，$\\vee$ 表示逻辑或。\n\n如果一条记录满足定义 A 的条件，我们就增加其发病日 $d$ 的计数。具体来说，我们在向量 $c_A$ 中增加索引为 $(d - t_{\\min})$ 的元素。同样，如果记录满足定义 B 的条件，我们就在向量 $c_B$ 中增加相应的元素。处理完所有记录后，向量 $c_A$ 和 $c_B$ 就代表了每日病例计数的离散时间序列，即流行曲线。\n\n**步骤3：NRMSE 计算**\n最后一步是计算 $\\mathrm{NRMSE}(A,B)$，它量化了两条曲线之间的形状差异，并按其平均水平进行归一化。\n\n首先，我们计算均方根误差 ($\\mathrm{RMSE}$)：\n$$ \\mathrm{RMSE}(A,B) = \\sqrt{\\frac{1}{|T|} \\sum_{t \\in T} \\left(c_{A}(t) - c_{B}(t)\\right)^2} $$\n这是两条曲线每日计数之间差值平方的均值的平方根。\n\n接下来，我们计算归一化因子 $\\mu$。这是两条曲线平均值的平均值。每条曲线的平均值由以下公式给出：\n$$ \\overline{c_{A}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{A}(t) \\quad \\text{and} \\quad \\overline{c_{B}} = \\frac{1}{|T|}\\sum_{t \\in T} c_{B}(t) $$\n那么归一化因子是：\n$$ \\mu = \\frac{1}{2}\\left(\\overline{c_{A}} + \\overline{c_{B}}\\right) $$\n\n最后，$\\mathrm{NRMSE}$ 是 $\\mathrm{RMSE}$ 与 $\\mu$ 的比值。定义了一个特殊情况，即当 $\\mu=0$ 时，这当且仅当对于所有 $t \\in T$，两条曲线都为零时发生。\n$$\n\\mathrm{NRMSE}(A,B) =\n\\begin{cases}\n0,  \\text{if } \\mu = 0 \\\\\n\\dfrac{\\mathrm{RMSE}(A,B)}{\\mu},  \\text{if } \\mu \\neq 0\n\\end{cases}\n$$\n每个测试用例的结果是此值，四舍五入到六位小数。\n\n**测试用例1的计算示例：**\n- **时间窗口**：发病日范围从 $d=0$ 到 $d=9$。因此，$t_{\\min}=0$，$t_{\\max}=9$，且 $|T|=10$。\n- **曲线构建**：根据定义处理所有 $14$ 条记录，得出以下每日计数：\n  - $c_A = [1, 1, 0, 1, 1, 1, 0, 0, 0, 0]$\n  - $c_B = [2, 2, 1, 2, 1, 1, 0, 1, 1, 0]$\n- **NRMSE 计算**：\n  - A 的总病例数：$\\sum c_A(t) = 5$。B 的总病例数：$\\sum c_B(t) = 11$。\n  - $\\overline{c_{A}} = 5/10 = 0.5$。\n  - $\\overline{c_{B}} = 11/10 = 1.1$。\n  - $\\mu = \\frac{1}{2}(0.5 + 1.1) = 0.8$。\n  - 差值向量为 $c_A - c_B = [-1, -1, -1, -1, 0, 0, 0, -1, -1, 0]$。\n  - 平方差向量为 $[1, 1, 1, 1, 0, 0, 0, 1, 1, 0]$。\n  - 平方差之和为 $6$。\n  - $\\mathrm{RMSE} = \\sqrt{6/10} = \\sqrt{0.6} \\approx 0.77459667$。\n  - $\\mathrm{NRMSE} = \\frac{0.77459667}{0.8} \\approx 0.96824584$。\n- **结果**：四舍五入到六位小数，结果为 $0.968246$。\n\n将此过程系统地应用于所有提供的测试用例，以得出最终答案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases by calculating the Normalized\n    Root Mean Square Error (NRMSE) between epidemic curves generated from\n    two different case definitions.\n    \"\"\"\n    test_cases = [\n        # Test Case 1\n        [\n            (0, 1, 1, 0, 1, 0), (0, 1, 0, 0, 1, 0), (1, 1, 1, 0, 0, 1),\n            (1, 1, 0, 1, 0, 1), (2, 1, 1, 0, 0, 0), (2, 0, 1, 1, 1, 0),\n            (3, 0, 0, 1, 0, 1), (3, 1, 1, 1, 1, 1), (4, 1, 1, 0, 1, 1),\n            (5, 1, 1, 0, 0, 1), (6, 0, 0, 0, 1, 1), (7, 1, 0, 0, 0, 1),\n            (8, 0, 1, 0, 1, 0), (9, 1, 1, 1, 0, 0)\n        ],\n        # Test Case 2\n        [\n            (0, 1, 1, 0, 1, 0), (0, 1, 1, 0, 0, 1), (1, 1, 1, 0, 1, 1),\n            (1, 0, 0, 1, 0, 0), (2, 1, 1, 0, 0, 0), (2, 1, 1, 1, 1, 1),\n            (3, 0, 0, 0, 1, 1), (3, 1, 1, 0, 0, 1)\n        ],\n        # Test Case 3\n        [\n            (5, 0, 1, 0, 1, 0)\n        ],\n        # Test Case 4\n        [\n            (2, 0, 0, 0, 1, 1), (3, 1, 0, 0, 0, 0), (4, 0, 1, 1, 0, 0)\n        ]\n    ]\n\n    results = []\n    for line_list in test_cases:\n        results.append(calculate_nrmse_for_case(line_list))\n\n    # Format the final output string exactly as specified.\n    formatted_results = ','.join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted_results}]\")\n\ndef calculate_nrmse_for_case(line_list):\n    \"\"\"\n    Calculates the NRMSE for a single test case's line list.\n\n    Args:\n        line_list: A list of tuples, where each tuple is a record\n                   (d, F, C, S, L, E).\n\n    Returns:\n        The calculated NRMSE value as a float.\n    \"\"\"\n    if not line_list:\n        return 0.0\n\n    data = np.array(line_list, dtype=int)\n    onset_days = data[:, 0]\n    \n    t_min = np.min(onset_days)\n    t_max = np.max(onset_days)\n    num_days = t_max - t_min + 1\n\n    counts_a = np.zeros(num_days, dtype=float)\n    counts_b = np.zeros(num_days, dtype=float)\n\n    for record in data:\n        d, f, c, s, l, e = record\n        \n        # Epidemiologic criteria: Lab confirmation or known exposure\n        epi_criterion = (l == 1) or (e == 1)\n\n        # Apply Case Definition A (strict)\n        # Fever AND Cough AND (Lab OR Exposure)\n        is_case_a = (f == 1) and (c == 1) and epi_criterion\n        if is_case_a:\n            counts_a[d - t_min] += 1\n\n        # Apply Case Definition B (broad)\n        # (Fever OR Cough OR Shortness of Breath) AND (Lab OR Exposure)\n        clinical_criterion_b = (f == 1) or (c == 1) or (s == 1)\n        is_case_b = clinical_criterion_b and epi_criterion\n        if is_case_b:\n            counts_b[d - t_min] += 1\n\n    # Calculate normalization factor mu\n    mean_a = np.mean(counts_a)\n    mean_b = np.mean(counts_b)\n    mu = 0.5 * (mean_a + mean_b)\n\n    # Handle the case where both curves are zero\n    if mu == 0:\n        return 0.0\n\n    # Calculate RMSE\n    squared_diff = (counts_a - counts_b) ** 2\n    mse = np.mean(squared_diff)\n    rmse = np.sqrt(mse)\n\n    # Calculate NRMSE\n    nrmse = rmse / mu\n    return nrmse\n\nsolve()\n```"
        },
        {
            "introduction": "在真实的长期监测项目中，监测方法并非一成不变。例如，病例定义可能会在疫情中途被更新，这会在流行曲线上造成人为的阶跃，从而掩盖疫情的真实增长趋势。为了准确评估疫情动态，我们需要识别并校正这些由方法学变更引入的系统性偏差。\n\n这个高级练习  引入了一种定量模型，用于估算和校正因病例定义变更而导致的计数不连续性。它展示了如何运用数学工具“看穿”数据假象，揭示背后真实的流行病学动态，并强调了在疫情调查中记录和量化方法学变更的重要性。",
            "id": "4507858",
            "problem": "一起急性传染病暴发通过按症状发作时间的周计数进行监测。在第 $t=0$ 周结束时，监测项目更新了病例定义，扩大了病例的发现范围。设 $O_t$ 表示流行病学第 $t$ 周（$t$ 为整数）的观测病例数，负数 $t$ 表示变更前的周，正数 $t$ 表示变更后的周。假设在一个较短的局部时间窗口内，真实发病率 $I_t$ 遵循指数动态模型 $I_t = I_0 \\exp(r t)$，在这些周内具有恒定的增长率 $r$，并且病例定义的更新导致发现率发生了一个不随时间变化的乘性变化，因子为 $k0$。形式上，对于变更前的周（$t0$），$O_t = \\alpha I_t$；对于变更后的周（$t0$），$O_t = k \\alpha I_t$。其中 $\\alpha0$ 是变更前的检出乘数；$I_0$、$r$、$\\alpha$ 和 $k$ 是未知常数。\n\n为避免过渡性伪影，第 $t=0$ 周被排除在外。观测到的周计数如下：\n- $O_{-3} = 81$，\n- $O_{-2} = 110$，\n- $O_{-1} = 148$，\n- $O_{+1} = 540$，\n- $O_{+2} = 729$。\n\n基于这些定义和假设（发病率呈指数增长，增长率 $r$ 恒定；$t=0$ 后发现率发生乘性、不随时间变化的偏移 $k$），首先仅使用对称周 $\\{t=-2,-1,+1,+2\\}$ 的数据，推导出一个消除了讨厌参数 $I_0$、$r$ 和 $\\alpha$ 的 $k$ 的估计量。然后，使用您估计的 $k$ 作为乘性可比性因子，将变更前 $t=-3$ 时的计数调整到变更后的标度上，即计算 $k \\times O_{-3}$。\n\n第 $t=-3$ 周的调整后计数是多少（以病例数表示）？将您最终的调整后计数四舍五入到四位有效数字。",
            "solution": "用户希望基于一个传染病暴发的数学模型来解决一个问题。\n\n### 步骤1：提取已知条件\n问题指明了以下模型和数据：\n- 第 `t` 周的真实发病率 `I_t` 由指数模型给出：$I_t = I_0 \\exp(r t)$，其中 `I_0` 和 `r` 是未知常数。\n- 观测病例数 `O_t` 通过一个检出乘数与真实发病率 `I_t` 相关。\n- 对于病例定义变更前的周（$t0$）：$O_t = \\alpha I_t$，其中 $\\alpha  0$ 是变更前的检出乘数。\n- 对于病例定义变更后的周（$t0$）：$O_t = k \\alpha I_t$，其中 $k  0$ 是乘性发现因子。\n- 第 $t=0$ 周被排除在分析之外。\n- 未知常数是 $I_0$、$r$、$\\alpha$ 和 $k$。\n- 观测到的周计数为：$O_{-3} = 81$、$O_{-2} = 110$、$O_{-1} = 148$、$O_{+1} = 540$、$O_{+2} = 729$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，采用了流行病学中常见的标准指数增长模型。由于病例定义修改导致病例发现率发生变化的概念，是一种符合实际的监测伪影。该问题在数学上是适定的；它提供了一个方程组和足够的数据来估计目标参数。语言客观、精确。所有术语都有明确定义。数据点与基础模型一致；例如，每个时期内连续项的比率几乎是恒定的：$O_{-1}/O_{-2} = 148/110 \\approx 1.345$ 且 $O_{+2}/O_{+1} = 729/540 = 1.35$，这支持了增长率 $r$ 恒定的假设。该问题并非无足轻重，需要系统性的推导来分离出参数 $k$。该问题被认为是有效的。\n\n### 步骤3：推导与求解\n\n第一个任务是仅使用来自对称周 $t \\in \\{-2, -1, +1, +2\\}$ 的数据，推导发现因子 $k$ 的估计量。必须消除讨厌参数 $I_0$、$r$ 和 $\\alpha$。\n\n让我们用模型参数来表示这些周的观测计数。\n对于 $t  0$：\n$O_t = \\alpha I_t = \\alpha I_0 \\exp(rt)$\n对于 $t=-1$：$O_{-1} = \\alpha I_0 \\exp(-r)$\n对于 $t=-2$：$O_{-2} = \\alpha I_0 \\exp(-2r)$\n\n对于 $t > 0$：\n$O_t = k \\alpha I_t = k \\alpha I_0 \\exp(rt)$\n对于 $t=+1$：$O_{+1} = k \\alpha I_0 \\exp(r)$\n对于 $t=+2$：$O_{+2} = k \\alpha I_0 \\exp(2r)$\n\n为了消除这些参数，我们可以构造这些观测值的比率。让我们对 $t0$ 的对称时间点 $t$ 和 $-t$ 的观测值求比。\n考虑 $t=1$ 时的比率：\n$$ \\frac{O_{+1}}{O_{-1}} = \\frac{k \\alpha I_0 \\exp(r)}{\\alpha I_0 \\exp(-r)} = k \\exp(2r) $$\n现在考虑 $t=2$ 时的比率：\n$$ \\frac{O_{+2}}{O_{-2}} = \\frac{k \\alpha I_0 \\exp(2r)}{\\alpha I_0 \\exp(-2r)} = k \\exp(4r) $$\n这样就得到了一个包含两个未知数 $k$ 和 $r$（或者更方便地，是 $k$ 和 $\\exp(2r)$）的方程组：\n1. $\\frac{O_{+1}}{O_{-1}} = k \\exp(2r)$\n2. $\\frac{O_{+2}}{O_{-2}} = k \\exp(4r) = k (\\exp(2r))^2$\n\n我们可以解这个方程组。从方程（1）中，我们可以用 $k$ 来表示 $\\exp(2r)$：\n$$ \\exp(2r) = \\frac{1}{k} \\frac{O_{+1}}{O_{-1}} $$\n将此表达式代入方程（2）：\n$$ \\frac{O_{+2}}{O_{-2}} = k \\left( \\frac{1}{k} \\frac{O_{+1}}{O_{-1}} \\right)^2 = k \\frac{1}{k^2} \\left( \\frac{O_{+1}}{O_{-1}} \\right)^2 = \\frac{1}{k} \\left( \\frac{O_{+1}}{O_{-1}} \\right)^2 $$\n现在我们可以解出 $k$：\n$$ k = \\frac{\\left( \\frac{O_{+1}}{O_{-1}} \\right)^2}{\\frac{O_{+2}}{O_{-2}}} = \\frac{O_{+1}^2}{O_{-1}^2} \\frac{O_{-2}}{O_{+2}} = \\frac{O_{+1}^2 O_{-2}}{O_{-1}^2 O_{+2}} $$\n这个 $k$ 的表达式就是所求的估计量，因为它仅依赖于指定周的观测计数，并消除了所有讨厌参数。\n\n现在，我们将给定的数值代入这个估计量：\n$O_{-2} = 110$\n$O_{-1} = 148$\n$O_{+1} = 540$\n$O_{+2} = 729$\n\n$$ k = \\frac{(540)^2 \\times 110}{(148)^2 \\times 729} $$\n为简化计算，我们可以注意到 $540 = 20 \\times 27$ 且 $729 = 27^2$。\n$$ k = \\frac{(20 \\times 27)^2 \\times 110}{148^2 \\times 27^2} = \\frac{20^2 \\times 27^2 \\times 110}{148^2 \\times 27^2} = \\frac{400 \\times 110}{148^2} $$\n此外，$148 = 4 \\times 37$。\n$$ k = \\frac{400 \\times 110}{(4 \\times 37)^2} = \\frac{400 \\times 110}{16 \\times 37^2} = \\frac{25 \\times 110}{37^2} = \\frac{2750}{1369} $$\n计算 $k$ 的数值：\n$$ k \\approx 2.0087655... $$\n\n第二个任务是使用估计出的 $k$ 来调整变更前 $t=-3$ 时的计数。调整后的计数是变更前的计数乘以可比性因子 $k$，从而有效地将其投影到变更后的发现标度上。\n调整后计数 = $k \\times O_{-3}$。\n已知 $O_{-3} = 81$。\n$$ \\text{调整后计数} = \\frac{2750}{1369} \\times 81 = \\frac{222750}{1369} \\approx 162.7099... $$\n\n最后一步是将此结果四舍五入到四位有效数字。前四位有效数字是 $1$、$6$、$2$ 和 $7$。第五位数字是 $0$，所以我们向下舍入。\n四舍五入到四位有效数字的调整后计数为 $162.7$。",
            "answer": "$$\\boxed{162.7}$$"
        }
    ]
}