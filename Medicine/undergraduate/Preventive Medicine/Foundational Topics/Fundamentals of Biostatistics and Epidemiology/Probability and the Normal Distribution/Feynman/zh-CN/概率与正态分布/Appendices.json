{
    "hands_on_practices": [
        {
            "introduction": "掌握正态分布的累积分布函数（CDF）是运用该分布解决实际问题的第一步。本练习旨在帮助你熟练使用标准正态CDF（通常表示为 $\\Phi(z)$）来计算一个变量落在特定区间内的概率。这项基本技能是后续更复杂统计推断（如假设检验和置信区间估计）的基石。",
            "id": "1956240",
            "problem": "在半导体制造的质量控制流程中，发现某种微芯片的归一化电噪声水平可以精确地用一个标准正态随机变量来建模，我们将其记为 $Z$。\n\n标准正态分布是一个连续概率分布，其概率密度函数为 $f(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{z^2}{2}\\right)$，其中 $-\\infty  z  \\infty$。随机变量 $Z$ 取值小于或等于某个常数 $c$ 的概率由其累积分布函数 (CDF) 给出，通常记为 $\\Phi(c) = P(Z \\le c)$。\n\n如果一个芯片的归一化噪声水平 $Z$ 严格介于一个正常数 $k$ 与该常数的两倍之间，即 $k  Z  2k$，则该芯片被定为“高性能”。\n\n求一个随机选取的微芯片被归类为“高性能”的概率的通用表达式。你的答案必须只用标准正态累积分布函数 $\\Phi$ 和参数 $k$ 来表示。",
            "solution": "设 $Z$ 为一个标准正态随机变量，其累积分布函数为 $\\Phi(c) = P(Z \\le c)$。一个芯片是“高性能”的事件为 $\\{k  Z  2k\\}$，其概率可以通过使用累积分布函数计算：$P(k  Z  2k) = P(Z \\le 2k) - P(Z \\le k) = \\Phi(2k) - \\Phi(k)$。",
            "answer": "$$\\boxed{\\Phi(2k)-\\Phi(k)}$$"
        },
        {
            "introduction": "在预防医学和公共卫生领域，我们不仅要估计人群的健康指标（如平均血糖水平），还要量化这些估计的不确定性。本练习将理论与实践相结合，指导你如何为一个总体均值构建置信区间，这是统计推断的核心应用之一。通过解决这个在公共卫生监测背景下提出的问题，你将学会如何应用t分布（正态分布的一个近亲）来处理样本数据，并正确解读置信水平的含义。",
            "id": "4563667",
            "problem": "一个社区预防医学项目通过定期筛查成年人的空腹血糖来进行公共卫生监测。在一次筛查中，根据一个旨在近似于从一个总体中进行独立同分布（iid）抽样的设计，获得了一个包含 $n = 25$ 名成年人的简单随机样本。设个体测量值为 $X_{1}, X_{2}, \\dots, X_{n}$，其中每个 $X_{i}$ 都被建模为来自具有共同均值 $\\mu$ 和方差 $\\sigma^{2}$ 的独立同分布正态分布，即 $X_{i} \\sim \\text{iid } N(\\mu, \\sigma^{2})$，且 $\\sigma^{2}$ 未知。该样本的样本均值为 $\\bar{x} = 102$ 毫克/分升 (mg/dL)，样本标准差为 $s = 18$ mg/dL。\n\n仅使用核心定义和关于正态模型下抽样分布的经过充分检验的事实，首先推导出当 $\\sigma^{2}$ 未知时 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式。然后，将 $\\alpha$ 特定为 $0.05$，并使用给定数据计算 $\\mu$ 的 $95\\%$ 置信区间的数值端点。将您的数值端点四舍五入到四位有效数字。用 mg/dL 表示最终的区间端点。\n\n最后，在监测的背景下解释该区间的覆盖特性：从业已实施的、在相同设计和总体条件下的重复多轮监测的角度，解释区间程序具有 $95\\%$ 覆盖率意味着什么。",
            "solution": "该问题陈述经评估是有效的。这是一个来自生物统计学领域的、有科学依据、提法明确且客观的问题。所有必要的数据（$n=25$，$\\bar{x}=102$，$s=18$）和条件（独立同分布正态模型，未知方差）都已提供，以推导和计算总体均值 $\\mu$ 的置信区间。任务明确：推导通用公式，计算特定的 $95\\%$ 区间，并解释结果。\n\n首先，我们推导当总体方差 $\\sigma^2$ 未知时，总体均值 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式。\n模型指出，个体测量值 $X_1, X_2, \\dots, X_n$ 是来自均值为 $\\mu$、方差为 $\\sigma^2$ 的正态分布的独立同分布（iid）样本，记为 $X_i \\sim N(\\mu, \\sigma^2)$。样本大小为 $n$。\n样本均值为 $\\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i$。根据正态分布的性质，样本均值 $\\bar{X}$ 也服从正态分布，其均值为 $\\mu$，方差为 $\\frac{\\sigma^2}{n}$，即 $\\bar{X} \\sim N(\\mu, \\frac{\\sigma^2}{n})$。\n\n由于 $\\sigma^2$ 未知，必须从样本中估计它。$\\sigma^2$ 的无偏估计量是样本方差，$S^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (X_i - \\bar{X})^2$。样本标准差是 $S = \\sqrt{S^2}$。\n\n枢轴量是样本数据和未知参数的函数，其分布不依赖于该参数。对于方差未知的正态样本，合适的枢轴量是 t-统计量：\n$$\nT = \\frac{\\bar{X} - \\mu}{S / \\sqrt{n}}\n$$\n根据统计学中的一个基本结果（通常与科克伦定理 (Cochran's theorem) 相关），该量 $T$ 服从自由度为 $\\nu = n-1$ 的学生 t-分布。我们将其表示为 $T \\sim t_{n-1}$。\n\n为了构建一个 $100(1-\\alpha)\\%$ 的置信区间，我们从 t-分布中找到一个临界值 $t_{n-1, \\alpha/2}$，使得值落在尾部的概率为 $\\alpha$。具体来说，$P(T  t_{n-1, \\alpha/2}) = \\alpha/2$。由于 t-分布关于 $0$ 的对称性，我们有：\n$$\nP(-t_{n-1, \\alpha/2}  T  t_{n-1, \\alpha/2}) = 1 - \\alpha\n$$\n代入 $T$ 的表达式：\n$$\nP\\left(-t_{n-1, \\alpha/2}  \\frac{\\bar{X} - \\mu}{S / \\sqrt{n}}  t_{n-1, \\alpha/2}\\right) = 1 - \\alpha\n$$\n我们现在整理不等式以分离出参数 $\\mu$：\n$$\n-t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}  \\bar{X} - \\mu  t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n从所有部分减去 $\\bar{X}$：\n$$\n-\\bar{X} - t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}  -\\mu  -\\bar{X} + t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n乘以 $-1$ 并反转不等号的方向：\n$$\n\\bar{X} + t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}} > \\mu > \\bar{X} - t_{n-1, \\alpha/2} \\cdot \\frac{S}{\\sqrt{n}}\n$$\n这就给出了 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间的解析表达式：\n$$\n\\left( \\bar{X} - t_{n-1, \\alpha/2} \\frac{S}{\\sqrt{n}}, \\bar{X} + t_{n-1, \\alpha/2} \\frac{S}{\\sqrt{n}} \\right)\n$$\n或者更紧凑地表示为 $\\bar{X} \\pm t_{n-1, \\alpha/2} \\frac{S}{\\sqrt{n}}$。\n\n接下来，我们将此结果应用于给定数据，并计算 $95\\%$ 的置信区间。\n给定的值为：\n样本大小 $n = 25$。\n样本均值 $\\bar{x} = 102$ mg/dL。\n样本标准差 $s = 18$ mg/dL。\n置信水平为 $95\\%$，所以 $1-\\alpha = 0.95$，这意味着 $\\alpha = 0.05$ 且 $\\alpha/2 = 0.025$。\n自由度为 $\\nu = n-1 = 25 - 1 = 24$。\n\n我们需要临界值 $t_{\\nu, \\alpha/2} = t_{24, 0.025}$。从标准 t-分布表或统计软件中，可以查到该值约为 $2.064$。\n$t_{24, 0.025} \\approx 2.064$。\n\n均值的标准误计算如下：\n$$\nSE(\\bar{x}) = \\frac{s}{\\sqrt{n}} = \\frac{18}{\\sqrt{25}} = \\frac{18}{5} = 3.6\n$$\n误差范围 (ME) 为：\n$$\nME = t_{24, 0.025} \\times SE(\\bar{x}) \\approx 2.064 \\times 3.6 = 7.4304\n$$\n置信区间的端点是：\n下限：$\\bar{x} - ME = 102 - 7.4304 = 94.5696$。\n上限：$\\bar{x} + ME = 102 + 7.4304 = 109.4304$。\n\n问题要求将端点四舍五入到四位有效数字。\n对于下限 $94.5696$，四位有效数字是 $9$、$4$、$5$ 和 $6$。下一位数字是 $9$，所以我们向上取整：$94.57$。\n对于上限 $109.4304$，四位有效数字是 $1$、$0$、$9$ 和 $4$。下一位数字是 $3$，所以我们不向上取整：$109.4$。\n$\\mu$ 的数值 $95\\%$ 置信区间为 $(94.57, 109.4)$ mg/dL。\n\n最后，我们解释该区间程序的覆盖特性。\n$95\\%$ 的置信水平指的是该方法的长期性能，而不是单个计算出的区间。在公共卫生监测项目的背景下，其解释如下：如果这个筛查过程（抽取一个包含 $n=25$ 名成年人的简单随机样本，并计算空腹血糖均值的 $95\\%$ 置信区间）在相同的总体条件下重复非常多次，那么这样构建的区间中约有 $95\\%$ 会包含真实但未知的总体血糖水平均值 $\\mu$。另外 $5\\%$ 的区间则不会捕获 $\\mu$。声称特定区间 $(94.57, 109.4)$ 有 $95\\%$ 的概率包含 $\\mu$ 是不正确的；一旦计算出来，这个区间要么包含 $\\mu$，要么不包含。概率是与生成区间的程序相关联的，而不是与单次实例的结果相关联。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n94.57  109.4\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "现代公共卫生研究日益依赖于计算机模拟来评估复杂干预措施的效果。本练习提供了一个高级的、计算性的实践，旨在让你掌握生成多元正态分布数据的方法，以模拟多个相互关联的风险因素（如血压和胆固醇）。通过完成这项任务，你不仅能加深对多元正态分布背后线性代数原理的理解，还将获得一项在蒙特卡洛模拟研究中至关重要的实用技能。",
            "id": "4563690",
            "problem": "一个公共卫生研究小组正在准备一项蒙特卡洛研究，以评估一个大型队列中的筛查策略。为了真实地反映经过标准变换后近似呈高斯分布的连续风险因素（例如，收缩压、身体质量指数和低密度脂蛋白胆固醇）的联合变异，他们需要模拟具有预先指定的均值向量和协方差矩阵的相关正态样本。目标是实现一个基于第一性原理的有原则的算法，该算法能生成具有给定均值向量和协方差矩阵的多元正态样本，然后使用基于抽样变异性证明其合理性的容差，将经验均值向量和协方差矩阵与其目标值进行验证。\n\n问题基本原理：\n- 多元正态分布的定义，以及独立标准正态变量的线性变换可产生一般多元正态变量的性质。\n- 协方差矩阵的性质，包括对称性和正定性，以及这类矩阵存在唯一可用于构造所需线性变换的下三角因子。\n- 从多元正态分布中进行独立同分布抽样的经验矩的抽样变异性，包括样本均值的方差以及当真实均值已知时最大似然协方差估计量的方差结构。\n\n您的任务是编写一个完整、可运行的程序，对于每个提供的测试用例，以纯数学和算法的方式执行以下步骤：\n\n1. 输入规范在程序内部固定（无外部输入）。对于每个测试用例，您会得到：\n   - 一个由均值向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^d$ 的长度所隐含的维度 $d$。\n   - 一个旨在为正定的对称协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{d \\times d}$。\n   - 样本量 $N \\in \\mathbb{N}$。\n   - 一个伪随机种子 $s \\in \\mathbb{N}$。\n\n2. 验证 $\\boldsymbol{\\Sigma}$ 是对称且正定的。如果 $\\boldsymbol{\\Sigma}$ 不是对称的或不是正定的，则该测试用例的结果必须是 $[\\text{False},\\text{False}]$。\n\n3. 使用正定性保证的唯一一个下三角因子，构造一个将独立标准正态抽样映射到均值为 $\\boldsymbol{\\mu}$、协方差为 $\\boldsymbol{\\Sigma}$ 的多元正态抽样的变换。使用以种子 $s$ 初始化的可复现伪随机数生成器生成 $N$ 个独立样本。\n\n4. 使用已知的目标均值 $\\boldsymbol{\\mu}$ 进行中心化，计算经验均值向量 $\\widehat{\\boldsymbol{\\mu}} \\in \\mathbb{R}^d$ 和最大似然协方差估计 $\\widehat{\\boldsymbol{\\Sigma}} \\in \\mathbb{R}^{d \\times d}$。\n\n5. 定义反映多元正态模型下抽样变异性的容差阈值：\n   - 对于均值，对每个分量 $j \\in \\{1,\\dots,d\\}$，定义容差\n     $$\\tau^{(\\mu)}_j = k_{\\mu} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{jj}}{N}},$$\n     其中 $k_{\\mu} \\in \\mathbb{R}$ 是一个固定乘数。使用 $k_{\\mu} = 4.0$。\n   - 对于协方差，对每个元素 $(i,j)$，定义容差\n     $$\\tau^{(\\Sigma)}_{ij} = k_{\\Sigma} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj}}{N}},$$\n     其中 $k_{\\Sigma} \\in \\mathbb{R}$ 是一个固定乘数。使用 $k_{\\Sigma} = 4.0$。\n\n6. 为每个测试用例确定两个布尔值：\n   - 一个均值接受布尔值，当且仅当对于所有 $j \\in \\{1,\\dots,d\\}$，都有 $|\\widehat{\\mu}_j - \\mu_j| \\le \\tau^{(\\mu)}_j$ 时，该值为 $\\text{True}$。\n   - 一个协方差接受布尔值，当且仅当对于所有 $i,j \\in \\{1,\\dots,d\\}$，都有 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}| \\le \\tau^{(\\Sigma)}_{ij}$ 时，该值为 $\\text{True}$。\n\n7. 最终的程序输出必须是单行，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是包含步骤 $6$ 中描述的两个布尔值的双元素方括号列表。例如，格式为\n   $$[\\,[b_{1,1},b_{1,2}],\\,[b_{2,1},b_{2,2}],\\,[b_{3,1},b_{3,2}],\\,[b_{4,1},b_{4,2}]\\,],$$\n   打印时不含空格，其中每个 $b_{k,\\ell}$ 为 $\\text{True}$ 或 $\\text{False}$。\n\n测试套件：\n- 案例 $1$（单位协方差，零均值）：\n  - $\\boldsymbol{\\mu} = [\\,0,\\,0,\\,0\\,]$。\n  - 相关矩阵 $\\mathbf{C}_1 = \\begin{bmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,1,\\,1,\\,1\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_1\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$ 等于单位矩阵。\n  - $N = 50000$。\n  - $s = 12345$。\n\n- 案例 $2$（实际的中等相关性）：\n  - $\\boldsymbol{\\mu} = [\\,120,\\,27,\\,130\\,]$。\n  - 相关矩阵 $\\mathbf{C}_2 = \\begin{bmatrix} 1  0.4  -0.2 \\\\ 0.4  1  0.3 \\\\ -0.2  0.3  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,12,\\,4,\\,25\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_2\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 60000$。\n  - $s = 2468$。\n\n- 案例 $3$（近奇异的高相关性）：\n  - $\\boldsymbol{\\mu} = [\\,50,\\,50,\\,50\\,]$。\n  - 相关矩阵具有恒定的非对角线元素 $r$: $\\mathbf{C}_3 = \\begin{bmatrix} 1  r  r \\\\ r  1  r \\\\ r  r  1 \\end{bmatrix}$，$r = 0.99$，标准差为 $\\boldsymbol{\\sigma} = [\\,10,\\,10,\\,10\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_3\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 80000$。\n  - $s = 13579$。\n\n- 案例 $4$（负相关和混合相关）：\n  - $\\boldsymbol{\\mu} = [\\,110,\\,23,\\,95\\,]$。\n  - 相关矩阵 $\\mathbf{C}_4 = \\begin{bmatrix} 1  -0.4  0.1 \\\\ -0.4  1  0.3 \\\\ 0.1  0.3  1 \\end{bmatrix}$ 和标准差 $\\boldsymbol{\\sigma} = [\\,8,\\,6,\\,5\\,]$，因此 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}_4\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$。\n  - $N = 70000$。\n  - $s = 97531$。\n\n实现约束：\n- 您必须为每个案例使用带有固定种子的伪随机生成器，以确保可复现性。\n- 在已知目标 $\\boldsymbol{\\mu}$ 处（而非样本均值）对协方差估计进行中心化，以与已知均值下的最大似然估计量保持一致。\n- 无外部输入或文件；所有参数均在程序内部定义。\n- 最终输出必须严格按照步骤 $7$ 中描述的格式打印为单行，不含空格。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[\\,[\\text{True},\\text{True}],\\,[\\text{True},\\text{False}]\\,]$），打印时不含空格。",
            "solution": "用户提供的问题被评估为有效。它在科学上基于多元统计理论，问题设定良好，目标明确，数据充分，并以客观、正式的语言表述。任务是实现并验证一个从多元正态分布生成样本的标准算法。\n\n### 理论框架\n\n从一般多元正态分布生成样本是基于该分布的一个基本性质。如果对于任意常数向量 $\\mathbf{a} \\in \\mathbb{R}^d$，线性组合 $\\mathbf{a}^T\\mathbf{X}$ 都是一个单变量正态随机变量，那么我们称一个 $d$ 维随机向量 $\\mathbf{X}$ 服从均值向量为 $\\boldsymbol{\\mu} \\in \\mathbb{R}^d$、协方差矩阵为 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{d \\times d}$ 的多元正态分布，记为 $\\mathbf{X} \\sim \\mathcal{N}_d(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$。\n\n生成此类样本的核心原理基于仿射变换性质。设 $\\mathbf{Z}$ 是一个 $d$ 维随机向量，其分量是独立同分布的标准正态随机变量，即对于 $i=1, \\dots, d$，有 $Z_i \\sim \\mathcal{N}(0, 1)$。$\\mathbf{Z}$ 的均值为 $\\mathbb{E}[\\mathbf{Z}] = \\mathbf{0}$，其协方差矩阵为 $\\mathbb{E}[\\mathbf{Z}\\mathbf{Z}^T] = \\mathbf{I}$，即单位矩阵。\n\n考虑 $\\mathbf{Z}$ 的一个线性变换，形式如下：\n$$ \\mathbf{X} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z} $$\n其中 $\\mathbf{L}$ 是一个 $d \\times d$ 的矩阵。$\\mathbf{X}$ 的均值为：\n$$ \\mathbb{E}[\\mathbf{X}] = \\mathbb{E}[\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}] = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbb{E}[\\mathbf{Z}] = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{0} = \\boldsymbol{\\mu} $$\n$\\mathbf{X}$ 的协方差矩阵为：\n$$ \\mathrm{Cov}(\\mathbf{X}) = \\mathbb{E}[(\\mathbf{X} - \\boldsymbol{\\mu})(\\mathbf{X} - \\boldsymbol{\\mu})^T] = \\mathbb{E}[(\\mathbf{L}\\mathbf{Z})(\\mathbf{L}\\mathbf{Z})^T] = \\mathbb{E}[\\mathbf{L}\\mathbf{Z}\\mathbf{Z}^T\\mathbf{L}^T] = \\mathbf{L}\\mathbb{E}[\\mathbf{Z}\\mathbf{Z}^T]\\mathbf{L}^T = \\mathbf{L}\\mathbf{I}\\mathbf{L}^T = \\mathbf{L}\\mathbf{L}^T $$\n为了生成具有目标协方差矩阵 $\\boldsymbol{\\Sigma}$ 的样本 $\\mathbf{X}$，我们必须找到一个矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^T$。\n\n### Cholesky分解\n\n寻找这样一个矩阵 $\\mathbf{L}$ 的一个标准且计算高效的方法是Cholesky分解。协方差矩阵 $\\boldsymbol{\\Sigma}$ 必须是对称且正定的。一个实对称矩阵 $\\boldsymbol{\\Sigma}$ 是正定的，当且仅当它能唯一地分解为一个对角线元素为正的下三角矩阵 $\\mathbf{L}$ 与其转置 $\\mathbf{L}^T$ 的乘积：\n$$ \\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^T $$\n该分解提供了所需的变换矩阵 $\\mathbf{L}$。这种唯一分解的存在性也是一种检验正定性的构造性方法。如果Cholesky分解算法成功，则矩阵是正定的；如果失败，则不是。\n\n### 算法与实现\n\n对每个测试用例，解决方案按以下步骤进行。\n\n1.  **输入规范与验证**：定义给定的目标均值向量 $\\boldsymbol{\\mu}$、相关矩阵 $\\mathbf{C}$、标准差向量 $\\boldsymbol{\\sigma}$、样本量 $N$ 和种子 $s$。通过关系式 $\\boldsymbol{\\Sigma} = \\mathrm{diag}(\\boldsymbol{\\sigma})\\,\\mathbf{C}\\,\\mathrm{diag}(\\boldsymbol{\\sigma})$ 构建协方差矩阵 $\\boldsymbol{\\Sigma}$。首先验证矩阵 $\\boldsymbol{\\Sigma}$ 的对称性，即我们检查是否 $\\boldsymbol{\\Sigma} = \\boldsymbol{\\Sigma}^T$。随后，通过尝试计算其Cholesky分解来确认其正定性。如果 $\\boldsymbol{\\Sigma}$ 不是对称的或分解失败，则该矩阵不是正定的，该测试用例的结果记录为 $[\\text{False}, \\text{False}]$。\n\n2.  **样本生成**：\n    - 使用指定的种子 $s$ 初始化一个伪随机数生成器以保证可复现性。\n    - 生成一个 $N \\times d$ 的独立标准正态样本矩阵 $\\mathbf{Z}_s$。$\\mathbf{Z}_s$ 的每一行代表从 $d$ 维标准正态分布中的一次抽样 $\\mathbf{z}^T$。\n    - 从有效的协方差矩阵 $\\boldsymbol{\\Sigma}$ 计算Cholesky因子 $\\mathbf{L}$。\n    - 使用该变换生成 $N$ 个来自 $\\mathcal{N}_d(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$ 的样本。设 $\\mathbf{X}$ 为生成的 $N \\times d$ 样本矩阵。$\\mathbf{X}$ 的第 $i$ 行，记为 $\\mathbf{x}_i^T$，计算公式为 $\\mathbf{x}_i^T = \\boldsymbol{\\mu}^T + \\mathbf{z}_i^T \\mathbf{L}^T$。用矩阵表示法，即为 $\\mathbf{X} = \\mathbf{1}\\boldsymbol{\\mu}^T + \\mathbf{Z}_s \\mathbf{L}^T$，其中 $\\mathbf{1}$ 是长度为 $N$ 的全一列向量。\n\n3.  **经验矩估计**：\n    - 经验均值向量 $\\widehat{\\boldsymbol{\\mu}}$ 通过对样本向量求平均来计算：\n      $$ \\widehat{\\boldsymbol{\\mu}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{x}_i $$\n    - 在已知总体均值 $\\boldsymbol{\\mu}$ 的情况下，协方差矩阵的最大似然估计计算如下：\n      $$ \\widehat{\\boldsymbol{\\Sigma}} = \\frac{1}{N} \\sum_{i=1}^N (\\mathbf{x}_i - \\boldsymbol{\\mu})(\\mathbf{x}_i - \\boldsymbol{\\mu})^T $$\n\n4.  **容差计算与验证**：\n    - **均值验证**：对于每个分量 $j \\in \\{1,\\dots,d\\}$，将绝对差 $|\\widehat{\\mu}_j - \\mu_j|$ 与容差 $\\tau_j^{(\\mu)}$ 进行比较。此容差与样本均值估计量 $\\widehat{\\mu}_j$ 的标准差成正比，其标准差为 $\\sqrt{\\boldsymbol{\\Sigma}_{jj}/N}$。容差设定为：\n      $$ \\tau_j^{(\\mu)} = k_{\\mu} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{jj}}{N}} $$\n      其中 $k_{\\mu} = 4.0$。如果对所有 $j$ 都有 $|\\widehat{\\mu}_j - \\mu_j| \\le \\tau_j^{(\\mu)}$ 成立，则均值接受布尔值为 $\\text{True}$。\n\n    - **协方差验证**：对于每个元素 $(i,j)$，将绝对差 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}|$ 与容差 $\\tau_{ij}^{(\\Sigma)}$ 进行比较。此容差与估计量 $\\widehat{\\Sigma}_{ij}$ 的标准差成正比，对于已知均值的正态分布，该标准差为 $\\sqrt{(\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj})/N}$。容差设定为：\n      $$ \\tau_{ij}^{(\\Sigma)} = k_{\\Sigma} \\sqrt{\\frac{\\boldsymbol{\\Sigma}_{ij}^2 + \\boldsymbol{\\Sigma}_{ii}\\boldsymbol{\\Sigma}_{jj}}{N}} $$\n      其中 $k_{\\Sigma} = 4.0$。如果对所有配对 $(i, j)$ 都有 $|\\widehat{\\Sigma}_{ij} - \\Sigma_{ij}| \\le \\tau_{ij}^{(\\Sigma)}$ 成立，则协方差接受布尔值为 $\\text{True}$。\n\n乘数 $k=4.0$ 意味着检查经验估计是否落在其期望值的 $4$ 个标准差之内。根据切比雪夫不等式，任何单次检查失败的概率小于 $1/k^2 = 1/16$，而对于高斯估计量，这个概率要小得多（约为 $6 \\times 10^{-5}$）。这使得检验很严格，但考虑了预期的抽样变异性。\n\n最终输出是一个列表，其中包含每个测试用例的一对布尔值 $[\\text{均值接受}, \\text{协方差接受}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multivariate normal simulation and validation problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: identity covariance, zero mean\n        {'mu': np.array([0., 0., 0.]),\n         'C': np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]),\n         'sigma_vec': np.array([1., 1., 1.]),\n         'N': 50000,\n         's': 12345},\n        # Case 2: realistic moderate correlations\n        {'mu': np.array([120., 27., 130.]),\n         'C': np.array([[1., 0.4, -0.2], [0.4, 1., 0.3], [-0.2, 0.3, 1.]]),\n         'sigma_vec': np.array([12., 4., 25.]),\n         'N': 60000,\n         's': 2468},\n        # Case 3: near-singular high correlation\n        {'mu': np.array([50., 50., 50.]),\n         'C': np.array([[1., 0.99, 0.99], [0.99, 1., 0.99], [0.99, 0.99, 1.]]),\n         'sigma_vec': np.array([10., 10., 10.]),\n         'N': 80000,\n         's': 13579},\n        # Case 4: negative and mixed correlations\n        {'mu': np.array([110., 23., 95.]),\n         'C': np.array([[1., -0.4, 0.1], [-0.4, 1., 0.3], [0.1, 0.3, 1.]]),\n         'sigma_vec': np.array([8., 6., 5.]),\n         'N': 70000,\n         's': 97531},\n    ]\n\n    results = []\n    k_mu = 4.0\n    k_Sigma = 4.0\n\n    for case in test_cases:\n        mu = case['mu']\n        C = case['C']\n        sigma_vec = case['sigma_vec']\n        N = case['N']\n        s = case['s']\n\n        # 1. Construct covariance matrix Sigma\n        D = np.diag(sigma_vec)\n        Sigma = D @ C @ D\n        \n        # 2. Validate Sigma: must be symmetric and positive definite\n        # Check symmetry\n        if not np.allclose(Sigma, Sigma.T):\n            results.append([False, False])\n            continue\n        \n        # Check positive definiteness by attempting Cholesky decomposition\n        try:\n            L = np.linalg.cholesky(Sigma)\n        except np.linalg.LinAlgError:\n            results.append([False, False])\n            continue\n\n        # 3. Generate samples\n        d = len(mu)\n        rng = np.random.default_rng(seed=s)\n        Z = rng.standard_normal(size=(N, d))\n        # X = mu + Z @ L.T\n        X = mu + Z.dot(L.T)\n\n        # 4. Compute empirical statistics\n        # Empirical mean\n        mu_hat = np.mean(X, axis=0)\n        \n        # Empirical covariance (MLE with known mean mu)\n        X_centered_known_mean = X - mu\n        # Sigma_hat = (X_centered_known_mean.T @ X_centered_known_mean) / N\n        Sigma_hat = np.cov(X_centered_known_mean, rowvar=False, ddof=0)\n        \n        # 5. Define tolerance thresholds\n        # Mean tolerance\n        tol_mu = k_mu * np.sqrt(np.diag(Sigma) / N)\n        \n        # Covariance tolerance\n        Sigma_ii = np.diag(Sigma).reshape(-1, 1)\n        Sigma_jj = np.diag(Sigma).reshape(1, -1)\n        Sigma_ii_jj = Sigma_ii @ Sigma_jj\n        tol_Sigma = k_Sigma * np.sqrt((np.square(Sigma) + Sigma_ii_jj) / N)\n\n        # 6. Determine acceptance booleans\n        mean_accepted = np.all(np.abs(mu_hat - mu) = tol_mu)\n        cov_accepted = np.all(np.abs(Sigma_hat - Sigma) = tol_Sigma)\n        \n        results.append([bool(mean_accepted), bool(cov_accepted)])\n\n    # 7. Format final output\n    formatted_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}