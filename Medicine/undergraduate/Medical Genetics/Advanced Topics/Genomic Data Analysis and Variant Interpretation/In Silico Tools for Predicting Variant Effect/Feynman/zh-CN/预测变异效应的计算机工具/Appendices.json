{
    "hands_on_practices": [
        {
            "introduction": "预测错义变异的影响是遗传学中的一个核心挑战。本练习将带你深入了解 SIFT (Sorting Intolerant From Tolerant) 这类工具背后的基本原理——进化保守性。通过从多序列比对的原始计数中推导出一个类似SIFT的分数，你将亲身体验如何量化保守性，并理解为何在处理有限数据时，像贝叶斯平滑这样的统计方法是至关重要的()。",
            "id": "5049990",
            "problem": "在一个人类蛋白质中，一个临床变异在一个跨同源序列高度保守的位置上被观察到。给定一个来自多序列比对（MSA）的有效列摘要，其中序列权重已被应用于校正冗余。该列包含以下残基的有效计数：丙氨酸（$\\mathrm{A}$）的计数为 $c_{\\mathrm{A}}=32$，缬氨酸（$\\mathrm{V}$）为 $c_{\\mathrm{V}}=12$，异亮氨酸（$\\mathrm{I}$）为 $c_{\\mathrm{I}}=4$，亮氨酸（$\\mathrm{L}$）为 $c_{\\mathrm{L}}=2$，所有其他氨基酸的计数为零。总有效计数为 $N=50$。假设使用贝叶斯平滑方法，通过强度为 $\\beta=10$ 的狄利克雷先验和背景氨基酸频率 $b_{i}$（使得 $\\sum_{i} b_{i}=1$）来估计该位置上可容忍残基的概率。脯氨酸（$\\mathrm{P}$）的背景频率为 $b_{\\mathrm{P}}=0.046$。\n\n从中心法则和进化保守性反映蛋白质序列功能约束的原理出发，根据比对计数和先验，推导出在该位置观察到脯氨酸的归一化后验概率，并将此概率解释为该位置特定取代 $\\mathrm{X} \\to \\mathrm{P}$（其中 $\\mathrm{X}$ 是参考残基）的 Sorting Intolerant From Tolerant (SIFT) 分数。在您的推导中，请论证对小样本或有偏样本使用贝叶斯平滑的合理性，并从保守性驱动的功能约束角度，解释使用概率阈值（通常为 $0.05$）来区分可能的不可容忍取代和可容忍取代的理由。\n\n使用所提供的数据，计算该位置脯氨酸的 SIFT 分数。将最终数值答案四舍五入到四位有效数字。将最终值表示为一个无单位的概率（不要使用百分号）。",
            "solution": "本题要求推导和计算一个 SIFT (Sorting Intolerant From Tolerant) 分数，该分数用于评估在蛋白质特定高度保守位置上发生脯氨酸取代的情况。在此，SIFT 分数的操作性定义为使用贝叶斯平滑方法估计的、在该位置观察到脯氨酸的归一化后验概率。\n\n此分析的起点是分子生物学的中心法则，该法则概述了遗传信息从 DNA 到 RNA 再到蛋白质的流动过程。蛋白质的氨基酸序列由其相应基因决定，进而决定其三维结构和生物学功能。进化保守性原理指出，蛋白质序列中对结构或功能至关重要的位置会受到强烈的负选择（纯化选择）。这意味着这些位置的突变通常是有害的，因此在进化过程中会从种群中被清除。因此，当在多序列比对（MSA）中比较来自不同物种的同源蛋白时，这些功能受限的位置表现出高度的保守性——即氨基酸的种类有限。SIFT 算法利用了这一原理，它假设在一个 MSA 的某个位置上很少观察到的氨基酸，如果通过新的突变引入，很可能在功能上是不可容忍的。\n\n题目提供了 MSA 中特定列的氨基酸有效计数：丙氨酸（$c_{\\mathrm{A}}=32$）、缬氨酸（$c_{\\mathrm{V}}=12$）、异亮氨酸（$c_{\\mathrm{I}}=4$）和亮氨酸（$c_{\\mathrm{L}}=2$）。所有这些都是非极性脂肪族氨基酸，这表明该位置对这类残基存在功能或结构上的约束。总有效计数为 $N = c_{\\mathrm{A}} + c_{\\mathrm{V}} + c_{\\mathrm{I}} + c_{\\mathrm{L}} = 32 + 12 + 4 + 2 = 50$。作为取代目标的脯氨酸，其计数为 $c_{\\mathrm{P}}=0$。\n\n对观察到脯氨酸的概率（$p_{\\mathrm{P}}$）进行朴素估计，将得到其相对频率：$p_{\\mathrm{P}} = \\frac{c_{\\mathrm{P}}}{N} = \\frac{0}{50} = 0$。这个零概率是有问题的，因为它意味着在该位置出现脯氨酸是绝对不可能的。这是一个基于有限且可能很小或有偏的序列样本得出的过于自信的结论。真实概率可能非常小，但并非为零。\n\n为了获得更稳健的估计，我们采用使用狄利克雷先验的贝叶斯平滑方法。该方法通过融入关于氨基酸分布的先验信念来正则化概率估计。在给定观测计数 $\\mathbf{c} = (c_1, c_2, \\dots, c_{20})$ 的条件下，观测到氨基酸 $i$ 的后验概率是通过将似然（来自数据）与狄利克雷先验分布相结合来计算的。狄利克雷先验由集中参数 $\\alpha_i$ 定义，其中 $\\alpha_i = \\beta b_i$。在这里，$\\beta$ 是先验的总强度（也称为伪计数），$b_i$ 是氨基酸 $i$ 在一个大型通用蛋白质语料库中的背景频率。\n\n氨基酸 $i$ 的后验概率，表示为 $P(i | \\mathbf{c})$，由以下公式给出：\n$$P(i | \\mathbf{c}) = \\frac{c_i + \\alpha_i}{\\sum_{j=1}^{20} (c_j + \\alpha_j)} = \\frac{c_i + \\beta b_i}{N + \\sum_{j=1}^{20} \\beta b_j}$$\n由于背景频率之和为一，即 $\\sum_{j=1}^{20} b_j = 1$，分母简化为 $N + \\beta$。因此，后验概率的最终公式为：\n$$P(i | \\mathbf{c}) = \\frac{c_i + \\beta b_i}{N + \\beta}$$\n这个公式可以解释为将伪计数（$\\beta b_i$）加到实际计数（$c_i$）上，然后进行归一化。这个过程通过将从观测数据中得到的估计概率拉向先验背景频率，从而“平滑”了分布，防止了未观测到的氨基酸出现零概率。\n\n我们需要计算脯氨酸（$\\mathrm{P}$）的这个概率。给定的值为：\n- 脯氨酸的观测计数，$c_{\\mathrm{P}} = 0$。\n- 总有效观测计数，$N = 50$。\n- 狄利克雷先验的强度，$\\beta = 10$。\n- 脯氨酸的背景频率，$b_{\\mathrm{P}} = 0.046$。\n\n将这些值代入公式，得到脯氨酸取代的 SIFT 分数：\n$$\\text{SIFT Score}(\\mathrm{X} \\to \\mathrm{P}) = P(\\mathrm{P} | \\mathbf{c}) = \\frac{c_{\\mathrm{P}} + \\beta b_{\\mathrm{P}}}{N + \\beta}$$\n$$\\text{SIFT Score}(\\mathrm{X} \\to \\mathrm{P}) = \\frac{0 + (10)(0.046)}{50 + 10}$$\n$$\\text{SIFT Score}(\\mathrm{X} \\to \\mathrm{P}) = \\frac{0.46}{60}$$\n$$P(\\mathrm{P} | \\mathbf{c}) = 0.007666...$$\n四舍五入到四位有效数字，SIFT 分数为 $0.007667$。\n\n然后通过与预定义的阈值（通常设为 $0.05$）进行比较来解释此分数。该阈值背后的基本原理植根于保守性驱动的功能约束。一个非常低的概率，比如计算出的这个值，表明与特异性观察到的氨基酸（A, V, I, L）和一般背景期望相比，脯氨酸在该位置的代表性极低。如此低的概率表明，强大的进化压力作用于该位点，排斥脯氨酸的存在。因此，引入脯氨酸的新突变被预测为“不可容忍的”，意味着它很可能破坏蛋白质的功能并产生有害影响。\n由于我们计算出的分数 $0.007667$ 小于阈值 $0.05$，因此脯氨酸取代将被分类为不可容忍或有害的。\n\n最终计算：\n$$ P(\\mathrm{P} | \\mathbf{c}) = \\frac{0.46}{60} \\approx 0.007667 $$",
            "answer": "$$\\boxed{0.007667}$$"
        },
        {
            "introduction": "除了改变蛋白质，遗传变异还可能通过破坏RNA剪接过程来影响基因功能。本练习聚焦于剪接位点的预测，这是一种关键的序列基元。你将使用位置权重矩阵（PWM）——一种捕捉序列基元中核苷酸偏好的强大模型——来精确计算一个点突变对剪接位点强度的影响，从而深入理解生物信息学工具如何量化变异的致病潜力()。",
            "id": "5049948",
            "problem": "一个基因在外显子-内含子边界处包含一个经典的供体剪接位点。在剪接过程中，一个序列窗口是真实剪接位点而非基因组背景的概率，可以通过使用位置权重矩阵（PWM）来建模，并假设每个位置的贡献是独立的。在此模型下，一个序列在剪接位点模型下的似然性与位置特异性核苷酸概率的乘积成正比，而在基因组背景模型下的似然性与背景核苷酸频率的乘积成正比。一个位点的强度由根据这些概率计算出的对数似然比得分 $S$ 来量化。点突变会改变单个位置的核苷酸，从而使 $S$ 改变 $\\Delta S$，突变后该位点为真位点的优势相对于突变前的倍数变化由 $\\exp(\\Delta S)$ 给出。\n\n考虑供体位点的$+2$位置，在参考序列中该位置的核苷酸是 $\\mathrm{T}$，在突变序列中是 $\\mathrm{C}$。用于真实供体位点的PWM在$+2$位置提供了以下位置特异性概率：$p_{+2}(\\mathrm{A})=0.02$, $p_{+2}(\\mathrm{C})=0.01$, $p_{+2}(\\mathrm{G})=0.03$, $p_{+2}(\\mathrm{T})=0.94$。基因组背景核苷酸频率为：$q(\\mathrm{A})=0.30$, $q(\\mathrm{C})=0.20$, $q(\\mathrm{G})=0.20$, $q(\\mathrm{T})=0.30$。\n\n从位置的独立性假设和似然比的定义出发，推导由$+2$位置的$\\mathrm{T}\\rightarrow\\mathrm{C}$突变引起的剪接位点强度变化 $\\Delta S$ 的表达式，并对其进行数值计算。然后计算该突变所隐含的似然比 $\\mathrm{LR}=\\exp(\\Delta S)$。将最终答案表示为小数，并四舍五入到四位有效数字。",
            "solution": "剪接位点的强度由对数似然比得分 $S$ 来量化。对于一个长度为 $L$、核苷酸为 $N_1, N_2, \\dots, N_L$ 的序列，得分 $S$ 定义为该序列在剪接位点模型（$M_{site}$）下的似然性与在基因组背景模型（$M_{bg}$）下的似然性之比的自然对数。\n\n在剪接位点模型下，假设位置独立，其似然性是每个位置 $i$ 上每个核苷酸 $N_i$ 的位置特异性概率 $p_i(N_i)$ 的乘积：\n$$L(\\text{sequence} | M_{site}) = \\prod_{i=1}^{L} p_i(N_i)$$\n在背景模型下，其似然性是背景频率 $q(N_i)$ 的乘积：\n$$L(\\text{sequence} | M_{bg}) = \\prod_{i=1}^{L} q(N_i)$$\n因此，对数似然比得分 $S$ 为：\n$$S = \\ln \\left( \\frac{L(\\text{sequence} | M_{site})}{L(\\text{sequence} | M_{bg})} \\right) = \\ln \\left( \\frac{\\prod_{i=1}^{L} p_i(N_i)}{\\prod_{i=1}^{L} q(N_i)} \\right)$$\n利用对数性质 $\\ln(a/b) = \\ln(a) - \\ln(b)$ 和 $\\ln(\\prod a_i) = \\sum \\ln(a_i)$，得分可以表示为位置特异性得分的总和：\n$$S = \\sum_{i=1}^{L} \\ln \\left( \\frac{p_i(N_i)}{q(N_i)} \\right)$$\n设参考序列表示为 $Seq_{ref}$，突变序列表示为 $Seq_{mut}$。这两个序列除了在$+2$位置外完全相同。在参考序列中，$+2$位置的核苷酸是 $\\mathrm{T}$，而在突变序列中是 $\\mathrm{C}$。\n\n参考序列的得分 $S_{ref}$ 是：\n$$S_{ref} = \\sum_{i \\neq +2} \\ln \\left( \\frac{p_i(N_i)}{q(N_i)} \\right) + \\ln \\left( \\frac{p_{+2}(\\mathrm{T})}{q(\\mathrm{T})} \\right)$$\n突变序列的得分 $S_{mut}$ 是：\n$$S_{mut} = \\sum_{i \\neq +2} \\ln \\left( \\frac{p_i(N_i)}{q(N_i)} \\right) + \\ln \\left( \\frac{p_{+2}(\\mathrm{C})}{q(\\mathrm{C})} \\right)$$\n剪接位点强度的变化 $\\Delta S$ 是突变序列得分与参考序列得分之差：\n$$\\Delta S = S_{mut} - S_{ref}$$\n$$\\Delta S = \\left[ \\sum_{i \\neq +2} \\ln \\left( \\frac{p_i(N_i)}{q(N_i)} \\right) + \\ln \\left( \\frac{p_{+2}(\\mathrm{C})}{q(\\mathrm{C})} \\right) \\right] - \\left[ \\sum_{i \\neq +2} \\ln \\left( \\frac{p_i(N_i)}{q(N_i)} \\right) + \\ln \\left( \\frac{p_{+2}(\\mathrm{T})}{q(\\mathrm{T})} \\right) \\right]$$\n由于其他所有位置的核苷酸未变，对这些位置的求和项相互抵消。这只留下了来自$+2$位置的得分贡献的变化。\n$$\\Delta S = \\ln \\left( \\frac{p_{+2}(\\mathrm{C})}{q(\\mathrm{C})} \\right) - \\ln \\left( \\frac{p_{+2}(\\mathrm{T})}{q(\\mathrm{T})} \\right)$$\n利用对数性质 $\\ln(a) - \\ln(b) = \\ln(a/b)$，我们得到 $\\Delta S$ 的推导表达式：\n$$\\Delta S = \\ln \\left( \\frac{p_{+2}(\\mathrm{C})/q(\\mathrm{C})}{p_{+2}(\\mathrm{T})/q(\\mathrm{T})} \\right) = \\ln \\left( \\frac{p_{+2}(\\mathrm{C}) \\cdot q(\\mathrm{T})}{p_{+2}(\\mathrm{T}) \\cdot q(\\mathrm{C})} \\right)$$\n现在我们代入给定的数值：\n- $+2$位置$\\mathrm{C}$的PWM概率: $p_{+2}(\\mathrm{C}) = 0.01$\n- $+2$位置$\\mathrm{T}$的PWM概率: $p_{+2}(\\mathrm{T}) = 0.94$\n- $\\mathrm{C}$的背景频率: $q(\\mathrm{C}) = 0.20$\n- $\\mathrm{T}$的背景频率: $q(\\mathrm{T}) = 0.30$\n\n将这些值代入 $\\Delta S$ 的表达式中：\n$$\\Delta S = \\ln \\left( \\frac{(0.01) \\cdot (0.30)}{(0.94) \\cdot (0.20)} \\right) = \\ln \\left( \\frac{0.003}{0.188} \\right)$$\n$$\\Delta S \\approx \\ln(0.0159574468)$$\n$$\\Delta S \\approx -4.1378$$\n问题要求计算隐含的似然比 $\\mathrm{LR} = \\exp(\\Delta S)$。这个值代表了序列是一个真实剪接位点与背景的优势的倍数变化。\n$$\\mathrm{LR} = \\exp(\\Delta S) = \\exp\\left( \\ln \\left( \\frac{p_{+2}(\\mathrm{C}) \\cdot q(\\mathrm{T})}{p_{+2}(\\mathrm{T}) \\cdot q(\\mathrm{C})} \\right) \\right)$$\n指数函数和自然对数函数是互为反函数，所以：\n$$\\mathrm{LR} = \\frac{p_{+2}(\\mathrm{C}) \\cdot q(\\mathrm{T})}{p_{+2}(\\mathrm{T}) \\cdot q(\\mathrm{C})} = \\frac{(0.01) \\cdot (0.30)}{(0.94) \\cdot (0.20)} = \\frac{0.003}{0.188}$$\n$$\\mathrm{LR} \\approx 0.0159574468$$\n问题要求将最终答案四舍五入到四位有效数字。第一位有效数字是$1$，第四位是$5$。随后的数字是$7$，大于等于$5$，所以我们将第四位有效数字向上取整。\n$$\\mathrm{LR} \\approx 0.01596$$\n这个结果表明，$+2$位置的$\\mathrm{T}\\rightarrow\\mathrm{C}$突变使该序列是真实剪接位点的似然性降低到原来的约$0.01596$倍，这是剪接位点强度的一次显著下降。",
            "answer": "$$\\boxed{0.01596}$$"
        },
        {
            "introduction": "现代的变异效应预测工具通常是集成了多种特征的复杂“黑箱”模型。理解模型为何做出某一特定预测，与预测本身同样重要。本项高级练习将指导你应用一种前沿的可解释人工智能（XAI）方法——SHAP，来剖析一个非线性致病性预测模型。通过从头计算每个特征（如保守性和结构信息）对特定变异评分的贡献，你将学会如何超越“接受”模型结果，进而“解释”其背后的决策依据()。",
            "id": "5049932",
            "problem": "给定一个用于单核苷酸变异的二元致病性预测器，该预测器表示为一个非线性逻辑斯蒂模型，结合了保守性、蛋白质结构、等位基因频率和剪接基序特征。目标是使用干预性背景边缘化程序，为一个特定变异计算 Shapley 可加性解释 (SHAP) 特征归因，并报告保守性和结构特征的贡献。\n\n该预测器定义如下。对于一个特征向量 $\\mathbf{x} = (x_1, x_2, x_3, x_4)$，其中 $x_1$ 是保守性得分，$x_2$ 是结构破坏得分，$x_3$ 是次要等位基因频率，$x_4$ 是剪接位点基序得分（每个都是 $[0,1]$ 范围内的实数），模型输出 $f(\\mathbf{x})$ 为\n$$\nf(\\mathbf{x}) = \\sigma\\!\\Big(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 \\sqrt{x_3} + \\beta_4 x_4 + \\beta_{12} x_1 x_2 + \\beta_{24} x_2 x_4 - \\beta_{13} x_1 \\sqrt{x_3}\\Big),\n$$\n其中 $\\sigma(t) = \\frac{1}{1 + e^{-t}}$ 是逻辑斯蒂 sigmoid 函数。系数固定如下：\n$$\n\\beta_0 = -1.0,\\quad \\beta_1 = 3.0,\\quad \\beta_2 = 2.5,\\quad \\beta_3 = -1.5,\\quad \\beta_4 = 1.2,\\quad \\beta_{12} = 1.8,\\quad \\beta_{24} = -1.0,\\quad \\beta_{13} = 0.7.\n$$\n\n您将使用合作博弈论中的 Shapley 值框架来计算 SHAP 归因。对于一个具有 $M$ 个特征（由集合 $N = \\{1,2,3,4\\}$ 索引）的模型，特征 $i \\in N$ 的 Shapley 值 $\\phi_i$ 定义为：\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|! \\, (M - |S| - 1)!}{M!} \\left( v(S \\cup \\{i\\}) - v(S) \\right),\n$$\n其中 $v(S)$ 是当只有集合 $S$ 中的特征被设置为变异的值，而所有其他特征被视为“缺失”时模型的值。在干预性背景边缘化方法中，$v(S)$ 是通过在一个给定的背景数据集上对模型输出进行平均来计算的，同时将不在 $S$ 中的所有特征替换为背景值：\n$$\nv(S) = \\frac{1}{K} \\sum_{b=1}^{K} f\\!\\left(\\mathbf{x}^{(S)}_b\\right),\n$$\n其中 $\\mathbf{x}^{(S)}_b$ 按分量定义为\n$$\n\\left(\\mathbf{x}^{(S)}_b\\right)_j = \\begin{cases}\nx^{\\text{variant}}_j,  \\text{if } j \\in S,\\\\\nx^{\\text{background}(b)}_j,  \\text{if } j \\notin S,\n\\end{cases}\n$$\n$K$ 是背景样本的数量。类似地，\n$$\nv(S \\cup \\{i\\}) = \\frac{1}{K} \\sum_{b=1}^{K} f\\!\\left(\\mathbf{x}^{(S \\cup \\{i\\})}_b\\right).\n$$\n\n所有特征都是 $[0,1]$ 范围内的无量纲分数，以小数形式表示。\n\n背景数据集 $\\mathcal{B}$（其中 $K = 5$）由以下特征向量给出：\n- $\\mathbf{b}_1 = (0.2,\\ 0.1,\\ 0.05,\\ 0.3)$,\n- $\\mathbf{b}_2 = (0.4,\\ 0.3,\\ 0.02,\\ 0.2)$,\n- $\\mathbf{b}_3 = (0.6,\\ 0.5,\\ 0.10,\\ 0.4)$,\n- $\\mathbf{b}_4 = (0.8,\\ 0.2,\\ 0.15,\\ 0.6)$,\n- $\\mathbf{b}_5 = (0.3,\\ 0.7,\\ 0.08,\\ 0.5)$.\n\n您必须为以下三个测试变异中的每一个计算 SHAP 值 $\\phi_1$（对应保守性）和 $\\phi_2$（对应结构）：\n- 变异 $A$：$\\mathbf{x}^{A} = (0.9,\\ 0.4,\\ 0.01,\\ 0.7)$,\n- 变异 $B$：$\\mathbf{x}^{B} = (0.5,\\ 0.95,\\ 0.20,\\ 0.1)$,\n- 变异 $C$：$\\mathbf{x}^{C} = (0.46,\\ 0.36,\\ 0.08,\\ 0.4)$.\n\n设计并实现一个程序，对于这三个变异中的每一个，对 $i \\in \\{1,2\\}$ 的所有 $S \\subseteq N \\setminus \\{i\\}$ 执行精确联盟枚举，计算相应的 Shapley 权重 $\\frac{|S|! (M - |S| - 1)!}{M!}$，通过在背景数据集上平均来评估干预值 $v(S)$ 和 $v(S \\cup \\{i\\})$，并对加权的边际贡献求和以获得 $\\phi_i$。\n\n您的程序应输出单行，其中包含一个按以下顺序排列的六个浮点数列表：$[\\phi_1(\\mathbf{x}^{A}), \\phi_2(\\mathbf{x}^{A}), \\phi_1(\\mathbf{x}^{B}), \\phi_2(\\mathbf{x}^{B}), \\phi_1(\\mathbf{x}^{C}), \\phi_2(\\mathbf{x}^{C})]$，每个数都四舍五入到恰好六位小数。此单行必须打印出来，不得包含任何附加文本。\n\n测试套件设计：\n- 一般情况：变异 $A$ 测试了典型的高保守性、中等结构破坏、低次要等位基因频率和高剪接基序得分的情况。\n- 边缘情况：变异 $B$ 测试了极端结构破坏、中等保守性、较高的次要等位基因频率和低剪接基序得分的情况。\n- 边界情况：变异 $C$ 等于背景数据集的分量均值，由于效率特性，当对所有特征求和时，应产生接近于零的净归因，尽管单个特征的归因可能不为零。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_k$ 是一个小数点后有六位数的小数。",
            "solution": "目标是为三个给定的遗传变异计算 Shapley 可加性解释 (SHAP) 特征归因，特别是保守性得分的 $\\phi_1$ 和结构破坏得分的 $\\phi_2$。计算基于在提供的背景数据集上执行的干预性边缘化程序。\n\n问题的核心在于计算每个特征 $i \\in N = \\{1, 2, 3, 4\\}$ 的 Shapley 值 $\\phi_i$，其中 $M=|N|=4$。Shapley 值的公式由下式给出：\n$$\n\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} \\frac{|S|! \\, (M - |S| - 1)!}{M!} \\left( v(S \\cup \\{i\\}) - v(S) \\right)\n$$\n该公式表示特征 $i$ 对其他特征所有可能联盟的边际贡献的加权平均值。项 $\\frac{|S|! \\, (M - |S| - 1)!}{M!}$ 是大小为 $|S|$ 的联盟 $S$ 的 Shapley 权重。\n\n特征联盟 $S$ 的值函数 $v(S)$ 定义为：当 $S$ 中的特征固定为变异的值 ($x^{\\text{variant}}_j$)，而不在 $S$ 中的其余特征在背景数据集 $\\mathcal{B}$ 上进行边缘化时，模型 $f(\\mathbf{x})$ 的期望输出。对于一个包含 $K=5$ 个样本的背景数据集，此期望通过样本均值来估计：\n$$\nv(S) = \\frac{1}{K} \\sum_{b=1}^{K} f\\!\\left(\\mathbf{x}^{(S)}_b\\right)\n$$\n向量 $\\mathbf{x}^{(S)}_b$ 是一个混合特征向量，其分量或来源于目标变异，或来源于第 $b$ 个背景样本：\n$$\n\\left(\\mathbf{x}^{(S)}_b\\right)_j = \\begin{cases}\nx^{\\text{variant}}_j,  \\text{if } j \\in S,\\\\\nx^{\\text{background}(b)}_j,  \\text{if } j \\notin S.\n\\end{cases}\n$$\n模型 $f(\\mathbf{x})$ 是一个非线性逻辑斯蒂函数：\n$$\nf(\\mathbf{x}) = \\sigma\\!\\Big(\\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 \\sqrt{x_3} + \\beta_4 x_4 + \\beta_{12} x_1 x_2 + \\beta_{24} x_2 x_4 - \\beta_{13} x_1 \\sqrt{x_3}\\Big)\n$$\n其中 $\\sigma(t) = (1 + e^{-t})^{-1}$ 且系数 $\\beta_k$ 是给定的常数。\n\n为给定的变异向量 $\\mathbf{x}^{\\text{variant}}$ 寻找 $\\phi_i$ 的计算步骤如下：\n1.  识别所有其他特征的集合 $N \\setminus \\{i\\}$。对于我们的四特征模型 ($M=4$)，如果要计算 $\\phi_1$，该集合为 $\\{2, 3, 4\\}$。\n2.  遍历 $N \\setminus \\{i\\}$ 的所有可能子集 $S$。这包括空集 $\\emptyset$ 以及该集合中一个、两个或更多特征的所有组合。对于 $M=4$，任何给定的特征 $i$ 都有 $2^{M-1} = 2^3 = 8$ 个这样的子集。\n3.  对于每个子集 $S$，计算其对应的值函数 $v(S)$ 和并集 $S \\cup \\{i\\}$ 的值函数 $v(S \\cup \\{i\\})$。这需要：\n    a. 对于 $\\mathcal{B}$ 中的 $K=5$ 个背景样本中的每一个 $\\mathbf{b}_k$，构造混合特征向量 $\\mathbf{x}^{(S)}_k$ 和 $\\mathbf{x}^{(S \\cup \\{i\\})}_k$。\n    b. 对这 $2 \\times K$ 个混合向量中的每一个评估模型 $f(\\cdot)$。\n    c. 对结果求平均以获得 $v(S)$ 和 $v(S \\cup \\{i\\})$。\n4.  计算边际贡献 $\\Delta v_S = v(S \\cup \\{i\\}) - v(S)$。\n5.  使用公式 $w_{|S|} = \\frac{|S|! (M - |S| - 1)!}{M!}$ 确定联盟大小 $|S|$ 的 Shapley 权重。对于 $M=4$，权重为：\n    - $|S|=0: \\frac{0!3!}{4!} = 1/4$\n    - $|S|=1: \\frac{1!2!}{4!} = 1/12$\n    - $|S|=2: \\frac{2!1!}{4!} = 1/12$\n    - $|S|=3: \\frac{3!0!}{4!} = 1/4$\n6.  总 Shapley 值 $\\phi_i$ 是所有子集 $S$ 上的加权边际贡献之和：$\\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} w_{|S|} \\Delta v_S$。\n\n对三个变异 $\\mathbf{x}^{A}$、$\\mathbf{x}^{B}$ 和 $\\mathbf{x}^{C}$ 中的每一个重复整个过程，以计算 $\\phi_1$ 和 $\\phi_2$。最终输出是这六个计算值的有序列表，每个值都四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nfrom math import factorial\n\ndef solve():\n    \"\"\"\n    Computes SHAP feature attributions for a variant pathogenicity predictor.\n    \"\"\"\n    \n    # Define model coefficients, background data, and test variants\n    # as specified in the problem statement.\n    BETA = {\n        'b0': -1.0, 'b1': 3.0, 'b2': 2.5, 'b3': -1.5, 'b4': 1.2,\n        'b12': 1.8, 'b24': -1.0, 'b13': 0.7\n    }\n\n    BACKGROUND_DATA = np.array([\n        [0.2, 0.1, 0.05, 0.3],\n        [0.4, 0.3, 0.02, 0.2],\n        [0.6, 0.5, 0.10, 0.4],\n        [0.8, 0.2, 0.15, 0.6],\n        [0.3, 0.7, 0.08, 0.5]\n    ])\n    \n    VARIANTS = [\n        np.array([0.9, 0.4, 0.01, 0.7]),  # Variant A\n        np.array([0.5, 0.95, 0.20, 0.1]), # Variant B\n        np.array([0.46, 0.36, 0.08, 0.4])  # Variant C\n    ]\n    \n    M = 4  # Total number of features\n\n    def sigmoid(t):\n        \"\"\"Computes the logistic sigmoid function.\"\"\"\n        return 1.0 / (1.0 + np.exp(-t))\n\n    def model_f(x):\n        \"\"\"\n        Computes the output of the nonlinear logistic model for a given\n        feature vector x.\n        \"\"\"\n        x1, x2, x3, x4 = x\n        sqrt_x3 = np.sqrt(x3)\n        logit = (BETA['b0'] +\n                 BETA['b1'] * x1 +\n                 BETA['b2'] * x2 +\n                 BETA['b3'] * sqrt_x3 +\n                 BETA['b4'] * x4 +\n                 BETA['b12'] * x1 * x2 +\n                 BETA['b24'] * x2 * x4 -\n                 BETA['b13'] * x1 * sqrt_x3)\n        return sigmoid(logit)\n\n    memoized_values = {}\n    def value_function(S_indices, x_variant, background_data):\n        \"\"\"\n        Computes the value function v(S) by averaging model outputs over\n        the background dataset for features not in the coalition S.\n        Uses memoization to avoid recomputing values for the same coalition.\n        \"\"\"\n        # S_indices uses 0-based indexing\n        s_key = (tuple(sorted(S_indices)), tuple(x_variant))\n        if s_key in memoized_values:\n            return memoized_values[s_key]\n\n        total_output = 0.0\n        for b_row in background_data:\n            x_hybrid = np.copy(b_row)\n            for j_idx in S_indices:\n                x_hybrid[j_idx] = x_variant[j_idx]\n            total_output += model_f(x_hybrid)\n        \n        result = total_output / len(background_data)\n        memoized_values[s_key] = result\n        return result\n\n    def calculate_shapley_value(i_1based, x_variant, background_data):\n        \"\"\"\n        Calculates the exact SHAP value for a feature i by enumerating\n        all coalitions of other features.\n        \"\"\"\n        # We use 0-based indexing for calculations.\n        i_0based = i_1based - 1  \n        all_features_indices = set(range(M))\n        other_features_indices = all_features_indices - {i_0based}\n        \n        shapley_value = 0.0\n        \n        for s_size in range(M):\n            weight = (factorial(s_size) * factorial(M - s_size - 1)) / factorial(M)\n            \n            # Iterate over all coalitions S of size s_size from other features\n            for S_tuple in combinations(other_features_indices, s_size):\n                S = set(S_tuple)\n                S_with_i = S.union({i_0based})\n                \n                # v(S)\n                v_S = value_function(S, x_variant, background_data)\n                \n                # v(S u {i})\n                v_S_with_i = value_function(S_with_i, x_variant, background_data)\n                \n                marginal_contribution = v_S_with_i - v_S\n                shapley_value += weight * marginal_contribution\n                \n        return shapley_value\n\n    results = []\n    # Loop over each variant to calculate the required SHAP values.\n    for variant_vector in VARIANTS:\n        memoized_values.clear()  # Clear memoization cache for each new variant\n        # Calculate phi_1 (for conservation score)\n        phi1 = calculate_shapley_value(1, variant_vector, BACKGROUND_DATA)\n        \n        # Calculate phi_2 (for structure disruption score)\n        phi2 = calculate_shapley_value(2, variant_vector, BACKGROUND_DATA)\n        \n        results.extend([phi1, phi2])\n\n    # Format the final output as specified.\n    output_str = ','.join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}