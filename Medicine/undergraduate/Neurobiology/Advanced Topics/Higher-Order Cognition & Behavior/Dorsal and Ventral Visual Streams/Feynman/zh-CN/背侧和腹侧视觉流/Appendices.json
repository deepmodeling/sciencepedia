{
    "hands_on_practices": [
        {
            "introduction": "背侧通路的一个关键功能是将来自视网膜的感官信息转换成以身体为中心的坐标系，这对于指导行动至关重要。增益场（Gain fields）是实现这种坐标变换的一种神经机制假说，即神经元对视觉刺激的反应会受到眼球位置的乘法调制。这个练习将让你通过构建一个增益场神经元的数学模型并计算其平均发放率，将一个抽象的计算概念变得具体化 。",
            "id": "5013675",
            "problem": "在灵长类视觉系统中，背侧视觉通路将视网膜拓扑感觉信号转换为行动所需的以身体为中心的表征。后顶叶皮层的Lateral Intraparietal area (LIP)中的神经元表现出增益场，这意味着它们的视觉驱动响应受到眼球位置的乘法调制。考虑一个LIP神经元，它接收一个视网膜运动输入 $r(t)$ 和一个眼球位置信号 $e(t)$，两者都用归一化的无量纲单位表示，因此它们的幅度是可比较的。假设该神经元的放电率 $f(t)$ 可以用与增益场调制一致的、能够实现从视网膜坐标到身体中心坐标信号转换的最低阶相互作用来很好地近似。\n\n给定视网膜输入为 $r(t) = A_{r}\\cos(\\omega t)$，眼球位置信号为 $e(t) = A_{e}\\cos(\\omega t + \\phi)$，其中 $A_{r}$、$A_{e}$、$\\omega$ 和 $\\phi$ 是常数。在小信号条件和一个周期内的平稳性假设下，假定神经元的放电率可以展开到能够捕捉眼球位置对视觉输入的乘法调制的最小非平凡阶，并且此展开由系数 $\\alpha$、$\\beta$ 和 $\\gamma$ 参数化（单位的选择使得 $f(t)$ 的单位为“峰/秒”）。这些常数是 $A_{r} = 0.6$, $A_{e} = 0.8$, $\\phi = \\frac{\\pi}{3}$, $\\alpha = 12$, $\\beta = 8$, 和 $\\gamma = 52$。角频率 $\\omega$ 非零但未具体指明；分析应在一个完整周期内对任何 $\\omega$ 都成立。\n\n从增益场的核心定义以及从视网膜坐标到身体中心坐标转换的要求出发，推导由增益场调制所蕴含的最小双线性放电率形式，并用它来计算在一个完整周期 $T = \\frac{2\\pi}{\\omega}$ 内的周期平均放电率 $\\bar{f}$。将你的最终数值答案四舍五入到四位有效数字。以“峰/秒”（spikes per second）为单位表示你的最终数值答案。",
            "solution": "问题要求计算一个用增益场动力学建模的Lateral Intraparietal area (LIP)中神经元的周期平均放电率。解题过程分两个阶段：首先，根据所提供的神经生物学原理推导神经元放电率的数学形式；其次，使用给定的输入信号计算该放电率在一个周期内的时间平均值。\n\n**1. 放电率模型的推导**\n\n问题陈述了神经元的放电率 $f(t)$ 是视网膜运动输入 $r(t)$ 和眼球位置信号 $e(t)$ 的函数。核心概念是“增益场”，即神经元对视觉刺激的响应受到眼球位置的乘法调制。这是一种将感觉信号从视网膜拓扑（以眼球为中心）的坐标系转换到另一个（例如以身体为中心）参考系的机制。\n\n我们被要求寻找“与增益场调制一致的最低阶相互作用”或“能捕捉乘法调制的最小非平凡阶”。这指向了对放电率函数 $f(r, e)$ 关于其输入 $r$ 和 $e$ 的泰勒级数展开，并截断以包含必要的项。一个通用的二元变量在点 $(r=0, e=0)$ 附近的泰勒展开式为：\n$$ f(r, e) = f(0,0) + \\frac{\\partial f}{\\partial r}r + \\frac{\\partial f}{\\partial e}e + \\frac{\\partial^2 f}{\\partial r \\partial e}re + \\text{更高阶项} $$\n此处，所有偏导数均在 $(r=0, e=0)$ 处求值。\n$f(0,0)$ 项代表一个恒定的基线放电率 $C$。\n$\\frac{\\partial f}{\\partial r}r$ 项代表神经元仅对视网膜刺激的响应。\n$\\frac{\\partial f}{\\partial e}e$ 项代表神经元仅受眼球位置的调制。\n$\\frac{\\partial^2 f}{\\partial r \\partial e}re$ 项是关键项。它是捕捉视网膜信号和眼球位置信号之间乘法相互作用的最低阶项。它的存在，即 $\\frac{\\partial^2 f}{\\partial r \\partial e} \\neq 0$，是在这个简化模型中增益场的数学标记。\n\n问题指明模型展开是由“系数 $\\alpha$、$\\beta$ 和 $\\gamma$”参数化的。将它们与线性和相互作用项的系数关联起来是合乎逻辑的。因此，我们确定：\n$\\alpha = \\frac{\\partial f}{\\partial r}$（对视网膜输入的敏感度）\n$\\beta = \\frac{\\partial f}{\\partial e}$（对眼球位置的敏感度）\n$\\gamma = \\frac{\\partial^2 f}{\\partial r \\partial e}$（增益场调制强度）\n\n这导出了最小双线性放电率形式：\n$$f(t) = C + \\alpha r(t) + \\beta e(t) + \\gamma r(t)e(t)$$\n问题没有提供基线放电率 $C$ 的值。然而，周期平均放电率 $\\bar{f}$ 需要一个数值答案。项 $C$ 的平均值就是 $C$。项 $\\alpha r(t)$ 和 $\\beta e(t)$ 的平均值将为零，因为它们是纯正弦波。因此，最终的平均值将是 $C + \\gamma \\overline{r(t)e(t)}$。要存在唯一的数值解，常数 $C$ 必须被指定。由于没有指定，我们必须推断问题的意图。“展开由系数 $\\alpha, \\beta, \\text{ 和 } \\gamma$ 参数化”这一说法表明，要使用的模型仅由与这些参数相关的项组成。这意味着我们要分析放电率的动态、依赖输入的部分，这等同于假设基线放电率为 $C=0$。在这个合理的假设下，模型变为：\n$$f(t) = \\alpha r(t) + \\beta e(t) + \\gamma r(t)e(t)$$\n\n**2. 周期平均放电率的计算**\n\n周期平均放电率 $\\bar{f}$ 定义为 $f(t)$ 在一个周期 $T = \\frac{2\\pi}{\\omega}$ 上的积分除以该周期：\n$$ \\bar{f} = \\frac{1}{T} \\int_0^T f(t) dt = \\frac{1}{T} \\int_0^T \\left( \\alpha r(t) + \\beta e(t) + \\gamma r(t)e(t) \\right) dt $$\n根据积分的线性性质，这变为：\n$$ \\bar{f} = \\alpha \\left(\\frac{1}{T} \\int_0^T r(t) dt\\right) + \\beta \\left(\\frac{1}{T} \\int_0^T e(t) dt\\right) + \\gamma \\left(\\frac{1}{T} \\int_0^T r(t)e(t) dt\\right) $$\n输入被给定为 $r(t) = A_r \\cos(\\omega t)$ 和 $e(t) = A_e \\cos(\\omega t + \\phi)$。任何形式为 $\\cos(\\Omega t + \\delta)$ 的正弦函数在一个完整周期内的时间平均值为零。因此，$r(t)$ 和 $e(t)$ 的平均值都为零：\n$$ \\frac{1}{T} \\int_0^T r(t) dt = 0 \\quad \\text{和} \\quad \\frac{1}{T} \\int_0^T e(t) dt = 0 $$\n$\\bar{f}$ 的表达式简化为相互作用项的平均值：\n$$ \\bar{f} = \\gamma \\left( \\frac{1}{T} \\int_0^T r(t)e(t) dt \\right) $$\n我们现在计算乘积 $r(t)e(t)$ 的积分：\n$$ \\int_0^T r(t)e(t) dt = \\int_0^T \\left( A_r \\cos(\\omega t) \\right) \\left( A_e \\cos(\\omega t + \\phi) \\right) dt = A_r A_e \\int_0^T \\cos(\\omega t) \\cos(\\omega t + \\phi) dt $$\n我们使用三角函数的积化和差恒等式 $$ \\cos(A)\\cos(B) = \\frac{1}{2}(\\cos(A-B) + \\cos(A+B)) $$：\n$$ \\cos(\\omega t) \\cos(\\omega t + \\phi) = \\frac{1}{2} \\left( \\cos(\\phi) + \\cos(2\\omega t + \\phi) \\right) $$\n将此代入积分：\n$$ \\int_0^T A_r A_e \\left( \\frac{1}{2} (\\cos(\\phi) + \\cos(2\\omega t + \\phi)) \\right) dt = \\frac{A_r A_e}{2} \\left[ \\int_0^T \\cos(\\phi) dt + \\int_0^T \\cos(2\\omega t + \\phi) dt \\right] $$\n第一个积分的计算结果是 $T \\cos(\\phi)$，因为 $\\cos(\\phi)$ 是一个常数。第二个积分为零，因为它是频率为 $2\\omega$ 的正弦函数在区间 $T = \\frac{2\\pi}{\\omega}$ 上的积分，这等于被积函数的两个完整周期。\n$$ \\int_0^T r(t)e(t) dt = \\frac{A_r A_e}{2} [T \\cos(\\phi) + 0] = \\frac{1}{2} A_r A_e T \\cos(\\phi) $$\n现在，我们可以求出平均值：\n$$ \\bar{f} = \\gamma \\left( \\frac{1}{T} \\left[ \\frac{1}{2} A_r A_e T \\cos(\\phi) \\right] \\right) = \\frac{1}{2} \\gamma A_r A_e \\cos(\\phi) $$\n这就是周期平均放电率的最终解析表达式。\n\n**3. 数值计算**\n\n我们代入给定的数值：\n$A_r = 0.6$\n$A_e = 0.8$\n$\\phi = \\frac{\\pi}{3}$\n$\\gamma = 52$\n\n首先，$\\cos(\\phi) = \\cos(\\frac{\\pi}{3}) = \\frac{1}{2} = 0.5$。\n现在，我们计算 $\\bar{f}$：\n$$ \\bar{f} = \\frac{1}{2} (52) (0.6) (0.8) (0.5) $$\n$$ \\bar{f} = (26) (0.6) (0.8) (0.5) $$\n$$ \\bar{f} = (26) (0.48) (0.5) $$\n$$ \\bar{f} = (26) (0.24) $$\n$$ \\bar{f} = 6.24 $$\n问题陈述单位是“峰/秒”，并要求将答案四舍五入到四位有效数字。\n$$ \\bar{f} = 6.240 \\text{ 峰/秒} $$\n其他系数 $\\alpha = 12$ 和 $\\beta = 8$ 在平稳正弦输入下对周期平均放电率没有贡献，因为它们对应的项在一个完整周期内的平均值为零。",
            "answer": "$$\\boxed{6.240}$$"
        },
        {
            "introduction": "背侧通路和腹侧通路分别处理关于“在哪里/如何”和“是什么”的信息，但我们如何将这些不同的信息整合成一个统一的知觉呢？本练习将探讨大脑如何结合来自两个通路的、有时甚至相互冲突的线索（例如，运动和形状线索）。你将运用贝叶斯推断来计算大脑如何根据每条线索的“可靠性”来赋予其最佳权重，从而理解知觉决策背后的强大计算原理 。",
            "id": "5013729",
            "problem": "在灵长类的视觉系统中，背侧视觉通路主要对运动衍生信息进行调谐，而腹侧视觉通路则对形状衍生信息进行调谐。考虑一个关于单个潜藏航向角 $\\theta$（单位为度）的知觉决策，该角度是在短暂呈现一个移动的带纹理物体时，相对于正前方的航向。假设如下：\n\n- 背侧运动线索产生一个测量值 $\\theta_{m}$，其高斯似然 $p(\\theta_{m} \\mid \\theta)$ 的均值为 $\\theta$，方差为 $\\sigma_{m}^{2}$。在某次特定试验中，运动测量值等于 $\\theta_{m} = 10$，背侧运动方差等于 $\\sigma_{m}^{2} = 4$。\n- 腹侧形状线索产生一个测量值 $\\theta_{s}$，其高斯似然 $p(\\theta_{s} \\mid \\theta)$ 的均值为 $\\theta$，方差为 $\\sigma_{s}^{2}$。在同一次试验中，形状测量值等于 $\\theta_{s} = -2$，腹侧形状方差等于 $\\sigma_{s}^{2} = 16$。\n- 观察者对航向角有一个高斯先验 $p(\\theta)$，其均值为 $\\mu_{p} = 0$，方差为 $\\sigma_{p}^{2} = 64$。\n- 假设在给定 $\\theta$ 的条件下，这些线索是条件独立的。\n\n使用贝叶斯定理和上述假设，推导航向角 $\\theta$ 的后验分布 $p(\\theta \\mid \\theta_{m}, \\theta_{s})$，并通过确定最大后验 (MAP) 估计来解释在线索冲突情况下的预测行为。量化背侧运动线索和腹侧形状线索的通路特定权重，这些权重定义为在高斯假设下，每个线索的可靠性（方差的倒数）对 MAP 估计的归一化贡献。\n\n仅报告航向角的 MAP 估计作为您的最终答案，以度为单位表示。将最终答案四舍五入到四位有效数字。",
            "solution": "该问题要求基于两个带噪声的感官线索和一个先验信念，求出潜藏航向角 $\\theta$ 的最大后验 (MAP) 估计。这是一个贝叶斯推断问题，具体来说是线索整合问题。\n\n根据贝叶斯定理，给定运动测量值 $\\theta_{m}$ 和形状测量值 $\\theta_{s}$ 的条件下，角度 $\\theta$ 的后验概率分布与似然和先验的乘积成正比：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto p(\\theta_{m}, \\theta_{s} \\mid \\theta) p(\\theta)$$\n问题陈述，在给定真实航向角 $\\theta$ 的条件下，这两个线索是条件独立的。因此，联合似然可以分解为各个似然的乘积：\n$$p(\\theta_{m}, \\theta_{s} \\mid \\theta) = p(\\theta_{m} \\mid \\theta) p(\\theta_{s} \\mid \\theta)$$\n将此代入第一个方程，我们得到后验的表达式：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto p(\\theta_{m} \\mid \\theta) p(\\theta_{s} \\mid \\theta) p(\\theta)$$\n我们已知右侧的三个分布都是高斯分布：\n1.  背侧运动线索似然：$p(\\theta_{m} \\mid \\theta) = \\mathcal{N}(\\theta, \\sigma_{m}^{2})$，其中测量值为 $\\theta_{m} = 10$，方差为 $\\sigma_{m}^{2} = 4$。\n2.  腹侧形状线索似然：$p(\\theta_{s} \\mid \\theta) = \\mathcal{N}(\\theta, \\sigma_{s}^{2})$，其中测量值为 $\\theta_{s} = -2$，方差为 $\\sigma_{s}^{2} = 16$。\n3.  先验分布：$p(\\theta) = \\mathcal{N}(\\mu_{p}, \\sigma_{p}^{2})$，其中均值为 $\\mu_{p} = 0$，方差为 $\\sigma_{p}^{2} = 64$。\n\n高斯分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 的概率密度函数与 $\\exp\\left(-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right)$ 成正比。因此，后验分布为：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto \\exp\\left(-\\frac{(\\theta_{m}-\\theta)^2}{2\\sigma_{m}^{2}}\\right) \\exp\\left(-\\frac{(\\theta_{s}-\\theta)^2}{2\\sigma_{s}^{2}}\\right) \\exp\\left(-\\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}}\\right)$$\n合并指数项：\n$$p(\\theta \\mid \\theta_{m}, \\theta_{s}) \\propto \\exp\\left( -\\frac{(\\theta-\\theta_{m})^2}{2\\sigma_{m}^{2}} -\\frac{(\\theta-\\theta_{s})^2}{2\\sigma_{s}^{2}} -\\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}} \\right)$$\nMAP 估计 $\\theta_{\\text{MAP}}$ 是使该后验概率最大化的 $\\theta$ 值。最大化后验等价于最小化其负对数。设 $J(\\theta)$ 为指数中的项（也称为负对数后验，忽略常数项）：\n$$J(\\theta) = \\frac{(\\theta-\\theta_{m})^2}{2\\sigma_{m}^{2}} + \\frac{(\\theta-\\theta_{s})^2}{2\\sigma_{s}^{2}} + \\frac{(\\theta-\\mu_{p})^2}{2\\sigma_{p}^{2}}$$\n为了找到 $J(\\theta)$ 的最小值，我们对 $\\theta$ 求其导数并将其设为 0：\n$$\\frac{dJ}{d\\theta} = \\frac{2(\\theta-\\theta_{m})}{2\\sigma_{m}^{2}} + \\frac{2(\\theta-\\theta_{s})}{2\\sigma_{s}^{2}} + \\frac{2(\\theta-\\mu_{p})}{2\\sigma_{p}^{2}} = 0$$\n$$\\frac{\\theta-\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta-\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\theta-\\mu_{p}}{\\sigma_{p}^{2}} = 0$$\n我们可以分离包含 $\\theta$ 的项：\n$$\\theta\\left(\\frac{1}{\\sigma_{m}^{2}} + \\frac{1}{\\sigma_{s}^{2}} + \\frac{1}{\\sigma_{p}^{2}}\\right) = \\frac{\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\mu_{p}}{\\sigma_{p}^{2}}$$\n解出 $\\theta$ 即可得到 MAP 估计 $\\theta_{\\text{MAP}}$：\n$$\\theta_{\\text{MAP}} = \\frac{\\frac{\\theta_{m}}{\\sigma_{m}^{2}} + \\frac{\\theta_{s}}{\\sigma_{s}^{2}} + \\frac{\\mu_{p}}{\\sigma_{p}^{2}}}{\\frac{1}{\\sigma_{m}^{2}} + \\frac{1}{\\sigma_{s}^{2}} + \\frac{1}{\\sigma_{p}^{2}}}$$\n该方程表明，MAP 估计是测量值和先验均值的加权平均，其中权重是每个信息来源的可靠性（方差的倒数）。设可靠性为 $r_{i} = 1/\\sigma_{i}^{2}$。\n$$r_{m} = \\frac{1}{\\sigma_{m}^{2}} = \\frac{1}{4}$$\n$$r_{s} = \\frac{1}{\\sigma_{s}^{2}} = \\frac{1}{16}$$\n$$r_{p} = \\frac{1}{\\sigma_{p}^{2}} = \\frac{1}{64}$$\nMAP 估计方程变为：\n$$\\theta_{\\text{MAP}} = \\frac{r_{m}\\theta_{m} + r_{s}\\theta_{s} + r_{p}\\mu_{p}}{r_{m} + r_{s} + r_{p}}$$\n代入给定的数值：\n$\\theta_{\\text{MAP}} = \\frac{(\\frac{1}{4})(10) + (\\frac{1}{16})(-2) + (\\frac{1}{64})(0)}{\\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64}}$\n首先，我们计算分子：\n$$\\text{Numerator} = \\frac{10}{4} - \\frac{2}{16} + 0 = 2.5 - 0.125 = 2.375$$\n以分数形式表示： $\\frac{160}{64} - \\frac{8}{64} = \\frac{152}{64}$。\n接下来，我们计算分母：\n$$\\text{Denominator} = \\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64} = \\frac{16}{64} + \\frac{4}{64} + \\frac{1}{64} = \\frac{21}{64}$$\n现在，我们计算 $\\theta_{\\text{MAP}}$ 的最终值：\n$$ \\theta_{\\text{MAP}} = \\frac{\\frac{152}{64}}{\\frac{21}{64}} = \\frac{152}{21} $$\n$$ \\theta_{\\text{MAP}} \\approx 7.2380952... $$\n每个线索的归一化权重是其可靠性除以总可靠性。\n总可靠性：$r_{\\text{total}} = r_{m} + r_{s} + r_{p} = \\frac{21}{64}$。\n背侧运动线索的权重：$w_{m} = \\frac{r_{m}}{r_{\\text{total}}} = \\frac{1/4}{21/64} = \\frac{16}{21} \\approx 0.762$。\n腹侧形状线索的权重：$w_{s} = \\frac{r_{s}}{r_{\\text{total}}} = \\frac{1/16}{21/64} = \\frac{4}{21} \\approx 0.190$。\n背侧运动线索的高可靠性（$\\sigma_{m}^{2} = 4$）使其具有较大的权重，将约 $7.24$ 度的 MAP 估计拉得更接近其测量值 $\\theta_{m}=10$，而不是冲突的腹侧形状线索测量值 $\\theta_{s}=-2$ 或先验均值 $\\mu_{p}=0$。\n\n问题要求航向角的 MAP 估计，并四舍五入到四位有效数字。\n$$ \\theta_{\\text{MAP}} = \\frac{152}{21} \\approx 7.2380952... $$\n四舍五入到四位有效数字得到 $7.238$。",
            "answer": "$$\n\\boxed{7.238}\n$$"
        },
        {
            "introduction": "我们如何验证关于视觉通路的计算模型是否准确地反映了大脑的真实活动？本练习将介绍一种前沿的神经科学技术——表征相似性分析（Representational Similarity Analysis, RSA），它使我们能够定量地比较模型的“表征几何”与真实大脑活动的“表征几何”。你将亲手实现RSA，量化一个计算模型的输出与背侧通路（MT区）和腹侧通路（IT区）神经数据的一致性，从而学习如何用经验数据来检验计算理论 。",
            "id": "5013737",
            "problem": "您将获得模拟的响应矩阵，这些矩阵反映了一个计算模型对一组共享刺激的响应，以及来自两个与背侧和腹侧视觉通路相关的经典视觉区域的相应神经群体响应。具体来说，背侧通路以中颞区（MT; Middle Temporal）为代表，腹侧通路以颞下皮层（IT; Inferior Temporal）为代表。您的任务是使用表征相似性分析和交叉验证相关性来量化模型与神经表征几何之间的一致性。\n\n使用的基本原理和定义：\n- 表征非相似性矩阵由响应矩阵定义：首先计算每对刺激在所有单元上的皮尔逊相关系数，然后通过 $d_{ij} = 1 - \\rho_{ij}$ 转换为非相似性。对于一个响应矩阵 $X \\in \\mathbb{R}^{n \\times p}$，其中 $n$ 是刺激数量， $p$ 是单元数量，定义表征非相似性矩阵 $D \\in \\mathbb{R}^{n \\times n}$ 为 $D_{ij} = 1 - \\mathrm{corr}(X_{i,\\cdot}, X_{j,\\cdot})$，且 $D_{ii} = 0$。\n- 将 $D$ 的上三角部分（不包括对角线）按一致的顺序向量化为一个向量 $v \\in \\mathbb{R}^{n(n-1)/2}$。\n- 给定模型的两个独立分割 $(M^{A}, M^{B})$ 和神经数据的两个独立分割 $(N^{1}, N^{2})$，形成四个表征非相似性向量 $v(M^{A}), v(M^{B}), v(N^{1}), v(N^{2})$。通过计算 $r_{1} = \\mathrm{corr}(v(M^{A}), v(N^{2}))$ 和 $r_{2} = \\mathrm{corr}(v(M^{B}), v(N^{1}))$ 来定义一个交叉验证的皮尔逊相关性。使用Fisher $z$变换组合 $r_{1}$ 和 $r_{2}$：$$z(r) = \\tfrac{1}{2}\\ln\\left(\\tfrac{1+r}{1-r}\\right)$$，在 $z$ 空间中取平均值，然后使用 $\\tanh$ 进行逆变换，以获得最终估计值 $r_{\\mathrm{cv}} = \\tanh\\left(\\tfrac{z(r_{1}) + z(r_{2})}{2}\\right)$。\n\n算法要求：\n- 在非相似性构建和最终的向量间相关性计算中均使用皮尔逊相关性。\n- 在应用Fisher $z$变换时，通过有原则地处理 $r = \\pm 1$ 的边界情况来确保数值稳定性。\n- 所有计算必须是确定性的，并且只能使用提供的矩阵和定义。\n\n测试套件：\n您必须为四个独立的场景计算 $r_{\\mathrm{cv}}$。对于每个场景，五个刺激情况的刺激顺序固定为 $(s_{1}, s_{2}, s_{3}, s_{4}, s_{5})$，四个刺激情况的刺激顺序固定为 $(t_{1}, t_{2}, t_{3}, t_{4})$。\n\n场景 $1$（模型运动特征 vs MT；$5 \\times 4$ 响应）：\n- 模型运动分割 $A$，$M_{\\mathrm{motion}}^{A} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.0  2.0  0.1  0.0 \\\\\n1.9  2.1  0.0  0.2 \\\\\n0.2  0.0  2.1  2.0 \\\\\n0.0  0.1  1.9  2.2 \\\\\n0.1  0.2  2.0  2.1\n\\end{bmatrix}\n$$\n- 模型运动分割 $B$，$M_{\\mathrm{motion}}^{B} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.1  1.9  0.0  0.1 \\\\\n2.0  2.0  0.1  0.1 \\\\\n0.1  0.0  2.0  2.2 \\\\\n0.0  0.2  2.2  1.9 \\\\\n0.2  0.1  2.1  2.0\n\\end{bmatrix}\n$$\n- 神经MT分割 $1$，$N_{\\mathrm{MT}}^{1} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.2  2.1  0.0  0.1 \\\\\n1.8  2.0  0.1  0.1 \\\\\n0.0  0.1  2.2  2.1 \\\\\n0.1  0.0  1.8  2.0 \\\\\n0.1  0.2  2.1  2.2\n\\end{bmatrix}\n$$\n- 神经MT分割 $2$，$N_{\\mathrm{MT}}^{2} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.0  2.2  0.1  0.0 \\\\\n2.1  1.9  0.0  0.2 \\\\\n0.2  0.0  2.0  2.1 \\\\\n0.0  0.1  2.2  1.8 \\\\\n0.1  0.2  2.0  2.3\n\\end{bmatrix}\n$$\n\n场景 $2$（模型形状特征 vs IT；$5 \\times 4$ 响应）：\n- 模型形状分割 $A$，$M_{\\mathrm{form}}^{A} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.0  2.0  0.1  0.0 \\\\\n0.1  0.0  2.0  2.0 \\\\\n2.1  1.9  0.0  0.1 \\\\\n0.0  0.1  2.1  1.9 \\\\\n1.0  1.1  0.9  1.0\n\\end{bmatrix}\n$$\n- 模型形状分割 $B$，$M_{\\mathrm{form}}^{B} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.1  1.9  0.0  0.1 \\\\\n0.0  0.1  2.1  1.9 \\\\\n1.9  2.1  0.1  0.0 \\\\\n0.1  0.0  1.9  2.1 \\\\\n1.1  1.0  1.0  0.9\n\\end{bmatrix}\n$$\n- 神经IT分割 $1$，$N_{\\mathrm{IT}}^{1} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.2  2.1  0.0  0.1 \\\\\n0.0  0.1  2.0  2.1 \\\\\n1.8  2.0  0.1  0.0 \\\\\n0.1  0.0  1.9  2.0 \\\\\n1.1  1.0  0.9  1.0\n\\end{bmatrix}\n$$\n- 神经IT分割 $2$，$N_{\\mathrm{IT}}^{2} \\in \\mathbb{R}^{5 \\times 4}$:\n$$\n\\begin{bmatrix}\n2.0  2.2  0.1  0.0 \\\\\n0.1  0.0  2.2  1.8 \\\\\n2.1  1.9  0.0  0.2 \\\\\n0.0  0.2  1.8  2.2 \\\\\n0.9  1.0  1.1  1.0\n\\end{bmatrix}\n$$\n\n场景 $3$（跨通路不匹配控制：模型运动特征 vs IT；$5 \\times 4$ 响应）：\n- 使用场景 $1$ 中的 $M_{\\mathrm{motion}}^{A}$ 和 $M_{\\mathrm{motion}}^{B}$。\n- 使用场景 $2$ 中的 $N_{\\mathrm{IT}}^{1}$ 和 $N_{\\mathrm{IT}}^{2}$。\n\n场景 $4$（边界情况，所有分割具有相同的表征几何；$4 \\times 3$ 响应）：\n- 令公共响应矩阵 $R \\in \\mathbb{R}^{4 \\times 3}$ 为\n$$\n\\begin{bmatrix}\n0.0  1.0  2.0 \\\\\n0.5  1.0  1.5 \\\\\n2.0  1.0  0.0 \\\\\n1.5  1.0  0.5\n\\end{bmatrix}\n$$\n- 设置 $M^{A} = R$, $M^{B} = R$, $N^{1} = R$, $N^{2} = R$。\n\n所需输出：\n- 对于每个场景，计算如上定义的交叉验证相关性 $r_{\\mathrm{cv}}$。\n- 最终的程序输出必须是单行文本，包含四个结果，以逗号分隔并用方括号括起来，顺序为场景 $1、2、3、4$。\n- 每个值必须是四舍五入到 $6$ 位小数的浮点数。\n\n您的程序必须只产生一行格式为：\"[result1,result2,result3,result4]\" 的输出。不涉及物理单位。不涉及角度。所有百分比（如有）必须表示为小数，但此处不需要。程序必须是自包含的，不接受任何输入，并且仅使用提供的定义和矩阵。计算必须使用支持执行环境中指定的线性代数运算的现代编程语言来执行。",
            "solution": "该问题要求计算一个交叉验证的相关系数，表示为 $r_{\\mathrm{cv}}$，以量化计算模型和神经数据的表征几何之间的相似性。这项任务属于表征相似性分析（Representational Similarity Analysis, RSA）的范畴，这是计算神经科学中一种常用的技术。该分析需要针对 $4$ 个不同的场景进行。\n\n解决方案通过遵循一系列明确定义的数学步骤来实现。首先，构建一个函数，将响应矩阵转换为其对应的表征非相似性矩阵（Representational Dissimilarity Matrix, RDM），然后将其向量化。其次，另一个函数使用此转换，根据每个场景提供的四个输入响应矩阵计算最终的交叉验证相关性 $r_{\\mathrm{cv}}$。\n\n**步骤 1：计算表征非相似性向量**\n\n第一个核心过程是将一个响应矩阵 $X \\in \\mathbb{R}^{n \\times p}$（其中 $n$ 是刺激数量， $p$ 是测量单元数量，例如神经元或模型单元）转换为一个向量化的RDM。这包括三个子步骤：\n\n1.  **成对相关性：** 对于每对刺激（索引为 $i$ 和 $j$），我们考虑它们对应的响应向量，即矩阵 $X$ 的行 $X_{i, \\cdot}$ 和 $X_{j, \\cdot}$。计算所有行对的皮尔逊相关系数 $\\rho_{ij} = \\mathrm{corr}(X_{i,\\cdot}, X_{j,\\cdot})$。这将产生一个对称的 $n \\times n$ 相关矩阵 $P$，其中 $P_{ij} = \\rho_{ij}$，且对角线元素全为 $1$。\n\n2.  **非相似性转换：** 使用公式 $$D_{ij} = 1 - \\rho_{ij}$$ 将相关矩阵 $P$ 转换为表征非相似性矩阵（RDM）$D$。此转换将高正相关（高相似性）映射到低非相似性值（接近 $0$），将高负相关（高反相似性）映射到高非相似性值（接近 $2$）。对角线元素 $D_{ii}$ 被明确设置为 $0$，因为一个刺激表征与其自身的非相似性为零。\n\n3.  **向量化：** RDM $D$ 是一个对称矩阵。所有相关信息都包含在其上三角（或下三角）中。我们将 $D$ 的严格上三角部分（即所有 $i  j$ 的元素 $D_{ij}$）向量化为一个单一向量 $v$。对于一个 $n \\times n$ 矩阵，该向量的长度为 $n(n-1)/2$。为了确保后续比较的有效性，所有矩阵的向量化必须遵循一致的顺序。\n\n**步骤 2：计算交叉验证相关性（$r_{\\mathrm{cv}}$）**\n\n第二个核心过程是使用模型响应的两个独立分割 $(M^{A}, M^{B})$ 和神经响应的两个独立分割 $(N^{1}, N^{2})$ 来计算最终的汇总统计量 $r_{\\mathrm{cv}}$。这种交叉验证方案可以防止因使用相同数据进行拟合和评估，或因单个数据集内的噪声相关性而可能导致的统计膨胀。\n\n1.  **生成 RDM 向量：** 使用步骤 $1$ 中的过程，我们计算四个 RDM 向量：$v(M^{A})$、$v(M^{B})$、$v(N^{1})$ 和 $v(N^{2})$。\n\n2.  **计算交叉相关性：** 在独立分割之间计算两个皮尔逊相关性。“裂半”逻辑要求将一个模型分割与*另一个*神经分割进行相关：\n    *   $r_{1} = \\mathrm{corr}(v(M^{A}), v(N^{2}))$\n    *   $r_{2} = \\mathrm{corr}(v(M^{B}), v(N^{1}))$\n\n3.  **通过 Fisher $z$ 变换平均相关性：** 相关系数不具有可加性。为了正确地对它们进行平均，必须首先将它们转换到一个近似正态分布且方差稳定的空间中。Fisher $z$ 变换用于此目的：\n    $$z(r) = \\frac{1}{2}\\ln\\left(\\frac{1+r}{1-r}\\right) = \\mathrm{arctanh}(r)$$\n    我们计算 $z(r_1)$ 和 $z(r_2)$，以及它们的算术平均值 $$\\bar{z} = \\frac{z(r_1) + z(r_2)}{2}$$。问题要求处理 $r = \\pm 1$ 的边界情况。$\\mathrm{arctanh}$ 函数正确地将 $r=1$ 映射到 $\\infty$，将 $r=-1$ 映射到 $-\\infty$。随后的平均和逆变换能正确处理这些无穷大值。\n\n4.  **逆变换：** 使用 Fisher $z$ 变换的逆变换，即双曲正切函数，将平均值 $\\bar{z}$ 转换回相关空间：\n    $$r_{\\mathrm{cv}} = \\tanh(\\bar{z})$$\n    这个最终值 $r_{\\mathrm{cv}}$ 是模型与神经表征几何之间的交叉验证相似性得分。\n\n**应用于场景**\n\n上述过程被应用于问题中定义的四个场景。\n\n*   **场景 1：** 模型运动 vs. MT。输入为 $M_{\\mathrm{motion}}^{A}$、$M_{\\mathrm{motion}}^{B}$、$N_{\\mathrm{MT}}^{1}$ 和 $N_{\\mathrm{MT}}^{2}$。所有矩阵均为 $5 \\times 4$。每个 RDM 向量将有 $5(4)/2 = 10$ 个元素。计算得出 $r_{\\mathrm{cv}} \\approx 0.999690$。\n\n*   **场景 2：** 模型形状 vs. IT。输入为 $M_{\\mathrm{form}}^{A}$、$M_{\\mathrm{form}}^{B}$、$N_{\\mathrm{IT}}^{1}$ 和 $N_{\\mathrm{IT}}^{2}$。所有矩阵均为 $5 \\times 4$。每个 RDM 向量将有 $10$ 个元素。计算得出 $r_{\\mathrm{cv}} \\approx 0.992225$。\n\n*   **场景 3：** 跨通路不匹配控制（模型运动 vs. IT）。此场景用作特异性控制，测试运动处理模型与运动相关脑区（MT）的一致性是否优于与形状相关脑区（IT）的一致性。输入为场景 $1$ 的 $M_{\\mathrm{motion}}^{A}$、$M_{\\mathrm{motion}}^{B}$ 和场景 $2$ 的 $N_{\\mathrm{IT}}^{1}$、$N_{\\mathrm{IT}}^{2}$。计算得出 $r_{\\mathrm{cv}} \\approx 0.088383$。正如预期的那样，这种不匹配的相关性远低于场景 $1$ 和 $2$ 中的匹配相关性。\n\n*   **场景 4：** 边界情况。在这里，所有四个输入矩阵都相同：$M^{A} = M^{B} = N^{1} = N^{2} = R$。$R$ 是一个 $4 \\times 3$ 矩阵。\n    *   由于所有输入矩阵都相同，所有四个 RDM 向量也将相同：$v(M^A) = v(M^B) = v(N^1) = v(N^2) = v(R)$。\n    *   交叉相关性将为 $$ r_1 = \\mathrm{corr}(v(R), v(R)) = 1 \\quad \\text{and} \\quad r_2 = \\mathrm{corr}(v(R), v(R)) = 1 $$，前提是向量 $v(R)$ 不是常数（对于给定的矩阵 $R$，它不是常数）。\n    *   $r=1$ 的 Fisher $z$ 变换是 $$ z(1) = \\mathrm{arctanh}(1) = \\infty $$。\n    *   平均值为 $$ \\bar{z} = (\\infty + \\infty)/2 = \\infty $$。\n    *   最终结果是 $$ r_{\\mathrm{cv}} = \\tanh(\\infty) = 1 $$。\n    此计算验证了边界条件的处理逻辑，并对实现进行了健全性检查。结果恰好是 $1.0$。\n\n该实现将系统地将这些步骤应用于所提供的数据矩阵，以计算最终的四个值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_rdm_vector(response_matrix: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the vectorized upper-triangular of the Representational Dissimilarity Matrix (RDM).\n\n    Args:\n        response_matrix: An n x p numpy array where n is the number of stimuli\n                         and p is the number of units.\n\n    Returns:\n        A 1D numpy array of length n(n-1)/2 representing the vectorized RDM.\n    \"\"\"\n    # Step 1: Compute the n x n matrix of Pearson correlations between rows.\n    # np.corrcoef with default rowvar=True computes correlation between rows.\n    # If a row is constant, its std dev is 0, leading to NaNs in corrcoef.\n    # The problem data avoids this.\n    corr_matrix = np.corrcoef(response_matrix)\n\n    # Step 2: Convert to a dissimilarity matrix (RDM)\n    dissimilarity_matrix = 1.0 - corr_matrix\n\n    # Step 3: Vectorize the upper-triangular part (excluding the diagonal, k=1)\n    n = response_matrix.shape[0]\n    upper_triangle_indices = np.triu_indices(n, k=1)\n    rdm_vector = dissimilarity_matrix[upper_triangle_indices]\n\n    return rdm_vector\n\ndef compute_r_cv(M_A: np.ndarray, M_B: np.ndarray, N_1: np.ndarray, N_2: np.ndarray) - float:\n    \"\"\"\n    Computes the cross-validated Pearson correlation between model and neural RDMs.\n\n    Args:\n        M_A: Model response matrix, split A.\n        M_B: Model response matrix, split B.\n        N_1: Neural response matrix, split 1.\n        N_2: Neural response matrix, split 2.\n\n    Returns:\n        The cross-validated correlation coefficient, r_cv.\n    \"\"\"\n    # Step 1: Compute the four RDM vectors\n    v_M_A = compute_rdm_vector(M_A)\n    v_M_B = compute_rdm_vector(M_B)\n    v_N_1 = compute_rdm_vector(N_1)\n    v_N_2 = compute_rdm_vector(N_2)\n\n    # Step 2: Compute the two cross-correlations\n    # np.corrcoef returns a 2x2 matrix, the value is at [0, 1] or [1, 0]\n    r1 = np.corrcoef(v_M_A, v_N_2)[0, 1]\n    r2 = np.corrcoef(v_M_B, v_N_1)[0, 1]\n\n    # Step 3: Average correlations using Fisher z-transform\n    # numpy.arctanh is the Fisher z-transform. It handles r = +/- 1 by returning +/- inf.\n    z1 = np.arctanh(r1)\n    z2 = np.arctanh(r2)\n    avg_z = (z1 + z2) / 2.0\n\n    # Step 4: Inverse transform to get the final r_cv\n    # numpy.tanh is the inverse of the Fisher z-transform.\n    r_cv = np.tanh(avg_z)\n    \n    return r_cv\n\ndef solve():\n    \"\"\"\n    Main function to run all scenarios and print the final results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Scenario 1 Data\n    M_motion_A = np.array([\n        [2.0, 2.0, 0.1, 0.0],\n        [1.9, 2.1, 0.0, 0.2],\n        [0.2, 0.0, 2.1, 2.0],\n        [0.0, 0.1, 1.9, 2.2],\n        [0.1, 0.2, 2.0, 2.1]\n    ])\n    M_motion_B = np.array([\n        [2.1, 1.9, 0.0, 0.1],\n        [2.0, 2.0, 0.1, 0.1],\n        [0.1, 0.0, 2.0, 2.2],\n        [0.0, 0.2, 2.2, 1.9],\n        [0.2, 0.1, 2.1, 2.0]\n    ])\n    N_MT_1 = np.array([\n        [2.2, 2.1, 0.0, 0.1],\n        [1.8, 2.0, 0.1, 0.1],\n        [0.0, 0.1, 2.2, 2.1],\n        [0.1, 0.0, 1.8, 2.0],\n        [0.1, 0.2, 2.1, 2.2]\n    ])\n    N_MT_2 = np.array([\n        [2.0, 2.2, 0.1, 0.0],\n        [2.1, 1.9, 0.0, 0.2],\n        [0.2, 0.0, 2.0, 2.1],\n        [0.0, 0.1, 2.2, 1.8],\n        [0.1, 0.2, 2.0, 2.3]\n    ])\n\n    # Scenario 2 Data\n    M_form_A = np.array([\n        [2.0, 2.0, 0.1, 0.0],\n        [0.1, 0.0, 2.0, 2.0],\n        [2.1, 1.9, 0.0, 0.1],\n        [0.0, 0.1, 2.1, 1.9],\n        [1.0, 1.1, 0.9, 1.0]\n    ])\n    M_form_B = np.array([\n        [2.1, 1.9, 0.0, 0.1],\n        [0.0, 0.1, 2.1, 1.9],\n        [1.9, 2.1, 0.1, 0.0],\n        [0.1, 0.0, 1.9, 2.1],\n        [1.1, 1.0, 1.0, 0.9]\n    ])\n    N_IT_1 = np.array([\n        [2.2, 2.1, 0.0, 0.1],\n        [0.0, 0.1, 2.0, 2.1],\n        [1.8, 2.0, 0.1, 0.0],\n        [0.1, 0.0, 1.9, 2.0],\n        [1.1, 1.0, 0.9, 1.0]\n    ])\n    N_IT_2 = np.array([\n        [2.0, 2.2, 0.1, 0.0],\n        [0.1, 0.0, 2.2, 1.8],\n        [2.1, 1.9, 0.0, 0.2],\n        [0.0, 0.2, 1.8, 2.2],\n        [0.9, 1.0, 1.1, 1.0]\n    ])\n\n    # Scenario 4 Data\n    R = np.array([\n        [0.0, 1.0, 2.0],\n        [0.5, 1.0, 1.5],\n        [2.0, 1.0, 0.0],\n        [1.5, 1.0, 0.5]\n    ])\n\n    # Execute all scenarios\n    r_cv1 = compute_r_cv(M_motion_A, M_motion_B, N_MT_1, N_MT_2)\n    r_cv2 = compute_r_cv(M_form_A, M_form_B, N_IT_1, N_IT_2)\n    r_cv3 = compute_r_cv(M_motion_A, M_motion_B, N_IT_1, N_IT_2)\n    r_cv4 = compute_r_cv(R, R, R, R)\n\n    results = [r_cv1, r_cv2, r_cv3, r_cv4]\n\n    # Format and print the final output as specified.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}