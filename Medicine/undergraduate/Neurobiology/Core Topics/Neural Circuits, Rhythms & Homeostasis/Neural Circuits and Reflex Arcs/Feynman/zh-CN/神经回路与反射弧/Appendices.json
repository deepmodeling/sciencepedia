{
    "hands_on_practices": [
        {
            "introduction": "神经信号在反射弧中的传递速度是决定反应时间的关键因素。本练习旨在通过一个简化的场景，让您亲手计算不同传导速度的神经纤维所造成的信号到达时间差异。通过这个计算，您将更深刻地理解轴突髓鞘化程度为何对神经系统的时间精度和信息处理至关重要 。",
            "id": "5036479",
            "problem": "人体下肢的单关节单突触牵张反射由一次短暂的叩击引发，该叩击同步兴奋了两群肌梭初级传入神经纤维。这两群神经纤维通过同一条长度为 $L=1.000\\,\\mathrm{m}$ 的笔直轴突路径投射到脊髓。其中一群由重度髓鞘化的快速传导轴突组成，传导速度为 $v_{\\mathrm{fast}}=60.00\\,\\mathrm{m/s}$；另一群由中度髓鞘化的轴突组成，传导速度为 $v_{\\mathrm{slow}}=30.00\\,\\mathrm{m/s}$。假设轴突传导沿路径是均匀的，并且除了轴突传导之外的所有延迟（感受器转导、突触传递和运动传出传导）都可以忽略不计。请仅使用运动学和可兴奋组织中传导的基本定义，确定来自较慢传入神经纤维的动作电位比来自较快传入神经纤维的动作电位晚多少时间到达脊髓。请将最终答案表示为一个等于较慢传入神经纤维到达时间减去较快传入神经纤维到达时间的数值，单位为 $\\mathrm{ms}$。将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求计算沿两群不同传入轴突（一群为快速传导，另一群为慢速传导）传播的动作电位到达脊髓的时间差。该问题表述清晰，并以神经生理学和运动学原理为科学基础。所有必要的数据均已提供，且简化假设也已明确说明。\n\n解决该问题的基本原理是匀速运动的关系式，即以恒定速度 $v$ 行进距离 $L$ 所需的时间 $t$ 由以下方程给出：\n$$t = \\frac{L}{v}$$\n这个原理在这里直接适用，因为问题指明了轴突传导速度在整个路径上是均匀的。\n\n我们已知以下数值：\n轴突路径的长度，$L = 1.000\\,\\mathrm{m}$。\n快速传导轴突的传导速度，$v_{\\mathrm{fast}} = 60.00\\,\\mathrm{m/s}$。\n慢速传导轴突的传导速度，$v_{\\mathrm{slow}} = 30.00\\,\\mathrm{m/s}$。\n\n我们可以计算每群轴突的传播时间。设 $t_{\\mathrm{fast}}$ 为快速传入神经纤维的时间，$t_{\\mathrm{slow}}$ 为慢速传入神经纤维的时间。\n\n快速传导群的传导时间为：\n$$t_{\\mathrm{fast}} = \\frac{L}{v_{\\mathrm{fast}}}$$\n\n慢速传导群的传导时间为：\n$$t_{\\mathrm{slow}} = \\frac{L}{v_{\\mathrm{slow}}}$$\n\n问题要求的是来自较慢传入神经纤维的动作电位比来自较快传入神经纤维的晚多少时间到达。这个量是它们到达时间的差值，我们将其表示为 $\\Delta t$。\n$$\\Delta t = t_{\\mathrm{slow}} - t_{\\mathrm{fast}}$$\n由于问题说明两群神经纤维被同步兴奋，这个时间差完全是由轴突传导时间的差异造成的。\n\n将 $t_{\\mathrm{slow}}$ 和 $t_{\\mathrm{fast}}$ 的表达式代入 $\\Delta t$ 的方程：\n$$\\Delta t = \\frac{L}{v_{\\mathrm{slow}}} - \\frac{L}{v_{\\mathrm{fast}}}$$\n我们可以提取公因数 $L$：\n$$\\Delta t = L \\left( \\frac{1}{v_{\\mathrm{slow}}} - \\frac{1}{v_{\\mathrm{fast}}} \\right)$$\n现在，我们将给定的数值代入这个表达式：\n$$\\Delta t = 1.000\\,\\mathrm{m} \\left( \\frac{1}{30.00\\,\\mathrm{m/s}} - \\frac{1}{60.00\\,\\mathrm{m/s}} \\right)$$\n为了进行括号内的减法，我们找到公分母 $60.00$：\n$$\\Delta t = 1.000\\,\\mathrm{m} \\left( \\frac{2}{60.00\\,\\mathrm{m/s}} - \\frac{1}{60.00\\,\\mathrm{m/s}} \\right)$$\n$$\\Delta t = 1.000\\,\\mathrm{m} \\left( \\frac{1}{60.00\\,\\mathrm{m/s}} \\right)$$\n$$\\Delta t = \\frac{1.000}{60.00}\\,\\mathrm{s}$$\n计算这个值得到：\n$$\\Delta t \\approx 0.016666...\\,\\mathrm{s}$$\n问题要求最终答案以毫秒（$\\mathrm{ms}$）表示。为了将秒（$\\mathrm{s}$）转换为毫秒，我们乘以转换因子 $1000\\,\\mathrm{ms/s}$：\n$$\\Delta t_{\\mathrm{ms}} = \\Delta t \\times 1000$$\n$$\\Delta t_{\\mathrm{ms}} = \\frac{1.000}{60.00} \\times 1000\\,\\mathrm{ms} = \\frac{1000}{60.00}\\,\\mathrm{ms}$$\n$$\\Delta t_{\\mathrm{ms}} = 16.6666...\\,\\mathrm{ms}$$\n最后，问题规定答案必须四舍五入到四位有效数字。结果的前四位有效数字是 $1$、$6$、$6$ 和 $6$。第五位数字是 $6$，大于或等于 $5$，所以我们必须将第四位有效数字向上取整。\n$$16.6666...\\,\\mathrm{ms} \\approx 16.67\\,\\mathrm{ms}$$\n因此，来自较慢传入神经纤维的动作电位比来自较快传入神经纤维的晚 $16.67\\,\\mathrm{ms}$ 到达。",
            "answer": "$$\n\\boxed{16.67}\n$$"
        },
        {
            "introduction": "在执行运动指令时，并非所有运动神经元都会同时被激活。本练习将引导您运用欧姆定律的基本形式（$\\Delta V = I R$）来探索这一现象背后的“大小原则”。您将通过计算发现，对于相同的突触输入电流，具有较高输入电阻（通常对应较小尺寸）的神经元会产生更大的电压响应，从而被优先募集，这揭示了运动控制中一个优雅而高效的组织原则 。",
            "id": "5036410",
            "problem": "两个脊髓α-运动神经元参与一个单突触牵张反射弧，并接收到一个幅度为 $I = 1\\,\\mathrm{nA}$ 的相同兴奋性突触后电流 (EPSC)。神经元的输入电阻不同：神经元 $\\mathrm{A}$ 的输入电阻为 $R_{\\mathrm{in},A} = 3\\,\\mathrm{M}\\Omega$，神经元 $\\mathrm{B}$ 的输入电阻为 $R_{\\mathrm{in},B} = 1\\,\\mathrm{M}\\Omega$。假设每个胞体可以近似为一个由突触电流驱动的被动、等电位膜片，并且相关的稳态膜电位变化可以很好地由平衡状态下电流和电压之间的被动膜关系来描述。同时假设两个运动神经元相对于静息状态具有相同的尖峰阈值，因此在相同突触电流下经历更大去极化的神经元将首先被募集。\n\n仅使用基本的被动膜原理，计算每个神经元响应电流 $I$ 时的稳态电压变化 $\\Delta V_{\\mathrm{ss}}$，并根据尺寸原则说明哪个神经元会先被募集。作为报告，请提供其稳态电压变化的比率作为最终答案，即\n$$\\frac{\\Delta V_{\\mathrm{ss}}(R_{\\mathrm{in}}=3\\,\\mathrm{M}\\Omega)}{\\Delta V_{\\mathrm{ss}}(R_{\\mathrm{in}}=1\\,\\mathrm{M}\\Omega)},$$\n作为一个没有单位的纯数。不需要四舍五入的指令，因为该比率可以精确计算。将最终比率表示为一个纯数（无单位）。",
            "solution": "被动神经元膜可以用标准的电流平衡方程来建模\n$$C_{\\mathrm{m}} \\frac{dV}{dt} + \\frac{V - E_{\\mathrm{L}}}{R_{\\mathrm{in}}} = I_{\\mathrm{syn}},$$\n其中 $C_{\\mathrm{m}}$ 是膜电容，$E_{\\mathrm{L}}$ 是漏泄反转电位，$R_{\\mathrm{in}}$ 是输入电阻，$I_{\\mathrm{syn}}$ 是突触电流。稳态由 $dV/dt = 0$ 定义，可得\n$$\\frac{V_{\\mathrm{ss}} - E_{\\mathrm{L}}}{R_{\\mathrm{in}}} = I_{\\mathrm{syn}}.$$\n将相对于漏泄反转电位的稳态去极化定义为 $\\Delta V_{\\mathrm{ss}} \\equiv V_{\\mathrm{ss}} - E_{\\mathrm{L}}$，我们得到线性的被动关系\n$$\\Delta V_{\\mathrm{ss}} = I_{\\mathrm{syn}} \\, R_{\\mathrm{in}}.$$\n这是被动膜在稳态下经过充分验证的欧姆行为。\n\n将此应用于每个具有相同突触电流 $I = 1\\,\\mathrm{nA}$ 的神经元：\n\n- 对于神经元 $\\mathrm{A}$，$R_{\\mathrm{in},A} = 3\\,\\mathrm{M}\\Omega$：\n$$\\Delta V_{\\mathrm{ss},A} = I \\, R_{\\mathrm{in},A} = \\left(1\\,\\mathrm{nA}\\right)\\left(3\\,\\mathrm{M}\\Omega\\right) = 3\\,\\mathrm{mV}.$$\n\n- 对于神经元 $\\mathrm{B}$，$R_{\\mathrm{in},B} = 1\\,\\mathrm{M}\\Omega$：\n$$\\Delta V_{\\mathrm{ss},B} = I \\, R_{\\mathrm{in},B} = \\left(1\\,\\mathrm{nA}\\right)\\left(1\\,\\mathrm{M}\\Omega\\right) = 1\\,\\mathrm{mV}.$$\n\n因此，它们稳态电压变化的比率为\n$$\\frac{\\Delta V_{\\mathrm{ss}}(R_{\\mathrm{in}}=3\\,\\mathrm{M}\\Omega)}{\\Delta V_{\\mathrm{ss}}(R_{\\mathrm{in}}=1\\,\\mathrm{M}\\Omega)} = \\frac{3\\,\\mathrm{mV}}{1\\,\\mathrm{mV}} = 3.$$\n\n关于募集顺序，在相对于静息状态具有相同尖峰阈值的假设下，对于相同的突触电流，具有较大稳态去极化的神经元将更早达到阈值。因此，输入电阻较高的神经元（神经元 $\\mathrm{A}$，$R_{\\mathrm{in}} = 3\\,\\mathrm{M}\\Omega$）在神经元 $\\mathrm{B}$ 之前被募集，这与尺寸原则一致。\n\n要求报告的最终量是这个比率，其精确值为 $3$，是一个无单位的数。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "将反射弧视为一个简单的线性通路是不完整的；它实际上是一个维持动态稳定性的闭环反馈控制系统。本练习将带您进入计算神经科学的世界，通过构建一个牵张反射的仿真模型来探索神经延迟如何影响系统的稳定性。通过亲自编写代码并进行模拟，您将直观地看到反馈增益和延迟之间的相互作用，并理解为何即使是微小的延迟增加也可能导致系统从稳定状态转变为振荡甚至失控 。",
            "id": "5036420",
            "problem": "您的任务是设计一个闭环计算实验，以量化附加的人工神经延迟如何降低单突触牵张反射的稳定性。将单个关节角度偏差建模为标量状态变量 $x(t)$，其中 $x(t)$ 表示与扰动前平衡点的偏差（无量纲）。肌肉-关节对象被建模为一个一阶线性系统，其时间常数为 $T$（单位：秒），接收运动指令 $u(t)$ 和外部扰动 $d(t)$：\n$$\nT \\frac{dx(t)}{dt} = -x(t) + u(t) + d(t).\n$$\n反射回路被建模为一个比例（P）控制器，作用于延迟的肌肉长度偏差，总神经延迟为 $\\tau = \\tau_{\\text{base}} + \\tau_{\\text{add}}$（单位：秒）：\n$$\nu(t) = -K\\,x(t - \\tau),\n$$\n其中 $K$ 是反射增益（无量纲），$\\tau_{\\text{base}}$ 是基线传导延迟（单位：秒），$\\tau_{\\text{add}}$ 是人工附加的延迟（单位：秒）。扰动是在 $t \\ge 0$ 时施加的单位阶跃扰动，即当 $t \\ge 0$ 时 $d(t) = A$ 且 $A = 1$，当 $t  0$ 时 $d(t) = 0$。$t  0$ 时的历史值为 $x(t) = 0$。\n\n您的任务是：\n- 使用前向欧拉离散化方法，以均匀时间步长 $\\Delta t = 0.0005$（秒）在总时长 $t_{\\max} = 3.0$（秒）内，实现延迟微分方程的闭环仿真。\n- 通过对存储的过去样本进行线性插值来近似延迟项 $x(t - \\tau)$。\n- 使用以下时域准则将仿真结果分类为稳定或不稳定：\n  - 如果 $\\max_{t \\in [0, t_{\\max}]} |x(t)|  X_{\\max}$，其中 $X_{\\max} = 5.0$，则分类为不稳定。\n  - 否则，计算 $x(t)$ 在最后四分之一时间窗口 $t \\in [0.75\\, t_{\\max}, t_{\\max}]$ 内的样本标准差，记为 $\\sigma_{\\text{late}}$。如果 $\\sigma_{\\text{late}} \\le \\varepsilon$，其中 $\\varepsilon = 0.02$，则分类为稳定；否则分类为不稳定。\n- 对于每组参数，在闭区间 $[0, \\tau_{\\max}]$（其中 $\\tau_{\\max} = 0.06$ 秒）中找到使系统被分类为稳定的最大附加延迟 $\\tau_{\\text{add}}^{\\star}$。在 $\\tau_{\\text{add}} \\in [0, \\tau_{\\max}]$ 上使用至少20次迭代的二分搜索来近似 $\\tau_{\\text{add}}^{\\star}$。\n\n需实现的离散化细节：\n- 令 $t_n = n \\Delta t$（对于整数 $n \\ge 0$），且 $x_n \\approx x(t_n)$，其中 $x_0 = 0$。\n- 定义 $d_n = A$（对于所有 $n \\ge 0$）。\n- 在每个步骤中，计算 $x_{\\text{delayed}}(t_n) \\approx (1 - \\alpha)\\,x_{m} + \\alpha\\,x_{m+1}$，其中 $m = \\lfloor (t_n - \\tau)/\\Delta t \\rfloor$ 且 $\\alpha = \\frac{(t_n - \\tau) - m \\Delta t}{\\Delta t}$，并约定当 $t  0$ 时 $x(t) = 0$。\n- 使用前向欧拉法更新：\n$$\nx_{n+1} = x_n + \\frac{\\Delta t}{T}\\left(-x_n - K\\,x_{\\text{delayed}}(t_n) + d_n\\right).\n$$\n\n搜索目标：\n- 对于每组参数 $(T, K, \\tau_{\\text{base}})$，计算 $\\tau_{\\text{add}}^{\\star}$ 至六位小数（单位：秒），其定义为在 $[0, \\tau_{\\max}]$ 区间内，根据上述准则系统被分类为稳定的附加延迟的上确界。\n\n测试套件：\n- 使用以下参数集，这些参数集共同探测了典型、高增益、零增益和快速对象等工况：\n  - 情况1：$T = 0.05$, $K = 6.0$, $\\tau_{\\text{base}} = 0.015$。\n  - 情况2：$T = 0.05$, $K = 12.0$, $\\tau_{\\text{base}} = 0.015$。\n  - 情况3：$T = 0.05$, $K = 0.0$, $\\tau_{\\text{base}} = 0.015$。\n  - 情况4：$T = 0.02$, $K = 8.0$, $\\tau_{\\text{base}} = 0.005$。\n\n答案规格：\n- 对于每种情况，将计算出的 $\\tau_{\\text{add}}^{\\star}$（单位：秒）作为一个浮点值输出，并四舍五入到恰好六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：$[0.012345,0.001000,0.060000,0.020500]$）。\n- 所有时间都必须以秒为单位表示。\n\n您的最终交付物必须是一个完整的、可运行的程序，该程序需实现所述的仿真、稳定性分类和二分搜索，并以上述指定的确切格式打印出四个测试用例的结果。",
            "solution": "问题陈述在内部是一致的，其科学基础植根于控制理论和神经生物学，并提供了一个良定义的计算任务。\n\n该解决方案是一个计算实验，旨在确定一个模型化的牵张反射回路的稳定性边界。问题的核心是一个一阶延迟微分方程（DDE），它模拟了在延迟比例反馈控制下关节角度的动力学。\n\n系统由以下方程描述：\n$$\nT \\frac{dx(t)}{dt} = -x(t) + u(t) + d(t)\n$$\n其中 $x(t)$ 是关节角度偏差，$T$ 是对象的时​​间常数，$u(t)$ 是神经控制信号，$d(t)$ 是外部扰动。反射回路提供的控制信号是状态的缩放和延迟版本：\n$$\nu(t) = -K\\,x(t - \\tau)\n$$\n这里，$K$ 是反射增益，$\\tau = \\tau_{\\text{base}} + \\tau_{\\text{add}}$ 是总环路延迟，由基线生理延迟 $\\tau_{\\text{base}}$ 和附加的人工延迟 $\\tau_{\\text{add}}$ 组成。将控制律代入对象动力学，得到闭环DDE：\n$$\nT \\frac{dx(t)}{dt} = -x(t) - K\\,x(t - \\tau) + d(t)\n$$\n系统从静止状态开始，$t  0$ 时 $x(t) = 0$，并在 $t \\ge 0$ 时受到单位阶跃扰动 $d(t) = 1$。\n\n为了数值求解此DDE，我们采用时间步长固定为 $\\Delta t = 0.0005$ 秒的前向欧拉法。令 $t_n = n \\Delta t$ 且 $x_n \\approx x(t_n)$。离散化的更新规则是：\n$$\nx_{n+1} = x_n + \\frac{\\Delta t}{T}\\left(-x_n - K\\,x_{\\text{delayed}}(t_n) + d_n\\right)\n$$\n其中，对于所有 $n \\ge 0$，$d_n = 1$，且 $x_0 = 0$。\n\n一个关键步骤是近似延迟状态 $x(t_n - \\tau)$。由于 $t_n - \\tau$ 通常不会与离散时间步重合，我们使用两个最近的过去时间点之间的线性插值。令 $s = (t_n - \\tau)/\\Delta t$ 为对应于延迟时间的非整数索引。其两端的整数索引为 $m = \\lfloor s \\rfloor$，小数部分为 $\\alpha = s - m$。插值由下式给出：\n$$\nx_{\\text{delayed}}(t_n) = (1 - \\alpha)\\,x_m + \\alpha\\,x_{m+1}\n$$\n其中 $x_k$ 是仿真历史记录中第 $k$ 步的值。初始条件 $t  0$ 时 $x(t) = 0$ 意味着如果 $t_n - \\tau  0$，那么 $x_{\\text{delayed}}(t_n) = 0$。这通过在插值期间将任何 $k  0$ 的历史值 $x_k$ 设置为零来处理。仿真运行的总时长为 $t_{\\max} = 3.0$ 秒。\n\n对于给定的参数集 $(T, K, \\tau)$，系统响应的稳定性使用一个由两部分组成的准则进行评估：\n1.  **幅值准则**：如果偏差超过最大允许阈值：$\\max_{t \\in [0, t_{\\max}]} |x(t)|  X_{\\max}$，其中 $X_{\\max} = 5.0$，则系统被分类为不稳定。这捕捉了无界发散的响应。\n2.  **变异性准则**：如果未满足幅值准则，我们评估其后期行为。在仿真的最后四分之一时间段 $t \\in [0.75\\,t_{\\max}, t_{\\max}]$ 内计算状态 $x(t)$ 的样本标准差 $\\sigma_{\\text{late}}$。如果 $\\sigma_{\\text{late}} \\le \\varepsilon$（其中 $\\varepsilon = 0.02$），则认为系统已达到稳态并分类为稳定。否则，将其分类为不稳定，这可以捕捉持续的振荡。\n\n主要目标是找到临界附加延迟 $\\tau_{\\text{add}}^{\\star}$，它被定义为在区间 $[0, \\tau_{\\max}]$（其中 $\\tau_{\\max} = 0.06$ 秒）内使系统保持稳定的最大值。该值代表了稳定域的边界。我们可以定义一个布尔函数 `is_stable`($\\tau_{\\text{add}}$)，如果系统稳定则返回真，否则返回假。预期随着 $\\tau_{\\text{add}}$ 的增加，此函数的返回值会从真变为假。\n\n为了找到 $\\tau_{\\text{add}}^{\\star}$，在区间 $[0, \\tau_{\\max}]$ 上采用二分搜索算法。该算法进行20次迭代以保证足够的精度。\n设搜索区间为 $[\\tau_{\\text{low}}, \\tau_{\\text{high}}]$。初始时，$\\tau_{\\text{low}}=0$ 且 $\\tau_{\\text{high}}=\\tau_{\\max}$。在每次迭代中：\n1.  计算中点：$\\tau_{\\text{mid}} = (\\tau_{\\text{low}} + \\tau_{\\text{high}}) / 2$。\n2.  使用 $\\tau_{\\text{add}} = \\tau_{\\text{mid}}$ 仿真系统，并评估其稳定性。\n3.  如果系统稳定，这意味着真实的 $\\tau_{\\text{add}}^{\\star}$ 至少为 $\\tau_{\\text{mid}}$。通过设置 $\\tau_{\\text{low}} = \\tau_{\\text{mid}}$ 在区间的上半部分继续搜索。\n4.  如果系统不稳定，则 $\\tau_{\\text{mid}}$ 太大，通过设置 $\\tau_{\\text{high}} = \\tau_{\\text{mid}}$ 将搜索限制在区间的下半部分。\n\n经过20次迭代后，$\\tau_{\\text{low}}$ 的值提供了 $\\tau_{\\text{add}}^{\\star}$（即稳定附加延迟集合的上确界）的一个高精度近似值。此过程应用于四个指定的参数集中的每一个，以获得最终结果。$K=0$ 的特殊情况代表一个开环系统，该系统是内在稳定的，因此其 $\\tau_{\\text{add}}^{\\star}$ 预期为 $\\tau_{\\max}$。",
            "answer": "```python\nimport numpy as np\n\ndef run_simulation(T, K, total_tau):\n    \"\"\"\n    Simulates the delayed differential equation using forward Euler.\n\n    Args:\n        T (float): Plant time constant.\n        K (float): Reflex gain.\n        total_tau (float): Total neural delay.\n\n    Returns:\n        np.ndarray: The history of the state variable x(t).\n    \"\"\"\n    # Define simulation parameters from the problem statement.\n    delta_t = 0.0005  # s\n    t_max = 3.0       # s\n    disturbance_amplitude = 1.0\n\n    num_steps = int(t_max / delta_t)\n    x_history = np.zeros(num_steps + 1)\n\n    delay_in_steps_float = total_tau / delta_t\n\n    # Main simulation loop using forward Euler.\n    for n in range(num_steps):\n        # Calculate the delayed term x(t - tau) using linear interpolation.\n        delayed_time_idx_float = n - delay_in_steps_float\n\n        if delayed_time_idx_float  0:\n            # If the delayed time is negative, the state is zero by convention.\n            x_delayed = 0.0\n        else:\n            m = int(np.floor(delayed_time_idx_float))\n            alpha = delayed_time_idx_float - m\n            \n            x_m = x_history[m]\n            x_m_plus_1 = x_history[m + 1]\n            \n            x_delayed = (1 - alpha) * x_m + alpha * x_m_plus_1\n\n        d_n = disturbance_amplitude\n        x_n = x_history[n]\n        \n        # Forward Euler update rule.\n        x_history[n + 1] = x_n + (delta_t / T) * (-x_n - K * x_delayed + d_n)\n        \n    return x_history\n\ndef check_stability(x_history):\n    \"\"\"\n    Classifies a simulation outcome as stable or unstable based on given criteria.\n\n    Args:\n        x_history (np.ndarray): The history of the state variable.\n\n    Returns:\n        bool: True if stable, False if unstable.\n    \"\"\"\n    # Define stability criteria parameters.\n    X_max = 5.0\n    epsilon = 0.02\n    t_max = 3.0\n    delta_t = 0.0005\n\n    # Criterion 1: Amplitude check for unbounded growth.\n    if np.max(np.abs(x_history))  X_max:\n        return False\n\n    # Criterion 2: Late-phase variability check for persistent oscillations.\n    num_steps = int(t_max / delta_t)\n    start_idx = int(0.75 * num_steps)\n    x_late = x_history[start_idx:]\n    \n    if len(x_late)  2:\n        # Not enough points for std dev, assume stable (no variability).\n        return True\n    \n    sigma_late = np.std(x_late, ddof=1) # Sample standard deviation.\n\n    return sigma_late = epsilon\n\ndef find_critical_delay(T, K, tau_base):\n    \"\"\"\n    Finds the largest added delay for stability using a bisection search.\n\n    Args:\n        T (float): Plant time constant.\n        K (float): Reflex gain.\n        tau_base (float): Baseline neural delay.\n\n    Returns:\n        float: The critical added delay tau_add_star.\n    \"\"\"\n    # Define search parameters.\n    tau_add_low = 0.0\n    tau_add_high = 0.06  # tau_max\n    iterations = 20\n\n    # For K=0, the feedback loop is open, system is always stable.\n    if K == 0.0:\n        return tau_add_high\n    \n    def is_stable(tau_add):\n        total_tau = tau_base + tau_add\n        x_history = run_simulation(T, K, total_tau)\n        return check_stability(x_history)\n\n    # Check if the system is unstable even with zero added delay.\n    if not is_stable(tau_add_low):\n        return 0.0\n        \n    # Bisection search to find the supremum of stable added delays.\n    low = tau_add_low\n    high = tau_add_high\n    \n    for _ in range(iterations):\n        mid = (low + high) / 2\n        if is_stable(mid):\n            # Midpoint is stable, so critical delay is at least mid.\n            # Search in the upper half.\n            low = mid\n        else:\n            # Midpoint is unstable, so critical delay is less than mid.\n            # Search in the lower half.\n            high = mid\n            \n    return low\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (T, K, tau_base)\n        (0.05, 6.0, 0.015),   # Case 1\n        (0.05, 12.0, 0.015),  # Case 2\n        (0.05, 0.0, 0.015),   # Case 3\n        (0.02, 8.0, 0.005),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        T, K, tau_base = case\n        tau_add_star = find_critical_delay(T, K, tau_base)\n        results.append(tau_add_star)\n\n    # Format output as a comma-separated list of floats with 6 decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}