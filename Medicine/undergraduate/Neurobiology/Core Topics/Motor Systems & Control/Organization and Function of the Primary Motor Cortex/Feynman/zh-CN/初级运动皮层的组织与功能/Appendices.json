{
    "hands_on_practices": [
        {
            "introduction": "要理解初级运动皮层（M1）的复杂功能，我们首先需要探究其基本构成单元——单个神经元的行为。这个练习将一个M1中的大型皮层脊髓神经元（Betz细胞）简化为一个经典的RC电路模型，这是计算神经科学中的一个基石。通过推导膜电位达到放电阈值所需的时间，你将亲身体验神经元的生物物理特性（如膜电容$C$和输入电阻$R$）如何决定其作为输入信号“积分器”的功能，并最终将连续的突触输入转化为离散的动作电位。",
            "id": "5049102",
            "problem": "Betz细胞是初级运动皮层(M1)中的一种大型V层皮质脊髓神经元，其胞体膜可以近似为一个电阻-电容元件。考虑一个Betz细胞，其相对于静息电位的膜电位$V(t)$在从$t=0$开始的恒定细胞内阶跃电流$I$的作用下，根据电容器电荷守恒和欧姆定律演变：$C \\frac{dV}{dt} + \\frac{V}{R} = I$（对于$t \\ge 0$），初始条件为$V(0)=0$。此处，$C$是膜电容，$R$是输入电阻，$I$是注入电流。相对于静息电位的发放阈值为$V_{\\text{th}}$。\n\n仅使用这些基本关系，推导膜电位首次达到阈值的时间$t_{\\text{th}}$的表达式，其定义为$V(t_{\\text{th}})=V_{\\text{th}}$。然后，对于一个Betz细胞，当$I = 1.0 \\times 10^{-9}\\,\\text{A}$，$R = 50 \\times 10^{6}\\,\\Omega$，$C = 5.0 \\times 10^{-10}\\,\\text{F}$，$V_{\\text{th}} = 15 \\times 10^{-3}\\,\\text{V}$时，计算$t_{\\text{th}}$的数值。假设$I R > V_{\\text{th}}$，以确保阈值是可达到的。将最终时间以毫秒为单位表示，并将数值答案四舍五入到四位有效数字。最后，利用您推导出的表达式，定性地解释增加$C$如何影响这类神经元发放起始的时间精度。",
            "solution": "问题陈述被评估为有效。它在科学上基于电路理论原理，并将其应用于一个标准的、简化的神经元模型（漏积分-发放模型）。该问题是适定的，包含一个带初始条件的一阶线性常微分方程，这保证了其解的唯一性。所有参数都已定义，且给出的数值对于一个大型神经元来说在物理上是现实的。条件 $I R > V_{\\text{th}}$ 确保了阈值是可达到的，从而使问题可解。\n\n任务是推导达到阈值的时间$t_{\\text{th}}$，在特定情况下计算其数值，并解释电容$C$在发放时间精度中的作用。\n\n首先，我们求解膜电位$V(t)$。其控制方程是一个一阶线性常微分方程：\n$$\nC \\frac{dV}{dt} + \\frac{V}{R} = I\n$$\n我们可以将其重排为标准形式 $\\frac{dy}{dx} + P(x)y = Q(x)$：\n$$\n\\frac{dV}{dt} + \\frac{1}{RC}V = \\frac{I}{C}\n$$\n令膜时间常数为$\\tau_m = RC$。方程变为：\n$$\n\\frac{dV}{dt} + \\frac{1}{\\tau_m}V = \\frac{I}{C}\n$$\n通解是齐次解$V_h(t)$和特解$V_p(t)$的和。\n齐次方程为$\\frac{dV_h}{dt} + \\frac{1}{\\tau_m}V_h = 0$，其解为$V_h(t) = A \\exp(-t/\\tau_m)$，其中$A$是一个积分常数。\n对于特解，由于强迫项$I/C$是常数，我们假设一个常数解$V_p(t) = K$。将其代入完整的常微分方程得到：\n$$\n0 + \\frac{K}{\\tau_m} = \\frac{I}{C} \\implies K = \\frac{I\\tau_m}{C} = \\frac{I(RC)}{C} = IR\n$$\n因此，特解为$V_p(t) = IR$。\n膜电位的通解是齐次解和特解的和：\n$$\nV(t) = V_h(t) + V_p(t) = A \\exp(-t/\\tau_m) + IR\n$$\n我们使用初始条件$V(0)=0$来确定常数$A$：\n$$\nV(0) = A \\exp(0) + IR = A + IR = 0 \\implies A = -IR\n$$\n将$A$代回通解，得到膜电位作为时间函数的特定解：\n$$\nV(t) = IR - IR \\exp(-t/\\tau_m) = IR \\left(1 - \\exp\\left(-\\frac{t}{RC}\\right)\\right)\n$$\n该方程描述了膜电容向稳态电压$IR$充电的过程。\n\n接下来，我们推导达到阈值的时间$t_{\\text{th}}$的表达式。这是$V(t)$首次达到阈值电位$V_{\\text{th}}$的时间。我们令$V(t_{\\text{th}}) = V_{\\text{th}}$并求解$t_{\\text{th}}$：\n$$\nV_{\\text{th}} = IR \\left(1 - \\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right)\\right)\n$$\n问题陈述中提到$IR > V_{\\text{th}}$，这确保了$0 < V_{\\text{th}}/(IR) < 1$，从而保证$t_{\\text{th}}$有一个实数正解。\n我们重排方程以求解$t_{\\text{th}}$：\n$$\n\\frac{V_{\\text{th}}}{IR} = 1 - \\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right)\n$$\n$$\n\\exp\\left(-\\frac{t_{\\text{th}}}{RC}\\right) = 1 - \\frac{V_{\\text{th}}}{IR}\n$$\n对两边取自然对数：\n$$\n-\\frac{t_{\\text{th}}}{RC} = \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right)\n$$\n最后，求解$t_{\\text{th}}$得到其符号表达式：\n$$\nt_{\\text{th}} = -RC \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right)\n$$\n现在，我们使用给定的参数计算$t_{\\text{th}}$的数值：\n$I = 1.0 \\times 10^{-9}\\,\\text{A}$\n$R = 50 \\times 10^{6}\\,\\Omega$\n$C = 5.0 \\times 10^{-10}\\,\\text{F}$\n$V_{\\text{th}} = 15 \\times 10^{-3}\\,\\text{V}$\n\n首先，我们用国际单位制单位计算这些乘积项：\n时间常数 $\\tau_m = RC$：\n$$\n\\tau_m = (50 \\times 10^{6}\\,\\Omega) \\times (5.0 \\times 10^{-10}\\,\\text{F}) = 250 \\times 10^{-4}\\,\\text{s} = 0.025\\,\\text{s}\n$$\n稳态电压 $V_{\\infty} = IR$：\n$$\nV_{\\infty} = (1.0 \\times 10^{-9}\\,\\text{A}) \\times (50 \\times 10^{6}\\,\\Omega) = 50 \\times 10^{-3}\\,\\text{V} = 0.050\\,\\text{V}\n$$\n无量纲比值 $V_{\\text{th}}/(IR)$：\n$$\n\\frac{V_{\\text{th}}}{IR} = \\frac{15 \\times 10^{-3}\\,\\text{V}}{50 \\times 10^{-3}\\,\\text{V}} = 0.3\n$$\n现在，我们将这些值代入$t_{\\text{th}}$的表达式中：\n$$\nt_{\\text{th}} = -(0.025\\,\\text{s}) \\ln(1 - 0.3) = -(0.025\\,\\text{s}) \\ln(0.7)\n$$\n使用$\\ln(0.7) \\approx -0.3566749$：\n$$\nt_{\\text{th}} \\approx -(0.025\\,\\text{s}) \\times (-0.3566749) \\approx 0.00891687\\,\\text{s}\n$$\n问题要求答案以毫秒为单位，并四舍五入到四位有效数字：\n$$\nt_{\\text{th}} \\approx 8.917 \\times 10^{-3}\\,\\text{s} = 8.917\\,\\text{ms}\n$$\n\n最后，我们定性地解释增加$C$如何影响神经元发放起始的时间精度。时间精度指的是在有噪声存在的情况下，发放时间的可靠性。较低的精度意味着在给定噪声水平下，发放时间的方差较大。\n我们推导出的表达式 $t_{\\text{th}} = -RC \\ln(1 - V_{\\text{th}}/IR)$ 表明，$t_{\\text{th}}$与$C$成正比。因此，增加电容会增加达到阈值所需的时间。神经元成为其输入电流的“更慢的”积分器。\n\n为了理解时间精度，我们必须考虑膜电位在接近阈值$V_{\\text{th}}$时的变化率$\\frac{dV}{dt}$。更陡峭的斜率（$\\frac{dV}{dt}$较大）意味着电压的微小波动（由电流噪声引起）只会导致穿越阈值时间的微小变化。相反，更平缓的斜率（$\\frac{dV}{dt}$较小）意味着同样微小的电压波动会导致发放时间的较大变化，从而降低了时间精度。\n电压的变化率可以通过重排原始的常微分方程得到：\n$$\n\\frac{dV}{dt} = \\frac{1}{C}\\left(I - \\frac{V}{R}\\right) = \\frac{IR - V}{RC}\n$$\n当电位达到阈值，$V=V_{\\text{th}}$时，该点轨迹的斜率为：\n$$\n\\frac{dV}{dt}\\Bigg|_{t=t_{\\text{th}}} = \\frac{IR - V_{\\text{th}}}{RC}\n$$\n从这个表达式可以看出，阈值处电压轨迹的斜率与电容$C$成反比。因此，增加$C$会减小斜率，使得电压上升到阈值的过程更平缓。这种更平缓的轨迹意味着膜电位中的任何噪声都会在穿越阈值的确切时间$t_{\\text{th}}$上引起更大的抖动或不确定性。\n总之，增加膜电容$C$通过在更长的时间窗口内平滑高频输入波动，使神经元成为一个更好的积分器，但这以牺牲发放起始的时间精度为代价。神经元的功能从“符合检测器”（低$C$，高精度）转变为“积分器”（高$C$，低精度）。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -RC \\ln\\left(1 - \\frac{V_{\\text{th}}}{IR}\\right) & 8.917 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在单个神经元的基础上，我们进而探究M1神经元群体如何编码运动信息，这是一个长期存在且至关重要的科学问题：M1编码的是运动的轨迹（运动学变量，如速度），还是产生运动的力（动力学变量）？这项计算练习将让你扮演神经科学家的角色，利用真实研究中使用的数据分析方法——跨条件回归泛化（cross-condition regression generalization）——来检验这两个相互竞争的假说。通过这个实践，你将学会如何运用计算模型来从神经活动数据中提取关于大脑功能的深刻见解。",
            "id": "5049049",
            "problem": "您将执行一项基于神经生物学的计算任务，以判断在两种外部负载条件下，初级运动皮层 (M1) 神经元中观察到的调谐漂移是由运动学编码还是动力学编码更好地解释。通常观察到，初级运动皮层 (M1) 表现出方向性调谐的发放，其可以局部地通过与手部运动学（例如速度）或动力学（例如力或力矩）的线性关系来近似。对于小范围内的线性编码模型，将发放速率近似为运动相关变量的线性函数是合理的。您的程序必须通过跨条件回归泛化来实现模型比较。\n\n数学设置：\n- 令 $r^{(c)}(t)$ 表示在条件 $c \\in \\{1,2\\}$ 下，单个神经元在时间索引 $t$ 的发放速率（单位：spikes/s）。\n- 令 $\\mathbf{v}^{(c)}(t) \\in \\mathbb{R}^2$ 表示平面手部速度矢量（单位：cm/s）。\n- 令 $\\mathbf{F}^{(c)}(t) \\in \\mathbb{R}^2$ 表示平面手部力矢量（单位：牛顿），其模型为 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$，其中 $\\alpha$ 是一个单位为 N/(cm/s) 的常数，$\\mathbf{L}^{(c)}$ 是条件 $c$ 下的恒定外部负载矢量（单位：牛顿）。\n- 运动学模型（速度编码）：\n$$\nr^{(c)}(t) = \\beta_0^{(c)} + \\boldsymbol{\\beta}^{(c)} \\cdot \\mathbf{v}^{(c)}(t) + \\epsilon^{(c)}(t),\n$$\n其中 $\\beta_0^{(c)} \\in \\mathbb{R}$，$\\boldsymbol{\\beta}^{(c)} \\in \\mathbb{R}^2$，$\\epsilon^{(c)}(t)$ 是零均值噪声。\n- 动力学模型（力编码）：\n$$\nr^{(c)}(t) = \\gamma_0^{(c)} + \\boldsymbol{\\gamma}^{(c)} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t),\n$$\n其中 $\\gamma_0^{(c)} \\in \\mathbb{R}$，$\\boldsymbol{\\gamma}^{(c)} \\in \\mathbb{R}^2$，$\\epsilon^{(c)}(t)$ 是零均值噪声。\n\n基于回归的比较：\n- 对于给定模型 $m \\in \\{\\text{kinematic}, \\text{kinetic}\\}$，分别为条件 1 和 2 构建设计矩阵 $\\mathbf{X}_1^{(m)}$ 和 $\\mathbf{X}_2^{(m)}$，每个矩阵包含三列：一个截距（全为 1），以及相关回归量（运动学模型为 $\\mathbf{v}$，动力学模型为 $\\mathbf{F}$）的两个分量。\n- 对于每个模型 $m$，通过在一个条件下拟合普通最小二乘法并在另一个条件下评估均方误差来计算跨条件泛化误差，并对称平均：\n$$\n\\hat{\\mathbf{w}}_1^{(m)} = \\arg\\min_{\\mathbf{w}} \\lVert \\mathbf{X}_1^{(m)} \\mathbf{w} - \\mathbf{y}_1 \\rVert_2^2, \\quad \n\\hat{\\mathbf{w}}_2^{(m)} = \\arg\\min_{\\mathbf{w}} \\lVert \\mathbf{X}_2^{(m)} \\mathbf{w} - \\mathbf{y}_2 \\rVert_2^2,\n$$\n$$\n\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_2 - \\mathbf{X}_2^{(m)} \\hat{\\mathbf{w}}_1^{(m)} \\rVert_2^2, \\quad\n\\mathrm{MSE}_{2\\rightarrow 1}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_1 - \\mathbf{X}_1^{(m)} \\hat{\\mathbf{w}}_2^{(m)} \\rVert_2^2,\n$$\n$$\nE_m = \\frac{1}{2} \\left( \\mathrm{MSE}_{1\\rightarrow 2}^{(m)} + \\mathrm{MSE}_{2\\rightarrow 1}^{(m)} \\right),\n$$\n其中 $\\mathbf{y}_c$ 是将 $t = 1,\\dots,n$ 的 $r^{(c)}(t)$ 堆叠而成的向量，$n$ 是每个条件的样本数。\n\n决策规则：\n- 如果 $E_{\\text{kinematic}} \\leq E_{\\text{kinetic}}$，则宣布运动学模型是更好的解释；否则宣布动力学模型是更好的解释。输出一个布尔值，其中 $\\text{True}$ 表示运动学模型更优，$\\text{False}$ 表示动力学模型更优。在完全相等的情况下，选择运动学模型（即 $\\text{True}$）。\n\n单位和角度约定：\n- 速度必须以 cm/s 为单位。\n- 力必须以牛顿为单位。\n- 发放速率必须以 spikes/s 为单位。\n- 用于调谐计算的任何内部角度都应以弧度为单位。最终输出中不包含任何角度。\n\n测试套件规范：\n您必须实现以下三种情况。在所有情况下，都有 $n=8$ 个运动方向，方向角为\n$$\n\\theta_i \\in \\{0, \\frac{\\pi}{4}, \\frac{\\pi}{2}, \\frac{3\\pi}{4}, \\pi, \\frac{5\\pi}{4}, \\frac{3\\pi}{2}, \\frac{7\\pi}{4}\\},\n$$\n恒定速率 $s = 10$ cm/s，且 $\\mathbf{v}(t) = s[\\cos\\theta_t, \\sin\\theta_t]$。使用确定性噪声向量\n$$\n\\boldsymbol{\\epsilon}^{(1)} = [0.05, -0.03, 0.02, -0.01, 0.04, -0.02, 0.03, -0.04],\n$$\n$$\n\\boldsymbol{\\epsilon}^{(2)} = [0.01, -0.02, 0.03, -0.01, 0.02, -0.03, 0.01, -0.02],\n$$\n分别逐样本应用于条件 1 和 2。\n\n- 情况 1（理想路径：主要为运动学编码）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n    - 运动学系数：$\\beta_0 = 5$ spikes/s, $\\boldsymbol{\\beta} = [0.8, 0.2]$ spikes/(cm/s)。\n    - 生成发放速率为 $r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}^{(c)}(t) + \\epsilon^{(c)}(t)$。\n\n- 情况 2（相反路径：主要为动力学编码）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [5, 0]$ N。\n    - 动力学系数：$\\gamma_0 = 6$ spikes/s, $\\boldsymbol{\\gamma} = [0.5, -0.3]$ spikes/N。\n    - 生成发放速率为 $r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$，其中 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$。\n\n- 情况 3（边缘情况：混合编码，可能出现平局）：\n    - $\\alpha = 0.5$ N/(cm/s)。\n    - $\\mathbf{L}^{(1)} = [0, 0]$ N, $\\mathbf{L}^{(2)} = [2, -2]$ N。\n    - 运动学系数：$\\beta_0 = 4$ spikes/s, $\\boldsymbol{\\beta} = [0.6, 0.6]$ spikes/(cm/s)。\n    - 动力学系数：$\\gamma_0 = 4$ spikes/s, $\\boldsymbol{\\gamma} = [0.4, 0.1]$ spikes/N。\n    - 混合权重：$w_k = 0.5$, $w_f = 0.5$。\n    - 生成发放速率为 $r^{(c)}(t) = w_k(\\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}^{(c)}(t)) + w_f(\\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t)) + \\epsilon^{(c)}(t)$，其中 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}^{(c)}(t) + \\mathbf{L}^{(c)}$。\n\n您的程序必须：\n- 为每种情况构建如上所述的数据集。\n- 对于每种情况，使用所述的回归程序计算跨条件泛化误差 $E_{\\text{kinematic}}$ 和 $E_{\\text{kinetic}}$。\n- 根据上述决策规则，为每种情况生成一个布尔结果，指示运动学编码是否通过回归比较更好地解释了观察到的调谐漂移。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[\\text{result1},\\text{result2},\\text{result3}]$），每个结果都是一个布尔值（$\\text{True}$ 表示运动学更优；$\\text{False}$ 表示动力学更优）。不应打印任何其他文本。",
            "solution": "该问题要求我们实现一个模型比较程序，以确定在两种不同的外部负载条件下，是运动学编码模型还是动力学编码模型能更好地解释来自初级运动皮层 (M1) 的模拟神经发放数据。比较方法是跨条件回归泛化，这是计算神经科学中用于在相互竞争的神经功能模型之间进行仲裁的标准技术。\n\n其核心原则是，一个好的神经编码模型，其参数对于模型已明确考虑到的外部条件变化应保持不变。例如，如果一个神经元真正编码的是力，那么即使外部负载发生变化，其力调谐参数（$\\gamma_0$, $\\boldsymbol{\\gamma}$）也应保持恒定。具有这种不变参数的模型，在一种条件下训练并在另一种条件下测试时，会表现出良好的泛化能力。相反，一个未能捕捉到真实潜在变量的模型，其参数会随条件变化而变化，因此泛化能力会很差。\n\n我们将分析三种不同的情况，每种情况代表一种不同的神经编码基准真相。对于每种情况，我们将：\n1.  为两种条件 $c \\in \\{1, 2\\}$，在 $n=8$ 个时间点（对应 8 个运动方向）上，生成运动学变量（速度 $\\mathbf{v}^{(c)}(t)$）、动力学变量（力 $\\mathbf{F}^{(c)}(t)$）和神经响应（发放速率 $r^{(c)}(t)$）。\n2.  为运动学和动力学模型构建设计矩阵。\n3.  使用普通最小二乘 (OLS) 回归分别对每个条件的数据拟合每个模型的参数。\n4.  通过计算在使用从一个条件拟合的参数预测另一个条件的数据时的均方误差 (MSE)，来评估每个模型的泛化性能。\n5.  对两个跨条件 MSE 进行平均，得到每个模型 $m$ 的对称误差分数 $E_m$。\n6.  应用决策规则：如果 $E_{\\text{kinematic}} \\leq E_{\\text{kinetic}}$，则认为运动学模型更优。\n\n让我们为任意给定情况形式化这些步骤。首先，我们生成运动学数据。速率是恒定的 $s=10$ cm/s，方向由 $\\theta_t \\in \\{0, \\frac{\\pi}{4}, \\frac{\\pi}{2}, \\frac{3\\pi}{4}, \\pi, \\frac{5\\pi}{4}, \\frac{3\\pi}{2}, \\frac{7\\pi}{4}\\}$ 给出，对应 $t=1, \\dots, 8$。时间 $t$ 的速度矢量为 $\\mathbf{v}(t) = [v_x(t), v_y(t)]^T = s[\\cos\\theta_t, \\sin\\theta_t]^T$。速度与负载条件无关，因此 $\\mathbf{v}^{(1)}(t) = \\mathbf{v}^{(2)}(t) = \\mathbf{v}(t)$。\n\n力矢量被建模为 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}$，其中 $\\alpha$ 是一个类粘性系数，$\\mathbf{L}^{(c)}$ 是条件 $c$ 的外部负载矢量。\n\n发放速率 $y_c = [r^{(c)}(1), \\dots, r^{(c)}(8)]^T$ 根据每种情况的具体规则生成。\n\n对于每个模型 $m \\in \\{\\text{kinematic}, \\text{kinetic}\\}$，我们建立一个线性回归问题。一般形式为 $\\mathbf{y}_c = \\mathbf{X}_c^{(m)} \\mathbf{w}_c^{(m)} + \\boldsymbol{\\epsilon}_c$。\n- 对于运动学模型，回归量是速度分量。由于速度相同，设计矩阵 $\\mathbf{X}_{\\text{kin}}$ 对两种条件都相同。它是一个 $n \\times 3$ 矩阵，其第 $t$ 行为 $[1, v_x(t), v_y(t)]$。\n- 对于动力学模型，回归量是力分量。由于力取决于负载 $\\mathbf{L}^{(c)}$，设计矩阵 $\\mathbf{X}_{\\text{kinet}}^{(c)}$ 对每个条件都不同。$\\mathbf{X}_{\\text{kinet}}^{(c)}$ 的第 $t$ 行为 $[1, F_x^{(c)}(t), F_y^{(c)}(t)]$。\n\n权重向量 $\\mathbf{w}$ 的 OLS 解由 $\\hat{\\mathbf{w}} = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$ 给出。我们计算四个这样的权重向量：$\\hat{\\mathbf{w}}_1^{(\\text{kin})}$、$\\hat{\\mathbf{w}}_2^{(\\text{kin})}$、$\\hat{\\mathbf{w}}_1^{(\\text{kinet})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kinet})}$。\n\n跨条件 MSE 计算如下：\n$\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_2 - \\mathbf{X}_2^{(m)} \\hat{\\mathbf{w}}_1^{(m)} \\rVert_2^2$\n$\\mathrm{MSE}_{2\\rightarrow 1}^{(m)} = \\frac{1}{n} \\lVert \\mathbf{y}_1 - \\mathbf{X}_1^{(m)} \\hat{\\mathbf{w}}_2^{(m)} \\rVert_2^2$\n模型 $m$ 的总误差为 $E_m = \\frac{1}{2} (\\mathrm{MSE}_{1\\rightarrow 2}^{(m)} + \\mathrm{MSE}_{2\\rightarrow 1}^{(m)})$。\n\n我们现在将此程序应用于三种情况中的每一种。\n\n**情况 1：主要为运动学编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s)，$\\mathbf{L}^{(1)} = [0, 0]$ N，$\\mathbf{L}^{(2)} = [5, 0]$ N。\n- 发放速率生成：$r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}(t) + \\epsilon^{(c)}(t)$，其中 $\\beta_0 = 5$ 且 $\\boldsymbol{\\beta} = [0.8, 0.2]$。\n- 发放速率由一个过程生成，其参数（$\\beta_0, \\boldsymbol{\\beta}$）相对于速度在不同条件下是稳定的。因此，运动学模型应该能很好地拟合数据，更重要的是，具有良好的泛化能力。系数 $\\hat{\\mathbf{w}}_1^{(\\text{kin})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kin})}$ 应该彼此非常相似，并且与真实参数 $[\\beta_0, \\beta_x, \\beta_y]^T = [5, 0.8, 0.2]^T$ 非常接近。因此，$E_{\\text{kinematic}}$ 预计会很小，主要由噪声项 $\\boldsymbol{\\epsilon}^{(c)}$ 决定。\n- 相比之下，发放速率和力之间的关系是不稳定的。$r^{(c)}(t) = \\beta_0 + \\boldsymbol{\\beta} \\cdot \\frac{1}{\\alpha}(\\mathbf{F}^{(c)}(t) - \\mathbf{L}^{(c)}) + \\epsilon^{(c)}(t) = (\\beta_0 - \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}) + (\\frac{1}{\\alpha}\\boldsymbol{\\beta}) \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$。截距项 $(\\beta_0 - \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)})$ 随负载 $\\mathbf{L}^{(c)}$ 而变化。在条件 1 上拟合的动力学模型对于条件 2 将有错误的截距，导致泛化能力差和较大的 $E_{\\text{kinetic}}$。\n- 预期：$E_{\\text{kinematic}} < E_{\\text{kinetic}}$，从而得到 `True` 输出。\n\n**情况 2：主要为动力学编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s)，$\\mathbf{L}^{(1)} = [0, 0]$ N，$\\mathbf{L}^{(2)} = [5, 0]$ N。\n- 发放速率生成：$r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t) + \\epsilon^{(c)}(t)$，其中 $\\gamma_0 = 6$ 且 $\\boldsymbol{\\gamma} = [0.5, -0.3]$。\n- 这与情况 1 相反。数据由一个稳定的动力学模型生成。动力学模型的参数在不同条件下是不变的。因此，我们预期 $\\hat{\\mathbf{w}}_1^{(\\text{kinet})}$ 和 $\\hat{\\mathbf{w}}_2^{(\\text{kinet})}$ 将与 $[\\gamma_0, \\gamma_x, \\gamma_y]^T = [6, 0.5, -0.3]^T$ 相似，并且 $E_{\\text{kinetic}}$ 应该很小。\n- 与速度的关系，$r^{(c)}(t) = \\gamma_0 + \\boldsymbol{\\gamma} \\cdot (\\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}) + \\epsilon^{(c)}(t) = (\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{L}^{(c)}) + (\\alpha\\boldsymbol{\\gamma}) \\cdot \\mathbf{v}(t) + \\epsilon^{(c)}(t)$，具有一个依赖于条件的截距 $(\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{L}^{(c)})$。运动学模型将无法泛化。\n- 预期：$E_{\\text{kinetic}} < E_{\\text{kinematic}}$，从而得到 `False` 输出。\n\n**情况 3：混合编码**\n- 参数：$\\alpha = 0.5$ N/(cm/s)，$\\mathbf{L}^{(1)} = [0, 0]$ N，$\\mathbf{L}^{(2)} = [2, -2]$ N。\n- 发放速率生成：$r^{(c)}(t) = w_k(\\beta_0 + \\boldsymbol{\\beta} \\cdot \\mathbf{v}(t)) + w_f(\\gamma_0 + \\boldsymbol{\\gamma} \\cdot \\mathbf{F}^{(c)}(t)) + \\epsilon^{(c)}(t)$，其中 $w_k=w_f=0.5$，$\\beta_0=4, \\boldsymbol{\\beta}=[0.6, 0.6]$，$\\gamma_0=4, \\boldsymbol{\\gamma}=[0.4, 0.1]$。\n- 发放速率是运动学项和动力学项的线性组合。我们可以通过将其完全用一个变量来表示来分析其结构。\n- 运动学表示：$r^{(c)}(t) = (\\dots) + (\\dots)\\cdot\\mathbf{v}(t)$。如情况 2 所示，代入 $\\mathbf{F}^{(c)}(t) = \\alpha \\mathbf{v}(t) + \\mathbf{L}^{(c)}$ 会导致一个依赖于 $\\mathbf{L}^{(c)}$ 的有效截距。\n- 动力学表示：我们代入 $\\mathbf{v}(t) = \\frac{1}{\\alpha}(\\mathbf{F}^{(c)}(t) - \\mathbf{L}^{(c)})$。\n$r^{(c)} = w_k(\\beta_0 + \\frac{1}{\\alpha}\\boldsymbol{\\beta}\\cdot(\\mathbf{F}^{(c)} - \\mathbf{L}^{(c)})) + w_f(\\gamma_0 + \\boldsymbol{\\gamma}\\cdot\\mathbf{F}^{(c)}) + \\epsilon^{(c)}$\n$r^{(c)} = (w_k\\beta_0 + w_f\\gamma_0 - \\frac{w_k}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}) + (\\frac{w_k}{\\alpha}\\boldsymbol{\\beta} + w_f\\boldsymbol{\\gamma})\\cdot\\mathbf{F}^{(c)} + \\epsilon^{(c)}$\n- 让我们检查有效截距：$\\gamma_{0, \\text{eff}}^{(c)} = w_k\\beta_0 + w_f\\gamma_0 - \\frac{w_k}{\\alpha}\\boldsymbol{\\beta}\\cdot\\mathbf{L}^{(c)}$。\n代入数值：$\\alpha=0.5, w_k=0.5, \\beta_0=4, \\gamma_0=4, \\boldsymbol{\\beta}=[0.6, 0.6]$。\n$\\gamma_{0, \\text{eff}}^{(c)} = 0.5(4) + 0.5(4) - \\frac{0.5}{0.5}([0.6, 0.6]\\cdot\\mathbf{L}^{(c)}) = 4 - [0.6, 0.6]\\cdot\\mathbf{L}^{(c)}$。\n对于条件 1：$\\mathbf{L}^{(1)} = [0, 0]$，所以 $\\gamma_{0, \\text{eff}}^{(1)} = 4$。\n对于条件 2：$\\mathbf{L}^{(2)} = [2, -2]$，所以 $[0.6, 0.6]\\cdot[2, -2] = 0.6(2) + 0.6(-2) = 1.2 - 1.2 = 0$。因此，$\\gamma_{0, \\text{eff}}^{(2)} = 4$。\n- 值得注意的是，对于这种特定的参数选择，有效的动力学截距在不同条件下是稳定的。有效的动力学斜率，$(\\frac{w_k}{\\alpha}\\boldsymbol{\\beta} + w_f\\boldsymbol{\\gamma})$，也是稳定的。这意味着混合模型可以被一个单一、不变的动力学模型完美地表示。\n- 因为动力学表示是稳定的，而运动学表示不是，所以动力学模型将具有好得多的泛化能力。\n- 预期：$E_{\\text{kinetic}} < E_{\\text{kinematic}}$，从而得到 `False` 输出。\n\n计算实现将精确遵循这一逻辑，以得出每种情况的最终布尔结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the three test cases for M1 encoding model comparison.\n    \"\"\"\n\n    def run_case(case_params: dict) -> bool:\n        \"\"\"\n        Runs a single case for model comparison.\n\n        Args:\n            case_params: A dictionary containing parameters for the case.\n\n        Returns:\n            A boolean, True if kinematic model is better or equal, False otherwise.\n        \"\"\"\n        # Common parameters\n        n_samples = 8\n        speed = 10.0\n        thetas = np.linspace(0, 2 * np.pi, n_samples, endpoint=False)\n        eps1 = np.array([0.05, -0.03, 0.02, -0.01, 0.04, -0.02, 0.03, -0.04])\n        eps2 = np.array([0.01, -0.02, 0.03, -0.01, 0.02, -0.03, 0.01, -0.02])\n\n        # Generate velocity data (same for both conditions)\n        v_data = speed * np.array([np.cos(thetas), np.sin(thetas)]).T\n\n        # Unpack case-specific parameters\n        alpha = case_params['alpha']\n        L1 = np.array(case_params['L1'])\n        L2 = np.array(case_params['L2'])\n\n        # Generate force data\n        F1_data = alpha * v_data + L1\n        F2_data = alpha * v_data + L2\n\n        # Generate firing rate data (response vectors y1, y2)\n        if case_params['type'] == 'kinematic':\n            beta0 = case_params['beta0']\n            beta_vec = np.array(case_params['beta'])\n            y1 = beta0 + v_data @ beta_vec + eps1\n            y2 = beta0 + v_data @ beta_vec + eps2\n        elif case_params['type'] == 'kinetic':\n            gamma0 = case_params['gamma0']\n            gamma_vec = np.array(case_params['gamma'])\n            y1 = gamma0 + F1_data @ gamma_vec + eps1\n            y2 = gamma0 + F2_data @ gamma_vec + eps2\n        elif case_params['type'] == 'mixed':\n            wk, wf = case_params['weights']\n            beta0, beta_vec = case_params['beta0'], np.array(case_params['beta'])\n            gamma0, gamma_vec = case_params['gamma0'], np.array(case_params['gamma'])\n            kin_term1 = wk * (beta0 + v_data @ beta_vec)\n            kin_term2 = wk * (beta0 + v_data @ beta_vec) \n            kinet_term1 = wf * (gamma0 + F1_data @ gamma_vec)\n            kinet_term2 = wf * (gamma0 + F2_data @ gamma_vec)\n            y1 = kin_term1 + kinet_term1 + eps1\n            y2 = kin_term2 + kinet_term2 + eps2\n        else:\n            raise ValueError(\"Unknown case type\")\n\n        # --- Model Comparison ---\n        \n        # 1. Kinematic Model\n        X_kin = np.c_[np.ones(n_samples), v_data]\n        \n        # Fit on condition 1, test on 2\n        w1_kin = np.linalg.lstsq(X_kin, y1, rcond=None)[0]\n        y2_pred_kin_from_1 = X_kin @ w1_kin\n        mse_1_2_kin = np.mean((y2 - y2_pred_kin_from_1)**2)\n        \n        # Fit on condition 2, test on 1\n        w2_kin = np.linalg.lstsq(X_kin, y2, rcond=None)[0]\n        y1_pred_kin_from_2 = X_kin @ w2_kin\n        mse_2_1_kin = np.mean((y1 - y1_pred_kin_from_2)**2)\n        \n        E_kinematic = 0.5 * (mse_1_2_kin + mse_2_1_kin)\n\n        # 2. Kinetic Model\n        X_kinet_1 = np.c_[np.ones(n_samples), F1_data]\n        X_kinet_2 = np.c_[np.ones(n_samples), F2_data]\n\n        # Fit on condition 1, test on 2\n        w1_kinet = np.linalg.lstsq(X_kinet_1, y1, rcond=None)[0]\n        y2_pred_kinet_from_1 = X_kinet_2 @ w1_kinet\n        mse_1_2_kinet = np.mean((y2 - y2_pred_kinet_from_1)**2)\n\n        # Fit on condition 2, test on 1\n        w2_kinet = np.linalg.lstsq(X_kinet_2, y2, rcond=None)[0]\n        y1_pred_kinet_from_2 = X_kinet_1 @ w2_kinet\n        mse_2_1_kinet = np.mean((y1 - y1_pred_kinet_from_2)**2)\n\n        E_kinetic = 0.5 * (mse_1_2_kinet + mse_2_1_kinet)\n\n        # Decision rule\n        return E_kinematic = E_kinetic\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        {\n            'type': 'kinematic',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [5.0, 0.0],\n            'beta0': 5.0, 'beta': [0.8, 0.2]\n        },\n        {\n            'type': 'kinetic',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [5.0, 0.0],\n            'gamma0': 6.0, 'gamma': [0.5, -0.3]\n        },\n        {\n            'type': 'mixed',\n            'alpha': 0.5,\n            'L1': [0.0, 0.0], 'L2': [2.0, -2.0],\n            'beta0': 4.0, 'beta': [0.6, 0.6],\n            'gamma0': 4.0, 'gamma': [0.4, 0.1],\n            'weights': (0.5, 0.5)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_case(case)\n        results.append(str(result))\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "最后，我们将M1的神经活动与其最终输出——肌肉控制——联系起来。大脑如何协调众多肌肉以产生流畅、精确的动作？这个练习探讨了M1神经元群体的集体活动如何转化为协调的肌肉激活模式。通过构建一个从神经元放电到肌电（EMG）信号的线性映射模型，并分析其“有效维度”，你将能够量化探索“肌肉协同”（muscle synergies）这一核心概念。这个实践让你能够运用奇异值分解（SVD）等强大的线性代数工具，来揭示皮层运动指令中隐藏的低维结构。",
            "id": "5049067",
            "problem": "您将获得在平面伸展任务中记录的集成神经元放电率和肌电图 (EMG) 数据。假设初级运动皮层 (M1) 通过一个线性群体编码模型来促进肌肉激活，在该模型中，EMG 活动被近似为集成放电率的线性变换。形式上，对于每次试验，设神经元放电矩阵为 $F \\in \\mathbb{R}^{n \\times T}$，其中 $n$ 是神经元数量，$T$ 是时间样本数量；设 EMG 矩阵为 $E \\in \\mathbb{R}^{m \\times T}$，其中 $m$ 是肌肉数量。线性模型假定\n$$\nE \\approx W F,\n$$\n其中 $W \\in \\mathbb{R}^{m \\times n}$ 是一个时不变映射，它捕获了集成放电如何控制肌肉激活。您的任务是使用 Moore–Penrose 伪逆通过最小二乘法估计 $W$，计算 $W$ 的数值秩，并从 $W$ 的奇异值谱中推断肌肉控制的有效维度。\n\n使用以下基本依据：\n- 群体编码假设，即平均 EMG 活动可以局部近似为 M1 中集成放电率的线性组合。\n- Moore–Penrose 伪逆 $(\\cdot)^{+}$ 的定义以及最小二乘解 $W = E F^{+}$。\n- $W$ 的奇异值分解 (SVD)，$W = U \\Sigma V^{\\top}$，其中 $\\Sigma$ 包含奇异值 $\\{\\sigma_i\\}$。\n- 数值秩定义为严格大于容差 $t = \\max(m,n) \\cdot \\sigma_{\\max} \\cdot \\epsilon$ 的奇异值 $\\sigma_i$ 的数量，其中 $\\sigma_{\\max} = \\max_i \\sigma_i$，$\\epsilon$ 是双精度算术的机器精度。\n- 有效维度定义为其归一化幅度至少为一个特定于任务的阈值 $\\tau$ 的奇异值的数量，即满足 $\\sigma_i / \\sigma_{\\max} \\ge \\tau$ 的 $i$ 的数量。\n\n给定以下矩阵和阈值，为每个测试用例计算 $W$ 的数值秩和使用所提供的 $\\tau$ 计算的有效维度。所有计算都应以纯数学术语进行；输出不需要物理单位。不使用角度，也不应使用百分比。\n\n测试套件：\n- 用例 $1$（理想情况，$F$ 为行满秩）：\n  - $F^{(1)} = \\begin{bmatrix}\n  1  2  3  4  5  6 \\\\\n  0  1  0  1  0  1 \\\\\n  2  0  1  2  3  4 \\\\\n  1  1  1  1  1  1\n  \\end{bmatrix}$，\n  - $E^{(1)} = \\begin{bmatrix}\n  1  2  3  4  5  6 \\\\\n  2  1  1  3  3  5 \\\\\n  3  1  2  3  4  5\n  \\end{bmatrix}$，\n  - $\\tau^{(1)} = 10^{-10}$。\n- 用例 $2$（$W$ 中存在秩 $\\leq 2$ 的低维协同）：\n  - $F^{(2)} = \\begin{bmatrix}\n  1  2  3  4  5  6 \\\\\n  0  1  0  1  0  1 \\\\\n  2  0  1  2  3  4 \\\\\n  1  1  1  1  1  1\n  \\end{bmatrix}$，\n  - $E^{(2)} = \\begin{bmatrix}\n  5  4  6  8  10  12 \\\\\n  3  2  2  4  4  6 \\\\\n  8  6  8  12  14  18\n  \\end{bmatrix}$，\n  - $\\tau^{(2)} = 0.3$。\n- 用例 $3$（边界情况，秩为 1 的映射）：\n  - $F^{(3)} = \\begin{bmatrix}\n  1  2  3  4  5  6 \\\\\n  0  1  0  1  0  1 \\\\\n  2  0  1  2  3  4 \\\\\n  1  1  1  1  1  1\n  \\end{bmatrix}$，\n  - $E^{(3)} = \\begin{bmatrix}\n  11  8  10  16  18  24 \\\\\n  5.5  4  5  8  9  12 \\\\\n  22  16  20  32  36  48\n  \\end{bmatrix}$，\n  - $\\tau^{(3)} = 0.5$。\n- 用例 $4$（边缘情况，$F$ 为病态矩阵且行相关）：\n  - $F^{(4)} = \\begin{bmatrix}\n  1  0  1  0  1  0 \\\\\n  2  0  2  0  2  0 \\\\\n  0  1  0  1  0  1 \\\\\n  1  1  1  1  1  1\n  \\end{bmatrix}$，\n  - $E^{(4)} = \\begin{bmatrix}\n  1  0  1  0  1  0 \\\\\n  2  1  2  1  2  1 \\\\\n  1  2  1  2  1  2\n  \\end{bmatrix}$，\n  - $\\tau^{(4)} = 10^{-10}$。\n\n您的程序应针对每个用例 $k \\in \\{1,2,3,4\\}$：\n1. 使用 Moore–Penrose 伪逆计算 $W^{(k)} = E^{(k)} \\left(F^{(k)}\\right)^{+}$。\n2. 使用 SVD 和容差 $t^{(k)} = \\max(m,n) \\cdot \\sigma_{\\max}^{(k)} \\cdot \\epsilon$ 计算 $W^{(k)}$ 的数值秩，其中 $\\epsilon$ 等于双精度机器精度。\n3. 计算有效维度 $D_{\\mathrm{eff}}^{(k)}$，即满足 $\\sigma_i^{(k)} / \\sigma_{\\max}^{(k)} \\ge \\tau^{(k)}$ 的奇异值的数量。\n\n最终输出格式：\n- 生成单行输出，包含一个逗号分隔的数对列表，每个数对的格式为 $[r_k,d_k]$，其中 $r_k$ 是用例 $k$ 的数值秩，$d_k$ 是其有效维度。整个列表必须用方括号括起来，且不含任何空格。例如：$\\left[[r_1,d_1],[r_2,d_2],[r_3,d_3],[r_4,d_4]\\right]$。",
            "solution": "我们从初级运动皮层 (M1) 的一个群体编码模型开始，在该模型中，集成神经元放电率促进肌肉激活。在短时间尺度和固定姿势下的一阶近似中，EMG 可以建模为集成放电的线性变换，从而得到关系式 $E \\approx W F$，其中 $E \\in \\mathbb{R}^{m \\times T}$，$F \\in \\mathbb{R}^{n \\times T}$，而 $W \\in \\mathbb{R}^{m \\times n}$ 是一个时不变映射，它捕获了从 M1 到肌肉的输出的组织结构。\n\n为了从观测值 $(E,F)$ 中估计 $W$，我们使用从 Moore–Penrose 伪逆推导出的最小二乘解。给定残差最小化问题\n$$\n\\min_{W} \\|E - W F\\|_F^2,\n$$\n解为\n$$\nW^{\\star} = E F^{+},\n$$\n其中 $F^{+}$ 是 $F$ 的 Moore–Penrose 伪逆。这可由矩阵最小二乘法中的正规方程和伪逆的定义得出，即使在 $F$ 秩亏的情况下，伪逆也能产生最小范数解。\n\n为了从控制维度的角度量化该映射的组织结构和功能，我们计算 $W$ 的奇异值分解 (SVD)：\n$$\nW = U \\Sigma V^{\\top},\n$$\n其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个包含奇异值 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$ 的矩形对角矩阵。\n\n数值秩 $r$ 定义为严格大于容差 $t$ 的奇异值的数量，其中\n$$\nt = \\max(m,n) \\cdot \\sigma_{\\max} \\cdot \\epsilon,\n$$\n其中 $\\sigma_{\\max} = \\max_i \\sigma_i$，$\\epsilon$ 是双精度浮点运算的机器精度。这个容差的设定是出于对 SVD 的后向稳定性和奇异值相对缩放的考虑。\n\n有效维度 $D_{\\mathrm{eff}}$ 定义为归一化幅度超过特定于任务的阈值 $\\tau$ 的奇异值的数量，即\n$$\nD_{\\mathrm{eff}} = \\left|\\left\\{ i \\,:\\, \\frac{\\sigma_i}{\\sigma_{\\max}} \\ge \\tau \\right\\}\\right|.\n$$\n这种阈值化处理捕获了神经元集成有效控制肌肉激活的强模式数量，这与运动控制中的肌肉协同和降维概念相一致。\n\n每个测试用例 $k$ 的算法步骤：\n1. 取 $F^{(k)} \\in \\mathbb{R}^{n \\times T}$ 和 $E^{(k)} \\in \\mathbb{R}^{m \\times T}$。\n2. 通过数值稳定的伪逆（例如，基于 SVD 的方法）计算 $F^{(k)+}$。\n3. 构建 $W^{(k)} = E^{(k)} F^{(k)+}$。\n4. 通过 SVD 计算 $W^{(k)}$ 的奇异值 $\\{\\sigma_i^{(k)}\\}$。\n5. 计算 $t^{(k)} = \\max(m,n) \\cdot \\sigma_{\\max}^{(k)} \\cdot \\epsilon$，并设置\n$$\nr_k = \\sum_{i} \\mathbf{1}\\left[\\sigma_i^{(k)}  t^{(k)}\\right].\n$$\n6. 计算\n$$\nd_k = \\sum_{i} \\mathbf{1}\\left[\\frac{\\sigma_i^{(k)}}{\\sigma_{\\max}^{(k)}} \\ge \\tau^{(k)}\\right].\n$$\n\n解释：\n- 较高的 $r_k$ 表示由 $W^{(k)}$ 编码的独立控制通道更多，但这受限于数值精度。\n- 较高的 $d_k$ 表示存在更多高于任务相关分辨率阈值的有效控制模式，这与强协同有关。\n\n将此方法应用于所提供的用例：\n- 用例 1：$F^{(1)}$ 是行满秩的，$E^{(1)}$ 由一个具有三个独立行的映射生成，得到 $r_1 = 3$。由于 $\\tau^{(1)} = 10^{-10}$，所有非零奇异值都被计数，因此 $d_1 = 3$。\n- 用例 2：$E^{(2)}$ 体现了一个秩最多为 2 的映射；SVD 给出两个主奇异值。由于 $\\tau^{(2)} = 0.3$，这两个强奇异值超过了阈值，因此 $r_2 = 2$ 且 $d_2 = 2$。\n- 用例 3：该映射的秩为 1。由于 $\\tau^{(3)} = 0.5$，单个非零奇异值超过了阈值，得到 $r_3 = 1$ 且 $d_3 = 1$。\n- 用例 4：$F^{(4)}$ 因行相关而秩亏，因此最小二乘估计 $W^{(4)}$ 塌陷到秩为 2 的可识别子空间。由于 $\\tau^{(4)} = 10^{-10}$，有效维度等于数值秩，即 $d_4 = 2$。\n\n最终输出必须是包含数对列表 $\\left[[r_1,d_1],[r_2,d_2],[r_3,d_3],[r_4,d_4]\\right]$ 的单行，且不含空格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_w(E, F):\n    # Moore-Penrose pseudoinverse-based least squares estimate of W\n    F_pinv = np.linalg.pinv(F)\n    W = E @ F_pinv\n    return W\n\ndef numerical_rank_and_effective_dim(W, tau):\n    # Singular values\n    s = np.linalg.svd(W, compute_uv=False)\n    smax = np.max(s) if s.size  0 else 0.0\n    # Machine epsilon for double precision\n    eps = np.finfo(float).eps\n    # Numerical rank tolerance\n    tol = max(W.shape) * smax * eps\n    rank = int(np.sum(s  tol))\n    # Effective dimensionality: count singular values with normalized magnitude = tau\n    if smax == 0.0:\n        eff_dim = 0\n    else:\n        eff_dim = int(np.sum((s / smax) = tau))\n    return rank, eff_dim\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (E, F, tau)\n    F1 = np.array([\n        [1, 2, 3, 4, 5, 6],\n        [0, 1, 0, 1, 0, 1],\n        [2, 0, 1, 2, 3, 4],\n        [1, 1, 1, 1, 1, 1]\n    ], dtype=float)\n    E1 = np.array([\n        [1, 2, 3, 4, 5, 6],\n        [2, 1, 1, 3, 3, 5],\n        [3, 1, 2, 3, 4, 5]\n    ], dtype=float)\n    tau1 = 1e-10\n\n    F2 = F1.copy()\n    E2 = np.array([\n        [5, 4, 6, 8, 10, 12],\n        [3, 2, 2, 4, 4, 6],\n        [8, 6, 8, 12, 14, 18]\n    ], dtype=float)\n    tau2 = 0.3\n\n    F3 = F1.copy()\n    E3 = np.array([\n        [11, 8, 10, 16, 18, 24],\n        [5.5, 4, 5, 8, 9, 12],\n        [22, 16, 20, 32, 36, 48]\n    ], dtype=float)\n    tau3 = 0.5\n\n    F4 = np.array([\n        [1, 0, 1, 0, 1, 0],\n        [2, 0, 2, 0, 2, 0],\n        [0, 1, 0, 1, 0, 1],\n        [1, 1, 1, 1, 1, 1]\n    ], dtype=float)\n    E4 = np.array([\n        [1, 0, 1, 0, 1, 0],\n        [2, 1, 2, 1, 2, 1],\n        [1, 2, 1, 2, 1, 2]\n    ], dtype=float)\n    tau4 = 1e-10\n\n    test_cases = [\n        (E1, F1, tau1),\n        (E2, F2, tau2),\n        (E3, F3, tau3),\n        (E4, F4, tau4),\n    ]\n\n    results = []\n    for E, F, tau in test_cases:\n        W = compute_w(E, F)\n        r, d = numerical_rank_and_effective_dim(W, tau)\n        results.append((r, d))\n\n    # Format output exactly as required: [[r1,d1],[r2,d2],[r3,d3],[r4,d4]]\n    output = \"[\" + \",\".join(f\"[{r},{d}]\" for (r, d) in results) + \"]\"\n    print(output)\n\nsolve()\n```"
        }
    ]
}