{
    "hands_on_practices": [
        {
            "introduction": "在神经发育过程中，突触的形成是一个基本过程。通过对兴奋性（vGluT1）和抑制性（vGAT）突触标记物的定量，我们可以追踪突触密度的增长，这一增长过程通常呈现出饱和的特性。本练习将指导你使用经典的逻辑斯谛增长模型来拟合这些发育数据，从而量化并比较不同类型突触的成熟速率。",
            "id": "5068900",
            "problem": "考虑通过对囊泡谷氨酸转运体$1$ (vGluT$1$)和囊泡γ-氨基丁酸转运体 (vGAT) 进行免疫染色所测量的突触斑点的发育累积。对于此类饱和增长过程，一个广泛使用且经过充分检验的模型是逻辑斯谛模型，其基础假设是瞬时变化率与当前量和剩余容量均成正比。其基础描述是逻辑斯谛微分方程\n$$\n\\frac{dy}{dt} = k\\,y\\left(1-\\frac{y}{A}\\right),\n$$\n其中 $y(t)$ 是相对于成年参考值归一化的突触斑点密度（无量纲），$t$ 是以天为单位的发育年龄，$A$ 是渐近上限水平（无量纲），$k$ 是成熟速率常数，单位为 $\\text{day}^{-1}$。时间 $t_{50}$ 定义为 $y(t)$ 达到其渐近水平一半时的时间，即 $y(t_{50}) = A/2$ （$t_{50}$ 的单位为天）。\n\n您的任务是编写一个程序，为下面的每个数据集，将逻辑斯谛模型的解拟合到 vGluT$1$ 和 vGAT 的测量数据上，估计参数 $A$、$k$ 和 $t_{50}$，然后使用 $k$ 值比较 vGluT$1$ 和 vGAT 之间的成熟速率。您必须使用非线性最小二乘法从所提供的数据中估计参数。时间单位为天，突触斑点密度无量纲（已经归一化）。报告成熟速率 $k$（单位为 $\\text{day}^{-1}$）和 $t_{50}$（单位为天）。将所有报告的 $k$ 值四舍五入到小数点后 $3$ 位，所有报告的 $t_{50}$ 值四舍五入到小数点后 $1$ 位。对于每个数据集，输出元组 $\\big[k_{\\mathrm{vGluT1}},k_{\\mathrm{vGAT}},t_{50,\\mathrm{vGluT1}},t_{50,\\mathrm{vGAT}},\\mathrm{is\\_vGluT1\\_faster}\\big]$，其中如果 $k_{\\mathrm{vGluT1}} > k_{\\mathrm{vGAT}}$，则 $\\mathrm{is\\_vGluT1\\_faster}$ 为 $1$，否则为 $0$。\n\n使用以下数据集（测试套件）。在每个数据集中，发育年龄（以天为单位）为 $t=[\\,2,5,8,12,16,20,30\\,]$，测得的归一化突触斑点密度以与 $t$ 对齐的列表形式给出，分别用于 vGluT$1$ 和 vGAT：\n\n- 数据集 $1$：\n  - vGluT$1$: $[\\,0.047,0.109,0.232,0.500,0.769,0.917,0.996\\,]$\n  - vGAT: $[\\,0.079,0.135,0.220,0.381,0.569,0.730,0.912\\,]$\n\n- 数据集 $2$：\n  - vGluT$1$: $[\\,0.082,0.147,0.250,0.445,0.660,0.823,0.977\\,]$\n  - vGAT: $[\\,0.074,0.137,0.240,0.443,0.666,0.833,0.980\\,]$\n\n- 数据集 $3$：\n  - vGluT$1$: $[\\,0.047,0.095,0.182,0.378,0.623,0.818,0.982\\,]$\n  - vGAT: $[\\,0.056,0.145,0.325,0.655,0.873,0.952,0.979\\,]$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。将三个数据集的结果按顺序连接成一个长度为 $15$ 的扁平列表：\n$$\n[\\,k_{\\mathrm{vGluT1},1},k_{\\mathrm{vGAT},1},t_{50,\\mathrm{vGluT1},1},t_{50,\\mathrm{vGAT},1},\\mathrm{is\\_vGluT1\\_faster}_1,\\;k_{\\mathrm{vGluT1},2},k_{\\mathrm{vGAT},2},t_{50,\\mathrm{vGluT1},2},t_{50,\\mathrm{vGAT},2},\\mathrm{is\\_vGluT1\\_faster}_2,\\;k_{\\mathrm{vGluT1},3},k_{\\mathrm{vGAT},3},t_{50,\\mathrm{vGluT1},3},t_{50,\\mathrm{vGAT},3},\\mathrm{is\\_vGluT1\\_faster}_3\\,].\n$$\n所有 $k$ 条目的单位必须是 $\\text{day}^{-1}$ 并四舍五入到 $3$ 位小数，所有 $t_{50}$ 条目的单位必须是天并四舍五入到 $1$ 位小数，每个 $\\mathrm{is\\_vGluT1\\_faster}$ 条目必须是整数 $0$ 或 $1$。",
            "solution": "所述问题是有效的。它在发育神经生物学领域有科学依据，在数学上定义明确，并为一项计算任务提供了一套完整且一致的数据和指令。使用逻辑斯谛模型描述突触增殖是一种标准方法，而通过非线性最小二乘法进行参数估计的指定任务是一种常规且合适的方法。\n\n解决方案分为三个主要步骤：首先，推导适用于曲线拟合的逻辑斯谛增长函数的解析形式；其次，使用非线性最小二乘法实现数值参数估计程序；第三，将此程序应用于所提供的数据集，以提取和比较相关的生物学参数。\n\n### 1. 逻辑斯谛增长模型\n\n该问题基于逻辑斯谛微分方程，这是一个描述资源受限条件下增长过程的基础模型：\n$$\n\\frac{dy}{dt} = k\\,y\\left(1-\\frac{y}{A}\\right)\n$$\n在此， $y(t)$ 表示在发育时间 $t$ 的归一化突触斑点密度。参数 $A$ 是渐近最大密度，或称承载能力，而 $k$ 是内在增长或成熟速率，单位为 $\\text{day}^{-1}$。项 $(1-y/A)$ 表示饱和的抑制效应；当 $y$ 接近 $A$ 时，增长率 $\\frac{dy}{dt}$ 接近 $0$。\n\n这是一个可分离的常微分方程。为了求解 $y(t)$，我们重新整理并积分：\n$$\n\\int \\frac{dy}{y(1-y/A)} = \\int k\\,dt\n$$\n对左侧使用部分分式分解，我们得到 $\\frac{1}{y(1-y/A)} = \\frac{1/A}{y/A} + \\frac{1/A}{1-y/A} = \\frac{1}{y} + \\frac{1}{A-y}$。积分变为：\n$$\n\\int \\left(\\frac{1}{y} + \\frac{1}{A-y}\\right) dy = \\int k\\,dt\n$$\n$$\n\\ln|y| - \\ln|A-y| = kt + C_1\n$$\n$$\n\\ln\\left(\\frac{y}{A-y}\\right) = kt + C_1\n$$\n对两边取指数并求解 $y(t)$，得到通解：\n$$\ny(t) = \\frac{A}{1 + e^{-(kt + C_1)}} = \\frac{A}{1 + C_0e^{-kt}}\n$$\n其中 $C_0 = e^{-C_1}$ 是一个积分常数。\n\n为了进行更直观的参数化，我们引入 $t_{50}$，即密度达到其渐近水平一半的时间，即 $y(t_{50}) = A/2$。将此条件代入通解：\n$$\n\\frac{A}{2} = \\frac{A}{1 + C_0e^{-kt_{50}}} \\implies 1 + C_0e^{-kt_{50}} = 2 \\implies C_0 = e^{kt_{50}}\n$$\n将 $C_0$ 的这个表达式代回 $y(t)$ 的解中，得到用于拟合的模型的最终形式：\n$$\ny(t) = \\frac{A}{1 + e^{kt_{50}}e^{-kt}} = \\frac{A}{1 + e^{k(t_{50}-t)}}\n$$\n这种参数化方法更适合拟合，因为参数 $A$、$k$ 和 $t_{50}$ 具有直接的物理解释：分别是渐近密度、成熟速率常数和达到半成熟的时间。\n\n### 2. 通过非线性最小二乘法进行参数估计\n\n任务是找到能最好地拟合 vGluT$1$ 和 vGAT 的给定实验数据 $(t_i, y_i)$ 的参数 $(A, k, t_{50})$。这通过使用非线性最小二乘 (NLS) 回归来实现。NLS 算法迭代地调整参数以最小化残差平方和 $S$，其中残差是观测数据点与模型预测值之间的差：\n$$\nS(A, k, t_{50}) = \\sum_{i=1}^{N} \\left[ y_i - y(t_i; A, k, t_{50}) \\right]^2\n$$\n这个优化问题通过计算方式求解，其中使用了 `scipy.optimize.curve_fit` 函数。该函数实现了 Levenberg-Marquardt 算法，这是一种用于解决 NLS 问题的稳健方法。\n\n算法的成功收敛需要为参数提供合理的初始猜测值，记为 $p_0 = [A_0, k_0, t_{50,0}]$。我们可以为这些初始猜测值制定简单的、由数据驱动的启发式方法：\n-   渐近线 $A_0$ 的初始猜测值取为数据集中的最大观测密度。\n-   达到最大值一半所需时间 $t_{50,0}$ 的初始猜测值是与数值上最接近 $A_0/2$ 的观测密度 $y_i$ 对应的时间点 $t_i$。\n-   速率常数 $k_0$ 的初始猜测值被设定为一个合理的默认值，例如 $0.2 \\, \\text{day}^{-1}$，因为在 $A$ 和 $t_{50}$ 有良好猜测值的情况下，拟合过程通常对这个初始值不太敏感。\n\n### 3. 算法实现与分析\n\n对 3 个数据集中的每一个都执行分析。对每个数据集，执行以下步骤：\n1.  对于 vGluT$1$ 数据，确定初始参数 $[A_0, k_0, t_{50,0}]$。然后使用模型 $y(t)$、时间数据 $t$、vGluT$1$ 密度数据和初始猜测值调用 `curve_fit` 函数，以找到最优参数 $(A_{\\mathrm{vGluT1}}, k_{\\mathrm{vGluT1}}, t_{50,\\mathrm{vGluT1}})$。\n2.  对 vGAT 数据重复相同的过程，以找到其最优参数 $(A_{\\mathrm{vGAT}}, k_{\\mathrm{vGAT}}, t_{50,\\mathrm{vGAT}})$。\n3.  使用其全精度浮点值比较估计的成熟速率 $k_{\\mathrm{vGluT1}}$ 和 $k_{\\mathrm{vGAT}}$。如果 $k_{\\mathrm{vGluT1}} > k_{\\mathrm{vGAT}}$，则标志 $\\mathrm{is\\_vGluT1\\_faster}$ 设置为 $1$，否则设置为 $0$。此比较必须在进行任何四舍五入之前执行，以避免潜在的不准确性。\n4.  用于报告的最终值按要求进行格式化：$k$ 值四舍五入到小数点后 $3$ 位，$t_{50}$ 值四舍五入到小数点后 $1$ 位。\n5.  收集五个结果值——$k_{\\mathrm{vGluT1}}$、$k_{\\mathrm{vGAT}}$、$t_{50,\\mathrm{vGluT1}}$、$t_{50,\\mathrm{vGAT}}$ 和 $\\mathrm{is\\_vGluT1\\_faster}$。\n\n最后，将所有三个数据集的结果列表连接起来，形成一个包含 $15$ 个元素的扁平列表，然后将其格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits logistic growth models to synaptogenesis data for vGluT1 and vGAT,\n    estimates maturation parameters, and compares rates.\n    \"\"\"\n\n    # Define the logistic model function for curve fitting.\n    # y(t) = A / (1 + exp(k * (t50 - t)))\n    # A: asymptotic level\n    # k: maturation rate constant\n    # t50: time to reach A/2\n    def logistic_model(t, A, k, t50):\n        return A / (1.0 + np.exp(k * (t50 - t)))\n\n    # Define the developmental time points (in days).\n    t_data = np.array([2, 5, 8, 12, 16, 20, 30])\n    \n    # Define the datasets for vGluT1 and vGAT puncta densities.\n    test_cases = [\n        {\n            \"vGluT1\": np.array([0.047, 0.109, 0.232, 0.500, 0.769, 0.917, 0.996]),\n            \"vGAT\": np.array([0.079, 0.135, 0.220, 0.381, 0.569, 0.730, 0.912])\n        },\n        {\n            \"vGluT1\": np.array([0.082, 0.147, 0.250, 0.445, 0.660, 0.823, 0.977]),\n            \"vGAT\": np.array([0.074, 0.137, 0.240, 0.443, 0.666, 0.833, 0.980])\n        },\n        {\n            \"vGluT1\": np.array([0.047, 0.095, 0.182, 0.378, 0.623, 0.818, 0.982]),\n            \"vGAT\": np.array([0.056, 0.145, 0.325, 0.655, 0.873, 0.952, 0.979])\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        y_vglut1 = case[\"vGluT1\"]\n        y_vgat = case[\"vGAT\"]\n\n        # --- Fit vGluT1 data ---\n        # Heuristic initial guesses for A, k, t50\n        p0_vglut1 = [y_vglut1.max(), 0.2, t_data[np.argmin(np.abs(y_vglut1 - y_vglut1.max() / 2.0))]]\n        # Perform non-linear least squares fitting\n        params_vglut1, _ = curve_fit(logistic_model, t_data, y_vglut1, p0=p0_vglut1, maxfev=5000)\n        _, k_vglut1, t50_vglut1 = params_vglut1\n\n        # --- Fit vGAT data ---\n        # Heuristic initial guesses for A, k, t50\n        p0_vgat = [y_vgat.max(), 0.2, t_data[np.argmin(np.abs(y_vgat - y_vgat.max() / 2.0))]]\n        # Perform non-linear least squares fitting\n        params_vgat, _ = curve_fit(logistic_model, t_data, y_vgat, p0=p0_vgat, maxfev=5000)\n        _, k_vgat, t50_vgat = params_vgat\n\n        # Compare maturation rates using full precision values\n        is_vglut1_faster = 1 if k_vglut1 > k_vgat else 0\n\n        # Format results as per problem specification\n        k_vglut1_str = f\"{k_vglut1:.3f}\"\n        k_vgat_str = f\"{k_vgat:.3f}\"\n        t50_vglut1_str = f\"{t50_vglut1:.1f}\"\n        t50_vgat_str = f\"{t50_vgat:.1f}\"\n\n        # Append formatted results for the current dataset\n        all_results.extend([\n            k_vglut1_str,\n            k_vgat_str,\n            t50_vglut1_str,\n            t50_vgat_str,\n            str(is_vglut1_faster)\n        ])\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "突触形成后，会经历一个关键的成熟阶段，其功能特性会发生显著改变。在谷氨酸能突触中，一个核心的成熟标志是AMPA受体数量的增加，这通常通过AMPA/NMDA受体比率来衡量。本练习将通过建立和求解一个基于受体插入和移除速率的微分方程模型，来从数学上探索这一重要比率如何随时间动态演变。",
            "id": "5068955",
            "problem": "在中枢神经系统突触形成过程中，随着活性驱动的插入超过组成性移除，每个突觸的α-氨基-3-羟基-5-甲基-4-异恶唑丙酸受体 (AMPAR) 含量会增加，而N-甲基-D-天冬氨酸受体 (NMDAR) 的含量通常随着亚基组成的成熟，在较慢的时间尺度上趋于稳定。考虑一个单一的谷氨酸能突觸，其中每个突觸的AMPAR数量（表示为 $A(t)$）和NMDAR数量（表示为 $N(t)$）根据受体流平衡演化：其时间变化率等于插入率减去移除率。设移除率为常数，且AMPAR的插入由一种从早期高活性状态衰减的发育性活动模式驱动。\n\n假设以下具有科学依据的模型：\n- AMPAR动力学：$\\frac{dA}{dt} = k_{A}(t) - k_{R} A(t)$，其中 $k_{R} > 0$ 为常数。\n- NMDAR动力学：$\\frac{dN}{dt} = k_{N} - \\delta N(t)$，其中 $k_{N} > 0$ 和 $\\delta > 0$ 为常数。\n- 活性依赖的AMPAR插入：$k_{A}(t) = \\alpha a(t)$，其中 $\\alpha > 0$ 为常数敏感度，且对于 $t \\ge 0$，$a(t) = a_{0} + a_{1} \\exp(-\\lambda t)$，其中 $a_{0} > 0$，$a_{1} \\ge 0$，$ \\lambda > 0$。\n- 初始条件：$A(0) = A_{0} \\ge 0$ 且 $N(0) = N_{0} \\ge 0$。\n- 定义 $k_{A,0} \\equiv \\alpha a_{0}$ 和 $k_{A,1} \\equiv \\alpha a_{1}$，并假设 $k_{R} \\neq \\lambda$。\n\n从上述受体流平衡原理和模型出发，对于一般的 $t \\ge 0$，推导 AMPAR/NMDAR 比率 $R(t) = \\frac{A(t)}{N(t)}$ 的闭式解析表达式，该表达式应以参数 $A_{0}$、$N_{0}$、$k_{A,0}$、$k_{A,1}$、$k_{R}$、$k_{N}$、$\\delta$ 和 $\\lambda$ 表示。将最终比率表示为一个无量纲的解析表达式。无需进行数值计算或四舍五入。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它基于神经生物学的既定原理，使用标准的数学形式，提出了一个可解的受体动力学模型。所有必要的数据和条件均已提供。\n\n目标是求出 AMPAR/NMDAR 比率 $R(t) = \\frac{A(t)}{N(t)}$。这需要分别求解 $A(t)$ 和 $N(t)$ 的微分方程。\n\n首先，我们求解NMDAR的数量 $N(t)$。其控制方程是一个一阶线性常微分方程 (ODE)：\n$$ \\frac{dN}{dt} = k_{N} - \\delta N(t) $$\n这可以重排为标准形式 $\\frac{dN}{dt} + \\delta N(t) = k_{N}$。积分因子为 $I(t) = \\exp\\left(\\int \\delta \\, dt\\right) = \\exp(\\delta t)$。用 $I(t)$ 乘以该常微分方程得到：\n$$ \\exp(\\delta t) \\frac{dN}{dt} + \\delta \\exp(\\delta t) N(t) = k_{N} \\exp(\\delta t) $$\n方程左边是乘积 $N(t) \\exp(\\delta t)$ 的导数：\n$$ \\frac{d}{dt} \\left[ N(t) \\exp(\\delta t) \\right] = k_{N} \\exp(\\delta t) $$\n两边对 $t$ 积分：\n$$ N(t) \\exp(\\delta t) = \\int k_{N} \\exp(\\delta t) \\, dt = \\frac{k_{N}}{\\delta} \\exp(\\delta t) + C_{N} $$\n其中 $C_{N}$ 是积分常数。两边乘以 $\\exp(-\\delta t)$ 解出 $N(t)$：\n$$ N(t) = \\frac{k_{N}}{\\delta} + C_{N} \\exp(-\\delta t) $$\n我们使用初始条件 $N(0) = N_{0}$ 来求 $C_{N}$：\n$$ N(0) = N_{0} = \\frac{k_{N}}{\\delta} + C_{N} \\exp(0) \\implies C_{N} = N_{0} - \\frac{k_{N}}{\\delta} $$\n将 $C_{N}$ 代回 $N(t)$ 的表达式中，得到NMDAR数量的完整解：\n$$ N(t) = \\frac{k_{N}}{\\delta} + \\left(N_{0} - \\frac{k_{N}}{\\delta}\\right) \\exp(-\\delta t) $$\n\n接下来，我们求解AMPAR的数量 $A(t)$。其控制常微分方程为：\n$$ \\frac{dA}{dt} = k_{A}(t) - k_{R} A(t) $$\n代入给定的表达式 $k_{A}(t) = k_{A,0} + k_{A,1} \\exp(-\\lambda t)$：\n$$ \\frac{dA}{dt} + k_{R} A(t) = k_{A,0} + k_{A,1} \\exp(-\\lambda t) $$\n这也是一个一阶线性常微分方程。积分因子为 $I(t) = \\exp\\left(\\int k_{R} \\, dt\\right) = \\exp(k_{R} t)$。用 $I(t)$ 乘以该常微分方程：\n$$ \\frac{d}{dt} \\left[ A(t) \\exp(k_{R} t) \\right] = \\left( k_{A,0} + k_{A,1} \\exp(-\\lambda t) \\right) \\exp(k_{R} t) = k_{A,0} \\exp(k_{R} t) + k_{A,1} \\exp((k_{R} - \\lambda) t) $$\n两边对 $t$ 积分：\n$$ A(t) \\exp(k_{R} t) = \\int \\left( k_{A,0} \\exp(k_{R} t) + k_{A,1} \\exp((k_{R} - \\lambda) t) \\right) \\, dt $$\n由于给定条件 $k_{R} \\neq \\lambda$，积分得到：\n$$ A(t) \\exp(k_{R} t) = \\frac{k_{A,0}}{k_{R}} \\exp(k_{R} t) + \\frac{k_{A,1}}{k_{R} - \\lambda} \\exp((k_{R} - \\lambda) t) + C_{A} $$\n其中 $C_{A}$ 是积分常数。解出 $A(t)$：\n$$ A(t) = \\frac{k_{A,0}}{k_{R}} + \\frac{k_{A,1}}{k_{R} - \\lambda} \\exp(-\\lambda t) + C_{A} \\exp(-k_{R} t) $$\n我们使用初始条件 $A(0) = A_{0}$ 来求 $C_{A}$：\n$$ A(0) = A_{0} = \\frac{k_{A,0}}{k_{R}} + \\frac{k_{A,1}}{k_{R} - \\lambda} + C_{A} \\implies C_{A} = A_{0} - \\frac{k_{A,0}}{k_{R}} - \\frac{k_{A,1}}{k_{R} - \\lambda} $$\n将 $C_{A}$ 代回，得到AMPAR数量的完整解：\n$$ A(t) = \\frac{k_{A,0}}{k_{R}} + \\frac{k_{A,1}}{k_{R} - \\lambda} \\exp(-\\lambda t) + \\left(A_{0} - \\frac{k_{A,0}}{k_{R}} - \\frac{k_{A,1}}{k_{R} - \\lambda}\\right) \\exp(-k_{R} t) $$\n\n最后，AMPAR/NMDAR比率 $R(t)$ 是 $A(t)$ 与 $N(t)$ 的比值：\n$$ R(t) = \\frac{A(t)}{N(t)} = \\frac{\\frac{k_{A,0}}{k_{R}} + \\frac{k_{A,1}}{k_{R} - \\lambda} \\exp(-\\lambda t) + \\left(A_{0} - \\frac{k_{A,0}}{k_{R}} - \\frac{k_{A,1}}{k_{R} - \\lambda}\\right) \\exp(-k_{R} t)}{\\frac{k_{N}}{\\delta} + \\left(N_{0} - \\frac{k_{N}}{\\delta}\\right) \\exp(-\\delta t)} $$\n这就是比率 $R(t)$ 的闭式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{\\frac{k_{A,0}}{k_{R}} + \\frac{k_{A,1}}{k_{R} - \\lambda} \\exp(-\\lambda t) + \\left(A_{0} - \\frac{k_{A,0}}{k_{R}} - \\frac{k_{A,1}}{k_{R} - \\lambda}\\right) \\exp(-k_{R} t)}{\\frac{k_{N}}{\\delta} + \\left(N_{0} - \\frac{k_{N}}{\\delta}\\right) \\exp(-\\delta t)}}\n$$"
        },
        {
            "introduction": "神经科学家如何从实验上量化突触网络的变化？一种强大的技术是记录微型兴奋性突触后电流（mEPSCs），它反映了单个突触囊泡的自发释放事件。本练习将引导你建立一个计算框架，通过分析mEPSC的统计特征（如频率和幅度），来推断观察到的可塑性是由突触数量、突触前释放概率还是突触后量子大小的改变所驱动的。",
            "id": "5068948",
            "problem": "给定您在两种条件下微型兴奋性突触后电流 (mEPSC) 记录的摘要统计数据：基线条件和丰富的感觉经验条件。在神经生物学的高年级本科课程中，一个公认的结论是 mEPSC 源于单个突触处单个囊泡的释放事件。对于 mEPSC，平均振幅反映了突触后的量子大小，而事件频率则反映了在所有功能性突触群体上积分得到的突触前自发释放速率。\n\n基本原理和定义：\n- 一个微型兴奋性突触后电流 (mEPSC) 事件是由单个突触处单个突触囊泡的释放产生的，它会产生一个突触后电流，其平均振幅与量子大小 $q$ 成正比。\n- 令 $N$ 表示与被记录神经元接触的功能性突触数量，令 $p_s$ 表示在测量时间窗口内每个突触的突触前自发释放概率。在独立性和平稳性条件下，mEPSC 事件频率 $f$ 与乘积 $N \\cdot p_s$ 成比例缩放。\n- 令 $A$ 表示 mEPSC 平均振幅，$S$ 表示 mEPSC 振幅的标准差，$B$ 表示根据事件间间隔统计数据计算的无量纲爆发性指数。在类泊松机制中，增加突触前释放概率 $p_s$ 的变化通常会增加短间隔事件，从而增加爆发性，而突触数量 $N$ 的变化会增加总频率，但当单个突触保持近似类泊松特性时，不一定会改变爆发性。\n\n分解的工作假设：\n- 由于每个 mEPSC 是一个单独的量子，量子大小 $q$ 的纯粹变化将使 $A$ 和 $S$ 按相同因子缩放，而 $f$ 和 $B$ 大致保持不变。\n- 突触数量 $N$ 的纯粹变化将使 $f$ 缩放，而 $A$、$S$ 和 $B$ 大致保持不变。\n- 突触前自发释放概率 $p_s$ 的纯粹变化将使 $f$ 缩放并增加 $B$（事件更聚集），而 $A$ 和 $S$ 大致保持不变。\n- 组合变化将表现出相应的组合模式。\n\n定义丰富 ($2$) 条件与基线 ($1$) 条件之间的以下比例因子：\n- 振幅比例因子：$\\alpha_A = A_2 / A_1$，\n- 振幅标准差比例因子：$\\alpha_S = S_2 / S_1$，\n- 频率比例因子：$\\alpha_f = f_2 / f_1$，\n- 爆发性比例因子：$\\alpha_B = B_2 / B_1$。\n\n决策阈值：\n- 令振幅和标准差容差为 $\\varepsilon_A = 0.10$（无量纲，相对值）。\n- 令频率容差为 $\\varepsilon_f = 0.10$（无量纲，相对值）。\n- 令爆发性容差为 $\\varepsilon_B = 0.20$（无量纲，相对值）。\n使用严格不等式比较：仅当绝对相对偏差超过其容差时，才认为参数“已改变”。\n\n分类规则：\n- 通过要求 $|\\alpha_A - 1| > \\varepsilon_A$ 和成比例缩放 $|\\alpha_S / \\alpha_A - 1| <= \\varepsilon_A$ 来确定突触后量子大小 $q$ 的变化。\n- 通过测试 $|\\alpha_f - 1| > \\varepsilon_f$ 来确定突触前因素是否发生变化。\n- 如果突触前因素发生变化且 $|\\alpha_B - 1| > \\varepsilon_B$，则将此突触前变化分类为 $p_s$ 的改变；否则将其分类为 $N$ 的改变。\n- 当同时检测到突触后和突触前变化时，结合以上规则以获得联合变化分类。\n\n要求的输出编码：\n- 将每个测试用例的最终分类编码为一个整数代码：\n    - $0$：无变化 (no_change)，\n    - $1$：q 变化 (q_change)，\n    - $2$：N 变化 (N_change)，\n    - $3$：p 变化 (p_change)，\n    - $4$：N 和 q 变化 (N_and_q_change)，\n    - $5$：p 和 q 变化 (p_and_q_change)。\n\n您的程序必须：\n- 实现上述分解和分类。\n- 使用下面提供的测试套件。\n- 生成单行输出，其中包含所有测试用例的整数代码列表，格式为方括号括起来的逗号分隔列表（例如，“[1,2,3]”）。\n\n单位和数据：\n- 平均振幅 $A$ 和振幅标准差 $S$ 以皮安 (pA) 为单位。\n- 频率 $f$ 以赫兹 (Hz) 为单位。\n- 爆发性 $B$ 是无量纲的。\n\n测试套件（基线和丰富条件下的值）：\n- 测试用例 $1$（纯 $q$ 变化）：$(A_1,S_1,f_1,B_1) = (12.0\\ \\mathrm{pA}, 3.6\\ \\mathrm{pA}, 4.0\\ \\mathrm{Hz}, 0.20)$；$(A_2,S_2,f_2,B_2) = (15.0\\ \\mathrm{pA}, 4.5\\ \\mathrm{pA}, 4.1\\ \\mathrm{Hz}, 0.20)$。\n- 测试用例 $2$（纯 $N$ 变化）：$(A_1,S_1,f_1,B_1) = (13.0\\ \\mathrm{pA}, 3.9\\ \\mathrm{pA}, 2.0\\ \\mathrm{Hz}, 0.18)$；$(A_2,S_2,f_2,B_2) = (13.0\\ \\mathrm{pA}, 3.9\\ \\mathrm{pA}, 4.0\\ \\mathrm{Hz}, 0.18)$。\n- 测试用例 $3$（纯 $p$ 变化）：$(A_1,S_1,f_1,B_1) = (11.0\\ \\mathrm{pA}, 3.3\\ \\mathrm{pA}, 2.5\\ \\mathrm{Hz}, 0.20)$；$(A_2,S_2,f_2,B_2) = (11.0\\ \\mathrm{pA}, 3.3\\ \\mathrm{pA}, 3.75\\ \\mathrm{Hz}, 0.35)$。\n- 测试用例 $4$（$p$ 和 $q$ 的组合变化）：$(A_1,S_1,f_1,B_1) = (10.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{Hz}, 0.15)$；$(A_2,S_2,f_2,B_2) = (12.0\\ \\mathrm{pA}, 3.6\\ \\mathrm{pA}, 4.5\\ \\mathrm{Hz}, 0.30)$。\n- 测试用例 $5$（在容差范围内无有意义的变化）：$(A_1,S_1,f_1,B_1) = (12.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{Hz}, 0.20)$；$(A_2,S_2,f_2,B_2) = (12.9\\ \\mathrm{pA}, 3.15\\ \\mathrm{pA}, 3.2\\ \\mathrm{Hz}, 0.22)$。\n- 测试用例 $6$（振幅容差的边界情况，不应计为变化）：$(A_1,S_1,f_1,B_1) = (10.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{pA}, 3.0\\ \\mathrm{Hz}, 0.20)$；$(A_2,S_2,f_2,B_2) = (11.0\\ \\mathrm{pA}, 3.3\\ \\mathrm{pA}, 3.0\\ \\mathrm{Hz}, 0.20)$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。",
            "solution": "所提出的问题是一个分类任务，它基于一个简化的突触传递生物物理模型，特别关注于解释微型兴奋性突触后电流 (mEPSC) 统计数据的变化。该问题具有科学依据，建立在公认的神经生物学原理之上，定义明确，具有明确的规则和数据，并且是客观的。因此，这是一个可以推导出解决方案的有效问题。\n\n任务的核心是根据从 mEPSC 记录中观察到的四个统计指标的变化来对潜在的神经生物学变化（突触后量子大小 $q$、突触数量 $N$ 和突触前释放概率 $p_s$）进行分类：这些指标包括平均振幅 ($A$)、振幅标准差 ($S$)、事件频率 ($f$) 和爆发性指数 ($B$)。分类遵循一套确定性规则，这些规则基于将这些参数的相对变化与预定义的容差阈值进行比较。\n\n首先，我们定义每个参数的比例因子，表示“丰富”条件（下标 $2$）下的值与“基线”条件（下标 $1$）下的值的比率：\n- 振幅比例因子：$\\alpha_A = A_2 / A_1$\n- 振幅标准差比例因子：$\\alpha_S = S_2 / S_1$\n- 频率比例因子：$\\alpha_f = f_2 / f_1$\n- 爆发性比例因子：$\\alpha_B = B_2 / B_1$\n\n决策过程涉及对潜在变化的顺序评估，遵循所提供的工作假设和分类规则。我们将使用两个布尔标志来表示每个测试用例的分析状态：一个用于突触后量子大小变化的标志 `q_changed`，以及一个指示突触前变化类型的变量 `presynaptic_change_type`（其中 $0$ 表示无变化，$2$ 表示突触数量 $N$ 的变化，$3$ 表示释放概率 $p_s$ 的变化）。\n\n决策阈值如下：\n- 振幅容差：$\\varepsilon_A = 0.10$\n- 频率容差：$\\varepsilon_f = 0.10$\n- 爆发性容差：$\\varepsilon_B = 0.20$\n\n分类逻辑分两个主要步骤进行：\n\n步骤 1：评估突触后量子大小 ($q$) 的变化\n如果 mEPSC 平均振幅 $A$ 发生显著变化，并且这种变化伴随着标准差 $S$ 的成比例变化，则可以推断出突触后量子大小 ($q$) 发生了变化。在数学上，这对应于同时满足两个条件：\n1. 振幅的绝对相对变化超过容差：$|\\alpha_A - 1| > \\varepsilon_A$。\n2. 标准差的缩放与振幅的缩放在容差范围内成比例：$|\\alpha_S / \\alpha_A - 1| <= \\varepsilon_A$。\n如果两个条件都为真，我们断定 $q$ 发生了变化（`q_changed` = true）。否则，我们断定没有证据表明 $q$ 发生了变化（`q_changed` = false）。严格不等式 ($>$) 至关重要。\n\n步骤 2：评估突触前（$N$ 或 $p_s$）的变化\n突触前功能的变化首先通过 mEPSC 频率 $f$ 的显著变化来检测。\n1. 如果频率的绝对相对变化超过其容差，则标记为发生突触前变化：$|\\alpha_f - 1| > \\varepsilon_f$。\n2. 如果检测到突触前变化，我们必须区分是突触数量 ($N$) 的变化还是释放概率 ($p_s$) 的变化。这通过检查爆发性指数 $B$ 来完成。根据模型， $p_s$ 的增加会导致更聚集（爆发性）的释放，从而增加 $B$。 $N$ 的变化会增加总事件率，但不会改变单个突触的释放时间模式，因此 $B$ 保持不变。\n   - 如果爆发性的绝对相对变化超过其容差，$|\\alpha_B - 1| > \\varepsilon_B$，则该变化被分类为由 $p_s$ 引起（`presynaptic_change_type` = $3$）。\n   - 否则，该变化被分类为由 $N$ 引起（`presynaptic_change_type` = $2$）。\n\n步骤 3：最终分类\n最后，将突触后和突触前评估的结果结合起来，分配六个整数代码之一：\n- 如果 `q_changed` 为真且 `presynaptic_change_type` 为 $3$（$p_s$ 变化），则代码为 $5$ (`p_and_q_change`)。\n- 如果 `q_changed` 为真且 `presynaptic_change_type` 为 $2$（$N$ 变化），则代码为 $4$ (`N_and_q_change`)。\n- 如果 `q_changed` 为真且 `presynaptic_change_type` 为 $0$（无突触前变化），则代码为 $1$ (`q_change`)。\n- 如果 `q_changed` 为假且 `presynaptic_change_type` 为 $3$，则代码为 $3$ (`p_change`)。\n- 如果 `q_changed` 为假且 `presynaptic_change_type` 为 $2$，则代码为 $2$ (`N_change`)。\n- 如果 `q_changed` 为假且 `presynaptic_change_type` 为 $0$，则代码为 $0$ (`no_change`)。\n\n让我们以测试用例 1 为例应用此算法：\n- 基线：$(A_1, S_1, f_1, B_1) = (12.0, 3.6, 4.0, 0.20)$\n- 丰富：$(A_2, S_2, f_2, B_2) = (15.0, 4.5, 4.1, 0.20)$\n- 比例因子：$\\alpha_A = 15.0/12.0 = 1.25$，$\\alpha_S = 4.5/3.6 = 1.25$，$\\alpha_f = 4.1/4.0 = 1.025$，$\\alpha_B = 0.20/0.20 = 1.0$。\n- 突触后评估：\n  - $|\\alpha_A - 1| = |1.25 - 1| = 0.25$。由于 $0.25 > \\varepsilon_A = 0.10$，第一个条件满足。\n  - $|\\alpha_S / \\alpha_A - 1| = |1.25 / 1.25 - 1| = 0$。由于 $0 <= \\varepsilon_A = 0.10$，第二个条件满足。\n  - 因此，`q_changed` 为真。\n- 突触前评估：\n  - $|\\alpha_f - 1| = |1.025 - 1| = 0.025$。由于 $0.025$ 不大于 $\\varepsilon_f = 0.10$，没有显著的突触前变化。\n  - 因此，`presynaptic_change_type` 保持为 $0$。\n- 最终分类：`q_changed` 为真且 `presynaptic_change_type` 为 $0$。正确的分类是 `q_change`，对应代码 $1$。\n\n这个严谨、分步的过程将被实施，以对所有提供的测试用例进行分类。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes mEPSC data to classify neurobiological changes based on a given model.\n    \"\"\"\n    \n    # Decision thresholds\n    EPS_A = 0.10  # Amplitude tolerance\n    EPS_F = 0.10  # Frequency tolerance\n    EPS_B = 0.20  # Burstiness tolerance\n\n    # Test suite: Each element is a tuple containing baseline and enriched condition stats.\n    # Format: ((A1, S1, f1, B1), (A2, S2, f2, B2))\n    test_cases = [\n        # Test case 1 (pure q change)\n        ((12.0, 3.6, 4.0, 0.20), (15.0, 4.5, 4.1, 0.20)),\n        # Test case 2 (pure N change)\n        ((13.0, 3.9, 2.0, 0.18), (13.0, 3.9, 4.0, 0.18)),\n        # Test case 3 (pure p change)\n        ((11.0, 3.3, 2.5, 0.20), (11.0, 3.3, 3.75, 0.35)),\n        # Test case 4 (combined p and q change)\n        ((10.0, 3.0, 3.0, 0.15), (12.0, 3.6, 4.5, 0.30)),\n        # Test case 5 (no meaningful change)\n        ((12.0, 3.0, 3.0, 0.20), (12.9, 3.15, 3.2, 0.22)),\n        # Test case 6 (boundary case at amplitude tolerance)\n        ((10.0, 3.0, 3.0, 0.20), (11.0, 3.3, 3.0, 0.20)),\n    ]\n\n    # Encoding dictionary\n    # 0: no_change, 1: q_change, 2: N_change, 3: p_change, \n    # 4: N_and_q_change, 5: p_and_q_change\n    \n    results = []\n    \n    for case in test_cases:\n        base, enriched = case\n        A1, S1, f1, B1 = base\n        A2, S2, f2, B2 = enriched\n\n        # Calculate scale factors\n        alpha_A = A2 / A1\n        alpha_S = S2 / S1\n        alpha_f = f2 / f1\n        alpha_B = B2 / B1\n\n        q_changed = False\n        presynaptic_change_type = 0  # 0: None, 2: N, 3: p\n\n        # Step 1: Evaluate postsynaptic (q) change\n        # A change in q requires a significant change in amplitude (A) and\n        # a proportional change in standard deviation (S).\n        if abs(alpha_A - 1) > EPS_A:\n            if abs(alpha_S / alpha_A - 1) <= EPS_A:\n                q_changed = True\n\n        # Step 2: Evaluate presynaptic (N or p) change\n        # A presynaptic change is detected by a significant change in frequency (f).\n        if abs(alpha_f - 1) > EPS_F:\n            # Distinguish N vs. p change by looking at burstiness (B).\n            if abs(alpha_B - 1) > EPS_B:\n                presynaptic_change_type = 3  # p_s change\n            else:\n                presynaptic_change_type = 2  # N change\n        \n        # Step 3: Combine results and classify\n        code = 0\n        if q_changed:\n            if presynaptic_change_type == 2:   # N_and_q_change\n                code = 4\n            elif presynaptic_change_type == 3: # p_and_q_change\n                code = 5\n            else:                              # q_change only\n                code = 1\n        else: # no q change\n            if presynaptic_change_type == 2:   # N_change only\n                code = 2\n            elif presynaptic_change_type == 3: # p_change only\n                code = 3\n            else:                              # no_change\n                code = 0\n        \n        results.append(code)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}