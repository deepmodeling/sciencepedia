{
    "hands_on_practices": [
        {
            "introduction": "The brain's ability to perceive three-dimensional rotation relies on the clever anatomical arrangement of the three semicircular canals in each inner ear. This practice challenges you to mathematically model this arrangement and understand how it functions. By treating head angular velocity as a vector, you will see how the canals, acting like a non-orthogonal sensor array, decompose any three-dimensional rotation into three distinct signals that the brain can process .",
            "id": "5078236",
            "problem": "A single labyrinth contains three semicircular canals: lateral (horizontal), anterior (superior), and posterior. The sensitive axis of a canal is defined as the unit normal to its plane, with the convention that the canal’s angular velocity sensitivity is given by the projection of the head’s instantaneous angular velocity vector onto this sensitive axis.\n\nAdopt a right-handed head-fixed coordinate system with unit basis vectors $\\hat{\\boldsymbol{x}}$ (anterior, positive forward), $\\hat{\\boldsymbol{y}}$ (leftward), and $\\hat{\\boldsymbol{z}}$ (superior, up). Let Reid’s plane be identified with the head-fixed $x$–$y$ plane.\n\nAssume the following idealized but anatomically consistent orientation model for the three canals of the right labyrinth:\n- The lateral canal plane coincides with Reid’s plane, so its sensitive axis is $\\hat{\\boldsymbol{n}}_{L}=\\hat{\\boldsymbol{z}}$.\n- The anterior canal plane is rotated such that its sensitive axis $\\hat{\\boldsymbol{n}}_{A}$ is obtained by rotating $\\hat{\\boldsymbol{z}}$ by an angle $\\theta=\\pi/4$ toward the in-plane unit direction $\\hat{\\boldsymbol{u}}_{A}=\\frac{1}{\\sqrt{2}}\\left(\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}\\right)$.\n- The posterior canal plane is rotated such that its sensitive axis $\\hat{\\boldsymbol{n}}_{P}$ is obtained by rotating $\\hat{\\boldsymbol{z}}$ by the same angle $\\theta=\\pi/4$ toward the in-plane unit direction $\\hat{\\boldsymbol{u}}_{P}=\\frac{1}{\\sqrt{2}}\\left(-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}\\right)$.\n\nLet the head’s instantaneous angular velocity be $\\boldsymbol{\\omega}=\\omega_{x}\\hat{\\boldsymbol{x}}+\\omega_{y}\\hat{\\boldsymbol{y}}+\\omega_{z}\\hat{\\boldsymbol{z}}$, expressed in radians per second in the head-fixed frame. Using rigid-body kinematics and vector projection, derive closed-form expressions for the three canal projections $s_{L}$, $s_{A}$, and $s_{P}$ defined by $s_{i}=\\boldsymbol{\\omega}\\cdot\\hat{\\boldsymbol{n}}_{i}$ for $i\\in\\{L,A,P\\}$. Express your final result as a single $1\\times 3$ row matrix whose entries are $s_{L}$, $s_{A}$, $s_{P}$ in terms of $\\omega_{x}$, $\\omega_{y}$, and $\\omega_{z}$. Use exact values (do not approximate square roots), and report the projections in radians per second. No numerical rounding is required.",
            "solution": "The problem statement is scientifically grounded, well-posed, objective, and contains all necessary information for a unique solution. It describes a standard, albeit idealized, model of the semicircular canals' orientation and function within the field of neurobiology and biomechanics. The problem is therefore deemed valid and a solution will be provided.\n\nThe objective is to compute the projections, $s_{i}$, of the head's instantaneous angular velocity vector, $\\boldsymbol{\\omega}$, onto the sensitive axes, $\\hat{\\boldsymbol{n}}_{i}$, of the three semicircular canals of the right labyrinth. The governing equation for each projection is the scalar product (dot product):\n$$s_{i} = \\boldsymbol{\\omega} \\cdot \\hat{\\boldsymbol{n}}_{i}$$\nThe angular velocity vector is given in the head-fixed coordinate system as $\\boldsymbol{\\omega}=\\omega_{x}\\hat{\\boldsymbol{x}}+\\omega_{y}\\hat{\\boldsymbol{y}}+\\omega_{z}\\hat{\\boldsymbol{z}}$. We must first determine the vector representation of each sensitive axis, $\\hat{\\boldsymbol{n}}_{i}$ for $i \\in \\{L, A, P\\}$, in this same coordinate system.\n\n1.  **Lateral Canal Projection ($s_{L}$)**\n    The sensitive axis for the lateral canal is explicitly given as $\\hat{\\boldsymbol{n}}_{L}=\\hat{\\boldsymbol{z}}$.\n    We compute the projection $s_{L}$ as follows:\n    $$s_{L} = \\boldsymbol{\\omega} \\cdot \\hat{\\boldsymbol{n}}_{L} = (\\omega_{x}\\hat{\\boldsymbol{x}}+\\omega_{y}\\hat{\\boldsymbol{y}}+\\omega_{z}\\hat{\\boldsymbol{z}}) \\cdot \\hat{\\boldsymbol{z}}$$\n    Using the orthonormality of the basis vectors ($\\hat{\\boldsymbol{x}}\\cdot\\hat{\\boldsymbol{z}}=0$, $\\hat{\\boldsymbol{y}}\\cdot\\hat{\\boldsymbol{z}}=0$, $\\hat{\\boldsymbol{z}}\\cdot\\hat{\\boldsymbol{z}}=1$), the expression simplifies to:\n    $$s_{L} = \\omega_{x}(0) + \\omega_{y}(0) + \\omega_{z}(1) = \\omega_{z}$$\n\n2.  **Anterior Canal Projection ($s_{A}$)**\n    The sensitive axis $\\hat{\\boldsymbol{n}}_{A}$ is obtained by rotating the vector $\\hat{\\boldsymbol{z}}$ by an angle $\\theta=\\pi/4$ toward the unit direction $\\hat{\\boldsymbol{u}}_{A}=\\frac{1}{\\sqrt{2}}\\left(\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}\\right)$. The vectors $\\hat{\\boldsymbol{z}}$ and $\\hat{\\boldsymbol{u}}_{A}$ are orthogonal, as $\\hat{\\boldsymbol{z}} \\cdot \\hat{\\boldsymbol{u}}_{A} = \\hat{\\boldsymbol{z}} \\cdot \\left(\\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{x}} + \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{y}}\\right) = 0$.\n    The formula for rotating a unit vector $\\hat{\\boldsymbol{v}}$ by an angle $\\theta$ toward an orthogonal unit vector $\\hat{\\boldsymbol{u}}$ is $\\hat{\\boldsymbol{v}}_{\\text{rot}} = \\hat{\\boldsymbol{v}}\\cos\\theta + \\hat{\\boldsymbol{u}}\\sin\\theta$.\n    Applying this formula with $\\hat{\\boldsymbol{v}}=\\hat{\\boldsymbol{z}}$ and $\\hat{\\boldsymbol{u}}=\\hat{\\boldsymbol{u}}_{A}$:\n    $$\\hat{\\boldsymbol{n}}_{A} = \\hat{\\boldsymbol{z}}\\cos\\left(\\frac{\\pi}{4}\\right) + \\hat{\\boldsymbol{u}}_{A}\\sin\\left(\\frac{\\pi}{4}\\right)$$\n    Substituting the values $\\cos(\\pi/4) = \\sin(\\pi/4) = \\frac{1}{\\sqrt{2}}$ and the expression for $\\hat{\\boldsymbol{u}}_{A}$:\n    $$\\hat{\\boldsymbol{n}}_{A} = \\hat{\\boldsymbol{z}}\\left(\\frac{1}{\\sqrt{2}}\\right) + \\left(\\frac{1}{\\sqrt{2}}(\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}})\\right)\\left(\\frac{1}{\\sqrt{2}}\\right)$$\n    $$\\hat{\\boldsymbol{n}}_{A} = \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}} + \\frac{1}{2}(\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}) = \\frac{1}{2}\\hat{\\boldsymbol{x}} + \\frac{1}{2}\\hat{\\boldsymbol{y}} + \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}}$$\n    Now we compute the projection $s_{A}$:\n    $$s_{A} = \\boldsymbol{\\omega} \\cdot \\hat{\\boldsymbol{n}}_{A} = (\\omega_{x}\\hat{\\boldsymbol{x}}+\\omega_{y}\\hat{\\boldsymbol{y}}+\\omega_{z}\\hat{\\boldsymbol{z}}) \\cdot \\left(\\frac{1}{2}\\hat{\\boldsymbol{x}} + \\frac{1}{2}\\hat{\\boldsymbol{y}} + \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}}\\right)$$\n    $$s_{A} = \\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z}$$\n\n3.  **Posterior Canal Projection ($s_{P}$)**\n    Similarly, the sensitive axis $\\hat{\\boldsymbol{n}}_{P}$ is obtained by rotating $\\hat{\\boldsymbol{z}}$ by $\\theta=\\pi/4$ toward the unit direction $\\hat{\\boldsymbol{u}}_{P}=\\frac{1}{\\sqrt{2}}\\left(-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}\\right)$. The vectors $\\hat{\\boldsymbol{z}}$ and $\\hat{\\boldsymbol{u}}_{P}$ are also orthogonal.\n    Using the same rotation formula:\n    $$\\hat{\\boldsymbol{n}}_{P} = \\hat{\\boldsymbol{z}}\\cos\\left(\\frac{\\pi}{4}\\right) + \\hat{\\boldsymbol{u}}_{P}\\sin\\left(\\frac{\\pi}{4}\\right)$$\n    Substituting the values:\n    $$\\hat{\\boldsymbol{n}}_{P} = \\hat{\\boldsymbol{z}}\\left(\\frac{1}{\\sqrt{2}}\\right) + \\left(\\frac{1}{\\sqrt{2}}(-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}})\\right)\\left(\\frac{1}{\\sqrt{2}}\\right)$$\n    $$\\hat{\\boldsymbol{n}}_{P} = \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}} + \\frac{1}{2}(-\\hat{\\boldsymbol{x}}+\\hat{\\boldsymbol{y}}) = -\\frac{1}{2}\\hat{\\boldsymbol{x}} + \\frac{1}{2}\\hat{\\boldsymbol{y}} + \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}}$$\n    Now we compute the projection $s_{P}$:\n    $$s_{P} = \\boldsymbol{\\omega} \\cdot \\hat{\\boldsymbol{n}}_{P} = (\\omega_{x}\\hat{\\boldsymbol{x}}+\\omega_{y}\\hat{\\boldsymbol{y}}+\\omega_{z}\\hat{\\boldsymbol{z}}) \\cdot \\left(-\\frac{1}{2}\\hat{\\boldsymbol{x}} + \\frac{1}{2}\\hat{\\boldsymbol{y}} + \\frac{1}{\\sqrt{2}}\\hat{\\boldsymbol{z}}\\right)$$\n    $$s_{P} = -\\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z}$$\n\n4.  **Final Result**\n    The problem requires the result as a single $1\\times 3$ row matrix with entries $s_{L}$, $s_{A}$, and $s_{P}$. Rationalizing the denominator for $\\frac{1}{\\sqrt{2}}$ to $\\frac{\\sqrt{2}}{2}$ is conventional but not required by the prompt; we will retain the form from the derivation. The components are:\n    $$s_{L} = \\omega_{z}$$\n    $$s_{A} = \\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z}$$\n    $$s_{P} = -\\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z}$$\n    Assembling these into a row matrix yields the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\omega_{z} & \\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z} & -\\frac{1}{2}\\omega_{x} + \\frac{1}{2}\\omega_{y} + \\frac{1}{\\sqrt{2}}\\omega_{z}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Vestibular information is critical for stabilizing our gaze and posture, a process achieved through rapid vestibulo-ocular reflexes (VOR). This exercise focuses on ocular counter-roll (OCR), a VOR driven by the otolith organs in response to static head tilt. You will build a model that translates the physical stimulus—the component of gravity sensed by the utricle—into a compensatory eye movement, exploring fundamental concepts like neural gain and saturation that shape the final motor output .",
            "id": "5078182",
            "problem": "A subject performs slow, quasi-static roll tilts about the naso-occipital axis by an angle $\\phi$ with respect to Earth-vertical, where $\\phi>0$ denotes right-ear-down (clockwise as viewed from behind). The utricular macula within the otolith organs detects the component of gravitational acceleration projected onto the interaural (lateral) axis. The semicircular canals encode angular velocity and therefore do not contribute to steady-state signals under quasi-static conditions. Assume the following:\n\n- The gravitational acceleration vector has magnitude $g$, and during steady tilt the lateral projection measured by the utricle is $a_{\\ell} = g \\sin(\\phi)$.\n- The central nervous system rescales the otolith signal by $g$ and inverts the geometry to estimate the tilt: $\\hat{\\phi} = \\arcsin\\!\\big(a_{\\ell}/g\\big)$.\n- The ocular counter-roll (OCR) component of the vestibulo-ocular reflex (VOR) maps the estimated tilt to torsional eye position with an overall central gain $G$ (dimensionless), such that the commanded torsion is proportional to $\\hat{\\phi}$ and opposite in sign to the head roll: $\\theta = -G\\,\\hat{\\phi}$, where $\\theta$ is torsional eye position.\n- The torsional mechanics and neural constraints impose a symmetric saturation $|\\theta| \\leq \\theta_{\\max}$.\n\nStarting from these bases, derive a closed-form expression for the steady-state OCR $\\theta(\\phi)$ in radians as a function of the roll tilt angle $\\phi$ in radians, the gain $G$, and the saturation $\\theta_{\\max}$, under the assumption that $|\\phi|<\\pi/2$. Then, using $G = 0.18$ and $\\theta_{\\max} = 7^{\\circ}$, compute the expected signed torsional eye positions in degrees for tilt angles $\\phi_{1} = 10^{\\circ}$, $\\phi_{2} = 30^{\\circ}$, and $\\phi_{3} = 50^{\\circ}$, adopting the convention that positive $\\phi$ evokes negative $\\theta$. Express the three numerical results in degrees, in the order $(\\phi_{1}, \\phi_{2}, \\phi_{3})$, and round your answers to four significant figures.",
            "solution": "The utricular macula senses the component of gravitational acceleration along the interaural axis. Under steady tilt with no linear motion other than gravity, the measured lateral acceleration is given by\n$$\na_{\\ell} = g \\sin(\\phi).\n$$\nNormalizing by $g$ and inverting the geometry yields the central estimate of roll tilt:\n$$\n\\hat{\\phi} = \\arcsin\\!\\left(\\frac{a_{\\ell}}{g}\\right) = \\arcsin\\!\\big(\\sin(\\phi)\\big).\n$$\nFor $|\\phi|<\\frac{\\pi}{2}$, the principal value satisfies $\\arcsin(\\sin(\\phi)) = \\phi$, so\n$$\n\\hat{\\phi} = \\phi \\quad \\text{for} \\quad |\\phi|<\\frac{\\pi}{2}.\n$$\nThe vestibulo-ocular reflex (VOR) torsional component, ocular counter-roll (OCR), is proportional to the estimated tilt with overall central gain $G$ and opposite sign (eyes counter-rotate relative to the head tilt):\n$$\n\\theta_{\\text{cmd}}(\\phi) = -G\\,\\hat{\\phi} = -G\\,\\phi.\n$$\nPhysiologically, torsional eye position is bounded in magnitude by a saturation limit $\\theta_{\\max}$, so the realized steady-state torsion is\n$$\n\\theta(\\phi) = -\\operatorname{sgn}(\\phi)\\,\\min\\!\\big(G\\,|\\phi|,\\ \\theta_{\\max}\\big),\n$$\nwhere $\\phi$ and $\\theta$ are in radians. This expression is obtained by taking the commanded value $\\theta_{\\text{cmd}}(\\phi)$ and clipping it to the interval $[-\\theta_{\\max},\\ \\theta_{\\max}]$.\n\nNext, we evaluate $\\theta$ for the specified tilts and parameters. We are asked to report torsion in degrees, rounded to four significant figures, with the convention that positive $\\phi$ evokes negative $\\theta$.\n\nConvert the saturation to radians for internal computation:\n$$\n\\theta_{\\max} = 7^{\\circ} = 7 \\times \\frac{\\pi}{180}\\ \\text{rad} = \\frac{7\\pi}{180}\\ \\text{rad}.\n$$\nHowever, it is convenient to note a unit relation when unsaturated: if $\\theta(\\text{rad}) = -G\\,\\phi(\\text{rad})$, then converting both to degrees gives\n$$\n\\theta(\\text{deg}) = \\theta(\\text{rad})\\times\\frac{180}{\\pi} = -G\\,\\phi(\\text{rad})\\times\\frac{180}{\\pi} = -G\\left(\\phi(\\text{deg})\\times\\frac{\\pi}{180}\\right)\\times\\frac{180}{\\pi} = -G\\,\\phi(\\text{deg}).\n$$\nThus, in the unsaturated regime, the numerical OCR in degrees is simply $-G$ times the numerical tilt in degrees.\n\nWe compute for each tilt:\n\n1. For $\\phi_{1} = 10^{\\circ}$,\n   - Unsaturated prediction in degrees: $\\theta_{1,\\text{unsat}} = -G\\,\\phi_{1} = -0.18 \\times 10^{\\circ} = -1.8^{\\circ}$.\n   - Compare to saturation: $|\\theta_{1,\\text{unsat}}| = 1.8^{\\circ} < 7^{\\circ}$, so no saturation.\n   - Rounded to four significant figures: $\\theta_{1} = -1.800^{\\circ}$.\n\n2. For $\\phi_{2} = 30^{\\circ}$,\n   - Unsaturated prediction in degrees: $\\theta_{2,\\text{unsat}} = -G\\,\\phi_{2} = -0.18 \\times 30^{\\circ} = -5.4^{\\circ}$.\n   - Compare to saturation: $|\\theta_{2,\\text{unsat}}| = 5.4^{\\circ} < 7^{\\circ}$, so no saturation.\n   - Rounded to four significant figures: $\\theta_{2} = -5.400^{\\circ}$.\n\n3. For $\\phi_{3} = 50^{\\circ}$,\n   - Unsaturated prediction in degrees: $\\theta_{3,\\text{unsat}} = -G\\,\\phi_{3} = -0.18 \\times 50^{\\circ} = -9.0^{\\circ}$.\n   - Compare to saturation: $|\\theta_{3,\\text{unsat}}| = 9.0^{\\circ} > 7^{\\circ}$, so the response saturates at the bound.\n   - Apply sign convention with saturation: $\\theta_{3} = -7.0^{\\circ}$.\n   - Rounded to four significant figures: $\\theta_{3} = -7.000^{\\circ}$.\n\nTherefore, the derived function and the requested numerical values (reported in the order $(\\phi_{1}, \\phi_{2}, \\phi_{3})$) are consistent with an otolith-driven estimate of tilt, a central gain, and torsional saturation, with semicircular canal contributions negligible under quasi-static, steady-state conditions.",
            "answer": "$$\\boxed{\\begin{pmatrix}-1.800 & -5.400 & -7.000\\end{pmatrix}}$$"
        },
        {
            "introduction": "While it is useful to model the three canals as single sensors, the brain actually receives information from a large population of afferent neurons. This hands-on coding exercise delves into how the central nervous system might decode this population activity to achieve a robust estimate of head motion. By implementing and comparing a \"naive\" decoder with a \"corrected\" one, you will learn why accounting for the real, non-uniform properties of neural populations is crucial for accurate sensory reconstruction .",
            "id": "5078244",
            "problem": "You are asked to implement a population vector decoding algorithm for semicircular canal afferent signals and to quantify its bias under non-uniform axis distributions. The coding model should start from first principles in neurobiology and mechanics: semicircular canal afferents approximate the component of head angular velocity along their anatomical axes. Formally, for a population of $N$ canal afferents with unit axis vectors $\\mathbf{u}_i \\in \\mathbb{R}^3$ and gains $k_i$, the instantaneous firing response of afferent $i$ is modeled as $r_i = k_i \\left(\\mathbf{u}_i \\cdot \\boldsymbol{\\omega}\\right)$, where $\\boldsymbol{\\omega} \\in \\mathbb{R}^3$ is the head angular velocity vector. Your decoding should be based on the population vector $\\mathbf{s} = \\sum_{i=1}^{N} r_i \\,\\mathbf{u}_i$, and you will examine bias introduced by non-uniform axis distributions and non-uniform gains.\n\nStarting from the definitions above and basic linear algebra, implement the following two decoders:\n\n- A naive decoder that assumes a uniform axis distribution and uses a scalar calibration derived from that assumption. Under an isotropic distribution (uniform over the unit sphere), the average of $\\mathbf{u}_i \\mathbf{u}_i^\\top$ satisfies $\\mathbb{E}\\left[\\mathbf{u}\\mathbf{u}^\\top\\right] = \\frac{1}{3}\\mathbf{I}$. Using this, the naive calibration matrix is $\\mathbf{C}_0 = \\bar{k}\\,\\frac{N}{3}\\,\\mathbf{I}$, where $\\bar{k}$ is the mean gain. The naive estimate is $\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} = \\mathbf{C}_0^{-1}\\,\\mathbf{s}$.\n\n- A corrected decoder that computes the actual second-moment matrix of the axis distribution with gains, $\\mathbf{M} = \\sum_{i=1}^{N} k_i\\,\\mathbf{u}_i\\,\\mathbf{u}_i^\\top$, and then inverts (or pseudo-inverts) it to obtain $\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} = \\mathbf{M}^{+}\\,\\mathbf{s}$, where $\\mathbf{M}^{+}$ denotes the inverse if $\\mathbf{M}$ is invertible, otherwise the Moore–Penrose pseudo-inverse.\n\nFor each test case provided below, compute the Euclidean norm of the estimation error for both decoders, $\\left\\|\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} - \\boldsymbol{\\omega}\\right\\|_2$ and $\\left\\|\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} - \\boldsymbol{\\omega}\\right\\|_2$, and report these as floating-point numbers in radians per second (rad/s). You must express results in rad/s. Angles, when they appear as components of $\\boldsymbol{\\omega}$, are in radians. No percentages are used; all scalar outputs must be floats.\n\nUse the following test suite, which covers uniform axis distributions, non-uniform distributions, gain heterogeneity, and a degenerate case with a singular matrix:\n\n- Test case $1$ (uniform axes, unit gains): $\\mathbf{u}_i \\in \\left\\{\\begin{bmatrix}1  0  0\\end{bmatrix}, \\begin{bmatrix}-1  0  0\\end{bmatrix}, \\begin{bmatrix}0  1  0\\end{bmatrix}, \\begin{bmatrix}0  -1  0\\end{bmatrix}, \\begin{bmatrix}0  0  1\\end{bmatrix}, \\begin{bmatrix}0  0  -1\\end{bmatrix}\\right\\}$, $k_i = 1$ for all $i$, $\\boldsymbol{\\omega} = \\begin{bmatrix}0.3  -0.2  0.5\\end{bmatrix}$ rad/s.\n\n- Test case $2$ (non-uniform axes, unit gains): $\\mathbf{u}_i \\in \\left\\{\\begin{bmatrix}1  0  0\\end{bmatrix}, \\begin{bmatrix}-1  0  0\\end{bmatrix}, \\begin{bmatrix}0  1  0\\end{bmatrix}, \\begin{bmatrix}0  0  1\\end{bmatrix}, \\begin{bmatrix}0  0  1\\end{bmatrix}, \\begin{bmatrix}0  0  1\\end{bmatrix}\\right\\}$, $k_i = 1$ for all $i$, $\\boldsymbol{\\omega} = \\begin{bmatrix}0.3  -0.2  0.5\\end{bmatrix}$ rad/s.\n\n- Test case $3$ (degenerate collinear axes, unit gains): $\\mathbf{u}_i = \\begin{bmatrix}0  0  1\\end{bmatrix}$ for $i = 1,\\dots,5$, $k_i = 1$ for all $i$, $\\boldsymbol{\\omega} = \\begin{bmatrix}0.3  -0.2  0.5\\end{bmatrix}$ rad/s.\n\n- Test case $4$ (uniform axes, heterogeneous gains): $\\mathbf{u}_i \\in \\left\\{\\begin{bmatrix}1  0  0\\end{bmatrix}, \\begin{bmatrix}-1  0  0\\end{bmatrix}, \\begin{bmatrix}0  1  0\\end{bmatrix}, \\begin{bmatrix}0  -1  0\\end{bmatrix}, \\begin{bmatrix}0  0  1\\end{bmatrix}, \\begin{bmatrix}0  0  -1\\end{bmatrix}\\right\\}$, $k = \\begin{bmatrix}2  0.5  1  3  0.8  1.2\\end{bmatrix}$, $\\boldsymbol{\\omega} = \\begin{bmatrix}0.1  0.05  -0.2\\end{bmatrix}$ rad/s.\n\n- Test case $5$ (invertible but anisotropic axes, unit gains): $\\mathbf{u}_1 = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  1  0\\end{bmatrix}$, $\\mathbf{u}_2 = \\begin{bmatrix}1  0  0\\end{bmatrix}$, $\\mathbf{u}_3 = \\begin{bmatrix}0  1  0\\end{bmatrix}$, $\\mathbf{u}_4 = \\begin{bmatrix}0  0  -1\\end{bmatrix}$, $\\mathbf{u}_5 = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}0  1  1\\end{bmatrix}$, $\\mathbf{u}_6 = \\frac{1}{\\sqrt{2}}\\begin{bmatrix}1  0  1\\end{bmatrix}$, $k_i = 1$ for all $i$, $\\boldsymbol{\\omega} = \\begin{bmatrix}-0.4  0.2  0.1\\end{bmatrix}$ rad/s.\n\nImplementation details:\n\n- Construct $\\mathbf{s}$ directly from the definition $\\mathbf{s} = \\sum_{i=1}^{N} r_i \\,\\mathbf{u}_i$ using $r_i = k_i \\left(\\mathbf{u}_i \\cdot \\boldsymbol{\\omega}\\right)$.\n\n- For the naive decoder, compute the mean gain $\\bar{k} = \\frac{1}{N}\\sum_{i=1}^{N} k_i$ and use $\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} = \\left(\\frac{3}{N\\,\\bar{k}}\\right)\\mathbf{s}$.\n\n- For the corrected decoder, compute $\\mathbf{M} = \\sum_{i=1}^{N} k_i\\,\\mathbf{u}_i\\,\\mathbf{u}_i^\\top$ and then $\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} = \\mathbf{M}^{+}\\,\\mathbf{s}$, using the Moore–Penrose pseudo-inverse when necessary.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $\\left[\\text{result1},\\text{result2},\\text{result3}\\right]$). For each test case in order, append the naive error followed by the corrected error, both expressed as floats in rad/s, so the final output contains $10$ floats for the $5$ test cases in the order $[\\text{naive}_1,\\text{corr}_1,\\text{naive}_2,\\text{corr}_2,\\dots,\\text{naive}_5,\\text{corr}_5]$.",
            "solution": "The user requires the implementation and comparison of two population vector decoding algorithms for semicircular canal afferent signals. The analysis centers on quantifying estimation error, particularly the bias introduced by non-uniform sensory axis distributions and heterogeneous gains.\n\n### Theoretical Foundation\n\nThe problem is rooted in the principles of neural population coding, specifically as applied to the vestibular system's sensing of angular head velocity.\n\n**1. Encoding Model:**\nThe response of a single semicircular canal afferent neuron is modeled by a linear equation. The firing rate $r_i$ of the $i$-th neuron is proportional to the projection of the head's angular velocity vector $\\boldsymbol{\\omega}$ onto the neuron's specific sensitivity axis $\\mathbf{u}_i$.\n\n$$r_i = k_i (\\mathbf{u}_i \\cdot \\boldsymbol{\\omega})$$\n\nHere, $k_i$ is the neuron's gain. This model establishes a linear relationship between the stimulus ($\\boldsymbol{\\omega}$) and the neural response ($r_i$).\n\n**2. Population Vector:**\nTo decode the stimulus, the brain is thought to combine information from the entire population of $N$ neurons. A common model for this is the population vector $\\mathbf{s}$, which is a vector sum of the preferred directions $\\mathbf{u}_i$, weighted by their corresponding firing rates $r_i$.\n\n$$\\mathbf{s} = \\sum_{i=1}^{N} r_i \\mathbf{u}_i$$\n\n**3. Decoding as a Linear System:**\nWe can substitute the encoding model into the population vector definition to establish a direct link between the stimulus $\\boldsymbol{\\omega}$ and the population vector $\\mathbf{s}$:\n\n$$\\mathbf{s} = \\sum_{i=1}^{N} \\left( k_i (\\mathbf{u}_i \\cdot \\boldsymbol{\\omega}) \\right) \\mathbf{u}_i$$\n\nUsing the vector identity $(\\mathbf{a} \\cdot \\mathbf{b})\\mathbf{c} = (\\mathbf{c}\\mathbf{a}^\\top)\\mathbf{b}$, where $\\mathbf{u}_i\\mathbf{u}_i^\\top$ is the outer product (a $3 \\times 3$ matrix), we can rewrite the expression:\n\n$$\\mathbf{s} = \\sum_{i=1}^{N} k_i (\\mathbf{u}_i \\mathbf{u}_i^\\top) \\boldsymbol{\\omega} = \\left( \\sum_{i=1}^{N} k_i \\mathbf{u}_i \\mathbf{u}_i^\\top \\right) \\boldsymbol{\\omega}$$\n\nThis reveals that the population vector $\\mathbf{s}$ is a linear transformation of the original stimulus $\\boldsymbol{\\omega}$. The transformation matrix, which we denote as $\\mathbf{M}$, captures the complete information about the population's axes and gains:\n\n$$\\mathbf{M} = \\sum_{i=1}^{N} k_i \\mathbf{u}_i \\mathbf{u}_i^\\top$$\n\nThe relationship simplifies to a matrix equation:\n$$\\mathbf{s} = \\mathbf{M} \\boldsymbol{\\omega}$$\n\nThe decoding problem is now equivalent to solving this system of linear equations for $\\boldsymbol{\\omega}$.\n\n### Decoder Implementations\n\n**1. Corrected Decoder:**\nThe most direct way to solve $\\mathbf{s} = \\mathbf{M} \\boldsymbol{\\omega}$ for $\\boldsymbol{\\omega}$ is by using the inverse of $\\mathbf{M}$. If $\\mathbf{M}$ is not invertible (i.e., it is singular, which occurs if the sensor axes $\\mathbf{u}_i$ do not span all three dimensions), the system does not have a unique solution. In such cases, the best linear unbiased estimator in a least-squares sense is found using the Moore-Penrose pseudo-inverse, denoted $\\mathbf{M}^{+}$. This gives the corrected estimate:\n\n$$\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} = \\mathbf{M}^{+} \\mathbf{s}$$\n\nThis decoder will provide a perfect reconstruction, $\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} = \\boldsymbol{\\omega}$, whenever $\\mathbf{M}$ is invertible. When $\\mathbf{M}$ is singular, it projects $\\boldsymbol{\\omega}$ onto the subspace spanned by the sensor axes, recovering the components of motion that the system can actually measure.\n\n**2. Naive Decoder:**\nThe naive decoder operates under a strong simplifying assumption: that the sensor axes are isotropically distributed and the gains are uniform ($\\forall i, k_i = \\bar{k}$). Under this ideal condition, the matrix $\\mathbf{M}$ would simplify to a scalar multiple of the identity matrix $\\mathbf{I}$. This is based on the statistical mechanics result that for a uniform distribution of unit vectors $\\mathbf{u}$ over a sphere, the expected value of the outer product is $\\mathbb{E}[\\mathbf{u}\\mathbf{u}^\\top] = \\frac{1}{3}\\mathbf{I}$. Summing over $N$ neurons with average gain $\\bar{k}$, the idealized matrix becomes:\n\n$$\\mathbf{C}_0 = \\sum_{i=1}^{N} \\bar{k} \\mathbb{E}[\\mathbf{u}\\mathbf{u}^\\top] = N \\bar{k} \\left( \\frac{1}{3} \\mathbf{I} \\right) = \\frac{N\\bar{k}}{3} \\mathbf{I}$$\n\nThe naive decoder uses the inverse of this idealized matrix, $\\mathbf{C}_0$, to estimate $\\boldsymbol{\\omega}$:\n\n$$\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} = \\mathbf{C}_0^{-1} \\mathbf{s} = \\left(\\frac{N\\bar{k}}{3} \\mathbf{I}\\right)^{-1} \\mathbf{s} = \\frac{3}{N\\bar{k}}\\mathbf{I}^{-1}\\mathbf{s} = \\frac{3}{N\\bar{k}}\\mathbf{s}$$\n\nThis decoder essentially treats the population vector $\\mathbf{s}$ as being perfectly aligned with $\\boldsymbol{\\omega}$, differing only by a scalar factor. This assumption fails when the true matrix $\\mathbf{M}$ is not a multiple of the identity, which occurs with non-uniform axis distributions or heterogeneous gains, leading to systematic estimation errors (bias).\n\n### Algorithm and Calculation Steps\n\nFor each test case, the following procedure is executed:\n1.  **Define Inputs**: The angular velocity $\\boldsymbol{\\omega}$, the set of $N$ axis vectors $\\{\\mathbf{u}_i\\}$, and the set of gains $\\{k_i\\}$ are defined.\n2.  **Compute Responses**: The firing rate for each neuron, $r_i = k_i (\\mathbf{u}_i \\cdot \\boldsymbol{\\omega})$, is calculated.\n3.  **Compute Population Vector**: The population vector $\\mathbf{s} = \\sum_{i=1}^{N} r_i \\mathbf{u}_i$ is computed.\n4.  **Apply Naive Decoder**:\n    a. The mean gain $\\bar{k} = \\frac{1}{N}\\sum k_i$ is calculated.\n    b. The naive estimate is computed: $\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} = \\frac{3}{N\\bar{k}}\\mathbf{s}$.\n    c. The naive error is calculated as the Euclidean norm: $\\|\\hat{\\boldsymbol{\\omega}}_{\\text{naive}} - \\boldsymbol{\\omega}\\|_2$.\n5.  **Apply Corrected Decoder**:\n    a. The matrix $\\mathbf{M} = \\sum_{i=1}^{N} k_i (\\mathbf{u}_i \\mathbf{u}_i^\\top)$ is constructed by summing the outer products.\n    b. The Moore-Penrose pseudo-inverse $\\mathbf{M}^{+}$ is computed.\n    c. The corrected estimate is computed: $\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} = \\mathbf{M}^{+} \\mathbf{s}$.\n    d. The corrected error is calculated as the Euclidean norm: $\\|\\hat{\\boldsymbol{\\omega}}_{\\text{corr}} - \\boldsymbol{\\omega}\\|_2$.\n6.  **Store Results**: The naive error and corrected error are stored for final output.\n\nThis process demonstrates how the corrected decoder, by explicitly computing the system matrix $\\mathbf{M}$, adapts to the specific configuration of sensors, whereas the naive decoder's performance degrades as the system deviates from the ideal uniform assumption.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares naive and corrected population vector decoders\n    for semicircular canal afferent signals.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: uniform axes, unit gains\n        {\n            \"u\": np.array([\n                [1, 0, 0], [-1, 0, 0], [0, 1, 0],\n                [0, -1, 0], [0, 0, 1], [0, 0, -1]\n            ]),\n            \"k\": np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"omega\": np.array([0.3, -0.2, 0.5])\n        },\n        # Case 2: non-uniform axes, unit gains\n        {\n            \"u\": np.array([\n                [1, 0, 0], [-1, 0, 0], [0, 1, 0],\n                [0, 0, 1], [0, 0, 1], [0, 0, 1]\n            ]),\n            \"k\": np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"omega\": np.array([0.3, -0.2, 0.5])\n        },\n        # Case 3: degenerate collinear axes, unit gains\n        {\n            \"u\": np.array([\n                [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]\n            ]),\n            \"k\": np.array([1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"omega\": np.array([0.3, -0.2, 0.5])\n        },\n        # Case 4: uniform axes, heterogeneous gains\n        {\n            \"u\": np.array([\n                [1, 0, 0], [-1, 0, 0], [0, 1, 0],\n                [0, -1, 0], [0, 0, 1], [0, 0, -1]\n            ]),\n            \"k\": np.array([2.0, 0.5, 1.0, 3.0, 0.8, 1.2]),\n            \"omega\": np.array([0.1, 0.05, -0.2])\n        },\n        # Case 5: invertible but anisotropic axes, unit gains\n        {\n            \"u\": np.array([\n                [1/np.sqrt(2), 1/np.sqrt(2), 0],\n                [1, 0, 0],\n                [0, 1, 0],\n                [0, 0, -1],\n                [0, 1/np.sqrt(2), 1/np.sqrt(2)],\n                [1/np.sqrt(2), 0, 1/np.sqrt(2)]\n            ]),\n            \"k\": np.array([1.0, 1.0, 1.0, 1.0, 1.0, 1.0]),\n            \"omega\": np.array([-0.4, 0.2, 0.1])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        u_vectors = case[\"u\"]\n        gains = case[\"k\"]\n        omega = case[\"omega\"]\n        N = len(gains)\n\n        # 1. Encoding: Calculate firing rates and population vector\n        # r_i = k_i * (u_i . omega)\n        # Vectorized: r = gains * (u_vectors @ omega)\n        r = gains * np.dot(u_vectors, omega)\n        \n        # s = sum(r_i * u_i)\n        # Vectorized: s = u_vectors.T @ r\n        s = np.dot(u_vectors.T, r)\n\n        # 2. Naive Decoder\n        k_bar = np.mean(gains)\n        omega_hat_naive = (3.0 / (N * k_bar)) * s\n        error_naive = np.linalg.norm(omega_hat_naive - omega)\n        results.append(error_naive)\n\n        # 3. Corrected Decoder\n        # M = sum(k_i * u_i * u_i.T)\n        M = np.zeros((3, 3))\n        for i in range(N):\n            M += gains[i] * np.outer(u_vectors[i], u_vectors[i])\n        \n        # Use Moore-Penrose pseudo-inverse for M+\n        M_pinv = np.linalg.pinv(M)\n        \n        # omega_hat_corr = M+ * s\n        omega_hat_corr = np.dot(M_pinv, s)\n        error_corr = np.linalg.norm(omega_hat_corr - omega)\n        results.append(error_corr)\n\n    # Format output as a comma-separated list of floats in brackets\n    print(f\"[{','.join(f'{r:.12f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}