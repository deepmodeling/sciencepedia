{
    "hands_on_practices": [
        {
            "introduction": "这项练习是一个经典的神经生理学思想实验，旨在巩固您对视网膜ON和OFF通路工作原理的理解。通过预测特定药理学阻断剂（L-AP4）对神经节细胞光反应的影响，您将深入探究这两种通路如何通过不同的突触机制，将光信号分离为“亮”和“暗”的独立信息流。这个练习  是理解视网膜对比度编码基本逻辑的关键一步。",
            "id": "5004878",
            "problem": "一位实验者在呈现一个位于中央、局限于感受野 (RF) 中心且对周围区域激活可忽略不计的小亮斑时，记录了视网膜神经节细胞 (RGC) 的细胞外动作电位。该亮斑是在平均背景亮度 $L_{0}$ 上，于时间 $t=0$ 施加、于时间 $t=T$ 关闭的一个振幅为 $\\Delta L>0$ 的亮度阶跃。阶跃前的基线放电率为 $r_{0}$。实验考虑了两种 RGC：ON 中心型 RGC 和 OFF 中心型 RGC。在确定了对照组的响应后，实验者浴灌法施加了 L-2-氨基-4-磷酸丁酸 (L-AP$4$；也称为 APB)，这是一种由 ON 双极细胞表达的突触后代谢型谷氨酸受体 $6$ (mGluR$6$) 的选择性激动剂。假设经典的视网膜回路：光增强使光感受器超极化并减少谷氨酸的释放；光感受器到 ON 双极细胞的突触通过 mGluR$6$ 是信号反转的，而光感受器到 OFF 双极细胞的突触通过离子型谷氨酸受体是信号保持的。每种 RGC 的中心兴奋主要来自其匹配的双极细胞通路（ON 或 OFF），并且中心的小亮斑将周围区域介导的贡献降至最低。\n\n哪个选项最能预测在对照条件下和施加 L-AP$4$ (APB) 后，ON 中心型与 OFF 中心型 RGC 中动作电位发放率变化的极性和定性时间进程，并正确解释其通路特异性的药理学原理？\n\nA. 对照组：ON 中心型细胞在 $t=0$ 时显示动作电位增加（通常是在 $0 < t < T$ 期间持续，可能带有瞬态成分），并在 $t=T$ 时受到抑制。OFF 中心型细胞在 $0 < t < T$ 期间受到抑制，并在 $t=T$ 时显示一个动作电位爆发。施加 L-AP4 后：ON 中心型 RGC 对光的反应被消除，因为 L-AP4 是一种 mGluR6 激动剂，它使 ON 双极细胞持续超极化，从而有效地将 ON 通路锁定在“关闭”状态，阻止了对光诱导的谷氨酸减少的任何响应。OFF 通路不受影响，因为 L-AP4 对离子型谷氨酸受体没有作用。\n\nB. 对照组：ON 中心型细胞在 $t=0$ 时显示动作电位增加，在 $t=T$ 时受到抑制。OFF 中心型细胞在 $0 < t < T$ 期间受到抑制，在 $t=T$ 时显示一个动作电位爆发。施加 L-AP4 后：OFF 中心型 RGC 对光的反应被消除，因为 L-AP4 阻断了将光信号传递给 OFF 双极细胞的离子型谷氨酸受体。ON 通路不受影响，因为其使用 mGluR6 受体。\n\nC. 对照组：ON 中心型细胞在 $0 < t < T$ 期间受到抑制，并在 $t=T$ 时显示一个动作电位爆发。OFF 中心型细胞在 $t=0$ 时显示动作电位增加。施加 L-AP4 后：两条通路都被消除，因为 L-AP4 作用于所有谷氨酸受体。\n\nD. 对照组：ON 中心型细胞在 $t=0$ 时显示动作电位增加，并在 $t=T$ 时受到抑制。OFF 中心型细胞在 $0 < t < T$ 期间受到抑制，在 $t=T$ 时显示一个动作电位爆发。施加 L-AP4 后：两条通路的作用被互换；ON 中心型 RGC 现在在光关闭时放电，而 OFF 中心型 RGC 在光开启时放电，因为 L-AP4 改变了突触的极性。",
            "solution": "在进行解答之前，将对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- **实验设置：** 记录视网膜神经节细胞 (RGC) 的细胞外动作电位。\n- **刺激：** 一个位于中央、局限于感受野 (RF) 中心的小亮斑。该刺激是一个振幅为 $\\Delta L > 0$ 的亮度阶跃，于时间 $t=0$ 施加，于时间 $t=T$ 关闭。背景亮度为 $L_{0}$。\n- **基线条件：** 刺激前的基线放电率为 $r_{0}$。\n- **研究的细胞：** 一个 ON 中心型 RGC 和一个 OFF 中心型 RGC。\n- **药理学试剂：** L-2-氨基-4-磷酸丁酸 (L-AP$4$ 或 APB)。\n- **试剂作用机制：** L-AP$4$ 是突触后代谢型谷氨酸受体 $6$ (mGluR$6$) 的一种选择性激动剂。\n- **目标受体的细胞定位：** mGluR$6$ 由 ON 双极细胞表达。\n- **经典视网膜回路原理：**\n    1. 光增强 ($\\Delta L > 0$) 使光感受器超极化。\n    2. 光感受器的超极化减少其谷氨酸释放速率。\n    3. 光感受器与 ON 双极细胞之间的突触是信号反转的，由 mGluR$6$ 介导。\n    4. 光感受器与 OFF 双极细胞之间的突触是信号保持的，由离子型谷氨酸受体 (iGluRs) 介导。\n- **回路假设：**\n    1. 每种 RGC 类型的中心兴奋主要来自其相应的双极细胞通路（ON-RGC 来自 ON 双极细胞；OFF-RGC 来自 OFF 双极细胞）。\n    2. 位于中心的小亮斑将来自 RF 周围区域的贡献降至最低。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据既定标准对问题陈述进行评估。\n- **科学依据：** 该问题描述了视网膜神经生理学中一个经典且基础的实验。所有陈述的原理——ON 和 OFF 通路的功能、mGluR$6$ 突触的信号反转性质、iGluR 突触的信号保持性质、光对光感受器的影响，以及 L-AP$4$ (APB) 作为 mGluR$6$ 激动剂的特定作用——都是视觉科学中公认的核心概念。\n- **适定性：** 问题定义清晰。它明确了输入（光刺激和药物）、系统（经典视网膜回路）和期望的输出（RGC 放电率的定性预测）。所提供的假设（最小的周围区域影响、经典的连接）使问题变得可解且明确。\n- **客观性：** 语言技术性强、精确，并且没有主观或含糊的术语。\n- **其他缺陷：** 该问题没有列出的那些缺陷。它在科学上不是不合理的、不完整的、矛盾的、不切实际的、不适定的或琐碎的。它要求应用基本原理来预测特定扰动的结果。\n\n### 第 3 步：结论与行动\n问题陈述是 **有效的**。将推导出解决方案。\n\n### 基于原理的推导\n\n我们将分析在对照条件下和施加 L-AP$4$ 后，ON 和 OFF 通路中的事件序列。\n\n**1. 对照条件（无 L-AP$4$）**\n\n*   **刺激开始 ($t=0$):** 呈现一个亮斑 ($\\Delta L > 0$)。\n    1.  感受野中心的光感受器吸收更多光子并 **超极化**。\n    2.  超极化的光感受器 **减少其谷氨酸的释放**。\n    3.  **ON 通路:** ON 双极细胞表达 mGluR$6$，这是一种代谢型受体，当与谷氨酸结合时，会使细胞超极化（信号反转突触）。谷氨酸释放的减少导致 **mGluR$6$ 的激活减少**，从而 **去抑制** ON 双极细胞，使其 **去极化**。这种去极化导致 ON 双极细胞增加其谷氨酸释放。下游的 ON 中心型 RGC 被兴奋，导致其 **动作电位发放率增加**。这种响应通常在刺激开始时 ($t=0$) 包括一个急剧的短暂爆发，并可能在 $0 < t < T$ 期间有一个持续的部分。\n    4.  **OFF 通路:** OFF 双极细胞表达离子型谷氨酸受体 (iGluRs)，这些受体是兴奋性的（信号保持突触）。谷氨酸释放的减少导致 **iGluRs 的激活减少**，使 OFF 双极细胞 **超极化**。这种超极化导致 OFF 双极细胞减少其谷氨酸释放。下游的 OFF 中心型 RGC 接收到的兴奋减少，导致其在 $0 < t < T$ 期间 **动作电位发放率降低**（放电暂停或下降）。\n\n*   **刺激关闭 ($t=T$):** 亮斑被关闭。\n    1.  亮度返回到基线 ($L_0$)。光感受器 **去极化** 回到其静息电位。\n    2.  这种去极化导致光感受器短暂地 **增加谷氨酸的释放**。\n    3.  **ON 通路:** 增加的谷氨酸释放 **强烈激活** ON 双极细胞上的 **抑制性 mGluR$6$ 受体**，使其 **超极化**。这导致 ON 中心型 RGC 的 **放电率下降或暂停**。\n    4.  **OFF 通路:** 增加的谷氨酸释放 **强烈激活** OFF 双极细胞上的 **兴奋性 iGluRs**，使其 **去极化**。这导致 OFF 中心型 RGC 中出现短暂的兴奋爆发，使其 **动作电位发放率增加**。\n\n**对照组总结：**\n- **ON 中心型 RGC:** 在光照开始时 ($t=0$) 强烈放电，在光照结束时 ($t=T$) 受到抑制。\n- **OFF 中心型 RGC:** 在光照呈现期间 ($0 < t < T$) 受到抑制，在光照结束时 ($t=T$) 强烈放电。\n\n**2. 施加 L-AP$4$ (APB) 后**\n\nL-AP$4$ 是 mGluR$6$ 的一种选择性激动剂。它结合并激活这些受体，模拟高浓度谷氨酸的存在。\n\n*   **对 ON 通路的影响:**\n    1.  L-AP$4$ 持续且强烈地激活 ON 双极细胞上的 mGluR$6$ 受体。\n    2.  这种激活模拟了高谷氨酸水平的效果，导致 ON 双极细胞处于持续的 **超极化** 状态。\n    3.  当在 $t=0$ 时呈现光刺激时，光感受器超极化并减少其谷氨酸释放。然而，ON 双极细胞已经被饱和浓度的激动剂 L-AP$4$ 最大限度地超极化。内源性谷氨酸的变化没有额外的效果。\n    4.  因此，ON 双极细胞 **无法对光产生去极化** 响应。它不向 ON 中心型 RGC 提供兴奋性信号。\n    5.  ON 中心型 RGC 的光诱发 **响应被消除**。\n\n*   **对 OFF 通路的影响:**\n    1.  OFF 通路依赖于光感受器和 OFF 双极细胞之间突触处的 iGluRs。\n    2.  L-AP$4$ 被描述为 mGluR$6$ 的 *选择性* 激动剂，对 iGluRs 没有显著影响。\n    3.  因此，从光感受器到 OFF 双极细胞，再到 OFF 中心型 RGC 的信号传导保持完整。\n    4.  施加 L-AP$4$ 后，**OFF 中心型 RGC 的响应基本不变**。\n\n### 逐项分析\n\n*   **A. 对照组：ON 中心型细胞在 $t=0$ 时显示动作电位增加（通常是在 $0 < t < T$ 期间持续，可能带有瞬态成分），并在 $t=T$ 时受到抑制。OFF 中心型细胞在 $0 < t < T$ 期间受到抑制，并在 $t=T$ 时显示一个动作电位爆发。施加 L-AP4 后：ON 中心型 RGC 对光的反应被消除，因为 L-AP4 是一种 mGluR6 激动剂，它使 ON 双极细胞持续超极化，从而有效地将 ON 通路锁定在“关闭”状态，阻止了对光诱导的谷氨酸减少的任何响应。OFF 通路不受影响，因为 L-AP4 对离子型谷氨酸受体没有作用。**\n    - 该选项准确描述了对照响应和施加药物后的响应，以及正确的药理学原理。\n\n*   **B. 对照组描述正确。施加 L-AP4 后的描述：它错误地声称 OFF 通路的响应被消除，并错误地将 L-AP4 的作用归因于阻断离子型受体。**\n\n*   **C. 对照组描述错误；它颠倒了 ON 和 OFF 细胞的作用。施加 L-AP4 后的描述也错误地声称两条通路都被消除。**\n\n*   **D. 对照组描述正确。施加 L-AP4 后的描述错误地声称两条通路的作用被互换，这在药理学上是不合理的。**\n\n因此，选项 A 是唯一与既定原理一致的预测。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了ON和OFF通路的生物学基础后，下一步是使用数学模型来定量描述中央-周边感受野。本练习  将引导您使用经典的高斯差分（DoG）模型，并从一个可测量的实验数据（即引起最大响应的光斑半径 $a^*$）中，通过微积分推导出感受野的一个核心参数：中央与周边拮抗的相对强度。这个过程完美地展示了如何将理论模型与实验观察联系起来。",
            "id": "5004856",
            "problem": "一个中心兴奋型视网膜神经节细胞 (on-center retinal ganglion cell, RGC) 被建模为一个线性空间滤波器，其感受野可以很好地用高斯差分 (Difference-of-Gaussians, DoG) 模型来描述。空间敏感度核函数为\n$$\nK(r) \\;=\\; K_{c}\\,G(r;\\sigma_{c}) \\;-\\; K_{s}\\,G(r;\\sigma_{s}),\n$$\n其中 $K_{c}>0$ 和 $K_{s}>0$ 分别是中心和环绕的增益，$r$ 是距感受野中心的径向距离，$G(r;\\sigma)$ 是一个归一化的、各向同性的二维高斯函数，由下式给出\n$$\nG(r;\\sigma)\\;=\\;\\frac{1}{2\\pi\\sigma^{2}}\\exp\\!\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right).\n$$\n一个半径为 $a$、相对于背景具有正对比度 $S$ 的稳定、空间均匀的亮圆形光斑，其中心对准感受野的中心。在线性滤波器近似下，瞬时响应幅度 $R(a)$ 与核函数 $K(r)$ 在光斑面积上的空间积分成正比：\n$$\nR(a)\\;=\\;S\\int_{r\\le a} K(r)\\,dA.\n$$\n实验上，光斑大小的调谐曲线 $R(a)$ 在半径 $a^{\\ast}$ 处呈现一个单峰，并在更大半径时减小，这与拮抗性的中心-环绕相互作用一致。\n\n给定测得的峰值半径 $a^{\\ast}=120\\,\\mu\\mathrm{m}$，以及已知的感受野尺度 $\\sigma_{c}=50\\,\\mu\\mathrm{m}$ 和 $\\sigma_{s}=150\\,\\mu\\mathrm{m}$，从上述定义出发：\n- 利用在 $a^{\\ast}>0$ 处存在局部最大值的必要条件，推导环绕增益与中心增益之比 $K_{s}/K_{c}$ 关于 $a^{\\ast}$、$\\sigma_{c}$ 和 $\\sigma_{s}$ 的解析表达式。\n- 将此比率用作一个定量的中心-环绕平衡度量，记为 $B\\equiv K_{s}/K_{c}$，并根据给定参数计算其数值。\n\n将平衡度量的数值答案四舍五入到四位有效数字。将平衡度量表示为一个无量纲数（无单位）。",
            "solution": "该问题是有效的，因为它科学上基于一个标准的神经生物学模型，数学上是适定的，并且所有必要的参数都已提供。\n\n中心兴奋型视网膜神经节细胞对半径为 $a$、对比度为 $S$ 的圆形光斑的瞬时响应幅度 $R(a)$，由感受野核函数 $K(r)$ 在光斑面积上的积分给出：\n$$\nR(a) = S \\int_{r \\le a} K(r) \\, dA\n$$\n核函数 $K(r)$ 是一个高斯差分 (DoG) 函数：\n$$\nK(r) = K_{c}G(r;\\sigma_{c}) - K_{s}G(r;\\sigma_{s})\n$$\n其中 $G(r;\\sigma)$ 是一个归一化的二维高斯函数：\n$$\nG(r;\\sigma) = \\frac{1}{2\\pi\\sigma^{2}}\\exp\\left(-\\frac{r^{2}}{2\\sigma^{2}}\\right)\n$$\n积分是在半径为 $a$ 的圆盘上进行的。在极坐标系中，面积微元是 $dA = r' dr' d\\theta$。由于核函数的径向对称性，对角度 $\\theta$ 从 $0$ 到 $2\\pi$ 的积分会产生一个 $2\\pi$ 的因子。\n$$\nR(a) = S \\int_0^a \\left( K_c G(r';\\sigma_c) - K_s G(r';\\sigma_s) \\right) 2\\pi r' dr'\n$$\n代入 $G(r';\\sigma)$ 的表达式：\n$$\nR(a) = S \\!\\int_0^a \\left[ K_c \\frac{1}{2\\pi\\sigma_c^2}\\exp\\left(-\\frac{r'^2}{2\\sigma_c^2}\\right) - K_s \\frac{1}{2\\pi\\sigma_s^2}\\exp\\left(-\\frac{r'^2}{2\\sigma_s^2}\\right) \\right] 2\\pi r' dr'\n$$\n$$\nR(a) = S \\int_0^a \\left[ \\frac{K_c}{\\sigma_c^2} \\exp\\left(-\\frac{r'^2}{2\\sigma_c^2}\\right) - \\frac{K_s}{\\sigma_s^2} \\exp\\left(-\\frac{r'^2}{2\\sigma_s^2}\\right) \\right] r' dr'\n$$\n这个积分可以逐项求解。对于一个通用高斯项，积分为：\n$$\n\\int_0^a \\frac{1}{\\sigma^2} \\exp\\left(-\\frac{r'^2}{2\\sigma^2}\\right) r' dr'\n$$\n使用换元法 $u = -\\frac{r'^2}{2\\sigma^2}$，我们有 $du = -\\frac{r'}{\\sigma^2} dr'$。积分变为：\n$$\n\\int_0^{-a^2/(2\\sigma^2)} (-du) = [-u]_0^{-a^2/(2\\sigma^2)} = -\\left(-\\frac{a^2}{2\\sigma^2}\\right) - (-0) = \\frac{a^2}{2\\sigma^2}\n$$\n这似乎是错的。让我们重新计算。\n$$\n\\int_0^a \\frac{r'}{\\sigma^2} \\exp\\left(-\\frac{r'^2}{2\\sigma^2}\\right) dr' = \\left[ -\\exp\\left(-\\frac{r'^2}{2\\sigma^2}\\right) \\right]_0^a = -\\exp\\left(-\\frac{a^2}{2\\sigma^2}\\right) - (-\\exp(0)) = 1 - \\exp\\left(-\\frac{a^2}{2\\sigma^2}\\right)\n$$\n将此结果应用于 $R(a)$ 表达式中的每一项：\n$$\nR(a) = S \\left[ K_c \\left(1 - \\exp\\left(-\\frac{a^2}{2\\sigma_c^2}\\right)\\right) - K_s \\left(1 - \\exp\\left(-\\frac{a^2}{2\\sigma_s^2}\\right)\\right) \\right]\n$$\n为了找到使响应最大化的半径 $a^{\\ast}$，我们必须求 $R(a)$ 关于 $a$ 的导数，并令其为零。\n$$\n\\frac{dR}{da} = S \\frac{d}{da} \\left[ K_c - K_c\\exp\\left(-\\frac{a^2}{2\\sigma_c^2}\\right) - K_s + K_s\\exp\\left(-\\frac{a^2}{2\\sigma_s^2}\\right) \\right]\n$$\n$$\n\\frac{dR}{da} = S \\left[ -K_c \\exp\\left(-\\frac{a^2}{2\\sigma_c^2}\\right)\\left(-\\frac{2a}{2\\sigma_c^2}\\right) + K_s \\exp\\left(-\\frac{a^2}{2\\sigma_s^2}\\right)\\left(-\\frac{2a}{2\\sigma_s^2}\\right) \\right]\n$$\n$$\n\\frac{dR}{da} = S \\cdot a \\left[ \\frac{K_c}{\\sigma_c^2}\\exp\\left(-\\frac{a^2}{2\\sigma_c^2}\\right) - \\frac{K_s}{\\sigma_s^2}\\exp\\left(-\\frac{a^2}{2\\sigma_s^2}\\right) \\right]\n$$\n另外，根据微积分基本定理，$\\frac{d}{da} \\int_0^a f(x)dx=f(a)$。在这里，$R(a) = S \\int_0^a K(r') 2\\pi r' dr'$。因此，$\\frac{dR}{da} = S \\cdot K(a) \\cdot 2\\pi a$。在 $a = a^{\\ast} > 0$ 处取最大值的条件是 $\\frac{dR}{da}|_{a=a^{\\ast}} = 0$，这意味着 $K(a^{\\ast}) = 0$。\n$$\nK(a^{\\ast}) = K_{c}G(a^{\\ast};\\sigma_{c}) - K_{s}G(a^{\\ast};\\sigma_{s}) = 0\n$$\n$$\nK_{c} \\frac{1}{2\\pi\\sigma_{c}^{2}}\\exp\\left(-\\frac{(a^{\\ast})^{2}}{2\\sigma_{c}^{2}}\\right) = K_{s} \\frac{1}{2\\pi\\sigma_{s}^{2}}\\exp\\left(-\\frac{(a^{\\ast})^{2}}{2\\sigma_{s}^{2}}\\right)\n$$\n我们现在可以求解增益之比 $B \\equiv K_s/K_c$。\n$$\n\\frac{K_s}{K_c} = \\frac{\\frac{1}{\\sigma_c^2}\\exp\\left(-\\frac{(a^{\\ast})^2}{2\\sigma_c^2}\\right)}{\\frac{1}{\\sigma_s^2}\\exp\\left(-\\frac{(a^{\\ast})^2}{2\\sigma_s^2}\\right)}\n$$\n$$\nB = \\frac{K_s}{K_c} = \\frac{\\sigma_s^2}{\\sigma_c^2} \\exp\\left(-\\frac{(a^{\\ast})^2}{2\\sigma_c^2} + \\frac{(a^{\\ast})^2}{2\\sigma_s^2}\\right)\n$$\n这就给出了平衡度量 $B$ 的解析表达式：\n$$\nB = \\left(\\frac{\\sigma_s}{\\sigma_c}\\right)^2 \\exp\\left( \\frac{(a^{\\ast})^2}{2} \\left(\\frac{1}{\\sigma_s^2} - \\frac{1}{\\sigma_c^2}\\right) \\right)\n$$\n现在我们用给定的参数数值计算这个表达式：$a^{\\ast}=120\\,\\mu\\mathrm{m}$，$\\sigma_{c}=50\\,\\mu\\mathrm{m}$，以及 $\\sigma_{s}=150\\,\\mu\\mathrm{m}$。单位是一致的，将会抵消，所以我们可以直接使用数值。\n标准差之比为：\n$$\n\\frac{\\sigma_s}{\\sigma_c} = \\frac{150}{50} = 3\n$$\n该比率的平方为：\n$$\n\\left(\\frac{\\sigma_s}{\\sigma_c}\\right)^2 = 3^2 = 9\n$$\n指数项为：\n$$\n\\frac{(a^{\\ast})^2}{2} \\left(\\frac{1}{\\sigma_s^2} - \\frac{1}{\\sigma_c^2}\\right) = \\frac{120^2}{2} \\left(\\frac{1}{150^2} - \\frac{1}{50^2}\\right)\n$$\n$$\n= \\frac{14400}{2} \\left(\\frac{1}{22500} - \\frac{1}{2500}\\right) = 7200 \\left(\\frac{1 - 9}{22500}\\right)\n$$\n$$\n= 7200 \\left(\\frac{-8}{22500}\\right) = \\frac{72 \\times (-8)}{225} = \\frac{8 \\times 9 \\times (-8)}{25 \\times 9} = -\\frac{64}{25} = -2.56\n$$\n将这些值代回 $B$ 的表达式中：\n$$\nB = 9 \\exp(-2.56)\n$$\n现在，我们计算其数值：\n$$\nB \\approx 9 \\times 0.0773047... \\approx 0.6957423...\n$$\n四舍五入到四位有效数字，平衡度量为 $B \\approx 0.6957$。\n这个结果 $B  1$ 表明，中心高斯核的峰值振幅（其与 $K_c/\\sigma_c^2$ 成比例）大于环绕高斯核的峰值振幅（$K_s/\\sigma_s^2$）。中心的总积分强度 $K_c$ 也大于环绕的总积分强度 $K_s$，这是中心兴奋型细胞对一个大的均匀亮刺激产生净兴奋性响应所必需的。",
            "answer": "$$\\boxed{0.6957}$$"
        },
        {
            "introduction": "最后一个练习是一个更高级的综合性课题，它将我们带到现代计算神经科学研究的前沿。前面的练习分析了模型的属性，而这个练习  解决了“逆问题”：如何从充满噪声的神经活动数据中精确地估计出感受野模型的参数。通过构建一个包含正则化策略的广义线性模型（GLM），您将了解到科学家们是如何建立稳健的神经编码模型，并以此来揭示大脑处理信息的复杂机制。",
            "id": "5004891",
            "problem": "你需要为一个以高斯差分（DoG）滤波器为模型的中央-环绕感受野，在广义线性模型（GLM）框架下，形式化并实现一种参数估计策略。该策略使用空间平滑正则化和基于生物学动机的尺度参数先验。最终目标是编写一个程序，该程序能够为指定的测试用例模拟数据，使用最大似然估计（MLE）和最大后验（MAP）估计来拟合参数，并报告与MLE相比，正则化的MAP拟合是否改善了对中心和环绕尺度的恢复效果。\n\n起点定义和事实：\n- 具有泊松观测模型的广义线性模型（GLM）定义如下。给定时间点$t$的刺激向量$\\mathbf{s}_t \\in \\mathbb{R}^{n}$，一个线性滤波器$\\mathbf{k} \\in \\mathbb{R}^{n}$，以及一个偏置$b \\in \\mathbb{R}$，条件强度为\n$$\n\\lambda_t = \\exp\\left(b + \\mathbf{k}^{\\top}\\mathbf{s}_t\\right),\n$$\n观测到的脉冲计数$y_t$是均值为$\\lambda_t$的泊松随机变量的一个实现。\n- 用于中央-环绕编码的高斯差分（DoG）滤波器在二维网格上定义为一个窄高斯函数和一个更宽的高斯函数之间的加权差。令$G(\\sigma)$表示在一个方形网格上离散化并归一化为单位和的各向同性二维高斯函数，其尺度参数为$\\sigma0$。对于一个中心ON型神经节细胞，其空间滤波器为\n$$\n\\mathbf{k}_{\\text{on}} = \\alpha \\, G(\\sigma_c) - \\beta \\, G(\\sigma_s),\n$$\n其中$\\alpha0$，$\\beta0$，$\\sigma_c0$，$\\sigma_s  \\sigma_c$。对于一个中心OFF型神经节细胞，其空间滤波器为\n$$\n\\mathbf{k}_{\\text{off}} = -\\alpha \\, G(\\sigma_c) + \\beta \\, G(\\sigma_s),\n$$\n对$\\alpha$、$\\beta$、$\\sigma_c$和$\\sigma_s$有相同的约束。\n- 滤波器的空间平滑性可以通过惩罚$\\mathbf{k}$在整个网格上的离散梯度平方范数来强制实现。令$\\nabla_x \\mathbf{k}$和$\\nabla_y \\mathbf{k}$表示沿两个网格轴的前向有限差分；平滑度泛函为\n$$\n\\Omega_{\\text{smooth}}(\\mathbf{k}) = \\sum_{i,j} \\left( (\\nabla_x \\mathbf{k})_{i,j}^2 + (\\nabla_y \\mathbf{k})_{i,j}^2 \\right)\n$$\n- 对于正尺度参数，一个符合生物学动机的选择是对数正态先验，它反映了正性和乘性变异性。如果$\\log \\sigma$服从均值为$\\mu$、方差为$\\tau^2$的正态分布，那么对于$\\sigma0$，负对数先验（最多相差一个加性常数）为\n$$\n\\phi_{\\text{logN}}(\\sigma; \\mu, \\tau) = \\log \\sigma + \\frac{(\\log \\sigma - \\mu)^2}{2 \\tau^2}\n$$\n\n你的任务：\n1. 实现一个模拟器，给定一个大小为$N \\times N$的方形网格，生成一个刺激序列$\\{\\mathbf{s}_t\\}_{t=1}^{T}$，其中每个$\\mathbf{s}_t \\in \\mathbb{R}^{N^2}$是通过将一个由独立标准正态变量组成的网格扁平化而形成的。给定一个DoG参数集和一个偏置$b$，生成均值为$\\lambda_t = \\exp(b + \\mathbf{k}^{\\top}\\mathbf{s}_t)$的泊松脉冲计数$y_t$。\n2. 为已知的极性（中心ON型或中心OFF型），实现两个$(\\alpha, \\beta, \\sigma_c, \\sigma_s, b)$的估计器：\n   - 最大似然估计（MLE）估计器，最小化负对数似然\n   $$\n   \\mathcal{L}_{\\text{NLL}}(\\theta) = \\sum_{t=1}^{T} \\left[ \\exp\\left(b + \\mathbf{k}(\\theta)^{\\top}\\mathbf{s}_t\\right) - y_t \\left(b + \\mathbf{k}(\\theta)^{\\top}\\mathbf{s}_t\\right) \\right],\n   $$\n   其中$\\theta$表示参数向量，$\\mathbf{k}(\\theta)$是根据$(\\alpha, \\beta, \\sigma_c, \\sigma_s)$和已知极性构建的DoG滤波器。\n   - 最大后验（MAP）估计器，最小化负对数似然和正则化项之和\n   $$\n   \\mathcal{J}_{\\text{MAP}}(\\theta) = \\mathcal{L}_{\\text{NLL}}(\\theta) + \\lambda_{\\text{prior}} \\left[\\phi_{\\text{logN}}(\\sigma_c; \\mu_c, \\tau_c) + \\phi_{\\text{logN}}(\\sigma_s; \\mu_s, \\tau_s)\\right] + \\lambda_{\\text{smooth}} \\, \\Omega_{\\text{smooth}}\\left(\\mathbf{k}(\\theta)\\right),\n   $$\n   其中$\\lambda_{\\text{prior}}$和$\\lambda_{\\text{smooth}}$是非负标量。\n3. 通过使用无约束变量和适当的变换来强制$\\alpha0$、$\\beta0$、$\\sigma_c0$和$\\sigma_s\\sigma_c$。一个有效的方法是对$\\log \\alpha$、$\\log \\beta$、$\\log \\sigma_c$和一个自由变量进行优化，该自由变量的平滑变换确保$\\log \\sigma_s - \\log \\sigma_c  0$；用这些无约束参数来表示$\\sigma_s$，从而使不等式总是成立。\n4. 对于下面测试套件中的每个测试用例，同时使用MLE和MAP拟合参数（从基于数据的相同初始化开始，而不是真实值），计算恢复的尺度$(\\sigma_c, \\sigma_s)$相对于已知的真实尺度的均方根误差（RMSE），并返回一个布尔值，指示在该用例中，MAP估计器是否比MLE估计器获得了更低的RMSE。\n\n网格和刺激规范：\n- 使用一个大小为$N=19$、单位间距的方形网格。在此网格上构建$G(\\sigma)$为$G_{i,j}(\\sigma) = \\exp\\left(-\\frac{x_i^2 + y_j^2}{2 \\sigma^2}\\right)$，并进行归一化以使$\\sum_{i,j} G_{i,j}(\\sigma) = 1$，其中$x_i$和$y_j$索引中心化的网格坐标。\n\n正则化的超参数：\n- 使用$\\lambda_{\\text{smooth}} = 0.01$。\n- 对$\\sigma_c$和$\\sigma_s$使用对数正态先验，其中$\\mu_c = \\log(1.2)$，$\\mu_s = \\log(3.6)$，$\\tau_c = 0.35$，$\\tau_s = 0.35$，以及$\\lambda_{\\text{prior}} = 100$。\n\n测试套件：\n- 用例1（理想情况）：中心ON型神经节细胞，$T=2000$，真实参数$\\alpha=1.0$，$\\beta=0.8$，$\\sigma_c=1.2$，$\\sigma_s=3.6$，$b=-2.0$。\n- 用例2（低基线边界条件）：中心OFF型神经节细胞，$T=2000$，真实参数$\\alpha=0.9$，$\\beta=1.2$，$\\sigma_c=0.8$，$\\sigma_s=2.4$，$b=-3.0$。\n- 用例3（样本较少的边缘情况）：中心ON型神经节细胞，$T=500$，真实参数$\\alpha=0.7$，$\\beta=0.7$，$\\sigma_c=1.8$，$\\sigma_s=5.4$，$b=-2.5$。\n\n计算和报告：\n- 对于每个用例，在从数据获得的共同起始点上初始化优化（例如，使用$\\log \\alpha = 0$，$\\log \\beta = 0$，$\\log \\sigma_c = \\mu_c$，一个能使$\\log \\sigma_s - \\log \\sigma_c \\approx \\mu_s - \\mu_c$的变换，以及初始化为$\\log(\\bar{y}+10^{-8})$的$b$，其中$\\bar{y}$是观测到的脉冲计数的均值）。在同一用例中，为MLE和MAP拟合使用相同的初始化。\n- 计算$(\\sigma_c, \\sigma_s)$的RMSE如下：\n$$\n\\text{RMSE} = \\sqrt{ \\frac{\\left(\\hat{\\sigma}_c - \\sigma_c^{\\ast}\\right)^2 + \\left(\\hat{\\sigma}_s - \\sigma_s^{\\ast}\\right)^2}{2} },\n$$\n其中$\\sigma_c^{\\ast}$和$\\sigma_s^{\\ast}$是真实尺度，帽子符号表示估计值。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例对应一个布尔值，按上述用例的顺序排列。例如：\"[True,False,True]\"。\n\n本问题中的所有量都是无量纲的，因此不需要单位转换。在任何指数或对数计算中，请确保数值稳定性。",
            "solution": "该问题要求实现并比较最大似然估计（MLE）和最大后验估计（MAP）在一个描述视网膜神经节细胞响应的广义线性模型（GLM）中的应用。该细胞的感受野被建模为高斯差分（DoG）滤波器。比较的依据是根据模拟数据恢复真实滤波器尺度参数的准确性。\n\n该模型的核心是一个泊松GLM。在一个小时间窗$t$内的脉冲计数$y_t$是从一个均值为$\\lambda_t$的泊松分布中抽取的，$\\lambda_t$是条件强度或发放率。\n$$\ny_t \\sim \\text{Poisson}(\\lambda_t)\n$$\n发放率$\\lambda_t$由刺激向量$\\mathbf{s}_t \\in \\mathbb{R}^{n}$和线性滤波器$\\mathbf{k} \\in \\mathbb{R}^{n}$的点积决定，该点积通过一个指数非线性函数。发放率的完整表达式为：\n$$\n\\lambda_t = \\exp\\left(b + \\mathbf{k}^{\\top}\\mathbf{s}_t\\right)\n$$\n其中$b$是一个标量偏置项。\n\n线性滤波器$\\mathbf{k}$代表细胞的空间感受野，被建模为高斯差分（DoG）。一个二维各向同性高斯函数$G(\\sigma)$在一个大小为$N \\times N$的方形网格上构建，其尺度（标准差）为$\\sigma$。这个离散的高斯函数被归一化以使其和为一。DoG滤波器是一个窄的“中心”高斯函数（尺度为$\\sigma_c$）和一个更宽的“环绕”高斯函数（尺度为$\\sigma_s$）的加权和。对于一个中心ON型细胞，滤波器为：\n$$\n\\mathbf{k}_{\\text{on}} = \\alpha \\, G(\\sigma_c) - \\beta \\, G(\\sigma_s)\n$$\n对于一个中心OFF型细胞，符号反转：\n$$\n\\mathbf{k}_{\\text{off}} = -\\alpha \\, G(\\sigma_c) + \\beta \\, G(\\sigma_s)\n$$\n模型参数为$\\theta = (\\alpha, \\beta, \\sigma_c, \\sigma_s, b)$，受限于$\\alpha0$, $\\beta0$, $\\sigma_c0$, 和$\\sigma_s  \\sigma_c$的约束。\n\n为了从刺激数据集$\\{\\mathbf{s}_t\\}_{t=1}^T$和脉冲计数数据集$\\{y_t\\}_{t=1}^T$中估计参数$\\theta$，我们最小化一个目标函数。\n\n对于最大似然估计（MLE），目标是给定参数下数据的负对数似然（NLL）。对于泊松GLM，这表示为：\n$$\n\\mathcal{L}_{\\text{NLL}}(\\theta) = \\sum_{t=1}^{T} \\left[ \\lambda_t(\\theta) - y_t \\log(\\lambda_t(\\theta)) \\right] = \\sum_{t=1}^{T} \\left[ \\exp\\left(b + \\mathbf{k}(\\theta)^{\\top}\\mathbf{s}_t\\right) - y_t \\left(b + \\mathbf{k}(\\theta)^{\\top}\\mathbf{s}_t\\right) \\right]\n$$\n\n对于最大后验（MAP）估计，我们在NLL上添加正则化项，这些项对应于关于参数的先验信念。MAP的目标函数是：\n$$\n\\mathcal{J}_{\\text{MAP}}(\\theta) = \\mathcal{L}_{\\text{NLL}}(\\theta) + P(\\theta)\n$$\n其中$P(\\theta)$是总惩罚项。在这个问题中，使用了两种惩罚。首先，对滤波器$\\mathbf{k}$施加空间平滑度惩罚，以鼓励滤波器中相邻像素具有相似的值：\n$$\n\\Omega_{\\text{smooth}}(\\mathbf{k}) = \\lambda_{\\text{smooth}} \\sum_{i,j} \\left( (\\nabla_x \\mathbf{k})_{i,j}^2 + (\\nabla_y \\mathbf{k})_{i,j}^2 \\right)\n$$\n其中$\\nabla_x$和$\\nabla_y$是离散梯度算子（有限差分），$\\lambda_{\\text{smooth}}=0.01$是一个控制此正则化强度的超参数。\n\n其次，对正尺度参数$\\sigma_c$和$\\sigma_s$施加了符合生物学动机的对数正态先验。单个尺度参数$\\sigma$的负对数先验为：\n$$\n\\phi_{\\text{logN}}(\\sigma; \\mu, \\tau) = \\log \\sigma + \\frac{(\\log \\sigma - \\mu)^2}{2 \\tau^2}\n$$\n总的先验惩罚是$\\sigma_c$和$\\sigma_s$的这些项之和，乘以$\\lambda_{\\text{prior}}=100$：\n$$\nP(\\theta) = \\lambda_{\\text{prior}} \\left[\\phi_{\\text{logN}}(\\sigma_c; \\mu_c, \\tau_c) + \\phi_{\\text{logN}}(\\sigma_s; \\mu_s, \\tau_s)\\right] + \\lambda_{\\text{smooth}} \\, \\Omega_{\\text{smooth}}\\left(\\mathbf{k}(\\theta)\\right)\n$$\n先验均值为$\\mu_c = \\log(1.2)$，$\\mu_s = \\log(3.6)$，方差为$\\tau_c^2=\\tau_s^2=0.35^2$。\n\n优化过程必须遵守参数约束。处理此问题的一个标准方法是使用无约束变量对模型进行重参数化。我们定义一个新的参数向量$\\mathbf{p} = (p_0, p_1, p_2, p_3, p_4)$，并通过变换将其与原始参数$\\theta$关联起来，从而自动满足约束：\n- $\\alpha = \\exp(p_0)$  (确保 $\\alpha  0$)\n- $\\beta = \\exp(p_1)$  (确保 $\\beta  0$)\n- $\\sigma_c = \\exp(p_2)$ (确保 $\\sigma_c  0$)\n- $\\sigma_s = \\sigma_c + \\exp(p_3) = \\exp(p_2) + \\exp(p_3)$ (确保 $\\sigma_s  \\sigma_c  0$)\n- $b = p_4$ (无约束)\n优化是在这个无约束向量$\\mathbf{p}$上使用数值优化器（`scipy.optimize.minimize`及`BFGS`算法）进行的。目标函数$\\mathcal{L}_{\\text{NLL}}$和$\\mathcal{J}_{\\text{MAP}}$被表示为$\\mathbf{p}$的函数。\n\n对于每个测试用例，实现按以下步骤进行：\n1.  **数据模拟**：生成一个包含$T$个样本的数据集。对于每个样本$t$，通过将一个$19 \\times 19$的独立标准正态随机变量网格扁平化来创建刺激$\\mathbf{s}_t$。根据真实参数构建真实滤波器$\\mathbf{k}^*$。然后从均值为$\\exp(b^* + (\\mathbf{k}^*)^{\\top}\\mathbf{s}_t)$的泊松分布中抽取脉冲计数$y_t$。\n2.  **初始化**：为MLE和MAP优化确定一个共同的起始点。根据问题的规范，我们设置$\\alpha=1$和$\\beta=1$的初始值。尺度参数根据先验均值进行初始化：$\\sigma_c^{\\text{init}} = \\exp(\\mu_c) = 1.2$ 和 $\\sigma_s^{\\text{init}} = \\exp(\\mu_s) = 3.6$。偏置$b$根据观测到的平均脉冲计数进行初始化：$b^{\\text{init}} = \\log(\\bar{y} + 10^{-8})$。然后将这些初始值转换到无约束空间以获得$\\mathbf{p}_{\\text{init}}$。\n3.  **优化**：从$\\mathbf{p}_{\\text{init}}$开始，最小化MLE和MAP目标函数，以找到估计的参数向量$\\hat{\\mathbf{p}}_{\\text{MLE}}$和$\\hat{\\mathbf{p}}_{\\text{MAP}}$。然后将这些向量转换回原始参数空间，以获得$\\hat{\\theta}_{\\text{MLE}}$和$\\hat{\\theta}_{\\text{MAP}}$。\n4.  **评估**：通过计算估计尺度$(\\hat{\\sigma}_c, \\hat{\\sigma}_s)$与真实尺度$(\\sigma_c^*, \\sigma_s^*)$之间的均方根误差（RMSE）来量化每个估计器的性能：\n    $$\n    \\text{RMSE} = \\sqrt{ \\frac{\\left(\\hat{\\sigma}_c - \\sigma_c^{\\ast}\\right)^2 + \\left(\\hat{\\sigma}_s - \\sigma_s^{\\ast}\\right)^2}{2} }\n    $$\n    最后，记录一个布尔值，指示MAP估计器是否比MLE估计器获得了更低的RMSE。对所有测试用例重复此过程。预期在先验的引导下，MAP估计器将更具鲁棒性，尤其是在数据较少的情况下，并能产生更准确的参数恢复结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.special import xlogy\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and estimation for all test cases.\n    \"\"\"\n\n    # Grid and stimulus specification\n    N = 19\n    GRID_COORDS = np.arange(N) - (N - 1) / 2\n    X_GRID, Y_GRID = np.meshgrid(GRID_COORDS, GRID_COORDS)\n    \n    # Hyperparameters for regularization\n    HYPERPARAMETERS = {\n        'lambda_smooth': 0.01,\n        'lambda_prior': 100.0,\n        'mu_c': np.log(1.2),\n        'tau_c': 0.35,\n        'mu_s': np.log(3.6),\n        'tau_s': 0.35,\n    }\n\n    # Test suite\n    TEST_CASES = [\n        {\n            'name': 'Case 1',\n            'polarity': 'on',\n            'T': 2000,\n            'true_params': {'alpha': 1.0, 'beta': 0.8, 'sigma_c': 1.2, 'sigma_s': 3.6, 'b': -2.0}\n        },\n        {\n            'name': 'Case 2',\n            'polarity': 'off',\n            'T': 2000,\n            'true_params': {'alpha': 0.9, 'beta': 1.2, 'sigma_c': 0.8, 'sigma_s': 2.4, 'b': -3.0}\n        },\n        {\n            'name': 'Case 3',\n            'polarity': 'on',\n            'T': 500,\n            'true_params': {'alpha': 0.7, 'beta': 0.7, 'sigma_c': 1.8, 'sigma_s': 5.4, 'b': -2.5}\n        },\n    ]\n\n    def get_gaussian(sigma):\n        \"\"\"Generates a normalized 2D Gaussian filter on the grid.\"\"\"\n        if sigma = 1e-6: # Avoid division by zero, return a delta function centered\n            g = np.zeros((N, N))\n            g[N // 2, N // 2] = 1.0\n            return g.flatten()\n        \n        g = np.exp(-(X_GRID**2 + Y_GRID**2) / (2 * sigma**2))\n        g_sum = np.sum(g)\n        if g_sum > 1e-9:\n            g /= g_sum\n        else: # Handle case of extremely small sigma leading to underflow\n            g.fill(0)\n            g[N // 2, N // 2] = 1.0\n        return g.flatten()\n\n    def unpack_params(p):\n        \"\"\"Transforms unconstrained optimization variables to model parameters.\"\"\"\n        p_alpha, p_beta, p_sigma_c, p_sigma_s_diff, p_b = p\n        alpha = np.exp(p_alpha)\n        beta = np.exp(p_beta)\n        sigma_c = np.exp(p_sigma_c)\n        sigma_s = sigma_c + np.exp(p_sigma_s_diff)\n        b = p_b\n        return {'alpha': alpha, 'beta': beta, 'sigma_c': sigma_c, 'sigma_s': sigma_s, 'b': b}\n\n    def get_dog_filter(params, polarity):\n        \"\"\"Constructs the DoG filter from parameters.\"\"\"\n        g_c = get_gaussian(params['sigma_c'])\n        g_s = get_gaussian(params['sigma_s'])\n        if polarity == 'on':\n            k = params['alpha'] * g_c - params['beta'] * g_s\n        else: # off\n            k = -params['alpha'] * g_c + params['beta'] * g_s\n        return k\n\n    def simulate_data(true_params, polarity, T, seed):\n        \"\"\"Generates stimuli and Poisson spike counts.\"\"\"\n        rng = np.random.default_rng(seed)\n        stimuli = rng.standard_normal((T, N*N))\n        \n        k_true = get_dog_filter(true_params, polarity)\n        b_true = true_params['b']\n        \n        rates = np.exp(b_true + stimuli @ k_true)\n        spikes = rng.poisson(rates)\n        return stimuli, spikes\n\n    def nll_objective(p, stimuli, spikes, polarity):\n        \"\"\"Negative log-likelihood for the Poisson GLM.\"\"\"\n        params = unpack_params(p)\n        k = get_dog_filter(params, polarity)\n        b = params['b']\n\n        lin_pred = b + stimuli @ k\n        \n        # The problem gives sum(exp(z) - y*z), which is -log_lik.\n        nll = np.sum(np.exp(lin_pred) - spikes * lin_pred)\n        return nll\n\n    def map_objective(p, stimuli, spikes, polarity):\n        \"\"\"MAP objective function (NLL + priors).\"\"\"\n        # Negative log-likelihood\n        nll = nll_objective(p, stimuli, spikes, polarity)\n\n        # Unpack params for regularization terms\n        params = unpack_params(p)\n        sigma_c = params['sigma_c']\n        sigma_s = params['sigma_s']\n        k = get_dog_filter(params, polarity)\n\n        # Log-normal prior penalty\n        log_sigma_c = np.log(sigma_c)\n        log_sigma_s = np.log(sigma_s)\n\n        phi_c = log_sigma_c + (log_sigma_c - HYPERPARAMETERS['mu_c'])**2 / (2 * HYPERPARAMETERS['tau_c']**2)\n        phi_s = log_sigma_s + (log_sigma_s - HYPERPARAMETERS['mu_s'])**2 / (2 * HYPERPARAMETERS['tau_s']**2)\n        prior_penalty = HYPERPARAMETERS['lambda_prior'] * (phi_c + phi_s)\n        \n        # Smoothness penalty\n        k_2d = k.reshape((N, N))\n        grad_x_sq = np.sum(np.diff(k_2d, axis=1)**2)\n        grad_y_sq = np.sum(np.diff(k_2d, axis=0)**2)\n        smoothness_penalty = HYPERPARAMETERS['lambda_smooth'] * (grad_x_sq + grad_y_sq)\n\n        return nll + prior_penalty + smoothness_penalty\n\n    def calculate_rmse(est_scales, true_scales):\n        \"\"\"Calculates RMSE for sigma_c and sigma_s.\"\"\"\n        est_sigma_c, est_sigma_s = est_scales\n        true_sigma_c, true_sigma_s = true_scales\n        rmse = np.sqrt(\n            ((est_sigma_c - true_sigma_c)**2 + (est_sigma_s - true_sigma_s)**2) / 2\n        )\n        return rmse\n\n    results = []\n    for i, case in enumerate(TEST_CASES):\n        # 1. Simulate data\n        stimuli, spikes = simulate_data(case['true_params'], case['polarity'], case['T'], seed=i)\n\n        # 2. Define initial parameters for optimization\n        b_init = np.log(np.mean(spikes) + 1e-8)\n        sigma_c_init = np.exp(HYPERPARAMETERS['mu_c']) # 1.2\n        sigma_s_init = np.exp(HYPERPARAMETERS['mu_s']) # 3.6\n\n        p_init = np.array([\n            np.log(1.0),                               # p_alpha\n            np.log(1.0),                               # p_beta\n            np.log(sigma_c_init),                      # p_sigma_c\n            np.log(sigma_s_init - sigma_c_init),       # p_sigma_s_diff\n            b_init                                     # p_b\n        ])\n\n        # 3. Fit MLE model\n        mle_res = minimize(\n            nll_objective, p_init,\n            args=(stimuli, spikes, case['polarity']),\n            method='BFGS', options={'maxiter': 500}\n        )\n        mle_params_est = unpack_params(mle_res.x)\n\n        # 4. Fit MAP model\n        map_res = minimize(\n            map_objective, p_init,\n            args=(stimuli, spikes, case['polarity']),\n            method='BFGS', options={'maxiter': 500}\n        )\n        map_params_est = unpack_params(map_res.x)\n\n        # 5. Compare RMSE\n        true_scales = (case['true_params']['sigma_c'], case['true_params']['sigma_s'])\n        \n        mle_scales_est = (mle_params_est['sigma_c'], mle_params_est['sigma_s'])\n        rmse_mle = calculate_rmse(mle_scales_est, true_scales)\n        \n        map_scales_est = (map_params_est['sigma_c'], map_params_est['sigma_s'])\n        rmse_map = calculate_rmse(map_scales_est, true_scales)\n        \n        results.append(rmse_map  rmse_mle)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}