{
    "hands_on_practices": [
        {
            "introduction": "神经回路并非细胞的随机集合，而是精密的计算设备。本练习将揭示经典侧向抑制网络所执行的基础计算。通过确定特定的连接权重，你将证明一个简单的局部布线模式如何能够实现离散的二阶导数算子——这是增强感觉信息中对比度和检测边缘的关键工具。",
            "id": "5029209",
            "problem": "考虑一个由整数 $i \\in \\mathbb{Z}$ 索引的一维感受器阵列，其输入活动为 $x_i$。一个下游线性网络通过对加权的自身输入和由侧向相互作用引起的加权最近邻输入求和，产生输出 $y_i$。假设该网络是线性的、平移不变的，并且最近邻的侧向连接是对称的。设自身连接权重为 $a$，每个最近邻侧向连接权重为 $w$（这些是带符号权重，负权重表示抑制）。在这些假设下，最通用的平移不变、对称、最近邻线性算子的形式为 $y_i = a\\,x_i + w\\,(x_{i-1} + x_{i+1})$。\n\n在感觉回路中，侧向抑制被理解为近似一个强调对比度的离散二阶空间导数。从间距为1的均匀格点上的二阶空间导数算子的基本性质（线性、平移不变性、关于 $i$ 的对称性、对常数和线性输入的零化作用，以及将二次输入 $x_i = i^2$ 映射为常数输出）出发，确定 $w$ 和 $a$ 的具体值，使得映射 $x \\mapsto y$ 等于该格点上的规范三点中心二阶差分算子。\n\n请将您的最终答案表示为行矩阵 $\\big(w, a\\big)$。无需四舍五入，也无需单位。",
            "solution": "用户希望我解决一个问题。我将首先验证问题陈述，如果有效，我将着手解决。\n\n### 步骤1：提取已知条件\n-   一个一维感受器阵列由整数 $i \\in \\mathbb{Z}$ 索引。\n-   输入活动为 $x_i$，输出活动为 $y_i$。\n-   该网络由一个线性的、平移不变的、对称的、最近邻算子描述。\n-   该算子的一般形式为 $y_i = a\\,x_i + w\\,(x_{i-1} + x_{i+1})$，其中 $a$ 是自身连接权重，$w$ 是最近邻侧向连接权重。\n-   问题要求该算子等价于间距为1的均匀格点上的规范三点中心二阶差分算子。\n-   目标算子的性质被列为：线性、平移不变性、关于 $i$ 的对称性、对常数和线性输入的零化作用，以及将二次输入 $x_i = i^2$ 映射到常数输出。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于一个成熟的神经生物学和计算概念，即使用侧向抑制来执行边缘检测，这在数学上被建模为二阶导数或拉普拉斯算子。其离散算子形式是一个标准的卷积核。这在科学上是合理的。\n-   **良态问题：** 该问题提供了一个双参数模型（$a$，$w$），并要求通过将该模型与一个特定的、明确定义的数学算子（规范中心二阶差分）相等来确定这些参数。这为获得唯一解提供了足够的信息。\n-   **客观性：** 问题以精确的数学术语陈述，没有主观性。\n\n该问题是有效的，因为它是自洽的、科学合理的且是良态的。检查清单中未发现任何缺陷。\n\n### 步骤3：结论与行动\n问题有效。我将继续解决它。\n\n问题要求我们找到权重 $a$ 和 $w$ 的具体值，使得给定的线性算子，\n$$ y_i = a\\,x_i + w\\,(x_{i-1} + x_{i+1}) $$\n与单位间距格点上的规范三点中心二阶差分算子相同。\n\n我们首先定义规范三点中心二阶差分算子。对于单变量 $z$ 的连续函数 $f(z)$，其二阶导数 $f''(z)$ 可以使用间距为 $h$ 的网格上的中心有限差分公式来近似：\n$$ f''(z) \\approx \\frac{f(z+h) - 2f(z) + f(z-h)}{h^2} $$\n将此近似应用于离散序列 $x_i$（代表整数点 $i$ 处的函数值）和网格间距 $h=1$，即可得到规范离散算子。因此，规范三点中心二阶差分算子的输出，我们可以表示为 $(\\Delta^2 x)_i$，是：\n$$ (\\Delta^2 x)_i = \\frac{x_{i+1} - 2x_i + x_{i-1}}{1^2} = x_{i+1} - 2x_i + x_{i-1} $$\n我们的任务是使给定的算子 $y_i$ 等于这个规范形式 $(\\Delta^2 x)_i$。我们可以通过按空间索引对各项进行排序来重写这两个表达式，以便于比较：\n$$ y_i = w\\,x_{i-1} + a\\,x_i + w\\,x_{i+1} $$\n$$ (\\Delta^2 x)_i = 1 \\cdot x_{i-1} - 2\\,x_i + 1 \\cdot x_{i+1} $$\n为了使这两个表达式对于任何任意输入序列 $x_i$ 都相等，对应项 $x_{i-1}$、$x_i$ 和 $x_{i+1}$ 的系数必须相同。\n\n通过比较系数，我们得到关于 $a$ 和 $w$ 的一个方程组：\n1.  从 $x_{i-1}$ 项的系数可得：$w = 1$。\n2.  从 $x_i$ 项的系数可得：$a = -2$。\n3.  从 $x_{i+1}$ 项的系数可得：$w = 1$。\n\n第三个方程是多余的，但与第一个方程一致。因此，唯一解是 $w=1$ 和 $a=-2$。\n\n问题还提到了二阶导数算子的几个基本性质。我们可以验证我们的解是否具备这些性质。该算子是 $y_i = x_{i-1} - 2x_i + x_{i+1}$。\n-   **对常数输入的零化作用：** 设 $x_i = c$，其中 $c$ 为某个常数。\n    $$ y_i = c - 2c + c = 0 $$\n    该性质得到满足。\n-   **对线性输入的零化作用：** 设 $x_i = m i + b$，其中 $m$ 和 $b$ 为常数。\n    $$ y_i = (m(i-1)+b) - 2(mi+b) + (m(i+1)+b) $$\n    $$ y_i = (mi - m + b) - (2mi + 2b) + (mi + m + b) $$\n    $$ y_i = (m - 2m + m)i + (-m + b - 2b + m + b) = 0 \\cdot i + 0 = 0 $$\n    该性质得到满足。\n-   **将二次输入映射为常数：** 设 $x_i = i^2$。\n    $$ y_i = (i-1)^2 - 2(i^2) + (i+1)^2 $$\n    $$ y_i = (i^2 - 2i + 1) - 2i^2 + (i^2 + 2i + 1) $$\n    $$ y_i = (i^2 - 2i^2 + i^2) + (-2i + 2i) + (1+1) = 0 \\cdot i^2 + 0 \\cdot i + 2 = 2 $$\n    输出为常数 $2$，所以该性质也得到满足。\n\n值 $w=1$ 和 $a=-2$ 唯一地定义了既符合所要求的一般形式又与规范二阶差分算子相同的算子。问题要求以行矩阵 $(w, a)$ 的形式给出答案。",
            "answer": "$$ \\boxed{\\begin{pmatrix} 1  -2 \\end{pmatrix}} $$"
        },
        {
            "introduction": "从离散模型过渡到更具生物学合理性的连续模型，我们通常使用高斯差分 ($DoG$) 函数来描述中央-周边感受野。本练习将探讨这种空间拮抗作用如何转化为在频率域中的刺激偏好。通过应用傅里叶变换，你将揭示为何具有此类感受野的神经元会充当“带通滤波器”，选择性地响应特定空间频率的视觉模式。",
            "id": "5029195",
            "problem": "早期感觉系统（如视网膜）中侧向抑制的一个标志是中心-周边感受野的出现，其空间滤波器可以很好地用高斯差分来近似。考虑一个由这种回路产生的一维感受野核，其模型为\n$$\nR(x) \\;=\\; k_{c}\\,\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma_{c}^{2}}\\right) \\;-\\; k_{s}\\,\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma_{s}^{2}}\\right),\n$$\n其中 $k_{c}$ 和 $k_{s}$ 是中心和周边的正增益系数，$\\sigma_{c}$ 和 $\\sigma_{s}$ 是中心和周边高斯函数的空间尺度（标准差）。一种用于探测空间调谐的标准实验探针是单位对比度的余弦光栅刺激\n$$\nS_{f}(x) \\;=\\; \\cos(2\\pi f x),\n$$\n其空间频率为 $f$（单位距离内的周期数），均值为零。对于一个偶函数核 $R(x)$，其对 $S_{f}(x)$ 的稳态线性响应幅度等于 $R(x)$ 在频率 $f$ 处的傅里叶变换（Fourier transform, FT）的幅值。\n\n从线性空间滤波、卷积以及一维高斯函数经过充分检验的傅里叶变换的核心定义出发，推导空间频率调谐曲线 $T(f)$，它被定义为响应幅度 $T(f) = \\left|\\int_{-\\infty}^{\\infty} R(x)\\cos(2\\pi f x)\\,dx\\right|$，作为 $f$ 的函数。然后，对于具体的参数值 $k_{c}=1$，$k_{s}=0.8$，$\\sigma_{c}=1$ 和 $\\sigma_{s}=3$（任意单位），解析地确定当 $f>0$ 时的非零峰值空间频率 $f_{\\text{peak}}$。将你最终的 $f_{\\text{peak}}$ 数值四舍五入到四位有效数字，并以“单位距离内的周期数”为单位表示。",
            "solution": "该问题已经过验证，被认为是有效的，因为它具有科学依据、问题设定良好、客观，并且包含了获得唯一解所需的所有必要信息。这是计算神经科学中的一个标准问题。\n\n第一个任务是推导空间频率调谐曲线 $T(f)$，它被定义为对正弦刺激的响应幅度。对于偶函数核 $R(x)$，这由以下公式给出：\n$$\nT(f) = \\left|\\int_{-\\infty}^{\\infty} R(x)\\cos(2\\pi f x)\\,dx\\right|\n$$\n感受野核 $R(x)$ 被表示为高斯差分：\n$$\nR(x) = k_{c}\\,\\exp\\left(-\\frac{x^{2}}{2\\sigma_{c}^{2}}\\right) - k_{s}\\,\\exp\\left(-\\frac{x^{2}}{2\\sigma_{s}^{2}}\\right)\n$$\n由于每个高斯项 $\\exp(-x^2/(2\\sigma^2))$ 都是 $x$ 的偶函数，它们的线性组合 $R(x)$ 也是一个偶函数。\n\n函数 $g(x)$ 的傅里叶变换 (FT) 定义为 $\\hat{g}(f) = \\mathcal{F}\\{g(x)\\} = \\int_{-\\infty}^{\\infty} g(x)\\exp(-i2\\pi f x)\\,dx$。使用欧拉公式 $\\exp(-i2\\pi f x) = \\cos(2\\pi f x) - i\\sin(2\\pi f x)$，傅里叶变换可以写成：\n$$\n\\hat{g}(f) = \\int_{-\\infty}^{\\infty} g(x)\\cos(2\\pi f x)\\,dx - i\\int_{-\\infty}^{\\infty} g(x)\\sin(2\\pi f x)\\,dx\n$$\n由于 $R(x)$ 是一个偶函数，乘积 $R(x)\\sin(2\\pi f x)$ 是一个奇函数，其在对称区间 $(-\\infty, \\infty)$ 上的积分为零。因此，$R(x)$ 的傅里叶变换的虚部为零。\n$$\n\\hat{R}(f) = \\int_{-\\infty}^{\\infty} R(x)\\cos(2\\pi f x)\\,dx\n$$\n这意味着调谐曲线 $T(f)$ 就是 $R(x)$ 的傅里叶变换的幅值：\n$$\nT(f) = |\\hat{R}(f)|\n$$\n为了求出 $\\hat{R}(f)$，我们利用傅里叶变换的线性和高斯函数傅里叶变换的标准结果。归一化高斯函数 $g(x) = \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$ 的傅里叶变换是：\n$$\n\\mathcal{F}\\left\\{\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\\right\\}(f) = \\sigma\\sqrt{2\\pi}\\,\\exp(-2\\pi^2\\sigma^2 f^2)\n$$\n将此应用于 $R(x)$ 的两个分量：\n$$\n\\hat{R}(f) = \\mathcal{F}\\left\\{k_{c}\\,\\exp\\left(-\\frac{x^{2}}{2\\sigma_{c}^{2}}\\right)\\right\\} - \\mathcal{F}\\left\\{k_{s}\\,\\exp\\left(-\\frac{x^{2}}{2\\sigma_{s}^{2}}\\right)\\right\\}\n$$\n$$\n\\hat{R}(f) = k_c \\left(\\sigma_c\\sqrt{2\\pi}\\,\\exp(-2\\pi^2\\sigma_c^2 f^2)\\right) - k_s \\left(\\sigma_s\\sqrt{2\\pi}\\,\\exp(-2\\pi^2\\sigma_s^2 f^2)\\right)\n$$\n提取公因式 $\\sqrt{2\\pi}$，我们得到 $\\hat{R}(f)$ 的表达式：\n$$\n\\hat{R}(f) = \\sqrt{2\\pi}\\left(k_c\\sigma_c\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s\\exp(-2\\pi^2\\sigma_s^2 f^2)\\right)\n$$\n调谐曲线是这个实值函数的幅值：\n$$\nT(f) = \\sqrt{2\\pi}\\left|k_c\\sigma_c\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s\\exp(-2\\pi^2\\sigma_s^2 f^2)\\right|\n$$\n这就完成了问题的第一部分。\n\n第二个任务是使用参数值 $k_{c}=1$，$k_{s}=0.8$，$\\sigma_{c}=1$ 和 $\\sigma_{s}=3$ 来找到当 $f>0$ 时的非零峰值空间频率 $f_{\\text{peak}}$。峰值频率对应于使 $T(f)$ 最大化的 $f$ 值。这等同于找到函数 $\\hat{R}(f)$ 在 $f>0$ 时的极值，因为 $|A|$ 的最大值出现在 $A$ 或 $A^2$ 取极值的地方。为了找到这个值，我们计算 $\\hat{R}(f)$ 关于 $f$ 的导数并将其设为零。为简化起见，我们可以忽略常数前置因子 $\\sqrt{2\\pi}$。\n\n令括号内的函数为 $H(f) = k_c\\sigma_c\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s\\exp(-2\\pi^2\\sigma_s^2 f^2)$。\n我们需要求解 $\\frac{dH(f)}{df} = 0$：\n$$\n\\frac{d}{df}\\left[k_c\\sigma_c\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s\\exp(-2\\pi^2\\sigma_s^2 f^2)\\right] = 0\n$$\n$$\nk_c\\sigma_c (-4\\pi^2\\sigma_c^2 f)\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s (-4\\pi^2\\sigma_s^2 f)\\exp(-2\\pi^2\\sigma_s^2 f^2) = 0\n$$\n对于非零峰值频率，我们假设 $f \\neq 0$ 并将方程两边除以 $-4\\pi^2 f$：\n$$\nk_c\\sigma_c^3\\exp(-2\\pi^2\\sigma_c^2 f^2) - k_s\\sigma_s^3\\exp(-2\\pi^2\\sigma_s^2 f^2) = 0\n$$\n$$\nk_c\\sigma_c^3\\exp(-2\\pi^2\\sigma_c^2 f^2) = k_s\\sigma_s^3\\exp(-2\\pi^2\\sigma_s^2 f^2)\n$$\n为了解出 $f^2$，我们重新整理各项：\n$$\n\\frac{\\exp(-2\\pi^2\\sigma_c^2 f^2)}{\\exp(-2\\pi^2\\sigma_s^2 f^2)} = \\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\n$$\n$$\n\\exp(-2\\pi^2 f^2(\\sigma_c^2 - \\sigma_s^2)) = \\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\n$$\n$$\n\\exp(2\\pi^2 f^2(\\sigma_s^2 - \\sigma_c^2)) = \\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\n$$\n对两边取自然对数：\n$$\n2\\pi^2 f^2(\\sigma_s^2 - \\sigma_c^2) = \\ln\\left(\\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\\right)\n$$\n解出 $f^2$：\n$$\nf^2 = \\frac{1}{2\\pi^2(\\sigma_s^2 - \\sigma_c^2)}\\ln\\left(\\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\\right)\n$$\n峰值空间频率 $f_{\\text{peak}}$ 是该表达式的正平方根：\n$$\nf_{\\text{peak}} = \\sqrt{\\frac{1}{2\\pi^2(\\sigma_s^2 - \\sigma_c^2)}\\ln\\left(\\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3}\\right)}\n$$\n现在，代入给定的参数值：$k_c=1$, $k_s=0.8$, $\\sigma_c=1$, $\\sigma_s=3$。\n首先，计算表达式内的各项：\n$$\n\\sigma_s^2 - \\sigma_c^2 = 3^2 - 1^2 = 9 - 1 = 8\n$$\n$$\n\\frac{k_s\\sigma_s^3}{k_c\\sigma_c^3} = \\frac{0.8 \\times 3^3}{1 \\times 1^3} = \\frac{0.8 \\times 27}{1} = 21.6\n$$\n将这些值代回 $f_{\\text{peak}}^2$ 的表达式中：\n$$\nf_{\\text{peak}}^2 = \\frac{1}{2\\pi^2(8)}\\ln(21.6) = \\frac{\\ln(21.6)}{16\\pi^2}\n$$\n取平方根求 $f_{\\text{peak}}$：\n$$\nf_{\\text{peak}} = \\sqrt{\\frac{\\ln(21.6)}{16\\pi^2}} = \\frac{\\sqrt{\\ln(21.6)}}{4\\pi}\n$$\n最后，我们计算数值并四舍五入到四位有效数字。\n使用 $\\ln(21.6) \\approx 3.072693$ 和 $\\pi \\approx 3.141593$：\n$$\nf_{\\text{peak}} \\approx \\frac{\\sqrt{3.072693}}{4 \\times 3.141593} \\approx \\frac{1.752910}{12.566371} \\approx 0.139494…\n$$\n四舍五入到四位有效数字，我们得到 $0.1395$。根据题目要求，单位是单位距离内的周期数。",
            "answer": "$$\n\\boxed{0.1395}\n$$"
        },
        {
            "introduction": "在本最后的练习中，理论将付诸实践，你将应用高斯差分模型来测试侧向抑制的一个关键功能：增强空间分辨率。通过建立一个数值模拟，你将量化评估两个邻近的刺激在经过处理后是否能够被区分。这项动手任务具体展示了侧向抑制如何锐化感觉表征，从而使大脑能够解析精细的细节。",
            "id": "5029213",
            "problem": "一个一维感觉层接收到一个空间机械刺激，该刺激被建模为两个邻近的局部压痕，其输出由通过中央-环绕感受野实现的侧向抑制来塑造。使用线性系统和感受野理论的基本原理，构建一个定量模型，并确定在给定的特定参数集下，这两个压痕是否可分辨。所有空间位置必须以 \\text{ mm} 表示。振幅是无量纲的。\n\n从以下基本基础开始：\n- 感受野是一个空间滤波器，通过对加权输入进行线性积分来产生输出。对于以 \\text{ mm} 为单位的一维位置坐标 $x$，由输入 $S(x)$ 和感受野 $R(x)$ 驱动的线性系统的输出 $O(x)$ 由以下卷积积分给出\n$$\nO(x) = \\int_{-\\infty}^{\\infty} S(u)\\, R(x-u)\\, \\mathrm{d}u.\n$$\n- 高斯函数被广泛用于近似中央-环绕感受野的中央和环绕部分。一个标准差为 $\\sigma$ (\\text{ mm}) 的归一化高斯函数是\n$$\nG_{\\sigma}(x) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma^{2}}\\right).\n$$\n- 高斯差分 (DoG) 感受野通过从中央部分减去一个按比例缩放的环绕部分来模拟侧向抑制：\n$$\nR(x) = G_{\\sigma_c}(x) - k\\, G_{\\sigma_s}(x),\n$$\n其中 $\\sigma_c$ 和 $\\sigma_s$ (单位为 \\text{ mm}) 分别是中央和环绕的标准差，$k$ 是一个无量纲的环绕权重。\n\n刺激定义：\n- 将两个压痕建模为两个相隔 $s$ \\text{ mm} 的局部正高斯函数：\n$$\nS(x) = A \\left[\\exp\\!\\left(-\\frac{(x - s/2)^2}{2 w_s^2}\\right) + \\exp\\!\\left(-\\frac{(x + s/2)^2}{2 w_s^2}\\right)\\right],\n$$\n其中 $A$ 是一个无量纲的振幅，$w_s$ (单位为 \\text{ mm}) 是捕捉压痕宽度的刺激标准差。该刺激未进行面积归一化，以反映有限的机械扩散。\n\n可分辨性准则：\n- 计算出 $O(x)$ 后，定义两个局部最大值 $p_1$ 和 $p_2$ (振幅为正) 以及它们之间沿 $x$ 轴的局部最小值 $m$。\n- 定义凹陷分数\n$$\n\\delta = \\frac{\\min(p_1, p_2) - m}{\\min(p_1, p_2)}.\n$$\n- 当且仅当以下所有条件都成立时，才声明该对是可分辨的：(i) $O(x)$ 中存在至少两个正的局部最大值，(ii) 所选的两个最大值沿 $x$ 轴被一个最小值隔开，(iii) 峰峰间距至少为 $0.5\\,s$ \\text{ mm}，以及 (iv) $\\delta \\ge \\tau$，其中阈值 $\\tau = 0.26$ (以小数形式表示)。\n\n数值实现要求：\n- 通过在对称空间域 $x \\in [-L/2, L/2]$ (其中 $L$ 单位为 \\text{ mm}) 上对 $S(x)$ 和 $R(x)$ 进行数值卷积来计算 $O(x)$。使用均匀空间步长 $dx$ (单位为 \\text{ mm})，并通过包含因子 $dx$ 来确保离散卷积能正确逼近该积分。\n- 使用离散导数检测局部最大值和最小值。仅考虑振幅为正的最大值用于可分辨性判断。\n\n测试套件：\n实现您的程序，以评估以下参数集的可分辨性。对所有情况，使用 $L = 20$ \\text{ mm} 和 $dx = 0.01$ \\text{ mm}，$A = 1$ (无量纲)，以及 $\\tau = 0.26$。\n\n- 情况 1：$s = 2.0$ \\text{ mm}, $w_s = 0.3$ \\text{ mm}, $\\sigma_c = 0.4$ \\text{ mm}, $\\sigma_s = 1.2$ \\text{ mm}, $k = 0.75$。\n- 情况 2：$s = 0.6$ \\text{ mm}, $w_s = 0.3$ \\text{ mm}, $\\sigma_c = 0.4$ \\text{ mm}, $\\sigma_s = 1.2$ \\text{ mm}, $k = 0.75$。\n- 情况 3：$s = 2.0$ \\text{ mm}, $w_s = 0.7$ \\text{ mm}, $\\sigma_c = 0.4$ \\text{ mm}, $\\sigma_s = 1.2$ \\text{ mm}, $k = 0.75$。\n- 情况 4：$s = 2.0$ \\text{ mm}, $w_s = 0.3$ \\text{ mm}, $\\sigma_c = 0.5$ \\text{ mm}, $\\sigma_s = 1.8$ \\text{ mm}, $k = 1.10$。\n- 情况 5：$s = 4.0$ \\text{ mm}, $w_s = 0.3$ \\text{ mm}, $\\sigma_c = 0.4$ \\text{ mm}, $\\sigma_s = 1.2$ \\text{ mm}, $k = 0.75$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如, \"[result1,result2,result3]\")。每个结果必须是一个布尔值，表示按上述顺序列出的相应情况的可分辨性。",
            "solution": "该问题要求开发一个定量模型，以评估一个采用侧向抑制的一维感觉系统对两个邻近机械压痕的可分辨性。该解决方案遵循线性系统理论和计算神经科学的原理。\n\n首先，我们建立数学框架。感觉系统的输出 $O(x)$ 是对输入刺激 $S(x)$ 进行线性滤波操作的结果。该操作在数学上由卷积积分描述：\n$$\nO(x) = S(x) * R(x) = \\int_{-\\infty}^{\\infty} S(u)\\, R(x-u)\\, \\mathrm{d}u\n$$\n其中 $R(x)$ 是系统的感受野，它充当卷积核或空间滤波器。\n\n刺激 $S(x)$ 代表两个局部压痕。它被建模为两个高斯函数的和，每个函数的振幅为 $A$，空间宽度由标准差 $w_s$ 控制。这两个高斯函数分别以 $x = -s/2$ 和 $x = +s/2$ 为中心，其中 $s$ 是间隔距离：\n$$\nS(x) = A \\left[\\exp\\!\\left(-\\frac{(x - s/2)^2}{2 w_s^2}\\right) + \\exp\\!\\left(-\\frac{(x + s/2)^2}{2 w_s^2}\\right)\\right]\n$$\n请注意，这些高斯分量未经面积归一化，这反映了一个模型，其中振幅 $A$ 对应于每个局部刺激的峰值强度。\n\n感受野 $R(x)$ 使用高斯差分 (DoG) 函数来模拟侧向抑制机制。这是感觉通路中发现的中央-环绕感受野的一种常见且具有生物学合理性的模型。DoG 滤波器通过从一个窄而强的兴奋性“中央”高斯函数中减去一个宽而弱的抑制性“环绕”高斯函数来构建：\n$$\nR(x) = G_{\\sigma_c}(x) - k\\, G_{\\sigma_s}(x)\n$$\n这里，$G_{\\sigma}(x)$ 是一个归一化的高斯函数，确保滤波器的分量在缩放前具有单位面积：\n$$\nG_{\\sigma}(x) = \\frac{1}{\\sqrt{2\\pi}\\,\\sigma}\\,\\exp\\!\\left(-\\frac{x^{2}}{2\\sigma^{2}}\\right)\n$$\n参数 $\\sigma_c$ 和 $\\sigma_s$ 分别代表兴奋性中央和抑制性环绕的空间范围，且 $\\sigma_s > \\sigma_c$。无量纲参数 $k$ 控制抑制性环绕相对于中央的强度。\n\n为了在数值上实现该解法，我们首先将一维空间域 $x \\in [-L/2, L/2]$ 离散化为一系列由小步长 $dx$ 分隔的点。在每个点上计算函数 $S(x)$ 和 $R(x)$，以生成相应的数值数组。然后，卷积积分通过离散卷积和来近似。使用像 `scipy.signal.convolve` 这样的数值库函数，这被计算为一个和，然后必须乘以空间步长 $dx$，以根据黎曼积分的定义正确缩放结果：\n$$\nO(x_i) \\approx \\sum_{j} S(x_j) R(x_i - x_j) \\, dx\n$$\n\n一旦计算出输出轮廓 $O(x)$，我们就应用指定的多部分可分辨性准则。这个过程确定两个初始刺激是否产生了一个可感知区分的响应。\n\n1.  **存在两个峰值 (条件 i)：** 我们首先在输出轮廓 $O(x)$ 中识别所有振幅为正的局部最大值。使用高度阈值为 $0$ 的 `scipy.signal.find_peaks` 函数适合此任务。如果找到少于两个这样的峰值，则刺激已合并为单个感知，被视为不可分辨。\n\n2.  **被最小值分隔 (条件 ii)：** 从正峰值集合中，我们选择振幅最高的两个，指定为 $p_1$ 和 $p_2$。问题要求这两个主峰值被一个局部最小值隔开。为验证这一点，我们在 $O(x)$ 中严格位于 $p_1$ 和 $p_2$ 位置之间的片段中搜索局部最小值。如果在此区间内未找到局部最小值，则峰值未被正确分离，刺激不可分辨。如果存在一个或多个最小值，我们选择值最低的那个作为中间的波谷 $m$。\n\n3.  **峰峰间距 (条件 iii)：** 两个已识别峰值位置之间的空间距离 $|x_{p1} - x_{p2}|$ 必须至少是原始刺激间隔的一半，即 $0.5s$。这个条件防止了峰值虽然可区分但塌陷得太近，以至于不能被认为是输入的忠实表示的情况。\n\n4.  **凹陷分数 (条件 iv)：** 最后，我们计算“凹陷分数”$\\delta$。该度量类似于光学中的瑞利判据 (Rayleigh criterion)，它量化了峰之间波谷相对于其高度的深度。其定义为：\n    $$\n    \\delta = \\frac{\\min(p_1, p_2) - m}{\\min(p_1, p_2)}\n    $$\n    只有当这个凹陷分数达到或超过给定阈值，即 $\\delta \\ge \\tau$ (其中 $\\tau = 0.26$) 时，刺激才被认为是可分辨的。\n\n只有当所有四个条件都满足时，给定的一组参数才会得出“可分辨”的结论。最终的实现会遍历每个测试用例，应用整个过程，并生成一个布尔结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve, find_peaks\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Global parameters as defined in the problem statement\n    L = 20.0  # mm\n    dx = 0.01  # mm\n    A = 1.0    # dimensionless\n    tau = 0.26 # dimensionless\n\n    # Test suite from the problem statement\n    test_cases = [\n        # s, w_s, sigma_c, sigma_s, k\n        (2.0, 0.3, 0.4, 1.2, 0.75),  # Case 1\n        (0.6, 0.3, 0.4, 1.2, 0.75),  # Case 2\n        (2.0, 0.7, 0.4, 1.2, 0.75),  # Case 3\n        (2.0, 0.3, 0.5, 1.8, 1.10),  # Case 4\n        (4.0, 0.3, 0.4, 1.2, 0.75),  # Case 5\n    ]\n\n    # --- Core logic function ---\n    def check_resolvability(s, w_s, sigma_c, sigma_s, k):\n        \"\"\"\n        Evaluates resolvability for a single set of parameters.\n        \n        Args:\n            s (float): Separation of stimulus Gaussians (mm).\n            w_s (float): Standard deviation of stimulus Gaussians (mm).\n            sigma_c (float): Standard deviation of receptive field center (mm).\n            sigma_s (float): Standard deviation of receptive field surround (mm).\n            k (float): Weight of the inhibitory surround.\n\n        Returns:\n            bool: True if resolvable, False otherwise.\n        \"\"\"\n        # 1. Setup spatial domain\n        x = np.arange(-L / 2, L / 2 + dx, dx)\n\n        # 2. Define stimulus S(x) and receptive field R(x)\n        \n        # Stimulus: Sum of two unnormalized Gaussians\n        S = A * (np.exp(-(x - s / 2)**2 / (2 * w_s**2)) + \n                 np.exp(-(x + s / 2)**2 / (2 * w_s**2)))\n\n        # Normalized Gaussian function for the receptive field\n        def G_norm(x_arr, sigma):\n            return (1 / (np.sqrt(2 * np.pi) * sigma)) * np.exp(-x_arr**2 / (2 * sigma**2))\n\n        # Receptive Field: Difference-of-Gaussians (DoG)\n        R_center = G_norm(x, sigma_c)\n        R_surround = G_norm(x, sigma_s)\n        R = R_center - k * R_surround\n\n        # 3. Compute output O(x) via convolution\n        # The convolution integral is approximated by the discrete sum multiplied by dx\n        O = dx * convolve(S, R, mode='same')\n\n        # 4. Apply resolvability criteria\n        \n        # (i) Find at least two positive local maxima\n        peak_indices, _ = find_peaks(O, height=0)\n        if len(peak_indices)  2:\n            return False\n\n        # Select the two highest-amplitude peaks\n        sorted_peak_indices = peak_indices[np.argsort(O[peak_indices])[::-1]]\n        idx_p1 = sorted_peak_indices[0]\n        idx_p2 = sorted_peak_indices[1]\n        \n        p1_val = O[idx_p1]\n        p2_val = O[idx_p2]\n\n        # Order peaks by their position on the x-axis\n        idx_left_peak = min(idx_p1, idx_p2)\n        idx_right_peak = max(idx_p1, idx_p2)\n        \n        # (ii) Check for a local minimum between the two main peaks.\n        # Check if peaks are adjacent, leaving no room for a minimum.\n        if idx_right_peak = idx_left_peak + 1:\n            return False\n            \n        # Search for minima in the segment strictly between the peaks.\n        sub_array_for_min = O[idx_left_peak + 1:idx_right_peak]\n        min_indices_relative, _ = find_peaks(-sub_array_for_min)\n        \n        if len(min_indices_relative) == 0:\n            return False\n        \n        # Find the value of the deepest local minimum between the peaks\n        deepest_min_idx_relative = min_indices_relative[np.argmin(sub_array_for_min[min_indices_relative])]\n        m_val = sub_array_for_min[deepest_min_idx_relative]\n\n        # (iii) Check peak-to-peak separation\n        x_p1 = x[idx_p1]\n        x_p2 = x[idx_p2]\n        peak_separation = abs(x_p1 - x_p2)\n        if peak_separation  0.5 * s:\n            return False\n            \n        # (iv) Check the dip fraction\n        p_min = min(p1_val, p2_val)\n        \n        # Ensure the minimum is not higher than the smaller peak\n        if m_val >= p_min:\n             return False\n\n        delta = (p_min - m_val) / p_min\n        if delta  tau:\n            return False\n\n        # If all conditions are met, the stimuli are resolvable\n        return True\n\n    # --- Run evaluation for all cases ---\n    results = []\n    for case in test_cases:\n        s_val, w_s_val, sigma_c_val, sigma_s_val, k_val = case\n        is_res = check_resolvability(s_val, w_s_val, sigma_c_val, sigma_s_val, k_val)\n        results.append(is_res)\n\n    # Final print statement in the exact required format\n    # The str() of a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}