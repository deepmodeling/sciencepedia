{
    "hands_on_practices": [
        {
            "introduction": "要真正理解节律性发生的生物过程（如体节发生），我们必须探究其背后的分子机制。本练习将引导您构建并分析一个核心的数学模型，该模型描述了由延迟负反馈驱动的基因振荡器。通过推导延迟微分方程并进行线性稳定性分析，您将亲手揭示一个简单的基因回路如何自发产生稳定的节律，从而为“分节时钟”的概念提供坚实的理论基础 。",
            "id": "4939433",
            "problem": "在脊椎动物的体节分割时钟中，Hairy and Enhancer of Split 1 (Hes1) 在体节前中胚层中表现出由延迟负反馈驱动的自抑制振荡。从分子生物学的中心法则和基于标准占有率的转录调控描述出发，构建一个针对 Hes1 信使核糖核酸 (mRNA) 浓度 $H(t)$ 的单变量最小模型，该模型能够捕捉延迟的自抑制和一级降解。使用以下具有科学依据的要素：\n\n- $H(t)$ 的转录受 Hes1 蛋白 $P(t)$ 的抑制，通过一个希尔系数为 $n$、半饱和常数为 $K$ 的希尔型启动子占有率模型实现。因此，瞬时转录速率是延迟的蛋白浓度 $P(t-\\tau)$ 的一个递减函数，其中 $\\tau$ 是有效的转录-翻译-成熟延迟。\n- 假设翻译和蛋白质周转相对于 $H(t)$ 动态的时间尺度足够快，从而可以合理地使用准稳态比例关系 $P(t) \\approx \\eta\\,H(t)$，其中比例因子 $\\eta>0$。\n- Hes1 mRNA 以速率 $\\delta>0$ 进行一级动力学降解。\n- 在没有抑制的情况下，最大转录速率为 $\\alpha>0$。\n\n在此基础上：\n\n1. 在准稳态比例关系 $P(t) \\approx \\eta\\,H(t)$ 下，推导一个包含延迟负反馈和一级降解的关于 $H(t)$ 的最小延迟微分方程 (DDE)。\n2. 确定非平凡稳态 $H^{*}>0$，并在 $H^{*}$ 附近对该 DDE 进行线性化，以获得控制小扰动的特征方程。\n3. 通过寻找特征方程的纯虚根，展示 Hopf 分岔（并因此产生持续振荡）发生的条件，并推导稳态首次失稳并产生振荡的最小正临界延迟 $\\tau_{c}$。\n4. 以线性化反馈增益 $A$ 和降解速率 $\\delta$ 的形式，给出 $\\tau_{c}$ 的闭式解。其中 $A$ 是在 $H^{*}$ 处评估的延迟抑制项斜率的正值，即 $A \\equiv -\\left.\\dfrac{d}{dx}\\dfrac{\\alpha}{1+\\left(\\dfrac{\\eta x}{K}\\right)^{n}}\\right|_{x=H^{*}}$。\n\n最终答案只需提供最小正 $\\tau_{c}$ 的解析表达式。不要包含单位，也无需进行数值计算。",
            "solution": "` tag start.\n2.  **第1部分：DDE 推导。** 陈述产生和降解的平衡关系。代入各项给定的形式。\n3.  **第2部分：稳态和线性化。** 为求稳态，将导数设为零。定义扰动。对非线性项进行泰勒展开。写出线性化的 DDE 和特征方程。\n4.  **第3和4部分：Hopf 分岔和临界延迟。** 代入 `λ = iω`。分离实部和虚部。求解 `ω_c` 和 `τ_c`。解释为何选择 `arccos` 函数和主值 (`k=0`)。`τ_c` 的最终表达式是此推导的结果。\n5.  `",
            "answer": "$$ \\boxed{\\frac{\\arccos\\left(-\\frac{\\delta}{A}\\right)}{\\sqrt{A^{2} - \\delta^{2}}}} $$"
        },
        {
            "introduction": "在通过数学推导理解了振荡的起源之后，下一个强大的工具便是计算机模拟。本练习将理论付诸实践，要求您编写程序来模拟分节时钟的动态行为。通过这种计算实验，您可以直观地观察振荡的出现，并系统地改变时间延迟或降解率等参数，探究它们如何调节时钟的周期和稳定性，这正是计算系统生物学家研究生物网络时所采用的方法 。",
            "id": "4939387",
            "problem": "你的任务是设计并实现一个数值实验，研究延迟负反馈基因调控回路如何产生体节发生过程中分节时钟的基础振荡，以及降解速率或延迟时间的变化如何影响这些振荡的存在与特性。使用一个最小的、具有生物学动机的延迟微分方程模型，该模型需与分子生物学中心法则（转录产生信使核糖核酸（mRNA），翻译产生蛋白质）以及有充分证据支持的观察结果（即 hairy 和 enhancer of split (HES) 家族基因通过延迟负反馈抑制其自身的转录）相一致。\n\n起点和定义：\n- 令 $M(t)$ 表示 mRNA 水平，$P(t)$ 表示蛋白质水平。\n- 转录被蛋白质以 $t - \\tau$ 的延迟抑制，这代表了转录、剪接、翻译、转运和翻译后修饰等累积过程。\n- 延迟负反馈抑制由一个指数为 $n$ 的希尔函数（Hill function）描述。\n- 降解是一级反应，mRNA 的速率常数为 $\\delta_m$，蛋白质的速率常数为 $\\delta$。\n- 从 mRNA 到蛋白质的翻译以速率常数 $k$ 进行，最大 mRNA 转录速率为 $\\alpha$。\n\n模型方程：\n$$\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t),$$\n$$\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t).$$\n\n要求：\n1. 实现一个能够处理延迟项 $P(t - \\tau)$ 的数值积分方案，无需使用外部文件或用户输入。你可以使用离散环形缓冲区或等效方法来近似延迟。使用固定时间步长 $dt$，并通过选择相对于存在的最快速率足够小的 $dt$ 来确保数值稳定性。\n2. 设计一种振荡检测方法，该方法在给定一个指定分析窗口内的模拟蛋白质时间序列后，返回：\n   - 一个布尔值，指示是否存在持续振荡，以及\n   - 一个浮点数，给出平均振荡周期（单位：秒）（如果存在振荡），如果不存在振荡则为 $0.0$。\n   持续振荡应通过在瞬态过程后检测到多个峰值，并要求振幅（最大值减去最小值）超过一个小的正阈值来确定。周期应计算为分析窗口内平均峰间间隔（单位：秒）。\n3. 对延迟 $\\tau$ 进行参数扫描，通过识别出能检测到持续振荡的最小测试 $\\tau$ 值来估计振荡的起始点（一个实际的分岔点）。如果所有测试的延迟都未产生振荡，则分岔估计返回 $0.0$。\n4. 在调节蛋白质降解速率 $\\delta$ 或延迟 $\\tau$ 的类实验性扰动下，验证振荡特性。\n\n物理和数值单位：\n- 时间必须以秒为单位。周期和延迟必须以秒为单位，作为浮点数报告。\n- 所有布尔值输出必须是字面量 $True$ 或 $False$。\n\n数值方法约束：\n- 积分使用固定时间步长 $dt = 1.0$ 秒。\n- 模拟总时长为 $T_{\\text{total}} = 20000.0$ 秒。\n- 将最初的 $5000.0$ 秒作为瞬态过程丢弃；在剩余的窗口中分析振荡。\n- 将 $M(0)$ 和 $P(0)$ 初始化为小的正值，并对 $t \\in [-\\tau, 0)$ 区间内的 $P(t)$ 使用恒定的历史前值。\n\n测试套件：\n使用以下参数集，每个参数集都由 $\\left(\\alpha, \\delta_m, k, \\delta, n, \\tau\\right)$ 定义，时间单位为秒，速率单位为秒的倒数：\n- 测试 1 (基线振荡状态)：$\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$, $\\tau = 1200.0$。以浮点数形式输出平均振荡周期（单位：秒）。\n- 测试 2 (边界情况，无延迟)：与测试 1 相同，但 $\\tau = 0.0$。输出一个布尔值，指示是否检测到持续振荡。\n- 测试 3 (扰动，更快降解)：与测试 1 相同，但 $\\delta = 2 \\times 0.000577$。以浮点数形式输出平均振荡周期（单位：秒）；如果不振荡，则输出 $0.0$。\n- 测试 4 (通过延迟扫描估算分岔点)：固定 $\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$，并对 $\\tau$ 扫描列表 $\\left[0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0\\right]$。从此列表中输出能产生持续振荡的最小 $\\tau$ 值（单位：秒）；如果没有，则输出 $0.0$。\n- 测试 5 (扰动，更慢降解)：与测试 1 相同，但 $\\delta = 0.5 \\times 0.000577$。以浮点数形式输出平均振荡周期（单位：秒）；如果不振荡，则输出 $0.0$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试 1 到测试 5 的顺序排列结果。该列表必须包含与上述规定输出相对应的类型为 $\\left[\\text{float}, \\text{boolean}, \\text{float}, \\text{float}, \\text{float}\\right]$ 的值。例如，一个有效的输出格式是 $\\left[1800.0,False,1500.0,900.0,2100.0\\right]$。",
            "solution": "该问题陈述已经过验证，被确定为计算系统生物学中一个适定的、有科学依据的任务。它要求对一个用于遗传振荡器的标准延迟微分方程（DDE）模型进行数值模拟和分析，这与发育生物学中分节时钟的研究相关。其参数、约束和目标都定义清晰且计算上可行。\n\n### 模型：延迟负反馈回路\n\n问题的核心是一个双变量模型，描述了信使 RNA (mRNA) 浓度 $M(t)$ 和蛋白质浓度 $P(t)$ 的动态。该模型是一个耦合延迟微分方程组：\n\n$$\n\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t)\n$$\n$$\n\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t)\n$$\n\n这些方程概括了分子生物学的基本原理：\n1.  **转录**：$\\frac{dM}{dt}$ 方程中的第一项模拟了 mRNA 的产生。产生速率受蛋白质 $P$ 的调节。最大转录速率为 $\\alpha$。\n2.  **抑制**：蛋白质 $P$ 抑制其自身基因的转录。这种负反馈由一个希尔函数 $\\frac{1}{1 + [P]^n}$ 描述，其中 $n$ 是决定抑制陡峭程度的希尔系数。较高的 $n$ 值意味着更接近开关般的响应。\n3.  **时间延迟**：抑制作用不是瞬时的。$P(t - \\tau)$ 项表明，时间 $t$ 的转录速率由过去某个时间 $t - \\tau$ 的蛋白质浓度决定。这个延迟 $\\tau$ 整合了转录、翻译和分子运输所需的时间。它是能够诱发振荡的关键要素。\n4.  **降解**：mRNA 和蛋白质都会发生降解，被建模为一级过程，速率常数分别为 $\\delta_m$ 和 $\\delta$。$-\\delta_m M(t)$ 和 $-\\delta P(t)$ 项代表这种清除过程。\n5.  **翻译**：$\\frac{dP}{dt}$ 方程中的 $k\\,M(t)$ 项模拟了从 mRNA 模板合成蛋白质的过程，其发生速率与 mRNA 浓度成正比，速率常数为 $k$。\n\n### 数值求解策略\n\n为求解该 DDE 系统，我们采用一种具有固定时间步长的数值积分方案。\n\n**离散化与积分**\n我们使用前向欧拉法（Forward Euler method），这是一种简单直接的显式时间步进方案。对于一个很小的时间步长 $dt$，系统在时间 $t+dt$ 的状态是根据其在时间 $t$ 的状态来近似的。给定时间步长 $dt = 1.0$ 秒，离散更新规则如下：\n$$\nM(t_i + dt) = M(t_i) + dt \\cdot \\left( \\frac{\\alpha}{1 + \\left[P(t_i - \\tau)\\right]^n} - \\delta_m M(t_i) \\right)\n$$\n$$\nP(t_i + dt) = P(t_i) + dt \\cdot (k\\,M(t_i) - \\delta\\,P(t_i))\n$$\n其中 $t_i = i \\cdot dt$，对于 $i = 0, 1, 2, \\dots$。所选的时间步长 $dt=1.0$ 远小于系统的特征时间尺度（例如 $1/\\delta_m = 1000$ 秒），从而确保了在给定参数下的数值稳定性。\n\n**处理时间延迟**\n$P(t_i - \\tau)$ 项需要访问蛋白质浓度的历史数据。我们将把 $M(t)$ 和 $P(t)$ 的完整时间序列存储在数组中。在每个时间步 $i$（对应时间 $t_i$），延迟的蛋白质浓度是在过去的时间 $t_i - \\tau$ 找到的。对应的数组索引是 $j = i - \\tau/dt$。由于所提供的 $\\tau$ 值是 $dt$ 的整数倍，该索引 $j$ 将是一个整数。对于 $t_i - \\tau  0$ 的时间点，我们必须查询系统的历史前值。\n\n**初始条件与历史条件**\n系统在 $t=0$ 时以小的正浓度初始化，以防止除以零并代表一个基础状态。我们设置 $M(0) = 1.0$ 和 $P(0) = 1.0$。对于历史前值，即 $t  0$，问题指定 $P(t)$ 为一个常数。我们将对所有 $t \\in [-\\tau, 0)$ 使用 $P(t) = P(0) = 1.0$ 的历史值。这是通过在延迟查找索引 $j$ 为负时使用 $P(0)$ 的值来实现的。\n\n### 振荡分析\n\n为了确定系统是否表现出持续振荡，我们在一个指定的窗口内分析蛋白质时间序列 $P(t)$，并丢弃初始的瞬态过程。\n\n1.  **分析窗口**：模拟运行总时间为 $T_{\\text{total}} = 20000.0$ 秒。我们丢弃最初的 $5000.0$ 秒，以使系统稳定到其长期行为（一个稳定稳态或一个极限环），并在时间区间 $[5000.0, 20000.0]$ 上进行分析。\n\n2.  **振荡检测逻辑**：\n    *   **振幅阈值**：振荡的一个主要指标是浓度的显著变化。我们计算峰-谷振幅 $A = \\max(P_{\\text{window}}) - \\min(P_{\\text{window}})$。为了区分真实振荡与数值噪声或阻尼振荡，我们要求该振幅超过一个阈值。选择 $A  0.1$ 的阈值是相对于预期稳态浓度的一个合理的小正值。\n    *   **峰值识别**：我们使用一个寻峰算法，具体为 `scipy.signal.find_peaks`，来识别蛋白质时间序列中的局部最大值。一个关键参数是 `prominence`（突显度），它衡量一个峰值从其周围基线中突出的程度。为了滤除微小的噪声峰，我们要求所需的突显度至少为总振幅 $A$ 的 $10\\%$。\n    *   **持续振荡标准**：为了使振荡被认为是“持续的”，我们要求在分析窗口内检测到至少 3 个显著峰值。这确保我们至少有两个完整的周期，从而可以计算出有意义的平均周期。\n\n3.  **周期计算**：如果满足持续振荡的标准，振荡周期计算为连续检测到的峰值之间的平均时间差。如果未检测到振荡，则周期报告为 $0.0$。\n\n### 测试用例执行\n将已建立的数值和分析框架应用于问题中定义的五个测试用例中的每一个。一个主函数为每个参数集协调模拟和分析，收集所需的特定输出：平均周期、表示振荡是否存在的布尔值，或来自参数扫描的分岔点。然后将结果格式化为指定的列表结构，用于最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n\n    def detect_oscillations(time_series, dt, analysis_start_time):\n        \"\"\"\n        Detects sustained oscillations in a time series and calculates their period.\n\n        Args:\n            time_series (np.ndarray): The data to analyze (e.g., protein concentration).\n            dt (float): The time step of the simulation.\n            analysis_start_time (float): Time to start the analysis from (to discard transients).\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if sustained oscillations are detected, False otherwise.\n                - float: The mean oscillation period in seconds, or 0.0 if not oscillating.\n        \"\"\"\n        analysis_start_idx = int(analysis_start_time / dt)\n        analysis_window = time_series[analysis_start_idx:]\n\n        if len(analysis_window)  3:\n            return False, 0.0\n\n        amplitude = np.max(analysis_window) - np.min(analysis_window)\n        \n        # Amplitude threshold for meaningful oscillation\n        amplitude_threshold = 0.1\n        if amplitude  amplitude_threshold:\n            return False, 0.0\n\n        # Find peaks with a prominence relative to the signal amplitude\n        # A minimal distance helps avoid detecting multiple peaks on a noisy crest.\n        # A distance of 100 steps (100 seconds) is safe.\n        prominence_threshold = 0.1 * amplitude\n        peaks, _ = signal.find_peaks(analysis_window, \n                                     prominence=prominence_threshold,\n                                     distance=int(100/dt))\n\n        # Require at least 3 peaks for a \"sustained\" oscillation and robust period calculation\n        if len(peaks)  3:\n            return False, 0.0\n\n        # Calculate mean period from inter-peak intervals\n        peak_intervals = np.diff(peaks) * dt\n        mean_period = np.mean(peak_intervals)\n\n        return True, mean_period\n\n    def run_simulation(alpha, delta_m, k, delta, n, tau, T_total, dt, analysis_start_time):\n        \"\"\"\n        Runs a single simulation of the DDE model.\n\n        Args:\n            (alpha, delta_m, k, delta, n, tau): Model parameters.\n            T_total (float): Total simulation time.\n            dt (float): Time step.\n            analysis_start_time (float): Start time for analysis.\n\n        Returns:\n            tuple: (is_oscillatory, mean_period) from detect_oscillations.\n        \"\"\"\n        num_steps = int(T_total / dt)\n        M = np.zeros(num_steps + 1)\n        P = np.zeros(num_steps + 1)\n\n        # Initial conditions: small positive values\n        M[0] = 1.0\n        P[0] = 1.0\n        P_history_val = 1.0 # Constant pre-history\n\n        delay_steps = int(tau / dt)\n\n        # Main integration loop (Forward Euler)\n        for i in range(num_steps):\n            delay_idx = i - delay_steps\n            P_delayed = P[delay_idx] if delay_idx >= 0 else P_history_val\n\n            dM_dt = alpha / (1.0 + P_delayed**n) - delta_m * M[i]\n            dP_dt = k * M[i] - delta * P[i]\n\n            M[i + 1] = M[i] + dt * dM_dt\n            P[i + 1] = P[i] + dt * dP_dt\n\n        is_oscillatory, mean_period = detect_oscillations(P, dt, analysis_start_time)\n        return is_oscillatory, mean_period\n\n    # Numerical settings from the problem\n    DT = 1.0\n    T_TOTAL = 20000.0\n    ANALYSIS_START = 5000.0\n\n    # Baseline parameters\n    base_params = {\n        'alpha': 0.01,\n        'delta_m': 0.001,\n        'k': 0.0001,\n        'delta': 0.000577,\n        'n': 4,\n        'tau': 1200.0\n    }\n\n    results = []\n\n    # --- Test 1: Baseline oscillatory regime ---\n    params1 = base_params.copy()\n    _, period1 = run_simulation(**params1, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period1)\n\n    # --- Test 2: Boundary, no delay ---\n    params2 = base_params.copy()\n    params2['tau'] = 0.0\n    is_oscillatory2, _ = run_simulation(**params2, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(is_oscillatory2)\n    \n    # --- Test 3: Perturbation, faster degradation ---\n    params3 = base_params.copy()\n    params3['delta'] *= 2.0\n    _, period3 = run_simulation(**params3, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period3)\n\n    # --- Test 4: Bifurcation estimate via delay sweep ---\n    params4_base = base_params.copy()\n    tau_sweep = [0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0]\n    bifurcation_tau = 0.0\n    for tau_val in tau_sweep:\n        params4 = params4_base.copy()\n        params4['tau'] = tau_val\n        is_oscillatory, _ = run_simulation(**params4, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n        if is_oscillatory:\n            bifurcation_tau = tau_val\n            break\n    results.append(bifurcation_tau)\n\n    # --- Test 5: Perturbation, slower degradation ---\n    params5 = base_params.copy()\n    params5['delta'] *= 0.5\n    _, period5 = run_simulation(**params5, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period5)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "理论模型和计算模拟的最终价值在于它们能否解释和预测在真实生物体中观察到的现象。本练习旨在连接抽象模型与胚胎的物理现实。您将使用从活体胚胎成像中获得的真实实验数据——即时钟周期$T$和波前速度$u$——来预测新生体节的大小，并将此预测与经过组织学处理后的测量结果进行比较，从而学会如何处理和解释实验过程中可能引入的误差，例如组织生长和固定伪影 。",
            "id": "4939470",
            "problem": "在体节发生的“钟-波阵面”模型中，体节前中胚层（PSM）表现出称为分节时钟的振荡性基因表达，其周期为 $T$。同时，一个停止前沿（决定波阵面）沿着胚胎的前后轴以速度 $u$ 向前移动。通过对活体鸟类胚胎进行延时成像构建的动态图，提供了测得的停止前沿速度 $u$ 和分节时钟的振荡周期 $T$。从第一性原理出发，使用核心定义将一个振荡周期内停止前沿前进的距离与新生体节的前后长度 $S$ 联系起来。接下来，认识到在分节后，体节的前后长度在组织学固定前会有一个分数增长 $\\gamma$，并且固定和处理过程会导致由分数损失 $s$ 表示的各向同性收缩。\n\n给定以下实验测定值：\n- 从动态图测得的停止前沿速度 $u = 1.6\\ \\text{µm}\\ \\text{min}^{-1}$。\n- 分节时钟周期 $T = 90\\ \\text{min}$。\n- 固定前沿前后维度的分数增长 $\\gamma = 0.05$。\n- 固定后组织学测量的体节长度 $S_{\\text{hist}} = 130\\ \\text{µm}$。\n\n仅使用分节时钟和波阵面的核心定义，首先根据实时动态图的测量值计算预测的新生体节长度 $S$（以微米为单位）。然后，推导并计算收缩分数 $s$，该分数能够使预测的活体体节长度（包括固定前指定的分数增长 $\\gamma$）与固定组织的组织学测量值 $S_{\\text{hist}}$ 相吻合。\n\n以小数形式报告最终答案，即收缩分数 $s$。将最终答案四舍五入至三位有效数字。最终答案中不要包含任何单位。",
            "solution": "问题陈述经评估有效。它在科学上基于已确立的脊椎动物体节发生的“钟-波阵面”模型，问题设定良好，数据充分且一致，并以客观方式表述。所提供的参数，如分节时钟周期和波阵面速度，在鸟类胚胎的生理现实范围内。该问题要求逻辑性地应用核心定义来推导一个具有物理意义的量。\n\n按照要求，解答过程分两个阶段进行。首先，根据动态图的测量值计算新生体节的长度 $S$。其次，将此值与分节后的生长和组织学测量值一同使用，以确定收缩分数 $s$。\n\n“钟-波阵面”模型的核心原理是，在分节时钟的每个周期 $T$ 内形成一个体节。这个新生体节的前后长度 $S$ 由决定波阵面在此时间间隔内沿体节前中胚层行进的距离决定。鉴于波阵面以恒定速度 $u$ 移动，长度 $S$ 由速度与时间的乘积给出：\n$$S = uT$$\n使用实验测定值 $u = 1.6 \\text{ µm min}^{-1}$ 和 $T = 90 \\text{ min}$：\n$$S = (1.6 \\text{ µm min}^{-1}) \\times (90 \\text{ min}) = 144 \\text{ µm}$$\n这是从体节前中胚层形成体节后，立即预测出的体节前后长度。\n\n接下来，我们考虑在最终组织学测量前改变此长度的生物学和技术过程。问题陈述，体节经历生长，其前后长度增加了一个分数 $\\gamma = 0.05$。生长后的长度，我们记为 $S_{\\text{grown}}$，是：\n$$S_{\\text{grown}} = S + \\gamma S = S(1 + \\gamma)$$\n代入计算出的 $S$ 值：\n$$S_{\\text{grown}} = 144 \\text{ µm} \\times (1 + 0.05) = 144 \\text{ µm} \\times 1.05 = 151.2 \\text{ µm}$$\n\n在此生长之后，组织被固定并进行组织学处理，这导致了各向同性收缩。这种收缩表示为从生长后长度 $S_{\\text{grown}}$ 中损失的一个分数 $s$。因此，组织学切片上最终测量的长度 $S_{\\text{hist}}$ 与 $S_{\\text{grown}}$ 的关系如下：\n$$S_{\\text{hist}} = S_{\\text{grown}} - s S_{\\text{grown}} = S_{\\text{grown}}(1 - s)$$\n题目要求我们求出收缩分数 $s$。我们可以重新排列这个方程来求解 $s$：\n$$1 - s = \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\n$$s = 1 - \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\n现在，我们可以代入 $S_{\\text{grown}}$ 和 $S$ 的表达式，得到一个用主要给定值表示 $s$ 的单一公式：\n$$s = 1 - \\frac{S_{\\text{hist}}}{S(1 + \\gamma)} = 1 - \\frac{S_{\\text{hist}}}{uT(1 + \\gamma)}$$\n使用给定值 $S_{\\text{hist}} = 130 \\text{ µm}$ 和先前计算出的值 $S_{\\text{grown}} = 151.2 \\text{ µm}$：\n$$s = 1 - \\frac{130 \\text{ µm}}{151.2 \\text{ µm}}$$\n$$s = 1 - 0.859788...$$\n$$s \\approx 0.140211...$$\n问题要求最终答案四舍五入至三位有效数字。\n$$s \\approx 0.140$$",
            "answer": "$$\\boxed{0.140}$$"
        }
    ]
}