{
    "hands_on_practices": [
        {
            "introduction": "成人干细胞群，例如造血干细胞（HSC），必须在生物体的整个生命周期内通过自我更新和分化之间的精细平衡来维持其数量的稳定。这项练习将指导你建立一个简洁而强大的数学模型来理解这种平衡，即“稳态”。通过推导实现稳态所需的条件，你将从定量的角度深入理解细胞的分裂模式和存活率是如何共同调控组织维持的。",
            "id": "4931794",
            "problem": "一个造血干细胞（HSC）以离散的代际进行随机分裂，其命运选项如下：对称性自我更新，以概率 $p_{s}$ 产生两个HSC；不对称分裂，以概率 $p_{a}$ 产生一个HSC和一个定向祖细胞；以及对称性分化，以概率 $p_{d}$ 产生两个定向祖细胞（因此产生零个HSC）。假设 $p_{s}+p_{a}+p_{d}=1$，并且每个新产生的HSC子细胞以 $1-\\alpha$ 的概率独立存活到下一代，其中 $\\alpha \\in [0,1)$ 代表由微环境介导的耗损或细胞凋亡。使用这些后代概率和存活率，将HSC的数量建模为一个Galton–Watson分支过程。\n\n令 $\\Delta N$ 表示由单个分裂的HSC从一代到下一代所贡献的HSC数量变化，即 $\\Delta N = N_{t+1}-N_{t}$，其中对于所追踪的亲代细胞，$N_{t}=1$。利用概率论中期望的基本定义和上述后代分布，推导出以 $p_{s}$、$p_{a}$、$p_{d}$ 和 $\\alpha$ 表示的预期净变化 $\\mathbb{E}[\\Delta N]$。然后施加稳态条件 $\\mathbb{E}[\\Delta N]=0$，并求解维持稳定HSC群体所需的自我更新概率 $p_{s}$，使其成为 $p_{d}$ 和 $\\alpha$ 的函数。请以仅含 $p_{d}$ 和 $\\alpha$ 的稳态自我更新概率 $p_{s}^{*}$ 的封闭形式表达式给出最终答案。不需要数值近似或四舍五入。",
            "solution": "### 第一步：提取已知条件\n-   单个造血干细胞（HSC）进行随机分裂。\n-   命运选项及其概率：\n    -   对称性自我更新（产生 $2$ 个HSC）：概率 $p_{s}$。\n    -   不对称分裂（产生 $1$ 个HSC）：概率 $p_{a}$。\n    -   对称性分化（产生 $0$ 个HSC）：概率 $p_{d}$。\n-   概率约束：$p_{s}+p_{a}+p_{d}=1$。\n-   每个新产生的HSC子细胞以 $1-\\alpha$ 的概率存活到下一代。\n-   $\\alpha \\in [0,1)$ 是耗损或细胞凋亡的概率。\n-   HSC的数量被建模为一个Galton–Watson分支过程。\n-   $\\Delta N$ 是由单个亲代HSC引起的HSC数量变化，即 $\\Delta N = N_{t+1}-N_{t}$，其中 $N_{t}=1$。\n-   目标是推导预期净变化 $\\mathbb{E}[\\Delta N]$，然后求解稳态自我更新概率 $p_{s}^{*}$（其中 $\\mathbb{E}[\\Delta N]=0$），使其成为 $p_{d}$ 和 $\\alpha$ 的函数。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学依据**：该问题使用标准的Galton-Watson分支过程来模拟干细胞群体动态。对称/不对称分裂、自我更新、分化和细胞凋亡等概念在干细胞生物学和组织学中是基础且公认的。该模型是一个简化模型，但在科学上是合理的。\n-   **问题适定**：该问题在数学上是适定的。概率被恰当约束，变量被清晰描述。任务是推导一个表达式并求解一个方程，这是一个标准的数学过程。存在唯一且有意义的解。\n-   **客观性**：问题以精确、客观的语言陈述，没有歧义或主观论断。\n\n### 第三步：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n问题要求计算从单个造血干细胞（HSC）开始，从一代到下一代HSC数量的预期净变化。设 $N_t$ 为第 $t$ 代的HSC数量。我们从单个亲代细胞开始，所以 $N_t = 1$。设 $N_{t+1}$ 为源自该单个亲代并在下一代存活的HSC数量。\n\n这个过程可以分解为两个阶段：分裂和存活。\n\n首先，亲代HSC分裂。设 $D$ 为表示此次分裂产生的HSC子细胞数量的随机变量。根据问题陈述，$D$ 的概率分布为：\n-   $P(D=2) = p_{s}$ (对称性自我更新)\n-   $P(D=1) = p_{a}$ (不对称分裂)\n-   $P(D=0) = p_{d}$ (对称性分化)\n\n分裂后立即产生的HSC的期望数量 $\\mathbb{E}[D]$ 为：\n$$\n\\mathbb{E}[D] = (2 \\times P(D=2)) + (1 \\times P(D=1)) + (0 \\times P(D=0))\n$$\n$$\n\\mathbb{E}[D] = 2p_{s} + p_{a}\n$$\n\n其次，这 $D$ 个子细胞中的每一个都必须存活下来才能计入下一代。每个子细胞以 $1-\\alpha$ 的概率独立存活。设 $N_{t+1}$ 为存活的HSC数量。存活细胞的期望数量 $\\mathbb{E}[N_{t+1}]$ 可以使用全期望定律求得：$\\mathbb{E}[N_{t+1}] = \\mathbb{E}[\\mathbb{E}[N_{t+1}|D]]$。\n\n给定产生了 $D=k$ 个子细胞，存活者的数量遵循一个具有 $k$ 次试验和成功概率为 $1-\\alpha$ 的二项分布。这个二项分布的期望是 $k(1-\\alpha)$。所以，$\\mathbb{E}[N_{t+1}|D=k] = k(1-\\alpha)$。\n现在，我们可以计算无条件期望 $\\mathbb{E}[N_{t+1}]$：\n$$\n\\mathbb{E}[N_{t+1}] = \\sum_{k \\in \\{0, 1, 2\\}} \\mathbb{E}[N_{t+1}|D=k] P(D=k)\n$$\n$$\n\\mathbb{E}[N_{t+1}] = [2(1-\\alpha)]p_{s} + [1(1-\\alpha)]p_{a} + [0(1-\\alpha)]p_{d}\n$$\n$$\n\\mathbb{E}[N_{t+1}] = (1-\\alpha)(2p_{s} + p_{a})\n$$\n或者，存活者的期望数量是产生的子细胞期望数量乘以单个存活概率：$\\mathbb{E}[N_{t+1}] = \\mathbb{E}[D] \\times (1-\\alpha) = (2p_{s} + p_{a})(1-\\alpha)$。\n\n来自这个单个亲代的HSC数量的净变化是 $\\Delta N = N_{t+1} - N_{t}$。因为我们从一个细胞开始，所以 $N_t=1$。\n预期净变化为：\n$$\n\\mathbb{E}[\\Delta N] = \\mathbb{E}[N_{t+1} - 1] = \\mathbb{E}[N_{t+1}] - 1\n$$\n$$\n\\mathbb{E}[\\Delta N] = (1-\\alpha)(2p_{s} + p_{a}) - 1\n$$\n这就是预期净变化的表达式。\n\n接下来，我们施加稳态条件，即要求HSC的期望数量保持恒定。这意味着预期净变化必须为零：$\\mathbb{E}[\\Delta N] = 0$。\n$$\n(1-\\alpha)(2p_{s} + p_{a}) - 1 = 0\n$$\n问题要求解出稳态自我更新概率 $p_{s}^{*}$，使其仅为 $p_{d}$ 和 $\\alpha$ 的函数。为此，我们必须从方程中消去 $p_{a}$。我们使用给定的约束条件 $p_{s} + p_{a} + p_{d} = 1$，这意味着 $p_{a} = 1 - p_{s} - p_{d}$。\n\n将 $p_{a}$ 的这个表达式代入稳态方程：\n$$\n(1-\\alpha)(2p_{s} + (1 - p_{s} - p_{d})) - 1 = 0\n$$\n现在，我们简化括号内的项：\n$$\n(1-\\alpha)(p_{s} + 1 - p_{d}) - 1 = 0\n$$\n我们现在求解 $p_{s}$，在此条件下即为 $p_{s}^{*}$：\n$$\n(1-\\alpha)(p_{s}^{*} + 1 - p_{d}) = 1\n$$\n因为 $\\alpha \\in [0, 1)$，所以项 $1-\\alpha$ 非零，我们可以用它来除：\n$$\np_{s}^{*} + 1 - p_{d} = \\frac{1}{1-\\alpha}\n$$\n分离出 $p_{s}^{*}$：\n$$\np_{s}^{*} = \\frac{1}{1-\\alpha} - 1 + p_{d}\n$$\n为了简化表达式的第一部分，我们通分：\n$$\np_{s}^{*} = \\frac{1 - (1-\\alpha)}{1-\\alpha} + p_{d}\n$$\n$$\np_{s}^{*} = \\frac{1 - 1 + \\alpha}{1-\\alpha} + p_{d}\n$$\n$$\np_{s}^{*} = \\frac{\\alpha}{1-\\alpha} + p_{d}\n$$\n这就是以耗损概率 $\\alpha$ 和对称性分化概率 $p_{d}$ 表示的稳态自我更新概率 $p_{s}^{*}$ 的最终封闭形式表达式。",
            "answer": "$$\\boxed{\\frac{\\alpha}{1-\\alpha} + p_{d}}$$"
        },
        {
            "introduction": "多能性是一个功能性定义，指的是单个干细胞能够分化形成所有三个胚层（外胚层、中胚层和内胚层）细胞的能力。这项练习挑战你像一位严谨的实验生物学家一样思考，设计一个能够明确检验细胞多能性的决定性实验。通过比较不同的实验方案，你将认识到在证明细胞真实潜能时，克隆分析和无偏见的培养条件为何至关重要，这也是干细胞研究中一块重要的基石。",
            "id": "4931742",
            "problem": "一位高年级本科生被要求从基本原理出发，推断干细胞的发育潜能如何受到谱系轨迹闭合的限制，并设计一个可证伪的检验来区分多能祖细胞和多潜能祖细胞。从核心定义和广为接受的事实开始：多能祖细胞（例如，胚胎干细胞（ESC）或诱导性多能干细胞（iPSC））在容许性条件下可以产生所有$3$个胚层（外胚层、中胚层、内胚层）的衍生物，而多潜能祖细胞则产生一组与其来源组织相适应的有限命运。在谱系推理中，一条轨迹可以形式化为一个有向无环图（DAG）$G=(V,E)$，其节点$V$是细胞状态，边$E$是转换；闭合意味着一旦路径进展到一个更受限制的节点，上游的选项便不可逆地丧失（无环路），并且终末分化的节点是吸收态。根据分子生物学的中心法则和发育生物学中经过充分验证的观察，命运决定涉及基因调控网络的稳定变化，这些变化施加了不可逆的限制，并可通过谱系特异性的转录程序读出。\n\n一个可证伪的检验必须明确假设、可测量的结果以及防止混淆因素的对照，并且必须在克隆分辨率下操作，以便在没有群体平均效应的情况下探究单个祖细胞的发育潜能。考虑以下旨在利用轨迹闭合概念来区分多能祖细胞和多潜能祖细胞的实验方案。\n\n哪个选项最好地阐述了发育潜能与谱系轨迹闭合的关系，并同时提出了一个可在无偏倚条件下区分多能祖细胞和多潜能祖细胞的、可证伪的单细胞克隆检验？\n\nA. 通过基于CRISPR的谱系追踪将可遗传的独特条形码引入单个、经流式分选的祖细胞中，并在一个为所有$3$个胚层设计成容许性和无偏倚的环境中培养每个克隆（例如，补充了允许外胚层、中胚层和内胚层分化的限定培养基）。在多个时间点$t_1,t_2,t_3$，进行单细胞RNA测序（scRNA-seq），使用参考图谱将每个子细胞分配到一个胚层身份，并从条形码重建每个克隆的谱系DAG $G$。陈述可证伪的假设：$H_0$（细胞是多潜能的）预测对于一个给定的克隆$c$，其在胚层间的分布满足$p_{\\text{ecto}}(c)+p_{\\text{meso}}(c)+p_{\\text{endo}}(c)\\leq 2$个非零项，并且$G$中的路径闭合到吸收态的一个子集上；$H_1$（细胞是多能的）预测在相同环境下$p_{\\text{ecto}}(c),p_{\\text{meso}}(c),p_{\\text{endo}}(c)>0$，并观察到随着轨迹的定向分化，发生不可逆的闭合。单个克隆对所有$3$个胚层都产生非零贡献即可证伪$H_0$；在重复实验中未能做到这一点则证伪$H_1$。\n\nB. 通过将异质性的候选祖细胞群体皮下注射到免疫缺陷小鼠体内，进行批量畸胎瘤分析，并在$8$周后对来自所有$3$个胚层的组织进行组织学评分。将三谱系组织的存在解释为存在多能细胞的证据，而其缺失则作为多潜能性的证据。\n\nC. 对培养的祖细胞使用免疫染色法检测与多能性相关的转录因子（例如，Oct$4$, Sox$2$, Nanog），并将多能性定义为标记阳性，多潜能性定义为标记阴性。通过测量分化后Oct$4$的丢失来验证闭合。\n\nD. 将$\\geq 10$个候选祖细胞组成的小细胞簇注射到植入前囊胚中，并检测发育后对组织的嵌合体贡献。将对所有$3$个胚层的组织都有贡献的祖细胞归类为多能祖细胞，将贡献少于$3$个胚层的归类为多潜能祖细胞。\n\nE. 在$4$天内追踪祖细胞的增殖速率和细胞周期时相分布，将多能性定义为高增殖，多潜能性定义为较低增殖，并从分化时增殖的停止来推断闭合。\n\n选择唯一的最佳选项。",
            "solution": "在进行解答之前，首先评估问题陈述的有效性。\n\n### 第1步：提取已知条件\n-   **多能祖细胞（例如，胚胎干细胞（ESC）、诱导性多能干细胞（iPSC））：** 在容许性条件下可以产生所有$3$个胚层（外胚层、中胚层、内胚层）的衍生物。\n-   **多潜能祖细胞：** 产生一组与其来源组织相适应的有限命运。\n-   **谱系轨迹形式化：** 一个有向无环图（DAG）$G=(V,E)$，其中节点$V$是细胞状态，边$E$是转换。\n-   **轨迹闭合：** 当细胞沿着路径进展时，上游发育选项的不可逆丧失。终末分化的节点是吸收态。\n-   **闭合的生物学机制：** 基因调控网络的稳定变化导致转录程序中不可逆的限制。\n-   **对可证伪检验的要求：** 必须明确假设、可测量的结果、对照，并在克隆分辨率下操作以评估单个祖细胞的潜能。\n-   **核心任务：** 找出最能将发育潜能与轨迹闭合联系起来，并提出一个可在无偏倚条件下区分多能祖细胞和多潜能祖细胞的、可证伪的单细胞克隆检验的选项。\n\n### 第2步：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、定义明确的且客观的。\n-   **科学上合理：** 多能性和多潜能性的定义是发育和干细胞生物学中的标准定义。将谱系形式化为有向无环图（$DAG$）是系统生物学中广泛使用和接受的概念模型。命运限制、基因调控网络和转录程序之间的联系是现代发育生物学的基石。对可证伪科学检验的要求是科学方法的基础。\n-   **定义明确：** 问题提供了一套清晰的标准来判断所给选项：潜能/闭合关系的阐述、可证伪性、单细胞克隆分辨率和无偏倚条件。这些标准允许通过逻辑评估确定唯一的最佳答案。\n-   **客观：** 语言技术性强、精确，没有主观或含糊的术语。所有概念要么被正式定义（例如，DAG、闭合），要么是该领域的标准术语。\n\n该问题没有表现出任何诸如科学上不合理、不完整或模棱两可的缺陷。它基于既定原则，提出了一个复杂但有效的实验设计挑战。\n\n### 第3步：结论和行动\n该问题是**有效的**。将根据所述要求分析每个选项来推导出解决方案。\n\n### 正确答案的推导\n\n任务是选择最能满足四个关键标准的选项：1) 它正确地将潜能与轨迹闭合联系起来；2) 它提出了一个可证伪的检验；3) 该检验在克隆（单细胞）分辨率下操作；4) 该检验在无偏倚的条件下进行。\n\n**选项A的分析**\n\n该选项提出了一个结合了多种强大技术的前沿实验。\n1.  **克隆分辨率：** 该方案明确从“单个、经流式分选的祖细胞”开始，并确保使用“可遗传的独特条形码”分别追踪每个克隆。这种设计保证了对单个创始细胞的发育潜能进行探究，完美地满足了克隆分辨率的要求。\n2.  **无偏倚的条件：** 实验在“容许性和无偏倚”的培养基中进行，该培养基旨在支持向所有$3$个胚层的分化。这是一个关键的对照，确保了未能产生某个谱系是由于细胞的内在限制（即多潜能性）而非外在环境的限制。\n3.  **可证伪的检验：** 该选项清晰地阐述了一个零假设（$H_0$：细胞是多潜能的）和一个备择假设（$H_1$：细胞是多能的）。它定义了一个精确、可测量的结果：后代在三个胚层上的分布，其中$p_{\\text{ecto}}(c), p_{\\text{meso}}(c), p_{\\text{endo}}(c)$代表来自克隆$c$的细胞被分配到每个胚层的比例。它为证伪$H_0$提供了一个明确的条件：单个克隆产生所有三个胚层的细胞。这是一个严谨且可证伪的框架。\n4.  **与轨迹闭合的联系：** 该方案明确涉及为每个克隆重建谱系DAG $G$。这使得能够直接观察命运选择和定向分化的不可逆性，这正是轨迹闭合的本质。它正确地预测，对于一个多潜能克隆，“$G$中的路径闭合到吸收态的一个子集上”，而一个多能克隆在“不可逆闭合”发生之前可以进入所有三个主要分支。\n\n该选项以高水平的科学严谨性满足了所有指定标准。\n\n**选项A的结论：正确**\n\n**选项B的分析**\n\n该选项描述了批量畸胎瘤分析。\n1.  **克隆分辨率：** 此检验不满足克隆分辨率的要求。它使用了一个“异质性群体”的细胞。如果形成了具有所有$3$个胚层的畸胎瘤，无法知道它是由一个多能细胞产生的，还是由一组不同的多潜能祖细胞共同产生的，这些祖细胞在总体上产生了三个胚层。\n2.  **无偏倚的条件：** *体内*环境通常被认为是容许性的，但它比选项A中的特定培养基的控制性和明确性要差。\n3.  **可证伪的检验：** 该检验是可证伪的，但其解释被群体平均效应所混淆。阳性结果是模棱两可的。阴性结果（没有三谱系畸胎瘤）强烈表明不存在多能细胞，但并非任何单个细胞为多潜能性的最终证据。\n4.  **与轨迹闭合的联系：** 这是一个简单的终点分析。它没有提供任何关于谱系轨迹或闭合过程的信息。它只对最终结果进行评分。\n\n该选项是一个经典的多能性检验，但它被问题对克隆分辨率的要求明确地否定了。\n\n**选项B的结论：错误**\n\n**选项C的分析**\n\n该选项建议使用分子标记来定义潜能。\n1.  **克隆分辨率：** 可以在单细胞上评估像Oct$4$、Sox$2$和Nanog这样的标记。然而，这个检验混淆了细胞的*状态*（它表达哪些标记）和它的发育*潜能*（它能产生哪些命运）。这些转录因子的存在与多能性有很强的相关性，但并非定义本身。正如问题中所给出的，定义是功能性的。此检验不直接检测形成$3$个胚层的能力。\n2.  **无偏倚的条件：** 不直接适用，因为这不是一个分化分析。\n3.  **可证伪的检验：** 它提出了一个定义，而不是一个关于潜能的可证伪检验。一个细胞可能表达标记但功能上无法分化，或者一个细胞可能失去标记但并未终末分化。\n4.  **与轨迹闭合的联系：** 所做的联系（“通过测量分化后Oct$4$的丢失来验证闭合”）是一种过度简化。闭合是整个基因调控网络中命运潜能的不可逆限制，而不仅仅是单个标记的下调。\n\n该选项失败了，因为它没有直接测试发育潜能，而这正是问题的核心。\n\n**选项C的结论：错误**\n\n**选项D的分析**\n\n该选项描述了嵌合体形成分析。\n1.  **克隆分辨率：** 此检验不满足克隆分辨率的要求，因为它指定注射“由$\\geq 10$个候选祖细胞组成的小细胞簇”。与选项B中的畸胎瘤分析类似，阳性结果（对所有$3$个胚层的贡献）是模棱两可的，可能源于多潜能细胞的混合。问题要求探究*单个*祖细胞。\n2.  **无偏倚的条件：** 植入前囊胚是测试发育潜能的金标准容许性环境，因此这个条件是满足的。\n3.  **可证伪的检验：** 该检验是可证伪的，但与选项B一样，其解释因缺乏克隆性而混淆。\n4.  **与轨迹闭合的联系：** 像畸胎瘤分析一样，这是一个终点分析，没有提供关于谱系限制的动态过程或轨迹图结构的数据。\n\n该选项描述了一种强大的*体内*分析方法，但如其所述，它违反了单细胞克隆分辨率这一关键要求。\n\n**选项D的结论：错误**\n\n**选项E的分析**\n\n该选项建议使用细胞增殖动力学来定义潜能。\n1.  **克隆分辨率：** 虽然可以在克隆水平上测量增殖，但该检验的前提在科学上是有缺陷的。\n2.  **科学基础：** 用“高增殖”来定义多能性是不正确的。虽然许多多能细胞系（如ESC）增殖迅速，但这是一种相关性，而不是一个决定性特征。许多其他类型的细胞，包括癌细胞和过渡扩增的多潜能祖细胞，也增殖迅速。反之，某些多能性的发育状态可以是静止的。这是一个根本上存在缺陷的标准。\n3.  **可证伪的检验：** 假设是可检验的，但它基于一个错误的前提，使得该检验作为多能性的区分标准是无效的。\n4.  **与轨迹闭合的联系：** 这种联系（“从分化时增殖的停止来推断闭合”）是一种严重的过度简化。细胞周期退出通常与终末分化耦合，但它不等同于轨迹闭合的概念，后者是关于命运选择的丧失。\n\n该选项基于一个弱相关性和一个科学上不合理的多能性定义。\n\n**选项E的结论：错误**\n\n**结论**\n选项A是唯一完全满足问题陈述中所有严格要求的方案。它提出了一个现代的、具有克隆分辨率的、可证伪的实验设计，该设计在无偏倚的条件下直接探究发育潜能，并通过DAG重建明确使用了轨迹闭合的形式化概念。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "细胞的分化路径可以被看作是一系列从一个细胞状态到另一个细胞状态的转变，这一过程能够用图论的语言进行优雅地描述。本练习连接了生物学与计算机科学，要求你将多能性的生物学定义转化为一种算法测试。通过应用图搜索算法，你将看到复杂的生物学概念如何被形式化和计算验证，这为分析细胞命运决定提供了强有力的工具。",
            "id": "4931821",
            "problem": "您的任务是在干细胞分化的有向状态转换模型中将多能性形式化，并实现一个算法来测试指定起始状态的多能性。其生物学基础是，多能性是产生所有三个胚层（外胚层、中胚层和内胚层）衍生物的能力。谱系图中的一个节点代表一个细胞状态。一条有向边代表一个从一个状态到另一个状态的允许的分化转换。如果一个节点在允许的转换下可以到达所有三个胚层的终点节点，则该节点是多能性的。\n\n基本基础：\n- 发育生物学中的多能性定义：一个多能性细胞可以分化为所有三个胚层（外胚层、中胚层、内胚层）的衍生物。\n- 有向图的可达性：在有向图 $G=(V,E)$ 中，如果存在一条从节点 $s$ 到节点 $t$ 的长度 $\\ge 0$ 的有向路径，则称节点 $t$ 可从节点 $s$ 到达。\n\n形式上，设 $G=(V,E)$ 是一个有向图，其中 $V$ 是谱系状态的集合，$E \\subseteq V \\times V$ 编码了允许的转换。设 $T=\\{\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$ 表示终末胚层节点的集合。将可达性谓词 $R_G(s,t)$ 定义为当且仅当在 $G$ 中存在一条从 $s$ 到 $t$ 的长度 $\\ge 0$ 的有向路径时为真。定义多能性谓词：\n$$\nP_G(s) = \\bigwedge_{t \\in T} R_G(s,t),\n$$\n也就是说，$P_G(s)$ 为真当且仅当 $s$ 可以到达 $T$ 中所有三个胚层终点。\n\n您的程序必须实现一个图搜索算法，以评估给定测试用例的 $P_G(s)$。程序必须是确定性的，且不得需要任何外部输入。它必须生成单行输出，其格式应精确地为方括号括起来的逗号分隔的布尔结果列表（例如，$[\\mathrm{True},\\mathrm{False}]$）。\n\n测试套件：\n为以下 $8$ 个有向图和查询节点提供结果，这些图和节点旨在探究“理想路径”、受限的多潜能性、终末定向、环以及缺失目标的情况。对于每个图 $G_i=(V_i,E_i)$，集合 $T$ 均假定为相同的 $\\{\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$。\n\n- 测试用例 $1$：$G_1$ 模拟一个胚胎干细胞 (ESC)。\n  $V_1=\\{\\mathrm{ESC},\\mathrm{Epiblast},\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_1=\\{(\\mathrm{ESC},\\mathrm{Epiblast}),(\\mathrm{Epiblast},\\mathrm{Ectoderm}),(\\mathrm{Epiblast},\\mathrm{Mesoderm}),(\\mathrm{Epiblast},\\mathrm{Endoderm})\\}$.\n  查询 $s_1=\\mathrm{ESC}$。预期的生物学行为：多能性的。\n\n- 测试用例 $2$：$G_2$ 模拟一个被重编程为类似 ESC 状态的诱导性多能干细胞 (iPSC)。\n  $V_2=\\{\\mathrm{iPSC},\\mathrm{ESC\\_like},\\mathrm{Epiblast},\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_2=\\{(\\mathrm{iPSC},\\mathrm{ESC\\_like}),(\\mathrm{ESC\\_like},\\mathrm{Epiblast}),(\\mathrm{Epiblast},\\mathrm{Ectoderm}),(\\mathrm{Epiblast},\\mathrm{Mesoderm}),(\\mathrm{Epiblast},\\mathrm{Endoderm})\\}$.\n  查询 $s_2=\\mathrm{iPSC}$。预期的生物学行为：多能性的。\n\n- 测试用例 $3$：$G_3$ 模拟一个造血干细胞 (HSC)，这是一种向中胚层衍生物分化的多潜能性成体干细胞 (ASC)。\n  $V_3=\\{\\mathrm{HSC},\\mathrm{Mesoderm},\\mathrm{Ectoderm},\\mathrm{Endoderm}\\}$,\n  $E_3=\\{(\\mathrm{HSC},\\mathrm{Mesoderm})\\}$.\n  查询 $s_3=\\mathrm{HSC}$。预期的生物学行为：非多能性的。\n\n- 测试用例 $4$：$G_4$ 模拟一个神经干细胞 (NSC)，一种外胚层限定的前体细胞。\n  $V_4=\\{\\mathrm{NSC},\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_4=\\{(\\mathrm{NSC},\\mathrm{Ectoderm})\\}$.\n  查询 $s_4=\\mathrm{NSC}$。预期的生物学行为：非多能性的。\n\n- 测试用例 $5$：$G_5$ 模拟上胚层，它可以生成所有三个胚层。\n  $V_5=\\{\\mathrm{Epiblast},\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_5=\\{(\\mathrm{Epiblast},\\mathrm{Ectoderm}),(\\mathrm{Epiblast},\\mathrm{Mesoderm}),(\\mathrm{Epiblast},\\mathrm{Endoderm})\\}$.\n  查询 $s_5=\\mathrm{Epiblast}$。预期的生物学行为：多能性的。\n\n- 测试用例 $6$：$G_6$ 模拟一个缺失内胚层转换的 ESC 图。\n  $V_6=\\{\\mathrm{ESC},\\mathrm{Epiblast},\\mathrm{Ectoderm},\\mathrm{Mesoderm}\\}$,\n  $E_6=\\{(\\mathrm{ESC},\\mathrm{Epiblast}),(\\mathrm{Epiblast},\\mathrm{Ectoderm}),(\\mathrm{Epiblast},\\mathrm{Mesoderm})\\}$.\n  查询 $s_6=\\mathrm{ESC}$。预期的生物学行为：非多能性的，因为内胚层不可达。\n\n- 测试用例 $7$：$G_7$ 包含一个始发态多能性状态和上胚层之间的环，但保留了通往所有三个胚层的路径。\n  $V_7=\\{\\mathrm{Primed\\_ESC},\\mathrm{Epiblast},\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_7=\\{(\\mathrm{Primed\\_ESC},\\mathrm{Epiblast}),(\\mathrm{Epiblast},\\mathrm{Primed\\_ESC}),(\\mathrm{Epiblast},\\mathrm{Ectoderm}),(\\mathrm{Epiblast},\\mathrm{Mesoderm}),(\\mathrm{Epiblast},\\mathrm{Endoderm})\\}$.\n  查询 $s_7=\\mathrm{Primed\\_ESC}$。预期的生物学行为：多能性的。\n\n- 测试用例 $8$：$G_8$ 直接查询一个终点节点。\n  $V_8=\\{\\mathrm{Ectoderm},\\mathrm{Mesoderm},\\mathrm{Endoderm}\\}$,\n  $E_8=\\varnothing$.\n  查询 $s_8=\\mathrm{Ectoderm}$。预期的生物学行为：非多能性的，因为它无法到达另外两个胚层。\n\n输出规范：\n- 您的程序应生成一行输出，其中包含按顺序排列的测试用例 $1$ 到 $8$ 的结果，格式为方括号括起来的逗号分隔列表，例如 $[\\mathrm{True},\\mathrm{False},\\dots]$。\n- 不涉及物理单位、角度单位或百分比；输出为布尔值。",
            "solution": "该问题要求我们使用有向图模型来形式化并测试生物学中的多能性概念。所提供的多能性定义基于发育生物学和图论的基本原理，使得该问题在科学上和数学上都是合理的。\n\n一个细胞状态被认为是多能性的，如果它可以分化成所有三个主要胚层（外胚层、中胚层和内胚层）的细胞。在给定的模型中，这被转化为一个图论中的可达性问题。使用一个有向图 $G=(V,E)$，其中 $V$ 代表细胞状态（节点）的集合，$E$ 代表允许的分化转换（有向边）的集合。三个胚层由一组固定的终点节点表示，$T=\\{\\mathrm{Ectoderm}, \\mathrm{Mesoderm}, \\mathrm{Endoderm}\\}$。\n\n状态 $s \\in V$ 的多能性通过谓词 $P_G(s)$ 进行评估，其定义如下：\n$$\nP_G(s) = \\bigwedge_{t \\in T} R_G(s,t)\n$$\n在这里，$R_G(s,t)$ 是一个可达性谓词，当且仅当存在一条从状态 $s$ 到状态 $t$ 的长度大于或等于 $0$ 的有向路径时为真。长度为 $0$ 的路径意味着任何节点都可以从其自身到达。逻辑合取（$\\bigwedge$）表示，要使 $s$ 具有多能性，它必须能够到达集合 $T$ 中的*每一个*终点节点。\n\n为了实现一个解决方案，我们必须设计一个算法来为给定的 $8$ 个测试用例中的每一个检查谓词 $P_G(s)$。这涉及到在每个图 $G_i$ 中，验证从给定的起始节点 $s_i$ 到 $T$ 中所有三个目标节点的可达性。\n\n问题的核心是解决可达性谓词 $R_G(s,t)$。用于确定有向图中可达性的一个标准且高效的算法是广度优先搜索（BFS）。对于给定的起始节点 $s$ 和目标节点 $t$，BFS 系统地逐层探索图，保证如果存在到 $t$ 的路径，它就能找到。该算法维护一个待访问节点的队列和一个已访问节点的集合，以避免冗余探索并正确处理带有环的图（如测试用例 $7$）。\n\n评估 $P_G(s)$ 的总体算法如下：\n$1$. 对于给定的图 $G=(V,E)$ 和查询节点 $s$，遍历集合 $T=\\{\\mathrm{Ectoderm}, \\mathrm{Mesoderm}, \\mathrm{Endoderm}\\}$ 中的每个目标节点 $t$。\n$2$. 对于每个 $t$，确定它是否可以从 $s$ 到达。这通过从 $s$ 开始执行一次 BFS 遍历来完成。\n   $a$. 一个重要的初始检查是目标节点 $t$ 是否存在于图的顶点集 $V$ 中。如果 $t \\notin V$，则从任何 $s \\in V$ 到 $t$ 的路径都不可能存在，所以 $R_G(s,t)$ 为假。这与测试用例 $6$ 相关，其中图 $G_6$ 缺少 $\\mathrm{Endoderm}$ 节点。\n   $b$. BFS 遍历从将 $s$ 放入队列开始。然后它重复地从队列中取出一个节点，并对于其每个未访问过的邻居，将其标记为已访问并添加到队列中。如果遇到 $t$，搜索成功终止。如果队列变空而 $t$ 尚未被找到，则 $t$ 从 $s$ 不可达。\n$3$. 如果发现 $T$ 中的任何目标 $t$ 从 $s$ 不可达，则合取式 $P_G(s)$ 变为假。该测试用例的算法可以提前终止，并报告结果为 `False`。\n$4$. 如果算法成功验证了 $T$ 中的所有三个节点都可以从 $s$ 到达，那么 $P_G(s)$ 为真。\n\n此过程应用于所提供的 $8$ 个测试用例中的每一个。每个测试用例的图都构建为一个邻接表，这是一个从每个节点到其直接后继节点列表的映射，由边集 $E_i$ 定义。这种数据结构对于像 BFS 这样的图遍历算法非常高效。最终输出是 $P_{G_1}(s_1), P_{G_2}(s_2), \\dots, P_{G_8}(s_8)$ 的布尔评估结果的有序列表。",
            "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the pluripotency evaluation problem for a series of test cases.\n    \"\"\"\n    \n    # The fixed set of terminal germ layer nodes.\n    T = {\"Ectoderm\", \"Mesoderm\", \"Endoderm\"}\n\n    # Define the 8 test cases as specified in the problem.\n    # Each case is a tuple: (Vertex set V, Edge set E, start node s).\n    test_cases = [\n        # Test case 1: ESC\n        (\n            {\"ESC\", \"Epiblast\", \"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            {(\"ESC\", \"Epiblast\"), (\"Epiblast\", \"Ectoderm\"), (\"Epiblast\", \"Mesoderm\"), (\"Epiblast\", \"Endoderm\")},\n            \"ESC\"\n        ),\n        # Test case 2: iPSC\n        (\n            {\"iPSC\", \"ESC_like\", \"Epiblast\", \"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            {(\"iPSC\", \"ESC_like\"), (\"ESC_like\", \"Epiblast\"), (\"Epiblast\", \"Ectoderm\"), (\"Epiblast\", \"Mesoderm\"), (\"Epiblast\", \"Endoderm\")},\n            \"iPSC\"\n        ),\n        # Test case 3: HSC (multipotent, not pluripotent)\n        (\n            {\"HSC\", \"Mesoderm\", \"Ectoderm\", \"Endoderm\"},\n            {(\"HSC\", \"Mesoderm\")},\n            \"HSC\"\n        ),\n        # Test case 4: NSC (unipotent/multipotent, not pluripotent)\n        (\n            {\"NSC\", \"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            {(\"NSC\", \"Ectoderm\")},\n            \"NSC\"\n        ),\n        # Test case 5: Epiblast\n        (\n            {\"Epiblast\", \"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            {(\"Epiblast\", \"Ectoderm\"), (\"Epiblast\", \"Mesoderm\"), (\"Epiblast\", \"Endoderm\")},\n            \"Epiblast\"\n        ),\n        # Test case 6: Missing Endoderm target node\n        (\n            {\"ESC\", \"Epiblast\", \"Ectoderm\", \"Mesoderm\"},\n            {(\"ESC\", \"Epiblast\"), (\"Epiblast\", \"Ectoderm\"), (\"Epiblast\", \"Mesoderm\")},\n            \"ESC\"\n        ),\n        # Test case 7: Graph with a cycle\n        (\n            {\"Primed_ESC\", \"Epiblast\", \"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            {(\"Primed_ESC\", \"Epiblast\"), (\"Epiblast\", \"Primed_ESC\"), (\"Epiblast\", \"Ectoderm\"), (\"Epiblast\", \"Mesoderm\"), (\"Epiblast\", \"Endoderm\")},\n            \"Primed_ESC\"\n        ),\n        # Test case 8: Querying a terminal node\n        (\n            {\"Ectoderm\", \"Mesoderm\", \"Endoderm\"},\n            set(), # Empty edge set\n            \"Ectoderm\"\n        )\n    ]\n\n    def is_reachable(adj_list, vertex_set, start_node, target_node):\n        \"\"\"\n        Determines if a target_node is reachable from a start_node using BFS.\n        A path of length >= 0 is considered.\n        \"\"\"\n        # A node is not reachable if it's not part of the graph's vertex set.\n        if target_node not in vertex_set:\n            return False\n\n        # A node is always reachable from itself (path of length 0).\n        if start_node == target_node:\n            return True\n\n        q = deque([start_node])\n        visited = {start_node}\n\n        while q:\n            current_node = q.popleft()\n            \n            # Get neighbors from adjacency list\n            neighbors = adj_list.get(current_node, [])\n            \n            for neighbor in neighbors:\n                if neighbor == target_node:\n                    return True\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    q.append(neighbor)\n        \n        return False\n\n    def check_pluripotency(V, E, s, T_targets):\n        \"\"\"\n        Evaluates the pluripotency predicate P_G(s).\n        \"\"\"\n        # Build adjacency list from the edge set for efficient traversal.\n        adj_list = {}\n        for u, v in E:\n            if u not in adj_list:\n                adj_list[u] = []\n            adj_list[u].append(v)\n            \n        # Check reachability for every target in T.\n        for target in T_targets:\n            if not is_reachable(adj_list, V, s, target):\n                return False # If any target is not reachable, P_G(s) is false.\n        \n        # If all targets were reachable, P_G(s) is true.\n        return True\n\n    results = []\n    for V_i, E_i, s_i in test_cases:\n        result = check_pluripotency(V_i, E_i, s_i, T)\n        results.append(result)\n\n    # Format the output as a comma-separated list of booleans in brackets.\n    output_str = f\"[{','.join(str(r).capitalize() for r in results)}]\"\n    print(output_str.replace(\"True\", \"True\").replace(\"False\", \"False\"))\n\nsolve()\n```"
        }
    ]
}