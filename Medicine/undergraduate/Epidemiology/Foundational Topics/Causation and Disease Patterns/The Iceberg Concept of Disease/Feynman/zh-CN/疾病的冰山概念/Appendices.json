{
    "hands_on_practices": [
        {
            "introduction": "要理解一种疾病的全貌，我们的眼光需要超越官方报告的病例数。第一个练习提供了一个基础计算，用于量化“冰山低估因子”，它根据有症状比例和监测效率来揭示隐藏的感染负担。掌握这种计算有助于我们把握疫情的真实规模。",
            "id": "4585457",
            "problem": "一种传染病在一次单一的流行浪潮中在一个封闭的人群中传播。\n\n在疾病自然史框架中，考虑以下核心定义：血清阳性率是指已经感染并产生可检测抗体的人群累积比例；有症状比例是指感染者出现症状的概率；有症状病例中的检测概率是指有症状病例被常规监测系统发现的概率。假设无症状感染者的检测可以忽略不计。\n\n设人口规模为 $N = 1{,}000$。假设血清阳性率为 $0.30$，有症状比例为 $0.25$，有症状病例中的检测概率为 $0.60$。将冰山低估因子定义为真实累积感染人数与监测系统发现的病例数之比。\n\n仅使用上述定义和数值，从第一性原理推导冰山低估因子。将最终答案表示为一个不带单位的最简分数。",
            "solution": "在进行求解之前，先对问题陈述的有效性进行审视。\n\n### 第1步：提取已知条件\n- 人口规模：$N = 1{,}000$\n- 血清阳性率：$S_p = 0.30$\n- 有症状比例：$P_{sym} = 0.25$\n- 有症状病例中的检测概率：$P_{det|sym} = 0.60$\n- 定义：无症状感染者的检测可以忽略不计。\n- 定义：冰山低估因子，此处表示为 $F_u$，是真实累积感染人数与监测系统发现的病例数之比。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题使用了流行病学中标准的、明确定义的概念，特别是“疾病冰山”、血清阳性率和病例检测。这些概念是预防医学和疾病自然史研究的基础。其前提是科学合理的。\n- **适定性**：该问题提供了所有必要的数据和清晰的定义，以推导出唯一的数值解。\n- **客观性**：语言精确且量化，没有主观或含糊的术语。\n- **完整性和一致性**：所提供的值是一致的（概率在 $0$ 和 $1$ 之间）。虽然给出了人口规模 $N$ 和血清阳性率 $S_p$，但将会证明它们与最终的比率无关，这并不构成矛盾，而是该问题结构的一个特点。\n\n### 第3步：结论与行动\n该问题被认为是有效的，因为它具有科学依据、适定、客观且内部一致。将从第一性原理推导出解。\n\n### 解题推导\n令以下变量代表问题中定义的量：\n- $N$：总人口规模，$N = 1{,}000$。\n- $S_p$：血清阳性率，即已感染人群的比例，$S_p = 0.30$。\n- $P_{sym}$：感染者出现症状的概率，$P_{sym} = 0.25$。\n- $P_{det|sym}$：有症状病例被检测到的概率，$P_{det|sym} = 0.60$。\n- $F_u$：冰山低估因子。\n\n问题将冰山低估因子定义为：\n$$\nF_u = \\frac{\\text{真实累积感染人数}}{\\text{检测到的病例数}}\n$$\n\n让我们根据给定信息推导分子和分母的表达式。\n\n首先，分子是真实累积感染人数（$I_{true}$）。这由血清阳性率作用于总人口确定：\n$$\nI_{true} = N \\times S_p\n$$\n\n其次，分母是检测到的病例数（$C_{det}$）。这是一个多步骤的计算。感染被分为有症状和无症状两组。\n- 有症状感染人数（$I_{sym}$）是总感染人数乘以有症状比例：\n$$\nI_{sym} = I_{true} \\times P_{sym} = (N \\times S_p) \\times P_{sym}\n$$\n- 问题陈述中提到，无症状感染者的检测可以忽略不计，我们将其形式化为无症状病例的检测概率为 $0$。因此，所有检测到的病例都必须来自有症状个体库。\n- 检测到的病例数是有症状感染人数乘以有症状病例的检测概率：\n$$\nC_{det} = I_{sym} \\times P_{det|sym} = ((N \\times S_p) \\times P_{sym}) \\times P_{det|sym}\n$$\n\n现在，我们可以将这些表达式代入冰山低估因子 $F_u$ 的定义中：\n$$\nF_u = \\frac{I_{true}}{C_{det}} = \\frac{N \\times S_p}{(N \\times S_p) \\times P_{sym} \\times P_{det|sym}}\n$$\n\n总感染人数的项，$N \\times S_p$，同时出现在分子和分母中，因此可以消掉。这表明低估因子与总人口规模和血清阳性率无关，而仅仅是疾病自然史和检测过程的条件概率的函数。\n$$\nF_u = \\frac{1}{P_{sym} \\times P_{det|sym}}\n$$\n\n现在，我们代入所提供的数值：\n- $P_{sym} = 0.25$\n- $P_{det|sym} = 0.60$\n\n$$\nF_u = \\frac{1}{0.25 \\times 0.60}\n$$\n\n首先，计算分母中的乘积。使用分数通常更清晰：\n$0.25 = \\frac{1}{4}$\n$0.60 = \\frac{6}{10} = \\frac{3}{5}$\n\n乘积是：\n$$\nP_{sym} \\times P_{det|sym} = \\frac{1}{4} \\times \\frac{3}{5} = \\frac{3}{20}\n$$\n\n或者，使用小数：\n$0.25 \\times 0.60 = 0.15$\n\n现在，我们计算最终因子 $F_u$：\n$$\nF_u = \\frac{1}{3/20} = \\frac{20}{3}\n$$\n\n这个因子表明，对于每一个检测到的病例，人群中大约有 $\\frac{20}{3}$ 或 $6.67$ 个真实感染。问题要求答案以最简分数形式表示。\n最终结果是 $\\frac{20}{3}$。",
            "answer": "$$\n\\boxed{\\frac{20}{3}}\n$$"
        },
        {
            "introduction": "我们观察到的“冰山一角”往往被我们使用的观测工具所扭曲。这个练习将探讨不完美的诊断检测（即灵敏度和特异度低于100%）如何误导我们，并教授一项关键技能：如何校正观察到的患病率来估算真实的疾病患病率。这是修正监测数据的基本步骤。",
            "id": "4644789",
            "problem": "在一项针对具有显著亚临床负担（即疾病的“冰山”现象）的感染进行的社区筛查项目中，由于诊断性能不完善，只有一部分真正感染的个体被检测出来，而一些未感染的个体则被错误地归类为阳性。设真实患病率为 $P_{t}$，筛查检测的灵敏度（Se）为 $Se = P(\\text{test} + \\mid \\text{disease})$，特异度（Sp）为 $Sp = P(\\text{test} - \\mid \\text{no disease})$。筛查人群中检测结果为阳性的观测比例即为观测患病率 $\\hat{P}_{o} = P(\\text{test} +)$。\n\n仅使用灵敏度（Se）、特异度（Sp）的定义、全概率定律以及恒等式 $P(\\text{no disease}) = 1 - P(\\text{disease})$，完成以下任务：\n\n1. 从第一性原理出发，推导一个在不完美检测条件下，将观测患病率 $\\hat{P}_{o}$ 与真实患病率 $P_{t}$ 联系起来的通用表达式。\n2. 对该表达式进行代数求解，用 $\\hat{P}_{o}$、$Se$ 和 $Sp$ 来表示 $P_{t}$。\n3. 将您的结果应用于以下筛查场景：观测患病率为 $\\hat{P}_{o} = 0.18$，灵敏度为 $Se = 0.88$，特异度为 $Sp = 0.96$。计算其所隐含的真实患病率 $P_{t}$。\n\n将最终答案表示为小数，并四舍五入到四位有效数字。",
            "solution": "首先，将对问题陈述的科学合理性、完整性和客观性进行验证。\n\n### 第 1 步：提取已知条件\n从问题陈述中逐字提取已知条件如下：\n-   真实患病率：$P_{t}$\n-   灵敏度：$Se = P(\\text{test} + \\mid \\text{disease})$\n-   特异度：$Sp = P(\\text{test} - \\mid \\text{no disease})$\n-   观测患病率：$\\hat{P}_{o} = P(\\text{test} +)$\n-   恒等式：$P(\\text{no disease}) = 1 - P(\\text{disease})$\n-   任务 1：推导一个用 $P_{t}$、$Se$ 和 $Sp$ 表示 $\\hat{P}_{o}$ 的表达式。\n-   任务 2：求解推导出的表达式以得到 $P_{t}$。\n-   任务 3：在 $\\hat{P}_{o} = 0.18$、$Se = 0.88$ 和 $Sp = 0.96$ 的情况下计算 $P_{t}$。最终答案要求是保留四位有效数字的小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据所需标准对问题进行评估：\n-   **科学依据**：该问题在根本上是合理的。它使用了流行病学和概率论中的标准、正确的定义，包括灵敏度、特异度、患病率和全概率定律。“疾病冰山概念”是流行病学中一个公认的比喻，指的是大量未被观察到的（亚临床、未诊断或无症状的）病例，而这类计算与此高度相关。\n-   **适定性**：这是一个适定问题。它提供了执行所要求的推导和计算所需的所有定义和数据。每个步骤都逻辑相连，可以得出一个唯一且有意义的解。$P_t$ 存在唯一解需要满足条件 $Se + Sp - 1 \\neq 0$。给定的值 $Se = 0.88$ 和 $Sp = 0.96$ 得出 $Se + Sp - 1 = 0.84 \\neq 0$，因此对于给定的参数，该问题是定义明确的。\n-   **客观性**：该问题以精确、客观和数学化的语言陈述，没有歧义、主观性和基于观点的论断。\n\n### 第 3 步：结论与行动\n该问题是有效的，因为它具有科学依据、适定性、客观性和完整性。现在我将按要求进行求解。\n\n解答按问题陈述的要求分为三个部分。\n\n#### 第 1 部分：观测患病率 $\\hat{P}_{o}$ 的推导\n观测患病率 $\\hat{P}_{o}$ 是指检测结果为阳性的概率，即 $P(\\text{test} +)$。要将其与真实患病率 $P_{t}$ 关联起来，我们必须考虑整个群体，这个群体由两个互斥且完备的组构成：患病人群和非患病人群。\n\n根据全概率定律，检测结果为阳性的总概率可以表示为在每个组内检测为阳性的概率之和，并按该组的流行率进行加权：\n$$\n\\hat{P}_{o} = P(\\text{test} +) = P(\\text{test} + \\mid \\text{disease}) P(\\text{disease}) + P(\\text{test} + \\mid \\text{no disease}) P(\\text{no disease})\n$$\n我们有以下定义：\n-   真实患病率为 $P(\\text{disease}) = P_{t}$。\n-   灵敏度为 $Se = P(\\text{test} + \\mid \\text{disease})$。\n-   根据概率公理，$P(\\text{no disease}) = 1 - P(\\text{disease}) = 1 - P_{t}$。\n-   特异度定义为 $Sp = P(\\text{test} - \\mid \\text{no disease})$。由于对于给定情况，一次检测的结果只能是阳性或阴性，因此有 $P(\\text{test} + \\mid \\text{no disease}) + P(\\text{test} - \\mid \\text{no disease}) = 1$。所以，一个无病个体检测结果为阳性的概率（即假阳性率）是 $P(\\text{test} + \\mid \\text{no disease}) = 1 - Sp$。\n\n将这些项代入全概率定律的方程中，即可得到观测患病率的期望表达式：\n$$\n\\hat{P}_{o} = (Se)(P_{t}) + (1 - Sp)(1 - P_{t})\n$$\n该表达式将观测患病率与真实患病率以及检测性能特征（灵敏度和特异度）联系起来。\n\n#### 第 2 部分：求解真实患病率 $P_{t}$\n现在我们对第 1 部分推导出的表达式进行代数变换，以求解 $P_{t}$。\n从下式开始：\n$$\n\\hat{P}_{o} = Se \\cdot P_{t} + (1 - Sp)(1 - P_{t})\n$$\n将右侧的 $(1 - Sp)$ 项展开：\n$$\n\\hat{P}_{o} = Se \\cdot P_{t} + 1 - Sp - P_{t} + Sp \\cdot P_{t}\n$$\n将所有含 $P_{t}$ 的项移到方程一侧，所有其他项移到另一侧：\n$$\n\\hat{P}_{o} - 1 + Sp = Se \\cdot P_{t} - P_{t} + Sp \\cdot P_{t}\n$$\n从右侧的项中提取公因子 $P_{t}$：\n$$\n\\hat{P}_{o} + Sp - 1 = (Se + Sp - 1) P_{t}\n$$\n最后，在假设 $Se + Sp - 1 \\neq 0$ 的前提下，将两边同除以系数 $(Se + Sp - 1)$ 来分离出 $P_{t}$：\n$$\nP_{t} = \\frac{\\hat{P}_{o} + Sp - 1}{Se + Sp - 1}\n$$\n这就是用观测患病率 $\\hat{P}_{o}$、灵敏度 $Se$ 和特异度 $Sp$ 表示真实患病率 $P_t$ 的通用表达式。这种关系通常被称为 Rogan and Gladen 公式。\n\n#### 第 3 部分：针对给定场景计算 $P_{t}$\n对于一个特定的筛查场景，我们有以下给定值：\n-   观测患病率 $\\hat{P}_{o} = 0.18$\n-   灵敏度 $Se = 0.88$\n-   特异度 $Sp = 0.96$\n\n我们将这些数值代入第 2 部分推导出的公式中：\n$$\nP_{t} = \\frac{0.18 + 0.96 - 1}{0.88 + 0.96 - 1}\n$$\n首先，我们计算分子：\n$$\n\\text{Numerator} = 0.18 + 0.96 - 1 = 1.14 - 1 = 0.14\n$$\n接下来，我们计算分母：\n$$\n\\text{Denominator} = 0.88 + 0.96 - 1 = 1.84 - 1 = 0.84\n$$\n现在，我们计算该比率以求得 $P_{t}$：\n$$\nP_{t} = \\frac{0.14}{0.84}\n$$\n该分数可简化为：\n$$\nP_{t} = \\frac{14}{84} = \\frac{1}{6}\n$$\n换算成小数，即 $P_{t} = 0.16666...$。问题要求答案四舍五入到四位有效数字。\n$$\nP_{t} \\approx 0.1667\n$$\n因此，社区中该感染的隐含真实患病率约为 $16.67\\%$。观测患病率（$18\\%$）与真实患病率（$16.67\\%$）之间的差异是由于检测的特异度不完善，这导致了假阳性，从而夸大了表观患病率。",
            "answer": "$$\n\\boxed{0.1667}\n$$"
        },
        {
            "introduction": "疾病的暴发是动态的，而非静止的，感染的“冰山”也是如此。本练习将从静态快照转向随时间变化的疫情模拟，融合了传播动态和报告延迟。通过对感染发生与报告之间的时间差进行建模，你将学会如何实时量化“即时冰山”和总的“未见积压病例”。",
            "id": "4644769",
            "problem": "实现一个离散时间的流行病学重建，该重建区分真实感染与延迟和漏报的观测数据，以量化构成水面下即时“冰山”的未见部分。您将使用离散时间下的感染更新概念和报告延迟机制。此任务必须纯粹基于更新过程和带延迟的稀疏化（thinning）的第一性原理来解决，不得依赖于预先封装好的推断程序。\n\n您将获得以下概念基础：\n- 在第 $t$ 天的真实新增感染，记为 $I_t$，是通过更新机制从过去的感染中产生的。具体来说，每一例 $k$ 天前发生的感染会贡献一个由代际间隔权重（以 $k$ 为索引）给出的比例，而整体的乘法缩放由第 $t$ 天的有效再生数（记为 $R_t$）控制。代际间隔权重为非负数，总和为1，并且仅适用于正滞后（即，第 $t$ 天的感染可能源于之前的 $t-1, t-2, \\dots$ 天）。提供了初始条件，以便可以向前计算该过程。\n- 在第 $t$ 天观测到的报告，记为 $Y_t$，是感染过程的一个延迟和稀疏化版本：所有感染中只有一部分（比例为 $\\rho$）最终被报告，并且它们是根据一个非负滞后的延迟分布出现的（即，报告可能与感染发生在同一天，或在几天后）。延迟权重为非负数，总和为1，并且允许同日权重为零。该过程将被确定性地作为期望值处理，不考虑随机噪声。\n- 第 $t$ 天的即时冰山部分是指在第 $t$ 天发生但尚未出现在第 $t$ 天报告中的那部分感染。在某个时间范围结束时的当前未见积压是指截至最后一天累计感染数与累计报告数之差。\n\n您的程序必须：\n1.  根据给定的第 $t=0$ 天的初始感染数、提供的有效再生数序列和代际间隔权重，仅使用上述更新概念，在指定的时间范围内构建真实感染序列 $I_t$。\n2.  根据给定的报告比例和延迟权重，仅使用所述的稀疏化和延迟概念，构建观测报告序列 $Y_t$。\n3.  计算在最后一天 $t=T-1$ 的以下两个值：\n    -   第 $t$ 天的即时冰山数，定义为在第 $t$ 天发生但未包含在第 $t$ 天报告中的感染数量。\n    -   第 $t$ 天的当前未见积压，定义为截至第 $t$ 天的累计感染数减去截至第 $t$ 天的累计报告数。\n\n注意：\n- 将所有量视为实值期望。\n- 所有权重在其各自的支撑集上归一化为总和为 $1$。\n- 时间是离散的，由整数 $t \\in \\{0,1,\\dots,T-1\\}$ 索引。\n- 代际间隔权重仅适用于严格为正的滞后，由 $k \\in \\{1,2,\\dots\\}$ 索引。\n- 报告延迟权重适用于非负滞后，由 $k \\in \\{0,1,\\dots\\}$ 索引。\n- 初始条件由第 $t=0$ 天的值 $I_0$ 给出；对于 $t \\geq 1$，真实感染必须仅由更新概念和先前计算的值生成。\n\n测试套件：\n对于每种情况，您将获得时间范围 $T$、有效再生数序列 $(R_0,\\dots,R_{T-1})$、代际间隔权重 $(w_1,w_2,\\dots,w_m)$、报告延迟权重 $(d_0,d_1,\\dots,d_\\ell)$、报告比例 $\\rho$ 以及初始感染数 $I_0$。\n\n情况 A（中度延迟下的普遍增长）：\n- $T = 8$。\n- $(R_0,\\dots,R_7) = (1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2)$。\n- 代际权重 $(w_1,w_2,w_3) = (0.6, 0.3, 0.1)$。\n- 延迟权重 $(d_0,d_1,d_2) = (0.2, 0.5, 0.3)$。\n- 报告比例 $\\rho = 0.7$。\n- 初始感染 $I_0 = 10$。\n\n情况 B（无当日报告的亚临界情况）：\n- $T = 7$。\n- $(R_0,\\dots,R_6) = (0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9)$。\n- 代际权重 $(w_1,w_2,w_3) = (0.5, 0.3, 0.2)$。\n- 延迟权重 $(d_0,d_1,d_2) = (0.0, 0.6, 0.4)$。\n- 报告比例 $\\rho = 0.5$。\n- 初始感染 $I_0 = 50$。\n\n情况 C（传播能力变化且近乎即时报告）：\n- $T = 7$。\n- $(R_0,\\dots,R_6) = (1.5, 1.2, 1.0, 0.8, 0.8, 0.9, 1.1)$。\n- 代际权重 $(w_1,w_2,w_3) = (0.7, 0.2, 0.1)$。\n- 延迟权重 $(d_0,d_1) = (0.9, 0.1)$。\n- 报告比例 $\\rho = 1.0$。\n- 初始感染 $I_0 = 5$。\n\n情况 D（单一滞后生成与混合延迟）：\n- $T = 3$。\n- $(R_0,R_1,R_2) = (1.3, 0.7, 1.1)$。\n- 代际权重 $(w_1) = (1.0)$。\n- 延迟权重 $(d_0,d_1) = (0.3, 0.7)$。\n- 报告比例 $\\rho = 0.6$。\n- 初始感染 $I_0 = 100$。\n\n输出规范：\n- 对于每种情况，计算两个实数：最后一天 $t=T-1$ 的即时冰山数，以及 $t=T-1$ 的当前未见积压。\n- 将所有四种情况的输出按以下顺序汇总到一个列表中：情况 A 即时冰山，情况 A 积压，情况 B 即时冰山，情况 B 积压，情况 C 即时冰山，情况 C 积压，情况 D 即时冰山，情况 D 积压。\n- 您的程序应生成单行输出，包含用方括号括起来的逗号分隔结果列表（例如，“[$x_1,x_2,\\dots,x_8$]”）。不应打印任何其他文本。",
            "solution": "经评估，用户提供的问题是**有效**的。它在科学上基于已确立的流行病学建模原则，问题陈述清晰，定义了所有必需的参数，并且其表述是客观的。该问题要求实现一个确定性的、离散时间的疾病传播和报告模型，这是计算流行病学中的一项标准任务。\n\n### 1. 模型形式化\n\n该问题描述了两个耦合的离散时间过程：新感染的生成和将这些感染观测为报告病例的过程。\n\n#### 1.1. 真实感染过程 ($I_t$)\n在给定一天 $t$ 的新增感染数，记为 $I_t$，由一个更新过程确定。该过程通过一个代际间隔分布和一个随时间变化的有效再生数 $R_t$，将当前的感染与过去的感染联系起来。代际间隔表示个体从被感染到感染另一个个体之间的时间。所提供的权重 $(w_1, w_2, \\dots, w_m)$ 代表一个离散化的代际间隔分布，其中 $w_k$ 是间隔为 $k$ 天的概率。总和 $\\sum_{k=1}^m w_k = 1$。问题指明这些权重仅适用于正滞后 ($k \\ge 1$)。\n\n第 $t$ 天的总“传染压力”或“感染力”是过去感染的加权和：$\\sum_{k=1}^m w_k I_{t-k}$。有效再生数 $R_t$ 对此压力进行缩放，从而得出新增感染数。因此，对于任何一天 $t \\geq 1$，新增感染数由以下离散更新方程给出：\n$$\nI_t = R_t \\sum_{k=1}^{m} w_k I_{t-k}\n$$\n其中 $m$ 是代际间隔分布中的最大滞后。提供了一个初始条件 $I_0$，并假设对于 $t  0$，$I_t = 0$。序列 $I_t$ 对于 $t \\in \\{1, 2, \\dots, T-1\\}$ 可以迭代计算。\n\n#### 1.2. 观测报告过程 ($Y_t$)\n观测报告 $Y_t$ 是真实感染 $I_t$ 的一个经过稀疏化和延迟的表示。\n- **稀疏化**：所有真实感染中只有一个比例 $\\rho$ 最终会被报告。这通过将感染数乘以 $\\rho$ 来建模。\n- **延迟**：在第 $s$ 天发生的感染会根据一个延迟分布在稍后的某一天 $t \\ge s$ 被报告。所提供的权重 $(d_0, d_1, \\dots, d_\\ell)$ 代表此分布，其中 $d_k$ 是报告延迟 $k$ 天的概率。总和 $\\sum_{k=0}^\\ell d_k = 1$。滞后 $k=0$ 对应于同日报告。\n\n第 $t$ 天的报告数是来自所有当前及过去日期（$s \\le t$）感染的报告总和。对于在第 $s$ 天发生的感染，在第 $t$ 天出现的预期报告数是 $\\rho \\cdot d_{t-s} \\cdot I_s$。对所有可能的感染日期 $s \\le t$ 求和，我们得到：\n$$\nY_t = \\sum_{s=0}^{t} \\rho \\cdot d_{t-s} \\cdot I_s\n$$\n这等价于一个离散卷积。通过替换延迟滞后 $k = t-s$，该公式可以重写为：\n$$\nY_t = \\rho \\sum_{k=0}^{\\ell} d_k I_{t-k}\n$$\n其中 $\\ell$ 是延迟分布中的最大滞后，我们同样假设对于 $t  0$，$I_t = 0$。一旦 $I_t$ 的完整序列已知，这允许迭代计算 $t \\in \\{0, 1, \\dots, T-1\\}$ 的 $Y_t$。\n\n### 2. 量化“冰山”\n\n该问题要求在最后一天 $t=T-1$ 计算两个特定指标。\n\n#### 2.1. 即时冰山数\n这被定义为“在第 $t$ 天发生但未包含在第 $t$ 天报告中的感染数量”。对于在第 $t$ 天发生的感染 $I_t$，其中一部分（比例为 $\\rho$）最终将被报告。在这些报告中，一部分（比例为 $d_0$）将在同一天被报告。因此，在第 $t$ 天源自第 $t$ 天感染的报告数是 $\\rho \\cdot d_0 \\cdot I_t$。即时冰山是第 $t$ 天的总感染数 $I_t$ 减去这个同日报告的部分。\n$$\n\\text{Immediate Iceberg}_t = I_t - (\\rho d_0 I_t) = I_t (1 - \\rho d_0)\n$$\n这个值代表了那些要么永不被报告（比例为 $1-\\rho$），要么将在后续日期报告（比例为 $\\rho(1-d_0)$）的感染。\n\n#### 2.2. 当前未见积压\n这被定义为“截至第 $t$ 天的累计感染数减去截至第 $t$ 天的累计报告数”。这是一个直接的计算：\n$$\n\\text{Unseen Backlog}_t = \\sum_{s=0}^{t} I_s - \\sum_{s=0}^{t} Y_s = \\sum_{s=0}^{t} (I_s - Y_s)\n$$\n这个值代表已经发生但尚未反映在累计报告数据中的感染总数，包括未报告的感染和那些仍在延迟流程中的感染。\n\n### 3. 算法实现\n\n解决方案通过顺序模拟这两个过程然后计算最终指标来实现。\n\n1.  **初始化**：给定时间范围 $T$ 和初始感染数 $I_0$，创建一个大小为 $T$ 的 NumPy 数组 `I`，并设置 `I[0] = I_0`。\n2.  **计算感染**：从 $t=1$ 到 $T-1$ 迭代。在每一步中，根据代际权重 `w` 对数组 `I` 的过去值求和，计算传染压力 $\\sum_{k=1}^{m} w_{k} I_{t-k}$。然后计算 $I_t = R_t \\cdot (\\text{传染压力})$ 并将其存储在 `I[t]` 中。需要注意处理 $t-k  0$ 的边界条件。\n3.  **计算报告**：创建一个大小为 $T$ 的 NumPy 数组 `Y`。从 $t=0$ 到 $T-1$ 迭代。在每一步中，使用现已完整的感染数组 `I` 和延迟权重 `d`，计算卷积和 $\\sum_{k=0}^{\\ell} d_k I_{t-k}$。然后计算 $Y_t = \\rho \\cdot (\\text{卷积和})$ 并将其存储在 `Y[t]` 中。\n4.  **计算最终指标**：\n    -   设置最后一天索引 `t_final = T - 1`。\n    -   获取最后一天的感染数 `I_final = I[t_final]`。\n    -   第一个延迟权重是 $d_0$。即时冰山计算为 `I_final * (1 - rho * d[0])`。\n    -   未见积压计算为 `np.sum(I) - np.sum(Y)`。\n5.  **汇总结果**：将每个测试案例计算出的两个指标按指定顺序收集到一个列表中。然后将此列表格式化为所需的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases, computes results,\n    and prints them in the specified format.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"T\": 8,\n            \"R\": np.array([1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2, 1.2]),\n            \"gen_weights\": np.array([0.6, 0.3, 0.1]),\n            \"delay_weights\": np.array([0.2, 0.5, 0.3]),\n            \"rho\": 0.7,\n            \"I0\": 10.0\n        },\n        {\n            \"T\": 7,\n            \"R\": np.array([0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9]),\n            \"gen_weights\": np.array([0.5, 0.3, 0.2]),\n            \"delay_weights\": np.array([0.0, 0.6, 0.4]),\n            \"rho\": 0.5,\n            \"I0\": 50.0\n        },\n        {\n            \"T\": 7,\n            \"R\": np.array([1.5, 1.2, 1.0, 0.8, 0.8, 0.9, 1.1]),\n            \"gen_weights\": np.array([0.7, 0.2, 0.1]),\n            \"delay_weights\": np.array([0.9, 0.1]),\n            \"rho\": 1.0,\n            \"I0\": 5.0\n        },\n        {\n            \"T\": 3,\n            \"R\": np.array([1.3, 0.7, 1.1]),\n            \"gen_weights\": np.array([1.0]),\n            \"delay_weights\": np.array([0.3, 0.7]),\n            \"rho\": 0.6,\n            \"I0\": 100.0\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        iceberg, backlog = compute_epidemic(**params)\n        results.extend([iceberg, backlog])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_epidemic(T, R, gen_weights, delay_weights, rho, I0):\n    \"\"\"\n    Computes the epidemiological forecast and derives the iceberg metrics.\n\n    Args:\n        T (int): Time horizon.\n        R (np.ndarray): Sequence of effective reproduction numbers.\n        gen_weights (np.ndarray): Generation interval weights (w_1, w_2, ...).\n        delay_weights (np.ndarray): Reporting delay weights (d_0, d_1, ...).\n        rho (float): Reporting fraction.\n        I0 (float): Initial infection count at t=0.\n\n    Returns:\n        tuple: A tuple containing (immediate_iceberg, unseen_backlog).\n    \"\"\"\n\n    # 1. Compute the sequence of true infections I_t\n    I = np.zeros(T, dtype=float)\n    I[0] = I0\n    m = len(gen_weights)\n\n    for t in range(1, T):\n        infectious_pressure = 0.0\n        # Sum over past infections weighted by generation interval distribution\n        # k corresponds to the lag (1, 2, ...), so index for w is k-1\n        for k in range(1, m + 1):\n            if t - k >= 0:\n                infectious_pressure += gen_weights[k - 1] * I[t - k]\n        \n        I[t] = R[t] * infectious_pressure\n\n    # 2. Compute the sequence of observed reports Y_t\n    Y = np.zeros(T, dtype=float)\n    l = len(delay_weights)\n\n    for t in range(T):\n        convolution_sum = 0.0\n        # Sum over current and past infections weighted by delay distribution\n        # k corresponds to the lag (0, 1, ...), so index for d is k\n        for k in range(l):\n            if t - k >= 0:\n                convolution_sum += delay_weights[k] * I[t - k]\n        \n        Y[t] = rho * convolution_sum\n\n    # 3. Compute final metrics for day t = T-1\n    t_final = T - 1\n    I_final = I[t_final]\n\n    # Immediate iceberg: infections on final day not reported on final day\n    d0 = delay_weights[0] if l > 0 else 0.0\n    immediate_iceberg = I_final * (1 - rho * d0)\n\n    # Unseen backlog: cumulative infections minus cumulative reports\n    unseen_backlog = np.sum(I) - np.sum(Y)\n\n    return immediate_iceberg, unseen_backlog\n\nsolve()\n```"
        }
    ]
}