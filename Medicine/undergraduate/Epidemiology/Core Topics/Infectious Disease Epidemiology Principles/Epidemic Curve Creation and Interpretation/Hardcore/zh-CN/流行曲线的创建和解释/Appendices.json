{
    "hands_on_practices": [
        {
            "introduction": "疫情曲线通常比简单的统计模型预测的波动性更大，这往往是由于超级传播事件等复杂因素造成的。本实践将引导你学习如何使用一个关键的统计量——泊松离散指数，来从原始病例计数中正式地检测这种“过度离散”现象 ()。在为疫情数据选择合适的统计模型之前，这是至关重要的一步。",
            "id": "4590076",
            "problem": "一所大学校园爆发了呼吸道感染。流行曲线（按等长时间间隔（每日）统计新发病例的直方图）显示出两个明显的峰值和一个长尾。研究人员怀疑发生了超级传播事件，导致曲线呈现多峰和重尾的特征。使用流行曲线的定义（即每日计数），以及齐次泊松过程的一个经过充分检验的性质（即每个区间都具有独立增量且均值和方差相等），并利用中心极限定理（CLT）对标准化残差之和的近似，请从第一性原理出发，推导一个仅基于曲线区间计数的拟合优度统计量，该统计量用于量化相对于泊松假设的过度离散程度。然后，计算该统计量对于以下$12$个连续每日计数的数值：\n$$ (x_1,\\dots,x_{12})=(2,3,4,5,22,7,5,4,3,18,6,5) $$\n将您的最终数值答案四舍五入到四位有效数字，并以无量纲数的形式表示。",
            "solution": "经评估，该问题陈述有效。它在科学上基于流行病学和统计学原理，问题设置良好，信息充分且一致，措辞客观。该任务是生物统计学中的一个标准练习：推导并计算一个拟合优度统计量，以检验计数数据相对于泊松模型的过度离散性。\n\n目标是推导一个拟合优度统计量，用于量化每日病例计数相对于齐次泊松过程假设的过度离散程度。设每日病例计数序列为 $(x_1, x_2, \\dots, x_N)$，其中 $N$ 是总天数（区间数）。在本问题中，$N=12$。\n\n原假设 $H_0$ 为：这些计数是由一个齐次泊松过程生成的。这意味着计数 $x_i$ 是 $N$ 个独立同分布（i.i.d.）随机变量 $X_1, X_2, \\dots, X_N$ 的实现，每个随机变量都服从具有单一恒定率参数 $\\lambda$ 的泊松分布。我们记为 $X_i \\sim \\text{Pois}(\\lambda)$，其中 $i=1, \\dots, N$。\n\n泊松分布的一个基本性质是其均值和方差相等，即 $E[X_i] = \\lambda$ 和 $\\text{Var}(X_i) = \\lambda$。当观测数据的方差显著大于均值时，就会发生过度离散，这将构成反对泊松模型的证据。\n\n问题要求我们使用标准化残差和中心极限定理（CLT）从第一性原理推导该统计量。对于单个观测值 $x_i$，真实模型下的标准化残差为：\n$$ Z_i = \\frac{x_i - E[X_i]}{\\sqrt{\\text{Var}(X_i)}} = \\frac{x_i - \\lambda}{\\sqrt{\\lambda}} $$\n在 $H_0$ 下，随机变量 $Z_i$ 的均值为 $0$，方差为 $1$。\n\n然而，参数 $\\lambda$ 是未知的，必须从数据中估计。$\\lambda$ 的最大似然估计（也是矩估计）是样本均值：\n$$ \\hat{\\lambda} = \\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x_i $$\n我们将此估计值 $\\bar{x}$ 代入标准化残差的表达式中。通过对这些估计的标准化残差的平方求和，可以构建一个拟合优度统计量。该统计量是泊松模型的皮尔逊卡方统计量，通常称为泊松离散统计量或离散指数统计量。其定义为：\n$$ D = \\sum_{i=1}^{N} \\left( \\frac{x_i - \\bar{x}}{\\sqrt{\\bar{x}}} \\right)^2 = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}{\\bar{x}} $$\n这个统计量 $D$ 衡量的是观测值与估计均值之间总的平方偏差，并由估计均值本身进行缩放。由于分子和分母的单位相同（计数），因此统计量 $D$ 是一个无量纲量。在原假设下，对于足够大的 $N$ 和 $\\lambda$，$D$ 近似服从自由度为 $N-1$ 的卡方分布。当 $D$ 的值相对于 $N-1$ 较大时，表明数据中的方差大于均值，即存在过度离散。\n\n现在我们为给定的数据计算该统计量的数值。\n数据是 $N=12$ 个连续的每日计数：\n$$ (x_1, \\dots, x_{12}) = (2, 3, 4, 5, 22, 7, 5, 4, 3, 18, 6, 5) $$\n首先，我们计算样本均值 $\\bar{x}$：\n$$ \\sum_{i=1}^{12} x_i = 2+3+4+5+22+7+5+4+3+18+6+5 = 84 $$\n$$ \\bar{x} = \\frac{84}{12} = 7 $$\n接下来，我们计算与均值的离差平方和 $\\sum_{i=1}^{12} (x_i - \\bar{x})^2$：\n\\begin{align*}\n\\sum_{i=1}^{12} (x_i - 7)^2 = (2-7)^2 + (3-7)^2 + (4-7)^2 + (5-7)^2 + (22-7)^2 + (7-7)^2 \\\\\n\\quad + (5-7)^2 + (4-7)^2 + (3-7)^2 + (18-7)^2 + (6-7)^2 + (5-7)^2 \\\\\n= (-5)^2 + (-4)^2 + (-3)^2 + (-2)^2 + (15)^2 + (0)^2 \\\\\n\\quad + (-2)^2 + (-3)^2 + (-4)^2 + (11)^2 + (-1)^2 + (-2)^2 \\\\\n= 25 + 16 + 9 + 4 + 225 + 0 + 4 + 9 + 16 + 121 + 1 + 4 \\\\\n= 434\n\\end{align*}\n最后，我们计算统计量 $D$：\n$$ D = \\frac{\\sum_{i=1}^{12} (x_i - \\bar{x})^2}{\\bar{x}} = \\frac{434}{7} = 62 $$\n问题要求答案四舍五入到四位有效数字。确切值为 $62$，表示为四位有效数字是 $62.00$。",
            "answer": "$$\\boxed{62.00}$$"
        },
        {
            "introduction": "原始的每日病例报告数往往充满噪声，流行病学家常用移动平均法来揭示其潜在趋势。然而，这种平滑处理并非没有代价。本练习将引导你通过数学推导，量化移动平均在存在系统性报告模式（如周末效应）时所引入的偏差和时间延迟 ()。理解这些权衡是正确解读平滑后疫情曲线的关键。",
            "id": "4590031",
            "problem": "流行曲线是每日报告病例数的时间序列。为减少此类曲线中的高频变动，分析师通常采用后移移动平均法，但这种平滑处理可能会引入偏差和时间延迟，尤其是在存在系统性的星期效应（“周末效应”）时。考虑以下一个有科学依据的每日报告病例数模型。\n\n假设潜在的每日平均发病率在短期窗口内是一个缓慢变化的函数，并且在最近七天内，可以很好地用线性趋势 $m_t = \\alpha + \\beta t$ 来近似，其中 $t$ 是以天为单位的日期索引，$\\alpha$ 和 $\\beta$ 是常数。第 $t$ 天的观测到的每日病例数，记为 $Y_t$，受到一个依赖于星期几的乘性报告因子的影响。设 $r_{\\mathrm{dow}(t)}$ 为第 $t$ 天的星期因子。将观测到的病例数建模为独立的泊松随机变量 $Y_t \\sim \\mathrm{Poisson}(r_{\\mathrm{dow}(t)}\\, m_t)$，并定义后移 7 日移动平均估计量 $M_t = \\frac{1}{7}\\sum_{i=0}^{6} Y_{t-i}$。\n\n已知在一个截至周一的窗口期内，以下经验性周末模式生效：$r_{\\mathrm{Mon}} = 1.9$，$r_{\\mathrm{Sun}} = 0.5$，$r_{\\mathrm{Sat}} = 0.6$，以及 $r_{\\mathrm{Tue}} = r_{\\mathrm{Wed}} = r_{\\mathrm{Thu}} = r_{\\mathrm{Fri}} = 1.0$。对于这个特定窗口，将 $t$ 视为周一，因此对 $M_t$ 有贡献的七天分别是周一（$i=0$）、周日（$i=1$）、周六（$i=2$）、周五（$i=3$）、周四（$i=4$）、周三（$i=5$）和周二（$i=6$）。\n\n从泊松分布的期望和方差的定义以及每日病例数的独立性出发，推导：\n\n- 在所述线性趋势模型下，移动平均估计量在第 $t$ 天的偏差，定义为 $B_t = \\mathbb{E}[M_t] - m_t$。\n- 移动平均估计量的方差，$\\mathrm{Var}(M_t)$。\n- 估计量在第 $t$ 天引入的有效延迟（以天为单位），定义为 $\\mathbb{E}[M_t]$ 中潜在均值权重的质心，即 $L_t = \\frac{\\sum_{i=0}^{6} i\\, r_{t-i}}{\\sum_{i=0}^{6} r_{t-i}}$，其中 $r_{t-i}$ 表示第 $t-i$ 天对应的星期因子。\n\n然后，在当前潜在均值为 $m_t = 280$ 且局部斜率为 $\\beta = 20$（病例数/天）的条件下，计算 $B_t$、$\\mathrm{Var}(M_t)$ 和 $L_t$ 的数值。将偏差和方差以病例数为单位表示，延迟以天为单位表示。将最终数值答案四舍五入到四位有效数字。以偏差、方差、延迟的顺序将最终结果表示为行向量。",
            "solution": "问题陈述具有科学依据，提法得当且客观。它提出了一个简化但标准的模型，用于流行病学中分析流行曲线，该模型结合了泊松分布的病例数、星期报告效应以及潜在发病率的局部线性趋势。所有变量、常数和目标都得到了明确定义，并提供了足够的信息来推导出一个唯一的、有意义的解。该问题是有效的，可以按所述方式解决。\n\n解决方案要求推导7日后移移动平均估计量 $M_t$ 的偏差（$B_t$）、方差（$\\mathrm{Var}(M_t)$）和有效延迟（$L_t$）的表达式，然后计算它们的数值。\n\n首先，我们确立每日病例数 $Y_t$ 的必要性质。给定 $Y_t \\sim \\mathrm{Poisson}(r_{\\mathrm{dow}(t)}\\, m_t)$，其期望和方差等于其率参数：\n$$\n\\mathbb{E}[Y_t] = \\mathrm{Var}(Y_t) = r_{\\mathrm{dow}(t)}\\, m_t\n$$\n问题陈述指出每日病例数是独立的随机变量。\n\n后移7日移动平均估计量定义为：\n$$\nM_t = \\frac{1}{7}\\sum_{i=0}^{6} Y_{t-i}\n$$\n\n**1. 偏差 $B_t$ 的推导**\n\n估计量 $M_t$ 的偏差定义为 $B_t = \\mathbb{E}[M_t] - m_t$。我们首先计算 $M_t$ 的期望。利用期望的线性性质：\n$$\n\\mathbb{E}[M_t] = \\mathbb{E}\\left[\\frac{1}{7}\\sum_{i=0}^{6} Y_{t-i}\\right] = \\frac{1}{7}\\sum_{i=0}^{6} \\mathbb{E}[Y_{t-i}]\n$$\n代入每个 $Y_{t-i}$ 的期望：\n$$\n\\mathbb{E}[M_t] = \\frac{1}{7}\\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)}\\, m_{t-i}\n$$\n接下来，我们使用潜在均值的线性趋势模型 $m_t = \\alpha + \\beta t$。这使我们能够用 $m_t$ 来表示 $m_{t-i}$：\n$$\nm_{t-i} = \\alpha + \\beta(t-i) = (\\alpha + \\beta t) - \\beta i = m_t - \\beta i\n$$\n将此代入 $\\mathbb{E}[M_t]$ 的表达式中：\n$$\n\\mathbb{E}[M_t] = \\frac{1}{7}\\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} (m_t - \\beta i)\n$$\n我们可以将求和项分开：\n$$\n\\mathbb{E}[M_t] = \\frac{1}{7}\\left( m_t \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} - \\beta \\sum_{i=0}^{6} i\\, r_{\\mathrm{dow}(t-i)} \\right)\n$$\n现在我们可以写出偏差 $B_t$ 的表达式：\n$$\nB_t = \\mathbb{E}[M_t] - m_t = \\left[ \\frac{m_t}{7} \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} - \\frac{\\beta}{7} \\sum_{i=0}^{6} i\\, r_{\\mathrm{dow}(t-i)} \\right] - m_t\n$$\n整理各项，我们得到偏差的通用公式：\n$$\nB_t = m_t \\left( \\frac{1}{7} \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} - 1 \\right) - \\frac{\\beta}{7} \\sum_{i=0}^{6} i\\, r_{\\mathrm{dow}(t-i)}\n$$\n\n**2. 方差 $\\mathrm{Var}(M_t)$ 的推导**\n\n估计量 $M_t$ 的方差计算如下：\n$$\n\\mathrm{Var}(M_t) = \\mathrm{Var}\\left(\\frac{1}{7}\\sum_{i=0}^{6} Y_{t-i}\\right)\n$$\n利用性质 $\\mathrm{Var}(cX) = c^2\\mathrm{Var}(X)$，我们有：\n$$\n\\mathrm{Var}(M_t) = \\left(\\frac{1}{7}\\right)^2 \\mathrm{Var}\\left(\\sum_{i=0}^{6} Y_{t-i}\\right) = \\frac{1}{49} \\mathrm{Var}\\left(\\sum_{i=0}^{6} Y_{t-i}\\right)\n$$\n由于每日病例数 $Y_{t-i}$ 是独立的，它们的和的方差等于它们方差的和：\n$$\n\\mathrm{Var}(M_t) = \\frac{1}{49} \\sum_{i=0}^{6} \\mathrm{Var}(Y_{t-i})\n$$\n代入 $\\mathrm{Var}(Y_{t-i}) = r_{\\mathrm{dow}(t-i)}\\, m_{t-i}$：\n$$\n\\mathrm{Var}(M_t) = \\frac{1}{49} \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)}\\, m_{t-i}\n$$\n这个和与 $\\mathbb{E}[M_t]$ 表达式中的和是相同的，因此我们可以说 $\\mathrm{Var}(M_t) = \\frac{1}{7}\\mathbb{E}[M_t]$。代入线性趋势模型 $m_{t-i} = m_t - \\beta i$，我们得到方差的通用公式：\n$$\n\\mathrm{Var}(M_t) = \\frac{1}{49} \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} (m_t - \\beta i) = \\frac{1}{49} \\left( m_t \\sum_{i=0}^{6} r_{\\mathrm{dow}(t-i)} - \\beta \\sum_{i=0}^{6} i\\, r_{\\mathrm{dow}(t-i)} \\right)\n$$\n\n**3. 有效延迟 $L_t$ 的推导**\n\n有效延迟 $L_t$ 在问题陈述中被定义为权重 $r_{t-i}$ 在延迟指数 $i$ 上的质心：\n$$\nL_t = \\frac{\\sum_{i=0}^{6} i\\, r_{t-i}}{\\sum_{i=0}^{6} r_{t-i}}\n$$\n其中 $r_{t-i}$ 是 $r_{\\mathrm{dow}(t-i)}$ 的简写。无需进一步推导；这是一个需要计算的定义公式。\n\n**数值计算**\n\n给定一个截至周一（第 $t$ 天）的窗口的以下数值：\n- $r_{t-0}$ (周一): $r_0 = 1.9$\n- $r_{t-1}$ (周日): $r_1 = 0.5$\n- $r_{t-2}$ (周六): $r_2 = 0.6$\n- $r_{t-3}$ (周五): $r_3 = 1.0$\n- $r_{t-4}$ (周四): $r_4 = 1.0$\n- $r_{t-5}$ (周三): $r_5 = 1.0$\n- $r_{t-6}$ (周二): $r_6 = 1.0$\n- 第 $t$ 天的潜在均值：$m_t = 280$\n- 局部斜率：$\\beta = 20$\n\n首先，我们计算所需的和：\n$$\n\\sum_{i=0}^{6} r_{t-i} = 1.9 + 0.5 + 0.6 + 1.0 + 1.0 + 1.0 + 1.0 = 7.0\n$$\n$$\n\\sum_{i=0}^{6} i\\, r_{t-i} = (0)(1.9) + (1)(0.5) + (2)(0.6) + (3)(1.0) + (4)(1.0) + (5)(1.0) + (6)(1.0)\n$$\n$$\n\\sum_{i=0}^{6} i\\, r_{t-i} = 0 + 0.5 + 1.2 + 3.0 + 4.0 + 5.0 + 6.0 = 19.7\n$$\n\n现在我们计算 $B_t$、$\\mathrm{Var}(M_t)$ 和 $L_t$。\n\n- **延迟 ($L_t$):**\n$$\nL_t = \\frac{\\sum_{i=0}^{6} i\\, r_{t-i}}{\\sum_{i=0}^{6} r_{t-i}} = \\frac{19.7}{7.0} \\approx 2.8142857... \\text{ 天}\n$$\n四舍五入到四位有效数字，$L_t = 2.814$ 天。\n\n- **偏差 ($B_t$):**\n$$\nB_t = m_t \\left( \\frac{1}{7} \\sum_{i=0}^{6} r_{t-i} - 1 \\right) - \\frac{\\beta}{7} \\sum_{i=0}^{6} i\\, r_{t-i}\n$$\n$$\nB_t = 280 \\left( \\frac{7.0}{7} - 1 \\right) - \\frac{20}{7} (19.7) = 280(0) - \\frac{394}{7} = -56.285714... \\text{ 病例}\n$$\n四舍五入到四位有效数字，$B_t = -56.29$ 病例。负偏差表明移动平均估计量滞后于真实的上升趋势。\n\n- **方差 ($\\mathrm{Var}(M_t)$):**\n$$\n\\mathrm{Var}(M_t) = \\frac{1}{49} \\left( m_t \\sum_{i=0}^{6} r_{t-i} - \\beta \\sum_{i=0}^{6} i\\, r_{t-i} \\right)\n$$\n$$\n\\mathrm{Var}(M_t) = \\frac{1}{49} \\left( (280)(7.0) - (20)(19.7) \\right) = \\frac{1}{49} (1960 - 394) = \\frac{1566}{49}\n$$\n$$\n\\mathrm{Var}(M_t) = 31.959183... \\text{ 病例}^2\n$$\n四舍五入到四位有效数字，$\\mathrm{Var}(M_t) = 31.96$ 病例$^2$。\n\n偏差、方差和延迟的最终结果（四舍五入到四位有效数字）分别为 $-56.29$、$31.96$ 和 $2.814$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -56.29  31.96  2.814\\end{pmatrix}}\n$$"
        },
        {
            "introduction": "确定疫情高峰是公共卫生评估中的一个关键任务，但从充满噪声的数据中观察到的高峰日仅仅是一个估计值。本实践将介绍一种强大的计算方法——参数自助法（parametric bootstrap），来量化我们对高峰时间的不确定性 ()。通过基于观测数据模拟大量可能的疫情曲线，我们可以为真实的高峰时间构建一个置信区间。",
            "id": "4590034",
            "problem": "给定几个假设疫情爆发在等时间间隔内的病例数。流行曲线定义为每个时间间隔内病例数的序列，其中每个计数被建模为计数过程的独立实现。为了量化高峰时间的不确定性，您的任务是使用病例数的自助法重抽样（bootstrap resampling）为高峰时间构建一个置信区间（CI）。为明确起见，将高峰时间定义为观测到最大计数的“最早”时间索引。\n\n基本假设和定义：\n- 每个区间的病例数被建模为独立泊松随机变量的实现，这是计数数据的常用模型。设时间索引 $t$ 处的观测计数为 $c_t$，其中 $t$ 的范围从 $0$ 到 $T - 1$，$T$ 是流行曲线中的区间总数。\n- 高峰时间估计量是观测计数最大值出现的“最早”索引，表示为一个整数索引，其中第一个区间为 $0$。\n- 自助法置信区间（BCI）是通过重复重抽样合成的病例数并为每个重抽样样本重新计算高峰时间来构建的。使用百分位法：下界是自助法高峰时间分布的经验 $q_{\\ell}$ 分位数，上界是经验 $q_u$ 分位数。\n\n您必须编写一个完整的、可运行的程序，该程序为每个测试用例计算：\n- 观测到的高峰时间索引（观测到的最大计数值的最早索引）。\n- 使用参数化自助法重抽样的高峰时间百分位 BCI 的下界和上界，其中，对于每个区间 $t$，自助法计数是从均值等于观测计数 $c_t$ 的泊松分布中独立抽取的。\n\n科学与计算要求：\n- 使用 $B$ 次自助法复制。\n- 使用分位数概率 $q_{\\ell}$ 和 $q_u$，其中 $q_{\\ell} \\in (0,1)$ 和 $q_u \\in (0,1)$ 且 $q_{\\ell}  q_u$，以小数形式表示（不带百分号）。\n- 在识别高峰时，通过选择达到最大值的最早索引来解决并列问题。\n- 时间单位是由整数索引的区间，您必须将其报告为整数索引。将最终的高峰时间估计值和界限表示为整数索引（单位：时间区间，第一个区间标记为 $0$）。\n\n测试套件：\n对于每个测试用例，您将得到一个元组 $(\\text{counts}, B, q_{\\ell}, q_u, s)$，其中 $\\text{counts}$ 是每个区间的病例数列表，$B$ 是自助法复制的次数，$q_{\\ell}$ 是下分位数概率，$q_u$ 是上分位数概率，$s$ 是用于可复现性的随机种子。\n\n- 测试用例 $1$ (单峰曲线):\n  - $\\text{counts} = [\\,0,\\,1,\\,3,\\,7,\\,12,\\,20,\\,27,\\,23,\\,15,\\,9,\\,5,\\,3,\\,2,\\,1,\\,0\\,]$\n  - $B = 4000$\n  - $q_{\\ell} = 0.025$\n  - $q_u = 0.975$\n  - $s = 12345$\n\n- 测试用例 $2$ (两个相等的峰值，通过最早索引处理并列情况):\n  - $\\text{counts} = [\\,0,\\,2,\\,5,\\,9,\\,12,\\,15,\\,15,\\,12,\\,9,\\,5,\\,2,\\,0\\,]$\n  - $B = 4000$\n  - $q_{\\ell} = 0.025$\n  - $q_u = 0.975$\n  - $s = 67890$\n\n- 测试用例 $3$ (平坦零值，边界情况):\n  - $\\text{counts} = [\\,0,\\,0,\\,0,\\,0,\\,0\\,]$\n  - $B = 4000$\n  - $q_{\\ell} = 0.025$\n  - $q_u = 0.975$\n  - $s = 13579$\n\n最终输出规范：\n- 对于每个测试用例，输出一个包含三个整数的列表 $[\\,\\hat{t}_{\\text{peak}},\\,L,\\,U\\,]$，其中 $\\hat{t}_{\\text{peak}}$ 是观测到的高峰索引，$L$ 是百分位 BCI 的下界，$U$ 是百分位 BCI 的上界。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表，每个测试用例由其自己的方括号列表表示（例如，$[\\,[\\,a,b,c\\,],\\,[\\,d,e,f\\,],\\,[\\,g,h,i\\,]\\,]$）。所有报告的值都必须是指定单位（时间区间）的整数，第一个区间标记为 $0$。",
            "solution": "该问题定义明确、科学上合理且计算上可行。所有必要的数据、参数和定义都已提供。这些假设，例如将病例数建模为独立的泊松随机变量，并使用参数化自助法进行置信区间估计，在流行病学领域是标准且适当的。因此，该问题被认为是 **有效的**。\n\n任务是为几个流行曲线计算观测到的高峰时间以及基于百分位法的自助置信区间 (BCI)。高峰时间定义为出现最大病例数的“最早”时间索引。\n\n**1. 理论框架**\n\n设观测到的病例数序列表示为 $\\mathbf{c} = (c_0, c_1, \\ldots, c_{T-1})$，其中 $c_t$ 是时间索引 $t$ 处的计数，$T$ 是时间区间的总数。\n\n**观测高峰时间估计量 ($\\hat{t}_{\\text{peak}}$):**\n高峰时间估计量 $\\hat{t}_{\\text{peak}}$ 定义为对应于最大观测计数的“最早”时间索引。在数学上，这表示为：\n$$\n\\hat{t}_{\\text{peak}} = \\min \\{ t \\in \\{0, 1, \\ldots, T-1\\} \\mid c_t = \\max_{i=0}^{T-1} c_i \\}\n$$\n这等同于许多数值库中的 `argmax` 函数，该函数返回最大值的第一次出现时的索引。\n\n**用于不确定性估计的参数化自助法：**\n该问题指定了一个参数化自助法程序，以量化 $\\hat{t}_{\\text{peak}}$ 估计中的不确定性。这涉及以下假设和步骤：\n\n- **模型假设：**每个观测计数 $c_t$ 被视为一个独立泊松随机变量 $C_t \\sim \\text{Poisson}(\\lambda_t)$ 的实现。\n- **参数估计：**每个时间 $t$ 的泊松分布的率参数 $\\lambda_t$ 通过观测计数 $c_t$ 来估计。即 $\\hat{\\lambda}_t = c_t$。\n- **重抽样：**生成大量的（$B$ 个）“自助法复制”或合成的流行曲线。对于每个复制 $b \\in \\{1, 2, \\ldots, B\\}$，创建一个新的计数序列 $\\mathbf{c}^{*(b)} = (c_0^{*(b)}, c_1^{*(b)}, \\ldots, c_{T-1}^{*(b)})$。每个合成计数 $c_t^{*(b)}$ 是从估计的分布中进行的独立随机抽取：\n$$\nc_t^{*(b)} \\sim \\text{Poisson}(\\hat{\\lambda}_t) = \\text{Poisson}(c_t)\n$$\n- **估计量的自助法分布：**对于每个合成曲线 $\\mathbf{c}^{*(b)}$，重新计算高峰时间估计量，得到一个自助法高峰时间 $\\hat{t}_{\\text{peak}}^{*(b)}$。\n$$\n\\hat{t}_{\\text{peak}}^{*(b)} = \\min \\{ t \\in \\{0, 1, \\ldots, T-1\\} \\mid c_t^{*(b)} = \\max_{i=0}^{T-1} c_i^{*(b)} \\}\n$$\n这 $B$ 个值的集合，$\\{\\hat{t}_{\\text{peak}}^{*(1)}, \\hat{t}_{\\text{peak}}^{*(2)}, \\ldots, \\hat{t}_{\\text{peak}}^{*(B)}\\}$，构成了高峰时间的经验自助法分布。\n\n**百分位置信区间：**\n$(1 - (\\alpha_{\\ell} + \\alpha_u)) \\times 100\\%$ 的百分位 BCI 是通过取排序后的自助法分布的经验分位数来构建的。给定下分位数和上分位数概率 $q_{\\ell}$ 和 $q_u$（其中，对于对称 CI，$q_{\\ell} = \\alpha/2$ 且 $q_u = 1 - \\alpha/2$），置信区间界限 $[L, U]$ 为：\n- $L$：自助法分布 $\\{\\hat{t}_{\\text{peak}}^*\\}$ 的第 $q_{\\ell}$ 经验分位数。\n- $U$：自助法分布 $\\{\\hat{t}_{\\text{peak}}^*\\}$ 的第 $q_u$ 经验分位数。\n\n$\\hat{t}_{\\text{peak}}$、$L$ 和 $U$ 的最终值必须报告为整数，因为它们代表时间索引。\n\n**2. 算法实现**\n\n对于由 $(\\text{counts}, B, q_{\\ell}, q_u, s)$ 指定的每个测试用例：\n\n1.  **初始化：**为了可复现性，将随机数生成器的种子设置为 $s$。将输入的 `counts` 列表转换为一个 NumPy 数组，我们称之为 $\\mathbf{c}_{\\text{obs}}$。设 $T$ 为此数组的长度。\n\n2.  **计算观测高峰时间：**使用 `numpy.argmax()` 从 $\\mathbf{c}_{\\text{obs}}$ 计算 $\\hat{t}_{\\text{peak}}$，该函数直接实现了所需定义（最大值的最早索引）。\n\n3.  **自助法循环：**\n    a. 初始化一个空列表或数组 `bootstrap_peak_times`，用于存储每次复制的高峰时间。\n    b. 重复 $B$ 次：\n        i. 生成一个长度为 $T$ 的合成计数向量 $\\mathbf{c}^*$。这是通过以向量化方式从泊松分布中抽样完成的，其中第 $t$ 个元素从 $\\text{Poisson}(c_{\\text{obs}, t})$ 中抽取。在 NumPy 中，这是 `rng.poisson(c_obs)`。\n        ii. 计算此合成向量的高峰时间，$\\hat{t}_{\\text{peak}}^* = \\text{np.argmax}(\\mathbf{c}^*)$。\n        iii. 将 $\\hat{t}_{\\text{peak}}^*$ 附加到 `bootstrap_peak_times` 列表中。\n\n4.  **确定置信界限：**\n    a. 循环结束后，将 `bootstrap_peak_times` 转换为 NumPy 数组。\n    b. 通过计算 `bootstrap_peak_times` 数组的 $q_{\\ell}$ 和 $q_u$ 分位数来计算下界 $L$ 和上界 $U$。为此使用 `numpy.quantile()` 函数。\n    c. 根据问题陈述的要求，将可能因插值而为浮点数的分位数结果值转换为整数。通过强制转换为 `int` 进行截断是满足此要求的直接且标准的方法。\n\n5.  **格式化输出：**为当前测试用例存储三元组 $[\\hat{t}_{\\text{peak}}, L, U]$。处理完所有用例后，将收集到的结果格式化为指定的最终字符串。\n\n此过程将应用于提供的每个测试用例。使用固定的随机种子 $s$ 可确保随机的自助法过程为每个用例产生确定性且可验证的答案。对于所有计数均为零的测试用例，所有时间点的泊松率参数 $\\lambda$ 均为 $0$。$\\lambda=0$ 的泊松分布只产生值 $0$。因此，每个自助法复制也将是一个零向量，其高峰时间将始终为 $0$，从而导致置信区间为 $[0, 0]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the observed peak time and a percentile-based Bootstrap Confidence Interval (BCI)\n    for the peak time of epidemic curves.\n    \"\"\"\n    \n    # Test suite: (counts, B, q_l, q_u, s)\n    test_cases = [\n        # Test case 1 (unimodal curve)\n        (\n            [0, 1, 3, 7, 12, 20, 27, 23, 15, 9, 5, 3, 2, 1, 0],\n            4000, 0.025, 0.975, 12345\n        ),\n        # Test case 2 (two equal peaks, tie handled by earliest index)\n        (\n            [0, 2, 5, 9, 12, 15, 15, 12, 9, 5, 2, 0],\n            4000, 0.025, 0.975, 67890\n        ),\n        # Test case 3 (flat zeros, boundary case)\n        (\n            [0, 0, 0, 0, 0],\n            4000, 0.025, 0.975, 13579\n        )\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        counts, B, q_l, q_u, s = case\n        \n        # Convert counts to a NumPy array\n        observed_counts = np.array(counts, dtype=np.int64)\n\n        # Step 1: Calculate the observed peak time (earliest index of max)\n        observed_peak_time = np.argmax(observed_counts)\n\n        # Step 2: Set up the random number generator for reproducibility\n        rng = np.random.default_rng(s)\n\n        # Step 3: Perform parametric bootstrap resampling\n        bootstrap_peak_times = np.zeros(B, dtype=np.int64)\n        \n        # In the edge case where all observed counts are 0, the Poisson parameter is 0.\n        # A Poisson(0) distribution always yields 0. Thus, every bootstrap sample will be\n        # all zeros, and the argmax will always be 0. We can optimize this.\n        if np.all(observed_counts == 0):\n            # bootstrap_peak_times is already initialized to all zeros.\n            pass\n        else:\n            for i in range(B):\n                # Generate one synthetic epidemic curve\n                # Each new count is drawn from a Poisson distribution with mean = observed count\n                synthetic_counts = rng.poisson(lam=observed_counts)\n                \n                # Calculate the peak time for the synthetic curve\n                bootstrap_peak_times[i] = np.argmax(synthetic_counts)\n\n        # Step 4: Construct the percentile confidence interval\n        # Calculate the lower and upper quantiles of the bootstrap distribution\n        # The problem requires integer indices as output. We cast the float result\n        # of the quantile function to int.\n        lower_bound = int(np.quantile(bootstrap_peak_times, q_l))\n        upper_bound = int(np.quantile(bootstrap_peak_times, q_u))\n        \n        # Step 5: Collect results for this case\n        result = [int(observed_peak_time), lower_bound, upper_bound]\n        all_results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n\n```"
        }
    ]
}