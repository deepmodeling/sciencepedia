{
    "hands_on_practices": [
        {
            "introduction": "年龄-时期-队列 (Age-Period-Cohort, APC) 分析的核心在于年龄 ($a$)、时期 ($p$) 和出生队列 ($c$) 这三个时间尺度之间的内在联系。这个练习将帮助你掌握它们之间最基本的关系：$c \\approx p - a$。通过一个直接的计算，你将固化对这三个变量如何相互关联的理解，这是进行更复杂APC模型分析的基础 。",
            "id": "4571535",
            "problem": "一个基于人群的癌症登记系统按单一年龄和日历年汇总了病例数和人时。数据被组织成一个矩形阵列，其中每个单元格对应一个年龄-时期-队列（APC）组合。设 $a$ 表示日历年中点的足岁年龄，$p$ 表示日历年，$c$ 表示出生队列年份。在APC分析中，每个APC单元格由 $(a,p)$ 索引，其中 $a \\in \\{0,1,2,\\dots,99\\}$ 且 $p \\in \\{1995,1996,\\dots,2010\\}$，并且队列索引 $c$ 的定义必须与流行病学中关于年龄（自出生后流逝的时间）和时期（日历时间）的定义保持一致。\n\n给定登记系统中的一个单元格：在日历年 $p = 2009$ 观测到的年龄为 $a = 37$，新发病例数为 $N_{37,2009} = 54$，人年数为 $Y_{37,2009} = 17{,}300$。请使用与上述年龄和时期的基本定义相符的科学一致的 $a$、$p$ 和 $c$ 索引方法，确定此APC单元格的队列索引 $c$。答案以整数日历年的形式表示。无需四舍五入。",
            "solution": "该问题要求确定特定年龄-时期-队列（APC）数据单元格的出生队列年份，用索引 $c$ 表示。给定的单元格由年龄索引 $a$ 和时期索引 $p$ 定义。\n\n**步骤1：问题验证**\n\n首先，我将提取给定信息并验证问题陈述。\n\n**已知条件：**\n*   年龄索引：$a = 37$ 岁，定义为“日历年中点的足岁年龄”。\n*   时期索引：$p = 2009$，定义为日历年。\n*   队列索引：$c$，定义为出生队列年份。\n*   $a$、$p$ 和 $c$ 之间的关系必须“与流行病学中关于年龄（自出生后流逝的时间）和时期（日历时间）的定义保持一致”。\n*   单元格 $(a,p) = (37, 2009)$ 的附加数据：新发病例数 $N_{37,2009} = 54$ 和人年数 $Y_{37,2009} = 17,300$。\n\n**验证：**\n1.  **科学依据**：该问题基于流行病学和生物统计学的既定原则，特别是年龄-时期-队列（APC）分析方法。年龄、时期和队列的概念是人口统计学和公共卫生的基础。\n2.  **适定性**：该问题是适定的。年龄、时期和出生队列之间的关系是确定性的。给定这三个变量中的任意两个，第三个通常由一个明确的恒等式指定。问题要求为给定的年龄和时期找到一个单一、唯一的队列索引。\n3.  **客观性**：问题使用了流行病学领域常见的精确、客观的术语进行陈述。\n4.  **缺陷分析**：\n    *   该问题不违反任何科学原则。\n    *   它可以直接形式化，并与APC分析相关。\n    *   所提供的信息（$a=37$, $p=2009$）足以确定 $c$。附加数据（$N_{37,2009}$ 和 $Y_{37,2009}$）在计算率方面具有上下文相关性，但对于确定队列索引本身并非必需。它们没有引入矛盾。\n    *   这些值是现实的，设置是可行的。\n    *   该问题不是不适定的；标准的索引约定提供了一个唯一的答案。虽然在某一年份将人群聚合到“37岁”组中会涉及来自两个相邻出生队列的个体，但单元格 $(a,p)$ 本身的索引通常遵循一个单一、简单的恒等式。\n\n**结论：** 该问题是有效的。\n\n**步骤2：求解推导**\n\n年龄-时期-队列分析的核心在于三个时间尺度之间的相互关系：年龄（$a$）、时期（$p$）和队列（$c$）。\n\n*   **时期 ($p$)** 是日历时间。\n*   **年龄 ($a$)** 是自出生以来流逝的时间。\n*   **队列 ($c$)** 是出生时间。\n\n这三个量不是独立的。对于一个在日历年 $c$ 出生的个体，其在日历年 $p$ 的年龄 $a$ 由当前年份与出生年份之差给出。这引出了APC分析中使用的基本恒等式：\n$$a \\approx p - c$$\n重新整理这个恒等式以求解出生队列年份 $c$ 可得：\n$$c \\approx p - a$$\n在APC模型的背景下，数据被聚合成由年龄 $a$ 和时期 $p$ 的整数值索引的离散单元格，这种近似被视为用于索引队列效应的精确恒等式：\n$$c = p - a$$\n这种线性依赖关系是APC模型的一个决定性特征，也是“识别问题”的根源，即在不对模型参数施加至少一个约束的情况下，无法唯一地估计年龄、时期和队列各自的线性效应。问题陈述中要求的“科学一致的索引”指的就是这个基本恒等式。\n\n问题提供了所讨论单元格的年龄和时期索引的具体值：\n*   年龄索引：$a = 37$\n*   时期索引：$p = 2009$\n\n将这些值代入队列索引恒等式中：\n$$c = 2009 - 37$$\n进行减法运算得出队列年份：\n$$c = 1972$$\n因此，2009年年龄为37岁的APC单元格对应于1972年的出生队列。所提供的新发病例数（$N_{37,2009} = 54$）和人年数（$Y_{37,2009} = 17,300$）的数据用于计算该单元格的发病率，但与确定队列索引 $c$ 的任务无关。",
            "answer": "$$\\boxed{1972}$$"
        },
        {
            "introduction": "在将理论应用于实际之前，我们必须处理原始数据。流行病学研究通常从个体层面的记录（如出生和事件日期）开始，而APC模型则需要分组和汇总后的数据。这个动手实践模拟了从个体日期到APC分组指数（$i_a, i_p, i_c$）的关键数据转换过程，它强调了精确定义（例如“足岁年龄”）和处理日历细节（如闰年）在确保数据质量和分析有效性方面的重要性 。",
            "id": "4571529",
            "problem": "要求您设计并实现一个完整的、可运行的程序，该程序将个人出生日期和事件日期映射到年龄-时期-队列 (Age-Period-Cohort, APC) 指数，并遵循明确定义的分箱方案，然后在一个小型合成数据集上验证映射的正确性。此映射必须遵循基于日历时间和周岁年龄的流行病学标准定义，并且必须纯粹以数学术语表示。\n\n基本依据与定义：\n- 设 $b$ 表示个人的出生日期，$t$ 表示事件日期，两者均遵循公历。\n- 事件发生时的周岁年龄定义为到事件发生日期为止，已经过的完整生日次数。形式上，周岁年龄 $a$ 是满足以下条件的最大整数 $k \\in \\mathbb{Z}_{\\ge 0}$：$b$ 的第 $k$ 个周年纪念日在 $t$ 当天或之前。这意味着 $a = \\text{years}(t) - \\text{years}(b)$，并根据 $t$ 是否发生在事件年份的生日之前进行调整。\n- 日历时期是事件日期的日历年份，记为 $\\text{year}(t)$。\n- 出生队列是出生的日历年份，记为 $\\text{year}(b)$。\n- 对于 2 月 29 日出生的特殊情况，为计算周岁年龄，定义其在非闰年的“生日”为 2 月 28 日。此约定确保了周岁年龄的计算没有歧义。\n\n分箱方案：\n- 年龄从 0 周岁开始，按 5 年为一组进行分箱，使用半开区间 $[0,5)$、$[5,10)$、$[10,15)$ 等。年龄组索引由 $i_a = \\left\\lfloor \\dfrac{a}{5} \\right\\rfloor$ 给出。\n- 时期以 2000 年为锚点，按 5 个日历年为一组进行分箱，使用半开区间 $[2000,2005)$、$[2005,2010)$、$[2010,2015)$ 等。时期组索引为 $i_p = \\left\\lfloor \\dfrac{\\text{year}(t) - 2000}{5} \\right\\rfloor$。\n- 队列以 2000 年为锚点，按 5 个出生年份为一组进行分箱，使用半开区间 $[2000,2005)$、$[2005,2010)$、$[2010,2015)$ 等。队列组索引为 $i_c = \\left\\lfloor \\dfrac{\\text{year}(b) - 2000}{5} \\right\\rfloor$。\n\n算法要求：\n- 给定 $(b, t)$，计算周岁年龄 $a$，然后根据上述定义获得 $i_a$、$i_p$ 和 $i_c$。\n- 处理 $t  b$ 的情况，将其标记为无效。\n- 除明确给出的定义外，不要做任何简化假设。\n\n验证目标：\n- 对于每个测试用例，验证计算出的元组 $(i_a, i_p, i_c)$ 与下面指定的预期元组完全匹配。每个测试用例的输出应为一个布尔值，表示计算出的索引是否与预期索引匹配。无效用例应产生布尔值 $\\text{False}$。\n\n测试套件：\n使用以下 $(b, t)$ 对集合。每个日期均以年-月-日格式给出。对于每个用例，都提供了预期的索引 $(i_a, i_p, i_c)$。这些用例包括一个通用场景、多个边界场景、闰日处理和一个无效用例。\n\n1. $b = 1995\\text{-}06\\text{-}15$, $t = 2007\\text{-}06\\text{-}15$. 预期 $(i_a, i_p, i_c) = (2, 1, -1)$。\n2. $b = 2000\\text{-}01\\text{-}01$, $t = 2000\\text{-}01\\text{-}01$. 预期 $(i_a, i_p, i_c) = (0, 0, 0)$。\n3. $b = 1999\\text{-}12\\text{-}31$, $t = 2004\\text{-}12\\text{-}31$. 预期 $(i_a, i_p, i_c) = (1, 0, -1)$。\n4. $b = 2004\\text{-}02\\text{-}29$, $t = 2010\\text{-}02\\text{-}28$. 预期 $(i_a, i_p, i_c) = (1, 2, 0)$。\n5. $b = 2004\\text{-}02\\text{-}29$, $t = 2012\\text{-}02\\text{-}29$. 预期 $(i_a, i_p, i_c) = (1, 2, 0)$。\n6. $b = 2005\\text{-}01\\text{-}01$, $t = 2010\\text{-}01\\text{-}01$. 预期 $(i_a, i_p, i_c) = (1, 2, 1)$。\n7. $b = 2008\\text{-}05\\text{-}20$, $t = 2008\\text{-}05\\text{-}19$. 预期无效，因此验证布尔值必须为 $\\text{False}$。\n8. $b = 2000\\text{-}07\\text{-}01$, $t = 2005\\text{-}01\\text{-}01$. 预期 $(i_a, i_p, i_c) = (0, 1, 0)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 8 个测试用例的验证结果，格式为方括号内以逗号分隔的列表（例如，$\"[r_1,r_2,\\dots,r_8]\"$），其中每个 $r_k$ 是一个布尔值，表示测试用例 $k$ 计算出的索引是否与预期索引匹配。不应打印任何其他文本。此问题不涉及任何单位、角度或百分比；所有输出均为前述的布尔值。",
            "solution": "该解决方案基于年龄、时期和队列的正式定义，以及在公历上一致的分箱方案。其基本依据是周岁年龄的定义，以及通过日历年份来确定日历时期和出生队列。\n\n步骤 1：定义周岁年龄。\n- 对于一个出生日期为 $b$、事件日期为 $t$ 的个体，周岁年龄 $a$ 是到 $t$ 为止已经过的完整生日次数。形式上，$a$ 是唯一的整数，如果事件日期 $t$ 发生在 $\\text{years}(t)$ 年的生日当天或之后，则 $a = \\text{years}(t) - \\text{years}(b)$；如果 $t$ 发生在该年生日之前，则 $a = \\text{years}(t) - \\text{years}(b) - 1$。这种方法使用日历算术而非小数值年份，确保了流行病学上的一致性。\n- 对于 2 月 29 日出生的情况，在非闰年的生日被定义为 2 月 28 日。此约定确保了周岁年龄的明确计数。\n\n步骤 2：将年龄映射到年龄组索引。\n- 给定 $a$，年龄组索引为 $i_a = \\left\\lfloor \\dfrac{a}{5} \\right\\rfloor$，反映了从 0 开始的 5 年年龄分箱。\n\n步骤 3：将事件日期映射到时期组索引。\n- 设 $\\text{year}(t)$ 为事件日期的日历年份。时期组索引为 $i_p = \\left\\lfloor \\dfrac{\\text{year}(t) - 2000}{5} \\right\\rfloor$，对应于 5 年期分箱 $[2000,2005)$、$[2005,2010)$ 等。这是一种纯粹基于日历的分类，与标准的年龄-时期-队列 (APC) 分析一致。\n\n步骤 4：将出生日期映射到队列组索引。\n- 设 $\\text{year}(b)$ 为出生日期的日历年份。队列组索引为 $i_c = \\left\\lfloor \\dfrac{\\text{year}(b) - 2000}{5} \\right\\rfloor$，对应于出生年份的 5 年期分箱 $[2000,2005)$、$[2005,2010)$ 等。\n\n步骤 5：处理无效输入。\n- 如果 $t  b$，则该场景在时间上是无效的。算法应检测到此情况并将其标记为无效。为进行验证，此类用例必须产生布尔值 $\\text{False}$。\n\n步骤 6：在合成数据集上进行验证。\n- 程序根据上述规则为 8 个测试用例中的每一个计算 $(i_a, i_p, i_c)$。\n- 然后，它将计算出的元组与每个用例的预期元组进行比较。如果 $t  b$，无论索引如何，它都将结果标记为 $\\text{False}$。\n- 每个测试用例的结果是一个布尔值，表示计算出的索引是否与问题描述中指定的预期索引匹配。\n\n基本原理和科学依据：\n- 将年龄定义为周岁年龄是流行病学中广泛使用的方法，因为它对应于已过的生日次数，这与离散年龄组中的风险暴露时间分类相一致。\n- 由日历年定义并以一致的 5 年间隔分组的日历时期和出生队列，遵循了标准的 APC 框架。该分箱方案使用半开区间，确保了边界分配的明确性。\n- 尽管在精确时间层面上，连续时间恒等式 $a = t - b$ 成立，但由于取整运算和日历边界的存在，将其分组到离散的箱中并不能保证在所有情况下都有 $i_c = i_p - i_a$。因此，队列索引是直接从出生年份计算的，而验证是基于明确的预期索引，而不是任何假定的索引恒等关系。\n\n算法说明：\n- 使用公历函数实现日期算术，以确定事件日期是否已达到事件年份中的生日。\n- 对于 2 月 29 日出生的情况，如果事件年份不是闰年，则将该年的生日定义为 2 月 28 日；否则，使用 2 月 29 日。这确保了个体在闰年和非闰年中，其周岁年龄的增长方式是一致的。\n\n最终程序行为：\n- 程序构建测试用例，计算索引，与预期值进行比较，并以列表格式打印包含 8 个布尔值的单行输出。该行是唯一产生的输出，可以被自动检查其正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport datetime\n\ndef is_leap_year(year: int) - bool:\n    \"\"\"Return True if year is a leap year in Gregorian calendar.\"\"\"\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef birthday_in_year(birth_month: int, birth_day: int, year: int) - datetime.date:\n    \"\"\"\n    Compute the birthday date in a given year.\n    For Feb 29 births, use Feb 28 in non-leap years.\n    \"\"\"\n    if birth_month == 2 and birth_day == 29 and not is_leap_year(year):\n        return datetime.date(year, 2, 28)\n    else:\n        return datetime.date(year, birth_month, birth_day)\n\ndef completed_age_years(birth: datetime.date, event: datetime.date) - int | None:\n    \"\"\"\n    Compute completed age in years at event date.\n    Return None if event  birth (invalid).\n    \"\"\"\n    if event  birth:\n        return None\n    # Age difference in years, adjusted by whether event has reached birthday in that year.\n    years_diff = event.year - birth.year\n    # Birthday in event year, with leap day convention handled.\n    bday_this_year = birthday_in_year(birth.month, birth.day, event.year)\n    if event = bday_this_year:\n        return years_diff\n    else:\n        return years_diff - 1\n\ndef age_group_index(age_years: int, width: int = 5) - int:\n    \"\"\"Age group index for completed age using width-year bins starting at 0.\"\"\"\n    return age_years // width\n\ndef period_group_index(event_year: int, anchor_year: int = 2000, width: int = 5) - int:\n    \"\"\"Period group index for calendar year using width-year bins anchored at anchor_year.\"\"\"\n    return (event_year - anchor_year) // width\n\ndef cohort_group_index(birth_year: int, anchor_year: int = 2000, width: int = 5) - int:\n    \"\"\"Cohort group index for birth year using width-year bins anchored at anchor_year.\"\"\"\n    return (birth_year - anchor_year) // width\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (birth_date_str, event_date_str, expected_tuple_or_None)\n    test_cases = [\n        # 1. b=1995-06-15, t=2007-06-15 - expected (i_a, i_p, i_c) = (2,1,-1)\n        (\"1995-06-15\", \"2007-06-15\", (2, 1, -1)),\n        # 2. b=2000-01-01, t=2000-01-01 - expected (0,0,0)\n        (\"2000-01-01\", \"2000-01-01\", (0, 0, 0)),\n        # 3. b=1999-12-31, t=2004-12-31 - expected (1,0,-1)\n        (\"1999-12-31\", \"2004-12-31\", (1, 0, -1)),\n        # 4. b=2004-02-29, t=2010-02-28 - expected (1,2,0)\n        (\"2004-02-29\", \"2010-02-28\", (1, 2, 0)),\n        # 5. b=2004-02-29, t=2012-02-29 - expected (1,2,0)\n        (\"2004-02-29\", \"2012-02-29\", (1, 2, 0)),\n        # 6. b=2005-01-01, t=2010-01-01 - expected (1,2,1)\n        (\"2005-01-01\", \"2010-01-01\", (1, 2, 1)),\n        # 7. Invalid: b=2008-05-20, t=2008-05-19 - expected invalid - False\n        (\"2008-05-20\", \"2008-05-19\", None),\n        # 8. b=2000-07-01, t=2005-01-01 - expected (0,1,0)\n        (\"2000-07-01\", \"2005-01-01\", (0, 1, 0)),\n    ]\n\n    results = []\n\n    for birth_str, event_str, expected in test_cases:\n        by, bm, bd = map(int, birth_str.split(\"-\"))\n        ty, tm, td = map(int, event_str.split(\"-\"))\n        birth = datetime.date(by, bm, bd)\n        event = datetime.date(ty, tm, td)\n\n        age = completed_age_years(birth, event)\n        if age is None:\n            # Invalid case: must be False\n            results.append(False)\n            continue\n\n        ia = age_group_index(age, width=5)\n        ip = period_group_index(event.year, anchor_year=2000, width=5)\n        ic = cohort_group_index(birth.year, anchor_year=2000, width=5)\n\n        computed = (ia, ip, ic)\n        # Compare with expected; if expected is None, it's invalid and should be False\n        is_correct = (expected is not None) and (computed == expected)\n        results.append(is_correct)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "掌握了基本定义和数据准备后，我们来探讨APC分析的理论核心——“可识别性问题” (identification problem)。由于年龄、时期和队列之间存在精确的线性关系 ($c=p-a$)，我们无法在模型中唯一地分离出这三个效应的线性趋势。然而，这个练习将向你展示，尽管线性趋势本身无法识别，但效应的“曲率” (curvatures)（通过二阶差分来衡量）是可估计的，这为我们从数据中提取有意义的、不受模型约束影响的结论提供了可能 。",
            "id": "4571547",
            "problem": "考虑一个用于发病率的标准年龄-时期-队列（APC）模型，其中年龄类别 $a$ 和时期类别 $p$ 中发病率的对数建模为 $\\ln(\\lambda_{ap}) = \\mu + \\alpha_{a} + \\pi_{p} + \\gamma_{c}$，队列类别 $c$ 由恒等式 $c = p - a$ 决定。\n\n假设年龄 $(\\alpha_{a})$、时期 $(\\pi_{p})$ 和队列 $(\\gamma_{c})$ 具有分类效应，并且数据构建在完整的年龄-时期网格上，因此队列索引由年龄和时期唯一确定。\n\n给定 $P = 6$ 个时期类别，其时期效应为 $(\\pi_{1}, \\pi_{2}, \\pi_{3}, \\pi_{4}, \\pi_{5}, \\pi_{6}) = (0.10, 0.18, 0.27, 0.29, 0.31, 0.30)$；以及 $C = 7$ 个队列类别，其队列效应为 $(\\gamma_{1}, \\gamma_{2}, \\gamma_{3}, \\gamma_{4}, \\gamma_{5}, \\gamma_{6}, \\gamma_{7}) = (-0.05, -0.02, 0.01, 0.05, 0.06, 0.06, 0.04)$。\n\n对序列 $\\{f_{k}\\}$ 定义一阶差分算子为 $\\Delta f_{k} = f_{k} - f_{k-1}$，对内部索引定义二阶差分算子为 $\\Delta^{2} f_{k} = \\Delta(\\Delta f_{k}) = f_{k+1} - 2 f_{k} + f_{k-1}$。\n\n从 APC 恒等式 $c = p - a$ 和分类 APC 效应的定义出发，推导在不施加任意约束的情况下，$(\\pi_{p})$ 和 $(\\gamma_{c})$ 的哪些特征是可估计的，然后计算特定的曲率对比 $\\Delta^{2} \\pi_{3}$ 和 $\\Delta^{2} \\gamma_{4}$。最后，给定 $P$ 和 $C$，确定时期和队列效应组合的可估计曲率子空间的维度（以单个整数表示）。\n\n将你的最终答案表示为一个行矩阵，其中包含三个条目，顺序为 $\\Delta^{2} \\pi_{3}$、$\\Delta^{2} \\gamma_{4}$ 和维度。无需四舍五入。不要包含单位。",
            "solution": "该问题被评估为有效。它在科学上基于年龄-时期-队列（APC）模型的统计理论，问题陈述清晰，并提供了足够的信息以获得唯一解，同时使用了客观和精确的术语。\n\n该问题的核心是关于率 $\\lambda_{ap}$ 的年龄-时期-队列（APC）模型，其中索引 $a$ 表示年龄类别，索引 $p$ 表示时期类别。该模型由下式给出：\n$$\n\\ln(\\lambda_{ap}) = \\mu + \\alpha_{a} + \\pi_{p} + \\gamma_{c}\n$$\n队列类别 $c$ 通过恒等式 $c = p - a$ 与年龄和时期呈线性相关。这种精确的线性关系是 APC 模型中基本不可识别性问题的根源。具体来说，对于任意常数 $k$，以下参数变换\n\\begin{align*}\n\\alpha_{a}^{*} = \\alpha_{a} + k \\cdot a \\\\\n\\pi_{p}^{*} = \\pi_{p} - k \\cdot p \\\\\n\\gamma_{c}^{*} = \\gamma_{c} + k \\cdot c\n\\end{align*}\n不会改变模型的预测值。这可以通过将变换后的参数代入模型方程来证明：\n$$\n\\mu + \\alpha_{a}^{*} + \\pi_{p}^{*} + \\gamma_{c}^{*} = \\mu + (\\alpha_{a} + k \\cdot a) + (\\pi_{p} - k \\cdot p) + (\\gamma_{c} + k \\cdot c)\n$$\n使用恒等式 $c = p - a$，涉及 $k$ 的项会相互抵消：\n$$\n\\mu + \\alpha_{a} + \\pi_{p} + \\gamma_{c} + ka - kp + k(p - a) = \\mu + \\alpha_{a} + \\pi_{p} + \\gamma_{c} + (ka - ka) + (-kp + kp) = \\mu + \\alpha_{a} + \\pi_{p} + \\gamma_{c}\n$$\n由于对于任意 $k$，模型的预测值在这种变换下保持不变，因此单个参数 $\\alpha_{a}$、$\\pi_{p}$ 和 $\\gamma_{c}$ 无法从数据中唯一估计。具体来说，它们的线性趋势（或“漂移”）是混淆的。\n\n如果模型参数的一个函数在所有非识别性变换下其值保持不变，则称该函数是“可估计的”。我们研究二阶差分算子，其定义为 $\\Delta^{2} f_{k} = f_{k+1} - 2 f_{k} + f_{k-1}$。该算子的一个关键性质是它能消除线性函数。如果 $f_k = m \\cdot k + b$，那么 $\\Delta^2 f_k = (m(k+1)+b) - 2(mk+b) + (m(k-1)+b) = m(k+1 - 2k + k-1) + b(1-2+1) = 0$。\n\n让我们将此算子应用于变换后的时期效应 $\\pi_{p}^{*} = \\pi_{p} - k \\cdot p$：\n$$\n\\Delta^{2} \\pi_{p}^{*} = \\Delta^{2} (\\pi_{p} - k \\cdot p) = \\Delta^{2} \\pi_{p} - k \\cdot \\Delta^{2} p\n$$\n由于 $\\Delta^{2} p = (p+1) - 2p + (p-1) = 0$，我们得到：\n$$\n\\Delta^{2} \\pi_{p}^{*} = \\Delta^{2} \\pi_{p}\n$$\n时期效应的二阶差分在此变换下保持不变，因此是一个可估计的函数。这些量通常被称为时期效应的“曲率”。\n\n类似地，对于变换后的队列效应 $\\gamma_{c}^{*} = \\gamma_{c} + k \\cdot c$：\n$$\n\\Delta^{2} \\gamma_{c}^{*} = \\Delta^{2} (\\gamma_{c} + k \\cdot c) = \\Delta^{2} \\gamma_{c} + k \\cdot \\Delta^{2} c\n$$\n由于 $\\Delta^{2} c = (c+1) - 2c + (c-1) = 0$，我们得到：\n$$\n\\Delta^{2} \\gamma_{c}^{*} = \\Delta^{2} \\gamma_{c}\n$$\n队列效应的二阶差分，或称曲率，也是一个可估计的函数。这些二阶差分是在不對模型參數施加任意约束的情况下可以估计的时期和队列效应的主要特征。\n\n接下来，我们使用所提供的数据计算特定的曲率对比 $\\Delta^{2} \\pi_{3}$ 和 $\\Delta^{2} \\gamma_{4}$。\n时期效应为 $(\\pi_{1}, \\pi_{2}, \\pi_{3}, \\pi_{4}, \\pi_{5}, \\pi_{6}) = (0.10, 0.18, 0.27, 0.29, 0.31, 0.30)$。\n时期效应在索引 $p=3$ 处的二阶差分为：\n$$\n\\Delta^{2} \\pi_{3} = \\pi_{4} - 2 \\pi_{3} + \\pi_{2} = 0.29 - 2(0.27) + 0.18 = 0.29 - 0.54 + 0.18 = -0.07\n$$\n\n队列效应为 $(\\gamma_{1}, \\gamma_{2}, \\gamma_{3}, \\gamma_{4}, \\gamma_{5}, \\gamma_{6}, \\gamma_{7}) = (-0.05, -0.02, 0.01, 0.05, 0.06, 0.06, 0.04)$。\n队列效应在索引 $c=4$ 处的二阶差分为：\n$$\n\\Delta^{2} \\gamma_{4} = \\gamma_{5} - 2 \\gamma_{4} + \\gamma_{3} = 0.06 - 2(0.05) + 0.01 = 0.06 - 0.10 + 0.01 = -0.03\n$$\n\n最后，我们确定时期和队列效应组合的可估计曲率子空间的维度。\n时期效应的可估计曲率是所有内部索引 $p$ 的二阶差分集合 $\\{\\Delta^{2} \\pi_{p}\\}$。给定 $P=6$ 个时期类别，内部索引为 $p = 2, 3, 4, 5$。这提供了 $P-2 = 6-2=4$ 个线性无关的可估计对比，它们构成了时期曲率子空间的一组基。\n队列效应的可估计曲率是所有内部索引 $c$ 的二阶差分集合 $\\{\\Delta^{2} \\gamma_{c}\\}$。给定 $C=7$ 个队列类别，内部索引为 $c = 2, 3, 4, 5, 6$。这提供了 $C-2 = 7-2=5$ 个线性无关的可估计对比，它们构成了队列曲率子空间的一组基。\n\n组合的可估计曲率子空间由时期曲率的基向量和队列曲率的基向量的并集张成。由于时期对比仅涉及参数 $\\{\\pi_p\\}$，而队列对比仅涉及参数 $\\{\\gamma_c\\}$，这两组基向量彼此线性无关。因此，组合子空间的维度是个体子空间维度的和。\n$$\n\\text{维度} = (\\text{时期曲率子空间的维度}) + (\\text{队列曲率子空间的维度})\n$$\n$$\n\\text{维度} = (P-2) + (C-2)\n$$\n代入给定值 $P=6$ 和 $C=7$：\n$$\n\\text{维度} = (6-2) + (7-2) = 4 + 5 = 9\n$$\n时期和队列效应组合的可估计曲率子空间的维度是 $9$。\n\n所要求的三个值是 $\\Delta^{2} \\pi_{3} = -0.07$、$\\Delta^{2} \\gamma_{4} = -0.03$ 和维度 $9$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -0.07  -0.03  9 \\end{pmatrix}}\n$$"
        }
    ]
}