{
    "hands_on_practices": [
        {
            "introduction": "在任何严谨的科学研究开始之前，精确的规划是确保实验成功和资源有效利用的关键。本练习将带您体验临床试验设计中的一个核心任务：样本量计算。通过推导和应用样本量公式，您将深入理解第一类错误率 ($\\alpha$)、统计功效 ($1-\\beta$)、效应大小 ($\\Delta$) 和所需样本量 ($n$) 之间的量化关系，这是生物统计学家必备的一项基本技能 。",
            "id": "4941871",
            "problem": "一项随机、平行组临床试验将比较一种新的抗高血压药物与安慰剂在降低收缩压方面的平均效果。设 $\\mu_{1}$ 和 $\\mu_{2}$ 分别表示药物组和安慰剂组的真实平均降低值，并假设组内标准差在各组间是共同的且等于 $\\sigma$。研究者计划每组分配 $n$ 名参与者，并将在显著性水平 $\\alpha = 0.05$ 下检验零假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ 相对于双侧备择假设 $H_{1}: \\mu_{1} - \\mu_{2} \\neq 0$。在计划阶段，他们将标准化均值差 $\\Delta = (\\mu_{1} - \\mu_{2})/\\sigma$ 的大小定为 $\\Delta = 0.40$，认为这具有临床意义，并要求在该备择假设下检验效能达到 $1 - \\beta = 0.90$。假设根据中心极限定理和稳定的方差规划，基于样本均值的双样本$z$统计量在 $H_{0}$ 下近似服从标准正态分布，在 $H_{1}$ 下近似服从均值非零的正态分布。设 $z_{p}$ 表示标准正态分布的 $p$-分位数，定义为 $\\Phi(z_{p}) = p$，其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数。\n\n从I类错误 $\\alpha$、II类错误 $\\beta$ 和检验效能 $1 - \\beta$ 的定义出发，并利用双样本标准化均值差在 $H_{0}$ 和 $H_{1}$ 下的近似分布，确定为达到设计要求所需的最小每组样本量 $n$。报告满足效能要求的最小整数 $n$。最终答案必须是一个不带单位的数字。",
            "solution": "用户希望确定在一项比较新药与安慰剂的随机临床试验中，每组所需的最小样本量 $n$。\n\n### 步骤1：验证问题陈述\n用户提供了以下信息：\n- **组别**：两个平行组（药物组和安慰剂组），每组样本量相等，均为 $n$。\n- **参数**：真实平均降低值 $\\mu_{1}$ (药物) 和 $\\mu_{2}$ (安慰剂)，具有共同的组内标准差 $\\sigma$。\n- **假设**：零假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ vs. 双侧备择假设 $H_{1}: \\mu_{1} - \\mu_{2} \\neq 0$。\n- **显著性水平**：I类错误率 $\\alpha = 0.05$。\n- **效应量**：目标标准化均值差 $\\Delta = (\\mu_{1} - \\mu_{2})/\\sigma = 0.40$。\n- **检验效能**：期望的检验效能为 $1 - \\beta = 0.90$，这意味着II类错误率为 $\\beta = 0.10$。\n- **假设**：使用双样本$z$统计量，该统计量在 $H_{0}$ 下近似服从标准正态分布，在 $H_{1}$ 下近似服从均值非零的正态分布。\n- **符号**：$z_{p}$ 是标准正态分布 $\\Phi(\\cdot)$ 的 $p$-分位数。\n\n该问题具有科学依据、提法明确且客观。这是一个生物统计学中标准样本量计算问题，所有必需的参数和假设都已提供。问题有效。\n\n### 步骤2：推导样本量公式\n设 $\\bar{X}_1$ 和 $\\bar{X}_2$ 分别为药物组和安慰剂组的样本平均收缩压降低值。每组的样本量为 $n$。总体均值差的估计量为 $\\bar{X}_1 - \\bar{X}_2$。\n\n假设组间独立且方差共同为 $\\sigma^2$，该估计量的方差为：\n$$ \\text{Var}(\\bar{X}_1 - \\bar{X}_2) = \\text{Var}(\\bar{X}_1) + \\text{Var}(\\bar{X}_2) = \\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n} = \\frac{2\\sigma^2}{n} $$\n均值差的标准误 (SE) 为：\n$$ \\text{SE} = \\sqrt{\\frac{2\\sigma^2}{n}} = \\sigma\\sqrt{\\frac{2}{n}} $$\n双样本$z$统计量定义为：\n$$ Z_{\\text{obs}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\text{SE}} = \\frac{\\bar{X}_1 - \\bar{X}_2}{\\sigma\\sqrt{2/n}} $$\n在零假设 $H_{0}: \\mu_{1} - \\mu_{2} = 0$ 下，估计量的期望值为 $E[\\bar{X}_1 - \\bar{X}_2] = 0$。根据中心极限定理，检验统计量的分布近似为标准正态分布：\n$$ Z_{\\text{obs}} \\mid H_0 \\sim N(0, 1) $$\n对于显著性水平为 $\\alpha$ 的双侧检验，如果观测统计量的绝对值超过临界值 $c$，我们就拒绝 $H_{0}$。这个临界值是标准正态分布的 $1-\\alpha/2$ 分位数。\n$$ \\text{拒绝域：} |Z_{\\text{obs}}| > z_{1-\\alpha/2} $$\n给定 $\\alpha = 0.05$，我们有 $\\alpha/2 = 0.025$，临界值为 $z_{1-0.025} = z_{0.975}$。\n\n接下来，我们考虑在计划所需的特定备择假设 $H_1: (\\mu_1 - \\mu_2)/\\sigma = \\Delta$ （即 $\\mu_1 - \\mu_2 = \\Delta\\sigma$）下检验统计量的分布。在该备择假设下，估计量的期望值为 $E[\\bar{X}_1 - \\bar{X}_2] = \\Delta\\sigma$。\n在此 $H_1$ 下，检验统计量 $Z_{\\text{obs}}$ 的期望值为：\n$$ E[Z_{\\text{obs}} \\mid H_1] = \\frac{E[\\bar{X}_1 - \\bar{X}_2]}{\\sigma\\sqrt{2/n}} = \\frac{\\Delta\\sigma}{\\sigma\\sqrt{2/n}} = \\Delta\\sqrt{\\frac{n}{2}} $$\n$Z_{\\text{obs}}$ 的方差保持为 $1$。因此，在该备择假设下，其分布为：\n$$ Z_{\\text{obs}} \\mid H_1 \\sim N\\left(\\Delta\\sqrt{\\frac{n}{2}}, 1\\right) $$\n检验效能 $1-\\beta$ 是当 $H_1$ 为真时正确拒绝 $H_0$ 的概率。\n$$ 1 - \\beta = P\\left(|Z_{\\text{obs}}| > z_{1-\\alpha/2} \\mid H_1\\right) $$\n这是双侧尾部拒绝概率之和：\n$$ 1 - \\beta = P\\left(Z_{\\text{obs}} > z_{1-\\alpha/2} \\mid H_1\\right) + P\\left(Z_{\\text{obs}}  -z_{1-\\alpha/2} \\mid H_1\\right) $$\n由于 $\\Delta = 0.40$ 是正数，在 $H_1$ 下 $Z_{\\text{obs}}$ 的均值为正。对于任何合理的样本量，$Z_{\\text{obs}}$ 的分布将向右平移，因此项 $P(Z_{\\text{obs}}  -z_{1-\\alpha/2} \\mid H_1)$ 将可以忽略不计。所以，检验效能主要由上侧尾部的拒绝概率决定。我们可以将检验效能近似为：\n$$ 1 - \\beta \\approx P\\left(Z_{\\text{obs}} > z_{1-\\alpha/2} \\mid H_1\\right) $$\n为了计算这个概率，我们使用随机变量 $Z_{\\text{obs}}$ 在 $H_1$ 下的分布对其进行标准化。设 $Z'$ 是一个标准正态随机变量。\n$$ 1 - \\beta \\approx P\\left( \\frac{Z_{\\text{obs}} - \\Delta\\sqrt{n/2}}{1} > z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}} \\right) $$\n$$ 1 - \\beta \\approx P\\left( Z' > z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}} \\right) $$\n利用标准正态累积分布函数 $\\Phi(\\cdot)$ 的性质 $P(Z' > x) = 1 - \\Phi(x) = \\Phi(-x)$：\n$$ 1 - \\beta \\approx \\Phi\\left( -\\left(z_{1-\\alpha/2} - \\Delta\\sqrt{\\frac{n}{2}}\\right) \\right) = \\Phi\\left( \\Delta\\sqrt{\\frac{n}{2}} - z_{1-\\alpha/2} \\right) $$\n我们已知要求的检验效能是 $1-\\beta$。根据定义，$1-\\beta = \\Phi(z_{1-\\beta})$。令 $\\Phi(\\cdot)$ 的参数相等：\n$$ z_{1-\\beta} = \\Delta\\sqrt{\\frac{n}{2}} - z_{1-\\alpha/2} $$\n现在，我们求解 $n$：\n$$ z_{1-\\alpha/2} + z_{1-\\beta} = \\Delta\\sqrt{\\frac{n}{2}} $$\n$$ \\left(z_{1-\\alpha/2} + z_{1-\\beta}\\right)^2 = \\Delta^2 \\left(\\frac{n}{2}\\right) $$\n$$ n = \\frac{2\\left(z_{1-\\alpha/2} + z_{1-\\beta}\\right)^2}{\\Delta^2} $$\n\n### 步骤3：计算样本量\n我们将给定值代入推导出的公式中。\n- 显著性水平 $\\alpha = 0.05 \\implies z_{1-\\alpha/2} = z_{0.975} \\approx 1.95996$。\n- 检验效能 $1-\\beta = 0.90 \\implies z_{1-\\beta} = z_{0.90} \\approx 1.28155$。\n- 标准化效应量 $\\Delta = 0.40$。\n\n$$ n = \\frac{2(1.95996 + 1.28155)^2}{(0.40)^2} $$\n$$ n = \\frac{2(3.24151)^2}{0.16} $$\n$$ n = \\frac{2(10.50739)}{0.16} $$\n$$ n = \\frac{21.01478}{0.16} $$\n$$ n \\approx 131.342 $$\n由于样本量 $n$ 必须是整数，并且必须满足检验效能要求，我们必须将此值向上取整到下一个整数。\n$$ n = 132 $$\n因此，每组所需的最小样本量为 $132$ 名参与者。",
            "answer": "$$\\boxed{132}$$"
        },
        {
            "introduction": "当数据来自配对设计（例如，对同一受试者进行治疗前后的测量）时，我们需要特殊的统计方法来解释数据点之间的相关性。本练习聚焦于配对二元结果的分析，您将从第一性原理出发，推导McNemar精确检验 。这个过程将揭示统计推断中的一个精妙策略——条件化，即通过对特定统计量（此处为不一致对的总数）设定条件，来消除讨厌参数，从而构建一个简洁而有效的检验。",
            "id": "4941841",
            "problem": "一项配对临床研究评估了一种新疗法对 $50$ 名相同患者治疗前后体内一种二元生物标志物状态（存在/不存在）的变化。对于每位患者，将配对结果定义为 $(Y_{\\text{pre}}, Y_{\\text{post}})$，其中 $Y \\in \\{0,1\\}$ 分别表示生物标志物不存在或存在。观察到的配对结果的 $2 \\times 2$ 表如下：有 $a$ 名患者的结果为 $(1,1)$，$b$ 名为 $(1,0)$，$c$ 名为 $(0,1)$，$d$ 名为 $(0,0)$，其中 $a=18$，$b=17$，$c=7$，$d=8$。\n\n从生物标志物存在的边际概率的原假设 $H_0: p_{\\text{pre}} = p_{\\text{post}}$ 的定义出发，并基于假设检验的第一性原理以及独立配对的伯努利模型，通过以下步骤推导用于配对二元结果的 McNemar 精确检验：\n- 阐明用于消除与总体不一致率相关的讨厌参数的条件化策略的合理性。\n- 指明在原假设 $H_0$ 下，给定总不一致配对数 $D=b+c$ 时，$(1,0)$ 型不一致配对数 $B$ 的分布。\n\n然后，使用您推导出的精确检验，计算观测数据的精确双侧 $p$ 值。将最终数值答案四舍五入到四位有效数字。",
            "solution": "该问题要求推导用于配对二元结果的 McNemar 精确检验，并将其应用于给定数据集以计算双侧 $p$ 值。\n\n首先，我们来形式化这个模型。我们有 $N$ 个独立的配对。对于每一对 $i \\in \\{1, \\dots, N\\}$，其结果为 $(Y_{i, \\text{pre}}, Y_{i, \\text{post}})$，其中每个 $Y$ 可取值为 $0$（生物标志物不存在）或 $1$（生物标志物存在）。每对有四种可能的结果：$(1,1)$、$(1,0)$、$(0,1)$ 和 $(0,0)$。设这些结果的概率分别为 $p_{11}$、$p_{10}$、$p_{01}$ 和 $p_{00}$，使得 $p_{11} + p_{10} + p_{01} + p_{00} = 1$。\n\n治疗前生物标志物存在的边际概率为 $p_{\\text{pre}} = P(Y_{\\text{pre}}=1)$。如果患者的结果是 $(1,1)$ 或 $(1,0)$，那么他的 $Y_{\\text{pre}}=1$。因此，$p_{\\text{pre}} = p_{11} + p_{10}$。\n类似地，治疗后生物标志物存在的边际概率为 $p_{\\text{post}} = P(Y_{\\text{post}}=1)$。如果患者的结果是 $(1,1)$ 或 $(0,1)$，那么他的 $Y_{\\text{post}}=1$。因此，$p_{\\text{post}} = p_{11} + p_{01}$。\n\n原假设 $H_0$ 是边际概率相等：$H_0: p_{\\text{pre}} = p_{\\text{post}}$。将用联合概率表示的表达式代入，我们得到：\n$$H_0: p_{11} + p_{10} = p_{11} + p_{01}$$\n从两边减去 $p_{11}$，原假设简化为：\n$$H_0: p_{10} = p_{01}$$\n这意味着原假设等价于陈述从存在变为不存在的概率与从不存在变为存在的概率相同。那些状态未发生变化的配对，即所谓的一致对（结果为 $(1,1)$ 和 $(0,0)$），对这个特定原假设的评估没有贡献，因为它们的基础概率 $p_{11}$ 和 $p_{00}$ 不涉及简化后的 $H_0$。\n\n观测数据包含四种结果中每一种的计数：$a$ 对应 $(1,1)$，$b$ 对应 $(1,0)$，$c$ 对应 $(0,1)$，$d$ 对应 $(0,0)$。对于总共 $N=a+b+c+d$ 对配对，观察到这些计数的似然函数服从多项分布：\n$$L(p_{11}, p_{10}, p_{01}, p_{00} | a, b, c, d) \\propto p_{11}^a p_{10}^b p_{01}^c p_{00}^d$$\n在 $H_0$ 下，即 $p_{10} = p_{01} = p_{\\text{discord}}$，似然函数变为：\n$$L \\propto p_{11}^a (p_{\\text{discord}})^b (p_{\\text{discord}})^c p_{00}^d = p_{11}^a p_{\\text{discord}}^{b+c} p_{00}^d$$\n该似然函数依赖于讨厌参数，特别是 $p_{11}$ 和 $p_{\\text{discord}}$（或等价地，$p_{11}$ 和 $p_{00}$，因为概率之和必须为 $1$）。为了构建一个独立于这些讨厌参数的检验，我们使用条件化论证。我们对数据中对于讨厌参数而言是充分统计量的方面进行条件化，使得条件分布仅依赖于感兴趣的参数。\n\n关键的洞见是只关注不一致对，即结果为 $(1,0)$ 和 $(0,1)$ 的配对。不一致对的总数是 $D = b+c$。让我们考虑一个配对是不一致对的*条件下*，其类型为 $(1,0)$ 的条件概率。设这个条件概率为 $\\pi$。\n$$\\pi = P(\\text{结果是} (1,0) | \\text{结果不一致}) = \\frac{P(\\text{结果是} (1,0))}{P(\\text{结果不一致})} = \\frac{p_{10}}{p_{10} + p_{01}}$$\n在原假设 $H_0: p_{10} = p_{01}$ 下，这个条件概率变为：\n$$\\pi_0 = \\frac{p_{10}}{p_{10} + p_{10}} = \\frac{p_{10}}{2p_{10}} = \\frac{1}{2}$$\n这种条件化策略非常有效，因为它产生了一个无参数的零分布。鉴于我们观察到总共 $D = b+c$ 个不一致对，这些配对中的每一个都可以被看作是一个独立的伯努利试验。在 $H_0$ 下，“成功”（观察到 $(1,0)$ 配对）的概率是 $1/2$。因此，在给定不一致对总数 $D$ 的条件下，$(1,0)$ 型配对的数量（用随机变量 $B$ 表示）服从二项分布。\n\n具体来说，在 $H_0$ 下，给定 $D=b+c$ 时 $B$ 的分布是：\n$$B | D=b+c \\sim \\text{Binomial}\\left(n = b+c, p = \\frac{1}{2}\\right)$$\n其概率质量函数由下式给出：\n$$P(B=k | D=n) = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^k \\left(1-\\frac{1}{2}\\right)^{n-k} = \\binom{n}{k} \\left(\\frac{1}{2}\\right)^n$$\n这就是 McNemar 精确检验的基础。\n\n现在，我们将此检验应用于所提供的数据：\n- $a = 18$\n- $b = 17$ (这些是 $(1,0)$ 型的配对)\n- $c = 7$ (这些是 $(0,1)$ 型的配对)\n- $d = 8$\n患者总数为 $N = 18+17+7+8 = 50$。\n\n不一致配对的数量是 $n = b+c = 17+7=24$。\n我们的检验统计量的观测值是 $b_{\\text{obs}} = 17$。\n此检验的零分布是 $\\text{Binomial}(n=24, p=1/2)$。\n\n我们需要计算双侧 $p$ 值。这是观测到与 $b_{\\text{obs}}=17$ 一样极端或更极端的结果的概率。对于像 $\\text{Binomial}(n, 1/2)$ 这样的对称分布，其期望值为 $E[B] = n \\times p = 24 \\times 1/2 = 12$。\n观测值 $17$ 距离均值 $17-12=5$ 个单位。在下尾部同样极端的值是 $12-5=7$。因此，“一样或更极端”对应于观测到 $B \\ge 17$ 或 $B \\le 7$。\n\n双侧 $p$ 值为 $P(B \\ge 17) + P(B \\le 7)$。\n$$p\\text{-value} = \\sum_{k=17}^{24} P(B=k) + \\sum_{k=0}^{7} P(B=k)$$\n$$p\\text{-value} = \\sum_{k=17}^{24} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24} + \\sum_{k=0}^{7} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24}$$\n由于二项式系数的对称性，$\\binom{n}{k} = \\binom{n}{n-k}$。对于我们的情况，$\\binom{24}{17} = \\binom{24}{7}$，$\\binom{24}{18} = \\binom{24}{6}$，依此类推。因此，这两个和相等。\n$$p\\text{-value} = 2 \\times \\sum_{k=17}^{24} \\binom{24}{k} \\left(\\frac{1}{2}\\right)^{24}$$\n我们计算二项式系数的和：\n$\\binom{24}{17} = 346104$\n$\\binom{24}{18} = 134596$\n$\\binom{24}{19} = 42504$\n$\\binom{24}{20} = 10626$\n$\\binom{24}{21} = 2024$\n$\\binom{24}{22} = 276$\n$\\binom{24}{23} = 24$\n$\\binom{24}{24} = 1$\n和为 $346104 + 134596 + 42504 + 10626 + 2024 + 276 + 24 + 1 = 536155$。\n归一化因子是 $(1/2)^{24} = 1/16777216$。\n\np 值为：\n$$p\\text{-value} = 2 \\times \\frac{536155}{16777216} = \\frac{1072310}{16777216}$$\n$$p\\text{-value} \\approx 0.06391404$$\n四舍五入到四位有效数字，我们得到 $0.06391$。",
            "answer": "$$\\boxed{0.06391}$$"
        },
        {
            "introduction": "传统的假设检验通常依赖于对数据分布的特定假设（例如正态性），但在现实世界中这些假设可能不成立。置换检验提供了一种强大且无需分布假设的替代方法，其有效性直接源于研究设计中的随机化过程。在这个实践中，您将为一个分层随机对照试验构建并实施一个置换检验，这需要您编写代码来处理分层结构，并根据排列组合的总数在精确枚举和蒙特卡洛模拟之间进行选择 。这项练习不仅能加深您对假设检验根本逻辑的理解，还能锻炼您作为现代生物统计学家必备的计算和编程能力。",
            "id": "4941799",
            "problem": "您需要为一项具有连续型结果、采用分层随机化的双臂随机对照试验（Randomized Controlled Trial (RCT)）构建一个置换检验。此任务要求您形式化原假设，定义一个利用分层信息的、科学合理的检验统计量，指定一个合适的置换方案，并实现一个程序来计算几个测试用例的基于随机化的双边p值。该程序必须遵循以下设计原则和输出要求。\n\n此推导的基础是基于随机化推断的假设检验定义：在无治疗效应的原假设下，观测到的结果对于治疗分配是不变的，并且任何检验统计量在原假设下的分布都可以通过根据随机化方案置换治疗标签来获得。具体来说，在分层随机化下，以每个分层内分配给治疗组和对照组的数量为条件，治疗分配在每个分层内是可交换的。\n\n将原假设定义为 $H_0$：治疗对任何参与者的结果都没有影响，因此两组之间结果的任何差异都归因于随机分配。将备择假设定义为 $H_1$：治疗组和对照组的平均结果之间存在非零差异。\n\n您必须指定一个能够捕捉平均治疗效应同时尊重分层结构的检验统计量。从概念上讲，该检验统计量应为各分层中组均值的聚合对比，其中每个分层的贡献与其规模成正比，从而无论参与者属于哪个分层，其贡献都是均等的。换言之，计算每个分层内治疗组的平均结果与对照组的平均结果之差，然后使用与分层规模成正比的权重聚合这些特定于分层的差异，以形成单一的对比值。\n\n对于置换方案，仅在每个分层内部置换治疗标签，同时保持该分层内观测到的治疗组和对照组参与者数量不变。这尊重了原始的分层随机化设计，并确保了在 $H_0$ 下的可交换性。\n\n对于双边p值，使用所选检验统计量在分层置换方案下的随机化分布，并计算其绝对值至少与观测到的检验统计量绝对值一样极端的置换所占的比例，即，计算满足 $|T_{\\text{perm}}| \\ge |T_{\\text{obs}}|$ 的置换数量，然后除以所考虑的置换总数。将p值表示为小数。\n\n当分层置换的总数不是太大时，精确枚举是可行的。设 $n_h$ 表示分层 $h$ 的大小，设 $n_{1h}$ 表示分层 $h$ 中接受治疗的人数。分层置换的总数是各分层 $\\binom{n_h}{n_{1h}}$ 的乘积。如果该乘积小于或等于 $100000$，您的程序必须执行精确枚举。如果该乘积超过 $100000$，则使用 $M=100000$ 次均匀采样的分层置换进行蒙特卡洛（MC）近似。为保证可复现性，蒙特卡洛随机数生成器应使用固定的种子 $42$。\n\n输入嵌入在程序中；不要读取外部输入。对于每个测试用例，您将获得：\n- $y$：一个连续结果的列表，\n- $z$：一个二元治疗标签的列表，其中 $1$ 代表治疗，$0$ 代表对照，\n- $s$：一个整数分层标签的列表。\n\n按上述方法计算每个测试用例的双边分层置换p值。将每个p值四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含所有测试用例的p值，格式为用方括号括起来的逗号分隔列表。\n\n待实现的测试套件：\n- 用例 $1$（两个分层，平衡，精确枚举）：\n  - $y = [5.2, 4.8, 3.9, 4.1, 6.1, 5.2, 6.3, 5.0, 6.0, 5.1]$\n  - $z = [1, 1, 0, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]$\n- 用例 $2$（单个分层，精确枚举）：\n  - $y = [10.2, 10.5, 9.4, 9.6, 10.1, 9.5]$\n  - $z = [1, 1, 0, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 0, 0]$\n- 用例 $3$（三个分层，规模不等，效应接近于零，精确枚举）：\n  - $y = [7.0, 7.1, 6.9, 5.0, 5.1, 5.2, 5.1, 8.0, 7.9, 8.1, 8.0, 8.0]$\n  - $z = [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2]$\n- 用例 $4$（三个分层，规模较大，蒙特卡洛近似）：\n  - $y = [11.0, 10.8, 11.2, 11.1, 10.3, 10.4, 10.2, 10.5, 9.5, 9.7, 9.0, 8.9, 9.1, 9.6, 9.0, 8.8, 9.4, 7.9, 7.5, 8.0, 7.6, 7.8, 7.4, 7.9, 7.5, 8.1, 7.6]$\n  - $z = [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]$\n  - $s = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]$\n\n最终输出格式：\n- 单行输出，包含四个p值，以逗号分隔并用方括号括起来，例如 $[p_1,p_2,p_3,p_4]$，其中每个 $p_i$ 是一个四舍五入到 $6$ 位的小数。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于对照试验的随机化推断原则，问题定义明确，目标清晰，数据充分，并使用了客观、正式的语言。因此，我们可以着手提供解决方案。\n\n该问题要求为双臂随机对照试验（RCT）实施一个分层置换检验。解决方案涉及形式化原假设和检验统计量，定义尊重分层设计的置换过程，并根据可能置换的总数在精确枚举和蒙特卡洛近似之间切换来计算双边p值。\n\n设参与者总数为 $N$。每个参与者 $i \\in \\{1, ..., N\\}$ 都有一个连续结果 $y_i$、一个二元治疗分配 $z_i \\in \\{0, 1\\}$（$1$ 代表治疗，$0$ 代表对照）和一个分层标签 $s_i$。设 $H$ 是唯一分层的集合。对于每个分层 $h \\in H$，设 $I_h = \\{i | s_i = h\\}$ 是该分层中参与者的索引集。分层 $h$ 的大小为 $n_h = |I_h|$。分层 $h$ 中接受治疗和作为对照的参与者数量分别为 $n_{1h} = \\sum_{i \\in I_h} z_i$ 和 $n_{0h} = n_h - n_{1h}$。总样本量为 $N = \\sum_{h \\in H} n_h$。\n\n尖锐原假设（sharp null hypothesis） $H_0$ 假定，治疗对任何参与者的结果都没有影响。这意味着每个参与者的结果 $y_i$ 是一个固定的特征，与其治疗分配 $z_i$ 无关。在 $H_0$ 下，即使治疗分配不同，观测到的结果也会是相同的。备择假设 $H_1$ 是存在非零的平均治疗效应。\n\n检验统计量必须是一个单一值，该值在考虑分层设计的同时，总结治疗组之间的差异。问题指定了一个检验统计量，它是按分层规模加权的、特定于分层的对比值的聚合。这确保了较大的分层对整体统计量的贡献更大。让我们将其形式化。\n\n在每个分层 $h \\in H$ 内，治疗组的平均结果为：\n$$ \\bar{y}_{1h} = \\frac{\\sum_{i \\in I_h} y_i z_i}{n_{1h}} $$\n对照组的平均结果为：\n$$ \\bar{y}_{0h} = \\frac{\\sum_{i \\in I_h} y_i (1 - z_i)}{n_{0h}} $$\n特定于分层的均值差异为 $\\Delta_h = \\bar{y}_{1h} - \\bar{y}_{0h}$。总体检验统计量 $T$ 是这些差异的加权平均值，权重与分层大小 $n_h$ 成正比：\n$$ T = \\sum_{h \\in H} w_h \\Delta_h = \\sum_{h \\in H} \\frac{n_h}{N} (\\bar{y}_{1h} - \\bar{y}_{0h}) $$\n这是一个标准且科学上合理的选择，通常称为分层均值差。问题中“从而无论参与者属于哪个分层，其贡献都是均等的”这句话应在这种加权平均结构的背景下解释，这是汇总分层水平效应以估计总体平均效应的标准方法，而不是字面上理解为每个 $y_i$ 都有相等的系数。\n\n在 $H_0$ 下，以计数 $n_{1h}$ 和 $n_{0h}$ 为条件，治疗分配 $z_i$ 在每个分层内是可交换的。这意味着在一个分层内，治疗标签的任何置换都与观测到的分配具有相同的可能性。与分层设计一致的可能治疗分配总数是每个分层内选择被治疗个体的方法数的乘积：\n$$ K = \\prod_{h \\in H} \\binom{n_h}{n_{1h}} $$\n\n置换检验按以下步骤进行：\n1.  计算观测数据的检验统计量，记为 $T_{\\text{obs}}$。\n2.  在 $H_0$ 下生成检验统计量的参考分布。这通过创建一组置换后的治疗分配 $z_{\\text{perm}}$ 来完成。对于每个 $z_{\\text{perm}}$，计算一个相应的检验统计量 $T_{\\text{perm}}$。\n3.  生成置换集的方法取决于总数 $K$：\n    a.  **精确枚举**：如果 $K \\le 100000$，我们生成所有 $K$ 个可能的有效分层分配。对于每个分层 $h$，我们考虑所有 $\\binom{n_h}{n_{1h}}$ 种将 $n_{1h}$ 个个体分配到治疗组的方式。完整的分配集是所有分层这些可能性的笛卡尔积。\n    b.  **蒙特卡洛近似**：如果 $K > 100000$，我们生成大量的（$M=100000$）随机置换。每个随机置换都是通过在每个分层 $h$ 内随机选择 $n_{1h}$ 名参与者进入治疗组来构建的，各分层之间独立进行。此抽样为无放回抽样。\n4.  双边p值是检验统计量的绝对值大于或等于观测到的检验统计量绝对值的置换（来自精确集或蒙特卡洛样本）所占的比例：\n$$ p = \\frac{\\sum_{j=1}^{N_{\\text{total}}} \\mathbb{I}(|T_{j}| \\ge |T_{\\text{obs}}|)}{N_{\\text{total}}} $$\n在这里，$N_{\\text{total}}$ 对于精确检验是 $K$，对于蒙特卡洛检验是 $M$，$T_j$ 是第 $j$ 次置换的检验统计量，$\\mathbb{I}(\\cdot)$ 是指示函数。观测数据配置是可能的置换之一，并包含在此计算中。\n\n此过程提供了一个对尖锐原假设的非参数、无假设检验，它正确地遵循了研究设计中使用的随机化方案。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nimport itertools\n\ndef calculate_p_value(y, z, s):\n    \"\"\"\n    Computes the two-sided stratified permutation p-value for a given dataset.\n\n    Args:\n        y (list): Continuous outcomes.\n        z (list): Binary treatment labels (1=treatment, 0=control).\n        s (list): Integer stratum labels.\n\n    Returns:\n        float: The calculated p-value, rounded to 6 decimal places.\n    \"\"\"\n    # Convert inputs to numpy arrays for efficient computation.\n    y = np.array(y)\n    z = np.array(z)\n    s = np.array(s)\n    N = len(y)\n\n    strata_labels = np.unique(s)\n    strata_info = {}\n    for stratum_label in strata_labels:\n        indices = np.where(s == stratum_label)[0]\n        n_h = len(indices)\n        n_1h = np.sum(z[indices])\n        strata_info[stratum_label] = {\n            'indices': indices,\n            'n_h': n_h,\n            'n_1h': int(n_1h)\n        }\n\n    def compute_statistic(z_vec):\n        \"\"\"Calculates the stratified difference in means test statistic.\"\"\"\n        stat_val = 0.0\n        for stratum_label, info in strata_info.items():\n            indices = info['indices']\n            n_h = info['n_h']\n            \n            y_h = y[indices]\n            z_h = z_vec[indices]\n            \n            n_1h = np.sum(z_h)\n            n_0h = n_h - n_1h\n\n            # If a stratum has all treated or all control, its contribution is 0.\n            if n_1h == 0 or n_0h == 0:\n                continue\n\n            mean_1h = np.sum(y_h[z_h == 1]) / n_1h\n            mean_0h = np.sum(y_h[z_h == 0]) / n_0h\n            \n            delta_h = mean_1h - mean_0h\n            stat_val += (n_h / N) * delta_h\n            \n        return stat_val\n\n    # Calculate the observed test statistic.\n    T_obs = compute_statistic(z)\n    abs_T_obs = abs(T_obs)\n\n    # Calculate the total number of possible permutations.\n    total_permutations = 1\n    for info in strata_info.values():\n        total_permutations *= comb(info['n_h'], info['n_1h'], exact=True)\n\n    if total_permutations = 100000:\n        # Perform exact enumeration.\n        \n        # Generate combinations of treated indices for each stratum.\n        stratum_combinations = []\n        for stratum_label in strata_labels:\n            info = strata_info[stratum_label]\n            indices_h = info['indices']\n            n_1h = info['n_1h']\n            stratum_combinations.append(list(itertools.combinations(indices_h, n_1h)))\n        \n        count_extreme = 0\n        \n        # Iterate through the Cartesian product of all stratum-level combinations.\n        for permuted_treated_indices_tuple in itertools.product(*stratum_combinations):\n            z_perm = np.zeros(N, dtype=int)\n            for treated_indices_for_stratum in permuted_treated_indices_tuple:\n                z_perm[list(treated_indices_for_stratum)] = 1\n            \n            T_perm = compute_statistic(z_perm)\n            \n            if abs(T_perm) >= abs_T_obs:\n                count_extreme += 1\n                \n        p_value = count_extreme / total_permutations\n    \n    else:\n        # Perform Monte Carlo approximation.\n        M = 100000\n        rng = np.random.default_rng(seed=42)\n        count_extreme = 0\n        \n        for _ in range(M):\n            z_perm = np.zeros(N, dtype=int)\n            for info in strata_info.values():\n                indices_h = info['indices']\n                n_1h = info['n_1h']\n                \n                # Randomly choose which subjects are treated within the stratum.\n                permuted_treated_indices = rng.choice(indices_h, size=n_1h, replace=False)\n                z_perm[permuted_treated_indices] = 1\n            \n            T_perm = compute_statistic(z_perm)\n            \n            if abs(T_perm) >= abs_T_obs:\n                count_extreme += 1\n                \n        p_value = count_extreme / M\n\n    return round(p_value, 6)\n    \ndef solve():\n    \"\"\"\n    Main function to define test cases and compute p-values.\n    \"\"\"\n    test_cases = [\n        # Case 1 (two strata, balanced, exact enumeration)\n        {\n            \"y\": [5.2, 4.8, 3.9, 4.1, 6.1, 5.2, 6.3, 5.0, 6.0, 5.1],\n            \"z\": [1, 1, 0, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]\n        },\n        # Case 2 (single stratum, exact enumeration)\n        {\n            \"y\": [10.2, 10.5, 9.4, 9.6, 10.1, 9.5],\n            \"z\": [1, 1, 0, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 0, 0]\n        },\n        # Case 3 (three strata, unequal sizes, near-zero effect, exact enumeration)\n        {\n            \"y\": [7.0, 7.1, 6.9, 5.0, 5.1, 5.2, 5.1, 8.0, 7.9, 8.1, 8.0, 8.0],\n            \"z\": [1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2]\n        },\n        # Case 4 (three strata, larger sizes, Monte Carlo approximation)\n        {\n            \"y\": [11.0, 10.8, 11.2, 11.1, 10.3, 10.4, 10.2, 10.5, 9.5, 9.7, 9.0, 8.9, 9.1, 9.6, 9.0, 8.8, 9.4, 7.9, 7.5, 8.0, 7.6, 7.8, 7.4, 7.9, 7.5, 8.1, 7.6],\n            \"z\": [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n            \"s\": [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = calculate_p_value(case[\"y\"], case[\"z\"], case[\"s\"])\n        results.append(p_val)\n    \n    # Format the results into the required string format.\n    # The f-string formatting ensures each number has 6 decimal places.\n    output_str = f\"[{','.join([f'{p:.6f}' for p in results])}]\"\n    print(output_str)\n\nsolve()\n\n```"
        }
    ]
}