{
    "hands_on_practices": [
        {
            "introduction": "要真正掌握方差分析（ANOVA），至关重要的是揭开统计软件的“黑箱”，亲手实践其内在计算。本练习将指导您从第一性原理出发，实现一个单因素方差分析，从而强化对总变异如何分解为组间和组内变异以计算$F$统计量的理解。通过从零开始构建分析过程，您将对变异分解的核心逻辑建立起扎实的认识 。",
            "id": "4965592",
            "problem": "您需要编写一个完整的程序，根据方差分解的基本原理，从原始数据构建单因素方差分析 (ANOVA) 表，然后仅报告为每个提供的数据集计算出的$F$统计量。您的实现不得调用任何内置的 ANOVA 程序；它必须根据平均值和离差平方和的核心定义来计算所有量值。从以下基本出发点开始：样本均值和离差平方和的定义；总变异可加性地分解为组内和组间分量的恒等式；以及单因素 ANOVA 模型下的独立性与方差齐性假设，在这些假设下，在原假设成立时，$F$统计量服从$F$分布。具体来说，仅使用以下原理作为起点：\n- 对于任意有限的实值观测数据集 $\\{y\\}$，样本均值为 $\\bar{y} = \\frac{1}{n}\\sum_{j=1}^{n} y_{j}$，总离差平方和为 $\\sum_{j=1}^{n} (y_{j} - \\bar{y})^{2}$。\n- 在一个有 $k$ 个组、各组大小为 $n_{i}$ 的单因素分组中，总平方和可分解为 $SS_{T} = SS_{W} + SS_{B}$，其中 $SS_{W}$ 是根据与组均值的离差计算的组内平方和，$SS_{B}$ 是根据组均值与总均值的离差（按组大小加权）计算的组间平方和。\n- 在单因素 ANOVA 模型下，若各组误差独立、服从正态分布且方差相等，则在所有组均值相等的原假设下，均方比 $F = MS_{B}/MS_{W}$ 服从分子自由度为 $k-1$、分母自由度为 $N - k$ 的 $F$ 分布，其中 $N = \\sum_{i=1}^{k} n_{i}$。\n\n您的程序必须为每个数据集完成以下任务：\n1. 计算每个组的均值 $\\bar{y}_{i}$、总均值 $\\bar{y}$、组内平方和 $SS_{W} = \\sum_{i=1}^{k}\\sum_{j=1}^{n_{i}}(y_{ij} - \\bar{y}_{i})^{2}$、总平方和 $SS_{T} = \\sum_{i=1}^{k}\\sum_{j=1}^{n_{i}}(y_{ij} - \\bar{y})^{2}$，以及组间平方和 $SS_{B} = SS_{T} - SS_{W}$（从而验证方差分解恒等式）。\n2. 计算自由度 $df_{B} = k - 1$ 和 $df_{W} = N - k$，均方 $MS_{B} = SS_{B}/df_{B}$ 和 $MS_{W} = SS_{W}/df_{W}$，以及 $F$统计量 $F = MS_{B}/MS_{W}$。\n3. 为保证数值稳健性，如果 $MS_{W} = 0$，当 $SS_{B} > 0$ 时将 $F$ 定义为 $+\\infty$，当 $SS_{B} = 0$ 时将 $F$ 定义为 $\\mathrm{nan}$。\n\n测试套件：\n请精确使用以下四个数据集，每个数据集表示为组的列表，其中每个组是一个实数列表。\n\n- 测试用例 A（均衡设计，组间差异明显）：$k = 3$，组数据\n  - 第 1 组：$[4.1, 4.3, 4.2, 4.0]$\n  - 第 2 组：$[5.0, 5.1, 4.9, 5.2]$\n  - 第 3 组：$[6.0, 5.8, 6.2, 5.9]$\n- 测试用例 B（无组间变异；所有组均值完全相等）：$k = 3$，组数据\n  - 第 1 组：$[10.0, 12.0, 8.0]$\n  - 第 2 组：$[9.0, 10.0, 11.0]$\n  - 第 3 组：$[7.0, 10.0, 13.0]$\n- 测试用例 C（样本量小且不相等）：$k = 2$，组数据\n  - 第 1 组：$[2.0, 2.1]$\n  - 第 2 组：$[2.5, 2.4, 2.6]$\n- 测试用例 D（组大小不等，其中一组有平移）：$k = 4$，组数据\n  - 第 1 组：$[15.0, 16.0, 14.0]$\n  - 第 2 组：$[15.0, 15.5]$\n  - 第 3 组：$[14.8, 15.2, 15.0, 15.1]$\n  - 第 4 组：$[18.0, 17.5, 18.2]$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的结果列表。对于每个测试用例，仅输出四舍五入到 $6$ 位小数的浮点数 $F$统计量，并按 A、B、C、D 的顺序排列。例如，最终输出必须如下所示：\n$[\\text{FA},\\text{FB},\\text{FC},\\text{FD}]$\n除了分隔数字所必需的逗号外，不包含任何额外的文本或空格。\n\n本问题不涉及物理单位，因此不要报告任何单位。不要读取任何输入；程序必须如上所述是完全自包含且可复现的。",
            "solution": "该问题要求从基本原理出发，实现单因素方差分析 (ANOVA)，以计算多个数据集的 $F$统计量。解决方案是通过系统地应用指定的方差分量定义来推导的。\n\n单因素 ANOVA 的核心原理是将数据集中的总变异分解为组间变异和组内变异。设数据包含 $k$ 个组。第 $i$ 个组（其中 $i \\in \\{1, 2, \\dots, k\\}$）包含 $n_i$ 个观测值，记为 $y_{ij}$，其中 $j \\in \\{1, 2, \\dots, n_i\\}$。数据集中总的观测值数量为 $N = \\sum_{i=1}^{k} n_i$。\n\n为给定数据集计算 $F$统计量的算法流程如下：\n\n1.  **均值计算**：\n    首先，我们计算所需的样本均值。\n    -   每个组 $i$ 的均值，记为 $\\bar{y}_i$，计算公式如下：\n        $$ \\bar{y}_i = \\frac{1}{n_i} \\sum_{j=1}^{n_i} y_{ij} $$\n    -   所有观测值的总均值，记为 $\\bar{y}$，计算公式如下：\n        $$ \\bar{y} = \\frac{1}{N} \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} y_{ij} $$\n\n2.  **平方和 (SS) 计算**：\n    通过计算离差平方和来进行方差分解。\n    -   **总平方和** ($SS_T$) 衡量所有数据点围绕总均值的总变异。其定义为：\n        $$ SS_T = \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y})^2 $$\n    -   **组内平方和** ($SS_W$)，也称为误差平方和，衡量数据点围绕各自组均值的变异。其计算方法是：先计算每个组内的离差平方和，然后将所有组的结果相加：\n        $$ SS_W = \\sum_{i=1}^{k} \\sum_{j=1}^{n_i} (y_{ij} - \\bar{y}_i)^2 $$\n    -   **组间平方和** ($SS_B$) 衡量各组均值围绕总均值的变异，并按组大小加权。根据问题的指示，该量值使用 ANOVA 的基本分解恒等式计算：\n        $$ SS_B = SS_T - SS_W $$\n        这个恒等式 $SS_T = SS_B + SS_W$ 是 ANOVA 的基石，它表明总变异等于组间变异与组内变异之和。\n\n3.  **自由度 (df) 计算**：\n    每个平方和项都关联一个自由度。\n    -   $SS_B$ 的自由度为 $df_B = k - 1$，对应于 $k$ 个组均值减去 1 个约束（即总均值）。\n    -   $SS_W$ 的自由度为 $df_W = N - k$，对应于 $N$ 个总观测值减去从中计算出的 $k$ 个组均值。\n\n4.  **均方 (MS) 计算**：\n    均方是平方和除以其各自的自由度，代表平均变异。\n    -   **组间均方**为：\n        $$ MS_B = \\frac{SS_B}{df_B} $$\n    -   **组内均方**为：\n        $$ MS_W = \\frac{SS_W}{df_W} $$\n    $MS_B$ 代表组间方差，而 $MS_W$ 代表组内合并方差。\n\n5.  **F-统计量计算**：\n    $F$统计量是组间方差与组内方差的比值。\n    $$ F = \\frac{MS_B}{MS_W} $$\n    一个大的 $F$ 值表明组间变异显著大于组内变异，从而提供了拒绝所有组均值相等的原假设的证据。\n\n6.  **特殊情况处理**：\n    问题指定了当分母 $MS_W$ 为零时的稳健性规则。这种情况当且仅当 $SS_W=0$ 时发生，即每个组内的所有观测值都相同时。\n    -   如果 $MS_W = 0$（即 $SS_W = 0$）且 $SS_B > 0$，则组间变异非零而组内变异为零。这意味着存在无限强的证据表明存在差异，因此 $F$ 被定义为 $+\\infty$。\n    -   如果 $MS_W = 0$（即 $SS_W = 0$）且 $SS_B = 0$，则整个数据集中的所有观测值都相同。在这种情况下，$F$统计量是不确定的，被定义为“非数值”($\\mathrm{nan}$)。\n\n实现将这些步骤转化为一个函数，该函数处理每个数据集，计算所有中间量（$N$、$k$、均值、$SS_T$、$SS_W$、$SS_B$、$df_B$、$df_W$、$MS_B$、$MS_W$），并返回最终的 $F$统计量，包括对特殊情况的指定处理。然后为每个测试用例调用该函数，并按要求格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef compute_f_statistic(data: list[list[float]]) -> float:\n    \"\"\"\n    Computes the F-statistic for a one-way ANOVA from first principles.\n\n    Args:\n        data: A list of lists, where each inner list represents a group's data.\n\n    Returns:\n        The calculated F-statistic as a float.\n    \"\"\"\n    # 1. Compute counts and consolidate data into a single array.\n    k = len(data)\n    if k = 1:\n        # F-statistic is not well-defined for a single group or no groups.\n        return math.nan\n\n    all_obs_list = [obs for group in data for obs in group]\n    N = len(all_obs_list)\n    \n    if N == k:\n        # This implies at least one group is empty or all groups have 1 obs,\n        # leading to df_w = 0.\n        if N == k and all(len(g)==1 for g in data):\n             # SS_W will be 0. Need to check SSB\n             ss_b_check = np.var(all_obs_list) * N\n             if ss_b_check > 0: return float('inf')\n             else: return float('nan')\n        return math.nan\n\n    all_obs_np = np.array(all_obs_list, dtype=np.float64)\n\n    # 2. Compute the group means and the overall mean.\n    overall_mean = np.mean(all_obs_np)\n    group_means = [np.mean(np.array(g, dtype=np.float64)) for g in data]\n\n    # 3. Compute the Sums of Squares (SS).\n    # SS_T: Total Sum of Squares\n    ss_t = np.sum((all_obs_np - overall_mean)**2)\n\n    # SS_W: Within-Groups Sum of Squares\n    ss_w = 0.0\n    for i in range(k):\n        group_data = np.array(data[i], dtype=np.float64)\n        ss_w += np.sum((group_data - group_means[i])**2)\n    \n    # SS_B: Between-Groups Sum of Squares, derived from the partitioning identity.\n    ss_b = ss_t - ss_w\n    \n    # Numpy's float precision can sometimes make a very small positive number\n    # slightly negative. We correct this for ss_b, which must be non-negative.\n    if ss_b  0 and np.isclose(ss_b, 0):\n        ss_b = 0.0\n\n    # 4. Compute degrees of freedom.\n    df_b = k - 1\n    df_w = N - k\n\n    # 5. Handle special cases as per problem description (based on SS_W).\n    # MS_W = 0 if and only if SS_W = 0.\n    if np.isclose(ss_w, 0):\n        ss_w = 0.0\n\n    if ss_w == 0:\n        if ss_b > 0:\n            return float('inf')\n        else: # ss_b is also 0\n            return float('nan')\n\n    # 6. Compute Mean Squares (MS) and the F-statistic.\n    ms_b = ss_b / df_b\n    ms_w = ss_w / df_w\n    \n    f_statistic = ms_b / ms_w\n    \n    return f_statistic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        [[4.1, 4.3, 4.2, 4.0], [5.0, 5.1, 4.9, 5.2], [6.0, 5.8, 6.2, 5.9]],\n        # Test case B\n        [[10.0, 12.0, 8.0], [9.0, 10.0, 11.0], [7.0, 10.0, 13.0]],\n        # Test case C\n        [[2.0, 2.1], [2.5, 2.4, 2.6]],\n        # Test case D\n        [[15.0, 16.0, 14.0], [15.0, 15.5], [14.8, 15.2, 15.0, 15.1], [18.0, 17.5, 18.2]]\n    ]\n\n    results = []\n    for case in test_cases:\n        f_value = compute_f_statistic(case)\n        results.append(f_value)\n\n    # Final print statement in the exact required format.\n    # The format specifier {:.6f} correctly handles regular floats, 'inf', and 'nan'.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在学会使用方差分析来分析数据之后，关键的下一步是学习如何设计有效的实验。本练习将介绍功效分析（power analysis），这是一个用于确定所需样本量的基本工具，以确保能高概率地检测到具有科学意义的效应。您将运用非中心$F$分布来计算所需的最小样本量，从而在理论统计学和实验设计实践之间架起一座桥梁 。",
            "id": "4965568",
            "problem": "您的任务是构建一个程序，为平衡单因素固定效应方差分析（ANOVA）执行功效分析。在正态性假设和共同组内方差的条件下，该程序必须确定为达到正确拒绝原假设的指定概率所需的每组最小整数样本量。该方法必须明确地将一个中心分布的临界阈值与来自非中心F分布的逆生存分位数进行比较。\n\n基本设置为一个平衡单因素固定效应方差分析模型，包含 $k$ 个组，每组样本量为 $n$，总样本量为 $N = k n$。第 $i$ 组的总体均值为 $\\mu_i$，所有组共享一个共同的误差方差 $\\sigma^2$。假设检验的目标是检验所有组均值相等的原假设 $H_0$ 与并非所有 $\\mu_i$ 都相等的固定效应备择假设。错误概率阈值是显著性水平 $\\alpha \\in (0,1)$，在固定效应备择假设下拒绝 $H_0$ 的期望概率是功效水平 $1 - \\beta \\in (0,1)$。\n\n您的程序必须：\n- 假设为平衡设计，即所有组的 $n$ 相等。\n- 计算在给定的组均值和共同组内方差下，能够达到或超过指定功效水平的最小整数组样本量 $n \\geq 2$。如果指定的均值意味着没有差异（即，在模型要求的意义上所有组均值相等），程序必须为该测试用例输出 $-1$，以表明在任何有限样本量下都无法达到目标功效。\n- 使用中心F分布确定在自由度为 $df_1 = k - 1$ 和 $df_2 = N - k$ 时，尾部概率为 $\\alpha$ 的临界阈值；并使用在固定效应备择假设下具有相应非中心性参数的非中心F分布在指定功效处的逆生存分位数，来评估是否满足功效要求。\n- 确保计算出的每组样本量是满足要求的最小整数。\n\n程序必须实现一个关于 $n$ 的单调搜索策略（例如，先确定范围再进行二分搜索），并且其决策逻辑必须基于中心F临界阈值与目标功效下非中心F逆生存分位数之间的比较。\n\n此计算不涉及物理单位。所有输出必须是整数。如果对于给定的参数无法达到目标功效（当所有组均值相等时发生这种情况），则输出 $-1$。\n\n测试套件：\n请在以下四个案例上评估您的程序。在每个案例中，输入是组均值列表、共同的组内方差、显著性水平和期望的功效。\n\n- 案例1：均值 $[0.0, 0.5, 1.0]$，方差 $\\sigma^2 = 1.0$，显著性水平 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.8$。\n- 案例2：均值 $[0.0, 0.2]$，方差 $\\sigma^2 = 1.0$，显著性水平 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.9$。\n- 案例3：均值 $[1.0, 1.0, 1.0, 1.0]$，方差 $\\sigma^2 = 1.0$，显著性水平 $\\alpha = 0.05$，期望功效 $1 - \\beta = 0.8$。\n- 案例4：均值 $[-1.0, -0.5, 0.0, 0.5, 1.0]$，方差 $\\sigma^2 = 0.5$，显著性水平 $\\alpha = 0.01$，期望功效 $1 - \\beta = 0.95$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个案例的整数结果，以逗号分隔的列表形式并用方括号括起来，顺序与上述案例相同。例如，输出格式必须类似于 $[n_1,n_2,n_3,n_4]$，其中每个 $n_i$ 是为案例 $i$ 计算出的最小每组样本量，如果无法达到则为 $-1$。",
            "solution": "用户提供的问题已经过严格验证，并被确定为 **有效**。这是一个在生物统计功效分析领域内适定且科学合理的问题。所有必要的参数都已指定，术语精确，目标明确。该问题要求实现一个标准的、尽管具有一定复杂性的统计程序。\n\n在此，提供一个完整且有理有据的解决方案。\n\n### 单因素方差分析功效分析的理论基础\n\n该问题基于单因素固定效应方差分析（ANOVA）的背景。对于来自组 $i \\in \\{1, \\dots, k\\}$ 和受试者 $j \\in \\{1, \\dots, n\\}$ 的观测值 $Y_{ij}$，其统计模型为：\n$$\nY_{ij} = \\mu_i + \\epsilon_{ij}\n$$\n其中 $\\mu_i$ 是第 $i$ 组的真实均值，误差项 $\\epsilon_{ij}$ 被假定为独立同分布的正态随机变量，$\\epsilon_{ij} \\sim \\mathcal{N}(0, \\sigma^2)$，所有 $k$ 个组共享一个共同方差 $\\sigma^2$。该设计是平衡的，意味着每个组具有相同的样本量 $n$。总样本量为 $N = kn$。\n\nANOVA 的假设检验为：\n-   原假设 $H_0$：所有组的均值相等，即 $\\mu_1 = \\mu_2 = \\dots = \\mu_k$。\n-   备择假设 $H_1$：至少有一个组的均值与其他组不同。\n\n检验统计量是组间均方（$MSB$）与组内均方（$MSW$）的比值：\n$$\nF = \\frac{MSB}{MSW} = \\frac{SSB / (k-1)}{SSW / (N-k)}\n$$\n在原假设和备择假设下，此F统计量的分布是功效分析的核心：\n1.  在 $H_0$ 下，统计量 $F$ 服从自由度为 $df_1 = k-1$ 和 $df_2 = N-k$ 的 **中心F分布**。我们将其表示为 $F \\sim F(df_1, df_2)$。\n2.  在 $H_1$ 下，统计量 $F$ 服从具有相同自由度和一个非中心性参数（NCP）$\\lambda$ 的 **非中心F分布**。我们将其表示为 $F \\sim F(df_1, df_2, \\lambda)$。\n\n非中心性参数 $\\lambda$ 量化了原假设为假的程度。对于平衡单因素方差分析，其定义为：\n$$\n\\lambda = \\frac{n \\sum_{i=1}^{k} (\\mu_i - \\bar{\\mu})^2}{\\sigma^2}\n$$\n其中 $\\bar{\\mu} = \\frac{1}{k} \\sum_{i=1}^{k} \\mu_i$ 是总体均值的总均值。\n\n### 功效计算与计算策略\n\n统计功效（$1-\\beta$）是正确拒绝一个错误的原假设的概率。如果观测到的F统计量 $F_{obs}$ 超过一个临界值 $F_{crit}$，我们就拒绝 $H_0$。这个临界值由显著性水平 $\\alpha$ 决定。具体来说，$F_{crit}$ 是这样一个值：在 $H_0$ 成立的条件下，观测到大于它的F统计量的概率恰好为 $\\alpha$。这对应于中心F分布的上$\\alpha$分位数：\n$$\nF_{crit} = F_{\\text{isf}}(\\alpha; df_1, df_2)\n$$\n其中 $F_{\\text{isf}}$ 是中心F分布的逆生存函数（或上尾的分位数点函数）。\n\n那么，功效就是在 $H_1$ 为真时，这个拒绝事件发生的概率：\n$$\n\\text{Power} = P(F > F_{crit} | H_1)\n$$\n由于在 $H_1$ 下，F统计量服从非中心F分布，因此功效使用该分布的生存函数（SF）来计算：\n$$\n\\text{Power} = \\text{SF}_{ncf}(F_{crit}; df_1, df_2, \\lambda)\n$$\n目标是找到满足以下条件的最小整数每组样本量 $n \\geq 2$：\n$$\n\\text{Power} \\geq 1-\\beta\n$$\n其中 $1-\\beta$ 是期望的功效水平。\n\n问题为这个检验指定了一种特殊方法，该方法涉及将中心临界阈值与来自非中心F分布的逆生存分位数进行比较。这是对功效条件的一个优雅的重构。条件 $\\text{SF}_{ncf}(F_{crit}; df_1, df_2, \\lambda) \\geq 1-\\beta$ 等价于：\n$$\nF_{crit} \\leq F_{ncf, \\text{isf}}(1-\\beta; df_1, df_2, \\lambda)\n$$\n这种等价性成立，因为生存函数是一个单调递减函数，所以对其逆函数（逆生存函数）应用于不等式两边会反转不等号的方向。这个不等式的右侧正是所要求的“在指定功效下的非中心F分布的逆生存分位数”。\n\n### 最小样本量 $n$ 的搜索算法\n\n问题的核心是找到满足上述不等式的最小整数 $n \\geq 2$。关键是，不等式的两边都依赖于 $n$：\n-   $df_2(n) = k(n-1)$\n-   $\\lambda(n) = n \\cdot C$，其中常数 $C = \\frac{\\sum (\\mu_i - \\bar{\\mu})^2}{\\sigma^2}$ 仅依赖于给定的问题参数。\n\n对不等式与 $n$ 的依赖关系进行分析，揭示了其单调性：\n-   左侧，$F_{crit}(n) = F_{\\text{isf}}(\\alpha; k-1, k(n-1))$，是关于 $n$ 的 **递减** 函数，因为增加分母自由度 $df_2$ 会使中心F分布更加集中。\n-   右侧，$F_{ncf, \\text{isf}}(1-\\beta; k-1, k(n-1), \\lambda(n))$，是关于 $n$ 的 **递增** 函数。这是因为 $df_2$ 的增加和非中心性参数 $\\lambda$ 的线性增加都会使非中心F分布向右移动，从而增加其分位数。\n\n由于是将一个递减函数与一个递增函数进行比较，因此对于所有大于某个阈值的 $n$，该条件都将得到满足。这种结构使得该问题适合进行高效搜索。\n\n算法流程如下：\n1.  **初始化**：从均值列表中计算 $k$。计算均值离差平方和 $\\sum_{i=1}^{k} (\\mu_i - \\bar{\\mu})^2$。如果此和为零（或在数值上与零无法区分），则意味着对于所有 $n$，$\\lambda=0$。在这种情况下，功效始终等于显著性水平 $\\alpha$。如果 $\\alpha$ 小于目标功效 $1-\\beta$，则目标无法实现。程序必须按规定返回 $-1$。\n2.  **搜索 $n$**：我们寻找满足功效条件的最小整数 $n \\geq 2$。\n    - 一种稳健的方法是首先建立一个搜索范围 $[n_{low}, n_{high}]$，使得在 $n_{low}$ 处不满足条件，而在 $n_{high}$ 处满足条件。这可以通过从一个较低的值（例如，$n_{low}=2$）开始，并以指数方式增加测试值，直到满足功效要求，该测试值即成为 $n_{high}$。\n    - 一旦确定了这个范围，就在 $[n_{low}, n_{high}]$ 范围内执行 **二分搜索**，以高效地精确定位使功效条件成立的最小整数 $n$。由于已确立的单调性，该策略是高效的，并保证能找到最小整数解。\n\n最终的Python实现将使用 `numpy` 进行数值计算，并使用 `scipy.stats.f.isf` 和 `scipy.stats.ncf.isf` 来计算所需的统计分位数，从而直接体现上述逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f, ncf\n\ndef compute_min_n_power_anova(\n    means: list[float], variance: float, alpha: float, power: float\n) -> int:\n    \"\"\"\n    Computes the minimal integer per-group sample size for a one-way ANOVA.\n\n    Args:\n        means: A list of population group means.\n        variance: The common within-group variance (sigma^2).\n        alpha: The significance level (Type I error probability).\n        power: The desired statistical power (1 - beta).\n\n    Returns:\n        The minimal integer sample size n per group (n >= 2), or -1 if\n        the target power is unattainable (i.e., all group means are equal).\n    \"\"\"\n\n    k = len(means)\n    if k  2:\n        # ANOVA requires at least 2 groups.\n        # This case is not in the test suite but is a logical check.\n        return -1\n\n    # Calculate the sum of squared deviations of group means from the grand mean\n    mu_array = np.array(means)\n    grand_mean = np.mean(mu_array)\n    sum_sq_dev = np.sum((mu_array - grand_mean) ** 2)\n\n    # If all means are equal, the noncentrality parameter is always 0.\n    # Power will be equal to alpha, so target power is unattainable.\n    if np.isclose(sum_sq_dev, 0.0):\n        return -1\n\n    effect_size_term = sum_sq_dev / variance\n\n    def is_power_sufficient(n: int) -> bool:\n        \"\"\"\n        Checks if a given sample size n achieves the target power.\n        The check is based on the problem's specified comparison.\n        \"\"\"\n        if n  2:\n            return False\n\n        df1 = k - 1\n        df2 = k * (n - 1)\n        \n        # Noncentrality parameter lambda\n        ncp = n * effect_size_term\n\n        # Central F critical threshold for significance level alpha\n        f_crit = f.isf(alpha, df1, df2)\n\n        # Inverse survival quantile from the noncentral F distribution at the target power\n        # The problem requires using the isf at the *power* level, not (1-power).\n        f_power_quantile = ncf.isf(1 - power, df1, df2, ncp)\n        \n        # The condition Power >= target_power is equivalent to F_crit = F_power_quantile\n        return f_crit = f_power_quantile\n\n    # Initial check at the lower bound n=2\n    if is_power_sufficient(2):\n        return 2\n\n    # --- Bracketing phase to find a search range [n_low, n_high] ---\n    n_low = 2\n    n_high = 4\n    # Set a practical limit to prevent potential infinite loops with extreme parameters\n    MAX_N_BRACKET = 1000000  \n    while not is_power_sufficient(n_high):\n        n_low = n_high\n        n_high *= 2\n        if n_high > MAX_N_BRACKET:\n            # Power goal is practically unattainable\n            return -1\n\n    # --- Binary search phase to find the minimal integer n ---\n    min_n = n_high\n    while n_low = n_high:\n        n_mid = n_low + (n_high - n_low) // 2\n        if n_mid  2:  # Ensure sample size is at least 2\n            n_low = n_mid + 1\n            continue\n\n        if is_power_sufficient(n_mid):\n            min_n = n_mid      # n_mid is a potential answer, try for smaller n\n            n_high = n_mid - 1\n        else:\n            n_low = n_mid + 1  # n_mid is too small, need larger n\n            \n    return min_n\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # format: (means, variance, alpha, power)\n    test_cases = [\n        ([0.0, 0.5, 1.0], 1.0, 0.05, 0.8),\n        ([0.0, 0.2], 1.0, 0.05, 0.9),\n        ([1.0, 1.0, 1.0, 1.0], 1.0, 0.05, 0.8),\n        ([-1.0, -0.5, 0.0, 0.5, 1.0], 0.5, 0.01, 0.95),\n    ]\n\n    results = []\n    for case in test_cases:\n        means, variance, alpha, power = case\n        result = compute_min_n_power_anova(means, variance, alpha, power)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "方差分析的简洁之美在均衡设计中体现得最为淋漓尽致，但当数据不均衡时会发生什么呢？本练习将深入探讨方差分析的几何解释，探索设计因子之间正交性的概念。通过编程实现正交性检验，您将发现它与平方和分量的独立性有何关联，并理解为何非正交（不均衡）设计需要更谨慎的解读 。",
            "id": "4965573",
            "problem": "给定一个线性模型情境，其中响应向量由两个设计因子的加性效应建模。目标是通过计算中心化列的逐对内积来检验设计因子的正交性，并将正交性与平方和分量的独立性及其Fisher-Snedecor $F$分布（定义为两个缩放的卡方变量之比）联系起来。请完全从线性模型和欧几里得空间投影的第一性原理出发，不使用预先指定的方差分析公式。\n\n用作基础的定义和假设：\n- 令响应向量为 $y \\in \\mathbb{R}^n$。令 $X_A \\in \\mathbb{R}^{n \\times p_A}$ 和 $X_B \\in \\mathbb{R}^{n \\times p_B}$ 为设计矩阵，使用任意全秩对比编码对两个分类因子 $A$ 和 $B$ 的主效应进行编码。令 $\\mathbf{1} \\in \\mathbb{R}^n$ 为截距列（所有元素均为1）。\n- 为进行内积检验，可以通过减去列均值来对列进行中心化，以移除截距方向。\n- 使用到列空间 $S$ 上的正交投影，定义为到 $S$ 上的欧几里得投影。将投影算子视为 $\\mathbb{R}^n$ 上的对称幂等线性映射。\n- 使用设计矩阵的秩来计算效应和误差的自由度。\n- 在具有独立同分布高斯误差的标准线性模型下，由到相互正交子空间上的正交投影所导出的二次型是独立的。当除以其自由度时，效应平方和与误差均方之比遵循Fisher-Snedecor $F$分布。\n\n您的程序必须：\n- 对每个测试用例，为因子 $A$ 和 $B$ 构建效应编码设计矩阵，其列数分别为 $L_A - 1$ 和 $L_B - 1$，其中 $L_A$ 和 $L_B$ 是水平数。使用一种确定性效应编码方案，对于 $L-1$ 列，如果属于每个非参考水平，则条目为 $+1$；如果属于参考水平，则为 $-1$；否则为 $0$。然后通过减去其均值来对每列进行中心化。\n- 计算 $X_A$ 的每个中心化列与 $X_B$ 的每个中心化列之间的逐对内积。同时计算所有对的最大绝对标准化内积（绝对相关系数）。如果此最大绝对标准化内积小于容差 $\\tau$，则声明正交性检验为真。\n- 使用Moore-Penrose伪逆构建到 $\\mathrm{span}(\\mathbf{1})$ 上的截距投影算子，以及到 $\\mathrm{span}([\\mathbf{1}, X_A])$ 和 $\\mathrm{span}([\\mathbf{1}, X_B])$ 上的投影算子，并形成 $Q_A$ 和 $Q_B$ 作为移除截距后（嵌套投影算子之差）$A$ 和 $B$ 的唯一效应投影算子。使用到全模型 $\\mathrm{span}([\\mathbf{1}, X_A, X_B])$ 上的投影算子计算 $SSE$。\n- 使用嵌套设计矩阵的矩阵秩计算自由度 $df_A$、$df_B$ 和 $df_e$。\n- 将每个因子的均方与误差均方之比作为其 $F$ 统计量进行计算，并计算其在Fisher-Snedecor $F$ 分布下的尾概率。当且仅当唯一效应投影算子 $Q_A$ 和 $Q_B$ 正交时（在容差 $\\tau$ 下，其乘积在数值上接近零算子），声明独立性条件为真。\n- 对所有正交性检验使用严格的容差 $\\tau = 10^{-10}$。\n\n测试套件：\n为以下三种情况实现上述要求。对于所有情况，设确定性残差为 $r_i = 0.1 \\times ((i \\bmod 3) - 1)$，其中索引 $i$ 从 $0$ 开始。均值和主效应为：因子 $A$ 水平的 $ \\mu = 10$， $ \\alpha = [-2, 0, 2]$，因子 $B$ 水平的 $\\beta = [-1, 1]$。响应定义为 $y_i = \\mu + \\alpha[A_i] + \\beta[B_i] + r_i$。\n\n- 情况1（平衡的 $3 \\times 2$ 设计，每个单元格两次重复；总计 $n=12$）：\n  - $A = [\\,0,0,1,1,2,2,0,0,1,1,2,2\\,]$\n  - $B = [\\,0,1,0,1,0,1,0,1,0,1,0,1\\,]$\n\n- 情况2（非平衡交叉；总计 $n=11$）：\n  - $A = [\\,0,0,0,1,1,2,2,2,2,2,1\\,]$\n  - $B = [\\,0,1,0,0,1,0,1,0,1,0,1\\,]$\n\n- 情况3（嵌套/重叠因子；$B$ 是 $A$ 的二元合并，其中如果 $A=2$ 则 $B=1$，否则 $B=0$；平衡的 $n=12$）：\n  - $A = [\\,0,0,1,1,2,2,0,0,1,1,2,2\\,]$\n  - $B = [\\,0,0,0,0,1,1,0,0,0,0,1,1\\,]$\n\n对于每种情况，按顺序输出以下内容：\n$[$\n- 中心化列的正交性检验（布尔值）,\n- 唯一效应投影算子 $Q_A$ 和 $Q_B$ 的独立性条件检验（布尔值）,\n- 因子列间的最大绝对标准化内积（浮点数）,\n- 因子 $A$ 的 $F$ 统计量（浮点数）,\n- 因子 $A$ 在Fisher-Snedecor $F$ 分布下的尾概率（浮点数）,\n- 因子 $B$ 的 $F$ 统计量（浮点数）,\n- 因子 $B$ 在Fisher-Snedecor $F$ 分布下的尾概率（浮点数）\n$]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每一项都是对应测试用例的结果列表，顺序与上文完全一致。例如，输出应如下所示：$[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list} ]$。",
            "solution": "该问题是有效的，因为它在科学上基于线性统计模型理论，在数学上是适定的，并且所有术语和程序都得到了客观和完整的定义。我现在将着手解决该问题。\n\n该问题要求从第一性原理出发，使用线性回归在向量投影方面的几何解释来分析双因子线性模型。我们将构建必要的矩阵和算子，以划分响应向量 $y$ 的方差，并检验两个因子 $A$ 和 $B$ 的显著性。\n\n**1. 线性模型与向量空间表述**\n\n给定的线性模型是 $y_i = \\mu + \\alpha[A_i] + \\beta[B_i] + r_i$。以向量形式，可以写成 $y = X\\theta + \\epsilon$，其中 $y \\in \\mathbb{R}^n$ 是响应向量，$\\epsilon$ 是误差向量。设计矩阵 $X$ 和参数向量 $\\theta$ 封装了模型结构。具体来说，我们可以将模型表示为：\n$$\ny = \\mathbf{1}\\mu + X_A\\alpha^* + X_B\\beta^* + \\epsilon\n$$\n其中 $\\mathbf{1}$ 是用于截距 $\\mu$ 的 $n \\times 1$ 全1向量，$X_A \\in \\mathbb{R}^{n \\times (L_A-1)}$ 和 $X_B \\in \\mathbb{R}^{n \\times (L_B-1)}$ 分别是因子 $A$（有 $L_A$ 个水平）和因子 $B$（有 $L_B$ 个水平）主效应的设计矩阵，而 $\\alpha^*$ 和 $\\beta^*$ 是效应系数向量。\n\n**2. 投影算子与平方和**\n\n此分析的核心是将响应向量 $y$ 正交投影到 $\\mathbb{R}^n$ 的不同子空间上。到矩阵 $Z$ 的列空间 $\\mathcal{C}(Z)$ 上的投影由投影算子 $P_Z$ 执行。如果 $Z$ 是满列秩的，则 $P_Z = Z(Z^T Z)^{-1}Z^T$。更一般地，使用Moore-Penrose伪逆 $Z^\\dagger$，投影算子为 $P_Z = Z Z^\\dagger$。投影算子是对称的（$P_Z^T = P_Z$）和幂等的（$P_Z^2 = P_Z$）。\n\n与一组预测变量 $Z$ 相关联的平方和（$SS$）是 $y$ 投影到 $\\mathcal{C}(Z)$ 上的欧几里得范数的平方：\n$$\nSS(Z) = \\|P_Z y\\|^2 = y^T P_Z^T P_Z y = y^T P_Z y\n$$\n\n问题要求我们计算特定的平方和。我们定义以下子空间及其投影算子：\n- 仅截距：子空间 $S_1 = \\mathrm{span}(\\mathbf{1})$，投影算子 $P_1$。\n- 截距和因子A：子空间 $S_{1,A} = \\mathrm{span}([\\mathbf{1}, X_A])$，投影算子 $P_{1,A}$。\n- 截距和因子B：子空间 $S_{1,B} = \\mathrm{span}([\\mathbf{1}, X_B])$，投影算子 $P_{1,B}$。\n- 全模型 (A+B)：子空间 $S_{1,A,B} = \\mathrm{span}([\\mathbf{1}, X_A, X_B])$，投影算子 $P_{1,A,B}$。\n\n一个因子的独特贡献是通过它解释的额外方差来评估的。问题将因子 $A$ 的唯一效应投影算子定义为 $Q_A = P_{1,A} - P_1$，因子 $B$ 的定义为 $Q_B = P_{1,B} - P_1$。这些也是投影算子。$Q_A$ 投影到 $\\mathcal{C}([\\mathbf{1}, X_A])$ 中与 $\\mathcal{C}(\\mathbf{1})$ 正交的子空间上。这个子空间恰好是中心化设计矩阵的列空间，即 $\\mathcal{C}(\\tilde{X}_A)$，其中 $\\tilde{X}_A = (I - P_1)X_A$。\n\n因子和误差的平方和则为：\n- A的平方和（给定截距）：$SS_A = \\|Q_A y\\|^2 = y^T Q_A y$。\n- B的平方和（给定截距）：$SS_B = \\|Q_B y\\|^2 = y^T Q_B y$。\n- 误差平方和：$SSE = \\|y - P_{1,A,B} y\\|^2 = \\|(I - P_{1,A,B})y\\|^2 = y^T (I - P_{1,A,B}) y$。\n\n**3. 自由度与F统计量**\n\n任何平方和项 $y^T P y$ 的自由度（$df$）是投影矩阵 $P$ 的秩，也即其迹，$df_P = \\mathrm{rank}(P) = \\mathrm{tr}(P)$。\n- $df_A = \\mathrm{rank}(Q_A) = \\mathrm{rank}(P_{1,A}) - \\mathrm{rank}(P_1) = L_A - 1$。\n- $df_B = \\mathrm{rank}(Q_B) = \\mathrm{rank}(P_{1,B}) - \\mathrm{rank}(P_1) = L_B - 1$。\n- $df_e = \\mathrm{rank}(I - P_{1,A,B}) = n - \\mathrm{rank}([\\mathbf{1}, X_A, X_B])$。\n\n均方（$MS$）是平方和除以其自由度，$MS = SS/df$。用于检验因子显著性的F统计量是其均方与误差均方（$MSE$）之比：\n- $F_A = \\frac{MS_A}{MSE} = \\frac{SS_A / df_A}{SSE / df_e}$\n- $F_B = \\frac{MS_B}{MSE} = \\frac{SS_B / df_B}{SSE / df_e}$\n在因子无效应的原假设下，并假设误差是独立同分布的高斯分布，该统计量遵循Fisher-Snedecor F分布，$F \\sim F(df_{effect}, df_e)$。\n\n**4. 正交性与独立性**\n\n检验了两种正交性概念：\n- **设计正交性**：如果因子 $A$ 和 $B$ 的中心化设计矩阵是正交的，即 $\\tilde{X}_A^T \\tilde{X}_B = \\mathbf{0}$，则称这两个因子是正交的。这意味着 $\\tilde{X}_A$ 的每一列都与 $\\tilde{X}_B$ 的每一列正交。这通过计算所有逐对内积并检查它们是否在数值上为零来检验。平衡设计（每个单元格中观测数相等）保证了此属性。\n- **投影算子正交性（平方和的独立性）**：如果平方和 $SS_A$ 和 $SS_B$ 对应的投影矩阵是正交的，即 $Q_A Q_B = \\mathbf{0}$，则它们在统计上是独立的。如前所述，$Q_A$ 是到 $\\mathcal{C}(\\tilde{X}_A)$ 上的投影算子，$Q_B$ 是到 $\\mathcal{C}(\\tilde{X}_B)$ 上的投影算子。条件 $Q_A Q_B = \\mathbf{0}$ 等价于这两个子空间的正交性，而这又等价于 $\\tilde{X}_A^T \\tilde{X}_B = \\mathbf{0}$。\n\n因此，对中心化列的逐对内积的检验与对投影算子 $Q_A$ 和 $Q_B$ 正交性的检验在数学上是等价的。我们期望它们在所有情况下产生相同的布尔结果。\n\n**5. 实现步骤**\n\n对于每个测试用例，我们执行以下计算：\n1.  使用给定的模型参数和残差函数生成长度为 $n$ 的响应向量 $y$。\n2.  构建效应编码设计矩阵 $X_A$（大小为 $n \\times (L_A-1)$）和 $X_B$（大小为 $n \\times (L_B-1)$）。我们使用一种效应编码方案，其中最后一个水平为参考水平。\n3.  通过减去列均值来中心化 $X_A$ 和 $X_B$，得到 $\\tilde{X}_A$ 和 $\\tilde{X}_B$。\n4.  计算 $\\tilde{X}_A$ 和 $\\tilde{X}_B$ 列之间的所有逐对内积。将它们归一化以获得相关系数，并找到最大绝对值。检查该值是否小于容差 $\\tau=10^{-10}$ 以检验设计正交性。\n5.  使用伪逆方法构建投影矩阵 $P_1$、$P_{1,A}$、$P_{1,B}$ 和 $P_{1,A,B}$。\n6.  计算唯一效应投影算子 $Q_A = P_{1,A} - P_1$ 和 $Q_B = P_{1,B} - P_1$。\n7.  通过计算其乘积的Frobenius范数 $\\|Q_A Q_B\\|_F$ 并与 $\\tau$ 比较来检查投影算子的正交性。\n8.  使用投影算子和 $y$ 计算 $SS_A$、$SS_B$ 和 $SSE$。\n9.  根据矩阵秩计算自由度 $df_A$、$df_B$ 和 $df_e$。\n10. 使用 `scipy.stats` 的 F 分布计算 $F_A$、$F_B$ 及其对应的尾概率（p值）。\n11. 收集并按规定格式化结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import f\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the validation and analysis for all test cases.\n    \"\"\"\n    \n    # Define parameters common to all test cases\n    mu = 10.0\n    alpha = np.array([-2.0, 0.0, 2.0])\n    beta = np.array([-1.0, 1.0])\n    r_func = lambda i: 0.1 * ((i % 3) - 1)\n    tau = 1e-10\n\n    # Define the test cases\n    test_cases = [\n        # Case 1: Balanced 3x2 design, n=12\n        {'A': np.array([0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2]),\n         'B': np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1])},\n        \n        # Case 2: Unbalanced crossing, n=11\n        {'A': np.array([0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 1]),\n         'B': np.array([0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1])},\n        \n        # Case 3: Nested/overlapping factors, n=12\n        {'A': np.array([0, 0, 1, 1, 2, 2, 0, 0, 1, 1, 2, 2]),\n         'B': np.array([0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1])}\n    ]\n\n    all_results = []\n    for case_data in test_cases:\n        A_levels = case_data['A']\n        B_levels = case_data['B']\n        \n        # Generate response vector y\n        n = len(A_levels)\n        residuals = np.array([r_func(i) for i in range(n)])\n        y = mu + alpha[A_levels] + beta[B_levels] + residuals\n        \n        # --- Start Analysis ---\n\n        def build_design_matrix(levels, num_levels):\n            \"\"\"Builds an effect-coded design matrix.\"\"\"\n            n_obs = len(levels)\n            ref_level = num_levels - 1\n            X = np.zeros((n_obs, num_levels - 1))\n            for i in range(n_obs):\n                level = levels[i]\n                if level == ref_level:\n                    X[i, :] = -1.0\n                else:\n                    if num_levels > 1 and level  ref_level:\n                        X[i, level] = 1.0\n            return X\n\n        LA = len(np.unique(A_levels))\n        LB = len(np.unique(B_levels))\n        \n        XA = build_design_matrix(A_levels, LA)\n        XB = build_design_matrix(B_levels, LB)\n\n        # 1. Orthogonality check of centered columns\n        XA_c = XA - XA.mean(axis=0)\n        XB_c = XB - XB.mean(axis=0)\n        \n        max_abs_corr = 0.0\n        if XA_c.shape[1] > 0 and XB_c.shape[1] > 0:\n            for i in range(XA_c.shape[1]):\n                col_A = XA_c[:, i]\n                norm_A = np.linalg.norm(col_A)\n                if norm_A  tau: continue\n                for j in range(XB_c.shape[1]):\n                    col_B = XB_c[:, j]\n                    norm_B = np.linalg.norm(col_B)\n                    if norm_B  tau: continue\n                    \n                    inner_product = np.dot(col_A, col_B)\n                    correlation = inner_product / (norm_A * norm_B)\n                    max_abs_corr = max(max_abs_corr, abs(correlation))\n\n        orthogonality_check = max_abs_corr  tau\n\n        # 2. Construct projectors and check independence\n        def make_projector(Z):\n            return Z @ np.linalg.pinv(Z)\n\n        one = np.ones((n, 1))\n        X_1 = one\n        X_1A = np.hstack([one, XA])\n        X_1B = np.hstack([one, XB])\n        \n        X_1AB = np.hstack([one, XA, XB])\n\n        P_1 = make_projector(X_1)\n        P_1A = make_projector(X_1A)\n        P_1B = make_projector(X_1B)\n        P_1AB = make_projector(X_1AB)\n        \n        QA = P_1A - P_1\n        QB = P_1B - P_1\n        \n        independence_check = np.linalg.norm(QA @ QB, 'fro')  tau\n\n        # 3. Compute DFs, SS, and F-statistics\n        df_A = np.linalg.matrix_rank(XA_c)\n        df_B = np.linalg.matrix_rank(XB_c)\n        df_e = n - np.linalg.matrix_rank(X_1AB)\n\n        SSA = y.T @ QA @ y\n        SSB = y.T @ QB @ y\n        SSE = y.T @ (np.identity(n) - P_1AB) @ y\n        \n        MSA = SSA / df_A if df_A > 0 else 0\n        MSB = SSB / df_B if df_B > 0 else 0\n        MSE = SSE / df_e if df_e > 0 else np.nan\n\n        if MSE > 0 and MSA >= 0 and df_A > 0:\n            F_A = MSA / MSE\n            p_A = f.sf(F_A, df_A, df_e)\n        else:\n            F_A = np.nan\n            p_A = np.nan\n\n        if MSE > 0 and MSB >= 0 and df_B > 0:\n            F_B = MSB / MSE\n            p_B = f.sf(F_B, df_B, df_e)\n        else:\n            F_B = np.nan\n            p_B = np.nan\n            \n        case_results = [\n            orthogonality_check,\n            independence_check,\n            float(max_abs_corr),\n            float(F_A),\n            float(p_A),\n            float(F_B),\n            float(p_B)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}