{
    "hands_on_practices": [
        {
            "introduction": "理论知识需要通过计算实践来巩固。此练习旨在将理论付诸实践，要求您针对具体的数据点计算两种重要且应用广泛的置信区间：似然比（Likelihood Ratio, LR）区间和威尔逊得分（Wilson score）区间。通过从零开始实现这些方法，包括为求解似然比区间的边界实现数值求根算法，您将深入理解这些高级方法背后的计算机制，并能直观地比较它们在不同情况下的表现，例如在样本比例接近边界时的行为 。",
            "id": "4911332",
            "problem": "考虑一个单次二项抽样情景，其中在 $\\;n\\;$ 次独立试验中观测到的“成功”次数 $\\;x\\;$ 被建模为一个成功概率为 $\\;p\\in(0,1)\\;$ 的二项随机变量。目标是从第一性原理出发，不使用任何现成公式，计算 $\\;p\\;$ 的精确似然比置信区间和近似的Wilson得分置信区间。\n\n推导的基本依据：\n- 二项模型：其概率质量函数为 $\\;P(X=x\\mid p)=\\binom{n}{x}p^x(1-p)^{n-x}\\;$，对数似然为 $\\;\\ell(p)=x\\log p+(n-x)\\log(1-p)+\\text{constant}\\;$，其中加法常数不依赖于 $\\;p\\;$。\n- 最大似然估计量为 $\\;\\hat p=x/n\\;$。\n- 用于比较一个固定的 $\\;p\\;$ 与 $\\;\\hat p\\;$ 的似然比检验统计量（也称为偏差）定义为两倍对数似然之差。单参数的Wilks定理表明，对于大样本，该似然比统计量近似服从自由度为1的卡方分布。\n- 二项模型的得分检验基于一个固定 $\\;p\\;$ 下的标准化得分，通过对得分检验不等式进行反演可以得到Wilson得分置信区间。\n\n您的任务：\n1. 使用二项模型和似然比统计量（定义为两倍对数似然之差）的定义，推导出关于 $\\;p\\;$ 的标量非线性方程，该方程的根定义了 $(1-\\alpha)$ 似然比置信区间的端点。这个区间是所有使得偏差等于自由度为1的卡方分布的上 $(1-\\alpha)$ 分位数的 $\\;p\\;$ 的集合。对此偏差方程实现一个稳健的Newton–Raphson求根器来计算端点。您的求解器必须强制 $\\;p\\in(0,1)\\;$，并通过分别在 $\\;0\\;$ 或 $\\;1\\;$ 正确返回一个区间端点来处理边界情况 $\\;x=0\\;$ 和 $\\;x=n\\;$。\n2. 从二项得分函数及其在该模型下的方差出发，反演双边得分检验不等式，以获得Wilson得分置信区间。直接根据推导出的不等式实现其计算，并确保输出值在单位区间内。\n3. 对每个测试用例，计算并返回以下五个值，形式为四舍五入到六位小数的十进制浮点数：最大似然估计值 $\\;\\hat p\\;$、似然比区间的下端点和上端点，以及Wilson得分区间的下端点和上端点。所有概率值必须以小数形式报告（而非百分比）。\n\n测试套件：\n- 案例 A：$n=50$, $x=10$, $\\alpha=0.05$。\n- 案例 B：$n=50$, $x=0$, $\\alpha=0.05$ (边界在0)。\n- 案例 C：$n=50$, $x=50$, $\\alpha=0.05$ (边界在1)。\n- 案例 D：$n=50$, $x=1$, $\\alpha=0.05$ (接近边界且成功次数稀疏)。\n- 案例 E：$n=200$, $x=100$, $\\alpha=0.01$ (样本量更大，比例居中，$\\alpha$更严格)。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个五元列表，顺序为 $[\\hat p,\\text{LR}_{\\text{lower}},\\text{LR}_{\\text{upper}},\\text{Wilson}_{\\text{lower}},\\text{Wilson}_{\\text{upper}}]$，其中每个条目都四舍五入到六位小数。例如，一个有效的格式是 $[[0.200000,0.106000,0.324000,0.116000,0.322000],[\\dots],\\dots]$。",
            "solution": "用户提供的问题已经过验证，并被确定为是合理的。这是一个生物统计学中的良置问题，基于已确立的似然推断原则。所有提供的信息都是完整、一致且科学有效的。该问题要求推导并实现两种用于二项比例的置信区间，这是该领域一项标准且重要的任务。\n\n解决方案将按要求分三部分进行开发：\n1.  似然比（LR）置信区间的推导与实现。\n2.  Wilson得分置信区间的推导与实现。\n3.  将这些实现应用于所提供的测试用例并格式化输出。\n\n### 1. 似然比（LR）置信区间\n\n对于二项比例 $p$，在 $n$ 次试验中观测到 $x$ 次成功，其对数似然函数为 $\\ell(p) = x\\log(p) + (n-x)\\log(1-p)$，忽略不依赖于 $p$ 的常数。最大似然估计量（MLE）是 $\\hat{p} = x/n$。\n\n用于检验原假设 $H_0: p=p_0$ 的似然比检验统计量（或称偏差）是：\n$$ D(p_0) = 2 \\left( \\ell(\\hat{p}) - \\ell(p_0) \\right) $$\n代入对数似然表达式，我们得到：\n$$ D(p_0) = 2 \\left( \\left[ x\\log(\\hat{p}) + (n-x)\\log(1-\\hat{p}) \\right] - \\left[ x\\log(p_0) + (n-x)\\log(1-p_0) \\right] \\right) $$\n$$ D(p_0) = 2 \\left( x\\log\\left(\\frac{\\hat{p}}{p_0}\\right) + (n-x)\\log\\left(\\frac{1-\\hat{p}}{1-p_0}\\right) \\right) $$\n根据Wilks定理，$D(p_0)$ 近似服从自由度为1的卡方分布 $\\chi^2_1$。一个 $(1-\\alpha)$ 置信区间由在显著性水平 $\\alpha$ 下未被检验拒绝的所有 $p_0$ 值构成。这对应于满足 $D(p) \\le c_\\alpha$ 的 $p$ 的集合，其中 $c_\\alpha = \\chi^2_{1, 1-\\alpha}$ 是 $\\chi^2_1$ 分布的上 $(1-\\alpha)$ 分位数。区间的端点是非线性方程的根：\n$$ f(p) = 2 \\left( x\\log\\left(\\frac{\\hat{p}}{p}\\right) + (n-x)\\log\\left(\\frac{1-\\hat{p}}{1-p}\\right) \\right) - c_\\alpha = 0 $$\n为了解这个方程，我们使用Newton-Raphson方法，这需要 $f(p)$ 的导数：\n$$ f'(p) = \\frac{d}{dp} D(p) = 2 \\left( -\\frac{x}{p} + \\frac{n-x}{1-p} \\right) = 2 \\frac{np-x}{p(1-p)} $$\n迭代更新规则是 $p_{k+1} = p_k - f(p_k)/f'(p_k)$。一个稳健的实现需要处理数值稳定性问题，并确保解保持在 $(0,1)$ 的有效范围内。将使用一种混合的Newton-二分法，即当Newton步超出搜索界限时，采取二分法步骤。\n\n**边界情况：**\n-   如果 $x=0$，那么 $\\hat{p}=0$。对数似然 $\\ell(\\hat{p}) = \\ell(0) = 0$。偏差简化为 $D(p) = -2n\\log(1-p)$。区间的下界是 $0$。上界通过求解 $-2n\\log(1-p) = c_\\alpha$ 得到，即 $p_U = 1 - \\exp(-c_\\alpha / (2n))$。\n-   如果 $x=n$，那么 $\\hat{p}=1$。对数似然 $\\ell(\\hat{p}) = \\ell(1) = 0$。偏差简化为 $D(p) = -2n\\log(p)$。区间的上界是 $1$。下界通过求解 $-2n\\log(p) = c_\\alpha$ 得到，即 $p_L = \\exp(-c_\\alpha / (2n))$。\n\n### 2. Wilson得分置信区间\n\n得分函数是对数似然的一阶导数：\n$$ U(p) = \\frac{\\partial \\ell}{\\partial p} = \\frac{x-np}{p(1-p)} $$\n得分的方差是Fisher信息，$I(p) = n/(p(1-p))$。标准化得分检验统计量是 $Z(p) = U(p)/\\sqrt{I(p)}$，简化后为：\n$$ Z(p) = \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}} $$\n对于大的 $n$，$Z(p)$ 近似服从标准正态分布。$(1-\\alpha)$ 置信区间是使得得分检验不被拒绝的 $p$ 的集合，即 $|Z(p)| \\le z_{\\alpha/2}$，其中 $z_{\\alpha/2}$ 是标准正态分布的上 $\\alpha/2$ 分位数。这等价于 $Z(p)^2 \\le z_{\\alpha/2}^2$：\n$$ \\frac{(\\hat{p}-p)^2}{p(1-p)/n} \\le z_{\\alpha/2}^2 $$\n重新整理这个不等式，得到一个关于 $p$ 的二次不等式：\n$$ \\left(1 + \\frac{z_{\\alpha/2}^2}{n}\\right)p^2 - \\left(2\\hat{p} + \\frac{z_{\\alpha/2}^2}{n}\\right)p + \\hat{p}^2 \\le 0 $$\n相应的二次方程 $Ap^2+Bp+C=0$ 的根提供了区间的端点。使用二次公式，端点为：\n$$ p = \\frac{\\left(\\hat{p} + \\frac{z_{\\alpha/2}^2}{2n}\\right) \\pm z_{\\alpha/2}\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n} + \\frac{z_{\\alpha/2}^2}{4n^2}}}{1 + \\frac{z_{\\alpha/2}^2}{n}} $$\n这个公式被直接实现。\n\n### 3. 实现与最终输出\n\n以下 Python 代码实现了这些推导。创建了一个稳健的 Newton-Raphson 求解器来寻找一般情况下的LR区间根，而对于边界情况则使用特定的公式。Wilson区间使用其闭式解进行计算。每个测试用例的结果被收集并按要求格式化为单个字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2, norm\n\ndef _robust_newton_solver(f, f_prime, bounds, tol=1e-9, max_iter=100):\n    \"\"\"\n    A robust Newton-Raphson solver that falls back to bisection if a\n    step goes out of the specified bounds. This is suitable for finding\n    the roots of the well-behaved deviance function.\n    \"\"\"\n    low, high = bounds\n    p = (low + high) / 2.0  # Start with a bisection step\n\n    f_low = f(low)\n    \n    for _ in range(max_iter):\n        fp = f(p)\n        if abs(high - low)  tol or abs(fp)  tol:\n            return p\n\n        # Update bracket for bisection fallback\n        if f_low * fp  0:\n            high = p\n        else:\n            low = p\n            f_low = fp\n\n        f_prime_p = f_prime(p)\n        if abs(f_prime_p)  1e-12: # Avoid division by zero\n            p_next = (low + high) / 2.0\n        else:\n            p_next = p - fp / f_prime_p\n\n        # If Newton step is out of bounds, fall back to bisection\n        if not (low = p_next = high):\n            p_next = (low + high) / 2.0\n        \n        p = p_next\n\n    return p\n\ndef get_lr_interval(n, x, alpha):\n    \"\"\"\n    Computes the Likelihood Ratio (LR) confidence interval for a binomial proportion.\n    \"\"\"\n    p_hat = x / n\n    crit_val = chi2.ppf(1 - alpha, df=1)\n\n    # Handle boundary cases with derived closed-form solutions\n    if x == 0:\n        lower = 0.0\n        upper = 1 - np.exp(-crit_val / (2 * n))\n        return lower, upper\n\n    if x == n:\n        lower = np.exp(-crit_val / (2 * n))\n        upper = 1.0\n        return lower, upper\n    \n    # Deviance function to find roots for: D(p) - crit_val = 0\n    def f(p):\n        if p = 0 or p >= 1:\n            return np.inf\n        term1 = x * np.log(p_hat / p)\n        term2 = (n - x) * np.log((1 - p_hat) / (1 - p))\n        return 2 * (term1 + term2) - crit_val\n\n    # Derivative of the deviance function\n    def f_prime(p):\n        if p = 0 or p >= 1:\n            return np.inf\n        return 2 * (n * p - x) / (p * (1 - p))\n\n    # Find lower root\n    lower_bound_search = (1e-12, p_hat)\n    lower = _robust_newton_solver(f, f_prime, lower_bound_search)\n    \n    # Find upper root\n    upper_bound_search = (p_hat, 1 - 1e-12)\n    upper = _robust_newton_solver(f, f_prime, upper_bound_search)\n\n    return lower, upper\n\ndef get_wilson_interval(n, x, alpha):\n    \"\"\"\n    Computes the Wilson score confidence interval for a binomial proportion.\n    \"\"\"\n    p_hat = x / n\n    z = norm.ppf(1 - alpha / 2)\n    z_sq = z**2\n    \n    denominator = 1 + z_sq / n\n    center_adj = p_hat + z_sq / (2 * n)\n    spread = z * np.sqrt((p_hat * (1 - p_hat) / n) + (z_sq / (4 * n**2)))\n    \n    lower = (center_adj - spread) / denominator\n    upper = (center_adj + spread) / denominator\n    \n    return lower, upper\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        (50, 10, 0.05), # Case A\n        (50, 0, 0.05),  # Case B\n        (50, 50, 0.05), # Case C\n        (50, 1, 0.05),  # Case D\n        (200, 100, 0.01),# Case E\n    ]\n\n    all_results = []\n    for n, x, alpha in test_cases:\n        p_hat = x / n\n        \n        lr_lower, lr_upper = get_lr_interval(n, x, alpha)\n        wilson_lower, wilson_upper = get_wilson_interval(n, x, alpha)\n        \n        case_results = [\n            p_hat, \n            lr_lower, \n            lr_upper, \n            wilson_lower, \n            wilson_upper\n        ]\n        all_results.append(case_results)\n\n    # Format the output string exactly as specified.\n    result_strings = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        res_list_str = [f\"{v:.6f}\" for v in res_list]\n        result_strings.append(f\"[{','.join(res_list_str)}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "一个置信区间的名义置信水平（如 $95\\%$）是否能在实践中得到保证？这个问题引出了“覆盖率”这一核心概念。本练习将引导您对广为人知但性能不佳的瓦尔德（Wald）区间进行一次“压力测试”。您将编写代码，通过精确的二项分布概率来计算并可视化瓦尔德区间在所有可能的真实比例 $p$ 下的实际覆盖率，从而清晰地揭示其在何种情况下会严重低于名义水平，特别是在比例 $p$ 接近 $0$ 或 $1$ 的情况 。这项实践对于培养批判性思维和理解近似方法的局限性至关重要。",
            "id": "4911344",
            "problem": "考虑一个独立同分布的伯努利试验序列，其成功概率为 $p \\in [0,1]$，样本量为 $n \\in \\mathbb{N}$。令 $X \\sim \\mathrm{Binomial}(n,p)$，样本比例为 $\\hat{p} = X/n$。一个双边名义 $(1-\\alpha)$ 置信区间的覆盖函数为 $C(p;n,\\alpha) = \\mathbb{P}_{p}\\{p \\in I(X)\\}$，其中 $I(X)$ 是一个依赖于数据的区间。将在 $p$ 处的欠覆盖定义为 $U(p;n,\\alpha) = (1-\\alpha) - C(p;n,\\alpha)$。\n\n在本任务中，将 $I(X)$ 取为双边 Wald 区间，该区间是通过对 $\\hat{p}$ 分布的渐近正态近似进行逆变换，并使用插入式方差估计构建的，同时使用标准正态分布的 $(1-\\alpha/2)$ 分位数。请在二项模型下从基本原理出发，对于固定的 $n$ 和 $\\alpha$，计算精确覆盖率 $C(p;n,\\alpha)$，并由此计算作为 $p$ 的函数的欠覆盖 $U(p;n,\\alpha)$。\n\n你的程序必须：\n- 对于每个指定的测试用例，通过在 $[\\varepsilon,1-\\varepsilon]$ 上的一个包含 $M$ 个点的均匀网格 $p_1,\\dots,p_M$ 上计算 $U(p;n,\\alpha)$ 来近似 $\\sup_{p \\in [0,1]} U(p;n,\\alpha)$，其中 $\\varepsilon  0$ 是一个小的排除区域，并返回最大欠覆盖值以及出现最大值的网格点 $p^\\star$。\n- 此外，通过返回一个布尔值来量化最大化点 $p^\\star$ 是否靠近边界。如果 $p^\\star \\le \\delta$ 或 $p^\\star \\ge 1-\\delta$，则返回 $\\mathrm{True}$，否则返回 $\\mathrm{False}$。\n\n需要使用的基本依据和定义：\n- 二项模型 $X \\sim \\mathrm{Binomial}(n,p)$ 和精确覆盖率的定义 $C(p;n,\\alpha) = \\sum_{k=0}^{n} \\mathbb{P}_{p}(X=k) \\cdot \\mathbf{1}\\{p \\in I(k)\\}$。\n- Wald 区间是通过对 $\\hat{p}$ 的渐近正态性进行逆变换，并使用 $p(1-p)$ 的插入式方差估计来构建的，同时使用 $(1-\\alpha/2)$ 标准正态分位数。不允许使用其他区间构造方法。\n\n数值和输出要求：\n- 将所有概率（包括覆盖率和欠覆盖）表示为 $[0,1]$ 范围内的小数。\n- 对于每个测试用例，返回一个包含三项的列表：网格上的最大欠覆盖值、对应的网格点 $p^\\star$ 以及边界峰值布尔值。将所有浮点数输出四舍五入到 $6$ 位小数。\n- 你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个以逗号分隔的列表，并用方括号括起来，每个测试用例的结果本身也是一个列表。例如：$[ [a_1,b_1,c_1],[a_2,b_2,c_2] ]$。\n\n测试套件：\n- 用例 1：$n=10$, $\\alpha=0.05$, $M=2001$, $\\varepsilon=10^{-6}$, $\\delta=0.1$。\n- 用例 2：$n=10$, $\\alpha=0.10$, $M=2001$, $\\varepsilon=10^{-6}$, $\\delta=0.1$。\n- 用例 3：$n=50$, $\\alpha=0.05$, $M=2001$, $\\varepsilon=10^{-6}$, $\\delta=0.1$。\n- 用例 4：$n=200$, $\\alpha=0.05$, $M=2001$, $\\varepsilon=10^{-6}$, $\\delta=0.1$。\n\n最终输出格式：\n- 单行输出，包含四个用例结果的列表，每个结果的格式为 $[\\text{max\\_undercoverage}, \\text{p\\_star}, \\text{near\\_boundary}]$，浮点数四舍五入到 $6$ 位小数，例如：$[[0.123456,0.001000,\\mathrm{True}],[\\dots],\\dots]$。",
            "solution": "该问题要求计算二项比例 $p$ 的双边 Wald 置信区间的最大欠覆盖。计算必须使用精确的二项概率分布，而不是推导该区间时所用的正态近似。题目要求我们通过在一个精细的均匀 $p$ 值网格上进行评估，来近似欠覆盖函数的上确界 $\\sup_{p \\in [0,1]} U(p;n,\\alpha)$。\n\n设 $X \\sim \\mathrm{Binomial}(n,p)$ 是在 $n$ 次独立伯努利试验中成功的次数，其成功概率为 $p$。样本比例为 $\\hat{p} = X/n$。\n\n首先，我们定义 $p$ 的 Wald 置信区间。它源于样本比例的渐近正态性，其中统计量 $Z = (\\hat{p}-p)/\\sqrt{p(1-p)/n}$ 在分布上收敛于标准正态分布。Wald 区间用其插入式估计 $\\sqrt{\\hat{p}(1-\\hat{p})/n}$ 替代了未知的标准误 $\\sqrt{p(1-p)/n}$。对于给定的成功次数 $k$（其中 $\\hat{p}=k/n$），名义 $(1-\\alpha)$ Wald 区间 $I(k)$ 由下式给出：\n$$\nI(k) = \\left[ \\frac{k}{n} - z_{1-\\alpha/2} \\sqrt{\\frac{\\frac{k}{n}(1-\\frac{k}{n})}{n}}, \\frac{k}{n} + z_{1-\\alpha/2} \\sqrt{\\frac{\\frac{k}{n}(1-\\frac{k}{n})}{n}} \\right]\n$$\n其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$ 分位数。注意，对于边界情况 $k=0$ 和 $k=n$，估计的标准误为 $0$，导致区间退化为单点 $[0,0]$ 或 $[1,1]$。\n\n对于真实的比例 $p$，该区间的精确覆盖概率是所有可能结果 $k \\in \\{0, 1, \\dots, n\\}$ 的概率之和，条件是这些结果产生的区间 $I(k)$ 包含真实参数 $p$。其形式化表达式为：\n$$\nC(p; n, \\alpha) = \\mathbb{P}_{p}\\{p \\in I(X)\\} = \\sum_{k=0}^{n} \\mathbb{P}_{p}(X=k) \\cdot \\mathbf{1}\\{p \\in I(k)\\}\n$$\n其中 $\\mathbb{P}_{p}(X=k)$ 是二项概率质量函数 (PMF)，\n$$\n\\mathbb{P}_{p}(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}\n$$\n而 $\\mathbf{1}\\{p \\in I(k)\\}$ 是一个指示函数，如果 $p$ 在区间 $I(k)$ 内，则其值为 $1$，否则为 $0$。\n\n在给定 $p$ 处的欠覆盖是名义覆盖水平 $(1-\\alpha)$ 与实际覆盖概率 $C(p; n, \\alpha)$ 之间的差值：\n$$\nU(p; n, \\alpha) = (1-\\alpha) - C(p; n, \\alpha)\n$$\n$U(p)$ 的正值表示该区间的表现劣于其名义水平。\n\n问题要求我们找出在 $p \\in [0,1]$ 上的最大欠覆盖。$\\sup_{p} U(p)$ 的解析解是难以处理的。因此，我们将按照规定采用数值方法。我们将在区间 $[\\varepsilon, 1-\\varepsilon]$ 内一个密集的均匀 $M$ 点网格上评估 $U(p; n, \\alpha)$，其中 $\\varepsilon$ 是一个小的正数，以避免在边界 $p=0$ 和 $p=1$ 处出现数值问题。\n\n算法流程如下：\n1.  对于由 $(n, \\alpha, M, \\varepsilon, \\delta)$ 指定的给定测试用例，我们首先预计算 $(1-\\alpha/2)$ 标准正态分位数 $z_{1-\\alpha/2}$。\n2.  然后，我们为每个可能的结果 $k \\in \\{0, 1, \\dots, n\\}$ 预计算 $n+1$ 个 Wald 区间 $I(k)$。令这些区间的下界和上界为 $L_k$ 和 $U_k$。\n3.  生成一个包含 $M$ 个候选 $p$ 值的均匀网格：$p_1, \\dots, p_M$ 在 $[\\varepsilon, 1-\\varepsilon]$ 内。\n4.  对于网格中的每个 $p_j$，我们计算其精确覆盖率 $C(p_j; n, \\alpha)$。如果天真地计算，这将是计算密集型的。向量化的方法更有效：\n    a. 构建一个大小为 $M \\times (n+1)$ 的二项概率矩阵 $\\mathbf{B}$，其中 $\\mathbf{B}_{jk} = \\mathbb{P}_{p_j}(X=k)$。\n    b. 构建一个大小为 $M \\times (n+1)$ 的布尔指示矩阵 $\\mathbf{J}$，其中 $\\mathbf{J}_{jk} = \\mathbf{1}\\{p_j \\in [L_k, U_k]\\}$。这可以通过广播操作高效计算。\n    c. 然后通过将 $\\mathbf{B}$ 和 $\\mathbf{J}$ 逐元素相乘并沿行（$k$ 轴）求和，在单个向量化操作中计算所有 $p_j$ 的覆盖概率：$C(p_j) = \\sum_{k=0}^{n} \\mathbf{B}_{jk} \\mathbf{J}_{jk}$。\n5.  利用覆盖值向量，我们计算欠覆盖值向量：$U(p_j) = (1-\\alpha) - C(p_j)$。\n6.  我们在欠覆盖向量中找到最大值。该值是我们对 $\\sup_{p} U(p)$ 的近似。我们还从网格中识别出出现该最大值时对应的比例 $p^\\star$。\n7.  最后，我们通过检查 $p^\\star \\le \\delta$ 或 $p^\\star \\ge 1-\\delta$ 来确定 $p^\\star$ 是否接近边界 $0$ 或 $1$。\n8.  将结果——最大欠覆盖、 $p^\\star$ 和边界峰值布尔值——按要求进行四舍五入和格式化。\n\n该流程精确地实现了覆盖率的基本原理定义，并为指定问题提供了稳健的数值解。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, binom\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, alpha, M, epsilon, delta)\n        (10, 0.05, 2001, 1e-6, 0.1),\n        (10, 0.10, 2001, 1e-6, 0.1),\n        (50, 0.05, 2001, 1e-6, 0.1),\n        (200, 0.05, 2001, 1e-6, 0.1),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _calculate_max_undercoverage(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res in results:\n        max_u_str = f\"{res[0]:.6f}\"\n        p_star_str = f\"{res[1]:.6f}\"\n        near_b_str = str(res[2])\n        formatted_results.append(f\"[{max_u_str},{p_star_str},{near_b_str}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef _calculate_max_undercoverage(n, alpha, M, epsilon, delta):\n    \"\"\"\n    Calculates the maximum undercoverage and related metrics for a single test case.\n    \n    Args:\n        n (int): Sample size.\n        alpha (float): Significance level for (1-alpha) confidence.\n        M (int): Number of points in the grid for p.\n        epsilon (float): Small exclusion for the p-grid boundaries.\n        delta (float): Threshold for boundary-peaking check.\n\n    Returns:\n        list: [max_undercoverage, p_star, near_boundary]\n    \"\"\"\n    # 1. Set up constants and grids\n    z_crit = norm.ppf(1.0 - alpha / 2.0)\n    p_grid = np.linspace(epsilon, 1.0 - epsilon, M)\n    k_values = np.arange(0, n + 1)\n\n    # 2. Pre-calculate Wald intervals for all possible outcomes k=0,...,n\n    p_hat = k_values / n\n\n    # The variance term is p_hat * (1 - p_hat), which is 0 for k=0 and k=n.\n    # np.sqrt is safe as the term is always non-negative.\n    std_err = np.sqrt(p_hat * (1.0 - p_hat) / n)\n    margin_of_error = z_crit * std_err\n    \n    lower_bounds = p_hat - margin_of_error\n    upper_bounds = p_hat + margin_of_error\n\n    # 3. Calculate Binomial PMF matrix for all p in grid and all k\n    # Create meshgrids for vectorized calculation\n    k_mesh, p_mesh = np.meshgrid(k_values, p_grid)\n    binom_pmf_matrix = binom.pmf(k_mesh, n, p_mesh)\n\n    # 4. Calculate coverage vector using broadcasting\n    # Reshape p_grid to (M, 1) to broadcast against interval bounds of shape (1, n+1)\n    p_grid_col = p_grid[:, np.newaxis]\n    \n    # is_covered is a boolean matrix of shape (M, n+1)\n    # is_covered[j, k] is True if p_grid[j] is in I(k)\n    is_covered = (p_grid_col >= lower_bounds)  (p_grid_col = upper_bounds)\n\n    # Element-wise product and sum over k-axis gives coverage for each p\n    coverage_vector = np.sum(is_covered * binom_pmf_matrix, axis=1)\n\n    # 5. Calculate undercoverage and find its maximum\n    target_coverage = 1.0 - alpha\n    undercoverage_vector = target_coverage - coverage_vector\n    \n    max_idx = np.argmax(undercoverage_vector)\n    max_undercoverage = undercoverage_vector[max_idx]\n    p_star = p_grid[max_idx]\n\n    # 6. Determine if the maximizer p_star is near a boundary\n    near_boundary = (p_star = delta) or (p_star >= 1.0 - delta)\n\n    return [max_undercoverage, p_star, near_boundary]\n\nsolve()\n```"
        },
        {
            "introduction": "在生物统计实践中，我们常常需要在多种看似合理的统计方法中做出选择。本综合性练习将指导您使用蒙特卡洛模拟这一强大的工具，对三种常用的比例置信区间——瓦尔德（Wald）区间、威尔逊得分（Wilson score）区间和阿格雷斯蒂-库尔（Agresti-Coull）区间——进行全面的性能评估。通过模拟成千上万次实验，您将经验性地估计并比较这些区间在不同样本量和真实比例下的实际覆盖率和期望长度，从而为您在未来的研究中“应该使用哪种置信区间”提供坚实的数据支持和决策依据 。",
            "id": "4911278",
            "problem": "单个总体比率由二项分布建模。设$X$表示在$n$次独立伯努利试验中观测到的成功次数，其成功概率为$p$，因此$X \\sim \\mathrm{Binomial}(n,p)$，样本比率为$\\hat{p} = X/n$。可以通过将此模型与大样本近似和检验反演相结合来推导$p$的置信区间。您的任务是推导、实现和比较三个区间：Wald区间、Wilson得分区间和Agresti–Coull区间。\n\n从二项模型以及得分检验和Wald检验的定义出发，仅使用基本原理推导每个区间：\n- 从二项似然以及得分检验和Wald检验的定义开始。\n- 在适当的情况下，通过（针对独立同分布伯努利变量的）中心极限定理，证明当$n$较大时$\\hat{p}$的正态近似是合理的。\n- 通过反演基于二项模型的$p$的得分检验来获得Wilson得分区间。\n- 应用受Wilson得分区间启发的加-$z^2$方法，并对调整后的样本比率使用类Wald形式，来获得Agresti–Coull区间。\n\n所有区间都必须被截断到$p$的有效参数范围$[0,1]$内。\n\n对于固定的名义置信水平$1-\\alpha$，将区间过程的覆盖概率定义为：在数据生成过程的$p$下，真实的$p$落入基于$X$计算出的区间内的概率。将区间的期望长度定义为：在数据生成过程的$p$下，区间长度的期望值。在此任务中，通过蒙特卡洛模拟对这两个量进行经验性近似。\n\n实现要求：\n- 对于每个测试用例，模拟$R$个独立实现$X_r \\sim \\mathrm{Binomial}(n,p)$，$r=1,\\dots,R$，根据$X_r$计算三个区间，并将覆盖率估计为区间包含真实$p$的模拟次数所占的比例。\n- 将期望长度估计为$R$次模拟的平均区间长度。\n- 使用从标准正态分布中获得的、与双侧水平$\\alpha$相对应的标准正态分位数$z$。\n- 为保证可复现性，使用固定的随机数生成器种子，其值为$20231111$。\n- 所有覆盖概率都必须以小数形式表示（不带百分号）。\n- 输出必须将所有测试用例的结果汇总到单行中。每个测试用例按以下顺序提供六个数字：Wald覆盖率、Wald期望长度、Wilson覆盖率、Wilson期望长度、Agresti–Coull覆盖率、Agresti–Coull期望长度。每个数字必须四舍五入到小数点后四位。\n\n测试套件：\n- 置信水平：$1-\\alpha = 0.95$，即$\\alpha = 0.05$（小数形式）。\n- 对于中等样本量和一系列包括内部值和边界邻近值的成功概率，使用以下用例（其中$R$表示每个用例的蒙特卡洛抽样次数）：\n  1. $(n,p,\\alpha,R) = (40, 0.10, 0.05, 100000)$，\n  2. $(n,p,\\alpha,R) = (80, 0.50, 0.05, 100000)$，\n  3. $(n,p,\\alpha,R) = (60, 0.90, 0.05, 100000)$，\n  4. $(n,p,\\alpha,R) = (50, 0.02, 0.05, 100000)$，\n  5. $(n,p,\\alpha,R) = (50, 0.98, 0.05, 100000)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的Python列表的列表形式的结果，每个内部列表对应一个测试用例，顺序与上述规定完全一致。例如，输出行必须类似于\n$[\\,[c_{1,\\mathrm{Wald}},\\ell_{1,\\mathrm{Wald}},c_{1,\\mathrm{Wilson}},\\ell_{1,\\mathrm{Wilson}},c_{1,\\mathrm{AC}},\\ell_{1,\\mathrm{AC}}],\\dots,[c_{5,\\mathrm{Wald}},\\ell_{5,\\mathrm{Wald}},c_{5,\\mathrm{Wilson}},\\ell_{5,\\mathrm{Wilson}},c_{5,\\mathrm{AC}},\\ell_{5,\\mathrm{AC}}]\\,]$,\n其中每个$c$是小数形式的覆盖概率，每个$\\ell$是小数形式的期望长度，所有值均四舍五入到小数点后四位。",
            "solution": "该问题要求对单个二项比率$p$的三个常用近似置信区间进行推导、实现和经验比较。统计模型假设，在大小为$n$的样本中，观测到的成功次数$X$服从二项分布，$X \\sim \\mathrm{Binomial}(n,p)$。样本比率$\\hat{p} = X/n$作为$p$的点估计量。\n\n这些大样本近似区间的基础是中心极限定理（CLT）。由于$X$是$n$个独立同分布的$\\mathrm{Bernoulli}(p)$随机变量之和，中心极限定理保证了对于足够大的样本量$n$，$\\hat{p}$的抽样分布近似为正态分布：\n$$\n\\hat{p} \\approx \\mathcal{N}\\left(p, \\frac{p(1-p)}{n}\\right)\n$$\n这意味着标准化随机变量$Z = \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}}$在分布上收敛于标准正态分布$\\mathcal{N}(0,1)$。所有三个区间都是通过对原假设$H_0: p = p_0$的统计检验进行反演而构建的，但它们在处理标准误项$\\sqrt{p(1-p)/n}$上有所不同，该项依赖于未知参数$p$。对于名义置信水平$1-\\alpha$，我们使用临界值$z_{\\alpha/2}$，即标准正态分布的上$\\alpha/2$分位数。\n\n**Wald区间**\n\nWald区间是通过反演Wald检验推导出来的。在Wald检验统计量中，标准误项中的未知参数$p$被其最大似然估计量$\\hat{p}$所取代。$H_0: p = p_0$的检验统计量因此为$Z = \\frac{\\hat{p}-p_0}{\\sqrt{\\hat{p}(1-\\hat{p})/n}}$。$p$的$100(1-\\alpha)\\%$置信区间被定义为所有使得该检验在显著性水平$\\alpha$下不会拒绝原假设的$p_0$值的集合。这对应于不等式：\n$$\n\\left| \\frac{\\hat{p}-p}{\\sqrt{\\hat{p}(1-\\hat{p})/n}} \\right| \\le z_{\\alpha/2}\n$$\n对该不等式求解$p$，得到对称的Wald区间：\n$$\n\\hat{p} \\pm z_{\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}\n$$\n虽然简单，但该区间的性能表现不佳，尤其是在$n$较小或$p$接近边界0或1时。其实际覆盖概率经常低于名义水平。当$\\hat{p}=0$或$\\hat{p}=1$时会出现一个严重缺陷，此时标准误为0，导致一个荒谬的零宽度区间。根据问题要求，所得区间必须被截断以落在有效参数空间$[0,1]$内。\n\n**Wilson得分区间**\n\nWilson得分区间是通过反演得分检验推导出来的。得分检验在标准误项中保留了参数的原假设值$p$。置信区间是满足以下不等式的所有$p$值的集合：\n$$\n\\left| \\frac{\\hat{p}-p}{\\sqrt{p(1-p)/n}} \\right| \\le z_{\\alpha/2}\n$$\n令$z = z_{\\alpha/2}$，对两边平方得到$(\\hat{p}-p)^2 \\le z^2 \\frac{p(1-p)}{n}$。整理此表达式可得到一个关于$p$的二次不等式。该区间的端点是相应二次方程的根：\n$$\n(n+z^2)p^2 - (2n\\hat{p} + z^2)p + n\\hat{p}^2 = 0\n$$\n应用二次公式，定义区间的两个$p$的根是：\n$$\n\\frac{n\\hat{p} + z^2/2}{n+z^2} \\pm \\frac{z}{n+z^2} \\sqrt{n\\hat{p}(1-\\hat{p}) + z^2/4}\n$$\nWilson区间提供了比Wald区间好得多的性能。它通常是非对称的（除非$\\hat{p}=0.5$），并且即使对于较小的样本量和接近边界的比率，其覆盖概率也更接近名义水平$1-\\alpha$。它本身就包含在$[0,1]$内，因此不需要显式截断。\n\n**Agresti-Coull区间**\n\nAgresti-Coull（AC）区间是一种备受推崇的调整方法，它将Wilson区间的优越性能特点与Wald区间的简单结构相结合。其推导是受Wilson区间中心点$\\frac{X + z^2/2}{n+z^2}$的启发。该表达式可以看作是基于调整后的样本量$\\tilde{n} = n+z^2$和调整后的成功次数$\\tilde{X} = X + z^2/2$的一个新的样本比率。AC区间就是一个使用这些调整后数值计算的类Wald区间。\n令$z = z_{\\alpha/2}$。首先，我们定义调整后的样本比率：\n$$\n\\tilde{p} = \\frac{X + z^2/2}{n + z^2}\n$$\n然后，AC区间构造如下：\n$$\n\\tilde{p} \\pm z \\sqrt{\\frac{\\tilde{p}(1-\\tilde{p})}{\\tilde{n}}} \\quad \\text{其中 } \\tilde{n} = n+z^2\n$$\n对于$95\\%$的置信水平，$z \\approx 1.96$且$z^2 \\approx 3.84$，这通常简化为$z^2 \\approx 4$。这就引出了著名的“加2个成功和2个失败”的规则。我们将使用包含$z^2$精确值的更通用的形式。AC区间也必须被截断到$[0,1]$范围内。\n\n**蒙特卡洛评估方法**\n\n为了经验性地评估和比较这三个区间的性质，我们采用蒙特卡洛模拟。对于测试套件中指定的每个参数组合$(n, p, \\alpha, R)$，我们执行以下步骤：\n1.  从二项分布中生成$R$个独立的随机变量：$X_r \\sim \\mathrm{Binomial}(n,p)$，其中$r = 1, \\dots, R$。\n2.  对于每个实现$X_r$，计算样本比率$\\hat{p}_r = X_r/n$，然后计算三个置信区间（Wald、Wilson、Agresti-Coull）中每一个的下界和上界。\n3.  每种区间类型的经验覆盖概率计算为在$R$次模拟中，真实参数值$p$包含在计算出的区间内的比例：\n    $$\n    \\text{Coverage} = \\frac{1}{R} \\sum_{r=1}^R \\mathbb{I}(p \\in [L_r, U_r])\n    $$\n    其中$[L_r, U_r]$是第$r$次模拟的区间，$\\mathbb{I}(\\cdot)$是指示函数。\n4.  每个区间的期望长度通过对$R$个计算出的区间的长度求平均来估计：\n    $$\n    \\text{Expected Length} = \\frac{1}{R} \\sum_{r=1}^R (U_r - L_r)\n    $$\n一个更优的区间是指其覆盖概率能达到接近名义水平$1-\\alpha$的同时，具有最小的期望长度。模拟使用固定的随机种子$20231111$进行，以确保可复现性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares Wald, Wilson score, and Agresti-Coull \n    confidence intervals for a binomial proportion via Monte Carlo simulation.\n    \"\"\"\n    # Define test cases: (n, p, alpha, R)\n    test_cases = [\n        (40, 0.10, 0.05, 100000),\n        (80, 0.50, 0.05, 100000),\n        (60, 0.90, 0.05, 100000),\n        (50, 0.02, 0.05, 100000),\n        (50, 0.98, 0.05, 100000),\n    ]\n\n    # Set random seed for reproducibility\n    seed = 20231111\n    rng = np.random.default_rng(seed)\n\n    all_results = []\n\n    for n, p_true, alpha, R in test_cases:\n        # Calculate the standard normal quantile z_{alpha/2}\n        z = norm.ppf(1 - alpha / 2)\n        z_sq = z**2\n\n        # Generate R binomial random variates\n        X = rng.binomial(n, p_true, size=R)\n        phat = X / n\n\n        # --- 1. Wald Interval ---\n        # Standard error for Wald interval\n        se_wald = np.sqrt(phat * (1 - phat) / n)\n        \n        # Calculate interval bounds\n        lower_wald = phat - z * se_wald\n        upper_wald = phat + z * se_wald\n        \n        # Truncate interval to [0, 1]\n        lower_wald = np.maximum(0, lower_wald)\n        upper_wald = np.minimum(1, upper_wald)\n        \n        # Calculate coverage and expected length\n        coverage_wald = np.mean((lower_wald = p_true)  (upper_wald >= p_true))\n        length_wald = np.mean(upper_wald - lower_wald)\n        \n        # --- 2. Wilson Score Interval ---\n        center_wilson = (phat + z_sq / (2 * n)) / (1 + z_sq / n)\n        width_term_wilson = (z / (1 + z_sq / n)) * np.sqrt(phat * (1 - phat) / n + z_sq / (4 * n**2))\n        \n        lower_wilson = center_wilson - width_term_wilson\n        upper_wilson = center_wilson + width_term_wilson\n        \n        # Wilson interval is naturally within [0,1], but clipping for numerical stability\n        lower_wilson = np.maximum(0, lower_wilson)\n        upper_wilson = np.minimum(1, upper_wilson)\n\n        # Calculate coverage and expected length\n        coverage_wilson = np.mean((lower_wilson = p_true)  (upper_wilson >= p_true))\n        length_wilson = np.mean(upper_wilson - lower_wilson)\n\n        # --- 3. Agresti-Coull Interval ---\n        n_tilde = n + z_sq\n        p_tilde = (X + z_sq / 2) / n_tilde\n\n        se_ac = np.sqrt(p_tilde * (1 - p_tilde) / n_tilde)\n        \n        lower_ac = p_tilde - z * se_ac\n        upper_ac = p_tilde + z * se_ac\n\n        # Truncate interval to [0, 1]\n        lower_ac = np.maximum(0, lower_ac)\n        upper_ac = np.minimum(1, upper_ac)\n        \n        # Calculate coverage and expected length\n        coverage_ac = np.mean((lower_ac = p_true)  (upper_ac >= p_true))\n        length_ac = np.mean(upper_ac - lower_ac)\n\n        # Store results for the current test case\n        case_results = [\n            coverage_wald, length_wald,\n            coverage_wilson, length_wilson,\n            coverage_ac, length_ac\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as a list of lists with 4-decimal rounding\n    formatted_results = []\n    for res_list in all_results:\n        # Format each number to 4 decimal places\n        formatted_list = [f\"{val:.4f}\" for val in res_list]\n        # Create the string representation of the inner list\n        formatted_results.append(f\"[{','.join(formatted_list)}]\")\n    \n    # Create the final string representation of the list of lists\n    final_output_string = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}