{
    "hands_on_practices": [
        {
            "introduction": "在生物统计学中，我们经常遇到表示比率或倍数变化的数据，例如基因表达或生物标志物的浓度变化。对于这类具有乘法性质的数据，传统的算术平均值可能无法准确反映其中心趋势。本练习  将从第一性原理出发，推导并应用几何平均值作为一种更合适的汇总统计量，并将其与算术平均值进行对比，从而加深你对不同类型数据应选择何种中心趋势度量指标的理解。",
            "id": "4955574",
            "problem": "一个实验室量化了 $n$ 名患者干预后相对于基线测量的血清生物标志物的倍数变化，其中每个倍数变化 $X_i$ 都是严格正数。在一个生物学上合理的倍数变化乘性误差模型下，每个观测值满足 $X_i = \\theta \\cdot U_i$ 且 $U_i > 0$，其自然对数满足 $\\mathbb{E}[\\ln(U_i)] = 0$。仅使用平均值和变换的核心定义与性质，从第一性原理出发，为 $\\{X_i\\}_{i=1}^{n}$ 推导出一个适合乘性效应的集中趋势的单数值摘要，并对以下数据进行计算。同时，计算 $\\{X_i\\}_{i=1}^{n}$ 的算术平均值。最后，报告对于以下观测到的倍数变化，算术平均值与该乘性摘要值的比率：\n$$\n0.62,\\; 0.75,\\; 0.88,\\; 1.04,\\; 1.22,\\; 1.35,\\; 1.60,\\; 1.90,\\; 2.10,\\; 2.50.\n$$\n将您最终报告的比率四舍五入到四位有效数字。最终答案以无单位小数形式表示。",
            "solution": "该问题要求推导适用于遵循乘性误差模型数据的集中趋势摘要，为给定数据集计算其值，为同一数据集计算算术平均值，最后计算这两个汇总统计量的比率。\n\n**步骤1：问题陈述的验证**\n\n在尝试任何解答之前，该问题都经过了严格的验证程序。\n\n**1.1. 提取已知条件：**\n- 一组 $n$ 个倍数变化测量值 $\\{X_i\\}_{i=1}^{n}$，其中每个 $X_i > 0$。\n- 一个乘性误差模型：$X_i = \\theta \\cdot U_i$，其中 $\\theta$ 是集中趋势参数，$U_i > 0$ 是乘性误差项。\n- 误差项的一个性质：$\\mathbb{E}[\\ln(U_i)] = 0$。\n- 一个包含 $n=10$ 个观测值的特定数据集：$\\{0.62, 0.75, 0.88, 1.04, 1.22, 1.35, 1.60, 1.90, 2.10, 2.50\\}$。\n- 将最终比率四舍五入到四位有效数字的指令。\n\n**1.2. 根据标准进行验证：**\n- **科学依据：** 该问题在科学上是合理的。乘性模型和对数变换是生物统计学中分析浓度、倍数变化或基因表达水平等数据的标准和基本工具，这些数据通常是右偏和异方差的。假设 $\\mathbb{E}[\\ln(U_i)] = 0$ 是将误差项在 $1$ 附近（乘性意义上）中心化的标准方法。\n- **适定性：** 该问题是适定的。它提供了所有必要的信息和一个明确的目标：基于模型推导 $\\theta$ 的估计量，计算它，计算算术平均值，并求出它们的比率。解的存在性和唯一性得到保证。\n- **客观性：** 该问题用精确、客观的数学和统计语言陈述。\n- **结论：** 问题陈述是有效的，因为它具有科学依据、适定、客观，并且没有明显缺陷。\n\n**步骤2：乘性摘要统计量的推导**\n\n目标是从给定模型 $X_i = \\theta \\cdot U_i$ 中找到参数 $\\theta$ 的合适估计量。模型的结构涉及乘法，这提示我们使用对数变换。对模型方程两边取自然对数，得到：\n$$\n\\ln(X_i) = \\ln(\\theta \\cdot U_i) = \\ln(\\theta) + \\ln(U_i)\n$$\n这个变换将乘性关系转换为加性关系。为清晰起见，我们定义新变量：$Y_i = \\ln(X_i)$，$\\mu = \\ln(\\theta)$，以及 $\\epsilon_i = \\ln(U_i)$。用这些新变量表示的模型变为：\n$$\nY_i = \\mu + \\epsilon_i\n$$\n这是一个标准的加性误差模型。问题陈述中说明 $\\mathbb{E}[\\ln(U_i)] = \\mathbb{E}[\\epsilon_i] = 0$。我们现在可以求出对数变换后数据 $Y_i$ 的期望值：\n$$\n\\mathbb{E}[Y_i] = \\mathbb{E}[\\mu + \\epsilon_i] = \\mathbb{E}[\\mu] + \\mathbb{E}[\\epsilon_i]\n$$\n因为 $\\mu$ 是一个常数，所以 $\\mathbb{E}[\\mu] = \\mu$。因此，\n$$\n\\mathbb{E}[Y_i] = \\mu + 0 = \\mu\n$$\n这表明 $\\mu = \\ln(\\theta)$ 是对数变换后观测值的总体均值。对于总体均值，一个自然且无偏的估计量是样本均值。因此，$\\mu$ 的估计量，记作 $\\hat{\\mu}$，是观测值 $Y_i$ 的平均值：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{i=1}^{n} Y_i = \\frac{1}{n} \\sum_{i=1}^{n} \\ln(X_i)\n$$\n我们的目标是估计 $\\theta$，而不是 $\\mu$。由于 $\\mu = \\ln(\\theta)$，我们可以通过取指数来恢复 $\\theta$：$\\theta = \\exp(\\mu)$。将此逆变换应用于我们的估计量 $\\hat{\\mu}$，得到 $\\theta$ 的估计量，记作 $\\hat{\\theta}$：\n$$\n\\hat{\\theta} = \\exp(\\hat{\\mu}) = \\exp\\left(\\frac{1}{n} \\sum_{i=1}^{n} \\ln(X_i)\\right)\n$$\n使用对数的性质，其中 $\\sum \\ln(a_i) = \\ln(\\prod a_i)$ 和 $c \\ln(a) = \\ln(a^c)$，我们可以重写该表达式：\n$$\n\\hat{\\theta} = \\exp\\left( \\frac{1}{n} \\ln\\left(\\prod_{i=1}^{n} X_i\\right) \\right) = \\exp\\left( \\ln\\left[ \\left(\\prod_{i=1}^{n} X_i\\right)^{1/n} \\right] \\right)\n$$\n由于指数函数和自然对数函数是互逆函数，这可以简化为：\n$$\n\\hat{\\theta} = \\left(\\prod_{i=1}^{n} X_i\\right)^{1/n}\n$$\n这是几何平均值的定义。因此，对于这个乘性模型，几何平均值是合适的集中趋势的单数值摘要。我们将其记为 $G$。\n\n**步骤3：几何平均值与算术平均值的计算**\n\n提供的数据集是 $\\{0.62, 0.75, 0.88, 1.04, 1.22, 1.35, 1.60, 1.90, 2.10, 2.50\\}$。观测数量为 $n=10$。\n\n首先，我们计算几何平均值 $G$。为保证数值稳定性，最好使用对数形式：\n$$\n\\ln(G) = \\frac{1}{10} \\sum_{i=1}^{10} \\ln(X_i)\n$$\n数据的自然对数之和为：\n$$\n\\sum_{i=1}^{10} \\ln(X_i) = \\ln(0.62) + \\ln(0.75) + \\ln(0.88) + \\ln(1.04) + \\ln(1.22) + \\ln(1.35) + \\ln(1.60) + \\ln(1.90) + \\ln(2.10) + \\ln(2.50)\n$$\n$$\n\\sum_{i=1}^{10} \\ln(X_i) \\approx -0.478036 - 0.287682 - 0.127833 + 0.039221 + 0.198851 + 0.300105 + 0.470004 + 0.641854 + 0.741937 + 0.916291 \\approx 2.414712\n$$\n$$\n\\ln(G) \\approx \\frac{2.414712}{10} = 0.2414712\n$$\n现在，我们通过取指数来求 $G$：\n$$\nG = \\exp(\\ln(G)) \\approx \\exp(0.2414712) \\approx 1.273087\n$$\n接下来，我们计算算术平均值 $A$：\n$$\nA = \\frac{1}{n} \\sum_{i=1}^{n} X_i = \\frac{1}{10} \\sum_{i=1}^{10} X_i\n$$\n数据之和为：\n$$\n\\sum_{i=1}^{10} X_i = 0.62 + 0.75 + 0.88 + 1.04 + 1.22 + 1.35 + 1.60 + 1.90 + 2.10 + 2.50 = 13.96\n$$\n$$\nA = \\frac{13.96}{10} = 1.396\n$$\n\n**步骤4：比率的计算**\n\n问题要求计算算术平均值与乘性摘要值（几何平均值）的比率。设该比率为 $R$。\n$$\nR = \\frac{A}{G}\n$$\n代入计算出的值：\n$$\nR = \\frac{1.396}{1.273087} \\approx 1.096545\n$$\n问题要求将此比率四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$9$、$6$。第五位数字是 $5$，所以我们将第四位数字向上取整。\n$$\nR \\approx 1.097\n$$\n作为检验，算术-几何平均值不等式指出，一组非负实数的算术平均值大于或等于它们的几何平均值。由于我们的数据点不完全相等，我们期望 $A > G$，这意味着 $R > 1$。我们的结果 $R \\approx 1.097$ 与这一原则相符。",
            "answer": "$$\\boxed{1.097}$$"
        },
        {
            "introduction": "真实世界的临床数据常常受到极端异常值的影响，这些异常值可能源于测量误差或个体特殊情况。传统的算术平均值对这些异常值极为敏感，可能导致对数据中心趋势的误判。本练习  将介绍一种稳健的统计方法——缩尾平均值（trimmed mean），通过计算并比较它与普通样本均值的差异，你将学会如何获得一个更可靠、更能抵抗异常值污染的中心位置估计。",
            "id": "4955542",
            "problem": "一项临床实验室研究记录了一个由 $n=20$ 名成年参与者组成的队列的丙氨酸氨基转移酶 (ALT) 水平，单位为单位/升 (U/L)。由于真实世界的数据收集，样本中包含严重的离群值。观测到的 ALT 值为：\n$$12,\\ 18,\\ 22,\\ 25,\\ 27,\\ 29,\\ 31,\\ 33,\\ 35,\\ 36,\\ 38,\\ 40,\\ 42,\\ 45,\\ 47,\\ 50,\\ 52,\\ 55,\\ 310,\\ 420.$$\n使用基于次序统计量的 $\\alpha$-截尾均值的定义，计算该样本的 $20\\%$-截尾均值。然后，在存在污染数据的情况下，从偏差-方差权衡的角度，将其与普通样本均值 $\\bar{X}_n$ 进行概念上的比较，以总结中心趋势。将您计算出的 $20\\%$-截尾均值四舍五入到四位有效数字，并以 $\\text{U/L}$ 为单位表示。最终报告的答案必须是 $20\\%$-截尾均值的单个数值。",
            "solution": "该问题被认为是有效的，因为它在生物统计学方面有科学依据，问题提出得当且提供了所有必要数据，并且其表述是客观的。它提出了一个计算中心趋势的稳健度量，并将其与经典估计量进行概念性比较的标准任务。\n\n该问题要求计算给定丙氨酸氨基转移酶 (ALT) 水平样本的 $20\\%$-截尾均值。样本大小为 $n=20$，截尾比例为 $\\alpha = 0.20$。\n\n所提供的数据为：\n$$12,\\ 18,\\ 22,\\ 25,\\ 27,\\ 29,\\ 31,\\ 33,\\ 35,\\ 36,\\ 38,\\ 40,\\ 42,\\ 45,\\ 47,\\ 50,\\ 52,\\ 55,\\ 310,\\ 420.$$\n这些值已经按非递减顺序排序，因此它们代表了次序统计量 $X_{(1)}, X_{(2)}, \\ldots, X_{(20)}$。\n\n$\\alpha$-截尾均值，记为 $\\bar{X}_{\\alpha}$，其定义为从已排序样本的下尾和上尾各移除比例为 $\\alpha$ 的观测值，然后计算剩余数据的算术平均值。从两端各截去的观测值数量 $k$ 由 $k = \\lfloor n\\alpha \\rfloor$ 给出，其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。\n\n对于本题，我们有：\n- 样本大小, $n = 20$\n- 截尾比例, $\\alpha = 0.20$\n\n从两端各截去的观测值数量为：\n$$ k = \\lfloor n\\alpha \\rfloor = \\lfloor 20 \\times 0.20 \\rfloor = \\lfloor 4 \\rfloor = 4 $$\n这意味着我们必须从样本中移除 $4$ 个最小值和 $4$ 个最大值。\n\n次序统计量为 $X_{(1)}, X_{(2)}, \\ldots, X_{(20)}$。我们从底部截去 $X_{(1)}, \\ldots, X_{(4)}$，从顶部截去 $X_{(17)}, \\ldots, X_{(20)}$。\n被截去的观测值是：\n- 下尾: $X_{(1)}=12,\\ X_{(2)}=18,\\ X_{(3)}=22,\\ X_{(4)}=25$\n- 上尾: $X_{(17)}=52,\\ X_{(18)}=55,\\ X_{(19)}=310,\\ X_{(20)}=420$\n\n$\\alpha$-截尾均值的公式为：\n$$ \\bar{X}_{\\alpha} = \\frac{1}{n - 2k} \\sum_{i=k+1}^{n-k} X_{(i)} $$\n在我们的例子中，这变为：\n$$ \\bar{X}_{0.20} = \\frac{1}{20 - 2(4)} \\sum_{i=4+1}^{20-4} X_{(i)} = \\frac{1}{12} \\sum_{i=5}^{16} X_{(i)} $$\n\n需要求平均值的剩余观测值为：\n$$ X_{(5)}=27,\\ X_{(6)}=29,\\ X_{(7)}=31,\\ X_{(8)}=33,\\ X_{(9)}=35,\\ X_{(10)}=36,\\ X_{(11)}=38,\\ X_{(12)}=40,\\ X_{(13)}=42,\\ X_{(14)}=45,\\ X_{(15)}=47,\\ X_{(16)}=50 $$\n这些观测值的总和是：\n$$ \\sum_{i=5}^{16} X_{(i)} = 27 + 29 + 31 + 33 + 35 + 36 + 38 + 40 + 42 + 45 + 47 + 50 = 453 $$\n这个总和中的观测值数量为 $n - 2k = 20 - 8 = 12$。\n\n现在，我们计算 $20\\%$-截尾均值：\n$$ \\bar{X}_{0.20} = \\frac{453}{12} = 37.75 $$\n题目要求四舍五入到四位有效数字。数值 $37.75$ 已经有四位有效数字。因此，$20\\%$-截尾均值为 $37.75 \\text{ U/L}$。\n\n为了进行概念性比较，我们首先计算普通样本均值 $\\bar{X}_n$：\n$$ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^n X_i = \\frac{1}{20} \\sum_{i=1}^{20} X_{(i)} $$\n所有观测值的总和是：\n$$ \\sum_{i=1}^{20} X_{(i)} = (12+18+22+25) + 453 + (52+55+310+420) = 77 + 453 + 837 = 1367 $$\n$$ \\bar{X}_{20} = \\frac{1367}{20} = 68.35 $$\n普通样本均值为 $68.35 \\text{ U/L}$。这个值受到两个极端离群值（$310$ 和 $420$）的严重影响，并且除了这两个值之外比所有其他值都大，这使其成为该数据集中心趋势的一个不良度量。\n\n偏差-方差权衡的比较如下：\n- **样本均值 ($\\bar{X}_n$)**：对于正态分布的均值，该估计量是一致最小方差无偏估计量 (UMVUE)。在这种理想假设下，它具有最高的统计效率（最低的方差）。然而，其崩溃点为 $0$，意味着单个任意大的离群值就可以将估计值破坏到任意程度。在存在污染数据的情况下，如本问题所示，样本均值可能会变得高度有偏，并且其抽样方差会急剧膨胀。它不是一个稳健的估计量。\n- **截尾均值 ($\\bar{X}_{\\alpha}$)**：这是一个稳健的估计量。通过舍弃一小部分极端值，它保护了估计值免受离群值的影响。\n    - **偏差**：如果潜在的真实分布是对称的，截尾均值是该对称中心的无偏估计量。如果分布是偏态的，截尾均值将是有偏的，但这种偏差通常小于少数极端离群值在样本均值中引起的偏差。它为分布主体部分的中心趋势提供了更好的估计。\n    - **方差**：对于来自完美正态分布的数据，截尾均值的方差略高于样本均值，这表示效率的损失。这是稳健性的“代价”。然而，对于来自重尾分布的数据，或者像本例中这样被离群值污染的分布，截尾均值的方差远低于样本均值。\n总之，截尾均值在理想条件下牺牲了一些效率，以在更现实的、包含污染数据或非正态数据的情景中获得显著的稳健性（更低的偏差和更低的方差）。对于给定的 ALT 数据，截尾均值 $37.75 \\text{ U/L}$ 比样本均值 $68.35 \\text{ U/L}$ 更能代表中心值。\n\n最终要求的答案是 $20\\%$-截尾均值的数值。\n$$ \\bar{X}_{0.20} = 37.75 $$",
            "answer": "$$\\boxed{37.75}$$"
        },
        {
            "introduction": "选择一个合适的汇总统计量（如中位数）只是数据分析的第一步，我们还需要量化其估计的不确定性，即标准误。对于中位数这类稳健统计量，其标准误的解析公式可能非常复杂或不存在。本练习  将引导你使用功能强大的非参数自助法（nonparametric bootstrap），通过编写代码进行模拟重抽样，来估计样本中位数的不确定性，从而掌握一项核心的现代计算统计技能。",
            "id": "4955521",
            "problem": "考虑来自未知分布 $F$ 的独立同分布观测值 $X_1,\\ldots,X_n$。经验累积分布函数 (ECDF) 定义为 $\\hat F_n(x) = \\frac{1}{n}\\sum_{i=1}^n \\mathbf{1}\\{X_i \\le x\\}$。对于一个汇总统计量 $T(\\hat F_n)$，非参数自助法通过 $T(\\hat F_n^\\ast)$ 的条件分布来近似 $T(\\hat F_n)$ 的抽样分布，其中 $\\hat F_n^\\ast$ 是从 $\\{X_1,\\ldots,X_n\\}$ 中有放回抽取的自助样本 $X_1^\\ast,\\ldots,X_n^\\ast$ 的 ECDF。自助标准误是从 $B$ 个独立重抽样的自助数据集中计算出的自助重复值 $T^{\\ast (1)},\\ldots,T^{\\ast (B)}$ 的标准差。\n\n你的任务是：\n- 通过从 $\\hat F_n$ 构建自助样本并计算自助重复值 $T^{\\ast (b)}$（其中 $b=1,\\ldots,B$），为通用统计量 $T(\\hat F_n)$ 定义非参数自助法。\n- 将 $T(\\hat F_n)$ 具体化为样本中位数。对于偶数样本量 $n$，将样本中位数定义为两个中心顺序统计量的平均值。对于奇数 $n$，将其定义为中心顺序统计量。\n- 计算样本中位数的自助标准误，即 $B$ 个自助中位数的无偏样本标准差，即：\n$$\n\\widehat{\\operatorname{se}}_{\\text{boot}}(T) \\;=\\; \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^B \\left(T^{\\ast (b)} - \\overline{T^\\ast}\\right)^2},\n$$\n其中 $\\overline{T^\\ast} = \\frac{1}{B}\\sum_{b=1}^B T^{\\ast (b)}$。\n\n实现要求：\n- 对每个测试用例使用 $B = 8000$ 次自助重抽样。\n- 对每个测试用例，使用 NumPy 的伪随机数生成器，配备 PCG64 位生成器和指定的种子，以确保可复现性。具体来说，使用以给定整数种子初始化的生成器 $\\texttt{numpy.random.Generator}(\\texttt{numpy.random.PCG64}(\\text{seed}))$。\n- 对每个测试用例，计算如上定义的样本中位数的自助标准误，并将结果四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n- 用例 1：数据 $\\{5.4,\\,5.1,\\,4.8,\\,5.9,\\,5.2,\\,6.0,\\,5.5,\\,5.7,\\,5.3,\\,4.9\\}$，种子 $314159$。\n- 用例 2：数据 $\\{2.0,\\,3.5,\\,3.5,\\,4.0,\\,5.0,\\,6.5\\}$，种子 $271828$。\n- 用例 3：数据 $\\{7.0,\\,7.0,\\,7.0\\}$，种子 $42$。\n- 用例 4：数据 $\\{0.1,\\,0.2,\\,0.15,\\,100.0,\\,0.18,\\,0.22,\\,0.12\\}$，种子 $202311$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含四个测试用例的自助标准误，以逗号分隔的列表形式包含在方括号中，按上述用例的顺序排列，每个值都四舍五入到 $6$ 位小数。例如，输出必须是 $[r_1,r_2,r_3,r_4]$ 的形式，其中每个 $r_i$ 是一个四舍五入到 $6$ 位的小数，并且不打印任何其他文本。",
            "solution": "该问题是有效的。它提出了一个清晰、明确的计算统计学任务，该任务在科学上是合理的，并且在计算上是可验证的。\n\n目标是为四个给定的数据集计算样本中位数的非参数自助标准误。非参数自助法是一种强大的重抽样技术，用于在不对潜在总体分布做出强假设的情况下，估计统计量的抽样分布。\n\n非参数自助法的基本原理是使用观测到的样本作为整个总体的近似。经验累积分布函数 (ECDF)，表示为 $\\hat{F}_n(x) = \\frac{1}{n} \\sum_{i=1}^n \\mathbf{1}\\{X_i \\le x\\}$，通过为每个观测数据点 $X_i$ 分配 $\\frac{1}{n}$ 的概率来将此形式化。从原始样本 $\\{X_1, \\ldots, X_n\\}$ 中进行有放回重抽样，等同于从由 $\\hat{F}_n$ 定义的分布中抽取独立同分布的样本。\n\n估计统计量 $T$（在本例中为样本中位数）的标准误的步骤如下：\n\n1.  **给定数据**：我们从一个大小为 $n$ 的原始样本开始，表示为 $\\{X_1, \\ldots, X_n\\}$。\n\n2.  **自助重抽样**：我们生成大量的自助样本，数量为 $B$。对于这个问题，$B = 8000$。每个自助样本，表示为 $\\{X_1^{*(b)}, \\ldots, X_n^{*(b)}\\}$ (其中 $b = 1, \\ldots, B$)，是通过从原始样本 $\\{X_1, \\ldots, X_n\\}$ 中*有放回地*抽取 $n$ 个数据点来创建的。\n\n3.  **计算自助重复值**：对于 $B$ 个自助样本中的每一个，我们计算感兴趣的统计量，即样本中位数。这将产生一组 $B$ 个自助重复值，$\\{ T^{*(1)}, T^{*(2)}, \\ldots, T^{*(B)} \\}$。样本中位数的定义如下：\n    - 如果样本量 $n$ 是奇数，中位数是排序后样本的中心值。\n    - 如果样本量 $n$ 是偶数，中位数是排序后样本的两个中心值的平均值。\n\n4.  **计算自助标准误**：自助标准误 $\\widehat{\\operatorname{se}}_{\\text{boot}}(T)$ 是 $T$ 的抽样分布标准差的估计值。它被计算为 $B$ 个自助重复值的样本标准差。问题指定使用无偏样本标准差公式：\n    $$ \\widehat{\\operatorname{se}}_{\\text{boot}}(T) = \\sqrt{\\frac{1}{B-1}\\sum_{b=1}^B \\left(T^{\\ast (b)} - \\overline{T^\\ast}\\right)^2} $$\n    其中 $\\overline{T^\\ast}$ 是自助重复值的均值：\n    $$ \\overline{T^\\ast} = \\frac{1}{B}\\sum_{b=1}^B T^{\\ast (b)} $$\n\n为确保可复现性，该过程必须使用指定的伪随机数生成器 `numpy.random.Generator(numpy.random.PCG64(seed))`，并为每个测试用例提供种子。\n\n对于每个测试用例，实现将按以下步骤进行：\n- 使用给定的 `seed` 初始化随机数生成器。\n- 使用生成器的 `choice` 方法（带 `replace=True` 参数）从原始数据中生成 $B = 8000$ 个大小为 $n$ 的自助样本。\n- 对每个自助样本，使用 `numpy.median` 计算其中位数，该函数能正确实现对偶数和奇数样本量的定义。\n- 收集这 $8000$ 个中位数。\n- 使用 `numpy.std` 及参数 `ddof=1` (Delta Degrees of Freedom) 计算这组中位数的标准差。设置 `ddof=1` 可确保平方差之和除以 $B-1$，与无偏样本标准差的所需公式相匹配。\n- 最后，将结果四舍五入到 $6$ 位小数。\n\n此过程将应用于问题陈述中指定的四个测试用例中的每一个。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bootstrap standard error of the sample median for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        ({'data': [5.4, 5.1, 4.8, 5.9, 5.2, 6.0, 5.5, 5.7, 5.3, 4.9], 'seed': 314159}),\n        ({'data': [2.0, 3.5, 3.5, 4.0, 5.0, 6.5], 'seed': 271828}),\n        ({'data': [7.0, 7.0, 7.0], 'seed': 42}),\n        ({'data': [0.1, 0.2, 0.15, 100.0, 0.18, 0.22, 0.12], 'seed': 202311})\n    ]\n\n    B = 8000\n    results = []\n\n    for case in test_cases:\n        data = np.array(case['data'])\n        seed = case['seed']\n        n = len(data)\n\n        # Initialize the random number generator with the specified seed and generator type.\n        rng = np.random.Generator(np.random.PCG64(seed))\n\n        # Store the medians of the bootstrap samples.\n        bootstrap_medians = np.empty(B)\n\n        # Generate B bootstrap samples and compute their medians.\n        for b in range(B):\n            # A bootstrap sample is drawn with replacement from the original data.\n            bootstrap_sample = rng.choice(data, size=n, replace=True)\n            \n            # Compute the median of the bootstrap sample.\n            # np.median correctly handles both even and odd sample sizes.\n            bootstrap_medians[b] = np.median(bootstrap_sample)\n\n        # Compute the bootstrap standard error, which is the sample standard deviation\n        # of the bootstrap medians. The ddof=1 argument specifies division by (B-1),\n        # yielding the unbiased sample standard deviation.\n        se_boot = np.std(bootstrap_medians, ddof=1)\n\n        # Round the result to 6 decimal places.\n        rounded_result = round(se_boot, 6)\n        results.append(rounded_result)\n\n    # Final print statement in the exact required format.\n    # The map to str is necessary to handle the case of 0.0 becoming '0.0'.\n    # A custom formatter could also ensure trailing zeros, but str() is sufficient here.\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}