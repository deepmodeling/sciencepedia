{
    "hands_on_practices": [
        {
            "introduction": "在任何生物统计研究开始之前，一个关键的步骤是确定需要多少数据才能得出有意义的结论。本练习将理论付诸实践，展示如何利用置信区间的公式来反向推算出研究所需的样本量，以确保估计达到预期的精度。通过这个在临床研究设计中至关重要的计算，您将掌握生物统计学家最常见的任务之一：为研究人员提供样本量建议。",
            "id": "4560495",
            "problem": "一种全身性炎症的临床生物标志物以毫克/升 (mg/L) 为单位进行量化。研究人员计划进行一项研究，使用置信水平为 $1 - \\alpha = 0.95$ 的双侧置信区间 (CI) 来估计该生物标志物的总体平均水平 $\\mu$。根据先前对独立队列的荟萃分析，该生物标志物的受试者内测量过程和生物学变异性可以通过均值为 $\\mu$、已知方差为 $\\sigma^{2}$ 的独立同分布 (i.i.d.) 高斯观测值 $X_{1}, X_{2}, \\dots, X_{n}$ 进行良好建模。该荟萃分析提供了一个经过外部验证的方差估计值 $\\sigma^{2} = 64$ (mg/L)$^{2}$，在研究规划阶段可将其视为已知。\n\n请从双侧置信区间的核心定义以及在已知方差的高斯模型下样本均值的抽样分布出发，推导出一个连接置信区间宽度 $W$、样本量 $n$、方差 $\\sigma^{2}$ 和标准正态分布的适当分位点的关系式。然后，利用该关系式，确定能够保证在置信水平 $0.95$ 下，为 $\\mu$ 设计的双侧置信区间总宽度为 $W = 3$ mg/L 的最小整数 $n$。\n\n将最终的样本量 $n$ 报告为单个整数。如果计算中出现非整数，请选择满足宽度约束 $W \\leq 3$ mg/L 的最小整数 $n$。最终数值答案中请勿包含任何单位。",
            "solution": "问题要求在已知总体方差 $\\sigma^2$ 的情况下，确定为使总体均值 $\\mu$ 的置信区间达到指定宽度所需的最小样本量 $n$。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件：**\n- 待估计的总体参数：总体平均生物标志物水平，$\\mu$。\n- 数据模型：独立同分布 (i.i.d.) 的高斯观测值 $X_{1}, X_{2}, \\dots, X_{n}$。\n- 观测值分布：$X_i \\sim N(\\mu, \\sigma^2)$。\n- 已知总体方差：$\\sigma^2 = 64$ (mg/L)$^2$。\n- 置信水平：$1 - \\alpha = 0.95$。\n- 期望的双侧置信区间总宽度：$W = 3$ mg/L。\n- 约束条件：最终样本量 $n$ 必须是满足宽度要求的最小整数。\n\n**1.2. 使用提取的已知条件进行验证：**\n- **科学依据：** 该问题牢固地植根于假设检验和估计的标准统计理论，特别是在已知方差的情况下为正态分布均值构建置信区间。这是生物统计学和临床试验设计中的一个典型问题。所提供的值对于生物学测量是合理的。\n- **适定性：** 该问题是适定的。它提供了所有必要的信息（$\\sigma^2$、置信水平、目标宽度），以确定样本量 $n$ 的唯一整数解。\n- **客观性：** 问题陈述是客观、精确的，没有歧义或主观语言。\n\n**1.3. 结论：**\n该问题是有效的。它在科学上是合理的、适定的和客观的。没有矛盾、信息缺失或违反基本原则的地方。我们可以继续进行求解。\n\n### 步骤 2：推导与求解\n\n总体均值 $\\mu$ 的估计量是样本均值 $\\bar{X}$，定义为：\n$$\n\\bar{X} = \\frac{1}{n} \\sum_{i=1}^{n} X_i\n$$\n鉴于 $X_i$ 是从正态分布 $N(\\mu, \\sigma^2)$ 中抽取的独立同分布随机变量，样本均值 $\\bar{X}$ 的抽样分布也是正态的。$\\bar{X}$ 的均值为 $E[\\bar{X}] = \\mu$，其方差为 $\\text{Var}(\\bar{X}) = \\frac{\\sigma^2}{n}$。因此，抽样分布为：\n$$\n\\bar{X} \\sim N\\left(\\mu, \\frac{\\sigma^2}{n}\\right)\n$$\n为了构建置信区间，我们使用一个其分布不依赖于未知参数 $\\mu$ 的枢轴量。我们将 $\\bar{X}$ 标准化以获得一个标准正态随机变量 $Z$：\n$$\nZ = \\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\sim N(0, 1)\n$$\n置信水平为 $1 - \\alpha$ 的双侧置信区间由以下概率陈述构建：\n$$\nP(-z_{\\alpha/2} \\le Z \\le z_{\\alpha/2}) = 1 - \\alpha\n$$\n其中 $z_{\\alpha/2}$ 是标准正态分布的上 $\\alpha/2$ 分位点，定义为 $P(Z > z_{\\alpha/2}) = \\alpha/2$。\n\n代入 $Z$ 的表达式得到：\n$$\nP\\left(-z_{\\alpha/2} \\le \\frac{\\bar{X} - \\mu}{\\sigma / \\sqrt{n}} \\le z_{\\alpha/2}\\right) = 1 - \\alpha\n$$\n我们重排不等式以分离出参数 $\\mu$：\n$$\n-z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le \\bar{X} - \\mu \\le z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\n$$\n$$\n-\\bar{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le -\\mu \\le -\\bar{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\n$$\n$$\n\\bar{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le \\mu \\le \\bar{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\n$$\n这就定义了 $\\mu$ 的 $100(1-\\alpha)\\%$ 置信区间：\n$$\n\\text{CI} = \\left[ \\bar{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}, \\bar{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\right]\n$$\n该置信区间的总宽度 $W$ 是上界与下界之差：\n$$\nW = \\left( \\bar{X} + z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\right) - \\left( \\bar{X} - z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\right) = 2 z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}}\n$$\n这个方程提供了连接宽度 $W$、样本量 $n$、标准差 $\\sigma$ 和标准正态分位点 $z_{\\alpha/2}$ 所需的关系。\n\n问题要求总宽度为 $W = 3$ mg/L。更准确地说，计划的宽度应最多为 $3$ mg/L。因此，我们得到不等式：\n$$\nW \\le 3 \\implies 2 z_{\\alpha/2} \\frac{\\sigma}{\\sqrt{n}} \\le 3\n$$\n现在我们可以求解 $n$：\n$$\n\\sqrt{n} \\ge \\frac{2 z_{\\alpha/2} \\sigma}{3}\n$$\n$$\nn \\ge \\left( \\frac{2 z_{\\alpha/2} \\sigma}{3} \\right)^2\n$$\n现在我们代入给定的值。\n置信水平为 $1 - \\alpha = 0.95$，所以 $\\alpha = 0.05$ 且 $\\alpha/2 = 0.025$。标准正态分布对应的分位点是 $z_{0.025}$。这个值使得累积概率为 $1 - 0.025 = 0.975$。$z_{0.025}$ 的标准值约为 $1.96$。\n已知方差为 $\\sigma^2 = 64$ (mg/L)$^2$，所以标准差为 $\\sigma = \\sqrt{64} = 8$ mg/L。\n期望的最大宽度为 $W = 3$ mg/L。\n\n将这些值代入关于 $n$ 的不等式中：\n$$\nn \\ge \\left( \\frac{2 \\times 1.96 \\times 8}{3} \\right)^2\n$$\n$$\nn \\ge \\left( \\frac{31.36}{3} \\right)^2\n$$\n$$\nn \\ge (10.4533...)^2\n$$\n$$\nn \\ge 109.2718...\n$$\n由于样本量 $n$ 必须是整数，我们必须取大于或等于 $109.2718...$ 的最小整数。这是确保满足宽度约束 $W \\le 3$ 所必需的。因此，所需的最小样本量为 $n=110$。",
            "answer": "$$\\boxed{110}$$"
        },
        {
            "introduction": "虽然基于大样本正态近似的置信区间非常有用，但它们在小样本情况下（如早期临床试验）可能会不准确。此练习深入探讨了置信区间的根本定义，即作为一系列假设检验的“反演”，并由此推导出用于二项分布比例的“精确”Clopper-Pearson区间。掌握这一推导过程有助于巩固区间估计的理论基础，并阐明由数据离散性引起的“保守性”覆盖这一重要概念。",
            "id": "4805618",
            "problem": "一项单臂早期临床研究旨在估计一种新疗法的真实不良事件概率 $p$。假设数据来自 $Y \\sim \\mathrm{Bin}(n,p)$，其中 $Y$ 是 $n$ 名独立患者中至少出现一次不良事件的患者数量。您需要使用二项检验的精确反演法（也称为 Clopper–Pearson (CP) 方法）为 $p$ 构建一个 $(1-\\alpha)$ 置信区间。\n\n任务：\n1. 仅从二项概率质量函数 $P(Y=y \\mid p)=\\binom{n}{y} p^{y} (1-p)^{n-y}$、水平为 $\\alpha/2$ 的精确单侧检验的定义以及检验族反演原理出发，通过求解关于 $p$ 的尾部概率方程的唯一解，推导出 CP 区间的下端点 $L$ 和上端点 $U$。用一个标准特殊函数的反函数来表示最终的端点，并清楚地说明这些端点是如何为 $y \\in \\{0,1,\\dots,n\\}$ 定义的。\n2. 提供一个简洁的论证，解释为什么 CP 区间是保守的，即对于所有 $p \\in (0,1)$，其覆盖概率至少为 $(1-\\alpha)$，并且由于离散性，对于许多 $p$ 值，其覆盖概率严格大于 $(1-\\alpha)$。\n3. 将您的通用结果应用于以下试点安全性设置：在 $n=2$ 名患者中，有 $y=1$ 名经历了不良事件，需要一个 $(1-\\alpha)=0.90$ 的置信区间。计算 CP 区间的长度（定义为 $U-L$），并报告四位有效数字的数值。以无单位的单个实数形式提供最终答案。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 数据模型：不良事件数 $Y$ 服从二项分布，$Y \\sim \\mathrm{Bin}(n,p)$。\n- 目标参数：$p$，即真实的不良事件概率。\n- 样本量：$n$ 名独立患者。\n- 观测数据：$y$，$Y$ 的实现值。\n- 二项概率质量函数：$P(Y=y \\mid p)=\\binom{n}{y} p^{y} (1-p)^{n-y}$。\n- 目标：为 $p$ 构建一个 $(1-\\alpha)$ 置信区间。\n- 方法：Clopper–Pearson (CP) 方法，涉及对一个二项检验族的精确反演。\n- 任务 1：从第一性原理出发推导下端点 $L$ 和上端点 $U$，并用一个标准特殊函数的反函数来表示它们。为所有可能的结果 $y \\in \\{0,1,\\dots,n\\}$ 定义端点。\n- 任务 2：解释为什么 CP 区间的覆盖概率对于所有 $p \\in (0,1)$ 至少为 $(1-\\alpha)$（即它是保守的）。\n- 任务 3：将推导出的公式应用于 $n=2$，$y=1$，置信水平为 $(1-\\alpha)=0.90$ 的情况。计算区间的长度 $U-L$，并提供四舍五入到四位有效数字的数值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，提法明确且客观。这是一个关于为二项比例构建置信区间的标准统计推断问题。Clopper-Pearson 方法是一种基础且成熟的技术。问题提供了所有必要信息，没有矛盾，并且以精确、正式的语言陈述。它不违反任何无效性标准。\n\n### 步骤 3：结论与行动\n问题有效。将提供完整解答。\n\n### 解答\n\n本解答根据问题陈述中指定的三个任务进行组织。\n\n#### 1. Clopper–Pearson (CP) 区间的推导\n\n通过反演一个假设检验族来构建 $(1-\\alpha)$ 置信区间的原理指出，参数 $p$ 的置信集由所有使得原假设 $H_0: p = p_0$ 在给定观测数据 $y$ 和显著性水平 $\\alpha$ 下*不被拒绝*的 $p_0$ 值组成。\n\nClopper-Pearson 方法是通过反演两个独立的单侧精确二项检验推导出来的，每个检验的显著性水平为 $\\alpha/2$。\n\n**下端点 $L$ 的推导**\n\n为了找到下端点 $L$，我们对每个可能的 $p_0 \\in (0,1)$ 值考虑单侧假设检验 $H_0: p = p_0$ 对 $H_1: p > p_0$。如果观测结果 $y$ 出乎意料地大，表明真实的 $p$ 可能大于 $p_0$，则拒绝此检验。此检验的 p 值为在原假设下，观测到与 $y$ 一样极端或更极端的结果的概率：\n$$ \\text{p-value}_U(y, p_0) = P(Y \\ge y \\mid p=p_0) = \\sum_{k=y}^{n} \\binom{n}{k} p_0^k (1-p_0)^{n-k} $$\n置信区间的下限 $L$ 是*不被*拒绝的最小 $p_0$ 值。这意味着我们在寻找值 $L$，使得如果 $p_0  L$，则假设 $H_0: p=p_0$ 被拒绝。当 p 值小于或等于 $\\alpha/2$ 时，发生拒绝。为了找到接受域的边界，我们将 p 值设为等于 $\\alpha/2$。\n下端点 $L$ 是以下方程的解：\n$$ P(Y \\ge y \\mid p=L) = \\sum_{k=y}^{n} \\binom{n}{k} L^k (1-L)^{n-k} = \\frac{\\alpha}{2} $$\n此方程对 $y \\in \\{1, \\dots, n\\}$ 成立。如果 $y=0$，则和为 $1$，因此方程 $1 = \\alpha/2$ 没有解。在这种情况下，基于观测值 $y=0$，对于任何 $p_0 \\ge 0$，检验 $H_0: p = p_0$ 都不会被拒绝。因此，根据惯例和检验逻辑，当 $y=0$ 时，下限为 $L=0$。\n\n**上端点 $U$ 的推导**\n\n为了找到上端点 $U$，我们对每个 $p_0 \\in (0,1)$ 考虑单侧假设检验 $H_0: p = p_0$ 对 $H_1: p  p_0$。如果观测结果 $y$ 出乎意料地小，则拒绝此检验。p 值为：\n$$ \\text{p-value}_L(y, p_0) = P(Y \\le y \\mid p=p_0) = \\sum_{k=0}^{y} \\binom{n}{k} p_0^k (1-p_0)^{n-k} $$\n上限 $U$ 是*不被*拒绝的最大 $p_0$ 值。我们通过将 p 值设为等于 $\\alpha/2$ 来找到这个边界。\n上端点 $U$ 是以下方程的解：\n$$ P(Y \\le y \\mid p=U) = \\sum_{k=0}^{y} \\binom{n}{k} U^k (1-U)^{n-k} = \\frac{\\alpha}{2} $$\n此方程对 $y \\in \\{0, \\dots, n-1\\}$ 成立。如果 $y=n$，则和为 $1$，因此方程 $1 = \\alpha/2$ 没有解。对于观测值 $y=n$，我们永远不会为了支持一个更小的 $p$ 而拒绝 $H_0: p=p_0$。因此，根据惯例，当 $y=n$ 时，上限为 $U=1$。\n\n**用特殊函数表示**\n\n二项和与正则化不完全贝塔函数 $I_x(a,b)$ 相关，后者是贝塔分布 $\\mathrm{Beta}(a,b)$ 的累积分布函数 (CDF)。相关恒等式为：\n$$ P(Y \\ge y \\mid p) = I_p(y, n-y+1) $$\n$$ P(Y \\le y \\mid p) = I_{1-p}(n-y, y+1) $$\n设 $F_{\\beta}^{-1}(q; a, b)$ 表示 $\\mathrm{Beta}(a,b)$ 分布的分位数函数（CDF的反函数），它返回一个值 $x$ 使得 $I_x(a,b)=q$。\n\n使用这些恒等式，我们可以表示 $L$ 和 $U$：\n- 对于 $L$，方程 $P(Y \\ge y \\mid p=L) = \\alpha/2$ 变为 $I_L(y, n-y+1) = \\alpha/2$。解出 $L$ 得到 $L = F_{\\beta}^{-1}(\\alpha/2; y, n-y+1)$。\n- 对于 $U$，方程 $P(Y \\le y \\mid p=U) = \\alpha/2$ 变为 $I_{1-U}(n-y, y+1) = \\alpha/2$。设 $q=1-U$。那么 $I_q(n-y, y+1) = \\alpha/2$。所以，$q = F_{\\beta}^{-1}(\\alpha/2; n-y, y+1)$。那么 $U = 1-q = 1 - F_{\\beta}^{-1}(\\alpha/2; n-y, y+1)$。使用恒等式 $1-F_{\\beta}^{-1}(q; a, b) = F_{\\beta}^{-1}(1-q; b, a)$，我们得到 $U = F_{\\beta}^{-1}(1-\\alpha/2; y+1, n-y)$。\n\n端点的完整定义是：\n- 对于 $y=0$：$L=0$ 且 $U = F_{\\beta}^{-1}(1-\\alpha/2; 1, n)$。\n- 对于 $y \\in \\{1, \\dots, n-1\\}$：$L = F_{\\beta}^{-1}(\\alpha/2; y, n-y+1)$ 且 $U = F_{\\beta}^{-1}(1-\\alpha/2; y+1, n-y)$。\n- 对于 $y=n$：$L=F_{\\beta}^{-1}(\\alpha/2; n, 1)$ 且 $U=1$。\n\n#### 2. CP 区间的保守性\n\n参数 $p$ 的置信区间的覆盖概率是在假设 $p$ 是真实值的情况下，该区间包含 $p$ 的概率。CP 区间 $[L(Y), U(Y)]$ 是保守的，意味着其覆盖概率 $C(p) = P(L(Y) \\le p \\le U(Y))$ 对于所有 $p \\in (0,1)$ 至少为 $(1-\\alpha)$。\n\n根据构造，区间 $[L(y), U(y)]$ 包含值 $p_0$ 当且仅当假设 $H_0: p=p_0$ 不被拒绝。这发生在两个单侧 p 值都大于或等于 $\\alpha/2$ 时：\n$$ L(y) \\le p \\iff P(Y \\ge y \\mid p) \\ge \\alpha/2 $$\n$$ p \\le U(y) \\iff P(Y \\le y \\mid p) \\ge \\alpha/2 $$\n如果 $p  L(Y)$ 或 $p > U(Y)$，则区间未能覆盖真实值 $p$。这对应于 $H_0: p$ 的拒绝。非覆盖概率是两个不相交事件（不相交性如下所示）的概率之和：上尾检验的第一类错误和下尾检验的第一类错误。\n$$ P(\\text{非覆盖}) = P_p(Y \\in \\{y \\mid p  L(y)\\}) + P_p(Y \\in \\{y \\mid p > U(y)\\}) $$\n条件 $p > U(y)$ 等价于 $P_p(Y \\le y)  \\alpha/2$。此事件的实际概率，我们称之为下尾拒绝概率 $\\alpha_L(p)$，是 $\\sum_{y \\text{ s.t. } P_p(Y \\le y)  \\alpha/2} P_p(Y=y)$。设 $y_{max}$ 是满足该条件的最大 $y$ 值。此和为 $P_p(Y \\le y_{max})$，根据定义小于 $\\alpha/2$。\n类似地，条件 $p  L(y)$ 等价于 $P_p(Y \\ge y)  \\alpha/2$。此事件的概率，即上尾拒绝概率 $\\alpha_U(p)$，是 $\\sum_{y \\text{ s.t. } P_p(Y \\ge y)  \\alpha/2} P_p(Y=y)$。设 $y_{min}$ 是满足此条件的最小 $y$ 值。此和为 $P_p(Y \\ge y_{min})$，也小于 $\\alpha/2$。\n\n基于离散分布的检验的确切检验水准必须小于或等于名义水平。这是因为 p 值分布是离散的，通常不可能定义一个概率恰好为 $\\alpha/2$ 的拒绝域。我们必须选择一个拒绝域，使其概率是在不超过 $\\alpha/2$ 的前提下的最大可能值。因此，我们有 $\\alpha_L(p) \\le \\alpha/2$ 和 $\\alpha_U(p) \\le \\alpha/2$。\n\n总的非覆盖概率是 $\\alpha_L(p) + \\alpha_U(p) \\le \\alpha/2 + \\alpha/2 = \\alpha$。\n因此，覆盖概率是 $C(p) = 1 - (\\alpha_L(p) + \\alpha_U(p)) \\ge 1-\\alpha$。\n\n对于许多 $p$ 值，覆盖率严格大于 $(1-\\alpha)$，这正是因为这种离散性。对于大多数 $(n, p)$ 的组合，不存在整数 $y$ 使得 $P_p(Y \\le y)$ 或 $P_p(Y \\ge y)$ 恰好等于 $\\alpha/2$。结果，实际的拒绝概率 $\\alpha_L(p)$ 和 $\\alpha_U(p)$ 通常严格小于 $\\alpha/2$，导致总的非覆盖概率严格小于 $\\alpha$，而覆盖概率严格大于 $(1-\\alpha)$。\n\n#### 3. 在试点安全性设置中的应用\n\n给定 $n=2$, $y=1$, 以及 $(1-\\alpha)=0.90$。这意味着 $\\alpha=0.10$ 且 $\\alpha/2=0.05$。\n\n对于下端点 $L$，我们在 $P(Y \\ge 1 \\mid p) = 0.05$ 中求解 $p=L$。\n$$ P(Y \\ge 1 \\mid p) = P(Y=1 \\mid p) + P(Y=2 \\mid p) = \\binom{2}{1} p^1 (1-p)^1 + \\binom{2}{2} p^2 (1-p)^0 $$\n$$ = 2p(1-p) + p^2 = 2p - 2p^2 + p^2 = 2p - p^2 $$\n我们设 $2L - L^2 = 0.05$，整理为二次方程 $L^2 - 2L + 0.05 = 0$。\n使用二次方程求根公式，$L = \\frac{2 \\pm \\sqrt{4 - 4(1)(0.05)}}{2} = 1 \\pm \\frac{\\sqrt{3.8}}{2}$。由于 $L$ 必须在 $[0,1]$ 内，我们取较小的根：\n$$ L = 1 - \\frac{\\sqrt{3.8}}{2} \\approx 1 - \\frac{1.94935886...}{2} = 1 - 0.97467943... \\approx 0.02532057... $$\n对于上端点 $U$，我们在 $P(Y \\le 1 \\mid p) = 0.05$ 中求解 $p=U$。\n$$ P(Y \\le 1 \\mid p) = P(Y=0 \\mid p) + P(Y=1 \\mid p) = \\binom{2}{0} p^0 (1-p)^2 + \\binom{2}{1} p^1 (1-p)^1 $$\n$$ = (1-p)^2 + 2p(1-p) = (1-2p+p^2) + (2p-2p^2) = 1 - p^2 $$\n我们设 $1 - U^2 = 0.05$，得到 $U^2 = 0.95$。由于 $U$ 必须在 $[0,1]$ 内，我们取正根：\n$$ U = \\sqrt{0.95} \\approx 0.97467943... $$\n置信区间的长度为 $U-L$：\n$$ U-L = \\sqrt{0.95} - \\left(1 - \\frac{\\sqrt{3.8}}{2}\\right) \\approx 0.97467943 - 0.02532057 = 0.94935886... $$\n四舍五入到四位有效数字，长度为 $0.9494$。",
            "answer": "$$\\boxed{0.9494}$$"
        },
        {
            "introduction": "教科书描述了不同置信区间的理论特性，但它们在实践中的表现究竟如何？本练习让您扮演计算统计学家的角色，通过设计一个模拟研究来凭经验验证理论。您将实现并比较三种广泛使用的二项比例置信区间（Wald、Wilson score 和 Clopper-Pearson），并凭经验衡量它们的“覆盖概率”。这项编码实践为了解不同方法在真实数据分析场景下的优劣提供了强有力的工具，并建立了对区间性能的直观理解。",
            "id": "4805580",
            "problem": "考虑一个二元结果模型，其中在 $n$ 次独立试验中观测到的事件数 $X$ 服从二项分布 $X \\sim \\mathrm{Binomial}(n,p)$，其中事件概率 $p \\in (0,1)$ 未知。在频率论框架中，$p$ 的置信区间的覆盖率定义为，在真实模型下重复抽样时，该区间包含真实参数值的概率。形式上，对于一个将数据 $X$ 映射到一个区间 $I(X)$ 的置信区间程序，其在特定 $p$ 值下的覆盖率为 $C(p) = \\mathbb{P}_p\\{p \\in I(X)\\}$。\n\n设计一个模拟研究，以经验性地评估三种不同的二项比例 $p$ 的双侧置信区间的覆盖率，每种区间的名义置信水平均为 $1-\\alpha$：\n\n- 从最大似然估计量 $\\hat{p}=X/n$ 的渐近正态性得到的 Wald 区间。\n- 通过对 $H_0: p=p_0$ 的分数检验进行反演得到的 Wilson 分数区间。\n- 通过对精确二项检验进行反演得到的精确 Clopper-Pearson 区间。\n\n使用以下基本原理来推导和实现每个区间：\n\n- 数据生成机制 $X \\sim \\mathrm{Binomial}(n,p)$ 和最大似然估计量 $\\hat{p}=X/n$。\n- $\\hat{p}$ 的渐近正态性：在正则性条件下，$\\sqrt{n}(\\hat{p}-p)$ 近似服从均值为 $0$、方差为 $p(1-p)$ 的正态分布，并且在方差项中可以使用 $p$ 的插件估计。\n- 二项模型中对 $H_0: p=p_0$ 的分数检验，以及通过反演此检验获得的置信区间。\n- 对二项模型进行精确检验反演，得到等尾置信区间，可通过 Beta 分布的分位数计算。\n\n您必须实现一个蒙特卡洛模拟，对于每个测试用例，该模拟从具有指定 $(n,p)$ 的二项模型中生成 $M$ 个独立的实现 $X_1,\\dots,X_M$，为每个实现构建三种置信区间，并将每个方法的覆盖率估计为区间包含真实 $p$ 值的实现所占的比例。为确保科学真实性，区间必须被裁剪到参数空间 $[0,1]$ 内。必须通过固定随机数生成器种子来使随机性可复现。\n\n模拟参数：\n\n- 名义置信水平：$1-\\alpha = 0.95$（即 $\\alpha = 0.05$）。\n- 每个测试用例的蒙特卡洛重复次数：$M = 10000$。\n- 随机种子：$12345$。\n\n测试套件（每个测试用例是一对 $(n,p)$）：\n\n- 用例 1：$(n,p) = (20,\\,0.01)$。\n- 用例 2：$(n,p) = (20,\\,0.10)$。\n- 用例 3：$(n,p) = (20,\\,0.50)$。\n- 用例 4：$(n,p) = (50,\\,0.01)$。\n- 用例 5：$(n,p) = (50,\\,0.10)$。\n- 用例 6：$(n,p) = (50,\\,0.50)$。\n- 用例 7：$(n,p) = (200,\\,0.01)$。\n- 用例 8：$(n,p) = (200,\\,0.10)$。\n- 用例 9：$(n,p) = (200,\\,0.50)$。\n\n对于每个测试用例，按 Wilson、Clopper-Pearson、Wald 的固定顺序报告三种方法的经验覆盖率。将每个覆盖率表示为四舍五入到4位小数的小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素是对应于一个测试用例的三元素列表，例如 $[\\,[c_{1,\\mathrm{Wilson}},c_{1,\\mathrm{CP}},c_{1,\\mathrm{Wald}}],\\,[c_{2,\\mathrm{Wilson}},c_{2,\\mathrm{CP}},c_{2,\\mathrm{Wald}}],\\,\\dots\\,]$。",
            "solution": "所提供的问题是有效的。这是一个在计算统计学中明确定义的任务，它基于成熟的统计理论，并且执行所需的所有参数都已提供。\n\n目标是进行一项蒙特卡洛模拟研究，以评估三种常见的二项比例 $p$ 置信区间的经验覆盖概率。对于参数 $p$ 的一个区间程序 $I(X)$，其覆盖概率定义为在重复抽样中，计算出的区间包含 $p$ 的真实值的概率。对于一个名义置信水平 $1-\\alpha$，一个好的区间程序应该使其真实覆盖率 $C(p) = \\mathbb{P}_p\\{p \\in I(X)\\}$ 对所有可能的 $p$ 值都接近 $1-\\alpha$。\n\n模拟将按以下步骤进行。对于每个由试验次数 $n$ 和真实概率 $p_{\\text{true}}$ 定义的测试用例，我们生成 $M=10000$ 个独立的观测结果 $X_i \\sim \\mathrm{Binomial}(n, p_{\\text{true}})$。对于每个观测结果 $X_i$，我们计算三种指定的置信区间。然后，每种方法的经验覆盖率被估计为这 $M$ 个区间中包含 $p_{\\text{true}}$ 的比例。名义置信水平为 $1-\\alpha = 0.95$，因此 $\\alpha = 0.05$。来自标准正态分布的临界值为 $z_{\\alpha/2} = z_{0.025}$，即 $\\mathcal{N}(0,1)$ 的第 $(1 - 0.025)$ 分位数。\n\n令 $X$ 为 $n$ 次试验中的成功次数。$p$ 的最大似然估计量（MLE）为 $\\hat{p} = X/n$。\n\n### 1. Wald 区间\n\nWald 区间源于 MLE 的渐近正态性。中心极限定理意味着对于大的 $n$，$\\hat{p}$ 的分布近似为正态分布：$\\hat{p} \\sim \\mathcal{N}(p, \\frac{p(1-p)}{n})$。根据 Slutsky 定理，我们可以在方差项中用 $p$ 的一致估计量 $\\hat{p}$ 来替代 $p$，从而得到标准化统计量：\n$$ Z = \\frac{\\hat{p} - p}{\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}} $$\n该统计量近似服从标准正态分布 $\\mathcal{N}(0,1)$。$p$ 的一个 $100(1-\\alpha)\\%$ 置信区间是通过找到所有满足 $|Z| \\le z_{\\alpha/2}$ 的 $p$ 值集合而构成的：\n$$ \\mathbb{P}\\left(-z_{\\alpha/2} \\le \\frac{\\hat{p} - p}{\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}} \\le z_{\\alpha/2}\\right) \\approx 1-\\alpha $$\n解出 $p$ 可得 Wald 区间：\n$$ \\left[ \\hat{p} - z_{\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}}, \\; \\hat{p} + z_{\\alpha/2} \\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n}} \\right] $$\n当 $X=0$ 或 $X=n$ 时，会出现一个实际问题，此时 $\\hat{p}=0$ 或 $\\hat{p}=1$。在这些情况下，标准误项 $\\sqrt{\\hat{p}(1-\\hat{p})/n}$ 变为 $0$，区间收缩为一个点 $[0,0]$ 或 $[1,1]$，这不切实际地暗示了完美的确定性。计算出的区间将被裁剪到 $[0,1]$。\n\n### 2. Wilson 分数区间\n\nWilson 分数区间是通过反演分数检验得到的。与 Wald 区间不同，分数检验使用原假设下的方差 $p_0(1-p_0)/n$，从而避免了在标准误中使用 $\\hat{p}$ 的问题。该区间是所有使得原假设 $H_0: p=p_0$ 在 $\\alpha$ 水平下不被拒绝的可能值 $p_0$ 的集合。这对应于满足以下条件的 $p$ 的集合：\n$$ \\left| \\frac{\\hat{p} - p}{\\sqrt{\\frac{p(1-p)}{n}}} \\right| \\le z_{\\alpha/2} $$\n两边平方并整理项，得到一个关于 $p$ 的二次不等式：\n$$ (\\hat{p} - p)^2 \\le z_{\\alpha/2}^2 \\frac{p(1-p)}{n} $$\n$$ n(\\hat{p}^2 - 2\\hat{p}p + p^2) \\le z_{\\alpha/2}^2 (p - p^2) $$\n$$ (n + z_{\\alpha/2}^2)p^2 - (2n\\hat{p} + z_{\\alpha/2}^2)p + n\\hat{p}^2 \\le 0 $$\n相应二次方程 $Ap^2+Bp+C=0$ 的根定义了区间的端点。使用二次公式 $\\frac{-B \\pm \\sqrt{B^2-4AC}}{2A}$，其中 $A = n+z_{\\alpha/2}^2$，$B = -(2n\\hat{p} + z_{\\alpha/2}^2)$，$C = n\\hat{p}^2$，区间由以下公式给出：\n$$ \\frac{2n\\hat{p} + z_{\\alpha/2}^2 \\pm z_{\\alpha/2}\\sqrt{4n\\hat{p}(1-\\hat{p}) + z_{\\alpha/2}^2}}{2(n+z_{\\alpha/2}^2)} $$\n这可以表示为：\n$$ \\frac{1}{1 + z_{\\alpha/2}^2/n} \\left( \\hat{p} + \\frac{z_{\\alpha/2}^2}{2n} \\pm z_{\\alpha/2}\\sqrt{\\frac{\\hat{p}(1-\\hat{p})}{n} + \\frac{z_{\\alpha/2}^2}{4n^2}} \\right) $$\n该区间的性能优于 Wald 区间，尤其是在样本量小或 $p$ 接近 0 或 1 时。\n\n### 3. Clopper-Pearson 区间\n\nClopper-Pearson 区间是一种通过反演两个单侧二项检验得到的“精确”方法。它的构建保证了对于所有 $p$ 值，覆盖概率至少为 $1-\\alpha$。\n下端点 $p_L$ 是以下方程的解：\n$$ \\mathbb{P}(X \\ge x | p=p_L) = \\sum_{k=x}^{n} \\binom{n}{k} p_L^k (1-p_L)^{n-k} = \\frac{\\alpha}{2} $$\n上端点 $p_U$ 是以下方程的解：\n$$ \\mathbb{P}(X \\le x | p=p_U) = \\sum_{k=0}^{x} \\binom{n}{k} p_U^k (1-p_U)^{n-k} = \\frac{\\alpha}{2} $$\n这些方程可以使用二项累积分布函数和正则化不完全 beta 函数之间的关系来求解。区间的端点由 Beta 分布的分位数给出：\n- 下界 $p_L$ 是参数为 $(x, n-x+1)$ 的 Beta 分布的 $\\alpha/2$ 分位数：$p_L = \\mathrm{Beta}^{-1}(\\alpha/2; x, n-x+1)$。对于 $x=0$ 的特殊情况，$p_L=0$。\n- 上界 $p_U$ 是参数为 $(x+1, n-x)$ 的 Beta 分布的 $1-\\alpha/2$ 分位数：$p_U = \\mathrm{Beta}^{-1}(1-\\alpha/2; x+1, n-x)$。对于 $x=n$ 的特殊情况，$p_U=1$。\n\n众所周知，这种方法是保守的，意味着其实际覆盖率通常超过名义的 $1-\\alpha$ 水平。\n\n该模拟将使用 Python 实现，利用 `numpy` 库进行向量化计算和随机数生成，并使用 `scipy.stats` 库获取统计函数（正态分布和 beta 分布的分位数）。为保证可复现性，随机数生成器将使用种子 $12345$ 进行初始化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, beta\n\ndef solve():\n    \"\"\"\n    Performs a Monte Carlo simulation to estimate the coverage of Wald, Wilson,\n    and Clopper-Pearson confidence intervals for a binomial proportion.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (20, 0.01),\n        (20, 0.10),\n        (20, 0.50),\n        (50, 0.01),\n        (50, 0.10),\n        (50, 0.50),\n        (200, 0.01),\n        (200, 0.10),\n        (200, 0.50),\n    ]\n\n    # Simulation parameters\n    M = 10000\n    alpha = 0.05\n    seed = 12345\n    rng = np.random.default_rng(seed)\n    \n    # Pre-calculate the standard normal critical value\n    z_crit = norm.ppf(1 - alpha / 2)\n    \n    all_results = []\n    \n    for n, p_true in test_cases:\n        # Generate M binomial random variates\n        # Shape: (M,)\n        X = rng.binomial(n, p_true, size=M)\n        \n        # Estimate of p\n        # Shape: (M,)\n        p_hat = X / n\n        \n        # --- 1. Wald Interval ---\n        # Standard error for the Wald interval\n        wald_se = np.sqrt(p_hat * (1 - p_hat) / n)\n        wald_lower = p_hat - z_crit * wald_se\n        wald_upper = p_hat + z_crit * wald_se\n        \n        # Clip interval to [0, 1]\n        wald_lower = np.maximum(0, wald_lower)\n        wald_upper = np.minimum(1, wald_upper)\n        \n        # Calculate coverage\n        wald_covered = (wald_lower = p_true)  (p_true = wald_upper)\n        wald_coverage = np.mean(wald_covered)\n        \n        # --- 2. Wilson Score Interval ---\n        z2 = z_crit**2\n        denom = 1 + z2 / n\n        center_adj = (p_hat + z2 / (2 * n))\n        \n        term = z_crit * np.sqrt( (p_hat * (1 - p_hat) / n) + (z2 / (4 * n**2)) )\n        \n        wilson_lower = (center_adj - term) / denom\n        wilson_upper = (center_adj + term) / denom\n\n        # Clip interval to [0, 1]\n        wilson_lower = np.maximum(0, wilson_lower)\n        wilson_upper = np.minimum(1, wilson_upper)\n        \n        # Calculate coverage\n        wilson_covered = (wilson_lower = p_true)  (p_true = wilson_upper)\n        wilson_coverage = np.mean(wilson_covered)\n\n        # --- 3. Clopper-Pearson Interval ---\n        alpha_half = alpha / 2\n        \n        # Lower bound\n        cp_lower = np.zeros_like(p_hat)\n        # Handle cases where X > 0, otherwise beta.ppf fails for a=0\n        mask_pos_x = X > 0\n        cp_lower[mask_pos_x] = beta.ppf(alpha_half, X[mask_pos_x], n - X[mask_pos_x] + 1)\n        \n        # Upper bound\n        cp_upper = np.ones_like(p_hat)\n        # Handle cases where X  n, otherwise beta.ppf fails for b=0\n        mask_lt_n = X  n\n        cp_upper[mask_lt_n] = beta.ppf(1 - alpha_half, X[mask_lt_n] + 1, n - X[mask_lt_n])\n        \n        # Calculate coverage\n        cp_covered = (cp_lower = p_true)  (p_true = cp_upper)\n        cp_coverage = np.mean(cp_covered)\n        \n        # Store results rounded to 4 decimal places in the specified order\n        # (Wilson, Clopper-Pearson, Wald)\n        case_results = [\n            round(wilson_coverage, 4),\n            round(cp_coverage, 4),\n            round(wald_coverage, 4)\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string as specified\n    sub_results_str = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_str = f\"[{','.join(sub_results_str)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}