{
    "hands_on_practices": [
        {
            "introduction": "掌握错误发现率（False Discovery Rate, FDR）控制的第一步是理解Benjamini-Hochberg（BH）程序的运作机制及其与$q$值的关系。这个练习将引导你从一组给定的$p$值出发，一步步计算出相应的$q$值。通过这个实践，你不仅能巩固对BH程序如何识别显著结果的理解，还能从根本上明白为何使用$q$值阈值与直接应用BH程序是等价的。",
            "id": "4930965",
            "problem": "一位生物统计学家在某项队列研究中分析基因层面的关联，得到一个包含 $m=15$ 个独立假设检验的族，其排序后的 $p$ 值 $p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(15)}$ 如下所示：\n$$\np_{(1)}=0.0008,\\quad p_{(2)}=0.003,\\quad p_{(3)}=0.0065,\\quad p_{(4)}=0.012,\\quad p_{(5)}=0.018,\n$$\n$$\np_{(6)}=0.021,\\quad p_{(7)}=0.044,\\quad p_{(8)}=0.051,\\quad p_{(9)}=0.062,\\quad p_{(10)}=0.078,\n$$\n$$\np_{(11)}=0.13,\\quad p_{(12)}=0.21,\\quad p_{(13)}=0.27,\\quad p_{(14)}=0.38,\\quad p_{(15)}=0.49.\n$$\n从一个检验的 $q$ 值是在 Benjamini–Hochberg (BH) 程序下，该检验将被纳入拒绝集的最低错误发现率（false discovery rate, FDR）水平这一核心定义出发，计算与这些排序后的 $p$ 值相关联的 $q$ 值向量。然后，使用计算出的 $q$ 值，在目标 $q$ 值水平 $q^{\\star}=0.09$ 下选择有所发现的检验，并从第一性原理出发解释为什么这种选择等同于在水平 $q^{\\star}$ 下应用一次 BH 程序。\n\n将在水平 $q^{\\star}=0.09$ 下的发现总数作为你的最终答案报告。无需四舍五入，最终答案必须是单个整数值。",
            "solution": "该问题已经过验证，并被认为是有效的，因为它的科学依据是既定的生物统计学多重比较校正理论，问题提法明确且提供了所有必要数据，并以客观、正式的语言陈述。\n\n该问题要求为一组给定的 $p$ 值计算 $q$ 值，并在指定的错误发现率（FDR）水平下确定显著发现的数量。它还要求解释使用预先计算的 $q$ 值与直接应用 Benjamini-Hochberg (BH) 程序之间的等价性。\n\n设 $m$ 为独立假设检验的总数。给定 $m=15$。\n设这些检验的排序 $p$ 值为 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。给定的值为：\n$p_{(1)}=0.0008$, $p_{(2)}=0.003$, $p_{(3)}=0.0065$, $p_{(4)}=0.012$, $p_{(5)}=0.018$, $p_{(6)}=0.021$, $p_{(7)}=0.044$, $p_{(8)}=0.051$, $p_{(9)}=0.062$, $p_{(10)}=0.078$, $p_{(11)}=0.13$, $p_{(12)}=0.21$, $p_{(13)}=0.27$, $p_{(14)}=0.38$, $p_{(15)}=0.49$.\n\n在水平 $\\alpha$ 下控制 FDR 的 BH 程序如下：找到满足 $p_{(k)} \\le \\frac{k}{m}\\alpha$ 的最大整数 $k \\in \\{1, \\dots, m\\}$。如果存在这样的 $k$，则拒绝对应于 $p_{(1)}, p_{(2)}, \\dots, p_{(k)}$ 的原假设。\n\n问题将检验的 $q$ 值定义为该检验将被宣布为显著的最小 FDR 水平。对于第 $i$ 个排序的检验，其 $q$ 值，记为 $q_{(i)}$，是该检验被拒绝的最小 $\\alpha$。遵循 BH 程序，如果存在某个索引 $j \\ge i$ 使得 $p_{(j)} \\le \\frac{j}{m}\\alpha$，则对应于 $p_{(i)}$ 的检验被拒绝。这等价于 $\\alpha \\ge \\frac{m \\cdot p_{(j)}}{j}$。为了找到允许拒绝第 $i$ 个检验的最小 $\\alpha$，我们必须为所有包含第 $i$ 个检验的可能拒绝集找到这些阈值的最小值。这导出了 BH 调整后 $p$ 值的定义，在本情景下即为 $q$ 值：\n$$q_{(i)} = \\min_{j=i, \\dots, m} \\left( \\frac{m \\cdot p_{(j)}}{j} \\right)$$\n这个定义确保了得到的 $q$ 值是单调不减的，即 $q_{(1)} \\le q_{(2)} \\le \\dots \\le q_{(m)}$。\n\n首先，我们计算中间值 $v_i = \\frac{m \\cdot p_{(i)}}{i}$，其中 $i=1, \\dots, 15$。\n$v_1 = \\frac{15}{1}(0.0008) = 0.012$\n$v_2 = \\frac{15}{2}(0.003) = 0.0225$\n$v_3 = \\frac{15}{3}(0.0065) = 0.0325$\n$v_4 = \\frac{15}{4}(0.012) = 0.045$\n$v_5 = \\frac{15}{5}(0.018) = 0.054$\n$v_6 = \\frac{15}{6}(0.021) = 0.0525$\n$v_7 = \\frac{15}{7}(0.044) = \\frac{0.66}{7} \\approx 0.094286$\n$v_8 = \\frac{15}{8}(0.051) = 0.095625$\n$v_9 = \\frac{15}{9}(0.062) = \\frac{0.93}{9} \\approx 0.103333$\n$v_{10} = \\frac{15}{10}(0.078) = 0.117$\n$v_{11} = \\frac{15}{11}(0.13) = \\frac{1.95}{11} \\approx 0.177273$\n$v_{12} = \\frac{15}{12}(0.21) = 0.2625$\n$v_{13} = \\frac{15}{13}(0.27) = \\frac{4.05}{13} \\approx 0.311538$\n$v_{14} = \\frac{15}{14}(0.38) = \\frac{5.7}{14} \\approx 0.407143$\n$v_{15} = \\frac{15}{15}(0.49) = 0.49$\n\n接下来，我们通过从右到左（从 $i=m$ 到 $1$）取累积最小值来计算 $q$ 值：$q_{(i)} = \\min(v_i, q_{(i+1)})$，其中 $q_{(m)} = v_m$。\n$q_{(15)} = v_{15} = 0.49$\n$q_{(14)} = \\min(v_{14}, q_{(15)}) = \\min(0.4071..., 0.49) = 0.4071... = \\frac{57}{140}$\n$q_{(13)} = \\min(v_{13}, q_{(14)}) = \\min(0.3115..., 0.4071...) = 0.3115... = \\frac{81}{260}$\n$q_{(12)} = \\min(v_{12}, q_{(13)}) = \\min(0.2625, 0.3115...) = 0.2625$\n$q_{(11)} = \\min(v_{11}, q_{(12)}) = \\min(0.1772..., 0.2625) = 0.1772... = \\frac{39}{220}$\n$q_{(10)} = \\min(v_{10}, q_{(11)}) = \\min(0.117, 0.1772...) = 0.117$\n$q_{(9)} = \\min(v_9, q_{(10)}) = \\min(0.1033..., 0.117) = 0.1033... = \\frac{31}{300}$\n$q_{(8)} = \\min(v_8, q_{(9)}) = \\min(0.095625, 0.1033...) = 0.095625$\n$q_{(7)} = \\min(v_7, q_{(8)}) = \\min(0.0942..., 0.095625) = 0.0942... = \\frac{33}{350}$\n$q_{(6)} = \\min(v_6, q_{(7)}) = \\min(0.0525, 0.0942...) = 0.0525$\n$q_{(5)} = \\min(v_5, q_{(6)}) = \\min(0.054, 0.0525) = 0.0525$\n$q_{(4)} = \\min(v_4, q_{(5)}) = \\min(0.045, 0.0525) = 0.045$\n$q_{(3)} = \\min(v_3, q_{(4)}) = \\min(0.0325, 0.045) = 0.0325$\n$q_{(2)} = \\min(v_2, q_{(3)}) = \\min(0.0225, 0.0325) = 0.0225$\n$q_{(1)} = \\min(v_1, q_{(2)}) = \\min(0.012, 0.0225) = 0.012$\n\n得到的 $q$ 值向量是：\n$q_{(1)}=0.012$, $q_{(2)}=0.0225$, $q_{(3)}=0.0325$, $q_{(4)}=0.045$, $q_{(5)}=0.0525$, $q_{(6)}=0.0525$, $q_{(7)} \\approx 0.0943$, $q_{(8)}=0.095625$, $q_{(9)} \\approx 0.1033$, $q_{(10)}=0.117$, $q_{(11)} \\approx 0.1773$, $q_{(12)}=0.2625$, $q_{(13)} \\approx 0.3115$, $q_{(14)} \\approx 0.4071$, $q_{(15)}=0.49$.\n\n为了在目标水平 $q^{\\star}=0.09$ 下选择发现，我们拒绝所有满足 $q_{(i)} \\le q^{\\star}$ 的假设。\n$q_{(1)} = 0.012 \\le 0.09$ (拒绝)\n$q_{(2)} = 0.0225 \\le 0.09$ (拒绝)\n$q_{(3)} = 0.0325 \\le 0.09$ (拒绝)\n$q_{(4)} = 0.045 \\le 0.09$ (拒绝)\n$q_{(5)} = 0.0525 \\le 0.09$ (拒绝)\n$q_{(6)} = 0.0525 \\le 0.09$ (拒绝)\n$q_{(7)} = \\frac{33}{350} \\approx 0.0943 > 0.09$ (不拒绝)\n由于 $q$ 值是单调不减的，所有从 $i=7$ 到 $i=15$ 的后续检验也不会被拒绝。发现的总数为 $6$。\n\n接下来，我们解释为什么这等同于在水平 $\\alpha = q^{\\star}=0.09$ 下应用 BH 程序。\n直接应用 BH 程序，我们寻找最大的 $k$ 使得 $p_{(k)} \\le \\frac{k}{m}q^{\\star} = \\frac{k}{15}(0.09) = 0.006k$。\n对于 $k=1: p_{(1)}=0.0008 \\le 0.006(1)=0.006$ (成立)\n对于 $k=2: p_{(2)}=0.003 \\le 0.006(2)=0.012$ (成立)\n对于 $k=3: p_{(3)}=0.0065 \\le 0.006(3)=0.018$ (成立)\n对于 $k=4: p_{(4)}=0.012 \\le 0.006(4)=0.024$ (成立)\n对于 $k=5: p_{(5)}=0.018 \\le 0.006(5)=0.030$ (成立)\n对于 $k=6: p_{(6)}=0.021 \\le 0.006(6)=0.036$ (成立)\n对于 $k=7: p_{(7)}=0.044 > 0.006(7)=0.042$ (不成立)\n满足条件的最大 $k$ 是 $k=6$。BH 程序拒绝前 $6$ 个假设，这与使用 $q$ 值方法得到的结果一致。\n\n这种等价性的正式解释如下。\n设 $q^{\\star}$ 为期望的 FDR 水平。\n方法1（q 值规则）：拒绝所有满足 $q_{(i)} \\le q^{\\star}$ 的假设 $H_{(i)}$。设 $k_q = \\max\\{i: q_{(i)} \\le q^{\\star}\\}$。由于 $q_{(i)}$ 是单调不减的，被拒绝的集合是 $\\{H_{(1)}, \\dots, H_{(k_q)}\\}$。\n方法2（BH 程序）：找到 $k_{BH} = \\max\\{i: p_{(i)} \\le \\frac{i}{m}q^{\\star}\\}$。被拒绝的集合是 $\\{H_{(1)}, \\dots, H_{(k_{BH})}\\}$。\n我们必须证明 $k_q = k_{BH}$。\n\n首先，我们来证明 $q_{(k_{BH})} \\le q^{\\star}$。根据 $k_{BH}$ 的定义，我们有 $p_{(k_{BH})} \\le \\frac{k_{BH}}{m}q^{\\star}$，这意味着 $\\frac{m \\cdot p_{(k_{BH})}}{k_{BH}} \\le q^{\\star}$。\n$q$ 值为 $q_{(k_{BH})} = \\min_{j=k_{BH}, \\dots, m} \\left(\\frac{m \\cdot p_{(j)}}{j}\\right)$。\n因为最小值计算中的一项（即 $j=k_{BH}$ 的那一项）小于或等于 $q^{\\star}$，所以最小值本身必须小于或等于 $q^{\\star}$。因此，$q_{(k_{BH})} \\le q^{\\star}$。\n根据 $q$ 值规则，假设 $H_{(k_{BH})}$ 被拒绝。由于 $q$ 值是单调不减的，所有 $i \\le k_{BH}$ 的 $H_{(i)}$ 也被拒绝。这意味着 $k_q \\ge k_{BH}$。\n\n接下来，我们考察 $q_{(k_{BH}+1)}$。根据 $k_{BH}$ 作为最大索引的定义，对于任何 $j > k_{BH}$，我们必然有 $p_{(j)} > \\frac{j}{m}q^{\\star}$，这等价于 $\\frac{m \\cdot p_{(j)}}{j} > q^{\\star}$。\n$q$ 值为 $q_{(k_{BH}+1)} = \\min_{j=k_{BH}+1, \\dots, m} \\left(\\frac{m \\cdot p_{(j)}}{j}\\right)$。\n由于这个最小值计算中的每一项都严格大于 $q^{\\star}$，所以最小值本身也必须严格大于 $q^{\\star}$。所以，$q_{(k_{BH}+1)} > q^{\\star}$。\n根据 $q$ 值规则，假设 $H_{(k_{BH}+1)}$ 不被拒绝。这意味着被拒绝假设的最大索引是 $k_{BH}$，因此 $k_q \\le k_{BH}$。\n\n结合 $k_q \\ge k_{BH}$ 和 $k_q \\le k_{BH}$，我们得出结论 $k_q = k_{BH}$。因此，这两个程序是等价的。发现的数量是 $6$。",
            "answer": "$$\\boxed{6}$$"
        },
        {
            "introduction": "在掌握了基本的BH程序后，认识其局限性至关重要，特别是在处理具有潜在依赖性的多重检验时。本练习将引入Benjamini-Yekutieli（BY）程序，这是一种在任意依赖性假设下都能控制FDR的更保守的方法。你将对同一数据集同时应用BH和BY程序，通过比较两种方法发现的结果数量，你将对统计功效和FDR控制稳健性之间的权衡有更实际的体会。",
            "id": "4930944",
            "problem": "一位生物统计学家正在分析一项RNA测序实验中 $m = 12$ 个基因的差异表达。对每个基因都进行了无差异表达的假设检验，得到以下未排序的 $p$ 值：\n$$\n0.02,\\ 0.12,\\ 0.006,\\ 0.0008,\\ 0.08,\\ 0.2,\\ 0.04,\\ 0.025,\\ 0.012,\\ 0.002,\\ 0.06,\\ 0.0045.\n$$\n假设这些检验可能存在任意依赖关系。该生物统计学家希望将错误发现率 (FDR) 控制在 $q = 0.05$ 的水平，并考虑了两种标准的步升程序：Benjamini–Hochberg (BH) 程序和 Benjamini–Yekutieli (BY) 程序。从FDR是所有发现中错误发现的期望比例这一核心定义出发，并使用标准的步升框架（即对 $p$ 值进行排序，并将它们与递增的临界值进行比较），确定以下内容：\n\n1. 对于 Benjamini–Yekutieli 程序，计算拒绝阈值（即，找出使得相应排序后的 $p$ 值被宣布为显著的那个最大秩 $k$，并报告该秩下的相关BY临界值）。\n\n2. 对于 Benjamini–Hochberg 程序，计算拒绝的数量。\n\n3. 将BY相对于BH的相对保守性量化为BY程序下的拒绝数量与BH程序下的拒绝数量之比。\n\n将最终的相对保守性度量表示为小数，并四舍五入到四位有效数字。不允许使用百分号。",
            "solution": "在尝试任何解决方案之前，所提出的问题都经过了严格的验证过程。\n\n### 步骤1：提取已知条件\n问题陈述中提供的明确数据和条件如下：\n- 假设检验的总数（基因数）：$m = 12$。\n- 未排序的 $p$ 值：$\\{0.02, 0.12, 0.006, 0.0008, 0.08, 0.2, 0.04, 0.025, 0.012, 0.002, 0.06, 0.0045\\}$。\n- 期望的错误发现率 (FDR) 控制水平：$q = 0.05$。\n- 检验的假定依赖结构：任意依赖。\n- 使用的程序：Benjamini-Hochberg (BH) 和 Benjamini-Yekutieli (BY)。\n- 任务1：对于BY程序，找到拒绝阈值，具体为显著检验的最大秩 $k$ 及其对应的临界值。\n- 任务2：对于BH程序，找到拒绝的数量。\n- 任务3：计算BY程序下的拒绝数量与BH程序下的拒绝数量之比，结果四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在已建立的多重假设检验统计理论中有坚实的基础。错误发现率、Benjamini-Hochberg程序和Benjamini-Yekutieli程序是现代生物统计学中的基石概念，特别是在如RNA测序等高通量数据的分析中。BH（用于独立性/正相关依赖性）和BY（用于任意依赖性）之间的区别是一个关键且标准的主题。该问题是这些原则的直接应用。\n- **适定性**：问题陈述清晰，为得出唯一解提供了所有必要信息。$p$ 值集合、检验总数 $m$ 和期望的FDR水平 $q$ 都已明确指定。这三个任务是基于所提供数据和标准算法的、含义明确的计算练习。\n- **客观性**：问题以客观、定量的语言进行阐述。它引用了标准的统计程序，不涉及主观解释。\n\n### 步骤3：结论与行动\n该问题在科学上是合理的、自洽的且适定的。不存在矛盾、歧义或事实错误。因此，该问题是**有效的**，并将提供解决方案。\n\n解决方案需要应用两种标准的步升程序来控制错误发现率。两种程序都首先将 $m$ 个p值从小到大排序，记为 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。\n\n首先，我们对给定的 $p$ 值进行排序：\n$p_{(1)} = 0.0008$\n$p_{(2)} = 0.002$\n$p_{(3)} = 0.0045$\n$p_{(4)} = 0.006$\n$p_{(5)} = 0.012$\n$p_{(6)} = 0.02$\n$p_{(7)} = 0.025$\n$p_{(8)} = 0.04$\n$p_{(9)} = 0.06$\n$p_{(10)} = 0.08$\n$p_{(11)} = 0.12$\n$p_{(12)} = 0.2$\n\n检验总数为 $m=12$，期望的FDR水平为 $q=0.05$。\n\n**任务1：Benjamini–Yekutieli (BY) 程序**\n\nBY程序旨在控制检验统计量之间存在任何形式依赖关系时的FDR。它通过引入一个校正因子 $c(m)$ 来修正BH程序，该因子是第 $m$ 个调和数。该程序是找到从1到 $m$ 的最大整数 $k$，使得：\n$$\np_{(k)} \\le \\frac{k}{m \\cdot c(m)}q\n$$\n对于 $m=12$，校正因子 $c(12)$ 是第12个调和数，$H_{12}$：\n$$\nc(12) = \\sum_{i=1}^{12} \\frac{1}{i} = 1 + \\frac{1}{2} + \\frac{1}{3} + \\dots + \\frac{1}{12} = \\frac{86021}{27720} \\approx 3.10321\n$$\n第 $i$ 个有序 $p$ 值的临界值是 $\\alpha_{BY,(i)} = \\frac{i}{12 \\cdot c(12)} (0.05)$。我们寻找满足 $p_{(k)} \\le \\alpha_{BY,(k)}$ 的最大 $k$。\n\n让我们将每个 $p_{(i)}$ 与其对应的临界值 $\\alpha_{BY,(i)}$ 进行比较：\n- 对于 $i=1$：$p_{(1)} = 0.0008$。临界值为 $\\alpha_{BY,(1)} = \\frac{1}{12 \\cdot c(12)}(0.05) \\approx \\frac{0.05}{37.2385} \\approx 0.00134$。由于 $0.0008 \\le 0.00134$，条件成立。\n- 对于 $i=2$：$p_{(2)} = 0.002$。临界值为 $\\alpha_{BY,(2)} = \\frac{2}{12 \\cdot c(12)}(0.05) \\approx 2 \\cdot 0.00134 = 0.00268$。由于 $0.002 \\le 0.00268$，条件成立。\n- 对于 $i=3$：$p_{(3)} = 0.0045$。临界值为 $\\alpha_{BY,(3)} = \\frac{3}{12 \\cdot c(12)}(0.05) \\approx 3 \\cdot 0.00134 = 0.00402$。由于 $0.0045 > 0.00402$，条件不成立。\n\n满足条件 $p_{(k)} \\le \\alpha_{BY,(k)}$ 的最大秩为 $k_{BY} = 2$。根据步升程序，秩为 $i=1, \\dots, k_{BY}$ 的假设被拒绝。因此，有2个假设被拒绝。按要求，拒绝阈值即为这个最大秩 $k_{BY}=2$ 处的临界值：\n$$\n\\alpha_{BY,(2)} = \\frac{2 \\cdot q}{m \\cdot c(m)} = \\frac{2 \\cdot (0.05)}{12 \\cdot \\frac{86021}{27720}} = \\frac{0.1 \\cdot 27720}{12 \\cdot 86021} = \\frac{2772}{1032252} \\approx 0.0026854\n$$\nBY程序下的拒绝数量为 $N_{BY} = 2$。\n\n**任务2：Benjamini–Hochberg (BH) 程序**\n\nBH程序在独立性或正回归依赖性下控制FDR，它不使用 $c(m)$ 校正因子。该程序是找到从1到 $m$ 的最大整数 $k$，使得：\n$$\np_{(k)} \\le \\frac{k}{m}q\n$$\n第 $i$ 个有序 $p$ 值的临界值是 $\\alpha_{BH,(i)} = \\frac{i}{12}(0.05)$。我们寻找满足 $p_{(k)} \\le \\alpha_{BH,(k)}$ 的最大 $k$。\n\n让我们将每个 $p_{(i)}$ 与其对应的临界值 $\\alpha_{BH,(i)}$ 进行比较：\n- 对于 $i=1$：$p_{(1)} = 0.0008 \\le \\frac{1}{12}(0.05) \\approx 0.00417$。条件成立。\n- 对于 $i=2$：$p_{(2)} = 0.002 \\le \\frac{2}{12}(0.05) \\approx 0.00833$。条件成立。\n- 对于 $i=3$：$p_{(3)} = 0.0045 \\le \\frac{3}{12}(0.05) = 0.0125$。条件成立。\n- 对于 $i=4$：$p_{(4)} = 0.006 \\le \\frac{4}{12}(0.05) \\approx 0.01667$。条件成立。\n- 对于 $i=5$：$p_{(5)} = 0.012 \\le \\frac{5}{12}(0.05) \\approx 0.02083$。条件成立。\n- 对于 $i=6$：$p_{(6)} = 0.02 \\le \\frac{6}{12}(0.05) = 0.025$。条件成立。\n- 对于 $i=7$：$p_{(7)} = 0.025 \\le \\frac{7}{12}(0.05) \\approx 0.02917$。条件成立。\n- 对于 $i=8$：$p_{(8)} = 0.04 > \\frac{8}{12}(0.05) \\approx 0.03333$。条件不成立。\n\n满足条件的最大秩为 $k_{BH} = 7$。根据BH程序，所有秩为 $i=1, \\dots, k_{BH}$ 的原假设 $H_{(i)}$ 都被拒绝。\nBH程序下的拒绝数量为 $N_{BH} = 7$。\n\n**任务3：相对保守性**\n\n相对保守性通过BY程序下的拒绝数量与BH程序下的拒绝数量之比来量化。\n$$\n\\text{比率} = \\frac{N_{BY}}{N_{BH}} = \\frac{2}{7}\n$$\n将此分数转换为小数约等于 $0.28571428...$。根据题目要求四舍五入到四位有效数字，我们得到 $0.2857$。这个小于1的比率证实了BY程序的预期更高保守性，由于其对任意依赖性有更严格的控制，因此拒绝了更少的假设。",
            "answer": "$$\n\\boxed{0.2857}\n$$"
        },
        {
            "introduction": "现代生物统计学分析常常涉及结构化的假设，例如在预定义的生物通路内分析基因，这需要比单轮多重检验更复杂的方法。本练习模拟了一个分层检验的真实场景，你需要实现一个两级检验流程：首先识别显著的通路，然后在这些通路内寻找显著的基因，并应用必要的校正来维持整体FDR控制。这个动手编码练习将理论与实践联系起来，为你处理基因组学等高通量领域中常见的多层次检验问题做好准备。",
            "id": "4930969",
            "problem": "给定一个反映通路水平和基因水平假设的两级多重检验问题，这在生物统计学中很常见。在顶层，有 $m$ 个通路假设，其通路水平的 p 值为 $\\{p^{(P)}_1,\\dots,p^{(P)}_m\\}$。在每个通路 $j \\in \\{1,\\dots,m\\}$ 内，有一族基因水平的 p 值 $\\{p^{(G)}_{j1},\\dots,p^{(G)}_{j n_j}\\}$。目标是使用 Benjamini-Hochberg (BH) 程序执行分层多重检验，以在通路和基因两个水平上控制错误发现率 (FDR)，并对考虑了数据依赖选择的第二阶段使用一种有原则的调整方法。\n\n基本定义和规则：\n- 错误发现率 (FDR) 定义为 $\\mathrm{FDR} = \\mathbb{E}\\left[\\frac{V}{\\max(R,1)}\\right]$，其中 $R$ 是拒绝原假设的数量，$V$ 是错误拒绝的数量。\n- 对于具有 p 值 $p_{(1)} \\le \\dots \\le p_{(n)}$ 的 $n$ 个假设，在名义水平 $q \\in (0,1)$ 下的 Benjamini-Hochberg (BH) 步升法规则选择满足 $p_{(k)} \\le \\frac{q k}{n}$ 的最大整数 $k \\in \\{0,1,\\dots,n\\}$（约定 $p_{(0)}=0$）。它拒绝所有满足 $p_i \\le p_{(k)}$ 的假设。当 $k=0$ 时，不拒绝任何假设。\n- 为在依赖于数据的族选择下保持有效的错误发现率保证，应用 Benjamini–Bogomolov (BB) 调整：在顶层以水平 $q_1$ 选择 $R$ 个族后，在每个选定的族内以调整后的水平 $q_2^\\star = q_2 \\cdot \\frac{R}{m}$ 应用 BH 程序，其中 $q_1$ 是通路水平的名义水平，$q_2$ 是目标族内的名义水平。\n\n您的程序必须从第一性原理实现以下分层程序：\n1. 在通路水平上，对 $m$ 个通路 p 值 $\\{p^{(P)}_1,\\dots,p^{(P)}_m\\}$ 应用名义水平为 $q_1$ 的 BH 步升法规则。设 $S \\subseteq \\{1,\\dots,m\\}$ 为选定通路索引的集合，并令 $R = |S|$。将通路 BH 阈值 $t_P$ 定义为 $p^{(P)}_{(k)}$，其中 $k$ 是 BH 索引；当 $R=0$ 时，设 $t_P=0$。\n2. 如果 $R>0$，计算调整后的族内水平 $q_2^\\star = q_2 \\cdot \\frac{R}{m}$。对于每个选定的通路 $j \\in S$，对其基因水平的 p 值 $\\{p^{(G)}_{j1},\\dots,p^{(G)}_{j n_j}\\}$ 应用水平为 $q_2^\\star$ 的 BH 步升法规则。设 $r_j$ 为通路 $j$ 中被拒绝的基因数量，设 $t^{(G)}_j$ 为通路 $j$ 中基因水平的 BH 阈值（如果 $r_j=0$，则设 $t^{(G)}_j=0$）。对于任何未被选择的通路 $j \\notin S$，不执行任何基因水平的检验。\n3. BH 规则中的所有比较都是包含性的；即 $p \\le \\frac{q k}{n}$ 构成一个拒绝。在存在与阈值相等的 p 值的情况下，拒绝所有满足 $p \\le t$ 的假设。\n\n输出规格：\n- 对于每个测试用例，输出一个列表，包含：\n  - 被拒绝的通路数量 $R$（整数）。\n  - 通路水平的 BH 阈值 $t_P$（浮点数）。\n  - 调整后的族内水平 $q_2^\\star$（浮点数）。\n  - 一个整数列表，按通路索引的升序给出 $[r_j]_{j \\in S}$。\n  - 一个浮点数列表，以相同顺序给出 $[t^{(G)}_j]_{j \\in S}$。\n- 所有浮点数必须四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含所有给定测试用例的结果，格式为逗号分隔的各用例结果列表，并用方括号括起来，不含多余空格。例如：“[[case1_result],[case2_result],...]”。\n\n测试套件：\n提供代码以完全按照规定解决以下三个测试用例。所有 p 值均为 $(0,1)$ 内的小数。\n\n- 测试用例 A (正常路径):\n  - $m=5$，通路 p 值 $[0.20,0.012,0.18,0.031,0.40]$，基因族：\n    - 通路 1: $[0.010,0.200,0.300]$\n    - 通路 2: $[0.002,0.015,0.70,0.50]$\n    - 通路 3: $[0.040,0.060]$\n    - 通路 4: $[0.005,0.010,0.020,0.200]$\n    - 通路 5: $[]$\n  - 使用 $q_1 = 0.1$ 和 $q_2 = 0.05$。\n- 测试用例 B (边界情况，无选定通路):\n  - $m=4$，通路 p 值 $[0.20,0.21,0.50,0.07]$，基因族：\n    - 通路 1: $[0.90]$\n    - 通路 2: $[0.60,0.70]$\n    - 通路 3: $[0.80,0.90,0.95]$\n    - 通路 4: $[0.30,0.40]$\n  - 使用 $q_1 = 0.05$ 和 $q_2 = 0.10$。\n- 测试用例 C (全部选定；族内存在等于阈值的情况):\n  - $m=3$，通路 p 值 $[0.02,0.10,0.18]$，基因族：\n    - 通路 1: $[0.02,0.005,0.20,0.016,0.010]$\n    - 通路 2: $[0.08,0.01,0.02,0.05]$\n    - 通路 3: $[0.081,0.08,0.07]$\n  - 使用 $q_1 = 0.2$ 和 $q_2 = 0.08$。\n\n重要实现细节：\n- 根据其定义直接实现 Benjamini-Hochberg 步升法规则，使其适用于任何 p 值输入列表和任何名义水平 $q \\in [0,1]$。\n- 当一个族包含零个假设时，将其拒绝数量定义为 $0$，阈值定义为 $0$。\n- 将所有浮点输出四舍五入到 $6$ 位小数。\n- 您的程序不得读取任何输入；它应在内部嵌入测试套件，并仅以所描述的精确格式打印所需的单行输出。",
            "solution": "该问题要求实现一个基于Benjamini-Hochberg (BH)方法的分层多重检验程序，这是一种在生物统计学中用于控制错误发现率(FDR)的标准且成熟的技术。该问题在科学上是合理的、良定的，并包含构建唯一、可验证解决方案所需的所有必要信息和定义。\n\n解决方案首先从其基本定义出发，实现核心的Benjamini-Hochberg程序，然后将其应用于指定的分层结构中，该结构涉及对第二阶段检验水平的Benjamini-Bogomolov (BB)调整。\n\n### 1. Benjamini-Hochberg (BH) 步升法程序\n对于一族包含 $n$ 个假设及其对应p值和期望的名义FDR水平 $q$，该程序如下：\n1. 将p值从小到大排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(n)}$。\n2. 找到最大的整数索引 $k$（其中 $1 \\le k \\le n$），使得第 $k$ 个有序p值 $p_{(k)}$ 满足条件：$p_{(k)} \\le \\frac{k \\cdot q}{n}$。\n3. 如果存在这样的 $k$，则定义显著性阈值 $t=p_{(k)}$。所有其对应p值 $p_i \\le t$ 的原始假设都被拒绝。\n4. 如果不存在这样的 $k$，则不拒绝任何假设，阈值 $t$ 为 $0$。\n\n### 2. 分层检验程序\n**步骤 2.1：通路水平分析**\n首先，对 $m$ 个通路水平的p值应用BH程序，名义水平为 $q_1$。这将得到被拒绝的通路数量 $R$ 和通路水平的显著性阈值 $t_P$。选定通路的集合是 $S = \\{j \\mid p^{(P)}_j \\le t_P\\}$。\n\n**步骤 2.2：带调整的基因水平分析**\n如果 $R > 0$，则继续检验基因水平的假设，但仅限于选定集合 $S$ 中的通路。根据Benjamini-Bogomolov (BB)调整，用于族内检验的调整后名义水平 $q_2^\\star$ 计算如下：$ q_2^\\star = q_2 \\cdot \\frac{R}{m} $。\n对于每个选定的通路 $j \\in S$，使用调整后的水平 $q_2^\\star$ 对其基因水平的p值应用BH程序，得到通路 $j$ 中被拒绝的基因数量 $r_j$ 和基因水平的阈值 $t_j^{(G)}$。\n\n以下是实现所述过程并为所有测试用例生成输出的完整、可运行的Python 3代码：\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that defines test cases and prints the final\n    formatted result.\n    \"\"\"\n\n    def bh_procedure(p_values, q):\n        \"\"\"\n        Implements the Benjamini-Hochberg (BH) step-up procedure.\n        \"\"\"\n        p_values_np = np.array(p_values)\n        n = len(p_values_np)\n        if n == 0:\n            return 0, 0.0\n\n        sorted_p = np.sort(p_values_np)\n        \n        thresholds = (np.arange(1, n + 1) * q) / n\n\n        significant_indices = np.where(sorted_p = thresholds)[0]\n        \n        if len(significant_indices) == 0:\n            return 0, 0.0\n            \n        k_index = significant_indices[-1]\n        cutoff = sorted_p[k_index]\n        \n        num_rejections = np.sum(p_values_np = cutoff)\n        \n        return int(num_rejections), float(cutoff)\n\n    def run_hierarchical_bh(m, p_pathway, p_genes, q1, q2):\n        \"\"\"\n        Performs the hierarchical BH procedure for a single test case.\n        \"\"\"\n        # Step 1: Pathway-level analysis\n        R, t_P = bh_procedure(p_pathway, q1)\n\n        r_j_list = []\n        t_G_j_list = []\n        q2_star = 0.0\n\n        # Step 2: Gene-level analysis\n        if R > 0:\n            # BB adjustment\n            q2_star = q2 * R / m\n            \n            selected_indices = [i + 1 for i, p in enumerate(p_pathway) if p = t_P]\n            selected_indices.sort() # Ensure ascending order of pathway index\n            \n            for j in selected_indices:\n                current_p_genes = p_genes[j - 1]\n                r_j, t_G_j = bh_procedure(current_p_genes, q2_star)\n                r_j_list.append(r_j)\n                t_G_j_list.append(t_G_j)\n        \n        return [R, t_P, q2_star, r_j_list, t_G_j_list]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            \"m\": 5, \"p_pathway\": [0.20, 0.012, 0.18, 0.031, 0.40],\n            \"p_genes\": [\n                [0.010, 0.200, 0.300],\n                [0.002, 0.015, 0.70, 0.50],\n                [0.040, 0.060],\n                [0.005, 0.010, 0.020, 0.200],\n                []\n            ],\n            \"q1\": 0.1, \"q2\": 0.05\n        },\n        # Test case B\n        {\n            \"m\": 4, \"p_pathway\": [0.20, 0.21, 0.50, 0.07],\n            \"p_genes\": [\n                [0.90],\n                [0.60, 0.70],\n                [0.80, 0.90, 0.95],\n                [0.30, 0.40]\n            ],\n            \"q1\": 0.05, \"q2\": 0.10\n        },\n        # Test case C\n        {\n            \"m\": 3, \"p_pathway\": [0.02, 0.10, 0.18],\n            \"p_genes\": [\n                [0.02, 0.005, 0.20, 0.016, 0.010],\n                [0.08, 0.01, 0.02, 0.05],\n                [0.081, 0.08, 0.07]\n            ],\n            \"q1\": 0.2, \"q2\": 0.08\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_hierarchical_bh(\n            case[\"m\"], case[\"p_pathway\"], case[\"p_genes\"], case[\"q1\"], case[\"q2\"]\n        )\n        results.append(result)\n\n    def format_single_result(res):\n        \"\"\"Formats a single case result into the required string format.\"\"\"\n        R, t_P, q2_star, r_j_list, t_G_j_list = res\n        \n        t_P_str = f\"{t_P:.6f}\"\n        q2_star_str = f\"{q2_star:.6f}\"\n        \n        r_j_list_str = f\"[{','.join(map(str, r_j_list))}]\"\n        \n        t_G_j_list_str = f\"[{','.join([f'{t:.6f}' for t in t_G_j_list])}]\"\n\n        return f\"[{R},{t_P_str},{q2_star_str},{r_j_list_str},{t_G_j_list_str}]\"\n\n    final_output_str = f\"[{','.join(format_single_result(r) for r in results)}]\"\n    print(final_output_str)\n\nsolve()\n```",
            "answer": "[[2,0.031000,0.020000,[1,2],[0.002000,0.010000]],[0,0.000000,0.000000,[],[]],[3,0.180000,0.080000,[4,4,0],[0.020000,0.080000,0.000000]]]"
        }
    ]
}