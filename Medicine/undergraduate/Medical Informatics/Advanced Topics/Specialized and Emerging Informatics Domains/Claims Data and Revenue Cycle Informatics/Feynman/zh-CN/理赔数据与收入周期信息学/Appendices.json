{
    "hands_on_practices": [
        {
            "introduction": "在医疗服务之后，费用的结算通常需要在患者和保险公司之间进行分摊。理解如何计算患者的自付费用是医疗计费和收入周期管理中的一项基本技能。这项练习将引导你完成一个标准案例，在其中你需要应用诸如免赔额、共同保险和自付上限等核心保险概念来确定患者的最终财务责任。",
            "id": "4825970",
            "problem": "一家医院就单次就诊提交了一份网络内门诊影像服务理赔申请，协商允许金额为 $1287.45$ 美元。该患者参加了一项优选医疗机构 (PPO) 计划，其福利设计和本年度累积额如下：\n\n- 年度免赔额：$1000$ 美元。该患者今年早些时候已支付 $570$ 美元用于满足免赔额，因此在本次理赔时，剩余免赔额为 $430$ 美元。\n- 免赔额满足后的共付保险比例：百分之十八，适用于允许金额中超出本次理赔仍需支付的任何免赔额的部分。\n- 每次网络内门诊的共付额：$35$ 美元，此费用在任何免赔额或共付保险之外额外适用。\n- 年度自付费用上限：$4500$ 美元。在本次理赔前，年初至今的患者费用分摊累积额（包括免赔额、共付保险和共付额）总计为 $3800$ 美元，因此剩余自付费用额度为年度上限减去年初至今的金额。\n\n假设由于是网络内服务，不存在福利协调、非承保费用和差额计费。仅根据医疗理赔裁决和收入周期信息学中使用的核心定义——即：\n- 免赔额是患者每年必须首先支付的承保允许费用部分，直到满足免赔额为止。\n- 共付保险是患者的费用分摊比例，适用于在满足本次理赔所欠的任何免赔额后剩余的允许费用部分。\n- 共付额是每次就诊适用的固定费用，在此计划设计下，它是在免赔额和共付保险之外额外增加的。\n- 自付费用上限为计划年度内患者支付的总费用分摊设定了上限；如果某次理赔会导致患者超出剩余的自付费用额度，则该理赔的患者责任金额将被减少，以确保患者支付的累计总额不超过该上限。\n\n根据这些定义，通过以下步骤推导出患者对本次单一理赔的责任金额：\n1. 确定应用于剩余免赔额的金额，\n2. 确定免赔额部分支付后剩余的任何允许金额的共付保险，\n3. 加上共付额，\n4. 用剩余的自付费用额度对结果进行封顶。\n\n以美元 (USD) 表示最终的患者责任金额，并将您的答案四舍五入到四位有效数字。",
            "solution": "首先，我们根据问题陈述定义变量和计算初步数值。\n- 理赔的允许金额：$A = \\$1287.45$\n- 剩余免赔额 $D_{rem} = \\$1000 - \\$570 = \\$430$\n- 共付保险比例：$r_{co} = 18\\% = 0.18$\n- 每次就诊的共付额：$C_{pay} = \\$35$\n- 剩余自付费用额度 $R_{OOP} = \\$4500 - \\$3800 = \\$700$\n\n接下来，我们遵循指定的四个步骤计算患者对本次理赔的总责任金额。\n\n1.  **确定应用于剩余免赔额的金额。**\n    患者需负责支付允许金额中不超过其剩余免赔额的部分。该金额 $P_D$ 是允许金额和剩余免赔额中的较小者。\n    $$P_D = \\min(A, D_{rem}) = \\min(\\$1287.45, \\$430) = \\$430$$\n    支付此金额后，患者的年度免赔额将完全满足。\n\n2.  **确定共付保险。**\n    共付保险适用于本次理赔的免赔额部分被核算后剩余的允许金额部分。需要计算共付保险的金额 $A_{co}$ 为：\n    $$A_{co} = A - P_D = \\$1287.45 - \\$430 = \\$857.45$$\n    患者的共付保险付款 $P_{co}$ 是此金额乘以共付保险比例。\n    $$P_{co} = A_{co} \\times r_{co} = \\$857.45 \\times 0.18 = \\$154.341$$\n\n3.  **加上共付额。**\n    问题指明，共付额 $C_{pay}$ 是一项附加费用。我们通过将免赔额部分、共付保险部分和共付额相加来计算初始患者责任金额 $L_{initial}$。\n    $$L_{initial} = P_D + P_{co} + C_{pay} = \\$430 + \\$154.341 + \\$35 = \\$619.341$$\n\n4.  **用剩余的自付费用额度对结果进行封顶。**\n    最终患者责任金额 $L_{final}$ 不能导致患者的年度总费用分摊超过自付费用上限。因此，本次理赔的责任金额上限为剩余的自付费用额度 $R_{OOP}$。最终责任金额是计算出的责任金额和剩余 OOP 额度中的较小者。\n    $$L_{final} = \\min(L_{initial}, R_{OOP}) = \\min(\\$619.341, \\$700) = \\$619.341$$\n    由于计算出的责任金额 $\\$619.341$ 小于剩余的自付费用额度 $\\$700$，因此自付费用上限不会减少患者对本次理赔的责任。\n\n最终的患者责任金额为 $\\$619.341$。问题要求将此答案四舍五入到四位有效数字。前四位有效数字是 $6$、$1$、$9$ 和 $3$。第五位有效数字是 $4$，小于 $5$，因此我们向下取整。\n$$L_{rounded} = 619.3$$\n\n本次理赔的最终患者责任金额为 $\\$619.30$。",
            "answer": "$$\\boxed{619.3}$$"
        },
        {
            "introduction": "计算出患者的责任部分后，下一个关键问题是保险公司会向医疗服务提供方支付多少费用。这项练习将深入探讨支付方报销的复杂性，以美国联邦医疗保险（Medicare）的医师费用表为模型。你将学习如何从相对价值单位 (RVUs) 出发，结合地理位置和特定手术的调整规则，来构建最终的支付金额，从而洞悉复杂的支付方方法学。",
            "id": "4825991",
            "problem": "一个卫生系统需要使用基于资源的相对价值量表（Resource-Based Relative Value Scale）的组成部分，来计算当日进行的一组操作的医疗保险医师费率表（Medicare Physician Fee Schedule）支付金额。该费率表支付金额源于以下基础：每项服务都有工作相对价值单位、执业费用相对价值单位和医疗事故相对价值单位；这些单位都通过相应的地理执业成本指数（Geographic Practice Cost Index）进行地理调整；然后，它们的总和再乘以医疗保险转换因子。某些支付政策会修改最终金额，包括双侧手术调整、多项操作支付减免，以及根据医疗机构和非医疗机构环境改变执业费用相对价值单位的服务地点差异。\n\n考虑在单一地区的一家门诊医院（医疗机构环境）为单个受益人进行的以下就诊。所有服务均可单独报告且未捆绑。没有全局期重叠，除了双侧修正因子外没有其他修正因子，也没有预算中性或自动减支调整。请使用以下数据。\n\n- 地区地理执业成本指数值：$GPCI_{w} = 1.04$，$GPCI_{p} = 0.97$，$GPCI_{f} = 0.91$。\n- 医疗保险转换因子：$CF = 33.89$ 美元/相对价值单位。\n- 操作 A（受双侧手术和多项操作政策影响）：工作相对价值单位 $RVU_{w,A} = 5.50$，医疗机构环境下的执业费用相对价值单位 $RVU_{p,A}^{(fac)} = 1.40$（非医疗机构为 $RVU_{p,A}^{(nonfac)} = 3.60$），医疗事故相对价值单位 $RVU_{f,A} = 0.50$。该服务在同一次手术中双侧进行，符合双侧手术调整的条件，当双侧进行时，其允许金额乘以因子 $1.5$。\n- 操作 B（受多项操作政策影响，但不符合双侧支付条件）：工作相对价值单位 $RVU_{w,B} = 3.20$，医疗机构环境下的执业费用相对价值单位 $RVU_{p,B}^{(fac)} = 0.80$（非医疗机构为 $RVU_{p,B}^{(nonfac)} = 2.10$），医疗事故相对价值单位 $RVU_{f,B} = 0.30$。\n\n本次就诊的支付政策说明：\n- 由于服务在医疗机构环境中进行，因此每项服务都使用医疗机构的执业费用相对价值单位。\n- 首先，使用基于资源的相对价值量表和地区调整来确定每项服务的允许金额。如果某项服务符合双侧条件且双侧进行，则在此阶段将双侧因子应用于该服务的允许金额。\n- 然后，按如下方式应用多项操作减免：根据双侧调整后的允许金额对服务进行排序；按 $1.0$ 的因子支付最高的允许金额，每项额外服务按 $0.5$ 的因子支付。\n\n遵循上述规则，计算本次就诊的总允许金额。将您的最终总额四舍五入到四位有效数字，并以美元（USD）表示结果。您的最终数值答案必须是单个实数值。",
            "solution": "首先，为单个操作 $i$ 建立地理调整后总相对价值单位（$RVU_{total}$）的通用公式：\n$$RVU_{total,i} = (RVU_{w,i} \\times GPCI_{w}) + (RVU_{p,i} \\times GPCI_{p}) + (RVU_{f,i} \\times GPCI_{f})$$\n该操作的允许金额通过将总调整后 RVU 乘以医疗保险转换因子（$CF$）来计算：\n$$Amount_{i} = RVU_{total,i} \\times CF$$\n计算过程分为三个主要步骤：(1) 确定每项操作的允许金额，并在适用的情况下应用双侧手术因子；(2) 应用多项操作支付减免；(3) 将最终金额相加。\n\n**步骤1：单独计算每项操作的允许金额。**\n\n对于操作 A：\n使用给定的 RVU 值和 GPCI 值，计算操作 A 的地理调整后总 RVU（$RVU_{total,A}$）：\n$$RVU_{total,A} = (5.50 \\times 1.04) + (1.40 \\times 0.97) + (0.50 \\times 0.91)$$\n$$RVU_{total,A} = 5.72 + 1.358 + 0.455 = 7.533$$\n操作 A 的基础允许金额（$Amount_{A,base}$）为：\n$$Amount_{A,base} = RVU_{total,A} \\times CF = 7.533 \\times 33.89 = 255.30937$$\n操作 A 是双侧进行的，并符合 $1.5$ 的双侧手术调整因子。\n$$Amount_{A,adj} = Amount_{A,base} \\times 1.5 = 255.30937 \\times 1.5 = 382.964055$$\n\n对于操作 B：\n计算操作 B 的地理调整后总 RVU（$RVU_{total,B}$）：\n$$RVU_{total,B} = (3.20 \\times 1.04) + (0.80 \\times 0.97) + (0.30 \\times 0.91)$$\n$$RVU_{total,B} = 3.328 + 0.776 + 0.273 = 4.377$$\n操作 B 的允许金额（$Amount_{B,adj}$）为：\n$$Amount_{B,adj} = RVU_{total,B} \\times CF = 4.377 \\times 33.89 = 148.33553$$\n\n**步骤2：应用多项操作支付减免（MPPR）。**\n该政策要求在进行任何双侧调整后，按允许金额对操作进行排序。\n$$Amount_{A,adj} = 382.964055$$\n$$Amount_{B,adj} = 148.33553$$\n由于 $Amount_{A,adj} > Amount_{B,adj}$，操作 A 是排名最高的服务，按 $1.0$ 的因子支付。操作 B 是附加服务，按 $0.5$ 的因子支付。\n\n操作 A 的最终支付金额为：\n$$Payment_{A} = 1.0 \\times Amount_{A,adj} = 1.0 \\times 382.964055 = 382.964055$$\n操作 B 的最终支付金额为：\n$$Payment_{B} = 0.5 \\times Amount_{B,adj} = 0.5 \\times 148.33553 = 74.167765$$\n\n**步骤3：计算就诊的总允许金额。**\n总允许金额是所有操作最终支付金额的总和。\n$$总金额 = Payment_{A} + Payment_{B}$$\n$$总金额 = 382.964055 + 74.167765 = 457.13182$$\n题目要求最终答案四舍五入到四位有效数字。计算值为 $457.13182$。前四位有效数字是 $4$、$5$、$7$ 和 $1$。第五位有效数字是 $3$，小于 $5$，因此舍去。\n$$四舍五入后的总金额 = 457.1$$\n总允许金额为 $457.10$ 美元。",
            "answer": "$$\\boxed{457.1}$$"
        },
        {
            "introduction": "现实世界中的理赔数据并非静态的交易列表，而是一个动态的记录，原始理赔单经常会被更正、调整甚至作废。最后的这项练习将从单次理赔的计算转向数据管理，你需要设计一套逻辑来“轧平”一个理赔链，以确定用于分析的唯一、权威的版本。这个过程将向你介绍医疗信息学中一个核心的数据工程挑战，即确保数据的准确性和一致性。",
            "id": "4826012",
            "problem": "一个卫生系统希望利用包含原始理赔、替换调整和作废的理赔数据，为每个服务线生成唯一的净记录用于分析。从收入周期管理（RCM）的角度来看，理赔是一个由理赔控制号（CCN）标识的版本化对象，其中每个新版本通过其父CCN引用前一版本，并使用理赔频率代码来指明其是原始理赔、替换（调整）还是作废（取消）。任务是指定一个数学上严谨的去重和净额结算逻辑，并将其实现为一个完整的程序，该程序能在一小组测试套件上产生确定性的结果。\n\n基本依据：\n- 在医疗计费标准中，机构理赔（统一账单，UB-04）上的理赔频率代码被广泛接受用来表示版本语义：$1$ 表示原始，$7$ 表示替换，$8$ 表示作废。这些是医疗保健领域理赔电子数据交换（EDI）中经过充分检验的惯例。\n- 版本控制原则：一个新的理赔版本通过明确引用父CCN来取代其父版本。这建立了一个有向无环图（DAG），其中每个节点是一个理赔版本，边代表取代关系。\n- 对于服务线分析，取代链中的最终版本才代表要分析的净状态。作废的语义是取消理赔，因此其净贡献为空。\n\n定义：\n- 服务线记录是一个元组 $(c, p, f, \\ell, a)$，其中 $c$ 是整数类型的理赔控制号（CCN），$p$ 是整数类型的父CCN或表示没有父项的空标记， $f \\in \\{1,7,8\\}$ 是整数类型的理赔频率代码，$\\ell$ 是整数类型的服务线标识符，$a$ 是一个实数，表示服务线的允许金额（以货币单位计，最终输出表示为不带货币符号的小数）。\n- 理赔版本内去重：对于所有具有相同 $c$ 的行，如果多行共享相同的 $\\ell$，则只保留输入顺序中的最后一行。这是一种“后写者优先”逻辑，与重复行条目的规范化处理一致。\n- 跨版本净额结算：在CCN上定义一个有向图 $G$，使得对于每个具有 $(c,p)$ 且 $p$ 不为空的记录，都存在一条从 $p$ 到 $c$ 的有向边。对于每个连通分量，令终端节点为任何出度为 $0$ 的CCN。该分量的净记录为：\n  - 如果终端节点的 $f=8$，则净记录为空集（无服务线）。\n  - 否则，净记录是来自终端节点的去重后服务线集合，按 $\\ell$ 升序排列，其金额 $a$ 取自该终端版本。\n- 游离调整：如果一个替换（$f=7$）引用了数据中不存在的父CCN，则将该替换视为该事件中净额结算的权威版本；终端节点即为该替换本身（除非后续被取代）。\n- 引用未知父项的作废：如果一个作废（$f=8$）引用了数据中不存在的父CCN，则将该事件的终端视为作废，并生成一个空的净记录。\n\n数学形式化：\n- 对于每个CCN $c$，令 $L_c$ 为去重后将服务线标识符 $\\ell$ 映射到金额 $a$ 的函数，即 $L_c(\\ell)$ 等于所有具有 $(c,\\ell)$ 的行中，按输入顺序最后一行所对应的金额。\n- 令 $E$ 表示 $G$ 的一个连通分量，令 $T(E)$ 表示其终端CCN（在链式结构下是唯一的；对于因不相交子链而产生的多个终端，则独立处理每个链）。定义净额算子 $N(E)$ 如下：\n  $$\n  N(E) = \\begin{cases}\n  \\varnothing  \\text{if } f(T(E)) = 8, \\\\\n  \\{ (\\ell, L_{T(E)}(\\ell)) \\mid \\ell \\in \\operatorname{dom}(L_{T(E)}) \\}  \\text{otherwise}.\n  \\end{cases}\n  $$\n- 程序必须为每个提供的测试用例计算 $N(E)$，并按 $\\ell$ 升序输出金额列表。金额为实数（小数）。如果 $N(E) = \\varnothing$，则输出一个空列表。\n\n程序输入格式：\n- 没有外部输入。程序必须在内部将测试套件定义为 Python 数据结构。\n\n测试套件：\n每个测试用例是一个行列表 $(c, p, f, \\ell, a)$，编码为带有键 \"ccn\", \"parent\", \"freq\", \"line_id\", 和 \"amount\" 的字典。数据集顺序是按时间排列的，因此去重操作使用所列顺序中每个 $(c,\\ell)$ 的最后一次出现。\n\n- 测试用例 1（理想路径，单个原始理赔含两条服务线）：\n  - $(c=$100$, p=\\text{None}, f=$1$, \\ell=$1$, a=$100.0$)$\n  - $(c=$100$, p=\\text{None}, f=$1$, \\ell=$2$, a=$50.0$)$\n  预期净金额：$[100.0, 50.0]$。\n\n- 测试用例 2（原始理赔被单次调整所替换）：\n  - $(c=$200$, p=\\text{None}, f=$1$, \\ell=$1$, a=$100.0$)$\n  - $(c=$200$, p=\\text{None}, f=$1$, \\ell=$2$, a=$50.0$)$\n  - $(c=$201$, p=$200$, f=$7$, \\ell=$1$, a=$120.0$)$\n  - $(c=$201$, p=$200$, f=$7$, \\ell=$2$, a=$70.0$)$\n  来自终端 $c=$201 的预期净金额：$[120.0, 70.0]$。\n\n- 测试用例 3（原始理赔，然后替换，然后作废）：\n  - $(c=$300$, p=\\text{None}, f=$1$, \\ell=$1$, a=$90.0$)$\n  - $(c=$301$, p=$300$, f=$7$, \\ell=$1$, a=$95.0$)$\n  - $(c=$302$, p=$301$, f=$8$, \\ell=$1$, a=$0.0$)$\n  预期净金额：$[]$（作废取消了该事件）。\n\n- 测试用例 4（原始理赔中存在重复服务线，去重采用后写者优先）：\n  - $(c=$400$, p=\\text{None}, f=$1$, \\ell=$1$, a=$100.0$)$\n  - $(c=$400$, p=\\text{None}, f=$1$, \\ell=$1$, a=$100.0$)$\n  预期净金额：$[100.0]$。\n\n- 测试用例 5（游离替换引用未知父项；将替换视为权威版本）：\n  - $(c=$501$, p=$500$, f=$7$, \\ell=$1$, a=$80.0$)$\n  预期净金额：$[80.0]$。\n\n- 测试用例 6（多步替换；后续替换移除了一条服务线）：\n  - $(c=$600$, p=\\text{None}, f=$1$, \\ell=$1$, a=$60.0$)$\n  - $(c=$600$, p=\\text{None}, f=$1$, \\ell=$2$, a=$40.0$)$\n  - $(c=$601$, p=$600$, f=$7$, \\ell=$1$, a=$60.0$)$\n  - $(c=$601$, p=$600$, f=$7$, \\ell=$2$, a=$50.0$)$\n  - $(c=$602$, p=$601$, f=$7$, \\ell=$1$, a=$70.0$)$\n  来自终端 $c=$602 的预期净金额：$[70.0]$。\n\n- 测试用例 7（作废引用未知父项；产生空结果）：\n  - $(c=$701$, p=$700$, f=$8$, \\ell=$1$, a=$10.0$)$\n  预期净金额：$[]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，并且本身必须是一个按 $\\ell$ 升序排列的表示净金额的小数列表。例如，三个测试用例的有效输出可能如下所示：$[[100.0,50.0],[120.0,70.0],[]]$。",
            "solution": "该任务要求设计一个正式的程序，用于对一系列版本化的医疗理赔进行净额结算。每个理赔由一个理赔控制号（$c$）标识，并可能通过引用一个父CCN（$p$）来取代先前的版本。理赔的性质由一个频率代码（$f$）给出：$1$ 代表原始，$7$ 代表替换，$8$ 代表作废。一个理赔包含一个或多个服务线，每个服务线都有一个标识符（$\\ell$）和一个金额（$a$）。目标是为每个理赔事件确定最终的，或称“净”的服务线金额集合。\n\n这个问题可以使用图论来建模。所有理赔的集合构成了一个有向图的集合，其中每个CCN是一个节点，从父理赔 $p$ 到其子理赔 $c$ 存在一条有向边。该图结构的每个连通分量代表一个单独的理赔事件。问题要求我们找到每个事件的终端节点——即理赔的最终版本——并提取其服务线数据，同时对作废情况进行特殊处理。\n\n解决此问题的算法按以下四个主要步骤进行：\n\n1.  **数据聚合与理赔内去重**：第一步是将原始输入记录处理为每个唯一CCN的结构化表示。我们使用一个字典，其中每个键是一个CCN，$c$。与每个键关联的值是一个对象，包含理赔的属性：其父CCN（$p$）、其频率代码（$f$）以及其服务线的集合。在此聚合过程中，我们应用指定的去重规则：对于同一理赔版本（即相同的 $c$）内共享相同服务线标识符（$\\ell$）的任何服务线，只保留在输入数据中遇到的最后一个。这种“后写者优先”的逻辑通过在遍历输入列表时简单地覆盖给定 $(c, \\ell)$ 对的金额来实现。\n\n2.  **图构建与事件识别**：我们建立理赔版本之间的取代关系。对于每个具有非空父项 $p$ 的记录，存在一条从 $p$ 到 $c$ 的有向边。所有此类理赔和边的集合构成了一个有根树森林，其中每个树或不相交的子图都是一个代表单个理赔事件的连通分量。对于“游离”调整和作废（即那些引用数据集中不存在的父CCN的理赔），此类理赔将成为新事件树的根。\n\n3.  **终端节点识别**：对于每个理赔事件（连通分量），我们必须找到其终端节点 $T(E)$。终端节点定义为其分量内出度为 $0$ 的CCN；也就是说，它不是数据集中任何其他理赔的父项。这可以通过识别所有唯一CCN的集合（$C_{defined}$）和所有被引用为父项的CCN的集合（$P_{referenced}$）来算法找到。终端节点的集合是集合差 $C_{defined} \\setminus P_{referenced}$。\n\n4.  **净记录生成**：在为一个事件识别出终端节点 $c_T = T(E)$ 后，我们应用最终的净额结算算子 $N(E)$。我们检索终端理赔的频率代码 $f(c_T)$。\n    - 如果 $f(c_T) = 8$，则该理赔事件被作废。净记录为空集 $\\varnothing$。\n    - 如果 $f(c_T) \\neq 8$ （即为 $1$ 或 $7$），净记录是与终端理赔 $c_T$ 相关联的服务线集合。最终输出要求这些服务线的金额，并按服务线标识符 $\\ell$ 的升序排列。\n\n这一系列操作提供了一种确定性、可重复且数学上严谨的方法，用于将版本化的理赔数据解析为最终的净状态以供分析。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Solves the claims netting problem for a suite of test cases.\n    The solution follows the specified logic of representing claims as a graph,\n    finding the terminal node of each claim episode, and applying netting rules.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path, single original with two lines)\n        [\n            {\"ccn\": 100, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 100.0},\n            {\"ccn\": 100, \"parent\": None, \"freq\": 1, \"line_id\": 2, \"amount\": 50.0},\n        ],\n        # Test case 2 (original replaced by a single adjustment)\n        [\n            {\"ccn\": 200, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 100.0},\n            {\"ccn\": 200, \"parent\": None, \"freq\": 1, \"line_id\": 2, \"amount\": 50.0},\n            {\"ccn\": 201, \"parent\": 200, \"freq\": 7, \"line_id\": 1, \"amount\": 120.0},\n            {\"ccn\": 201, \"parent\": 200, \"freq\": 7, \"line_id\": 2, \"amount\": 70.0},\n        ],\n        # Test case 3 (original, then replacement, then void)\n        [\n            {\"ccn\": 300, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 90.0},\n            {\"ccn\": 301, \"parent\": 300, \"freq\": 7, \"line_id\": 1, \"amount\": 95.0},\n            {\"ccn\": 302, \"parent\": 301, \"freq\": 8, \"line_id\": 1, \"amount\": 0.0},\n        ],\n        # Test case 4 (duplicate lines in original, dedup last-wins)\n        [\n            {\"ccn\": 400, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 100.0},\n            {\"ccn\": 400, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 100.0},\n        ],\n        # Test case 5 (stray replacement referencing unknown parent)\n        [\n            {\"ccn\": 501, \"parent\": 500, \"freq\": 7, \"line_id\": 1, \"amount\": 80.0},\n        ],\n        # Test case 6 (multi-step replacements; later replacement removes a line)\n        [\n            {\"ccn\": 600, \"parent\": None, \"freq\": 1, \"line_id\": 1, \"amount\": 60.0},\n            {\"ccn\": 600, \"parent\": None, \"freq\": 1, \"line_id\": 2, \"amount\": 40.0},\n            {\"ccn\": 601, \"parent\": 600, \"freq\": 7, \"line_id\": 1, \"amount\": 60.0},\n            {\"ccn\": 601, \"parent\": 600, \"freq\": 7, \"line_id\": 2, \"amount\": 50.0},\n            {\"ccn\": 602, \"parent\": 601, \"freq\": 7, \"line_id\": 1, \"amount\": 70.0},\n        ],\n        # Test case 7 (void referencing unknown parent)\n        [\n            {\"ccn\": 701, \"parent\": 700, \"freq\": 8, \"line_id\": 1, \"amount\": 10.0},\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        net_amounts = process_claim_episode(case)\n        results.append(net_amounts)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_claim_episode(records):\n    \"\"\"\n    Processes a list of service line records for a single claim episode.\n\n    Args:\n        records: A list of dictionaries, where each dictionary is a service line record.\n\n    Returns:\n        A list of floats representing the net amounts, sorted by line_id,\n        or an empty list if the episode is voided.\n    \"\"\"\n    # Step 1: Data Aggregation and Intra-Claim Deduplication\n    claims_data = {}\n    for record in records:\n        ccn = record[\"ccn\"]\n        if ccn not in claims_data:\n            claims_data[ccn] = {\n                \"parent\": record[\"parent\"],\n                \"freq\": record[\"freq\"],\n                \"lines\": {}\n            }\n        # Last-write-wins for service lines\n        claims_data[ccn][\"lines\"][record[\"line_id\"]] = record[\"amount\"]\n\n    if not claims_data:\n        return []\n\n    # Step 2  3: Graph Construction and Terminal Node Identification\n    defined_ccns = set(claims_data.keys())\n    # A CCN is a parent if it's listed as a parent of another defined CCN\n    parent_ccns = {data[\"parent\"] for data in claims_data.values() if data[\"parent\"] in defined_ccns}\n    \n    # Terminal CCNs are defined CCNs that are not parents to any other defined CCN\n    terminal_ccns = defined_ccns - parent_ccns\n\n    if not terminal_ccns:\n        # This case should not happen with the given problem constraints, as a DAG must\n        # have at least one node with out-degree 0 unless it's empty or has a cycle.\n        # Assuming no cycles as per \"DAG\" description.\n        return []\n        \n    # Each test case represents a single episode, so we expect one terminal node.\n    terminal_ccn = list(terminal_ccns)[0]\n    \n    # Step 4: Net Record Generation\n    terminal_claim = claims_data[terminal_ccn]\n    \n    # If the terminal claim is a void (frequency code 8), the net result is empty.\n    if terminal_claim[\"freq\"] == 8:\n        return []\n\n    # Otherwise, sort the service lines by ID and extract the amounts.\n    sorted_lines = sorted(terminal_claim[\"lines\"].items())\n    net_amounts = [amount for line_id, amount in sorted_lines]\n    \n    return net_amounts\n\nsolve()\n```"
        }
    ]
}