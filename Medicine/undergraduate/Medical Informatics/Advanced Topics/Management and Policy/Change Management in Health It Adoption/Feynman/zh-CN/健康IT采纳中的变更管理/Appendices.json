{
    "hands_on_practices": [
        {
            "introduction": "成功的健康信息技术采纳始于坚实的项目管理基础。本练习将介绍关键路径法 (Critical Path Method, CPM)，这是一种用于规划和确定项目时间表的关键工具。通过将 CPM 应用于一个真实的电子健康记录 (EHR) 实施场景，您将学习如何计算项目的最短持续时间，这是设定实际期望和有效管理资源的核心技能。",
            "id": "4825800",
            "problem": "一家医院正在采用一套新的电子健康记录（EHR）系统，这是医学信息学领域企业变更管理项目的一部分。该变更计划表示为一个活动前置网络，其中活动的持续时间是确定的，以周为单位。当一项活动的所有前置条件都完成后，该活动可以立即开始。假设没有资源限制，没有延迟，并且当活动按顺序排列时，其持续时间是固定的且可相加的。\n\n基本原理：在关键路径法（CPM）中，项目被建模为一个有向无环图，其中节点代表具有持续时间的活动，有向边代表前置约束。在这种表示方法下，项目的最小可行完成时间等于从开始到结束贯穿网络的最长路径的长度（以时间计），因为每个活动的最早开始时间取决于沿任何传入路径的最晚（即时间最长）前置活动的完成时间。\n\n该医院的关键变更活动和前置约束如下：\n- 构建和配置EHR（“Build”），持续时间为 $8$ 周。\n- 员工培训（“Training”），持续时间为 $4$ 周，必须在“Build”完成后才能开始。\n- 利益相关者沟通与参与（“Communication”），持续时间为 $4$ 周，必须在“Build”完成后才能开始。\n- 上线稳定（“Go-Live”），持续时间为 $1$ 周，必须在“Training”和“Communication”都完成后才能开始。\n\n将项目开始时间视为 $0$ 周。使用上述CPM基本原理，计算项目的最小持续时间。请用一个以周为单位的实数值数字表示您的最终答案。无需四舍五入；请报告确切的整数周数。",
            "solution": "用户提供了一个问题，要求应用关键路径法（CPM）来确定一个项目的最小持续时间。\n\n### 步骤1：提取已知条件\n问题陈述提供了以下信息：\n-   **方法：** 关键路径法（CPM）。项目的最小完成时间是项目网络中最长路径的长度。\n-   **项目开始时间：** $0$ 周。\n-   **活动与持续时间：**\n    -   `构建`：$8$ 周\n    -   `培训`：$4$ 周\n    -   `沟通`：$4$ 周\n    -   `上线`：$1$ 周\n-   **前置约束：**\n    -   `培训`必须在`构建`之后。\n    -   `沟通`必须在`构建`之后。\n    -   `上线`必须在`培训`和`沟通`之后。\n\n### 步骤2：使用提取的已知条件进行验证\n根据所需标准对问题进行验证：\n-   **科学依据：** 该问题基于关键路径法，这是运筹学和项目管理中一个标准且成熟的算法。所提供的“基本原理”是对CPM核心原则的正确描述。\n-   **适定性：** 该问题是适定的。活动、其持续时间以及前置关系都已明确定义，这允许构建一个有向无环图并计算出唯一的最小项目持续时间。\n-   **客观性：** 该问题以客观的方式陈述，使用了精确的语言和定量数据。它没有主观或含糊不清的术语。\n-   **完整性：** 该问题是自包含的，提供了找到解决方案所需的所有信息。\n-   **一致性：** 所提供的数据和约束是内部一致的，不会导致矛盾。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将构建一个解决方案。\n\n### 解答\n问题要求计算采用EHR系统的项目的最小持续时间，该项目可以建模为一个项目网络。根据提供的基本原理，这个持续时间等于相应有向无环图中最长路径（关键路径）的长度。\n\n让我们将项目表示为一个图，其中节点是活动，有向边代表前置约束。为了使图完整，我们引入一个持续时间为 $0$ 的`开始`节点，它在所有初始活动之前；以及一个持续时间为 $0$ 的`结束`节点，它在所有最终活动之后。\n\n活动及其持续时间（$D$）如下：\n-   $D_{Start} = 0$\n-   $D_{Build} = 8$\n-   $D_{Training} = 4$\n-   $D_{Communication} = 4$\n-   $D_{Go-Live} = 1$\n-   $D_{Finish} = 0$\n\n前置约束定义了图的有向边：\n1.  `Start` $\\rightarrow$ `Build`\n2.  `Build` $\\rightarrow$ `Training`\n3.  `Build` $\\rightarrow$ `Communication`\n4.  `Training` $\\rightarrow$ `Go-Live`\n5.  `Communication` $\\rightarrow$ `Go-Live`\n6.  `Go-Live` $\\rightarrow$ `Finish`\n\n我们必须识别从`开始`节点到`结束`节点的所有可能路径，并计算每条路径的总持续时间。路径的持续时间是该路径上所有活动持续时间之和。\n\n网络结构显示，`构建`活动之后是两个并行活动，即`培训`和`沟通`，这两个活动都必须在`上线`活动开始前完成。这在网络中创建了两条不同的路径。\n\n**路径1：** `Start` $\\rightarrow$ `Build` $\\rightarrow$ `Training` $\\rightarrow$ `Go-Live` $\\rightarrow$ `Finish`\n该路径的总持续时间 $T_1$ 是其组成活动持续时间的总和：\n$$T_1 = D_{Start} + D_{Build} + D_{Training} + D_{Go-Live} + D_{Finish}$$\n代入给定值：\n$$T_1 = 0 + 8 + 4 + 1 + 0 = 13 \\text{ weeks}$$\n\n**路径2：** `Start` $\\rightarrow$ `Build` $\\rightarrow$ `Communication` $\\rightarrow$ `Go-Live` $\\rightarrow$ `Finish`\n该路径的总持续时间 $T_2$ 的计算方式类似：\n$$T_2 = D_{Start} + D_{Build} + D_{Communication} + D_{Go-Live} + D_{Finish}$$\n代入给定值：\n$$T_2 = 0 + 8 + 4 + 1 + 0 = 13 \\text{ weeks}$$\n\n项目的最小持续时间由网络中最长路径（关键路径）的长度决定。我们比较所有已识别路径的持续时间：\n$$\\text{Minimal Project Duration} = \\max(T_1, T_2)$$\n$$\\text{Minimal Project Duration} = \\max(13, 13) = 13 \\text{ weeks}$$\n\n两条路径的长度相同，因此它们都是关键路径。最长路径的持续时间，也就是完成项目的最短时间，是 $13$ 周。",
            "answer": "$$\n\\boxed{13}\n$$"
        },
        {
            "introduction": "在实施变革后，衡量其影响至关重要，这有助于证明投资的价值并指导未来的决策。本练习将实践从运营改进到量化收益的转化过程，具体来说，您将计算由文档记录时间缩短所带来的总工时节省和等效全职员工 (Full-Time Equivalent, FTE) 收益。掌握这种量化分析能力对于构建商业案例和评估健康 IT 项目的投资回报率至关重要。",
            "id": "4825823",
            "problem": "一个区域性门诊医疗网络在其电子健康记录 (EHR) 系统中实施了一项新的文档记录功能，这是一项旨在减轻临床医生负担和提高接诊能力的变更管理举措的一部分。在稳定采用后，直接观察研究证实，每次诊疗的平均病历记录时间减少了 $5$ 分钟，且未增加诊后工作量。该网络在稳定状态下每周进行 $1{,}000$ 次患者诊疗。假设以下基本事实和定义：\n\n- 节省的时间在独立诊疗中是可累加的，因此每周节省的总时间等于诊疗次数乘以每次诊疗节省的时间。\n- 分钟与小时的换算关系是 $60$ 分钟等于 $1$ 小时。\n- 一个全职等效 (FTE) 定义为每周 $40$ 小时。\n\n仅使用这些事实和定义，计算每周节省的总小时数所带来的生产力影响，然后通过将每周节省的小时数除以 FTE 每周小时数的定义，将此影响转化为节省的 FTE。以小时为单位表示生产力影响，并以无单位的 FTE 数量表示节省的 FTE。将两个结果都四舍五入到四位有效数字。按以下顺序提供您的最终结果：每周节省的小时数，节省的 FTE。",
            "solution": "该问题是有效的，因为它是自洽的，在应用健康信息学的背景下具有科学依据，并且在数学上是适定的。所有必要的数据、定义和关系都已提供，可以计算出唯一的解。\n\n设 $\\Delta t_{\\text{encounter}}$ 表示每次患者诊疗平均节省的时间， $N_{\\text{encounters}}$ 为每周的诊疗次数， $H_{\\text{FTE}}$ 为定义为一个全职等效 (FTE) 的每周工作小时数。问题提供了以下数值：\n$\\Delta t_{\\text{encounter}} = 5$ 分钟\n$N_{\\text{encounters}} = 1,000$ 次诊疗/周\n$H_{\\text{FTE}} = 40$ 小时/周\n\n分钟和小时之间的换算因子为 $60 \\text{ minutes} = 1 \\text{ hour}$。\n\n首先，我们计算每周节省的总时间。问题指出节省的时间是可累加的，因此每周节省的总时间（以分钟为单位），我们记为 $\\Delta T_{\\text{weekly, min}}$，是每周诊疗次数与每次诊疗节省时间的乘积。\n$$ \\Delta T_{\\text{weekly, min}} = N_{\\text{encounters}} \\times \\Delta t_{\\text{encounter}} $$\n代入给定值：\n$$ \\Delta T_{\\text{weekly, min}} = 1,000 \\times 5 = 5,000 \\text{ 分钟} $$\n\n接下来，我们必须将这个节省的总时间从分钟转换为小时。设 $\\Delta T_{\\text{weekly, hr}}$ 为每周节省的总时间（以小时为单位）。使用换算因子：\n$$ \\Delta T_{\\text{weekly, hr}} = \\frac{\\Delta T_{\\text{weekly, min}}}{60} $$\n$$ \\Delta T_{\\text{weekly, hr}} = \\frac{5,000}{60} \\text{ 小时} = \\frac{500}{6} \\text{ 小时} = \\frac{250}{3} \\text{ 小时} $$\n作为小数，该值为 $83.333\\overline{3}$ 小时。问题要求将此结果四舍五入到四位有效数字。\n$$ \\Delta T_{\\text{weekly, hr}} \\approx 83.33 \\text{ 小时} $$\n\n最后，我们计算节省的 FTE，记为 $S_{\\text{FTE}}$。这定义为每周节省的总小时数除以一个 FTE 的小时数。\n$$ S_{\\text{FTE}} = \\frac{\\Delta T_{\\text{weekly, hr}}}{H_{\\text{FTE}}} $$\n为在最终四舍五入步骤前保持精度，我们使用 $\\Delta T_{\\text{weekly, hr}}$ 的精确分数值：\n$$ S_{\\text{FTE}} = \\frac{\\frac{250}{3}}{40} = \\frac{250}{3 \\times 40} = \\frac{250}{120} = \\frac{25}{12} $$\n作为小数，该值为 $2.08333\\overline{3}$。问题要求将此结果四舍五入到四位有效数字。\n$$ S_{\\text{FTE}} \\approx 2.083 $$\n\n要求的两个值是每周节省的小时数和节省的 FTE，均四舍五入到四位有效数字。\n每周节省的小时数：$83.33$\n节省的 FTE：$2.083$",
            "answer": "$$ \\boxed{\\begin{pmatrix} 83.33  2.083 \\end{pmatrix}} $$"
        },
        {
            "introduction": "变革管理不仅仅是静态的计划和评估，更是一个动态的演进过程。本练习将引导您使用系统动力学建模，来模拟可用性改进和用户阻力等多种力量如何随时间相互作用，共同影响最终的工作流程效率。通过构建和运行一个简单的微分方程模型，您将能够探索复杂的“假设”情景，从而更深刻地理解变革的动态本质，并将理论概念与实用的编程模拟技能相结合。",
            "id": "4825784",
            "problem": "一家医院正在推行电子健康记录 (EHR) 系统，一个变更管理团队希望研究可用性改进和变革阻力如何随时间影响工作流程效率。考虑一个简单的系统动力学模型，其基础是净变化等于流入减去流出的原则：工作流程效率 $W(t)$ 的瞬时变化率是可用性改进信号 $U(t)$ 和阻力信号 $R(t)$ 的净效应，并由敏感度参数进行缩放。形式上，该模型由以下常微分方程 (ODE) 定义：$$\\frac{dW}{dt} = \\alpha U(t) - \\beta R(t),$$ 其中 $W(t)$ 是 $[0,1]$ 上的无单位归一化指数，$U(t)$ 是无单位的可用性改进指数，$R(t)$ 是无单位的阻力指数。参数 $\\alpha$ 和 $\\beta$ 是非负系数，单位为 $\\text{每天}$，分别量化了 $W(t)$ 对 $U(t)$ 和 $R(t)$ 的响应度。假设初始条件为 $W(0) = W_0$，并通过每次更新后对状态进行裁剪来施加物理约束 $W(t) \\in [0,1]$。\n\n使用均匀的时间步长 $\\Delta t$（单位：天），通过应用与导数定义一致的一阶有限差分，在有限的时间范围 $T$（单位：天）内对该 ODE 进行近似，然后在网格 $t_n = n \\Delta t$（其中 $n = 0, 1, \\dots, N$，$N \\Delta t = T$）上随时间推进 $W(t)$。最终关注的量是推行结束时的工作流程效率 $W(T)$，表示为无单位的小数，四舍五入到 $3$ 位小数。\n\n如下文所述，为每个测试用例将 $U(t)$ 和 $R(t)$ 定义为外生的随时间变化的信号。为了科学上的真实性，每个 $U(t)$ 和 $R(t)$ 的构建都反映了合理的变更管理模式：通过培训和迭代设计实现的可用性增量提升，以及因利益相关者参与而减小的阻力。\n\n单位和约束：\n- 时间 $t$ 以天为单位。\n- 参数 $\\alpha$ 和 $\\beta$ 的单位为 $\\text{每天}$。\n- 量 $W(t)$、$U(t)$ 和 $R(t)$ 是无单位的指数。\n- 每次更新后通过裁剪强制 $W(t) \\in [0,1]$。\n- 在最终输出中将 $W(T)$ 四舍五入到 $3$ 位小数。\n\n测试套件：\n- 案例 1 (可用性上升、阻力衰减的一般情况)：\n  - $\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.20$, $T = 90$, $\\Delta t = 1$。\n  - 可用性改进：$$U(t) = U_{\\text{base}} + \\frac{U_{\\text{amp}}}{1 + e^{-s (t - t_0)}}, \\quad U_{\\text{base}} = 0.30,\\ U_{\\text{amp}} = 0.50,\\ s = 0.10,\\ t_0 = 45.$$\n  - 阻力：$$R(t) = R_0 e^{-k t}, \\quad R_0 = 0.60,\\ k = 0.05.$$\n- 案例 2 (无可用性改进、阻力恒定的边界情况)：\n  - $\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.50$, $T = 30$, $\\Delta t = 1$。\n  - 可用性改进：$$U(t) = 0.$$\n  - 阻力：$$R(t) = 0.40.$$\n- 案例 3 (零阻力、可用性恒定的边缘情况)：\n  - $\\alpha = 0.08$, $\\beta = 0.00$, $W_0 = 0.10$, $T = 20$, $\\Delta t = 0.5$。\n  - 可用性改进：$$U(t) = 0.50.$$\n  - 阻力：$$R(t) = 0.$$\n- 案例 4 (早期高阻力加缓解措施以及线性可用性增长的压力情况)：\n  - $\\alpha = 0.05$, $\\beta = 0.07$, $W_0 = 0.40$, $T = 60$, $\\Delta t = 0.5$。\n  - 可用性改进 (在时间范围内线性增长)：$$U(t) = U_{\\min} + (U_{\\max} - U_{\\min}) \\frac{t}{T}, \\quad U_{\\min} = 0.20,\\ U_{\\max} = 0.70.$$\n  - 阻力 (在 $t_c$ 时进行分段缓解)：$$R(t) = \\begin{cases} R_0,  t  t_c \\\\ \\gamma R_0,  t \\ge t_c \\end{cases}, \\quad R_0 = 0.70,\\ \\gamma = 0.30,\\ t_c = 30.$$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含 4 个浮点数，分别对应案例 1 到案例 4 的 $W(T)$ 值，并四舍五入到 3 位小数。例如，输出格式如 $$[w_1,w_2,w_3,w_4]$$，其中每个 $w_i$ 是一个四舍五入到 3 位小数的十进制数，并且不打印任何其他文本。",
            "solution": "该问题提出了一个关于工作流程效率的系统动力学模型，需要进行数值求解。在进行求解之前，需要对问题陈述进行严格的验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n问题提供了以下信息：\n-   **控制方程**：关于工作流程效率 $W(t)$ 的常微分方程 (ODE)：\n    $$\\frac{dW}{dt} = \\alpha U(t) - \\beta R(t)$$\n-   **状态变量**：$W(t)$，一个无单位的归一化指数。\n-   **外生输入**：$U(t)$ (无单位的可用性改进指数) 和 $R(t)$ (无单位的阻力指数)。\n-   **参数**：$\\alpha, \\beta$ 是非负敏感度系数，单位为 $\\text{每天}$。\n-   **初始条件**：$W(0) = W_0$。\n-   **约束**：$W(t) \\in [0,1]$，通过每次更新后裁剪状态来强制执行。\n-   **数值方法**：在均匀时间网格 $t_n = n \\Delta t$（其中 $n = 0, 1, \\dots, N$，$N \\Delta t = T$）上的一阶有限差分近似。\n-   **关注量**：最终工作流程效率 $W(T)$，四舍五入到 3 位小数。\n-   **测试套件**：\n    -   **案例 1**：$\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.20$, $T = 90$, $\\Delta t = 1$。信号为 $U(t) = 0.30 + \\frac{0.50}{1 + e^{-0.10 (t - 45)}}$ 和 $R(t) = 0.60 e^{-0.05 t}$。\n    -   **案例 2**：$\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.50$, $T = 30$, $\\Delta t = 1$。信号为 $U(t) = 0$ 和 $R(t) = 0.40$。\n    -   **案例 3**：$\\alpha = 0.08$, $\\beta = 0.00$, $W_0 = 0.10$, $T = 20$, $\\Delta t = 0.5$。信号为 $U(t) = 0.50$ 和 $R(t) = 0$。\n    -   **案例 4**：$\\alpha = 0.05$, $\\beta = 0.07$, $W_0 = 0.40$, $T = 60$, $\\Delta t = 0.5$。信号为 $U(t) = 0.20 + (0.70 - 0.20) \\frac{t}{60}$ 和 $R(t) = \\begin{cases} 0.70,  t  30 \\\\ 0.30 \\times 0.70,  t \\ge 30 \\end{cases}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据以下验证标准对问题进行评估：\n-   **科学性**：该问题基于一阶线性常微分方程，这是数学建模和系统动力学中的一个基本工具。将其应用于建模变更管理动态，虽然是一种简化，但也是此类模型的合理应用。为输入信号选择的函数形式——逻辑斯谛、指数、线性和分段函数——都是标准的，并且对于表示所述现象是合理的。\n-   **适定性**：该问题是一个初值问题。控制 ODE 结合初始条件 $W(0) = W_0$ 构成了一个适定问题。要求使用特定方法（一阶有限差分）进行数值求解，并为每个案例提供了所有参数，这使得任务明确且可解。指定的算法确定了唯一的数值轨迹。\n-   **客观性**：该问题使用精确的数学语言和定义进行表述。所有量都有定义，任务的规定没有主观或基于意见的元素。\n-   **完整性和一致性**：每个测试用例都提供了所有必需的信息，包括参数、初始条件、时间范围、步长以及输入的函数形式。设置中没有矛盾之处。\n-   **可行性**：指定的数值模拟在计算上是易于处理的，并且需要标准的数值方法。约束是基于物理动机且明确定义的。\n\n**步骤 3：结论与行动**\n\n该问题具有科学性、适定性、客观性和完整性。判定为 **有效**。我们可以继续构建解决方案。\n\n### 解法推导\n\n问题的核心是数值求解一个非齐次一阶常微分方程。\n\n**1. 数值离散化**\n\n控制 ODE 为：\n$$ \\frac{dW}{dt} = \\alpha U(t) - \\beta R(t) $$\n问题指定了“与导数定义一致的一阶有限差分”。这意味着使用前向差分来近似在时间 $t_n$ 的导数 $\\frac{dW}{dt}$：\n$$ \\frac{dW}{dt} \\bigg|_{t=t_n} \\approx \\frac{W(t_{n+1}) - W(t_n)}{\\Delta t} $$\n其中 $t_{n+1} = t_n + \\Delta t$。令 $W_n = W(t_n)$。将此代入 ODE，得到前向欧拉法：\n$$ \\frac{W_{n+1} - W_n}{\\Delta t} = \\alpha U(t_n) - \\beta R(t_n) $$\n对 $W_{n+1}$ 进行整理，我们得到迭代更新规则：\n$$ W_{n+1} = W_n + \\Delta t \\left( \\alpha U(t_n) - \\beta R(t_n) \\right) $$\n\n**2. 状态约束 (裁剪)**\n\n问题施加了物理约束，即工作流程效率 $W(t)$ 必须保持在区间 $[0,1]$ 内。这在每个时间步之后强制执行。设 $W'_{n+1}$ 是通过欧拉步计算出的值：\n$$ W'_{n+1} = W_n + \\Delta t \\left( \\alpha U(t_n) - \\beta R(t_n) \\right) $$\n该步的最终值 $W_{n+1}$ 是通过将 $W'_{n+1}$ 裁剪到有效范围获得的：\n$$ W_{n+1} = \\max(0, \\min(1, W'_{n+1})) $$\n\n**3. 模拟算法**\n\n对于每个测试用例，我们将执行以下算法：\n1.  初始化参数 $\\alpha$、$\\beta$、$W_0$、$T$ 和 $\\Delta t$。\n2.  定义特定于案例的函数 $U(t)$ 和 $R(t)$。\n3.  计算总步数，$N = T / \\Delta t$。\n4.  初始化状态：$W = W_0$。\n5.  从 $n = 0$ 迭代到 $N-1$：\n    a. 计算当前时间 $t_n = n \\cdot \\Delta t$。\n    b. 评估信号 $U(t_n)$ 和 $R(t_n)$。\n    c. 计算该步内的效率变化：$\\Delta W = \\Delta t \\left( \\alpha U(t_n) - \\beta R(t_n) \\right)$。\n    d. 更新状态：$W \\leftarrow W + \\Delta W$。\n    e. 应用裁剪约束：$W \\leftarrow \\max(0, \\min(1, W))$。\n6.  该案例的结果是 $N$ 步后 $W$ 的最终值，对应于 $W(T)$。此最终值四舍五入到 3 位小数。\n\n该算法将为四个指定的测试用例中的每一个实现。\n\n**案例 1**：\n-   参数：$\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.20$, $T = 90$, $\\Delta t = 1$。\n-   $N = 90/1 = 90$ 步。\n-   $U(t) = 0.30 + 0.50 / (1 + e^{-0.10 (t - 45)})$\n-   $R(t) = 0.60 e^{-0.05 t}$\n\n**案例 2**：\n-   参数：$\\alpha = 0.06$, $\\beta = 0.04$, $W_0 = 0.50$, $T = 30$, $\\Delta t = 1$。\n-   $N = 30/1 = 30$ 步。\n-   $U(t) = 0$\n-   $R(t) = 0.40$\n-   更新规则简化为 $W_{n+1} = \\max(0, \\min(1, W_n + 1 \\cdot (0.06 \\cdot 0 - 0.04 \\cdot 0.40))) = \\max(0, \\min(1, W_n - 0.016))$。\n\n**案例 3**：\n-   参数：$\\alpha = 0.08$, $\\beta = 0.00$, $W_0 = 0.10$, $T = 20$, $\\Delta t = 0.5$。\n-   $N = 20/0.5 = 40$ 步。\n-   $U(t) = 0.50$\n-   $R(t) = 0$\n-   更新规则简化为 $W_{n+1} = \\max(0, \\min(1, W_n + 0.5 \\cdot (0.08 \\cdot 0.50 - 0))) = \\max(0, \\min(1, W_n + 0.02))$。\n\n**案例 4**：\n-   参数：$\\alpha = 0.05$, $\\beta = 0.07$, $W_0 = 0.40$, $T = 60$, $\\Delta t = 0.5$。\n-   $N = 60/0.5 = 120$ 步。\n-   $U(t) = 0.20 + (0.50) \\frac{t}{60}$\n-   $R(t) = \\begin{cases} 0.70  \\text{if } t  30 \\\\ 0.21  \\text{if } t \\ge 30 \\end{cases}$ (因为 $0.30 \\times 0.70 = 0.21$)。\n\n实现将遵循这种结构化方法。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs the workflow efficiency simulation for a given set of parameters.\n\n    Args:\n        params (dict): A dictionary containing all parameters for the simulation:\n            'alpha', 'beta', 'W0', 'T', 'dt', 'U_func', 'R_func'.\n\n    Returns:\n        float: The final workflow efficiency W(T), rounded to 3 decimals.\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    W0 = params['W0']\n    T = params['T']\n    dt = params['dt']\n    U_func = params['U_func']\n    R_func = params['R_func']\n\n    num_steps = int(T / dt)\n    W = W0\n    \n    for i in range(num_steps):\n        t = i * dt\n        \n        U_val = U_func(t)\n        R_val = R_func(t)\n        \n        # Forward Euler method step\n        dW_dt = alpha * U_val - beta * R_val\n        W_prime = W + dW_dt * dt\n        \n        # Apply clipping constraint\n        W = np.clip(W_prime, 0.0, 1.0)\n        \n    return round(W, 3)\n\ndef solve():\n    \"\"\"\n    Defines the four test cases and runs the simulation for each,\n    then prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general case with rising usability and decaying resistance)\n        {\n            'alpha': 0.06, 'beta': 0.04, 'W0': 0.20, 'T': 90, 'dt': 1,\n            'U_func': lambda t: 0.30 + 0.50 / (1 + np.exp(-0.10 * (t - 45))),\n            'R_func': lambda t: 0.60 * np.exp(-0.05 * t)\n        },\n        # Case 2 (boundary case with no usability improvements and constant resistance)\n        {\n            'alpha': 0.06, 'beta': 0.04, 'W0': 0.50, 'T': 30, 'dt': 1,\n            'U_func': lambda t: 0,\n            'R_func': lambda t: 0.40\n        },\n        # Case 3 (edge case with zero resistance and constant usability)\n        {\n            'alpha': 0.08, 'beta': 0.00, 'W0': 0.10, 'T': 20, 'dt': 0.5,\n            'U_func': lambda t: 0.50,\n            'R_func': lambda t: 0\n        },\n        # Case 4 (stress case with early high resistance and piecewise mitigation)\n        {\n            'alpha': 0.05, 'beta': 0.07, 'W0': 0.40, 'T': 60, 'dt': 0.5,\n            'U_func': lambda t: 0.20 + (0.70 - 0.20) * (t / 60),\n            'R_func': lambda t: 0.70 if t  30 else 0.70 * 0.30\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}