{
    "hands_on_practices": [
        {
            "introduction": "本练习是临床循证医学中的一项基本实践。贝叶斯定理为我们提供了一个正式的框架，用以根据新证据（检验结果）更新我们的信念（检验前概率），这正是诊断推理的精髓。通过这项实践，您将学会如何量化这一贯穿于临床诊疗过程中的关键认知任务 。",
            "id": "4859155",
            "problem": "在一次门诊中，一位临床医生考虑为一种疑似疾病安排一项二元诊断测试。在这次诊疗中，信息流从基于病史和检查的初步判断，发展到观察测试结果后的更新判断。设检验前概率为 $0.3$。该测试的灵敏度为 $0.8$，特异度为 $0.9$。仅使用灵敏度、特异度、概率、几率和贝叶斯定理的基本定义，确定患者在测试结果为阳性后的疾病检验后概率。将最终答案表示为 $0$ 到 $1$ 之间的小数，并四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确、客观，并包含使用既定的概率论原理得出唯一解所需的所有必要信息。\n\n任务是计算在测试结果为阳性的情况下，患者患有该疾病的检验后概率。这是贝叶斯定理的一个经典应用。我们首先正式定义事件和给定的概率。\n\n设 $D$ 为患者患有该疾病的事件。\n设 $D^c$ 为患者未患该疾病的事件。\n设 $T^+$ 为诊断测试结果为阳性的事件。\n设 $T^-$ 为诊断测试结果为阴性的事件。\n\n根据问题陈述，我们得到以下信息：\n1.  疾病的检验前概率为 $P(D) = 0.3$。\n2.  测试的灵敏度是指在患者患有疾病的情况下测试结果为阳性的概率。用我们的符号表示，即为 $P(T^+ | D) = 0.8$。\n3.  测试的特异度是指在患者未患疾病的情况下测试结果为阴性的概率。用我们的符号表示，即为 $P(T^- | D^c) = 0.9$。\n\n我们的目标是求出在测试结果为阳性时患病的检验后概率，记作 $P(D | T^+)$。\n\n根据贝叶斯定理，条件概率 $P(D | T^+)$ 可以表示为：\n$$\nP(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+)}\n$$\n\n分子包含已知的项：$P(T^+ | D) = 0.8$ 和 $P(D) = 0.3$。分母 $P(T^+)$ 是获得阳性测试结果的总概率。这可以使用全概率定律计算，该定律指出，一个事件的概率可以通过在一组互斥且完备的事件上对其条件概率求和来找到。在这种情况下，事件集合是 $\\{D, D^c\\}$。\n$$\nP(T^+) = P(T^+ | D) P(D) + P(T^+ | D^c) P(D^c)\n$$\n\n为了计算 $P(T^+)$，我们需要确定 $P(D^c)$ 和 $P(T^+ | D^c)$ 的值。\n\n未患病的概率 $P(D^c)$ 是患病概率 $P(D)$ 的补集：\n$$\nP(D^c) = 1 - P(D) = 1 - 0.3 = 0.7\n$$\n\n概率 $P(T^+ | D^c)$ 是在患者未患病的情况下测试结果为阳性的概率。这是假阳性率。它是特异度 $P(T^- | D^c)$ 的补集：\n$$\nP(T^+ | D^c) = 1 - P(T^- | D^c) = 1 - 0.9 = 0.1\n$$\n\n现在我们可以计算阳性测试的总概率 $P(T^+)$：\n$$\nP(T^+) = (P(T^+ | D) \\times P(D)) + (P(T^+ | D^c) \\times P(D^c))\n$$\n代入已知值：\n$$\nP(T^+) = (0.8 \\times 0.3) + (0.1 \\times 0.7)\n$$\n$$\nP(T^+) = 0.24 + 0.07 = 0.31\n$$\n\n在确定了所有部分之后，我们现在可以将它们代回贝叶斯定理中，以求得检验后概率 $P(D | T^+)$：\n$$\nP(D | T^+) = \\frac{P(T^+ | D) P(D)}{P(T^+)} = \\frac{0.8 \\times 0.3}{0.31}\n$$\n$$\nP(D | T^+) = \\frac{0.24}{0.31}\n$$\n\n为了得到最终的数值答案，我们进行除法运算：\n$$\nP(D | T^+) \\approx 0.774193548...\n$$\n\n题目要求答案以小数形式表示，并四舍五入到四位有效数字。\n$$\nP(D | T^+) \\approx 0.7742\n$$\n这就是患者在收到阳性测试结果后的疾病检验后概率。",
            "answer": "$$\n\\boxed{0.7742}\n$$"
        },
        {
            "introduction": "本练习将我们的视角从单个患者扩展到整个患者群体。现代电子健康记录（EHR）系统包含了海量数据，而从中提取有意义的临床见解，则需要将临床问题形式化为可计算的查询。这项实践将指导您如何构建一个概率模型，来估算满足复杂时间序列查询条件的患者群体规模，这是临床研究和医院运营中的一项核心技能 。",
            "id": "4859208",
            "problem": "您将获得一个针对因胸痛就诊并随后进行肌钙蛋白测量的患者的电子健康记录 (EHR) 临床诊疗形式化模型。我们感兴趣的临床查询是：“胸痛发作后 $6$ 小时内的首次肌钙蛋白升高。”您必须构建此查询的逻辑定义，并使用基于原则的概率推导，在指定的数据集特征下计算预期的结果计数。\n\n按如下方式，在患者级事件上以逻辑术语定义该查询。对于每位患者，设胸痛发作为时间 $t_0$ 的一个带时间戳的事件。设肌钙蛋白实验室结果为 $t_0$ 之后的时刻 $t_1, t_2, \\dots$ 的带时间戳的事件，每个事件都关联一个数值 $v(t_i)$（单位：纳克/升）和一个临床阈值 $\\tau$（单位：纳克/升），使得 $v(t_i) \\ge \\tau$ 表示肌钙蛋白升高。当且仅当满足 $v(t^\\star) \\ge \\tau$ 的最早时间 $t^\\star$ 满足 $t^\\star - t_0 \\le w$（窗口 $w = 6$ 小时）时，该查询对患者返回真，否则返回假。\n\n为计算满足查询条件的患者的预期数量，请使用以下数据集特征模型：\n- 每位患者以概率 $p_{\\mathrm{cp}} \\in [0,1]$ 属于胸痛队列，患者之间相互独立。\n- 以属于胸痛队列为条件，肌钙蛋白抽检在 $t_0$ 之后发生，遵循 $[0,\\infty)$ 上的均匀泊松过程 (homogeneous Poisson process)，其速率为每小时 $\\rho$ 个事件。等价地，在长度为 $x$ 小时的时间区间内，预期的抽检次数为 $\\rho x$，并且不相交区间内的计数是独立的。\n- 在时间 $t \\ge 0$ 的一次抽检结果为升高的概率是 $p_e(t) = 1 - e^{-\\beta t}$，其中 $\\beta \\ge 0$ 是一个上升参数（单位：每小时），用于模拟发病后随时间推移升高可能性增加的情况，并且抽检结果是否升高是根据其发生时间独立标记的。\n- 窗口长度为 $w = 6$ 小时，时间以小时为单位。\n\n仅使用此模型和概率论的第一性原理，推导出在一个大小为 $N$ 的队列中，查询返回真的患者预期数量，该数量是 $N, p_{\\mathrm{cp}}, \\rho, \\beta, w$ 的函数。您必须实现一个程序，为下面的测试套件中的每组参数计算此预期计数。该程序不得模拟数据，必须通过解析方法计算期望值。\n\n单位和输出规范：\n- 时间单位为小时，速率单位为每小时。\n- 最终的预期计数必须以十进制数（浮点数）输出。不要输出百分比。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，\"[x_1,x_2,x_3]\"），每个数字四舍五入到两位小数。\n\n测试套件（每个案例是一个元组 $(N, p_{\\mathrm{cp}}, \\rho, \\beta, w)$）：\n- 案例 A (正常路径): $(10000, 0.4, 0.5, 0.4, 6)$。\n- 案例 B (边界情况：无胸痛): $(20000, 0.0, 1.5, 0.8, 6)$。\n- 案例 C (近乎即时升高，中等抽检率): $(5000, 0.7, 1.0, 10.0, 6)$。\n- 案例 D (边界情况：零抽检率): $(8000, 0.5, 0.0, 0.5, 6)$。\n- 案例 E (边界情况：升高概率无增长): $(12000, 0.6, 0.3, 0.0, 6)$。\n\n您的任务：\n- 按照上述规范构建逻辑查询定义（查询本身无需代码输出，它是推导过程的一部分）。\n- 实现一个完整、可运行的程序，该程序使用解析推导来计算所有测试案例的预期计数，并以指定的确切格式打印它们。该程序不得接受任何输入。\n\n注意：推导必须从泊松过程 (Poisson processes) 和独立标记的基本定义开始，并且不得依赖未经第一性原理论证的快捷公式。",
            "solution": "目标是计算满足临床查询“胸痛发作后 $w=6$ 小时内首次肌钙蛋白升高”的患者预期数量 $E$。该计算将基于由参数 $N$（总患者数）、$p_{\\mathrm{cp}}$（属于胸痛队列的概率）、$\\rho$（肌钙蛋白抽检率）和 $\\beta$（升高上升参数）定义的概率模型。\n\n设 $S$ 为表示满足查询条件的患者总数的随机变量。我们可以将 $S$ 表示为指示随机变量的和，$S = \\sum_{k=1}^N I_k$，其中如果患者 $k$ 满足查询条件，则 $I_k=1$，否则 $I_k=0$。根据期望的线性性质，预期患者数为：\n$$E[S] = E\\left[\\sum_{k=1}^N I_k\\right] = \\sum_{k=1}^N E[I_k]$$\n由于每位患者都服从相同的概率模型，所以对于所有 $k$，$E[I_k]$ 都是相同的。设 $P(\\text{query true})$ 为随机选择的单个患者满足查询的概率。则 $E[I_k] = 1 \\cdot P(I_k=1) + 0 \\cdot P(I_k=0) = P(\\text{query true})$。因此，总的预期计数为：\n$$E = N \\cdot P(\\text{query true})$$\n\n为了求得 $P(\\text{query true})$，我们使用全概率定律，以患者是否属于胸痛队列（事件 $CP$）为条件。问题陈述，肌钙蛋白抽检仅对该队列中的患者进行。\n$$P(\\text{query true}) = P(\\text{query true} | CP) \\cdot P(CP) + P(\\text{query true} | \\neg CP) \\cdot P(\\neg CP)$$\n我们已知 $P(CP) = p_{\\mathrm{cp}}$。对于不属于胸痛队列 ($\\neg CP$) 的患者，不会进行肌钙蛋白抽检，因此不可能发现升高的肌钙蛋白。因此，对于此类患者，查询总是为假，这意味着 $P(\\text{query true} | \\neg CP) = 0$。方程简化为：\n$$P(\\text{query true}) = P(\\text{query true} | CP) \\cdot p_{\\mathrm{cp}}$$\n让我们记 $P_q = P(\\text{query true} | CP)$。如果在胸痛发作（时间 $t_0$，我们设为 $0$）后的窗口 $w$ 内，首次升高的肌钙蛋白出现在时间 $t^\\star$，则查询为真。这在逻辑上等价于在时间区间 $[0, w]$ 内至少有一次升高的肌钙蛋白抽检。计算其互补事件的概率通常更简单：在 $[0, w]$ 内没有升高的肌钙蛋白抽检。\n$$P_q = 1 - P(\\text{no elevated draws in } [0, w] | CP)$$\n\n问题陈述，对于 $CP$ 队列中的患者，肌钙蛋白抽检的发生遵循一个均匀泊松过程 (HPP)，其恒定速率为 $\\rho$（事件/小时）。在时间 $t$ 发生的每次抽检被独立地标记为“升高”的概率为 $p_e(t) = 1 - e^{-\\beta t}$。这种对 HPP 事件进行标记的过程称为稀疏化 (thinning)。由此产生的标记（升高）事件流形成一个非均匀泊松过程 (NHPP)，其速率函数 $\\lambda(t)$ 随时间变化。NHPP 的速率是原始 HPP 速率与标记概率的乘积：\n$$\\lambda(t) = \\rho \\cdot p_e(t) = \\rho (1 - e^{-\\beta t})$$\n对于一个 NHPP，在给定区间 $[a, b]$ 内的事件数 $k$ 服从泊松分布 (Poisson distribution)，其均值为 $\\Lambda = \\int_a^b \\lambda(t) dt$。对于我们的问题，区间是 $[0, w]$，因此升高的肌钙蛋白抽检的平均数量为 $\\Lambda_w$：\n$$\\Lambda_w = \\int_0^w \\lambda(t) dt = \\int_0^w \\rho (1 - e^{-\\beta t}) dt$$\n我们必须计算这个积分。\n\n情况 1：$\\beta > 0$\n$$\\Lambda_w = \\rho \\int_0^w (1 - e^{-\\beta t}) dt = \\rho \\left[ \\int_0^w 1 dt - \\int_0^w e^{-\\beta t} dt \\right]$$\n$$\\Lambda_w = \\rho \\left[ t - \\left(-\\frac{1}{\\beta} e^{-\\beta t}\\right) \\right]_0^w = \\rho \\left[ \\left(w + \\frac{1}{\\beta} e^{-\\beta w}\\right) - \\left(0 + \\frac{1}{\\beta} e^{-0}\\right) \\right]$$\n$$\\Lambda_w = \\rho \\left[ w + \\frac{1}{\\beta} e^{-\\beta w} - \\frac{1}{\\beta} \\right] = \\rho \\left[ w - \\frac{1}{\\beta} (1 - e^{-\\beta w}) \\right]$$\n\n情况 2：$\\beta = 0$\n如果 $\\beta = 0$，则在任何时间 $t$ 升高的概率为 $p_e(t) = 1 - e^0 = 0$。因此，升高的抽检率 $\\lambda(t) = \\rho \\cdot 0 = 0$。任何区间内升高的抽检的平均数量为 $\\Lambda_w = \\int_0^w 0 dt = 0$。\n\n在 $[0, w]$ 内升高的抽检次数服从均值为 $\\Lambda_w$ 的泊松分布。观察到 $k$ 个事件的概率为 $P(k) = \\frac{e^{-\\Lambda_w} \\Lambda_w^k}{k!}$。我们感兴趣的是零个事件 ($k=0$) 的概率：\n$$P(\\text{no elevated draws in } [0, w]) = \\frac{e^{-\\Lambda_w} \\Lambda_w^0}{0!} = e^{-\\Lambda_w}$$\n因此，对于胸痛队列中的患者，查询为真的概率是：\n$$P_q = 1 - P(\\text{no elevated draws in } [0, w]) = 1 - e^{-\\Lambda_w}$$\n综合所有部分，患者预期数量的最终表达式为：\n$$E = N \\cdot p_{\\mathrm{cp}} \\cdot P_q = N \\cdot p_{\\mathrm{cp}} \\cdot (1 - e^{-\\Lambda_w})$$\n\n代入 $\\Lambda_w$ 的表达式：\n- 如果 $\\beta > 0$：\n$$E = N \\cdot p_{\\mathrm{cp}} \\cdot \\left( 1 - \\exp\\left( -\\rho \\left[ w - \\frac{1}{\\beta} (1 - e^{-\\beta w}) \\right] \\right) \\right)$$\n- 如果 $\\beta = 0$：\n$\\Lambda_w = 0$，所以 $P_q = 1 - e^0 = 0$。这得出 $E = 0$。\n如果 $p_{\\mathrm{cp}}=0$ 或 $\\rho=0$，也会得到 $E=0$ 的相同结果，因为这分别意味着没有患者在队列中，或者没有进行抽检。推导出的公式与这些边界条件一致。\n这个解析公式将被实现，以计算给定测试套件的结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the expected number of patients satisfying the clinical query\n    for a suite of test cases based on an analytical derivation.\n    \"\"\"\n\n    # Test suite (each case is a tuple (N, p_cp, rho, beta, w))\n    test_cases = [\n        # Case A (happy path)\n        (10000, 0.4, 0.5, 0.4, 6),\n        # Case B (boundary: no chest pain)\n        (20000, 0.0, 1.5, 0.8, 6),\n        # Case C (near-immediate elevation, moderate draw rate)\n        (5000, 0.7, 1.0, 10.0, 6),\n        # Case D (boundary: zero draw rate)\n        (8000, 0.5, 0.0, 0.5, 6),\n        # Case E (boundary: no rise in elevation probability)\n        (12000, 0.6, 0.3, 0.0, 6),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, p_cp, rho, beta, w = case\n\n        # The expected count is 0 if no patients are in the chest pain cohort,\n        # or if the rate of troponin draws is zero.\n        if p_cp == 0.0 or rho == 0.0:\n            expected_count = 0.0\n        # If beta is 0, the probability of elevation is always 0.\n        elif beta == 0.0:\n            expected_count = 0.0\n        else:\n            # Calculate Lambda_w, the mean of the non-homogeneous Poisson process\n            # for elevated troponins over the interval [0, w].\n            # Lambda_w = rho * integral from 0 to w of (1 - exp(-beta*t)) dt\n            lambda_w = rho * (w - (1 / beta) * (1 - np.exp(-beta * w)))\n\n            # P_q is the probability of the query being true for a patient in the\n            # chest pain cohort, which is 1 - P(no elevated draws in [0, w]).\n            # P(no elevated draws) for a Poisson process with mean lambda_w is exp(-lambda_w).\n            p_q = 1 - np.exp(-lambda_w)\n\n            # The total expected number of patients is N * p_cp * P_q.\n            expected_count = N * p_cp * p_q\n        \n        results.append(f\"{expected_count:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "本练习聚焦于信息流动的最后一个关键环节：确保数据能在不同系统间被准确理解和使用。我们将介绍语义互操作性的概念，以及FHIR、LOINC和UCUM等标准在其中扮演的角色。这项实践将为您提供将原始临床数据映射为标准化、机器可读格式的动手经验，这是现代健康信息交换的基石 。",
            "id": "4859159",
            "problem": "您正在实现一个映射函数，该函数将临床诊疗过程中获得的血糖测量值编码为符合 Fast Healthcare Interoperability Resources (FHIR) Observation 标准的、具有语义互操作性的表示形式。您的推导和设计必须基于以下原则和定义：Logical Observation Identifiers Names and Codes (LOINC) 作为观察类型的标准化词汇系统的作用，用于单位的 Uniform Code for Units of Measure (UCUM)，以及 FHIR Observation 资源的语义，该语义要求 `code` 传达观察概念，`valueQuantity` 传达测量值和单位。此外，您必须使用摩尔质量的物理定义在物质的量浓度和质量浓度之间进行转换。具体而言，设 $M$ 表示 D-葡萄糖的摩尔质量，其中 $M = 180.15588$ 克/摩尔。物质的量浓度（单位：毫摩尔/升）与质量浓度（单位：毫克/分升）之间的单位转换源自基本单位关系。\n\n设计一个算法，对于在临床诊疗中收集的每个血糖观察值，给定一组输入：\n- 一个数值测量值 $v$，\n- 一个单位字符串 $u$（可能的值见下文测试套件），\n- 一个样本描述 $s$（例如，毛细血管血、静脉血浆），\n- 一个司法管辖区 $j$（美国或非美国），\n\n生成以下输出：\n- 一个以毫克/分升 (mg/dL) 表示的规范化血糖数值，四舍五入到 3 位小数，\n- 代表观察概念的所选 LOINC 代码的数字标识符，通过移除 LOINC 标识符中的连字符编码为整数（例如，LOINC $2339\\text{-}0$ 变为整数 23390），\n- 所选 FHIR 配置文件的数字标识符：当 $j$ 表示美国时，使用 1 代表 HL7 FHIR United States Core Observation Laboratory 配置文件；否则使用 2 代表 HL7 FHIR International Patient Summary (IPS) Observation results 配置文件。\n\n您的算法必须遵守基于上述原则的这些规则：\n1. 单位规范化至 UCUM：\n   - 将等于毫克/分升任何文本变体的 $u$ 解释为 UCUM mg/dL，并保持数值 $v$ 在 mg/dL 单位下不变。\n   - 将等于毫克/升的 $u$ 解释为 UCUM mg/L，并通过乘以 $0.1$ 转换为 mg/dL，使得 $v_{\\mathrm{mg/dL}} = 0.1 \\cdot v_{\\mathrm{mg/L}}$。\n   - 将等于毫摩尔/升的 $u$ 解释为 UCUM mmol/L，并使用摩尔质量定义转换为 mg/dL：$$v_{\\mathrm{mg/dL}} = \\frac{M}{10} \\cdot v_{\\mathrm{mmol/L}}$$$。这里 $M = 180.15588$ 克/摩尔，因子 $10$ 源于 $1\\,\\mathrm{L} = 10\\,\\mathrm{dL}$ 以及毫摩尔和毫克的定义。\n   - 将等于微摩尔/升的 $u$ 解释为 UCUM $\\mu$mol/L，首先通过除以 $1000$ 转换为 mmol/L，然后按上述方法处理，使得 $$v_{\\mathrm{mg/dL}} = \\frac{M}{10} \\cdot \\left(\\frac{v_{\\mu\\mathrm{mol}/\\mathrm{L}}}{1000}\\right)$$$。\n2. 根据观察语义和样本选择 LOINC 代码：\n   - 如果 $s$ 表示血清或血浆样本，则选择 LOINC $2345\\text{-}7$ (Glucose [Mass/volume] in Serum or Plasma)，编码为整数 23457。\n   - 否则，如果 $s$ 表示血液样本（包括毛细血管血），则：\n     - 如果单位是基于质量的（mg/dL 或 mg/L），选择 LOINC $2339\\text{-}0$ (Glucose [Mass/volume] in Blood)，编码为整数 23390。\n     - 如果单位是基于物质的量的（mmol/L 或 $\\mu$mol/L），选择 LOINC $15074\\text{-}8$ (Glucose [Moles/volume] in Blood)，编码为整数 150748。\n3. 选择 FHIR 配置文件以确保在司法管辖区级别的语义互操作性：\n   - 如果 $j$ 是美国，使用 HL7 FHIR United States Core Observation Laboratory 配置文件，编码为 1。\n   - 否则，使用 HL7 FHIR International Patient Summary (IPS) Observation results 配置文件，编码为 2。\n\n您的程序必须实现上述算法，并为以下测试套件生成结果。每个测试用例是一个元组 $(v, u, s, j)$：\n\n- 测试用例 A（正常路径，毛细血管血，基于质量，美国）：$(108, \"mg/dL\", \"capillary blood\", \"US\")$。预期进行质量归一化且无需转换，LOINC $2339\\text{-}0$，美国配置文件。\n- 测试用例 B（物质的量，血液，非美国）：$(5.6, \"mmol/L\", \"capillary blood\", \"EU\")$。预期使用 $M = 180.15588$ 从 mmol/L 转换为 mg/dL，LOINC $15074\\text{-}8$，IPS 配置文件。\n- 测试用例 C（血清/血浆，基于质量，输入单位 mg/L，美国）：$(900, \"mg/L\", \"venous plasma\", \"US\")$。预期从 mg/L 转换为 mg/dL，LOINC $2345\\text{-}7$，美国配置文件。\n- 测试用例 D（物质的量，单位微摩尔/升，血液，非美国）：$(5600, \"umol/L\", \"blood\", \"EU\")$。预期从 $\\mu$mol/L 转换为 mmol/L，然后再转换为 mg/dL，LOINC $15074\\text{-}8$，IPS 配置文件。\n- 测试用例 E（基于质量，使用 mg/dL 的文本变体，血液，美国）：$(65, \"mg per dl\", \"blood\", \"US\")$。预期归一化为 mg/dL 且数值不变，LOINC $2339\\text{-}0$，美国配置文件。\n\n您的程序应输出单行，其中包含一个结果列表，每个测试用例一个结果，每个结果是一个包含三个数字的列表，顺序为 [canonical_value_mg_per_dL, loinc_code_integer, profile_id_integer]。规范化值必须以 mg/dL 表示并四舍五入到 $3$ 位小数。最后一行必须以 Python 风格的列表的列表的精确格式打印，并用逗号分隔，例如：[[$a_1$, $b_1$, $c_1$],[$a_2$, $b_2$, $c_2$],...]。",
            "solution": "将临床血糖测量值映射到具有语义互操作性的 Fast Healthcare Interoperability Resources (FHIR) Observation 资源的问题是有效的。它在科学上基于医学信息学和化学的既定标准，问题提出得很好，具有清晰的输入和确定性的规则，并且其表述是客观的。解决方案需要设计一个算法来协调三个不同但相关的任务：单位规范化、概念编码和司法管辖区配置文件选择。该算法的设计基于语义互操作性的核心原则，特别是使用 Logical Observation Identifiers Names and Codes (LOINC) 表示观察概念，使用 Uniform Code for Units of Measure (UCUM) 表示定量值，以及使用 FHIR 标准来结构化数据。\n\n算法设计分为三个逻辑步骤，反映了问题陈述的要求。\n\n**步骤 1：规范化值和单位规范化**\n\n第一步是将由值 $v$ 和单位字符串 $u$ 组成的输入测量值转换为规范表示。问题将此规范形式指定为以质量浓度单位毫克/分升 ($\\text{mg/dL}$) 表示的数值，并四舍五入到 3 位小数。这种规范化对于标准化数据比较和解释至关重要，它遵循了 UCUM 为任何给定数量提供单一、明确表示的理念。\n\n转换逻辑取决于输入单位 $u$：\n- 如果输入单位 $u$ 是毫克/分升的文本变体（例如 `mg/dL`、`mg per dl`），则不需要进行数值转换。值 $v$ 已经是目标单位。算法将此归类为基于质量的单位。\n- 如果输入单位是毫克/升 ($\\text{mg/L}$)，则使用关系 $1\\,\\text{L} = 10\\,\\text{dL}$ 将其转换为 $\\text{mg/dL}$。这给出了转换公式：\n$$v_{\\text{mg/dL}} = v_{\\text{mg/L}} \\times \\frac{1\\,\\text{L}}{10\\,\\text{dL}} = 0.1 \\cdot v_{\\text{mg/L}}$$\n这也是一个基于质量的单位。\n- 如果输入单位是物质的量浓度，特别是毫摩尔/升 ($\\text{mmol/L}$)，转换为质量浓度需要 D-葡萄糖的摩尔质量，给定为 $M = 180.15588$ 克/摩尔。推导如下：\n$$v \\left[\\frac{\\text{mmol}}{\\text{L}}\\right] = v \\left[\\frac{10^{-3}\\,\\text{mol}}{\\text{L}}\\right]$$\n乘以摩尔质量 $M$ 将摩尔转换为克：\n$$v \\times M \\left[\\frac{10^{-3}\\,\\text{g}}{\\text{L}}\\right] = v \\times M \\left[\\frac{\\text{mg}}{\\text{L}}\\right]$$\n最后，将升转换为分升：\n$$v_{\\text{mg/dL}} = \\frac{v_{\\text{mmol/L}} \\times M}{10}$$\n算法正确地应用了这个公式：$v_{\\text{mg/dL}} = \\frac{M}{10} \\cdot v_{\\text{mmol/L}}$。这被归类为基于物质的量的单位。\n- 如果输入单位是微摩尔/升 ($\\text{µmol/L}$)，首先通过除以 $1000$ 将其转换为 $\\text{mmol/L}$，然后应用与上面相同的转换：\n$$v_{\\text{mg/dL}} = \\frac{M}{10} \\cdot \\left(\\frac{v_{\\text{µmol/L}}}{1000}\\right)$$\n这也是一个基于物质的量的单位。\n\n计算出的规范化值随后四舍五入到 3 位小数。一个指示原始单位是基于质量还是基于物质的量的标志被保留到下一步。\n\n**步骤 2：LOINC 代码选择**\n\n第二步是选择适当的 LOINC 代码。LOINC 为识别医学实验室观察提供了一个通用标准。一个 LOINC 代码精确定义了分析物（葡萄糖）、测量的属性（例如，质量浓度、摩尔浓度）和样本类型（例如，血液、血清、血浆）。算法选择代码的逻辑直接实现了这种语义结构。\n\n- 如果样本描述 $s$ 指示为血清或血浆（例如，\"venous plasma\"），则分析物系统是血清或血浆。所需的 LOINC 代码是 $2345\\text{-}7$ (\"Glucose [Mass/volume] in Serum or Plasma\")，这解释了所有值最终都规范化为质量浓度的原因。这被编码为整数 23457。\n- 如果样本 $s$ 是血液（例如，\"capillary blood\", \"blood\"），代码的选择取决于最初测量的属性，该属性已在步骤 1 中确定。\n    - 如果原始单位是基于质量的 ($\\text{mg/dL}$ 或 $\\text{mg/L}$)，则属性是质量浓度。正确的 LOINC 代码是 $2339\\text{-}0$ (\"Glucose [Mass/volume] in Blood\")，编码为 23390。\n    - 如果原始单位是基于物质的量的 ($\\text{mmol/L}$ 或 $\\text{µmol/L}$)，则属性是摩尔浓度。正确的 LOINC 代码是 $15074\\text{-}8$ (\"Glucose [Moles/volume] in Blood\")，编码为 150748。即使值本身已被规范化为 $\\text{mg/dL}$，这也正确地保留了测量的原始语义意图。在一个完整的 FHIR Observation 中，`valueQuantity` 将持有规范化后的值，而 `code` ($15074\\text{-}8$) 将表示原始测量是基于摩尔的。\n\n**步骤 3：FHIR 配置文件选择**\n\n最后一步是选择一个司法管辖区配置文件标识符。FHIR 配置文件为特定上下文（如国家医疗保健系统）调整基础 FHIR 资源，从而增强该领域内的互操作性。\n- 如果司法管辖区 $j$ 是美国 (\"US\")，算法选择 HL7 FHIR United States Core Observation Laboratory 配置文件，编码为整数 1。\n- 对于任何其他司法管辖区，它选择 HL7 FHIR International Patient Summary (IPS) Observation results 配置文件，这是一个更广泛的国际标准。这被编码为整数 2。\n\n这三个步骤被集成到一个单一函数中，该函数处理每个输入观察元组 $(v, u, s, j)$ 并生成所需的三元素输出列表，确保符合指定的信息学标准和科学原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process a list of test cases and print the results.\n    \"\"\"\n    \n    # Per the problem, M is the molar mass of D-Glucose in grams per mole.\n    M = 180.15588\n\n    # The test suite provided in the problem statement.\n    test_cases = [\n        # (v, u, s, j)\n        (108, \"mg/dL\", \"capillary blood\", \"US\"),\n        (5.6, \"mmol/L\", \"capillary blood\", \"EU\"),\n        (900, \"mg/L\", \"venous plasma\", \"US\"),\n        (5600, \"umol/L\", \"blood\", \"EU\"),\n        (65, \"mg per dl\", \"blood\", \"US\"),\n    ]\n\n    results = []\n    for v, u, s, j in test_cases:\n        result = process_observation(v, u, s, j, M)\n        results.append(result)\n\n    # The final print statement must produce the exact specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_observation(v, u, s, j, M):\n    \"\"\"\n    Applies the algorithm to a single blood glucose observation.\n\n    Args:\n        v (numeric): The measurement value.\n        u (str): The unit string.\n        s (str): The specimen description.\n        j (str): The jurisdiction code.\n        M (float): The molar mass of D-Glucose.\n\n    Returns:\n        list: A list containing [canonical_value_mg_per_dL, loinc_code_integer, profile_id_integer].\n    \"\"\"\n\n    # --- Rule 1: Unit normalization to UCUM and value conversion ---\n    # Normalize unit string for robust matching.\n    u_norm = u.lower().replace(\" \", \"\").replace(\"per\", \"/\")\n    \n    is_mass_based = False\n    canonical_value = 0.0\n\n    if u_norm in [\"mg/dl\"]:\n        canonical_value = float(v)\n        is_mass_based = True\n    elif u_norm == \"mg/l\":\n        # Convert mg/L to mg/dL: v_mg_per_dL = 0.1 * v_mg_per_L\n        canonical_value = 0.1 * v\n        is_mass_based = True\n    elif u_norm == \"mmol/l\":\n        # Convert mmol/L to mg/dL: v_mg_per_dL = (M / 10) * v_mmol_per_L\n        canonical_value = (M / 10.0) * v\n        is_mass_based = False\n    elif u_norm == \"umol/l\":\n        # Convert umol/L to mg/dL\n        canonical_value = (M / 10.0) * (v / 1000.0)\n        is_mass_based = False\n    \n    # Round the final canonical value to 3 decimal places.\n    canonical_value = round(canonical_value, 3)\n\n    # --- Rule 2: LOINC code selection from observation semantics ---\n    s_norm = s.lower()\n    loinc_code = 0\n\n    if \"serum\" in s_norm or \"plasma\" in s_norm:\n        # For serum or plasma, use LOINC 2345-7\n        loinc_code = 23457\n    elif \"blood\" in s_norm:\n        if is_mass_based:\n            # For blood with mass-based unit, use LOINC 2339-0\n            loinc_code = 23390\n        else: # Amount-of-substance-based\n            # For blood with mole-based unit, use LOINC 15074-8\n            loinc_code = 150748\n            \n    # --- Rule 3: FHIR profile selection based on jurisdiction ---\n    profile_id = 0\n    if j.upper() == \"US\":\n        # United States jurisdiction uses US Core profile\n        profile_id = 1\n    else:\n        # Other jurisdictions use IPS profile\n        profile_id = 2\n        \n    return [canonical_value, loinc_code, profile_id]\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}