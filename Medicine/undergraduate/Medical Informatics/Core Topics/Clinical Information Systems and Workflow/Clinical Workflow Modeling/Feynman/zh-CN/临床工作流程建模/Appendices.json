{
    "hands_on_practices": [
        {
            "introduction": "要改进临床工作流程，我们首先必须准确地理解其当前状态。流程挖掘提供了强大的技术，可以从医院信息系统生成的事件日志中自动发现工作流程模型。本练习  要求您将基础的 Alpha 挖掘算法应用于一个模拟真实世界的事件日志，不仅要发现流程，还要批判性地评估日志记录的不精确性如何导致模型与既定的临床规程相冲突。",
            "id": "4828733",
            "problem": "某医院急诊科的事件日志记录了临床活动，包含案例标识符、活动名称以及从案例开始计时的分钟时间戳。活动被编码为单个字母：$R$ (登记)、$T$ (分诊)、$V$ (生命体征测量)、$L$ (实验室检查医嘱)、$I$ (影像学检查)、$M$ (药物管理)、$D$ (出院)。相同的时间戳表示活动同时完成，由于日志记录分辨率的限制，其在案例内部的记录顺序是任意的。每个案例中记录的总顺序如下所示。共有 $6$ 个案例：\n\n- 案例 1：$R(0) \\rightarrow T(5) \\rightarrow V(5) \\rightarrow L(10) \\rightarrow I(12) \\rightarrow M(15) \\rightarrow D(30)$\n- 案例 2：$R(0) \\rightarrow V(4) \\rightarrow T(4) \\rightarrow I(8) \\rightarrow L(9) \\rightarrow M(14) \\rightarrow D(25)$\n- 案例 3：$R(0) \\rightarrow T(3) \\rightarrow V(3) \\rightarrow L(7) \\rightarrow M(13) \\rightarrow I(13) \\rightarrow D(22)$\n- 案例 4：$R(0) \\rightarrow T(2) \\rightarrow V(2) \\rightarrow I(6) \\rightarrow L(6) \\rightarrow M(12) \\rightarrow D(20)$\n- 案例 5：$R(0) \\rightarrow V(5) \\rightarrow T(5) \\rightarrow L(11) \\rightarrow I(11) \\rightarrow D(23)$\n- 案例 6：$R(0) \\rightarrow T(4) \\rightarrow V(4) \\rightarrow M(9) \\rightarrow L(9) \\rightarrow I(10) \\rightarrow D(21)$\n\n使用 Alpha 挖掘算法从事件日志中推导控制流关系。首先根据记录的序列构建直接跟随关系 $>$，然后根据 Alpha 挖掘算法的核心定义，将活动对 $(x,y)$ 分类为因果关系 $x \\rightarrow y$、并发关系 $x \\parallel y$ 或无关联关系 $x \\# y$。\n\n该急诊科的领域知识规定了以下优先约束：$R$ 必须在所有其他活动之前；$T$ 必须在 $V$ 之前；在 $V$ 之后，只有 $L$ 和 $I$ 可以进行，顺序不限且可以并发；$M$ 必须在 $L$ 和 $I$ 都发生之后才能发生；$D$ 是最后一个活动。\n\n计算被 Alpha 挖掘算法分类为并发关系 $x \\parallel y$ 但违反了所述领域优先约束的无序活动对的数量。请给出一个整数作为最终答案。",
            "solution": "目标是找出被 Alpha 挖掘算法分类为并发关系但违反了给定领域优先约束的无序活动对的数量。解决方案分三步进行：首先，我们将 Alpha 挖掘算法的定义应用于事件日志，以推导控制流关系；其次，我们找出所有被分类为并发的活动对；第三，我们将这些并发对与领域约束进行比较，以计算违规数量。\n\n事件日志中的唯一活动集合是 $A = \\{R, T, V, L, I, M, D\\}$。\n\n### 步骤 1：构建直接跟随关系 ($>$)\n\nAlpha 挖掘算法的基本构建块是直接跟随关系，表示为 $x > y$，当且仅当在事件日志中至少有一个案例序列中，活动 $x$ 紧随活动 $y$ 之后。我们检查所提供的 $6$ 个案例来填充这个关系。\n\n- 案例 1：得出 $R>T, T>V, V>L, L>I, I>M, M>D$。\n- 案例 2：得出 $R>V, V>T, T>I, I>L, L>M, M>D$。\n- 案例 3：得出 $R>T, T>V, V>L, L>M, M>I, I>D$。\n- 案例 4：得出 $R>T, T>V, V>I, I>L, L>M, M>D$。\n- 案例 5：得出 $R>V, V>T, T>L, L>I, I>D$。\n- 案例 6：得出 $R>T, T>V, V>M, M>L, L>I, I>D$。\n\n从日志中汇总所有唯一的直接跟随对，得到以下关系集：\n- 从 $R$：$R>T, R>V$\n- 从 $T$：$T>V, T>I, T>L$\n- 从 $V$：$V>T, V>L, V>I, V>M$\n- 从 $L$：$L>I, L>M$\n- 从 $I$：$I>M, I>L, I>D$\n- 从 $M$：$M>D, M>I, M>L$\n- 从 $D$：没有活动在 $D$ 之后。\n\n### 步骤 2：识别并发对 ($x \\parallel y$)\n\nAlpha 挖掘算法定义了任意两个不同活动 $x$ 和 $y$ 之间的三种关系：\n- **因果关系 ($x \\rightarrow y$)：** 如果 $x > y$ 且非 $y > x$。\n- **并发关系 ($x \\parallel y$)：** 如果 $x > y$ 且 $y > x$。\n- **无关联关系 ($x \\# y$)：** 如果非 $x > y$ 且非 $y > x$。\n\n我们感兴趣的是找出所有被分类为并发的无序对 $\\{x, y\\}$。我们必须找到所有同时满足 $x > y$ 和 $y > x$ 的活动对。通过检查步骤 1 中推导出的直接跟随关系：\n\n1.  对于活动对 $\\{T, V\\}$：\n    - $T>V$ 被观察到 (例如，在案例 1 中)。\n    - $V>T$ 被观察到 (例如，在案例 2 中)。\n    - 由于两个条件都满足，Alpha 挖掘算法将这对活动分类为并发：$T \\parallel V$。\n\n2.  对于活动对 $\\{L, I\\}$：\n    - $L>I$ 被观察到 (例如，在案例 1 中)。\n    - $I>L$ 被观察到 (例如，在案例 2 中)。\n    - 因此，这对活动被分类为并发：$L \\parallel I$。\n\n3.  对于活动对 $\\{L, M\\}$：\n    - $L>M$ 被观察到 (例如，在案例 2 中)。\n    - $M>L$ 被观察到 (例如，在案例 6 中)。\n    - 因此，这对活动被分类为并发：$L \\parallel M$。\n\n4.  对于活动对 $\\{I, M\\}$：\n    - $I>M$ 被观察到 (例如，在案例 1 中)。\n    - $M>I$ 被观察到 (例如，在案例 3 中)。\n    - 因此，这对活动被分类为并发：$I \\parallel M$。\n\n没有其他活动对满足并发条件。因此，Alpha 挖掘算法识别出恰好四个并发对：$\\{T,V\\}$、$\\{L,I\\}$、$\\{L,M\\}$ 和 $\\{I,M\\}$。\n\n### 步骤 3：将并发对与领域约束进行比较\n\n现在，我们根据指定的领域优先约束来评估这四个并发对中的每一个，以确定哪些分类是违规的。\n\n-   **领域约束：**\n    1.  $R$ 必须在所有其他活动之前。\n    2.  $T$ 必须在 $V$ 之前。\n    3.  在 $V$ 之后，只有 $L$ 和 $I$ 可以进行... 并且可以并发。\n    4.  $M$ 必须在 $L$ 和 $I$ 都发生之后才能发生。\n    5.  $D$ 是最后一个活动。\n\n-   **并发对的评估：**\n\n    1.  **活动对 $\\{T,V\\}$：**\n        -   Alpha 挖掘算法分类：$T \\parallel V$。\n        -   领域约束 2：“$T$ 必须在 $V$ 之前”。此约束强加了严格的因果依赖关系，即 $V$ 不能在 $T$ 之前。分类 $T \\parallel V$ 意味着序列 $V \\rightarrow T$ 是可能的（并且确实在日志中被观察到），这直接违反了此约束。\n\n    2.  **活动对 $\\{L,I\\}$：**\n        -   Alpha 挖掘算法分类：$L \\parallel I$。\n        -   领域约束 3：“...$L$ 和 $I$ 可以按任何顺序进行并且可以并发”。分类 $L \\parallel I$ 与此约束完全一致。\n\n    3.  **活动对 $\\{L,M\\}$：**\n        -   Alpha 挖掘算法分类：$L \\parallel M$。\n        -   领域约束 4：“$M$ 必须在 $L$ 和 $I$ 都发生之后才能发生”。这意味着 $L$ 必须始终在 $M$ 之前。分类 $L \\parallel M$ 意味着序列 $M \\rightarrow L$ 也是可能的（并且已被观察到），这违反了此约束。\n\n    4.  **活动对 $\\{I,M\\}$：**\n        -   Alpha 挖掘算法分类：$I \\parallel M$。\n        -   领域约束 4：“$M$ 必须在 $L$ 和 $I$ 都发生之后才能发生”。这意味着 $I$ 必须始终在 $M$ 之前。分类 $I \\parallel M$ 意味着序列 $M \\rightarrow I$ 也是可能的（并且已被观察到），这违反了此约束。\n\n### 结论\n\nAlpha 挖掘算法将四个活动对分类为并发。我们发现其中三个分类违反了所提供的领域知识：\n1.  $\\{T,V\\}$\n2.  $\\{L,M\\}$\n3.  $\\{I,M\\}$\n\n因此，被 Alpha 挖掘算法分类为并发但违反领域优先约束的无序活动对的总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在描绘出工作流程图后，下一个关键步骤是对其性能进行量化分析。本实践  介绍了排队论中一个出人意料地简单而强大的原则——利特尔法则（Little's Law），它将患者流量、等待时间与系统拥堵联系起来。通过将其应用于医院抽血区，您将学会在不需要复杂模拟的情况下，诊断瓶颈并理解患者流动的基本动态。",
            "id": "4828720",
            "problem": "一家大学医院的门诊抽血区在早晨的高峰时段以稳定状态运行数小时。设长期平均到达率用 $\\lambda$ 表示，患者在抽血区（从到达至离开，包括等待和抽血）花费的长期平均时间用 $W$ 表示。设实际在抽血区（等待或正在接受服务）的患者的长期时间平均数用 $L$ 表示。在稳定期间，测量得出 $\\lambda = 17$ 名患者/小时， $W = 19$ 分钟/名患者。使用流守恒和稳态时间平均的第一性原理，确定该抽血区的 $L$ 值。请以计数（患者数量）的形式表示您的答案，并将最终数值四舍五入至四位有效数字。\n\n此外，请解释连接长期时间平均占用数 $L$、长期平均到达率 $\\lambda$ 和长期平均系统逗留时间 $W$ 的基本原理，不使用任何快捷公式，并列举在此临床情境下该关系成立所需的最小假设。",
            "solution": "问题陈述已经过验证，被认为是合理的。这是一个基于排队论既定原则（特别是在临床工作流分析中的应用）的适定问题。所提供的数据是一致的，足以得到唯一解。\n\n问题要求做两件事：首先，在给定长期平均到达率 $\\lambda$ 和长期平均系统逗留时间 $W$ 的情况下，确定抽血区内患者的长期时间平均数 $L$。其次，要求从第一性原理出发解释这三个量之间的基本关系，并说明其有效性所需的最小假设。\n\n我们按照要求，首先从第一性原理推导这个关系。这个关系被称为利特尔法则（Little's Law），但我们将不直接引用其名称，而是进行推导。考虑一个时长为 $T$ 的长期观察期内的系统。\n\n设 $L(t)$ 为在时间 $t$ 抽血区内的患者数量。长期时间平均患者数 $L$ 定义为当 $T$ 趋于无穷大时，在区间 $[0, T]$ 上的时间平均的极限：\n$$L = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_0^T L(t) \\, dt$$\n积分 $\\int_0^T L(t) \\, dt$ 表示在该区间内系统中累积的总患者时间。例如，如果在 $\\Delta t = 2$ 小时内有 $L(t) = 5$ 名患者，则累积时间为 $10$ 患者-小时。\n\n我们也可以从单个患者的角度计算这个总累积患者时间。设 $A(T)$ 为在区间 $[0, T]$ 内到达的患者总数。长期平均到达率 $\\lambda$ 定义为：\n$$\\lambda = \\lim_{T \\to \\infty} \\frac{A(T)}{T}$$\n设 $W_i$ 为患者 $i$ 在系统中花费的总时间。在 $[0, T]$ 期间累积的总患者时间是在此区间内所有在系统中的患者花费时间的总和。对于一个大的 $T$，在一个稳定的系统（即患者数量不会无限增加的系统）中，在 $t=0$ 时已在场或在 $t=T$ 时仍在场的患者所贡献的时间相对于总量来说可以忽略不计。因此，总累积患者时间可以通过将在该区间内到达的所有患者的逗留时间相加来精确近似：\n$$\\int_0^T L(t) \\, dt \\approx \\sum_{i=1}^{A(T)} W_i$$\n当 $T \\to \\infty$ 时，这个近似在极限情况下变成等式。\n\n患者在系统中花费的长期平均时间 $W$ 是所有到达患者的个体时间 $W_i$ 的平均值：\n$$W = \\lim_{T \\to \\infty} \\frac{\\sum_{i=1}^{A(T)} W_i}{A(T)}$$\n现在，我们可以将这些定义结合起来。我们从 $L$ 的定义开始，并代入积分的替代表达式：\n$$L = \\lim_{T \\to \\infty} \\frac{1}{T} \\int_0^T L(t) \\, dt = \\lim_{T \\to \\infty} \\frac{1}{T} \\sum_{i=1}^{A(T)} W_i$$\n我们可以通过乘以和除以 $A(T)$ 来重写这个表达式：\n$$L = \\lim_{T \\to \\infty} \\left( \\frac{A(T)}{T} \\cdot \\frac{\\sum_{i=1}^{A(T)} W_i}{A(T)} \\right)$$\n由于 $\\lambda$ 和 $W$ 的极限存在，乘积的极限等于极限的乘积：\n$$L = \\left( \\lim_{T \\to \\infty} \\frac{A(T)}{T} \\right) \\left( \\lim_{T \\to \\infty} \\frac{\\sum_{i=1}^{A(T)} W_i}{A(T)} \\right)$$\n代入 $\\lambda$ 和 $W$ 的定义，我们得到基本关系：\n$$L = \\lambda W$$\n这个推导基于守恒原理：从时间积分角度看的总累积占用时间，必须等于从单个患者求和角度看的总占用时间。\n\n使此关系成立所需的最小假设非常通用：\n1.  **平均值的存在性**：定义 $\\lambda$、$W$ 和 $L$ 的极限必须存在且为有限值。问题陈述该系统在“稳定的早晨高峰条件下”运行，这意味着统计上的平稳性。\n2.  **流守恒**：系统必须是稳定的。这意味着长期平均到达率必须等于长期平均离开率。在这种情况下，这意味着进入抽血区的患者最终会离开，并且等待的患者数量不会无限增长。\n\n值得注意的是，该关系不依赖于到达或服务过程的具体概率分布、服务台（抽血师）的数量，或排队规则（例如，先入先出）。\n\n现在，我们将此关系应用于给定数据。\n给定的长期平均到达率为 $\\lambda = 17 \\text{ patients/hour}$。\n给定的长期平均系统逗留时间为 $W = 19 \\text{ minutes/patient}$。\n\n为了使用公式 $L = \\lambda W$，时间单位必须一致。我们将 $W$ 从分钟转换为小时。\n$$W = 19 \\text{ min} \\times \\frac{1 \\text{ hour}}{60 \\text{ min}} = \\frac{19}{60} \\text{ hours}$$\n现在我们可以计算 $L$：\n$$L = \\lambda W = \\left(17 \\frac{\\text{patients}}{\\text{hour}}\\right) \\times \\left(\\frac{19}{60} \\text{ hours}\\right)$$\n$$L = \\frac{17 \\times 19}{60} \\text{ patients} = \\frac{323}{60} \\text{ patients}$$\n其数值为：\n$$L = 5.38333... \\text{ patients}$$\n问题要求答案四舍五入至四位有效数字。\n$$L \\approx 5.383 \\text{ patients}$$\n该值表示在稳定的高峰时段内，实际在抽血区（等待或正在抽血）的患者的时间平均数。",
            "answer": "$$\n\\boxed{5.383}\n$$"
        },
        {
            "introduction": "有效的工作流程管理往往取决于关键资源的优化配置，例如技能熟练的临床人员。这个问题  将引导您应对医院运营中的一个核心挑战：护士排班。您将学习如何将复杂的操作规则（如循环班次和技能组合要求）转化为一个精确的数学模型，以找到一个能最小化人员缺口并确保持续提供优质患者护理的最佳排班方案。",
            "id": "4828757",
            "problem": "您正在临床工作流建模领域内，为一个临床护士排班子问题设计一个数学上精确的模型。该场景涉及医院科室中常见的循环班次和技能组合约束，人员由注册护士 (RN) 和执业护士 (LPN) 组成。您的任务是根据运筹学的核心定义，将此问题形式化为一个整数线性规划 (ILP) 问题，并实现一个程序，为提供的测试套件计算最优目标值。\n\n从以下基本原则和定义出发：分配守恒（在规划周期内，每位护士仅有一个起始班次）、循环排班概念（班次安排在几天内以固定顺序重复），以及覆盖约束（捕捉每个班次和每天按技能类别所需的最低人员配备）。使用绝对偏差的标准定义来量化所提供的人员配备与所需人员配备之间的不匹配，并将问题设定为最小化所有日-班次-技能单元的绝对偏差之和。不要假设任何专门的护士排班捷径；从这些通用原则推导出公式。\n\n临床工作流模型假设：\n- 时间范围为 $T = 3$ 个连续日，索引为 $t \\in \\{0,1,2\\}$。\n- 每天有 $S = 3$ 个班次，索引为 $s \\in \\{0,1,2\\}$，分别对应白班 ($s=0$)、晚班 ($s=1$) 和夜班 ($s=2$)。\n- 有 $K = 2$ 种技能类别：注册护士 (RN) 和执业护士 (LPN)。在程序中，将 RN 编码为 $k=0$，LPN 编码为 $k=1$。\n- 循环班次规则定义如下：如果一名护士在第 $t=0$ 天的初始班次是 $r \\in \\{0,1,2\\}$，那么该护士在第 $t$ 天的班次是 $(r + t) \\bmod 3$。这强制实施了跨连续日的白班 $\\rightarrow$ 晚班 $\\rightarrow$ 夜班的循环轮换。\n- 技能组合覆盖约束要求，对于每一天 $t$ 和每一个班次 $s$，所分配的 RN 和 LPN 护士数量应尽可能接近所需数量，即最小化绝对偏差之和。\n\n待建模的决策概念：\n- 为每位护士 $n$ 选择一个在第 $t=0$ 天的单一初始班次 $r \\in \\{0,1,2\\}$。循环规则根据所选的初始班次确定性地决定该护士在第 $t=1$ 天和第 $t=2$ 天的班次。使用二进制决策来编码此选择。\n- 对于每个日-班次-技能三元组 $(t,s,k)$，定义非负偏差变量，以便测量实际覆盖与所需覆盖之间的绝对差异。\n\n目标（待推导和实现）：最小化所有 $(t,s,k)$ 上的绝对偏差总和。\n\n约束（待推导和实现）：\n- 为每位护士选择且仅选择一个初始班次。\n- 每个 $(t,s,k)$ 的实际覆盖由初始班次的循环传播和护士技能类型计算得出，并且偏差的测量方式能够在目标函数中产生绝对差值。所有约束必须是线性的。\n\n测试套件：\n实现您的程序以解决以下三个实例。在所有情况下，$T=3$ 天，每天 $S=3$ 个班次，并遵循所定义的循环规则。\n\n- 案例 A（均衡、旋转不变的需求；预期可精确满足）：\n  - $N=6$ 名护士，技能为 $[0,0,0,1,1,1]$，其中 $0$ 表示 RN，$1$ 表示 LPN。\n  - 对于每一天 $t \\in \\{0,1,2\\}$ 和每一个班次 $s \\in \\{0,1,2\\}$，所需的 RN 数量为 $1$，所需的 LPN 数量为 $1$。\n\n- 案例 B（总人数不足；预期有不可避免的偏差）：\n  - $N=5$ 名护士，技能为 $[0,0,0,1,1]$。\n  - 对于每一天 $t \\in \\{0,1,2\\}$ 和每一个班次 $s \\in \\{0,1,2\\}$，所需的 RN 数量为 $1$，所需的 LPN 数量为 $1$。\n\n- 案例 C（供应与每日总数匹配，但需求不具有旋转不变性；预期有偏差）：\n  - $N=6$ 名护士，技能为 $[0,0,0,0,1,1]$。\n  - 对于每一天 $t \\in \\{0,1,2\\}$，按班次所需的人数为：\n    - 白班 $s=0$：RN $2$，LPN $0$。\n    - 晚班 $s=1$：RN $1$，LPN $1$。\n    - 夜班 $s=2$：RN $1$，LPN $1$。\n\n程序要求：\n- 使用整数线性规划或一种能为这些特定实例证明达到相同最优解的启发式算法来制定和求解每个案例。模型必须严格执行循环班次规则。\n- 每个案例的目标是一个单一实数：所有 $(t,s,k)$ 上可能的最小绝对偏差总和。\n- 您的程序必须生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 [案例 A, 案例 B, 案例 C]，每个数字四舍五入到两位小数，例如，\"[0.00,3.00,8.00]\"。\n- 程序不应需要用户输入；所有数据必须从上述测试套件中硬编码。\n\n交付物：\n- 一个完整的、可运行的程序，能够完全按照规定计算所需输出。",
            "solution": "用户提供了一个临床护士排班问题，需要将其建模并作为优化问题求解。核心任务是确定护士到循环班次模式的最优分配，以最小化与指定人员配备需求的总偏差。\n\n### 问题验证\n\n根据指定标准对问题陈述进行评估。\n\n-   **已知条件**：\n    -   时间范围 $T=3$ 天, $t \\in \\{0,1,2\\}$。\n    -   每天 $S=3$ 个班次, $s \\in \\{0,1,2\\}$。\n    -   技能 $K=2$ 种：RN ($k=0$)，LPN ($k=1$)。\n    -   循环班次规则：第 $t=0$ 天的初始班次为 $r$，则第 $t$ 天的班次为 $(r+t) \\pmod 3$。\n    -   目标：最小化实际覆盖与所需覆盖之间的绝对偏差总和。\n    -   决策：为每位护士分配一个初始班次 $r \\in \\{0,1,2\\}$。\n    -   测试案例：\n        -   **案例 A**：$N=6$ 名护士，技能为 $[0,0,0,1,1,1]$，所有日-班次对的需求均为 $1$ 名 RN 和 $1$ 名 LPN。\n        -   **案例 B**：$N=5$ 名护士，技能为 $[0,0,0,1,1]$，所有日-班次对的需求均为 $1$ 名 RN 和 $1$ 名 LPN。\n        -   **案例 C**：$N=6$ 名护士，技能为 $[0,0,0,0,1,1]$，每日需求为白班 ($s=0$)：$2$ RN，$0$ LPN；晚班 ($s=1$)：$1$ RN，$1$ LPN；夜班 ($s=2$)：$1$ RN，$1$ LPN。\n\n-   **验证结论**：\n    -   该问题在**科学上基于**运筹学和整数线性规划，这些是排班问题的标准工具。\n    -   该问题是**良构的**，为每个测试案例提供了清晰的目标函数和一套完整、一致的约束和数据。\n    -   该问题是**客观的**，使用了精确的数学和逻辑语言。\n    -   该问题没有缺陷；它是一个有效的、可解的优化问题。\n\n### 问题形式化表述\n\n我们首先将问题形式化为整数线性规划 (ILP)。\n\n**1. 索引和集合：**\n-   $n \\in \\{0, 1, \\dots, N-1\\}$：护士集合。\n-   $t \\in \\{0, 1, 2\\}$：天数集合。\n-   $s \\in \\{0, 1, 2\\}$：班次集合。\n-   $r \\in \\{0, 1, 2\\}$：第 $t=0$ 天的初始班次集合。\n-   $k \\in \\{0, 1\\}$：技能集合 (RN, LPN)。\n\n**2. 参数：**\n-   $N$：护士总数。\n-   $S_{nk}$：一个二进制参数，如果护士 $n$ 拥有技能 $k$，则为 $1$，否则为 $0$。对于此问题，我们给出了一个更简单的技能列表，可以将其预处理为此形式。\n-   $R_{tsk}$：第 $t$ 天、第 $s$ 班次所需的拥有技能 $k$ 的护士数量。\n\n**3. 决策变量：**\n-   $x_{nr} \\in \\{0, 1\\}$：一个二进制变量，如果护士 $n$ 被分配到初始班次 $r$，则为 $1$，否则为 $0$。\n-   $u_{tsk}^+ \\ge 0$：一个连续变量，表示在第 $t$ 天、第 $s$ 班次，技能 $k$ 的超额覆盖（盈余）。\n-   $u_{tsk}^- \\ge 0$：一个连续变量，表示在第 $t$ 天、第 $s$ 班次，技能 $k$ 的短缺覆盖（短缺）。\n\n**4. 目标函数：**\n目标是最小化绝对偏差之和。这通过最小化盈余和短缺变量之和来实现线性化。\n$$ \\min Z = \\sum_{t=0}^{2} \\sum_{s=0}^{2} \\sum_{k=0}^{1} (u_{tsk}^+ + u_{tsk}^-) $$\n\n**5. 约束：**\n-   **分配约束**：每位护士必须被分配到且仅分配到一个初始班次模式。\n    $$ \\sum_{r=0}^{2} x_{nr} = 1 \\quad \\forall n \\in \\{0, \\dots, N-1\\} $$\n-   **覆盖与偏差约束**：此约束将护士分配与人员配备水平及其与需求的偏差联系起来。在第 $t$ 天、第 $s$ 班次，拥有技能 $k$ 的护士数量是那些初始班次 $r$ 循环导致在第 $t$ 天为班次 $s$ 的护士总和。这在 $r = (s-t) \\pmod 3$ 时发生。\n    $$ \\sum_{n=0}^{N-1} S_{nk} \\cdot x_{n, (s-t+3) \\pmod 3} - u_{tsk}^+ + u_{tsk}^- = R_{tsk} \\quad \\forall t, s, k $$\n-   **变量域**：\n    $$ x_{nr} \\in \\{0, 1\\} \\quad \\forall n, r $$\n    $$ u_{tsk}^+ \\ge 0, \\quad u_{tsk}^- \\ge 0 \\quad \\forall t, s, k $$\n\n### 求解策略\n\n问题规范要求使用标准的 Python 库（`numpy`, `scipy`）来求解，这些库不包含 ILP 求解器。然而，问题实例很小，最大案例中只有 $N=6$ 名护士。将初始班次分配给护士的总独特分配数为 $3^N$。对于 $N=6$，这是 $3^6 = 729$，这个数字小到足以进行穷举搜索（暴力搜索）。暴力搜索方法保证能找到全局最优解，因此满足问题对可证明最优解的要求。\n\n可以对暴力搜索方法进行优化。在计算覆盖率时，具有相同技能的护士是无法区分的。因此，问题简化为找到每种技能的护士总数 ($N_k$) 在三个初始班次模式 ($r=0, 1, 2$) 中的最优分布。\n\n令 $n_{kr}$ 为分配到初始班次 $r$ 的拥有技能 $k$ 的护士数量。我们需要找到满足以下条件的整数划分：\n$$ \\sum_{r=0}^{2} n_{kr} = N_k \\quad \\forall k \\in \\{0, 1\\} $$\n这类划分的数量远小于 $3^N$。对于每种划分组合（每种技能一个），我们可以计算总偏差并找到最小值。\n\n### 算法\n所实现的算法遵循这种优化的暴力搜索策略：\n1.  对于每个测试案例，定义护士数量 $N$、他们的技能以及需求矩阵 $R_{tsk}$。\n2.  确定每种技能的护士总数，$N_0$ (RN) 和 $N_1$ (LPN)。\n3.  生成 $N_0$ 到三个非负整数 $(n_{00}, n_{01}, n_{02})$ 的所有可能整数划分。每个三元组分别代表开始于班次 $0, 1, 2$ 的 RN 数量。\n4.  同样地，为 LPN 生成 $N_1$ 到 $(n_{10}, n_{11}, n_{12})$ 的所有划分。\n5.  遍历 RN 划分和 LPN 划分的每一种组合。每个组合代表一个完整的初始分配方案。\n6.  对于每个分配方案，计算 $T=3$ 天规划周期内的总偏差：\n    a.  将此方案的总偏差初始化为 $0$。\n    b.  对于每一天 $t \\in \\{0, 1, 2\\}$ 和每个班次 $s \\in \\{0, 1, 2\\}$：\n        i.  确定源初始班次组 $r' = (s-t+3) \\pmod 3$。\n        ii. 分配的 RN 数量为 $n_{0,r'}$，分配的 LPN 数量为 $n_{1,r'}$。\n        iii. 计算 RN 的绝对偏差：$|n_{0,r'} - R_{ts0}|$。\n        iv. 计算 LPN 的绝对偏差：$|n_{1,r'} - R_{ts1}|$。\n        v.  将这些偏差加到方案的总偏差中。\n7.  记录在所有分配方案中找到的最小总偏差。这个最小值是该测试案例的最优解。\n8.  收集所有三个案例的最优值，并按规定格式化输出。",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Solves the nurse rostering problem for three specified cases by finding\n    the assignment that minimizes total deviation from staffing requirements.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n\n    # Case A: Balanced, rotation-invariant requirements\n    skills_A = [0, 0, 0, 1, 1, 1]  # 3 RN, 3 LPN\n    reqs_A = np.ones((3, 3, 2), dtype=int)  # 1 RN, 1 LPN everywhere\n\n    # Case B: Insufficient total headcount\n    skills_B = [0, 0, 0, 1, 1]  # 3 RN, 2 LPN\n    reqs_B = np.ones((3, 3, 2), dtype=int)  # 1 RN, 1 LPN everywhere\n\n    # Case C: Supply matches daily totals but requirements are not rotation-invariant\n    skills_C = [0, 0, 0, 0, 1, 1]  # 4 RN, 2 LPN\n    reqs_C = np.zeros((3, 3, 2), dtype=int)\n    for t in range(3):\n        reqs_C[t, 0, 0] = 2  # Day shift: 2 RN, 0 LPN\n        reqs_C[t, 0, 1] = 0\n        reqs_C[t, 1, 0] = 1  # Eve shift: 1 RN, 1 LPN\n        reqs_C[t, 1, 1] = 1\n        reqs_C[t, 2, 0] = 1  # Night shift: 1 RN, 1 LPN\n        reqs_C[t, 2, 1] = 1\n\n    test_cases = [\n        {\"skills\": skills_A, \"requirements\": reqs_A},\n        {\"skills\": skills_B, \"requirements\": reqs_B},\n        {\"skills\": skills_C, \"requirements\": reqs_C},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        skills = case[\"skills\"]\n        requirements = case[\"requirements\"]\n        \n        num_nurses = len(skills)\n        num_skills = 2 # 0: RN, 1: LPN\n        num_shifts = 3\n        num_days = 3\n\n        # Count nurses per skill\n        nurses_per_skill = np.zeros(num_skills, dtype=int)\n        for skill_idx in skills:\n            nurses_per_skill[skill_idx] += 1\n\n        def get_partitions(n_items, k_bins):\n            \"\"\"Generates all partitions of n_items into k_bins.\"\"\"\n            if k_bins == 1:\n                yield (n_items,)\n                return\n            for i in range(n_items + 1):\n                for sub_partition in get_partitions(n_items - i, k_bins - 1):\n                    yield (i,) + sub_partition\n        \n        # Generate all possible ways to assign nurses of each skill to initial shifts\n        rn_partitions = list(get_partitions(nurses_per_skill[0], num_shifts))\n        lpn_partitions = list(get_partitions(nurses_per_skill[1], num_shifts))\n\n        min_total_deviation = float('inf')\n\n        # Iterate over all combinations of skill partitions\n        for rn_part, lpn_part in product(rn_partitions, lpn_partitions):\n            # rn_part = (num_rn_start_s0, num_rn_start_s1, num_rn_start_s2)\n            # lpn_part = (num_lpn_start_s0, num_lpn_start_s1, num_lpn_start_s2)\n            \n            initial_assignment_counts = np.array([rn_part, lpn_part]).T\n            # Shape: (num_shifts, num_skills). E.g., initial_assignment_counts[r, k]\n            \n            current_total_deviation = 0\n            \n            # Calculate coverage and deviation for this assignment\n            assigned_coverage = np.zeros_like(requirements)\n            for t in range(num_days):\n                for s in range(num_shifts):\n                    # The group of nurses working shift s on day t started on shift r'\n                    r_prime = (s - t + num_shifts) % num_shifts\n                    assigned_coverage[t, s, 0] = initial_assignment_counts[r_prime, 0] # RNs\n                    assigned_coverage[t, s, 1] = initial_assignment_counts[r_prime, 1] # LPNs\n            \n            deviation_matrix = np.abs(assigned_coverage - requirements)\n            current_total_deviation = np.sum(deviation_matrix)\n            \n            if current_total_deviation  min_total_deviation:\n                min_total_deviation = current_total_deviation\n        \n        results.append(min_total_deviation)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.2f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}