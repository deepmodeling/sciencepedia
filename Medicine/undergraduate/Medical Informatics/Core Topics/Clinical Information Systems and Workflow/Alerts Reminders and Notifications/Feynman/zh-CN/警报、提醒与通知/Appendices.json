{
    "hands_on_practices": [
        {
            "introduction": "临床警报的有效性并不仅仅取决于其技术上的灵敏度。本练习将引导你运用贝叶斯定理，揭示当某种疾病的基准率（患病率）较低时，即使警报系统具有很高的灵敏度和特异性，其阳性预测值（PPV）也可能出人意料地低。通过这个计算，你将从数学上理解临床实践中普遍存在的“警报疲劳”现象的根本原因。",
            "id": "4822027",
            "problem": "一家医院在其电子健康记录 (EHR) 系统中部署了一个临床决策支持 (CDS) 警报，用于通知临床医生存在一种潜在可干预的状况，记为 $D$。在筛查人群中，$D$ 的基础率（患病率）为 $P(D)=0.05$。该警报的灵敏度为 $0.9$，特异度为 $0.8$。灵敏度定义为在患者确实患有 $D$ 的情况下警报触发的概率，特异度定义为在患者没有患有 $D$ 的情况下警报不触发的概率。使用基本概率定义和贝叶斯定理，计算阳性预测值 (PPV)，其定义为在警报触发的情况下患者确实患有 $D$ 的概率。将 PPV 表示为四舍五入到四位有效数字的小数。计算出 PPV 后，请基于基本原理，用文字解释该值对于临床实践中感知到的警报可靠性以及警报疲劳的可能性意味着什么。你的最终数值答案必须仅为 PPV 值（无单位）。",
            "solution": "该问题要求计算一个临床决策支持 (CDS) 警报的阳性预测值 (PPV)，并解释其含义。该问题提法明確，在概率论和医学信息学方面有科学依据，并包含了得出唯一解所需的所有信息。\n\n首先，我们必须使用标准概率符号将给定信息形式化。设 $D$ 为患者患有该状况的事件，设 $A$ 为 CDS 警报触发的事件。互补事件为 $D^c$（患者没有该状况）和 $A^c$（警报不触发）。\n\n给定条件如下：\n1.  该状况的基础率或患病率：$P(D) = 0.05$。\n2.  警报的灵敏度，即患者患有该状况时警报触发的概率：$P(A|D) = 0.9$。\n3.  警报的特异度，即患者没有该状况时警报不触发的概率：$P(A^c|D^c) = 0.8$。\n\n从这些给定条件中，我们可以推导出计算所需的两个额外概率。\n患者没有该状况的概率是患病率的补集：\n$$P(D^c) = 1 - P(D) = 1 - 0.05 = 0.95$$\n在患者没有该状况的情况下警报触发的概率（即假阳性率）是特异度的补集：\n$$P(A|D^c) = 1 - P(A^c|D^c) = 1 - 0.8 = 0.2$$\n\n问题要求我们计算阳性预测值 (PPV)，它被定义为在警报已触发 ($A$) 的情况下，患者确实患有该状况 ($D$) 的概率。用概率术语来说，我们需要计算 $P(D|A)$。\n\n我们将使用贝叶斯定理来求这个条件概率：\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A)}$$\n\n分母 $P(A)$ 代表警报触发的总概率。它可以使用全概率定律计算，即对患有该状况的患者（真阳性）和没有该状况的患者（假阳性）警报触发的概率求和：\n$$P(A) = P(A \\cap D) + P(A \\cap D^c)$$\n使用条件概率的定义 $P(X \\cap Y) = P(X|Y)P(Y)$，我们可以将其展开为：\n$$P(A) = P(A|D)P(D) + P(A|D^c)P(D^c)$$\n\n将此展开式代回贝叶斯定理，得到 PPV 的完整公式：\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A|D)P(D) + P(A|D^c)P(D^c)}$$\n\n现在，我们可以将数值代入此公式。\n分子是真阳性事件（患者患有该状况且警报触发）的概率：\n$$\\text{Numerator} = P(A|D)P(D) = (0.9) \\times (0.05) = 0.045$$\n分母中的第一项与分子相同：\n$$P(A|D)P(D) = 0.045$$\n分母中的第二项是假阳性事件（患者没有该状况且警报触发）的概率：\n$$P(A|D^c)P(D^c) = (0.2) \\times (0.95) = 0.190$$\n警报触发的总概率是这两项之和：\n$$P(A) = 0.045 + 0.190 = 0.235$$\n最后，我们可以计算 PPV：\n$$P(D|A) = \\frac{0.045}{0.235} \\approx 0.19148936...$$\n\n问题要求结果四舍五入到四位有效数字。\n$$PPV \\approx 0.1915$$\n\n计算出的阳性预测值为 $0.1915$。这个值意味着，当临床医生看到这个特定的警報时，患者实际患有状况 $D$ 的概率仅为 $19.15\\%$。反过来说，这意味着在 $1 - 0.1915 = 0.8085$ 即 $80.85\\%$ 的情况下，警报是假警报（即患者没有患有状况 $D$）。\n\n这个非常低的 PPV 对临床实践有重要影响。\n对于感知到的警报可靠性，临床医生很可能会认为该警报非常不可靠。一个每 $5$ 次中就有超过 $4$ 次是错误的工具，是无法赢得信任的。这侵蚀了临床医生对 CDS 系统的信任。\n\n这种差的可靠性是警报疲劳的直接原因。警报疲劳是指临床医生在接触大量临床不相关或错误的警报后，对安全警报和通知变得不敏感的现象。经历频繁的、低价值的干扰会分散对患者护理的注意力，并导致临床医生养成忽略或不加审慎考虑就反射性地覆盖警报的习惯。这种行为虽然是对过多“噪音”的合理反应，但却是危险的，因为它可能导致忽略掉一个罕见但至关重要的真阳性警报，从而破坏了 CDS 的主要安全目标。在这种情况下，低 PPV 的根本原因是相对较低的特异度（$0.8$，导致了 $0.2$ 的高假阳性率）和疾病的低患病率（$0.05$）的结合。即使灵敏度很高，对大量健康个体进行特异度不完美的测试，也会产生大量的假阳性，其数量会淹没来自较小患病人群的真阳性。",
            "answer": "$$\n\\boxed{0.1915}\n$$"
        },
        {
            "introduction": "理解了警报系统背后的概率挑战后，让我们动手构建一个具体的警报。本练习将让你扮演一名信息学专家的角色，使用当前主流的健康数据交换标准——HL7 FHIR——来精确定义一个警报触发器。你将学习如何为代码、数值和单位设定严格的标准，这是确保系统互操作性和患者安全的关键技能。",
            "id": "4821956",
            "problem": "您正在 Health Level 7 (HL7) Fast Healthcare Interoperability Resources (FHIR) 中设计一个警报机制，当实验室 Observation 指示血清钾高于临床显著阈值时，该机制会通知下游系统。请使用以下基本定义作为您推导和算法规范的基础：\n\n- HL7 FHIR R4 Subscription 使用应用于资源类型的搜索条件字符串，遵循 FHIR 搜索语义。Observation 的 code 是一个令牌（token）搜索参数，它能精确匹配代码系统和代码的组合。标准的 LOINC（Logical Observation Identifiers Names and Codes，逻辑观察标识符名称和代码）系统由统一资源标识符（URI）“http://loinc.org”表示。\n- FHIR 中用于值的数量（quantity）搜索参数，在 Observation 上名为“value-quantity”，使用一个比较器前缀和一个“值|系统|代码”的数量三元组。统一计量单位代码（Unified Code for Units of Measure, UCUM）系统由 URI “http://unitsofmeasure.org”表示，毫摩尔/升的代码是“mmol/L”。对于比较器前缀“gt”，其语义为严格大于。因此，“gt$5.5$”意为“$>$ $5.5$”。\n- FHIR 使用“value-quantity=[comparator][number]|[system]|[code]”形式进行数量搜索匹配时，要求单位系统和单位代码完全相等才被视为可比较；不执行单位转换。如果系统或代码任一不完全匹配，则该数量不匹配。\n\n任务要求：\n\n1. 精确指定 HL7 FHIR R4 Subscription 的搜索条件字符串，该字符串用于监视 LOINC 代码为“2823-3”且值严格大于 $5.5$ 毫摩尔/升的血清或血浆钾的 Observation 资源。请使用上述语义，并要求系统和代码精确匹配。然后，指定一个通道配置，该配置使用表述性状态传递（REST）钩子，通过安全超文本传输协议（HTTPS）传递 JavaScript 对象表示法（JSON）载荷。您必须定义通道类型、端点和载荷内容类型。\n2. 实现一个程序，用于评估以下每个伪 Observation 输入是否会触发第 1 部分中推导出的 Subscription 的交付。每个输入是一个包含五个字段的元组：（code_system, code, value, unit_system, unit_code）。一个案例当且仅当满足以下所有条件时才会触发：\n   - code_system 等于“http://loinc.org”且 code 等于“2823-3”，\n   - value 是一个严格大于 $5.5$ 的实数，\n   - unit_system 等于“http://unitsofmeasure.org”且 unit_code 等于“mmol/L”。\n   如果任何字段缺失或不满足条件，则该案例不触发。\n\n使用以下测试用例集：\n- 案例 A：(\"http://loinc.org\", \"2823-3\", $6.2$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 B：(\"http://loinc.org\", \"2823-3\", $5.5$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 C：(\"http://loinc.org\", \"2823-3\", $4.7$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 D：(\"http://loinc.org\", \"2951-2\", $6.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 E：(\"http://loinc.org\", \"2823-3\", $6.0$, \"http://unitsofmeasure.org\", \"meq/L\")\n- 案例 F：(\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\") 其中 null 表示不存在数值，\n- 案例 G：(\"http://example.org/loinc\", \"2823-3\", $7.1$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 H：(\"http://loinc.org\", \"2823-3\", $-1.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- 案例 I：(\"http://loinc.org\", \"2823-3\", $5.5000001$, \"http://unitsofmeasure.org\", \"mmol/L\")\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true,false,true]”）。布尔值应使用标准的 Python 大写格式“True”和“False”打印。",
            "solution": "该问题是有效的，因为它在医学信息学和 HL7 FHIR 标准领域具有科学依据，问题陈述清晰明确，要求无歧义，并且其表述是客观的。所有必要的定义、常量和条件都已提供，以推导出唯一且可验证的解决方案。\n\n问题按规定分为两部分进行解决。\n\n第 1 部分：HL7 FHIR Subscription 的规范\n\n目标是创建一个能针对特定类型的 `Observation` 资源触发的订阅。这需要定义一组能够精确选择目标资源的搜索条件。HL7 FHIR R4 搜索框架使用参数-值对的组合，通过与号（`&`）连接，并附加在资源类型之后。\n\n所需的订阅必须监视 `Observation` 资源，因此条件字符串将以 `Observation?` 开头。\n\n条件 1：Observation 代码\n第一个条件是 Observation 代码，它必须是血清或血浆钾的 LOINC 代码 `\"2823-3\"`。问题指出 `code` 搜索参数的类型是 `token`，并且它同时匹配代码系统和代码值。指定的令牌搜索语法是 `[parameter]=[system]|[code]`。\n\n- 参数名称：`code`\n- 代码系统 URI：`http://loinc.org`\n- 代码值：`2823-3`\n\n根据指定格式组合这些元素，得到搜索字符串的第一部分：\n`code=http://loinc.org|2823-3`\n\n条件 2：Observation 值\n第二个条件是 Observation 的值，它必须严格大于 $5.5$ 毫摩尔/升。这需要使用 `value-quantity` 搜索参数。问题指定了数量搜索的格式为 `[parameter]=[comparator][number]|[system]|[code]`。它还规定搜索是严格的，不进行单位转换，需要单位系统和单位代码的精确匹配。\n\n- 参数名称：`value-quantity`\n- “严格大于”的比较器：`gt`\n- 数值：$5.5$\n- 单位系统 URI (UCUM)：`http://unitsofmeasure.org`\n- 单位代码：`mmol/L`\n\n组合这些元素，得到搜索字符串的第二部分：\n`value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\n最终搜索条件字符串\n`Subscription` 资源的完整 `criteria` 字符串是通过将资源类型与两个条件连接而成，用 `&` 连接。\n\n`Observation?code=http://loinc.org|2823-3&value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\n通道配置\n问题进一步要求指定通知的交付通道。这在 `Subscription` 资源的 `channel` 元素中配置。要求是 REST 钩子、JSON 载荷和 HTTPS 端点。\n\n-   `channel.type`：按规定，对于 REST 钩子，值为 `rest-hook`。\n-   `channel.endpoint`：这必须是一个将发送通知的安全 URL。将使用一个代表性的占位符，例如 `https://downstream-system.example.com/fhir/receive`。\n-   `channel.payload`：对于代表 FHIR 资源的 JSON 载荷，标准的 MIME 类型是 `application/fhir+json`。\n\n这三项规范定义了订阅的交付机制。\n\n第 2 部分：伪 Observation 输入的算法评估\n\n任务是创建一个程序，实现由订阅条件定义的逻辑。一个伪 Observation 当且仅当所有指定条件都满足时，才会触发通知。每个案例的输入是一个元组：`(code_system, code, value, unit_system, unit_code)`。\n\n触发的逻辑是以下五个条件的合取：\n1.  `code_system` 必须严格等于字符串 `\"http://loinc.org\"`。\n2.  `code` 必须严格等于字符串 `\"2823-3\"`。\n3.  `value` 必须是数字类型，并且必须严格大于 $5.5$。`null` 或非数值会使此条件不满足。\n4.  `unit_system` 必须严格等于字符串 `\"http://unitsofmeasure.org\"`。\n5.  `unit_code` 必须严格等于字符串 `\"mmol/L\"`。\n\n此逻辑应用于每个测试案例：\n\n-   案例 A: `(\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   所有条件均满足。`code_system`、`code`、`unit_system` 和 `unit_code` 匹配。值 $6.2$ 是数字且 $6.2 > 5.5$。\n    -   结果: `True`。\n\n-   案例 B: `(\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。$5.5$ 不严格大于 $5.5$。\n    -   结果: `False`。\n\n-   案例 C: `(\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。$4.7$ 不大于 $5.5$。\n    -   结果: `False`。\n\n-   案例 D: `(\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   `code` 条件不满足。`\"2951-2\"` 不等于 `\"2823-3\"`。\n    -   结果: `False`。\n\n-   案例 E: `(\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\")`\n    -   `unit_code` 条件不满足。`\"meq/L\"` 不等于 `\"mmol/L\"`。\n    -   结果: `False`。\n\n-   案例 F: `(\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。`null` 值不是数字，无法比较。\n    -   结果: `False`。\n\n-   案例 G: `(\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   `code_system` 条件不满足。`\"http://example.org/loinc\"` 不等于 `\"http://loinc.org\"`。\n    -   结果: `False`。\n\n-   案例 H: `(\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   值条件不满足。虽然是数字，但 $-1.0$ 不大于 $5.5$。负浓度在物理上不可能，但这与逻辑评估无关。\n    -   结果: `False`。\n\n-   案例 I: `(\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   所有条件均满足。值 $5.5000001$ 严格大于 $5.5$。\n    -   结果: `True`。\n\n下面的程序将直接实现此评估逻辑，并生成指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Evaluates a series of pseudo-Observation inputs against HL7 FHIR\n    subscription criteria for hyperkalemia alerts.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (code_system, code, value, unit_system, unit_code)\n    # The 'null' value from the problem is represented as Python's None.\n    test_cases = [\n        (\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case A\n        (\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case B\n        (\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case C\n        (\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case D\n        (\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\"),   # Case E\n        (\"http://loinc.org\", \"2823-3\", None, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case F\n        (\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case G\n        (\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case H\n        (\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\") # Case I\n    ]\n\n    # Define the target values based on the subscription criteria.\n    TARGET_CODE_SYSTEM = \"http://loinc.org\"\n    TARGET_CODE = \"2823-3\"\n    VALUE_THRESHOLD = 5.5\n    TARGET_UNIT_SYSTEM = \"http://unitsofmeasure.org\"\n    TARGET_UNIT_CODE = \"mmol/L\"\n\n    results = []\n    for case in test_cases:\n        code_system, code, value, unit_system, unit_code = case\n\n        # A case triggers if and only if all conditions are met.\n        # This is a direct implementation of the logical AND of all checks.\n\n        # 1. Check if a numeric value is present and if it's strictly greater than the threshold.\n        #    Python's isinstance handles both int and float.\n        #    A None value will cause the first part of this AND to be false.\n        value_is_valid = isinstance(value, (int, float)) and value > VALUE_THRESHOLD\n\n        # 2. Check for exact matches on code system, code, unit system, and unit code.\n        code_system_matches = (code_system == TARGET_CODE_SYSTEM)\n        code_matches = (code == TARGET_CODE)\n        unit_system_matches = (unit_system == TARGET_UNIT_SYSTEM)\n        unit_code_matches = (unit_code == TARGET_UNIT_CODE)\n\n        # 3. The final result is the logical conjunction of all conditions.\n        trigger = (\n            code_system_matches and\n            code_matches and\n            value_is_valid and\n            unit_system_matches and\n            unit_code_matches\n        )\n        results.append(trigger)\n\n    # Final print statement in the exact required format.\n    # The default string representation of Python's boolean is \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的临床数据往往是不完整的，这对警报系统的设计构成了巨大挑战。本练习通过引入一个包含“阳性”、“阴性”和“未知”的三值逻辑系统，来教你如何优雅地处理缺失的实验室数据。你将实现并分析这种更精密的逻辑，并探索不同的警报触发策略（如“严格”与“谨慎”策略）如何帮助我们构建更细致、更安全的临床决策支持系统。",
            "id": "4822035",
            "problem": "一份电子健康记录（EHR）警报必须在存在缺失数据的情况下评估实验室触发条件。系统必须区分三种状态：阳性（positive）、阴性（negative）和未知（unknown）。为一个结合了多个实验室条件的触发器形式化一个三值逻辑，并计算该逻辑在两种策略下如何影响警报触发。\n\n使用的基本原理：\n- 具有以下值的三值语义域：阳性、阴性、未知，分别表示为 $P$、$N$ 和 $U$。\n- 对单个实验室值 $x$ 与阈值 $t$ 在关系 $\\ge$ 或 $\\le$ 下的确定性阈值评估，定义为：如果 $x$ 存在，则通过比较 $x$ 和 $t$ 来决定 $P$ 或 $N$；如果 $x$ 缺失，则返回 $U$。\n- 作用于 $\\{P,N,U\\}$ 的连接词的强三值逻辑（Kleene 语义）：\n  - 否定：$\\lnot P = N$，$\\lnot N = P$，$\\lnot U = U$。\n  - 合取：$P \\land P = P$，对于任何 $v \\in \\{P,N,U\\}$，$N \\land v = N$，$v \\land N = N$，$P \\land U = U$，$U \\land P = U$，$U \\land U = U$。\n  - 析取：对于任何 $v \\in \\{P,N,U\\}$，$P \\lor v = P$，$v \\lor P = P$，$N \\lor N = N$，$N \\lor U = U$，$U \\lor N = U$，$U \\lor U = U$。\n\n待评估的警报表达式：\n- 基于阈值化的实验室值定义三个原子触发器 $A$、$B$ 和 $C$：\n  - $A$ 是在关系 $\\ge$ 下测试 $x_A$ 与阈值 $t_A$ 的三值结果。\n  - $B$ 是在关系 $\\ge$ 下测试 $x_B$ 与阈值 $t_B$ 的三值结果。\n  - $C$ 是在关系 $\\le$ 下测试 $x_C$ 与阈值 $t_C$ 的三值结果。\n- 复合触发器是 $E = A \\lor (B \\land C)$，在强三值逻辑下进行评估。\n\n警报触发策略：\n- 严格策略 $S$：当且仅当 $E = P$ 时触发。\n- 谨慎策略 $C$：当 $E = P$ 或 $E = U$ 时触发。\n\n输出的整数编码：\n- 使用映射 $m(P) = 1$，$m(N) = 0$，$m(U) = -1$。\n\n您的程序必须：\n1. 为 $A$、$B$ 和 $C$ 实现三值阈值评估，以及为 $\\lnot$、$\\land$ 和 $\\lor$ 实现强三值逻辑。\n2. 为每个测试用例计算 $E$，然后计算严格触发决策 $S$ 和谨慎触发决策 $C$。\n3. 生成单行输出，包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是形式为 $[m(E), S, C]$ 的列表。\n\n阈值：\n- $t_A = 5.5$，$t_B = 1.5$，$t_C = 60$。\n\n测试套件（每个测试用例提供元组 $(x_A, x_B, x_C)$，其中缺失值用 `None` 表示）：\n- 用例 1：$(5.0, 1.2, 70)$。\n- 用例 2：$(5.6, 1.0, 90)$。\n- 用例 3：$(4.0, 2.0, 40)$。\n- 用例 4：$(4.0, 2.2, 80)$。\n- 用例 5：$(\\text{None}, 2.0, 40)$。\n- 用例 6：$(\\text{None}, \\text{None}, \\text{None})$。\n- 用例 7：$(5.5, 1.5, 60)$。\n- 用例 8：$(4.5, \\text{None}, 50)$。\n\n最终输出格式：\n- 单行：一个由方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的列表 $[m(E), S, C]$，例如 $[[1,\\mathrm{True},\\mathrm{True}],[0,\\mathrm{False},\\mathrm{False}],\\dots]$。",
            "solution": "该问题要求形式化并应用一个三值逻辑系统，以在存在缺失实验室数据的情况下评估医疗警报触发器。解决方案涉及定义逻辑框架，为几个测试用例评估一个复合逻辑表达式，并根据两种不同的策略确定警报触发决策。\n\n首先，我们建立该系统的数学基础。语义域由三个逻辑值组成：阳性（$P$）、阴性（$N$）和未知（$U$）。这些值使用强三值逻辑进行操作，也称为 Kleene 的 $K_3$ 逻辑。合取（$\\land$）和析取（$\\lor$）运算符的行为由以下真值表定义：\n\n**合取 ($v_1 \\land v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\land & P & N & U \\\\\n\\hline\nP & P & N & U \\\\\nN & N & N & N \\\\\nU & U & N & U\n\\end{array}\n$$\n\n**析取 ($v_1 \\lor v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\lor & P & N & U \\\\\n\\hline\nP & P & P & P \\\\\nN & P & N & U \\\\\nU & P & U & U\n\\end{array}\n$$\n\n该逻辑的一个重要特性是 $N$ 在合取中的行为和 $P$ 在析取中的行为。单个 $N$ 操作数足以使合取结果为 $N$（$N$ 对于 $\\land$ 是“显性”或“吸收性”的）。类似地，单个 $P$ 操作数足以使析取结果为 $P$（$P$ 对于 $\\lor$ 是显性的）。当无法从可用的非未知值中确定结果时，会出现值 $U$。\n\n问题定义了三个原子触发器 $A$、$B$ 和 $C$，基于实验室值 $x_A$、$x_B$ 和 $x_C$ 及其各自的阈值 $t_A$、$t_B$ 和 $t_C$。\n-   $t_A = 5.5$\n-   $t_B = 1.5$\n-   $t_C = 60$\n\n每个原子触发器的评估如下：\n1.  触发器 $A$ 在 $x_A \\ge 5.5$ 时评估为 $P$，在 $x_A < 5.5$ 时评估为 $N$，在 $x_A$ 缺失时评估为 $U$。\n2.  触发器 $B$ 在 $x_B \\ge 1.5$ 时评估为 $P$，在 $x_B < 1.5$ 时评估为 $N$，在 $x_B$ 缺失时评估为 $U$。\n3.  触发器 $C$ 在 $x_C \\le 60$ 时评估为 $P$，在 $x_C > 60$ 时评估为 $N$，在 $x_C$ 缺失时评估为 $U$。\n\n这些原子触发器被组合成一个单一的复合表达式 $E$：\n$$\nE = A \\lor (B \\land C)\n$$\n该表达式的评估遵循运算顺序，首先评估括号中的合取。\n\n最后，根据 $E$ 的结果值定义了两种警报触发策略：\n-   **严格策略 ($S$)**：当且仅当 $E = P$ 时，警报触发。\n-   **谨慎策略 ($C_{\\text{policy}}$)**：当 $E = P$ 或 $E = U$ 时，警报触发。\n\n每个用例的最终输出需要将 $E$ 的逻辑值映射到一个整数代码：$m(P) = 1$，$m(N) = 0$，$m(U) = -1$。严格策略 ($S$) 和谨慎策略 ($C_{\\text{policy}}$) 的决策表示为布尔值 `True` 或 `False`。\n\n让我们用两个代表性的测试用例来演示评估过程。\n\n**用例 4：输入 $(x_A, x_B, x_C) = (4.0, 2.2, 80)$**\n此用例没有缺失数据。\n\n1.  **评估原子触发器**：\n    -   $A$：$x_A = 4.0$。条件是 $4.0 \\ge 5.5$，为假。因此，$A = N$。\n    -   $B$：$x_B = 2.2$。条件是 $2.2 \\ge 1.5$，为真。因此，$B = P$。\n    -   $C$：$x_C = 80$。条件是 $80 \\le 60$，为假。因此，$C = N$。\n\n2.  **评估子表达式 $(B \\land C)$**：\n    -   我们计算 $P \\land N$。根据合取表，$P \\land N = N$。\n\n3.  **评估完整表达式 $E = A \\lor (B \\land C)$**：\n    -   我们计算 $N \\lor N$。根据析取表，$N \\lor N = N$。所以，$E=N$。\n\n4.  **确定策略和最终输出**：\n    -   $m(E) = m(N) = 0$。\n    -   严格策略 ($S$)：$E = P$ 吗？否（$N \\neq P$）。所以，$S = \\text{False}$。\n    -   谨慎策略 ($C_{\\text{policy}}$)：$E = P$ 或 $E = U$ 吗？否（$N \\neq P$ 且 $N \\neq U$）。所以，$C_{\\text{policy}} = \\text{False}$。\n    -   结果向量为 $[0, \\text{False}, \\text{False}]$。\n\n**用例 8：输入 $(x_A, x_B, x_C) = (4.5, \\text{None}, 50)$**\n此用例包含一个缺失值，展示了 $U$ 状态的作用。\n\n1.  **评估原子触发器**：\n    -   $A$：$x_A = 4.5$。条件是 $4.5 \\ge 5.5$，为假。因此，$A = N$。\n    -   $B$：$x_B = \\text{None}$。该值缺失。因此，$B = U$。\n    -   $C$：$x_C = 50$。条件是 $50 \\le 60$，为真。因此，$C = P$。\n\n2.  **评估子表达式 $(B \\land C)$**：\n    -   我们计算 $U \\land P$。根据合取表，$U \\land P = U$。\n\n3.  **评估完整表达式 $E = A \\lor (B \\land C)$**：\n    -   我们计算 $N \\lor U$。根据析取表，$N \\lor U = U$。所以，$E=U$。\n\n4.  **确定策略和最终输出**：\n    -   $m(E) = m(U) = -1$。\n    -   严格策略 ($S$)：$E = P$ 吗？否（$U \\neq P$）。所以，$S = \\text{False}$。\n    -   谨慎策略 ($C_{\\text{policy}}$)：$E = P$ 或 $E = U$ 吗？是（$U = U$）。所以，$C_{\\text{policy}} = \\text{True}$。\n    -   结果向量为 $[-1, \\text{False}, \\text{True}]$。\n\n通过将此过程应用于所有八个测试用例，我们得到以下结果：\n-   用例 1：$(5.0, 1.2, 70) \\implies A=N, B=N, C=N \\implies E = N \\lor (N \\land N) = N$。结果：$[0, \\text{False}, \\text{False}]$。\n-   用例 2：$(5.6, 1.0, 90) \\implies A=P, B=N, C=N \\implies E = P \\lor (N \\land N) = P$。结果：$[1, \\text{True}, \\text{True}]$。\n-   用例 3：$(4.0, 2.0, 40) \\implies A=N, B=P, C=P \\implies E = N \\lor (P \\land P) = P$。结果：$[1, \\text{True}, \\text{True}]$。\n-   用例 4：$(4.0, 2.2, 80) \\implies A=N, B=P, C=N \\implies E = N \\lor (P \\land N) = N$。结果：$[0, \\text{False}, \\text{False}]$。\n-   用例 5：$(\\text{None}, 2.0, 40) \\implies A=U, B=P, C=P \\implies E = U \\lor (P \\land P) = P$。结果：$[1, \\text{True}, \\text{True}]$。\n-   用例 6：$(\\text{None}, \\text{None}, \\text{None}) \\implies A=U, B=U, C=U \\implies E = U \\lor (U \\land U) = U$。结果：$[-1, \\text{False}, \\text{True}]$。\n-   用例 7：$(5.5, 1.5, 60) \\implies A=P, B=P, C=P \\implies E = P \\lor (P \\land P) = P$。结果：$[1, \\text{True}, \\text{True}]$。\n-   用例 8：$(4.5, \\text{None}, 50) \\implies A=N, B=U, C=P \\implies E = N \\lor (U \\land P) = U$。结果：$[-1, \\text{False}, \\text{True}]$。\n\n这些结果由下一节中的实现系统地生成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport operator\n\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the three-valued logic problem for medical alerts.\n    \"\"\"\n    \n    # Define the three logic states. Using strings for clarity.\n    P, N, U = \"P\", \"N\", \"U\"\n\n    # Define the integer mapping for the output.\n    MAPPING = {P: 1, N: 0, U: -1}\n\n    def evaluate_atomic_trigger(value, threshold, op):\n        \"\"\"\n        Evaluates a single lab value against a threshold.\n        'op' is a comparison operator from the operator module.\n        \"\"\"\n        if value is None:\n            return U\n        if op(value, threshold):\n            return P\n        else:\n            return N\n\n    def kleene_and(v1, v2):\n        \"\"\"Implements strong Kleene three-valued conjunction (AND).\"\"\"\n        if v1 == N or v2 == N:\n            return N\n        if v1 == P and v2 == P:\n            return P\n        return U\n\n    def kleene_or(v1, v2):\n        \"\"\"Implements strong Kleene three-valued disjunction (OR).\"\"\"\n        if v1 == P or v2 == P:\n            return P\n        if v1 == N and v2 == N:\n            return N\n        return U\n\n    # Thresholds for the atomic triggers A, B, and C.\n    t_A = 5.5\n    t_B = 1.5\n    t_C = 60\n\n    # Test suite: tuples of (x_A, x_B, x_C), with None for missing values.\n    test_cases = [\n        (5.0, 1.2, 70),       # Case 1\n        (5.6, 1.0, 90),       # Case 2\n        (4.0, 2.0, 40),       # Case 3\n        (4.0, 2.2, 80),       # Case 4\n        (None, 2.0, 40),      # Case 5\n        (None, None, None),   # Case 6\n        (5.5, 1.5, 60),       # Case 7\n        (4.5, None, 50),      # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        x_A, x_B, x_C = case\n\n        # Step 1: Evaluate atomic triggers A, B, and C.\n        A = evaluate_atomic_trigger(x_A, t_A, operator.ge) # A is x_A >= t_A\n        B = evaluate_atomic_trigger(x_B, t_B, operator.ge) # B is x_B >= t_B\n        C = evaluate_atomic_trigger(x_C, t_C, operator.le) # C is x_C <= t_C\n\n        # Step 2: Evaluate the composite expression E = A or (B and C).\n        # The inner conjunction (B and C) is evaluated first.\n        B_and_C = kleene_and(B, C)\n        \n        # Then the outer disjunction.\n        E = kleene_or(A, B_and_C)\n\n        # Step 3: Apply firing policies and map E to its integer representation.\n        m_E = MAPPING[E]\n        \n        # Strict policy (S): fire if and only if E is Positive.\n        S = (E == P)\n        \n        # Cautious policy (C): fire if E is Positive or Unknown.\n        C_policy = (E == P or E == U)\n\n        # Collect the results for this case in the specified format [m(E), S, C].\n        results.append([m_E, S, C_policy])\n\n    # Final print statement must produce a single line in the exact specified format.\n    # The str() function on a list correctly formats it with capitalized Booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}