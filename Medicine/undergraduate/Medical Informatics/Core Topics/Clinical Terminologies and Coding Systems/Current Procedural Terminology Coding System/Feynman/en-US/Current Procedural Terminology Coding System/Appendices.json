{
    "hands_on_practices": [
        {
            "introduction": "Procedural coding often involves more than selecting a single code; it requires building a complete picture of the service provided. This exercise  focuses on Mohs Micrographic Surgery, a procedure whose coding rules exemplify this complexity. By working through this clinically realistic scenario, you will practice applying a multi-level logic involving anatomic location, surgical stages, the number of tissue blocks, and the separate reporting of post-excisional repairs. Mastering this layered approach is fundamental to accurately representing complex surgical services.",
            "id": "4461245",
            "problem": "A $68$-year-old man undergoes Mohs micrographic surgery (MMS) for a biopsy-proven basal cell carcinoma (BCC) on the nasal ala. The surgeon performs both the excision and the intraoperative frozen section histologic assessment. Stage $1$ of MMS requires $4$ tissue blocks to achieve margin assessment; residual tumor persists. Stage $2$ requires $6$ tissue blocks and achieves clear margins. The final defect on the nose is closed primarily with an intermediate layered repair resulting in a linear suture line measuring $3.4\\ \\mathrm{cm}$. According to Current Procedural Terminology (CPT) rules that define MMS codes by anatomic location, stage, and number of tissue blocks, and that define intermediate layered repair codes by anatomic site and total length, which set of CPT codes most accurately captures this encounter?\n\nA. $17311 \\times 1$, $17312 \\times 1$, $17315 \\times 1$, $12052 \\times 1$\n\nB. $17311 \\times 1$, $17312 \\times 1$, $12052 \\times 1$\n\nC. $17311 \\times 1$, $17312 \\times 1$, $17315 \\times 2$, $12052 \\times 1$\n\nD. $17313 \\times 1$, $17314 \\times 1$, $17315 \\times 1$, $12052 \\times 1$\n\nE. $17311 \\times 1$, $17312 \\times 1$, $13132 \\times 1$",
            "solution": "The user has provided a clinical scenario and requested the most accurate set of Current Procedural Terminology (CPT) codes for the encounter. This requires a systematic application of CPT coding rules, which I will treat as a set of formal axioms.\n\n### Step 1: Extract Givens\n- Patient: $68$-year-old man\n- Diagnosis: Basal cell carcinoma (BCC)\n- Procedure: Mohs micrographic surgery (MMS)\n- Anatomic Location (MMS): Nasal ala (part of the nose, which is on the head)\n- Stage $1$: $4$ tissue blocks, incomplete excision.\n- Stage $2$: $6$ tissue blocks, complete excision (clear margins).\n- Repair Procedure: Intermediate layered repair.\n- Repair Location: Nose.\n- Repair Size: $3.4\\ \\mathrm{cm}$ linear suture line.\n- CPT Rule Stipulations:\n    - MMS codes are determined by anatomic location, stage, and number of tissue blocks.\n    - Repair codes are determined by anatomic site, complexity (intermediate), and total length.\n\n### Step 2: Validate a priori a valid problem statement\nThe problem statement describes a standard clinical scenario in dermatologic surgery. The CPT system is a formal, objective standard for medical billing in the United States. The problem provides all necessary parameters (anatomic sites, number of surgical stages, number of tissue blocks per stage, repair type, and repair size) to uniquely determine the correct set of codes by applying the established CPT rules. The problem is scientifically grounded, well-posed, objective, and contains no internal contradictions or ambiguities. Therefore, the problem is valid and a solution can be derived.\n\n### Step 3: Derivation of CPT Codes\n\nThe encounter consists of two main billable services: the Mohs micrographic surgery and the surgical repair. These must be coded separately according to CPT guidelines.\n\n**Part 1: Mohs Micrographic Surgery (MMS) Codes**\n\nMMS coding is based on a primary code for the first stage and an add-on code for each subsequent stage. The specific codes are differentiated by anatomic location.\n\n1.  **Anatomic Location:** The surgery is on the \"nasal ala\". The nose is part of the head. CPT codes $17311$ and $17312$ are used for MMS on the head, neck, hands, feet, genitalia, or any location requiring complex reconstruction. Codes $17313$ and $17314$ are for the trunk, arms, or legs and are therefore incorrect for this location.\n\n2.  **First Stage (Stage $1$):**\n    - The first stage of MMS is coded using CPT code $17311$ for the specified anatomic area.\n    - CPT code $17311$ covers the first stage, including up to $5$ tissue blocks.\n    - In this case, Stage $1$ required $4$ tissue blocks. Since $4 \\leq 5$, this stage is correctly reported by **$17311 \\times 1$**.\n\n3.  **Second Stage (Stage $2$):**\n    - Each additional stage after the first is reported using an add-on code. For the head/neck area, this is CPT code $17312$.\n    - CPT code $17312$ covers an additional stage, including up to $5$ tissue blocks.\n    - In this case, Stage $2$ was performed, so a code for an additional stage is required. This part of the service is reported by **$17312 \\times 1$**.\n\n4.  **Additional Tissue Blocks:**\n    - CPT code $17315$ is an add-on code used to report each additional tissue block *after the first 5* within any single stage.\n    - Stage $1$ had $4$ blocks, which is less than $5$, so no $17315$ is reported for Stage $1$.\n    - Stage $2$ had $6$ blocks. The code for the second stage, $17312$, includes the first $5$ of these blocks. The $6^{\\text{th}}$ block is an additional block.\n    - The number of additional blocks is $6 - 5 = 1$.\n    - Therefore, this single extra block is reported by **$17315 \\times 1$**.\n\nCombining the MMS codes, the surgical portion is coded as: $17311 \\times 1$, $17312 \\times 1$, and $17315 \\times 1$.\n\n**Part 2: Surgical Repair Code**\n\nCPT guidelines state that simple repairs are bundled with the MMS procedure, but intermediate and complex repairs are reported separately. The problem specifies an \"intermediate layered repair\".\n\n1.  **Repair Complexity and Location:** The repair is intermediate. The CPT codes for intermediate repairs are in the series $12031-12057$. The repair is on the nose. The codes for intermediate repairs of the \"face, ears, eyelids, nose, lips...\" are $12051-12057$.\n\n2.  **Repair Size:** The repair measured $3.4\\ \\mathrm{cm}$. We must find the code that includes this length.\n    - CPT $12051$: $2.5\\ \\mathrm{cm}$ or less.\n    - CPT $12052$: $2.6\\ \\mathrm{cm}$ to $5.0\\ \\mathrm{cm}$.\n    - CPT $12053$: $5.1\\ \\mathrm{cm}$ to $7.5\\ \\mathrm{cm}$.\n    - A length of $3.4\\ \\mathrm{cm}$ falls within the range for CPT code $12052$.\n\nTherefore, the repair is correctly reported by **$12052 \\times 1$**.\n\n**Summary of All Correct Codes:**\nThe complete and accurate coding for this encounter is the combination of the MMS codes and the repair code:\n$17311 \\times 1$, $17312 \\times 1$, $17315 \\times 1$, $12052 \\times 1$.\n\n### Step 4: Option-by-Option Analysis\n\nA. **$17311 \\times 1$, $17312 \\times 1$, $17315 \\times 1$, $12052 \\times 1$**\nThis option includes the correct code for the first stage ($17311$), the correct code for the second stage ($17312$), the correct code for the single additional block in stage $2$ ($17315$), and the correct code for the intermediate repair of $3.4\\ \\mathrm{cm}$ on the nose ($12052$). This set of codes perfectly matches the derived solution.\n**Verdict: Correct.**\n\nB. **$17311 \\times 1$, $17312 \\times 1$, $12052 \\times 1$**\nThis option correctly codes for the two stages and the repair. However, it omits CPT code $17315$, which is required to bill for the $6^{\\text{th}}$ tissue block taken during Stage $2$. The code for the second stage, $17312$, only covers up to $5$ blocks. This coding is incomplete and results in under-billing.\n**Verdict: Incorrect.**\n\nC. **$17311 \\times 1$, $17312 \\times 1$, $17315 \\times 2$, $12052 \\times 1$**\nThis option correctly codes for the stages and the repair. However, it incorrectly bills for two units of $17315$. CPT code $17315$ is billed for each block *after* the first $5$ in a given stage. Stage $2$ had $6$ blocks, which is only $1$ block more than $5$. Therefore, only one unit of $17315$ is appropriate. This represents over-billing.\n**Verdict: Incorrect.**\n\nD. **$17313 \\times 1$, $17314 \\times 1$, $17315 \\times 1$, $12052 \\times 1$**\nThis option uses CPT codes $17313$ (first stage) and $17314$ (additional stage). These codes are for MMS performed on the trunk, arms, or legs. The surgery was on the nasal ala (head), making these codes incorrect for the anatomic location.\n**Verdict: Incorrect.**\n\nE. **$17311 \\times 1$, $17312 \\times 1$, $13132 \\times 1$**\nThis option omits the necessary code $17315$ for the additional block in Stage $2$. Furthermore, it uses CPT code $13132$ for the repair. The $13xxx$ series codes are for complex repairs. The problem explicitly states the repair was \"intermediate\". Therefore, $13132$ is an incorrect code for the repair.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Building on the skills of coding a single complex procedure, this practice  introduces the challenge of coding multiple, interacting services within a single encounter. Outpatient infusion services are governed by a strict hierarchy and time-based rules that dictate which services are 'initial' and how subsequent or concurrent services are reported. This problem will help you master the logical framework required to navigate these rules, a critical skill for accurate coding and reimbursement in oncology and other specialties that rely heavily on infusion therapies.",
            "id": "4831700",
            "problem": "In outpatient infusion coding under the Current Procedural Terminology (CPT) coding system, services are categorized hierarchically and time-based reporting rules apply. The hierarchy for intravenous administration establishes that chemotherapy infusion supersedes therapeutic/prophylactic/diagnostic infusion, which supersedes hydration. Only one “initial” service may be selected per encounter, and it must be chosen from the highest applicable category. Additional reporting for sequential and concurrent infusions and for intravenous pushes and injections follows category-specific rules.\n\nA patient undergoes the following services in a single hospital outpatient encounter:\n- Chemotherapy infusion of Drug A begins at $08{:}00$ and ends at $09{:}35$, lasting $95$ minutes total.\n- Hydration runs concurrently via a secondary line from $08{:}10$ to $08{:}50$, lasting $40$ minutes.\n- After the chemotherapy infusion ends, a therapeutic antibiotic infusion (Drug B) is administered sequentially from $09{:}40$ to $10{:}10$, lasting $30$ minutes.\n- An antiemetic is administered as an intravenous push at $08{:}05$.\n- A vitamin B12 injection is administered intramuscularly at $10{:}20$.\n\nAssume the following Relative Value Units (RVUs) for the relevant CPT codes:\n- Initial chemotherapy infusion (up to $1$ hour): CPT $96413$ has $3.40$ RVUs.\n- Each additional hour of chemotherapy infusion: CPT $96415$ has $1.60$ RVUs.\n- Concurrent infusion add-on: CPT $96368$ has $0.80$ RVUs.\n- Additional sequential infusion of a new therapeutic/prophylactic/diagnostic substance/drug (up to $1$ hour): CPT $96367$ has $1.20$ RVUs.\n- Intravenous push of a new therapeutic/prophylactic/diagnostic substance/drug: CPT $96375$ has $0.70$ RVUs.\n- Intramuscular injection: CPT $96372$ has $0.60$ RVUs.\n\nUse the core CPT hierarchy and time-based reporting rules to determine the correctly reportable codes from this encounter and compute the total professional payment using a national conversion factor of $C = 36.00$ dollars per RVU. Express the final payment in United States dollars (USD) and round your answer to four significant figures.",
            "solution": "The problem is assessed to be valid. It presents a self-contained, rule-based scenario within the domain of medical informatics and computational healthcare billing, which is a formalizable topic. The provided data, definitions, and constraints are sufficient and internally consistent, allowing for a unique solution by applying the given hierarchical and time-based rules. The problem is well-posed.\n\nThe solution proceeds by systematically applying the Current Procedural Terminology (CPT) coding rules as described in the problem statement to the patient encounter. The total professional payment is the product of the sum of the Relative Value Units (RVUs) for all correctly reported services and the national conversion factor.\n\nThe primary principle is the service hierarchy: Chemotherapy infusion $$ Therapeutic/Prophylactic/Diagnostic infusion $$ Hydration. Only one \"initial\" service can be reported, and it must correspond to the highest-ranking service provided during the encounter.\n\n1.  **Determination of the Initial Service:**\n    The patient received a chemotherapy infusion, a therapeutic infusion, and hydration. According to the specified hierarchy, chemotherapy is the highest-ranking service. Therefore, the initial service code must be for the chemotherapy infusion.\n\n2.  **Coding the Chemotherapy Infusion:**\n    The chemotherapy infusion lasted for a total of $95$ minutes. CPT coding for prolonged services is based on time blocks.\n    -   The first hour of service (minutes $1$ through $60$) is reported as the initial service. The appropriate code is CPT $96413$ (Initial chemotherapy infusion, up to $1$ hour), which corresponds to $3.40$ RVUs.\n    -   The remaining time is $95 - 60 = 35$ minutes. The rule for additional hours requires reporting CPT $96415$ for each additional hour of infusion. Conventionally, a unit of time is reportable once more than half of that unit has been completed. Since $35$ minutes is greater than half of an hour ($30$ minutes), one additional hour of chemotherapy infusion is reportable. The code is CPT $96415$ (Each additional hour of chemotherapy infusion), corresponding to $1.60$ RVUs.\n\n3.  **Coding the Concurrent Hydration:**\n    A hydration infusion was administered concurrently with the chemotherapy for $40$ minutes. While standard CPT guidelines often preclude separate reporting of concurrent hydration, this problem must be treated as a self-contained system. The problem provides a code, CPT $96368$, described as a \"Concurrent infusion add-on\" with $0.80$ RVUs. Given that a concurrent infusion service was rendered and a corresponding code is provided within the problem's defined set of rules, it is appropriate to report it.\n    -   The code for the concurrent service is CPT $96368$, which adds $0.80$ RVUs.\n\n4.  **Coding the Sequential Therapeutic Infusion:**\n    After the chemotherapy was complete, a sequential infusion of a therapeutic antibiotic (Drug B) was administered for $30$ minutes. This is an additional infusion of a new therapeutic drug.\n    -   The appropriate code is CPT $96367$ (Additional sequential infusion of a new therapeutic/prophylactic/diagnostic substance/drug, up to $1$ hour). The duration of $30$ minutes falls within the \"up to $1$ hour\" parameter. This service corresponds to $1.20$ RVUs.\n\n5.  **Coding the Intravenous (IV) Push:**\n    An antiemetic was administered as an IV push. This is a therapeutic/prophylactic substance distinct from the chemotherapy agent. An IV push of a non-chemotherapy substance is a separately reportable service.\n    -   The code is CPT $96375$ (Intravenous push of a new therapeutic/prophylactic/diagnostic substance/drug), which corresponds to $0.70$ RVUs.\n\n6.  **Coding the Intramuscular (IM) Injection:**\n    An IM injection of vitamin B12 was given. This service involves a different route of administration (intramuscular) and is not part of the intravenous service hierarchy. It is therefore a distinct and separately reportable procedure.\n    -   The code is CPT $96372$ (Intramuscular injection), which corresponds to $0.60$ RVUs.\n\n7.  **Calculation of Total RVUs and Final Payment:**\n    The total RVUs for the encounter is the sum of the RVUs for all reportable codes.\n    $$ \\text{Total RVU} = \\text{RVU}_{96413} + \\text{RVU}_{96415} + \\text{RVU}_{96368} + \\text{RVU}_{96367} + \\text{RVU}_{96375} + \\text{RVU}_{96372} $$\n    $$ \\text{Total RVU} = 3.40 + 1.60 + 0.80 + 1.20 + 0.70 + 0.60 = 8.30 $$\n    The total payment is calculated by multiplying the total RVUs by the conversion factor, $C = 36.00$ dollars per RVU.\n    $$ \\text{Total Payment} = (\\text{Total RVU}) \\times C $$\n    $$ \\text{Total Payment} = 8.30 \\times 36.00 = 298.8 $$\n    The problem requests the answer to be rounded to four significant figures. The calculated value $298.8$ already consists of four significant figures.\n\nThus, the total professional payment for this encounter is $298.80$ USD.",
            "answer": "$$\n\\boxed{298.8}\n$$"
        },
        {
            "introduction": "The principles of accurate coding are not just for manual application; they form the basis of the automated validation engines that power modern healthcare administration. This practice  challenges you to transition from the role of a coder to that of an informatics professional by building a claim validator from first principles. By translating CPT's structural, referential, and relational rules into a runnable program, you will gain hands-on experience in how medical informatics applies formal logic to ensure data integrity and compliance at scale.",
            "id": "4831697",
            "problem": "You are given a simplified validation and referential integrity task grounded in the Current Procedural Terminology (CPT) coding system. The goal is to implement a deterministic validator that enforces format constraints on CPT codes and modifiers, checks existence of codes against a versioned master set, and verifies referential integrity among related identifiers, all using first-principles from relational database theory and formal languages.\n\nFundamental base used for the derivation:\n- Relational Model of Data: A relation consists of tuples over attributes; a primary key uniquely identifies tuples; a foreign key must reference an existing primary key in the referenced relation. Referential integrity is the requirement that for every foreign key value $f$, there exists a matching primary key value $p$ in the referenced relation.\n- Formal Language Theory: a regular language can be recognized by a deterministic finite automaton (DFA) or matched by a regular expression; membership in a finite set can be decided by set containment.\n- CPT context: For this exercise, a CPT code is modeled as a string of exactly $5$ digits. A modifier, if present, is modeled as exactly $2$ uppercase letters or digits. Validity of a CPT code is defined by membership in a provided master set for the specific test case.\n\nYou must implement a program that validates a list of claims. Each claim is a collection of claim lines, and each claim line is a tuple with the following attributes:\n- line identifier (string),\n- claim identifier (string),\n- CPT code (string),\n- quantity (integer),\n- modifier (string; empty string means no modifier),\n- order identifier (string; empty string means no order),\n- parent line identifier (string; empty string means no parent).\n\nValidation rules to implement:\n- Format validation:\n  - CPT code must consist of exactly $5$ digits.\n  - If a modifier is present (non-empty string), it must be exactly $2$ characters, each an uppercase letter $A$–$Z$ or a digit $0$–$9$.\n- Code existence:\n  - CPT code must exist in the provided master set for the case.\n- Referential integrity:\n  - If an order identifier is present, it must exist in the provided set of valid orders.\n  - If a parent line identifier is present, it must refer to an existing line identifier within the same claim and must not be equal to its own line identifier.\n  - Line identifiers must be unique within a claim.\n- Add-on requirement:\n  - A provided mapping associates certain CPT codes (add-on codes) to one or more required base CPT codes. If a claim line’s CPT code appears as a key in the mapping, then at least one of the required base CPT codes must also appear as a CPT code in another line of the same claim.\n\nInput specification within the program:\n- Each test case is a tuple containing:\n  - a master set of CPT codes (set of strings),\n  - an add-on mapping (dictionary from string to list of strings),\n  - a set of valid order identifiers (set of strings),\n  - a list of claims; each claim is a dictionary with a claim identifier and a list of line dictionaries. Each line dictionary contains the attributes described above.\n\nOutput specification:\n- For each test case, produce a boolean indicating whether all claims in that test case pass all validation rules.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[True,False,True]\").\n\nTest suite to cover different facets:\n- Case $1$ (happy path): Master codes {\"11111\",\"12345\",\"54321\",\"77777\"}; add-on mapping {\"12345\": [\"11111\"]}; valid orders {\"ORD1\"}; claim \"C1\" has three lines: \n  - line \"L1\": code \"11111\", quantity $1$, modifier \"26\", no order, no parent;\n  - line \"L2\": code \"12345\", quantity $1$, modifier \"AA\", no order, no parent;\n  - line \"L3\": code \"54321\", quantity $2$, empty modifier, order \"ORD1\", no parent.\n  Expected result: True.\n- Case $2$ (code format boundary): Master codes {\"22222\"}; no add-ons; no orders; claim \"C2\" has one line with code \"2222\" (only $4$ digits), quantity $1$, empty modifier, no order, no parent. Expected result: False.\n- Case $3$ (modifier format edge): Master codes {\"33333\"}; no add-ons; no orders; claim \"C3\" has one line with code \"33333\", quantity $1$, modifier \"A*\", no order, no parent. Expected result: False.\n- Case $4$ (add-on without base): Master codes {\"11111\",\"12345\"}; add-on mapping {\"12345\": [\"11111\"]}; no orders; claim \"C4\" has one line with code \"12345\", quantity $1$, empty modifier, no order, no parent. Expected result: False.\n- Case $5$ (missing parent reference): Master codes {\"44444\"}; no add-ons; no orders; claim \"C5\" has one line with code \"44444\", quantity $1$, empty modifier, no order, parent \"L999\" (nonexistent). Expected result: False.\n- Case $6$ (referential integrity satisfied): Master codes {\"55555\",\"66666\"}; no add-ons; valid orders {\"ORD9\",\"ORD8\"}; claim \"C6\" has two lines:\n  - line \"L1\": code \"55555\", quantity $1$, modifier \"99\", order \"ORD9\", no parent;\n  - line \"L2\": code \"66666\", quantity $3$, modifier \"B2\", empty order, parent \"L1\".\n  Expected result: True.\n- Case $7$ (duplicate line identifiers): Master codes {\"77777\"}; no add-ons; no orders; claim \"C7\" has two lines both with line identifier \"L1\" and code \"77777\", quantities $1$, empty modifiers, no orders, no parents. Expected result: False.\n\nImplement the validator according to the rules above and apply it to the provided test suite. Your program should produce the single-line output in the specified format.",
            "solution": "The problem requires the implementation of a deterministic validator for a simplified model of medical claims, based on the Current Procedural Terminology (CPT) system. The validation process is grounded in first principles from relational database theory and formal language theory. A given test case is considered valid if and only if all claims within it adhere to a specific set of rules. The solution is architected as a hierarchical validator that processes each claim and its constituent lines systematically.\n\nThe core of the solution is a function that validates a single claim. A claim is a collection of lines, which can be viewed as a relation where each line is a tuple. The validation of a claim proceeds in three main stages: enforcing entity integrity for line identifiers, performing line-level validation against format and existence constraints, and finally, verifying inter-line referential integrity and other relational constraints.\n\nFirst, a preliminary check ensures the uniqueness of the `$line\\_identifier$` for all lines within a single claim. This corresponds to the entity integrity constraint in the relational model, where a primary key must uniquely identify each tuple in a relation. We achieve this by collecting all `$line\\_identifier$` values into a list and comparing its size to the size of a set constructed from the same values. If the sizes differ, a duplicate `$line\\_identifier$` exists, and the claim is invalid. This pre-computed set of unique `$line\\_identifier$`s is also used later for efficient referential integrity checks.\n\nSecond, each line in the claim is individually validated against a series of rules. This stage involves checks that can be performed on a single line tuple, sometimes with reference to external master data sets but not to other lines in the same claim.\n- **Format Validation**: This is an application of formal language theory. We verify that the `$CPT\\_code$` and `$modifier$` strings belong to specified regular languages. A valid `$CPT\\_code$` must match the pattern of exactly $5$ digits (equivalent to the regular expression `\\d{5}`). A non-empty `$modifier$` must match the pattern of exactly $2$ alphanumeric, uppercase characters (equivalent to `[A-Z0-9]{2}`). This is implemented by checking the string length and iterating through its characters to verify they fall within the allowed character sets, `$0-9$` and `$A-Z$`.\n- **Existence Validation**: This is a direct application of set theory. The `$CPT\\_code$` of a line must exist in the provided `$master\\_set$ of CPT codes. This is a simple membership test: `cpt_code` $\\in$ `master_set`.\n- **Referential Integrity (External)**: This applies the relational model's principle of referential integrity for foreign keys pointing to external relations. If a line contains a non-empty `$order\\_identifier$`, this value is treated as a foreign key that must reference a primary key in the `valid_orders` relation. This is implemented as a set membership test: `order_identifier` $\\in$ `valid_orders`.\n\nThird, after all lines have passed individual validation, claim-level checks that involve relationships between lines are performed. This stage ensures the internal consistency of the claim relation itself.\n- **Referential Integrity (Internal)**: A non-empty `$parent\\_line\\_identifier$` acts as a self-referencing foreign key. It must point to an existing `$line\\_identifier$` within the same claim. The validation ensures two conditions: the value of `$parent\\_line\\_identifier$` exists in the pre-computed set of the claim's line identifiers, and it is not a self-reference (`$parent\\_line\\_identifier$` $\\neq$ the line's own `$line\\_identifier$`).\n- **Add-on Requirement**: This is the most complex relational constraint. If a line's `$CPT\\_code$` is designated as an add-on code in the `$add\\_on\\_mapping$`, then at least one of its specified base codes must be present on a different line within the same claim. To implement this check, the algorithm iterates through each line. If the line's `$CPT\\_code$` is an add-on, it then scans all *other* lines in the claim, checking if any of their `$CPT\\_code$`s match one of the required base codes. If no such base code is found on any other line, the validation fails. This process is conceptually analogous to executing a dependent subquery or a join in a relational database to verify a condition across related tuples.\n\nA claim is deemed valid only if all its lines pass all applicable validation steps. The overall test case is valid only if every single claim within it is valid. If any check at any level fails, the validation process for that test case terminates immediately with a result of `False`.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the validator.\n    \"\"\"\n    test_cases = [\n        # Case 1: Happy path\n        (\n            {\"11111\", \"12345\", \"54321\", \"77777\"},\n            {\"12345\": [\"11111\"]},\n            {\"ORD1\"},\n            [\n                {\n                    \"claim_id\": \"C1\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"11111\", \"quantity\": 1, \"modifier\": \"26\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                        {\"line_id\": \"L2\", \"cpt_code\": \"12345\", \"quantity\": 1, \"modifier\": \"AA\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                        {\"line_id\": \"L3\", \"cpt_code\": \"54321\", \"quantity\": 2, \"modifier\": \"\", \"order_id\": \"ORD1\", \"parent_line_id\": \"\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 2: CPT code format boundary (4 digits)\n        (\n            {\"22222\"},\n            {},\n            {},\n            [\n                {\n                    \"claim_id\": \"C2\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"2222\", \"quantity\": 1, \"modifier\": \"\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 3: Modifier format edge (invalid character)\n        (\n            {\"33333\"},\n            {},\n            {},\n            [\n                {\n                    \"claim_id\": \"C3\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"33333\", \"quantity\": 1, \"modifier\": \"A*\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 4: Add-on without base\n        (\n            {\"11111\", \"12345\"},\n            {\"12345\": [\"11111\"]},\n            {},\n            [\n                {\n                    \"claim_id\": \"C4\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"12345\", \"quantity\": 1, \"modifier\": \"\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 5: Missing parent reference\n        (\n            {\"44444\"},\n            {},\n            {},\n            [\n                {\n                    \"claim_id\": \"C5\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"44444\", \"quantity\": 1, \"modifier\": \"\", \"order_id\": \"\", \"parent_line_id\": \"L999\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 6: Referential integrity satisfied\n        (\n            {\"55555\", \"66666\"},\n            {},\n            {\"ORD9\", \"ORD8\"},\n            [\n                {\n                    \"claim_id\": \"C6\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"55555\", \"quantity\": 1, \"modifier\": \"99\", \"order_id\": \"ORD9\", \"parent_line_id\": \"\"},\n                        {\"line_id\": \"L2\", \"cpt_code\": \"66666\", \"quantity\": 3, \"modifier\": \"B2\", \"order_id\": \"\", \"parent_line_id\": \"L1\"},\n                    ]\n                }\n            ]\n        ),\n        # Case 7: Duplicate line identifiers\n        (\n            {\"77777\"},\n            {},\n            {},\n            [\n                {\n                    \"claim_id\": \"C7\",\n                    \"lines\": [\n                        {\"line_id\": \"L1\", \"cpt_code\": \"77777\", \"quantity\": 1, \"modifier\": \"\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                        {\"line_id\": \"L1\", \"cpt_code\": \"77777\", \"quantity\": 1, \"modifier\": \"\", \"order_id\": \"\", \"parent_line_id\": \"\"},\n                    ]\n                }\n            ]\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(validate_test_case(case))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_test_case(case_data):\n    \"\"\"\n    Validates an entire test case. A case is valid if all its claims are valid.\n    \"\"\"\n    master_codes, addon_map, valid_orders, claims = case_data\n    for claim in claims:\n        if not validate_claim(claim['lines'], master_codes, addon_map, valid_orders):\n            return False\n    return True\n\ndef validate_claim(lines, master_codes, addon_map, valid_orders):\n    \"\"\"\n    Validates a single claim by checking all its lines against all rules.\n    \"\"\"\n    # Rule: Line identifiers must be unique within a claim.\n    line_ids_list = [line['line_id'] for line in lines]\n    if len(line_ids_list) != len(set(line_ids_list)):\n        return False\n    line_id_set = set(line_ids_list)\n\n    # First pass: validate individual line properties (format, existence, external refs)\n    for line in lines:\n        # Rule: CPT code must consist of exactly 5 digits.\n        cpt_code = line['cpt_code']\n        if not (isinstance(cpt_code, str) and len(cpt_code) == 5 and cpt_code.isdigit()):\n            return False\n\n        # Rule: Modifier, if present, must be 2 uppercase alphanumeric characters.\n        modifier = line['modifier']\n        if modifier:\n            if not(isinstance(modifier, str) and len(modifier) == 2):\n                return False\n            for char in modifier:\n                if not (char.isdigit() or ('A' = char = 'Z')):\n                    return False\n\n        # Rule: CPT code must exist in the master set.\n        if cpt_code not in master_codes:\n            return False\n\n        # Rule: Order identifier, if present, must be in the valid set.\n        order_id = line['order_id']\n        if order_id and order_id not in valid_orders:\n            return False\n\n        # Rule: Parent line identifier, if present, must refer to an existing line.\n        parent_line_id = line['parent_line_id']\n        if parent_line_id:\n            if parent_line_id not in line_id_set:\n                return False\n            # Rule: ... and must not be equal to its own line identifier.\n            if parent_line_id == line['line_id']:\n                return False\n\n    # Second pass: validate inter-line relationships (add-on requirement)\n    for line in lines:\n        cpt_code = line['cpt_code']\n        # Rule: Check add-on requirement.\n        if cpt_code in addon_map:\n            required_bases = set(addon_map[cpt_code])\n            found_base_on_other_line = False\n            for other_line in lines:\n                if line['line_id'] != other_line['line_id']:\n                    if other_line['cpt_code'] in required_bases:\n                        found_base_on_other_line = True\n                        break\n            if not found_base_on_other_line:\n                return False\n\n    return True\n\nsolve()\n```"
        }
    ]
}