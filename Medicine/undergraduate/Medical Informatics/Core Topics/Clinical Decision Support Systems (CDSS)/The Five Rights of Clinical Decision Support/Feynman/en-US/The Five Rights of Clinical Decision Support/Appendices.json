{
    "hands_on_practices": [
        {
            "introduction": "The Five Rights of Clinical Decision Support (CDS) provide a crucial framework for designing effective interventions, but they are more than just a memorable checklist. To build robust and safe systems, we must be able to define these principles with formal precision. This first practice  challenges you to do just that by applying a formal model of the \"Right Person\" constraint, using concepts of scope of practice and accountability to analyze a realistic clinical scenario. This exercise will strengthen your ability to think critically and logically about the rules that govern who should receive a CDS alert.",
            "id": "4860766",
            "problem": "An inpatient electronic health record contains an early warning intervention built as Clinical Decision Support (CDS), defined by the widely accepted five rights: deliver the right information to the right person in the right format via the right channel at the right time in workflow. Consider the following formal model to ground the analysis of the right person constraint.\n\nLet $\\mathcal{U}$ be the set of clinicians and $\\mathcal{A}$ the set of allowable clinical actions. For each clinician $u \\in \\mathcal{U}$, let $S(u) \\subseteq \\mathcal{A}$ denote the clinician’s scope of practice, defined as the set of actions $u$ is legally authorized and credentialed to execute without requiring another clinician’s cosign at the time of execution. For a patient case $p$, a sepsis alert instantiates a recommendation bundle $B \\subseteq \\mathcal{A}$ that includes actions that require ordering privileges (for example, ordering a lactate, blood cultures, fluid bolus, and broad-spectrum antibiotics). Assume $|B| = 4$.\n\nDefine an accountability chain on the care team as a strict partial order $\\prec$ over a subset $\\mathcal{U}_p \\subseteq \\mathcal{U}$ such that $u \\prec v$ means $u$ reports to $v$ for case $p$, and define the accountable set $\\mathcal{R}(p) \\subseteq \\mathcal{U}_p$ as those clinicians assigned direct responsibility for executing or delegating actions for $p$ with clear legal accountability. A routing function $r$ maps alerts to recipients, $r(p, B) \\in \\mathcal{U}_p$.\n\nThe right person property is satisfied for alert $(p, B)$ routed to $u$ if and only if both of the following conditions hold: (i) $B \\subseteq S(u)$, and (ii) $u \\in \\mathcal{R}(p)$. This encodes that the recipient must be both authorized to execute the recommended actions and situated in the accountability structure for the case. Assume time-to-act constraints are enforced elsewhere (right time) and do not alter the right person definition.\n\nSuppose a trainee $T \\in \\mathcal{U}_p$ has no ordering privileges for $p$, so $B \\nsubseteq S(T)$, and $T \\prec A$ for attending $A \\in \\mathcal{U}_p$, with $B \\subseteq S(A)$ and $A \\in \\mathcal{R}(p)$. The CDS is currently configured to route the sepsis alert to $T$ alone, i.e., $r(p, B) = T$.\n\nWhich option gives the most correct formal argument, using accountability chains and scope of practice, for why routing the sepsis alert to $T$ violates the right person constraint as defined above?\n\nA. Since $B \\nsubseteq S(T)$, the predicate “right person” fails at $T$ regardless of the existence of $A$ with $B \\subseteq S(A)$. The right person property is recipient-local: for $u = T$, (i) fails. Additionally, $T \\prec A$ implies $T$ is non-maximal with respect to authority in the accountability chain for $p$, reinforcing that $T$ lacks direct accountability to execute $B$. Therefore, $r(p, B) = T$ violates the right person constraint.\n\nB. Because $T \\prec A$ and there exists $A$ such that $B \\subseteq S(A)$ and $A \\in \\mathcal{R}(p)$, routing to $T$ is acceptable: $T$ can escalate along the accountability chain to $A$, so the team collectively satisfies $B \\subseteq S(T) \\cup S(A)$, preserving the right person property.\n\nC. The right person constraint is satisfied if $T$ can initiate communication within $\\Delta t = 60$ minutes to any $v$ with $B \\subseteq S(v)$. Since $T$ can page $A$ in $10$ minutes, routing to $T$ maintains the right person property via timely delegation along $\\prec$.\n\nD. The sepsis alert is informational, not actionable, so the right person condition reduces to membership in $\\mathcal{U}_p$; because $T \\in \\mathcal{U}_p$, routing to $T$ satisfies the right person constraint regardless of $S(T)$.",
            "solution": "The problem provides a formal definition for the \"right person\" property, which requires two conditions to be met for a recipient $u$: (i) the recommended actions $B$ must be within the recipient's scope of practice, $B \\subseteq S(u)$, and (ii) the recipient must be in the accountable set, $u \\in \\mathcal{R}(p)$.\n\nThe alert is routed to the trainee $T$, so we must evaluate these conditions for the recipient $u=T$. The problem states that the trainee \"has no ordering privileges,\" which formally means the recommended action bundle $B$ is not a subset of the trainee's scope of practice, i.e., $B \\nsubseteq S(T)$.\n\nSince condition (i) is false, the entire \"right person\" predicate, which is a logical conjunction of (i) AND (ii), is necessarily false. Therefore, routing the alert to $T$ violates the right person constraint. The existence of an attending physician $A$ who *does* satisfy the conditions is irrelevant to the evaluation for the actual recipient, $T$.\n\n- **Option A** correctly identifies this failure of condition (i) as the definitive reason for the violation, noting that the property is \"recipient-local.\" This is the correct formal argument.\n- **Option B** incorrectly suggests a \"collective\" or team-based scope of practice, which contradicts the provided individual-based definition.\n- **Option C** incorrectly introduces time constraints and delegation, which the problem explicitly excludes from the definition of the \"right person.\"\n- **Option D** incorrectly reclassifies the actionable alert (which contains orders) as merely \"informational\" in an attempt to bypass the scope of practice requirement. This contradicts the problem description.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "In an ideal world, we would maximize all Five Rights simultaneously. However, in the complex reality of clinical settings, these principles can sometimes be in tension with one another. This next exercise  explores a common design trade-off where an attempt to improve the \"Right Time\" inadvertently degrades the accuracy of reaching the \"Right Person.\" Using fundamental probability theory, you will quantify the net impact of this design change on user adherence, learning a valuable lesson in the importance of holistic, systems-level analysis when designing CDS.",
            "id": "4860710",
            "problem": "A hospital implements Clinical Decision Support (CDS), defined as software that delivers patient-specific assessments or recommendations to clinicians at the point of care, to uphold the five rights: right information, right person, right intervention format, right channel, and right time/place. Consider an allergy-check alert for initiating a high-risk antibiotic. The CDS team considers shifting the alert earlier in the medication ordering workflow to improve the right time/place, but doing so triggers a routing constraint: the identity of the ordering prescriber is not yet known at the earlier point, so the alert is probabilistically routed to a pool intended for triage nurses instead of the prescribing physician.\n\nUse the following scientifically plausible parameters. At the later time (after order signing), identity resolution is strong and routing targets the prescribing physician with probability $0.95$, while $0.05$ goes to the triage nurse pool. At the earlier time (during order entry initiation), routing goes to the prescribing physician with probability $0.30$ and to the triage nurse pool with probability $0.70$ due to incomplete identity resolution at that step.\n\nLet adherence be the probability that the recipient performs the recommended action (e.g., resolves the allergy conflict). At the later time, the adherence probability when the prescribing physician receives the alert is $0.48$, and when the triage nurse receives it is $0.15$. At the earlier time, the adherence probability when the prescribing physician receives the alert increases to $0.62$, and when the triage nurse receives it increases to $0.25$, reflecting better timing for acting before the order is finalized. All probabilities are empirically estimated and are independent across orders.\n\nStarting from the core definitions of probability and conditioning, compute the expected adherence at the later time and at the earlier time by appropriately combining routing probabilities and conditional adherence probabilities. Then compute the net effect on adherence, defined as $\\Delta A = A_{\\text{early}} - A_{\\text{late}}$, where $A_{\\text{early}}$ and $A_{\\text{late}}$ are the expected adherence probabilities under earlier and later timing, respectively.\n\nExpress the net effect $\\Delta A$ as a unitless decimal. Round your answer to four significant figures. Do not use a percentage sign.",
            "solution": "The problem asks for the expected adherence probability at two different times, \"late\" and \"early,\" and the net change between them. We can calculate these expected probabilities using the law of total probability, conditioning on whether the alert is routed to a physician or a nurse.\n\nLet $A_{\\text{late}}$ be the expected adherence at the later time and $A_{\\text{early}}$ be the expected adherence at the earlier time.\n\n**Expected Adherence at the Later Time ($A_{\\text{late}}$)**\nThe probability is the sum of the adherence probabilities for each recipient path (physician or nurse):\n$$A_{\\text{late}} = P(\\text{adhere} | \\text{physician}) P(\\text{physician}) + P(\\text{adhere} | \\text{nurse}) P(\\text{nurse})$$\nUsing the given values:\n$$A_{\\text{late}} = (0.48)(0.95) + (0.15)(0.05)$$\n$$A_{\\text{late}} = 0.456 + 0.0075 = 0.4635$$\n\n**Expected Adherence at the Earlier Time ($A_{\\text{early}}$)**\nSimilarly, we calculate the expected adherence using the probabilities for the earlier time:\n$$A_{\\text{early}} = (0.62)(0.30) + (0.25)(0.70)$$\n$$A_{\\text{early}} = 0.186 + 0.175 = 0.361$$\n\n**Net Effect ($\\Delta A$)**\nThe net effect on adherence is the difference between the early and late adherence probabilities:\n$$\\Delta A = A_{\\text{early}} - A_{\\text{late}}$$\n$$\\Delta A = 0.361 - 0.4635 = -0.1025$$\n\nThe result, expressed as a unitless decimal with four significant figures, is $-0.1025$.",
            "answer": "$$\\boxed{-0.1025}$$"
        },
        {
            "introduction": "Moving from theory to practice, our final exercise puts you in the role of a CDS developer. A key challenge in health informatics is inferring a clinician's immediate task from a stream of raw interaction data to deliver an alert at the \"Right Time in Workflow.\" This hands-on coding problem  guides you through building a simple but powerful algorithm based on a state machine model to detect a medication ordering context. You will then evaluate your algorithm's performance against ground-truth data, gaining practical experience in the core task of computational context-awareness in CDS.",
            "id": "4860764",
            "problem": "You are given a sequence modeling task grounded in the Five Rights of Clinical Decision Support (CDS), which specify that CDS interventions should deliver the Right Information to the Right Person in the Right Intervention Format via the Right Channel at the Right Time in Workflow. From the perspective of Electronic Health Record (EHR) event analytics, the Right Time in Workflow dimension requires detecting whether a clinician is actively engaged in a medication ordering activity so that an intervention can be displayed without interrupting unrelated work. Formally, you must infer a binary medication-ordering state from EHR event logs using a deterministic and reproducible algorithm based on first principles, and then validate this inference against annotated ground truth by calculating precision and recall.\n\nFundamental base:\n- Clinical Decision Support (CDS) Five Rights are treated as a foundational constraint: a CDS intervention must be shown at the Right Time in Workflow and to the Right Person. In computational terms, this implies that state inference should be scoped to the correct user and patient context, and it should activate only during medication ordering tasks.\n- Deterministic Finite Automaton (DFA): A DFA over discrete events can model workflow context. A DFA comprises a finite set of states and deterministic transitions on events. This is widely accepted in computer science for modeling interaction sequences.\n- Information retrieval metrics: Precision and recall are defined on sets of predicted positives and actual positives. Let $\\mathrm{TP}$ denote true positives, $\\mathrm{FP}$ denote false positives, and $\\mathrm{FN}$ denote false negatives. Then precision is $\\mathrm{precision} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FP}}$ and recall is $\\mathrm{recall} = \\frac{\\mathrm{TP}}{\\mathrm{TP}+\\mathrm{FN}}$. If a denominator is $0$, define the corresponding metric as $1$ by convention to avoid undefined values while preserving monotonic behavior with respect to errors.\n\nTask:\n1. Construct a deterministic context detection algorithm that, for each event, labels whether the medication ordering context is active for the tuple $(\\text{user}, \\text{patient})$ at that moment. Use a DFA whose states include a baseline inactive state and at least one active state indicating medication order composition. The DFA must:\n   - Maintain independent contexts per $(\\text{user}, \\text{patient})$ pair to satisfy the Right Person constraint.\n   - Activate on events that deterministically indicate entry into the order composition (for example, opening the order composer).\n   - Remain active on events that involve order entry steps (for example, entering dose or route, adding to cart).\n   - Deactivate on events that deterministically terminate the composition (for example, signing orders, cancelling, closing the composer).\n   - Immediately clear all active contexts for a given user on an event that switches the patient for that user.\n   - Label each event as positive (active) if and only if the ordering context is active for its $(\\text{user}, \\text{patient})$ immediately after processing the event’s transition, with the special case that an event that terminates the composition is labeled positive if and only if the context was active immediately before termination.\n\n2. Compute $\\mathrm{precision}$ and $\\mathrm{recall}$ of your predicted labels versus ground-truth annotations for each test case. Return each metric as a decimal in $[0,1]$, rounded to $3$ decimal places.\n\nEvents:\nEach event is a tuple $(t, u, p, e)$, where $t$ is a timestamp as an integer, $u$ is a user identifier as a string, $p$ is a patient identifier as a string, and $e$ is the event type as a string. The event space includes at least the following tokens: `open_patient_chart`, `search_medication`, `open_order_composer`, `enter_dose`, `enter_route`, `add_to_cart`, `view_lab`, `sign_orders`, `cancel`, `close_order_composer`, `switch_patient`, `view_note`. You may assume the events are already ordered by increasing $t$ within each test case.\n\nTest suite:\nProvide results for the following cases. For each case, the second item is the ground-truth binary label sequence corresponding positionally to the events. A label of $1$ indicates the ordering context is active; a label of $0$ indicates inactive.\n\n- Case $1$ (happy path, single user and patient):\n  Events:\n  $(1,`U1`,`P1`,`open_patient_chart`)$,\n  $(2,`U1`,`P1`,`search_medication`)$,\n  $(3,`U1`,`P1`,`open_order_composer`)$,\n  $(4,`U1`,`P1`,`enter_dose`)$,\n  $(5,`U1`,`P1`,`enter_route`)$,\n  $(6,`U1`,`P1`,`add_to_cart`)$,\n  $(7,`U1`,`P1`,`view_lab`)$,\n  $(8,`U1`,`P1`,`sign_orders`)$,\n  $(9,`U1`,`P1`,`view_lab`)$.\n  Ground truth: $[0,0,1,1,1,1,1,1,0]$.\n\n- Case $2$ (no ordering activity, noise only):\n  Events:\n  $(1,`U1`,`P1`,`open_patient_chart`)$,\n  $(2,`U1`,`P1`,`view_lab`)$,\n  $(3,`U1`,`P1`,`view_note`)$.\n  Ground truth: $[0,0,0]$.\n\n- Case $3$ (abandoned composer and patient switch):\n  Events:\n  $(1,`U1`,`P1`,`open_patient_chart`)$,\n  $(2,`U1`,`P1`,`open_order_composer`)$,\n  $(3,`U1`,`P1`,`enter_dose`)$,\n  $(4,`U1`,`P1`,`close_order_composer`)$,\n  $(5,`U1`,`P1`,`search_medication`)$,\n  $(6,`U1`,`P2`,`switch_patient`)$,\n  $(7,`U1`,`P2`,`open_order_composer`)$,\n  $(8,`U1`,`P2`,`enter_route`)$,\n  $(9,`U1`,`P2`,`cancel`)$.\n  Ground truth: $[0,1,1,1,0,0,1,1,1]$.\n\n- Case $4$ (interleaved activities across users, same patient):\n  Events:\n  $(1,`U1`,`P1`,`open_order_composer`)$,\n  $(2,`U2`,`P1`,`open_patient_chart`)$,\n  $(3,`U1`,`P1`,`enter_dose`)$,\n  $(4,`U2`,`P1`,`search_medication`)$,\n  $(5,`U2`,`P1`,`open_order_composer`)$,\n  $(6,`U1`,`P1`,`sign_orders`)$,\n  $(7,`U2`,`P1`,`enter_route`)$,\n  $(8,`U2`,`P1`,`sign_orders`)$.\n  Ground truth: $[1,0,1,0,1,1,1,1]$.\n\n- Case $5$ (missing composer open, human-annotated ordering):\n  Events:\n  $(1,`U1`,`P1`,`open_patient_chart`)$,\n  $(2,`U1`,`P1`,`search_medication`)$,\n  $(3,`U1`,`P1`,`enter_dose`)$,\n  $(4,`U1`,`P1`,`enter_route`)$,\n  $(5,`U1`,`P1`,`add_to_cart`)$,\n  $(6,`U1`,`P1`,`sign_orders`)$.\n  Ground truth: $[0,0,1,1,1,1]$.\n\n- Case $6$ (spurious composer open, immediately cancelled):\n  Events:\n  $(1,`U1`,`P1`,`open_patient_chart`)$,\n  $(2,`U1`,`P1`,`open_order_composer`)$,\n  $(3,`U1`,`P1`,`cancel`)$.\n  Ground truth: $[0,0,0]$.\n\nOutput specification:\n- For each case, compute $\\mathrm{precision}$ and $\\mathrm{recall}$ as decimals in $[0,1]$ rounded to $3$ decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order: $[\\text{precision}_{1},\\text{recall}_{1},\\text{precision}_{2},\\text{recall}_{2},\\ldots]$ for all cases.",
            "solution": "The task is to implement a Deterministic Finite Automaton (DFA) to infer a \"medication-ordering\" state from EHR event logs and evaluate its performance using precision and recall.\n\n#### DFA Design\nThe algorithm maintains an independent state (`INACTIVE` or `ACTIVE`) for each `(user, patient)` context. State transitions are defined by event types:\n- **Activation Events**: `open_order_composer` transitions the state to `ACTIVE`.\n- **Termination Events**: `sign_orders`, `cancel`, `close_order_composer` transition the state to `INACTIVE`.\n- **Neutral Events**: All other events do not change the state.\n- **Context-Reset**: `switch_patient` resets all contexts for that user to `INACTIVE`.\n\n#### Label Prediction Logic\nFor each event, a binary label is predicted based on the context's state:\n- For a **terminating event**, the label is based on the state *before* the transition.\n- For all **other events**, the label is based on the state *after* the transition.\n\n#### Evaluation\nThe predicted labels are compared against the ground-truth labels to calculate True Positives (TP), False Positives (FP), and False Negatives (FN). Precision and recall are then computed using the standard formulas:\n- $\\text{precision} = \\frac{\\text{TP}}{\\text{TP}+\\text{FP}}$\n- $\\text{recall} = \\frac{\\text{TP}}{\\text{TP}+\\text{FN}}$\n\nIf a denominator is zero, the metric is defined as $1.0$. The final metrics are rounded to three decimal places. The provided code in the answer block implements this logic to generate the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a DFA-based context detection algorithm for medication ordering,\n    evaluates it against ground truth, and computes precision and recall.\n    \"\"\"\n    test_cases = [\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'search_medication'),\n                (3, 'U1', 'P1', 'open_order_composer'),\n                (4, 'U1', 'P1', 'enter_dose'),\n                (5, 'U1', 'P1', 'enter_route'),\n                (6, 'U1', 'P1', 'add_to_cart'),\n                (7, 'U1', 'P1', 'view_lab'),\n                (8, 'U1', 'P1', 'sign_orders'),\n                (9, 'U1', 'P1', 'view_lab'),\n            ],\n            \"ground_truth\": [0, 0, 1, 1, 1, 1, 1, 1, 0]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'view_lab'),\n                (3, 'U1', 'P1', 'view_note'),\n            ],\n            \"ground_truth\": [0, 0, 0]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'open_order_composer'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U1', 'P1', 'close_order_composer'),\n                (5, 'U1', 'P1', 'search_medication'),\n                (6, 'U1', 'P2', 'switch_patient'),\n                (7, 'U1', 'P2', 'open_order_composer'),\n                (8, 'U1', 'P2', 'enter_route'),\n                (9, 'U1', 'P2', 'cancel'),\n            ],\n            \"ground_truth\": [0, 1, 1, 1, 0, 0, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_order_composer'),\n                (2, 'U2', 'P1', 'open_patient_chart'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U2', 'P1', 'search_medication'),\n                (5, 'U2', 'P1', 'open_order_composer'),\n                (6, 'U1', 'P1', 'sign_orders'),\n                (7, 'U2', 'P1', 'enter_route'),\n                (8, 'U2', 'P1', 'sign_orders'),\n            ],\n            \"ground_truth\": [1, 0, 1, 0, 1, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'search_medication'),\n                (3, 'U1', 'P1', 'enter_dose'),\n                (4, 'U1', 'P1', 'enter_route'),\n                (5, 'U1', 'P1', 'add_to_cart'),\n                (6, 'U1', 'P1', 'sign_orders'),\n            ],\n            \"ground_truth\": [0, 0, 1, 1, 1, 1]\n        },\n        {\n            \"events\": [\n                (1, 'U1', 'P1', 'open_patient_chart'),\n                (2, 'U1', 'P1', 'open_order_composer'),\n                (3, 'U1', 'P1', 'cancel'),\n            ],\n            \"ground_truth\": [0, 0, 0]\n        }\n    ]\n\n    all_results = []\n    \n    ACTIVATION_EVENTS = {'open_order_composer'}\n    TERMINATION_EVENTS = {'sign_orders', 'cancel', 'close_order_composer'}\n    INACTIVE, ACTIVE = 0, 1\n\n    for case in test_cases:\n        events = case[\"events\"]\n        ground_truth = case[\"ground_truth\"]\n        \n        contexts = {}  # (user, patient) -> state\n        predicted_labels = []\n\n        for _, user, patient, event_type in events:\n            context_key = (user, patient)\n            state_before = contexts.get(context_key, INACTIVE)\n            \n            # Special rule for switch_patient\n            if event_type == 'switch_patient':\n                # Invalidate all of the user's sessions\n                for key in list(contexts.keys()):\n                    if key[0] == user:\n                        contexts[key] = INACTIVE\n            \n            # Determine state transition\n            if event_type in ACTIVATION_EVENTS:\n                state_after = ACTIVE\n            elif event_type in TERMINATION_EVENTS:\n                state_after = INACTIVE\n            else:\n                state_after = state_before\n\n            # Determine label based on problem rules\n            if event_type in TERMINATION_EVENTS:\n                label = state_before\n            else:\n                label = state_after\n            \n            predicted_labels.append(label)\n            \n            # Update context state\n            contexts[context_key] = state_after\n\n        # Calculate metrics\n        tp = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 1 and g == 1)\n        fp = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 1 and g == 0)\n        fn = sum(1 for p, g in zip(predicted_labels, ground_truth) if p == 0 and g == 1)\n\n        # Calculate precision\n        if (tp + fp) == 0:\n            precision = 1.0\n        else:\n            precision = tp / (tp + fp)\n\n        # Calculate recall\n        if (tp + fn) == 0:\n            recall = 1.0\n        else:\n            recall = tp / (tp + fn)\n        \n        # Round and append results\n        all_results.append(round(precision, 3))\n        all_results.append(round(recall, 3))\n\n    # Format output as a single string\n    formatted_results = [f\"{r:.3f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}