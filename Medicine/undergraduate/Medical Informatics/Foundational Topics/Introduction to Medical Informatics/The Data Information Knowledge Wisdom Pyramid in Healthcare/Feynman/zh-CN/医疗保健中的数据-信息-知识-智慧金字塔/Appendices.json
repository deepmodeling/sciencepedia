{
    "hands_on_practices": [
        {
            "introduction": "医学信息学的核心任务之一是将原始数据转化为临床决策支持。本练习将引导您完成这一基本过程，从诊断测试的原始数据（阳性/阴性结果）和统计信息（如灵敏度和特异度）出发，运用贝叶斯定理推导出具有临床意义的知识（即患者患病的后验概率）。通过从第一性原理出发进行推导，您将深刻理解在医疗保健领域中，信息是如何被合成为知识的。",
            "id": "4860486",
            "problem": "一家医院实验室正在评估一种二元筛查测试，该测试是数据、信息、知识、智慧（DIKW）流程的一部分。在这个流程中，测试结果和疾病状态的原始观测数据（数据）被总结为操作特性（信息），然后与基线患病率等背景信息结合，以产生后验概率（知识），最终指导临床行动（智慧）。设 $D$ 表示随机选择的患者确实患有该疾病的事件，并设 $+$ 表示阳性测试结果。已知测试的灵敏度为 $0.85$，特异性为 $0.90$，目标人群中的疾病患病率为 $0.20$。\n\n仅从条件概率的定义 $P(A \\mid B) = \\frac{P(A \\cap B)}{P(B)}$ 和全概率定律 $P(B) = P(B \\mid A)P(A) + P(B \\mid \\overline{A})P(\\overline{A})$ 出发，推导后验概率 $P(D \\mid +)$ 关于 $P(+ \\mid D)$、$P(+ \\mid \\overline{D})$、$P(D)$ 和 $P(\\overline{D})$ 的一般表达式。然后，使用给定的灵敏度、特异性和患病率值，计算 $P(D \\mid +)$ 的数值。将最终答案表示为精确分数。不包括单位，也不要四舍五入。",
            "solution": "该问题要求推导在给定阳性测试结果的情况下患病的后验概率 $P(D \\mid +)$ 的表达式，然后使用所提供的数据计算其数值。推导必须从条件概率的基本定义和全概率定律开始。\n\n首先，让我们将给定的信息形式化。\n设 $D$ 为患者患病的事件。\n设 $\\overline{D}$ 为患者未患病的事件。\n设 $+$ 为测试结果为阳性的事件。\n设 $-$ 为测试结果为阴性的事件。\n\n问题提供了以下量：\n1.  测试的灵敏度，即在患者患病的情况下测试结果为阳性的概率：$P(+ \\mid D) = 0.85$。\n2.  测试的特异性，即在患者未患病的情况下测试结果为阴性的概率：$P(- \\mid \\overline{D}) = 0.90$。\n3.  人群中的疾病患病率，即患者患病的先验概率：$P(D) = 0.20$。\n\n推导需要从两个给定的原则开始：\n1.  条件概率的定义：$P(A \\mid B) = \\frac{P(A \\cap B)}{P(B)}$。\n2.  全概率定律：$P(B) = P(B \\mid A)P(A) + P(B \\mid \\overline{A})P(\\overline{A})$。\n\n我们的目标是推导 $P(D \\mid +)$ 的表达式。使用条件概率的定义，我们可以写出：\n$$\nP(D \\mid +) = \\frac{P(D \\cap +)}{P(+)}\n$$\n符号 $P(D \\cap +)$ 表示患者患病且测试为阳性的联合概率。分子可以使用 $P(+ \\mid D)$ 的条件概率定义重新表示：\n$$\nP(+ \\mid D) = \\frac{P(+ \\cap D)}{P(D)}\n$$\n由于交集运算符是可交换的，$P(+ \\cap D) = P(D \\cap +)$。重新整理这个方程可以得到分子的表达式：\n$$\nP(D \\cap +) = P(+ \\mid D) P(D)\n$$\n现在，我们处理分母 $P(+)$，它是测试结果为阳性的总概率。我们使用全概率定律，将样本空间划分为事件 $D$（患病）和 $\\overline{D}$（不患病）。将该定律应用于事件 $+$，我们得到：\n$$\nP(+) = P(+ \\mid D)P(D) + P(+ \\mid \\overline{D})P(\\overline{D})\n$$\n将分子 $P(D \\cap +)$ 和分母 $P(+)$ 的表达式代入我们最初的 $P(D \\mid +)$ 方程，我们得到一般表达式：\n$$\nP(D \\mid +) = \\frac{P(+ \\mid D) P(D)}{P(+ \\mid D)P(D) + P(+ \\mid \\overline{D})P(\\overline{D})}\n$$\n这个表达式是贝叶斯定理的一种形式，按要求从第一性原理推导得出。\n\n接下来，我们使用给定的数据计算 $P(D \\mid +)$ 的数值。我们有：\n- $P(+ \\mid D) = 0.85$ (灵敏度)\n- $P(D) = 0.20$ (患病率)\n\n我们还需要 $P(+ \\mid \\overline{D})$ 和 $P(\\overline{D})$ 的值。\n未患病的概率是患病率的补集：\n$$\nP(\\overline{D}) = 1 - P(D) = 1 - 0.20 = 0.80\n$$\n在未患病的情况下测试为阳性的概率 $P(+ \\mid \\overline{D})$，被称为假阳性率。它是特异性 $P(- \\mid \\overline{D})$ 的补集：\n$$\nP(+ \\mid \\overline{D}) = 1 - P(- \\mid \\overline{D}) = 1 - 0.90 = 0.10\n$$\n现在我们可以将所有数值代入推导出的公式中：\n$$\nP(D \\mid +) = \\frac{(0.85) \\times (0.20)}{(0.85) \\times (0.20) + (0.10) \\times (0.80)}\n$$\n让我们计算乘积：\n- 分子：$0.85 \\times 0.20 = 0.17$\n- 分母中的第一项：$0.85 \\times 0.20 = 0.17$\n- 分母中的第二项：$0.10 \\times 0.80 = 0.08$\n\n将这些结果代回方程：\n$$\nP(D \\mid +) = \\frac{0.17}{0.17 + 0.08} = \\frac{0.17}{0.25}\n$$\n为了将其表示为精确分数，我们可以将小数值写成分数并简化：\n$$\nP(D \\mid +) = \\frac{\\frac{17}{100}}{\\frac{25}{100}} = \\frac{17}{100} \\times \\frac{100}{25} = \\frac{17}{25}\n$$\n因此，在给定阳性测试结果的情况下，患有该疾病的后验概率是 $\\frac{17}{25}$。这个结果代表了DIKW金字塔中的“知识”步骤，在该步骤中，原始数据（个体结果）和信息（灵敏度、特异性、患病率）被综合起来，以生成具有临床意义的概率。",
            "answer": "$$\n\\boxed{\\frac{17}{25}}\n$$"
        },
        {
            "introduction": "在医疗保健领域，大量有价值的信息被锁定在非结构化的临床文本中。本练习将带您进入自然语言处理（NLP）的世界，探索如何将原始的临床笔记（数据）转化为结构化的断言（信息），例如判断“肺炎”是否存在。您将通过构建和评估一个基于规则的否定检测算法，亲身体验如何通过增加上下文知识来显著提升信息提取的准确性，从而做出更明智的表型判定。",
            "id": "4860503",
            "problem": "您会收到一组从电子健康记录（EHR）中提取的简短临床陈述。分析目标是通过设计和评估一个基于规则的自然语言处理（NLP）组件来展示医疗保健领域中的数据、信息、知识、智慧（DIKW）金字塔。该组件将原始文本（$data$）转换为结构化断言（$information$），支持表型决策功能（$knowledge$），并对规则的适用性及其预期影响产生评估性见解（$wisdom$）。我们关注的表型是当前是否存在肺炎。您必须构建一个专门针对短语“no evidence of pneumonia”的否定范围检测算法，并评估其相对于朴素基线的表型特异性和敏感性的影响。\n\n基本基础：\n- 临床语言学惯例：短语“no evidence of $X$”表示在所述上下文中不存在 $X$；这是临床放射学和评估记录中广泛接受的文档模式。\n- 混淆矩阵定义：对于二元分类器，一个带标签的案例数据集会产生真阳性（TP）、假阳性（FP）、真阴性（TN）、假阴性（FN）的计数。敏感性和特异性定义如下\n$$\\text{sensitivity} = \\frac{TP}{TP + FN}, \\quad \\text{specificity} = \\frac{TN}{TN + FP}.$$\n- 序列化分词被建模为按字母单词和子句边界标点符号对字符串进行拆分。\n\n形式化：\n- 设临床陈述为有限字母表上的字符串 $S$。经过小写转换和分词后，$S$ 被映射为词元序列 $\\{t_1, t_2, \\dots, t_n\\}$，其中每个 $t_i$ 要么是一个字母单词，要么是边界符号 $\\{',', ';', '.'\\}$ 之一。\n- 定义边界集 $B = \\{ \\text{'but'}, \\text{'however'}, ',', ';', '.' \\}$。边界词元用于为范围目的切分子句。\n- 定义朴素表型检测器 $g(S)$，当且仅当任何词元等于单词“pneumonia”时，它返回 $1$（表型存在）；否则返回 $0$。\n- 定义改进的检测器 $h(S)$，当且仅当存在至少一个等于“pneumonia”的词元，且该词元不在任何连续出现的三词元短语“no evidence of”的前向范围内时，它返回 $1$。形式上，对于任何满足 $(t_k, t_{k+1}, t_{k+2}) = (\\text{'no'}, \\text{'evidence'}, \\text{'of'})$ 的索引 $k$，定义前向范围区间 $I_k = \\{ k+3, k+4, \\dots, m-1 \\}$，其中 $m$ 是满足 $t_m \\in B$ 的最小索引 $\\ge k+3$，如果不存在这样的边界，则 $m = n+1$。位于位置 $j$ 的词元“pneumonia”如果满足 $\\exists k$ 使得 $j \\in I_k$，则被认为是否定的。如果存在位于某个位置 $j$ 的“pneumonia”词元未被否定，则函数 $h(S)$ 输出 $1$；否则输出 $0$。\n\n您必须实现 $g(S)$ 和 $h(S)$，并在以下带标签的测试集上对它们进行评估。每个案例都是一个元组 $(S, y)$，其中 $S$ 是临床陈述，$y \\in \\{0,1\\}$ 是当前肺炎表型的真实标签。该测试集旨在包括一般情况、边界条件以及与通过标点符号和语篇标记终止范围相关的边缘情况。\n\n测试集（每个 $y$ 是 $\\{0,1\\}$ 中的整数）：\n$1$. $(\\text{\"There is no evidence of pneumonia.\"}, 0)$\n$2$. $(\\text{\"There is evidence of pneumonia.\"}, 1)$\n$3$. $(\\text{\"No evidence of pneumonia or pleural effusion.\"}, 0)$\n$4$. $(\\text{\"No evidence of pneumonia, but mild atelectasis.\"}, 0)$\n$5$. $(\\text{\"Findings compatible with pneumonia.\"}, 1)$\n$6$. $(\\text{\"No evidence of lobar pneumonia seen today.\"}, 0)$\n$7$. $(\\text{\"Pneumonia is present in the right lower lobe.\"}, 1)$\n$8$. $(\\text{\"No evidence of pneumonia; clinical pneumonia persists.\"}, 1)$\n$9$. $(\\text{\"History: pneumonia last year.\"}, 0)$\n$10$. $(\\text{\"No evidence of pneumonia and consolidation.\"}, 0)$\n$11$. $(\\text{\"No evidence of pneumonia however bacterial bronchitis noted.\"}, 0)$\n$12$. $(\\text{\"Pneumonia suspected clinically.\"}, 1)$\n$13$. $(\\text{\"Clear lungs without infiltrate.\"}, 0)$\n\n计算要求：\n- 计算 $g$ 和 $h$ 在所有 $13$ 个案例上的混淆矩阵计数 $(TP, FP, TN, FN)$。\n- 以十进制形式的实数计算 $g$ 和 $h$ 的敏感性和特异性。如果任何分母等于 $0$，为完成此任务，将相应的指标定义为 $0$。\n- 将每个指标四舍五入到小数点后 $3$ 位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按 $[\\text{sensitivity}_g,\\text{specificity}_g,\\text{sensitivity}_h,\\text{specificity}_h]$ 的顺序排列，其中每个条目都是一个四舍五入到小数点后 $3$ 位的浮点数，例如 $[0.857,0.750,0.900,0.900]$。",
            "solution": "该问题是有效的，因为它具有科学依据、定义明确、客观，并包含推导出唯一解所需的所有必要信息。任务是基于一组临床陈述，实现并评估两种用于检测肺炎是否存在的表型检测算法 $g(S)$ 和 $h(S)$。这个过程展示了数据、信息、知识、智慧（DIKW）层级结构：原始文本 $S$ 是*数据*；检测器的结构化输出是*信息*；算法本身代表应用的*知识*；而对其性能的比较评估则产生了关于其效用的*智慧*。解决方案分为四个步骤：分词、实现两个检测器、针对测试集进行评估以及计算性能指标。\n\n**步骤 1：分词**\n\n第一步是将每个原始临床陈述字符串 $S$ 转换为词元序列。根据问题的形式化定义，这包括将字符串转换为小写，然后将其分割为字母单词或指定的边界标点符号 $\\{',', ';', '.'\\}$ 之一。这可以通过使用正则表达式来稳健地实现，该表达式查找所有一个或多个字母字符的序列，或匹配其中一个标点字符。将模式 `r'[a-z]+|[.,;]'` 应用于小写字符串即可实现此目的，能正确地将像 `\"No evidence of pneumonia; ...\"` 这样的字符串解析为词元列表 `['no', 'evidence', 'of', 'pneumonia', ';', ...]`。不在标点符号集中的非字母字符，例如 `\"History:\"` 中的冒号，被有效忽略，这与问题对有效词元的定义一致。\n\n**步骤 2：朴素表型检测器 $g(S)$**\n\n朴素检测器 $g(S)$ 模拟了一个简单的关键词搜索。如果在分词后的序列中任何位置存在词元 `'pneumonia'`，它就将陈述分类为肺炎阳性。\n该函数定义为：\n$$ g(S) = \\begin{cases} 1  \\text{if 'pneumonia' is a token in } S \\\\ 0  \\text{otherwise} \\end{cases} $$\n这个函数很容易实现，只需对输入字符串 $S$ 进行分词，然后检查目标词元是否存在即可。\n\n**步骤 3：改进的表型检测器 $h(S)$**\n\n改进的检测器 $h(S)$ 融合了上下文知识，特别是用于否定范围检测的规则。它旨在通过识别术语 `'pneumonia'` 何时被短语 `\"no evidence of\"` 否定来减少假阳性。\n\n$h(S)$ 的逻辑如下：\n$1$. 将输入字符串 $S$ 分词成词元序列 $\\{t_0, t_1, \\dots, t_{N-1}\\}$，其中 $N$ 是词元的总数。\n$2$. 识别出词元 `'pneumonia'` 出现的所有索引。设这个索引集合为 $P_{idx}$。如果 $P_{idx}$ 为空，$h(S)$ 立即返回 $0$。\n$3$. 识别出连续的三词元短语 `('no', 'evidence', 'of')` 开始的所有索引。对于每个这样的起始索引 $k$，我们必须确定其前向范围。\n$4$. 索引 $k$ 处的否定词的前向范围覆盖从 $k+3$ 开始直到（但不包括）第一个后续边界词元的词元索引。边界词元集定义为 $B = \\{ \\text{'but'}, \\text{'however'}, ',', ';', '.' \\}$。如果在索引 $k+2$ 之后没有找到边界词元，则范围延伸到陈述的末尾。形式上，对于每个在 $k$ 处开始的否定，其范围区间为 $I_k = \\{k+3, \\dots, m-1\\}$，其中 $m$ 是满足 $t_m \\in B$ 的最小索引 $\\ge k+3$，如果不存在这样的边界，则 $m=N$。\n$5$. 通过取所有此类范围区间 $I_k$ 的并集，构造一个包含所有被否定索引的主集合 $N_{idx}$。\n$6$. 当且仅当 $P_{idx}$ 中至少存在一个肺炎索引不在被否定索引集 $N_{idx}$ 中时，函数 $h(S)$ 返回 $1$。否则，如果所有 `'pneumonia'` 的提及都在否定范围内，$h(S)$ 返回 $0$。\n\n这种逻辑能正确处理陈述中既包含否定又包含肯定的肺炎提及的情况，例如 `\"No evidence of pneumonia; clinical pneumonia persists.\"`。\n\n**步骤 4：评估和指标计算**\n\n为了评估 $g(S)$ 和 $h(S)$ 的性能，我们处理提供的 $13$ 个案例的测试集。对于每个检测器，通过将其对每个陈述 $S$ 的预测与真实标签 $y$ 进行比较来填充混淆矩阵。由此得出真阳性（$TP$）、假阳性（$FP$）、真阴性（$TN$）和假阴性（$FN$）的计数。\n\n数据中阳性实例的总数为 $P = TP + FN$，阴性实例的总数为 $N = TN + FP$。根据测试集，$P=5$ 且 $N=8$。\n\n性能指标是敏感性和特异性，定义如下：\n$$ \\text{sensitivity} = \\frac{TP}{TP + FN} \\quad \\text{and} \\quad \\text{specificity} = \\frac{TN}{TN + FP} $$\n如果任何分母为零，则该指标定义为 $0$。\n\n- **对于函数 $g(S)$**：任何提及 `'pneumonia'` 都会导致阳性预测。这正确地识别了所有 $5$ 个真阳性案例（$TP_g=5, FN_g=0$），但错误地分类了 $8$ 个阴性案例中的 $7$ 个，这些案例在否定或不相关的上下文中提及了肺炎（$FP_g=7, TN_g=1$）。\n  - $\\text{sensitivity}_g = \\frac{5}{5+0} = 1.0$\n  - $\\text{specificity}_g = \\frac{1}{1+7} = 0.125$\n\n- **对于函数 $h(S)$**：否定逻辑正确地识别了阴性案例中的否定性提及，显著减少了假阳性。它正确地分类了所有 $5$ 个真阳性案例（$TP_h=5, FN_h=0$）。它仅错误地将一个阴性案例 `\"History: pneumonia last year.\"` 分类为阳性，因为该规则未考虑时间性，只考虑了否定（$FP_h=1$）。它正确地分类了另外 $7$ 个阴性案例（$TN_h=7$）。\n  - $\\text{sensitivity}_h = \\frac{5}{5+0} = 1.0$\n  - $\\text{specificity}_h = \\frac{7}{7+1} = 0.875$\n\n最终结果四舍五入到小数点后 $3$ 位，并按要求格式呈现。特异性从 $0.125$ 提高到 $0.875$ 而敏感性没有损失，这证明了否定检测规则的价值，提供了问题陈述中所寻求的分析性*智慧*。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\n\ndef solve():\n    \"\"\"\n    Implements and evaluates two phenotype detectors for pneumonia based on a\n    rule-based NLP approach, demonstrating the DIKW pyramid.\n    \"\"\"\n    \n    # Test suite: (clinical_statement, ground_truth_label)\n    # ground_truth_label: 1 for pneumonia present, 0 for absent.\n    test_cases = [\n        (\"There is no evidence of pneumonia.\", 0),\n        (\"There is evidence of pneumonia.\", 1),\n        (\"No evidence of pneumonia or pleural effusion.\", 0),\n        (\"No evidence of pneumonia, but mild atelectasis.\", 0),\n        (\"Findings compatible with pneumonia.\", 1),\n        (\"No evidence of lobar pneumonia seen today.\", 0),\n        (\"Pneumonia is present in the right lower lobe.\", 1),\n        (\"No evidence of pneumonia; clinical pneumonia persists.\", 1),\n        (\"History: pneumonia last year.\", 0),\n        (\"No evidence of pneumonia and consolidation.\", 0),\n        (\"No evidence of pneumonia however bacterial bronchitis noted.\", 0),\n        (\"Pneumonia suspected clinically.\", 1),\n        (\"Clear lungs without infiltrate.\", 0)\n    ]\n\n    def tokenize(sentence: str) -> list[str]:\n        \"\"\"\n        Tokenizes a sentence according to the problem's formalization.\n        It lowercases the string and extracts alphabetic words or specific\n        punctuation marks.\n        \"\"\"\n        return re.findall(r'[a-z]+|[.,;]', sentence.lower())\n\n    def g(sentence: str) -> int:\n        \"\"\"\n        Naive phenotype detector g(S). Returns 1 if 'pneumonia' is found, 0 otherwise.\n        \"\"\"\n        tokens = tokenize(sentence)\n        return 1 if 'pneumonia' in tokens else 0\n\n    def h(sentence: str) -> int:\n        \"\"\"\n        Improved phenotype detector h(S) with negation scope detection.\n        Returns 1 if an un-negated 'pneumonia' is found, 0 otherwise.\n        \"\"\"\n        tokens = tokenize(sentence)\n        n = len(tokens)\n        boundary_set = {'but', 'however', ',', ';', '.'}\n        negation_phrase = ['no', 'evidence', 'of']\n\n        pneumonia_indices = {i for i, token in enumerate(tokens) if token == 'pneumonia'}\n        if not pneumonia_indices:\n            return 0\n\n        negated_indices = set()\n        for k in range(n - len(negation_phrase) + 1):\n            if tokens[k:k + len(negation_phrase)] == negation_phrase:\n                scope_start = k + len(negation_phrase)\n                scope_end = n\n                for m in range(scope_start, n):\n                    if tokens[m] in boundary_set:\n                        scope_end = m\n                        break\n                # The scope includes indices from scope_start up to scope_end.\n                negated_indices.update(range(scope_start, scope_end))\n\n        # Check if there is any pneumonia index that is not negated.\n        for p_idx in pneumonia_indices:\n            if p_idx not in negated_indices:\n                return 1\n        \n        return 0\n\n    # Initialize confusion matrix counters\n    conf_g = {'TP': 0, 'FP': 0, 'TN': 0, 'FN': 0}\n    conf_h = {'TP': 0, 'FP': 0, 'TN': 0, 'FN': 0}\n\n    # Evaluate both detectors over the test suite\n    for sentence, y_true in test_cases:\n        y_pred_g = g(sentence)\n        y_pred_h = h(sentence)\n\n        # Update confusion matrix for g(S)\n        if y_pred_g == 1 and y_true == 1: conf_g['TP'] += 1\n        elif y_pred_g == 1 and y_true == 0: conf_g['FP'] += 1\n        elif y_pred_g == 0 and y_true == 0: conf_g['TN'] += 1\n        elif y_pred_g == 0 and y_true == 1: conf_g['FN'] += 1\n\n        # Update confusion matrix for h(S)\n        if y_pred_h == 1 and y_true == 1: conf_h['TP'] += 1\n        elif y_pred_h == 1 and y_true == 0: conf_h['FP'] += 1\n        elif y_pred_h == 0 and y_true == 0: conf_h['TN'] += 1\n        elif y_pred_h == 0 and y_true == 1: conf_h['FN'] += 1\n    \n    # Calculate metrics, with division-by-zero handling\n    sens_den_g = conf_g['TP'] + conf_g['FN']\n    sensitivity_g = conf_g['TP'] / sens_den_g if sens_den_g > 0 else 0.0\n    spec_den_g = conf_g['TN'] + conf_g['FP']\n    specificity_g = conf_g['TN'] / spec_den_g if spec_den_g > 0 else 0.0\n\n    sens_den_h = conf_h['TP'] + conf_h['FN']\n    sensitivity_h = conf_h['TP'] / sens_den_h if sens_den_h > 0 else 0.0\n    spec_den_h = conf_h['TN'] + conf_h['FP']\n    specificity_h = conf_h['TN'] / spec_den_h if spec_den_h > 0 else 0.0\n    \n    results = [sensitivity_g, specificity_g, sensitivity_h, specificity_h]\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当数据被转化为宝贵的知识库后，DIKW金字塔的顶端——智慧，要求我们以负责任和合乎道德的方式使用这些信息。本练习将让您直面医疗数据共享中的一个关键挑战：在保护患者隐私与最大化数据科研价值之间取得平衡。通过探索和评估不同的数据脱敏技术（如k-匿名、l-多样性），您将实践如何量化和优化这一权衡，这正是将信息学知识应用于现实世界复杂决策的智慧体现。",
            "id": "4860535",
            "problem": "一个医疗保健分析团队的任务是在医疗保健领域的数据、信息、知识、智慧 (DIKW) 金字塔概念框架内，评估和改进一个医院出院数据集的去识别化过程。原始的出院记录被视为数据；通过准标识符形成等价类是将数据转化为信息的结构；隐私度量则量化了转换在多大程度上保护了机密性和效用性。考虑以下包含 $16$ 条记录的固定出院数据集，每条记录为一个元组 $(\\text{Age}, \\text{ZIP}, \\text{Gender}, \\text{Diagnosis})$，其中 $\\text{Age}$ 以年为单位，$\\text{ZIP}$ 为 $5$ 位数邮政编码，$\\text{Gender}$ 为 $\\text{F}$ 或 $\\text{M}$，$\\text{Diagnosis}$ 属于 $\\{\\text{Cardio}, \\text{Oncology}, \\text{Psych}, \\text{Infectious}\\}$：\n$(23, 02139, \\text{F}, \\text{Cardio})$, $(24, 02139, \\text{M}, \\text{Psych})$, $(27, 02138, \\text{F}, \\text{Infectious})$, $(29, 02138, \\text{M}, \\text{Oncology})$, $(33, 02141, \\text{F}, \\text{Psych})$, $(35, 02141, \\text{F}, \\text{Cardio})$, $(38, 02142, \\text{M}, \\text{Oncology})$, $(41, 02142, \\text{F}, \\text{Psych})$, $(44, 02139, \\text{M}, \\text{Cardio})$, $(47, 02138, \\text{F}, \\text{Infectious})$, $(52, 02141, \\text{M}, \\text{Oncology})$, $(55, 02142, \\text{F}, \\text{Psych})$, $(59, 02139, \\text{F}, \\text{Cardio})$, $(62, 02138, \\text{M}, \\text{Infectious})$, $(66, 02141, \\text{F}, \\text{Oncology})$, $(70, 02142, \\text{M}, \\text{Psych})$.\n\n准标识符为 $\\{\\text{Age}, \\text{ZIP}, \\text{Gender}\\}$。一个转换由三个参数指定：\n- 年龄泛化宽度 $w_A \\in \\{5,10,20\\}$。对于一个年龄 $a$，其泛化后的年龄区间定义为 $[w_A \\cdot \\lfloor a / w_A \\rfloor,\\, w_A \\cdot \\lfloor a / w_A \\rfloor + (w_A - 1)]$。\n- 邮政编码泛化前缀长度 $p_Z \\in \\{3,2\\}$，保留 $5$ 位邮政编码的前 $p_Z$ 位数字。\n- 性别抑制标志 $g \\in \\{0,1\\}$，其中 $g = 0$ 保留性别， $g = 1$ 则抑制性别（替换为单个通用符号）。\n\n在任何选定的转换 $(w_A, p_Z, g)$ 下，通过将具有相同泛化准标识符（年龄区间、邮政编码前缀以及性别或抑制符号）的记录分组来定义等价类。对于每个等价类 $C$，令 $|C|$ 为其大小，令 $S_C$ 为 $C$ 中存在的不同 $\\text{Diagnosis}$ 值的集合，令 $P_C$ 为由 $C$ 导出的在 $\\{\\text{Cardio}, \\text{Oncology}, \\text{Psych}, \\text{Infectious}\\}$ 上的经验分布。令 $P$ 为整个数据集中在 $\\{\\text{Cardio}, \\text{Oncology}, \\text{Psych}, \\text{Infectious}\\}$ 上的总体经验分布。\n\n隐私度量定义如下：\n- $k$-匿名性在级别 $k$ 上成立，如果每个等价类的大小都满足 $|C| \\geq k$。观测到的 $k$ 为 $\\min_C |C|$。\n- $l$-多样性在级别 $l$ 上成立，如果每个等价类至少包含 $l$ 个不同的敏感值，即 $|S_C| \\geq l$。观测到的 $l$ 为 $\\min_C |S_C|$。\n- $t$-贴近性在阈值 $t$ 上成立，如果对于每个类 $C$，全变差距离 $d_{TV}(P_C,P) \\leq t$，其中 $$d_{TV}(P_C,P) = \\frac{1}{2} \\sum_{i \\in \\{\\text{Cardio}, \\text{Oncology}, \\text{Psych}, \\text{Infectious}\\}} \\left| P_C(i) - P(i) \\right|.$$ 观测到的 $t$ 为 $\\max_C d_{TV}(P_C,P)$。\n\n定义一个效用损失模型来量化转换所造成的信息损失：\n- 令年龄范围为 $R_A = (\\max \\text{Age}) - (\\min \\text{Age}) + 1$。年龄效用损失为 $u_A = \\frac{w_A}{R_A}$。\n- 邮政编码效用损失为 $u_Z = \\frac{5 - p_Z}{5}$。\n- 性别效用损失为 $u_G = \\begin{cases}0  \\text{if } g=0,\\\\ 1  \\text{if } g=1.\\end{cases}$\n给定非负权重 $(\\alpha, \\beta, \\gamma)$ 且 $\\alpha + \\beta + \\gamma = 1$，总效用损失为 $$U = \\alpha \\cdot u_A + \\beta \\cdot u_Z + \\gamma \\cdot u_G.$$\n\n从这些基本定义出发，编写一个程序，对于每个测试用例，枚举给定离散集合中的所有转换 $(w_A, p_Z, g)$，计算观测到的 $k$、$l$、$t$ 和 $U$，并选择满足所需 $l$-多样性阈值且 $U$ 最小的转换。当 $U$ 出现平局时，必须通过字典序 $(w_A \\text{ 升序},\\, p_Z \\text{ 降序},\\, g \\text{ 升序})$ 来确定性地打破平局。$k$-匿名性、$l$-多样性和 $t$-贴近性的比较是通过报告所选转换的观测值 $k$、$l$ 和 $t$ 来进行的；选择仅基于满足所需的 $l$-多样性阈值和最小化 $U$。\n\n如果在搜索空间中没有转换满足所需的 $l$-多样性阈值，则该测试用例的输出必须是元组 $[\\text{False}, -1, -1, -1, 1.0, 0, 0, 1.0]$，其中 $\\text{False}$ 表示不可行，$-1$ 占位符表示参数缺失，$1.0$ 是最坏情况的效用损失标记，$0$ 表示退化的观测 $k$ 和 $l$，$1.0$ 标记用于归一化的最大 $t$。\n\n所有浮点数输出必须四舍五入到 $4$ 位小数。不涉及角度；不涉及物理单位。程序必须生成一行输出，其中包含所有测试用例的聚合结果，格式为方括号括起来的逗号分隔列表，每个测试用例的结果本身是一个列表，顺序为 $[\\text{exists}, w_A, p_Z, g, U, k_{\\text{obs}}, l_{\\text{obs}}, t_{\\text{obs}}]$。\n\n使用以下测试套件，该套件在不同的 $l$ 要求和效用偏好下探测试选择过程：\n- 测试用例 1：要求 $l = 2$，权重 $(\\alpha, \\beta, \\gamma) = (0.5, 0.4, 0.1)$。\n- 测试用例 2：要求 $l = 3$，权重 $(\\alpha, \\beta, \\gamma) = (0.4, 0.4, 0.2)$。\n- 测试用例 3：要求 $l = 4$，权重 $(\\alpha, \\beta, \\gamma) = (0.6, 0.3, 0.1)$。\n\n您的程序应生成单行输出，其中包含以方括号括起来的逗号分隔列表形式的结果（例如，$[\\,[\\text{result\\_t1}],\\,[\\text{result\\_t2}],\\,[\\text{result\\_t3}]\\,]$）。",
            "solution": "该问题是有效的。它自成体系、数学上定义明确，并且科学地植根于医学信息学中数据隐私的既定原则，特别是与 $k$-匿名性、$l$-多样性和 $t$-贴近性等概念相关。该问题提供了一个完整的数据集、一个离散的转换集合、所有度量和效用损失的精确公式，以及一个具有明确平局打破规则的无歧义优化目标。这种结构确保了存在一个唯一的、可验证的解。\n\n该解决方案通过系统地评估每种可能的数据转换与指定标准来实现。算法按以下步骤进行：\n\n1.  **数据表示与初始计算**：\n    存储包含 $16$ 条记录的固定数据集。每条记录是一个元组 $(\\text{Age}, \\text{ZIP}, \\text{Gender}, \\text{Diagnosis})$。在评估任何转换之前，我们计算在所有转换中保持不变的值：\n    -   记录总数，$N=16$。\n    -   'Age' 属性的范围，$R_A = (\\max \\text{Age}) - (\\min \\text{Age}) + 1$。对于给定数据，$\\min \\text{Age} = 23$，$\\max \\text{Age} = 70$，因此 $R_A = 70 - 23 + 1 = 48$。\n    -   敏感属性 'Diagnosis' 在其域 $D = \\{\\text{Cardio}, \\text{Oncology}, \\text{Psych}, \\text{Infectious}\\}$ 上的总体经验概率分布 $P$。计数如下：$\\text{Cardio}: 4, \\text{Oncology}: 4, \\text{Psych}: 5, \\text{Infectious}: 3$。因此，分布为 $P = \\{\\text{Cardio}: 4/16, \\text{Oncology}: 4/16, \\text{Psych}: 5/16, \\text{Infectious}: 3/16\\}$，可简化为 $P = \\{\\text{Cardio}: 0.25, \\text{Oncology}: 0.25, \\text{Psych}: 0.3125, \\text{Infectious}: 0.1875\\}$。\n\n2.  **转换枚举与评估**：\n    算法遍历提供的每个测试用例。对于每个测试用例，它会评估来自指定离散搜索空间的每一种可能的转换 $(w_A, p_Z, g)$：$w_A \\in \\{5, 10, 20\\}$，$p_Z \\in \\{3, 2\\}$，$g \\in \\{0, 1\\}$。这总共构成了 $3 \\times 2 \\times 2 = 12$ 种转换。\n\n3.  **泛化与等价类形成**：\n    对于给定的转换 $(w_A, p_Z, g)$，数据集中的每条记录都会被泛化。准标识符元组 $(\\text{Age}, \\text{ZIP}, \\text{Gender})$ 被映射到一个泛化元组：\n    -   年龄 $a$ 被泛化为其区间的下界，$\\lfloor a / w_A \\rfloor \\cdot w_A$。\n    -   一个 $5$ 位数的邮政编码字符串被泛化为其长度为 $p_Z$ 的前缀。\n    -   性别要么被保留（如果 $g=0$），要么被抑制为一个通用符号 '$*$'（如果 $g=1$）。\n    映射到相同泛化准标识符元组的记录构成一个等价类 $C$。\n\n4.  **隐私与效用度量计算**：\n    一旦为某个转换形成了等价类，就计算以下度量：\n    -   **$k$-匿名性**：观测到的匿名级别 $k_{\\text{obs}}$ 是最小等价类的大小：$k_{\\text{obs}} = \\min_{C} |C|$。\n    -   **$l$-多样性**：观测到的多样性级别 $l_{\\text{obs}}$ 是任何单个等价类中不同敏感值的最小数量：$l_{\\text{obs}} = \\min_C |S_C|$，其中 $S_C$ 是类 $C$ 中不同 'Diagnosis' 值的集合。\n    -   **$t$-贴近性**：对于每个类 $C$，计算其局部诊断分布 $P_C$。$P_C$ 与全局分布 $P$ 之间的全变差距离 $d_{TV}(P_C, P)$ 计算为 $d_{TV}(P_C, P) = \\frac{1}{2} \\sum_{i \\in D} |P_C(i) - P(i)|$。观测到的贴近性阈值 $t_{\\text{obs}}$ 是所有类中这些距离的最大值：$t_{\\text{obs}} = \\max_C d_{TV}(P_C, P)$。\n    -   **效用损失**：总效用损失 $U$ 是使用特定测试用例中的权重 $(\\alpha, \\beta, \\gamma)$ 计算的每个准标识符的部分损失的加权和：\n        $$U = \\alpha \\cdot u_A + \\beta \\cdot u_Z + \\gamma \\cdot u_G$$\n        其中 $u_A = \\frac{w_A}{R_A}$，$u_Z = \\frac{5 - p_Z}{5}$，以及 $u_G = g$。\n\n5.  **最优转换选择**：\n    在评估完所有 $12$ 种转换并计算出它们各自的度量 $(U, k_{\\text{obs}}, l_{\\text{obs}}, t_{\\text{obs}})$ 之后，根据以下逻辑选择最优转换：\n    -   **筛选**：所有不满足测试用例所需 $l$-多样性（即 $l_{\\text{obs}}  l_{\\text{required}}$）的转换都将被丢弃。\n    -   **优化与平局打破**：从剩余的有效转换中，选择具有最小效用损失 $U$ 的一个。任何 $U$ 的平局都通过选择在 $(w_A, p_Z, g)$ 的字典序（$w_A$ 升序，$p_Z$ 降序，$g$ 升序）中排在最前面的转换来解决。\n\n6.  **输出生成**：\n    -   如果筛选步骤产生一个空集（没有转换满足 $l$-多样性要求），则该问题对于该测试用例被视为不可行，并生成一个特定的失败元组：$[\\text{False}, -1, -1, -1, 1.0, 0, 0, 1.0]$。\n    -   否则，所选最优转换的参数和度量被格式化为一个结果元组：$[\\text{True}, w_A, p_Z, g, U, k_{\\text{obs}}, l_{\\text{obs}}, t_{\\text{obs}}]$。$U$ 和 $t_{\\text{obs}}$ 的浮点值四舍五入到 $4$ 位小数。\n\n最终输出将所有测试用例的结果聚合成一个单一的逗号分隔列表。",
            "answer": "```python\nimport numpy as np\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the data privacy transformation problem by enumerating all possible\n    transformations, calculating privacy metrics (k-anonymity, l-diversity, \n    t-closeness) and utility loss, and selecting the optimal transformation\n    based on the specified criteria for each test case.\n    \"\"\"\n    \n    # Raw dataset of 16 records\n    data = [\n        (23, '02139', 'F', 'Cardio'), (24, '02139', 'M', 'Psych'),\n        (27, '02138', 'F', 'Infectious'), (29, '02138', 'M', 'Oncology'),\n        (33, '02141', 'F', 'Psych'), (35, '02141', 'F', 'Cardio'),\n        (38, '02142', 'M', 'Oncology'), (41, '02142', 'F', 'Psych'),\n        (44, '02139', 'M', 'Cardio'), (47, '02138', 'F', 'Infectious'),\n        (52, '02141', 'M', 'Oncology'), (55, '02142', 'F', 'Psych'),\n        (59, '02139', 'F', 'Cardio'), (62, '02138', 'M', 'Infectious'),\n        (66, '02141', 'F', 'Oncology'), (70, '02142', 'M', 'Psych')\n    ]\n    \n    diagnosis_domain = sorted(['Cardio', 'Oncology', 'Psych', 'Infectious'])\n    \n    # Pre-calculate global values\n    ages = [rec[0] for rec in data]\n    R_A = float(max(ages) - min(ages) + 1)\n    \n    all_diagnoses = [rec[3] for rec in data]\n    total_records = len(all_diagnoses)\n    global_dist_counter = collections.Counter(all_diagnoses)\n    P = {d: global_dist_counter[d] / total_records for d in diagnosis_domain}\n\n    # Define search space for transformations\n    transformations = [\n        (w_A, p_Z, g)\n        for w_A in [5, 10, 20]\n        for p_Z in [3, 2]\n        for g in [0, 1]\n    ]\n\n    # Test suite\n    test_cases = [\n        {'l_req': 2, 'weights': (0.5, 0.4, 0.1)},\n        {'l_req': 3, 'weights': (0.4, 0.4, 0.2)},\n        {'l_req': 4, 'weights': (0.6, 0.3, 0.1)},\n    ]\n\n    aggregated_results = []\n    \n    for case in test_cases:\n        l_req = case['l_req']\n        alpha, beta, gamma = case['weights']\n        \n        evaluated_transforms = []\n\n        for w_A, p_Z, g in transformations:\n            # Form Equivalence Classes (ECs)\n            ecs = collections.defaultdict(list)\n            for age, zip_code, gender, diagnosis in data:\n                gen_age = w_A * (age // w_A)\n                gen_zip = zip_code[:p_Z]\n                gen_gender = '*' if g == 1 else gender\n                key = (gen_age, gen_zip, gen_gender)\n                ecs[key].append(diagnosis)\n\n            # Calculate privacy metrics for the current transformation\n            if not ecs:\n                k_obs, l_obs, t_obs = 0, 0, 1.0\n            else:\n                class_sizes = [len(diagnoses) for diagnoses in ecs.values()]\n                k_obs = min(class_sizes) if class_sizes else 0\n                \n                distinct_diagnoses_counts = [len(set(diagnoses)) for diagnoses in ecs.values()]\n                l_obs = min(distinct_diagnoses_counts) if distinct_diagnoses_counts else 0\n\n                max_dtv = 0.0\n                for diagnoses in ecs.values():\n                    class_size = len(diagnoses)\n                    class_dist_counter = collections.Counter(diagnoses)\n                    PC = {d: class_dist_counter.get(d, 0) / class_size for d in diagnosis_domain}\n                    \n                    dtv = 0.5 * sum(abs(PC[d] - P[d]) for d in diagnosis_domain)\n                    if dtv > max_dtv:\n                        max_dtv = dtv\n                t_obs = max_dtv\n\n            # Calculate utility loss U\n            u_A = w_A / R_A\n            u_Z = (5.0 - p_Z) / 5.0\n            u_G = float(g)\n            U = alpha * u_A + beta * u_Z + gamma * u_G\n            \n            evaluated_transforms.append({\n                'params': (w_A, p_Z, g),\n                'metrics': (U, k_obs, l_obs, t_obs)\n            })\n\n        # Select the best transformation based on criteria\n        valid_transforms = [t for t in evaluated_transforms if t['metrics'][2] >= l_req]\n        \n        if not valid_transforms:\n            result = [False, -1, -1, -1, 1.0, 0, 0, 1.0]\n        else:\n            # Sort by U (asc), wA (asc), pZ (desc), g (asc)\n            def sort_key(transform):\n                U, _, _, _ = transform['metrics']\n                w_A, p_Z, g = transform['params']\n                return (U, w_A, -p_Z, g)\n\n            valid_transforms.sort(key=sort_key)\n            best_transform = valid_transforms[0]\n            \n            w_A, p_Z, g = best_transform['params']\n            U, k_obs, l_obs, t_obs = best_transform['metrics']\n            \n            result = [\n                True, w_A, p_Z, g,\n                round(U, 4), int(k_obs), int(l_obs), round(t_obs, 4)\n            ]\n        \n        aggregated_results.append(result)\n\n    # Format final output as a string\n    # E.g., [[True, 10, ...], [False, ...]]\n    str_results = [str(res).replace(\"'\", \"\") for res in aggregated_results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}