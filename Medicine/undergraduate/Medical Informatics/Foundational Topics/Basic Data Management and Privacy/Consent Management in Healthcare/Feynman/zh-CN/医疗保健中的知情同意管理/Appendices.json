{
    "hands_on_practices": [
        {
            "introduction": "医疗保健中的同意管理通常涉及处理来自同一患者的多个、可能重叠的同意指令。为了确保决策的清晰性和一致性，我们可以使用数学语言来精确地描述这些策略的组合效果。本练习将指导您使用集合论的基本运算（如交集 $\\cap$、并集 $\\cup$ 和差集 $\\setminus$），根据一组给定的规则来计算多个同意文件的最终有效权限，这是一个将抽象策略形式化的基础实践。",
            "id": "4830922",
            "problem": "一位患者提交了多份同意文件，这些文件用于管控特定临床数据类别的披露。为形式化此组合过程，我们将每份同意文件表示为一个有序集合对，即一个允许集合和一个排除集合，并使用基于经典集合论的标准集合运算来对策略组合进行建模。设临床数据类别的全集为 $$U=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}, \\mathrm{HIV}\\}.$$ 对于每份同意文件 $C_i$，通过 $$P_i = A_i \\setminus X_i,$$ 定义相应的策略集 $P_i$，其中 $A_i$ 是 $C_i$ 明确允许的类别集合，$X_i$ 是 $C_i$ 明确排除的类别集合。\n\n该患者的四份同意文件和一份随后的撤销如下：\n- $C_1$: $A_1=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}\\}$, $X_1=\\{\\mathrm{GEN}\\}$。\n- $C_2$: $A_2=\\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{GEN}, \\mathrm{MH}\\}$, $X_2=\\{\\mathrm{HIV}\\}$。\n- $C_3$: $A_3=\\{\\mathrm{LAB}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}\\}$, $X_3=\\{\\mathrm{IMG}\\}$。\n- $C_4$: $A_4=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}, \\mathrm{HIV}\\}$, $X_4=\\{\\mathrm{GEN}, \\mathrm{MH}\\}$。\n- 撤销：$R=\\{\\mathrm{MH}, \\mathrm{HIV}\\}$。\n\n假设该机构在当前的披露场景中，使用以下不含括号的表达式，并遵循固定的运算符优先级来组合成有效的允许类别集 $E$：\n- 最高优先级：交集 $\\cap$，\n- 中等优先级：差集 $\\setminus$，\n- 最低优先级：并集 $\\cup$，\n在各自的优先级级别上，所有二元运算符均为左结合。\n\n有效集由下式给出\n$$E = P_1 \\cap P_2 \\setminus P_3 \\cup P_4 \\setminus R.$$\n\n从 $P_i=A_i\\setminus X_i$ 的基本语义和上述优先级规则出发，计算集合 $E$ 的基数 $|E|$。请将最终结果以整数形式报告，无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是自洽的、在经典集合论中有科学依据且适定的。该问题是关于根据指定的非标准优先级顺序应用已定义的集合运算的一项形式化练习。所有集合、运算符和求值规则都已明确提供，因此可以计算出唯一的解。\n\n任务是计算有效允许类别集 $E$ 的基数 $|E|$，其中 $E$ 由表达式 $E = P_1 \\cap P_2 \\setminus P_3 \\cup P_4 \\setminus R$ 定义。首先，我们必须根据给定的同意文件确定各个策略集 $P_i = A_i \\setminus X_i$。\n\n临床数据类别的全集为 $U=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}, \\mathrm{HIV}\\}$。\n\n各个策略集的计算如下：\n对于 $C_1$：$A_1=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}\\}$, $X_1=\\{\\mathrm{GEN}\\}$。\n$$P_1 = A_1 \\setminus X_1 = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}\\} \\setminus \\{\\mathrm{GEN}\\} = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}\\}$$\n\n对于 $C_2$：$A_2=\\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{GEN}, \\mathrm{MH}\\}$, $X_2=\\{\\mathrm{HIV}\\}$。\n$$P_2 = A_2 \\setminus X_2 = \\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{GEN}, \\mathrm{MH}\\} \\setminus \\{\\mathrm{HIV}\\} = \\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{GEN}, \\mathrm{MH}\\}$$\n\n对于 $C_3$：$A_3=\\{\\mathrm{LAB}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}\\}$, $X_3=\\{\\mathrm{IMG}\\}$。\n$$P_3 = A_3 \\setminus X_3 = \\{\\mathrm{LAB}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}\\} \\setminus \\{\\mathrm{IMG}\\} = \\{\\mathrm{LAB}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}\\}$$\n\n对于 $C_4$：$A_4=\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}, \\mathrm{HIV}\\}$, $X_4=\\{\\mathrm{GEN}, \\mathrm{MH}\\}$。\n$$P_4 = A_4 \\setminus X_4 = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}, \\mathrm{HIV}\\} \\setminus \\{\\mathrm{GEN}, \\mathrm{MH}\\} = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}, \\mathrm{HIV}\\}$$\n\n撤销集为 $R=\\{\\mathrm{MH}, \\mathrm{HIV}\\}$。\n\n接下来，我们根据指定的运算符优先级来计算表达式 $E = P_1 \\cap P_2 \\setminus P_3 \\cup P_4 \\setminus R$：交集 ($\\cap$) 的优先级最高，其次是差集 ($\\setminus$)，最后是并集 ($\\cup$)，其优先级最低。该运算顺序决定了以下的组合方式：\n$$E = ((P_1 \\cap P_2) \\setminus P_3) \\cup (P_4 \\setminus R)$$\n\n我们通过计算子表达式来进行求解。\n首先，我们计算交集 $P_1 \\cap P_2$：\n$$T_1 = P_1 \\cap P_2 = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{BILL}\\} \\cap \\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}, \\mathrm{GEN}, \\mathrm{MH}\\} = \\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}\\}$$\n\n接下来，我们计算差集 $(P_1 \\cap P_2) \\setminus P_3$：\n$$T_2 = T_1 \\setminus P_3 = \\{\\mathrm{IMG}, \\mathrm{MED}, \\mathrm{NOTE}\\} \\setminus \\{\\mathrm{LAB}, \\mathrm{NOTE}, \\mathrm{BILL}, \\mathrm{GEN}, \\mathrm{MH}\\} = \\{\\mathrm{IMG}, \\mathrm{MED}\\}$$\n元素 $\\mathrm{NOTE}$ 因为存在于 $P_3$ 中而被移除。\n\n然后，我们计算差集 $P_4 \\setminus R$：\n$$T_3 = P_4 \\setminus R = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}, \\mathrm{HIV}\\} \\setminus \\{\\mathrm{MH}, \\mathrm{HIV}\\} = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}\\}$$\n元素 $\\mathrm{HIV}$ 因为存在于 $R$ 中而被移除。\n\n最后，我们计算这两个结果集的并集以求得 $E$：\n$$E = T_2 \\cup T_3 = \\{\\mathrm{IMG}, \\mathrm{MED}\\} \\cup \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}\\} = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}\\}$$\n\n有效的允许类别集为 $E = \\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}\\}$。问题要求计算该集合的基数 $|E|$。\n$$|E| = |\\{\\mathrm{LAB}, \\mathrm{IMG}, \\mathrm{MED}, \\mathrm{BILL}\\}| = 4$$",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在将抽象的策略模型转化为实际系统时，我们需要一个能够评估复杂规则的策略引擎。现实世界中的访问控制系统（如基于 XACML 标准的系统）正是通过评估与请求相关的多重属性（如用户角色、资源类型、操作目的）来做出精细化决策。本练习要求您构建一个简化的策略决策点（PDP），它能根据一个包含同意状态、紧急情况“破玻璃”条款和敏感数据排除规则的正式策略，来裁决一系列访问请求。",
            "id": "4830982",
            "problem": "您将处理一个医疗信息学领域的场景，其目标是管理医疗保健中的同意。任务是指定并评估一个符合可扩展访问控制标记语言 (eXtensible Access Control Markup Language, XACML) 的访问控制策略，以强制执行基于同意的目的限制。您必须实现一个编程实现的策略决策点 (PDP)，该决策点根据正式策略评估请求，并为固定的测试套件生成决策。\n\n基本假设和定义：\n- 基于属性的访问控制 (Attribute-Based Access Control, ABAC) 通过作用于附加在主体、资源、操作和环境上下文的属性之上的逻辑谓词来评估访问。设请求是一个从符号属性名称到值的有限映射 $r$。评估使用公认的命题逻辑运算符 $\\land$ (逻辑与)、$\\lor$ (逻辑或) 和 $\\lnot$ (逻辑非)，以及等式 $=$、不等式 $\\neq$、集合成员关系 $\\in$ 和集合子集关系 $\\subseteq$ 进行。\n- 基于同意的目的限制原则要求，只有在获得特定使用目的的明确同意、在已同意的数据类别范围内且在同意有效期内时，才允许处理临床数据。\n- XACML 评估模型包括目标 (target)、规则 (rule) 和组合算法 (combining algorithm)。策略的目标谓词 $T(r)$ 决定了该策略是否适用。一条规则有一个效果（Permit 或 Deny）和一个条件谓词 $C_i(r)$。此处使用的组合算法是 permit-overrides 的简化形式：任何适用的 Permit 决定都会覆盖 Deny 和 NotApplicable；当未解析的属性评估影响规则条件时，会导致 Indeterminate。\n\n策略规范：\n- 策略目标谓词：\n  $$T(r) := r[\\text{resource\\_type}] = \\text{\"clinical\"}.$$\n  如果 $T(r)$ 为假，则最终决定为 NotApplicable。如果 $r[\\text{resource\\_type}]$ 缺失，则决定为 Indeterminate。\n\n- 规则 $\\mathcal{R}_1$ (通过明确同意、具有目的和范围限制的许可)：\n  效果：Permit。\n  条件 $C_1(r)$ 要求以下所有子条件同时成立：\n  $$r[\\text{consent\\_status}] = \\text{True},$$\n  $$r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}],$$\n  $$r[\\text{requester\\_role}] \\in r[\\text{consent\\_roles}],$$\n  $$r[\\text{data\\_category}] \\in r[\\text{consent\\_data\\_categories}],$$\n  $$r[\\text{now}] \\le r[\\text{consent\\_expiry\\_time}].$$\n  如果 $C_1(r)$ 中的任何属性缺失，$C_1(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_2$ (紧急情况下为治疗目的“破窗”许可)：\n  效果：Permit。\n  条件 $C_2(r)$:\n  $$r[\\text{emergency}] = \\text{True} \\land r[\\text{allow\\_emergency\\_override}] = \\text{True} \\land r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"} \\land r[\\text{requester\\_role}] \\in \\{\\text{\"physician\"}, \\text{\"nurse\"}\\}.$$\n  如果 $C_2(r)$ 中的任何属性缺失，$C_2(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_3$ (当同意中排除时，拒绝敏感类别的研究)：\n  效果：Deny。\n  条件 $C_3(r)$:\n  $$r[\\text{data\\_category}] \\in \\{\\text{\"genetic\"}, \\text{\"mental\\_health\"}\\} \\land r[\\text{purpose\\_of\\_use}] = \\text{\"research\"} \\land r[\\text{exclude\\_sensitive}] = \\text{True}.$$\n  如果 $C_3(r)$ 中的任何属性缺失，$C_3(r)$ 的评估结果为 Indeterminate。\n\n- 规则 $\\mathcal{R}_4$ (当策略目标适用且无许可规则适用时的默认拒绝)：\n  效果：Deny。\n  条件 $C_4(r)$ 是一个重言式（恒为真），但只有在目标 $T(r)$ 为真且没有其他规则产生 Permit、Deny 或 Indeterminate 的结果时才会被考虑。这在目标域内编码了故障安全默认值（默认为拒绝）。\n\n组合算法（简化的 permit-overrides）：\n给定在目标 $T(r)$ 下的规则结果多重集 $\\{R_i\\}$，\n1. 如果 $T(r)$ 为假，返回 NotApplicable。\n2. 如果因 $r[\\text{resource\\_type}]$ 缺失导致 $T(r)$ 为 Indeterminate，返回 Indeterminate。\n3. 评估每个 $C_i(r)$：\n   - 如果任何 $R_i$ 是 Permit，返回 Permit。\n   - 否则，如果任何 $R_i$ 是 Indeterminate，返回 Indeterminate。\n   - 否则，如果任何 $R_i$ 是 Deny，返回 Deny。\n   - 否则（没有规则适用），通过应用 $\\mathcal{R}_4$ 返回 Deny。\n这与一种保守的解释相一致：未解析的属性引用产生 Indeterminate，而在目标内缺乏正面授权则导致 Deny。\n\n决策编码：\n- Permit $\\rightarrow$ $1$\n- Deny $\\rightarrow$ $0$\n- NotApplicable $\\rightarrow$ $-1$\n- Indeterminate $\\rightarrow$ $2$\n\n单位：\n- 所有时间属性 $r[\\text{now}]$ 和 $r[\\text{consent\\_expiry\\_time}]$ 均以 Unix 纪元以来的秒数表示，并且所有比较必须以秒为单位进行。\n\n测试套件：\n在以下 $8$ 个请求上评估策略。每个请求 $r$ 都以属性名称到值的映射形式给出。\n\n- 测试用例 $1$ (具有有效治疗同意的正常路径)：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}, \\text{\"imaging\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $2$ (请求研究目的，但同意仅限于治疗)：\n  除 $r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}$ 外，与用例 1 相同。\n\n- 测试用例 $3$ (同意已过期)：\n  除 $r[\\text{now}] = 1900000000$ 和 $r[\\text{consent\\_expiry\\_time}] = 1800000000$ 外，与用例 1 相同。\n\n- 测试用例 $4$ (护士在无同意的情况下为治疗目的进行紧急“破窗”访问)：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{False}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"nurse\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000100$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{True}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $5$ (对敏感数据的研究被同意范围排除)：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"research\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"researcher\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"researcher\"}$,\n  $r[\\text{data\\_category}] = \\text{\"genetic\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $6$ (因非临床资源而不适用)：\n  $r[\\text{resource\\_type}] = \\text{\"financial\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $7$ (因目标适用但同意目的缺失而导致不确定)：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}]$ 缺失,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"physician\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n- 测试用例 $8$ (角色未在同意中授权)：\n  $r[\\text{resource\\_type}] = \\text{\"clinical\"}$,\n  $r[\\text{consent\\_status}] = \\text{True}$,\n  $r[\\text{consent\\_purposes}] = [\\text{\"treatment\"}]$,\n  $r[\\text{consent\\_roles}] = [\\text{\"physician\"}, \\text{\"nurse\"}]$,\n  $r[\\text{consent\\_data\\_categories}] = [\\text{\"lab\\_results\"}]$,\n  $r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}$,\n  $r[\\text{requester\\_role}] = \\text{\"admin\"}$,\n  $r[\\text{data\\_category}] = \\text{\"lab\\_results\"}$,\n  $r[\\text{now}] = 1700000000$,\n  $r[\\text{consent\\_expiry\\_time}] = 1800000000$,\n  $r[\\text{emergency}] = \\text{False}$,\n  $r[\\text{allow\\_emergency\\_override}] = \\text{True}$,\n  $r[\\text{exclude\\_sensitive}] = \\text{True}$.\n\n您的任务：\n- 实现一个程序，该程序对 $i \\in \\{1,2,3\\}$ 编码 $T(r)$ 和 $C_i(r)$，应用上述组合算法，并计算每个测试用例的决策编码。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\text{\"[1,0,-1]\"}$）。",
            "solution": "该问题要求为一个基于属性的访问控制 (ABAC) 系统实现一个策略决策点 (PDP)，其规范方式类似于 XACML。PDP 必须根据为医疗保健中的同意管理而设计的正式策略来评估访问请求。解决方案涉及系统地将给定的逻辑谓词和组合算法转换为一个过程化的评估流程。\n\n解决方案的核心是一个处理单个访问请求的函数，该请求表示为从属性名称到值的映射 $r$。此函数必须产生四种可能的决策之一：Permit (编码为 $1$)、Deny (编码为 $0$)、NotApplicable (编码为 $-1$) 或 Indeterminate (编码为 $2$)。\n\n评估过程严格遵循问题陈述中定义的层次结构。首先，评估策略的目标谓词 $T(r)$。\n$$T(r) := r[\\text{resource\\_type}] = \\text{\"clinical\"}$$\n如果请求中缺少属性 $r[\\text{resource\\_type}]$，则 $T(r)$ 的评估是不明确的，导致最终决策为 Indeterminate ($2$)。如果该属性存在但其值不是“clinical”，则该策略不适用，决策为 NotApplicable ($-1$)。当且仅当 $T(r)$ 为真时，评估才会进入规则阶段。\n\n一旦满足目标，PDP 会评估一组规则，每个规则都有一个条件谓词 $C_i(r)$ 和一个效果（Permit 或 Deny）。一个关键方面是在条件评估期间处理缺失的属性。如果谓词 $C_i(r)$ 所需的任何属性缺失，则 $C_i(r)$ 的评估结果为 Indeterminate。因此，规则 $\\mathcal{R}_i$ 的结果按如下方式确定：\n- 如果 $C_i(r)$ 为真，则结果为规则的效果（Permit 或 Deny）。\n- 如果 $C_i(r)$ 为假，则该规则不适用。\n- 如果 $C_i(r)$ 的结果为 Indeterminate，则该规则的结果为 Indeterminate。\n\n四个指定的规则是：\n1.  $\\mathcal{R}_1$ (Permit)：条件 $C_1(r) := (r[\\text{consent\\_status}] = \\text{True}) \\land (r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}]) \\land (r[\\text{requester\\_role}] \\in r[\\text{consent\\_roles}]) \\land (r[\\text{data\\_category}] \\in r[\\text{consent\\_data\\_categories}]) \\land (r[\\text{now}] \\le r[\\text{consent\\_expiry\\_time}])$。该规则强制执行核心的同意要求。\n2.  $\\mathcal{R}_2$ (Permit)：条件 $C_2(r) := (r[\\text{emergency}] = \\text{True}) \\land (r[\\text{allow\\_emergency\\_override}] = \\text{True}) \\land (r[\\text{purpose\\_of\\_use}] = \\text{\"treatment\"}) \\land (r[\\text{requester\\_role}] \\in \\{\\text{\"physician\"}, \\text{\"nurse\"}\\})$。该规则提供了一种紧急“破窗”机制。\n3.  $\\mathcal{R}_3$ (Deny)：条件 $C_3(r) := (r[\\text{data\\_category}] \\in \\{\\text{\"genetic\"}, \\text{\"mental\\_health\"}\\}) \\land (r[\\text{purpose\\_of\\_use}] = \\text{\"research\"}) \\land (r[\\text{exclude\\_sensitive}] = \\text{True})$。该规则对敏感数据强制执行特定的排除条款。\n4.  $\\mathcal{R}_4$ (Deny)：这是一个默认拒绝规则，仅在目标被满足且没有其他规则产生 Permit、Deny 或 Indeterminate 结果时适用。\n\n在评估完各个规则 $\\mathcal{R}_1$、$\\mathcal{R}_2$ 和 $\\mathcal{R}_3$ 后，使用指定的“简化的 permit-overrides”算法组合它们的结果。该算法建立了一个明确的优先级：\n1.  如果任何规则产生 Permit，则最终决策为 Permit ($1$)。\n2.  否则，如果任何规则产生 Indeterminate，则最终决策为 Indeterminate ($2$)。\n3.  否则，如果任何规则产生 Deny，则最终决策为 Deny ($0$)。\n4.  否则（意味着所有规则都不适用），触发默认拒绝规则 $\\mathcal{R}_4$，最终决策为 Deny ($0$)。\n\n举例说明，考虑测试用例 1 (正常路径)：\n- 由于 $r[\\text{resource\\_type}] = \\text{\"clinical\"}$，$T(r)$ 为真。\n- 对于 $\\mathcal{R}_1$，$C_1(r)$ 的所有五个子条件都满足：同意是有效的，目的匹配，角色匹配，数据类别匹配，且请求在有效期内。因此，$C_1(r)$ 为真，$\\mathcal{R}_1$ 产生 Permit。\n- 组合算法找到一个 Permit 结果，并立即返回最终决定 Permit ($1$)。\n\n相反，考虑测试用例 7 (缺失属性)：\n- $T(r)$ 为真。\n- 评估 $C_1(r)$ 时，检查 $r[\\text{purpose\\_of\\_use}] \\in r[\\text{consent\\_purposes}]$ 需要属性 $r[\\text{consent\\_purposes}]$。由于它缺失，$C_1(r)$ 的评估结果为 Indeterminate。因此，规则 $\\mathcal{R}_1$ 的结果是 Indeterminate。\n- $\\mathcal{R}_2$ 和 $\\mathcal{R}_3$ 的条件评估结果为假。\n- 组合算法没有找到 Permit 结果。然后它从 $\\mathcal{R}_1$ 找到一个 Indeterminate 结果，并返回最终决定 Indeterminate ($2$)。\n\n实现将包括一个主评估函数，用于协调这些步骤。将使用辅助函数来评估每个条件谓词，通过传播 Indeterminate 状态来仔细处理可能缺失的属性。最终程序将遍历所提供的测试套件，对每个用例应用此评估逻辑，并将得出的决策代码格式化为指定的输出字符串。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, evaluate them against the policy,\n    and print the results.\n    \"\"\"\n\n    # --- Decision and Logic Constants ---\n    class Decision:\n        PERMIT = 1\n        DENY = 0\n        NOT_APPLICABLE = -1\n        INDETERMINATE = 2\n\n    class RuleResult:\n        PERMIT = \"Permit\"\n        DENY = \"Deny\"\n        NOT_APPLICABLE = \"NotApplicable\"\n        INDETERMINATE = \"Indeterminate\"\n\n    class MissingAttributeError(Exception):\n        \"\"\"Custom exception for handling missing attributes in requests.\"\"\"\n        pass\n\n    def get_attribute(request, key):\n        \"\"\"Safely retrieves an attribute, raising an error if it's missing.\"\"\"\n        if key not in request:\n            raise MissingAttributeError(f\"Attribute '{key}' is missing.\")\n        return request[key]\n\n    # --- Rule Condition Predicate Evaluators ---\n    def evaluate_C1(r):\n        try:\n            return (\n                get_attribute(r, 'consent_status') is True and\n                get_attribute(r, 'purpose_of_use') in get_attribute(r, 'consent_purposes') and\n                get_attribute(r, 'requester_role') in get_attribute(r, 'consent_roles') and\n                get_attribute(r, 'data_category') in get_attribute(r, 'consent_data_categories') and\n                get_attribute(r, 'now') = get_attribute(r, 'consent_expiry_time')\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_C2(r):\n        try:\n            return (\n                get_attribute(r, 'emergency') is True and\n                get_attribute(r, 'allow_emergency_override') is True and\n                get_attribute(r, 'purpose_of_use') == \"treatment\" and\n                get_attribute(r, 'requester_role') in {\"physician\", \"nurse\"}\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_C3(r):\n        try:\n            return (\n                get_attribute(r, 'data_category') in {\"genetic\", \"mental_health\"} and\n                get_attribute(r, 'purpose_of_use') == \"research\" and\n                get_attribute(r, 'exclude_sensitive') is True\n            )\n        except MissingAttributeError:\n            return RuleResult.INDETERMINATE\n\n    def evaluate_request(r):\n        \"\"\"\n        Evaluates a single access request against the defined policy.\n        \"\"\"\n        # 1. Target Evaluation\n        try:\n            if get_attribute(r, 'resource_type') != \"clinical\":\n                return Decision.NOT_APPLICABLE\n        except MissingAttributeError:\n            return Decision.INDETERMINATE\n\n        # 2. Evaluate Rule Conditions\n        condition_outcomes = {\n            'C1': evaluate_C1(r),\n            'C2': evaluate_C2(r),\n            'C3': evaluate_C3(r),\n        }\n\n        # 3. Determine Rule Results based on Effects\n        rule_results = []\n        # Rule R1 (Permit)\n        if condition_outcomes['C1'] is True:\n            rule_results.append(RuleResult.PERMIT)\n        elif condition_outcomes['C1'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n\n        # Rule R2 (Permit)\n        if condition_outcomes['C2'] is True:\n            rule_results.append(RuleResult.PERMIT)\n        elif condition_outcomes['C2'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n            \n        # Rule R3 (Deny)\n        if condition_outcomes['C3'] is True:\n            rule_results.append(RuleResult.DENY)\n        elif condition_outcomes['C3'] is False:\n            rule_results.append(RuleResult.NOT_APPLICABLE)\n        else: # Indeterminate\n            rule_results.append(RuleResult.INDETERMINATE)\n\n        # 4. Apply Combining Algorithm (Simplified Permit-Overrides)\n        if RuleResult.PERMIT in rule_results:\n            return Decision.PERMIT\n        \n        if RuleResult.INDETERMINATE in rule_results:\n            return Decision.INDETERMINATE\n        \n        if RuleResult.DENY in rule_results:\n            return Decision.DENY\n            \n        # All rules are NotApplicable, so apply default deny (R4)\n        return Decision.DENY\n\n    # --- Test Suite Definition ---\n    case1 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        \"consent_purposes\": [\"treatment\"], \"consent_roles\": [\"physician\", \"nurse\"],\n        \"consent_data_categories\": [\"lab_results\", \"imaging\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"physician\",\n        \"data_category\": \"lab_results\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case2 = case1.copy(); case2[\"purpose_of_use\"] = \"research\"\n    case3 = case1.copy(); case3[\"now\"] = 1900000000\n    case4 = {\n        \"resource_type\": \"clinical\", \"consent_status\": False,\n        \"consent_purposes\": [\"treatment\"], \"consent_roles\": [\"physician\", \"nurse\"],\n        \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"nurse\",\n        \"data_category\": \"lab_results\", \"now\": 1700000100,\n        \"consent_expiry_time\": 1800000000, \"emergency\": True,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case5 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        \"consent_purposes\": [\"research\"], \"consent_roles\": [\"researcher\"],\n        \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"research\", \"requester_role\": \"researcher\",\n        \"data_category\": \"genetic\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case6 = case1.copy(); case6[\"resource_type\"] = \"financial\"\n    case7 = {\n        \"resource_type\": \"clinical\", \"consent_status\": True,\n        # \"consent_purposes\" is missing\n        \"consent_roles\": [\"physician\"], \"consent_data_categories\": [\"lab_results\"],\n        \"purpose_of_use\": \"treatment\", \"requester_role\": \"physician\",\n        \"data_category\": \"lab_results\", \"now\": 1700000000,\n        \"consent_expiry_time\": 1800000000, \"emergency\": False,\n        \"allow_emergency_override\": True, \"exclude_sensitive\": True\n    }\n    case8 = case1.copy(); case8[\"requester_role\"] = \"admin\"\n\n    test_cases = [case1, case2, case3, case4, case5, case6, case7, case8]\n\n    # --- Execution and Output ---\n    results = [evaluate_request(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个设计良好的策略引擎也可能因配置错误而产生严重的安全漏洞，“策略遮蔽”（policy shadowing）就是其中一个典型例子，即一条宽泛的“拒绝”规则错误地覆盖了一条更具体的“允许”规则。本练习将让您扮演安全分析师的角色，通过分析一系列测试用例的结果，评估一个旨在检测此类配置错误的工具的性能。您需要计算该检测器的 $F_1$ 分数，这是衡量系统准确性的一个标准指标，从而实践对访问控制系统进行审计和验证的关键技能。",
            "id": "4830976",
            "problem": "一个医院级别的电子健康记录（EHR）系统强制执行基于角色的访问控制（RBAC）和患者同意策略。其预期的组合语义是“最具体的允许覆盖宽泛的拒绝”，但一个错误的配置部署了“宽泛的拒绝覆盖”评估模式，其中一条宽泛的拒绝规则具有高优先级。这导致了遮蔽（shadowing）：本应授权访问的特定允许规则被一个更通用的拒绝规则所隐藏。考虑以下合规性所要求的同意和访问控制规则：\n\n- 具体允许规则 $P_{\\text{cardio}}$：如果 subject.role $=$ Cardiologist, resource.type $=$ cardiology\\_notes, purpose $=$ treatment，则允许，无论主体隶属关系（内部或外部），只要患者已同意接受治疗。\n- 具体允许规则 $P_{\\text{er}}$：如果 subject.dept $=$ Emergency, resource.type $=$ allergies, purpose $=$ emergency，则允许。\n- 宽泛拒绝规则 $D_{\\text{ext}}$：如果 subject.affiliation $\\neq$ Hospital\\_H1（一个“外部”提供者），则拒绝。在已部署的引擎中，此拒绝规则被错误配置为比具体允许规则具有更高的评估优先级。\n- 宽泛拒绝规则 $D_{\\text{research}}$：如果 purpose $=$ research 且 patient.research\\_opt\\_out $=$ true，则拒绝。\n\n一名安全分析师正在评估一个遮蔽-错误配置检测器，如果某个访问请求的策略路径中，一个具体的允许规则因引擎的错误配置优先级而被一个更宽泛的拒绝规则覆盖，该检测器就会将该请求标记为“被遮蔽的允许”。该分析师执行了以下 $12$ 个测试用例 $T_{1}$ 到 $T_{12}$，每个用例都标注了其在合规语义（最具体的允许覆盖）下的预期决策、在错误配置（宽泛的拒绝覆盖）下的实际引擎决策，以及检测器是否标记了它。\n\n- $T_{1}$：subject.affiliation $=$ external; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false; emergency $=$ false。预期：允许；实际：拒绝；检测器：已标记。\n- $T_{2}$：subject.affiliation $=$ internal; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false; emergency $=$ false。预期：允许；实际：允许；检测器：未标记。\n- $T_{3}$：subject.affiliation $=$ external; subject.dept $=$ Emergency; resource.type $=$ allergies; purpose $=$ emergency; patient.research\\_opt\\_out $=$ false。预期：允许；实际：拒绝；检测器：已标记。\n- $T_{4}$：subject.affiliation $=$ external; subject.role $=$ Cardiologist; resource.type $=$ radiology\\_report; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false。预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{5}$：subject.affiliation $=$ internal; subject.dept $=$ Emergency; resource.type $=$ allergies; purpose $=$ emergency; patient.research\\_opt\\_out $=$ false。预期：允许；实际：允许；检测器：未标记。\n- $T_{6}$：subject.affiliation $=$ external; subject.role $=$ Nurse; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{7}$：subject.affiliation $=$ external; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ research; patient.research\\_opt\\_out $=$ false。预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{8}$：subject.affiliation $=$ internal; subject.role $=$ Researcher; resource.type $=$ lab\\_results; purpose $=$ research; patient.research\\_opt\\_out $=$ true。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{9}$：subject.affiliation $=$ external; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; emergency $=$ true; patient.research\\_opt\\_out $=$ false。预期：允许；实际：拒绝；检测器：未标记。\n- $T_{10}$：subject.affiliation $=$ external; subject.dept $=$ Emergency; resource.type $=$ allergies; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false。预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{11}$：subject.affiliation $=$ internal; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false。预期：允许；实际：允许；检测器：未标记。\n- $T_{12}$：subject.affiliation $=$ external; subject.role $=$ Cardiologist; resource.type $=$ cardiology\\_notes; purpose $=$ treatment; patient.research\\_opt\\_out $=$ false; eConsent\\_override $=$ true。预期：允许；实际：拒绝；检测器：已标记。\n\n定义一个“阳性”测试为：根据预期语义本应应用具体允许规则（允许），但由于宽泛的拒绝规则而被已部署的引擎拒绝，即一个被遮蔽的允许。仅使用上述数据，计算该检测器在此测试套件上的 $F_{1}$分数，将检测到的情况视为“阳性”预测。将您的答案四舍五入到四位有效数字。最终值以纯数字形式表示，不带百分号。",
            "solution": "首先，对用户提供的问题进行严格的验证过程。\n\n### 第一步：提取已知信息\n问题提供了一套访问控制规则、两种不同策略评估语义的描述，以及一套包含 $12$ 个测试用例及其结果的测试集。\n\n**访问控制规则：**\n- $P_{\\text{cardio}}$：如果 subject.role $=$ Cardiologist, resource.type $=$ cardiology\\_notes, purpose $=$ treatment，则允许。\n- $P_{\\text{er}}$：如果 subject.dept $=$ Emergency, resource.type $=$ allergies, purpose $=$ emergency，则允许。\n- $D_{\\text{ext}}$：如果 subject.affiliation $\\neq$ Hospital\\_H1，则拒绝。此规则被错误配置为高优先级。\n- $D_{\\text{research}}$：如果 purpose $=$ research 且 patient.research\\_opt\\_out $=$ true，则拒绝。\n\n**策略语义：**\n- 预期语义：“最具体的允许覆盖宽泛的拒绝”。\n- 实际（错误配置的）语义：“宽泛的拒绝覆盖”。\n\n**检测器定义：**\n- 如果一个具体的允许规则处于活动状态但被一个更宽泛的拒绝规则所覆盖，检测器就会将请求标记为“被遮蔽的允许”。\n\n**评估的基本事实定义：**\n- 一个“阳性”测试用例定义为代表一个被遮蔽的允许，它对应于一个 `Intended` (预期) 决策为 `Permit` (允许) 而 `Actual` (实际) 引擎决策为 `Deny` (拒绝) 的访问请求。\n\n**评估的预测定义：**\n- 一个“阳性”预测是检测器 `Flagged` (标记) 了请求的用例。\n\n**测试用例 ($T_1$ 到 $T_{12}$):**\n- $T_{1}$：预期：允许；实际：拒绝；检测器：已标记。\n- $T_{2}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{3}$：预期：允许；实际：拒绝；检测器：已标记。\n- $T_{4}$：预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{5}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{6}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{7}$：预期：拒绝；实际：拒绝；检测器：已标记。\n- $T_{8}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{9}$：预期：允许；实际：拒绝；检测器：未标记。\n- $T_{10}$：预期：拒绝；实际：拒绝；检测器：未标记。\n- $T_{11}$：预期：允许；实际：允许；检测器：未标记。\n- $T_{12}$：预期：允许；实际：拒绝；检测器：已标记。\n\n### 第二步：使用提取的已知信息进行验证\n该问题在科学上植根于计算机安全和医学信息学领域，使用了诸如基于角色的访问控制（RBAC）、策略评估和遮蔽等标准术语。该问题是适定 (well-posed) 的，因为它提供了一个完整、自洽的数据集和一个明确的目标：计算 $F_{1}$分数，这是衡量二元分类准确性的标准指标。其语言客观而精确。所提供的数据，包括测试用例的结果（`Intended`、`Actual`、`Detector`），为计算提供了一致的基础，即使检测器本身存在缺陷（而这正是评估的重点）。该问题没有违反任何基本原则，没有规定不足，也不包含对当前任务的矛盾约束。\n\n### 第三步：结论与行动\n该问题被判定为**有效**。将提供完整的解决方案。\n\n### 求解过程\n目标是根据遮蔽-错误配置检测器在所提供的 $12$ 个测试用例上的性能，计算其 $F_{1}$分数。$F_{1}$分数是精确率和召回率的调和平均数。\n\n首先，我们必须确定基本事实和检测器的预测，以构建一个混淆矩阵。\n- **阳性条件**（一个真实的遮蔽实例）被问题定义为 `Intended` (预期) 决策是 `Permit` (允许) 且 `Actual` (实际) 决策是 `Deny` (拒绝) 的测试。\n- **阴性条件**则是任何其他组合。\n- **阳性预测**是检测器标记为 `Flagged` 的测试用例。\n- **阴性预测**是检测器标记为 `Not Flagged` 的测试用例。\n\n现在我们可以对 $12$ 个测试用例中的每一个进行分类：\n\n- $T_1$：预期 `Permit`，实际 `Deny`。这是一个**阳性条件**。检测器 `Flagged` (标记) 了它，这是一个**阳性预测**。因此，$T_1$ 是一个真阳性 ($TP$)。\n- $T_2$：预期 `Permit`，实际 `Permit`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_2$ 是一个真阴性 ($TN$)。\n- $T_3$：预期 `Permit`，实际 `Deny`。这是一个**阳性条件**。检测器 `Flagged` (标记) 了它，这是一个**阳性预测**。因此，$T_3$ 是一个真阳性 ($TP$)。\n- $T_4$：预期 `Deny`，实际 `Deny`。这是一个**阴性条件**。检测器 `Flagged` (标记) 了它，这是一个**阳性预测**。因此，$T_4$ 是一个假阳性 ($FP$)。\n- $T_5$：预期 `Permit`，实际 `Permit`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_5$ 是一个真阴性 ($TN$)。\n- $T_6$：预期 `Deny`，实际 `Deny`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_6$ 是一个真阴性 ($TN$)。\n- $T_7$：预期 `Deny`，实际 `Deny`。这是一个**阴性条件**。检测器 `Flagged` (标记) 了它，这是一个**阳性预测**。因此，$T_7$ 是一个假阳性 ($FP$)。\n- $T_8$：预期 `Deny`，实际 `Deny`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_8$ 是一个真阴性 ($TN$)。\n- $T_9$：预期 `Permit`，实际 `Deny`。这是一个**阳性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_9$ 是一个假阴性 ($FN$)。\n- $T_{10}$：预期 `Deny`，实际 `Deny`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。因此，$T_{10}$ 是一个真阴性 ($TN$)。\n- $T_{11}$：预期 `Permit`，实际 `Permit`。这是一个**阴性条件**。检测器 `Not Flagged` (未标记) 它，这是一个**阴性预测**。这与 $T_2$ 相同，是一个真阴性 ($TN$)。\n- $T_{12}$：预期 `Permit`，实际 `Deny`。这是一个**阳性条件**。检测器 `Flagged` (标记) 了它，这是一个**阳性预测**。因此，$T_{12}$ 是一个真阳性 ($TP$)。\n\n总结这 $12$ 个测试的计数结果：\n- 真阳性 ($TP$): $3$ ($T_1, T_3, T_{12}$)\n- 假阳性 ($FP$): $2$ ($T_4, T_7$)\n- 真阴性 ($TN$): $6$ ($T_2, T_5, T_6, T_8, T_{10}, T_{11}$)\n- 假阴性 ($FN$): $1$ ($T_9$)\n\n测试总数为 $3 + 2 + 6 + 1 = 12$，正确无误。\n\n接下来，我们计算精确率和召回率。\n精确率是正确预测的阳性观测值与总预测阳性观测值的比率。\n$$ \\text{Precision} = \\frac{TP}{TP + FP} $$\n代入数值：\n$$ \\text{Precision} = \\frac{3}{3 + 2} = \\frac{3}{5} = 0.6 $$\n\n召回率（或灵敏度）是正确预测的阳性观测值与实际类别中所有观测值的比率。\n$$ \\text{Recall} = \\frac{TP}{TP + FN} $$\n代入数值：\n$$ \\text{Recall} = \\frac{3}{3 + 1} = \\frac{3}{4} = 0.75 $$\n\n最后，计算 $F_{1}$分数，即精确率和召回率的调和平均数。\n$$ F_1 = 2 \\times \\frac{\\text{Precision} \\times \\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\n代入已计算出的精确率和召回率值：\n$$ F_1 = 2 \\times \\frac{0.6 \\times 0.75}{0.6 + 0.75} = 2 \\times \\frac{0.45}{1.35} $$\n为了简化分数：\n$$ F_1 = 2 \\times \\frac{45}{135} = 2 \\times \\frac{1}{3} = \\frac{2}{3} $$\n作为小数，$F_1 = 0.666666...$。问题要求四舍五入到四位有效数字。\n$$ F_1 \\approx 0.6667 $$",
            "answer": "$$ \\boxed{0.6667} $$"
        }
    ]
}