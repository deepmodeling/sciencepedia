{
    "hands_on_practices": [
        {
            "introduction": "医疗保健数据通常涉及事件的时间线，例如入院和出院。数据质量的一个基本方面是时间合理性——确保事件以合乎逻辑的时间顺序发生。本实践将教您如何通过编程方式定义和检测逻辑上不可能的情况，例如出院发生在入院之前，这是清理任何纵向数据集的关键第一步 。",
            "id": "4833782",
            "problem": "您将获得一组从电子健康记录 (EHR) 数据中提取的患者层面住院时间线。这些时间线以列表形式表示，包含自一个固定原点起测量的入院和出院时间点（以天为单位）。您的目标是，以编程方式检测对基本时间合理性和患者内部一致性约束的违规行为，并量化这些违规的比率。\n\n基本核心定义：\n- 对于一次住院，时间合理性要求出院时间不早于入院时间。形式上，对于一次入院时间为 $t_a$、出院时间为 $t_d$ 的住院，合理性要求 $t_d \\ge t_a$。\n- 对于住院占用，患者内部一致性要求单个患者不能有重叠的住院记录。将每次住院建模为一个半开区间 $[t_a, t_d)$，对于同一患者的两次住院 $(t_{a,i}, t_{d,i})$ 和 $(t_{a,j}, t_{d,j})$，它们重叠当且仅当 $\\max(t_{a,i}, t_{a,j})  \\min(t_{d,i}, t_{d,j})$。在边界上相等，即 $\\max(t_{a,i}, t_{a,j}) = \\min(t_{d,i}, t_{d,j})$，表示邻接，而非重叠。\n\n需要计算的目标违规：\n- 出院早于入院的违规：统计满足 $t_d  t_a$ 的住院记录数量。\n- 重叠的住院：在有效住院（即满足 $t_d \\ge t_a$ 的住院）中，按患者统计如上定义的重叠住院对的数量。\n\n要求计算的比率：\n- 记录层面的出院早于入院比率 $R_1$：出院早于入院的违规次数 $V_1$ 与总住院次数 $N$ 的比值，即 $R_1 = V_1 / N$。\n- 对层面的重叠率 $R_2$：所有患者中重叠的有效住院对总数 $V_2$ 与可比较的有效住院对总数 $T$ 的比值，即 $R_2 = V_2 / T$。如果 $T = 0$，则定义 $R_2 = 0$。\n- 患者层面的重叠普遍率 $R_{2p}$：至少有一个重叠有效住院对的患者数量 $P_{\\text{over}}$ 与总患者数 $P$ 的比值，即 $R_{2p} = P_{\\text{over}} / P$。\n\n单位与测量：\n- 所有时间点必须视为以天为单位的实数。不涉及角度测量。将所有比率表示为四舍五入到 $6$ 位小数的小数。\n\n测试套件：\n使用以下四个测试用例，每个用例指定为一组患者列表，其中每个患者是一个住院列表，每次住院是一个以天为单位的配对 $(t_a, t_d)$。区间被解释为 $[t_a, t_d)$。\n- 测试用例 1 (通用“理想路径”)：\n  - 患者 1：$(1, 3)$, $(3, 5)$。\n  - 患者 2：$(10, 12)$。\n  - 患者 3：$(20, 25)$, $(24, 26)$, $(30, 31)$。\n- 测试用例 2 (包含出院早于入院和重叠情况)：\n  - 患者 1：$(5, 4)$, $(7, 9)$。\n  - 患者 2：$(0, 10)$, $(2, 8)$。\n  - 患者 3：$(10, 12)$, $(12, 14)$。\n- 测试用例 3 (零个可比较对的边界情况)：\n  - 患者 1：$(3, 2)$。\n  - 患者 2：$(0, 1)$。\n  - 患者 3：$(5, 4)$。\n- 测试用例 4 (边界条件和多个重叠)：\n  - 患者 1：$(1, 3)$, $(3, 5)$, $(2, 4)$。\n  - 患者 2：$(10, 12)$, $(10, 12)$。\n  - 患者 3：$(20, 20)$。\n\n程序要求：\n- 实现一个程序，为每个测试用例计算 $R_1$、$R_2$ 和 $R_{2p}$，计算过程需完全遵循上述定义，并且在计算与重叠相关的量时仅使用有效住院。\n- 将每个测试用例的三个比率表示为四舍五入到 $6$ 位小数的小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[R_1^{(1)}, R_2^{(1)}, R_{2p}^{(1)}, R_1^{(2)}, R_2^{(2)}, R_{2p}^{(2)}, R_1^{(3)}, R_2^{(3)}, R_{2p}^{(3)}, R_1^{(4)}, R_2^{(4)}, R_{2p}^{(4)}]$，其中上标表示从 $1$ 到 $4$ 的测试用例索引。",
            "solution": "问题陈述已经过分析，并被确定为有效。它在医学信息学领域，特别是在数据质量评估方面，具有科学依据。所提供的定义在数学上是精确且内部一致的，构成了一个适定的计算问题。目标清晰，没有歧义或主观性。\n\n任务是根据电子健康记录 (EHR) 数据中的患者时间线，计算三个特定的数据质量比率。我们将基于所提供的定义来形式化此流程。\n\n一次住院由一对时间点 $(t_a, t_d)$ 表示，其中 $t_a$ 是入院时间，$t_d$ 是出院时间。该次住院对应于半开区间 $[t_a, t_d)$。一条患者记录是这样一个住院列表。一个测试用例是一个患者记录列表。\n\n需要计算的三个比率是：\n1.  记录层面的出院早于入院比率，$R_1$。\n2.  对层面的重叠率，$R_2$。\n3.  患者层面的重叠普遍率，$R_{2p}$。\n\n让我们为这些比率定义必要的量。\n\n**1. 时间合理性与比率 $R_1$**\n\n如果出院时间不早于入院时间，则一次住院 $(t_a, t_d)$ 被认为是时间上合理的。\n$$\n\\text{Plausibility condition: } t_d \\ge t_a\n$$\n如果 $t_d  t_a$，则发生违规。设 $V_1$ 为一个测试用例中所有住院记录里此类违规的总数。设 $N$ 为所有患者的总住院次数。比率 $R_1$ 定义为：\n$$\nR_1 = \\frac{V_1}{N}\n$$\n如果 $N=0$，我们定义 $R_1=0$。\n\n**2. 患者内部一致性与比率 $R_2$ 和 $R_{2p}$**\n\n这些比率涉及单个患者的重叠住院。分析仅限于*有效*住院，即那些满足合理性条件 $t_d \\ge t_a$ 的住院。\n\n对于一个给定的患者，两次不同的有效住院 $(t_{a,i}, t_{d,i})$ 和 $(t_{a,j}, t_{d,j})$，如果它们对应的时间区间 $[t_{a,i}, t_{d,i})$ 和 $[t_{a,j}, t_{d,j})$ 有非空交集，则定义为重叠。这可以形式化地表示为：\n$$\n\\text{Overlap condition: } \\max(t_{a,i}, t_{a,j})  \\min(t_{d,i}, t_{d,j})\n$$\n请注意，邻接情况，即 $\\max(t_{a,i}, t_{a,j}) = \\min(t_{d,i}, t_{d,j})$，不构成重叠。\n\n为了计算比率 $R_2$ 和 $R_{2p}$，我们为给定的测试用例定义以下量：\n-   $P$：总患者数。\n-   $k_p$：患者 $p$ 的有效住院次数。\n-   $T$：可比较的有效住院对的总数。一个拥有 $k_p$ 次有效住院的患者贡献 $\\binom{k_p}{2} = \\frac{k_p(k_p-1)}{2}$ 对。因此，$T = \\sum_{p=1}^{P} \\binom{k_p}{2}$。\n-   $V_2$：重叠的有效住院对的总数，对所有患者求和。\n-   $P_{\\text{over}}$：至少有一对重叠有效住院的患者数量。\n\n比率 $R_2$ 是重叠对与可比较对的比值：\n$$\nR_2 = \\frac{V_2}{T}\n$$\n根据定义，如果 $T=0$，则 $R_2=0$。\n\n比率 $R_{2p}$ 是存在与重叠相关的数据质量问题的患者比例：\n$$\nR_{2p} = \\frac{P_{\\text{over}}}{P}\n$$\n如果 $P=0$，我们定义 $R_{2p}=0$。\n\n**算法流程**\n\n对于每个测试用例，我们执行以下步骤：\n1.  初始化计数器：$V_1 = 0$，$N = 0$，$V_2 = 0$，$T = 0$，$P_{\\text{over}} = 0$，并将 $P$ 设为测试用例中的总患者数。\n2.  遍历测试用例中的每个患者。\n3.  对于每个患者，将其住院记录划分为一个 `valid_stays` 列表（$t_d \\ge t_a$）并统计无效住院（$t_d  t_a$）的数量。每次遇到无效住院，将 $V_1$ 加一。将患者的总住院次数加到 $N$ 上。\n4.  对于当前患者，设 $k_p$ 为 `valid_stays` 中的住院次数。将 $\\binom{k_p}{2}$ 加到总数 $T$ 中。\n5.  如果 $k_p \\ge 2$，遍历 `valid_stays` 中所有唯一的住院对。对于每一对，使用条件 $\\max(t_{a,i}, t_{a,j})  \\min(t_{d,i}, t_{d,j})$ 检查是否重叠。\n6.  统计当前患者的重叠对数量。设此数量为 `patient_overlap_count`。将此计数加到总数 $V_2$ 中。\n7.  如果 `patient_overlap_count` $ 0$，则将 $P_{\\text{over}}$ 加一。\n8.  遍历完所有患者后，使用各自的公式计算最终比率 $R_1$、$R_2$ 和 $R_{2p}$。确保按规定处理除以零的情况。\n9.  将每个比率四舍五入到 $6$ 位小数。\n\n**示例演练：测试用例 1**\n\n-   数据：患者 1：$(1, 3), (3, 5)$；患者 2：$(10, 12)$；患者 3：$(20, 25), (24, 26), (30, 31)$。\n-   总患者数 $P = 3$。\n-   总住院次数 $N = 2 + 1 + 3 = 6$。\n\n**步骤 1：合理性检查 ($R_1$)**\n-   检查所有住院记录：$3 \\ge 1$，$5 \\ge 3$，$12 \\ge 10$，$25 \\ge 20$，$26 \\ge 24$，$31 \\ge 30$。全部有效。\n-   $V_1 = 0$。\n-   $R_1 = V_1 / N = 0 / 6 = 0.0$。\n\n**步骤 2：重叠分析 ($R_2$, $R_{2p}$)**\n-   **患者 1：**有效住院：`[(1, 3), (3, 5)]`。$k_1 = 2$。\n    - 可比较对：$\\binom{2}{2} = 1$。\n    - 检查 $((1, 3), (3, 5))$ 是否重叠：$\\max(1, 3) = 3$，$\\min(3, 5) = 3$。条件 $3  3$ 不成立。无重叠。\n-   **患者 2：**有效住院：`[(10, 12)]`。$k_2 = 1$。\n    - 可比较对：$\\binom{1}{2} = 0$。无可检查的对。\n-   **患者 3：**有效住院：`[(20, 25), (24, 26), (30, 31)]`。$k_3 = 3$。\n    - 可比较对：$\\binom{3}{2} = 3$。\n    - 对 $((20, 25), (24, 26))$：$\\max(20, 24) = 24$，$\\min(25, 26) = 25$。条件 $24  25$ 成立。发现重叠。\n    - 对 $((20, 25), (30, 31))$：$\\max(20, 30) = 30$，$\\min(25, 31) = 25$。条件 $30  25$ 不成立。无重叠。\n    - 对 $((24, 26), (30, 31))$：$\\max(24, 30) = 30$，$\\min(26, 31) = 26$。条件 $30  26$ 不成立。无重叠。\n    - 患者 3 有 $1$ 个重叠对。由于该值 $0$，我们将此患者计入 $P_{\\text{over}}$。\n\n**步骤 3：汇总并计算比率**\n-   可比较对总数 $T = \\binom{2}{2} + \\binom{1}{2} + \\binom{3}{2} = 1 + 0 + 3 = 4$。\n-   重叠对总数 $V_2 = 0 (\\text{P1}) + 0 (\\text{P2}) + 1 (\\text{P3}) = 1$。\n-   有重叠的患者总数 $P_{\\text{over}} = 1$ (患者 3)。\n-   $R_2 = V_2 / T = 1 / 4 = 0.25$。\n-   $R_{2p} = P_{\\text{over}} / P = 1 / 3 \\approx 0.333333$。\n\n测试用例 1 的最终比率为 $(0.0, 0.25, 0.333333...)$。其余测试用例按相同方式处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef solve():\n    \"\"\"\n    Computes data quality violation rates for EHR inpatient timelines.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        [\n            [(1, 3), (3, 5)],\n            [(10, 12)],\n            [(20, 25), (24, 26), (30, 31)]\n        ],\n        # Test case 2\n        [\n            [(5, 4), (7, 9)],\n            [(0, 10), (2, 8)],\n            [(10, 12), (12, 14)]\n        ],\n        # Test case 3\n        [\n            [(3, 2)],\n            [(0, 1)],\n            [(5, 4)]\n        ],\n        # Test case 4\n        [\n            [(1, 3), (3, 5), (2, 4)],\n            [(10, 12), (10, 12)],\n            [(20, 20)]\n        ]\n    ]\n\n    all_results = []\n\n    for case_data in test_cases:\n        # Initialize counters for the current test case\n        total_stays_n = 0\n        discharge_before_admission_v1 = 0\n        total_comparable_pairs_t = 0\n        overlapping_pairs_v2 = 0\n        patients_with_overlap_p_over = 0\n        total_patients_p = len(case_data)\n\n        for patient_stays in case_data:\n            total_stays_n += len(patient_stays)\n            \n            valid_stays = []\n            for stay in patient_stays:\n                t_a, t_d = stay\n                if t_d  t_a:\n                    discharge_before_admission_v1 += 1\n                else:\n                    valid_stays.append(stay)\n\n            k_p = len(valid_stays)\n            patient_comparable_pairs = math.comb(k_p, 2)\n            total_comparable_pairs_t += patient_comparable_pairs\n\n            if patient_comparable_pairs > 0:\n                patient_overlap_count = 0\n                for stay1, stay2 in combinations(valid_stays, 2):\n                    t_a1, t_d1 = stay1\n                    t_a2, t_d2 = stay2\n                    \n                    # Overlap condition: max(ta,i, ta,j)  min(td,i, td,j)\n                    if max(t_a1, t_a2)  min(t_d1, t_d2):\n                        patient_overlap_count += 1\n                \n                if patient_overlap_count > 0:\n                    patients_with_overlap_p_over += 1\n                    overlapping_pairs_v2 += patient_overlap_count\n\n        # Calculate rates\n        # R1: Record-level discharge-before-admission rate\n        r1 = (discharge_before_admission_v1 / total_stays_n) if total_stays_n > 0 else 0.0\n\n        # R2: Pair-level overlap rate\n        r2 = (overlapping_pairs_v2 / total_comparable_pairs_t) if total_comparable_pairs_t > 0 else 0.0\n\n        # R2p: Patient-level overlap prevalence\n        r2p = (patients_with_overlap_p_over / total_patients_p) if total_patients_p > 0 else 0.0\n        \n        all_results.extend([r1, r2, r2p])\n\n    # Format the final output string\n    formatted_results = [f\"{res:.6f}\" for res in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "许多有价值的临床信息，如吸烟状况，通常是由人类编码员从非结构化文本中提取的。当数据是通过人类判断生成时，衡量其可靠性，即不同评估者之间的一致性，就变得至关重要。本练习介绍了科恩系数 ($ \\kappa $)，这是一种标准统计量，用于量化超出偶然预期的一致性，使您能够评估人工提取数据的可信度 。",
            "id": "4833853",
            "problem": "一家医院正在评估从电子健康记录 (EHR) 临床记录中提取吸烟状况时，数据质量维度中的可靠性。两名临床编码员独立地为每位患者分配四个名义类别中的一个：当前吸烟者 (Current)、既往吸烟者 (Former)、从不吸烟者 (Never) 或未知 (Unknown)。在一个包含 $300$ 名患者的队列中，联合分类如下：\n\n- 在编码员 A 标记为“当前吸烟者”的患者中，编码员 B 的标记为：“当前吸烟者”$55$例，“既往吸烟者”$7$例，“从不吸烟者”$6$例，“未知”$2$例。\n- 在编码员 A 标记为“既往吸烟者”的患者中，编码员 B 的标记为：“当前吸烟者”$6$例，“既往吸烟者”$75$例，“从不吸烟者”$7$例，“未知”$2$例。\n- 在编码员 A 标记为“从不吸烟者”的患者中，编码员 B 的标记为：“当前吸烟者”$4$例，“既往吸烟者”$12$例，“从不吸烟者”$100$例，“未知”$4$例。\n- 在编码员 A 标记为“未知”的患者中，编码员 B 的标记为：“当前吸烟者”$0$例，“既往吸烟者”$1$例，“从不吸烟者”$4$例，“未知”$15$例。\n\n仅使用名义类别评估者间信度的基本定义——该定义根据给定评估者边际标签分布的机遇预期一致性来调整观察到的一致性——计算这两位编码员的 Cohen's $\\kappa$ 系数。报告结果时，应为一个无量纲数，并四舍五入到四位有效数字。你的最终答案必须是一个实数。",
            "solution": "在医疗保健信息提取任务中，可靠性这一数据质量维度量化了不同观察者之间测量结果的一致性。对于名义类别，广泛使用的经机遇校正的评估者间信度系数是 Cohen's $\\kappa$。其第一性原理定义为：超出机遇水平的一致性部分，除以可能达到的超出机遇水平的最大一致性部分进行归一化。设 $P_{o}$ 表示观察到的一致性比例，设 $P_{e}$ 表示在每位编码员的边际标签分布独立的假设下，因机遇而预期的一致性比例。该系数为\n$$\n\\kappa \\;=\\; \\frac{P_{o} - P_{e}}{1 - P_{e}}.\n$$\n\n步骤 $1$：从列联表的对角线计算 $P_{o}$。对角线上的计数为：当前-当前 $55$，既往-既往 $75$，从不-从不 $100$，未知-未知 $15$。患者总数为 $300$。因此\n$$\nP_{o} \\;=\\; \\frac{55 + 75 + 100 + 15}{300} \\;=\\; \\frac{245}{300} \\;=\\; \\frac{49}{60}.\n$$\n\n步骤 $2$：通过边际分布的乘积计算 $P_{e}$。首先，计算行（编码员 A）的总计：\n- 当前：$55 + 7 + 6 + 2 = 70$，\n- 既往：$6 + 75 + 7 + 2 = 90$，\n- 从不：$4 + 12 + 100 + 4 = 120$，\n- 未知：$0 + 1 + 4 + 15 = 20$。\n\n然后，计算列（编码员 B）的总计：\n- 当前：$55 + 6 + 4 + 0 = 65$，\n- 既往：$7 + 75 + 12 + 1 = 95$，\n- 从不：$6 + 7 + 100 + 4 = 117$，\n- 未知：$2 + 2 + 4 + 15 = 23$。\n\n每个边际比例是相应的总数除以 $300$。因此，\n$$\nP_{e} \\;=\\; \\sum_{\\text{categories}} \\left(\\frac{\\text{row total}}{300}\\right)\\!\\left(\\frac{\\text{column total}}{300}\\right)\n\\;=\\; \\frac{70 \\cdot 65 + 90 \\cdot 95 + 120 \\cdot 117 + 20 \\cdot 23}{300^{2}}.\n$$\n计算分子：\n$$\n70 \\cdot 65 = 4550,\\quad 90 \\cdot 95 = 8550,\\quad 120 \\cdot 117 = 14040,\\quad 20 \\cdot 23 = 460,\n$$\n所以总和为\n$$\n4550 + 8550 + 14040 + 460 = 27600.\n$$\n因此\n$$\nP_{e} \\;=\\; \\frac{27600}{90000} \\;=\\; \\frac{23}{75}.\n$$\n\n步骤 $3$：计算 $\\kappa$：\n$$\n\\kappa \\;=\\; \\frac{P_{o} - P_{e}}{1 - P_{e}} \\;=\\; \\frac{\\frac{49}{60} - \\frac{23}{75}}{1 - \\frac{23}{75}}.\n$$\n化简分子：\n$$\n\\frac{49}{60} - \\frac{23}{75} \\;=\\; \\frac{245}{300} - \\frac{92}{300} \\;=\\; \\frac{153}{300} \\;=\\; \\frac{51}{100}.\n$$\n化简分母：\n$$\n1 - \\frac{23}{75} \\;=\\; \\frac{52}{75}.\n$$\n因此，\n$$\n\\kappa \\;=\\; \\frac{\\frac{51}{100}}{\\frac{52}{75}} \\;=\\; \\frac{51}{100} \\cdot \\frac{75}{52} \\;=\\; \\frac{153}{208}.\n$$\n以小数形式表示，\n$$\n\\kappa \\approx 0.735576923.\n$$\n四舍五入到四位有效数字，\n$$\n\\kappa \\approx 0.7356.\n$$\n\n临床应用解释：根据常用的定性指导原则（例如，Landis and Koch 的量表），$\\kappa$ 值在 $0.61$ 至 $0.80$ 范围内通常被描述为“实质性”一致，而 $\\geq 0.81$ 的值则被描述为“几乎完美”一致。因此，$\\kappa \\approx 0.7356$ 表明吸烟状况提取任务具有实质性的评估者间信度。这对于临床部署是否足够，取决于具体应用的风险承受能力；高风险的决策支持系统通常要求 $\\kappa$ 值接近或超过 $0.80$。",
            "answer": "$$\\boxed{0.7356}$$"
        },
        {
            "introduction": "在现实世界的数据集中，某些数据字段不可避免地会缺失。这种缺失的影响在很大程度上取决于数据缺失的*原因*，这一概念可以通过不同的缺失机制来描述，例如完全随机缺失 (MCAR) 与非随机缺失 (MNAR)。通过这个问题，您将学会计算完整率，更重要的是，量化关于缺失的不同假设如何导致队列选择中产生显著不同的结论，从而突显统计思维在数据质量评估中的关键作用 。",
            "id": "4833809",
            "problem": "一个医院系统正在从其电子健康记录（EHR）数据库中构建一个用于结局研究的分析队列。每条记录的必填字段为 $ \\{\\text{age}, \\text{sex}, \\text{diagnosis}, \\text{medication}\\} $。我们关心的数据质量维度是完整性，其定义为所有必填字段均非缺失的记录所占的比例。医院的信息学团队报告了在整个数据集上测得的以下边际缺失率：$ \\text{age} $ 缺失的概率 $ = 0.01 $，$ \\text{sex} $ 缺失的概率 $ = 0.02 $，$ \\text{diagnosis} $ 缺失的概率 $ = 0.05 $，以及 $ \\text{medication} $ 缺失的概率 $ = 0.10 $。该分析队列由以下临床纳入标准定义：年龄至少为 $ 18 $ 岁（成人），诊断记录中包含国际疾病分类第十版（ICD-10）编码 $ E11 $（2型糖尿病），以及用药记录中包含 metformin。纳入标准还要求四个必填字段都存在（非缺失）。\n\n考虑了两种缺失机制。在完全随机缺失（MCAR）的情况下，字段的存在与患者特征无关，且各字段之间相互独立。在非随机缺失（MNAR）的情况下，诊断字段的存在取决于患者是否真的患有 ICD-10 $ E11 $，而用药字段的存在取决于患者是否真的服用 metformin，同时 $ \\text{age} $ 和 $ \\text{sex} $ 字段的存在情况保持如报告所述，并与其他变量独立。在源人群中确定了以下临床患病率：$ \\mathbb{P}(E11) = 0.12 $，$ \\mathbb{P}(\\text{metformin} \\mid E11) = 0.62 $，以及 $ \\mathbb{P}(\\text{metformin} \\mid \\neg E11) = 0.02 $。在 MNAR 条件下，字段存在的概率为 $ \\mathbb{P}(\\text{diagnosis present} \\mid E11) = 0.90 $，$ \\mathbb{P}(\\text{diagnosis present} \\mid \\neg E11) = 0.96 $，$ \\mathbb{P}(\\text{medication present} \\mid \\text{metformin}) = 0.80 $，以及 $ \\mathbb{P}(\\text{medication present} \\mid \\neg \\text{metformin}) = 0.92 $。假设当字段存在时，其值是准确的，并且没有错误分类；同时假设在给定患者真实的 $ E11 $ 和 metformin 状态的情况下，诊断字段的存在和用药字段的存在是条件独立的。\n\n仅使用以上信息以及概率公理和完整性的定义，计算以下内容：\n\n1. MCAR 假设下的总体完整率，即 $ \\mathbb{P}(\\text{all four required fields present}) $。\n2. 在 MCAR 和 MNAR 之间，仅因字段缺失而导致的临床合格成人记录预期保留率的绝对差异，定义为\n$$\n\\Delta \\;=\\; \\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MCAR}) \\;-\\; \\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MNAR}),\n$$\n其中“included”（已纳入）表示所有四个字段都存在，并且记录的值符合临床纳入标准。\n\n将两个最终值以小数形式表示，不带百分号。将最终数值四舍五入到四位有效数字。不需要物理单位。",
            "solution": "数据质量维度“完整性”定义为一条记录中所有必填字段都非缺失的概率。设必填字段为 $ A = \\text{age} $，$ S = \\text{sex} $，$ D = \\text{diagnosis} $ 和 $ M = \\text{medication} $。报告的边际缺失率为\n$$\n\\mathbb{P}(A \\text{ missing}) = 0.01, \\quad \\mathbb{P}(S \\text{ missing}) = 0.02, \\quad \\mathbb{P}(D \\text{ missing}) = 0.05, \\quad \\mathbb{P}(M \\text{ missing}) = 0.10.\n$$\n因此，边际存在概率为\n$$\n\\mathbb{P}(A \\text{ present}) = 0.99, \\quad \\mathbb{P}(S \\text{ present}) = 0.98, \\quad \\mathbb{P}(D \\text{ present}) = 0.95, \\quad \\mathbb{P}(M \\text{ present}) = 0.90.\n$$\n\n在完全随机缺失（MCAR）的情况下，字段的存在在各字段之间是独立的，并且与患者特征无关。根据独立事件的乘法法则，MCAR 下的总体完整率为\n$$\n\\mathbb{P}(A \\wedge S \\wedge D \\wedge M) \\;=\\; \\mathbb{P}(A)\\,\\mathbb{P}(S)\\,\\mathbb{P}(D)\\,\\mathbb{P}(M) \\;=\\; 0.99 \\times 0.98 \\times 0.95 \\times 0.90.\n$$\n分步计算乘积：\n$$\n0.99 \\times 0.98 = 0.9702, \\quad 0.9702 \\times 0.95 = 0.92169, \\quad 0.92169 \\times 0.90 = 0.829521.\n$$\n因此，MCAR 下的总体完整率为 $ 0.829521 $。\n\n接下来，我们通过比较 MCAR 与 MNAR 下临床合格成人记录的预期保留率，来量化缺失字段对队列选择的影响。将“合格成人”定义为真实值符合临床标准的患者（年龄至少 $ 18 $ 岁，患有 ICD-10 $ E11 $ 的2型糖尿病，并服用 metformin）。假设字段存在时其值完全准确，没有错误分类。\n\n在 MCAR 下，一个合格成人记录被纳入的概率（即所有四个字段都存在，并且在存在的情况下，记录的值反映了真实值）仅仅是字段存在概率的乘积，因为 MCAR 断定其独立性，且不依赖于真实值：\n$$\n\\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MCAR}) \\;=\\; \\mathbb{P}(A)\\,\\mathbb{P}(S)\\,\\mathbb{P}(D)\\,\\mathbb{P}(M) \\;=\\; 0.829521.\n$$\n\n在非随机缺失（MNAR）下，$ \\mathbb{P}(D \\text{ present}) $ 取决于 $ E11 $ 状态，而 $ \\mathbb{P}(M \\text{ present}) $ 取决于 metformin 状态。对于临床合格的成人亚组，其真实状态是患有 $ E11 $ 和服用 metformin。因此，使用给定的条件存在概率，并假设 $ A $ 和 $ S $ 与其他变量独立：\n$$\n\\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MNAR}) \\;=\\; \\mathbb{P}(A)\\,\\mathbb{P}(S)\\,\\mathbb{P}(D \\text{ present} \\mid E11)\\,\\mathbb{P}(M \\text{ present} \\mid \\text{metformin}).\n$$\n代入数值：\n$$\n\\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MNAR}) \\;=\\; 0.99 \\times 0.98 \\times 0.90 \\times 0.80.\n$$\n分步计算：\n$$\n0.99 \\times 0.98 = 0.9702, \\quad 0.9702 \\times 0.90 = 0.87318, \\quad 0.87318 \\times 0.80 = 0.698544.\n$$\n\n影响差异 $ \\Delta $ 是临床合格成人亚组在 MCAR 和 MNAR 下纳入概率的绝对差值：\n$$\n\\Delta \\;=\\; \\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MCAR}) \\;-\\; \\mathbb{P}(\\text{included} \\mid \\text{eligible adult}, \\text{MNAR}) \\;=\\; 0.829521 \\;-\\; 0.698544 \\;=\\; 0.130977.\n$$\n\n最后，应用四舍五入到四位有效数字的要求。MCAR 下的完整率 $ 0.829521 $ 四舍五入为 $ 0.8295 $。影响差异 $ 0.130977 $ 四舍五入为 $ 0.1310 $。根据要求，两个值都是不带百分号的小数。",
            "answer": "$$\\boxed{\\begin{pmatrix}0.8295  0.1310\\end{pmatrix}}$$"
        }
    ]
}