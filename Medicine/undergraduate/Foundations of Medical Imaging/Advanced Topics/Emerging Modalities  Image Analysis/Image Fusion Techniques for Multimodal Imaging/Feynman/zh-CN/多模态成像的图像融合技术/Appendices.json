{
    "hands_on_practices": [
        {
            "introduction": "在多模态图像融合中，一个根本性的挑战在于不同模态的图像（如PET和MR）具有截然不同的物理单位和强度范围。直接融合这些原始数据可能会导致结果严重偏向某一种模态。因此，在应用凸组合等融合规则之前，必须进行强度归一化，以确保不同模态的数据在可比较的尺度上。本实践将引导你基于明确的统计学约束，推导出一个仿射缩放定律，从而科学地协调PET和MR的强度值，为实现无偏见的图像融合奠定数学基础 。",
            "id": "4891123",
            "problem": "一家医院的研究实验室旨在通过凸组合融合技术，将正电子发射断层扫描（PET）图像与磁共振（MR）幅度图像进行融合，以共同可视化新陈代谢和解剖结构。设PET图像由体素级的标准化摄取值（SUV）表示，记为 $S$，MR图像的强度记为 $M$。融合使用模型 $F = w M + (1 - w) g(S)$，其中 $w \\in [0,1]$，$g$ 是一个确定性映射，它将PET的SUV值重缩放到一个与MR兼容的强度标度。\n\n为了在不同组织间实现科学上可解释的融合，实验室要求融合过程不偏向组织对比度。在操作上，“不偏向组织对比度”意味着，在背景组织水平附近，当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化，并且融合后的背景水平与MR的背景水平相匹配。假设对于均匀感兴趣区域内的图像强度，以下经过充分检验的统计事实成立：平均强度 $\\mu$ 和标准差 $\\sigma$ 表征了典型的背景水平和波动尺度，并且线性映射能保持排序，并以可控的方式缩放均值和方差。\n\n实验室测量了感兴趣区域的统计数据，发现：\n- MR平均值 $\\mu_{\\mathrm{MR}} = 600$（任意MR单位），MR标准差 $\\sigma_{\\mathrm{MR}} = 80$。\n- PET平均值 $\\mu_{\\mathrm{PET}} = 2.0$（SUV），PET标准差 $\\sigma_{\\mathrm{PET}} = 0.5$（SUV）。\n\n从均值、方差和凸组合的核心定义出发，并强制执行上述两个约束条件，推导出显式的仿射缩放定律 $g(S)$，该定律将PET的SUV值映射到一个与MR兼容的标度上，适用于不偏向组织对比度的凸组合融合。请将最终的 $g(S)$ 表示为关于 $S$ 的闭式解析表达式，单位为任意MR单位。无需四舍五入。",
            "solution": "用户希望推导一个仿射缩放定律 $g(S)$，用于将PET图像强度与MR图像强度进行融合。\n\n### 步骤1：提取已知条件\n-   PET图像体素值（SUV）：$S$\n-   MR图像体素值（强度）：$M$\n-   融合模型：$F = w M + (1 - w) g(S)$\n-   权重因子：$w \\in [0,1]$\n-   PET缩放函数：$g(S)$，一个仿射缩放定律\n-   MR背景统计数据：平均值 $\\mu_{\\mathrm{MR}} = 600$，标准差 $\\sigma_{\\mathrm{MR}} = 80$\n-   PET背景统计数据：平均值 $\\mu_{\\mathrm{PET}} = 2.0$，标准差 $\\sigma_{\\mathrm{PET}} = 0.5$\n-   约束1：在背景组织水平附近，当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化。\n-   约束2：融合后的背景水平与MR的背景水平相匹配。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为PET-MR融合是一项标准的医学成像技术。使用凸组合和仿射缩放是成熟的方法。这些约束是客观的，并且可以数学形式化，旨在确保有意义的融合。问题是适定的，提供了两个约束来确定仿射函数的两个参数。所提供的数值是合理的。未检测到任何缺陷。\n\n### 步骤3：结论与行动\n问题有效。将提供完整解答。\n\n### 仿射缩放定律的推导\n\n问题要求推导一个显式的仿射缩放定律，其通用形式为 $g(S) = aS + b$，其中 $a$ 和 $b$ 是待定常数。我们将使用提供的两个约束来建立一个关于 $a$ 和 $b$ 的二元一次方程组。\n\n**约束2分析：匹配背景水平**\n\n该约束规定“融合后的背景水平与MR的背景水平相匹配”。背景水平由平均强度量化。设 $\\mu_F$、$\\mu_{\\mathrm{MR}}$ 和 $\\mu_{g(S)}$ 分别表示融合图像、MR图像和缩放后PET图像的平均值。\n\n缩放后PET图像的平均值 $\\mu_{g(S)}$ 通过应用期望算子得到：\n$$\n\\mu_{g(S)} = E[g(S)] = E[aS + b]\n$$\n利用期望的线性性质，$E[X+Y] = E[X] + E[Y]$ 和 $E[cX] = cE[X]$：\n$$\n\\mu_{g(S)} = a E[S] + b = a\\mu_{\\mathrm{PET}} + b\n$$\n融合图像的平均值 $\\mu_F$ 由下式给出：\n$$\n\\mu_F = E[F] = E[w M + (1 - w) g(S)]\n$$\n假设体素的MR强度和PET SUV是由独立过程生成的，则和的期望等于期望的和：\n$$\n\\mu_F = w E[M] + (1 - w) E[g(S)] = w\\mu_{\\mathrm{MR}} + (1-w)\\mu_{g(S)}\n$$\n约束条件为 $\\mu_F = \\mu_{\\mathrm{MR}}$。将此代入 $\\mu_F$ 的方程中：\n$$\n\\mu_{\\mathrm{MR}} = w\\mu_{\\mathrm{MR}} + (1-w)\\mu_{g(S)}\n$$\n$$\n(1-w)\\mu_{\\mathrm{MR}} = (1-w)\\mu_{g(S)}\n$$\n为了使此关系对任意 $w \\in [0, 1)$（即对于任何非平凡的融合）都成立，缩放后PET图像的平均值必须等于MR图像的平均值：\n$$\n\\mu_{g(S)} = \\mu_{\\mathrm{MR}}\n$$\n代入 $\\mu_{g(S)}$ 的表达式，我们得到关于 $a$ 和 $b$ 的第一个方程：\n$$\na\\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}} \\quad \\quad (1)\n$$\n\n**约束1分析：对标准化变化的相等敏感度**\n\n该约束规定“当 $w = \\frac{1}{2}$ 时，任一模态中相等的标准化变化（一个标准差）会在融合图像中产生等量的变化”。我们可以使用偏导数来形式化融合图像 $F$ 相对于输入图像 $M$ 和 $S$ 变化的敏感度。\n\n融合图像是两个变量的函数，$F(M, S) = wM + (1-w)g(S)$。$F$ 对 $M$ 微小变化的敏感度是 $\\frac{\\partial F}{\\partial M}$，对 $S$ 微小变化的敏感度是 $\\frac{\\partial F}{\\partial S}$。\n$$\n\\frac{\\partial F}{\\partial M} = w\n$$\n$$\n\\frac{\\partial F}{\\partial S} = (1-w) \\frac{d g(S)}{d S} = (1-w)a\n$$\n$M$ 的“标准化变化”被指定为一个标准差，即 $\\sigma_{\\mathrm{MR}}$。由此产生的 $F$ 的变化，记为 $\\Delta F_M$，是：\n$$\n\\Delta F_M = \\frac{\\partial F}{\\partial M} \\sigma_{\\mathrm{MR}} = w\\sigma_{\\mathrm{MR}}\n$$\n同样，$S$ 的标准化变化是 $\\sigma_{\\mathrm{PET}}$，由此产生的 $F$ 的变化，记为 $\\Delta F_S$，是：\n$$\n\\Delta F_S = \\frac{\\partial F}{\\partial S} \\sigma_{\\mathrm{PET}} = (1-w) a \\sigma_{\\mathrm{PET}}\n$$\n约束要求当 $w = \\frac{1}{2}$ 时，这些变化的量值相等：\n$$\n|\\Delta F_M| = |\\Delta F_S| \\quad \\text{在 } w = \\frac{1}{2} \\text{ 时}\n$$\n$$\n\\left| \\frac{1}{2} \\sigma_{\\mathrm{MR}} \\right| = \\left| \\left(1 - \\frac{1}{2}\\right) a \\sigma_{\\mathrm{PET}} \\right|\n$$\n由于标准差是非负的，这可以简化为：\n$$\n\\frac{1}{2} \\sigma_{\\mathrm{MR}} = \\frac{1}{2} |a| \\sigma_{\\mathrm{PET}}\n$$\n$$\n\\sigma_{\\mathrm{MR}} = |a| \\sigma_{\\mathrm{PET}}\n$$\n为了使缩放具有科学可解释性，更高的PET SUV（表示更高的新陈代谢活动）应映射到更高的强度值，这意味着 $a > 0$。因此，我们可以去掉绝对值：\n$$\na \\sigma_{\\mathrm{PET}} = \\sigma_{\\mathrm{MR}} \\quad \\quad (2)\n$$\n\n**求解 $a$ 和 $b$**\n\n我们现在有一个包含两个未知数 $a$ 和 $b$ 的二元一次方程组：\n1.  $a\\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}}$\n2.  $a\\sigma_{\\mathrm{PET}} = \\sigma_{\\mathrm{MR}}$\n\n从方程(2)中，我们求解 $a$：\n$$\na = \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\n$$\n将这个 $a$ 的表达式代入方程(1)以求解 $b$：\n$$\n\\left(\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\\right) \\mu_{\\mathrm{PET}} + b = \\mu_{\\mathrm{MR}}\n$$\n$$\nb = \\mu_{\\mathrm{MR}} - \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} \\mu_{\\mathrm{PET}}\n$$\n完整的仿射缩放定律是 $g(S) = aS + b$。代入 $a$ 和 $b$ 的表达式：\n$$\ng(S) = \\left(\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}\\right) S + \\left(\\mu_{\\mathrm{MR}} - \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} \\mu_{\\mathrm{PET}}\\right)\n$$\n这个表达式可以重排成一个更具洞察力的形式：\n$$\ng(S) = \\mu_{\\mathrm{MR}} + \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} (S - \\mu_{\\mathrm{PET}})\n$$\n此形式表明，PET SUV值 $S$ 首先通过其均值 $\\mu_{\\mathrm{PET}}$ 进行中心化，然后按标准差之比 $\\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}}$ 进行缩放，最后平移以匹配MR的均值 $\\mu_{\\mathrm{MR}}$。\n\n**数值计算**\n\n我们现在代入给定的数值：\n$\\mu_{\\mathrm{MR}} = 600$，$\\sigma_{\\mathrm{MR}} = 80$，$\\mu_{\\mathrm{PET}} = 2.0$，以及 $\\sigma_{\\mathrm{PET}} = 0.5$。\n\n首先，计算 $a$：\n$$\na = \\frac{\\sigma_{\\mathrm{MR}}}{\\sigma_{\\mathrm{PET}}} = \\frac{80}{0.5} = 160\n$$\n接下来，计算 $b$：\n$$\nb = \\mu_{\\mathrm{MR}} - a \\mu_{\\mathrm{PET}} = 600 - (160)(2.0) = 600 - 320 = 280\n$$\n因此，显式的仿射缩放定律是：\n$$\ng(S) = 160S + 280\n$$\n$g(S)$ 的单位是任意MR单位，符合要求。",
            "answer": "$$\n\\boxed{g(S) = 160S + 280}\n$$"
        },
        {
            "introduction": "图像融合的目标远不止于简单地叠加图像，更在于利用一种模态的信息来增强另一种模态的定量准确性。在PET成像中，部分容积效应（Partial Volume Effect, PVE）是限制其对小病灶精确定量的一大障碍。本动手编码实践将向你展示如何利用MR提供的高分辨率解剖结构信息，通过几何传输矩阵（Geometric Transfer Matrix, GTM）方法来校正PET数据中的部分容积效应。你将通过构建一个完整的仿真流程，亲眼见证该校正方法如何显著提高PET图像的定量恢复系数 。",
            "id": "4891216",
            "problem": "您将获得一个简化的二维多模态成像场景，其中包含合成的病灶模型。其中，“正电子发射断层扫描 (PET)” 通道被建模为一个具有高斯点扩散函数 (PSF) 的线性、移不变的成像系统，而 “磁共振 (MR)” 通道提供高分辨率的区域结构分割。测量得到的PET图像被建模为真实活度分布与高斯PSF的卷积。目标是使用几何传输矩阵法进行基于区域的部分容积校正，生成校正前后的融合图像，并量化每个病灶的恢复系数。\n\n基本原理：\n- 成像的线性系统理论：测量得到的PET图像被建模为真实活度分布与系统PSF的卷积，即 $I_{\\mathrm{meas}} = I_{\\mathrm{true}} \\ast h$，其中 $h$ 是一个归一化的高斯PSF，$\\ast$ 表示卷积。\n- 基于区域的活度模型：真实分布被假定在 $K$ 个具有已知掩模 $\\{M_j\\}_{j=1}^{K}$ 的不相交区域上是分段常数，因此 $I_{\\mathrm{true}}(\\mathbf{r}) = \\sum_{j=1}^{K} C_j M_j(\\mathbf{r})$，其中 $C_j$ 是区域活度（常数）。\n- 几何传输矩阵法：将测量得到的PET图像的感兴趣区域均值定义为 $m_i = \\frac{1}{|R_i|}\\int_{R_i} I_{\\mathrm{meas}}(\\mathbf{r}) \\, d\\mathbf{r}$，适用于具有掩模 $M_i$ 的区域 $R_i$，并定义 $G_{ij} = \\frac{1}{|R_i|}\\int_{R_i} (M_j \\ast h)(\\mathbf{r}) \\, d\\mathbf{r}$。那么，测得的区域均值向量 $\\mathbf{m}$ 满足 $\\mathbf{m} = G \\mathbf{C}$，并通过求解线性系统 $\\hat{\\mathbf{C}} = G^{-1} \\mathbf{m}$ 获得 $\\mathbf{C}$ 的估计值，假设 $G$ 是非奇异的。\n- 病灶 $j$ 的恢复系数：$\\mathrm{RC}_j = \\frac{\\bar{I}_{\\mathrm{region},j}}{C^{\\mathrm{true}}_j}$，其中 $\\bar{I}_{\\mathrm{region},j}$ 是病灶区域 $j$ 内的平均强度，$C^{\\mathrm{true}}_j$ 是真实的区域活度。\n\n您必须为每个测试用例执行以下步骤：\n1. 构建一个 $N \\times N$ 的网格，像素大小为 $p$ 毫米，并生成两个圆形病灶掩模和一个背景掩模。真实活度图像为 $I_{\\mathrm{true}}(\\mathbf{r}) = C_1 M_1(\\mathbf{r}) + C_2 M_2(\\mathbf{r}) + C_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})$，其中 $M_{\\mathrm{bg}} = 1 - M_1 - M_2$。\n2. 通过将 $I_{\\mathrm{true}}$ 与标准差为 $\\sigma$ (单位为毫米) 的归一化高斯PSF进行卷积，生成测量得到的PET图像。PSF在像素单位下的标准差为 $\\sigma_{\\mathrm{px}} = \\sigma / p$。\n3. 计算测量得到的PET图像在 $M_1$、$M_2$ 和 $M_{\\mathrm{bg}}$ 上的区域均值 $m_i$。\n4. 构建几何传输矩阵 $G$，其元素 $G_{ij}$ 的计算方法是：将每个掩模 $M_j$ 与PSF进行卷积，然后在区域 $i$ 上对结果进行平均。\n5. 利用线性系统 $G \\hat{\\mathbf{C}} = \\mathbf{m}$ 求解经过部分容积校正的区域活度 $\\hat{\\mathbf{C}} = [\\hat{C}_1,\\hat{C}_2,\\hat{C}_{\\mathrm{bg}}]^\\top$。构建校正后的PET图像 $I_{\\mathrm{corr}}(\\mathbf{r}) = \\hat{C}_1 M_1(\\mathbf{r}) + \\hat{C}_2 M_2(\\mathbf{r}) + \\hat{C}_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})$。\n6. 计算病灶1和2在校正前后的恢复系数，校正前为 $\\mathrm{RC}^{\\mathrm{before}}_j = \\frac{\\bar{I}_{\\mathrm{meas},j}}{C^{\\mathrm{true}}_j}$，校正后为 $\\mathrm{RC}^{\\mathrm{after}}_j = \\frac{\\bar{I}_{\\mathrm{corr},j}}{C^{\\mathrm{true}}_j}$，其中 $\\bar{I}_{\\mathrm{meas},j}$ 和 $\\bar{I}_{\\mathrm{corr},j}$ 分别是 $I_{\\mathrm{meas}}$ 和 $I_{\\mathrm{corr}}$ 在病灶 $j$ 内的平均强度。这些系数是无量纲的。\n7. 使用与结构图像进行简单强度混合的方法，创建校正前后的融合图像。定义一个结构图像 $S$，为病灶分配高强度值，为背景分配较低的值，例如 $S = s_{\\ell}(M_1 + M_2) + s_{\\mathrm{bg}} M_{\\mathrm{bg}}$，其中 $s_{\\ell} = 0.8$，$s_{\\mathrm{bg}} = 0.2$。通过最小-最大归一化将 $S$ 和PET图像都归一化到 $[0,1]$ 区间，并计算 $F_{\\mathrm{before}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{meas,norm}}$ 和 $F_{\\mathrm{after}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{corr,norm}}$，其中 $\\alpha = 0.5$。你不需要输出融合图像，但必须计算它们。\n\n所有图像都是二维数组。强度单位是任意的。长度尺度必须以 $\\mathrm{mm}$ 为单位处理，并按照规定进行像素尺寸转换。不使用角度。恢复系数必须以无单位的小数形式报告。\n\n测试套件：\n- 所有测试用例通用参数：图像尺寸 $N = 128$ 像素，像素大小 $p = 1.0 \\ \\mathrm{mm}$ 每像素，融合混合参数 $\\alpha = 0.5$，结构图像强度 $s_{\\ell} = 0.8$，$s_{\\mathrm{bg}} = 0.2$。\n- 用例 1：\n  - 病灶直径: $d_1 = 12.0 \\ \\mathrm{mm}$，$d_2 = 6.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）: $(x_1,y_1) = (48,64)$，$(x_2,y_2) = (80,64)$。\n  - 真实活度: $C_1 = 5.0$，$C_2 = 3.5$，$C_{\\mathrm{bg}} = 1.0$。\n  - PSF标准差: $\\sigma = 2.5 \\ \\mathrm{mm}$。\n- 用例 2：\n  - 病灶直径: $d_1 = 4.0 \\ \\mathrm{mm}$，$d_2 = 8.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）: $(x_1,y_1) = (40,64)$，$(x_2,y_2) = (92,64)$。\n  - 真实活度: $C_1 = 6.0$，$C_2 = 4.0$，$C_{\\mathrm{bg}} = 1.0$。\n  - PSF标准差: $\\sigma = 3.0 \\ \\mathrm{mm}$。\n- 用例 3：\n  - 病灶直径: $d_1 = 10.0 \\ \\mathrm{mm}$，$d_2 = 10.0 \\ \\mathrm{mm}$。\n  - 病灶中心（以像素为单位）: $(x_1,y_1) = (60,64)$，$(x_2,y_2) = (74,64)$。\n  - 真实活度: $C_1 = 5.0$，$C_2 = 2.0$，$C_{\\mathrm{bg}} = 1.2$。\n  - PSF标准差: $\\sigma = 3.5 \\ \\mathrm{mm}$。\n\n所需最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。\n- 对于每个测试用例，按顺序附加：$\\mathrm{RC}^{\\mathrm{before}}_1$、$\\mathrm{RC}^{\\mathrm{before}}_2$、$\\mathrm{RC}^{\\mathrm{after}}_1$、$\\mathrm{RC}^{\\mathrm{after}}_2$，每个都四舍五入到 $4$ 位小数。\n- 因此，最终输出将是一个包含12个浮点数的扁平列表，按顺序对应于用例1、2和3，总共有12个条目。\n\n您的程序必须为提供的测试套件严格执行上述步骤，并以指定的格式打印结果。不允许用户输入或外部文件。输出是四舍五入到4位小数的无单位小数。",
            "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于线性系统理论应用于医学成像（特别是正电子发射断层扫描(PET)）的原理。该问题是适定的（well-posed），提供了计算所需量的所有必要参数和清晰、客观的程序。指定的方法，即用于部分容积校正的几何传输矩阵（GTM）法，是该领域中一种标准且公认的技术。为合成模型提供的参数对于模拟研究是切合实际的。\n\n解决方案通过执行问题陈述中概述的步骤来进行。问题的核心是校正部分容积效应，这是由于扫描仪空间分辨率有限而导致的PET成像定量准确性下降的问题。这种效应导致在一个小区域内测得的活度是其真实活度与其周围环境活度的混合。GTM方法通过对预定义区域之间的信号“溢出”进行建模来校正此问题。\n\n成像过程的基本模型是一个线性移不变系统，由卷积方程描述：\n$$\nI_{\\mathrm{meas}}(\\mathbf{r}) = (I_{\\mathrm{true}} \\ast h)(\\mathbf{r}) = \\int I_{\\mathrm{true}}(\\mathbf{r}') h(\\mathbf{r} - \\mathbf{r}') \\, d\\mathbf{r}'\n$$\n其中 $I_{\\mathrm{true}}(\\mathbf{r})$ 是放射性示踪剂活度的真实空间分布，$h(\\mathbf{r})$ 是系统的点扩散函数（PSF），$I_{\\mathrm{meas}}(\\mathbf{r})$ 是最终测得的图像。对于此问题，PSF是一个标准差为 $\\sigma$ 的归一化二维高斯函数。\n\n真实活度分布被定义为在 $K=3$ 个不相交区域（两个病灶和一个背景）上是分段常数：\n$$\nI_{\\mathrm{true}}(\\mathbf{r}) = C_1 M_1(\\mathbf{r}) + C_2 M_2(\\mathbf{r}) + C_{\\mathrm{bg}} M_{\\mathrm{bg}}(\\mathbf{r})\n$$\n这里，$C_j$ 是每个区域内真实的、未知的恒定活度，$M_j(\\mathbf{r})$ 是相应的二进制掩模（区域内为1，区域外为0），假设这些掩模可从像MR这样的高分辨率模态中获知。\n\nGTM方法将真实活度向量 $\\mathbf{C} = [C_1, C_2, C_{\\mathrm{bg}}]^\\top$ 与测量的平均活度向量 $\\mathbf{m} = [m_1, m_2, m_{\\mathrm{bg}}]^\\top$ 联系起来，其中 $m_i$ 是 $I_{\\mathrm{meas}}$ 在区域 $i$ 上的平均值。它们的关系是线性系统 $\\mathbf{m} = G\\mathbf{C}$。几何传输矩阵 $G$ 的元素 $G_{ij}$ 表示从区域 $j$ “溢出”到区域 $i$ 测量中的信号分数。\n\n算法流程如下：\n\n1.  **模型生成**：对于每个测试用例，我们构建一个离散的 $N \\times N$ 网格，其中 $N=128$。像素大小为 $p=1.0 \\ \\mathrm{mm}$。在此网格上，我们生成二进制掩模 $M_1$、$M_2$ 和 $M_{\\mathrm{bg}}$。$M_1$ 和 $M_2$ 是由其中心 $(x_j, y_j)$ 和直径 $d_j$ 定义的圆形掩模。背景掩模为 $M_{\\mathrm{bg}} = 1 - M_1 - M_2$。使用真实活度 $C_1, C_2, C_{\\mathrm{bg}}$，合成真实活度图像 $I_{\\mathrm{true}}$。\n\n2.  **图像模糊化**：通过将真实图像 $I_{\\mathrm{true}}$ 与归一化的高斯PSF $h$ 进行卷积来模拟测量的PET图像 $I_{\\mathrm{meas}}$。PSF的标准差以 $\\mathrm{mm}$ 为单位给出，即 $\\sigma$，将其转换为像素单位为 $\\sigma_{\\mathrm{px}} = \\sigma/p$。这种卷积可以使用数字高斯滤波器高效实现。\n    $$\n    I_{\\mathrm{meas}} = I_{\\mathrm{true}} \\ast h\n    $$\n\n3.  **测量均值计算**：通过对 $I_{\\mathrm{meas}}$ 在掩模 $M_i$ 内的像素值求平均，计算每个区域 $i \\in \\{1, 2, \\mathrm{bg}\\}$ 的平均测量活度 $m_i$。用离散形式表示，对于区域 $i$：\n    $$\n    m_i = \\frac{\\sum_{\\mathbf{p}} (I_{\\mathrm{meas}})_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}{\\sum_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}\n    $$\n    其中求和遍及网格中的所有像素 $\\mathbf{p}$。\n\n4.  **几何传输矩阵构建**：构建 $3 \\times 3$ 矩阵 $G$。每个元素 $G_{ij}$ 的计算方法是：首先将源区域的掩模 $M_j$ 与PSF $h$进行卷积，然后将得到的模糊掩模在“目标”区域 $M_i$ 上求平均。\n    $$\n    G_{ij} = \\frac{\\sum_{\\mathbf{p}} ((M_j \\ast h)_{\\mathbf{p}} (M_i)_{\\mathbf{p}})}{\\sum_{\\mathbf{p}} (M_i)_{\\mathbf{p}}}\n    $$\n    该矩阵量化了所有区域对之间的空间串扰。\n\n5.  **部分容积校正**：利用测量均值向量 $\\mathbf{m}$ 和矩阵 $G$，我们求解线性方程组 $G\\hat{\\mathbf{C}} = \\mathbf{m}$，以找到估计的（或经部分容积校正的）活度 $\\hat{\\mathbf{C}} = [\\hat{C}_1, \\hat{C}_2, \\hat{C}_{\\mathrm{bg}}]^\\top$。\n    $$\n    \\hat{\\mathbf{C}} = G^{-1}\\mathbf{m}\n    $$\n    这可以通过使用标准的线性代数求解器来实现。然后使用这些估计的活度合成一个校正后的图像 $I_{\\mathrm{corr}}$：$I_{\\mathrm{corr}} = \\hat{C}_1 M_1 + \\hat{C}_2 M_2 + \\hat{C}_{\\mathrm{bg}} M_{\\mathrm{bg}}$。\n\n6.  **恢复系数定量**：为了评估校正的性能，我们为每个病灶计算一个恢复系数（RC）。RC是测量或估计的平均活度与真实活度之比。\n    校正前，对于病灶 $j \\in \\{1, 2\\}$：\n    $$\n    \\mathrm{RC}^{\\mathrm{before}}_j = \\frac{m_j}{C^{\\mathrm{true}}_j}\n    $$\n    校正后，根据构造，校正图像 $I_{\\mathrm{corr}}$ 中区域 $j$ 的平均活度恰好是 $\\hat{C}_j$。因此，校正后的RC为：\n    $$\n    \\mathrm{RC}^{\\mathrm{after}}_j = \\frac{\\hat{C}_j}{C^{\\mathrm{true}}_j}\n    $$\n    RC为1.0表示完美恢复了真实活度。\n\n7.  **图像融合**：尽管融合图像不属于最终数值输出的一部分，但仍需生成它们。创建一个结构图像 $S = s_{\\ell}(M_1+M_2) + s_{\\mathrm{bg}}M_{\\mathrm{bg}}$。PET图像（$I_{\\mathrm{meas}}$、$I_{\\mathrm{corr}}$）和结构图像 $S$ 被归一化到 $[0, 1]$ 范围。然后通过加权和创建融合图像，例如，$F_{\\mathrm{before}} = \\alpha S_{\\mathrm{norm}} + (1-\\alpha) I_{\\mathrm{meas,norm}}$，其中 $\\alpha=0.5$。\n\n将此完整过程应用于三个测试用例中的每一个，并计算和报告每个用例的四个恢复系数（$\\mathrm{RC}^{\\mathrm{before}}_1, \\mathrm{RC}^{\\mathrm{before}}_2, \\mathrm{RC}^{\\mathrm{after}}_1, \\mathrm{RC}^{\\mathrm{after}}_2$）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.ndimage import gaussian_filter\n\ndef solve():\n    \"\"\"\n    Solves the partial volume correction problem for the given test suite.\n    \"\"\"\n    \n    # Common parameters for all test cases\n    N = 128\n    p = 1.0  # mm/pixel\n    alpha = 0.5\n    s_l = 0.8\n    s_bg = 0.2\n\n    test_cases = [\n        # Case 1\n        {'d': (12.0, 6.0), 'center': ((48, 64), (80, 64)), 'C_true': (5.0, 3.5, 1.0), 'sigma': 2.5},\n        # Case 2\n        {'d': (4.0, 8.0), 'center': ((40, 64), (92, 64)), 'C_true': (6.0, 4.0, 1.0), 'sigma': 3.0},\n        # Case 3\n        {'d': (10.0, 10.0), 'center': ((60, 64), (74, 64)), 'C_true': (5.0, 2.0, 1.2), 'sigma': 3.5},\n    ]\n\n    all_results = []\n    \n    # Create coordinate grid for mask generation\n    # yy corresponds to rows (y-coordinate), xx to columns (x-coordinate)\n    yy, xx = np.mgrid[:N, :N]\n\n    for case in test_cases:\n        # Step 1: Construct true image and masks\n        radii_mm = (case['d'][0] / 2.0, case['d'][1] / 2.0)\n        radii_px = [r / p for r in radii_mm]\n        centers_px = case['center'] # (x, y) = (col, row)\n        \n        dist_sq_1 = (xx - centers_px[0][0])**2 + (yy - centers_px[0][1])**2\n        dist_sq_2 = (xx - centers_px[1][0])**2 + (yy - centers_px[1][1])**2\n        \n        M1 = (dist_sq_1 = radii_px[0]**2).astype(float)\n        M2 = (dist_sq_2 = radii_px[1]**2).astype(float)\n        M_bg = 1.0 - M1 - M2\n        \n        masks = [M1, M2, M_bg]\n        region_pixels = [np.sum(m) for m in masks]\n\n        C_true_vec = np.array(case['C_true'])\n        I_true = C_true_vec[0] * M1 + C_true_vec[1] * M2 + C_true_vec[2] * M_bg\n        \n        # Step 2: Generate the measured PET image by convolution\n        sigma_px = case['sigma'] / p\n        I_meas = gaussian_filter(I_true, sigma=sigma_px, mode='reflect')\n\n        # Step 3: Compute the region-wise means of the measured image\n        m_measured = np.array([np.sum(I_meas * M) / num_pix if num_pix > 0 else 0 \n                               for M, num_pix in zip(masks, region_pixels)])\n\n        # Step 4: Form the geometric transfer matrix G\n        G = np.zeros((3, 3))\n        for j in range(3):  # For each source region mask M_j\n            M_j_blurred = gaussian_filter(masks[j], sigma=sigma_px, mode='reflect')\n            for i in range(3):  # For each target region of interest M_i\n                if region_pixels[i] > 0:\n                    G[i, j] = np.sum(M_j_blurred * masks[i]) / region_pixels[i]\n                else:\n                    G[i, j] = 0\n\n        # Step 5: Solve for corrected activities and create corrected image\n        try:\n            C_hat = np.linalg.solve(G, m_measured)\n        except np.linalg.LinAlgError:\n            # In case of a singular matrix, use pseudo-inverse\n            C_hat = np.linalg.pinv(G) @ m_measured\n        \n        I_corr = C_hat[0] * M1 + C_hat[1] * M2 + C_hat[2] * M_bg\n\n        # Step 6: Compute recovery coefficients\n        RC_before_1 = m_measured[0] / C_true_vec[0]\n        RC_before_2 = m_measured[1] / C_true_vec[1]\n        \n        # Mean of corrected image in region j is C_hat_j by construction\n        RC_after_1 = C_hat[0] / C_true_vec[0]\n        RC_after_2 = C_hat[1] / C_true_vec[1]\n        \n        # Step 7: Create fused images (as required by problem, though not directly output)\n        S = s_l * (M1 + M2) + s_bg * M_bg\n        \n        def normalize(img):\n            min_val = np.min(img)\n            max_val = np.max(img)\n            if max_val == min_val:\n                return np.zeros_like(img) \n            return (img - min_val) / (max_val - min_val)\n\n        S_norm = normalize(S)\n        I_meas_norm = normalize(I_meas)\n        I_corr_norm = normalize(I_corr)\n        \n        F_before = alpha * S_norm + (1 - alpha) * I_meas_norm\n        F_after = alpha * S_norm + (1 - alpha) * I_corr_norm\n        \n        # Append results for the current case to the main list\n        case_results = [RC_before_1, RC_before_2, RC_after_1, RC_after_2]\n        all_results.extend(case_results)\n\n    # Format the final output string\n    final_output_str = [f\"{r:.4f}\" for r in all_results]\n    print(f\"[{','.join(final_output_str)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了设计更强大和灵活的融合算法，现代方法常将图像融合构建为一个复杂的优化问题。这种变分方法允许我们在融合过程中强制施加期望的属性，例如在保留重要特征的同时抑制噪声。本高级编码实践将带你探索一种基于小波域的尖端融合模型，该模型通过一个混合范数正则化项来促进小波细节系数的组稀疏性。你将亲手实现邻近梯度法（Proximal Gradient Method, PGM）来求解这个非光滑凸优化问题，深入理解如何将复杂的数学模型转化为有效的融合算法 。",
            "id": "4891205",
            "problem": "给定两个大小为 $N \\times N$（其中 $N$ 为偶数）的无量纲模态图像 $y^{(1)}$ 和 $y^{(2)}$，以及一个作用于 $\\mathbb{R}^{N \\times N}$ 上的单层、正交二维哈尔(Haar)小波变换 $W$。融合变量是小波域系数张量 $c \\in \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$，该张量由四个子带 $(\\mathrm{LL}, \\mathrm{LH}, \\mathrm{HL}, \\mathrm{HH})$ 堆叠而成。设保真度权重为 $\\alpha_1, \\alpha_2  0$，定义凸目标函数为\n$$\nF(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 + \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2,\n$$\n其中，第二项是混合范数，它对每个空间位置 $(i,j)$ 处的高频系数三元组施加 $\\ell_2$-范数，然后将得到的幅值求和（即 $\\ell_{2,1}$ 范数）。低频系数 $c_{\\mathrm{LL}}$ 不受惩罚。此处，离散小波变换（DWT）指的是正交单层二维哈尔变换，而近端梯度法（PGM）指的是一种迭代方法，该方法在光滑部分上交替执行梯度下降步骤，在非光滑部分上交替执行近端操作。\n\n基于以下基本前提：\n- 二次保真度项的梯度是利普希茨(Lipschitz)连续的，其常数为某个 $L  0$，\n- 可分离范数和的近端算子在每个 $(i,j)$ 位置上按组作用，\n请推导 $c$ 的近端梯度迭代式（步长为常数，等于梯度利普希茨常数的倒数）并加以实现。您还必须推导并实现作用于每个空间位置 $(i,j)$ 的三元组 $\\left(c_{\\mathrm{LH}}[i,j], c_{\\mathrm{HL}}[i,j], c_{\\mathrm{HH}}[i,j]\\right)$ 上的混合范数的近端算子。\n\n在优化 $c$ 之后，重建融合图像 $x^\\star = W^\\top c^\\star$，并为下方的每个测试用例计算最终的目标函数值 $F(c^\\star)$。所有输出均为无量纲实数。\n\n实现细节和要求：\n- 对大小为 $N \\times N$（其中 $N$ 为偶数）的图像，明确地实现单层正交哈尔DWT $W$ 及其逆变换 $W^\\top$。\n- 使用恒定步长，其值等于保真度项梯度的利普希茨常数的倒数。\n- 精确运行 $K$ 次迭代，其中 $K$ 在测试套件中指定。\n\n测试套件（每个用例定义了 $y^{(1)}$, $y^{(2)}$, $\\alpha_1$, $\\alpha_2$, $\\lambda$, $K$）：\n- 用例 1（正常路径）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 1  1  1  1 \\\\ 1  2  2  1 \\\\ 1  2  2  1 \\\\ 1  1  1  1 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.2$, $K = 200$\n- 用例 2（边界情况，无正则化）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 1  1  1  1 \\\\ 1  2  2  1 \\\\ 1  2  2  1 \\\\ 1  1  1  1 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.0$, $K = 200$\n- 用例 3（边缘情况，模态相同）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\\\ 2  2  2  2 \\end{bmatrix}$\n  - $\\alpha_1 = 1.0$, $\\alpha_2 = 1.0$, $\\lambda = 0.5$, $K = 200$\n- 用例 4（不同模态权重）：\n  - $N = 4$\n  - $y^{(1)} = \\begin{bmatrix} 0  1  0  1 \\\\ 1  0  1  0 \\\\ 0  1  0  1 \\\\ 1  0  1  0 \\end{bmatrix}$\n  - $y^{(2)} = \\begin{bmatrix} 0  0  0  0 \\\\ 0  3  3  0 \\\\ 0  3  3  0 \\\\ 0  0  0  0 \\end{bmatrix}$\n  - $\\alpha_1 = 3.0$, $\\alpha_2 = 0.5$, $\\lambda = 0.1$, $K = 200$\n\n您的程序应生成单行输出，其中包含四个用例的最终目标值 $F(c^\\star)$，格式为方括号内以逗号分隔的列表，并按上述用例的顺序排列（例如，$[0.123,0.456,0.789,1.234]$）。输出为无量纲实数。",
            "solution": "用户希望使用近端梯度法 (PGM) 解决一个用于图像融合的凸优化问题。我将首先验证问题陈述，然后推导必要的数学组件，最后构建解决方案。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **模态图像**：两个大小为 $N \\times N$（$N$为偶数）的无量纲图像 $y^{(1)}, y^{(2)}$。\n- **小波变换**：一个单层、正交的二维哈尔(Haar)小波变换 $W: \\mathbb{R}^{N \\times N} \\to \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$。其伴随（逆）变换为 $W^\\top$。\n- **优化变量**：小波系数张量 $c \\in \\mathbb{R}^{4 \\times \\frac{N}{2} \\times \\frac{N}{2}}$，由四个子带 $\\{c_{\\mathrm{LL}}, c_{\\mathrm{LH}}, c_{\\mathrm{HL}}, c_{\\mathrm{HH}}\\}$ 组成。\n- **目标函数**：\n$$\nF(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 + \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2\n$$\n- **参数**：保真度权重 $\\alpha_1, \\alpha_2  0$；正则化参数 $\\lambda \\ge 0$。\n- **算法**：近端梯度法 (PGM)，使用恒定步长 $\\tau=1/L$，其中 $L$ 是 $F(c)$ 光滑部分的梯度的利普希茨常数。\n- **迭代次数**：精确地 $K$ 次迭代。\n- **最终输出**：当 $c^\\star$ 是经过 $K$ 次迭代后的系数张量时，目标函数的值 $F(c^\\star)$。\n- **测试套件**：四个测试用例，指定了 $N, y^{(1)}, y^{(2)}, \\alpha_1, \\alpha_2, \\lambda, K$。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n- **科学严谨性**：该问题描述了一个用于多模态图像融合的标准且成熟的变分模型。目标函数由一个二次数据保真度项和一个混合范数正则化项（$\\ell_{2,1}$-范数）组成，这是促进小波系数群稀疏性的常见选择。使用 PGM 是解决此类非光滑凸优化问题的先进方法。哈尔小波变换是信号处理中的一个基本工具。该公式在科学和数学上都是合理的。\n- **适定性**：目标函数 $F(c)$ 是一个严格凸的二次函数（当 $\\alpha_1, \\alpha_2  0$ 时）和一个凸的非光滑函数的和。因此，这个和是严格凸的，保证了唯一最小化子的存在。该问题是适定的。\n- **客观性**：问题使用精确的数学符号和客观的语言进行陈述，没有歧义或主观论断。\n- **完整性和一致性**：问题为完整求解提供了所有必要的数据和参数。提供的测试用例是完整的。没有内部矛盾。\n- **现实性**：该设置是计算成像领域的标准模型，在此背景下完全现实。\n- **结构**：问题结构清晰。要求运行 $K$ 次迭代，尽管特定的步长选择会导致算法在一步内收敛，但这应被视为一个必须遵守的指令，而不是一个使问题无效的缺陷。算法的行为是问题有效的数学结构的直接结果。\n\n**步骤 3：结论与行动**\n\n此问题是**有效的**。将继续进行求解过程。\n\n### 近端梯度法迭代的推导\n\n目标函数 $F(c)$ 可以分解为一个光滑可微的部分 $g(c)$ 和一个非光滑凸的部分 $h(c)$。\n$$ F(c) = g(c) + h(c) $$\n其中\n$$ g(c) = \\frac{1}{2} \\sum_{m=1}^{2} \\alpha_m \\left\\| c - W y^{(m)} \\right\\|_2^2 $$\n$$ h(c) = \\lambda \\sum_{i=1}^{\\frac{N}{2}} \\sum_{j=1}^{\\frac{N}{2}} \\left\\| \\begin{bmatrix} c_{\\mathrm{LH}}[i,j] \\\\ c_{\\mathrm{HL}}[i,j] \\\\ c_{\\mathrm{HH}}[i,j] \\end{bmatrix} \\right\\|_2 $$\n为简化表示，令 $c_m = W y^{(m)}$。对于张量 $A$，平方$\\ell_2$-范数 $\\|A\\|_2^2$ 被解释为弗罗贝尼乌斯范数的平方，即其所有元素的平方和。\n\n**1. 光滑部分的梯度，$\\nabla g(c)$**\n\n函数 $g(c)$ 是一个关于 $c$ 的二次函数。其梯度通过对 $c$ 求导得到：\n$$ \\nabla g(c) = \\sum_{m=1}^{2} \\alpha_m (c - c_m) = (\\alpha_1 + \\alpha_2)c - (\\alpha_1 c_1 + \\alpha_2 c_2) $$\n\n**2. 梯度的利普希茨常数，$L$**\n\n$\\nabla g(c)$ 的利普希茨常数 $L$ 是其海森矩阵的谱范数。$g(c)$ 的海森矩阵为：\n$$ \\nabla^2 g(c) = (\\alpha_1 + \\alpha_2) I $$\n其中 $I$ 是单位算子。利普希茨常数是海森矩阵的最大（绝对值）特征值，显然为：\n$$ L = \\alpha_1 + \\alpha_2 $$\n问题指定了恒定步长 $\\tau = 1/L$。\n$$ \\tau = \\frac{1}{\\alpha_1 + \\alpha_2} $$\n\n**3. 近端梯度法迭代**\n\nPGM 的更新规则为：\n$$ c^{(k+1)} = \\mathrm{prox}_{\\tau h}\\left(c^{(k)} - \\tau \\nabla g(c^{(k)})\\right) $$\n我们来分析近端算子的参数：\n$$ c^{(k)} - \\tau \\nabla g(c^{(k)}) = c^{(k)} - \\frac{1}{\\alpha_1 + \\alpha_2} \\left( (\\alpha_1 + \\alpha_2)c^{(k)} - (\\alpha_1 c_1 + \\alpha_2 c_2) \\right) $$\n$$ = c^{(k)} - c^{(k)} + \\frac{\\alpha_1 c_1 + \\alpha_2 c_2}{\\alpha_1 + \\alpha_2} $$\n$$ = \\frac{\\alpha_1 W y^{(1)} + \\alpha_2 W y^{(2)}}{\\alpha_1 + \\alpha_2} $$\n我们将这个常数张量记为 $\\bar{c}$：\n$$ \\bar{c} = \\frac{\\alpha_1 W y^{(1)} + \\alpha_2 W y^{(2)}}{\\alpha_1 + \\alpha_2} $$\n近端算子的参数与迭代次数 $k$ 无关。更新规则简化为：\n$$ c^{(k+1)} = \\mathrm{prox}_{\\tau h}(\\bar{c}) $$\n这意味着迭代序列 $c^{(k)}$ 在一步之内就收敛到解 $c^\\star = \\mathrm{prox}_{\\tau h}(\\bar{c})$。尽管如此，我们仍将按照要求实现 $K$ 次迭代的循环。\n\n**4. 非光滑部分的近端算子，$\\mathrm{prox}_{\\tau h}(z)$**\n\n非光滑项 $h(c)$ 是在不相交的系数群组上的范数之和。这种可分离性使得近端算子可以按组计算。\n正则化不适用于低频子带 $c_{\\mathrm{LL}}$，因此对于这些系数，$h(c)$ 为零。因此，近端算子对于该子带是恒等算子：\n$$ (\\mathrm{prox}_{\\tau h}(z))_{\\mathrm{LL}} = z_{\\mathrm{LL}} $$\n对于高频（细节）子带，在每个空间位置 $(i,j)$，我们必须求解：\n$$ \\arg\\min_{v \\in \\mathbb{R}^3} \\left( \\frac{1}{2} \\| v - u \\|_2^2 + \\tau \\lambda \\|v\\|_2 \\right) $$\n其中 $u = \\begin{bmatrix} z_{\\mathrm{LH}}[i,j] \\\\ z_{\\mathrm{HL}}[i,j] \\\\ z_{\\mathrm{HH}}[i,j] \\end{bmatrix}$ 是输入张量 $z$ 在该位置的系数向量。这是缩放后 $\\ell_2$-范数的近端算子，也称为向量软阈值或组软阈值。其解为：\n$$ \\mathrm{prox}_{\\tau\\lambda \\|\\cdot\\|_2}(u) = \\left( 1 - \\frac{\\tau \\lambda}{\\|u\\|_2} \\right)_+ u = \\max\\left(0, 1 - \\frac{\\tau \\lambda}{\\|u\\|_2}\\right) u $$\n其中 $(\\cdot)_+ = \\max(0, \\cdot)$。\n在实践中，对于每个 $(i,j)$：\n1. 提取向量 $u = (z_{\\mathrm{LH}}[i,j], z_{\\mathrm{HL}}[i,j], z_{\\mathrm{HH}}[i,j])$。\n2. 计算其 $\\ell_2$-范数，$n = \\|u\\|_2$。\n3. 如果 $n > \\tau \\lambda$，更新后的向量为 $\\left(1 - \\frac{\\tau \\lambda}{n}\\right) u$。\n4. 如果 $n \\le \\tau \\lambda$，更新后的向量为 $(0, 0, 0)$。\n\n### 最终算法总结\n1.  对于每个输入图像 $y^{(m)}$，计算其小波变换 $c_m = W y^{(m)}$。\n2.  计算利普希茨常数 $L = \\alpha_1 + \\alpha_2$ 和步长 $\\tau = 1/L$。\n3.  初始化系数张量 $c^{(0)}$（例如，全零）。\n4.  对于 $k = 0, \\dots, K-1$：\n    a. 计算梯度下降更新的参数：$z = c^{(k)} - \\tau \\nabla g(c^{(k)})$。如前所推导，这简化为常数 $\\bar{c} = (\\alpha_1 c_1 + \\alpha_2 c_2)/L$。\n    b. 应用近端算子得到 $c^{(k+1)} = \\mathrm{prox}_{\\tau h}(z)$。\n        i.  LL 子带直接通过：$(c^{(k+1)})_{\\mathrm{LL}} = z_{\\mathrm{LL}}$。\n        ii. 对于 $\\frac{N}{2} \\times \\frac{N}{2}$ 子带中的每个空间索引 $(i,j)$，对细节系数三元组 $(z_{\\mathrm{LH}}[i,j], z_{\\mathrm{HL}}[i,j], z_{\\mathrm{HH}}[i,j])$ 应用阈值为 $\\tau\\lambda$ 的向量软阈值。\n5.  经过 $K$ 次迭代后，结果为 $c^\\star = c^{(K)}$。\n6.  计算最终目标函数值 $F(c^\\star)$：\n    $F(c^\\star) = \\frac{1}{2} \\alpha_1 \\| c^\\star - c_1 \\|_2^2 + \\frac{1}{2} \\alpha_2 \\| c^\\star - c_2 \\|_2^2 + \\lambda \\sum_{i,j} \\|(c^\\star_{\\mathrm{LH}}[i,j], c^\\star_{\\mathrm{HL}}[i,j], c^\\star_{\\mathrm{HH}}[i,j])\\|_2$。\n\n这个完整、合理的流程将被实现，以解决给定测试用例的问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the image fusion problem for all test cases.\n    \"\"\"\n    \n    # Test suite from the problem statement\n    test_cases = [\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.2, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.0, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n            \"y2\": np.array([[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]]),\n            \"alpha1\": 1.0, \"alpha2\": 1.0, \"lam\": 0.5, \"K\": 200\n        },\n        {\n            \"N\": 4,\n            \"y1\": np.array([[0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0]]),\n            \"y2\": np.array([[0, 0, 0, 0], [0, 3, 3, 0], [0, 3, 3, 0], [0, 0, 0, 0]]),\n            \"alpha1\": 3.0, \"alpha2\": 0.5, \"lam\": 0.1, \"K\": 200\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = _solve_single_case(params)\n        results.append(result)\n        \n    # Format the final output string\n    output_str = f\"[{','.join(f'{r:.7f}' for r in results)}]\"\n    print(output_str)\n\ndef _haar_1d(v):\n    \"\"\"Computes the 1D orthonormal Haar wavelet transform.\"\"\"\n    N = len(v)\n    if N  2: return v\n    N_half = N // 2\n    v_even = v[::2]\n    v_odd = v[1::2]\n    sqrt2_inv = 1 / np.sqrt(2.0)\n    averages = (v_even + v_odd) * sqrt2_inv\n    details = (v_even - v_odd) * sqrt2_inv\n    return np.concatenate((averages, details))\n\ndef _dwt2(image):\n    \"\"\"Computes the 2D orthonormal single-level Haar wavelet transform.\"\"\"\n    N = image.shape[0]\n    N_half = N // 2\n    \n    # 1. Apply 1D Haar to each row\n    temp = np.apply_along_axis(_haar_1d, 1, image)\n    \n    # 2. Apply 1D Haar to each column of the result\n    coeffs_matrix = np.apply_along_axis(_haar_1d, 0, temp)\n    \n    # 3. Separate into 4 subbands and stack them\n    c_ll = coeffs_matrix[:N_half, :N_half]\n    c_hl = coeffs_matrix[N_half:, :N_half]\n    c_lh = coeffs_matrix[:N_half, N_half:]\n    c_hh = coeffs_matrix[N_half:, N_half:]\n    \n    return np.stack([c_ll, c_lh, c_hl, c_hh], axis=0)\n\ndef _solve_single_case(params):\n    \"\"\"Implements the PGM for a single test case.\"\"\"\n    N = params[\"N\"]\n    y1 = params[\"y1\"].astype(float)\n    y2 = params[\"y2\"].astype(float)\n    alpha1 = params[\"alpha1\"]\n    alpha2 = params[\"alpha2\"]\n    lam = params[\"lam\"]\n    K = params[\"K\"]\n\n    N_half = N // 2\n\n    # Step 1: Compute wavelet transforms of input images\n    c1 = _dwt2(y1)\n    c2 = _dwt2(y2)\n\n    # Step 2: Compute algorithm parameters\n    L = alpha1 + alpha2\n    tau = 1.0 / L\n\n    # Step 3: Initialize coefficient tensor\n    c_k = np.zeros_like(c1)\n\n    # Pre-compute the argument to the prox operator, as it's constant\n    z = (alpha1 * c1 + alpha2 * c2) / L\n    \n    # Step 4: PGM Iteration\n    for _ in range(K):\n        # Proximal step\n        c_k_plus_1 = np.zeros_like(z)\n        \n        # LL subband (no regularization)\n        c_k_plus_1[0, :, :] = z[0, :, :]\n        \n        # Detail subbands (LH, HL, HH)\n        threshold = tau * lam\n        \n        if threshold > 0:\n            # Extract detail coefficient vectors for all spatial locations\n            # Shape: (N_half*N_half, 3)\n            detail_vectors = np.stack([\n                z[1, :, :].ravel(),  # LH\n                z[2, :, :].ravel(),  # HL\n                z[3, :, :].ravel()   # HH\n            ], axis=1)\n\n            # Compute norms for all vectors at once\n            norms = np.linalg.norm(detail_vectors, axis=1) # Shape: (N_half*N_half,)\n            \n            # Compute scaling factors\n            scale = np.maximum(0.0, 1.0 - threshold / np.where(norms > 1e-12, norms, 1e-12))\n            \n            # Apply scaling\n            prox_vectors = detail_vectors * scale[:, np.newaxis]\n            \n            # Reshape and place back into c_k_plus_1\n            c_k_plus_1[1, :, :] = prox_vectors[:, 0].reshape(N_half, N_half)\n            c_k_plus_1[2, :, :] = prox_vectors[:, 1].reshape(N_half, N_half)\n            c_k_plus_1[3, :, :] = prox_vectors[:, 2].reshape(N_half, N_half)\n        else: # No regularization, just copy details\n            c_k_plus_1[1:4, :, :] = z[1:4, :, :]\n            \n        c_k = c_k_plus_1\n        \n    c_star = c_k\n\n    # Step 6: Compute the final objective function value F(c*)\n    fidelity_term1 = 0.5 * alpha1 * np.sum((c_star - c1) ** 2)\n    fidelity_term2 = 0.5 * alpha2 * np.sum((c_star - c2) ** 2)\n    \n    regularization_term = 0.0\n    if lam > 0:\n        detail_vectors_star = np.stack([\n            c_star[1, :, :].ravel(),\n            c_star[2, :, :].ravel(),\n            c_star[3, :, :].ravel()\n        ], axis=1)\n        norms_star = np.linalg.norm(detail_vectors_star, axis=1)\n        regularization_term = lam * np.sum(norms_star)\n        \n    final_objective_value = fidelity_term1 + fidelity_term2 + regularization_term\n    \n    return final_objective_value\n\nsolve()\n```"
        }
    ]
}