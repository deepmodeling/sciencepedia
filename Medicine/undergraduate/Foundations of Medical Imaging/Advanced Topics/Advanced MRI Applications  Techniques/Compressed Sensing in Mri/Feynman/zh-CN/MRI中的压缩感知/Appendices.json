{
    "hands_on_practices": [
        {
            "introduction": "压缩感知之所以有效，其核心思想在于将传统采样方法中产生的结构化、相干的混叠伪影 (aliasing artifacts) 转化为非相干的、类似噪声的伪影，从而便于后续的去噪处理。本练习将引导你通过一个计算实验来亲身体验这一关键效应。你将生成两种不同类型的k空间采样掩模，并检查它们各自对应的点扩散函数 (Point Spread Function, PSF)，从而量化地理解为何随机采样在产生非相干伪影方面优于周期性的结构化采样 。这将为你深入理解压缩感知磁共振成像的基本原理建立起直观的认识。",
            "id": "4870620",
            "problem": "您将执行一项任务，该任务基于磁共振成像（MRI）中频域采样与图像域混叠之间的关系。请使用离散傅里叶变换（DFT）框架，具体如下。\n\n基本原理：在二维成像中，当图像网格上的一个离散物体通过二维离散傅里叶变换（DFT）转换到频域时，会得到其频率表示。频域中的欠采样对应于将全采样的频率数据乘以一个二元采样掩模。在图像域中，这种乘法操作对应于与采样掩模的逆DFT（即点扩散函数，PSF）进行卷积。因此，对于一个采样掩模，图像域中的混叠伪影由PSF来表征。结构化的周期性采样通常会产生相干的混叠（鬼影），而随机采样则会产生不相干的、类似噪声的伪影。这些是医学成像和压缩感知基础中经过充分验证的标准事实。\n\n目标：编写一个程序，在一个大小为 $N \\times N$（其中 $N$ 为给定值）的二维网格上，沿着相位编码方向（$k_y$ 轴）构建两种类型的频域采样掩模，并使用基于PSF的度量标准比较每种掩模引起的混叠鬼影的相干性。\n\n使用的定义：\n- 采样掩模的二维逆DFT（记作 $\\mathrm{IDFT}_2$）产生点扩散函数 $p(\\mathbf{r})$，其中 $\\mathbf{r}$ 是图像域像素的索引。您可以使用任何归一化方式来实现 $\\mathrm{IDFT}_2$，因为下面的度量标准由一个比率定义，该比率会抵消掉一致的缩放因子。\n- PSF的幅度为 $|p(\\mathbf{r})|$。\n- 令 $p_0$ 为移位后PSF的中心像素（即，在应用移位以使零频分量居中之后），并令 $\\mathcal{R}$ 表示除中心点外的所有像素的集合。定义一个掩模的混叠鬼影相coherent性比率为\n$$\nC \\;=\\; \\frac{\\max_{\\mathbf{r} \\in \\mathcal{R}} |p(\\mathbf{r})|}{\\operatorname{mean}_{\\mathbf{r} \\in \\mathcal{R}} |p(\\mathbf{r})|}.\n$$\n如果在 $\\mathcal{R}$ 上 $|p(\\mathbf{r})|$ 恒为零，则定义 $C = 0$。\n\n为每个测试用例 $(N, R)$ 构建的采样掩模：\n- 随机移位的笛卡尔掩模：从 $\\{0, 1, \\dots, R-1\\}$ 中均匀选择一个随机整数移位 $s$，并选择所有满足 $(k_y - s) \\bmod R = 0$ 的相位编码线 $k_y$。对于每个选定的 $k_y$，包含其在所有 $k_x$ 上的整条线（即，将掩模中的这些行设置为1，其他行设置为0）。这将产生一组具有随机循环移位的周期性线。\n- 采样密度匹配的全随机掩模：令 $M$ 为在给定的 $(N, R)$ 实现中，由随机移位的笛卡尔掩模选定的线的数量。从 $\\{0,1,\\dots,N-1\\}$ 中独立地均匀随机选择一个包含 $M$ 个不同 $k_y$ 索引的集合，并包含这些在所有 $k_x$ 上的整条线。\n\n对于每个掩模，计算其PSF $p(\\mathbf{r})$（作为掩模的二维逆DFT），应用频率移位使中心瓣位于中心，排除中心像素，并如上所述计算相干性比率 $C$。\n\n比较任务：对于每个测试用例 $(N, R)$，计算：\n- $C_{\\mathrm{shift}}$：随机移位的笛卡尔掩模的相干性比率。\n- $C_{\\mathrm{rand}}$：线数匹配的全随机掩模的相干性比率。\n\n为每个测试用例生成一个布尔结果，指示是否 $C_{\\mathrm{rand}}  C_{\\mathrm{shift}}$。\n\n随机性与可复现性：\n- 对于基础生成器，使用固定的随机种子 $s_0 = 2025$。\n- 对于从0开始的测试用例索引 $i$，使用种子 $s_0 + i$ 为该用例生成移位 $s$ 和随机线子集，以确保可复现性。\n\n测试套件：\n- 用例 1：$(N, R) = (64, 4)$。\n- 用例 2：$(N, R) = (64, 8)$。\n- 用例 3：$(N, R) = (64, 1)$。\n- 用例 4：$(N, R) = (60, 7)$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True}]$。\n- 每个测试用例的结果是一个布尔值，指示该用例是否满足 $C_{\\mathrm{rand}}  C_{\\mathrm{shift}}$，结果顺序与测试套件中的用例顺序相同。\n\n此问题不涉及物理单位。角度不参与计算。所有数值输出均为指定的布尔值。程序必须是自包含的，并且不需要任何输入。",
            "solution": "该问题要求对磁共振成像（MRI）中两种不同k空间欠采样策略所产生的混叠伪影相干性进行算法比较。此分析的基础是k空间采样掩模与图像域点扩散函数（PSF）之间的傅里叶关系。PSF被定义为采样掩模的逆离散傅里叶变换（IDFT），它描述了物体中的单个点在重建图像中如何扩散。PSF旁瓣的结构表现为混叠伪影或“鬼影”，其结构由采样掩模的几何形状决定。周期性的结构化掩模预计会产生具有稀疏、高幅度旁瓣的PSF（相干混叠），而随机化掩模预计会产生具有大量、低幅度、类似噪声的旁瓣的PSF（不相干混叠）。本问题使用PSF旁瓣幅度的峰均比来量化这种相干性。\n\n该过程对每个测试用例执行，每个用例由网格大小参数 $N$ 和采样率参数 $R$ 定义。每个用例都使用一个唯一的、可复现的随机种子。\n\n**第1步：掩模生成**\n\n对于给定的测试用例 $(N, R)$ 及其对应的随机种子，构建两个 $N \\times N$ 的二元采样掩模。采样沿着相位编码方向（由 $k_y$ 轴表示）进行，这意味着k空间网格的整行要么被完全采样，要么被完全跳过。\n\n1.  **随机移位的笛卡尔掩模 ($M_{\\mathrm{shift}}$):** 该掩模模拟具有随机起始位置的周期性欠采样采集。从集合 $\\{0, 1, \\dots, R-1\\}$ 中均匀选择一个随机整数移位 $s$。当且仅当索引为 $k_y$ (其中 $k_y \\in \\{0, 1, \\dots, N-1\\}$) 的相位编码线满足条件 $(k_y - s) \\bmod R = 0$ 时，该线被选中。对于每个选定的 $k_y$，掩模 $M_{\\mathrm{shift}}$ 中的相应行被设置为1；所有其他条目均为0。\n\n2.  **全随机掩模 ($M_{\\mathrm{rand}}$):** 该掩模被设计为具有与笛卡尔掩模相同的采样密度（即，相同的总采样线数），但线的选择是随机的。首先，计算在 $M_{\\mathrm{shift}}$ 中选择的线数 $M$。然后，从 $\\{0, 1, \\dots, N-1\\}$ 中均匀随机地选择一个新的包含 $M$ 个不同线索引的集合。通过将与这些随机选择的索引相对应的行设置为1来构建掩模 $M_{\\mathrm{rand}}$。\n\n**第2步：点扩散函数与相干性比率计算**\n\n对于每个掩模，计算其对应的PSF和相干性比率。\n\n1.  **点扩散函数 (PSF):** 二维PSF $p(\\mathbf{r})$ 是k空间掩模的逆离散傅里叶变换。为了便于分析其结构，PSF被移位，使其主瓣（对应于k空间的零频分量）位于 $N \\times N$ 图像网格的中心。这在计算上通过应用二维逆快速傅里叶变换（$\\mathrm{IDFT}_2$），然后进行循环移位（`fftshift`）来实现。\n\n2.  **相干性比率 ($C$):** 相干性比率是一个旨在量化混叠伪影相对于其平均强度的“峰值度”的度量。令 $|p(\\mathbf{r})|$ 为移位后PSF的幅度。中心像素 $p_0$ 代表主瓣，在伪影分析中被排除。令 $\\mathcal{R}$ 为所有非中心像素位置的集合。相干性比率定义为：\n    $$\n    C \\;=\\; \\frac{\\max_{\\mathbf{r} \\in \\mathcal{R}} |p(\\mathbf{r})|}{\\operatorname{mean}_{\\mathbf{r} \\in \\mathcal{R}} |p(\\mathbf{r})|}\n    $$\n    在掩模被完全采样的特定情况下（例如，对于 $R=1$），PSF是一个完美的δ函数，意味着对于所有 $\\mathbf{r} \\in \\mathcal{R}$，都有 $|p(\\mathbf{r})| = 0$。在这种情况下，$C$ 的表达式变为不确定的 $0/0$ 形式。问题规定，在这种情况下，$C$ 应定义为 $0$。\n\n**第3步：比较与最终输出**\n\n任务的核心是比较两种采样方案产生的伪影的相干性。对于每个测试用例 $(N, R)$：\n\n1.  计算随机移位的笛卡尔掩模的相干性比率 $C_{\\mathrm{shift}}$。\n2.  计算全随机掩模的相干性比率 $C_{\\mathrm{rand}}$。\n3.  评估布尔表达式 $C_{\\mathrm{rand}}  C_{\\mathrm{shift}}$。这检验了一个假设，即随机采样比结构化的周期性采样导致更少相干（更像噪声）的伪影。\n\n对测试套件中的所有用例重复此过程，使用基础随机种子 $s_0 = 2025$ 并为每个后续测试用例（对于用例索引 $i$）递增它（$s_0+i$）以确保可复现性。最终输出是这些布尔结果的列表。对于边界情况 $(N=64, R=1)$，两种掩模都对应于全采样，得出 $C_{\\mathrm{shift}} = 0$ 和 $C_{\\mathrm{rand}} = 0$。比较 $0  0$ 的结果为 False。对于所有其他 $R > 1$ 的情况，我们预计 $C_{\\mathrm{rand}}  C_{\\mathrm{shift}}$ 为 True，这证实了压缩感知的一个基本原则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_coherence_ratio(mask):\n    \"\"\"\n    Computes the PSF and its coherence ratio for a given k-space mask.\n\n    Args:\n        mask (np.ndarray): A 2D numpy array representing the k-space sampling mask.\n\n    Returns:\n        float: The coherence ratio C.\n    \"\"\"\n    N, _ = mask.shape\n\n    # 1. Compute the PSF as the inverse DFT of the mask, then center it.\n    psf = np.fft.ifft2(mask)\n    psf_shifted = np.fft.fftshift(psf)\n    psf_mag = np.abs(psf_shifted)\n\n    # 2. Extract sidelobes by excluding the central pixel.\n    center_y, center_x = N // 2, N // 2\n    \n    # Create a boolean mask for the region of interest R (all pixels except the center).\n    roi_mask = np.ones((N, N), dtype=bool)\n    roi_mask[center_y, center_x] = False\n    sidelobes = psf_mag[roi_mask]\n\n    # 3. Handle the special case of zero sidelobes (full sampling).\n    # This also handles the potential division by zero.\n    if np.all(sidelobes == 0):\n        return 0.0\n\n    # 4. Compute the coherence ratio.\n    max_sidelobe = np.max(sidelobes)\n    mean_sidelobe = np.mean(sidelobes)\n    \n    C = max_sidelobe / mean_sidelobe\n    return C\n\ndef calculate_comparison(N, R, seed):\n    \"\"\"\n    Generates two masks, computes their coherence ratios, and compares them.\n\n    Args:\n        N (int): The grid size (N x N).\n        R (int): The Cartesian sampling rate parameter.\n        seed (int): The random seed for this test case.\n\n    Returns:\n        bool: The result of C_rand  C_shift.\n    \"\"\"\n    # Initialize a random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # --- Mask 1: Randomly Shifted Cartesian ---\n    mask_shift = np.zeros((N, N), dtype=float)\n    s = rng.integers(R)\n    ky_indices_shift = [ky for ky in range(N) if (ky - s) % R == 0]\n    mask_shift[ky_indices_shift, :] = 1.0\n\n    # --- Mask 2: Fully Random with Matched Density ---\n    M = len(ky_indices_shift)\n    mask_rand = np.zeros((N, N), dtype=float)\n    # Choose M distinct ky indices uniformly at random.\n    ky_indices_rand = rng.choice(N, size=M, replace=False)\n    mask_rand[ky_indices_rand, :] = 1.0\n\n    # --- Compute Coherence Ratios ---\n    C_shift = compute_coherence_ratio(mask_shift)\n    C_rand = compute_coherence_ratio(mask_rand)\n\n    # --- Perform Comparison ---\n    return C_rand  C_shift\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (64, 4),  # Case 1\n        (64, 8),  # Case 2\n        (64, 1),  # Case 3\n        (60, 7),  # Case 4\n    ]\n\n    base_seed = 2025\n    results = []\n\n    for i, (N, R) in enumerate(test_cases):\n        seed = base_seed + i\n        result = calculate_comparison(N, R, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Python's str(bool) outputs 'True' or 'False' which is the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "迭代重建算法通过在某个变换域 (例如小波域) 中增强稀疏性来为欠采样的混叠图像“去噪”，而实现这一目标的核心数学工具是软阈值算子 (soft-thresholding operator)。本练习将要求你从邻近算子 (proximal operator) 的基本定义出发，推导用于复数值磁共振成像数据的复数软阈值算子，并编程实现它 。你将通过推导和实践发现，为何此操作能够在收缩系数幅值的同时保持其相位不变，这正是既能促进稀疏性又不引入相位失真的关键所在。",
            "id": "4870640",
            "problem": "您的任务是，在磁共振成像（MRI）的背景下，利用压缩感知的原理，实现并分析用于小波系数的复值软阈值处理。考虑到由于正交检测和相位编码，MRI 图像及其小波系数是复值的。压缩感知（CS）通过惩罚系数的模之和，在某个变换域（此处为小波域）中促进稀疏性。\n\n基础知识：\n- 一个复数可写作 $z = r e^{i \\phi}$，其中 $r = |z| \\geq 0$ 是其模，$\\phi = \\arg(z) \\in (-\\pi,\\pi]$ 是其相位，$i = \\sqrt{-1}$ 是虚数单位。\n- 向量 $x \\in \\mathbb{C}^n$ 的复 $\\ell_1$ 范数是 $\\|x\\|_1 = \\sum_{k=1}^n |x_k|$。\n- 函数 $g$ 在点 $y$ 处的近端算子定义为 $\\mathrm{prox}_g(y) = \\arg\\min_x \\left( \\tfrac{1}{2}\\|x-y\\|_2^2 + g(x) \\right)$，这是凸优化中一个经过充分检验的概念，常用于压缩感知 MRI。\n\n任务：\n- 从上述基础出发，将逐系数应用的复值软阈值算子推导为复 $\\ell_1$ 范数的近端算子。您的推导过程必须阐明为何该算子在复数域中通过收缩模来促进稀疏性，同时保持相位不变。\n- 实现一个程序，对代表小波系数的给定复数数组应用复值软阈值处理。对于每个测试用例，程序必须计算在阈值处理后仍然非零的那些系数中，原始系数与阈值处理后系数之间的最大绝对相位差（以弧度为单位）。如果所有阈值处理后的系数都为零，则该用例返回 $0$。角度必须以弧度为单位测量。\n\n输入规范（内嵌于程序中）：\n- 您将获得一个测试套件，其中包含复系数数组和非负阈值 $\\tau$。\n- 对每个数组应用阈值为 $\\tau$ 的逐系数复值软阈值处理。\n\n需要实现的测试套件：\n- 用例 1 (正常路径)：系数 $\\left[ 1 + i,\\; -0.5 + 2 i,\\; 0.3 - 0.4 i,\\; 0 + 0 i \\right]$，阈值为 $\\tau = 0.5$。\n- 用例 2 (边界条件，等于阈值)：系数 $\\left[ 0.5 + 0 i,\\; 0 - 0.5 i,\\; 0.3535533905932738 + 0.3535533905932738 i \\right]$，阈值为 $\\tau = 0.5$。\n- 用例 3 (零阈值)：系数 $\\left[ -2 + 3 i,\\; 4 + 0 i,\\; 0 + 5 i,\\; -1 - 1 i \\right]$，阈值为 $\\tau = 0$。\n- 用例 4 (高阈值导致所有系数为零)：系数 $\\left[ 1 + 2 i,\\; -3 + 4 i,\\; 5 - 6 i \\right]$，阈值为 $\\tau = 10$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，输出一个等于如上定义的最大绝对相位差（以弧度为单位）的实数（浮点数）。最终输出必须为 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$ 的形式。\n\n科学真实性要求：\n- 将小波变换视为对复图像的线性酉变换；阈值处理直接作用于复小波系数。\n- 在您的推导中严格证明，保持相位不变同时收缩模这一特性，是源于最小化一个基于近端算子定义的凸目标函数，而非来自启发式捷径。\n\n回答格式：\n- 提供完整的推导和解释。\n- 提供可在内部定义并运行测试套件的可运行代码。\n- 最终的打印输出必须是上文指定的精确格式的单行文本。",
            "solution": "该问题要求推导复值软阈值算子并实现它，以分析其相位保持特性。该算子是许多压缩感知重建算法的基础，包括用于 MRI 的算法，在这些算法中，通过在变换域（例如小波域）中促进稀疏性，来实现欠采样采集。\n\n推导从近端算子的定义开始。对于一个给定的函数 $g$，其在点 $y$ 处的近端算子定义为：\n$$\n\\mathrm{prox}_g(y) = \\arg\\min_x \\left( \\frac{1}{2}\\|x-y\\|_2^2 + g(x) \\right)\n$$\n在压缩感知的背景下，函数 $g(x)$ 通常是用于促进稀疏性的、按比例缩放的 $\\ell_1$ 范数。对于复系数向量 $x \\in \\mathbb{C}^n$，我们使用 $g(x) = \\tau \\|x\\|_1 = \\tau \\sum_{k=1}^n |x_k|$，其中 $\\tau \\geq 0$ 是一个非负阈值参数。需要最小化的目标函数是：\n$$\nJ(x) = \\frac{1}{2}\\|x-y\\|_2^2 + \\tau \\|x\\|_1 = \\frac{1}{2} \\sum_{k=1}^n |x_k - y_k|^2 + \\tau \\sum_{k=1}^n |x_k|\n$$\n由于目标函数是各项之和，且每一项仅涉及单个系数对 $(x_k, y_k)$，因此该最小化问题是可分的。我们可以通过独立地最小化每个分量对总目标的贡献来找到最优向量 $x$。因此，对于每个系数 $k$，我们求解以下关于复变量 $x \\in \\mathbb{C}$ 的最小化问题，给定复测量值 $y \\in \\mathbb{C}$：\n$$\n\\hat{x} = \\arg\\min_{x \\in \\mathbb{C}} \\left( \\frac{1}{2} |x - y|^2 + \\tau |x| \\right)\n$$\n让我们用极坐标表示复变量 $x$ 和 $y$：$x = r_x e^{i\\phi_x}$ 和 $y = r_y e^{i\\phi_y}$，其中 $r_x = |x|$, $\\phi_x = \\arg(x)$, $r_y = |y|$, 且 $\\phi_y = \\arg(y)$。目标函数变为：\n$$\nj(r_x, \\phi_x) = \\frac{1}{2} |r_x e^{i\\phi_x} - r_y e^{i\\phi_y}|^2 + \\tau r_x\n$$\n展开模的平方项：\n$$\n|r_x e^{i\\phi_x} - r_y e^{i\\phi_y}|^2 = (r_x e^{i\\phi_x} - r_y e^{i\\phi_y})(r_x e^{-i\\phi_x} - r_y e^{-i\\phi_y}) = r_x^2 - 2 r_x r_y \\cos(\\phi_x - \\phi_y) + r_y^2\n$$\n因此，目标函数为：\n$$\nj(r_x, \\phi_x) = \\frac{1}{2} (r_x^2 - 2 r_x r_y \\cos(\\phi_x - \\phi_y) + r_y^2) + \\tau r_x\n$$\n我们寻求关于模 $r_x \\geq 0$ 和相位 $\\phi_x \\in (-\\pi, \\pi]$ 最小化该函数。如果 $y = 0$，则 $r_y=0$，目标函数变为 $\\frac{1}{2}r_x^2 + \\tau r_x$，该函数显然在 $r_x = 0$ 处取得最小值，这意味着 $\\hat{x} = 0$。\n\n如果 $y \\neq 0$（因此 $r_y > 0$），我们可以首先对相位 $\\phi_x$ 进行最小化。唯一依赖于 $\\phi_x$ 的项是 $-2 r_x r_y \\cos(\\phi_x - \\phi_y)$。为了最小化目标 $j$，必须最小化这一项，这等价于最大化 $\\cos(\\phi_x - \\phi_y)$。余弦函数的最大值为 $1$，当其自变量为 $0$（或 $2\\pi$ 的任意整数倍）时取得。这意味着最优相位 $\\phi_x$ 必须等于输入系数的相位 $\\phi_y$。这是一个关键结果：复 $\\ell_1$ 范数的近端算子保持输入系数的相位不变，即 $\\arg(\\hat{x}) = \\arg(y)$。\n\n确定了 $\\phi_x = \\phi_y$ 之后，我们可以将 $\\cos(\\phi_x - \\phi_y) = 1$ 代入目标函数，此时目标函数仅依赖于模 $r_x$：\n$$\nj(r_x) = \\frac{1}{2} (r_x^2 - 2 r_x r_y + r_y^2) + \\tau r_x = \\frac{1}{2} (r_x - r_y)^2 + \\tau r_x\n$$\n这就是实值软阈值处理的目标函数，我们必须在 $r_x \\geq 0$ 的条件下将其最小化。该函数是凸函数，但在 $r_x = 0$ 处不可微。我们使用次梯度微积分。次微分 $\\partial j(r_x)$ 由下式给出：\n$$\n\\partial j(r_x) = (r_x - r_y) + \\tau \\cdot \\partial r_x\n$$\n其中 $\\partial r_x$ 是非负变量的绝对值函数的次微分。当 $0 \\in \\partial j(r_x)$ 时，达到最小值。\n\n情况 1：解位于 $r_x > 0$。此时，$\\partial r_x = \\{1\\}$，因此我们令导数为零：$r_x - r_y + \\tau = 0 \\implies r_x = r_y - \\tau$。由于我们假设了 $r_x > 0$，此解仅在 $r_y - \\tau > 0$（即 $r_y > \\tau$）时有效。\n\n情况 2：解位于 $r_x = 0$。对于非负变量，其次微分是 $\\partial r_x = [0, 1]$。在边界点 $r_x=0$ 处的最优性条件是方向导数非负。$j'(0^+) = -r_y + \\tau$。为了使 $r_x=0$ 成为最小值点，我们必须有 $j'(0^+) \\geq 0$，这意味着 $-r_y + \\tau \\geq 0$，即 $r_y \\leq \\tau$。\n\n结合这两种情况，最优模 $r_x=|\\hat{x}|$ 为：\n$$\n|\\hat{x}| = \\begin{cases} r_y - \\tau,  \\text{if } r_y > \\tau \\\\ 0, \\text{if } r_y \\leq \\tau \\end{cases}\n$$\n这可以紧凑地写作 $|\\hat{x}| = \\max(0, r_y - \\tau) = (|y| - \\tau)_+$。\n\n结合模和相位的结果，复值软阈值算子为：\n$$\n\\hat{x} = |\\hat{x}| e^{i\\phi_x} = \\max(0, |y| - \\tau) e^{i\\arg(y)}\n$$\n对于 $y \\neq 0$，我们可以写作 $e^{i\\arg(y)} = y/|y|$。因此，该算子可以表示为：\n$$\n\\hat{x} = \\max(0, |y| - \\tau) \\frac{y}{|y|} = \\left(1 - \\frac{\\tau}{|y|}\\right)_+ y\n$$\n该推导严格地表明，对于任何模 $|y|$ 大于阈值 $\\tau$ 的系数 $y$，得到的系数 $\\hat{x}$ 是非零的，并且其相位与 $y$ 的相位相同。其模被收缩了 $\\tau$。如果 $|y| \\leq \\tau$，则该系数被设为零。正是这种对小系数的选择性收缩促进了稀疏性。\n\n计算任务是实现该算子，并计算在保持非零的系数子集中，原始系数与阈值处理后系数之间的最大绝对相位差。根据推导，理论上该相位差必须恒等于零。数值计算可作为对这一基本性质的验证。对于所有系数都被阈值处理为零的任何测试用例，最大相位差定义为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements complex soft-thresholding and computes the maximum phase difference\n    for a suite of test cases, as per the problem description.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([1 + 1j, -0.5 + 2j, 0.3 - 0.4j, 0 + 0j], dtype=complex), 0.5),\n        (np.array([0.5 + 0j, 0 - 0.5j, 0.3535533905932738 + 0.3535533905932738j], dtype=complex), 0.5),\n        (np.array([-2 + 3j, 4 + 0j, 0 + 5j, -1 - 1j], dtype=complex), 0.0),\n        (np.array([1 + 2j, -3 + 4j, 5 - 6j], dtype=complex), 10.0),\n    ]\n\n    results = []\n\n    for y, tau in test_cases:\n        # Complex soft-thresholding operator: S_tau(y)\n        # S_tau(y_k) = max(0, |y_k| - tau) * (y_k / |y_k|)\n        # This is numerically robustly implemented as:\n        # x = y * scale, where scale = max(0, |y|-tau) / |y|\n        \n        magnitudes = np.abs(y)\n        \n        # Calculate the shrunk magnitudes.\n        shrunk_magnitudes = np.maximum(0, magnitudes - tau)\n        \n        # Calculate the thresholded coefficients.\n        # We use np.divide to handle division by zero safely.\n        # Where magnitude is 0, the numerator shrunk_magnitudes is also 0 (since tau>=0).\n        # We specify out=np.zeros_like(...) so that 0/0 results in 0.\n        scale = np.divide(shrunk_magnitudes, magnitudes, \n                          out=np.zeros_like(magnitudes, dtype=float), \n                          where=(magnitudes != 0))\n        \n        x = y * scale\n\n        # Identify the coefficients that remain non-zero after thresholding.\n        # A small tolerance is used for floating point comparisons.\n        nonzero_mask = np.abs(x) > 1e-15\n\n        if not np.any(nonzero_mask):\n            # If all thresholded coefficients are zero, the max phase difference is 0.\n            max_phase_diff = 0.0\n        else:\n            # Select the original and thresholded coefficients that are non-zero.\n            y_nonzero = y[nonzero_mask]\n            x_nonzero = x[nonzero_mask]\n            \n            # Calculate the phase difference.\n            # np.angle(z2 * np.conj(z1)) gives angle(z2) - angle(z1) in (-pi, pi].\n            # This is numerically more stable than np.angle(z2) - np.angle(z1).\n            phase_diffs = np.angle(x_nonzero * np.conj(y_nonzero))\n            \n            # Find the maximum absolute phase difference.\n            max_phase_diff = np.max(np.abs(phase_diffs))\n            \n        results.append(max_phase_diff)\n\n    # Format the results into the required output string.\n    # The str() conversion ensures standard float representation.\n    # The derived theory predicts all results will be 0.0\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "我们如何将欠采样采集到的数据与促进稀疏性的阈值算子结合起来进行图像重建呢？交替方向乘子法 (Alternating Direction Method of Multipliers, ADMM) 为此提供了一个强大的算法框架。在本练习中，你将首先推导基于ADMM的重建算法的完整迭代更新步骤，然后将这些规则应用于一个具体而微的数值算例 。通过亲手执行一次完整的算法迭代，你将具体地理解图像估计、稀疏系数和对偶变量是如何协同工作，一步步求解出最终的重建图像的。",
            "id": "4870662",
            "problem": "考虑一个压缩感知磁共振成像 (MRI) 重建问题，其中未知图像向量为 $x \\in \\mathbb{R}^{N}$，k空间数据为 $y \\in \\mathbb{R}^{N}$，欠采样掩模是一个对角选择矩阵 $M \\in \\mathbb{R}^{N \\times N}$，傅里叶编码算子是酉离散傅里叶变换 (DFT) $F \\in \\mathbb{R}^{N \\times N}$（对于以下特定情况，假设为实值）。设稀疏变换为 $\\Psi \\in \\mathbb{R}^{N \\times N}$，并假设 $\\Psi$ 是标准正交的。正则化重建旨在最小化以下目标函数\n$$\n\\min_{x \\in \\mathbb{R}^{N}} \\; \\frac{\\beta}{2} \\| M F x - y \\|_{2}^{2} + \\lambda \\| \\Psi x \\|_{1},\n$$\n其中 $\\beta > 0$ 和 $\\lambda > 0$ 是给定的权重。引入分裂变量 $z \\in \\mathbb{R}^{N}$ 以强制执行约束 $z = \\Psi x$，并使用交替方向乘子法 (ADMM) 求解该问题。使用缩放对偶变量 $u \\in \\mathbb{R}^{N}$ 和惩罚参数 $\\rho > 0$。从基本定义出发（从ADMM的增广拉格朗日量定义以及酉变换和标准正交变换的标准性质开始），推导迭代更新 $x^{k+1}$、$z^{k+1}$ 和 $u^{k+1}$ 的闭式表达式。解释为什么 $z$ 更新可简化为逐分量的软阈值操作，以及为什么 $u$ 更新是对偶上升。\n\n然后，针对以下具体、完全指定的实例进行分析：\n- 维度 $N = 2$。\n- 酉2点DFT为\n$$\nF = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 1  -1 \\end{bmatrix}.\n$$\n- 掩模仅选择第一个k空间分量，\n$$\nM = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix}.\n$$\n- 稀疏变换为单位矩阵，$\\Psi = I$。\n- 参数为 $\\beta = 1$，$\\rho = 2$，$\\lambda = 0.5$。\n- 测得的k空间数据为 $y = \\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}$。\n- 在第 $k$ 次迭代时，变量为 $z^{k} = \\begin{bmatrix} 1 \\\\ -0.5 \\end{bmatrix}$ 和 $u^{k} = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix}$。\n\n使用你推导出的更新规则和给定的数值，计算更新后的对偶变量 $u^{k+1}$ 的第二个分量，结果应为一个精确的、闭式的实数表达式。不要进行近似或四舍五入；报告精确值，如果出现根式则保留。最终答案必须是无单位的单个表达式。",
            "solution": "该问题要求推导压缩感知MRI重建问题的交替方向乘子法 (ADMM) 更新步骤，然后针对一个给定实例计算一个特定值。\n\n### 步骤 1：ADMM 更新规则的推导\n\n通过引入分裂变量 $z = \\Psi x$，原始问题被重写为一个约束优化问题：\n$$ \\min_{x, z} \\frac{\\beta}{2} \\| M F x - y \\|_{2}^{2} + \\lambda \\| z \\|_{1} \\quad \\text{s.t.} \\quad \\Psi x - z = 0 $$\n该问题的缩放形式的增广拉格朗日量 $L_{\\rho}(x, z, u)$ 为：\n$$ L_{\\rho}(x, z, u) = \\frac{\\beta}{2} \\| M F x -y \\|_{2}^{2} + \\lambda \\| z \\|_{1} + \\frac{\\rho}{2} \\| \\Psi x - z + u \\|_{2}^{2} - \\frac{\\rho}{2} \\| u \\|_{2}^{2} $$\nADMM 迭代地对这个拉格朗日量相对于 $x$ 和 $z$ 进行最小化，然后更新对偶变量 $u$。\n\n**1. $x$ 更新：**\n通过对 $L_{\\rho}$ 关于 $x$ 进行最小化来找到 $x$ 的更新，同时将 $z$ 和 $u$ 固定在第 $k$ 次迭代的值：\n$$ x^{k+1} = \\arg\\min_{x} L_{\\rho}(x, z^k, u^k) = \\arg\\min_{x} \\left( \\frac{\\beta}{2} \\| M F x - y \\|_{2}^{2} + \\frac{\\rho}{2} \\| \\Psi x - z^k + u^k \\|_{2}^{2} \\right) $$\n这是一个最小二乘问题。通过将关于 $x$ 的梯度设为零来找到最小值。梯度为：\n$$ \\nabla_x L_{\\rho} = \\beta F^T M^T (M F x - y) + \\rho \\Psi^T (\\Psi x - z^k + u^k) = 0 $$\n由于 $M$ 是一个对角选择矩阵，所以 $M^T=M$ 且 $M^2=M$。由于 $\\Psi$ 是标准正交的，所以 $\\Psi^T \\Psi = I$。\n$$ \\beta F^T M F x + \\rho x = \\beta F^T M y + \\rho \\Psi^T(z^k - u^k) $$\n$$ (\\beta F^T M F + \\rho I) x = \\beta F^T M y + \\rho \\Psi^T(z^k - u^k) $$\n矩阵 $(\\beta F^T M F + \\rho I)$ 是正定的，因此是可逆的。$x^{k+1}$ 的闭式解为：\n$$ x^{k+1} = (\\beta F^T M F + \\rho I)^{-1} \\left( \\beta F^T M y + \\rho \\Psi^T(z^k - u^k) \\right) $$\n\n**2. $z$ 更新：**\n通过对 $L_{\\rho}$ 关于 $z$ 进行最小化来找到 $z$ 的更新，使用新计算的 $x^{k+1}$ 和之前的 $u^k$：\n$$ z^{k+1} = \\arg\\min_{z} L_{\\rho}(x^{k+1}, z, u^k) = \\arg\\min_{z} \\left( \\lambda \\| z \\|_{1} + \\frac{\\rho}{2} \\| \\Psi x^{k+1} - z + u^k \\|_{2}^{2} \\right) $$\n令 $v = \\Psi x^{k+1} + u^k$。最小化问题为：\n$$ z^{k+1} = \\arg\\min_{z} \\left( \\lambda \\| z \\|_{1} + \\frac{\\rho}{2} \\| z - v \\|_{2}^{2} \\right) $$\n这个表达式是可分的，意味着我们可以对每个分量 $z_i$ 独立地进行最小化：\n$$ z_i^{k+1} = \\arg\\min_{z_i} \\left( \\lambda |z_i| + \\frac{\\rho}{2} (z_i - v_i)^2 \\right) $$\n这是著名的L1范数的近端算子，其解是软阈值函数，记为 $\\mathcal{S}_{\\tau}(\\cdot)$，其中阈值为 $\\tau = \\lambda/\\rho$。\n该算子逐分量定义为 $z_i^{k+1} = \\mathcal{S}_{\\lambda/\\rho}(v_i) = \\text{sgn}(v_i) \\max(|v_i| - \\lambda/\\rho, 0)$。向量形式为：\n$$ z^{k+1} = \\mathcal{S}_{\\lambda/\\rho}(\\Psi x^{k+1} + u^k) $$\n这就是为什么 $z$ 更新简化为逐分量的软阈值操作。\n\n**3. $u$ 更新：**\n缩放对偶变量 $u$ 的更新是对偶问题上的一个梯度上升步骤。更新规则由下式给出：\n$$ u^{k+1} = u^k + (\\Psi x^{k+1} - z^{k+1}) $$\n项 $r^{k+1} = \\Psi x^{k+1} - z^{k+1}$ 是第 $k+1$ 次迭代的原始残差。该更新将对偶变量沿约束违反的方向移动，这是对偶上升方法的特征。\n\n### 步骤 2：数值计算\n\n我们现在针对给定的实例，计算 $u^{k+1}$ 的第二个分量。\n参数为：$N=2$, $\\beta=1$, $\\rho=2$, $\\lambda=0.5$, $\\Psi=I$。\n$F = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 1  -1 \\end{bmatrix}$, $M = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix}$, $y = \\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}$, $z^{k} = \\begin{bmatrix} 1 \\\\ -0.5 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ -1/2 \\end{bmatrix}$, $u^{k} = \\begin{bmatrix} 0.2 \\\\ -0.1 \\end{bmatrix} = \\begin{bmatrix} 1/5 \\\\ -1/10 \\end{bmatrix}$。\n\n所需值为 $(u^{k+1})_2$，其中 $u^{k+1} = u^k + x^{k+1} - z^{k+1}$ (因为 $\\Psi=I$)。\n这需要计算 $x^{k+1}$ 和 $z^{k+1}$。\n\n**A. 计算 $x^{k+1}$**\n更新为 $x^{k+1} = A^{-1} b$，其中 $A = \\beta F^T M F + \\rho I$，$b = \\beta F^T M y + \\rho (z^k - u^k)$。\n首先，计算矩阵 $A$：\n$F$ 是实数且对称的，所以 $F^T=F$。\n$M F = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix} \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 1  -1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 0  0 \\end{bmatrix}$。\n$F M F = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 1  -1 \\end{bmatrix} \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 0  0 \\end{bmatrix} = \\frac{1}{2}\\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$。\n$A = 1 \\cdot \\frac{1}{2}\\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix} + 2 \\cdot \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} = \\begin{bmatrix} 1/2  1/2 \\\\ 1/2  1/2 \\end{bmatrix} + \\begin{bmatrix} 2  0 \\\\ 0  2 \\end{bmatrix} = \\begin{bmatrix} 5/2  1/2 \\\\ 1/2  5/2 \\end{bmatrix} = \\frac{1}{2}\\begin{bmatrix} 5  1 \\\\ 1  5 \\end{bmatrix}$。\n逆矩阵为 $A^{-1} = \\frac{1}{\\det(A)} \\text{adj}(A) = \\frac{1}{(5/2)^2 - (1/2)^2} \\begin{bmatrix} 5/2  -1/2 \\\\ -1/2  5/2 \\end{bmatrix} = \\frac{1}{24/4} \\begin{bmatrix} 5/2  -1/2 \\\\ -1/2  5/2 \\end{bmatrix} = \\frac{1}{6} \\frac{1}{2} \\begin{bmatrix} 5  -1 \\\\ -1  5 \\end{bmatrix} = \\frac{1}{12}\\begin{bmatrix} 5  -1 \\\\ -1  5 \\end{bmatrix}$。\n\n接下来，计算向量 $b$：\n$M y = \\begin{bmatrix} 1  0 \\\\ 0  0 \\end{bmatrix}\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix}$。\n$F M y = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1  1 \\\\ 1  -1 \\end{bmatrix}\\begin{bmatrix} 2 \\\\ 0 \\end{bmatrix} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 2 \\\\ 2 \\end{bmatrix} = \\begin{bmatrix} \\sqrt{2} \\\\ \\sqrt{2} \\end{bmatrix}$。\n$z^k - u^k = \\begin{bmatrix} 1 \\\\ -1/2 \\end{bmatrix} - \\begin{bmatrix} 1/5 \\\\ -1/10 \\end{bmatrix} = \\begin{bmatrix} 4/5 \\\\ -5/10 + 1/10 \\end{bmatrix} = \\begin{bmatrix} 4/5 \\\\ -4/10 \\end{bmatrix} = \\begin{bmatrix} 4/5 \\\\ -2/5 \\end{bmatrix}$。\n$b = 1 \\cdot \\begin{bmatrix} \\sqrt{2} \\\\ \\sqrt{2} \\end{bmatrix} + 2 \\cdot \\begin{bmatrix} 4/5 \\\\ -2/5 \\end{bmatrix} = \\begin{bmatrix} \\sqrt{2} + 8/5 \\\\ \\sqrt{2} - 4/5 \\end{bmatrix}$。\n\n现在，计算 $x^{k+1} = A^{-1}b$：\n$x^{k+1} = \\frac{1}{12}\\begin{bmatrix} 5  -1 \\\\ -1  5 \\end{bmatrix} \\begin{bmatrix} \\sqrt{2} + 8/5 \\\\ \\sqrt{2} - 4/5 \\end{bmatrix} = \\frac{1}{12} \\begin{bmatrix} 5(\\sqrt{2} + 8/5) - (\\sqrt{2} - 4/5) \\\\ -(\\sqrt{2} + 8/5) + 5(\\sqrt{2} - 4/5) \\end{bmatrix}$\n$x^{k+1} = \\frac{1}{12} \\begin{bmatrix} 5\\sqrt{2} + 8 - \\sqrt{2} + 4/5 \\\\ -\\sqrt{2} - 8/5 + 5\\sqrt{2} - 4 \\end{bmatrix} = \\frac{1}{12} \\begin{bmatrix} 4\\sqrt{2} + 44/5 \\\\ 4\\sqrt{2} - 28/5 \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{2}}{3} + \\frac{11}{15} \\\\ \\frac{\\sqrt{2}}{3} - \\frac{7}{15} \\end{bmatrix}$。\n\n**B. 计算 $z^{k+1}$**\n更新为 $z^{k+1} = \\mathcal{S}_{\\lambda/\\rho}(x^{k+1} + u^k)$。\n阈值为 $\\tau = \\lambda/\\rho = 0.5/2 = 0.25 = 1/4$。\n令 $v = x^{k+1} + u^k$。我们需要它的第二个分量 $v_2$。\n$v_2 = (x^{k+1})_2 + (u^k)_2 = \\left(\\frac{\\sqrt{2}}{3} - \\frac{7}{15}\\right) + \\left(-\\frac{1}{10}\\right)$。\n$v_2 = \\frac{10\\sqrt{2}}{30} - \\frac{14}{30} - \\frac{3}{30} = \\frac{10\\sqrt{2} - 17}{30}$。\n为了应用软阈值算子，我们检查 $v_2$ 的大小。\n$10\\sqrt{2} \\approx 10 \\times 1.414 = 14.14$。所以，$v_2 \\approx (14.14 - 17)/30 = -2.86/30 \\approx -0.095$。\n阈值为 $\\tau = 1/4 = 0.25$。\n由于 $|v_2| \\approx 0.095  0.25$，所以 $v_2$ 位于软阈值算子的“死区”内。\n为了严谨起见，我们比较 $|v_2| = \\frac{17 - 10\\sqrt{2}}{30}$ 和 $\\tau = \\frac{1}{4} = \\frac{7.5}{30}$。\n我们比较 $17 - 10\\sqrt{2}$ 和 $7.5$，这等价于比较 $9.5$ 和 $10\\sqrt{2}$。\n两边平方，我们比较 $9.5^2 = 90.25$ 和 $(10\\sqrt{2})^2 = 200$。\n因为 $90.25  200$，所以我们有 $9.5  10\\sqrt{2}$，这意味着 $|v_2|  \\tau$。\n因此，$(z^{k+1})_2 = \\mathcal{S}_{\\tau}(v_2) = 0$。\n\n**C. 计算 $(u^{k+1})_2$**\n更新规则是 $(u^{k+1})_2 = (u^k)_2 + (x^{k+1})_2 - (z^{k+1})_2$。\n代入计算出的值：\n$(u^{k+1})_2 = -\\frac{1}{10} + \\left(\\frac{\\sqrt{2}}{3} - \\frac{7}{15}\\right) - 0$。\n$(u^{k+1})_2 = -\\frac{3}{30} + \\frac{10\\sqrt{2}}{30} - \\frac{14}{30}$。\n$(u^{k+1})_2 = \\frac{10\\sqrt{2} - 3 - 14}{30} = \\frac{10\\sqrt{2} - 17}{30}$。\n\n最终要求的值是 $u^{k+1}$ 的第二个分量，它是一个精确的、闭式的实数表达式。",
            "answer": "$$ \\boxed{\\frac{10\\sqrt{2} - 17}{30}} $$"
        }
    ]
}