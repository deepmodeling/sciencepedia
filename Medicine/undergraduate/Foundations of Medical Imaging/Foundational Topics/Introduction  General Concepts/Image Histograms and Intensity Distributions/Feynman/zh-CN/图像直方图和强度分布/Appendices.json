{
    "hands_on_practices": [
        {
            "introduction": "在比较不同图像或不同采集条件下的图像时，一个核心挑战是它们的强度值范围和分布可能大不相同。Z-分数归一化是一种基本但极其强大的技术，可将强度分布转换到一个标准化的尺度上。通过这个练习 ()，你将从第一性原理出发，推导出这种变换，并深入理解它如何在不扭曲分布固有形状（如偏斜度）的前提下，实现直方图的中心化和尺度缩放。",
            "id": "4891654",
            "problem": "在一幅放射学图像中，选择一个感兴趣区域（ROI）以通过经验直方图研究其强度分布，该直方图近似了像素强度的潜在概率密度。设ROI内的像素强度被建模为一个实值随机变量 $X$，其均值 $ \\mu $ 有限，标准差 $ \\sigma $ 为正，其中 $ \\sigma > 0 $。考虑通过对 $X$ 进行仿射变换来构建一个标准化强度 $Z$，使得标准化后的直方图被中心化和缩放，从而便于跨被试或跨扫描的比较，同时不扭曲分布的内在形状特征。\n\n从期望 $E[\\cdot]$ 和方差 $\\mathrm{Var}(\\cdot)$ 的定义出发，并仅使用随机变量的仿射变换性质及其如何作用于概率密度和直方图，推导仿射映射 $Z = a X + b$ 产生零均值和单位方差的标准化强度的条件。然后，论证这种重新缩放如何影响直方图的中心、分布范围以及诸如偏度和峰度之类的形状描述符，并判断ROI中像素强度的相对顺序是否被保留。假设直方图是分布的忠实经验表示，并且重新缩放被统一应用于所有ROI像素。最后，选择正确陈述了推导过程和其对直方图影响的选项。\n\n哪个选项是正确的？\n\nA. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。该变换是严格递增的，因此保留了ROI强度的相对顺序。标准化后的直方图被平移至中心为 $0$，并按因子 $1/\\sigma$ 进行水平缩放。诸如偏度和峰度之类的形状描述符在这种仿射标准化下保持不变。\n\nB. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = \\sigma$ 和 $b = -\\mu$。该变换将强度分布范围压缩了因子 $\\sigma$，并且当 $X$ 是高斯分布时，会使标准化后的直方图在某个区间上变为均匀分布。\n\nC. 映射 $Z = (X - \\mu)/\\sigma$ 确保了直方图的组边界和计数与 $X$ 的相同，只是重新标记了x轴。ROI的均值和方差在这种归一化下被保留。\n\nD. 映射 $Z = (X - \\mu)/\\sigma$ 将直方图中心置于 $0$ 并将其方差设为 $1$，但它会通过改变偏度和峰度来改变形状，除非 $X$ 是高斯分布。\n\nE. 当应用于计算机断层扫描（CT）图像中的感兴趣区域（ROI）时，z-score归一化取决于像素的空间排列，并且可能破坏强度顺序，因为该变换相对于 $X$ 是非线性的。",
            "solution": "用户希望我扮演一位STEM教授，解决一个关于直方图标准化的问题。我将验证问题，然后推导解决方案并评估各个选项。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 在放射学图像中选择了一个感兴趣区域（ROI）。\n- ROI内的像素强度被建模为一个实值随机变量 $X$。\n- $X$ 的均值 $\\mu$ 有限。\n- $X$ 的标准差 $\\sigma > 0$ 为正。\n- 通过仿射变换构建一个标准化强度 $Z$：$Z = aX + b$。\n- 目的是创建一个标准化的直方图用于比较，而不扭曲内在的形状特征。\n- 对 $Z$ 的期望属性是零均值 ($E[Z] = 0$) 和单位方差 ($\\mathrm{Var}(Z) = 1$)。\n- 推导必须从期望 $E[\\cdot]$ 和方差 $\\mathrm{Var}(\\cdot)$ 的定义出发，并使用仿射变换的性质。\n- 假设直方图是分布的忠实经验表示。\n- 重新缩放被统一应用于所有ROI像素。\n- 任务是推导 $a$ 和 $b$ 的条件，并分析其对直方图中心、分布范围、形状（偏度、峰度）以及强度排序的影响。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于基础统计学及其在医学图像分析中的应用。标准化随机变量（创建z-score）的概念是一种标准、有效且广泛使用的技术。所有术语（$\\mu, \\sigma, E[\\cdot], \\mathrm{Var}(\\cdot)$, 仿射变换, 偏度, 峰度）在统计学中都有明确的定义。\n- **适定性：** 该问题提供了一个明确的目标：找到仿射映射 $Z=aX+b$ 的参数 $a$ 和 $b$，以产生一个具有指定均值和方差的变量 $Z$。这是一个可解问题，对于 $a$（符号除外）和 $b$ 有唯一解。所需的假设（有限的 $\\mu$，正的 $\\sigma$）已明确说明。\n- **客观性：** 问题以精确、客观的数学和科学语言陈述。它没有歧义或主观性。\n\n**缺陷清单：**\n1.  **科学或事实不健全：**无。前提是健全的。\n2.  **不可形式化或不相关：**无。该问题可直接形式化，并且是图像强度归一化主题的核心。\n3.  **不完整或矛盾的设置：**无。提供了所有必要信息。条件 $\\sigma > 0$ 避免了除以零。\n4.  **不切实际或不可行：**无。这是图像处理中一个常见且实用的程序。\n5.  **不适定或结构不良：**无。存在唯一且稳定的解。\n6.  **伪深刻、琐碎或同义反复：**无。虽然是标准推导，但它正确地测试了对基本统计特性及其含义的理解。\n7.  **超出科学可验证性范围：**无。该推导在数学上是可验证的。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。我现在将进行推导并评估选项。\n\n### 推导与求解\n\n问题要求找到仿射变换 $Z = aX + b$ 的参数 $a$ 和 $b$，使得得到的随机变量 $Z$ 的均值为 $0$、方差为 $1$。我们已知 $X$ 的均值为 $E[X] = \\mu$，方差为 $\\mathrm{Var}(X) = \\sigma^2$，且 $\\sigma > 0$。\n\n**1. 均值条件：**\n我们要求 $E[Z] = 0$。利用期望算子的线性性质：\n$$E[Z] = E[aX + b] = aE[X] + b$$\n代入 $E[X] = \\mu$：\n$$E[Z] = a\\mu + b$$\n将其设为 $0$ 得到我们的第一个方程：\n$$a\\mu + b = 0 \\implies b = -a\\mu$$\n\n**2. 方差条件：**\n我们要求 $\\mathrm{Var}(Z) = 1$。利用方差在仿射变换下的性质：\n$$\\mathrm{Var}(Z) = \\mathrm{Var}(aX + b) = a^2 \\mathrm{Var}(X)$$\n代入 $\\mathrm{Var}(X) = \\sigma^2$：\n$$\\mathrm{Var}(Z) = a^2 \\sigma^2$$\n将其设为 $1$ 得到我们的第二个方程：\n$$a^2 \\sigma^2 = 1$$\n解出 $a$，因为已知 $\\sigma > 0$：\n$$a^2 = \\frac{1}{\\sigma^2} \\implies a = \\pm \\frac{1}{\\sigma}$$\n按照惯例，对于标准化，我们选择正根 $a = 1/\\sigma$ 以保持分布的方向（即，大于均值的值在标准化后仍为正值）。\n\n**3. 确定参数：**\n当 $a = 1/\\sigma$ 时，我们可以从第一个方程中求出 $b$：\n$$b = -a\\mu = -\\left(\\frac{1}{\\sigma}\\right)\\mu = -\\frac{\\mu}{\\sigma}$$\n因此，所需的仿射变换为：\n$$Z = \\left(\\frac{1}{\\sigma}\\right)X - \\frac{\\mu}{\\sigma} = \\frac{X - \\mu}{\\sigma}$$\n这种变换被称为标准分数或z-score。\n\n**4. 效果分析：**\n- **中心和分布范围：** 根据构造， $Z$ 的均值为 $0$，方差为 $1$。标准差为 $\\sqrt{1} = 1$。就直方图而言，这意味着分布被平移，使其质心位于 $0$。水平轴按因子 $a = 1/\\sigma$ 进行缩放。如果 $\\sigma > 1$，这是压缩；如果 $0  \\sigma  1$，这是拉伸。\n\n- **强度的相对顺序：** 变换是一个仿射映射 $f(x) = (1/\\sigma)x - \\mu/\\sigma$。其导数为 $f'(x) = 1/\\sigma$。由于已知 $\\sigma  0$，所以对所有 $x$ 都有 $f'(x)  0$。这意味着变换是严格递增的。因此，如果两个像素强度为 $x_1$ 和 $x_2$ 且 $x_1  x_2$，它们变换后的值 $z_1$ 和 $z_2$ 将满足 $z_1  z_2$。所有像素强度的相对顺序被保留。\n\n- **形状描述符（偏度和峰度）：** 这些描述符是基于标准化中心矩定义的。\n    - 随机变量 $Y$ 的均值为 $\\mu_Y$ 时，其 $n$ 阶中心矩为 $\\mu_n(Y) = E[(Y - \\mu_Y)^n]$。\n    - $Z$ 的 $n$ 阶中心矩为 $\\mu_n(Z) = E[(Z - E[Z])^n] = E[(Z-0)^n] = E[Z^n]$。\n    - 让我们用 $X$ 来表示它：\n    $$\\mu_n(Z) = E\\left[\\left(\\frac{X-\\mu}{\\sigma}\\right)^n\\right] = \\frac{1}{\\sigma^n} E[(X-\\mu)^n] = \\frac{\\mu_n(X)}{\\sigma^n}$$\n    - **偏度**是三阶标准化矩：$\\gamma_1(Y) = \\mu_3(Y) / (\\mathrm{std}(Y))^3$。\n    对于 $Z$，标准差为 $1$，所以其偏度为：\n    $$\\gamma_1(Z) = \\frac{\\mu_3(Z)}{1^3} = \\mu_3(Z) = \\frac{\\mu_3(X)}{\\sigma^3}$$\n    这正是 $X$ 的偏度 $\\gamma_1(X)$ 的定义。因此，$\\gamma_1(Z) = \\gamma_1(X)$。偏度是不变的。\n    - **峰度**是四阶标准化矩：$\\beta_2(Y) = \\mu_4(Y) / (\\mathrm{std}(Y))^4$。\n    对于 $Z$，标准差为 $1$，所以其峰度为：\n    $$\\beta_2(Z) = \\frac{\\mu_4(Z)}{1^4} = \\mu_4(Z) = \\frac{\\mu_4(X)}{\\sigma^4}$$\n    这正是 $X$ 的峰度 $\\beta_2(X)$ 的定义。因此，$\\beta_2(Z) = \\beta_2(X)$。峰度是不变的。\n    由于偏度和峰度不变，分布的内在形状被保留。\n\n### 逐项分析选项\n\n**A. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。该变换是严格递增的，因此保留了ROI强度的相对顺序。标准化后的直方图被平移至中心为 $0$，并按因子 $1/\\sigma$ 进行水平缩放。诸如偏度和峰度之类的形状描述符在这种仿射标准化下保持不变。**\n- $a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$ 的推导是正确的。\n- 关于变换是严格递增的（因为 $a = 1/\\sigma  0$）并保留顺序的陈述是正确的。\n- 关于直方图中心位于 $0$ 并按 $1/\\sigma$ 缩放的描述是正确的。\n- 关于偏度和峰度不变的陈述是正确的。\n- **结论：** **正确**。该陈述的每个部分都是准确的，并且可以从推导中得出。\n\n**B. 在 $Z = a X + b$ 中选择 $a$ 和 $b$ 使得 $E[Z] = 0$ 和 $\\mathrm{Var}(Z) = 1$，得到 $a = \\sigma$ 和 $b = -\\mu$。该变换将强度分布范围压缩了因子 $\\sigma$，并且当 $X$ 是高斯分布时，会使标准化后的直方图在某个区间上变为均匀分布。**\n- $a$ 和 $b$ 的值不正确。如推导所示，$a = 1/\\sigma$ 和 $b = -\\mu/\\sigma$。若 $a=\\sigma$ 和 $b=-\\mu$，则 $E[Z] = \\sigma \\mu - \\mu$ 且 $\\mathrm{Var}(Z) = \\sigma^4$，通常情况下这二者都不是所期望的 $0$ 和 $1$。\n- 关于标准化高斯分布会变成均匀分布的说法是错误的。高斯变量的仿射变换结果是另一个高斯变量。具体来说，对于高斯分布 $X \\sim N(\\mu, \\sigma^2)$，$Z = (X-\\mu)/\\sigma$ 会得到 $Z \\sim N(0, 1)$，即标准正态分布，它不是均匀分布。\n- **结论：** **不正确**。\n\n**C. 映射 $Z = (X - \\mu)/\\sigma$ 确保了直方图的组边界和计数与 $X$ 的相同，只是重新标记了x轴。ROI的均值和方差在这种归一化下被保留。**\n- 关于均值和方差被保留的说法是错误的。该变换的目的和结果就是将均值从 $\\mu$ 变为 $0$，方差从 $\\sigma^2$ 变为 $1$。\n- 关于组边界相同的说法是错误的。位于值 $x$ 的组边界会被映射到新值 $(x-\\mu)/\\sigma$。组的位置和宽度都被缩放和移动了。\n- **结论：** **不正确**。\n\n**D. 映射 $Z = (X - \\mu)/\\sigma$ 将直方图中心置于 $0$ 并将其方差设为 $1$，但它会通过改变偏度和峰度来改变形状，除非 $X$ 是高斯分布。**\n- 第一部分是正确的：该映射将直方图中心置于 $0$ 并将其方差设为 $1$。\n- 第二部分是错误的。如上所述，对于*任何*具有有限矩的分布，偏度和峰度在这种仿射变换下都是不变的，而不仅仅是高斯分布。该变换保留了形状。\n- **结论：** **不正确**。\n\n**E. 当应用于计算机断层扫描（CT）图像中的感兴趣区域（ROI）时，z-score归一化取决于像素的空间排列，并且可能破坏强度顺序，因为该变换相对于 $X$ 是非线性的。**\n- 变换 $Z = aX+b$ 是仿射（如果 $b=0$ 则是线性）变换的定义。它相对于 $X$ 不是非线性的。\n- 因为该变换是一个严格递增的线性函数（因为 $a = 1/\\sigma  0$），它保留强度顺序，而不是破坏它。\n- ROI的全局统计量 $\\mu$ 和 $\\sigma$ 的计算涉及对所有像素求和，而不管其空间排列如何。然后，变换 $z_i = (x_i - \\mu)/\\sigma$ 被独立地应用于每个像素的强度值 $x_i$，与其位置无关。因此，变换本身不依赖于像素的空间排列。\n- **结论：** **不正确**。该陈述包含多个错误的说法。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "理想的教科书模型与现实世界的图像采集之间往往存在差距，后者常常受到探测器饱和等伪影的影响。本练习 () 建立了一个混合分布模型，用于精确量化像素饱和对图像整体统计数据（如均值和方差）造成的偏差。通过推导和计算，你将亲身体会到这种伪影如何影响基于统计的自动化算法（如阈值分割），从而更好地理解理论与实践的联系。",
            "id": "4891605",
            "problem": "一个数字医疗成像系统在闭区间 $\\left[0,1\\right]$ 的归一化标度上记录像素强度，其中最大码值 $1$ 对应于饱和。考虑一次采集，其中比例为 $p$ 的像素由于探测器削波而在最大码值处饱和，而剩余比例为 $1-p$ 的像素，在没有饱和的情况下，会遵循一个在 $\\left[0,1\\right]$ 上的均匀基线强度分布。图像直方图被用于计算视场内所有像素的经验均值和方差。许多简单的全局阈值启发式方法选择一个形式为 $T=\\mu+k\\sigma$ 的阈值 $T$，其中 $\\mu$ 是经验均值，$\\sigma$ 是经验标准差，且 $k0$ 是一个用户选择的常数。\n\n仅使用期望、方差和混合分布的基本定义：\n- 在由概率为 $p$ 的位于 $1$ 处的点质量和概率为 $1-p$ 的在 $\\left[0,1\\right]$ 上的均匀分布组成的混合模型下，推导经验均值 $\\mu(p)$ 和经验方差 $\\sigma^{2}(p)$ 作为饱和比例 $p$ 的函数的闭式表达式。\n- 令 $T_{\\text{true}}(k)$ 表示在 $p=0$ 的理想情况下计算的阈值，令 $T_{\\text{obs}}(p,k)$ 表示在饱和混合模型下计算的阈值。推导阈值偏差 $\\Delta T(p,k)=T_{\\text{obs}}(p,k)-T_{\\text{true}}(k)$ 的闭式表达式。\n\n最后，通过在 $p=0.18$ 和 $k=1.2$ 处计算 $\\Delta T(p,k)$ 的值来量化给定饱和比例下的阈值偏差。将最终数值答案四舍五入到四位有效数字。将答案表示为一个无单位的数。",
            "solution": "在尝试解答之前，根据指定的标准验证问题。\n\n### 步骤1：提取已知条件\n- 像素强度在闭区间 $\\left[0,1\\right]$ 内。\n- 最大码值为 $1$，对应饱和。\n- 比例为 $p$ 的像素在最大码值 $1$ 处饱和。\n- 剩余比例为 $1-p$ 的像素遵循在 $\\left[0,1\\right]$ 上的均匀基线强度分布。\n- 整体模型是一个混合分布：概率为 $p$ 的位于 $1$ 处的点质量和概率为 $1-p$ 的在 $\\left[0,1\\right]$ 上的均匀分布。\n- 阈值 $T$ 定义为 $T=\\mu+k\\sigma$，其中 $\\mu$ 是经验均值，$\\sigma$ 是经验标准差，且 $k0$ 是一个常数。\n- 第一个任务：推导经验均值 $\\mu(p)$ 和经验方差 $\\sigma^{2}(p)$ 作为 $p$ 的函数的闭式表达式。\n- 第二个任务：推导阈值偏差 $\\Delta T(p,k)=T_{\\text{obs}}(p,k)-T_{\\text{true}}(k)$ 的闭式表达式，其中 $T_{\\text{true}}(k)$ 是 $p=0$ 时的阈值，而 $T_{\\text{obs}}(p,k)$ 是饱和混合模型下的阈值。\n- 第三个任务：在 $p=0.18$ 和 $k=1.2$ 处计算 $\\Delta T(p,k)$ 的值，并将答案四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在概率论和统计学（混合分布、期望、方差）方面有很好的基础，并将这些概念应用于数字图像处理中一个常见且现实的问题，特别是医疗成像（探测器饱和及其对图像统计数据的影响）。该模型是一个有效的简化。\n- **适定性**：该问题提供了推导所要求的表达式和计算最终数值所需的所有必要信息和清晰定义。它是自洽的，并且其结构可导向一个唯一的解。\n- **客观性**：该问题使用精确、客观的数学和科学语言陈述，没有歧义或主观论断。\n\n该问题未表现出任何列出的缺陷（例如，科学上不健全、不完整、矛盾、模糊）。均匀分布和点质量之间的混合数学模型定义良好，适合所要求的分析。\n\n### 步骤3：结论和行动\n该问题是 **有效的**。将提供完整的解答。\n\n令 $I$ 为表示像素强度的随机变量。根据问题描述，$I$ 的分布是两种分布的混合：\n1. 在区间 $\\left[0,1\\right]$ 上的均匀分布，我们称此分量为 $I_U \\sim U(0,1)$。此分量以概率 $1-p$ 被选中。\n2. 一个恒定值 $1$（一个点质量），我们称此分量为 $I_S$。此分量以概率 $p$ 被选中。\n\n期望值（均值）$\\mu(p) = \\mathbb{E}[I]$ 和二阶矩 $\\mathbb{E}[I^2]$ 可以通过使用全期望定律，根据强度值是从混合分布的哪个分量中提取的来进行条件化计算。\n$\\mathbb{E}[I^m] = (1-p)\\mathbb{E}[I_U^m] + p\\mathbb{E}[I_S^m]$。\n\n首先，我们求每个分量的矩。\n对于均匀分量 $I_U \\sim U(0,1)$，其概率密度函数为当 $x \\in \\left[0,1\\right]$ 时 $f_U(x)=1$，否则为 $0$。\n一阶矩为 $\\mathbb{E}[I_U] = \\int_0^1 x \\cdot 1 \\, dx = \\left[\\frac{x^2}{2}\\right]_0^1 = \\frac{1}{2}$。\n二阶矩为 $\\mathbb{E}[I_U^2] = \\int_0^1 x^2 \\cdot 1 \\, dx = \\left[\\frac{x^3}{3}\\right]_0^1 = \\frac{1}{3}$。\n\n对于饱和分量 $I_S=1$，其矩为：\n$\\mathbb{E}[I_S] = \\mathbb{E}[1] = 1$。\n$\\mathbb{E}[I_S^2] = \\mathbb{E}[1^2] = 1$。\n\n现在，我们可以计算混合分布的均值 $\\mu(p)$ 和方差 $\\sigma^2(p)$。\n均值为 $\\mu(p) = \\mathbb{E}[I] = (1-p)\\mathbb{E}[I_U] + p\\mathbb{E}[I_S]$。\n$\\mu(p) = (1-p) \\cdot \\frac{1}{2} + p \\cdot 1 = \\frac{1-p}{2} + p = \\frac{1-p+2p}{2} = \\frac{1+p}{2}$。\n\n方差为 $\\sigma^2(p) = \\mathbb{E}[I^2] - (\\mathbb{E}[I])^2 = \\mathbb{E}[I^2] - (\\mu(p))^2$。我们首先需要混合分布的二阶矩 $\\mathbb{E}[I^2]$。\n$\\mathbb{E}[I^2] = (1-p)\\mathbb{E}[I_U^2] + p\\mathbb{E}[I_S^2]$。\n$\\mathbb{E}[I^2] = (1-p)\\cdot\\frac{1}{3} + p \\cdot 1 = \\frac{1-p}{3} + p = \\frac{1-p+3p}{3} = \\frac{1+2p}{3}$。\n\n现在我们可以求出方差 $\\sigma^2(p)$：\n$\\sigma^2(p) = \\frac{1+2p}{3} - \\left(\\frac{1+p}{2}\\right)^2 = \\frac{1+2p}{3} - \\frac{1+2p+p^2}{4}$。\n为了合并这些项，我们使用公分母 $12$：\n$\\sigma^2(p) = \\frac{4(1+2p) - 3(1+2p+p^2)}{12} = \\frac{4+8p - 3-6p-3p^2}{12}$。\n$\\sigma^2(p) = \\frac{1+2p-3p^2}{12}$。\n均值和方差的表达式为：\n$\\mu(p) = \\frac{1+p}{2}$\n$\\sigma^2(p) = \\frac{1+2p-3p^2}{12}$\n\n接下来，我们推导阈值偏差 $\\Delta T(p,k) = T_{\\text{obs}}(p,k) - T_{\\text{true}}(k)$。\n阈值定义为 $T = \\mu + k\\sigma = \\mu + k\\sqrt{\\sigma^2}$。\n\n首先，我们求出 $p=0$ 理想情况下的“真实”阈值 $T_{\\text{true}}(k)$。\n$\\mu(0) = \\frac{1+0}{2} = \\frac{1}{2}$。\n$\\sigma^2(0) = \\frac{1+2(0)-3(0)^2}{12} = \\frac{1}{12}$。\n标准差为 $\\sigma(0) = \\sqrt{\\frac{1}{12}} = \\frac{1}{\\sqrt{12}} = \\frac{1}{2\\sqrt{3}}$。\n所以，$T_{\\text{true}}(k) = \\mu(0) + k\\sigma(0) = \\frac{1}{2} + \\frac{k}{2\\sqrt{3}}$。\n\n接下来，我们求饱和混合模型下的“观测”阈值 $T_{\\text{obs}}(p,k)$。\n$\\mu(p) = \\frac{1+p}{2}$。\n$\\sigma(p) = \\sqrt{\\sigma^2(p)} = \\sqrt{\\frac{1+2p-3p^2}{12}} = \\frac{\\sqrt{1+2p-3p^2}}{2\\sqrt{3}}$。\n平方根内的项可以因式分解：$1+2p-3p^2 = (1-p)(1+3p)$。\n所以，$\\sigma(p) = \\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}$。\n因此，$T_{\\text{obs}}(p,k) = \\mu(p) + k\\sigma(p) = \\frac{1+p}{2} + k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}$。\n\n阈值偏差 $\\Delta T(p,k)$ 是两者的差：\n$\\Delta T(p,k) = T_{\\text{obs}}(p,k) - T_{\\text{true}}(k) = \\left(\\frac{1+p}{2} + k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}}\\right) - \\left(\\frac{1}{2} + \\frac{k}{2\\sqrt{3}}\\right)$。\n$\\Delta T(p,k) = \\left(\\frac{1+p}{2} - \\frac{1}{2}\\right) + \\left(k\\frac{\\sqrt{(1-p)(1+3p)}}{2\\sqrt{3}} - \\frac{k}{2\\sqrt{3}}\\right)$。\n$\\Delta T(p,k) = \\frac{p}{2} + \\frac{k}{2\\sqrt{3}}\\left(\\sqrt{(1-p)(1+3p)} - 1\\right)$。\n\n最后，我们计算当 $p=0.18$ 和 $k=1.2$ 时此表达式的值。\n$\\Delta T(0.18, 1.2) = \\frac{0.18}{2} + \\frac{1.2}{2\\sqrt{3}}\\left(\\sqrt{(1-0.18)(1+3 \\cdot 0.18)} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{(0.82)(1+0.54)} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{0.82 \\times 1.54} - 1\\right)$。\n$\\Delta T(0.18, 1.2) = 0.09 + \\frac{0.6}{\\sqrt{3}}\\left(\\sqrt{1.2628} - 1\\right)$。\n现在我们计算数值：\n$\\sqrt{1.2628} \\approx 1.1237437$。\n$\\frac{0.6}{\\sqrt{3}} \\approx 0.3464102$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.3464102 \\times (1.1237437 - 1)$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.3464102 \\times 0.1237437$。\n$\\Delta T(0.18, 1.2) \\approx 0.09 + 0.0428610$。\n$\\Delta T(0.18, 1.2) \\approx 0.132861$。\n\n四舍五入到四位有效数字，我们得到 $0.1329$。",
            "answer": "$$\\boxed{0.1329}$$"
        },
        {
            "introduction": "直方图均衡化是图像增强领域最著名的技术之一，它能显著提升图像的对比度。这个动手编程练习 () 将引导你发现一个深刻的联系：直方图均衡化的核心逻辑与经典的计数排序算法如出一辙。通过从头开始逐步实现频率统计、累积分布函数计算和强度重映射，你将获得对如何通过算法操作直方图来改善图像质量的坚实理解。",
            "id": "3224674",
            "problem": "设计并实现一个程序，该程序使用计数排序的核心机制对一幅 $8$ 位灰度图像执行直方图均衡化。目标是通过将频繁出现的强度值分布到整个可用范围内来重新映射像素强度，以增强对比度。你的方法必须仅基于以下基本定义和经过充分检验的事实：(i) 针对有界整数键的计数排序，其操作方式是为每个可能的键值计算一个频率数组，然后通过计算前缀和（累积计数）来得出其位置或排名；(ii) 直方图均衡化使用图像直方图的累积分布函数（CDF）来重新映射每个强度值，以拉伸动态范围。不要使用任何其他算法捷径或特定领域的图像处理函数。你的实现必须源于这两个基础。\n\n定义和约束：\n- 图像域包含 $L = 256$ 个可能的强度级别，由集合 $\\{0, 1, 2, \\dots, 255\\}$ 中的整数索引。\n- 令 $T$ 表示图像中的像素总数。\n- 令 $h[v]$ 表示强度 $v$ 的频率，其中 $v \\in \\{0, 1, \\dots, 255\\}$。\n- 令 $H[v]$ 表示前缀和 $H[v] = \\sum_{u=0}^{v} h[u]$，这是以计数单位表示的累积分布函数（CDF）。\n- 令 $H_{\\min}$ 表示在 $\\{H[v] : h[v]  0\\}$ 中的最小正值。\n\n你的程序必须：\n- 通过对像素进行单次遍历来构造 $h[\\cdot]$，这与计数排序的计数阶段完全相同。\n- 通过对 $h[\\cdot]$ 进行单次从左到右的前缀和计算来构造 $H[\\cdot]$，这与计数排序的前缀和阶段完全相同。\n- 通过单调缩放累积计数，将每个观察到的强度 $v$ 重新映射到 $\\{0, 1, \\dots, 255\\}$ 中的一个新值，使得第一个观察到的强度（其CDF为 $H_{\\min}$）映射到 $0$，而最大CDF $T$ 映射到 $255$。使用不大于该值的最大整数操作（向下取整）来离散化缩放后的值。未观察到的强度可以任意赋值，只要映射是非递减的，并且对于观察到的强度，满足所述约束。处理退化情况 $T = H_{\\min}$（所有像素共享单一强度），方法是将每个像素映射到 $0$。\n- 将得到的映射应用到图像上。\n\n你的实现在常数因子内必须是 $T + L$ 的严格线性时间复杂度。\n\n测试套件（所有图像都很小，并表示为整数矩阵；将它们视为二维数组，并在展平时使用行主序）：\n- 测试用例 1（一个 $4 \\times 4$ 的图像）：\n  - $\\begin{bmatrix}\n  52  55  61  59 \\\\\n  79  61  76  61 \\\\\n  85  64  59  55 \\\\\n  52  61  59  79\n  \\end{bmatrix}$\n- 测试用例 2（一个 $3 \\times 3$ 的图像；强度恒定）：\n  - $\\begin{bmatrix}\n  128  128  128 \\\\\n  128  128  128 \\\\\n  128  128  128\n  \\end{bmatrix}$\n- 测试用例 3（一个 $2 \\times 4$ 的图像；均匀递增的小范围）：\n  - $\\begin{bmatrix}\n  0  1  2  3 \\\\\n  4  5  6  7\n  \\end{bmatrix}$\n- 测试用例 4（一个 $2 \\times 3$ 的图像；极端的双峰分布）：\n  - $\\begin{bmatrix}\n  0  0  0 \\\\\n  255  255  255\n  \\end{bmatrix}$\n\n要求的最终输出格式：\n- 你的程序应生成一行输出，其中包含 $4$ 个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个结果本身必须是行主序展平后的均衡化图像，表示为一个整数列表。具体来说，输出必须是 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4}]$ 形式的单行，其中每个 $\\text{case}i$ 是一个包含 $T_i$ 个在整数区间 $\\{0,\\dots,255\\}$ 内的整数列表。\n\n不应从标准输入读取任何输入，也不得使用任何外部文件。你的程序必须是自包含且可复现的。",
            "solution": "问题陈述已经过严格审查，并被认为是有效的。它具有科学依据，定义明确，客观且内部一致。它基于计数排序和图像处理中直方图均衡化的既定原则，提出了一个形式化且可解的算法挑战。因此，我们可以着手提供一个解决方案。\n\n任务是通过重新映射像素强度来对一幅 $8$ 位灰度图像执行直方图均衡化。这个过程通过将强度值更均匀地分布在整个可用动态范围内来增强对比度。该方法必须源于计数排序的核心机制。对于一幅 $8$ 位图像，其强度级别在整数集合 $\\{0, 1, \\dots, 255\\}$ 中。我们将可用级别的总数表示为 $L = 256$。\n\n**第1步：频率分析（直方图构建）**\n\n基础步骤是确定图像中每个强度级别的频率，这与计数排序的第一阶段相呼应。我们构建一个频率数组，或称直方图，记作 $h$。该数组大小为 $L=256$，其中每个索引 $v \\in \\{0, 1, \\dots, 255\\}$ 对应一个强度级别。\n\n假设输入图像表示为具有强度值的像素集合。我们将直方图数组 $h$ 初始化为全零。然后，我们对图像中的所有 $T$ 个像素进行单次遍历。对于每个强度为 $v$ 的像素，我们增加直方图中相应的计数器：\n$$h[v] \\leftarrow h[v] + 1$$\n遍历完所有像素后，$h[v]$ 将保存强度为 $v$ 的像素总数。此操作的时间复杂度为 $O(T)$。\n\n**第2步：累积分布函数（CDF）构建**\n\n第二步是计算累积直方图 $H$，这类似于计数排序的前缀和阶段。该数组代表了像素强度的累积分布函数（CDF），尽管尚未归一化。对于每个强度级别 $v$，$H[v]$ 存储强度小于或等于 $v$ 的像素总数。\n\n数组 $H$ 的大小同样为 $L=256$，通过对直方图 $h$ 进行单次遍历来构建：\n$$H[v] = \\sum_{u=0}^{v} h[u]$$\n这可以通过前缀和高效计算：\n$$H[0] = h[0]$$\n$$H[v] = H[v-1] + h[v] \\quad \\text{for } v = 1, 2, \\dots, L-1$$\n像素总数 $T$ 由累积直方图的最后一个值给出，$T = H[L-1]$。此阶段的时间复杂度为 $O(L)$。\n\n**第3步：推导重映射变换**\n\n直方图均衡化的核心是定义一个映射函数 $f(v)$，它将原始强度 $v$ 转换为新强度 $v'$。问题指定了对累积计数的特定单调缩放。目标是将观察到的累积计数范围映射到完整的输出强度范围 $\\{0, 1, \\dots, 255\\}$。\n\n首先，我们确定与观察到的强度值相对应的最小累积计数。这被定义为 $H_{\\min}$：\n$$H_{\\min} = \\min \\{ H[v] \\mid v \\in \\{0, \\dots, 255\\}, h[v]  0 \\}$$\n对于观察到的像素，$H[v]$ 的值范围从 $H_{\\min}$到 $T$。问题要求将这个源区间 $[H_{\\min}, T]$ 缩放到目标强度区间 $[0, L-1]$。\n\n当图像中所有像素具有相同强度时，会出现一种特殊情况。在这种情况下，只有一个 $h[v]$ 非零，且其值等于 $T$。因此，$H_{\\min}$ 将等于 $T$。问题明确指出，在这种退化情况（$T = H_{\\min}$）下，所有像素都应映射到强度值 $0$。\n\n对于非退化情况（$T  H_{\\min}$），我们应用线性变换。强度级别 $v$ 的重映射函数 $f(v)$ 由下式给出：\n$$f(v) = \\left\\lfloor (L-1) \\cdot \\frac{H[v] - H_{\\min}}{T - H_{\\min}} \\right\\rfloor$$\n此处，$(L-1)$ 为 $255$。项 $\\frac{H[v] - H_{\\min}}{T - H_{\\min}}$ 将累积计数缩放到归一化范围 $[0, 1]$。乘以 $(L-1)$ 将其缩放到 $[0, 255]$。向下取整函数 $\\lfloor \\cdot \\rfloor$ 将结果离散化为不大于该值的最接近整数，如问题所指定。这个重映射函数是为所有可能的强度值 $v \\in \\{0, \\dots, 255\\}$ 计算的，并存储在一个查找表中。构建此表需要 $O(L)$ 的时间。\n\n**第4步：应用映射**\n\n有了从 $f(v)$ 推导出的重映射查找表，最后一步是创建均衡化后的图像。我们再次遍历原始图像的 $T$ 个像素。每个原始强度为 $v$ 的像素都被赋予查找表中的新强度 $f(v)$。此步骤的时间复杂度为 $O(T)$。\n\n**复杂度分析**\n\n算法的总时间复杂度是各步骤复杂度之和：\n1.  直方图构建：$O(T)$\n2.  CDF 构建：$O(L)$\n3.  重映射表构建：$O(L)$\n4.  图像重映射：$O(T)$\n\n总体复杂度为 $O(T) + O(L) + O(L) + O(T) = O(T+L)$。这满足了问题陈述中指定的线性时间复杂度要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef equalize_histogram(image_matrix: np.ndarray) - list[int]:\n    \"\"\"\n    Performs histogram equalization on an 8-bit grayscale image matrix.\n\n    This implementation follows the principles of counting sort as specified:\n    1.  Computes a frequency histogram (h).\n    2.  Computes the cumulative distribution function (H).\n    3.  Derives a remapping function based on scaling the CDF.\n    4.  Applies the remapping to the image pixels.\n\n    Args:\n        image_matrix: A 2D numpy array of integers representing the image.\n\n    Returns:\n        A flattened list of integers representing the equalized image.\n    \"\"\"\n    L = 256  # Number of intensity levels for an 8-bit image\n\n    # Flatten the image into a 1D array of pixel intensities.\n    pixels = image_matrix.flatten()\n    T = pixels.size  # Total number of pixels\n\n    if T == 0:\n        return []\n\n    # Step 1: Construct the frequency array h (Histogram).\n    # This corresponds to counting sort's counting phase.\n    # np.bincount is a highly efficient way to compute a histogram.\n    h = np.bincount(pixels, minlength=L)\n\n    # Step 2: Construct the cumulative frequency array H (CDF).\n    # This corresponds to counting sort's prefix-sum phase.\n    H = np.cumsum(h).astype(np.int64)\n\n    # Step 3: Determine the remapping function.\n    \n    # Find H_min, the smallest cumulative count for an observed intensity.\n    # First, get indices where the histogram is non-zero.\n    observed_intensity_indices = np.where(h  0)[0]\n    \n    # H is monotonically non-decreasing, so the minimum H for an observed\n    # intensity corresponds to the first observed intensity.\n    H_min = H[observed_intensity_indices[0]]\n\n    # Handle the degenerate case where T = H_min.\n    # This occurs if all pixels have the same intensity.\n    if T == H_min:\n        return [0] * T\n\n    # For the general case, derive the remapping lookup table.\n    # The formula scales the range [H_min, T] to [0, L-1].\n    # Using floating-point arithmetic for the division is crucial.\n    scale_factor = (L - 1) / (T - H_min)\n    \n    # Apply the formula f(v) = floor((L-1) * (H[v] - H_min) / (T - H_min))\n    # This is done for all possible intensity values v from 0 to 255.\n    remap_table = np.floor(scale_factor * (H - H_min))\n    \n    # Clip values to ensure they are within the [0, 255] range and cast to an integer type.\n    # While the formula should not produce out-of-bounds values, clipping is a safeguard.\n    remap_table = np.clip(remap_table, 0, L - 1).astype(np.uint8)\n\n    # Step 4: Apply the mapping.\n    # Use the remap_table as a lookup table to transform the original pixel values.\n    # This is a fast, vectorized operation in numpy.\n    equalized_pixels = remap_table[pixels]\n\n    return equalized_pixels.tolist()\n\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the histogram equalization algorithm on each,\n    and prints the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [52, 55, 61, 59],\n            [79, 61, 76, 61],\n            [85, 64, 59, 55],\n            [52, 61, 59, 79]\n        ], dtype=np.uint8),\n        np.array([\n            [128, 128, 128],\n            [128, 128, 128],\n            [128, 128, 128]\n        ], dtype=np.uint8),\n        np.array([\n            [0, 1, 2, 3],\n            [4, 5, 6, 7]\n        ], dtype=np.uint8),\n        np.array([\n            [0, 0, 0],\n            [255, 255, 255]\n        ], dtype=np.uint8)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = equalize_histogram(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each result is a list of integers, which is converted to its string\n    # representation without spaces, and then joined by commas.\n    string_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}