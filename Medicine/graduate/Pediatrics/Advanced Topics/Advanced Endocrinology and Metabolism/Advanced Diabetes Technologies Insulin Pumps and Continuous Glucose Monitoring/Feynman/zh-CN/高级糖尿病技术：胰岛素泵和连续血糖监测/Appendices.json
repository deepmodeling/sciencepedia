{
    "hands_on_practices": [
        {
            "introduction": "安全有效地使用胰岛素泵的核心在于避免“剂量叠加”——即在前一剂胰岛素仍在显著发挥作用时，过早地追加下一剂，从而导致低血糖。为了解决这个问题，现代胰岛素泵会计算“板上胰岛素”（Insulin-on-Board, IOB），即体内仍具活性的胰岛素量。本练习将通过一个符合生理学的药效学模型，指导您从第一性原理出发，量化IOB，并将其应用于调整校正剂量，这是理解高级糖尿病技术安全逻辑的基石。",
            "id": "5099481",
            "problem": "一位患有1型糖尿病的儿科患者使用一台集成了动态血糖监测（CGM）功能的胰岛素泵。设速效胰岛素推注的药效学脉冲响应被建模为一个线性时不变系统，其脉冲响应核为 $w(\\tau)$，其中 $\\tau$ 表示自推注以来经过的时间。假设采用以下广泛使用且生理上合理的 Erlang-3 核：\n$$\nw(\\tau) \\;=\\; \\frac{\\lambda^{3}\\,\\tau^{2}\\,\\exp(-\\lambda\\,\\tau)}{2}, \\quad \\tau \\ge 0,\n$$\n其速率参数为 $\\lambda = 1 \\,\\text{h}^{-1}$。该核是归一化的，使得 $\\int_{0}^{\\infty} w(\\tau)\\,d\\tau = 1$，并且线性叠加原理适用（即，对多次推注的响应是相加的）。\n\n在时间 $t_i$ 给予的剂量为 $D$ 的一次推注，其在时间 $T$ 贡献的体内活性胰岛素（IOB）定义为尚未起效的推注部分的剩余分数乘以 $D$。使用上述核函数，对于经过时间 $\\tau = T - t_i$，剩余分数 $R(\\tau)$ 为\n$$\nR(\\tau) \\;=\\; \\int_{\\tau}^{\\infty} w(s)\\,ds.\n$$\n\n在当前时钟时间 $T$，胰岛素泵的历史记录显示有两次先前的推注：\n- 推注1：在 $T - 2.5 \\,\\text{h}$ 时给予 $D_{1} = 2.0 \\,\\text{U}$。\n- 推注2：在 $T - 1.0 \\,\\text{h}$ 时给予 $D_{2} = 1.0 \\,\\text{U}$。\n\nCGM显示当前血糖为 $G(T) = 210 \\,\\text{mg/dL}$，并呈稳定的上升趋势，速率为 $r = 0.5 \\,\\text{mg/dL/min}$。为了进行预测性校正，使用 $30 \\,\\text{min}$ 的预测期，因此在 $T + 30 \\,\\text{min}$ 时的预测血糖为 $G_{p} = G(T) + r \\times 30 \\,\\text{min}$。目标血糖为 $G^{*} = 110 \\,\\text{mg/dL}$，胰岛素敏感因子（ISF）为每单位胰岛素 $45 \\,\\text{mg/dL}$。\n\n在上述假设下，计算：\n1. 使用 $R(\\tau)$ 和给定的 $w(\\tau)$ 计算在时间 $T$ 的总体内活性胰岛素 $\\text{IOB}(T)$。\n2. 忽略 IOB 的校正推注剂量 $D_{\\text{corr},0} = \\dfrac{G_{p} - G^{*}}{\\text{ISF}}$。\n3. 经 IOB 调整的校正推注剂量 $D_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T)$。\n\n将 $D_{\\text{corr}}$ 的最终数值答案四舍五入至四位有效数字。以 $\\text{U}$ 为单位表示最终剂量。",
            "solution": "该问题是有效的，因为它在科学上基于标准的药代动力学/药效学建模，是适定的（提供了所有必要信息），并且以客观、正式的方式呈现。我们着手求解。\n\n问题要求计算经 IOB 调整的校正胰岛素推注剂量 $D_{\\text{corr}}$。这需要一个三步计算过程：\n1.  计算总体内活性胰岛素 $\\text{IOB}(T)$。\n2.  计算未经调整的校正推注剂量 $D_{\\text{corr},0}$。\n3.  计算最终调整后的推注剂量 $D_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T)$。\n\n首先，我们确定胰岛素作用剩余分数 $R(\\tau)$ 的解析形式。脉冲响应核函数给出如下：\n$$\nw(\\tau) = \\frac{\\lambda^{3}\\,\\tau^{2}\\,\\exp(-\\lambda\\,\\tau)}{2}, \\quad \\tau \\ge 0\n$$\n剩余分数 $R(\\tau)$ 是该核函数从 $\\tau$ 到无穷大的积分：\n$$\nR(\\tau) = \\int_{\\tau}^{\\infty} w(s)\\,ds = \\int_{\\tau}^{\\infty} \\frac{\\lambda^{3}\\,s^{2}\\,\\exp(-\\lambda\\,s)}{2}\\,ds\n$$\n为了计算这个积分，我们使用两次分部积分法来求 $s^{2}\\,\\exp(-\\lambda\\,s)$ 的不定积分。\n让我们求解 $\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds$。\n第一次分部积分：设 $u = s^2$ 且 $dv = \\exp(-\\lambda\\,s)\\,ds$。则 $du = 2s\\,ds$ 且 $v = -\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)$。\n$$\n\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) - \\int \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)\\right)(2s\\,ds) = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) + \\frac{2}{\\lambda}\\int s\\,\\exp(-\\lambda\\,s)\\,ds\n$$\n对剩余的积分进行第二次分部积分：设 $u=s$ 且 $dv = \\exp(-\\lambda\\,s)\\,ds$。则 $du=ds$ 且 $v = -\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)$。\n$$\n\\int s\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\int \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)\\right)\\,ds = -\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\frac{1}{\\lambda^2}\\exp(-\\lambda\\,s)\n$$\n将此结果代回，不定积分为：\n$$\n\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) + \\frac{2}{\\lambda}\\left(-\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\frac{1}{\\lambda^2}\\exp(-\\lambda\\,s)\\right) = -\\exp(-\\lambda\\,s)\\left(\\frac{s^2}{\\lambda} + \\frac{2s}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\n$$\n现在我们可以计算 $R(\\tau)$ 的定积分：\n$$\nR(\\tau) = \\frac{\\lambda^3}{2} \\left[ -\\exp(-\\lambda\\,s)\\left(\\frac{s^2}{\\lambda} + \\frac{2s}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right) \\right]_{\\tau}^{\\infty}\n$$\n当 $s \\to \\infty$ 时，项 $\\exp(-\\lambda\\,s) \\to 0$（因为 $\\lambda > 0$）。因此，表达式在上限处的值为 $0$。\n$$\nR(\\tau) = \\frac{\\lambda^3}{2} \\left( 0 - \\left(-\\exp(-\\lambda\\,\\tau)\\left(\\frac{\\tau^2}{\\lambda} + \\frac{2\\tau}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\\right) \\right) = \\frac{\\lambda^3}{2} \\exp(-\\lambda\\,\\tau) \\left(\\frac{\\tau^2}{\\lambda} + \\frac{2\\tau}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\n$$\n化简此表达式，得到剩余分数的公式：\n$$\nR(\\tau) = \\exp(-\\lambda\\,\\tau) \\left( \\frac{(\\lambda\\tau)^2}{2} + \\lambda\\tau + 1 \\right)\n$$\n\n**第1步：计算总体内活性胰岛素 $\\text{IOB}(T)$**\n\n问题提供了速率参数 $\\lambda = 1 \\,\\text{h}^{-1}$。将其代入 $R(\\tau)$ 的表达式中，可简化为：\n$$\nR(\\tau) = \\exp(-\\tau) \\left( \\frac{\\tau^2}{2} + \\tau + 1 \\right)\n$$\n其中 $\\tau$ 的单位是小时。\n\n患者有两次先前的推注：\n- 推注1：$D_1 = 2.0 \\,\\text{U}$，经过时间 $\\tau_1 = 2.5 \\,\\text{h}$。\n- 推注2：$D_2 = 1.0 \\,\\text{U}$，经过时间 $\\tau_2 = 1.0 \\,\\text{h}$。\n\n每次推注产生的 IOB 为 $D_i \\times R(\\tau_i)$。总 IOB 是每次推注贡献的总和：\n$$\n\\text{IOB}(T) = D_1 R(\\tau_1) + D_2 R(\\tau_2)\n$$\n我们计算 $R(\\tau_1)$ 和 $R(\\tau_2)$：\n$$\nR(\\tau_1) = R(2.5) = \\exp(-2.5) \\left( \\frac{(2.5)^2}{2} + 2.5 + 1 \\right) = \\exp(-2.5) \\left( \\frac{6.25}{2} + 3.5 \\right) = \\exp(-2.5) (3.125 + 3.5) = 6.625 \\exp(-2.5)\n$$\n$$\nR(\\tau_2) = R(1.0) = \\exp(-1.0) \\left( \\frac{(1.0)^2}{2} + 1.0 + 1 \\right) = \\exp(-1.0) \\left( 0.5 + 2.0 \\right) = 2.5 \\exp(-1.0)\n$$\n现在，我们计算总 IOB：\n$$\n\\text{IOB}(T) = (2.0)(6.625 \\exp(-2.5)) + (1.0)(2.5 \\exp(-1.0)) = 13.25 \\exp(-2.5) + 2.5 \\exp(-1.0)\n$$\n其数值为：\n$$\n\\text{IOB}(T) \\approx 13.25 \\times 0.082085 + 2.5 \\times 0.367879 \\approx 1.087626 + 0.919699 \\approx 2.007325 \\,\\text{U}\n$$\n\n**第2步：计算未经调整的校正推注剂量 $D_{\\text{corr},0}$**\n\n首先，我们计算在时间 $T + 30 \\,\\text{min}$ 的预测血糖 $G_p$。\n当前血糖为 $G(T) = 210 \\,\\text{mg/dL}$，变化率为 $r = 0.5 \\,\\text{mg/dL/min}$。\n$$\nG_p = G(T) + r \\times 30 \\,\\text{min} = 210 \\,\\text{mg/dL} + (0.5 \\,\\text{mg/dL/min}) \\times (30 \\,\\text{min}) = 210 + 15 = 225 \\,\\text{mg/dL}\n$$\n使用目标血糖 $G^* = 110 \\,\\text{mg/dL}$ 和胰岛素敏感因子 $\\text{ISF} = 45 \\,\\text{mg/dL/U}$ 来计算未经调整的校正推注剂量。\n$$\nD_{\\text{corr},0} = \\frac{G_p - G^*}{\\text{ISF}} = \\frac{225 - 110}{45} = \\frac{115}{45} \\,\\text{U}\n$$\n其数值为：\n$$\nD_{\\text{corr},0} = \\frac{23}{9} \\approx 2.555556 \\,\\text{U}\n$$\n\n**第3步：计算经 IOB 调整的校正推注剂量 $D_{\\text{corr}}$**\n\n最终经 IOB 调整的校正推注剂量是未经调整的剂量减去总 IOB。\n$$\nD_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T) = \\frac{115}{45} - \\left( 13.25 \\exp(-2.5) + 2.5 \\exp(-1.0) \\right)\n$$\n代入数值：\n$$\nD_{\\text{corr}} \\approx 2.555556 - 2.007325 = 0.548231 \\,\\text{U}\n$$\n问题要求将最终答案四舍五入至四位有效数字。\n$$\nD_{\\text{corr}} \\approx 0.5482 \\,\\text{U}\n$$",
            "answer": "$$\n\\boxed{0.5482}\n$$"
        },
        {
            "introduction": "在掌握了胰岛素作用的基本动态后，下一步是实现治疗的个性化。胰岛素碳水化合物比率（ICR）是决定餐食胰岛素剂量的关键参数，但它因人而异，且可能随时间变化。本练习将引导您扮演数据科学家的角色，使用来自连续血糖监测（CGM）和餐食日志的模拟数据，通过普通最小二乘法（OLS）回归分析，来估计患者特异性的ICR。这种从真实世界数据中提取临床参数的方法，是精准糖尿病管理的核心技能。",
            "id": "5099525",
            "problem": "一个儿科内分泌科正在评估来自持续葡萄糖监测 (CGM) 和胰岛素泵用餐日志的数据，以估算用于餐后血糖控制的数据驱动型胰岛素-碳水化合物比率 (ICR)。持续葡萄糖监测 (CGM) 在餐后固定的时间点提供组织间液葡萄糖测量值，单位为毫克/分升 (mg/dL)。对于每餐，记录了碳水化合物量（克）和餐时胰岛素推注量（国际单位 IU）。目标是利用这些记录来估算一个 ICR，该 ICR 能够反映每单位速效胰岛素中和多少克碳水化合物以防止餐后血糖升高，并量化模型的误差（单位为毫克/分升 mg/dL）。\n\n基本原理。从质量平衡的角度出发：餐后血糖浓度的变化由外源性碳水化合物进入血液和胰岛素介导的清除所驱动。在较短的餐后时间窗口内，将净偏移视为这两个相反过程的可观察结果。假设在研究范围内，餐后偏移与碳水化合物和胰岛素剂量之间的关系可以很好地用一个线性模型来近似，并通过普通最小二乘法 (OLS) 来估算模型参数。\n\n使用的定义。对于第 $m$ 餐，将餐后血糖偏移 $E_m$ 定义为在固定的餐后时间窗口内的最大 CGM 读数减去餐前基线 CGM 值。第 $m$ 餐的基线是紧接在用餐开始前的 CGM 水平。餐后时间窗口包括用餐开始后 $30$、$60$、$90$、$120$、$150$ 和 $180$ 分钟的六个固定时间点。碳水化合物剂量 $c_m$ 以克表示，餐时胰岛素推注剂量 $b_m$ 以国际单位 (IU) 表示。线性模型通过一个仿射关系将 $E_m$ 与 $(c_m,b_m)$ 关联起来。估算出的胰岛素-碳水化合物比率 (ICR) 是指，为使预测偏移为零，每单位胰岛素所需的碳水化合物克数。该值是根据拟合模型的系数从逻辑上推导出来的，而不使用问题中提供的任何快捷公式。模型误差通过观测到的偏移与模型预测的偏移之间的均方根误差 (RMSE) 进行量化，单位为 mg/dL。\n\n数据与计算说明。使用以下包含三个案例的测试套件。在每个案例中，对于每餐 $m$，您会得到一个基线 CGM 值（单位 mg/dL）、一个碳水化合物剂量 $c_m$（单位克）、一个餐时胰岛素推注剂量 $b_m$（单位 IU）和一个偏移振幅参数 $A_m$（单位 mg/dL）。将每餐的 CGM 餐后曲线构建为六个 mg/dL 值：基线值加上 $A_m$ 乘以固定的形状分数向量 $S=[0.1,0.5,1.0,0.8,0.6,0.2]$，分别对应于 $30$、$60$、$90$、$120$、$150$ 和 $180$ 分钟。计算 $E_m$ 为这六个 CGM 餐后值中的最大值与基线值之差。然后，通过带截距的 OLS 拟合将 $E_m$ 与 $c_m$ 和 $b_m$ 关联的线性模型，最后根据拟合模型的系数推导出数据驱动的 ICR（克/单位），使得预测偏移为零。计算观测到的 $E_m$ 与模型预测的偏移之间的 RMSE，单位为 mg/dL。\n\n单位。所有 CGM 值单位为 mg/dL，所有碳水化合物剂量单位为克，所有胰岛素剂量单位为国际单位 (IU)，ICR 必须以克/单位报告。RMSE 必须以 mg/dL 报告。\n\n测试套件。对于每个案例，使用给定的餐次级别参数：\n\n案例 $1$（理想路径，混合剂量）：\n- 形状分数 $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- 餐次（基线 mg/dL，$c_m$ 克，$b_m$ IU，$A_m$ mg/dL）：\n  - $(95,60,5,15)$\n  - $(105,45,3,20)$\n  - $(100,75,6,10)$\n  - $(110,30,2,12)$\n  - $(98,90,7,15)$\n  - $(102,50,0,95)$\n\n案例 $2$（边界覆盖，部分零胰岛素）：\n- 形状分数 $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- 餐次：\n  - $(100,20,0,42)$\n  - $(97,80,6,38)$\n  - $(103,10,1,5)$\n  - $(108,100,10,8)$\n\n案例 $3$（边缘情况，含噪声和异常值）：\n- 形状分数 $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- 餐次：\n  - $(94,60,3,40)$\n  - $(99,90,6,20)$\n  - $(101,30,1,30)$\n  - $(96,120,10,5)$\n  - $(104,45,0,75)$\n\n算法要求。对于每个案例：\n- 构建包含截距以及 $c_m$ 和 $b_m$ 列的设计矩阵，以及由 CGM 曲线计算出的观测值 $E_m$ 组成的响应向量。\n- 通过 Moore–Penrose 伪逆，使用普通最小二乘法 (OLS) 估算模型系数。\n- 从第一性原理推导出 ICR，即沿碳水化合物-胰岛素给药轴的变化能使模型预测的偏移为零的克/单位比值。\n- 计算 RMSE（单位 mg/dL），即残差平方的均值的平方根。\n\n答案格式与舍入。您的程序应生成一行输出，其中包含六个结果，格式为逗号分隔的列表并用方括号括起来，顺序为：$[\\text{ICR}_{1},\\text{RMSE}_{1},\\text{ICR}_{2},\\text{RMSE}_{2},\\text{ICR}_{3},\\text{RMSE}_{3}]$。将每个浮点结果四舍五入到两位小数。ICR 值的单位必须是克/单位，RMSE 值的单位必须是 mg/dL。不应打印其他任何文本。",
            "solution": "目标是使用持续葡萄糖监测 (CGM) 和胰岛素泵用餐日志来估计一个数据驱动的胰岛素-碳水化合物比率 (ICR)。其逻辑从第一性原理的质量平衡角度出发，然后构建一个可实现的算法。\n\n第一性原理基础。我们将餐后血糖动态视为碳水化合物进入和胰岛素介导的葡萄糖清除的结果。在餐后短暂的时间窗口内，假设膳食碳水化合物 $c_m$ 和胰岛素推注 $b_m$ 与观测到的 CGM 偏移 $E_m$ 之间存在局部线性关系。具体来说，为第 $m$ 餐写出一个仿射近似：\n$$\nE_m \\approx \\beta_0 + \\beta_c \\, c_m + \\beta_b \\, b_m + \\varepsilon_m,\n$$\n其中 $\\beta_0$ 捕获基线偏移和其他因素，$\\beta_c$ 捕获碳水化合物摄入对葡萄糖偏移的边际效应，$\\beta_b$ 捕获胰岛素推注对偏移的边际效应，而 $\\varepsilon_m$ 是随机误差。这种线性化是在假设 $c_m$ 和 $b_m$ 在一个典型操作点周围的变化是适度的情况下，对潜在的非线性质量平衡关系在操作范围内进行一阶泰勒展开而得到的标准近似。\n\n胰岛素-碳水化合物比率 (ICR) 的推导。胰岛素-碳水化合物比率 (ICR) 定义为中和一餐的升糖效应所需的每单位速效胰岛素对应的碳水化合物克数。在仿射模型中，考虑微小的变化 $\\Delta c$ 和 $\\Delta b$ 使得偏移保持不变，即 $\\Delta E = 0$。对线性模型求微分可得\n$$\n0 \\approx \\beta_c \\, \\Delta c + \\beta_b \\, \\Delta b.\n$$\n求解中和剂量比率，我们得到\n$$\n\\frac{\\Delta c}{\\Delta b} \\approx - \\frac{\\beta_b}{\\beta_c}.\n$$\n左侧即为胰岛素-碳水化合物比率 (ICR)，单位为克/单位。因此，ICR 的数据驱动估计值可以直接从拟合的系数中获得，而无需调用任何快捷公式：通过普通最小二乘法 (OLS) 估计 $\\beta_c$ 和 $\\beta_b$ 后，计算\n$$\n\\widehat{\\text{ICR}} = - \\frac{\\widehat{\\beta}_b}{\\widehat{\\beta}_c}.\n$$\n\n从 CGM 计算偏移。对于每餐 $m$，我们将偏移 $E_m$ 定义为在固定的餐后时间窗口内的最大 CGM 值减去餐前基线。餐后时间窗口指定为餐后 $30$、$60$、$90$、$120$、$150$ 和 $180$ 分钟。给定一个基线 CGM 值（单位 mg/dL）和一个振幅参数 $A_m$（单位 mg/dL），在这六个时间点构建 CGM 序列为\n$$\n\\text{CGM}_{m}(t_k) = \\text{baseline}_m + A_m \\cdot s_k,\n$$\n其中形状分数向量为 $S = [s_1, s_2, s_3, s_4, s_5, s_6] = [0.1, 0.5, 1.0, 0.8, 0.6, 0.2]$。偏移则为\n$$\nE_m = \\max_{k \\in \\{1,\\dots,6\\}} \\text{CGM}_{m}(t_k) - \\text{baseline}_m.\n$$\n根据 $s_3 = 1.0$ 的构造，最大值出现在 $90$ 分钟处，且等于振幅 $A_m$；然而，算法必须从 CGM 数据中计算它，而不是假定一个值。\n\n普通最小二乘法 (OLS)。将各餐次数据堆叠成设计矩阵 $X$ 和响应向量 $y$：\n$$\nX = \\begin{bmatrix}\n1  c_1  b_1 \\\\\n\\vdots  \\vdots  \\vdots \\\\\n1  c_M  b_M\n\\end{bmatrix}, \\quad\ny = \\begin{bmatrix}\nE_1 \\\\\n\\vdots \\\\\nE_M\n\\end{bmatrix}.\n$$\nOLS 系数向量 $\\widehat{\\beta} = [\\widehat{\\beta}_0,\\widehat{\\beta}_c,\\widehat{\\beta}_b]^\\top$ 使用 Moore–Penrose 伪逆计算：\n$$\n\\widehat{\\beta} = X^{+} y,\n$$\n其中 $X^{+}$ 表示 $X$ 的伪逆。即使 $X^\\top X$ 是病态的，这种方法在数值上也是稳定的。\n\n模型误差。计算模型预测的偏移\n$$\n\\widehat{y} = X \\, \\widehat{\\beta},\n$$\n以及残差 $r = y - \\widehat{y}$。均方根误差 (RMSE) 以 mg/dL 为单位量化误差：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} r_m^2 }.\n$$\n\n各案例的算法步骤。\n1. 对于每餐，使用基线和振幅以及固定的形状分数构建六个 CGM 值，计算 $E_m$ 为最大值减去基线。\n2. 为案例中的所有餐次构建 $X$ 和 $y$。\n3. 通过伪逆计算 $\\widehat{\\beta}$，推导出 $\\widehat{\\text{ICR}} = -\\widehat{\\beta}_b / \\widehat{\\beta}_c$（克/单位）。\n4. 计算 $\\widehat{y}$ 和 RMSE（单位 mg/dL）。\n5. 将 $\\widehat{\\text{ICR}}$ 和 RMSE 四舍五入到两位小数，并准备单行输出。\n\n测试套件覆盖范围的基本原理。案例 1 提供了一组均衡的数据，包含变化的碳水化合物和胰岛素剂量以及一餐零胰岛素；案例 2 包括了最小或零胰岛素以及宽碳水化合物范围的边界情景；案例 3 包括了带噪声的偏移和一个异常值餐次（尽管胰岛素剂量高，但峰值很小），用于测试鲁棒性。这些案例共同检验了模型的可识别性、伪逆的稳定性以及对噪声的敏感性。\n\n最终输出规范。程序必须打印一行包含 $[\\text{ICR}_{1},\\text{RMSE}_{1},\\text{ICR}_{2},\\text{RMSE}_{2},\\text{ICR}_{3},\\text{RMSE}_{3}]$ 的内容，其中每个值四舍五入到两位小数，ICR 值的单位为克/单位，RMSE 值的单位为 mg/dL。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_cgm_series(baseline, amplitude, shape_fracs):\n    \"\"\"\n    Construct the CGM postprandial series for a meal:\n    baseline + amplitude * shape_fracs at fixed times 30-180 min.\n    Returns the array of CGM values in mg/dL.\n    \"\"\"\n    return baseline + amplitude * np.array(shape_fracs, dtype=float)\n\ndef compute_excursions(meals, shape_fracs):\n    \"\"\"\n    Given a list of meals with fields:\n      - 'baseline' (mg/dL)\n      - 'carb' (grams)\n      - 'bolus' (IU)\n      - 'amplitude' (mg/dL)\n    and a shape fractions vector,\n    construct CGM series and compute excursions E_m as max(post) - baseline.\n    Returns:\n      - c_list: list of carbs per meal (grams)\n      - b_list: list of bolus per meal (IU)\n      - e_list: list of excursions per meal (mg/dL)\n    \"\"\"\n    c_list, b_list, e_list = [], [], []\n    for meal in meals:\n        baseline = float(meal['baseline'])\n        amplitude = float(meal['amplitude'])\n        c = float(meal['carb'])\n        b = float(meal['bolus'])\n        cgm_series = construct_cgm_series(baseline, amplitude, shape_fracs)\n        excursion = float(np.max(cgm_series) - baseline)\n        c_list.append(c)\n        b_list.append(b)\n        e_list.append(excursion)\n    return np.array(c_list), np.array(b_list), np.array(e_list)\n\ndef ols_icr_and_rmse(c, b, e):\n    \"\"\"\n    Perform OLS with intercept to fit e ~ beta0 + beta_c * c + beta_b * b.\n    Derive ICR = -beta_b / beta_c (grams per unit).\n    Compute RMSE between observed e and predicted.\n    Returns (icr, rmse).\n    \"\"\"\n    # Design matrix with intercept\n    X = np.column_stack([np.ones_like(c), c, b])\n    # Moore–Penrose pseudoinverse solution\n    beta = np.linalg.pinv(X) @ e\n    beta0, beta_c, beta_b = beta.tolist()\n    # Derive ICR from first principles: grams per unit that neutralizes excursion\n    # Avoid division by zero: if beta_c ~ 0, set ICR to np.nan\n    icr = -beta_b / beta_c if abs(beta_c) > 1e-12 else np.nan\n    # Predictions and RMSE\n    y_hat = X @ beta\n    rmse = float(np.sqrt(np.mean((e - y_hat) ** 2)))\n    return float(icr), rmse\n\ndef solve():\n    # Fixed shape fractions at 30,60,90,120,150,180 minutes\n    shape_fracs = [0.1, 0.5, 1.0, 0.8, 0.6, 0.2]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path, mixed doses\n        [\n            {'baseline': 95,  'carb': 60, 'bolus': 5,  'amplitude': 15},\n            {'baseline': 105, 'carb': 45, 'bolus': 3,  'amplitude': 20},\n            {'baseline': 100, 'carb': 75, 'bolus': 6,  'amplitude': 10},\n            {'baseline': 110, 'carb': 30, 'bolus': 2,  'amplitude': 12},\n            {'baseline': 98,  'carb': 90, 'bolus': 7,  'amplitude': 15},\n            {'baseline': 102, 'carb': 50, 'bolus': 0,  'amplitude': 95},\n        ],\n        # Case 2: boundary coverage, some zero insulin\n        [\n            {'baseline': 100, 'carb': 20,  'bolus': 0,  'amplitude': 42},\n            {'baseline': 97,  'carb': 80,  'bolus': 6,  'amplitude': 38},\n            {'baseline': 103, 'carb': 10,  'bolus': 1,  'amplitude': 5},\n            {'baseline': 108, 'carb': 100, 'bolus': 10, 'amplitude': 8},\n        ],\n        # Case 3: edge with noise and an outlier\n        [\n            {'baseline': 94,  'carb': 60,  'bolus': 3,  'amplitude': 40},\n            {'baseline': 99,  'carb': 90,  'bolus': 6,  'amplitude': 20},\n            {'baseline': 101, 'carb': 30,  'bolus': 1,  'amplitude': 30},\n            {'baseline': 96,  'carb': 120, 'bolus': 10, 'amplitude': 5},\n            {'baseline': 104, 'carb': 45,  'bolus': 0,  'amplitude': 75},\n        ],\n    ]\n\n    results = []\n    for meals in test_cases:\n        c, b, e = compute_excursions(meals, shape_fracs)\n        icr, rmse = ols_icr_and_rmse(c, b, e)\n        # Round to two decimals for output\n        results.append(f\"{icr:.2f}\")\n        results.append(f\"{rmse:.2f}\")\n\n    # Final print statement in the exact required format: single line, comma-separated in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "具备了计算IOB和个性化参数的能力之后，我们可以着手设计更智能的剂量算法。简单的校正公式在血糖接近正常范围或快速下降时可能存在风险。本练习将带您进入高级算法设计的领域，构建一个非线性的、风险自适应的校正剂量计算方案。您将使用如Kovatchev风险函数等成熟工具，根据当前的血糖水平和变化趋势动态调整给药策略，主动降低低血糖风险，这体现了现代人工胰腺系统的核心设计思想。",
            "id": "5099507",
            "problem": "一个儿科胰岛素泵控制器使用连续血糖监测来计算用于高血糖症的校正胰岛素推注。传统的校正推注公式使用一个恒定的校正因子（也称为胰岛素敏感性因子），但这会在当前血糖较低时增加低血糖症的风险。您的任务是设计并实现一个非线性校正因子方案，当血糖浓度低于指定的低阈值时，该方案会衰减校正量以降低低血糖症风险，同时保持单位一致性和科学真实性。所有计算必须源自儿科糖尿病技术中的第一性原理和经过充分测试的定义，并且所有数学实体都必须用 LaTeX 书写。\n\n从以下基本概念和事实开始：\n- 在胰岛素泵治疗中，高血糖症的校正推注是通过将血糖偏差除以校正因子来计算的。设校正因子用 $S$ 表示，单位为 $\\mathrm{mg/dL}$ 每 $\\mathrm{U}$（胰岛素单位），当前血糖为 $G$，单位为 $\\mathrm{mg/dL}$，目标血糖为 $G^{\\ast}$，单位为 $\\mathrm{mg/dL}$。无风险衰减的名义校正推注为 $(G - G^{\\ast})/S$，单位为 $\\mathrm{U}$。\n- 体内活性胰岛素 (IOB)，记为 $I_{\\mathrm{OB}}$，单位为 $\\mathrm{U}$，代表应减少任何建议的额外推注的残留活性胰岛素。一个标量分数 $\\eta \\in [0,1]$ 代表 $I_{\\mathrm{OB}}$ 在当前决策时间的效力，产生一个有效偏移量 $\\eta I_{\\mathrm{OB}}$，单位为 $\\mathrm{U}$。\n- Kovatchev 血糖风险函数是一个经过充分测试的血糖相关风险映射。定义\n$$F(G) = 1.509\\left((\\ln G)^{1.084} - 5.381\\right),$$\n以及原始风险\n$$R(G) = 10\\,[F(G)]^2.$$\n为了分离低血糖风险，使用\n$$R_{\\mathrm{low}}(G) = 10\\,[\\min(F(G),0)]^2,$$\n该函数仅当 $F(G) \\lt 0$ 时非零，对应于较低的血糖值。\n- 连续血糖监测趋势（变化率）$\\dot{G}$（单位 $\\mathrm{mg/dL/min}$）在为负时会增加低血糖风险。一个简单且有充分依据的趋势风险归一化方法是\n$$r_{\\mathrm{slope}}(\\dot{G}) = \\min\\left(1,\\max\\left(0, -\\frac{\\dot{G}}{d_0}\\right)\\right),$$\n其中 $d_0$ 是一个参考幅度，单位为 $\\mathrm{mg/dL/min}$。\n\n按如下方式设计非线性校正因子方案，确保在 $G \\lt 90\\,\\mathrm{mg/dL}$ 时强调衰减：\n1. 使用一个标度 $R_{\\mathrm{scale}}$ 将低血糖风险归一化到单位区间，\n$$r_{\\mathrm{low}}(G) = \\min\\left(1,\\frac{R_{\\mathrm{low}}(G)}{R_{\\mathrm{scale}}}\\right).$$\n2. 使用指数生存形式将低血糖风险和斜率风险组合成一个单一的无量纲权重，\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-\\alpha\\,r_{\\mathrm{low}}(G) - \\beta\\,r_{\\mathrm{slope}}(\\dot{G})\\right),$$\n其中系数 $\\alpha$ 和 $\\beta$ 为非负数。当 $r_{\\mathrm{low}}$ 或 $r_{\\mathrm{slope}}$ 增加时，此函数值增加，并且其界限在 $[0,1]$ 内。\n3. 定义一个有效的非线性校正因子\n$$S_{\\mathrm{eff}}(G,\\dot{G}) = S\\left(1 + \\lambda\\,r(G,\\dot{G})\\right),$$\n其中 $\\lambda \\ge 0$ 控制衰减程度。当 $G \\lt 90\\,\\mathrm{mg/dL}$ 时，$r_{\\mathrm{low}}(G)$ 为正，$S_{\\mathrm{eff}}$ 增加，从而减少推荐的胰岛素剂量。\n4. 计算风险加权的校正推注（单位为胰岛素单位），\n$$B(G,\\dot{G},S,I_{\\mathrm{OB}}) = \\max\\left(0,\\,\\min\\left(B_{\\max},\\,\\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}\\right)\\right),$$\n该公式将负值钳位到 $0\\,\\mathrm{U}$（低于目标值时不进行校正），并将过大的值限制在 $B_{\\max}\\,\\mathrm{U}$ 以确保儿科安全。\n\n您的任务：\n- 将上述设计实现为一个程序，对于每个测试用例，计算 $B(G,\\dot{G},S,I_{\\mathrm{OB}})$（单位为胰岛素单位），四舍五入到两位小数。\n- 除非在测试用例中另有说明，否则使用以下常量：$G^{\\ast} = 110\\,\\mathrm{mg/dL}$，$\\eta = 0.6$， $R_{\\mathrm{scale}} = 20$， $d_0 = 2\\,\\mathrm{mg/dL/min}$， $\\alpha = 1$， $\\beta = 1$， $B_{\\max} = 5.0\\,\\mathrm{U}$。\n- 角度单位不适用。所有输出均为胰岛素单位 $\\mathrm{U}$，并且必须是四舍五入到两位小数的浮点数。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来的结果（例如，\"[result1,result2,...]\"）。\n\n测试套件：\n评估八个案例，参数为 $(G, \\dot{G}, S, I_{\\mathrm{OB}}, \\lambda)$，所有单位均已指定：\n1. $G = 250\\,\\mathrm{mg/dL}$, $\\dot{G} = +2\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.5\\,\\mathrm{U}$, $\\lambda = 2.0$。\n2. $G = 90\\,\\mathrm{mg/dL}$, $\\dot{G} = 0\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$。\n3. $G = 120\\,\\mathrm{mg/dL}$, $\\dot{G} = -2\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.2\\,\\mathrm{U}$, $\\lambda = 2.0$。\n4. $G = 85\\,\\mathrm{mg/dL}$, $\\dot{G} = -1\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$。\n5. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = +3\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$。\n6. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = -3\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 1.0\\,\\mathrm{U}$, $\\lambda = 2.0$。\n7. $G = 400\\,\\mathrm{mg/dL}$, $\\dot{G} = +1\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$。\n8. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = -1\\,\\mathrm{mg/dL/min}$, $S = 60\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.3\\,\\mathrm{U}$, $\\lambda = 3.0$。\n\n您的程序必须计算并打印这八个案例对应的推荐校正推注 $B$ 的浮点数列表，每个值都四舍五入到两位小数，并以单行、方括号括起的逗号分隔列表形式输出。",
            "solution": "所提出的问题是有效的。它在科学上基于糖尿病技术的既定原则，问题陈述清晰，定义和约束完整，并且其表述是客观的。因此，我们将着手进行合理的求解。\n\n任务是设计并实现一种风险感知算法，用于计算校正胰岛素推注。当存在较高的低血糖风险时（表现为当前血糖水平低或血糖趋势快速下降），该算法会衰减胰岛素剂量。计算过程分为四个主要步骤，我们将系统地处理这些步骤。\n\n模型的固定参数如下：\n- 目标血糖, $G^{\\ast} = 110\\,\\mathrm{mg/dL}$\n- 体内活性胰岛素 (IOB) 效力分数, $\\eta = 0.6$\n- 低血糖风险归一化标度, $R_{\\mathrm{scale}} = 20$\n- 血糖趋势参考幅度, $d_0 = 2\\,\\mathrm{mg/dL/min}$\n- 风险组合系数（低血糖）, $\\alpha = 1$\n- 风险组合系数（趋势）, $\\beta = 1$\n- 最大允许推注, $B_{\\max} = 5.0\\,\\mathrm{U}$\n\n最终的校正推注 $B$ 是当前血糖 $G$、血糖趋势 $\\dot{G}$、名义校正因子 $S$、体内活性胰岛素 $I_{\\mathrm{OB}}$ 以及风险权重参数 $\\lambda$ 的函数。\n\n计算推注 $B(G,\\dot{G},S,I_{\\mathrm{OB}})$ 的过程如下：\n\n**步骤 1：量化和归一化来自血糖水平的低血糖风险**\n\n首先，我们使用 Kovatchev 血糖风险函数量化与当前血糖水平 $G$ 相关的风险。该函数将血糖浓度映射到一个风险分数，其中负值表示低血糖风险。\n该函数定义为：\n$$F(G) = 1.509\\left((\\ln G)^{1.084} - 5.381\\right)$$\n为了分离低血糖风险，我们只考虑 $F(G)$ 的负值。原始的低血糖风险 $R_{\\mathrm{low}}(G)$ 由下式给出：\n$$R_{\\mathrm{low}}(G) = 10\\,[\\min(F(G),0)]^2$$\n只有当 $G$ 低到足以使 $F(G)$ 为负时，该值才非零。为了创建一个界限在 $[0,1]$ 内的无量纲风险度量，我们使用一个缩放因子 $R_{\\mathrm{scale}}$ 来归一化 $R_{\\mathrm{low}}(G)$：\n$$r_{\\mathrm{low}}(G) = \\min\\left(1,\\frac{R_{\\mathrm{low}}(G)}{R_{\\mathrm{scale}}}\\right)$$\n对于给定的参数，$R_{\\mathrm{scale}} = 20$。$r_{\\mathrm{low}}(G) = 1$ 的值表示来自血糖水平的最大缩放风险。\n\n**步骤 2：量化和归一化来自血糖趋势的低血糖风险**\n\n负的血糖趋势 $\\dot{G}$ 也会增加低血糖风险。该风险通过将变化率相对于一个参考幅度 $d_0$ 进行归一化来量化。公式为：\n$$r_{\\mathrm{slope}}(\\dot{G}) = \\min\\left(1,\\max\\left(0, -\\frac{\\dot{G}}{d_0}\\right)\\right)$$\n当 $d_0 = 2\\,\\mathrm{mg/dL/min}$ 时，此函数将下降趋势映射到 $0$ 和 $1$ 之间的一个风险分数。$\\dot{G} = -2\\,\\mathrm{mg/dL/min}$ 的趋势会产生 $r_{\\mathrm{slope}} = 1$，代表最大的基于趋势的风险。对于任何稳定或上升的趋势（$\\dot{G} \\ge 0$），$r_{\\mathrm{slope}}(\\dot{G}) = 0$。\n\n**步骤 3：组合风险因子并调整校正因子**\n\n两个无量纲的风险分量 $r_{\\mathrm{low}}(G)$ 和 $r_{\\mathrm{slope}}(\\dot{G})$ 被组合成一个单一的总风险权重 $r(G,\\dot{G})$。指数生存形式确保组合风险大于或等于单个风险，并保持在 $[0,1]$ 的界限内：\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-\\alpha\\,r_{\\mathrm{low}}(G) - \\beta\\,r_{\\mathrm{slope}}(\\dot{G})\\right)$$\n当系数 $\\alpha=1$ 和 $\\beta=1$ 时，这简化为：\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-r_{\\mathrm{low}}(G) - r_{\\mathrm{slope}}(\\dot{G})\\right)$$\n然后，这个组合风险权重用于调整名义校正因子 $S$。有效校正因子 $S_{\\mathrm{eff}}$ 与风险成比例增加，这反过来会减少计算出的胰岛素剂量。\n$$S_{\\mathrm{eff}}(G,\\dot{G}) = S\\left(1 + \\lambda\\,r(G,\\dot{G})\\right)$$\n参数 $\\lambda \\ge 0$ 控制此衰减的强度。对于给定的风险水平，较大的 $\\lambda$ 会导致 $S_{\\mathrm{eff}}$ 更显著的增加。如果总风险 $r(G,\\dot{G})$ 为零，则 $S_{\\mathrm{eff}} = S$。\n\n**步骤 4：计算最终的校正推注**\n\n最后一步是计算风险加权的校正推注 $B$。这是使用标准的推注公式完成的，但使用了有效校正因子 $S_{\\mathrm{eff}}$。计算还考虑了体内活性胰岛素（$I_{\\mathrm{OB}}$）并包含了安全钳位。\n基础计算为：\n$$\\text{Bolus}_{\\text{base}} = \\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}$$\n其中 $G-G^{\\ast}$ 是与目标的偏差，$\\eta I_{\\mathrm{OB}}$ 是要减去的有效 IOB。\n\n为确保安全，最终推注 $B$ 受到约束：它不能为负（如果血糖低于目标值，则不给予胰岛素），并且被限制在最大值 $B_{\\max}$。\n$$B(G,\\dot{G},S,I_{\\mathrm{OB}}) = \\max\\left(0,\\,\\min\\left(B_{\\max},\\,\\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}\\right)\\right)$$\n当 $B_{\\max} = 5.0\\,\\mathrm{U}$ 时，任何超过此值的计算推注都将减少到 $5.0\\,\\mathrm{U}$。任何负结果（如果 $G \\le G^{\\ast}$ 或 IOB 偏移量很大时会发生）都将设置为 $0\\,\\mathrm{U}$。\n\n我们现在将为提供的八个测试用例中的每一个实施这套完整的计算序列。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a risk-weighted corrective insulin bolus for a series of test cases.\n    \"\"\"\n\n    # Define the constants for the calculation as specified in the problem.\n    G_star = 110.0  # Target glucose (mg/dL)\n    eta = 0.6       # IOB potency fraction (dimensionless)\n    R_scale = 20.0  # Hypoglycemia risk normalization scale (dimensionless)\n    d0 = 2.0        # Glucose trend reference magnitude (mg/dL/min)\n    alpha = 1.0     # Risk combination coefficient for low glucose (dimensionless)\n    beta = 1.0      # Risk combination coefficient for trend (dimensionless)\n    B_max = 5.0     # Maximum allowable bolus (U)\n\n    def calculate_bolus(G, G_dot, S, I_OB, lam):\n        \"\"\"\n        Calculates the final corrective bolus B for a single set of inputs.\n\n        Args:\n            G (float): Current glucose (mg/dL)\n            G_dot (float): Glucose trend (mg/dL/min)\n            S (float): Correction factor (mg/dL/U)\n            I_OB (float): Insulin on Board (U)\n            lam (float): Attenuation control parameter (lambda)\n\n        Returns:\n            float: The calculated corrective bolus, rounded to two decimal places.\n        \"\"\"\n        # Step 1: Quantify and Normalize Hypoglycemia Risk from Glucose Level\n        if G <= 0:  # Logarithm is undefined for G = 0, risk is maximal\n            F_G = -np.inf\n        else:\n            F_G = 1.509 * (np.log(G)**1.084 - 5.381)\n        \n        R_low_G = 10.0 * (min(F_G, 0.0))**2\n        r_low_G = min(1.0, R_low_G / R_scale)\n\n        # Step 2: Quantify and Normalize Hypoglycemia Risk from Glucose Trend\n        r_slope_G_dot = min(1.0, max(0.0, -G_dot / d0))\n\n        # Step 3: Combine Risk Factors and Modulate the Correction Factor\n        r_combined = 1.0 - np.exp(-alpha * r_low_G - beta * r_slope_G_dot)\n        S_eff = S * (1.0 + lam * r_combined)\n\n        # Step 4: Compute the Final Corrective Bolus\n        # The bolus is only non-zero if G > G_star\n        if G > G_star:\n            bolus_base = (G - G_star) / S_eff - eta * I_OB\n        else:\n            bolus_base = -1.0  # Ensure result is = 0 to be clamped by max(0, ...)\n\n        B = max(0.0, min(B_max, bolus_base))\n        \n        return round(B, 2)\n\n    # Define the test cases from the problem statement.\n    # Parameters: (G, G_dot, S, I_OB, lambda)\n    test_cases = [\n        (250.0, 2.0, 50.0, 0.5, 2.0),\n        (90.0, 0.0, 50.0, 0.0, 2.0),\n        (120.0, -2.0, 50.0, 0.2, 2.0),\n        (85.0, -1.0, 50.0, 0.0, 2.0),\n        (180.0, 3.0, 50.0, 0.0, 2.0),\n        (180.0, -3.0, 50.0, 1.0, 2.0),\n        (400.0, 1.0, 50.0, 0.0, 2.0),\n        (180.0, -1.0, 60.0, 0.3, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        G, G_dot, S, I_OB, lam = case\n        result = calculate_bolus(G, G_dot, S, I_OB, lam)\n        results.append(f\"{result:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}