{
    "hands_on_practices": [
        {
            "introduction": "定量聚合酶链式反应（qPCR）是快速检测和量化病原体的基本工具。本实践练习模拟了一个常见的临床实验室场景，您需要将原始的qPCR信号——定量循环数（$C_q$）——转化为一个有意义的细菌载量指标。掌握这一过程对于诊断活动性感染和评估疾病负担至关重要。",
            "id": "4645947",
            "problem": "一个临床微生物学实验室正在使用定量聚合酶链式反应 (qPCR) 对一名患者尿液中的致病性 Leptospira interrogans 进行定量分析。该检测方法靶向一个假定为每个细菌单拷贝的保守致病基因。定量循环 (Cq) 值通过标准曲线进行校准，该标准曲线在恒定扩增效率下，根据经验将初始模板拷贝数与 Cq 值关联为线性函数。校准得出关系式 $C_q = -3.3\\log_{10}(N) + 40$，其中 $N$ 表示扩增开始时反应体积中存在的初始模板拷贝数，$C_q$ 表示定量循环。\n\n从患者样本中，从 $200~\\mu\\text{L}$ 尿液中提取脱氧核糖核酸 (DNA)，最终洗脱体积为 $50~\\mu\\text{L}$。qPCR 反应体积为 $20~\\mu\\text{L}$，其中 $5~\\mu\\text{L}$ 是 DNA 模板。患者样本的 $C_q$ 值为 $30$。使用提供的校准关系和所述体积，计算 qPCR 反应中的初始模板拷贝数 $N$，然后估算原始尿液中的细菌载量，单位为拷贝数/$\\text{mL}$。将最终的细菌载量四舍五入至三位有效数字，并以拷贝数/$\\text{mL}$为单位表示最终结果。",
            "solution": "该问题是有效的，因为它科学地基于定量聚合酶链式反应 (qPCR) 的原理，问题陈述清晰，提供了足够的信息以获得唯一解，并且以客观、明确的语言表达。\n\n求解过程分两个阶段。首先，我们使用提供的校准方程确定 qPCR 反应体积中存在的初始模板拷贝数 $N$。其次，我们使用这个数值以及 DNA 提取和反应设置中指定的体积来计算原始尿液样本中的细菌浓度。\n\n**第一部分：计算 qPCR 反应中的模板拷贝数**\n\n定量循环 $C_q$ 与初始模板拷贝数 $N$ 之间的关系由以下线性方程给出：\n$$C_q = -3.3\\log_{10}(N) + 40$$\n患者样本的 $C_q$ 值为 $30$。我们将此值代入方程：\n$$30 = -3.3\\log_{10}(N) + 40$$\n我们的目标是求解 $N$。我们首先分离对数项：\n$$30 - 40 = -3.3\\log_{10}(N)$$\n$$-10 = -3.3\\log_{10}(N)$$\n接下来，我们求解 $\\log_{10}(N)$:\n$$\\log_{10}(N) = \\frac{-10}{-3.3} = \\frac{10}{3.3} = \\frac{100}{33}$$\n为了求出 $N$，我们对等式两边取以 $10$ 为底的反函数（反对数）：\n$$N = 10^{\\left(\\frac{100}{33}\\right)}$$\n这个值 $N$ 代表添加到 qPCR 反应中的 DNA 模板体积（指定为 $V_{template} = 5~\\mu\\text{L}$）中所含的 DNA 模板拷贝数。\n\n**第二部分：计算原始尿液样本中的细菌载量**\n\n上面计算出的拷贝数 $N$ 包含在添加到 qPCR 反应中的 $V_{template} = 5~\\mu\\text{L}$ DNA 洗脱液中。首先，我们确定整个 DNA 洗脱液中的 DNA 拷贝浓度。\n设 $C_{eluate}$ 为 DNA 洗脱液中每微升的拷贝浓度。\n$$C_{eluate} = \\frac{N}{V_{template}} = \\frac{10^{\\left(\\frac{100}{33}\\right)}}{5~\\mu\\text{L}}$$\nDNA 洗脱液的总体积为 $V_{elution} = 50~\\mu\\text{L}$。整个洗脱液中的总拷贝数 $N_{eluate}$ 是其浓度和总体积的乘积：\n$$N_{eluate} = C_{eluate} \\times V_{elution} = \\left(\\frac{10^{\\left(\\frac{100}{33}\\right)}}{5~\\mu\\text{L}}\\right) \\times 50~\\mu\\text{L}$$\n$$N_{eluate} = 10 \\times 10^{\\left(\\frac{100}{33}\\right)} = 10^1 \\times 10^{\\left(\\frac{100}{33}\\right)} = 10^{\\left(1 + \\frac{100}{33}\\right)} = 10^{\\left(\\frac{33+100}{33}\\right)} = 10^{\\left(\\frac{133}{33}\\right)}$$\n这个总拷贝数 $N_{eluate}$ 是从初始体积为 $V_{urine} = 200~\\mu\\text{L}$ 的尿液中提取的。假设提取效率为 100%，这就是 $200~\\mu\\text{L}$ 尿液中存在的细菌基因拷贝数。\n\n问题要求以拷贝数/毫升 ($\\text{mL}$) 为单位计算细菌载量。设 $L_{urine}$ 为此浓度。首先，我们计算以拷贝数/微升为单位的浓度：\n$$L_{urine, \\mu L} = \\frac{N_{eluate}}{V_{urine}} = \\frac{10^{\\left(\\frac{133}{33}\\right)}}{200}~\\frac{\\text{copies}}{\\mu\\text{L}}$$\n为了将此浓度转换为拷贝数/$\\text{mL}$，我们使用换算因子 $1~\\text{mL} = 1000~\\mu\\text{L}$：\n$$L_{urine} = L_{urine, \\mu L} \\times \\frac{1000~\\mu\\text{L}}{1~\\text{mL}} = \\frac{10^{\\left(\\frac{133}{33}\\right)}}{200} \\times 1000~\\frac{\\text{copies}}{\\text{mL}}$$\n$$L_{urine} = 5 \\times 10^{\\left(\\frac{133}{33}\\right)}~\\frac{\\text{copies}}{\\text{mL}}$$\n现在，我们计算数值。指数约为 $\\frac{133}{33} \\approx 4.030303...$\n$$L_{urine} \\approx 5 \\times 10^{4.030303...}$$\n$$L_{urine} \\approx 5 \\times 10724.11$$\n$$L_{urine} \\approx 53620.55~\\frac{\\text{copies}}{\\text{mL}}$$\n问题要求将最终答案四舍五入至三位有效数字。前三位有效数字是 $5$、$3$ 和 $6$。第四位数字是 $2$，小于 $5$，因此我们向下取整。\n$$L_{urine} \\approx 53600~\\frac{\\text{copies}}{\\text{mL}}$$\n用标准科学记数法表示，即为 $5.36 \\times 10^4$ 拷贝数/毫升。由于问题假设每个细菌含一个单拷贝基因，因此该值代表细菌载量。",
            "answer": "$$\n\\boxed{5.36 \\times 10^{4}}\n$$"
        },
        {
            "introduction": "理解抗生素浓度与其杀菌效果之间的关系是药理学和有效治疗方案设计的核心。本练习深入探讨药效动力学（PD）建模，指导您从基本原理推导出S型Emax模型（Hill方程）。通过应用此模型，您可以预测多西环素等药物的疗效，为制定给药策略提供定量依据。",
            "id": "4660375",
            "problem": "Leptospira interrogans对四环素类抗菌药物doxycycline敏感，其主要分子作用是可逆地结合到细菌的$30\\,$\\text{S}核糖体亚基上以抑制蛋白质合成。在一个药代动力学/药效动力学（PK/PD）框架中，假设细菌杀灭效果由靶点占据驱动并且是可饱和的，并有以下假设：（i）在抗生素浓度为$C$时，靶点结合遵循质量作用定律，（ii）可观察到的效果与被占据靶点的比例呈单调关系，（iii）占据和效果之间联系的协同性由一个无量纲的斜率参数$\\gamma \\geq 1$来表征，以及（iv）产生半数最大效应的浓度等于半数最大效应浓度（EC50）。将最大效应归一化为1，使得分数杀灭率$E(C)$的值在闭区间$[0,1]$内。\n\n仅从这些假设出发，推导出一个关于$C$、$\\gamma$和半数最大效应浓度（EC50）的饱和效应模型$E(C)$的闭式解。然后，使用推导出的模型，计算当浓度$C=4\\,\\mathrm{\\mu g/mL}$，$EC_{50}=1\\,\\mathrm{\\mu g/mL}$且$\\gamma=2$时，doxycycline的预期分数杀灭率。将您的数值答案四舍五入到四位有效数字，并以无单位小数的形式报告。",
            "solution": "该问题陈述经评估是有效的。其科学基础在于药理学和生物物理化学的原理，描述了一个标准剂量-反应模型（希尔方程）的推导和应用。该问题是适定的、客观的、自洽的，并且所有提供的数据和假设都是一致且足以得出一个唯一的、有意义的解。\n\n任务首先是推导出一个饱和效应模型$E(C)$的闭式解，然后用它来计算一个具体的值。\n\n**第1部分：模型$E(C)$的推导**\n\n该模型将分数杀灭效应$E$描述为抗菌药物浓度$C$的函数。最大效应被归一化为$1$，因此$E$的范围是$0$到$1$。\n\n推导从给定的假设出发。包含协同性的S型反应曲线的标准模型是希尔方程。假设（iii）直接指向这个模型，该模型建立了反应比率与浓度之间的幂律关系。反应比率是已达到的效应与剩余可能效应的比值。当$E_{max}=1$时，这个比率是$\\frac{E}{1-E}$。该关系由下式给出：\n$$\n\\frac{E}{1-E} = \\left(\\frac{C}{K}\\right)^{\\gamma}\n$$\n此处，$\\gamma$是量化协同性的无量纲斜率参数（或希尔系数），$K$是具有浓度单位的常数。\n\n为了找到$E(C)$的闭式表达式，我们求解该方程以得到$E$：\n$$\nE = (1-E) \\cdot \\left(\\frac{C}{K}\\right)^{\\gamma}\n$$\n$$\nE = \\frac{C^{\\gamma}}{K^{\\gamma}} - E \\cdot \\frac{C^{\\gamma}}{K^{\\gamma}}\n$$\n$$\nE \\left(1 + \\frac{C^{\\gamma}}{K^{\\gamma}}\\right) = \\frac{C^{\\gamma}}{K^{\\gamma}}\n$$\n$$\nE \\left(\\frac{K^{\\gamma} + C^{\\gamma}}{K^{\\gamma}}\\right) = \\frac{C^{\\gamma}}{K^{\\gamma}}\n$$\n$$\nE(C) = \\frac{C^{\\gamma}}{K^{\\gamma} + C^{\\gamma}}\n$$\n这个方程代表了饱和效应模型，它与假设（i）、（ii）和（iii）一致。当$C \\to \\infty$时，$E \\to 1$；当$C \\to 0$时，$E \\to 0$。\n\n接下来，我们使用假设（iv）来确定常数$K$。该假设指出，产生半数最大效应的浓度是$\\text{EC}_{50}$。由于最大效应为$1$，半数最大效应为$E = 0.5$。这发生在$C = \\text{EC}_{50}$时。我们将这些值代入我们推导出的模型中：\n$$\n0.5 = \\frac{(\\text{EC}_{50})^{\\gamma}}{K^{\\gamma} + (\\text{EC}_{50})^{\\gamma}}\n$$\n两边同乘以分母得到：\n$$\n0.5 \\left(K^{\\gamma} + (\\text{EC}_{50})^{\\gamma}\\right) = (\\text{EC}_{50})^{\\gamma}\n$$\n$$\n0.5 K^{\\gamma} + 0.5 (\\text{EC}_{50})^{\\gamma} = (\\text{EC}_{50})^{\\gamma}\n$$\n$$\n0.5 K^{\\gamma} = 0.5 (\\text{EC}_{50})^{\\gamma}\n$$\n$$\nK^{\\gamma} = (\\text{EC}_{50})^{\\gamma}\n$$\n由于$K$和$\\text{EC}_{50}$都是实数、正值的浓度，我们可以得出结论$K = \\text{EC}_{50}$。\n\n将$K = \\text{EC}_{50}$代回$E(C)$的模型中，我们得到最终的闭式表达式：\n$$\nE(C) = \\frac{C^{\\gamma}}{(\\text{EC}_{50})^{\\gamma} + C^{\\gamma}}\n$$\n这就是所要求的饱和效应模型，通常称为S型Emax模型或希尔方程。\n\n**第2部分：分数杀灭率的计算**\n\n任务的第二部分是使用推导出的模型和以下给定的参数值来计算分数杀灭率$E$：\n- 浓度：$C=4\\,\\mathrm{\\mu g/mL}$\n- 半数最大效应浓度：$\\text{EC}_{50}=1\\,\\mathrm{\\mu g/mL}$\n- 斜率参数：$\\gamma=2$\n\n我们将这些值代入推导出的公式中。$C$和$\\text{EC}_{50}$的单位相同，因此它们会相消，得到一个无量纲的$E$值。\n$$\nE = \\frac{(4)^{2}}{(1)^{2} + (4)^{2}}\n$$\n$$\nE = \\frac{16}{1 + 16}\n$$\n$$\nE = \\frac{16}{17}\n$$\n为了获得最终的数值答案，我们将这个分数转换为小数，并按要求四舍五入到四位有效数字。\n$$\nE = 0.9411764705...\n$$\n第五位有效数字是$7$，它大于或等于$5$，所以我们将第四位数字向上取整。\n$$\nE \\approx 0.9412\n$$\n因此，在指定浓度下doxycycline的预期分数杀灭率约等于$0.9412$。",
            "answer": "$$\n\\boxed{0.9412}\n$$"
        },
        {
            "introduction": "分子流行病学利用遗传数据来揭示传染病的传播动态。这项生物信息学实践将让您扮演一名暴发调查员的角色，使用多位点序列分型（MLST）数据来分析钩端螺旋体暴发。您将编写代码来分配序列类型，计算菌株之间的遗传距离，并推断传播簇，这些都是现代公共卫生监测的核心技能。",
            "id": "4645693",
            "problem": "给你一份在一次疑似局部暴发中分离出的 Leptospira interrogans 菌株在 $7$ 个管家基因位点上的等位基因谱。使用多位点序列分型 (MLST)，每个分离株的等位基因谱是一个包含 $7$ 个非负整数的序列，每个整数对应一个位点。一个序列类型 (ST) 由一个精确的 $7$ 位点等位基因谱定义。你的任务是编写一个完整、可运行的程序，该程序需对每个提供的测试用例，基于以下基本定义执行相应的计算。\n\n基本定义：\n- 多位点序列分型 (MLST) 将每个分离株表示为一个等位基因谱向量 $\\mathbf{a} \\in \\mathbb{N}^L$（其中 $L=7$），$\\mathbb{N}$ 表示非负整数集，每个坐标 $a_i$ 是位点 $i$ 的等位基因标识符。\n- 序列类型 (ST) 是分配给一个精确等位基因谱的唯一标识符；一个 ST 数据库是从已知的 ST 标识符（整数）到 $\\mathbb{N}^7$ 中的 $7$ 位点等位基因谱的有限映射。\n- 两个具有谱 $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{N}^7$ 的分离株之间的等位基因距离是跨位点的错配数，定义为\n$$\nd(\\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{7} \\mathbf{1}\\{a_i \\neq b_i\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 对于一个固定的错配阈值 $t \\in \\mathbb{N}$，定义一个无向图 $G=(V,E)$，其顶点 $V$ 对分离株进行索引，当且仅当 $d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)}) \\le t$ 时，边连接分离株 $u,v$。$G$ 的连通分量被用作传播链的简单、基于逻辑的代理指标，其假设是（通过等位基因错配）紧密相关的谱表明了最近的共同传播历史。\n\n每个测试用例的程序要求：\n1. ST 分配：给定一个将 ST 标识符映射到等位基因谱的 ST 数据库 $\\mathcal{D}$，通过将每个分离株的谱与 $\\mathcal{D}$ 中的谱进行精确匹配来为其分配 ST。如果不存在精确匹配，则分配值 $-1$。\n2. 成对等位基因距离矩阵：计算完整的 $n \\times n$ 矩阵 $D$，其中 $n$ 是分离株的数量，且对于所有对 $(u,v)$，$D_{uv} = d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)})$。\n3. 通过阈值图推断传播链：使用指定的阈值 $t$ 构建图 $G$，并为每个分离株输出其连通分量标签。标签必须是从 $1$ 开始的整数，在从索引 $1$ 到索引 $n$ 扫描分离株时按首次出现的顺序分配；同一个连通分量中的所有分离株共享相同的标签。\n\n最终输出格式：\n- 对于每个测试用例，生成一个包含三项的列表：ST 分配结果（按分离株输入顺序列出的整数列表）、展平的成对距离矩阵（按行主序排列并包含对角线元素的整数列表），以及连通分量标签（按分离株输入顺序列出的整数列表）。\n- 你的程序应生成单行输出，其中包含用方括号括起来、以逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。每个 \"result\" 是上述针对一个测试用例的列表。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：\n  - ST 数据库 $\\mathcal{D}_1$：\n    - ST $1$：[$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - ST $2$：[$1$,$2$,$4$,$4$,$5$,$6$,$7$]\n    - ST $42$：[$2$,$1$,$3$,$4$,$5$,$6$,$7$]\n    - ST $5$：[$1$,$2$,$3$,$4$,$6$,$6$,$7$]\n  - 暴发分离株谱（顺序定义了索引 $1$ 到 $4$）：\n    - 分离株 $1$：[$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - 分离株 $2$：[$1$,$2$,$4$,$4$,$5$,$6$,$7$]\n    - 分离株 $3$：[$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - 分离株 $4$：[$2$,$1$,$3$,$4$,$5$,$6$,$7$]\n  - 阈值 $t_1 = 1$。\n- 测试用例 $2$ (边界情况：谱相同，阈值严格)：\n  - ST 数据库 $\\mathcal{D}_2$：\n    - ST $7$：[$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n  - 暴发分离株谱（顺序定义了索引 $1$ 到 $3$）：\n    - 分离株 $1$：[$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n    - 分离株 $2$：[$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n    - 分离株 $3$：[$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n  - 阈值 $t_2 = 0$。\n- 测试用例 $3$ (边缘情况：出现新谱，通过单连接形成链)：\n  - ST 数据库 $\\mathcal{D}_3$：\n    - ST $10$：[$1$,$1$,$1$,$1$,$1$,$1$,$1$]\n    - ST $11$：[$1$,$1$,$2$,$1$,$1$,$1$,$1$]\n  - 暴发分离株谱（顺序定义了索引 $1$ 到 $3$）：\n    - 分离株 $1$：[$1$,$1$,$1$,$1$,$1$,$1$,$1$]\n    - 分离株 $2$：[$1$,$1$,$2$,$1$,$1$,$1$,$1$]\n    - 分离株 $3$：[$1$,$2$,$2$,$1$,$1$,$1$,$1$]\n  - 阈值 $t_3 = 1$。\n\n答案规范：\n- 对于每个测试用例，答案必须是 [STs, distances, clusters] 形式的列表，其中 STs 是一个整数列表，distances 是一个整数列表，clusters 也是一个整数列表。\n- 最终输出必须是单行文本，包含三个测试用例的结果，形式为用方括号括起来、以逗号分隔的列表，不含任何额外的空白或文本。",
            "solution": "本解决方案从多位点序列分型 (MLST) 和图连通性的基本定义出发，将它们转化为精确的计算步骤。\n\n1. 表示与 ST 分配：\n   - 每个分离株由一个 $7$ 维等位基因向量 $\\mathbf{a} = (a_1,a_2,\\dots,a_7) \\in \\mathbb{N}^7$ 表示。\n   - 提供的 ST 数据库 $\\mathcal{D}$ 是一个从整数 ST 标识符（例如，$1$, $2$, $42$）到 $\\mathbb{N}^7$ 中精确等位基因向量的有限映射。为给分离株分配 ST，我们执行精确匹配查找：如果存在一个 ST $s$ 使得 $\\mathcal{D}(s) = \\mathbf{a}$，则返回 $s$；否则，返回 $-1$ 以表示未知或新的谱。\n   - 从算法上讲，将 $\\mathcal{D}$ 反转为一个从谱元组到 ST 标识符的字典，并对每个分离株执行常数时间查找。这遵循了 ST 由精确的 $7$ 位点匹配定义的规则。\n\n2. 等位基因距离：\n   - 对于任意两个谱为 $\\mathbf{a}$ 和 $\\mathbf{b}$ 的分离株，其等位基因错配距离为\n     $$\n     d(\\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{7} \\mathbf{1}\\{a_i \\neq b_i\\}.\n     $$\n   - 这是在 $\\mathbb{N}^7$ 上的汉明距离，限制于在每个位点上进行相等性比较。它捕捉了等位基因不同的位点数量，符合医学微生物学中经过充分检验的 MLST 实践。\n   - 从算法上讲，通过迭代 $i$ 从 $1$ 到 $7$ 并在 $a_i \\neq b_i$ 时累加 $1$ 来计算 $d$。对于 $n$ 个分离株，构建完整的 $n \\times n$ 矩阵 $D$，其元素为 $D_{uv} = d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)})$。复杂度为 $O(n^2 \\cdot 7)$。\n\n3. 通过阈值图推断传播链：\n   - 给定一个非负整数阈值 $t$，定义一个无向图 $G=(V,E)$，其中 $V=\\{1,2,\\dots,n\\}$ 对分离株进行索引，且当且仅当 $D_{uv} \\le t$ 时，$\\{u,v\\} \\in E$。\n   - $G$ 的连通分量提供了一种有原则的、基于阈值的聚类方法，可作为潜在传播链的代理：如果 $d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)}) \\le t$，则这些分离株在等位基因空间中是“邻近的”，因此很可能在近期的传播链中相连。单连接连通性整合了传递关系：如果 $u$ 与 $v$ 相近，且 $v$ 与 $w$ 相近，那么即使 $u$ 和 $w$ 的差异大于 $t$，这三者也属于同一个连通分量。\n   - 从算法上讲，从每个未标记的顶点开始执行广度优先搜索 (BFS) 或深度优先搜索 (DFS) 来发现其所在的连通分量。在从索引 $1$ 到 $n$ 扫描分离株时，按首次出现的顺序分配从 $1$ 开始的连通分量标签。\n\n4. 输出构建：\n   - 对于每个测试用例，输出三项内容：\n     - 按分离株输入顺序排列的 ST 分配结果（整数列表）。\n     - 按行主序展平并包含对角线元素的距离矩阵（整数列表）。\n     - 按分离株输入顺序排列的连通分量标签（从 $1$ 开始的整数列表）。\n   - 将三个测试用例的输出聚合到一个列表中，并打印仅包含此聚合列表的一行文本，该列表用逗号分隔，并用方括号括起，不含空格。\n\n测试套件推理：\n- 测试用例 $1$：\n  - 分离株谱中包含与 ST $1$、ST $2$ 和 ST $42$ 的精确匹配；其中一个谱 [[$1$,$2$,$3$,$4$,$5$,$6$,$7$]] 出现两次，将 ST $1$ 分配给了两个分离株。\n  - 当 $t_1=1$ 时，图连接的是最多相差一个位点的分离株。分离株 $1$ 和 $3$ 的距离 $d=0$，因此相互连接。分离株 $2$ 与分离株 $1$ 和 $3$ 相差一个位点，因此与它们相连。分离株 $4$ 与分离株 $1$ 和 $3$ 相差两个位点，因此在 $t_1=1$ 的条件下不与之相连，形成一个独立的连通分量。算法将标记两个连通分量，第一个包含分离株 $1, 2, 3$，第二个包含分离株 $4$。\n- 测试用例 $2$：\n  - 所有分离株具有相同的谱，均与 ST $7$ 匹配。当 $t_2=0$ 时，仅在完全相同的谱之间存在边；所有分离株两两相同，因此图是完全连通的，从而形成一个单一的连通分量，所有分离株的标签都为 $1$。\n- 测试用例 $3$：\n  - 两个分离株分别与 ST $10$ 和 ST $11$ 匹配。第三个分离株具有一个新的谱，被分配为 $-1$。当 $t_3=1$ 时，图连接相差一个位点的分离株。第二个分离株充当了桥梁：它与第一个和第三个分离株均相差一个位点，因此根据传递性，所有三个分离株都属于同一个连通分量，并都获得相同的分量标签 $1$。\n\n这些步骤忠实地实现了基于 MLST 的 ST 分配、等位基因错配距离计算和阈值化连通性，以推断可能的传播链，这些都基于医学微生物学中用于 Leptospira interrogans 暴发分析的核心定义和标准实践。",
            "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5 (imported but not required), standard library only.\nimport numpy as np\nfrom collections import deque\n\ndef assign_sts(profiles, st_db):\n    \"\"\"\n    Assign ST by exact match. Unknown profiles get -1.\n    st_db: dict {ST_id: profile_list_of_7_ints}\n    profiles: list of profile_list_of_7_ints\n    returns: list of ST ids per profile\n    \"\"\"\n    # Invert database: profile tuple -> ST id\n    profile_to_st = {tuple(v): k for k, v in st_db.items()}\n    sts = []\n    for p in profiles:\n        sts.append(profile_to_st.get(tuple(p), -1))\n    return sts\n\ndef allelic_distance(a, b):\n    \"\"\"Count mismatches across 7 loci.\"\"\"\n    return sum(1 for ai, bi in zip(a, b) if ai != bi)\n\ndef distance_matrix(profiles):\n    \"\"\"Compute full nxn allelic distance matrix.\"\"\"\n    n = len(profiles)\n    D = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                D[i][j] = 0\n            else:\n                D[i][j] = allelic_distance(profiles[i], profiles[j])\n    return D\n\ndef connected_components(D, t):\n    \"\"\"\n    Compute connected components under threshold t on distance matrix D.\n    Return component labels per vertex in input order, starting at 1.\n    \"\"\"\n    n = len(D)\n    labels = [0]*n\n    current_label = 0\n    for start in range(n):\n        if labels[start] != 0:\n            continue\n        current_label += 1\n        # BFS from start\n        queue = deque([start])\n        labels[start] = current_label\n        while queue:\n            u = queue.popleft()\n            for v in range(n):\n                if labels[v] == 0 and D[u][v] = t:\n                    labels[v] = current_label\n                    queue.append(v)\n    return labels\n\ndef flatten_row_major(matrix):\n    \"\"\"Flatten a matrix (list of lists) in row-major order including diagonal.\"\"\"\n    return [elem for row in matrix for elem in row]\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Recursively format Python lists/ints/floats/bools without spaces,\n    enclosed in brackets for lists, with commas between elements.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"True\" if obj else \"False\"\n    elif isinstance(obj, (int, float)):\n        return str(obj)\n    else:\n        # Fallback for other types (should not occur in this task)\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"st_db\": {\n                1: [1,2,3,4,5,6,7],\n                2: [1,2,4,4,5,6,7],\n                42: [2,1,3,4,5,6,7],\n                5: [1,2,3,4,6,6,7],\n            },\n            \"profiles\": [\n                [1,2,3,4,5,6,7],\n                [1,2,4,4,5,6,7],\n                [1,2,3,4,5,6,7],\n                [2,1,3,4,5,6,7],\n            ],\n            \"t\": 1,\n        },\n        # Test Case 2\n        {\n            \"st_db\": {\n                7: [3,3,3,3,3,3,3],\n            },\n            \"profiles\": [\n                [3,3,3,3,3,3,3],\n                [3,3,3,3,3,3,3],\n                [3,3,3,3,3,3,3],\n            ],\n            \"t\": 0,\n        },\n        # Test Case 3\n        {\n            \"st_db\": {\n                10: [1,1,1,1,1,1,1],\n                11: [1,1,2,1,1,1,1],\n            },\n            \"profiles\": [\n                [1,1,1,1,1,1,1],\n                [1,1,2,1,1,1,1],\n                [1,2,2,1,1,1,1],\n            ],\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        st_db = case[\"st_db\"]\n        profiles = case[\"profiles\"]\n        t = case[\"t\"]\n\n        # ST assignment\n        sts = assign_sts(profiles, st_db)\n\n        # Distance matrix and flatten\n        D = distance_matrix(profiles)\n        D_flat = flatten_row_major(D)\n\n        # Connected components under threshold t\n        clusters = connected_components(D, t)\n\n        # Append result triple for this test case\n        results.append([sts, D_flat, clusters])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_no_spaces(results))\n\nsolve()\n```"
        }
    ]
}