{
    "hands_on_practices": [
        {
            "introduction": "联合模型的一个核心功能是将患者不断变化的生物标志物水平直接与其事件发生的瞬时风险（即风险率）联系起来。第一个练习将指导你完成一个基础的个体特异性风险率 $h_i(t)$ 的计算，以巩固对纵向轨迹、基线协变量和关联参数 $\\alpha$ 如何结合以量化特定时刻风险的理解 。",
            "id": "4968612",
            "problem": "肿瘤学中的一项前瞻性队列研究纵向追踪受试者特异性的血清生物标志物，并记录其进展时间。考虑一个通过共享参数将纵向生物标志物过程与事件时间过程联系起来的联合模型。纵向子模型在时间 $t$ 产生一个受试者特异性的后验均值轨迹 $\\hat m_i(t)$，其中 $i$ 是受试者的索引。生存子模型遵循比例风险原则：受试者特异性风险函数 $h_i(t)$ 与基线风险 $h_0(t)$ 成正比，其对数线性预测因子取决于基线协变量和同期的生物标志物水平。具体来说，假设对数风险在基线协变量贡献 $\\gamma^{\\top} w_i$ 和当前值关联项 $\\alpha \\hat m_i(t)$ 上是可加的，其中 $\\gamma$ 是基线协变量向量 $w_i$ 的回归系数向量，而 $\\alpha$ 量化了预期生物标志物水平与风险之间的关联。基线风险 $h_0(t)$ 是 $t$ 的一个非负函数，反映了当 $\\gamma^{\\top} w_i = 0$ 且 $\\hat m_i(t) = 0$ 时受试者的基础事件率。\n\n从风险函数的定义和Cox比例风险(PH)模型中的比例风险假设出发，推导 $h_i(t)$ 关于 $h_0(t)$、$\\gamma^{\\top} w_i$、$\\alpha$ 和 $\\hat m_i(t)$ 的显式表达式。然后，对于一个特定受试者，在给定时间 $t$，当 $\\hat m_i(t) = 2.3$、$\\gamma^{\\top} w_i = 0.5$、$\\alpha = 0.8$ 和 $h_0(t) = 0.01$ 时，对 $h_i(t)$ 进行数值计算。将最终数值答案四舍五入到四位有效数字。以“事件数/月”为单位表示风险。最后，根据微小时间间隔内的瞬时事件概率，对所得风险的量级给出一个简短的数值解释。",
            "solution": "用户提供了一个医学统计建模领域的问题陈述，具体涉及纵向数据和事件时间数据的联合建模。任务是推导受试者特异性风险函数的表达式，对其进行数值计算，并给出解释。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n-   模型是一个带有共享参数的联合模型。\n-   纵向子模型提供受试者特异性的后验均值轨迹，$\\hat{m}_i(t)$。\n-   生存子模型遵循比例风险原则。\n-   受试者特异性风险函数为 $h_i(t)$。\n-   基线风险函数为 $h_0(t)$。\n-   对数风险在基线协变量贡献 $\\gamma^{\\top} w_i$ 和当前值关联项 $\\alpha \\hat{m}_i(t)$ 上是可加的。\n-   基线风险 $h_0(t)$ 对应于 $\\gamma^{\\top} w_i = 0$ 且 $\\hat{m}_i(t) = 0$ 的受试者。\n-   用于特定评估的值：$\\hat{m}_i(t) = 2.3$，$\\gamma^{\\top} w_i = 0.5$，$\\alpha = 0.8$，以及 $h_0(t) = 0.01$。\n-   风险的单位是“事件数/月”。\n\n**步骤 2：使用提取的给定条件进行验证**\n-   **科学基础**：该问题具有科学基础。它描述了一个标准的时依Cox比例风险模型，其中时依协变量是纵向子模型的输出。这是共享参数联合模型的典型结构，是在生物统计学中用于分析临床试验和队列研究数据的广泛使用且经过验证的方法。\n-   **适定性**：该问题是适定的。它提供了清晰的定义和所有必要信息，以推导所要求的表达式并执行数值计算。任务具体，并导向唯一的解。\n-   **客观性**：问题以精确、客观和技术性的语言陈述，没有歧义或主观论断。\n-   **结论**：没有明显的缺陷，如科学上不合理、不完整、矛盾或含糊不清。该问题是应用生存分析原理的一个有效练习。\n\n**步骤 3：结论与行动**\n问题有效。现在开始求解过程。\n\n### 风险函数表达式的推导\n\n问题陈述生存子模型遵循比例风险(PH)原则。在PH模型中，受试者 $i$ 在时间 $t$ 的风险函数，记为 $h_i(t)$，与基线风险函数 $h_0(t)$ 成正比。比例因子是受试者协变量的函数。对于时依模型，此关系表示为：\n$$\nh_i(t) = h_0(t) \\exp(\\eta_i(t))\n$$\n其中 $\\eta_i(t)$ 是受试者 $i$ 在时间 $t$ 的线性预测因子。\n\n问题指明“对数风险是可加的”。这是描述对数风险尺度上线性预测因子结构的标准术语。具体来说，对PH方程取自然对数可得：\n$$\n\\ln(h_i(t)) = \\ln(h_0(t)) + \\eta_i(t)\n$$\n或\n$$\n\\ln\\left(\\frac{h_i(t)}{h_0(t)}\\right) = \\eta_i(t)\n$$\n量 $\\ln(h_i(t)) - \\ln(h_0(t))$ 是对数风险比，它等于线性预测因子。\n\n问题定义了线性预测因子的组成部分。它在基线协变量贡献 $\\gamma^{\\top} w_i$ 和生物标志物当前值项 $\\alpha \\hat{m}_i(t)$ 上是可加的。因此，线性预测因子 $\\eta_i(t)$ 是：\n$$\n\\eta_i(t) = \\gamma^{\\top} w_i + \\alpha \\hat{m}_i(t)\n$$\n将此线性预测因子的表达式代入第一个 $h_i(t)$ 的方程，得到受试者特异性风险函数的显式表达式：\n$$\nh_i(t) = h_0(t) \\exp\\left(\\gamma^{\\top} w_i + \\alpha \\hat{m}_i(t)\\right)\n$$\n这就是根据给定分量推导出的 $h_i(t)$ 的表达式。\n\n### 数值计算\n\n下一个任务是使用给定的值，对特定受试者在给定时间 $t$ 的 $h_i(t)$ 进行数值计算：\n-   $\\hat{m}_i(t) = 2.3$\n-   $\\gamma^{\\top} w_i = 0.5$\n-   $\\alpha = 0.8$\n-   $h_0(t) = 0.01$ 事件数/月。\n\n我们将这些值代入推导出的公式中：\n$$\nh_i(t) = 0.01 \\times \\exp\\left(0.5 + (0.8)(2.3)\\right)\n$$\n首先，我们计算指数中的线性预测因子的值：\n$$\n0.5 + (0.8)(2.3) = 0.5 + 1.84 = 2.34\n$$\n现在，将此值代回风险表达式中：\n$$\nh_i(t) = 0.01 \\times \\exp(2.34)\n$$\n我们计算 $\\exp(2.34)$ 的值：\n$$\n\\exp(2.34) \\approx 10.381606\n$$\n最后，我们计算 $h_i(t)$：\n$$\nh_i(t) \\approx 0.01 \\times 10.381606 = 0.10381606\n$$\n问题要求将最终数值答案四舍五入到四位有效数字。前四位有效数字是 $1$、$0$、$3$ 和 $8$。第五位有效数字是 $1$，所以我们向下舍入。\n$$\nh_i(t) \\approx 0.1038\n$$\n单位是事件数/月。\n\n### 风险的解释\n\n风险函数 $h(t)$ 表示在存活至时间 $t$ 的条件下，事件在时间 $t$ 发生的瞬时率。其定义为：\n$$\nh(t) = \\lim_{\\Delta t \\to 0} \\frac{P(t \\le T  t + \\Delta t \\mid T \\ge t)}{\\Delta t}\n$$\n其中 $T$ 是事件时间随机变量。对于一个非常小的时间间隔 $\\Delta t$，在该间隔内发生事件的概率（以存活到该间隔开始为条件）可以近似为：\n$$\nP(t \\le T  t + \\Delta t \\mid T \\ge t) \\approx h(t) \\Delta t\n$$\n在我们的案例中，计算出的风险是 $h_i(t) \\approx 0.1038$ 事件数/月。这意味着对于一个在时间 $t$ 时无进展并且具有指定协变量和生物标志物特征（$\\gamma^{\\top} w_i = 0.5$ 和 $\\hat{m}_i(t) = 2.3$）的受试者，其瞬时进展风险为每月 $0.1038$。为了更具体地说明，该受试者在下一个微小时间间隔 $\\Delta t$ 内经历疾病进展的近似概率为 $0.1038 \\times \\Delta t$，其中 $\\Delta t$ 以月为单位。例如，在一天（约一个月的 $\\frac{1}{30}$）的过程中，进展的概率约为 $0.1038 \\times \\frac{1}{30} \\approx 0.00346$，即约 $0.35\\%$。",
            "answer": "$$\n\\boxed{0.1038}\n$$"
        },
        {
            "introduction": "除了瞬时风险，联合模型的真正威力在于进行动态的、个性化的预测。本练习将从时间点的风险率转向计算未来时间窗口内的生存概率，这是一个常见的临床问题。你还将使用Delta方法来量化该预测的不确定性，这是实际应用中至关重要的一步 。",
            "id": "4968550",
            "problem": "一项临床研究通过随机截距和随机斜率纵向模型来监测一个连续观测的生物标志物，并通过比例风险结构将主要事件的瞬时风险与当前潜在的生物标志物水平联系起来。考虑受试者 $i$，其历史信息截至时间 $t^{\\star} = 2$ (年)。纵向子模型将受试者特异性潜在生物标志物轨迹指定为 $m_i(t) = \\beta_0 + \\beta_1 t + b_{0i} + b_{1i} t$，其中 $b_{0i}$ 和 $b_{1i}$ 分别是随机截距和随机斜率。事件时间子模型将风险指定为 $h_i(t \\mid b_i) = \\lambda_0 \\exp\\{\\alpha \\, m_i(t)\\}$，其中 $\\lambda_0  0$ 是一个恒定的基线风险，$\\alpha$ 是一个生物标志物-事件关联参数。假设除了 $m_i(t)$ 外，风险中没有其他基线协变量。\n\n假设一个联合模型已被拟合，并得到经验贝叶斯(EB)估计 $\\hat b_i = (\\hat b_{0i}, \\hat b_{1i})^{\\top}$ 以及在给定受试者截至 $t^{\\star}$ 的数据下 $b_i$ 的后验分布的正态近似：$b_i \\mid \\text{data up to } t^{\\star} \\approx \\mathcal{N}_2(\\hat b_i, V_i)$，其中 $V_i$ 是 $2 \\times 2$ 的协方差矩阵。对于该受试者，使用从联合模型拟合中估计出的以下参数值：\n- $\\lambda_0 = 0.05$ (每年)，$\\alpha = 0.4$，$\\beta_0 = 1.0$，$\\beta_1 = 0.3$，\n- $\\hat b_i = (\\hat b_{0i}, \\hat b_{1i})^{\\top} = (0.2, -0.05)^{\\top}$，\n- $V_i = \\begin{pmatrix} 0.04  0.006 \\\\ 0.006  0.01 \\end{pmatrix}$。\n\n从风险和生存之间的基本关系 $S_i(t) = \\exp\\!\\left(-\\int_0^t h_i(s \\mid b_i)\\, ds\\right)$ 出发，并在给定受试者在 $t^{\\star}$ 时的信息的条件下，请从第一性原理推导，对于时间窗 $[t^{\\star}, t^{\\star}+1]$，使用 EB 估计 $\\hat b_i$ 的“代入式”一年期动态生存预测 $S_i(1 \\mid \\hat b_i)$，然后通过基于 $V_i$ 的一阶 Delta 方法近似，量化 $S_i(1 \\mid \\hat b_i)$ 中仅由 $b_i$ 的估计所导致的不确定性。明确计算：\n1. $S_i(1 \\mid \\hat b_i)$ 的数值。\n2. 由 $b_i$ 的不确定性引起的一阶 Delta 方法对 $S_i(1 \\mid \\hat b_i)$ 的标准误的数值。\n\n将生存预测及其标准误均表示为无量纲量。将每个数值四舍五入到四位有效数字。你的最终答案必须是这两个数字的有序对。",
            "solution": "本题要求在纵向和事件时间数据的联合模型框架内，计算动态生存预测及其相关的标准误。求解过程分为两部分：首先，计算“代入式”生存估计；其次，使用一阶 Delta 方法量化其不确定性。\n\n问题中对于“时间窗 $[t^{\\star}, t^{\\star}+1]$ 内的一年期动态生存预测”的符号 $S_i(1 \\mid \\hat b_i)$，指的是在生存到时间 $t^{\\star}$ 的条件下，生存超过时间 $t^{\\star}+1$ 的条件概率，并使用经验贝叶斯估计 $\\hat b_i$ 进行评估。该条件生存概率，我们记作 $S_{dyn}(1 \\mid b_i)$，其形式化定义为 $P(T_i  t^{\\star}+1 \\mid T_i  t^{\\star}, b_i)$。基于风险函数 $h_i(t)$ 和生存函数 $S_i(t) = \\exp(-\\int_0^t h_i(s) ds)$ 之间的基本关系，该条件概率为：\n$$\nS_{dyn}(1 \\mid b_i) = \\frac{S_i(t^{\\star}+1 \\mid b_i)}{S_i(t^{\\star} \\mid b_i)} = \\frac{\\exp\\left(-\\int_0^{t^{\\star}+1} h_i(s \\mid b_i) \\, ds\\right)}{\\exp\\left(-\\int_0^{t^{\\star}} h_i(s \\mid b_i) \\, ds\\right)} = \\exp\\left(-\\int_{t^{\\star}}^{t^{\\star}+1} h_i(s \\mid b_i) \\, ds\\right)\n$$\n题目要求的是“代入式”估计，这意味着我们将随机效应向量 $b_i = (b_{0i}, b_{1i})^{\\top}$ 替换为其估计值 $\\hat b_i = (\\hat b_{0i}, \\hat b_{1i})^{\\top}$。\n\n在估计值 $\\hat b_i$ 处评估的受试者特异性纵向轨迹为：\n$$\nm_i(t \\mid \\hat b_i) = \\beta_0 + \\beta_1 t + \\hat b_{0i} + \\hat b_{1i} t = (\\beta_0 + \\hat b_{0i}) + (\\beta_1 + \\hat b_{1i}) t\n$$\n让我们将受试者 $i$ 的固定和随机部分定义为 $B_{0i} = \\beta_0 + \\hat b_{0i}$ 和 $B_{1i} = \\beta_1 + \\hat b_{1i}$。\n那么风险函数为 $h_i(t \\mid \\hat b_i) = \\lambda_0 \\exp\\{\\alpha \\, m_i(t \\mid \\hat b_i)\\} = \\lambda_0 \\exp\\{\\alpha(B_{0i} + B_{1i} t)\\}$。\n\n首先，我们计算区间 $[t^{\\star}, t^{\\star}+1]$ 上的累积风险：\n$$\n\\Lambda_i(t^{\\star}, t^{\\star}+1 \\mid \\hat b_i) = \\int_{t^{\\star}}^{t^{\\star}+1} h_i(s \\mid \\hat b_i) \\, ds = \\int_{t^{\\star}}^{t^{\\star}+1} \\lambda_0 \\exp(\\alpha B_{0i} + \\alpha B_{1i} s) \\, ds\n$$\n$$\n= \\lambda_0 \\exp(\\alpha B_{0i}) \\int_{t^{\\star}}^{t^{\\star}+1} \\exp(\\alpha B_{1i} s) \\, ds\n$$\n假设 $B_{1i} \\neq 0$，该积分的计算结果为：\n$$\n\\Lambda_i(t^{\\star}, t^{\\star}+1 \\mid \\hat b_i) = \\lambda_0 \\exp(\\alpha B_{0i}) \\left[ \\frac{\\exp(\\alpha B_{1i} s)}{\\alpha B_{1i}} \\right]_{s=t^{\\star}}^{t^{\\star}+1} = \\frac{\\lambda_0 \\exp(\\alpha B_{0i})}{\\alpha B_{1i}} \\left( \\exp(\\alpha B_{1i}(t^{\\star}+1)) - \\exp(\\alpha B_{1i} t^{\\star}) \\right)\n$$\n“代入式”动态生存预测为 $S_{dyn}(1 \\mid \\hat b_i) = \\exp(-\\Lambda_i(t^{\\star}, t^{\\star}+1 \\mid \\hat b_i))$。\n\n使用给定值：\n$t^{\\star} = 2$，$\\lambda_0 = 0.05$，$\\alpha = 0.4$，$\\beta_0 = 1.0$，$\\beta_1 = 0.3$，$\\hat b_{0i} = 0.2$，$\\hat b_{1i} = -0.05$。\n$B_{0i} = 1.0 + 0.2 = 1.2$\n$B_{1i} = 0.3 + (-0.05) = 0.25$\n由于 $B_{1i} = 0.25 \\neq 0$，我们可以使用推导出的公式。\n$$\n\\Lambda_i(2, 3 \\mid \\hat b_i) = \\frac{0.05 \\exp(0.4 \\times 1.2)}{0.4 \\times 0.25} \\left( \\exp(0.4 \\times 0.25 \\times 3) - \\exp(0.4 \\times 0.25 \\times 2) \\right)\n$$\n$$\n= \\frac{0.05 \\exp(0.48)}{0.1} \\left( \\exp(0.3) - \\exp(0.2) \\right) = 0.5 \\exp(0.48) \\left( \\exp(0.3) - \\exp(0.2) \\right)\n$$\n数值计算如下：\n$$\n\\Lambda_i(2, 3 \\mid \\hat b_i) \\approx 0.5 \\times 1.616074 \\times (1.349859 - 1.221403) \\approx 0.5 \\times 1.616074 \\times 0.128456 \\approx 0.10380\n$$\n生存预测为：\n$$\nS_{dyn}(1 \\mid \\hat b_i) = \\exp(-0.10380) \\approx 0.90141\n$$\n四舍五入到四位有效数字，生存预测为 $0.9014$。\n\n接下来，我们使用一阶 Delta 方法计算标准误。令 $g(b_i) = S_{dyn}(1 \\mid b_i)$。$g(b_i)$ 的方差可近似为：\n$$\n\\text{Var}(g(b_i)) \\approx \\left[ \\nabla_b g(b_i) \\right]^{\\top} V_i \\left[ \\nabla_b g(b_i) \\right] \\Big|_{b_i=\\hat b_i}\n$$\n其中 $\\nabla_b g(b_i)$ 是 $g(b_i)$ 关于 $b_i = (b_{0i}, b_{1i})^{\\top}$ 的梯度。\n令 $\\Lambda(b_i) = \\int_{t^{\\star}}^{t^{\\star}+1} h_i(s \\mid b_i) \\, ds$。则 $g(b_i) = \\exp(-\\Lambda(b_i))$。\n使用链式法则，梯度为：\n$$\n\\nabla_b g(b_i) = -\\exp(-\\Lambda(b_i)) \\nabla_b \\Lambda(b_i) = -g(b_i) \\nabla_b \\Lambda(b_i)\n$$\n我们需要计算累积风险的梯度，$\\nabla_b \\Lambda(b_i) = (\\frac{\\partial \\Lambda}{\\partial b_{0i}}, \\frac{\\partial \\Lambda}{\\partial b_{1i}})^{\\top}$。\n第一个偏导数为：\n$$\n\\frac{\\partial \\Lambda}{\\partial b_{0i}} = \\int_{t^{\\star}}^{t^{\\star}+1} \\frac{\\partial}{\\partial b_{0i}} h_i(s \\mid b_i) \\, ds = \\int_{t^{\\star}}^{t^{\\star}+1} h_i(s \\mid b_i) \\cdot \\alpha \\frac{\\partial m_i(s \\mid b_i)}{\\partial b_{0i}} \\, ds = \\int_{t^{\\star}}^{t^{\\star}+1} \\alpha h_i(s \\mid b_i) \\, ds = \\alpha \\Lambda(b_i)\n$$\n第二个偏导数为：\n$$\n\\frac{\\partial \\Lambda}{\\partial b_{1i}} = \\int_{t^{\\star}}^{t^{\\star}+1} \\frac{\\partial}{\\partial b_{1i}} h_i(s \\mid b_i) \\, ds = \\int_{t^{\\star}}^{t^{\\star}+1} h_i(s \\mid b_i) \\cdot \\alpha \\frac{\\partial m_i(s \\mid b_i)}{\\partial b_{1i}} \\, ds = \\int_{t^{\\star}}^{t^{\\star}+1} \\alpha s h_i(s \\mid b_i) \\, ds\n$$\n我们在 $b_i = \\hat b_i$ 处计算这些导数。\n$\\frac{\\partial \\Lambda}{\\partial b_{0i}} \\Big|_{\\hat b_i} = \\alpha \\Lambda(\\hat b_i) \\approx 0.4 \\times 0.10380 = 0.041520$。\n对于第二个导数：\n$$\n\\frac{\\partial \\Lambda}{\\partial b_{1i}} \\Big|_{\\hat b_i} = \\int_{2}^{3} \\alpha s \\, \\lambda_0 \\exp(\\alpha(B_{0i} + B_{1i} s)) \\, ds = \\alpha \\lambda_0 \\exp(\\alpha B_{0i}) \\int_{2}^{3} s \\exp(\\alpha B_{1i} s) \\, ds\n$$\n积分 $\\int s \\exp(as) \\, ds$ 可通过分部积分法求解：$\\left(\\frac{s}{a} - \\frac{1}{a^2}\\right)\\exp(as)$。\n当 $a = \\alpha B_{1i} = 0.4 \\times 0.25 = 0.1$ 时：\n$$\n\\int_{2}^{3} s \\exp(0.1 s) \\, ds = \\left[ \\left(\\frac{s}{0.1} - \\frac{1}{0.1^2}\\right) \\exp(0.1s) \\right]_{2}^{3} = \\left[ (10s - 100) \\exp(0.1s) \\right]_{2}^{3}\n$$\n$$\n= (10 \\times 3 - 100)\\exp(0.3) - (10 \\times 2 - 100)\\exp(0.2) = 80\\exp(0.2) - 70\\exp(0.3)\n$$\n数值计算结果为 $80 \\times 1.221403 - 70 \\times 1.349859 \\approx 97.71224 - 94.49013 = 3.22211$。\n于是，\n$$\n\\frac{\\partial \\Lambda}{\\partial b_{1i}} \\Big|_{\\hat b_i} = (0.4)(0.05) \\exp(0.48) \\times 3.22211 = 0.02 \\exp(0.48) \\times 3.22211 \\approx 0.02 \\times 1.616074 \\times 3.22211 \\approx 0.10411\n$$\n所以，$\\nabla_b \\Lambda(\\hat b_i) \\approx (0.041520, 0.10411)^{\\top}$。\n$g$ 的梯度是：\n$$\n\\nabla_b g(\\hat b_i) \\approx -0.90141 \\begin{pmatrix} 0.041520 \\\\ 0.10411 \\end{pmatrix} = \\begin{pmatrix} -0.037422 \\\\ -0.093845 \\end{pmatrix}\n$$\n现在我们使用 $V_i = \\begin{pmatrix} 0.04  0.006 \\\\ 0.006  0.01 \\end{pmatrix}$ 计算方差：\n$$\n\\text{Var}(g(\\hat b_i)) \\approx \\begin{pmatrix} -0.037422  -0.093845 \\end{pmatrix} \\begin{pmatrix} 0.04  0.006 \\\\ 0.006  0.01 \\end{pmatrix} \\begin{pmatrix} -0.037422 \\\\ -0.093845 \\end{pmatrix}\n$$\n首先，行向量与矩阵的乘积：\n$$\n\\begin{pmatrix} -0.037422  -0.093845 \\end{pmatrix} \\begin{pmatrix} 0.04  0.006 \\\\ 0.006  0.01 \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} (-0.037422)(0.04) + (-0.093845)(0.006)  (-0.037422)(0.006) + (-0.093845)(0.01) \\end{pmatrix}\n$$\n$$\n= \\begin{pmatrix} -0.00149688 - 0.00056307  -0.00022453 - 0.00093845 \\end{pmatrix} = \\begin{pmatrix} -0.00205995  -0.00116298 \\end{pmatrix}\n$$\n最后，乘以列向量：\n$$\n\\text{Var}(g(\\hat b_i)) \\approx \\begin{pmatrix} -0.00205995  -0.00116298 \\end{pmatrix} \\begin{pmatrix} -0.037422 \\\\ -0.093845 \\end{pmatrix}\n$$\n$$\n= (-0.00205995)(-0.037422) + (-0.00116298)(-0.093845) \\approx 0.00007709 + 0.00010915 \\approx 0.00018624\n$$\n标准误是方差的平方根：\n$$\n\\text{SE}(g(\\hat b_i)) = \\sqrt{\\text{Var}(g(\\hat b_i))} \\approx \\sqrt{0.00018624} \\approx 0.013647\n$$\n四舍五入到四位有效数字，标准误为 $0.01365$。\n\n所需的值为生存预测及其标准误。\n1. 生存预测：$0.9014$\n2. 标准误：$0.01365$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.9014  0.01365 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在探讨了如何使用已拟合的联合模型之后，我们现在转向模型拟合过程本身。这个高级练习通过让你实现期望最大化 (Expectation-Maximization, EM) 算法的一个循环来揭开估算过程的神秘面纱。通过这个练习，你还将计算轨迹估计中的“倾斜”，从而对生存结局如何告知并完善我们对受试者纵向轮廓的认知有一个切实的理解 。",
            "id": "4968553",
            "problem": "考虑一个用于医学纵向标志物和事件时间结局的联合模型，其包含以下组成部分，这些部分的选择反映了生物统计学和流行病学中广泛使用的建模策略。纵向子模型是一个线性混合效应模型：对于在时间 $t_{ij}$ 测量且响应为 $y_{ij}$ 的受试者 $i$，\n$$\ny_{ij} = x_{ij}^{\\top}\\beta + z_{ij}^{\\top} b_i + \\varepsilon_{ij}, \\quad \\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma^2), \\quad b_i \\sim \\mathcal{N}(0, D),\n$$\n其中 $x_{ij}$ 和 $z_{ij}$ 是设计向量，$\\beta$ 是固定效应向量，$b_i$ 是受试者特异性随机效应向量，$\\sigma^2$ 是残差方差，$D$ 是随机效应协方差矩阵。事件时间子模型采用比例风险公式，具有恒定的基线风险和当前值关联：\n$$\nh_i(t) = \\lambda_0 \\exp\\left(\\alpha \\, m_i(t)\\right), \\quad m_i(t) = x(t)^{\\top}\\beta + z(t)^{\\top} b_i,\n$$\n其中 $\\lambda_0$ 是基线风险，$\\alpha$ 是将标志物与风险联系起来的关联参数，$m_i(t)$ 是纵向轨迹的当前值。令 $T_i$ 表示观测到的事件时间或删失时间，$\\delta_i \\in \\{0,1\\}$ 表示事件指示符（其中 $1$ 表示观测到事件）。\n\n从上述基本定义和标准似然理论出发，$b_i$ 在给定 $(y_i, T_i, \\delta_i)$ 条件下的后验分布与纵向似然、生存似然和随机效应先验的乘积成正比。在期望最大化（EM）算法（Expectation-Maximization (EM)）中，E步（期望步）需要计算条件期望 $E[b_i \\mid y_i, T_i, \\delta_i]$。Laplace 近似通过定位对数后验的众数并使用局部二次近似来评估该期望。然后，M步（最大化步）使用 $b_i$ 的条件期望，通过加权最小二乘法（权重为 $1/\\sigma^2$）来更新 $\\beta$。\n\n根据以下规范实现单次EM迭代：\n\n1. 对每个受试者 $i$，使用以 $b_i$ 对数后验的众数为中心的 Laplace 近似来计算 $E[b_i \\mid y_i, T_i, \\delta_i]$，该众数通过 Newton 法获得，其中对数后验的 Hessian 矩阵采用数值近似。对数后验是以下各项的总和：\n   - 在残差方差为 $\\sigma^2$ 的正态模型下的纵向对数似然。\n   - 具有恒定基线风险和当前值关联的生存对数似然：\n     $$\n     \\ell_{S,i}(b_i) = \\delta_i \\left(\\log \\lambda_0 + \\alpha \\, m_i(T_i)\\right) - \\int_0^{T_i} \\lambda_0 \\exp\\left(\\alpha \\, m_i(u)\\right) \\, du,\n     $$\n     其中 $m_i(u) = x(u)^{\\top}\\beta + z(u)^{\\top} b_i$ 且 $x(u) = z(u)$ 定义如下。\n   - 协方差为 $D$ 的 $b_i$ 的高斯先验对数密度。\n\n2. 使用权重 $w_{ij} = 1/\\sigma^2$ 通过加权最小二乘法更新 $\\beta$，将 $E[b_i \\mid y_i, T_i, \\delta_i]$ 视为混合模型中的已知偏移量。\n\n3. 此外，计算与纯线性混合效应（Linear Mixed Effects (LME)）分析相比，由生存信息引起的“倾斜”（tilt）。将 LME 后验均值 $E_{\\text{LME}}[b_i \\mid y_i]$ 定义为仅在纵向模型下的高斯后验均值。将受试者 $i$ 的倾斜定义为两个后验均值所隐含的在 $T_i$ 时的当前值差异：\n   $$\n   \\Delta m_i(T_i) = \\left[1, \\, T_i\\right]^{\\top} \\left(E[b_i \\mid y_i, T_i, \\delta_i] - E_{\\text{LME}}[b_i \\mid y_i]\\right).\n   $$\n   报告所有受试者的平均倾斜：\n   $$\n   \\text{Tilt} = \\frac{1}{N} \\sum_{i=1}^N \\Delta m_i(T_i),\n   $$\n   它量化了生存信息如何相对于纯 LME 后验均值，在由 $\\alpha$ 和观测到的 $(T_i, \\delta_i)$ 决定的方向上，使 $E[b_i \\mid \\cdot]$ 发生倾斜。\n\n使用以下科学上合理且自洽的数据和参数，其中单位被隐式解释为无量纲标志物，且纵向访视和生存时间均以相同单位测量：\n\n- 受试者数量： $N = 3$。\n- 每位受试者的访视时间： $t_{ij} \\in \\{0, 1, 2\\}$，其中 $j = 1, 2, 3$。\n- 设计向量： $x_{ij} = z_{ij} = \\begin{bmatrix} 1 \\\\ t_{ij} \\end{bmatrix}$ 用于纵向模型；$x(u) = z(u) = \\begin{bmatrix} 1 \\\\ u \\end{bmatrix}$ 用于生存模型的当前值。\n- 纵向响应：\n  - 受试者 $1$： $y_{1\\cdot} = [\\,2.4, \\,3.0, \\,3.2\\,]$。\n  - 受试者 $2$： $y_{2\\cdot} = [\\,1.8, \\,2.1, \\,2.5\\,]$。\n  - 受试者 $3$： $y_{3\\cdot} = [\\,2.1, \\,2.9, \\,3.6\\,]$。\n- 生存时间和指示符：\n  - 受试者 $1$： $T_1 = 0.8$, $\\delta_1 = 1$。\n  - 受试者 $2$： $T_2 = 3.0$, $\\delta_2 = 0$。\n  - 受试者 $3$： $T_3 = 2.0$, $\\delta_3 = 1$。\n- 基线风险： $\\lambda_0 = 0.15$ (恒定)。\n- 关联参数测试套件（三种情况用于测试倾斜方向和边界行为）：\n  - 情况A： $\\alpha = 0.8$ (正关联)。\n  - 情况B： $\\alpha = -0.8$ (负关联)。\n  - 情况C： $\\alpha = 0.0$ (无关联)。\n- 残差方差： $\\sigma^2 = 0.25$。\n- 随机效应协方差： $D = \\mathrm{diag}(0.4, 0.05)$。\n- 单次EM迭代的初始固定效应： $\\beta^{(0)} = [\\,1.5, \\,0.3\\,]^{\\top}$。\n\n实现要求：\n\n- 对于测试套件中的每个 $\\alpha$，从 $\\beta^{(0)}$ 开始执行恰好一次EM迭代：\n  - E步：使用以通过 Newton 法找到的后验众数为中心的 Laplace 近似计算 $E[b_i \\mid y_i, T_i, \\delta_i]$，其中对数后验的 Hessian 矩阵通过中心差分进行数值近似。\n  - M步：对所有受试者和访视，使用权重 $1/\\sigma^2$ 通过加权最小二乘法更新 $\\beta$，将 $E[b_i \\mid y_i, T_i, \\delta_i]$ 视为已知偏移量。\n\n- 仅在纵向子模型下，使用高斯后验公式定义纯 LME 后验均值 $E_{\\text{LME}}[b_i \\mid y_i]$。\n\n- 对于每种 $\\alpha$ 情况，计算并返回结果列表 $[\\,\\beta_0^{(1)}, \\,\\beta_1^{(1)}, \\,\\text{Tilt}\\,]$，其中 $\\beta^{(1)}$ 是单次EM迭代后更新的固定效应向量。\n\n你的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内是三种情况的结果，每种结果本身是一个包含三个浮点数的列表，用方括号括起来，格式与\n$$\n[\\,[\\beta_{0,A},\\beta_{1,A},\\text{Tilt}_A],\\,[\\beta_{0,B},\\beta_{1,B},\\text{Tilt}_B],\\,[\\beta_{0,C},\\beta_{1,C},\\text{Tilt}_C]\\,].\n$$\n完全一致。不应打印任何其他文本。答案必须仅包含纯数字，不附加任何单位。输出为浮点数，必须由程序根据指定的数据和参数计算得出；无需用户输入。\n\n测试套件覆盖范围：\n\n- 情况A ($\\alpha = 0.8$) 检验了联合建模中的标准正关联。\n- 情况B ($\\alpha = -0.8$) 测试了方向性反转，确保倾斜反映负关联。\n- 情况C ($\\alpha = 0.0$) 作为一个边界情况，此时生存信息不影响 $b_i$ 的后验分布，倾斜应在数值上接近于零。\n\n通过使用具有当前值关联的恒定基线风险、高斯纵向误差、正态随机效应以及纵向访视与生存时间之间一致的时间网格，确保了科学真实性。所有数值都是适度的，并与典型的临床纵向标志物和随访时间一致。",
            "solution": "该问题要求为纵向和事件时间数据的联合模型实现单次期望最大化（EM）迭代。目标是更新固定效应参数向量 $\\beta$，并计算一个“倾斜”（tilt）度量，该度量用于量化生存数据对随机效应后验估计的影响。该过程针对关联参数 $\\alpha$ 的三个不同值执行。\n\n受试者 $i$ 在时间 $t_{ij}$ 的纵向子模型是一个线性混合效应模型：\n$$\ny_{ij} = x_{ij}^{\\top}\\beta + z_{ij}^{\\top} b_i + \\varepsilon_{ij}, \\quad \\varepsilon_{ij} \\sim \\mathcal{N}(0,\\sigma^2), \\quad b_i \\sim \\mathcal{N}(0, D)\n$$\n受试者 $i$ 的事件时间子模型遵循比例风险公式，具有恒定的基线风险 $\\lambda_0$ 和当前值关联结构：\n$$\nh_i(t) = \\lambda_0 \\exp\\left(\\alpha \\, m_i(t)\\right), \\quad \\text{其中} \\quad m_i(t) = x(t)^{\\top}\\beta + z(t)^{\\top} b_i\n$$\n问题将设计向量指定为 $x_{ij} = z_{ij} = [1, t_{ij}]^{\\top}$ 和 $x(t) = z(t) = [1, t]^{\\top}$，这对应于一个随机截距和随机斜率模型。我们被给予了初始参数 $\\beta^{(0)}$、$\\sigma^2$ 和 $D$，以及 $N=3$ 个受试者的数据。\n\n单次EM迭代由一个期望（E）步和一个最大化（M）步组成。\n\n**1. E步：随机效应的条件期望**\n\nE步需要计算在给定观测数据 $(y_i, T_i, \\delta_i)$ 和当前参数估计 $\\theta^{(0)} = (\\beta^{(0)}, \\sigma^2, D, \\lambda_0, \\alpha)$ 的条件下，随机效应 $b_i$ 的期望。这个期望是 $E[b_i \\mid y_i, T_i, \\delta_i, \\theta^{(0)}]$。\n\n使用 Laplace 近似来评估此期望。该近似表明，条件期望可以由 $b_i$ 的后验分布的众数很好地近似。\n$$\n\\hat{b}_i^{\\text{joint}} = E[b_i \\mid y_i, T_i, \\delta_i, \\theta^{(0)}] \\approx \\arg\\max_{b_i} p(b_i \\mid y_i, T_i, \\delta_i, \\theta^{(0)})\n$$\n寻找众数等价于最大化对数后验，或最小化其负值。对数后验与三个组成部分的总和成正比：纵向对数似然、生存对数似然以及随机效应的先验对数密度。\n$$\n\\log p(b_i \\mid \\cdot) \\propto \\ell_{L,i}(b_i) + \\ell_{S,i}(b_i) + \\log p(b_i)\n$$\n关于 $b_i$ 的各个组成部分是：\n- **纵向对数似然**：基于测量误差的正态分布，$\\varepsilon_i = y_i - X_i\\beta - Z_ib_i$。\n    $$\n    \\ell_{L,i}(b_i) = -\\frac{1}{2\\sigma^2} (y_i - X_i\\beta^{(0)} - Z_ib_i)^{\\top}(y_i - X_i\\beta^{(0)} - Z_ib_i)\n    $$\n- **生存对数似然**：对于恒定基线风险和当前值关联。\n    $$\n    \\ell_{S,i}(b_i) = \\delta_i \\left(\\log \\lambda_0 + \\alpha \\, m_i(T_i)\\right) - \\int_0^{T_i} \\lambda_0 \\exp\\left(\\alpha \\, m_i(u)\\right) \\, du\n    $$\n    其中 $m_i(u) = [1, u]^{\\top}\\beta^{(0)} + [1, u]^{\\top}b_i$。该积分可以解析计算。令 $C_0 = \\alpha(\\beta_0^{(0)} + b_{i0})$ 和 $C_1 = \\alpha(\\beta_1^{(0)} + b_{i1})$。如果 $C_1 \\neq 0$，积分为 $\\frac{\\exp(C_0)}{C_1}(\\exp(C_1 T_i) - 1)$；如果 $C_1 = 0$，则为 $T_i\\exp(C_0)$。\n- **先验对数密度**：根据假设 $b_i \\sim \\mathcal{N}(0,D)$。\n    $$\n    \\log p(b_i) = -\\frac{1}{2} b_i^{\\top}D^{-1}b_i - \\frac{1}{2}\\log|2\\pi D|\n    $$\n后验的众数通过使用 Newton 法最小化负对数后验来找到。令 $F(b_i)$ 为负对数后验函数（目标函数）。$b_i$ 的迭代更新公式为：\n$$\nb_i^{(k+1)} = b_i^{(k)} - [H_F(b_i^{(k)})]^{-1} g_F(b_i^{(k)})\n$$\n其中 $g_F(b_i)$ 和 $H_F(b_i)$ 分别是 $F(b_i)$ 的梯度和 Hessian 矩阵。按照规定，Hessian 矩阵是数值近似的。为保证稳健性，梯度也使用中心差分进行数值计算。迭代从 $b_i^{(0)} = [0, 0]^{\\top}$ 开始。\n\n**2. M步：固定效应的更新**\n\n在M步中，固定效应向量 $\\beta$ 通过最大化期望完全数据对数似然进行更新，这简化为一个加权最小二乘问题。我们找到最小化以下表达式的 $\\beta^{(1)}$：\n$$\n\\sum_{i=1}^N \\sum_{j=1}^{n_i} w_{ij} (y_{ij} - x_{ij}^{\\top}\\beta - z_{ij}^{\\top}\\hat{b}_i^{\\text{joint}})^2\n$$\n其中 $\\hat{b}_i^{\\text{joint}}$ 是在E步中计算的条件期望，权重为 $w_{ij}=1/\\sigma^2$。令 $y_{ij}^* = y_{ij} - z_{ij}^{\\top}\\hat{b}_i^{\\text{joint}}$，问题变为最小化 $\\sum_{i,j} (y_{ij}^* - x_{ij}^{\\top}\\beta)^2 / \\sigma^2$。常数因子 $1/\\sigma^2$ 可以忽略，从而得到一个普通最小二乘问题。对于所有受试者数据堆叠在一起的矩阵形式：\n$$\n\\beta^{(1)} = (X_{\\text{stacked}}^{\\top}X_{\\text{stacked}})^{-1}X_{\\text{stacked}}^{\\top}Y_{\\text{stacked}}^*\n$$\n其中 $Y_{\\text{stacked}}^*$ 是所有 $y_{ij}^*$ 值的向量，$X_{\\text{stacked}}$ 是固定效应的堆叠设计矩阵。\n\n**3. 倾斜计算**\n\n“倾斜”（tilt）量化了因纳入生存信息而导致的估计轨迹的变化。它将联合模型的后验均值 $\\hat{b}_i^{\\text{joint}}$ 与纯线性混合效应（LME）模型的后验均值 $\\hat{b}_i^{\\text{LME}} = E_{\\text{LME}}[b_i \\mid y_i, \\theta^{(0)}]$ 进行比较。\nLME后验均值是贝叶斯线性模型的一个标准结果，由下式给出：\n$$\n\\hat{b}_i^{\\text{LME}} = \\left(\\frac{1}{\\sigma^2}Z_i^\\top Z_i + D^{-1}\\right)^{-1} \\frac{1}{\\sigma^2} Z_i^\\top (y_i - X_i\\beta^{(0)})\n$$\n受试者 $i$ 的倾斜是其在生存时间 $T_i$ 时轨迹当前值的差异：\n$$\n\\Delta m_i(T_i) = [1, \\, T_i]^{\\top} \\left(\\hat{b}_i^{\\text{joint}} - \\hat{b}_i^{\\text{LME}}\\right)\n$$\n最终报告的值是所有 $N$ 个受试者的平均倾斜：\n$$\n\\text{Tilt} = \\frac{1}{N} \\sum_{i=1}^N \\Delta m_i(T_i)\n$$\n当 $\\alpha=0$ 时，生存数据不提供关于 $b_i$ 的信息，因此我们预期 $\\hat{b}_i^{\\text{joint}} \\approx \\hat{b}_i^{\\text{LME}}$，从而 $\\text{Tilt} \\approx 0$。当 $\\alpha  0$ 时，事件（$\\delta_i=1$）表明轨迹较高，使 $\\hat{b}_i^{\\text{joint}}$ 向上倾斜；而当 $\\alpha  0$ 时，事件表明轨迹较低。对于删失的受试者（$\\delta_i=0$），逻辑则相反。\n\n该过程对 $\\alpha$ 在 $\\{0.8, -0.8, 0.0\\}$ 中的每个值执行，使用所提供的数据和初始参数 $\\beta^{(0)} = [1.5, 0.3]^{\\top}$、$\\sigma^2=0.25$、 $D=\\mathrm{diag}(0.4, 0.05)$ 和 $\\lambda_0=0.15$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a single EM iteration for a joint model of longitudinal and time-to-event data.\n    \"\"\"\n\n    # --- 1. Define Data and Parameters ---\n    # Number of subjects\n    N = 3\n\n    # Longitudinal and survival data for N=3 subjects\n    y_data = [\n        np.array([2.4, 3.0, 3.2]),\n        np.array([1.8, 2.1, 2.5]),\n        np.array([2.1, 2.9, 3.6])\n    ]\n    t_visits = np.array([0.0, 1.0, 2.0])\n    T_survival = np.array([0.8, 3.0, 2.0])\n    delta_event = np.array([1, 0, 1])\n\n    # Design matrices (common for all subjects)\n    Z = np.vstack((np.ones_like(t_visits), t_visits)).T\n    X = Z\n\n    # Model parameters\n    beta0 = np.array([1.5, 0.3])\n    sigma2 = 0.25\n    D = np.diag([0.4, 0.05])\n    D_inv = np.linalg.inv(D)\n    lambda0 = 0.15\n\n    # Test suite for alpha\n    alpha_suite = [0.8, -0.8, 0.0]\n\n    # --- 2. Helper Functions ---\n    def neg_log_posterior(b, y, T, delta, alpha, X, Z, beta, sigma2, D_inv, lambda0):\n        \"\"\"\n        Computes the negative of the log-posterior of b_i. This is the objective function to minimize.\n        \"\"\"\n        # Longitudinal log-likelihood contribution\n        residuals = y - X @ beta - Z @ b\n        log_lik_long = (1 / (2 * sigma2)) * (residuals.T @ residuals)\n\n        # Survival log-likelihood contribution\n        m_T = np.array([1, T]) @ beta + np.array([1, T]) @ b\n        term1_surv = delta * (np.log(lambda0) + alpha * m_T)\n\n        # Integral part of survival likelihood\n        c0 = alpha * (beta[0] + b[0])\n        c1 = alpha * (beta[1] + b[1])\n        \n        integral_val = 0\n        if np.abs(c1)  1e-9: # Handle case where slope is near zero\n            integral_val = T * np.exp(c0)\n        else:\n            integral_val = (np.exp(c0) / c1) * (np.exp(c1 * T) - 1)\n        \n        term2_surv = -lambda0 * integral_val\n        log_lik_surv = term1_surv + term2_surv\n\n        # Prior log-density contribution for b_i\n        log_prior_b = 0.5 * (b.T @ D_inv @ b)\n\n        # Negative log-posterior (ignoring constants)\n        return log_lik_long + log_prior_b - log_lik_surv\n\n    def numerical_gradient(f, x, args, h=1e-5):\n        \"\"\"Numerically compute gradient of f at x using central differences.\"\"\"\n        grad = np.zeros_like(x)\n        for i in range(len(x)):\n            x_plus_h = x.copy()\n            x_plus_h[i] += h\n            x_minus_h = x.copy()\n            x_minus_h[i] -= h\n            grad[i] = (f(x_plus_h, *args) - f(x_minus_h, *args)) / (2 * h)\n        return grad\n\n    def numerical_hessian(f, x, args, h=1e-5):\n        \"\"\"Numerically compute Hessian of f at x using central differences.\"\"\"\n        n = len(x)\n        hess = np.zeros((n, n))\n        for i in range(n):\n            for j in range(n):\n                x_pp = x.copy(); x_pp[i] += h; x_pp[j] += h\n                x_pm = x.copy(); x_pm[i] += h; x_pm[j] -= h\n                x_mp = x.copy(); x_mp[i] -= h; x_mp[j] += h\n                x_mm = x.copy(); x_mm[i] -= h; x_mm[j] -= h\n                \n                val = (f(x_pp, *args) - f(x_pm, *args) - f(x_mp, *args) + f(x_mm, *args)) / (4 * h**2)\n                hess[i, j] = val\n        return hess\n\n    def newton_method(f, x0, args, max_iter=10, tol=1e-6):\n        \"\"\"Newton's method for finding the minimum of f.\"\"\"\n        x = x0.copy()\n        for _ in range(max_iter):\n            grad = numerical_gradient(f, x, args)\n            hess = numerical_hessian(f, x, args)\n            try:\n                step = np.linalg.solve(hess, grad)\n            except np.linalg.LinAlgError:\n                # Use psuedo-inverse if Hessian is singular\n                step = np.linalg.pinv(hess) @ grad\n            \n            x_new = x - step\n            if np.linalg.norm(x_new - x)  tol:\n                break\n            x = x_new\n        return x\n\n    # --- 3. Main Loop for Each Alpha Case ---\n    results = []\n    \n    # Pre-calculate LME posterior means (independent of alpha)\n    b_lme_means = []\n    P_inv = np.linalg.inv(Z.T @ Z / sigma2 + D_inv)\n    for i in range(N):\n        y_i = y_data[i]\n        term2 = (Z.T @ (y_i - X @ beta0)) / sigma2\n        b_lme_i = P_inv @ term2\n        b_lme_means.append(b_lme_i)\n\n    # Pre-calculate terms for M-step\n    X_stacked = np.vstack([X] * N)\n    XTX_inv = np.linalg.inv(X_stacked.T @ X_stacked)\n\n    for alpha in alpha_suite:\n        # --- E-Step ---\n        b_joint_means = []\n        for i in range(N):\n            b0_i = np.array([0.0, 0.0])\n            args = (y_data[i], T_survival[i], delta_event[i], alpha, X, Z, beta0, sigma2, D_inv, lambda0)\n            b_joint_i = newton_method(neg_log_posterior, b0_i, args)\n            b_joint_means.append(b_joint_i)\n\n        # --- M-Step ---\n        y_star_stacked = np.zeros(N * len(t_visits))\n        for i in range(N):\n            y_i_star = y_data[i] - Z @ b_joint_means[i]\n            y_star_stacked[i*len(t_visits):(i+1)*len(t_visits)] = y_i_star\n        \n        beta1 = XTX_inv @ X_stacked.T @ y_star_stacked\n\n        # --- Tilt Calculation ---\n        tilts = []\n        for i in range(N):\n            zt_i = np.array([1, T_survival[i]])\n            delta_m_i = zt_i.T @ (b_joint_means[i] - b_lme_means[i])\n            tilts.append(delta_m_i)\n        \n        avg_tilt = np.mean(tilts)\n        \n        results.append([beta1[0], beta1[1], avg_tilt])\n\n    # --- 4. Format and Print Output ---\n    # Convert lists to string representation for printing\n    result_strings = [f\"[{r[0]:.8f},{r[1]:.8f},{r[2]:.8f}]\" for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\n\nsolve()\n```"
        }
    ]
}