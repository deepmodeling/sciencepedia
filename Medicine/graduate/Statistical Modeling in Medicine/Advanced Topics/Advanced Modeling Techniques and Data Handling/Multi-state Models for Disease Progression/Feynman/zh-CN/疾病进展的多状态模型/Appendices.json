{
    "hands_on_practices": [
        {
            "introduction": "从观察数据中估计疾病进展概率是多状态建模的核心任务。本练习将指导您从零开始实现 Aalen-Johansen 估计量 (AJE)，这是一种将 Kaplan-Meier 方法推广到多状态模型的强大非参数工具。通过这个实践 ()，您将深入理解 AJE 如何处理事件时间、风险集和删失数据，从而准确估计累积发病率等关键指标。",
            "id": "4975726",
            "problem": "考虑一个用于疾病进展的连续时间多状态模型，该模型包含三个状态：$0$ (健康)、$1$ (患病) 和 $2$ (死亡)。状态 $2$ 是吸收态。所有个体在时间 $0$ 时均从状态 $0$ 开始。假设数据为具有精确转移时间的面板数据，可能存在右删失。假设该连续时间多状态过程是非爆炸性的，并由允许的转移 $0 \\to 1$、$0 \\to 2$ 和 $1 \\to 2$ 之间的转移强度决定。\n\n从基础的计数过程框架出发，为每个允许的转移 $r \\to s$ 定义计数过程 $N_{rs}(t)$，该过程对截至时间 $t$ 观察到的从状态 $r$ 到状态 $s$ 的转移数量进行计数；并定义风险过程 $Y_r(t)$，该过程对在时间 $t$ 之前瞬间处于状态 $r$ 且在观察中的个体数量进行计数。累积转移强度矩阵的非参数估计量通过事件时间的增量来定义，该增量为观察到的转移计数与相应源状态下风险人群的比率。Aalen–Johansen 估计量 (AJE) 定义为单位矩阵加上估计的强度增量的乘积积分，它产生从时间 $0$ 到时间 $t$ 的转移概率矩阵的估计。\n\n您的任务是实现一个程序，仅使用这些核心定义，通过 Aalen–Johansen 估计量计算从状态 $0$ 开始到时间 $t$ 的累积死亡发生率。该值是从时间 $0$ 到时间 $t$ 的估计转移概率矩阵的 $(0,2)$ 项。时间以天为单位，您必须将最终结果表示为小数（而非百分比）。您可以假设在任何给定时间，一个个体最多经历一次转移，并且转移时间被精确记录（不同个体之间可能存在时间重合）。删失时间是精确的，意味着个体在删失时间之后便不再被观察；在删失时间之前瞬间，他们仍被视为在观察中。\n\n您的程序必须处理以下测试用例套件，每个用例包含一组个体的转移和删失时间，以及一个评估时间 $t_{\\text{end}}$。对于每个用例，计算截至 $t_{\\text{end}}$ 的累积死亡发生率，即在时间 $0$ 处于状态 $0$ 的条件下，在时间 $t_{\\text{end}}$ 处于状态 $2$ 的估计概率。\n\n每个案例中使用的数据集的表示规则：\n- 每个个体由一个转移列表表示，每次转移表示为 $(\\text{time}, \\text{new\\_state})$，其中 $\\text{time} \\ge 0$ 且 $\\text{new\\_state} \\in \\{0,1,2\\}$，以及一个可选的删失时间 $c \\ge 0$ 或 $\\text{None}$。所有个体在时间 $0$ 时均从状态 $0$ 开始。转移列表在时间上是严格递增的，并且对于每个个体，在任何给定时间最多包含一次转移。如果给定了删失时间 $c$，则该个体在时间 $c$（含）之前都在观察中，在 $c$ 之后则严格不再被观察。\n\n测试套件：\n- 案例 1 (一般混合转移和删失):\n  - 个体:\n    - 个体 1: 转移 $\\{(1.5, 1), (4.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 2: 转移 $\\{(3.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 3: 转移 $\\{(2.0, 1)\\}$，删失 $5.0$。\n    - 个体 4: 转移 $\\{\\}$，删失 $6.0$。\n    - 个体 5: 转移 $\\{(5.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 6: 转移 $\\{(1.0, 1), (3.5, 2)\\}$，删失 $\\text{None}$。\n  - 评估时间: $t_{\\text{end}} = 5.0$ 天。\n- 案例 2 (边界情况：评估时间前无死亡):\n  - 个体:\n    - 个体 1: 转移 $\\{(1.0, 1)\\}$，删失 $4.0$。\n    - 个体 2: 转移 $\\{(3.0, 1)\\}$，删失 $3.5$。\n    - 个体 3: 转移 $\\{\\}$，删失 $2.0$。\n    - 个体 4: 转移 $\\{\\}$，删失 $4.0$。\n  - 评估时间: $t_{\\text{end}} = 4.0$ 天。\n- 案例 3 (边缘情况：同时直接死亡):\n  - 个体:\n    - 个体 1: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 2: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 3: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 4: 转移 $\\{(2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 5: 转移 $\\{\\}$，删失 $3.0$。\n    - 个体 6: 转移 $\\{\\}$，删失 $1.0$。\n  - 评估时间: $t_{\\text{end}} = 2.0$ 天。\n- 案例 4 (时间重合与混合路径):\n  - 个体:\n    - 个体 1: 转移 $\\{(1.0, 1), (2.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 2: 转移 $\\{(1.0, 1)\\}$，删失 $1.5$。\n    - 个体 3: 转移 $\\{(1.0, 2)\\}$，删失 $\\text{None}$。\n    - 个体 4: 转移 $\\{\\}$，删失 $3.0$。\n    - 个体 5: 转移 $\\{\\}$，删失 $\\text{None}$。\n    - 个体 6: 转移 $\\{(1.0, 1)\\}$，删失 $\\text{None}$。\n  - 评估时间: $t_{\\text{end}} = 2.0$ 天。\n\n算法要求：\n- 从所有个体的转移时间中构建截至 $t_{\\text{end}}$ 的不同事件时间的集合。\n- 对于每个事件时间 $t$：\n  - 计算 $Y_r(t)$（对于 $r \\in \\{0,1,2\\}$），即在 $t$ 之前瞬间处于状态 $r$ 且在观察中的个体数量。\n  - 对于每个允许的对 $(r,s)$（其中 $r \\ne s$），计算在 $t$ 时刻发生的转移数量 $dN_{rs}(t)$。\n  - 构建 $3 \\times 3$ 的增量矩阵 $d\\hat{\\mathbf A}(t)$，其非对角线项为 $d\\hat A_{rs}(t) = dN_{rs}(t) / Y_r(t)$（如果 $Y_r(t) > 0$，否则为 $0$），对角线项为 $d\\hat A_{rr}(t) = - \\sum_{s \\ne r} d\\hat A_{rs}(t)$。\n  - 通过乘积积分 $\\hat{\\mathbf P}(0,t) = \\hat{\\mathbf P}(0,t^{-}) \\cdot \\left(\\mathbf I + d\\hat{\\mathbf A}(t)\\right)$ 更新估计的转移概率矩阵，初始值为 $\\hat{\\mathbf P}(0,0) = \\mathbf I$。\n- 处理完截至 $t_{\\text{end}}$ 的所有事件时间后，提取 $\\hat{\\mathbf P}(0,t_{\\text{end}})$ 的 $(0,2)$ 项作为累积死亡发生率。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为方括号内的逗号分隔列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是按案例指定的 $t_{\\text{end}}$（以天为单位）计算的累积死亡发生率的小数估计值。\n\n所有时间必须以天为单位处理，所有输出必须是小数（不是分数或百分比）。通过完全按照规定正确处理风险人群、时间重合和右删失，确保科学真实性。",
            "solution": "该问题陈述经评估有效。它在科学上基于多状态模型和事件史分析的既定统计理论。该问题是适定的，提供了明确的目标、所有必要的数据，以及一套基于 Aalen–Johansen 估计量 (AJE) 的完整定义和算法要求。其表述是客观的、数学上严谨的，并且没有模糊或矛盾之处。\n\n任务是为一个从‘健康’状态开始的个体队列，计算截至特定时间 $t_{\\text{end}}$ 的累积死亡发生率。这对应于在一个分别代表‘健康’、‘患病’和‘死亡’的三状态模型 $\\{0, 1, 2\\}$ 中估计转移概率 $P_{02}(0, t_{\\text{end}})$。Aalen-Johansen 估计量提供了整个转移概率矩阵 $\\mathbf{P}(s, t)$ 的非参数估计，该矩阵包含概率 $P_{ij}(s, t) = \\mathbb{P}(\\text{在时间 } s \\text{ 状态为 } i \\text{ 的条件下，在时间 } t \\text{ 状态为 } j)$。\n\n该估计量被构建为累积转移强度矩阵 $\\mathbf{\\Lambda}(t)$ 的乘积积分。对于具有离散事件时间的面板数据，此乘积积分变为对观察到的事件时间的有限乘积。从时间 $0$ 到时间 $t$ 的估计转移概率矩阵，记为 $\\hat{\\mathbf{P}}(0, t)$，是迭代计算的。从 $\\hat{\\mathbf{P}}(0, 0) = \\mathbf{I}$（单位矩阵）开始，对于每个不同的事件时间 $\\tau_j > 0$，矩阵更新如下：\n$$\n\\hat{\\mathbf{P}}(0, \\tau_j) = \\hat{\\mathbf{P}}(0, \\tau_{j-1}) \\cdot (\\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j))\n$$\n其中 $\\tau_0 = 0$ 且 $\\hat{\\mathbf{P}}(0, \\tau_0) = \\mathbf{I}$。矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$ 表示在时间 $\\tau_j$ 累积转移强度矩阵的估计变化量。\n\n$3 \\times 3$ 矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$ 的项是基于计数过程定义的。对于每个可能从状态 $r$ 到状态 $s$ ($r \\neq s$) 的转移，非对角线项为：\n$$\nd\\hat{A}_{rs}(\\tau_j) = \\frac{dN_{rs}(\\tau_j)}{Y_r(\\tau_j)}\n$$\n此处，$dN_{rs}(\\tau_j)$ 是在时间 $\\tau_j$ 恰好观察到从状态 $r$ 转移到状态 $s$ 的个体数量。$Y_r(\\tau_j)$ 是在时间 $\\tau_j$ 之前瞬间处于状态 $r$ 且在观察中（即未被删失）的个体数量。如果风险人群 $Y_r(\\tau_j)$ 为零，则 $d\\hat{A}_{rs}(\\tau_j)$ 定义为 $0$。\n\n对角线项的定义是为了确保矩阵 $(\\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j))$ 的列和为 $1$，这保证了 $\\hat{\\mathbf{P}}$ 保持为一个随机矩阵（行和为 $1$）。这是通过设置以下项实现的：\n$$\nd\\hat{A}_{rr}(\\tau_j) = - \\sum_{s \\neq r} d\\hat{A}_{rs}(\\tau_j)\n$$\n对于吸收态 $2$，所有源于它的转移强度都为零，因此 $d\\hat{\\mathbf{A}}(\\tau_j)$ 的第三行始终是零向量。\n\n解决该问题的算法如下：\n1.  **识别事件时间**：从所有个体提供的数据中，编译所有小于或等于指定评估时间 $t_{\\text{end}}$ 的唯一转移时间的集合。按升序对这些时间进行排序：$\\tau_1  \\tau_2  \\dots  \\tau_K$。\n2.  **初始化**：将初始转移概率矩阵设置为 $3 \\times 3$ 的单位矩阵，$\\hat{\\mathbf{P}}(0, 0) = \\mathbf{I}$。\n3.  **遍历事件时间**：对于排序列表中的每个事件时间 $\\tau_j$：\n    a. **确定风险集**：对于每个非吸收态 $r \\in \\{0, 1\\}$，确定风险计数 $Y_r(\\tau_j)$。这涉及遍历所有个体，根据他们的转移历史确定其在 $\\tau_j$ 之前瞬间的状态，并检查他们的观察期（未因删失而终止）是否延伸到 $\\tau_j$。\n    b. **统计转移数量**：对于每种允许的转移类型（$0 \\to 1$, $0 \\to 2$, $1 \\to 2$），统计在时间 $\\tau_j$ 恰好进行特定转移 $r \\to s$ 的个体数量 $dN_{rs}(\\tau_j)$。\n    c. **构建增量矩阵**：使用 $d\\hat{A}_{rs}(\\tau_j)$ 和 $d\\hat{A}_{rr}(\\tau_j)$ 的公式构建矩阵 $d\\hat{\\mathbf{A}}(\\tau_j)$。\n    d. **更新概率矩阵**：计算更新矩阵 $\\mathbf{M}_j = \\mathbf{I} + d\\hat{\\mathbf{A}}(\\tau_j)$。然后，通过矩阵乘法更新估计值：$\\hat{\\mathbf{P}}(0, \\tau_j) = \\hat{\\mathbf{P}}(0, \\tau_{j-1}) \\cdot \\mathbf{M}_j$。\n4.  **提取最终结果**：遍历完截至 $\\tau_K$ 的所有事件时间后，得到的矩阵 $\\hat{\\mathbf{P}}(0, \\tau_K)$ 即为估计值 $\\hat{\\mathbf{P}}(0, t_{\\text{end}})$。累积死亡发生率是该矩阵的 $(0, 2)$ 项（使用基于 0 的索引），即 $\\hat{P}_{02}(0, t_{\\text{end}})$。\n\n此过程正确处理了时间重合的事件（通过在一步中计算所有同时发生的转移）和右删失（通过在删失时间后将删失个体从风险集中排除）。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    # Representation of test cases:\n    # Each case is a tuple: (individuals, t_end)\n    # Each individual is a tuple: (transitions, censoring_time)\n    # transitions is a list of tuples: (time, new_state)\n    # censoring_time is a float or None.\n    test_cases = [\n        # Case 1\n        (\n            [\n                ([(1.5, 1), (4.0, 2)], None),\n                ([(3.0, 2)], None),\n                ([(2.0, 1)], 5.0),\n                ([], 6.0),\n                ([(5.0, 2)], None),\n                ([(1.0, 1), (3.5, 2)], None),\n            ],\n            5.0\n        ),\n        # Case 2\n        (\n            [\n                ([(1.0, 1)], 4.0),\n                ([(3.0, 1)], 3.5),\n                ([], 2.0),\n                ([], 4.0),\n            ],\n            4.0\n        ),\n        # Case 3\n        (\n            [\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([(2.0, 2)], None),\n                ([], 3.0),\n                ([], 1.0),\n            ],\n            2.0\n        ),\n        # Case 4\n        (\n            [\n                ([(1.0, 1), (2.0, 2)], None),\n                ([(1.0, 1)], 1.5),\n                ([(1.0, 2)], None),\n                ([], 3.0),\n                ([], None),\n                ([(1.0, 1)], None),\n            ],\n            2.0\n        ),\n    ]\n\n    results = []\n    for individuals, t_end in test_cases:\n        result = compute_cumulative_incidence(individuals, t_end)\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.12f}'.rstrip('0').rstrip('.') if '.' in f'{r:.12f}' else str(r) for r in results)}]\")\n\ndef compute_cumulative_incidence(individuals_raw, t_end):\n    \"\"\"\n    Computes the cumulative incidence to death by t_end using the Aalen-Johansen estimator.\n\n    Args:\n        individuals_raw: A list of individuals, where each is a tuple of\n                         (list of transitions, censoring time).\n        t_end: The evaluation time.\n\n    Returns:\n        The estimated cumulative incidence to death (P_02) as a float.\n    \"\"\"\n    # Pre-process data for easier access\n    individuals = []\n    all_transition_times = set()\n    for transitions, censoring_time in individuals_raw:\n        # Convert list of transitions to a dictionary for faster lookups\n        trans_dict = {t: s for t, s in transitions}\n        # Use infinity for non-censored individuals\n        c_time = censoring_time if censoring_time is not None else float('inf')\n        individuals.append({'transitions': trans_dict, 'censoring_time': c_time})\n        for t in trans_dict.keys():\n            all_transition_times.add(t)\n\n    # Get unique, sorted event times up to t_end\n    event_times = sorted([t for t in all_transition_times if t = t_end])\n\n    # Initialize the transition probability matrix P(0, t)\n    p_hat = np.identity(3)\n\n    for t_event in event_times:\n        # At-risk counts Y_r(t) for r in {0, 1}\n        y = {0: 0, 1: 0}\n        # Transition counts dN_rs(t)\n        dn = {(0, 1): 0, (0, 2): 0, (1, 2): 0}\n\n        for p_idx, p_data in enumerate(individuals):\n            # An individual is under observation if the event time is not strictly after their censoring time.\n            if t_event > p_data['censoring_time']:\n                continue\n\n            # Determine the individual's state just prior to t_event\n            current_state = 0\n            # Get transition times before the current event time\n            trans_before = [t for t in p_data['transitions'] if t  t_event]\n            if trans_before:\n                last_trans_time = max(trans_before)\n                current_state = p_data['transitions'][last_trans_time]\n\n            # If in an absorbing state, they are no longer at risk for transitions\n            if current_state == 2:\n                continue\n\n            # Add to at-risk set\n            y[current_state] += 1\n            \n            # Check for a transition at t_event\n            if t_event in p_data['transitions']:\n                new_state = p_data['transitions'][t_event]\n                transition = (current_state, new_state)\n                if transition in dn:\n                    dn[transition] += 1\n\n        # Construct the increment matrix d_A_hat\n        d_a_hat = np.zeros((3, 3))\n        \n        if y[0] > 0:\n            d_a_hat[0, 1] = dn[(0, 1)] / y[0]\n            d_a_hat[0, 2] = dn[(0, 2)] / y[0]\n        \n        if y[1] > 0:\n            d_a_hat[1, 2] = dn[(1, 2)] / y[1]\n\n        # Set diagonal elements\n        d_a_hat[0, 0] = -(d_a_hat[0, 1] + d_a_hat[0, 2])\n        d_a_hat[1, 1] = -d_a_hat[1, 2]\n        # State 2 is absorbing, so d_a_hat[2,:] is all zeros.\n\n        # Update P_hat via product integral step\n        update_matrix = np.identity(3) + d_a_hat\n        p_hat = p_hat @ update_matrix\n\n    # The result is the (0, 2) entry of the final P_hat matrix\n    return p_hat[0, 2]\n\nsolve()\n```"
        },
        {
            "introduction": "多状态模型的一个关键应用是为患者提供动态和个性化的未来病程预测。这通常涉及求解时变马尔可夫模型的 Kolmogorov 向前方程，其中转移率因协变量变化或时变基线风险而随时间改变。通过这个练习 ()，您将学习如何在转移强度分段恒定的区间上进行积分，以计算未来的状态概率，这是构建实时临床决策支持工具的一项核心技能。",
            "id": "4975749",
            "problem": "考虑一个用于疾病进展的连续时间多状态模型，该模型具有三个状态：$1$ (健康)、$2$ (患病) 和 $3$ (死亡)。假设这是一个时间非齐次的连续时间马尔可夫链 (CTMC)，其中在时间 $t$、协变量值为 $X(t)$ 时，从状态 $i$ 到状态 $j$ 的转移强度由对数线性模型 $ \\lambda_{ij}(t) = \\lambda_{ij,0}(t) \\exp\\big(\\beta_{ij} X(t)\\big) $ 给出（对于 $i \\neq j$），且 $ \\lambda_{ii}(t) \\equiv 0 $。协变量 $X(t)$ 是一个标量的、随时间分段常数的函数。基线风险 $ \\lambda_{ij,0}(t) $ 是随时间分段常数的函数，具体如下所述。生成元矩阵 $Q(t)$ 的非对角线元素为 $ q_{ij}(t) = \\lambda_{ij}(t) $，对角线元素为 $ q_{ii}(t) = -\\sum_{j \\neq i} \\lambda_{ij}(t) $。状态 $3$ 是吸收态，因此 $ q_{33}(t) = 0 $ 且对于所有 $j \\neq 3$ 都有 $ q_{3j}(t) = 0 $。\n\n时间以月为单位，强度以“月”的倒数为单位。你的任务是，从时间 $t$ 的指定状态分布 $ \\pi(t) $ 出发，通过求解生成元 $Q(\\cdot)$ 在下述假设和数据下所蕴含的前向动力学，来计算在时间范围 $t+h$ 时处于各个状态的动态预测概率。所有报告的概率必须以十进制小数表示，并四舍五入到 $6$ 位小数。不涉及角度。计算必须通过适当地处理由分段常数的基线风险和分段常数的协变量路径引起的时间依赖性来执行。\n\n允许的转移 $1 \\to 2$、$1 \\to 3$ 和 $2 \\to 3$ 的基线风险函数 $ \\lambda_{ij,0}(t) $ (单位：月分之一) 使用在 $t \\in \\{0,2,5\\}$ 月的断点定义如下：\n- 对于 $ t \\in [0,2) $：\n  - $ \\lambda_{12,0}(t) = 0.03 $\n  - $ \\lambda_{13,0}(t) = 0.00 $\n  - $ \\lambda_{23,0}(t) = 0.04 $\n- 对于 $ t \\in [2,5) $：\n  - $ \\lambda_{12,0}(t) = 0.05 $\n  - $ \\lambda_{13,0}(t) = 0.02 $\n  - $ \\lambda_{23,0}(t) = 0.06 $\n- 对于 $ t \\ge 5 $：\n  - $ \\lambda_{12,0}(t) = 0.08 $\n  - $ \\lambda_{13,0}(t) = 0.04 $\n  - $ \\lambda_{23,0}(t) = 0.09 $\n\n协变量效应的回归系数 $ \\beta_{ij} $ 为：\n- $ \\beta_{12} = 0.7 $\n- $ \\beta_{13} = 1.0 $\n- $ \\beta_{23} = 0.5 $\n\n协变量路径 $ X(t) $ 是分段常数的，将在下面的每个测试案例中具体说明。\n\n通过求解从时间 $t$ 到时间 $t+h$ 的前向动力学，计算每个测试案例的状态占据概率向量 $ \\pi(t+h) $，同时考虑协变量路径和基线风险分段的变化。你必须确保解尊重状态 $3$ 的吸收性质，并与模型定义一致。时间以月表示，强度以月分之一表示。将 $ \\pi(t+h) $ 的每个分量四舍五入到 $6$ 位小数。\n\n测试套件 (每个案例提供 $t$、$h$、$ \\pi(t) $，以及作为由断点和值定义的分段常数函数的协变量路径 $X(t)$)：\n- 案例 1：\n  - $ t = 3 $\n  - $ h = 2 $\n  - $ \\pi(t) = [1.0, 0.0, 0.0] $\n  - 协变量路径：断点 $ [0.0, 4.0] $，值 $ [0.0, 1.0] $，表示对于 $ t \\in [0,4) $，$ X(t) = 0 $；对于 $ t \\ge 4 $，$ X(t) = 1 $。\n- 案例 2 (边界条件)：\n  - $ t = 5 $\n  - $ h = 0 $\n  - $ \\pi(t) = [0.0, 1.0, 0.0] $\n  - 协变量路径：断点 $ [0.0, 4.0] $，值 $ [0.0, 1.0] $。\n- 案例 3 (非退化的初始分布)：\n  - $ t = 6 $\n  - $ h = 3 $\n  - $ \\pi(t) = [0.6, 0.4, 0.0] $\n  - 协变量路径：断点 $ [0.0] $，值 $ [1.0] $，表示 $ X(t) \\equiv 1 $。\n- 案例 4 (边缘案例，初始时 $1 \\to 3$ 的基线风险为零)：\n  - $ t = 1 $\n  - $ h = 1.5 $\n  - $ \\pi(t) = [1.0, 0.0, 0.0] $\n  - 协变量路径：断点 $ [0.0] $，值 $ [0.0] $，表示 $ X(t) \\equiv 0 $。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试案例的结果是表示状态 $[1,2,3]$ 的 $ \\pi(t+h) $ 的三个四舍五入小数的列表。例如，输出格式为 $ [[p_{1,1},p_{1,2},p_{1,3}],[p_{2,1},p_{2,2},p_{2,3}],\\ldots] $，其中每个 $p_{k,i}$ 都四舍五入到 $6$ 位小数。",
            "solution": "用户提供的问题已经过严格验证，并被确定为是合理的。这是一个在医学数据统计建模领域中提法明确、有科学依据的问题。该问题要求计算时间非齐次连续时间马尔可夫链 (CTMC) 中的未来状态概率，这是使用多状态模型进行动态预测的一项标准任务。\n\n该解决方案的理论基础是 Kolmogorov 前向方程，它控制着状态占据概率向量 $\\pi(t)$ 随时间的演化：\n$$\n\\frac{d}{dt}\\pi(t) = \\pi(t) Q(t)\n$$\n在此，$\\pi(t) = [\\pi_1(t), \\pi_2(t), \\pi_3(t)]$ 是一个行向量，表示在时间 $t$ 处于各个状态的概率，而 $Q(t)$ 是在时间 $t$ 的转移强度矩阵，或称生成元矩阵。\n\n从时间 $s$ 到未来时间 $u$ 的预测解由以下公式给出：\n$$\n\\pi(u) = \\pi(s) P(s, u)\n$$\n其中 $P(s, u)$ 是转移概率矩阵。其元素 $P_{ij}(s,u)$ 表示在时间 $s$ 处于状态 $i$ 的条件下，在时间 $u$ 处于状态 $j$ 的概率。\n\n问题指出，基线风险 $\\lambda_{ij,0}(t)$ 和协变量路径 $X(t)$ 都是分段常数的。因此，转移强度 $\\lambda_{ij}(t) = \\lambda_{ij,0}(t) \\exp(\\beta_{ij} X(t))$ 也是分段常数的，这意味着生成元矩阵 $Q(t)$ 是分段常数的。\n\n设我们感兴趣的时间区间为 $[t, t+h]$。我们必须找出此区间内所有使生成元矩阵 $Q(\\cdot)$ 值发生变化的时间点。这些断点源于分段常数基线风险的定义（在时间 $2$ 和 $5$）以及分段常数的协变量路径（每个测试案例特定）。让我们将起始时间 $t$、结束时间 $t+h$ 以及两者之间的任何断点组成的排序后唯一时间点集合表示为 $\\tau_0, \\tau_1, \\dots, \\tau_K$，其中 $\\tau_0 = t$ 且 $\\tau_K = t+h$。\n\n在任何子区间 $[\\tau_k, \\tau_{k+1})$ 内，生成元矩阵是恒定的。我们用 $Q_k$ 表示这个常数矩阵。对于这样一个具有常数生成元 $Q_k$ 和时长 $\\Delta\\tau_k = \\tau_{k+1} - \\tau_k$ 的子区间，转移概率矩阵由矩阵指数给出：\n$$\nP(\\tau_k, \\tau_{k+1}) = \\exp(\\Delta\\tau_k \\cdot Q_k)\n$$\n其中矩阵指数 $\\exp(A)$ 由其泰勒级数 $\\sum_{n=0}^{\\infty} \\frac{A^n}{n!}$ 定义。\n\n在整个时间范围 $[t, t+h]$ 上的总转移概率矩阵，是通过利用 Chapman-Kolmogorov 属性，按时间顺序将每个子区间的矩阵相乘得到的：\n$$\nP(t, t+h) = P(\\tau_0, \\tau_1) \\cdot P(\\tau_1, \\tau_2) \\cdot \\ldots \\cdot P(\\tau_{K-1}, \\tau_K) = \\prod_{k=0}^{K-1} \\exp\\big((\\tau_{k+1} - \\tau_k) Q_k\\big)\n$$\n\n最终的状态概率向量通过将初始概率向量 $\\pi(t)$ 与这个总转移矩阵相乘来计算：\n$$\n\\pi(t+h) = \\pi(t) \\cdot P(t, t+h)\n$$\n\n每个测试案例的步骤如下：\n1.  定义预测区间 $[t, t+h]$。\n2.  汇集来自基线风险函数和给定协变量路径的、位于 $(t, t+h)$ 内的所有断点。创建一个从 $t$ 开始到 $t+h$ 结束的排序时间点序列 $\\tau_0, \\tau_1, \\dots, \\tau_K$。\n3.  初始化一个总转移矩阵 $P_{total}$ 为 $3 \\times 3$ 的单位矩阵 $I$。\n4.  对于 $k=0, \\dots, K-1$，遍历子区间 $[\\tau_k, \\tau_{k+1})$：\n    a.  在子区间内选择一个代表性时间点，例如中点 $\\bar{\\tau} = (\\tau_k + \\tau_{k+1})/2$。\n    b.  确定此区间内 $\\lambda_{ij,0}(\\bar{\\tau})$ 和 $X(\\bar{\\tau})$ 的常数值。\n    c.  构建生成元矩阵 $Q_k$。允许的转移是 $1 \\to 2$、$1 \\to 3$ 和 $2 \\to 3$。状态 $3$ 是吸收态。该矩阵的形式为：\n        $$\n        Q_k = \\begin{pmatrix} -\\big(\\lambda_{12}(\\bar{\\tau}) + \\lambda_{13}(\\bar{\\tau})\\big)  \\lambda_{12}(\\bar{\\tau})  \\lambda_{13}(\\bar{\\tau}) \\\\ 0  -\\lambda_{23}(\\bar{\\tau})  \\lambda_{23}(\\bar{\\tau}) \\\\ 0  0  0 \\end{pmatrix}\n        $$\n    d.  使用数值库函数计算矩阵指数，从而计算子区间的转移矩阵 $P_k = \\exp\\big((\\tau_{k+1}-\\tau_k) \\cdot Q_k\\big)$。\n    e.  更新总转移矩阵：$P_{total} = P_{total} \\cdot P_k$。注意矩阵乘法不满足交换律。在 Python 中使用 NumPy，这表示为 `P_total = P_total @ P_k`。\n5.  遍历所有子区间后，计算最终的概率向量：$\\pi(t+h) = \\pi(t) \\cdot P_{total}$。\n6.  按要求将所得向量的每个元素四舍五入到 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves for the state occupancy probabilities in a continuous-time multi-state\n    disease progression model.\n    \"\"\"\n    \n    # Model parameters\n    BETA_COEFFICIENTS = {\n        '12': 0.7,\n        '13': 1.0,\n        '23': 0.5\n    }\n\n    # Baseline hazard piecewise definition\n    # Structure: (end_time, {transition: hazard_value})\n    BASELINE_HAZARDS_DEF = [\n        (2.0, {'12': 0.03, '13': 0.00, '23': 0.04}),\n        (5.0, {'12': 0.05, '13': 0.02, '23': 0.06}),\n    ]\n    # Hazard for t = 5.0\n    BASELINE_HAZARDS_FINAL = {'12': 0.08, '13': 0.04, '23': 0.09}\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        {'t': 3, 'h': 2, 'pi_t': [1.0, 0.0, 0.0], 'x_path': ([0.0, 4.0], [0.0, 1.0])},\n        {'t': 5, 'h': 0, 'pi_t': [0.0, 1.0, 0.0], 'x_path': ([0.0, 4.0], [0.0, 1.0])},\n        {'t': 6, 'h': 3, 'pi_t': [0.6, 0.4, 0.0], 'x_path': ([0.0], [1.0])},\n        {'t': 1, 'h': 1.5, 'pi_t': [1.0, 0.0, 0.0], 'x_path': ([0.0], [0.0])},\n    ]\n\n    def get_baseline_hazards(time_point):\n        \"\"\"Returns baseline hazards (lambda_12,0, lambda_13,0, lambda_23,0) for a given time.\"\"\"\n        for t_end, hazards in BASELINE_HAZARDS_DEF:\n            if time_point  t_end:\n                return hazards['12'], hazards['13'], hazards['23']\n        return BASELINE_HAZARDS_FINAL['12'], BASELINE_HAZARDS_FINAL['13'], BASELINE_HAZARDS_FINAL['23']\n\n    def get_covariate_value(time_point, x_path):\n        \"\"\"Returns the covariate value X(t) for a given time and piecewise path.\"\"\"\n        breakpoints, values = x_path\n        # np.searchsorted finds the index where an element should be inserted to maintain order.\n        # 'right' side ensures that at a breakpoint, we take the value of the new interval.\n        idx = np.searchsorted(breakpoints, time_point, side='right') - 1\n        return values[idx]\n\n    def construct_q_matrix(time_point, x_path):\n        \"\"\"Constructs the generator matrix Q for a given time and covariate path.\"\"\"\n        l12_0, l13_0, l23_0 = get_baseline_hazards(time_point)\n        x_val = get_covariate_value(time_point, x_path)\n        \n        # Calculate transition intensities lambda_ij(t)\n        l12 = l12_0 * np.exp(BETA_COEFFICIENTS['12'] * x_val)\n        l13 = l13_0 * np.exp(BETA_COEFFICIENTS['13'] * x_val)\n        l23 = l23_0 * np.exp(BETA_COEFFICIENTS['23'] * x_val)\n        \n        # Construct the 3x3 generator matrix Q\n        Q = np.array([\n            [-(l12 + l13), l12, l13],\n            [0, -l23, l23],\n            [0, 0, 0]\n        ])\n        return Q\n\n    def compute_final_probabilities(t, h, pi_t, x_path):\n        \"\"\"\n        Computes the state probability vector pi(t+h) by solving the forward dynamics.\n        \"\"\"\n        if h == 0:\n            return np.round(pi_t, 6).tolist()\n            \n        t_start = t\n        t_end = t + h\n        \n        # Collect all unique breakpoints within the prediction interval (t, t+h)\n        baseline_breakpoints = [bp for bp, _ in BASELINE_HAZARDS_DEF]\n        covariate_breakpoints = x_path[0]\n        \n        all_breakpoints = sorted(list(set(\n            [bp for bp in baseline_breakpoints if t_start  bp  t_end] +\n            [bp for bp in covariate_breakpoints if t_start  bp  t_end]\n        )))\n        \n        time_points = [t_start] + all_breakpoints + [t_end]\n        \n        # Initialize total transition probability matrix to identity\n        P_total = np.identity(3)\n        \n        # Iterate over sub-intervals where Q is constant\n        for i in range(len(time_points) - 1):\n            tau_start = time_points[i]\n            tau_end = time_points[i+1]\n            delta_tau = tau_end - tau_start\n            \n            # Use midpoint of interval to determine constant Q\n            tau_mid = (tau_start + tau_end) / 2\n            \n            Q = construct_q_matrix(tau_mid, x_path)\n            \n            # Compute transition matrix for the sub-interval\n            P_interval = expm(delta_tau * Q)\n            \n            # Update total transition matrix\n            P_total = P_total @ P_interval\n            \n        # Compute final probability vector\n        pi_t_h = np.array(pi_t) @ P_total\n        \n        return np.round(pi_t_h, 6).tolist()\n\n    results = []\n    for case in test_cases:\n        result = compute_final_probabilities(case['t'], case['h'], case['pi_t'], case['x_path'])\n        results.append(result)\n\n    # Format the output string as per requirements\n    # e.g., [[p1,p2,p3],[q1,q2,q3],...]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在许多疾病研究中，患者可能面临多种相互竞争的结局事件（例如，死于不同原因），这构成了“竞争风险”问题。处理这一问题存在两种主流建模框架：原因别风险 (cause-specific hazards, CSH) 模型和子分布风险 (subdistribution hazards, Fine-Gray) 模型，它们回答不同的科学问题且结果的解释也不同。本练习 () 要求您同时计算这两种模型的预测结果并进行比较，这将帮助您辨析它们之间关键的概念差异，并为您在未来的研究中选择合适的模型提供实践基础。",
            "id": "4975715",
            "problem": "考虑一个具有一个初始状态和两个吸收态的多状态疾病进展模型，该模型处于竞争风险下。设初始状态表示为状态 $0$，吸收态（两种不同的失败原因）表示为状态 $1$ 和 $2$。个体在时间 $t = 0$ 时从状态 $0$ 开始。仅有基线协变量可用。假设存在单个基线协变量 $x \\in \\mathbb{R}$，时间以年为单位。风险率以 年$^{-1}$ 表示。概率必须以小数形式报告。目标是，在指定的随访时间 $t$，使用特定原因风险模型计算原因 1 的特定原因累积发生率，并使用 Fine–Gray 子分布风险模型进行替代预测，然后比较这两种预测。\n\n使用以下基本原理：\n- 对于原因 $j \\in \\{1,2\\}$，特定原因风险由 $\\lambda_j(t \\mid x)$ 定义，总生存函数为 $S(t \\mid x) = \\exp\\!\\left(-\\int_0^t \\{\\lambda_1(u \\mid x) + \\lambda_2(u \\mid x)\\} \\,\\mathrm{d}u\\right)$。\n- 原因 1 的累积发生率函数 (CIF) 为 $F_1(t \\mid x) = \\int_0^t S(u \\mid x)\\,\\lambda_1(u \\mid x)\\,\\mathrm{d}u$。\n- 原因 1 的 Fine–Gray 子分布风险由 $h_1^{\\ast}(t \\mid x)$ 定义，并通过微分方程 $\\frac{\\mathrm{d}}{\\mathrm{d}t}F_1(t \\mid x) = h_1^{\\ast}(t \\mid x)\\{1 - F_1(t \\mid x)\\}$ 与 CIF 相关联。\n\n为实施计算所作的建模假设：\n- 特定原因风险不随时间变化，但通过对数线性模型依赖于 $x$：$\\lambda_j(t \\mid x) = \\lambda_{j0}\\,\\exp(\\beta_j x)$，其中 $j \\in \\{1,2\\}$，常数 $\\lambda_{j0} \\ge 0$ 且 $\\beta_j \\in \\mathbb{R}$。\n- 原因 1 的 Fine–Gray 子分布风险遵循比例子分布风险模型：$h_1^{\\ast}(t \\mid x) = h_{10}^{\\ast}(t)\\,\\exp(\\gamma x)$，其中基线子分布风险 $h_{10}^{\\ast}(t)$ 是分段常数：\n  - 在 $[0,2)$ 年区间，$h_{10}^{\\ast}(t) = 0.04$ 年$^{-1}$。\n  - 在 $[2,5)$ 年区间，$h_{10}^{\\ast}(t) = 0.025$ 年$^{-1}$。\n  - 在 $[5,\\infty)$ 年区间，$h_{10}^{\\ast}(t) = 0.01$ 年$^{-1}$。\n\n每个测试用例的任务：\n1. 根据特定原因风险的定义，使用上述常数风险模型，计算原因 1 的累积发生率 $F_1(t \\mid x)$。\n2. 使用给定的分段基线 $h_{10}^{\\ast}(t)$ 和比例子分布风险模型，计算在指定时间 $t$ 的 Fine–Gray 子分布风险 $h_1^{\\ast}(t \\mid x)$。\n3. 仅使用给定的基线子分布风险计划和 $\\gamma$，计算由子分布风险模型所蕴含的基于 Fine–Gray 的累积发生率 $F_1^{\\mathrm{FG}}(t \\mid x)$。\n4. 计算绝对差 $\\Delta(t \\mid x) = \\left|F_1(t \\mid x) - F_1^{\\mathrm{FG}}(t \\mid x)\\right|$。\n\n所有时间必须以年为单位提供，风险以年$^{-1}$为单位，CIF 值以小数形式（无单位）提供。您的程序应生成单行输出，其中包含一个用方括号括起的逗号分隔列表。每个测试用例的结果必须是一个包含四个浮点数的列表，顺序完全按照：$[F_1(t \\mid x), h_1^{\\ast}(t \\mid x), F_1^{\\mathrm{FG}}(t \\mid x), \\Delta(t \\mid x)]$。顶层输出必须是这些逐测试用例列表的列表；例如：$[[a_1,b_1,c_1,d_1],[a_2,b_2,c_2,d_2],\\dots]$。\n\n测试套件（五个案例，旨在覆盖一般情况、时间边界、移除竞争原因、对称性和高风险）：\n- 案例 $1$：$\\lambda_{10} = 0.12$, $\\lambda_{20} = 0.08$, $\\beta_1 = 0.5$, $\\beta_2 = -0.2$, $x = 1.0$, $t = 3.0$, $\\gamma = 0.4$。\n- 案例 $2$（时间边界）：$\\lambda_{10} = 0.12$, $\\lambda_{20} = 0.08$, $\\beta_1 = 0.5$, $\\beta_2 = -0.2$, $x = 0.0$, $t = 0.0$, $\\gamma = 0.3$。\n- 案例 $3$（无竞争风险）：$\\lambda_{10} = 0.15$, $\\lambda_{20} = 0.0$, $\\beta_1 = 0.0$, $\\beta_2 = 0.0$, $x = 2.0$, $t = 5.0$, $\\gamma = 0.1$。\n- 案例 $4$（基线风险对称）：$\\lambda_{10} = 0.05$, $\\lambda_{20} = 0.05$, $\\beta_1 = 0.3$, $\\beta_2 = 0.3$, $x = -1.0$, $t = 10.0$, $\\gamma = -0.5$。\n- 案例 $5$（高风险协变量和长随访）：$\\lambda_{10} = 0.2$, $\\lambda_{20} = 0.15$, $\\beta_1 = 0.8$, $\\beta_2 = 0.1$, $x = 3.0$, $t = 8.0$, $\\gamma = 0.6$。\n\n您的程序必须为每个案例计算指定的量，并打印单行输出：一个用方括号括起的逗号分隔列表，其中包含按指定顺序和单位排列的每个案例的四个浮点数列表。",
            "solution": "我们从具有两个原因的竞争风险的基本定义开始。设特定原因风险函数为 $\\lambda_1(t \\mid x)$ 和 $\\lambda_2(t \\mid x)$，总生存函数为\n$$\nS(t \\mid x) = \\exp\\!\\left(-\\int_0^t \\{\\lambda_1(u \\mid x) + \\lambda_2(u \\mid x)\\} \\,\\mathrm{d}u\\right).\n$$\n根据定义，原因 1 的累积发生率函数 (Cumulative Incidence Function (CIF)) 是\n$$\nF_1(t \\mid x) = \\int_0^t S(u \\mid x)\\,\\lambda_1(u \\mid x)\\,\\mathrm{d}u.\n$$\n在特定原因风险不随时间变化，但通过对数线性形式 $\\lambda_j(t \\mid x) = \\lambda_{j0}\\,\\exp(\\beta_j x)$ (其中 $j \\in \\{1,2\\}$) 依赖于基线协变量 $x$ 的建模假设下，积分得以简化，因为 $\\lambda_1(u \\mid x) + \\lambda_2(u \\mid x) = \\lambda_1(x) + \\lambda_2(x)$ 对 $u$ 而言是常数，这里我们定义\n$$\n\\lambda_1(x) := \\lambda_{10}\\,\\exp(\\beta_1 x), \\quad \\lambda_2(x) := \\lambda_{20}\\,\\exp(\\beta_2 x).\n$$\n因此，\n$$\nS(t \\mid x) = \\exp\\!\\left(-\\{\\lambda_1(x) + \\lambda_2(x)\\} t\\right).\n$$\n原因 1 的 CIF 变为\n$$\nF_1(t \\mid x) = \\int_0^t \\exp\\!\\left(-\\{\\lambda_1(x) + \\lambda_2(x)\\} u\\right)\\,\\lambda_1(x)\\,\\mathrm{d}u.\n$$\n计算此积分可得\n$$\nF_1(t \\mid x) = \\frac{\\lambda_1(x)}{\\lambda_1(x) + \\lambda_2(x)} \\left( 1 - \\exp\\!\\left(-\\{\\lambda_1(x) + \\lambda_2(x)\\} t \\right) \\right),\n$$\n并约定如果 $\\lambda_1(x) + \\lambda_2(x) = 0$，则对于所有 $t$，$F_1(t \\mid x) = 0$。\n\n接下来，我们考虑原因 1 的 Fine–Gray 子分布风险模型。Fine–Gray 子分布风险 $h_1^{\\ast}(t \\mid x)$ 通过将其与原因 1 CIF 联系起来的微分方程来定义：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}F_1(t \\mid x) = h_1^{\\ast}(t \\mid x)\\{1 - F_1(t \\mid x)\\}.\n$$\n在比例子分布风险模型下，我们假设\n$$\nh_1^{\\ast}(t \\mid x) = h_{10}^{\\ast}(t)\\,\\exp(\\gamma x),\n$$\n其中 $h_{10}^{\\ast}(t)$ 是基线子分布风险函数。上述微分方程是关于 $F_1(t \\mid x)$ 的一阶线性常微分方程，其解为\n$$\nF_1^{\\mathrm{FG}}(t \\mid x) = 1 - \\exp\\!\\left(-\\int_0^t h_1^{\\ast}(u \\mid x)\\,\\mathrm{d}u\\right) = 1 - \\exp\\!\\left(-\\exp(\\gamma x) \\int_0^t h_{10}^{\\ast}(u)\\,\\mathrm{d}u\\right).\n$$\n在本问题中，$h_{10}^{\\ast}(t)$ 是分段常数：\n- 在 $[0,2)$ 年区间，$h_{10}^{\\ast}(t) = 0.04$ 年$^{-1}$。\n- 在 $[2,5)$ 年区间，$h_{10}^{\\ast}(t) = 0.025$ 年$^{-1}$。\n- 在 $[5,\\infty)$ 年区间，$h_{10}^{\\ast}(t) = 0.01$ 年$^{-1}$。\n因此，到时间 $t$ 为止的累积基线子分布风险，记为 $H_{10}^{\\ast}(t) := \\int_0^t h_{10}^{\\ast}(u)\\,\\mathrm{d}u$，是截至时间 $t$ 的各分段上风险高度乘以区间长度的总和。具体来说，对于任意 $t \\ge 0$，\n$$\nH_{10}^{\\ast}(t) = 0.04\\cdot \\min(t,2) + 0.025\\cdot \\max\\{\\min(t,5) - 2, 0\\} + 0.01\\cdot \\max\\{t - 5, 0\\}.\n$$\n因此，\n$$\nF_1^{\\mathrm{FG}}(t \\mid x) = 1 - \\exp\\!\\left(-\\exp(\\gamma x)\\,H_{10}^{\\ast}(t)\\right),\n$$\n且在时间 $t$ 的瞬时 Fine–Gray 子分布风险是\n$$\nh_1^{\\ast}(t \\mid x) = h_{10}^{\\ast}(t)\\,\\exp(\\gamma x),\n$$\n其中 $h_{10}^{\\ast}(t)$ 根据包含 $t$ 的分段来选择。\n\n每个测试用例的算法步骤：\n1. 计算 $\\lambda_1(x) = \\lambda_{10}\\,\\exp(\\beta_1 x)$ 和 $\\lambda_2(x) = \\lambda_{20}\\,\\exp(\\beta_2 x)$。\n2. 使用从常数风险模型积分得到的闭式表达式计算 $F_1(t \\mid x)$。如果 $\\lambda_1(x) + \\lambda_2(x) = 0$，则设 $F_1(t \\mid x) = 0$。\n3. 通过对截至时间 $t$ 的每个分段常数段的贡献求和来计算 $H_{10}^{\\ast}(t)$；然后计算\n   $F_1^{\\mathrm{FG}}(t \\mid x) = 1 - \\exp\\!\\left(-\\exp(\\gamma x)\\,H_{10}^{\\ast}(t)\\right)$。\n4. 通过为给定的 $t$ 选择合适的分段来确定 $h_{10}^{\\ast}(t)$；然后计算 $h_1^{\\ast}(t \\mid x) = h_{10}^{\\ast}(t)\\,\\exp(\\gamma x)$。\n5. 计算 $\\Delta(t \\mid x) = \\left|F_1(t \\mid x) - F_1^{\\mathrm{FG}}(t \\mid x)\\right|$。\n\n边界情况与覆盖范围：\n- 当 $t = 0$ 时，$F_1(t \\mid x) = 0$ 且 $F_1^{\\mathrm{FG}}(t \\mid x) = 0$；Fine–Gray 风险就是 $t = 0$ 时的基线值乘以 $\\exp(\\gamma x)$，由于第一个分段的设置，这里是 $0.04\\cdot \\exp(\\gamma x)$。\n- 当 $\\lambda_{20} = 0$ 且 $\\beta_2 = 0$ 时，不存在竞争风险；特定原因 CIF 简化为原因 1 的指数失效模型。Fine–Gray 预测取决于指定的子分布基线风险计划，这可能与特定原因模型不同，从而产生有信息量的差异。\n- 对称的基线风险展示了协变量通过 $\\beta_1$、$\\beta_2$ 和 $\\gamma$ 发挥的作用。\n- 高风险和长随访方案检验了数值稳定性以及两种建模方法之间的区别。\n\n该程序实现了这些计算，并打印一个单行输出，其中包含每个测试用例的四个浮点数结果列表：$[F_1(t \\mid x), h_1^{\\ast}(t \\mid x), F_1^{\\mathrm{FG}}(t \\mid x), \\Delta(t \\mid x)]$，按规定用方括号括起并用逗号分隔。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cause_specific_cif(lambda10, lambda20, beta1, beta2, x, t):\n    \"\"\"\n    Compute cause-1 cumulative incidence F1(t|x) under constant cause-specific hazards:\n    lambda1(x) = lambda10 * exp(beta1 * x)\n    lambda2(x) = lambda20 * exp(beta2 * x)\n    F1(t|x) = [lambda1 / (lambda1 + lambda2)] * (1 - exp(-(lambda1 + lambda2) * t))\n    With the convention F1 = 0 if lambda1 + lambda2 == 0.\n    \"\"\"\n    l1 = lambda10 * np.exp(beta1 * x)\n    l2 = lambda20 * np.exp(beta2 * x)\n    total = l1 + l2\n    if total == 0.0:\n        return 0.0\n    return (l1 / total) * (1.0 - np.exp(-total * t))\n\ndef fg_baseline_integral(h0_schedule, t):\n    \"\"\"\n    Compute H0*(t) = integral_0^t h0(u) du for piecewise-constant baseline subdistribution hazard h0.\n    h0_schedule: list of segments (start, end, h0), with end=None for the last segment.\n    Assumes schedule is ordered and covers [0, infinity).\n    \"\"\"\n    H = 0.0\n    for start, end, h0 in h0_schedule:\n        if t = start:\n            break\n        seg_end = end if end is not None else t\n        duration = min(t, seg_end) - start\n        if duration > 0.0:\n            H += h0 * duration\n    return H\n\ndef fg_hazard_at_t(h0_schedule, t, gamma, x):\n    \"\"\"\n    Compute h1*(t|x) = h0(t) * exp(gamma * x) at time t based on the schedule.\n    \"\"\"\n    base_h = None\n    for start, end, h0 in h0_schedule:\n        if end is None:\n            if t >= start:\n                base_h = h0\n                break\n        else:\n            if (t >= start) and (t  end):\n                base_h = h0\n                break\n    if base_h is None:\n        # If not found due to numerical boundary, default to last segment\n        base_h = h0_schedule[-1][2]\n    return base_h * np.exp(gamma * x)\n\ndef fg_cif(h0_schedule, t, gamma, x):\n    \"\"\"\n    Compute F1^FG(t|x) = 1 - exp(- exp(gamma * x) * H0*(t)), where H0*(t) is the\n    baseline subdistribution cumulative hazard integral over [0, t].\n    \"\"\"\n    H0 = fg_baseline_integral(h0_schedule, t)\n    return 1.0 - np.exp(- np.exp(gamma * x) * H0)\n\ndef format_list_no_spaces(obj):\n    \"\"\"\n    Serialize Python lists (possibly nested) of numbers to a string without spaces,\n    using brackets and commas only, e.g., [[a,b,c,d],[...],...].\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_list_no_spaces(x) for x in obj) + \"]\"\n    else:\n        # Format floats compactly\n        if isinstance(obj, float):\n            # Use repr-like formatting but ensure standard decimal representation\n            return (\"{:.12g}\".format(obj))\n        else:\n            return str(obj)\n\ndef solve():\n    # Define the piecewise baseline subdistribution hazard schedule h0*(t)\n    # Segments: (start, end, h0) in year^{-1}\n    h0_schedule = [\n        (0.0, 2.0, 0.04),\n        (2.0, 5.0, 0.025),\n        (5.0, None, 0.01),\n    ]\n\n    # Define the test cases from the problem statement.\n    # Each case: lambda10, lambda20, beta1, beta2, x, t, gamma\n    test_cases = [\n        # Case 1\n        (0.12, 0.08, 0.5, -0.2, 1.0, 3.0, 0.4),\n        # Case 2 (boundary t=0)\n        (0.12, 0.08, 0.5, -0.2, 0.0, 0.0, 0.3),\n        # Case 3 (no competing risk)\n        (0.15, 0.0, 0.0, 0.0, 2.0, 5.0, 0.1),\n        # Case 4 (symmetry in baseline hazards)\n        (0.05, 0.05, 0.3, 0.3, -1.0, 10.0, -0.5),\n        # Case 5 (high-risk covariate and long follow-up)\n        (0.2, 0.15, 0.8, 0.1, 3.0, 8.0, 0.6),\n    ]\n\n    results = []\n    for lambda10, lambda20, beta1, beta2, x, t, gamma in test_cases:\n        # Cause-specific CIF for cause 1\n        F_cs = cause_specific_cif(lambda10, lambda20, beta1, beta2, x, t)\n        # Fine–Gray hazard at time t\n        h_fg_t = fg_hazard_at_t(h0_schedule, t, gamma, x)\n        # Fine–Gray CIF for cause 1\n        F_fg = fg_cif(h0_schedule, t, gamma, x)\n        # Absolute difference\n        diff = abs(F_cs - F_fg)\n        results.append([F_cs, h_fg_t, F_fg, diff])\n\n    # Final print statement in the exact required format without spaces.\n    print(format_list_no_spaces(results))\n\nsolve()\n```"
        }
    ]
}