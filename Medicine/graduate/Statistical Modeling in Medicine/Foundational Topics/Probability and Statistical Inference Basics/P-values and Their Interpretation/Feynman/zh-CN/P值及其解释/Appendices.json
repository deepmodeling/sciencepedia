{
    "hands_on_practices": [
        {
            "introduction": "对 $p$ 值的深入理解始于对其计算方法的扎实掌握。本练习旨在通过一个流行病学中的常见情景——使用 $Z$ 统计量检验关联性，来训练这项基本技能。通过从标准正态分布推导双侧 $p$ 值的计算公式，并将其应用于一个假设性研究，您将巩固 $p$ 值的核心定义：即在原假设为真的前提下，观测到至少与当前结果一样极端的数据的概率 。",
            "id": "4617807",
            "problem": "一项队列研究旨在调查长期高暴露于空气污染中的细颗粒物是否与哮喘发病相关。设相对风险的对数为 $\\beta$。根据中心极限定理（CLT），在原假设 $H_{0}:\\beta=0$ 下，估计量 $\\hat{\\beta}$ 近似服从均值为 $0$、方差为 $s_{\\hat{\\beta}}^{2}$ 的正态分布。考虑标准化检验统计量 $Z=\\hat{\\beta}/s_{\\hat{\\beta}}$，在 $H_{0}$ 下，该统计量服从均值为 $0$、方差为 $1$ 的标准正态分布。在该研究中，观测值为 $Z_{\\text{obs}}=2.1$。使用双侧p值的定义，即在 $H_{0}$ 下计算得到的、获得一个至少与观测值一样极端（在任一尾部）的检验统计量的概率，推导出一个用标准正态累积分布函数 $\\Phi(\\cdot)$ 表示的双侧p值表达式，并计算当 $Z_{\\text{obs}}=2.1$ 时的数值。将你的数值答案四舍五入至四位有效数字。最后，在给定的流行病学背景下，简要解释该p值的含义。",
            "solution": "解答包括三个部分：推导双侧p值的表达式，计算其数值，并在给定背景下提供解释。\n\n**第1部分：p值表达式的推导**\n\n双侧p值定义为在原假设 $H_{0}$ 下，观测到至少与已观测值一样极端的检验统计量的概率。检验统计量是 $Z$，在 $H_{0}$ 下服从标准正态分布 $Z \\sim N(0, 1)$。观测值为 $Z_{\\text{obs}} = 2.1$。\n\n一个“至少与 $Z_{\\text{obs}}$ 一样极端”的结果意味着检验统计量 $Z$ 的值大于或等于 $Z_{\\text{obs}}$，或者小于或等于 $-Z_{\\text{obs}}$。由于观测值为正，这等同于检验统计量的绝对值大于或等于观测值的绝对值。\n因此，p值由以下概率给出：\n$$p = P(|Z| \\ge |Z_{\\text{obs}}| | H_{0})$$\n代入观测值 $Z_{\\text{obs}} = 2.1$：\n$$p = P(|Z| \\ge 2.1)$$\n这个不等式可以分解为两个不相交的事件，代表分布的两个尾部：\n$$p = P(Z \\ge 2.1) + P(Z \\le -2.1)$$\n标准正态分布关于其均值 $0$ 是对称的。因此，左尾的概率等于右尾的概率：\n$$P(Z \\le -2.1) = P(Z \\ge 2.1)$$\n因此，p值的表达式可以简化为：\n$$p = 2 \\times P(Z \\ge 2.1)$$\n标准正态累积分布函数（CDF）$\\Phi(z)$ 定义为 $\\Phi(z) = P(Z \\le z)$。右尾的概率可以用CDF表示为：\n$$P(Z \\ge z) = 1 - P(Z  z)$$\n由于正态分布是连续分布，所以 $P(Z  z) = P(Z \\le z) = \\Phi(z)$。因此：\n$$P(Z \\ge 2.1) = 1 - \\Phi(2.1)$$\n将此代回p值的表达式，我们得到用标准正态CDF表示的目标表达式：\n$$p = 2 \\times (1 - \\Phi(2.1))$$\n对于一个一般的观测检验统计量 $Z_{\\text{obs}}$，表达式为 $p = 2(1 - \\Phi(|Z_{\\text{obs}}|))$。\n\n**第2部分：p值的数值计算**\n\n我们需要计算 $p = 2 \\times (1 - \\Phi(2.1))$ 的值。使用标准统计表或软件，标准正态CDF在 $z=2.1$ 处的值约为：\n$$\\Phi(2.1) \\approx 0.98213558$$\n现在，我们计算p值：\n$$p \\approx 2 \\times (1 - 0.98213558)$$\n$$p \\approx 2 \\times 0.01786442$$\n$$p \\approx 0.03572884$$\n题目要求答案四舍五入到四位有效数字。第一位有效数字是 $3$。接下来的三位是 $5$、$7$ 和 $2$。第五位有效数字是 $8$，大于或等于 $5$，所以我们将第四位有效数字（$2$）向上取整为 $3$。\n$$p \\approx 0.03573$$\n\n**第3部分：p值的解释**\n\n计算出的p值约为 $0.03573$。在流行病学研究的背景下，这个值有其精确的含义。原假设 $H_{0}: \\beta=0$ 对应于长期高暴露于细颗粒物与哮喘发病率之间没有关联（即相对风险为 $1$）。p值是指，*假设原假设为真* 的前提下，观测到暗示关联性至少与本研究发现的一样强（由 $Z_{\\text{obs}}=2.1$ 代表）的数据的概率。\n\n因此，其解释为：如果长期暴露于细颗粒物与哮喘发病率之间确实没有关联，那么纯粹由于随机机遇或抽样变异性，观测到与本研究中检测到的关联性一样强或更强的关联的概率为 $3.573\\%$。一个小的p值（通常小于预先设定的显著性水平，如 $0.05$）通常被视为拒绝原假设、支持存在关联的备择假设的证据。",
            "answer": "$$\n\\boxed{0.03573}\n$$"
        },
        {
            "introduction": "尽管 $p$ 值低于传统阈值 $0.05$ 常被誉为“统计学显著”，但这样的结论可能出人意料地脆弱。本练习将介绍脆弱指数（fragility index），这是一个用于批判性评估试验结果稳健性的现代指标。通过为一个临床试验结果计算该指数，您将学习如何量化需要改变多少参与者的结局才能推翻研究结论，从而提供一个比简单的 $p$ 值阈值更细致入微的视角 。",
            "id": "4617811",
            "problem": "一项在疫情爆发背景下进行的随机、平行分组临床试验，比较了一种候选预防性干预措施与标准护理。在干预组中，招募了 $n_{1} = 6$ 名参与者；在对照组中，招募了 $n_{2} = 6$ 名参与者。主要终点是一个二元结果：暴露后 $7$ 天内确诊感染（事件）与未确诊感染（非事件）。观察到的 $2 \\times 2$ 列联表如下：\n- 干预组：$0$ 例事件和 $6$ 例非事件。\n- 对照组：$5$ 例事件和 $1$ 例非事件。\n\n假设原假设为两组的事件概率相等，且试验设计证明在计算p值时以固定边际（总事件数和总分配数）为条件是合理的。使用双侧Fisher精确检验，显著性水平为 $\\alpha = 0.05$，其中双侧p值的定义为：在具有相同边际的所有列联表中，其在原假设下的概率小于或等于观察到的列联表概率的所有概率之和。\n\n任务：\n1. 从固定边际和随机分配下原假设的p值定义出发，推导并计算观察到的列联表的精确双侧Fisher p值。将中间概率表示为精确的有理数，也可提供小数展开以供解释。\n2. 将此二分类比较的脆弱性指数定义为最小的整数 $f \\geq 0$，使得在事件数较少的组（此处为干预组）中将 $f$ 个非事件结果重新分类为事件，并保持其他所有条件不变后，重新计算的精确双侧Fisher p值大于或等于 $\\alpha$。通过每次递增改变一个结果并逐步精确地重新计算双侧p值来计算该脆弱性指数。\n3. 用一句话简要说明，从基于p值得出的结论的稳定性角度，脆弱性指数小在流行病学上的解释。\n\n以整数形式报告脆弱性指数。最终答案无需四舍五入。",
            "solution": "设 $2 \\times 2$ 列联表结构如下，其中 $a$ 和 $c$ 是事件数，$b$ 和 $d$ 是非事件数。\n\n| 组别       | 事件 | 非事件 | 总计 |\n|--------------|--------|------------|-------|\n| 干预       | $a$    | $b$        | $n_1$ |\n| 对照       | $c$    | $d$        | $n_2$ |\n| 总计       | $K$    | $N-K$      | $N$   |\n\n问题提供了以下观察数据：\n- 干预组：$a=0$ 例事件，$b=6$ 例非事件。\n- 对照组：$c=5$ 例事件，$d=1$ 例非事件。\n\n由此产生的列联表及其边际如下：\n- 行合计：$n_1 = a+b = 0+6 = 6$， $n_2 = c+d = 5+1 = 6$。\n- 列合计：$K = a+c = 0+5 = 5$， $N-K = b+d = 6+1 = 7$。\n- 总合计：$N = n_1+n_2 = 6+6 = 12$。\n\n在两组事件概率无差异的原假设下，并以固定边际为条件，观察到干预组有 $a$ 个事件的列联表的概率由超几何概率质量函数给出：\n$$ P(a) = \\frac{\\binom{K}{a} \\binom{N-K}{n_1-a}}{\\binom{N}{n_1}} $$\n对于观察到的列联表，参数为 $N=12$，$n_1=6$，$K=5$。$a$ 的可能取值是满足 $ \\max(0, n_1+K-N) \\leq a \\leq \\min(n_1, K) $ 的整数。此处，$ \\max(0, 6+5-12) \\leq a \\leq \\min(6, 5) $，简化为 $0 \\leq a \\leq 5$。\n\n**1. 计算双侧p值**\n\n首先，我们计算 $a$ 从 $0$ 到 $5$ 所有可能取值的概率。分母是 $\\binom{12}{6} = \\frac{12 \\cdot 11 \\cdot 10 \\cdot 9 \\cdot 8 \\cdot 7}{6 \\cdot 5 \\cdot 4 \\cdot 3 \\cdot 2 \\cdot 1} = 924$。\n这些概率是：\n- 对于 $a=0$：$P(0) = \\frac{\\binom{5}{0} \\binom{7}{6}}{\\binom{12}{6}} = \\frac{1 \\cdot 7}{924} = \\frac{7}{924}$\n- 对于 $a=1$：$P(1) = \\frac{\\binom{5}{1} \\binom{7}{5}}{\\binom{12}{6}} = \\frac{5 \\cdot 21}{924} = \\frac{105}{924}$\n- 对于 $a=2$：$P(2) = \\frac{\\binom{5}{2} \\binom{7}{4}}{\\binom{12}{6}} = \\frac{10 \\cdot 35}{924} = \\frac{350}{924}$\n- 对于 $a=3$：$P(3) = \\frac{\\binom{5}{3} \\binom{7}{3}}{\\binom{12}{6}} = \\frac{10 \\cdot 35}{924} = \\frac{350}{924}$\n- 对于 $a=4$：$P(4) = \\frac{\\binom{5}{4} \\binom{7}{2}}{\\binom{12}{6}} = \\frac{5 \\cdot 21}{924} = \\frac{105}{924}$\n- 对于 $a=5$：$P(5) = \\frac{\\binom{5}{5} \\binom{7}{1}}{\\binom{12}{6}} = \\frac{1 \\cdot 7}{924} = \\frac{7}{924}$\n\n观察到的列联表对应于 $a=0$，其概率为 $P(0) = 7/924$。双侧p值是所有概率等于或小于观察到列联表的概率的总和。我们找出所有满足 $P(a) \\leq P(0)$ 的 $a$。根据上面的列表，这些是 $a=0$ 和 $a=5$。\n\n因此，双侧p值为：\n$$ p = P(0) + P(5) = \\frac{7}{924} + \\frac{7}{924} = \\frac{14}{924} $$\n化简该分数得到：\n$$ p = \\frac{14}{14 \\cdot 66} = \\frac{1}{66} $$\n换算成小数，即 $p \\approx 0.01515...$。由于 $p  \\alpha = 0.05$，该结果具有统计学显著性。\n\n**2. 计算脆弱性指数**\n\n脆弱性指数 $f$ 是将干预组中非事件结果重新分类为事件的最小非负整数，该变动使得p值不再具有统计学显著性（即 $p \\geq \\alpha = 0.05$）。\n\n- **情况 $f=0$**：没有结果被改变。p值为 $p = 1/66 \\approx 0.015$，小于 $0.05$。结果仍然显著。\n\n- **情况 $f=1$**：我们将干预组中的一个非事件更改为事件。新的观察列联表为：\n  - 干预组：$a' = 0+1=1$ 例事件，$b' = 6-1=5$ 例非事件。\n  - 对照组：$c' = 5$ 例事件，$d' = 1$ 例非事件。\n\n这一修改改变了列的边际。用于分析的新列联表是：\n| 组别       | 事件 | 非事件 | 总计 |\n|--------------|--------|------------|-------|\n| 干预       | $1$    | $5$        | $6$   |\n| 对照       | $5$    | $1$        | $6$   |\n| 总计       | $6$    | $6$        | $12$  |\n\n新的边际是 $n_1=6$，$n_2=6$，$K'=6$ 和 $N-K'=6$。我们必须用这个新的超几何分布重新计算p值，其中观察到的单元格是 $a=1$。概率分布是 $P(a) = \\frac{\\binom{K'}{a} \\binom{N-K'}{n_1-a}}{\\binom{N}{n_1}} = \\frac{\\binom{6}{a} \\binom{6}{6-a}}{\\binom{12}{6}}$。\n分母仍然是 $924$。$a$ 的可能取值现在是 $0, 1, ..., 6$。\n\n这个新分布的概率是：\n- $P(0) = \\frac{\\binom{6}{0}\\binom{6}{6}}{924} = \\frac{1 \\cdot 1}{924} = \\frac{1}{924}$\n- $P(1) = \\frac{\\binom{6}{1}\\binom{6}{5}}{924} = \\frac{6 \\cdot 6}{924} = \\frac{36}{924}$\n- $P(2) = \\frac{\\binom{6}{2}\\binom{6}{4}}{924} = \\frac{15 \\cdot 15}{924} = \\frac{225}{924}$\n- $P(3) = \\frac{\\binom{6}{3}\\binom{6}{3}}{924} = \\frac{20 \\cdot 20}{924} = \\frac{400}{924}$\n- $P(4) = P(2) = \\frac{225}{924}$\n- $P(5) = P(1) = \\frac{36}{924}$\n- $P(6) = P(0) = \\frac{1}{924}$\n\n对于 $f=1$ 的情况，观察到的列联表对应于 $a=1$，其概率为 $P(1) = 36/924$。新的双侧p值是所有满足 $P(a) \\leq P(1)$ 的列联表的概率之和。这些是对应 $a=0, 1, 5, 6$ 的列联表。\n新的p值 $p'$ 是：\n$$ p' = P(0) + P(1) + P(5) + P(6) = \\frac{1}{924} + \\frac{36}{924} + \\frac{36}{924} + \\frac{1}{924} = \\frac{74}{924} $$\n化简得到 $p' = \\frac{37}{462}$。\n换算成小数， $p' \\approx 0.08008...$。我们将其与显著性水平进行比较：\n$$ p' \\approx 0.08008... \\geq 0.05 $$\n当 $f=1$ 时，条件得到满足。由于当 $f=0$ 时条件未满足，所以最小整数是 $1$。因此，脆弱性指数是 $1$。\n\n**3. 流行病学解释**\n\n脆弱性指数小意味着试验结果的统计学显著性是脆弱的，因为它仅依赖于少数几个参与者的结果。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "经典的统计检验方法通常依赖于很强的数据正态性等假设，而这些假设在实践中可能无法满足。最后的这项练习将从基于公式的方法转向一种功能强大且假设要求宽松的计算方法：置换检验（permutation test）。通过编写程序计算置换 $p$ 值，您将亲身体验可交换性（exchangeability）原理，并了解如何直接从数据中生成零分布，为复杂的医学研究提供一种稳健的假设检验备选方案 。",
            "id": "4617824",
            "problem": "考虑流行病学中常见的两组比较，其中在一个暴露组和一个非暴露组中测量一个连续结果。当正态性假设存疑时，一种获得有效$p$值的原则性方法是在可交换性假设下使用置换检验。可交换性断言，在无效应的原假设下，结果的联合分布对于暴露标签的置换是不变的。\n\n您需要基于可交换性来形式化置换$p$值，并实现一个程序，用以计算两组间均值差异的双侧置换$p$值。检验统计量必须是样本均值之差，定义为 $T = \\bar{X}_E - \\bar{X}_U$，其中 $\\bar{X}_E$ 和 $\\bar{X}_U$ 分别表示暴露组和非暴露组的样本均值。双侧$p$值将使用绝对值$|T|$作为极端性的度量来计算。在可交换性下，$T$的零分布是通过在 $n = n_E + n_U$ 个观测值上对 $n_E$ 个暴露标签和 $n_U$ 个非暴露标签的所有分配进行重新标记来生成的，或者当精确枚举在计算上不可行时，通过蒙特卡洛 (MC) 抽样进行近似。\n\n您的程序必须：\n- 接受一组硬编码的测试用例，每个用例包含两个分别对应暴露组和非暴露组的观测结果（实数）列表，以及一个整数 $B$ 表示蒙特卡洛置换的次数。如果 $B = 0$，则对所有 $\\binom{n}{n_E}$ 种重新标记进行精确枚举；如果 $B  0$，则使用 $B$ 次随机置换来近似可交换性假设下的 $p$ 值。对于蒙特卡洛方法，使用固定的随机种子以确保可复现性。\n- 对每个用例，计算 $T = \\bar{X}_E - \\bar{X}_U$ 的双侧置换 $p$ 值，其定义为满足 $|T^{\\pi}| \\ge |T_{\\text{obs}}|$ 的置换（精确或蒙特卡洛）所占的比例，其中 $T^{\\pi}$ 是在给定标签置换 $\\pi$ 下计算的检验统计量，而 $T_{\\text{obs}}$ 是从原始标签计算出的观测检验统计量。\n- 将每个 $p$ 值表示为四舍五入到 $6$ 位小数的小数。\n\n使用的基本原理：\n- 流行病学中无效应原假设下的可交换性定义：结果的联合分布在暴露标签的置换下保持不变。\n- $p$ 值的定义：在原假设下，观测到至少与实际实现的检验统计量一样极端的检验统计量的概率。\n\n测试套件：\n- 用例1（平衡，精确计算）：暴露组 $[2.1, 1.9, 2.3, 2.0, 2.2]$，非暴露组 $[1.8, 1.7, 1.6, 1.9, 1.5]$，$B = 0$。\n- 用例2（边界情况，相同结果的精确计算）：暴露组 $[0.0, 0.0]$，非暴露组 $[0.0, 0.0]$，$B = 0$。\n- 用例3（不平衡，蒙特卡洛近似）：暴露组 $[1.04, 0.92, 1.10, 0.95, 1.00, 1.08, 0.97, 1.02]$，非暴露组 $[0.88, 0.79, 0.85, 0.80, 0.90, 0.84, 0.76, 0.83, 0.88, 0.82, 0.91, 0.86]$，$B = 50000$，固定种子 $42$。\n- 用例4（极端差异，精确计算）：暴露组 $[5.0, 5.1, 5.2, 4.9]$，非暴露组 $[1.0, 1.1, 0.9, 1.2]$，$B = 0$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含测试套件的置换$p$值，四舍五入到$6$位小数，形式为用方括号括起来的逗号分隔列表。例如，输出应类似于 $[p_1,p_2,p_3,p_4]$，其中每个 $p_i$ 对应于上面给出的第 $i$ 个用例。",
            "solution": "该问题要求为两组比较计算置换检验的$p$值，这是一种在流行病学和生物统计学中，当不满足正态性等分布假设时具有根本重要性的非参数方法。该方法的基石是原假设下的可交换性原则。\n\n### 解决方案构建\n\n#### 理论框架\n设暴露组的观测结果集为 $Y_E = \\{y_{E,1}, \\dots, y_{E,n_E}\\}$，非暴露组的观测结果集为 $Y_U = \\{y_{U,1}, \\dots, y_{U,n_U}\\}$。各自的样本量为 $n_E$ 和 $n_U$。总观测数为 $n = n_E + n_U$。\n\n原假设 $H_0$ 是暴露对结果没有影响。在 $H_0$ 下，可交换性假设意味着 $n$ 个受试者中的任何一个都有同等可能被分到暴露组或非暴露组。因此，将合并后的结果 $Y = Y_E \\cup Y_U$ 划分为大小为 $n_E$ 和 $n_U$ 的组是任意的。\n\n观测到的检验统计量是样本均值之差：\n$$T_{\\text{obs}} = \\bar{y}_E - \\bar{y}_U = \\frac{1}{n_E}\\sum_{i=1}^{n_E} y_{E,i} - \\frac{1}{n_U}\\sum_{j=1}^{n_U} y_{U,j}$$\n为了评估 $T_{\\text{obs}}$ 的显著性，我们将其与在原假设下生成的检验统计量的参考分布进行比较。这个零分布是通过考虑对合并集 $Y$ 中的 $n$ 个观测值进行重新标记的所有可能方式来创建的。\n\n一个置换 $\\pi$ 对应于将 $Y$ 重新划分为一个新的大小为 $n_E$ 的“暴露”组 $Y_E^{\\pi}$ 和一个新的大小为 $n_U$ 的“非暴露”组 $Y_U^{\\pi}$。对于每个这样的置换，我们计算一个检验统计量：\n$$T^{\\pi} = \\bar{y}_E^{\\pi} - \\bar{y}_U^{\\pi}$$\n所有 $T^{\\pi}$ 值的集合构成了精确的零分布。唯一置换（即唯一划分）的总数为 $N_{total} = \\binom{n}{n_E}$。\n\n双侧 $p$ 值是观测到至少与实际观测值一样极端的检验统计量的概率。使用绝对值作为极端性的度量，该 $p$ 值为：\n$$p = \\frac{\\text{count}(\\{ \\pi : |T^{\\pi}| \\ge |T_{\\text{obs}}|\\})}{N_{total}}$$\n\n#### 计算策略\n该实现需要根据 $B$ 的值采用两种不同的程序。\n\n**情况 1：精确枚举 ($B = 0$)**\n当 $N_{total} = \\binom{n}{n_E}$ 在计算上可管理时，使用此方法。\n1.  将所有观测值合并到一个单一的合并数组 $Y$ 中。\n2.  计算并存储观测检验统计量的绝对值 $|T_{\\text{obs}}|$。\n3.  从集合 $\\{0, 1, \\dots, n-1\\}$ 中生成所有可能的 $n_E$ 个索引的组合。每个组合代表了构成一个置换暴露组的观测值的索引。\n4.  初始化一个计数器 $N_{\\text{extreme}}$ 为 $0$。\n5.  遍历每个索引组合：\n    a. 形成置换后的暴露组 $Y_E^{\\pi}$ 和置换后的非暴露组 $Y_U^{\\pi}$。\n    b. 计算置换检验统计量 $T^{\\pi}$。\n    c. 如果 $|T^{\\pi}| \\ge |T_{\\text{obs}}|$，则将 $N_{\\text{extreme}}$ 加一。\n6.  精确 $p$ 值为 $p = N_{\\text{extreme}} / N_{total}$，其中 $N_{total} = \\binom{n}{n_E}$。\n\n**情况 2：蒙特卡洛近似 ($B  0$)**\n当 $N_{total}$ 太大而无法进行精确枚举时，使用此方法。\n1.  将所有观测值合并到一个单一的合并数组 $Y$ 中。\n2.  计算并存储 $|T_{\\text{obs}}|$。\n3.  设置随机数生成器种子以确保可复现性。\n4.  初始化一个计数器 $N_{\\text{extreme}}$ 为 $0$。\n5.  重复 $B$ 次：\n    a. 随机打乱合并数组 $Y$。\n    b. 前 $n_E$ 个元素构成置换后的暴露组 $Y_E^{\\pi}$，其余 $n_U$ 个元素构成非暴露组 $Y_U^{\\pi}$。\n    c. 计算置换检验统计量 $T^{\\pi}$。\n    d. 如果 $|T^{\\pi}| \\ge |T_{\\text{obs}}|$，则将 $N_{\\text{extreme}}$ 加一。\n6.  近似 $p$ 值为 $p \\approx N_{\\text{extreme}} / B$。\n\n该计算框架直接实现了理论原则，并遵循了问题陈述的规范。每个用例的最终结果都四舍五入到 $6$ 位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import comb\nimport itertools\n\ndef calculate_p_value(exposed_obs, unexposed_obs, B, seed=None):\n    \"\"\"\n    Computes the two-sided permutation p-value for the difference in means.\n\n    Args:\n        exposed_obs (list): Observed outcomes for the exposed group.\n        unexposed_obs (list): Observed outcomes for the unexposed group.\n        B (int): Number of Monte Carlo permutations. If 0, performs exact enumeration.\n        seed (int, optional): Random seed for Monte Carlo simulation. Defaults to None.\n\n    Returns:\n        float: The computed p-value, rounded to 6 decimal places.\n    \"\"\"\n    exposed_arr = np.array(exposed_obs)\n    unexposed_arr = np.array(unexposed_obs)\n\n    n_e = len(exposed_arr)\n    n_u = len(unexposed_arr)\n    n = n_e + n_u\n\n    all_data = np.concatenate((exposed_arr, unexposed_arr))\n\n    # Calculate the observed test statistic\n    t_obs = np.mean(exposed_arr) - np.mean(unexposed_arr)\n    abs_t_obs = np.abs(t_obs)\n\n    extreme_count = 0\n\n    if B == 0:  # Exact enumeration\n        total_permutations = comb(n, n_e, exact=True)\n        indices = range(n)\n        \n        # Iterate over all combinations of indices for the exposed group\n        for exposed_indices in itertools.combinations(indices, n_e):\n            exposed_indices = np.array(exposed_indices)\n            unexposed_indices = np.array(list(set(indices) - set(exposed_indices)))\n            \n            perm_exposed = all_data[exposed_indices]\n            perm_unexposed = all_data[unexposed_indices]\n            \n            t_perm = np.mean(perm_exposed) - np.mean(perm_unexposed)\n            \n            if np.abs(t_perm) = abs_t_obs:\n                extreme_count += 1\n        \n        p_value = extreme_count / total_permutations\n\n    else:  # Monte Carlo approximation\n        if seed is not None:\n            rng = np.random.default_rng(seed)\n        else:\n            rng = np.random.default_rng()\n\n        for _ in range(B):\n            permuted_data = rng.permutation(all_data)\n            \n            perm_exposed = permuted_data[:n_e]\n            perm_unexposed = permuted_data[n_e:]\n            \n            t_perm = np.mean(perm_exposed) - np.mean(perm_unexposed)\n            \n            if np.abs(t_perm) = abs_t_obs:\n                extreme_count += 1\n        \n        p_value = extreme_count / B\n    \n    return round(p_value, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (balanced, exact computation)\n        {'exposed': [2.1, 1.9, 2.3, 2.0, 2.2], 'unexposed': [1.8, 1.7, 1.6, 1.9, 1.5], 'B': 0, 'seed': None},\n        # Case 2 (boundary, exact computation with identical outcomes)\n        {'exposed': [0.0, 0.0], 'unexposed': [0.0, 0.0], 'B': 0, 'seed': None},\n        # Case 3 (unbalanced, Monte Carlo approximation)\n        {'exposed': [1.04, 0.92, 1.10, 0.95, 1.00, 1.08, 0.97, 1.02], 'unexposed': [0.88, 0.79, 0.85, 0.80, 0.90, 0.84, 0.76, 0.83, 0.88, 0.82, 0.91, 0.86], 'B': 50000, 'seed': 42},\n        # Case 4 (extreme difference, exact computation)\n        {'exposed': [5.0, 5.1, 5.2, 4.9], 'unexposed': [1.0, 1.1, 0.9, 1.2], 'B': 0, 'seed': None}\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = calculate_p_value(case['exposed'], case['unexposed'], case['B'], case['seed'])\n        results.append(p_val)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}