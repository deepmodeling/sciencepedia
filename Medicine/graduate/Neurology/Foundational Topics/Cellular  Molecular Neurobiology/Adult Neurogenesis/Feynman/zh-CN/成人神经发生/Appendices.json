{
    "hands_on_practices": [
        {
            "introduction": "我们如何测量那些无法直接观察到的细胞事件的持续时间？这项练习将向你展示，如何通过巧妙的实验设计和基本的概率论，揭示DNA合成期（S期）的隐藏时长。这是理解细胞增殖的一个关键参数，也是定量分析神经发生过程的基础。",
            "id": "4445541",
            "problem": "成体海马齿状回的祖细胞在体内进行异步增殖。溴脱氧尿苷 (BrdU) 仅在其存在时，于脱氧核糖核酸合成期（S期）掺入脱氧核糖核酸中。考虑一个双脉冲标记范式，其中两个无限短的 BrdU 脉冲在时间 $t=0$ 和 $t=\\Delta t$（$\\Delta t>0$）施加。假设一个稳态、遍历的细胞群体具有以下性质：(i) 每个细胞的 S 期具有固定的持续时间 $T_s$（在所研究的亚群中是恒定的），(ii) 脉冲的持续时间与 $T_s$ 相比可以忽略不计，但却是饱和的，因此一个细胞被脉冲标记当且仅当它在脉冲施加时处于 S 期，(iii) 标记检测是完美的，且标记在 S 期的剩余时间内持续存在而无损失，以及 (iv) 在被评估的亚群中，脉冲之间没有细胞损失。\n\n将一个在两个脉冲时都掺入 BrdU 的细胞定义为“双标记”细胞。令 $f$ 表示在时间 $t=\\Delta t$ 被第二次脉冲标记的细胞中，同时也被第一次脉冲标记的细胞的经验测量分数，即在第二次脉冲标记的细胞中双标记细胞所占的比例。从关于异步更新过程的第一性原理和S期占有率的定义出发，推导双标记分数对 $\\Delta t$ 和 $T_s$ 的预期依赖关系。然后，在 $0  \\Delta t  T_s$ 的条件下，推导出从实验测量量 $f$ 和 $\\Delta t$ 计算 $T_s$ 的单个闭合形式解析表达式。",
            "solution": "该问题要求从双脉冲标记实验中推导 S 期持续时间 $T_s$。我们首先根据所给的假设将系统形式化。\n\n祖细胞群体被描述为异步且处于稳态。这意味着细胞周期事件（如进入S期）随时间以恒定速率发生，并且细胞在周期不同阶段的分布是时不变的。对于所研究群体中的所有细胞，S期具有固定的持续时间 $T_s$。\n\n令 $f$ 为在第二次 BrdU 脉冲（在 $t=\\Delta t$ 时）标记的细胞中，同时也被第一次脉冲（在 $t=0$ 时）标记的细胞的比例。这可以解释为一个条件概率：\n$$f = P(\\text{细胞在 } t=0 \\text{ 时处于S期} \\mid \\text{细胞在 } t=\\Delta t \\text{ 时处于S期})$$\n\n考虑一个被第二次脉冲标记的细胞。这意味着它在时间 $t=\\Delta t$ 处于S期。我们定义一个随机变量 $\\tau$ 为该细胞在第二次脉冲时刻已在S期中度过的时间。这是细胞在S期内的“年龄”。根据定义，一个细胞处于S期的持续时间为 $T_s$，因此该细胞的 $\\tau$ 的可能值在区间 $[0, T_s)$ 内。\n\n“异步”和“稳态”的假设意味着，在任何给定时刻，处于S期的细胞群体中，其年龄 $\\tau$ 的分布是均匀的。因此，$\\tau$ 的概率密度函数 (PDF) 为：\n$$p(\\tau) = \\begin{cases} \\frac{1}{T_s}  \\text{若 } 0 \\le \\tau  T_s \\\\ 0  \\text{其他} \\end{cases}$$\n\n一个在时间 $t=\\Delta t$ 时S期年龄为 $\\tau$ 的细胞，必定是在时间 $t_{enter} = \\Delta t - \\tau$ 进入S期的。为了让这个细胞也能在 $t=0$ 时被第一次脉冲标记，它必须在 $t=0$ 时处于S期。一个细胞在时间 $t=0$ 处于S期的条件是，它的进入时间 $t_{enter}$ 和退出时间 $t_{exit} = t_{enter} + T_s$ 必须将 $t=0$ 包含在内：\n$$t_{enter} \\le 0  t_{exit}$$\n将 $t_{enter}$ 和 $t_{exit}$ 的表达式用 $\\tau$ 代入：\n$$\\Delta t - \\tau \\le 0 \\implies \\tau \\ge \\Delta t$$\n$$0  (\\Delta t - \\tau) + T_s \\implies \\tau  \\Delta t + T_s$$\n因此，一个在 $t=\\Delta t$ 时处于S期的细胞，当且仅当其在时间 $t=\\Delta t$ 的S期年龄 $\\tau$ 满足 $\\Delta t \\le \\tau  \\Delta t + T_s$ 时，它在 $t=0$ 时也处于S期。\n\n分数 $f$ 是在给定 $\\tau$ 处于 $[0, T_s)$ 的条件下，$\\tau$ 落入该范围的概率。我们通过在两个区间 $[\\Delta t, \\Delta t + T_s)$ 和 $[0, T_s)$ 的交集上对 PDF $p(\\tau)$ 进行积分来计算这个概率。\n\n问题指定了 $0  \\Delta t  T_s$ 的条件。在此条件下，区间的交集为 $[\\Delta t, T_s)$。因此，分数 $f$ 为：\n$$f = \\int_{\\Delta t}^{T_s} p(\\tau) \\,d\\tau = \\int_{\\Delta t}^{T_s} \\frac{1}{T_s} \\,d\\tau$$\n计算该积分可得：\n$$f = \\frac{1}{T_s} [\\tau]_{\\Delta t}^{T_s} = \\frac{1}{T_s} (T_s - \\Delta t) = 1 - \\frac{\\Delta t}{T_s}$$\n这个方程给出了双标记分数 $f$ 对脉冲间间隔 $\\Delta t$ 和S期持续时间 $T_s$ 的依赖关系。如果 $\\Delta t \\ge T_s$，区间的交集为空，则 $f=0$，这在物理上是正确的，因为没有细胞能够跨越比其S期持续时间更长的时间间隔。\n\n最后一步是在 $0  \\Delta t  T_s$ 的条件下，根据实验测量量 $f$ 和 $\\Delta t$ 求解 $T_s$。我们重新整理 $f$ 的表达式：\n$$ f = 1 - \\frac{\\Delta t}{T_s} $$\n$$ \\frac{\\Delta t}{T_s} = 1 - f $$\n对于一个非零区间 $\\Delta t  0$，我们有 $f  1$，所以 $1 - f \\ne 0$。因此，我们可以求解 $T_s$：\n$$ T_s = \\frac{\\Delta t}{1 - f} $$\n这就是所要求的 $T_s$ 的单个闭合形式解析表达式。",
            "answer": "$$\\boxed{\\frac{\\Delta t}{1 - f}}$$"
        },
        {
            "introduction": "产生新的神经元只是成功的一半，它们还必须存活下来才能整合进神经环路。这项练习将探讨我们如何基于神经营养因子（如脑源性神经营养因子 BDNF）的浓度，来数学建模一个年轻神经元的生死抉择。通过这种方式，我们将分子层面的结合事件与细胞群体层面的存活结果联系起来。",
            "id": "4445565",
            "problem": "海马体齿状回中的成体神经发生受到营养信号的调控，其中包括脑源性神经营养因子 (BDNF)，它能激活原肌球蛋白受体激酶B (TrkB) 受体。\n\n在一项关于成体新生颗粒细胞存活的受控体外测定中，假设存活概率由受体占有率和饱和转导决定：被占用的TrkB结合位点的比例由标准的单位点结合关系给出，而存活效应增量随占有率线性增加，直至在基线之上达到一个最大增量。假设结合位点是独立的（希尔系数 $n=1$），并且下游信号传导在达到一个加在基线存活率 $S_0$ 上的最大增量 $S_{\\max}$ 时饱和。\n\n从配体浓度为 $[\\text{BDNF}]$、半饱和常数为 $K$ 的受体占有率的定义出发，并假设在达到最大增量之前，占有-效应转导是线性的，推导出存活概率 $S([\\text{BDNF}])$ 的函数形式。请仔细地用与成体神经发生相关的生物物理术语解释参数 $K$ 和 $S_{\\max}$。\n\n一项实验报告称，在没有BDNF的情况下，基线存活概率为 $S_0 = 0.35$，而在非常高的BDNF浓度下，饱和存活概率为 $S_0 + S_{\\max} = 0.80$。测得的半效应浓度（即存活增量等于其最大增量一半时的BDNF浓度）为 $K = 3$ nM。使用你推导出的表达式，计算达到目标存活概率 $S^{*} = 0.65$ 所需的BDNF浓度 $[\\text{BDNF}]^{*}$。将你的最终浓度四舍五入至三位有效数字，并以纳摩尔（nM）为单位表示。",
            "solution": "问题陈述已经过验证，被认为是科学上可靠、提法恰当、客观且内部一致的。它描述了一个应用于成体神经发生中神经营养因子信号传导背景下的标准生物物理模型，该模型涉及配体-受体结合和剂量-反应药理学。推导模型和计算所要求的值所需的所有必要参数和条件均已提供。\n\n解答过程分为三部分：首先，推导存活概率函数；其次，对模型参数进行生物物理学解释；最后，计算特定的BDNF浓度。\n\n### 第1部分：存活概率函数 $S([\\text{BDNF}])$ 的推导\n\n问题陈述指出，被占用的原肌球蛋白受体激酶B ($\\text{TrkB}$) 受体的比例（记为 $\\theta$），遵循配体（BDNF）浓度为 $[\\text{BDNF}]$、半饱和常数为 $K$ 时的标准单位点结合关系。当希尔系数 $n=1$ 时，此关系由米氏方程或希尔方程给出：\n$$\n\\theta([\\text{BDNF}]) = \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]}\n$$\n总存活概率 $S([\\text{BDNF}])$ 是在没有BDNF时的基线存活概率 $S_0$ 与一个依赖于BDNF浓度的存活效应增量 $\\Delta S$ 之和。\n$$\nS([\\text{BDNF}]) = S_0 + \\Delta S([\\text{BDNF}])\n$$\n问题明确指出，存活效应增量 $\\Delta S$ 与受体占有率 $\\theta$ 成线性关系。这意味着存在一个形式为 $\\Delta S = c \\cdot \\theta$ 的关系，其中 $c$ 是一个比例常数。\n\n为了确定常数 $c$，我们使用以下条件：在饱和的BDNF浓度下（$[\\text{BDNF}] \\to \\infty$），受体占有率 $\\theta$ 趋近于1，存活效应增量达到其最大值 $S_{\\max}$。\n$$\n\\lim_{[\\text{BDNF}] \\to \\infty} \\theta([\\text{BDNF}]) = \\lim_{[\\text{BDNF}] \\to \\infty} \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]} = 1\n$$\n在此极限下，$\\Delta S = S_{\\max}$。将这些代入线性关系中得到 $S_{\\max} = c \\cdot 1$，因此比例常数是 $c = S_{\\max}$。\n\n因此，存活效应增量由下式给出：\n$$\n\\Delta S([\\text{BDNF}]) = S_{\\max} \\cdot \\theta([\\text{BDNF}]) = S_{\\max} \\left( \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]} \\right)\n$$\n将此表达式代回总存活概率方程，得到最终的函数形式：\n$$\nS([\\text{BDNF}]) = S_0 + S_{\\max} \\left( \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]} \\right)\n$$\n该方程是具有非零基线的药理学剂量-反应曲线的标准形式。\n\n### 第2部分：参数 $K$ 和 $S_{\\max}$ 的解释\n\n1.  **$S_{\\max}$ (最大增量)**：此参数代表由BDNF-TrkB信号通路介导的存活概率可能的最大增量。它是饱和BDNF水平下的最大可能存活概率（$S_0 + S_{\\max}$）与基线存活概率（$S_0$）之间的差值。在生物物理学上，$S_{\\max}$ 量化了BDNF作为这些特定神经元存活促进因子的**效能**。它代表了这个特定信号系统增强细胞存活的全部能力。\n\n2.  **$K$ (半饱和常数)**：此参数的单位是浓度。问题陈述其为半效应浓度。我们可以验证这一点。存活效应增量为 $\\Delta S = S_{\\max} \\left( \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]} \\right)$。我们寻求使该增量效应为其最大值一半时的浓度 $[\\text{BDNF}]$，即 $\\Delta S = \\frac{S_{\\max}}{2}$。\n    $$\n    \\frac{S_{\\max}}{2} = S_{\\max} \\left( \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]} \\right)\n    $$\n    假设 $S_{\\max} \\neq 0$，我们可以两边同除以 $S_{\\max}$：\n    $$\n    \\frac{1}{2} = \\frac{[\\text{BDNF}]}{K + [\\text{BDNF}]}\n    $$\n    $$\n    K + [\\text{BDNF}] = 2[\\text{BDNF}]\n    $$\n    $$\n    [\\text{BDNF}] = K\n    $$\n    因此，$K$ 正是达到最大存活效应增量一半时所需的BDNF浓度。这也被称为EC50（半数有效浓度）。在生物物理学上，$K$ 是衡量BDNF**效价**的指标，并反映了BDNF配体对其TrkB受体的亲和力。较低的 $K$ 值表示较高的亲和力，因为需要较低浓度的配体就能引起半最大效应。\n\n### 第3部分：目标BDNF浓度的计算\n\n问题提供了以下实验数值：\n-   基线存活概率，$S_0 = 0.35$。\n-   饱和存活概率，$S_0 + S_{\\max} = 0.80$。\n-   半效应浓度，$K = 3$ nM。\n-   目标存活概率，$S^{*} = 0.65$。\n\n首先，我们计算最大增量 $S_{\\max}$：\n$$\nS_{\\max} = (S_0 + S_{\\max}) - S_0 = 0.80 - 0.35 = 0.45\n$$\n现在我们有了推导模型所需的所有参数：\n$$\nS([\\text{BDNF}]) = 0.35 + 0.45 \\left( \\frac{[\\text{BDNF}]}{3 + [\\text{BDNF}]} \\right)\n$$\n我们需要找到导致目标存活概率 $S^{*} = 0.65$ 的浓度 $[\\text{BDNF}]^{*}$。我们令 $S([\\text{BDNF}]^{*}) = S^{*}$，然后求解 $[\\text{BDNF}]^{*}$：\n$$\n0.65 = 0.35 + 0.45 \\left( \\frac{[\\text{BDNF}]^{*}}{3 + [\\text{BDNF}]^{*}} \\right)\n$$\n为了求解 $[\\text{BDNF}]^{*}$，我们首先分离含有该变量的项：\n$$\n0.65 - 0.35 = 0.45 \\left( \\frac{[\\text{BDNF}]^{*}}{3 + [\\text{BDNF}]^{*}} \\right)\n$$\n$$\n0.30 = 0.45 \\left( \\frac{[\\text{BDNF}]^{*}}{3 + [\\text{BDNF}]^{*}} \\right)\n$$\n两边同除以 $0.45$：\n$$\n\\frac{0.30}{0.45} = \\frac{[\\text{BDNF}]^{*}}{3 + [\\text{BDNF}]^{*}}\n$$\n该分数可化简为 $\\frac{30}{45} = \\frac{2}{3}$：\n$$\n\\frac{2}{3} = \\frac{[\\text{BDNF}]^{*}}{3 + [\\text{BDNF}]^{*}}\n$$\n现在，我们通过交叉相乘来求解 $[\\text{BDNF}]^{*}$：\n$$\n2(3 + [\\text{BDNF}]^{*}) = 3[\\text{BDNF}]^{*}\n$$\n$$\n6 + 2[\\text{BDNF}]^{*} = 3[\\text{BDNF}]^{*}\n$$\n$$\n6 = 3[\\text{BDNF}]^{*} - 2[\\text{BDNF}]^{*}\n$$\n$$\n[\\text{BDNF}]^{*} = 6\n$$\n浓度为 $[\\text{BDNF}]^{*} = 6$ nM。问题要求将答案四舍五入至三位有效数字。作为整数，6有一位有效数字。为了用三位有效数字表示，我们写作 $6.00$。根据指定，单位是纳摩尔（nM）。",
            "answer": "$$\n\\boxed{6.00}\n$$"
        },
        {
            "introduction": "为了把握全局，我们必须将神经发生的各个独立步骤整合成一个完整的系统。这项练习将指导你建立一个计算模型，该模型可以模拟从单个干细胞到新生神经元群体的完整谱系演化。通过这个模型，你将能够探索不同的细胞分裂策略如何影响最终的神经发生输出。",
            "id": "4445563",
            "problem": "构建一个成体神经发生的谱系树模型，其中放射状胶质细胞样 (RGL) 干细胞经历对称或不对称分裂，并预测在离散时间范围内每个初始干细胞的预期神经源性输出。该模型必须基于基本定义和经过充分检验的随机过程事实进行构建，然后作为适合实现的确定性期望计算来执行。\n\n从以下原则性基础开始。\n\n- 成体神经发生由放射状胶质细胞样 (RGL) 干细胞维持，这些干细胞可以分裂以自我更新或产生后代，包括中间祖细胞和神经母细胞，后者成熟为神经元。每次分裂事件产生两个子细胞。在离散时间内，每个细胞要么根据一个概率进行分裂，要么保持静息。这些结果定义了一个时齐、离散时间、多类型分支过程。\n\n- 对于分支过程中的期望计算，根据全期望定律，期望群体向量呈线性演化，因为独立同分布亲代的预期后代数量是线性相加的。如果 $X_t$ 表示时间 $t$ 的数量，那么期望数量 $\\mathbb{E}[X_t]$ 遵循由每个亲代的平均后代数决定的线性递推关系。\n\n模型设定，包括区室和每个时间步的事件：\n- 令 $S_t$ 表示时间 $t$ 时 RGL 干细胞的预期数量，$P_t$ 表示时间 $t$ 时短暂增殖祖细胞的预期数量，$B_t$ 表示时间 $t$ 时神经母细胞的预期数量。成熟神经元是终末细胞，通过累积输出 $C_T$ 进行计数，$C_T$ 定义为到时间 $T$ 为止产生的成熟神经元的预期总数。\n\n- RGL 干细胞动力学。在给定的时间步内，每个 RGL 细胞以概率 $d_s$ 分裂，或以概率 $1 - d_s$ 保持静息。在分裂的条件下，结果如下：\n  1. 对称性自我更新：以概率 $p_{\\mathrm{ssr}}$ 产生 $2$ 个 RGL 干细胞。\n  2. 不对称分裂：以概率 $p_{\\mathrm{as}}$ 产生 $1$ 个 RGL 干细胞和 $1$ 个祖细胞。\n  3. 对称性分化分裂：以概率 $p_{\\mathrm{symdiff}}$ 产生 $2$ 个祖细胞。\n  这些概率满足 $p_{\\mathrm{ssr}} + p_{\\mathrm{as}} + p_{\\mathrm{symdiff}} = 1$。\n\n- 短暂增殖祖细胞动力学。在给定的时间步内，每个祖细胞以概率 $d_p$ 分裂，或以概率 $1 - d_p$ 保持不变。在分裂的条件下：\n  1. 对称性自我更新：以概率 $r_{\\mathrm{ss}}$ 产生 $2$ 个祖细胞。\n  2. 不对称神经源性分裂：以概率 $r_{\\mathrm{as}}$ 产生 $1$ 个祖细胞和 $1$ 个神经母细胞。\n  3. 终末神经源性分裂：以概率 $r_{\\mathrm{term}}$ 产生 $2$ 个神经母细胞。\n  这些概率满足 $r_{\\mathrm{ss}} + r_{\\mathrm{as}} + r_{\\mathrm{term}} = 1$。\n\n- 神经母细胞动力学。在给定的时间步内，每个神经母细胞以概率 $m_b$ 成熟为神经元，以概率 $a_b$ 经历凋亡，或以概率 $1 - m_b - a_b$ 保持为神经母细胞，其中 $m_b + a_b \\le 1$。我们在这个模型中不包括神经母细胞的分裂。\n\n初始条件：\n- 在 $t = 0$ 时，有一个 RGL 干细胞，没有下游细胞：$S_0 = 1$，$P_0 = 0$，$B_0 = 0$。\n\n使用全期望定律定义每个时间步的预期更新：\n- 对于RGLs：\n  $$S_{t+1} = S_t \\left[(1 - d_s)\\cdot 1 + d_s \\cdot (2 p_{\\mathrm{ssr}} + 1 p_{\\mathrm{as}} + 0 p_{\\mathrm{symdiff}})\\right].$$\n- 对于祖细胞：\n  $$P_{t+1} = P_t \\left[(1 - d_p)\\cdot 1 + d_p \\cdot (2 r_{\\mathrm{ss}} + 1 r_{\\mathrm{as}} + 0 r_{\\mathrm{term}})\\right] + S_t \\left[d_s \\cdot (0 p_{\\mathrm{ssr}} + 1 p_{\\mathrm{as}} + 2 p_{\\mathrm{symdiff}})\\right].$$\n- 对于神经母细胞：\n  $$B_{t+1} = P_t \\left[d_p \\cdot (0 r_{\\mathrm{ss}} + 1 r_{\\mathrm{as}} + 2 r_{\\mathrm{term}})\\right] + B_t \\left[1 - m_b - a_b\\right].$$\n- 在时间步 $t$ 产生的成熟神经元的预期数量等于 $m_b \\cdot B_t$，因此到时间 $T$ 为止的累积预期神经源性输出为\n  $$C_T = \\sum_{t=0}^{T-1} m_b \\cdot B_t.$$\n\n你的任务是实现一个程序，给定参数和一个时间范围 $T$，为几个测试用例计算 $C_T$。将每个结果表示为四舍五入到六位小数的浮点数。不需要物理单位。不涉及角度。百分比必须按所示表示为小数。\n\n测试套件：\n- 测试用例 $1$ (平衡的分裂和神经发生)：\n  $d_s = 0.2$, $p_{\\mathrm{ssr}} = 0.3$, $p_{\\mathrm{as}} = 0.5$, $p_{\\mathrm{symdiff}} = 0.2$,\n  $d_p = 0.6$, $r_{\\mathrm{ss}} = 0.4$, $r_{\\mathrm{as}} = 0.4$, $r_{\\mathrm{term}} = 0.2$,\n  $m_b = 0.5$, $a_b = 0.1$, $T = 10$.\n- 测试用例 $2$ (主要为对称性自我更新，低神经源性驱动)：\n  $d_s = 0.5$, $p_{\\mathrm{ssr}} = 0.9$, $p_{\\mathrm{as}} = 0.1$, $p_{\\mathrm{symdiff}} = 0.0$,\n  $d_p = 0.3$, $r_{\\mathrm{ss}} = 0.8$, $r_{\\mathrm{as}} = 0.2$, $r_{\\mathrm{term}} = 0.0$,\n  $m_b = 0.5$, $a_b = 0.2$, $T = 10$.\n- 测试用例 $3$ (纯分化级联至成熟神经元)：\n  $d_s = 0.5$, $p_{\\mathrm{ssr}} = 0.0$, $p_{\\mathrm{as}} = 0.0$, $p_{\\mathrm{symdiff}} = 1.0$,\n  $d_p = 1.0$, $r_{\\mathrm{ss}} = 0.0$, $r_{\\mathrm{as}} = 0.0$, $r_{\\mathrm{term}} = 1.0$,\n  $m_b = 1.0$, $a_b = 0.0$, $T = 3$.\n- 测试用例 $4$ (静息干细胞，预期净输出为零)：\n  $d_s = 0.0$, $p_{\\mathrm{ssr}} = 0.5$, $p_{\\mathrm{as}} = 0.5$, $p_{\\mathrm{symdiff}} = 0.0$,\n  $d_p = 0.5$, $r_{\\mathrm{ss}} = 0.5$, $r_{\\mathrm{as}} = 0.5$, $r_{\\mathrm{term}} = 0.0$,\n  $m_b = 0.5$, $a_b = 0.5$, $T = 10$.\n- 测试用例 $5$ (强祖细胞神经发生但神经母细胞损耗高)：\n  $d_s = 0.3$, $p_{\\mathrm{ssr}} = 0.2$, $p_{\\mathrm{as}} = 0.3$, $p_{\\mathrm{symdiff}} = 0.5$,\n  $d_p = 0.8$, $r_{\\mathrm{ss}} = 0.3$, $r_{\\mathrm{as}} = 0.3$, $r_{\\mathrm{term}} = 0.4$,\n  $m_b = 0.1$, $a_b = 0.9$, $T = 20$.\n\n最终输出格式：\n- 你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表（例如，\"[result1,result2,result3]\"），其中每个结果对应一个测试用例的 $C_T$，按上面列出的顺序排列，并四舍五入到六位小数。",
            "solution": "问题陈述经过严格验证，并被确定为有效。它在科学上基于随机过程的原理，特别是应用于成体神经发生中细胞谱系动力学的多类型分支过程。该模型是适定的，具有一套完整的参数、初始条件以及用于预期细胞群体的确定性递推关系。目标明确定义且计算上可实现。没有内部矛盾、事实错误或歧义。\n\n该问题要求计算在离散时间范围 $T$ 内，从一个放射状胶质细胞样 (RGL) 干细胞的初始群体开始的累积预期神经源性输出，记为 $C_T$。该系统通过三种细胞类型的预期数量来建模：RGL 干细胞 ($S_t$)、短暂增殖祖细胞 ($P_t$) 和神经母细胞 ($B_t$)。\n\n该动力学由一个线性递推关系系统控制，该系统是通过将全期望定律应用于每个时间步中每种细胞类型的底层随机事件（静息、分裂、分化、凋亡）而得出的。所提供的方程是：\n$$S_{t+1} = S_t \\left[(1 - d_s) + d_s \\cdot (2 p_{\\mathrm{ssr}} + p_{\\mathrm{as}})\\right]$$\n$$P_{t+1} = P_t \\left[(1 - d_p) + d_p \\cdot (2 r_{\\mathrm{ss}} + r_{\\mathrm{as}})\\right] + S_t \\left[d_s \\cdot (p_{\\mathrm{as}} + 2 p_{\\mathrm{symdiff}})\\right]$$\n$$B_{t+1} = P_t \\left[d_p \\cdot (r_{\\mathrm{as}} + 2 r_{\\mathrm{term}})\\right] + B_t \\left[1 - m_b - a_b\\right]$$\n\n为了提供一个清晰高效的解决方案，我们首先定义一组从输入参数导出的常系数。这些系数代表了所有可能事件对每个时间步群体数量的净效应。\n\n令 $\\rho_S$ 为预期 RGL 干细胞群体 $S_t$ 的净增殖因子。\n$$\\rho_S = (1 - d_s) \\cdot 1 + d_s (2 p_{\\mathrm{ssr}} + 1 p_{\\mathrm{as}} + 0 p_{\\mathrm{symdiff}}) = 1 - d_s + d_s(2p_{\\mathrm{ssr}} + p_{\\mathrm{as}})$$\n该因子结合了来自静息细胞（以因子 $1$ 持续存在）和分裂细胞的贡献。\n\n令 $\\gamma_{SP}$ 为每个时间步中每个 RGL 干细胞产生的祖细胞的预期数量。\n$$\\gamma_{SP} = d_s (0 p_{\\mathrm{ssr}} + 1 p_{\\mathrm{as}} + 2 p_{\\mathrm{symdiff}}) = d_s(p_{\\mathrm{as}} + 2p_{\\mathrm{symdiff}})$$\n\n令 $\\rho_P$ 为预期祖细胞群体 $P_t$ 自我增殖的净增殖因子。\n$$\\rho_P = (1 - d_p) \\cdot 1 + d_p (2 r_{\\mathrm{ss}} + 1 r_{\\mathrm{as}} + 0 r_{\\mathrm{term}}) = 1 - d_p + d_p(2r_{\\mathrm{ss}} + r_{\\mathrm{as}})$$\n\n令 $\\gamma_{PB}$ 为每个时间步中每个祖细胞产生的神经母细胞的预期数量。\n$$\\gamma_{PB} = d_p (0 r_{\\mathrm{ss}} + 1 r_{\\mathrm{as}} + 2 r_{\\mathrm{term}}) = d_p(r_{\\mathrm{as}} + 2r_{\\mathrm{term}})$$\n\n令 $\\phi_B$ 为神经母细胞群体 $B_t$ 的持续因子，它考虑了既不成熟也不经历凋亡的细胞。\n$$\\phi_B = 1 - m_b - a_b$$\n\n使用这些系数，递推关系系统简化为：\n$1.$ $S_{t+1} = \\rho_S S_t$\n$2.$ $P_{t+1} = \\rho_P P_t + \\gamma_{SP} S_t$\n$3.$ $B_{t+1} = \\phi_B B_t + \\gamma_{PB} P_t$\n\n初始条件给定为 $S_0 = 1$，$P_0 = 0$ 和 $B_0 = 0$。到时间 $T$ 的累积神经源性输出是从 $t=0$ 到 $t=T-1$ 每一步产生的新神经元的总和。在时间步 $t$ 产生的神经元数量是时间 $t$ 的预期神经母细胞数量 $B_t$ 乘以成熟概率 $m_b$。\n$$C_T = \\sum_{t=0}^{T-1} m_b B_t$$\n\n计算过程是对该系统在指定时间范围 $T$ 内的直接迭代模拟。\n算法如下：\n$1.$ 对于给定的一组参数，计算常系数 $\\rho_S, \\gamma_{SP}, \\rho_P, \\gamma_{PB}, \\phi_B$。\n$2.$ 将状态变量初始化为它们在 $t=0$ 时的值：$S \\leftarrow 1.0$，$P \\leftarrow 0.0$，$B \\leftarrow 0.0$。\n$3.$ 初始化累积神经元计数：$C \\leftarrow 0.0$。\n$4.$ 对 $t$ 从 $0$ 到 $T-1$ 进行迭代：\n    a. 计算当前步骤中产生的新神经元的数量：$m_b \\cdot B$。将此数量加到累加器 $C$ 中。\n    b. 使用当前状态值 $(S, P, B)$ 计算下一个时间步 $t+1$ 的状态：\n        $S_{next} \\leftarrow \\rho_S S$\n        $P_{next} \\leftarrow \\rho_P P + \\gamma_{SP} S$\n        $B_{next} \\leftarrow \\phi_B B + \\gamma_{PB} P$\n    c. 为下一次迭代更新状态变量：$S \\leftarrow S_{next}$，$P \\leftarrow P_{next}$，$B \\leftarrow B_{next}$。\n$5.$ 循环完成后，$C$ 中累积的值即为最终结果 $C_T$。然后根据要求将该值四舍五入到六位小数。\n对每个测试用例执行此算法以产生最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the expected neurogenic output for a lineage tree model of adult neurogenesis.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (d_s, p_ssr, p_as, p_symdiff, d_p, r_ss, r_as, r_term, m_b, a_b, T)\n    test_cases = [\n        # Test Case 1 (balanced division and neurogenesis)\n        (0.2, 0.3, 0.5, 0.2, 0.6, 0.4, 0.4, 0.2, 0.5, 0.1, 10),\n        # Test Case 2 (predominantly symmetric self-renewal, low neurogenic drive)\n        (0.5, 0.9, 0.1, 0.0, 0.3, 0.8, 0.2, 0.0, 0.5, 0.2, 10),\n        # Test Case 3 (pure differentiative cascade to mature neurons)\n        (0.5, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 3),\n        # Test Case 4 (quiescent stem cells, net zero output expected)\n        (0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 10),\n        # Test Case 5 (strong progenitor neurogenesis but high neuroblast attrition)\n        (0.3, 0.2, 0.3, 0.5, 0.8, 0.3, 0.3, 0.4, 0.1, 0.9, 20),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        d_s, p_ssr, p_as, p_symdiff, d_p, r_ss, r_as, r_term, m_b, a_b, T = case\n\n        # Calculate the constant coefficients for the recurrence relations\n        rho_S = (1.0 - d_s) + d_s * (2.0 * p_ssr + 1.0 * p_as)\n        gamma_SP = d_s * (1.0 * p_as + 2.0 * p_symdiff)\n        rho_P = (1.0 - d_p) + d_p * (2.0 * r_ss + 1.0 * r_as)\n        gamma_PB = d_p * (1.0 * r_as + 2.0 * r_term)\n        phi_B = 1.0 - m_b - a_b\n\n        # Initialize state variables (expected counts)\n        # S: RGL stem cells, P: Progenitors, B: Neuroblasts\n        S, P, B = 1.0, 0.0, 0.0\n        \n        # Initialize cumulative neuron output\n        C_T = 0.0\n\n        # Iterate through time from t=0 to T-1\n        for _ in range(T):\n            # Add neurons generated in the current step to the cumulative total\n            C_T += m_b * B\n            \n            # Calculate the state for the next time step\n            S_next = rho_S * S\n            P_next = rho_P * P + gamma_SP * S\n            B_next = phi_B * B + gamma_PB * P\n            \n            # Update the state for the next iteration\n            S, P, B = S_next, P_next, B_next\n            \n        # Append the final rounded result to the list\n        results.append(f\"{C_T:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}