{
    "hands_on_practices": [
        {
            "introduction": "要研究意识的神经关联，一个关键的初始步骤是量化在觉醒状态转变（例如进入麻醉状态）期间大脑信号的变化。本练习提供了分析脑电图（EEG）数据的基本实践，特别是计算不同频段谱功率的变化。通过解决这个问题 ，学生将具体理解一个有据可查的无意识状态的电生理学特征。",
            "id": "4501010",
            "problem": "脑电图（EEG）的特定频段谱功率是一种广泛使用的、与唤醒水平相关的定量神经信号。已知 alpha 频段（$8$–$12$ Hz）和 delta 频段（$0.5$–$4$ Hz）会随着A型γ-氨基丁酸（$\\text{GABA}_\\text{A}$）能麻醉剂（如 propofol）的诱导而发生变化，并且这些变化一直被认为与意识状态的转变相关。假设一名成年受试者在休息状态下，在临床确认的 propofol 诱导的无反应状态开始之前，其基线 alpha 频段功率为 $5$ 任意单位，delta 频段功率为 $3$ 任意单位。在诱导后 $5$ 分钟内，使用相同的预处理流程和空间电极布局，测得的 alpha 频段功率增加到 $12$ 任意单位，delta 频段功率增加到 $10$ 任意单位。使用数量按比例增加的基本定义，即 $(P_{\\text{after}}-P_{\\text{before}})/P_{\\text{before}}$，计算 alpha 和 delta 频段的比例增量。将每个增量表示为小数（即初始值的分数，而不是带百分号的数字），并将每个结果四舍五入到四位有效数字。按 alpha、delta 的顺序报告这两个数字。用一句话解释特定频段变化的模式如何从意识的神经相关物的角度与意识水平相关联。最终的数值答案必须无单位（无量纲）。",
            "solution": "首先对问题进行验证过程。\n\n### 第1步：提取已知条件\n-   Alpha 频段频率范围：$8$–$12$ Hz\n-   Delta 频段频率范围：$0.5$–$4$ Hz\n-   基线 alpha 频段功率，$P_{\\alpha, \\text{before}}$：$5$ 任意单位\n-   基线 delta 频段功率，$P_{\\delta, \\text{before}}$：$3$ 任意单位\n-   诱导后 alpha 频段功率，$P_{\\alpha, \\text{after}}$：$12$ 任意单位\n-   诱导后 delta 频段功率，$P_{\\delta, \\text{after}}$：$10$ 任意单位\n-   比例增量的定义：$\\frac{P_{\\text{after}}-P_{\\text{before}}}{P_{\\text{before}}}$\n-   四舍五入要求：四位有效数字\n-   报告顺序：alpha, delta\n-   解释任务：将变化模式与意识水平相关联。\n\n### 第2步：使用提取的已知条件进行验证\n该问题具有科学依据。在使用如 propofol 等 GABA 能麻醉剂后，所述的 alpha 和 delta 频段功率变化与临床神经科学和麻醉学中的既有发现一致。额叶 alpha 功率的反常增加（“alpha 浪涌”）以及慢波（delta）功率的同时增加，是记录完备的意识丧失的神经相关物。该问题提法得当，为计算提供了所有必要的数值和精确的数学定义。它是客观的，没有歧义。问题的解释性部分不会使问题无效，因为它要求在所提供的科学背景下，基于计算出的数据得出结论，这是科学问题解决中的标准做法。\n\n### 第3步：结论与行动\n该问题被视为有效，将提供完整解答。\n\n问题要求使用提供的公式和数据计算 alpha 和 delta EEG 频段的比例增量。设比例增量用 $\\Delta_P$ 表示。公式为：\n$$ \\Delta_P = \\frac{P_{\\text{after}}-P_{\\text{before}}}{P_{\\text{before}}} $$\n其中 $P_{\\text{before}}$ 是麻醉诱导前的功率，$P_{\\text{after}}$ 是诱导后的功率。\n\n首先，我们计算 alpha 频段的比例增量 $\\Delta_{P, \\alpha}$。\n给定值为 $P_{\\alpha, \\text{before}} = 5$ 和 $P_{\\alpha, \\text{after}} = 12$。\n将这些值代入公式：\n$$ \\Delta_{P, \\alpha} = \\frac{12 - 5}{5} = \\frac{7}{5} = 1.4 $$\n问题要求答案四舍五入到四位有效数字。精确值 $1.4$ 写成 $1.400$ 以满足此要求。\n\n接下来，我们计算 delta 频段的比例增量 $\\Delta_{P, \\delta}$。\n给定值为 $P_{\\delta, \\text{before}} = 3$ 和 $P_{\\delta, \\text{after}} = 10$。\n将这些值代入公式：\n$$ \\Delta_{P, \\delta} = \\frac{10 - 3}{3} = \\frac{7}{3} $$\n作为小数，这是一个循环小数：$2.3333...$。\n四舍五入到四位有效数字，我们得到 $2.333$。\n\n最终的数值答案是 alpha 和 delta 频段的比例增量，按顺序为：$1.400$ 和 $2.333$。\n\n最后，问题要求对特定频段变化的模式进行解释。alpha（$1.400$）和 delta（$2.333$）频段功率的同时大幅度比例增加，特别是慢波 delta 活动的相对增幅更大，这代表了从清醒到 propofol 诱导的无反应状态转变的特征性电生理学标志或神经相关物。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.400 & 2.333\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "除了简单的觉醒状态变化，一个核心目标是识别与有意识感知本身明确相关的神经活动。本实践深入探讨了一种常见的实验范式，即使用事件相关电位（ERPs）对比大脑对“可见”与“不可见”刺激的反应。这个问题  旨在培养神经生理学数据分析的关键技能，包括使用严谨的统计方法来精确定位与意识相关的信号出现的时间，同时控制多重比较问题。",
            "id": "4501015",
            "problem": "一项脑电图（EEG）研究通过比较在两种条件下由相同视觉刺激诱发的事件相关电位（ERP）波形来检验意识的神经关联物。这两种条件是：由于反向掩蔽而有意识感知到（“看见”）和没有有意识感知到（“未看见”）。测量在枕部后侧的一个电极上进行。对于 $n=24$ 名参与者，在八个刺激后潜伏期 $t$ 的总平均ERP振幅（单位：微伏）以及配对差异的被试内标准差如下所示。对于每个潜伏期 $t$，给定 $\\mu_{\\text{seen}}(t)$、$\\mu_{\\text{unseen}}(t)$ 和 $s_{d}(t)$，其中 $s_{d}(t)$ 是被试内差异 $d_{i}(t)=\\text{ERP}_{\\text{seen},i}(t)-\\text{ERP}_{\\text{unseen},i}(t)$ 在所有参与者中的标准差。\n\n- $t=100~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=2.1~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=2.0~\\mu\\mathrm{V}$, $s_{d}(t)=1.2~\\mu\\mathrm{V}$\n- $t=150~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=3.0~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=2.7~\\mu\\mathrm{V}$, $s_{d}(t)=1.1~\\mu\\mathrm{V}$\n- $t=180~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-1.6~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-0.8~\\mu\\mathrm{V}$, $s_{d}(t)=1.0~\\mu\\mathrm{V}$\n- $t=200~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-2.4~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-1.2~\\mu\\mathrm{V}$, $s_{d}(t)=1.1~\\mu\\mathrm{V}$\n- $t=220~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-2.7~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-1.2~\\mu\\mathrm{V}$, $s_{d}(t)=1.0~\\mu\\mathrm{V}$\n- $t=250~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-1.9~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-0.9~\\mu\\mathrm{V}$, $s_{d}(t)=1.2~\\mu\\mathrm{V}$\n- $t=300~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=2.4~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=1.9~\\mu\\mathrm{V}$, $s_{d}(t)=1.3~\\mu\\mathrm{V}$\n- $t=350~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=5.1~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=3.1~\\mu\\mathrm{V}$, $s_{d}(t)=1.5~\\mu\\mathrm{V}$\n\n任务：\n1. 计算每个潜伏期的差异波 $D(t)=\\mu_{\\text{seen}}(t)-\\mu_{\\text{unseen}}(t)$。\n2. 对于每个潜伏期，使用统计量 $t(t)=\\bar{d}(t)/\\left(s_{d}(t)/\\sqrt{n}\\right)$ 对参与者进行配对t检验，其中 $\\bar{d}(t)=D(t)$，自由度为 $\\mathrm{df}=n-1$。使用学生t分布获取每个 $t$ 的双侧p值。\n3. 为了控制在 $m=8$ 个时间点上的多重比较，应用 Benjamini–Hochberg 程序进行错误发现率（FDR）控制，设定 $q=0.05$。确定“看见”和“未看见”的ERP首次出现统计上显著差异的最早潜伏期。\n4. 根据检验的统计结构和ERP数据的时间依赖性，简要说明所选多重比较方法的适当性，并将其与至少一种替代方法（例如，Bonferroni 总体错误率（FWER）控制或基于聚类的置换检验）进行对比。\n\n在此背景下，哪个选项最能确定最早的显著差异并指明了控制多重比较的适当方法？\n\nA. $180~\\mathrm{ms}$；将 $D(t)$ 计算为“看见”减去“未看见”的差值，在每个时间点使用配对t检验，并使用 Benjamini–Hochberg 错误发现率（$q=0.05$）对 $m=8$ 个检验进行控制；最早的显著潜伏期是 $180~\\mathrm{ms}$。\n\nB. $150~\\mathrm{ms}$；计算 $D(t)$ 并使用未校正的配对t检验（$\\alpha=0.05$），然后应用 Bonferroni 校正来确认 $150~\\mathrm{ms}$ 作为最早的差异仍然显著。\n\nC. $220~\\mathrm{ms}$；使用配对t检验和 Bonferroni 总体错误率控制（$\\alpha_{\\mathrm{FWER}}=0.05/8$），因为更早的潜伏期未能通过此校正，使得 $220~\\mathrm{ms}$ 成为第一个显著的差异点。\n\nD. $300~\\mathrm{ms}$；使用跨时间点的基于聚类的置换检验来控制多重比较，因为只有 $300~\\mathrm{ms}$ 附近的晚期正成分产生了一个显著的聚类起始点，而更早的负向偏转没有形成显著的聚类。",
            "solution": "用户提供了一个来自认知神经科学领域的问题，要求对模拟的事件相关电位（ERP）数据进行统计分析。将通过执行四个指定的任务来解决这个问题。\n\n### 步骤1：问题陈述的验证\n\n首先，提取问题的已知信息。\n- **研究类型**：关于意识的神经关联物的脑电图（EEG）研究。\n- **比较**：相同视觉刺激下的“看见”与“未看见”条件。\n- **测量**：枕部后侧电极的ERP振幅。\n- **样本量**：$n=24$ 名参与者。\n- **数据点**：$m=8$ 个潜伏期 $t$（单位：毫秒）。\n- **每个潜伏期 $t$ 提供的统计数据**：\n  - “看见”条件下的总平均ERP振幅：$\\mu_{\\text{seen}}(t)$。\n  - “未看见”条件下的总平均ERP振幅：$\\mu_{\\text{unseen}}(t)$。\n  - 被试内差异的标准差：$s_{d}(t)$，其中 $d_{i}(t)=\\text{ERP}_{\\text{seen},i}(t)-\\text{ERP}_{\\text{unseen},i}(t)$。\n- **具体数据**：\n  - $t=100~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=2.1~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=2.0~\\mu\\mathrm{V}$, $s_{d}(t)=1.2~\\mu\\mathrm{V}$\n  - $t=150~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=3.0~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=2.7~\\mu\\mathrm{V}$, $s_{d}(t)=1.1~\\mu\\mathrm{V}$\n  - $t=180~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-1.6~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-0.8~\\mu\\mathrm{V}$, $s_{d}(t)=1.0~\\mu\\mathrm{V}$\n  - $t=200~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-2.4~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-1.2~\\mu\\mathrm{V}$, $s_{d}(t)=1.1~\\mu\\mathrm{V}$\n  - $t=220~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-2.7~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-1.2~\\mu\\mathrm{V}$, $s_{d}(t)=1.0~\\mu\\mathrm{V}$\n  - $t=250~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=-1.9~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=-0.9~\\mu\\mathrm{V}$, $s_{d}(t)=1.2~\\mu\\mathrm{V}$\n  - $t=300~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=2.4~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=1.9~\\mu\\mathrm{V}$, $s_{d}(t)=1.3~\\mu\\mathrm{V}$\n  - $t=350~\\mathrm{ms}$: $\\mu_{\\text{seen}}(t)=5.1~\\mu\\mathrm{V}$, $\\mu_{\\text{unseen}}(t)=3.1~\\mu\\mathrm{V}$, $s_{d}(t)=1.5~\\mu\\mathrm{V}$\n- **任务1**：计算差异波 $D(t)=\\mu_{\\text{seen}}(t)-\\mu_{\\text{unseen}}(t)$。\n- **任务2**：在每个潜伏期进行配对t检验。检验统计量为 $t(t)=\\bar{d}(t)/\\left(s_{d}(t)/\\sqrt{n}\\right)$，其中 $\\bar{d}(t)=D(t)$，自由度为 $\\mathrm{df}=n-1$。获取双侧p值。\n- **任务3**：应用 Benjamini–Hochberg 程序对 $m=8$ 次检验进行错误发现率（FDR）控制，设定 $q=0.05$。确定最早的显著潜伏期。\n- **任务4**：说明所选多重比较方法的合理性。\n\n问题陈述具有科学依据，描述了认知神经科学中标准的实验设计和数据分析流程。所提供的数据是现实的，任务定义明确且可形式化。使用总平均振幅 $\\mu_{\\text{seen}}$ 和 $\\mu_{\\text{unseen}}$ 计算平均差异 $\\bar{d}(t)$ 是正确的，因为差异的平均值等于平均值的差异：$\\bar{d}(t) = \\frac{1}{n}\\sum_i d_i(t) = \\frac{1}{n}\\sum_i(\\text{ERP}_{\\text{seen},i}(t) - \\text{ERP}_{\\text{unseen},i}(t)) = \\mu_{\\text{seen}}(t) - \\mu_{\\text{unseen}}(t) = D(t)$。配对t检验和自由度的统计公式是正确的。问题是自洽的，不包含任何矛盾或歧义。\n\n**结论**：问题有效。\n\n### 步骤2：解决方案的推导\n\n解决方案通过执行问题陈述中列出的四个任务来进行。\n\n**任务1：计算差异波 $D(t)$。**\n差异波 $D(t) = \\bar{d}(t) = \\mu_{\\text{seen}}(t)-\\mu_{\\text{unseen}}(t)$ 的计算结果如下：\n- $t=100~\\mathrm{ms}$: $D(100) = 2.1 - 2.0 = 0.1~\\mu\\mathrm{V}$\n- $t=150~\\mathrm{ms}$: $D(150) = 3.0 - 2.7 = 0.3~\\mu\\mathrm{V}$\n- $t=180~\\mathrm{ms}$: $D(180) = -1.6 - (-0.8) = -0.8~\\mu\\mathrm{V}$\n- $t=200~\\mathrm{ms}$: $D(200) = -2.4 - (-1.2) = -1.2~\\mu\\mathrm{V}$\n- $t=220~\\mathrm{ms}$: $D(220) = -2.7 - (-1.2) = -1.5~\\mu\\mathrm{V}$\n- $t=250~\\mathrm{ms}$: $D(250) = -1.9 - (-0.9) = -1.0~\\mu\\mathrm{V}$\n- $t=300~\\mathrm{ms}$: $D(300) = 2.4 - 1.9 = 0.5~\\mu\\mathrm{V}$\n- $t=350~\\mathrm{ms}$: $D(350) = 5.1 - 3.1 = 2.0~\\mu\\mathrm{V}$\n\n**任务2：进行配对t检验并获取p值。**\n样本量 $n=24$，因此自由度为 $\\mathrm{df}=n-1=23$。平均差异的标准误为 $SE_d(t) = s_d(t)/\\sqrt{n} = s_d(t)/\\sqrt{24}$。t统计量为 $t_{stat}(t) = \\bar{d}(t)/SE_d(t)$。我们计算这些值以及来自学生t分布的相应双侧p值。\n\n- $t=100~\\mathrm{ms}$: $SE_d = 1.2/\\sqrt{24} \\approx 0.2449~\\mu\\mathrm{V}$。$t_{stat} = 0.1 / 0.2449 \\approx 0.408$。$p \\approx 0.6871$。\n- $t=150~\\mathrm{ms}$: $SE_d = 1.1/\\sqrt{24} \\approx 0.2245~\\mu\\mathrm{V}$。$t_{stat} = 0.3 / 0.2245 \\approx 1.336$。$p \\approx 0.1942$。\n- $t=180~\\mathrm{ms}$: $SE_d = 1.0/\\sqrt{24} \\approx 0.2041~\\mu\\mathrm{V}$。$t_{stat} = -0.8 / 0.2041 \\approx -3.919$。$p \\approx 0.00069$。\n- $t=200~\\mathrm{ms}$: $SE_d = 1.1/\\sqrt{24} \\approx 0.2245~\\mu\\mathrm{V}$。$t_{stat} = -1.2 / 0.2245 \\approx -5.345$。$p \\approx 0.000018$。\n- $t=220~\\mathrm{ms}$: $SE_d = 1.0/\\sqrt{24} \\approx 0.2041~\\mu\\mathrm{V}$。$t_{stat} = -1.5 / 0.2041 \\approx -7.349$。$p \\approx 0.0000003$。\n- $t=250~\\mathrm{ms}$: $SE_d = 1.2/\\sqrt{24} \\approx 0.2449~\\mu\\mathrm{V}$。$t_{stat} = -1.0 / 0.2449 \\approx -4.083$。$p \\approx 0.00049$。\n- $t=300~\\mathrm{ms}$: $SE_d = 1.3/\\sqrt{24} \\approx 0.2654~\\mu\\mathrm{V}$。$t_{stat} = 0.5 / 0.2654 \\approx 1.884$。$p \\approx 0.0720$。\n- $t=350~\\mathrm{ms}$: $SE_d = 1.5/\\sqrt{24} \\approx 0.3062~\\mu\\mathrm{V}$。$t_{stat} = 2.0 / 0.3062 \\approx 6.532$。$p \\approx 0.0000015$。\n\n**任务3：应用 Benjamini–Hochberg (BH) 程序。**\n我们对 $m=8$ 次比较进行错误发现率（FDR）控制，设定 $q=0.05$。\n1. 将p值 $p_{(i)}$ 按升序排列：\n    - $p_{(1)} = 0.0000003$ (来自 $t=220~\\mathrm{ms}$)\n    - $p_{(2)} = 0.0000015$ (来自 $t=350~\\mathrm{ms}$)\n    - $p_{(3)} = 0.000018$ (来自 $t=200~\\mathrm{ms}$)\n    - $p_{(4)} = 0.00049$ (来自 $t=250~\\mathrm{ms}$)\n    - $p_{(5)} = 0.00069$ (来自 $t=180~\\mathrm{ms}$)\n    - $p_{(6)} = 0.0720$ (来自 $t=300~\\mathrm{ms}$)\n    - $p_{(7)} = 0.1942$ (来自 $t=150~\\mathrm{ms}$)\n    - $p_{(8)} = 0.6871$ (来自 $t=100~\\mathrm{ms}$)\n2. 找到满足 $p_{(k)} \\leq \\frac{k}{m}q$ 的最大秩 $k$。此处，$m=8$，$q=0.05$。\n    - $k=1$: $p_{(1)} \\approx 3 \\times 10^{-7} \\leq (1/8)\\times 0.05 = 0.00625$。条件满足。\n    - $k=2$: $p_{(2)} \\approx 1.5 \\times 10^{-6} \\leq (2/8)\\times 0.05 = 0.0125$。条件满足。\n    - $k=3$: $p_{(3)} \\approx 1.8 \\times 10^{-5} \\leq (3/8)\\times 0.05 = 0.01875$。条件满足。\n    - $k=4$: $p_{(4)} \\approx 4.9 \\times 10^{-4} \\leq (4/8)\\times 0.05 = 0.025$。条件满足。\n    - $k=5$: $p_{(5)} \\approx 6.9 \\times 10^{-4} \\leq (5/8)\\times 0.05 = 0.03125$。条件满足。\n    - $k=6$: $p_{(6)} \\approx 0.0720 > (6/8)\\times 0.05 = 0.0375$。条件不满足。\n3. 最大秩为 $k=5$。因此，拒绝与秩为1到5的p值对应的零假设。\n4. 显著的潜伏期是对应于这些p值的潜伏期：$220$、$350$、$200$、$250$ 和 $180~\\mathrm{ms}$。\n5. 这些显著结果中最早的潜伏期是 $180~\\mathrm{ms}$。\n\n**任务4：说明方法的合理性并与替代方法进行对比。**\n- **Benjamini-Hochberg (FDR)的适当性**：在像ERP这样的神经生理学时间序列数据中，相邻的时间点高度相关。标准的BH程序在某些形式的依赖性（正回归依赖性，PRDS）下是稳健的，这对此类数据是一个合理的假设。FDR控制不如总体错误率（FWER）控制保守，因此提供了更大的统计功效来检测真实效应，这在神经科学中常见的探索性分析中通常是可取的。它控制所有被拒绝的假设中错误发现的预期比例，是在发现真实效应和做出错误声明之间的一个务实权衡。\n- **与Bonferroni (FWER)的对比**：Bonferroni校正通过将显著性水平 $\\alpha$ 除以检验次数 $m$ 来控制FWER。在这里，调整后的显著性阈值将是 $p  0.05/8 = 0.00625$。$180, 200, 220, 250, 350~\\mathrm{ms}$ 处的p值都小于此阈值，因此也将是显著的。最早的显著潜伏期仍然是 $180~\\mathrm{ms}$。虽然Bonferroni应用起来更简单，但众所周知它过于保守，尤其是在检验相关时，从而增加了II型错误（未能检测到真实效应）的机率。\n- **与基于聚类的置换检验的对比**：这种非参数方法是专门为具有时空结构的数据设计的。它识别超过某一阈值的相邻检验的聚类，并通过置换检验来评估这些聚类的显著性。这种方法内在地考虑了ERP数据的时间相关性，并且通常比像BH或Bonferroni这样的逐点校正更敏感。然而，它检验的是聚类的显著性，而不是单个时间点的显著性。根据我们从 $180$ 到 $250~\\mathrm{ms}$ 获得的强烈、连续的t统计量，该方法很可能会识别出一个在 $180~\\mathrm{ms}$ 或之前开始的显著负向聚类。BH是一种有效且广泛使用的逐点替代方法。\n\n### 步骤3：选项评估\n\n- **A. $180~\\mathrm{ms}$；将 $D(t)$ 计算为“看见”减去“未看见”的差值，在每个时间点使用配对t检验，并使用 Benjamini–Hochberg 错误发现率（$q=0.05$）对 $m=8$ 个检验进行控制；最早的显著潜伏期是 $180~\\mathrm{ms}$。**\n该选项准确地描述了问题陈述中要求的方法论，并正确地指出了分析的结果。我的计算证实，在BH-FDR校正后，$180~\\mathrm{ms}$ 是观察到统计上显著差异的最早潜伏期。\n**结论：正确。**\n\n- **B. $150~\\mathrm{ms}$；计算 $D(t)$ 并使用未校正的配对t检验（$\\alpha=0.05$），然后应用 Bonferroni 校正来确认 $150~\\mathrm{ms}$ 作为最早的差异仍然显著。**\n在 $150~\\mathrm{ms}$ 处的未校正p值为 $p \\approx 0.194$，在 $\\alpha=0.05$ 水平下不显著。因此，$150~\\mathrm{ms}$ 是最早的未校正显著潜伏期的前提是错误的。所描述的方法论也是不合理的。\n**结论：不正确。**\n\n- **C. $220~\\mathrm{ms}$；使用配对t检验和 Bonferroni 总体错误率控制（$\\alpha_{\\mathrm{FWER}}=0.05/8$），因为更早的潜伏期未能通过此校正，使得 $220~\\mathrm{ms}$ 成为第一个显著的差异点。**\nBonferroni校正后的阈值是 $p  0.05/8 = 0.00625$。在 $180~\\mathrm{ms}$ 处的p值为 $p \\approx 0.00069$，远低于此阈值。因此，关于更早潜伏期（特别是 $180~\\mathrm{ms}$）未能通过校正的说法是错误的。使用Bonferroni校正的最早显著潜伏期是 $180~\\mathrm{ms}$，而不是 $220~\\mathrm{ms}$。\n**结论：不正确。**\n\n- **D. $300~\\mathrm{ms}$；使用跨时间点的基于聚类的置换检验来控制多重比较，因为只有 $300~\\mathrm{ms}$ 附近的晚期正成分产生了一个显著的聚类起始点，而更早的负向偏转没有形成显著的聚类。**\n这个选项提出了另一种方法。然而，在 $300~\\mathrm{ms}$ 处的未校正p值为 $p \\approx 0.072$，不具有统计显著性。相比之下，$180~\\mathrm{ms}$ 到 $250~\\mathrm{ms}$ 的潜伏期显示出强烈、连续的负向偏转，p值非常小。基于聚类的分析极不可能在 $300~\\mathrm{ms}$ 处找到一个显著聚类，却未能在前一个范围内找到。该结论与所提供的数据不一致。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "该领域的最终目标不仅是寻找关联，还要理解意识背后的计算原理。这个高级实践邀请学生通过构建一个基于预测编码框架的计算模型来接触这一前沿领域。通过推导并实现一个旨在最小化预测误差的分层神经网络的更新规则 ，学生将探索一个关于大脑如何通过持续的预测与校正循环来产生意识体验的强大假说。",
            "id": "4501106",
            "problem": "要求您形式化并实现一个双层分层预测编码模型，通过反馈预测和前馈预测误差之间的相互作用来研究意识的神经关联物。该模型必须建立在以下基础之上：适用于线性高斯模型的贝叶斯法则、作为方差倒数的精度概念，以及在拉普拉斯假设下的变分推断，该推断产生用于最小化变分自由能（VFE）的梯度下降更新。任务是推导并实现一个数学上明确的模型和一个关于意识内容何时浮现的决策标准，并将其构建为一个完全指定的计算问题。\n\n考虑一个具有两个潜在层级和一个观测值的分层线性高斯生成模型：\n- 顶层潜在状态 $s_t \\in \\mathbb{R}^n$ 通过线性映射 $A \\in \\mathbb{R}^{n \\times n}$ 生成中间潜在状态 $x_t \\in \\mathbb{R}^n$。\n- 中间潜在状态 $x_t$ 通过线性映射 $C \\in \\mathbb{R}^{n \\times n}$ 生成观测值 $y_t \\in \\mathbb{R}^n$。\n- 每一层的噪声都是加性的高斯噪声。\n\n形式上，生成过程如下：\n$$\nx_t = A s_t + \\epsilon_x, \\quad \\epsilon_x \\sim \\mathcal{N}(0, \\Sigma_x),\n$$\n$$\ny_t = C x_t + \\epsilon_y, \\quad \\epsilon_y \\sim \\mathcal{N}(0, \\Sigma_y),\n$$\n并且 $s_t$ 的先验为\n$$\ns_t \\sim \\mathcal{N}(\\mu_s^0, \\Sigma_s).\n$$\n逆协方差（精度）为 $\\Pi_x = \\Sigma_x^{-1}$、$\\Pi_y = \\Sigma_y^{-1}$ 和 $\\Pi_s = \\Sigma_s^{-1}$。假设潜在原因 $s_t \\equiv s^\\star$ 随时间恒定，且 $\\Sigma_x$、$\\Sigma_y$ 和 $\\Sigma_s$ 不随时间变化。设一个类注意增益 $\\gamma > 0$ 通过 $\\Pi_y^{\\mathrm{eff}} = \\gamma \\Pi_y$ 调节有效感觉精度。\n\n定义内部估计 $\\hat{s}_t$ 和 $\\hat{x}_t$，并假设预测编码更新来自于在拉普拉斯近似下对变分自由能（VFE）的梯度下降。反馈信号传递预测 $\\hat{x}_t^{\\mathrm{pred}} = A \\hat{s}_t$ 和 $\\hat{y}_t^{\\mathrm{pred}} = C \\hat{x}_t$。前馈信号传递精度加权的预测误差，其中感觉预测误差为 $e_y = y_t - \\hat{y}_t^{\\mathrm{pred}}$，中间层预测误差为 $e_x = \\hat{x}_t - \\hat{x}_t^{\\mathrm{pred}}$。先验偏差为 $e_s = \\hat{s}_t - \\mu_s^0$。\n\n您的任务：\n- 基于上述基础，为 $\\hat{x}_t$ 和 $\\hat{s}_t$ 推导离散时间梯度下降更新规则，这些规则能够最小化 VFE，并与“反馈传递预测，前馈传递精度加权的预测误差”的规则保持一致。\n- 实现一个模拟器，该模拟器在 $T$ 个步骤中为固定的 $A$、$C$ 和 $s^\\star$ 演化内部估计，同时在每个时间步从生成模型中生成带有独立高斯噪声的观测值。\n- 根据预测和预测误差之间的相互作用，定义一个意识内容浮现标准（CCEC）：\n    - 设精度加权的感觉误差范数为 $\\| \\Pi_y^{\\mathrm{eff}} e_y \\|_2$，精度加权的中层误差范数为 $\\| \\Pi_x e_x \\|_2$。\n    - 使用针对线性高斯模型的拉普拉斯近似来近似顶层的后验精度：\n      $$\n      \\Lambda_s = \\Pi_s + A^\\top \\Pi_x A, \\quad \\Sigma_s^{\\mathrm{post}} = \\Lambda_s^{-1}.\n      $$\n      高斯顶层后验的微分熵为\n      $$\n      H_s = \\frac{1}{2} \\ln\\left((2\\pi e)^n \\det(\\Sigma_s^{\\mathrm{post}})\\right).\n      $$\n    - 如果在时间 $t$ 同时满足以下所有条件，则称意识内容浮现：\n        1. $\\| \\Pi_y^{\\mathrm{eff}} e_{y,t} \\|_2 \\le \\varepsilon_{\\mathrm{low}}$,\n        2. $\\| \\Pi_x e_{x,t} \\|_2 \\le \\varepsilon_{\\mathrm{low}}$,\n        3. $\\| \\hat{s}_t - s^\\star \\|_2 \\le \\delta_s$,\n        4. $H_s \\le H_{\\mathrm{thresh}}$.\n      如果在 $T$ 步模拟中，这组不等式能连续保持至少 $L$ 个时间步，则宣布该试验中出现了意识内容。\n\n您的程序必须：\n- 使用 $n=2$，$A = I_2$ 和 $C = I_2$，其中 $I_2$ 是 $2\\times 2$ 的单位矩阵。\n- 使用固定的 $s^\\star = [1.0, -1.0]^\\top$ 和初始内部估计 $\\hat{s}_0 = [0.0, 0.0]^\\top$、$\\hat{x}_0 = [0.0, 0.0]^\\top$。\n- 在每个时间步抽取独立的高斯噪声：$\\epsilon_x \\sim \\mathcal{N}(0, \\Sigma_x)$、$\\epsilon_y \\sim \\mathcal{N}(0, \\Sigma_y)$，并设置随机种子以确保可复现性，从而使您的答案是确定性的。\n- 使用步长 $\\alpha_x$ 和 $\\alpha_s$ 实现推导出的离散时间更新。\n- 对于每个测试用例，返回一个布尔值，指示在 CCEC 标准下是否有意识内容浮现。\n\n测试套件：\n- 所有测试的通用固定量：维度 $n=2$，$A=I_2$，$C=I_2$，$s^\\star = [1.0,-1.0]^\\top$，初始 $\\hat{s}_0=[0,0]^\\top$，$\\hat{x}_0=[0,0]^\\top$，$T=80$，$L=5$，$\\varepsilon_{\\mathrm{low}}=0.2$，$\\delta_s=0.25$，$H_{\\mathrm{thresh}}=0.5$。\n- 四个测试用例在噪声尺度、先验、注意增益和更新率上有所不同，具体指定为元组 $(\\mu_s^0, \\sigma_y, \\sigma_x, \\sigma_s, \\gamma, \\alpha_x, \\alpha_s)$：\n    1. 案例1（理想路径）：$( [0.0,0.0], 0.2, 0.3, 1.0, 1.0, 0.35, 0.25 )$。\n    2. 案例2（低有效感觉精度）：$( [0.0,0.0], 1.5, 1.0, 1.0, 0.05, 0.35, 0.25 )$。\n    3. 案例3（弱反馈更新）：$( [0.0,0.0], 0.2, 0.3, 1.0, 1.0, 0.35, 0.02 )$。\n    4. 案例4（占主导地位的错误先验）：$( [3.0,3.0], 0.2, 0.3, 0.1, 1.0, 0.35, 0.25 )$。\n\n实现细节：\n- 为每个测试用例设置 $\\Sigma_y = \\sigma_y^2 I_2$、$\\Sigma_x = \\sigma_x^2 I_2$ 和 $\\Sigma_s = \\sigma_s^2 I_2$，以及相应的精度 $\\Pi_y = \\Sigma_y^{-1}$、$\\Pi_x = \\Sigma_x^{-1}$、$\\Pi_s = \\Sigma_s^{-1}$ 和 $\\Pi_y^{\\mathrm{eff}} = \\gamma \\Pi_y$。\n- 在每个时间步，生成 $x_t = A s^\\star + \\epsilon_x$ 和 $y_t = C x_t + \\epsilon_y$，并根据推导的预测编码规则更新 $\\hat{x}_t$ 和 $\\hat{s}_t$。\n\n要求的最终程序输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[True,False,True,False]”），按上面列出的顺序对应四个测试用例。",
            "solution": "用户提供了一个计算神经科学领域中明确定义的问题，其理论基础是预测编码。任务是为一个分层生成模型推导更新规则，实现一个模拟，并应用一个特定的标准来判断意识内容的浮现。该问题在科学上是合理的，自成体系，并且在算法上是明确的。\n\n### 1. 从变分自由能推导更新规则\n\n预测编码框架的核心是最小化变分自由能（VFE），对于线性高斯模型，在拉普拉斯近似下，这等同于最小化一个由精度加权的平方预测误差之和定义的能量函数。\n\n生成模型由以下部分给出：\n- 先验：$p(s_t) = \\mathcal{N}(s_t | \\mu_s^0, \\Sigma_s)$\n- 似然（层级1）：$p(x_t|s_t) = \\mathcal{N}(x_t | A s_t, \\Sigma_x)$\n- 似然（层级2）：$p(y_t|x_t) = \\mathcal{N}(y_t | C x_t, \\Sigma_y)$\n\nVFE，记为 $F$，可以表示为内部估计 $\\hat{s}_t$ 和 $\\hat{x}_t$ 的函数。目标是找到最小化该量的估计值。VFE 与由各自精度加权的误差平方和成正比。感觉精度 $\\Pi_y = \\Sigma_y^{-1}$ 受注意增益 $\\gamma$ 调制，产生有效精度 $\\Pi_y^{\\mathrm{eff}} = \\gamma \\Pi_y$。\n\n待最小化的 VFE 为：\n$$\nF(\\hat{s}_t, \\hat{x}_t) = \\frac{1}{2} (y_t - C\\hat{x}_t)^\\top \\Pi_y^{\\mathrm{eff}} (y_t - C\\hat{x}_t) + \\frac{1}{2} (\\hat{x}_t - A\\hat{s}_t)^\\top \\Pi_x (\\hat{x}_t - A\\hat{s}_t) + \\frac{1}{2} (\\hat{s}_t - \\mu_s^0)^\\top \\Pi_s (\\hat{s}_t - \\mu_s^0)\n$$\n我们使用梯度下降法推导 $\\hat{x}_t$ 和 $\\hat{s}_t$ 的更新规则。更新方向为 $F$ 的负梯度方向：\n$$\n\\hat{x}_{t+1} = \\hat{x}_t - \\alpha_x \\frac{\\partial F}{\\partial \\hat{x}_t}\n$$\n$$\n\\hat{s}_{t+1} = \\hat{s}_t - \\alpha_s \\frac{\\partial F}{\\partial \\hat{s}_t}\n$$\n其中 $\\alpha_x$ 和 $\\alpha_s$ 是步长（学习率）。\n\n首先，我们计算 $F$ 对 $\\hat{x}_t$ 的偏导数：\n$$\n\\frac{\\partial F}{\\partial \\hat{x}_t} = \\frac{\\partial}{\\partial \\hat{x}_t} \\left[ \\frac{1}{2} (y_t - C\\hat{x}_t)^\\top \\Pi_y^{\\mathrm{eff}} (y_t - C\\hat{x}_t) + \\frac{1}{2} (\\hat{x}_t - A\\hat{s}_t)^\\top \\Pi_x (\\hat{x}_t - A\\hat{s}_t) \\right]\n$$\n使用二次型的恒等式 $\\frac{\\partial}{\\partial v} (z - Mv)^\\top W (z-Mv) = -2 M^\\top W (z-Mv)$，我们得到：\n$$\n\\frac{\\partial F}{\\partial \\hat{x}_t} = -C^\\top \\Pi_y^{\\mathrm{eff}} (y_t - C\\hat{x}_t) + \\Pi_x (\\hat{x}_t - A\\hat{s}_t)\n$$\n将预测误差定义为 $e_{y,t} = y_t - C\\hat{x}_t$ 和 $e_{x,t} = \\hat{x}_t - A\\hat{s}_t$，梯度为：\n$$\n\\frac{\\partial F}{\\partial \\hat{x}_t} = \\Pi_x e_{x,t} - C^\\top \\Pi_y^{\\mathrm{eff}} e_{y,t}\n$$\n因此，$\\hat{x}_t$ 的更新规则为：\n$$\n\\hat{x}_{t+1} = \\hat{x}_t - \\alpha_x (\\Pi_x e_{x,t} - C^\\top \\Pi_y^{\\mathrm{eff}} e_{y,t}) = \\hat{x}_t + \\alpha_x (C^\\top \\Pi_y^{\\mathrm{eff}} e_{y,t} - \\Pi_x e_{x,t})\n$$\n此更新调整 $\\hat{x}_t$ 以减少其在感觉层面造成的误差（含 $e_{y,t}$ 的项）以及它相对于上层预测所代表的误差（含 $e_{x,t}$ 的项）。\n\n接下来，我们计算对 $\\hat{s}_t$ 的偏导数：\n$$\n\\frac{\\partial F}{\\partial \\hat{s}_t} = \\frac{\\partial}{\\partial \\hat{s}_t} \\left[ \\frac{1}{2} (\\hat{x}_t - A\\hat{s}_t)^\\top \\Pi_x (\\hat{x}_t - A\\hat{s}_t) + \\frac{1}{2} (\\hat{s}_t - \\mu_s^0)^\\top \\Pi_s (\\hat{s}_t - \\mu_s^0) \\right]\n$$\n这得到：\n$$\n\\frac{\\partial F}{\\partial \\hat{s}_t} = -A^\\top \\Pi_x (\\hat{x}_t - A\\hat{s}_t) + \\Pi_s (\\hat{s}_t - \\mu_s^0)\n$$\n将先验偏差定义为 $e_{s,t} = \\hat{s}_t - \\mu_s^0$，梯度为：\n$$\n\\frac{\\partial F}{\\partial \\hat{s}_t} = \\Pi_s e_{s,t} - A^\\top \\Pi_x e_{x,t}\n$$\n$\\hat{s}_t$ 的更新规则为：\n$$\n\\hat{s}_{t+1} = \\hat{s}_t - \\alpha_s (\\Pi_s e_{s,t} - A^\\top \\Pi_x e_{x,t}) = \\hat{s}_t + \\alpha_s (A^\\top \\Pi_x e_{x,t} - \\Pi_s e_{s,t})\n$$\n此更新调整 $\\hat{s}_t$ 以更好地预测下一层的状态（含 $e_{x,t}$ 的项），同时受其先验的正则化（含 $e_{s,t}$ 的项）。这些推导出的规则与预测编码更新的规范形式一致。\n\n### 2. 模拟与意识内容浮现标准（CCEC）\n\n模拟过程在 $T=80$ 个时间步上演化内部估计 $\\hat{x}_t$ 和 $\\hat{s}_t$。在每一步中，从具有固定潜在原因 $s^\\star$ 的模型中生成一个新的观测值 $y_t$。然后评估 CCEC。\n\nCCEC 要求四个条件同时满足至少 $L=5$ 个连续时间步。对于给定的时间步 $t$，这些条件是：\n1.  **低感觉预测误差：** $\\| \\Pi_y^{\\mathrm{eff}} e_{y,t} \\|_2 \\le \\varepsilon_{\\mathrm{low}}$。这衡量了模型的感觉预测是否准确，并由有效感觉精度加权。这里，$\\varepsilon_{\\mathrm{low}}=0.2$。\n2.  **低层级预测误差：** $\\| \\Pi_x e_{x,t} \\|_2 \\le \\varepsilon_{\\mathrm{low}}$。这衡量了中层表示是否能被顶层原因很好地解释，并由中层精度加权。\n3.  **准确的顶层估计：** $\\| \\hat{s}_t - s^\\star \\|_2 \\le \\delta_s$。这检查模型的最高层估计是否已收敛到感觉的真实潜在原因。这里，$\\delta_s=0.25$。\n4.  **高后验精度（低熵）：** $H_s \\le H_{\\mathrm{thresh}}$。后验精度反映了对顶层估计的置信度。更精确的后验对应于更低的熵。计算了 $s$ 的高斯后验的微分熵 $H_s$。这里，$H_{\\mathrm{thresh}}=0.5$。\n\n在拉普拉斯近似下，后验精度为 $\\Lambda_s = \\Pi_s + A^\\top \\Pi_x A$。后验协方差为 $\\Sigma_s^{\\mathrm{post}} = \\Lambda_s^{-1}$。对于本问题，其中 $n=2$，$A=I_2$，且精度是单位矩阵的标量倍数（$\\Pi_s = \\frac{1}{\\sigma_s^2}I_2$，$\\Pi_x = \\frac{1}{\\sigma_x^2}I_2$），每个测试用例的熵是恒定的：\n$$\n\\Lambda_s = \\left(\\frac{1}{\\sigma_s^2} + \\frac{1}{\\sigma_x^2}\\right) I_2\n$$\n$$\n\\det(\\Sigma_s^{\\mathrm{post}}) = \\det(\\Lambda_s^{-1}) = \\left(\\left(\\frac{1}{\\sigma_s^2} + \\frac{1}{\\sigma_x^2}\\right)^{-1}\\right)^2\n$$\n$$\nH_s = \\frac{1}{2} \\ln\\left((2\\pi e)^n \\det(\\Sigma_s^{\\mathrm{post}})\\right) = \\ln\\left(2\\pi e \\left(\\frac{1}{\\sigma_s^2} + \\frac{1}{\\sigma_x^2}\\right)^{-1}\\right) = 1 + \\ln(2\\pi) - \\ln\\left(\\frac{1}{\\sigma_s^2} + \\frac{1}{\\sigma_x^2}\\right)\n$$\n这个条件作为一个静态过滤器。对于案例2，其中 $\\sigma_x=1.0$ 和 $\\sigma_s=1.0$，则 $H_s = 1 + \\ln(2\\pi) - \\ln(2) \\approx 2.14 > 0.5$。因此，案例2永远无法满足CCEC。对于所有其他案例，此条件均得到满足。然后，模拟通过应用推导出的更新规则并动态检查其余三个条件来继续进行。",
            "answer": "```python\n# The final, self-contained, and runnable Python code.\nimport numpy as np\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation for a given set of parameters.\n\n    Args:\n        params (tuple): A tuple containing the parameters for the simulation:\n                        (mu_s0, sigma_y, sigma_x, sigma_s, gamma, alpha_x, alpha_s).\n\n    Returns:\n        bool: True if conscious content emerges, False otherwise.\n    \"\"\"\n    # Unpack parameters\n    mu_s0, sigma_y, sigma_x, sigma_s, gamma, alpha_x, alpha_s = params\n    mu_s0 = np.array(mu_s0, dtype=np.float64)\n\n    # Common fixed parameters\n    n = 2\n    T = 80\n    L = 5\n    eps_low = 0.2\n    delta_s = 0.25\n    H_thresh = 0.5\n    s_star = np.array([1.0, -1.0], dtype=np.float64)\n    A = np.identity(n, dtype=np.float64)\n    C = np.identity(n, dtype=np.float64)\n\n    # Initial internal estimates\n    s_hat = np.array([0.0, 0.0], dtype=np.float64)\n    x_hat = np.array([0.0, 0.0], dtype=np.float64)\n\n    # Precision matrices (using np.float64 for stability)\n    sigma_y, sigma_x, sigma_s = np.float64(sigma_y), np.float64(sigma_x), np.float64(sigma_s)\n    \n    # Sigmas are squared, so they must be non-zero.\n    if sigma_y == 0.0 or sigma_x == 0.0 or sigma_s == 0.0:\n        return False\n        \n    Pi_y = (1.0 / sigma_y**2) * np.identity(n)\n    Pi_x = (1.0 / sigma_x**2) * np.identity(n)\n    Pi_s = (1.0 / sigma_s**2) * np.identity(n)\n    Pi_y_eff = gamma * Pi_y\n\n    # --- CCEC Condition 4: Entropy ---\n    # This is constant for a given simulation. It can be pre-calculated.\n    pi_s_scalar = 1.0 / sigma_s**2\n    pi_x_scalar = 1.0 / sigma_x**2\n    H_s = (n / 2.0) * (1.0 + np.log(2.0 * np.pi)) - (n/2.0) * np.log(pi_s_scalar + pi_x_scalar)\n    \n    if H_s > H_thresh:\n        return False\n\n    consecutive_success_count = 0\n\n    # Simulation loop over T time steps\n    for _ in range(T):\n        # 1. Generate new observation y_t from the generative model\n        eps_x = np.random.normal(0, sigma_x, size=n)\n        x_t = A @ s_star + eps_x\n        eps_y = np.random.normal(0, sigma_y, size=n)\n        y_t = C @ x_t + eps_y\n\n        # 2. Compute prediction errors based on current estimates (from previous step)\n        e_y = y_t - C @ x_hat\n        e_x = x_hat - A @ s_hat\n        e_s = s_hat - mu_s0\n\n        # 3. Update internal estimates via gradient descent\n        # Gradients are grad_F_x = Pi_x*e_x - C.T*Pi_y_eff*e_y\n        # and grad_F_s = Pi_s*e_s - A.T*Pi_x*e_x.\n        # Updates are in the negative gradient direction.\n        x_hat_next = x_hat + alpha_x * (C.T @ Pi_y_eff @ e_y - Pi_x @ e_x)\n        s_hat_next = s_hat + alpha_s * (A.T @ Pi_x @ e_x - Pi_s @ e_s)\n        \n        # 4. Check CCEC conditions.\n        # The error criteria use errors computed before the update.\n        # The state criterion uses the state after the update.\n        cond1 = np.linalg.norm(Pi_y_eff @ e_y) = eps_low\n        cond2 = np.linalg.norm(Pi_x @ e_x) = eps_low\n        cond3 = np.linalg.norm(s_hat_next - s_star) = delta_s\n        # cond4 (H_s) is static and was checked before the loop.\n\n        if cond1 and cond2 and cond3:\n            consecutive_success_count += 1\n        else:\n            consecutive_success_count = 0\n        \n        if consecutive_success_count >= L:\n            return True\n\n        # 5. Advance the state for the next time step\n        x_hat = x_hat_next\n        s_hat = s_hat_next\n\n    # If the loop completes without meeting the criterion for L steps\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Set a fixed random seed for reproducibility of the results.\n    np.random.seed(0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple is (mu_s^0, sigma_y, sigma_x, sigma_s, gamma, alpha_x, alpha_s).\n    test_cases = [\n        # Case 1 (happy path)\n        ([0.0, 0.0], 0.2, 0.3, 1.0, 1.0, 0.35, 0.25),\n        # Case 2 (low effective sensory precision)\n        ([0.0, 0.0], 1.5, 1.0, 1.0, 0.05, 0.35, 0.25),\n        # Case 3 (weak feedback updating)\n        ([0.0, 0.0], 0.2, 0.3, 1.0, 1.0, 0.35, 0.02),\n        # Case 4 (dominating incorrect prior)\n        ([3.0, 3.0], 0.2, 0.3, 0.1, 1.0, 0.35, 0.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}