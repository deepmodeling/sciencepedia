{
    "hands_on_practices": [
        {
            "introduction": "第一个实践是建模的基础练习。我们不从复杂的分子机制入手，而是纯粹从一系列定义S形响应曲线的经验属性出发，推导出广泛使用的希尔方程。这种方法有助于阐明该唯象模型背后的数学假设，并为其在描述协同现象中的应用和局限性提供一个批判性的视角 。",
            "id": "3884108",
            "problem": "考虑一个由配体激活的变构酶，其单一可观测输出随游离配体浓度 $[L]$ 单调增加，并在 $[L]$ 非常大时饱和于一个最大值。令分数激活（也称分数占据）表示为 $\\theta([L])$，定义为酶处于其激活状态的概率。假设以下性质，这些性质源于在许多协同结合和激活系统中观察到的S型响应的经验特征：\n\n1. 相对于特征浓度 $K$ 的形状尺度不变性：存在一个无量纲函数 $f$，使得 $\\theta([L]) = f([L]/K)$，其中 $K$ 由半激活条件 $\\theta(K) = \\tfrac{1}{2}$ 定义。量 $[L]$ 和 $K$ 均以摩尔浓度 (M) 表示。\n\n2. 与质量作用激活一致的适当渐近极限：\n   $$\\lim_{[L]\\to 0} \\theta([L]) = 0, \\quad \\lim_{[L]\\to \\infty} \\theta([L]) = 1.$$\n\n3. 在对数浓度轴上关于半激活点的对称性：对于所有正数 $x$，函数满足\n   $$f(x) + f\\!\\left(\\frac{1}{x}\\right) = 1,$$\n   这意味着对数优势比 $\\ln\\!\\big(\\theta([L])/(1-\\theta([L]))\\big)$ 是关于 $\\ln([L]/K)$ 的奇函数。\n\n4. 在动态范围内，对数优势比相对于配体浓度的相对变化的对数灵敏度为常数，由一个正常数 $n_H$（希尔系数）表征：$\\ln\\!\\big(\\theta([L])/(1-\\theta([L]))\\big)$ 对 $\\ln([L]/K)$ 的斜率与 $[L]$ 无关，在半激活点等于 $n_H$，并且根据假设，在整个动态范围内都等于 $n_H$。\n\n仅从这些性质以及分数激活和对数优势比的标准定义出发，推导与所有四个性质一致的、用 $[L]$、$K$ 和 $n_H$ 表示的 $\\theta([L])$ 的唯一解析表达式。将 $[L]$ 和 $K$ 以摩尔浓度 (M) 表示。然后，基于变构的机理学第一性原理，讨论这种作为唯象拟合的经验表示的局限性，包括其与变构的微观质量作用模型的关系。最终答案必须是 $\\theta([L])$ 的单一封闭形式表达式；无需四舍五入。",
            "solution": "目标是推导出一个与给定性质一致的 $\\theta([L])$ 表达式。我们首先重申将要使用的基本数学结构。分数激活 $\\theta([L])$ 是一个介于 $0$ 和 $1$ 之间的无量纲量，解释为在给定配体浓度 $[L]$ 下酶处于激活状态的概率。对数优势比，也称为 logit，定义为\n$$\\mathrm{logit}(\\theta) = \\ln\\!\\left(\\frac{\\theta}{1-\\theta}\\right)。$$\n\n根据性质1（尺度不变性），对于某个函数 $f$ 且 $\\theta(K)=\\tfrac{1}{2}$，有 $\\theta([L]) = f([L]/K)$。根据性质2（适当的渐近性），当 $x\\to 0$ 时 $f(x)\\to 0$，当 $x\\to \\infty$ 时 $f(x)\\to 1$。根据性质3（对称性），对于所有 $x0$：\n$$f(x) + f\\!\\left(\\frac{1}{x}\\right) = 1。$$\n这种对称性意味着\n$$\\frac{f(x)}{1-f(x)} = \\left(\\frac{1}{f(1/x)}\\right) - 1 = \\frac{f(x)}{f(1/x)}。$$\n取对数，对称性条件可以重写为 $f(x)$ 的对数优势比的形式：\n$$\\ln\\!\\left(\\frac{f(x)}{1-f(x)}\\right) = -\\,\\ln\\!\\left(\\frac{f(1/x)}{1-f(1/x)}\\right),$$\n这表明函数 $g(y) \\equiv \\ln\\!\\left(\\frac{f(\\exp(y))}{1-f(\\exp(y))}\\right)$ 是关于 $y$ 的奇函数，即 $g(-y) = -g(y)$。用原始变量表示，这意味着\n$$\\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right)$$\n是关于 $\\ln([L]/K)$ 的奇函数。\n\n根据性质4（对数优势比的恒定对数灵敏度），我们断言对数优势比相对于 $\\ln([L]/K)$ 的斜率与 $[L]$ 无关，在半激活点 $\\theta(K)=\\tfrac{1}{2}$ 处等于 $n_H$，并且根据假设，在整个动态范围内都等于 $n_H$。令 $y \\equiv \\ln([L]/K)$，并定义\n$$g(y) \\equiv \\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right) = \\ln\\!\\left(\\frac{f(\\exp(y))}{1-f(\\exp(y))}\\right)。$$\n性质4表明\n$$\\frac{d g(y)}{d y} = n_H,$$\n对于动态范围内的所有 $y$。这是一个具有常数斜率的一阶常微分方程。对 $y$ 积分得到\n$$g(y) = n_H\\,y + C,$$\n其中 $C$ 是一个积分常数。性质3指出 $g(y)$ 是一个奇函数，这意味着 $g(0)=0$。在 $y=0$（对应于 $[L]=K$ 和 $\\theta=\\tfrac{1}{2}$）处求值，我们发现 $g(0) = \\ln\\!\\left(\\frac{1/2}{1-1/2}\\right) = \\ln(1) = 0$，因此 $C=0$。所以，\n$$\\ln\\!\\left(\\frac{\\theta([L])}{1-\\theta([L])}\\right) = n_H \\,\\ln\\!\\left(\\frac{[L]}{K}\\right)。$$\n\n对两边取指数，得到\n$$\\frac{\\theta([L])}{1-\\theta([L])} = \\left(\\frac{[L]}{K}\\right)^{n_H}。$$\n求解 $\\theta([L])$，\n$$\\theta([L]) = \\frac{\\left(\\frac{[L]}{K}\\right)^{n_H}}{1+\\left(\\frac{[L]}{K}\\right)^{n_H}} = \\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}}。$$\n这个表达式满足相对于 $K$ 的尺度不变性，得出 $\\theta(K)=\\tfrac{1}{2}$，并遵循渐近性：当 $[L]\\to 0$ 时，分子相对于分母可以忽略不计，得到 $\\theta\\to 0$；当 $[L]\\to \\infty$ 时，分母由 $[L]^{n_H}$ 主导，得到 $\\theta\\to 1$。此外，对称性 $f(x)+f(1/x)=1$ 也得到满足，因为\n$$\\frac{x^{n_H}}{1+x^{n_H}} + \\frac{(1/x)^{n_H}}{1+(1/x)^{n_H}} = \\frac{x^{n_H}}{1+x^{n_H}} + \\frac{1}{1+x^{n_H}} = 1。$$\n\n因此，在所述假设下，与所有四个性质一致的唯一解析表达式是\n$$\\theta([L]) = \\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}},$$\n其中 $[L]$ 和 $K$ 以摩尔浓度 (M) 表示，而 $\\theta$ 是无量纲的。\n\n作为唯象拟合的局限性及其与机理变构的关系：\n\n- $n_H$ 的微观可解释性：参数 $n_H$ 在此被定义为在动态范围内对数优势比对 $\\ln([L]/K)$ 的恒定斜率。在源自微观质量作用模型的真实变构系统中，例如 Monod–Wyman–Changeux (MWC) 模型或 Koshland–Némethy–Filmer (KNF) 模型，该斜率通常随 $[L]$ 变化。希尔系数等于半激活点的斜率，但通常不等于结合位点的数量，也不会在整个 $[L]$ 范围内保持恒定。因此，$n_H$ 是一个捕捉表观协同性的唯象参数，但不能唯一地映射到特定的机制或位点数量。\n\n- 热力学一致性与微观状态解析：希尔形式将多状态结合和构象平衡集总成一个单一的有效等温线。它没有编码通过枚举与微观可逆性和细致平衡一致的微观状态而产生的结合多项式。因此，希尔等温线可能违反由异促变构中的热力学连锁和多配体耦合所施加的约束，并且除了通过平均斜率外，它无法预测诸如顺序结合步骤、负协同性或状态依赖性亲和力变化等精细特征。\n\n- 调节剂和效应剂的作用：在机理模型中，变构调节剂会改变特定的平衡常数（例如，构象能或位点亲和力）。希尔方程可以模仿左移或右移（$K$ 的有效变化）和表观斜率变化（$n_H$ 的有效变化），但无法厘清这些变化是源于构象平衡的改变、位点亲和力的改变，还是活性位点数量的变化。因此，它对突变效应和效应剂特异性扰动的预测能力有限。\n\n- 配体耗尽和有限的受体浓度：希尔形式假设 $[L]$ 实际上是恒定的（浴近似）。在配体并非大量过量的细胞环境中，结合会耗尽游离配体，正确的等温线涉及守恒约束。希尔形式没有包含这些约束，在配体和受体浓度相当的情况下可能会错误估计激活程度。\n\n- 全局斜率恒定性：推导过程假设了对数优势比相对于 $\\ln([L]/K)$ 的斜率是恒定的。真实的协同系统通常表现出非恒定的对数灵敏度；例如，陡峭度可能在半激活点附近最大，而在两端则较平缓。因此，希尔形式可能会高估或低估远离中间浓度范围的灵敏度，并可能在系统模型中错误地表示噪声过滤和超敏性。\n\n总之，所推导的表达式是一个紧凑的、尺度不变的S形曲线，通过 $n_H$ 捕捉了平均协同性，但它是唯象的，可能不符合微观质量作用约束，也无法提供对变构调控的机理见解。当需要机理解释或扰动的预测性建模时，应谨慎使用。",
            "answer": "$$\\boxed{\\frac{[L]^{n_H}}{K^{n_H} + [L]^{n_H}}}$$"
        },
        {
            "introduction": "在建立了协同性的数学描述之后，任何生物化学家或系统生物学家的一项关键技能，就是从实验数据中识别出这种行为。本实践侧重于酶动力学的图形诊断，比较非协同（双曲线）和协同（S形）体系在经典图谱上的特征。通过理解数据变换如何揭示潜在的动力学特性，你将培养出解读真实世界实验结果所需的直觉 。",
            "id": "3884132",
            "problem": "一位研究人员试图诊断一种酶是表现出典型的非协同性Michaelis–Menten行为的双曲动力学，还是表现出正变构（正协同性）的S型动力学。该酶催化一个单底物反应，初始速率 $v$ 是在一系列远低于底物耗尽范围的底物浓度 $[S]$ 下测量的。研究人员构建了三种诊断图：Eadie–Hofstee图（纵坐标为 $v$，横坐标为 $v/[S]$）、Lineweaver–Burk图（纵坐标为 $1/v$，横坐标为 $1/[S]$）和Hill图（纵坐标为 $\\log\\big(v/(V_{\\max}-v)\\big)$，横坐标为 $\\log [S]$，其中 $V_{\\max}$ 表示最大速度）。\n\n仅使用酶动力学公认的建模基础（底物与酶活性位点的质量作用结合、酶守恒以及初始速率条件）以及这三种变换的标准含义，选择正确陈述了这三种图谱中区分双曲动力学和S型动力学的定性特征的选项。您的答案必须针对每种图谱，指明其轨迹是线性的还是曲线的，斜率是恒定的还是随 $[S]$ 变化的，以及在从双曲动力学过渡到S型动力学时，变换中的相关截距是否保持不变。\n\nA. 双曲动力学：Eadie–Hofstee图在所有 $[S]$ 范围内完全线性，具有恒定的负斜率和为 $V_{\\max}$ 的y轴截距；Lineweaver–Burk图完全线性，具有正斜率和为 $1/V_{\\max}$ 的y轴截距；Hill图在其中心区域近似线性，斜率为 $1$。S型（正协同性）：Eadie–Hofstee图变为曲线（非线性）轨迹，斜率随 $[S]$ 变化，但y轴截距 $V_{\\max}$ 保持不变；Lineweaver–Burk图偏离线性，呈向上凸的曲率，但y轴截距 $1/V_{\\max}$ 保持不变；Hill图的中心斜率 $1$，并在低 $[S]$ 和高 $[S]$ 处弯曲。\n\nB. 双曲动力学：Eadie–Hofstee图线性，具有正斜率和等于 $K_M$ 的y轴截距；Lineweaver–Burk图为曲线；Hill图的斜率 $1$。S型（正协同性）：Eadie–Hofstee图保持线性；Lineweaver–Burk图变为完全线性；Hill图的斜率回到 $1$。\n\nC. 双曲动力学：Eadie–Hofstee图线性，具有负斜率和为 $V_{\\max}$ 的y轴截距；Lineweaver–Burk图线性，y轴截距为 $1/V_{\\max}$；Hill图的中心斜率 $1$。S型（正协同性）：Eadie–Hofstee图为曲线；Lineweaver–Burk图呈向下凹的曲率；Hill图在中心区域的斜率恰好为 $1$。\n\nD. 双曲动力学：由于饱和效应，Eadie–Hofstee图为曲线；Lineweaver–Burk图完全线性；Hill图的斜率 $\\approx 1$。S型（正协同性）：Eadie–Hofstee图变为线性，但斜率随 $[S]$ 变化；Lineweaver–Burk图保持完全线性；Hill图的斜率 $1$。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于酶动力学原理，问题阐述清晰，客观，并包含所有必要信息以得出唯一解，没有歧义或矛盾。\n\n我们将首先推导两种动力学模型——双曲（Michaelis–Menten）和S型（正协同性）——下每种诊断图的数学形式，然后根据这些推导评估每个选项。\n\n### 双曲（非协同性）动力学\n\n非协同性、单底物酶动力学的标准模型是Michaelis–Menten方程：\n$$ v = \\frac{V_{\\max} [S]}{K_M + [S]} $$\n其中 $v$ 是初始反应速率，$[S]$ 是底物浓度，$V_{\\max}$ 是最大速率，$K_M$ 是米氏常数。\n\n**1. Eadie–Hofstee图（$v$ 对 $v/[S]$）：**\n为了推导Eadie–Hofstee图的形式，我们对Michaelis–Menten方程进行代数重排。\n$$ v(K_M + [S]) = V_{\\max}[S] $$\n$$ vK_M + v[S] = V_{\\max}[S] $$\n将整个方程除以 $[S]$ 得：\n$$ \\frac{vK_M}{[S]} + v = V_{\\max} $$\n将其重排为线性方程 $y = mx + c$ 的形式，其中纵坐标为 $y=v$，横坐标为 $x=v/[S]$：\n$$ v = -K_M \\left(\\frac{v}{[S]}\\right) + V_{\\max} $$\n该方程描述了一条直线。\n- **轨迹：** 完全线性。\n- **斜率：** 斜率为常数，等于 $-K_M$，是一个负值。\n- **y轴截距：** 在 $v$ 轴上的截距（当 $v/[S] = 0$ 时）为 $V_{\\max}$。\n\n**2. Lineweaver–Burk图（$1/v$ 对 $1/[S]$）：**\n此图通过对Michaelis–Menten方程取倒数得到：\n$$ \\frac{1}{v} = \\frac{K_M + [S]}{V_{\\max}[S]} $$\n分离分子中的各项：\n$$ \\frac{1}{v} = \\frac{K_M}{V_{\\max}[S]} + \\frac{[S]}{V_{\\max}[S]} $$\n$$ \\frac{1}{v} = \\left(\\frac{K_M}{V_{\\max}}\\right) \\frac{1}{[S]} + \\frac{1}{V_{\\max}} $$\n该方程为线性形式 $y = mx + c$，其中纵坐标为 $y=1/v$，横坐标为 $x=1/[S]$。\n- **轨迹：** 完全线性。\n- **斜率：** 斜率为常数，等于 $K_M/V_{\\max}$，是一个正值。\n- **y轴截距：** 在 $1/v$ 轴上的截距（当 $1/[S] = 0$ 时）为 $1/V_{\\max}$。\n\n**3. Hill图（$\\log\\big(v/(V_{\\max}-v)\\big)$ 对 $\\log [S]$）：**\n对于非协同性动力学，Hill系数 $n_H$ 等于 $1$。可以用Hill方程的形式来证明这一点。首先，我们表示比率 $v/(V_{\\max}-v)$：\n$$ V_{\\max} - v = V_{\\max} - \\frac{V_{\\max}[S]}{K_M + [S]} = \\frac{V_{\\max}(K_M + [S]) - V_{\\max}[S]}{K_M + [S]} = \\frac{V_{\\max}K_M}{K_M + [S]} $$\n$$ \\frac{v}{V_{\\max}-v} = \\frac{V_{\\max}[S]/(K_M + [S])}{V_{\\max}K_M/(K_M + [S])} = \\frac{[S]}{K_M} $$\n对两边取对数：\n$$ \\log\\left(\\frac{v}{V_{\\max}-v}\\right) = \\log\\left(\\frac{[S]}{K_M}\\right) = \\log[S] - \\log K_M $$\n这是一个线性方程，其中纵坐标是 $\\log(v/(V_{\\max}-v))$，横坐标是 $\\log[S]$。\n- **轨迹：** 完全线性。\n- **斜率（Hill系数, $n_H$）：** 斜率恰好为 $1$。\n\n### S型（正协同性）动力学\n\n正协同性的最简单模型是Hill方程，其中Hill系数 $n_H$ 大于 $1$。\n$$ v = \\frac{V_{\\max} [S]^{n_H}}{K_{0.5}^{n_H} + [S]^{n_H}} $$\n这里，$K_{0.5}$ 是产生一半最大速率时的底物浓度。对于 $n_H > 1$，该方程产生一个 $v$ 对 $[S]$ 的S型曲线。\n\n**1. Eadie–Hofstee图（$v$ 对 $v/[S]$）：**\n图的变量是 $v = \\frac{V_{\\max} [S]^{n_H}}{K_{0.5}^{n_H} + [S]^{n_H}}$ 和 $\\frac{v}{[S]} = \\frac{V_{\\max} [S]^{n_H-1}}{K_{0.5}^{n_H} + [S]^{n_H}}$。当 $n_H > 1$ 时，$v$ 和 $v/[S]$ 之间的关系是非线性的。\n- **轨迹：** 该图是曲线（非线性）的。\n- **y轴截距：** 当 $[S] \\to \\infty$ 时，$v \\to V_{\\max}$ 且 $v/[S] \\to 0$。因此，该图在 $V_{\\max}$ 处与 $v$ 轴相交。y轴截距保持不变。\n- **斜率：** 斜率不是恒定的。对于正协同性，表观亲和力随底物结合而增加，意味着表观 $K_M$ 随 $[S]$ 的增加而减小。由于Eadie-Hofstee图的斜率与 $-K_{app}$ 相关，因此斜率沿曲线变化。轨迹是向上凹的。\n\n**2. Lineweaver–Burk图（$1/v$ 对 $1/[S]$）：**\n对Hill方程取倒数：\n$$ \\frac{1}{v} = \\frac{K_{0.5}^{n_H} + [S]^{n_H}}{V_{\\max} [S]^{n_H}} = \\frac{K_{0.5}^{n_H}}{V_{\\max}} \\left(\\frac{1}{[S]}\\right)^{n_H} + \\frac{1}{V_{\\max}} $$\n- **轨迹：** 由于 $n_H > 1$， $1/v$ 和 $1/[S]$ 之间的关系不是线性的。该图是一条曲线。具体来说，因为 $1/[S]$ 项的指数大于 $1$，曲线是凸的（向上弯曲）。\n- **y轴截距：** 当 $1/[S] \\to 0$（即 $[S] \\to \\infty$）时，$(1/[S])^{n_H}$ 项趋于 $0$，且 $1/v \\to 1/V_{\\max}$。y轴截距保持不变。\n\n**3. Hill图（$\\log\\big(v/(V_{\\max}-v)\\big)$ 对 $\\log [S]$）：**\nHill图本身就是由Hill方程构建的。通过对Hill方程的代数操作：\n$$ \\log\\left(\\frac{v}{V_{\\max}-v}\\right) = n_H \\log[S] - n_H \\log K_{0.5} $$\n- **斜率：** 如果酶完全遵循简单的Hill模型，该图将是一条斜率等于 $n_H$ 的直线。对于正协同性，$n_H > 1$。\n- **轨迹和细微之处：** 然而，简单的Hill方程是一个经验模型。更具机理性的模型（例如MWC、KNF）和实验数据显示，协同酶的Hill图不是一条单一的直线。相反，它具有特征性的S形，在极低和极高的底物浓度下会弯曲。在这些极端情况下的斜率接近 $1$，而图的中心、最线性的部分的斜率最大，等于Hill系数 $n_H$。因此，正协同性的特征是中心斜率大于 $1$，并在两端弯曲。\n\n### 选项评估\n\n**A. 双曲动力学：Eadie–Hofstee图在所有 $[S]$ 范围内完全线性，具有恒定的负斜率和为 $V_{\\max}$ 的y轴截距；Lineweaver–Burk图完全线性，具有正斜率和为 $1/V_{\\max}$ 的y轴截距；Hill图在其中心区域近似线性，斜率为 $1$。S型（正协同性）：Eadie–Hofstee图变为曲线（非线性）轨迹，斜率随 $[S]$ 变化，但y轴截距 $V_{\\max}$ 保持不变；Lineweaver–Burk图偏离线性，呈向上凸的曲率，但y轴截距 $1/V_{\\max}$ 保持不变；Hill图的中心斜率 $1$，并在低 $[S]$ 和高 $[S]$ 处弯曲。**\n\n- **双曲动力学描述：** 这与我们的推导完全匹配。E-H图是线性的，斜率为 $-K_M$，截距为 $V_{\\max}$。L-B图是线性的，斜率为 $K_M/V_{\\max}$，截距为 $1/V_{\\max}$。Hill图的斜率为 $1$。“在其中心区域近似线性”是一个实践性的陈述，但斜率值 $1$ 是关键信息，且是正确的。\n- **S型动力学描述：** 这也与我们的推导完全匹配。E-H图变为曲线，但保留 $V_{\\max}$ 截距。L-B图变为曲线（具体为向上凸），但保留 $1/V_{\\max}$ 截距。Hill图表现出正协同性的特征：中心斜率 $1$ 并在两端弯曲。\n- **结论：** 正确。\n\n**B. 双曲动力学：Eadie–Hofstee图线性，具有正斜率和等于 $K_M$ 的y轴截距；Lineweaver–Burk图为曲线；Hill图的斜率 $1$。S型（正协同性）：Eadie–Hofstee图保持线性；Lineweaver–Burk图变为完全线性；Hill图的斜率回到 $1$。**\n\n- **双曲动力学描述：** E-H图的斜率为负（$-K_M$），而不是正。其y轴截距是 $V_{\\max}$，而不是 $K_M$。L-B图是线性的，不是曲线。Hill图斜率为 $1$，而不是 $1$。此部分根本上是错误的。\n- **结论：** 不正确。\n\n**C. 双曲动力学：Eadie–Hofstee图线性，具有负斜率和为 $V_{\\max}$ 的y轴截距；Lineweaver–Burk图线性，y轴截距为 $1/V_{\\max}$；Hill图的中心斜率 $1$。S型（正协同性）：Eadie–Hofstee图为曲线；Lineweaver–Burk图呈向下凹的曲率；Hill图在中心区域的斜率恰好为 $1$。**\n\n- **S型动力学描述：** 正协同性的L-B图是向上凸的，而不是向下凹的。Hill图斜率恰好为 $1$ 将意味着没有协同性，与前提矛盾。\n- **结论：** 不正确。\n\n**D. 双曲动力学：由于饱和效应，Eadie–Hofstee图为曲线；Lineweaver–Burk图完全线性；Hill图的斜率 $\\approx 1$。S型（正协同性）：Eadie–Hofstee图变为线性，但斜率随 $[S]$ 变化；Lineweaver–Burk图保持完全线性；Hill图的斜率 $1$。**\n\n- **双曲动力学描述：** 对于Michaelis-Menten动力学，E-H图是线性的；这正是它的用途。说它是曲线是不正确的。\n- **S型动力学描述：** E-H图变为曲线，而不是线性。一个“线性”图不可能有一个“随 $[S]$ 变化”的斜率；这是一个自相矛盾的说法。L-B图变为曲线，而不是保持线性。Hill图斜率 $1$ 表示无协同性，而不是正协同性。\n- **结论：** 不正确。\n\n基于严谨的推导，只有选项A正确描述了两种动力学方案下三种图谱的区别特征。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "这最后一个实践将我们对变构的理解从单分子水平提升到系统水平。我们探讨一个变构酶的急剧、开关般的响应如何在一个更大的生物回路中充当关键部件。通过一个涉及分岔分析的计算练习，你将发现将变构酶嵌入正反馈回路中如何能产生像双稳态和迟滞这样复杂的动态行为，这些行为是细胞决策和信号处理的基础 。",
            "id": "3884074",
            "problem": "考虑一种酶，根据 Monod–Wyman–Changeux (MWC) 变构模型，该酶可以存在于两种构象状态：松弛态 $R$ 和紧张态 $T$。设 $x$ 表示变构激活剂的无量纲浓度（通过松弛态解离常数进行缩放），并假设该酶会产生活性剂，从而形成正反馈。处于 $R$ 状态的酶所占的比例，记为 $f_R(x)$，由基于质量作用结合的标准 MWC 占有率公式给出。其中 $L$ 是变构常数（在没有配体时 $T/R$ 的比率），$m$ 是每个酶上相同结合位点的数量， $K_R$ 和 $K_T$ 分别是激活剂与 $R$ 状态和 $T$ 状态的解离常数。假设 $K_T \\gg K_R$，以模拟优先稳定 $R$ 状态的激活剂。\n\n设激活剂的产生-降解动力学由常微分方程 (ODE) 建模\n$$\n\\frac{dx}{dt} = k_b + k_p\\, f_R(x; L, m, K_R, K_T) - k_d\\, x,\n$$\n其中 $k_b \\ge 0$ 是基础生产速率（无量纲），$k_p \\ge 0$ 是最大活化诱导生产速率（无量纲），$k_d  0$ 是一阶降解速率（无量纲）。系统在满足以下条件的 $x^\\ast$ 值处呈现稳态\n$$\n0 = k_b + k_p\\, f_R(x^\\ast; L, m, K_R, K_T) - k_d\\, x^\\ast.\n$$\n如果雅可比矩阵（右侧关于 $x$ 的导数）在 $x^\\ast$ 处的值为负，则稳态 $x^\\ast$ 是局部稳定的：\n$$\nJ(x^\\ast) = k_p\\, \\frac{df_R}{dx}(x^\\ast; L, m, K_R, K_T) - k_d  0.\n$$\n\n任务：\n1. 从 Monod–Wyman–Changeux (MWC) 模型假设和质量作用结合出发，推导 $f_R(x; L, m, K_R, K_T)$ 及其导数 $\\frac{df_R}{dx}(x; L, m, K_R, K_T)$ 作为 $x$ 的函数计算表达式。\n2. 使用这些表达式和上述 ODE，对给定的参数集实现数值分岔分析。具体来说：\n   - 计算给定参数集的所有非负实数稳态 $x^\\ast$，并使用 $J(x^\\ast)$ 对其稳定性进行分类。\n   - 确定系统对于该参数集是否是双稳态的（两个不同的稳定稳态被一个不稳定的稳态隔开）。\n3. 通过在固定的 $(L, m, K_R, K_T, k_b)$ 条件下，扫描 $(k_p, k_d)$ 参数平面上的一个小网格，来绘制双稳态区域。返回双稳态网格点的数量。\n4. 通过在 $k_p$ 中进行参数扫描来说明磁滞现象：\n   - 进行正向扫描：将 $k_p$ 从一个低值逐步增加到一个高值，在每一步通过连续性选择稳定稳态（选择离上一步平衡点最近的稳定平衡点）。记录所跟踪的稳定分支消失时的第一个 $k_p$ 值（跳到另一个分支）。\n   - 进行反向扫描：将 $k_p$ 从一个高值逐步降低到一个低值，类似地跟踪稳定分支并记录跳变时的 $k_p$ 值。\n   - 计算磁滞宽度，即反向扫描跳变和正向扫描跳变在 $k_p$ 上的差值。如果任一扫描中均未发生跳变，则将磁滞宽度定义为 $0$。\n由于缩放，所有变量都是无量纲的；不涉及物理单位。在有限域 $x \\in [0, x_{\\max}]$ 上使用鲁棒的数值求根区间法，其中 $x_{\\max}$ 选择得足够大以包含所有交点。如果 $k_b + k_p \\le 0$，则将系统视为除了基础生产外没有其他生产，并相应处理。在整个过程中确保 $x$ 的非负性。\n\n测试套件：\n提供三个参数集以测试不同方面：\n- 情况 A（理想路径，单稳态）：$(L, m, K_R, K_T, k_b) = (10, 3, 1.0, 10.0, 0.01)$；在 $k_p \\in \\{0.2, 0.4, 0.6\\}$ 和 $k_d \\in \\{0.8, 1.0, 1.2\\}$ 的 $3 \\times 3$ 网格上扫描 $(k_p, k_d)$；在 $k_p$ 上从 $0.0$ 到 $2.0$ 进行磁滞扫描，步长为 $0.02$。\n- 情况 B（预期存在双稳态区域）：$(L, m, K_R, K_T, k_b) = (200, 4, 1.0, 50.0, 0.01)$；在 $k_p \\in \\{0.5, 0.75, 1.0, 1.25, 1.5\\}$ 和 $k_d \\in \\{0.10, 0.175, 0.25, 0.325, 0.40\\}$ 的 $5 \\times 5$ 网格上扫描 $(k_p, k_d)$；在 $k_p$ 上从 $0.0$ 到 $2.0$ 进行磁滞扫描，步长为 $0.02$。\n- 情况 C（接近边界，敏感）：$(L, m, K_R, K_T, k_b) = (80, 4, 1.0, 30.0, 0.01)$；在 $k_p \\in \\{0.6, 0.8, 1.0, 1.2\\}$ 和 $k_d \\in \\{0.20, 0.23, 0.26, 0.29\\}$ 的 $4 \\times 4$ 网格上扫描 $(k_p, k_d)$；在 $k_p$ 上从 $0.0$ 到 $2.0$ 进行磁滞扫描，步长为 $0.02$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于三种情况中的每一种，输出一个双元素列表 $[B, H]$，其中 $B$ 是在 $(k_p, k_d)$ 扫描中找到的双稳态网格点的整数计数，H 是从 $k_p$ 扫描计算出的磁滞宽度（一个无量纲单位的浮点数）。最终输出必须是以下形式：\n$$\n[[B_A, H_A],[B_B, H_B],[B_C, H_C]]\n$$\n且不带任何附加文本。",
            "solution": "我们从用于变构调控的 Monod–Wyman–Changeux (MWC) 模型开始。该酶具有两种构象状态，松弛态 $R$ 和紧张态 $T$，其变构常数 $L$ 等于在无配体情况下 $T$ 与 $R$ 的比值。一个变构激活剂通过 $m$ 个相同的结合位点与 $R$ 和 $T$ 两种状态结合，其解离常数分别为 $K_R$ 和 $K_T$。在快速平衡和质量作用结合条件下，每个状态的配体占据的统计权重为\n$$\nA_R(x) = \\left(1 + \\frac{x}{K_R}\\right)^m,\\quad A_T(x) = \\left(1 + \\frac{x}{K_T}\\right)^m,\n$$\n它们的比率为\n$$\nR(x) = \\frac{A_T(x)}{A_R(x)} = \\left(\\frac{1 + x/K_T}{1 + x/K_R}\\right)^m.\n$$\n处于 $R$ 状态的酶分子所占的比例是条件概率\n$$\nf_R(x; L, m, K_R, K_T) = \\frac{1}{1 + L\\, R(x)} = \\frac{1}{1 + L \\left(\\frac{1 + x/K_T}{1 + x/K_R}\\right)^m}.\n$$\n这是一个经过充分检验的公式，源自 MWC 框架和质量作用结合平衡。\n\n为了使用 ODE\n$$\n\\frac{dx}{dt} = k_b + k_p\\, f_R(x; L, m, K_R, K_T) - k_d\\, x,\n$$\n我们需要 $f_R(x)$ 关于 $x$ 的导数来进行稳定性分析。使用链式法则对 $R(x)$ 求导，利用\n$$\n\\frac{d}{dx}\\ln R(x) = m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right),\n$$\n因此\n$$\n\\frac{dR}{dx} = R(x)\\, m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right).\n$$\n对 $f_R(x) = \\left(1 + L R(x)\\right)^{-1}$ 应用导数法则，得到\n$$\n\\frac{df_R}{dx}(x; L, m, K_R, K_T) = -\\frac{L\\, \\frac{dR}{dx}}{\\left(1 + L R(x)\\right)^2}\n= -\\frac{L\\, R(x)\\, m\\left(\\frac{1/K_T}{1 + x/K_T} - \\frac{1/K_R}{1 + x/K_R}\\right)}{\\left(1 + L R(x)\\right)^2}.\n$$\n对于 $K_T \\gg K_R$ 的激活剂，括号中的项为负，因此总导数为正，这与激活配体的预期相符。\n\n稳态 $x^\\ast$ 满足\n$$\nh(x^\\ast) \\equiv k_b + k_p\\, f_R(x^\\ast) - k_d\\, x^\\ast = 0.\n$$\n为了数值求解所有非负稳态，我们在一个足够大的 $x_{\\max}$ 的有限域 $x \\in [0, x_{\\max}]$ 上对 $h(x)$ 的根进行区间限定。由于 $f_R(x) \\in (0, 1)$，当 $x \\to \\infty$ 时，$h(x) \\sim k_b + k_p - k_d x$，该式最终变为负值；在 $x = 0$ 处，对于非负的 $k_b$ 和 $k_p$，$h(0) = k_b + k_p f_R(0) \\ge 0$。因此，至少存在一个根。我们在一个网格上对 $h(x)$ 进行采样，并使用鲁棒的区间法（例如 Brent 法）在符号发生变化的位置精确查找根的位置。\n\n为了对稳定性进行分类，我们计算每个稳态处的雅可比矩阵：\n$$\nJ(x^\\ast) = k_p\\, \\frac{df_R}{dx}(x^\\ast) - k_d.\n$$\n如果 $J(x^\\ast)  0$，该不动点是局部稳定的；如果 $J(x^\\ast) > 0$，它是不稳定的。在一维连续时间自治 ODE 中，局部稳定性取决于不动点处向量场导数的符号。\n\n当存在三个非负实数不动点时，即两个稳定平衡点被一个不稳定平衡点分开，就会出现双稳态。使用上述程序，我们可以确定在固定的 $(L, m, K_R, K_T, k_b)$ 条件下，给定的参数对 $(k_p, k_d)$ 是否会产生双稳态。绘制双稳态区域意味着在 $(k_p, k_d)$ 平面上扫描一个网格，并计算产生这种模式的参数对的数量。\n\n为了说明由折叠（鞍节点）分岔引起的磁滞现象，我们在控制参数 $k_p$ 中进行扫描：\n- 在增加 $k_p$ 的正向扫描中，我们从一个低的 $k_p$ 值开始，计算所有稳定稳态，并选择与先前选择的稳定状态最接近的一个（通过邻近性进行延拓）。随着 $k_p$ 的增加，如果所跟踪的稳定分支不复存在（一个鞍节点使该分支消失），系统必须跳到另一个稳定分支。我们记录跳变时的 $k_p$ 值。\n- 在减小 $k_p$ 的反向扫描中，我们类似地从高的 $k_p$ 值开始跟踪高 $x$ 分支。当这个分支消失时，系统会向下跳变。我们记录那个跳变值。\n磁滞宽度是反向扫描跳变和正向扫描跳变在 $k_p$ 上的差值。如果没有发生跳变（在所有 $k_p$ 值下均为单稳态机制），则磁滞宽度为零。\n\n算法细节：\n1. 选择足够大的 $x_{\\max}$，例如 $x_{\\max} = \\max\\left(5, \\frac{5(k_b + k_p)}{\\max(k_d, \\varepsilon)}\\right)$，其中 $\\varepsilon > 0$ 是一个小数以避免除以零。在 $[0, x_{\\max}]$ 的精细网格上对 $h(x)$ 进行采样，检测符号变化，并应用区间求根器来获得所有非负稳态。\n2. 使用上述解析表达式计算 $\\frac{df_R}{dx}$，评估 $J(x^\\ast)$，并对稳定性进行分类。\n3. 对于网格映射，迭代 $(k_p, k_d)$ 的值，应用步骤 1-2，并计算双稳态情况的数量。\n4. 对于磁滞，构建一个 $k_p$ 值的列表。对每个值，找到所有稳定稳态。在每一步，选择与先前选择的根最接近的稳定根（沿 $x$ 的欧几里得距离），当先前跟踪的分支消失且附近没有稳定根时，检测到跳变。记录增加和减少扫描的跳变值，然后计算磁滞宽度。\n\n通过确保 $x$ 的非负性、通过增大 $x_{\\max}$ 来防止符号变化缺失、并将只有一个不动点的情况视为单稳态来处理边界情况。由于通过解离常数进行了缩放，所有量都是无量纲的，输出的磁滞宽度也以无量纲单位报告。\n\n测试套件包括三个参数集：\n- 情况 A 关注单稳态机制，并验证双稳态计数为零和磁滞宽度为零。\n- 情况 B 探索强正反馈，可能存在双稳态和非零磁滞宽度。\n- 情况 C 探测近边界的敏感性，可能存在小的双稳态区域和小的磁滞宽度。\n\n程序输出一行形式为 $[[B_A, H_A],[B_B, H_B],[B_C, H_C]]$ 的结果，其中 $B_\\cdot$ 是整数，$H_\\cdot$ 是浮点数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# MWC fraction of relaxed (active) state and its derivative\ndef mwc_fraction(x, L, m, KR, KT):\n    # Avoid division by zero with small epsilon\n    x = np.maximum(x, 0.0)\n    AR = (1.0 + x / KR) ** m\n    AT = (1.0 + x / KT) ** m\n    R = AT / AR\n    return 1.0 / (1.0 + L * R)\n\ndef mwc_fraction_derivative(x, L, m, KR, KT):\n    x = np.maximum(x, 0.0)\n    AR = (1.0 + x / KR) ** m\n    AT = (1.0 + x / KT) ** m\n    R = AT / AR\n    denomR = 1.0 + L * R\n    # d/dx ln R = m * [ (1/KT)/(1 + x/KT) - (1/KR)/(1 + x/KR) ]\n    term = m * ((1.0 / KT) / (1.0 + x / KT) - (1.0 / KR) / (1.0 + x / KR))\n    dRdx = R * term\n    # df/dx = -L * dRdx / (1 + L R)^2\n    return -L * dRdx / (denomR ** 2)\n\n# Vector field h(x) = kb + kp * fR(x) - kd * x\ndef h_field(x, params, kp, kd):\n    L, m, KR, KT, kb = params\n    return kb + kp * mwc_fraction(x, L, m, KR, KT) - kd * x\n\ndef jacobian_at_x(x, params, kp, kd):\n    L, m, KR, KT, kb = params\n    df = mwc_fraction_derivative(x, L, m, KR, KT)\n    return kp * df - kd\n\ndef find_roots_and_stability(params, kp, kd, x_max=None, grid_points=2000):\n    # Determine a robust x_max\n    L, m, KR, KT, kb = params\n    if x_max is None:\n        # ensure large enough domain\n        x_max = max(5.0, 5.0 * (kb + max(kp, 1e-6)) / max(kd, 1e-6))\n    xs = np.linspace(0.0, x_max, grid_points + 1)\n    hs = h_field(xs, params, kp, kd)\n\n    # Identify sign changes for bracketing\n    roots = []\n    for i in range(grid_points):\n        h1 = hs[i]\n        h2 = hs[i + 1]\n        if np.isnan(h1) or np.isnan(h2):\n            continue\n        if h1 == 0.0:\n            roots.append(xs[i])\n        elif h2 == 0.0:\n            roots.append(xs[i + 1])\n        elif h1 * h2  0.0:\n            # bracket found\n            try:\n                r = brentq(lambda z: h_field(z, params, kp, kd), xs[i], xs[i + 1], maxiter=200)\n                roots.append(r)\n            except Exception:\n                # If brentq fails, skip this bracket\n                continue\n\n    # Deduplicate roots (numerical noise)\n    roots = sorted(roots)\n    deduped = []\n    for r in roots:\n        if not deduped or abs(r - deduped[-1]) > 1e-6:\n            deduped.append(r)\n    roots = deduped\n\n    # Stability classification: J(x*)  0 => stable\n    stability = []\n    for r in roots:\n        J = jacobian_at_x(r, params, kp, kd)\n        stability.append(J  0.0)\n    return roots, stability\n\ndef is_bistable(roots, stability):\n    # Bistable if there exist at least two stable roots separated by an unstable one\n    # Count stable roots\n    stable_indices = [i for i, st in enumerate(stability) if st]\n    if len(stable_indices)  2 or len(roots)  3:\n        return False\n    # Check if there is an unstable root between the two extreme stable roots\n    min_stable = min(stable_indices)\n    max_stable = max(stable_indices)\n    # There must be at least one root between them and it must be unstable\n    for j in range(min_stable + 1, max_stable):\n        if not stability[j]:\n            return True\n    return False\n\ndef map_bistability(params, kp_values, kd_values):\n    count_bistable = 0\n    for kp in kp_values:\n        for kd in kd_values:\n            roots, stability = find_roots_and_stability(params, kp, kd)\n            if is_bistable(roots, stability):\n                count_bistable += 1\n    return count_bistable\n\ndef hysteresis_width_in_kp(params, kp_min, kp_max, kp_step, kd):\n    # Forward sweep: start at low kp, pick low-x stable state\n    kp_list_forward = np.arange(kp_min, kp_max + kp_step / 2.0, kp_step)\n    kp_list_backward = kp_list_forward[::-1]\n\n    forward_jump_kp = None\n    backward_jump_kp = None\n\n    # Helper to pick nearest stable root to previous x\n    def pick_nearest_stable(roots, stability, x_prev):\n        stable_roots = [r for r, st in zip(roots, stability) if st]\n        if len(stable_roots) == 0:\n            return None\n        if x_prev is None:\n            # For forward sweep, choose smallest stable root initially\n            return min(stable_roots)\n        # Choose root closest to x_prev\n        dists = [abs(r - x_prev) for r in stable_roots]\n        idx = int(np.argmin(dists))\n        return stable_roots[idx]\n\n    # Forward sweep\n    x_prev = None\n    branch_exists = True\n    for kp in kp_list_forward:\n        roots, stability = find_roots_and_stability(params, kp, kd)\n        candidate = pick_nearest_stable(roots, stability, x_prev)\n        if candidate is None:\n            # No stable root: pathological; treat as branch loss\n            if branch_exists and forward_jump_kp is None:\n                forward_jump_kp = kp\n            branch_exists = False\n            x_prev = None\n            continue\n        if x_prev is None:\n            # initialize\n            x_prev = candidate\n            branch_exists = True\n        else:\n            # If previously on branch but now nearest stable is far because branch vanished,\n            # detect jump by checking if previous x is not within any stable root neighborhood.\n            stable_roots = [r for r, st in zip(roots, stability) if st]\n            if branch_exists and len(stable_roots) >= 1:\n                # Check if previous branch root persists approximately\n                # If the closest stable root is not near previous by threshold, infer jump\n                if min(abs(np.array(stable_roots) - x_prev)) > 0.1:\n                    if forward_jump_kp is None:\n                        forward_jump_kp = kp\n                    branch_exists = False\n            x_prev = candidate\n\n    # Backward sweep: choose highest stable root initially\n    def pick_nearest_stable_backward(roots, stability, x_prev):\n        stable_roots = [r for r, st in zip(roots, stability) if st]\n        if len(stable_roots) == 0:\n            return None\n        if x_prev is None:\n            return max(stable_roots)\n        dists = [abs(r - x_prev) for r in stable_roots]\n        idx = int(np.argmin(dists))\n        return stable_roots[idx]\n\n    x_prev = None\n    branch_exists = True\n    for kp in kp_list_backward:\n        roots, stability = find_roots_and_stability(params, kp, kd)\n        candidate = pick_nearest_stable_backward(roots, stability, x_prev)\n        if candidate is None:\n            if branch_exists and backward_jump_kp is None:\n                backward_jump_kp = kp\n            branch_exists = False\n            x_prev = None\n            continue\n        if x_prev is None:\n            x_prev = candidate\n            branch_exists = True\n        else:\n            stable_roots = [r for r, st in zip(roots, stability) if st]\n            if branch_exists and len(stable_roots) >= 1:\n                if min(abs(np.array(stable_roots) - x_prev)) > 0.1:\n                    if backward_jump_kp is None:\n                        backward_jump_kp = kp\n                    branch_exists = False\n            x_prev = candidate\n\n    # Compute hysteresis width\n    if forward_jump_kp is None or backward_jump_kp is None:\n        return 0.0\n    else:\n        return float(max(0.0, backward_jump_kp - forward_jump_kp))\n\ndef solve():\n    results = []\n\n    # Case A: monostable expected\n    params_A = (10.0, 3, 1.0, 10.0, 0.01)  # (L, m, KR, KT, kb)\n    kp_values_A = np.array([0.2, 0.4, 0.6])\n    kd_values_A = np.array([0.8, 1.0, 1.2])\n    count_A = map_bistability(params_A, kp_values_A, kd_values_A)\n    width_A = hysteresis_width_in_kp(params_A, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=1.0)\n\n    results.append([int(count_A), float(width_A)])\n\n    # Case B: bistable region expected\n    params_B = (200.0, 4, 1.0, 50.0, 0.01)\n    kp_values_B = np.array([0.5, 0.75, 1.0, 1.25, 1.5])\n    kd_values_B = np.array([0.10, 0.175, 0.25, 0.325, 0.40])\n    count_B = map_bistability(params_B, kp_values_B, kd_values_B)\n    width_B = hysteresis_width_in_kp(params_B, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=0.25)\n\n    results.append([int(count_B), float(width_B)])\n\n    # Case C: near boundary\n    params_C = (80.0, 4, 1.0, 30.0, 0.01)\n    kp_values_C = np.array([0.6, 0.8, 1.0, 1.2])\n    kd_values_C = np.array([0.20, 0.23, 0.26, 0.29])\n    count_C = map_bistability(params_C, kp_values_C, kd_values_C)\n    width_C = hysteresis_width_in_kp(params_C, kp_min=0.0, kp_max=2.0, kp_step=0.02, kd=0.26)\n\n    results.append([int(count_C), float(width_C)])\n\n    # Print final results in the exact required format\n    # Ensure consistent float formatting\n    formatted = []\n    for item in results:\n        # item is [int, float]\n        formatted.append(f\"[{item[0]},{item[1]}]\")\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}