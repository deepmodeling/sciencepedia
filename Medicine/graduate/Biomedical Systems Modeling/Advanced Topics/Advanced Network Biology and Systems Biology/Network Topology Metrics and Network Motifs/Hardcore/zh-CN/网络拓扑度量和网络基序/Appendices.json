{
    "hands_on_practices": [
        {
            "introduction": "分析任何网络的第一步是将其用数学上易于处理的方式进行表示。邻接矩阵是实现这一目标的基本工具，它将网络中的连接关系编码为一个矩阵。通过这个矩阵，我们可以轻松计算出节点度，这是衡量一个节点连接性的最基本指标。本练习  将指导你从一个给定的蛋白质相互作用列表开始，亲手构建其邻接矩阵，并计算每个节点的度，这是掌握网络量化分析的基础。",
            "id": "3910063",
            "problem": "考虑一个合成的蛋白质-蛋白质相互作用（PPI）网络，它代表了信号模块中相互作用蛋白质的一个小子集。该网络被建模为一个无向、无权、简单的图，包含 $6$ 个标记为 $p_1, p_2, p_3, p_4, p_5, p_6$ 的蛋白质。在 $p_i$ 和 $p_j$ 之间的一条无向边表示存在通过诸如 yeast two-hybrid 等实验检测到的物理相互作用；不允许存在多重边和自环。观测到的相互作用由以下无序对给出：\n$$\\{(p_1,p_2),\\ (p_1,p_3),\\ (p_2,p_3),\\ (p_2,p_4),\\ (p_3,p_5),\\ (p_4,p_5),\\ (p_5,p_6)\\}.$$\n使用顶点的规范排序 $(p_1,p_2,p_3,p_4,p_5,p_6)$，构建这个无向、无权网络的邻接矩阵 $A$。然后，仅使用图论的核心定义，直接从 $A$ 计算每个节点 $p_i$ 的度 $d_i$，并按指定的顶点顺序报告度向量 $(d_1,d_2,d_3,d_4,d_5,d_6)$。最终答案必须以单个行向量的形式给出。",
            "solution": "问题要求为一个给定的蛋白质-蛋白质相互作用（PPI）网络构建邻接矩阵，并随后计算其节点的度向量。该网络被建模为一个无向、无权、简单的图。\n\n首先，我们定义图 $G=(V, E)$，其中 $V$ 是顶点（蛋白质）的集合，$E$ 是边（相互作用）的集合。\n顶点集合为 $V = \\{p_1, p_2, p_3, p_4, p_5, p_6\\}$。顶点的数量为 $|V| = 6$。\n代表无向相互作用的边集合由以下 $7$ 个无序对给出：\n$E = \\{\\{p_1,p_2\\},\\ \\{p_1,p_3\\},\\ \\{p_2,p_3\\},\\ \\{p_2,p_4\\},\\ \\{p_3,p_5\\},\\ \\{p_4,p_5\\},\\ \\{p_5,p_6\\}\\}$。\n\n一个具有 $N$ 个顶点的无向、无权、简单图的邻接矩阵 $A$ 是一个 $N \\times N$ 矩阵，其中元素 $A_{ij}$ 定义为：\n$$\nA_{ij} = \\begin{cases} 1  \\text{如果顶点 } i \\text{ 和顶点 } j \\text{ 之间存在边} \\\\ 0  \\text{否则} \\end{cases}\n$$\n由于该图是简单图，不存在自环，这意味着对角线元素 $A_{ii}$ 均为 $0$。由于该图是无向的，邻接矩阵是对称的，即对所有 $i,j$ 都有 $A_{ij} = A_{ji}$。\n\n我们将使用指定的顶点规范排序 $(p_1,p_2,p_3,p_4,p_5,p_6)$ 来构建这个 $6 \\times 6$ 的邻接矩阵 $A$。$A$ 的行和列按顺序对应这些顶点。\n\n根据边集合 $E$，我们填充 $A$ 的非零非对角线元素：\n- 边 $\\{p_1, p_2\\}$ 意味着 $A_{12} = A_{21} = 1$。\n- 边 $\\{p_1, p_3\\}$ 意味着 $A_{13} = A_{31} = 1$。\n- 边 $\\{p_2, p_3\\}$ 意味着 $A_{23} = A_{32} = 1$。\n- 边 $\\{p_2, p_4\\}$ 意味着 $A_{24} = A_{42} = 1$。\n- 边 $\\{p_3, p_5\\}$ 意味着 $A_{35} = A_{53} = 1$。\n- 边 $\\{p_4, p_5\\}$ 意味着 $A_{45} = A_{54} = 1$。\n- 边 $\\{p_5, p_6\\}$ 意味着 $A_{56} = A_{65} = 1$。\n\n所有其他的非对角线元素均为 $0$，所有对角线元素也均为 $0$。完整的邻接矩阵 $A$ 是：\n$$\nA = \\begin{pmatrix}\n0  1  1  0  0  0 \\\\\n1  0  1  1  0  0 \\\\\n1  1  0  0  1  0 \\\\\n0  1  0  0  1  0 \\\\\n0  0  1  1  0  1 \\\\\n0  0  0  0  1  0\n\\end{pmatrix}\n$$\n\n接下来，我们计算每个顶点 $p_i$ 的度 $d_i$。在无权图中，一个顶点的度是连接到它的边的数量。对于一个由邻接矩阵 $A$ 表示的图，顶点 $p_i$ 的度 $d_i$ 是 $A$ 的第 $i$ 行（或由于对称性，第 $i$ 列）元素的总和。公式为：\n$$\nd_i = \\sum_{j=1}^{N} A_{ij}\n$$\n在本例中，$N=6$。\n\n我们将此公式应用于矩阵 $A$ 的每一行：\n- 对于 $p_1$：$d_1 = \\sum_{j=1}^{6} A_{1j} = A_{11} + A_{12} + A_{13} + A_{14} + A_{15} + A_{16} = 0 + 1 + 1 + 0 + 0 + 0 = 2$。\n- 对于 $p_2$：$d_2 = \\sum_{j=1}^{6} A_{2j} = A_{21} + A_{22} + A_{23} + A_{24} + A_{25} + A_{26} = 1 + 0 + 1 + 1 + 0 + 0 = 3$。\n- 对于 $p_3$：$d_3 = \\sum_{j=1}^{6} A_{3j} = A_{31} + A_{32} + A_{33} + A_{34} + A_{35} + A_{36} = 1 + 1 + 0 + 0 + 1 + 0 = 3$。\n- 对于 $p_4$：$d_4 = \\sum_{j=1}^{6} A_{4j} = A_{41} + A_{42} + A_{43} + A_{44} + A_{45} + A_{46} = 0 + 1 + 0 + 0 + 1 + 0 = 2$。\n- 对于 $p_5$：$d_5 = \\sum_{j=1}^{6} A_{5j} = A_{51} + A_{52} + A_{53} + A_{54} + A_{55} + A_{56} = 0 + 0 + 1 + 1 + 0 + 1 = 3$。\n- 对于 $p_6$：$d_6 = \\sum_{j=1}^{6} A_{6j} = A_{61} + A_{62} + A_{63} + A_{64} + A_{65} + A_{66} = 0 + 0 + 0 + 0 + 1 + 0 = 1$。\n\n计算出的度为 $d_1 = 2$, $d_2 = 3$, $d_3 = 3$, $d_4 = 2$, $d_5 = 3$, 和 $d_6 = 1$。\n因此，按指定的顶点顺序 $(p_1, p_2, p_3, p_4, p_5, p_6)$，度向量为 $(d_1, d_2, d_3, d_4, d_5, d_6)$。\n这对应于向量 $(2, 3, 3, 2, 3, 1)$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 2  3  3  2  3  1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "网络分析的魅力在于揭示其拓扑结构如何决定其动态功能。超越简单的节点度，图拉普拉斯矩阵是一个更强大的工具，它的谱特性（即特征值）与网络中的信号传播、同步和弹性等动态过程密切相关。本练习  将引导你为一个星形网络计算其代数连通性（拉普拉斯矩阵的第二个最小特征值 $\\lambda_2$），并理解为何该值是衡量网络通讯弹性的关键指标。",
            "id": "3909886",
            "problem": "考虑一个由五个细胞组成的简化细胞间通讯网络，该网络被建模为一个无向加权图，其中每条边代表细胞间归一化的间隙连接电导。该网络的基元是星形结构：细胞 $1$ 作为中心枢纽，与细胞 $2$、$3$、$4$ 和 $5$ 连接，且不存在其他连接。所有四个从中心到叶节点的连接都具有相同的归一化权重 $w = \\frac{3}{4}$。令 $A$ 表示加权邻接矩阵，$D$ 表示对角加权度矩阵（其元素为 $d_{i} = \\sum_{j} A_{ij}$），$L = D - A$ 表示组合图拉普拉斯算子。代数连通度定义为 $L$ 的第二小特征值 $\\lambda_{2}$。在由线性常微分方程(ODE) $\\frac{d\\mathbf{x}}{dt} = -L \\mathbf{x}$ 建模的类扩散细胞间信号传导的背景下，$\\lambda_{2}$ 是一个影响最慢非平凡弛豫模式的谱量。\n\n从 $A$、$D$ 和 $L$ 的定义出发，并且不使用任何非从这些定义推导出的专门公式，为该网络构建 $L$，计算 $L$ 的所有特征值，确定代数连通度 $\\lambda_{2}$，并简要说明 $\\lambda_{2}$ 如何与此星形基元中细胞间通讯的弹性相关。以精确分数形式表示 $\\lambda_{2}$ 的最终值。无需四舍五入。",
            "solution": "该问题要求为一个给定的5细胞星形网络构建图拉普拉斯矩阵 $L$，计算其所有特征值，确定代数连通度 $\\lambda_2$，并说明其在通讯弹性中的作用。\n\n该网络包含 $n=5$ 个细胞。细胞 $1$ 是中心枢纽，细胞 $2、3、4、5$ 是叶节点。该图是无向的。连接存在于细胞 $1$ 和其他四个细胞之间。每条边的权重给定为 $w = \\frac{3}{4}$。不存在其他连接。\n\n首先，我们构建加权邻接矩阵 $A$。它是一个 $5 \\times 5$ 的对称矩阵，其中 $A_{ij}$ 是细胞 $i$ 和细胞 $j$ 之间边的权重。\n非零的非对角元素为 $A_{12} = A_{21} = w$，$A_{13} = A_{31} = w$，$A_{14} = A_{41} = w$ 和 $A_{15} = A_{51} = w$。所有其他非对角元素均为 $0$。对角元素 $A_{ii}$ 均为 $0$。\n代入 $w = \\frac{3}{4}$，邻接矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n0  \\frac{3}{4}  \\frac{3}{4}  \\frac{3}{4}  \\frac{3}{4} \\\\\n\\frac{3}{4}  0  0  0  0 \\\\\n\\frac{3}{4}  0  0  0  0 \\\\\n\\frac{3}{4}  0  0  0  0 \\\\\n\\frac{3}{4}  0  0  0  0\n\\end{pmatrix}\n$$\n\n接下来，我们构建对角加权度矩阵 $D$。对角元素由 $d_{i} = \\sum_{j} A_{ij}$ 给出。\n对于中心枢纽（细胞 $1$）：$d_1 = A_{12} + A_{13} + A_{14} + A_{15} = w + w + w + w = 4w$。\n对于叶节点（细胞 $2、3、4、5$）：$d_2 = A_{21} = w$，$d_3 = A_{31} = w$，$d_4 = A_{41} = w$，$d_5 = A_{51} = w$。\n当 $w = \\frac{3}{4}$ 时，我们有 $d_1 = 4(\\frac{3}{4}) = 3$ 和 $d_2=d_3=d_4=d_5 = \\frac{3}{4}$。\n度矩阵 $D$ 为：\n$$\nD = \\begin{pmatrix}\n3  0  0  0  0 \\\\\n0  \\frac{3}{4}  0  0  0 \\\\\n0  0  \\frac{3}{4}  0  0 \\\\\n0  0  0  \\frac{3}{4}  0 \\\\\n0  0  0  0  \\frac{3}{4}\n\\end{pmatrix}\n$$\n\n组合图拉普拉斯算子 $L$ 定义为 $L = D - A$。\n$$\nL = \\begin{pmatrix}\n3  -\\frac{3}{4}  -\\frac{3}{4}  -\\frac{3}{4}  -\\frac{3}{4} \\\\\n-\\frac{3}{4}  \\frac{3}{4}  0  0  0 \\\\\n-\\frac{3}{4}  0  \\frac{3}{4}  0  0 \\\\\n-\\frac{3}{4}  0  0  \\frac{3}{4}  0 \\\\\n-\\frac{3}{4}  0  0  0  \\frac{3}{4}\n\\end{pmatrix}\n$$\n用符号权重 $w$ 表示，该矩阵为：\n$$\nL = \\begin{pmatrix}\n4w  -w  -w  -w  -w \\\\\n-w  w  0  0  0 \\\\\n-w  0  w  0  0 \\\\\n-w  0  0  w  0 \\\\\n-w  0  0  0  w\n\\end{pmatrix}\n$$\n为了求出 $L$ 的特征值 $\\lambda$，我们求解特征方程 $L\\mathbf{v} = \\lambda\\mathbf{v}$，其中 $\\mathbf{v}$ 为非零特征向量。\n对于任何连通图的组合拉普拉斯算子，其每行之和为零。这意味着向量 $\\mathbf{v}_1 = (1, 1, 1, 1, 1)^T$ 是一个特征值为 $\\lambda_1 = 0$ 的特征向量，因为 $L\\mathbf{v}_1 = \\mathbf{0} = 0 \\cdot \\mathbf{v}_1$。这是最小的特征值。\n\n由于叶节点的对称性，我们可以找到其他特征值。考虑一个特征向量 $\\mathbf{v}$，其中枢纽分量为零，$v_1=0$，且叶节点分量之和为零，即 $\\sum_{i=2}^5 v_i = 0$。我们来计算 $L\\mathbf{v}$：\n结果向量的第一个分量是 $(L\\mathbf{v})_1 = 4wv_1 - w(v_2+v_3+v_4+v_5) = 4w(0) - w(0) = 0$。由于 $v_1=0$，这与 $\\lambda v_1$ 相匹配。\n对于任何叶节点 $k \\in \\{2, 3, 4, 5\\}$，第 $k$ 个分量是 $(L\\mathbf{v})_k = -wv_1 + wv_k = -w(0) + wv_k = wv_k$。这与 $\\lambda v_k$ 相匹配，其中 $\\lambda=w$。\n因此，任何满足 $v_1=0$ 和 $\\sum_{i=2}^5 v_i=0$ 的向量 $\\mathbf{v}$ 都是一个特征值为 $\\lambda=w$ 的特征向量。此类向量构成的子空间维度为 $5 - 2 = 3$。例如，向量 $(0, 1, -1, 0, 0)^T$、$(0, 1, 0, -1, 0)^T$ 和 $(0, 1, 0, 0, -1)^T$ 是此特征空间中的线性无关向量。因此，特征值 $\\lambda = w$ 的重数为 $3$。\n\n我们已经找到了四个特征值：$\\lambda_1 = 0$ 和 $\\lambda_2=\\lambda_3=\\lambda_4=w$。第五个特征值 $\\lambda_5$ 可以利用特征值之和等于矩阵的迹这一性质求得，即 $\\sum \\lambda_i = \\text{Tr}(L)$。\n$\\text{Tr}(L) = d_1 + d_2 + d_3 + d_4 + d_5 = 4w + w + w + w + w = 8w$。\n特征值之和为 $\\lambda_1 + \\lambda_2 + \\lambda_3 + \\lambda_4 + \\lambda_5 = 0 + w + w + w + \\lambda_5 = 3w + \\lambda_5$。\n令二者相等，$3w + \\lambda_5 = 8w$，解得 $\\lambda_5 = 5w$。\n\n$L$ 的特征值按非递减顺序排列为：\n$\\lambda_1=0$\n$\\lambda_2=w$\n$\\lambda_3=w$\n$\\lambda_4=w$\n$\\lambda_5=5w$\n\n代入 $w=\\frac{3}{4}$ 的值：\n$\\lambda_1 = 0$\n$\\lambda_2 = \\lambda_3 = \\lambda_4 = \\frac{3}{4}$\n$\\lambda_5 = 5 \\times \\frac{3}{4} = \\frac{15}{4}$\n\n代数连通度定义为第二小特征值 $\\lambda_2$。\n因此，$\\lambda_2 = w = \\frac{3}{4}$。\n\n$\\lambda_2$ 与弹性的关系源于动力系统 $\\frac{d\\mathbf{x}}{dt} = -L\\mathbf{x}$。其通解是指数衰减模式的线性组合：$\\mathbf{x}(t) = \\sum_{i=1}^5 c_i e^{-\\lambda_i t} \\mathbf{v}_i$，其中 $\\mathbf{v}_i$ 是 $L$ 的特征向量。与 $\\lambda_1=0$ 相关的项不衰减，代表所有细胞浓度相等的最终共识状态。所有其他模式都衰减到零。收敛到此共识状态的速率由最慢的衰减模式决定，该模式对应于最小的非零特征值 $\\lambda_2$。此最慢模式的时间常数为 $\\tau = 1/\\lambda_2$。$\\lambda_2$ 的值越大，意味着时间常数越小，因此在受到扰动后能更快地收敛到同步状态。在细胞间通讯的背景下，这种快速同步是网络弹性的一个度量，因为它反映了系统有效分配信号并恢复到一个稳定、均匀状态的能力。因此，更高的代数连通度 $\\lambda_2$ 表示一个更具弹性的通讯网络。",
            "answer": "$$\n\\boxed{\\frac{3}{4}}\n$$"
        },
        {
            "introduction": "网络基序（Network Motifs）被认为是构成复杂网络功能的基本构建模块，它们是比预期中更频繁出现的特定子图。本练习  聚焦于一个重要的调控基序——前馈环（Feed-Forward Loop, FFL），并引入了“符号”网络的概念（即相互作用可以是激活或抑制）。你将学习如何在一个有符号网络中识别FFL，根据其内部调控逻辑将其分为“一致性”或“非一致性”类型，并通过与零模型比较来评估其统计显著性。",
            "id": "3910102",
            "problem": "考虑一个有符号调控网络，该网络被建模为一个有向简单图 $G = (V, E)$，并带有一个符号函数 $\\sigma : E \\to \\{-1, +1\\}$。一个三元组是一个由三个不同节点组成的有序三元组 $(x, y, z) \\in V^3$，其中 $x \\neq y \\neq z \\neq x$。当且仅当所有三条有向边 $(x, y)$、$(x, z)$ 和 $(y, z)$ 都存在于 $E$ 中时，三元组 $(x, y, z)$ 上存在一个前馈环（FFL）模体。在一个有符号FFL中，一致性通过比较从 $x$ 到 $z$ 的直接路径和间接路径来定义：如果 $\\sigma(x, z) = \\sigma(x, y)\\cdot\\sigma(y, z)$，则该模体是一致的，否则是不一致的。目标是识别指定三元组中的所有FFL，将其分类为一致或不一致，并计算它们相对于一个保持符号的零模型的期望富集度。\n\n使用以下基本定义和假设：\n- 网络是一个有向简单图，无自环，每个有序对 $(u, v)$ (其中 $u \\neq v$) 至多有一条边。如果 $(u, v) \\in E$，则赋予其一个符号 $\\sigma(u, v) \\in \\{-1, +1\\}$。\n- 在保持符号的零模型下，每个有序对 $(u, v)$ (其中 $u \\neq v$) 独立地以概率 $p_+ = E_+ / M$ 成为一条正边，以概率 $p_- = E_- / M$ 成为一条负边，以概率 $1 - p_+ - p_-$ 没有边。其中 $E_+$ 和 $E_-$ 是观测网络中正边和负边的数量，而 $M = |V|\\cdot(|V| - 1)$ 是可能的有序对数量。\n- 在计算期望时，假定零模型中的有序对之间是相互独立的；期望的线性性质确保了一组三元组的总期望计数是每个三元组期望计数的总和。\n\n您的程序必须：\n1. 对于每个测试用例，根据提供的边列表和三元组列表构建网络，识别这些三元组中的所有FFL，并使用规则 $\\sigma(x, z) = \\sigma(x, y)\\cdot\\sigma(y, z)$ 将每个FFL分类为一致或不一致。\n2. 根据上述定义的保持符号的零模型，计算一致和不一致FFL的期望数量。令 $a = p_+ = E_+ / M$ 和 $b = p_- = E_- / M$。对于一个三元组，存在一个一致性FFL的概率是\n$$\nP_{\\mathrm{coh}} = a^3 + 3\\,a\\,b^2,\n$$\n而存在一个不一致性FFL的概率是\n$$\nP_{\\mathrm{incoh}} = 3\\,a^2\\,b + b^3.\n$$\n因此，对于 $T$ 个三元组，期望计数分别为 $T\\cdot P_{\\mathrm{coh}}$ 和 $T\\cdot P_{\\mathrm{incoh}}$。\n3. 将富集度计算为观测计数与期望计数的比率，分别针对一致和不一致模体。如果期望计数为零，当观测计数为零时，将富集度定义为 $0.0$；当观测计数为严格正数时，定义为 $+\\infty$。\n\n测试套件：\n- 测试用例 $1$（一般的混合符号情况）：\n  - 节点：$V = \\{0, 1, 2, 3, 4\\}$。\n  - 边（每个元组为 $(u, v, s)$，其中 $s \\in \\{-1, +1\\}$）：\n    - $(0, 1, +1)$, $(0, 2, -1)$, $(1, 2, +1)$, $(1, 3, -1)$, $(0, 3, +1)$, $(3, 2, -1)$, $(2, 4, +1)$, $(0, 4, -1)$。\n  - 三元组：$(0, 1, 2)$, $(0, 1, 3)$, $(0, 3, 2)$, $(1, 2, 4)$, $(0, 2, 4)$。\n- 测试用例 $2$（全正边的边界情况）：\n  - 节点：$V = \\{0, 1, 2, 3\\}$。\n  - 边：$(0, 1, +1)$, $(0, 2, +1)$, $(1, 2, +1)$, $(1, 3, +1)$, $(0, 3, +1)$, $(2, 3, +1)$。\n  - 三元组：$(0, 1, 2)$, $(0, 1, 3)$, $(1, 2, 3)$。\n- 测试用例 $3$（无FFL的边缘情况，含混合符号）：\n  - 节点：$V = \\{0, 1, 2, 3\\}$。\n  - 边：$(0, 1, +1)$, $(3, 1, +1)$, $(0, 3, -1)$, $(2, 3, -1)$。\n  - 三元组：$(0, 2, 3)$, $(1, 2, 3)$。\n\n程序输出规范：\n- 对于每个测试用例，输出列表 $[O_{\\mathrm{coh}}, O_{\\mathrm{incoh}}, E_{\\mathrm{coh}}, E_{\\mathrm{incoh}}, R_{\\mathrm{coh}}, R_{\\mathrm{incoh}}]$，其中 $O_{\\mathrm{coh}}$ 和 $O_{\\mathrm{incoh}}$ 是整数（观测计数），$E_{\\mathrm{coh}}$ 和 $E_{\\mathrm{incoh}}$ 是四舍五入到 $6$ 位小数的浮点数（期望计数），$R_{\\mathrm{coh}}$ 和 $R_{\\mathrm{incoh}}$ 是富集比，当其为有限值时四舍五入到 $6$ 位小数，当期望计数为零且观测计数为正时设为 $+\\infty$。\n- 您的程序应生成单行输出，其中包含结果，格式为由方括号括起的逗号分隔列表，并按测试用例的顺序排列。例如，一个有效的输出形式为 $[[\\dots],[\\dots],[\\dots]]$，其中每个内部列表按上述顺序对应一个测试用例。\n\n所有计算都严格基于数学且无单位；角度不适用。算法必须从所述定义和假设中逻辑推导得出，不得使用超出这些基础的任何捷径。",
            "solution": "该问题旨在识别和分类有向图中的有符号前馈环（$\\mathrm{FFL}$）模体，并根据一个保持符号的零模型计算其统计富集度。该问题是良定的，有科学依据，并为获得唯一解提供了所有必要的定义和数据。\n\n解决方案分为四个主要阶段进行：\n1.  网络和输入数据的表示。\n2.  观测到的$\\mathrm{FFL}$的识别和分类。\n3.  在指定的零模型下计算期望的$\\mathrm{FFL}$计数。\n4.  富集分数的计算。\n\n**1. 网络表示**\n\n带符号函数 $\\sigma : E \\to \\{-1, +1\\}$ 的有符号有向图 $G = (V, E)$ 可以使用邻接矩阵或邻接字典来高效地表示。考虑到测试用例中网络规模小且可能具有稀疏性，邻接字典是一个实用的选择。该结构将一个节点有序对 $(u, v)$ 映射到边的符号 $\\sigma(u, v)$（如果边存在）。对于不在 $E$ 中的任何对 $(u, v)$，我们可以认为其符号为 $0$。让这个表示法用函数 `adj(u, v)` 表示，使得如果 $(u, v) \\in E$，则 `adj`$(u, v) = \\sigma(u, v)$，否则 `adj`$(u, v) = 0$。\n\n**2. 观测到的模体识别与计数**\n\n一个 $\\mathrm{FFL}$ 模体定义在一个有序的不同节点三元组 $(x, y, z)$ 上。$\\mathrm{FFL}$的结构要求是同时存在三条有向边：$(x, y)$、$(x, z)$ 和 $(y, z)$。\n\n对于问题中提供的每个三元组 $(x, y, z)$，我们检查这三条边的存在性。这等价于检查 $\\text{adj}(x, y) \\neq 0$、$\\text{adj}(x, z) \\neq 0$ 和 $\\text{adj}(y, z) \\neq 0$。\n\n如果存在一个 $\\mathrm{FFL}$，它将被分类为一致或不一致。一致性条件通过比较从 $x$ 到 $z$ 的直接路径的符号与经过 $y$ 的间接路径的符号来定义。\n-   如果间接路径的符号乘积等于直接路径的符号：$\\sigma(x, y) \\cdot \\sigma(y, z) = \\sigma(x, z)$，则 $\\mathrm{FFL}$ 是 **一致的**。\n-   否则，$\\mathrm{FFL}$ 是 **不一致的**：$\\sigma(x, y) \\cdot \\sigma(y, z) = -\\sigma(x, z)$。\n\n通过遍历每个测试用例提供的三元组列表，我们计数观测到的一致$\\mathrm{FFL}$（表示为 $O_{\\mathrm{coh}}$）和不一致$\\mathrm{FFL}$（表示为 $O_{\\mathrm{incoh}}$）的数量。\n\n**3. 零模型与期望计数**\n\n问题定义了一个保持符号的零模型来评估观测计数的统计显著性。在此模型中，每条边的形成都是一个独立的随机事件。\n\n首先，我们根据观测到的图建立模型参数：\n-   $|V|$: 图中节点的数量。\n-   $M = |V|(|V| - 1)$: 不同节点之间可能的有向边的总数。\n-   $E_+$: 观测图中正（$+1$）边的总数。\n-   $E_-$: 观测图中负（$-1$）边的总数。\n\n由此，我们定义任意给定的不同节点有序对 $(u, v)$ 的概率：\n-   存在一条正边的概率是 $a = p_+ = E_+ / M$。\n-   存在一条负边的概率是 $b = p_- = E_- / M$。\n-   不存在边的概率是 $1 - a - b$。\n\n问题是要找到一个任意三元组 $(x, y, z)$ 形成一致或不一致$\\mathrm{FFL}$的概率。一个 $\\mathrm{FFL}$ 要求边 $(x, y), (x, z), (y, z)$ 存在。设它们的符号为 $s_{xy}, s_{xz}, s_{yz} \\in \\{-1, +1\\}$。\n\n对于一个 **一致的** $\\mathrm{FFL}$，符号必须满足 $s_{xz} = s_{xy} \\cdot s_{yz}$。可能的符号组合 $(s_{xy}, s_{yz}, s_{xz})$ 及其概率是：\n-   $(+1, +1, +1)$: 概率是 $a \\cdot a \\cdot a = a^3$。\n-   $(+1, -1, -1)$: 概率是 $a \\cdot b \\cdot b = ab^2$。\n-   $(-1, +1, -1)$: 概率是 $b \\cdot a \\cdot b = ab^2$。\n-   $(-1, -1, +1)$: 概率是 $b \\cdot b \\cdot a = ab^2$。\n将这些概率相加，一个给定三元组上出现一致$\\mathrm{FFL}$的总概率为 $P_{\\mathrm{coh}} = a^3 + 3ab^2$。\n\n对于一个 **不一致的** $\\mathrm{FFL}$，符号必须满足 $s_{xz} = -s_{xy} \\cdot s_{yz}$。可能的符号组合是：\n-   $(+1, +1, -1)$: 概率是 $a \\cdot a \\cdot b = a^2b$。\n-   $(+1, -1, +1)$: 概率是 $a \\cdot b \\cdot a = a^2b$。\n-   $(-1, +1, +1)$: 概率是 $b \\cdot a \\cdot a = a^2b$。\n-   $(-1, -1, -1)$: 概率是 $b \\cdot b \\cdot b = b^3$。\n将这些概率相加，一个给定三元组上出现不一致$\\mathrm{FFL}$的总概率为 $P_{\\mathrm{incoh}} = 3a^2b + b^3$。\n\n给定一个包含 $T$ 个待研究三元组的列表，期望计数可以根据期望的线性性质推导出来。一致和不一致$\\mathrm{FFL}$的期望数量为：\n$$E_{\\mathrm{coh}} = T \\cdot P_{\\mathrm{coh}}$$\n$$E_{\\mathrm{incoh}} = T \\cdot P_{\\mathrm{incoh}}$$\n\n**4. 富集度计算**\n\n富集比 $R$ 量化了一个模体的观测频率相对于其在零模型中期望频率的高低程度。它被定义为观测计数与期望计数的比率：\n$$R_{\\mathrm{coh}} = \\frac{O_{\\mathrm{coh}}}{E_{\\mathrm{coh}}}$$\n$$R_{\\mathrm{incoh}} = \\frac{O_{\\mathrm{incoh}}}{E_{\\mathrm{incoh}}}$$\n\n当期望计数为零时，会出现特殊情况。问题指定了以下处理方式：\n-   如果 $E = 0$ 且 $O = 0$，富集度 $R$ 定义为 $0.0$。\n-   如果 $E = 0$ 且 $O  0$，富集度 $R$ 定义为 $+\\infty$。\n\n通过为每个提供的测试用例执行这些步骤，我们可以计算出所需的数值列表：$[O_{\\mathrm{coh}}, O_{\\mathrm{incoh}}, E_{\\mathrm{coh}}, E_{\\mathrm{incoh}}, R_{\\mathrm{coh}}, R_{\\mathrm{incoh}}]$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the FFL analysis problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"num_nodes\": 5,\n            \"edges\": [\n                (0, 1, 1), (0, 2, -1), (1, 2, 1), (1, 3, -1), (0, 3, 1),\n                (3, 2, -1), (2, 4, 1), (0, 4, -1)\n            ],\n            \"triads\": [\n                (0, 1, 2), (0, 1, 3), (0, 3, 2), (1, 2, 4), (0, 2, 4)\n            ]\n        },\n        {\n            \"num_nodes\": 4,\n            \"edges\": [\n                (0, 1, 1), (0, 2, 1), (1, 2, 1), (1, 3, 1), (0, 3, 1), (2, 3, 1)\n            ],\n            \"triads\": [\n                (0, 1, 2), (0, 1, 3), (1, 2, 3)\n            ]\n        },\n        {\n            \"num_nodes\": 4,\n            \"edges\": [\n                (0, 1, 1), (3, 1, 1), (0, 3, -1), (2, 3, -1)\n            ],\n            \"triads\": [\n                (0, 2, 3), (1, 2, 3)\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"num_nodes\"], case[\"edges\"], case[\"triads\"])\n        results.append(result)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_list in results:\n        inner_list_str = []\n        for item in res_list:\n            if isinstance(item, int):\n                inner_list_str.append(str(item))\n            elif item == float('inf'):\n                inner_list_str.append('inf')\n            elif isinstance(item, float):\n                inner_list_str.append(f\"{item:.6f}\")\n        formatted_results.append(f\"[{','.join(inner_list_str)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef process_case(num_nodes, edges, triads):\n    \"\"\"\n    Processes a single test case to find FFLs and calculate enrichment.\n    \"\"\"\n    # 1. Construct graph representation and count edge signs\n    graph = {}\n    e_plus = 0\n    e_minus = 0\n    for u, v, s in edges:\n        graph[(u, v)] = s\n        if s == 1:\n            e_plus += 1\n        elif s == -1:\n            e_minus += 1\n\n    # 2. Identify and classify observed FFLs\n    o_coh = 0\n    o_incoh = 0\n    for x, y, z in triads:\n        s_xy = graph.get((x, y), 0)\n        s_xz = graph.get((x, z), 0)\n        s_yz = graph.get((y, z), 0)\n\n        # Check if it's an FFL\n        if s_xy != 0 and s_xz != 0 and s_yz != 0:\n            if s_xz == s_xy * s_yz:\n                o_coh += 1\n            else:\n                o_incoh += 1\n    \n    # 3. Compute expected counts from the null model\n    m = num_nodes * (num_nodes - 1)\n    a = e_plus / m if m > 0 else 0\n    b = e_minus / m if m > 0 else 0\n    \n    num_triads = len(triads)\n    \n    p_coh = a**3 + 3 * a * b**2\n    p_incoh = 3 * a**2 * b + b**3\n    \n    e_coh = num_triads * p_coh\n    e_incoh = num_triads * p_incoh\n\n    # 4. Compute enrichment ratios\n    # Coherent enrichment\n    if e_coh == 0:\n        r_coh = 0.0 if o_coh == 0 else float('inf')\n    else:\n        r_coh = o_coh / e_coh\n    \n    # Incoherent enrichment\n    if e_incoh == 0:\n        r_incoh = 0.0 if o_incoh == 0 else float('inf')\n    else:\n        r_incoh = o_incoh / e_incoh\n\n    return [o_coh, o_incoh, e_coh, e_incoh, r_coh, r_incoh]\n\nsolve()\n```"
        }
    ]
}