{
    "hands_on_practices": [
        {
            "introduction": "We begin with a foundational motif in synthetic biology: the genetic toggle switch. This exercise provides practice in translating a simple biological interaction—mutual repression—into a formal Boolean model. By identifying the stable steady-states, or fixed-point attractors, you will gain firsthand insight into how this network architecture naturally gives rise to bistability, a key property for cellular memory and decision-making. ",
            "id": "1419894",
            "problem": "A genetic toggle switch is a small synthetic gene-regulatory network that exhibits bistability. Consider a simplified model of a toggle switch composed of two genes, Gene Alpha and Gene Beta. The state of this system at a discrete time step $t$ can be described by a pair of Boolean variables, $(A(t), B(t))$, where a value of 1 signifies that the gene is expressed (ON) and a value of 0 signifies that it is not expressed (OFF).\n\nThe two genes are mutual repressors. The rules governing the network's evolution are as follows, under a synchronous update scheme (both genes update their state simultaneously at each time step):\n\n1.  Gene Alpha will be expressed at time $t+1$ if and only if Gene Beta is NOT expressed at time $t$.\n2.  Gene Beta will be expressed at time $t+1$ if and only if Gene Alpha is NOT expressed at time $t$.\n\nA stable steady-state, also known as a fixed point, is a state of the system that remains unchanged over time. That is, if the system is in state $(A(t), B(t))$, its next state $(A(t+1), B(t+1))$ is identical.\n\nIdentify all possible stable steady-states (fixed points) of this genetic toggle switch model.\n\nA. The state (0, 0) a single steady-state.\n\nB. The states (0, 1) and (1, 0) are the two steady-states.\n\nC. The state (1, 1) is a single steady-state.\n\nD. The states (0, 0) and (1, 1) are the two steady-states.\n\nE. All four states (0, 0), (0, 1), (1, 0), and (1, 1) are steady-states.\n\nF. The system has no stable steady-states.",
            "solution": "Let $A(t), B(t) \\in \\{0,1\\}$ denote the states of Gene Alpha and Gene Beta at time $t$. The synchronous update rules are\n$$\nA(t+1)=\\neg B(t), \\quad B(t+1)=\\neg A(t),\n$$\nwhere $\\neg$ denotes Boolean NOT. A fixed point is a state $(A,B)$ such that\n$$\nA(t+1)=A(t)=A, \\quad B(t+1)=B(t)=B.\n$$\nTherefore, fixed points satisfy the system\n$$\nA=\\neg B, \\quad B=\\neg A.\n$$\nFrom $A=\\neg B$, applying $\\neg$ to both sides gives $\\neg A=\\neg(\\neg B)=B$, which matches the second equation. Thus the system reduces to solving $A=\\neg B$ over Boolean values. The solutions are exactly\n$$\n(A,B)=(0,1) \\quad \\text{and} \\quad (A,B)=(1,0).\n$$\nVerification:\n- For $(0,1)$, the update gives $(\\neg 1,\\neg 0)=(0,1)$, so it is a fixed point.\n- For $(1,0)$, the update gives $(\\neg 0,\\neg 1)=(1,0)$, so it is a fixed point.\nThe remaining states are not fixed:\n- $(0,0)\\mapsto(1,1)\\neq(0,0)$,\n- $(1,1)\\mapsto(0,0)\\neq(1,1)$.\nHence the stable steady-states are $(0,1)$ and $(1,0)$, corresponding to option B.",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "Having explored fixed points, we now turn to more complex dynamics and the global structure of the state space. This problem challenges you to analyze a network that gives rise to limit cycle attractors and to map the boundaries of their influence. By identifying initial states that are close in state space (Hamming distance of 1) yet lead to different long-term outcomes, you will develop an intuition for the concept of basins of attraction and the system's sensitivity to initial conditions. ",
            "id": "1419879",
            "problem": "Consider a simplified model of a genetic regulatory circuit consisting of three genes, $G_1$, $G_2$, and $G_3$. The state of each gene can be either 'off' (represented by 0) or 'on' (represented by 1). The state of the entire system at a discrete time step $t$ is given by the ordered triple $S(t) = (g_1(t), g_2(t), g_3(t))$, where $g_i(t)$ is the state of gene $G_i$. The system evolves in synchronous discrete time steps according to the following Boolean update rules, where $g'_i$ denotes the state of gene $G_i$ at time $t+1$:\n\n$g'_1 = \\neg g_2(t)$\n$g'_2 = \\neg g_3(t)$\n$g'_3 = \\neg g_1(t)$\n\nHere, $\\neg$ represents the logical NOT operator. The long-term behavior of the system from a given initial state is to settle into an attractor, which can be a single stable state (a fixed point) or a repeating sequence of states (a limit cycle). The set of all initial states that lead to a particular attractor is called its basin of attraction.\n\nThe Hamming distance between two states is the number of gene states in which they differ. Which of the following pairs of initial states, $(S_A, S_B)$, has a Hamming distance of 1 and where $S_A$ and $S_B$ belong to the basins of two different attractors?\n\nA. $((0, 0, 0), (1, 1, 1))$\n\nB. $((1, 0, 0), (0, 1, 0))$\n\nC. $((0, 0, 0), (1, 0, 0))$\n\nD. $((1, 1, 0), (0, 1, 0))$\n\nE. $((0, 0, 1), (1, 0, 1))$",
            "solution": "Define the synchronous Boolean update map $F:\\{0,1\\}^{3}\\to\\{0,1\\}^{3}$ by\n$$\nF(g_{1},g_{2},g_{3})=(\\neg g_{2},\\,\\neg g_{3},\\,\\neg g_{1}).\n$$\nAttractors are periodic orbits (including possible fixed points) of $F$.\n\nFirst, test for fixed points $(g_{1},g_{2},g_{3})$ satisfying\n$$\ng_{1}=\\neg g_{2},\\quad g_{2}=\\neg g_{3},\\quad g_{3}=\\neg g_{1}.\n$$\nFrom $g_{1}=\\neg g_{2}$ and $g_{2}=\\neg g_{3}$, we obtain $g_{1}=\\neg(\\neg g_{3})=g_{3}$. Combining with $g_{3}=\\neg g_{1}$ yields $g_{1}=\\neg g_{1}$, which is impossible. Therefore, there are no fixed points.\n\nNext, show $F$ is bijective by solving for the unique preimage $(g_{1},g_{2},g_{3})$ from a given image $(g'_{1},g'_{2},g'_{3})$:\n$$\ng'_{1}=\\neg g_{2}\\Rightarrow g_{2}=\\neg g'_{1},\\quad\ng'_{2}=\\neg g_{3}\\Rightarrow g_{3}=\\neg g'_{2},\\quad\ng'_{3}=\\neg g_{1}\\Rightarrow g_{1}=\\neg g'_{3}.\n$$\nThus $F$ is a permutation of the $8$ states, so every state lies on a cycle (no transients). Compute the images to identify the cycles:\n- $F(0,0,0)=(1,1,1)$ and $F(1,1,1)=(0,0,0)$, giving a $2$-cycle $\\{000,111\\}$.\n- Starting from $(0,0,1)$:\n$$\n001\\to 101\\to 100\\to 110\\to 010\\to 011\\to 001,\n$$\nwhich is a $6$-cycle containing $\\{001,011,010,110,100,101\\}$.\n\nTherefore, there are exactly two attractors: the $2$-cycle $\\{000,111\\}$ and the $6$-cycle $\\{001,011,010,110,100,101\\}$. Because $F$ is bijective, the basin of each attractor is precisely the set of states on that attractor.\n\nNow evaluate the options. The Hamming distance $d_{H}(S_{A},S_{B})$ is the number of positions in which the two triples differ.\n- A: $(000,111)$ has $d_{H}=3$, not $1$.\n- B: $(100,010)$ has $d_{H}=2$; both are in the $6$-cycle basin.\n- C: $(000,100)$ has $d_{H}=1$; $000$ is in the $2$-cycle basin and $100$ is in the $6$-cycle basin.\n- D: $(110,010)$ has $d_{H}=1$; both are in the $6$-cycle basin.\n- E: $(001,101)$ has $d_{H}=1$; both are in the $6$-cycle basin.\n\nOnly option C satisfies both conditions.",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "This final practice moves from abstract models to a concrete application in computational systems biology: predicting cell fate in hematopoiesis. The exercise requires you to implement a simulation and directly compare the effects of synchronous versus asynchronous updating—a critical and often-debated choice in Boolean modeling. By observing how this single modeling assumption can alter the predicted attractors and, consequently, the cellular phenotype, you will appreciate the importance of critically evaluating the premises of your model. ",
            "id": "2376751",
            "problem": "You are given a discrete gene-regulatory Boolean network intended to capture coarse-grained lineage decisions during hematopoiesis. A Boolean network consists of a finite set of nodes and a deterministic update function for each node. The system state at time $t$ is a vector $\\mathbf{x}(t) \\in \\{0,1\\}^{n}$, where $n$ is the number of nodes and each component encodes the inactive ($0$) or active ($1$) state of a gene or regulatory factor. Each node $i$ has a Boolean update function $f_i:\\{0,1\\}^{n}\\to\\{0,1\\}$, and the global update rule aggregates these $n$ node-wise updates under a specified updating scheme. Two schemes are considered: synchronous updating and asynchronous updating. In synchronous updating, all $n$ nodes are updated simultaneously at each discrete time step $t\\to t+1$ using $\\mathbf{x}(t+1)=\\left(f_1(\\mathbf{x}(t)),\\dots,f_n(\\mathbf{x}(t))\\right)$. In asynchronous updating, at each micro-step only one node is updated according to its function while other nodes retain their current values; a schedule specifies which node to update at each micro-step. An attractor is either a fixed point (period-$1$ cycle) or a limit cycle (period-$k$ with $k\\ge 2$) within the state-transition graph under a chosen updating scheme. The predicted cell fate is defined by the attractor reached from a specified initial condition.\n\nConsider the following network of $n=5$ nodes, ordered as $\\left[G,P,F,C,E\\right]$, representing, respectively, GATA$1$, PU.$1$, FOG$1$, CEBP$\\alpha$, and E$2$A. The Boolean update rules are:\n- $G^{+} = (G \\lor F)\\land \\neg P$,\n- $P^{+} = (P \\lor C)\\land \\neg G$,\n- $F^{+} = G$,\n- $C^{+} = P$,\n- $E^{+} = \\neg (G \\lor P)$,\nwhere $X^{+}$ denotes the value of node $X$ at the next time index under the chosen updating scheme, $\\lor$ is logical disjunction, $\\land$ is logical conjunction, and $\\neg$ is logical negation.\n\nPredicted cell fates are mapped from the attractor as follows. If the attractor is a fixed point $\\mathbf{x}^{\\star}$:\n- Erythroid: if $G^{\\star}=1$ and $P^{\\star}=0$ (encode as integer $0$),\n- Myeloid: if $G^{\\star}=0$ and $P^{\\star}=1$ (encode as integer $1$),\n- Lymphoid: if $G^{\\star}=0$ and $P^{\\star}=0$ (encode as integer $2$).\nIf the attractor is a limit cycle (period $k\\ge 2$) or an otherwise ambiguous configuration, encode as integer $3$.\n\nImplement a program that, for each test case below, computes the predicted fate code as an integer according to the network and mapping above. Your implementation should:\n- For synchronous updating, iterate $\\mathbf{x}(t+1)=\\mathbf{f}(\\mathbf{x}(t))$ until an attractor is detected by first repeat of a previously seen state. If the period is $1$, map $\\mathbf{x}^{\\star}$ to a fate code as defined; if the period is greater than $1$, return $3$. Use a maximum of $T_{\\max}=50$ steps; if no attractor is found by then, return $3$.\n- For asynchronous updating, use the provided schedule of node indices to update one node per micro-step. If the schedule has length $L$, apply it cyclically (i.e., position $s$ in the infinite schedule is the index at $(s \\bmod L)$). Detect and classify attractors as in the synchronous case, with the same $T_{\\max}=50$ bound; if no attractor is found by then, return $3$.\n\nTest suite. Each test case is a tuple indicating the updating scheme, initial condition, and, for asynchronous cases, the schedule:\n- Test case $1$: synchronous; initial $\\mathbf{x}(0)=[1,0,1,0,0]$.\n- Test case $2$: synchronous; initial $\\mathbf{x}(0)=[0,1,0,1,0]$.\n- Test case $3$: synchronous; initial $\\mathbf{x}(0)=[0,0,0,0,0]$.\n- Test case $4$: asynchronous; initial $\\mathbf{x}(0)=[1,1,1,1,0]$; schedule $[0,2,3,4,1]$ repeated cyclically.\n- Test case $5$: asynchronous; initial $\\mathbf{x}(0)=[1,1,1,1,0]$; schedule $[1,3,4,0,2]$ repeated cyclically.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[0,1,2,3,0]\"). Each element must be the integer fate code for the corresponding test case in the order listed above. No physical units are involved. Angles are not used. Percentages are not used. The only allowed output types are integers aggregated into the specified list format.",
            "solution": "The problem requires the simulation of a discrete gene-regulatory Boolean network to predict cell fates based on the network's attractors. The validation of the problem statement finds it to be scientifically grounded, well-posed, and computationally tractable. We shall therefore proceed to construct a solution.\n\nThe system is a Boolean network with $n=5$ nodes, representing key regulatory factors in hematopoiesis. The state of the system at any discrete time $t$ is a vector $\\mathbf{x}(t) \\in \\{0,1\\}^{5}$, where the components correspond to the genes $[G, P, F, C, E]$ in that order. An entry of $1$ denotes an active gene, and $0$ denotes an inactive gene.\n\nThe dynamics of the network are governed by a set of Boolean update functions, one for each node $i$, denoted by $f_i:\\{0,1\\}^5 \\to \\{0,1\\}$. Let the state vector be $\\mathbf{x} = [x_0, x_1, x_2, x_3, x_4]$, corresponding to $[G, P, F, C, E]$. The update rules are given as:\n- $G^{+} = x_0^{+} = f_0(\\mathbf{x}) = (x_0 \\lor x_2) \\land \\neg x_1$\n- $P^{+} = x_1^{+} = f_1(\\mathbf{x}) = (x_1 \\lor x_3) \\land \\neg x_0$\n- $F^{+} = x_2^{+} = f_2(\\mathbf{x}) = x_0$\n- $C^{+} = x_3^{+} = f_3(\\mathbf{x}) = x_1$\n- $E^{+} = x_4^{+} = f_4(\\mathbf{x}) = \\neg (x_0 \\lor x_1)$\nHere, $\\lor$ is logical OR, $\\land$ is logical AND, and $\\neg$ is logical NOT. The result of these logical operations must be interpreted as integers $0$ or $1$.\n\nThe problem specifies two distinct updating schemes: synchronous and asynchronous. For each scheme, we must simulate the network's trajectory from a given initial state $\\mathbf{x}(0)$ to identify an attractor. An attractor is a state or a set of states that, once entered, the system cannot leave. It can be a fixed point (a state that maps to itself, forming a cycle of period $k=1$) or a limit cycle (a sequence of states that repeats, forming a cycle of period $k \\ge 2$).\n\nThe core of the algorithm for both schemes is to iterate the system state and maintain a history of visited states to detect when a state repeats. Let us use a dictionary to store each unique state vector encountered and the time step at which it was first visited. The simulation proceeds for a maximum of $T_{\\max}=50$ steps.\n\nFor the **synchronous updating scheme**, all five node functions are evaluated simultaneously. The state of the system at time $t+1$ is computed from the state at time $t$ as follows:\n$$\n\\mathbf{x}(t+1) = \\mathbf{f}(\\mathbf{x}(t)) = [f_0(\\mathbf{x}(t)), f_1(\\mathbf{x}(t)), f_2(\\mathbf{x}(t)), f_3(\\mathbf{x}(t)), f_4(\\mathbf{x}(t))]\n$$\nThe simulation proceeds as follows:\n1. Initialize with the given state $\\mathbf{x}(0)$ at time $t=0$.\n2. Store $\\mathbf{x}(0)$ in a history record: `history[tuple(x(0))] = 0`.\n3. For $t$ from $0$ to $T_{\\max}-1$:\n   a. Compute the next state, $\\mathbf{x}_{next} = \\mathbf{f}(\\mathbf{x}(t))$.\n   b. Check if $\\mathbf{x}_{next}$ has been seen before (i.e., if `tuple(x_next)` is in `history`).\n   c. If yes, an attractor is found. Let $t_{prev}$ be the time step stored for $\\mathbf{x}_{next}$. The period of the cycle is $k = (t+1) - t_{prev}$.\n   d. If no, add $\\mathbf{x}_{next}$ to the history: `history[tuple(x_next)] = t+1`, and set $\\mathbf{x}(t+1) = \\mathbf{x}_{next}$.\n4. If the loop completes without finding a cycle, the outcome is considered ambiguous.\n\nFor the **asynchronous updating scheme**, only one node is updated per micro-step, determined by a given schedule. The schedule is a sequence of node indices that is repeated cyclically. Let the schedule be $S$ of length $L$.\n1. Initialize with the given state $\\mathbf{x}(0)$ at micro-step $s=0$.\n2. Store $\\mathbf{x}(0)$ in a history record: `history[tuple(x(0))] = 0`.\n3. For $s$ from $0$ to $T_{\\max}-1$:\n   a. Determine the node to update: $i = S[s \\bmod L]$.\n   b. Compute the new value for only this node: $x'_{i} = f_i(\\mathbf{x}(s))$.\n   c. Form the next state $\\mathbf{x}(s+1)$ by copying $\\mathbf{x}(s)$ and setting its $i$-th component to $x'_{i}$.\n   d. The cycle detection logic is identical to the synchronous case, using micro-step index $s$ instead of $t$.\n\nOnce an attractor is identified, it must be classified to determine the cell fate.\n- If the attractor is a fixed point (period $k=1$), its state vector $\\mathbf{x}^{\\star} = [G^{\\star}, P^{\\star}, F^{\\star}, C^{\\star}, E^{\\star}]$ is used for mapping.\n  - Erythroid (code $0$): if $G^{\\star}=1$ and $P^{\\star}=0$.\n  - Myeloid (code $1$): if $G^{\\star}=0$ and $P^{\\star}=1$.\n  - Lymphoid (code $2$): if $G^{\\star}=0$ and $P^{\\star}=0$.\n- If the attractor is a limit cycle (period $k \\ge 2$) or if no attractor is found within $T_{\\max}$ steps, the fate is ambiguous (code $3$). It is worth noting that for a state space of size $2^5=32$, any trajectory must repeat a state within $32$ steps, so the $T_{\\max}=50$ limit is more than sufficient.\n\nLet us trace **Test Case 4**: asynchronous update, $\\mathbf{x}(0)=[1,1,1,1,0]$, and schedule $[0,2,3,4,1]$.\n- State representation: $[G, P, F, C, E]$.\n- Initial state at $s=0$: $\\mathbf{x}_0 = [1,1,1,1,0]$. History: $\\{ (1,1,1,1,0): 0 \\}$.\n- Micro-step $s=1$ (update index $0$, node $G$): $G^{+} = (1 \\lor 1) \\land \\neg 1 = 0$. New state $\\mathbf{x}_1 = [0,1,1,1,0]$. History: $\\{ \\dots, (0,1,1,1,0): 1 \\}$.\n- Micro-step $s=2$ (update index $2$, node $F$): $F^{+} = G = 0$. New state $\\mathbf{x}_2 = [0,1,0,1,0]$. History: $\\{ \\dots, (0,1,0,1,0): 2 \\}$.\n- Micro-step $s=3$ (update index $3$, node $C$): $C^{+} = P = 1$. New state $\\mathbf{x}_3 = [0,1,0,1,0]$.\n- At this point, the generated state $\\mathbf{x}_3$ has already been seen. It was first recorded at micro-step $s_{prev}=2$.\n- The period is $k = (\\text{current step index}) - s_{prev} = 3 - 2 = 1$. The attractor is a fixed point.\n- The fixed point state is $\\mathbf{x}^{\\star} = [0,1,0,1,0]$.\n- Mapping this to a fate: $G^{\\star}=0, P^{\\star}=1$ corresponds to Myeloid, which has code $1$.\nThe implementation will follow this logic for all test cases.\n```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Boolean network simulation problem for a given set of test cases.\n    \"\"\"\n\n    T_max = 50\n\n    def get_update_vector(state):\n        \"\"\"\n        Computes the full next state vector for synchronous update.\n        state: [G, P, F, C, E]\n        \"\"\"\n        x = state\n        g_next = (x[0] or x[2]) and not x[1]\n        p_next = (x[1] or x[3]) and not x[0]\n        f_next = x[0]\n        c_next = x[1]\n        e_next = not (x[0] or x[1])\n        return np.array([g_next, p_next, f_next, c_next, e_next], dtype=int)\n\n    def get_single_update(state, node_index):\n        \"\"\"\n        Computes the updated value for a single node.\n        \"\"\"\n        x = state\n        if node_index == 0:  # G\n            return (x[0] or x[2]) and not x[1]\n        elif node_index == 1:  # P\n            return (x[1] or x[3]) and not x[0]\n        elif node_index == 2:  # F\n            return x[0]\n        elif node_index == 3:  # C\n            return x[1]\n        elif node_index == 4:  # E\n            return not (x[0] or x[1])\n        return x[node_index] # Should not be reached\n\n    def get_fate_code(state_vector):\n        \"\"\"\n        Maps a fixed point attractor state to a fate code.\n        \"\"\"\n        g_star, p_star = state_vector[0], state_vector[1]\n        if g_star == 1 and p_star == 0:\n            return 0  # Erythroid\n        if g_star == 0 and p_star == 1:\n            return 1  # Myeloid\n        if g_star == 0 and p_star == 0:\n            return 2  # Lymphoid\n        # According to the problem analysis, this case should not be reached\n        # for a fixed point of the given network.\n        return 3 # Ambiguous\n\n    def simulate_synchronous(initial_state):\n        \"\"\"\n        Simulates the network using synchronous updates.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n\n        for t in range(T_max):\n            next_state = get_update_vector(current_state)\n            \n            if tuple(next_state) in history:\n                t_prev = history[tuple(next_state)]\n                period = (t + 1) - t_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = t + 1\n            current_state = next_state\n        \n        return 3 # No attractor found within T_max\n\n    def simulate_asynchronous(initial_state, schedule):\n        \"\"\"\n        Simulates the network using asynchronous updates based on a schedule.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n        schedule_len = len(schedule)\n\n        for s in range(T_max):\n            node_to_update = schedule[s % schedule_len]\n            \n            next_state = current_state.copy()\n            updated_val = get_single_update(current_state, node_to_update)\n            next_state[node_to_update] = int(updated_val)\n            \n            if tuple(next_state) in history:\n                s_prev = history[tuple(next_state)]\n                period = (s + 1) - s_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = s + 1\n            current_state = next_state\n            \n        return 3 # No attractor found within T_max\n\n    test_cases = [\n        {'type': 'sync', 'initial': [1, 0, 1, 0, 0]},\n        {'type': 'sync', 'initial': [0, 1, 0, 1, 0]},\n        {'type': 'sync', 'initial': [0, 0, 0, 0, 0]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [0, 2, 3, 4, 1]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [1, 3, 4, 0, 2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'sync':\n            result = simulate_synchronous(case['initial'])\n        else: # async\n            result = simulate_asynchronous(case['initial'], case['schedule'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```",
            "answer": "$$\\boxed{\\text{[0,1,2,1,0]}}$$"
        }
    ]
}