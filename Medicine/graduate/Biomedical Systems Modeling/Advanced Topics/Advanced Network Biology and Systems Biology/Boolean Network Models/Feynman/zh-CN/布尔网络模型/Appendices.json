{
    "hands_on_practices": [
        {
            "introduction": "基因转换开关是合成生物学中的一个基本模体，它由两个相互抑制的基因组成。这个练习 () 旨在帮助你通过分析这个简单网络来识别稳定稳态，即不动点吸引子。理解其双稳态特性（存在两种稳定状态）是掌握布尔网络如何模拟细胞决策和记忆功能的关键第一步。",
            "id": "1419894",
            "problem": "遗传拨动开关是一种表现出双稳态的小型合成基因调控网络。考虑一个由两个基因（基因 Alpha 和基因 Beta）组成的拨动开关的简化模型。在离散时间步长 $t$ 时，该系统的状态可以用一对布尔变量 $(A(t), B(t))$ 来描述，其中值 1 表示基因表达（ON），值 0 表示基因不表达（OFF）。\n\n这两个基因是相互抑制的。在同步更新方案（两个基因在每个时间步长同时更新其状态）下，控制网络演化的规则如下：\n\n1.  基因 Alpha 在时间 $t+1$ 将被表达，当且仅当基因 Beta 在时间 $t$ 不被表达。\n2.  基因 Beta 在时间 $t+1$ 将被表达，当且仅当基因 Alpha 在时间 $t$ 不被表达。\n\n一个稳定的稳态，也称为不动点，是系统随时间保持不变的状态。也就是说，如果系统处于状态 $(A(t), B(t))$，其下一个状态 $(A(t+1), B(t+1))$ 是相同的。\n\n找出该遗传拨动开关模型所有可能的稳定稳态（不动点）。\n\nA. 状态 (0, 0) 是单个稳态。\n\nB. 状态 (0, 1) 和 (1, 0) 是两个稳态。\n\nC. 状态 (1, 1) 是单个稳态。\n\nD. 状态 (0, 0) 和 (1, 1) 是两个稳态。\n\nE. 所有四个状态 (0, 0), (0, 1), (1, 0) 和 (1, 1) 都是稳态。\n\nF. 该系统没有稳定的稳态。",
            "solution": "令 $A(t), B(t) \\in \\{0,1\\}$ 表示基因 Alpha 和基因 Beta 在时间 $t$ 的状态。同步更新规则为\n$$\nA(t+1)=\\neg B(t), \\quad B(t+1)=\\neg A(t),\n$$\n其中 $\\neg$ 表示布尔非。一个不动点是满足以下条件的状态 $(A,B)$：\n$$\nA(t+1)=A(t)=A, \\quad B(t+1)=B(t)=B.\n$$\n因此，不动点满足以下方程组：\n$$\nA=\\neg B, \\quad B=\\neg A.\n$$\n从 $A=\\neg B$ 出发，对两边应用 $\\neg$ 运算得到 $\\neg A=\\neg(\\neg B)=B$，这与第二个方程相符。因此，该方程组简化为在布尔值上求解 $A=\\neg B$。其解恰好为\n$$\n(A,B)=(0,1) \\quad \\text{and} \\quad (A,B)=(1,0).\n$$\n验证：\n- 对于 $(0,1)$，更新得到 $(\\neg 1,\\neg 0)=(0,1)$，因此它是一个不动点。\n- 对于 $(1,0)$，更新得到 $(\\neg 0,\\neg 1)=(1,0)$，因此它是一个不动点。\n其余状态不是不动点：\n- $(0,0)\\mapsto(1,1)\\neq(0,0)$,\n- $(1,1)\\mapsto(0,0)\\neq(1,1)$.\n因此，稳定的稳态是 $(0,1)$ 和 $(1,0)$，对应于选项 B。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "识别网络中的吸引子只是第一步；更重要的是理解哪些初始状态会导向哪个最终结局。这个概念被称为“吸引盆”，它决定了系统的命运和鲁棒性。这个练习 () 将引导你分析一个三基因网络的整个状态空间，以描绘其吸引盆的边界，并探索微小扰动（汉明距离为1）如何导致系统走向完全不同的命运。",
            "id": "1419879",
            "problem": "考虑一个由三个基因 $G_1$、$G_2$ 和 $G_3$ 组成的简化遗传调控回路模型。每个基因的状态可以是“关”（用 0 表示）或“开”（用 1 表示）。在离散时间步 $t$ 时，整个系统的状态由有序三元组 $S(t) = (g_1(t), g_2(t), g_3(t))$ 给出，其中 $g_i(t)$ 是基因 $G_i$ 的状态。系统根据以下布尔更新规则以同步离散时间步演化，其中 $g'_i$ 表示基因 $G_i$ 在时间 $t+1$ 时的状态：\n\n$g'_1 = \\neg g_2(t)$\n$g'_2 = \\neg g_3(t)$\n$g'_3 = \\neg g_1(t)$\n\n在这里，$\\neg$ 表示逻辑非运算符。从一个给定的初始状态出发，系统的长期行为是稳定到一个吸引子，这个吸引子可以是一个单一的稳定状态（不动点），也可以是一个重复的状态序列（极限环）。所有导致特定吸引子的初始状态的集合称为其吸引盆。\n\n两个状态之间的汉明距离是它们基因状态不同的位置数。以下哪对初始状态 $(S_A, S_B)$ 的汉明距离为 1，并且 $S_A$ 和 $S_B$ 属于两个不同吸引子的吸引盆？\n\nA. $((0, 0, 0), (1, 1, 1))$\n\nB. $((1, 0, 0), (0, 1, 0))$\n\nC. $((0, 0, 0), (1, 0, 0))$\n\nD. $((1, 1, 0), (0, 1, 0))$\n\nE. $((0, 0, 1), (1, 0, 1))$",
            "solution": "定义同步布尔更新映射 $F:\\{0,1\\}^{3}\\to\\{0,1\\}^{3}$ 如下：\n$$\nF(g_{1},g_{2},g_{3})=(\\neg g_{2},\\,\\neg g_{3},\\,\\neg g_{1})。\n$$\n吸引子是 $F$ 的周期轨道（包括可能的不动点）。\n\n首先，测试满足以下条件的不动点 $(g_{1},g_{2},g_{3})$：\n$$\ng_{1}=\\neg g_{2},\\quad g_{2}=\\neg g_{3},\\quad g_{3}=\\neg g_{1}。\n$$\n由 $g_{1}=\\neg g_{2}$ 和 $g_{2}=\\neg g_{3}$，我们得到 $g_{1}=\\neg(\\neg g_{3})=g_{3}$。结合 $g_{3}=\\neg g_{1}$ 得出 $g_{1}=\\neg g_{1}$，这是不可能的。因此，不存在不动点。\n\n接下来，通过从给定的像 $(g'_{1},g'_{2},g'_{3})$ 求解唯一的原像 $(g_{1},g_{2},g_{3})$ 来证明 $F$ 是双射的：\n$$\ng'_{1}=\\neg g_{2}\\Rightarrow g_{2}=\\neg g'_{1},\\quad\ng'_{2}=\\neg g_{3}\\Rightarrow g_{3}=\\neg g'_{2},\\quad\ng'_{3}=\\neg g_{1}\\Rightarrow g_{1}=\\neg g'_{3}。\n$$\n因此 $F$ 是这 8 个状态的一个排列，所以每个状态都位于一个环上（没有瞬态）。计算像以确定这些环：\n- $F(0,0,0)=(1,1,1)$ 且 $F(1,1,1)=(0,0,0)$，这给出了一个 2-周期环 $\\{000,111\\}$。\n- 从 $(0,0,1)$ 开始：\n$$\n001\\to 101\\to 100\\to 110\\to 010\\to 011\\to 001,\n$$\n这是一个包含 $\\{001,011,010,110,100,101\\}$ 的 6-周期环。\n\n因此，恰好有两个吸引子：2-周期环 $\\{000,111\\}$ 和 6-周期环 $\\{001,011,010,110,100,101\\}$。因为 $F$ 是双射的，每个吸引子的吸引盆恰好是该吸引子上的状态集合。\n\n现在评估各个选项。汉明距离 $d_{H}(S_{A},S_{B})$ 是两个三元组中不同位置的数量。\n- A: $(000,111)$ 的 $d_{H}=3$，而不是 $1$。\n- B: $(100,010)$ 的 $d_{H}=2$；两者都在 6-周期环的吸引盆中。\n- C: $(000,100)$ 的 $d_{H}=1$；$000$ 在 2-周期环的吸引盆中，而 $100$ 在 6-周期环的吸引盆中。\n- D: $(110,010)$ 的 $d_{H}=1$；两者都在 6-周期环的吸引盆中。\n- E: $(001,101)$ 的 $d_{H}=1$；两者都在 6-周期环的吸引盆中。\n\n只有选项 C 同时满足两个条件。",
            "answer": "$$\\boxed{C}$$"
        },
        {
            "introduction": "生物过程本质上是随机且非同步的，因此，布尔网络模型中更新机制的选择（同步或异步）会显著影响其动力学行为和预测结果。这个编程实践 () 将一个简化的造血过程网络作为研究对象，要求你通过编写代码来模拟并比较不同更新策略下的细胞命运。通过这个练习，你将亲身体会到，一个看似微小的建模假设如何能根本性地改变对复杂生物系统命运决定的理解。",
            "id": "2376751",
            "problem": "给定一个离散的基因调控布尔网络，旨在捕捉造血过程中粗粒度的谱系决策。布尔网络由有限的节点集和每个节点的确定性更新函数组成。系统在时间 $t$ 的状态是一个向量 $\\mathbf{x}(t) \\in \\{0,1\\}^{n}$，其中 $n$ 是节点数，每个分量编码一个基因或调控因子的非激活（$0$）或激活（$1$）状态。每个节点 $i$ 都有一个布尔更新函数 $f_i:\\{0,1\\}^{n}\\to\\{0,1\\}$，全局更新规则在指定的更新方案下将这 $n$ 个节点的更新聚合起来。这里考虑两种方案：同步更新和异步更新。在同步更新中，所有 $n$ 个节点在每个离散时间步 $t\\to t+1$ 同时更新，使用 $\\mathbf{x}(t+1)=\\left(f_1(\\mathbf{x}(t)),\\dots,f_n(\\mathbf{x}(t))\\right)$。在异步更新中，每个微步只有一个节点根据其函数进行更新，而其他节点保持其当前值；一个调度表指定了在每个微步要更新哪个节点。吸引子是在选定更新方案下，状态转移图中的不动点（周期为$1$的循环）或极限环（周期 $k\\ge 2$）。预测的细胞命运由从指定的初始条件达到的吸引子定义。\n\n考虑以下包含 $n=5$ 个节点的网络，顺序为 $\\left[G,P,F,C,E\\right]$，分别代表 GATA$1$、PU.$1$、FOG$1$、CEBP$\\alpha$ 和 E$2$A。布尔更新规则如下：\n- $G^{+} = (G \\lor F)\\land \\neg P$，\n- $P^{+} = (P \\lor C)\\land \\neg G$，\n- $F^{+} = G$，\n- $C^{+} = P$，\n- $E^{+} = \\neg (G \\lor P)$，\n其中 $X^{+}$ 表示在所选更新方案下，节点 $X$ 在下一个时间索引的值，$\\lor$ 是逻辑或，$\\land$ 是逻辑与，$\\neg$ 是逻辑非。\n\n预测的细胞命运根据吸引子映射如下。如果吸引子是一个不动点 $\\mathbf{x}^{\\star}$：\n- 红系：如果 $G^{\\star}=1$ 且 $P^{\\star}=0$（编码为整数 $0$），\n- 髓系：如果 $G^{\\star}=0$ 且 $P^{\\star}=1$（编码为整数 $1$），\n- 淋巴系：如果 $G^{\\star}=0$ 且 $P^{\\star}=0$（编码为整数 $2$）。\n如果吸引子是极限环（周期 $k\\ge 2$）或其他模糊配置，则编码为整数 $3$。\n\n实现一个程序，对下面的每个测试用例，根据上述网络和映射计算预测的命运代码（一个整数）。您的实现应：\n- 对于同步更新，迭代 $\\mathbf{x}(t+1)=\\mathbf{f}(\\mathbf{x}(t))$ 直到通过首次重复先前见过的状态来检测到吸引子。如果周期为 $1$，则按定义将 $\\mathbf{x}^{\\star}$ 映射到命运代码；如果周期大于 $1$，则返回 $3$。最多使用 $T_{\\max}=50$ 步；如果届时未找到吸引子，则返回 $3$。\n- 对于异步更新，使用提供的节点索引调度表，每个微步更新一个节点。如果调度表长度为 $L$，则循环应用它（即，无限调度表中位置 $s$ 的索引是 $(s \\bmod L)$ 处的索引）。与同步情况一样检测和分类吸引子，具有相同的 $T_{\\max}=50$ 步数限制；如果届时未找到吸引子，则返回 $3$。\n\n测试套件。每个测试用例是一个元组，指明更新方案、初始条件，以及对于异步情况的调度表：\n- 测试用例 $1$：同步；初始 $\\mathbf{x}(0)=[1,0,1,0,0]$。\n- 测试用例 $2$：同步；初始 $\\mathbf{x}(0)=[0,1,0,1,0]$。\n- 测试用例 $3$：同步；初始 $\\mathbf{x}(0)=[0,0,0,0,0]$。\n- 测试用例 $4$：异步；初始 $\\mathbf{x}(0)=[1,1,1,1,0]$；调度表 $[0,2,3,4,1]$ 循环重复。\n- 测试用例 $5$：异步；初始 $\\mathbf{x}(0)=[1,1,1,1,0]$；调度表 $[1,3,4,0,2]$ 循环重复。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来的结果（例如，\"[0,1,2,3,0]\"）。每个元素必须是按上面列出的顺序对应的测试用例的整数命运代码。不涉及物理单位。不使用角度。不使用百分比。唯一允许的输出类型是聚合成指定列表格式的整数。",
            "solution": "该问题要求模拟一个离散的基因调控布尔网络，以根据网络的吸引子预测细胞命运。对问题陈述的验证发现其具有科学依据、问题设定良好且计算上是可行的。因此，我们将着手构建一个解决方案。\n\n该系统是一个具有 $n=5$ 个节点的布尔网络，代表了造血过程中的关键调控因子。在任何离散时间 $t$，系统的状态是一个向量 $\\mathbf{x}(t) \\in \\{0,1\\}^{5}$，其分量按顺序对应于基因 $[G, P, F, C, E]$。值为 $1$ 表示基因激活，值为 $0$ 表示基因非激活。\n\n网络的动态由一组布尔更新函数控制，每个节点 $i$ 一个，记为 $f_i:\\{0,1\\}^5 \\to \\{0,1\\}$。设状态向量为 $\\mathbf{x} = [x_0, x_1, x_2, x_3, x_4]$，对应于 $[G, P, F, C, E]$。更新规则如下：\n- $G^{+} = x_0^{+} = f_0(\\mathbf{x}) = (x_0 \\lor x_2) \\land \\neg x_1$\n- $P^{+} = x_1^{+} = f_1(\\mathbf{x}) = (x_1 \\lor x_3) \\land \\neg x_0$\n- $F^{+} = x_2^{+} = f_2(\\mathbf{x}) = x_0$\n- $C^{+} = x_3^{+} = f_3(\\mathbf{x}) = x_1$\n- $E^{+} = x_4^{+} = f_4(\\mathbf{x}) = \\neg (x_0 \\lor x_1)$\n这里，$\\lor$ 是逻辑或，$\\land$ 是逻辑与，$\\neg$ 是逻辑非。这些逻辑运算的结果必须解释为整数 $0$ 或 $1$。\n\n问题指定了两种不同的更新方案：同步和异步。对于每种方案，我们必须从给定的初始状态 $\\mathbf{x}(0)$ 开始模拟网络的轨迹，以识别吸引子。吸引子是一个状态或一组状态，系统一旦进入就无法离开。它可以是一个不动点（一个映射到自身的状态，形成周期 $k=1$ 的循环），也可以是一个极限环（一个重复的状态序列，形成周期 $k \\ge 2$ 的循环）。\n\n两种方案算法的核心是迭代系统状态并维护一个访问过的状态历史，以检测状态何时重复。让我们使用一个字典来存储遇到的每个唯一状态向量及其首次访问的时间步。模拟最多进行 $T_{\\max}=50$ 步。\n\n对于**同步更新方案**，所有五个节点函数同时求值。系统在时间 $t+1$ 的状态由时间 $t$ 的状态计算得出，如下所示：\n$$\n\\mathbf{x}(t+1) = \\mathbf{f}(\\mathbf{x}(t)) = [f_0(\\mathbf{x}(t)), f_1(\\mathbf{x}(t)), f_2(\\mathbf{x}(t)), f_3(\\mathbf{x}(t)), f_4(\\mathbf{x}(t))]\n$$\n模拟过程如下：\n1. 用给定的状态 $\\mathbf{x}(0)$ 在时间 $t=0$ 进行初始化。\n2. 将 $\\mathbf{x}(0)$ 存储在历史记录中：`history[tuple(x(0))] = 0`。\n3. 对于从 $0$ 到 $T_{\\max}-1$ 的 $t$：\n   a. 计算下一个状态，$\\mathbf{x}_{next} = \\mathbf{f}(\\mathbf{x}(t))$。\n   b. 检查 $\\mathbf{x}_{next}$ 是否曾被访问过（即 `tuple(x_next)` 是否在 `history` 中）。\n   c. 如果是，则找到了一个吸引子。设 $t_{prev}$ 是为 $\\mathbf{x}_{next}$ 存储的时间步。循环的周期为 $k = (t+1) - t_{prev}$。\n   d. 如果否，则将 $\\mathbf{x}_{next}$ 添加到历史记录中：`history[tuple(x_next)] = t+1`，并设置 $\\mathbf{x}(t+1) = \\mathbf{x}_{next}$。\n4. 如果循环完成而没有找到循环，则结果被视为模糊。\n\n对于**异步更新方案**，每个微步只有一个节点被更新，由给定的调度表决定。调度表是一个循环重复的节点索引序列。设调度表为 $S$，长度为 $L$。\n1. 用给定的状态 $\\mathbf{x}(0)$ 在微步 $s=0$ 进行初始化。\n2. 将 $\\mathbf{x}(0)$ 存储在历史记录中：`history[tuple(x(0))] = 0`。\n3. 对于从 $0$ 到 $T_{\\max}-1$ 的 $s$：\n   a. 确定要更新的节点：$i = S[s \\bmod L]$。\n   b. 仅计算该节点的新值：$x'_{i} = f_i(\\mathbf{x}(s))$。\n   c. 通过复制 $\\mathbf{x}(s)$ 并将其第 $i$ 个分量设置为 $x'_{i}$ 来形成下一个状态 $\\mathbf{x}(s+1)$。\n   d. 循环检测逻辑与同步情况相同，使用微步索引 $s$ 代替 $t$。\n\n一旦识别出吸引子，就必须对其进行分类以确定细胞命运。\n- 如果吸引子是不动点（周期 $k=1$），则其状态向量 $\\mathbf{x}^{\\star} = [G^{\\star}, P^{\\star}, F^{\\star}, C^{\\star}, E^{\\star}]$ 用于映射。\n  - 红系（代码 $0$）：如果 $G^{\\star}=1$ 且 $P^{\\star}=0$。\n  - 髓系（代码 $1$）：如果 $G^{\\star}=0$ 且 $P^{\\star}=1$。\n  - 淋巴系（代码 $2$）：如果 $G^{\\star}=0$ 且 $P^{\\star}=0$。\n- 如果吸引子是极限环（周期 $k \\ge 2$）或在 $T_{\\max}$ 步内未找到吸引子，则命运是模糊的（代码 $3$）。值得注意的是，对于一个大小为 $2^5=32$ 的状态空间，任何轨迹都必须在 $32$ 步内重复一个状态，因此 $T_{\\max}=50$ 的限制是绰绰有余的。\n\n让我们追踪**测试用例4**：异步更新，$\\mathbf{x}(0)=[1,1,1,1,0]$，调度表 $[0,2,3,4,1]$。\n- 状态表示：$[G, P, F, C, E]$。\n- $s=0$ 时的初始状态：$\\mathbf{x}_0 = [1,1,1,1,0]$。历史记录：$\\{ (1,1,1,1,0): 0 \\}$。\n- 微步 $s=1$（更新索引 $0$，节点 $G$）：$G^{+} = (1 \\lor 1) \\land \\neg 1 = 0$。新状态 $\\mathbf{x}_1 = [0,1,1,1,0]$。历史记录：$\\{ \\dots, (0,1,1,1,0): 1 \\}$。\n- 微步 $s=2$（更新索引 $2$，节点 $F$）：$F^{+} = G = 0$。新状态 $\\mathbf{x}_2 = [0,1,0,1,0]$。历史记录：$\\{ \\dots, (0,1,0,1,0): 2 \\}$。\n- 微步 $s=3$（更新索引 $3$，节点 $C$）：$C^{+} = P = 1$。新状态 $\\mathbf{x}_3 = [0,1,0,1,0]$。\n- 此时，生成的状态 $\\mathbf{x}_3$ 已经被访问过。它首次记录于微步 $s_{prev}=2$。\n- 周期是 $k = (\\text{当前步索引}) - s_{prev} = 3 - 2 = 1$。吸引子是一个不动点。\n- 不动点状态是 $\\mathbf{x}^{\\star} = [0,1,0,1,0]$。\n- 将此映射到命运：$G^{\\star}=0, P^{\\star}=1$ 对应于髓系，其代码为 $1$。\n该实现将对所有测试用例遵循此逻辑。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Boolean network simulation problem for a given set of test cases.\n    \"\"\"\n\n    T_max = 50\n\n    def get_update_vector(state):\n        \"\"\"\n        Computes the full next state vector for synchronous update.\n        state: [G, P, F, C, E]\n        \"\"\"\n        x = state\n        g_next = (x[0] or x[2]) and not x[1]\n        p_next = (x[1] or x[3]) and not x[0]\n        f_next = x[0]\n        c_next = x[1]\n        e_next = not (x[0] or x[1])\n        return np.array([g_next, p_next, f_next, c_next, e_next], dtype=int)\n\n    def get_single_update(state, node_index):\n        \"\"\"\n        Computes the updated value for a single node.\n        \"\"\"\n        x = state\n        if node_index == 0:  # G\n            return (x[0] or x[2]) and not x[1]\n        elif node_index == 1:  # P\n            return (x[1] or x[3]) and not x[0]\n        elif node_index == 2:  # F\n            return x[0]\n        elif node_index == 3:  # C\n            return x[1]\n        elif node_index == 4:  # E\n            return not (x[0] or x[1])\n        return x[node_index] # Should not be reached\n\n    def get_fate_code(state_vector):\n        \"\"\"\n        Maps a fixed point attractor state to a fate code.\n        \"\"\"\n        g_star, p_star = state_vector[0], state_vector[1]\n        if g_star == 1 and p_star == 0:\n            return 0  # Erythroid\n        if g_star == 0 and p_star == 1:\n            return 1  # Myeloid\n        if g_star == 0 and p_star == 0:\n            return 2  # Lymphoid\n        # According to the problem analysis, this case should not be reached\n        # for a fixed point of the given network.\n        return 3 # Ambiguous\n\n    def simulate_synchronous(initial_state):\n        \"\"\"\n        Simulates the network using synchronous updates.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n\n        for t in range(T_max):\n            next_state = get_update_vector(current_state)\n            \n            if tuple(next_state) in history:\n                t_prev = history[tuple(next_state)]\n                period = (t + 1) - t_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = t + 1\n            current_state = next_state\n        \n        return 3 # No attractor found within T_max\n\n    def simulate_asynchronous(initial_state, schedule):\n        \"\"\"\n        Simulates the network using asynchronous updates based on a schedule.\n        \"\"\"\n        current_state = np.array(initial_state, dtype=int)\n        history = {tuple(current_state): 0}\n        schedule_len = len(schedule)\n\n        for s in range(T_max):\n            node_to_update = schedule[s % schedule_len]\n            \n            next_state = current_state.copy()\n            updated_val = get_single_update(current_state, node_to_update)\n            next_state[node_to_update] = int(updated_val)\n            \n            if tuple(next_state) in history:\n                s_prev = history[tuple(next_state)]\n                period = (s + 1) - s_prev\n                if period == 1:\n                    return get_fate_code(next_state)\n                else:\n                    return 3  # Limit cycle\n            \n            history[tuple(next_state)] = s + 1\n            current_state = next_state\n            \n        return 3 # No attractor found within T_max\n\n    test_cases = [\n        {'type': 'sync', 'initial': [1, 0, 1, 0, 0]},\n        {'type': 'sync', 'initial': [0, 1, 0, 1, 0]},\n        {'type': 'sync', 'initial': [0, 0, 0, 0, 0]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [0, 2, 3, 4, 1]},\n        {'type': 'async', 'initial': [1, 1, 1, 1, 0], 'schedule': [1, 3, 4, 0, 2]},\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'sync':\n            result = simulate_synchronous(case['initial'])\n        else: # async\n            result = simulate_asynchronous(case['initial'], case['schedule'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}