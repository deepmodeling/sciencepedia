{
    "hands_on_practices": [
        {
            "introduction": "要以模型为基础进行分析，第一步是为生物系统创建一个数学表示。化学计量矩阵（$S$）是这一表示的基石，它精确地捕捉了代谢物和反应之间的定量关系。本练习  将指导你如何将一个简单的反应网络图转化为其对应的 $S$ 矩阵，从而巩固在后续所有分析中都至关重要的符号约定。",
            "id": "3888980",
            "problem": "在基因组尺度代谢模型中，充分混合假设下的细胞内质量平衡由代谢物浓度时间导数和反应通量之间的线性关系表示，其中化学计量矩阵编码了反应的参与情况。从生化网络在稳态或动态下的质量守恒出发，每个细胞内代谢物的平衡可以写成 $d\\mathbf{x}/dt = S\\,\\mathbf{v}$ 的形式，其中 $S$ 是化学计量矩阵，其元素 $s_{ij}$ 等于代谢物 $i$ 在反应 $j$ 中的带符号化学计量系数（消耗为负，生成为正，不参与为零）。考虑一个由三个代谢物和三个不可逆反应 $R1: A \\to B$、$R2: B \\to C$ 和 $R3: C \\to A$ 组成的最小闭合网络，每个反应都具有单位化学计量系数。使用质量平衡公式所隐含的标准符号约定，采用代谢物排序 $\\{A,B,C\\}$ 作为行，反应排序 $\\{R1,R2,R3\\}$ 作为列，并构建化学计量矩阵 $S$。将 $S$ 明确写成一个整数值的 $3 \\times 3$ 矩阵。最终答案必须是明确的矩阵，不需要任何四舍五入或单位。",
            "solution": "问题要求为给定的生化网络构建化学计量矩阵，记为 $S$。控制系统的基本关系是细胞内代谢物的质量平衡方程，其形式如下：\n$$\n\\frac{d\\mathbf{x}}{dt} = S\\,\\mathbf{v}\n$$\n在此方程中，$\\mathbf{x}$ 是代谢物浓度向量，$\\mathbf{v}$ 是反应通量向量，$S$ 是化学计量矩阵。矩阵 $S$ 的一个元素 $s_{ij}$ 代表代谢物 $i$ 在反应 $j$ 中的带符号化学计量系数。问题指定了标准符号约定：对于被消耗的代谢物（反应物），系数为负；对于生成的代谢物，系数为正。如果一个代谢物不参与某个反应，其对应的系数为零。\n\n问题定义了一个包含 $3$ 个代谢物和 $3$ 个反应的网络。代谢物的排序（对应于矩阵的行）被指定为 $\\{A,B,C\\}$。因此，第 $1$ 行对应代谢物 $A$，第 $2$ 行对应代谢物 $B$，第 $3$ 行对应代谢物 $C$。反应的排序（对应于矩阵的列）被指定为 $\\{R1,R2,R3\\}$。因此，第 $1$ 列对应反应 $R1$，第 $2$ 列对应反应 $R2$，第 $3$ 列对应反应 $R3$。因此，矩阵 $S$ 将是一个 $3 \\times 3$ 矩阵。\n\n给定的反应如下：\n- $R1: A \\to B$\n- $R2: B \\to C$\n- $R3: C \\to A$\n\n所有反应都被说明具有“单位化学计量系数”，这意味着每个非零系数的绝对值为 $1$。\n\n我们现在可以通过确定每一列的元素来构建矩阵 $S$，其中每一列代表一个单一的反应。\n\n对于第一列（$j=1$），它对应于反应 $R1: A \\to B$：\n- 代谢物 $A$（第 $i=1$ 行）被消耗。根据符号约定，其化学计量系数为负。考虑到单位系数，我们有 $s_{11} = -1$。\n- 代谢物 $B$（第 $i=2$ 行）被生成。其系数为正，所以 $s_{21} = +1$。\n- 代谢物 $C$（第 $i=3$ 行）不参与此反应。因此，$s_{31} = 0$。\n于是，$S$ 的第一列是 $\\begin{pmatrix} -1 \\\\ 1 \\\\ 0 \\end{pmatrix}$。\n\n对于第二列（$j=2$），它对应于反应 $R2: B \\to C$：\n- 代谢物 $A$（第 $i=1$ 行）不参与。因此，$s_{12} = 0$。\n- 代谢物 $B$（第 $i=2$ 行）被消耗。其系数为负，所以 $s_{22} = -1$。\n- 代谢物 $C$（第 $i=3$ 行）被生成。其系数为正，所以 $s_{32} = +1$。\n于是，$S$ 的第二列是 $\\begin{pmatrix} 0 \\\\ -1 \\\\ 1 \\end{pmatrix}$。\n\n对于第三列（$j=3$），它对应于反应 $R3: C \\to A$：\n- 代谢物 $A$（第 $i=1$ 行）被生成。其系数为正，所以 $s_{13} = +1$。\n- 代谢物 $B$（第 $i=2$ 行）不参与。因此，$s_{23} = 0$。\n- 代谢物 $C$（第 $i=3$ 行）被消耗。其系数为负，所以 $s_{33} = -1$。\n于是，$S$ 的第三列是 $\\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}$。\n\n最后，将三列组合起来，我们得到完整的化学计量矩阵 $S$：\n$$\nS = \\begin{pmatrix} s_{11}  s_{12}  s_{13} \\\\ s_{21}  s_{22}  s_{23} \\\\ s_{31}  s_{32}  s_{33} \\end{pmatrix} = \\begin{pmatrix} -1  0  1 \\\\ 1  -1  0 \\\\ 0  1  -1 \\end{pmatrix}\n$$\n这就是根据指定约定代表给定网络化学计量的明确的整数值 $3 \\times 3$ 矩阵。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} -1  0  1 \\\\ 1  -1  0 \\\\ 0  1  -1 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在构建了网络的数学表示之后，下一步便是模拟其行为。通量平衡分析（FBA）是一种强大的方法，它基于系统处于稳态（$S v = 0$）的假设，即代谢物不会随时间净积累。本练习  提供了一个极简但完整的FBA问题，引导你找到一个最大化特定生物学目标（如分泌速率）的最优通量分布，从而阐明基于约束的建模的核心原理。",
            "id": "3889046",
            "problem": "考虑一个最小的基因组尺度代谢模型片段，该模型包含单一的内部代谢物和两个代表摄取和分泌的不可逆交换反应。其化学计量矩阵为 $S = \\begin{bmatrix}1  -1\\end{bmatrix}$，其中第一列对应于摄取通量 $v_{1}$，第二列对应于分泌通量 $v_{2}$。假设系统处于稳态，因此内部代谢物池不发生累积。该系统受到反应边界的约束，这些边界反映了生物物理容量限制和热力学不可逆性：$0 \\leq v_{1} \\leq 10$ 和 $v_{2} \\geq 0$，其中 $v_{2}$ 没有上限。所有通量的单位均为毫摩尔每克干重每小时 (mmol gDW$^{-1}$ h$^{-1}$)，其中克干重 (gDW) 指的是细胞的干重。\n\n使用通量平衡分析的稳态假设，构建并求解线性优化问题，以在 $S v = 0$ 和给定边界的约束下最大化分泌速率 $v_{2}$。将最优目标值 $v_{2}^{\\star}$ 以单个数字的形式报告。请用单位 mmol gDW$^{-1}$ h$^{-1}$ 表示您的答案。无需四舍五入。",
            "solution": "该问题要求我们求解一个线性规划（LP）问题。通量平衡分析（FBA）的一般形式是：\n最大化 $Z = c^T v$\n约束条件为：\n1. $S v = 0$ (稳态质量平衡)\n2. $v_{lb} \\leq v \\leq v_{ub}$ (通量容量约束)\n\n现在，我们将该问题的具体已知条件应用于此通用公式。\n\n**1. 目标函数**\n目标是最大化分泌通量 $v_{2}$。这可以写成最大化目标函数 $Z = v_{2}$。\n\n**2. 约束条件**\na) **稳态约束**: $S v = 0$。代入给定的 $S$ 和 $v$：\n$$ \\begin{bmatrix}1  -1\\end{bmatrix} \\begin{bmatrix}v_{1} \\\\ v_{2}\\end{bmatrix} = 0 $$\n展开得到标量方程：\n$$ v_{1} - v_{2} = 0 \\implies v_{1} = v_{2} $$\n该方程表示，为了使内部代谢物池保持恒定，摄取速率（$v_1$）必须等于分泌速率（$v_2$）。\n\nb) **通量边界约束**:\n$$ 0 \\leq v_{1} \\leq 10 $$\n$$ v_{2} \\geq 0 $$\n\n**3. 求解**\n综合所有约束，我们的问题是：在 $v_{1} = v_{2}$ 和 $0 \\leq v_{1} \\leq 10$ 的条件下最大化 $v_{2}$。\n由于 $v_{1} = v_{2}$，最大化 $v_{2}$ 等同于最大化 $v_{1}$。\n$v_{1}$ 的最大允许值是 $10$。因此，摄取通量的最优值为 $v_{1}^{\\star} = 10$。\n根据稳态约束，分泌通量的最优值也必须是：\n$$ v_{2}^{\\star} = v_{1}^{\\star} = 10 $$\n最优目标值为 $10$。根据问题陈述，单位是 mmol gDW$^{-1}$ h$^{-1}$。最大分泌速率为 $10$ mmol gDW$^{-1}$ h$^{-1}$。",
            "answer": "$$\\boxed{10}$$"
        },
        {
            "introduction": "掌握了FBA的基本原理后，我们就可以探索其在系统生物学和代谢工程中的强大应用。合成致死是一个重要的概念，指的是两个非必需基因的同时缺失对细胞是致命的，这揭示了网络中的功能冗余。本练习  将引导你使用FBA来系统地筛选这些关键的遗传相互作用，展示模型如何为网络鲁棒性和潜在治疗靶点生成可检验的假设。",
            "id": "3888967",
            "problem": "在通量平衡分析 (FBA) 的稳态假设背景下，给定一组由化学计量矩阵和通量边界表示的分支代谢网络。在稳态下，细胞内代谢物浓度不随时间变化，且通量满足质量平衡方程。你的任务是为每个网络计算一个综合致死反应对，该反应对会阻断生物质的生产，而任何单个反应的删除都不会，并从理论上解释通路之间的相互依赖关系。\n\n定义与基础：\n- 通量平衡分析 (FBA) 假设系统处于稳态，其中细胞内代谢物浓度的累积可以忽略不计。质量平衡约束由以下线性系统给出\n$$\nS \\, v = 0,\n$$\n其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，包含 $m$ 种代谢物和 $n$ 个反应，而 $v \\in \\mathbb{R}^{n}$ 是反应通量向量。\n- 通量边界施加了生理上有意义的约束\n$$\n\\ell \\le v \\le u,\n$$\n其中下界为 $\\ell \\in \\mathbb{R}^{n}$，上界为 $u \\in \\mathbb{R}^{n}$。\n- 生物质生产被建模为一个特殊的汇反应，其索引为 $b \\in \\{0,1,\\dots,n-1\\}$，目标是最大化生物质通量 $v_b$。这可以被表述为一个线性规划问题，其目标向量 $c \\in \\mathbb{R}^{n}$ 满足 $c_b = 1$ 且对于 $i \\ne b$ 有 $c_i = 0$；该优化问题为\n$$\n\\max_{v \\in \\mathbb{R}^n} \\; c^\\top v \\quad \\text{subject to} \\quad S v = 0, \\; \\ell \\le v \\le u.\n$$\n- 对于一组可删除的反应 $D \\subseteq \\{0,1,\\dots,n-1\\}$，一个综合致死对被定义为一个反应对 $(i,j)$，其中 $i,j \\in D$, $i \\ne j$，并且在给定的生物质通量正性数值容差 $\\tau > 0$ 下满足以下性质：\n  1. 删除反应 $i$（即 $v_i = 0$，通过边界 $0 \\le v_i \\le 0$ 强制实现）后，最优生物质通量严格为正：$\\max c^\\top v > \\tau$。\n  2. 删除反应 $j$ 后，最优生物质通量严格为正：$\\max c^\\top v > \\tau$。\n  3. 同时删除反应 $i$ 和 $j$ 后，最优生物质通量在容差范围内为零：$\\max c^\\top v \\le \\tau$。\n- 在所有满足上述性质的反应对中，选择字典序最小的对，即 $i$ 最小的对 $(i,j)$，如果 $i$ 相同，则选择 $j$ 最小的对。\n\n你的程序必须为以下测试套件中的每个网络计算出这样一个反应对。如果某个网络中不存在综合致死对，则在该情况下返回一个空列表 $[\\ ]$。\n\n数值容差：\n- 使用容差 $\\tau = 10^{-7}$ 来判断是正值 ($> \\tau$) 还是有效零值 ($\\le \\tau$)。\n\n索引约定：\n- 反应使用从零开始的索引。\n\n测试套件（所有边界均为任意通量单位；所有矩阵和向量均为精确整数项）：\n\n情况 1（通往必需前体的平行冗余通路）：\n- 代谢物：$m = 2$，排序为 $[A, X]$。\n- 反应：$n = 4$，排序为 $[R_0, R_1, R_2, R_3]$，其中 $R_0$ 是吸收反应，$R_3$ 是生物质反应。\n- 化学计量矩阵\n$$\nS = \\begin{bmatrix}\n1  -1  -1  0 \\\\\n0  1  1  -1\n\\end{bmatrix}.\n$$\n- 下界\n$$\n\\ell = \\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{bmatrix}, \\quad\nu = \\begin{bmatrix}\n10 \\\\ 1000 \\\\ 1000 \\\\ 1000\n\\end{bmatrix}.\n$$\n- 生物质反应索引 $b = 3$。\n- 可删除集合 $D = \\{1, 2\\}$。\n\n情况 2（一个两步分支和一个通往相同前体的直接捷径）：\n- 代谢物：$m = 3$，排序为 $[A, Y, X]$。\n- 反应：$n = 5$，排序为 $[R_0, R_1, R_2, R_3, R_4]$，其中 $R_0$ 是吸收反应，$R_4$ 是生物质反应。\n- 化学计量矩阵\n$$\nS = \\begin{bmatrix}\n1  -1  0  -1  0 \\\\\n0  1  -1  0  0 \\\\\n0  0  1  1  -1\n\\end{bmatrix}.\n$$\n- 下界\n$$\n\\ell = \\begin{bmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{bmatrix}, \\quad\nu = \\begin{bmatrix}\n10 \\\\ 1000 \\\\ 1000 \\\\ 1000 \\\\ 1000\n\\end{bmatrix}.\n$$\n- 生物质反应索引 $b = 4$。\n- 可删除集合 $D = \\{1, 2, 3\\}$。\n\n情况 3（单一路径，无冗余）：\n- 代谢物：$m = 2$，排序为 $[A, X]$。\n- 反应：$n = 3$，排序为 $[R_0, R_1, R_2]$，其中 $R_0$ 是吸收反应，$R_2$ 是生物质反应。\n- 化学计量矩阵\n$$\nS = \\begin{bmatrix}\n1  -1  0 \\\\\n0  1  -1\n\\end{bmatrix}.\n$$\n- 下界\n$$\n\\ell = \\begin{bmatrix}\n0 \\\\ 0 \\\\ 0\n\\end{bmatrix}, \\quad\nu = \\begin{bmatrix}\n10 \\\\ 1000 \\\\ 1000\n\\end{bmatrix}.\n$$\n- 生物质反应索引 $b = 2$。\n- 可删除集合 $D = \\{1\\}$。\n\n你的程序必须为每种情况计算出 $D$ 中字典序最小的综合致死对 $(i,j)$（如果存在），否则返回一个空列表。最终输出格式必须是单行，包含一个由方括号括起来的逗号分隔列表，其中每个元素要么是一个空列表 $[\\ ]$，要么是一个包含从零开始的索引的列表 $[i,j]$。例如，输出应类似于\n$$\n[\\,[i_1,j_1],[\\ ],[i_3,j_3]\\,]\n$$\n但需以单行形式打印，不含额外文本。本问题中没有角度或物理单位，所有数值答案都是整数列表。通过遵守稳态质量平衡和线性约束，并完全按照规定计算线性规划，来确保科学真实性。",
            "solution": "### 基于原则的设计与解题步骤\n\n核心任务是在代谢网络中识别综合致死反应对。一个综合致死对 $(i, j)$ 是指一对反应，它们对于细胞目标（此处为生物质生产）来说单独是非必需的，但共同作用时却是必需的。同时移除它们会导致目标函数的失效。这种现象通常源于代谢通路中的冗余，即两个或多个反应或通路可以执行等效的功能。\n\n**1. 通量平衡分析 (FBA) 的公式化**\n\n分析的基础是稳态假设，该假设假定在相关的时间尺度上，内部代谢物的浓度不发生变化。这表示为每个代谢物的质量平衡方程：\n$$\nS v = 0\n$$\n其中 $S$ 是 $m \\times n$ 的化学计量矩阵，代表 $m$ 种代谢物和 $n$ 个反应，$v$ 是 $n$ 个反应通量的向量。\n\n每个通量 $v_k$ 的可能范围受到下界 $\\ell_k$ 和上界 $u_k$ 的约束：\n$$\n\\ell \\le v \\le u\n$$\n这些边界可以代表热力学约束（例如，不可逆性，$v_k \\ge 0$）或营养物吸收或酶容量的限制。\n\n细胞目标被假定为最大化一个特定的生物功能，建模为通过生物质反应的通量 $v_b$。这被公式化为一个线性规划（LP）问题：\n$$\n\\text{maximize} \\quad c^\\top v \\quad \\text{subject to} \\quad S v = 0, \\quad \\ell \\le v \\le u\n$$\n其中目标向量 $c$ 的定义为 $c_b=1$ 且所有其他分量为零。\n\n**2. 定义和识别综合致死对**\n\n从可删除反应集合 $D$ 中取出一对反应 $(i,j)$，如果它满足以下三个条件（对照数值容差 $\\tau = 10^{-7}$ 进行检查），则被定义为综合致死：\n1.  **删除反应 $i$ 后的生存能力**：当反应 $i$ 被删除时，最大生物质通量大于 $\\tau$。\n2.  **删除反应 $j$ 后的生存能力**：当反应 $j$ 被删除时，最大生物质通量大于 $\\tau$。\n3.  **双重删除 $(i,j)$ 的致死性**：当反应 $i$ 和 $j$ 都被删除时，最大生物质通量小于或等于 $\\tau$。\n\n反应的删除在计算上通过将其通量边界设置为零来建模，即对于一个被删除的反应 $k$，我们设置 $\\ell_k = 0$ 和 $u_k = 0$。\n\n**3. 算法方法**\n\n为了为每个给定的网络找到字典序最小的综合致死对，我们将采用一种系统搜索算法：\n1.  对于每个测试用例（网络），获取可删除反应的集合 $D$。\n2.  从 $D$ 中生成所有唯一的对 $(i, j)$，使得 $i  j$。为确保首先找到字典序最小的对，搜索应按 $i$ 的递增顺序进行，对于每个 $i$，再按 $j$ 的递增顺序进行。\n3.  对于每个候选对 $(i, j)$：\n    a.  求解删除反应 $i$ 后的 FBA 问题。检查最优生物质通量是否  $\\tau$。\n    b.  如果是，则求解删除反应 $j$ 后的 FBA 问题。检查最优生物质通量是否  $\\tau$。\n    c.  如果两个单次删除都具有生存能力，则求解同时删除反应 $i$ 和 $j$ 后的 FBA 问题。检查最优生物质通量是否 $\\le \\tau$。\n4.  第一个满足所有三个条件的对 $(i,j)$ 就是字典序最小的综合致死对。我们记录下这个对，并继续处理下一个测试用例。\n5.  如果搜索完成而没有找到任何这样的对，则该网络中不存在综合致死对，我们记录一个空列表。\n\nLP 问题将使用 `scipy.optimize.linprog` 来解决。由于此函数执行最小化，最大化 $c^\\top v$ 的目标被转换为最小化 $-c^\\top v$。\n\n**4. 测试用例分析**\n\n*   **情况 1**：该网络有两个平行反应（$R_1, R_2$），它们从底物 $A$ 生产必需的生物质前体 $X$。\n    - $R_0: \\rightarrow A$\n    - $R_1: A \\rightarrow X$\n    - $R_2: A \\rightarrow X$\n    - $R_3: X \\rightarrow \\text{Biomass}$\n    反应 $R_1$ 和 $R_2$ 是冗余的。单独删除任何一个都允许另一个维持到 $X$ 的通量，因此生物质生产是可行的。同时删除 $R_1$ 和 $R_2$ 会切断从 $A$ 到 $X$ 的连接，使得生物质生产不可能。可删除集合是 $D=\\{1, 2\\}$，所以唯一可能的对是 $(1, 2)$，这是一个综合致死对。\n\n*   **情况 2**：该网络有两条从 $A$ 生产前体 $X$ 的替代通路：一条直接捷径（$R_3$）和一条两步通路（$R_1, R_2$）。\n    - $R_0: \\rightarrow A$\n    - 通路 1: $R_1: A \\rightarrow Y$, 然后 $R_2: Y \\rightarrow X$\n    - 通路 2: $R_3: A \\rightarrow X$ (捷径)\n    - $R_4: X \\rightarrow \\text{Biomass}$\n    可删除的反应是 $D=\\{1, 2, 3\\}$。我们寻找字典序最小的综合致死对。这些对是 $(1,2)$、$(1,3)$、$(2,3)$。\n    - 删除对 $(1,2)$ 不是致死的，因为捷径 $R_3$ 仍然存在。\n    - 删除对 $(1,3)$ 是致死的。它破坏了捷径（$R_3$）和替代通路（$R_1$）的入口点。单独删除 $R_1$ 或 $R_3$ 不是致死的。因此，$(1,3)$ 是一个综合致死对。\n    - 由于我们按字典序搜索，$(1,3)$ 是第一个被找到的，因此是答案。\n\n*   **情况 3**：该网络是一个简单的线性通路。\n    - $R_0: \\rightarrow A$\n    - $R_1: A \\rightarrow X$\n    - $R_2: X \\rightarrow \\text{Biomass}$\n    反应 $R_1$ 对于生物质生产是必需的。仅删除它本身就将是致死的。根据综合致死的定义（其中单个删除必须是可行的），如果一个反应本身是必需的，它就不能成为综合致死对的一部分。此外，可删除集合 $D=\\{1\\}$ 只包含一个反应，无法形成由不同反应组成的对。因此，不存在综合致死对。\n\n这个详细的分析证实了理论预期，并为实现提供了信息。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves for the lexicographically smallest synthetic lethal pair in a set of metabolic networks.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"S\": np.array([\n                [1, -1, -1, 0],\n                [0, 1, 1, -1]\n            ]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000]),\n            \"b\": 3,\n            \"D\": [1, 2]\n        },\n        {\n            \"S\": np.array([\n                [1, -1, 0, -1, 0],\n                [0, 1, -1, 0, 0],\n                [0, 0, 1, 1, -1]\n            ]),\n            \"l\": np.array([0, 0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000, 1000]),\n            \"b\": 4,\n            \"D\": [1, 2, 3]\n        },\n        {\n            \"S\": np.array([\n                [1, -1, 0],\n                [0, 1, -1]\n            ]),\n            \"l\": np.array([0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000]),\n            \"b\": 2,\n            \"D\": [1]\n        }\n    ]\n\n    tau = 1e-7\n    results = []\n\n    def run_fba(S, l, u, b):\n        \"\"\"\n        Performs Flux Balance Analysis to maximize biomass flux.\n        \n        Args:\n            S (np.ndarray): Stoichiometric matrix.\n            l (np.ndarray): Lower flux bounds.\n            u (np.ndarray): Upper flux bounds.\n            b (int): Index of the biomass reaction.\n\n        Returns:\n            float: The maximum biomass flux.\n        \"\"\"\n        num_reactions = S.shape[1]\n        c_obj = np.zeros(num_reactions)\n        c_obj[b] = -1  # To maximize v_b, we minimize -v_b\n\n        # Bounds must be a sequence of (min, max) tuples\n        bounds = list(zip(l, u))\n        \n        # A_eq @ x == b_eq\n        A_eq = S\n        b_eq = np.zeros(S.shape[0])\n\n        res = linprog(c=c_obj, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        if res.success:\n            return -res.fun\n        else:\n            return 0.0\n\n    for case in test_cases:\n        S, l_orig, u_orig, b, D = case[\"S\"], case[\"l\"], case[\"u\"], case[\"b\"], case[\"D\"]\n        sl_pair_found = None\n\n        # Sort D to ensure lexicographical order of pairs\n        D.sort()\n        \n        # Generate pairs (i, j) with i  j\n        candidate_pairs = list(itertools.combinations(D, 2))\n\n        for i, j in candidate_pairs:\n            # Condition 1: Check single deletion of i\n            l_del_i, u_del_i = l_orig.copy(), u_orig.copy()\n            l_del_i[i], u_del_i[i] = 0, 0\n            biomass_i = run_fba(S, l_del_i, u_del_i, b)\n            \n            if biomass_i  tau:\n                # Condition 2: Check single deletion of j\n                l_del_j, u_del_j = l_orig.copy(), u_orig.copy()\n                l_del_j[j], u_del_j[j] = 0, 0\n                biomass_j = run_fba(S, l_del_j, u_del_j, b)\n                \n                if biomass_j  tau:\n                    # Condition 3: Check double deletion of i and j\n                    l_del_ij, u_del_ij = l_orig.copy(), u_orig.copy()\n                    l_del_ij[i], u_del_ij[i] = 0, 0\n                    l_del_ij[j], u_del_ij[j] = 0, 0\n                    biomass_ij = run_fba(S, l_del_ij, u_del_ij, b)\n\n                    if biomass_ij = tau:\n                        sl_pair_found = [i, j]\n                        break  # Found the lexicographically smallest pair\n\n        if sl_pair_found:\n            results.append(sl_pair_found)\n        else:\n            results.append([])\n    \n    # Format the final output string exactly as specified\n    final_str_parts = []\n    for res in results:\n        if res:\n            final_str_parts.append(f\"[{res[0]},{res[1]}]\")\n        else:\n            final_str_parts.append(\"[]\")\n    final_output = f\"[{','.join(final_str_parts)}]\"\n\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}