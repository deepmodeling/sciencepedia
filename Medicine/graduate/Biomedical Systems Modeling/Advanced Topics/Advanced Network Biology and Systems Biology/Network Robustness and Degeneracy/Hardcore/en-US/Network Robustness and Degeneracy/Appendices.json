{
    "hands_on_practices": [
        {
            "introduction": "This first practice establishes a fundamental method for quantifying a system's robustness to continuous parameter noise. By applying a first-order Taylor linearization around a nominal operating point, we can analytically determine how small, random fluctuations in system parameters propagate to the output. This exercise will have you derive and apply the core formula of linear uncertainty propagation, using the Jacobian matrix to connect input parameter covariance $\\Sigma_{p}$ to output variance $\\Sigma_{y}$, a cornerstone of sensitivity analysis in both engineering and biology. ",
            "id": "3909340",
            "problem": "Consider a differentiable mapping from a parameter vector $p \\in \\mathbb{R}^{3}$ to an output vector $y \\in \\mathbb{R}^{2}$, denoted $y = f(p)$, representing the normalized steady-state outputs of a two-readout biomedical signaling module. Let $p^{\\star}$ be a nominal parameter operating point obtained from calibration experiments, and let small parameter fluctuations be modeled as a zero-mean Multivariate Normal distribution (MVN) $p = p^{\\star} + \\delta p$ with covariance matrix $\\Sigma_{p} \\in \\mathbb{R}^{3 \\times 3}$. Assume that the mapping $f$ is sufficiently smooth for a first-order Taylor linearization to be valid in a neighborhood of $p^{\\star}$, and denote the Jacobian at $p^{\\star}$ by $J = \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}} \\in \\mathbb{R}^{2 \\times 3}$.\n\nStarting from first principles (Taylor linearization and the definition of covariance), derive an expression for the output covariance matrix $\\Sigma_{y}$ in terms of $J$ and $\\Sigma_{p}$. Then, for the specific case\n$$\nJ = \\begin{pmatrix}\n0.5 & -0.3 & 0.0 \\\\\n0.1 & 0.2 & 0.4\n\\end{pmatrix},\n\\qquad\n\\Sigma_{p} = \\begin{pmatrix}\n0.04 & 0.012 & 0.0 \\\\\n0.012 & 0.09 & -0.006 \\\\\n0.0 & -0.006 & 0.01\n\\end{pmatrix},\n$$\ncompute the output covariance matrix $\\Sigma_{y}$ and use it to quantify robustness to parameter noise via the scalar metric $R = \\operatorname{tr}(\\Sigma_{y})$, the expected squared magnitude of output deviations under the linearized model.\n\nReport the numerical value of $R$ rounded to four significant figures. Because the outputs are normalized, treat $R$ as dimensionless and do not attach units. Your final answer must be a single real number.",
            "solution": "The problem statement is evaluated and found to be valid. It is scientifically grounded in the principles of sensitivity analysis and error propagation for nonlinear systems. The problem is well-posed, providing all necessary data and definitions for a unique solution. The given numerical values are consistent and plausible, as the provided covariance matrix $\\Sigma_p$ is symmetric and positive definite. The problem is objective and free of ambiguity.\n\nThe solution proceeds in two parts. First, we derive the general expression for the output covariance matrix $\\Sigma_y$ under a linear approximation. Second, we apply this formula to the specific matrices provided to compute the robustness metric $R$.\n\n### Part 1: Derivation of the Output Covariance Matrix\n\nWe are given a differentiable mapping $y = f(p)$, where $p \\in \\mathbb{R}^{3}$ is a parameter vector and $y \\in \\mathbb{R}^{2}$ is an output vector. The parameters fluctuate around a nominal operating point $p^{\\star}$ according to $p = p^{\\star} + \\delta p$. The fluctuations $\\delta p$ are modeled as a zero-mean Multivariate Normal distribution with covariance matrix $\\Sigma_{p}$. Thus, we have the statistical properties:\n$$E[\\delta p] = 0$$\n$$\\text{Cov}(\\delta p) = E[(\\delta p - E[\\delta p])(\\delta p - E[\\delta p])^{T}] = E[\\delta p (\\delta p)^{T}] = \\Sigma_{p}$$\n\nThe output $y$ will fluctuate around its nominal value $y^{\\star} = f(p^{\\star})$. We can approximate the output fluctuations $\\delta y = y - y^{\\star}$ using a first-order Taylor series expansion of $f(p)$ around $p^{\\star}$:\n$$y = f(p) = f(p^{\\star} + \\delta p) \\approx f(p^{\\star}) + \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}} \\delta p$$\nLet $J = \\left.\\frac{\\partial f}{\\partial p}\\right|_{p^{\\star}}$ be the Jacobian matrix of the mapping evaluated at the nominal point. The approximation becomes:\n$$y \\approx y^{\\star} + J \\delta p$$\nThis implies that the output deviation from the nominal value is approximately linear in the parameter deviation:\n$$\\delta y = y - y^{\\star} \\approx J \\delta p$$\nWe now derive the covariance matrix of the output vector $y$, denoted $\\Sigma_{y} = \\text{Cov}(y)$. The expected value of $y$ is:\n$$E[y] \\approx E[y^{\\star} + J \\delta p] = y^{\\star} + J E[\\delta p] = y^{\\star} + J \\cdot 0 = y^{\\star}$$\nUsing this, the covariance matrix $\\Sigma_{y}$ can be calculated as:\n$$\\Sigma_{y} = E[(y - E[y])(y - E[y])^{T}]$$\nSubstituting the approximations for $E[y]$ and the deviation $y - E[y] \\approx J \\delta p$:\n$$\\Sigma_{y} \\approx E[(J \\delta p)(J \\delta p)^{T}]$$\nUsing the transpose property $(AB)^{T} = B^{T}A^{T}$, we have:\n$$\\Sigma_{y} \\approx E[J (\\delta p) (\\delta p)^{T} J^{T}]$$\nSince the Jacobian matrix $J$ is a constant matrix (evaluated at the fixed point $p^{\\star}$), it can be factored out of the expectation:\n$$\\Sigma_{y} \\approx J E[\\delta p (\\delta p)^{T}] J^{T}$$\nWe recognize the term inside the expectation as the covariance matrix of the parameters, $\\Sigma_{p} = E[\\delta p (\\delta p)^{T}]$.\nTherefore, the expression for the output covariance matrix under this linear approximation is:\n$$\\Sigma_{y} = J \\Sigma_{p} J^{T}$$\n\n### Part 2: Calculation of the Robustness Metric $R$\n\nWe are given the specific matrices for the Jacobian and the parameter covariance:\n$$J = \\begin{pmatrix} 0.5 & -0.3 & 0.0 \\\\ 0.1 & 0.2 & 0.4 \\end{pmatrix}, \\qquad \\Sigma_{p} = \\begin{pmatrix} 0.04 & 0.012 & 0.0 \\\\ 0.012 & 0.09 & -0.006 \\\\ 0.0 & -0.006 & 0.01 \\end{pmatrix}$$\nThe transpose of the Jacobian matrix $J$ is:\n$$J^{T} = \\begin{pmatrix} 0.5 & 0.1 \\\\ -0.3 & 0.2 \\\\ 0.0 & 0.4 \\end{pmatrix}$$\nFirst, we compute the matrix product $J \\Sigma_{p}$:\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.5 & -0.3 & 0.0 \\\\ 0.1 & 0.2 & 0.4 \\end{pmatrix} \\begin{pmatrix} 0.04 & 0.012 & 0.0 \\\\ 0.012 & 0.09 & -0.006 \\\\ 0.0 & -0.006 & 0.01 \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} (0.5)(0.04) + (-0.3)(0.012) + (0.0)(0.0) & (0.5)(0.012) + (-0.3)(0.09) + (0.0)(-0.006) & (0.5)(0.0) + (-0.3)(-0.006) + (0.0)(0.01) \\\\ (0.1)(0.04) + (0.2)(0.012) + (0.4)(0.0) & (0.1)(0.012) + (0.2)(0.09) + (0.4)(-0.006) & (0.1)(0.0) + (0.2)(-0.006) + (0.4)(0.01) \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.02 - 0.0036 & 0.006 - 0.027 & 0.0018 \\\\ 0.004 + 0.0024 & 0.0012 + 0.018 - 0.0024 & -0.0012 + 0.004 \\end{pmatrix}$$\n$$J \\Sigma_{p} = \\begin{pmatrix} 0.0164 & -0.021 & 0.0018 \\\\ 0.0064 & 0.0168 & 0.0028 \\end{pmatrix}$$\nNext, we compute $\\Sigma_{y} = (J \\Sigma_{p}) J^{T}$:\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0164 & -0.021 & 0.0018 \\\\ 0.0064 & 0.0168 & 0.0028 \\end{pmatrix} \\begin{pmatrix} 0.5 & 0.1 \\\\ -0.3 & 0.2 \\\\ 0.0 & 0.4 \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} (0.0164)(0.5) + (-0.021)(-0.3) + (0.0018)(0.0) & (0.0164)(0.1) + (-0.021)(0.2) + (0.0018)(0.4) \\\\ (0.0064)(0.5) + (0.0168)(-0.3) + (0.0028)(0.0) & (0.0064)(0.1) + (0.0168)(0.2) + (0.0028)(0.4) \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0082 + 0.0063 & 0.00164 - 0.0042 + 0.00072 \\\\ 0.0032 - 0.00504 & 0.00064 + 0.00336 + 0.00112 \\end{pmatrix}$$\n$$\\Sigma_{y} = \\begin{pmatrix} 0.0145 & -0.00184 \\\\ -0.00184 & 0.00512 \\end{pmatrix}$$\nThe robustness metric $R$ is defined as the trace of the output covariance matrix, $R = \\operatorname{tr}(\\Sigma_{y})$. The trace is the sum of the diagonal elements.\n$$R = 0.0145 + 0.00512 = 0.01962$$\nThe problem requires the answer to be rounded to four significant figures. The number $0.01962$ has four significant figures ($1$, $9$, $6$, $2$). The next digit is an implicit zero. Thus, no rounding is necessary.\nThe value of the robustness metric is $0.01962$. This metric represents the expected squared magnitude of output deviations, $E[||\\delta y||^2]$, and serves as a measure of total output variance. A smaller value of $R$ implies greater robustness to parameter noise.",
            "answer": "$$\\boxed{0.01962}$$"
        },
        {
            "introduction": "Moving beyond small parameter fluctuations, this exercise explores robustness to large-scale structural perturbations, such as the complete loss of a reaction due to a gene knockout. You will use Flux Balance Analysis (FBA), a key computational technique in systems biology, to assess the functional consequences of such changes. This practice operationalizes robustness as the ability of a metabolic network to maintain a critical biological objective, like biomass production, by leveraging its inherent pathway redundancy. ",
            "id": "3909395",
            "problem": "Consider a steady-state metabolic network represented by a stoichiometric matrix $S \\in \\mathbb{R}^{m \\times n}$ with flux vector $v \\in \\mathbb{R}^{n}$, subject to mass balance constraints $S v = 0$ and bound constraints $l \\le v \\le u$, where $l, u \\in \\mathbb{R}^{n}$ are lower and upper bounds for each reaction. Flux Balance Analysis (FBA) is formulated as the linear optimization problem of maximizing a biomass production objective $c^{\\top} v$ subject to $S v = 0$ and $l \\le v \\le u$, where $c \\in \\mathbb{R}^{n}$ selects the biomass-producing reaction(s). Define the robustness to single-reaction knockouts with respect to a minimum biomass flux threshold $f_{\\min} \\in \\mathbb{R}_{\\ge 0}$ as the fraction of reactions in a designated knockout set $\\mathcal{K} \\subseteq \\{0,1,\\dots,n-1\\}$ for which there exists a feasible flux $v$ under the knockout (implemented by fixing the corresponding flux $v_i$ to $0$) that achieves $c^{\\top} v \\ge f_{\\min}$. Formally, for a given test case,\n$$\nR \\equiv \\frac{1}{|\\mathcal{K}|} \\sum_{i \\in \\mathcal{K}} \\mathbf{1}\\left(\\exists v \\text{ such that } S v = 0,\\; l \\le v \\le u,\\; v_i = 0,\\; c^{\\top} v \\ge f_{\\min}\\right),\n$$\nwhere $\\mathbf{1}(\\cdot)$ is $1$ if the condition is true and $0$ otherwise, and $|\\mathcal{K}|$ is the cardinality of $\\mathcal{K}$. All fluxes and thresholds are in arbitrary consistent flux units, so no physical unit conversion is required.\n\nYour task is to write a complete program that computes $R$ for each of the following four toy network test cases. In each case, the program must solve an FBA problem that maximizes $c^{\\top} v$ under the specified constraints for each single-reaction knockout $i \\in \\mathcal{K}$, and then check if the optimal value is at least $f_{\\min}$. Use a numerical tolerance of $10^{-9}$ when comparing $c^{\\top} v$ to $f_{\\min}$ to account for solver precision. The final result for each test case must be returned as a floating-point number in $[0,1]$, equal to the fraction of successful knockouts.\n\nTest Case 1 (Parallel redundant pathways with ample capacities):\n- Internal metabolites are two species, yielding $m = 2$, and there are $n = 4$ reactions with indices $0,1,2,3$. The stoichiometric matrix is\n$$\nS = \\begin{bmatrix}\n1 & -1 & -1 & 0 \\\\\n0 & 0 & 1 & -1\n\\end{bmatrix},\n$$\nwhere columns correspond to reactions $0,1,2,3$ respectively. The bounds are\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\nThe objective vector is\n$$\nc = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\nso that the biomass objective equals $v_1 + v_3$. The knockout set is\n$$\n\\mathcal{K} = \\{0,1,2,3\\}.\n$$\nThe minimum biomass threshold is\n$$\nf_{\\min} = 5.\n$$\n\nTest Case 2 (Single linear pathway with no redundancy):\n- Internal metabolites are two species, yielding $m = 2$, and there are $n = 3$ reactions with indices $0,1,2$. The stoichiometric matrix is\n$$\nS = \\begin{bmatrix}\n1 & -1 & 0 \\\\\n0 & 1 & -1\n\\end{bmatrix},\n$$\nwith reactions $0,1,2$ respectively. The bounds are\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 1000 \\\\ 1000 \\end{bmatrix}.\n$$\nThe objective vector is\n$$\nc = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\nso that the biomass objective equals $v_2$. The knockout set is\n$$\n\\mathcal{K} = \\{0,1,2\\}.\n$$\nThe minimum biomass threshold is\n$$\nf_{\\min} = 5.\n$$\n\nTest Case 3 (Parallel redundant pathways with threshold equal to the undeleted optimum):\n- Identical to Test Case $1$ in $S$, $l$, $u$, $c$, and $\\mathcal{K}$. The only difference is the minimum biomass threshold\n$$\nf_{\\min} = 10.\n$$\n\nTest Case 4 (Parallel pathways with capacity limits on each branch):\n- Internal metabolites are two species, yielding $m = 2$, and there are $n = 4$ reactions with indices $0,1,2,3$. The stoichiometric matrix is\n$$\nS = \\begin{bmatrix}\n1 & -1 & -1 & 0 \\\\\n0 & 0 & 1 & -1\n\\end{bmatrix}.\n$$\nThe bounds are\n$$\nl = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix},\\quad\nu = \\begin{bmatrix} 10 \\\\ 8 \\\\ 1000 \\\\ 6 \\end{bmatrix},\n$$\nso reaction $1$ has an upper bound of $8$ and reaction $3$ has an upper bound of $6$. The objective vector is\n$$\nc = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 1 \\end{bmatrix},\n$$\nand the knockout set is\n$$\n\\mathcal{K} = \\{0,1,2,3\\}.\n$$\nThe minimum biomass threshold is\n$$\nf_{\\min} = 9.\n$$\n\nImplement the program to solve each test case exactly as specified. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the above test cases, for example $[r_1,r_2,r_3,r_4]$, where each $r_i$ is the computed robustness value for Test Case $i$ expressed as a decimal in $[0,1]$.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the established principles of Flux Balance Analysis (FBA), a standard method in systems biology for analyzing metabolic networks. The problem is well-posed, providing all necessary mathematical definitions, constraints, and data for four distinct and solvable test cases. The language is objective and precise, and the task is computationally feasible.\n\nThe core of the problem is to compute the robustness, $R$, of a metabolic network to a series of single-reaction knockouts. This metric is defined as the fraction of knockouts in a set $\\mathcal{K}$ that still permit the network to produce a biomass flux greater than or equal to a minimum threshold, $f_{\\min}$. The existence of such a flux distribution is determined by solving an FBA problem for each knockout.\n\nThe fundamental principle is that under the steady-state assumption, the fluxes $v \\in \\mathbb{R}^n$ through the $n$ reactions of a metabolic network with $m$ internal metabolites must satisfy the mass balance equation $S v = 0$, where $S \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix. Additionally, fluxes are constrained by lower and upper bounds, $l \\le v \\le u$. FBA uses linear programming (LP) to find a flux vector $v$ that satisfies these constraints while maximizing a cellular objective function, typically biomass production, represented as $c^{\\top} v$.\n\nThe analytical procedure for each test case is as follows:\n1.  Initialize a counter for successful knockouts, $N_{success}$, to $0$.\n2.  For each reaction index $i$ in the specified knockout set $\\mathcal{K}$:\n    a. Formulate an LP problem to find the maximum possible biomass flux under the knockout condition. A knockout of reaction $i$ is implemented by constraining its flux to zero, i.e., $v_i = 0$.\n    b. The LP problem is thus:\n    $$\n    \\begin{array}{ll}\n    \\underset{v}{\\text{maximize}} & z = c^{\\top} v \\\\\n    \\text{subject to} & S v = 0 \\\\\n    & l_j \\le v_j \\le u_j \\quad \\forall j \\neq i \\\\\n    & v_i = 0\n    \\end{array}\n    $$\n    c. This maximization problem is solved using a standard LP solver. Computationally, this is often posed as a minimization problem. Maximizing $c^{\\top}v$ is equivalent to minimizing $(-c)^{\\top}v$. The constraints are passed to the solver: $S$ as the equality constraint matrix `A_eq`, a zero vector as the equality constraint vector `b_eq`, and the flux bounds $l \\le v \\le u$ as the `bounds` parameter. The knockout constraint $v_i=0$ is efficiently handled by setting the specific bounds for $v_i$ to $(0, 0)$.\n    d. Let the optimal objective value returned by the solver for the minimization be $z^*_{\\min}$. The maximum biomass production is then $z^*_{\\max} = -z^*_{\\min}$.\n    e. This maximum biomass value is compared against the threshold $f_{\\min}$. To account for potential floating-point inaccuracies from the numerical solver, a tolerance $\\epsilon = 10^{-9}$ is used. If the solver finds a feasible solution and $z^*_{\\max} \\ge f_{\\min} - \\epsilon$, the knockout is considered survivable, and the counter $N_{success}$ is incremented.\n3.  After iterating through all knockouts in $\\mathcal{K}$, the robustness $R$ is calculated as the ratio of successful knockouts to the total number of knockouts performed:\n    $$\n    R = \\frac{N_{success}}{|\\mathcal{K}|}\n    $$\nThis procedure is applied to each of the four test cases using their respective parameters ($S$, $l$, $u$, $c$, $\\mathcal{K}$, and $f_{\\min}$) to generate the final results.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, compute robustness for each,\n    and print the results in the specified format.\n    \"\"\"\n    # Numerical tolerance for comparing biomass flux to the threshold.\n    TOLERANCE = 1e-9\n\n    # Definition of the four test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test Case 1\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 5.0,\n        },\n        {\n            \"name\": \"Test Case 2\",\n            \"S\": np.array([[1, -1, 0], [0, 1, -1]]),\n            \"l\": np.array([0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000]),\n            \"c\": np.array([0, 0, 1]),\n            \"K\": {0, 1, 2},\n            \"f_min\": 5.0,\n        },\n        {\n            \"name\": \"Test Case 3\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 1000, 1000, 1000]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 10.0,\n        },\n        {\n            \"name\": \"Test Case 4\",\n            \"S\": np.array([[1, -1, -1, 0], [0, 0, 1, -1]]),\n            \"l\": np.array([0, 0, 0, 0]),\n            \"u\": np.array([10, 8, 1000, 6]),\n            \"c\": np.array([0, 1, 0, 1]),\n            \"K\": {0, 1, 2, 3},\n            \"f_min\": 9.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        robustness = compute_robustness(\n            S=case[\"S\"],\n            l=case[\"l\"],\n            u=case[\"u\"],\n            c=case[\"c\"],\n            K=case[\"K\"],\n            f_min=case[\"f_min\"],\n            tol=TOLERANCE\n        )\n        results.append(robustness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_robustness(S, l, u, c, K, f_min, tol):\n    \"\"\"\n    Computes the robustness for a single metabolic network configuration.\n\n    Args:\n        S (np.ndarray): Stoichiometric matrix (m x n).\n        l (np.ndarray): Lower bounds for fluxes (n,).\n        u (np.ndarray): Upper bounds for fluxes (n,).\n        c (np.ndarray): Objective vector (n,).\n        K (set): Set of reaction indices to knock out.\n        f_min (float): Minimum biomass flux threshold.\n        tol (float): Numerical tolerance for comparison.\n\n    Returns:\n        float: The computed robustness value R.\n    \"\"\"\n    successful_knockouts = 0\n    num_reactions = S.shape[1]\n    \n    # Objective for minimization: -c to maximize c'v\n    c_solver = -c\n    \n    # Equality constraints: Sv = 0\n    A_eq = S\n    b_eq = np.zeros(S.shape[0])\n\n    for i in K:\n        # Create the bounds for the fluxes for this knockout simulation.\n        # It's a list of (min, max) tuples.\n        bounds = list(zip(l, u))\n        \n        # Apply the knockout by setting the flux bounds to (0, 0)\n        if 0 <= i < num_reactions:\n            bounds[i] = (0, 0)\n        else:\n            # This case should not happen with valid input but is good practice.\n            continue\n            \n        # Solve the linear programming problem\n        res = linprog(c=c_solver, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')\n\n        # Check if a feasible solution was found that meets the threshold\n        if res.success:\n            # The result from linprog is the minimum. We need the maximum.\n            max_biomass = -res.fun\n            if max_biomass >= f_min - tol:\n                successful_knockouts += 1\n\n    # Calculate robustness R\n    if not K:\n        return 0.0\n    \n    return successful_knockouts / len(K)\n\nsolve()\n```"
        },
        {
            "introduction": "Robustness is often enabled by degeneracy, the principle that structurally distinct system components or pathways can yield equivalent function. This final practice delves into degeneracy directly by exploring the concept of alternative optima in Flux Balance Analysis. You will implement lexicographic optimization, a powerful algorithm to systematically enumerate these distinct solutions, thereby uncovering the different metabolic routing strategies that can all achieve the same maximal biological objective. ",
            "id": "3909353",
            "problem": "Consider a Flux Balance Analysis (FBA) formulation of a metabolic network at steady state, where the flux vector is denoted by $\\mathbf{v} \\in \\mathbb{R}^n$, and the stoichiometric matrix is denoted by $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$. Steady state imposes the constraint $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$. Bounds on fluxes are given by lower bounds $\\mathbf{l} \\in \\mathbb{R}^n$ and upper bounds $\\mathbf{u} \\in \\mathbb{R}^n$, forming box constraints $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$ component-wise. The biological objective is encoded by a coefficient vector $\\mathbf{c} \\in \\mathbb{R}^n$, and the standard FBA objective is to maximize $\\mathbf{c}^\\top \\mathbf{v}$ subject to the constraints. Alternative optima indicate degeneracy in metabolic function when multiple distinct flux distributions achieve the same maximal biomass objective value. To interrogate degeneracy structurally, lexicographic optimization can be used: after first maximizing $\\mathbf{c}^\\top \\mathbf{v}$ to obtain the maximum value $z^\\star$, one imposes the equality constraint $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$ and then minimizes components of $\\mathbf{v}$ sequentially according to a priority order. This procedure selects distinct route sets when alternative optima exist.\n\nImplement a program that, for each test network below, performs the following steps:\n- Solve the primal linear program to maximize $\\mathbf{c}^\\top \\mathbf{v}$ subject to $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ and $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$, obtaining the optimal value $z^\\star$ and one optimal flux vector $\\mathbf{v}^\\star$.\n- For each provided lexicographic priority sequence (each sequence is an ordered list of reaction indices), perform sequential minimizations as follows: starting with the feasible set defined by $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$, $\\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}$, and $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$, minimize $v_{i_1}$; then impose the equality $v_{i_1} = v_{i_1}^{\\min}$ and minimize $v_{i_2}$; proceed until all indices in the sequence have been minimized in order, each time adding equality constraints that fix previously minimized components to their attained minima. Let the final flux vector be denoted $\\mathbf{v}^{\\mathrm{lex}}$ for that sequence.\n- Define the route set for a given sequence as the set of indices in a designated route index list whose flux in $\\mathbf{v}^{\\mathrm{lex}}$ exceeds a threshold $\\epsilon$, where $\\epsilon$ must be set to $\\epsilon = 10^{-9}$.\n- For each test network, collect the route sets obtained across all provided priority sequences, remove duplicates, and report the count of distinct route sets. Use zero-based reaction indexing throughout (that is, the first reaction has index $0$, the second has index $1$, and so on).\n\nYou must implement the above using linear programming in a purely mathematical manner. All computations are dimensionless; no physical units are required. Angles are not involved. No percentages are required.\n\nTest Suite:\n- Test Case $1$ (two parallel conversions):\n  - Reactions: $v_0$ (uptake), $v_1$ and $v_2$ (two parallel conversions), $v_3$ (biomass drain).\n  - Metabolites: $m_1$, $m_2$.\n  - Stoichiometric matrix $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 4}$:\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1 & -1 & -1 & 0 \\\\\n    0 & 1 & 1 & -1\n    \\end{bmatrix}\n    $$\n  - Bounds: $\\mathbf{l} = [0, 0, 0, 0]$, $\\mathbf{u} = [6, 100, 100, 100]$.\n  - Objective coefficients: $\\mathbf{c} = [0, 0, 0, 1]$.\n  - Lexicographic priority sequences: $[1, 2]$ and $[2, 1]$.\n  - Route indices to consider in support sets: $[1, 2]$.\n- Test Case $2$ (three parallel conversions):\n  - Reactions: $v_0$ (uptake), $v_1$, $v_2$, $v_3$ (three parallel conversions), $v_4$ (biomass drain).\n  - Metabolites: $m_1$, $m_2$.\n  - Stoichiometric matrix $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 5}$:\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1 & -1 & -1 & -1 & 0 \\\\\n    0 & 1 & 1 & 1 & -1\n    \\end{bmatrix}\n    $$\n  - Bounds: $\\mathbf{l} = [0, 0, 0, 0, 0]$, $\\mathbf{u} = [9, 100, 100, 100, 100]$.\n  - Objective coefficients: $\\mathbf{c} = [0, 0, 0, 0, 1]$.\n  - Lexicographic priority sequences: $[1, 2, 3]$, $[2, 3, 1]$, $[3, 1, 2]$.\n  - Route indices to consider in support sets: $[1, 2, 3]$.\n- Test Case $3$ (capacity-limited branch):\n  - Reactions: $v_0$ (uptake), $v_1$ and $v_2$ (two parallel conversions with asymmetric capacities), $v_3$ (biomass drain).\n  - Metabolites: $m_1$, $m_2$.\n  - Stoichiometric matrix $\\mathbf{S} \\in \\mathbb{R}^{2 \\times 4}$:\n    $$\n    \\mathbf{S} = \\begin{bmatrix}\n    1 & -1 & -1 & 0 \\\\\n    0 & 1 & 1 & -1\n    \\end{bmatrix}\n    $$\n  - Bounds: $\\mathbf{l} = [0, 0, 0, 0]$, $\\mathbf{u} = [8, 5, 8, 100]$.\n  - Objective coefficients: $\\mathbf{c} = [0, 0, 0, 1]$.\n  - Lexicographic priority sequences: $[1, 2]$, $[2, 1]$.\n  - Route indices to consider in support sets: $[1, 2]$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the counts of distinct route sets for Test Case $1$, Test Case $2$, and Test Case $3$, as a comma-separated list enclosed in square brackets, for example, $[r_1,r_2,r_3]$, where each $r_i$ is an integer. The threshold must be set to $\\epsilon = 10^{-9}$ when determining whether a flux component is considered active in a route set.",
            "solution": "The problem is valid. It is scientifically grounded in the established principles of Flux Balance Analysis (FBA) and linear programming, commonly used in systems biology to study metabolic networks. The problem is well-posed, providing all necessary data and a clear, unambiguous algorithmic description that leads to a unique solution for each test case. All terms are formally defined, and the premises are factually sound within the context of metabolic modeling.\n\nThe problem requires the implementation of a lexicographic optimization procedure to explore the degenerate solution space of a metabolic network. Degeneracy, in this context, refers to the existence of multiple distinct flux distributions ($\\mathbf{v}$) that yield the same maximal biological objective value ($z^\\star$). Lexicographic optimization provides a systematic way to select a unique flux distribution from this space of alternative optima, based on a prioritized list of objectives. By varying the priority order, we can uncover different \"strategies\" or routes the network can use, which are revealed as distinct sets of active reactions.\n\nThe solution is implemented in four main steps for each test case:\n\n**1. Primal Linear Program (LP) for the Biological Objective**\n\nFirst, we solve the standard FBA problem, which is a linear program designed to find the maximum possible flux through a biological objective function, such as biomass production. This objective is represented by the vector $\\mathbf{c} \\in \\mathbb{R}^n$. The problem is formulated as:\n\n$$\n\\begin{align*}\n\\text{maximize} \\quad & z = \\mathbf{c}^\\top \\mathbf{v} \\\\\n\\text{subject to} \\quad & \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n& \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u}\n\\end{align*}\n$$\n\nHere, $\\mathbf{v} \\in \\mathbb{R}^n$ is the vector of reaction fluxes, $\\mathbf{S} \\in \\mathbb{R}^{m \\times n}$ is the stoichiometric matrix, $\\mathbf{l} \\in \\mathbb{R}^n$ and $\\mathbf{u} \\in \\mathbb{R}^n$ are the lower and upper bounds on the fluxes, respectively. The constraint $\\mathbf{S}\\mathbf{v} = \\mathbf{0}$ enforces the steady-state assumption, where the production and consumption of each internal metabolite are balanced.\n\nThis maximization problem is solved using a standard LP solver. We denote the optimal objective value as $z^\\star$.\n\n**2. Sequential Lexicographic Minimization**\n\nAfter determining $z^\\star$, we explore the space of flux vectors that achieve this maximum. This is done by adding a new constraint, $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$, to the original problem. This constraint restricts the feasible solutions to the face of the solution polytope corresponding to the maximal objective.\n\nFor each given lexicographic priority sequence of reaction indices, say $(i_1, i_2, \\dots, i_k)$, we perform a series of sequential LPs. The process is as follows:\n\nFor $j = 1, 2, \\dots, k$:\n- We solve an LP to minimize the flux $v_{i_j}$ of the $j$-th reaction in the priority sequence. The feasible set for this LP includes the original steady-state and bound constraints, the optimality constraint $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$, and additional constraints from previous steps in the sequence. Specifically, for all preceding indices $p < j$, we add equality constraints $v_{i_p} = v_{i_p}^{\\min}$, where $v_{i_p}^{\\min}$ is the minimum value found in step $p$.\n\nThe formulation for the $j$-th step is:\n\n$$\n\\begin{align*}\n\\text{minimize} \\quad & v_{i_j} \\\\\n\\text{subject to} \\quad & \\mathbf{S}\\mathbf{v} = \\mathbf{0} \\\\\n& \\mathbf{l} \\le \\mathbf{v} \\le \\mathbf{u} \\\\\n& \\mathbf{c}^\\top \\mathbf{v} = z^\\star \\\\\n& v_{i_p} = v_{i_p}^{\\min} \\quad \\text{for } p = 1, \\dots, j-1\n\\end{align*}\n$$\n\nLet the optimal value of this LP be $v_{i_j}^{\\min}$. This value is then used to fix the flux $v_{i_j}$ for all subsequent minimizations in the sequence. After iterating through all indices in the priority sequence, the resulting flux vector, $\\mathbf{v}^{\\mathrm{lex}}$, is uniquely determined.\n\n**3. Route Set Identification**\n\nFor each final vector $\\mathbf{v}^{\\mathrm{lex}}$ obtained from a priority sequence, we identify the corresponding \"route set\". The problem defines this as the set of active reactions from a specified list of `route_indices`. A reaction $j$ from this list is considered active if its flux $v_j^{\\mathrm{lex}}$ exceeds a small positive threshold, $\\epsilon$. The problem specifies $\\epsilon = 10^{-9}$.\n\nFormally, for a given $\\mathbf{v}^{\\mathrm{lex}}$ and a set of `route_indices` $I_{\\text{route}}$, the resulting route set $R$ is:\n$$\nR = \\{ j \\in I_{\\text{route}} \\mid v_j^{\\mathrm{lex}} > \\epsilon \\}\n$$\n\n**4. Counting Distinct Route Sets**\n\nThe entire procedure (Steps $2$ and $3$) is repeated for every priority sequence provided in the test case. The route sets generated from all sequences are collected. The final result for the test case is the total count of unique route sets found. This count quantifies the number of distinct metabolic operational modes that can be selected by varying the minimization priorities, providing insight into the structural degeneracy of the network.\n\nThe implementation uses the `scipy.optimize.linprog` function. The initial maximization is performed by minimizing $-\\mathbf{c}^\\top \\mathbf{v}$. For the lexicographic part, the optimality constraint $\\mathbf{c}^\\top \\mathbf{v} = z^\\star$ is added to the set of equality constraints. The sequential fixing of variables $v_{i_j} = v_{i_j}^{\\min}$ is implemented efficiently by progressively tightening the `bounds` parameter of the `linprog` function for each variable in the sequence.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Solves a series of FBA problems with lexicographic optimization\n    to count distinct metabolic route sets.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([6.0, 100.0, 100.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2], [2, 1]],\n            \"route_indices\": [1, 2],\n        },\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([9.0, 100.0, 100.0, 100.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2, 3], [2, 3, 1], [3, 1, 2]],\n            \"route_indices\": [1, 2, 3],\n        },\n        {\n            \"S\": np.array([[1.0, -1.0, -1.0, 0.0], [0.0, 1.0, 1.0, -1.0]]),\n            \"l\": np.array([0.0, 0.0, 0.0, 0.0]),\n            \"u\": np.array([8.0, 5.0, 8.0, 100.0]),\n            \"c\": np.array([0.0, 0.0, 0.0, 1.0]),\n            \"sequences\": [[1, 2], [2, 1]],\n            \"route_indices\": [1, 2],\n        },\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case in test_cases:\n        S, l, u, c = case[\"S\"], case[\"l\"], case[\"u\"], case[\"c\"]\n        sequences = case[\"sequences\"]\n        route_indices = case[\"route_indices\"]\n        num_vars = S.shape[1]\n\n        # Step 1: Solve the primal FBA problem to find the optimal objective value z_star.\n        # We maximize c'v by minimizing -c'v.\n        initial_bounds = list(zip(l, u))\n        res_primal = linprog(\n            -c,\n            A_eq=S,\n            b_eq=np.zeros(S.shape[0]),\n            bounds=initial_bounds,\n            method='highs',\n        )\n\n        if not res_primal.success:\n            # According to the problem specification, all test cases are well-posed.\n            # This block is for robustness but should not be reached.\n            raise RuntimeError(\"Primal FBA optimization failed.\")\n        \n        # The optimal objective value z_star is the negative of the minimized value.\n        z_star = -res_primal.fun\n\n        # Step 2: Perform lexicographic optimization for each priority sequence.\n        distinct_route_sets = set()\n\n        # Add the objective constraint c'v = z_star to the equality constraints.\n        A_lex = np.vstack([S, c])\n        b_lex = np.hstack([np.zeros(S.shape[0]), z_star])\n\n        for seq in sequences:\n            # For each sequence, start with the original bounds.\n            current_bounds = list(zip(l, u))\n            v_lex = None\n\n            # Sequentially minimize fluxes according to the priority sequence.\n            for reaction_idx in seq:\n                # Define objective: minimize v[reaction_idx]\n                c_lex = np.zeros(num_vars)\n                c_lex[reaction_idx] = 1\n\n                # Solve the LP with the current set of fixed fluxes.\n                res_lex = linprog(\n                    c_lex,\n                    A_eq=A_lex,\n                    b_eq=b_lex,\n                    bounds=current_bounds,\n                    method='highs',\n                )\n\n                if not res_lex.success:\n                    raise RuntimeError(f\"Lexicographic minimization failed for index {reaction_idx}.\")\n                \n                # Get the minimum value for the current reaction flux.\n                v_min = res_lex.fun\n                \n                # Update the bounds for this reaction to 'fix' it to its minimized value\n                # for all subsequent optimization steps in this sequence.\n                # A small tolerance is subtracted/added to handle potential solver precision issues,\n                # ensuring the new bound is strictly a point.\n                current_bounds[reaction_idx] = (v_min, v_min)\n                \n                # The solution vector from the last LP call in the sequence is the final one.\n                v_lex = res_lex.x\n\n            if v_lex is None:\n                # This would only occur if a sequence is empty.\n                continue\n\n            # Step 3: Determine the route set for the final flux vector v_lex.\n            # A route set consists of indices from route_indices whose flux > epsilon.\n            # A frozenset is used as it is hashable and can be added to a set.\n            current_route_set = frozenset(\n                idx for idx in route_indices if v_lex[idx] > epsilon\n            )\n            distinct_route_sets.add(current_route_set)\n        \n        # Step 4: The result for this test case is the count of distinct route sets found.\n        results.append(len(distinct_route_sets))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}