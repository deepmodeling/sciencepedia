{
    "hands_on_practices": [
        {
            "introduction": "作为最基础的种群增长模型之一，纯生过程（或称尤尔过程）为我们理解随机繁殖提供了理论基础。仅仅知道平均种群大小是不够的，我们需要了解种群规模在任意时刻的完整概率分布。本练习将引导你通过求解柯尔莫哥洛夫前向方程，从第一性原理出发推导出这个过程的瞬态概率分布 ，这是一项掌握连续时间马尔可夫链动态学核心分析技能的关键实践。",
            "id": "3920107",
            "problem": "生物反应器中一个增殖细胞的克隆群体被建模为一个连续时间马尔可夫链，其状态由时间 $t \\geq 0$ 时的细胞数量 $X(t) \\in \\{1,2,3,\\dots\\}$ 给出。每个细胞以恒定的单位细胞分裂率 $\\lambda > 0$ 独立分裂，且没有细胞死亡。因此，当群体处于状态 $n$ 时，总出生率为 $\\lambda n$，并且没有向更低状态的转移。假设初始条件为 $X(0)=1$。\n\n仅从生灭过程的 Kolmogorov 前向方程和连续时间马尔可夫链的基本定义出发，推导这个纯生过程的瞬态概率分布。具体来说，对于任意整数 $n \\geq 1$，确定概率 $P(X(t)=n \\mid X(0)=1)$ 作为 $\\lambda$ 和 $t$ 的函数的封闭形式表达式。\n\n您的最终答案必须是关于 $\\lambda$、$t$ 和 $n$ 的单个封闭形式解析表达式。不要提供不等式或需要求解的方程。无需四舍五入，也无需报告单位，因为答案是一个概率。",
            "solution": "该问题描述了一个从单个个体开始的纯生过程，也称为 Yule 过程。设 $P_n(t)$ 是在时间 $t=0$ 时群体大小为 1 的条件下，在时间 $t$ 时群体大小为 $n$ 的概率。即，$P_n(t) = P(X(t)=n \\mid X(0)=1)$。状态空间为 $\\{1, 2, 3, \\dots\\}$。单位细胞分裂率为 $\\lambda$，因此当群体大小为 $n$ 时，总出生率为 $\\lambda_n = n\\lambda$。对所有 $n$，死亡率 $\\mu_n = 0$。\n\n系统动力学由 Kolmogorov 前向方程控制。对于一般的生灭过程，在时间 $t$ 处于状态 $n$ 的概率方程为：\n$$\n\\frac{dP_n(t)}{dt} = \\lambda_{n-1} P_{n-1}(t) + \\mu_{n+1} P_{n+1}(t) - (\\lambda_n + \\mu_n) P_n(t)\n$$\n在我们的具体情况下，$\\lambda_n = n\\lambda$ 且 $\\mu_n = 0$。将这些率代入一般方程，我们得到适用于我们纯生过程的微分方程组。\n\n对于 $n \\ge 2$，进入状态 $n$ 的转移仅来自状态 $n-1$（一次出生），而离开状态 $n$ 的转移仅去往状态 $n+1$（另一次出生）。因此，方程为：\n$$\n\\frac{dP_n(t)}{dt} = \\lambda(n-1) P_{n-1}(t) - n\\lambda P_n(t)\n$$\n对于状态 $n=1$，没有比它更低的状态，所以不可能有转移进入状态 1。唯一可能的是从状态 1 转移到状态 2，其发生率为 $\\lambda_1 = 1 \\cdot \\lambda = \\lambda$。因此，$P_1(t)$ 的方程为：\n$$\n\\frac{dP_1(t)}{dt} = -\\lambda_1 P_1(t) = -\\lambda P_1(t)\n$$\n初始条件是 $X(0)=1$，这转化为以下初始概率：\n$P_1(0) = 1$\n$P_n(0) = 0$ for all $n \\ge 2$.\n\n我们可以递归地求解这个常微分方程组。\n\n首先，我们求解 $P_1(t)$：\n$$\n\\frac{dP_1(t)}{dt} = -\\lambda P_1(t)\n$$\n这是一个可分离的一阶线性常微分方程。解的形式为 $P_1(t) = C \\exp(-\\lambda t)$。使用初始条件 $P_1(0)=1$，我们求出常数 $C$：\n$1 = C \\exp(0) \\implies C=1$。\n因此，在时间 $t$ 恰好有一个细胞的概率是：\n$$\nP_1(t) = \\exp(-\\lambda t)\n$$\n接下来，我们使用 $n=2$ 的方程求解 $P_2(t)$：\n$$\n\\frac{dP_2(t)}{dt} = \\lambda(2-1) P_1(t) - 2\\lambda P_2(t) = \\lambda P_1(t) - 2\\lambda P_2(t)\n$$\n代入 $P_1(t)$ 的表达式：\n$$\n\\frac{dP_2(t)}{dt} + 2\\lambda P_2(t) = \\lambda \\exp(-\\lambda t)\n$$\n这是一个一阶线性非齐次常微分方程。我们使用积分因子 $I(t) = \\exp(\\int 2\\lambda dt) = \\exp(2\\lambda t)$ 来求解它。方程两边乘以 $I(t)$：\n$$\n\\exp(2\\lambda t) \\frac{dP_2(t)}{dt} + 2\\lambda \\exp(2\\lambda t) P_2(t) = \\lambda \\exp(2\\lambda t) \\exp(-\\lambda t)\n$$\n$$\n\\frac{d}{dt} \\left( P_2(t) \\exp(2\\lambda t) \\right) = \\lambda \\exp(\\lambda t)\n$$\n两边对 $t$ 积分：\n$$\nP_2(t) \\exp(2\\lambda t) = \\int \\lambda \\exp(\\lambda t) dt = \\exp(\\lambda t) + C\n$$\n$$\nP_2(t) = \\exp(-\\lambda t) + C \\exp(-2\\lambda t)\n$$\n使用初始条件 $P_2(0)=0$：\n$0 = \\exp(0) + C \\exp(0) \\implies 0 = 1 + C \\implies C = -1$。\n所以，$P_2(t)$ 的解是：\n$$\nP_2(t) = \\exp(-\\lambda t) - \\exp(-2\\lambda t) = \\exp(-\\lambda t)(1 - \\exp(-\\lambda t))\n$$\n我们观察到一个模式正在出现：\n$P_1(t) = \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{1-1}$\n$P_2(t) = \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{2-1}$\n我们假设对于 $n \\ge 1$ 的通解是：\n$$\nP_n(t) = \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{n-1}\n$$\n我们用数学归纳法证明这个假设。\n$n=1$ 的基础情况已验证。\n假设该公式对某个整数 $k \\ge 1$ 成立：$P_k(t) = \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{k-1}$。\n我们必须使用微分方程证明它对 $k+1$ 也成立：\n$$\n\\frac{dP_{k+1}(t)}{dt} + (k+1)\\lambda P_{k+1}(t) = k\\lambda P_k(t)\n$$\n代入 $P_{k+1}(t)$ 的假设形式：\n$P_{k+1}(t) = \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^k$。\n关于 $t$ 的导数是：\n$$\n\\frac{dP_{k+1}(t)}{dt} = -\\lambda \\exp(-\\lambda t) (1-\\exp(-\\lambda t))^k + \\exp(-\\lambda t) \\cdot k(1-\\exp(-\\lambda t))^{k-1} \\cdot (\\lambda \\exp(-\\lambda t))\n$$\n$$\n\\frac{dP_{k+1}(t)}{dt} = -\\lambda \\exp(-\\lambda t) (1-\\exp(-\\lambda t))^k + k\\lambda \\exp(-2\\lambda t) (1-\\exp(-\\lambda t))^{k-1}\n$$\n现在将此代入 $P_{k+1}(t)$ 微分方程的左侧 (LHS)：\n$$\nLHS = \\left( -\\lambda \\exp(-\\lambda t) (1-\\exp(-\\lambda t))^k + k\\lambda \\exp(-2\\lambda t) (1-\\exp(-\\lambda t))^{k-1} \\right) + (k+1)\\lambda \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^k\n$$\n合并第一项和第三项：\n$$\nLHS = ( (k+1)\\lambda - \\lambda ) \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^k + k\\lambda \\exp(-2\\lambda t) (1-\\exp(-\\lambda t))^{k-1}\n$$\n$$\nLHS = k\\lambda \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^k + k\\lambda \\exp(-2\\lambda t) (1-\\exp(-\\lambda t))^{k-1}\n$$\n提出公因式 $k\\lambda \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^{k-1}$：\n$$\nLHS = k\\lambda \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^{k-1} \\left[ (1-\\exp(-\\lambda t)) + \\exp(-\\lambda t) \\right]\n$$\n$$\nLHS = k\\lambda \\exp(-\\lambda t)(1-\\exp(-\\lambda t))^{k-1} [1]\n$$\n微分方程的右侧 (RHS) 是 $k\\lambda P_k(t)$。使用我们对 $P_k(t)$ 的归纳假设：\n$$\nRHS = k\\lambda \\left( \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{k-1} \\right)\n$$\n我们看到 LHS = RHS，所以我们假设的解满足该微分方程。我们还必须检查初始条件：\n$$\nP_{k+1}(0) = \\exp(0) (1 - \\exp(0))^{k} = 1 \\cdot (1-1)^k = 0\n$$\n这对任何 $k \\ge 1$（即对任何 $n \\ge 2$）都成立。归纳完成。\n推导出的瞬态概率分布是一个成功概率为 $p=\\exp(-\\lambda t)$ 的几何分布。在时间 $t$ 有 $n$ 个细胞的概率是：\n$P(X(t)=n \\mid X(0)=1) = \\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{n-1}$，对于 $n=1, 2, 3, \\ldots$。",
            "answer": "$$\\boxed{\\exp(-\\lambda t) (1 - \\exp(-\\lambda t))^{n-1}}$$"
        },
        {
            "introduction": "理论模型只有在能够与实验数据相结合时才显示出其全部力量。当我们观察一个生物种群（例如培养皿中的细胞）的增殖和消亡时，我们如何从这些观察中估计出内在的出生率 $\\lambda$ 和死亡率 $\\mu$？本练习将向你展示如何对一个完整观测的生灭过程轨迹应用最大似然估计法 。通过此实践，你将学会识别充分统计量，并推导出模型参数的最优估计，这是连接随机过程理论与实际数据分析的关键一步。",
            "id": "3920158",
            "problem": "一个单克隆哺乳动物细胞群体在灌注生物反应器中维持培养，其条件是在观察窗口内可以忽略细胞间的相互作用。该群体的大小被建模为一个线性生死过程，这是一个连续时间马尔可夫链 (CTMC)，其状态空间为 $\\{0,1,2,\\dots\\}$，生成元由 $q_{n,n+1} = \\lambda n$，$q_{n,n-1} = \\mu n$ 和 $q_{n,n} = -(\\lambda+\\mu)n$ 对 $n \\in \\mathbb{N}$ 指定。其中 $\\lambda > 0$ 是单位细胞的有丝分裂出生率，$\\mu > 0$ 是单位细胞的死亡率。初始群体大小 $n(0) = n_{0}$ 是已知的且为严格正数。\n\n在一个固定的观察区间 $[0,T]$ 内，轨迹被完全观察：每个跳跃时间及其类型（出生或死亡）都被记录下来，并且每个状态下的分段常数占据时间是已知的。令 $B$ 表示记录到的总出生事件数，$D$ 表示记录到的总死亡事件数，并定义累积暴露量\n$$\nS \\equiv \\int_{0}^{T} n(t)\\, dt,\n$$\n这是在 $[0,T]$ 上累积的总群体大小-时间。假设没有迁入和数据删失。\n\n仅从 CTMC 的定义、指数等待时间的无记忆性以及跳跃过程路径密度的乘积形式出发，推导完全观察到的轨迹的似然函数 $L(\\lambda,\\mu \\mid \\text{trajectory})$，该函数是 $\\lambda$ 和 $\\mu$ 的函数；然后，计算最大似然估计量 (MLE) $\\hat{\\lambda}$ 和 $\\hat{\\mu}$。最后，在暴露量 $S \\to \\infty$ 的情况下（等价于在确保 $S \\to \\infty$ 的条件下 $T \\to \\infty$），引用 CTMC 中 MLE 的适当正则性条件，确定 $\\hat{\\lambda}$ 和 $\\hat{\\mu}$ 的主阶渐近方差。\n\n在你的最终答案中，按 $\\hat{\\lambda}$、$\\hat{\\mu}$、$\\mathrm{Var}(\\hat{\\lambda})$ (主阶)、$\\mathrm{Var}(\\hat{\\mu})$ (主阶) 的顺序，以单行矩阵的形式呈现。不需要四舍五入；提供精确的解析表达式。在最终的方框表达式中不要包含单位。",
            "solution": "首先验证问题，以确保其具有科学依据、是良定的且客观的。\n\n### 步骤1：提取给定条件\n- **模型**：线性生死过程，一个连续时间马尔可夫链 (CTMC)。\n- **状态空间**：$\\{0, 1, 2, \\dots\\}$。\n- **生成元矩阵元素**：对于 $n \\in \\mathbb{N}$，$q_{n,n+1} = \\lambda n$，$q_{n,n-1} = \\mu n$，以及 $q_{n,n} = -(\\lambda+\\mu)n$。\n- **参数**：单位细胞出生率 $\\lambda > 0$，单位细胞死亡率 $\\mu > 0$。\n- **初始条件**：时间 $t=0$ 时的群体大小为 $n(0) = n_0$，其中 $n_0$ 是一个已知的正整数。\n- **观察方案**：在时间区间 $[0, T]$ 内完全观察单个轨迹。这包括所有跳跃时间、每次跳跃的类型（出生或死亡），以及在所有 $t \\in [0, T]$ 时的群体大小 $n(t)$。\n- **充分统计量**：\n    - $B$：在 $[0, T]$ 内的总出生事件计数。\n    - $D$：在 $[0, T]$ 内的总死亡事件计数。\n    - $S \\equiv \\int_{0}^{T} n(t)\\, dt$：在 $[0, T]$ 内的累积群体暴露量。\n- **假设**：群体没有迁入，数据没有删失。\n- **目标**：\n    1. 推导似然函数 $L(\\lambda, \\mu \\mid \\text{trajectory})$。\n    2. 计算最大似然估计量 (MLE) $\\hat{\\lambda}$ 和 $\\hat{\\mu}$。\n    3. 在累积暴露量 $S \\to \\infty$ 的极限下，确定 $\\hat{\\lambda}$ 和 $\\hat{\\mu}$ 的主阶渐近方差。\n\n### 步骤2：使用提取的给定条件进行验证\n该问题是随机过程统计推断中的一个标准练习，特别是针对连续时间马尔可夫链。\n- **科学依据**：线性生死过程是数学生物学、群体遗传学和排队论中的一个基础和典型的模型。其数学表述是严谨且完善的。所述问题在科学上和数学上都是合理的。\n- **良定性**：问题定义清晰。所提供的数据（$B$、$D$ 和 $S$）是在完全观察条件下该过程参数（$\\lambda$, $\\mu$）的众所周知的充分统计量。目标明确，能导出一个唯一的、有意义的解。\n- **客观性**：问题使用精确、标准的数学和统计术语来陈述。它没有任何歧义、主观性或非科学的主张。\n\n### 步骤3：结论和行动\n问题是**有效的**。现在开始求解过程。\n\n### 似然函数的推导\n对于一个在区间 $[0, T]$ 上被完全观察的一般 CTMC $X(t)$ 的轨迹，其似然由观察到的跳跃速率的乘积与跳跃之间逗留时间的概率的乘积给出。设观察到的跳跃时间为 $0  t_1  t_2  \\dots  t_k  T$，其中在区间 $[t_i, t_{i+1})$（$t_0=0$ 且 $t_{k+1}=T$）内状态为 $n_i$。似然为：\n$$\nL = \\left( \\prod_{i=1}^{k} q_{n_{i-1}, n_i} \\right) \\exp\\left( - \\sum_{i=0}^{k} q_{n_i} (t_{i+1} - t_i) \\right)\n$$\n其中 $q_{n,m}$ 是从状态 $n$ 到状态 $m$ 的转移率，而 $q_n = \\sum_{m \\neq n} q_{n,m}$ 是从状态 $n$ 的总离开率。\n\n对于给定的线性生死过程，速率为：\n- 出生：$q_{n, n+1} = \\lambda n$\n- 死亡：$q_{n, n-1} = \\mu n$\n- 总离开率：$q_n = q_{n, n+1} + q_{n, n-1} = \\lambda n + \\mu n = (\\lambda + \\mu)n$。\n\n似然表达式中的乘积项可以根据跳跃的类型进行分解。共有 $B$ 次出生事件和 $D$ 次死亡事件。设第 $j$ 次出生事件发生前系统的状态为 $n_{b,j}$，第 $j$ 次死亡事件发生前系统的状态为 $n_{d,j}$。跳跃速率的乘积为：\n$$\n\\prod_{\\text{jumps}} \\text{rate} = \\left( \\prod_{j=1}^{B} (\\lambda n_{b,j}) \\right) \\left( \\prod_{j=1}^{D} (\\mu n_{d,j}) \\right) = \\lambda^B \\mu^D \\left( \\prod_{j=1}^{B} n_{b,j} \\prod_{j=1}^{D} n_{d,j} \\right)\n$$\n涉及群体大小乘积的项仅取决于观察到的路径，而与参数 $\\lambda$ 和 $\\mu$ 无关。为了找到 MLE，此项是一个比例常数。\n\n指数项涉及离开率与逗留时间的乘积之和。这个和可以表示为在观察区间上的积分：\n$$\n\\sum_{i=0}^{k} q_{n_i} (t_{i+1} - t_i) = \\int_{0}^{T} q_{n(t)} dt = \\int_{0}^{T} (\\lambda + \\mu) n(t) dt\n$$\n使用累积暴露量 $S = \\int_{0}^{T} n(t)\\, dt$ 的定义，这变为：\n$$\n(\\lambda + \\mu) \\int_{0}^{T} n(t) dt = (\\lambda + \\mu) S\n$$\n结合这些部分，观察到的轨迹的似然函数 $L(\\lambda, \\mu)$，作为参数 $\\lambda$ 和 $\\mu$ 的函数，与以下表达式成正比：\n$$\nL(\\lambda, \\mu \\mid \\text{trajectory}) \\propto \\lambda^B \\mu^D \\exp\\left(-(\\lambda + \\mu)S\\right)\n$$\n\n### 最大似然估计量 (MLE) 的计算\n为了找到 MLE，我们关于 $\\lambda$ 和 $\\mu$ 最大化 $L(\\lambda, \\mu)$。更方便的是最大化对数似然函数 $\\ell(\\lambda, \\mu) = \\ln L(\\lambda, \\mu)$：\n$$\n\\ell(\\lambda, \\mu) = B \\ln \\lambda + D \\ln \\mu - (\\lambda + \\mu)S + C\n$$\n其中 $C$ 是一个不依赖于 $\\lambda$ 或 $\\mu$ 的常数。\n\n我们计算 $\\ell$ 关于 $\\lambda$ 和 $\\mu$ 的偏导数，并令它们为零：\n$$\n\\frac{\\partial \\ell}{\\partial \\lambda} = \\frac{B}{\\lambda} - S = 0\n$$\n$$\n\\frac{\\partial \\ell}{\\partial \\mu} = \\frac{D}{\\mu} - S = 0\n$$\n解这些关于 $\\lambda$ 和 $\\mu$ 的方程，得到最大似然估计量 $\\hat{\\lambda}$ 和 $\\hat{\\mu}$：\n$$\n\\hat{\\lambda} = \\frac{B}{S}\n$$\n$$\n\\hat{\\mu} = \\frac{D}{S}\n$$\n为了确认这些是最大值点，我们可以检查二阶偏导数。$\\ell$ 的黑塞矩阵是：\n$$\nH = \\begin{pmatrix} \\frac{\\partial^2 \\ell}{\\partial \\lambda^2}  \\frac{\\partial^2 \\ell}{\\partial \\lambda \\partial \\mu} \\\\ \\frac{\\partial^2 \\ell}{\\partial \\mu \\partial \\lambda}  \\frac{\\partial^2 \\ell}{\\partial \\mu^2} \\end{pmatrix} = \\begin{pmatrix} -\\frac{B}{\\lambda^2}  0 \\\\ 0  -\\frac{D}{\\mu^2} \\end{pmatrix}\n$$\n因为 $\\lambda  0$, $\\mu  0$, $B \\ge 0$, 并且 $D \\ge 0$，对角线元素是非正的。对于一个至少有一次出生和一次死亡的非平凡轨迹，$B  0$ 且 $D  0$，黑塞矩阵是负定的，这确认了我们找到了一个唯一的最大值点。\n\n### 渐近方差的推导\nMLE 的渐近方差-协方差矩阵由费雪信息矩阵 $I(\\theta)$ 的逆给出，其中 $\\theta = (\\lambda, \\mu)$。费雪信息矩阵定义为黑塞矩阵期望的负值：$I(\\theta) = -E[H(\\theta)]$。\n$$\nI(\\theta) = -E\\left[ \\begin{pmatrix} -\\frac{B}{\\lambda^2}  0 \\\\ 0  -\\frac{D}{\\mu^2} \\end{pmatrix} \\right] = \\begin{pmatrix} \\frac{E[B]}{\\lambda^2}  0 \\\\ 0  \\frac{E[D]}{\\mu^2} \\end{pmatrix}\n$$\n出生次数 $B$ 和死亡次数 $D$ 是随机变量，我们需要找到它们的期望。在时间 $t$ 的瞬时出生率是 $\\lambda n(t)$。在 $[0, T]$ 上的期望出生数是期望速率的积分：\n$$\nE[B] = E\\left[ \\int_0^T dN_B(t) \\right] = \\int_0^T E[\\lambda n(t)] dt = \\lambda E\\left[\\int_0^T n(t) dt\\right] = \\lambda E[S]\n$$\n类似地，对于死亡次数：\n$$\nE[D] = E\\left[ \\int_0^T dN_D(t) \\right] = \\int_0^T E[\\mu n(t)] dt = \\mu E\\left[\\int_0^T n(t) dt\\right] = \\mu E[S]\n$$\n将这些期望代入费雪信息矩阵：\n$$\nI(\\theta) = \\begin{pmatrix} \\frac{\\lambda E[S]}{\\lambda^2}  0 \\\\ 0  \\frac{\\mu E[S]}{\\mu^2} \\end{pmatrix} = \\begin{pmatrix} \\frac{E[S]}{\\lambda}  0 \\\\ 0  \\frac{E[S]}{\\mu} \\end{pmatrix}\n$$\n估计量 $(\\hat{\\lambda}, \\hat{\\mu})$ 的渐近方差-协方差矩阵是费雪信息矩阵的逆：\n$$\n\\mathrm{Var}(\\hat{\\theta}) \\approx I(\\theta)^{-1} = \\begin{pmatrix} \\frac{\\lambda}{E[S]}  0 \\\\ 0  \\frac{\\mu}{E[S]} \\end{pmatrix}\n$$\n问题指定了当观察到的暴露量 $S \\to \\infty$ 时的渐近极限。在此极限下，观察到的暴露量 $S$ 成为样本中信息量的自然度量。对于具有大值 $S$ 的特定轨迹，期望 $E[S]$ 可以很好地由 $S$ 近似。因此，估计量的主阶渐近方差用真实参数和观察到的暴露量 $S$ 来表示。\n$\\hat{\\lambda}$ 的渐近方差为：\n$$\n\\mathrm{Var}(\\hat{\\lambda}) \\approx \\frac{\\lambda}{S}\n$$\n$\\hat{\\mu}$ 的渐近方差为：\n$$\n\\mathrm{Var}(\\hat{\\mu}) \\approx \\frac{\\mu}{S}\n$$\n非对角线项为零，表明估计量 $\\hat{\\lambda}$ 和 $\\hat{\\mu}$ 是渐近不相关的。\n\n最终结果是：\n1. 出生率的 MLE：$\\hat{\\lambda} = \\frac{B}{S}$\n2. 死亡率的 MLE：$\\hat{\\mu} = \\frac{D}{S}$\n3. $\\hat{\\lambda}$ 的渐近方差：$\\mathrm{Var}(\\hat{\\lambda}) \\approx \\frac{\\lambda}{S}$\n4. $\\hat{\\mu}$ 的渐近方差：$\\mathrm{Var}(\\hat{\\mu}) \\approx \\frac{\\mu}{S}$\n\n这些表达式将按要求以单行矩阵形式呈现。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{B}{S}  \\frac{D}{S}  \\frac{\\lambda}{S}  \\frac{\\mu}{S}\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "参数估计并非模型构建的终点，而是一个关键的中间步骤。我们必须严格检验我们选择的模型结构是否真正捕捉了数据的生成机制。本练习介绍了一种强大而通用的模型验证技术——时间重整定理，并要求你通过编程实现一个基于该定理的拟合优度诊断 。这项计算实践将教会你如何将复杂的事件序列数据转化为一个简单的均匀性检验，为你评估任何点过程模型的有效性提供一个不可或缺的工具。",
            "id": "3920131",
            "problem": "您的任务是构建一个完整、可运行的程序，该程序使用时间重标残差和针对均匀分布的单样本 Kolmogorov–Smirnov 检验，为生物医学点过程数据实现拟合优度诊断。背景是建模为非齐次泊松过程的神经元脉冲序列，尽管其公式是纯数学的。所有事件时间以秒 (s) 为单位，强度以秒的倒数 ($\\mathrm{s}^{-1}$) 为单位。\n\n基本原理：\n- 对于一个条件强度函数为 $\\lambda(t \\mid \\mathcal{H}_t)$ 的简单点过程，其中 $\\mathcal{H}_t$ 表示直到时间 $t$ 的历史，当模型为生成过程正确指定时，其事件间间隔的积分条件强度增量 $$W_k = \\int_{t_{k-1}}^{t_k} \\lambda(u \\mid \\mathcal{H}_u)\\,du$$ 是均值为 $1$ 的独立同分布指数随机变量。等价地，变换后的残差 $$U_k = 1 - e^{-W_k}$$ 是在 $[0,1]$ 上独立同分布的均匀随机变量。\n- Kolmogorov–Smirnov (KS) 检验，正式名称为 Kolmogorov–Smirnov test (KST)，将样本的经验累积分布函数 (CDF) 与一个指定的连续 CDF（此处为 $[0,1]$ 上的均匀 CDF）进行比较，并为原假设（即样本是从指定分布中抽取的）得出一个检验统计量 $D$ 和一个 $p$ 值。\n\n模型设定：\n- 考虑一个在 $[0,\\infty)$ 上的非齐次泊松过程，其强度为\n$$\n\\lambda(t;\\theta) = \\beta + A \\exp\\!\\left(-\\frac{(t - \\mu)^2}{2\\sigma^2}\\right), \\quad t \\ge 0,\n$$\n其中 $\\theta = (\\beta, A, \\mu, \\sigma)$ 且 $\\beta \\ge 0$, $A \\ge 0$, $\\sigma  0$, 以及 $\\mu \\in \\mathbb{R}$。\n- 对于任意区间 $[a,b]$，此模型下的积分强度为\n$$\n\\int_a^b \\lambda(u;\\theta)\\,du = \\beta(b-a) + A \\sigma \\sqrt{\\frac{\\pi}{2}} \\left[\\operatorname{erf}\\!\\left(\\frac{b - \\mu}{\\sqrt{2}\\,\\sigma}\\right) - \\operatorname{erf}\\!\\left(\\frac{a - \\mu}{\\sqrt{2}\\,\\sigma}\\right)\\right],\n$$\n其中 $\\operatorname{erf}(\\cdot)$ 是 Gauss 误差函数。\n\n诊断设计（您的程序必须实现）：\n1. 使用已知的真实强度 $\\lambda(t;\\theta_{\\text{true}})$ 生成合成事件：\n   - 通过累积强度的反演，确定性地生成 $n$ 个事件时间 $0 = t_0  t_1  \\dots  t_n$，使得对于 $k=1,\\dots,n$，积分增量 $W_k = \\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta_{\\text{true}})\\,du$ 满足 $U_k = 1 - e^{-W_k}$，其中 $U_k \\in (0,1)$ 是一个预定的确定性序列。使用序列 $U_k = \\frac{k}{n+1}$，使得积分增量为 $W_k = -\\ln(1 - U_k)$，并通过求解以下方程来解出每个 $t_k$：\n   $$\n   \\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta_{\\text{true}})\\,du = -\\ln(1 - U_k),\n   $$\n   在 $t_k$ 上使用单调求根方法（例如，二分法），将解限定在有限区间 $[t_{k-1}, T_{\\max}]$ 内，其中 $T_{\\max}$ 的选择应足够大以容纳所需的总积分强度。\n2. 在候选模型 $\\lambda(t;\\theta_{\\text{model}})$ 下计算时间重标残差：\n   - 计算\n   $$\n   W_k^{\\text{model}} = \\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta_{\\text{model}})\\,du, \\quad U_k^{\\text{model}} = 1 - e^{-W_k^{\\text{model}}}.\n   $$\n3. 对 $\\{U_k^{\\text{model}}\\}_{k=1}^n$ 应用单样本 Kolmogorov–Smirnov 检验，与 $[0,1]$ 上的连续均匀分布进行比较，得到检验统计量 $D$ 和一个 $p$ 值。\n4. 对于每个测试用例，根据规则“如果 $p \\ge \\alpha$ 则接受”，输出一个布尔值，指示在水平 $\\alpha$ 下是否接受原假设。\n\n测试套件：\n为以下四个测试用例实现该诊断。在每个用例中，使用 $\\theta_{\\text{true}}$ 生成合成事件时间，然后使用 $\\theta_{\\text{model}}$ 计算残差。时间单位使用秒 (s)，强度单位使用秒的倒数 ($\\mathrm{s}^{-1}$)。设置 $T_{\\max} = 300\\,\\mathrm{s}$。\n\n- 用例 1（设定良好，中等样本量）：\n  - $\\theta_{\\text{true}} = (\\beta, A, \\mu, \\sigma) = (0.5, 1.0, 10.0, 1.0)$\n  - $\\theta_{\\text{model}} = (0.5, 1.0, 10.0, 1.0)$\n  - $n = 50$\n  - $\\alpha = 0.05$\n- 用例 2（幅度设定错误，相同样本量）：\n  - $\\theta_{\\text{true}} = (0.5, 1.0, 10.0, 1.0)$\n  - $\\theta_{\\text{model}} = (0.5, 2.0, 10.0, 1.0)$\n  - $n = 50$\n  - $\\alpha = 0.05$\n- 用例 3（幅度设定错误，小样本量）：\n  - $\\theta_{\\text{true}} = (0.5, 1.0, 10.0, 1.0)$\n  - $\\theta_{\\text{model}} = (0.5, 2.0, 10.0, 1.0)$\n  - $n = 5$\n  - $\\alpha = 0.05$\n- 用例 4（位置设定错误，较大样本量）：\n  - $\\theta_{\\text{true}} = (0.3, 1.5, 20.0, 2.0)$\n  - $\\theta_{\\text{model}} = (0.3, 1.5, 25.0, 2.0)$\n  - $n = 60$\n  - $\\alpha = 0.05$\n\n最终输出格式：\n您的程序应产生单行输出，其中包含四个用例的接受决策，形式为方括号括起来的逗号分隔列表，例如，“[True,False,True,False]”。每个条目都是一个布尔值，指示该用例中模型的时重标残差是否在指定的显著性水平上通过了均匀 Kolmogorov–Smirnov 检验。",
            "solution": "用户在生物医学系统建模领域提供了一个定义明确的计算问题，具体涉及点过程模型的验证。我将首先确认问题陈述的有效性，然后提供一个全面的解决方案和实现。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n*   **过程模型**：在 $[0, \\infty)$ 上的一个非齐次泊松过程，其强度函数为 $\\lambda(t;\\theta) = \\beta + A \\exp(-\\frac{(t - \\mu)^2}{2\\sigma^2})$，其中 $\\theta = (\\beta, A, \\mu, \\sigma)$。\n*   **积分强度公式**：强度的定积分由公式 $\\int_a^b \\lambda(u;\\theta)\\,du = \\beta(b-a) + A \\sigma \\sqrt{\\frac{\\pi}{2}} \\left[\\operatorname{erf}(\\frac{b - \\mu}{\\sqrt{2}\\,\\sigma}) - \\operatorname{erf}(\\frac{a - \\mu}{\\sqrt{2}\\,\\sigma})\\right]$ 给出。\n*   **时间重标原理**：如果模型是正确的，积分强度增量 $W_k = \\int_{t_{k-1}}^{t_k} \\lambda(u \\mid \\mathcal{H}_u)\\,du$ 是均值为 1 的独立同分布 (i.i.d.) 指数随机变量。变换后的残差 $U_k = 1 - e^{-W_k}$ 是在 $[0,1]$ 上独立同分布的均匀变量。\n*   **合成数据生成**：通过求解 $\\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta_{\\text{true}})\\,du = -\\ln(1 - U_k)$ 来确定性地生成事件时间 $0 = t_0  t_1  \\dots  t_n$，其中 $U_k = \\frac{k}{n+1}$。需使用单调求根方法在区间 $[t_{k-1}, T_{\\max}]$ 内求解。\n*   **拟合优度检验**：对计算出的残差 $\\{U_k^{\\text{model}}\\}_{k=1}^n = \\{1 - e^{-\\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta_{\\text{model}})\\,du}\\}_{k=1}^n$ 应用单样本 Kolmogorov–Smirnov (KS) 检验，与标准均匀分布进行比较。\n*   **决策规则**：如果 KS 检验的 $p$ 值大于或等于显著性水平 $\\alpha$，则接受原假设（即模型与数据拟合）。\n*   **常量和参数**：$T_{\\max} = 300\\,\\mathrm{s}$。指定了四个测试用例，每个用例都有不同的真实参数 ($\\theta_{\\text{true}}$)、模型参数 ($\\theta_{\\text{model}}$)、样本量 ($n$) 和显著性水平 ($\\alpha=0.05$)。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学依据充分**：该问题基于时间重标定理，这是点过程理论的基石。强度函数是瞬时速率变化的标准模型。使用 Kolmogorov-Smirnov 检验进行拟合优度检验，以对抗均匀分布，是一种标准的统计程序。通过反演确定性地生成事件的方法是创建具有特定属性的合成数据的有效技术。该问题在科学上和数学上都是合理的。\n2.  **良态的**：所有必要的函数、参数和过程都已明确定义。对于给定的参数约束（因为 $\\beta \\geq 0$, $A \\geq 0$, 且它们不都为零），强度函数 $\\lambda(t)$ 严格为正，这确保了其积分是严格递增的。这保证了用于生成事件时间的求根问题有唯一解。为 $T_{\\max}$ 提供的值足够大，可以包含指定测试用例的所有事件。该问题是自洽且无歧义的。\n3.  **客观的**：问题使用精确的数学语言和客观、可验证的指令来陈述。没有主观或基于意见的成分。\n\n**步骤 3：结论与行动**\n\n问题是**有效的**。它具有充分的科学依据、是良态的且客观的。我现在将继续提供解决方案。\n\n### 解决方案\n\n该解决方案涉及实现一个计算诊断程序，以评估非齐次泊松过程模型的拟合优度。这将通过遵循规定的步骤来完成：在一个“真实”模型下确定性地生成合成事件数据，在一个“候选”模型下计算时间重标残差，并对这些残差进行均匀性统计检验。\n\n**1. 理论框架：时间重标定理**\n该方法的基础是时间重标定理。对于一个事件时间为 $t_1, t_2, \\dots, t_n$ 且条件强度函数被正确指定的点过程 $\\lambda(t | \\mathcal{H}_t)$，量\n$$\nW_k = \\int_{t_{k-1}}^{t_k} \\lambda(u | \\mathcal{H}_u) \\, du, \\quad k=1, 2, \\dots, n\n$$\n是来自速率为 $1$ 的指数分布的独立同分布随机变量。这里，$\\mathcal{H}_t$ 代表直到时间 $t$ 的事件历史。对于非齐次泊松过程，强度 $\\lambda(t)$ 与历史无关。\n\n通过应用概率积分变换，我们可以将这些指数变量转换为均匀变量。如果 $W \\sim \\text{Exponential}(1)$，其累积分布函数 (CDF) 为 $F(w) = 1 - e^{-w}$。变换后的变量 $U=F(W)=1-e^{-W}$ 在 $[0,1]$ 上均匀分布。因此，如果我们的模型 $\\lambda(t;\\theta)$ 是正确的，时间重标残差\n$$\nU_k = 1 - \\exp\\left(-\\int_{t_{k-1}}^{t_k} \\lambda(u;\\theta) \\, du\\right)\n$$\n必须是来自 Uniform$[0,1]$ 分布的独立同分布样本。这构成了我们拟合优度检验的原假设的基础。\n\n**2. 合成事件生成**\n为了测试我们的诊断程序，我们首先需要一组事件时间。我们从一个已知的真实模型 $\\lambda(t; \\theta_{\\text{true}})$ 中确定性地生成这些时间。我们不采用随机模拟，而是通过将残差 $U_k$ 设置为均匀分布的分位数来对其施加一个确定性结构：\n$$\nU_k = \\frac{k}{n+1}, \\quad k = 1, \\dots, n.\n$$\n这一选择确保了如果用正确的模型进行分析，残差将呈现“完美的”分布。由此，我们推导出每个事件间间隔所需的积分强度：\n$$\nW_k = -\\ln(1 - U_k) = -\\ln\\left(1 - \\frac{k}{n+1}\\right) = \\ln\\left(\\frac{n+1}{n+1-k}\\right).\n$$\n然后通过为每个 $k$ 依次求解积分方程来找到事件时间 $t_k$：\n$$\n\\int_{t_{k-1}}^{t_k} \\lambda(u; \\theta_{\\text{true}}) \\, du = W_k.\n$$\n令 $\\Lambda(a, b; \\theta) = \\int_a^b \\lambda(u; \\theta) \\, du$。我们需要对 $t$ 求解方程 $\\Lambda(t_{k-1}, t, \\theta_{\\text{true}}) - W_k = 0$。由于 $\\lambda(t) > 0$，函数 $f(t) = \\Lambda(t_{k-1}, t, \\theta_{\\text{true}})$ 在 $t$ 上是严格递增的。这保证了存在一个唯一的根 $t_k > t_{k-1}$，可以使用像 Brent 方法这样的数值求根算法在搜索区间 $[t_{k-1}, T_{\\max}]$ 内高效地找到它。\n\n**3. 残差计算与统计检验**\n一旦生成了事件时间 $\\{t_k\\}_{k=1}^n$，我们就测试一个候选模型 $\\lambda(t; \\theta_{\\text{model}})$。注意 $\\theta_{\\text{model}}$ 可能等于也可能不等于 $\\theta_{\\text{true}}$。我们计算此候选模型下的残差：\n$$\nW_k^{\\text{model}} = \\Lambda(t_{k-1}, t_k; \\theta_{\\text{model}}),\n$$\n$$\nU_k^{\\text{model}} = 1 - \\exp(-W_k^{\\text{model}}).\n$$\n如果 $\\theta_{\\text{model}}$ 是生成事件时间的过程的良好表示（即，如果 $\\theta_{\\text{model}} \\approx \\theta_{\\text{true}}$），序列 $\\{U_k^{\\text{model}}\\}$ 应该看起来像是来自 Uniform$[0,1]$ 分布的样本。我们使用单样本 Kolmogorov-Smirnov (KS) 检验来正式检验这个假设。KS 检验计算样本 $\\{U_k^{\\text{model}}\\}$ 的经验 CDF 与标准均匀分布的理论 CDF 之间的最大绝对差。这个差值就是检验统计量 $D$。该检验得出一个 $p$ 值，它是在原假设下观察到至少与 $D$ 一样极端的统计量的概率。\n\n**4. 决策**\n我们将 $p$ 值与显著性水平 $\\alpha$ 进行比较。如果 $p \\ge \\alpha$，我们没有足够的证据拒绝原假设，于是我们“接受”该模型（更正式地说，我们未能拒绝它）。如果 $p  \\alpha$，我们拒绝原假设，结论是候选模型对数据拟合不佳。程序将对四个指定的测试用例中的每一个执行这整个过程，并报告决策规则的布尔结果。\n\n*   **用例 1（设定良好）**：$\\theta_{\\text{model}} = \\theta_{\\text{true}}$。残差 $\\{U_k^{\\text{model}}\\}$ 被生成为完美的均匀分位数。KS 检验应产生一个大的 $p$ 值，从而导致接受。\n*   **用例 2（幅度设定错误）**：$\\theta_{\\text{model}}$ 的幅度 $A$ 大于 $\\theta_{\\text{true}}$。这将导致计算出的 $W_k^{\\text{model}}$ 系统性地大于真实的 $W_k$，从而将 $U_k^{\\text{model}}$ 的值推向 $1$。KS 检验应能检测到这种与均匀性的偏离，产生一个小的 $p$ 值，从而导致拒绝。\n*   **用例 3（幅度设定错误，小样本）**：与用例 2 相同的设定错误，但样本量小得多 ($n=5$)。统计检验在小样本下的功效较低，使其更难检测到偏离。尽管模型不正确，检验仍有可能未能拒绝原假设。\n*   **用例 4（位置设定错误）**：$\\theta_{\\text{model}}$ 的峰值位置 $\\mu$ 与 $\\theta_{\\text{true}}$ 不同。这将导致系统性失配，其中 $W_k^{\\text{model}}$ 在某些区间过小，而在其他区间过大。在有足够样本量 ($n=60$) 的情况下，预计 KS 检验将检测到这一点并拒绝该模型。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.optimize import brentq\nfrom scipy.stats import kstest\n\ndef solve():\n    \"\"\"\n    Implements a goodness-of-fit diagnostic for an inhomogeneous Poisson process model\n    using time-rescaled residuals and the Kolmogorov-Smirnov test.\n    \"\"\"\n\n    def integrated_lambda(t_start, t_end, theta):\n        \"\"\"\n        Calculates the integrated intensity over the interval [t_start, t_end].\n\n        The intensity function is lambda(t) = beta + A * exp(-(t - mu)^2 / (2 * sigma^2)).\n        The integral is computed analytically using the error function erf.\n        \"\"\"\n        beta, A, mu, sigma = theta\n        \n        # Linear term from the constant baseline intensity beta\n        integral_beta = beta * (t_end - t_start)\n        \n        # Gaussian term's contribution\n        # Argument for the error function: z = (t - mu) / (sqrt(2) * sigma)\n        z_start = (t_start - mu) / (np.sqrt(2) * sigma)\n        z_end = (t_end - mu) / (np.sqrt(2) * sigma)\n        \n        # Integral of the Gaussian component\n        integral_gauss = A * sigma * np.sqrt(np.pi / 2) * (erf(z_end) - erf(z_start))\n        \n        return integral_beta + integral_gauss\n\n    def generate_events(theta_true, n, t_max):\n        \"\"\"\n        Generates a deterministic sequence of event times by inverting the\n        cumulative intensity function.\n        \"\"\"\n        event_times = np.zeros(n)\n        t_prev = 0.0\n        \n        for k in range(1, n + 1):\n            # Prescribed U_k values are quantiles of the uniform distribution\n            U_k = k / (n + 1)\n            # Corresponding integrated intensity W_k for an exponential(1) variable\n            W_k = -np.log(1 - U_k)\n            \n            # Define the function whose root we need to find.\n            # We are solving integrated_lambda(t_prev, t_k) - W_k = 0 for t_k.\n            def root_func(t_k):\n                return integrated_lambda(t_prev, t_k, theta_true) - W_k\n\n            # Use Brent's method to find the next event time t_k.\n            # The search interval is [t_prev, t_max].\n            # f(t_prev) is -W_k  0. We expect f(t_max) > 0 for a root to be bracketed.\n            try:\n                t_k = brentq(root_func, t_prev, t_max, xtol=1e-12, rtol=1e-12)\n                event_times[k-1] = t_k\n                t_prev = t_k\n            except ValueError:\n                # This would happen if t_max is not large enough, so root_func(t_max) is not positive.\n                # The problem setup ensures t_max is sufficient.\n                raise ValueError(f\"Root not bracketed for event {k}. Increase T_max.\")\n                \n        return event_times\n\n    # Test cases defined in the problem statement.\n    # Format: (theta_true, theta_model, n, alpha)\n    # T_max is common for all cases.\n    T_MAX = 300.0\n    test_cases = [\n        # Case 1: Well-specified, moderate sample size\n        {'theta_true': (0.5, 1.0, 10.0, 1.0), 'theta_model': (0.5, 1.0, 10.0, 1.0), 'n': 50, 'alpha': 0.05},\n        # Case 2: Amplitude misspecified, same sample size\n        {'theta_true': (0.5, 1.0, 10.0, 1.0), 'theta_model': (0.5, 2.0, 10.0, 1.0), 'n': 50, 'alpha': 0.05},\n        # Case 3: Amplitude misspecified, small sample size\n        {'theta_true': (0.5, 1.0, 10.0, 1.0), 'theta_model': (0.5, 2.0, 10.0, 1.0), 'n': 5, 'alpha': 0.05},\n        # Case 4: Location misspecified, larger sample size\n        {'theta_true': (0.3, 1.5, 20.0, 2.0), 'theta_model': (0.3, 1.5, 25.0, 2.0), 'n': 60, 'alpha': 0.05},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        theta_true = case['theta_true']\n        theta_model = case['theta_model']\n        n = case['n']\n        alpha = case['alpha']\n\n        # 1. Generate synthetic event times using the ground-truth model\n        event_times = generate_events(theta_true, n, T_MAX)\n        \n        # 2. Compute time-rescaled residuals under the candidate model\n        U_model = np.zeros(n)\n        t_prev = 0.0\n        for i, t_k in enumerate(event_times):\n            W_k_model = integrated_lambda(t_prev, t_k, theta_model)\n            U_model[i] = 1.0 - np.exp(-W_k_model)\n            t_prev = t_k\n            \n        # 3. Apply a one-sample KS test against the uniform distribution\n        # The null hypothesis is that the sample `U_model` is drawn from a uniform distribution.\n        ks_statistic, p_value = kstest(U_model, 'uniform')\n        \n        # 4. Accept the null hypothesis if p >= alpha\n        decision = (p_value >= alpha)\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}