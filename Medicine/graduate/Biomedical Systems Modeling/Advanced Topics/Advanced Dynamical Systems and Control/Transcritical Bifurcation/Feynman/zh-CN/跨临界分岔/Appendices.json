{
    "hands_on_practices": [
        {
            "introduction": "首先，我们将所学知识应用于合成生物学的一个具体场景。此问题要求您在一个酶动力学模型中，计算触发跨临界分岔的临界抑制剂浓度。掌握这种计算方法，是预测和控制生物回路中常见的开关行为的一项基本技能。",
            "id": "1724859",
            "problem": "在一个合成生物电路中，酶浓度 $y(t)$ 的动力学可以通过以下一阶非线性微分方程来建模：\n$$ \\frac{dy}{dt} = (k_p - k_d - \\beta c)y - \\frac{k_p}{Y_{max}} y^2 $$\n在这个模型中，外部施加的抑制剂分子浓度 $c$ 作为系统的控制参数。当参数 $c$ 变化时，系统在平凡不动点 $y=0$ 处表现出跨临界分岔。\n\n系统的参数已经通过实验确定为：\n- 最大自催化生产速率常数，$k_p = 0.52 \\text{ min}^{-1}$。\n- 酶自然降解速率常数，$k_d = 0.11 \\text{ min}^{-1}$。\n- 抑制剂有效性常数，$\\beta = 0.075 \\text{ L} \\cdot \\mu\\text{mol}^{-1} \\cdot \\text{min}^{-1}$。\n- 酶饱和浓度，$Y_{max} = 15 \\text{ }\\mu\\text{M}$。\n\n$y$ 和 $c$ 的单位均为微摩尔每升 ($\\mu\\text{M}$)。\n\n确定抑制剂浓度的临界值 $c_{crit}$，在该值下系统在平衡点 $y=0$ 处发生跨临界分岔。请用微摩尔每升 ($\\mu\\text{M}$) 为单位表示你的答案，并将最终答案四舍五入到三位有效数字。",
            "solution": "我们已知微分方程\n$$\n\\frac{dy}{dt} = \\left(k_{p} - k_{d} - \\beta c\\right)y - \\frac{k_{p}}{Y_{\\max}}y^{2}.\n$$\n平衡点满足\n$$\n0 = \\left(k_{p} - k_{d} - \\beta c\\right)y - \\frac{k_{p}}{Y_{\\max}}y^{2}\n= y\\left[\\left(k_{p} - k_{d} - \\beta c\\right) - \\frac{k_{p}}{Y_{\\max}}y\\right].\n$$\n因此不动点为\n$$\ny_{1}=0,\\qquad y_{2}=\\frac{Y_{\\max}}{k_{p}}\\left(k_{p} - k_{d} - \\beta c\\right).\n$$\n在 $y=0$ 处的跨临界分岔发生于 $y=0$ 处的线性化稳定性改变，且非平凡平衡点与 $y=0$ 碰撞时。雅可比矩阵（右侧关于 $y$ 的导数）是\n$$\nf_{y}(y;c)=\\left(k_{p} - k_{d} - \\beta c\\right) - 2\\frac{k_{p}}{Y_{\\max}}y,\n$$\n所以在 $y=0$ 处，\n$$\nf_{y}(0;c)=k_{p} - k_{d} - \\beta c.\n$$\n分岔发生在 $f_{y}(0;c)=0$ 时，这给出了临界抑制剂浓度\n$$\nc_{\\text{crit}}=\\frac{k_{p} - k_{d}}{\\beta}.\n$$\n代入给定的参数值，\n$$\nc_{\\text{crit}}=\\frac{0.52 - 0.11}{0.075}=\\frac{0.41}{0.075}=\\frac{82}{15}\\approx 5.466\\overline{6}.\n$$\n四舍五入到三位有效数字，得到 $5.47$ 微摩尔单位，符合要求。",
            "answer": "$$\\boxed{5.47}$$"
        },
        {
            "introduction": "识别分岔点只是第一步；要对其类型进行分类，需要更仔细地审视系统的数学结构。这个问题将挑战您去分析，为何一个表现出分岔的系统却不满足跨临界分岔的特定标准。这项练习旨在加深您对区分不同分岔类型的精确条件的理解，这是严谨动力系统分析的一个关键方面。",
            "id": "1724860",
            "problem": "考虑一个由微分方程 $\\dot{x} = f(x, \\mu)$ 定义的一维动力系统，其中 $x(t)$ 是状态变量，$\\mu$ 是一个实值参数。系统的不动点 $x^*$ 满足 $f(x^*, \\mu) = 0$。如果在参数值 $\\mu_c$ 处，当 $\\mu$ 穿过 $\\mu_c$ 时，系统的定性行为（例如其不动点的数量或稳定性）发生变化，则称在 $\\mu_c$ 处发生分岔。\n\n在原点 $(x^*, \\mu_c) = (0, 0)$ 处发生的跨临界分岔的范式由 $\\dot{x} = \\mu x - x^2$ 给出。对于一个通用系统 $\\dot{x} = f(x, \\mu)$ 要在点 $(x^*, \\mu_c)$ 经历跨临界分岔，必须满足 $f(x, \\mu)$ 在该点求值的偏导数的某些条件。\n\n现在，考虑由以下方程给出的特定系统：\n$$ \\dot{x} = \\mu x - x^3 $$\n可以验证，$x^* = 0$ 对所有 $\\mu$ 值都是一个不动点，并且涉及该不动点的分岔发生在临界参数值 $\\mu_c = 0$ 处。然而，这种分岔不是跨临界分岔。\n\n下列哪个陈述提供了对于系统 $\\dot{x} = \\mu x - x^3$ 在 $(x^*, \\mu_c)=(0,0)$ 处的分岔不是跨临界分岔的精确数学原因？令 $f(x, \\mu) = \\mu x - x^3$。\n\nA. 不动点 $x^*=0$ 并非对所有 $\\mu$ 值都存在。\n\nB. 当 $\\mu$ 穿过 $\\mu_c=0$ 时，不动点 $x^*=0$ 的稳定性不发生变化。\n\nC. 偏导数 $\\frac{\\partial f}{\\partial \\mu}$ 在 $(0,0)$ 处的值非零。\n\nD. 二阶偏导数 $\\frac{\\partial^2 f}{\\partial x^2}$ 在 $(0,0)$ 处的值为零。\n\nE. 偏导数 $\\frac{\\partial^2 f}{\\partial x \\partial \\mu}$ 在 $(0,0)$ 处的值为零。",
            "solution": "我们寻找导致系统 $\\dot{x}=f(x,\\mu)=\\mu x - x^{3}$ 在 $(x^{*},\\mu_{c})=(0,0)$ 处的跨临界分岔不成立的精确条件。\n\n对于一维系统 $\\dot{x}=f(x,\\mu)$ 在 $(0,0)$ 处的跨临界分岔，标准的非退化性和横截性条件要求：\n1) $f(0,0)=0$,\n2) $f_{x}(0,0)=0$,\n3) $f_{xx}(0,0)\\neq 0$,\n4) $f_{x\\mu}(0,0)\\neq 0$,\n并且（在许多标准表述中）还有 $f_{\\mu}(0,0)=0$，以便在不动点处的主要参数依赖性由混合偏导数捕捉。\n\n计算 $f(x,\\mu)=\\mu x - x^{3}$ 的必要导数：\n- 在候选分岔点处的值：\n$$\nf(0,0)=\\mu\\cdot 0 - 0^{3}=0.\n$$\n- 关于 $x$ 的一阶导数：\n$$\nf_{x}(x,\\mu)=\\frac{\\partial}{\\partial x}(\\mu x - x^{3})=\\mu - 3x^{2},\\quad f_{x}(0,0)=0.\n$$\n- 关于 $x$ 的二阶导数：\n$$\nf_{xx}(x,\\mu)=\\frac{\\partial^{2}}{\\partial x^{2}}(\\mu x - x^{3})=-6x,\\quad f_{xx}(0,0)=0.\n$$\n- 混合导数：\n$$\nf_{x\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu - 3x^{2})=1,\\quad f_{x\\mu}(0,0)=1\\neq 0.\n$$\n- 关于 $\\mu$ 的一阶导数：\n$$\nf_{\\mu}(x,\\mu)=\\frac{\\partial}{\\partial\\mu}(\\mu x - x^{3})=x,\\quad f_{\\mu}(0,0)=0.\n$$\n\n因此，在 $(0,0)$ 处，条件 $f(0,0)=0$、$f_{x}(0,0)=0$、$f_{x\\mu}(0,0)\\neq 0$ 和 $f_{\\mu}(0,0)=0$ 都得到满足。然而，跨临界分岔的关键非退化条件 $f_{xx}(0,0)\\neq 0$ 不成立，因为 $f_{xx}(0,0)=0$。因此，该分岔不是跨临界分岔的精确数学原因是关于 $x$ 的二阶偏导数在 $(0,0)$ 处为零。\n\n在给出的选项中，这完全对应于陈述 D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "在实际的生物医学建模中，我们常常依赖复杂的模拟或实验数据，而无法获得简洁的解析公式。这项高级练习旨在通过让您开发一种数值算法，直接从模拟数据中检验跨临界分岔的条件，从而将理论与实践联系起来。这种方法对于在真实的研究环境中验证模型和理解系统行为至关重要。",
            "id": "3939176",
            "problem": "考虑一个模拟在充分混合隔室中稳态细胞密度的一维常微分方程，其中状态 $x$ 表示无量纲细胞密度，参数 $\\mu$ 表示净增殖驱动力，并伴有由接触抑制引起的二次饱和效应。该动力学由初值问题 $\\frac{dx}{dt} = f(x,\\mu;k)$ 给出，其中 $f$ 在 $(x,\\mu)=(0,0)$ 的邻域内是光滑的，并通过在一个小的时间增量 $\\Delta t$ 上的显式欧拉步以模拟形式指定：从 $x(0)=x_0$ 开始，生成 $x(\\Delta t)=x_0 + \\Delta t\\, f(x_0,\\mu;k)$。假设 $k$ 是一个捕捉自限制强度的非负实数参数。\n\n在生物医学系统建模中，当两个平衡分支相交并交换稳定性时，会发生跨临界分岔。在 $(x,\\mu)=(0,0)$ 处的泛型跨临界分岔的非退化条件要求 $f_{x\\mu}(0,0)\\neq 0$ 和 $f_{xx}(0,0)\\neq 0$，其中下标表示偏导数。您的任务是开发一种数值方法，该方法仅利用从上述显式欧拉步模拟出的短时数据，来估计 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$，然后使用这些估计值来检验跨临界分岔的非退化条件。\n\n从微积分和动力系统的核心定义出发，实现一个算法，该算法：\n- 通过从 $x(0)=x$ 开始模拟一个大小为 $\\Delta t$ 的显式欧拉步，并计算有限差分 $(x(\\Delta t)-x)/\\Delta t$，来估计在指定的 $(x,\\mu)$ 处的右侧函数 $f(x,\\mu;k)$。\n- 使用在 $(x,\\mu)=(0,0)$ 周围的有限差分法，以及小的对称扰动 $h_x$ 和 $h_\\mu$，从扰动点处 $f(x,\\mu;k)$ 的估计值来数值近似 $f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$。\n- 如果对于一个指定的容差 $\\epsilon0$， $|f_{x\\mu}(0,0)|\\epsilon$ 和 $|f_{xx}(0,0)|\\epsilon$ 同时成立，则宣布跨临界分岔的非退化检验通过。\n\n使用以下参数集 $(k,h_x,h_\\mu,\\Delta t,\\epsilon)$ 的测试套件：\n- 情况1：$k=1.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况2：$k=0.0$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n- 情况3：$k=2.5$, $h_x=5\\times 10^{-5}$, $h_\\mu=2\\times 10^{-4}$, $\\Delta t=5\\times 10^{-7}$, $\\epsilon=10^{-6}$。\n- 情况4：$k=10^{-12}$, $h_x=10^{-4}$, $h_\\mu=10^{-4}$, $\\Delta t=10^{-6}$, $\\epsilon=10^{-6}$。\n\n假设生物医学模拟器底层的 $f$ 与接触限制增殖一致，具体为在原点邻域内 $f(x,\\mu;k)=\\mu x - k x^2$，但您决不能使用此闭式形式来计算导数；您必须按照描述从模拟数据中估计 $f$。\n\n您的程序必须为每个测试用例生成一个包含三个值的列表：$f_{x\\mu}(0,0)$ 和 $f_{xx}(0,0)$ 的数值估计值（作为浮点数），后跟一个布尔值，指示在容差 $\\epsilon$ 下跨临界分岔的非退化检验是否通过。将所有测试用例的结果聚合到单行输出中，该输出包含一个用方括号括起来的逗号分隔列表，例如 $[[a_1,b_1,c_1],[a_2,b_2,c_2],[a_3,b_3,c_3],[a_4,b_4,c_4]]$，其中每个 $a_i$ 和 $b_i$ 是浮点数，每个 $c_i$ 是布尔值。输出不需要物理单位，也不涉及角度。最终输出格式必须严格遵守指定的单行格式。",
            "solution": "该问题要求对由常微分方程 $\\frac{dx}{dt} = f(x,\\mu;k)$ 描述的动力系统，在原点 $(x, \\mu) = (0, 0)$ 处的跨临界分岔的非退化条件进行数值验证。非退化条件由 $f_{x\\mu}(0,0) \\neq 0$ 和 $f_{xx}(0,0) \\neq 0$ 给出，其中下标表示偏导数。函数 $f$ 本身未以可供分析的闭式形式给出；相反，必须通过模拟的显式欧拉步来估计它。\n\n该算法方法包括三个主要阶段：首先，为函数 $f(x, \\mu; k)$ 定义一个数值估计器；其次，在有限差分公式中使用此估计器来近似偏导数 $f_{xx}(0,0)$ 和 $f_{x\\mu}(0,0)$；第三，对这些估计导数的量级应用容差 $\\epsilon$ 来检验非退化条件。\n\n第一阶段是估计函数 $f(x,\\mu;k)$。问题通过一个执行单次显式欧拉步的模拟器提供了对系统动力学的访问。对于初始条件 $x(0) = x_0$，在时间 $\\Delta t$ 的状态由下式给出：\n$$ x(\\Delta t) = x_0 + \\Delta t \\cdot f(x_0, \\mu; k) $$\n通过对该方程进行代数重排，我们可以在点 $(x_0, \\mu)$ 处为函数 $f$ 构建一个估计器：\n$$ \\hat{f}(x_0, \\mu; k) = \\frac{x(\\Delta t) - x_0}{\\Delta t} $$\n问题指明，模拟器使用的底层动力学遵循模型 $f(x,\\mu;k) = \\mu x - k x^2$。虽然我们的算法不得使用此解析形式来计算导数，但我们必须用它来定义模拟器。将此代入欧拉步，得到：\n$$ x(\\Delta t) = x_0 + \\Delta t (\\mu x_0 - k x_0^2) $$\n这个函数代表了我们用以估计 $f$ 的模拟预言机。\n\n第二阶段是偏导数的数值近似。我们采用中心有限差分公式，使用小的对称扰动 $h_x$ 和 $h_\\mu$ 来估计在分岔点 $(x, \\mu) = (0, 0)$ 处的二阶和混合偏导数。$f_{xx}(0,0)$ 的近似使用三点中心差分公式：\n$$ f_{xx}(0,0) \\approx \\frac{\\hat{f}(h_x, 0; k) - 2\\hat{f}(0, 0; k) + \\hat{f}(-h_x, 0; k)}{h_x^2} $$\n所需的函数值通过我们的估计器 $\\hat{f}$ 获得：$\\hat{f}(h_x, 0; k)$ 通过从 $x(0) = h_x$、$\\mu=0$ 开始模拟来计算；$\\hat{f}(0, 0; k)$ 通过从 $x(0) = 0$、$\\mu=0$ 开始模拟来计算；而 $\\hat{f}(-h_x, 0; k)$ 通过从 $x(0) = -h_x$、$\\mu=0$ 开始模拟来计算。$f_{x\\mu}(0,0)$ 的近似使用四点中心差分公式：\n$$ f_{x\\mu}(0,0) \\approx \\frac{\\hat{f}(h_x, h_\\mu; k) - \\hat{f}(h_x, -h_\\mu; k) - \\hat{f}(-h_x, h_\\mu; k) + \\hat{f}(-h_x, -h_\\mu; k)}{4 h_x h_\\mu} $$\n这需要在 $(x, \\mu)$ 平面中以原点为中心的小矩形的四个角点上对我们的函数估计器 $\\hat{f}$ 进行四次求值。例如，$\\hat{f}(h_x, h_\\mu; k)$ 是通过从初始条件 $x(0) = h_x$ 和参数值 $\\mu = h_\\mu$ 开始模拟来计算的。\n\n第三个也是最后一个阶段是非退化检验。利用导数的数值估计值（记为 $\\hat{f}_{xx}(0,0)$ 和 $\\hat{f}_{x\\mu}(0,0)$），将非退化条件与给定的正容差 $\\epsilon$ 进行比较检验。当且仅当以下两个不等式都成立时，该检验被宣布为通过：\n$$ |\\hat{f}_{xx}(0,0)|  \\epsilon \\quad \\text{且} \\quad |\\hat{f}_{x\\mu}(0,0)|  \\epsilon $$\n然后将此过程应用于每个提供的测试用例。对于给定的底层函数 $f(x, \\mu; k) = \\mu x - k x^2$，其真实导数为 $f_{xx}(0,0) = -2k$ 和 $f_{x\\mu}(0,0) = 1$。我们的数值估计值应该非常接近这些解析值，因为有限差分公式对于低阶多项式是精确的。非退化检验实际上变成了检查 $|-2k|  \\epsilon$ 和 $|1|  \\epsilon$ 是否成立。鉴于 $\\epsilon$ 很小（例如，$10^{-6}$），第二个条件几乎总是满足，因此检验的关键在于参数 $k$ 的量级是否足够大。",
            "answer": "```python\nimport numpy as np\n\ndef _hidden_simulator_step(x0, mu, k, dt):\n    \"\"\"\n    This function represents the \"black box\" biomedical simulator.\n    It computes x(t+dt) from x(t) using one explicit Euler step.\n    The problem specifies the underlying ODE is dx/dt = mu*x - k*x**2.\n    The algorithm must treat this as an oracle and not use its internal formula\n    to compute analytical derivatives.\n    \"\"\"\n    f_val = mu * x0 - k * x0**2\n    return x0 + dt * f_val\n\ndef estimate_f(x0, mu, k, dt):\n    \"\"\"\n    Estimates f(x0, mu; k) by simulating one explicit Euler step of size dt\n    from x(0)=x0 and computing the finite difference (x(dt)-x0)/dt,\n    as required by the problem statement.\n    \"\"\"\n    x_at_dt = _hidden_simulator_step(x0, mu, k, dt)\n    f_estimate = (x_at_dt - x0) / dt\n    return f_estimate\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and produce the final output.\n    \"\"\"\n    # Test suite of parameter sets (k, h_x, h_mu, dt, epsilon)\n    test_cases = [\n        # Case 1: k=1.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 2: k=0.0, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (0.0, 1e-4, 1e-4, 1e-6, 1e-6),\n        # Case 3: k=2.5, h_x=5x10^-5, h_mu=2x10^-4, dt=5x10^-7, epsilon=10^-6\n        (2.5, 5e-5, 2e-4, 5e-7, 1e-6),\n        # Case 4: k=10^-12, h_x=10^-4, h_mu=10^-4, dt=10^-6, epsilon=10^-6\n        (1e-12, 1e-4, 1e-4, 1e-6, 1e-6),\n    ]\n\n    results = []\n    for case in test_cases:\n        k, h_x, h_mu, dt, epsilon = case\n\n        # Estimate f_xx(0,0) using a central difference formula.\n        # This requires three calls to the f-estimator.\n        f_plus_x = estimate_f(h_x, 0.0, k, dt)\n        f_zero = estimate_f(0.0, 0.0, k, dt)\n        f_minus_x = estimate_f(-h_x, 0.0, k, dt)\n        est_f_xx = (f_plus_x - 2.0 * f_zero + f_minus_x) / (h_x**2)\n\n        # Estimate f_xmu(0,0) using a central difference formula.\n        # This requires four calls to the f-estimator.\n        f_pp = estimate_f(h_x, h_mu, k, dt)   # Point (+h_x, +h_mu)\n        f_pm = estimate_f(h_x, -h_mu, k, dt)  # Point (+h_x, -h_mu)\n        f_mp = estimate_f(-h_x, h_mu, k, dt)  # Point (-h_x, +h_mu)\n        f_mm = estimate_f(-h_x, -h_mu, k, dt) # Point (-h_x, -h_mu)\n        est_f_xmu = (f_pp - f_pm - f_mp + f_mm) / (4.0 * h_x * h_mu)\n\n        # Perform the transcritical nondegeneracy test.\n        is_nondegenerate = abs(est_f_xmu)  epsilon and abs(est_f_xx)  epsilon\n\n        results.append([est_f_xmu, est_f_xx, is_nondegenerate])\n\n    # Format the final output string exactly as specified: [[...],[...],...]\n    # Using str() on a list of lists creates the required formatting.\n    # Capitalized True/False from Python's str() is the standard representation.\n    output_str = \"[[{:.1f}, {:.1f}, {}], [{:.1f}, {:.1f}, {}], [{:.1f}, {:.1f}, {}], [{:.1f}, {:.1e}, {}]]\".format(\n        results[0][0], results[0][1], results[0][2],\n        results[1][0], results[1][1], results[1][2],\n        results[2][0], results[2][1], results[2][2],\n        results[3][0], results[3][1], results[3][2]\n    )\n    # This manual formatting is to ensure consistency and avoid potential float precision display issues.\n    # But the problem asks for floats, and standard repr is fine.\n    # Let's revert to the simpler, more robust method.\n    output_str = f\"[{','.join(str(r) for r in results)}]\"\n    print(output_str)\n\n# The prompt asks for a runnable code block, but the final output should be a string, not execution result.\n# So I provide the runnable code block which, when run, would produce the required string.\n# The expected output string is: [[1.0, -2.0, True],[1.0, 0.0, False],[1.0, -5.0, True],[1.0, -2.0000000000000003e-12, False]]\n# Since I cannot run the code, I provide the code as the answer.\n```"
        }
    ]
}