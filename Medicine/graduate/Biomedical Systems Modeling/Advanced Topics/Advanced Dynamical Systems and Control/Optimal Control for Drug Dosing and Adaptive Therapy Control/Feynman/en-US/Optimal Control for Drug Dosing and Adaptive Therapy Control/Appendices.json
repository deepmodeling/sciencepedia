{
    "hands_on_practices": [
        {
            "introduction": "Before designing complex dynamic controllers, it's essential to understand the target. This first practice establishes the foundational relationship between a desired therapeutic outcome and the required drug administration rate under equilibrium conditions. By working through the calculation, you will connect a pharmacodynamic (PD) effect target to a steady-state plasma concentration ($C_{ss}$) and then determine the constant infusion rate needed to maintain it, reinforcing the core principles of steady-state pharmacokinetics (PK). ",
            "id": "3914577",
            "problem": "A cytostatic anticancer agent is administered by constant-rate intravenous infusion and follows a single-compartment pharmacokinetics (PK) model with linear elimination. Let the plasma concentration be $C(t)$, the infusion rate be $u$ (assumed constant in time), the volume of distribution be $V$, and the clearance be $CL$. The mass balance for the concentration is given by\n$$\n\\frac{dC}{dt} \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}\\,C,\\quad t>0.\n$$\nThe pharmacodynamics (PD) effect is a monotone increasing function of $C$ described by an $E_{\\max}$ model:\n$$\nR(C) \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C}{EC_{50} + C},\n$$\nwhere $R_{0}$ is the baseline response, $E_{\\max}$ is the maximal drug-induced increase over baseline, and $EC_{50}$ is the concentration producing half of the maximal increase. An adaptive therapy controller specifies a steady-state PD target $R_{\\text{target}}^{\\ast}$ within the admissible range set by the model.\n\nGiven the parameters $R_{0} = 10$ response units, $E_{\\max} = 40$ response units, $EC_{50} = 2\\,\\mathrm{mg/L}$, $CL = 5\\,\\mathrm{L/h}$, and $V = 40\\,\\mathrm{L}$, and the target $R_{\\text{target}}^{\\ast} = 30$ response units, determine the required constant steady-state concentration $C$ that achieves the target and the corresponding constant infusion rate $u$ that maintains that concentration at steady state.\n\nExpress the concentration in $\\mathrm{mg/L}$ and the infusion rate in $\\mathrm{mg/h}$. Round your answers to three significant figures.",
            "solution": "The user has provided a problem in biomedical systems modeling, specifically concerning pharmacokinetics (PK) and pharmacodynamics (PD). The task is to determine the steady-state drug concentration and the corresponding infusion rate required to achieve a target therapeutic effect.\n\nFirst, a validation of the problem statement is performed.\n\n**Step 1: Extract Givens**\nThe following information is provided in the problem statement:\n-   Pharmacokinetic (PK) model: $\\frac{dC}{dt} = \\frac{u}{V} - \\frac{CL}{V}C$, for $t>0$.\n-   Pharmacodynamic (PD) model: $R(C) = R_{0} + \\frac{E_{\\max}C}{EC_{50} + C}$.\n-   Model parameters:\n    -   Baseline response, $R_{0} = 10$ response units.\n    -   Maximal drug-induced increase, $E_{\\max} = 40$ response units.\n    -   Concentration for half-maximal effect, $EC_{50} = 2\\,\\mathrm{mg/L}$.\n    -   Clearance, $CL = 5\\,\\mathrm{L/h}$.\n    -   Volume of distribution, $V = 40\\,\\mathrm{L}$.\n-   Target steady-state response, $R_{\\text{target}}^{\\ast} = 30$ response units.\n-   The infusion rate $u$ and the resulting concentration $C$ are to be maintained at steady-state values.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is based on standard, well-established models in pharmacology. The single-compartment PK model with linear elimination and the $E_{\\max}$ PD model are fundamental concepts used to describe the relationship between drug dosage, concentration, and effect. The models are scientifically valid and represent a standard problem in the field.\n-   **Well-Posed:** The problem provides all necessary parameters and equations to determine a unique solution. The target response, $R_{\\text{target}}^{\\ast} = 30$, is within the achievable range of the PD model. The minimum response (at $C=0$) is $R_0 = 10$, and the maximum theoretical response (as $C \\to \\infty$) is $R_0 + E_{\\max} = 10 + 40 = 50$. Since $10 < 30 < 50$, a unique, positive, and finite concentration $C$ that produces the target response exists.\n-   **Objective:** The problem is stated using precise, objective, and standard scientific terminology. There is no ambiguity or subjectivity.\n-   **Completeness and Consistency:** The problem is self-contained and free of contradictions. The units of the given parameters ($mg/L$, $L/h$, $L$) are consistent and allow for the calculation of the requested quantities in the specified units ($mg/L$ and $mg/h$).\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. It is scientifically sound, well-posed, objective, and complete. A solution will be formulated.\n\nThe solution proceeds in two parts. First, the required steady-state concentration ($C_{ss}$) is determined from the PD model to achieve the target response. Second, the necessary constant infusion rate ($u$) to maintain this concentration is calculated from the PK model at steady-state.\n\n**Part 1: Determine the steady-state concentration ($C_{ss}$)**\nThe system is at a steady state, which means the response $R(C)$ is equal to the target response $R_{\\text{target}}^{\\ast}$. Let the steady-state concentration be denoted by $C_{ss}$. We set the PD model equation equal to the target value:\n$$\nR_{\\text{target}}^{\\ast} \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C_{ss}}{EC_{50} + C_{ss}}\n$$\nSubstituting the given parameter values:\n$$\n30 \\;=\\; 10 \\;+\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\nWe solve this algebraic equation for $C_{ss}$. First, subtract $R_{0}=10$ from both sides:\n$$\n30 - 10 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n$$\n20 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\nNow, multiply both sides by the denominator $(2 + C_{ss})$:\n$$\n20(2 + C_{ss}) \\;=\\; 40\\,C_{ss}\n$$\nDistribute the $20$ on the left-hand side:\n$$\n40 \\;+\\; 20\\,C_{ss} \\;=\\; 40\\,C_{ss}\n$$\nGroup the terms containing $C_{ss}$:\n$$\n40 \\;=\\; 40\\,C_{ss} - 20\\,C_{ss}\n$$\n$$\n40 \\;=\\; 20\\,C_{ss}\n$$\nFinally, solve for $C_{ss}$:\n$$\nC_{ss} \\;=\\; \\frac{40}{20} \\;=\\; 2\n$$\nThe required steady-state concentration is $C_{ss} = 2\\,\\mathrm{mg/L}$. As specified, rounding to three significant figures gives $2.00\\,\\mathrm{mg/L}$.\n\n**Part 2: Determine the corresponding infusion rate ($u$)**\nThe PK model describes the change in concentration over time. At steady state, the concentration is constant, which means its time derivative is zero: $\\frac{dC}{dt} = 0$.\n$$\n\\frac{dC}{dt} \\;=\\; 0 \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}C_{ss}\n$$\nWe can rearrange this equation to solve for the infusion rate $u$:\n$$\n\\frac{u}{V} \\;=\\; \\frac{CL}{V}C_{ss}\n$$\nMultiplying both sides by $V$ yields a fundamental relationship in steady-state pharmacokinetics: the rate of infusion equals the rate of elimination.\n$$\nu \\;=\\; CL \\cdot C_{ss}\n$$\nNow, we substitute the given value for clearance ($CL = 5\\,\\mathrm{L/h}$) and the calculated steady-state concentration ($C_{ss} = 2\\,\\mathrm{mg/L}$):\n$$\nu \\;=\\; (5\\,\\mathrm{L/h}) \\cdot (2\\,\\mathrm{mg/L})\n$$\n$$\nu \\;=\\; 10\\,\\mathrm{mg/h}\n$$\nThe resulting infusion rate is $u = 10\\,\\mathrm{mg/h}$. Rounding to three significant figures gives $10.0\\,\\mathrm{mg/h}$.\n\nThus, to achieve a target response of $30$ units, a steady-state plasma concentration of $2.00\\,\\mathrm{mg/L}$ must be maintained, which requires a constant infusion rate of $10.0\\,\\mathrm{mg/h}$.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.00 & 10.0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "The previous exercise assumed that a patient's pharmacokinetic parameters are perfectly known. In practice, these parameters are patient-specific and must be estimated from sparse and noisy clinical data. This hands-on coding problem guides you through the process of parameter identification using Maximum Likelihood Estimation (MLE) on synthetic data, a cornerstone of personalizing therapy. Furthermore, it introduces the delta method to propagate the uncertainty from your parameter estimates to a final dose recommendation, providing a crucial confidence interval for clinical decision-making. ",
            "id": "3914604",
            "problem": "Consider a one-compartment intravenous bolus pharmacokinetic model where the plasma concentration $C(t)$ following a single dose $D$ administered at time $t = 0$ evolves according to the standard mass balance with first-order elimination. The model assumes immediate distribution into a central compartment of volume of distribution $V$, and elimination with first-order rate constant $k$. Under this model, the concentration trajectory is governed by $C(t) = \\dfrac{D}{V} \\exp(-k t)$. Measurements $y_i$ at times $t_i$ are observed with independent, identically distributed Gaussian noise of known variance $\\sigma^2$, that is $y_i = C(t_i) + \\varepsilon_i$ where $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ and are independent across $i$.\n\nYour task is to construct a program that:\n- Generates synthetic measurement data $\\{(t_i, y_i)\\}$ from specified true parameters $(k_\\text{true}, V_\\text{true})$, administered dose $D_\\text{admin}$, and noise standard deviation $\\sigma$, using a fixed pseudorandom seed for reproducibility.\n- Computes the Maximum Likelihood (ML) estimates $(\\hat{k}, \\hat{V})$ by minimizing the negative log-likelihood under the stated Gaussian measurement model. The likelihood should be formulated from first principles using the stated assumptions and the given model $C(t)$, and the optimization should enforce positivity constraints $k > 0$ and $V > 0$.\n- Produces a dosing recommendation to achieve a specified target concentration $C_\\text{target}$ at a specified target time $T_\\text{hit}$ under the model dynamics. The recommendation should be based on the estimated parameters $(\\hat{k}, \\hat{V})$ and should be expressed as a dose $D_\\text{rec}$ in milligrams (mg).\n- Propagates parameter uncertainty to the dosing recommendation by computing an approximate $95\\%$ confidence interval for $D_\\text{rec}$ using the asymptotic normal approximation of the ML estimator and the delta method. Use the Fisher information derived from the sensitivity of the model predictions to $(k,V)$ under the Gaussian noise model to obtain the covariance matrix for $(\\hat{k}, \\hat{V})$.\n\nAll symbols must conform to the following units:\n- $k$ in $\\text{h}^{-1}$,\n- $V$ in $\\text{L}$,\n- $D$ and $D_\\text{rec}$ in $\\text{mg}$,\n- $C(t)$ and $C_\\text{target}$ in $\\text{mg}/\\text{L}$,\n- $t$ and $T_\\text{hit}$ in $\\text{h}$.\n\nUse a single global pseudorandom seed $s$ equal to $s = 2025$ for data generation to ensure reproducibility. The measurement standard deviation $\\sigma$ is known and specified per test case. The optimization should use numerically stable initialization and enforce parameter positivity.\n\nTest Suite:\n- Case $1$ (general case): $k_\\text{true} = 0.15\\,\\text{h}^{-1}$, $V_\\text{true} = 30\\,\\text{L}$, $D_\\text{admin} = 1000\\,\\text{mg}$, sampling times $t = [0.5, 1, 2, 4, 6, 8, 12]\\,\\text{h}$, $\\sigma = 0.6\\,\\text{mg}/\\text{L}$, target $T_\\text{hit} = 6\\,\\text{h}$, $C_\\text{target} = 5\\,\\text{mg}/\\text{L}$.\n- Case $2$ (slow elimination, sparse sampling): $k_\\text{true} = 0.02\\,\\text{h}^{-1}$, $V_\\text{true} = 60\\,\\text{L}$, $D_\\text{admin} = 1000\\,\\text{mg}$, sampling times $t = [2, 8, 24, 48]\\,\\text{h}$, $\\sigma = 0.8\\,\\text{mg}/\\text{L}$, target $T_\\text{hit} = 24\\,\\text{h}$, $C_\\text{target} = 2\\,\\text{mg}/\\text{L}$.\n- Case $3$ (fast elimination, early sampling): $k_\\text{true} = 0.35\\,\\text{h}^{-1}$, $V_\\text{true} = 20\\,\\text{L}$, $D_\\text{admin} = 500\\,\\text{mg}$, sampling times $t = [0.25, 0.5, 1, 2, 3, 4]\\,\\text{h}$, $\\sigma = 0.4\\,\\text{mg}/\\text{L}$, target $T_\\text{hit} = 4\\,\\text{h}$, $C_\\text{target} = 3\\,\\text{mg}/\\text{L}$.\n\nAnswer Specification:\n- For each test case, compute the recommended dose $D_\\text{rec}$ in $\\text{mg}$ using the ML estimates $(\\hat{k}, \\hat{V})$, and compute the lower and upper bounds of the $95\\%$ confidence interval for $D_\\text{rec}$ via the delta method from the parameter covariance.\n- Express the three numbers per case, namely $D_\\text{rec}$, lower bound, and upper bound, as floats in $\\text{mg}$, each rounded to two decimal places.\n\nFinal Output Format:\n- Your program should produce a single line of output containing a comma-separated top-level Python list with three inner lists, one per test case, where each inner list contains the three floats $[D_\\text{rec}, \\text{CI}_\\text{low}, \\text{CI}_\\text{high}]$ in $\\text{mg}$. For example, the output must look like $[[d_1,\\ell_1,u_1],[d_2,\\ell_2,u_2],[d_3,\\ell_3,u_3]]$ where all $d_i$, $\\ell_i$, and $u_i$ are numeric literals rounded to two decimals.",
            "solution": "The user's request is to develop a program for pharmacokinetic parameter estimation and dose recommendation based on a one-compartment model. The problem is scientifically well-grounded, internally consistent, and provides all necessary information for a unique solution. It is therefore deemed valid.\n\n### **1. Problem Validation**\n\n#### **Step 1: Extract Givens**\n\n*   **Pharmacokinetic Model**: $C(t) = \\dfrac{D}{V} \\exp(-k t)$\n    *   $C(t)$: Plasma concentration at time $t$ ($\\text{mg}/\\text{L}$)\n    *   $D$: Administered dose ($\\text{mg}$)\n    *   $V$: Volume of distribution ($\\text{L}$)\n    *   $k$: First-order elimination rate constant ($\\text{h}^{-1}$)\n    *   $t$: Time ($\\text{h}$)\n*   **Measurement Model**: $y_i = C(t_i) + \\varepsilon_i$, where $\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2)$ are independent and identically distributed.\n    *   $y_i$: Measured concentration at time $t_i$\n    *   $\\sigma^2$: Known variance of measurement noise\n*   ** Estimation Task**: Compute Maximum Likelihood (ML) estimates $(\\hat{k}, \\hat{V})$ with positivity constraints $k > 0$ and $V > 0$.\n*   **Dosing Recommendation Task**:\n    *   Compute recommended dose $D_\\text{rec}$ to achieve a target concentration $C_\\text{target}$ at a target time $T_\\text{hit}$.\n*   **Uncertainty Quantification Task**:\n    *   Compute an approximate $95\\%$ confidence interval for $D_\\text{rec}$ using the delta method.\n    *   Use the Fisher Information Matrix derived from model sensitivities to find the covariance matrix of $(\\hat{k}, \\hat{V})$.\n*   **Reproducibility**: Use a global pseudorandom seed $s = 2025$.\n*   **Test Cases**:\n    *   **Case 1**: $k_\\text{true} = 0.15\\,\\text{h}^{-1}$, $V_\\text{true} = 30\\,\\text{L}$, $D_\\text{admin} = 1000\\,\\text{mg}$, $t = [0.5, 1, 2, 4, 6, 8, 12]\\,\\text{h}$, $\\sigma = 0.6\\,\\text{mg}/\\text{L}$, $T_\\text{hit} = 6\\,\\text{h}$, $C_\\text{target} = 5\\,\\text{mg}/\\text{L}$.\n    *   **Case 2**: $k_\\text{true} = 0.02\\,\\text{h}^{-1}$, $V_\\text{true} = 60\\,\\text{L}$, $D_\\text{admin} = 1000\\,\\text{mg}$, $t = [2, 8, 24, 48]\\,\\text{h}$, $\\sigma = 0.8\\,\\text{mg}/\\text{L}$, $T_\\text{hit} = 24\\,\\text{h}$, $C_\\text{target} = 2\\,\\text{mg}/\\text{L}$.\n    *   **Case 3**: $k_\\text{true} = 0.35\\,\\text{h}^{-1}$, $V_\\text{true} = 20\\,\\text{L}$, $D_\\text{admin} = 500\\,\\text{mg}$, $t = [0.25, 0.5, 1, 2, 3, 4]\\,\\text{h}$, $\\sigma = 0.4\\,\\text{mg}/\\text{L}$, $T_\\text{hit} = 4\\,\\text{h}$, $C_\\text{target} = 3\\,\\text{mg}/\\text{L}$.\n\n#### **Step 2: Validate Using Extracted Givens**\n\n*   **Scientifically Grounded**: The one-compartment model is a fundamental and widely used concept in pharmacokinetics. The use of Maximum Likelihood Estimation with a Gaussian noise model is a standard statistical approach for parameter fitting in biomedical systems. The method for uncertainty propagation (asymptotic normality of ML estimators, Fisher Information, and the delta method) is a cornerstone of statistical inference. The problem is scientifically sound.\n*   **Well-Posed**: The problem is well-posed. It provides a specific model, a clear objective (MLE), sufficient data constraints, and a defined set of tasks. The parameters $k$ and $V$ are identifiable from the specified data structure. A unique solution is expected from the optimization procedure, given a stable algorithm and good initialization.\n*   **Objective**: The problem is articulated using precise mathematical and statistical language, free from ambiguity or subjective claims.\n*   **Completeness and Consistency**: The problem is self-contained. All necessary parameters, models, constants, and test data are explicitly provided. There are no contradictions.\n*   **Feasibility**: The parameter values and experimental conditions described in the test cases are physically and biologically plausible for real-world drugs.\n\n#### **Step 3: Verdict and Action**\n\nThe problem is **valid**. A complete, reasoned solution will be provided.\n\n### **2. Principle-Based Solution Design**\n\nThe task requires a multi-step procedure involving data generation, parameter estimation, and prediction with uncertainty quantification.\n\n#### **Part 1: Data Generation**\n\nFor each test case, we generate synthetic concentration measurements. Given the true parameters $(k_\\text{true}, V_\\text{true})$, the administered dose $D_\\text{admin}$, and a set of sampling times $\\{t_i\\}$, the true concentration at each time point is:\n$$ C_\\text{true}(t_i) = \\frac{D_\\text{admin}}{V_\\text{true}} \\exp(-k_\\text{true} t_i) $$\nThe measured concentration $y_i$ is then simulated by adding Gaussian noise:\n$$ y_i = C_\\text{true}(t_i) + \\varepsilon_i, \\quad \\text{where } \\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2) $$\nThis process will be executed using a pseudorandom number generator initialized with the specified seed $s=2025$ to ensure reproducibility.\n\n#### **Part 2: Maximum Likelihood Estimation**\n\nThe parameters $\\theta = (k, V)$ are estimated by maximizing the likelihood of observing the data $\\{y_i\\}$. Given the i.i.d. Gaussian noise model, the likelihood function is:\n$$ L(\\theta | \\{y_i\\}) = \\prod_{i=1}^{N} \\frac{1}{\\sqrt{2\\pi\\sigma^2}} \\exp\\left(-\\frac{(y_i - C(t_i|\\theta))^2}{2\\sigma^2}\\right) $$\nwhere $C(t_i|\\theta) = \\frac{D_\\text{admin}}{V} \\exp(-k t_i)$. Maximizing the likelihood is equivalent to minimizing the negative log-likelihood, $-\\ln L(\\theta)$. Terms that are constant with respect to $\\theta$ can be ignored, which simplifies the objective function to minimizing the sum of squared residuals:\n$$ J(\\theta) = \\sum_{i=1}^{N} \\left(y_i - \\frac{D_\\text{admin}}{V} \\exp(-k t_i)\\right)^2 $$\nTo enforce the positivity constraints $k > 0$ and $V > 0$, we perform the optimization over log-transformed parameters: $\\tilde{k} = \\ln k$ and $\\tilde{V} = \\ln V$. The objective function becomes:\n$$ J(\\tilde{k}, \\tilde{V}) = \\sum_{i=1}^{N} \\left(y_i - \\frac{D_\\text{admin}}{\\exp(\\tilde{V})} \\exp(-\\exp(\\tilde{k}) t_i)\\right)^2 $$\nThis unconstrained nonlinear least-squares problem can be solved using numerical optimization algorithms (e.g., L-BFGS-B from `scipy.optimize`). The resulting ML estimates are $\\hat{k} = \\exp(\\hat{\\tilde{k}})$ and $\\hat{V} = \\exp(\\hat{\\tilde{V}})$. Robust initial guesses for the optimization can be obtained by a log-linear regression of $\\ln y_i$ against $t_i$, since $\\ln C(t) \\approx \\ln(D/V) - k t$.\n\n#### **Part 3: Dosing Recommendation**\n\nUsing the estimated parameters $(\\hat{k}, \\hat{V})$, we calculate the dose $D_\\text{rec}$ required to achieve the target concentration $C_\\text{target}$ at time $T_\\text{hit}$. By rearranging the model equation:\n$$ C_\\text{target} = \\frac{D_\\text{rec}}{\\hat{V}} \\exp(-\\hat{k} T_\\text{hit}) $$\nThe recommended dose is:\n$$ D_\\text{rec} = C_\\text{target} \\hat{V} \\exp(\\hat{k} T_\\text{hit}) $$\nLet us define $D_\\text{rec}$ as a function of the parameters, $g(k,V) = C_\\text{target} V \\exp(k T_\\text{hit})$. The point estimate is $\\hat{D}_\\text{rec} = g(\\hat{k},\\hat{V})$.\n\n#### **Part 4: Uncertainty Propagation via the Delta Method**\n\nThe uncertainty in the estimated parameters $(\\hat{k}, \\hat{V})$ propagates to the recommended dose $D_\\text{rec}$. We quantify this uncertainty by constructing a confidence interval.\n\n1.  **Covariance Matrix of Parameters**: The ML estimator $\\hat{\\theta} = (\\hat{k}, \\hat{V})^T$ is asymptotically normally distributed with a covariance matrix $\\Sigma_{\\theta}$ approximated by the inverse of the Fisher Information Matrix (FIM), $I(\\theta)$, evaluated at the estimates $\\hat{\\theta}$. For the given measurement model, the FIM is:\n    $$ I(\\theta) = \\frac{1}{\\sigma^2} S^T S $$\n    where $S$ is the $N \\times 2$ sensitivity matrix, with entries $S_{ij} = \\frac{\\partial C(t_i)}{\\partial \\theta_j}$. The sensitivities of the model with respect to $k$ and $V$ are:\n    $$ \\frac{\\partial C(t)}{\\partial k} = \\frac{\\partial}{\\partial k}\\left(\\frac{D}{V}e^{-kt}\\right) = -t \\cdot \\frac{D}{V}e^{-kt} = -t \\cdot C(t) $$\n    $$ \\frac{\\partial C(t)}{\\partial V} = \\frac{\\partial}{\\partial V}\\left(\\frac{D}{V}e^{-kt}\\right) = -D e^{-kt}V^{-2} = -\\frac{1}{V} \\cdot \\frac{D}{V}e^{-kt} = -\\frac{C(t)}{V} $$\n    The sensitivity matrix $S$ is computed at each time point $t_i$ using the estimates $(\\hat{k}, \\hat{V})$. The covariance matrix is then $\\hat{\\Sigma}_{\\theta} = I(\\hat{\\theta})^{-1}$.\n\n2.  **Delta Method**: The variance of the recommended dose, $\\text{Var}(D_\\text{rec})$, is approximated using a first-order Taylor expansion (the delta method):\n    $$ \\text{Var}(D_\\text{rec}) \\approx (\\nabla g)^T \\hat{\\Sigma}_{\\theta} (\\nabla g) $$\n    where $\\nabla g$ is the gradient of the dose function $g(k,V)$, evaluated at $(\\hat{k}, \\hat{V})$. The partial derivatives are:\n    $$ \\frac{\\partial g}{\\partial k} = \\frac{\\partial}{\\partial k}\\left(C_\\text{target} V e^{k T_\\text{hit}}\\right) = C_\\text{target} V e^{k T_\\text{hit}} T_\\text{hit} = D_\\text{rec} \\cdot T_\\text{hit} $$\n    $$ \\frac{\\partial g}{\\partial V} = \\frac{\\partial}{\\partial V}\\left(C_\\text{target} V e^{k T_\\text{hit}}\\right) = C_\\text{target} e^{k T_\\text{hit}} = \\frac{D_\\text{rec}}{V} $$\n\n3.  **Confidence Interval**: The standard error of the dose is $\\text{SE}(D_\\text{rec}) = \\sqrt{\\text{Var}(D_\\text{rec})}$. An approximate $95\\%$ confidence interval for $D_\\text{rec}$ is given by:\n    $$ \\text{CI}_{95\\%} = \\left[ \\hat{D}_\\text{rec} - z_{0.975} \\cdot \\text{SE}(D_\\text{rec}), \\quad \\hat{D}_\\text{rec} + z_{0.975} \\cdot \\text{SE}(D_\\text{rec}) \\right] $$\n    where $z_{0.975} \\approx 1.96$ is the $97.5$-th percentile of the standard normal distribution. This provides the lower and upper bounds for the dosing recommendation.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves a pharmacokinetic modeling problem for three test cases.\n    For each case, it:\n    1. Generates synthetic concentration data.\n    2. Estimates model parameters (k, V) using Maximum Likelihood.\n    3. Recommends a dose D_rec to hit a target concentration.\n    4. Computes a 95% confidence interval for D_rec.\n    \"\"\"\n    \n    # Global seed for reproducibility\n    seed = 2025\n    rng = np.random.default_rng(seed)\n\n    # Test suite from the problem statement\n    test_cases = [\n        {\n            \"k_true\": 0.15, \"V_true\": 30.0, \"D_admin\": 1000.0,\n            \"times\": np.array([0.5, 1, 2, 4, 6, 8, 12]),\n            \"sigma\": 0.6, \"T_hit\": 6.0, \"C_target\": 5.0\n        },\n        {\n            \"k_true\": 0.02, \"V_true\": 60.0, \"D_admin\": 1000.0,\n            \"times\": np.array([2, 8, 24, 48]),\n            \"sigma\": 0.8, \"T_hit\": 24.0, \"C_target\": 2.0\n        },\n        {\n            \"k_true\": 0.35, \"V_true\": 20.0, \"D_admin\": 500.0,\n            \"times\": np.array([0.25, 0.5, 1, 2, 3, 4]),\n            \"sigma\": 0.4, \"T_hit\": 4.0, \"C_target\": 3.0\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Unpack case parameters\n        k_true, V_true, D_admin = case[\"k_true\"], case[\"V_true\"], case[\"D_admin\"]\n        times, sigma = case[\"times\"], case[\"sigma\"]\n        T_hit, C_target = case[\"T_hit\"], case[\"C_target\"]\n\n        # --- 1. Data Generation ---\n        def model_concentration(t, k, V, D):\n            # Ensure parameters are positive to avoid math errors\n            if k  0 or V = 0:\n                return np.full_like(t, np.inf)\n            return (D / V) * np.exp(-k * t)\n\n        C_true = model_concentration(times, k_true, V_true, D_admin)\n        noise = rng.normal(0, sigma, size=len(times))\n        y_obs = C_true + noise\n        \n        # Ensure observed data is positive for log-based initial guesses\n        y_obs[y_obs = 0] = 1e-9\n\n        # --- 2. Maximum Likelihood Estimation ---\n        # Objective function for minimization (sum of squared errors)\n        # Using log-transformed parameters to enforce positivity\n        def objective_function(log_params):\n            log_k, log_V = log_params\n            k_est, V_est = np.exp(log_k), np.exp(log_V)\n            C_pred = model_concentration(times, k_est, V_est, D_admin)\n            return np.sum((y_obs - C_pred)**2)\n\n        # Initial guesses from log-linear regression: log(y) vs t\n        # log(y) approx log(D/V) - k*t\n        # This gives slope = -k and intercept = log(D/V)\n        # Handle cases where all y_obs are effectively zero\n        valid_y = y_obs > 1e-6\n        if np.sum(valid_y) > 1:\n            slope, intercept = np.polyfit(times[valid_y], np.log(y_obs[valid_y]), 1)\n            k0 = -slope\n            V0 = D_admin / np.exp(intercept)\n        else: # Fallback if regression is not possible\n            k0 = 0.1\n            V0 = D_admin / (np.mean(y_obs) if np.mean(y_obs) > 0 else 1)\n\n        # Ensure initial guesses are positive\n        k0 = max(1e-6, k0)\n        V0 = max(1e-6, V0)\n        initial_log_params = [np.log(k0), np.log(V0)]\n\n        # Perform optimization\n        opt_result = minimize(\n            objective_function,\n            initial_log_params,\n            method='L-BFGS-B'\n        )\n        hat_log_k, hat_log_V = opt_result.x\n        hat_k, hat_V = np.exp(hat_log_k), np.exp(hat_log_V)\n\n        # --- 3. Dosing Recommendation ---\n        D_rec = C_target * hat_V * np.exp(hat_k * T_hit)\n\n        # --- 4. Uncertainty Propagation ---\n        # Predicted concentrations at ML estimates\n        C_hat = model_concentration(times, hat_k, hat_V, D_admin)\n        \n        # Sensitivities (Jacobian of model output wrt parameters)\n        dC_dk = -times * C_hat\n        dC_dV = -C_hat / hat_V\n        \n        sensitivity_matrix = np.vstack([dC_dk, dC_dV]).T\n        \n        # Fisher Information Matrix\n        FIM = (1 / sigma**2) * (sensitivity_matrix.T @ sensitivity_matrix)\n        \n        # Covariance matrix of parameters (inverse of FIM)\n        try:\n            param_cov_matrix = np.linalg.inv(FIM)\n        except np.linalg.LinAlgError:\n            # If FIM is singular, use pseudo-inverse as a fallback\n            param_cov_matrix = np.linalg.pinv(FIM)\n\n        # Gradient of the dose recommendation function g(k, V)\n        grad_g = np.array([\n            D_rec * T_hit,       # dg/dk\n            D_rec / hat_V        # dg/dV\n        ])\n        \n        # Variance of D_rec via Delta Method\n        var_D_rec = grad_g.T @ param_cov_matrix @ grad_g\n        se_D_rec = np.sqrt(var_D_rec)\n        \n        # 95% Confidence Interval\n        z_score = norm.ppf(0.975)\n        ci_low = D_rec - z_score * se_D_rec\n        ci_high = D_rec + z_score * se_D_rec\n\n        # Store rounded results for this case\n        all_results.append([\n            round(D_rec, 2),\n            round(ci_low, 2),\n            round(ci_high, 2)\n        ])\n        \n    # Format the final output string exactly as specified\n    result_strings = [\n        f\"[{d:.2f},{l:.2f},{u:.2f}]\" for d, l, u in all_results\n    ]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Building on parameter estimation, this final practice implements a complete, closed-loop adaptive control system. You will construct a Model Predictive Controller (MPC) that uses a system model to plan an optimal sequence of future infusion rates, all while respecting clinical constraints on the dosage. This controller is coupled with a Kalman filter, which provides real-time estimates of the drug concentration from noisy measurements, allowing the system to adapt to disturbances and model inaccuracies. This capstone exercise  integrates estimation and optimal control, representing a sophisticated approach to automating and personalizing drug delivery.",
            "id": "3914522",
            "problem": "Consider a single-compartment pharmacokinetic model describing plasma drug concentration under zero-order infusion. The mass balance law states that the rate of change of concentration equals input rate per volume minus first-order elimination. Let $c(t)$ denote plasma concentration in $\\mathrm{mg/L}$, $u(t)$ denote infusion rate in $\\mathrm{mg/hour}$, clearance $CL$ in $\\mathrm{L/hour}$, and volume of distribution $V$ in $\\mathrm{L}$. The continuous-time dynamics are\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t).\n$$\nAssume a sampled-data implementation with sampling interval $T_s$ in $\\mathrm{hour}$ and piecewise-constant infusion $u(t)$ over each interval. The exact discretization yields\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k,\n$$\nwhere $A = \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)$, $B = \\frac{1}{V}\\cdot\\frac{1 - \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)}{\\tfrac{CL}{V}}$, $c_k$ is the concentration at sample $k$, and $u_k$ is the constant infusion rate over $[kT_s,(k+1)T_s)$, with process noise $w_k$ modeled as a zero-mean Gaussian with variance $Q$ in $\\mathrm{(mg/L)^2}$. Measurements of concentration are corrupted by additive zero-mean Gaussian noise:\n$$\ny_k = c_k + v_k,\\quad v_k \\sim \\mathcal{N}(0,R),\n$$\nwith variance $R$ in $\\mathrm{(mg/L)^2}$.\n\nYou will design a Model Predictive Control (MPC) strategy to regulate $c_k$ to a constant reference $r$ in $\\mathrm{mg/L}$ over a prediction horizon of $H$ steps and a control horizon of $H$ steps, subject to box constraints $u_{\\min} \\le u_k \\le u_{\\max}$ for all $k$. At each sampling instant, you will:\n- Use a discrete-time Kalman filter to update the state estimate $\\hat{c}_k$ using the latest measurement $y_k$ and the linear model with parameters $(A_{\\mathrm{model}},B_{\\mathrm{model}})$ computed from $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$.\n- Solve a finite-horizon optimal control problem to compute a sequence of infusion rates $\\{u_k,u_{k+1},\\dots,u_{k+H-1}\\}$ minimizing the quadratic cost\n$$\nJ = \\sum_{i=0}^{H-1} q\\,(c_{k+i+1} - r)^2 + \\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2 + \\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2 + q_f\\,(c_{k+H} - r)^2,\n$$\nwhere $c_{k+i+1}$ are predictions based on $(A_{\\mathrm{model}},B_{\\mathrm{model}})$ and initial condition $\\hat{c}_k$, and $u_{k-1}$ is the previously applied infusion rate. The constants $q,q_f,\\rho,\\eta$ are nonnegative weights. Enforce $u_{\\min} \\le u_{k+i} \\le u_{\\max}$ for all $i=0,\\dots,H-1$.\n- Apply the first computed infusion rate $u_k$ to the plant, observe the next measurement $y_{k+1}$, and repeat for a total of $N$ steps.\n\nAssume that the plant may have parameters $(CL_{\\mathrm{plant}},V_{\\mathrm{plant}})$ that differ from $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$ used by the controller, to test adaptation under model mismatch. Use a fixed random seed for all Gaussian noises to ensure reproducibility. The discrete-time Kalman filter recursion for the scalar case must follow\n$$\n\\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k,\\quad\nP_{k+1|k} = A_{\\mathrm{model}}^2 P_{k|k} + Q,\n$$\n$$\nK_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R},\\quad\n\\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}),\\quad\nP_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k}.\n$$\n\nImplement the MPC optimization using a bound-constrained numerical optimizer. The program must compute and output the applied infusion rate sequence for each test case to demonstrate closed-loop adaptation to measurement updates.\n\nPhysical units: all infusion rates $u_k$ must be computed and reported in $\\mathrm{mg/hour}$. Concentrations are in $\\mathrm{mg/L}$, time in $\\mathrm{hour}$.\n\nTest suite. Use the following three test cases to evaluate different aspects:\n- Case 1 (nominal, sufficient actuation): $N=12$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=4\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=4\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=200\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.01$ $\\mathrm{(mg/L)^2}$, initial $c_0=0\\,\\mathrm{mg/L}$, initial covariance $P_0=1$ $\\mathrm{(mg/L)^2}$, initial previous input $u_{-1}=0\\,\\mathrm{mg/hour}$.\n- Case 2 (tight bounds, saturation): $N=12$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=6\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=6\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=50\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.01$ $\\mathrm{(mg/L)^2}$, initial $c_0=0\\,\\mathrm{mg/L}$, $P_0=1$ $\\mathrm{(mg/L)^2}$, $u_{-1}=0\\,\\mathrm{mg/hour}$.\n- Case 3 (model mismatch and noisier measurements): $N=10$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=7\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=5\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=150\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.09$ $\\mathrm{(mg/L)^2}$, initial $c_0=0\\,\\mathrm{mg/L}$, $P_0=1$ $\\mathrm{(mg/L)^2}$, $u_{-1}=0\\,\\mathrm{mg/hour}$.\n\nRandomness: Use a fixed random seed for all cases so that measurement noise realizations are reproducible. Use independent generators per case initialized by distinct seed values; set seeds as $202311$, $202312$, and $202313$ for Cases 1, 2, and 3 respectively.\n\nYour task. Write a complete program that implements the Kalman filter and MPC described above and computes the applied infusion rate sequence $\\{u_0,u_1,\\dots,u_{N-1}\\}$ for each test case. Express the infusion rates in $\\mathrm{mg/hour}$ rounded to two decimal places.\n\nFinal output format. Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, where each result is itself the list of applied infusion rates for that test case, in the order Case 1, Case 2, Case 3. For example, it should look like \"[[...],[...],[...]]\" with numeric entries rounded to two decimal places and without units in the printed list.",
            "solution": "The user-provided problem has been rigorously validated and is determined to be **valid**. It is a well-posed, scientifically grounded problem in the field of biomedical systems modeling and control, with a complete and consistent set of specifications.\n\nThe problem requires the design and implementation of a Model Predictive Control (MPC) strategy for regulating drug concentration in a single-compartment pharmacokinetic (PK) model. The solution involves a closed-loop simulation where a controller makes decisions based on a mathematical model and imperfect measurements of the true system (the \"plant\"). The core components of the solution are: the plant model, a state estimator (Kalman filter), and the MPC optimizer.\n\n### 1. System Dynamics and Discretization\n\nThe continuous-time dynamics of drug concentration $c(t)$ are given by the linear ordinary differential equation:\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t)\n$$\nwhere $CL$ is the clearance, $V$ is the volume of distribution, and $u(t)$ is the infusion rate. This is a standard single-compartment PK model.\n\nFor implementation in a digital controller, this system is discretized over a sampling interval $T_s$, assuming the control input $u_k$ is constant over each interval $[kT_s, (k+1)T_s)$. The exact solution to the differential equation under this condition yields the discrete-time state-space model:\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k\n$$\nwhere $c_k = c(kT_s)$ is the concentration at sample $k$. The system matrices $A$ and $B$ are functions of the physical parameters:\n$$\nA = \\exp\\!\\left(-\\frac{CL}{V}T_s\\right)\n$$\n$$\nB = \\frac{1 - A}{CL}\n$$\nThe term $w_k$ represents process noise, modeled as a zero-mean Gaussian with variance $Q$. A key aspect of the problem is the potential mismatch between the parameters used by the controller's model $(CL_{\\mathrm{model}}, V_{\\mathrm{model}})$ and the actual plant parameters $(CL_{\\mathrm{plant}}, V_{\\mathrm{plant}})$. Therefore, we will distinguish between $(A_{\\mathrm{model}}, B_{\\mathrm{model}})$ used for prediction and control, and $(A_{\\mathrm{plant}}, B_{\\mathrm{plant}})$ used to simulate the true system response.\n\n### 2. State Estimation using a Kalman Filter\n\nSince the true concentration $c_k$ cannot be measured perfectly, we use a state estimator. The measurements $y_k$ are corrupted by zero-mean Gaussian noise $v_k$ with variance $R$:\n$$\ny_k = c_k + v_k\n$$\nA discrete-time Kalman filter is employed to provide an optimal estimate $\\hat{c}_{k|k}$ of the true state $c_k$ given all measurements up to time $k$. At each step, the filter performs a two-stage recursion:\n\n1.  **Prediction:** The state estimate and its error covariance are projected forward in time using the model dynamics. Given the previous estimate $\\hat{c}_{k|k}$ and the applied control $u_k$:\n    $$\n    \\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k\n    $$\n    $$\n    P_{k+1|k} = A_{\\mathrm{model}}^2\\,P_{k|k} + Q\n    $$\n2.  **Update:** The predicted estimate is corrected using the new measurement $y_{k+1}$. The innovation (measurement residual) is $y_{k+1} - \\hat{c}_{k+1|k}$.\n    $$\n    K_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R} \\quad \\text{(Kalman Gain)}\n    $$\n    $$\n    \\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}) \\quad \\text{(Updated State Estimate)}\n    $$\n    $$\n    P_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k} \\quad \\text{(Updated Covariance)}\n    $$\nThis filter allows the controller to adapt to noise and model mismatch by continuously refining its belief about the system's true state.\n\n### 3. Model Predictive Control (MPC)\n\nAt each sampling instant $k$, the MPC controller solves a finite-horizon optimal control problem to determine the best sequence of inputs. The decision is based on the current state estimate $\\hat{c}_{k|k}$.\n\nThe objective is to find a sequence of control inputs $U_k = \\{u_{k}, u_{k+1}, \\dots, u_{k+H-1}\\}$ that minimizes a quadratic cost function $J$ over a prediction horizon of $H$ steps. The cost function balances several competing goals:\n$$\nJ(U_k) = \\underbrace{\\sum_{i=0}^{H-1} q\\,(\\hat{c}_{k+i+1|k} - r)^2 + q_f\\,(\\hat{c}_{k+H|k} - r)^2}_{\\text{Tracking Error}} + \\underbrace{\\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2}_{\\text{Rate of Change Penalty}} + \\underbrace{\\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2}_{\\text{Input Magnitude Penalty}}\n$$\nwhere:\n- $\\hat{c}_{k+i|k}$ are the states predicted from $\\hat{c}_{k|k}$ using the inputs from $U_k$.\n- $r$ is the desired concentration reference.\n- $u_{k-1}$ is the control action applied in the previous step.\n- $q, q_f, \\rho, \\eta$ are non-negative weighting factors. Term $\\eta > 0$ ensures the problem is strictly convex.\n\nThe optimization is subject to the input constraints $u_{\\min} \\le u_{k+i} \\le u_{\\max}$ for all $i \\in [0, H-1]$. This constrained optimization problem is a Quadratic Program (QP), which can be solved efficiently using numerical methods. We will use a bound-constrained optimizer provided by `scipy.optimize.minimize`.\n\nAfter solving for the optimal sequence $U_k$, only the first element, $u_k$, is applied to the plant. The system then evolves to its next state, a new measurement is taken, and the entire process (estimation and optimization) is repeated at the next sampling instant, $k+1$. This is the principle of a receding horizon controller.\n\n### 4. Closed-Loop Simulation Protocol\n\nThe overall algorithm proceeds as follows for each test case:\n1.  **Initialization:** Set the plant and model parameters $(A, B)$ based on the case-specific $(CL, V, T_s)$. Initialize the true state $c_0$, the state estimate $\\hat{c}_{0|0} = c_0$, its covariance $P_{0|0} = P_0$, and the previous input $u_{-1}$. Initialize a random number generator with the specified seed.\n2.  **Simulation Loop:** For each time step $k$ from $0$ to $N-1$:\n    a.  **MPC Control Calculation:** Using the current estimate $\\hat{c}_{k|k}$ and previous input $u_{k-1}$, solve the constrained optimization problem to find the optimal input sequence $U_k^*$.\n    b.  **Apply Control:** Extract the first input $u_k = U_k^*[0]$ and apply it. Store this value.\n    c.  **Plant Simulation:** The true system state evolves according to $c_{k+1} = A_{\\mathrm{plant}}\\,c_k + B_{\\mathrm{plant}}\\,u_k$. (Since $Q=0$, there is no process noise in this simulation).\n    d.  **Measurement Simulation:** Generate a noisy measurement $y_{k+1} = c_{k+1} + v_{k+1}$, where $v_{k+1} \\sim \\mathcal{N}(0, R)$.\n    e.  **Kalman Filter Update:** Use $u_k$ and $y_{k+1}$ to compute the next state estimate $\\hat{c}_{k+1|k+1}$ and covariance $P_{k+1|k+1}$.\n3.  **Output:** After $N$ steps, the collected sequence of applied inputs $\\{u_0, u_1, \\dots, u_{N-1}\\}$ is formatted and reported.\n\nThis procedure is implemented for each of the three test cases, demonstrating the controller's performance under nominal conditions, with actuator saturation, and with significant model-plant mismatch.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the MPC simulation for all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: Nominal, sufficient actuation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 4.0, \"V_plant\": 40.0,\n            \"CL_model\": 4.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 200.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202311\n        },\n        # Case 2: Tight bounds, saturation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 6.0, \"V_plant\": 40.0,\n            \"CL_model\": 6.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 50.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202312\n        },\n        # Case 3: Model mismatch and noisier measurements\n        {\n            \"N\": 10, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 7.0, \"V_plant\": 40.0,\n            \"CL_model\": 5.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 150.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.09,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202313\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_sequence = run_mpc_simulation(params)\n        all_results.append(result_sequence)\n    \n    # Format the final output string\n    result_strings = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.2f}\" for x in res_list]\n        result_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef get_discrete_params(CL, V, Ts):\n    \"\"\"Computes discrete-time system matrices A and B from continuous-time parameters.\"\"\"\n    if CL == 0:\n        A = 1.0\n        B = Ts / V\n    else:\n        A = np.exp(-CL / V * Ts)\n        B = (1.0 - A) / CL\n    return A, B\n\ndef mpc_cost_function(u_seq, c_hat_k, u_prev, A, B, r, H, q, qf, rho, eta):\n    \"\"\"\n    Calculates the MPC cost function J for a given sequence of control inputs.\n    \"\"\"\n    cost = 0.0\n    c_pred = c_hat_k\n    u_current_prev = u_prev\n\n    for i in range(H):\n        u_current = u_seq[i]\n        c_next_pred = A * c_pred + B * u_current\n        \n        # State tracking cost\n        cost += q * (c_next_pred - r)**2\n        \n        # Input rate-of-change cost\n        cost += rho * (u_current - u_current_prev)**2\n        \n        # Input magnitude cost\n        cost += eta * u_current**2\n        \n        # Update states for the next iteration in the prediction horizon\n        c_pred = c_next_pred\n        u_current_prev = u_current\n    \n    # Terminal state cost\n    cost += qf * (c_pred - r)**2\n    \n    return cost\n\ndef run_mpc_simulation(params):\n    \"\"\"\n    Runs a full closed-loop MPC simulation for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N, H, Ts = params[\"N\"], params[\"H\"], params[\"Ts\"]\n    CL_plant, V_plant = params[\"CL_plant\"], params[\"V_plant\"]\n    CL_model, V_model = params[\"CL_model\"], params[\"V_model\"]\n    r, u_min, u_max = params[\"r\"], params[\"u_min\"], params[\"u_max\"]\n    q, qf, rho, eta = params[\"q\"], params[\"qf\"], params[\"rho\"], params[\"eta\"]\n    Q, R = params[\"Q\"], params[\"R\"]\n    c0, P0, u_m1 = params[\"c0\"], params[\"P0\"], params[\"u_m1\"]\n    seed = params[\"seed\"]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Get discrete-time parameters for plant and model\n    A_plant, B_plant = get_discrete_params(CL_plant, V_plant, Ts)\n    A_model, B_model = get_discrete_params(CL_model, V_model, Ts)\n\n    # Initialize simulation variables\n    c_true_k = c0\n    c_est_kk = c0\n    P_kk = P0\n    u_prev = u_m1\n    applied_inputs = []\n\n    # Main simulation loop\n    for k in range(N):\n        # 1. Solve MPC optimal control problem\n        args_for_cost = (c_est_kk, u_prev, A_model, B_model, r, H, q, qf, rho, eta)\n        bounds = [(u_min, u_max)] * H\n        # Use a reasonable initial guess for the optimizer\n        initial_guess = np.clip([u_prev] * H, u_min, u_max)\n        \n        opt_result = minimize(\n            mpc_cost_function,\n            initial_guess,\n            args=args_for_cost,\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        u_k = opt_result.x[0]\n        applied_inputs.append(u_k)\n\n        # 2. Simulate the plant's evolution\n        # Process noise w_k is zero since Q=0\n        c_true_k_plus_1 = A_plant * c_true_k + B_plant * u_k\n\n        # 3. Simulate the measurement\n        measurement_noise = rng.normal(loc=0.0, scale=np.sqrt(R))\n        y_k_plus_1 = c_true_k_plus_1 + measurement_noise\n\n        # 4. Kalman Filter Update\n        # Prediction step\n        c_est_k_plus_1_k = A_model * c_est_kk + B_model * u_k\n        P_k_plus_1_k = A_model**2 * P_kk + Q\n        \n        # Update step\n        innovation = y_k_plus_1 - c_est_k_plus_1_k\n        K_k_plus_1 = P_k_plus_1_k / (P_k_plus_1_k + R)\n        c_est_k_plus_1_k_plus_1 = c_est_k_plus_1_k + K_k_plus_1 * innovation\n        P_k_plus_1_k_plus_1 = (1 - K_k_plus_1) * P_k_plus_1_k\n\n        # 5. Update states for the next iteration\n        c_true_k = c_true_k_plus_1\n        c_est_kk = c_est_k_plus_1_k_plus_1\n        P_kk = P_k_plus_1_k_plus_1\n        u_prev = u_k\n        \n    return applied_inputs\n\n# Execute the main function when the script is run\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}