{
    "hands_on_practices": [
        {
            "introduction": "设计给药方案的基础是确定在稳态下达到预期治疗效果所需的给药速率。本练习将指导您通过联立单室药代动力学（PK）模型和标准的药效学（PD）$E_{\\max}$模型来计算该速率。通过此练习，您将巩固对剂量、浓度和响应之间基本关系的理解。",
            "id": "3914577",
            "problem": "一种细胞抑制性抗癌药物通过恒速静脉输注给药，并遵循具有线性消除的单室药代动力学 (PK) 模型。设血浆浓度为 $C(t)$，输注速率为 $u$（假定不随时间变化），分布容积为 $V$，清除率为 $CL$。浓度的质量平衡由下式给出\n$$\n\\frac{dC}{dt} \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}\\,C,\\quad t0.\n$$\n药效动力学 (PD) 效应是 $C$ 的单调递增函数，由一个 $E_{\\max}$ 模型描述：\n$$\nR(C) \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C}{EC_{50} + C},\n$$\n其中 $R_{0}$ 是基线效应，$E_{\\max}$ 是药物在基线之上引起的最大效应增量，$EC_{50}$ 是产生最大效应增量一半时的浓度。一个自适应治疗控制器在模型设定的允许范围内指定一个稳态药效动力学目标 $R_{\\text{target}}^{\\ast}$。\n\n给定参数 $R_{0} = 10$ 效应单位，$E_{\\max} = 40$ 效应单位，$EC_{50} = 2\\,\\mathrm{mg/L}$，$CL = 5\\,\\mathrm{L/h}$，以及 $V = 40\\,\\mathrm{L}$，目标 $R_{\\text{target}}^{\\ast} = 30$ 效应单位，确定达到该目标所需的恒定稳态浓度 $C$ 以及在稳态下维持该浓度所需的相应恒定输注速率 $u$。\n\n将浓度以 $\\mathrm{mg/L}$ 表示，输注速率以 $\\mathrm{mg/h}$ 表示。将您的答案四舍五入到三位有效数字。",
            "solution": "用户提供了一个生物医学系统建模问题，具体涉及药代动力学 (PK) 和药效动力学 (PD)。任务是确定达到目标治疗效果所需的稳态药物浓度及相应的输注速率。\n\n首先，对问题陈述进行验证。\n\n**第1步：提取已知条件**\n问题陈述中提供了以下信息：\n-   药代动力学 (PK) 模型：$\\frac{dC}{dt} = \\frac{u}{V} - \\frac{CL}{V}C$，对于 $t0$。\n-   药效动力学 (PD) 模型：$R(C) = R_{0} + \\frac{E_{\\max}C}{EC_{50} + C}$。\n-   模型参数：\n    -   基线效应，$R_{0} = 10$ 效应单位。\n    -   最大药物诱导增量，$E_{\\max} = 40$ 效应单位。\n    -   半最大效应浓度，$EC_{50} = 2\\,\\mathrm{mg/L}$。\n    -   清除率，$CL = 5\\,\\mathrm{L/h}$。\n    -   分布容积，$V = 40\\,\\mathrm{L}$。\n-   目标稳态效应，$R_{\\text{target}}^{\\ast} = 30$ 效应单位。\n-   输注速率 $u$ 和由此产生的浓度 $C$ 将维持在稳态值。\n\n**第2步：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题基于药理学中标准的、成熟的模型。具有线性消除的单室 PK 模型和 $E_{\\max}$ PD 模型是用于描述药物剂量、浓度和效应之间关系的基本概念。这些模型在科学上是有效的，代表了该领域的标准问题。\n-   **问题适定：** 该问题提供了确定唯一解所需的所有必要参数和方程。目标效应 $R_{\\text{target}}^{\\ast} = 30$ 在 PD 模型的可达范围内。最小效应（在 $C=0$ 时）为 $R_0 = 10$，最大理论效应（当 $C \\to \\infty$ 时）为 $R_0 + E_{\\max} = 10 + 40 = 50$。由于 $10  30  50$，因此存在一个唯一的、正的、有限的浓度 $C$ 来产生目标效应。\n-   **客观性：** 问题陈述使用了精确、客观和标准的科学术语，没有歧义或主观性。\n-   **完整性与一致性：** 该问题是自洽的，没有矛盾。给定参数的单位（$mg/L$, $L/h$, $L$）是一致的，并允许以指定单位（$mg/L$ 和 $mg/h$）计算所要求的量。\n\n**第3步：结论与行动**\n该问题被认为是**有效的**。它在科学上是合理的、适定的、客观的和完整的。将构建一个解决方案。\n\n求解过程分为两部分。首先，根据 PD 模型确定达到目标效应所需的稳态浓度 ($C_{ss}$)。其次，根据稳态下的 PK 模型计算维持该浓度所需的恒定输注速率 ($u$)。\n\n**第1部分：确定稳态浓度 ($C_{ss}$)**\n系统处于稳态，这意味着效应 $R(C)$ 等于目标效应 $R_{\\text{target}}^{\\ast}$。设稳态浓度为 $C_{ss}$。我们将 PD 模型方程设为等于目标值：\n$$\nR_{\\text{target}}^{\\ast} \\;=\\; R_{0} \\;+\\; \\frac{E_{\\max}\\,C_{ss}}{EC_{50} + C_{ss}}\n$$\n代入给定的参数值：\n$$\n30 \\;=\\; 10 \\;+\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n我们求解这个关于 $C_{ss}$ 的代数方程。首先，从等式两边减去 $R_{0}=10$：\n$$\n30 - 10 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n$$\n20 \\;=\\; \\frac{40\\,C_{ss}}{2 + C_{ss}}\n$$\n现在，等式两边同时乘以分母 $(2 + C_{ss})$：\n$$\n20(2 + C_{ss}) \\;=\\; 40\\,C_{ss}\n$$\n将左侧的 $20$ 分配进去：\n$$\n40 \\;+\\; 20\\,C_{ss} \\;=\\; 40\\,C_{ss}\n$$\n合并含有 $C_{ss}$ 的项：\n$$\n40 \\;=\\; 40\\,C_{ss} - 20\\,C_{ss}\n$$\n$$\n40 \\;=\\; 20\\,C_{ss}\n$$\n最后，求解 $C_{ss}$：\n$$\nC_{ss} \\;=\\; \\frac{40}{20} \\;=\\; 2\n$$\n所需的稳态浓度为 $C_{ss} = 2\\,\\mathrm{mg/L}$。按要求，四舍五入到三位有效数字，得到 $2.00\\,\\mathrm{mg/L}$。\n\n**第2部分：确定相应的输注速率 ($u$)**\nPK 模型描述了浓度随时间的变化。在稳态下，浓度是恒定的，这意味着其时间导数为零：$\\frac{dC}{dt} = 0$。\n$$\n\\frac{dC}{dt} \\;=\\; 0 \\;=\\; \\frac{u}{V} \\;-\\; \\frac{CL}{V}C_{ss}\n$$\n我们可以重排该方程来求解输注速率 $u$：\n$$\n\\frac{u}{V} \\;=\\; \\frac{CL}{V}C_{ss}\n$$\n两边同乘以 $V$ 得到稳态药代动力学中的一个基本关系：输注速率等于消除速率。\n$$\nu \\;=\\; CL \\cdot C_{ss}\n$$\n现在，我们代入给定的清除率值 ($CL = 5\\,\\mathrm{L/h}$) 和计算出的稳态浓度 ($C_{ss} = 2\\,\\mathrm{mg/L}$):\n$$\nu \\;=\\; (5\\,\\mathrm{L/h}) \\cdot (2\\,\\mathrm{mg/L})\n$$\n$$\nu \\;=\\; 10\\,\\mathrm{mg/h}\n$$\n得到的输注速率为 $u = 10\\,\\mathrm{mg/h}$。四舍五入到三位有效数字，得到 $10.0\\,\\mathrm{mg/h}$。\n\n因此，为达到 30 个单位的目标效应，必须维持 $2.00\\,\\mathrm{mg/L}$ 的稳态血浆浓度，这需要 $10.0\\,\\mathrm{mg/h}$ 的恒定输注速率。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2.00  10.0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "尽管恒速输注是一个有用的理论概念，但许多治疗方案涉及周期性给药。本练习通过推导药物浓度的精确离散时间映射，来探索系统在重复静脉推注下的动态行为。您将进一步分析此映射的稳定性，以理解浓度如何以及为何会收敛到一个可预测的稳态模式。",
            "id": "3914599",
            "problem": "考虑一个单室药代动力学（PK）模型，用于描述血浆药物浓度 $C(t)$，该模型具有一级消除和瞬时快速推注给药的特点。两次给药之间的消除动力学遵循质量平衡和一级动力学：$C(t)$ 的变化率与 $C(t)$ 成正比，比例常数为一个正常数消除速率常数 $k$，因此 $dC/dt = -k C$。给药事件发生在时间点 $\\{t_k\\}_{k \\in \\mathbb{N}}$，具有恒定的给药间隔 $\\Delta t$，其中 $t_{k+1} = t_k + \\Delta t$。在每个给药时间 $t_{k+1}$，进行一次静脉快速推注，导致浓度瞬间跃升，跃升幅度为 $\\Delta_k$（单位为浓度）。设 $C_k$ 表示在时间 $t_k$ 推注后立即的浓度，类似地，$C_{k+1}$ 表示在时间 $t_{k+1}$ 推注后立即的浓度。\n\n仅从以下基本前提开始：在给药事件之间，系统遵循 $dC/dt = -k C$（其中 $k  0$）；在每个给药时间 $t_{k+1}$，推注使浓度瞬间增加 $\\Delta_k$。请推导出一个精确的离散时间映射，该映射描述了在给药间隔 $\\Delta t$ 和推注 $\\Delta_k$ 作用下，如何从 $C_k$ 得到 $C_{k+1}$。然后，施加周期性给药条件，即对所有 $k$ 都有 $\\Delta_k \\equiv \\Delta$，并分析此映射的不动点及其在小扰动下的稳定性。您的分析必须根据映射的线性化以及一级动力学指数解的基本性质，明确地证明其稳定性。\n\n作为最终答案，请提供周期性给药下不动点浓度 $C^{\\ast}$ 的一个单一闭式解析表达式，用 $k$、$\\Delta t$ 和 $\\Delta$ 表示。",
            "solution": "问题陈述经评估有效。它在科学上基于标准的药代动力学建模，问题提出得当，目标明确，且没有内部矛盾或歧义。它代表了在指定领域内一个可形式化的问题。\n\n我们首先分析在单个给药间隔内，即从第 $k$ 次给药时间 $t_k$ 到第 $(k+1)$ 次给药时间 $t_{k+1}$，药物浓度 $C(t)$ 的动力学。设 $C_k$ 表示在时间 $t_k$ 进行快速推注给药后立即的浓度。\n\n在时间区间 $(t_k, t_{k+1})$ 内，没有药物施用，浓度根据一级消除过程衰减，该过程由以下微分方程描述：\n$$\n\\frac{dC}{dt} = -k C(t)\n$$\n其中 $k  0$ 是消除速率常数。这是一个可分离的一阶线性常微分方程。其解可以通过从区间开始时的初始条件积分得到。在时间 $t_k$ 给药后立即的浓度为 $C_k$。因此，对于 $t \\in [t_k, t_{k+1})$，解为：\n$$\nC(t) = C_k \\exp(-k(t-t_k))\n$$\n我们关心的是在下一次给药时间 $t_{k+1}$ 之前的瞬间浓度。我们将这个“谷”浓度表示为 $C_{k+1}^{-}$。我们通过在区间末端，即当 $t \\to t_{k+1}$ 时，计算 $C(t)$ 的值来找到它。鉴于给药间隔是恒定的，$t_{k+1} - t_k = \\Delta t$。\n$$\nC_{k+1}^{-} = C(t_{k+1}) = C_k \\exp(-k(t_{k+1}-t_k)) = C_k \\exp(-k \\Delta t)\n$$\n在时间 $t_{k+1}$，施用了一次静脉快速推注，导致浓度瞬间增加量为 $\\Delta_k$。此次给药后立即的浓度，表示为 $C_{k+1}$，是谷浓度和推注引起的增加量之和：\n$$\nC_{k+1} = C_{k+1}^{-} + \\Delta_k\n$$\n代入 $C_{k+1}^{-}$ 的表达式，我们推导出关联两个连续周期给药后浓度的离散时间映射：\n$$\nC_{k+1} = C_k \\exp(-k \\Delta t) + \\Delta_k\n$$\n这是具有可变给药量 $\\Delta_k$ 的系统的通用精确离散时间映射。\n\n接下来，我们施加周期性给药的条件，即所有给药的推注量恒定，即对于所有 $k \\in \\mathbb{N}$，都有 $\\Delta_k = \\Delta$。该映射简化为一个线性一阶递推关系：\n$$\nC_{k+1} = C_k \\exp(-k \\Delta t) + \\Delta\n$$\n此映射的一个不动点，记为 $C^{\\ast}$，是指从一个周期到下一个周期保持不变的浓度。在不动点处，系统处于稳态，因此 $C_{k+1} = C_k = C^{\\ast}$。我们可以通过将其代入映射来求得 $C^{\\ast}$：\n$$\nC^{\\ast} = C^{\\ast} \\exp(-k \\Delta t) + \\Delta\n$$\n现在，我们求解 $C^{\\ast}$：\n$$\nC^{\\ast} - C^{\\ast} \\exp(-k \\Delta t) = \\Delta\n$$\n$$\nC^{\\ast} (1 - \\exp(-k \\Delta t)) = \\Delta\n$$\n$$\nC^{\\ast} = \\frac{\\Delta}{1 - \\exp(-k \\Delta t)}\n$$\n这就是不动点（稳态峰值）浓度的闭式解析表达式。\n\n最后，我们分析这个不动点的稳定性。对于一个一维离散映射 $x_{k+1} = f(x_k)$，如果映射在不动点处的导数的绝对值小于1，即 $|f'(x^{\\ast})|  1$，则该不动点 $x^{\\ast}$ 是稳定的。\n我们的映射是 $C_{k+1} = f(C_k)$，其中函数 $f(C)$ 由下式给出：\n$$\nf(C) = C \\exp(-k \\Delta t) + \\Delta\n$$\n我们计算 $f(C)$ 关于 $C$ 的导数：\n$$\nf'(C) = \\frac{d}{dC} \\left( C \\exp(-k \\Delta t) + \\Delta \\right) = \\exp(-k \\Delta t)\n$$\n该导数是一个常数，与浓度 $C$ 无关。因此，稳定性条件是 $|f'(C^{\\ast})|  1$，这可以转化为：\n$$\n|\\exp(-k \\Delta t)|  1\n$$\n问题陈述中指出，消除速率常数 $k$ 是正数（$k  0$）。给药间隔 $\\Delta t$ 本身也是正数（$\\Delta t  0$）。因此，指数 $-k \\Delta t$ 严格为负。实指数函数的基本性质决定了，对于任何实数负参数 $x  0$，其值 $\\exp(x)$ 介于0和1之间，即 $0  \\exp(x)  1$。\n将此应用于我们的情况：\n$$\n-k \\Delta t  0 \\implies 0  \\exp(-k \\Delta t)  1\n$$\n由于 $\\exp(-k \\Delta t)$ 是一个小于1的正数，其绝对值就是它本身，并且严格小于1：\n$$\n|\\exp(-k \\Delta t)| = \\exp(-k \\Delta t)  1\n$$\n因此，对于任何有物理意义的参数 $k  0$ 和 $\\Delta t  0$，稳定性条件总是满足的。这意味着不动点 $C^{\\ast}$ 是全局稳定的。任何初始浓度 $C_0$ 都将导致一个浓度序列 $\\{C_k\\}$，该序列会收敛到这个唯一的稳态值 $C^{\\ast}$。项 $\\exp(-k \\Delta t)$ 作为一个收缩因子，确保了初始状态的影响在每个给药周期中逐渐减小，从而导致收敛。",
            "answer": "$$\n\\boxed{\\frac{\\Delta}{1 - \\exp(-k \\Delta t)}}\n$$"
        },
        {
            "introduction": "这项综合性练习整合了估计和最优控制，旨在设计一个真正的自适应治疗系统。您将实现一个与卡尔曼滤波器相结合的模型预测控制器（MPC），在一个模拟环境中调节药物浓度，同时考虑测量噪声和潜在的模型与实际情况不匹配的问题。本练习为您在临床相关背景下应用闭环反馈控制的核心原理提供了动手实践经验。",
            "id": "3914522",
            "problem": "考虑一个描述零阶输注下血浆药物浓度的单室药代动力学模型。质量平衡定律指出，浓度的变化率等于单位体积的输入速率减去一级消除。令 $c(t)$ 表示血浆浓度（单位 $\\mathrm{mg/L}$），$u(t)$ 表示输注速率（单位 $\\mathrm{mg/hour}$），清除率 $CL$（单位 $\\mathrm{L/hour}$），以及分布容积 $V$（单位 $\\mathrm{L}$）。连续时间动态方程为\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t).\n$$\n假设采用采样数据实现，采样间隔为 $T_s$（单位 $\\mathrm{hour}$），并且在每个区间内输注速率 $u(t)$ 是分段恒定的。精确离散化得到\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k,\n$$\n其中 $A = \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)$，$B = \\frac{1}{V}\\cdot\\frac{1 - \\exp\\!\\big(-\\tfrac{CL}{V}T_s\\big)}{\\tfrac{CL}{V}}$，$c_k$ 是在采样点 $k$ 的浓度，$u_k$ 是在 $[kT_s,(k+1)T_s)$ 区间内的恒定输注速率，过程噪声 $w_k$ 被建模为零均值高斯噪声，其方差为 $Q$（单位 $\\mathrm{(mg/L)^2}$）。浓度测量值受到加性零均值高斯噪声的干扰：\n$$\ny_k = c_k + v_k,\\quad v_k \\sim \\mathcal{N}(0,R),\n$$\n方差为 $R$（单位 $\\mathrm{(mg/L)^2}$）。\n\n您将设计一个模型预测控制 (MPC) 策略，在 $H$ 步的预测时域和 $H$ 步的控制时域内，将 $c_k$ 调节至一个恒定的参考值 $r$（单位 $\\mathrm{mg/L}$），并受制于对所有 $k$ 均成立的箱式约束 $u_{\\min} \\le u_k \\le u_{\\max}$。在每个采样时刻，您将：\n- 使用离散时间卡尔曼滤波器，根据最新的测量值 $y_k$ 和由 $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$ 计算出的参数 $(A_{\\mathrm{model}},B_{\\mathrm{model}})$ 构成的线性模型，来更新状态估计值 $\\hat{c}_k$。\n- 求解一个有限时域最优控制问题，计算一个输注速率序列 $\\{u_k,u_{k+1},\\dots,u_{k+H-1}\\}$，以最小化二次型代价函数：\n$$\nJ = \\sum_{i=0}^{H-1} q\\,(c_{k+i+1} - r)^2 + \\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2 + \\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2 + q_f\\,(c_{k+H} - r)^2,\n$$\n其中 $c_{k+i+1}$ 是基于 $(A_{\\mathrm{model}},B_{\\mathrm{model}})$ 和初始条件 $\\hat{c}_k$ 的预测值，$u_{k-1}$ 是前一个时刻施加的输注速率。常数 $q,q_f,\\rho,\\eta$ 是非负权重。对所有 $i=0,\\dots,H-1$ 强制执行 $u_{\\min} \\le u_{k+i} \\le u_{\\max}$。\n- 将计算出的第一个输注速率 $u_k$ 应用于被控对象（plant），观测下一个测量值 $y_{k+1}$，并重复该过程，总共进行 $N$ 步。\n\n假设被控对象（plant）的参数 $(CL_{\\mathrm{plant}},V_{\\mathrm{plant}})$ 可能与控制器使用的模型参数 $(CL_{\\mathrm{model}},V_{\\mathrm{model}})$ 不同，以测试在模型失配情况下的自适应能力。对所有高斯噪声使用固定的随机种子，以确保可复现性。标量情况下的离散时间卡尔曼滤波器递推公式必须遵循：\n$$\n\\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k,\\quad\nP_{k+1|k} = A_{\\mathrm{model}}^2 P_{k|k} + Q,\n$$\n$$\nK_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R},\\quad\n\\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}),\\quad\nP_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k}.\n$$\n\n使用一个带边界约束的数值优化器来实现 MPC 优化。程序必须计算并输出每个测试用例所施加的输注速率序列，以展示对测量更新的闭环自适应能力。\n\n物理单位：所有输注速率 $u_k$ 必须以 $\\mathrm{mg/hour}$ 为单位进行计算和报告。浓度单位为 $\\mathrm{mg/L}$，时间单位为 $\\mathrm{hour}$。\n\n测试套件。使用以下三个测试用例来评估不同方面：\n- 案例 1（标称情况，执行能力充足）：$N=12$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=4\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=4\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=200\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.01$ $\\mathrm{(mg/L)^2}$, 初始 $c_0=0\\,\\mathrm{mg/L}$, 初始协方差 $P_0=1$ $\\mathrm{(mg/L)^2}$, 初始前一输入 $u_{-1}=0\\,\\mathrm{mg/hour}$。\n- 案例 2（严格边界，饱和）：$N=12$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=6\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=6\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=50\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.01$ $\\mathrm{(mg/L)^2}$, 初始 $c_0=0\\,\\mathrm{mg/L}$, $P_0=1$ $\\mathrm{(mg/L)^2}$, $u_{-1}=0\\,\\mathrm{mg/hour}$。\n- 案例 3（模型失配和更强的测量噪声）：$N=10$, $H=4$, $T_s=6\\,\\mathrm{hour}$, $CL_{\\mathrm{plant}}=7\\,\\mathrm{L/hour}$, $V_{\\mathrm{plant}}=40\\,\\mathrm{L}$, $CL_{\\mathrm{model}}=5\\,\\mathrm{L/hour}$, $V_{\\mathrm{model}}=40\\,\\mathrm{L}$, $r=2\\,\\mathrm{mg/L}$, $u_{\\min}=0\\,\\mathrm{mg/hour}$, $u_{\\max}=150\\,\\mathrm{mg/hour}$, $q=1$, $q_f=1$, $\\rho=10^{-3}$, $\\eta=10^{-4}$, $Q=0$ $\\mathrm{(mg/L)^2}$, $R=0.09$ $\\mathrm{(mg/L)^2}$, 初始 $c_0=0\\,\\mathrm{mg/L}$, $P_0=1$ $\\mathrm{(mg/L)^2}$, $u_{-1}=0\\,\\mathrm{mg/hour}$。\n\n随机性：对所有案例使用固定的随机种子，以使测量噪声的实现是可复现的。每个案例使用独立的生成器，并用不同的种子值进行初始化；案例 1、2 和 3 的种子分别设置为 $202311$、$202312$ 和 $202313$。\n\n您的任务。编写一个完整的程序，实现上述的卡尔曼滤波器和 MPC，并为每个测试用例计算所施加的输注速率序列 $\\{u_0,u_1,\\dots,u_{N-1}\\}$。输注速率以 $\\mathrm{mg/hour}$ 为单位表示，并四舍五入到两位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含三个结果，格式为用方括号括起来的逗号分隔列表。每个结果本身是该测试用例所施加的输注速率列表，顺序为案例 1、案例 2、案例 3。例如，输出形式应如 \"[[...],[...],[...]]\"，其中的数值条目四舍五入到两位小数，并且打印的列表中不含单位。",
            "solution": "用户提供的问题已经过严格验证，并被确定为 **有效**。这是一个在生物医学系统建模与控制领域中提法恰当、有科学依据的问题，具有完整且一致的规范。\n\n该问题要求设计并实现一个模型预测控制 (MPC) 策略，用于调节单室药代动力学 (PK) 模型中的药物浓度。解决方案涉及一个闭环仿真，其中控制器基于数学模型和对真实系统（“被控对象”）的不完美测量来做出决策。该方案的核心组成部分是：被控对象模型、状态估计器（卡尔曼滤波器）和 MPC 优化器。\n\n### 1. 系统动态与离散化\n\n药物浓度 $c(t)$ 的连续时间动态由以下线性常微分方程给出：\n$$\n\\frac{dc(t)}{dt} = -\\frac{CL}{V}\\,c(t) + \\frac{1}{V}\\,u(t)\n$$\n其中 $CL$ 是清除率，$V$ 是分布容积，$u(t)$ 是输注速率。这是一个标准的单室 PK 模型。\n\n为了在数字控制器中实现，该系统在采样间隔 $T_s$ 上进行离散化，假设控制输入 $u_k$ 在每个区间 $[kT_s, (k+1)T_s)$ 上是恒定的。在此条件下，该微分方程的精确解可得到离散时间状态空间模型：\n$$\nc_{k+1} = A\\,c_k + B\\,u_k + w_k\n$$\n其中 $c_k = c(kT_s)$ 是在采样点 $k$ 的浓度。系统矩阵 $A$ 和 $B$ 是物理参数的函数：\n$$\nA = \\exp\\!\\left(-\\frac{CL}{V}T_s\\right)\n$$\n$$\nB = \\frac{1 - A}{CL}\n$$\n项 $w_k$ 代表过程噪声，建模为方差为 $Q$ 的零均值高斯分布。问题的一个关键方面是控制器模型使用的参数 $(CL_{\\mathrm{model}}, V_{\\mathrm{model}})$ 与实际被控对象参数 $(CL_{\\mathrm{plant}}, V_{\\mathrm{plant}})$ 之间可能存在失配。因此，我们将区分用于预测和控制的 $(A_{\\mathrm{model}}, B_{\\mathrm{model}})$ 和用于仿真真实系统响应的 $(A_{\\mathrm{plant}}, B_{\\mathrm{plant}})$。\n\n### 2. 使用卡尔曼滤波器的状态估计\n\n由于真实浓度 $c_k$ 无法被完美测量，我们使用一个状态估计器。测量值 $y_k$ 受到方差为 $R$ 的零均值高斯噪声 $v_k$ 的干扰：\n$$\ny_k = c_k + v_k\n$$\n采用离散时间卡尔曼滤波器，以在给定截至时间 $k$ 的所有测量值的情况下，提供真实状态 $c_k$ 的最优估计 $\\hat{c}_{k|k}$。在每一步中，滤波器执行一个两阶段的递推：\n\n1.  **预测：** 使用模型动态将状态估计及其误差协方差向前投射。给定前一个估计 $\\hat{c}_{k|k}$ 和施加的控制 $u_k$：\n    $$\n    \\hat{c}_{k+1|k} = A_{\\mathrm{model}}\\,\\hat{c}_{k|k} + B_{\\mathrm{model}}\\,u_k\n    $$\n    $$\n    P_{k+1|k} = A_{\\mathrm{model}}^2\\,P_{k|k} + Q\n    $$\n2.  **更新：** 使用新的测量值 $y_{k+1}$ 来校正预测的估计。新息（测量残差）为 $y_{k+1} - \\hat{c}_{k+1|k}$。\n    $$\n    K_{k+1} = \\frac{P_{k+1|k}}{P_{k+1|k} + R} \\quad \\text{(卡尔曼增益)}\n    $$\n    $$\n    \\hat{c}_{k+1|k+1} = \\hat{c}_{k+1|k} + K_{k+1}\\,(y_{k+1} - \\hat{c}_{k+1|k}) \\quad \\text{(更新的状态估计)}\n    $$\n    $$\n    P_{k+1|k+1} = (1 - K_{k+1})\\,P_{k+1|k} \\quad \\text{(更新的协方差)}\n    $$\n该滤波器通过不断修正其对系统真实状态的信念，使控制器能够适应噪声和模型失配。\n\n### 3. 模型预测控制 (MPC)\n\n在每个采样时刻 $k$，MPC 控制器求解一个有限时域最优控制问题，以确定最佳的输入序列。该决策基于当前的状态估计 $\\hat{c}_{k|k}$。\n\n目标是找到一个控制输入序列 $U_k = \\{u_{k}, u_{k+1}, \\dots, u_{k+H-1}\\}$，该序列能在 $H$ 步的预测时域内最小化一个二次型代价函数 $J$。该代价函数平衡了几个相互竞争的目标：\n$$\nJ(U_k) = \\underbrace{\\sum_{i=0}^{H-1} q\\,(\\hat{c}_{k+i+1|k} - r)^2 + q_f\\,(\\hat{c}_{k+H|k} - r)^2}_{\\text{跟踪误差}} + \\underbrace{\\sum_{i=0}^{H-1} \\rho\\,(u_{k+i} - u_{k+i-1})^2}_{\\text{变化率惩罚}} + \\underbrace{\\sum_{i=0}^{H-1} \\eta\\,u_{k+i}^2}_{\\text{输入量值惩罚}}\n$$\n其中：\n- $\\hat{c}_{k+i|k}$ 是从 $\\hat{c}_{k|k}$ 使用 $U_k$ 中的输入预测出的状态。\n- $r$ 是期望的浓度参考值。\n- $u_{k-1}$ 是上一步施加的控制动作。\n- $q, q_f, \\rho, \\eta$ 是非负权重因子。项 $\\eta  0$ 确保该问题是严格凸的。\n\n该优化受制于输入约束 $u_{\\min} \\le u_{k+i} \\le u_{\\max}$（对所有 $i \\in [0, H-1]$）。这个约束优化问题是一个二次规划 (QP) 问题，可以使用数值方法高效求解。我们将使用 `scipy.optimize.minimize` 提供的带边界约束的优化器。\n\n在求解出最优序列 $U_k$ 后，仅将其第一个元素 $u_k$ 应用于被控对象。然后系统演化到其下一个状态，获取新的测量值，并在下一个采样时刻 $k+1$ 重复整个过程（估计和优化）。这就是滚动时域控制器的原理。\n\n### 4. 闭环仿真协议\n\n对于每个测试用例，总体算法流程如下：\n1.  **初始化：** 基于特定案例的 $(CL, V, T_s)$ 设置被控对象和模型的参数 $(A, B)$。初始化真实状态 $c_0$、状态估计 $\\hat{c}_{0|0} = c_0$、其协方差 $P_{0|0} = P_0$ 以及前一输入 $u_{-1}$。使用指定的种子初始化一个随机数生成器。\n2.  **仿真循环：** 对于从 $0$ 到 $N-1$ 的每个时间步 $k$：\n    a. **MPC 控制计算：** 使用当前估计 $\\hat{c}_{k|k}$ 和前一输入 $u_{k-1}$，求解约束优化问题以找到最优输入序列 $U_k^*$。\n    b. **施加控制：** 提取第一个输入 $u_k = U_k^*[0]$ 并施加。存储该值。\n    c. **被控对象仿真：** 真实系统状态根据 $c_{k+1} = A_{\\mathrm{plant}}\\,c_k + B_{\\mathrm{plant}}\\,u_k$ 演化。（由于 $Q=0$，此仿真中没有过程噪声）。\n    d. **测量仿真：** 生成带噪测量值 $y_{k+1} = c_{k+1} + v_{k+1}$，其中 $v_{k+1} \\sim \\mathcal{N}(0, R)$。\n    e. **卡尔曼滤波器更新：** 使用 $u_k$ 和 $y_{k+1}$ 来计算下一个状态估计 $\\hat{c}_{k+1|k+1}$ 和协方差 $P_{k+1|k+1}$。\n3.  **输出：** 在 $N$ 步之后，收集到的已施加输入序列 $\\{u_0, u_1, \\dots, u_{N-1}\\}$ 被格式化并报告。\n\n对三个测试用例中的每一个都实施此过程，以展示控制器在标称条件、执行器饱和以及存在显著模型-被控对象失配情况下的性能。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to run the MPC simulation for all test cases and print the results.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: Nominal, sufficient actuation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 4.0, \"V_plant\": 40.0,\n            \"CL_model\": 4.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 200.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202311\n        },\n        # Case 2: Tight bounds, saturation\n        {\n            \"N\": 12, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 6.0, \"V_plant\": 40.0,\n            \"CL_model\": 6.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 50.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.01,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202312\n        },\n        # Case 3: Model mismatch and noisier measurements\n        {\n            \"N\": 10, \"H\": 4, \"Ts\": 6.0,\n            \"CL_plant\": 7.0, \"V_plant\": 40.0,\n            \"CL_model\": 5.0, \"V_model\": 40.0,\n            \"r\": 2.0, \"u_min\": 0.0, \"u_max\": 150.0,\n            \"q\": 1.0, \"qf\": 1.0, \"rho\": 1e-3, \"eta\": 1e-4,\n            \"Q\": 0.0, \"R\": 0.09,\n            \"c0\": 0.0, \"P0\": 1.0, \"u_m1\": 0.0,\n            \"seed\": 202313\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_sequence = run_mpc_simulation(params)\n        all_results.append(result_sequence)\n    \n    # Format the final output string\n    result_strings = []\n    for res_list in all_results:\n        formatted_list = [f\"{x:.2f}\" for x in res_list]\n        result_strings.append(f\"[{','.join(formatted_list)}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\ndef get_discrete_params(CL, V, Ts):\n    \"\"\"Computes discrete-time system matrices A and B from continuous-time parameters.\"\"\"\n    if CL == 0:\n        A = 1.0\n        B = Ts / V\n    else:\n        A = np.exp(-CL / V * Ts)\n        B = (1.0 - A) / CL\n    return A, B\n\ndef mpc_cost_function(u_seq, c_hat_k, u_prev, A, B, r, H, q, qf, rho, eta):\n    \"\"\"\n    Calculates the MPC cost function J for a given sequence of control inputs.\n    \"\"\"\n    cost = 0.0\n    c_pred = c_hat_k\n    u_current_prev = u_prev\n\n    for i in range(H):\n        u_current = u_seq[i]\n        c_next_pred = A * c_pred + B * u_current\n        \n        # State tracking cost\n        cost += q * (c_next_pred - r)**2\n        \n        # Input rate-of-change cost\n        cost += rho * (u_current - u_current_prev)**2\n        \n        # Input magnitude cost\n        cost += eta * u_current**2\n        \n        # Update states for the next iteration in the prediction horizon\n        c_pred = c_next_pred\n        u_current_prev = u_current\n    \n    # Terminal state cost\n    cost += qf * (c_pred - r)**2\n    \n    return cost\n\ndef run_mpc_simulation(params):\n    \"\"\"\n    Runs a full closed-loop MPC simulation for a single test case.\n    \"\"\"\n    # Unpack parameters\n    N, H, Ts = params[\"N\"], params[\"H\"], params[\"Ts\"]\n    CL_plant, V_plant = params[\"CL_plant\"], params[\"V_plant\"]\n    CL_model, V_model = params[\"CL_model\"], params[\"V_model\"]\n    r, u_min, u_max = params[\"r\"], params[\"u_min\"], params[\"u_max\"]\n    q, qf, rho, eta = params[\"q\"], params[\"qf\"], params[\"rho\"], params[\"eta\"]\n    Q, R = params[\"Q\"], params[\"R\"]\n    c0, P0, u_m1 = params[\"c0\"], params[\"P0\"], params[\"u_m1\"]\n    seed = params[\"seed\"]\n\n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Get discrete-time parameters for plant and model\n    A_plant, B_plant = get_discrete_params(CL_plant, V_plant, Ts)\n    A_model, B_model = get_discrete_params(CL_model, V_model, Ts)\n\n    # Initialize simulation variables\n    c_true_k = c0\n    c_est_kk = c0\n    P_kk = P0\n    u_prev = u_m1\n    applied_inputs = []\n\n    # Main simulation loop\n    for k in range(N):\n        # 1. Solve MPC optimal control problem\n        args_for_cost = (c_est_kk, u_prev, A_model, B_model, r, H, q, qf, rho, eta)\n        bounds = [(u_min, u_max)] * H\n        # Use a reasonable initial guess for the optimizer\n        initial_guess = np.clip([u_prev] * H, u_min, u_max)\n        \n        opt_result = minimize(\n            mpc_cost_function,\n            initial_guess,\n            args=args_for_cost,\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n        \n        u_k = opt_result.x[0]\n        applied_inputs.append(u_k)\n\n        # 2. Simulate the plant's evolution\n        # Process noise w_k is zero since Q=0\n        c_true_k_plus_1 = A_plant * c_true_k + B_plant * u_k\n\n        # 3. Simulate the measurement\n        measurement_noise = rng.normal(loc=0.0, scale=np.sqrt(R))\n        y_k_plus_1 = c_true_k_plus_1 + measurement_noise\n\n        # 4. Kalman Filter Update\n        # Prediction step\n        c_est_k_plus_1_k = A_model * c_est_kk + B_model * u_k\n        P_k_plus_1_k = A_model**2 * P_kk + Q\n        \n        # Update step\n        innovation = y_k_plus_1 - c_est_k_plus_1_k\n        K_k_plus_1 = P_k_plus_1_k / (P_k_plus_1_k + R)\n        c_est_k_plus_1_k_plus_1 = c_est_k_plus_1_k + K_k_plus_1 * innovation\n        P_k_plus_1_k_plus_1 = (1 - K_k_plus_1) * P_k_plus_1_k\n\n        # 5. Update states for the next iteration\n        c_true_k = c_true_k_plus_1\n        c_est_kk = c_est_k_plus_1_k_plus_1\n        P_kk = P_k_plus_1_k_plus_1\n        u_prev = u_k\n        \n    return applied_inputs\n\n# Execute the main function when the script is run\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}