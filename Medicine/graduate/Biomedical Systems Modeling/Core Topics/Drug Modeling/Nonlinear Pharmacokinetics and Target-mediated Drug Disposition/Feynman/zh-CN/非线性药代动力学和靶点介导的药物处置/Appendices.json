{
    "hands_on_practices": [
        {
            "introduction": "第一个练习将带你深入靶标介导的药物处置（TMDD）的核心：药物与其靶标之间的平衡结合。通过运用质量作用定律和质量守恒定律，你将推导出游离药物浓度、结合亲和力 ($K_d$) 与靶标占有率 ($\\theta$) 之间的基本关系。这个推导过程将帮助你深刻理解，在TMDD系统中，为什么给药总量与药理效应之间的关系会发生偏移。",
            "id": "3911837",
            "problem": "一种单克隆抗体通过可逆的一对一结合，在中央室中与一个单价的细胞表面靶标结合。设游离药物浓度为 $C$，游离靶标浓度为 $R$，药物-靶标复合物浓度为 $DR$。总靶标浓度为 $R_{\\text{tot}}$，占有率定义为 $\\theta = DR / R_{\\text{tot}}$。该结合在平衡状态下由解离常数 $K_{d}$ 表征，根据质量作用定律定义为 $K_{d} = \\frac{C R}{DR}$。假设达到瞬时平衡，且 $R_{\\text{tot}}$ 是有限的，并可能与临床相关药物浓度相当，这反映了靶介导的药物处置（TMDD）。\n\n仅从质量作用定律和靶标的质量守恒出发，推导达到 $\\theta = 0.5$ 所需的游离药物浓度 $C$ 的表达式，用 $K_{d}$ 和 $R_{\\text{tot}}$ 表示。请以单一的闭合形式表达式给出最终结果。未提供数值；请以符号形式表示最终答案。\n\n在您的解题过程中，从基本定义开始，证明每一步的合理性，并使用平衡结合框架简要解释与靶标可忽略不计（非TMDD）的情景相比，TMDD如何改变总给药浓度与效应之间的关系。最终答案中不要包含单位。",
            "solution": "该问题经评估是有效的。它在科学上基于受体药理学和药代动力学的原理，特别是靶介导的药物处置（TMDD）。问题是适定的、自洽的，并使用了精确、客观的语言。所有必要的定义和条件都已提供，足以推导出一个唯一且有意义的解。\n\n推导过程从问题陈述中提供的基本原理开始。\n\n平衡状态下的三个核心关系是：\n1.  质量作用定律，定义了解离常数 $K_d$：\n    $$K_d = \\frac{C R}{DR}$$\n    其中 $C$ 是游离药物浓度，$R$ 是游离靶标浓度，$DR$ 是药物-靶标复合物浓度。\n\n2.  靶标的质量守恒，将总靶标浓度 $R_{\\text{tot}}$ 与其游离形式和结合形式联系起来：\n    $$R_{\\text{tot}} = R + DR$$\n\n3.  占有率 $\\theta$ 的定义：\n    $$\\theta = \\frac{DR}{R_{\\text{tot}}}$$\n\n目标是求出达到占有率 $\\theta = 0.5$ 所需的游离药物浓度 $C$。\n\n首先，我们对指定条件 $\\theta = 0.5$ 使用占有率的定义：\n$$\\frac{DR}{R_{\\text{tot}}} = 0.5$$\n这意味着药物-靶标复合物的浓度是总靶标浓度的一半：\n$$DR = 0.5 R_{\\text{tot}}$$\n\n接下来，我们使用靶标的质量守恒来求出在此条件下的游离靶标浓度 $R$。我们重排守恒方程以解出 $R$：\n$$R = R_{\\text{tot}} - DR$$\n代入上一步中 $DR$ 的表达式：\n$$R = R_{\\text{tot}} - 0.5 R_{\\text{tot}} = 0.5 R_{\\text{tot}}$$\n这个结果表明，当一半的靶标被占据时，另一半必然是游离的。\n\n现在，我们将 $DR$ 和 $R$ 的表达式代入质量作用定律方程：\n$$K_d = \\frac{C R}{DR} = \\frac{C (0.5 R_{\\text{tot}})}{0.5 R_{\\text{tot}}}$$\n项 $0.5 R_{\\text{tot}}$ 同时出现在分子和分母中，因此可以消去，前提是 $R_{\\text{tot}} \\neq 0$，这是使问题有意义的物理上的必然要求。\n$$K_d = C$$\n因此，达到 $50\\%$ 靶标占有率所需的游离药物浓度恰好等于解离常数 $K_d$。$C$ 的表达式不显式包含 $R_{\\text{tot}}$，这是受体理论的一个基本结果。对于给定的占有率水平，所需的游离浓度仅取决于结合亲和力（$K_d$），而不取决于靶标的总量。\n\n为了解释TMDD如何改变总药物浓度与效应之间的关系，我们必须考虑总药物浓度 $C_{\\text{tot}}$。在中央室中，总药物是游离药物与结合到靶标上的药物之和：\n$$C_{\\text{tot}} = C + DR$$\n我们现在可以求出达到 $\\theta = 0.5$ 所需的总药物浓度。根据我们上面的推导，在 $\\theta = 0.5$ 时：\n-   所需的游离药物浓度为 $C = K_d$。\n-   结合药物的浓度为 $DR = 0.5 R_{\\text{tot}}$。\n\n将这些代入 $C_{\\text{tot}}$ 的方程中：\n$$C_{\\text{tot}} \\left( \\text{at } \\theta = 0.5 \\right) = K_d + 0.5 R_{\\text{tot}}$$\n\n现在，我们可以将TMDD情景与非TMDD（或简单受体）情景进行比较。\n-   **非TMDD情景**：在这种情况下，假定总靶标浓度与药物浓度相比可以忽略不计（$R_{\\text{tot}} \\approx 0$）。结合到靶标上的药物量不显著，因此 $DR \\approx 0$。所以，总药物浓度约等于游离药物浓度：$C_{\\text{tot}} \\approx C$。要达到 $50\\%$ 的占有率，需要游离浓度 $C=K_d$，这意味着总浓度 $C_{\\text{tot}} \\approx K_d$。在这个经典模型中，产生半数最大效应（或占有率）的浓度 $EC_{50}$ 等于 $K_d$。\n\n-   **TMDD情景**：在这种情况下，$R_{\\text{tot}}$ 是有限且显著的。达到 $50\\%$ 占有率所需的总药物浓度是 $C_{\\text{tot}} = K_d + 0.5 R_{\\text{tot}}$。结合的药物 $DR$ 充当一个“汇”，有效地从游离池中移除了大量的药物。为了达到所需的游离浓度 $C=K_d$，必须给予足够的药物，既要使这个“汇”饱和（达到 $0.5 R_{\\text{tot}}$ 的水平），又要建立平衡的游离浓度。\n\n其结果是浓度-效应曲线发生移动。如果药理效应与占有率成正比，并且绘制的是效应与*总*药物浓度的关系图，那么表观 $EC_{50}$ 将不再是 $K_d$，而是 $K_d + 0.5 R_{\\text{tot}}$。这导致曲线向右移动，表明表观效价降低。这种移动的幅度与总靶标浓度 $R_{\\text{tot}}$ 成正比。",
            "answer": "$$\\boxed{K_d}$$"
        },
        {
            "introduction": "从静态平衡转向动态行为，这个实践将挑战你在真实的多剂量给药方案下，对一个完整的TMDD模型进行仿真。这项计算练习旨在帮助你直接观察TMDD的关键现象，例如靶标耗竭及其对药物蓄积（以曲线下面积 $AUC$ 衡量）的影响。理解这些动态过程对于为表现出TMDD特性的药物设计有效的治疗策略至关重要。",
            "id": "3911866",
            "problem": "考虑一个在多次静脉推注给药下，具有受体周转的目标介导的药物处置 (TMDD) 模型。假设一个体积为 $V$ (升) 的单室充分混合的中央室，药物浓度为 $D$ (毫克/升)，游离靶标/受体浓度为 $R$ (毫克/升)，药物-靶标复合物浓度为 $C$ (毫克/升)。该系统的演化遵循质量作用结合动力学和带有受体周转的线性消除。设药物在时间 $t = 0, \\tau, 2\\tau, \\dots, (N-1)\\tau$ 以剂量为 $\\text{dose}$ (毫克) 的瞬时推注方式给药，其中 $\\tau$ 是给药间隔 (小时)，$N$ 是给药次数。每次给药后，药物浓度立即增加 $\\Delta D = \\text{dose}/V$。\n\n在给药瞬间之间，控制系统的常微分方程 (ODE) 如下：\n$$\\frac{dD}{dt} = -k_{\\text{el}} D - k_{\\text{on}} D R + k_{\\text{off}} C,$$\n$$\\frac{dR}{dt} = k_{\\text{r}} - k_{\\text{deg}} R - k_{\\text{on}} D R + k_{\\text{off}} C,$$\n$$\\frac{dC}{dt} = k_{\\text{on}} D R - k_{\\text{off}} C - k_{\\text{int}} C,$$\n其中单位 $k_{\\text{el}}$ 为 $\\text{h}^{-1}$，$k_{\\text{on}}$ 为 $\\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$，$k_{\\text{off}}$ 为 $\\text{h}^{-1}$，$k_{\\text{int}}$ 为 $\\text{h}^{-1}$，$k_{\\text{r}}$ 为 $\\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$，$k_{\\text{deg}}$ 为 $\\text{h}^{-1}$。在无药物的情况下，基线游离靶标为 $R_0 = k_{\\text{r}}/k_{\\text{deg}}$。\n\n定义以下量来量化多次给药下的累积和靶标耗竭：\n- 药物浓度的给药间隔内曲线下面积 (AUC) 为 $AUC_i = \\int_{t_i}^{t_{i}+\\tau} D(t)\\, dt$，其中 $t_i = i \\tau$。\n- TMDD 下的累积比是无量纲量 $AR_{\\text{TMDD}} = AUC_{N-1} / AUC_0$，用于比较最后一个间隔与第一个间隔。\n- 最后一次给药前的给药前谷值游离靶标浓度为 $R_{\\text{trough,last}} = R(t_N^-)$，其中 $t_N = N \\tau$，上标 $-$ 表示给药前瞬间的值。耗竭分数为无量纲量 $\\Delta_{\\text{dep}} = 1 - R_{\\text{trough,last}} / R_0$。\n- 为与无靶标结合的系统进行比较，考虑一个具有消除作用且采用相同推注给药方案的单室线性模型，由 $\\frac{dD}{dt} = -k_{\\text{el}} D$ 给出，具有相同的 $V$、$\\text{dose}$、$\\tau$ 和 $N$。设 $AR_{\\text{lin}}$ 是为此线性比较模型使用第一个和最后一个间隔的 AUC 定义的类似累积比。将累积差异量化为 $\\Delta AR = AR_{\\text{TMDD}} - AR_{\\text{lin}}$。\n\n从基本的质量作用动力学和受体周转出发，实现一个确定性的数值模拟，该模拟能够：\n1. 演化 TMDD 系统，使其跨越 $N$ 个给药间隔，并在每个给药时间进行瞬时推注添加，然后计算 $AUC_0$、$AUC_{N-1}$、$AR_{\\text{TMDD}}$ 和 $R_{\\text{trough,last}}$。\n2. 在相同的给药方案下演化线性比较模型，并计算 $AR_{\\text{lin}}$。\n3. 计算耗竭分数 $\\Delta_{\\text{dep}}$ 和累积差异 $\\Delta AR$。\n\n将 $AR_{\\text{TMDD}}$、$\\Delta_{\\text{dep}}$ 和 $\\Delta AR$ 表示为四舍五入到三位小数的无量纲浮点数。\n\n您的程序必须为每个测试用例生成一行输出，包含一个三元素列表 $[AR_{\\text{TMDD}}, \\Delta_{\\text{dep}}, \\Delta AR]$，并将所有测试用例聚合到一个由方括号括起来的逗号分隔的列表中。例如，最终输出格式应为 $[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots]$ 的形式，其中每个 $a_i$、$b_i$ 和 $c_i$ 是四舍五入到三位小数的浮点数。\n\n测试套件 (每个用例列出 $(V,\\ \\text{dose},\\ \\tau,\\ N,\\ k_{\\text{el}},\\ k_{\\text{on}},\\ k_{\\text{off}},\\ k_{\\text{int}},\\ k_{\\text{r}},\\ k_{\\text{deg}})$):\n- 用例 1 (中等结合，中等周转，典型间隔): ($3\\ \\text{L}$, $30\\ \\text{mg}$, $24\\ \\text{h}$, $6$, $0.05\\ \\text{h}^{-1}$, $0.05\\ \\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$, $0.1\\ \\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.05\\ \\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$, $0.05\\ \\text{h}^{-1}$).\n- 用例 2 (弱结合，预计靶标耗竭最小): ($3\\ \\text{L}$, $30\\ \\text{mg}$, $24\\ \\text{h}$, $6$, $0.05\\ \\text{h}^{-1}$, $0.005\\ \\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.05\\ \\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$, $0.05\\ \\text{h}^{-1}$).\n- 用例 3 (强结合，受体周转慢): ($3\\ \\text{L}$, $30\\ \\text{mg}$, $24\\ \\text{h}$, $6$, $0.03\\ \\text{h}^{-1}$, $0.1\\ \\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$, $0.05\\ \\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.01\\ \\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$, $0.01\\ \\text{h}^{-1}$).\n- 用例 4 (长给药间隔，预计累积最小): ($3\\ \\text{L}$, $30\\ \\text{mg}$, $72\\ \\text{h}$, $6$, $0.05\\ \\text{h}^{-1}$, $0.05\\ \\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$, $0.1\\ \\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.05\\ \\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$, $0.05\\ \\text{h}^{-1}$).\n- 用例 5 (高剂量，潜在的靶标饱和和显著耗竭): ($3\\ \\text{L}$, $90\\ \\text{mg}$, $24\\ \\text{h}$, $6$, $0.05\\ \\text{h}^{-1}$, $0.05\\ \\text{L}\\,\\text{mg}^{-1}\\,\\text{h}^{-1}$, $0.1\\ \\text{h}^{-1}$, $0.5\\ \\text{h}^{-1}$, $0.05\\ \\text{mg}\\,\\text{L}^{-1}\\,\\text{h}^{-1}$, $0.05\\ \\text{h}^{-1}$).\n\n所有计算在内部都应使用指定的物理单位表示，但所要求的输出 $AR_{\\text{TMDD}}$、$\\Delta_{\\text{dep}}$ 和 $\\Delta AR$ 必须是无量纲的，并打印为四舍五入到三位小数。您的程序应生成一行输出，包含一个由方括号括起来的逗号分隔列表形式的结果 (例如, $[[result1a,result1b,result1c],[result2a,result2b,result2c],\\dots]$)。",
            "solution": "用户提供了一个有效的问题陈述，详细描述了一个具有多次静脉推注给药的目标介导的药物处置 (TMDD) 模型。任务是执行数值模拟以量化药物累积和靶标耗竭。该问题在科学上是合理的，定义明确，并包含进行唯一、可验证的求解所需的所有信息。\n\n问题的核心是求解一个由三个耦合的非线性常微分方程 (ODE) 组成的系统，该系统描述了药物浓度 ($D$)、游离靶标浓度 ($R$) 和药物-靶标复合物浓度 ($C$) 的时间演化。方程如下：\n$$\n\\frac{dD}{dt} = -k_{\\text{el}} D - k_{\\text{on}} D R + k_{\\text{off}} C\n$$\n$$\n\\frac{dR}{dt} = k_{\\text{r}} - k_{\\text{deg}} R - k_{\\text{on}} D R + k_{\\text{off}} C\n$$\n$$\n\\frac{dC}{dt} = k_{\\text{on}} D R - k_{\\text{off}} C - k_{\\text{int}} C\n$$\n\n模拟必须考虑多次给药方案，其中 $N$ 次瞬时推注剂量（剂量为 $\\text{dose}$）在时间 $t = 0, \\tau, 2\\tau, \\dots, (N-1)\\tau$ 施用。\n\n模拟过程如下：\n1.  **初始条件**：在时间 $t=0$（首次给药前），系统假定处于无药物的稳态。这意味着药物和复合物的浓度为零：$D(0^-) = 0$ 和 $C(0^-) = 0$。游离靶标浓度处于其基线水平，由其合成和降解的平衡决定：$R(0^-) = R_0 = k_{\\text{r}}/k_{\\text{deg}}$。因此，初始状态向量为 $[D_0, R_0, C_0] = [0, k_{\\text{r}}/k_{\\text{deg}}, 0]$。\n\n2.  **给药间隔的迭代模拟**：模拟在 $N$ 个给药间隔内迭代进行。对于从 $0$ 到 $N-1$ 的每个间隔 $i$：\n    a.  **给药事件**：在间隔开始时，$t_i = i\\tau$，施用推注剂量。这导致中央室（体积为 $V$）中的药物浓度瞬时增加：$D(t_i^+) = D(t_i^-) + \\text{dose}/V$。靶标 $R$ 和复合物 $C$ 的浓度不受剂量的直接影响，并保持连续。\n    b.  **数值积分**：在时间跨度 $[t_i, t_i + \\tau]$ 上对 ODE 系统进行数值求解。此积分步骤的初始条件是给药后的浓度 $[D(t_i^+), R(t_i), C(t_i)]$。我们将使用 `scipy.integrate` 库中的 `solve_ivp` 函数，这是解决 ODE 系统初值问题的强大工具。在间隔结束时系统的最终状态 $[D((t_i+\\tau)^-), R((t_i+\\tau)^-), C((t_i+\\tau)^-)]$，将作为下一个间隔的给药前状态。\n\n3.  **计算输出量**：\n    a.  **曲线下面积 ($AUC_i$)**：药物浓度的 AUC，$AUC_i = \\int_{i\\tau}^{(i+1)\\tau} D(t) dt$，针对第一个 ($i=0$) 和最后一个 ($i=N-1$) 间隔进行计算。为实现这一点，我们指示 `solve_ivp` 求解器返回一个密集输出。这使我们能够评估在间隔内大量时间点上的药物浓度 $D(t)$。然后使用 `numpy.trapz` 实现的梯形法则精确地近似该积分。\n    b.  **TMDD 累积比 ($AR_{\\text{TMDD}}$)**：这被计算为最后一个间隔的 AUC 与第一个间隔的 AUC 之比：$AR_{\\text{TMDD}} = AUC_{N-1} / AUC_0$。\n    c.  **给药前谷值靶标浓度 ($R_{\\text{trough,last}}$)**：这是模拟结束时（时间 $t = N\\tau$）的游离靶标浓度。它对应于最后一次积分步骤中 $R$ 的最终值。问题陈述中将其称为 $R(t_N^-)$。\n    d.  **耗竭分数 ($\\Delta_{\\text{dep}}$)**：这量化了谷值靶标浓度相对于其基线值的降低：$\\Delta_{\\text{dep}} = 1 - R_{\\text{trough,last}} / R_0$。\n    e.  **线性累积比 ($AR_{\\text{lin}}$)**：对于线性比较模型 $\\frac{dD}{dt} = -k_{\\text{el}} D$，在 $N$ 次给药后的累积比可以解析推导。第 $N$ 个间隔与第一个间隔的 AUC 之比等于这些间隔开始时的峰值浓度之比。该比率由几何级数的和给出：\n        $$\n        AR_{\\text{lin}} = \\frac{1 - e^{-Nk_{\\text{el}}\\tau}}{1 - e^{-k_{\\text{el}}\\tau}}\n        $$\n        使用该解析公式比模拟线性模型更准确、更高效。\n    f.  **累积差异 ($\\Delta AR$)**：这是 TMDD 模型和线性模型的累积比之间的差异：$\\Delta AR = AR_{\\text{TMDD}} - AR_{\\text{lin}}$。\n\n最终的实现将根据此过程处理每个测试用例，计算所需的三个无量纲量（$AR_{\\text{TMDD}}$、$\\Delta_{\\text{dep}}$、$\\Delta AR$），将它们四舍五入到三位小数，并按规定格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the TMDD problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # (V, dose, tau, N, k_el, k_on, k_off, k_int, k_r, k_deg)\n        (3.0, 30.0, 24.0, 6, 0.05, 0.05, 0.1, 0.5, 0.05, 0.05),\n        (3.0, 30.0, 24.0, 6, 0.05, 0.005, 0.5, 0.5, 0.05, 0.05),\n        (3.0, 30.0, 24.0, 6, 0.03, 0.1, 0.05, 0.5, 0.01, 0.01),\n        (3.0, 30.0, 72.0, 6, 0.05, 0.05, 0.1, 0.5, 0.05, 0.05),\n        (3.0, 90.0, 24.0, 6, 0.05, 0.05, 0.1, 0.5, 0.05, 0.05),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        V, dose, tau, N, k_el, k_on, k_off, k_int, k_r, k_deg = case\n\n        # Define the system of ODEs for the TMDD model\n        def tmdd_model(t, y, k_el, k_on, k_off, k_int, k_r, k_deg):\n            D, R, C = y\n            dD_dt = -k_el * D - k_on * D * R + k_off * C\n            dR_dt = k_r - k_deg * R - k_on * D * R + k_off * C\n            dC_dt = k_on * D * R - k_off * C - k_int * C\n            return [dD_dt, dR_dt, dC_dt]\n\n        # Baseline receptor concentration\n        R0 = k_r / k_deg if k_deg > 0 else 0.0\n\n        # Initial conditions: drug-free steady state\n        y0 = np.array([0.0, R0, 0.0])\n        \n        # Dose amount added to concentration\n        delta_D = dose / V\n\n        auc_0 = 0.0\n        auc_N_minus_1 = 0.0\n        \n        y_current = y0.copy()\n\n        for i in range(N):\n            # Apply bolus dose\n            y_current[0] += delta_D\n            \n            # Time span for the current interval\n            t_start = i * tau\n            t_end = (i + 1) * tau\n            t_span = [t_start, t_end]\n\n            # Solve ODEs for the interval\n            sol = solve_ivp(\n                fun=tmdd_model,\n                t_span=t_span,\n                y0=y_current,\n                args=(k_el, k_on, k_off, k_int, k_r, k_deg),\n                method='Radau', # Suitable for stiff systems\n                dense_output=True,\n                atol=1e-9,  # Absolute tolerance\n                rtol=1e-6   # Relative tolerance\n            )\n            \n            # Update state for the next interval\n            y_current = sol.y[:, -1]\n            \n            # Calculate AUC for the first and last intervals\n            if i == 0 or i == N - 1:\n                # Use dense output for accurate AUC calculation\n                t_eval = np.linspace(t_start, t_end, 500)\n                D_values = sol.sol(t_eval)[0]\n                auc = np.trapz(D_values, t_eval)\n                \n                if i == 0:\n                    auc_0 = auc\n                if i == N - 1:\n                    auc_N_minus_1 = auc\n\n        # Final trough receptor concentration\n        R_trough_last = y_current[1]\n\n        # Calculate AR_TMDD\n        AR_TMDD = auc_N_minus_1 / auc_0 if auc_0 > 0 else 0.0\n        \n        # Calculate Depletion Fraction\n        delta_dep = 1.0 - R_trough_last / R0 if R0 > 0 else 1.0\n\n        # Calculate AR_lin (analytical formula)\n        # AR_lin = (1 - exp(-N*k_el*tau)) / (1 - exp(-k_el*tau))\n        exp_term = np.exp(-k_el * tau)\n        if np.abs(1.0 - exp_term)  1e-9: # Avoid division by zero if k_el*tau is very small\n            AR_lin = float(N)\n        else:\n            AR_lin = (1.0 - np.exp(-N * k_el * tau)) / (1.0 - exp_term)\n\n        # Calculate Accumulation Difference\n        delta_AR = AR_TMDD - AR_lin\n        \n        # Round results to three decimal places\n        result_triplet = [\n            round(AR_TMDD, 3),\n            round(delta_dep, 3),\n            round(delta_AR, 3)\n        ]\n        all_results.append(result_triplet)\n    \n    # Format the final output string\n    # e.g., [[1.234,0.567,-0.123],[...]]\n    output_str = \"[\" + \",\".join(f\"[{a},{b},{c}]\" for a, b, c in all_results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "建立和仿真模型只是过程的一部分，深入理解其属性同等重要。最后的这个练习将介绍局部敏感性分析，这是一种强大的技术，用于量化模型预测值如何响应其参数的变化。这项实践将使你掌握识别影响药物暴露（例如 $AUC$）和靶标结合（例如 $\\theta_{max}$）的关键参数的技能，这是模型优化和实验设计的关键一步。",
            "id": "3911846",
            "problem": "计算在静脉快速推注给药条件下，一个机制性靶点介导的药物处置系统的归一化局部灵敏度。使用一个单室药物模型，该模型包含单一药物-靶点结合位点和受体周转。药物以中央室中的初始浓度形式给药，而在无药物存在的情况下，受体以稳态存在并进行周转。基于质量作用动力学和一级受体周转推导出的模型方程如下，分别对应游离药物浓度 $C(t)$、游离受体浓度 $R(t)$ 和药物-受体复合物浓度 $RC(t)$：\n$$\n\\frac{dC}{dt} \\;=\\; -\\,k_{el}\\,C \\;-\\; k_{on}\\,C\\,R \\;+\\; k_{off}\\,RC,\n$$\n$$\n\\frac{dR}{dt} \\;=\\; k_{syn} \\;-\\; k_{deg}\\,R \\;-\\; k_{on}\\,C\\,R \\;+\\; k_{off}\\,RC,\n$$\n$$\n\\frac{dRC}{dt} \\;=\\; k_{on}\\,C\\,R \\;-\\; \\left(k_{off}+k_{int}\\right)\\,RC.\n$$\n其中，$k_{on}$ 是结合速率常数，$k_{off}$ 是解离速率常数，$k_{int}$ 是复合物的内化速率，$k_{el}$ 是一级药物消除速率常数，$k_{syn}$ 是受体零级合成速率，$k_{deg}$ 是受体一级降解速率常数。初始条件为\n$$\nC(0) \\;=\\; \\frac{D}{V_c}, \\quad R(0) \\;=\\; R_{tot}, \\quad RC(0) \\;=\\; 0,\n$$\n其中 $k_{syn} = k_{deg}\\,R_{tot}$ 以确保在无药物时受体处于稳态。解离常数定义为 $K_d = \\frac{k_{off}}{k_{on}}$。\n\n在有限观测区间 $[0,T]$ 上，从模型中定义两个标量输出：\n- 游离药物的浓度-时间曲线下面积 (AUC)：\n$$\nAUC \\;=\\; \\int_{0}^{T} C(t)\\,dt.\n$$\n- 最大受体占据分数：\n$$\n\\theta_{max} \\;=\\; \\max_{t \\in [0,T]} \\left( \\frac{RC(t)}{R(t)+RC(t)} \\right).\n$$\n\n对于标量输出 $J \\in \\{AUC,\\;\\theta_{max}\\}$ 和模型参数 $p \\in \\{k_{on},\\,k_{off},\\,k_{int},\\,R_{tot},\\,K_d\\}$，归一化局部灵敏度定义为\n$$\nS_p(J) \\;=\\; \\frac{p}{J}\\,\\frac{\\partial J}{\\partial p},\n$$\n该值可通过对数参数空间中的中心有限差分进行数值近似：\n$$\nS_p(J) \\;\\approx\\; \\frac{J\\!\\left(p(1+\\varepsilon)\\right) - J\\!\\left(p(1-\\varepsilon)\\right)}{2\\,\\varepsilon\\,J(p)},\n$$\n其中 $\\varepsilon$ 是一个小的相对步长。\n\n您的任务是实现一个程序，该程序能够：\n- 对下面的每个测试用例，在 $[0,T]$（其中 $T = 240$ 小时）上模拟常微分方程组，使用数值稳定的求解器和足够精细的评估网格来准确计算 $AUC$ 和 $\\theta_{max}$。\n- 使用中心相对扰动（$\\varepsilon = 10^{-4}$）计算 $p \\in \\{k_{on},\\,k_{off},\\,k_{int},\\,R_{tot},\\,K_d\\}$ 的归一化局部灵敏度 $S_p(AUC)$ 和 $S_p(\\theta_{max})$。在计算 $S_{K_d}(\\cdot)$ 时，改变 $K_d$ 同时保持 $k_{on}$ 不变，并调整 $k_{off}$ 以使扰动后的值满足 $k_{off} = k_{on}\\,K_d$。对于其他灵敏度，仅改变指定参数并保持其他参数不变。对于 $R_{tot}$ 的扰动，确保 $k_{syn} = k_{deg}\\,R_{tot}$ 得到一致的更新。\n- 对于每个测试用例中的每个输出 $J \\in \\{AUC,\\;\\theta_{max}\\}$，在集合 $\\{k_{on},\\,k_{off},\\,k_{int},\\,R_{tot},\\,K_d\\}$ 中，识别出具有最大归一化局部灵敏度绝对值的参数索引，索引映射如下\n$$\n0 \\mapsto k_{on},\\quad 1 \\mapsto k_{off},\\quad 2 \\mapsto k_{int},\\quad 3 \\mapsto R_{tot},\\quad 4 \\mapsto K_d.\n$$\n\n全程使用的物理和数值单位：\n- 时间 $t$ 单位为小时。\n- 浓度 $C, R, RC, R_{tot}$ 单位为纳摩尔/升。\n- $k_{on}$ 单位为 $\\mathrm{(nM\\cdot h)^{-1}}$；$k_{off}, k_{int}, k_{el}, k_{deg}$ 单位为 $\\mathrm{h^{-1}}$；$K_d$ 单位为纳摩尔/升；$D$ 单位为纳摩尔；$V_c$ 单位为升。\n- 曲线下面积 $AUC$ 应以 $\\mathrm{nM\\cdot h}$ 计算。您无需打印 $AUC$；只需在内部计算即可。\n- 受体占据分数是无量纲的。\n\n测试套件。对于所有测试用例，除非被覆盖，否则使用以下基线参数：\n- $k_{on} = 0.1 \\;\\mathrm{(nM\\cdot h)^{-1}}$，\n- $K_d = 1.0 \\;\\mathrm{nM}$，\n- $k_{off} = k_{on}\\,K_d$，\n- $k_{int} = 0.3 \\;\\mathrm{h^{-1}}$，\n- $R_{tot} = 50.0 \\;\\mathrm{nM}$，\n- $k_{deg} = 0.05 \\;\\mathrm{h^{-1}}$，\n- $k_{el} = 0.05 \\;\\mathrm{h^{-1}}$，\n- $D = 300.0 \\;\\mathrm{nmol}$，\n- $V_c = 3.0 \\;\\mathrm{L}$，\n- $T = 240.0 \\;\\mathrm{h}$。\n\n提供以下四个测试用例，每个用例通过指定的覆盖项与基线有所不同：\n- 测试用例 1（基线/理想路径）：无覆盖项。\n- 测试用例 2（低受体边界）：$R_{tot} = 1.0 \\;\\mathrm{nM}$。\n- 测试用例 3（弱结合边缘）：$K_d = 10.0 \\;\\mathrm{nM}$ 且在基线 $k_{on}$ 下 $k_{off} = k_{on}\\,K_d$。\n- 测试用例 4（快速内化边缘）：$k_{int} = 1.0 \\;\\mathrm{h^{-1}}$。\n\n最终输出规范：\n- 对于每个测试用例，返回一个包含两个整数的列表 $[i_{AUC},\\,i_{\\theta}]$，其中 $i_{AUC}$ 是 $|S_p(AUC)|$ 值最大的参数索引，$i_{\\theta}$ 是 $|S_p(\\theta_{max})|$ 值最大的参数索引，使用上述定义中的索引映射。\n- 您的程序应生成单行输出，其中包含四个双整数列表的结果，以逗号分隔，并用方括号括起来，例如\n`[ [0,2],[\\dots],[\\dots],[\\dots] ]`。\n不应打印任何其他文本。角度单位不适用于此问题。在内部将任何分数量表示为十进制浮点数；打印的结果仅为索引（整数）。",
            "solution": "我们从质量作用动力学和受体周转开始。在充分混合的中央室中，游离药物浓度 $C(t)$ 通过一级速率常数 $k_{el}$ 的线性消除以及与游离受体 $R(t)$ 的二级动力学结合而发生变化。结合步骤使游离药物减少 $k_{on}\\,C\\,R$，而药物-受体复合物 $RC(t)$ 的解离则通过 $k_{off}\\,RC$ 恢复游离药物。因此，\n$$\n\\frac{dC}{dt} \\;=\\; -k_{el}\\,C \\;-\\; k_{on}\\,C\\,R \\;+\\; k_{off}\\,RC.\n$$\n游离受体以零级速率 $k_{syn}$ 合成，并以一级速率 $k_{deg}\\,R$ 降解。药物-受体结合以 $k_{on}\\,C\\,R$ 的速率消耗游离受体，而复合物解离以 $k_{off}\\,RC$ 的速率恢复游离受体。因此，\n$$\n\\frac{dR}{dt} \\;=\\; k_{syn} \\;-\\; k_{deg}\\,R \\;-\\; k_{on}\\,C\\,R \\;+\\; k_{off}\\,RC.\n$$\n复合物以 $k_{on}\\,C\\,R$ 的速率形成，并通过解离和内化而损失，得到\n$$\n\\frac{dRC}{dt} \\;=\\; k_{on}\\,C\\,R \\;-\\; \\left(k_{off} + k_{int}\\right)\\,RC.\n$$\n在无药物的基线条件下，我们通过 $k_{syn} = k_{deg}\\,R_{tot}$ 施加受体稳态，这样在无药物时 $R(t) \\to R_{tot}$。解离常数定义为 $K_d = \\frac{k_{off}}{k_{on}}$。\n\n输出定义为 $AUC = \\int_{0}^{T} C(t)\\,dt$ 和 $\\theta_{max} = \\max_{t\\in[0,T]} \\left( \\frac{RC(t)}{R(t)+RC(t)} \\right)$。为计算这些值，我们使用能处理刚性问题的求解器和密集的评估网格，在 $[0,T]$ 上对常微分方程组进行数值积分以确保准确性。$AUC$ 通过在求解器输出网格上使用梯形法则进行近似，而 $\\theta_{max}$ 则通过在同一网格上评估 $\\theta(t)$ 并取其最大值来计算。\n\n对于标量输出 $J$ 和参数 $p$，归一化局部灵敏度\n$$\nS_p(J) \\;=\\; \\frac{p}{J}\\,\\frac{\\partial J}{\\partial p}\n$$\n通过具有小相对步长 $\\varepsilon$ 的中心有限差分进行近似：\n$$\nS_p(J) \\;\\approx\\; \\frac{J\\!\\left(p(1+\\varepsilon)\\right) - J\\!\\left(p(1-\\varepsilon)\\right)}{2\\,\\varepsilon\\,J(p)}.\n$$\n该表达式源于对数参数空间中的链式法则，\n$$\n\\frac{\\partial \\log J}{\\partial \\log p} \\;=\\; \\frac{p}{J}\\,\\frac{\\partial J}{\\partial p},\n$$\n以及 $\\partial \\log J / \\partial \\log p$ 的中心差分近似。\n\n在计算 $S_{K_d}(J)$ 时，我们将 $K_d$ 视为一个独立参数，保持 $k_{on}$ 不变，并对扰动值强制执行 $k_{off} = k_{on}\\,K_d$。然后，根据链式法则，\n$$\n\\frac{\\partial J}{\\partial K_d}\\bigg|_{k_{on}} \\;=\\; \\frac{\\partial J}{\\partial k_{off}}\\,\\frac{\\partial k_{off}}{\\partial K_d}\\bigg|_{k_{on}} \\;=\\; k_{on}\\,\\frac{\\partial J}{\\partial k_{off}},\n$$\n这意味着对于 $k_{on}$ 固定的严格局部变化，有\n$$\nS_{K_d}(J) \\;=\\; \\frac{K_d}{J}\\,\\frac{\\partial J}{\\partial K_d} \\;=\\; \\frac{k_{off}}{J}\\,\\frac{\\partial J}{\\partial k_{off}} \\;=\\; S_{k_{off}}(J)\n$$\n。在数值上，通过直接扰动 $K_d$ 并使用 $k_{off} = k_{on}\\,K_d$ 来计算 $S_{K_d}(J)$，会强制执行这种关系。\n\n算法步骤：\n- 固定数值单位：时间单位为小时，浓度单位为纳摩尔/升，速率常数单位为指定单位，$AUC$ 单位为 $\\mathrm{nM\\cdot h}$。\n- 对于每个测试用例，组合带覆盖项的参数。设置初始条件 $C(0) = D/V_c$，$R(0) = R_{tot}$，$RC(0) = 0$ 以及 $k_{syn} = k_{deg}\\,R_{tot}$。\n- 使用像 Livermore Solver for Ordinary Differential Equations (LSODA) 这样的刚性求解器，在 $[0,T]$ 的均匀评估网格上积分常微分方程组，并采用严格的容差以确保准确的灵敏度评估。从解中计算 $AUC$ 和 $\\theta_{max}$。\n- 对于集合 $\\{k_{on},\\,k_{off},\\,k_{int},\\,R_{tot},\\,K_d\\}$ 中的每个参数 $p$，使用中心差分（$\\varepsilon = 10^{-4}$）计算 $S_p(AUC)$ 和 $S_p(\\theta_{max})$。对于 $R_{tot}$，根据扰动后的 $R_{tot}$ 一致地更新 $k_{syn}$。对于 $K_d$，保持 $k_{on}$ 固定，并对 $p(1+\\varepsilon)$ 和 $p(1-\\varepsilon)$ 两种扰动都设置 $k_{off} = k_{on}\\,K_d$。\n- 分别对 $AUC$ 和 $\\theta_{max}$，使用映射 $0 \\mapsto k_{on}$，$1 \\mapsto k_{off}$，$2 \\mapsto k_{int}$，$3 \\mapsto R_{tot}$，$4 \\mapsto K_d$，确定五个灵敏度中绝对值最大的索引 $i_{AUC}$ 和 $i_{\\theta}$。\n- 将四个测试用例的结果汇总成一个包含四个双整数列表的单一列表并打印。\n\n主导模式的解释：\n- 在具有中到高受体丰度和相当高亲和力（$K_d = 1.0$）的基线情况下，靶点介导的药物处置对药物清除有显著贡献。因此，$AUC$ 通常对控制靶点介导消除能力和通量的参数（如 $R_{tot}$ 和 $k_{int}$）最为敏感，而一旦结合不是速率限制步骤，则对 $k_{on}$ 的敏感性较低。最大受体占据率 $\\theta_{max}$ 往往对结合亲和力（由 $k_{off}$ 或等效地由 $K_d$ 编码）最为敏感，特别是当初始药物浓度不远高于 $R_{tot}$ 时。\n- 在低受体边界（$R_{tot} = 1.0$）下，靶点介导的途径饱和程度最低；$AUC$ 对靶点相关参数的敏感性降低，而更多地受到线性消除 $k_{el}$（在此不属于灵敏度分析集合）的影响，因此如果结合动力学仍然瞬时调节 $C(t)$，指定参数中最大的灵敏度可能会转向 $k_{off}$ 或 $k_{on}$。$\\theta_{max}$ 仍然主要由亲和力驱动。\n- 在弱结合边缘（$K_d = 10.0$）下，占据率较低，$\\theta_{max}$ 对 $k_{off}$（根据链式法则，也同样对 $K_d$）变得非常敏感。由于复合物形成较少，$AUC$ 对靶点相关参数的灵敏度减小。\n- 在快速内化边缘（$k_{int} = 1.0$）下，内化作用显著增加了从复合物中靶点介导的药物移除，放大了 $AUC$ 对 $k_{int}$ 以及可能对 $R_{tot}$ 的灵敏度。如果内化作用迅速耗尽 $RC$ 并使平衡向结合动力学方向移动，$\\theta_{max}$ 可能对 $k_{on}$ 变得更加敏感。\n\n该程序实现了这些计算，并为每个测试用例，以要求的格式输出了 $AUC$ 和 $\\theta_{max}$ 的最大绝对归一化局部灵敏度所对应的参数索引。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef tmdd_rhs(t, y, params):\n    C, R, RC = y\n    k_on = params['k_on']\n    k_off = params['k_off']\n    k_int = params['k_int']\n    k_el = params['k_el']\n    k_deg = params['k_deg']\n    k_syn = params['k_syn']\n    dCdt = -k_el * C - k_on * C * R + k_off * RC\n    dRdt = k_syn - k_deg * R - k_on * C * R + k_off * RC\n    dRCdt = k_on * C * R - (k_off + k_int) * RC\n    return [dCdt, dRdt, dRCdt]\n\ndef simulate_and_outputs(par, T=240.0, n_eval=4001):\n    # Build consistent parameter set including k_syn, initial conditions\n    params = par.copy()\n    params['k_off'] = params['k_on'] * params['K_d'] if 'K_d' in params and ('k_off' not in params or params['k_off'] is None) else params['k_off']\n    params['k_syn'] = params['k_deg'] * params['R_tot']\n    C0 = params['Dose'] / params['V_c']\n    y0 = [C0, params['R_tot'], 0.0]\n    t_eval = np.linspace(0.0, T, n_eval)\n    sol = solve_ivp(\n        fun=lambda t, y: tmdd_rhs(t, y, params),\n        t_span=(0.0, T),\n        y0=y0,\n        method='LSODA',\n        t_eval=t_eval,\n        rtol=1e-9,\n        atol=1e-12,\n        vectorized=False\n    )\n    t = sol.t\n    C = sol.y[0]\n    R = sol.y[1]\n    RC = sol.y[2]\n    # AUC via trapezoidal rule\n    auc = np.trapz(C, t)\n    # Occupancy fraction and its max\n    denom = R + RC\n    # Safeguard against numerical zero denominators\n    theta = np.where(denom > 0.0, RC / denom, 0.0)\n    theta_max = np.max(theta)\n    return auc, theta_max\n\ndef compute_normalized_sensitivities(base_params, eps=1e-4):\n    # Parameters of interest and mapping indices\n    # 0 -> k_on, 1 -> k_off, 2 -> k_int, 3 -> R_tot, 4 -> K_d\n    # Compute baseline outputs\n    auc0, th0 = simulate_and_outputs(base_params)\n    # Sensitivity arrays\n    s_auc = np.zeros(5, dtype=float)\n    s_th = np.zeros(5, dtype=float)\n\n    # Helper to perturb and compute outputs\n    def J_for_params(mod_params):\n        return simulate_and_outputs(mod_params)\n\n    # k_on sensitivity (vary k_on only)\n    for idx, pname in enumerate(['k_on', 'k_off', 'k_int', 'R_tot', 'K_d']):\n        # Build +/- perturbations\n        p0 = None\n        if pname == 'k_on':\n            p0 = base_params['k_on']\n            for sign in [+1, -1]:\n                scale = 1.0 + sign * eps\n                par_mod = base_params.copy()\n                par_mod['k_on'] = p0 * scale\n                # keep k_off fixed for this sensitivity\n                par_mod['k_off'] = base_params['k_off']\n                # ensure K_d matches base unless needed elsewhere; here K_d is not used by simulate if k_off provided\n                auc, th = J_for_params(par_mod)\n                if sign > 0:\n                    auc_p, th_p = auc, th\n                else:\n                    auc_m, th_m = auc, th\n            s_auc[idx] = (auc_p - auc_m) / (2.0 * eps * auc0)\n            s_th[idx] = (th_p - th_m) / (2.0 * eps * th0 if th0 != 0.0 else 1.0)\n\n        elif pname == 'k_off':\n            p0 = base_params['k_off']\n            for sign in [+1, -1]:\n                scale = 1.0 + sign * eps\n                par_mod = base_params.copy()\n                par_mod['k_off'] = p0 * scale\n                # keep k_on fixed; K_d not used in simulate if k_off given\n                auc, th = J_for_params(par_mod)\n                if sign > 0:\n                    auc_p, th_p = auc, th\n                else:\n                    auc_m, th_m = auc, th\n            s_auc[idx] = (auc_p - auc_m) / (2.0 * eps * auc0)\n            s_th[idx] = (th_p - th_m) / (2.0 * eps * th0 if th0 != 0.0 else 1.0)\n\n        elif pname == 'k_int':\n            p0 = base_params['k_int']\n            for sign in [+1, -1]:\n                scale = 1.0 + sign * eps\n                par_mod = base_params.copy()\n                par_mod['k_int'] = p0 * scale\n                auc, th = J_for_params(par_mod)\n                if sign > 0:\n                    auc_p, th_p = auc, th\n                else:\n                    auc_m, th_m = auc, th\n            s_auc[idx] = (auc_p - auc_m) / (2.0 * eps * auc0)\n            s_th[idx] = (th_p - th_m) / (2.0 * eps * th0 if th0 != 0.0 else 1.0)\n\n        elif pname == 'R_tot':\n            p0 = base_params['R_tot']\n            for sign in [+1, -1]:\n                scale = 1.0 + sign * eps\n                par_mod = base_params.copy()\n                par_mod['R_tot'] = p0 * scale\n                # k_syn must be updated inside simulate via k_deg*R_tot; no need to set here\n                auc, th = J_for_params(par_mod)\n                if sign > 0:\n                    auc_p, th_p = auc, th\n                else:\n                    auc_m, th_m = auc, th\n            s_auc[idx] = (auc_p - auc_m) / (2.0 * eps * auc0)\n            s_th[idx] = (th_p - th_m) / (2.0 * eps * th0 if th0 != 0.0 else 1.0)\n\n        elif pname == 'K_d':\n            # Vary K_d while holding k_on fixed and updating k_off = k_on * K_d\n            p0 = base_params['K_d']\n            for sign in [+1, -1]:\n                scale = 1.0 + sign * eps\n                par_mod = base_params.copy()\n                par_mod['K_d'] = p0 * scale\n                par_mod['k_off'] = par_mod['k_on'] * par_mod['K_d']\n                auc, th = J_for_params(par_mod)\n                if sign > 0:\n                    auc_p, th_p = auc, th\n                else:\n                    auc_m, th_m = auc, th\n            s_auc[idx] = (auc_p - auc_m) / (2.0 * eps * auc0)\n            s_th[idx] = (th_p - th_m) / (2.0 * eps * th0 if th0 != 0.0 else 1.0)\n\n    return s_auc, s_th\n\ndef solve():\n    # Baseline parameters\n    base = {\n        'k_on': 0.1,      # (nM*h)^-1\n        'K_d': 1.0,       # nM\n        'k_off': 0.1 * 1.0, # will be kept in base for sensitivities\n        'k_int': 0.3,     # h^-1\n        'R_tot': 50.0,    # nM\n        'k_deg': 0.05,    # h^-1\n        'k_el': 0.05,     # h^-1\n        'Dose': 300.0,    # nmol\n        'V_c': 3.0        # L\n    }\n    # Test cases with overrides\n    tests = []\n    # Test 1: baseline\n    tests.append(base.copy())\n    # Test 2: low receptor boundary\n    t2 = base.copy()\n    t2['R_tot'] = 1.0\n    tests.append(t2)\n    # Test 3: weak binding edge\n    t3 = base.copy()\n    t3['K_d'] = 10.0\n    t3['k_off'] = t3['k_on'] * t3['K_d']\n    tests.append(t3)\n    # Test 4: fast internalization edge\n    t4 = base.copy()\n    t4['k_int'] = 1.0\n    tests.append(t4)\n\n    results = []\n    for params in tests:\n        # Ensure k_off consistency if not overridden\n        if 'k_off' not in params or params['k_off'] is None:\n            params['k_off'] = params['k_on'] * params['K_d']\n        s_auc, s_th = compute_normalized_sensitivities(params, eps=1e-4)\n        # Indices of maximum absolute sensitivities\n        i_auc = int(np.argmax(np.abs(s_auc)))\n        i_th = int(np.argmax(np.abs(s_th)))\n        results.append([i_auc, i_th])\n\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}