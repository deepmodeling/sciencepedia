{
    "hands_on_practices": [
        {
            "introduction": "Before we can model vast, interconnected networks, we must master their fundamental building blocks. This first exercise grounds you in the core principles of signal transduction modeling by analyzing a canonical two-stage pathway. By deriving the steady-state dose-response relationship from mass-action kinetics and calculating the half-maximal effective concentration ($EC_{50}$), you will develop a foundational skill: translating a biological schematic into a quantitative, predictive tool for understanding how cells interpret external signals .",
            "id": "3880102",
            "problem": "Model a cytokine–receptor signaling module to derive the steady-state dose–response and compute the half-maximal effective concentration (EC50). Consider an extracellular cytokine at concentration $L$ (nanomolar, nM) that binds a cell-surface receptor with total level $R_T$ (nM). Binding is $1:1$ and governed by mass-action kinetics with equilibrium dissociation constant $K_D$ (nM), defined by $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$. Let $C$ (nM) denote the receptor–ligand complex at steady state. The downstream signaling is modeled as activation of a transcription factor (for example, Janus kinase/signal transducer and activator of transcription (JAK-STAT)) with total pool $S_T$ (nM). The active form $S^*$ (nM) is produced by complex-dependent activation and removed by a first-order deactivation. Assume well-mixed conditions and steady state for binding and signaling. Use the following fundamental bases: (i) mass-action binding and conservation of receptor, (ii) mass-action activation and conservation of substrate, and (iii) first-order deactivation.\n\nDefinitions and model components to use:\n- Binding and conservation: receptor–ligand binding is reversible with a conserved receptor pool. At steady state, use mass-action equilibrium and receptor conservation to relate $C$ to $L$, $R_T$, and $K_D$ without assuming ligand depletion from the bulk extracellular pool.\n- Downstream activation and deactivation: the activation of $S^*$ is proportional to the complex $C$ and the available inactive pool $(S_T - S^*)$ with activation rate constant $k_a$ (per nanomolar per second, $\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$). Deactivation is first-order with rate constant $k_d$ (per second, $\\mathrm{s}^{-1}$). Impose steady state for $S^*$.\n\nTasks:\n1. From the above fundamental bases, derive a steady-state mapping $L \\mapsto S^*(L)$ that depends only on $L$, $K_D$, $R_T$, $S_T$, $k_a$, and $k_d$. Do not introduce any additional phenomenological assumptions.\n2. Define the half-maximal effective concentration (EC50) as the unique $L$ in nanomolar such that $S^*(L)$ equals half the dynamic range from minimum to maximum steady-state activation with respect to $L$. In this model, $S^*$ approaches a minimum at $L \\to 0$ and a maximum at $L \\to \\infty$. Use these limits to formalize the EC50 condition precisely and solve for EC50 from first principles.\n3. Implement a program that, for each parameter set in the test suite below, computes the EC50 in nanomolar and returns these values. The program must not require any user input and must run deterministically.\n\nPhysical and numerical units:\n- Concentrations $L$, $R_T$, $S_T$, and $K_D$ are in nanomolar (nM).\n- Time is in seconds (s).\n- Rate constants are $k_a$ in $\\mathrm{nM}^{-1}\\mathrm{s}^{-1}$ and $k_d$ in $\\mathrm{s}^{-1}$.\n- Express the final EC50 values in nanomolar (nM) as floating-point numbers.\n\nTest suite (each line lists $(K_D, R_T, S_T, k_a, k_d)$):\n- Case A (general “happy path”): $K_D = 10$, $R_T = 100$, $S_T = 100$, $k_a = 0.01$, $k_d = 0.1$.\n- Case B (boundary approaching linear downstream module with $k_a R_T \\ll k_d$): $K_D = 10$, $R_T = 100$, $S_T = 100$, $k_a = 10^{-5}$, $k_d = 0.1$.\n- Case C (strong downstream saturation with $k_a R_T \\gg k_d$): $K_D = 50$, $R_T = 50$, $S_T = 200$, $k_a = 0.1$, $k_d = 0.01$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each $resulti$ is the EC50 for the corresponding test case, in nanomolar, represented as a floating-point number.",
            "solution": "The problem is first validated to ensure it is scientifically sound, well-posed, and objective.\n\n### Step 1: Extract Givens\n\n-   **Variables & Concentrations:**\n    -   $L$: Extracellular cytokine concentration (nM).\n    -   $R_T$: Total cell-surface receptor concentration (nM).\n    -   $C$: Receptor-ligand complex concentration at steady state (nM).\n    -   $S_T$: Total transcription factor pool concentration (nM).\n    -   $S^*$: Activated transcription factor concentration at steady state (nM).\n\n-   **Constants:**\n    -   $K_D$: Equilibrium dissociation constant for ligand-receptor binding (nM), defined as $K_D = k_{\\mathrm{off}}/k_{\\mathrm{on}}$.\n    -   $k_a$: Activation rate constant for $S^*$ (nM$^{-1}$s$^{-1}$).\n    -   $k_d$: Deactivation rate constant for $S^*$ (s$^{-1}$).\n\n-   **Model Principles (Fundamental Bases):**\n    1.  **Binding and Conservation:** Binding is reversible mass-action at equilibrium ($L + R \\rightleftharpoons C$). The total receptor pool is conserved ($R_T = [R] + C$, where $[R]$ is the free receptor concentration). Ligand depletion is not assumed.\n    2.  **Downstream Activation and Conservation:** Activation of $S^*$ is mass-action, proportional to $C$ and the inactive substrate pool $(S_T - S^*)$. The total substrate pool is conserved ($S_T = [S] + S^*$, where $[S]$ is the inactive substrate concentration).\n    3.  **Deactivation:** Deactivation of $S^*$ is a first-order process.\n\n-   **Tasks:**\n    1.  Derive the steady-state mapping $L \\mapsto S^*(L)$.\n    2.  Derive the half-maximal effective concentration (EC50), defined as the unique $L$ where $S^*(L)$ is half of its dynamic range, which spans from $L \\to 0$ to $L \\to \\infty$.\n    3.  Implement a program to compute the EC50 for given parameter sets.\n\n-   **Test Suite:**\n    -   Case A: $(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 0.01, 0.1)$.\n    -   Case B: $(K_D, R_T, S_T, k_a, k_d) = (10, 100, 100, 10^{-5}, 0.1)$.\n    -   Case C: $(K_D, R_T, S_T, k_a, k_d) = (50, 50, 200, 0.1, 0.01)$.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement describes a canonical two-stage signaling pathway, a common motif in systems biology. The modeling approach relies on fundamental, well-established principles: mass-action kinetics for bimolecular interactions and first-order kinetics for unimolecular decay, coupled with conservation laws for total component concentrations. These are standard and scientifically sound assumptions for building ordinary differential equation (ODE) models of biochemical networks, and their steady-state analysis is a routine procedure. The problem is self-contained, providing all necessary parameters and definitions. The definition of EC50 is standard for dose-response analysis. The parameters and units are dimensionally consistent. The problem is objective and free of non-scientific claims.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is scientifically grounded, well-posed, and objective. I will proceed with the derivation and solution.\n\n### Derivation of the Solution\n\n**Part 1: Derivation of the steady-state complex concentration $C(L)$**\n\nThe binding of the ligand $L$ to the receptor $R$ to form a complex $C$ is described by the reaction $L + R \\rightleftharpoons C$. At equilibrium, the dissociation constant $K_D$ is given by:\n$$K_D = \\frac{[R][L]}{[C]}$$\nThe concentration of free receptors $[R]$ and complex $C$ are constrained by the conservation of total receptors, $R_T$:\n$$R_T = [R] + C \\implies [R] = R_T - C$$\nSubstituting the expression for $[R]$ into the $K_D$ equation:\n$$K_D = \\frac{(R_T - C)L}{C}$$\nWe solve this algebraic equation for $C$ as a function of $L$:\n$$K_D C = L R_T - L C$$\n$$C (K_D + L) = L R_T$$\n$$C(L) = \\frac{R_T L}{K_D + L}$$\nThis is the standard Langmuir isotherm or Michaelis-Menten binding equation, which relates the steady-state concentration of the receptor-ligand complex to the ligand concentration.\n\n**Part 2: Derivation of the steady-state activated substrate concentration $S^*(C)$**\n\nThe activation of the substrate $S$ to its active form $S^*$ is catalyzed by the complex $C$, and $S^*$ is deactivated via a first-order process. The rate of formation of $S^*$ is $v_{\\text{form}} = k_a [S] C$, and the rate of deactivation is $v_{\\text{deact}} = k_d S^*$. The total substrate pool $S_T$ is conserved:\n$$S_T = [S] + S^* \\implies [S] = S_T - S^*$$\nAt steady state, the rate of formation equals the rate of deactivation:\n$$v_{\\text{form}} = v_{\\text{deact}}$$\n$$k_a (S_T - S^*) C = k_d S^*$$\nWe solve this for $S^*$ as a function of $C$:\n$$k_a S_T C - k_a S^* C = k_d S^*$$\n$$k_a S_T C = S^* (k_d + k_a C)$$\n$$S^*(C) = \\frac{k_a S_T C}{k_d + k_a C}$$\nThis equation describes how the downstream signal $S^*$ depends on the concentration of the active complex $C$.\n\n**Part 3: Derivation of the complete dose-response curve $S^*(L)$**\n\nTo obtain the full dose-response relationship, we substitute the expression for $C(L)$ from Part 1 into the expression for $S^*(C)$ from Part 2:\n$$S^*(L) = \\frac{k_a S_T \\left( \\frac{R_T L}{K_D + L} \\right)}{k_d + k_a \\left( \\frac{R_T L}{K_D + L} \\right)}$$\nTo simplify, we multiply the numerator and denominator by $(K_D + L)$:\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d(K_D + L) + k_a R_T L}$$\nGrouping terms in $L$ in the denominator:\n$$S^*(L) = \\frac{k_a S_T R_T L}{k_d K_D + k_d L + k_a R_T L} = \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\nThis is the final expression for the steady-state dose-response curve $S^*(L)$.\n\n**Part 4: Derivation of the EC50**\n\nThe EC50 is the ligand concentration $L$ at which the response $S^*$ is half of its maximal possible change. First, we determine the minimum and maximum response.\n\nThe minimum response, $S_{\\text{min}}^*$, occurs at $L=0$:\n$$S_{\\text{min}}^* = S^*(0) = \\frac{k_a S_T R_T (0)}{k_d K_D + (k_d + k_a R_T)(0)} = 0$$\nThe maximum response, $S_{\\text{max}}^*$, occurs in the limit $L \\to \\infty$:\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} S^*(L) = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T L}{k_d K_D + (k_d + k_a R_T)L}$$\nTo evaluate the limit, we divide the numerator and denominator by $L$:\n$$S_{\\text{max}}^* = \\lim_{L \\to \\infty} \\frac{k_a S_T R_T}{\\frac{k_d K_D}{L} + (k_d + k_a R_T)} = \\frac{k_a S_T R_T}{0 + k_d + k_a R_T} = \\frac{k_a S_T R_T}{k_d + k_a R_T}$$\nThe EC50 is defined by the condition $S^*(\\text{EC50}) = \\frac{1}{2}(S_{\\text{max}}^* - S_{\\text{min}}^*) + S_{\\text{min}}^*$. Since $S_{\\text{min}}^* = 0$, this simplifies to:\n$$S^*(\\text{EC50}) = \\frac{1}{2} S_{\\text{max}}^*$$\n$$\\frac{k_a S_T R_T (\\text{EC50})}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2} \\left( \\frac{k_a S_T R_T}{k_d + k_a R_T} \\right)$$\nAssuming the system is functional ($k_a, S_T, R_T$ are non-zero), we can cancel the term $k_a S_T R_T$ from both sides:\n$$\\frac{\\text{EC50}}{k_d K_D + (k_d + k_a R_T)(\\text{EC50})} = \\frac{1}{2(k_d + k_a R_T)}$$\nCross-multiplying gives:\n$$2(k_d + k_a R_T)(\\text{EC50}) = k_d K_D + (k_d + k_a R_T)(\\text{EC50})$$\nSubtracting $(k_d + k_a R_T)(\\text{EC50})$ from both sides:\n$$(k_d + k_a R_T)(\\text{EC50}) = k_d K_D$$\nFinally, solving for EC50 yields the definitive formula:\n$$\\text{EC50} = \\frac{k_d K_D}{k_d + k_a R_T}$$\nThis elegant result shows that the system's half-maximal effective concentration depends on the receptor-ligand binding affinity ($K_D$) and is modulated by the downstream signaling parameters ($k_a, k_d, R_T$). Notably, the total pool of the signaling substrate, $S_T$, affects the amplitude of the maximal response ($S_{\\text{max}}^*$) but does not influence the EC50.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the EC50 for a cytokine signaling model based on a derived formula.\n\n    The model consists of a two-stage signaling cascade:\n    1. Receptor-ligand binding: L + R <-> C\n    2. Substrate activation: S + C -> S* + C and S* -> S\n\n    The derived steady-state half-maximal effective concentration (EC50) is given by:\n    EC50 = (k_d * K_D) / (k_d + k_a * R_T)\n\n    where:\n    K_D : Dissociation constant (nM)\n    R_T : Total receptor concentration (nM)\n    S_T : Total substrate concentration (nM) - Note: not in the final EC50 formula\n    k_a : Activation rate constant (nM^-1 s^-1)\n    k_d : Deactivation rate constant (s^-1)\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple represents (K_D, R_T, S_T, k_a, k_d).\n    test_cases = [\n        # Case A (general “happy path”)\n        (10.0, 100.0, 100.0, 0.01, 0.1),\n        # Case B (boundary approaching linear downstream module)\n        (10.0, 100.0, 100.0, 1e-5, 0.1),\n        # Case C (strong downstream saturation)\n        (50.0, 50.0, 200.0, 0.1, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        K_D, R_T, S_T, k_a, k_d = case\n\n        # The parameter S_T is part of the problem definition but analytically\n        # cancels out from the EC50 calculation, as it only affects the\n        # magnitude of the response, not the concentration at which\n        # the half-maximal response is achieved.\n\n        # Calculate the numerator of the EC50 formula.\n        numerator = k_d * K_D\n        \n        # Calculate the denominator of the EC50 formula.\n        denominator = k_d + k_a * R_T\n\n        # Compute the EC50.\n        # Check for division by zero, although physically unlikely in this model.\n        if denominator == 0:\n            # A denominator of zero would imply k_d=0 and (k_a=0 or R_T=0),\n            # which is a physically degenerate system. We can assign inf or nan.\n            # Based on the physics, if k_d=0, the system never deactivates,\n            # so any non-zero L would eventually lead to S_max. EC50 would be 0.\n            # If denominator is zero AND k_d is also 0, EC50 is 0/0.\n            # Let's stick to the formula and normal parameter regimes.\n            ec50 = np.nan \n        else:\n            ec50 = numerator / denominator\n        \n        results.append(ec50)\n\n    # Format the results into the required string format.\n    # e.g., \"[result1,result2,result3]\"\n    output_string = \"[\" + \",\".join(map(str, results)) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "Cytokine signaling networks are not simple linear chains; their functions are dictated by intricate architectures of feedback and feedforward loops. This practice moves beyond simple response curves to explore how network structure gives rise to complex, dynamic behaviors. You will numerically simulate a model containing both positive and negative feedback motifs to uncover emergent properties like bistability and oscillations, which are crucial for cellular decision-making and temporal coding but cannot be predicted by analyzing components in isolation .",
            "id": "3880126",
            "problem": "Consider a minimal, mechanistically grounded cytokine signaling network model that captures positive feedback leading to bistability and negative feedback leading to oscillations. The network involves Signal Transducer and Activator of Transcription (STAT), Suppressor of Cytokine Signaling (SOCS), and cytokine receptor activation. Let $R(t)$ denote the dimensionless fraction of activated receptor, $S(t)$ denote the dimensionless fraction of active STAT (phosphorylated and dimerized), and $X(t)$ denote the dimensionless concentration of SOCS. Let $S_{\\mathrm{tot}}$ be the dimensionless total STAT available for activation. The dynamics are modeled by an Ordinary Differential Equation (ODE) system derived from mass-action and Hill-type kinetics:\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t)\n$$,\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t)\n$$,\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t)\n$$.\nIn these equations, $k_{r0}$ represents baseline receptor activation attributable to a constant cytokine input, $k_{rp}$ is the strength of positive feedback from $S(t)$ to receptor activation (for example, via receptor upregulation or autocrine enhancement), $k_{rd}$ is receptor deactivation, $k_{rx}$ captures SOCS-dependent inhibition of the receptor, $k_{s}$ and $k_{sd}$ are STAT activation and deactivation rates, and $k_{x}$ and $k_{xd}$ are SOCS synthesis and degradation rates. The Hill coefficients $n$ and $m$ reflect cooperativity in the feedback processes. The Hill functions are $H_{r}(S) = \\dfrac{S^{n}}{K_{r}^{n} + S^{n}}$ and $H_{x}(S) = \\dfrac{S^{m}}{K_{x}^{m} + S^{m}}$. Time is measured in minutes. All state variables and thresholds are dimensionless. All rate constants have units of per minute.\n\nStarting from mass-action kinetics, conservation of total STAT, and saturable transcriptional activation modeled by Hill functions, it is known that positive feedback can create multiple stable steady states for the same parameters and input (bistability), and that sufficiently strong, delayed negative feedback can destabilize a steady state and produce sustained oscillations. Your task is to implement a program that, for each parameter set provided, determines:\n- Whether the system exhibits bistability at constant parameters, operationally defined as the presence of at least two distinct asymptotically stable equilibria reached from different initial conditions.\n- Whether the system exhibits sustained oscillations, operationally defined as the trajectory converging to a nontrivial limit cycle with nonvanishing amplitude in $S(t)$ after transients.\n\nThe decision must be made by direct numerical simulation with the following standardized procedure and thresholds, which ensure universal applicability across programming languages:\n\nSimulation and detection protocol:\n- Use $S_{\\mathrm{tot}} = 1$.\n- For each parameter set, simulate the ODE system over the time horizon $[0, T]$ with $T = 300$ minutes and a uniform evaluation grid of $N = 3001$ points.\n- Use the Cartesian product of initial conditions $R(0) \\in \\{0, 0.5, 1.5\\}$, $S(0) \\in \\{0, 0.5\\,S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$, and $X(0) \\in \\{0, 0.5, 1.5\\}$ to probe multiple basins of attraction.\n- Define the final analysis window as the last quarter of the simulation, $t \\in [0.75\\,T, T]$. For any trajectory, compute the amplitudes $A_{R}$, $A_{S}$, and $A_{X}$ as the difference between the maximum and minimum values of $R(t)$, $S(t)$, and $X(t)$ over this window.\n- Equilibrium detection: If $\\max\\{A_{R}, A_{S}, A_{X}\\} < \\epsilon_{\\mathrm{eq}}$ with $\\epsilon_{\\mathrm{eq}} = 10^{-3}$, classify the trajectory as converging to an equilibrium. Record the equilibrium by the mean vector over the window, and cluster equilibria from different initial conditions using a Euclidean distance tolerance $\\epsilon_{\\mathrm{cluster}} = 0.02$; equilibria separated by more than $\\epsilon_{\\mathrm{cluster}}$ are considered distinct.\n- Oscillation detection: If $A_{S} \\ge \\epsilon_{\\mathrm{osc}}$ with $\\epsilon_{\\mathrm{osc}} = 0.05$ over the final window, and the amplitude over the final quarter is at least $0.8$ times the amplitude over the preceding quarter (to exclude decaying transients), and there are at least three distinct local maxima of $S(t)$ in the final half of the simulation, classify the trajectory as exhibiting sustained oscillations.\n- Case-level decisions: For a parameter set, declare bistability if at least two distinct equilibria are identified across the initial-condition grid. Declare oscillations if at least one initial condition yields sustained oscillations by the above criteria.\n\nTest suite:\nEvaluate the following four parameter sets (rates in per minute, thresholds dimensionless) with $S_{\\mathrm{tot}} = 1$:\n- Case $1$ (nominal negative feedback, no positive feedback):\n$k_{r0} = 0.1$, $k_{rp} = 0.0$, $K_{r} = 0.3$, $n = 2$, $k_{rd} = 0.5$, $k_{rx} = 0.2$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.5$, $K_{x} = 0.4$, $m = 2$, $k_{xd} = 0.3$.\n- Case $2$ (strong positive feedback, weak negative feedback):\n$k_{r0} = 0.05$, $k_{rp} = 1.5$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 0.4$, $k_{rx} = 0.05$, $k_{s} = 2.0$, $k_{sd} = 1.0$, $k_{x} = 0.2$, $K_{x} = 0.3$, $m = 3$, $k_{xd} = 0.3$.\n- Case $3$ (strong negative feedback with slow SOCS and high cooperativity):\n$k_{r0} = 0.05$, $k_{rp} = 0.3$, $K_{r} = 0.3$, $n = 3$, $k_{rd} = 0.4$, $k_{rx} = 1.5$, $k_{s} = 3.0$, $k_{sd} = 1.0$, $k_{x} = 2.0$, $K_{x} = 0.5$, $m = 10$, $k_{xd} = 0.05$.\n- Case $4$ (boundary case with fast deactivation and degradation):\n$k_{r0} = 0.2$, $k_{rp} = 3.0$, $K_{r} = 0.2$, $n = 4$, $k_{rd} = 2.0$, $k_{rx} = 0.5$, $k_{s} = 5.0$, $k_{sd} = 3.0$, $k_{x} = 0.5$, $K_{x} = 0.5$, $m = 2$, $k_{xd} = 1.5$.\n\nRequired final output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each element being a list of two booleans $[\\text{bistability}, \\text{oscillation}]$ corresponding to the cases in order. For example, the output should look like $[[\\mathrm{False},\\mathrm{False}],[\\mathrm{True},\\mathrm{False}],[\\mathrm{False},\\mathrm{True}],[\\mathrm{False},\\mathrm{False}]]$.",
            "solution": "The user has provided a well-defined problem in the domain of biomedical systems modeling, specifically focusing on the dynamics of a cytokine signaling network. The task is to determine whether specific parameter sets for a given Ordinary Differential Equation (ODE) model lead to bistability or sustained oscillations.\n\n### Problem Formulation and Model\n\nThe system's dynamics are described by a set of three coupled nonlinear ODEs for the state variables $R(t)$, $S(t)$, and $X(t)$, which represent the dimensionless concentrations of activated receptor, active STAT, and SOCS protein, respectively.\n\nThe governing equations are:\n$$\n\\frac{dR}{dt} \\;=\\; k_{r0} \\;+\\; k_{rp}\\,\\frac{S(t)^{n}}{K_{r}^{n} + S(t)^{n}} \\;-\\; k_{rd}\\,R(t) \\;-\\; k_{rx}\\,X(t)\\,R(t)\n$$\n$$\n\\frac{dS}{dt} \\;=\\; k_{s}\\,R(t)\\,\\big(S_{\\mathrm{tot}} - S(t)\\big) \\;-\\; k_{sd}\\,S(t)\n$$\n$$\n\\frac{dX}{dt} \\;=\\; k_{x}\\,\\frac{S(t)^{m}}{K_{x}^{m} + S(t)^{m}} \\;-\\; k_{xd}\\,X(t)\n$$\n\nHere, the terms model baseline activation ($k_{r0}$), cooperative positive feedback from active STAT to receptor activation ($k_{rp}$ term with Hill coefficient $n$), first-order deactivation ($k_{rd}R$), SOCS-mediated inhibition ($k_{rx}XR$), STAT activation proportional to receptor activity ($k_s R (S_{\\mathrm{tot}}-S)$) and deactivation ($k_{sd}S$), and cooperative STAT-induced synthesis of SOCS ($k_x$ term with Hill coefficient $m$) and its degradation ($k_{xd}X$). This model structure is mechanistically sound, incorporating key regulatory motifs: a positive feedback loop ($S \\rightarrow R \\rightarrow S$) capable of producing bistability, and a negative feedback loop ($S \\rightarrow X \\dashv R \\rightarrow S$) capable of producing oscillations.\n\n### Algorithmic Design and Implementation\n\nThe solution strategy is to perform direct numerical simulation of the ODE system and analyze the long-term behavior of the trajectories based on a detailed protocol provided in the problem statement. This approach avoids the complexities of analytical bifurcation analysis for this three-dimensional nonlinear system.\n\n1.  **Numerical Integration**: The core of the solution is a numerical ODE solver. We will use `scipy.integrate.solve_ivp`, a robust adaptive-step solver, to integrate the system dynamics over a time horizon $T = 300$ minutes. The solution will be evaluated on a fine-grained uniform time grid of $N = 3001$ points to ensure that dynamic features like oscillations are well-resolved.\n\n2.  **Exploration of State Space**: To detect multiple stable states (bistability), it is essential to start the simulation from different points in the state space. The protocol specifies a grid of $3 \\times 3 \\times 3 = 27$ initial conditions, constructed from the Cartesian product of $\\{0, 0.5, 1.5\\}$ for $R(0)$ and $X(0)$, and $\\{0, 0.5 S_{\\mathrm{tot}}, S_{\\mathrm{tot}}\\}$ for $S(0)$, with $S_{\\mathrm{tot}}=1$. This grid provides a broad sampling of potential basins of attraction.\n\n3.  **Asymptotic Behavior Analysis**: For each trajectory, we analyze its behavior in the final quarter of the simulation time, $t \\in [225, 300]$, to ensure that initial transients have decayed and the system has settled into its asymptotic state (an equilibrium or a limit cycle).\n\n4.  **Equilibrium Detection and Clustering**: A trajectory is classified as converging to an equilibrium if the amplitudes of all state variables ($R, S, X$) in the final analysis window are below a small threshold, $\\epsilon_{\\mathrm{eq}} = 10^{-3}$. The steady-state value is recorded as the mean of the state vector over this window. After simulating from all initial conditions, the collected set of equilibrium points is clustered using a Euclidean distance tolerance $\\epsilon_{\\mathrm{cluster}} = 0.02$. If two or more distinct clusters of equilibria are found, the parameter set is classified as exhibiting **bistability**.\n\n5.  **Oscillation Detection**: A trajectory is classified as oscillatory based on a three-part criterion designed to identify sustained, non-decaying oscillations of significant amplitude:\n    a. The amplitude of active STAT, $A_S$, in the final window must be non-negligible ($A_S \\ge \\epsilon_{\\mathrm{osc}} = 0.05$).\n    b. The oscillation must be sustained, not a decaying transient. This is checked by requiring the amplitude in the final quarter to be at least $80\\%$ of the amplitude in the preceding quarter ($t \\in [150, 225]$).\n    c. The oscillation must have a periodic character, verified by requiring at least three distinct local maxima of $S(t)$ in the final half of the simulation ($t \\in [150, 300]$).\n    If any of the 27 trajectories for a given parameter set meets all three criteria, the parameter set is classified as exhibiting **oscillation**.\n\n6.  **Case Evaluation**: This entire procedure is systematically applied to each of the four provided parameter sets. For each case, we determine the two boolean flags for bistability and oscillation, and aggregate the results into the specified output format. This principled, simulation-based approach provides a robust and verifiable method for characterizing the complex dynamics of the given nonlinear system.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport itertools\n\ndef solve():\n    \"\"\"\n    Main function to solve the cytokine signaling network problem.\n    It iterates through four parameter sets, analyzes each for bistability and\n    oscillations according to the specified protocol, and prints the results.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Nominal negative feedback, no positive feedback\n        {\n            \"k_r0\": 0.1, \"k_rp\": 0.0, \"K_r\": 0.3, \"n\": 2, \"k_rd\": 0.5, \"k_rx\": 0.2,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.5, \"K_x\": 0.4, \"m\": 2, \"k_xd\": 0.3\n        },\n        # Case 2: Strong positive feedback, weak negative feedback\n        {\n            \"k_r0\": 0.05, \"k_rp\": 1.5, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 0.4, \"k_rx\": 0.05,\n            \"k_s\": 2.0, \"k_sd\": 1.0, \"k_x\": 0.2, \"K_x\": 0.3, \"m\": 3, \"k_xd\": 0.3\n        },\n        # Case 3: Strong negative feedback with slow SOCS and high cooperativity\n        {\n            \"k_r0\": 0.05, \"k_rp\": 0.3, \"K_r\": 0.3, \"n\": 3, \"k_rd\": 0.4, \"k_rx\": 1.5,\n            \"k_s\": 3.0, \"k_sd\": 1.0, \"k_x\": 2.0, \"K_x\": 0.5, \"m\": 10, \"k_xd\": 0.05\n        },\n        # Case 4: Boundary case with fast deactivation and degradation\n        {\n            \"k_r0\": 0.2, \"k_rp\": 3.0, \"K_r\": 0.2, \"n\": 4, \"k_rd\": 2.0, \"k_rx\": 0.5,\n            \"k_s\": 5.0, \"k_sd\": 3.0, \"k_x\": 0.5, \"K_x\": 0.5, \"m\": 2, \"k_xd\": 1.5\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        result = analyze_parameter_set(params)\n        results.append(result)\n\n    # Format the final output as a Python literal string without spaces\n    print(repr(results).replace(\" \", \"\"))\n\ndef analyze_parameter_set(params):\n    \"\"\"\n    Analyzes a single parameter set for bistability and oscillations.\n    \"\"\"\n    S_tot = 1.0\n    T_final = 300.0\n    N_points = 3001\n    t_span = [0, T_final]\n    t_eval = np.linspace(t_span[0], t_span[1], N_points)\n    \n    epsilon_eq = 1e-3\n    epsilon_cluster = 0.02\n    epsilon_osc = 0.05\n\n    def model(t, y, p):\n        R, S, X = y\n        hr_s = S**p[\"n\"] / (p[\"K_r\"]**p[\"n\"] + S**p[\"n\"]) if S >= 0 else 0\n        hx_s = S**p[\"m\"] / (p[\"K_x\"]**p[\"m\"] + S**p[\"m\"]) if S >= 0 else 0\n\n        # Ensure state variables are non-negative for biological realism\n        R, S, X = max(0, R), max(0, S), max(0,X)\n\n        dRdt = p[\"k_r0\"] + p[\"k_rp\"] * hr_s - p[\"k_rd\"] * R - p[\"k_rx\"] * X * R\n        dSdt = p[\"k_s\"] * R * (S_tot - S) - p[\"k_sd\"] * S\n        dXdt = p[\"k_x\"] * hx_s - p[\"k_xd\"] * X\n        return [dRdt, dSdt, dXdt]\n\n    ic_R = [0, 0.5, 1.5]\n    ic_S = [0, 0.5 * S_tot, S_tot]\n    ic_X = [0, 0.5, 1.5]\n    initial_conditions = list(itertools.product(ic_R, ic_S, ic_X))\n\n    found_equilibria = []\n    is_oscillatory = False\n\n    # Define analysis window indices\n    final_quarter_start_idx = int(N_points * 0.75)\n    third_quarter_start_idx = int(N_points * 0.5)\n    \n    for y0 in initial_conditions:\n        sol = solve_ivp(model, t_span, y0, args=(params,), t_eval=t_eval, method='RK45')\n        \n        R_sol, S_sol, X_sol = sol.y\n        \n        # Final analysis window (last quarter)\n        R_final = R_sol[final_quarter_start_idx:]\n        S_final = S_sol[final_quarter_start_idx:]\n        X_final = X_sol[final_quarter_start_idx:]\n        \n        A_R = np.ptp(R_final)\n        A_S = np.ptp(S_final)\n        A_X = np.ptp(X_final)\n        \n        # Equilibrium detection\n        if max(A_R, A_S, A_X) < epsilon_eq:\n            eq_point = np.array([np.mean(R_final), np.mean(S_final), np.mean(X_final)])\n            found_equilibria.append(eq_point)\n            continue # Move to next initial condition\n            \n        # Oscillation detection (only if not an equilibrium and not already found)\n        if not is_oscillatory:\n            # Condition 1: Amplitude threshold\n            if A_S >= epsilon_osc:\n                # Condition 2: Non-decaying amplitude\n                S_preceding = S_sol[third_quarter_start_idx:final_quarter_start_idx]\n                A_S_preceding = np.ptp(S_preceding)\n                if A_S_preceding == 0 or A_S >= 0.8 * A_S_preceding:\n                    # Condition 3: At least 3 peaks in the final half\n                    S_half = S_sol[third_quarter_start_idx:]\n                    num_peaks = 0\n                    for i in range(1, len(S_half) - 1):\n                        if S_half[i] > S_half[i-1] and S_half[i] > S_half[i+1]:\n                            num_peaks += 1\n                    \n                    if num_peaks >= 3:\n                        is_oscillatory = True\n\n    # Bistability decision via clustering\n    is_bistable = False\n    if len(found_equilibria) >= 2:\n        unique_equilibria = []\n        for eq in found_equilibria:\n            is_new = True\n            for unique_eq in unique_equilibria:\n                dist = np.linalg.norm(eq - unique_eq)\n                if dist <= epsilon_cluster:\n                    is_new = False\n                    break\n            if is_new:\n                unique_equilibria.append(eq)\n        if len(unique_equilibria) >= 2:\n            is_bistable = True\n            \n    return [is_bistable, is_oscillatory]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "A model's predictive power is only as strong as its parameters are identifiable from experimental data. This final practice addresses the critical, real-world challenge of model validation and parameter uncertainty. You will implement a sensitivity analysis to compute the Fisher Information Matrix (FIM) and use its eigenvalue spectrum to assess \"sloppiness\"—a common feature of systems biology models where some parameter combinations are poorly constrained . This advanced exercise provides a quantitative framework for evaluating a model's credibility and guiding future experimental design.",
            "id": "3880132",
            "problem": "You are tasked with implementing a quantitative sensitivity analysis and sloppiness assessment for a simplified cytokine signaling network model within the broader context of biomedical systems modeling. Consider a cytokine ligand binding to its cell surface receptor, forming a signaling-competent complex that drives downstream phosphorylation of Signal Transducer and Activator of Transcription (STAT). Use the following model assumptions and definitions as the fundamental base:\n\n- Dynamics are governed by Ordinary Differential Equations (ODEs), a well-tested formalism for biochemical network modeling. Receptor-ligand interactions follow mass-action kinetics, and phosphorylation/dephosphorylation are modeled using bilinear mass-action terms.\n- The measurement model is additive, independent Gaussian noise with a constant variance across time, a standard assumption that leads to a least-squares objective and the Fisher Information Matrix (FIM).\n\nModel variables and parameters:\n- Variables: $R(t)$ is the concentration of free receptor, $C(t)$ is the concentration of ligand-bound receptor complex, and $P(t)$ is the concentration of phosphorylated STAT. The total STAT is conserved as $S_{\\text{tot}}$, so the unphosphorylated STAT is $S(t) = S_{\\text{tot}} - P(t)$.\n- External ligand concentration $L$ is constant over time.\n- Parameters (all nonnegative): $k_{\\mathrm{on}}$ (binding, units $\\mathrm{nM}^{-1}\\,\\mathrm{s}^{-1}$), $k_{\\mathrm{off}}$ (unbinding, units $\\mathrm{s}^{-1}$), $k_{\\mathrm{int}}$ (complex internalization, units $\\mathrm{s}^{-1}$), $k_{p}$ (phosphorylation, units $\\mathrm{nM}^{-1}\\,\\mathrm{s}^{-1}$), $k_{dp}$ (dephosphorylation, units $\\mathrm{s}^{-1}$), $k_{\\mathrm{syn}}$ (receptor synthesis, units $\\mathrm{nM}\\,\\mathrm{s}^{-1}$), $k_{\\mathrm{deg}}$ (receptor degradation, units $\\mathrm{s}^{-1}$).\n- Initial conditions represent pre-stimulation equilibrium for receptor with no complex and no phosphorylated STAT: $R(0) = k_{\\mathrm{syn}}/k_{\\mathrm{deg}}$, $C(0) = 0$, $P(0) = 0$.\n\nThe ODE system:\n$$\n\\frac{dR}{dt} = k_{\\mathrm{syn}} - k_{\\mathrm{deg}}\\,R - k_{\\mathrm{on}}\\,L\\,R + k_{\\mathrm{off}}\\,C,\n$$\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,L\\,R - (k_{\\mathrm{off}} + k_{\\mathrm{int}})\\,C,\n$$\n$$\n\\frac{dP}{dt} = k_{p}\\,C\\,(S_{\\mathrm{tot}} - P) - k_{dp}\\,P.\n$$\n\nMeasurements:\n- The observable is $P(t)$ measured at a set of specified times.\n- The measurement noise model is additive Gaussian with variance $\\sigma^2$ (units $\\mathrm{nM}^2$) per measurement.\n\nSensitivity and sloppiness assessment:\n- Let the parameter vector be $\\theta = [k_{\\mathrm{on}}, k_{\\mathrm{off}}, k_{\\mathrm{int}}, k_{p}, k_{dp}, k_{\\mathrm{syn}}, k_{\\mathrm{deg}}]$.\n- Define sensitivities at the measurement times as numerical partial derivatives $\\partial P(t_j)/\\partial \\theta_i$ computed by finite differences. Use central differences when both the positive and negative perturbations keep parameters nonnegative; otherwise use a one-sided forward difference. For a given parameter value $\\theta_i$, use a perturbation magnitude $\\delta_i = \\max(10^{-8}, 10^{-6}\\,\\theta_i)$.\n- The Fisher Information Matrix (FIM) for independent, identically distributed Gaussian noise is constructed from the sensitivities and the noise variance. From the FIM eigen-spectrum, define sloppiness as the ratio $s = \\lambda_{\\min}/\\lambda_{\\max}$, where $\\lambda_{\\min}$ and $\\lambda_{\\max}$ are the smallest and largest eigenvalues, respectively. If $\\lambda_{\\max}$ is numerically zero (e.g., less than $10^{-15}$), define $s = 0.0$.\n- Eigenvalues must be treated as nonnegative by clipping small negative values (due to numerical roundoff) to zero before computing $s$.\n\nUnits:\n- Concentrations are in nanomolar (nM), time is in seconds (s), and all rate parameters have units consistent with the ODEs above. The final sloppiness metric $s$ is dimensionless and must be reported as floats rounded to six decimal places.\n\nTest suite:\nImplement your program to compute the sloppiness metric $s$ for each of the following four cases. In all cases, the observable is $P(t)$ at the specified times.\n\n- Case 1 (happy path): $\\theta = [1\\times 10^{-3}, 1\\times 10^{-2}, 5\\times 10^{-3}, 2\\times 10^{-3}, 1\\times 10^{-2}, 1\\times 10^{-2}, 2\\times 10^{-3}]$, $L = 10$, $S_{\\text{tot}} = 100$, $\\sigma = 1.0$, $t = [0, 50, 100, 200, 400, 800]$.\n- Case 2 (late-time measurements near steady state): same $\\theta$ and $L$ and $S_{\\text{tot}}$ as Case 1, but $\\sigma = 1.0$, $t = [1000, 2000, 4000, 8000]$.\n- Case 3 (low ligand, near-unobservable): same $\\theta$ and $S_{\\text{tot}}$ as Case 1, but $L = 0.01$, $\\sigma = 1.0$, $t = [0, 50, 100, 200, 400, 800]$.\n- Case 4 (fast binding and slower internalization): $\\theta = [5\\times 10^{-3}, 5\\times 10^{-3}, 1\\times 10^{-3}, 5\\times 10^{-3}, 5\\times 10^{-3}, 2\\times 10^{-2}, 1\\times 10^{-3}]$, $L = 20$, $S_{\\text{tot}} = 100$, $\\sigma = 0.5$, $t = [10, 20, 40, 80, 160, 320]$.\n\nAnswer specification:\n- Your program should produce a single line of output containing the sloppiness results for Cases $1$–$4$ as a comma-separated list enclosed in square brackets, each value rounded to six decimal places (e.g., $[0.123456,0.000789,0.000000,0.045678]$).",
            "solution": "The user has provided a well-defined problem in the domain of biomedical systems modeling. The problem is scientifically grounded, mathematically consistent, and algorithmically specified. It passed all validation checks.\n\nThe problem requires a quantitative sensitivity and sloppiness analysis of a simplified ordinary differential equation (ODE) model for cytokine signaling. The objective is to compute a sloppiness metric, $s$, for four different scenarios. This metric quantifies the practical identifiability of the model's parameters from the specified experimental data. The procedure involves numerically solving the ODEs, computing parameter sensitivities using finite differences, constructing the Fisher Information Matrix (FIM), and analyzing its eigenvalue spectrum.\n\nFirst, we formalize the mathematical model. The state of the system is described by the concentrations of free receptor, $R(t)$, ligand-bound receptor complex, $C(t)$, and phosphorylated STAT, $P(t)$. The dynamics are governed by the following system of ODEs:\n$$\n\\frac{dR}{dt} = k_{\\mathrm{syn}} - k_{\\mathrm{deg}}\\,R - k_{\\mathrm{on}}\\,L\\,R + k_{\\mathrm{off}}\\,C\n$$\n$$\n\\frac{dC}{dt} = k_{\\mathrm{on}}\\,L\\,R - (k_{\\mathrm{off}} + k_{\\mathrm{int}})\\,C\n$$\n$$\n\\frac{dP}{dt} = k_{p}\\,C\\,(S_{\\mathrm{tot}} - P) - k_{dp}\\,P\n$$\nThe parameter vector to be analyzed is $\\theta = [k_{\\mathrm{on}}, k_{\\mathrm{off}}, k_{\\mathrm{int}}, k_{p}, k_{dp}, k_{\\mathrm{syn}}, k_{\\mathrm{deg}}]$. The system is stimulated by a constant ligand concentration $L$. Total STAT is conserved at $S_{\\mathrm{tot}}$. The initial conditions at time $t=0$ represent the pre-stimulation steady state:\n$$\nR(0) = \\frac{k_{\\mathrm{syn}}}{k_{\\mathrm{deg}}}, \\quad C(0) = 0, \\quad P(0) = 0\n$$\nIt is crucial to note that the initial condition for $R(0)$ depends on the parameters $k_{\\mathrm{syn}}$ (index $5$ in $\\theta$) and $k_{\\mathrm{deg}}$ (index $6$ in $\\theta$).\n\nThe analysis proceeds in several steps:\n\n1.  **Numerical Solution of ODEs**: To determine the model output, $P(t)$, at the specified measurement times $t_j$, the ODE system must be integrated numerically from $t=0$ to the maximum measurement time for each case. A high-precision numerical solver, such as `solve_ivp` from the `SciPy` library, is appropriate for this task.\n\n2.  **Sensitivity Matrix Calculation**: The core of the analysis is the sensitivity matrix, $J$, which contains the partial derivatives of the observable $P(t)$ with respect to each parameter $\\theta_i$, evaluated at the measurement time points $t_j$. The elements of this matrix are $J_{ji} = \\frac{\\partial P(t_j)}{\\partial \\theta_i}$. These are computed numerically using finite differences. For each parameter $\\theta_i$, a small perturbation $\\delta_i = \\max(10^{-8}, 10^{-6}\\,\\theta_i)$ is applied.\n    - If a symmetric perturbation is possible (i.e., $\\theta_i - \\delta_i \\ge 0$), a central difference formula is used:\n      $$\n      \\frac{\\partial P(t_j)}{\\partial \\theta_i} \\approx \\frac{P(t_j; \\theta + \\delta_i \\mathbf{e}_i) - P(t_j; \\theta - \\delta_i \\mathbf{e}_i)}{2\\delta_i}\n      $$\n    - Otherwise, a forward difference formula is used:\n      $$\n      \\frac{\\partial P(t_j)}{\\partial \\theta_i} \\approx \\frac{P(t_j; \\theta + \\delta_i \\mathbf{e}_i) - P(t_j; \\theta)}{\\delta_i}\n      $$\n    Here, $P(t_j; \\theta')$ denotes the model output at time $t_j$ computed with the parameter vector $\\theta'$, and $\\mathbf{e}_i$ is the standard basis vector for the $i$-th parameter. When calculating the output for a perturbed parameter vector, the initial condition $R(0)$ must be re-evaluated using the perturbed values of $k_{\\mathrm{syn}}$ and $k_{\\mathrm{deg}}$. This requires solving the ODE system multiple times for each of the $7$ parameters.\n\n3.  **Fisher Information Matrix (FIM)**: The FIM relates parameter sensitivities to measurement uncertainty. For the specified model with additive, independent Gaussian noise with variance $\\sigma^2$, the FIM is given by:\n    $$\n    F = \\frac{1}{\\sigma^2} J^T J\n    $$\n    where $J^T$ is the transpose of the sensitivity matrix. The FIM is a $7 \\times 7$ symmetric, positive semi-definite matrix. Its eigenvalues characterize the amount of information the data provides about different combinations of parameters.\n\n4.  **Sloppiness Assessment**: The sloppiness of the model is assessed via the eigenvalue spectrum of the FIM. The eigenvalues, $\\{\\lambda_i\\}$, are computed. Due to numerical precision limits, any small negative eigenvalues are clipped to $0$. Let $\\lambda_{\\max}$ and $\\lambda_{\\min}$ be the largest and smallest non-negative eigenvalues, respectively. The sloppiness metric $s$ is the ratio of these eigenvalues:\n    $$\n    s = \\frac{\\lambda_{\\min}}{\\lambda_{\\max}}\n    $$\n    A small value of $s$ (i.e., $s \\ll 1$) indicates sloppiness, meaning that some parameter combinations are very poorly constrained by the data, while others are well-constrained. As a special case, if $\\lambda_{\\max}$ is numerically zero (less than $10^{-15}$), the sloppiness is defined as $s = 0.0$.\n\nThe implementation will apply this four-step procedure to each of the four test cases provided, yielding four distinct sloppiness values, which are then formatted as required.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef _calculate_sloppiness_for_case(case_data):\n    \"\"\"\n    Calculates the sloppiness metric for a single case.\n    \"\"\"\n    theta, L, S_tot, sigma, t_points = case_data\n    num_params = len(theta)\n    num_t_points = len(t_points)\n    \n    # Ensure t_points are sorted and include 0 if not present for integration span\n    t_points_sorted = np.sort(list(set(np.union1d([0], t_points))))\n    t_span = (0, t_points_sorted[-1])\n\n    def model_odes(t, y, current_theta, L_val, Stot_val):\n        \"\"\"Defines the system of ODEs.\"\"\"\n        R, C, P = y\n        k_on, k_off, k_int, k_p, k_dp, k_syn, k_deg = current_theta\n        \n        dR_dt = k_syn - k_deg * R - k_on * L_val * R + k_off * C\n        dC_dt = k_on * L_val * R - (k_off + k_int) * C\n        dP_dt = k_p * C * (Stot_val - P) - k_dp * P\n        \n        return [dR_dt, dC_dt, dP_dt]\n\n    def solve_for_p(params, t_eval_points):\n        \"\"\"Solves the ODE system and returns the P(t) trajectory.\"\"\"\n        k_syn, k_deg = params[5], params[6]\n        R0 = k_syn / k_deg if k_deg > 0 else 0\n        y0 = [R0, 0, 0]\n        \n        sol = solve_ivp(\n            fun=model_odes,\n            t_span=t_span,\n            y0=y0,\n            args=(params, L, S_tot),\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n        \n        # Check if requested times are different from sorted times for indexing\n        if not np.array_equal(t_eval_points, t_points_sorted):\n            # We need to evaluate at the original t_points, which might not be sorted\n            # and might not start at 0.\n            p_values = sol.sol(t_eval_points)[2]\n            return p_values\n            \n        # If t_points was already sorted and contained 0, we need to map solution points\n        # to the original t_points.\n        sol_t = sol.t\n        p_at_sol_t = sol.y[2]\n        # Interpolate to find values at original t_points\n        p_values = np.interp(t_eval_points, sol_t, p_at_sol_t)\n        return p_values\n\n    # Get base trajectory for P(t)\n    p_base = solve_for_p(theta, t_points)\n    \n    # Initialize sensitivity matrix\n    J = np.zeros((num_t_points, num_params))\n\n    # Calculate sensitivities for each parameter\n    for i in range(num_params):\n        theta_i = theta[i]\n        delta_i = max(1e-8, 1e-6 * theta_i)\n\n        if theta_i >= delta_i: # Use central difference\n            theta_plus = np.copy(theta)\n            theta_plus[i] += delta_i\n            p_plus = solve_for_p(theta_plus, t_points)\n            \n            theta_minus = np.copy(theta)\n            theta_minus[i] -= delta_i\n            p_minus = solve_for_p(theta_minus, t_points)\n            \n            J[:, i] = (p_plus - p_minus) / (2 * delta_i)\n        else: # Use forward difference\n            theta_plus = np.copy(theta)\n            theta_plus[i] += delta_i\n            p_plus = solve_for_p(theta_plus, t_points)\n            \n            J[:, i] = (p_plus - p_base) / delta_i\n\n    # Calculate Fisher Information Matrix (FIM)\n    FIM = (1 / sigma**2) * (J.T @ J)\n    \n    # Calculate eigenvalues\n    eigenvalues = np.linalg.eigvalsh(FIM)\n    \n    # Clip small negative eigenvalues to zero\n    eigenvalues[eigenvalues < 0] = 0\n    \n    # Sort eigenvalues\n    eigenvalues = np.sort(eigenvalues)\n    \n    lambda_min = eigenvalues[0]\n    lambda_max = eigenvalues[-1]\n    \n    # Calculate sloppiness\n    if lambda_max < 1e-15:\n        s = 0.0\n    else:\n        s = lambda_min / lambda_max\n        \n    return s\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]), # theta\n            10.0, # L\n            100.0, # S_tot\n            1.0, # sigma\n            np.array([0, 50, 100, 200, 400, 800]) # t\n        ),\n        # Case 2\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]),\n            10.0,\n            100.0,\n            1.0,\n            np.array([1000, 2000, 4000, 8000])\n        ),\n        # Case 3\n        (\n            np.array([1e-3, 1e-2, 5e-3, 2e-3, 1e-2, 1e-2, 2e-3]),\n            0.01,\n            100.0,\n            1.0,\n            np.array([0, 50, 100, 200, 400, 800])\n        ),\n        # Case 4\n        (\n            np.array([5e-3, 5e-3, 1e-3, 5e-3, 5e-3, 2e-2, 1e-3]),\n            20.0,\n            100.0,\n            0.5,\n            np.array([10, 20, 40, 80, 160, 320])\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        sloppiness = _calculate_sloppiness_for_case(case)\n        results.append(sloppiness)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}