{
    "hands_on_practices": [
        {
            "introduction": "心房肌细胞电生理的计算模型建立在对单个离子通道行为的精确描述之上。本练习的核心是模拟一个关键起搏电流（如$I_f$）的门控动力学，这是Hodgkin-Huxley模型的基石。通过这个实践，您将学习如何解析求解门控变量的微分方程，并将其预测与模拟的实验数据进行比较，这是验证和优化离子通道模型的关键技能。",
            "id": "3927781",
            "problem": "考虑在电压钳下测量的窦房结 (SAN) 起搏电流的一个 Hodgkin–Huxley (HH) 风格的门控变量。该门控变量记作 $x(t)$，在电压钳条件下根据一级动力学演化：\n$$\n\\frac{dx}{dt} = \\frac{x_{\\infty}(V(t)) - x(t)}{\\tau_x(V(t))},\n$$\n其中 $V(t)$ 是指令电压，$x_{\\infty}(V)$ 是门控在电压 $V$ 下的稳态值，而 $\\tau_x(V)$ 是在电压 $V$ 下趋近稳态的时间常数。在一个阶跃钳实验中，指令电压为\n$$\nV(t) = \\begin{cases} V_{\\text{pre}}, & t < 0 \\\\ V_{\\text{step}}, & t \\ge 0 \\end{cases}\n$$\n并且假设系统在阶跃之前处于稳态，即 $x(0) = x_{\\infty}(V_{\\text{pre}})$。\n\n对稳态和时间常数函数使用以下科学上合理的形式（与窦房结中超极化激活的环核苷酸门控通道的行为一致）：\n$$\nx_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(\\frac{V - V_{1/2}}{k}\\right)}, \\quad \\tau_x(V) = \\tau_{\\min} + \\frac{\\tau_{\\text{amp}}}{1 + \\exp\\left(\\frac{V - V_{\\tau}}{k_{\\tau}}\\right)}.\n$$\n使用以下参数值：\n$$\nV_{1/2} = -75 \\text{ mV}, \\quad k = 7 \\text{ mV}, \\quad \\tau_{\\min} = 20 \\text{ ms}, \\quad \\tau_{\\text{amp}} = 200 \\text{ ms}, \\quad V_{\\tau} = -80 \\text{ mV}, \\quad k_{\\tau} = 10 \\text{ mV}.\n$$\n\n任务：\n1. 从电压钳下的一级动力学出发，推导在从 $V_{\\text{pre}}$ 到 $V_{\\text{step}}$ 的阶跃以及初始条件 $x(0) = x_{\\infty}(V_{\\text{pre}})$ 之后，$t \\ge 0$ 的激活时间进程 $x(t)$。将你推导的 $x(t)$ 用 $x_{\\infty}(V_{\\text{step}})$、$\\tau_x(V_{\\text{step}})$ 和 $x_{\\infty}(V_{\\text{pre}})$ 明确表示。\n2. 使用推导出的 $x(t)$，为一组测试用例计算在指定时间点的预测激活时间进程。\n3. 对于每个测试用例，评估模型与如下定义的假设测量数据的拟合度。在时间点 $t_i$ 的假设数据 $y_{\\text{meas}}(t_i)$ 由以下公式生成：\n$$\ny_{\\text{meas}}(t_i) = x_{\\text{data}}(t_i) + a \\sin\\left(\\frac{2\\pi t_i}{T}\\right),\n$$\n其中 $x_{\\text{data}}(t)$ 使用相同的 $x_{\\infty}(V)$ 计算，但时间常数经过缩放，即 $\\tau_{\\text{data}}(V_{\\text{step}}) = s \\cdot \\tau_x(V_{\\text{step}})$。正弦函数的参数以弧度为单位。每个测试用例均提供振幅 $a$ 和周期 $T$。计算模型预测值 $x(t_i)$ 与假设数据 $y_{\\text{meas}}(t_i)$ 之间的均方根误差 (RMSE)：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(x(t_i) - y_{\\text{meas}}(t_i)\\right)^2},\n$$\n其中 $N$ 是测试用例中时间点的数量。\n\n物理和数值单位：\n- 电压 $V$ 必须以 $\\text{mV}$ 为单位处理。\n- 时间 $t$ 必须以 $\\text{ms}$ 为单位处理。\n- 正弦函数的参数必须以弧度为单位。\n- 门控变量的值是无量纲的。\n\n测试套件：\n对于下面的每个测试用例，实现上述计算。使用所提供的 $V_{\\text{pre}}$、$V_{\\text{step}}$、时间点列表 $\\{t_i\\}$、用于数据时间常数的缩放因子 $s$、正弦波振幅 $a$ 和正弦波周期 $T$。\n\n- 测试用例 A (正常路径，超极化阶跃)：\n  - $V_{\\text{pre}} = -50 \\text{ mV}$，\n  - $V_{\\text{step}} = -80 \\text{ mV}$，\n  - 时间点 $\\{t_i\\} = [\\,0,\\,20,\\,40,\\,60,\\,80,\\,100,\\,150,\\,200,\\,300,\\,500,\\,800\\,] \\text{ ms}$，\n  - $s = 1.1$，\n  - $a = 0.02$，\n  - $T = 200 \\text{ ms}$。\n\n- 测试用例 B (边界情况，零阶跃幅度)：\n  - $V_{\\text{pre}} = -60 \\text{ mV}$，\n  - $V_{\\text{step}} = -60 \\text{ mV}$，\n  - 时间点 $\\{t_i\\} = [\\,0,\\,10,\\,20,\\,50,\\,100,\\,200,\\,400\\,] \\text{ ms}$，\n  - $s = 1.0$，\n  - $a = 0.01$，\n  - $T = 100 \\text{ ms}$。\n\n- 测试用例 C (强超极化，更快的数据动力学)：\n  - $V_{\\text{pre}} = -60 \\text{ mV}$，\n  - $V_{\\text{step}} = -100 \\text{ mV}$，\n  - 时间点 $\\{t_i\\} = [\\,0,\\,25,\\,50,\\,75,\\,100,\\,150,\\,250,\\,400,\\,700\\,] \\text{ ms}$，\n  - $s = 0.8$，\n  - $a = 0.015$，\n  - $T = 300 \\text{ ms}$。\n\n- 测试用例 D (去极化阶跃，失活)：\n  - $V_{\\text{pre}} = -80 \\text{ mV}$，\n  - $V_{\\text{step}} = -40 \\text{ mV}$，\n  - 时间点 $\\{t_i\\} = [\\,0,\\,10,\\,30,\\,60,\\,90,\\,120,\\,200,\\,400\\,] \\text{ ms}$，\n  - $s = 1.3$，\n  - $a = 0.02$，\n  - $T = 150 \\text{ ms}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含测试用例 A、B、C 和 D 的 RMSE 值，按此顺序排列，形式为一个用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数（例如，$[0.123456,0.234567,0.345678,0.456789]$）。不应打印任何额外的文本。最终输出值是无量纲的。",
            "solution": "该问题要求分析在电压钳方案下，一个窦房结起搏电流的 Hodgkin-Huxley 风格门控变量 $x(t)$。解决方案包括三个主要部分：首先，推导门控变量时间进程 $x(t)$ 的解析解；其次，使用该解计算系统的预测行为；第三，将此预测与人工生成的数据进行比较，以使用均方根误差 (RMSE) 来量化模型误差。\n\n### 第 1 部分：门控变量时间进程的解析解\n门控变量 $x(t)$ 的演化由以下一阶常微分方程 (ODE) 控制：\n$$\n\\frac{dx}{dt} = \\frac{x_{\\infty}(V(t)) - x(t)}{\\tau_x(V(t))}\n$$\n实验方案是阶跃钳，其中电压 $V(t)$ 在 $t < 0$ 时保持在 $V_{\\text{pre}}$，并在 $t \\ge 0$ 时阶跃至 $V_{\\text{step}}$。假设系统在阶跃前处于稳态，这提供了初始条件 $x(0) = x_{\\infty}(V_{\\text{pre}})$。\n\n对于 $t \\ge 0$，电压是恒定的，$V(t) = V_{\\text{step}}$。因此，稳态值 $x_{\\infty}(V_{\\text{step}})$ 和时间常数 $\\tau_x(V_{\\text{step}})$ 也是常数。为简洁起见，我们分别将它们表示为 $x_{\\infty, \\text{step}}$ 和 $\\tau_{\\text{step}}$。该 ODE 简化为：\n$$\n\\frac{dx}{dt} = \\frac{x_{\\infty, \\text{step}} - x}{\\tau_{\\text{step}}}\n$$\n这是一个一阶线性非齐次常微分方程。它可以重排为标准形式 $\\frac{dx}{dt} + P(t)x = Q(t)$：\n$$\n\\frac{dx}{dt} + \\frac{1}{\\tau_{\\text{step}}}x = \\frac{x_{\\infty, \\text{step}}}{\\tau_{\\text{step}}}\n$$\n这类方程的解描述了从一个初始值到最终稳态值的指数松弛过程。其通解形式为：\n$$\nx(t) = x_{\\text{particular}} + x_{\\text{homogeneous}} = A + C \\exp\\left(-\\frac{t}{\\tau_{\\text{step}}}\\right)\n$$\n特解是当 $t \\to \\infty$ 时的稳态，即 $x(t) = x_{\\infty, \\text{step}}$。因此，$A = x_{\\infty, \\text{step}}$。\n$$\nx(t) = x_{\\infty, \\text{step}} + C \\exp\\left(-\\frac{t}{\\tau_{\\text{step}}}\\right)\n$$\n积分常数 $C$ 由 $t=0$ 时的初始条件确定。给定条件为 $x(0) = x_{\\infty}(V_{\\text{pre}})$。我们将其记为 $x_{\\infty, \\text{pre}}$。\n$$\nx(0) = x_{\\infty, \\text{pre}} = x_{\\infty, \\text{step}} + C \\exp(0) = x_{\\infty, \\text{step}} + C\n$$\n解出 $C$ 可得：\n$$\nC = x_{\\infty, \\text{pre}} - x_{\\infty, \\text{step}}\n$$\n将此代回通解，得到 $t \\ge 0$ 时 $x(t)$ 的特定解：\n$$\nx(t) = x_{\\infty, \\text{step}} + (x_{\\infty, \\text{pre}} - x_{\\infty, \\text{step}}) \\exp\\left(-\\frac{t}{\\tau_{\\text{step}}}\\right)\n$$\n这可以明确地用依赖于电压的函数写成：\n$$\nx(t) = x_{\\infty}(V_{\\text{step}}) + (x_{\\infty}(V_{\\text{pre}}) - x_{\\infty}(V_{\\text{step}})) \\exp\\left(-\\frac{t}{\\tau_x(V_{\\text{step}})}\\right)\n$$\n这个方程描述了门控变量的激活（或失活）时间进程，从其初始稳态值开始，以由阶跃电压决定的时间常数指数趋近其新的稳态值。\n\n### 第 2 部分：RMSE 计算策略\n该问题要求计算在一系列时间点 $\\{t_i\\}$ 上，模型预测值 $x(t_i)$ 与假设的测量数据 $y_{\\text{meas}}(t_i)$ 之间的均方根误差 (RMSE)。\n\n每个时间点 $t_i$ 的模型预测值 $x(t_i)$ 是使用给定的模型参数，直接从推导出的解析解计算得出的。\n\n假设数据 $y_{\\text{meas}}(t_i)$ 由两部分构成：\n1.  一个基本分量 $x_{\\text{data}}(t_i)$，它遵循相同的物理过程，但具有不同的时间常数 $\\tau_{\\text{data}}(V_{\\text{step}}) = s \\cdot \\tau_x(V_{\\text{step}})$。因此其时间进程为：\n    $$\n    x_{\\text{data}}(t_i) = x_{\\infty}(V_{\\text{step}}) + (x_{\\infty}(V_{\\text{pre}}) - x_{\\infty}(V_{\\text{step}})) \\exp\\left(-\\frac{t_i}{s \\cdot \\tau_x(V_{\\text{step}})}\\right)\n    $$\n2.  一个附加的正弦噪声项 $a \\sin\\left(\\frac{2\\pi t_i}{T}\\right)$。\n\n将这两部分结合起来，得到假设数据的完整表达式：\n$$\ny_{\\text{meas}}(t_i) = x_{\\text{data}}(t_i) + a \\sin\\left(\\frac{2\\pi t_i}{T}\\right)\n$$\n每个时间点的误差是差值 $e_i = x(t_i) - y_{\\text{meas}}(t_i)$。代入 $x(t_i)$ 和 $y_{\\text{meas}}(t_i)$ 的表达式，误差项变为：\n$$\ne_i = (x_{\\infty}(V_{\\text{step}}) - x_{\\infty}(V_{\\text{pre}})) \\left[ \\exp\\left(-\\frac{t_i}{s \\cdot \\tau_x(V_{\\text{step}})}\\right) - \\exp\\left(-\\frac{t_i}{\\tau_x(V_{\\text{step}})}\\right) \\right] - a \\sin\\left(\\frac{2\\pi t_i}{T}\\right)\n$$\n这突显了差异的两个来源：由于缩放因子 $s$ 导致的指数衰减率差异，以及正弦噪声。\n\n最后，根据其定义计算 RMSE：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (e_i)^2} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(x(t_i) - y_{\\text{meas}}(t_i)\\right)^2}\n$$\n其中 $N$ 是时间点的数量。\n\n### 第 3 部分：算法实现\n该实现将使用 Python 的 `numpy` 库进行高效的向量化计算。总体算法如下：\n1.  定义模型参数（$V_{1/2}$、$k$ 等）和每个测试用例的参数（$V_{\\text{pre}}$、$V_{\\text{step}}$、$\\{t_i\\}$ 等）。\n2.  实现两个函数 `x_inf(V)` 和 `tau_x(V)`，分别对应 $x_{\\infty}(V)$ 和 $\\tau_x(V)$ 的数学定义。\n3.  遍历每个测试用例。对于每个用例：\n    a. 确定 $x_{\\infty, \\text{pre}} = x_{\\infty}(V_{\\text{pre}})$、$x_{\\infty, \\text{step}} = x_{\\infty}(V_{\\text{step}})$ 和 $\\tau_{\\text{step}} = \\tau_x(V_{\\text{step}})$ 的值。\n    b. 为时间点 $\\{t_i\\}$ 创建一个 `numpy` 数组。\n    c. 将推导出的 $x(t)$ 解析解应用于时间点数组，计算预测模型值的向量 `x_pred`。\n    d. 计算假设数据值的向量 `y_meas`。这包括首先使用缩放的时间常数 $\\tau_{\\text{data}} = s \\cdot \\tau_{\\text{step}}$ 计算 `x_data` 分量，然后加上计算出的正弦噪声项。\n    e. 通过计算 `x_pred` 和 `y_meas` 向量之间差的平方的 `numpy.mean`，再取其 `numpy.sqrt` 来计算 RMSE。\n4.  收集所有测试用例的 RMSE 值。\n5.  将收集到的结果格式化为指定的字符串格式：一个用方括号括起来的逗号分隔列表，其中浮点数四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the RMSE between a Hodgkin-Huxley gating variable\n    model and synthetic data for several voltage-clamp test cases.\n    \"\"\"\n    # Define model parameters as specified in the problem statement.\n    V_HALF = -75.0\n    K = 7.0\n    TAU_MIN = 20.0\n    TAU_AMP = 200.0\n    V_TAU = -80.0\n    K_TAU = 10.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"Test Case A\",\n            \"V_pre\": -50.0,\n            \"V_step\": -80.0,\n            \"times\": np.array([0, 20, 40, 60, 80, 100, 150, 200, 300, 500, 800], dtype=float),\n            \"s\": 1.1,\n            \"a\": 0.02,\n            \"T\": 200.0,\n        },\n        {\n            \"name\": \"Test Case B\",\n            \"V_pre\": -60.0,\n            \"V_step\": -60.0,\n            \"times\": np.array([0, 10, 20, 50, 100, 200, 400], dtype=float),\n            \"s\": 1.0,\n            \"a\": 0.01,\n            \"T\": 100.0,\n        },\n        {\n            \"name\": \"Test Case C\",\n            \"V_pre\": -60.0,\n            \"V_step\": -100.0,\n            \"times\": np.array([0, 25, 50, 75, 100, 150, 250, 400, 700], dtype=float),\n            \"s\": 0.8,\n            \"a\": 0.015,\n            \"T\": 300.0,\n        },\n        {\n            \"name\": \"Test Case D\",\n            \"V_pre\": -80.0,\n            \"V_step\": -40.0,\n            \"times\": np.array([0, 10, 30, 60, 90, 120, 200, 400], dtype=float),\n            \"s\": 1.3,\n            \"a\": 0.02,\n            \"T\": 150.0,\n        },\n    ]\n\n    def x_inf(V, V_half_param, k_param):\n        \"\"\"Calculates the steady-state value of the gating variable.\"\"\"\n        return 1.0 / (1.0 + np.exp((V - V_half_param) / k_param))\n\n    def tau_x(V, tau_min_param, tau_amp_param, V_tau_param, k_tau_param):\n        \"\"\"Calculates the time constant of the gating variable.\"\"\"\n        return tau_min_param + tau_amp_param / (1.0 + np.exp((V - V_tau_param) / k_tau_param))\n\n    def x_t_analytical(t_arr, x_inf_pre_val, x_inf_step_val, tau_step_val):\n        \"\"\"Calculates the time course of the gating variable using the analytical solution.\"\"\"\n        delta_x = x_inf_step_val - x_inf_pre_val\n        # The equation relies on a non-zero time constant.\n        if tau_step_val == 0:\n            # This case is not expected with the given tau_x function.\n            # If t=0, exp is 1, so x(0) = x_inf_step - delta_x = x_inf_pre.\n            # If t > 0 and tau=0, this implies instantaneous change, so x(t)=x_inf_step.\n            # For simplicity and given the model constraints, we assume tau > 0.\n            # A more robust implementation might handle this, but it is outside problem scope.\n            pass\n        return x_inf_step_val - delta_x * np.exp(-t_arr / tau_step_val)\n\n    rmse_results = []\n    for case in test_cases:\n        V_pre = case[\"V_pre\"]\n        V_step = case[\"V_step\"]\n        times = case[\"times\"]\n        s = case[\"s\"]\n        a = case[\"a\"]\n        T = case[\"T\"]\n\n        # Calculate values needed for the analytical solution\n        x_inf_pre_val = x_inf(V_pre, V_HALF, K)\n        x_inf_step_val = x_inf(V_step, V_HALF, K)\n        tau_step_model = tau_x(V_step, TAU_MIN, TAU_AMP, V_TAU, K_TAU)\n        \n        # 1. Compute the predicted time course x(t_i) from the model\n        x_pred = x_t_analytical(times, x_inf_pre_val, x_inf_step_val, tau_step_model)\n\n        # 2. Generate the hypothetical measurement data y_meas(t_i)\n        # It is based on a scaled time constant\n        tau_step_data = s * tau_step_model\n        x_data_component = x_t_analytical(times, x_inf_pre_val, x_inf_step_val, tau_step_data)\n        \n        # Add sinusoidal noise\n        sinusoidal_noise = a * np.sin(2.0 * np.pi * times / T)\n        y_meas = x_data_component + sinusoidal_noise\n        \n        # 3. Compute the Root-Mean-Square Error (RMSE)\n        squared_errors = (x_pred - y_meas)**2\n        mean_squared_error = np.mean(squared_errors)\n        rmse = np.sqrt(mean_squared_error)\n        \n        rmse_results.append(f\"{rmse:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(rmse_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "将单个离子通道的动力学特性整合为完整的细胞模型，是理解自发性心律（即起搏）的关键一步。本练习将指导您构建一个简化的“整合-发放”起搏细胞模型，用以探究“滑稽电流”（$I_f$）如何驱动舒张期去极化，并模拟药物（如伊伐布雷定）如何通过阻断此电流来调节起搏频率。这个过程清晰地展示了从通道特性到细胞功能和药理学应用的联系。",
            "id": "3927789",
            "problem": "要求您构建一个自洽的计算实验，以量化抗心律失常药物 ivabradine 如何通过降低最大 f-电流电导或诱导状态依赖性通道阻断，来改变一个简化的窦房结 (SA) 节点模型的自发放电速率。该模型必须从第一性原理推导，并进行数值求解。最终输出必须是您的程序生成的单行文本，其中包含针对指定的一组测试参数集计算出的自发放电速率，单位为赫兹。\n\n基本和模型假设：\n\n- 膜被建模为一个理想电容器，电容为 $C_m$，受离子电流影响，遵循电容器定律 $C_m \\, dV/dt = - I_{\\text{ion}}$。膜电位为 $V$（单位：毫伏），时间为 $t$（单位：毫秒）。自发活动由一个“整合-发放”理想化模型表示：当 $V$ 达到阈值 $V_{\\text{th}}$ 时，即发生一次峰电位，并且 $V$ 被瞬时重置为 $V_{\\text{reset}}$ 以开始下一个周期。\n- 唯一明确建模的电压依赖性电流是超极化激活电流 ($I_f$)，由超极化激活的环核苷酸门控 (HCN) 通道携带，而所有其他电流则保持固定并聚合成一个恒定的背景电流 $I_{\\text{bg}}$。\n- f-电流以 Hodgkin–Huxley 形式建模：\n  $$ I_f = \\bar{g}_f \\, f \\, (V - E_f), $$\n  其中 $\\bar{g}_f$ 是最大 $I_f$ 电导（单位：纳西门子），$E_f$ 是反转电位（单位：毫伏），$f$ 是激活门控（无量纲）。门控 $f$ 遵循一级动力学：\n  $$ \\frac{df}{dt} = \\frac{f_{\\infty}(V) - f}{\\tau_f(V)}, \\quad f_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(\\frac{V - V_{1/2}}{k_f}\\right)}, $$\n  其中 $V_{1/2}$ 是半激活电压，$k_f$ 是斜率因子。为简化起见，将 $\\tau_f(V)$ 视为常数。\n- Ivabradine 的作用以两种不同方式建模，每个测试用例分别应用其中一种：\n  1. 电导缩放：最大电导的分数性降低 $\\alpha$ 产生有效电导\n     $$ \\bar{g}_f^{\\text{eff}} = (1 - \\alpha) \\, \\bar{g}_f, \\quad \\alpha \\in [0,1]. $$\n  2. 状态依赖性阻断：通道以与开放概率代理 $f$ 成正比的速率转换到药物结合的阻断状态，其中阻断分数 $x$ 遵循\n     $$ \\frac{dx}{dt} = k_{\\text{on}} \\, f \\, (1 - x) - k_{\\text{off}} \\, x, $$\n     给出有效电导\n     $$ \\bar{g}_f^{\\text{eff}} = \\bar{g}_f \\, (1 - x). $$\n  此处 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 是速率常数（单位：毫秒的倒数）。药物被假定不直接改变 $f_{\\infty}(V)$ 或 $\\tau_f(V)$。\n- 在任一种 ivabradine 模型下，完整的电压动力学为\n  $$ \\frac{dV}{dt} = -\\frac{I_{\\text{bg}} + \\bar{g}_f^{\\text{eff}} \\, f \\, (V - E_f)}{C_m}. $$\n\n算法要求：\n\n- 对于状态依赖性阻断情况，初始化 $V(0) = V_{\\text{reset}}$、$f(0) = f_{\\infty}(V_{\\text{reset}})$ 和 $x(0) = 0$。使用固定的时间步长 $\\Delta t$ 和显式更新方法，对耦合常微分方程进行时间上的前向积分。当 $V$ 穿过 $V_{\\text{th}}$ 时，记录峰电位时间，立即将 $V$ 重置为 $V_{\\text{reset}}$，并继续积分。如果存在第三次和第二次峰电位，则将它们之间的峰间期计算为周期长度；否则使用第二次和第一次峰电位之间的间隔。如果在模拟时限内发生的峰电位少于两次，则返回 $0.0$ 赫兹的自发放电速率。\n- 自发放电速率定义为周期长度（以秒为单位）的倒数：\n  $$ \\text{rate (Hz)} = \\frac{1000}{\\text{cycle length (ms)}}. $$\n\n在所有测试用例中使用以下固定参数（已指定单位）：\n\n- $C_m = 40$ pF (皮法)。\n- $\\bar{g}_f = 0.12$ nS (纳西门子)。\n- $E_f = -20$ mV (毫伏)。\n- $I_{\\text{bg}} = -0.8$ pA (皮安)。\n- $V_{1/2} = -70$ mV, $k_f = 7$ mV。\n- $\\tau_f = 100$ ms (毫秒)。\n- $V_{\\text{th}} = -40$ mV, $V_{\\text{reset}} = -60$ mV。\n- 时间步长 $\\Delta t = 0.05$ ms；最大模拟时间 $T_{\\max} = 5000$ ms。\n\n测试套件：\n\n每个测试用例是一个形式为 $(\\text{model}, p_1, p_2)$ 的元组，其中 $\\text{model}$ 是字符串 \"scale\" 或 \"block\"。对于 \"scale\"，$p_1 = \\alpha$ 是分数性降低值，$p_2$ 被忽略。对于 \"block\"，$p_1 = k_{\\text{on}}$ 且 $p_2 = k_{\\text{off}}$。\n\n使用以下六个测试用例：\n\n1. $(\\text{\"scale\"}, 0.0, 0.0)$ 基线，无 ivabradine (有效 $\\bar{g}_f$ 不变)。\n2. $(\\text{\"scale\"}, 0.5, 0.0)$ $\\bar{g}_f$ 中度降低。\n3. $(\\text{\"scale\"}, 1.0, 0.0)$ 完全消除 $\\bar{g}_f$。\n4. $(\\text{\"block\"}, 0.002, 0.0005)$ 慢起始、部分阻断。\n5. $(\\text{\"block\"}, 0.02, 0.005)$ 快起始、更强阻断。\n6. $(\\text{\"block\"}, 0.0001, 0.01)$ 可忽略的阻断（解离占主导）。\n\n答案规格：\n\n- 您的程序必须计算每个测试用例的自发放电速率，单位为赫兹，并四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，“[1.234,2.345,3.456,4.567,5.678,6.789]”。",
            "solution": "问题陈述已经过分析，被认为是有效的。它在科学上基于细胞电生理学的既定原理，特别是用于离子通道的 Hodgkin-Huxley 形式主义和用于起搏的整合-发放模型。该问题是适定的，提供了一整套参数、初始条件、模型方程和一个清晰的数值方案以产生唯一的、可计算的结果。所有术语都得到了客观且明确的定义。指定的单位是一致的。\n\n**1. 模型构建**\n\n该模型描述了一个简化的窦房结细胞的膜电位 $V$。其动力学由一个常微分方程 (ODE) 组控制。核心原理是电容器定律，该定律指出膜电位的变化率与流过膜电容 $C_m$ 的总离子电流 $I_{\\text{ion}}$ 成正比。\n\n膜电位 $V$（单位：mV）随时间 $t$（单位：ms）变化的控制方程是：\n$$ \\frac{dV}{dt} = -\\frac{I_{\\text{ion}}}{C_m} $$\n总离子电流 $I_{\\text{ion}}$ 是恒定背景电流 $I_{\\text{bg}}$ 和电压依赖性 f-电流 $I_f$ 的和：\n$$ I_{\\text{ion}} = I_{\\text{bg}} + I_f $$\nf-电流 $I_f$ 建模为：\n$$ I_f = \\bar{g}_f^{\\text{eff}} \\, f \\, (V - E_f) $$\n其中 $\\bar{g}_f^{\\text{eff}}$ 是有效最大电导（单位：nS），$f$ 是一个无量纲的激活门控，$E_f$ 是反转电位（单位：mV）。负电流对应于正电荷的净内流（去极化）。$dV/dt$ 的方程在 $I_{\\text{ion}}$ 前包含一个负号，正确地将净内向电流转换为正的 $dV/dt$。单位（pF, pA, nS, mV, ms）在量纲上是一致的，因为 $\\text{pA}/\\text{pF} = (\\text{A}/\\text{F}) = \\text{V}/\\text{s}$，且 $\\text{mV}/\\text{ms} = (10^{-3}\\text{V})/(10^{-3}\\text{s}) = \\text{V}/\\text{s}$。\n\n激活门控 $f$ 遵循一级动力学：\n$$ \\frac{df}{dt} = \\frac{f_{\\infty}(V) - f}{\\tau_f} $$\n其中 $\\tau_f$ 是一个恒定的时间常数（单位：ms），$f_{\\infty}(V)$ 是电压依赖的稳态激活函数：\n$$ f_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(\\frac{V - V_{1/2}}{k_f}\\right)} $$\n此处，$V_{1/2}$ 是半激活电压，$k_f$ 是斜率因子。\n\n**2. Ivabradine 作用的建模**\n\n对 ivabradine 在 $\\bar{g}_f^{\\text{eff}}$ 上的作用使用了两个独立的模型：\n\n- **模型 1：电导缩放 (\"scale\")**\n该模型假设最大电导 $\\bar{g}_f$ 有一个简单的分数性降低 $\\alpha$：\n$$ \\bar{g}_f^{\\text{eff}} = (1 - \\alpha) \\bar{g}_f $$\n\n- **模型 2：状态依赖性阻断 (\"block\")**\n该模型引入了第三个状态变量 $x$，表示被阻断通道的分数。$x$ 的动力学由下式给出：\n$$ \\frac{dx}{dt} = k_{\\text{on}} \\, f \\, (1 - x) - k_{\\text{off}} \\, x $$\n其中 $k_{\\text{on}}$ 和 $k_{\\text{off}}$ 分别是结合和解离速率常数（单位：ms$^{-1}$）。阻断依赖于通道的开放状态，由激活变量 $f$ 作为代理。那么有效电导为：\n$$ \\bar{g}_f^{\\text{eff}} = \\bar{g}_f (1 - x) $$\n\n**3. 数值解和自发放电速率计算**\n\n该耦合 ODE 系统使用固定时间步长 $\\Delta t$ 的显式（前向）欧拉方法进行数值求解。设 $V_n$、$f_n$ 和 $x_n$ 为时间步 $n$ 处的值。时间步 $n+1$ 处的值计算如下：\n$$ V_{n+1} = V_n + \\Delta t \\cdot \\left( -\\frac{I_{\\text{bg}} + \\bar{g}_f^{\\text{eff}, n} \\, f_n \\, (V_n - E_f)}{C_m} \\right) $$\n$$ f_{n+1} = f_n + \\Delta t \\cdot \\left( \\frac{f_{\\infty}(V_n) - f_n}{\\tau_f} \\right) $$\n对于 \"block\" 模型，我们还计算：\n$$ x_{n+1} = x_n + \\Delta t \\cdot (k_{\\text{on}} f_n (1 - x_n) - k_{\\text{off}} x_n) $$\n注意 $\\bar{g}_f^{\\text{eff}, n}$ 取决于模型：对于 \"scale\" 模型，它是一个常数；对于 \"block\" 模型，它是 $\\bar{g}_f(1-x_n)$。\n\n模拟按以下逻辑进行：\n- **初始化**：在 $t=0$ 时，$V(0)=V_{\\text{reset}}$，$f(0)=f_{\\infty}(V_{\\text{reset}})$，以及 $x(0)=0$。\n- **积分和峰电位发放**：系统随时间向前积分。在每个时间步，更新状态变量后，进行检查：如果 $V_{n+1} \\geq V_{\\text{th}}$。\n- **重置**：如果超过阈值，当前时间 $t_{n+1}$ 被记录为峰电位时间。然后在下一个积分步骤开始前，电压被瞬时重置为 $V=V_{\\text{reset}}$。门控变量 $f$ 和 $x$ 不被重置。\n- **周期长度和速率**：模拟运行最大持续时间 $T_{\\max}$。模拟结束后，分析记录的峰电位时间列表。周期长度是第三次和第二次峰电位之间的时间差。如果只发生了两次峰电位，则使用第二次和第一次之间的时间差。自发放电速率（单位：赫兹，Hz）则为 $1000 / \\text{周期长度 (ms)}$。如果检测到的峰电位少于两个，速率为 $0.0$ Hz。\n\n模型和模拟的具体参数如下：\n- $C_m = 40$ pF, $\\bar{g}_f = 0.12$ nS, $E_f = -20$ mV, $I_{\\text{bg}} = -0.8$ pA。\n- $V_{1/2} = -70$ mV, $k_f = 7$ mV, $\\tau_f = 100$ ms。\n- $V_{\\text{th}} = -40$ mV, $V_{\\text{reset}} = -60$ mV。\n- $\\Delta t = 0.05$ ms, $T_{\\max} = 5000$ ms。\n\n该计算实验将对问题陈述中指定的六个测试用例中的每一个执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the sinoatrial node simulation for all test cases\n    and print the results in the specified format.\n    \"\"\"\n\n    # --- Test Suite ---\n    # Each case: (model_type, param1, param2)\n    # \"scale\": param1 = alpha, param2 is ignored\n    # \"block\": param1 = k_on, param2 = k_off\n    test_cases = [\n        (\"scale\", 0.0, 0.0),\n        (\"scale\", 0.5, 0.0),\n        (\"scale\", 1.0, 0.0),\n        (\"block\", 0.002, 0.0005),\n        (\"block\", 0.02, 0.005),\n        (\"block\", 0.0001, 0.01),\n    ]\n\n    results = []\n    for case in test_cases:\n        model, p1, p2 = case\n        rate = run_simulation(model, p1, p2)\n        results.append(rate)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.3f}' for r in results)}]\")\n\n\ndef run_simulation(model: str, p1: float, p2: float) -> float:\n    \"\"\"\n    Runs a single simulation for a given model and parameter set.\n\n    Args:\n        model: \"scale\" or \"block\".\n        p1: alpha for \"scale\", k_on for \"block\".\n        p2: ignored for \"scale\", k_off for \"block\".\n\n    Returns:\n        The calculated spontaneous rate in Hertz, rounded to 3 decimal places.\n    \"\"\"\n    # --- Fixed Model Parameters ---\n    # Units: V in mV, t in ms, C in pF, g in nS, I in pA\n    Cm = 40.0       # pF\n    g_f_bar = 0.12  # nS\n    E_f = -20.0     # mV\n    I_bg = -0.8     # pA\n    V_half = -70.0  # mV\n    k_f = 7.0       # mV\n    tau_f = 100.0   # ms\n    V_th = -40.0    # mV\n    V_reset = -60.0 # mV\n\n    # --- Simulation Parameters ---\n    dt = 0.05       # ms\n    T_max = 5000.0  # ms\n    num_steps = int(T_max / dt)\n    \n    # --- Helper function for f_infinity ---\n    def f_inf(V_val):\n        return 1.0 / (1.0 + np.exp((V_val - V_half) / k_f))\n\n    # --- Initial Conditions ---\n    V = V_reset\n    f = f_inf(V_reset)\n    x = 0.0  # Blocked fraction, only used in \"block\" model\n\n    spike_times = []\n\n    # --- Integration Loop ---\n    for i in range(num_steps):\n        current_time = i * dt\n        \n        # Determine effective conductance based on the model\n        if model == \"scale\":\n            alpha = p1\n            g_f_eff = (1 - alpha) * g_f_bar\n        elif model == \"block\":\n            g_f_eff = g_f_bar * (1 - x)\n        else: # Should not happen with given test cases\n            raise ValueError(f\"Unknown model type: {model}\")\n\n        # Calculate time derivatives using explicit Euler method\n        # dV/dt = -(I_bg + I_f) / Cm\n        # I_f = g_f_eff * f * (V - E_f)\n        dV_dt = -(I_bg + g_f_eff * f * (V - E_f)) / Cm\n        \n        # df/dt = (f_inf(V) - f) / tau_f\n        df_dt = (f_inf(V) - f) / tau_f\n        \n        # Update state variables\n        V += dV_dt * dt\n        f += df_dt * dt\n        \n        # Update blocked fraction if applicable\n        if model == \"block\":\n            k_on = p1\n            k_off = p2\n            dx_dt = k_on * f * (1.0 - x) - k_off * x\n            x += dx_dt * dt\n\n        # --- Spike detection and reset ---\n        if V >= V_th:\n            spike_times.append(current_time)\n            V = V_reset\n            # A more precise method could interpolate the exact crossing time,\n            # but for a small dt this is a reasonable approximation.\n    \n    # --- Calculate Spontaneous Rate ---\n    if len(spike_times) < 2:\n        return 0.0\n    \n    if len(spike_times) >= 3:\n        # Use the interspike interval between the 2nd and 3rd spikes for stability\n        cycle_length_ms = spike_times[2] - spike_times[1]\n    else: # Exactly 2 spikes\n        # Use the first interspike interval\n        cycle_length_ms = spike_times[1] - spike_times[0]\n        \n    # Convert cycle length (ms) to rate (Hz)\n    rate_hz = 1000.0 / cycle_length_ms\n    \n    return round(rate_hz, 3)\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "一个成功的起搏器不仅需要自发地产生动作电位，还必须能够可靠地驱动周围的非起搏心房组织。这个从“源”（SAN细胞）到“汇”（心房肌）的信号传递问题是心脏电生理学中的一个核心概念。在本练习中，您将分析源-汇相互作用的简化模型，并计算确保成功传导所需的最小条件，例如SAN核心细胞的数量或细胞间的耦合电导。",
            "id": "3927796",
            "problem": "要求您为一个简化的窦房结 (SAN) 核心与心房组织之间的连接处，形式化一个用于动作电位起始的最小源-汇条件，然后根据给定的细胞特性，计算确保可靠传播所需的最小 SAN 核心大小或每细胞耦合电导。您的程序必须实现推导出的公式，并为预定义的测试套件生成结果。\n\n假设与建模基础：\n- 以 Kirchhoff 电流定律 (KCL) 和电容器方程为起点。连接处的心房组织被建模为单个等电位膜片，其具有恒定的电容 $C_A$ 和漏电导 $G_A$（对应静息电位 $E_A$）。SAN 核心被建模为 $N$ 个相同的源细胞，每个细胞通过一个在上升相期间保持恒定的间隙连接电导 $g_{\\text{gap}}$（每细胞）耦合到心房膜片。\n- 在 SAN 上升相阶段，将 SAN 源电压近似为一个在固定可用持续时间 $T_{\\text{avail}}$ 内的恒定钳制电位 $V_S$。这是一个用于评估最小源-汇条件的一阶源近似。\n- 心房膜必须在时间窗口 $T_{\\text{avail}}$ 内达到指定的电压阈值 $V_{\\text{th}}$，才能构成从 SAN 核心向外的可靠传播。\n- 所有电位均以毫伏为单位，但方程仅使用差值和无量纲比率，因此电位单位在对数中被抵消。时间通过比率 $C_A/G$ 出现，当 $C_A$ 的单位为纳法拉， $G$ 的单位为纳西门子时，该比率的单位为秒。\n\n控制方程：\n- 令 $V_A(t)$ 表示心房膜电压。根据 KCL 和电容器定律，对于 $t \\ge 0$，\n$$\nC_A \\,\\frac{dV_A}{dt} = -G_A \\,(V_A - E_A) + N\\,g_{\\text{gap}} \\,(V_S - V_A).\n$$\n这个线性、时不变一阶系统有解\n$$\nV_A(t) = V_{\\infty} - \\left(V_{\\infty} - V_{A0}\\right)\\,\\exp\\left(-\\frac{(G_A + N g_{\\text{gap}})}{C_A}\\,t\\right),\n$$\n其中 $V_{A0} = V_A(0)$ 且稳态为\n$$\nV_{\\infty} = \\frac{G_A\\,E_A + N g_{\\text{gap}}\\,V_S}{G_A + N g_{\\text{gap}}}.\n$$\n因此，达到阈值 $V_{\\text{th}}$ 所需的时间 $t_{\\text{req}}$ 为\n$$\nt_{\\text{req}}(N,g_{\\text{gap}}) = \\frac{C_A}{G_A + N g_{\\text{gap}}}\\,\\ln\\!\\left(\\frac{V_{\\infty} - V_{A0}}{V_{\\infty} - V_{\\text{th}}}\\right).\n$$\n一个必要条件是 $V_{\\infty} > V_{\\text{th}}$；如果此条件不满足，则不可能达到 $V_{\\text{th}}$。如果 $t_{\\text{req}}(N,g_{\\text{gap}}) \\le T_{\\text{avail}}$ 且 $V_{\\infty} > V_{\\text{th}}$，则实现可靠传播。\n\n计算任务：\n1) 给定固定的每细胞耦合 $g_{\\text{gap}}$，计算最小整数核心大小 $N_{\\min}$，使得 $t_{\\text{req}}(N_{\\min},g_{\\text{gap}}) \\le T_{\\text{avail}}$ 且 $V_{\\infty}(N_{\\min},g_{\\text{gap}}) > V_{\\text{th}}$。如果 $V_S \\le V_{\\text{th}}$，则声明任务不可行并返回 $-1$。\n2) 给定固定的整数核心大小 $N_{\\text{fixed}}$，计算满足 $t_{\\text{req}}(N_{\\text{fixed}},g_{\\text{gap,min}}) \\le T_{\\text{avail}}$ 且 $V_{\\infty}(N_{\\text{fixed}},g_{\\text{gap,min}}) > V_{\\text{th}}$ 的最小每细胞耦合电导 $g_{\\text{gap,min}}$（单位为纳西门子）。如果 $V_S \\le V_{\\text{th}}$，则声明不可行并返回 $-1$。报告的 $g_{\\text{gap,min}}$ 需四舍五入到三位小数。\n\n单位和角度约定：\n- 使用 $C_A$ 单位为纳法拉 (nF)，$G_A$ 和 $g_{\\text{gap}}$ 单位为纳西门子 (nS)，$V_S$、$E_A$、$V_{A0}$ 和 $V_{\\text{th}}$ 单位为毫伏 (mV)，$T_{\\text{avail}}$ 单位为秒 (s)。计算出的 $t_{\\text{req}}$ 将以秒为单位。此问题不涉及角度。\n\n测试套件：\n对于每种情况，您的程序必须使用列出的参数，并按上述规定计算 $N_{\\min}$ 和 $g_{\\text{gap,min}}$。在所有情况下，设置 $V_{A0}=E_A$。\n\n- A情况（一般情况，预计可实现可靠传播）：\n  - $C_A = 0.2$ nF, $G_A = 1.0$ nS, $E_A = -80$ mV, $V_{\\text{th}} = -55$ mV, $V_S = 10$ mV, $g_{\\text{gap}} = 0.5$ nS, $T_{\\text{avail}} = 0.005$ s, $N_{\\text{fixed}} = 5$.\n\n- B情况（可用时间更短，条件更严格）：\n  - $C_A = 0.2$ nF, $G_A = 1.0$ nS, $E_A = -80$ mV, $V_{\\text{th}} = -55$ mV, $V_S = 10$ mV, $g_{\\text{gap}} = 0.5$ nS, $T_{\\text{avail}} = 0.001$ s, $N_{\\text{fixed}} = 5$.\n\n- C情况（源较弱，但仍高于阈值）：\n  - $C_A = 0.2$ nF, $G_A = 1.0$ nS, $E_A = -80$ mV, $V_{\\text{th}} = -55$ mV, $V_S = -45$ mV, $g_{\\text{gap}} = 0.5$ nS, $T_{\\text{avail}} = 0.004$ s, $N_{\\text{fixed}} = 5$.\n\n- D情况（不可行，源低于阈值）：\n  - $C_A = 0.2$ nF, $G_A = 1.0$ nS, $E_A = -80$ mV, $V_{\\text{th}} = -55$ mV, $V_S = -60$ mV, $g_{\\text{gap}} = 1.0$ nS, $T_{\\text{avail}} = 0.010$ s, $N_{\\text{fixed}} = 5$.\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个元素对应一种情况，并且本身是一个形式为 $[N_{\\min}, g_{\\text{gap,min}}]$ 的双元素列表。对于不可行的值，使用整数 $-1$。对于可行的 $g_{\\text{gap,min}}$，四舍五入到三位小数（单位为 nS）。例如，一个包含两种情况的有效输出看起来像：[[3,0.742],[7,0.115]]。",
            "solution": "该问题要求对从简化的窦房结 (SAN) 核心模型到心房负载的成功动作电位传播的最小条件进行形式化和计算。这是心脏电生理学中一个经典的源-汇问题。我们将首先推导必要的解析条件，然后概述用于计算所提供测试用例的最小源大小 ($N_{\\min}$) 和最小每细胞耦合电导 ($g_{\\text{gap,min}}$) 的数值算法。\n\n心房膜片的状态由其电压 $V_A(t)$ 描述，该电压由以下一阶线性常微分方程控制：\n$$\nC_A \\,\\frac{dV_A}{dt} = -G_A \\,(V_A - E_A) + N\\,g_{\\text{gap}} \\,(V_S - V_A)\n$$\n其中 $C_A$ 是心房电容，$G_A$ 是心房漏电导，$E_A$ 是心房静息电位，$N$ 是 SAN 源细胞的数量，$g_{\\text{gap}}$ 是每个细胞的间隙连接电导，$V_S$ 是 SAN 源的钳制电压。初始条件为 $V_A(0) = V_{A0}$，在所有测试用例中均设置为 $E_A$。\n\n影响心房膜片的总电导为 $G_{\\text{tot}} = G_A + N g_{\\text{gap}}$。令来自 SAN 核心的总耦合电导为 $G_c = N g_{\\text{gap}}$。该方程可以重写为：\n$$\nC_A \\,\\frac{dV_A}{dt} + (G_A + G_c) V_A = G_A E_A + G_c V_S\n$$\n这个常微分方程 (ODE) 的解如问题陈述中所示：\n$$\nV_A(t) = V_{\\infty} - \\left(V_{\\infty} - V_{A0}\\right)\\,\\exp\\left(-\\frac{G_A + G_c}{C_A}\\,t\\right)\n$$\n其中稳态电压 $V_{\\infty}$ 为：\n$$\nV_{\\infty} = \\frac{G_A E_A + G_c V_S}{G_A + G_c}\n$$\n可靠传播要求心房电压 $V_A(t)$ 在可用时间窗口 $T_{\\text{avail}}$ 内达到阈值 $V_{\\text{th}}$。这施加了两个基本约束：\n\n1.  **稳态条件：** 稳态电压 $V_{\\infty}$ 必须大于阈值 $V_{\\text{th}}$。如果 $V_{\\infty} \\le V_{\\text{th}}$，则永远无法达到阈值，因为 $V_A(t)$ 从 $V_{A0}$ 单调地趋近于 $V_{\\infty}$。\n    $$ V_{\\infty} > V_{\\text{th}} \\implies \\frac{G_A E_A + G_c V_S}{G_A + G_c} > V_{\\text{th}} $$\n    假设 $G_A+G_c > 0$，我们重新整理以找到关于 $G_c$ 的条件：\n    $$ G_A E_A + G_c V_S > V_{\\text{th}} (G_A + G_c) \\implies G_c (V_S - V_{\\text{th}}) > G_A (V_{\\text{th}} - E_A) $$\n    由于 $G_A > 0$，$G_c > 0$，且通常 $V_{\\text{th}} > E_A$，因此右侧为正。为使此不等式成立，必须有 $V_S - V_{\\text{th}} > 0$，即 $V_S > V_{\\text{th}}$。如果 $V_S \\le V_{\\text{th}}$，如问题所述，传播是不可能的。如果 $V_S > V_{\\text{th}}$，该条件给出了一个最小所需总耦合电导，我们将其表示为 $G_{c,\\text{crit}}$：\n    $$ G_c > G_A \\frac{V_{\\text{th}} - E_A}{V_S - V_{\\text{th}}} = G_{c,\\text{crit}} $$\n\n2.  **时间条件：** 达到阈值所需的时间 $t_{\\text{req}}$ 必须小于或等于可用时间 $T_{\\text{avail}}$。$t_{\\text{req}}$ 的表达式是通过求解 $V_A(t_{\\text{req}}) = V_{\\text{th}}$ 得到的：\n    $$ t_{\\text{req}}(G_c) = \\frac{C_A}{G_A + G_c}\\,\\ln\\!\\left(\\frac{V_{\\infty} - V_{A0}}{V_{\\infty} - V_{\\text{th}}}\\right) \\le T_{\\text{avail}} $$\n    使用 $V_{A0} = E_A$ 和电压差的表达式，对数的参数变为：\n    $$ \\frac{V_{\\infty} - E_A}{V_{\\infty} - V_{\\text{th}}} = \\frac{G_c(V_S - E_A)}{G_c(V_S - V_{\\text{th}}) - G_A(V_{\\text{th}} - E_A)} $$\n    分母为正当且仅当 $G_c > G_{c,\\text{crit}}$，这与稳态条件相同。因此，时间条件隐式地包含了稳态条件。函数 $t_{\\text{req}}(G_c)$ 在 $G_c > G_{c,\\text{crit}}$ 时是连续且单调递减的。此性质确保对于任何 $T_{\\text{avail}} > 0$，都存在一个唯一值 $G_{c,\\text{min}} > G_{c,\\text{crit}}$ 使得 $t_{\\text{req}}(G_{c,\\text{min}}) = T_{\\text{avail}}$，并且对于所有 $G_c \\ge G_{c,\\text{min}}$，不等式 $t_{\\text{req}}(G_c) \\le T_{\\text{avail}}$ 都成立。\n\n我们的目标是找到这个最小总耦合电导 $G_{c,\\text{min}}$，它是以下超越方程的根：\n$$\nH(G_c) = \\frac{C_A}{G_A + G_c}\\,\\ln\\!\\left(\\frac{G_c(V_S - E_A)}{G_c(V_S - V_{\\text{th}}) - G_A(V_{\\text{th}} - E_A)}\\right) - T_{\\text{avail}} = 0\n$$\n\n**算法方法**\n\n对于每个测试用例，我们首先执行可行性检查。如果 $V_S \\le V_{\\text{th}}$，则两个任务都通过返回 $-1$ 被指定为不可行。否则，我们按如下方式进行：\n\n**任务 1：计算最小核心大小 ($N_{\\min}$)**\n给定一个固定的每细胞电导 $g_{\\text{gap}}$，我们寻找满足传播条件的最小整数 $N$。由于 $N$ 是一个离散整数，直接迭代搜索是最直接和稳健的方法。\n1. 初始化细胞计数 $N = 1$。\n2. 在一个循环中，计算总耦合 $G_c = N \\cdot g_{\\text{gap}}$。\n3. 检查是否 $G_c > G_{c,\\text{crit}}$。如果不是，则增加 $N$ 并继续，因为阈值无法达到。\n4. 如果 $G_c > G_{c,\\text{crit}}$，计算 $t_{\\text{req}}(G_c)$。\n5. 如果 $t_{\\text{req}}(G_c) \\le T_{\\text{avail}}$，当前的 $N$ 就是所需的最小大小 $N_{\\min}$。循环终止。\n6. 如果 $t_{\\text{req}}(G_c) > T_{\\text{avail}}$，增加 $N$ 并重复。\n\n**任务 2：计算最小耦合电导 ($g_{\\text{gap,min}}$)**\n给定一个固定的核心大小 $N_{\\text{fixed}}$，我们需要找到确保传播的最小连续值 $g_{\\text{gap,min}}$。这等价于找到最小总耦合电导 $G_{c,\\text{min}}$，然后计算 $g_{\\text{gap,min}} = G_{c,\\text{min}} / N_{\\text{fixed}}$。\n1. 通过求解方程 $H(G_c) = 0$ 来找到 $G_{c,\\text{min}}$。由于 $H(G_c)$ 是单调的，像 Brent 方法（来自 SciPy 的 `brentq`）这样的数值求根算法非常有效。\n2. 可以为求根器建立搜索区间。下界是 $G_{c,\\text{crit}}$。可以通过找到一个值 $G_{c, \\text{upper}}$ 使得 $H(G_{c, \\text{upper}}) < 0$ 来确定上界。自适应扩展搜索（例如，将初始猜测加倍）可以找到一个合适的上界。\n3. 一旦以足够的精度找到根 $G_{c,\\text{min}}$，计算 $g_{\\text{gap,min}} = G_{c,\\text{min}} / N_{\\text{fixed}}$。\n4. 按要求将结果四舍五入到三位小数。\n\n这种方法通过将解析推导与适当的数值技术相结合，为问题提供了一个完整而严谨的解决方案。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the minimal SAN core size (N_min) and per-cell coupling \n    conductance (g_gap_min) for a set of test cases based on a simplified \n    source-sink model of cardiac action potential propagation.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general, reliable propagation expected)\n        {'C_A': 0.2, 'G_A': 1.0, 'E_A': -80.0, 'V_th': -55.0, 'V_S': 10.0, \n         'g_gap': 0.5, 'T_avail': 0.005, 'N_fixed': 5},\n        # Case B (shorter available time, more stringent)\n        {'C_A': 0.2, 'G_A': 1.0, 'E_A': -80.0, 'V_th': -55.0, 'V_S': 10.0, \n         'g_gap': 0.5, 'T_avail': 0.001, 'N_fixed': 5},\n        # Case C (weaker source, still above threshold)\n        {'C_A': 0.2, 'G_A': 1.0, 'E_A': -80.0, 'V_th': -55.0, 'V_S': -45.0, \n         'g_gap': 0.5, 'T_avail': 0.004, 'N_fixed': 5},\n        # Case D (infeasible, source below threshold)\n        {'C_A': 0.2, 'G_A': 1.0, 'E_A': -80.0, 'V_th': -55.0, 'V_S': -60.0, \n         'g_gap': 1.0, 'T_avail': 0.010, 'N_fixed': 5},\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        C_A = params['C_A']\n        G_A = params['G_A']\n        E_A = params['E_A']\n        V_th = params['V_th']\n        V_S = params['V_S']\n        g_gap = params['g_gap']\n        T_avail = params['T_avail']\n        N_fixed = params['N_fixed']\n        V_A0 = E_A\n        \n        # Preliminiary check for feasibility\n        if V_S <= V_th:\n            all_results.append([-1, -1.0])\n            continue\n\n        # --- Task 1: Find N_min ---\n        def calculate_t_req(N, g_gap_val):\n            G_c = N * g_gap_val\n            V_inf = (G_A * E_A + G_c * V_S) / (G_A + G_c)\n            \n            # Check steady-state condition\n            if V_inf <= V_th:\n                return float('inf') # Threshold is unreachable\n\n            log_arg_num = V_inf - V_A0\n            log_arg_den = V_inf - V_th\n            \n            if log_arg_den <= 0: # Should be covered by V_inf > V_th\n                return float('inf')\n\n            t_req = (C_A / (G_A + G_c)) * np.log(log_arg_num / log_arg_den)\n            return t_req\n\n        N_min = -1\n        # Iterative search for N_min\n        # A safety break is included, though not expected to be hit with valid params.\n        for n_test in range(1, 100000):\n            t_req_val = calculate_t_req(n_test, g_gap)\n            if t_req_val <= T_avail:\n                N_min = n_test\n                break\n        \n        # --- Task 2: Find g_gap_min ---\n        def get_H_Gc(G_c):\n            # This function is H(G_c) = t_req(G_c) - T_avail, which we want to find the root of.\n            V_inf = (G_A * E_A + G_c * V_S) / (G_A + G_c)\n            log_arg_num = G_c * (V_S - E_A)\n            log_arg_den = G_c * (V_S - V_th) - G_A * (V_th - E_A)\n            \n            # log_arg_den must be positive\n            if log_arg_den <= 0:\n                # Outside valid domain for root finding\n                return float('inf')\n\n            t_req = (C_A / (G_A + G_c)) * np.log(log_arg_num / log_arg_den)\n            return t_req - T_avail\n\n        # Lower bound for G_c from the steady-state condition\n        G_c_crit = G_A * (V_th - E_A) / (V_S - V_th)\n        \n        # We need a search interval [a, b] for brentq where h(a) > 0 and h(b)  0\n        # The lower bound 'a' is slightly above G_c_crit\n        a = G_c_crit * 1.000001\n        \n        # Check if a solution is possible\n        if get_H_Gc(a)  0: # This case is rare but means any Gc > G_c_crit works\n            G_c_min = a\n        else:\n            # Find an upper bound 'b' for the search\n            b = a * 2\n            max_iter = 20\n            iter_count = 0\n            while get_H_Gc(b) > 0 and iter_count  max_iter:\n                b *= 2\n                iter_count += 1\n            \n            try:\n                if iter_count  max_iter:\n                    G_c_min = brentq(get_H_Gc, a, b)\n                else: # Could not find a bracket\n                    G_c_min = -1 # Should not happen in this problem\n            except ValueError:\n                G_c_min = -1 # Should not happen\n\n        if G_c_min != -1:\n            g_gap_min = round(G_c_min / N_fixed, 3)\n        else:\n            g_gap_min = -1.0\n            \n        all_results.append([N_min, g_gap_min])\n\n    # Format the final output string\n    result_str = ','.join([f\"[{n},{g}]\" for n, g in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}