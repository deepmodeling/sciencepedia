{
    "hands_on_practices": [
        {
            "introduction": "This practice provides a foundational exercise in pharmacokinetic modeling by estimating the clearance rate of glucagon from the bloodstream. Understanding how quickly a hormone is eliminated is crucial for predicting its concentration over time. You will apply a single-compartment model to analyze hypothetical experimental data, learning to distinguish between different noise structures and select the appropriate statistical estimation technique—a vital skill for handling real-world biological measurements .",
            "id": "3890333",
            "problem": "You are modeling plasma glucagon dynamics after an intravenous bolus injection in a single, well-mixed compartment. After the bolus, glucagon is cleared without further secretion or infusion. Use mass balance and conservation principles to derive an estimator for the plasma glucagon clearance rate constant and compute the half-life. The compartmental model assumes first-order clearance and constant volume. Concentrations are measured in picomoles per liter ($\\mathrm{pmol/L}$), and time is in minutes.\n\nStarting from the fundamental base of compartmental mass balance and standard noise models used in biomedical systems modeling, construct a program that estimates the clearance rate constant $k_{cl}$ and the half-life $t_{1/2}$ from experimental measurements of plasma glucagon concentration $H(t)$ following a bolus at $t=0$. Treat the data under two different measurement noise assumptions:\n\n- For multiplicative log-normal measurement noise, perform estimation using a linear model in the natural logarithm domain with Ordinary Least Squares (OLS) on $\\ln(H)$ versus time.\n- For additive Gaussian measurement noise with constant variance, perform estimation using Nonlinear Least Squares (NLS) on the original scale with positivity constraints on parameters.\n\nYour program must, for each test case defined below, estimate $k_{cl}$ in $\\mathrm{min^{-1}}$ and compute the half-life $t_{1/2}$ in minutes. Express outputs as floats rounded to six decimal places. The final output must be a single line containing a comma-separated list of all results aggregated in order as $[k_{cl}^{(1)}, t_{1/2}^{(1)}, k_{cl}^{(2)}, t_{1/2}^{(2)}, \\dots]$.\n\nUse the following test suite of four parameter sets to validate your implementation. In each case, treat the provided arrays as observed measurements. All times are in minutes and all concentrations are in $\\mathrm{pmol/L}$.\n\nTest case $1$ (multiplicative log-normal noise, ordinary least squares in log-domain):\n- Time points $t$: [$0$, $3$, $6$, $9$, $12$, $15$, $18$, $21$, $24$, $27$, $30$]\n- Measured concentrations $H$: [$500.000000$, $279.893934$, $146.079193$, $85.128928$, $44.905386$, $25.142469$, $13.388624$, $7.797699$, $3.951277$, $2.145555$, $1.177407$]\n- Noise model: log-normal (multiplicative)\n\nTest case $2$ (additive Gaussian noise, nonlinear least squares on original scale):\n- Time points $t$: [$0$, $5$, $10$, $15$, $20$, $25$, $30$, $35$, $40$]\n- Measured concentrations $H$: [$297.000000$, $185.959198$, $105.363832$, $69.939048$, $40.600585$, $22.625500$, $19.936120$, $5.059215$, $7.494691$]\n- Noise model: additive (constant variance)\n\nTest case $3$ (multiplicative log-normal noise, ordinary least squares in log-domain):\n- Time points $t$: [$0$, $0.5$, $1.0$, $1.5$, $2.0$, $2.5$, $3.0$, $3.5$, $4.0$, $4.5$, $5.0$]\n- Measured concentrations $H$: [$800.000000$, $490.076772$, $291.360517$, $182.074211$, $106.102862$, $65.667999$, $41.024544$, $23.432169$, $14.652510$, $9.331557$, $5.120840$]\n- Noise model: log-normal (multiplicative)\n\nTest case $4$ (multiplicative log-normal noise with minimal data, ordinary least squares in log-domain):\n- Time points $t$: [$0$, $10$]\n- Measured concentrations $H$: [$250.000000$, $126.629253$]\n- Noise model: log-normal (multiplicative)\n\nAlgorithmic requirements:\n- Define a physically plausible compartmental framework based on conservation of mass. Use Ordinary Differential Equation (ODE) reasoning to motivate your estimators.\n- For log-normal noise cases, estimate the slope and intercept of the linear relationship in the log-domain and back-transform to recover parameters. For additive noise cases, estimate parameters by minimizing the sum of squared residuals on the original scale with positivity constraints.\n- Compute $t_{1/2}$ from the estimated clearance rate constant.\n- The program must produce results in $\\mathrm{min^{-1}}$ for $k_{cl}$ and minutes for $t_{1/2}$, each rounded to six decimal places.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., [$k_{cl}^{(1)}$, $t_{1/2}^{(1)}$, $k_{cl}^{(2)}$, $t_{1/2}^{(2)}$, $k_{cl}^{(3)}$, $t_{1/2}^{(3)}$, $k_{cl}^{(4)}$, $t_{1/2}^{(4)}$]).",
            "solution": "We begin from the compartmental mass balance for plasma glucagon under a bolus injection at time $t=0$ with no subsequent secretion or infusion. Let $H(t)$ denote the plasma glucagon concentration in $\\mathrm{pmol/L}$ and assume constant volume and first-order clearance. The ordinary differential equation (ODE) for mass balance is\n$$\n\\frac{dH}{dt} = -k_{cl}\\, H(t),\n$$\nwhere $k_{cl}  0$ is the clearance rate constant in $\\mathrm{min^{-1}}$. The initial condition after the bolus is\n$$\nH(0) = H_0,\n$$\nwhere $H_0$ is the initial concentration immediately after injection. Solving the linear ODE yields the exponential decay solution\n$$\nH(t) = H_0 \\, e^{-k_{cl} t}.\n$$\nA standard pharmacokinetic definition of half-life is the time $t_{1/2}$ such that the concentration falls to one half of its initial value:\n$$\nH(t_{1/2}) = \\frac{H_0}{2}.\n$$\nSubstituting the solution gives\n$$\nH_0 \\, e^{-k_{cl} t_{1/2}} = \\frac{H_0}{2} \\quad \\Rightarrow \\quad e^{-k_{cl} t_{1/2}} = \\frac{1}{2} \\quad \\Rightarrow \\quad t_{1/2} = \\frac{\\ln(2)}{k_{cl}}.\n$$\n\nEstimation strategy depends on the measurement noise model. We consider two common models:\n\n1. Multiplicative log-normal noise: $M_i = H(t_i) \\, e^{\\varepsilon_i}$ with $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$ independent across $i$. Taking natural logarithms,\n$$\n\\ln M_i = \\ln H_0 - k_{cl} t_i + \\varepsilon_i,\n$$\nwhich is a linear model in $t_i$ with intercept $\\ln H_0$ and slope $-k_{cl}$. Under this noise model, Ordinary Least Squares (OLS) on $(t_i, \\ln M_i)$ provides the maximum likelihood estimator. Let $y_i = \\ln M_i$, and define sample means $\\bar{t} = \\frac{1}{n}\\sum_i t_i$ and $\\bar{y} = \\frac{1}{n}\\sum_i y_i$. The OLS slope and intercept are\n$$\ns = \\frac{\\sum_i (t_i - \\bar{t})(y_i - \\bar{y})}{\\sum_i (t_i - \\bar{t})^2}, \\quad b = \\bar{y} - s \\bar{t}.\n$$\nThe parameter estimates are\n$$\n\\hat{k}_{cl} = -s, \\quad \\hat{H}_0 = e^{b}, \\quad \\hat{t}_{1/2} = \\frac{\\ln(2)}{\\hat{k}_{cl}}.\n$$\n\n2. Additive Gaussian noise with constant variance: $M_i = H(t_i) + \\eta_i$, where $\\eta_i \\sim \\mathcal{N}(0, \\sigma^2)$ independent. In this case, the natural logarithm does not linearize the errors, and the appropriate estimator is Nonlinear Least Squares (NLS) on the original scale. Define the residuals\n$$\nr_i(H_0, k_{cl}) = M_i - H_0 e^{-k_{cl} t_i},\n$$\nand minimize the objective\n$$\nJ(H_0, k_{cl}) = \\sum_i r_i(H_0, k_{cl})^2\n$$\nsubject to $H_0  0$ and $k_{cl}  0$. The minimizer $(\\hat{H}_0, \\hat{k}_{cl})$ yields the half-life estimate\n$$\n\\hat{t}_{1/2} = \\frac{\\ln(2)}{\\hat{k}_{cl}}.\n$$\nA practical approach initializes NLS using the OLS estimates in the log-domain to improve convergence.\n\nAlgorithm summary:\n- For each test case, inspect the noise model.\n- If the noise model is log-normal (multiplicative), compute $\\hat{k}_{cl}$ and $\\hat{H}_0$ by OLS on $(t_i, \\ln M_i)$ and then compute $\\hat{t}_{1/2} = \\ln(2)/\\hat{k}_{cl}$.\n- If the noise model is additive (constant variance), perform NLS on the original scale with bounds $H_0  0$, $k_{cl}  0$, initializing from the log-domain OLS, and then compute $\\hat{t}_{1/2}$.\n- Round $\\hat{k}_{cl}$ in $\\mathrm{min^{-1}}$ and $\\hat{t}_{1/2}$ in minutes to six decimal places.\n- Aggregate results in the specified single-line format.\n\nScientific realism and consistency:\n- The compartmental ODE arises from conservation of mass and first-order clearance kinetics, a well-tested assumption for many peptide hormones.\n- The half-life definition is standard in pharmacokinetics.\n- The noise models reflect common measurement characteristics: multiplicative errors correspond to proportional assay variability, and additive errors correspond to constant-variance instrument noise.\n- The test suite includes a typical decay with multiplicative noise, an additive-noise scenario handled by NLS, a rapid-clearance boundary case, and a minimal-data edge case, enabling coverage across methods and numerical conditions.\n\nThe implemented program follows these principles, choosing the appropriate estimator per case, and prints the results in the required format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef ols_log_domain(t, H):\n    \"\"\"\n    Estimate k_cl and H0 using OLS in the log-domain.\n    Model: ln(H) = b - k_cl * t + epsilon\n    Returns k_cl (0), H0 (0)\n    \"\"\"\n    t = np.asarray(t, dtype=float)\n    H = np.asarray(H, dtype=float)\n    if np.any(H = 0):\n        raise ValueError(\"All concentration measurements must be positive for log-domain OLS.\")\n    y = np.log(H)\n    t_mean = t.mean()\n    y_mean = y.mean()\n    denom = np.sum((t - t_mean) ** 2)\n    # Handle potential zero denominator\n    if denom == 0.0:\n        # If all t are identical (degenerate), fall back to two-point slope if possible\n        if len(t) = 2 and t[0] != t[-1]:\n            s = (y[-1] - y[0]) / (t[-1] - t[0])\n        else:\n            s = 0.0\n    else:\n        s = np.sum((t - t_mean) * (y - y_mean)) / denom\n    b = y_mean - s * t_mean\n    k_cl = -s\n    H0 = float(np.exp(b))\n    return float(k_cl), H0\n\ndef nls_original_scale(t, H, init_kcl=None, init_H0=None):\n    \"\"\"\n    Estimate k_cl and H0 using NLS on original scale with positivity constraints.\n    Returns k_cl (0), H0 (0)\n    \"\"\"\n    t = np.asarray(t, dtype=float)\n    H = np.asarray(H, dtype=float)\n\n    def model_func(tt, H0, k_cl):\n        return H0 * np.exp(-k_cl * tt)\n\n    # Initial guesses from log-domain OLS\n    if init_kcl is None or init_H0 is None:\n        try:\n            k_guess, H0_guess = ols_log_domain(t, H.clip(min=1e-9))\n        except Exception:\n            # Fallback initial guesses\n            H0_guess = max(H.max(), 1.0)\n            # Use rough slope from two points if possible\n            if len(t) = 2 and H[0]  0 and H[-1]  0 and t[-1] != t[0]:\n                s = (np.log(H[-1]) - np.log(H[0])) / (t[-1] - t[0])\n                k_guess = max(-s, 1e-6)\n            else:\n                k_guess = 0.1\n    else:\n        k_guess, H0_guess = init_kcl, init_H0\n\n    # Bounds ensure positivity\n    bounds = ([1e-12, 1e-12], [np.inf, np.inf])\n    try:\n        popt, _ = curve_fit(\n            model_func,\n            t,\n            H,\n            p0=[H0_guess, k_guess],\n            bounds=bounds,\n            maxfev=10000,\n        )\n        H0_hat, k_hat = popt\n    except Exception:\n        # Fallback to initial guesses if optimization fails\n        H0_hat, k_hat = H0_guess, k_guess\n\n    return float(k_hat), float(H0_hat)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"t\": [0.0, 3.0, 6.0, 9.0, 12.0, 15.0, 18.0, 21.0, 24.0, 27.0, 30.0],\n            \"H\": [500.000000, 279.893934, 146.079193, 85.128928, 44.905386, 25.142469,\n                  13.388624, 7.797699, 3.951277, 2.145555, 1.177407],\n            \"noise_model\": \"log-normal\",\n        },\n        {\n            \"t\": [0.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0],\n            \"H\": [297.000000, 185.959198, 105.363832, 69.939048, 40.600585, 22.625500,\n                  19.936120, 5.059215, 7.494691],\n            \"noise_model\": \"additive\",\n        },\n        {\n            \"t\": [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0],\n            \"H\": [800.000000, 490.076772, 291.360517, 182.074211, 106.102862, 65.667999,\n                  41.024544, 23.432169, 14.652510, 9.331557, 5.120840],\n            \"noise_model\": \"log-normal\",\n        },\n        {\n            \"t\": [0.0, 10.0],\n            \"H\": [250.000000, 126.629253],\n            \"noise_model\": \"log-normal\",\n        },\n    ]\n\n    results = []\n    ln2 = np.log(2.0)\n\n    for case in test_cases:\n        t = case[\"t\"]\n        H = case[\"H\"]\n        noise_model = case[\"noise_model\"]\n\n        if noise_model == \"log-normal\":\n            k_hat, H0_hat = ols_log_domain(t, H)\n        elif noise_model == \"additive\":\n            # Initialize from log-domain OLS to aid NLS\n            k_init, H0_init = ols_log_domain(t, np.clip(H, 1e-9, None))\n            k_hat, H0_hat = nls_original_scale(t, H, init_kcl=k_init, init_H0=H0_init)\n        else:\n            # Unknown model: default to log-domain OLS\n            k_hat, H0_hat = ols_log_domain(t, H)\n\n        # Ensure positivity\n        k_hat = float(abs(k_hat))\n        # Compute half-life\n        t_half = ln2 / k_hat if k_hat  0 else float('inf')\n\n        # Round to six decimals\n        results.append(round(k_hat, 6))\n        results.append(round(t_half, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon clearance, this exercise focuses on modeling the *secretion* of glucagon in response to its primary regulator, glucose. You will work with the Hill equation, a canonical model for describing dose-response relationships in physiology, to characterize the inhibitory effect of glucose on glucagon release. This practice will develop your skills in nonlinear parameter estimation, allowing you to quantify key properties of the system like its sensitivity ($K_G$) and cooperativity ($n$) from experimental data .",
            "id": "3890363",
            "problem": "You are modeling pancreatic alpha-cell glucagon secretion under the influence of plasma glucose using a Hill-type inhibitory response. The secretion model is postulated as a saturating inhibitory function given by\n$$\ns_{H}(G) \\;=\\; \\frac{s_{0}}{1 + \\left(\\frac{G}{K_{G}}\\right)^{n}},\n$$\nwhere $s_{H}(G)$ is the predicted secretion at glucose $G$, $s_{0}$ is the maximal secretion in the absence of glucose inhibition, $K_{G}$ is the characteristic glucose level at which secretion is half-inhibited, and $n$ is the Hill exponent describing the cooperativity of suppression. This Hill-type form is a well-tested empirical representation in endocrine physiology for ligand-mediated inhibition and is appropriate as a simplified regulatory law when glucose rapidly equilibrates and intracellular processes reach a quasi-steady state.\n\nTask: Given datasets of measured glucose $G$ (in millimolar, mM), observed secretion $s$ (in arbitrary consistent units), and known $s_{0}$ for each dataset, estimate the parameters $n$ and $K_{G}$ by fitting the model on the original scale of secretion via nonlinear least squares, subject to $n  0$ and $K_{G}  0$. Your program must implement a principled estimation procedure that is justified from first principles (e.g., transforming the model to obtain an identifiable linear relation for an initial guess, then refining on the original nonlinear model). Express $K_{G}$ in millimolar and $n$ as a dimensionless quantity. All numerical answers must be reported as decimal floats rounded to three digits after the decimal point.\n\nFoundational starting points you may assume include: quasi-steady receptor-ligand occupancy leading to Hill-type dose-response, the definition of the natural logarithm, and least-squares estimation as minimizing the sum of squared residuals.\n\nEstimation target: For each dataset, compute the pair $(\\hat{n}, \\hat{K}_{G})$ that minimizes the sum of squared residuals\n$$\n\\sum_{i=1}^{N}\\left[\\frac{s_{0}}{1+\\left(\\frac{G_{i}}{K_{G}}\\right)^{n}} - s_{i}\\right]^{2},\n$$\nwith $n  0$ and $K_{G}  0$, using an initialization derived from a mathematically justified transformation of the model.\n\nUnit requirements: Glucose $G$ and $K_{G}$ must be handled in millimolar (mM). Report $K_{G}$ in millimolar and $n$ as dimensionless.\n\nAngle units do not apply. If you compute any ratios or fractions, report them as decimal numbers rather than with a percentage sign.\n\nTest suite: Use the following four datasets. Each dataset specifies $s_{0}$, a list of glucose values $G$ in mM, and the corresponding observed secretion values $s$ in the same arbitrary units as $s_{0}$.\n\n- Dataset A (well-conditioned, noise-free, cooperative suppression):\n  - $s_{0} = 1.0$\n  - $G = [\\,3.0,\\,4.0,\\,6.0,\\,8.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,0.6400000000,\\,0.5000000000,\\,0.3076923077,\\,0.2000000000,\\,0.1379310345\\,]$\n\n- Dataset B (moderate noise, typical dynamic range):\n  - $s_{0} = 2.0$\n  - $G = [\\,3.0,\\,4.0,\\,5.0,\\,7.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,1.6200000000,\\,1.3700000000,\\,1.1800000000,\\,0.8400000000,\\,0.5300000000\\,]$\n\n- Dataset C (steep cooperativity, high Hill exponent):\n  - $s_{0} = 1.5$\n  - $G = [\\,3.0,\\,4.0,\\,5.0,\\,6.0,\\,7.0,\\,8.0\\,]$ (mM)\n  - $s = [\\,1.2110000000,\\,0.7500000000,\\,0.3700000000,\\,0.1750000000,\\,0.0860000000,\\,0.0450000000\\,]$\n\n- Dataset D (boundary identifiability with minimal points):\n  - $s_{0} = 1.0$\n  - $G = [\\,3.0,\\,10.0\\,]$ (mM)\n  - $s = [\\,0.8220000000,\\,0.1110000000\\,]$\n\nComputational and reporting requirements:\n\n- For each dataset, compute $(\\hat{n}, \\hat{K}_{G})$ subject to positivity ($\\hat{n}  0$, $\\hat{K}_{G}  0$).\n- Use a transformation grounded in the model structure to obtain an initial guess, then refine by minimizing the sum of squared residuals on the original scale $s$.\n- Output format: Your program should produce a a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\,\\hat{n}_{A},\\,\\hat{K}_{G,A},\\,\\hat{n}_{B},\\,\\hat{K}_{G,B},\\,\\hat{n}_{C},\\,\\hat{K}_{G,C},\\,\\hat{n}_{D},\\,\\hat{K}_{G,D}\\,],\n$$\nwith each value rounded to three digits after the decimal point. $K_{G}$ values must implicitly be in millimolar (mM) and $n$ dimensionless as stated above.",
            "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and complete. The model presented, a Hill-type inhibitory function, is a canonical and empirically validated representation for dose-response phenomena in physiology and pharmacology. The objective, which is to estimate the model parameters $n$ and $K_{G}$ from supplied datasets using nonlinear least squares, constitutes a standard and well-defined task in computational science and statistical modeling. The provided data are numerically consistent and physically plausible within the context of glucose-glucagon dynamics.\n\nThe estimation of parameters $(\\hat{n}, \\hat{K}_{G})$ will be performed using a two-step, principled approach. First, an initial guess for the parameters is derived by linearizing the model equation. Second, this initial guess is refined by performing a nonlinear optimization to minimize the sum of squared residuals on the original, untransformed scale. This two-step procedure is robust: the linearization provides a computationally inexpensive and often accurate starting point, guiding the subsequent nonlinear search towards the global minimum and away from non-physical local minima. The refinement step is critical because it honors the original error structure of the data, ensuring the final estimates are statistically optimal under the assumption of additive, homoscedastic noise on the secretion measurements.\n\n**Step 1: Initial Parameter Guess via Model Linearization**\n\nThe secretion model is given by:\n$$ s_{H}(G) = \\frac{s_{0}}{1 + \\left(\\frac{G}{K_{G}}\\right)^{n}} $$\nwhere $s_{H}(G)$ is the secretion value, which we equate with the observed data $s_i$ for each glucose concentration $G_i$. The parameter $s_0$ is known for each dataset. We must estimate $n$ and $K_{G}$. We can algebraically rearrange the equation to isolate the term containing the parameters $n$ and $K_{G}$:\n$$ \\frac{s_0}{s_i} = 1 + \\left(\\frac{G_i}{K_{G}}\\right)^{n} $$\n$$ \\frac{s_0}{s_i} - 1 = \\left(\\frac{G_i}{K_{G}}\\right)^{n} $$\nFor this transformation to be valid, we require $s_i  s_0$, which holds for all provided data points, ensuring that the left-hand side is positive. Taking the natural logarithm of both sides yields:\n$$ \\ln\\left(\\frac{s_0}{s_i} - 1\\right) = \\ln\\left[\\left(\\frac{G_i}{K_{G}}\\right)^{n}\\right] $$\nUsing the properties of logarithms, $\\ln(a^b) = b\\ln(a)$ and $\\ln(a/b) = \\ln(a) - \\ln(b)$, we obtain:\n$$ \\ln\\left(\\frac{s_0}{s_i} - 1\\right) = n \\left( \\ln(G_i) - \\ln(K_{G}) \\right) $$\nThis equation can be expressed in the form of a linear relationship, $y = m x + c$:\n$$ \\underbrace{\\ln\\left(\\frac{s_0}{s_i} - 1\\right)}_{y_i} = \\underbrace{n}_{m} \\cdot \\underbrace{\\ln(G_i)}_{x_i} + \\underbrace{(-n \\ln(K_{G}))}_{c} $$\nThus, we can transform each data point $(G_i, s_i)$ into a new coordinate system $(x_i, y_i)$, where $x_i = \\ln(G_i)$ and $y_i = \\ln(s_0/s_i - 1)$. We then perform a linear regression on these transformed points to estimate the slope $m$ and y-intercept $c$. From these, we derive the initial parameter guesses:\n$$ n_{\\text{init}} = m $$\n$$ K_{G, \\text{init}} = \\exp\\left(-\\frac{c}{m}\\right) = \\exp\\left(-\\frac{c}{n_{\\text{init}}}\\right) $$\n\n**Step 2: Nonlinear Least Squares Refinement**\n\nThe initial guesses $(n_{\\text{init}}, K_{G, \\text{init}})$ are used as the starting point for a more rigorous optimization. The objective is to find the parameter set $(\\hat{n}, \\hat{K}_{G})$ that minimizes the sum of squared residuals (SSR) between the model's predictions and the observed data on the original scale:\n$$ \\text{SSR}(n, K_G) = \\sum_{i=1}^{N}\\left[s_{H}(G_i; n, K_G) - s_{i}\\right]^{2} = \\sum_{i=1}^{N}\\left[\\frac{s_{0}}{1+\\left(\\frac{G_{i}}{K_{G}}\\right)^{n}} - s_{i}\\right]^{2} $$\nThis minimization is a nonlinear optimization problem subject to the physical constraints $n  0$ and $K_{G}  0$. We employ a quasi-Newton method, specifically L-BFGS-B, which is well-suited for this type of problem as it can efficiently handle box constraints (bounds). The optimization is performed using the `minimize` function from the `scipy.optimize` library, with the bounds for both $n$ and $K_{G}$ set to $(0, \\infty)$ to ensure physically meaningful results. The final estimated parameters $(\\hat{n}, \\hat{K}_{G})$ are the values returned by the optimization algorithm upon convergence.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Estimates parameters for a Hill-type model of glucagon secretion.\n    The solution follows a two-step process:\n    1.  Calculates an initial guess for the parameters (n, K_G) by\n        linearizing the model equation and performing a linear regression.\n    2.  Refines the initial guess by minimizing the sum of squared residuals\n        on the original nonlinear model using scipy.optimize.minimize.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"s0\": 1.0,\n            \"G\": [3.0, 4.0, 6.0, 8.0, 10.0],\n            \"s\": [0.6400000000, 0.5000000000, 0.3076923077, 0.2000000000, 0.1379310345]\n        },\n        {\n            \"id\": \"B\",\n            \"s0\": 2.0,\n            \"G\": [3.0, 4.0, 5.0, 7.0, 10.0],\n            \"s\": [1.6200000000, 1.3700000000, 1.1800000000, 0.8400000000, 0.5300000000]\n        },\n        {\n            \"id\": \"C\",\n            \"s0\": 1.5,\n            \"G\": [3.0, 4.0, 5.0, 6.0, 7.0, 8.0],\n            \"s\": [1.2110000000, 0.7500000000, 0.3700000000, 0.1750000000, 0.0860000000, 0.0450000000]\n        },\n        {\n            \"id\": \"D\",\n            \"s0\": 1.0,\n            \"G\": [3.0, 10.0],\n            \"s\": [0.8220000000, 0.1110000000]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s0 = case[\"s0\"]\n        G = np.array(case[\"G\"], dtype=float)\n        s = np.array(case[\"s\"], dtype=float)\n\n        # Step 1: Calculate initial guess via model linearization.\n        # Filter data to ensure s  s0 for the log transformation.\n        valid_indices = (s  0)  (s  s0)\n        G_filt = G[valid_indices]\n        s_filt = s[valid_indices]\n        \n        # Check if enough points are available for linear regression\n        if len(G_filt) = 2:\n            x = np.log(G_filt)\n            y = np.log(s0 / s_filt - 1)\n\n            # Perform linear regression y = m*x + c\n            # where m = n and c = -n*ln(K_G)\n            m, c = np.polyfit(x, y, 1)\n\n            # Derived initial guesses. A positive slope 'm' is expected for inhibitory action.\n            if m  0:\n                n_init = m\n                KG_init = np.exp(-c / m)\n            else:\n                # Fallback guess if data is too noisy for a good linear fit\n                n_init = 2.0\n                KG_init = np.median(G)\n        else:\n             # Fallback guess if no valid points for linearization.\n             n_init = 2.0\n             KG_init = np.median(G)\n        \n        # Ensure initial guesses are positive\n        if n_init = 0: n_init = 1.0\n        if KG_init = 0: KG_init = np.median(G)\n\n\n        # Step 2: Refine parameters with nonlinear least squares.\n        def model_func(params, G_vals, s0_val):\n            n, KG = params\n            # Clip KG to avoid division by zero or domain errors.\n            KG = max(KG, 1e-9)\n            return s0_val / (1.0 + (G_vals / KG)**n)\n\n        def ssr_func(params, G_vals, s_vals, s0_val):\n            \"\"\"Sum of Squared Residuals objective function.\"\"\"\n            model_s = model_func(params, G_vals, s0_val)\n            return np.sum((model_s - s_vals)**2)\n\n        initial_guess = [n_init, KG_init]\n        # Set bounds to enforce n  0 and K_G  0\n        bounds = ((1e-9, None), (1e-9, None))\n        \n        # Run the optimization\n        opt_result = minimize(\n            ssr_func,\n            initial_guess,\n            args=(G, s, s0),\n            method='L-BFGS-B',\n            bounds=bounds\n        )\n\n        n_hat, KG_hat = opt_result.x\n\n        results.append(f\"{n_hat:.3f}\")\n        results.append(f\"{KG_hat:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This capstone exercise integrates the concepts of hormone action and feedback into a complete system model of glucose regulation. By analyzing a linearized model of the glucose-insulin-glucagon axis, you will explore how controller feedback gains influence system stability and the potential for oscillations. This practice introduces bifurcation analysis, a powerful tool from control theory used to ensure the robustness and safety of physiological control systems, with direct relevance to designing technologies like the artificial pancreas .",
            "id": "3890365",
            "problem": "Consider a continuous-time, lumped-parameter model for glucose regulation centered on the interaction of glucagon and insulin. Let $H(t)$ denote deviation of glucagon from its steady state, $I(t)$ denote deviation of insulin from its steady state, and $G(t)$ denote deviation of plasma glucose concentration from its steady state (setpoint). Time is measured in minutes, $t$ is in minutes, $H$ and $I$ are in normalized hormone units, and $G$ is in $\\mathrm{mg/dL}$. The control objective is to regulate $G(t)$ to $0$ by modulating hormone secretion rates via feedback on $G(t)$. Starting from standard continuous-time modeling assumptions and well-tested physiological facts (insulin lowers glucose and glucagon raises glucose; glucagon decreases when glucose increases and insulin increases when glucose increases), the linearized dynamics around the setpoint are given by the following ordinary differential equation (ODE) system:\n$$\n\\frac{dH}{dt} = -a_H H + \\sigma_H G + u_H, \\quad\n\\frac{dI}{dt} = -a_I I + \\sigma_I G + u_I, \\quad\n\\frac{dG}{dt} = c_H H - c_I I - a_G G,\n$$\nwith feedback controller\n$$\nu_H = -k_H G, \\quad u_I = k_I G.\n$$\nHere, $a_H$, $a_I$, and $a_G$ are positive decay rates in $\\mathrm{min^{-1}}$; $c_H$ and $c_I$ quantify the effect of glucagon and insulin on glucose in $\\mathrm{(mg/dL)/(unit \\cdot min)}$; $\\sigma_H$ (negative) and $\\sigma_I$ (positive) are the local sensitivities of endogenous hormone secretion to glucose in $\\mathrm{(unit)/(mg/dL \\cdot min)}$; and $k_H$ and $k_I$ are feedback gains in $\\mathrm{(unit)/(mg/dL \\cdot min)}$. Around the steady state $(H,I,G)=(0,0,0)$, the Jacobian matrix is\n$$\nA(k_H,k_I)=\\begin{bmatrix}\n-a_H  0  \\sigma_H - k_H \\\\\n0  -a_I  \\sigma_I + k_I \\\\\nc_H  -c_I  -a_G\n\\end{bmatrix}.\n$$\nA bifurcation occurs when eigenvalues of $A(k_H,k_I)$ change qualitative character as $k_H$ or $k_I$ vary, for example crossing the imaginary axis (instability onset) or changing from real to complex conjugate pairs (onset of oscillatory transients). For this problem, a parameter pair $(k_H,k_I)$ is deemed “safe” if all eigenvalues of $A(k_H,k_I)$ are real and have strictly negative real parts; otherwise it is “unsafe.” All stability and oscillation assessments must be performed by analyzing the eigenvalues of $A(k_H,k_I)$.\n\nUse the following numerically plausible parameter values, consistent with accepted physiological magnitudes:\n$$\na_H = 0.15 \\ \\mathrm{min^{-1}}, \\quad a_I = 0.25 \\ \\mathrm{min^{-1}}, \\quad a_G = 0.10 \\ \\mathrm{min^{-1}},\n$$\n$$\nc_H = 0.60 \\ \\mathrm{\\frac{mg/dL}{unit \\cdot min}}, \\quad c_I = 1.20 \\ \\mathrm{\\frac{mg/dL}{unit \\cdot min}},\n$$\n$$\n\\sigma_H = -0.03 \\ \\mathrm{\\frac{unit}{mg/dL \\cdot min}}, \\quad \\sigma_I = 0.04 \\ \\mathrm{\\frac{unit}{mg/dL \\cdot min}}.\n$$\n\nTask: Perform a one-parameter bifurcation analysis by sweeping $k_H$ over a specified range for fixed $k_I$ values. For each test case, determine all contiguous subintervals of $k_H$ in which the system is safe. A “contiguous subinterval” is a maximal interval of $k_H$ values (on the discretized grid) for which the system remains safe at each grid point; endpoints must be taken from the grid used for the sweep.\n\nYour program must:\n- Form $A(k_H,k_I)$ for each grid point.\n- Compute its eigenvalues.\n- Classify each grid point as safe if and only if all eigenvalues are real and have strictly negative real parts.\n- Return, for each test case, the list of maximal contiguous safe subintervals of $k_H$ found on the grid, expressed as pairs $[k_{\\text{start}}, k_{\\text{end}}]$ with both endpoints included.\n\nUse the following test suite of fixed $k_I$ and $k_H$ sweep specifications:\n1. $k_I = 0.05$; sweep $k_H$ from $-0.10$ to $0.20$ with step $0.005$.\n2. $k_I = -0.10$; sweep $k_H$ from $-0.10$ to $0.20$ with step $0.005$.\n3. $k_I = 0.20$; sweep $k_H$ from $-0.05$ to $0.50$ with step $0.01$.\n\nThe final output format must be a single line containing a comma-separated list of the three results, each result itself being a list of interval pairs, enclosed in square brackets. For example: $[\\,[\\,[x_1,x_2],[x_3,x_4]\\,],\\,[\\,],\\,[\\,[y_1,y_2]\\,]\\,]$. No units are to be included in the output; all values are plain decimal numbers in $\\mathrm{(unit)/(mg/dL \\cdot min)}$ for $k_H$ and $k_I$.",
            "solution": "The user wants me to solve a problem based on a continuous-time, lumped-parameter model of glucose regulation.\n\n### Step 1: Extract Givens\n\n**System Dynamics:**\nThe state variables are $H(t)$, $I(t)$, and $G(t)$, representing deviations from steady-state for glucagon, insulin, and glucose, respectively. The system of ordinary differential equations (ODEs) is:\n$$\n\\frac{dH}{dt} = -a_H H + \\sigma_H G + u_H\n$$\n$$\n\\frac{dI}{dt} = -a_I I + \\sigma_I G + u_I\n$$\n$$\n\\frac{dG}{dt} = c_H H - c_I I - a_G G\n$$\n\n**Feedback Controller:**\nThe control inputs $u_H$ and $u_I$ are defined by a linear feedback law based on glucose deviation $G$:\n$$\nu_H = -k_H G\n$$\n$$\nu_I = k_I G\n$$\n\n**Jacobian Matrix:**\nThe Jacobian matrix of the closed-loop system around the steady state $(H,I,G)=(0,0,0)$ is given as:\n$$\nA(k_H,k_I)=\\begin{bmatrix}\n-a_H  0  \\sigma_H - k_H \\\\\n0  -a_I  \\sigma_I + k_I \\\\\nc_H  -c_I  -a_G\n\\end{bmatrix}\n$$\n\n**Definition of \"Safe\":**\nA parameter pair $(k_H,k_I)$ is \"safe\" if and only if all eigenvalues of the Jacobian matrix $A(k_H,k_I)$ meet two conditions:\n1. They are all real numbers.\n2. They all have strictly negative real parts.\n\n**Model Parameters:**\n- $a_H = 0.15 \\ \\mathrm{min^{-1}}$\n- $a_I = 0.25 \\ \\mathrm{min^{-1}}$\n- $a_G = 0.10 \\ \\mathrm{min^{-1}}$\n- $c_H = 0.60 \\ \\mathrm{(mg/dL)/(unit \\cdot min)}$\n- $c_I = 1.20 \\ \\mathrm{(mg/dL)/(unit \\cdot min)}$\n- $\\sigma_H = -0.03 \\ \\mathrm{(unit)/(mg/dL \\cdot min)}$\n- $\\sigma_I = 0.04 \\ \\mathrm{(unit)/(mg/dL \\cdot min)}$\n\n**Task:**\nFor each test case, sweep the feedback gain $k_H$ over a specified range while keeping $k_I$ fixed. Identify all maximal contiguous subintervals of $k_H$ on the discretized grid where the system is \"safe\". The result for each test case should be a list of interval pairs $[k_{\\text{start}}, k_{\\text{end}}]$.\n\n**Test Suite:**\n1.  $k_I = 0.05$; sweep $k_H$ from $-0.10$ to $0.20$ with step $0.005$.\n2.  $k_I = -0.10$; sweep $k_H$ from $-0.10$ to $0.20$ with step $0.005$.\n3.  $k_I = 0.20$; sweep $k_H$ from $-0.05$ to $0.50$ with step $0.01$.\n\n**Output Format:**\nA single line with a comma-separated list of results for the three test cases, enclosed in brackets. Example: `[[[x_1,x_2],[x_3,x_4]],[],[[y_1,y_2]]]` (with no spaces).\n\n### Step 2: Validate Using Extracted Givens\n\n-   **Scientifically Grounded:** The problem uses a standard linearized state-space model, a fundamental technique in systems biology and control engineering for analyzing the local stability of a system around an equilibrium point. The physiological assumptions (e.g., insulin lowers glucose, glucagon raises it) are correct. The model is scientifically sound.\n-   **Well-Posed:** The problem is well-posed. For any given pair of controller gains $(k_H, k_I)$, the Jacobian matrix $A$ is uniquely defined. Its eigenvalues can be computed unambiguously. The criteria for a \"safe\" system are precise and objective (all eigenvalues must be real and have strictly negative real parts). The task is a well-defined numerical analysis procedure.\n-   **Objective:** The problem is stated in objective, mathematical language. It is free of ambiguity, subjectivity, or opinion-based claims.\n-   **Completeness:** All necessary numerical values for the model parameters, the structure of the equations, the definition of safety, and the specifications for the numerical sweeps are provided. The problem is self-contained.\n-   **Consistency:** The units are consistent. The provided Jacobian matrix is correctly derived from substituting the control laws $u_H = -k_H G$ and $u_I = k_I G$ into the system dynamics and then linearizing.\n    - $\\frac{dH}{dt} = -a_H H + (\\sigma_H - k_H)G$\n    - $\\frac{dI}{dt} = -a_I I + (\\sigma_I + k_I)G$\n    - $\\frac{dG}{dt} = c_H H - c_I I - a_G G$\n    The Jacobian $\\frac{\\partial \\mathbf{\\dot{x}}}{\\partial \\mathbf{x}}$ for $\\mathbf{x} = [H, I, G]^T$ corresponds exactly to the given matrix $A$.\n\n### Step 3: Verdict and Action\n\nThe problem is **valid**. It is a well-defined, scientifically grounded numerical analysis task based on a standard model in biomedical engineering. I will proceed with the solution.\n\nThe solution requires a numerical sweep over the parameter $k_H$ for three distinct, fixed values of $k_I$. For each point on the $k_H$ grid, the following steps are necessary:\n1.  Construct the $3 \\times 3$ Jacobian matrix $A(k_H, k_I)$ using the given constant parameters and the current values of the gains.\n2.  Compute the three eigenvalues of this matrix. A standard numerical library function, such as `numpy.linalg.eigvals` in Python, is suitable for this.\n3.  Check if the computed eigenvalues satisfy the two conditions for the system to be \"safe\":\n    a.  All eigenvalues must be real. Numerically, this means their imaginary parts must be zero (or within a small tolerance, e.g., $ 10^{-9}$, to account for floating-point inaccuracies).\n    b.  The real parts of all eigenvalues must be strictly negative (i.e., $ 0$).\n4.  After classifying each point on the $k_H$ grid as \"safe\" or \"unsafe\", the final step is to identify the maximal contiguous subintervals within the grid where all points are \"safe\".\n\nThis process will be repeated for each of the three test cases. The resulting lists of safe intervals will then be formatted into a single string as specified. A helper function will be designed to find these contiguous intervals from a boolean list of safety statuses corresponding to the grid points. The final output will be generated by converting the list of results into a string, ensuring no whitespace is included, to match the required format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a one-parameter bifurcation analysis for a glucose regulation model.\n\n    The function sweeps the controller gain k_H for fixed values of k_I,\n    computes the eigenvalues of the system's Jacobian matrix at each point,\n    and identifies \"safe\" intervals where all eigenvalues are real and strictly negative.\n    \"\"\"\n    # Define constant model parameters\n    a_H = 0.15      # min^-1\n    a_I = 0.25      # min^-1\n    a_G = 0.10      # min^-1\n    c_H = 0.60      # (mg/dL)/(unit * min)\n    c_I = 1.20      # (mg/dL)/(unit * min)\n    sigma_H = -0.03 # (unit)/(mg/dL * min)\n    sigma_I = 0.04  # (unit)/(mg/dL * min)\n\n    # Define the test cases for the parameter sweeps\n    test_cases = [\n        {'k_I': 0.05, 'k_H_start': -0.10, 'k_H_end': 0.20, 'k_H_step': 0.005},\n        {'k_I': -0.10, 'k_H_start': -0.10, 'k_H_end': 0.20, 'k_H_step': 0.005},\n        {'k_I': 0.20, 'k_H_start': -0.05, 'k_H_end': 0.50, 'k_H_step': 0.01},\n    ]\n\n    all_results = []\n    TOLERANCE = 1e-9  # Tolerance for checking if an imaginary part is zero\n\n    for case in test_cases:\n        k_I = case['k_I']\n        start, end, step = case['k_H_start'], case['k_H_end'], case['k_H_step']\n\n        # Generate the grid of k_H values using np.linspace for precision\n        num_points = int(round((end - start) / step)) + 1\n        k_H_grid = np.linspace(start, end, num_points)\n\n        is_safe_list = []\n        for k_H in k_H_grid:\n            # Construct the Jacobian matrix A for the current (k_H, k_I) pair\n            A = np.array([\n                [-a_H, 0.0, sigma_H - k_H],\n                [0.0, -a_I, sigma_I + k_I],\n                [c_H, -c_I, -a_G]\n            ])\n\n            # Compute the eigenvalues of the matrix\n            eigenvalues = np.linalg.eigvals(A)\n\n            # Check the \"safe\" conditions\n            # 1. All eigenvalues must be real.\n            all_real = np.all(np.abs(np.imag(eigenvalues))  TOLERANCE)\n            # 2. All real parts must be strictly negative.\n            all_neg_real = np.all(np.real(eigenvalues)  0.0)\n\n            is_safe_list.append(all_real and all_neg_real)\n\n        # Identify contiguous subintervals of safe k_H values\n        safe_intervals = []\n        in_interval = False\n        start_k_H = None\n        for i, is_safe in enumerate(is_safe_list):\n            if is_safe and not in_interval:\n                start_k_H = k_H_grid[i]\n                in_interval = True\n            elif not is_safe and in_interval:\n                end_k_H = k_H_grid[i - 1]\n                safe_intervals.append([start_k_H, end_k_H])\n                in_interval = False\n        \n        # If the sweep ends while in a safe interval, close the interval\n        if in_interval:\n            end_k_H = k_H_grid[-1]\n            safe_intervals.append([start_k_H, end_k_H])\n            \n        all_results.append(safe_intervals)\n\n    # Format the final output string to match the required format '[[...],[],...]'\n    # with no whitespace. Using str() and replace() is a robust way to achieve this.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}