{
    "hands_on_practices": [
        {
            "introduction": "希尔函数并非一个凭空选择的数学曲线，它源于分子结合的物理化学原理。这项练习将指导你从统计力学的基本假设出发，推导出希尔函数，并探索高合作性系数 $n$ 如何产生超敏感的开关式响应。理解这一点对于认识细胞如何做出精确的“开/关”决策至关重要。",
            "id": "4393060",
            "problem": "转录激活因子 $X$ 以协同方式调控一个启动子：只有当 $n$ 个 $X$ 分子同时结合时，启动子才会切换到激活状态。假设系统处于快速平衡状态，结合的激活因子对启动子的消耗可忽略不计（即总激活因子浓度约等于游离浓度），且启动子上的结合位点是相同且不可区分的。非激活的启动子状态的统计权重为 $1$，而激活状态的统计权重与 $[X]^{n}$ 成正比，其中 $[X]$ 表示激活因子的浓度。设比例常数（一个平衡结合参数）为 $\\kappa$，其单位为 $\\text{(浓度)}^{-n}$。\n\n从质量作用定律和结合的平衡统计力学出发，推导归一化的启动子活性 $A_{n}([X])$，该活性定义为启动子处于激活状态的概率，并用 $[X]$、$n$ 和一个由 $\\kappa$ 定义的有效浓度标度 $K$ 来表示。然后，为了表征高协同性极限下激活阈值的边缘行为，定义一个标度化变量 $z = n \\ln\\!\\left(\\frac{[X]}{K}\\right)$ 并评估极限标度化活性\n$$\ng(z) = \\lim_{n \\to \\infty} A_{n}\\!\\big(K \\exp(z/n)\\big).\n$$\n将 $g(z)$ 的最终答案表示为一个无单位的、单一的闭合形式解析表达式。不需要进行数值计算或四舍五入。",
            "solution": "该问题陈述经核实具有科学依据、提法恰当且客观。它描述了一个基于平衡统计力学的协同性转录激活的标准模型。其推导是系统生物学中的一个教科书式练习。\n\n该问题要求得到两个主要结果：首先，推导归一化的启动子活性 $A_n([X])$ 作为激活因子浓度 $[X]$、协同性参数 $n$ 和有效浓度标度 $K$ 的函数；其次，在高协同性极限 ($n \\to \\infty$) 下评估极限标度化活性 $g(z)$。\n\n首先，我们推导归一化的启动子活性 $A_n([X])$ 的表达式。该系统由一个启动子组成，它可以存在于两种状态之一：非激活状态（未结合或部分结合，在此协同模型中均视为非激活）和激活状态（有 $n$ 个激活因子 $X$ 分子同时结合）。\n\n根据平衡统计力学的原理，系统处于某一特定状态的概率与其统计权重成正比。问题给出了两种状态的统计权重：\n1.  非激活的启动子状态：统计权重 $W_{\\text{inactive}} = 1$。\n2.  激活的启动子状态，其中 $n$ 个激活因子 $X$ 分子结合：统计权重 $W_{\\text{active}} = \\kappa [X]^n$，其中 $[X]$ 是激活因子浓度，$\\kappa$ 是一个平衡结合参数。\n\n配分函数 $Z$ 是系统所有可能状态的统计权重的总和。\n$$\nZ = W_{\\text{inactive}} + W_{\\text{active}} = 1 + \\kappa [X]^n\n$$\n\n归一化的启动子活性 $A_n([X])$ 定义为启动子处于激活状态的概率。该概率由激活状态的统计权重与总配分函数之比给出。\n$$\nA_n([X]) = \\frac{W_{\\text{active}}}{Z} = \\frac{\\kappa [X]^n}{1 + \\kappa [X]^n}\n$$\n\n为了用有效浓度标度 $K$ 来表示该活性，我们将方程重排为希尔函数的标准形式。通过将分子和分母同除以 $\\kappa$，我们得到：\n$$\nA_n([X]) = \\frac{[X]^n}{\\frac{1}{\\kappa} + [X]^n}\n$$\n\n现在我们可以定义一个有效浓度标度 $K$，使其 $n$ 次方对应于 $1/\\kappa$ 这一项。令 $K^n = 1/\\kappa$。此定义意味着 $K = \\kappa^{-1/n}$。$\\kappa$ 的单位为 $(\\text{浓度})^{-n}$，因此 $K$ 的单位是 $((\\text{浓度})^{-n})^{-1/n} = \\text{浓度}$。$K$ 代表启动子活性达到半最大值时的激活因子浓度 $[X]$，因为 $A_n(K) = K^n / (K^n + K^n) = 1/2$。\n\n将 $K^n$ 代入 $A_n([X])$ 的表达式，我们得到标准的希尔方程：\n$$\nA_n([X]) = \\frac{[X]^n}{K^n + [X]^n}\n$$\n这也可以写作：\n$$\nA_n([X]) = \\frac{\\left(\\frac{[X]}{K}\\right)^n}{1 + \\left(\\frac{[X]}{K}\\right)^n}\n$$\n\n接下来，我们评估当 $n \\to \\infty$ 时的极限标度化活性 $g(z)$。问题定义了一个标度化变量 $z = n \\ln\\left(\\frac{[X]}{K}\\right)$，它聚焦于 $[X]=K$ 附近的过渡区域。从这个定义中，我们可以用 $z$ 和 $n$ 来表示比值 $[X]/K$：\n$$\n\\frac{z}{n} = \\ln\\left(\\frac{[X]}{K}\\right) \\implies \\frac{[X]}{K} = \\exp\\left(\\frac{z}{n}\\right)\n$$\n这意味着浓度 $[X]$ 被设为 $K \\exp(z/n)$。因此，在极限中要求值的函数是 $A_n([X])$，其中对 $[X]$ 进行了这一特定替换。\n\n我们将 $[X]/K = \\exp(z/n)$ 代入 $A_n([X])$ 的表达式中：\n$$\nA_n\\big(K \\exp(z/n)\\big) = \\frac{\\left(\\exp\\left(\\frac{z}{n}\\right)\\right)^n}{1 + \\left(\\exp\\left(\\frac{z}{n}\\right)\\right)^n}\n$$\n简化分子和分母中的指数项得到：\n$$\n\\left(\\exp\\left(\\frac{z}{n}\\right)\\right)^n = \\exp\\left(\\frac{z}{n} \\times n\\right) = \\exp(z)\n$$\n将此代回活性的表达式，我们得到：\n$$\nA_n\\big(K \\exp(z/n)\\big) = \\frac{\\exp(z)}{1 + \\exp(z)}\n$$\n现在我们可以计算所求的极限，即极限标度化活性 $g(z)$：\n$$\ng(z) = \\lim_{n \\to \\infty} A_{n}\\!\\big(K \\exp(z/n)\\big) = \\lim_{n \\to \\infty} \\left( \\frac{\\exp(z)}{1 + \\exp(z)} \\right)\n$$\n表达式 $\\frac{\\exp(z)}{1 + \\exp(z)}$ 不包含变量 $n$。因此，当 $n \\to \\infty$ 时的极限就是表达式本身。\n$$\ng(z) = \\frac{\\exp(z)}{1 + \\exp(z)}\n$$\n这个函数，即逻辑斯谛函数，描述了在高协同性极限下，通过标度化变量 $z$ 的视角观察到的激活曲线的“软”阶跃函数形状。\n这就是 $g(z)$ 的最终闭合形式解析表达式。",
            "answer": "$$\n\\boxed{\\frac{\\exp(z)}{1 + \\exp(z)}}\n$$"
        },
        {
            "introduction": "生物系统本质上是动态变化的，静态的希尔函数需要被置于动态框架中才能描述真实的生命过程。这项练习将静态的希尔函数作为生产项，结合一级降解过程，构建描述基因产物（如mRNA）浓度随时间变化的常微分方程。这是构建任何基因调控网络模型的基础单元。",
            "id": "4393067",
            "problem": "哺乳动物细胞核中的一个基因受激活转录因子（TF）的调控。其启动子有 $n$ 个相同的结合位点，以一种全有或全无的协同方式起作用：当且仅当所有 $n$ 个位点都被 TF 占据时，启动子才具有转录活性。假设转录因子与启动子的结合和解离在比信使核糖核酸（mRNA）合成和降解快得多的时间尺度上达到热力学平衡。该基因产生 mRNA 的合成速率与启动子处于活性状态的概率成正比，且 mRNA 通过一级动力学降解。从核心的物理化学和生物化学原理——启动子-TF相互作用的质量作用结合平衡、细致平衡定律和中心法则（脱氧核糖核酸（DNA）转录为 mRNA）出发，推导当 TF 浓度在时间 $t=0$ 时被钳制在恒定值 $\\bar{T}$ 且初始 mRNA 为 $x(0)=0$ 时，mRNA 时间进程 $x(t)$ 的闭式表达式。\n\n假设如下：\n- 单个 TF 结合位点的解离常数为 $K$。\n- 协同结合实际上是全有或全无的：启动子的活性状态需要 $n$ 个 TF 分子同时占据。\n- mRNA 合成速率常数为 $k_{\\mathrm{tr}}$（单位：分子/细胞/单位时间），与启动子处于活性状态的概率成正比。\n- mRNA 降解速率常数为 $\\gamma$（单位：每单位时间）。\n- TF 浓度 $\\bar{T}$ 和解离常数 $K$ 使用相同的浓度单位表示。\n- 以“分子/细胞”为单位表示最终的 mRNA 浓度函数 $x(t)$。\n\n您的答案必须是关于 $x(t)$ 的一个单一闭式解析表达式，用 $k_{\\mathrm{tr}}$、$\\gamma$、$\\bar{T}$、$K$、$n$ 和 $t$ 表示。不要给出不等式、需要求解的方程或数值。无需四舍五入。",
            "solution": "该问题要求推导由激活转录因子（TF）调控的基因的信使核糖核酸（mRNA）浓度的时间进程，记为 $x(t)$。推导必须基于生物化学和物理化学的基本原理。\n\n首先，我们对基因启动子的状态进行建模。问题指出，启动子有 $n$ 个相同的 TF 结合位点，并且结合方式是“全有或全无的协同方式”。这意味着我们可以将启动子建模为仅存在两种状态：一个自由的非活性状态（$P_{\\text{free}}$）和一个所有 $n$ 个位点都被占据的完全结合的活性状态（$P_{\\text{active}}$）。具有部分占据的中间状态被认为是可忽略的。其可逆结合反应为：\n$$ P_{\\text{free}} + nT \\rightleftharpoons P_{\\text{active}} $$\n其中 $T$ 代表 TF 分子。\n\n问题指出，与转录和翻译的时间尺度相比，这种结合-解离过程会迅速达到热力学平衡。因此，我们可以将质量作用定律应用于此平衡。该反应的总解离常数 $K_{D}$ 由下式给出：\n$$ K_{D} = \\frac{[P_{\\text{free}}][T]^{n}}{[P_{\\text{active}}]} $$\n其中 $[...]$ 表示浓度。\n\n问题提供了一个单个 TF 结合位点的解离常数 $K$。对于涉及 $n$ 个相同位点的“全有或全无”或完全协同的过程，总解离常数 $K_{D}$ 与单位点常数 $K$ 的关系为 $K_{D} = K^{n}$。这是建模高协同性系统时的标准假设，反映了在协同结合事件中各个结合亲和力的乘法效应。将此代入我们的平衡方程得到：\n$$ K^{n} = \\frac{[P_{\\text{free}}][T]^{n}}{[P_{\\text{active}}]} $$\n\n启动子仅在处于 $P_{\\text{active}}$ 状态时才具有转录活性。启动子处于活性状态的概率 $p_{\\text{active}}$ 是总启动子群体中处于活性状态的部分：\n$$ p_{\\text{active}} = \\frac{[P_{\\text{active}}]}{[P_{\\text{total}}]} = \\frac{[P_{\\text{active}}]}{[P_{\\text{free}}] + [P_{\\text{active}}]} $$\n根据平衡表达式，我们可以用 $[P_{\\text{active}}]$ 来表示 $[P_{\\text{free}}]$：\n$$ [P_{\\text{free}}] = [P_{\\text{active}}] \\frac{K^{n}}{[T]^{n}} $$\n将此代入 $p_{\\text{active}}$ 的方程中：\n$$ p_{\\text{active}} = \\frac{[P_{\\text{active}}]}{[P_{\\text{active}}] \\frac{K^{n}}{[T]^{n}} + [P_{\\text{active}}]} $$\n通过消去分子和分母中的 $[P_{\\text{active}}]$ 项，我们得到：\n$$ p_{\\text{active}} = \\frac{1}{\\frac{K^{n}}{[T]^{n}} + 1} = \\frac{[T]^{n}}{K^{n} + [T]^{n}} $$\n这就是著名的希尔函数，描述了启动子对 TF 浓度的概率响应。问题指出，对于 $t \\ge 0$，TF 浓度被钳制在恒定值 $\\bar{T}$。因此，激活概率在时间上是恒定的：\n$$ p_{\\text{active}} = \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} $$\n\n接下来，我们建立控制 mRNA 浓度 $x(t)$ 的微分方程。$x(t)$ 的变化率是其合成速率和降解速率之差。\n$$ \\frac{dx}{dt} = (\\text{synthesis rate}) - (\\text{degradation rate}) $$\n合成速率与启动子处于活性状态的概率成正比，速率常数为 $k_{\\mathrm{tr}}$。\n$$ \\text{synthesis rate} = k_{\\mathrm{tr}} \\cdot p_{\\text{active}} = k_{\\mathrm{tr}} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} $$\nmRNA 的降解遵循一级动力学，速率常数为 $\\gamma$。\n$$ \\text{degradation rate} = \\gamma x(t) $$\n结合这些项，我们得到以下一阶线性常微分方程（ODE）：\n$$ \\frac{dx}{dt} = k_{\\mathrm{tr}} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} - \\gamma x(t) $$\n令常数合成项表示为 $C_S = k_{\\mathrm{tr}} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}}$。该 ODE 变为：\n$$ \\frac{dx}{dt} + \\gamma x(t) = C_S $$\n这是一阶线性 ODE 的标准形式。通解可以通过使用积分因子或将齐次解和特解相加来求得。$\\frac{dx_h}{dt} + \\gamma x_h = 0$ 的齐次解是 $x_h(t) = A \\exp(-\\gamma t)$，其中 $A$ 是一个积分常数。对于特解，由于右侧是常数，我们可以假设一个常数特解 $x_p(t) = B$。将其代入 ODE 得到 $0 + \\gamma B = C_S$，所以 $B = \\frac{C_S}{\\gamma}$。\n通解是齐次解和特解之和：\n$$ x(t) = x_h(t) + x_p(t) = A \\exp(-\\gamma t) + \\frac{C_S}{\\gamma} $$\n\n为了确定常数 $A$，我们应用问题中给定的初始条件：$x(0) = 0$。\n$$ x(0) = A \\exp(-\\gamma \\cdot 0) + \\frac{C_S}{\\gamma} = A \\cdot 1 + \\frac{C_S}{\\gamma} = 0 $$\n这给出 $A = -\\frac{C_S}{\\gamma}$。\n\n将 $A$ 代回通解，我们得到 $x(t)$ 的特解：\n$$ x(t) = -\\frac{C_S}{\\gamma} \\exp(-\\gamma t) + \\frac{C_S}{\\gamma} = \\frac{C_S}{\\gamma} (1 - \\exp(-\\gamma t)) $$\n最后，我们代入 $C_S$ 的完整表达式：\n$$ x(t) = \\frac{1}{\\gamma} \\left( k_{\\mathrm{tr}} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} \\right) (1 - \\exp(-\\gamma t)) $$\n这个表达式可以更紧凑地写为：\n$$ x(t) = \\frac{k_{\\mathrm{tr}}}{\\gamma} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} (1 - \\exp(-\\gamma t)) $$\n这就是基于给定参数和原理的 mRNA 浓度随时间变化的闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{k_{\\mathrm{tr}}}{\\gamma} \\frac{\\bar{T}^{n}}{K^{n} + \\bar{T}^{n}} (1 - \\exp(-\\gamma t))}$$"
        },
        {
            "introduction": "将单个基因的动态模型连接起来，可以产生复杂的、超越单个组件功能的“涌现”行为。这项练习将挑战你为一个最重要的网络基序——正反馈回路——建模。通过数值计算，你将亲手发现这个简单的电路如何产生“双稳态”，这一特性是细胞记忆、分化等关键生命现象的分子基础。",
            "id": "4393065",
            "problem": "单个基因产物通过与其启动子协同结合来激活自身的转录，从而进行正反馈。假设转录激活源于启动子被激活剂的平衡占据，激活剂浓度用 $A$ 表示（单位为 $\\mathrm{nM}$），此过程遵循快速平衡近似和解离常数为 $K$（单位为 $\\mathrm{nM}$）的 $n$ 阶协同结合。设存在基础生产速率 $\\alpha_0$（单位为 $\\mathrm{nM}/\\mathrm{h}$）、最大激活放大生产贡献 $\\alpha$（单位为 $\\mathrm{nM}/\\mathrm{h}$）以及一级降解速率常数 $\\delta$（单位为 $\\mathrm{h}^{-1}$）。激活剂浓度 $A(t)$ 的连续时间动力学由一个根据这些组分构建的一维常微分方程控制。\n\n从以下基本原理出发：(i) 启动子协同占据的质量作用结合平衡，(ii) 分子生物学的中心法则（DNA $\\rightarrow$ RNA $\\rightarrow$ 蛋白质）断言转录活性决定生产速率，以及 (iii) 线性一级降解，推导出由启动子协同占据产生的、作为 $A$ 的饱和单调递增函数的调控激活函数，并构建 $A(t)$ 的动力学方程。然后，重点研究稳态及其稳定性。\n\n对于给定的参数集 $(\\alpha_0,\\alpha,\\delta,K,n)$，通过令总生产等于总降解来定义 $A\\ge 0$ 的稳态方程 $f(A)=0$。如果一维稳定性判据成立，即导数 $\\frac{d f}{d A}(A^\\ast)$ 为负，则稳态 $A^\\ast$ 是稳定的；如果导数为正，则是不稳定的。在具有足够协同性的强正反馈下，可能存在多个稳态，包括由一个不稳定稳态分隔开的两个稳定稳态所构成的双稳态。\n\n您的程序必须：\n- 基于协同占据的平衡占据实现推导出的调控函数，并根据生产项和降解项构建 $f(A)$。\n- 通过扫描一个足够大的区间并对符号变化进行区间限定，然后用一个鲁棒的求解器精化根，以数值方式找到所有非负稳态 $A^\\ast$（$f(A)$ 在 $A\\ge 0$ 上的根）。\n- 使用根处 $\\frac{d f}{d A}$ 的符号将每个稳态分类为稳定或不稳定。\n- 对于每个测试用例，返回稳定稳态的数量和稳定稳态浓度的排序列表（升序），以 $\\mathrm{nM}$ 为单位表示为浮点值。\n\n使用以下具有科学合理参数的测试套件：\n- 测试用例 1：$(\\alpha_0,\\alpha,\\delta,K,n)=(2,120,1,20,4)$，其中 $A$ 的单位为 $\\mathrm{nM}$，速率单位为 $\\mathrm{nM}/\\mathrm{h}$ 和 $\\mathrm{h}^{-1}$。\n- 测试用例 2：$(\\alpha_0,\\alpha,\\delta,K,n)=(2,15,1,20,4)$，其中 $A$ 的单位为 $\\mathrm{nM}$，速率单位为 $\\mathrm{nM}/\\mathrm{h}$ 和 $\\mathrm{h}^{-1}$。\n- 测试用例 3：$(\\alpha_0,\\alpha,\\delta,K,n)=(2,120,8,20,4)$，其中 $A$ 的单位为 $\\mathrm{nM}$，速率单位为 $\\mathrm{nM}/\\mathrm{h}$ 和 $\\mathrm{h}^{-1}$。\n- 测试用例 4：$(\\alpha_0,\\alpha,\\delta,K,n)=(2,120,1,20,1)$，其中 $A$ 的单位为 $\\mathrm{nM}$，速率单位为 $\\mathrm{nM}/\\mathrm{h}$ 和 $\\mathrm{h}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的各测试用例结果项列表。每个用例项本身必须是一个形如 $[\\text{num\\_stable},[\\text{stable\\_root}_1,\\text{stable\\_root}_2,\\ldots]]$ 的列表，不含空格。例如，对于两个测试用例，格式将是 $[[2,[a,b]],[1,[c]]]$，其中 $a$、$b$ 和 $c$ 是以 $\\mathrm{nM}$ 为单位、用十进制表示的浮点浓度。对于上面指定的四个测试用例，最终输出必须遵循此确切格式。",
            "solution": "该问题要求对一个遗传自调控网络的稳态及其稳定性进行分析。核心任务包括推导控制微分方程，确定稳态条件，以及实现一个数值算法来为给定的参数集找到并分类稳态。\n\n首先，我们根据所提供的物理和生物学原理构建数学模型。激活剂蛋白的浓度，用 $A$ 表示，随时间的变化取决于其生产和降解之间的平衡。这可以表示为一个一维常微分方程（ODE）：\n$$ \\frac{dA}{dt} = \\text{生产速率} - \\text{降解速率} $$\n\n降解过程被描述为一个速率常数为 $\\delta$ 的一级反应。因此，降解速率与浓度 $A$ 成正比：\n$$ \\text{降解速率} = \\delta A $$\n\n激活剂的生产受激活剂自身调节。存在一个基础生产速率 $\\alpha_0$，即使在没有激活剂的情况下也会发生。此外，激活剂通过与其启动子结合来增强其自身的生产。这种结合被描述为一个 $n$ 阶的协同过程。在快速平衡近似下，被激活剂占据的启动子分数 $\\theta$ 由希尔函数给出：\n$$ \\theta(A) = \\frac{A^n}{K^n + A^n} $$\n这里，$K$ 是解离常数，代表启动子占据率达到一半时的 $A$ 浓度。激活的生产速率与该占据分数成正比，最大激活放大贡献为 $\\alpha$。总生产速率是基础速率和激活速率之和：\n$$ \\text{生产速率} = \\alpha_0 + \\alpha \\cdot \\theta(A) = \\alpha_0 + \\alpha \\frac{A^n}{K^n + A^n} $$\n\n结合生产项和降解项，我们得到 $A(t)$ 的完整动力学方程：\n$$ \\frac{dA}{dt} = \\alpha_0 + \\alpha \\frac{A^n}{K^n + A^n} - \\delta A $$\n\n系统的稳态是指净变化率为零时的浓度 $A^\\ast$，即 $\\frac{dA}{dt} = 0$。这个条件定义了稳态方程 $f(A) = 0$，其中：\n$$ f(A) = \\alpha_0 + \\alpha \\frac{A^n}{K^n + A^n} - \\delta A $$\n该方程的非负根 $A^\\ast \\ge 0$ 对应于稳态浓度。在图形上，这些是 S 型生产曲线 $P(A) = \\alpha_0 + \\alpha \\frac{A^n}{K^n + A^n}$ 和线性降解直线 $D(A) = \\delta A$ 的交点。\n\n稳态 $A^\\ast$ 的稳定性由系统对 $A^\\ast$ 周围小扰动的响应决定。对于一维系统，这由在稳态处计算的 $f(A)$ 导数的符号给出。如果 $\\frac{df}{dA}(A^\\ast)  0$，则稳态 $A^\\ast$ 是稳定的，意味着扰动会衰减，系统返回到 $A^\\ast$。如果 $\\frac{df}{dA}(A^\\ast)  0$，则它是不稳定的，意味着扰动会被放大，使系统偏离 $A^\\ast$。\n\n为了求导数，我们将 $f(A)$ 对 $A$ 求导：\n$$ \\frac{df}{dA} = \\frac{d}{dA} \\left( \\alpha_0 + \\alpha \\frac{A^n}{K^n + A^n} - \\delta A \\right) $$\n对希尔函数项使用商法则，我们得到：\n$$ \\frac{df}{dA} = \\alpha \\frac{(nA^{n-1})(K^n + A^n) - (A^n)(nA^{n-1})}{(K^n + A^n)^2} - \\delta = \\alpha \\frac{nK^nA^{n-1}}{(K^n + A^n)^2} - \\delta $$\n\n数值实现过程如下：\n$1$. 对于每个参数集 $(\\alpha_0, \\alpha, \\delta, K, n)$，定义 $f(A)$ 和 $\\frac{df}{dA}$ 的函数。\n$2$. 确定根 $A^\\ast$ 的合适搜索区间。任何稳态的一个安全上限由最大可能生产速率除以降解常数给出，$A_{max} = (\\alpha_0 + \\alpha) / \\delta$。我们扫描一个稍大的区间，例如，从 $0$ 到 $1.5 \\cdot A_{max} + 10$。\n$3$. 以小步长扫描该区间，以识别 $f(A)$ 符号发生变化的连续点对。每对这样的点都限定了一个根的范围。\n$4$. 对于找到的每个区间，使用一个鲁棒的数值求根算法，例如 Brent-Dekker 方法（在 `scipy.optimize.brentq` 中实现），来找到根 $A^\\ast$ 的精确值。\n$5$. 对于每个根 $A^\\ast$，计算导数 $\\frac{df}{dA}(A^\\ast)$。\n$6$. 如果 $\\frac{df}{dA}(A^\\ast)  0$，则该根被分类为稳定。\n$7$. 收集每个案例的稳定根，按升序排序，并按照问题陈述中指定的格式与它们的数量一起格式化。\n此过程系统地找到所有非负稳态并确定其稳定性，从而使我们能够为每组参数表征系统的行为（单稳态与双稳态）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves for the stable steady states of a genetic auto-activation circuit.\n\n    The function iterates through a set of test cases, each defined by parameters\n    (alpha0, alpha, delta, K, n). For each case, it finds the non-negative roots\n    of the steady-state equation f(A) = 0 and classifies them as stable or unstable.\n\n    The steady-state equation is:\n    f(A) = alpha0 + alpha * A^n / (K^n + A^n) - delta * A\n\n    A steady state A* is stable if df/dA(A*)  0. The derivative is:\n    df/dA = alpha * n * K^n * A^(n-1) / (K^n + A^n)^2 - delta\n    \"\"\"\n    test_cases = [\n        # (alpha0, alpha, delta, K, n)\n        (2, 120, 1, 20, 4),\n        (2, 15, 1, 20, 4),\n        (2, 120, 8, 20, 4),\n        (2, 120, 1, 20, 1)\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        alpha0, alpha, delta, K, n = case\n\n        # To avoid potential overflow with large powers, use log-exp trick if needed,\n        # but standard float64 is sufficient for these parameters.\n        # Define f(A) and its derivative df/dA\n        def f(A):\n            if A  0:\n                return np.inf  # We only care about A >= 0\n            A_n = A**n\n            K_n = K**n\n            return alpha0 + alpha * A_n / (K_n + A_n) - delta * A\n\n        def dfdA(A):\n            if A  0:\n                return 0 # Value for A0 is not relevant for stability analysis.\n            \n            # Handle A=0 case for A**(n-1) when n=1, where it's A**0=1.\n            # a**(b-1) for a=0, b=1 should be 1. np.power(0,0) is 1.\n            A_pow_n_minus_1 = np.power(A, n - 1)\n            \n            K_n = K**n\n            A_n = A**n\n            \n            numerator = alpha * n * K_n * A_pow_n_minus_1\n            denominator = (K_n + A_n)**2\n            \n            if denominator == 0:\n                # Should not happen for K>0 or A>0. If K=0 and A=0, it's a singularity.\n                # All K in test cases are > 0.\n                return -delta\n            \n            return numerator / denominator - delta\n\n        # Root finding using a bracketing scan followed by a robust solver\n        roots = []\n        \n        # A generous but informed search range\n        A_max_bound = (alpha0 + alpha) / delta\n        search_domain_max = A_max_bound * 1.5 + 50\n        \n        # Scan for intervals where f(A) changes sign\n        scan_step = 0.01\n        A_scan_points = np.arange(0, search_domain_max, scan_step)\n        \n        # Ensure the first point's value is calculated\n        f_prev = f(A_scan_points[0])\n\n        for i in range(1, len(A_scan_points)):\n            a = A_scan_points[i-1]\n            b = A_scan_points[i]\n            f_curr = f(b)\n            if np.sign(f_curr) != np.sign(f_prev):\n                # A bracket [a, b] is found\n                try:\n                    root = brentq(f, a, b)\n                    # Add root if it's not a duplicate from a previous bracket\n                    if not any(np.isclose(root, r) for r in roots):\n                        roots.append(root)\n                except ValueError:\n                    # brentq might fail if signs are not opposite, though our check prevents this.\n                    # This can happen if one value is exactly zero.\n                    if f_prev == 0:\n                        if not any(np.isclose(a, r) for r in roots):\n                            roots.append(a)\n            f_prev = f_curr\n\n        # If alpha0 is exactly 0, A=0 is a trivial root. Not the case here.\n        # Check f(0) in case the first root is missed by the scan.\n        # f(0) is alpha0, which is > 0 for all cases. So no root at A=0.\n\n        # Classify each found root and collect the stable ones\n        stable_roots = []\n        for root in roots:\n            derivative_at_root = dfdA(root)\n            if derivative_at_root  0:\n                stable_roots.append(root)\n        \n        stable_roots.sort()\n\n        # Store the result for the current case\n        case_result = [len(stable_roots), stable_roots]\n        all_results.append(case_result)\n\n    # Format the final output string as specified: [[num,[root1,...]],...]\n    # without any spaces.\n    result_strings = []\n    for num_stable, roots_list in all_results:\n        # Convert each root to a string, then join them with commas\n        roots_str = f\"[{','.join(map(str, roots_list))}]\"\n        result_strings.append(f\"[{num_stable},{roots_str}]\")\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}