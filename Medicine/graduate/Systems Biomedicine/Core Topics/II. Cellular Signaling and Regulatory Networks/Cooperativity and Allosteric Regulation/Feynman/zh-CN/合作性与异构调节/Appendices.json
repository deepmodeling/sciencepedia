{
    "hands_on_practices": [
        {
            "introduction": "希尔方程是描述协同结合现象的经典唯象模型。这项实践旨在训练一项核心技能：从实验数据中提取关键的定量参数，如半激活浓度（$K_{0.5}$）和希尔系数（$n_H$）。通过将原始测量数据与模型拟合 ，我们可以量化系统的协同性，为理解其调控特性奠定基础。",
            "id": "4331836",
            "problem": "给定某膜转运蛋白的摄取测量数据，其速率对细胞外底物浓度表现出S型依赖关系。在系统生物医学中，这种行为与多蛋白复合物中功能状态的协同和变构调节相一致。从化学动力学和热力学占有率的定义出发，假设稳态摄取速率与处于活性、底物结合状态的转运蛋白分子的分数成正比，并且结合事件之间的协同相互作用导致浓度-响应曲线具有有效的陡峭度。\n\n将半活化浓度 $K_{0.5}$ 定义为摄取速率等于其最大值一半时的底物浓度，并将希尔系数 $n_H$ 定义为在半活化点处，分数活化的对数优势比（log-odds）对浓度自然对数的局部斜率。您的任务是使用协同转运蛋白模型对所提供的数据进行拟合，以估算每个数据集的 $K_{0.5}$ 和 $n_H$。\n\n您的程序必须：\n- 构建一个参数化的浓度-响应模型，该模型与稳态条件下的协同结合相容，并可通过非线性最小二乘法从数据中进行辨识。\n- 通过最小化测量摄取速率与模型预测值之间的残差平方和，估算每个数据集的最大摄取速率、半活化浓度 $K_{0.5}$ 和有效希尔系数 $n_H$。\n- 生成结果，其中 $K_{0.5}$ 以 $\\mu\\mathrm{M}$ 为单位，而 $n_H$ 为无量纲量。两者均以十进制数报告。\n\n提供的测试套件包含四个数据集，每个数据集均指定为底物浓度 $S$（单位为 $\\mu\\mathrm{M}$）和摄取速率 $J$（单位为 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）的配对。请使用这些精确数据，除了拟合过程所隐含的转换外，不要进行任何其他转换。\n\n数据集 $\\mathcal{A}$（宽浓度范围的一般协同情况）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{0.5,1,2,5,10,25,50,100\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.24937656,0.99009901,3.84615385,20.0,50.0,86.20689655,96.15384615,99.00990099\\}$。\n\n数据集 $\\mathcal{B}$（接近非协同行为）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{3,6,12,24,48\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{10.0,17.14285714,26.66666667,36.92307692,45.71428571\\}$。\n\n数据集 $\\mathcal{C}$（具有陡峭活化曲线的高协同性）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{5,10,20,30,50,80,120\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.06167046,0.97560976,13.19587629,40.0,70.96774194,78.44654664,79.76403026\\}$。\n\n数据集 $\\mathcal{D}$（包括零浓度和接近饱和的边界情况）：\n- 浓度 $S$（单位 $\\mu\\mathrm{M}$）：$\\{0,1,5,50\\}$。\n- 摄取速率 $J$（单位 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$）：$\\{0.0,1.92307692,25.0,49.5049505\\}$。\n\n算法要求：\n- 使用非线性最小二乘估计器，并设置参数边界以确保所有拟合参数均为正值。\n- 基于观测到的最大摄取速率和接近半最大响应时的浓度，使用数据驱动的启发式方法初始化参数。\n\n角度单位不适用。所有物理量均已采用其指定单位。将最终输出表示为十进制数。输出格式必须是单行，包含一个用方括号括起来的逗号分隔列表。该列表必须按顺序包含 $\\mathcal{A}$、然后是 $\\mathcal{B}$、然后是 $\\mathcal{C}$、最后是 $\\mathcal{D}$ 的估计值 $K_{0.5}$ 和 $n_H$：\n$[K_{0.5}^{(\\mathcal{A})},n_H^{(\\mathcal{A})},K_{0.5}^{(\\mathcal{B})},n_H^{(\\mathcal{B})},K_{0.5}^{(\\mathcal{C})},n_H^{(\\mathcal{C})},K_{0.5}^{(\\mathcal{D})},n_H^{(\\mathcal{D})}]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5,r_6,r_7,r_8]$）。",
            "solution": "该问题要求将协同转运蛋白模型拟合到四个不同的摄取速率与底物浓度的数据集。目标是估算每个数据集的半活化浓度 $K_{0.5}$ 和希尔系数 $n_H$。\n\n### 问题验证\n\n首先，根据所需标准对问题陈述进行验证。\n\n1.  **已知条件提取**：\n    *   **模型**：稳态摄取速率 $J$ 与活性的、底物结合的转运蛋白分子的分数成正比。该系统表现出S型动力学，表明存在协同性。\n    *   **参数**：$K_{0.5}$ 是摄取速率为最大速率 $J_{max}$ 一半时的底物浓度 $S$。希尔系数 $n_H$ 定义为在 $S=K_{0.5}$ 处评估的分数活化的对数优势比与浓度自然对数的斜率。\n    *   **任务**：使用非线性最小二乘法估算四个数据集（$\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$、$\\mathcal{D}$）的 $J_{max}$、$K_{0.5}$ 和 $n_H$。报告估算出的 $K_{0.5}$ 和 $n_H$。\n    *   **数据**：提供了四组 $(S, J)$ 配对，其中 $S$ 的单位是 $\\mu\\mathrm{M}$，$J$ 的单位是 $\\mathrm{pmol}\\,\\mathrm{s}^{-1}\\,\\mathrm{cell}^{-1}$。\n    *   **约束**：估计器必须使用非线性最小二乘法，强制参数为正，并采用数据驱动的启发式方法进行参数初始化。\n\n2.  **验证检查**：\n    *   **科学依据**：该问题在化学动力学和酶/转运蛋白理论的基本原理方面有坚实的基础。协同结合、S型响应、希尔系数和半活化浓度的概念在生物化学和系统生物学中是标准概念。\n    *   **适定性**：任务是通过曲线拟合进行参数估计，这是一个标准的、适定的数值问题。所提供的数据足以辨识指定模型的三个参数（$J_{max}$、$K_{0.5}$、$n_H$）。\n    *   **客观性**：问题陈述使用了精确、客观和定量的语言。不存在主观因素。\n\n3.  **结论**：该问题是**有效的**。它是一个定量生物数据分析中的标准、科学合理的问题。\n\n### 解答推导\n\n#### 1. 数学模型的构建\n\n摄取速率 $J$ 与转运蛋白活性状态的分数占有率 $\\theta$ 成正比。这可以写成：\n$$ J(S) = J_{max} \\cdot \\theta(S) $$\n其中 $S$ 是底物浓度，$J_{max}$ 是最大摄取速率。\n\n关于协同结合的描述和希尔系数 $n_H$ 的定义指向使用**希尔方程**来为 $\\theta(S)$ 建模。以半活化浓度 $K_{0.5}$ 参数化的标准希尔方程形式是：\n$$ \\theta(S) = \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n这种形式确保了当 $S = K_{0.5}$ 时，$\\theta(K_{0.5}) = \\frac{K_{0.5}^{n_H}}{K_{0.5}^{n_H} + K_{0.5}^{n_H}} = \\frac{1}{2}$，这与 $K_{0.5}$ 的定义一致。\n\n我们来验证模型与所提供的 $n_H$ 定义的一致性。分数活化的对数优势比由 $\\ln(\\frac{\\theta}{1-\\theta})$ 给出。\n首先，我们求出 $1-\\theta$：\n$$ 1 - \\theta(S) = 1 - \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} = \\frac{K_{0.5}^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n然后，优势比是：\n$$ \\frac{\\theta(S)}{1 - \\theta(S)} = \\frac{S^{n_H}}{K_{0.5}^{n_H}} = \\left(\\frac{S}{K_{0.5}}\\right)^{n_H} $$\n取自然对数得到对数优势比，这个关系被称为希尔图：\n$$ \\ln\\left(\\frac{\\theta(S)}{1 - \\theta(S)}\\right) = n_H \\ln(S) - n_H \\ln(K_{0.5}) $$\n对数优势比对 $\\ln(S)$ 的导数是：\n$$ \\frac{d}{d(\\ln S)}\\left[ n_H \\ln(S) - n_H \\ln(K_{0.5}) \\right] = n_H $$\n对于所有 $S  0$，包括在 $S = K_{0.5}$ 点，斜率是常数且等于 $n_H$。因此，该模型与所有提供的定义完全一致。\n\n将这些结合起来，得到摄取速率 $J(S)$ 的最终模型：\n$$ J(S) = J_{max} \\frac{S^{n_H}}{K_{0.5}^{n_H} + S^{n_H}} $$\n为了数值稳定性，尤其是在计算环境中，最好表示为：\n$$ J(S) = \\frac{J_{max}}{1 + \\left(\\frac{K_{0.5}}{S}\\right)^{n_H}} $$\n当 $S$ 很大时，这种形式可以避免计算大数值，并且对于 $n_H  0$，当 $S \\to 0$ 时，可以正确地计算出 $J(S) \\to 0$。\n\n#### 2. 参数估计策略\n\n参数 $J_{max}$、$K_{0.5}$ 和 $n_H$ 将通过最小化每个数据点 $(S_i, J_i)$ 的测量摄取速率 $J_i$ 与模型预测速率 $J(S_i)$ 之间的残差平方和 (SSR) 来估计：\n$$ \\text{SSR}(J_{max}, K_{0.5}, n_H) = \\sum_{i} \\left( J_i - J(S_i; J_{max}, K_{0.5}, n_H) \\right)^2 $$\n这是一个非线性最小二乘优化问题。我们将使用 `scipy.optimize.curve_fit` 函数，该函数实现了Levenberg-Marquardt算法或信赖域反射算法，以找到最小化SSR的参数值。\n\n#### 3. 算法实现\n\n对于每个数据集，实现将按以下步骤进行：\n\n1.  **模型函数**：将定义一个Python函数，实现希尔方程的数值稳定形式。它将显式处理 $S=0$ 的情况，以避免除以零并确保 $J(0) = 0$ 的正确输出。\n\n2.  **初始参数 ($p_0$)**：根据要求，使用数据驱动的启发式方法为优化算法提供初始猜测值：\n    *   $J_{max, init}$：设置为略大于观测到的最大摄取速率的值，例如 $1.05 \\times \\max(J)$。这考虑了可能尚未达到完全饱和的数据集。\n    *   $K_{0.5, init}$：估计为观测摄取速率 $J_i$ 最接近 $0.5 \\times J_{max, init}$ 时的底物浓度 $S_i$。搜索范围限于 $S  0$ 的数据点。\n    *   $n_{H, init}$：选择一个中性的初始值 $1.0$，代表非协同的米氏-门顿情况。\n\n3.  **参数边界**：为了强制正性，所有三个参数（$J_{max}$、$K_{0.5}$、$n_H$）的下界都设置为 $0$，上界设置为无穷大。\n\n4.  **拟合**：使用模型函数、数据、初始参数和边界调用 `scipy.optimize.curve_fit`。\n\n此过程应用于数据集 $\\mathcal{A}$、$\\mathcal{B}$、$\\mathcal{C}$ 和 $\\mathcal{D}$。从每次拟合中得到的 $K_{0.5}$ 和 $n_H$ 的估计值被收集并格式化为最终的输出字符串。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Fits a cooperative transporter model (Hill equation) to concentration-response data\n    to estimate the half-activation concentration (K_0.5) and the Hill coefficient (n_H).\n    \"\"\"\n    # Define the test cases as specified in the problem statement.\n    test_cases = [\n        # Dataset A\n        (np.array([0.5, 1, 2, 5, 10, 25, 50, 100]),\n         np.array([0.24937656, 0.99009901, 3.84615385, 20.0, 50.0, 86.20689655, 96.15384615, 99.00990099])),\n        # Dataset B\n        (np.array([3, 6, 12, 24, 48]),\n         np.array([10.0, 17.14285714, 26.66666667, 36.92307692, 45.71428571])),\n        # Dataset C\n        (np.array([5, 10, 20, 30, 50, 80, 120]),\n         np.array([0.06167046, 0.97560976, 13.19587629, 40.0, 70.96774194, 78.44654664, 79.76403026])),\n        # Dataset D\n        (np.array([0, 1, 5, 50]),\n         np.array([0.0, 1.92307692, 25.0, 49.5049505]))\n    ]\n\n    results = []\n\n    def hill_model(S, J_max, K_0_5, n_H):\n        \"\"\"\n        Numerically stable implementation of the Hill equation for cooperative binding.\n        J(S) = J_max / (1 + (K_0.5 / S)^n_H)\n        \"\"\"\n        # Create an output array initialized to zeros.\n        j_pred = np.zeros_like(S, dtype=float)\n        \n        # Identify where S  0 to avoid division by zero.\n        s_is_positive = S  0\n        \n        # Extract substrate concentrations that are positive.\n        S_pos = S[s_is_positive]\n        \n        # The optimizer may test K_0_5 at the boundary (0). This prevents a division by zero.\n        if K_0_5  0:\n            # Calculate the ratio K_0.5 / S for positive S values.\n            ratio = K_0_5 / S_pos\n            # Calculate the predicted J for these points using the stable formula.\n            j_pred[s_is_positive] = J_max / (1.0 + np.power(ratio, n_H))\n            \n        # For S=0, j_pred remains 0, which is the correct physical limit.\n        return j_pred\n\n    for s_data, j_data in test_cases:\n        # Heuristic for initial parameter guesses (p0) as required by the problem.\n        j_max_obs = np.max(j_data) if len(j_data)  0 else 0\n        \n        # p0 for J_max: A value slightly larger than the observed maximum.\n        p0_jmax = j_max_obs * 1.05 if j_max_obs  0 else 1.0\n\n        # p0 for K_0.5: Substrate concentration where J is closest to half of p0_jmax.\n        # This search is restricted to data points where S is positive.\n        half_max_j = p0_jmax / 2.0\n        \n        s_pos = s_data[s_data  0]\n        j_pos = j_data[s_data  0]\n        \n        if len(s_pos)  0:\n            k05_init_idx = np.argmin(np.abs(j_pos - half_max_j))\n            p0_k05 = s_pos[k05_init_idx]\n        else:\n            # Fallback if all S values are zero.\n            p0_k05 = 1.0\n\n        # Ensure K_0.5 initial guess is a small positive number, not zero.\n        p0_k05 = max(p0_k05, 1e-9)\n        \n        # p0 for n_H: A neutral value of 1.0.\n        p0_nh = 1.0\n\n        p0 = [p0_jmax, p0_k05, p0_nh]\n\n        # Define bounds to enforce positivity of all parameters, as required.\n        lower_bounds = [0.0, 0.0, 0.0]\n        upper_bounds = [np.inf, np.inf, np.inf]\n        \n        try:\n            # Perform nonlinear least squares fitting.\n            params, _ = curve_fit(\n                hill_model,\n                s_data,\n                j_data,\n                p0=p0,\n                bounds=(lower_bounds, upper_bounds),\n                maxfev=10000  # Increased iterations for robustness.\n            )\n            # The returned parameters are (J_max, K_0.5, n_H).\n            _, k05_fit, nh_fit = params\n            results.extend([k05_fit, nh_fit])\n        except RuntimeError:\n            results.extend([np.nan, np.nan])\n\n    # Format the final output as a single-line, comma-separated list of decimal numbers.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然希尔方程能很好地描述协同性，但它并未揭示其分子起源。Monod-Wyman-Changeux (MWC) 模型是一个强大的理论框架，它基于蛋白质的构象系综提供了一种物理机制。这项实践将引导你从第一性原理出发，推导MWC模型的结合方程 ，并通过数值计算探索模型参数如何共同塑造协同响应曲线。",
            "id": "4331823",
            "problem": "要求您实现并使用一个数值求解器，来解决一个由 Monod–Wyman–Changeux (MWC) 协同变构模型控制的配体结合系统。该系统模拟了一个具有 $n$ 个相同配体结合位点的蛋白质，该蛋白质可以以两种构象存在：松弛态（relaxed state，$R$）和紧张态（tense state，$T$）。在没有配体的情况下，这两种构象处于快速平衡中，其构象平衡常数为 $L_0 = [T_0]/[R_0]$。配体与 $R$ 态和 $T$ 态结合，其解离常数分别为 $K_R$ 和 $K_T$。定义 $c = K_R/K_T$ 和 $\\alpha = [L]/K_R$，其中 $[L]$ 是游离配体浓度。假设 $0  c \\leq 1$，因此 $R$ 态对配体的亲和力高于 $T$ 态。\n\n从结合多项式（作为微观状态之和）的定义和质量作用定律出发，推导分数位点占有率 $\\theta([L])$ 的可计算表达式，该表达式是关于 $[L]$、$n$、$L_0$、$K_R$ 和 $c$ 的函数，推导过程不应假设任何预先存在的 $\\theta([L])$ 封闭形式。然后，对于下方的每个测试用例，数值计算出达到目标占有率 $\\theta^\\star = 0.5$ 时所需的游离配体浓度 $[L]$（单位为 $\\mu\\mathrm{M}$），以及由下式定义的相应局部希尔系数 $n_H$：\n$$\nn_H \\equiv \\left. \\frac{d \\ln\\!\\left( \\frac{\\theta}{1-\\theta} \\right)}{d \\ln [L]} \\right|_{\\theta=\\theta^\\star}.\n$$\n您必须在您为 $\\theta^\\star$ 找到的 $[L]$ 浓度下，通过对 $\\ln [L]$ 求导，从 $\\theta([L])$ 数值计算出 $n_H$。\n\n您可以使用的基本原理包括：结合平衡的质量作用定律、配分函数（结合多项式）作为微观状态统计权重之和的定义，以及平均可观测量作为结合多项式对数对相应活度参数的导数的定义。不要使用或假设任何关于 $\\theta([L])$ 的最终“捷径”表达式；请从第一性原理推导它。\n\n数值和输出要求：\n- 对于每个测试用例，在 $[L]  0$ 的区间上，使用一个仅依赖于单调性的稳健区间法来求解满足 $\\theta([L]) = \\theta^\\star$ 的 $[L]$。\n- 在求得的 $[L]$ 处，通过在 $\\ln [L]$ 尺度上使用数值稳定的对称有限差分法来计算 $n_H$。\n- 将 $[L]$ 以 $\\mu\\mathrm{M}$ 为单位表示，将 $n_H$ 表示为无量纲数。将 $[L]$ 和 $n_H$ 均四舍五入到小数点后 $6$ 位。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序为 $[L]_1, n_{H,1}, [L]_2, n_{H,2}, \\dots$，其中下标表示测试用例的索引。\n\n需要实现和求解的测试套件：\n1. $n = 4$, $L_0 = 10^4$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 0.1$, $\\theta^\\star = 0.5$。\n2. $n = 1$, $L_0 = 10^2$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 10^{-2}$, $\\theta^\\star = 0.5$。\n3. $n = 3$, $L_0 = 10^6$, $K_R = 2\\,\\mu\\mathrm{M}$, $c = 1$, $\\theta^\\star = 0.5$。\n4. $n = 6$, $L_0 = 10^8$, $K_R = 0.5\\,\\mu\\mathrm{M}$, $c = 10^{-2}$, $\\theta^\\star = 0.5$。\n5. $n = 4$, $L_0 = 10^{-2}$, $K_R = 1\\,\\mu\\mathrm{M}$, $c = 0.1$, $\\theta^\\star = 0.5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`\"[x_1,y_1,x_2,y_2]\"`），其中每个 $x_i$ 是计算出的 $[L]$（单位为 $\\mu\\mathrm{M}$），每个 $y_i$ 是对应的 $n_H$，两者均四舍五入到小数点后 $6$ 位，并按照上述测试套件的顺序排列。",
            "solution": "该问题要求首先从第一性原理出发，推导 Monod-Wyman-Changeux (MWC) 模型的分数饱和度函数 $\\theta([L])$，然后通过数值实现，为几组不同的参数集，求解当目标饱和度为 $\\theta^\\star=0.5$ 时的配体浓度 $[L]$ 以及相关的希尔系数 $n_H$。\n\n### 1. 分数饱和度函数 $\\theta([L])$ 的推导\n\nMWC 模型假设一个大分子具有 $n$ 个相同且独立的配体结合位点，并且该大分子存在于两种不同的构象状态：松弛态（relaxed state, $R$）和紧张态（tense state, $T$）。这两种状态处于平衡之中，其特征由变构常数 $L_0 = [T_0]/[R_0]$ 描述，其中 $[T_0]$ 和 $[R_0]$ 是在没有配体（$L$）存在时这两种状态的浓度。\n\n我们首先定义系统中每个可能微观状态的统计权重，该权重是相对于未结合的松弛态 $R_0$ 而言的，我们将 $R_0$ 的参考权重赋值为 $1$。一个微观状态由其构象（$R$ 或 $T$）和结合的配体数量（$i$，从 $0$ 到 $n$）来定义。\n\n配体与 $R$ 态结合的微观解离常数为 $K_R$，与 $T$ 态结合的微观解离常数为 $K_T$。设 $[L]$ 为游离配体浓度。为方便起见，我们定义归一化配体浓度 $\\alpha = [L]/K_R$。\n\n结合了 $i$ 个配体的 $R$ 态浓度 $[R_i]$ 通过质量作用定律与 $[R_0]$ 相关联。对于 $n$ 个相同的位点，有 $\\binom{n}{i}$ 种方式来排布 $i$ 个配体。因此，平衡反应 $R_0 + iL \\rightleftharpoons R_i$ 给出：\n$$\n[R_i] = \\binom{n}{i} [R_0] \\left(\\frac{[L]}{K_R}\\right)^i = \\binom{n}{i} [R_0] \\alpha^i\n$$\n因此，$R_i$ 态相对于 $R_0$ 的统计权重是 $\\binom{n}{i} \\alpha^i$。\n\n类似地，对于 $T$ 态，其浓度 $[T_i]$ 由下式给出：\n$$\n[T_i] = \\binom{n}{i} [T_0] \\left(\\frac{[L]}{K_T}\\right)^i\n$$\n使用 $L_0 = [T_0]/[R_0]$ 和定义 $c = K_R/K_T$，我们可以将其表示为相对于 $[R_0]$ 的形式：\n$$\n[T_i] = \\binom{n}{i} (L_0 [R_0]) \\left(\\frac{c[L]}{K_R}\\right)^i = \\binom{n}{i} L_0 [R_0] (c\\alpha)^i\n$$\n$T_i$ 态相对于 $R_0$ 的统计权重是 $L_0 \\binom{n}{i} (c\\alpha)^i$。\n\n结合多项式（或称配分函数）$P$ 是所有可能微观状态的统计权重之和：\n$$\nP = \\sum_{i=0}^{n} (\\text{weight of } R_i) + \\sum_{i=0}^{n} (\\text{weight of } T_i) = \\sum_{i=0}^{n} \\binom{n}{i} \\alpha^i + L_0 \\sum_{i=0}^{n} \\binom{n}{i} (c\\alpha)^i\n$$\n应用二项式定理 $\\sum_{i=0}^{n} \\binom{n}{i} x^i = (1+x)^n$，我们得到结合多项式的封闭形式表达式：\n$$\nP = (1+\\alpha)^n + L_0(1+c\\alpha)^n\n$$\n\n分数饱和度 $\\theta$ 是每个蛋白质平均结合的配体数 $\\langle i \\rangle$ 除以总位点数 $n$。平均结合配体数可以从结合多项式推导得出：\n$$\n\\langle i \\rangle = \\frac{d(\\ln P)}{d(\\ln \\alpha)} = \\frac{\\alpha}{P}\\frac{dP}{d\\alpha}\n$$\n计算 $P$ 对 $\\alpha$ 的导数：\n$$\n\\frac{dP}{d\\alpha} = \\frac{d}{d\\alpha} \\left[ (1+\\alpha)^n + L_0(1+c\\alpha)^n \\right] = n(1+\\alpha)^{n-1} + L_0 n(1+c\\alpha)^{n-1}c\n$$\n将此导数代回到 $\\langle i \\rangle$ 的表达式中：\n$$\n\\langle i \\rangle = \\frac{\\alpha}{P} \\left[ n(1+\\alpha)^{n-1} + L_0 n c (1+c\\alpha)^{n-1} \\right] = \\frac{n\\alpha(1+\\alpha)^{n-1} + nL_0 c\\alpha(1+c\\alpha)^{n-1}}{(1+\\alpha)^n + L_0(1+c\\alpha)^n}\n$$\n最后，分数饱和度 $\\theta([L]) = \\langle i \\rangle / n$ 为：\n$$\n\\theta([L]) = \\frac{\\alpha(1+\\alpha)^{n-1} + L_0 c\\alpha(1+c\\alpha)^{n-1}}{(1+\\alpha)^n + L_0(1+c\\alpha)^n} \\quad \\text{其中 } \\alpha = \\frac{[L]}{K_R}\n$$\n这就是从第一性原理推导出的所需的可计算的 $\\theta$ 表达式。\n\n### 2. 数值计算策略\n\n**a. 求解 $\\theta^\\star = 0.5$ 时的 $[L]$**\n\n我们需要找到方程 $f([L]) = \\theta([L]) - 0.5 = 0$ 的根。函数 $\\theta([L])$ 随 $[L]$ 的增加从 $\\theta(0)=0$ 单调递增至 $\\lim_{[L]\\to\\infty} \\theta([L])=1$。这一性质保证了对于目标饱和度 $\\theta^\\star=0.5$，存在一个唯一的正根 $[L]$。\n\n问题指定了使用稳健的区间法。我们将使用 Brent 方法（如 `scipy.optimize.brentq` 中所实现的），该方法既高效又能保证收敛，前提是给定一个初始区间 $[L_{low}, L_{high}]$，使得 $f(L_{low})$ 和 $f(L_{high})$ 异号。我们可以将 $L_{low}$ 设置为一个非常小的正值（或 $0$），此时 $f(L_{low})  0$。然后，可以通过从一个猜测值（例如 $K_R$）开始，并迭代地增加该值直到函数符号改变，来找到一个上界 $L_{high}$ 使得 $f(L_{high})  0$。\n\n**b. 计算希尔系数 $n_H$**\n\n局部希尔系数定义为：\n$$\nn_H = \\left. \\frac{d \\ln\\!\\left( \\frac{\\theta}{1-\\theta} \\right)}{d \\ln [L]} \\right|_{\\theta=\\theta^\\star}\n$$\n这将使用对称有限差分近似进行数值计算，该方法以其稳定性与（二阶）准确性而著称。设 $y = \\ln [L]$ 和 $g(y) = \\ln(\\theta(e^y) / (1-\\theta(e^y)))$。导数 $g'(y)$ 可近似为：\n$$\nn_H \\approx \\frac{g(y^\\star+h) - g(y^\\star-h)}{2h}\n$$\n其中 $y^\\star = \\ln [L]^\\star$ 是上一步中求得的配体浓度的自然对数，$h$ 是一个很小的步长（例如 $h=10^{-8}$）。我们计算 $[L]_1 = [L]^\\star e^{-h}$ 和 $[L]_2 = [L]^\\star e^{h}$，计算相应的饱和度 $\\theta_1 = \\theta([L]_1)$ 和 $\\theta_2 = \\theta([L]_2)$，然后评估有限差分公式：\n$$\nn_H \\approx \\frac{\\ln\\left(\\frac{\\theta_2}{1-\\theta_2}\\right) - \\ln\\left(\\frac{\\theta_1}{1-\\theta_1}\\right)}{2h}\n$$\n为确保数值精度，尤其是在有限差分计算中，所有中间浮点运算都将使用高精度数据类型（`numpy.longdouble`）执行。最终结果将按要求四舍五入至小数点后 $6$ 位。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef get_theta(L, n, L0, KR, c):\n    \"\"\"\n    Computes the fractional saturation (theta) for the MWC model.\n\n    Args:\n        L (np.longdouble): Free ligand concentration.\n        n (int): Number of binding sites.\n        L0 (float): Allosteric constant [T0]/[R0].\n        KR (float): Dissociation constant for the R state.\n        c (float): Ratio of dissociation constants, KR/KT.\n\n    Returns:\n        np.longdouble: The fractional saturation theta.\n    \"\"\"\n    if L  0:\n        return np.longdouble(0.0)\n    \n    # Use longdouble for higher precision in intermediate calculations\n    L, KR, L0, c = np.longdouble(L), np.longdouble(KR), np.longdouble(L0), np.longdouble(c)\n    n = int(n)\n    \n    alpha = L / KR\n    \n    # Numerator of the theta expression\n    num_term_R = alpha * np.power(1 + alpha, n - 1)\n    num_term_T = L0 * c * alpha * np.power(1 + c * alpha, n - 1)\n    numerator = num_term_R + num_term_T\n\n    # Denominator of the theta expression\n    den_term_R = np.power(1 + alpha, n)\n    den_term_T = L0 * np.power(1 + c * alpha, n)\n    denominator = den_term_R + den_term_T\n    \n    if denominator == 0:\n        # This case is unlikely with positive parameters\n        return np.nan\n        \n    return numerator / denominator\n\ndef solve_L_for_theta_star(theta_star, n, L0, KR, c):\n    \"\"\"\n    Solves for the ligand concentration [L] that yields a target saturation.\n\n    Args:\n        theta_star (float): The target fractional saturation.\n        n, L0, KR, c: Parameters for the MWC model.\n\n    Returns:\n        np.longdouble: The ligand concentration [L] in micromolars.\n    \"\"\"\n    def root_func(L):\n        return get_theta(L, n, L0, KR, c) - theta_star\n    \n    # Establish a bracket [a, b] for the root finder\n    # Since theta(0) = 0, root_func(0) = -theta_star  0.\n    a = np.longdouble(0.0)\n    \n    # Find an upper bound b such that root_func(b)  0\n    b = np.longdouble(KR if KR  0 else 1.0) # Initial guess for the upper bound\n    \n    max_iter = 100\n    count = 0\n    while root_func(b)  0 and count  max_iter:\n        b *= 10\n        count += 1\n    if count == max_iter:\n        raise RuntimeError(f\"Failed to find an upper bracket for the root. Params: n={n}, L0={L0}, KR={KR}, c={c}\")\n\n    # Use Brent's method for robust and efficient root finding\n    L_star = brentq(root_func, a, b, xtol=1e-15, rtol=1e-15)\n    return L_star\n\ndef get_hill_coeff(L_star, n, L0, KR, c):\n    \"\"\"\n    Numerically computes the Hill coefficient at a given ligand concentration.\n\n    Args:\n        L_star (np.longdouble): Ligand concentration at which to evaluate nH.\n        n, L0, KR, c: Parameters for the MWC model.\n\n    Returns:\n        np.longdouble: The local Hill coefficient nH.\n    \"\"\"\n    # Small step size in log-space for symmetric finite difference\n    h = np.longdouble(1e-8)\n    \n    L1 = L_star * np.exp(-h)\n    L2 = L_star * np.exp(h)\n    \n    theta1 = get_theta(L1, n, L0, KR, c)\n    theta2 = get_theta(L2, n, L0, KR, c)\n    \n    # Ensure theta values are within (0, 1) to avoid log domain errors\n    if not (0  theta1  1 and 0  theta2  1):\n        raise ValueError(f\"Theta values out of (0,1) for nH calc: theta1={theta1}, theta2={theta2}\")\n\n    # Numerator of the finite difference formula for d(ln(odds))/d(ln(L))\n    y1 = np.log(theta1 / (1 - theta1))\n    y2 = np.log(theta2 / (1 - theta2))\n    \n    # Symmetric finite difference formula\n    nH = (y2 - y1) / (2 * h)\n    return nH\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (n, L0, KR, c)\n        (4, 1e4, 1.0, 0.1),\n        (1, 1e2, 1.0, 1e-2),\n        (3, 1e6, 2.0, 1.0),\n        (6, 1e8, 0.5, 1e-2),\n        (4, 1e-2, 1.0, 0.1),\n    ]\n    theta_star = 0.5\n    \n    results = []\n    \n    for n, L0, KR, c in test_cases:\n        L_star = solve_L_for_theta_star(theta_star, n, L0, KR, c)\n        nH = get_hill_coeff(L_star, n, L0, KR, c)\n        \n        # Format results to 6 decimal places as required\n        results.append(f\"{float(L_star):.6f}\")\n        results.append(f\"{float(nH):.6f}\")\n\n    # Print the final output in the required single-line format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了单分子层面的变构调控后，我们将视角提升至网络层面，探究其在生物系统中的功能性后果。变构调控是生物通路中复杂行为的关键构成要素。本实践将探讨在一个模拟的代谢网络中，由变构调节剂介导的负反馈如何产生双稳态（bistability）——一种对细胞决策至关重要的“开关”行为 。",
            "id": "4331910",
            "problem": "考虑一个最小化的分支酶促途径，其中一个浓度固定的共同上游底物被转化为一个中间代谢物，然后分配到两个分支中，其中一个分支产生一个效应物，该效应物作为上游和分支酶的负变构调节剂（NAM）。设底物浓度恒定，并用 $X$ 表示中间代谢物浓度，用 $A$ 表示效应物（NAM）浓度。该途径的结构是：一个上游步骤，其进入中间代谢物的有效流入速率为 $v_0$，随后是两个消耗该中间代谢物的流出步骤 $v_1$ 和 $v_2$。效应物 $A$ 的生成与分支 $v_1$ 成正比，并通过一级动力学被清除。\n\n使用以下基本原理和假设，每一项都是系统生物医学和生物化学动力学中广泛接受的起点：\n- 中间代谢物的质量守恒意味着常微分方程 $dX/dt = v_0 - v_1 - v_2$。\n- 效应物平衡意味着 $dA/dt = \\alpha\\, v_1 - k_A A$，其中 $\\alpha$ 是化学计量产率， $k_A$ 是一级清除常数。\n- 单底物酶的 Michaelis–Menten 动力学：对于最大速率为 $V_{\\max}$ 和 Michaelis 常数为 $K_M$ 的酶，其速率作为底物 $S$ 的函数是 $V_{\\max}\\, S/(K_M + S)$。\n- 分支 $v_1$ 的 Hill 型协同性，Hill 系数为 $h$：速率为 $V_1\\, X^{h}/(K_1^{h} + X^{h})$。\n- 负变构调节表示为一个乘法抑制因子，形式为 $1/(1 + (A/K_I)^{n})$，作用于受影响酶的最大速率，其中 $K_I$ 是抑制常数， $n$ 是调节的 Hill（协同性）系数。\n\n假设上游底物浓度 $S_{\\text{in}}$ 恒定，且上游反应表现出受 $A$ 的变构抑制。定义一个有效的上游饱和因子 $V_s = V_0\\, S_{\\text{in}}/(K_0 + S_{\\text{in}})$。模型如下：\n- 上游流入：$v_0(A) = \\dfrac{V_s}{1 + \\left(\\dfrac{A}{K_{I0}}\\right)^{n_0}}$。\n- 分支 1 的协同性消耗：$v_1(X) = \\dfrac{V_1\\, X^{h}}{K_1^{h} + X^{h}}$。\n- 分支 2 的 Michaelis–Menten 消耗及受 $A$ 的额外变构抑制：$v_2(X,A) = \\dfrac{V_2\\, X}{K_2 + X}\\cdot \\dfrac{1}{1 + \\left(\\dfrac{A}{K_{I2}}\\right)^{n_2}}$。\n- 效应物平衡：$dA/dt = \\alpha\\, v_1(X) - k_A A$。\n\n所有浓度必须视为非负实数。在整个问题中，将 $X$ 和 $A$ 的单位解释为微摩尔（micromolar），时间单位为秒，速率单位为微摩尔/秒。任何计算出的通量必须以微摩尔/秒为单位进行数值表示。\n\n从上述质量平衡方程和动力学定义出发，执行以下操作：\n1) 通过施加 $dX/dt = 0$ 和 $dA/dt = 0$ 条件，导出 $(X^{\\ast}, A^{\\ast})$ 的稳态代数系统。\n2) 对于给定的参数集，计算求解稳态方程的所有不同的非负稳态 $(X^{\\ast}, A^{\\ast})$。对于每个稳态，计算该二维动力学系统在 $(X^{\\ast}, A^{\\ast})$ 处的雅可比矩阵，并通过其特征值实部的符号来确定局部渐近稳定性。\n3) 对于每个局部渐近稳定稳态，计算稳态通量 $J_0 = v_0(A^{\\ast})$、$J_1 = v_1(X^{\\ast})$ 和 $J_2 = v_2(X^{\\ast},A^{\\ast})$。\n4) 识别参数集是否表现出双稳态，此处操作性地定义为存在至少两个不同的局部渐近稳定稳态。\n\n您必须实现一个程序，对以下测试套件参数集进行上述步骤的数值计算。在每种情况下，将 $S_{\\text{in}}$ 视为常数，并在模型内部构造 $V_s = V_0\\, S_{\\text{in}}/(K_0 + S_{\\text{in}})$，而不是将其作为独立参数。\n\n- 测试用例 1（基线，预期的单稳态区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 6$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 100$ 微摩尔, $n_0 = 2$.\n  - $V_1 = 2.0$ 微摩尔/秒, $K_1 = 1.0$ 微摩尔, $h = 2$.\n  - $V_2 = 1.5$ 微摩尔/秒, $K_2 = 1.0$ 微摩尔.\n  - $K_{I2} = 1000000$ 微摩尔, $n_2 = 2$.\n  - $\\alpha = 1.0$, $k_A = 0.5$ /秒.\n\n- 测试用例 2（具有更强非线性和反馈的边缘区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 10$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 50$ 微摩尔, $n_0 = 2$.\n  - $V_1 = 3.5$ 微摩尔/秒, $K_1 = 1.0$ 微摩尔, $h = 3$.\n  - $V_2 = 2.5$ 微摩尔/秒, $K_2 = 1.0$ 微摩尔.\n  - $K_{I2} = 6.0$ 微摩尔, $n_2 = 4$.\n  - $\\alpha = 1.2$, $k_A = 0.25$ /秒.\n\n- 测试用例 3（强非线性，可能的双稳态区域）：\n  - $S_{\\text{in}} = 10$ 微摩尔, $V_0 = 12$ 微摩尔/秒, $K_0 = 5$ 微摩尔, $K_{I0} = 40$ 微摩尔, $n_0 = 2$.\n  - $V_1 = 4.5$ 微摩尔/秒, $K_1 = 0.8$ 微摩尔, $h = 4$.\n  - $V_2 = 2.0$ 微摩尔/秒, $K_2 = 0.8$ 微摩尔.\n  - $K_{I2} = 2.5$ 微摩尔, $n_2 = 4$.\n  - $\\alpha = 1.5$, $k_A = 0.2$ /秒.\n\n算法要求和数值规范：\n- 通过寻找由 $dX/dt$ 和 $dA/dt$ 右侧定义的向量函数的所有根来求解稳态方程。在 $(X,A)$ 的合理二维网格上使用多个初始猜测来探索状态空间，并通过欧几里得范数下的一个小容差来去除重复的根。\n- 通过丢弃任何带有负分量或残差范数高于小容差的候选根来强制执行非负性约束。\n- 对于每个候选稳态，计算该点处完整二维系统的雅可比矩阵，并通过特征值对其稳定性进行分类。\n- 对于每个稳定稳态，计算通量三元组 $(J_0, J_1, J_2)$。\n- 对于每个测试用例，按 $X^{\\ast}$ 递增的顺序对稳定稳态进行排序，然后以相同的顺序列出相应的通量三元组。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目。每个条目必须是一个长度固定为 $10$ 的列表，其第一个元素是找到的局部渐近稳定稳态的整数数量，其后是九个浮点数，对应于按 $X^{\\ast}$ 递增顺序排列的最多三个稳定稳态的 $(J_0,J_1,J_2)$；如果找到的稳定稳态少于三个，则用哨兵值 $-1.0$ 填充剩余的通量条目。\n- 输出中的所有浮点数必须四舍五入到小数点后六位。\n- 单行输出必须是语法上有效的列表的列表字符串，例如 $[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$，用逗号分隔。\n\n您的程序必须使用上述测试套件，并按规定生成单行输出。不允许用户输入，也不允许访问外部数据文件或网络。",
            "solution": "该问题要求对一个代表具有变构调节的分支代谢途径的二维动力学系统进行全面分析。该分析涉及推导稳态条件，数值计算所有非负稳态，评估其局部渐近稳定性，并计算相应的代谢通量。\n\n系统的状态由中间代谢物 $X$ 和变构效应物 $A$ 的浓度描述。其动力学由基于质量守恒原理的两个耦合常微分方程（ODE）系统控制：\n$$\n\\frac{dX}{dt} = v_0(A) - v_1(X) - v_2(X, A) \\equiv F(X, A)\n$$\n$$\n\\frac{dA}{dt} = \\alpha\\, v_1(X) - k_A A \\equiv G(X, A)\n$$\n其中，各组分速率函数由以下公式给出：\n- 上游流入：$v_0(A) = \\dfrac{V_s}{1 + \\left(\\dfrac{A}{K_{I0}}\\right)^{n_0}}$，其中 $V_s = \\dfrac{V_0\\, S_{\\text{in}}}{K_0 + S_{\\text{in}}}$。\n- 分支 1 消耗：$v_1(X) = \\dfrac{V_1\\, X^{h}}{K_1^{h} + X^{h}}$。\n- 分支 2 消耗：$v_2(X,A) = \\dfrac{V_2\\, X}{K_2 + X} \\cdot \\dfrac{1}{1 + \\left(\\dfrac{A}{K_{I2}}\\right)^{n_2}}$。\n\n**步骤 1：稳态代数系统的推导**\n\n稳态，表示为 $(X^{\\ast}, A^{\\ast})$，是状态空间中的一个点，在该点系统停止演化，即所有时间导数均为零。我们施加条件 $dX/dt = 0$ 和 $dA/dt = 0$：\n$$\nF(X^{\\ast}, A^{\\ast}) = v_0(A^{\\ast}) - v_1(X^{\\ast}) - v_2(X^{\\ast}, A^{\\ast}) = 0\n$$\n$$\nG(X^{\\ast}, A^{\\ast}) = \\alpha\\, v_1(X^{\\ast}) - k_A A^{\\ast} = 0\n$$\n这是稳态浓度 $(X^{\\ast}, A^{\\ast})$ 的代数系统。从第二个方程，我们可以将 $A^{\\ast}$ 表示为 $X^{\\ast}$ 的显式函数：\n$$\nA^{\\ast}(X^{\\ast}) = \\frac{\\alpha}{k_A} v_1(X^{\\ast}) = \\frac{\\alpha}{k_A} \\frac{V_1\\, (X^{\\ast})^{h}}{K_1^{h} + (X^{\\ast})^{h}}\n$$\n这种关系被称为变量 $A$ 的零斜线。将 $A^{\\ast}$ 的这个表达式代入第一个稳态方程可以消去 $A^{\\ast}$，从而得到一个关于单个变量 $X^{\\ast}$ 的高度非线性方程：\n$$\nv_0(A^{\\ast}(X^{\\ast})) - v_1(X^{\\ast}) - v_2(X^{\\ast}, A^{\\ast}(X^{\\ast})) = 0\n$$\n该方程的根对应于系统稳态的 $X$ 坐标。我们必须找到所有物理上有意义的根，即非负实数 $X^{\\ast} \\ge 0$。\n\n**步骤 2：局部渐近稳定性分析**\n\n为了确定稳态 $(X^{\\ast}, A^{\\ast})$ 的局部渐近稳定性，我们分析系统在该点附近的行为。这通过线性化常微分方程系统来实现，其中涉及计算向量场 $(F, G)$ 在稳态处的雅可比矩阵 $J$：\n$$\nJ(X, A) = \\begin{pmatrix} \\frac{\\partial F}{\\partial X}  \\frac{\\partial F}{\\partial A} \\\\ \\frac{\\partial G}{\\partial X}  \\frac{\\partial G}{\\partial A} \\end{pmatrix} = \\begin{pmatrix} -\\frac{\\partial v_1}{\\partial X} - \\frac{\\partial v_2}{\\partial X}  \\frac{\\partial v_0}{\\partial A} - \\frac{\\partial v_2}{\\partial A} \\\\ \\alpha \\frac{\\partial v_1}{\\partial X}  -k_A \\end{pmatrix}\n$$\n一个稳态 $(X^{\\ast}, A^{\\ast})$ 是局部渐近稳定的，当且仅当雅可比矩阵 $J(X^{\\ast}, A^{\\ast})$ 的所有特征值的实部都为负。所需的偏导数是：\n- $\\frac{\\partial v_0}{\\partial A} = -V_s \\frac{n_0}{K_{I0}} \\left(\\frac{A}{K_{I0}}\\right)^{n_0-1} \\left(1 + \\left(\\frac{A}{K_{I0}}\\right)^{n_0}\\right)^{-2}$\n- $\\frac{\\partial v_1}{\\partial X} = V_1 \\frac{h K_1^h X^{h-1}}{(K_1^h + X^h)^2}$\n- $\\frac{\\partial v_2}{\\partial X} = \\frac{V_2 K_2}{(K_2 + X)^2} \\frac{1}{1 + \\left(\\frac{A}{K_{I2}}\\right)^{n_2}}$\n- $\\frac{\\partial v_2}{\\partial A} = -\\frac{V_2 X}{K_2 + X} \\frac{n_2}{K_{I2}} \\left(\\frac{A}{K_{I2}}\\right)^{n_2-1} \\left(1 + \\left(\\frac{A}{K_{I2}}\\right)^{n_2}\\right)^{-2}$\n\n对于每个有效的根 $X^{\\ast}$，我们计算相应的 $A^{\\ast}$，在 $(X^{\\ast}, A^{\\ast})$ 处评估偏导数，构造雅可比矩阵，并计算其特征值。如果对于所有特征值 $\\lambda_i$，都有 $\\text{Re}(\\lambda_i)  0$，则该稳态是稳定的。\n\n**步骤 3：稳态通量的计算**\n\n对于找到的每个局部渐近稳定稳态 $(X^{\\ast}, A^{\\ast})$，我们计算通过途径中每一步的稳态通量（反应速率）：\n- 流入通量：$J_0 = v_0(A^{\\ast})$\n- 分支 1 通量：$J_1 = v_1(X^{\\ast})$\n- 分支 2 通量：$J_2 = v_2(X^{\\ast}, A^{\\ast})$\n根据第一个稳态方程，必须满足 $J_0 = J_1 + J_2$。这可作为数值解的一致性检查。\n\n**步骤 4：双稳态的识别**\n\n双稳态被定义为对于同一组参数，存在至少两个不同的局部渐近稳定稳态。数值程序将计算找到的稳定稳态的数量。如果此计数为 2 或更大，则系统被归类为双稳态。\n\n**数值实现策略**\n\n问题的核心是找到单变量方程 $H(X) = v_0(A(X)) - v_1(X) - v_2(X, A(X)) = 0$ 的所有非负根。这将通过在 $X  0$ 的足够大的区间上扫描 $H(X)$ 的符号变化来完成。对于每个区间 $[x_i, x_{i+1}]$，如果 $H(x_i)H(x_{i+1})  0$，则应用稳健的数值求根算法（例如 Brent 方法）来找到根 $X^{\\ast}$。找到的根将被去重。\n对于每个唯一的非负根 $X^{\\ast}$（及其对应的 $A^{\\ast} \\ge 0$），通过雅可比矩阵的特征值来评估其稳定性。然后计算所有稳定状态的通量，并根据指定的输出格式进行报告。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the metabolic pathway problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1 (baseline, expected monostable regime)\n        {\n            'S_in': 10.0, 'V0': 6.0, 'K0': 5.0, 'KI0': 100.0, 'n0': 2.0,\n            'V1': 2.0, 'K1': 1.0, 'h': 2.0,\n            'V2': 1.5, 'K2': 1.0, 'KI2': 1000000.0, 'n2': 2.0,\n            'alpha': 1.0, 'kA': 0.5\n        },\n        # Test Case 2 (edge regime with stronger nonlinearity and feedbacks)\n        {\n            'S_in': 10.0, 'V0': 10.0, 'K0': 5.0, 'KI0': 50.0, 'n0': 2.0,\n            'V1': 3.5, 'K1': 1.0, 'h': 3.0,\n            'V2': 2.5, 'K2': 1.0, 'KI2': 6.0, 'n2': 4.0,\n            'alpha': 1.2, 'kA': 0.25\n        },\n        # Test Case 3 (strongly nonlinear, likely bistable regime)\n        {\n            'S_in': 10.0, 'V0': 12.0, 'K0': 5.0, 'KI0': 40.0, 'n0': 2.0,\n            'V1': 4.5, 'K1': 0.8, 'h': 4.0,\n            'V2': 2.0, 'K2': 0.8, 'KI2': 2.5, 'n2': 4.0,\n            'alpha': 1.5, 'kA': 0.2\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result = _analyze_case(params)\n        all_results.append(result)\n\n    # Format output\n    output_str = \"[\"\n    for i, res_list in enumerate(all_results):\n        output_str += \"[\"\n        # Add num stable states\n        output_str += str(res_list[0])\n        # Add fluxes\n        if len(res_list)  1:\n            formatted_fluxes = [f\"{f:.6f}\" for f in res_list[1]]\n            output_str += \",\" + \",\".join(formatted_fluxes)\n        \n        output_str += \"]\"\n        if i  len(all_results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    # Replace single quotes from Python list repr with double quotes if any, and remove spaces\n    final_output = output_str.replace(\"'\", '\"').replace(\" \", \"\")\n    \n    print(final_output)\n\n\ndef _analyze_case(params):\n    \"\"\"\n    Analyzes a single parameter set to find stable steady states and fluxes.\n    \"\"\"\n    S_in, V0, K0, KI0, n0 = params['S_in'], params['V0'], params['K0'], params['KI0'], params['n0']\n    V1, K1, h = params['V1'], params['K1'], params['h']\n    V2, K2, KI2, n2 = params['V2'], params['K2'], params['KI2'], params['n2']\n    alpha, kA = params['alpha'], params['kA']\n\n    Vs = V0 * S_in / (K0 + S_in)\n\n    # Rate functions\n    def v0(A):\n        if A  0: A = 0\n        return Vs / (1 + (A / KI0)**n0)\n\n    def v1(X):\n        if X  0: X = 0\n        return V1 * (X**h) / (K1**h + X**h)\n\n    def v2(X, A):\n        if X  0: X = 0\n        if A  0: A = 0\n        inhib_factor = 1 / (1 + (A / KI2)**n2)\n        return (V2 * X / (K2 + X)) * inhib_factor\n\n    # Relationship A(X) from dA/dt = 0\n    def A_of_X(X):\n        return (alpha / kA) * v1(X)\n\n    # Root finding function H(X) = 0\n    def H(X):\n        if X  0: return float('inf') # Penalize negative domain\n        A = A_of_X(X)\n        return v0(A) - v1(X) - v2(X, A)\n\n    # --- Find Roots ---\n    roots = []\n    scan_points = np.logspace(-3, 2, 5000)\n    for i in range(len(scan_points) - 1):\n        x1, x2 = scan_points[i], scan_points[i+1]\n        try:\n            h1, h2 = H(x1), H(x2)\n            if h1 * h2  0:\n                root = brentq(H, x1, x2, xtol=1e-12, rtol=1e-12)\n                if root = 0 and abs(H(root))  1e-9:\n                    # Deduplicate\n                    is_new_root = True\n                    for r in roots:\n                        if np.isclose(root, r, atol=1e-8):\n                            is_new_root = False\n                            break\n                    if is_new_root:\n                        roots.append(root)\n        except (ValueError, RuntimeError):\n            continue\n    \n    # --- Stability Analysis ---\n    # Partial derivatives for Jacobian\n    def dv0_dA(A):\n        if A = 0: return 0.0\n        term_A_KI0 = A / KI0\n        return -Vs * n0 / KI0 * (term_A_KI0**(n0-1)) / (1 + term_A_KI0**n0)**2\n\n    def dv1_dX(X):\n        if X = 0: return 0.0\n        return V1 * h * (K1**h) * (X**(h-1)) / (K1**h + X**h)**2\n        \n    def dv2_dX(X, A):\n        if X  0: X=0\n        if A  0: A=0\n        inhib_factor = 1 / (1 + (A / KI2)**n2)\n        return (V2 * K2 / (K2 + X)**2) * inhib_factor\n\n    def dv2_dA(X, A):\n        if X  0: X=0\n        if A = 0: return 0.0\n        term_A_KI2 = A / KI2\n        rate_part = V2 * X / (K2 + X)\n        return -rate_part * (n2 / KI2) * (term_A_KI2**(n2-1)) / (1 + term_A_KI2**n2)**2\n\n    stable_states = []\n    for X_star in roots:\n        A_star = A_of_X(X_star)\n        \n        # Jacobian elements\n        J11 = -dv1_dX(X_star) - dv2_dX(X_star, A_star)\n        J12 = dv0_dA(A_star) - dv2_dA(X_star, A_star)\n        J21 = alpha * dv1_dX(X_star)\n        J22 = -kA\n        \n        jacobian = np.array([[J11, J12], [J21, J22]])\n        \n        eigenvalues = np.linalg.eigvals(jacobian)\n        \n        if np.all(np.real(eigenvalues)  0):\n            J0 = v0(A_star)\n            J1 = v1(X_star)\n            J2 = v2(X_star, A_star)\n            stable_states.append({'X_star': X_star, 'fluxes': (J0, J1, J2)})\n\n    # Sort stable states by X_star\n    stable_states.sort(key=lambda s: s['X_star'])\n\n    # Format output for this case\n    num_stable = len(stable_states)\n    flux_list = []\n    for state in stable_states:\n        flux_list.extend(state['fluxes'])\n        \n    # Pad with -1.0 up to 3 stable states (9 flux values)\n    padding_needed = 9 - len(flux_list)\n    if padding_needed  0:\n        flux_list.extend([-1.0] * padding_needed)\n\n    return [num_stable, flux_list[:9]]\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}