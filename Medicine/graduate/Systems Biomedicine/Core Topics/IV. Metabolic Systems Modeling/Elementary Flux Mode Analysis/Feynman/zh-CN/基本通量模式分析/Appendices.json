{
    "hands_on_practices": [
        {
            "introduction": "理解基本通量模式（EFM）的最佳方式是从头开始手动计算它们。这项练习将引导你完成在一个小型网络中识别最小通路的过程，从而巩固稳态和支撑集最小性的核心定义。通过直接应用这些基本原则，你将对 EFM 作为代谢网络不可分割的功能单元建立起直观的理解。",
            "id": "4337330",
            "problem": "考虑一个哺乳动物细胞中的最小细胞内转换模块，该模块涉及三种内部代谢物 $A$、$B$ 和 $C$，以及六个交换和转化反应。化学计量矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$（行按 $A$、$B$、$C$ 排序；列按反应 $v_{1},\\dots,v_{6}$ 排序）和不可逆性模式 $I$ 由下式给出\n$$\nS \\;=\\;\n\\begin{pmatrix}\n1  -1  0  0  -1  0 \\\\\n0  1  -1  0  0  -1 \\\\\n0  0  1  -1  1  0\n\\end{pmatrix},\n\\qquad\nI \\;=\\; (1,\\,1,\\,1,\\,1,\\,1,\\,1),\n$$\n其中 $I_{i} = 1$ 表示反应 $i$ 是不可逆的，从而要求对所有 $i \\in \\{1,\\dots,6\\}$ 都有 $v_{i} \\ge 0$。这些反应可以解释如下：$v_{1}$ 是 $A$ 的摄取，$v_{2}$ 是 $A \\to B$，$v_{3}$ 是 $B \\to C$，$v_{4}$ 是 $C$ 的分泌，$v_{5}$ 是 $A \\to C$，$v_{6}$ 是 $B$ 的分泌。在细胞内代谢物的标准稳态假设下，通量向量 $v \\in \\mathbb{R}^{6}$ 满足 $S v = 0$ 且分量上 $v \\ge 0$。\n\n从基本定义出发，一个基本通量模式 (EFM) 是一个位于通量锥 $\\{v \\in \\mathbb{R}^{6} \\mid S v = 0,\\, v \\ge 0\\}$ 中的非零通量向量，并且在所有可行通量向量中具有关于集合包含的最小支撑集。请通过观察枚举该网络的所有 EFM，并通过测试所有真支撑集的可行性来验证其最小性。请给出 EFM 的总数作为最终答案。最终答案以无单位数字形式表示。无需四舍五入。",
            "solution": "该问题要求枚举给定代谢网络的所有基本通量模式 (EFM)。该网络的化学计量由矩阵 $S \\in \\mathbb{R}^{3 \\times 6}$ 描述，并且所有反应都是不可逆的。\n\n首先，我们建立定义通量锥的方程组。一个通量向量 $v = (v_1, v_2, v_3, v_4, v_5, v_6)^T$ 必须满足稳态条件 $S v = 0$ 和非负约束 $v_i \\ge 0$（对于 $i \\in \\{1, \\dots, 6\\}$）。\n\n矩阵方程 $S v = 0$ 转化为以下线性方程组：\n1.  $v_1 - v_2 - v_5 = 0$\n2.  $v_2 - v_3 - v_6 = 0$\n3.  $v_3 - v_4 + v_5 = 0$\n\n一个基本通量模式 (EFM) 是一个满足这三个方程且 $v \\ge 0$ 的非零向量 $v$，其支撑集 $supp(v) = \\{i \\mid v_i \\neq 0\\}$ 在集合包含关系下是最小的。这意味着不存在其他非零通量向量 $v'$ 使得 $supp(v') \\subsetneq supp(v)$。\n\n题目建议“通过观察”找到 EFM，这对应于识别从输入到输出的最小的、自洽的路径。唯一的摄取反应是 $v_1$，因此任何 EFM 都必须有 $v_1 > 0$。分泌反应是 $v_4$ 和 $v_6$。因此，任何 EFM 都必须表示从 $A$ 的摄取到 $B$ 或 $C$ 的分泌的路径。\n\n我们识别出三个这样的简单路径：\n\n路径 1：$v_1 \\to v_2 \\to v_3 \\to v_4$。这对应于通过中间体 $B$ 将外部底物整体转化为产物 $C$。活跃的反应是 $v_1, v_2, v_3, v_4$。我们假设 $v_5=0$ 和 $v_6=0$。\n方程组变为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_3 = 0 \\implies v_2 = v_3$\n$v_3 - v_4 = 0 \\implies v_3 = v_4$\n这导致 $v_1 = v_2 = v_3 = v_4$。将通量设置为归一化的值 $1$，我们得到候选通量向量 $e_1 = (1, 1, 1, 1, 0, 0)^T$。其支撑集为 $supp(e_1) = \\{1, 2, 3, 4\\}$。\n\n路径 2：$v_1 \\to v_5 \\to v_4$。这是 $A$ 到 $C$ 的直接转化。活跃的反应是 $v_1, v_5, v_4$。我们假设 $v_2=0, v_3=0, v_6=0$。\n方程组变为：\n$v_1 - v_5 = 0 \\implies v_1 = v_5$\n$0 = 0$\n$-v_4 + v_5 = 0 \\implies v_4 = v_5$\n这导致 $v_1 = v_5 = v_4$。对于归一化的通量 $1$，我们得到候选向量 $e_2 = (1, 0, 0, 1, 1, 0)^T$。其支撑集为 $supp(e_2) = \\{1, 4, 5\\}$。\n\n路径 3：$v_1 \\to v_2 \\to v_6$。这条路径代表将外部底物转化为产物 $B$，然后分泌出去。活跃的反应是 $v_1, v_2, v_6$。我们假设 $v_3=0, v_4=0, v_5=0$。\n方程组变为：\n$v_1 - v_2 = 0 \\implies v_1 = v_2$\n$v_2 - v_6 = 0 \\implies v_2 = v_6$\n$0 = 0$\n这导致 $v_1 = v_2 = v_6$。对于归一化的通量 $1$，我们得到候选向量 $e_3 = (1, 1, 0, 0, 0, 1)^T$。其支撑集为 $supp(e_3) = \\{1, 2, 6\\}$。\n\n接下来，我们必须为每个候选向量验证其支撑集的最小性。\n\n对于 $e_1$，其支撑集为 $supp(e_1) = \\{1, 2, 3, 4\\}$：如果我们考虑该支撑集的任何真子集，反应链就会被破坏。例如，我们测试支撑集 $\\{1, 2, 3\\}$，设置 $v_4=0$（此外还有 $v_5=0, v_6=0$）。第三个方程 $v_3 - v_4 + v_5 = 0$ 变为 $v_3=0$。这意味着 $v_2=v_3=0$ 且 $v_1=v_2=0$。因此，只有零通量是可能的。这对任何真子集都成立。所以，$supp(e_1)$ 是最小的，$e_1$ 是一个 EFM。\n\n对于 $e_2$，其支撑集为 $supp(e_2) = \\{1, 4, 5\\}$：我们测试支撑集 $\\{1, 5\\}$，设置 $v_4=0$。第三个方程 $v_3 - v_4 + v_5 = 0$（其中 $v_3=0$）变为 $v_5=0$。从第一个方程 $v_1 - v_2 - v_5 = 0$（其中 $v_2=0$），我们得到 $v_1=v_5=0$。同样，只有零通量是可能的。这个论证可以对其他真子集 $\\{1, 4\\}$ 和 $\\{4, 5\\}$ 重复。因此，$supp(e_2)$ 是最小的，$e_2$ 是一个 EFM。\n\n对于 $e_3$，其支撑集为 $supp(e_3) = \\{1, 2, 6\\}$：我们测试支撑集 $\\{1, 2\\}$，设置 $v_6=0$。第二个方程 $v_2 - v_3 - v_6 = 0$（其中 $v_3=0$）变为 $v_2=0$。第一个方程 $v_1 - v_2 - v_5 = 0$（其中 $v_5=0$）给出 $v_1=v_2=0$。只有平凡通量。这个逻辑适用于所有真子集。因此，$supp(e_3)$ 是最小的，$e_3$ 是一个 EFM。\n\n为了确认这些是*唯一*的 EFM，我们可以完全求解该方程组。我们可以用三个自由变量表示三个因变量。我们选择 $v_4, v_5, v_6$ 作为自由变量。从方程组可得：\n$v_3 = v_4 - v_5$\n$v_2 = v_3 + v_6 = v_4 - v_5 + v_6$\n$v_1 = v_2 + v_5 = (v_4 - v_5 + v_6) + v_5 = v_4 + v_6$\n\n非负约束 $v_i \\ge 0$ 对自由变量施加了条件：\n$v_4 \\ge 0, v_5 \\ge 0, v_6 \\ge 0$\n$v_3 \\ge 0 \\implies v_4 - v_5 \\ge 0 \\implies v_4 \\ge v_5$\n$v_2 \\ge 0 \\implies v_4 - v_5 + v_6 \\ge 0$（如果 $v_4 \\ge v_5$ 和 $v_6 \\ge 0$，此条件自动满足）\n$v_1 \\ge 0 \\implies v_4 + v_6 \\ge 0$（如果 $v_4 \\ge 0, v_6 \\ge 0$，此条件自动满足）\n\n可行通量锥由向量 $v = (v_4+v_6, v_4-v_5+v_6, v_4-v_5, v_4, v_5, v_6)^T$ 描述，其中 $v_4 \\ge v_5 \\ge 0$ 且 $v_6 \\ge 0$。\n为了找到极射线（即 EFM），我们可以重新参数化以消除不等式约束 $v_4 \\ge v_5$。令 $\\gamma = v_4 - v_5 \\ge 0$。则 $v_4 = v_5 + \\gamma$。我们使用 $v_5, v_6, \\gamma$ 作为非负参数。\n令 $v_5 = \\alpha, v_6 = \\beta, \\gamma = \\delta$，其中 $\\alpha, \\beta, \\delta \\ge 0$。\n则 $v_4 = \\alpha + \\delta$。将这些代入其他变量的表达式中：\n$v_1 = (\\alpha+\\delta) + \\beta = \\alpha + \\beta + \\delta$\n$v_2 = (\\alpha+\\delta) - \\alpha + \\beta = \\beta + \\delta$\n$v_3 = (\\alpha+\\delta) - \\alpha = \\delta$\n$v_4 = \\alpha + \\delta$\n$v_5 = \\alpha$\n$v_6 = \\beta$\n\n通量锥中的任何通量向量 $v$ 都可以写成三个向量的非负线性组合：\n$$\nv = \\begin{pmatrix} v_1 \\\\ v_2 \\\\ v_3 \\\\ v_4 \\\\ v_5 \\\\ v_6 \\end{pmatrix} =\n\\alpha \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 1 \\\\ 0 \\end{pmatrix} +\n\\beta \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} +\n\\delta \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n此分解中的三个向量正是我们通过观察找到的向量 $e_2$、$e_3$ 和 $e_1$（其中 $\\delta$ 对应 $e_1$，$\\alpha$ 对应 $e_2$，$\\beta$ 对应 $e_3$）。\n这些向量构成了通量锥的极射线集合。由于我们已经验证了它们的最小支撑集性质，它们就是 EFM 的完整集合。\n\n总共有三个基本通量模式。\n1.  EFM 1: $e_1 = (1, 1, 1, 1, 0, 0)^T$\n2.  EFM 2: $e_2 = (1, 0, 0, 1, 1, 0)^T$\n3.  EFM 3: $e_3 = (1, 1, 0, 0, 0, 1)^T$\n\n问题要求 EFM 的总数。总数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "在掌握了 EFM 的基本概念之后，一个自然的问题是：它们有何实际用途？这项练习将 EFM 分析与代谢工程中的一个核心应用——最小切割集（MCS）的计算——联系起来。你将通过编写程序来学习如何利用 EFM 来识别能够阻断特定目标反应的最小基因敲除策略，这展示了 EFM 在设计和改造生物系统中的强大能力。",
            "id": "4337272",
            "problem": "给定一组处于稳态的小型、不可逆生物化学反应网络，以及每个网络的一个目标反应索引。任务是计算所有通过目标反应且带有正通量的基本通量模式，然后通过与每个此类基本通量模式相交来计算所有能够阻断目标反应的最小割集。最终答案必须是一个完整、可运行的程序。\n\n基本原理：\n- 稳态意味着内部代谢物的平衡满足 $S v = 0$，其中 $S \\in \\mathbb{R}^{m \\times n}$ 是化学计量矩阵，$m$ 是内部代谢物的数量，$n$ 是反应的数量，$v \\in \\mathbb{R}^{n}$ 是通量向量。\n- 不可逆反应要求各分量满足 $v \\ge 0$。\n- 基本通量模式 (EFM) 定义为一个非零可行通量向量 $v$，它满足 $S v = 0$ 和（对于不可逆反应）$v \\ge 0$，且其支撑集 $\\mathrm{supp}(v) = \\{ j \\in \\{0,\\dots,n-1\\} \\mid v_j \\ne 0 \\}$ 在所有可行通量向量中对于集合包含关系是最小的。基本通量模式是由 $S v = 0$ 和 $v \\ge 0$ 定义的凸锥的射线，对于不可逆网络，基本通量模式中的每个活性反应都具有严格为正的通量。\n- 针对给定目标反应的最小割集 (MCS) 是一个最小的反应集合，移除该集合中的反应可以阻断所有通过目标反应且带有严格正通量的可行通量向量。等价地，MCS 正是所有通过目标反应且带有严格正通量的基本通量模式的支撑集族群的最小命中集（也称为最小横截集）。这里，如果对于集合族群 $\\mathcal{F}$ 中的所有集合 $F$，都有 $C \\cap F \\ne \\emptyset$，则称集合 $C$ 是该族群的一个命中集；如果 $C$ 的任何真子集都不是命中集，则称 $C$ 是最小的。\n\n您的程序必须：\n1) 对于每个测试网络，遵循 $S v = 0$ 和 $v \\ge 0$ 的约束，枚举出所有通过给定目标反应且带有严格正通量的基本通量模式的支撑集。\n2) 计算这些支撑集的所有最小命中集，以获得用于阻断目标反应的所有最小割集。\n3) 对于每个测试网络，返回最小割集集合，其形式为按字典序排序的、由从零开始的反应索引组成的排序列表的列表。\n\n可行性与最小性检查的形式化：\n- 对于包含目标索引 $t$ 的候选支撑集 $J \\subseteq \\{0,\\dots,n-1\\}$，可行性意味着存在一个向量 $x \\in \\mathbb{R}^{|J|}$，满足 $x \\ge \\mathbf{1}$ 且 $S_{:,J} x = 0$。由于约束是齐次的，经过适当缩放后，存在一个严格为正的解 $x > 0$ 等价于存在一个解 $x \\ge \\mathbf{1}$。这确保了候选支撑集中的每个反应都是真正活性的，并具有严格为正的通量。\n- 支撑集的最小性意味着对于 $J$ 的任何真子集 $K \\subset J$，方程 $S_{:,K} x = 0$ 都不存在严格为正的解 $x > 0$。\n\n程序内部的输入规范：\n- 共有三个测试网络。对于每个案例，您将获得化学计量矩阵 $S$ 和从零开始的目标反应索引 $t$。所有反应都是不可逆的，并受 $v \\ge 0$ 的约束。\n\n测试套件：\n- 案例 A（通往产物的分支途径）：\n  - 代谢物：$A, B, C$ ($m = 3$)。\n  - 反应（均为不可逆，$n = 6$）：\n    - $R_0$: $S_{\\mathrm{ext}} \\to A$: 列向量 $[1, 0, 0]^\\top$。\n    - $R_1$: $A \\to B$: 列向量 $[-1, 1, 0]^\\top$。\n    - $R_2$: $B \\to C$: 列向量 $[0, -1, 1]^\\top$。\n    - $R_3$: $C \\to P_{\\mathrm{ext}}$ (目标)：列向量 $[0, 0, -1]^\\top$。\n    - $R_4$: $A \\to C$: 列向量 $[-1, 0, 1]^\\top$。\n    - $R_5$: $B \\to \\mathrm{waste}$: 列向量 $[0, -1, 0]^\\top$。\n  - 目标索引：$t = 3$。\n\n- 案例 B（通过转换步骤到达目标的两条路径）：\n  - 代谢物：$A, B, C$ ($m = 3$)。\n  - 反应（均为不可逆，$n = 5$）：\n    - $R_0$: $S_{\\mathrm{ext}} \\to A$: 列向量 $[1, 0, 0]^\\top$。\n    - $R_1$: $A \\to B$: 列向量 $[-1, 1, 0]^\\top$。\n    - $R_2$: $A \\to C$: 列向量 $[-1, 0, 1]^\\top$。\n    - $R_3$: $B \\to P_{\\mathrm{ext}}$ (目标)：列向量 $[0, -1, 0]^\\top$。\n    - $R_4$: $C \\to B$: 列向量 $[0, 1, -1]^\\top$。\n  - 目标索引：$t = 3$。\n\n- 案例 C（不可行的目标通量）：\n  - 代谢物：$A$ ($m = 1$)。\n  - 反应（均为不可逆，$n = 1$）：\n    - $R_0$: $A \\to P_{\\mathrm{ext}}$ (目标)：列向量 $[-1]^\\top$。\n  - 目标索引：$t = 0$。\n\n输出规范：\n- 对于每个测试案例，输出最小割集的列表，该列表由已排序的、包含从零开始的反应索引的列表组成，并遵循以下排序约定：\n  - 在每个最小割集内部，反应索引必须严格递增。\n  - 一个测试案例的最小割集集合必须按这些列表进行字典序排序。\n  - 整个程序的输出必须是单行，包含一个列表，其中按顺序（案例 A、案例 B、案例 C）包含三个案例的结果。\n- 最终输出必须是单行，格式与 Python 列表字面量完全一致，例如：$[\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$。\n\n答案类型：\n- 每个案例的结果是一个整数列表的列表。顶层结果是一个长度为 $3$ 的列表。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，“[resultA,resultB,resultC]”）。",
            "solution": "该问题要求在几个小型、不可逆的生物化学网络中，为一个目标反应计算最小割集 (MCS)。这个任务分为两个主要阶段：首先，枚举所有涉及目标反应的基本通量模式 (EFM)；其次，计算这些 EFM 支撑集的所有最小命中集。问题正确地指出，这些最小命中集正是 MCS。\n\n解决方案将以一个 Python 程序实现，该程序由几个函数构成，每个函数处理问题的一个特定部分。\n\n### 第一部分：枚举携带目标通量的基本通量模式\n\n基本通量模式由其支撑集的最小性定义——支撑集是具有非零通量的反应集合。对于不可逆网络，EFM 中的所有反应都具有严格为正的通量。一个支撑集 $J$ 对应一个 EFM，当且仅当：\n1.  **可行性**：存在一个通量向量 $v > 0$ 且 $\\mathrm{supp}(v) = J$，满足 $S v = 0$。根据题目要求，这可以通过检查线性系统 $S_{:,J} x = 0$ 在约束 $x \\ge 1$ 下是否存在解来测试，这是一个标准的线性规划可行性问题。设 $k = |J|$，该系统是寻找一个 $x \\in \\mathbb{R}^k$ 使得 $S_{:,J} x = 0$ 和 $x \\ge 1$。这可以通过将目标函数设为零，使用 `scipy.optimize.linprog` 来解决。\n2.  **最小性**：$J$ 的任何真子集都不是一个可行的支撑集。\n\n寻找所有包含目标反应 $t$ 的 EFM 支撑集的算法如下：\n- 生成所有包含目标反应 $t$ 的可能反应子集 $J$。这通过获取所有其他反应的幂集，并将 $t$ 添加到每个子集中来实现。\n- 对每个候选支撑集 $J$，使用 `scipy.optimize.linprog` 检查其可行性。收集所有可行的支撑集。\n- 从可行支撑集列表中筛选出满足最小性的集合。如果不存在其他可行支撑集 $K$ 是 $J$ 的真子集，则可行支撑集 $J$ 是最小的。通过先按大小对可行支撑集进行排序，然后对每个候选集检查其是否是任何已确认的最小支撑集的超集，可以高效地执行此筛选。\n\n### 第二部分：计算最小割集（最小命中集）\n\n一旦确定了相关 EFM 支撑集的集合 $\\mathcal{F} = \\{E_1, E_2, \\dots, E_p\\}$，下一步就是计算它们的最小命中集 (MHS)。如果集合 $C$ 与 $\\mathcal{F}$ 中的每个集合都有非空交集（即 $\\forall E_i \\in \\mathcal{F}, C \\cap E_i \\ne \\emptyset$），则称 $C$ 是 $\\mathcal{F}$ 的一个命中集。一个 MCS 是在集合包含关系下最小的命中集。\n\nMHS 的计算可以使用一种称为横截算法的迭代过程来完成。该算法流程如下：\n- 用空族群的 MHS 初始化 MHS 集合，即只包含空集的集合：$\\mathcal{H}_0 = \\{\\emptyset\\}$。\n- 迭代处理每个 EFM 支撑集 $E_i \\in \\mathcal{F}$：\n  - 对于每个已有的 MHS $H \\in \\mathcal{H}_{i-1}$ 和 $E_i$ 中的每个反应 $r$，形成一个新的候选命中集 $H' = H \\cup \\{r\\}$。\n  - 新的候选集集合是 $\\mathcal{H}'_i = \\{ H \\cup \\{r\\} \\mid H \\in \\mathcal{H}_{i-1}, r \\in E_i \\}$。\n  - 下一个 MHS 集合 $\\mathcal{H}_i$ 是通过仅保留 $\\mathcal{H}'_i$ 中的最小集合而获得的。\n- 迭代完所有 EFM 支撑集后，最终的集合 $\\mathcal{H}_p$ 就是所有 MCS 的集合。\n\n这个过程能正确计算出所有的 MCS。如果携带目标通量的 EFM 集合为空（如案例 C 中，目标通量不可行），则族群 $\\mathcal{F}$ 为空。空族群的最小命中集是空集 $\\emptyset$，因为成为命中集的条件被虚满足。因此，MCS 的集合是 $\\{\\emptyset\\}$，表示为 `[[]]`。\n\n### 最终输出格式\n\n每个测试案例得到的 MCS 列表都根据问题规范进行排序：每个单独的 MCS（反应索引列表）按升序排序，而所有 MCS 的列表则按字典序排序。然后将所有测试案例的结果汇总到一个列表中，并以紧凑的单行格式打印。\n\n下面的 Python 程序实现了这一完整逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations\n\ndef _check_feasibility(S, support):\n    \"\"\"\n    Checks if a given support is feasible by solving a linear programming problem.\n    A support J is feasible if there exists a flux vector v > 0 with supp(v) = J.\n    This is equivalent to checking if the system S_J * x = 0 has a solution with x >= 1.\n    \"\"\"\n    if not support:\n        return False\n    \n    S_J = S[:, support]\n    m, k = S_J.shape\n\n    # We are solving a feasibility problem, so the objective function is irrelevant.\n    # min c^T * x, where c is a vector of zeros.\n    c = np.zeros(k)\n\n    # Constraints are S_J * x = 0 and x >= 1.\n    bounds = [(1, None)] * k\n\n    # Solve the linear program. The 'highs' method is robust.\n    # We only care about whether a solution was found (res.success).\n    res = linprog(c, A_eq=S_J, b_eq=np.zeros(m), bounds=bounds, method='highs')\n    \n    return res.success\n\ndef find_target_efms(S, t):\n    \"\"\"\n    Enumerates all elementary flux mode supports that include the target reaction 't'.\n    It first finds all feasible supports containing 't' and then filters for minimality.\n    \"\"\"\n    num_reactions = S.shape[1]\n    other_reactions = [r for r in range(num_reactions) if r != t]\n    \n    feasible_supports = []\n    \n    # Iterate over all subsets of other_reactions to form candidate supports with 't'.\n    for i in range(len(other_reactions) + 1):\n        for combo in combinations(other_reactions, i):\n            support_candidate = sorted(list(combo) + [t])\n            if _check_feasibility(S, support_candidate):\n                feasible_supports.append(support_candidate)\n\n    # Filter for minimal supports to get EFMs.\n    # Sorting by length allows for efficient checking of minimality.\n    feasible_supports.sort(key=len)\n    \n    efm_supports = []\n    for J in feasible_supports:\n        is_minimal = True\n        # A support J is not minimal if it's a superset of an already found EFM.\n        for K in efm_supports:\n            if set(K).issubset(set(J)):\n                is_minimal = False\n                break\n        if is_minimal:\n            efm_supports.append(J)\n            \n    return efm_supports\n\ndef _minimize_sets(list_of_sets):\n    \"\"\"\n    Given a list of sets (represented as lists), returns a new list\n    containing only the minimal sets with respect to subset inclusion.\n    \"\"\"\n    if not list_of_sets:\n        return []\n\n    # Use frozensets for hashing and efficient storage.\n    set_versions = {frozenset(s) for s in list_of_sets}\n    \n    # Sort by size for efficient subset checking.\n    sorted_sets = sorted(list(set_versions), key=len)\n    \n    minimal_sets = []\n    for s_i in sorted_sets:\n        is_minimal = True\n        for m_j in minimal_sets:\n            if m_j.issubset(s_i):\n                is_minimal = False\n                break\n        if is_minimal:\n            minimal_sets.append(s_i)\n            \n    # Convert back to sorted lists of integers.\n    return [sorted(list(s)) for s in minimal_sets]\n\ndef compute_minimal_hitting_sets(family_of_sets):\n    \"\"\"\n    Computes all minimal hitting sets (transversals) for a family of sets\n    using an iterative transversal algorithm.\n    \"\"\"\n    # The minimal hitting set of an empty family is {emptyset}.\n    mhs = [[]]\n    \n    for s in family_of_sets:\n        new_mhs = []\n        for h in mhs:\n            for element in s:\n                # Form a new candidate hitting set by adding an element from the current set 's'.\n                new_h = h + [element]\n                new_mhs.append(new_h)\n        # Prune the generated candidates to keep only minimal ones for the next iteration.\n        mhs = _minimize_sets(new_mhs)\n        \n    return mhs\n\ndef compute_overall_mcs_for_case(S, t):\n    \"\"\"\n    Orchestrates the computation of MCS for a single network case.\n    1. Finds target-carrying EFMs.\n    2. Computes the minimal hitting sets of their supports.\n    3. Sorts the result as specified.\n    \"\"\"\n    # 1. Enumerate supports of elementary flux modes that use the target reaction.\n    efm_supports = find_target_efms(S, t)\n\n    # 2. Compute minimal hitting sets, which are the minimal cut sets.\n    mcs_list = compute_minimal_hitting_sets(efm_supports)\n    \n    # 3. Sort the final list of MCSs lexicographically.\n    mcs_list.sort()\n    \n    return mcs_list\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the computation, and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    \n    # Case A: Branched pathway to product\n    S_A = np.array([\n        [1., -1., 0., 0., -1., 0.],\n        [0., 1., -1., 0., 0., -1.],\n        [0., 0., 1., -1., 1., 0.]\n    ])\n    t_A = 3\n\n    # Case B: Two routes to target via a conversion step\n    S_B = np.array([\n        [1., -1., -1., 0., 0.],\n        [0., 1., 0., -1., 1.],\n        [0., 0., 1., 0., -1.]\n    ])\n    t_B = 3\n\n    # Case C: Infeasible target flux\n    S_C = np.array([[-1.]])\n    t_C = 0\n\n    test_cases = [ (S_A, t_A), (S_B, t_B), (S_C, t_C) ]\n\n    results = []\n    for S, t in test_cases:\n        result = compute_overall_mcs_for_case(S, t)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is modified to remove spaces for a compact output.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "虽然化学计量分析是强大的，但它本身并不能完全捕捉细胞内复杂的生物物理现实。这项高级练习引入了热力学约束，为你展示了如何将通路分析提升到一个新的真实性水平。通过为给定的 EFM 构建和求解一个可行性问题，你将学会如何根据代谢物浓度和吉布斯自由能来筛选出那些在生物物理上真正可行的通路。",
            "id": "4337268",
            "problem": "给定一个小生化网络的一组基本通量模式 (EFMs; Elementary Flux Mode) 和热力学参数范围。您必须从基础热力学出发，推导出一个混合整数线性可行性公式，该公式通过热力学可行性来筛选 EFM，并将其实现为一个可运行的程序。该程序需要为每个参数集下的每个 EFM 输出，是否存在一组在给定边界内的代谢物化学势，使得所有活性的内源反应与其通量方向在热力学上一致。\n\n基本原理和假设：\n- 化学计量矩阵为 $S \\in \\mathbb{R}^{m \\times n}$，其中有 $m$ 个内源代谢物和 $n$ 个反应。反应 $j$ 的吉布斯自由能变定义为 $$\\Delta_r G_j = \\sum_{i=1}^{m} S_{i,j} \\, \\mu_i = \\left(S^\\top \\mu\\right)_j,$$ 其中 $\\mu_i$ 是代谢物 $i$ 的化学势。\n- 代谢物 $i$ 的化学势由下式给出 $$\\mu_i = \\mu_i^\\circ + R T \\ln c_i,$$ 其中 $\\mu_i^\\circ$ 是标准化学势，$R$ 是摩尔气体常数，$T$ 是绝对温度，$c_i$ 是代谢物 $i$ 的浓度。给定 $c_i$ 的界限，即 $c_i \\in [c_i^{\\min}, c_i^{\\max}]$，这意味着 $\\mu_i$ 的界限为： $$\\mu_i^{\\min} = \\mu_i^\\circ + R T \\ln c_i^{\\min}, \\quad \\mu_i^{\\max} = \\mu_i^\\circ + R T \\ln c_i^{\\max}.$$\n- 为了热力学上的一致性，正向流动的活性反应必须满足 $$\\Delta_r G_j \\le -\\varepsilon,$$ 反向流动的活性反应必须满足 $$\\Delta_r G_j \\ge \\varepsilon,$$ 其中 $\\varepsilon > 0$ 是一个小的严格不等式容差。\n\n混合整数线性规划 (MILP; Mixed-Integer Linear Programming) 公式描述：\n- 为每个可逆反应 $j$ 引入一个二元变量 $y_j \\in \\{0,1\\}$ 来指示方向：$y_j = 1$ 表示反应 $j$ 正向流动，$y_j = 0$ 表示反应 $j$ 反向流动。使用大 $M$ 法 (big-$M$ formulation) 来编码与方向相关的线性不等式：\n  $$\\Delta_r G_j \\le -\\varepsilon + M\\,(1 - y_j), \\quad \\Delta_r G_j \\ge \\varepsilon - M\\,y_j,$$\n  其中 $M$ 是一个足够大的正常数。\n- 对于具有已知反应方向的 EFM，将 $y_j$ 设置为 EFM 指示的方向（即固定 $y_j$），这将使 MILP 简化为关于 $\\mu$ 且带有边界约束的线性可行性问题。\n\n网络规格：\n- 内源代谢物：$A$、$B$、$C$ (因此 $m = 3$)。\n- 反应 ($n = 6$)，仅给出内源代谢物的化学计量（交换反应涉及未在 $S$ 中表示的外源物质池）：\n  1. $R_0$: $\\text{ext} \\to A$，化学计量为 $S_{\\cdot,0} = [1,\\,0,\\,0]^\\top$ (交换反应；不约束 $\\Delta_r G_0$)。\n  2. $R_1$: $A \\to B$，化学计量为 $S_{\\cdot,1} = [-1,\\,1,\\,0]^\\top$ (内源反应；约束热力学)。\n  3. $R_2$: $B \\to C$，化学计量为 $S_{\\cdot,2} = [0,\\,-1,\\,1]^\\top$ (内源反应；约束热力学)。\n  4. $R_3$: $C \\to A$，化学计量为 $S_{\\cdot,3} = [1,\\,0,\\,-1]^\\top$ (内源反应；约束热力学)。\n  5. $R_4$: $A \\to \\text{ext}$，化学计量为 $S_{\\cdot,4} = [-1,\\,0,\\,0]^\\top$ (交换反应；不约束热力学)。\n  6. $R_5$: $C \\to \\text{ext}$，化学计量为 $S_{\\cdot,5} = [0,\\,0,\\,-1]^\\top$ (交换反应；不约束热力学)。\n\nEFM 列表（$(R_0,R_1,R_2,R_3,R_4,R_5)$ 的通量方向，使用 $+1$ 表示正向，$-1$ 表示反向，$0$ 表示非活性；假设交换反应在热力学上不受约束）：\n- $\\text{EFM}_1$: $[+1,\\,+1,\\,+1,\\,0,\\,0,\\,+1]$。\n- $\\text{EFM}_2$: $[0,\\,+1,\\,+1,\\,+1,\\,0,\\,0]$。\n- $\\text{EFM}_3$: $[+1,\\,0,\\,0,\\,0,\\,+1,\\,0]$。\n- $\\text{EFM}_4$: $[+1,\\,+1,\\,+1,\\,+1,\\,+1,\\,0]$。\n- $\\text{EFM}_5$: $[+1,\\,+1,\\,+1,\\,0,\\,+1,\\,+1]$。\n- $\\text{EFM}_6$: $[+1,\\,-1,\\,+1,\\,0,\\,0,\\,+1]$。\n\n常数和单位：\n- 使用 $R = 0.008314$ (单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$)。\n- 使用 $T = 310$ (单位 $\\mathrm{K}$)。\n- 使用 $\\varepsilon = 10^{-6}$ (单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)。\n- 浓度 $c_i$ 的单位为 $\\mathrm{M}$ (摩尔/升)。\n- 所有能量必须以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位。\n\n测试套件（三个参数集）：\n1. 案例 1 (理想情况)：$\\mu^\\circ = [ -10,\\,-20,\\,-30 ]$ (单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)；$A$、$B$、$C$ 各自的浓度范围 $[c^{\\min},c^{\\max}]$ 为 $[10^{-6},\\,10^{-3}]$ (单位 $\\mathrm{M}$)。\n2. 案例 2 (驱动力为零的边界情况)：$\\mu^\\circ = [ -20,\\,-20,\\,-20 ]$ (单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)；浓度范围均为 $[10^{-4},\\,10^{-4}]$ (单位 $\\mathrm{M}$)，即固定值。\n3. 案例 3 (导致一个步骤逆转的倾斜范围)：$\\mu^\\circ = [ -20,\\,-20,\\,-20 ]$ (单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$)；浓度范围：$A$ 在 $[10^{-9},\\,10^{-8}]$ $\\mathrm{M}$，$B$ 在 $[10^{-2},\\,10^{-1}]$ $\\mathrm{M}$，$C$ 在 $[10^{-2},\\,10^{-1}]$ $\\mathrm{M}$。\n\n任务：\n- 对于每个测试案例，根据提供的 $\\mu_i^\\circ$、$R$、$T$ 和 $[c_i^{\\min},c_i^{\\max}]$ 计算 $\\mu_i^{\\min}$ 和 $\\mu_i^{\\max}$。\n- 对于每个 EFM 和测试案例，构建关于 $\\mu \\in \\mathbb{R}^3$ 的线性可行性问题：\n  - 界限：$\\mu_i^{\\min} \\le \\mu_i \\le \\mu_i^{\\max}$，其中 $i \\in \\{A,B,C\\}$。\n  - 对于每个活性的内源反应 $j \\in \\{1,2,3\\}$：\n    - 如果 EFM 方向为正向，则强制执行 $\\sum_i S_{i,j} \\mu_i \\le -\\varepsilon$。\n    - 如果 EFM 方向为反向，则强制执行 $\\sum_i S_{i,j} \\mu_i \\ge \\varepsilon$。\n  - 交换反应 $j \\in \\{0,4,5\\}$ 不施加任何热力学约束。\n- 确定每种情况下每个 EFM 的可行性（布尔值）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个案例的结果必须是 $\\text{EFM}_1$ 到 $\\text{EFM}_6$ 的布尔值列表（按顺序）。因此，总输出是包含三个列表的列表：$$[\\,[b_{1,1},\\,b_{1,2},\\,b_{1,3},\\,b_{1,4},\\,b_{1,5},\\,b_{1,6}],\\,[b_{2,1},\\,\\dots,\\,b_{2,6}],\\,[b_{3,1},\\,\\dots,\\,b_{3,6}]\\,],$$ 其中 $b_{k,\\ell}$ 对于可行（真）为 $1$，对于不可行（假）为 $0$。在嵌套列表中以 Python 字面量（$\\texttt{True}$ 或 $\\texttt{False}$）打印布尔值。",
            "solution": "该问题要求在不同的参数条件下，确定给定代谢网络的几个基本通量模式 (EFM) 的热力学可行性。此任务可转化为求解一系列线性可行性问题。对于每个 EFM 和每个参数集（测试案例），我们必须确定是否存在一个代谢物化学势向量 $\\mu$，能够同时满足所有施加的热力学约束和基于浓度的约束。\n\n### 1. 理论阐述\n\n该问题由两组关于内源代谢物 $A$、$B$ 和 $C$ 的化学势 $\\mu = [\\mu_A, \\mu_B, \\mu_C]^\\top$ 的线性约束定义。\n\n#### 1.1. 化学势的界限\n代谢物 $i$ 的化学势 $\\mu_i$ 由基本热力学关系给出：\n$$ \\mu_i = \\mu_i^\\circ + R T \\ln c_i $$\n其中 $\\mu_i^\\circ$ 是标准化学势，$R$ 是摩尔气体常数，$T$ 是绝对温度，$c_i$ 是代谢物浓度。给定一个浓度范围 $c_i \\in [c_i^{\\min}, c_i^{\\max}]$，化学势 $\\mu_i$ 也相应地有界：\n$$ \\mu_i^{\\min} \\le \\mu_i \\le \\mu_i^{\\max} $$\n其中 $\\mu_i^{\\min} = \\mu_i^\\circ + R T \\ln c_i^{\\min}$ 和 $\\mu_i^{\\max} = \\mu_i^\\circ + R T \\ln c_i^{\\max}$。这些界限在化学势空间中定义了一个超矩形，代表了 $\\mu$ 的可行搜索空间。\n\n#### 1.2. 热力学驱动力约束\n热力学第二定律规定，反应只能朝着吉布斯自由能减少的方向进行。对于反应 $j$，其吉布斯自由能变 $\\Delta_r G_j$ 由下式给出：\n$$ \\Delta_r G_j = \\left(S^\\top \\mu\\right)_j = \\sum_{i=1}^{m} S_{i,j} \\mu_i $$\n其中 $S$ 是化学计量矩阵。一个 EFM 指定了每个活性反应的方向。为使系统在热力学上保持一致，对于每个活性的内源反应 $j \\in \\{1, 2, 3\\}$，必须满足以下条件：\n- 如果反应 $j$ 向前进行（通量为正）：$\\Delta_r G_j \\le -\\varepsilon$。\n- 如果反应 $j$ 向后进行（通量为负）：$\\Delta_r G_j \\ge \\varepsilon$。\n\n此处，$\\varepsilon > 0$ 是一个小的容差，以确保有严格的正或负驱动力，防止系统在热力学平衡状态下运行。这些条件是关于变量 $\\mu_i$ 的线性不等式。一个正向反应约束 $\\left(S^\\top \\mu\\right)_j \\le -\\varepsilon$ 已经处于标准形式 $a^\\top x \\le b$。一个反向反应约束 $\\left(S^\\top \\mu\\right)_j \\ge \\varepsilon$ 可以重写为 $-\\left(S^\\top \\mu\\right)_j \\le -\\varepsilon$ 以适应相同的标准形式。\n\n### 2. 算法方法\n\n对于每个测试案例和每个 EFM，我们构建一个线性可行性问题。该问题的变量是化学势 $\\mu_A, \\mu_B, \\mu_C$。问题在于找到一个向量 $\\mu$，使其满足：\n1.  界限约束：$\\mu_i^{\\min} \\le \\mu_i \\le \\mu_i^{\\max}$，其中 $i \\in \\{A, B, C\\}$。\n2.  一个线性不等式系统 $A_{ub} \\mu \\le b_{ub}$，该系统源于 EFM 中活性内源反应的热力学约束。\n\n这是一个典型的线性可行性问题。我们可以使用线性规划 (LP) 求解器来解决它。通过将目标函数设置为一个常数（例如，$c^\\top \\mu = 0$），LP 求解器的任务就简化为在约束定义的可行域内找到任意一点。如果求解器找到这样一个点，则系统是可行的；否则，系统是不可行的。\n\n### 3. 实现计划\n\n解决方案使用 Python 实现，利用 `numpy` 进行高效的线性代数运算，并使用 `scipy.optimize.linprog`作为 LP 求解器。\n\n1.  **常数和网络定义**：定义物理常数（$R$、$T$、$\\varepsilon$）、转置的化学计量矩阵 $S^\\top$ 以及 EFM 列表。\n2.  **迭代测试案例**：主循环遍历所提供的三个测试案例。在每次迭代中，它首先根据特定案例的标准电势 $\\mu_i^\\circ$ 和浓度范围，计算每个代谢物的 $\\mu_i^{\\min}$ 和 $\\mu_i^{\\max}$ 界限。\n3.  **迭代 EFM**：一个嵌套循环遍历六个 EFM。对于每个 EFM：\n    a.  初始化一个空的约束列表。\n    b.  算法检查每个内源反应（$R_1, R_2, R_3$）的通量方向。\n    c.  如果一个反应是活性的，则相应的不等式（$S_{\\cdot,j}^\\top \\mu \\le -\\varepsilon$ 或 $-S_{\\cdot,j}^\\top \\mu \\le -\\varepsilon$）被构建并添加到约束系统中（即，一个行被添加到 $A_{ub}$，一个元素被添加到 $b_{ub}$）。\n    d.  如果一个 EFM 没有活性的内源反应（例如，$\\text{EFM}_3$），则该问题是平凡可行的，因为非空界限内的任何一组势都是有效解。\n4.  **求解可行性**：使用零目标函数、构建的不等式约束（$A_{ub}$、$b_{ub}$）和计算出的势界限来调用 `scipy.optimize.linprog` 函数。\n5.  **存储并输出结果**：`linprog` 返回的结果对象的 `success` 属性直接提供了布尔值的可行性。将这些布尔值收集到每个测试案例的列表中，并将结果列表进行汇总。最终的嵌套列表以指定格式打印到标准输出。\n\n初步分析表明，$\\text{EFM}_2$ 和 $\\text{EFM}_4$ 各包含一个无效循环 ($A \\to B \\to C \\to A$)，这在结构上是不可行的。其热力学约束之和会导致矛盾 $0 \\le -3\\varepsilon$，从而保证了它们在所有测试案例中都不可行。相反，$\\text{EFM}_3$ 没有活性的内源反应，因此总是热力学可行的。其余 EFM 的可行性则取决于每个测试案例的具体热力学参数。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Validates a set of Elementary Flux Modes (EFMs) for thermodynamic feasibility\n    by solving a series of linear feasibility problems.\n    \"\"\"\n    # Define constants and units\n    R = 0.008314  # kJ mol^-1 K^-1\n    T = 310.0      # K\n    epsilon = 1e-6 # kJ mol^-1\n\n    # Transposed stoichiometric matrix S_T for internal metabolites A, B, C\n    # Rows correspond to reactions R0-R5, columns to metabolites A, B, C\n    S_T = np.array([\n        [1.0, 0.0, 0.0],   # R0: ext -> A\n        [-1.0, 1.0, 0.0],  # R1: A -> B\n        [0.0, -1.0, 1.0],  # R2: B -> C\n        [1.0, 0.0, -1.0],  # R3: C -> A\n        [-1.0, 0.0, 0.0],  # R4: A -> ext\n        [0.0, 0.0, -1.0],  # R5: C -> ext\n    ])\n    \n    # Internal reactions are R1, R2, R3 (indices 1, 2, 3)\n    INTERNAL_REACTION_INDICES = [1, 2, 3]\n\n    # Elementary Flux Modes (EFMs)\n    efms = [\n        # Directions for (R0, R1, R2, R3, R4, R5)\n        [+1, +1, +1, 0, 0, +1],  # EFM1\n        [0, +1, +1, +1, 0, 0],   # EFM2\n        [+1, 0, 0, 0, +1, 0],    # EFM3\n        [+1, +1, +1, +1, +1, 0], # EFM4\n        [+1, +1, +1, 0, +1, +1], # EFM5\n        [+1, -1, +1, 0, 0, +1],  # EFM6\n    ]\n\n    test_cases = [\n        {\n            \"mu_standard\": np.array([-10.0, -20.0, -30.0]),\n            \"c_ranges\": np.array([[1e-6, 1e-3], [1e-6, 1e-3], [1e-6, 1e-3]]) # A, B, C\n        },\n        {\n            \"mu_standard\": np.array([-20.0, -20.0, -20.0]),\n            \"c_ranges\": np.array([[1e-4, 1e-4], [1e-4, 1e-4], [1e-4, 1e-4]]) # A, B, C\n        },\n        {\n            \"mu_standard\": np.array([-20.0, -20.0, -20.0]),\n            \"c_ranges\": np.array([[1e-9, 1e-8],   # A\n                                  [1e-2, 1e-1],   # B\n                                  [1e-2, 1e-1]])  # C\n        }\n    ]\n\n    RT = R * T\n    final_results = []\n\n    for case in test_cases:\n        mu_standard = case[\"mu_standard\"]\n        c_ranges = case[\"c_ranges\"]\n        \n        # Calculate chemical potential bounds for mu = [mu_A, mu_B, mu_C]\n        mu_min = mu_standard + RT * np.log(c_ranges[:, 0])\n        mu_max = mu_standard + RT * np.log(c_ranges[:, 1])\n        mu_bounds = list(zip(mu_min, mu_max))\n        \n        case_results = []\n        for efm in efms:\n            # Construct the linear inequality system A_ub * mu = b_ub\n            A_ub_list = []\n            b_ub_list = []\n\n            for j in INTERNAL_REACTION_INDICES:\n                flux_dir = efm[j]\n                \n                if flux_dir == 1:  # Forward reaction: S_T[j] * mu = -epsilon\n                    A_ub_list.append(S_T[j])\n                    b_ub_list.append(-epsilon)\n                elif flux_dir == -1:  # Reverse reaction: S_T[j] * mu >= epsilon  (or -S_T[j] * mu = -epsilon)\n                    A_ub_list.append(-S_T[j])\n                    b_ub_list.append(-epsilon)\n            \n            # If there are no active internal reactions, the problem is trivially feasible\n            if not A_ub_list:\n                case_results.append(True)\n                continue\n\n            A_ub = np.array(A_ub_list)\n            b_ub = np.array(b_ub_list)\n\n            # Solve the linear feasibility problem\n            # Objective function is zero as we only care about feasibility\n            c = np.zeros(S_T.shape[1])\n            \n            # Use 'highs' for robustness. It is the default in newer SciPy versions.\n            res = linprog(c=c, A_ub=A_ub, b_ub=b_ub, bounds=mu_bounds, method='highs')\n            \n            # The 'success' flag indicates if a feasible solution was found\n            case_results.append(res.success)\n            \n        final_results.append(case_results)\n\n    # Print the final result in the requested format\n    print(final_results)\n\nsolve()\n```"
        }
    ]
}