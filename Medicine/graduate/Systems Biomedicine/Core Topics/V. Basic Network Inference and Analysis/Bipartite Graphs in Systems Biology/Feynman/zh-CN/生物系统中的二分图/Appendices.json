{
    "hands_on_practices": [
        {
            "introduction": "在系统生物学中，任何计算分析的第一步都是将复杂的生物网络转化为精确的数学形式。这个练习将指导你如何将一个转录因子与基因的调控关系网络，表示为其对应的二分邻接矩阵和完整邻接矩阵。通过这个过程，你不仅能巩固如图顶点度（degree）和握手引理（handshake lemma）等基本图论概念，还能熟练掌握使用线性代数语言来描述和操作生物网络的基础技能。",
            "id": "4321176",
            "problem": "在一个转录因子-基因调控系统中，考虑一个二分图，其包含一组转录因子 (TF) $U = \\{T_1, T_2, T_3\\}$ 和一组基因 $V = \\{G_1, G_2, G_3, G_4\\}$。$T_i \\in U$ 和 $G_j \\in V$ 之间的边表示有实验支持的结合。初始证据定义的边集 $E_0$ 为\n$$\nE_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}.\n$$\n使用以下基本定义：一个二分图在 $U$ 内部或 $V$ 内部没有边；双邻接矩阵 $B \\in \\{0,1\\}^{|U|\\times|V|}$ 的元素 $B_{ij} = 1$ 表示 $T_i$ 和 $G_j$ 之间有边，否则 $B_{ij} = 0$；在顶点排序 $(U,V)$ 下，全邻接矩阵 $A \\in \\{0,1\\}^{(|U|+|V|)\\times(|U|+|V|)}$ 的分块结构为\n$$\nA = \\begin{pmatrix}\n0  B \\\\\nB^{\\top}  0\n\\end{pmatrix};\n$$\n一个顶点的度是其关联边的数量；二分图的握手引理指出，$U$ 中所有顶点的度之和等于 $V$ 中所有顶点的度之和，且都等于总边数。\n\n任务：\n- 构建与 $E_0$ 对应的初始双邻接矩阵 $B_0$ 和全邻接矩阵 $A_0$。\n- 计算初始图在 $U$ 上的度向量（记为 $d_U^{(0)} \\in \\mathbb{N}^{|U|}$）和在 $V$ 上的度向量（记为 $d_V^{(0)} \\in \\mathbb{N}^{|V|}$）。验证握手引理对 $E_0$ 成立。\n- 新的染色质免疫沉淀测序证据表明存在另外两个结合：$(T_1,G_2)$ 和 $(T_3,G_4)$。令 $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$。构建更新后的双邻接矩阵 $B_1$ 和全邻接矩阵 $A_1$，以及更新后的度向量 $d_U^{(1)}$ 和 $d_V^{(1)}$。再次验证握手引理对 $E_1$ 成立。\n\n最后，定义更新矩阵 $\\Delta A = A_1 - A_0$ 并计算标量\n$$\nS = \\|\\Delta A\\|_F^2 = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A).\n$$\n仅报告 $S$ 的值作为最终答案。无需四舍五入。",
            "solution": "该问题定义明确，具有科学依据，并提供了进行求解所需的所有信息。\n\n转录因子集为 $U = \\{T_1, T_2, T_3\\}$，因此 $|U|=3$。基因集为 $V = \\{G_1, G_2, G_3, G_4\\}$，因此 $|V|=4$。二分图中的总顶点数为 $|U|+|V| = 3+4=7$。\n\n首先，我们构建与边集 $E_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}$ 对应的初始双邻接矩阵 $B_0$。矩阵 $B_0$ 是一个 $3 \\times 4$ 矩阵，其中行对应 $U$ 的元素，列对应 $V$ 的元素。如果 $T_i$ 和 $G_j$ 之间存在边，则元素 $B_{ij}$ 为 $1$。\n$$\nB_0 = \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  0\n\\end{pmatrix}\n$$\n全邻接矩阵 $A_0$ 是一个 $7 \\times 7$ 的分块矩阵，定义为 $A_0 = \\begin{pmatrix} \\mathbf{0}_{3\\times3}  B_0 \\\\ B_0^{\\top}  \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n$$\nA_0 = \\left(\\begin{array}{ccc|cccc}\n0  0  0  1  0  1  0 \\\\\n0  0  0  0  1  1  1 \\\\\n0  0  0  1  0  0  0 \\\\\n\\hline\n1  0  1  0  0  0  0 \\\\\n0  1  0  0  0  0  0 \\\\\n1  1  0  0  0  0  0 \\\\\n0  1  0  0  0  0  0\n\\end{array}\\right)\n$$\n接下来，我们计算度向量。$U$ 中顶点的度是 $B_0$ 中对应行的和。$V$ 中顶点的度是 $B_0$ 中对应列的和。\n$U$ 的度向量为 $d_U^{(0)}$：\n$\\deg(T_1) = 1+0+1+0 = 2$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+0 = 1$\n因此，$d_U^{(0)} = (2, 3, 1)^{\\top}$。\n\n$V$ 的度向量为 $d_V^{(0)}$：\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 0+1+0 = 1$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+0 = 1$\n因此，$d_V^{(0)} = (2, 1, 2, 1)^{\\top}$。\n\n为了验证握手引理，我们将每个部分中的度相加，并与边数 $|E_0| = 6$ 进行比较。\n$U$ 中的度之和：$\\sum_{i=1}^{3} (d_U^{(0)})_i = 2+3+1 = 6$。\n$V$ 中的度之和：$\\sum_{j=1}^{4} (d_V^{(0)})_j = 2+1+2+1 = 6$。\n由于两个和都等于 $|E_0|$，因此握手引理对初始图成立。\n\n现在，我们考虑具有两条新边 $(T_1,G_2)$ 和 $(T_3,G_4)$ 的更新图。新的边集是 $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$，有 $|E_1| = 6+2 = 8$ 条边。更新后的双邻接矩阵 $B_1$ 是通过将这些边添加到 $B_0$ 中得到的，这对应于将与边 $(T_1,G_2)$ 和 $(T_3,G_4)$ 相应的元素设为1。\n$$\nB_1 = \\begin{pmatrix}\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  1\n\\end{pmatrix}\n$$\n更新后的全邻接矩阵为 $A_1 = \\begin{pmatrix} \\mathbf{0}_{3\\times3}  B_1 \\\\ B_1^{\\top}  \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n\n更新后的度向量 $d_U^{(1)}$ 和 $d_V^{(1)}$ 是：\n$d_U^{(1)}$ ($B_1$ 的行和)：\n$\\deg(T_1) = 1+1+1+0 = 3$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+1 = 2$\n因此，$d_U^{(1)} = (3, 3, 2)^{\\top}$。\n\n$d_V^{(1)}$ ($B_1$ 的列和)：\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 1+1+0 = 2$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+1 = 2$\n因此，$d_V^{(1)} = (2, 2, 2, 2)^{\\top}$。\n\n验证更新后图的握手引理：\n$U$ 中的度之和：$\\sum_{i=1}^{3} (d_U^{(1)})_i = 3+3+2 = 8$。\n$V$ 中的度之和：$\\sum_{j=1}^{4} (d_V^{(1)})_j = 2+2+2+2 = 8$。\n两个和都等于 $|E_1|=8$，因此引理成立。\n\n最后，我们计算标量 $S = \\|\\Delta A\\|_F^2$，其中 $\\Delta A = A_1 - A_0$。\n首先，我们求出差分矩阵 $\\Delta A$。\n$$\n\\Delta A = A_1 - A_0 = \\begin{pmatrix} \\mathbf{0}  B_1 \\\\ B_1^{\\top}  \\mathbf{0} \\end{pmatrix} - \\begin{pmatrix} \\mathbf{0}  B_0 \\\\ B_0^{\\top}  \\mathbf{0} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{0}  B_1 - B_0 \\\\ B_1^{\\top} - B_0^{\\top}  \\mathbf{0} \\end{pmatrix}\n$$\n令 $\\Delta B = B_1 - B_0$。\n$$\n\\Delta B = \\begin{pmatrix}\n1  1  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  1\n\\end{pmatrix} - \\begin{pmatrix}\n1  0  1  0 \\\\\n0  1  1  1 \\\\\n1  0  0  0\n\\end{pmatrix} = \\begin{pmatrix}\n0  1  0  0 \\\\\n0  0  0  0 \\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n这个矩阵 $\\Delta B$ 仅在增加的边 $(T_1, G_2)$ 和 $(T_3, G_4)$ 对应的位置上有非零元素。\n完整的差分矩阵是 $\\Delta A = \\begin{pmatrix} \\mathbf{0}_{3\\times3}  \\Delta B \\\\ \\Delta B^{\\top}  \\mathbf{0}_{4\\times4} \\end{pmatrix}$。\n具体地：\n$$\n\\Delta A = \\left(\\begin{array}{ccc|cccc}\n0  0  0  0  1  0  0 \\\\\n0  0  0  0  0  0  0 \\\\\n0  0  0  0  0  0  1 \\\\\n\\hline\n0  0  0  0  0  0  0 \\\\\n1  0  0  0  0  0  0 \\\\\n0  0  0  0  0  0  0 \\\\\n0  0  1  0  0  0  0\n\\end{array}\\right)\n$$\n弗罗贝尼乌斯范数的平方，$S = \\|\\Delta A\\|_F^2$，是 $\\Delta A$ 中所有元素的平方和。\n$$\nS = \\sum_{i,j} (\\Delta A_{ij})^2\n$$\n$\\Delta A$ 的非零元素为 1，位于位置 $(1,5)$、$(3,7)$、$(5,1)$ 和 $(7,3)$。共有 $4$ 个这样的元素。\n因此，它们的平方和为：\n$$\nS = 1^2 + 1^2 + 1^2 + 1^2 = 1+1+1+1 = 4\n$$\n这个值也可以使用迹的定义 $S = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A)$ 来计算。由于 $\\Delta A$ 是一个实对称矩阵，所以 $\\Delta A^{\\top} = \\Delta A$，因此 $S = \\operatorname{trace}(\\Delta A^2)$。$\\Delta A^2$ 的对角线元素是 $\\Delta A$ 的行与自身的点积。这恰好计算了每行中非零元素的数量。例如，$\\Delta A^2$ 的第一个对角线元素是 1，来自 $\\Delta A$ 的第 1 行，该行有一个非零元素。共有 4 行，每行都有一个非零元素。所以迹将是 $1+1+1+1 = 4$。两种方法得到相同的结果。\n一个基于分块结构的更直接的论证是 $S = \\|\\Delta A\\|_F^2 = \\|\\Delta B\\|_F^2 + \\|\\Delta B^{\\top}\\|_F^2$。\n$\\|\\Delta B\\|_F^2 = 1^2 + 1^2 = 2$。\n由于弗罗贝尼乌斯范数在转置下不变，所以 $\\|\\Delta B^{\\top}\\|_F^2 = 2$。\n因此，$S = 2 + 2 = 4$。",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "在分析网络结构时，我们不仅关心其整体属性，更对其中反复出现的、具有特定功能的局部结构模式（即“网络基序”，network motifs）感兴趣。本练习将引导你推导并实现一个高效的算法，通过巧妙地运用矩阵乘法来精确计数二分图中的4-环（$4$-cycles），这是一种代表共调控或反馈机制的重要基序。这个实践将为你清晰地展示如何将抽象的图论概念转化为具体、高效的计算方法。",
            "id": "4321179",
            "problem": "考虑一个简单二分图 $G=(V,E)$，其顶点集分为两个不相交的类别 $V_{\\mathrm{enz}}$ (酶) 和 $V_{\\mathrm{met}}$ (代谢物)，其中每条边 $e \\in E$ 连接 $V_{\\mathrm{enz}}$ 中的一个顶点和 $V_{\\mathrm{met}}$ 中的一个顶点。设双邻接矩阵为 $B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$，其中如果酶 $i$ 与代谢物 $j$ 相连，则 $B_{ij} = 1$，否则 $B_{ij} = 0$。假设图中没有多重边和自环，因此 $B$ 是一个二元矩阵，描述了一个简单二分图。一个 4-环 (4-cycle) 是一个长度为 4 的简单环，其顶点在 $V_{\\mathrm{enz}}$ 和 $V_{\\mathrm{met}}$ 之间交替，即一个由不同顶点组成的序列 $(e_a, m_u, e_b, m_v)$，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$，$m_u, m_v \\in V_{\\mathrm{met}}$，并且边 $(e_a,m_u)$、$(m_u,e_b)$、$(e_b,m_v)$、$(m_v,e_a)$ 均存在于 $E$ 中。\n\n仅从这些核心定义出发，通过将 $C_4$ 表示为矩阵乘积 $B B^{\\top}$ 和 $B^{\\top} B$ 以及一个基于共享邻居的组合计数论证，推导出一个有理论依据的算法来计算整数 $C_4$，即 $G$ 中不同简单 4-环的数量。您的推导必须证明为什么对一个部中的共享邻居进行无序对计数可以得出不同简单 4-环的总数，以及为什么在另一个部上存在一个等价的对称表达式。基于此推导，实现一个程序，为下方的每个测试网络计算 $C_4$。\n\n每个测试网络由一个二元矩阵 $B$ 表示，其行索引酶，列索引代谢物。这些矩阵如下：\n\n- 测试 $1$ (完全二分子图中的最小 4-环)：$B = \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$。\n- 测试 $2$ (无 4-环，稀疏连接)：$B = \\begin{bmatrix} 1  0  0 \\\\ 1  0  0 \\\\ 0  1  0 \\end{bmatrix}$。\n- 测试 $3$ (多个重叠的 4-环)：$B = \\begin{bmatrix} 1  1  1  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$。\n- 测试 $4$ (完全二分图 $K_{3,3}$): $B = \\begin{bmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{bmatrix}$。\n- 测试 $5$ (边界情况，单个酶)：$B = \\begin{bmatrix} 1  1  1  1 \\end{bmatrix}$。\n\n您的程序必须对上述每个矩阵 $B$，使用从核心定义推导出的有理论依据的算法来计算整数 $C_4$。此外，为了进行内部验证，您应确保通过对酶计数（通过 $B B^{\\top}$）获得的值，与通过对代谢物计数（通过 $B^{\\top} B$）获得的值相等，并且与通过检查所有酶和代谢物的无序对进行直接枚举得到的值相等。最终输出应为单行，其中包含按测试 1 到 5 顺序排列的、计算出的 $C_4$ 值列表，格式为用方括号括起来的逗号分隔列表（例如，$[a,b,c,d,e]$）。不涉及物理单位或角度单位，也不需要百分比；每个输出条目都必须是整数。\n\n您的程序应只生成包含最终列表的一行，不含任何额外文本。",
            "solution": "在尝试解决方案之前，对问题陈述的有效性进行评估。\n\n### 第 1 步：提取已知信息\n- **图类型**：一个简单二分图 $G=(V,E)$，其顶点集分为两个不相交的类别 $V_{\\mathrm{enz}}$ (酶) 和 $V_{\\mathrm{met}}$ (代谢物)。\n- **边的定义**：每条边 $e \\in E$ 连接 $V_{\\mathrm{enz}}$ 中的一个顶点和 $V_{\\mathrm{met}}$ 中的一个顶点。\n- **双邻接矩阵**：$B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$，其中 $n_{\\mathrm{enz}} = |V_{\\mathrm{enz}}|$ 且 $n_{\\mathrm{met}} = |V_{\\mathrm{met}}|$。如果酶 $i$ 与代谢物 $j$ 相连，则 $B_{ij} = 1$，否则 $B_{ij} = 0$。\n- **环的定义**：一个简单 4-环是一个由不同顶点组成的序列 $(e_a, m_u, e_b, m_v)$，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$，$m_u, m_v \\in V_{\\mathrm{met}}$，并且边 $(e_a,m_u)$、$(m_u,e_b)$、$(e_b,m_v)$、$(m_v,e_a)$ 均存在于 $E$ 中。\n- **目标**：推导一个算法，使用矩阵乘积 $B B^{\\top}$ 和 $B^{\\top} B$ 来计算不同简单 4-环的数量 $C_4$，并实现该算法。\n- **测试数据**：\n    - 测试 $1$：$B = \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$\n    - 测试 $2$：$B = \\begin{bmatrix} 1  0  0 \\\\ 1  0  0 \\\\ 0  1  0 \\end{bmatrix}$\n    - 测试 $3$：$B = \\begin{bmatrix} 1  1  1  0 \\\\ 1  1  1  0 \\\\ 0  1  1  1 \\end{bmatrix}$\n    - 测试 $4$：$B = \\begin{bmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{bmatrix}$\n    - 测试 $5$：$B = \\begin{bmatrix} 1  1  1  1 \\end{bmatrix}$\n- **输出格式**：一个单行的逗号分隔整数列表，`[c1,c2,c3,c4,c5]`。\n\n### 第 2 步：使用提取的已知信息进行验证\n根据所需标准对问题进行评估。\n- **科学性**：该问题基于图论和线性代数的基本和标准概念。使用双邻接矩阵表示二分图和子图计数是成熟的数学课题。它们在酶-代谢物网络中的应用是系统生物学中一种常见的抽象。\n- **良构性**：问题定义清晰。输入矩阵已明确给出，期望的输出（4-环的数量）对每个输入都是一个唯一可确定的整数。\n- **客观性**：问题陈述使用精确、形式化的数学语言，没有歧义或主观论断。\n- **缺陷分析**：\n    1.  **科学/事实不健全**：无。定义和前提都是标准的，并且在数学上是合理的。\n    2.  **无法形式化/不相关**：无。问题是明确的数学问题，并与所述领域相关。\n    3.  **不完整/矛盾**：无。所有必要的定义和数据都已提供。\n    4.  **不切实际/不可行**：无。问题处理的是抽象的图结构，对于给定的矩阵，现代计算机可以轻松完成计算。\n    5.  **不适定/结构不良**：无。存在唯一解，且可从前提推导得出。\n    6.  **伪深刻/琐碎**：无。该问题需要一个非平凡的推导，将矩阵代数与组合计数联系起来，这是一个标准但概念上很有意义的练习。\n    7.  **超出科学可验证性**：无。结果可以通过直接枚举和推导出的公式进行验证。\n\n### 第 3 步：结论与行动\n问题是 **有效的**。将推导并实现一个有理论依据的解决方案。\n\n### 算法推导\n\n在具有分部 $V_{\\mathrm{enz}}$ 和 $V_{\\mathrm{met}}$ 的二分图中，一个简单 4-环由四个不同顶点的序列 $(e_a, m_u, e_b, m_v)$ 定义，其中 $e_a, e_b \\in V_{\\mathrm{enz}}$ 且 $m_u, m_v \\in V_{\\mathrm{met}}$。该环的存在意味着存在四条边：$(e_a, m_u)$、$(e_a, m_v)$、$(e_b, m_u)$ 和 $(e_b, m_v)$。这四个顶点和四条边构成了一个完全二分子图 $K_{2,2}$。因此，计算不同简单 4-环的数量 $C_4$ 等价于计算 $G$ 中不同 $K_{2,2}$ 子图的数量。\n\n一个 $K_{2,2}$ 子图由一对不同的酶（无序对）$\\{e_a, e_b\\}$ 和一对不同的代谢物（无序对）$\\{m_u, m_v\\}$ 唯一确定，条件是所有四个对应的边都存在。我们可以通过遍历一个部中的顶点对，并计算另一个部中有多少对顶点可以完成一个 $K_{2,2}$ 来对这些子图进行计数。\n\n**方法 1：通过酶对进行计数**\n\n考虑来自 $V_{\\mathrm{enz}}$ 的任意一对不同的酶（无序对）$\\{e_a, e_b\\}$。要使这两个酶成为一个 4-环的一部分，它们必须共享至少两个公共代谢物邻居。设 $N(v)$ 表示顶点 $v$ 的邻居集合。$e_a$ 和 $e_b$ 的公共代谢物邻居集合为 $N(e_a) \\cap N(e_b)$。设该集合的大小为 $k_{ab} = |N(e_a) \\cap N(e_b)|$。\n\n为了与 $e_a$ 和 $e_b$ 构成一个 4-环，我们必须从它们的公共邻居中选择两个不同的代谢物。从这 $k_{ab}$ 个公共邻居中选择一对无序的代谢物的方法数由二项式系数 $\\binom{k_{ab}}{2}$ 给出。每种这样的选择都与酶对 $\\{e_a, e_b\\}$ 构成一个唯一的 $K_{2,2}$ 子图（从而构成一个 4-环）。\n\n为了找到 4-环的总数 $C_4$，我们必须对所有不同的酶无序对将此数量求和：\n$$ C_4 = \\sum_{\\{e_a, e_b\\} \\subseteq V_{\\mathrm{enz}}, |\\{e_a, e_b\\}|=2} \\binom{k_{ab}}{2} = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{k_{ab}}{2} $$\n其中 $a$ 和 $b$ 是酶的索引。\n\n我们可以用双邻接矩阵 $B$ 来表示 $k_{ab}$。$B$ 的第 $i$ 行，记作 $B_{i,:}$，是一个向量，其第 $j$ 个分量为 1 当且仅当酶 $e_i$ 与代谢物 $m_j$ 相连。公共邻居数 $k_{ab}$ 是 $B_{a,:}$ 和 $B_{b,:}$ 中同为 1 的位置数。这恰好是这两个行向量的点积：\n$$ k_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} $$\n现在，考虑矩阵乘积 $S_{\\mathrm{enz}} = B B^{\\top}$。这是一个 $n_{\\mathrm{enz}} \\times n_{\\mathrm{enz}}$ 的对称矩阵。元素 $(S_{\\mathrm{enz}})_{ab}$ 是 $B$ 的第 $a$ 行与 $B^{\\top}$ 的第 $b$ 列的点积。因为 $B^{\\top}$ 的第 $b$ 列就是 $B$ 的第 $b$ 行，所以我们有：\n$$ (S_{\\mathrm{enz}})_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} = k_{ab} $$\n因此，$S_{\\mathrm{enz}} = B B^{\\top}$ 的非对角线元素计算了酶对之间共享的代谢物邻居数量。对角线元素 $(S_{\\mathrm{enz}})_{aa}$ 计算了酶 $e_a$ 的度，这与本计算无关。\n\n将此代入我们的计数公式，我们得到算法：\n$$ C_4 = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{(S_{\\mathrm{enz}})_{ab}}{2} = \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\frac{(S_{\\mathrm{enz}})_{ab}((S_{\\mathrm{enz}})_{ab} - 1)}{2} $$\n这个表达式对矩阵 $S_{\\mathrm{enz}}$ 的上（或下）三角部分（不包括对角线）的贡献求和。\n\n**方法 2：通过代谢物对进行计数（对称论证）**\n\n这个论证是完全对称的。我们可以从考虑来自 $V_{\\mathrm{met}}$ 的一对不同的代谢物（无序对）$\\{m_u, m_v\\}$ 开始。设 $k'_{uv} = |N(m_u) \\cap N(m_v)|$ 是这对代谢物的公共酶邻居数。为了形成一个 4-环，我们必须从这个集合中选择两个不同的酶，这有 $\\binom{k'_{uv}}{2}$ 种方法。\n\n对所有不同的代谢物无序对求和，得到总数：\n$$ C_4 = \\sum_{\\{m_u, m_v\\} \\subseteq V_{\\mathrm{met}}, |\\{m_u, m_v\\}|=2} \\binom{k'_{uv}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{k'_{uv}}{2} $$\n公共邻居数 $k'_{uv}$ 可以从 $B$ 的列中找到。设 $B_{:,j}$ 为第 $j$ 个列向量。那么：\n$$ k'_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} $$\n这对应于矩阵乘积 $S_{\\mathrm{met}} = B^{\\top}B$ 的元素，这是一个 $n_{\\mathrm{met}} \\times n_{\\mathrm{met}}$ 的对称矩阵，其中：\n$$ (S_{\\mathrm{met}})_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} = k'_{uv} $$\n这导出了等价的公式：\n$$ C_4 = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{(S_{\\mathrm{met}})_{uv}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\frac{(S_{\\mathrm{met}})_{uv}((S_{\\mathrm{met}})_{uv} - 1)}{2} $$\n\n**等价性证明**\n两个公式都计算了同一组对象：$K_{2,2}$ 子图，每个子图对应一个唯一的简单 4-环。第一个公式根据酶对来划分计数，而第二个公式根据代谢物对来划分计数。由于每个 4-环都恰好涉及一对酶和一对代谢物，因此两个求和必须得出相同的总数 $C_4$。这证实了组合恒等式：\n$$ \\sum_{1 \\le a  b \\le n_{\\mathrm{enz}}} \\binom{(BB^{\\top})_{ab}}{2} = \\sum_{1 \\le u  v \\le n_{\\mathrm{met}}} \\binom{(B^{\\top}B)_{uv}}{2} $$\n\n推导出的算法是首先计算这些“共享邻居”矩阵之一（$S_{\\mathrm{enz}}$ 或 $S_{\\mathrm{met}}$），然后遍历其唯一的非对角线元素 $k$，并对 $\\binom{k}{2}$ 的值求和。这比枚举所有四个顶点的组合在计算上更有效。实现将使用以酶为中心的公式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_c4(B: np.ndarray) -> int:\n    \"\"\"\n    Computes the number of simple 4-cycles (C4) in a bipartite graph.\n\n    The algorithm is derived from a combinatorial argument based on shared neighbors.\n    A 4-cycle is formed by two enzymes {e_a, e_b} and two metabolites {m_u, m_v}.\n    This structure requires that both enzymes are connected to both metabolites.\n    \n    1. The number of 4-cycles can be found by summing contributions from every\n       pair of enzymes {e_a, e_b}.\n    2. For a given pair, if they share k_ab common metabolite neighbors, they can\n       form binom(k_ab, 2) distinct 4-cycles by choosing 2 metabolites from\n       the shared set.\n    3. The number of shared neighbors k_ab for enzymes e_a and e_b is given by\n       the matrix product S_enz = B @ B.T, where (S_enz)_ab = k_ab.\n    4. The total count C4 is the sum of binom(k, 2) over all off-diagonal\n       elements k of the S_enz matrix.\n\n    Args:\n        B: The n_enz x n_met biadjacency matrix of the graph, as a numpy array.\n\n    Returns:\n        The total number of simple 4-cycles (C4) as an integer.\n    \"\"\"\n    if B.shape[0] < 2:\n        # A 4-cycle requires at least two enzymes.\n        return 0\n\n    # S_enz is the enzyme-enzyme shared neighbor matrix.\n    # (S_enz)_ab = number of metabolites connected to both enzyme a and enzyme b.\n    S_enz = B @ B.T\n\n    num_enzymes = S_enz.shape[0]\n    c4_count = 0\n\n    # Iterate over the upper triangle of the S_enz matrix (excluding the diagonal).\n    # This corresponds to iterating over all unique pairs of enzymes {a, b}.\n    for i in range(num_enzymes):\n        for j in range(i + 1, num_enzymes):\n            # k is the number of shared neighbors for the enzyme pair {i, j}.\n            k = S_enz[i, j]\n            \n            # If there are k shared neighbors, we can form binom(k, 2) 4-cycles.\n            # binom(k, 2) = k * (k - 1) / 2\n            if k >= 2:\n                c4_count += k * (k - 1) // 2\n                \n    return c4_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, computes C4 for each, and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: a minimal 4-cycle in a complete bipartite subgraph\n        np.array([[1, 1], \n                  [1, 1]]),\n        # Test 2: no 4-cycles, sparse connections\n        np.array([[1, 0, 0],\n                  [1, 0, 0],\n                  [0, 1, 0]]),\n        # Test 3: multiple overlapping 4-cycles\n        np.array([[1, 1, 1, 0],\n                  [1, 1, 1, 0],\n                  [0, 1, 1, 1]]),\n        # Test 4: complete bipartite K_{3,3}\n        np.array([[1, 1, 1],\n                  [1, 1, 1],\n                  [1, 1, 1]]),\n        # Test 5: boundary case, single enzyme\n        np.array([[1, 1, 1, 1]])\n    ]\n\n    results = []\n    for B in test_cases:\n        result = count_c4(B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了分析局部结构，二分图模型也是识别网络中全局关键节点的有力工具。本练习将聚焦于一个经典的图优化问题——最小顶点覆盖（minimum vertex cover），并要求你在一个反应-代谢物网络中求解。这个过程不仅需要你应用如图论中著名的 Kőnig 定理，更重要的是，它让你能够将抽象的数学解与一个重要的生物学概念——代谢网络中的“瓶颈”（choke points）——直接联系起来，从而为药物靶点发现等应用提供理论依据。",
            "id": "4321211",
            "problem": "考虑一个反应-代谢物二分网络，该网络被建模为一个二分图 $G = (R \\cup M, E)$，其中 $R$ 是反应顶点的集合，$M$ 是代谢物顶点的集合，$E \\subseteq R \\times M$ 是连接反应与代谢物的边的集合，如果一代谢物参与一反应（作为底物或产物），则存在相应的边。该图是简单、无权且无自环的。$R$ 中的所有顶点索引从 $0$ 到 $r - 1$，$M$ 中的所有顶点索引从 $0$ 到 $m - 1$，其中 $r = |R|$，$m = |M|$。对于一个给定的实例，其二分结构由 $r$、$m$ 以及一个有序对 $(i, j)$ 形式的边列表提供，其中 $i \\in \\{0, 1, \\dots, r - 1\\}$ 且 $j \\in \\{0, 1, \\dots, m - 1\\}$。\n\n根据图论的基本原理，图的顶点覆盖是一个顶点集合 $C \\subseteq R \\cup M$，使得 $E$ 中的每条边至少有一个端点在 $C$ 中。最小顶点覆盖是具有最小可能基数的顶点覆盖。在反应-代谢物二分网络的背景下，包含在最小顶点覆盖中的代谢物顶点子集可以被解释为用于通路中断的潜在瓶颈点，因为从网络中移除这些代谢物会消除所有关联的反应-代谢物边，从而阻断了通过被覆盖的边所关联的反应连通性。\n\n您的任务是编写一个完整的程序，为每个测试用例计算该二分图的一个最小顶点覆盖，并输出该覆盖中包含的代谢物顶点（来自 $M$）的索引，按非递减顺序排序。每个测试用例的结果必须是一个整数列表。\n\n请从核心定义和广为接受的图论事实出发。不应假设或使用任何未基于这些原理的特定技巧。该算法对于由给定参数描述的任何二分图实例都应是正确的。\n\n不涉及物理单位或角度。所有输出必须是纯数值。\n\n测试套件：\n- 测试用例 1：$r = 4$, $m = 4$, 边 $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)\\}$。\n- 测试用例 2：$r = 3$, $m = 2$, 边 $E = \\{(0, 0), (1, 0), (2, 0)\\}$。\n- 测试用例 3：$r = 2$, $m = 3$, 边 $E = \\{(0, 0), (1, 1)\\}$。\n- 测试用例 4：$r = 4$, $m = 4$, 边 $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$。\n- 测试用例 5：$r = 2$, $m = 2$, 边 $E = \\emptyset$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身是计算出的最小顶点覆盖中代谢物索引的列表，按非递减顺序排序。例如，一个包含两个测试用例的输出可能看起来像 $[[0,1],[2]]$。您的程序必须为提供的测试套件输出且仅输出这样的一行。",
            "solution": "该问题要求我们找到给定反应-代谢物二分图 $G = (R \\cup M, E)$ 的一个最小顶点覆盖中所包含的代谢物顶点集。解决方案必须源于图论的基本原理。\n\n在二分图中，将最小顶点覆盖与另一个关键图结构联系起来的最重要原理是柯尼希定理 (Kőnig's theorem)。该定理指出，在任何二分图中，最大匹配中的边数等于最小顶点覆盖中的顶点数。\n设 $\\mathcal{M}_{max}$ 为一个最大匹配（没有公共顶点的最大边集），$C_{min}$ 为一个最小顶点覆盖（与每条边都关联的最小顶点集）。柯尼希定理表明：\n$$|\\mathcal{M}_{max}| = |C_{min}|$$\n柯尼希定理的构造性证明提供了一个直接的算法，可以在给定最大匹配的情况下找到一个最小顶点覆盖。我们的策略将遵循这一构造性算法。\n\n该算法主要分两步进行：\n1.  在二分图 $G$ 中找到一个最大匹配 $\\mathcal{M}$。\n2.  使用匹配 $\\mathcal{M}$ 构造一个最小顶点覆盖 $C$。\n\n**步骤 1：寻找最大匹配**\n\n可以通过重复寻找“增广路径”来找到最大匹配。增广路径是图中的一条路径，它在当前匹配之外的边和当前匹配之内的边之间交替，从一个分部中的未匹配顶点开始，到另一个分部中的未匹配顶点结束。通过反转增广路径上边的状态（将非匹配边加入匹配，并将匹配边从中移除），匹配的大小会增加一。我们继续寻找并应用增广路径，直到找不到为止。此时，该匹配就是最大匹配。\n\n寻找增广路径的过程可以使用深度优先搜索 (DFS) 或广度优先搜索 (BFS) 高效实现。我们将使用一种基于 DFS 的方法。我们遍历反应集 $R$ 中的每个顶点 $u$。对于每个 $u$，我们执行一次 DFS 来寻找从它开始的增广路径。\n\n设图的两个分部为 $U=R$ (反应) 和 $V=M$ (代谢物)。匹配可以用一个大小为 $m=|M|$ 的数组 `match_M` 来表示，其中 `match_M[j]` 存储与代谢物 $j \\in M$ 匹配的 $R$ 中的顶点，如果 $j$ 未匹配，则为一个特殊值（例如 -1）。\n\nDFS 函数 `dfs(u, visited, match_M, adj)` 尝试寻找从反应顶点 $u \\in R$ 开始的增广路径。`visited` 数组记录在当前 DFS 中访问过的代谢物顶点，以防止循环。该函数的工作方式如下：对于 $u$ 的每个邻居 $v \\in M$，如果 $v$ 未被访问，我们将其标记为已访问。如果 $v$ 未匹配，我们就找到了一条增广路径。我们将 $u$ 与 $v$ 匹配并返回 true。如果 $v$ 已经与某个顶点 $u' \\in R$ 匹配，我们递归调用 `dfs(u', ...)`。如果这个递归调用找到了从 $u'$ 开始的增广路径，我们就可以“移动”匹配：$u'$ 获得一个新的伙伴，从而释放了 $v$，然后我们可以将 $v$ 与 $u$ 匹配。\n\n**步骤 2：构造最小顶点覆盖**\n\n一旦找到最大匹配 $\\mathcal{M}$，我们就可以构造一个最小顶点覆盖 $C$。设 $R_u$ 是反应集 $R$ 中未匹配顶点的集合。设 $Z$ 是 $G$ 中所有可以通过交替路径从 $R_u$ 中任意顶点到达的顶点的集合。交替路径是一条其边在 $\\mathcal{M}$ 之外和 $\\mathcal{M}$ 之内交替的路径。集合 $Z$ 可以通过从 $R_u$ 中所有顶点开始进行一次图遍历（DFS 或 BFS）来找到：\n- 从一个顶点 $u \\in R \\cap Z$ 出发，如果边 $(u,v)$ **不**在 $\\mathcal{M}$ 中，则遍历到顶点 $v \\in M$。\n- 从一个顶点 $v \\in M \\cap Z$ 出发，如果边 $(u,v)$ **在** $\\mathcal{M}$ 中，则遍历到顶点 $u \\in R$。\n\n找到集合 $Z$ 后（可划分为 $Z_R = Z \\cap R$ 和 $Z_M = Z \\cap M$），最小顶点覆盖 $C$ 由柯尼希定理的构造性证明中的公式给出：\n$$C = (R \\setminus Z_R) \\cup Z_M$$\n问题要求的是该覆盖中的代谢物顶点的索引，这正是集合 $Z_M$。\n\n让我们用测试用例 4 来说明：$r=4, m=4, E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$。\n- 分部为 $R=\\{0, 1, 2, 3\\}$ 和 $M=\\{0, 1, 2, 3\\}$。\n- **步骤 1：** 我们寻找一个最大匹配。通过增广路径算法可能找到的一个最大匹配是 $\\mathcal{M} = \\{(0,0), (1,1), (2,2)\\}$。该匹配的大小为 3。顶点 $r_3$ 在 $R$ 中未匹配，顶点 $m_1$ 和 $m_3$ 在 $M$ 中未匹配。\n- **步骤 2：** 我们构造顶点覆盖。\n  - $R$ 中未匹配的顶点集为 $R_u = \\{3\\}$。\n  - 我们寻找可通过交替路径从 $R_u$ 到达的顶点集 $Z$。\n    1. 从 $r_3$ 开始遍历。将 $r_3$ 加入 $Z$。\n    2. 从 $r_3$ 出发，我们可以沿着非匹配边 $(3,2)$ 到达 $m_2$。将 $m_2$ 加入 $Z$。\n    3. 从 $m_2$ 出发，我们必须沿着一条匹配边遍历。边 $(2,2)$ 在 $\\mathcal{M}$ 中。所以，我们遍历到 $r_2$。将 $r_2$ 加入 $Z$。\n    4. 从 $r_2$ 出发，我们只能遍历非匹配边，但其唯一的邻居是 $m_2$，它已经在 $Z$ 中了。遍历停止。\n  - 已访问的顶点集为 $Z = \\{r_2, r_3, m_2\\}$。\n  - 我们将 $Z$ 划分为 $Z_R = \\{2, 3\\}$ 和 $Z_M = \\{2\\}$。\n  - 最小顶点覆盖为 $C = (R \\setminus Z_R) \\cup Z_M = (\\{0,1,2,3\\} \\setminus \\{2,3\\}) \\cup \\{2\\} = \\{0,1\\} \\cup \\{2\\}$。这指的是顶点 $r_0, r_1, m_2$。\n  - $C$ 的大小为 3，这与最大匹配的大小相等，是正确的。\n- 覆盖中的代谢物顶点是 $Z_M$ 中的顶点，即 $\\{m_2\\}$。要求的输出是按非递减顺序排序的索引列表：$[2]$。\n\n提供的代码为每个测试用例实现了这一过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through test cases, computes the metabolite indices in a minimum\n    vertex cover for each, and prints the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)]),\n        # Test case 2\n        (3, 2, [(0, 0), (1, 0), (2, 0)]),\n        # Test case 3\n        (2, 3, [(0, 0), (1, 1)]),\n        # Test case 4\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]),\n        # Test case 5\n        (2, 2, [])\n    ]\n\n    results = []\n    for r, m, edges in test_cases:\n        result = compute_mvc_metabolites(r, m, edges)\n        results.append(result)\n\n    # Format the final output string as per requirements, removing spaces in lists.\n    # e.g., [[0,1],[2]] instead of '[[0, 1], [2]]'\n    formatted_results = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_mvc_metabolites(r, m, edges):\n    \"\"\"\n    Computes the metabolite indices in a minimum vertex cover of a bipartite graph.\n\n    The function follows the constructive proof of Kőnig's theorem:\n    1. Find a maximum matching using an augmenting path algorithm (DFS-based).\n    2. Construct the minimum vertex cover from the matching by finding all\n       vertices reachable from unmatched R-vertices via alternating paths.\n    3. Return the metabolite vertices from the constructed cover.\n\n    Args:\n        r (int): Number of vertices in the reaction set R.\n        m (int): Number of vertices in the metabolite set M.\n        edges (list of tuples): The set of edges E, where each edge is (i, j)\n                                with i in R and j in M.\n\n    Returns:\n        list of int: A sorted list of indices of metabolite vertices in one\n                     minimum vertex cover.\n    \"\"\"\n    if not edges:\n        return []\n\n    adj = [[] for _ in range(r)]\n    for u, v in edges:\n        adj[u].append(v)\n\n    # `match_m[j]` stores the R-vertex matched with M-vertex j.\n    match_m = np.full(m, -1, dtype=int)\n\n    def dfs_match(u, visited_m_dfs, current_match_m, adj_list):\n        \"\"\"\n        DFS to find an augmenting path starting from an R-vertex u.\n        \"\"\"\n        for v in adj_list[u]:\n            if not visited_m_dfs[v]:\n                visited_m_dfs[v] = True\n                # If v is unmatched, or its partner can find another match\n                if current_match_m[v] == -1 or dfs_match(current_match_m[v], visited_m_dfs, current_match_m, adj_list):\n                    current_match_m[v] = u\n                    return True\n        return False\n\n    # Step 1: Find a maximum matching\n    for i in range(r):\n        visited_m_in_dfs = np.zeros(m, dtype=bool)\n        dfs_match(i, visited_m_in_dfs, match_m, adj)\n        \n    # Build reverse matching for convenience\n    match_r = np.full(r, -1, dtype=int)\n    for j in range(m):\n        if match_m[j] != -1:\n            match_r[match_m[j]] = j\n\n    # Step 2: Construct the minimum vertex cover\n    unmatched_r = [i for i in range(r) if match_r[i] == -1]\n\n    # Find the set Z of vertices reachable from unmatched_r via alternating paths\n    z_r = set(unmatched_r)\n    z_m = set()\n    queue = list(unmatched_r)\n    head = 0\n\n    while head < len(queue):\n        u = queue[head]\n        head += 1\n        for v in adj[u]:\n            # Traverse non-matching edge from R to M\n            if v not in z_m and match_r[u] != v:\n                z_m.add(v)\n                u_partner = match_m[v]\n                # If endpoint is matched, traverse matching edge from M to R\n                if u_partner != -1 and u_partner not in z_r:\n                    z_r.add(u_partner)\n                    queue.append(u_partner)\n\n    # The metabolite vertices in the minimum vertex cover are exactly z_m.\n    # The cover C = (R \\ z_r) U z_m\n    mvc_metabolites = sorted(list(z_m))\n    \n    return mvc_metabolites\n\nsolve()\n```"
        }
    ]
}