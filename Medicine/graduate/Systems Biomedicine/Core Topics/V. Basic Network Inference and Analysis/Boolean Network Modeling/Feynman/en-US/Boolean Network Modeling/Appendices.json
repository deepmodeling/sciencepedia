{
    "hands_on_practices": [
        {
            "introduction": "The behavior of a Boolean network is defined not by a single state transition, but by its complete set of long-term trajectories. To understand this global behavior, we can map out the entire state-transition graph, which visualizes every possible path the system can take. This exercise provides a foundational understanding of how global system dynamics, including stable patterns known as attractors, emerge from simple, local update rules .",
            "id": "4321661",
            "problem": "In systems biomedicine, Boolean network modeling represents regulatory interactions among molecular species with binary-valued nodes that evolve in discrete time according to deterministic update rules. Consider a two-node Boolean network modeling cross-regulation between two genes with node states $x_1 \\in \\{0,1\\}$ and $x_2 \\in \\{0,1\\}$. Under synchronous updates, the network evolves according to the deterministic map $F:\\{0,1\\}^{2} \\to \\{0,1\\}^{2}$ given by the node update rules $f_1=\\neg x_2$ and $f_2=x_1$, so that $F(x_1,x_2) = (\\neg x_2, x_1)$. Starting from the fundamental definitions of synchronous Boolean network dynamics and discrete-time state-transition graphs, do the following:\n- Enumerate the full directed transition graph on the state space $\\{0,1\\}^{2}$ induced by $F$.\n- Identify all cycles (also called periodic orbits or limit cycles) in this graph and compute their lengths in discrete time.\n\nAs your final numerical answer, report the length of the unique cycle you identify. No rounding is needed. Express the answer as a pure number without units.",
            "solution": "The user has provided a problem from the field of systems biomedicine, specifically concerning Boolean network modeling. I will first validate the problem statement according to the required procedure.\n\n### Step 1: Extract Givens\n- **System**: A two-node Boolean network.\n- **Node states**: $x_1 \\in \\{0,1\\}$ and $x_2 \\in \\{0,1\\}$.\n- **State space**: $\\{0,1\\}^2$.\n- **Update scheme**: Synchronous updates.\n- **Deterministic map**: $F:\\{0,1\\}^{2} \\to \\{0,1\\}^{2}$.\n- **Node update rules**: $f_1 = \\neg x_2$ and $f_2 = x_1$.\n- **Map definition**: $F(x_1,x_2) = (\\neg x_2, x_1)$.\n- **Task 1**: Enumerate the full directed transition graph on the state space $\\{0,1\\}^{2}$ induced by $F$.\n- **Task 2**: Identify all cycles (periodic orbits or limit cycles) and compute their lengths.\n- **Final Answer Requirement**: Report the length of the unique cycle.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is well-grounded in the established theory of discrete dynamical systems and specifically Boolean networks, a standard modeling formalism in computational systems biology and related fields. The concepts of state space, synchronous updates, state-transition graphs, and limit cycles are all fundamental and rigorously defined.\n2.  **Well-Posed**: The problem is well-posed. The state space is finite, containing $2^2=4$ states. The update map $F$ is deterministic. For any finite, deterministic system, the state trajectory from any initial condition is unique and must eventually enter a periodic orbit (a cycle). The problem asks to characterize these dynamics, which is a solvable task with a unique outcome.\n3.  **Objective**: The problem is stated in precise, objective mathematical language, free from ambiguity or subjective claims.\n4.  **Flaw Checklist**: The problem does not violate any of the specified criteria for invalidity. It is scientifically sound, formalizable, complete, feasible, and well-structured.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be provided.\n\n### Solution\nThe problem requires us to analyze the dynamics of a two-node synchronous Boolean network. The state of the network at any discrete time step $t$ is given by the vector $(x_1(t), x_2(t))$, where $x_1$ and $x_2$ can take values in $\\{0, 1\\}$. The state space of the system is the set of all possible state vectors, $S = \\{0,1\\}^2 = \\{(0,0), (0,1), (1,0), (1,1)\\}$.\n\nThe network evolves according to a synchronous update rule, where the state of all nodes at time $t+1$ is determined simultaneously from the state of all nodes at time $t$. This evolution is described by the map $F: S \\to S$, defined as $F(x_1, x_2) = (x_1(t+1), x_2(t+1))$. The individual update functions are given as $x_1(t+1) = f_1(x_1(t), x_2(t)) = \\neg x_2(t)$ and $x_2(t+1) = f_2(x_1(t), x_2(t)) = x_1(t)$.\nThe logical NOT operator, $\\neg$, is defined as $\\neg 0 = 1$ and $\\neg 1 = 0$.\nThe full map is thus $F(x_1, x_2) = (\\neg x_2, x_1)$.\n\nTo enumerate the directed state-transition graph, we apply the map $F$ to each of the $4$ states in the state space $S$:\n\n1.  For the state $(0,0)$:\n    $$F(0,0) = (\\neg 0, 0) = (1,0)$$\n    This corresponds to a directed edge from state $(0,0)$ to state $(1,0)$ in the transition graph.\n\n2.  For the state $(0,1)$:\n    $$F(0,1) = (\\neg 1, 0) = (0,0)$$\n    This corresponds to a directed edge from state $(0,1)$ to state $(0,0)$.\n\n3.  For the state $(1,0)$:\n    $$F(1,0) = (\\neg 0, 1) = (1,1)$$\n    This corresponds to a directed edge from state $(1,0)$ to state $(1,1)$.\n\n4.  For the state $(1,1)$:\n    $$F(1,1) = (\\neg 1, 1) = (0,1)$$\n    This corresponds to a directed edge from state $(1,1)$ to state $(0,1)$.\n\nThe full directed transition graph consists of these four transitions. We can trace the path through the state space by following these directed edges. Starting from any arbitrary state, for instance $(0,0)$:\n- The successor of $(0,0)$ is $(1,0)$.\n- The successor of $(1,0)$ is $(1,1)$.\n- The successor of $(1,1)$ is $(0,1)$.\n- The successor of $(0,1)$ is $(0,0)$.\n\nThis sequence of transitions forms a closed loop, or cycle:\n$$ (0,0) \\to (1,0) \\to (1,1) \\to (0,1) \\to (0,0) $$\n\nA cycle (or periodic orbit, or limit cycle) is a trajectory that repeats itself. In this case, the sequence of states repeats every $4$ time steps. Since all four states of the system are part of this single closed loop, there are no other states available to form other cycles or transient paths leading to different cycles. Therefore, this network possesses a single, unique cycle that encompasses the entire state space.\n\nThe length of a cycle is defined as the number of states (or, equivalently, the number of time steps) in the repeating sequence. The identified cycle contains the four states $(0,0)$, $(1,0)$, $(1,1)$, and $(0,1)$.\nThus, the length of this unique cycle is $4$.",
            "answer": "$$\\boxed{4}$$"
        },
        {
            "introduction": "For larger or more complex biological networks, manual analysis of the state space becomes impractical. This is especially true for asynchronous models, where the dynamics can be richer and more varied than in synchronous ones. This practice challenges you to shift from manual calculation to algorithmic implementation, a critical skill for analyzing realistic biological systems, by developing a program to identify attractors and their corresponding basins of attraction under asynchronous dynamics .",
            "id": "4321637",
            "problem": "Consider a Boolean network in the context of systems biomedicine, where a Gene Regulatory Network (GRN) is modeled as $n$ binary nodes with state space $\\{0,1\\}^n$. Let the node indices be labeled as $1,2,\\dots,n$, and let a Boolean state be denoted by $x=(x_1,x_2,\\dots,x_n)$ with each $x_i \\in \\{0,1\\}$. For each node $i$, the Boolean update function is $f_i:\\{0,1\\}^n \\to \\{0,1\\}$. The asynchronous update semantics are defined as follows: from a state $x$, for every index $i$ such that $f_i(x) \\neq x_i$, there is a directed transition to a successor state $y^{(i)}$ whose components satisfy $y^{(i)}_i = f_i(x)$ and $y^{(i)}_j = x_j$ for all $j \\neq i$. If $f_i(x) = x_i$ for all $i \\in \\{1,\\dots,n\\}$, then $x$ is a fixed point with no outgoing transitions. The global dynamics under asynchronous updates can be represented as a finite directed graph on the $2^n$ states.\n\nWe define the directed state-transition graph $G$ whose vertices are the $2^n$ binary states and whose edges $x \\to y$ represent single-node asynchronous updates as above. An attractor under asynchronous semantics is a terminal Strongly Connected Component (SCC) of $G$, i.e., a non-empty subset $A \\subseteq \\{0,1\\}^n$ that is strongly connected and has no outgoing edges to states outside $A$. The basin of attraction of an attractor $A$ is defined here as the set of all states from which there exists at least one directed path (under asynchronous updates) to any state in $A$. The basin size is the cardinality of this set. We will use the mapping from binary state vectors to integer indices $s \\in \\{0,1,\\dots,2^n-1\\}$ given by\n$$\ns(x) \\;=\\; \\sum_{i=1}^{n} x_i \\, 2^{\\,n-i},\n$$\nso that $x_1$ is the most significant bit and $x_n$ is the least significant bit. This integer encoding defines a total order on states, which we will use to sort attractors by the minimum index they contain and to sort the states within each attractor in increasing index order.\n\nYour task is to write a complete program that:\n- Enumerates all $2^n$ states for each given network,\n- Constructs all asynchronous transitions according to the above definition,\n- Computes all attractors as terminal SCCs,\n- Determines the size of each attractor (number of states in the SCC),\n- Determines the size of each basin by counting the number of states that can reach at least one state in the attractor via directed paths,\n- Outputs the results for a provided test suite exactly in the required format.\n\nStart from fundamental definitions of Boolean networks, asynchronous update semantics, and graph-theoretic Strongly Connected Components, without assuming any specialized shortcut formulas. Ensure that your algorithmic reasoning is consistent with these definitions.\n\nTest Suite:\nFor each test case $k$, the network is specified by an integer $n_k$ and the list of node update functions $(f_1,\\dots,f_{n_k})$. The test suite contains three networks:\n\n- Test case $1$: $n_1 = 3$ with\n  $f_1(x) = x_2$, $f_2(x) = x_1$, $f_3(x) = x_3$.\n- Test case $2$: $n_2 = 3$ with a negative-feedback ring\n  $f_1(x) = \\neg x_2$, $f_2(x) = \\neg x_3$, $f_3(x) = \\neg x_1$,\n  where $\\neg$ denotes logical negation.\n- Test case $3$: $n_3 = 2$ with\n  $f_1(x) = \\neg x_1$, $f_2(x) = x_2$.\n\nAnswer specification:\n- For each test case, your program must produce a list with four elements:\n  $[$number of attractors$, $list of attractors as lists of state indices$, $list of attractor sizes$, $list of basin sizes$]$.\n- Each attractor is represented as a list of the integer indices of its states, sorted in increasing order according to $s(x)$.\n- Attractors are ordered in the overall list by increasing value of the minimum state index they contain.\n- Basin sizes are ordered to align with the corresponding attractors.\n- All numbers must be integers.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example:\n$[ \\text{result\\_tc1} , \\text{result\\_tc2} , \\text{result\\_tc3} ]$,\nwithout any additional whitespace in the printed line.\n\nThere are no physical units involved, and there are no angles or percentages. The final output is purely combinatorial data in the integer encoding defined above. The problem is universally applicable and solvable in any modern programming language by constructing and analyzing the finite directed graph induced by asynchronous Boolean updates. Ensure scientific realism by adhering to the defined semantics and by returning logically consistent attractors and basin sizes.",
            "solution": "The problem requires a comprehensive analysis of asynchronous Boolean networks, including the identification of attractors and their basins of attraction. The solution necessitates a multi-step algorithmic approach founded on graph theory. The state space of a Boolean network with $n$ nodes is $\\{0,1\\}^n$, which contains $2^n$ unique states. We model the system's dynamics as a directed state-transition graph $G=(V, E)$, where the set of vertices $V$ is the set of all $2^n$ states, and a directed edge $(x, y) \\in E$ exists if state $y$ is reachable from state $x$ via a single asynchronous update.\n\nFirst, we formalize the state representation. Each state $x = (x_1, x_2, \\dots, x_n)$ is mapped to a unique integer index $s \\in \\{0, 1, \\dots, 2^n-1\\}$ using the specified formula:\n$$\ns(x) = \\sum_{i=1}^{n} x_i \\, 2^{n-i}\n$$\nThis encoding treats $(x_1, \\dots, x_n)$ as the binary representation of $s$, with $x_1$ as the most significant bit. This allows us to use integer indices to represent states, which is convenient for implementing graph algorithms.\n\nThe algorithmic procedure is as follows:\n\n1.  **State-Transition Graph Construction**: We begin by constructing the adjacency list representation of the graph $G$. For each of the $2^n$ states, identified by its integer index $s$, we first convert $s$ back to its binary vector form $x=(x_1, \\dots, x_n)$. Then, for each node $i \\in \\{1, \\dots, n\\}$, we evaluate the corresponding update function $f_i(x)$. If the current state of the node, $x_i$, differs from the target value, i.e., $x_i \\neq f_i(x)$, an asynchronous transition is possible. This transition leads to a successor state $y^{(i)}$ where only the $i$-th component is updated: $y^{(i)}_i = f_i(x)$ and $y^{(i)}_j = x_j$ for all $j \\neq i$. We convert each such successor state $y^{(i)}$ to its integer index and add it to the adjacency list of state $s$. If a state $x$ satisfies $f_i(x) = x_i$ for all $i$, it is a fixed point and has no outgoing transitions.\n\n2.  **Strongly Connected Component (SCC) Decomposition**: An attractor is defined as a terminal Strongly Connected Component (SCC) of the state-transition graph $G$. To find all SCCs, we employ Tarjan's algorithm, a standard and efficient method based on a single Depth-First Search (DFS) traversal of the graph. For each vertex $u$, the algorithm maintains two values: a discovery time `disc[u]`, which is the time of the first visit, and a \"low-link\" value `low[u]`, which is the lowest discovery time reachable from $u$ (including itself) through its DFS subtree. A vertex $u$ is the root of an SCC if and only if `disc[u] == low[u]`. When such a root is found, all vertices on the algorithm's stack above and including $u$ form a single SCC. This procedure partitions the entire set of states $V$ into disjoint SCCs.\n\n3.  **Identification of Attractors (Terminal SCCs)**: After decomposing the graph into SCCs, we must identify which of these are terminal. An SCC, say $C$, is terminal if and only if there are no edges originating from any state $u \\in C$ that lead to a state $v \\notin C$. We iterate through each computed SCC. For each state within the SCC, we examine its successors in the original graph $G$. If all successors of all states in the SCC are also contained within that same SCC, it is declared a terminal SCC, or an attractor.\n\n4.  **Basin of Attraction Calculation**: The basin of attraction of an attractor $A$ is defined as the set of all states from which there exists at least one path to any state in $A$. To compute the size of this set, we can solve a reachability problem on the graph. The set of states that can reach $A$ is most efficiently found by considering the reverse graph, $G_{rev}$, where every edge $(u,v)$ in $G$ is replaced by an edge $(v,u)$. Then, starting a graph traversal (such as Breadth-First Search or Depth-First Search) from all states in the attractor $A$ simultaneously on $G_{rev}$, we can discover all states from which $A$ is reachable. The total number of unique states visited during this traversal constitutes the basin of $A$, and its cardinality is the basin size.\n\n5.  **Output Formatting**: Finally, the results for each test case are compiled. The identified attractors are sorted based on the minimum state index they contain. The states within each attractor are also sorted in increasing order of their indices. The attractor sizes and basin sizes are listed in an order corresponding to the sorted attractors. This structured data is then formatted into the specified list format for final output.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# scipy is available but not required for this problem.\n# from scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and print results for all test cases.\n    \"\"\"\n\n    # Helper function to format lists without whitespace, as per output requirements.\n    def format_list(item):\n        if isinstance(item, list):\n            return f\"[{','.join(format_list(x) for x in item)}]\"\n        else:\n            return str(item)\n\n    test_cases = [\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: x[1], lambda x: x[0], lambda x: x[2]],\n        },\n        {\n            \"n\": 3,\n            \"functions\": [lambda x: 1 - x[1], lambda x: 1 - x[2], lambda x: 1 - x[0]],\n        },\n        {\n            \"n\": 2,\n            \"functions\": [lambda x: 1 - x[0], lambda x: x[1]],\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        functions = case[\"functions\"]\n        result = analyze_network(n, functions)\n        all_results.append(result)\n\n    print(format_list(all_results))\n\ndef analyze_network(n, functions):\n    \"\"\"\n    Analyzes a single Boolean network to find its attractors and their basins.\n\n    Args:\n        n (int): The number of nodes in the network.\n        functions (list of callables): The list of Boolean update functions.\n\n    Returns:\n        list: A list containing [num_attractors, attractors, attractor_sizes, basin_sizes].\n    \"\"\"\n    num_states = 1 << n  # Equivalent to 2**n\n\n    # --- 1. Graph Construction ---\n    adj = {i: [] for i in range(num_states)}\n    rev_adj = {i: [] for i in range(num_states)}\n\n    for s in range(num_states):\n        # Convert integer index to binary state tuple\n        state_str = f'{s:0{n}b}'\n        state = tuple(int(c) for c in state_str)\n\n        for i in range(n):\n            target_val = functions[i](state)\n            if state[i] != target_val:\n                next_state_list = list(state)\n                next_state_list[i] = target_val\n                # Convert next state to integer index\n                next_s = int(\"\".join(map(str, next_state_list)), 2)\n                if next_s not in adj[s]:\n                    adj[s].append(next_s)\n                if s not in rev_adj[next_s]:\n                    rev_adj[next_s].append(s)\n    \n    # --- 2. SCC Decomposition (Tarjan's Algorithm) ---\n    disc = [-1] * num_states\n    low = [-1] * num_states\n    on_stack = [False] * num_states\n    stack = []\n    time = 0\n    sccs = []\n\n    def tarjan_dfs(u):\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n        stack.append(u)\n        on_stack[u] = True\n\n        for v in adj[u]:\n            if disc[v] == -1:\n                tarjan_dfs(v)\n                low[u] = min(low[u], low[v])\n            elif on_stack[v]:\n                low[u] = min(low[u], disc[v])\n\n        if low[u] == disc[u]:\n            scc = []\n            while True:\n                node = stack.pop()\n                on_stack[node] = False\n                scc.append(node)\n                if node == u:\n                    break\n            sccs.append(set(scc))\n\n    for i in range(num_states):\n        if disc[i] == -1:\n            tarjan_dfs(i)\n\n    # --- 3. Identify Terminal SCCs (Attractors) ---\n    attractors = []\n    for scc in sccs:\n        is_terminal = True\n        for u in scc:\n            for v in adj[u]:\n                if v not in scc:\n                    is_terminal = False\n                    break\n            if not is_terminal:\n                break\n        if is_terminal:\n            attractors.append(sorted(list(scc)))\n\n    # Sort attractors by their minimum state index\n    attractors.sort(key=lambda a: a[0])\n\n    # --- 4. Basin of Attraction Calculation ---\n    basin_sizes = []\n    for attractor in attractors:\n        queue = list(attractor)\n        visited = set(attractor)\n        head = 0\n        while head < len(queue):\n            u = queue[head]\n            head += 1\n            for p in rev_adj[u]:\n                if p not in visited:\n                    visited.add(p)\n                    queue.append(p)\n        basin_sizes.append(len(visited))\n\n    # --- 5. Format Output ---\n    num_attractors = len(attractors)\n    attractor_sizes = [len(a) for a in attractors]\n    \n    return [num_attractors, attractors, attractor_sizes, basin_sizes]\n\nsolve()\n\n```"
        },
        {
            "introduction": "Beyond direct simulation and graph traversal, we can leverage powerful formal methods from computer science to analyze network properties. Finding the stable states, or fixed points, of a network is a fundamental task, as these often correspond to distinct cellular phenotypes. This advanced exercise introduces the powerful technique of reframing the search for fixed points ($x = f(x)$) as a Boolean Satisfiability (SAT) problem, allowing you to use highly optimized solvers to analyze networks far too large for exhaustive exploration .",
            "id": "4321651",
            "problem": "You are given a synchronous Boolean network of $n$ genes with state vector $x \\in \\{0,1\\}^{n}$ and an update rule $f : \\{0,1\\}^{n} \\rightarrow \\{0,1\\}^{n}$. A fixed point is any state $x$ such that $x = f(x)$. Construct a Boolean Satisfiability (SAT) formulation by encoding the fixed point condition $x_i \\leftrightarrow f_i(x)$ for each gene $i \\in \\{1,\\dots,n\\}$ as a set of clauses in Conjunctive Normal Form (CNF). Use the standard Tseitin transformation to convert arbitrary Boolean expressions composed of $\\land$, $\\lor$, $\\neg$, and exclusive-or $\\oplus$ over literals into CNF. Solve for all satisfying assignments using a complete SAT procedure and, for each satisfying assignment of the original variables $(x_1,\\dots,x_n)$, verify it by direct substitution into $f$ to confirm $x = f(x)$. Report the set of all verified fixed points for each test case.\n\nFundamental base and definitions to use:\n- Boolean algebra on $\\{0,1\\}$ with operations $\\land$ (logical and), $\\lor$ (logical or), $\\neg$ (logical not), and $\\oplus$ (exclusive-or).\n- Conjunctive Normal Form (CNF) is a conjunction of disjunctions of literals, where a literal is either a variable $v$ or its negation $\\neg v$.\n- The Tseitin transformation introduces auxiliary variables to represent subformulas and enforces their equivalence to those subformulas via CNF clauses, preserving satisfiability while ensuring at most linear growth in the number of clauses.\n- Satisfiability (SAT) asks whether there exists $x \\in \\{0,1\\}^{n}$ satisfying all CNF clauses.\n\nYour program must implement the SAT encoding and solving without user input and produce results for the following test suite of Boolean networks. In each network, $x_i$ denotes the $i$-th gene, constants $0$ and $1$ denote fixed Boolean values, and the update functions are given as Boolean expressions of the variables.\n\nTest suite:\n- Case A: $n=3$, with update functions\n  - $f_1(x) = x_2 \\land \\neg x_3$\n  - $f_2(x) = x_1 \\lor x_3$\n  - $f_3(x) = \\neg x_1 \\land \\neg x_2$\n- Case B: $n=4$, with update functions\n  - $f_1(x) = x_1$\n  - $f_2(x) = \\neg x_2$\n  - $f_3(x) = 1$\n  - $f_4(x) = 0$\n- Case C: $n=4$, with update functions\n  - $f_1(x) = x_2$\n  - $f_2(x) = x_1$\n  - $f_3(x) = x_3$\n  - $f_4(x) = x_1 \\oplus x_2$\n\nAlgorithmic requirements:\n- Encode each fixed point constraint $x_i \\leftrightarrow f_i(x)$ to CNF using Tseitin transformation for the subformulas $f_i(x)$ and bi-implications for the root auxiliary variable.\n- Solve the CNF using a complete SAT solver that performs unit propagation and branching to enumerate all satisfying assignments. Auxiliary variables introduced by Tseitin transformation should not appear in the final reported fixed points.\n- For each candidate assignment of $(x_1,\\dots,x_n)$ obtained from the SAT solver, verify by computing $f(x)$ directly from the Boolean expressions and selecting only those assignments where $x = f(x)$.\n\nOutput specification:\n- For each test case, output the list of all verified fixed points, where each fixed point is represented as a list of integers corresponding to $(x_1,\\dots,x_n)$ with entries in $\\{0,1\\}$. Sort the fixed points lexicographically in ascending order.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result\\_A,result\\_B,result\\_C]$), where $result\\_A$, $result\\_B$, and $result\\_C$ are the lists of fixed points for Cases A, B, and C, respectively.\n\nThere are no physical units, angles, or percentages in this problem. All outputs must be lists of integers or lists of such lists. The program must run without any user input and must include the test suite internally.",
            "solution": "The problem requires finding all fixed points of several given synchronous Boolean networks. A fixed point is a state vector $x \\in \\{0,1\\}^n$ such that $x = f(x)$, where $f: \\{0,1\\}^n \\rightarrow \\{0,1\\}^n$ is the network's synchronous update rule. This condition is equivalent to a system of $n$ simultaneous Boolean equations: $x_i = f_i(x_1, \\dots, x_n)$ for each gene $i \\in \\{1, \\dots, n\\}$. The task is to solve this system by first converting it into a Boolean Satisfiability (SAT) problem in Conjunctive Normal Form (CNF) and then using a complete SAT solver to find all satisfying assignments for the variables $(x_1, \\dots, x_n)$.\n\nThe overall methodology is composed of three main stages:\n1.  **SAT Encoding**: The system of equations $x_i = f_i(x)$ is converted into a single Boolean formula in CNF.\n2.  **SAT Solving**: A complete SAT solver, based on the Davis-Putnam-Logemann-Loveland (DPLL) algorithm, is implemented to find all satisfying assignments for the CNF formula.\n3.  **Verification**: The solutions found by the SAT solver are verified by direct substitution into the original Boolean functions $f_i(x)$ to ensure they are indeed fixed points.\n\nThe detailed, principled steps are as follows:\n\n**1. SAT Encoding via Tseitin Transformation**\n\nThe core of the problem is to find assignments that satisfy the logical bi-implication $x_i \\leftrightarrow f_i(x)$ for all $i = 1, \\dots, n$. The expressions for $f_i(x)$ can be arbitrarily complex combinations of Boolean operators ($\\land$, $\\lor$, $\\neg$, $\\oplus$). To convert these into CNF, we use the Tseitin transformation. This standard technique introduces new auxiliary variables to represent the output of each sub-expression and adds clauses that enforce the logical equivalence. The result is an equisatisfiable formula in CNF whose size is linear in the size of the original formula.\n\nFirst, we represent each function $f_i(x)$ as an expression tree, where leaves are variables ($x_j$) or constants ($0$ or $1$) and internal nodes are operators. The transformation is applied recursively on this tree.\n\nFor each sub-expression $s$, we introduce a new auxiliary variable $z_s$. We then generate clauses that enforce the equivalence $z_s \\leftrightarrow s$. The standard CNF conversions for the required operators are:\n-   **Negation**: For an expression $s = \\neg a$, the equivalence $z_s \\leftrightarrow \\neg a$ is encoded as $(\\neg z_s \\lor \\neg a) \\land (z_s \\lor a)$.\n-   **Conjunction (AND)**: For $s = a \\land b$, the equivalence $z_s \\leftrightarrow (a \\land b)$ is encoded as $(\\neg z_s \\lor a) \\land (\\neg z_s \\lor b) \\land (z_s \\lor \\neg a \\lor \\neg b)$.\n-   **Disjunction (OR)**: For $s = a \\lor b$, the equivalence $z_s \\leftrightarrow (a \\lor b)$ is encoded as $(\\neg z_s \\lor a \\lor b) \\land (z_s \\lor \\neg a) \\land (z_s \\lor \\neg b)$.\n-   **Exclusive OR (XOR)**: For $s = a \\oplus b$, the equivalence $z_s \\leftrightarrow (a \\oplus b)$ is encoded as $(\\neg z_s \\lor a \\lor b) \\land (\\neg z_s \\lor \\neg a \\lor \\neg b) \\land (z_s \\lor a \\lor \\neg b) \\land (z_s \\lor \\neg a \\lor b)$.\n\nThis process is applied to all sub-expressions within each $f_i(x)$. Let $z_i$ be the auxiliary variable corresponding to the root of the expression tree for $f_i(x)$. The final step is to enforce the fixed point condition itself, $x_i \\leftrightarrow f_i(x)$, which becomes $x_i \\leftrightarrow z_i$. This is encoded into CNF as $(\\neg x_i \\lor z_i) \\land (x_i \\lor \\neg z_i)$.\n\nThe collection of all clauses generated for all $f_i(x)$ and all fixed point conditions $x_i \\leftrightarrow z_i$ forms the final CNF formula. Variables are represented as integers, where a positive integer $k$ represents the variable $v_k$ and a negative integer $-k$ represents its negation $\\neg v_k$. A clause is a list of integers, and the CNF formula is a list of such clauses.\n\n**2. Complete SAT Solver (DPLL Algorithm)**\n\nTo find all satisfying assignments, we implement a complete SAT solver based on the DPLL algorithm. The algorithm systematically explores the space of possible variable assignments using a backtracking search. Its core components are:\n-   **Unit Propagation**: The algorithm repeatedly scans the CNF formula for \"unit clauses\" (clauses with only one unassigned literal). If a unit clause $(l)$ is found, the literal $l$ must be true for the whole formula to be satisfied. The variable corresponding to $l$ is assigned a value, and the formula is simplified:\n    1.  All clauses containing $l$ are satisfied and can be removed.\n    2.  In all clauses containing $\\neg l$, the literal $\\neg l$ is false and can be removed, shortening the clause.\n    This process is repeated until no more unit clauses can be found. If at any point an empty clause is generated (e.g., by simplifying $(l)$ and $(\\neg l)$), it signifies a contradiction, and the current assignment path is unsatisfiable.\n-   **Branching (Splitting Rule)**: If unit propagation terminates and the formula is neither satisfied (empty set of clauses) nor determined to be unsatisfiable (contains an empty clause), an unassigned variable is chosen. The algorithm then recursively branches, trying both possible assignments (true and false) for the chosen variable.\n    -   First, it assumes the variable is true and calls itself on the simplified formula.\n    -   Then, it assumes the variable is false and does the same.\n\nTo find all solutions, the search does not terminate upon finding the first one. Instead, when a satisfying assignment is found, it is recorded, and the algorithm backtracks to explore other branches of the search tree. The final output of the solver is a list of all complete assignments for the original variables $(x_1, \\dots, x_n)$ that satisfy the CNF formula.\n\n**3. Verification**\n\nAs required by the problem statement, a final verification step is performed. Each satisfying assignment for $(x_1, \\dots, x_n)$ found by the SAT solver is substituted back into the original, non-transformed Boolean functions $f_i(x)$. We compute the vector $f(x) = (f_1(x), \\dots, f_n(x))$ and check if the equality $x = f(x)$ holds. Only the assignments that pass this verification are considered true fixed points. This step acts as a safeguard, ensuring the correctness of both the Tseitin transformation and the SAT solver implementation. The verified fixed points for each test case are then sorted lexicographically.",
            "answer": "```python\nimport numpy as np\nimport copy\nfrom itertools import chain\n\n# Note: numpy and scipy are permitted but not strictly necessary for this logic.\n# They are included to adhere to the execution environment specification.\n\nclass Expr:\n    \"\"\"Base class for Boolean expressions.\"\"\"\n    def __init__(self):\n        pass\n\nclass Var(Expr):\n    \"\"\"Represents a variable, e.g., x_i.\"\"\"\n    def __init__(self, index):\n        super().__init__()\n        self.index = index\n    def __repr__(self):\n        return f\"x{self.index}\"\n    def eval(self, assignment):\n        return assignment[self.index - 1]\n\nclass Const(Expr):\n    \"\"\"Represents a constant value (0 or 1).\"\"\"\n    def __init__(self, value):\n        super().__init__()\n        assert value in (0, 1)\n        self.value = value\n    def __repr__(self):\n        return str(self.value)\n    def eval(self, assignment):\n        return self.value\n\nclass Not(Expr):\n    \"\"\"Represents logical NOT.\"\"\"\n    def __init__(self, operand):\n        super().__init__()\n        self.operand = operand\n    def __repr__(self):\n        return f\"~({self.operand})\"\n    def eval(self, assignment):\n        return 1 - self.operand.eval(assignment)\n\nclass BinOp(Expr):\n    \"\"\"Base class for binary operations.\"\"\"\n    def __init__(self, left, right):\n        super().__init__()\n        self.left = left\n        self.right = right\n\nclass And(BinOp):\n    \"\"\"Represents logical AND.\"\"\"\n    def __repr__(self):\n        return f\"({self.left} & {self.right})\"\n    def eval(self, assignment):\n        return self.left.eval(assignment) & self.right.eval(assignment)\n\nclass Or(BinOp):\n    \"\"\"Represents logical OR.\"\"\"\n    def __repr__(self):\n        return f\"({self.left} | {self.right})\"\n    def eval(self, assignment):\n        return self.left.eval(assignment) | self.right.eval(assignment)\n\nclass Xor(BinOp):\n    \"\"\"Represents logical XOR.\"\"\"\n    def __repr__(self):\n        return f\"({self.left} ^ {self.right})\"\n    def eval(self, assignment):\n        return self.left.eval(assignment) ^ self.right.eval(assignment)\n\nclass TseitinTransformer:\n    \"\"\"\n    Transforms Boolean expressions into CNF using Tseitin's algorithm.\n    \"\"\"\n    def __init__(self, n_vars):\n        self.n_vars = n_vars\n        self.next_aux_var = n_vars + 1\n        self.clauses = []\n        self.memo = {}\n\n    def _get_aux_var(self):\n        var = self.next_aux_var\n        self.next_aux_var += 1\n        return var\n\n    def transform(self, expr):\n        \"\"\"Recursively transform an expression tree into CNF clauses.\"\"\"\n        if expr in self.memo:\n            return self.memo[expr]\n            \n        if isinstance(expr, Var):\n            return expr.index\n        if isinstance(expr, Const):\n            aux = self._get_aux_var()\n            if expr.value == 1:\n                self.clauses.append([aux])\n            else:\n                self.clauses.append([-aux])\n            return aux\n\n        if isinstance(expr, Not):\n            a = self.transform(expr.operand)\n            z = self._get_aux_var()\n            # z <-> ~a  <=> (~z v ~a) & (z v a)\n            self.clauses.extend([[-z, -a], [z, a]])\n            self.memo[expr] = z\n            return z\n\n        if isinstance(expr, BinOp):\n            a = self.transform(expr.left)\n            b = self.transform(expr.right)\n            z = self._get_aux_var()\n            if isinstance(expr, And):\n                # z <-> a & b <=> (~z v a) & (~z v b) & (z v ~a v ~b)\n                self.clauses.extend([[-z, a], [-z, b], [z, -a, -b]])\n            elif isinstance(expr, Or):\n                # z <-> a | b <=> (~z v a v b) & (z v ~a) & (z v ~b)\n                self.clauses.extend([[-z, a, b], [z, -a], [z, -b]])\n            elif isinstance(expr, Xor):\n                # z <-> a ^ b <=> (~z v a v b) & (~z v ~a v ~b) & (z v a v ~b) & (z v ~a v b)\n                self.clauses.extend([[-z, a, b], [-z, -a, -b], [z, a, -b], [z, -a, b]])\n            self.memo[expr] = z\n            return z\n\nclass SATSolver:\n    \"\"\"\n    A complete DPLL-based SAT solver to find all satisfying assignments.\n    \"\"\"\n    def __init__(self, n_vars, clauses):\n        self.n_vars = n_vars\n        self.clauses = clauses\n        self.solutions = []\n\n    def solve(self):\n        self.solutions = []\n        self._solve_recursive(copy.deepcopy(self.clauses), {})\n        # Filter for unique solutions of original variables and convert to 0/1 list format.\n        unique_assignments = set()\n        for sol_map in self.solutions:\n            assignment = []\n            for i in range(1, self.n_vars + 1):\n                assignment.append(1 if sol_map.get(i, True) else 0)\n            unique_assignments.add(tuple(assignment))\n        \n        # Sort lexicographically\n        sorted_solutions = sorted([list(s) for s in unique_assignments])\n        return sorted_solutions\n\n    def _solve_recursive(self, clauses, assignment):\n        clauses, assignment, conflict = self._unit_propagate(clauses, assignment)\n\n        if conflict:\n            return\n\n        if not clauses:\n            self.solutions.append(assignment)\n            return\n\n        var = self._choose_variable(clauses, assignment)\n        if var == 0: # All variables assigned\n            self.solutions.append(assignment)\n            return\n            \n        # Branch on var = True\n        new_clauses_true = copy.deepcopy(clauses)\n        new_assignment_true = assignment.copy()\n        new_clauses_true.append([var])\n        self._solve_recursive(new_clauses_true, new_assignment_true)\n\n        # Branch on var = False\n        new_clauses_false = copy.deepcopy(clauses)\n        new_assignment_false = assignment.copy()\n        new_clauses_false.append([-var])\n        self._solve_recursive(new_clauses_false, new_assignment_false)\n\n    def _unit_propagate(self, clauses, assignment):\n        while True:\n            unit_literals = set()\n            for clause in clauses:\n                if len(clause) == 1:\n                    unit_literals.add(clause[0])\n\n            if not unit_literals:\n                break\n            \n            literal = unit_literals.pop()\n            var = abs(literal)\n            val = literal > 0\n            \n            if var in assignment and assignment[var] != val:\n                return None, None, True # Conflict\n\n            assignment[var] = val\n            \n            new_clauses = []\n            for clause in clauses:\n                new_clause = []\n                is_satisfied = False\n                for lit in clause:\n                    v = abs(lit)\n                    v_val = lit > 0\n                    if v == var:\n                        if v_val == val:\n                            is_satisfied = True\n                            break\n                    else: # Not the assigned var\n                        new_clause.append(lit)\n                if is_satisfied:\n                    continue\n                if not new_clause:\n                    return None, None, True # Conflict\n                new_clauses.append(new_clause)\n            clauses = new_clauses\n            \n        return clauses, assignment, False\n\n    def _choose_variable(self, clauses, assignment):\n        all_vars = set(abs(lit) for lit in chain.from_iterable(clauses))\n        for var in all_vars:\n            if var not in assignment:\n                return var\n        return 0\n\n\ndef solve():\n    # Define test cases\n    v = {i: Var(i) for i in range(1, 5)}\n\n    test_cases = [\n        {\n            \"n\": 3,\n            \"functions\": [\n                And(v[2], Not(v[3])),\n                Or(v[1], v[3]),\n                And(Not(v[1]), Not(v[2]))\n            ]\n        },\n        {\n            \"n\": 4,\n            \"functions\": [\n                v[1],\n                Not(v[2]),\n                Const(1),\n                Const(0)\n            ]\n        },\n        {\n            \"n\": 4,\n            \"functions\": [\n                v[2],\n                v[1],\n                v[3],\n                Xor(v[1], v[2])\n            ]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N = case[\"n\"]\n        functions = case[\"functions\"]\n        \n        # 1. SAT Encoding\n        transformer = TseitinTransformer(N)\n        all_clauses = []\n        \n        for i in range(N):\n            fi_expr = functions[i]\n            # Get clauses for the function expression f_i\n            transformer.memo = {}\n            z_i = transformer.transform(fi_expr)\n            all_clauses.extend(transformer.clauses)\n            transformer.clauses = []\n            \n            # Add clauses for the fixed point condition: x_i <-> f_i\n            # which is x_i <-> z_i, where z_i is the aux var for f_i.\n            # ( -x_i V z_i ) & ( x_i V -z_i )\n            x_i_literal = i + 1\n            all_clauses.extend([[-x_i_literal, z_i], [x_i_literal, -z_i]])\n        \n        # 2. SAT Solving\n        num_total_vars = transformer.next_aux_var - 1\n        solver = SATSolver(N, all_clauses)\n        candidate_solutions = solver.solve()\n        \n        # 3. Verification\n        verified_fixed_points = []\n        for sol in candidate_solutions:\n            x = tuple(sol)\n            fx = []\n            for i in range(N):\n                fx.append(functions[i].eval(x))\n            \n            if x == tuple(fx):\n                verified_fixed_points.append(list(x))\n        \n        all_results.append(verified_fixed_points)\n\n    # Final print statement in the exact required format\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```"
        }
    ]
}