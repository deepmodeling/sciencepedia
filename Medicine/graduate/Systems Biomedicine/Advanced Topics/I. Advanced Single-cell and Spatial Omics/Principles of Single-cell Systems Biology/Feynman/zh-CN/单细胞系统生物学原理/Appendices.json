{
    "hands_on_practices": [
        {
            "introduction": "在开始一项昂贵的单细胞测序实验之前，一个关键的初步步骤是确定所需的实验规模。当目标是表征稀有细胞群体时，这一点尤其重要。\n\n本练习将引导您从第一性原理出发，回答一个基本问题：“我必须对多少细胞进行测序，才能有很高的概率检测到我感兴趣的细胞类型？” \n\n通过将细胞捕获过程建模为一系列独立的伯努利试验（Bernoulli trials），您将构建一个用于实验设计的定量框架，这项技能对于有效分配研究资源至关重要。",
            "id": "4377566",
            "problem": "一项单细胞RNA测序（scRNA-seq）实验旨在检测一个大型、充分混合组织中以群体频率 $f$ 存在的稀有细胞类型。假设以下条件成立：每个捕获的细胞是一个独立的、同分布的伯努利试验，判断其是否为稀有细胞类型的成功概率为 $f$；采样相对于细胞类型是无偏的；对捕获的稀有细胞的分类是完美的。仅从这些假设和独立伯努利试验的基本概率原理出发，推导当采样 $N$ 个细胞时，检测到至少一个稀有细胞的概率，并将其表示为 $f$ 和 $N$ 的函数。然后，通过反转您的表达式，推导出使检测概率至少达到用户指定目标 $P^{\\star}$（其中 $0  P^{\\star}  1$）的最小整数 $N$ 的解析表达式。最后，对 $f = 7 \\times 10^{-5}$ 和 $P^{\\star} = 0.975$ 计算您的表达式，并报告满足该标准的最小整数 $N$。以无单位的整数形式提供最终的 $N$。由于所要求的 $N$ 是一个整数，因此无需按有效数字进行四舍五入。",
            "solution": "首先将根据所需标准对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n-   稀有细胞类型的群体频率：$f$\n-   每个捕获的细胞是一个独立的、同分布的（i.i.d.）伯努利试验，判断其是否为稀有细胞类型的成功概率为 $f$。\n-   采样相对于细胞类型是无偏的。\n-   对捕获的稀有细胞的分类是完美的。\n-   采样的细胞总数：$N$\n-   目标检测概率：$P^{\\star}$\n-   目标概率的约束条件：$0  P^{\\star}  1$\n-   频率的数值：$f = 7 \\times 10^{-5}$\n-   目标概率的数值：$P^{\\star} = 0.975$\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据：** 该问题牢固地基于概率论，特别是从独立同分布（i.i.d.）的伯努利试验中推导出的二项分布。这是设计单细胞测序实验以估计检测稀有群体所需样本量的标准和基本模型。这些假设（无偏采样、完美分类）是理想化的情况，但它们是构建基线模型的标准做法。\n-   **适定性：** 该问题是适定的。它要求推导一个概率，反转该公式以找到最小样本量，并进行特定的数值计算。所有必要的参数（$f$, $P^{\\star}$）都已提供，目标明确，从而可以得出一个唯一的、稳定的且有意义的解。\n-   **客观性：** 语言正式、精确，没有主观或基于观点的陈述。\n-   **其他缺陷：** 该问题没有表现出任何其他缺陷，如不完整、矛盾、不切实际、不适定或琐碎。所提供的值在此类生物实验的实际范围内。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解答。\n\n### 解题推导\n\n设捕获一个稀有细胞的事件为“成功”，捕获一个普通细胞的事件为“失败”。根据问题陈述，在 $N$ 次细胞捕获中，每一次都是一个独立的伯努利试验，成功概率为 $f$。\n\n设 $X$ 为在一个包含 $N$ 个细胞的样本中检测到的稀有细胞数量的随机变量。在给定假设下，$X$ 服从参数为 $N$（试验次数）和 $f$（成功概率）的二项分布。其概率质量函数由下式给出：\n$$P(X=k) = \\binom{N}{k} f^k (1-f)^{N-k}$$\n对于 $k \\in \\{0, 1, 2, ..., N\\}$。\n\n问题要求的是检测到*至少一个*稀有细胞的概率。这是事件 $\\{X \\ge 1\\}$。计算其互补事件，即检测到*零*个稀有细胞（即 $\\{X=0\\}$）的概率，然后从 1 中减去这个概率，会更直接。\n\n检测到零个稀有细胞的概率是：\n$$P(X=0) = \\binom{N}{0} f^0 (1-f)^{N-0}$$\n由于 $\\binom{N}{0} = 1$ 且 $f^0 = 1$，上式简化为：\n$$P(X=0) = (1-f)^N$$\n因此，检测到至少一个稀有细胞的概率，我们记为 $P_{\\text{detect}}(N, f)$，是：\n$$P_{\\text{detect}}(N, f) = P(X \\ge 1) = 1 - P(X=0) = 1 - (1-f)^N$$\n这就是作为 $f$ 和 $N$ 的函数的检测概率的表达式。\n\n接下来，我们必须找到使检测概率至少达到用户指定目标 $P^{\\star}$ 的最小整数 $N$。我们建立不等式：\n$$P_{\\text{detect}}(N, f) \\ge P^{\\star}$$\n$$1 - (1-f)^N \\ge P^{\\star}$$\n重新整理不等式以求解 $N$：\n$$1 - P^{\\star} \\ge (1-f)^N$$\n问题陈述 $0  P^{\\star}  1$，这意味着 $0  1 - P^{\\star}  1$。同样，由于 $f$ 是一个群体频率，我们假设 $0  f  1$，这意味着 $0  1-f  1$。由于不等式两边都为正，我们可以对两边取自然对数。自然对数是一个严格递增函数，因此不等号的方向保持不变：\n$$\\ln(1 - P^{\\star}) \\ge \\ln((1-f)^N)$$\n使用对数运算法则 $\\ln(a^b) = b\\ln(a)$：\n$$\\ln(1 - P^{\\star}) \\ge N \\ln(1-f)$$\n为了分离出 $N$，我们必须除以 $\\ln(1-f)$。由于 $0  1-f  1$，其对数 $\\ln(1-f)$ 是一个负数。不等式两边同除以一个负数会反转不等号的方向：\n$$\\frac{\\ln(1 - P^{\\star})}{\\ln(1-f)} \\le N$$\n这可以写成：\n$$N \\ge \\frac{\\ln(1 - P^{\\star})}{\\ln(1-f)}$$\n问题要求满足此条件的最小*整数* $N$。右侧的表达式是所需的最小样本量，它可能不是一个整数。因此，最小整数 $N$ 必须是该值的向上取整（ceiling）。\n最小整数 $N$ 的解析表达式是：\n$$N = \\left\\lceil \\frac{\\ln(1 - P^{\\star})}{\\ln(1-f)} \\right\\rceil$$\n\n最后，我们用给定的数值 $f = 7 \\times 10^{-5}$ 和 $P^{\\star} = 0.975$ 来计算这个表达式。\n\n首先，我们计算对数内的项：\n$$1 - P^{\\star} = 1 - 0.975 = 0.025$$\n$$1 - f = 1 - 7 \\times 10^{-5} = 1 - 0.00007 = 0.99993$$\n\n现在，我们将这些值代入关于 $N$ 的不等式中：\n$$N \\ge \\frac{\\ln(0.025)}{\\ln(0.99993)}$$\n使用计算器计算对数值：\n$$\\ln(0.025) \\approx -3.68887945411$$\n$$\\ln(0.99993) \\approx -0.0000700024501$$\n现在我们计算这个比率：\n$$N \\ge \\frac{-3.68887945411}{-0.0000700024501} \\approx 52696.0906$$\n满足此条件的最小整数 $N$ 是该值的向上取整：\n$$N = \\lceil 52696.0906 \\rceil = 52697$$\n因此，必须至少采样 $52697$ 个细胞，才能确保检测到至少一个稀有细胞的概率不低于 $0.975$。",
            "answer": "$$\\boxed{52697}$$"
        },
        {
            "introduction": "基于液滴的单细胞技术功能强大，但也容易受到一种常见技术赝像的影响，即“双细胞”（doublets），也就是两个细胞被捕获在同一个液滴中。这些技术赝像会严重扭曲下游分析，例如对细胞类型比例的估计。\n\n本实践从两个角度探讨双细胞的影响。首先，您将建立一个概率模型，以量化双细胞在细胞类型丰度估计中引入的偏差。其次，您将应用统计决策理论的原理来优化双细胞检测的阈值，从而在精确率（precision）和召回率（recall）之间取得平衡 。\n\n掌握这些概念将使您能够批判性地评估数据质量，并实施稳健的策略来减轻技术赝像在您自己分析中的混杂效应。",
            "id": "4377572",
            "problem": "一个基于液滴的单细胞核糖核酸测序 (scRNA-seq) 实验对一个由两种细胞类型（记为 $A$ 和 $B$）组成的异质细胞群体进行采样，其真实比例分别为 $p_A$ 和 $p_B = 1 - p_A$。捕获的条形码中有比例为 $\\delta$ 的部分源于双联体，双联体是由两个独立采样的细胞配对形成的。因此，双联体类型的频率为：$A{+}A$ 的概率为 $p_A^2$，$A{+}B$ 的概率为 $2 p_A p_B$，$B{+}B$ 的概率为 $p_B^2$。一个朴素的细胞类型分配分类器，如果一个内部标记分数超过其对应值，则将一个条形码标记为 $A$ 类；对于双联体，规则如下：$A{+}A$ 总是被标记为 $A$，$B{+}B$ 总是被标记为 $B$，而 $A{+}B$ 以概率 $q$ 被标记为 $A$，以概率 $1 - q$ 被标记为 $B$。假设分类器在处理单联体方面是完美的。\n\n第 1 部分 (比例影响)：根据上述生成模型和分配规则，从第一性原理推导类型 $A$ 的期望观测比例（记为 $\\hat{p}_A^{\\mathrm{obs}}$）的解析表达式。然后，用 $p_A$、$\\delta$ 和 $q$ 表示偏差 $\\Delta_A = \\hat{p}_A^{\\mathrm{obs}} - p_A$。计算当 $p_A = 0.65$、$\\delta = 0.12$ 和 $q = 0.75$ 时 $\\Delta_A$ 的值。将 $\\Delta_A$ 表示为小数，并将您的数值答案四舍五入到四位有效数字。\n\n第 2 部分 (优化精确率-召回率的双联体检测阈值)：对于每个条形码，从文库大小和共表达等聚合特征中计算出一个双联体检测分数 $s$。将以条形码类型为条件的分数建模为指数分布：$s \\mid \\mathrm{doublet} \\sim \\mathrm{Exp}(\\lambda_D)$ 和 $s \\mid \\mathrm{singlet} \\sim \\mathrm{Exp}(\\lambda_S)$，定义在 $[0,\\infty)$ 上，其中 $\\lambda_S > \\lambda_D$。设双联体的先验概率为 $\\pi_D \\in (0,1)$。考虑一个阈值规则，当且仅当 $s > t$ 时，预测为双联体。使用精确率 (precision) 和召回率 (recall) 的标准定义以及称为 $F_1$-score 的调和平均数，推导出使 $F_1$-score 最大化的阈值 $t^{\\star}$ 的闭式表达式，该表达式用 $\\pi_D$、$\\lambda_D$ 和 $\\lambda_S$ 表示。然后，当 $\\lambda_D = 0.5$、$\\lambda_S = 1.5$ 和 $\\pi_D = 0.10$ 时，对 $t^{\\star}$ 进行数值计算，并将您的数值答案四舍五入到四位有效数字。\n\n将您的最终答案以单行矩阵的形式报告，其中包含 $\\Delta_A$ 和 $t^{\\star}$ 这两个量，并按此顺序排列。这些答案无需物理单位。",
            "solution": "该问题被评估为有效，因为它科学地基于单细胞基因组学和统计分类的原理，数学上是适定的，有足够的信息得到唯一解，并且陈述客观。我们着手解决这两个部分。\n\n第 1 部分：偏差 $\\Delta_A$ 的推导\n\n设 $\\hat{p}_A^{\\mathrm{obs}}$ 为被分类为类型 $A$ 的细胞的观测比例。这是随机选择一个条形码被分类为类型 $A$ 的概率。我们可以根据条形码是单联体还是双联体的情况，使用全概率定律来表达这个概率。\n\n来自单联体的条形码比例为 $1-\\delta$，来自双联体的比例为 $\\delta$。因此，\n$$\n\\hat{p}_A^{\\mathrm{obs}} = P(\\text{classified as } A) = P(\\text{classified as } A \\mid \\text{singlet}) P(\\text{singlet}) + P(\\text{classified as } A \\mid \\text{doublet}) P(\\text{doublet})\n$$\n$$\n\\hat{p}_A^{\\mathrm{obs}} = P(A_{\\mathrm{obs}} \\mid S)(1-\\delta) + P(A_{\\mathrm{obs}} \\mid D)\\delta\n$$\n首先，考虑单联体。一个单联体是从真实比例为 $p_A$ 和 $p_B$ 的群体中抽取的。分类器对单联体是完美的。\n$$\nP(A_{\\mathrm{obs}} \\mid S) = P(A_{\\mathrm{obs}} \\mid \\text{true cell is } A) P(\\text{true cell is } A) + P(A_{\\mathrm{obs}} \\mid \\text{true cell is } B) P(\\text{true cell is } B)\n$$\n在这里，$P(\\text{true cell is } A) = p_A$ 且 $P(\\text{true cell is } B) = p_B$。由于分类器对单联体是完美的，所以 $P(A_{\\mathrm{obs}} \\mid \\text{true cell is } A) = 1$ 且 $P(A_{\\mathrm{obs}} \\mid \\text{true cell is } B) = 0$。\n$$\nP(A_{\\mathrm{obs}} \\mid S) = (1)(p_A) + (0)(p_B) = p_A\n$$\n接下来，考虑双联体。问题陈述了双联体类型的概率为 $P(A{+}A) = p_A^2$，$P(A{+}B) = 2p_A p_B$ 和 $P(B{+}B) = p_B^2$。双联体的分类规则已给出。\n$$\nP(A_{\\mathrm{obs}} \\mid D) = P(A_{\\mathrm{obs}} \\mid A{+}A)P(A{+}A) + P(A_{\\mathrm{obs}} \\mid A{+}B)P(A{+}B) + P(A_{\\mathrm{obs}} \\mid B{+}B)P(B{+}B)\n$$\n代入给定的概率：$P(A_{\\mathrm{obs}} \\mid A{+}A)=1$，$P(A_{\\mathrm{obs}} \\mid A{+}B)=q$ 和 $P(A_{\\mathrm{obs}} \\mid B{+}B)=0$。\n$$\nP(A_{\\mathrm{obs}} \\mid D) = (1)(p_A^2) + (q)(2p_A p_B) + (0)(p_B^2) = p_A^2 + 2q p_A p_B\n$$\n现在，我们将这些代回到 $\\hat{p}_A^{\\mathrm{obs}}$ 的表达式中。\n$$\n\\hat{p}_A^{\\mathrm{obs}} = p_A(1-\\delta) + (p_A^2 + 2q p_A p_B)\\delta\n$$\n偏差定义为 $\\Delta_A = \\hat{p}_A^{\\mathrm{obs}} - p_A$。\n$$\n\\Delta_A = [p_A(1-\\delta) + (p_A^2 + 2q p_A p_B)\\delta] - p_A\n$$\n$$\n\\Delta_A = p_A - p_A\\delta + p_A^2\\delta + 2q p_A p_B \\delta - p_A\n$$\n$$\n\\Delta_A = - p_A\\delta + p_A^2\\delta + 2q p_A p_B \\delta\n$$\n我们可以提出公因子 $\\delta p_A$：\n$$\n\\Delta_A = \\delta p_A (-1 + p_A + 2q p_B)\n$$\n代入 $p_B = 1-p_A$：\n$$\n\\Delta_A = \\delta p_A (-1 + p_A + 2q(1-p_A))\n$$\n$$\n\\Delta_A = \\delta p_A (-1 + p_A + 2q - 2q p_A)\n$$\n$$\n\\Delta_A = \\delta p_A ((p_A - 2q p_A) + (2q - 1))\n$$\n$$\n\\Delta_A = \\delta p_A (p_A(1 - 2q) - (1 - 2q))\n$$\n$$\n\\Delta_A = \\delta p_A (1-p_A)(-(1-2q)) = \\delta p_A (1-p_A)(2q-1) = \\delta p_A p_B (2q-1)\n$$\n对于数值计算，给定 $p_A = 0.65$，$\\delta = 0.12$ 和 $q = 0.75$。\n首先，$p_B = 1 - p_A = 1 - 0.65 = 0.35$。\n然后，$2q-1 = 2(0.75) - 1 = 1.5 - 1 = 0.5$。\n将这些值代入 $\\Delta_A$ 的表达式中：\n$$\n\\Delta_A = (0.12)(0.65)(0.35)(0.5) = 0.01365\n$$\n这个值有四位有效数字，因此无需四舍五入。\n\n第 2 部分：最优阈值 $t^{\\star}$ 的推导\n\n我们要找到使 $F_1$-score 最大化的阈值 $t$。$F_1$-score 是精确率 $P$ 和召回率 $R$ 的调和平均数：$F_1 = 2 \\frac{PR}{P+R}$。\n\n首先，我们将精确率和召回率定义为阈值 $t$ 的函数。正类是“双联体”。\n分数分布为 $s \\mid \\mathrm{doublet} \\sim \\mathrm{Exp}(\\lambda_D)$ 和 $s \\mid \\mathrm{singlet} \\sim \\mathrm{Exp}(\\lambda_S)$。指数分布 $\\mathrm{Exp}(\\lambda)$ 的生存函数为 $S(t) = P(s > t) = \\exp(-\\lambda t)$。\n\n设 $\\pi_D$ 为一个条形码是双联体的先验概率。对于一个阈值 $t$，真阳性 ($TP$)、假阳性 ($FP$) 和假阴性 ($FN$) 的数量与以下成正比：\n$$\nP(\\text{TP}; t) = P(s>t \\mid \\text{doublet})P(\\text{doublet}) = \\pi_D \\exp(-\\lambda_D t)\n$$\n$$\nP(\\text{FP}; t) = P(s>t \\mid \\text{singlet})P(\\text{singlet}) = (1-\\pi_D) \\exp(-\\lambda_S t)\n$$\n$$\nP(\\text{FN}; t) = P(s \\le t \\mid \\text{doublet})P(\\text{doublet}) = \\pi_D (1 - \\exp(-\\lambda_D t))\n$$\n召回率 $R(t)$ 是真阳性率：\n$$\nR(t) = \\frac{P(\\text{TP}; t)}{P(\\text{TP}; t) + P(\\text{FN}; t)} = \\frac{\\pi_D \\exp(-\\lambda_D t)}{\\pi_D \\exp(-\\lambda_D t) + \\pi_D (1 - \\exp(-\\lambda_D t))} = \\exp(-\\lambda_D t)\n$$\n精确率 $P(t)$ 是阳性预测值：\n$$\nP(t) = \\frac{P(\\text{TP}; t)}{P(\\text{TP}; t) + P(\\text{FP}; t)} = \\frac{\\pi_D \\exp(-\\lambda_D t)}{\\pi_D \\exp(-\\lambda_D t) + (1-\\pi_D) \\exp(-\\lambda_S t)}\n$$\n$F_1$-score 可以写为：\n$$\nF_1(t) = \\frac{2 P(\\text{TP}; t)}{2 P(\\text{TP}; t) + P(\\text{FP}; t) + P(\\text{FN}; t)} = \\frac{2 \\pi_D \\exp(-\\lambda_D t)}{2\\pi_D \\exp(-\\lambda_D t) + (1-\\pi_D) \\exp(-\\lambda_S t) + \\pi_D(1-\\exp(-\\lambda_D t))}\n$$\n$$\nF_1(t) = \\frac{2 \\pi_D \\exp(-\\lambda_D t)}{\\pi_D + \\pi_D \\exp(-\\lambda_D t) + (1-\\pi_D) \\exp(-\\lambda_S t)}\n$$\n为了最大化 $F_1(t)$，我们可以对 $t$ 求导并令其导数为 0。我们忽略分子中的常数因子 $2\\pi_D$，转而最大化 $G(t) = \\frac{\\exp(-\\lambda_D t)}{\\pi_D + \\pi_D \\exp(-\\lambda_D t) + (1-\\pi_D) \\exp(-\\lambda_S t)}$。\n使用商法则 $(u/v)' = (u'v - uv')/v^2=0$，这意味着 $u'v - uv' = 0$。\n设 $u(t) = \\exp(-\\lambda_D t)$ 和 $v(t) = \\pi_D + \\pi_D \\exp(-\\lambda_D t) + (1-\\pi_D) \\exp(-\\lambda_S t)$。\n导数分别为 $u'(t) = -\\lambda_D \\exp(-\\lambda_D t)$ 和 $v'(t) = -\\pi_D \\lambda_D \\exp(-\\lambda_D t) - (1-\\pi_D)\\lambda_S \\exp(-\\lambda_S t)$。\n令 $u'v - uv' = 0$：\n$$\n(-\\lambda_D e^{-\\lambda_D t})(\\pi_D + \\pi_D e^{-\\lambda_D t} + (1-\\pi_D)e^{-\\lambda_S t}) - (e^{-\\lambda_D t})(-\\pi_D\\lambda_D e^{-\\lambda_D t} - (1-\\pi_D)\\lambda_S e^{-\\lambda_S t}) = 0\n$$\n两边同除以非零项 $e^{-\\lambda_D t}$：\n$$\n-\\lambda_D(\\pi_D + \\pi_D e^{-\\lambda_D t} + (1-\\pi_D)e^{-\\lambda_S t}) - (-\\pi_D\\lambda_D e^{-\\lambda_D t} - (1-\\pi_D)\\lambda_S e^{-\\lambda_S t}) = 0\n$$\n$$\n-\\lambda_D\\pi_D - \\lambda_D\\pi_D e^{-\\lambda_D t} - \\lambda_D(1-\\pi_D)e^{-\\lambda_S t} + \\pi_D\\lambda_D e^{-\\lambda_D t} + (1-\\pi_D)\\lambda_S e^{-\\lambda_S t} = 0\n$$\n项 $-\\lambda_D\\pi_D e^{-\\lambda_D t}$ 和 $+\\pi_D\\lambda_D e^{-\\lambda_D t}$ 相互抵消。\n$$\n-\\lambda_D\\pi_D + (1-\\pi_D)(\\lambda_S - \\lambda_D)e^{-\\lambda_S t} = 0\n$$\n解出 $e^{-\\lambda_S t}$：\n$$\ne^{-\\lambda_S t} = \\frac{\\lambda_D \\pi_D}{(1-\\pi_D)(\\lambda_S - \\lambda_D)}\n$$\n对等式两边取自然对数：\n$$\n-\\lambda_S t = \\ln\\left(\\frac{\\lambda_D \\pi_D}{(1-\\pi_D)(\\lambda_S - \\lambda_D)}\\right)\n$$\n最优阈值 $t^{\\star}$ 为：\n$$\nt^{\\star} = -\\frac{1}{\\lambda_S}\\ln\\left(\\frac{\\lambda_D \\pi_D}{(1-\\pi_D)(\\lambda_S - \\lambda_D)}\\right) = \\frac{1}{\\lambda_S}\\ln\\left(\\frac{(1-\\pi_D)(\\lambda_S - \\lambda_D)}{\\lambda_D \\pi_D}\\right)\n$$\n对于数值计算，我们使用 $\\lambda_D = 0.5$，$\\lambda_S = 1.5$ 和 $\\pi_D = 0.10$。\n$1-\\pi_D = 0.90$。\n$\\lambda_S - \\lambda_D = 1.5 - 0.5 = 1.0$。\n对数的参数为：\n$$\n\\frac{(1-\\pi_D)(\\lambda_S - \\lambda_D)}{\\lambda_D \\pi_D} = \\frac{(0.90)(1.0)}{(0.5)(0.10)} = \\frac{0.9}{0.05} = 18\n$$\n所以，最优阈值为：\n$$\nt^{\\star} = \\frac{1}{1.5} \\ln(18)\n$$\n计算数值：\n$$\nt^{\\star} \\approx \\frac{2.8903717}{1.5} \\approx 1.9269145\n$$\n四舍五入到四位有效数字得到 $t^{\\star} = 1.927$。\n\n最终答案要求将 $\\Delta_A$ 和 $t^{\\star}$ 两个量放在一个单行矩阵中。\n$$\n\\Delta_A = 0.01365\n$$\n$$\nt^{\\star} = 1.927\n$$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.01365  1.927\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "在初步质量控制之后，必须对单细胞实验的原始计数矩阵进行归一化，以消除技术变异性，并进行处理以识别具有生物学信息的基因。这几乎是所有单细胞分析工作流程中的一个基础步骤。\n\n这项计算练习要求您实现一个用于识别高变异基因（Highly Variable Genes, HVGs）的完整流程。您将从归一化文库大小差异开始，接着应用基于唯一分子标识（UMI）计数负二项（Negative Binomial）分布模型的方差稳定化变换，最后通过基因的残差方差对其进行排序，以找出那些比仅由技术噪音预期的变异性更大的基因 。\n\n通过完成这项任务，您将获得关于驱动现代单细胞分析工具包的统计模型和算法的实践经验，从而将理论理解转化为实际应用。",
            "id": "4377587",
            "problem": "给定一项基于系统生物医学中单细胞系统生物学原理的计算任务：实现一种方法，根据已知的取样深度对独特分子标识符（UMI）计数数据进行归一化，基于一个生成模型执行方差稳定化，并根据跨细胞的残差方差筛选高可变基因（HVG）。\n\n使用的基本和核心定义：\n- 令 $x_{g i}$ 表示基因 $g$ 在细胞 $i$ 中观测到的 UMI 计数。假设一个生成模型，其中 $x_{g i}$ 是一个随机变量，其均值为 $s_i \\mu_g$，其中 $s_i$ 是一个代表细胞 $i$ 取样深度的大小因子，$\\mu_g$ 是基因 $g$ 的期望表达水平。固定离散参数 $\\phi \\ge 0$ 的负二项（NB）模型具有方差\n$$\n\\operatorname{Var}[x_{g i}] = s_i \\mu_g + \\phi (s_i \\mu_g)^2,\n$$\n当 $\\phi = 0$ 时，该模型退化为泊松模型。\n- 已知的文库大小 $L_i$ 与真实的取样深度成正比；使用它们通过将 $L_i$ 重新缩放到一个共同的参考深度来计算大小因子 $s_i$。参考深度必须是 $L_i$ 的一个稳健统计量。\n- 使用上述 NB 均值-方差关系作为方差稳定化和残差分析的基础。\n\n任务要求：\n1. 使用一个稳健的参考值，根据提供的文库大小 $L_i$ 计算大小因子 $s_i$。\n2. 使用有原则的估计方法，从联合模型 $E[x_{g i}] = s_i \\mu_g$ 中直接为每个基因 $g$ 估计 $\\mu_g$。\n3. 以与 NB 均值-方差关系一致的方式，构建数据的方差稳定化残差表示。残差必须按基因进行中心化，并且必须进行缩放以考虑模型下依赖于均值的方差。\n4. 对每个基因，计算其跨细胞的残差方差，并选出残差方差最大的前 $k$ 个基因。如果残差方差出现平局，则通过较小的基因索引来打破平局。对基因使用从零开始的索引。\n\n你的程序必须实现上述流程，并将其应用于以下测试套件。对于每个测试用例，返回所选基因索引（从零开始）的列表，按残差方差从高到低排序（平局打破后），列表长度等于 $k$。\n\n测试套件：\n- 案例 A（一般情况）：\n  - 计数矩阵 $X$（基因 $\\times$ 细胞）：\n    $$\n    X = \\begin{bmatrix}\n    10  15  8  12  11  9 \\\\\n    5  20  6  25  5  23 \\\\\n    50  75  40  60  55  45 \\\\\n    0  1  0  2  0  1 \\\\\n    30  70  24  72  33  63\n    \\end{bmatrix}\n    $$\n  - 文库大小 $L = [1000, 1500, 800, 1200, 1100, 900]$。\n  - 离散度 $\\phi = 0.1$。\n  - HVG 数量 $k = 2$。\n- 案例 B（边界条件，泊松极限和均等深度）：\n  - 计数矩阵 $X$：\n    $$\n    X = \\begin{bmatrix}\n    10  10  10  10 \\\\\n    2  20  1  18 \\\\\n    0  0  0  0 \\\\\n    5  7  6  4\n    \\end{bmatrix}\n    $$\n  - 文库大小 $L = [1000, 1000, 1000, 1000]$。\n  - 离散度 $\\phi = 0$。\n  - HVG 数量 $k = 1$。\n- 案例 C（具有异构深度和接近零计数的基因的边缘情况）：\n  - 计数矩阵 $X$：\n    $$\n    X = \\begin{bmatrix}\n    1  5  0  4  6 \\\\\n    50  210  30  160  260 \\\\\n    8  60  3  40  90 \\\\\n    0  0  0  0  0 \\\\\n    15  30  9  40  35 \\\\\n    0  100  0  150  300\n    \\end{bmatrix}\n    $$\n  - 文库大小 $L = [500, 2000, 300, 1500, 2500]$。\n  - 离散度 $\\phi = 1.0$。\n  - HVG 数量 $k = 2$。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果是一个整数列表，并且输出中不得有任何空格。例如，输出格式必须与\n$$\n[\\,[i_1,i_2],\\,[j_1],\\,[k_1,k_2]\\,]\n$$\n渲染为单行字符串的形式完全一样，无空格：\n\"[[i1,i2],[j1],[k1,k2]]\"。",
            "solution": "该问题提出了一个有效且定义明确的计算任务，其基础是单细胞系统生物学中已确立的原则。它要求实现一个标准工作流程，用于从独特分子标识符（UMI）计数数据中识别高可变基因（HVG）。其模型、方法和数据在科学上是合理的且内部一致。我们采用一种有原则的解决方案。\n\n目标是识别那些在细胞间表现出比特定技术噪声模型预期更大变异性的基因。该模型假设基因 $g$ 在细胞 $i$ 中的 UMI 计数 $x_{gi}$ 服从一个分布，其均值与细胞的取样深度和基因的内在表达水平成正比，即 $E[x_{gi}] = s_i \\mu_g$。方差由负二项（NB）关系给出：$\\operatorname{Var}[x_{gi}] = s_i \\mu_g + \\phi (s_i \\mu_g)^2$。参数 $\\phi$ 控制离散度，捕捉超泊松变异。当 $\\phi=0$ 时，模型简化为泊松分布。\n\n解决方案按照四个要求的任务构建。\n\n### 步骤 1：大小因子计算\n“大小因子” $s_i$ 是归一化常数，用于解释细胞间文库大小或取样深度的差异。它们通过将给定的原始文库大小 $L_i$ 缩放到一个共同的参考尺度来计算。\n\n问题指定使用“稳健统计量”作为参考深度。中位数是此目的的标准选择，因为它对具有极高或极低文库大小的离群细胞不敏感。因此，参考深度 $L_{ref}$ 定义为：\n$$\nL_{ref} = \\operatorname{median}(\\{L_1, L_2, \\ldots, L_{N_c}\\})\n$$\n其中 $N_c$ 是细胞数量。\n\n然后，每个细胞 $i$ 的大小因子计算为其文库大小与参考深度的比率：\n$$\ns_i = \\frac{L_i}{L_{ref}}\n$$\n这确保了具有中位数文库大小的细胞的大小因子为 1，而其他细胞的计数被有效地缩放到这个参考水平。\n\n### 步骤 2：基因表达均值估计\n参数 $\\mu_g$ 代表基因 $g$ 的归一化、内在平均表达水平。模型方程为 $E[x_{gi}] = s_i \\mu_g$。为了从观测数据 $x_{gi}$ 和计算出的大小因子 $s_i$ 中估计 $\\mu_g$，我们可以使用矩估计法。对给定基因 $g$ 在所有细胞上的期望值求和得到：\n$$\n\\sum_{i=1}^{N_c} E[x_{gi}] = \\sum_{i=1}^{N_c} s_i \\mu_g = \\mu_g \\sum_{i=1}^{N_c} s_i\n$$\n根据大数定律，我们可以用观测值的总和来近似期望值的总和，即 $E[\\sum_i x_{gi}] \\approx \\sum_i x_{gi}$。这导出了一个有原则的 $\\mu_g$ 估计量：\n$$\n\\hat{\\mu}_g = \\frac{\\sum_{i=1}^{N_c} x_{gi}}{\\sum_{i=1}^{N_c} s_i}\n$$\n该估计量代表一个基因的总计数，按总有效文库大小进行缩放。如果一个基因在所有细胞中的总计数为零，其估计的平均表达 $\\hat{\\mu}_g$ 将为 0。\n\n### 步骤 3：方差稳定化残差计算\nHVG 检测的核心是区分生物学变异和技术噪声。我们通过计算相对于平均表达水平稳定的残差来实现这一点。皮尔逊残差是用于此目的的合适度量。它被定义为观测计数与期望计数之差，并由模型的期望标准差进行标准化。\n\n首先，我们使用我们的估计值 $\\hat{\\mu}_g$ 和已知的大小因子 $s_i$ 计算每个基因-细胞对的估计期望计数 $\\hat{E}[x_{gi}]$：\n$$\n\\hat{E}[x_{gi}] = s_i \\hat{\\mu}_g\n$$\n接下来，我们将我们的估计均值代入 NB 模型，计算期望方差 $\\widehat{\\operatorname{Var}}[x_{gi}]$：\n$$\n\\widehat{\\operatorname{Var}}[x_{gi}] = s_i \\hat{\\mu}_g + \\phi (s_i \\hat{\\mu}_g)^2 = \\hat{E}[x_{gi}] + \\phi (\\hat{E}[x_{gi}])^2\n$$\n皮尔逊残差 $r_{gi}$ 则是：\n$$\nr_{gi} = \\frac{x_{gi} - \\hat{E}[x_{gi}]}{\\sqrt{\\widehat{\\operatorname{Var}}[x_{gi}]}} = \\frac{x_{gi} - s_i \\hat{\\mu}_g}{\\sqrt{s_i \\hat{\\mu}_g + \\phi (s_i \\hat{\\mu}_g)^2}}\n$$\n这些残差的期望值中心为 0，并且如果数据完美遵循噪声模型，其理论方差将为 1。\n\n当 $\\hat{\\mu}_g = 0$ 时，会出现一个关键的边缘情况。这发生在所有细胞中计数均为零的基因。在这种情况下，期望计数 $\\hat{E}[x_{gi}]$ 和期望方差 $\\widehat{\\operatorname{Var}}[x_{gi}]$ 均为 0。残差公式变为 $\\frac{0-0}{0}$，这是不确定的。然而，正确的物理和统计学解释是，如果一个基因未表达且预期不会被表达，那么它与模型就没有偏差。因此，对于这样的基因，残差 $r_{gi}$ 必须定义为 0。\n\n### 步骤 4：高可变基因筛选\n其表达水平由生物学过程而非仅仅是技术噪声驱动的基因，其残差方差将比模型预测的要大。我们可以通过计算每个基因在所有细胞间的残差样本方差来量化这一点。\n\n对于每个基因 $g$，残差方差 $\\operatorname{Var}_{res}(g)$ 计算为其残差 $\\{r_{g1}, r_{g2}, \\ldots, r_{g,N_c}\\}$ 的无偏样本方差：\n$$\n\\operatorname{Var}_{res}(g) = \\frac{1}{N_c - 1} \\sum_{i=1}^{N_c} (r_{gi} - \\bar{r}_g)^2\n$$\n其中 $\\bar{r}_g = \\frac{1}{N_c} \\sum_{i=1}^{N_c} r_{gi}$ 是基因 $g$ 残差的样本均值。\n\n最后，为了选出前 $k$ 个 HVG，我们执行以下步骤：\n1. 为每个基因创建一个元组列表，其中包含其残差方差和原始索引：$(\\operatorname{Var}_{res}(g), g)$。\n2. 对此列表进行排序。主要排序标准是残差方差，按降序排列。次要标准是基因索引，按升序排列，用于打破平局。\n3. 从这个排序列表中取出的前 $k$ 个基因的索引即为结果。\n此过程确保了基于基因超出模型预期的方差对其进行唯一且确定性的排序，满足了问题陈述的所有要求。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the highly variable gene detection problem for the provided test suite.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"X\": np.array([\n                [10, 15, 8, 12, 11, 9],\n                [5, 20, 6, 25, 5, 23],\n                [50, 75, 40, 60, 55, 45],\n                [0, 1, 0, 2, 0, 1],\n                [30, 70, 24, 72, 33, 63]\n            ]),\n            \"L\": np.array([1000, 1500, 800, 1200, 1100, 900]),\n            \"phi\": 0.1,\n            \"k\": 2\n        },\n        {\n            \"X\": np.array([\n                [10, 10, 10, 10],\n                [2, 20, 1, 18],\n                [0, 0, 0, 0],\n                [5, 7, 6, 4]\n            ]),\n            \"L\": np.array([1000, 1000, 1000, 1000]),\n            \"phi\": 0.0,\n            \"k\": 1\n        },\n        {\n            \"X\": np.array([\n                [1, 5, 0, 4, 6],\n                [50, 210, 30, 160, 260],\n                [8, 60, 3, 40, 90],\n                [0, 0, 0, 0, 0],\n                [15, 30, 9, 40, 35],\n                [0, 100, 0, 150, 300]\n            ]),\n            \"L\": np.array([500, 2000, 300, 1500, 2500]),\n            \"phi\": 1.0,\n            \"k\": 2\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        X = case[\"X\"]\n        L = case[\"L\"]\n        phi = case[\"phi\"]\n        k = case[\"k\"]\n        \n        num_genes, num_cells = X.shape\n\n        # Step 1: Compute size factors s_i\n        L_ref = np.median(L)\n        s = L / L_ref\n\n        # Step 2: Estimate gene expression mean mu_g\n        # mu_hat has shape (num_genes,)\n        sum_s = np.sum(s)\n        total_counts_per_gene = np.sum(X, axis=1)\n        mu_hat = np.divide(total_counts_per_gene, sum_s, \n                           out=np.zeros_like(total_counts_per_gene, dtype=float), \n                           where=sum_s!=0)\n\n        # Step 3: Construct variance-stabilized residuals\n        # Reshape for broadcasting: mu_hat (G,1), s (1,C) - expected_counts (G,C)\n        mu_hat_col = mu_hat[:, np.newaxis]\n        s_row = s[np.newaxis, :]\n        \n        expected_counts = mu_hat_col * s_row\n        \n        expected_variance = expected_counts + phi * (expected_counts**2)\n        \n        # Calculate Pearson residuals: (observed - expected) / sqrt(expected_variance)\n        numerator = X - expected_counts\n        denominator = np.sqrt(expected_variance)\n        \n        # Handle division by zero for genes with mu_hat = 0\n        residuals = np.divide(numerator, denominator, \n                              out=np.zeros_like(numerator, dtype=float), \n                              where=denominator!=0)\n        \n        # Step 4: Compute residual variance and select top k genes\n        # ddof=1 for unbiased sample variance.\n        # This will be an array of shape (num_genes,)\n        # If a row in residuals is constant (e.g., all 0s), variance is 0.\n        # np.var handles this correctly, no NaNs are produced for constant inputs.\n        residual_variances = np.var(residuals, axis=1, ddof=1)\n        \n        # Create a list of (variance, gene_index) tuples.\n        gene_variances = list(enumerate(residual_variances))\n        \n        # Sort by variance (desc) and then by gene index (asc) for tie-breaking.\n        # Python's sort is stable, but a lambda key is more explicit.\n        # key = (variance, index) - sort by (-variance, index)\n        sorted_genes = sorted(gene_variances, key=lambda item: (-item[1], item[0]))\n        \n        # Select the top k gene indices.\n        top_k_indices = [index for index, var in sorted_genes[:k]]\n        \n        all_results.append(f\"[{','.join(map(str, top_k_indices))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}