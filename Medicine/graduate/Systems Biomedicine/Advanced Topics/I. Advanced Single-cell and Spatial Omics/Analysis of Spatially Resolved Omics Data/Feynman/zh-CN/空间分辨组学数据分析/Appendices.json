{
    "hands_on_practices": [
        {
            "introduction": "在分析空间分辨组学数据时，一个基础性的首要步骤是形式化地定义测量位点之间的关系。本练习将引导您完成从一组坐标构建空间邻域图的核心任务，该任务将几何上的邻近关系转化为一种可计算的结构 。通过实现一个 $\\epsilon$ 半径图，您将亲身体验距离阈值 $\\epsilon$ 的选择如何直接影响网络连通性和局部社区的定义。",
            "id": "4315795",
            "problem": "给定代表空间分辨组学分析中测量位置的空间坐标，这些坐标被视为二维欧几里得空间中的点。目标是对于一个以微米（$\\,\\mu \\mathrm{m}\\,$）为单位的给定非负距离阈值 $\\,\\epsilon\\,$，在这些点上构建一个 $\\epsilon$-半径图，计算其邻接矩阵，并评估图的连通性作为 $\\,\\epsilon\\,$ 的函数。程序必须从第一性原理出发实现以下内容。\n\n基本原理和定义：\n- 分子生物学中心法则确立了在空间位置上对分子种类的测量，但为了计算，我们将这些位置抽象为度量空间中的点。在欧几里得度量空间中，两点 $\\,p_i=(x_i,y_i)\\,$ 和 $\\,p_j=(x_j,y_j)\\,$ 之间的距离由欧几里得度量定义\n$$\nd_{ij} \\equiv \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}.\n$$\n- 一个包含 $\\,N\\,$ 个点的简单无向图由其邻接矩阵 $\\,A^{(\\epsilon)} \\in \\{0,1\\}^{N \\times N}\\,$ 定义，其中\n$$\nA^{(\\epsilon)}_{ij} \\equiv \\begin{cases}\n1,  \\text{if } i \\ne j \\text{ and } d_{ij} \\le \\epsilon,\\\\\n0,  \\text{otherwise.}\n\\end{cases}\n$$\n不包括自环，因此对于所有 $\\,i\\,$，$\\,A^{(\\epsilon)}_{ii} = 0\\,$。\n- 连通性通过连通分量来评估。令 $\\,K(\\epsilon)\\,$ 表示由 $\\,A^{(\\epsilon)}\\,$ 导出的图的连通分量的整数数量。令 $\\,L(\\epsilon)\\,$ 表示最大连通分量的大小（整数）。定义连通分数\n$$\nF(\\epsilon) \\equiv \\frac{L(\\epsilon)}{N},\n$$\n一个四舍五入到四位小数的实数。\n\n程序要求：\n- 给定一个以 $\\,\\mu \\mathrm{m}\\,$ 为单位的坐标列表 $\\,\\{(x_i,y_i)\\}_{i=1}^N\\,$ 和一个同样以 $\\,\\mu \\mathrm{m}\\,$ 为单位的阈值集合 $\\,\\{\\epsilon_t\\}_{t=1}^T\\,$，为每个 $\\,\\epsilon_t\\,$ 构建 $\\,A^{(\\epsilon_t)}\\,$ 并计算 $\\,K(\\epsilon_t)\\,$ 和 $\\,F(\\epsilon_t)\\,$。\n- 最终输出不得包含物理单位；仅包含指定的数字。在内部，距离必须以 $\\,\\mu \\mathrm{m}\\,$ 为单位处理，以下阈值 $\\,\\epsilon\\,$ 的值也均以 $\\,\\mu \\mathrm{m}\\,$ 为单位。\n\n测试套件与覆盖范围：\n为以下四个独立的测试用例提供结果，每个用例包含一个坐标集和一个阈值集。这些测试用例探究了一般情况、边界条件、重复坐标以及带有离群点的网格结构。\n\n- 测试用例 $\\,1\\,$ (两个在空间上分离的紧凑簇；$\\,N=6\\,$)：\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,(0,0),\\,(1,0),\\,(0.5,0.5),\\,(10,0),\\,(11,0),\\,(10.5,-0.5)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,\\epsilon \\in [0.4,\\,0.71,\\,1.0,\\,8.9,\\,9.0]\\,$。\n\n- 测试用例 $\\,2\\,$ (重复点和精确距离边界；$\\,N=3\\,$)：\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,(0,0),\\,(0,0),\\,(3,4)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,\\epsilon \\in [0.0,\\,0.0001,\\,5.0]\\,$。\n\n- 测试用例 $\\,3\\,$ (等间距的线性链；$\\,N=5\\,$)：\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,(0,0),\\,(2,0),\\,(4,0),\\,(6,0),\\,(8,0)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,\\epsilon \\in [1.0,\\,2.0,\\,2.1,\\,8.0]\\,$。\n\n- 测试用例 $\\,4\\,$ (带有一个离群点的网格；$\\,N=5\\,$)：\n  - 坐标 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,(0,0),\\,(0,1),\\,(1,0),\\,(1,1),\\,(4,4)\\,$。\n  - 阈值 (单位 $\\,\\mu \\mathrm{m}\\,$)：$\\,\\epsilon \\in [0.9,\\,1.0,\\,1.5,\\,5.0]\\,$。\n\n答案规格：\n- 对于每个测试用例，计算列表 $\\,\\{K(\\epsilon_t)\\}_{t=1}^T\\,$ 和列表 $\\,\\{F(\\epsilon_t)\\}_{t=1}^T\\,$，其中 $\\,F(\\epsilon_t)\\,$ 四舍五入到四位小数并表示为小数。\n- 您的程序应生成单行输出，按上述顺序为每个测试用例包含一对列表 $\\,\\big([\\text{list of }K],\\,[\\text{list of }F]\\big)\\,$，并将这些列表对聚合到一个外部列表中。具体来说，输出必须是以下形式的单行：\n$$\n\\big[\\,\\big([K_{1,1},\\ldots,K_{1,T_1}],\\,[F_{1,1},\\ldots,F_{1,T_1}]\\big),\\,\\ldots,\\,\\big([K_{4,1},\\ldots,K_{4,T_4}],\\,[F_{4,1},\\ldots,F_{4,T_4}]\\big)\\,\\big].\n$$\n输出行中只允许出现数字和括号；不要包含单位或其他文本。",
            "solution": "我们将首先验证问题陈述来处理用户的请求，然后在问题有效性的基础上，提供一个包含底层科学推理和完整 Python 实现的完整解决方案。\n\n### 问题验证\n\n#### 步骤 1：提取已知条件\n\n- **度量空间**：问题设置在二维欧几里得空间中。\n- **欧几里得距离**：两点 $\\,p_i=(x_i,y_i)\\,$ 和 $\\,p_j=(x_j,y_j)\\,$ 之间的距离定义为 $d_{ij} \\equiv \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$。\n- **图定义**：在一个包含 $\\,N\\,$ 个点的集合上构建一个 $\\epsilon$-半径图。其邻接矩阵 $\\,A^{(\\epsilon)} \\in \\{0,1\\}^{N \\times N}\\,$ 由规则定义：如果 $\\,i \\ne j\\,$ 且 $\\,d_{ij} \\le \\epsilon\\,$，则 $A^{(\\epsilon)}_{ij} = 1\\,$，否则 $A^{(\\epsilon)}_{ij} = 0\\,$。不包括自环，即对所有 $\\,i\\,$，$\\,A^{(\\epsilon)}_{ii} = 0\\,$。\n- **连通性度量**：\n  - $\\,K(\\epsilon)\\,$：给定 $\\,\\epsilon\\,$ 时图中连通分量的整数数量。\n  - $\\,L(\\epsilon)\\,$：最大连通分量的大小（整数）。\n  - $\\,F(\\epsilon) \\equiv \\frac{L(\\epsilon)}{N}\\,$：连通分数，一个四舍五入到四位小数的实数。\n- **输入数据**：程序接收一个坐标列表 $\\,\\{(x_i,y_i)\\}_{i=1}^N\\,$ 和一个距离阈值集合 $\\,\\{\\epsilon_t\\}_{t=1}^T\\,$。所有空间和距离单位均为微米（$\\,\\mu \\mathrm{m}\\,$）。\n- **测试用例**：\n    - **用例 1**：$\\,N=6\\,$ 个坐标 $\\,(0,0),\\,(1,0),\\,(0.5,0.5),\\,(10,0),\\,(11,0),\\,(10.5,-0.5)\\,$，阈值为 $\\,\\epsilon \\in [0.4,\\,0.71,\\,1.0,\\,8.9,\\,9.0]\\,$。\n    - **用例 2**：$\\,N=3\\,$ 个坐标 $\\,(0,0),\\,(0,0),\\,(3,4)\\,$，阈值为 $\\,\\epsilon \\in [0.0,\\,0.0001,\\,5.0]\\,$。\n    - **用例 3**：$\\,N=5\\,$ 个坐标 $\\,(0,0),\\,(2,0),\\,(4,0),\\,(6,0),\\,(8,0)\\,$，阈值为 $\\,\\epsilon \\in [1.0,\\,2.0,\\,2.1,\\,8.0]\\,$。\n    - **用例 4**：$\\,N=5\\,$ 个坐标 $\\,(0,0),\\,(0,1),\\,(1,0),\\,(1,1),\\,(4,4)\\,$，阈值为 $\\,\\epsilon \\in [0.9,\\,1.0,\\,1.5,\\,5.0]\\,$。\n- **输出规格**：一个单行字符串，表示一个元组列表。每个元组对应一个测试用例，并包含两个列表：计算出的 $\\,K\\,$ 值列表和计算出的 $\\,F\\,$ 值列表。指定格式为：$\\big[\\,\\big([K_{1,1},\\ldots],\\,[F_{1,1},\\ldots]\\big),\\,\\ldots,\\,\\big([K_{4,1},\\ldots],\\,[F_{4,1},\\ldots]\\big)\\,\\big]$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行评估。\n\n- **科学基础**：该问题基于图论（无向图、邻接矩阵、连通分量）和几何学（欧几里得距离）的基本和标准概念。其应用背景——空间分辨组学——是系统生物学中一个有效且重要的研究领域，其中此类基于图的分析被用来模拟细胞间的相互作用。该问题不含任何伪科学或事实性错误。\n- **适定性**：对于任何给定的 $\\,N\\,$ 个点集和非负阈值 $\\,\\epsilon\\,$，$\\epsilon$-半径图是唯一定义的。连通分量的数量和最大分量的大小是任何图的明确且可计算的属性。该问题的结构确保每个测试用例都有唯一的解。\n- **客观性**：该问题使用精确的数学定义和客观的语言陈述，没有主观解释的余地。\n- **完整性与一致性**：该问题是自洽的。它提供了所有必要的定义、数据（坐标和阈值）以及清晰的输出规格。邻接矩阵的定义，包括排除自环（$\\,i \\ne j\\,$）和非严格不等式（$\\,d_{ij} \\le \\epsilon\\,$），都是明确且内部一致的。\n- **可行性**：所提供的坐标和阈值是现实的。计算任务是可行的，并且可以使用标准算法在合理的时间内解决。\n- **结构性**：该问题结构良好。它要求从第一性原理出发实现一个算法，这是一个明确的指令。测试用例经过精心设计，以涵盖各种场景，包括聚类数据、重复坐标（被视为不同节点）、线性结构以及带有离群点的网格。\n\n#### 步骤 3：结论与行动\n\n该问题是**有效的**。它科学合理、适定且完整。我现在将着手解决。\n\n### 基于原理的解决方案设计\n\n问题的核心是通过改变距离阈值 $\\,\\epsilon\\,$，分析由一组固定点生成的一系列图的连通性。该解决方案必须从第一性原理出发实现，特别是连通分量的计算。\n\n1.  **距离计算**：对于一组 $\\,N\\,$ 个点，第一步是计算所有点对之间的欧几里得距离。为优化流程，我们可以预先计算一个对称的 $\\,N \\times N\\,$ 距离矩阵 $\\,D\\,$，其中 $\\,D_{ij} = d_{ij}\\,$。这样可以避免为每个阈值 $\\,\\epsilon\\,$ 重复计算距离。\n\n2.  **图的构建**：对于每个给定的阈值 $\\,\\epsilon_t\\,$，我们构建邻接矩阵 $\\,A^{(\\epsilon_t)}\\,$。根据定义，当且仅当对应的距离 $\\,D_{ij}\\,$ 满足 $\\,0 < D_{ij} \\le \\epsilon_t\\,$ 时，元素 $\\,A^{(\\epsilon_t)}_{ij}\\,$ 被设置为 $\\,1\\,$。条件 $\\,D_{ij} > 0\\,$ 隐式地处理了 $\\,i \\ne j\\,$ 的要求，因为 $\\,D_{ii} = 0\\,$。这可以通过对预先计算的距离矩阵应用阈值化操作来高效实现。\n\n3.  **连通分量算法**：问题要求找出连通分量的数量 $\\,K(\\epsilon_t)\\,$ 和最大连通分量的大小 $\\,L(\\epsilon_t)\\,$。这是一个经典的图遍历问题。我们将从第一性原理出发实现一个算法，例如深度优先搜索（DFS）或广度优先搜索（BFS），来识别这些分量。算法流程如下：\n    a. 初始化一个大小为 $\\,N\\,$ 的 `visited` 数组来跟踪已访问的节点，初始值均为 `False`。\n    b. 初始化一个空列表 `component_sizes`，用于存储找到的每个分量的大小。\n    c. 从 $\\,0\\,$ 到 $\\,N-1\\,$ 遍历每个节点 $\\,i\\,$。\n    d. 如果节点 $\\,i\\,$ 尚未被访问，则表示发现了一个新的、未被发现的分量的起点。\n        i.  从节点 $\\,i\\,$ 开始进行图遍历（例如，使用栈的迭代式DFS）。\n        ii. 将节点 $\\,i\\,$ 标记为已访问，并将其推入栈中。\n        iii. 初始化当前分量大小的计数器为 $\\,0\\,$。\n        iv. 当栈不为空时，弹出一个节点 $\\,u\\,$，增加大小计数器，并检查其所有邻居 $\\,v\\,$（即 $\\,A^{(\\epsilon_t)}_{uv} = 1\\,$ 的节点）。对于每个未访问的邻居 $\\,v\\,$，将其标记为已访问并推入栈中。\n    e. 从节点 $\\,i\\,$ 开始的遍历完成后，大小计数器的最终值就是该分量的大小。将此大小附加到 `component_sizes` 列表中。\n    f. 遍历完所有节点后，连通分量的数量 $\\,K(\\epsilon_t)\\,$ 就是启动的总遍历次数，即 `component_sizes` 列表的长度。\n    g. 最大连通分量的大小 $\\,L(\\epsilon_t)\\,$ 是 `component_sizes` 列表中的最大值。\n\n4.  **度量计算与格式化**：计算出 $\\,K(\\epsilon_t)\\,$ 和 $\\,L(\\epsilon_t)\\,$ 后，计算连通分数 $\\,F(\\epsilon_t) = L(\\epsilon_t) / N\\,$ 并按要求四舍五入到四位小数。对集合 $\\,\\{\\epsilon_t\\}\\,$ 中的所有阈值重复此过程。\n\n5.  **输出生成**：最后一步是将所有测试用例收集到的 $\\,K\\,$ 和 $\\,F\\,$ 值列表格式化为问题描述中指定的确切字符串格式，确保没有多余的字符或不正确的间距。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_connected_components(adj_matrix: np.ndarray):\n    \"\"\"\n    Finds connected components in a graph from its adjacency matrix.\n    Implementation is from first principles using an iterative Depth-First Search (DFS).\n\n    Args:\n        adj_matrix: An N x N numpy array representing the graph's adjacency matrix.\n\n    Returns:\n        A tuple (num_components, largest_component_size).\n    \"\"\"\n    n = adj_matrix.shape[0]\n    if n == 0:\n        return 0, 0\n\n    visited = [False] * n\n    component_sizes = []\n\n    for i in range(n):\n        if not visited[i]:\n            # Found the start of a new component\n            current_component_size = 0\n            stack = [i]\n            visited[i] = True\n\n            while stack:\n                u = stack.pop()\n                current_component_size += 1\n                # Find neighbors of u where there is an edge (value is 1)\n                neighbors = np.where(adj_matrix[u] == 1)[0]\n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n            \n            component_sizes.append(current_component_size)\n\n    num_components = len(component_sizes)\n    largest_component_size = max(component_sizes) if component_sizes else 0\n\n    return num_components, largest_component_size\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            # Test Case 1\n            [(0, 0), (1, 0), (0.5, 0.5), (10, 0), (11, 0), (10.5, -0.5)],\n            [0.4, 0.71, 1.0, 8.9, 9.0]\n        ),\n        (\n            # Test Case 2\n            [(0, 0), (0, 0), (3, 4)],\n            [0.0, 0.0001, 5.0]\n        ),\n        (\n            # Test Case 3\n            [(0, 0), (2, 0), (4, 0), (6, 0), (8, 0)],\n            [1.0, 2.0, 2.1, 8.0]\n        ),\n        (\n            # Test Case 4\n            [(0, 0), (0, 1), (1, 0), (1, 1), (4, 4)],\n            [0.9, 1.0, 1.5, 5.0]\n        )\n    ]\n\n    all_results = []\n    for coordinates_list, thresholds in test_cases:\n        coords = np.array(coordinates_list, dtype=float)\n        N = coords.shape[0]\n\n        # Use numpy broadcasting to efficiently compute the pairwise distance matrix.\n        # coords[:, np.newaxis, :] -> shape (N, 1, 2)\n        # coords[np.newaxis, :, :] -> shape (1, N, 2)\n        # Difference results in a shape (N, N, 2) array of coordinate differences.\n        dist_matrix = np.sqrt(np.sum((coords[:, np.newaxis, :] - coords[np.newaxis, :, :])**2, axis=-1))\n\n        k_results = []\n        f_results = []\n\n        for epsilon in thresholds:\n            # Construct adjacency matrix A_ij = 1 if i != j and d_ij = epsilon.\n            adj_matrix_bool = (dist_matrix = epsilon)\n            np.fill_diagonal(adj_matrix_bool, False)\n            adj_matrix = adj_matrix_bool.astype(int)\n\n            K, L = find_connected_components(adj_matrix)\n            \n            # For N=0, F would be undefined. Problem constraints ensure N >= 3.\n            F = round(L / N, 4) if N > 0 else 0.0\n\n            k_results.append(K)\n            f_results.append(F)\n        \n        all_results.append((k_results, f_results))\n\n    # Construct the final output string exactly as specified.\n    # Manually build the string to control spacing and format.\n    case_strings = []\n    for k_list, f_list in all_results:\n        k_str = f\"[{','.join(map(str, k_list))}]\"\n        f_str = f\"[{','.join(map(str, f_list))}]\"\n        case_strings.append(f\"({k_str},{f_str})\")\n        \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "一旦空间关系被建立，我们就可以研究分子测量值如何与空间位置相关联。本练习从表示结构转向量化空间模式，使用了来自细胞分割掩模和蛋白质强度测量的数据 。您将计算关键的汇总统计量和一种广泛使用的空间自相关度量，这对于确定一个分子标记物的表达是随机的还是具有空间组织性至关重要。",
            "id": "4315652",
            "problem": "您将获得一组综合生成但科学上合理的数据，代表了系统生物医学中一个简化的空间分辨蛋白质组学场景。该场景遵循分子生物学中心法则这一基本基础，该法则描述了从脱氧核糖核酸 (DNA) 到核糖核酸 (RNA) 再到蛋白质的信息流，并且组织切片中蛋白质标记物强度的测量可以被视为每个已分割细胞的定量变量。分割掩码将每个像素分配给一个细胞标识符，从而能够对细胞位置进行几何推断。任务是计算每种细胞类型的汇总统计量，并使用基于距离的邻居定义来评估标记物表达的空间自相关性。核心量是每种细胞类型的单个细胞强度的样本均值和无偏样本方差，以及使用有限半径内的反距离权重计算的细胞空间自相关度量。\n\n作为该问题基础的基本定律和核心定义包括：随机变量的期望值和方差的定义，通过平均像素中心坐标来构建标记区域的质心，以及空间自相关的概念，即邻近观测值趋于相似的趋势。假设标记物的测量单位为任意强度单位，而空间距离使用微米。\n\n对于每个测试用例，提供以下数据：\n\n- 一个二维分割掩码，为每个像素指定细胞标识符。背景用 $0$ 标记。\n- 从每个细胞标识符到分类细胞类型标签的映射。\n- 从每个细胞标识符到单个标记物的每细胞蛋白质强度的映射。\n- 像素大小 $p$（单位为微米），指定一个像素边缘的物理尺寸。\n- 邻居半径 $r$（单位为微米），定义了空间邻域：如果两个不同细胞的质心之间的欧几里得距离小于或等于 $r$，则它们被视为邻居。邻居对的空间权重定义为其质心距离的倒数，否则为零。\n\n您的程序必须为每个测试用例执行以下操作：\n- 从分割掩码计算每个细胞的质心。标记区域的质心是属于该区域的像素中心物理坐标的算术平均值，其中位于行索引 $i$ 和列索引 $j$ 的像素中心坐标为 $\\left((i + 0.5) \\cdot p, (j + 0.5) \\cdot p\\right)$（单位为微米）。\n- 对于每种细胞类型，计算该类型细胞的每细胞强度 $x_c$ 的样本均值和无偏样本方差（对于 $k$ 个样本，除数为 $k - 1$）。如果一种细胞类型只有 $k=1$ 个样本，则方差报告为 $0$。\n- 使用上述定义的标准基于距离的加权方案，评估所有细胞中标记物表达的空间自相关性。如果细胞少于 $2$ 个，或者总权重为 $0$，或者所有细胞强度的样本方差为 $0$，则空间自相关值报告为 $0$。\n\n所有距离均以微米表示。最终输出为无量纲量。角度单位不适用。\n\n测试套件规范：\n- 测试用例 $1$（正常路径）：\n  - $5 \\times 5$ 大小的分割掩码 $M_1$：\n    - 第 $0$ 行：[$1$, $1$, $2$, $2$, $0$]\n    - 第 $1$ 行：[$1$, $1$, $2$, $2$, $0$]\n    - 第 $2$ 行：[$0$, $0$, $0$, $0$, $0$]\n    - 第 $3$ 行：[$3$, $3$, $4$, $4$, $0$]\n    - 第 $4$ 行：[$3$, $3$, $4$, $4$, $0$]\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 3$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 1.0$, $x_2 = 2.5$, $x_3 = 1.5$, $x_4 = 3.0$。\n- 测试用例 $2$（无邻居的边界条件）：\n  - 分割掩码 $M_2 = M_1$。\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 1$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 1.0$, $x_2 = 2.5$, $x_3 = 1.5$, $x_4 = 3.0$。\n- 测试用例 $3$（零方差的边缘情况）：\n  - 分割掩码 $M_3 = M_1$。\n  - 像素大小 $p = 1$ 微米。\n  - 邻居半径 $r = 3$ 微米。\n  - 细胞类型映射：$1 \\mapsto$ \"A\", $2 \\mapsto$ \"B\", $3 \\mapsto$ \"A\", $4 \\mapsto$ \"B\"。\n  - 每细胞强度：$x_1 = 2.0$, $x_2 = 2.0$, $x_3 = 2.0$, $x_4 = 2.0$。\n\n输出规范：\n- 对于每个测试用例，返回一个包含三个元素的列表：\n  - 按类型标签的字典序列出的每种类型的样本均值列表，\n  - 按相同顺序列出的每种类型的无偏样本方差列表，\n  - 空间自相关值（浮点数）。\n- 将所有测试用例的结果汇总到一行中，该行包含一个由这些每个用例的列表组成的列表。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[[means_case1,vars_case1,moran_case1],[means_case2,vars_case2,moran_case2],[means_case3,vars_case3,moran_case3]]”）。所有数值结果必须是浮点数或浮点数列表。不应打印任何其他文本。",
            "solution": "所提供的问题具有科学依据、提法明确且完整。它展示了空间生物信息学中的一个标准计算工作流程，要求从分割掩码计算细胞质心，为不同细胞群体计算汇总统计量，并使用定义的自相关指数评估空间模式。该问题是有效的，可以通过实施指定的计算来解决。\n\n解决过程分为三个主要部分：\n1.  从分割掩码计算细胞质心。\n2.  计算每种细胞类型的汇总统计量（均值和方差）。\n3.  计算所有细胞中标记物强度的空间自相关性。\n\n每个步骤都将进行数学描述，然后使用测试用例 1 的数据进行详细示例演算。\n\n### 1. 细胞质心计算\n\n一个细胞的几何质心是属于该细胞的所有像素中心的物理坐标的算术平均值。给定矩阵索引为 $(i, j)$（行，列）的像素和 $p$ 微米的像素大小，该像素中心的物理坐标由下式给出：\n$$ (y, z) = ((i + 0.5) \\cdot p, (j + 0.5) \\cdot p) $$\n对于由一组 $N_c$ 个像素组成的细胞 $c$，其像素索引为 $S_c = \\{(i_1, j_1), (i_2, j_2), \\dots, (i_{N_c}, j_{N_c})\\}$，其质心 $(\\bar{y}_c, \\bar{z}_c)$ 计算如下：\n$$ \\bar{y}_c = \\frac{p}{N_c} \\sum_{k=1}^{N_c} (i_k + 0.5) $$\n$$ \\bar{z}_c = \\frac{p}{N_c} \\sum_{k=1}^{N_c} (j_k + 0.5) $$\n\n**示例（测试用例 1）：**\n- 像素大小 $p = 1\n\\mu m$。\n- 细胞 $1$ 由索引为 $(0,0), (0,1), (1,0), (1,1)$ 的像素组成。共有 $N_1 = 4$ 个像素。\n- 质心是：\n  $$ \\bar{y}_1 = \\frac{1}{4} ((0+0.5) + (0+0.5) + (1+0.5) + (1+0.5)) = \\frac{0.5+0.5+1.5+1.5}{4} = 1.0 \\, \\mu m $$\n  $$ \\bar{z}_1 = \\frac{1}{4} ((0+0.5) + (1+0.5) + (0+0.5) + (1+0.5)) = \\frac{0.5+1.5+0.5+1.5}{4} = 1.0 \\, \\mu m $$\n  因此，细胞 $1$ 的质心是 $C_1 = (1.0, 1.0)$。\n- 类似地，我们找到其他细胞的质心：\n  - 细胞 $2$（像素 $(0,2), (0,3), (1,2), (1,3)$）：$C_2 = (1.0, 3.0)$。\n  - 细胞 $3$（像素 $(3,0), (3,1), (4,0), (4,1)$）：$C_3 = (4.0, 1.0)$。\n  - 细胞 $4$（像素 $(3,2), (3,3), (4,2), (4,3)$）：$C_4 = (4.0, 3.0)$。\n\n### 2. 按类型的汇总统计量\n\n对于每种细胞类型，我们收集属于该类型的所有细胞的强度，并计算样本均值和无偏样本方差。\n\n- 对于一个包含 $k$ 个细胞、强度为 $\\{x_1, x_2, \\dots, x_k\\}$ 的细胞类型，其**样本均值**为：\n  $$ \\bar{x}_{\\text{type}} = \\frac{1}{k} \\sum_{i=1}^k x_i $$\n- **无偏样本方差**为：\n  $$ s^2_{\\text{type}} = \\frac{1}{k-1} \\sum_{i=1}^k (x_i - \\bar{x}_{\\text{type}})^2 $$\n  如果 $k=1$，方差定义为 $0$。\n\n**示例（测试用例 1）：**\n- 细胞类型按字典序排序：“A”、“B”。\n- **“A”类型**：细胞 $1$ 和 $3$，强度为 $x_1=1.0, x_3=1.5$。这里 $k=2$。\n  - 均值：$\\bar{x}_A = \\frac{1.0 + 1.5}{2} = 1.25$。\n  - 方差：$s^2_A = \\frac{(1.0 - 1.25)^2 + (1.5 - 1.25)^2}{2-1} = (-0.25)^2 + (0.25)^2 = 0.0625 + 0.0625 = 0.125$。\n- **“B”类型**：细胞 $2$ 和 $4$，强度为 $x_2=2.5, x_4=3.0$。这里 $k=2$。\n  - 均值：$\\bar{x}_B = \\frac{2.5 + 3.0}{2} = 2.75$。\n  - 方差：$s^2_B = \\frac{(2.5 - 2.75)^2 + (3.0 - 2.75)^2}{2-1} = (-0.25)^2 + (0.25)^2 = 0.0625 + 0.0625 = 0.125$。\n- 结果为 `means = [1.25, 2.75]` 和 `variances = [0.125, 0.125]`。\n\n### 3. 空间自相关（莫兰指数I）\n\n该问题要求使用标准的基于距离的加权方案来评估空间自相关。这对应于计算莫兰指数I，其定义如下：\n$$ I = \\frac{N}{\\sum_{i=1}^N \\sum_{j=1}^N w_{ij}} \\frac{\\sum_{i=1}^N \\sum_{j=1}^N w_{ij} (x_i - \\bar{x})(x_j - \\bar{x})}{\\sum_{i=1}^N (x_i - \\bar{x})^2} $$\n其中：\n- $N$ 是细胞总数。\n- $x_i$ 是细胞 $i$ 的强度。\n- $\\bar{x}$ 是所有细胞的平均强度。\n- $w_{ij}$ 是细胞 $i$ 和细胞 $j$ 之间的空间权重。\n权重 $w_{ij}$ 定义为细胞 $i$ 和 $j$ 的质心之间的欧几里得距离的倒数（如果该距离小于或等于给定半径 $r$），否则为 $0$。$w_{ii} = 0$。\n\n$$ w_{ij} = \\begin{cases} 1/d_{ij}  \\text{if } 0  d_{ij} \\le r \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $d_{ij} = \\sqrt{(\\bar{y}_i - \\bar{y}_j)^2 + (\\bar{z}_i - \\bar{z}_j)^2}$。\n\n如果 $N  2$，总权重 $W=\\sum_i\\sum_j w_{ij}$ 为 $0$，或者总方差（与 $\\sum_i (x_i - \\bar{x})^2$ 成正比）为 $0$，则该值报告为 $0$。\n\n**示例（测试用例 1）：**\n- 细胞数量 $N=4$。强度 $\\{1.0, 2.5, 1.5, 3.0\\}$。\n- 全局平均强度：$\\bar{x} = \\frac{1.0+2.5+1.5+3.0}{4} = 2.0$。\n- 与均值的偏差 $(x_i - \\bar{x})$：$\\{-1.0, 0.5, -0.5, 1.0\\}$。\n- 偏差平方和：$\\sum_i (x_i - \\bar{x})^2 = (-1.0)^2 + (0.5)^2 + (-0.5)^2 + (1.0)^2 = 2.5$。\n- 邻居半径 $r = 3.0 \\, \\mu m$。质心：$C_1(1,1), C_2(1,3), C_3(4,1), C_4(4,3)$。\n- 距离和权重 $(w_{ij} = w_{ji})$：\n  - $d_{12} = \\sqrt{(1-1)^2 + (1-3)^2} = 2.0 \\le 3.0 \\implies w_{12} = 1/2.0 = 0.5$。\n  - $d_{13} = \\sqrt{(1-4)^2 + (1-1)^2} = 3.0 \\le 3.0 \\implies w_{13} = 1/3.0$。\n  - $d_{14} = \\sqrt{(1-4)^2 + (1-3)^2} = \\sqrt{13} \\approx 3.61  3.0 \\implies w_{14} = 0$。\n  - $d_{24} = \\sqrt{(1-4)^2 + (3-3)^2} = 3.0 \\le 3.0 \\implies w_{24} = 1/3.0$。\n  - $d_{34} = \\sqrt{(4-4)^2 + (1-3)^2} = 2.0 \\le 3.0 \\implies w_{34} = 1/2.0$。\n  - $d_{23} = \\sqrt{(1-4)^2 + (3-1)^2} = \\sqrt{13} \\approx 3.61  3.0 \\implies w_{23} = 0$。\n- 总权重 $W = \\sum_i \\sum_j w_{ij} = 2 \\cdot (w_{12} + w_{13} + w_{24} + w_{34}) = 2 \\cdot (0.5 + 1/3 + 1/3 + 0.5) = 2 \\cdot (1 + 2/3) = 10/3$。\n- 莫兰指数I的分子：$\\sum_i \\sum_j w_{ij}(x_i - \\bar{x})(x_j - \\bar{x}) = 2 \\cdot [w_{12}(-1.0)(0.5) + w_{13}(-1.0)(-0.5) + w_{24}(0.5)(1.0) + w_{34}(-0.5)(1.0)] = 2 \\cdot [0.5(-0.5) + (1/3)(0.5) + (1/3)(0.5) + 0.5(-0.5)] = 2 \\cdot [-0.25 + 1/6 + 1/6 - 0.25] = 2 \\cdot [-0.5 + 1/3] = 2 \\cdot [-1/6] = -1/3$。\n- 莫兰指数I：$I = \\frac{4}{10/3} \\frac{-1/3}{2.5} = \\frac{12}{10} \\frac{-1}{7.5} = 1.2 \\cdot (-0.1333...) = -0.16$。\n\n测试用例 1 的最终结果是 `[[1.25, 2.75], [0.125, 0.125], -0.16]`。\n\n- **测试用例 2** 与测试用例 1 完全相同，只是 $r=1.0$。所有细胞间距离都大于 $1.0$，因此所有权重 $w_{ij}$ 均为 $0$。总权重 $W=0$，根据定义，莫兰指数I为 $0.0$。\n- **测试用例 3** 与测试用例 1 完全相同，只是所有强度均为 $2.0$。全局均值为 $2.0$，因此所有偏差 $(x_i - \\bar{x})$ 均为 $0$。总方差为 $0$，根据定义，莫兰指数I为 $0.0$。每种类型的方差也为 $0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import euclidean\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and generate the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 3.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 1.0, 2: 2.5, 3: 1.5, 4: 3.0}\n        },\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 1.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 1.0, 2: 2.5, 3: 1.5, 4: 3.0}\n        },\n        {\n            \"mask\": np.array([\n                [1, 1, 2, 2, 0],\n                [1, 1, 2, 2, 0],\n                [0, 0, 0, 0, 0],\n                [3, 3, 4, 4, 0],\n                [3, 3, 4, 4, 0]\n            ]),\n            \"pixel_size\": 1.0,\n            \"neighbor_radius\": 3.0,\n            \"type_map\": {1: \"A\", 2: \"B\", 3: \"A\", 4: \"B\"},\n            \"intensity_map\": {1: 2.0, 2: 2.0, 3: 2.0, 4: 2.0}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(\n            case[\"mask\"],\n            case[\"pixel_size\"],\n            case[\"neighbor_radius\"],\n            case[\"type_map\"],\n            case[\"intensity_map\"]\n        )\n        results.append(result)\n\n    # Format output according to specification\n    # str() on a list correctly formats it with brackets, e.g., '[1.0, 2.0]'\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef process_case(segmentation_mask, pixel_size, neighbor_radius, type_map, intensity_map):\n    \"\"\"\n    Processes a single test case to compute statistics and spatial autocorrelation.\n    \"\"\"\n    # Step 1: Collect cell data and compute centroids\n    cell_pixels = {}\n    rows, cols = segmentation_mask.shape\n    for i in range(rows):\n        for j in range(cols):\n            cell_id = segmentation_mask[i, j]\n            if cell_id > 0:\n                if cell_id not in cell_pixels:\n                    cell_pixels[cell_id] = []\n                cell_pixels[cell_id].append((i, j))\n\n    cell_ids = sorted(cell_pixels.keys())\n    centroids = {}\n    for cell_id in cell_ids:\n        pixel_coords = np.array(cell_pixels[cell_id])\n        # Centroid in pixel index space\n        mean_pixel_idx = np.mean(pixel_coords, axis=0)\n        # Convert to physical coordinates\n        centroid_phys = (mean_pixel_idx + 0.5) * pixel_size\n        centroids[cell_id] = centroid_phys\n    \n    # Step 2: Compute per-type statistics\n    type_data = {}\n    for cell_id in cell_ids:\n        cell_type = type_map[cell_id]\n        if cell_type not in type_data:\n            type_data[cell_type] = []\n        type_data[cell_type].append(intensity_map[cell_id])\n\n    sorted_types = sorted(type_data.keys())\n    type_means = []\n    type_vars = []\n    for cell_type in sorted_types:\n        intensities = np.array(type_data[cell_type], dtype=float)\n        type_means.append(np.mean(intensities))\n        if len(intensities) > 1:\n            # ddof=1 for unbiased sample variance\n            type_vars.append(np.var(intensities, ddof=1))\n        else:\n            type_vars.append(0.0)\n\n    # Step 3: Compute spatial autocorrelation (Moran's I)\n    num_cells = len(cell_ids)\n    if num_cells  2:\n        moran_i = 0.0\n    else:\n        intensities_all = np.array([intensity_map[cid] for cid in cell_ids], dtype=float)\n        mean_intensity_all = np.mean(intensities_all)\n        deviations = intensities_all - mean_intensity_all\n        sum_sq_dev = np.sum(deviations**2)\n\n        if sum_sq_dev == 0:\n            moran_i = 0.0\n        else:\n            total_weight = 0.0\n            moran_numerator = 0.0\n\n            for i in range(num_cells):\n                for j in range(num_cells):\n                    if i == j:\n                        continue\n                    \n                    id_i = cell_ids[i]\n                    id_j = cell_ids[j]\n                    \n                    dist = euclidean(centroids[id_i], centroids[id_j])\n                    \n                    weight = 0.0\n                    if dist = neighbor_radius and dist > 0: # dist > 0 is implicit with i!=j\n                        # Inverse distance weight\n                        weight = 1.0 / dist\n                    \n                    total_weight += weight\n                    moran_numerator += weight * deviations[i] * deviations[j]\n\n            if total_weight == 0:\n                moran_i = 0.0\n            else:\n                moran_i = (num_cells / total_weight) * (moran_numerator / sum_sq_dev)\n\n    return [type_means, type_vars, moran_i]\n\nsolve()\n```"
        }
    ]
}