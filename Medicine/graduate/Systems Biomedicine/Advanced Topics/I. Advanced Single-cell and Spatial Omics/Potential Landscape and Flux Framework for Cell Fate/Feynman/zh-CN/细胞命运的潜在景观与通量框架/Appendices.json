{
    "hands_on_practices": [
        {
            "introduction": "这项实践练习在理论概念与可测量量之间建立了一座基础的桥梁。我们将探索如何利用平均首通时间（MFPTs）——一个可以从实验时间序列数据中估算出的值——来量化两种不同细胞命运的相对稳定性。通过一个简单的双态马尔可夫模型，你将直接从这些动力学测量值中推导出势能差，为理解和计算势景中吸引子的“深度”提供一种具体方法 。",
            "id": "4376534",
            "problem": "在用于细胞命运研究的势景和流框架中，考虑一个高维随机基因调控系统，该系统具有两个分离良好的亚稳盆，对应于标记为 $A$ 和 $B$ 的表型状态。将该动力学粗粒化为一个具有两个状态 $A$ 和 $B$ 以及恒定转移速率 $k_{A \\to B}$ 和 $k_{B \\to A}$ 的连续时间马尔可夫跳跃过程。对完整的随机动力学进行长时间的直接模拟，得到以下平均首达时间（平均首达时间 (MFPT) 定义为从一个给定的初始集出发，首次到达一个指定的目标集所需的期望时间）：从盆 $A$ 出发，到达盆 $B$ 的 MFPT 为 $\\tau_{A \\to B} = 20~\\mathrm{h}$；从盆 $B$ 出发，到达盆 $A$ 的 MFPT 为 $\\tau_{B \\to A} = 5~\\mathrm{h}$。\n\n在以下基本定义和事实的框架内进行分析：\n- 粗粒化的两态过程被假定为一个具有恒定转移速率的时间齐次的连续时间马尔可夫链。\n- 稳态分布 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$ 是稳态下的主方程结合归一化条件的解。\n- 粗粒化势景由 $U_i = -\\ln p_i^{\\mathrm{ss}}$ 定义（取玻尔兹曼常数乘以温度为单位一的单位制），相差一个可加常数。\n- 在边 $A \\rightleftarrows B$ 上的粗粒化稳态概率流为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。\n\n仅使用这些基础和给定的 MFPT：\n1. 从 MFPT 推导出速率 $k_{A \\to B}$ 和 $k_{B \\to A}$。\n2. 从速率推导出稳态概率 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$。\n3. 将粗粒化势差 $\\Delta U \\equiv U_B - U_A$ 完全用 MFPT 表示，并精确计算其值。\n4. 从第一性原理出发，简要论证粗粒化稳态流 $J_{A B}^{\\mathrm{ss}}$ 的值，并解释这如何与底层的非平衡稳态下存在的非零连续空间概率流场 $\\mathbf{J}(\\mathbf{x})$ 相关联。\n\n请以自然对数的形式给出 $\\Delta U$ 的精确表达式作为最终答案。最终答案中不要包含单位。",
            "solution": "首先验证问题以确保其科学上成立、内容自洽且提法恰当。\n\n**步骤1：提取已知条件**\n- 该系统是一个高维随机基因调控系统，具有两个亚稳态 $A$ 和 $B$。\n- 该动力学被粗粒化为状态 $A$ 和 $B$ 之间的连续时间马尔可夫跳跃过程。\n- 转移速率是恒定的，记为 $k_{A \\to B}$ 和 $k_{B \\to A}$。\n- 从盆 $A$ 到盆 $B$ 的平均首达时间（MFPT）为 $\\tau_{A \\to B} = 20~\\mathrm{h}$。\n- 从盆 $B$ 到盆 $A$ 的 MFPT 为 $\\tau_{B \\to A} = 5~\\mathrm{h}$。\n- 稳态分布为 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$。\n- 粗粒化势定义为 $U_i = -\\ln p_i^{\\mathrm{ss}}$，单位制中玻尔兹曼常数乘以温度为1。\n- 粗粒化稳态概率流为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础（关键）：** 该问题牢固地植根于分析随机生物系统的既定统计物理学框架，特别是 Jin Wang 及其合作者发展的势和流景理论。粗粒化、连续时间马尔可夫链、平均首达时间以及势和流的定义都是该领域的标准概念。该问题在科学上是合理的。\n- **提法恰当：** 问题提供了两个数据点（两个 MFPT）来确定两个未知数（两个转移速率）。由此，所有其他量都可以被唯一地推导出来。问题是自洽的，并为得到唯一解提供了充分信息。\n- **客观性（关键）：** 语言精确且定量，没有主观或模糊的术语。\n\n**步骤3：结论与行动**\n- **结论：** 问题有效。\n- **行动：** 进行完整求解。\n\n**求解推导**\n\n问题需要一个分为四部分的解答，将按顺序进行处理。\n\n**1. 从 MFPT 推导出速率 $k_{A \\to B}$ 和 $k_{B \\to A}$。**\n\n对于一个两态连续时间马尔可夫过程，系统在发生转移前，在给定状态停留的时间呈指数分布。如果系统处于状态 $A$，唯一可能的转移是到状态 $B$。这个转移的速率是 $k_{A \\to B}$。因此，在状态 $A$ 的等待时间是一个速率参数为 $k_{A \\to B}$ 的指数随机变量。该指数分布的均值是速率的倒数。\n\n从状态 $A$ 到状态 $B$ 的平均首达时间（MFPT），记为 $\\tau_{A \\to B}$，定义为从状态 $A$ 出发，首次到达状态 $B$ 的期望时间。在这个简单的两态模型中，这恰好是在发生向 $B$ 的跳跃之前，在状态 $A$ 中的平均等待时间。因此，MFPT 是从起始状态转出的转移速率的倒数。\n\n数学上，我们有：\n$$ \\tau_{A \\to B} = \\frac{1}{k_{A \\to B}} $$\n从 $B$ 到 $A$ 的转移也类似：\n$$ \\tau_{B \\to A} = \\frac{1}{k_{B \\to A}} $$\n使用给定值 $\\tau_{A \\to B} = 20~\\mathrm{h}$ 和 $\\tau_{B \\to A} = 5~\\mathrm{h}$，我们可以计算出速率：\n$$ k_{A \\to B} = \\frac{1}{\\tau_{A \\to B}} = \\frac{1}{20}~\\mathrm{h}^{-1} $$\n$$ k_{B \\to A} = \\frac{1}{\\tau_{B \\to A}} = \\frac{1}{5}~\\mathrm{h}^{-1} $$\n\n**2. 从速率推导出稳态概率 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$。**\n\n稳态分布 $\\{p_A^{\\mathrm{ss}}, p_B^{\\mathrm{ss}}\\}$ 通过求解稳态下的主方程得到，此时概率的时间导数为零。状态 $A$ 的主方程是：\n$$ \\frac{dp_A}{dt} = -k_{A \\to B} p_A + k_{B \\to A} p_B $$\n在稳态下，$\\frac{dp_A}{dt} = 0$，这意味着：\n$$ p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A} $$\n这是细致平衡条件，表明在稳态下，从 $A$到 $B$ 的总概率流等于从 $B$ 到 $A$ 的总概率流。\n\n我们还有归一化条件：\n$$ p_A^{\\mathrm{ss}} + p_B^{\\mathrm{ss}} = 1 $$\n从细致平衡方程，我们将 $p_B^{\\mathrm{ss}}$ 用 $p_A^{\\mathrm{ss}}$ 表示：\n$$ p_B^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} \\frac{k_{A \\to B}}{k_{B \\to A}} $$\n将此代入归一化条件：\n$$ p_A^{\\mathrm{ss}} + p_A^{\\mathrm{ss}} \\frac{k_{A \\to B}}{k_{B \\to A}} = 1 $$\n$$ p_A^{\\mathrm{ss}} \\left( 1 + \\frac{k_{A \\to B}}{k_{B \\to A}} \\right) = 1 $$\n求解 $p_A^{\\mathrm{ss}}$：\n$$ p_A^{\\mathrm{ss}} = \\frac{1}{1 + \\frac{k_{A \\to B}}{k_{B \\to A}}} = \\frac{k_{B \\to A}}{k_{B \\to A} + k_{A \\to B}} $$\n对于 $p_B^{\\mathrm{ss}}$：\n$$ p_B^{\\mathrm{ss}} = 1 - p_A^{\\mathrm{ss}} = \\frac{k_{A \\to B}}{k_{B \\to A} + k_{A \\to B}} $$\n代入速率的数值 ($k_{A \\to B} = 1/20$ 和 $k_{B \\to A} = 1/5$)：\n$$ p_A^{\\mathrm{ss}} = \\frac{1/5}{1/5 + 1/20} = \\frac{1/5}{(4+1)/20} = \\frac{1}{5} \\cdot \\frac{20}{5} = \\frac{4}{5} $$\n$$ p_B^{\\mathrm{ss}} = \\frac{1/20}{1/5 + 1/20} = \\frac{1/20}{(4+1)/20} = \\frac{1}{20} \\cdot \\frac{20}{5} = \\frac{1}{5} $$\n\n**3. 将粗粒化势差 $\\Delta U \\equiv U_B - U_A$ 完全用 MFPT 表示，并计算其值。**\n\n势定义为 $U_i = -\\ln p_i^{\\mathrm{ss}}$。因此，势差为：\n$$ \\Delta U = U_B - U_A = (-\\ln p_B^{\\mathrm{ss}}) - (-\\ln p_A^{\\mathrm{ss}}) = \\ln p_A^{\\mathrm{ss}} - \\ln p_B^{\\mathrm{ss}} = \\ln\\left(\\frac{p_A^{\\mathrm{ss}}}{p_B^{\\mathrm{ss}}}\\right) $$\n使用从速率推导出的 $p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$ 的表达式：\n$$ \\frac{p_A^{\\mathrm{ss}}}{p_B^{\\mathrm{ss}}} = \\frac{k_{B \\to A} / (k_{B \\to A} + k_{A \\to B})}{k_{A \\to B} / (k_{B \\to A} + k_{A \\to B})} = \\frac{k_{B \\to A}}{k_{A \\to B}} $$\n这个比率也可以直接从细致平衡条件 $p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A}$ 得到。\n将此代入 $\\Delta U$ 的表达式：\n$$ \\Delta U = \\ln\\left(\\frac{k_{B \\to A}}{k_{A \\to B}}\\right) $$\n现在，我们使用 $k_{A \\to B} = 1/\\tau_{A \\to B}$ 和 $k_{B \\to A} = 1/\\tau_{B \\to A}$ 将其用 MFPT 表示：\n$$ \\Delta U = \\ln\\left(\\frac{1/\\tau_{B \\to A}}{1/\\tau_{A \\to B}}\\right) = \\ln\\left(\\frac{\\tau_{A \\to B}}{\\tau_{B \\to A}}\\right) $$\n该表达式完全根据可测量的 MFPT 给出了势差。用给定的数据计算此值：\n$$ \\Delta U = \\ln\\left(\\frac{20}{5}\\right) = \\ln(4) $$\n\n**4. 论证粗粒化稳态流 $J_{A B}^{\\mathrm{ss}}$ 的值，并解释其与底层的连续空间概率流场 $\\mathbf{J}(\\mathbf{x})$ 的联系。**\n\n粗粒化稳态流定义为 $J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_B^{\\mathrm{ss}} k_{B \\to A}$。如第2部分所述，该系统达到稳态的条件是细致平衡条件，$p_A^{\\mathrm{ss}} k_{A \\to B} = p_B^{\\mathrm{ss}} k_{B \\to A}$。将此直接代入流的定义，表明净流为零：\n$$ J_{A B}^{\\mathrm{ss}} = p_A^{\\mathrm{ss}} k_{A \\to B} - p_A^{\\mathrm{ss}} k_{A \\to B} = 0 $$\n粗粒化流 $J_{A B}^{\\mathrm{ss}}$ 代表了整个盆 $A$ 和整个盆 $B$ 之间的净概率质量转移速率。值为 $0$ 意味着从宏观角度看，系统处于平衡状态。从 $A$ 到 $B$ 的流出被从 $B$ 到 $A$ 的流入完美平衡。\n\n然而，底层的高维系统通常是一个非平衡稳态（NESS）。在一个连续的状态空间 $\\mathbf{x}$（例如蛋白质浓度）中，一个 NESS 由一个不随时间变化的概率密度 $P_{\\mathrm{ss}}(\\mathbf{x})$ 和一个非零的、无散度的概率流场 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$（即 $\\nabla \\cdot \\mathbf{J}_{\\mathrm{ss}} = 0$，但 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x}) \\neq \\mathbf{0}$）来描述。这种非零流是系统被能量消耗过程（如ATP水解）驱动而偏离热力学平衡的标志。这种流通常表现为状态空间中持续的循环流。\n\n粗粒化过程对这些微观细节进行了平均。离散状态 $A$ 和 $B$ 对应于连续状态空间中的大片区域（盆）。虽然微观流 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$ 可以在任何地方都非零，从而在盆内和盆之间产生旋转流，但为了使每个盆中的总概率（$p_A^{\\mathrm{ss}}$ 和 $p_B^{\\mathrm{ss}}$）随时间保持恒定，整个盆 $A$ 和整个盆 $B$ 之间的概率*净*交换必须为零。因此，粗粒化流的值为零，$J_{A B}^{\\mathrm{ss}} = 0$，是粗粒化描述达到稳态的必要条件，并且它与底层微观层面存在一个非零的非平衡流场 $\\mathbf{J}_{\\mathrm{ss}}(\\mathbf{x})$ 是完全相容的。粗粒化有效地积分掉了非平衡环流，从而得到一个满足细致平衡的描述。",
            "answer": "$$\n\\boxed{\\ln(4)}\n$$"
        },
        {
            "introduction": "在抽象模型的基础上，这个练习将我们带入现实的计算系统生物学领域。我们将处理一个细胞命运决定的经典模型：基因拨动开关。你的任务是实现一个 Fokker-Planck 方程的数值求解器，以计算完整的稳态概率分布和流场，从而让你能够可视化维持细胞身份的双稳态势景以及驱动其动态的非平衡概率流 。",
            "id": "4376575",
            "problem": "考虑一个表示相互抑制触发开关的二维随机基因调控网络。状态向量 $(x,y)$ 的宏观确定性漂移由常微分方程 (ODE) 给出\n$$\n\\frac{dx}{dt} = f_x(x,y),\\quad \\frac{dy}{dt} = f_y(x,y),\n$$\n其中方程右边代表因衰变和具有 Hill 型非线性的交叉抑制而降解的产生项。在内在噪声下的介观描述中，概率密度 $P(x,y,t)$ 的时间演化由 Fokker–Planck 方程 (FPE) 控制，该方程也称为前向 Kolmogorov 方程，\n$$\n\\frac{\\partial P(x,y,t)}{\\partial t} = -\\nabla \\cdot \\mathbf{J}(x,y,t),\n$$\n其中概率流 $\\mathbf{J}$ 由下式给出\n$$\n\\mathbf{J}(x,y,t) = \\mathbf{f}(x,y)\\,P(x,y,t) - \\mathbf{D}\\,\\nabla P(x,y,t),\n$$\n其中漂移为 $\\mathbf{f}(x,y) = (f_x(x,y), f_y(x,y))$，$\\mathbf{D} = \\mathrm{diag}(D_x, D_y)$ 是一个恒定对角扩散矩阵。在稳态下，稳态分布 $P_{\\text{ss}}(x,y)$ 及其相关的流 $\\mathbf{J}_{\\text{ss}}(x,y)$ 满足无散度条件\n$$\n\\nabla \\cdot \\mathbf{J}_{\\text{ss}}(x,y) = 0.\n$$\n该守恒定律编码了势景（来自概率分布）和非平衡流（来自环状概率流）。\n\n从上述概率的普适守恒定律和流的定义出发，您将使用有限体积法在均匀矩形网格上离散化稳态 Fokker–Planck 方程。离散化必须：\n- 在矩形域 $[0,L]\\times[0,L]$ 上的 $N_x \\times N_y$ 网格上，对 $P_{\\text{ss}}$ 使用单元中心未知数。网格间距为均匀的 $\\Delta x = L/N_x$ 和 $\\Delta y = L/N_y$，单元中心位于 $(x_i,y_j) = ((i+\\tfrac{1}{2})\\Delta x,(j+\\tfrac{1}{2})\\Delta y)$，其中 $i=0,\\ldots,N_x-1$，$j=0,\\ldots,N_y-1$。\n- 对每个单元，使用迎风格式处理对流部分 $\\mathbf{f}(x,y)\\,P$，使用中心差分处理扩散部分 $-\\mathbf{D}\\,\\nabla P$，来计算面通量。\n- 在区域边界上施加零法向通量边界条件（无通量）。\n- 对每个单元施加稳态约束 $\\nabla\\cdot\\mathbf{J}_{\\text{ss}}=0$，并施加归一化约束 $\\int P_{\\text{ss}}(x,y)\\,dx\\,dy = 1$ 以封闭线性系统。\n\n对于该触发开关网络，使用以下具有 Hill 型抑制的无量纲漂移函数：\n$$\nf_x(x,y) = \\frac{\\alpha}{1 + \\left(\\frac{y}{K}\\right)^n} - x + h,\\qquad\nf_y(x,y) = \\frac{\\alpha}{1 + \\left(\\frac{x}{K}\\right)^m} - y + s,\n$$\n其中 $\\alpha>0$ 是最大生产速率，$K>0$ 是抑制阈值（设 $K=1$），$n,m\\ge 2$ 是 Hill 系数。参数 $h$ 和 $s$ 引入了偏置项。\n\n本问题中所有量均为无量纲；不需要物理单位。问题不涉及角度；不需要角度单位。最终的数值输出必须是实值标量。\n\n您的程序必须：\n1. 使用上述有限体积法组装并求解 $P_{\\text{ss}}$ 的离散稳态 FPE。\n2. 使用中心差分计算 $\\nabla P_{\\text{ss}}$，并在单元中心处计算漂移，从而计算单元中心通量场 $\\mathbf{J}_{\\text{ss}}(x_i,y_j) = \\left(J_x(i,j), J_y(i,j)\\right)$。\n3. 通过中心差分计算单元中心的离散散度残差，\n$$\nR(i,j) = \\frac{J_x(i+1,j) - J_x(i-1,j)}{2\\Delta x} + \\frac{J_y(i,j+1) - J_y(i,j-1)}{2\\Delta y},\n$$\n在边界处使用适当的单边差分，并报告所有单元上 $R$ 的平均绝对值，作为 $\\nabla\\cdot\\mathbf{J}_{\\text{ss}}=0$ 满足程度的度量。\n\n为以下参数集测试套件实现上述要求，以确保覆盖不同的机制区域：\n- 测试用例 1（双稳态，对称，低噪声；“理想路径”）：$L=4$, $N_x=N_y=40$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_1 = \\left|1 - \\sum_{i,j} P_{\\text{ss}}(i,j)\\,\\Delta x\\,\\Delta y\\right|$。\n  - 平均绝对散度残差 $M_1 = \\frac{1}{N_x N_y}\\sum_{i,j} |R(i,j)|$。\n  - 双峰平衡度量 $B_1$，定义为高-$x$/低-$y$ 吸引盆和低-$x$/高-$y$ 吸引盆中两个概率质量中的较小者，其中吸引盆分别是矩形区域 $\\{x>2.5, y<0.5\\}$ 和 $\\{x<0.5, y>2.5\\}$。每个质量是在相应区域内 $P_{\\text{ss}}$ 值的总和乘以 $\\Delta x\\,\\Delta y$。\n- 测试用例 2（单稳态区域，中等噪声）：$L=4$, $N_x=N_y=40$, $\\alpha=1.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.05$。报告：\n  - 归一化误差 $E_2$。\n  - 平均绝对散度残差 $M_2$。\n  - $P_{\\text{ss}}$ 全局最大值位置到点 $(1,1)$ 的距离 $R_{\\max,2}$，计算公式为 $\\sqrt{(x_{\\max}-1)^2 + (y_{\\max}-1)^2}$。\n- 测试用例 3（有偏双稳态）：$L=4$, $N_x=N_y=40$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=+0.3$, $s=-0.3$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_3$。\n  - 平均绝对散度残差 $M_3$。\n  - 质量不对称性 $\\Delta_3 = M_{x\\text{-high}} - M_{y\\text{-high}}$，其中 $M_{x\\text{-high}}$ 是在 $\\{x>2.5, y<0.5\\}$ 中的概率质量，$M_{y\\text{-high}}$ 是在 $\\{x<0.5, y>2.5\\}$ 中的质量。\n- 测试用例 4（在较粗网格上的边界条件敏感性）：$L=4$, $N_x=N_y=20$, $\\alpha=3.0$, $K=1.0$, $n=4$, $m=4$, $h=0.0$, $s=0.0$, $D_x=D_y=0.03$。报告：\n  - 归一化误差 $E_4$。\n  - 平均绝对散度残差 $M_4$。\n  - 平均绝对边界法向通量 $F_4$，定义为沿左右边界单元中心的 $|J_x|$ 和沿上下边界单元中心的 $|J_y|$ 的平均值。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[E_1,\\,M_1,\\,B_1,\\,E_2,\\,M_2,\\,R_{\\max,2},\\,E_3,\\,M_3,\\,\\Delta_3,\\,E_4,\\,M_4,\\,F_4].\n$$\n所有十二个输出都必须是十进制数（浮点值）。不应打印任何其他文本。",
            "solution": "该问题要求对一个基因调控触发开关模型的二维稳态 Fokker-Planck 方程进行数值求解。解将通过在均匀网格上使用有限体积法获得，随后计算几个指定的度量。\n\n稳态下的控制方程是关于概率流的无散度条件，即 $\\nabla \\cdot \\mathbf{J}_{\\text{ss}} = 0$。流 $\\mathbf{J}_{\\text{ss}}$ 由对流（或漂移）部分和扩散部分组成：\n$$\n\\mathbf{J}_{\\text{ss}}(x,y) = \\mathbf{f}(x,y)P_{\\text{ss}}(x,y) - \\mathbf{D} \\nabla P_{\\text{ss}}(x,y)\n$$\n其中 $P_{\\text{ss}}(x,y)$ 是稳态概率分布，$\\mathbf{f}(x,y) = (f_x(x,y), f_y(x,y))$ 是确定性漂移向量，$\\mathbf{D} = \\mathrm{diag}(D_x, D_y)$ 是恒定的对角扩散矩阵。\n\n**有限体积离散化**\n\n该方法的核心是在计算网格的每个单元上以积分形式执行守恒定律 $\\nabla \\cdot \\mathbf{J}_{\\text{ss}} = 0$。区域 $[0,L] \\times [0,L]$ 被离散化为 $N_x \\times N_y$ 的单元网格。每个单元 $\\Omega_{i,j}$ 是一个以 $(x_i, y_j) = ((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y)$ 为中心的小矩形，尺寸为 $\\Delta x \\times \\Delta y$，其中 $\\Delta x = L/N_x$ 且 $\\Delta y = L/N_y$。\n\n我们在 $\\Omega_{i,j}$ 上对控制方程进行积分，并应用散度定理：\n$$\n\\int_{\\Omega_{i,j}} \\nabla \\cdot \\mathbf{J}_{\\text{ss}} \\,dA = \\oint_{\\partial\\Omega_{i,j}} \\mathbf{J}_{\\text{ss}} \\cdot \\mathbf{n} \\,ds = 0\n$$\n其中 $\\mathbf{n}$ 是指向单元边界 $\\partial\\Omega_{i,j}$ 外部的法向量。这种积分形式表明，流出单元的总概率流为零。对于矩形单元，这变为：\n$$\n\\left( J_{x, i+1/2, j} - J_{x, i-1/2, j} \\right) \\Delta y + \\left( J_{y, i, j+1/2} - J_{y, i, j-1/2} \\right) \\Delta x = 0\n$$\n这里，$J_{x, i+1/2, j}$ 表示在单元右侧面中心（位于 $x=(i+1)\\Delta x$）处计算的流的 x 分量，其他三个面（左、上、下）也类似。\n\n**数值通量近似**\n\n为继续进行，我们必须用单元中心的概率值 $P_{i,j} \\equiv P_{\\text{ss}}(x_i, y_j)$ 来近似面通量。该通量由两部分组成。\n\n1.  **扩散通量**：扩散部分 $-D_x\\frac{\\partial P}{\\partial x}$ 使用二阶中心差分进行近似。在右侧面 $(i+1/2, j)$ 处，其表达式为：\n    $$\n    -D_x \\frac{\\partial P}{\\partial x}\\bigg|_{i+1/2, j} \\approx -D_x \\frac{P_{i+1,j} - P_{i,j}}{\\Delta x}\n    $$\n\n2.  **对流通量**：对流部分 $f_x P$ 按规定需要使用迎风格式以保证稳定性。面上的 $P$ 值取自“迎风”单元，即流动起源的单元。令 $f_{x, i+1/2, j} \\equiv f_x(x_{i+1/2}, y_j)$。\n    - 如果 $f_{x, i+1/2, j} > 0$（流动从左到右），我们使用 $P_{i,j}$。\n    - 如果 $f_{x, i+1/2, j} < 0$（流动从右到左），我们使用 $P_{i+1,j}$。\n    这可以紧凑地表示为 $f_{x, i+1/2, j}^+ P_{i,j} + f_{x, i+1/2, j}^- P_{i+1,j}$，其中 $f^+ = \\max(f,0)$ 且 $f^- = \\min(f,0)$。\n\n结合两个部分，通过单元 $(i,j)$ 右侧面的总通量为：\n$$\nJ_{x, i+1/2, j} \\approx \\left( f_{x, i+1/2, j}^+ P_{i,j} + f_{x, i+1/2, j}^- P_{i+1,j} \\right) - D_x \\frac{P_{i+1,j} - P_{i,j}}{\\Delta x}\n$$\n其他三个面（$J_{x, i-1/2, j}$、$J_{y, i, j+1/2}$、$J_{y, i, j-1/2}$）的表达式也可类似推导。\n\n**线性系统的组装**\n\n将这些通量近似值代入每个单元 $(i,j)$ 的通量平衡方程，会得到一个将 $P_{i,j}$ 与其四个邻居 $P_{i \\pm 1, j}$ 和 $P_{i, j \\pm 1}$ 联系起来的线性代数方程。这会形成一个形如 $\\mathbf{A}\\mathbf{p} = \\mathbf{0}$ 的大型稀疏线性方程组，其中 $\\mathbf{p}$ 是一个包含所有未知单元概率 $P_{i,j}$ 的向量（展平为一个大小为 $N_x N_y$ 的一维数组）。矩阵 $\\mathbf{A}$ 具有五对角结构。\n\n通过在区域边界上将法向通量设置为零来引入无通量边界条件。例如，对于左边界上的单元 $(0,j)$，通过其左侧面的通量为零，即 $J_{x, -1/2, j} = 0$。这将修改边界单元的通量平衡方程。\n\n**封闭系统**\n\n齐次系统 $\\mathbf{A}\\mathbf{p} = \\mathbf{0}$ 具有非平凡解（因为每行系数之和为零），但此解仅在相差一个乘法常数的意义下是确定的。为了获得唯一且具有物理意义的概率分布，我们必须施加归一化约束：\n$$\n\\int_0^L \\int_0^L P_{\\text{ss}}(x,y) \\,dx\\,dy = 1\n$$\n其离散形式为 $\\sum_{i,j} P_{i,j} \\Delta x \\Delta y = 1$。此方程用于替换系统中一个（冗余的）通量平衡方程。通常，最后一个单元的方程会被替换。这将系统转换为一个非齐次系统 $\\mathbf{A'}\\mathbf{p} = \\mathbf{b}$，其中 $\\mathbf{A'}$ 的最后一行包含系数 $\\Delta x \\Delta y$，$\\mathbf{b}$ 的最后一个元素为 $1$。该系统有唯一解，可以使用稀疏线性求解器找到。\n\n**后处理与度量计算**\n\n在求解向量 $\\mathbf{p}$ 并将其重塑为二维数组 $P_{i,j}$ 后，计算指定的度量：\n1.  **归一化误差 ($E$)**：计算为 $\\left|1 - \\sum_{i,j} P_{i,j}\\Delta x \\Delta y\\right|$，以验证线性求解的准确性。\n2.  **单元中心通量和散度残差 ($M$)**：使用求解出的 $P_{i,j}$ 计算单元中心通量场 $\\mathbf{J}_{\\text{ss}}(x_i, y_j)$。漂移 $\\mathbf{f}$ 在单元中心求值，梯度 $\\nabla P_{\\text{ss}}$ 使用中心差分（边界处使用单边差分）进行近似。然后计算此通量场的散度 $R(i,j) = (\\nabla \\cdot \\mathbf{J}_{\\text{ss}})_{i,j}$，同样使用中心/单边差分。$R(i,j)$ 在整个网格上的平均绝对值 $M$ 量化了数值解满足原始无散度条件的程度。\n3.  **吸引盆度量 ($B_1$, $\\Delta_3$)**：通过将所有中心落在指定矩形区域（吸引盆）内的单元的 $P_{i,j} \\Delta x \\Delta y$ 求和，来计算这些区域的概率质量。这些质量用于计算双峰平衡度量 $B_1$ 和不对称性 $\\Delta_3$。\n4.  **峰值位置 ($R_{\\max,2}$)**：找到 $P_{i,j}$ 最大值的网格索引，将其转换为空间坐标 $(x_{\\max}, y_{\\max})$，并用其计算到参考点的距离。\n5.  **边界通量 ($F_4$)**：通过对所有边界单元上预先计算的单元中心法向通量分量（垂直边界上的 $|J_x|$，水平边界上的 $|J_y|$）的绝对值进行平均，来计算平均绝对法向通量。\n\n这一全面的过程能够对触发开关系统在不同参数区域下的稳态行为进行稳健的数值表征。",
            "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main orchestrator function that runs all test cases and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Bistable, symmetric, low noise\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 1\n        },\n        # Test Case 2: Monostable, moderate noise\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 1.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.05, \"Dy\": 0.05, \"case_id\": 2\n        },\n        # Test Case 3: Biased bistability\n        {\n            \"L\": 4.0, \"Nx\": 40, \"Ny\": 40, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.3, \"s\": -0.3, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 3\n        },\n        # Test Case 4: Coarser grid sensitivity\n        {\n            \"L\": 4.0, \"Nx\": 20, \"Ny\": 20, \"alpha\": 3.0, \"K\": 1.0, \n            \"n\": 4.0, \"m\": 4.0, \"h\": 0.0, \"s\": 0.0, \n            \"Dx\": 0.03, \"Dy\": 0.03, \"case_id\": 4\n        },\n    ]\n\n    all_results = []\n    for params in test_cases:\n        results = run_case(**params)\n        all_results.extend(results)\n\n    # Format the final output string as specified.\n    print(f\"[{','.join(f'{r:.8e}' for r in all_results)}]\")\n\ndef run_case(L, Nx, Ny, alpha, K, n, m, h, s, Dx, Dy, case_id):\n    \"\"\"\n    Solves the FPE for a single set of parameters and computes the required metrics.\n    \"\"\"\n    dx = L / Nx\n    dy = L / Ny\n    \n    # Cell center coordinates\n    x_centers = (np.arange(Nx) + 0.5) * dx\n    y_centers = (np.arange(Ny) + 0.5) * dy\n    \n    # Face coordinates\n    x_faces = np.arange(Nx + 1) * dx\n    y_faces = np.arange(Ny + 1) * dy\n\n    # Drift functions\n    def fx(x, y):\n        return alpha / (1 + (y / K)**n) - x + h\n    def fy(x, y):\n        return alpha / (1 + (x / K)**m) - y + s\n\n    N_vars = Nx * Ny\n    A = lil_matrix((N_vars, N_vars))\n    \n    # Assemble the matrix A\n    for j in range(Ny):\n        for i in range(Nx):\n            k = i + j * Nx # Flattened index\n            \n            # Coefficients for neighbors\n            # East face (i+1/2)\n            if i  Nx - 1:\n                f_val = fx(x_faces[i + 1], y_centers[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] += (f_pos + Dx / dx) * dy\n                A[k, k + 1] += (f_neg - Dx / dx) * dy\n\n            # West face (i-1/2)\n            if i > 0:\n                f_val = fx(x_faces[i], y_centers[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] -= (f_neg - Dx / dx) * dy\n                A[k, k - 1] -= (f_pos + Dx / dx) * dy\n\n            # North face (j+1/2)\n            if j  Ny - 1:\n                f_val = fy(x_centers[i], y_faces[j + 1])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] += (f_pos + Dy / dy) * dx\n                A[k, k + Ny] += (f_neg - Dy / dy) * dx\n            \n            # South face (j-1/2)\n            if j > 0:\n                f_val = fy(x_centers[i], y_faces[j])\n                f_pos = max(f_val, 0)\n                f_neg = min(f_val, 0)\n                A[k, k] -= (f_neg - Dy / dy) * dx\n                A[k, k - Ny] -= (f_pos + Dy / dy) * dx\n\n    # Create RHS vector and apply normalization constraint\n    b = np.zeros(N_vars)\n    A[-1, :] = dx * dy  # Replace last equation\n    b[-1] = 1.0\n\n    # Solve the linear system\n    A_csr = A.tocsr()\n    p_vec = spsolve(A_csr, b)\n    P_ss = p_vec.reshape((Ny, Nx))\n\n    # --- Post-processing and Metric Calculation ---\n\n    # Metric: Normalization Error (E)\n    norm_error = np.abs(1.0 - np.sum(P_ss) * dx * dy)\n\n    # Metric: Mean Absolute Divergence Residual (M)\n    # 1. Compute cell-centered flux J\n    yy, xx = np.meshgrid(y_centers, x_centers, indexing='ij')\n    fx_c = fx(xx, yy)\n    fy_c = fy(xx, yy)\n\n    grad_P_y, grad_P_x = np.gradient(P_ss, dy, dx)\n\n    Jx = fx_c * P_ss - Dx * grad_P_x\n    Jy = fy_c * P_ss - Dy * grad_P_y\n    \n    # 2. Compute divergence of J\n    grad_Jy_y, _ = np.gradient(Jy, dy, dx)\n    _, grad_Jx_x = np.gradient(Jx, dy, dx)\n    R = grad_Jx_x + grad_Jy_y\n    mean_abs_div_residual = np.mean(np.abs(R))\n\n    # --- Case-specific Metrics ---\n    if case_id == 1 or case_id == 3:\n        # Basins for bistability metrics\n        basin_x_high_mask = (xx > 2.5)  (yy  0.5)\n        basin_y_high_mask = (xx  0.5)  (yy > 2.5)\n        \n        mass_x_high = np.sum(P_ss[basin_x_high_mask]) * dx * dy\n        mass_y_high = np.sum(P_ss[basin_y_high_mask]) * dx * dy\n\n        if case_id == 1:\n            # Bimodality balance B1\n            bimodality_balance = min(mass_x_high, mass_y_high)\n            return [norm_error, mean_abs_div_residual, bimodality_balance]\n        else: # case_id == 3\n            # Mass asymmetry Delta3\n            mass_asymmetry = mass_x_high - mass_y_high\n            return [norm_error, mean_abs_div_residual, mass_asymmetry]\n\n    elif case_id == 2:\n        # Distance of max probability from (1,1)\n        j_max, i_max = np.unravel_index(np.argmax(P_ss), P_ss.shape)\n        x_max = x_centers[i_max]\n        y_max = y_centers[j_max]\n        R_max_2 = np.sqrt((x_max - 1.0)**2 + (y_max - 1.0)**2)\n        return [norm_error, mean_abs_div_residual, R_max_2]\n\n    elif case_id == 4:\n        # Average absolute boundary normal flux F4\n        flux_left = np.abs(Jx[:, 0])\n        flux_right = np.abs(Jx[:, -1])\n        flux_bottom = np.abs(Jy[0, :])\n        flux_top = np.abs(Jy[-1, :])\n        \n        total_abs_flux = np.sum(flux_left) + np.sum(flux_right) + np.sum(flux_bottom) + np.sum(flux_top)\n        num_boundary_points = 2 * Nx + 2 * Ny\n        avg_abs_boundary_flux = total_abs_flux / num_boundary_points\n        return [norm_error, mean_abs_div_residual, avg_abs_boundary_flux]\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "我们已经学习了如何定义和计算势景，但是细胞是如何在这个势景上的稳定命运（“山谷”）之间进行转换的呢？这项实践练习介绍了弦方法，这是一种强大的计算算法，用于寻找两个状态之间的最可能转变路径。通过实现该方法，你将能识别出关键的鞍点并计算能量壁垒，这些量最终决定了细胞命运的稳定性以及分化或重编程的速率 。",
            "id": "4376608",
            "problem": "考虑一个细胞状态变量向量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 的过阻尼随机动力学，该动力学由一个小噪声下的势景观 $U(\\mathbf{x})$ 控制，并被建模为以下 Itô 随机微分方程\n$$\n\\frac{d\\mathbf{x}}{dt} = -\\nabla U(\\mathbf{x}) + \\sqrt{2\\epsilon}\\,\\boldsymbol{\\xi}(t),\n$$\n其中 $\\epsilon  0$ 是一个小的无量纲噪声强度，$\\boldsymbol{\\xi}(t)$ 是一个标准高斯白噪声过程。在小噪声极限下，稳定细胞命运（$U$ 的局部极小值）之间的转变主要由沿着最小能量（作用量）路径穿过指数为1的鞍点的轨迹所主导。在梯度系统中，最小能量路径简化为以尽可能少的势能攀升到达两个盆地之间鞍点的路径。从位于 $\\mathbf{x}_\\mathrm{min}$ 的一个命运到位于 $\\mathbf{x}_\\mathrm{sad}$ 的鞍点的转变的能垒高度定义为能量差\n$$\n\\Delta U = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_\\mathrm{min}),\n$$\n以无量纲单位表示（无物理单位）。\n\n为下面每个势函数，实现一个基于弦方法（或等效地，概念上的微动弹性带方法）的算法，以近似两个给定稳定命运之间的最小能量路径。您的算法必须：\n- 从给定的初始猜测值开始，通过局部优化识别两个局部极小值。\n- 初始化一条连接两个极小值的离散路径（一条“弦”），并通过以下方式迭代地演化它：将内部点沿着垂直于局部路径切线的势景观梯度方向向下移动，然后进行重新参数化以保持近似均匀的弧长间距。在整个演化过程中，端点必须固定在已识别的极小值上。\n- 收敛后，将最终路径上具有最大势值的点识别为近似鞍点。然后，从该点开始，通过最小化函数 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$ 来求解 $U$ 在此最大值附近的驻点，从而精炼鞍点的位置。使用 $U$ 的 Hessian 矩阵对精炼后的点进行分类；如果其 Hessian 矩阵有一个正特征值和一个负特征值（指数为1的鞍点），则接受它；否则，使用路径上势能最高的点作为鞍点的估计值。\n- 计算相对于每个极小值的两个能垒高度：$\\Delta U_1 = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_{\\mathrm{min},1})$ 和 $\\Delta U_2 = U(\\mathbf{x}_\\mathrm{sad}) - U(\\mathbf{x}_{\\mathrm{min},2})$，以无量纲单位表示。\n\n测试套件的势函数（均为无量纲）：\n1. $U_1(x,y) = \\frac{1}{4}\\,(x^2 - 1)^2 + \\frac{1}{2}\\,(y + \\frac{1}{2}x)^2$。\n2. $U_2(x,y) = (x^2 - 1)^2 + y^2 + \\frac{1}{2}\\,x y$。\n3. $U_3(x,y) = (x^2 - 1)^2 + y^2$。\n\n对于每个势函数，使用以下测试参数以确保覆盖一般情况和边界情况：\n- 情况 1（弯曲耦合路径）：势函数 $U_1$，极小值的初始猜测值 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.6)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,-0.6)$，路径节点数 $N = 101$，弦演化的时间步长 $\\Delta t = 0.05$，最大迭代次数 $K = 400$。\n- 情况 2（各向异性耦合双阱）：势函数 $U_2$，极小值的初始猜测值 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.3)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,-0.3)$，$N = 101$，$\\Delta t = 0.05$，$K = 600$。\n- 情况 3（解耦的对称双阱；边界情况）：势函数 $U_3$，极小值的初始猜测值 $\\mathbf{x}_{\\mathrm{min},1}^{(0)} = (-1.2,\\,0.0)$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)} = (1.2,\\,0.0)$，$N = 101$，$\\Delta t = 0.05$，$K = 300$。\n\n您的程序必须：\n- 为每个势函数实现解析梯度 $\\nabla U$。\n- 使用局部优化器从提供的猜测值开始识别极小值。\n- 通过将 $-\\nabla U$ 投影到垂直于局部切线的方向，并在每次迭代中重新参数化为均匀弧长来演化弦。\n- 通过最小化 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$ 来精炼鞍点，并通过对 $\\nabla U$ 进行数值微分得到的 $U$ 的 Hessian 矩阵进行分类。\n- 对于每种情况，返回两个能垒高度 $\\Delta U_1$ 和 $\\Delta U_2$ 以及鞍点坐标 $(x_\\mathrm{sad}, y_\\mathrm{sad})$，所有值均为浮点数并四舍五入到六位小数。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每种情况贡献一个形式为 $[\\Delta U_1,\\Delta U_2,x_\\mathrm{sad},y_\\mathrm{sad}]$ 的子列表。例如，输出必须如下所示\n$$\n[[\\Delta U_1^{(1)},\\Delta U_2^{(1)},x_\\mathrm{sad}^{(1)},y_\\mathrm{sad}^{(1)}],[\\Delta U_1^{(2)},\\Delta U_2^{(2)},x_\\mathrm{sad}^{(2)},y_\\mathrm{sad}^{(2)}],[\\Delta U_1^{(3)},\\Delta U_2^{(3)},x_\\mathrm{sad}^{(3)},y_\\mathrm{sad}^{(3)}]].\n$$\n所有量都是无量纲的（无单位）。不使用角度。不需要百分比。",
            "solution": "用户提供的问题是有效的，因为它具有科学依据、适定且客观。它基于统计物理学和计算化学中已确立的原则，特别是使用弦方法在势能面上寻找最小能量路径，概述了一个清晰的计算任务。所有必要的参数、函数和程序步骤都已提供。\n\n问题的核心是实现一个算法，用于近似给定势函数 $U(\\mathbf{x})$ 的两个局部极小值之间的最小能量路径 (MEP)。如所提供的 Itô 随机微分方程所述，MEP 是理解随机系统中稳定态（例如细胞命运）之间转变速率的关键概念。在低噪声极限 ($\\epsilon \\to 0$)下，最概然的转变路径就是 MEP。\n\n解决方案是通过遵循问题陈述中详述的步骤顺序来实现的。\n\n### 步骤 1：势函数和梯度的定义\n\n对于每个势函数 $U_k(x, y)$，推导出其解析梯度 $\\nabla U_k = \\left(\\frac{\\partial U_k}{\\partial x}, \\frac{\\partial U_k}{\\partial y}\\right)$，以用于后续的数值计算过程。\n1.  对于 $U_1(x,y) = \\frac{1}{4}(x^2 - 1)^2 + \\frac{1}{2}(y + \\frac{1}{2}x)^2$，梯度为：\n    $$ \\nabla U_1(x,y) = \\left( x(x^2 - 1) + \\frac{1}{2}\\left(y + \\frac{1}{2}x\\right), y + \\frac{1}{2}x \\right) = \\left( x^3 - \\frac{3}{4}x + \\frac{1}{2}y, \\frac{1}{2}x + y \\right) $$\n2.  对于 $U_2(x,y) = (x^2 - 1)^2 + y^2 + \\frac{1}{2}xy$，梯度为：\n    $$ \\nabla U_2(x,y) = \\left( 2(x^2 - 1)(2x) + \\frac{1}{2}y, 2y + \\frac{1}{2}x \\right) = \\left( 4x^3 - 4x + \\frac{1}{2}y, \\frac{1}{2}x + 2y \\right) $$\n3.  对于 $U_3(x,y) = (x^2 - 1)^2 + y^2$，梯度为：\n    $$ \\nabla U_3(x,y) = \\left( 2(x^2 - 1)(2x), 2y \\right) = \\left( 4x^3 - 4x, 2y \\right) $$\n这些函数被实现为接受一个二维向量 $\\mathbf{x} = (x, y)$ 作为输入。\n\n### 步骤 2：定位极小值\n\n对应于细胞命运的两个稳定态（$U$ 的局部极小值）是通过执行局部优化找到的。从提供的初始猜测值 $\\mathbf{x}_{\\mathrm{min},1}^{(0)}$ 和 $\\mathbf{x}_{\\mathrm{min},2}^{(0)}$ 开始，我们使用一种拟牛顿优化算法 (L-BFGS-B)，该算法在 `scipy.optimize.minimize` 中实现。这种方法高效且稳健，尤其是在提供了目标函数的解析梯度（雅可比矩阵）时。目标函数是势函数 $U(\\mathbf{x})$，其雅可比矩阵是 $\\nabla U(\\mathbf{x})$。\n\n### 步骤 3：弦方法的实现\n\n最小能量路径由一条“弦”来近似，它是在位形空间中由 $N$ 个点（节点）组成的离散序列。\n\n**a. 初始化：** 该弦被初始化为一条在 $\\mathbb{R}^2$ 中连接上一步找到的两个极小值 $\\mathbf{x}_{\\mathrm{min},1}$ 和 $\\mathbf{x}_{\\mathrm{min},2}$ 的直线。$N$ 个节点沿此线段均匀分布。\n\n**b. 弦的演化：** 弦经过 $K$ 次迭代进行演化。在每次迭代中，弦的两个端点保持固定在极小值处。$N-2$ 个内部节点通过两个子步骤进行更新：\n1.  **垂直动力学：** 每个内部节点 $\\mathbf{x}_i$ 根据势导出力的分量 $\\mathbf{F}(\\mathbf{x}_i) = -\\nabla U(\\mathbf{x}_i)$ 进行移动，该分量垂直于该点处的路径。节点 $\\mathbf{x}_i$ 处的局部切向量 $\\boldsymbol{\\tau}_i$ 使用中心差分格式进行近似：$\\boldsymbol{\\tau}_i \\propto (\\mathbf{x}_{i+1} - \\mathbf{x}_{i-1})$。然后，垂直力为 $\\mathbf{F}_{\\perp,i} = \\mathbf{F}_i - (\\mathbf{F}_i \\cdot \\hat{\\boldsymbol{\\tau}}_i) \\hat{\\boldsymbol{\\tau}}_i$，其中 $\\hat{\\boldsymbol{\\tau}}_i$ 是单位化的切向量。节点通过一个欧拉步进行更新：$\\mathbf{x}_i \\leftarrow \\mathbf{x}_i + \\Delta t \\, \\mathbf{F}_{\\perp,i}$。此步骤将弦向势能面的“下坡”方向移动，降低其总势能，而投影操作可防止节点沿路径滑动。\n2.  **重新参数化：** 垂直方向的更新会破坏节点的均匀间距。为了保持路径的平滑表示，节点会沿着当前路径重新分布，以确保它们具有相等的弧长间距。这通过首先计算沿路径的累积弧长，然后使用线性插值（`numpy.interp`）在总弧长的均匀间隔处找到新节点的坐标来实现。\n\n### 步骤 4：鞍点的识别与精炼\n\n经过 $K$ 次迭代后，弦提供了 MEP 的一个近似。\n\n**a. 初始估计：** 转变的鞍点是沿 MEP 势能最高的点。通过识别收敛后的弦上具有最高势值 $U$ 的节点，找到一个初始估计值 $\\mathbf{x}_{\\mathrm{sad, initial}}$。\n\n**b. 精炼：** 鞍点的精度得到提高。一个真实的鞍点是 $U$ 的一个驻点（即 $\\nabla U = \\mathbf{0}$），具有特定的 Hessian 结构。为了找到这个点，我们从 $\\mathbf{x}_{\\mathrm{sad, initial}}$ 开始，试图最小化梯度范数的平方 $F(\\mathbf{x}) = \\frac{1}{2}\\|\\nabla U(\\mathbf{x})\\|^2$。L-BFGS-B 算法再次被用于此最小化任务。一个真实的驻点对应于 $F(\\mathbf{x}) = 0$。\n\n**c. 分类：** 精炼后的点 $\\mathbf{x}_{\\mathrm{sad, refined}}$ 通过检查在该点评估的 Hessian 矩阵 $H_{ij} = \\frac{\\partial^2 U}{\\partial x_i \\partial x_j}$ 的特征值来进行分类。根据问题说明，Hessian 矩阵是通过对解析梯度 $\\nabla U$ 使用中心有限差分近似进行数值计算的。如果一个点的 Hessian 矩阵有一个负特征值和一个正特征值，则该点被分类为指数为1的鞍点。如果精炼后的点被确认为驻点（即 $F(\\mathbf{x}_{\\mathrm{sad, refined}}) \\approx 0$）并且是指数为1的鞍点，则它被接受为最终的鞍点 $\\mathbf{x}_{\\mathrm{sad}}$。否则，使用路径上势能最大点得到的未精炼估计值 $\\mathbf{x}_{\\mathrm{sad, initial}}$。\n\n### 步骤 5：能垒高度计算和输出格式化\n\n最后，在确定了极小值和鞍点的位置后，正向和反向转变的两个能垒计算如下：\n$$ \\Delta U_1 = U(\\mathbf{x}_{\\mathrm{sad}}) - U(\\mathbf{x}_{\\mathrm{min},1}) $$\n$$ \\Delta U_2 = U(\\mathbf{x}_{\\mathrm{sad}}) - U(\\mathbf{x}_{\\mathrm{min},2}) $$\n对于三个测试用例中的每一个，收集计算出的能垒高度和鞍点坐标。这些数值结果四舍五入到六位小数，并且最终输出被格式化为表示列表的列表的单个字符串，按要求不含空格。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the three specified test cases.\n    It implements the string method to find minimum energy paths and calculates\n    transition barrier heights.\n    \"\"\"\n\n    def get_potential_functions(potential_name):\n        \"\"\"\n        Returns the potential function U and its analytic gradient gradU for a given name.\n        \"\"\"\n        if potential_name == \"U1\":\n            U = lambda p: 0.25 * (p[0]**2 - 1)**2 + 0.5 * (p[1] + 0.5 * p[0])**2\n            gradU = lambda p: np.array([p[0]**3 - 0.75 * p[0] + 0.5 * p[1], 0.5 * p[0] + p[1]])\n        elif potential_name == \"U2\":\n            U = lambda p: (p[0]**2 - 1)**2 + p[1]**2 + 0.5 * p[0] * p[1]\n            gradU = lambda p: np.array([4*p[0]**3 - 4*p[0] + 0.5*p[1], 2*p[1] + 0.5*p[0]])\n        elif potential_name == \"U3\":\n            U = lambda p: (p[0]**2 - 1)**2 + p[1]**2\n            gradU = lambda p: np.array([4*p[0]**3 - 4*p[0], 2*p[1]])\n        else:\n            raise ValueError(f\"Unknown potential: {potential_name}\")\n        return U, gradU\n\n    def find_mep_and_barriers(potential_name, x_guess1, x_guess2, N, dt, K):\n        \"\"\"\n        Calculates the MEP, saddle point, and barrier heights for a given potential and parameters.\n        \"\"\"\n        U, gradU = get_potential_functions(potential_name)\n\n        # 1. Find local minima using L-BFGS-B with analytic gradient\n        res1 = minimize(U, x_guess1, jac=gradU, method='L-BFGS-B')\n        min1 = res1.x\n        res2 = minimize(U, x_guess2, jac=gradU, method='L-BFGS-B')\n        min2 = res2.x\n\n        # 2. Initialize string (path) as a linear interpolation between minima\n        path = np.linspace(min1, min2, N)\n\n        # 3. Evolve string for K iterations\n        for _ in range(K):\n            path_copy = path.copy()\n            # a. Perpendicular gradient step for interior nodes\n            for i in range(1, N - 1):\n                tangent = path[i+1] - path[i-1]\n                norm_tangent = np.linalg.norm(tangent)\n                if norm_tangent > 1e-9:\n                    tangent /= norm_tangent\n                else: \n                    continue\n\n                force = -gradU(path[i])\n                force_perp = force - np.dot(force, tangent) * tangent\n                path_copy[i] += dt * force_perp\n            path = path_copy\n\n            # b. Reparameterization to uniform arc length\n            arc_lengths = np.cumsum(np.linalg.norm(np.diff(path, axis=0), axis=1))\n            arc_lengths = np.insert(arc_lengths, 0, 0)\n            total_length = arc_lengths[-1]\n\n            if total_length  1e-9:\n                path = np.linspace(min1, min2, N)\n                continue\n            \n            target_arc_lengths = np.linspace(0, total_length, N)\n            \n            interp_x = np.interp(target_arc_lengths, arc_lengths, path[:, 0])\n            interp_y = np.interp(target_arc_lengths, arc_lengths, path[:, 1])\n            path = np.vstack([interp_x, interp_y]).T\n            \n            path[0], path[-1] = min1, min2 # Enforce fixed endpoints\n\n        # 4. Identify and refine saddle point\n        # a. Initial estimate from path maximum\n        potentials_on_path = np.array([U(p) for p in path])\n        saddle_idx_initial = np.argmax(potentials_on_path)\n        saddle_initial = path[saddle_idx_initial]\n\n        # b. Refine by minimizing F(x) = 1/2*||gradU(x)||^2\n        f_to_minimize = lambda p: 0.5 * np.dot(gradU(p), gradU(p))\n        res_saddle = minimize(f_to_minimize, saddle_initial, method='L-BFGS-B', tol=1e-10)\n        saddle_refined = res_saddle.x\n\n        # c. Classify refined point using numerical Hessian\n        h = 1e-6\n        hessian = np.zeros((2, 2))\n        hessian[0, 0] = (gradU(saddle_refined + [h, 0])[0] - gradU(saddle_refined - [h, 0])[0]) / (2 * h)\n        hessian[1, 1] = (gradU(saddle_refined + [0, h])[1] - gradU(saddle_refined - [0, h])[1]) / (2 * h)\n        hessian[0, 1] = (gradU(saddle_refined + [0, h])[0] - gradU(saddle_refined - [0, h])[0]) / (2 * h)\n        hessian[1, 0] = (gradU(saddle_refined + [h, 0])[1] - gradU(saddle_refined - [h, 0])[1]) / (2 * h)\n        hessian = 0.5 * (hessian + hessian.T)\n        \n        eigenvalues = np.linalg.eigvalsh(hessian)\n\n        is_stationary = res_saddle.fun  1e-8\n        is_index1_saddle = eigenvalues[0]  0 and eigenvalues[1] > 0\n\n        if is_stationary and is_index1_saddle:\n            saddle_final = saddle_refined\n        else:\n            saddle_final = saddle_initial\n\n        # 5. Compute barrier heights\n        U_min1, U_min2 = U(min1), U(min2)\n        U_sad = U(saddle_final)\n        \n        delta_U1, delta_U2 = U_sad - U_min1, U_sad - U_min2\n        \n        return [round(val, 6) for val in [delta_U1, delta_U2, saddle_final[0], saddle_final[1]]]\n\n    \n    test_cases = [\n        {\"name\": \"U1\", \"guess1\": np.array([-1.2, 0.6]), \"guess2\": np.array([1.2, -0.6]), \"N\": 101, \"dt\": 0.05, \"K\": 400},\n        {\"name\": \"U2\", \"guess1\": np.array([-1.2, 0.3]), \"guess2\": np.array([1.2, -0.3]), \"N\": 101, \"dt\": 0.05, \"K\": 600},\n        {\"name\": \"U3\", \"guess1\": np.array([-1.2, 0.0]), \"guess2\": np.array([1.2, 0.0]), \"N\": 101, \"dt\": 0.05, \"K\": 300},\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = find_mep_and_barriers(case[\"name\"], case[\"guess1\"], case[\"guess2\"], case[\"N\"], case[\"dt\"], case[\"K\"])\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}