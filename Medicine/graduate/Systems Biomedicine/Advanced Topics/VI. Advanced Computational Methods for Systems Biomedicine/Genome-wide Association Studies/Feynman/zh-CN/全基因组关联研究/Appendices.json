{
    "hands_on_practices": [
        {
            "introduction": "全基因组关联研究 (GWAS) 的一个核心挑战是多重检验问题。由于同时测试数百万个遗传变异，若不进行校正，仅凭偶然性就极有可能产生大量假阳性结果。本练习旨在通过应用Bonferroni校正来巩固对控制全族错误率（FWER）重要性的理解，并计算出在GWAS中广泛使用的标准显著性阈值 。",
            "id": "1494362",
            "problem": "一个遗传学家团队正在进行一项全基因组关联分析（GWAS），以识别与一种新发现的复杂疾病相关的遗传标记。GWAS通过扫描许多个体的基因组，以确定与对照组相比，是否存在某些特定的遗传变异在患有该疾病的人群中更常见。本研究中分析的遗传变异是单核苷酸多态性（SNPs）。\n\n在这项特定研究中，研究人员正在同时检验 $m = 1,000,000$ 个独立的SNPs与该疾病的统计关联。传统上，对于单次统计检验，显著性的p值阈值（α水平）设定为 $\\alpha = 0.05$。然而，进行如此大量的检验会显著增加纯粹由偶然机会导致至少出现一个“假阳性”结果（I类错误）的概率。\n\n为了解决这个多重检验问题，研究团队决定控制家族错误率（FWER），其定义为在所有进行的检验中犯一次或多次I类错误的概率。他们的目标是将FWER保持在0.05或以下。为实现这一目标，他们将对其显著性阈值应用Bonferroni校正。\n\n给定待检验的独立SNPs数量和期望的FWER，计算一个SNP为了被认为是统计显著的所需满足的、经过Bonferroni校正后的新p值阈值。请用科学记数法表示你的答案。",
            "solution": "根据Bonferroni程序，家族错误率满足Bonferroni不等式：\n$$\n\\text{FWER} \\leq \\sum_{i=1}^{m} \\alpha_{i}.\n$$\n如果 $m$ 个检验中的每一个都以相同的单次检验显著性水平 $\\alpha^{*}$ 进行，则\n$$\n\\text{FWER} \\leq m \\alpha^{*}.\n$$\n为了将FWER控制在期望的水平 $\\alpha$ ，选择 $\\alpha^{*}$ 使得\n$$\nm \\alpha^{*} \\leq \\alpha \\quad \\Rightarrow \\quad \\alpha^{*} = \\frac{\\alpha}{m}.\n$$\n已知 $\\alpha = 0.05$ 且 $m = 1{,}000{,}000 = 10^{6}$，将 $0.05 = 5 \\times 10^{-2}$ 代入计算\n$$\n\\alpha^{*} = \\frac{5 \\times 10^{-2}}{10^{6}} = 5 \\times 10^{-2-6} = 5 \\times 10^{-8}.\n$$\n因此，经过Bonferroni校正后的p值阈值为 $5 \\times 10^{-8}$。",
            "answer": "$$\\boxed{5 \\times 10^{-8}}$$"
        },
        {
            "introduction": "在GWAS分析中，获得统计上显著的结果仅仅是第一步；确保这些关联不是由研究设计中的系统性偏差所引起同样至关重要。这种被称为“批次效应”的混杂因素，如果与病例-对照状态相关联，可能会产生大量虚假的关联信号。本练习将挑战您像一名数据侦探一样思考，从一个看似取得了惊人发现的研究中，识别出最可能导致其结果出现偏差的根本原因 。",
            "id": "1494331",
            "problem": "一个大型研究联盟正在进行一项全基因组关联研究 (GWAS)，以识别与一种复杂呼吸系统疾病“航空代谢综合征” (Aero-Metabolic Syndrome, AMS) 相关的遗传变异。该研究设计涉及从一个专业呼吸科诊所网络招募的`10,000`名病例，以及从一个普通人群健康登记系统中选择的`10,000`名对照。为有效管理大样本量，基因分型过程被分布式进行。所有`10,000`名病例的DNA样本在一个中央实验室使用“BioArray v2.0”平台进行处理，并对数百万个单核苷酸多态性 (SNP) 进行了基因分型。与此同时，所有`10,000`名对照的DNA样本在另一个设施使用“GenoChip v3.5”平台进行处理和基因分型。\n\n在来自两个平台的数据被合并并经过标准质量控制后，对每个SNP进行了统计关联检验。分析揭示了一个惊人的结果：分布在每条染色体上的数以万计的SNP都显示出与AMS有统计学显著的关联，这远远超过了复杂疾病GWAS的典型发现。\n\n下列哪个选项为这种全基因组范围内显著关联的过量现象提供了最合理的解释？\n\nA. 人群分层：病例组和对照组来自具有系统性不同遗传背景的人群，这些与遗传背景相关的等位基因频率差异被误解为疾病关联。\n\nB. 多基因结构：AMS是一种高度多基因的疾病，其遗传风险确实由遍布整个基因组的数万个常见变异的累积微小效应决定。\n\nC. 选择偏倚：从专业诊所招募病例导致队列患有更严重的疾病形式，富集了大量在普通人群对照组中未发现的罕见、高影响变异。\n\nD. 系统性基因分型偏倚：两种不同的基因分型平台在等位基因测量上存在微小、一致且平台特异性的不准确性，由于这些不准确性与病例-对照标签完全相关，从而产生了广泛的假阳性信号。\n\nE. 隐性亲缘关系：病例组在不知情的情况下包含了大量有近亲关系的个体，这违反了样本独立性的统计假设，并夸大了家族内部共享位点的关联信号。",
            "solution": "我们将单个SNP的关联检验形式化为等位基因卡方检验或病例状态对基因型的逻辑斯蒂回归。设 $Y \\in \\{0,1\\}$ 表示病例状态，$G \\in \\{0,1,2\\}$ 表示编码后的基因型，并考虑在逻辑斯蒂模型 $\\ln\\left(\\frac{\\Pr(Y=1 \\mid G)}{\\Pr(Y=0 \\mid G)}\\right) = \\alpha + \\beta_{G} G$ 中，对每个SNP的原假设 $H_{0}: \\beta_{G} = 0$。在正确的模型设定且无混杂因素的情况下，似然比检验统计量或沃尔德检验统计量在 $H_{0}$ 下服从渐近 $\\chi^{2}_{1}$ 分布，因此，在复杂疾病中，除了少数真实的关联外，整个基因组的p值在原假设下应近似服从均匀分布。\n\n观察到的模式是，在每条染色体上都出现了全基因组范围内的显著关联过量，有数以万计的SNP达到了显著性水平。这种普遍的膨胀现象表明存在一种系统性的、影响了绝大部分SNP的对原假设的偏离。我们通过将每个选项与检验行为联系起来进行检验。\n\n选项B (多基因结构)：在一个高度多基因的性状中，许多变异具有微小的真实效应。在严格的全基因组阈值 $\\alpha_{GW}$ (例如，$\\alpha_{GW} \\approx 5 \\times 10^{-8}$) 下检测到某个SNP的效能取决于关联检验的非中心化参数 $\\Lambda$。对于一个加性检验，一个标准的近似给出 $\\Lambda \\approx N_{\\text{eff}} \\cdot 2 p (1 - p) \\cdot (\\ln \\theta)^{2}$，其中 $p$ 是次要等位基因频率，$\\theta$ 是每个等位基因的比值比，$N_{\\text{eff}}$ 是一个由病例和对照组数量决定的有效样本量函数。对于具有较小 $\\ln \\theta$ 的实际复杂性状，即使是大的 $N_{\\text{eff}}$ 在 $\\alpha_{GW}$ 水平下也只能产生有限的效能。因此，仅凭多基因性，用这个样本量并不能产生数以万计的全基因组显著位点；它产生的是一种可以通过如LD得分回归或多基因评分等方法检测到的多基因信号，而不是普遍的单SNP显著性。\n\n选项C (对严重性的选择偏倚)：招募更严重的病例可能会富集罕见的、高影响的变异。基因分型芯片主要针对常见变异；罕见的、效应严重的等位基因通常标记效果不佳。此外，这种富集并不会在整个基因组的常见SNP上造成一致的等位基因频率差异；它不会在常见变异上产生广泛的假阳性。\n\n选项E (隐性亲缘关系)：亲缘关系违反了独立性假设，从而影响方差估计，并且在未建模的情况下会夸大检验统计量。然而，这种夸大通常取决于共享模式，并且并非在所有SNP上都一致；在实践中，它会产生一个适度的、全基因组范围的膨胀因子，有时还会产生局部信号，而不是遍布所有染色体的数以万计的显著关联。此外，亲缘关系会降低有效样本量，在使用正确的标准误后，这通常会减少而不是大量增加全基因组显著位点的数量。\n\n选项A (人群分层)：病例组和对照组之间系统性的遗传背景差异会因人口历史而非疾病，导致全基因组范围的等位基因频率差异，从而夸大许多SNP的关联统计量。如果不加以校正，这很可能造成广泛的显著性。然而，标准的GWAS流程包括对遗传背景主成分的校正，这通常可以减轻大部分的分层效应。虽然A可以解释广泛的膨胀，但本研究的设计提供了一个更直接、更强的混杂来源。\n\n选项D (来自不同平台的系统性基因分型偏倚)：在此情况下，基因分型平台与表型完全混杂：所有病例使用 BioArray v2.0，所有对照使用 GenoChip v3.5。设 $B \\in \\{0,1\\}$ 表示平台，病例为 $B=1$，对照为 $B=0$。设真实的加性基因型为 $G$，但测量的基因型为 $\\tilde{G} = G + \\epsilon_{B}$，其中由于差异性检出、差异性缺失或探针化学性质，导致 $E[\\epsilon_{1}] \\neq E[\\epsilon_{0}]$ 或误差分布因平台而异。病例组和对照组之间测得的平均基因型的期望差异是\n$$\nE[\\tilde{G} \\mid Y=1] - E[\\tilde{G} \\mid Y=0] = \\underbrace{E[G \\mid Y=1] - E[G \\mid Y=0]}_{\\Delta \\text{ (真实效应)}} + \\underbrace{E[\\epsilon_{1}] - E[\\epsilon_{0}]}_{\\delta \\text{ (平台偏倚)}}.\n$$\n对于大多数SNP，在原假设下，$\\Delta = 0$，但只要存在平台特异性的检出偏倚，就有 $\\delta \\neq 0$。由于 $B$ 与 $Y$ 完全共线，因此无法在关联模型中对 $B$ 进行校正；遗漏变量偏倚会将平台引起的差异归因于基因型系数，从而产生虚假的关联。等位基因卡方检验的检验统计量近似为\n$$\nT \\approx \\frac{\\left(\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}}\\right)^{2}}{\\hat{V}},\n$$\n其中 $\\hat{p}_{\\text{case}}$ 和 $\\hat{p}_{\\text{control}}$ 是观测到的等位基因频率，$\\hat{V}$ 是在原假设下估计的方差。如果由于平台偏倚，在许多SNP上都有 $\\hat{p}_{\\text{case}} - \\hat{p}_{\\text{control}} \\approx \\delta$，那么 $T$ 就会在全基因组范围内被夸大。与削弱关联的随机非差异性测量误差不同，这是一种与结局状态相关的差异性错分，它在许多SNP上同时产生偏离原假设的偏倚，这与观察到的遍布所有染色体的数以万计的显著位点的模式完全匹配。\n\n鉴于所有病例和对照组都在不同设施的不同平台上进行基因分型的这一具体研究设计细节，与病例-对照状态完全相关的系统性、平台特异性基因分型偏倚是全基因组范围内显著关联过量现象的最合理和最直接的解释。\n\n因此，正确选项是D。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "全基因组关联研究 (GWAS) 的一个强大应用是构建多基因风险评分 (PRS)，它汇总了许多遗传变异的微小效应，以预测个体对某种性状或疾病的遗传易感性。这个高级的编程练习将指导您完成从模拟GWAS数据到构建和评估PRS的整个流程。通过这个实践，您将把统计遗传学的理论与生物信息学的实际应用联系起来，深入理解PRS的构建原理及其预测性能的评估方法 。",
            "id": "2394707",
            "problem": "你的任务是在一个模拟的全基因组关联研究 (GWAS) 环境中构建一个多基因风险评分 (PRS)，并评估其作为单核苷酸多态性 (SNP) 纳入阈值的函数的预测准确性。目标是为几种参数配置定义、计算并报告预测相关性的平方。\n\n定义与设置：\n\n- 全基因组关联研究 (GWAS) 检查遗传变异与性状之间的关联。考虑 $m$ 个单核苷酸多态性 (SNP)，每个都有一个次要等位基因频率 (MAF)。对于每个 SNP $j \\in \\{1,\\ldots,m\\}$，个体的基因型被编码为次要等位基因的计数，取值为 $\\{0,1,2\\}$。\n- 对于每个 SNP $j$，其 MAF $p_j$ 从区间 $[0.05, 0.5]$ 上的连续均匀分布中独立抽取。在哈迪-温伯格平衡下，将每个基因型条目模拟为从 $\\mathrm{Binomial}(2, p_j)$ 分布中进行的独立抽样。\n- 将样本分为大小为 $n_{\\text{train}}$ 的训练队列和大小为 $n_{\\text{test}}$ 的测试队列。令 $\\mathbf{G}_{\\text{train}} \\in \\mathbb{R}^{n_{\\text{train}} \\times m}$ 和 $\\mathbf{G}_{\\text{test}} \\in \\mathbb{R}^{n_{\\text{test}} \\times m}$ 为相应的基因型矩阵。\n- 使用训练队列的统计数据对 SNP 列进行标准化：对于每个 SNP $j$，计算 $\\mathbf{G}_{\\text{train}}$ 中第 $j$ 列的训练均值 $\\mu_j$ 和标准差 $\\sigma_j$。通过以下方式定义标准化矩阵 $\\mathbf{X}_{\\text{train}}$ 和 $\\mathbf{X}_{\\text{test}}$：\n  $$X_{\\text{train}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0,\n  \\end{cases}\n  \\qquad\n  X_{\\text{test}}[i,j] = \\begin{cases}\n  \\dfrac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}  \\text{若 } \\sigma_j  0,\\\\\n  0  \\text{若 } \\sigma_j = 0.\n  \\end{cases}$$\n  如果 $\\sigma_j = 0$，则在两个队列中都将该标准化列视为恒等于 $0$。\n- 从 $\\{1,\\ldots,m\\}$ 中不放回地均匀选择 $k$ 个因果 SNP 索引；定义真实效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$，使得对于非因果的 $j$，$\\beta^{\\star}_j = 0$，而原始因果效应作为 $\\mathcal{N}(0,1)$ 的独立抽样得出。\n- 令狭义遗传力为 $h^2 \\in [0,1]$。缩放原始效应向量以使训练集中的遗传方差等于 $h^2$，具体如下。计算训练集中的遗传成分 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$，其方差为 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$，并设置：\n  $$\\boldsymbol{\\beta}^{\\star} = \\begin{cases}\n  \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\dfrac{h^2}{v_g}}  \\text{若 } v_g  0,\\\\\n  \\mathbf{0}  \\text{若 } v_g = 0.\n  \\end{cases}$$\n  将环境噪声方差定义为 $\\sigma_e^2 = 1 - h^2$。\n- 通过以下方式在两个队列中生成表型：\n  $$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}),$$\n  $$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I}).$$\n- 在训练队列中，为每个 SNP $j$ 拟合一个带截距的线性模型来进行单变量关联分析，并令 $p_j$ 为 SNP $j$ 的斜率等于 $0$ 的零假设的双边 $p$ 值。等价地，如果 $r_j$ 表示 $\\mathbf{X}_{\\text{train}}$ 的第 $j$ 列与 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关系数，自由度为 $\\nu = n_{\\text{train}} - 2$，则定义 $t$ 统计量为：\n  $$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu},$$\n  以及双边 $p$ 值：\n  $$p_j = 2 \\, \\mathbb{P}\\left(T_{\\nu} \\ge |t_j|\\right),$$\n  其中 $T_{\\nu}$ 是一个自由度为 $\\nu$ 的学生 t 分布随机变量。如果训练集中 SNP $j$ 的方差为零或 $\\mathbf{y}_{\\text{train}}$ 的方差为零，则设置 $p_j = 1$。\n- 对于给定的阈值 $p_T \\in (0,1]$，定义纳入的 SNP 集合 $S(p_T) = \\{j \\in \\{1,\\ldots,m\\} \\mid p_j \\le p_T\\}$。令 $\\hat{\\beta}_j$ 为在训练队列中估计的 SNP $j$ 的单变量普通最小二乘法斜率（带截距）。将测试集在阈值 $p_T$ 下的 PRS 定义为：\n  $$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j].$$\n  如果 $S(p_T)$ 为空，则将 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 定义为零向量。\n- 将预测准确性定义为测试队列上的决定系数，\n  $$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2,$$\n  其中 $\\mathrm{Corr}$ 表示皮尔逊相关性。如果在测试队列中 $\\mathrm{PRS}_{\\text{test}}(p_T)$ 或 $\\mathbf{y}_{\\text{test}}$ 的方差为零，则设置 $R^2(p_T) = 0$。\n\n任务：\n\n- 对于下方测试套件中的每个参数集，使用提供的随机种子执行上述模拟和分析。对于每个指定的阈值列表，按给定顺序计算每个 $p_T$ 的 $R^2(p_T)$。\n- 报告每个 $R^2(p_T)$ 值，四舍五入到 $6$ 位小数。\n\n测试套件：\n\n- 情况 A：种子 $= 42$，$n_{\\text{train}} = 1500$，$n_{\\text{test}} = 1000$，$m = 3000$，$k = 150$，$h^2 = 0.5$，阈值 $= \\left[10^{-8}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 5 \\times 10^{-1}, 1\\right]$。\n- 情况 B：种子 $= 7$，$n_{\\text{train}} = 300$，$n_{\\text{test}} = 300$，$m = 1500$，$k = 50$，$h^2 = 0.5$，阈值 $= \\left[10^{-20}, 10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况 C：种子 $= 2023$，$n_{\\text{train}} = 800$，$n_{\\text{test}} = 800$，$m = 2000$，$k = 0$，$h^2 = 0.0$，阈值 $= \\left[10^{-5}, 10^{-3}, 10^{-2}, 10^{-1}, 1\\right]$。\n- 情况 D：种子 $= 99$，$n_{\\text{train}} = 1200$，$n_{\\text{test}} = 800$，$m = 2500$，$k = 100$，$h^2 = 0.8$，阈值 $= \\left[10^{-8}, 10^{-6}, 10^{-4}, 10^{-2}, 1\\right]$。\n\n边界情况约定：\n\n- 如果任何 SNP 列在训练队列中的方差为零，则在两个队列中都将其标准化值设为零，其估计效应 $\\hat{\\beta}_j$ 设为 $0$，其 $p_j$ 设为 $1$。\n- 如果训练表型方差为零，则将所有 $\\hat{\\beta}_j$ 设为 $0$，所有 $p_j$ 设为 $1$。\n- 如果测试 PRS 或测试表型的方差为零，则对该阈值设置 $R^2(p_T) = 0$。\n\n最终输出规范：\n\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，不含空格，格式如下：\n  - 对于每种情况，按给定顺序输出其阈值对应的列表 $\\left[R^2(p_{T,1}), R^2(p_{T,2}), \\ldots \\right]$，并将每个条目四舍五入到 $6$ 位小数。\n  - 将 A、B、C、D 四种情况按顺序聚合到一个列表中，形成一个嵌套列表。例如：$\\left[[r_{A,1},r_{A,2}], [r_{B,1},r_{B,2}], [r_{C,1},r_{C,2}], [r_{D,1},r_{D,2}]\\right]$。",
            "solution": "所提出的问题是统计遗传学领域一项全面且有效的模拟研究，特别涉及全基因组关联研究 (GWAS) 和多基因风险评分 (PRS)。任务是实现指定的模拟流程，该流程在科学上基于复杂性状的标准多基因模型，并评估由此产生的 PRS 的预测准确性。所有参数和过程都有明确定义，使得问题客观且在算法上易于处理。我将首先详细解释该方法论，然后进行实现。\n\n整个过程可以分解为几个逻辑阶段：数据模拟、关联分析、PRS 构建和评估。\n\n首先，我们为两个不同的队列模拟遗传和表型数据：一个大小为 $n_{\\text{train}}$ 的训练队列和一个大小为 $n_{\\text{test}}$ 的测试队列。我们考虑一个包含 $m$ 个单核苷酸多态性 (SNP) 的基因组。对于每个 SNP $j$，其次要等位基因频率 (MAF)，记为 $p_j$，从均匀分布 $\\mathrm{Uniform}(0.05, 0.5)$ 中抽取。在哈迪-温伯格平衡的假设下，每个个体在 SNP $j$ 上的基因型（即次要等位基因的计数）是从二项分布 $\\mathrm{Binomial}(2, p_j)$ 中进行的独立随机抽样。此过程生成原始基因型矩阵 $\\mathbf{G}_{\\text{train}}$ 和 $\\mathbf{G}_{\\text{test}}$。\n\n原始基因型计数通常不直接用于分析，而是进行标准化。对于每个 SNP $j$，我们仅使用训练数据计算其均值 $\\mu_j$ 和标准差 $\\sigma_j$。然后使用这些统计数据对两个队列的基因型矩阵进行标准化：\n$$X_{\\text{train}}[i,j] = \\frac{G_{\\text{train}}[i,j] - \\mu_j}{\\sigma_j} \\quad \\text{和} \\quad X_{\\text{test}}[i,j] = \\frac{G_{\\text{test}}[i,j] - \\mu_j}{\\sigma_j}$$\n一个关键的边界情况是当一个 SNP 在训练队列中的方差为零时 ($\\sigma_j = 0$)。在这种情况下，该 SNP 不提供信息，其在两个队列中的标准化值都设为 $0$。\n\n接下来，我们通过定义性状的遗传结构来为我们的模拟建立基准真相。我们从 $m$ 个 SNP 中随机选择 $k$ 个作为“因果”SNP。真实遗传效应向量 $\\boldsymbol{\\beta}^{\\star} \\in \\mathbb{R}^m$ 仅在这些因果 SNP 处有非零条目。这 $k$ 个 SNP 的初始原始效应从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取。然后，这些原始效应 $\\boldsymbol{\\beta}_{\\text{raw}}$ 被缩放以满足指定的狭义遗传力 $h^2$。遗传力代表可归因于遗传方差的表型方差比例。我们计算训练集中的遗传成分为 $\\mathbf{g}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}_{\\text{raw}}$ 及其方差 $v_g = \\mathrm{Var}(\\mathbf{g}_{\\text{train}})$。最终的、经过缩放的效应向量是：\n$$\\boldsymbol{\\beta}^{\\star} = \\boldsymbol{\\beta}_{\\text{raw}} \\sqrt{\\frac{h^2}{v_g}}$$\n这种缩放确保了训练数据中真实遗传成分的方差 $\\mathrm{Var}(\\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star})$ 精确地为 $h^2$。如果 $v_g=0$，则 $\\boldsymbol{\\beta}^{\\star}$ 是零向量。总表型方差被归一化为 $1$，因此环境噪声的方差为 $\\sigma_e^2 = 1 - h^2$。然后使用线性模型为两个队列生成表型：\n$$\\mathbf{y}_{\\text{train}} = \\mathbf{X}_{\\text{train}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{train}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{train}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n$$\\mathbf{y}_{\\text{test}} = \\mathbf{X}_{\\text{test}} \\boldsymbol{\\beta}^{\\star} + \\boldsymbol{\\varepsilon}_{\\text{test}}, \\quad \\text{其中} \\quad \\boldsymbol{\\varepsilon}_{\\text{test}} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma_e^2 \\mathbf{I})$$\n\n有了模拟的训练数据 $(\\mathbf{X}_{\\text{train}}, \\mathbf{y}_{\\text{train}})$，我们进行 GWAS。对于每个 SNP $j$，我们检验其与表型无关联的零假设。这是通过拟合单变量线性模型来完成的。关联强度由一个 $t$ 统计量来量化。令 $r_j$ 为第 $j$ 个 SNP 向量 $\\mathbf{X}_{\\text{train}}[:,j]$ 与表型向量 $\\mathbf{y}_{\\text{train}}$ 之间的皮尔逊相关系数。$t$ 统计量为：\n$$t_j = \\frac{r_j}{\\sqrt{1 - r_j^2}} \\sqrt{\\nu}$$\n其中 $\\nu = n_{\\text{train}} - 2$ 是自由度。然后从学生 t 分布计算双边 $p$ 值 $p_j$：$p_j = 2 \\, \\mathbb{P}(T_{\\nu} \\ge |t_j|)$，其中 $T_{\\nu}$ 是一个服从自由度为 $\\nu$ 的 t 分布的随机变量。同时，我们为每个 SNP 估计单变量普通最小二乘法 (OLS) 效应大小 $\\hat{\\beta}_j$。对于一个标准化的预测变量，这个斜率可以被高效地计算出来。\n\n下一步是为测试集构建 PRS。基于一个指定的 $p$ 值阈值 $p_T$，我们构成一个包含的 SNP 集合 $S(p_T) = \\{j \\mid p_j \\le p_T\\}$。PRS 是测试队列中标准化基因型的加权和，其权重是来自训练 GWAS 的估计效应大小 $\\hat{\\beta}_j$：\n$$\\mathrm{PRS}_{\\text{test}}(p_T) = \\sum_{j \\in S(p_T)} \\hat{\\beta}_j \\, X_{\\text{test}}[:,j]$$\n如果没有 SNP 达到阈值，$S(p_T)$ 就为空，PRS 是一个零向量。\n\n最后，我们评估 PRS 的预测准确性。这是通过决定系数 $R^2$ 来衡量的，即测试队列中预测的 PRS 与实际表型之间的皮尔逊相关系数的平方：\n$$R^2(p_T) = \\left(\\mathrm{Corr}\\left(\\mathrm{PRS}_{\\text{test}}(p_T), \\mathbf{y}_{\\text{test}}\\right)\\right)^2$$\n如果 PRS 或测试表型任一方的方差为零，则相关性未定义，$R^2(p_T)$ 设为 $0$。\n\n该算法将为测试套件中提供的每个参数集系统地执行整个流程。为了提高效率，将使用 `numpy` 进行向量化计算，特别是在 GWAS 摘要统计和 PRS 计算方面。每种情况的随机种子确保了随机模拟的可重复性。最终输出将是计算出的 $R^2(p_T)$ 值，按规定进行四舍五入和格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import t as student_t\n\ndef run_simulation(seed, n_train, n_test, m, k, h2, thresholds):\n    \"\"\"\n    Performs a single GWAS/PRS simulation run for a given set of parameters.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # 1. Simulate MAFs and Genotypes\n    mafs = rng.uniform(0.05, 0.5, size=m)\n    g_train = rng.binomial(2, mafs, size=(n_train, m))\n    g_test = rng.binomial(2, mafs, size=(n_test, m))\n    \n    # 2. Standardize Genotypes\n    mu_train = np.mean(g_train, axis=0)\n    sigma_train = np.std(g_train, axis=0)\n    \n    std_is_zero = (sigma_train == 0)\n    \n    x_train = np.zeros_like(g_train, dtype=float)\n    x_test = np.zeros_like(g_test, dtype=float)\n    \n    non_zero_std_indices = ~std_is_zero\n    \n    # Use np.divide with where clause to avoid runtime warnings\n    if np.any(non_zero_std_indices):\n        x_train[:, non_zero_std_indices] = np.divide(\n            g_train[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n        x_test[:, non_zero_std_indices] = np.divide(\n            g_test[:, non_zero_std_indices] - mu_train[non_zero_std_indices],\n            sigma_train[non_zero_std_indices]\n        )\n\n    # 3. Simulate True Effects and Scale by Heritability\n    beta_raw = np.zeros(m)\n    if k  0:\n        causal_indices = rng.choice(m, size=k, replace=False)\n        beta_raw[causal_indices] = rng.normal(0, 1, size=k)\n    \n    g_train_component = x_train @ beta_raw\n    v_g = np.var(g_train_component)\n    \n    beta_star = np.zeros(m)\n    if v_g  0 and h2  0:\n        scaling_factor = np.sqrt(h2 / v_g)\n        beta_star = beta_raw * scaling_factor\n    \n    # 4. Simulate Phenotypes\n    sigma_e2 = 1.0 - h2\n    sigma_e = np.sqrt(sigma_e2) if sigma_e2  0 else 0.0\n    \n    y_train = x_train @ beta_star + rng.normal(0, sigma_e, size=n_train)\n    y_test = x_test @ beta_star + rng.normal(0, sigma_e, size=n_test)\n    \n    # 5. Perform GWAS in Training Cohort\n    hat_betas = np.zeros(m)\n    p_values = np.ones(m)\n    \n    y_train_var = np.var(y_train, ddof=1)\n    if y_train_var == 0:\n        # If y_train has no variance, all betas are 0 and p-values are 1.\n        # This is handled by hat_betas and p_values being pre-initialized.\n        pass\n    else:\n        y_train_c = y_train - np.mean(y_train)\n        \n        # OLS slope estimates (beta_hat)\n        sum_x_sq = np.sum(x_train**2, axis=0)\n        valid_snps_for_beta = (sum_x_sq  0)\n        \n        if np.any(valid_snps_for_beta):\n            hat_betas[valid_snps_for_beta] = (x_train[:, valid_snps_for_beta].T @ y_train_c) / sum_x_sq[valid_snps_for_beta]\n        \n        # Pearson correlations (r)\n        # r = beta_hat * (std_x / std_y)\n        std_x_train_sample = np.std(x_train, axis=0, ddof=1)\n        std_y_train_sample = np.sqrt(y_train_var)\n        \n        correlations = np.zeros(m)\n        valid_snps_for_corr = (std_x_train_sample  0)\n        if np.any(valid_snps_for_corr):\n            correlations[valid_snps_for_corr] = hat_betas[valid_snps_for_corr] * (std_x_train_sample[valid_snps_for_corr] / std_y_train_sample)\n\n        # Handle perfect correlation case to avoid division by zero in t-statistic\n        correlations = np.clip(correlations, -1.0 + 1e-15, 1.0 - 1e-15)\n\n        # t-statistics and p-values\n        df = n_train - 2\n        if df  0:\n            t_stats = (correlations / np.sqrt(1 - correlations**2)) * np.sqrt(df)\n            p_values = 2 * student_t.sf(np.abs(t_stats), df)\n            \n            # SNPs with zero variance in training must have p-value of 1\n            p_values[std_is_zero] = 1.0\n\n    # 6. Calculate PRS and R^2 for each threshold\n    r2_results = []\n    y_test_var = np.var(y_test)\n    \n    for p_t in thresholds:\n        included_snps_mask = (p_values = p_t)\n        \n        if not np.any(included_snps_mask) or y_test_var == 0:\n            r2_results.append(0.0)\n            continue\n        \n        hat_betas_selected = hat_betas[included_snps_mask]\n        x_test_selected = x_test[:, included_snps_mask]\n        \n        prs_test = x_test_selected @ hat_betas_selected\n        \n        prs_var = np.var(prs_test)\n        \n        if prs_var == 0:\n            r2_results.append(0.0)\n            continue\n            \n        corr_matrix = np.corrcoef(prs_test, y_test)\n        corr = corr_matrix[0, 1]\n        \n        r2 = corr**2\n        r2_results.append(np.round(r2, 6))\n        \n    return r2_results\n\n\ndef solve():\n    test_cases = [\n        {'seed': 42, 'n_train': 1500, 'n_test': 1000, 'm': 3000, 'k': 150, 'h2': 0.5, 'thresholds': [1e-8, 1e-5, 1e-3, 1e-2, 1e-1, 5e-1, 1]},\n        {'seed': 7, 'n_train': 300, 'n_test': 300, 'm': 1500, 'k': 50, 'h2': 0.5, 'thresholds': [1e-20, 1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 2023, 'n_train': 800, 'n_test': 800, 'm': 2000, 'k': 0, 'h2': 0.0, 'thresholds': [1e-5, 1e-3, 1e-2, 1e-1, 1]},\n        {'seed': 99, 'n_train': 1200, 'n_test': 800, 'm': 2500, 'k': 100, 'h2': 0.8, 'thresholds': [1e-8, 1e-6, 1e-4, 1e-2, 1]}\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = run_simulation(\n            seed=case['seed'],\n            n_train=case['n_train'],\n            n_test=case['n_test'],\n            m=case['m'],\n            k=case['k'],\n            h2=case['h2'],\n            thresholds=case['thresholds']\n        )\n        all_results.append(results)\n    \n    # Format the final output string exactly as required\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}