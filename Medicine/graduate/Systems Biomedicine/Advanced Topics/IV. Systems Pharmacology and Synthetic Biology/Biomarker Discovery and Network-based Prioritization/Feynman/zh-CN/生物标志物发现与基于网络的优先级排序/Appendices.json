{
    "hands_on_practices": [
        {
            "introduction": "在许多网络医学分析中，第一步是从基因表达等高维分子数据中推断出一个网络。本练习将指导你构建一个加权基因共表达网络，这是系统生物学中的一个基本结构。通过这个实践，你将学习如何将统计上的相似性（皮尔逊相关性）转化为图论中的对象，并计算一个基础但重要的中心性度量——加权度 。",
            "id": "4320638",
            "problem": "您的任务是构建一个加权基因共表达网络，并计算节点度，以用于生物标志物发现和基于网络的优先级排序。请从以下基本原则出发：两个基因在多个样本中的表达谱之间的皮尔逊积矩相关系数（PPMCC）、根据相关性大小构建的加权邻接矩阵的定义，以及加权网络中节点度的图论定义。\n\n定义与要求：\n- 设有 $n$ 个样本和 $p$ 个基因。将表达矩阵表示为 $X \\in \\mathbb{R}^{n \\times p}$，其中第 $i$ 列是基因 $i$ 在 $n$ 个样本中的表达向量 $x_i \\in \\mathbb{R}^n$。\n- 基因 $i$ 和 $j$ 之间的皮尔逊积矩相关系数（PPMCC）为\n$$\nr_{ij} = \\frac{\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)\\left(x_{jt} - \\bar{x}_j\\right)}{\\sqrt{\\left(\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)^2\\right)\\left(\\sum_{t=1}^{n} \\left(x_{jt} - \\bar{x}_j\\right)^2\\right)}},\n$$\n其中 $\\bar{x}_i$ 是 $x_i$ 在 $n$ 个样本中的均值。如果 $\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)^2 = 0$ 或 $\\sum_{t=1}^{n} \\left(x_{jt} - \\bar{x}_j\\right)^2 = 0$（即某个基因在所有样本中的表达量恒定），则定义 $r_{ij} = 0$。\n- 构建一个加权邻接矩阵 $W \\in \\mathbb{R}^{p \\times p}$，其元素为\n$$\nw_{ij} = \\begin{cases}\n\\left| r_{ij} \\right|^{\\beta},  i \\neq j, \\\\\n0,  i = j,\n\\end{cases}\n$$\n其中 $\\beta > 0$ 是一个给定的软阈值幂参数。\n- 节点 $i$ 的加权度为\n$$\nk_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{p} w_{ij}.\n$$\n\n您的程序必须精确实现这些定义，并为指定测试集中的每个基因计算加权度 $k_i$。计算不涉及物理单位。在最终输出中，将每个度 $k_i$ 表示为至少有六位小数精度的浮点数。\n\n测试集：\n- 案例 1：$X$ 有 $n = 6$ 个样本和 $p = 5$ 个基因。\n  - $x_1 = [1,2,3,4,5,6]$\n  - $x_2 = [6,5,4,3,2,1]$\n  - $x_3 = [2,4,6,8,10,12]$\n  - $x_4 = [1,1,2,2,3,3]$\n  - $x_5 = [3,3,3,3,3,3]$\n  - $\\beta = 2$\n- 案例 2：$X$ 有 $n = 5$ 个样本和 $p = 4$ 个基因。\n  - $x_1 = [0,0,0,0,0]$\n  - $x_2 = [1,2,3,4,5]$\n  - $x_3 = [2,1,0,-1,-2]$\n  - $x_4 = [5,4,3,2,1]$\n  - $\\beta = 1$\n- 案例 3：$X$ 有 $n = 3$ 个样本和 $p = 2$ 个基因。\n  - $x_1 = [1,2,3]$\n  - $x_2 = [3,2,1]$\n  - $\\beta = 3$\n- 案例 4：$X$ 有 $n = 4$ 个样本和 $p = 3$ 个基因。\n  - $x_1 = [1,0,-1,0]$\n  - $x_2 = [1,1,1,1]$\n  - $x_3 = [1,-1,1,-1]$\n  - $\\beta = 10$\n- 案例 5：$X$ 有 $n = 6$ 个样本和 $p = 3$ 个基因。\n  - $x_1 = [0,1,0,1,0,1]$\n  - $x_2 = [0.1,0.9,0.2,0.8,0.05,0.95]$\n  - $x_3 = [-0.1,-0.9,-0.2,-0.8,-0.05,-0.95]$\n  - $\\beta = 4$\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来。这个顶层列表的每个元素对应一个测试案例，并且本身必须是该案例的 $p$ 个加权度 $[k_1, k_2, \\ldots, k_p]$ 的列表。例如，对于上述五个案例，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots],[\\dots]]$，其中的浮点数值至少有六位小数精度。",
            "solution": "我们将加权共表达网络的构建基于两个公认的原则：统计学中基于相关性的相似性和图论中的节点度。在系统生物医学中，候选生物标志物的网络优先级排序通常依赖于从共表达关系中导出的中心性度量，正如在加权基因共表达网络分析（WGCNA）中，邻接矩阵是通过对相似性进行软阈值化构建的。我们的步骤如下。\n\n基因 $i$ 和 $j$ 之间的皮尔逊积矩相关系数（PPMCC）是衡量线性关联的标准化指标。给定 $x_i \\in \\mathbb{R}^n$ 和 $x_j \\in \\mathbb{R}^n$，样本均值为 $\\bar{x}_i$ 和 $\\bar{x}_j$，分子\n$$\n\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)\\left(x_{jt} - \\bar{x}_j\\right)\n$$\n是未归一化的协方差，而分母\n$$\n\\sqrt{\\left(\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)^2\\right)\\left(\\sum_{t=1}^{n} \\left(x_{jt} - \\bar{x}_j\\right)^2\\right)}\n$$\n是未归一化标准差的乘积。两者的比值消除了单位和尺度，得到 $r_{ij} \\in [-1,1]$。这与经过充分检验的统计学实践一致，并且与计算协方差时使用除数 $n$ 还是 $n-1$ 无关，因为这些因子在相关系数的比率中会被抵消。当一个基因在所有样本中表达量恒定时，其方差为零，分母为零，$r_{ij}$ 无定义；在操作上，我们将任何涉及此类基因的基因对的 $r_{ij}$ 设为 0，以避免引入人为的边。\n\n为了构建加权邻接矩阵，我们使用相关系数的绝对值 $\\left|r_{ij}\\right|$ 来反映共表达强度，而不考虑其方向（正或负）。当目标是量化连接性时，这在基于网络的优先级排序中是一种常见且有科学动机的选择。然后我们应用一个软阈值幂 $\\beta > 0$：\n$$\nw_{ij} = \\begin{cases}\n\\left| r_{ij} \\right|^{\\beta},  i \\neq j, \\\\\n0,  i = j,\n\\end{cases}\n$$\n并设置 $w_{ii} = 0$ 以移除自环。参数 $\\beta$ 控制对强相关的强调程度：较大的 $\\beta$ 会抑制较弱的边并突显较强的边，这是在共表达网络中用于促进近似无标度拓扑的一个原则。\n\n节点 $i$ 的加权度（也称为强度）为\n$$\nk_i = \\sum_{\\substack{j=1 \\\\ j \\neq i}}^{p} w_{ij},\n$$\n它量化了基因 $i$ 与所有其他基因的总连接性。在生物标志物发现中，较大的 $k_i$ 表明其具有更高的网络中心性和潜在的调控重要性。\n\n算法步骤：\n- 对于每个测试案例，计算每个基因 $i$ 的均值 $\\bar{x}_i$，通过减去其均值来中心化每个基因向量，并计算每个基因的未归一化平方和。对于每对 $(i,j)$，通过中心化向量的元素级乘积之和来计算未归一化协方差。如果任一基因的平方和为零，则设置 $r_{ij} = 0$；否则计算\n$$\nr_{ij} = \\frac{\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)\\left(x_{jt} - \\bar{x}_j\\right)}{\\sqrt{\\left(\\sum_{t=1}^{n} \\left(x_{it} - \\bar{x}_i\\right)^2\\right)\\left(\\sum_{t=1}^{n} \\left(x_{jt} - \\bar{x}_j\\right)^2\\right)}}.\n$$\n- 通过 $w_{ij} = \\left|r_{ij}\\right|^{\\beta}$（对于 $i \\neq j$）和 $w_{ii} = 0$ 来构建 $W$。\n- 对每个 $i$ 计算 $k_i = \\sum_{j \\neq i} w_{ij}$。\n\n测试集覆盖的边界情况：\n- 案例 1 包括完美的正相关和负相关、一个中等相关性，以及一个表达量恒定的基因 ($x_5$)。例如，$x_1$ 和 $x_3$ 呈线性关系 ($x_3 = 2 x_1$)，得到 $r_{13} = 1$，因此 $w_{13} = 1^{2} = 1$；而 $x_1$ 和 $x_2$ 完全负相关 ($r_{12} = -1$, $w_{12} = 1$)。$x_1$ 和 $x_4$ 之间的相关性很高但非完美；具体来说，\n$$\nr_{14} = \\frac{8}{\\sqrt{70}} \\approx 0.956182887,\\quad w_{14} \\approx (0.956182887)^{2} \\approx 0.914297,\n$$\n而 $x_5$ 是恒定的，所以所有的 $r_{i5} = 0$ 和 $w_{i5} = 0$。加权度 $k_i$ 是这些贡献的总和。\n- 案例 2 强调了对恒定基因 ($x_1$) 和完美负相关（例如 $r_{23} = -1$, $r_{24} = -1$）的处理，其中 $\\beta = 1$，因此 $w_{ij} = \\left| r_{ij} \\right|$。\n- 案例 3 是一个最小网络（$p=2$），具有完美的负相关和 $\\beta = 3$，得到 $w_{12} = 1$ 且 $k_1 = k_2 = 1$。\n- 案例 4 包括一个恒定基因 ($x_2$) 和一个正交对 ($x_1$ 与 $x_3$)，产生 $r_{13} = 0$；由于 $\\beta = 10$，所有度都为 $0$。\n- 案例 5 包含强但非完美的相关和负相关，展示了 $\\beta = 4$ 在强调强边同时保留细微差异的效果。例如，对于中心化后的向量 $x_1$ 和 $x_2$，可得\n$$\nr_{12} \\approx \\frac{1.15}{\\sqrt{1.5 \\cdot 0.915}} \\approx 0.9827,\\quad w_{12} \\approx (0.9827)^{4} \\approx 0.931,\n$$\n类似地，$r_{23} \\approx -0.989$ 得到 $w_{23} \\approx 0.957$。度 $k_i$ 是各自关联边权重的总和。\n\n实现细节：\n- 使用数组表示 $X$，并根据上述公式计算均值、中心化向量、平方和以及成对相关性。\n- 构建 $W$ 时，对角线元素为零，非对角线元素为 $\\left|r_{ij}\\right|$ 的 $\\beta$ 次方。\n- 通过对行求和（不包括对角线元素）来计算 $k_i$。\n\n程序返回一行，其中包含五个案例的度列表的列表，格式为 $[[k_1,\\dots,k_p],\\dots]$，浮点数值至少保留六位小数精度，以确保下游优先级比较的稳定性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_weighted_degrees(X: np.ndarray, beta: float) -> list:\n    \"\"\"\n    Compute weighted degrees for a co-expression network:\n    - Pearson correlation r_ij from centered gene expression profiles\n    - Weighted adjacency w_ij = |r_ij|^beta for i != j, w_ii = 0\n    - Weighted degree k_i = sum_{j != i} w_ij\n    \"\"\"\n    # X: shape (n_samples, n_genes)\n    n, p = X.shape\n    # Center columns\n    means = X.mean(axis=0)\n    centered = X - means\n    # Unnormalized sum of squares per gene\n    ss = (centered ** 2).sum(axis=0)\n    # Initialize correlation matrix\n    R = np.zeros((p, p), dtype=float)\n    # Compute pairwise correlations\n    for i in range(p):\n        for j in range(i + 1, p):\n            denom = np.sqrt(ss[i] * ss[j])\n            if denom == 0.0:\n                rij = 0.0\n            else:\n                cov = (centered[:, i] * centered[:, j]).sum()\n                rij = cov / denom\n            R[i, j] = rij\n            R[j, i] = rij\n    # Construct weighted adjacency\n    W = np.abs(R) ** beta\n    np.fill_diagonal(W, 0.0)\n    # Weighted degrees\n    degrees = W.sum(axis=1)\n    # Round to ensure at least six decimal digits of precision in display\n    return [float(np.round(d, 6)) for d in degrees]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n=6, p=5, beta=2\n        (\n            np.array([\n                [1, 6, 2, 1, 3],\n                [2, 5, 4, 1, 3],\n                [3, 4, 6, 2, 3],\n                [4, 3, 8, 2, 3],\n                [5, 2, 10, 3, 3],\n                [6, 1, 12, 3, 3]\n            ], dtype=float),\n            2.0\n        ),\n        # Case 2: n=5, p=4, beta=1\n        (\n            np.array([\n                [0, 1, 2, 5],\n                [0, 2, 1, 4],\n                [0, 3, 0, 3],\n                [0, 4, -1, 2],\n                [0, 5, -2, 1]\n            ], dtype=float),\n            1.0\n        ),\n        # Case 3: n=3, p=2, beta=3\n        (\n            np.array([\n                [1, 3],\n                [2, 2],\n                [3, 1]\n            ], dtype=float),\n            3.0\n        ),\n        # Case 4: n=4, p=3, beta=10\n        (\n            np.array([\n                [1, 1, 1],\n                [0, 1, -1],\n                [-1, 1, 1],\n                [0, 1, -1]\n            ], dtype=float),\n            10.0\n        ),\n        # Case 5: n=6, p=3, beta=4\n        (\n            np.array([\n                [0.0, 0.1, -0.1],\n                [1.0, 0.9, -0.9],\n                [0.0, 0.2, -0.2],\n                [1.0, 0.8, -0.8],\n                [0.0, 0.05, -0.05],\n                [1.0, 0.95, -0.95]\n            ], dtype=float),\n            4.0\n        ),\n    ]\n\n    results = []\n    for X, beta in test_cases:\n        degrees = compute_weighted_degrees(X, beta)\n        results.append(degrees)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "构建网络后，我们可以利用其结构来优先排序候选基因。本练习将探讨网络扩散，特别是带重启的随机游走（Random Walk with Restart），这是一种强大的优先级排序算法。通过实现并比较两种不同的归一化方案，你将深入了解算法选择（特别是对网络枢纽节点的处理）如何影响基因排序，这是在实际应用中必须审慎考虑的关键点 。",
            "id": "4320621",
            "problem": "考虑一个基因或蛋白质相互作用网络，表示为一个具有 $n$ 个节点的有限、简单、无向、加权图。设该网络由一个邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 编码，其中 $A_{ij} \\ge 0$ 且 $A_{ij} = A_{ji}$。设节点 $i$ 的度为 $d_i = \\sum_{j=1}^{n} A_{ij}$，度矩阵为 $D = \\mathrm{diag}(d_1,\\dots,d_n)$。在基于网络的生物标志物优先排序中，通过在网络上传播初始信号 $s \\in \\mathbb{R}^{n}$ 来获得最终的优先排序得分 $x \\in \\mathbb{R}^{n}$，并根据这些得分对节点进行排名。两种常用的扩散度归一化方法是行随机归一化和对称归一化，它们可能会产生不同的排名，特别是对于高度节点（中心节点）。\n\n从马尔可夫链中的概率守恒和图信号归一化的基本原则出发，实现一个与这些原则一致的迭代扩散过程。使用以下规范：\n\n1. 扩散状态更新必须遵循重复传播并重新注入初始信号的思想，体现带重启的随机游走（RWR）的概念。在每次迭代中，新状态必须通过组合传播分量和初始信号 $s$ 的重新注入分量来计算，由参数 $\\alpha$（$0  \\alpha  1$）控制，以确保收缩并收敛到一个不动点。\n\n2. 实现传播算子 $W$ 的两种变体：\n   - 行随机归一化：基于 $D$ 和 $A$ 构建一个矩阵 $W_{\\mathrm{row}}$，使得对于度 $d_i > 0$ 的节点，其行和为 $1$。度 $d_i = 0$ 的节点不得传播任何质量（mass）。\n   - 对称归一化：使用 $D$ 和 $A$ 通过对称度归一化导出一个矩阵 $W_{\\mathrm{sym}}$，以减少中心节点的主导作用并考虑图的几何结构。度 $d_i = 0$ 的节点不得传播任何质量（mass）。\n\n3. 对于给定的种子集 $S \\subset \\{1,\\dots,n\\}$，定义一个初始信号 $s$，将相等的质量（mass）置于 $S$ 中的节点上，其他节点上为零。总质量必须为 $1$。\n\n4. 迭代扩散直至收敛，收敛条件为连续迭代之差的范数低于指定的容差，或达到最大迭代次数。\n\n5. 收敛后，分别计算 $W_{\\mathrm{row}}$ 和 $W_{\\mathrm{sym}}$ 的最终得分 $x_{\\mathrm{row}}$ 和 $x_{\\mathrm{sym}}$。按得分降序对节点进行排名。如果出现平局，则通过较小的节点索引来打破平局（即，索引较小的节点获得更好的排名）。将排序转换为排名位置 $r_{\\mathrm{row}}(i)$ 和 $r_{\\mathrm{sym}}(i)$，其中 $1$ 为最佳排名。\n\n6. 将高度节点集 $H$ 定义为度 $d_i$ 最高的 $k$ 个节点，平局由较小的索引打破。计算高度节点的有符号排名变化，$\\Delta r(i) = r_{\\mathrm{sym}}(i) - r_{\\mathrm{row}}(i)$，适用于所有 $i \\in H$。正值 $\\Delta r(i)$ 表示与行随机归一化相比，该节点在对称归一化下的排名更差（排名数值更高）；负值表示其排名更好。\n\n7. 对于每个测试用例，产生三个输出：\n   - $H$ 上平均绝对排名变化的实数。\n   - $H$ 上最大绝对排名变化的整数。\n   - 按节点索引升序排列的有符号排名变化列表 $[\\Delta r(i)]_{i \\in H}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[result\\_1,result\\_2,\\dots]$），其中每个 $result\\_t$ 本身就是一个列表 $[\\text{mean\\_abs\\_change},\\text{max\\_abs\\_change},[\\Delta r(i) \\text{ for } i \\in H]]$。\n\n为以下测试套件实现上述功能。每个测试用例提供 $A$、种子集 $S$、重启参数 $\\alpha$、高度节点截断值 $k$、最大迭代次数 $T_{\\max}$ 和容差 $\\varepsilon$。矩阵以显式形式给出，行和列的索引从 $0$ 到 $n-1$。\n\n测试用例 $1$（正常路径，单个连通分量，一个中心节点）：\n- $n = 6$\n- $$A = \\begin{bmatrix}\n0  3  2  4  1  1 \\\\\n3  0  2  0  0  0 \\\\\n2  2  0  1  0  0 \\\\\n4  0  1  0  2  0 \\\\\n1  0  0  2  0  3 \\\\\n1  0  0  0  3  0\n\\end{bmatrix}$$\n- $S = \\{4,5\\}$\n- $\\alpha = 0.85$\n- $k = 2$\n- $T_{\\max} = 10000$\n- $\\varepsilon = 10^{-12}$\n\n测试用例 $2$（边缘情况，一个星形中心节点和一个局部三角形）：\n- $n = 7$\n- $$A = \\begin{bmatrix}\n0  2  2  2  2  2  0 \\\\\n2  0  0  0  0  0  0 \\\\\n2  0  0  0  0  0  0 \\\\\n2  0  0  0  0  2  1 \\\\\n2  0  0  0  0  0  0 \\\\\n2  0  0  2  0  0  3 \\\\\n0  0  0  1  0  3  0\n\\end{bmatrix}$$\n- $S = \\{0\\}$\n- $\\alpha = 0.90$\n- $k = 2$\n- $T_{\\max} = 10000$\n- $\\varepsilon = 10^{-12}$\n\n测试用例 $3$（边界条件，两个不连通分量，每个分量中都有中心节点）：\n- $n = 8$\n- $$A = \\begin{bmatrix}\n0  4  0  0  0  0  0  0 \\\\\n4  0  3  2  0  0  0  0 \\\\\n0  3  0  1  0  0  0  0 \\\\\n0  2  1  0  0  0  0  0 \\\\\n0  0  0  0  0  1  2  0 \\\\\n0  0  0  0  1  0  2  1 \\\\\n0  0  0  0  2  2  0  2 \\\\\n0  0  0  0  0  1  2  0\n\\end{bmatrix}$$\n- $S = \\{0,6\\}$\n- $\\alpha = 0.70$\n- $k = 3$\n- $T_{\\max} = 10000$\n- $\\varepsilon = 10^{-12}$\n\n所有输出都必须在没有任何外部输入的情况下产生。您的程序必须使用这些确切的测试用例，并以上述确切格式输出单行结果。",
            "solution": "### 步骤1：提取已知信息\n\n问题提供了以下数据和定义：\n- 基因/蛋白质相互作用网络是一个具有 $n$ 个节点的有限、简单、无向、加权图。\n- 邻接矩阵：$A \\in \\mathbb{R}^{n \\times n}$，其中 $A_{ij} \\ge 0$ 且 $A_{ij} = A_{ji}$。\n- 节点 $i$ 的度：$d_i = \\sum_{j=1}^{n} A_{ij}$。\n- 度矩阵：$D = \\mathrm{diag}(d_1,\\dots,d_n)$。\n- 初始信号向量：$s \\in \\mathbb{R}^{n}$。\n- 最终优先排序得分向量：$x \\in \\mathbb{R}^{n}$。\n- 扩散更新规则：基于“重复传播并重新注入初始信号 $s$”的迭代过程，由参数 $\\alpha$（$0  \\alpha  1$）控制。\n- 传播算子 $W$：\n    - 行随机归一化：$W_{\\mathrm{row}}$，对于度 $d_i > 0$ 的节点，其行和为 $1$。度 $d_i = 0$ 的节点不传播质量（mass）。\n    - 对称归一化：$W_{\\mathrm{sym}}$，使用 $D$ 和 $A$ 通过对称度归一化导出。度 $d_i = 0$ 的节点不传播质量（mass）。\n- 初始信号定义：对于种子集 $S$，$s$ 在 $S$ 中的节点上具有相等的质量，在其他节点上为零，总质量和为 $1$。\n- 收敛标准：连续迭代之差的L2范数小于容差 $\\varepsilon$，或达到最大迭代次数 $T_{\\max}$。\n- 排名：节点按得分降序排名。平局由较小的节点索引打破。排名 $r(i)$ 从 $1$ 开始。\n- 高度节点 $H$：度 $d_i$ 最高的 $k$ 个节点的集合，平局由较小的节点索引打破。\n- $i \\in H$ 的有符号排名变化：$\\Delta r(i) = r_{\\mathrm{sym}}(i) - r_{\\mathrm{row}}(i)$。\n- 每个测试用例的必需输出：一个包含 $H$ 上平均绝对排名变化、$H$ 上最大绝对排名变化以及按节点索引升序排列的有符号排名变化列表 $[\\Delta r(i)]_{i \\in H}$ 的列表。\n- 测试用例 1：$n=6$, $A=\\begin{bmatrix} 0  3  2  4  1  1 \\\\ 3  0  2  0  0  0 \\\\ 2  2  0  1  0  0 \\\\ 4  0  1  0  2  0 \\\\ 1  0  0  2  0  3 \\\\ 1  0  0  0  3  0 \\end{bmatrix}$, $S=\\{4,5\\}$, $\\alpha=0.85$, $k=2$, $T_{\\max}=10000$, $\\varepsilon=10^{-12}$。\n- 测试用例 2：$n=7$, $A=\\begin{bmatrix} 0  2  2  2  2  2  0 \\\\ 2  0  0  0  0  0  0 \\\\ 2  0  0  0  0  0  0 \\\\ 2  0  0  0  0  2  1 \\\\ 2  0  0  0  0  0  0 \\\\ 2  0  0  2  0  0  3 \\\\ 0  0  0  1  0  3  0 \\end{bmatrix}$, $S=\\{0\\}$, $\\alpha=0.90$, $k=2$, $T_{\\max}=10000$, $\\varepsilon=10^{-12}$。\n- 测试用例 3：$n=8$, $A=\\begin{bmatrix} 0  4  0  0  0  0  0  0 \\\\ 4  0  3  2  0  0  0  0 \\\\ 0  3  0  1  0  0  0  0 \\\\ 0  2  1  0  0  0  0  0 \\\\ 0  0  0  0  0  1  2  0 \\\\ 0  0  0  0  1  0  2  1 \\\\ 0  0  0  0  2  2  0  2 \\\\ 0  0  0  0  0  1  2  0 \\end{bmatrix}$, $S=\\{0,6\\}$, $\\alpha=0.70$, $k=3$, $T_{\\max}=10000$, $\\varepsilon=10^{-12}$。\n\n### 步骤2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估。\n\n- **科学依据**：该问题基于网络科学和图论的成熟原则，特别是带重启的随机游走（RWR）算法。邻接矩阵、度归一化（行随机和对称）以及迭代扩散等概念是计算系统生物学中用于基因优先排序等任务的标准方法。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它为每个测试用例提供了所有必要的参数（$A, S, \\alpha, k, T_{\\max}, \\varepsilon$）。RWR算法被描述为传播和重新注入的组合，由 $\\alpha$ 控制，对应于迭代过程 $x_{t+1} = (1-\\alpha)s + \\alpha W x_t$。对于 $0  \\alpha  1$ 且 $W$ 是一个有效的传播算子（谱半径 $\\rho(W) \\le 1$），该过程是一个压缩映射，保证了唯一且稳定的不动点解的存在。排名和中心节点选择的平局打破规则确保了结果的唯一性。\n- **客观性**：所有术语都通过数学和程序化方式定义。语言精确，没有主观或含糊的陈述。\n- **完整性与一致性**：问题是自洽的。传播算子、初始信号、收敛、排名和最终度量的定义都已提供并且相互一致。对度 $d_i=0$ 的节点的处理方式也已明确，防止了除零错误，并确保了算法的鲁棒性。\n- **现实性**：网络规模和参数值对于一个计算问题来说是现实的，没有可行性问题。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。这是一个来自网络生物学领域的定义明确、有科学依据且计算上可行的问题。我现在将着手构建解决方案。\n\n### 基于原则的解决方案设计\n\n问题的核心是在图上实现并比较两种带重启的随机游走（RWR）算法的变体。该算法模拟一个信号在网络中扩散的过程，在每一步中，信号既可以继续传播到邻居节点，也可以从一组种子节点“重启”。\n\n**1. 网络和信号初始化**\n网络由其邻接矩阵 $A$ 表示。每个节点 $i$ 的度 $d_i$ 计算为其关联边的权重之和，即 $d_i = \\sum_{j} A_{ij}$。初始信号 $s$ 是一个向量，代表“信号质量”的初始分布。对于给定的种子节点集 $S$，信号在这些节点中均匀分布，使得如果节点 $i$ 在 $S$ 中，则 $s_i = 1/|S|$，否则 $s_i = 0$。这确保了总信号质量被归一化，即 $\\sum_{i} s_i = 1$。\n\n**2. 传播算子**\n扩散过程由传播算子 $W$ 控制，它是邻接矩阵 $A$ 的一个归一化版本。指定了两种归一化方案：\n\n- **行随机归一化 ($W_{\\mathrm{row}}$)**：这种归一化模拟了图上的经典随机游走。从节点 $i$ 到节点 $j$ 的转移概率与边权重 $A_{ij}$ 成正比。我们构造 $W_{\\mathrm{row}} = D^{-1}A$，其中 $D^{-1}$ 是度矩阵 $D$ 的逆。对于度 $d_i > 0$ 的节点 $i$，$D^{-1}$ 的第 $(i,i)$ 个元素是 $1/d_i$。这确保了 $W_{\\mathrm{row}}$ 中对应于已连接节点的每一行之和为 $1$，从而在局部上守恒概率质量。如果 $d_i = 0$，则 $D^{-1}$ 中的相应条目为 $0$，确保孤立节点不传播任何信号，如规范所述。\n\n- **对称归一化 ($W_{\\mathrm{sym}}$)**：这种归一化通常更受青睐，因为它使算子对称，这对应于一个可逆的马尔可夫链，并具有良好的谱特性。它定义为 $W_{\\mathrm{sym}} = D^{-1/2} A D^{-1/2}$，其中 $D^{-1/2}$ 是一个对角矩阵，对于度 $d_i > 0$ 的节点，其对角线上的条目为 $1/\\sqrt{d_i}$，否则为 $0$。这种归一化倾向于减少高度节点（中心节点）的影响，因为与它们相连的边的权重比行随机情况下被更重地降低了。\n\n**3. 迭代扩散（带重启的随机游走）**\n扩散过程是对得分向量 $x$ 的迭代更新，从 $x_0 = s$ 开始。更新规则结合了传播和重新注入：\n$$x_{t+1} = (1-\\alpha)s + \\alpha W x_t$$\n这里，$\\alpha \\in (0, 1)$ 是继续概率。在每一步 $t$，每个节点上的一部分信号 $\\alpha$ 根据 $W$ 传播到其邻居，而剩余部分 $(1-\\alpha)$ 则从初始源分布 $s$ 中补充。由于迭代映射是压缩的，该过程保证收敛到唯一的稳态分布 $x_{ss}$。迭代持续进行，直到连续得分向量之间的变化可以忽略不计，即 $\\|x_{t+1} - x_t\\|_2  \\varepsilon$，或直到达到最大迭代次数 $T_{\\max}$。\n\n**4. 排名与比较**\n收敛后，我们得到两个最终得分向量，$x_{\\mathrm{row}}$ 和 $x_{\\mathrm{sym}}$，分别对应两种归一化方案。为了比较它们的效果，我们执行以下步骤：\n- **排名**：对于每个得分向量，根据得分降序对节点进行从 $1$ 到 $n$ 的排名。得分平局通过为索引较小的节点分配更好的排名来打破。这将产生两个排名向量，$r_{\\mathrm{row}}$ 和 $r_{\\mathrm{sym}}$。\n- **高度节点识别**：通过找到度 $d_i$ 最高的 $k$ 个节点来确定高度节点集 $H$。度平局通过选择索引较小的节点来打破。\n- **排名变化分析**：对于高度节点集 $H$ 中的每个节点 $i$，计算有符号排名变化 $\\Delta r(i) = r_{\\mathrm{sym}}(i) - r_{\\mathrm{row}}(i)$。正值 $\\Delta r(i)$ 表示与行随机归一化相比，该节点在对称归一化下的排名更差（即，排名数值更大）。\n- **最终度量**：通过三个度量来总结比较结果：\n    1. $H$ 中所有节点的绝对排名变化的平均值：$\\frac{1}{k} \\sum_{i \\in H} |\\Delta r(i)|$。\n    2. $H$ 上绝对排名变化的最大值：$\\max_{i \\in H} |\\Delta r(i)|$。\n    3. 有符号排名变化列表 $[\\Delta r(i)]_{i \\in H}$，按节点索引 $i$ 升序排列。\n\n这种结构化的分析将系统地揭示在网络扩散背景下，归一化选择如何影响中心节点的优先排序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the execution for all test cases.\n    It defines the test cases and calls the core analysis function for each,\n    then formats and prints the final output.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([\n                [0, 3, 2, 4, 1, 1],\n                [3, 0, 2, 0, 0, 0],\n                [2, 2, 0, 1, 0, 0],\n                [4, 0, 1, 0, 2, 0],\n                [1, 0, 0, 2, 0, 3],\n                [1, 0, 0, 0, 3, 0]\n            ]),\n            \"S\": {4, 5},\n            \"alpha\": 0.85,\n            \"k\": 2,\n            \"T_max\": 10000,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [0, 2, 2, 2, 2, 2, 0],\n                [2, 0, 0, 0, 0, 0, 0],\n                [2, 0, 0, 0, 0, 0, 0],\n                [2, 0, 0, 0, 0, 2, 1],\n                [2, 0, 0, 0, 0, 0, 0],\n                [2, 0, 0, 2, 0, 0, 3],\n                [0, 0, 0, 1, 0, 3, 0]\n            ]),\n            \"S\": {0},\n            \"alpha\": 0.90,\n            \"k\": 2,\n            \"T_max\": 10000,\n            \"epsilon\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [0, 4, 0, 0, 0, 0, 0, 0],\n                [4, 0, 3, 2, 0, 0, 0, 0],\n                [0, 3, 0, 1, 0, 0, 0, 0],\n                [0, 2, 1, 0, 0, 0, 0, 0],\n                [0, 0, 0, 0, 0, 1, 2, 0],\n                [0, 0, 0, 0, 1, 0, 2, 1],\n                [0, 0, 0, 0, 2, 2, 0, 2],\n                [0, 0, 0, 0, 0, 1, 2, 0]\n            ]),\n            \"S\": {0, 6},\n            \"alpha\": 0.70,\n            \"k\": 3,\n            \"T_max\": 10000,\n            \"epsilon\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_diffusion_analysis(\n            A=case[\"A\"],\n            S=case[\"S\"],\n            alpha=case[\"alpha\"],\n            k=case[\"k\"],\n            T_max=case[\"T_max\"],\n            epsilon=case[\"epsilon\"]\n        )\n        results.append(result)\n\n    # Custom string formatting to avoid spaces and ensure required output format\n    result_strs = []\n    for res in results:\n        mean_val, max_val, delta_list = res\n        delta_str = '[' + ','.join(map(str, delta_list)) + ']'\n        result_strs.append(f'[{mean_val},{max_val},{delta_str}]')\n    \n    print(f\"[{','.join(result_strs)}]\")\n\ndef run_diffusion_analysis(A, S, alpha, k, T_max, epsilon):\n    \"\"\"\n    Performs the full diffusion analysis for a single test case.\n    \"\"\"\n    n = A.shape[0]\n\n    # Step 1: Calculate degrees and identify the high-degree node set H\n    degrees = A.sum(axis=1)\n    node_degree_pairs = [(-degrees[i], i) for i in range(n)]\n    node_degree_pairs.sort()\n    H = sorted([node_degree_pairs[i][1] for i in range(k)])\n\n    # Step 2: Construct the initial signal vector s\n    s = np.zeros(n)\n    if S:\n        s[[i for i in S]] = 1.0 / len(S)\n\n    # Step 3: Define the diffusion iterator\n    def perform_rwr(W, s_vec, alpha_param, T_max_iter, eps):\n        x = np.copy(s_vec)\n        reinjection_term = (1 - alpha_param) * s_vec\n        for _ in range(T_max_iter):\n            x_new = alpha_param * (W @ x) + reinjection_term\n            if np.linalg.norm(x_new - x)  eps:\n                return x_new\n            x = x_new\n        return x\n\n    # Step 4: Construct propagation operators W_row and W_sym\n    # Avoid division by zero for nodes with degree 0\n    with np.errstate(divide='ignore', invalid='ignore'):\n        d_inv = np.array([1.0 / d if d  0 else 0 for d in degrees])\n        d_inv_sqrt = np.array([1.0 / np.sqrt(d) if d  0 else 0 for d in degrees])\n    \n    D_inv = np.diag(d_inv)\n    D_inv_sqrt = np.diag(d_inv_sqrt)\n\n    W_row = D_inv @ A\n    W_sym = D_inv_sqrt @ A @ D_inv_sqrt\n\n    # Step 5: Run diffusion for both normalizations\n    x_row = perform_rwr(W_row, s, alpha, T_max, epsilon)\n    x_sym = perform_rwr(W_sym, s, alpha, T_max, epsilon)\n\n    # Step 6: Define a ranking function\n    def get_ranks(scores):\n        n_nodes = len(scores)\n        # Sort by score (desc) and then index (asc)\n        sorted_nodes = sorted(range(n_nodes), key=lambda i: (-scores[i], i))\n        ranks = np.zeros(n_nodes, dtype=int)\n        for rank_pos, node_idx in enumerate(sorted_nodes):\n            ranks[node_idx] = rank_pos + 1\n        return ranks\n\n    # Step 7: Calculate ranks\n    r_row = get_ranks(x_row)\n    r_sym = get_ranks(x_sym)\n\n    # Step 8: Calculate rank changes and summary metrics for nodes in H\n    delta_r_values = [int(r_sym[i] - r_row[i]) for i in H]\n    abs_delta_r_values = np.abs(delta_r_values)\n    \n    mean_abs_change = np.mean(abs_delta_r_values)\n    max_abs_change = int(np.max(abs_delta_r_values)) if delta_r_values else 0\n    \n    return [mean_abs_change, max_abs_change, delta_r_values]\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "生物标志物发现的最终目标是找到具有临床应用价值的分子。最后的这个练习将从网络优先排序转向临床效用评估，聚焦于一个核心区别：一个生物标志物仅仅是预后性的（prognostic），还是能够真正预测治疗反应（predictive）。这个基于随机试验和因果推断原理的思想实验，将挑战你应用这些定义来判断一个生物标志物在个体化医疗中的潜在作用 。",
            "id": "4320718",
            "problem": "在一项针对复杂疾病的靶向治疗的随机对照试验（RCT）中，您正在评估一个候选分子生物标志物 $X$，以决定在基因相互作用网络中，是否应优先将其用于下游的基于网络的生物标志物发现。设 $Y \\in \\{0,1\\}$ 表示二元临床响应，$T \\in \\{0,1\\}$ 为治疗指示变量，$X \\in \\{0,1\\}$ 表示是否存在由生物标志物定义的分层。给定在分层 $X=1$ 内观测到的以下条件响应概率：$P(Y=1 \\mid X=1,T=1)=0.6$，$P(Y=1 \\mid X=1,T=0)=0.3$，以及分层内的边际响应 $P(Y=1 \\mid X=1)=0.45$。假设在随机化和一致性下的标准因果可识别性条件成立，包括 $T \\perp (Y(0),Y(1)) \\mid X$，并且在 $X$ 的分层内没有未测量的混杂因素。\n\n仅使用预后性与预测性生物标志物的定义以及 RCT 中分层特异性风险差的因果解释，从第一性原理出发，解决以下问题：\n\n1. 利用给定的概率和随机化原则，判断生物标志物 $X$ 是否表现出与预测价值（$X$ 对治疗效果的效应修饰）一致的证据，或者仅仅是预后性的（无论治疗如何都与结局相关），严格限制在观测到的分层 $X=1$ 内。根据由 $P(Y=1 \\mid X=1,T=t)$ 识别的因果对比，明确证明您的结论。\n\n2. 在风险差尺度上，为“无治疗与生物标志物交互作用”构建适当的零假设，并用 $P(Y=1 \\mid X=x,T=t)$（其中 $x \\in \\{0,1\\}$ 且 $t \\in \\{0,1\\}$）来表示。该零假设应表述为在无交互作用条件下等于 $0$ 的单个标量对比。\n\n3. 对于基于网络的优先级排序，您将提供分层特异性风险差 $\\Delta_{X=1}$ 作为节点特异性预测权重，以在一个经整理的分子相互作用网络上初始化一个扩散过程。仅使用提供的概率计算这个 $\\Delta_{X=1}$。报告 $\\Delta_{X=1}$ 的数值作为您的最终答案。无需四舍五入。最终答案以纯数字形式表示，不带单位。",
            "solution": "本问题要求我们基于随机对照试验（RCT）的数据，从第一性原理出发，评估一个候选生物标志物 $X$ 的价值。我们将分步解答。\n\n1.  **评估 $X$ 在 $X=1$ 分层中的价值**\n\n    - **预后价值 (Prognostic Value)** 指的是在未经治疗（或接受标准治疗）的情况下，生物标志物与临床结局的关联。这需要比较 $P(Y=1 \\mid X=1, T=0)$ 和 $P(Y=1 \\mid X=0, T=0)$。我们已知前者为 $0.3$，但后者未知，因此我们无法从现有数据中判断 $X$ 的预后价值。\n\n    - **预测价值 (Predictive Value)** 指的是生物标志物能否预测治疗效果的差异。我们可以在 $X=1$ 分层内计算治疗带来的**风险差 (Risk Difference, RD)**。由于这是RCT，我们可以将观测到的条件概率解释为因果效应：\n      $$\n      \\Delta_{X=1} = E[Y \\mid X=1, \\text{do}(T=1)] - E[Y \\mid X=1, \\text{do}(T=0)]\n      $$\n      在可识别性假设下，这等同于：\n      $$\n      \\Delta_{X=1} = P(Y=1 \\mid X=1, T=1) - P(Y=1 \\mid X=1, T=0) = 0.6 - 0.3 = 0.3\n      $$\n      因为在 $X=1$ 这个亚组中，治疗效果 $\\Delta_{X=1}$ 不为零（为 $0.3$），这表明治疗对这个亚组是有效的。因此，生物标志物 $X$ 能够识别出一个对治疗有积极响应的患者群体。这正是**预测价值**的体现。它不仅仅是预后性的，因为它明确地揭示了治疗与标志物状态之间的相互作用对结局的影响。\n\n2.  **“无治疗与生物标志物交互作用”的零假设**\n\n    一个生物标志物没有预测价值（即无交互作用）意味着治疗效果在所有生物标志物分层中都是相同的。在风险差尺度上，这意味着在 $X=1$ 亚组中的治疗效果等于在 $X=0$ 亚组中的治疗效果。我们可以将此表述为以下零假设：\n    $$\n    H_0: \\Delta_{X=1} - \\Delta_{X=0} = 0\n    $$\n    将其展开，我们得到一个单一的标量对比：\n    $$\n    (P(Y=1 \\mid X=1, T=1) - P(Y=1 \\mid X=1, T=0)) - (P(Y=1 \\mid X=0, T=1) - P(Y=1 \\mid X=0, T=0)) = 0\n    $$\n    这个表达式精确地定义了在风险差尺度上不存在交互作用。\n\n3.  **计算分层特异性风险差 $\\Delta_{X=1}$**\n\n    根据问题要求，我们需要计算在 $X=1$ 分层内的风险差，作为下游网络分析的权重。如第一部分所计算：\n    $$\n    \\Delta_{X=1} = P(Y=1 \\mid X=1, T=1) - P(Y=1 \\mid X=1, T=0) = 0.6 - 0.3 = 0.3\n    $$\n    这个值 $0.3$ 代表了在该生物标志物阳性的患者群体中，接受治疗相比不接受治疗所带来的额外响应概率。",
            "answer": "$$\n\\boxed{0.3}\n$$"
        }
    ]
}