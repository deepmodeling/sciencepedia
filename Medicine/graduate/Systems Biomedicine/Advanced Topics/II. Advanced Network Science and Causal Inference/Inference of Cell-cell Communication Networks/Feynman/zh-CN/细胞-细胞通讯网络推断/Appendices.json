{
    "hands_on_practices": [
        {
            "introduction": "在推断细胞间通讯网络时，一个核心挑战是如何将真实的相互作用信号与随机的共表达模式区分开来。评估潜在通讯连接统计显著性的一个稳健方法是使用置换检验。这种非参数方法使我们能够根据具体数据生成一个零分布，为计算观测到的相互作用强度的p值提供了一种强有力的方法。本练习将指导您实现这样一个检验，这是验证通讯网络的一项基本技能。",
            "id": "4355885",
            "problem": "给定一种基于配体-受体相互作用和空间接触概率的形式化方法，用于描述发送细胞类型 $a$ 和接收细胞类型 $b$ 之间的细胞间通讯。构建一个经验置换检验，通过在发送细胞类型内对细胞间的配体表达进行置换，来为细胞间边权重 $W_{ab}$ 构建一个零分布，同时保持配体表达的边缘分布不变，并计算观测到的边的上尾 $p$ 值。\n\n从以下基本前提开始：\n- 细胞遵循分子生物学中心法则，即基因表达产生蛋白质（例如配体和受体）。细胞间的通讯由配体-受体对介导；一次接触介导的信号事件的概率随配体和受体丰度的乘积单调增加。\n- 对于两种细胞类型，定义一个接触概率矩阵 $C \\in \\mathbb{R}_{\\ge 0}^{n_a \\times n_b}$，其元素 $C_{ij}$ 是类型为 $a$ 的发送细胞 $i$ 与类型为 $b$ 的接收细胞 $j$ 接触的概率（或归一化权重），其中 $\\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij}$ 是有限的。\n- 对于由 $k \\in \\{1,\\dots,K\\}$ 索引的 $K$ 个配体-受体对，令 $L \\in \\mathbb{R}_{\\ge 0}^{n_a \\times K}$ 表示发送细胞中的配体表达，$R \\in \\mathbb{R}_{\\ge 0}^{n_b \\times K}$ 表示接收细胞中的受体表达，以及 $s \\in \\mathbb{R}_{>0}^{K}$ 表示特定配对的结合强度（或权重）。\n\n将细胞间边权重 $W_{ab}$ 定义为在接触加权下，所有配体-受体对的期望接触介导信号总量：\n$$\nW_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L_{ik} \\, R_{jk}.\n$$\n\n在零假设下，即在一个细胞类型内，配体表达值在各个发送细胞间的分配是可交换的（即，高配体表达与接触结构之间不存在特定的细胞水平对齐），通过对每个配体 $k$ 在发送细胞类型内的细胞间独立地置换配体表达来构建一个零分布：\n$$\nL^{(r)}_{\\cdot k} \\;=\\; \\pi^{(r)}\\!\\left(L_{\\cdot k}\\right),\n$$\n其中 $\\pi^{(r)}$ 是对第 $k$ 个配体列的 $n_a$ 个条目的随机置换，而 $r \\in \\{1,\\dots,R\\}$ 是置换索引。对于每次置换，计算\n$$\nW^{(r)}_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L^{(r)}_{ik} \\, R_{jk}.\n$$\n令 $W^{\\text{obs}}_{ab}$ 表示从原始的 $L, R, C, s$ 计算出的观测边权重。报告带有连续性校正的上尾经验 $p$ 值：\n$$\np \\;=\\; \\frac{1 + \\sum_{r=1}^{R} \\mathbb{I}\\!\\left(W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}\\right)}{R + 1},\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，$R$ 是置换次数。答案以 $\\left[0,1\\right]$ 范围内的小数形式给出。\n\n您的程序必须实现上述过程，并为以下测试套件计算 $p$ 值。请使用下面给出的确切矩阵和参数。为保证可复现性，请为置换使用指定的随机种子。没有物理单位。不使用角度。不使用百分比。最终数值答案以小数表示。\n\n测试用例 1 (一般情况):\n- 维度: $n_a = 4$, $n_b = 5$, $K = 3$。\n- 配体矩阵:\n$$\nL^{(1)} \\;=\\;\n\\begin{bmatrix}\n2.0  0.5  1.0 \\\\\n1.5  2.0  0.0 \\\\\n3.0  1.0  0.5 \\\\\n0.2  3.5  2.0\n\\end{bmatrix}\n$$\n- 受体矩阵:\n$$\nR^{(1)} \\;=\\;\n\\begin{bmatrix}\n0.5  0.0  1.0 \\\\\n1.0  1.5  0.5 \\\\\n0.2  2.0  0.0 \\\\\n1.5  0.5  1.5 \\\\\n0.0  1.0  0.2\n\\end{bmatrix}\n$$\n- 接触矩阵:\n$$\nC^{(1)} \\;=\\;\n\\begin{bmatrix}\n0.9  0.1  0.0  0.0  0.0 \\\\\n0.0  0.8  0.1  0.0  0.0 \\\\\n0.0  0.0  0.7  0.2  0.0 \\\\\n0.0  0.0  0.0  0.6  0.4\n\\end{bmatrix}\n$$\n- 结合强度:\n$$\ns^{(1)} \\;=\\; \\begin{bmatrix} 1.0  0.8  0.5 \\end{bmatrix}\n$$\n- 置换次数: $R^{(1)} = 1000$。\n- 随机种子: $42$。\n\n测试用例 2 (边界：零接触):\n- 维度: $n_a = 3$, $n_b = 3$, $K = 2$。\n- 配体矩阵:\n$$\nL^{(2)} \\;=\\;\n\\begin{bmatrix}\n1.0  2.0 \\\\\n0.0  1.5 \\\\\n3.0  0.5\n\\end{bmatrix}\n$$\n- 受体矩阵:\n$$\nR^{(2)} \\;=\\;\n\\begin{bmatrix}\n0.5  1.0 \\\\\n1.0  0.0 \\\\\n0.0  1.5\n\\end{bmatrix}\n$$\n- 接触矩阵:\n$$\nC^{(2)} \\;=\\;\n\\begin{bmatrix}\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0 \\\\\n0.0  0.0  0.0\n\\end{bmatrix}\n$$\n- 结合强度:\n$$\ns^{(2)} \\;=\\; \\begin{bmatrix} 1.0  1.0 \\end{bmatrix}\n$$\n- 置换次数: $R^{(2)} = 500$。\n- 随机种子: $7$。\n\n测试用例 3 (边缘情况：单一配体-受体对与集中接触):\n- 维度: $n_a = 4$, $n_b = 4$, $K = 1$。\n- 配体矩阵:\n$$\nL^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.0 \\\\\n0.0 \\\\\n10.0 \\\\\n0.0\n\\end{bmatrix}\n$$\n- 受体矩阵:\n$$\nR^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.0 \\\\\n5.0 \\\\\n0.0 \\\\\n0.0\n\\end{bmatrix}\n$$\n- 接触矩阵:\n$$\nC^{(3)} \\;=\\;\n\\begin{bmatrix}\n0.05  0.05  0.05  0.05 \\\\\n0.05  0.05  0.05  0.05 \\\\\n0.05  1.00  0.05  0.05 \\\\\n0.05  0.05  0.05  0.05\n\\end{bmatrix}\n$$\n- 结合强度:\n$$\ns^{(3)} \\;=\\; \\begin{bmatrix} 1.0 \\end{bmatrix}\n$$\n- 置换次数: $R^{(3)} = 1000$。\n- 随机种子: $123$。\n\n测试用例 4 (边界：单细胞发送者和接收者):\n- 维度: $n_a = 1$, $n_b = 1$, $K = 2$。\n- 配体矩阵:\n$$\nL^{(4)} \\;=\\;\n\\begin{bmatrix}\n2.0  4.0\n\\end{bmatrix}\n$$\n- 受体矩阵:\n$$\nR^{(4)} \\;=\\;\n\\begin{bmatrix}\n3.0  1.0\n\\end{bmatrix}\n$$\n- 接触矩阵:\n$$\nC^{(4)} \\;=\\;\n\\begin{bmatrix}\n0.5\n\\end{bmatrix}\n$$\n- 结合强度:\n$$\ns^{(4)} \\;=\\; \\begin{bmatrix} 1.0  0.1 \\end{bmatrix}\n$$\n- 置换次数: $R^{(4)} = 1000$。\n- 随机种子: $21$。\n\n您的程序应生成单行输出，其中包含按顺序排列的四个测试用例的 $p$ 值，格式为方括号内由逗号分隔的列表，每个值四舍五入到恰好六位小数（例如，$[0.123456,0.654321,0.500000,0.000999]$）。",
            "solution": "该问题要求实现一个经验置换检验，用以评估发送细胞类型 $a$ 和接收细胞类型 $b$ 之间计算出的细胞间边权重 $W_{ab}$ 的统计显著性。该边权重基于配体-受体表达、它们的结合强度和空间接触概率，量化了信号相互作用的总潜力。\n\n解决方案的结构如下：\n1.  一个函数，用于从输入矩阵计算细胞间边权重 $W_{ab}$。\n2.  一个程序，用于通过置换配体表达来为 $W_{ab}$ 生成零分布。\n3.  基于此零分布计算经验 $p$ 值。\n\n**1. 观测边权重 $W_{ab}^{\\text{obs}}$ 的计算**\n\n细胞间边权重 $W_{ab}$ 被定义为所有可能的信号相互作用的总和，按配体-受体对结合强度 $s_k$ 和细胞-细胞接触概率 $C_{ij}$ 进行加权。其公式如下：\n$$\nW_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L_{ik} \\, R_{jk}\n$$\n其中 $L \\in \\mathbb{R}_{\\ge 0}^{n_a \\times K}$ 是配体表达矩阵，$R \\in \\mathbb{R}_{\\ge 0}^{n_b \\times K}$ 是受体表达矩阵，$C \\in \\mathbb{R}_{\\ge 0}^{n_a \\times n_b}$ 是接触概率矩阵，$s \\in \\mathbb{R}_{>0}^{K}$ 是结合强度向量，$n_a$ 和 $n_b$ 分别是发送细胞和接收细胞的数量，$K$ 是配体-受体对的数量。\n\n这个四重求和可以使用张量缩并来高效实现。NumPy 库的 `einsum` 函数非常适合此任务。表达式 $\\sum_{k=1}^{K} \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} s_k C_{ij} L_{ik} R_{jk}$ 可以直接转换为一个签名为 `'k,ij,ik,jk->'` 的 `einsum` 操作。在这里，$i$ 代表发送细胞的索引，$j$ 代表接收细胞的索引，$k$ 代表配体-受体对的索引。输入是具有相应索引的向量/矩阵 $s$、$C$、$L$ 和 $R$。该操作对所有索引 $i$、$j$ 和 $k$ 求和，以产生一个标量输出。这为计算观测权重 $W_{ab}^{\\text{obs}}$（使用原始矩阵 $L$）和置换权重 $W_{ab}^{(r)}$ 提供了一种计算上高效且数值上稳定的方法。\n\n**2. 零分布的生成**\n\n零假设 $H_0$ 假定，发送细胞间的配体表达模式相对于它们的接触概率是随机的。也就是说，将高或低配体表达值分配给单个发送细胞的具体方式不携带任何信息。为了模拟这种零情景，我们通过置换检验为 $W_{ab}$ 生成一个零分布。\n\n该过程涉及为 $r \\in \\{1,\\dots,R\\}$ 生成 $R$ 个置换后的边权重 $W_{ab}^{(r)}$。对于每个重复 $r$，我们构建一个置换后的配体矩阵 $L^{(r)}$。关键在于，问题陈述了置换是“对每个配体 $k$ 独立进行”的。这意味着对于每个置换重复 $r$，以及对于矩阵 $L$ 的每个配体（列）$k$，我们都在 $n_a$ 个发送细胞间独立地打乱其表达值。\n\n算法如下：对于每次置换 $r=1, \\dots, R$：\n- 创建一个大小为 $n_a \\times K$ 的新矩阵 $L^{(r)}$。\n- 对于每一列 $k=1, \\dots, K$：\n    - $L^{(r)}$ 的第 $k$ 列，记为 $L_{\\cdot k}^{(r)}$，是 $L$ 的原始第 $k$ 列的一个随机置换，即 $L_{\\cdot k}^{(r)} = \\pi_k^{(r)}(L_{\\cdot k})$。置换 $\\pi_k^{(r)}$ 对每个 $k$ 和 $r$ 都是独立抽取的。\n- 使用 $L^{(r)}$ 计算置换权重 $W_{ab}^{(r)}$：\n$$\nW^{(r)}_{ab} \\;=\\; \\sum_{k=1}^{K} s_k \\sum_{i=1}^{n_a} \\sum_{j=1}^{n_b} C_{ij} \\, L^{(r)}_{ik} \\, R_{jk}\n$$\n\n这个过程保留了每个配体表达的边缘分布，但破坏了配体表达模式与细胞-细胞接触概率之间的任何特定相关结构。\n\n当 $n_a=1$ 时会出现一个重要的边缘情况。在这种情况下，只有一个发送细胞。对包含单个元素的列表进行置换会得到相同的列表。因此，对于所有的 $r$，$L^{(r)} = L$，这意味着 $W_{ab}^{(r)} = W_{ab}^{\\text{obs}}$。\n\n**3. 经验 $p$ 值的计算**\n\n经验 $p$ 值是在零假设下，观测到与观测权重一样极端或更极端的权重的概率。对于上尾检验，我们计算大于或等于观测权重的置换权重的数量。问题指定了连续性校正，这是置换检验中的标准做法，以避免 $p$ 值为 $0$ 并确保检验是保守的。公式为：\n$$\np \\;=\\; \\frac{1 + \\sum_{r=1}^{R} \\mathbb{I}\\!\\left(W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}\\right)}{R + 1}\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数，当条件为真时为 $1$，否则为 $0$。分子中的 $1$ 是因为观测到的统计量本身也被视为零假设下分布的一个成员。分母中的 $1$ 反映了包括观测统计量在内的分布的总大小。\n\n对于 $n_a=1$ 的边缘情况，每个 $W_{ab}^{(r)}$ 都等于 $W_{ab}^{\\text{obs}}$。条件 $W^{(r)}_{ab} \\ge W^{\\text{obs}}_{ab}$ 总是成立。因此，指示函数的总和变为 $R$。$p$ 值为 $(1+R)/(R+1) = 1$。如果接触矩阵 $C$ 全为零，同样的逻辑也适用，因为这会使所有权重（$W_{ab}^{\\text{obs}}$ 和所有 $W_{ab}^{(r)}$）都为 $0$，从而使得不等式 $0 \\ge 0$ 总是成立。实现中正确处理了这些情况。\n\n一个专门的函数封装了这整个过程，它接受数据矩阵、置换次数 $R$ 和用于可复现性的随机种子作为输入，并返回最终的 $p$ 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_p_value(L, R_mat, C, s, num_permutations, seed):\n    \"\"\"\n    Computes the empirical p-value for an intercellular edge weight.\n\n    Args:\n        L (np.ndarray): Ligand expression matrix (n_a x K).\n        R_mat (np.ndarray): Receptor expression matrix (n_b x K).\n        C (np.ndarray): Contact probability matrix (n_a x n_b).\n        s (np.ndarray): Binding strengths vector (K,).\n        num_permutations (int): Number of permutations (R).\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        float: The calculated upper-tail p-value.\n    \"\"\"\n\n    def calculate_W_ab(ligand_matrix, receptor_matrix, contact_matrix, strengths_vector):\n        \"\"\"Calculates the edge weight using einsum for efficiency.\"\"\"\n        # W_ab = sum_{k,i,j} s_k * C_ij * L_ik * R_jk\n        # Indices: i=sender cell, j=receiver cell, k=ligand-receptor pair\n        return np.einsum('k,ij,ik,jk->', strengths_vector, contact_matrix, ligand_matrix, receptor_matrix, optimize=True)\n\n    n_a = L.shape[0]\n\n    # Calculate the observed edge weight\n    W_obs = calculate_W_ab(L, R_mat, C, s)\n\n    # Edge case: If n_a=1, permutations are the identity map.\n    # W_perm will always be W_obs. The p-value is 1.\n    # This also handles the case where W_obs is 0 due to C=0, as W_perm will also be 0, so W_perm >= W_obs is always true.\n    if n_a == 1 or np.all(C == 0):\n        return 1.0\n\n    # Initialize the random number generator for permutation\n    rng = np.random.default_rng(seed)\n\n    # Perform the permutation test\n    count_ge = 0\n    \n    for _ in range(num_permutations):\n        # Create a new permuted ligand matrix for each permutation replicate\n        L_perm = np.empty_like(L)\n        for k in range(L.shape[1]):\n            # rng.permutation returns a new shuffled array, leaving the original unchanged\n            L_perm[:, k] = rng.permutation(L[:, k])\n        \n        # Calculate the permuted weight\n        W_perm = calculate_W_ab(L_perm, R_mat, C, s)\n\n        if W_perm >= W_obs:\n            count_ge += 1\n\n    # Calculate the empirical p-value with continuity correction\n    p_value = (1.0 + count_ge) / (1.0 + num_permutations)\n    \n    return p_value\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            # Test case 1 (general case)\n            \"L\": np.array([\n                [2.0, 0.5, 1.0],\n                [1.5, 2.0, 0.0],\n                [3.0, 1.0, 0.5],\n                [0.2, 3.5, 2.0]\n            ]),\n            \"R_mat\": np.array([\n                [0.5, 0.0, 1.0],\n                [1.0, 1.5, 0.5],\n                [0.2, 2.0, 0.0],\n                [1.5, 0.5, 1.5],\n                [0.0, 1.0, 0.2]\n            ]),\n            \"C\": np.array([\n                [0.9, 0.1, 0.0, 0.0, 0.0],\n                [0.0, 0.8, 0.1, 0.0, 0.0],\n                [0.0, 0.0, 0.7, 0.2, 0.0],\n                [0.0, 0.0, 0.0, 0.6, 0.4]\n            ]),\n            \"s\": np.array([1.0, 0.8, 0.5]),\n            \"num_permutations\": 1000,\n            \"seed\": 42\n        },\n        {\n            # Test case 2 (boundary: zero contact)\n            \"L\": np.array([\n                [1.0, 2.0],\n                [0.0, 1.5],\n                [3.0, 0.5]\n            ]),\n            \"R_mat\": np.array([\n                [0.5, 1.0],\n                [1.0, 0.0],\n                [0.0, 1.5]\n            ]),\n            \"C\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"s\": np.array([1.0, 1.0]),\n            \"num_permutations\": 500,\n            \"seed\": 7\n        },\n        {\n            # Test case 3 (edge case: single ligand–receptor pair with concentrated contact)\n            \"L\": np.array([\n                [0.0],\n                [0.0],\n                [10.0],\n                [0.0]\n            ]),\n            \"R_mat\": np.array([\n                [0.0],\n                [5.0],\n                [0.0],\n                [0.0]\n            ]),\n            \"C\": np.array([\n                [0.05, 0.05, 0.05, 0.05],\n                [0.05, 0.05, 0.05, 0.05],\n                [0.05, 1.00, 0.05, 0.05],\n                [0.05, 0.05, 0.05, 0.05]\n            ]),\n            \"s\": np.array([1.0]),\n            \"num_permutations\": 1000,\n            \"seed\": 123\n        },\n        {\n            # Test case 4 (boundary: single-cell sender)\n            \"L\": np.array([\n                [2.0, 4.0]\n            ]),\n            \"R_mat\": np.array([\n                [3.0, 1.0]\n            ]),\n            \"C\": np.array([\n                [0.5]\n            ]),\n            \"s\": np.array([1.0, 0.1]),\n            \"num_permutations\": 1000,\n            \"seed\": 21\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p_val = compute_p_value(**case)\n        results.append(p_val)\n\n    # Format the results as a comma-separated list of strings with 6 decimal places\n    formatted_results = [f\"{p:.6f}\" for p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管统计验证至关重要，但单细胞数据集的巨大规模——包含数万个细胞——使得计算效率成为首要问题。一个对所有可能的细胞-细胞对进行评分的朴素算法通常在计算上是不可行的。本练习探讨了算法复杂度的概念，并展示了如何利用生物学和空间上的稀疏性来大幅减少计算时间，这是设计可扩展分析工具的一项关键原则。",
            "id": "4355933",
            "problem": "考虑一个系统生物医学中的单细胞数据集，其中包含 $N$ 个细胞和 $P$ 个从文献中整理的已知配体-受体对。给定基因表达数据和整理好的配体-受体对，一种用于细胞间通讯推断的基线算法会为每个有序的发送-接收细胞对 $(i,j)$（其中 $i \\neq j$）计算一个配对通讯分数。该分数是通过对所有 $P$ 个配体-受体对中的每一个（$k \\in \\{1,\\dots,P\\}$），使用细胞 $i$ 中的配体表达和细胞 $j$ 中的受体表达，并应用一个固定成本的评分函数 $f$ 来计算的。假设评估单个对 $(i,j,k)$ 的函数 $f$ 的成本是一个与 $N$ 和 $P$ 无关的常数。\n\n要求您从算法复杂度和操作计数的基石定义出发，形式化这个朴素评分程序的计算成本，然后提出并分析一种基于生物学约束的、基于稀疏性的剪枝方法。具体来说：\n\n- 使用大O符号的标准定义，通过计算评分函数评估的次数，推导出朴素算法关于 $N$ 和 $P$ 的计算复杂度。\n- 提出一种基于稀疏性的剪枝策略，该策略仅在两个条件同时成立时才评估通讯分数：(i) 细胞 $i$ 和 $j$ 在从数据中推断出的空间或邻近图中是相邻的，以及 (ii) 对于配体-受体对 $k$，细胞 $i$ 中的配体和细胞 $j$ 中的受体都以高于固定阈值的水平表达。将每个有序对 $(i,j)$（其中 $i \\neq j$）的邻接性建模为一个伯努利随机变量，该变量以概率 $\\alpha \\in (0,1)$ 等于 $1$，否则等于 $0$，且在有序对之间相互独立。将配体和受体的超阈值表达指示符分别建模为独立的伯努利随机变量 $X_{ik}$ 和 $Y_{jk}$，其中 $X_{ik}=1$ 的概率为 $\\pi_{l} \\in (0,1)$，$Y_{jk}=1$ 的概率为 $\\pi_{r} \\in (0,1)$，并且在细胞和配对之间相互独立，也与邻接性独立。假设在此背景下，独立性是一个可接受的近似。\n- 在此模型下，推导剪枝后评分函数评估的期望次数，用 $N$、$P$、$\\alpha$、$\\pi_{l}$ 和 $\\pi_{r}$ 表示。\n\n将缩减因子 $R$ 定义为朴素评估的期望次数与剪枝后评估的期望次数之比。以 $\\alpha$、$\\pi_{l}$ 和 $\\pi_{r}$ 的形式，提供 $R$ 的单个封闭形式解析表达式。不要引入任何新参数。最终答案无需单位。不需要数值近似或四舍五入。",
            "solution": "该问题要求推导一个朴素的细胞间通讯评分算法的计算复杂度，该算法剪枝版本的期望计算次数，以及由此产生的缩减因子。解答按要求分为三个部分展开。\n\n第1部分：朴素算法的计算复杂度\n\n朴素算法为每个有序的发送-接收细胞对 $(i,j)$（其中 $i \\neq j$）计算一个通讯分数，涵盖所有 $P$ 个配体-受体对。评分函数评估的总次数，我们记为 $C_{\\text{naive}}$，是通过计算函数 $f$ 被评估的唯一元组 $(i, j, k)$ 的数量来确定的。\n\n数据集中有 $N$ 个细胞。\n发送细胞 $i$ 可以是这 $N$ 个细胞中的任何一个。\n接收细胞 $j$ 可以是 $N$ 个细胞中的任何一个，但有约束条件 $j \\neq i$。因此，对于每个选定的 $i$，有 $N-1$ 个 $j$ 的选择。\n因此，满足 $i \\neq j$ 的不同有序细胞对 $(i,j)$ 的数量是 $N(N-1)$。\n对 $P$ 个整理好的配体-受体对中的每一个进行评分，其索引为 $k \\in \\{1, \\dots, P\\}$。\n\n评估总次数是元组 $(i, j, k)$ 每个分量的选择数量的乘积：\n$$C_{\\text{naive}} = (\\text{number of choices for } i) \\times (\\text{number of choices for } j) \\times (\\text{number of choices for } k)$$\n$$C_{\\text{naive}} = N \\times (N-1) \\times P = N(N-1)P$$\n为了用大O符号表示，我们分析当 $N$ 和 $P$ 变大时的渐近行为。\n$$C_{\\text{naive}} = (N^2 - N)P = N^2P - NP$$\n这个多项式中的主导项是 $N^2P$。因此，朴素算法的计算复杂度是 $O(N^2P)$，因为评估 $f$ 的成本被假定为一个常数。\n\n第2部分：剪枝算法的期望评估次数\n\n剪枝算法仅在三个独立条件都满足时，才对元组 $(i, j, k)$ 进行评分函数评估：\n1.  细胞 $i$ 和 $j$ 是相邻的。这被建模为每个有序对 $(i, j)$（其中 $i \\neq j$）的伯努利随机变量 $A_{ij}$。邻接的概率是 $P(A_{ij}=1) = \\alpha$。\n2.  细胞 $i$ 中配体对 $k$ 的配体表达水平高于一个阈值。这被建模为一个伯努利随机变量 $X_{ik}$，其 $P(X_{ik}=1) = \\pi_l$。\n3.  细胞 $j$ 中配体对 $k$ 的受体表达水平高于一个阈值。这被建模为一个伯努利随机变量 $Y_{jk}$，其 $P(Y_{jk}=1) = \\pi_r$。\n\n设 $E_{ijk}$ 是一个指示随机变量，如果对元组 $(i, j, k)$ 评估了评分函数，则 $E_{ijk}=1$，否则 $E_{ijk}=0$。评估当且仅当所有三个条件都满足时发生。因此，$E_{ijk} = A_{ij} \\cdot X_{ik} \\cdot Y_{jk}$。\n\n剪枝算法中的总评估次数 $C_{\\text{pruned}}$ 是一个随机变量，由所有可能元组的和给出：\n$$C_{\\text{pruned}} = \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} \\sum_{k=1}^{P} E_{ijk}$$\n我们被要求找出期望评估次数 $E[C_{\\text{pruned}}]$。根据期望的线性性质：\n$$E[C_{\\text{pruned}}] = E\\left[ \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} \\sum_{k=1}^{P} E_{ijk} \\right] = \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} \\sum_{k=1}^{P} E[E_{ijk}]$$\n一个指示变量的期望值是它所指示事件的概率。\n$$E[E_{ijk}] = P(E_{ijk}=1) = P(A_{ij}=1 \\text{ and } X_{ik}=1 \\text{ and } Y_{jk}=1)$$\n问题陈述了底层的随机变量 $A_{ij}$、$X_{ik}$ 和 $Y_{jk}$ 是相互独立的。因此，联合事件的概率是它们各自概率的乘积：\n$$E[E_{ijk}] = P(A_{ij}=1) \\cdot P(X_{ik}=1) \\cdot P(Y_{jk}=1) = \\alpha \\pi_l \\pi_r$$\n对于所考虑的所有元组 $(i, j, k)$，这个概率是恒定的。我们可以将其代回到求期望值的总和中：\n$$E[C_{\\text{pruned}}] = \\sum_{i=1}^{N} \\sum_{j=1, j \\neq i}^{N} \\sum_{k=1}^{P} (\\alpha \\pi_l \\pi_r)$$\n项 $\\alpha \\pi_l \\pi_r$ 是一个常数。求和是针对所有 $N(N-1)P$ 个可能的元组。\n$$E[C_{\\text{pruned}}] = N(N-1)P \\alpha \\pi_l \\pi_r$$\n\n第3部分：缩减因子 $R$\n\n缩减因子 $R$ 定义为朴素评估次数与剪枝后期望评估次数之比。朴素评分过程是确定性的，所以评估次数 $C_{\\text{naive}}$ 是一个常数。其期望值就是它本身，$E[C_{\\text{naive}}] = C_{\\text{naive}} = N(N-1)P$。\n$$R = \\frac{E[C_{\\text{naive}}]}{E[C_{\\text{pruned}}]}$$\n代入上面推导出的表达式：\n$$R = \\frac{N(N-1)P}{N(N-1)P \\alpha \\pi_l \\pi_r}$$\n由于 $N>1$（为了使 $i \\neq j$ 的对 $(i,j)$ 存在）、$P \\ge 1$、$\\alpha > 0$、$\\pi_l > 0$ 和 $\\pi_r > 0$，项 $N(N-1)P$ 非零，可以从分子和分母中约去。\n$$R = \\frac{1}{\\alpha \\pi_l \\pi_r}$$\n这就是根据给定的稀疏性和表达概率参数得出的缩减因子的最终封闭形式表达式。",
            "answer": "$$\n\\boxed{\\frac{1}{\\alpha \\pi_{l} \\pi_{r}}}\n$$"
        },
        {
            "introduction": "在统计显著性和计算可行性之上，是正确因果解释的挑战。在复杂的生物系统中，即使有合理的生物学理由，在统计模型中对某些变量进行控制（conditioning）有时反而会引入偏误。本练习通过一个简化的结构模型，深入探讨了“对撞偏误”（collider bias）的概念，揭示了控制像受体表达这样的中介变量会如何扭曲配体对下游转录反应的估计因果效应。理解这一原理对于避免通讯网络因果解释中的常见陷阱至关重要。",
            "id": "4355888",
            "problem": "考虑一个简单的细胞间通讯机理模型，其中发送细胞 $i$ 表达配体 $L_i$，接收细胞 $j$ 表达同源受体 $R_j$，该受体介导转录反应 $T_j$。假设存在一个未观测到的接收细胞状态变量 $U_j$（例如，分化或应激状态），它同时影响 $R_j$ 和 $T_j$。为了研究 $L_i$ 对 $T_j$ 的因果效应，一些分析会控制观测到的受体水平 $R_j$ 以“确保受体可用性”，但这可能引入对撞偏倚，因为 $R_j$ 可能同时受到 $L_i$ 和 $U_j$ 的影响。您将在线性高斯结构模型下，量化这种由对撞偏倚引起的失真的幅度。\n\n假设存在以下线性结构方程，且所有变量都已中心化，均值为零：\n1. $L_i \\sim \\mathcal{N}(0,\\sigma_L^2)$，$U_j \\sim \\mathcal{N}(0,\\sigma_U^2)$，且 $L_i \\perp U_j$。\n2. $R_j = \\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R$，其中 $\\varepsilon_R \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon_R}^2)$ 且 $\\varepsilon_R$ 独立于 $L_i$ 和 $U_j$。\n3. $T_j = \\gamma_L L_i + \\gamma_R R_j + \\alpha_{UT} U_j + \\varepsilon_T$，其中 $\\varepsilon_T \\sim \\mathcal{N}(0,\\sigma_{\\varepsilon_T}^2)$ 且 $\\varepsilon_T$ 独立于 $L_i$、$U_j$ 和 $\\varepsilon_R$。\n\n您考虑对 $T_j$ 进行关于 $L_i$ 和 $R_j$ 的普通最小二乘 (OLS) 回归（即，控制观测到的 $R_j$ 但不控制未观测到的 $U_j$）。设在此回归中 $L_i$ 的 OLS 系数的大样本极限表示为 $\\beta_L$。目标因果效应为 $\\gamma_L$。将由对撞偏倚引起的渐近偏倚定义为 $B \\equiv \\beta_L - \\gamma_L$。\n\n仅使用上述假设和关于多元正态设定下线性投影的基本事实，推导 $B$ 的封闭形式表达式，该表达式是关于 $\\alpha_{LR}$、$\\alpha_{UR}$、$\\alpha_{UT}$、$\\sigma_U^2$ 和 $\\sigma_{\\varepsilon_R}^2$ 的函数。您的最终答案必须是仅包含这些参数的单个简化的 $B$ 的解析表达式。不要提供中间方程，也不要包含任何单位。定性地（用语言）解释为什么在这种情况下，当以 $R_j$ 为条件时 $B$ 可以不为零，但最终答案只报告 $B$ 的表达式。",
            "solution": "该问题陈述是一个在因果推断领域中表述清晰且具有科学依据的练习，特别关注线性结构方程模型框架内的对撞分层偏倚。它提供了推导唯一、有意义的解所需的所有必要假设和定义。因此，该问题被认为是有效的。\n\n目标是计算渐近偏倚 $B \\equiv \\beta_L - \\gamma_L$，其中 $\\beta_L$ 是在 $T_j$ 对 $L_i$ 和 $R_j$ 的回归中，$L_i$ 的大样本普通最小二乘 (OLS) 系数。$L_i$ 对 $T_j$ 的目标因果效应由参数 $\\gamma_L$ 给出。\n\n对于因变量 $Y$ 对一组回归量 $X$ 的回归，其大样本（总体）OLS 系数由公式 $\\beta = (E[XX^T])^{-1}E[XY]$ 给出。在我们的案例中，因变量是 $T_j$，回归量是 $X_1 = L_i$ 和 $X_2 = R_j$。系数向量是 $\\begin{pmatrix} \\beta_L \\\\ \\beta_R \\end{pmatrix}$。公式为：\n$$\n\\begin{pmatrix} \\beta_L \\\\ \\beta_R \\end{pmatrix} = \\begin{pmatrix} E[L_i^2]  E[L_i R_j] \\\\ E[R_j L_i]  E[R_j^2] \\end{pmatrix}^{-1} \\begin{pmatrix} E[L_i T_j] \\\\ E[R_j T_j] \\end{pmatrix}\n$$\n由于所有变量都已中心化，均值为零，所以乘积的期望是协方差，平方的期望是方差。设 $\\Sigma_{XX}$ 是回归量的协方差矩阵，$\\Sigma_{XT}$ 是回归量与因变量之间的协方差向量。\n$$\n\\Sigma_{XX} = \\begin{pmatrix} \\text{Var}(L_i)  \\text{Cov}(L_i, R_j) \\\\ \\text{Cov}(L_i, R_j)  \\text{Var}(R_j) \\end{pmatrix}, \\quad \\Sigma_{XT} = \\begin{pmatrix} \\text{Cov}(L_i, T_j) \\\\ \\text{Cov}(R_j, T_j) \\end{pmatrix}\n$$\n我们通过从给定的结构方程中计算所需的方差和协方差来进行。\n\n1.  **回归量的协方差矩阵 ($\\Sigma_{XX}$):**\n    *   $\\text{Var}(L_i) = \\sigma_L^2$ (给定)。\n    *   $\\text{Cov}(L_i, R_j) = \\text{Cov}(L_i, \\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R)$。利用协方差的线性和独立性假设（$L_i \\perp U_j, L_i \\perp \\varepsilon_R$），我们得到：\n        $\\text{Cov}(L_i, R_j) = \\alpha_{LR} \\text{Var}(L_i) + \\alpha_{UR} \\text{Cov}(L_i, U_j) + \\text{Cov}(L_i, \\varepsilon_R) = \\alpha_{LR} \\sigma_L^2$。\n    *   $\\text{Var}(R_j) = \\text{Var}(\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R)$。因为 $L_i, U_j, \\varepsilon_R$ 相互独立：\n        $\\text{Var}(R_j) = \\alpha_{LR}^2 \\text{Var}(L_i) + \\alpha_{UR}^2 \\text{Var}(U_j) + \\text{Var}(\\varepsilon_R) = \\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2$。\n\n2.  **协方差向量 ($\\Sigma_{XT}$):**\n    为计算与 $T_j$ 的协方差，我们首先将 $R_j$ 的表达式代入 $T_j$ 的方程中：\n    $T_j = \\gamma_L L_i + \\gamma_R (\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R) + \\alpha_{UT} U_j + \\varepsilon_T$\n    $T_j = (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) U_j + \\gamma_R \\varepsilon_R + \\varepsilon_T$。\n    *   $\\text{Cov}(L_i, T_j) = \\text{Cov}(L_i, (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + \\dots)$。由于 $L_i$ 独立于 $U_j$、$\\varepsilon_R$ 和 $\\varepsilon_T$：\n        $\\text{Cov}(L_i, T_j) = (\\gamma_L + \\gamma_R \\alpha_{LR}) \\text{Var}(L_i) = (\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2$。\n    *   $\\text{Cov}(R_j, T_j) = \\text{Cov}(\\alpha_{LR} L_i + \\alpha_{UR} U_j + \\varepsilon_R, (\\gamma_L + \\gamma_R \\alpha_{LR}) L_i + (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) U_j + \\gamma_R \\varepsilon_R + \\varepsilon_T)$。\n        利用协方差的双线性和注意到 $L_i, U_j, \\varepsilon_R, \\varepsilon_T$ 相互独立（除了 $\\varepsilon_R$ 出现在两项中）：\n        $\\text{Cov}(R_j, T_j) = \\alpha_{LR} (\\gamma_L + \\gamma_R \\alpha_{LR}) \\text{Var}(L_i) + \\alpha_{UR} (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) \\text{Var}(U_j) + \\gamma_R \\text{Var}(\\varepsilon_R)$\n        $= \\alpha_{LR} (\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2 + \\alpha_{UR} (\\gamma_R \\alpha_{UR} + \\alpha_{UT}) \\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2$。\n\n3.  **求解 $\\beta_L$:**\n    系数 $\\beta_L$ 是向量 $\\Sigma_{XX}^{-1} \\Sigma_{XT}$ 的第一个元素。使用 $2 \\times 2$ 矩阵的逆矩阵公式 $\\begin{pmatrix} a  b \\\\ c  d \\end{pmatrix}^{-1} = \\frac{1}{ad-bc} \\begin{pmatrix} d  -b \\\\ -c  a \\end{pmatrix}$，我们感兴趣的是 $\\Sigma_{XX}^{-1}$ 的第一行：\n    $\\beta_L = \\frac{1}{\\det(\\Sigma_{XX})} [ \\text{Var}(R_j) \\text{Cov}(L_i, T_j) - \\text{Cov}(L_i, R_j) \\text{Cov}(R_j, T_j) ]$。\n    行列式是：\n    $\\det(\\Sigma_{XX}) = \\text{Var}(L_i) \\text{Var}(R_j) - (\\text{Cov}(L_i, R_j))^2$\n    $= \\sigma_L^2 (\\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) - (\\alpha_{LR} \\sigma_L^2)^2$\n    $= \\alpha_{LR}^2 \\sigma_L^4 + \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) - \\alpha_{LR}^2 \\sigma_L^4 = \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)$。\n\n    现在，我们计算 $\\beta_L$ 的分子：\n    $\\text{Num}(\\beta_L) = (\\alpha_{LR}^2 \\sigma_L^2 + \\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) \\cdot ((\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2) - (\\alpha_{LR} \\sigma_L^2) \\cdot (\\alpha_{LR}(\\gamma_L + \\gamma_R\\alpha_{LR})\\sigma_L^2 + \\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2)$\n    \n    展开并找出可以消去的项：\n    第一部分中的项 $(\\alpha_{LR}^2 \\sigma_L^2) \\cdot ((\\gamma_L + \\gamma_R \\alpha_{LR}) \\sigma_L^2)$ 与第二部分中的 $-(\\alpha_{LR} \\sigma_L^2) \\cdot (\\alpha_{LR}(\\gamma_L + \\gamma_R\\alpha_{LR})\\sigma_L^2)$ 相消。\n    \n    剩余的分子是：\n    $\\text{Num}(\\beta_L) = (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)(\\gamma_L + \\gamma_R \\alpha_{LR})\\sigma_L^2 - \\alpha_{LR}\\sigma_L^2[\\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]$\n    \n    除以 $\\det(\\Sigma_{XX}) = \\sigma_L^2 (\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2)$:\n    $\\beta_L = (\\gamma_L + \\gamma_R \\alpha_{LR}) - \\frac{\\alpha_{LR}[\\alpha_{UR}(\\gamma_R\\alpha_{UR} + \\alpha_{UT})\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n    \n    让我们简化被减去的分数：\n    $\\frac{\\alpha_{LR}[\\gamma_R\\alpha_{UR}^2\\sigma_U^2 + \\alpha_{UR}\\alpha_{UT}\\sigma_U^2 + \\gamma_R \\sigma_{\\varepsilon_R}^2]}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} = \\frac{\\alpha_{LR}\\gamma_R(\\alpha_{UR}^2\\sigma_U^2 + \\sigma_{\\varepsilon_R}^2) + \\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} = \\alpha_{LR}\\gamma_R + \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n    \n    将此代回 $\\beta_L$ 的表达式中：\n    $\\beta_L = (\\gamma_L + \\gamma_R \\alpha_{LR}) - \\left( \\alpha_{LR}\\gamma_R + \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} \\right)$\n    $\\beta_L = \\gamma_L - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$\n\n4.  **推导偏倚 B:**\n    渐近偏倚是 $B = \\beta_L - \\gamma_L$。\n    $B = \\left( \\gamma_L - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2} \\right) - \\gamma_L = - \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}$。\n\n定性地讲，偏倚的产生是由于因果模型的结构。变量 $R_j$ 是一个“对撞因子”，因为它是 $L_i$（我们感兴趣的变量）和 $U_j$（未观测到的混杂因素）的共同效应。根据假设，$L_i$ 和 $U_j$ 是独立的。然而，以它们的共同效应 $R_j$ 为条件（这正是多元回归分析所做的），会在 $L_i$ 和 $U_j$ 之间引入统计关联。这打开了一条从 $L_i$ 到 $T_j$ 的虚假的、非因果的“后门路径”，即 $L_i \\leftarrow \\text{条件化} \\rightarrow U_j \\rightarrow T_j$。$L_i$ 的系数的 OLS 估计量 $\\beta_L$ 除了包含真实的直接效应 $\\gamma_L$ 外，还错误地包含了这条虚假路径，从而导致偏倚。偏倚项不为零，当且仅当构成这条诱导路径的所有环节都存在：$L_i$ 必须影响 $R_j$ ($\\alpha_{LR}\\neq0$），$U_j$ 必须影响 $R_j$ ($\\alpha_{UR}\\neq0$），且 $U_j$ 必须影响 $T_j$ ($\\alpha_{UT}\\neq0$）。",
            "answer": "$$\n\\boxed{- \\frac{\\alpha_{LR}\\alpha_{UR}\\alpha_{UT}\\sigma_U^2}{\\alpha_{UR}^2 \\sigma_U^2 + \\sigma_{\\varepsilon_R}^2}}\n$$"
        }
    ]
}