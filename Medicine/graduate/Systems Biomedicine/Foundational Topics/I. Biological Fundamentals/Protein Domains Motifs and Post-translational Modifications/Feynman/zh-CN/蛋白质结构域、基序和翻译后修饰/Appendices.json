{
    "hands_on_practices": [
        {
            "introduction": "蛋白质功能的实现依赖于精确的分子识别，例如一个结构域与一个短肽基序的结合。理解这些相互作用的物理化学基础是至关重要的。本练习将引导你使用等温滴定量热法 (ITC) 的模拟数据，通过计算吉布斯自由能变 ($\\Delta G$) 来剖析一个典型的磷酸化基序-结构域结合事件的热力学驱动力 。通过这项实践，你将学会区分焓驱动和熵驱动的过程，并将这些热力学参数与分子层面的相互作用（如氢键和疏水效应）联系起来。",
            "id": "4379776",
            "problem": "一个识别翻译后修饰肽基序的模块化信号蛋白域通过等温滴定微量热法 (ITC) 进行测定。具体来说，一个 14-3-3 结构域与来自一个代谢调节剂的含磷酸化丝氨酸的基序结合。实验在恒温恒压下进行，溶液经过缓冲处理，确保没有相变发生，并且溶剂在量热法目的下表现理想。\n\n恒温恒压过程的基本热力学定义包括吉布斯自由能 $G$、焓 $H$、熵 $S$，以及自发结合与吉布斯自由能变 $\\Delta G$ 符号的关系。ITC 直接报告结合的摩尔焓变 $\\Delta H$，而温度标度的熵项 $-T\\Delta S$ 可以通过平衡结合等温线的温度依赖性来确定。在这些条件下，焓和熵贡献的符号和相对大小决定了结合是主要由焓驱动还是由熵驱动。\n\n对于在 $T = 298 \\ \\text{K}$ 下磷酸化基序与 14-3-3 结构域的相互作用，测得的量为：\n- $\\Delta H = -51.2 \\ \\text{kJ} \\ \\text{mol}^{-1}$，\n- $-T\\Delta S = +22.6 \\ \\text{kJ} \\ \\text{mol}^{-1}$。\n\n仅使用适用于恒温恒压的基本热力学关系，计算结合的吉布斯自由能变 $\\Delta G$。然后，根据 $\\Delta H$ 和 $-T\\Delta S$ 的符号和大小，确定结合是焓驱动还是熵驱动，并根据模块化结构域识别磷酸化基序的典型分子相互作用来论证你的结论。\n\n以 $\\text{kJ} \\ \\text{mol}^{-1}$ 为单位表示 $\\Delta G$ 的最终数值，并将答案四舍五入到四位有效数字。在你的演算过程中提供解释，但最终报告的值必须仅为 $\\Delta G$ 的数值。",
            "solution": "问题陈述经评估有效。它在科学上基于化学热力学原理在生物物理化学，特别是蛋白质-配体结合中的应用。问题提法很明确，提供了所有必要的数据（$\\Delta H$ 和 $-T\\Delta S$），以便使用一个基本的、符合上下文的方程来计算吉布斯自由能变（$\\Delta G$）。所提供的值对于所描述的生物相互作用是现实的。问题是客观的，没有歧义。因此，可以构建一个解决方案。\n\n主要任务是计算结合事件的吉布斯自由能变 $\\Delta G$，并确定该相互作用的热力学驱动力。在恒定温度（$T$）和压力下，吉布斯自由能、焓（$H$）和熵（$S$）之间的关系由吉布斯-亥姆霍兹方程给出：\n$$\n\\Delta G = \\Delta H - T\\Delta S\n$$\n这个方程是确定一个过程自发性的基础。$\\Delta G$ 的负值表示一个自发过程，而正值表示一个非自发过程。\n\n问题提供了在温度 $T = 298 \\ \\text{K}$ 下，磷酸化基序与 14-3-3 结构域结合的以下实验测量量：\n1.  摩尔焓变，$\\Delta H = -51.2 \\ \\text{kJ} \\ \\text{mol}^{-1}$。\n2.  对自由能的熵贡献，$-T\\Delta S = +22.6 \\ \\text{kJ} \\ \\text{mol}^{-1}$。\n\n吉布斯-亥姆霍兹方程可以方便地改写以直接使用所提供的项：\n$$\n\\Delta G = (\\Delta H) + (-T\\Delta S)\n$$\n将给定值代入此方程：\n$$\n\\Delta G = (-51.2 \\ \\text{kJ} \\ \\text{mol}^{-1}) + (+22.6 \\ \\text{kJ} \\ \\text{mol}^{-1})\n$$\n$$\n\\Delta G = -28.6 \\ \\text{kJ} \\ \\text{mol}^{-1}\n$$\n问题要求最终答案四舍五入到四位有效数字。计算出的值 $-28.6$ 有三位有效数字。为了用四位有效数字表示，我们添加一个尾随零：\n$$\n\\Delta G = -28.60 \\ \\text{kJ} \\ \\text{mol}^{-1}\n$$\n$\\Delta G$ 的符号为负，这证实了在指定条件下结合过程是自发的。\n\n接下来，我们必须确定结合是焓驱动还是熵驱动。我们分析焓项和熵项对总自由能变的贡献。\n-   焓项为 $\\Delta H = -51.2 \\ \\text{kJ} \\ \\text{mol}^{-1}$。该项为负值，表示过程是放热的且在能量上是有利的。这个有利的贡献促进了结合。\n-   熵项为 $-T\\Delta S = +22.6 \\ \\text{kJ} \\ \\text{mol}^{-1}$。该项为正值，意味着 $T\\Delta S$ 项为负值（$T\\Delta S = -22.6 \\ \\text{kJ} \\ \\text{mol}^{-1}$）。由于 $T$ 是正数，熵变本身 $\\Delta S$ 必须是负数。负的 $\\Delta S$ 表示有序性增加，这对于自发过程是不利的。这个不利的贡献阻碍了结合。\n\n结合被认为是**焓驱动**的，因为大的、有利的焓变（$|\\Delta H| = 51.2 \\ \\text{kJ} \\ \\text{mol}^{-1}$）是主导驱动力，并成功克服了相反的、不利的熵变（此处表示为 $|-T\\Delta S| = 22.6 \\ \\text{kJ} \\ \\text{mol}^{-1}$）。净结果是一个自发反应（$\\Delta G < 0$）。\n\n这种热力学特征的分子层面解释根植于形成的相互作用类型和系统有序性的变化。\n-   **有利的焓（$\\Delta H < 0$）：** 大的负焓变源于在结合口袋中形成的强而特异的非共价相互作用，这些相互作用释放能量。对于一个结合磷酸化丝氨酸的 14-3-3 结构域，这些相互作用通常包括：\n    1.  磷酸丝氨酸上的二价阴离子磷酸基团（$-\\text{PO}_3^{2-}$）与结构域结合裂隙内的一组带正电荷的残基（例如精氨酸、赖氨酸）之间的强静电相互作用（盐桥）。\n    2.  肽主链、肽侧链和蛋白质极性残基之间广泛的氢键网络。\n    - 这些高度特异性和方向性的相互作用在能量上比单个分子与溶剂（水）的相互作用更有利，从而导致净热量释放。\n\n-   **不利的熵（$\\Delta S < 0$）：** 阻碍结合的负熵变主要是由于系统有序性的增加。\n    1.  **平动和转动自由度的损失：** 两个独立的分子（蛋白质结构域和肽基序）结合形成一个单一的、移动性较差的复合物，从而减少了总的平动和转动熵。\n    2.  **构象自由度的损失：** 柔性的、非结构化的肽基序在结合后被锁定在一个特定的、有序的构象中。同样，蛋白质结构域表面的柔性环也可能变得更加刚性。这种运动自由度的“冻结”代表了构象熵的显著减少。\n    - 虽然从结合表面置换出有序水分子（疏水效应）可以对 $\\Delta S$ 做出有利的（正的）贡献，但在这种情况下，总熵变为负。这表明生物分子的结合和构象限制所带来的有序化效应占主导地位。\n\n总之，这种结合是焓驱动相互作用的一个典型案例，其中强而特异的静电和氢键相互作用的形成提供了能量，以“支付”形成有序复合物所带来的熵罚。",
            "answer": "$$\n\\boxed{-28.60}\n$$"
        },
        {
            "introduction": "细胞信号通路的核心是动态的调控网络，其中蛋白质翻译后修饰（PTM）的水平由相互拮抗的酶（如激酶和磷酸酶）精确控制。本练习构建了一个动力学模型，用于模拟一个由支架蛋白调节的磷酸化-去磷酸化循环 。你将通过计算来确定目标蛋白在稳态时的磷酸化比例，从而深入理解细胞如何通过 SH2 和 WW 等模块化结构域来整合信号并微调响应。",
            "id": "4379708",
            "problem": "一种胞质蛋白 $P$ 包含一个可以被磷酸化的单一丝氨酸基序，产生磷酸化状态 $P_{p}$。一种丝氨酸/苏氨酸激酶 $K$ 通过其Src同源2（SH2）结构域识别一个对接基序，而一种丝氨酸/苏氨酸磷酸酶 $F$ 通过其色氨酸（WW）结构域被招募到一个支架上。在生理条件下，即三磷酸腺苷（ATP）近似恒定、底物占有率低以及酶浓度恒定的情况下，该基序的磷酸化和去磷酸化通量可以分别被建模为相对于 $[P]$ 和 $[P_{p}]$ 的伪一级过程。\n\nSH2结构域介导的激酶 $K$ 到支架肽 $S$ 的招募调节了磷酸化的有效催化速率常数。设SH2–$S$ 相互作用的解离常数为 $K_{d}^{D} = 2.0\\,\\mu\\text{M}$，游离支架肽浓度为 $[S] = 5.0\\,\\mu\\text{M}$。假设只有一个结合位点且 $[S] \\gg [K]_{\\text{tot}}$，则具有被占据对接位点的激酶分子比例为 $f_{D} = \\dfrac{[S]}{K_{d}^{D} + [S]}$。当对接位点被占据时，有效的伪一级磷酸化速率常数为 $k_{\\text{kin}}^{\\text{on}} = 0.08\\,\\text{s}^{-1}$；当未被占据时，为 $k_{\\text{kin}}^{\\text{off}} = 0.01\\,\\text{s}^{-1}$。总的有效磷酸化速率常数是加权平均值 $k_{\\text{kin}} = f_{D}\\,k_{\\text{kin}}^{\\text{on}} + (1 - f_{D})\\,k_{\\text{kin}}^{\\text{off}}$。\n\n类似地，WW结构域介导的磷酸酶 $F$ 到支架基序 $M$ 的招募调节了有效的去磷酸化速率常数。设WW–$M$ 相互作用的解离常数为 $K_{d}^{WW} = 10\\,\\mu\\text{M}$，游离支架基序浓度为 $[M] = 20\\,\\mu\\text{M}$。通过WW结构域结合的磷酸酶分子比例为 $f_{WW} = \\dfrac{[M]}{K_{d}^{WW} + [M]}$。在没有WW介导的招募时，基础伪一级去磷酸化速率常数为 $k_{\\text{phos},0} = 0.06\\,\\text{s}^{-1}$。当WW结构域被占据时，局部微环境使催化速率降低一个因子 $r = 0.5$，因此有效的去磷酸化速率常数为 $k_{\\text{phos}} = (1 - f_{WW})\\,k_{\\text{phos},0} + f_{WW}\\,(r\\,k_{\\text{phos},0})$。\n\n在稳态时，该基序的质量作用平衡满足\n$$\n\\frac{d[P_{p}]}{dt} = k_{\\text{kin}}[P] - k_{\\text{phos}}[P_{p}] = 0,\n$$\n这意味着一个恒定的比率 $\\dfrac{[P_{p}]}{[P]} = \\dfrac{k_{\\text{kin}}}{k_{\\text{phos}}}$。\n\n使用以上信息计算稳态比率 $\\dfrac{[P_{p}]}{[P]}$。将你的最终答案表示为一个无量纲小数，并将结果四舍五入到四位有效数字。",
            "solution": "用户希望根据一个由支架调节的酶动力学模型，确定磷酸化蛋白与未磷酸化蛋白的稳态比率 $\\dfrac{[P_{p}]}{[P]}$。\n\n首先验证问题以确保其科学上合理、定义明确且客观。\n\n### 步骤1：提取已知条件\n- 激酶 $K$ 对磷酸化的调节：\n  - SH2–$S$ 相互作用的解离常数：$K_{d}^{D} = 2.0\\,\\mu\\text{M}$\n  - 游离支架肽浓度：$[S] = 5.0\\,\\mu\\text{M}$\n  - 具有被占据对接位点的激酶比例：$f_{D} = \\dfrac{[S]}{K_{d}^{D} + [S]}$\n  - 伪一级磷酸化速率常数（对接位点被占据）：$k_{\\text{kin}}^{\\text{on}} = 0.08\\,\\text{s}^{-1}$\n  - 伪一级磷酸化速率常数（对接位点未被占据）：$k_{\\text{kin}}^{\\text{off}} = 0.01\\,\\text{s}^{-1}$\n  - 总有效磷酸化速率常数：$k_{\\text{kin}} = f_{D}\\,k_{\\text{kin}}^{\\text{on}} + (1 - f_{D})\\,k_{\\text{kin}}^{\\text{off}}$\n\n- 磷酸酶 $F$ 对去磷酸化的调节：\n  - WW–$M$ 相互作用的解离常数：$K_{d}^{WW} = 10\\,\\mu\\text{M}$\n  - 游离支架基序浓度：$[M] = 20\\,\\mu\\text{M}$\n  - 通过WW结构域结合的磷酸酶比例：$f_{WW} = \\dfrac{[M]}{K_{d}^{WW} + [M]}$\n  - 基础伪一级去磷酸化速率常数：$k_{\\text{phos},0} = 0.06\\,\\text{s}^{-1}$\n  - WW结构域被占据时催化速率降低因子：$r = 0.5$\n  - 有效去磷酸化速率常数：$k_{\\text{phos}} = (1 - f_{WW})\\,k_{\\text{phos},0} + f_{WW}\\,(r\\,k_{\\text{phos},0})$\n\n- 稳态条件：\n  - $\\dfrac{d[P_{p}]}{dt} = k_{\\text{kin}}[P] - k_{\\text{phos}}[P_{p}] = 0$\n  - 稳态比率：$\\dfrac{[P_{p}]}{[P]} = \\dfrac{k_{\\text{kin}}}{k_{\\text{phos}}}$\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据：** 该问题描述了一个标准的磷酸化-去磷酸化循环的生化模型。使用SH2和WW结构域进行蛋白质-蛋白质相互作用和支架形成，通过此类相互作用调节酶活性，以及在低底物浓度条件下应用伪一级动力学，这些都是分子生物学和酶动力学中公认的原理。参数值在生理上是合理的。该模型是系统生物学中常用且有效的简化方法。\n- **定义明确：** 计算所需比率的所有必要常数、浓度和公式均已提供。问题是自洽的，并导向唯一的解。\n- **客观性：** 语言精确且量化。问题基于已建立的动力学模型，没有主观论断。\n\n### 步骤3：结论与行动\n该问题被认为是**有效的**。将推导出解决方案。\n\n解决方案需要计算磷酸化 ($k_{\\text{kin}}$) 和去磷酸化 ($k_{\\text{phos}}$) 的总有效速率常数，然后求出它们的比值。\n\n首先，我们计算具有被占据对接位点的激酶分子的比例 $f_{D}$。\n给定 $K_{d}^{D} = 2.0\\,\\mu\\text{M}$ 和 $[S] = 5.0\\,\\mu\\text{M}$：\n$$\nf_{D} = \\frac{[S]}{K_{d}^{D} + [S]} = \\frac{5.0\\,\\mu\\text{M}}{2.0\\,\\mu\\text{M} + 5.0\\,\\mu\\text{M}} = \\frac{5.0}{7.0} = \\frac{5}{7}\n$$\n\n接下来，我们使用这个比例来计算总有效磷酸化速率常数 $k_{\\text{kin}}$。\n给定 $k_{\\text{kin}}^{\\text{on}} = 0.08\\,\\text{s}^{-1}$ 和 $k_{\\text{kin}}^{\\text{off}} = 0.01\\,\\text{s}^{-1}$：\n$$\nk_{\\text{kin}} = f_{D}\\,k_{\\text{kin}}^{\\text{on}} + (1 - f_{D})\\,k_{\\text{kin}}^{\\text{off}}\n$$\n$$\nk_{\\text{kin}} = \\left(\\frac{5}{7}\\right) (0.08\\,\\text{s}^{-1}) + \\left(1 - \\frac{5}{7}\\right) (0.01\\,\\text{s}^{-1})\n$$\n$$\nk_{\\text{kin}} = \\left(\\frac{5}{7}\\right) (0.08\\,\\text{s}^{-1}) + \\left(\\frac{2}{7}\\right) (0.01\\,\\text{s}^{-1})\n$$\n$$\nk_{\\text{kin}} = \\frac{5 \\times 0.08 + 2 \\times 0.01}{7}\\,\\text{s}^{-1} = \\frac{0.40 + 0.02}{7}\\,\\text{s}^{-1} = \\frac{0.42}{7}\\,\\text{s}^{-1} = 0.06\\,\\text{s}^{-1}\n$$\n\n现在，我们计算通过WW结构域结合的磷酸酶分子的比例 $f_{WW}$。\n给定 $K_{d}^{WW} = 10\\,\\mu\\text{M}$ 和 $[M] = 20\\,\\mu\\text{M}$：\n$$\nf_{WW} = \\frac{[M]}{K_{d}^{WW} + [M]} = \\frac{20\\,\\mu\\text{M}}{10\\,\\mu\\text{M} + 20\\,\\mu\\text{M}} = \\frac{20}{30} = \\frac{2}{3}\n$$\n\n使用这个比例，我们计算有效的去磷酸化速率常数 $k_{\\text{phos}}$。\n给定 $k_{\\text{phos},0} = 0.06\\,\\text{s}^{-1}$ 和 $r = 0.5$：\n$$\nk_{\\text{phos}} = (1 - f_{WW})\\,k_{\\text{phos},0} + f_{WW}\\,(r\\,k_{\\text{phos},0})\n$$\n该表达式可以因式分解：\n$$\nk_{\\text{phos}} = k_{\\text{phos},0} \\left( (1 - f_{WW}) + r\\,f_{WW} \\right) = k_{\\text{phos},0} \\left( 1 - f_{WW} + r\\,f_{WW} \\right) = k_{\\text{phos},0} \\left( 1 - (1-r)f_{WW} \\right)\n$$\n代入数值：\n$$\nk_{\\text{phos}} = (0.06\\,\\text{s}^{-1}) \\left( 1 - (1-0.5)\\left(\\frac{2}{3}\\right) \\right)\n$$\n$$\nk_{\\text{phos}} = (0.06\\,\\text{s}^{-1}) \\left( 1 - (0.5)\\left(\\frac{2}{3}\\right) \\right) = (0.06\\,\\text{s}^{-1}) \\left( 1 - \\frac{1}{3} \\right)\n$$\n$$\nk_{\\text{phos}} = (0.06\\,\\text{s}^{-1}) \\left( \\frac{2}{3} \\right) = 0.04\\,\\text{s}^{-1}\n$$\n\n最后，我们计算稳态比率 $\\dfrac{[P_{p}]}{[P]}$。\n$$\n\\frac{[P_{p}]}{[P]} = \\frac{k_{\\text{kin}}}{k_{\\text{phos}}} = \\frac{0.06\\,\\text{s}^{-1}}{0.04\\,\\text{s}^{-1}} = \\frac{6}{4} = 1.5\n$$\n问题要求答案表示为无量纲小数，并四舍五入到四位有效数字。\n$$\n1.5 \\implies 1.500\n$$",
            "answer": "$$\n\\boxed{1.500}\n$$"
        },
        {
            "introduction": "在演化过程中，蛋白质通过结构域的重排、增删而获得新的功能，这些结构域的线性排列被称为结构域架构。定量比较这些架构对于理解蛋白质家族的演化关系和功能分化至关重要。本练习将带你进入计算生物学的领域，应用集合论中的 Jaccard 相似性指数来从三个不同维度（组分、数量和顺序）量化比较蛋白质结构域架构 。这项技能是分析大规模蛋白质组数据和推断蛋白质功能的基础。",
            "id": "4379742",
            "problem": "给定一组旁系同源蛋白对。每个蛋白由一个有序的结构域标识符列表（例如，精选名称或蛋白质家族（Pfam）标识符）表示，这些标识符共同构成一个结构域架构。使用集合论和序列组织的定义，为每对蛋白构建比较性结构域架构图，并计算三个Jaccard相似性指数以量化其分化程度。目标是量化结构域内容、多重性和顺序方面的相似性。\n\n基本原理：\n- 蛋白质是氨基酸的线性聚合物；蛋白质通常包含称为结构域的模块化亚基，这些亚基在不同蛋白质中反复出现，并与特定功能相关联。沿蛋白质的结构域线性顺序即为结构域架构。\n- 旁系同源体由基因复制产生，并可能在进化过程中在结构域架构上发生分化。\n- 两个集合 $X$ 和 $Y$ 之间的 Jaccard 指数定义为 $J(X,Y) = \\frac{|X \\cap Y|}{|X \\cup Y|}$。\n- 多重集是集合的推广，允许一个元素出现多次；对于多重集 $M$ 和 $N$，其逐元素计数分别为 $n_M(d)$ 和 $n_N(d)$，广义 Jaccard 指数定义为 $J(M,N) = \\frac{\\sum_d \\min\\{n_M(d), n_N(d)\\}}{\\sum_d \\max\\{n_M(d), n_N(d)\\}}$。\n\n需要实现的定义：\n- 设蛋白质架构为一个有序的结构域标识符列表 $A = [a_1, a_2, \\dots, a_m]$，类似地，$B = [b_1, b_2, \\dots, b_n]$。\n- 定义唯一结构域内容集合 $U_A = \\{a_i \\mid i \\in \\{1,\\dots,m\\}\\}$ 和 $U_B = \\{b_j \\mid j \\in \\{1,\\dots,n\\}\\}$。\n- 定义结构域多重性计数 $n_A(d)$ 等于结构域 $d$ 在 $A$ 中出现的次数，类似地，$n_B(d)$ 用于 $B$。\n- 定义邻接集合（有序二元组）为 $S_A = \\{(a_i, a_{i+1}) \\mid i \\in \\{1,\\dots,m-1\\}\\}$ 和 $S_B = \\{(b_j, b_{j+1}) \\mid j \\in \\{1,\\dots,n-1\\}\\}$，其中每个元素是连续结构域类型的有序对。允许重复；例如，如果 $a_i = a_{i+1}$，那么有序对 $(a_i, a_{i+1})$ 就是 $(d,d)$，并且在集合定义中，每个邻接位置都会被包含一次（集合会移除重复项）。\n- 为每对蛋白计算三个 Jaccard 相似性指数：\n  - 内容 Jaccard 指数 $J_c = \\frac{|U_A \\cap U_B|}{|U_A \\cup U_B|}$。\n  - 多重集 Jaccard 指数 $J_m = \\frac{\\sum_d \\min\\{n_A(d), n_B(d)\\}}{\\sum_d \\max\\{n_A(d), n_B(d)\\}}$，其中总和是针对存在于 $A$ 或 $B$ 中的所有结构域标识符 $d$ 进行计算。\n  - 邻接 Jaccard 指数 $J_a = \\frac{|S_A \\cap S_B|}{|S_A \\cup S_B|}$。\n\n边界约定：\n- 如果任何 Jaccard 指数的分母为 $0$（例如，$U_A$ 和 $U_B$ 均为空，或 $S_A$ 和 $S_B$ 均为空，或所有多重集计数均为零），则将该 Jaccard 指数定义为 $1$。\n\n角度单位不适用。没有物理单位。\n\n你的任务：\n- 对于下面的每个测试用例，根据上述定义计算 $J_c$、$J_m$ 和 $J_a$。\n- 将三个浮点数结果中的每一个都精确到小数点后 $6$ 位。\n\n测试套件（每个项目是一对架构 $(A,B)$，每个架构以结构域标识符的有序列表形式给出）：\n- 用例 $1$：$A = [\\text{\"Pkinase\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$, $B = [\\text{\"Pkinase\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$。\n- 用例 $2$：$A = [\\text{\"Pkinase\"}, \\text{\"SH2\"}]$, $B = [\\text{\"RRM\"}, \\text{\"WD40\"}]$。\n- 用例 $3$：$A = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"PH\"}, \\text{\"FHA\"}]$, $B = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$。\n- 用例 $4$：$A = [\\text{\"zf-C2H2\"}]$, $B = [\\text{\"zf-C2H2\"}, \\text{\"zf-C2H2\"}]$。\n- 用例 $5$：$A = [\\ ]$（空列表）, $B = [\\ ]$（空列表）。\n- 用例 $6$：$A = [\\text{\"SH3\"}, \\text{\"Pro-rich\"}, \\text{\"SH2\"}]$, $B = [\\text{\"SH2\"}, \\text{\"Pro-rich\"}, \\text{\"SH3\"}]$。\n\n最终输出格式：\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个项目是对应测试用例的一个三元素列表，顺序为 $[J_c, J_m, J_a]$。每个浮点数必须精确到小数点后 $6$ 位。\n- 例如，两个用例的有效整体格式如下所示：$[[0.123456,0.654321,1.000000],[1.000000,0.000000,0.500000]]$。",
            "solution": "### 步骤 1：提取已知信息\n\n问题提供了以下数据、定义和条件：\n- **旁系同源蛋白**：由基因复制产生的蛋白对。\n- **蛋白质结构域架构**：一个有序的结构域标识符列表。设两个架构为 $A = [a_1, a_2, \\dots, a_m]$ 和 $B = [b_1, b_2, \\dots, b_n]$。\n- **唯一结构域内容集合**：对于架构 $A$，这是 $U_A = \\{a_i \\mid i \\in \\{1,\\dots,m\\}\\}$。对于 $B$，这是 $U_B = \\{b_j \\mid j \\in \\{1,\\dots,n\\}\\}$。\n- **结构域多重性计数**：对于架构 $A$ 中的结构域 $d$，其计数为 $n_A(d)$。对于 $B$，其计数为 $n_B(d)$。\n- **邻接集合**：对于架构 $A$，它是序偶对（二元组）的集合 $S_A = \\{(a_i, a_{i+1}) \\mid i \\in \\{1,\\dots,m-1\\}\\}$。对于 $B$，它是 $S_B = \\{(b_j, b_{j+1}) \\mid j \\in \\{1,\\dots,n-1\\}\\}$。\n- **内容 Jaccard 指数 ($J_c$)**：$J_c = \\frac{|U_A \\cap U_B|}{|U_A \\cup U_B|}$。\n- **多重集 Jaccard 指数 ($J_m$)**：$J_m = \\frac{\\sum_d \\min\\{n_A(d), n_B(d)\\}}{\\sum_d \\max\\{n_A(d), n_B(d)\\}}$，对存在于 $A$ 或 $B$ 中的所有结构域 $d$ 求和。\n- **邻接 Jaccard 指数 ($J_a$)**：$J_a = \\frac{|S_A \\cap S_B|}{|S_A \\cup S_B|}$。\n- **边界约定**：如果任何 Jaccard 指数的分母为 $0$，则该指数定义为 $1$。\n- **舍入**：所有最终的浮点数结果必须精确到小数点后 $6$ 位。\n- **测试套件**：\n    - 用例 $1$：$A = [\\text{\"Pkinase\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$, $B = [\\text{\"Pkinase\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$\n    - 用例 $2$：$A = [\\text{\"Pkinase\"}, \\text{\"SH2\"}]$, $B = [\\text{\"RRM\"}, \\text{\"WD40\"}]$\n    - 用例 $3$：$A = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"PH\"}, \\text{\"FHA\"}]$, $B = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$\n    - 用例 $4$：$A = [\\text{\"zf-C2H2\"}]$, $B = [\\text{\"zf-C2H2\"}, \\text{\"zf-C2H2\"}]$\n    - 用例 $5$：$A = [\\ ]$, $B = [\\ ]$\n    - 用例 $6$：$A = [\\text{\"SH3\"}, \\text{\"Pro-rich\"}, \\text{\"SH2\"}]$, $B = [\\text{\"SH2\"}, \\text{\"Pro-rich\"}, \\text{\"SH3\"}]$\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n- **科学依据充分**：该问题在计算生物学和生物信息学领域有充分的依据。蛋白质结构域、结构域架构、旁系同源体以及使用像 Jaccard 指数这样的基于集合的相似性度量等概念，是比较蛋白质序列的标准且科学合理的方法。\n- **定义明确**：该问题在数学上是定义明确的。它为所有三个必需的度量指标（$J_c, J_m, J_a$）提供了明确、无歧义的定义，包括必要的集合和计数函数。所有输入数据（测试用例）均已提供。对于除以零的边界条件也已明确规定。这确保了每个测试用例都存在唯一且稳定的解。\n- **客观性**：问题以精确、客观的语言陈述。定义是形式化的，不依赖于主观解释。\n- **缺陷清单**：该问题没有表现出任何列出的缺陷。它是科学有效的、可形式化的、完整的、可行的、结构良好的、非平凡的且可验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。将开发一个解决方案。\n\n### 求解过程\n\n任务是为每对给定的蛋白质结构域架构 $(A, B)$ 计算三个不同的 Jaccard 相似性指数。这些指数分别基于唯一结构域内容（$J_c$）、结构域多重性（$J_m$）和结构域顺序/邻接性（$J_a$）来量化相似性。我们将对每个测试用例系统地应用所提供的定义。\n\n让我们以用例 3 为例来说明这个过程：\n$A = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"PH\"}, \\text{\"FHA\"}]$\\\n$B = [\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"SH2\"}, \\text{\"PH\"}]$\n\n**1. 内容 Jaccard 指数 ($J_c$)**\n该指数比较唯一结构域的集合，忽略计数和顺序。\n首先，我们构建唯一结构域内容集合 $U_A$ 和 $U_B$：\n$U_A = \\{\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"FHA\"}\\}$\n$U_B = \\{\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"SH2\"}\\}$\n\n接下来，我们找出它们的交集和并集：\n$U_A \\cap U_B = \\{\\text{\"Pkinase\"}, \\text{\"PH\"}\\}$\n$U_A \\cup U_B = \\{\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"FHA\"}, \\text{\"SH2\"}\\}$\n\n这些集合的基数是 $|U_A \\cap U_B| = 2$ 和 $|U_A \\cup U_B| = 4$。\n内容 Jaccard 指数是：\n$$ J_c = \\frac{|U_A \\cap U_B|}{|U_A \\cup U_B|} = \\frac{2}{4} = 0.5 $$\n\n**2. 多重集 Jaccard 指数 ($J_m$)**\n该指数考虑了每个结构域出现的次数。\n我们首先识别出两个架构中所有的唯一结构域，即集合 $U_A \\cup U_B$: $\\{\\text{\"Pkinase\"}, \\text{\"PH\"}, \\text{\"FHA\"}, \\text{\"SH2\"}\\}$。\n然后我们计算该集合中每个结构域 $d$ 的计数 $n_A(d)$ 和 $n_B(d)$。\n\n- 对于 $d = \\text{\"Pkinase\"}$：$n_A(d) = 1$, $n_B(d) = 1$。$\\min=1$, $\\max=1$。\n- 对于 $d = \\text{\"PH\"}$：$n_A(d) = 2$, $n_B(d) = 2$。$\\min=2$, $\\max=2$。\n- 对于 $d = \\text{\"FHA\"}$：$n_A(d) = 1$, $n_B(d) = 0$。$\\min=0$, $\\max=1$。\n- 对于 $d = \\text{\"SH2\"}$：$n_A(d) = 0$, $n_B(d) = 1$。$\\min=0$, $\\max=1$。\n\n分子是最小值的总和：\n$$ \\sum_d \\min\\{n_A(d), n_B(d)\\} = 1 + 2 + 0 + 0 = 3 $$\n分母是最大值的总和：\n$$ \\sum_d \\max\\{n_A(d), n_B(d)\\} = 1 + 2 + 1 + 1 = 5 $$\n多重集 Jaccard 指数是：\n$$ J_m = \\frac{3}{5} = 0.6 $$\n\n**3. 邻接 Jaccard 指数 ($J_a$)**\n该指数通过检查相邻对（二元组）的集合来比较结构域的顺序。\n首先，我们构建邻接集合 $S_A$ 和 $S_B$。一个长度为 $k$ 的架构将有 $k-1$ 个邻接关系。\n对于 $A = [a_1, a_2, a_3, a_4]$，$S_A = \\{(a_1, a_2), (a_2, a_3), (a_3, a_4)\\}$。\n$S_A = \\{(\\text{\"Pkinase\"}, \\text{\"PH\"}), (\\text{\"PH\"}, \\text{\"PH\"}), (\\text{\"PH\"}, \\text{\"FHA\"})\\}$\n对于 $B = [b_1, b_2, b_3, b_4]$，$S_B = \\{(b_1, b_2), (b_2, b_3), (b_3, b_4)\\}$。\n$S_B = \\{(\\text{\"Pkinase\"}, \\text{\"PH\"}), (\\text{\"PH\"}, \\text{\"SH2\"}), (\\text{\"SH2\"}, \\text{\"PH\"})\\}$\n\n接下来，我们找出这些有序对集合的交集和并集：\n$S_A \\cap S_B = \\{(\\text{\"Pkinase\"}, \\text{\"PH\"})\\}$\n$S_A \\cup S_B = \\{(\\text{\"Pkinase\"}, \\text{\"PH\"}), (\\text{\"PH\"}, \\text{\"PH\"}), (\\text{\"PH\"}, \\text{\"FHA\"}), (\\text{\"PH\"}, \\text{\"SH2\"}), (\\text{\"SH2\"}, \\text{\"PH\"})\\}$\n\n基数是 $|S_A \\cap S_B| = 1$ 和 $|S_A \\cup S_B| = 5$。\n邻接 Jaccard 指数是：\n$$ J_a = \\frac{|S_A \\cap S_B|}{|S_A \\cup S_B|} = \\frac{1}{5} = 0.2 $$\n\n该过程被系统地应用于所有测试用例以推导出最终结果。特别注意边界情况。例如，在用例 5 中，架构 $A$ 和 $B$ 都是空列表。这导致唯一结构域和邻接关系的集合为空，多重集指数的计数值总和为零。在这三种情况下，Jaccard 公式的分母都变为 $0$。根据指定的边界约定，$J_c$、$J_m$ 和 $J_a$ 都定义为 $1$。类似地，对于用例 4，第一个架构的长度为 $1$，因此其邻接集合 $S_A$ 为空。通过对给定严格定义的全面、分步应用，确保了为每对蛋白质架构正确计算出三个相似性指数。实现过程将把这个逻辑形式化。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ... # No scipy needed for this task.\n\ndef calculate_jaccards(A, B):\n    \"\"\"\n    Computes the Content, Multiset, and Adjacency Jaccard indices for two\n    protein domain architectures.\n\n    Args:\n        A (list): The first protein architecture, an ordered list of domain IDs.\n        B (list): The second protein architecture, an ordered list of domain IDs.\n\n    Returns:\n        tuple: A triplet of floats (J_c, J_m, J_a) rounded to 6 decimal places.\n    \"\"\"\n\n    # 1. Content Jaccard Index (J_c)\n    U_A = set(A)\n    U_B = set(B)\n    \n    union_c_size = len(U_A.union(U_B))\n    \n    if union_c_size == 0:\n        J_c = 1.0\n    else:\n        intersection_c_size = len(U_A.intersection(U_B))\n        J_c = intersection_c_size / union_c_size\n\n    # 2. Multiset Jaccard Index (J_m)\n    all_domains = U_A.union(U_B)\n    min_sum = 0\n    max_sum = 0\n    \n    # Using list.count() is simple but can be inefficient for long lists.\n    # For this problem's scale, it's perfectly acceptable.\n    for domain in all_domains:\n        count_A = A.count(domain)\n        count_B = B.count(domain)\n        min_sum += min(count_A, count_B)\n        max_sum += max(count_A, count_B)\n\n    if max_sum == 0:\n        J_m = 1.0\n    else:\n        J_m = min_sum / max_sum\n\n    # 3. Adjacency Jaccard Index (J_a)\n    S_A = set()\n    if len(A) > 1:\n        for i in range(len(A) - 1):\n            S_A.add((A[i], A[i+1]))\n            \n    S_B = set()\n    if len(B) > 1:\n        for i in range(len(B) - 1):\n            S_B.add((B[i], B[i+1]))\n\n    union_a_size = len(S_A.union(S_B))\n    \n    if union_a_size == 0:\n        J_a = 1.0\n    else:\n        intersection_a_size = len(S_A.intersection(S_B))\n        J_a = intersection_a_size / union_a_size\n        \n    return (\n        f\"{J_c:.6f}\",\n        f\"{J_m:.6f}\",\n        f\"{J_a:.6f}\"\n    )\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        ([\"Pkinase\", \"SH2\", \"PH\"], [\"Pkinase\", \"SH2\", \"PH\"]),\n        # Case 2\n        ([\"Pkinase\", \"SH2\"], [\"RRM\", \"WD40\"]),\n        # Case 3\n        ([\"Pkinase\", \"PH\", \"PH\", \"FHA\"], [\"Pkinase\", \"PH\", \"SH2\", \"PH\"]),\n        # Case 4\n        ([\"zf-C2H2\"], [\"zf-C2H2\", \"zf-C2H2\"]),\n        # Case 5\n        ([], []),\n        # Case 6\n        ([\"SH3\", \"Pro-rich\", \"SH2\"], [\"SH2\", \"Pro-rich\", \"SH3\"])\n    ]\n\n    results = []\n    for case in test_cases:\n        A, B = case\n        j_c, j_m, j_a = calculate_jaccards(A, B)\n        # Format the result for each case as a string representation of a list\n        results.append(f\"[{j_c},{j_m},{j_a}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}