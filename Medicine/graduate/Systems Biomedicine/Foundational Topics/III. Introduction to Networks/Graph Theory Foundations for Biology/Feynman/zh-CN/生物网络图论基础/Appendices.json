{
    "hands_on_practices": [
        {
            "introduction": "生物网络并非随机连接，而是包含了反复出现的、具有特定功能的结构模式，即“网络基序”（network motifs）。其中，三节点反馈回路（3-cycles）是最重要的基序之一，它们在调控系统稳定性、状态切换和振荡行为中扮演着核心角色。本练习将展示一个连接线性代数与图结构的强大实例：你将利用邻接矩阵立方的迹$\\mathrm{tr}(A^3)$来精确量化一个基因调控网络中三节点反馈回路的数量。这项实践旨在培养你将抽象数学性质转化为具体生物学洞见的能力，这是系统生物学研究的一项核心技能。",
            "id": "4349908",
            "problem": "考虑一个包含六个转录因子（TF）的有向基因调控网络，该网络由一个简单的有向图（无自环、无多重边）建模，其结构由一个 $6 \\times 6$ 的邻接矩阵 $A$ 编码。其中，如果存在从转录因子 $i$ 到转录因子 $j$ 的有向相互作用，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。矩阵 $A$ 为\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  0  0  1  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  1  0  0 \\\\\n0  1  0  0  1  0 \\\\\n0  0  1  0  0  1 \\\\\n1  0  0  1  0  0\n\\end{pmatrix}.\n$$\n请仅使用图论中关于邻接矩阵和有向图游走的核心定义和成熟结论，推导量$\\mathrm{tr}(A^{3})$如何揭示该网络中存在的有向 3-环路（三节点反馈回路）。然后，为给定的矩阵 $A$ 计算$\\mathrm{tr}(A^{3})$的值。您的最终答案必须是$\\mathrm{tr}(A^{3})$的值，表示为一个实数。此外，作为推导的一部分，请简要论证有向 3-环路在系统生物医学中的生物学意义。最终数值答案中请勿包含任何单位。",
            "solution": "问题要求推导邻接矩阵立方的迹$\\mathrm{tr}(A^3)$与图中定向 3-环路数量之间的关系，并随后为一个特定的基因调控网络计算该值。\n\n首先，我们建立理论基础。图论中的一个基本结论指出，对于一个有 $n$ 个节点和邻接矩阵 $A$ 的简单有向图，矩阵幂 $A^k$ 的元素 $(A^k)_{ij}$ 给出了从节点 $i$ 到节点 $j$ 的长度为 $k$ 的不同游走（walk）的数量。一个长度为 $k$ 的游走是一个包含 $k+1$ 个节点的序列 $v_0, v_1, \\dots, v_k$，使得对于所有的 $m \\in \\{1, \\dots, k\\}$，都存在一条从 $v_{m-1}$ 到 $v_m$ 的有向边。\n\n当 $k=3$ 时，元素 $(A^3)_{ij}$ 是从节点 $i$ 到节点 $j$ 的长度为 3 的不同游走的数量。矩阵 $A^3$ 是 $A^2$ 和 $A$ 的乘积，其中 $(A^2)_{ip} = \\sum_{q=1}^{n} A_{iq}A_{qp}$。因此，$A^3$ 的元素由下式给出：\n$$ (A^3)_{ij} = \\sum_{p=1}^{n} (A^2)_{ip} A_{pj} = \\sum_{p=1}^{n} \\left( \\sum_{q=1}^{n} A_{iq}A_{qp} \\right) A_{pj} = \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pj} $$\n这个表达式计算了形如 $i \\to q \\to p \\to j$ 的游走的数量。\n\n$A^3$ 的迹，记为 $\\mathrm{tr}(A^3)$，是 $A^3$ 对角线元素之和：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii} $$\n代入对角线元素的表达式，我们得到：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pi} $$\n每一项 $A_{iq}A_{qp}A_{pi}$ 等于 $1$ 当且仅当边序列 $(i, q)$、$(q, p)$ 和 $(p, i)$ 在图中都存在，形成一个长度为 3 的闭合游走：$i \\to q \\to p \\to i$。否则，该项为 $0$。因此，$\\mathrm{tr}(A^3)$ 计算了图中长度为 3 的闭合游走的总数。\n\n让我们分析长度为 3 的闭合游走的类型：\n一个游走 $i \\to q \\to p \\to i$ 可以有重复的节点。\n1. 所有节点相同：$i=p=q$。游走为 $i \\to i \\to i \\to i$。它的存在要求 $A_{ii}=1$。然而，题目说明该图没有自环，这可由给定矩阵 $A$ 的所有对角线元素都为 0 得到证实。因此，这种类型的游走在我们的网络中不存在。\n2. 两个节点相同（例如，$i=p$, $p \\neq q$）。游走为 $i \\to q \\to i \\to i$。这将需要一条从 $i$ 到 $i$ 的边，因此 $A_{ii}=1$，而事实并非如此。同样的逻辑适用于 $i=q$ 或 $p=q$ 的情况（例如，$i \\to p \\to p \\to i$ 需要 $A_{pp}=1$）。\n3. 所有三个节点 $i, p, q$ 都是不同的。游走 $i \\to q \\to p \\to i$ 是一个长度为 3 的有向环路，也称为 3-环路。\n\n由于没有自环，排除了包含重复节点的游走，因此量 $\\mathrm{tr}(A^3)$ 只计算了所有三个节点都不同的长度为 3 的闭合游走。每个这样的游走对应一个唯一的有向 3-环路。一个特定的 3-环路，比如说涉及节点 $\\{v_1, v_2, v_3\\}$ 和边 $(v_1, v_2)$、$(v_2, v_3)$ 和 $(v_3, v_1)$，在 $\\mathrm{tr}(A^3)$ 的求和中将被计算三次：\n- 作为闭合游走 $v_1 \\to v_2 \\to v_3 \\to v_1$ 被计算一次（当 $i=v_1$ 时）。\n- 作为闭合游走 $v_2 \\to v_3 \\to v_1 \\to v_2$ 被计算一次（当 $i=v_2$ 时）。\n- 作为闭合游走 $v_3 \\to v_1 \\to v_2 \\to v_3$ 被计算一次（当 $i=v_3$ 时）。\n\n因此，$\\mathrm{tr}(A^3)$ 等于图中有向 3-环路数量的 3 倍。如果我们用 $N_3$ 表示 3-环路的数量，则有 $\\mathrm{tr}(A^3) = 3 N_3$。这就说明了这个量如何揭示这些结构的存在和丰度。\n\n在系统生物医学中，有向环路是基本的网络基序（network motif），称为反馈回路。一个 3-环路代表一个三组分反馈回路（例如，转录因子 1 调控转录因子 2，转录因子 2 调控转录因子 3，而转录因子 3 又反过来调控转录因子 1）。这类基序具有深远的生物学意义，因为它们是复杂动态行为的关键组成部分。例如，负反馈回路（含有奇数个抑制性相互作用的回路）对于促进稳定性和稳态至关重要。正反馈回路（含有偶数个抑制性相互作用的回路）可以产生双稳态，允许细胞在不同的功能状态之间切换，这是细胞分化的核心过程。正负反馈的相互作用可以产生振荡，这是细胞周期和昼夜节律等生物节律的基础。因此，识别和量化 3-环路是剖析基因调控网络功能逻辑的关键一步。\n\n现在，我们为给定的邻接矩阵 $A$ 计算$\\mathrm{tr}(A^3)$：\n$$ A = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} $$\n首先，我们计算 $A^2 = A \\times A$：\n$$ A^2 = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  2  1  0  2 \\\\ 2  1  0  2  1  0 \\\\ 0  2  0  0  2  0 \\\\ 0  0  2  1  0  2 \\\\ 2  0  0  2  0  0 \\\\ 0  2  0  0  2  0 \\end{pmatrix} $$\n接下来，我们计算 $A^3 = A^2 \\times A$。为了求迹，我们只需要对角线元素。$A^3$ 的第 $i$ 个对角线元素 $(A^3)_{ii}$ 是 $A^2$ 的第 $i$ 行与 $A$ 的第 $i$ 列的点积。\n$(A^3)_{11} = (0)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 2+2=4$\n$(A^3)_{22} = (2)(1) + (1)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) = 2+2=4$\n$(A^3)_{33} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 2+2=4$\n$(A^3)_{44} = (0)(0) + (0)(1) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 2+2=4$\n$(A^3)_{55} = (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) + (0)(0) = 2+2=4$\n$(A^3)_{66} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 2+2=4$\n\n$A^3$ 的对角线元素都等于 $4$。迹是这些元素的和：\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{6} (A^3)_{ii} = 4 + 4 + 4 + 4 + 4 + 4 = 6 \\times 4 = 24 $$\n$\\mathrm{tr}(A^3)$ 的值为 $24$。这表明在这个基因调控网络中存在 $N_3 = \\frac{24}{3} = 8$ 个不同的有向 3-环路。",
            "answer": "$$\\boxed{24}$$"
        },
        {
            "introduction": "为了理解信号或影响如何在生物网络中传播，我们常常将这些过程建模为随机游走或马尔可夫链。然而，要使这类模型产生有意义且稳定的预测（例如，对节点重要性的唯一排名），其底层的网络结构必须满足特定属性。本练习将深入探讨“遍历性”（ergodicity）这一关键概念，它保证了马尔可夫链拥有唯一的长期稳态分布。你将分析一个简单的生物网络为何可能不满足遍历性，并理解谷歌PageRank算法中著名的“瞬移”（teleportation）机制是如何从根本上解决这个问题的。",
            "id": "4349898",
            "problem": "考虑一个包含节点 $X_1$、$X_2$、$X_3$ 和 $X_4$ 的有向生物相互作用网络，其中有向边 $X_i \\to X_j$ 表示生物实体 $X_i$ 对 $X_j$ 的潜在影响（例如，转录因子作用、信号传导或代谢转换）。通过以下基本规则在该网络上定义一个离散时间马尔可夫链：(i) 状态空间是集合 $\\{X_1,X_2,X_3,X_4\\}$，(ii) 一步转移概率通过对出边进行归一化得到，使得每个节点从其出邻居中进行均匀选择，以及 (iii) 如果一个节点没有出边，它将以概率 $1$ 停留在自身（在下面的网络中没有出现此类节点）。边如下：\n- 从 $X_1$ 到 $X_2$ 和 $X_3$，\n- 从 $X_2$ 到 $X_1$，\n- 从 $X_3$ 到 $X_4$，\n- 从 $X_4$ 到 $X_3$。\n\n使用核心定义：一个具有转移矩阵 $P$ 的马尔可夫链是遍历的（ergodic），如果它既是不可约的（irreducible，每个状态与其他每个状态互通）又是非周期的（aperiodic，返回每个状态的次数的最大公约数为 $1$）。一个强连通分量（strongly connected component）是一个最大的节点子集，其中每个节点都可以从该子集中的其他每个节点到达。一个汇强连通分量（sink strongly connected component）是一个没有指向其他分量的出边的强连通分量。瞬移（Teleportation）指的是一种机制，在每一步中，链以概率 $\\alpha$（其中 $0  \\alpha  1$）跳转到一个从指定的节点概率分布 $v$ 中抽取的节点，并以概率 $1-\\alpha$ 遵循基于网络的转移规则。\n\n构建与该网络对应的行随机转移矩阵 $P$。然后，严格根据上述核心定义和广为接受的事实（包括针对非负本原矩阵的 Perron–Frobenius 定理），评估为什么该网络上的马尔可夫链可能不是遍历的。接下来，考虑带有参数 $\\alpha$ 和瞬移分布 $v$ 的瞬移增强链。确定在什么条件下，对于开区间 $(0,1)$ 内的任何 $\\alpha$ 选择，增强链都变得遍历，并从第一性原理证明该结论。\n\n哪个选项正确地描述了原始链中遍历性的失效以及通过瞬移恢复遍历性的情况？\n\nA. 该链不是遍历的，因为由于存在一个汇强连通分量而导致其是可约的，并且它包含一个引起周期性的 2-周期；在瞬移条件下，对于任何 $0  \\alpha  1$ 和任何满足对所有节点 $i$ 都有 $v_i > 0$ 的分布 $v$，修改后的转移矩阵具有严格为正的项，因此它是不可约和非周期的，因而是遍历的，具有唯一的平稳分布，并且从任何初始分布都会收敛。\n\nB. 该链已经是遍历的，因为它包含至少一个周期；瞬移是不必要的，并且对于任何 $0  \\alpha  1$ 都不影响收敛性。\n\nC. 非遍历性仅在存在零出度节点时出现；添加瞬移，对于任何 $0  \\alpha  1$ 和任何分布 $v$——即使 $v$ 对某些节点分配了零概率——也总能保证遍历性。\n\nD. 瞬移可以修复可约性但不能修复周期性；汇分量中的 2-周期持续存在，因此对于所有 $0  \\alpha  1$，该链仍然是非遍历的。\n\nE. 在瞬移下实现遍历性需要设置 $\\alpha=1$；对于 $0  \\alpha  1$，无论 $v$ 的选择如何，该链仍然是非遍历的。",
            "solution": "问题要求分析一个在给定有向生物网络上定义的马尔可夫链，评估其遍历性，并评价瞬移如何影响其性质。解决方案需要构建转移矩阵，找出任何遍历性缺失的原因，并确定在何种条件下瞬移可以恢复遍历性。\n\n首先，我们验证问题陈述的有效性。\n\n**步骤1：提取已知条件**\n- 节点：$X_1, X_2, X_3, X_4$。\n- 边：$X_1 \\to X_2$, $X_1 \\to X_3$, $X_2 \\to X_1$, $X_3 \\to X_4$, $X_4 \\to X_3$。\n- 马尔可夫链规则：\n    - 状态空间：$\\{X_1, X_2, X_3, X_4\\}$。\n    - 转移概率：一个有出边的节点会随机均匀地转移到它的一个邻居节点。\n    - 零出度规则：一个没有出边的节点以概率 $1$ 停留在自身。（问题陈述该网络中没有此类节点）。\n- 核心定义：\n    - 遍历的（Ergodic）：不可约且非周期。\n    - 不可约的（Irreducible）：每个状态都能与其他每个状态互通。\n    - 非周期的（Aperiodic）：对于每个状态，所有可能的返回路径长度的最大公约数 (GCD) 为 $1$。\n    - 强连通分量 (SCC)：一个最大的节点子集，其中每个节点都可以从该子集中的其他每个节点到达。\n    - 汇强连通分量 (Sink SCC)：一个没有出边指向分量外节点的 SCC。\n    - 瞬移（Teleportation）：以概率 $\\alpha \\in (0,1)$ 跳转到从分布 $v$ 中抽取的节点；以概率 $1-\\alpha$ 遵循网络转移规则。\n\n**步骤2：使用提取的已知条件进行验证**\n- 该问题具有科学依据，使用了马尔可夫链理论和图论中的标准定义，这些都是系统生物学中的基本工具。\n- 该问题是良定的（well-posed）。网络结构和构建转移矩阵的规则是无歧义的，从而导出一个唯一的矩阵和一个可解的问题。\n- 该问题是客观的，用精确的数学语言陈述。\n- 设置是完整且一致的；所有必要的信息都已提供。\n- 该网络是一个有效的抽象模型，且该问题在数学上是可行的。\n- 该问题是非平凡的，需要应用几个相互关联的概念（不可约性、周期性、强连通分量、瞬移）。\n\n**步骤3：结论与行动**\n问题是有效的。可以开始解题过程。\n\n**推导**\n\n**1. 构建转移矩阵 $P$**\n令状态索引为 $1, 2, 3, 4$，分别对应节点 $X_1, X_2, X_3, X_4$。转移概率 $P_{ij}$ 是从状态 $i$ 移动到状态 $j$ 的概率。\n\n- 从状态 $X_1$（出度为 $2$）：有边指向 $X_2$ 和 $X_3$。\n  $P_{12} = 1/2$，$P_{13} = 1/2$。从 $X_1$ 出发的其他概率为 $0$。\n- 从状态 $X_2$（出度为 $1$）：有边指向 $X_1$。\n  $P_{21} = 1$。从 $X_2$ 出发的其他概率为 $0$。\n- 从状态 $X_3$（出度为 $1$）：有边指向 $X_4$。\n  $P_{34} = 1$。从 $X_3$ 出发的其他概率为 $0$。\n- 从状态 $X_4$（出度为 $1$）：有边指向 $X_3$。\n  $P_{43} = 1$。从 $X_4$ 出发的其他概率为 $0$。\n\n得到的行随机转移矩阵 $P$ 为：\n$$ P = \\begin{pmatrix} 0  1/2  1/2  0 \\\\ 1  0  0  0 \\\\ 0  0  0  1 \\\\ 0  0  1  0 \\end{pmatrix} $$\n\n**2. 原始链的遍历性分析**\n一个马尔可夫链是遍历的，当且仅当它既是不可约的又是非周期的。\n\n- **不可约性分析**：我们检查是否每个状态都能从其他任何状态到达。\n  - 该图有两个强连通分量 (SCC)：$C_1 = \\{X_1, X_2\\}$ 和 $C_2 = \\{X_3, X_4\\}$。在每个分量内部，节点是相互可达的（例如，$X_1 \\to X_2 \\to X_1$ 和 $X_3 \\to X_4 \\to X_3$）。\n  - 存在一条从 $C_1$ 到 $C_2$ 的边 $X_1 \\to X_3$。这意味着 $C_2$ 中的状态可以从 $C_1$ 中的状态到达。\n  - 然而，没有从 $C_2$ 到 $C_1$ 的边。例如，无法从状态 $X_3$ 到达状态 $X_1$。任何从 $\\{X_3, X_4\\}$ 开始的路径都被困在这个子集内。\n  - 由于并非所有状态都互通，该链是**可约的**。\n  - 分量 $C_2 = \\{X_3, X_4\\}$ 是一个**汇强连通分量**，因为没有边离开它。存在多个强连通分量，其中一个是汇，这是导致可约性的一个结构性原因。\n\n- **非周期性分析**：我们检查每个状态的周期，定义为从该状态出发回到自身的所有可能路径长度的最大公约数。\n  - 对于状态 $X_1$：任何返回路径都必须从 $X_1$ 到一个邻居再返回。唯一返回 $X_1$ 的路径来自 $X_2$。因此，任何环路都必须是 $X_1 \\to X_2 \\to X_1 \\to ...$ 的形式。最小返回路径是 $X_1 \\to X_2 \\to X_1$，长度为 $2$。所有返回路径的长度都将是 $2$ 的倍数（例如，$4, 6, \\dots$）。$\\{2, 4, 6, \\dots\\}$ 的最大公约数是 $2$。所以，状态 $X_1$ 是周期的，周期为 $2$。\n  - 对于状态 $X_3$：唯一的返回路径是 $X_3 \\to X_4 \\to X_3$，其长度为 $2$。所有返回路径的长度都是 $2$ 的倍数。最大公约数是 $2$。状态 $X_3$ 是周期的，周期为 $2$。\n  - 由于状态的周期为 $2 \\neq 1$，该链是**周期的**。\n\n对原始链的结论：该马尔可夫链不是遍历的，因为它既是**可约的**也是**周期的**。\n\n**3. 瞬移增强链的分析**\n增强链的转移矩阵 $P'$ 由 $P' = (1-\\alpha)P + \\alpha \\mathbf{1} v^T$ 给出，其中 $\\mathbf{1}$ 是一个全1列向量，$v$ 是瞬移概率向量。矩阵项 $P'_{ij}$ 为：\n$$ P'_{ij} = (1-\\alpha)P_{ij} + \\alpha v_j $$\n我们需要找到使链对于任何 $\\alpha \\in (0,1)$ 都是遍历的关于 $v$ 的条件。\n\n我们施加条件，即对于所有状态 $j \\in \\{1, 2, 3, 4\\}$，$v_j > 0$。\n因为 $\\alpha \\in (0,1)$，我们有 $1-\\alpha > 0$ 和 $\\alpha > 0$。\n项 $(1-\\alpha)P_{ij}$ 是非负的，因为 $P_{ij} \\ge 0$。\n项 $\\alpha v_j$ 是严格为正的，因为 $\\alpha > 0$ 且我们假设了 $v_j > 0$。\n因此，新矩阵中的每一项都是严格为正的：\n$$ P'_{ij} = (1-\\alpha)P_{ij} + \\alpha v_j > 0 $$\n一个所有项都严格为正的转移矩阵被称为正矩阵。这样的矩阵对马尔可夫链的性质有深刻的影响。\n\n- **不可约性**：由于对所有 $i,j$ 都有 $P'_{ij} > 0$，所以在一步之内从任何状态 $i$ 转移到任何状态 $j$ 的概率都非零。这直接意味着该链是**不可约的**。\n\n- **非周期性**：对于任何状态 $i$，一步返回的概率是 $P'_{ii} = (1-\\alpha)P_{ii} + \\alpha v_i$。由于 $v_i > 0$ 和 $\\alpha > 0$，我们有 $P'_{ii} > 0$。一个具有正自转移概率（长度为1的返回路径）的状态必然是非周期的，因为返回路径长度集合的最大公约数必须为1。由于这对所有状态 $i$ 都成立，该链是**非周期的**。\n\n由于增强链既是不可约的又是非周期的，因此它是**遍历的**。只要对所有 $j$ 都有 $v_j > 0$，这个结论对任何 $\\alpha \\in (0,1)$ 都成立。针对本原矩阵（包括所有正矩阵的类别）的 Perron-Frobenius 定理保证了这样的链具有唯一的正平稳分布 $\\pi$，并且从任何初始分布开始，链的状态分布都会收敛到 $\\pi$。\n\n**逐项分析选项**\n\n**A. 该链不是遍历的，因为由于存在一个汇强连通分量而导致其是可约的，并且它包含一个引起周期性的 2-周期；在瞬移条件下，对于任何 $0  \\alpha  1$ 和任何满足对所有节点 $i$ 都有 $v_i > 0$ 的分布 $v$，修改后的转移矩阵具有严格为正的项，因此它是不可约和非周期的，因而是遍历的，具有唯一的平稳分布，并且从任何初始分布都会收敛。**\n该陈述正确地指出了原始链的双重失效：它是可约的（由于存在汇强连通分量）和周期的（由于环路结构）。它还正确地指出了瞬移恢复不可约性和非周期性的条件（对所有 $i$，$v_i > 0$）和机制（$P'$ 的所有项都变为正），从而导致遍历性和收敛到唯一的平稳分布。这与我们的推导完全吻合。\n**结论：正确。**\n\n**B. 该链已经是遍历的，因为它包含至少一个周期；瞬移是不必要的，并且对于任何 $0  \\alpha  1$ 都不影响收敛性。**\n该链是遍历的这一初始声明是错误的，如上所示。其理由“因为它包含至少一个环路”是有缺陷的；环路是不可约性的必要条件但非充分条件，并且可能是周期性的原因。\n**结论：不正确。**\n\n**C. 非遍历性仅在存在零出度节点时出现；添加瞬移，对于任何 $0  \\alpha  1$ 和任何分布 $v$——即使 $v$ 对某些节点分配了零概率——也总能保证遍历性。**\n陈述的第一部分是错误的。给定的网络没有零出度的节点，但链却是非遍历的。第二部分也是错误的。如果 $v$ 对某些节点分配零概率（例如，$v_1=0, v_2=0$），新链可能仍然是可约的，因为一个状态可能没有任何路径（直接的或通过瞬移）到达瞬移概率为零的节点。\n**结论：不正确。**\n\n**D. 瞬移可以修复可约性但不能修复周期性；汇分量中的 2-周期持续存在，因此对于所有 $0  \\alpha  1$，该链仍然是非遍历的。**\n该陈述错误地声称瞬移无法修复周期性。如前所示，如果 $v_i > 0$，则对所有 $i$ 都有 $P'_{ii} > 0$。每个节点上存在长度为1的自环确保了所有状态都变为非周期的。虽然图的2-周期结构仍然存在，但概率动态被改变，从而打破了严格的周期性。\n**结论：不正确。**\n\n**E. 在瞬移下实现遍历性需要设置 $\\alpha=1$；对于 $0  \\alpha  1$，无论 $v$ 的选择如何，该链仍然是非遍历的。**\n该陈述是错误的。设置 $\\alpha=1$ 是一个充分但非必要条件。我们的分析表明，对于任何 $\\alpha \\in (0,1)$ 和一个正向量 $v$，链都会变得遍历。因此，声称它仍然是非遍历的是错误的。\n**结论：不正确。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在理解了随机游走和遍历性的理论基础后，我们现在可以着手实现一个强大的网络节点排序算法——个性化PageRank。该算法不仅能识别网络中通常意义下最具影响力的基因或蛋白质，还能根据特定的生物过程或上下文进行针对性排序。这项练习要求你从第一性原理出发，实现PageRank算法，包括处理“悬挂节点”（dangling nodes）这一关键步骤，以确保底层的马尔可夫链是良定义的。你将通过幂迭代法找到该过程的稳态分布，从而将抽象的理论转化为一个功能强大的网络分析工具。",
            "id": "4349876",
            "problem": "实现一个程序，用于计算小型有向转录网络上的个性化PageRank，并严格处理悬挂节点。目标是从马尔可夫链和图随机性的第一性原理推导并实现该算法，而不是未经论证地引用一个现成的公式。具体而言，考虑一个代表转录调控网络的有向图，其中节点是基因或转录因子，有向边代表调控关系。设阻尼因子表示为 $\\alpha \\in (0,1)$，个性化向量表示为 $v \\in \\mathbb{R}^n$，其中 $v \\ge 0$ 且 $\\sum_{i=1}^n v_i = 1$。PageRank向量 $p \\in \\mathbb{R}^n$ 被定义为在该图上带瞬移的随机游走的稳态分布。\n\n使用的基本原理：\n- 使用离散时间马尔可夫链的定义，该链具有一个列随机转移矩阵，以及稳态分布 $p$ 满足 $p = M p$ 的概念，其中 $M$ 是一个合适的列随机矩阵，同时满足 $\\sum_{i=1}^n p_i = 1$ 和 $p \\ge 0$。\n- 使用经过充分检验的观察结果：在PageRank随机游走中，游走者有 $\\alpha$ 的概率从当前节点的所有出边中均匀随机选择一条进行移动，有 $(1-\\alpha)$ 的概率瞬移到根据个性化向量 $v$ 抽样的一个节点。\n- 使用以下事实：一个悬挂节点（出度为零的节点）在原始转移矩阵中会导致其对应列的和为零，必须通过根据 $v$ 重新分配其概率质量来处理，以使有效的转移仍然是列随机的。\n\n您的程序必须根据这些原理实现以下内容：\n- 从有向图构建一个列随机转移模型，其中对于每个至少有一条出边的节点，转移到其任何一个出邻居的概率相等且总和为 $1$。对于任何出度为零的节点（悬挂节点），确保其概率质量根据 $v$ 进行重新分配。\n- 对于给定的 $\\alpha$ 和 $v$，通过幂迭代计算唯一的PageRank向量 $p$，直到在 $\\ell_1$ 范数下收敛，容差为 $\\varepsilon = 10^{-12}$，并设置 $10000$ 次迭代的硬性上限。迭代的初始值设为 $p^{(0)} = v$。\n- 返回结果 $p$，其中每个条目四舍五入到六位小数。\n\n图表示：\n- 节点索引从 $0$ 到 $n-1$。有向边符号 $j \\to i$ 表示“从节点 $j$ 到节点 $i$”，这对应于列随机邻接矩阵中的一个条目，其中第 $j$ 列包含从节点 $j$ 出发的概率。\n- 一个包含节点 $\\{A,B,C,D,E\\}$ 的转录网络映射到索引 $A \\mapsto 0$, $B \\mapsto 1$, $C \\mapsto 2$, $D \\mapsto 3$, $E \\mapsto 4$。\n\n测试套件：\n- 测试用例 1：图 $G_1$，包含节点 $\\{0,1,2,3,4\\}$ 和边 $0 \\to 1$、$0 \\to 2$、$1 \\to 2$、$1 \\to 3$、$2 \\to 1$、$3 \\to 2$、$3 \\to 4$。节点 $4$ 是悬挂节点（没有出边）。使用 $\\alpha = 0.85$ 和均匀个性化向量 $v = \\left[\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5}\\right]$。\n- 测试用例 2：与测试用例 1 中相同的图 $G_1$，使用 $\\alpha = 0.95$ 和相同的均匀向量 $v$。\n- 测试用例 3：与测试用例 1 中相同的图 $G_1$，使用 $\\alpha = 0.85$ 和非均匀个性化向量 $v = [0.05, 0.05, 0.8, 0.05, 0.05]$。\n- 测试用例 4：图 $G_2$，包含节点 $\\{0,1,2\\}$ 且没有任何边，因此所有节点都是悬挂节点。使用 $\\alpha = 0.85$ 和均匀向量 $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$。\n- 测试用例 5：图 $G_3$，包含节点 $\\{0,1,2\\}$ 和一条边 $0 \\to 1$，节点 $1$ 和 $2$ 是悬挂节点。使用 $\\alpha = 0.85$ 和均匀向量 $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$。\n\n收敛性和数值规格：\n- 对 $\\ell_1$ 收敛准则使用 $\\varepsilon = 10^{-12}$。\n- 最多使用 $10000$ 次迭代。\n- 在输出前，将最终PageRank向量的每个条目四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含按顺序排列的测试用例结果，形式为逗号分隔的列表的列表，不含空格。例如，输出格式必须严格为：\n\"[[p_{11},p_{12},...,p_{1n}],[p_{21},p_{22},...],[...],...]\"\n其中 $p_{kj}$ 是测试用例 $k$ 的浮点数结果，四舍五入到六位小数。",
            "solution": "计算个性化PageRank向量的问题，是寻找一个特定离散时间马尔可夫链的稳态分布的问题。解决方案将从第一性原理出发推导，从构建随机游走的转移矩阵开始，最终形成幂迭代算法。\n\n### 1. 底层马尔可夫链\n\n在具有 $n = |V|$ 个节点的有向图 $G = (V, E)$ 上的随机游走可以建模为一个马尔可夫链。系统在第 $k$ 步的状态是一个概率分布向量 $p^{(k)} \\in \\mathbb{R}^n$，其中 $p_i^{(k)}$ 是随机游走者位于节点 $i$ 的概率。状态根据 $p^{(k+1)} = M p^{(k)}$ 演化，其中 $M$ 是一个列随机转移矩阵。条目 $M_{ij}$ 表示从节点 $j$ 转移到节点 $i$ 的概率。稳态分布 $p$ 满足 $p = M p$，同时满足约束条件 $p \\ge 0$ 和 $\\sum_{i=1}^n p_i = 1$。\n\n### 2. 构建PageRank转移模型\n\nPageRank随机游走者的移动是两种行为的加权组合：\n1.  以概率 $\\alpha$，游走者从其当前节点随机选择一条出边进行移动。\n2.  以概率 $1-\\alpha$，游走者“瞬移”到根据个性化向量 $v$ 随机选择的一个节点。\n\n我们必须构建一个能够捕捉这种行为的列随机矩阵 $M$。\n\n#### 2.1. 处理基于图的游走（`S` 矩阵）\n\n我们首先对纯粹遵循图结构的游走进行建模。\n- 对于一个非悬挂节点 $j$（出度 $d_j > 0$ 的节点），位于 $j$ 的游走者以均匀概率 $1/d_j$ 移动到其任何一个邻居 $i$。\n- 对于一个悬挂节点 $j$（出度 $d_j = 0$ 的节点），游走者被困住。问题规定，这部分概率质量必须根据个性化向量 $v$ 重新分配。这等同于一次强制瞬移：从悬挂节点 $j$ 出发，游走者以概率 $v_i$ 跳转到任意节点 $i$。\n\n我们来构建一个表示这种基于图的游走（包括悬挂节点修正）的矩阵 $S$。\n- 令 $A$ 为一个表示非悬挂节点转移的矩阵。\n$$\nA_{ij} = \\begin{cases} 1/d_j  \\text{如果 } j \\to i \\text{ 是一条边且 } d_j > 0 \\\\ 0  \\text{其他情况} \\end{cases}\n$$\n$A$ 中对应于非悬挂节点的列之和为 $1$，而对应于悬挂节点的列全为零。\n- 为了处理悬挂节点，我们增加一个修正项。令 $d \\in \\{0,1\\}^n$ 为一个指示向量，其中如果节点 $j$ 是悬挂的，则 $d_j=1$，否则 $d_j=0$。从悬挂节点 $j$ 的转移是跳转到节点 $i$ 的概率为 $v_i$。这可以由外积 $v d^T$ 表示。\n- 图游走的完整随机转移矩阵 $S$ 是这两部分之和：\n$$\nS = A + v d^T\n$$\n我们来验证 $S$ 是列随机的。第 $j$ 列的和为 $\\sum_i S_{ij}$。\n- 如果 $j$ 不是悬挂节点 ($d_j=0$): $\\sum_i S_{ij} = \\sum_i A_{ij} = \\sum_{i \\in \\text{neighbors}(j)} 1/d_j = d_j \\cdot (1/d_j) = 1$。\n- 如果 $j$ 是悬挂节点 ($d_j=1$): $\\sum_i S_{ij} = \\sum_i (A_{ij} + v_i d_j) = \\sum_i (0 + v_i) = \\sum_i v_i = 1$。\n因此，$S$ 是一个有效的列随机矩阵。\n\n#### 2.2. 引入瞬移（`M` 矩阵）\n\n每一步完整的PageRank转移是图游走（由 $S$ 控制）和全局瞬移（由 $v$ 控制）的组合。\n从任何节点 $j$ 转移到目标节点 $i$ 的概率是：\n$$\nP(j \\to i) = \\alpha \\cdot (\\text{通过图游走的概率}) + (1-\\alpha) \\cdot (\\text{通过瞬移的概率})\n$$\n通过图游走从 $j$ 转移到 $i$ 的概率由 $S_{ij}$ 给出。瞬移到节点 $i$ 的概率是 $v_i$，这与起始节点 $j$ 无关。\n因此，最终的谷歌矩阵 $M$ 的条目 $M_{ij}$ 是：\n$$\nM_{ij} = \\alpha S_{ij} + (1-\\alpha)v_i\n$$\n用矩阵表示法，即为 $M = \\alpha S + (1-\\alpha) v \\mathbf{1}^T$，其中 $\\mathbf{1}^T$ 是一个全为一的行向量。这个矩阵 $M$ 是列随机的，其唯一的（对应于特征值 $1$ 的）主特征向量就是PageRank向量 $p$。\n\n### 3. 幂迭代算法\n\nPageRank向量 $p$ 是满足 $p = M p$ 的稳态分布。这可以通过幂迭代法找到：从一个初始猜测 $p^{(0)}$ 开始，我们重复应用转移矩阵：$p^{(k+1)} = M p^{(k)}$。序列 $p^{(k)}$ 会收敛到 $p$。\n\n我们来推导迭代更新规则：\n$$\np^{(k+1)} = M p^{(k)} = (\\alpha S + (1-\\alpha) v \\mathbf{1}^T) p^{(k)}\n$$\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v (\\mathbf{1}^T p^{(k)})\n$$\n由于 $p^{(k)}$ 是一个概率分布，$\\sum_j p_j^{(k)} = 1$，这意味着 $\\mathbf{1}^T p^{(k)} = 1$。\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v\n$$\n这为我们提供了一个更直接的迭代更新。为了计算效率，我们可以进一步展开 $S$：\n$$\np^{(k+1)} = \\alpha (A + v d^T) p^{(k)} + (1-\\alpha) v\n$$\n$$\np^{(k+1)} = \\alpha A p^{(k)} + \\alpha v (d^T p^{(k)}) + (1-\\alpha) v\n$$\n令 $m_d^{(k)} = d^T p^{(k)} = \\sum_{j \\text{ is dangling}} p_j^{(k)}$ 为在第 $k$ 步时位于悬挂节点上的总概率质量。方程变为：\n$$\np^{(k+1)} = \\alpha (A p^{(k)}) + (\\alpha m_d^{(k)} + 1 - \\alpha) v\n$$\n这就是用于幂迭代的最终、计算高效的更新规则。\n\n**算法：**\n1.  **初始化**：设置初始PageRank向量 $p^{(0)} = v$，迭代计数器 $k=0$。\n2.  **预处理**：根据图的边，确定出度 $d_j$ 并识别悬挂节点集合 $D = \\{j \\mid d_j=0\\}$。构建非悬挂转移矩阵 $A$，或等价的表示。\n3.  **迭代**：对 $k=0, 1, 2, \\dots$ 重复，最多进行 $10000$ 次迭代：\n    a.  存储当前向量：$p_{\\text{old}} = p^{(k)}$。\n    b.  计算悬挂质量：$m_d = \\sum_{j \\in D} p_j^{\\text{old}}$。\n    c.  计算游走贡献：$p'_{\\text{walk}} = A p_{\\text{old}}$。这是通过对每个节点 $i$ 求和所有流入的概率流来完成的：$(p'_{\\text{walk}})_i = \\sum_{j \\to i, j \\notin D} p_j^{\\text{old}} / d_j$。\n    d.  计算新的PageRank向量：$p^{(k+1)} = \\alpha p'_{\\text{walk}} + (\\alpha m_d + 1 - \\alpha) v$。\n    e.  **检查收敛**：计算差值的 $\\ell_1$ 范数：$\\Delta = ||p^{(k+1)} - p_{\\text{old}}||_1 = \\sum_i |p_i^{(k+1)} - p_i^{\\text{old}}|$。如果 $\\Delta  \\varepsilon = 10^{-12}$，则终止迭代。\n4.  **结果**：最终向量 $p^{(k+1)}$ 是计算出的PageRank向量。将其条目四舍五入到六位小数。",
            "answer": "```python\nimport numpy as np\n\ndef compute_pagerank(edges, n, alpha, v, epsilon, max_iter):\n    \"\"\"\n    Computes the Personalized PageRank vector from first principles.\n\n    Args:\n        edges (list): A list of tuples (from_node, to_node) representing directed edges.\n        n (int): The total number of nodes in the graph.\n        alpha (float): The damping factor.\n        v (np.ndarray):The personalization vector.\n        epsilon (float): The convergence tolerance for the L1 norm.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The computed PageRank vector.\n    \"\"\"\n    # 1. Build adjacency list and find out-degrees.\n    adj = [[] for _ in range(n)]\n    out_degrees = np.zeros(n, dtype=int)\n    for j, i in edges:\n        # j - i means from node j to node i\n        adj[j].append(i)\n        out_degrees[j] += 1\n\n    # 2. Identify dangling nodes.\n    dangling_nodes_mask = (out_degrees == 0)\n\n    # 3. Construct the 'A' matrix for transitions from non-dangling nodes.\n    # For small graphs, a dense matrix is acceptable.\n    A = np.zeros((n, n))\n    non_dangling_indices = np.where(out_degrees  0)[0]\n    for j in non_dangling_indices:\n        for i in adj[j]:\n            A[i, j] = 1.0 / out_degrees[j]\n\n    # 4. Power Iteration.\n    p = v.copy()  # Initialize p^(0) = v\n\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # Calculate the total probability mass on dangling nodes.\n        dangling_mass = np.sum(p_old[dangling_nodes_mask])\n\n        # Calculate the contribution from the random walk on non-dangling nodes.\n        # This is the A*p_old part of the update rule.\n        p_walk_contribution = np.dot(A, p_old)\n\n        # The teleportation component combines the mass from dangling nodes\n        # and the (1-alpha) global teleportation probability.\n        teleport_factor = alpha * dangling_mass + (1.0 - alpha)\n        teleport_contribution = teleport_factor * v\n\n        # Combine walk and teleportation to get the new PageRank vector.\n        p = alpha * p_walk_contribution + teleport_contribution\n\n        # Check for convergence using the L1 norm.\n        l1_norm_diff = np.linalg.norm(p - p_old, ord=1)\n        if l1_norm_diff  epsilon:\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the Personalized PageRank computation.\n    \"\"\"\n    # Test case definitions\n    # Graph 1\n    n1 = 5\n    edges1 = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 1), (3, 2), (3, 4)]\n    v1_uniform = np.full(n1, 1.0 / n1)\n    v1_nonuniform = np.array([0.05, 0.05, 0.8, 0.05, 0.05])\n\n    # Graph 2\n    n2 = 3\n    edges2 = []\n    v2_uniform = np.full(n2, 1.0 / n2)\n\n    # Graph 3\n    n3 = 3\n    edges3 = [(0, 1)]\n    v3_uniform = np.full(n3, 1.0 / n3)\n\n    test_cases = [\n        # (graph_edges, num_nodes, alpha, personalization_vector)\n        (edges1, n1, 0.85, v1_uniform),\n        (edges1, n1, 0.95, v1_uniform),\n        (edges1, n1, 0.85, v1_nonuniform),\n        (edges2, n2, 0.85, v2_uniform),\n        (edges3, n3, 0.85, v3_uniform),\n    ]\n\n    epsilon = 1e-12\n    max_iter = 10000\n    results = []\n\n    for edges, n, alpha, v in test_cases:\n        p_vector = compute_pagerank(edges, n, alpha, v, epsilon, max_iter)\n        # Round each element to 6 decimal places as required.\n        rounded_p = [round(val, 6) for val in p_vector]\n        results.append(rounded_p)\n\n    # Format the final output string to be a comma-separated list of lists\n    # with no spaces, e.g., \"[[p1,p2],[q1,q2]]\".\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}