{
    "hands_on_practices": [
        {
            "introduction": "深入理解一个概率分布，意味着要超越其概率密度函数。矩生成函数（Moment Generating Function, MGF）是一个强大的数学工具，如同分布的“指纹”，它不仅能唯一确定一个分布，还能让我们轻松计算出其所有阶的矩。本练习将引导你从第一性原理出发，推导作为统计理论基石的正态分布的矩生成函数，并展示如何利用它来计算如方差和峰度等关键特性。",
            "id": "4387180",
            "problem": "在一个系统生物医学分析中，一个经过校准的定量生物标志物读数的残余测量误差可以很好地由一个均值为 $\\mu$、方差为 $\\sigma^{2}$ 的正态随机变量 $X$ 来建模。$X$ 的概率密度函数由下式给出\n$$\nf_{X}(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right).\n$$\n从矩生成函数 (MGF) 的定义出发，\n$$\nM_{X}(t)=\\mathbb{E}\\!\\left[\\exp(tX)\\right]=\\int_{-\\infty}^{\\infty}\\exp(tx)\\,f_{X}(x)\\,dx,\n$$\n推导出一个对所有实数 $t$ 均有效的 $M_{X}(t)$ 的闭式表达式。然后，仅使用第一性原理（上述定义和证明积分号下微分合理性的标准定理），证明如何通过对 $M_{X}(t)$ 在 $t=0$ 处进行重复微分来得到对任意非负整数 $n$ 的原始矩 $\\mathbb{E}[X^{n}]$。最后，将此框架应用于中心化变量 $Y=X-\\mu$，并通过对相应的 MGF 进行微分，显式地计算四阶中心矩 $\\mathbb{E}\\!\\left[(X-\\mu)^{4}\\right]$。\n\n请以 $\\sigma$ 的单个闭式解析表达式形式提供最终答案。不要四舍五入。",
            "solution": "该问题是有效的，因为它是概率论和统计学中一个标准的、适定的问题，其基础是正确的数学和科学原理。我们将按要求分三部分进行推导。\n\n第一部分：正态随机变量的矩生成函数 (MGF) 的推导\n\n问题定义了一个均值为 $\\mu$、方差为 $\\sigma^2$ 的正态随机变量 $X$，其概率密度函数 (PDF) 为：\n$$\nf_{X}(x)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right)\n$$\n矩生成函数 (MGF) $M_X(t)$ 定义为 $\\exp(tX)$ 的期望值：\n$$\nM_{X}(t) = \\mathbb{E}[\\exp(tX)] = \\int_{-\\infty}^{\\infty} \\exp(tx) f_{X}(x) dx\n$$\n将正态分布的 PDF 代入此定义，我们得到：\n$$\nM_{X}(t) = \\int_{-\\infty}^{\\infty} \\exp(tx) \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left(-\\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx\n$$\n我们可以合并指数函数的参数：\n$$\nM_{X}(t) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\exp\\left(tx - \\frac{(x-\\mu)^{2}}{2\\sigma^{2}}\\right) dx\n$$\n为了求解这个积分，我们对指数部分进行配方。我们关注指数的参数：\n$$\ntx - \\frac{(x-\\mu)^{2}}{2\\sigma^{2}} = tx - \\frac{x^2 - 2\\mu x + \\mu^2}{2\\sigma^2} = \\frac{2\\sigma^2 tx - (x^2 - 2\\mu x + \\mu^2)}{2\\sigma^2}\n$$\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2\\mu x - 2\\sigma^2 tx + \\mu^2 \\right] = -\\frac{1}{2\\sigma^2} \\left[ x^2 - 2(\\mu + \\sigma^2 t)x + \\mu^2 \\right]\n$$\n现在，我们对包含 $x$ 的项进行配方。我们加上并减去 $(\\mu + \\sigma^2 t)^2$：\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ \\left(x^2 - 2(\\mu + \\sigma^2 t)x + (\\mu + \\sigma^2 t)^2\\right) - (\\mu + \\sigma^2 t)^2 + \\mu^2 \\right]\n$$\n$$\n= -\\frac{1}{2\\sigma^2} \\left[ (x - (\\mu + \\sigma^2 t))^2 - (\\mu^2 + 2\\mu\\sigma^2 t + \\sigma^4 t^2) + \\mu^2 \\right]\n$$\n$$\n= -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\frac{2\\mu\\sigma^2 t + \\sigma^4 t^2}{2\\sigma^2} = -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\mu t + \\frac{1}{2}\\sigma^2 t^2\n$$\n将此结果代回 $M_X(t)$ 的积分中：\n$$\nM_{X}(t) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\exp\\left( -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} + \\mu t + \\frac{1}{2}\\sigma^2 t^2 \\right) dx\n$$\n项 $\\exp(\\mu t + \\frac{1}{2}\\sigma^2 t^2)$ 不依赖于 $x$，可以从积分中提出：\n$$\nM_{X}(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) \\int_{-\\infty}^{\\infty} \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left( -\\frac{(x - (\\mu + \\sigma^2 t))^2}{2\\sigma^2} \\right) dx\n$$\n剩下的积分是一个均值为 $\\mu' = \\mu + \\sigma^2 t$、方差为 $\\sigma^2$ 的正态 PDF 在其整个定义域 $(-\\infty, \\infty)$ 上的积分。任何 PDF 下的总面积都等于 1。因此，该积分的值为 1。\n这样我们就得到了正态分布 MGF 的闭式表达式：\n$$\nM_{X}(t) = \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n该表达式对所有实数值 $t$ 均有效。\n\n第二部分：通过微分生成矩的合理性证明\n\n$X$ 的 $n$ 阶原始矩定义为 $\\mathbb{E}[X^n]$。我们需要说明这如何与 $M_X(t)$ 在 $t=0$ 处的导数相关联。让我们对 $M_X(t)$ 关于 $t$ 求导：\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\frac{d^n}{dt^n} \\int_{-\\infty}^{\\infty} \\exp(tx) f_X(x) dx\n$$\n在某些正则性条件下，我们可以交换微分和积分的顺序（这一结果可由诸如莱布尼茨积分法则或控制收敛定理等定理来正式证明）。对于正态分布，被积函数关于 $t$ 的偏导数存在且连续。此外，对于 $0$ 附近的任意紧区间中的 $t$，导数的绝对值的积分是有界的，因为当 $|x| \\to \\infty$ 时，$f_X(x)$ 的指数衰减速度超过了微分带来的任何多项式增长。这证明了交换顺序的合理性。\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\int_{-\\infty}^{\\infty} \\frac{\\partial^n}{\\partial t^n} [\\exp(tx)] f_X(x) dx\n$$\n$\\exp(tx)$ 关于 $t$ 的 $n$ 阶偏导数是 $x^n \\exp(tx)$。\n$$\n\\frac{d^n}{dt^n} M_X(t) = \\int_{-\\infty}^{\\infty} x^n \\exp(tx) f_X(x) dx = \\mathbb{E}[X^n \\exp(tX)]\n$$\n为了求得 $n$ 阶原始矩，我们将此表达式在 $t=0$ 处求值：\n$$\n\\left. \\frac{d^n}{dt^n} M_X(t) \\right|_{t=0} = \\mathbb{E}[X^n \\exp(0 \\cdot X)] = \\mathbb{E}[X^n \\cdot 1] = \\mathbb{E}[X^n]\n$$\n这表明 $n$ 阶原始矩 $\\mathbb{E}[X^n]$ 可以通过求 MGF $M_X(t)$ 的 $n$ 阶导数并在 $t=0$ 处求值得到。\n\n第三部分：四阶中心矩的计算\n\n四阶中心矩是 $\\mathbb{E}[(X-\\mu)^4]$。我们定义一个中心化的随机变量 $Y = X-\\mu$。$Y$ 的矩就是 $X$ 的中心矩。我们需要找到 $Y$ 的 MGF，记为 $M_Y(t)$。\n$$\nM_Y(t) = \\mathbb{E}[\\exp(tY)] = \\mathbb{E}[\\exp(t(X-\\mu))] = \\mathbb{E}[\\exp(tX)\\exp(-t\\mu)]\n$$\n由于 $\\exp(-t\\mu)$ 相对于随机变量 $X$ 是一个常数，我们可以将其从期望中提出：\n$$\nM_Y(t) = \\exp(-t\\mu) \\mathbb{E}[\\exp(tX)] = \\exp(-t\\mu) M_X(t)\n$$\n代入我们在第一部分中推导出的 $M_X(t)$ 的表达式：\n$$\nM_Y(t) = \\exp(-t\\mu) \\exp\\left(\\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) = \\exp\\left(-t\\mu + \\mu t + \\frac{1}{2}\\sigma^2 t^2\\right) = \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n注意，$Y$ 是一个均值为 $\\mathbb{E}[Y] = \\mathbb{E}[X-\\mu] = \\mu-\\mu=0$、方差为 $\\mathrm{Var}(Y) = \\mathrm{Var}(X) = \\sigma^2$ 的正态随机变量。我们为 $Y$ 找到的 MGF 与均值为 $0$、方差为 $\\sigma^2$ 的正态分布的一般公式是一致的。\n\n为了求得四阶中心矩 $\\mathbb{E}[Y^4]$，我们必须计算 $M_Y(t)$ 的四阶导数，并在 $t=0$ 处求值。\n$$\nM_Y(t) = \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n一阶导数：\n$$\nM_Y'(t) = \\frac{d}{dt}\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n二阶导数（使用乘法法则）：\n$$\nM_Y''(t) = \\sigma^2 \\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (\\sigma^2 t)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (\\sigma^2 + \\sigma^4 t^2)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n三阶导数：\n$$\nM_Y'''(t) = (2\\sigma^4 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (\\sigma^2 + \\sigma^4 t^2)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (2\\sigma^4 t + \\sigma^4 t + \\sigma^6 t^3)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) = (3\\sigma^4 t + \\sigma^6 t^3)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n四阶导数：\n$$\nM_Y^{(4)}(t) = (3\\sigma^4 + 3\\sigma^6 t^2)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right) + (3\\sigma^4 t + \\sigma^6 t^3)(\\sigma^2 t)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (3\\sigma^4 + 3\\sigma^6 t^2 + 3\\sigma^6 t^2 + \\sigma^8 t^4)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n$$\n= (3\\sigma^4 + 6\\sigma^6 t^2 + \\sigma^8 t^4)\\exp\\left(\\frac{1}{2}\\sigma^2 t^2\\right)\n$$\n最后，我们在 $t=0$ 处计算四阶导数的值，以获得四阶中心矩：\n$$\n\\mathbb{E}[(X-\\mu)^4] = \\mathbb{E}[Y^4] = M_Y^{(4)}(0) = (3\\sigma^4 + 6\\sigma^6(0)^2 + \\sigma^8(0)^4)\\exp(0) = 3\\sigma^4\n$$\n四阶中心矩是 $3\\sigma^4$。",
            "answer": "$$\n\\boxed{3\\sigma^{4}}\n$$"
        },
        {
            "introduction": "尽管像$t$检验这样的参数检验方法很强大，但它们依赖于可能不成立的特定分布假设。Delta方法利用微积分为此提供了一个强大而简洁的解决方案。本练习将引导你推导这个核心的渐近工具，并将其应用于对数变换后的样本均值，这在分析具有乘性噪声或偏态分布的生物数据时非常常见。",
            "id": "4387137",
            "problem": "在一项关于分泌性细胞因子浓度的系统生物医学研究中，假设 $X_{1}, X_{2}, \\ldots, X_{n}$ 是来自 $n$ 个不同细胞培养物的独立同分布的浓度测量值，建模为 $X_{i} \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，其中 $\\mu > 0$ 以反映浓度严格为正。研究人员通常报告对数转换后的摘要，以使乘性变异性线性化并稳定方差。考虑估计量 $\\hat{\\theta} = g(\\bar{X})$，其中 $g$ 是在 $\\mu$ 的一个邻域内的一阶连续可微函数，$\\bar{X} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}$。\n\n仅从样本均值的定义、其在独立性下的方差以及中心极限定理（CLT）出发，通过在 $\\mu$ 周围使用一阶展开对 $g$ 进行线性化，推导出一个对于大 $n$ 有效的 $\\operatorname{Var}(\\hat{\\theta})$ 的渐近近似。然后将您的推导特化到 $g(x) = \\ln(x)$ 的情况，并提供大 $n$ 近似下 $\\operatorname{Var}(\\ln(\\bar{X}))$ 的最终闭式解析表达式，用 $\\mu$、$\\sigma^{2}$ 和 $n$ 表示。\n\n将最终答案表示为单一的解析表达式。不要四舍五入。",
            "solution": "用户想要找到样本均值函数方差 $\\operatorname{Var}(g(\\bar{X}))$ 的一个渐近近似，然后将此结果特化到自然对数函数。推导必须从问题陈述中概述的第一性原理开始。\n\n该问题被认为是有效的。\n- 它在科学上基于标准统计理论（中心极限定理，Delta方法）。\n- 它是良定的，提供了所有必要信息。\n- 语言客观而精确。\n\n我们按要求开始推导。\n\n设 $X_{1}, X_{2}, \\ldots, X_{n}$ 是来自一个均值为 $\\mathbb{E}[X_{i}] = \\mu$ 且方差为 $\\operatorname{Var}(X_{i}) = \\sigma^{2}$ 的分布的独立同分布（i.i.d.）随机变量。问题指定了正态分布 $X_{i} \\sim \\mathcal{N}(\\mu, \\sigma^{2})$，但此推导在更一般的情况下也成立。样本均值定义为 $\\bar{X} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}$。\n\n样本均值的方差 $\\operatorname{Var}(\\bar{X})$ 使用方差的性质推导得出。由于 $X_{i}$ 是独立的：\n$$\n\\operatorname{Var}(\\bar{X}) = \\operatorname{Var}\\left(\\frac{1}{n}\\sum_{i=1}^{n} X_{i}\\right) = \\frac{1}{n^{2}} \\operatorname{Var}\\left(\\sum_{i=1}^{n} X_{i}\\right)\n$$\n由于独立性，和的方差等于方差的和：\n$$\n\\operatorname{Var}\\left(\\sum_{i=1}^{n} X_{i}\\right) = \\sum_{i=1}^{n} \\operatorname{Var}(X_{i}) = \\sum_{i=1}^{n} \\sigma^{2} = n\\sigma^{2}\n$$\n将此代回，我们得到样本均值的方差：\n$$\n\\operatorname{Var}(\\bar{X}) = \\frac{1}{n^{2}}(n\\sigma^{2}) = \\frac{\\sigma^{2}}{n}\n$$\n问题指定 $n$ 很大。中心极限定理（CLT）指出，当 $n \\to \\infty$ 时，样本均值 $\\bar{X}$ 的分布趋近于正态分布。更正式地说，$\\sqrt{n}(\\bar{X} - \\mu)$ 在分布上收敛于 $\\mathcal{N}(0, \\sigma^{2})$。这意味着对于大 $n$，$\\bar{X}$ 集中在其均值 $\\mu$ 的一个小邻域内。这种集中性为在点 $\\mu$ 周围对函数 $g$ 使用线性近似提供了理由。\n\n我们感兴趣的是估计量 $\\hat{\\theta} = g(\\bar{X})$，其中 $g$ 是一个一阶连续可微函数。我们在点 $\\mu$ 周围对 $g(\\bar{X})$ 进行一阶泰勒展开：\n$$\ng(\\bar{X}) \\approx g(\\mu) + g'(\\mu)(\\bar{X} - \\mu)\n$$\n这是一个我们忽略了高阶项的近似，这在 $n$ 很大时是有效的，因为 $\\bar{X}$ 接近于 $\\mu$。现在我们计算这个线性近似的方差：\n$$\n\\operatorname{Var}(\\hat{\\theta}) = \\operatorname{Var}(g(\\bar{X})) \\approx \\operatorname{Var}(g(\\mu) + g'(\\mu)(\\bar{X} - \\mu))\n$$\n利用对于任意随机变量 $Y$ 和常数 $a, b$，我们有 $\\operatorname{Var}(aY + b) = a^{2}\\operatorname{Var}(Y)$ 的性质。这里，$g(\\mu)$ 和 $g'(\\mu)$ 是常数，$\\mu$ 也是。令 $Y = \\bar{X}$，$a = g'(\\mu)$，常数项为 $g(\\mu) - g'(\\mu)\\mu$。表达式简化为：\n$$\n\\operatorname{Var}(g(\\bar{X})) \\approx \\operatorname{Var}(g'(\\mu)\\bar{X}) = (g'(\\mu))^{2} \\operatorname{Var}(\\bar{X})\n$$\n代入先前推导出的 $\\operatorname{Var}(\\bar{X}) = \\frac{\\sigma^{2}}{n}$ 表达式，我们得到 $\\hat{\\theta}$ 方差的一般渐近近似：\n$$\n\\operatorname{Var}(g(\\bar{X})) \\approx (g'(\\mu))^{2} \\frac{\\sigma^{2}}{n}\n$$\n这个结果通常被称为Delta方法。\n\n接下来，我们将此推导特化到函数为自然对数 $g(x) = \\ln(x)$ 的情况。问题陈述 $\\mu > 0$，这确保了 $\\ln(\\mu)$ 是良定义的。对于大 $n$，$\\bar{X}$ 将接近 $\\mu$，因此 $\\bar{X}$ 也将以高概率为正，从而 $\\ln(\\bar{X})$ 将是良定义的。\n\n首先，我们求 $g(x)$ 的导数：\n$$\ng'(x) = \\frac{d}{dx}(\\ln(x)) = \\frac{1}{x}\n$$\n接下来，我们在点 $x=\\mu$ 处计算这个导数：\n$$\ng'(\\mu) = \\frac{1}{\\mu}\n$$\n现在，我们将这个具体的导数代入我们的一般方差近似公式：\n$$\n\\operatorname{Var}(\\ln(\\bar{X})) \\approx \\left(\\frac{1}{\\mu}\\right)^{2} \\operatorname{Var}(\\bar{X}) = \\frac{1}{\\mu^{2}} \\frac{\\sigma^{2}}{n}\n$$\n这就给出了大 $n$ 近似下 $\\operatorname{Var}(\\ln(\\bar{X}))$ 的最终闭式解析表达式：\n$$\n\\operatorname{Var}(\\ln(\\bar{X})) \\approx \\frac{\\sigma^{2}}{n\\mu^{2}}\n$$",
            "answer": "$$\n\\boxed{\\frac{\\sigma^{2}}{n\\mu^{2}}}\n$$"
        },
        {
            "introduction": "尽管像$t$检验这样的参数检验方法很强大，但它们依赖于可能不成立的特定分布假设。置换检验（Permutation test）基于可交换性原理，直接从观测数据中构建零分布，提供了一种稳健且无需分布假设的替代方案。这个动手编程练习要求你从零开始实现一个精确置换检验，将抽象的统计理论转化为具体的代码。通过这项实践，你将深化对假设检验基本逻辑以及计算统计学力量的理解。",
            "id": "4387115",
            "problem": "考虑一个源于系统生物医学的双样本比较问题，其科学问题是两种生物学条件（例如，对照组与处理组）是否产生不同的平均分子测量值（例如，对数转换后的单细胞蛋白质丰度）。您的任务是在条件标签可交换性的假设下，开发一个针对均值差异的严格置换检验，并对于小样本，通过枚举所有与观测样本量一致的标签分配来推导精确的零分布。\n\n请基于以下原则进行推导：\n- 零假设下的可交换性：在零假设（即两种条件下的测量值分布相同）下，观测到的标签不提供信息，任何保持原始组大小的标签重分配都是等可能的。\n- 假设检验的随机化原则：检验统计量的参考零分布是通过在实验设计允许的所有标签分配下评估该统计量而构建的，并在零假设下将这些分配视为等可能。\n- 将均值差异定义为检验统计量：对于合并观测值，该统计量是分配给 $A$ 组的测量值平均值与分配给 $B$ 组的测量值平均值之差。\n\n形式上，假设您观测到 $A$ 组有 $n_A$ 个测量值，$B$ 组有 $n_B$ 个测量值，合并数据为 $x_1, x_2, \\dots, x_N$，其中 $N = n_A + n_B$。在零假设和标签可交换性下，所有将合并观测值中的 $n_A$ 个精确分配给 $A$ 组、 $n_B$ 个分配给 $B$ 组的标签分配都是等可能的。将检验统计量 $T$ 定义为均值差异 $T = \\bar{X}_A - \\bar{X}_B$。对于小样本，精确零分布是通过枚举所有标签分配得到的所有 $T$ 值的多重集，并赋予这些标签分配均匀概率。双边 $p$ 值是在此零分布下，观测到绝对值至少与原始标签得到的观测统计量一样大的统计量的概率。\n\n您的程序必须：\n- 从提供的带标签数据中计算观测到的均值差异 $T_{\\text{obs}}$。\n- 枚举所有允许的标签分配（即保持原始组大小的分配），并通过计算每个唯一 $T$ 值的频率再除以总标签分配数，来计算 $T$ 的精确零分布。\n- 计算精确的双边 $p$ 值，即 $|T| \\geq |T_{\\text{obs}}|$ 的总零概率，以小数形式表示。\n- 对于每个测试用例，输出一个包含三个部分的列表：双边 $p$ 值、精确零分布的排序后唯一支撑点列表，以及与此支撑对齐的相应概率列表。所有浮点输出必须四舍五入到六位小数，并以小数形式表示（而非分数或百分号）。\n\n将此实现为一个完整的、可运行的程序，为以下测试套件生成结果：\n- 测试用例 $1$（平衡，中等差异）：$A$ 组测量值 $[1.24, 1.37, 1.51, 1.63]$，$B$ 组测量值 $[1.10, 1.21, 1.28, 1.30]$。\n- 测试用例 $2$（边界，最小非平凡样本）：$A$ 组测量值 $[2.80]$，$B$ 组测量值 $[2.10]$。\n- 测试用例 $3$（组大小不等）：$A$ 组测量值 $[0.95, 1.02, 1.08]$，$B$ 组测量值 $[0.89, 0.92, 1.00, 1.05, 1.10]$。\n- 测试用例 $4$（平衡且有重复值）：$A$ 组测量值 $[3.20, 3.20, 3.40]$，$B$ 组测量值 $[3.10, 3.20, 3.30]$。\n- 测试用例 $5$（退化的相等值）：$A$ 组测量值 $[1.50, 1.50]$，$B$ 组测量值 $[1.50, 1.50]$。\n\n您的程序应生成单行输出，其中包含所有五个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[p,\\;S,\\;P]$ 形式的列表，其中 $p$ 是双边 $p$ 值，$S$ 是精确零分布的排序后唯一支撑点列表，$P$ 是与 $S$ 对齐的概率列表。例如，您的输出必须具有 $[[p_1,S_1,P_1],[p_2,S_2,P_2],[p_3,S_3,P_3],[p_4,S_4,P_4],[p_5,S_5,P_5]]$ 的形状，所有浮点数四舍五入到六位小数并以小数表示。\n\n不涉及物理单位或角度单位。所有概率和 $p$ 值必须是小数（而非分数或百分比）。",
            "solution": "### 问题验证\n\n#### 步骤 1：提取给定信息\n\n问题提供了以下数据、定义和约束：\n\n*   **主题**：系统生物医学中的双样本比较问题。\n*   **目标**：开发一个针对均值差异的严格置换检验。\n*   **假设**：零假设下条件标签的可交换性。\n*   **核心原则**：\n    1.  **可交换性**：在两种条件具有相同分布的零假设下，任何保留组大小的标签重分配都是等可能的。\n    2.  **随机化原则**：检验统计量的零分布是通过在所有允许的、等可能的标签分配下对其进行评估来构建的。\n*   **形式化设置**：\n    *   $A$ 组有 $n_A$ 个测量值。\n    *   $B$ 组有 $n_B$ 个测量值。\n    *   合并数据：$x_1, x_2, \\dots, x_N$，其中 $N = n_A + n_B$。\n    *   检验统计量：$T = \\bar{X}_A - \\bar{X}_B$。\n    *   零分布：通过枚举所有 $\\binom{N}{n_A}$ 种标签分配得到的所有 $T$ 值的多重集，具有均匀概率。\n*   **要求计算**：\n    1.  观测到的均值差异 $T_{\\text{obs}}$。\n    2.  $T$ 的精确零分布（支撑点及其概率）。\n    3.  精确的双边 $p$ 值：$P(|T| \\geq |T_{\\text{obs}}|)$。\n*   **输出格式**：对于每个测试用例，一个列表 $[p, S, P]$，其中 $p$ 是 $p$ 值，$S$ 是零分布的排序后唯一支撑点列表，$P$ 是对应的概率列表。所有浮点数必须四舍五入到六位小数。所有测试用例的最终输出必须是单行：这些结果列表的列表。\n*   **测试用例**：\n    1.  A组: $[1.24, 1.37, 1.51, 1.63]$, B组: $[1.10, 1.21, 1.28, 1.30]$。\n    2.  A组: $[2.80]$, B组: $[2.10]$。\n    3.  A组: $[0.95, 1.02, 1.08]$, B组: $[0.89, 0.92, 1.00, 1.05, 1.10]$。\n    4.  A组: $[3.20, 3.20, 3.40]$, B组: $[3.10, 3.20, 3.30]$。\n    5.  A组: $[1.50, 1.50]$, B组: $[1.50, 1.50]$。\n\n#### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准对问题陈述进行评估：\n\n1.  **有科学依据**：问题在根本上是合理的。基于随机化原则和可交换性的置换检验是非参数统计的基石，由 R.A. Fisher 建立。它是一种标准、有效且强大的假设检验方法，尤其适用于渐近近似可能失效的小样本情况。检验统计量——均值差异，是比较集中趋势的常用且恰当的选择。系统生物医学的背景是合适的。\n2.  **定义明确**：问题是定义明确的。它提供了所有必要信息：数据集、检验统计量的精确定义、构建零分布的方法（完全枚举），以及 $p$ 值的定义。样本量足够小，使得对所有标签分配进行完全枚举在计算上是可行的。所要求的输出有明确的定义。\n3.  **客观性**：语言完全是客观、数学化的，不含主观或基于观点的陈述。\n4.  **完整性和一致性**：设置是完整的且内部一致。没有缺失数据或矛盾的约束。指定的测试用例涵盖了一系列场景（平衡、不平衡、重复值、退化情况），可以对所实现的算法进行彻底验证。\n5.  **现实性和可行性**：测量的数值对于生物数据（例如，对数转换后的丰度）是现实的。对于给定的小样本量，枚举所有排列的任务在计算上是可行的。例如，最大的案例是测试用例3，其中 $n_A=3, n_B=5$，导致 $N=8$。排列的数量为 $\\binom{8}{3} = 56$，这对于计算机来说是微不足道的。\n6.  **无其他缺陷**：问题并非微不足道（它需要不明显的实现细节）、非隐喻性、也非同义反复。退化情况（测试用例5）为算法的稳健性提供了有意义的检验。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效的**。它具有科学合理性、定义明确，并基于已建立的统计原则提供了一个清晰、可计算的任务。我现在将着手解决问题。\n\n### 解法\n\n任务是实现一个精确的置换检验，用于检验两个样本（$A$ 组和 $B$ 组）之间的均值差异。该解法的核心在于随机化原则，该原则假定在零假设（$H_0$）（即组间无差异）下，标签'A'和'B'是任意的。因此，将合并数据划分为保持原始大小 $n_A$ 和 $n_B$ 的新组的任何一种方式都是等可能的。\n\n设观测数据为 $X_A = \\{x_{A,1}, \\dots, x_{A,n_A}\\}$ 和 $X_B = \\{x_{B,1}, \\dots, x_{B,n_B}\\}$。总观测数为 $N = n_A + n_B$。合并数据集为 $X_{pool} = X_A \\cup X_B$。\n\n**1. 观测检验统计量**\n\n检验统计量是样本均值之差，$T = \\bar{X}_A - \\bar{X}_B$。我们首先为原始的、观测到的标签计算这个值。该值表示为 $T_{\\text{obs}}$。\n$$\nT_{\\text{obs}} = \\frac{1}{n_A} \\sum_{i=1}^{n_A} x_{A,i} - \\frac{1}{n_B} \\sum_{j=1}^{n_B} x_{B,j}\n$$\n\n**2. 构建精确零分布**\n\n在 $H_0$ 下，将 'A' 的 $n_A$ 个标签和 'B' 的 $n_B$ 个标签分配给 $X_{pool}$ 中 $N$ 个观测值的所有可能方式都是等概率的。此类唯一分配（或标签排列）的总数由二项式系数给出：\n$$\nC_{total} = \\binom{N}{n_A} = \\frac{N!}{n_A! (N-n_A)!} = \\frac{N!}{n_A! n_B!}\n$$\n该算法通过枚举从合并数据 $X_{pool}$ 中形成大小为 $n_A$ 的新组 $A'$ 的每一种可能方式来进行。剩下的 $n_B$ 个元素自动形成互补的 $B'$ 组。对于每个这样的排列 $k = 1, \\dots, C_{total}$，我们计算检验统计量 $T_k'$：\n$$\nT_k' = \\bar{X}_{A',k} - \\bar{X}_{B',k}\n$$\n这些 $C_{total}$ 个值的集合 $\\{T_1', T_2', \\dots, T_{C_{total}}'\\}$ 构成了检验统计量 $T$ 的精确零分布。\n\n计算说明：设 $S_{pool} = \\sum_{i=1}^{N} x_i$ 为所有合并观测值的总和。对于任何排列，如果 $A'$ 组中元素的和为 $S_{A'}$，那么 $B'$ 组的和为 $S_{B'} = S_{pool} - S_{A'}$。统计量 $T'$ 可以写成：\n$$\nT' = \\frac{S_{A'}}{n_A} - \\frac{S_{pool} - S_{A'}}{n_B} = S_{A'} \\left( \\frac{1}{n_A} + \\frac{1}{n_B} \\right) - \\frac{S_{pool}}{n_B}\n$$\n这表明 $T'$ 是 $S_{A'}$ 的单调线性函数。该分布可以通过首先找到所有含 $n_A$ 个元素的子集的和的分布，然后将这些和转换为相应的均值差异值来推导。在实现中，直接计算均值对于给定的约束条件来说清晰且足够高效。\n\n**3. 计算支撑和概率**\n\n处理 $T'$ 值的多重集以找到零分布的支撑 $S$，即唯一值集合 $\\{t_1, t_2, \\dots, t_m\\}$。我们将这些值按升序排序。对于每个唯一值 $t_j \\in S$，我们在所有 $T'$ 值的多重集中找到其频率 $f_j$。在零假设下观测到 $t_j$ 的概率是：\n$$\nP(T = t_j) = \\frac{f_j}{C_{total}}\n$$\n这就得到了与排序后的支撑 $S$ 对齐的概率列表 $P = \\{P(T=t_1), \\dots, P(T=t_m)\\}$。\n\n**4. 双边 $p$ 值计算**\n\n双边 $p$ 值是在零分布下，获得一个至少与观测到的统计量一样极端的检验统计量的概率。“一样极端”是通过绝对值来衡量的。$p$ 值的计算公式为：\n$$\np = P(|T| \\ge |T_{\\text{obs}}|) = \\frac{\\text{Number of permutations } k \\text{ where } |T_k'| \\ge |T_{\\text{obs}}|}{C_{total}}\n$$\n由于潜在的浮点数不精确性，比较 $|T_k'| \\ge |T_{\\text{obs}}|$ 时应谨慎实现，例如，通过比较到一个很高的精度，如对于一个小的 $\\epsilon>0$ 比较 $|T_k'| - |T_{\\text{obs}}| \\ge -\\epsilon$。鉴于这些值源于有理数运算，在一个安全的十进制位数（例如12位）上四舍五入后直接比较是一种稳健的策略。\n\n将要实现的算法将对每个提供的测试用例执行这些步骤。在 Python 中使用 `itertools.combinations` 是枚举合并数据分区的理想方法。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\nimport math\n\ndef run_permutation_test(data_a, data_b):\n    \"\"\"\n    Performs an exact two-sample permutation test for the difference in means.\n\n    Args:\n        data_a (list): A list of numerical measurements for group A.\n        data_b (list): A list of numerical measurements for group B.\n\n    Returns:\n        list: A list containing [p_value, support, probabilities], where\n              p_value is the two-sided p-value,\n              support is a sorted list of unique values in the null distribution,\n              and probabilities is the list of corresponding probabilities.\n    \"\"\"\n    n_a = len(data_a)\n    n_b = len(data_b)\n    N = n_a + n_b\n\n    # Convert to numpy arrays for vectorized operations\n    data_a = np.array(data_a)\n    data_b = np.array(data_b)\n    \n    # 1. Pool the data\n    pooled_data = np.concatenate((data_a, data_b))\n\n    # 2. Calculate the observed test statistic\n    mean_a_obs = np.mean(data_a) if n_a > 0 else 0.0\n    mean_b_obs = np.mean(data_b) if n_b > 0 else 0.0\n    T_obs = mean_a_obs - mean_b_obs\n    \n    # Rounding for consistent floating point comparisons later\n    # A high precision is used internally to avoid collapsing distinct but close values.\n    precision = 12\n    T_obs_rounded = round(T_obs, precision)\n\n    # 3. Generate the null distribution by enumerating all permutations\n    null_distribution_T_values = []\n    \n    # Each combination represents a possible group A\n    for indices_a in combinations(range(N), n_a):\n        indices_a = np.array(indices_a)\n        \n        # Create permuted groups A and B using indices\n        perm_a_data = pooled_data[indices_a]\n        \n        # The remaining indices form group B\n        mask = np.ones(N, dtype=bool)\n        mask[indices_a] = False\n        perm_b_data = pooled_data[mask]\n        \n        # Calculate the test statistic for this permutation\n        mean_a_perm = np.mean(perm_a_data) if n_a > 0 else 0.0\n        mean_b_perm = np.mean(perm_b_data) if n_b > 0 else 0.0\n        T_perm = mean_a_perm - mean_b_perm\n        \n        null_distribution_T_values.append(round(T_perm, precision))\n\n    null_distribution_T_values = np.array(null_distribution_T_values)\n    total_permutations = len(null_distribution_T_values)\n\n    # 4. Calculate the two-sided p-value\n    # Count permutations where |T_perm| is >= |T_obs|\n    # Use a small tolerance for floating point comparison robustness\n    # A more robust way, given we rounded, is direct comparison.\n    count_extreme = np.sum(np.abs(null_distribution_T_values) >= abs(T_obs_rounded))\n    p_value = count_extreme / total_permutations if total_permutations > 0 else 1.0\n\n    # 5. Get the support and probabilities of the null distribution\n    if total_permutations > 0:\n        unique_T, counts = np.unique(null_distribution_T_values, return_counts=True)\n        # Sorting is guaranteed by np.unique\n        support = unique_T.tolist()\n        probabilities = (counts / total_permutations).tolist()\n    else:\n        support = [0.0] if T_obs_rounded == 0.0 else [T_obs_rounded]\n        probabilities = [1.0]\n\n    # 6. Round final results to six decimal places for output\n    p_value_rounded = round(p_value, 6)\n    support_rounded = [round(v, 6) for v in support]\n    probabilities_rounded = [round(p, 6) for p in probabilities]\n\n    return [p_value_rounded, support_rounded, probabilities_rounded]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'a': [1.24, 1.37, 1.51, 1.63], 'b': [1.10, 1.21, 1.28, 1.30]},\n        {'a': [2.80], 'b': [2.10]},\n        {'a': [0.95, 1.02, 1.08], 'b': [0.89, 0.92, 1.00, 1.05, 1.10]},\n        {'a': [3.20, 3.20, 3.40], 'b': [3.10, 3.20, 3.30]},\n        {'a': [1.50, 1.50], 'b': [1.50, 1.50]},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_permutation_test(case['a'], case['b'])\n        all_results.append(result)\n\n    # Custom formatter to match the precise output format including spacing.\n    def format_float(f):\n        return f\"{f:.6f}\"\n    \n    def format_list_of_floats(lst):\n        return f\"[{','.join(format_float(x) for x in lst)}]\"\n        \n    def format_case_result(res):\n        p, s, P = res\n        p_str = format_float(p)\n        s_str = format_list_of_floats(s)\n        P_str = format_list_of_floats(P)\n        return f\"[{p_str},{s_str},{P_str}]\"\n        \n    output_str = f\"[{','.join(format_case_result(r) for r in all_results)}]\"\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}