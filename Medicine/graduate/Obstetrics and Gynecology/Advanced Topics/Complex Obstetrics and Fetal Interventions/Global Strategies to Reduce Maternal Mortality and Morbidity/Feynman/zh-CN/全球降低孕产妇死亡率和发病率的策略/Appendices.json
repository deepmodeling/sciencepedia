{
    "hands_on_practices": [
        {
            "introduction": "本练习旨在将循证干预措施的有效性转化为可量化的人群层面影响。通过一个关于交通代金券计划的假设情景，我们将运用相对风险（$RR$）和全概率定律等核心流行病学原理，来估算提高分娩设施覆盖率对降低孕产妇平均死亡风险的预期效果。这项实践旨在培养学生将临床或项目数据与人口统计学相结合，从而对公共卫生策略进行前瞻性评估的关键技能。",
            "id": "4446929",
            "problem": "一个低收入国家正在实施一项交通券计划，旨在通过减少出行相关的经济障碍，提高在医疗机构分娩的比例。与非机构内分娩相比，已知机构内分娩对孕产妇死亡具有保护作用。假设如下：\n\n- 效应指标是相对风险 (RR)，定义为 $RR = \\frac{r_{\\text{facility}}}{r_{\\text{non-facility}}}$，其中 $r_{\\text{facility}}$ 是在医疗机构内每次分娩的孕产妇死亡风险，$r_{\\text{non-facility}}$ 是在医疗机构外每次分娩的孕产妇死亡风险。\n- 机构内分娩的保护作用是恒定的，等于 $RR = 0.85$。\n- 在交通券计划实施前，医疗机构内分娩的比例为 $c_{0} = 0.55$。计划实施后，预期的医疗机构内分娩比例为 $c_{1} = 0.75$。\n- 人群平均的每次分娩孕产妇死亡风险由应用于分娩地点的全概率定律给出：$r(c) = c \\, r_{\\text{facility}} + (1 - c) \\, r_{\\text{non-facility}}$，适用于任意覆盖率 $c$。\n- 交通券计划仅影响覆盖率 $c$，除了导致分娩地点的转移外，不会改变 $RR$、$r_{\\text{facility}}$ 或 $r_{\\text{non-facility}}$ 本身。\n\n从这些定义和假设出发，推导当覆盖率从 $c_{0}$ 增加到 $c_{1}$ 时，人群平均孕产妇死亡风险的比例减少量的表达式。然后使用 $RR = 0.85$、$c_{0} = 0.55$ 和 $c_{1} = 0.75$ 计算其数值。将最终的死亡率降低表示为无单位的小数，并将答案四舍五入到四位有效数字。",
            "solution": "我们从相对风险 (RR) 的定义开始，该定义将机构内风险与机构外风险联系起来：\n$$RR = \\frac{r_{\\text{facility}}}{r_{\\text{non-facility}}}.$$\n这意味着\n$$r_{\\text{facility}} = RR \\cdot r_{\\text{non-facility}}.$$\n\n根据全概率定律，在机构分娩覆盖率为 $c$ 时，人群平均的每次分娩孕产妇死亡风险为\n$$r(c) = c \\, r_{\\text{facility}} + (1 - c) \\, r_{\\text{non-facility}}.$$\n代入 $r_{\\text{facility}} = RR \\cdot r_{\\text{non-facility}}$ 得\n\\begin{align*}\nr(c) = c \\, (RR \\cdot r_{\\text{non-facility}}) + (1 - c) \\, r_{\\text{non-facility}} \\\\\n= r_{\\text{non-facility}} \\left( c \\, RR + (1 - c) \\right) \\\\\n= r_{\\text{non-facility}} \\left( 1 - c (1 - RR) \\right).\n\\end{align*}\n\n设 $c_{0}$ 为计划实施前的覆盖率，$c_{1}$ 为计划实施后的覆盖率。由于覆盖率从 $c_{0}$ 变为 $c_{1}$ 导致的人群平均风险的比例减少量定义为\n$$\\Delta = 1 - \\frac{r(c_{1})}{r(c_{0})}.$$\n使用上面推导出的 $r(c)$ 的表达式，\n\\begin{align*}\n\\frac{r(c_{1})}{r(c_{0})} = \\frac{r_{\\text{non-facility}} \\left( 1 - c_{1} (1 - RR) \\right)}{r_{\\text{non-facility}} \\left( 1 - c_{0} (1 - RR) \\right)} \\\\\n= \\frac{1 - c_{1} (1 - RR)}{1 - c_{0} (1 - RR)}.\n\\end{align*}\n因此，\n$$\\Delta = 1 - \\frac{1 - c_{1} (1 - RR)}{1 - c_{0} (1 - RR)}.$$\n\n现在，代入数值 $RR = 0.85$，$c_{0} = 0.55$ 和 $c_{1} = 0.75$。首先计算 $1 - RR$：\n$$1 - RR = 1 - 0.85 = 0.15.$$\n计算分子项：\n\\begin{align*}\n1 - c_{1} (1 - RR) = 1 - 0.75 \\times 0.15 \\\\\n= 1 - 0.1125 \\\\\n= 0.8875.\n\\end{align*}\n计算分母项：\n\\begin{align*}\n1 - c_{0} (1 - RR) = 1 - 0.55 \\times 0.15 \\\\\n= 1 - 0.0825 \\\\\n= 0.9175.\n\\end{align*}\n因此，\n\\begin{align*}\n\\frac{r(c_{1})}{r(c_{0})} = \\frac{0.8875}{0.9175}.\n\\end{align*}\n为了方便地将该比率表示为精确值，我们将其写成整数比并进行化简：\n\\begin{align*}\n\\frac{0.8875}{0.9175} = \\frac{8875}{9175} = \\frac{355}{367}.\n\\end{align*}\n因此，比例减少量为\n\\begin{align*}\n\\Delta = 1 - \\frac{355}{367} = \\frac{367 - 355}{367} = \\frac{12}{367}.\n\\end{align*}\n将其转换为小数并四舍五入到四位有效数字：\n\\begin{align*}\n\\frac{12}{367} \\approx 0.032698... \\\\\n\\Delta \\approx 0.03270 \\quad \\text{(四位有效数字)}.\n\\end{align*}\n\n这个数值代表，在机构内分娩相对于非机构内分娩的 $RR = 0.85$ 的条件下，将机构分娩覆盖率从 $c_{0} = 0.55$ 提高到 $c_{1} = 0.75$ 所导致的孕产妇死亡率的预期比例减少量（以小数形式表示）。",
            "answer": "$$\\boxed{0.03270}$$"
        },
        {
            "introduction": "在现实世界中，孕产妇死亡通常由多种原因导致，这些原因在风险上相互竞争。本练习引入了生存分析中的竞争风险模型，这是一个评估特定原因（如产后败血症）死亡率的关键工具。通过推导和计算特定原因累积发生率函数，您将学会如何在存在多种死亡风险时，准确量化某一特定原因所造成的真实负担，从而为针对性干预措施的优先排序提供更精确的证据。",
            "id": "4446976",
            "problem": "一个与世界卫生组织（WHO）合作的全球孕产妇健康联盟正在一个高负担地区评估综合策略——例如标准化的感染预防措施包、及时的抗生素治疗以及强化的转诊网络——对产后孕产妇死亡率的影响。为了在人群水平上量化风险，假设分娩后的孕产妇死亡由竞争性原因引起，在产后期间具有原因别瞬时风险率 $h_{i}(t)$，其中 $t$ 是从分娩开始计算的天数。\n\n采用标准的竞争风险框架，从以下基本定义开始：\n- 原因别风险率 $h_{i}(t)$ 是在存活至时间 $t$ 的条件下，原因 $i$ 的事件在时间 $t$ 发生的瞬时速率。\n- 全因风险率为 $h(t)=\\sum_{i} h_{i}(t)$。\n- 在独立竞争风险和具有右连续风险率的连续时间模型下，生存函数为 $S(t)=\\exp\\!\\left(-\\int_{0}^{t} h(u)\\,du\\right)$。\n\n在一个假设的高风险队列中，分娩时存活率为 $100\\%$ ($S(0)=1$)，假设在时间区间 $t\\in[0,42]$ 内，脓毒症的原因别风险率是常数 $h_{s}(t)=h_{s}=0.0003$ 每天，而所有其他孕产妇死亡原因的总原因别风险率是常数 $h_{o}(t)=h_{o}=0.0007$ 每天。使用竞争风险下特定原因的累积发生率的正式定义，在这些假设下推导脓毒症在时间 $t$ 的累积发生函数，并计算其在产后 $t=42$ 天时的值。\n\n将最终结果表示为十进制比例（无单位），并四舍五入到四位有效数字。",
            "solution": "目标是推导脓毒症的累积发生函数（CIF），记为 $CI_s(t)$，并计算其在 $t=42$ 天时的值。特定原因 $i$ 的CIF，也称为子分布函数，量化了原因 $i$ 的事件在时间 $t$ 之前发生的概率。它的正式定义是在时间区间 $[0, t]$ 上对原因别发生率进行积分。在时间 $u$ 的原因别发生率是原因别风险率 $h_i(u)$ 和全因生存概率 $S(u)$ 的乘积。\n\n定义为：\n$$CI_i(t) = \\int_{0}^{t} h_i(u) S(u) \\,du$$\n\n对于此问题，我们关心的是作为死亡原因的脓毒症。因此，我们需要求：\n$$CI_s(t) = \\int_{0}^{t} h_s(u) S(u) \\,du$$\n\n首先，我们必须确定全因生存函数 $S(t)$。该函数取决于全因风险率 $h(t)$，即所有原因别风险率的总和。在这种情况下，我们有两个竞争性原因：脓毒症 ($s$) 和所有其他原因 ($o$)。\n\n给定的原因别风险率是常数：\n- 脓毒症的风险率：$h_s(t) = h_s = 0.0003$ 每天。\n- 其他原因的风险率：$h_o(t) = h_o = 0.0007$ 每天。\n\n全因风险率 $h(t)$ 是它们的和：\n$$h(t) = h_s(t) + h_o(t) = h_s + h_o$$\n由于 $h_s$ 和 $h_o$ 是常数，全因风险率 $h(t)$ 也是一个常数，我们将其表示为 $h$：\n$$h = h_s + h_o = 0.0003 + 0.0007 = 0.001 \\text{ 每天}$$\n\n全因生存函数 $S(t)$ 定义为：\n$$S(t) = \\exp\\left(-\\int_{0}^{t} h(u) \\,du\\right)$$\n将常数全因风险率 $h$ 代入积分：\n$$\\int_{0}^{t} h \\,du = h \\int_{0}^{t} \\,du = ht$$\n因此，生存函数为：\n$$S(t) = \\exp(-ht) = \\exp(-(h_s + h_o)t)$$\n这是具有恒定风险率的指数分布的标准生存函数。\n\n现在我们可以将 $h_s(u)$ 和 $S(u)$ 的表达式代回到 $CI_s(t)$ 的公式中：\n$$CI_s(t) = \\int_{0}^{t} h_s S(u) \\,du = \\int_{0}^{t} h_s \\exp(-(h_s + h_o)u) \\,du$$\n由于 $h_s$ 是常数，我们可以将其移到积分符号外：\n$$CI_s(t) = h_s \\int_{0}^{t} \\exp(-(h_s + h_o)u) \\,du$$\n我们现在计算这个定积分：\n$$CI_s(t) = h_s \\left[ -\\frac{1}{h_s + h_o} \\exp(-(h_s + h_o)u) \\right]_{0}^{t}$$\n应用积分上下限，$u=t$ 和 $u=0$：\n$$CI_s(t) = h_s \\left( \\left( -\\frac{1}{h_s + h_o} \\exp(-(h_s + h_o)t) \\right) - \\left( -\\frac{1}{h_s + h_o} \\exp(-(h_s + h_o) \\cdot 0) \\right) \\right)$$\n因为 $\\exp(0) = 1$：\n$$CI_s(t) = h_s \\left( -\\frac{\\exp(-(h_s + h_o)t)}{h_s + h_o} + \\frac{1}{h_s + h_o} \\right)$$\n提取公因式 $\\frac{1}{h_s + h_o}$，得到推导出的脓毒症累积发生函数：\n$$CI_s(t) = \\frac{h_s}{h_s + h_o} \\left( 1 - \\exp(-(h_s + h_o)t) \\right)$$\n该方程表示在存在竞争风险的情况下，到时间 $t$ 为止因脓毒症导致孕产妇死亡的概率。\n\n问题要求计算该函数在 $t=42$ 天时的数值。我们代入给定的值：\n- $h_s = 0.0003$\n- $h_o = 0.0007$\n- $h_s + h_o = 0.001$\n- $t = 42$\n\n$$CI_s(42) = \\frac{0.0003}{0.0003 + 0.0007} \\left( 1 - \\exp(-(0.0003 + 0.0007) \\times 42) \\right)$$\n$$CI_s(42) = \\frac{0.0003}{0.001} \\left( 1 - \\exp(-0.001 \\times 42) \\right)$$\n$$CI_s(42) = 0.3 \\left( 1 - \\exp(-0.042) \\right)$$\n现在，我们计算数值：\n$$CI_s(42) \\approx 0.3 \\times (1 - 0.958869036)$$\n$$CI_s(42) \\approx 0.3 \\times 0.041130964$$\n$$CI_s(42) \\approx 0.012339289$$\n问题要求答案四舍五入到四位有效数字。前四位有效数字是 $1, 2, 3, 3$。下一位数字是 $9$，大于或等于 $5$，因此我们将最后一位有效数字向上取整。\n$$CI_s(42) \\approx 0.01234$$\n这就是该队列中一名妇女在产后 $42$ 天内死于脓毒症的累积发生率，或称概率。",
            "answer": "$$\\boxed{0.01234}$$"
        },
        {
            "introduction": "减少到达适宜医疗机构的延迟是降低孕产妇死亡率的核心策略之一。本实践练习将带您进入卫生系统规划与运筹学的交叉领域，要求您将一个地区的转诊网络抽象为图模型。您将应用Dijkstra最短路径算法，并通过优化新设施的选址来最大限度地改善医疗服务的可及性，其衡量标准是人口加权的中位旅行时间。这项综合性任务旨在培养您利用计算工具来解决复杂的卫生系统设计问题，从而做出数据驱动的战略决策。",
            "id": "4446990",
            "problem": "设计并实现一个程序，该程序将多个地区转诊至综合性紧急产科和新生儿护理（CEmONC）设施的出行时间建模为加权图，并选择两个新的设施位置，以最小化到达任何 CEmONC 设施的人口加权中位数时间。其科学基础是孕产妇保健领域广为接受的“三延迟模型”，其中通过减少到达 CEmONC 的出行时间来缩短第二延迟（延迟获得适当护理）。其数学基础是图论和加权图上的最短路径。\n\n使用以下基本依据和定义：\n- 设一个地区转诊网络由一个连通的、无向的加权图 $G = (V, E)$ 表示，其节点集为 $V = \\{0, 1, \\ldots, n-1\\}$，边集为 $E \\subseteq V \\times V$。每条边 $(u, v) \\in E$ 都有一个相关的正权重 $w(u, v) > 0$，表示沿连接 $u$ 和 $v$ 的路段的出行时间（分钟）。\n- 设子集 $F \\subseteq V$ 表示当前拥有具备 CEmONC 能力的设施的节点。设 $C \\subseteq V$ 表示有资格增设新 CEmONC 设施的候选节点。假设 $F \\cap C = \\emptyset$。\n- 设 $p: V \\to \\mathbb{R}_{>0}$ 表示人口权重（例如，居住在每个节点附近面临产科急症风险的妇女人数）。对于每个节点 $v \\in V$，定义 $p(v)$ 为其人口权重。\n- 对于任何设施节点集 $S \\subseteq V$，将节点 $v$ 的最近设施出行时间定义为 $d_S(v)$，即从 $v$到 $S$ 中任意节点的最短路径长度（分钟），计算为连接 $v$到 $S$ 中任意设施节点的所有路径中的最小值。所有路径都评估为边权重之和，且所有边权重均为严格正数。使用 Dijkstra 最短路径算法的基本原理计算 $d_S(v)$。\n- 为集合 $S$ 定义人口加权中位数出行时间如下。设多重集 $\\{(d_S(v), p(v)) \\mid v \\in V\\}$ 按 $d_S(v)$ 的非递减顺序排序。设 $P_{\\text{tot}} = \\sum_{v \\in V} p(v)$，并设 $m$ 为 $d_S(v)$ 的最小值，使得所有 $d_S(v)$ 不超过 $m$ 的节点的 $p(v)$ 累积和至少为 $P_{\\text{tot}}/2$。那么 $m$ 就是人口加权中位数出行时间（分钟）。如果出现平局导致中位数相同，则通过选择具有最小人口加权平均出行时间 $\\bar{t}_S = \\left(\\sum_{v \\in V} p(v) \\cdot d_S(v)\\right) / P_{\\text{tot}}$ 的配置来打破平局。\n\n您的程序必须：\n1. 对于每个测试用例，使用当前设施 $F$ 计算基线人口加权中位数出行时间 $m_{\\text{base}}$。\n2. 在所有无序对 $\\{c_1, c_2\\}$（其中 $c_1, c_2 \\in C$ 且 $c_1 \\neq c_2$）中，评估 $S = F \\cup \\{c_1, c_2\\}$ 并计算 $m_S$。选择使 $m_S$ 最小化的配对。如果多个配对产生相同的最小 $m_S$，则选择使 $\\bar{t}_S$ 最小化的配对。\n3. 报告所选配对的优化后人口加权中位数 $m_{\\text{opt}}$ 以及改进量 $\\Delta = m_{\\text{base}} - m_{\\text{opt}}$，以分钟为单位。如果由于数值精度问题 $\\Delta$ 为负，则将其视为 $0$。\n4. 所有出行时间以分钟表示，四舍五入到一位小数。\n\n测试套件和参数：\n- 测试用例 1（通用“理想路径”用例）：\n  - 节点：$n = 9$, $V = \\{0,1,2,3,4,5,6,7,8\\}$。\n  - 边 $E$ （每个元组为 $(u, v, w)$，其中 $w$ 以分钟为单位）：\n    - $(0, 1, 12)$, $(1, 2, 10)$, $(2, 3, 8)$, $(3, 4, 15)$, $(4, 5, 7)$, $(5, 6, 9)$, $(6, 7, 11)$, $(7, 8, 13)$,\n    - $(0, 3, 20)$, $(1, 4, 17)$, $(2, 5, 14)$, $(3, 6, 12)$, $(4, 7, 10)$, $(5, 8, 9)$。\n  - 当前设施 $F = \\{0\\}$。\n  - 候选节点 $C = \\{3, 4, 6, 8\\}$。\n  - 人口权重 $p(v)$ （单位：人）：$p = [800, 1200, 1500, 1000, 2000, 1300, 900, 1100, 1600]$。\n- 测试用例 2（接近对称覆盖和多重平局的边界用例）：\n  - 节点：$n = 6$, $V = \\{0,1,2,3,4,5\\}$。\n  - 边 $E$：\n    - $(0, 1, 5)$, $(1, 2, 5)$, $(2, 3, 5)$, $(3, 4, 5)$, $(4, 5, 5)$, $(0, 5, 25)$。\n  - 当前设施 $F = \\{2, 4\\}$。\n  - 候选节点 $C = \\{1, 3, 5\\}$。\n  - 人口权重 $p = [500, 500, 500, 500, 500, 500]$。\n- 测试用例 3（人口高度集中于现有设施的边缘用例）：\n  - 节点：$n = 8$, $V = \\{0,1,2,3,4,5,6,7\\}$。\n  - 边 $E$：\n    - $(0, 1, 3)$, $(1, 2, 4)$, $(2, 3, 6)$, $(3, 4, 7)$, $(4, 5, 8)$, $(5, 6, 9)$, $(6, 7, 10)$。\n  - 当前设施 $F = \\{0\\}$。\n  - 候选节点 $C = \\{2, 5, 7\\}$。\n  - 人口权重 $p = [10000, 10, 10, 10, 10, 10, 10, 10]$。\n\n算法要求：\n- 直接实现具有非负边权重的 Dijkstra 最短路径算法。对于最近设施的计算，通过将 $F$ 中的所有节点初始化为距离 $0$ 并应用标准松弛过程来实现多源变体。\n- 对于每个候选配对，重新计算最近设施距离以及定义的人口加权中位数和平均值。\n- 通过确定性的平局打破规则确保计算的正确性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例结果必须是 $[m_{\\text{base}}, m_{\\text{opt}}, \\Delta, c_1, c_2]$ 形式的列表，其中 $m_{\\text{base}}$、$m_{\\text{opt}}$ 和 $\\Delta$ 是四舍五入到一位小数的浮点数（分钟），$c_1$、$c_2$ 是表示所选候选节点的整数。将三个测试用例的结果聚合成一个单一列表，如 $[[m_{\\text{base}}, m_{\\text{opt}}, \\Delta, c_1, c_2],[\\ldots],[\\ldots]]$。",
            "solution": "该解决方案旨在通过最小化整个地区转诊网络的人口加权中位数出行时间，从一组候选位置中找到一对最优的新 CEmONC 设施位置。\n\n**1. 模型表示**\n地区的转诊网络被建模为一个连通的无向图 $G = (V, E)$。\n- 节点 $V = \\{0, 1, \\ldots, n-1\\}$ 代表关键位置（例如，村庄、城镇、道路交叉口）。\n- 边 $(u, v) \\in E$ 代表路段，其权重 $w(u,v)$ 对应于以分钟为单位的出行时间。\n- 每个节点 $v$ 的人口由权重 $p(v)$ 给出。\n- 节点子集 $F \\subseteq V$ 代表现有 CEmONC 设施的位置。\n- 一个不相交的子集 $C \\subseteq V$ ($F \\cap C = \\emptyset$) 代表新设施的候选位置。\n\n**2. 核心算法组件**\n\n**a. 最近设施出行时间计算**\n为了计算从每个节点 $v \\in V$ 到集合 $S \\subseteq V$ 中最近设施的出行时间，我们采用多源 Dijkstra 算法。距离 $d_S(v)$ 是从 $v$ 到 $S$ 中任意节点的最短路径。该算法初始化如下：\n- 大小为 $n$ 的距离数组 `dist` 被初始化，对于所有 $v \\in S$，`dist[v] = 0`；对于所有 $v \\notin S$，`dist[v] = \\infty`。\n- 一个最小优先队列被初始化，包含所有设施节点 $s \\in S$，每个节点的优先级（距离）为 $0$。\n随后，该算法的执行过程与标准 Dijkstra 算法完全相同，迭代地从优先队列中提取距离最小的节点，并对其出边进行松弛，直到所有可达节点的的最短路径距离都已最终确定。这可以正确地为所有 $v \\in V$ 找到 $d_S(v) = \\min_{s \\in S} \\text{shortest\\_path}(v, s)$。\n\n**b. 人口加权中位数和平均值计算**\n给定距离集 $\\{d_S(v) \\mid v \\in V\\}$ 和人口权重集 $\\{p(v) \\mid v \\in V\\}$，可以计算人口加权中位数和平均值。\n- **人口加权中位数 ($m_S$)**：\n  1. 我们为所有 $v \\in V$ 构成一个元组多重集 $(d_S(v), p(v))$。\n  2. 该多重集根据出行时间 $d_S(v)$ 按非递减顺序排序。\n  3. 计算总人口 $P_{\\text{tot}} = \\sum_{v \\in V} p(v)$。\n  4. 我们遍历排序后的元组，累加人口权重。中位数 $m_S$ 是第一个使累积人口总和达到或超过 $P_{\\text{\\text{tot}}} / 2$ 的元组 $(d_S(v_i), p(v_i))$ 的出行时间。\n- **人口加权平均值 ($\\bar{t}_S$)**：\n  该值用于打破平局，计算方式为加权平均值：\n  $$ \\bar{t}_S = \\frac{\\sum_{v \\in V} p(v) \\cdot d_S(v)}{P_{\\text{tot}}} $$\n\n**3. 优化过程**\n整体算法通过评估每种可能的情景来找到最优的新设施配对。\n1. **基线计算**：首先，使用初始设施集 $F$ 计算基线人口加权中位数出行时间 $m_{\\text{base}}$。这包括以 $S=F$ 运行多源 Dijkstra 算法，然后计算中位数。\n\n2. **迭代优化**：\n   - 程序从集合 $C$ 中生成所有唯一的、无序的候选节点对 $\\{c_1, c_2\\}$。\n   - 对于每对候选节点，形成一个新的临时设施集 $S = F \\cup \\{c_1, c_2\\}$。\n   - 计算该集合 $S$ 的指标 $m_S$ 和 $\\bar{t}_S$。\n   - 将这些指标与迄今为止找到的最佳指标进行比较。如果满足以下条件，一对节点 $\\{c_1, c_2\\}$ 将成为新的最优解：\n     - 其中位数 $m_S$ 严格小于当前最佳中位数。\n     - 或者，其中位数 $m_S$ 等于当前最佳中位数，但其平均值 $\\bar{t}_S$ 严格小于当前最佳平均值。\n     - 为了在中位数和平均值均出现平局时保证确定性，我们可以选择字典序最小的配对（例如，通过对节点索引进行排序）。该实现通过按固定顺序迭代来隐式处理此问题。\n\n3. **最终结果生成**：一旦评估完所有配对，就确定了最优配对 $\\{c_1^*, c_2^*\\}$。优化后的中位数为 $m_{\\text{opt}} = m_{F \\cup \\{c_1^*, c_2^*\\}}$. 改进量的计算公式为 $\\Delta = m_{\\text{base}} - m_{\\text{opt}}$。如果数值精度导致 $\\Delta$ 成为一个小的负数，则将其下取整至 $0.0$。每个测试用例的最终输出是一个列表 $[m_{\\text{base}}, m_{\\text{opt}}, \\Delta, c_1^*, c_2^*]$，其中出行时间四舍五入到一位小数。\n\n这种结构化的方法确保所有约束都得到满足，并根据问题的标准找到了全局最优的新设施位置配对。",
            "answer": "```python\nimport numpy as np\nimport heapq\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to process test cases for CEmONC facility placement optimization.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"n\": 9,\n            \"edges\": [\n                (0, 1, 12), (1, 2, 10), (2, 3, 8), (3, 4, 15), (4, 5, 7), \n                (5, 6, 9), (6, 7, 11), (7, 8, 13), (0, 3, 20), (1, 4, 17), \n                (2, 5, 14), (3, 6, 12), (4, 7, 10), (5, 8, 9)\n            ],\n            \"F\": {0},\n            \"C\": {3, 4, 6, 8},\n            \"p\": [800, 1200, 1500, 1000, 2000, 1300, 900, 1100, 1600]\n        },\n        # Test Case 2\n        {\n            \"n\": 6,\n            \"edges\": [\n                (0, 1, 5), (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (0, 5, 25)\n            ],\n            \"F\": {2, 4},\n            \"C\": {1, 3, 5},\n            \"p\": [500, 500, 500, 500, 500, 500]\n        },\n        # Test Case 3\n        {\n            \"n\": 8,\n            \"edges\": [\n                (0, 1, 3), (1, 2, 4), (2, 3, 6), (3, 4, 7), (4, 5, 8), \n                (5, 6, 9), (6, 7, 10)\n            ],\n            \"F\": {0},\n            \"C\": {2, 5, 7},\n            \"p\": [10000, 10, 10, 10, 10, 10, 10, 10]\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n, edges, F, C, p = case[\"n\"], case[\"edges\"], case[\"F\"], case[\"C\"], np.array(case[\"p\"])\n        \n        adj = [[] for _ in range(n)]\n        for u, v, w in edges:\n            adj[u].append((v, w))\n            adj[v].append((u, w))\n\n        def multi_source_dijkstra(facility_nodes):\n            \"\"\"\n            Computes shortest path from all nodes to the nearest facility.\n            \"\"\"\n            dist = np.full(n, np.inf)\n            pq = []\n            for facility in facility_nodes:\n                dist[facility] = 0\n                heapq.heappush(pq, (0, facility))\n\n            while pq:\n                d, u = heapq.heappop(pq)\n\n                if d > dist[u]:\n                    continue\n\n                for v, weight in adj[u]:\n                    if dist[u] + weight  dist[v]:\n                        dist[v] = dist[u] + weight\n                        heapq.heappush(pq, (dist[v], v))\n            return dist\n\n        def calculate_metrics(distances, populations):\n            \"\"\"\n            Calculates population-weighted median and mean travel times.\n            \"\"\"\n            total_pop = np.sum(populations)\n            median_threshold = total_pop / 2.0\n\n            # For median calculation\n            data = sorted(zip(distances, populations))\n            \n            cumulative_pop = 0\n            weighted_median = 0\n            for d, pop_weight in data:\n                cumulative_pop += pop_weight\n                if cumulative_pop >= median_threshold:\n                    weighted_median = d\n                    break\n            \n            # For mean calculation\n            weighted_sum = np.dot(distances, populations)\n            weighted_mean = weighted_sum / total_pop if total_pop > 0 else 0\n\n            return weighted_median, weighted_mean\n\n        # 1. Compute baseline metrics\n        base_distances = multi_source_dijkstra(F)\n        m_base, _ = calculate_metrics(base_distances, p)\n\n        # 2. Find optimal pair\n        best_median = float('inf')\n        best_mean = float('inf')\n        best_pair = None\n\n        candidate_pairs = list(combinations(sorted(list(C)), 2))\n        \n        for pair in candidate_pairs:\n            c1, c2 = pair\n            current_facilities = F.union({c1, c2})\n            \n            distances = multi_source_dijkstra(current_facilities)\n            m_s, t_bar_s = calculate_metrics(distances, p)\n\n            if m_s  best_median:\n                best_median = m_s\n                best_mean = t_bar_s\n                best_pair = pair\n            elif m_s == best_median:\n                if t_bar_s  best_mean:\n                    best_mean = t_bar_s\n                    best_pair = pair\n        \n        # In case no improvement is possible, ensure variables are set\n        if best_pair is None:\n            # This happens if C has fewer than 2 elements, or if we want to handle no improvement case.\n            # Here, we can assume there's always an 'optimal' choice even if it's not an improvement.\n            # If C has 2 members, candidate_pairs has 1 element. If C has 2, it's empty.\n            if candidate_pairs:\n                best_pair = candidate_pairs[0]\n                current_facilities = F.union(set(best_pair))\n                distances = multi_source_dijkstra(current_facilities)\n                m_opt_val, _ = calculate_metrics(distances, p)\n            else: # No valid pairs to test\n                m_opt_val = m_base\n                best_pair = (-1, -1) # Placeholder for no valid choice\n        else:\n            m_opt_val = best_median\n\n        # 3. Report results\n        delta = m_base - m_opt_val\n        delta = max(0.0, delta)\n\n        result = [\n            round(m_base, 1),\n            round(m_opt_val, 1),\n            round(delta, 1),\n            best_pair[0],\n            best_pair[1]\n        ]\n        all_results.append(result)\n\n    print(f\"{all_results}\")\n\nsolve()\n```"
        }
    ]
}