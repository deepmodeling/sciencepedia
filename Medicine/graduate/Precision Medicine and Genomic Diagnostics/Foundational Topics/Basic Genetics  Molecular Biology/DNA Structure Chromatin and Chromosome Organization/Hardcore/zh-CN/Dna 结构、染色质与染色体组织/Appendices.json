{
    "hands_on_practices": [
        {
            "introduction": "染色质的基本单位是核小体，它要求将刚性的DNA分子紧密地缠绕在组蛋白八聚体上。由于DNA的弯曲，这个过程会产生显著的能量代价。本练习将演示如何使用蠕虫状链（Worm-like Chain, WLC）模型来量化这一能量成本，该模型是高分子物理学的基石，它为我们理解调控基因组包装的物理约束提供了深刻见解 。",
            "id": "4335315",
            "problem": "在精准医疗和基因组诊断学中，染色质内脱氧核糖核酸（DNA）弯曲的能量学影响核小体的稳定性以及酶探针的可及性。考虑一个半柔性聚合物的蠕虫状链模型，其弯曲模量由 $A = k_{B} T P$ 给出，其中 $k_{B}$ 表示玻尔兹曼常数，$T$ 表示绝对温度，$P$ 表示持续长度。一条具有弧长参数 $s$ 和曲率 $\\kappa(s)$ 的光滑空间曲线，其弹性弯曲能 $E$ 由基本的蠕虫状链表达式 $E = \\frac{1}{2} A \\int \\kappa(s)^{2} \\, ds$ 给出。假设核小体DNA以近似恒定的曲率缠绕在组蛋白八聚体上，该曲率由几何半径 $R$ 决定，因此 $\\kappa(s) \\approx \\frac{1}{R}$。取组蛋白核心半径为 $R = 4.2\\,\\mathrm{nm}$，生理离子强度下DNA的持续长度为 $P = 50\\,\\mathrm{nm}$，缠绕的DNA轮廓长度为 $L = 147 \\times 0.34\\,\\mathrm{nm}$，其中 $0.34\\,\\mathrm{nm}$ 是每对碱基对的上升高度。使用这些具有物理合理性的输入数据和上述基本关系，推导并计算这段缠绕DNA片段的弯曲能。将最终答案表示为玻尔兹曼常数与温度乘积的无量纲倍数（即，报告 $E/(k_{B} T)$），并将您的答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其科学上合理、提法恰当且客观。\n\n### 步骤 1：提取已知条件\n- 弯曲模量：$A = k_{B} T P$\n- 玻尔兹曼常数：$k_{B}$\n- 绝对温度：$T$\n- 持续长度：$P$\n- 弯曲能表达式：$E = \\frac{1}{2} A \\int \\kappa(s)^{2} \\, ds$\n- 弧长参数：$s$\n- 曲率：$\\kappa(s)$\n- 曲率的近似值：$\\kappa(s) \\approx \\frac{1}{R}$\n- 组蛋白核心半径：$R = 4.2\\,\\mathrm{nm}$\n- DNA持续长度：$P = 50\\,\\mathrm{nm}$\n- 缠绕DNA轮廓长度：$L = 147 \\times 0.34\\,\\mathrm{nm}$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，它采用了成熟的蠕虫状链（WLC）模型来描述DNA的弹性特性，这是生物物理学中的标准方法。所提供的弯曲模量（$A$）和弯曲能（$E$）的方程是该模型中的正确基本表达式。给定的物理参数（$P = 50\\,\\mathrm{nm}$、$R = 4.2\\,\\mathrm{nm}$ 以及从147个碱基对推导出的轮廓长度）与科学文献中公认的生理条件下DNA的数值一致。该问题提法恰当，提供了所有必要的信息和明确的目标，从而能得出一个唯一的、有意义的解。语言精确客观。因此，该问题被认定为有效。\n\n### 步骤 3：结论与行动\n问题有效。现在将推导完整的解答过程。\n\n任务是计算缠绕在组蛋白核心上的一段DNA的弯曲能 $E$，并将其表示为 $k_{B} T$ 的无量纲倍数。出发点是蠕虫状链模型所描述的半柔性聚合物的弹性弯曲能表达式：\n$$E = \\frac{1}{2} A \\int_{0}^{L} \\kappa(s)^{2} \\, ds$$\n此处，$A$ 是弯曲模量，$\\kappa(s)$ 是在弧长位置 $s$ 处的局部曲率，积分是在聚合物片段的总轮廓长度 $L$ 上进行的。\n\n弯曲模量 $A$ 由以下关系式给出：\n$$A = k_{B} T P$$\n其中 $k_{B}$ 是玻尔兹曼常数，$T$ 是绝对温度，$P$ 是DNA的持续长度。\n\n问题指出，DNA以近似恒定的曲率缠绕在组蛋白八聚体上。该曲率由组蛋白核心的半径 $R$ 决定。对于一个曲率半径恒为 $R$ 的曲线，其曲率 $\\kappa$ 由 $\\kappa = \\frac{1}{R}$ 给出。因此，我们得到近似关系：\n$$\\kappa(s) \\approx \\frac{1}{R}$$\n\n将 $A$ 和 $\\kappa(s)$ 的表达式代入能量方程，得到：\n$$E = \\frac{1}{2} (k_{B} T P) \\int_{0}^{L} \\left(\\frac{1}{R}\\right)^{2} \\, ds$$\n由于 $R$ 是一个常数，项 $\\frac{1}{R^2}$可以移到积分号外：\n$$E = \\frac{k_{B} T P}{2 R^{2}} \\int_{0}^{L} \\, ds$$\n$ds$ 从 $0$ 到 $L$ 的积分就是总轮廓长度 $L$：\n$$\\int_{0}^{L} \\, ds = L$$\n这可将能量表达式简化为：\n$$E = \\frac{k_{B} T P L}{2 R^{2}}$$\n问题要求最终答案是无量纲量 $\\frac{E}{k_{B} T}$。将上式除以 $k_{B} T$，我们得到所需量的最终解析公式：\n$$\\frac{E}{k_{B} T} = \\frac{P L}{2 R^{2}}$$\n\n现在，我们将提供的数值代入该表达式。\n持续长度为 $P = 50\\,\\mathrm{nm}$。\n组蛋白核心的半径为 $R = 4.2\\,\\mathrm{nm}$。\n轮廓长度 $L$ 由碱基对数量（147）与每对碱基对的上升高度（$0.34\\,\\mathrm{nm}$）的乘积给出：\n$$L = 147 \\times 0.34\\,\\mathrm{nm} = 49.98\\,\\mathrm{nm}$$\n代入这些值：\n$$\\frac{E}{k_{B} T} = \\frac{(50\\,\\mathrm{nm}) (49.98\\,\\mathrm{nm})}{2 (4.2\\,\\mathrm{nm})^{2}}$$\n单位在量纲上是一致的，因为 $(\\mathrm{nm} \\times \\mathrm{nm}) / \\mathrm{nm}^2$ 会得到一个无量纲的量。\n进行计算：\n$$\\frac{E}{k_{B} T} = \\frac{2499}{2 \\times (4.2)^{2}} = \\frac{2499}{2 \\times 17.64} = \\frac{2499}{35.28}$$\n进行最后的除法运算：\n$$\\frac{E}{k_{B} T} \\approx 70.83333...$$\n问题要求答案四舍五入到四位有效数字。\n结果是 $70.83$。",
            "answer": "$$\\boxed{70.83}$$"
        },
        {
            "introduction": "除了静态结构，染色质还受到组蛋白修饰（如H3K27ac）的动态调控。尽管ChIP-seq是绘制这些修饰图谱的强大工具，但在样本之间进行定量比较，尤其是在发生全局性变化时，充满了挑战。本练习介绍如何使用外源spike-in（掺入参照）进行数据标准化，从而能够对观察到的组蛋白修饰水平变化进行严格的统计评估 。",
            "id": "4335400",
            "problem": "一个实验室正在使用染色质免疫沉淀后测序（ChIP-seq）技术，并辅以来自 Drosophila melanogaster 的外源spike-in参考，来量化癌细胞系中对照组与处理组之间组蛋白H3赖氨酸27乙酰化（H3K27ac）的差异。在免疫沉淀之前，将等质量的spike-in染色质添加到对照组和处理组中。处理使H3K27ac水平全局增加了两倍，这改变了人类读数与spike-in读数的比例，但并未改变spike-in的绝对投入质量。测序和比对产生以下总数：\n- 对照组比对到人类基因组的读数：$H_{c} = 3.6 \\times 10^{7}$；对照组比对到spike-in的读数：$S_{c} = 4.0 \\times 10^{6}$。\n- 处理组比对到人类基因组的读数：$H_{t} = 3.8 \\times 10^{7}$；处理组比对到spike-in的读数：$S_{t} = 2.0 \\times 10^{6}$。\n\n对于三个代表性的H3K27ac峰，原始的人类基因组比对读数计数如下：\n- 峰A：$h_{A,c} = 1000$, $h_{A,t} = 2111$。\n- 峰B：$h_{B,c} = 500$, $h_{B,t} = 950$。\n- 峰C：$h_{C,c} = 300$, $h_{C,t} = 1000$。\n\n从比例抽样和计数过程的第一性原理出发，按以下步骤进行：\n1. 推导处理组的spike-in归一化因子 $f_{t}$，使得归一化后，处理组中人类读数与spike-in读数的比例等于对照组中的比例。使用定义 $R_{c} = H_{c}/S_{c}$ 和 $R_{t} = H_{t}/S_{t}$，并设定条件 $f_{t} R_{t} = R_{c}$。\n2. 使用 $f_{t}$ 计算每个峰 $i \\in \\{A,B,C\\}$ 的归一化处理组峰计数 $h'_{i,t} = f_{t} \\, h_{i,t}$，以及每个峰对应的归一化倍数变化 $\\mathrm{FC}_{i} = h'_{i,t}/h_{i,c}$。\n3. 为了确定观察到的峰水平倍数变化是否为假象（即完全由全局两倍增加引起），将均一全局变化下的处理组峰计数的零假设期望形式化为 $\\lambda_{i} = h_{i,c} \\, (R_{t}/R_{c})$，并将峰计数建模为均值为 $\\lambda_{i}$ 的泊松分布。使用双边显著性水平 $\\alpha = 0.05$，如果观察到的 $h_{i,t}$ 在统计上与泊松模型下的 $\\lambda_{i}$ 一致（即双边 $p$ 值大于 $\\alpha$），则将该峰分类为“假象峰”。\n4. 以单一值的形式，报告根据此标准被判定为假象峰的三个峰的比例。将最终比例表示为简化分数或小数。如果选择小数，请将答案四舍五入到四位有效数字。",
            "solution": "对问题陈述进行验证。\n\n### 第1步：提取已知信息\n- 对照组比对到人类基因组的读数：$H_{c} = 3.6 \\times 10^{7}$\n- 对照组比对到spike-in的读数：$S_{c} = 4.0 \\times 10^{6}$\n- 处理组比对到人类基因组的读数：$H_{t} = 3.8 \\times 10^{7}$\n- 处理组比对到spike-in的读数：$S_{t} = 2.0 \\times 10^{6}$\n- 峰A对照组读数：$h_{A,c} = 1000$\n- 峰A处理组读数：$h_{A,t} = 2111$\n- 峰B对照组读数：$h_{B,c} = 500$\n- 峰B处理组读数：$h_{B,t} = 950$\n- 峰C对照组读数：$h_{C,c} = 300$\n- 峰C处理组读数：$h_{C,t} = 1000$\n- 处理使H3K27ac水平全局增加了两倍。\n- 读数比例的定义：$R_{c} = H_{c}/S_{c}$ 和 $R_{t} = H_{t}/S_{t}$。\n- 归一化因子的定义：$f_{t}$ 由条件 $f_{t} R_{t} = R_{c}$ 定义。\n- 归一化处理组峰计数的定义：$h'_{i,t} = f_{t} \\, h_{i,t}$，对于峰 $i \\in \\{A,B,C\\}$。\n- 归一化倍数变化的定义：$\\mathrm{FC}_{i} = h'_{i,t}/h_{i,c}$。\n- 处理组峰计数的零假设期望的定义：$\\lambda_{i} = h_{i,c} \\, (R_{t}/R_{c})$。\n- 统计模型：峰计数被建模为均值为 $\\lambda_{i}$ 的泊松过程。\n- 双边检验的显著性水平：$\\alpha = 0.05$。\n- “假象峰”的定义：一个峰，其观察计数 $h_{i,t}$ 与零假设期望 $\\lambda_i$ 在统计上一致，即双边 $p$ 值大于 $\\alpha$。\n- 最终目标：报告假象峰的比例。\n\n### 第2步：使用提取的已知信息进行验证\n该问题具有科学依据，描述了ChIP-seq数据的标准spike-in归一化程序，这是一种用于解释组蛋白修饰水平全局变化的技术。所有术语都有明确定义，并提供了所有必要的数据。这些数值是自洽的；例如，总读数比例的比值 $(H_t/S_t)/(H_c/S_c) = ((3.8\\times 10^7)/(2.0\\times 10^6))/((3.6\\times 10^7)/(4.0\\times 10^6)) = 19/9 \\approx 2.11$，这与陈述的“两倍”全局增加是一致的。该问题提法得当、客观，并且不违反任何科学或逻辑原则。\n\n### 第3步：结论与行动\n问题有效。将推导解答。\n\n解答过程将执行问题陈述中指定的四个步骤。\n\n**1. 推导处理组的spike-in归一化因子 $f_{t}$。**\n\n首先，我们计算对照组和处理组条件下人类读数与spike-in读数的比例。\n对于对照组：\n$$R_{c} = \\frac{H_{c}}{S_{c}} = \\frac{3.6 \\times 10^{7}}{4.0 \\times 10^{6}} = 9$$\n对于处理组：\n$$R_{t} = \\frac{H_{t}}{S_{t}} = \\frac{3.8 \\times 10^{7}}{2.0 \\times 10^{6}} = 19$$\n归一化因子 $f_{t}$ 由应用后使读数比例相等的条件定义，即 $f_{t} R_{t} = R_{c}$。求解 $f_t$：\n$$f_{t} = \\frac{R_{c}}{R_{t}} = \\frac{9}{19}$$\n\n**2. 计算归一化的处理组峰计数和倍数变化。**\n\n使用推导出的因子 $f_{t} = 9/19$，我们对原始处理组峰计数 $h_{i,t}$ 进行归一化，得到 $h'_{i,t} = f_{t} h_{i,t}$。然后，归一化倍数变化为 $\\mathrm{FC}_{i} = h'_{i,t}/h_{i,c}$。\n\n对于峰A ($h_{A,c}=1000, h_{A,t}=2111$)：\n$$h'_{A,t} = \\frac{9}{19} \\times 2111 = \\frac{18999}{19} \\approx 999.947$$\n$$\\mathrm{FC}_{A} = \\frac{h'_{A,t}}{h_{A,c}} = \\frac{18999/19}{1000} = \\frac{18999}{19000} \\approx 0.99995$$\n\n对于峰B ($h_{B,c}=500, h_{B,t}=950$)：\n$$h'_{B,t} = \\frac{9}{19} \\times 950 = 9 \\times 50 = 450$$\n$$\\mathrm{FC}_{B} = \\frac{h'_{B,t}}{h_{B,c}} = \\frac{450}{500} = 0.9$$\n\n对于峰C ($h_{C,c}=300, h_{C,t}=1000$)：\n$$h'_{C,t} = \\frac{9}{19} \\times 1000 = \\frac{9000}{19} \\approx 473.68$$\n$$\\mathrm{FC}_{C} = \\frac{h'_{C,t}}{h_{C,c}} = \\frac{9000/19}{300} = \\frac{30}{19} \\approx 1.5789$$\n\n**3. 基于统计检验将峰分类为假象峰。**\n\n如果一个峰的观察处理组计数 $h_{i,t}$ 与变化纯粹由全局效应驱动的零假设一致，则该峰被分类为“假象峰”。在此零假设下，期望计数为 $\\lambda_{i} = h_{i,c} \\, (R_{t}/R_{c})$。观察计数 $h_{i,t}$ 被建模为来自均值为 $\\lambda_{i}$ 的泊松分布的抽样，即 $h_{i,t} \\sim \\mathrm{Pois}(\\lambda_{i})$。我们使用双边检验，显著性水平为 $\\alpha = 0.05$。\n\n零模型的比率为 $\\frac{R_{t}}{R_{c}} = \\frac{19}{9}$。\n\n对于峰A：\n- 零假设期望：$\\lambda_{A} = h_{A,c} \\frac{R_{t}}{R_{c}} = 1000 \\times \\frac{19}{9} = \\frac{19000}{9} \\approx 2111.11$。\n- 观察计数：$h_{A,t} = 2111$。\n- 观察计数非常接近期望均值。由于 $\\lambda_{A}$ 很大，我们可以用正态分布 $N(\\mu=\\lambda_{A}, \\sigma^2=\\lambda_{A})$ 来近似泊松分布。标准差为 $\\sigma_{A} = \\sqrt{\\lambda_{A}} \\approx \\sqrt{2111.11} \\approx 45.95$。观测值与均值的偏差 $2111 - 2111.11 = -0.11$，仅为标准差的很小一部分。相应的 $p$ 值将会很大，明显大于 $\\alpha=0.05$。\n- 结论：峰A是假象峰。\n\n对于峰B：\n- 零假设期望：$\\lambda_{B} = h_{B,c} \\frac{R_{t}}{R_{c}} = 500 \\times \\frac{19}{9} = \\frac{9500}{9} \\approx 1055.56$。\n- 观察计数：$h_{B,t} = 950$。\n- 使用正态近似（因为 $\\lambda_{B}$ 很大，所以是合理的），其中 $\\mu_{B} = \\lambda_{B}$ 且 $\\sigma_{B} = \\sqrt{\\lambda_{B}} \\approx \\sqrt{1055.56} \\approx 32.49$。\n- 带连续性校正的检验统计量（z-分数）是：\n  $Z = \\frac{(h_{B,t} + 0.5) - \\lambda_{B}}{\\sigma_{B}} = \\frac{950.5 - 1055.56}{32.49} \\approx \\frac{-105.06}{32.49} \\approx -3.23$。\n- 双边 $p$ 值为 $2 \\times P(Z \\le -3.23)$。该值约等于 $2 \\times 0.00062 = 0.00124$。\n- 由于 $0.00124  0.05$，我们拒绝零假设。\n- 结论：峰B不是假象峰。\n\n对于峰C：\n- 零假设期望：$\\lambda_{C} = h_{C,c} \\frac{R_{t}}{R_{c}} = 300 \\times \\frac{19}{9} = \\frac{1900}{3} \\approx 633.33$。\n- 观察计数：$h_{C,t} = 1000$。\n- 使用正态近似，其中 $\\mu_{C} = \\lambda_{C}$ 且 $\\sigma_{C} = \\sqrt{\\lambda_{C}} \\approx \\sqrt{633.33} \\approx 25.17$。\n- 带连续性校正的检验统计量（z-分数）是：\n  $Z = \\frac{(h_{C,t} - 0.5) - \\lambda_{C}}{\\sigma_{C}} = \\frac{999.5 - 633.33}{25.17} \\approx \\frac{366.17}{25.17} \\approx 14.55$。\n- z-分数非常大。相应的双边 $p$ 值小到可以忽略不计。\n- 由于 $p \\ll 0.05$，我们拒绝零假设。\n- 结论：峰C不是假象峰。\n\n**4. 报告假象峰的比例。**\n\n在分析的三个峰（$\\{A, B, C\\}$）中，只有峰A被分类为假象峰。\n假象峰的数量是 $1$。\n总峰数是 $3$。\n假象峰的比例是 $\\frac{1}{3}$。",
            "answer": "$$\\boxed{\\frac{1}{3}}$$"
        },
        {
            "introduction": "在最大尺度上，染色体组织涉及维持正确的拷贝数，而拷贝数变异（Copy Number Variations, CNVs）是包括癌症在内的许多疾病的标志。这项高级练习将指导您构建一个隐马尔可夫模型（Hidden Markov Model, HMM），用于分析全基因组测序的读数深度数据。您将学习如何通过整合肿瘤纯度和倍性等生物学变量来推断绝对拷贝数，展示了现代基因组诊断中使用的强大计算方法 。",
            "id": "4335375",
            "problem": "给定多个测试用例的分箱全基因组测序（WGS）读数计数以及各分箱的鸟嘌呤-胞嘧啶（GC）偏差因子。假设测序深度与DNA丰度成正比，且读数采样遵循泊松过程。使用隐马尔可夫模型（HMM）将基因组建模为隐藏拷贝数状态的序列，其中发射（emissions）为每个分箱的原始读数计数，而转移（transitions）反映了片段的连续性。整合肿瘤纯度和肿瘤倍性，将观测到的混合覆盖度转换为每个整数肿瘤拷贝数状态的期望均值。\n\n从以下基本依据出发：\n- 测序深度与DNA丰度成正比。对于一个总DNA质量与拷贝数成正比的分箱，其期望读数计数与此丰度成比例缩放。\n- 泊松过程描述了读数采样过程，其概率质量函数为 $P(Y=y \\mid \\mu)=\\frac{\\mu^{y}e^{-\\mu}}{y!}$，其中 $y$ 是观测到的计数值，$\\mu$ 是期望均值。\n- 使用隐马尔可夫模型（HMM）进行分割，该模型包含状态集 $\\mathcal{S}$、转移矩阵 $\\mathbf{A}$ 和初始分布 $\\boldsymbol{\\pi}$，并采用维特比解码来寻找最可能的状态路径。\n\n在肿瘤总拷贝数状态为 $c \\in \\mathcal{S}$ 的情况下，一个分箱的期望读数计数的均值定义如下。设肿瘤纯度为 $p \\in [0,1]$，肿瘤倍性（每个单倍体基因组的全基因组平均肿瘤拷贝数）为 $P  0$，正常拷贝数为 $2$。状态 $c$ 相对于样本全基因组混合基线的期望混合拷贝数比率为\n$$\nR(c;p,P)=\\frac{p\\cdot c + (1-p)\\cdot 2}{p\\cdot P + (1-p)\\cdot 2}.\n$$\n设分箱 $i$ 的GC偏差因子为 $g_i0$，在 $R(c)=1$ 和 $g_i=1$ 的情况下，未知的基线期望计数尺度为 $D_00$。为了从数据中标定 $D_0$，通过GC偏差校正计数值，即 $\\tilde{Y}_i=Y_i/g_i$，并利用二倍体正常的假设来估计\n$$\nD_0 \\approx \\frac{\\mathrm{median}\\left(\\{\\tilde{Y}_i\\}\\right)}{R(2;p,P)}.\n$$\n那么，分箱 $i$ 在状态 $c$ 下的发射均值为\n$$\n\\mu_{i}(c)=D_0 \\cdot R(c;p,P)\\cdot g_i,\n$$\n且发射被建模为 $Y_i \\sim \\mathrm{Poisson}\\!\\left(\\mu_i(c)\\right)$。\n\n构建一个具有以下特性的HMM：\n- 状态空间 $\\mathcal{S}$ 为每个测试用例中指定的候选整数肿瘤总拷贝数集合。\n- 转移矩阵具有高自转移概率 $a_{ss}=\\alpha$ 和均匀变化概率 $a_{s\\neq t}=\\frac{1-\\alpha}{|\\mathcal{S}|-1}$。\n- 初始分布 $\\pi_s=\\frac{1}{|\\mathcal{S}|}$。\n\n使用维特比算法解码每个分箱的最可能拷贝数状态，然后将具有相同解码状态的连续分箱合并为片段。对于每个片段，报告其整数肿瘤绝对拷贝数 $c$。\n\n您的程序必须实现此过程，并为以下测试套件生成结果。下面所有的数组都是有序列表，每个条目都是标量。不需要物理单位；所有量都是无量纲的计数或因子。不涉及角度。最终输出必须是整数和整数列表。\n\n测试套件：\n- 案例A（中等纯度和三倍体肿瘤倍性的一般分割）：\n    - 肿瘤纯度 $p=0.6$，肿瘤倍性 $P=3.0$，状态集 $\\mathcal{S}=\\{0,1,2,3,4,5,6\\}$，自转移参数 $\\alpha=0.995$。\n    - 计数 $Y$: [$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$73$,$81$,$117$,$129$,$117$,$129$,$117$,$51$,$57$,$51$,$57$,$51$]。\n    - GC因子 $g$: [$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$]。\n- 案例B（极低纯度的边界条件，近二倍体混合物）：\n    - 肿瘤纯度 $p=0.05$，肿瘤倍性 $P=2.0$，状态集 $\\mathcal{S}=\\{0,1,2,3,4\\}$，自转移参数 $\\alpha=0.999$。\n    - 计数 $Y$: [$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$,$120$]。\n    - GC因子 $g$: [$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$,$1.0$]。\n- 案例C（高肿瘤纯度和带有局灶性事件的四倍体肿瘤）：\n    - 肿瘤纯度 $p=0.9$，肿瘤倍性 $P=4.0$，状态集 $\\mathcal{S}=\\{0,1,2,3,4,5,6,7,8\\}$，自转移参数 $\\alpha=0.997$。\n    - 计数 $Y$: [$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$135$,$165$,$103$,$126$,$103$,$126$,$103$,$126$,$103$,$126$,$103$,$126$,$71$,$87$,$71$,$87$,$71$,$87$,$7$,$9$]。\n    - GC因子 $g$: [$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$,$0.9$,$1.1$]。\n- 案例D（包含零拷贝片段和混合事件的边缘案例）：\n    - 肿瘤纯度 $p=0.8$，肿瘤倍性 $P=2.5$，状态集 $\\mathcal{S}=\\{0,1,2,3,4,5,6\\}$，自转移参数 $\\alpha=0.995$。\n    - 计数 $Y$: [$63$,$70$,$63$,$70$,$63$,$70$,$63$,$70$,$63$,$70$,$0$,$14$,$13$,$0$,$14$,$13$,$0$,$14$,$13$,$0$,$139$,$154$,$139$,$154$,$139$,$154$,$139$,$154$,$139$,$154$]。\n    - GC因子 $g$: [$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$1.0$,$1.05$,$0.95$,$1.0$,$1.05$,$0.95$,$1.0$,$1.05$,$0.95$,$1.0$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$,$0.95$,$1.05$]。\n\n算法要求：\n- 使用对数概率实现维特比解码，以避免数值下溢。使用上面定义的转移模型和均匀的初始对数概率。\n- 使用上面给出的 $D_0$ 校准方法。\n- 对均值为 $\\mu_i(c)$ 的发射使用泊松对数似然。\n- 将连续相同的解码状态合并为片段，并以整数形式输出每个片段的肿瘤绝对拷贝数。\n\n答案格式：\n- 对于每个案例，按顺序输出推断出的片段级肿瘤绝对拷贝数列表。将四个案例的结果汇总到单行中，打印为一个用方括号括起来的逗号分隔列表，不含空格，其中每个案例的结果本身也是一个用方括号括起来的逗号分隔列表。例如：$[\\,[2,2,4,1],[2],\\ldots\\,]$，但不含空格。",
            "solution": "用户在癌症基因组学领域提供了一个定义明确的计算问题。任务是实现一个隐马尔可夫模型（HMM），从分箱的全基因组测序（WGS）读数计数数据中推断DNA拷贝数片段。问题陈述已经过验证，被认为是科学上合理、完整且定义良好的。所有参数、模型和数据均已提供，可以直接、明确地进行实现。\n\n解决方案首先根据提供的规范将HMM组件形式化，然后应用维特比算法解码最可能的隐藏拷贝数状态序列。该模型的核心在于其能够将观察到的、带有噪声的读数计数转换为潜在拷贝数状态的概率，这一过程由一个统计模型控制，该模型考虑了肿瘤纯度、肿瘤倍性以及GC含量等技术偏差。\n\n**1. HMM框架与参数化**\n\n一个HMM由其状态空间 $\\mathcal{S}$、转移概率 $\\mathbf{A}$、发射概率和初始状态分布 $\\boldsymbol{\\pi}$ 定义。\n\n-   **状态空间 ($\\mathcal{S}$)**：隐藏状态是每个测试用例提供的整数肿瘤总拷贝数。设 $|\\mathcal{S}|$ 为状态数。\n\n-   **初始分布 ($\\boldsymbol{\\pi}$)**：指定了均匀的初始分布，意味着在第一个位置，任何状态都是等可能的。对于每个状态 $s \\in \\mathcal{S}$，初始概率为 $\\pi_s = 1/|\\mathcal{S}|$。在对数空间中，即为 $\\log(\\pi_s) = -\\log(|\\mathcal{S}|)$。\n\n-   **转移矩阵 ($\\mathbf{A}$)**：该矩阵模拟了片段连续性的假设。不同状态之间的转移很少见，而自转移很常见。概率由以下公式给出：\n    -   自转移：$a_{ss} = \\alpha$\n    -   状态改变：$a_{s \\neq t} = \\frac{1-\\alpha}{|\\mathcal{S}|-1}$\n    这些将被转换为对数概率：$\\log(a_{ss}) = \\log(\\alpha)$ 和 $\\log(a_{s \\neq t}) = \\log(1-\\alpha) - \\log(|\\mathcal{S}|-1)$。\n\n-   **发射概率**：在给定隐藏拷贝数状态 $c$ 的情况下，在分箱 $i$ 中观测到读数计数 $Y_i$ 的概率由泊松分布建模，$Y_i \\sim \\mathrm{Poisson}(\\mu_i(c))$。其对数概率质量函数为 $\\log(P(Y_i=y | \\mu_i(c))) = y \\log(\\mu_i(c)) - \\mu_i(c) - \\log(y!)$。项 $\\log(y!)$ 可以使用 `scipy.special.gammaln(y+1)` 计算。`scipy.stats.poisson.logpmf` 直接提供了这个功能。\n\n**2. 泊松均值 ($\\mu_i(c)$) 的计算**\n\n分箱 $i$ 和状态 $c$ 的泊松分布的期望均值 $\\mu_i(c)$ 整合了几个生物学和技术因素：\n\n1.  **混合比率 ($R(c;p,P)$)**：肿瘤样本是肿瘤细胞（纯度 $p$，倍性 $P$）和正常二倍体细胞（纯度 $1-p$，倍性 $2$）的混合物。拷贝数为 $c$ 的肿瘤区域的期望相对DNA丰度为：\n    $$\n    R(c;p,P) = \\frac{p \\cdot c + (1-p) \\cdot 2}{p \\cdot P + (1-p) \\cdot 2}\n    $$\n    该比率将特定状态的拷贝数归一化到样本每个细胞的平均DNA含量。\n\n2.  **基线深度校准 ($D_0$)**：总测序深度是一个未知的缩放因子。它使用提供的公式进行校准，该公式将估计锚定到理论上的二倍体状态（$c=2$）。首先，对读数计数进行GC偏差校正（$g_i$）：$\\tilde{Y}_i=Y_i/g_i$。然后，$D_0$ 估计为：\n    $$\n    D_0 \\approx \\frac{\\mathrm{median}(\\{\\tilde{Y}_i\\})}{R(2;p,P)}\n    $$\n    中位数提供了对典型读数计数水平的稳健估计，该公式假设该水平对应于二倍体状态的期望比率。\n\n3.  **最终发射均值**：分箱 $i$ 在状态 $c$ 下的均值是基线深度、状态特异性混合比率和分箱特异性GC偏差因子的乘积：\n    $$\n    \\mu_{i}(c) = D_0 \\cdot R(c;p,P) \\cdot g_i\n    $$\n\n**3. 维特比解码算法**\n\n为了找到最可能的隐藏状态（拷贝数）序列，我们使用维特比算法，该算法在对数空间中实现以防止数值下溢。\n\n-   **初始化（分箱 $i=0$）**：维特比矩阵 $V$ 存储了在给定状态和位置结束的任何路径的最大对数概率。对于第一个分箱，对于每个状态 $s_j \\in \\mathcal{S}$（对应拷贝数为 $c_j$）：\n    $$\n    V_{j,0} = \\log(\\pi_j) + \\log(P(Y_0 | \\mu_0(c_j)))\n    $$\n    同时也初始化一个回溯指针矩阵 $B$。\n\n-   **递归（分箱 $i = 1, \\dots, N-1$）**：对于每个后续的分箱 $i$ 和每个状态 $s_j$：\n    $$\n    V_{j,i} = \\log(P(Y_i | \\mu_i(c_j))) + \\max_{k \\in \\{1,\\dots,|\\mathcal{S}|\\}} \\left( V_{k, i-1} + \\log(a_{k,j}) \\right)\n    $$\n    此条目的回溯指针存储了达到最大值的索引 $k$：\n    $$\n    B_{j,i} = \\arg\\max_{k \\in \\{1,\\dots,|\\mathcal{S}|\\}} \\left( V_{k, i-1} + \\log(a_{k,j}) \\right)\n    $$\n\n-   **终止与回溯**：通过在 $V$ 的最后一列上取最大值来找到最可能的最终状态。然后，从这个最终状态开始，向后追溯回溯指针矩阵 $B$，以重建整个最可能的状态路径。\n\n**4. 分割**\n\n解码的路径是每个分箱的拷贝数状态序列。最后一步是将具有相同解码拷贝数的连续分箱合并为单个片段，并报告该片段共享的拷贝数。最终输出是这些片段级拷贝数的有序列表。实现将通过此流程处理每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        {\n            \"id\": \"A\",\n            \"p\": 0.6, \"P\": 3.0, \"S\": [0, 1, 2, 3, 4, 5, 6], \"alpha\": 0.995,\n            \"Y\": [73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 73, 81, 117, 129, 117, 129, 117, 51, 57, 51, 57, 51],\n            \"g\": [0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 0.95, 1.05, 0.95, 1.05, 0.95]\n        },\n        {\n            \"id\": \"B\",\n            \"p\": 0.05, \"P\": 2.0, \"S\": [0, 1, 2, 3, 4], \"alpha\": 0.999,\n            \"Y\": [120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120, 120],\n            \"g\": [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]\n        },\n        {\n            \"id\": \"C\",\n            \"p\": 0.9, \"P\": 4.0, \"S\": [0, 1, 2, 3, 4, 5, 6, 7, 8], \"alpha\": 0.997,\n            \"Y\": [135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 135, 165, 103, 126, 103, 126, 103, 126, 103, 126, 103, 126, 71, 87, 71, 87, 71, 87, 7, 9],\n            \"g\": [0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1, 0.9, 1.1]\n        },\n        {\n            \"id\": \"D\",\n            \"p\": 0.8, \"P\": 2.5, \"S\": [0, 1, 2, 3, 4, 5, 6], \"alpha\": 0.995,\n            \"Y\": [63, 70, 63, 70, 63, 70, 63, 70, 63, 70, 0, 14, 13, 0, 14, 13, 0, 14, 13, 0, 139, 154, 139, 154, 139, 154, 139, 154, 139, 154],\n            \"g\": [0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 1.0, 1.05, 0.95, 1.0, 1.05, 0.95, 1.0, 1.05, 0.95, 1.0, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05, 0.95, 1.05]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        segments = perform_viterbi_segmentation(\n            p=case[\"p\"], P=case[\"P\"], S=case[\"S\"],\n            alpha=case[\"alpha\"], Y=case[\"Y\"], g=case[\"g\"]\n        )\n        results.append(f\"[{','.join(map(str, segments))}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef perform_viterbi_segmentation(p, P, S, alpha, Y, g):\n    \"\"\"\n    Solves a single test case for CNV segmentation using an HMM.\n    \"\"\"\n    # Convert inputs to numpy arrays for vectorized operations\n    S = np.array(S, dtype=int)\n    Y = np.array(Y, dtype=int)\n    g = np.array(g, dtype=float)\n    \n    num_states = len(S)\n    num_bins = len(Y)\n    \n    # 1. Model Parameter Calculation\n    mixture_baseline = p * P + (1 - p) * 2.0\n    r_numerators = p * S + (1 - p) * 2.0\n    R_c = r_numerators / mixture_baseline\n    \n    Y_corr = Y / g\n    \n    idx_c2 = np.where(S == 2)[0][0]\n    R_c2 = R_c[idx_c2]\n    \n    D_0 = np.median(Y_corr) / R_c2\n    \n    mu_ic = D_0 * R_c[:, np.newaxis] * g[np.newaxis, :]\n    \n    log_alpha = np.log(alpha)\n    if num_states  1:\n        log_beta = np.log((1 - alpha) / (num_states - 1))\n    else:\n        log_beta = -np.inf # Not encountered in test cases\n\n    log_A = np.full((num_states, num_states), log_beta)\n    np.fill_diagonal(log_A, log_alpha)\n    \n    log_pi = np.full(num_states, -np.log(num_states))\n    \n    # 2. Viterbi Algorithm\n    viterbi_matrix = np.zeros((num_states, num_bins))\n    backpointer_matrix = np.zeros((num_states, num_bins), dtype=int)\n    \n    log_emission_probs_0 = poisson.logpmf(Y[0], mu_ic[:, 0])\n    viterbi_matrix[:, 0] = log_pi + log_emission_probs_0\n    \n    for i in range(1, num_bins):\n        log_emission_probs_i = poisson.logpmf(Y[i], mu_ic[:, i])\n        \n        for j in range(num_states):\n            state_scores = viterbi_matrix[:, i-1] + log_A[:, j]\n            best_prev_state = np.argmax(state_scores)\n            max_log_prob = state_scores[best_prev_state]\n            \n            viterbi_matrix[j, i] = max_log_prob + log_emission_probs_i[j]\n            backpointer_matrix[j, i] = best_prev_state\n\n    # 3. Backtracking\n    path = np.zeros(num_bins, dtype=int)\n    if num_bins  0:\n        path[num_bins - 1] = np.argmax(viterbi_matrix[:, num_bins - 1])\n        for i in range(num_bins - 2, -1, -1):\n            path[i] = backpointer_matrix[path[i+1], i+1]\n    \n    cn_path = S[path]\n    \n    # 4. Collapse Segments\n    if num_bins == 0:\n        return []\n        \n    segments = [cn_path[0]]\n    for i in range(1, num_bins):\n        if cn_path[i] != segments[-1]:\n            segments.append(cn_path[i])\n            \n    return segments\n\nsolve()\n```"
        }
    ]
}