{
    "hands_on_practices": [
        {
            "introduction": "在生物信息学中，一个常见且极易出错的任务是在不同坐标系统之间转换基因组区间。本练习将引导您处理从1基、闭区间（NCBI风格）到0基、半开区间（UCSC BED格式）的转换，同时还要考虑基因组版本间的“坐标提升”（liftover）。通过精确计算并验证转换前后区间长度的不变性，您将掌握确保数据在不同工具和数据库（如NCBI、EBI、UCSC基因组浏览器）之间保持一致性的核心技能。",
            "id": "4318980",
            "problem": "一位从事精准医疗的研究人员需要跨基因组组装版本和文件格式协调基因组区间数据，以便与美国国家生物技术信息中心 (NCBI)、欧洲生物信息学研究所 (EBI)、GenBank、参考序列 (RefSeq) 以及单核苷酸多态性数据库 (dbSNP) 进行下游整合。从参考序列 (RefSeq) 中检索了人类基因组参考联盟第37版 (GRCh37) 上的一个临床相关基因的三个外显子区间。这些区间采用美国国家生物技术信息中心 (NCBI) 的风格，其坐标是 $1$ 基、闭区间。在染色体 $7$ 上的这些区间是：\n- 区域 $1$：起始 $s_{1} = 55321114$，终止 $e_{1} = 55321333$。\n- 区域 $2$：起始 $s_{2} = 55322001$，终止 $e_{2} = 55322231$。\n- 区域 $3$：起始 $s_{3} = 55323900$，终止 $e_{3} = 55323985$。\n\n针对该基因座的基于链式比对的组装版本转换表明，在包含所有三个区间的局部共线性区块内，到人类基因组参考联盟第38版 (GRCh38) 的映射是正链上的一个线性偏移：对于 GRCh37 中的任意位置 $x$，其在 GRCh38 中相应的位置是 $x' = x + \\Delta$，其中 $\\Delta = 413$，并且在这三个区间中的任何一个内部都没有间隙。\n\n这些数据必须被转换为浏览器可扩展数据 (BED) 格式，以用于加州大学圣克鲁兹分校 (UCSC) 基因组浏览器，该格式使用 $0$ 基、半开区间的约定。仅使用坐标系统的基本定义（即 $1$ 基、闭区间与 $0$ 基、半开区间坐标的含义）和给定的线性偏移，完成以下任务：\n1. 计算每个区域 $i \\in \\{1,2,3\\}$ 经过边界校正的 GRCh38 BED 坐标 $(s'_{i}, e'_{i})$。\n2. 计算转换前的总长度 $$L_{\\mathrm{pre}} = \\sum_{i=1}^{3}\\left(e_{i} - s_{i} + 1\\right)。$$\n3. 计算 BED 约定下的转换后总长度 $$L_{\\mathrm{post}} = \\sum_{i=1}^{3}\\left(e'_{i} - s'_{i}\\right)。$$\n4. 通过计算 $L_{\\mathrm{post}} - L_{\\mathrm{pre}}$ 来验证等式是否成立，并在假设等式成立的情况下，报告共同的总长度。\n\n以碱基对 (bp) 为单位表示最终的总长度。无需四舍五入；请提供精确的整数值。您最终报告的量必须是单个实数。",
            "solution": "该问题要求将基因组区间坐标从 GRCh37 组装版本转换为 GRCh38 组装版本，并同时从 NCBI 的 $1$ 基、闭区间坐标系统转换为浏览器可扩展数据 (BED) 格式的 $0$ 基、半开区间系统。然后，我们必须计算转换前后区间的总长度，并验证长度是否守恒。\n\n首先，我们建立转换规则。在 $1$ 基、闭区间系统中，一个区间表示为 $[s, e]$，代表从位置 $s$ 到位置 $e$（包含两者）的碱基集合。这种区间的长度计算为 $L = e - s + 1$。在 $0$ 基、半开区间系统中，一个区间表示为 $[s', e')$，代表从位置 $s'$ 到但不包括位置 $e'$ 的碱基集合。这种区间的长度是 $L' = e' - s'$。\n\n转换包括两个独立的变换：\n1.  从 GRCh37 到 GRCh38 的组装版本转换（liftover），这是一个给定的线性偏移 $\\Delta = 413$。GRCh37 中的一个位置 $x$ 对应于 GRCh38 中的位置 $x' = x + \\Delta$。\n2.  从 $1$ 基、闭区间到 $0$ 基、半开区间的坐标系统变更。\n\n让我们推导在单个组装版本上进行坐标系统变更的公式。对于一个 $1$ 基、闭区间 $[S, E]$，第一个物理碱基位于位置 $S$，最后一个位于位置 $E$。在 $0$ 基系统中，位置为 $k$ 的碱基的索引是 $k-1$。因此，该区间中的碱基对应的索引为 $\\{S-1, S, \\dots, E-1\\}$。一个 $0$ 基、半开区间 $[S_0, E_0)$ 必须从第一个碱基的索引开始，所以 $S_0 = S-1$。它必须在最后一个碱基索引之后的一个位置结束，所以 $E_0 = (E-1) + 1 = E$。转换规则是 $[S, E] \\rightarrow [S-1, E)$。\n\n将这两个变换结合起来，应用于 GRCh37 上的初始区间 $[s_i, e_i]$：\n首先，应用版本转换的偏移量 $\\Delta = 413$。在 GRCh38 坐标中，该区间仍然是 $1$ 基、闭区间，为 $[s_i + \\Delta, e_i + \\Delta]$。\n其次，应用坐标系统变更。设 $S = s_i + \\Delta$ 和 $E = e_i + \\Delta$。最终的 $0$ 基、半开区间坐标 $(s'_i, e'_i)$ 由以下公式给出：\n$$s'_i = S - 1 = s_i + \\Delta - 1$$\n$$e'_i = E = e_i + \\Delta$$\n\n现在我们执行指定的任务。\n\n1. 计算每个区域 $i \\in \\{1,2,3\\}$ 经过边界校正的 GRCh38 BED 坐标 $(s'_{i}, e'_{i})$。\n给定的偏移量是 $\\Delta = 413$。\n\n对于区域 $1$：$s_1 = 55321114$, $e_1 = 55321333$。\n$s'_1 = s_1 + \\Delta - 1 = 55321114 + 413 - 1 = 55321526$。\n$e'_1 = e_1 + \\Delta = 55321333 + 413 = 55321746$。\nGRCh38 BED 坐标为 $(s'_{1}, e'_{1}) = (55321526, 55321746)$。\n\n对于区域 $2$：$s_2 = 55322001$, $e_2 = 55322231$。\n$s'_2 = s_2 + \\Delta - 1 = 55322001 + 413 - 1 = 55322413$。\n$e'_2 = e_2 + \\Delta = 55322231 + 413 = 55322644$。\nGRCh38 BED 坐标为 $(s'_{2}, e'_{2}) = (55322413, 55322644)$。\n\n对于区域 $3$：$s_3 = 55323900$, $e_3 = 55323985$。\n$s'_3 = s_3 + \\Delta - 1 = 55323900 + 413 - 1 = 55324312$。\n$e'_3 = e_3 + \\Delta = 55323985 + 413 = 55324398$。\nGRCh38 BED 坐标为 $(s'_{3}, e'_{3}) = (55324312, 55324398)$。\n\n2. 计算转换前的总长度 $L_{\\mathrm{pre}}$。\n每个初始区间的长度为 $L_i = e_i - s_i + 1$。\n$L_1 = 55321333 - 55321114 + 1 = 219 + 1 = 220$ bp。\n$L_2 = 55322231 - 55322001 + 1 = 230 + 1 = 231$ bp。\n$L_3 = 55323985 - 55323900 + 1 = 85 + 1 = 86$ bp。\n转换前的总长度为：\n$$L_{\\mathrm{pre}} = \\sum_{i=1}^{3} L_i = 220 + 231 + 86 = 537 \\text{ bp}。$$\n\n3. 计算转换后的总长度 $L_{\\mathrm{post}}$。\n每个转换后区间的长度为 $L'_i = e'_i - s'_i$。\n$L'_1 = 55321746 - 55321526 = 220$ bp。\n$L'_2 = 55322644 - 55322413 = 231$ bp。\n$L'_3 = 55324398 - 55324312 = 86$ bp。\n转换后的总长度为：\n$$L_{\\mathrm{post}} = \\sum_{i=1}^{3} L'_i = 220 + 231 + 86 = 537 \\text{ bp}。$$\n\n4. 验证等式是否成立并报告共同的总长度。\n总长度之间的差为 $L_{\\mathrm{post}} - L_{\\mathrm{pre}} = 537 - 537 = 0$。\n等式成立，正如预期。这可以通过解析方式证明：转换后区间的长度为 $L'_i = e'_i - s'_i = (e_i + \\Delta) - (s_i + \\Delta - 1) = e_i - s_i + 1 = L_i$。因此，在这种特定转换下，长度是不变的。\n\n三个外显子区间的共同总长度为 $537$ 碱基对。",
            "answer": "$$\n\\boxed{537}\n$$"
        },
        {
            "introduction": "基因变异通常使用相对于转录本编码序列（CDS）的HGVS命名法（例如，$c.50\\text{G}>\\text{A}$）来描述。然而，为了在基因组浏览器中可视化或与其他基因组数据整合，我们必须将其精确定位到染色体的绝对坐标上。本练习要求您根据一个假设基因的外显子结构，将一系列HGVS $c.$ 变异映射到其基因组位置，这是在临床基因组学中连接测序结果与参考基因组注释的关键一步。",
            "id": "4319011",
            "problem": "一个临床测序实验室正在验证其内部转换逻辑，该逻辑用于将人类基因组变异协会 (HGVS) 的编码DNA ($c.$) 变异描述映射到基因组参考联盟人类第38版 (GRCh38) 上的绝对基因组碱基位置。目标基因有一个经过审编的单一参考序列 (RefSeq) 转录本，其美国国家生物技术信息中心 (NCBI) RefSeq 登录号为 $NM\\_999999.1$，并被注释在 $12$ 号染色体的正链上。欧洲生物信息学研究所 (EBI) 的基因组浏览器和 GenBank 证实了该转录本在 GRCh38 上的以下外显子区间，坐标以1为基准、包含两端的闭区间形式报告：\n\n- 外显子 $1$：起始于 $100{,}000{,}101$，终止于 $100{,}000{,}300$。\n- 外显子 $2$：起始于 $100{,}010{,}001$，终止于 $100{,}010{,}150$。\n- 外显子 $3$：起始于 $100{,}020{,}501$，终止于 $100{,}021{,}000$。\n\n编码序列的起始位置 ($c.1$，即起始密码子中腺嘌呤的第一个碱基) 位于外显子 $1$ 中，基因组坐标为 $100{,}000{,}110$。单核苷酸多态性数据库 (dbSNP) 列出了该基因的多个临床相关变异，实验室希望计算其中以下相对于 $NM\\_999999.1$ 的 HGVS $c.$ 变异的绝对基因组位置：\n\n- $c.50\\text{G}>\\text{A}$，\n- $c.200\\text{C}>\\text{T}$，\n- $c.341+5\\text{G}>\\text{T}$，\n- $c.342-3\\text{A}>\\text{G}$。\n\n使用转录本剪接和 HGVS $c.$ 命名法的基础定义，推导出一个将正链转录本的 $c.$ 坐标映射到基因组坐标的通用方法，然后将其应用于所提供的特定外显子结构和编码起始位置，以计算这四个变异的绝对 GRCh38 碱基位置。您可以假设 $NM\\_999999.1$ 采用经典剪接，没有可变外显子，并且如上所述，$c.1$ 是第一个编码碱基，恰好位于外显子 $1$ 内的第 $10$ 个碱基处。将这四个基因组碱基位置报告为 GRCh38 上的整数，按升序排序，并以单行矩阵的形式呈现。无需四舍五入。最终答案仅以坐标的行矩阵形式表示，不带单位。",
            "solution": "该问题要求将人类基因组变异协会（HGVS）的编码DNA（`$c.$`）坐标映射到GRCh38基因组的绝对位置。对于位于正链上的基因，此过程涉及将外显子的编码部分拼接成一个连续的坐标系统，然后将目标c.位置映射回其基因组坐标。\n\n首先，我们确定转录本`$NM\\_999999.1$`的编码部分的特征。给定的外显子坐标是1基准且包含两端的：\n- 外显子 1：起始 `$S_1 = 100{,}000{,}101$`，终止 `$F_1 = 100{,}000{,}300$`\n- 外显子 2：起始 `$S_2 = 100{,}010{,}001$`，终止 `$F_2 = 100{,}010{,}150$`\n- 外显子 3：起始 `$S_3 = 100{,}020{,}501$`，终止 `$F_3 = 100{,}021{,}000$`\n\n编码序列起始位置 `$c.1$` 位于基因组坐标 `$C_{start} = 100{,}000{,}110$`。\n\n现在我们确定每个外显子内的编码序列长度和 `$c.$` 坐标范围。\n\n1.  **外显子 1 分析：**\n    外显子 $1$ 中的编码序列起始于 `$C_{start}`，终止于外显子末端 `$F_1$`。\n    外显子 $1$ 编码部分的长度为 `$L_{c1} = F_1 - C_{start} + 1 = 100{,}000{,}300 - 100{,}000{,}110 + 1 = 191$` 个碱基。\n    因此，外显子 $1$ 包含从 `$c.1$` 到 `$c.191$` 的编码位置。\n\n2.  **外显子 2 分析：**\n    外显子 $2$ 完全是编码区。其长度为 `$L_{c2} = F_2 - S_2 + 1 = 100{,}010{,}150 - 100{,}010{,}001 + 1 = 150$` 个碱基。\n    外显子 $2$ 中的第一个 `$c.$` 位置是 `$191 + 1 = 192$`，最后一个 `$c.$` 位置是 `$191 + 150 = 341$`。\n    因此，外显子 $2$ 包含从 `$c.192$` 到 `$c.341$` 的编码位置。\n\n3.  **外显子 3 分析：**\n    外显子 $3$ 的编码序列在外显子 $2$ 之后开始。第一个 `$c.$` 位置是 `$341 + 1 = 342$`，对应基因组位置 `$S_3$`。\n\n这建立了以下映射关系：\n- 外显子 $1$：`$c.1$` 到 `$c.191$` 对应于基因组位置 `[$100{,}000{,}110, 100{,}000{,}300$]`。\n- 外显子 $2$：`$c.192$` 到 `$c.341$` 对应于基因组位置 `[$100{,}010{,}001, 100{,}010{,}150$]`。\n- 外显子 $3$：`$c.342$` 开始，对应基因组位置 `$100{,}020{,}501$`。\n\n现在，我们可以计算每个指定变异的基因组位置。\n\n**变异 1：`$c.50\\text{G}>\\text{A}$`**\n位置 `$c.50$` 落在外显子 $1$ 的范围内。基因组坐标通过计算与编码序列起点的偏移量得到。\n基因组位置 = `$C_{start} + (\\text{c.position} - 1) = 100{,}000{,}110 + (50 - 1) = 100{,}000{,}159$`。\n\n**变异 2：`$c.200\\text{C}>\\text{T}$`**\n位置 `$c.200$` 落在外显子 $2$ 的范围内。与外显子 $2$ 编码序列起点（`$c.192$`，基因组位置 `$S_2$`）的偏移量为 `$200 - 192 = 8$` 个碱基。\n基因组位置 = `$S_2 + \\text{offset} = 100{,}010{,}001 + 8 = 100{,}010{,}009$`。\n\n**变异 3：`$c.341+5\\text{G}>\\text{T}$`**\n这是一个内含子变异。位置 `$c.341$` 是外显子 $2$ 的最后一个编码碱基，其基因组位置是 `$F_2 = 100{,}010{,}150$`。`$+5$` 表示位于下游内含子中 $5$ 个碱基的位置。\n基因组位置 = `$F_2 + 5 = 100{,}010{,}150 + 5 = 100{,}010{,}155$`。\n\n**变异 4：`$c.342-3\\text{A}>\\text{G}$`**\n这也是一个内含子变异。位置 `$c.342$` 是外显子 $3$ 的第一个编码碱基，其基因组位置是 `$S_3 = 100{,}020{,}501$`。`$-3$` 表示位于上游内含子中 $3$ 个碱基的位置。\n基因组位置 = `$S_3 - 3 = 100{,}020{,}501 - 3 = 100{,}020{,}498$`。\n\n计算得出的四个在 `$GRCh38$` 上的绝对基因组位置按升序排列为：\n1. `$100{,}000{,}159$`\n2. `$100{,}010{,}009$`\n3. `$100{,}010{,}155$`\n4. `$100{,}020{,}498$`\n\n最终结果是这四个整数坐标的有序列表。",
            "answer": "$$\\boxed{\\begin{pmatrix} 100000159  100010009  100010155  100020498 \\end{pmatrix}}$$"
        },
        {
            "introduction": "在精准医疗的实际应用中，基因变异数据往往来源多样，其标识符格式也五花八门，例如dbSNP的rsID、不同的HGVS表达形式（`g.` 或 `c.`）以及SPDI格式。为了进行统一的分析和解读，必须将这些异构的标识符解析并转换为一种规范的、可计算的格式。本练习模拟了构建一个生物信息学工具的过程，该工具能够处理这些复杂的输入，并根据一组明确的规则（包括处理正负链转录本）将其标准化，这是构建稳健的自动化基因诊断流程的基石。",
            "id": "4319014",
            "problem": "您需要实现一个完整的、可运行的程序，该程序将异构的基因组变异标识符标准化为统一的、适用于精准医疗管理的规范参考上下文。该程序不得使用任何外部数据源；相反，它必须在一个自包含的、明确定义的小型知识库上运行，并遵循基于标准基因组学表示的、形式化的确定性规则。此场景反映了在基因组诊断流程中，来自美国国家生物技术信息中心 (NCBI)、欧洲生物信息学研究所 (EBI)、GenBank、参考序列 (RefSeq) 和单核苷酸多态性数据库 (dbSNP) 的标识符是如何被协调统一的。\n\n规范参考上下文定义为一个四元组 $\\langle R, p, d, i \\rangle$：\n- $R$ 是基因组参考登录号根（去除版本号）的整数代码，唯一代表规范参考序列。\n- $p$ 是变异锚定的零基基因组坐标。\n- $d$ 是删除序列的整数编码。\n- $i$ 是插入序列的整数编码。\n\n程序必须接受并标准化以下形式的混合输入：\n- 来自单核苷酸多态性数据库 (dbSNP) 的参考单核苷酸多态性簇标识符 (rsID)，例如 “rs…”。\n- 人类基因组变异协会 (HGVS) 在基因组水平 (“g.”) 或编码 DNA 水平 (“c.”) 的表达式，例如 “NC_000019.10:g.1101G>A” 或 “NM_000001.2:c.201G>A”。\n- 替换-位置-删除-插入 (SPDI)，例如 “NC_000019.10:1100:G:A”。\n- 单独的 RefSeq Accession.version (无变异)，例如 “NC_000017.11”。\n\n您的任务是严格根据以下基本依据和事实来实现标准化规则：\n- 分子生物学中心法则：脱氧核糖核酸 (DNA) 转录为核糖核酸 (RNA)，再翻译为蛋白质；RefSeq 转录本根据基因转录方向进行定向，可以位于基因组正链或负链上。\n- 坐标系统：在基因组 HGVS 水平上，基因组位点可以用一基坐标表示，而在 SPDI 中则使用零基坐标。\n- 带版本的登录号（例如 “NC_000019.10”）共享一个无版本的根（例如 “NC_000019”），该根用作规范参考键。在本练习中，假定给定根的所有版本都具有相同的坐标系统。\n- 负链映射的反向互补：如果转录本位于基因组负链上，则必须对来自转录本的碱基进行反向互补，以推导出相应的基因组等位基因。\n\n规范参考上下文详情：\n- 参考登录号根到整数代码的映射：\n  - $R(\\text{\"NC\\_000019\"}) = 19$\n  - $R(\\text{\"NC\\_000017\"}) = 17$\n- 对于字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 上的脱氧核糖核酸 (DNA) 字符串 $s$，基于终止符的 $5$ 进制整数编码 $E(s)$ 定义如下。设数字映射为 $\\text{A} \\mapsto 1$, $\\text{C} \\mapsto 2$, $\\text{G} \\mapsto 3$, $\\text{T} \\mapsto 4$，并在末尾附加一个数字为 $0$ 的终止符。那么\n$$\nE(s) = \\sum_{k=0}^{L} d_k \\cdot 5^k,\n$$\n其中 $s$ 的长度为 $L$，$d_k$ 是第 $k$ 个字符的数字（对于 $k \\in \\{0,\\dots,L-1\\}$），$d_L = 0$ 是终止符。根据此构造，$E(\\text{\"\"}) = 0$，且不同的序列会产生不同的整数。\n- 反向互补按碱基计算，通过 $\\mathrm{rc}(\\text{A})=\\text{T}$, $\\mathrm{rc}(\\text{T})=\\text{A}$, $\\mathrm{rc}(\\text{C})=\\text{G}$, $\\mathrm{rc}(\\text{G})=\\text{C}$；对于字符串，则反转字符串并对每个碱基进行互补。\n\n经过整理的自包含知识库：\n- 规范基因组参考仅限于根为 “NC_000019” 和 “NC_000017” 的登录号。在本练习中，每个根的所有版本都被视为坐标相同。\n- rsID 到基因组的映射（此表中所有坐标均为零基）：\n  - $\\text{rs1000001} \\mapsto (\\text{\"NC\\_000019.10\"}, p=1100, \\text{ref}=\\text{\"G\"}, \\text{alt}=\\text{\"A\"})$\n  - $\\text{rs2000002} \\mapsto (\\text{\"NC\\_000017.11\"}, p=1800, \\text{ref}=\\text{\"A\"}, \\text{alt}=\\text{\"T\"})$\n  - $\\text{rs3000003} \\mapsto (\\text{\"NC\\_000017.11\"}, p=500, \\text{ref}=\\text{\"TA\"}, \\text{alt}=\\text{\"\"})$\n- 转录本到基因组的映射（线性、单片段模型；所有范围均为闭区间）：\n  - $\\text{\"NM\\_000001.2\"}$：基因组参考 $\\text{\"NC\\_000019.10\"}$，正链，编码范围 $c \\in [1,10000]$ 映射到基因组范围 $g \\in [901,10900]$，关系式为 $g = 900 + c$。\n  - $\\text{\"NM\\_000002.1\"}$：基因组参考 $\\text{\"NC\\_000017.11\"}$，负链，编码范围 $c \\in [1,1000]$ 映射到基因组范围 $g \\in [901,1900]$，关系式为 $g = 1900 - (c - 1)$。\n\n标准化规则：\n1. 对于 rsID 输入，从整理好的表格中获取 $(\\text{acc.version}, p, \\text{ref}, \\text{alt})$；从登录号中去除版本号以获得其根，使用表格将根转换为 $R$，并生成 $\\langle R, p, E(\\text{ref}), E(\\text{alt}) \\rangle$。\n2. 对于 HGVS 基因组输入 “acc.version:g.PREF>ALT”，解析一基坐标 $P$ 和等位基因 $\\text{REF}$ 与 $\\text{ALT}$，然后计算 $p=P-1$，去除版本号得到根，获取 $R$，并生成 $\\langle R, p, E(\\text{REF}), E(\\text{ALT}) \\rangle$。\n3. 对于 HGVS 编码输入 “tx.version:c.CREF>ALT”，解析一基坐标 $C$、转录本 $tx.version$ 以及转录本上的等位基因。使用转录本的映射关系计算基因组的一基坐标 $G$ 如下：\n   - 正链：$G = g_{\\text{start}} + (C - 1)$。\n   - 负链：$G = g_{\\text{end}} - (C - 1)$。\n   然后 $p = G - 1$。设 $(\\text{REF}, \\text{ALT})$ 为基因组等位基因：\n   - 正链：$(\\text{REF}, \\text{ALT}) = (\\text{CREF}, \\text{CALT})$。\n   - 负链：$(\\text{REF}, \\text{ALT}) = (\\mathrm{rc}(\\text{CREF}), \\mathrm{rc}(\\text{CALT}))$。\n   将转录本关联的基因组登录号去除版本号得到其根，并映射到 $R$。输出 $\\langle R, p, E(\\text{REF}), E(\\text{ALT}) \\rangle$。\n4. 对于 SPDI “acc.version:pos:del:ins”，直接使用给定的 $p=\\text{pos}$（零基），将 $(\\text{del},\\text{ins})$ 作为（可能为空的）字符串，去除版本号得到根并映射到 $R$，然后输出 $\\langle R, p, E(\\text{del}), E(\\text{ins}) \\rangle$。\n5. 对于没有变异的裸 RefSeq Accession.version，在映射到 $R$ 后，输出 $\\langle R, -1, 0, 0 \\rangle$。\n6. 对于任何包含根不在已定义规范参考中的登录号的输入，或任何解析或映射失败的输入，输出 $\\langle -1, -1, -1, -1 \\rangle$。\n\n角度单位不适用。输出中没有物理单位。所有数字输出必须是指定的整数。\n\n测试套件：\n您的程序必须使用上述规则，按此确切顺序，为以下输入计算结果：\n1. “rs1000001”\n2. “NC_000019.10:g.1101G>A”\n3. “NM_000001.2:c.201G>A”\n4. “NC_000019.10:1100:G:A”\n5. “NC_000017.11”\n6. “NC_000019.9:1100:G:A”\n7. “rs3000003”\n8. “NM_000002.1:c.100T>A”\n9. “NC_000017.11:499:TA:”\n10. “NC_000017.11:g.1801A>T”\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果本身都是一个按 $[R,p,d,i]$ 顺序排列的包含四个整数的列表。例如：“[ [r1,p1,d1,i1], [r2,p2,d2,i2], ... ]”，不带空格的形式也是可接受的。该问题所需的输出必须由您的程序生成，并且必须反映上面定义的规范化过程。",
            "solution": "该问题的解决方案是实现一个程序，用于将不同格式的基因变异标识符（rsID、HGVS、SPDI）解析并转换为统一的规范参考上下文 $\\langle R, p, d, i \\rangle$。该程序的核心逻辑是根据一组确定性规则，在一个自包含的知识库上运行。以下是实现该程序的算法概述：\n\n1.  **数据结构和辅助函数**：程序首先定义必要的静态数据结构，包括参考登录号到整数的映射、rsID到基因组位置的映射，以及转录本到基因组的映射。此外，还需实现辅助函数：一个用于从登录号中提取根并获取其整数代码 $R$ 的函数，一个根据问题定义的5进制规则对DNA序列进行编码的函数 $E(s)$，以及一个计算DNA序列反向互补的函数 $\\mathrm{rc}(s)$。\n\n2.  **主标准化函数**：此函数是程序的核心，它接受一个输入字符串，并通过一系列条件检查来确定其格式，然后应用相应的规则。\n    *   **rsID**：如果输入以 \"rs\" 开头，则应用规则1，使用rsID映射表查找信息。\n    *   **HGVS/SPDI/Bare Accession**：对其他格式，可以通过检查字符串中是否存在冒号 (\":\") 以及特定的子字符串（如 \"g.\" 或 \"c.\"）来区分。\n    *   对于 **HGVS 编码 (`c.`)** 变异（规则3），逻辑最为复杂。它需要根据转录本的链方向（正或负）来选择正确的公式计算基因组坐标，并对负链上的等位基因进行反向互补。\n    *   对于 **HGVS 基因组 (`g.`)** 变异（规则2），将1基坐标转换为0基坐标。\n    *   对于 **SPDI** 格式（规则4），直接解析出已是0基的坐标和等位基因。\n    *   对于**裸登录号**（规则5），如果输入不含变异信息但格式有效，则生成特殊的 `[-1, 0, 0]` 变异部分。\n    *   **错误处理**（规则6）：如果输入不符合任何已知格式，或者其登录号不在知识库中，则返回一个预定义的错误四元组 `[-1, -1, -1, -1]`。\n\n3.  **执行和输出**：主程序将遍历给定的测试用例列表，对每个用例调用标准化函数，收集结果，并按照要求的格式（一个包含整数列表的列表）打印最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport re\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print output.\n    \"\"\"\n\n    # --- Self-Contained Knowledge Base and Constants ---\n    \n    REF_ACCESSION_ROOT_TO_CODE = {\"NC_000019\": 19, \"NC_000017\": 17}\n    \n    RSID_TO_GENOMIC = {\n        \"rs1000001\": (\"NC_000019.10\", 1100, \"G\", \"A\"),\n        \"rs2000002\": (\"NC_000017.11\", 1800, \"A\", \"T\"),\n        \"rs3000003\": (\"NC_000017.11\", 500, \"TA\", \"\"),\n    }\n\n    TX_TO_GENOMIC_MAP = {\n        \"NM_000001.2\": {\n            \"gen_acc\": \"NC_000019.10\",\n            \"strand\": \"+\",\n            \"g_start\": 901,\n            \"g_end\": 10900,\n        },\n        \"NM_000002.1\": {\n            \"gen_acc\": \"NC_000017.11\",\n            \"strand\": \"-\",\n            \"g_start\": 901,\n            \"g_end\": 1900,\n        },\n    }\n\n    BASE_TO_DIGIT = {\"A\": 1, \"C\": 2, \"G\": 3, \"T\": 4}\n    BASE_COMPLEMENT = {\"A\": \"T\", \"T\": \"A\", \"C\": \"G\", \"G\": \"C\"}\n    ERROR_RESULT = [-1, -1, -1, -1]\n\n    # --- Helper Functions ---\n\n    def get_root_and_R(accession):\n        \"\"\"Strips version from accession and maps root to integer code R.\"\"\"\n        root_match = re.match(r\"([^_]+_\\d+)\", accession)\n        if not root_match:\n            return None\n        root = root_match.group(1)\n        return REF_ACCESSION_ROOT_TO_CODE.get(root)\n\n    def encode_sequence(s):\n        \"\"\"Computes the base-5 integer encoding E(s) for a DNA sequence.\"\"\"\n        if not s:\n            return 0\n        encoding = 0\n        for i, base in enumerate(s):\n            if base not in BASE_TO_DIGIT:\n                raise ValueError(\"Invalid base in sequence\")\n            encoding += BASE_TO_DIGIT[base] * (5 ** i)\n        return encoding\n\n    def reverse_complement(s):\n        \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n        return \"\".join(BASE_COMPLEMENT.get(b, '') for b in reversed(s))\n\n    # --- Main Normalization Logic ---\n\n    def normalize(input_str):\n        \"\"\"\n        Normalizes a genomic variant identifier to the canonical format [R, p, d, i].\n        \"\"\"\n        try:\n            # Rule 1: rsID\n            if input_str.startswith(\"rs\"):\n                if input_str in RSID_TO_GENOMIC:\n                    acc, p, ref, alt = RSID_TO_GENOMIC[input_str]\n                    R = get_root_and_R(acc)\n                    if R is not None:\n                        return [R, p, encode_sequence(ref), encode_sequence(alt)]\n\n            # Check for colon to distinguish from bare accession\n            elif \":\" in input_str:\n                parts = input_str.split(\":\", 1)\n                acc_part = parts[0]\n                var_part = parts[1]\n                R = get_root_and_R(acc_part)\n\n                if R is None: # Rule 6: Invalid root\n                    # Check if it's a transcript accession\n                    if acc_part not in TX_TO_GENOMIC_MAP:\n                        return ERROR_RESULT\n                \n                # Rule 3: HGVS coding\n                if var_part.startswith(\"c.\"):\n                    if acc_part in TX_TO_GENOMIC_MAP:\n                        tx_info = TX_TO_GENOMIC_MAP[acc_part]\n                        genomic_R = get_root_and_R(tx_info[\"gen_acc\"])\n                        match = re.match(r\"c\\.(\\d+)([ACGT]+)>([ACGT]+)\", var_part)\n                        if match:\n                            C_str, cref, calt = match.groups()\n                            C = int(C_str)\n                            if tx_info[\"strand\"] == \"+\":\n                                G = tx_info[\"g_start\"] + (C - 1)\n                                ref, alt = cref, calt\n                            else:  # strand == \"-\"\n                                G = tx_info[\"g_end\"] - (C - 1)\n                                ref, alt = reverse_complement(cref), reverse_complement(calt)\n                            p = G - 1\n                            return [genomic_R, p, encode_sequence(ref), encode_sequence(alt)]\n\n                # Rule 2: HGVS genomic\n                elif var_part.startswith(\"g.\"):\n                    if R is not None:\n                        match = re.match(r\"g\\.(\\d+)([ACGT]+)>([ACGT]+)\", var_part)\n                        if match:\n                            P_str, ref, alt = match.groups()\n                            p = int(P_str) - 1\n                            return [R, p, encode_sequence(ref), encode_sequence(alt)]\n\n                # Rule 4: SPDI\n                else:\n                    spdi_parts = input_str.split(':')\n                    if len(spdi_parts) == 4 and R is not None and spdi_parts[1].isdigit():\n                        _, pos_str, dele, ins = spdi_parts\n                        p = int(pos_str)\n                        return [R, p, encode_sequence(dele), encode_sequence(ins)]\n\n            # Rule 5: Bare Accession\n            elif re.fullmatch(r\"[A-Z]{2}_\\d+\\.\\d+\", input_str):\n                R = get_root_and_R(input_str)\n                if R is not None:\n                    return [R, -1, 0, 0]\n\n        except (ValueError, IndexError):\n            return ERROR_RESULT\n            \n        return ERROR_RESULT\n\n    # Test Suite\n    test_cases = [\n        \"rs1000001\",\n        \"NC_000019.10:g.1101G>A\",\n        \"NM_000001.2:c.201G>A\",\n        \"NC_000019.10:1100:G:A\",\n        \"NC_000017.11\",\n        \"NC_000019.9:1100:G:A\",\n        \"rs3000003\",\n        \"NM_000002.1:c.100T>A\",\n        \"NC_000017.11:499:TA:\",\n        \"NC_000017.11:g.1801A>T\",\n    ]\n\n    results = [normalize(case) for case in test_cases]\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}