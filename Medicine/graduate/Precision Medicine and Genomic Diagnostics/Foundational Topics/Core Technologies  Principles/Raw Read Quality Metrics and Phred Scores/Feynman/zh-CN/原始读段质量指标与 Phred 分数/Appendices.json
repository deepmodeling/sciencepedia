{
    "hands_on_practices": [
        {
            "introduction": "在开始任何下游分析之前，我们必须确保能够正确地解析和解读原始测序数据。FASTQ文件中的碱基质量分数是评估测序可靠性的基石，但其编码格式存在历史遗留的两种主要标准：Phred+33和Phred+64。这个实践练习将指导您构建一个算法，用于自动检测给定FASTQ文件所使用的编码方案，这是任何稳健的生物信息学流程中至关重要的第一步。通过完成这项任务，您将掌握处理测序数据时所需的基本验证技能。",
            "id": "4374632",
            "problem": "您正在为一个临床生物信息学流程开发一个分类模块，该模块必须能自动检测给定 FASTQ 文件中使用的 Phred 分数编码方案。在 FASTQ 格式（Fast All-Sequence Toolbox for Quality）中，每个测序片段 (read) 由四行表示；第四行使用可打印的美国信息交换标准代码 (ASCII) 字符来编码每个碱基的质量。每个碱基的质量由 Phred 质量分数定义，其公式为 $Q=-10\\log_{10}(P_{\\text{error}})$，其中 $Q$ 是一个整数，$P_{\\text{error}}$ 是碱基检出 (base call) 不正确的概率。广泛使用的平台通过应用一个固定的线性偏移量 $o$（其中 $o\\in\\{33,64\\}$）将整数 Phred 质量分数映射到可打印的 ASCII 字符，从而产生了两种历史编码方式。在精准医疗的临床实践中，合理的碱基检出质量通常位于一个平台限制的闭区间 $[Q_{\\min},Q_{\\max}]$ 内，对于现代仪器，该区间通常近似为 $[0,41]$。\n\n您的任务是构建一个程序，给定一组观测到的质量字符串（假设它们是 FASTQ 记录的第四行，不含头部信息或序列）和已知的平台约束 $(Q_{\\min},Q_{\\max})$，推断数据是与 Phred$+33$（偏移量 33）、Phred$+64$（偏移量 64）、两者都一致，还是两者都不一致。决策规则必须是纯逻辑的：对于一个候选偏移量 $o$，所有提供的质量字符串中，每个字符（其 ASCII 码为 $c$）解码出的整数质量值 $q=c-o$ 都必须满足 $Q_{\\min}\\le q\\le Q_{\\max}$。如果只有一个偏移量 $o\\in\\{33,64\\}$ 满足此约束，则输出该偏移量的整数值（$33$ 或 $64$）。如果两个偏移量都满足约束（即，在区间 $[Q_{\\min},Q_{\\max}]$ 引起的重叠范围内存在歧义），或者两者都不满足（即，数据不一致或已损坏），则输出 $-1$。\n\n请实现此决策逻辑，并将其应用于以下测试套件。每个测试用例是一个元组，包含一个质量字符串列表和 $(Q_{\\min},Q_{\\max})$ 边界：\n\n- 测试用例 $1$（因 ASCII 字符值较低而明确为 Phred$+33$）：\n  - 质量字符串：[\"IIII!!!!JJJJ\", \"!$%'()*+,-./0123\"]\n  - $(Q_{\\min},Q_{\\max})=(0,41)$\n- 测试用例 $2$（因 ASCII 字符值较高而明确为 Phred$+64$）：\n  - 质量字符串：[\"abchi\", \"`defg\"]\n  - $(Q_{\\min},Q_{\\max})=(0,41)$\n- 测试用例 $3$（存在歧义：对于给定边界，所有字符都位于两种编码的重叠区域内）：\n  - 质量字符串：[\"@ABCDEFGHIJ\"]\n  - $(Q_{\\min},Q_{\\max})=(0,41)$\n- 测试用例 $4$（两种编码均无效，因为在两种偏移量下都存在超出范围的字符；视作不一致/已损坏）：\n  - 质量字符串：[\"I}I\"]\n  - $(Q_{\\min},Q_{\\max})=(0,41)$\n- 测试用例 $5$（通过更严格的平台最低质量，例如仪器运行设置，来消除歧义）：\n  - 质量字符串：[\"@@AAJJ\"]\n  - $(Q_{\\min},Q_{\\max})=(3,41)$\n\n您的程序必须处理这些固定的测试用例，并生成单行输出，其中包含按顺序排列的 $5$ 个测试用例的结果，形式为包含在方括号内的、由逗号分隔且无空格的整数列表。每个测试用例唯一允许的输出是整数 $33$、$64$ 或 $-1$。例如，输出格式必须为 [$r_1$,$r_2$,$r_3$,$r_4$,$r_5$] 的形式，其中每个 $r_i\\in\\{33,64,-1\\}$。",
            "solution": "该问题要求我们为 FASTQ 数据中的 Phred 质量分数编码方案开发一个确定性分类器。这是基因组分析流程中一个常见的预处理步骤，以确保质量指标得到正确解释。我们将形式化所提供的决策逻辑，然后将其应用于各个测试用例。\n\n### 基本原理\n\nPhred 质量分数 $Q$ 量化了碱基检出不正确的概率 $P_{\\text{error}}$。其关系定义如下：\n$$Q = -10 \\log_{10}(P_{\\text{error}})$$\n例如，$Q$ 分数为 $10$ 意味着碱基检出不正确的概率为十分之一 ($P_{\\text{error}} = 10^{-1}$)，$Q$ 分数为 $20$ 意味着概率为百分之一 ($P_{\\text{error}} = 10^{-2}$)，以此类推。\n\n在 FASTQ 格式中，这个整数分数 $Q$ 并不直接存储。它被编码为单个可打印的 ASCII 字符。这种编码是通过将一个固定的整数偏移量 $o$ 加到质量分数 $Q$ 上，从而得到待存储字符的整数 ASCII 码 $c$ 来实现的。\n$$c = Q + o$$\n这意味着要解码质量分数，我们必须从字符的 ASCII 码中减去偏移量：\n$$Q = c - o$$\n\n问题指出了两种常见的历史编码方案，由它们的偏移量定义：\n1.  **Phred+$33$ (Sanger 格式)**：此处，偏移量为 $o = 33$。ASCII 字符的范围从字符 `!` (ASCII 码 $33$) 开始，对应于 $Q=0$。\n2.  **Phred+$64$ (Illumina 格式)**：此处，偏移量为 $o = 64$。ASCII 字符的范围从字符 `@` (ASCII 码 $64$) 开始，对应于 $Q=0$。\n\n此外，测序仪器通常产生特定于平台的范围内的质量分数，我们用闭区间 $[Q_{\\min}, Q_{\\max}]$ 表示。对于给定的一组质量字符串，一个编码方案（即一个候选偏移量 $o$）被认为是有效的，当且仅当数据中的*每一个字符*在解码后产生的质量分数 $Q$ 都落在这个有效范围内。\n\n### 算法设计和决策逻辑\n\n令 $S$ 为给定测试用例中所有观测到的质量字符串的集合。令 $\\mathcal{C}$ 为 $S$ 中所有字符串中出现的所有字符的集合。对于任何字符 $char \\in \\mathcal{C}$，令 $\\text{ord}(char)$ 为其对应的整数 ASCII 码。\n\n任务的核心是根据所提供的数据和质量范围 $[Q_{\\min}, Q_{\\max}]$ 来验证每个候选偏移量 $o_1=33$ 和 $o_2=64$。\n\n一个偏移量 $o$ 被视为**有效**，如果对于所有字符 $char \\in \\mathcal{C}$，解码后的质量分数 $Q = \\text{ord}(char) - o$ 满足以下条件：\n$$Q_{\\min} \\le (\\text{ord}(char) - o) \\le Q_{\\max}$$\n\n我们可以优化这个过程，而不是检查每一个字符。令 $c_{\\min} = \\min_{char \\in \\mathcal{C}} \\{\\text{ord}(char)\\}$ 和 $c_{\\max} = \\max_{char \\in \\mathcal{C}} \\{\\text{ord}(char)\\}$。这些是在数据中观测到的最小和最大 ASCII 码。有效性的条件可以简化为只检查这两个极值。一个偏移量 $o$ 是有效的，当且仅当：\n$$Q_{\\min} \\le (c_{\\min} - o) \\quad \\text{且} \\quad (c_{\\max} - o) \\le Q_{\\max}$$\n这是因为如果解码后的最小和最大质量值在 $[Q_{\\min}, Q_{\\max}]$ 范围内，那么所有中间的质量值也必定在此范围内。\n\n我们定义两个布尔标志：\n-   `is_33_valid`: 如果 $o=33$ 是一个有效偏移量，则为 True，否则为 False。\n-   `is_64_valid`: 如果 $o=64$ 是一个有效偏移量，则为 True，否则为 False。\n\n最终输出由这两个标志的状态根据规定的规则决定：\n1.  如果 `is_33_valid` 为 True 且 `is_64_valid` 为 False：编码明确为 Phred+$33$。输出为 $33$。\n2.  如果 `is_33_valid` 为 False 且 `is_64_valid` 为 True：编码明确为 Phred+$64$。输出为 $64$。\n3.  如果两者都为 True（有歧义）或都为 False（不一致/已损坏）：编码无法唯一确定或无效。输出为 $-1$。\n\n这个逻辑可以简洁地表达为：如果 `is_33_valid` $\\neq$ `is_64_valid`，则返回有效的偏移量；否则，返回 $-1$。\n\n### 应用于测试用例\n\n我们现在将此算法应用于每个测试用例。\n\n-   **测试用例 $1$**：质量字符串 `[\"IIII!!!!JJJJ\", \"!$%'()*+,-./0123\"]`，$(Q_{\\min}, Q_{\\max})=(0, 41)$。\n    -   组合后的字符包括 `!` 到 `J`。\n    -   $c_{\\min} = \\text{ord}('!') = 33$，$c_{\\max} = \\text{ord}('J') = 74$。\n    -   对于 $o=33$：解码后的范围是 $[33-33, 74-33] = [0, 41]$。这在 $[0, 41]$ 范围内。`is_33_valid` = True。\n    -   对于 $o=64$：解码后的范围是 $[33-64, 74-64] = [-31, 10]$。这不在 $[0, 41]$ 范围内，因为 $-31  0$。`is_64_valid` = False。\n    -   结果：$33$。\n\n-   **测试用例 $2$**：质量字符串 `[\"abchi\", \"`defg\"]`，$(Q_{\\min}, Q_{\\max})=(0, 41)$。\n    -   组合后的字符包括 `` ` `` 到 `i`。\n    -   $c_{\\min} = \\text{ord}('`') = 96$，$c_{\\max} = \\text{ord}('i') = 105$。\n    -   对于 $o=33$：解码后的范围是 $[96-33, 105-33] = [63, 72]$。这不在 $[0, 41]$ 范围内，因为 $63 > 41$。`is_33_valid` = False。\n    -   对于 $o=64$：解码后的范围是 $[96-64, 105-64] = [32, 41]$。这在 $[0, 41]$ 范围内。`is_64_valid` = True。\n    -   结果：$64$。\n\n-   **测试用例 $3$**：质量字符串 `[\"@ABCDEFGHIJ\"]`，$(Q_{\\min}, Q_{\\max})=(0, 41)$。\n    -   字符是 `@` 到 `J`。\n    -   $c_{\\min} = \\text{ord}('@') = 64$，$c_{\\max} = \\text{ord}('J') = 74$。\n    -   对于 $o=33$：解码后的范围是 $[64-33, 74-33] = [31, 41]$。这在 $[0, 41]$ 范围内。`is_33_valid` = True。\n    -   对于 $o=64$：解码后的范围是 $[64-64, 74-64] = [0, 10]$。这在 $[0, 41]$ 范围内。`is_64_valid` = True。\n    -   结果（有歧义）：$-1$。\n\n-   **测试用例 $4$**：质量字符串 `[\"I}I\"]`，$(Q_{\\min}, Q_{\\max})=(0, 41)$。\n    -   字符是 `I` 和 `}`。\n    -   $c_{\\min} = \\text{ord}('I') = 73$，$c_{\\max} = \\text{ord}('}') = 125$。\n    -   对于 $o=33$：解码后的范围是 $[73-33, 125-33] = [40, 92]$。这不在 $[0, 41]$ 范围内，因为 $92 > 41$。`is_33_valid` = False。\n    -   对于 $o=64$：解码后的范围是 $[73-64, 125-64] = [9, 61]$。这不在 $[0, 41]$ 范围内，因为 $61 > 41$。`is_64_valid` = False。\n    -   结果（不一致）：$-1$。\n\n-   **测试用例 $5$**：质量字符串 `[\"@@AAJJ\"]`，$(Q_{\\min}, Q_{\\max})=(3, 41)$。\n    -   字符是 `@`、`A`、`J`。\n    -   $c_{\\min} = \\text{ord}('@') = 64$，$c_{\\max} = \\text{ord}('J') = 74$。\n    -   对于 $o=33$：解码后的范围是 $[64-33, 74-33] = [31, 41]$。这在 $[3, 41]$ 范围内。`is_33_valid` = True。\n    -   对于 $o=64$：解码后的范围是 $[64-64, 74-64] = [0, 10]$。这不在 $[3, 41]$ 范围内，因为 $0  3$。`is_64_valid` = False。\n    -   结果：$33$。\n\n五个测试用例的最终结果序列是 [$33$, $64$, $-1$, $-1$, $33$]。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_offset_validity(all_chars_ord: np.ndarray, offset: int, q_min: int, q_max: int) - bool:\n    \"\"\"\n    Checks if a given offset is valid for the observed character ordinals and quality score range.\n\n    An offset is valid if all decoded quality scores fall within [q_min, q_max].\n    This is equivalent to checking if the min and max decoded scores are in the range.\n\n    Args:\n        all_chars_ord: A numpy array of integer ASCII codes for all observed quality characters.\n        offset: The candidate Phred offset (e.g., 33 or 64).\n        q_min: The minimum allowed Phred score.\n        q_max: The maximum allowed Phred score.\n\n    Returns:\n        True if the offset is valid, False otherwise.\n    \"\"\"\n    if all_chars_ord.size == 0:\n        # If there are no quality characters, no data point can invalidate an encoding.\n        # Per the problem's logic, this would lead to an 'ambiguous' determination as\n        # both offsets are vacuously true.\n        return True\n\n    min_q_decoded = np.min(all_chars_ord) - offset\n    max_q_decoded = np.max(all_chars_ord) - offset\n\n    return min_q_decoded = q_min and max_q_decoded = q_max\n\ndef classify_encoding(quality_strings: list[str], quality_bounds: tuple[int, int]) - int:\n    \"\"\"\n    Classifies the Phred encoding (33, 64, or ambiguous/invalid -1) for a set\n    of quality strings given platform quality constraints.\n\n    Args:\n        quality_strings: A list of strings, where each string is a line of \n                         FASTQ quality scores.\n        quality_bounds: A tuple (Q_min, Q_max) representing the inclusive range \n                        of valid Phred scores.\n\n    Returns:\n        An integer: 33 for Phred+33, 64 for Phred+64, or -1 for ambiguous or invalid.\n    \"\"\"\n    q_min, q_max = quality_bounds\n    \n    # Combine all characters from all provided quality strings into a single sequence.\n    full_quality_string = \"\".join(quality_strings)\n\n    # Convert all characters to their integer ASCII ordinal values using NumPy for efficiency.\n    all_chars_ord = np.array([ord(c) for c in full_quality_string], dtype=np.int32)\n    \n    offset_33 = 33\n    offset_64 = 64\n    \n    # Check validity for both standard offsets.\n    is_33_valid = check_offset_validity(all_chars_ord, offset_33, q_min, q_max)\n    is_64_valid = check_offset_validity(all_chars_ord, offset_64, q_min, q_max)\n    \n    # Apply the decision logic from the problem statement.\n    if is_33_valid and not is_64_valid:\n        return offset_33\n    elif not is_33_valid and is_64_valid:\n        return offset_64\n    else:  # This branch handles two cases:\n           # 1. is_33_valid AND is_64_valid (ambiguous)\n           # 2. NOT is_33_valid AND NOT is_64_valid (inconsistent/corrupted)\n           # In both scenarios, the required output is -1.\n        return -1\n\ndef solve():\n    \"\"\"\n    Main function to run the predefined test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1: Clear Phred+33\n        ([\"IIII!!!!JJJJ\", \"!$%'()*+,-./0123\"], (0, 41)),\n        # Test case 2: Clear Phred+64\n        ([\"abchi\", \"`defg\"], (0, 41)),\n        # Test case 3: Ambiguous\n        ([\"@ABCDEFGHIJ\"], (0, 41)),\n        # Test case 4: Inconsistent/Corrupted\n        ([\"I}I\"], (0, 41)),\n        # Test case 5: Disambiguation by stricter Q_min\n        ([\"@@AAJJ\"], (3, 41)),\n    ]\n\n    results = []\n    for quality_strings, quality_bounds in test_cases:\n        result = classify_encoding(quality_strings, quality_bounds)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在解决了如何检测正确的编码方案后 (见 )，一个自然而然的问题是：“如果我们搞错了会怎么样？” 这个练习将通过一个实际的计算案例，量化因错误解读Phred编码（例如，将Phred+64误认为Phred+33）而导致的严重后果。通过计算单个碱基和整条读长（read）错误概率的低估因子，您将深刻体会到为何数据解析的准确性在精准医疗诊断中至关重要。",
            "id": "4374725",
            "problem": "一个精准肿瘤学流程接收来自一台旧式临床测序仪的FASTQ（FASTA加质量）格式的全外显子组测序读数，该测序仪使用Phred+$64$约定对碱基质量分数进行编码。由于配置错误，一个下游变异检测模块将同样的数据解读为Phred+$33$。考虑单个测序读数，其所有位置上真实的每碱基Phred质量分数均为$Q_{\\text{true}} = 30$。假设各位置的碱基识别错误是独立的，每个错误都受由$Q_{\\text{true}}$所蕴含的相同真实错误概率支配，并且该模块仅根据被错误解读的质量分数来估计碱基错误概率。通过计算两个乘法因子来量化这种编码不匹配对下游错误概率的影响：\n- 单碱基低估因子$r_{\\text{base}}$，定义为被错误解读的每碱基错误概率与真实的每碱基错误概率的比值。\n- 读数级别低估因子$r_{\\text{read}}$，定义为长度为$L = 150$的测序读数包含至少一个碱基识别错误的被错误解读的概率与相应的真实概率的比值。\n\n将您的最终数值四舍五入到四位有效数字，并以小数（而非百分比）形式表示。按顺序$(r_{\\text{base}}, r_{\\text{read}})$提供您的两个结果。",
            "solution": "该问题陈述已经过严格验证，被认为是自洽的、有科学依据且提法恰当的。所有必要的参数和定义均已提供，所描述的场景是生物信息学中一个现实且可形式化的问题。因此，我将继续进行解答。\n\n该问题要求计算两个因子$r_{\\text{base}}$和$r_{\\text{read}}$，用以量化Phred分数编码不匹配的影响。问题的核心在于Phred质量分数$Q$的定义，及其与碱基识别错误概率$P_e$之间的关系。该关系由下式给出：\n$$Q = -10 \\log_{10}(P_e)$$\n根据此定义，错误概率$P_e$可以表示为质量分数$Q$的函数：\n$$P_e = 10^{-Q/10}$$\n\n首先，让我们确定真实参数和被错误解读的参数。\n真实的Phred质量分数给定为$Q_{\\text{true}} = 30$。\n因此，真实的每碱基错误概率$P_{e, \\text{true}}$为：\n$$P_{e, \\text{true}} = 10^{-Q_{\\text{true}}/10} = 10^{-30/10} = 10^{-3} = 0.001$$\n\n测序数据使用Phred+$64$约定进行编码。这意味着质量分数$Q$作为ASCII字符存储，其整数值为$Q + 64$。对于$Q_{\\text{true}} = 30$，FASTQ文件中字符的ASCII值为：\n$$\\text{ASCII value} = Q_{\\text{true}} + 64 = 30 + 64 = 94$$\n一个下游模块错误地使用Phred+$33$约定来解读这些数据。它假设质量分数为ASCII值减去$33$。因此，被错误解读的质量分数$Q_{\\text{misinterpreted}}$为：\n$$Q_{\\text{misinterpreted}} = \\text{ASCII value} - 33 = 94 - 33 = 61$$\n使用这个被错误解读的质量分数，该模块计算出一个被错误解读的每碱基错误概率$P_{e, \\text{misinterpreted}}$：\n$$P_{e, \\text{misinterpreted}} = 10^{-Q_{\\text{misinterpreted}}/10} = 10^{-61/10} = 10^{-6.1}$$\n\n现在我们可以计算第一个所求量，即单碱基低估因子$r_{\\text{base}}$。这是被错误解读的每碱基错误概率与真实的每碱基错误概率的比值。\n$$r_{\\text{base}} = \\frac{P_{e, \\text{misinterpreted}}}{P_{e, \\text{true}}} = \\frac{10^{-6.1}}{10^{-3}} = 10^{-6.1 - (-3)} = 10^{-3.1}$$\n为获得数值，我们计算$10^{-3.1}$：\n$$r_{\\text{base}} \\approx 0.000794328...$$\n四舍五入到四位有效数字，我们得到：\n$$r_{\\text{base}} \\approx 0.0007943$$\n\n接下来，我们计算读数级别低估因子$r_{\\text{read}}$。这需要我们首先确定长度为$L$的测序读数包含至少一个碱基识别错误的概率。单个碱基被正确识别的概率是$1 - P_e$。假设碱基识别错误是独立事件，则整个长度为$L$的测序读数没有错误的概率是$(1 - P_e)^L$。因此，一个测序读数至少有一个错误的概率是：\n$$P(\\text{read has} \\ge 1 \\text{ error}) = 1 - (1 - P_e)^L$$\n测序读数的长度给定为$L = 150$。\n\n一个测序读数包含至少一个错误的真实概率$P(\\text{read error})_{\\text{true}}$为：\n$$P(\\text{read error})_{\\text{true}} = 1 - (1 - P_{e, \\text{true}})^L = 1 - (1 - 10^{-3})^{150} = 1 - (0.999)^{150}$$\n一个测序读数包含至少一个错误的被错误解读的概率$P(\\text{read error})_{\\text{misinterpreted}}$为：\n$$P(\\text{read error})_{\\text{misinterpreted}} = 1 - (1 - P_{e, \\text{misinterpreted}})^L = 1 - (1 - 10^{-6.1})^{150}$$\n读数级别低估因子$r_{\\text{read}}$是这两个概率的比值：\n$$r_{\\text{read}} = \\frac{P(\\text{read error})_{\\text{misinterpreted}}}{P(\\text{read error})_{\\text{true}}} = \\frac{1 - (1 - 10^{-6.1})^{150}}{1 - (0.999)^{150}}$$\n现在，我们计算分子和分母的数值。\n分母：\n$$1 - (0.999)^{150} \\approx 1 - 0.860713303 = 0.139286697$$\n分子：\n$$1 - (1 - 10^{-6.1})^{150} \\approx 1 - (1 - 7.94328 \\times 10^{-7})^{150} \\approx 1 - 0.999880856 = 0.000119144$$\n$P_{e, \\text{misinterpreted}}$的值非常小，因此对于分子，近似式$1 - (1 - x)^n \\approx nx$相当准确：$150 \\times 10^{-6.1} \\approx 0.000119149$。\n\n现在我们计算比值：\n$$r_{\\text{read}} = \\frac{0.000119144}{0.139286697} \\approx 0.000855420...$$\n四舍五入到四位有效数字，我们得到：\n$$r_{\\text{read}} \\approx 0.0008554$$\n\n两个所求的乘法因子是$r_{\\text{base}} \\approx 0.0007943$和$r_{\\text{read}} \\approx 0.0008554$。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.0007943  0.0008554 \\end{pmatrix}}$$"
        },
        {
            "introduction": "当我们能够可靠地获取每个碱基的质量分数后，便可以利用这些信息进行更高级别的科学推断。这个实践练习将带您进入精准医学的核心应用：变异检测。您将学习如何综合利用来自多条独立测序读长的证据，运用贝叶斯定理来计算共有碱基（consensus base）的后验错误概率。此过程不仅能加深您对Phred分数概率本质的理解，还将引导您掌握在实际计算中为保证数值稳定性而使用的重要技巧，如对数-指数和（log-sum-exp）。",
            "id": "4374772",
            "problem": "在用于精准医疗的靶向肿瘤学基因包中，一个临床可操作的位点被多个独立的二代测序 (NGS) 读数所覆盖。在一个特定位置上，所有读数都报告了相同的碱基检出，记为核苷酸 $\\mathrm{A}$。对于每一次读数 $i \\in \\{1,2,3,4,5\\}$，碱基检出软件提供了一个校准的单次读数错误概率 $p_i$，表示所报告的碱基是不正确的。这五次读数具有以下错误概率：$p_1 = 3.2 \\times 10^{-6}$，$p_2 = 7.5 \\times 10^{-7}$，$p_3 = 1.1 \\times 10^{-6}$，$p_4 = 4.0 \\times 10^{-8}$ 以及 $p_5 = 2.3 \\times 10^{-6}$。\n\n任务：\n1. 将每个 $p_i$ 转换为其 Phred 质量得分 (Q-score)，其定义为 $Q_i = -10 \\log_{10}(p_i)$。\n2. 假设给定真实碱基，各读数是条件独立的，并且当发生错误时，错误为三种不正确核苷酸中任意一种的可能性是均等的。在此条件下，计算在所有五次读数都报告为 $\\mathrm{A}$ 的情况下，该位置的真实碱基不是 $\\mathrm{A}$ 的后验概率。使用均匀先验分布于各种核苷酸，因此真实碱基是 $\\mathrm{A}$ 的先验概率为 $1/4$，不是 $\\mathrm{A}$ 的先验概率为 $3/4$。为确保当 $p_i \\ll 10^{-6}$ 时的数值稳定性，请在自然对数域中进行计算，并在对似然项求和时使用 log-sum-exp 方法。\n\n您的推导应基于以下基本定义：$p$ 和 $Q$ 之间的 Phred 映射关系、读数的条件独立性、单次读数错误在三种替代核苷酸间的对称性以及贝叶斯定理。将最终数值答案以后验错误概率的形式表示（一个无单位的十进制数）。将最终答案四舍五入至四位有效数字。",
            "solution": "用户提供了一个基因组诊断学领域的问题，要求使用贝叶斯推断计算 Phred 质量得分和测序错误的后验概率。\n\n### 第 1 步：提取已知条件\n-   观测数据 ($D$)：在特定位点上的五次独立的二代测序 (NGS) 读数均报告核苷酸为 $\\mathrm{A}$。\n-   读数数量，$n = 5$。\n-   单次读数错误概率 ($p_i$)：\n    -   $p_1 = 3.2 \\times 10^{-6}$\n    -   $p_2 = 7.5 \\times 10^{-7}$\n    -   $p_3 = 1.1 \\times 10^{-6}$\n    -   $p_4 = 4.0 \\times 10^{-8}$\n    -   $p_5 = 2.3 \\times 10^{-6}$\n-   Phred 质量得分 (Q-score) 的定义：$Q_i = -10 \\log_{10}(p_i)$。\n-   任务 1：将每个 $p_i$ 转换为其对应的 $Q_i$。\n-   任务 2：在给定观测数据 $D$ 的情况下，计算真实碱基不是 $\\mathrm{A}$ 的后验概率。\n-   任务 2 的假设：\n    1.  条件独立性：给定真实核苷酸，各读数是条件独立的。\n    2.  错误对称性：当一次读数发生错误时，其错误为三种不正确核苷酸中任意一种的可能性是均等的。\n    3.  先验概率：四种可能的真实核苷酸（$\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}$）的先验分布是均匀的。即，对于任意 $k \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$，$P(\\text{真实碱基} = k) = 1/4$。这意味着真实碱基为 $\\mathrm{A}$ 的先验概率是 $P(H_A) = 1/4$，而真实碱基不是 $\\mathrm{A}$ 的先验概率是 $P(H_{\\neg A}) = 3/4$。\n-   计算方法：为保证数值稳定性，计算应在自然对数域中进行，并在适当情况下使用 log-sum-exp 方法。\n-   最终答案：后验错误概率，四舍五入至四位有效数字。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题在科学上基于基因组学、生物信息学和贝叶斯统计学的原理。Phred 得分、读数错误概率以及用于基因分型的贝叶斯推断等概念在该领域是标准方法。所提供的数据值是符合实际的。这是一个定义明确的问题，所有必要的信息和假设都已清晰陈述，可以推导出一个唯一的、有意义的解。语言客观、精确。该问题不违反任何无效性标准。\n\n### 第 3 步：结论与行动\n问题有效。将提供详细的解答。\n\n### 解题推导\n\n**任务 1：Phred 质量得分 (Q-score) 计算**\n\nPhred 质量得分 $Q_i$ 定义为错误概率 $p_i$ 的对数映射：\n$$Q_i = -10 \\log_{10}(p_i)$$\n使用此公式，我们将每个给定的错误概率 $p_i$ 转换为其对应的 Q-score。\n\n对于读数 1：\n$Q_1 = -10 \\log_{10}(3.2 \\times 10^{-6}) = -10 (\\log_{10}(3.2) - 6) \\approx -10(0.5051 - 6) \\approx 54.95$\n\n对于读数 2：\n$Q_2 = -10 \\log_{10}(7.5 \\times 10^{-7}) = -10 (\\log_{10}(7.5) - 7) \\approx -10(0.8751 - 7) \\approx 61.25$\n\n对于读数 3：\n$Q_3 = -10 \\log_{10}(1.1 \\times 10^{-6}) = -10 (\\log_{10}(1.1) - 6) \\approx -10(0.0414 - 6) \\approx 59.59$\n\n对于读数 4：\n$Q_4 = -10 \\log_{10}(4.0 \\times 10^{-8}) = -10 (\\log_{10}(4.0) - 8) = -10(0.6021 - 8) \\approx 73.98$\n\n对于读数 5：\n$Q_5 = -10 \\log_{10}(2.3 \\times 10^{-6}) = -10 (\\log_{10}(2.3) - 6) \\approx -10(0.3617 - 6) \\approx 56.38$\n\n这些 Q-score 代表了对每一次独立碱基检出的置信度，得分越高表示错误概率越低。\n\n**任务 2：后验概率计算**\n\n我们希望计算在所有五次读数都观测到核苷酸 $\\mathrm{A}$ 的条件下，真实核苷酸不是 $\\mathrm{A}$ 的后验概率。令 $D$ 表示所有五次读数都报告为 $\\mathrm{A}$ 的事件，即 $D = \\{R_1=\\mathrm{A}, R_2=\\mathrm{A}, R_3=\\mathrm{A}, R_4=\\mathrm{A}, R_5=\\mathrm{A}\\}$。令 $H_k$ 表示真实核苷酸是 $k$ 的假设，其中 $k \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$。我们要求解 $P(H_{\\neg A} | D)$，其中 $H_{\\neg A}$ 是真实碱基不是 $\\mathrm{A}$ 的复合假设，即 $H_{\\neg A} = H_C \\cup H_G \\cup H_T$。\n\n根据贝叶斯定理，任意假设 $H_k$ 的后验概率为：\n$$P(H_k | D) = \\frac{P(D | H_k) P(H_k)}{P(D)}$$\n项 $P(D)$ 是数据的边际似然，或称为证据，由全概率定律给出：\n$$P(D) = \\sum_{k \\in \\{\\mathrm{A,C,G,T}\\}} P(D|H_k)P(H_k)$$\n所求概率为 $P(H_{\\neg A} | D) = P(H_C | D) + P(H_G | D) + P(H_T | D)$。这可以计算为：\n$$P(H_{\\neg A} | D) = \\frac{P(D, H_{\\neg A})}{P(D)} = \\frac{P(D, H_C) + P(D, H_G) + P(D, H_T)}{P(D, H_A) + P(D, H_C) + P(D, H_G) + P(D, H_T)}$$\n其中 $P(D, H_k) = P(D|H_k)P(H_k)$ 是数据和假设的联合概率。\n\n为了在自然对数域中进行计算，我们首先计算联合概率的对数。\n先验概率对于所有 $k$ 均为 $P(H_k) = 1/4$。因此，$\\ln(P(H_k)) = \\ln(1/4) = -\\ln(4) \\approx -1.38629$。\n\n接下来，我们构建似然 $P(D|H_k)$。\n如果真实碱基是 $\\mathrm{A}$（即 $H_A$ 为真），在读数 $i$ 中观测到 $\\mathrm{A}$ 是一次正确的检出，概率为 $1-p_i$。由于条件独立性，似然为：\n$$L_A = P(D|H_A) = \\prod_{i=1}^{5} (1-p_i)$$\n如果真实碱基不是 $\\mathrm{A}$（例如，$H_C$ 为真），在读数 $i$ 中观测到 $\\mathrm{A}$ 就是一个错误。总错误概率是 $p_i$。根据错误对称性假设，这个特定错误 (C $\\to$ A) 的概率是 $p_i/3$。似然为：\n$$L_{C} = P(D|H_C) = \\prod_{i=1}^{5} \\frac{p_i}{3}$$\n根据对称性，$L_C = L_G = L_T$。我们将这个共同的似然表示为 $L_{\\text{err}}$。\n\n现在，我们计算联合概率的对数 $\\ln(P(D, H_k)) = \\ln(P(D|H_k)) + \\ln(P(H_k))$。\n\n$H_A$ 的对数似然：\n$\\ln(L_A) = \\sum_{i=1}^{5} \\ln(1-p_i) = \\ln(1-3.2\\times10^{-6}) + \\ldots + \\ln(1-2.3\\times10^{-6}) \\approx -7.390 \\times 10^{-6}$\n$H_A$ 的对数联合概率：\n$\\ln(P(D, H_A)) = \\ln(L_A) + \\ln(1/4) \\approx -7.390 \\times 10^{-6} - 1.38629436 = -1.38629443$\n\n$H_C$（以及 $H_G$, $H_T$）的对数似然：\n$\\ln(L_{\\text{err}}) = \\sum_{i=1}^{5} \\ln(p_i/3) = \\sum_{i=1}^{5} \\ln(p_i) - 5\\ln(3)$\n$\\sum \\ln(p_i) = \\ln(3.2\\times10^{-6}) + \\ldots + \\ln(2.3\\times10^{-6}) \\approx -12.6524 - 14.1032 - 13.7202 - 17.0344 - 12.9826 \\approx -70.4927$\n$\\ln(L_{\\text{err}}) \\approx -70.4927 - 5(1.0986) \\approx -70.4927 - 5.4931 = -75.9858$\n$H_C$ 的对数联合概率：\n$\\ln(P(D, H_C)) = \\ln(L_{\\text{err}}) + \\ln(1/4) \\approx -75.9858 - 1.3863 = -77.3721$\n由于对称性，$\\ln(P(D, H_G)) = \\ln(P(D, H_T)) = \\ln(P(D, H_C))$。\n\n我们需要计算 $\\ln(P(D, H_{\\neg A})) = \\ln(P(D, H_C) + P(D, H_G) + P(D, H_T))$。由于这些项相等，可以简化为：\n$\\ln(P(D, H_{\\neg A})) = \\ln(3 \\times P(D, H_C)) = \\ln(3) + \\ln(P(D, H_C))$\n$\\ln(P(D, H_{\\neg A})) \\approx 1.0986 + (-77.3721) = -76.2735$\n\n总证据的对数为 $\\ln(P(D)) = \\ln(P(D, H_A) + P(D, H_{\\neg A}))$。我们为此使用 log-sum-exp 技巧：\n$\\mathrm{logsumexp}(x, y) = \\max(x, y) + \\ln(\\exp(x-\\max(x,y)) + \\exp(y-\\max(x,y)))$\n令 $x = \\ln(P(D, H_A)) \\approx -1.3863$ 且 $y = \\ln(P(D, H_{\\neg A})) \\approx -76.2735$。\n$\\max(x,y) = x = -1.3863$。\n$\\ln P(D) \\approx x + \\ln(\\exp(0) + \\exp(y-x)) = x + \\ln(1 + \\exp(y-x))$\n$y - x \\approx -76.2735 - (-1.3863) = -74.8872$。\n$\\ln P(D) \\approx -1.3863 + \\ln(1 + \\exp(-74.8872))$。第二项小到可以忽略不计。\n所以，$\\ln P(D) \\approx -1.3863$。\n\n后验概率的对数为：\n$\\ln(P(H_{\\neg A} | D)) = \\ln(P(D, H_{\\neg A})) - \\ln(P(D))$\n$\\ln(P(H_{\\neg A} | D)) \\approx -76.2735 - (-1.3863) = -74.8872$\n\n最后，我们对该值取指数，以获得后验概率：\n$P(H_{\\neg A} | D) = \\exp(\\ln(P(H_{\\neg A} | D))) \\approx \\exp(-74.8872)$\n\n让我们使用更精确的值：\n$\\sum \\ln(p_i) = -70.49274387$\n$5\\ln(3) = 5.49306144$\n$\\ln(4) = 1.38629436$\n$\\ln(L_{\\text{err}}) = -70.49274387 - 5.49306144 = -75.98580531$\n$\\ln(P(D, H_{\\neg A})) = \\ln(3) + \\ln(L_{\\text{err}}) + \\ln(1/4) = 1.09861229 - 75.98580531 - 1.38629436 = -76.27348738$\n$\\ln(P(D, H_A)) = -7.390 \\times 10^{-6} - 1.38629436 = -1.38629443$\n$\\ln(P(H_{\\neg A} | D)) = \\ln(P(D, H_{\\neg A})) - \\ln(P(D)) = \\ln(P(D, H_{\\neg A})) - \\mathrm{logsumexp}(\\ln(P(D, H_A)), \\ln(P(D, H_{\\neg A})))$\n$\\ln(P(H_{\\neg A} | D)) = -76.27348738 - \\mathrm{logsumexp}(-1.38629443, -76.27348738)$\n$\\ln(P(H_{\\neg A} | D)) = -76.27348738 - (-1.38629443 + \\ln(1 + \\exp(-74.88719295)))$\n$\\ln(P(H_{\\neg A} | D)) \\approx -74.88719295$\n$P(H_{\\neg A} | D) = \\exp(-74.88719295) \\approx 1.19652 \\times 10^{-33}$\n\n将此结果四舍五入至四位有效数字，得到 $1.197 \\times 10^{-33}$。这个极小的概率表明，在来自五次高质量读数的压倒性且一致的证据下，我们有非常高的置信度认为真实核苷酸确实是 $\\mathrm{A}$。",
            "answer": "$$\n\\boxed{1.197 \\times 10^{-33}}\n$$"
        }
    ]
}