{
    "hands_on_practices": [
        {
            "introduction": "我们将从一个基础但至关重要的应用开始：利用药物基因组学信息来指导药物剂量。华法林是一种抗凝血剂，其剂量需求在个体间差异很大，部分原因在于 $VKORC1$ 和 $CYP2C9$ 基因的变异。本练习 () 模拟了如何使用一个包含临床和遗传因素的线性模型来计算患者的初始华法林剂量，这体现了诸如 PharmGKB 等信息资源在临床实践中的核心价值。",
            "id": "4367538",
            "problem": "考虑在一个精准医疗框架下估算华法林的初始剂量，该框架使用来自药物基因组学知识库 (PharmGKB) 的信息。PharmGKB 负责整理维生素K环氧化物还原酶复合物亚基1 (VKORC1) 和细胞色素P450家族2亚家族C成员9 (CYP2C9) 的基因型-表型关系及等位基因功能注释。假设一个线性预测模型，该模型将初始日剂量表示为临床和遗传协变量的加性函数，这与线性回归预测器的一般定义一致：响应是输入的加权和。设初始日剂量 $D$（单位为 $\\mathrm{mg/day}$）的模型为\n$$\nD = \\beta_{0} + \\beta_{1}\\,\\mathrm{Age} + \\beta_{2}\\,\\mathrm{Weight} + \\beta_{3}\\,I_{\\mathrm{VKORC1}} + \\beta_{4}\\,I_{\\mathrm{CYP2C9}},\n$$\n其中，$\\mathrm{Age}$ 的单位是岁，$\\mathrm{Weight}$ 的单位是千克，$I_{\\mathrm{VKORC1}}$ 是 VKORC1 $-1639\\,\\mathrm{G}>\\mathrm{A}$ 位点上 $A$ 等位基因的数量（可从 PharmGKB 注释的基因型中推断：$GG \\rightarrow 0$，$GA \\rightarrow 1$，$AA \\rightarrow 2$），$I_{\\mathrm{CYP2C9}}$ 是 CYP2C9 $*2$ 和 $*3$ 中功能减弱的等位基因的数量（PharmGKB 注释的功能减弱的等位基因；例如，$*1/*3 \\rightarrow 1$）。假设系数为\n$$\n\\beta_{0} = 7.0,\\quad \\beta_{1} = -0.03,\\quad \\beta_{2} = 0.04,\\quad \\beta_{3} = -0.8,\\quad \\beta_{4} = -1.2,\n$$\n单位保持一致，使得 $D$ 的单位为 $\\mathrm{mg/day}$。对于一个假设的患者，其 $\\mathrm{Age} = 65$，$\\mathrm{Weight} = 80$，VKORC1 基因型为 $AA$（因此 $I_{\\mathrm{VKORC1}} = 2$），CYP2C9 基因型为 $*1/*3$（因此 $I_{\\mathrm{CYP2C9}} = 1$）：\n\n- 计算初始日剂量 $D$（单位为 $\\mathrm{mg/day}$）。\n- 通过计算 $D$ 对 $\\mathrm{Weight}$ 的弹性，对 $\\mathrm{Weight}$ 进行局部敏感性分析，其定义为\n$$\nE_{\\mathrm{Weight}} = \\left(\\frac{\\partial D}{\\partial\\,\\mathrm{Weight}}\\right)\\frac{\\mathrm{Weight}}{D}.\n$$\n\n将弹性 $E_{\\mathrm{Weight}}$ 作为您的唯一最终答案。将您的最终答案四舍五入到四位有效数字。剂量 $D$ 应以 $\\mathrm{mg/day}$ 表示，但报告的最终弹性是无量纲的。请勿在最终的方框答案中包含任何单位。",
            "solution": "该问题经核实具有科学依据、是良定的、客观且完整的。提供了获得唯一解所需的所有数据和定义。其背景适用于精准医疗领域，并基于药物基因组学的既定原则。\n\n华法林的初始日剂量 $D$ 由以下线性模型给出：\n$$\nD = \\beta_{0} + \\beta_{1}\\,\\mathrm{Age} + \\beta_{2}\\,\\mathrm{Weight} + \\beta_{3}\\,I_{\\mathrm{VKORC1}} + \\beta_{4}\\,I_{\\mathrm{CYP2C9}}\n$$\n问题提供了以下系数和患者特定协变量的值：\n系数：\n$$\n\\beta_{0} = 7.0 \\\\\n\\beta_{1} = -0.03 \\\\\n\\beta_{2} = 0.04 \\\\\n\\beta_{3} = -0.8 \\\\\n\\beta_{4} = -1.2\n$$\n患者数据：\n$$\n\\mathrm{Age} = 65\\,\\text{years} \\\\\n\\mathrm{Weight} = 80\\,\\mathrm{kg} \\\\\nI_{\\mathrm{VKORC1}} = 2 \\\\\nI_{\\mathrm{CYP2C9}} = 1\n$$\n首先，我们将这些值代入模型方程，计算初始日剂量 $D$。假设系数的单位是一致的，从而得到以 $\\mathrm{mg/day}$ 为单位的剂量。\n$$\nD = 7.0 + (-0.03)(65) + (0.04)(80) + (-0.8)(2) + (-1.2)(1)\n$$\n我们对每一项进行乘法运算：\n$$\n\\beta_{1}\\,\\mathrm{Age} = -0.03 \\times 65 = -1.95 \\\\\n\\beta_{2}\\,\\mathrm{Weight} = 0.04 \\times 80 = 3.2 \\\\\n\\beta_{3}\\,I_{\\mathrm{VKORC1}} = -0.8 \\times 2 = -1.6 \\\\\n\\beta_{4}\\,I_{\\mathrm{CYP2C9}} = -1.2 \\times 1 = -1.2\n$$\n将这些结果代回 $D$ 的方程中：\n$$\nD = 7.0 - 1.95 + 3.2 - 1.6 - 1.2\n$$\n将各项相加，得到估算剂量：\n$$\nD = (7.0 + 3.2) - (1.95 + 1.6 + 1.2) = 10.2 - 4.75 = 5.45\n$$\n因此，初始日剂量为 $D = 5.45\\,\\mathrm{mg/day}$。\n\n接下来，我们通过计算 $D$ 对 $\\mathrm{Weight}$ 的弹性 $E_{\\mathrm{Weight}}$ 来进行局部敏感性分析。弹性定义为：\n$$\nE_{\\mathrm{Weight}} = \\left(\\frac{\\partial D}{\\partial\\,\\mathrm{Weight}}\\right)\\frac{\\mathrm{Weight}}{D}\n$$\n为了计算这个值，我们首先需要求出 $D$ 关于 $\\mathrm{Weight}$ 的偏导数。使用给定的 $D$ 的线性模型：\n$$\n\\frac{\\partial D}{\\partial\\,\\mathrm{Weight}} = \\frac{\\partial}{\\partial\\,\\mathrm{Weight}} \\left( \\beta_{0} + \\beta_{1}\\,\\mathrm{Age} + \\beta_{2}\\,\\mathrm{Weight} + \\beta_{3}\\,I_{\\mathrm{VKORC1}} + \\beta_{4}\\,I_{\\mathrm{CYP2C9}} \\right)\n$$\n由于所有其他变量（$\\mathrm{Age}$、$I_{\\mathrm{VKORC1}}$、$I_{\\mathrm{CYP2C9}}$）和系数相对于 $\\mathrm{Weight}$ 都被视为常数，导数简化为：\n$$\n\\frac{\\partial D}{\\partial\\,\\mathrm{Weight}} = \\beta_{2}\n$$\n给定的 $\\beta_{2}$ 值为 $0.04$。\n$$\n\\frac{\\partial D}{\\partial\\,\\mathrm{Weight}} = 0.04\n$$\n现在，我们将这个偏导数、患者的体重和计算出的剂量 $D$ 代入弹性公式：\n$$\nE_{\\mathrm{Weight}} = (0.04) \\frac{80}{5.45}\n$$\n$$\nE_{\\mathrm{Weight}} = \\frac{3.2}{5.45}\n$$\n进行除法运算得到：\n$$\nE_{\\mathrm{Weight}} \\approx 0.5871559633...\n$$\n题目要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $5$、$8$、$7$ 和 $1$。第五位数字是 $5$，因此需要将最后一位有效数字向上进一位。\n$$\nE_{\\mathrm{Weight}} \\approx 0.5872\n$$\n弹性 $E_{\\mathrm{Weight}}$ 是一个无量纲量，表示体重变化 $1\\%$ 时剂量的百分比变化。",
            "answer": "$$\n\\boxed{0.5872}\n$$"
        },
        {
            "introduction": "在掌握了基本的剂量计算后，我们将探讨一个更复杂的真实世界场景：如何解释不明确的基因检测结果。$CYP2D6$ 是一个高度多态性的药物代谢酶，其基因拷贝数变异 (CNV) 使得基因分型变得复杂。本练习 () 引入了临床药理遗传学实施联盟 (CPIC) 指南中标准的 $CYP2D6$ 活性评分系统，并要求您应用决策理论框架，在基因分型结果不明确的情况下，做出以安全为先的保守功能解释。",
            "id": "4367583",
            "problem": "使用 PharmGKB 资源和临床药物遗传学实施联盟 (CPIC) 的指南，将基因型转化为预测药物反应的核心任务之一是，将星号等位基因映射到功能类别并计算基因活性得分。以细胞色素 P450 家族 2 亚家族 D 成员 6 (CYP2D6) 为例，其星号等位基因被分为正常功能、功能减退和无功能三类，基因活性得分通过对每个拷贝的活性值求和来计算。根据 PharmGKB 整理并由 CPIC 协调统一的基本事实：一个正常功能等位基因贡献的活性值为 $1$，一个功能减退等位基因贡献的活性值为 $0.5$，一个无功能等位基因贡献的活性值为 $0$。拷贝数变异 (CNV) 会影响基因拷贝的总数，每个拷贝都将其等位基因特异性活性值贡献给总和。\n\n一名患者的 CYP2D6 基因型显示其拥有一个正常功能星号等位基因和一个功能减退星号等位基因，由于一次重复，总共有 $3$ 个拷贝。然而，基于测序读数的 CNV 解析存在歧义：要么是正常功能等位基因被重复，要么是功能减退等位基因被重复。设 $p_{N}$ 表示正常功能等位基因被重复的后验概率，$p_{D}$ 表示功能减退等位基因被重复的后验概率，且 $p_{N} + p_{D} = 1$。在本例中，$p_{N} = 0.38$ 且 $p_{D} = 0.62$。\n\n为了优先考虑功能性解释，请基于一个安全优先的错分框架构建一个决策规则：对于高估真实活性得分（即，当真实情况为低活性解释时，选择了高活性解释）的情况，施加 $\\lambda = 2$ 的惩罚；对于低估（即，当真实情况为高活性解释时，选择了低活性解释）的情况，施加 $1$ 的惩罚。请选择在这些惩罚和后验概率下能够最小化预期损失的解释。使用此决策规则，确定哪个等位基因被视为重复，并通过将来自每个等位基因类别的每个拷贝的贡献相加来计算最终的 CYP2D6 活性得分。将最终活性得分表示为一个无单位的标量，并四舍五入到三位有效数字。",
            "solution": "用户要求我解决一个涉及药物基因组学解释的问题，具体是在不确定性下计算 CYP2D6 活性得分。这需要使用决策论方法来处理有歧义的拷贝数变异数据。\n\n### 步骤 1：验证问题陈述\n\n我将首先提取已知条件，然后验证问题的科学合理性、适定性和客观性。\n\n**提取的已知条件：**\n-   基因：细胞色素 P450 家族 2 亚家族 D 成员 6 (CYP2D6)\n-   正常功能等位基因活性值：$1$\n-   功能减退等位基因活性值：$0.5$\n-   无功能等位基因活性值：$0$\n-   患者的基本基因型：一个正常功能等位基因，一个功能减退等位基因。\n-   拷贝数变异 (CNV)：一次重复导致总共有 $3$ 个基因拷贝。\n-   歧义性：正常功能等位基因或功能减退等位基因被重复。\n-   $p_{N}$：正常功能等位基因被重复的后验概率。$p_{N} = 0.38$。\n-   $p_{D}$：功能减退等位基因被重复的后验概率。$p_{D} = 0.62$。\n-   约束条件：$p_{N} + p_{D} = 1$。\n-   决策框架：基于安全优先的错分框架最小化预期损失。\n-   高估活性得分的惩罚：$\\lambda = 2$。\n-   低估活性得分的惩罚：$1$。\n-   任务：根据决策规则确定被重复的等位基因，并计算最终的 CYP2D6 活性得分。\n-   输出要求：最终得分必须是一个无单位的标量，并四舍五入到三位有效数字。\n\n**验证结论：**\n1.  **科学依据**：该问题基于既有的药物基因组学原理，特别是临床药物遗传学实施联盟 (CPIC) 的指南和 PharmGKB 数据库的使用。星号等位基因、活性得分和 CYP2D6 拷贝数变异等概念是该领域的标准。应用包括后验概率和损失函数以管理不确定性的贝叶斯决策理论是一种严谨且有效的统计方法。\n2.  **适定性**：该问题是适定的。它提供了所有必要的数据（等位基因活性、概率、惩罚）和一个清晰、无歧义的目标（最小化预期损失）。可以确定唯一的解。\n3.  **客观性**：问题以精确、量化和无偏见的语言陈述。\n\n该问题有效。我现在将继续进行求解。\n\n### 步骤 2：构建解决方案\n\n该问题要求我们对患者基因型的两种可能解释做出决策，然后计算相应的活性得分。决策将通过选择能最小化预期损失的解释来做出。\n\n**1. 定义自然状态及相应的活性得分**\n\n存在两种互斥的自然状态，对应两种可能的重复事件。\n\n-   **状态 $S_{N}$**：正常功能等位基因被重复。\n    在此情况下，患者拥有两个正常功能等位基因拷贝和一个功能减退等位基因拷贝。总活性得分 $A_N$ 是各个等位基因活性值的总和：\n    $$A_N = (2 \\times 1) + (1 \\times 0.5) = 2 + 0.5 = 2.5$$\n    此状态的概率为给定的后验概率，$P(S_{N}) = p_{N} = 0.38$。\n\n-   **状态 $S_{D}$**：功能减退等位基因被重复。\n    在此情况下，患者拥有一个正常功能等位基因拷贝和两个功能减退等位基因拷贝。总活性得分 $A_D$ 为：\n    $$A_D = (1 \\times 1) + (2 \\times 0.5) = 1 + 1 = 2.0$$\n    此状态的概率为 $P(S_{D}) = p_{D} = 0.62$。\n\n我们注意到，$A_N = 2.5$ 代表了高活性的解释，而 $A_D = 2.0$ 代表了低活性的解释。\n\n**2. 定义行动和损失函数**\n\n我们必须在两种可能的行动（解释）中选择一种。\n-   **行动 $D_N$**：结论为正常功能等位基因被重复，分配活性得分为 $A_N = 2.5$。\n-   **行动 $D_D$**：结论为功能减退等位基因被重复，分配活性得分为 $A_D = 2.0$。\n\n损失函数 $L(\\text{行动}, \\text{真实状态})$ 由给定的错分惩罚定义。\n-   如果我们选择 $D_N$ 而真实状态是 $S_D$，我们就高估了活性。损失为 $L(D_N, S_D) = 2$。\n-   如果我们选择 $D_D$ 而真实状态是 $S_N$，我们就低估了活性。损失为 $L(D_D, S_N) = 1$。\n-   如果选择的行动与真实状态相符，则分类正确，损失为 $0$。因此，$L(D_N, S_N) = 0$ 且 $L(D_D, S_D) = 0$。\n\n**3. 计算每个行动的预期损失**\n\n一个行动的预期损失是每种可能状态的损失与其概率加权的总和。\n\n-   **行动 $D_N$ (选择较高得分) 的预期损失：**\n    $$E[L(D_N)] = L(D_N, S_N) P(S_N) + L(D_N, S_D) P(S_D)$$\n    $$E[L(D_N)] = (0 \\times p_{N}) + (2 \\times p_{D})$$\n    代入给定的概率：\n    $$E[L(D_N)] = 2 \\times 0.62 = 1.24$$\n\n-   **行动 $D_D$ (选择较低得分) 的预期损失：**\n    $$E[L(D_D)] = L(D_D, S_N) P(S_N) + L(D_D, S_D) P(S_D)$$\n    $$E[L(D_D)] = (1 \\times p_{N}) + (0 \\times p_{D})$$\n    代入给定的概率：\n    $$E[L(D_D)] = 1 \\times 0.38 = 0.38$$\n\n**4. 做出决策并确定最终活性得分**\n\n决策规则是选择使预期损失最小化的行动。我们比较预期损失：\n$$E[L(D_D)] = 0.38$$\n$$E[L(D_N)] = 1.24$$\n因为 $0.38  1.24$，所以有 $E[L(D_D)]  E[L(D_N)]$. 最优行动是 $D_D$。\n\n这个决策对应于**功能减退等位基因被重复**的解释。因此，最终的 CYP2D6 活性得分是 $A_D$。\n$$A_D = 2.0$$\n问题要求答案四舍五入到三位有效数字。数值 $2.0$ 可以写成 $2.00$ 来明确表示三位有效数字。\n\n最终活性得分为 $2.00$。",
            "answer": "$$\\boxed{2.00}$$"
        },
        {
            "introduction": "最后，我们将视角从药物基因组学信息的“使用者”转变为“提供者”。一个强大的信息资源不仅在于其内容的准确性，还在于其数据的可访问性和可计算性。本练习 () 要求您设计一个 RESTful API 的核心逻辑，用于查询基因-药物关联，这挑战您思考如何对复杂的药物基因组学数据进行结构化、规范化和有序化，使其能够被临床决策支持系统等下游应用高效利用。",
            "id": "4367504",
            "problem": "您的任务是，从第一性原理出发，为一种表征状态转移（REST）风格的查询形式化其逻辑，该查询用于查询根据本地目录构建的药物基因组学基因-药物关联，该目录反映了药物基因组学知识库（PharmacoGenomics Knowledge Base, PharmGKB）的内容。端点设计在概念上是一个形式为“/genes/{symbol}/associations”的统一资源标识符，并且必须满足幂等检索语义。响应必须以确定性的、机器可读的数字形式编码证据等级、表型标识符和关联的指南标识符，并符合以下约束。\n\n基本原理：\n- 在药物基因组学中，基因-药物关联描述了基因变异如何影响临床结果（例如，药物疗效或毒性）。基因根据中心法则进行转录和翻译，而基因型到表型的关系已由药物基因组学知识库（PharmacoGenomics Knowledge Base, PharmGKB）等资源系统地整理。\n- 药物基因组学整理中的证据等级是序数类别（例如，等级 $1\\mathrm{A}$、等级 $1\\mathrm{B}$、等级 $2\\mathrm{A}$、等级 $2\\mathrm{B}$、等级 $3$、等级 $4$），按从等级 $1\\mathrm{A}$ 到等级 $4$ 的降序代表递减的证据强度。序数类别允许单调映射为适合计算的整数。\n- 根据定义，RESTful \"GET\" 查询是只读且幂等的：使用相同参数的重复检索会产生相同的表示。\n\n您必须实现一个确定性转换 $f$，它将输入的基因符号字符串 $g$ 转换为三个数组：\n- $E(g)$，一个整数证据代码列表，针对目录中与 $g$ 关联的所有唯一基因-药物对，按证据从强到弱的顺序排列。\n- $P(g)$，一个 $g$ 的整数表型标识符列表，经去重并按升序排列。\n- $G(g)$，一个 $g$ 的整数指南标识符列表，经去重并按升序排列。\n\n该转换必须使用以下形式化规则来定义：\n1. 规范化：设 $n(g)$ 是通过大写转换和修剪空白字符得到的规范化基因符号。通过 $n(g)$ 实现的查询匹配是大小写不敏感和空白不敏感的。\n\n2. 证据映射：设 $s:\\{\\text{\"1A\"},\\text{\"1B\"},\\text{\"2A\"},\\text{\"2B\"},\\text{\"3\"},\\text{\"4\"}\\}\\to\\mathbb{Z}$ 为序数映射\n   $$s(\\text{\"1A\"})=5,\\quad s(\\text{\"1B\"})=4,\\quad s(\\text{\"2A\"})=3,\\quad s(\\text{\"2B\"})=2,\\quad s(\\text{\"3\"})=1,\\quad s(\\text{\"4\"})=0.$$\n\n3. 基因-药物对去重：如果同一 $(\\text{gene},\\text{drug})$ 对存在多个条目，则将其合并为单个关联，其证据是这些条目中 $s(e)$ 的最大值，其表型和指南标识符是这些条目的并集。\n\n4. $E(g)$ 的排序：设 $\\mathcal{A}(g)$ 为规则3处理后 $g$ 的唯一 $(\\text{drug}, s(e))$ 对集合。按 $-s(e)$ 对 $\\mathcal{A}(g)$ 进行排序，若值相等，则按药物字符串的字典序作为决胜规则。将 $E(g)$ 定义为该排序顺序中 $s(e)$ 值的列表。\n\n5. 表型：一个受控词汇表将表型标签映射到整数标识符。使用的映射如下：\n   - \"poor metabolizer\" $\\mapsto$ $10$\n   - \"intermediate metabolizer\" $\\mapsto$ $20$\n   - \"normal metabolizer\" $\\mapsto$ $30$\n   - \"deficient enzyme activity\" $\\mapsto$ $40$\n   - \"risk of hemolysis\" $\\mapsto$ $50$\n   - \"toxicity risk\" $\\mapsto$ $60$\n   - \"hypersensitivity risk\" $\\mapsto$ $70$\n   将 $P(g)$ 定义为规则3处理后，$g$ 的任何关联中出现的所有唯一表型标识符的升序排序列表。\n\n6. 指南标识符：指南标识符是整数。它们可能反映了诸如临床药理遗传学实施联盟（Clinical Pharmacogenetics Implementation Consortium, CPIC）或荷兰药物遗传学工作组（Dutch Pharmacogenetics Working Group, DPWG）等来源。将 $G(g)$ 定义为规则3处理后，$g$ 的任何关联中出现的所有唯一指南标识符的升序排序列表。如果一个关联没有指南标识符，则它对 $G(g)$ 没有贡献。\n\n7. 未知符号：如果 $n(g)$ 在目录中没有关联，则将 $E(g), P(g), G(g)$ 定义为空列表。\n\n扁平化输出编码：\n- 对于程序输出，每个测试用例必须编码为包含以下拼接内容的单个扁平化整数列表：\n  $$[|E(g)|, E(g), |P(g)|, P(g), |G(g)|, G(g)],$$\n  其中 $|X|$ 表示列表 $X$ 的基数。如果 $|X|=0$，则其长度标记后不跟任何 $X$ 的元素。\n\n您的程序必须使用以下固定的本地目录（反映了药物基因组学中整理的貌似合理且广为人知的基因-药物关联）：\n- (gene: \"CYP2C19\", drug: \"clopidogrel\", evidence: \"1A\", phenotypes: [\"poor metabolizer\"], guideline IDs: [$1001$, $2001$])\n- (gene: \"CYP2C19\", drug: \"voriconazole\", evidence: \"2A\", phenotypes: [\"poor metabolizer\"], guideline IDs: [$1002$])\n- (gene: \"CYP2C19\", drug: \"clopidogrel\", evidence: \"2B\", phenotypes: [\"intermediate metabolizer\"], guideline IDs: [$2001$])\n- (gene: \"TPMT\", drug: \"thiopurines\", evidence: \"1A\", phenotypes: [\"deficient enzyme activity\"], guideline IDs: [$1003$])\n- (gene: \"G6PD\", drug: \"primaquine\", evidence: \"2A\", phenotypes: [\"risk of hemolysis\"], guideline IDs: [$2002$])\n- (gene: \"SLCO1B1\", drug: \"simvastatin\", evidence: \"1A\", phenotypes: [\"toxicity risk\"], guideline IDs: [$1004$])\n- (gene: \"HLA-B\", drug: \"abacavir\", evidence: \"1A\", phenotypes: [\"hypersensitivity risk\"], guideline IDs: [$1005$, $3001$])\n- (gene: \"DPYD\", drug: \"fluorouracil\", evidence: \"1A\", phenotypes: [\"toxicity risk\"], guideline IDs: [$1006$, $2003$])\n- (gene: \"VKORC1\", drug: \"warfarin\", evidence: \"1A\", phenotypes: [\"toxicity risk\"], guideline IDs: [$1007$])\n- (gene: \"CYP2D6\", drug: \"codeine\", evidence: \"2A\", phenotypes: [\"poor metabolizer\"], guideline IDs: [$1008$])\n- (gene: \"CYP2D6\", drug: \"tramadol\", evidence: \"3\", phenotypes: [\"poor metabolizer\"], guideline IDs: [])\n\n测试套件：\n- 案例 $1$：$g=$ \"CYP2C19\"（正常路径，包含重复的 $(\\text{gene},\\text{drug})$ 条目和冲突的证据，以测试规则 $3$）。\n- 案例 $2$：$g=$ \"TPMT\"（单个强关联）。\n- 案例 $3$：$g=$ \"G6PD\"（中等强度证据）。\n- 案例 $4$：$g=$ \"CYP2D6\"（混合关联，其中一个没有指南标识符，以测试规则 $6$）。\n- 案例 $5$：$g=$ \"XYZ\"（未知基因符号，以测试规则 $7$）。\n\n答案规范：\n- 您的程序必须为每个测试用例计算如上定义的扁平化编码。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且本身也是一个用方括号括起来且只包含整数的逗号分隔列表（例如，“[[...],[...],...]”）。\n- 不涉及物理单位、角度或百分比；所有输出均为整数。\n\n该问题要求您从上述基本定义出发，推导并实现转换 $f$ 及相关的数据处理，以确保对于给定的目录和测试套件，输出是幂等的、确定性的且排序正确的。",
            "solution": "问题陈述经过严格审查，被确定为**有效**。它在科学上基于药物基因组学的原理，问题设定良好，具有一套完整且一致的规则，并以客观、形式化的语言表述。它提供了推导出唯一且可验证解所需的所有必要数据和定义。\n\n任务是实现一个确定性转换（表示为 $f$），它将一个基因符号字符串 $g$ 映射到三个有序的整数列表：$E(g)$（证据代码）、$P(g)$（表型标识符）和 $G(g)$（指南标识符）。该转换必须遵守一套关于数据规范化、聚合和排序的特定规则，这些规则反映了生物信息学数据整理的实践。最终输出必须是一个扁平化的整数列表。\n\n此转换 $f(g)$ 的实现是通过一系列数据处理步骤来设计的，这些步骤直接源自所提供的规则。\n\n**1. 数据表示**\n\n首先，将固定的本地目录和指定的映射形式化为适合计算的数据结构。目录表示为记录列表，而证据和表型映射则表示为键值字典。\n\n-   **证据映射 $s$**：一个将证据等级字符串映射到其定义的整数序数的字典：$s(\\text{\"1A\"}) = 5, s(\\text{\"1B\"}) = 4, \\dots, s(\\text{\"4\"}) = 0$。\n-   **表型映射**：一个将表型标签（例如，“poor metabolizer”）映射到其整数标识符（例如，$10$）的字典。\n\n**2. 算法转换 $f(g)$**\n\n解决方案的核心是一个根据规则处理输入基因符号 $g$ 的函数。\n\n**步骤 2.1：规范化与筛选**\n\n根据规则1，输入的基因符号 $g$ 首先通过转换为大写并移除首尾空白字符来规范化为 $n(g)$。这确保了匹配不区分大小写和空白字符。然后筛选本地目录，以检索与规范化基因 $n(g)$ 对应的所有记录。\n\n如果找不到 $n(g)$ 的记录，则根据规则7，该基因的处理终止。函数为 $E(g)$、$P(g)$ 和 $G(g)$ 返回三个空列表。\n\n**步骤 2.2：聚合与去重**\n\n此步骤实现规则3，这对于确保每个唯一的基因-药物对都由一个单一的、合并后的关联来表示至关重要。这是生物信息学数据库中呈现最相关和最强证据的常见要求。我们创建一个中间数据结构，即一个字典，其中药物名称作为键。与每个键关联的值是一个对象，该对象聚合了该特定基因-药物对的证据、表型和指南标识符。\n\n对于从筛选出的、与基因 $n(g)$ 关联的目录中的每个条目：\n-   识别出药物名称。\n-   如果该药物尚未在我们的聚合字典中，则为其创建一个新条目。\n-   证据等级被映射为其整数代码 $s(e)$。聚合逻辑将药物的存储证据更新为当前和新证据代码的最大值：$\\max(s(e)_{\\text{current}}, s(e)_{\\text{new}})$。\n-   使用集合的并集操作来累积关联的表型和指南标识符集合。使用集合自然地处理了去重。\n\n遍历完该基因的所有目录条目后，此字典包含每个唯一基因-药物关联的合并数据。\n\n**步骤 2.3：证据向量 $E(g)$ 的生成**\n\n此步骤实现规则4。目标是生成一个有序的证据代码列表。\n-   首先，从聚合数据中构建一个 $(\\text{drug}, s(e))$ 对的列表。这对应于集合 $\\mathcal{A}(g)$。\n-   此列表根据指定的两级标准进行排序：\n    1.  主排序键：证据代码 $s(e)$ 的降序，等同于 $-s(e)$ 的升序。\n    2.  次排序键（决胜规则）：药物名称的升序字典序。\n-   最终的证据列表 $E(g)$ 是通过从此排序后的对列表中提取证据代码来创建的。\n\n**步骤 2.4：表型向量 $P(g)$ 和指南向量 $G(g)$ 的生成**\n\n此步骤实现规则5和6。\n-   从基因 $n(g)$ 的聚合关联中收集所有唯一的表型标签和指南标识符。这是通过对与该基因关联的所有药物的表型和指南ID集合取并集来实现的。\n-   然后，使用提供的表型映射，将收集到的表型标签集合映射到其对应的整数标识符。\n-   最后，将得到的表型标识符集合转换为列表并按升序排序以生成 $P(g)$。指南标识符集合也转换为列表并按升序排序以生成 $G(g)$。规则6被隐式处理，因为没有指南标识符的关联在并集运算中贡献一个空集，因此没有影响。\n\n**步骤 2.5：最终输出编码**\n\n按照规定，将生成的三个列表 $E(g)$、$P(g)$ 和 $G(g)$ 合并为一个扁平化的列表作为最终输出。格式是一个自描述的整数序列：`[`$|E(g)|, E(g) \\text{的元素}, |P(g)|, P(g) \\text{的元素}, |G(g)|, G(g) \\text{的元素}$`]`。每个列表 $X$ 的基数 $|X|$ 位于该列表的元素之前，这使得解析器能够无歧义地读取序列化数据。如果列表为空，其基数为 $0$，并且后面不跟任何元素。对测试套件中的每个基因符号重复整个过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints pharmacogenomic association data for a test suite of genes\n    based on a fixed local catalog and a set of formal rules.\n    \"\"\"\n    \n    # Fixed local catalog reflecting plausible pharmacogenomic associations.\n    CATALOG = [\n        {\"gene\": \"CYP2C19\", \"drug\": \"clopidogrel\", \"evidence\": \"1A\", \"phenotypes\": [\"poor metabolizer\"], \"guideline_ids\": [1001, 2001]},\n        {\"gene\": \"CYP2C19\", \"drug\": \"voriconazole\", \"evidence\": \"2A\", \"phenotypes\": [\"poor metabolizer\"], \"guideline_ids\": [1002]},\n        {\"gene\": \"CYP2C19\", \"drug\": \"clopidogrel\", \"evidence\": \"2B\", \"phenotypes\": [\"intermediate metabolizer\"], \"guideline_ids\": [2001]},\n        {\"gene\": \"TPMT\", \"drug\": \"thiopurines\", \"evidence\": \"1A\", \"phenotypes\": [\"deficient enzyme activity\"], \"guideline_ids\": [1003]},\n        {\"gene\": \"G6PD\", \"drug\": \"primaquine\", \"evidence\": \"2A\", \"phenotypes\": [\"risk of hemolysis\"], \"guideline_ids\": [2002]},\n        {\"gene\": \"SLCO1B1\", \"drug\": \"simvastatin\", \"evidence\": \"1A\", \"phenotypes\": [\"toxicity risk\"], \"guideline_ids\": [1004]},\n        {\"gene\": \"HLA-B\", \"drug\": \"abacavir\", \"evidence\": \"1A\", \"phenotypes\": [\"hypersensitivity risk\"], \"guideline_ids\": [1005, 3001]},\n        {\"gene\": \"DPYD\", \"drug\": \"fluorouracil\", \"evidence\": \"1A\", \"phenotypes\": [\"toxicity risk\"], \"guideline_ids\": [1006, 2003]},\n        {\"gene\": \"VKORC1\", \"drug\": \"warfarin\", \"evidence\": \"1A\", \"phenotypes\": [\"toxicity risk\"], \"guideline_ids\": [1007]},\n        {\"gene\": \"CYP2D6\", \"drug\": \"codeine\", \"evidence\": \"2A\", \"phenotypes\": [\"poor metabolizer\"], \"guideline_ids\": [1008]},\n        {\"gene\": \"CYP2D6\", \"drug\": \"tramadol\", \"evidence\": \"3\", \"phenotypes\": [\"poor metabolizer\"], \"guideline_ids\": []}\n    ]\n\n    # Rule 2: Evidence mapping from ordinal categories to integers.\n    EVIDENCE_MAPPING = {\"1A\": 5, \"1B\": 4, \"2A\": 3, \"2B\": 2, \"3\": 1, \"4\": 0}\n\n    # Rule 5: Phenotype mapping from controlled vocabulary to integer identifiers.\n    PHENOTYPE_MAPPING = {\n        \"poor metabolizer\": 10,\n        \"intermediate metabolizer\": 20,\n        \"normal metabolizer\": 30,\n        \"deficient enzyme activity\": 40,\n        \"risk of hemolysis\": 50,\n        \"toxicity risk\": 60,\n        \"hypersensitivity risk\": 70,\n    }\n\n    def process_gene(gene_symbol: str) - tuple[list[int], list[int], list[int]]:\n        \"\"\"\n        Applies the transformation f(g) to a single gene symbol.\n        \n        Args:\n            gene_symbol: The gene symbol string g.\n\n        Returns:\n            A tuple containing the lists E(g), P(g), and G(g).\n        \"\"\"\n        # Rule 1: Normalization\n        normalized_symbol = gene_symbol.strip().upper()\n\n        # Filter catalog for the normalized gene symbol\n        gene_entries = [entry for entry in CATALOG if entry[\"gene\"] == normalized_symbol]\n\n        # Rule 7: Handle unknown symbols\n        if not gene_entries:\n            return [], [], []\n\n        # Rule 3: Deduplication and aggregation of gene-drug pairs\n        aggregated_associations = {}\n        for entry in gene_entries:\n            drug = entry[\"drug\"]\n            evidence_code = EVIDENCE_MAPPING[entry[\"evidence\"]]\n            \n            if drug not in aggregated_associations:\n                aggregated_associations[drug] = {\n                    \"evidence_code\": -1,  # Sentinel for max operation\n                    \"phenotypes\": set(),\n                    \"guideline_ids\": set()\n                }\n            \n            # Collapse to single association with max evidence\n            aggregated_associations[drug][\"evidence_code\"] = max(\n                aggregated_associations[drug][\"evidence_code\"],\n                evidence_code\n            )\n            # Union phenotypes and guideline IDs\n            aggregated_associations[drug][\"phenotypes\"].update(entry[\"phenotypes\"])\n            aggregated_associations[drug][\"guideline_ids\"].update(entry[\"guideline_ids\"])\n\n        # Rule 4: Generate and order E(g)\n        # Create list of (drug_name, evidence_code) for sorting\n        associations_for_sorting = [\n            (drug, data[\"evidence_code\"]) for drug, data in aggregated_associations.items()\n        ]\n        # Sort by -evidence_code (descending), then by drug name (ascending)\n        associations_for_sorting.sort(key=lambda x: (-x[1], x[0]))\n        e_g = [item[1] for item in associations_for_sorting]\n        \n        # Rules 5  6: Generate P(g) and G(g)\n        all_phenotypes = set()\n        all_guideline_ids = set()\n        for data in aggregated_associations.values():\n            all_phenotypes.update(data[\"phenotypes\"])\n            all_guideline_ids.update(data[\"guideline_ids\"])\n            \n        # Map phenotype labels to codes, then create sorted unique list\n        p_g_codes = {PHENOTYPE_MAPPING[pheno] for pheno in all_phenotypes}\n        p_g = sorted(list(p_g_codes))\n        \n        # Create sorted unique list of guideline IDs\n        g_g = sorted(list(all_guideline_ids))\n        \n        return e_g, p_g, g_g\n\n    # Test suite from the problem statement\n    test_cases = [\n        \"CYP2C19\",\n        \"TPMT\",\n        \"G6PD\",\n        \"CYP2D6\",\n        \"XYZ\",\n    ]\n\n    final_results = []\n    for gene_symbol in test_cases:\n        e_g, p_g, g_g = process_gene(gene_symbol)\n        \n        # Assemble the flattened output encoding for the current test case\n        flattened_list = [len(e_g)] + e_g + [len(p_g)] + p_g + [len(g_g)] + g_g\n        \n        # Format the integer list as a string \"[i,j,k,...]\"\n        formatted_case_result = f\"[{','.join(map(str, flattened_list))}]\"\n        final_results.append(formatted_case_result)\n        \n    # Print the final output in the exact required format: \"[[...],[...],...]\"\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```"
        }
    ]
}