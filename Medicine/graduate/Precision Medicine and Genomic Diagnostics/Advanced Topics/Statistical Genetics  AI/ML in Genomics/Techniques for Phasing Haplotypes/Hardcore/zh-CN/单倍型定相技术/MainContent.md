## 引言
在基因组学时代，高通量测序技术使我们能够以前所未有的精度和规模获取个体的遗传变异信息。然而，标准的测序流程通常只能提供一个基因座上两个等位基因的“基因型”，却丢失了这些变异在亲本染色体上的原始排列信息，即“单倍型”。单倍型定相（Haplotype Phasing）正是解决这一问题的关键技术，它旨在重建构成个体基因组的两条完整的单倍型序列。这一过程的重要性不容小觑，因为它直接关系到我们能否将离散的变异列表转化为具有生物学意义的遗传蓝图。

本文所要解决的核心知识缺口，在于标准基因分型与完整生物学功能之间的鸿沟。例如，在一个与隐性[遗传病](@entry_id:273195)相关的基因中发现两个不同的致病变异时，若无法确定它们是位于同一条染色体（顺式）还是不同染色体（反式），临床诊断就会陷入不确定性。同样，在药物基因组学中，多个变异的组合决定了药物代谢酶的活性，而错误的相位判断可能导致灾难性的用药决策。因此，掌握单倍型定相技术，是从基因型到精准表型预测的必经之路。

为了帮助读者全面掌握这一领域，本文将分为三个核心部分。在“原理与机制”一章中，我们将深入探讨单倍型定相的数学基础、核心概念以及三大主流技术（基于遗传、群体和读长）的内在逻辑。随后，在“应用与跨学科连接”一章中，我们将展示这些技术如何在临床诊断、肿瘤学、[群体遗传学](@entry_id:146344)等领域解决实际问题，并与其他前沿学科交叉融合。最后，通过“动手实践”部分，读者将有机会亲手应用这些知识，巩固对关键算法和评估指标的理解。

## 原理与机制

本章旨在系统阐述单倍型定相的核心原理与关键机制。在上一章介绍背景知识的基础上，我们将深入探讨单倍型定相的数学形式、临床意义、主要技术方法及其准确性评估。我们将从基本定义出发，逐步剖析基于遗传规律、群体统计信息和直接分子证据的各种定相策略，并通过具体的计算实例来阐明其内在逻辑。

### 单倍型定相的基本概念

在深入探讨技术细节之前，我们必须首先精确定义什么是单倍型，以及为什么确定单倍型（即“定相”）在遗传学和精准医学中至关重要。

#### 单倍型的形式化表示

在[二倍体](@entry_id:268054)生物中，每个常染色体基因座都存在两个同源染色体。**单倍型 (haplotype)** 是指在单条同源染色体上沿序列排列的一组等位基因。相应地，一个基因座上的两条同源染色体所携带的一对单倍型被称为**双倍型 (diplotype)**。定相 (phasing) 的过程，本质上就是确定一个在多个杂合位点观察到的等位基因，究竟分别属于哪一条同源染色体，从而重建原始的两条单倍型序列。

为了进行计算分析，我们需要一个严谨的数学框架来描述这一概念。考虑一个包含 $m$ 个杂合变异位点的染色体区域，位点集合为 $S = \{p_1, \dots, p_m\}$。在每个位点上，等位基因可以用一个字母表 $\mathcal{A} = \{0, 1\}$ 来表示，其中 $0$ 代表参考等位基因，$1$ 代表变异等位基因。

一个完整的单倍型可以被形式化地表示为一个函数 $h: S \to \{0, 1\}$，该函数为集合 $S$ 中的每个位点分配一个等位基因。由于[二倍体](@entry_id:268054)生物拥有两条同源染色体，一个经过定相的双倍型可以表示为一个[有序对](@entry_id:269702) $(h_1, h_2)$，其中 $h_1$ 和 $h_2$ 都是从 $S$到$\{0, 1\}$ 的函数。

这些位点被假定为杂合的，这意味着在每个位点 $p \in S$，两条染色体上的等位基因必须不同。这一生物学约束可以通过一个简单的代数关系来表达：对于所有的 $p \in S$，必须满足 $h_1(p) + h_2(p) = 1$。这个约束意味着一条单倍型在所有杂合位点上都是另一条单倍型的“反向互补”序列。如果我们用 $\bar{h}$ 表示 $h$ 的互补序列，那么任何一个定相后的双倍型都具有 $(h, \bar{h})$ 的形式。

此外，生物学的现实是，将两条同源染色体任意标记为“第一条”或“第二条”并不会改变个体的遗传状态。因此，[有序对](@entry_id:269702) $(h_1, h_2)$ 和 $(h_2, h_1)$ 在生物学上是等价的。这种等价性必须通过一个[等价关系](@entry_id:138275)来捕捉。我们定义两个[有序对](@entry_id:269702) $(h_1, h_2)$ 和 $(h_1', h_2')$ 是等价的，记作 $(h_1, h_2) \sim (h_1', h_2')$，当且仅当 $(h_1', h_2')$ 可以通过交换 $(h_1, h_2)$ 的元素得到。因此，一个给定双倍型 $(h_1, h_2)$ 的等价类是集合 $\{(h_1, h_2), (h_2, h_1)\}$。只要存在至少一个杂合位点 ($m \ge 1$)，该[等价类](@entry_id:156032)就包含两个不同的[有序对](@entry_id:269702) 。理解这种表示方法与内在的对称性，是后续所有定相算法的基础。

#### 复合杂合性与临床意义

单倍型定相不仅是一个计算问题，更具有深远的临床意义，尤其是在[常染色体隐性遗传](@entry_id:270708)病的诊断中。这类疾病通常要求一个基因的两个拷贝（等位基因）同时失去功能，即所谓的**双等位基因失活 (biallelic inactivation)**。

当通过外显子组测序（WES）或基因组测序（WGS）在一个与隐性[遗传病](@entry_id:273195)相关的基因（例如基因 $G$）中发现两个不同的杂合致病性变异（$v_1$ 和 $v_2$）时，一个关键问题随之而来：这两个变异在染色体上的相对位置如何？存在两种可能性：

1.  **顺式构型 (cis configuration)**：两个变异位于同一条同源染色体上。这意味着一个单倍型携带了 $(v_1, v_2)$，而另一个单倍型在相应位置是野生型的。在这种情况下，个体仍然拥有一条功能完好的基因拷贝，通常不会表现出隐性[遗传病](@entry_id:273195)，而仅仅是携带者。

2.  **反式构型 (trans configuration)**：两个变异位于不同的同源染色体上。即一个单倍型携带 $(v_1, \text{野生型})$，另一个携带 $(\text{野生型}, v_2)$。如果 $v_1$ 和 $v_2$ 都是功能丧失性变异，这种构型将导致该个体没有任何功能正常的基因拷贝，从而引发疾病。这种状态被称为**复合杂合性 (compound heterozygosity)**。

因此，区分顺式和反式构型，即进行单倍型定相，对于确定这两个变异是否是致病原因至关重要。仅仅在两个位点上观察到约 $50\%$ 的变异[等位基因频率](@entry_id:146872)（VAF）是不足以区分这两种情况的，因为无论顺式还是反式，每个位点的VAF理论上都应接近 $50\%$。

例如，一个临床案例中，在某个基因中发现了两个相距约 $600$ 个碱基对（bp）的杂合变异。如果使用的是读长为 $2 \times 150$ bp、平均插入片段大小为 $350$ bp 的标准短读长测序，由于插入片段长度（$350$ bp）远小于变异间距（$600$ bp），几乎不可能有任何单个测序片段能同时覆盖这两个变异。因此，仅凭这些数据无法进行基于读长的定相。在这种情况下，必须借助其他方法，如利用父母遗传信息进行定相，或者采用**[长读长测序](@entry_id:268696)技术**（如ONT或[PacBio](@entry_id:264261) SMRT），其产生的单分子读长可达数千甚至上万个碱基，能够轻松跨越 $600$ bp的距离，从而直接观察到两个变异是否在同一条DNA分子上，明确其顺式/反式关系 。

### 单倍型定相的主要方法

单倍型定相的方法可以大致分为三类：基于遗传规律的方法、基于群体统计的方法和基于测序读长的方法。这些方法利用不同来源的信息来解析等位基因在染色体上的连锁关系。

#### 基于遗传规律的定相

基于遗传规律的定相，特别是利用**核心家系（trio）**——即父母和子女——的数据，是最可靠的定相方法之一。其基本原理是孟德尔遗传定律：子女从父母双方各继承一条单倍型。

考虑一个简单的场景，涉及两个连锁的基因座，等位基因分别为 $A/a$ 和 $B/b$。假设父母和子女在这两个基因座上都是双重杂合子（基因型均为 $A/a, B/b$）。我们的目标是确定父母和子女的单倍型构型（即是顺式 $AB/ab$ 还是反式 $Ab/aB$）。

要使子女的基因型为 $A/a, B/b$，其从母亲处获得的配子 ($G_M$) 和从父亲处获得的配子 ($G_F$) 必须是互补的。例如，如果母亲提供了 $AB$ 配子，父亲就必须提供 $ab$ 配子。所有能产生 $A/a, B/b$ 子女的配子组合共有四种：$(G_M, G_F)$ 可以是 $(AB, ab)$、$(ab, AB)$、$(Ab, aB)$ 或 $(aB, Ab)$。

同时，父母双方也各有两种可能的单倍型构型（顺式或反式）。一个完整的家系定相配置需要明确母亲的构型、父亲的构型以及他们分别传递给子女的配子。假定基因座间的重组率 $r$ 满足 $0 \lt r \lt 1$，这意味着父母可以产生亲本型和重组型的配子。

综合考虑，母亲有两种构型选择，父亲有两种构型选择，而传递给子女的配子组合有四种。由于任何一种配子（亲本型或重组型）都可以由任何一种构型（顺式或反式）的父母产生，所有这些选择都是相互独立的。因此，在这种特定情况下，总共存在 $2 \times 2 \times 4 = 16$ 种符合孟德尔遗传定律的家系定相配置 。通过分析家系中其他成员的基因型或使用更密集的标记，通常可以排除大部分可能性，从而精确推断出单倍型。

#### 基于群体的统计定相

当家系数据不可用时，我们可以利用大规模参考群体中的统计信息进行定相，这种方法称为统计定相。其核心原理是**[连锁不平衡](@entry_id:146203) (Linkage Disequilibrium, LD)**。

LD是指在一个群体中，不同基因座上的等位基因之间的非随机关联。如果两个位点（例如 $A/a$ 和 $B/b$）完全独立，那么 $AB$ 单倍型在群体中的频率 ($f_{AB}$) 应该等于 $A$ 等位基因频率 ($p_A$) 与 $B$ 等位基因频率 ($p_B$) 的乘积，即 $f_{AB} = p_A p_B$。当观测到的单倍型频率偏离这个[期望值](@entry_id:150961)时，就存在连锁不平衡。

这种偏差的大小通常用LD系数 $D$ 来量化，其标准定义为：
$$ D = f_{AB} - p_A p_B $$
通过代数变换，可以证明一个等价且非常直观的表达形式：
$$ D = f_{AB} f_{ab} - f_{Ab} f_{aB} $$
这个公式表明，$D$ 值衡量了“耦合”单倍型（$AB$ 和 $ab$）的频率乘积与“排斥”单倍型（$Ab$ 和 $aB$）的频率乘积之间的差异。

LD的存在为统计定相提供了关键信息。对于一个未定相的、基因型为 $A/a, B/b$ 的个体，其真实的单倍型构型有两种可能：顺式 ($AB/ab$) 或反式 ($Ab/aB$)。在群体中，这两种构型的频率分别与 $2 f_{AB} f_{ab}$ 和 $2 f_{Ab} f_{aB}$ 成正比。因此，给定一个个体是双重杂合子，其构型为顺式的[条件概率](@entry_id:151013)与 $f_{AB} f_{ab}$ 成正比，而为反式的[条件概率](@entry_id:151013)与 $f_{Ab} f_{aB}$ 成正比。

当 $D \neq 0$ 时，$f_{AB} f_{ab} \neq f_{Ab} f_{aB}$，这意味着两种构型的可能性不再相等。
-   如果 $D > 0$，则 $AB/ab$ （顺式）构型更可能。
-   如果 $D  0$，则 $Ab/aB$ （反式）构型更可能。

因此，通过在一个大规模的**参考面板 (reference panel)**（例如千人基因组计划）中估计单倍型频率和LD模式，我们就可以对一个新的、未定相的个体进行概率推断，确定其最有可能的单倍型构型 。

现代统计定相算法（如IMPUTE、BEAGLE、SHAPEIT）正是基于这一原理，它们将个体的基因组视为由参考面板中存在的单倍型片段拼接而成的“马赛克”。根据 Li-Stephens 模型，一个目标个体的单倍型可以在局部窗口内被看作是参考面板中某些单倍型的拷贝。

定相的准确性很大程度上取决于参考面板的质量，特别是其规模和多样性。假设一个目标个体的两条真实单倍型为 $h_1$ 和 $h_2$，它们在群体中的频率分别为 $p$ 和 $q$。一个定相算法能够准确解析该个体的前提是，参考面板中必须同时包含 $h_1$ 和 $h_2$ 的至少一个拷贝。如果参考面板是从群体中随机抽取的 $n$ 条单倍型，那么定相成功的概率就可以被量化。

在只考虑一个局部窗口并忽略重组的简化模型下，我们可以推导出定相的预期准确率 $A(n)$。如果面板同时包含 $h_1$ 和 $h_2$，准确率为 $1$；否则，算法只能随机猜测，准确率为 $0.5$。最终，预期准确率可以表示为面板大小 $n$ 的函数：
$$ A(n) = \frac{1}{2} + \frac{1}{2}\left[1 - (1 - p)^n - (1 - q)^n + (1 - p - q)^n\right] $$
这个公式清晰地表明，随着面板大小 $n$ 的增加，同时包含 $h_1$ 和 $h_2$ 的概率（即方括号内的项）趋近于 $1$，从而使得总准确率 $A(n)$ 趋近于 $1$。这也解释了为什么在构建参考面板时，需要尽可能大的样本量和广泛的群体代表性 。

#### 基于测序读长的定相

与依赖[统计推断](@entry_id:172747)的群体方法不同，**基于读长的定相 (read-based phasing)** 利用的是直接的物理证据。当单个DNA分子被测序时，如果一个测序读长（或一对配对末端读长）同时跨越了两个或多个杂合位点，那么这些位点上的等位基因就被物理地连接在了一起，从而提供了它们位于同一条染色体上的直接证据。

**1. 局部定相与定相区块**

基于读长的定相通常只能在局部区域内可靠地进行。我们可以构建一个**连接图 (connectivity graph)**，其中每个节点代表一个杂合位点，如果至少有一个测序片段跨越了两个位点 $X_i$ 和 $X_j$，就在它们之间画一条边。这个图的**连通分量 (connected component)** 就定义了一个**定相区块 (phase block)**。

在一个定相区块内部，所有位点的[相对相位](@entry_id:148120)关系都可以被确定。例如，我们可以确定位点1的等位基因 $A$ 与位点2的等位基因 $T$ 在同一条染色体上。然而，这种**局部定相 (local phase)** 关系是相对的，我们无法仅凭这些信息断定这个 $A-T$ 单倍型是来自父亲还是母亲。

当两个相邻的杂合位点之间的距离超过了测序片段的跨度（例如，对于短读长测序是插入片段的大小，对于[长读长测序](@entry_id:268696)是读长本身），它们之间就无法形成连接。这就在定相区块之间造成了间隙。最终，一个染色体的定相结果通常是一系列独立的定相区块。要将这些区块连接起来，形成**染色体尺度定相 (chromosome-scale phase)**，就需要额外的长程信息，例如来自专门的长程连接技术（如Hi-C、Strand-seq）的信号，或者利用前述的遗传或群体信息来桥接这些区块 。

定相区块的大小直接受到测序技术参数的影响。假设两个相邻杂合位点相距为 $d$，测序片段的有效跨度为 $S$ ($d \le S$)，测序深度为 $D$。能够跨越这两个位点的片段数 $\lambda(d)$ 通常与 $D$ 和 $(S-d)$ 成正比。例如，对于长度为 $l$ 的单端读长，$\lambda(d) = D \times \frac{l-d}{l}$ 。根据泊松分布模型，在它们之间形成区块边界（即没有片段跨越）的概率是 $\exp(-\lambda(d))$。显然，增加[测序深度](@entry_id:178191) $D$ 或使用跨度更长的技术（增加 $S$），都能增加 $\lambda(d)$，从而降低区块边界出现的概率，得到更长、更连续的定相区块 。

**2. 读长定相的算法模型**

读长定相的算法主要分为两大类：[组合优化](@entry_id:264983)方法和概率统计方法。

*   **[组合优化](@entry_id:264983)方法：最小错误校正 (MEC)**

   组合方法将定相问题视为一个优化问题。一个核心模型是**最小错误校正 (Minimum Error Correction, MEC)**。其目标是找到一个假设的单倍型 $H$（及其互补的 $H^c$），使得所有测序读长与这对单倍型匹配所需的“校正”总数最小。这里的“校正”指的是将读长上的碱基翻转以使其与推定的单倍型完全一致。

   对于每个读长 $R_i$，它要么来自 $H$，要么来自 $H^c$。我们计算它与 $H$ 和 $H^c$ 在其覆盖位点上的[汉明距离](@entry_id:157657)（即不匹配的碱[基数](@entry_id:754020)），分别记为 $d(R_i, H)$ 和 $d(R_i, H^c)$。为了使 $R_i$ 与这对单倍型一致，所需的最小校正数是 $\min(d(R_i, H), d(R_i, H^c))$。MEC分数就是所有读长所需最小校正数的总和，对所有可能的单倍型 $H$ 取最小值。
   $$ \text{MEC} = \min_{H} \sum_{i} \min(d(R_i, H), d(R_i, H^c)) $$
   MEC问题通常是NP-hard的，但在实践中，可以通过各种[启发式算法](@entry_id:176797)、[整数线性规划](@entry_id:636600)或定参算法来求解。例如，对于一个包含三个读长 $R_1=(0,0,\varnothing)$, $R_2=(\varnothing,1,1)$, $R_3=(1,\varnothing,0)$ 的微型数据集，通过遍历所有 $2^{3-1}=4$ 种可能的单倍型构型，可以计算出MEC分数为 $1$ 。这表明，通过翻转数据矩阵中的一个碱基，就可以使所有读长与某一对假设的单倍型完美兼容。

*   **概率统计方法：似然计算**

   [概率方法](@entry_id:197501)则旨在计算不同定相假设的后验概率。这类方法的核心是建立一个能解释测序错误和等位基因不平衡等随机因素的[生成模型](@entry_id:177561)。

   考虑两个杂合SNP，我们需要判断它们是顺式构型 ($H_{\text{cis}}$) 还是反式构型 ($H_{\text{trans}}$)。我们可以根据观察到的读长数据（$n_{AB}, n_{ab}, n_{Ab}, n_{aB}$）和已知的测序错误率来计算这两种假设的[似然比](@entry_id:170863) $\Lambda = \frac{L(H_{\text{cis}} \mid \text{data})}{L(H_{\text{trans}} \mid \text{data})}$。

   测序错误率 $p$ 可以从碱基质量分数 $Q$ 中得出，即 $p = 10^{-Q/10}$。假设错误是独立的，我们可以计算在给定真实单倍型（如 $AB$）的情况下，观察到某种读长（如 $Ab$）的概率。例如，观察到 $Ab$ 需要在第一个位点读对，第二个位点读错，概率为 $(1-p)p$。

   通过对所有可能性进行加权平均（因为一个读长可能来自两条染色体中的任意一条），我们可以推导出在 $H_{\text{cis}}$ 和 $H_{\text{trans}}$ 假设下，观察到与假设“一致”的读长（如 $AB/ab$ 对 $H_{\text{cis}}$）和“不一致”的读长（如 $Ab/aB$ 对 $H_{\text{cis}}$）的概率 $\pi_C$ 和 $\pi_D$。最终，[似然比](@entry_id:170863)可以被简化为一个优美的形式：
   $$ \Lambda = \left(\frac{\pi_C}{\pi_D}\right)^{n_C - n_D} $$
   其中 $n_C$ 是与 $H_{\text{cis}}$ 一致的读长总数， $n_D$ 是不一致的读长总数。代入 $p=10^{-Q/10}$ 后，该公式直接将碱基质量、读长计数与定相的置信度联系起来 。当一致的读长远多于不一致的读长时（$n_C \gg n_D$），[似然比](@entry_id:170863)会非常大，强烈支持顺式构型。

### 定相准确性的评估

无论采用何种方法，对定相结果的质量进行评估都至关重要。最常用的两个指标是**转换错误 (switch error)** 和 **错配/汉明错误 (mismatch/Hamming error)**。

**转换错误 (Switch Error)** 衡量的是定相的局部一致性。一个转换错误发生在同一**定相区块内**的两个**相邻**杂合位点之间，如果它们预测的[相对相位](@entry_id:148120)与真实的[相对相位](@entry_id:148120)相反。换句话说，如果真实单倍型在位点 $i$ 和 $i+1$ 上是 `A-T`，而预测结果是 `A-C`（其中 `C` 是 `T` 在该位点的另一个等位基因），那么在 $i$ 和 $i+1$ 之间就发生了一次转换。**转换错误率 (Switch Error Rate, SER)** 定义为转换错误的总数除以可能发生转换的总机会数（即所有区块内相邻位点对的总数）。

**汉明错误 (Hamming Error)** 则衡量的是每个位点定相的绝对准确性。由于整个定相区块的父源标签（例如，“来自父亲”或“来自母亲”）是任意的，直接比较预测标签和真实标签可能会因为区块整体方向的错误反转而夸大错误数。因此，在计算汉明错误时，对于每个预测的定相区块，我们会比较其原始版本和整体翻转后的版本与真实单倍型的匹配情况，取其中不匹配位点数较少者作为该区块的汉明错误。**汉明错误率 (Hamming Error Rate, HER)** 是所有区块的汉明错误总数除以总的杂合位点数。

区块边界处的错误（有时称为 **末端转换 (end-switch)**）在两种评估中处理方式不同。转换错误率只关注区块内部的连接，因此不计算区块之间的错误。而汉明错误通过对每个区块进行最优翻转，实际上“吸收”了区块间的方向性错误，只关注区块内部的定相是否一致。

让我们通过一个实例来理解这两个指标的区别  。假设一个区域有6个杂合位点，真实单倍型（以0/1标签表示）为 `[0, 1, 0, 1, 0, 1]`。某个算法的预测结果分为两个区块：
-   区块1 (位点1-4): `[0, 1, 1, 0]`
-   区块2 (位点5-6): `[1, 0]`

*   **计算转换错误率 (SER)**:
    *   总机会数 = (区块1位点数 - 1) + (区块2位点数 - 1) = (4-1) + (2-1) = 4。
    *   在区块1中，位点2-3的[相对相位](@entry_id:148120)错误（真实为 `1-0`，预测为 `1-1`），构成1个转换错误。其他连接（1-2，3-4，5-6）的[相对相位](@entry_id:148120)均正确。
    *   SER = $1/4 = 0.25$。

*   **计算汉明错误率 (HER)**:
    *   对于区块1 `[0, 1, 1, 0]`，与真实 `[0, 1, 0, 1]` 比较，有2个错配（位点3,4）。将其翻转为 `[1, 0, 0, 1]` 后再比较，仍有2个错配（位点1,2）。因此，该区块的汉明错误为 $\min(2,2)=2$。
    *   对于区块2 `[1, 0]`，与真实 `[0, 1]` 比较，有2个错配。将其翻转为 `[0, 1]` 后再比较，有0个错配。因此，该区块的汉明错误为 $\min(2,0)=0$。
    *   总汉明错误 = $2 + 0 = 2$。
    *   HER = $2/6 \approx 0.33$。

这个例子清晰地表明，SER衡量的是内部连接的保真度，而HER则在校正了区块整体方向后，衡量了最终单点分配的准确性。两者共同为我们提供了评估定相算法性能的全面视角。