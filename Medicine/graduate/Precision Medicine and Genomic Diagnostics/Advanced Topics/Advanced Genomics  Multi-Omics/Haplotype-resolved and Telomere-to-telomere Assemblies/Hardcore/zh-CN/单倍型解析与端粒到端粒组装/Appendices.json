{
    "hands_on_practices": [
        {
            "introduction": "正如我们所见，高的连续性指标可能掩盖重大的组装错误。下一个关键技能是成为一名“基因组侦探”，利用原始测序数据揭示这些隐藏的错误组装。本练习将指导您解读主要结构性错误（如倒位和易位）的典型信号，通过整合长读长比对和 Hi-C 染色体构象图谱的证据来进行判断。",
            "id": "4348197",
            "problem": "一个人类基因组的端粒到端粒（T2T）单倍型解析组装正在接受评估，以检测其中可能存在的错误组装。评估方法包括使用长读长比对、双末端短读长作图，以及通过单核苷酸多态性进行分相以区分不同单倍型接触的高通量染色体构象捕获（Hi-C）接触图谱。现考虑来自单倍型 H1 的一个重叠群，该重叠群包含两个可疑的邻接（连接点）JA 和 JB。观察到以下现象：\n\n- 跨越 JA 的长读长比对显示出分裂读长，其第一段片段比对到 $1$ 号染色体的正链上，而第二段片段比对到 $1$ 号染色体上一个更近端的位点的反链上；这两个片段在重叠群中紧密相邻，但比对到的参考位点的顺序相对于参考坐标系是颠倒的。跨越 JA 的双末端短读长富集了朝外方向的配对（例如，$\\mathrm{R}\\mathrm{F}$），并且其表观插入片段大小远超文库的平均值。针对 H1 的单倍型解析 Hi-C 图谱显示，在 $1$ 号染色体上，除了预期的接触概率 $P(s)$ 随基因组距离 $s$ 增加而衰减的模式外，还叠加了以 JA 两侧断点为中心的镜像对称的非对角线条纹。\n\n- 跨越 JB 的长读长比对显示出分裂读长，其片段在重叠群中位置相邻，但在参考基因组中比对到了非同源染色体上，即一段比对到 $1$ 号染色体，另一段比对到 $8$ 号染色体。针对 H1 的单倍型解析 Hi-C 图谱显示，有一个离散的染色体间接触块将 $1$ 号染色体的位点与 $8$ 号染色体的位点连接起来；而在单倍型 H2 的图谱中则没有这个接触块，在这些位点之间只观察到背景噪声。\n\n假设以下经过充分检验的事实为基本依据：在一个正确组装的线性染色体中，组装序列里的相邻碱基对应于真实基因组中的相邻位点，因此长读长会连续比对而不会分裂；双末端读长具有文库特异性的方向和插入片段大小的限制；在 Hi-C 数据中，接触概率 $P(s)$ 随着基因组距离 $s$ 的增加而衰减，并且在同一染色体内部和同一单倍型相位内部的顺式接触会富集，而结构重排会产生特征性的非对角线或染色体间的接触富集。\n\n哪种关于 JA 和 JB 的错误组装类型的判定最符合这些数据？\n\nA. JA 是一个重定位（染色体内的转座，无方向翻转），JB 是一个倒位。\n\nB. JA 是一个倒位（同一染色体内的方向翻转），JB 是一个易位（染色体间的邻接）。\n\nC. JA 是一个重定位（染色体内的转座），JB 是一个易位，因为 Hi-C 中的对称条纹可由任何染色体内的邻接引起。\n\nD. JA 是一个易位，JB 是一个重定位，因为染色体间的 Hi-C 接触块可能反映的是重复序列的滲透效应而非邻接。\n\nE. JA 和 JB 都是重定位，因为非对角线的 Hi-C 富集表明了物理上的邻近性，而与染色体身份无关。",
            "solution": "必须首先验证问题陈述的科学合理性、清晰度和完整性。\n\n**步骤 1：提取已知信息**\n\n-   **系统**：一个人类基因组的端粒到端粒（T2T）单倍型解析组装。\n-   **数据类型**：长读长比对、双末端短读长作图，以及单倍型解析的高通量染色体构象捕获（Hi-C）接触图谱。\n-   **重叠群**：来自单倍型 H1 的一个重叠群。\n-   **连接点 JA 的观察结果**：\n    1.  **长读长**：跨越 JA 的分裂读长。第一段片段比对到 $1$ 号染色体（正链）。第二段片段比对到 $1$ 号染色体上一个更近端的位点（反链）。片段在重叠群中相邻，但参考位点的顺序是颠倒的。\n    2.  **双末端读长**：富集了朝外方向的配对（例如，$\\mathrm{R}\\mathrm{F}$）。表观插入片段大小远大于文库平均值。\n    3.  **Hi-C (H1)**：以断点为中心的镜像对称非对角线条纹，叠加在 $1$ 号染色体上典型的 $P(s)$ vs. $s$ 衰减模式之上。\n-   **连接点 JB 的观察结果**：\n    1.  **长读长**：跨越 JB 的分裂读长。片段在重叠群中相邻，但比对到非同源染色体上：一段到 $1$ 号染色体，另一段到 $8$ 号染色体。\n    2.  **Hi-C (H1)**：一个离散的染色体间接触块，连接了 $1$ 号染色体的位点和 $8$ 号染色体的位点。\n    3.  **Hi-C (H2)**：该染色体间接触块缺失；只观察到背景噪声。\n-   **基本原理**：\n    1.  正确的组装具有连续的长读长作图。\n    2.  正确的组装符合双末端文库的限制（方向、插入片段大小）。\n    3.  Hi-C 接触概率 $P(s)$ 随基因组距离 $s$ 衰减，在顺式接触中富集，并为结构重排显示出特征模式。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n该问题具有科学依据，提问明确，且客观。\n-   **科学依据**：问题使用了基因组组装和结构变异分析领域的标准术语、数据类型（长读长、短读长、Hi-C）和概念。所描述的不同类型重排的数据特征是经典的且符合事实。\n-   **提问明确性**：问题提供了一组具体的观察结果，并要求从给定的选项中选出最合适的解释（错误组装类型）。信息充分且自洽，足以得出逻辑结论。\n-   **客观性**：问题使用精确的技术语言（例如，“朝外方向”、“染色体间接触块”）描述数据模式，没有主观或模糊的措辞。\n\n**步骤 3：结论与行动**\n\n问题陈述有效。可以推导出解决方案。\n\n**解决方案的推导**\n\n通过解读所提供的多模态基因组数据，可以推断出连接点 JA 和 JB 处的错误组装的性质。\n\n**连接点 JA 的分析**\n\n1.  **长读长证据**：长读长是分裂的。一段片段比对到 $1$ 号染色体上某一位点的正链，而重叠群中与之相邻的片段则比对到 $1$ 号染色体上另一个位点的*反*链。比对到的参考位点顺序相对于它们在重叠群中的顺序是颠倒的，这一事实加上链方向的改变（正向到反向），是**倒位**的经典特征。组装器错误地将一个倒位片段一侧的侧翼序列与另一侧的侧翼序列连接了起来。\n\n2.  **双末端短读长证据**：跨越倒位断点的读长通常会以异常方向进行比对。双末端读长的标准方向是朝内（`F-R`，或 `--> --`）。倒位边界导致其中一个侧翼序列被倒转，使得读长对以朝外方向（例如，`R-F` 或 `-- -->`）进行比对。报告中 `R-F` 方向的富集证实了倒位的存在。表观插入片段过大也是预料之中的，因为这些读长在组装的重叠群中跨越了连接点，但在线性的参考基因组坐标系中，它们比对到了现在相距很远的位点上。这一证据强烈支持了**倒位**的结论。\n\n3.  **Hi-C 证据**：Hi-C 测量的是三维空间上的邻近性。倒位会使一段染色体片段折返，使得倒位区域的两端在空间上彼此靠近。当根据线性参考基因组作图时，这会产生特征性的非对角线互作信号。“以两个断点为中心的镜像对称非对角线条纹”的描述与 Hi-C 图谱中染色体**倒位**的标志性“领结”或“X形”模式相符。\n\n*关于 JA 的结论*：所有三个证据来源——长读长、双末端读长和 Hi-C——都共同指向一个结论：JA 代表一个**倒位**。\n\n**连接点 JB 的分析**\n\n1.  **长读长证据**：JB 处的分裂读长片段比对到了两个不同的染色体上：$1$ 号染色体和 $8$ 号染色体。在重叠群中的一个邻接对应于真实基因组中两个不同染色体之间的邻接，这正是染色体间**易位**的定义。\n\n2.  **Hi-C 证据**：在全基因组 Hi-C 接触图谱中，不同染色体之间的互作（染色体间互作）表现为非对角线区域的接触块。这些接触通常是稀疏的，代表了随机接触的低背景。易位将一个染色体上的区域带到了另一个染色体区域的永久物理邻近位置。这导致了两个染色体之间出现一个新的、强的、局部的接触富集，表现为一个“离散的染色体间接触块”。这是**易位**的典型 Hi-C 特征。\n\n3.  **单倍型解析证据**：这个接触块存在于 H1 单倍型图谱中，但在 H2 图谱中缺失，这一事实表明该易位是一个真实的、存在于对应 H1 的染色体拷贝上的杂合结构变异。这排除了全局性组装或作图错误的可能，并加强了 JB 代表一个**易位**的结论。\n\n*关于 JB 的结论*：长读长和单倍型解析的 Hi-C 数据明确地将 JB 鉴定为一个**易位**。\n\n**总结**：JA 是一个倒位。JB 是一个易位。\n\n**选项评估**\n\n-   **A. JA 是一个重定位（染色体内的转座，无方向翻转），JB 是一个倒位。**\n    -   这是错误的。由于存在方向翻转的特征，JA 是一个倒位。JB 是一个易位，而不是倒位。**错误**。\n\n-   **B. JA 是一个倒位（同一染色体内的方向翻转），JB 是一个易位（染色体间的邻接）。**\n    -   这个判定与分析完全一致。JA 的特征（带有方向翻转的分裂读长、`R-F` 配对、对称的 Hi-C 条纹）指向倒位。JB 的特征（跨染色体的分裂读长、染色体间的 Hi-C 接触块）指向易位。**正确**。\n\n-   **C. JA 是一个重定位（染色体内的转座），JB 是一个易位，因为 Hi-C 中的对称条纹可由任何染色体内的邻接引起。**\n    -   JA 被错误地识别了；证据指向倒位，而非简单的重定位。其给出的理由也是有缺陷的；“镜像对称条纹”的特定模式是倒位的特征，而非所有染色体内重排的特征。**错误**。\n\n-   **D. JA 是一个易位，JB 是一个重定位，因为染色体间的 Hi-C 接触块可能反映的是重复序列的滲透效应而非邻接。**\n    -   整个判定都是错误的。JA 是一个染色体内的事件（倒位）。JB 是一个染色体间的事件（易位）。尽管关于重复序列的警告在 Hi-C 分析中是一个合理的担忧，但在这里它与来自长读长和信号的单倍型特异性的汇集证据相矛盾。**错误**。\n\n-   **E. JA 和 JB 都是重定位，因为非对角线的 Hi-C 富集表明了物理上的邻近性，而与染色体身份无关。**\n    -   这个选项使用了一个模糊的术语（“重定位”）并且错误地解读了数据。JA 具体是一个倒位。JB 是一个易位。其理由过于简单化，因为 Hi-C 富集的*模式*，而不仅仅是其存在，才是诊断重排类型的关键。**错误**。",
            "answer": "$$\\boxed{B}$$"
        },
        {
            "introduction": "真正的 T2T 组装不仅要求高连续性和高准确性，还需要完整重建如端粒这样的挑战性区域。这项综合性练习将引导您从人工检查转向自动化验证，要求您设计一个计算算法。您将学习如何将复杂的生物学特征——基序富集、覆盖度下降和读长比对方向偏好——转化为一个稳健的多方位方法，以编程方式识别和验证组装中的端粒末端。",
            "id": "4348159",
            "problem": "您的任务是设计一种计算方法，用于在用于精准医疗和基因组诊断的单倍型解析端粒到端粒（T2T）组装中，识别和验证重叠群（contig）中的端粒末端。该方法必须整合基序富集、覆盖度信号行为和比对方向一致性，并以基础生物学和统计学原理为依据。具体而言，以下定义和假设是基本依据：\n\n- 脱氧核糖核酸（DNA）是一种基于字母表 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 的聚合物序列，它编码遗传信息，与分子生物学的中心法则一致。\n- 脊椎动物的端粒重复序列由基序 $\\text{TTAGGG}$ 及其反向互补序列 $\\text{CCCTAA}$ 组成，它们在染色体末端附近串联出现。\n- 一个基因座的全基因组测序覆盖度可以通过从速率为 $\\lambda$ 的泊松过程中抽样来近似，这意味着在稳定抽样下，期望覆盖度值与 $\\lambda$ 成正比，且每个位置的变异接近 $\\lambda$。\n- 在重叠群的真实末端区域附近，测序读段（read）的比对方向预计会相对于重叠群边界表现出方向一致的排列（例如，在一端“朝外”），这可以通过伯努利过程进行建模，当不存在方向性结构时，其零假设期望为 $0.5$ 的平衡方向。\n\n您的算法必须为每个重叠群末端（左端和右端）计算以下三个指标：\n\n1. 基序富集分数：对于末端大小为 $L$ 个碱基的窗口，计算一个对数优势富集分数 $S_{\\mathrm{m}}$，该分数比较了 $\\text{TTAGGG}$ 或 $\\text{CCCTAA}$ 的观测频率（选择在该窗口中富集程度较高的方向）与从整个重叠群的碱基组成推导出的期望概率。基序的期望概率是整个重叠群中边际碱基频率的乘积。观测频率是基序出现次数除以窗口中可能的基序起始位置数。您必须通过在适当位置应用一个可忽略的平滑常数来避免除以零的错误。\n2. 覆盖度下降标准：计算末端窗口中的平均覆盖度与整个重叠群的平均覆盖度之比 $R_{\\mathrm{c}}$。一个经过验证的末端预计会显示 $R_{\\mathrm{c}}$ 小于一个在 $(0,1)$ 范围内的指定阈值。\n3. 方向一致性分数：在末端窗口中，计算“朝外”比对的读段方向分数 $\\hat{p}$，并评估一个正态近似 $z$-分数 $S_{\\mathrm{o}} = \\dfrac{\\hat{p} - 0.5}{\\sqrt{0.25/n}}$，其中 $n$ 是在末端附近采样的读段数量。一个经过验证的末端必须满足 $S_{\\mathrm{o}}$ 的下限，并且 $\\hat{p} > 0.5$。\n\n一个末端当且仅当同时满足所有三个标准时才被验证：\n- $S_{\\mathrm{m}} \\ge \\tau_{\\mathrm{m}}$\n- $R_{\\mathrm{c}} \\le \\theta_{\\mathrm{c}}$\n- $S_{\\mathrm{o}} \\ge \\tau_{\\mathrm{o}}$ 且 $\\hat{p} > 0.5$\n\n使用以下常量：\n- 基序对数优势阈值 $\\tau_{\\mathrm{m}} = 2.0$\n- 覆盖度比率阈值 $\\theta_{\\mathrm{c}} = 0.6$\n- 方向 $z$-分数阈值 $\\tau_{\\mathrm{o}} = 2.0$\n- 平滑常数 $\\epsilon = 10^{-9}$\n\n窗口长度 $L$ 在每个测试用例中指定。独立处理两个末端，并报告每个重叠群中经过验证的末端总数，该总数必须是 $\\{0,1,2\\}$ 中的一个整数。\n\n您的程序的输入是隐式的（如下文所述，硬编码在程序中）。您的程序必须将该方法应用于以下测试套件。每个测试用例定义了一个重叠群序列、其覆盖度数组、末端窗口长度 $L$ 以及特定于末端的读段方向列表。所有角度都无关且不存在；不需要物理单位。将所有数值输出表示为整数。\n\n测试套件：\n- 案例 $1$ (单倍型 $\\text{H1}$):\n  - 重叠群长度 $= 400$。序列 $=$ $\\text{TTAGGG}$ 重复 $18$ 次，后跟 $\\text{ACGT}$ 重复 $73$ 次。\n  - 覆盖度数组：前 $120$ 个位置的覆盖度 $= 8$，其余 $280$ 个位置的覆盖度 $= 32$。\n  - 窗口长度 $L = 120$。\n  - 左端方向：$30$ 个读段，其中 $25$ 个朝外，$5$ 个朝内。\n  - 右端方向：$30$ 个读段，其中 $16$ 个朝外，$14$ 个朝内。\n- 案例 $2$ (单倍型 $\\text{H2}$):\n  - 重叠群长度 $= 500$。序列 $=$ $\\text{TTAGGG}$ 重复 $20$ 次，然后 $\\text{GACT}$ 重复 $65$ 次，然后 $\\text{CCCTAA}$ 重复 $20$ 次。\n  - 覆盖度数组：前 $120$ 个位置的覆盖度 $= 10$，中间 $260$ 个位置的覆盖度 $= 35$，最后 $120$ 个位置的覆盖度 $= 10$。\n  - 窗口长度 $L = 120$。\n  - 左端方向：$40$ 个读段，其中 $35$ 个朝外，$5$ 个朝内。\n  - 右端方向：$40$ 个读段，其中 $32$ 个朝外，$8$ 个朝内。\n- 案例 $3$ (无端粒的对照重叠群):\n  - 重叠群长度 $= 450$。序列 $=$ $\\text{GACT}$ 重复 $112$ 次，后跟 $\\text{GA}$。\n  - 覆盖度数组：所有 $450$ 个位置的覆盖度 $= 30$。\n  - 窗口长度 $L = 120$。\n  - 左端方向：$40$ 个读段，其中 $20$ 个朝外，$20$ 个朝内。\n  - 右端方向：$40$ 个读段，其中 $22$ 个朝外，$18$ 个朝内。\n- 案例 $4$ (存在基序但覆盖度下降不足):\n  - 重叠群长度 $= 420$。序列 $=$ $\\text{TTAGGG}$ 重复 $15$ 次，后跟 $\\text{ATGC}$ 重复 $82$ 次，后跟 $\\text{AT}$。\n  - 覆盖度数组：前 $120$ 个位置的覆盖度 $= 26$，其余 $300$ 个位置的覆盖度 $= 31$。\n  - 窗口长度 $L = 120$。\n  - 左端方向：$30$ 个读段，其中 $26$ 个朝外，$4$ 个朝内。\n  - 右端方向：$30$ 个读段，其中 $15$ 个朝外，$15$ 个朝内。\n- 案例 $5$ (大窗口的边界情况):\n  - 重叠群长度 $= 200$。序列 $=$ $\\text{ATGC}$ 重复 $50$ 次。\n  - 覆盖度数组：前 $150$ 个位置的覆盖度 $= 25$，最后 $50$ 个位置的覆盖度 $= 30$。\n  - 窗口长度 $L = 150$。\n  - 左端方向：$20$ 个读段，其中 $11$ 个朝外，$9$ 个朝内。\n  - 右端方向：$20$ 个读段，其中 $9$ 个朝外，$11$ 个朝内。\n\n输出规范：\n- 对于每个测试用例，计算两个重叠群末端中经过验证的端粒末端的整数数量。\n- 您的程序应生成单行输出，其中包含五个案例按顺序排列的结果，格式为逗号分隔的列表并用方括号括起来（例如，$[\\text{r}_1,\\text{r}_2,\\text{r}_3,\\text{r}_4,\\text{r}_5]$）。条目必须是整数。\n\n您的算法必须在一个单一、完整、可运行的 Python 程序中实现。不允许用户交互或使用外部文件。程序必须完全按照规定计算所有量，并以所需格式输出最终结果。",
            "solution": "该问题要求设计并实现一种计算方法，用于验证来自单倍型解析的端粒到端粒（T2T）组装中重叠群的端粒末端。验证必须基于三种不同证据线的综合：端粒基序富集、测序覆盖度模式和读段比对方向偏倚。问题陈述具有科学依据、定义明确且客观，引用了分子生物学和生物统计学中的既定原则。因此，该问题被认为是有效的，可以制定解决方案。\n\n该算法的核心原则是为端粒的三个生物学特征中的每一个量化证据，并且仅当所有三个特征都满足先验定义的统计阈值时，才将一个重叠群末端声明为经过验证的端粒。我们将独立分析每个重叠群的左端和右端。对于每个末端，定义一个大小为 $L$ 的窗口，该窗口构成分析区域。\n\n让我们通过其三个主要组成部分来剖析该算法。\n\n**1. 基序富集分数 ($S_{\\mathrm{m}}$)**\n\n该指标量化了典型脊椎动物端粒重复序列的过度表达。\n\n*   **原理**: 真正的端粒由特定DNA基序的长串联阵列组成。在脊椎动物中，这是一条链上的 $6$ 碱基对基序 $\\text{TTAGGG}$ 及其另一条链上的反向互补序列 $\\text{CCCTAA}$。一个真正的端粒基因组区域应该显示出这些基序的频率显著高于基于重叠群整体核苷酸组成随机预期的频率。\n*   **公式**: 我们计算一个对数优势富集分数 $S_{\\mathrm{m}}$。首先，我们确定一个特定的 $6$-mer 基序在任何给定位置出现的期望概率 $P_{\\text{exp}}$。在一个简单的核苷酸独立模型下，这是其组成碱基在整个重叠群中边际频率的乘积。设 $f(B)$ 是重叠群中碱基 $B \\in \\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ 的频率。\n    $$P_{\\text{exp, TTAGGG}} = f(\\text{T}) \\cdot f(\\text{T}) \\cdot f(\\text{A}) \\cdot f(\\text{G}) \\cdot f(\\text{G}) \\cdot f(\\text{G})$$\n    $$P_{\\text{exp, CCCTAA}} = f(\\text{C}) \\cdot f(\\text{C}) \\cdot f(\\text{C}) \\cdot f(\\text{T}) \\cdot f(\\text{A}) \\cdot f(\\text{A})$$\n    接下来，我们计算在长度为 $L$ 的分析窗口内基序的观测频率 $P_{\\text{obs}}$。这是发现基序的次数 $N_{\\text{obs}}$ 除以一个 $6$-mer 可能的起始位置数，即 $L - 6 + 1$。\n    $$P_{\\text{obs}} = \\frac{N_{\\text{obs}}}{L-5}$$\n    给定基序的富集分数是观测概率与期望概率之比的自然对数。在分母中加入一个平滑常数 $\\epsilon = 10^{-9}$，以防止在重叠群中某个碱基不存在导致 $P_{\\text{exp}} = 0$ 的罕见情况下出现除以零的错误。\n    $$S_{\\mathrm{m}} = \\ln\\left(\\frac{P_{\\text{obs}}}{P_{\\text{exp}} + \\epsilon}\\right)$$\n    由于DNA的任何一条链都可能在重叠群序列中表示，我们为 $\\text{TTAGGG}$ 和 $\\text{CCCTAA}$ 两者计算 $S_{\\mathrm{m}}$，并取两者中的最大值作为该窗口的分数。如果 $S_{\\mathrm{m}} \\ge \\tau_{\\mathrm{m}}$（阈值给定为 $\\tau_{\\mathrm{m}} = 2.0$），则认为该末端具有显著的基序富集。如果 $P_{\\text{obs}}=0$，则分数为 $\\ln(0) = -\\infty$，这将正确地导致验证失败。\n\n**2. 覆盖度下降标准 ($R_{\\mathrm{c}}$)**\n\n该指标识别染色体最末端测序覆盖度的特征性下降。\n\n*   **原理**: 在全基因组鸟枪法测序中，读段是从基因组的随机片段生成的。一个区域要被测序，它必须两侧都有基因组DNA才能被捕获到一个片段中。线性染色体的最末端是例外；它们仅在一侧有侧翼序列。这导致测序覆盖度逐渐下降，在末端处应接近全基因组平均覆盖度的大约一半。为简单起见，问题将其建模为一个离散的下降。\n*   **公式**: 我们计算末端窗口内的平均测序覆盖度 $\\bar{c}_{\\text{win}}$ 与整个重叠群的平均覆盖度 $\\bar{c}_{\\text{ctg}}$ 之比 $R_{\\mathrm{c}}$。\n    $$R_{\\mathrm{c}} = \\frac{\\bar{c}_{\\text{win}}}{\\bar{c}_{\\text{ctg}}}$$\n    一个真正的端粒末端预计具有显著较低的覆盖度。验证标准是 $R_{\\mathrm{c}} \\le \\theta_{\\mathrm{c}}$，阈值给定为 $\\theta_{\\mathrm{c}} = 0.6$。\n\n**3. 方向一致性分数 ($S_{\\mathrm{o}}$)**\n\n该指标评估在重叠群末端附近比对的读段对的方向偏倚。\n\n*   **原理**: 双末端测序读段具有已知的方向（例如，正向-反向），并由一定的插入片段大小隔开。在一个真正的染色体末端，所有跨越染色体和测序载体（或简言之，DNA的物理末端）之间连接处的读段对，都会有一个读段比对到染色体上，而其配对读段要么未比对，要么比对到接头序列上。这产生了一种强烈的方向偏倚，其中所有有效的比对都从分子的末端“向内”指向。问题将其抽象为相对于重叠群边界的“朝外”，这同样可以用于识别方向信号。在非末端区域的零假设下，读段方向应大致平衡（每个方向约占50%）。我们可以检验是否存在与这个50%零假设的显著偏离。\n*   **公式**: 读段的方向被建模为一个伯努利过程。对于在重叠群末端附近采样的 $n$ 个读段，设 $k$ 为“朝外”读段的计数。其比例为 $\\hat{p} = k/n$。我们检验零假设 $H_0: p = 0.5$ 对备择假设 $H_1: p > 0.5$。我们使用此单尾检验的正态近似 $z$-分数：\n    $$S_{\\mathrm{o}} = \\frac{\\hat{p} - p_0}{\\sqrt{p_0(1-p_0)/n}} = \\frac{\\hat{p} - 0.5}{\\sqrt{0.25/n}}$$\n    一个高的正分数值表示显著偏向“朝外”方向，这与一个真正的末端相符。验证标准是双重的：统计显著性必须超过一个阈值 $S_{\\mathrm{o}} \\ge \\tau_{\\mathrm{o}}$（其中 $\\tau_{\\mathrm{o}} = 2.0$），并且偏倚的方向必须正确，即 $\\hat{p} > 0.5$。\n\n**综合验证算法**\n\n最后一步是将这三个指标合并为对重叠群每个末端的单一验证决策。\n\n对于给定的重叠群及其相关数据：\n1.  计算重叠群范围的碱基频率和平均覆盖度。\n2.  对于左端（从索引 $0$ 到 $L-1$ 的窗口）：\n    a. 计算 $S_{\\mathrm{m, left}}$。\n    b. 计算 $R_{\\mathrm{c, left}}$。\n    c. 计算 $S_{\\mathrm{o, left}}$ 和 $\\hat{p}_{\\text{left}}$。\n    d. 左端当且仅当（$S_{\\mathrm{m, left}} \\ge \\tau_{\\mathrm{m}}$）与（$R_{\\mathrm{c, left}} \\le \\theta_{\\mathrm{c}}$）与（$S_{\\mathrm{o, left}} \\ge \\tau_{\\mathrm{o}}$ 且 $\\hat{p}_{\\text{left}} > 0.5$）同时成立时，才被验证。\n3.  对于右端（从索引 $-L$ 到末尾的窗口）：\n    a. 计算 $S_{\\mathrm{m, right}}$。\n    b. 计算 $R_{\\mathrm{c, right}}$。\n    c. 计算 $S_{\\mathrm{o, right}}$ 和 $\\hat{p}_{\\text{right}}$。\n    d. 右端当且仅当（$S_{\\mathrm{m, right}} \\ge \\tau_{\\mathrm{m}}$）与（$R_{\\mathrm{c, right}} \\le \\theta_{\\mathrm{c}}$）与（$S_{\\mathrm{o, right}} \\ge \\tau_{\\mathrm{o}}$ 且 $\\hat{p}_{\\text{right}} > 0.5$）同时成立时，才被验证。\n4.  重叠群的已验证末端总数是左端和右端验证结果（验证为1，未验证为0）的总和。\n\n此过程应用于每个测试用例以生成最终结果。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the telomere validation algorithm on all test cases.\n    \"\"\"\n    \n    # --- Constants and Thresholds ---\n    TAU_M = 2.0  # Motif log-odds threshold\n    THETA_C = 0.6  # Coverage ratio threshold\n    TAU_O = 2.0  # Orientation z-score threshold\n    EPSILON = 1e-9  # Smoothing constant\n    MOTIF_LEN = 6\n    MOTIF_FWD = \"TTAGGG\"\n    MOTIF_REV = \"CCCTAA\"\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        # Case 1 (haplotype H1)\n        {\n            \"seq\": \"TTAGGG\" * 18 + \"ACGT\" * 73,\n            \"cov\": np.concatenate([np.full(120, 8), np.full(280, 32)]),\n            \"L\": 120,\n            \"left_orient\": (30, 25),  # (total_reads, outward_reads)\n            \"right_orient\": (30, 16),\n        },\n        # Case 2 (haplotype H2)\n        {\n            \"seq\": \"TTAGGG\" * 20 + \"GACT\" * 65 + \"CCCTAA\" * 20,\n            \"cov\": np.concatenate([np.full(120, 10), np.full(260, 35), np.full(120, 10)]),\n            \"L\": 120,\n            \"left_orient\": (40, 35),\n            \"right_orient\": (40, 32),\n        },\n        # Case 3 (control contig)\n        {\n            \"seq\": \"GACT\" * 112 + \"GA\",\n            \"cov\": np.full(450, 30),\n            \"L\": 120,\n            \"left_orient\": (40, 20),\n            \"right_orient\": (40, 22),\n        },\n        # Case 4 (motif present but insufficient coverage drop)\n        {\n            \"seq\": \"TTAGGG\" * 15 + \"ATGC\" * 82 + \"AT\",\n            \"cov\": np.concatenate([np.full(120, 26), np.full(300, 31)]),\n            \"L\": 120,\n            \"left_orient\": (30, 26),\n            \"right_orient\": (30, 15),\n        },\n        # Case 5 (boundary case with large window)\n        {\n            \"seq\": \"ATGC\" * 50,\n            \"cov\": np.concatenate([np.full(150, 25), np.full(50, 30)]),\n            \"L\": 150,\n            \"left_orient\": (20, 11),\n            \"right_orient\": (20, 9),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(analyze_contig(case, TAU_M, THETA_C, TAU_O, EPSILON, MOTIF_FWD, MOTIF_REV, MOTIF_LEN))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef validate_end(window_seq, window_cov, mean_contig_cov, p_exps, orient_data, L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n    \"\"\"\n    Applies the three validation criteria to a single contig end.\n    \n    Returns:\n        bool: True if the end is validated, False otherwise.\n    \"\"\"\n    \n    # 1. Motif Enrichment Score (S_m)\n    num_possible_starts = L - motif_len + 1\n    if num_possible_starts = 0:\n        s_m = -np.inf\n    else:\n        count_fwd = window_seq.count(motif_fwd)\n        count_rev = window_seq.count(motif_rev)\n        \n        p_obs_fwd = count_fwd / num_possible_starts\n        p_obs_rev = count_rev / num_possible_starts\n        \n        p_exp_fwd, p_exp_rev = p_exps\n        \n        s_m_fwd = np.log(p_obs_fwd / (p_exp_fwd + epsilon)) if p_obs_fwd > 0 else -np.inf\n        s_m_rev = np.log(p_obs_rev / (p_exp_rev + epsilon)) if p_obs_rev > 0 else -np.inf\n        \n        s_m = max(s_m_fwd, s_m_rev)\n\n    metric1_ok = s_m >= tau_m\n\n    # 2. Coverage Drop Criterion (R_c)\n    mean_window_cov = np.mean(window_cov)\n    if mean_contig_cov == 0: # Avoid division by zero\n        r_c = np.inf\n    else:\n        r_c = mean_window_cov / mean_contig_cov\n    \n    metric2_ok = r_c = theta_c\n\n    # 3. Orientation Consistency Score (S_o)\n    n, outward_count = orient_data\n    if n == 0:\n        p_hat = 0.5\n        s_o = 0.0\n    else:\n        p_hat = outward_count / n\n        s_o = (p_hat - 0.5) / np.sqrt(0.25 / n)\n        \n    metric3_ok = (s_o >= tau_o) and (p_hat > 0.5)\n    \n    return metric1_ok and metric2_ok and metric3_ok\n\n\ndef analyze_contig(case, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n    \"\"\"\n    Analyzes a single contig and returns the number of validated telomeric ends.\n    \"\"\"\n    seq = case[\"seq\"]\n    cov = case[\"cov\"]\n    L = case[\"L\"]\n    contig_len = len(seq)\n    \n    # --- Contig-wide metrics ---\n    base_counts = {base: seq.count(base) for base in 'ACGT'}\n    base_freqs = {base: count / contig_len for base, count in base_counts.items()}\n    \n    p_exp_fwd = (base_freqs.get('T', 0)**2 * base_freqs.get('A', 0) * base_freqs.get('G', 0)**3)\n    p_exp_rev = (base_freqs.get('C', 0)**3 * base_freqs.get('T', 0) * base_freqs.get('A', 0)**2)\n    p_exps = (p_exp_fwd, p_exp_rev)\n    \n    mean_contig_cov = np.mean(cov)\n\n    # --- End-specific validation ---\n    validated_ends = 0\n    \n    # Left end\n    left_window_seq = seq[:L]\n    left_window_cov = cov[:L]\n    if validate_end(left_window_seq, left_window_cov, mean_contig_cov, p_exps, case[\"left_orient\"], L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n        validated_ends += 1\n        \n    # Right end\n    right_window_seq = seq[-L:]\n    right_window_cov = cov[-L:]\n    if validate_end(right_window_seq, right_window_cov, mean_contig_cov, p_exps, case[\"right_orient\"], L, tau_m, theta_c, tau_o, epsilon, motif_fwd, motif_rev, motif_len):\n        validated_ends += 1\n        \n    return validated_ends\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}