{
    "hands_on_practices": [
        {
            "introduction": "我们首先从一个根本问题开始：为什么解析复杂基因组重排必须使用长读长测序？这个练习将引导您从第一性原理出发，推导出一个简洁的数学模型来计算跨越复杂重排事件所需的最小读长。通过这个实践，您将对长读长技术的核心优势有一个具体而定量的理解。",
            "id": "4377786",
            "problem": "一个影响癌症驱动基因的复杂结构变异，表现为沿重排单倍型上连接点（断点）和连接点间区间的交替序列。设一条连续路径上有 $k$ 个连接点，以及 $k$ 个连接点间的区间，其长度分别为 $d_1, d_2, \\dots, d_k$（以碱基对为单位）。来自单分子实时（SMRT）测序或牛津纳米孔技术（Oxford Nanopore Technologies）的单条长读长，必须跨越这条完整路径，才能在临床基因组诊断环境中解析该重排。\n\n基本依据：\n- 断点是两个基因组位点之间的连接处；其几何范围与区间长度相比可以忽略不计，因此被视为一个点。\n- 长度为 $L$ 的长读长覆盖一个连续序列，并且为了能够可靠比对，其左端和右端必须至少包含 $u$ 个碱基的独特可映射侧翼序列。其中 $u$ 是比对过程所需的最小唯一种子长度（例如，在比对工具的容错率下实现可靠唯一性的最小 $k$-mer 种子长度）。\n- 在读长内部，每个内部断点必须被其左右两侧足够的序列所包围才能被观察到，但这些碱基来自于读长已经跨越的连接点间区间。\n\n仅从这些基本事实和定义出发，推导出一个解析表达式，用于计算跨越整个重排路径并能可靠比对读长两端的必要且充分的最小读长 $L_{\\min}$。然后，使用您推导的表达式，计算以下情况的 $L_{\\min}$：\n$$\nk = 5, \\quad (d_1, d_2, d_3, d_4, d_5) = (2400,\\ 13150,\\ 820,\\ 29900,\\ 412)\\ \\text{bp}, \\quad u = 150\\ \\text{bp}.\n$$\n假设区间长度足够大，以至于在读长内部，每个内部断点两侧都至少有 $u$ 个碱基的侧翼。以碱基对（bp）为单位表示最终长度。提供精确的整数碱基对数量，不要四舍五入。",
            "solution": "用户希望我解决以下问题。\n\n该问题要求推导解析一个复杂基因组重排所需的最小读长 $L_{\\min}$ 的解析表达式，并将此表达式应用于一个具体案例。\n\n首先，对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 穿过的连接点数量：$k$。\n- 连接点间区间的数量：$k$，长度分别为 $d_1, d_2, \\dots, d_k$。\n- 用于比对的最小唯一种子长度：$u$。\n- 读长必须在其左端和右端至少包含 $u$ 个碱基的侧翼序列。\n- 假设：区间长度足够大，使得在读长内部，每个内部断点两侧都至少有 $u$ 个碱基。\n- 用于计算的具体数值：$k = 5$，$(d_1, d_2, d_3, d_4, d_5) = (2400, 13150, 820, 29900, 412)$ 碱基对（bp），以及 $u = 150$ bp。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题在科学上基于长读长测序和结构变异分析的原理。其术语和概念是基因组学领域的标准。该问题是客观且可形式化的。\n\n问题陈述中存在一个微小的歧义。它指明了“穿过 $k$ 个连接点”和“$k$ 个连接点间区间”。一个由 $k$ 个区间首尾相连组成的连续路径包含 $k-1$ 个内部连接点（断点）。这表明存在轻微的语言不精确性。然而，问题始终使用 $k$ 作为区间的数量，给出了 $k=5$ 以及对应的5个区间长度列表 $(d_1, \\dots, d_5)$。问题的核心取决于这些区间的总长度，而非连接点的数量。因此，这个歧义被认为是一个非致命的不精确之处，不会妨碍得出唯一且合乎逻辑的解。最合理的解释是该路径由 $k$ 个不同的片段组成。除此之外，该问题是自洽的、适定的，并且没有矛盾或不科学的前提。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将推导解答。\n\n### 最小读长 $L_{\\min}$ 的推导\n\n该问题要求确定测序读长 $L$ 的最小长度，该长度既能跨越一个复杂的结构变异，又能可靠地比对到参考基因组上。\n\n设重排的基因组路径定义为一个由 $k$ 个长度为 $d_1, d_2, \\dots, d_k$ 的区间串联而成的连续序列。连接点被视作零长度的点。构成该重排的序列总长度，记为 $D$，是这些区间长度的总和：\n$$D = \\sum_{i=1}^{k} d_i$$\n\n为了使一个读长能够解析这个结构，必须满足两个条件：\n1.  读长必须完全跨越长度为 $D$ 的整个重排路径。\n2.  读长必须是可比对的。问题陈述指出，这要求读长在其左端和右端至少包含 $u$ 个碱基的独特可映射侧翼序列。这些侧翼序列与重排路径相邻，但不是路径的一部分。\n\n让我们在一维坐标系上对重排路径进行建模。我们可以将路径的起点定义在坐标 $0$ 处，终点在坐标 $D$ 处。因此，该路径占据了区间 $[0, D]$。\n- 左侧翼区域是坐标 $x  0$ 的序列。\n- 右侧翼区域是坐标 $x  D$ 的序列。\n\n一个长度为 $L$ 的测序读长覆盖基因组的一个连续区间。设该区间为 $[x_0, x_0 + L]$。\n\n为了满足比对条件，读长必须从左侧翼区域捕获至少 $u$ 个碱基，并从右侧翼区域捕获至少 $u$ 个碱基。\n- 为了从左侧翼（区域 $x  0$）捕获 $u$ 个碱基，读长必须在坐标 $-u$ 或之前开始。这施加了约束条件 $x_0 \\le -u$。\n- 为了从右侧翼（区域 $x  D$）捕获 $u$ 个碱基，读长必须在坐标 $D + u$ 或之后结束。这施加了约束条件 $x_0 + L \\ge D + u$。\n\n读长还必须跨越从坐标 $0$ 到 $D$ 的整个重排路径。上述两个条件更为严格，并自动确保了路径被跨越。如果 $x_0 \\le -u$ 且 $x_0 + L \\ge D+u$，那么读长区间 $[x_0, x_0+L]$ 必然包含 $[0, D]$，因为 $u  0$ 且 $D  0$。\n\n我们寻求最小读长 $L_{\\min}$。根据第二个约束条件，我们有：\n$$L \\ge D + u - x_0$$\n为了最小化 $L$，我们必须最大化 $x_0$ 的值。根据第一个约束条件，$x_0$ 的最大允许值为 $-u$。\n\n将 $x_0 = -u$ 代入关于 $L$ 的不等式中：\n$$L \\ge D + u - (-u)$$\n$$L \\ge D + 2u$$\n\n因此，满足所有条件的最小可能读长 $L_{\\min}$ 是：\n$$L_{\\min} = D + 2u$$\n代入 $D$ 的表达式：\n$$L_{\\min} = \\left(\\sum_{i=1}^{k} d_i\\right) + 2u$$\n该表达式代表了重排序列本身的长度，加上两端两个最小唯一锚定序列的长度。\n\n问题中包含一个假设，即“区间长度足够大，以至于在读长内部，每个内部断点两侧都至少有 $u$ 个碱基的侧翼。”我们推导出的最小长度读长覆盖了所有区间 $d_1, \\dots, d_k$ 的全部内容，因此将包含每个区间的完整序列。因此，对于区间 $d_i$ 和 $d_{i+1}$ 之间的连接点，读长将包含连接点左侧的全部 $d_i$ 和右侧的全部 $d_{i+1}$。因此，该假设简化为条件 $d_i \\ge u$ 对所有与内部连接点相邻的区间 $i$ 都成立。此假设确保了问题是适定的，并且不需要更复杂的断点检测模型，但它不改变 $L_{\\min}$ 的推导，因为 $L_{\\min}$ 是由整个重排路径外部两端的要求决定的。\n\n### 具体案例的计算\n\n我们已知以下数值：\n- $k = 5$\n- $(d_1, d_2, d_3, d_4, d_5) = (2400, 13150, 820, 29900, 412)$ bp\n- $u = 150$ bp\n\n首先，我们计算重排路径的总长度 $D$：\n$$D = \\sum_{i=1}^{5} d_i = d_1 + d_2 + d_3 + d_4 + d_5$$\n$$D = 2400 + 13150 + 820 + 29900 + 412$$\n$$D = 46682\\ \\text{bp}$$\n\n接下来，我们使用推导出的 $L_{\\min}$ 公式：\n$$L_{\\min} = D + 2u$$\n$$L_{\\min} = 46682 + 2 \\times 150$$\n$$L_{\\min} = 46682 + 300$$\n$$L_{\\min} = 46982\\ \\text{bp}$$\n\n所需的最小读长为 46982 碱基对。",
            "answer": "$$\\boxed{46982}$$"
        },
        {
            "introduction": "理解了为何需要长读长之后，下一步便是如何分析它们产生的数据。这个编程练习让您扮演生物信息学家的角色，从多条含有错误的测序读段比对结果中，精确解析基因组断点处的序列。您将实现一个算法，构建共有序列并量化断点处的微同源性（microhomology）等关键生物学特征。",
            "id": "4377754",
            "problem": "给定多个跨越基因组断点的长读长序列的带间隙比对。每个比对表示为字母表 {A, C, G, T, -} 上的单个字符串，其中破折号符号表示比对引入的间隙。一个测试用例中的所有字符串长度相等，并提供一个断点索引，该索引将比对列划分为左片段和右片段。您的任务是使用偏序比对形式化方法计算共有连接序列，并量化推断的连接处微同源长度的置信度。\n\n使用的基本原理和定义：\n- 偏序比对可以通过一个有向无环图 (DAG) 进行建模，其中节点表示比对的字符状态，有向边表示列式前进。给定预先比对好的等长字符串，该 DAG 退化为一个线性的列链，每列最多有一个共有字符和可选的间隙状态。这种表示允许在每个位置上对跨读长的证据进行明确的聚合。\n- 在一个具有对称核苷酸先验的独立单碱基观测模型下，某一列的最大后验共有碱基是在忽略间隙的情况下，在所有读长中观测计数最高的核苷酸，并按字典序进行确定性平局决胜。这一选择在序列共有建模中经过充分检验的多项-狄利克雷框架证明是合理的。\n- 连接处的微同源定义为从左片段和右片段中移除间隙后，左片段的后缀与右片段的前缀之间最长完全匹配的长度。设断点索引为 $b$，设 $s$ 为一个长度为 $L$ 的读长或共有比对字符串。定义左子串 $s[0:b]$ 和右子串 $s[b:L]$。移除间隙后，将它们表示为 $s_{\\text{left}}$ 和 $s_{\\text{right}}$。微同源长度 $\\ell$ 是满足长度为 $\\ell$ 的 $s_{\\text{left}}$ 后缀等于长度为 $\\ell$ 的 $s_{\\text{right}}$ 前缀的最大整数 $\\ell \\in \\{0, 1, \\dots, \\min(|s_{\\text{left}}|, |s_{\\text{right}}|)\\}$。\n- 推断的微同源长度的置信度使用对称狄利克雷后验预测模型进行量化。设 $N$ 为读长总数，设在所有读长中观察到的长度形成 $K$ 个不同的类别，设 $c_{\\ell^\\ast}$ 是在下述平局决胜规则下选定的（最高）微同源长度 $\\ell^\\ast$ 的计数。使用对称狄利克雷先验参数 $\\alpha = 1$，$\\ell^\\ast$ 的后验预测概率（置信度）为 $\\displaystyle \\frac{c_{\\ell^\\ast} + \\alpha}{N + K\\alpha}$。\n\n计算要求：\n1. 构建偏序比对共有序列：\n   - 对于每个列索引 $i \\in \\{0, 1, \\dots, L-1\\}$，统计所有读长中 $\\{ \\text{A}, \\text{C}, \\text{G}, \\text{T} \\}$ 核苷酸的数量，忽略间隙。\n   - 选择计数最大的核苷酸作为共有碱基。如果出现平局，选择 $\\text{A}  \\text{C}  \\text{G}  \\text{T}$ 中字典序最小的那个。如果某一列的所有读长都是间隙，则该列的共有序列也是间隙。\n   - 通过从完整共有比对字符串中移除间隙来定义共有连接序列。\n2. 将微同源定义应用于断点索引 $b$ 处的共有比对字符串，计算共有微同源长度 $\\ell_{\\text{cons}}$。\n3. 对每个读长，使用相同的定义计算其微同源长度 $\\ell_r$。\n4. 确定选定的微同源长度 $\\ell^\\ast$，即在所有读长中计数最多的长度；如果出现平局，选择较大的长度（临床惯例倾向于在证据均等的情况下支持最大重叠）。\n5. 将置信度值 $\\displaystyle \\frac{c_{\\ell^\\ast} + 1}{N + K}$ 计算为小数值。\n\n测试套件：\n为以下测试用例提供结果。每个用例给出一个比对好的读长数组和断点索引 $b$。\n\n- 用例 $1$ (理想路径；清晰的微同源):\n  - Reads: [\"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGATGGAA\"]\n  - Breakpoint index $b = 5$\n- 用例 $2$ (微同源长度出现平局):\n  - Reads: [\"AGGTACCT\", \"AGGTTCCT\", \"AGGTACCT\", \"AGGTTCCT\"]\n  - Breakpoint index $b = 4$\n- 用例 $3$ (连接处附近有间隙；一致的微同源):\n  - Reads: [\"AAGCT-CTGAA\", \"AAGC-TCTGAA\", \"AA-GCTCTGAA\"]\n  - Breakpoint index $b = 6$\n- 用例 $4$ (边界情况；所有读长均无微同源):\n  - Reads: [\"GTCGATTGCT\", \"GTCGATTGCT\", \"GTCGATTGCT\"]\n  - Breakpoint index $b = 5$\n\n答案规范：\n对于每个测试用例，计算并返回一个包含以下内容的三元组：\n- 无间隙共有连接序列的长度（一个整数），\n- 共有微同源长度 $\\ell_{\\text{cons}}$（一个整数），\n- 如上定义的置信度值（一个浮点数）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素本身是针对一个测试用例的三个值的列表。例如，格式为 “[[x1,y1,z1],[x2,y2,z2],[x3,y3,z3],[x4,y4,z4]]”，其中每个 $x_i$ 和 $y_i$ 是整数，每个 $z_i$ 是浮点数。不涉及物理单位；所有数值输出均为无量纲。不出现角度，因此不需要角度单位。不得使用百分比；请以小数形式报告置信度。",
            "solution": "问题陈述是有效的。它在科学上是合理的，基于计算生物学和统计学中已建立的原则，如序列共有建模和贝叶斯推断。问题定义明确，提供了无歧义的定义、约束和计算过程，包括明确的平局决胜规则，这保证了唯一且可验证的解。所有必要的数据都在测试用例中提供。\n\n解决方案是通过系统地遵循问题陈述中列出的计算要求得出的。该过程应用于每个测试用例，每个用例包含一组带间隙的序列比对和一个断点索引 `$b$`。\n\n1.  **共有序列生成**：此步骤的核心是从一组比对好的读长中确定最具代表性的序列。共有比对字符串是逐列构建的。对于每个列索引 `$i \\in \\{0, 1, \\dots, L-1\\}$`（其中 `$L$` 是比对长度），我们统计所有 `$N$` 个读长中每个核苷酸（`$\\text{A}$`、`$\\text{C}$`、`$\\text{G}$`、`$\\text{T}$`）的出现次数。由 `'-'` 表示的间隙被排除在此计数之外。\n    - 第 `$i$` 列的共有碱基是根据最大后验 (MAP) 原则选择的。如前所述，在对称先验下，这简化为选择频率最高的核苷酸。\n    - 如果给定列的所有读长都包含一个间隙，则该列的共有序列也被定义为间隙。\n    - 如果核苷酸计数出现平局，则通过选择字典序最小的核苷酸来解决，遵循 `$\\text{A}  \\text{C}  \\text{G}  \\text{T}$` 的顺序。\n    - 这个过程产生一个全长的共有比对字符串。最终的“共有连接序列”是通过从此字符串中移除所有间隙字符生成的。这个无间隙序列的长度是该测试用例所需的第一个输出值。\n\n2.  **微同源长度计算**：此过程量化连接断点处的短序列一致性，并应用于共有序列和每个单独的读长。对于任何给定的字符串 `$s$` 和断点索引 `$b$`：\n    - 字符串被划分为一个左子串 `$s[0:b]$` 和一个右子串 `$s[b:L]$`。\n    - 从这两个子串中移除所有间隙字符（`'-'`），得到无间隙序列 `$s_{\\text{left}}$` 和 `$s_{\\text{right}}$`。\n    - 微同源长度 `$\\ell$` 是既是 `$s_{\\text{left}}$` 的后缀又是 `$s_{\\text{right}}$` 的前缀的最长字符串的长度。为找到此长度，我们检查长度为 `$k$` 的 `$s_{\\text{left}}$` 后缀和长度为 `$k$` 的 `$s_{\\text{right}}$` 前缀是否相等，从 `$k = \\min(|s_{\\text{left}}|, |s_{\\text{right}}|)$` 向下迭代到 `$1$`。找到的第一个匹配项即为 `$\\ell$` 的值。如果没有找到非空匹配，则 `$\\ell=0$`。\n    - 在共有比对字符串上执行此计算，可提供共有微同源长度 `$\\ell_{\\text{cons}}$`，这是第二个所需的输出。\n\n3.  **置信度分数量化**：微同源的置信度是使用贝叶斯框架，从单个读长中微同源长度的统计分布推导出来的。\n    - 首先，为 `$N$` 个读长中的每一个计算微同源长度 `$\\ell_r$`。\n    - 然后，对所得长度的频率进行计数。设 `$K$` 为在读长集合中观察到的唯一微同源长度的数量。\n    - “选定的”微同源长度 `$\\ell^\\ast$` 定义为出现最频繁的长度。如果最高频率出现平局，则通过在并列的候选项中选择最大的长度来打破平局。\n    - 设 `$c_{\\ell^\\ast}$` 是这个选定长度 `$\\ell^\\ast$` 的计数。\n    - 然后，使用给定的对称狄利克雷模型在均匀先验（`$\\alpha = 1$`）下的后验预测概率公式计算置信度分数：\n    $$ \\text{Confidence} = \\frac{c_{\\ell^\\ast} + \\alpha}{N + K\\alpha} = \\frac{c_{\\ell^\\ast} + 1}{N + K} $$\n    - 这个置信度值，表示为十进制浮点数，是该测试用例的第三个也是最后一个所需的输出。\n\n设计了一个 Python 程序来封装此逻辑。一个主函数遍历所有测试用例，将每个用例的数据传递给一个子函数，该子函数执行三个计算步骤并返回结果三元组。最终输出被格式化为这些三元组的列表。",
            "answer": "```python\nimport collections\n\ndef solve():\n    \"\"\"\n    Solves the genomic rearrangement problem by computing consensus sequences,\n    microhomology lengths, and confidence scores for a suite of test cases.\n    \"\"\"\n\n    def compute_results(reads: list[str], b: int) - list:\n        \"\"\"\n        Computes the required metrics for a single test case.\n\n        Args:\n            reads: A list of aligned sequence strings.\n            b: The breakpoint index.\n\n        Returns:\n            A list containing [length of gapless consensus, consensus microhomology, confidence].\n        \"\"\"\n        num_reads = len(reads)\n        if num_reads == 0:\n            return [0, 0, 0.0]\n        \n        len_reads = len(reads[0])\n        \n        # Requirement 1: Build a partial order alignment consensus\n        consensus_alignment_list = []\n        for i in range(len_reads):\n            # Tally non-gap bases in the current column\n            bases_in_col = [read[i] for read in reads if read[i] != '-']\n            \n            if not bases_in_col:\n                # If all reads have a gap, consensus is a gap\n                consensus_alignment_list.append('-')\n            else:\n                counts = collections.Counter(bases_in_col)\n                max_count = max(counts.values())\n                \n                # Tie-breaking: select the lexicographically smallest nucleotide\n                tied_bases = sorted([base for base, count in counts.items() if count == max_count])\n                consensus_alignment_list.append(tied_bases[0])\n\n        consensus_alignment_str = \"\".join(consensus_alignment_list)\n        consensus_junction_seq = consensus_alignment_str.replace('-', '')\n        len_consensus_junction = len(consensus_junction_seq)\n\n        def calculate_microhomology(s: str, b_idx: int) - int:\n            \"\"\"\n            Calculates microhomology length for a given sequence and breakpoint.\n            \"\"\"\n            left_part_raw = s[:b_idx]\n            right_part_raw = s[b_idx:]\n            \n            left_part = left_part_raw.replace('-', '')\n            right_part = right_part_raw.replace('-', '')\n            \n            max_l = min(len(left_part), len(right_part))\n            for l in range(max_l, 0, -1):\n                if left_part[-l:] == right_part[:l]:\n                    return l\n            return 0\n\n        # Requirement 2: Compute consensus microhomology length\n        l_cons = calculate_microhomology(consensus_alignment_str, b)\n\n        # Requirement 3: Compute per-read microhomology lengths\n        read_mh_lengths = [calculate_microhomology(read, b) for read in reads]\n\n        # Requirement 4  5: Determine selected length and compute confidence\n        mh_counts = collections.Counter(read_mh_lengths)\n        \n        # Determine the selected microhomology length l_star\n        max_count_mh = 0\n        if mh_counts:\n            max_count_mh = max(mh_counts.values())\n        \n        # Tie-breaking rule for l_star: select the larger length\n        tied_lengths = [length for length, count in mh_counts.items() if count == max_count_mh]\n        l_star = max(tied_lengths) if tied_lengths else 0\n        \n        c_l_star = mh_counts.get(l_star, 0)\n        \n        N = num_reads\n        K = len(mh_counts)  # Number of distinct microhomology length categories\n        \n        # Compute confidence using the Dirichlet posterior predictive model\n        confidence = (c_l_star + 1) / (N + K)\n\n        return [len_consensus_junction, l_cons, confidence]\n\n    test_cases = [\n        {\"reads\": [\"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGACGGAA\", \"TTACGATGGAA\"], \"b\": 5},\n        {\"reads\": [\"AGGTACCT\", \"AGGTTCCT\", \"AGGTACCT\", \"AGGTTCCT\"], \"b\": 4},\n        {\"reads\": [\"AAGCT-CTGAA\", \"AAGC-TCTGAA\", \"AA-GCTCTGAA\"], \"b\": 6},\n        {\"reads\": [\"GTCGATTGCT\", \"GTCGATTGCT\", \"GTCGATTGCT\"], \"b\": 5}\n    ]\n    \n    results = []\n    for case in test_cases:\n        result = compute_results(case[\"reads\"], case[\"b\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "当一个分析工具或算法鉴定出一组结构变异后，我们如何衡量其性能？最后一个练习将带您解决基准测试这一关键任务。您将应用精准率（precision）、召回率（recall）和 $F_1$ 分数等标准分类指标，将变异识别结果与“金标准”真实数据集进行比较，从而评估其准确性。这是临床基因组学和方法开发中一项常规但至关重要的工作。",
            "id": "4377762",
            "problem": "一项临床基因组学研究旨在使用长读长测序来基准评估结构变异（SV）检出性能，以解析复杂的基因组重排。通过正交实验和综合性人工审查，构建了一个包含 $120$ 个SV的高置信度真实集。一个长读长SV检出工具报告了 $110$ 个变异检出。由于长读长测序的断点估计可能存在轻微差异，一个预测的检出被认为与一个真实SV匹配，当且仅当SV类型相同，并且每个相关断点位于真实断点$\\pm 50$个碱基对（bp）的范围内。对于双断点SV（例如，缺失和倒位），两个断点都必须满足容差范围；对于单断点SV（例如，插入），单个断点必须满足相同的容差范围。在这些规则下，构建了一个在真实SV和预测SV之间的一对一二分匹配，以最大化匹配的总数。\n\n匹配后，汇总的混淆矩阵计数为：真阳性 $TP = 84$，假阳性 $FP = 26$，以及假阴性 $FN = 36$。\n\n从二元分类的核心定义出发，根据上述容差匹配范式，用 $TP$、$FP$ 和 $FN$ 来定义用于SV基准评估的精确率、召回率和 $F_1$ 分数。然后计算给定计数的 $F_1$ 分数。将最终数值四舍五入到四位有效数字。最终答案以纯数字形式表示，不带单位。",
            "solution": "问题陈述经过验证。\n\n**步骤1：提取给定信息**\n-   真实集中的结构变异（SV）数量：$120$。\n-   长读长检出工具的SV检出数量：$110$。\n-   断点的匹配容差：$\\pm 50$ bp。\n-   真阳性（$TP$）：$84$。\n-   假阳性（$FP$）：$26$。\n-   假阴性（$FN$）：$36$。\n\n**步骤2：使用提取的给定信息进行验证**\n该问题具有科学依据、提法明确且客观。它描述了对基因组变异检出工具进行基准评估的标准流程。所提供的数据是完整的且内部一致。\n\n-   实际阳性案例的总数（真实集中的SV）为 $120$。这必须等于真阳性（被正确识别的真实SV）和假阴性（被遗漏的真实SV）的总和。检查数据：$TP + FN = 84 + 36 = 120$。这与之一致。\n-   预测阳性案例的总数（算法检出的SV）为 $110$。这必须等于真阳性（正确作出的检出）和假阳性（错误作出的检出）的总和。检查数据：$TP + FP = 84 + 26 = 110$。这也与之一致。\n\n该问题是有效的，因为它没有科学上的不健全性、矛盾、模糊性或任何其他列出的缺陷。可以从提供的信息中推导出完整的解决方案。\n\n**求解过程**\n任务是在二元分类的背景下定义精确率、召回率和 $F_1$ 分数，然后根据给定数据计算 $F_1$ 分数。这些指标是评估分类模型性能的基础，在此案例中，分类模型即为SV检出工具。\n\n**真阳性（$TP$）** 是模型正确预测为阳性类的结果。在这里，它是一个与真实SV匹配的检出SV。给定 $TP = 84$。\n\n**假阳性（$FP$）** 是模型错误预测为阳性类的结果。在这里，它是一个不与任何真实SV匹配的检出SV。给定 $FP = 26$。这对应于过度检出或虚假检出。\n\n**假阴性（$FN$）** 是模型错误预测为阴性类的结果。在这里，它是一个未被检出工具检测到的真实SV。给定 $FN = 36$。这对应于灵敏度不足。\n\n**1. 指标的定义**\n\n**精确率 (Precision)**：精确率，也称为阳性预测值（PPV），衡量的是所有阳性预测中实际正确的比例。它回答了这样一个问题：“在算法检出的所有SV中，有多大比例是真实的？”其定义为：\n$$ \\text{Precision} = \\frac{TP}{TP + FP} $$\n\n**召回率 (Recall)**：召回率，也称为灵敏度（Sensitivity）或真阳性率（TPR），衡量的是所有实际阳性案例中被正确识别的比例。它回答了这样一个问题：“在样本中存在的所有真实SV中，算法找到了多大比例？”其定义为：\n$$ \\text{Recall} = \\frac{TP}{TP + FN} $$\n\n**$F_1$ 分数**：$F_1$ 分数是精确率和召回率的调和平均数。它提供了一个平衡两者的单一指标，这在类别分布不均时尤其有用。两个数 $a$ 和 $b$ 的调和平均数的通用公式是 $2 / (\\frac{1}{a} + \\frac{1}{b})$。因此，$F_1$ 分数为：\n$$ F_1 = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}} $$\n为了直接用 $TP$、$FP$ 和 $FN$ 表示 $F_1$ 分数，我们代入精确率和召回率的定义：\n$$ F_1 = 2 \\cdot \\frac{\\left(\\frac{TP}{TP + FP}\\right) \\cdot \\left(\\frac{TP}{TP + FN}\\right)}{\\left(\\frac{TP}{TP + FP}\\right) + \\left(\\frac{TP}{TP + FN}\\right)} $$\n为了简化，我们为主分式分母中的和式找到一个公分母：\n$$ F_1 = 2 \\cdot \\frac{\\frac{TP^2}{(TP + FP)(TP + FN)}}{\\frac{TP(TP + FN) + TP(TP + FP)}{(TP + FP)(TP + FN)}} $$\n从分子和分母中消去公因式 $(TP + FP)(TP + FN)$：\n$$ F_1 = \\frac{2 \\cdot TP^2}{TP(TP + FN) + TP(TP + FP)} $$\n从分母中提出因子 $TP$：\n$$ F_1 = \\frac{2 \\cdot TP^2}{TP((TP + FN) + (TP + FP))} = \\frac{2 \\cdot TP}{TP + FN + TP + FP} $$\n这简化为规范公式：\n$$ F_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN} $$\n\n**2. $F_1$ 分数的计算**\n\n使用提供的计数：$TP = 84$，$FP = 26$ 和 $FN = 36$。我们将这些值代入推导出的 $F_1$ 分数公式中。\n\n$$ F_1 = \\frac{2 \\cdot 84}{2 \\cdot 84 + 26 + 36} $$\n$$ F_1 = \\frac{168}{168 + 26 + 36} $$\n$$ F_1 = \\frac{168}{168 + 62} $$\n$$ F_1 = \\frac{168}{230} $$\n现在，我们计算数值：\n$$ F_1 = \\frac{168}{230} \\approx 0.73043478... $$\n题目要求将最终答案四舍五入到四位有效数字。前四位有效数字是 $7$、$3$、$0$ 和 $4$。第五位有效数字是 $3$，小于 $5$，所以我们向下舍入。\n$$ F_1 \\approx 0.7304 $$",
            "answer": "$$\\boxed{0.7304}$$"
        }
    ]
}