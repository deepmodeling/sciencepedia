{
    "hands_on_practices": [
        {
            "introduction": "细胞解卷积的成功在很大程度上依赖于一个准确的细胞类型特异性表达谱，即特征矩阵 $S$。在实践中，这个矩阵通常源自单细胞RNA测序（scRNA-seq）数据。这个练习将指导您完成一个标准的生物信息学流程，将原始的scRNA-seq计数数据处理成一个稳健的特征矩阵，其中涵盖了处理scRNA-seq数据技术性偏差所必需的关键步骤，例如文库大小归一化和方差稳定化转换 。掌握这一过程至关重要，因为解卷积结果的质量直接取决于输入特征矩阵的质量。",
            "id": "4321251",
            "problem": "您将获得单细胞RNA测序 (scRNA-seq) 计数数据以及 $K$ 种类型的整数细胞类型标签。您的任务是构建一个参考特征矩阵 $S \\in \\mathbb{R}^{G \\times K}$，其中条目 $S_{g,t}$ 表示基因 $g$ 在经过适当预处理后，在线性尺度上按细胞类型计算的平均表达量。该构建过程必须基于科学合理的步骤，这些步骤植根于组织块表达的混合模型。在该模型中，基因 $g$ 的组织块表达被建模为细胞类型特异性表达的线性组合：$$Y_g \\approx \\sum_{t=1}^{K} S_{g,t} \\, w_t,$$ 其中 $Y_g$ 是线性单位下的组织块表达量，$w_t$ 是总和为1的非负混合权重。为确保在具有不同捕获效率和测序深度的细胞之间具有可比性，您必须通过文库大小对scRNA-seq计数进行归一化并稳定方差，然后返回到与混合模型一致的线性尺度。\n\n从以下核心事实和定义开始：\n- 单细胞RNA测序 (scRNA-seq) 计数数据是非负整数，由于技术因素（捕获效率、测序深度），每个细胞的文库大小可变。\n- 细胞 $i$ 的文库大小定义为 $$L_i = \\sum_{g=1}^{G} C_{g,i},$$ 其中 $C_{g,i}$ 是细胞 $i$ 中基因 $g$ 的原始计数。\n- 计数可以缩放为每百万计数 (CPM)，这是一个线性单位，通过以下公式计算：$$X_{g,i} = \\begin{cases} \\dfrac{C_{g,i}}{L_i} \\times M,  L_i > 0, \\\\ 0,  L_i = 0, \\end{cases}$$ 其中 $M = 10^6$（一百万）代表目标文库大小。\n- 对数转换通常用于稳定计数衍生度量的方差；然而，混合模型要求 $S$ 处于线性尺度。\n\n您必须实现以下步骤：\n1. 计算所有细胞的文库大小 $L_i$。\n2. 使用上述规则（$M = 10^6$）将计数归一化为CPM。\n3. 通过计算 $$Z_{g,i} = \\log\\!\\big(1 + X_{g,i}\\big),$$ 应用方差稳定化，使用自然对数。\n4. 对于每种细胞类型 $t \\in \\{1, \\dots, K\\}$，计算 $Z_{g,i}$ 在类型 $t$ 的细胞上的均值：$$\\mu_{g,t} = \\frac{1}{n_t} \\sum_{i \\in I_t} Z_{g,i},$$ 其中 $I_t$ 是标签为 $t$ 的细胞的索引集合，$n_t = |I_t|$。\n5. 反向转换回线性CPM尺度：$$S_{g,t} = \\exp(\\mu_{g,t}) - 1.$$\n\n按如下方式处理边界情况：\n- 如果某个细胞的 $L_i = 0$，则为所有 $g$ 定义 $X_{g,i} = 0$，以避免除以零，并且因为没有计数意味着该细胞没有表达的证据。\n- 如果某种细胞类型 $t$ 没有细胞（即 $n_t = 0$），则为所有 $g$ 定义 $S_{g,t} = 0$。\n\n单位：$S$ 的所有输出必须以每百万计数 (CPM) 表示，为实值浮点数。对数是无单位的。不涉及角度。如果概念上出现百分比，必须表示为小数，但您的程序不应计算混合权重。\n\n您的程序必须实现上述流程，并为下面的每个测试用例计算 $S$。对于每个用例，返回一个包含 $G \\times K$ 个浮点数的行主序扁平化列表，四舍五入到六位小数。\n\n测试套件：\n- 用例 A（一般情况，$G = 4$, $N = 6$, $K = 3$）：\n  $$C = \\begin{bmatrix}\n  100  200  0  50  400  300 \\\\\n  0  100  50  0  200  100 \\\\\n  500  0  0  300  100  0 \\\\\n  0  0  100  200  0  0\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 1, 2, 2, 3, 3], \\quad M = 10^6.$$\n- 用例 B（边界情况：文库大小为零的细胞，基因全为零，$G = 3$, $N = 4$, $K = 2$）：\n  $$C = \\begin{bmatrix}\n  0  0  100  0 \\\\\n  0  0  0  0 \\\\\n  0  50  0  50\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 1, 2, 2], \\quad M = 10^6.$$\n- 用例 C（边界情况：单一细胞类型，计数偏斜，$G = 2$, $N = 3$, $K = 2$）：\n  $$C = \\begin{bmatrix}\n  1000  2000  3000 \\\\\n  5000  0  0\n  \\end{bmatrix}, \\quad \\text{labels} = [1, 2, 2], \\quad M = 10^6.$$\n\n最终输出格式：\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例，并且本身是一个用方括号括起来的、逗号分隔的 $S$ 值的扁平化列表（按行主序），四舍五入到六位小数。例如：\n$$[ [s^{(A)}_1,\\dots,s^{(A)}_{G\\cdot K}], [s^{(B)}_1,\\dots,s^{(B)}_{G\\cdot K}], [s^{(C)}_1,\\dots,s^{(C)}_{G\\cdot K}] ].$$",
            "solution": "用户提供了一个定义明确的计算生物学问题，即从单细胞RNA测序 (scRNA-seq) 计数数据构建细胞类型特征矩阵 $S$。该问题在科学上是合理的，在数学上是精确的，并且在算法上是明确的。它被验证为一个合法的问题。\n\n目标是计算一个特征矩阵 $S \\in \\mathbb{R}^{G \\times K}$，其中 $S_{g,t}$ 代表基因 $g$ 对于细胞类型 $t$ 的平均表达量。该矩阵对于细胞解卷积至关重要，细胞解卷积旨在利用线性混合模型 $Y_g \\approx \\sum_{t=1}^{K} S_{g,t} \\, w_t$ 从组织块表达数据中估算细胞类型比例。所提供的方法是生物信息学中一个标准且稳健的流程。解决方案通过实施指定的步骤来推进，每个步骤都基于既定的科学原理。\n\n**第1步：按文库大小进行归一化**\n\n原始数据包含一个计数矩阵 $C \\in \\mathbb{Z}_{\\ge 0}^{G \\times N}$，其中 $C_{g,i}$ 是在细胞 $i$ 中检测到的基因 $g$ 的RNA转录本数量。scRNA-seq中技术变异的一个主要来源是细胞间测序深度和捕获效率的差异。细胞 $i$ 的文库大小，定义为转录本总数 $L_i = \\sum_{g=1}^{G} C_{g,i}$，可作为这些技术因素的代表。为了使表达水平在细胞间具有可比性，必须对原始计数进行归一化。\n\n问题指定了归一化为每百万计数 (CPM)，这是一种广泛使用的方法。基因 $g$ 在细胞 $i$ 中的CPM值，记为 $X_{g,i}$，计算如下：\n$$\nX_{g,i} = \\begin{cases} \\dfrac{C_{g,i}}{L_i} \\times M,  L_i > 0, \\\\ 0,  L_i = 0. \\end{cases}\n$$\n在这里，$M = 10^6$ 是一个缩放因子，它为所有细胞设定了一个共同的文库大小（一百万）。这种变换将表达数据置于一个线性的、可比较的尺度上，同时正确处理了总计数为零的细胞（$L_i = 0$）的边界情况，对于这些细胞，表达量逻辑上为零。\n\n**第2步：方差稳定化**\n\n基因表达计数数据，即使在归一化后，也常常表现出异方差性，即表达的方差随均值的增加而增加。这一特性可能导致在下游分析中，高表达基因被赋予过大的权重。对数转换是一种标准的统计技术，用于稳定方差，使其在整个表达值范围内更加均匀。\n\n指定的转换为：\n$$\nZ_{g,i} = \\log\\!\\big(1 + X_{g,i}\\big)\n$$\n其中 $\\log$ 表示自然对数。加上一个伪计数 $1$ 有两个目的：它避免了对零取对数（因为 $X_{g,i} \\ge 0$），并且它减弱了对数对小计数值的影响，防止了低表达基因之间比率的不当膨胀。\n\n**第3步：按细胞类型聚合**\n\n为了为每种细胞类型创建典型的表达特征，我们必须聚合属于该类型的所有细胞的表达谱。问题指定细胞类型标签是从 $1$ 到 $K$ 的整数。对于每个基因 $g$ 和细胞类型 $t$，特征是从对数转换值的平均值中导出的。\n\n设 $I_t$ 为对应于类型 $t$ 的细胞索引集合，$n_t = |I_t|$ 为此类细胞的数量。平均对数表达量 $\\mu_{g,t}$ 计算如下：\n$$\n\\mu_{g,t} = \\frac{1}{n_t} \\sum_{i \\in I_t} Z_{g,i}\n$$\n在对数空间中取平均值比在线性CPM尺度上取平均值对离群值更具鲁棒性。单个细胞中的极端表达值对均值的影响会减小。如果数据集中没有代表某种细胞类型 $t$（$n_t = 0$），则其特征谱 $S_{g,t}$ 对所有基因 $g$ 都定义为 $0$，这是一个合乎逻辑的默认值。\n\n**第4步：反向转换到线性尺度**\n\n最终的特征矩阵 $S$ 旨在用于线性混合模型。\n因此，聚合的表达值必须是线性尺度，而不是对数尺度。平均对数表达值 $\\mu_{g,t}$ 必须被转换回原始的CPM尺度。\n\n变换 $z = \\log(1+x)$ 的逆是 $x = \\exp(z) - 1$。将此应用于 $\\mu_{g,t}$ 得到最终的特征矩阵条目：\n$$\nS_{g,t} = \\exp(\\mu_{g,t}) - 1\n$$\n这个值 $S_{g,t}$ 可以被解释为基因 $g$ 在细胞类型 $t$ 中表达的中心趋势的稳健度量。它等同于类型 $t$ 所有细胞的 $(1+X_{g,i})$ 值的几何平均数减 $1$。这提供了一个在线性CPM尺度上的代表性表达值，适用于解卷积算法。\n\n完整的流程构成了一种从scRNA-seq数据构建高质量特征矩阵的有原则且科学合理的方法。",
            "answer": "```python\nimport numpy as np\n\ndef build_signature_matrix(C, labels, M=1e6):\n    \"\"\"\n    Constructs a reference signature matrix S from scRNA-seq count data.\n\n    Args:\n        C (np.ndarray): A GxN matrix of raw counts (G aenes, N cells).\n        labels (np.ndarray): A 1D array of N integer cell-type labels (1-based).\n        M (float): The scaling factor for CPM normalization (e.g., 10^6).\n\n    Returns:\n        np.ndarray: The GxK signature matrix S.\n    \"\"\"\n    # Defensive copy to avoid modifying original inputs\n    C = C.astype(np.float64)\n    labels = np.array(labels, dtype=int)\n\n    G, N = C.shape\n    if N == 0:\n        # Handle case with no cells\n        K = np.max(labels) if labels.size > 0 else 0\n        return np.zeros((G, K))\n    \n    # Step 1: Compute library sizes\n    L = C.sum(axis=0)\n\n    # Step 2: Normalize to counts per million (CPM)\n    X = np.zeros_like(C, dtype=np.float64)\n    valid_cells_mask = L > 0\n    # Use np.divide with a 'where' clause for safe division\n    X[:, valid_cells_mask] = np.divide(C[:, valid_cells_mask], L[valid_cells_mask], where=L[valid_cells_mask] > 0) * M\n    \n    # Step 3: Apply variance stabilization\n    Z = np.log(1.0 + X)\n\n    # Determine K, the number of cell types\n    # The problem implies labels are 1...K, so max(labels) defines K.\n    K = np.max(labels) if labels.size > 0 else 0\n    S = np.zeros((G, K), dtype=np.float64)\n    \n    # Iterate through cell types 1 to K\n    for t in range(1, K + 1):\n        # Find indices for cells of the current type t\n        cell_indices = np.where(labels == t)[0]\n        n_t = len(cell_indices)\n\n        # Step 4  5: Aggregate and Back-transform\n        if n_t > 0:\n            # Select columns from Z for the current cell type\n            Z_t = Z[:, cell_indices]\n            \n            # Compute the mean of log-transformed values\n            mu_gt = np.mean(Z_t, axis=1)\n            \n            # Back-transform to the linear scale and assign to S\n            # S columns are 0-indexed, so we use t-1\n            S[:, t - 1] = np.exp(mu_gt) - 1.0\n        else:\n            # Per the problem, if a cell type has no cells, its signature is all zeros.\n            # S is initialized to zeros, so no action is needed.\n            pass\n            \n    return S\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    test_cases = [\n        (\n            np.array([\n                [100, 200, 0, 50, 400, 300],\n                [0, 100, 50, 0, 200, 100],\n                [500, 0, 0, 300, 100, 0],\n                [0, 0, 100, 200, 0, 0]\n            ]),\n            np.array([1, 1, 2, 2, 3, 3])\n        ),\n        (\n            np.array([\n                [0, 0, 100, 0],\n                [0, 0, 0, 0],\n                [0, 50, 0, 50]\n            ]),\n            np.array([1, 1, 2, 2])\n        ),\n        (\n            np.array([\n                [1000, 2000, 3000],\n                [5000, 0, 0]\n            ]),\n            np.array([1, 2, 2])\n        )\n    ]\n\n    all_results_str = []\n    for C, labels in test_cases:\n        S = build_signature_matrix(C, labels)\n        \n        # Flatten the matrix in row-major ('C') order\n        flat_S = S.flatten(order='C')\n        \n        # Format each number to six decimal places\n        formatted_S = [f\"{val:.6f}\" for val in flat_S]\n        \n        # Create the string for the current case's result list\n        case_result_str = f\"[{','.join(formatted_S)}]\"\n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "在获得特征矩阵 $S$ 后，核心任务是从一个整体组织样本的表达谱 $y$ 中估算出不同细胞类型的比例 $p$。本练习提供了一个动手计算，旨在通过约束非负最小二乘法（NNLS）来解决这个核心解卷积问题 。该方法将整体组织的表达建模为各细胞类型表达谱的线性组合，并寻求能够最小化重建误差的比例向量，同时满足物理约束（即比例必须为非负数且总和为1）。通过这个具体的数值示例，您将对构成大多数解卷积算法基础的数学目标函数和约束条件有更深入和实践性的理解。",
            "id": "4321276",
            "problem": "在用于精准医疗和基因组诊断中细胞解卷积的整体组织基因表达线性混合模型中，观测到的整体表达向量 $\\mathbf{y} \\in \\mathbb{R}^{5}$ 被建模为细胞类型特异性表达谱的凸组合，即 $\\mathbf{y} \\approx \\mathbf{S}\\mathbf{p}$。其中，$\\mathbf{S} \\in \\mathbb{R}^{5 \\times 3}$ 是特征矩阵（其列为 5 个基因在 3 种细胞类型中的表达谱），$\\mathbf{p} \\in \\mathbb{R}^{3}$ 是满足 $\\mathbf{1}^{\\top}\\mathbf{p} = 1$ 的非负细胞类型比例向量。考虑一个包含 5 个基因和 3 种细胞类型的场景，其特征矩阵和整体向量由下式给出：\n$$\n\\mathbf{S} = \n\\begin{bmatrix}\n8  2  0 \\\\\n1  4  3 \\\\\n0  5  2 \\\\\n3  1  0 \\\\\n2  0  6\n\\end{bmatrix},\n\\quad\n\\mathbf{y} =\n\\begin{bmatrix}\n3.2 \\\\\n2.8 \\\\\n2.6 \\\\\n1.3 \\\\\n2.4\n\\end{bmatrix},\n$$\n其中所有数值的单位均为百万转录本（TPM）。使用带有等式约束 $\\mathbf{1}^{\\top}\\mathbf{p} = 1$ 的非负最小二乘法公式，计算最优细胞类型比例向量 $\\hat{\\mathbf{p}}$，然后计算以 TPM 为单位的残差欧几里得范数 $\\|\\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y}\\|_{2}$。以 TPM 表示最终的残差范数，如果需要四舍五入，请将答案保留到四位有效数字。答案必须是一个实数值。",
            "solution": "用户提供了一个来自基因组诊断领域的问题，具体涉及整体组织表达数据的细胞解卷积。任务是计算最优细胞类型比例向量 $\\hat{\\mathbf{p}}$ 和相应的残差范数 $\\|\\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y}\\|_{2}$。\n\n首先，需要对问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n-   整体表达的模型是 $\\mathbf{y} \\approx \\mathbf{S}\\mathbf{p}$。\n-   整体表达向量为 $\\mathbf{y} = \\begin{bmatrix} 3.2 \\\\ 2.8 \\\\ 2.6 \\\\ 1.3 \\\\ 2.4 \\end{bmatrix}$。\n-   特征矩阵为 $\\mathbf{S} = \\begin{bmatrix} 8  2  0 \\\\ 1  4  3 \\\\ 0  5  2 \\\\ 3  1  0 \\\\ 2  0  6 \\end{bmatrix}$。\n-   细胞类型比例向量 $\\mathbf{p} \\in \\mathbb{R}^{3}$ 必须满足以下约束条件：\n    1.  非负性：对于 $i=1, 2, 3$，$p_i \\ge 0$。这可以写成 $\\mathbf{p} \\ge \\mathbf{0}$。\n    2.  和为一：$\\sum_{i=1}^{3} p_i = 1$。这可以写成 $\\mathbf{1}^{\\top}\\mathbf{p} = 1$。\n-   该优化问题是一个带约束的非负最小二乘问题：找到使 $\\|\\mathbf{S}\\mathbf{p} - \\mathbf{y}\\|_{2}$ 最小化的 $\\hat{\\mathbf{p}}$。这等价于最小化 $\\|\\mathbf{S}\\mathbf{p} - \\mathbf{y}\\|_{2}^2$。\n-   最终需要计算的量是残差欧几里得范数 $\\|\\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y}\\|_{2}$。\n-   如果需要四舍五入，最终答案必须保留到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据。线性混合模型 $\\mathbf{y} = \\mathbf{S}\\mathbf{p}$ 是对整体转录组数据进行计算解卷积的标准且广泛使用的公式。带有和为一约束的非负最小二乘法这一优化框架是求解细胞类型比例 $\\mathbf{p}$ 的常用方法。数据类型（实值表达水平）和维度都是符合实际的。\n\n该问题在数学上是适定的。目标函数 $f(\\mathbf{p}) = \\|\\mathbf{S}\\mathbf{p} - \\mathbf{y}\\|_{2}^2$ 是凸函数。由 $\\mathbf{p} \\ge \\mathbf{0}$ 和 $\\mathbf{1}^{\\top}\\mathbf{p} = 1$ 定义的约束集是一个单纯形，它是一个凸的紧集。在凸集上对凸函数进行最小化存在唯一的全局最小值。因此，存在唯一的解 $\\hat{\\mathbf{p}}$。\n\n问题陈述完整、客观，且不包含矛盾或含糊之处。\n\n### 步骤 3：结论与行动\n该问题被视为有效。下面将进行求解。\n\n### 解题过程\n该优化问题是找到能解决以下问题的 $\\hat{\\mathbf{p}}$：\n$$ \\underset{\\mathbf{p}}{\\text{minimize}} \\quad \\frac{1}{2}\\|\\mathbf{S}\\mathbf{p} - \\mathbf{y}\\|_{2}^2 $$\n$$ \\text{subject to} \\quad \\mathbf{p} \\ge \\mathbf{0} \\quad \\text{and} \\quad \\mathbf{1}^{\\top}\\mathbf{p} = 1 $$\n设 $\\mathbf{p} = [p_1, p_2, p_3]^{\\top}$。等式约束 $\\mathbf{1}^{\\top}\\mathbf{p} = 1$ 可用于消去其中一个变量。令 $p_3 = 1 - p_1 - p_2$。该问题可以用 $p_1$ 和 $p_2$ 重新表述。\n约束条件变为 $p_1 \\ge 0$，$p_2 \\ge 0$，以及 $1 - p_1 - p_2 \\ge 0$，可简化为 $p_1 + p_2 \\le 1$。\n\n设 $\\mathbf{S}$ 的列向量为 $\\mathbf{c}_1, \\mathbf{c}_2, \\mathbf{c}_3$。$\\mathbf{S}\\mathbf{p}$ 项可以重写为：\n$$ \\mathbf{S}\\mathbf{p} = p_1\\mathbf{c}_1 + p_2\\mathbf{c}_2 + p_3\\mathbf{c}_3 = p_1\\mathbf{c}_1 + p_2\\mathbf{c}_2 + (1-p_1-p_2)\\mathbf{c}_3 = p_1(\\mathbf{c}_1 - \\mathbf{c}_3) + p_2(\\mathbf{c}_2 - \\mathbf{c}_3) + \\mathbf{c}_3 $$\n令 $\\mathbf{p}' = \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix}$，$\\mathbf{S}' = \\begin{bmatrix} \\mathbf{c}_1 - \\mathbf{c}_3  \\mathbf{c}_2 - \\mathbf{c}_3 \\end{bmatrix}$，以及 $\\mathbf{y}' = \\mathbf{y} - \\mathbf{c}_3$。目标函数变为在约束条件 $p_1 \\ge 0, p_2 \\ge 0, p_1+p_2 \\le 1$ 下最小化 $\\|\\mathbf{S}'\\mathbf{p}' - \\mathbf{y}'\\|_{2}^2$。\n\n首先，我们计算 $\\mathbf{S}'$ 和 $\\mathbf{y}'$：\n$$\n\\mathbf{c}_1 - \\mathbf{c}_3 = \\begin{bmatrix} 8-0 \\\\ 1-3 \\\\ 0-2 \\\\ 3-0 \\\\ 2-6 \\end{bmatrix} = \\begin{bmatrix} 8 \\\\ -2 \\\\ -2 \\\\ 3 \\\\ -4 \\end{bmatrix}, \\quad\n\\mathbf{c}_2 - \\mathbf{c}_3 = \\begin{bmatrix} 2-0 \\\\ 4-3 \\\\ 5-2 \\\\ 1-0 \\\\ 0-6 \\end{bmatrix} = \\begin{bmatrix} 2 \\\\ 1 \\\\ 3 \\\\ 1 \\\\ -6 \\end{bmatrix}\n$$\n所以，$\\mathbf{S}' = \\begin{bmatrix} 8  2 \\\\ -2  1 \\\\ -2  3 \\\\ 3  1 \\\\ -4  -6 \\end{bmatrix}$。\n$$\n\\mathbf{y}' = \\mathbf{y} - \\mathbf{c}_3 = \\begin{bmatrix} 3.2 \\\\ 2.8 \\\\ 2.6 \\\\ 1.3 \\\\ 2.4 \\end{bmatrix} - \\begin{bmatrix} 0 \\\\ 3 \\\\ 2 \\\\ 0 \\\\ 6 \\end{bmatrix} = \\begin{bmatrix} 3.2 \\\\ -0.2 \\\\ 0.6 \\\\ 1.3 \\\\ -3.6 \\end{bmatrix}\n$$\n我们首先通过求解正规方程组 $(\\mathbf{S}')^{\\top}\\mathbf{S}'\\mathbf{p}' = (\\mathbf{S}')^{\\top}\\mathbf{y}'$ 来解决无约束最小二乘问题。\n\n让我们计算矩阵 $(\\mathbf{S}')^{\\top}\\mathbf{S}'$ 和 $(\\mathbf{S}')^{\\top}\\mathbf{y}'$：\n$$\n(\\mathbf{S}')^{\\top}\\mathbf{S}' = \n\\begin{bmatrix}\n8  -2  -2  3  -4 \\\\\n2  1  3  1  -6\n\\end{bmatrix}\n\\begin{bmatrix} 8  2 \\\\ -2  1 \\\\ -2  3 \\\\ 3  1 \\\\ -4  -6 \\end{bmatrix}\n=\n\\begin{bmatrix}\n64+4+4+9+16  16-2-6+3+24 \\\\\n16-2-6+3+24  4+1+9+1+36\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n97  35 \\\\\n35  51\n\\end{bmatrix}\n$$\n$$\n(\\mathbf{S}')^{\\top}\\mathbf{y}' = \n\\begin{bmatrix}\n8  -2  -2  3  -4 \\\\\n2  1  3  1  -6\n\\end{bmatrix}\n\\begin{bmatrix} 3.2 \\\\ -0.2 \\\\ 0.6 \\\\ 1.3 \\\\ -3.6 \\end{bmatrix}\n=\n\\begin{bmatrix}\n8(3.2) - 2(-0.2) - 2(0.6) + 3(1.3) - 4(-3.6) \\\\\n2(3.2) + 1(-0.2) + 3(0.6) + 1(1.3) - 6(-3.6)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n25.6 + 0.4 - 1.2 + 3.9 + 14.4 \\\\\n6.4 - 0.2 + 1.8 + 1.3 + 21.6\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n43.1 \\\\\n30.9\n\\end{bmatrix}\n$$\n待求解的方程组是 $\\begin{bmatrix} 97  35 \\\\ 35  51 \\end{bmatrix} \\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\begin{bmatrix} 43.1 \\\\ 30.9 \\end{bmatrix}$。\n该矩阵的行列式为 $97 \\times 51 - 35^2 = 4947 - 1225 = 3722$。\n解 $\\mathbf{p}'$ 由下式给出：\n$$\n\\begin{bmatrix} p_1 \\\\ p_2 \\end{bmatrix} = \\frac{1}{3722} \\begin{bmatrix} 51  -35 \\\\ -35  97 \\end{bmatrix} \\begin{bmatrix} 43.1 \\\\ 30.9 \\end{bmatrix}\n= \\frac{1}{3722} \\begin{bmatrix} 51(43.1) - 35(30.9) \\\\ -35(43.1) + 97(30.9) \\end{bmatrix}\n= \\frac{1}{3722} \\begin{bmatrix} 2198.1 - 1081.5 \\\\ -1508.5 + 2997.3 \\end{bmatrix}\n= \\frac{1}{3722} \\begin{bmatrix} 1116.6 \\\\ 1488.8 \\end{bmatrix}\n= \\begin{bmatrix} 0.3 \\\\ 0.4 \\end{bmatrix}\n$$\n因此，无约束解为 $p_1 = 0.3$ 和 $p_2 = 0.4$。我们必须检查该解是否满足简化后问题的约束条件：\n1. $p_1 = 0.3 \\ge 0$ (满足)\n2. $p_2 = 0.4 \\ge 0$ (满足)\n3. $p_1 + p_2 = 0.3 + 0.4 = 0.7 \\le 1$ (满足)\n\n由于无约束解位于可行域内，因此它也是带约束问题的解。\n现在我们求 $p_3$：\n$$ p_3 = 1 - p_1 - p_2 = 1 - 0.3 - 0.4 = 0.3 $$\n这满足约束条件 $p_3 \\ge 0$。\n因此，最优细胞类型比例向量为 $\\hat{\\mathbf{p}} = \\begin{bmatrix} 0.3 \\\\ 0.4 \\\\ 0.3 \\end{bmatrix}$。\n\n最后一步是计算残差欧几里得范数 $\\|\\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y}\\|_{2}$。首先，我们计算拟合的整体表达向量 $\\hat{\\mathbf{y}} = \\mathbf{S}\\hat{\\mathbf{p}}$：\n$$\n\\hat{\\mathbf{y}} = \\mathbf{S}\\hat{\\mathbf{p}} = \n\\begin{bmatrix}\n8  2  0 \\\\\n1  4  3 \\\\\n0  5  2 \\\\\n3  1  0 \\\\\n2  0  6\n\\end{bmatrix}\n\\begin{bmatrix}\n0.3 \\\\\n0.4 \\\\\n0.3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n8(0.3) + 2(0.4) + 0(0.3) \\\\\n1(0.3) + 4(0.4) + 3(0.3) \\\\\n0(0.3) + 5(0.4) + 2(0.3) \\\\\n3(0.3) + 1(0.4) + 0(0.3) \\\\\n2(0.3) + 0(0.4) + 6(0.3)\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n2.4 + 0.8 \\\\\n0.3 + 1.6 + 0.9 \\\\\n2.0 + 0.6 \\\\\n0.9 + 0.4 \\\\\n0.6 + 1.8\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n3.2 \\\\\n2.8 \\\\\n2.6 \\\\\n1.3 \\\\\n2.4\n\\end{bmatrix}\n$$\n我们观察到拟合向量 $\\hat{\\mathbf{y}}$ 与观测向量 $\\mathbf{y}$ 完全相等。\n残差向量是：\n$$ \\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y} = \\begin{bmatrix} 3.2 \\\\ 2.8 \\\\ 2.6 \\\\ 1.3 \\\\ 2.4 \\end{bmatrix} - \\begin{bmatrix} 3.2 \\\\ 2.8 \\\\ 2.6 \\\\ 1.3 \\\\ 2.4 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} = \\mathbf{0} $$\n因此，残差欧几里得范数为：\n$$ \\|\\mathbf{S}\\hat{\\mathbf{p}} - \\mathbf{y}\\|_{2} = \\|\\mathbf{0}\\|_{2} = \\sqrt{0^2+0^2+0^2+0^2+0^2} = 0 $$\n结果是精确值 $0$，因此无需四舍五入。这表明观测数据可以被线性混合模型完美解释，意味着向量 $\\mathbf{y}$ 位于特征矩阵 $\\mathbf{S}$ 列向量的凸包内。",
            "answer": "$$\\boxed{0}$$"
        },
        {
            "introduction": "虽然最小二乘法为我们提供了一个精确的点估计值，但贝叶斯方法允许我们整合先验知识，并对估计结果的不确定性进行量化。本练习将探讨一个共轭的狄利克雷-多项式模型（Dirichlet-Multinomial model）来估计细胞类型比例 。您将学习如何使用一个非对称的狄利克雷先验（asymmetric Dirichlet prior）来编码关于稀有细胞类型的先验信念，以及如何利用观测数据来更新这些信念，从而获得关于比例的完整后验分布。这项高级练习展示了贝叶斯建模在基因组学中的强大能力，它不仅提供了一个答案（后验均值），还提供了对该答案的置信度度量（后验方差），这对于临床决策至关重要。",
            "id": "4321280",
            "problem": "您正在为精准医疗和基因组诊断对体组织（bulk-tissue）表达数据中的细胞组成比例进行建模。假设潜在的细胞类型比例向量为 $p = (p_1, \\dots, p_K)$，其中 $p_j \\ge 0$ 且 $\\sum_{j=1}^K p_j = 1$。您在 $p$ 上放置一个非对称狄利克雷先验（asymmetric Dirichlet prior）来编码关于稀有细胞类型的先验知识：$p \\sim \\text{Dirichlet}(\\alpha_1, \\dots, \\alpha_K)$，其中稀有细胞类型具有较小的集中度参数 $ \\alpha_j $。然后，您观测到总数为 $N = \\sum_{j=1}^K x_j$ 次分配的细胞类型特异性聚合计数 $x = (x_1, \\dots, x_K)$，该计数由以 $p$ 为参数的多项式似然（Multinomial likelihood）建模。\n\n从多项式似然和狄利克雷先验的基本定义及其贝叶斯共轭性出发，推导在给定 $x$ 的情况下 $p$ 的后验分布。从该后验分布中，推导出后验均值 $\\mathbb{E}[p_j \\mid x]$ 和后验方差 $\\mathrm{Var}(p_j \\mid x)$ 关于后验集中度参数的一般表达式。使用这些表达式，通过改变单个集中度参数 $ \\alpha_j $ 同时保持所有其他集中度参数不变，来编码关于稀有细胞类型的先验知识。通过计算精确值（不使用百分号；所有比例均表示为小数），模拟在几种情景下改变该单个参数如何影响相应 $p_j$ 的后验均值和方差。\n\n实现一个程序，针对下方的每个测试用例，该程序接受：\n- 一个非对称先验集中度向量 $(\\alpha_1, \\dots, \\alpha_K)$，\n-一个索引 $j$，指定要更改其单个集中度参数的稀有细胞类型，\n- 一个用于替换 $\\alpha_j$ 的值列表，\n- 一个观测到的计数值向量 $(x_1, \\dots, x_K)$，\n\n并为 $\\alpha_j$ 的每个替换值，输出相应后验分布下 $p_j$ 的后验均值和方差。一个测试用例的输出应为一个浮点数列表，顺序为 $[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\dots]$，其中每一对对应 $\\alpha_j$ 的一个替换值。\n\n使用以下旨在探究不同情况的测试套件：\n\n- 测试用例 1（一般情况，稀有细胞计数较少）：\n  - $K = 5$\n  - 先验集中度：$(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4, \\alpha_5) = (0.5, 2.0, 2.0, 1.0, 0.1)$\n  - 稀有细胞类型索引：$j = 5$\n  - $\\alpha_j$ 的替换值：$[0.05, 0.1, 1.0]$\n  - 观测计数：$(x_1, x_2, x_3, x_4, x_5) = (60, 180, 140, 15, 5)$\n\n- 测试用例 2（边界情况，稀有细胞的观测计数为零）：\n  - $K = 4$\n  - 先验集中度：$(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4) = (1.5, 1.5, 1.5, 0.05)$\n  - 稀有细胞类型索引：$j = 4$\n  - $\\alpha_j$ 的替换值：$[0.01, 0.05, 5.0]$\n  - 观测计数：$(x_1, x_2, x_3, x_4) = (120, 80, 50, 0)$\n\n- 测试用例 3（稀有细胞的先验相对于数据较大）：\n  - $K = 3$\n  - 先验集中度：$(\\alpha_1, \\alpha_2, \\alpha_3) = (0.5, 0.5, 100.0)$\n  - 稀有细胞类型索引：$j = 3$\n  - $\\alpha_j$ 的替换值：$[10.0, 100.0, 1000.0]$\n  - 观测计数：$(x_1, x_2, x_3) = (30, 20, 10)$\n\n- 测试用例 4（小样本量，多种稀有类型，对先验的敏感性）：\n  - $K = 6$\n  - 先验集中度：$(\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4, \\alpha_5, \\alpha_6) = (0.2, 0.2, 0.2, 0.2, 0.2, 0.2)$\n  - 稀有细胞类型索引：$j = 3$\n  - $\\alpha_j$ 的替换值：$[0.01, 0.2, 2.0]$\n  - 观测计数：$(x_1, x_2, x_3, x_4, x_5, x_6) = (2, 1, 0, 0, 1, 0)$\n\n您的程序应生成单行输出，其中包含所有四个测试用例的聚合结果，形式为方括号括起来的逗号分隔列表，每个测试用例贡献一个如上所述格式的内部列表。所有数值输出都应是四舍五入到小数点后六位的小数。最终输出必须是 $[[\\text{mean}_1,\\text{var}_1,\\text{mean}_2,\\text{var}_2,\\dots],[\\dots],[\\dots],[\\dots]]$ 的形式，并精确地作为单行打印，无任何附加文本。",
            "solution": "我们首先对体组织表达数据的细胞解卷积（cellular deconvolution）概率模型进行形式化。令 $p = (p_1, \\dots, p_K)$ 表示细胞类型比例向量，其中 $p_j \\ge 0$ 且 $\\sum_{j=1}^K p_j = 1$。为了编码先验知识，我们在 $p$ 上放置一个非对称狄利克雷先验，\n$$\np \\sim \\text{Dirichlet}(\\alpha_1, \\dots, \\alpha_K),\n$$\n其中集中度参数 $\\alpha_j > 0$ 控制了组合上的先验质量。稀有细胞类型较小的 $\\alpha_j$ 值表示我们先验地认为 $p_j$ 通常很小。\n\n假设我们观测到计数 $x = (x_1, \\dots, x_K)$，总数为 $N = \\sum_{j=1}^K x_j$，它由以 $p$ 为条件的多项式分布生成：\n$$\nx \\mid p \\sim \\text{Multinomial}(N, p).\n$$\n在多项式分布下，似然函数在忽略多项式系数常数的情况下为：\n$$\nL(p; x) \\propto \\prod_{j=1}^K p_j^{x_j}.\n$$\n狄利克雷先验的密度函数为\n$$\n\\pi(p; \\alpha) = \\frac{1}{B(\\alpha)} \\prod_{j=1}^K p_j^{\\alpha_j - 1},\n$$\n其中 $B(\\alpha)$ 是多元贝塔函数 $B(\\alpha) = \\frac{\\prod_{j=1}^K \\Gamma(\\alpha_j)}{\\Gamma(\\alpha_0)}$，且 $\\alpha_0 = \\sum_{j=1}^K \\alpha_j$。\n\n根据贝叶斯定理 (Bayes' theorem)，后验分布与似然和先验的乘积成正比：\n$$\n\\pi(p \\mid x) \\propto L(p; x) \\cdot \\pi(p; \\alpha) \\propto \\prod_{j=1}^K p_j^{x_j} \\cdot \\prod_{j=1}^K p_j^{\\alpha_j - 1} = \\prod_{j=1}^K p_j^{(\\alpha_j + x_j) - 1}.\n$$\n通过识别狄利克雷核，我们得出结论，后验分布也是狄利克雷分布，其更新后的集中度参数为\n$$\n\\alpha'_j = \\alpha_j + x_j, \\quad \\text{for } j = 1, \\dots, K,\n$$\n总集中度为\n$$\n\\alpha'_0 = \\sum_{j=1}^K \\alpha'_j = \\sum_{j=1}^K \\alpha_j + \\sum_{j=1}^K x_j = \\alpha_0 + N.\n$$\n\n我们现在推导在狄利克雷分布下 $p_j$ 的后验均值和方差。对于 $p \\sim \\text{Dirichlet}(\\alpha')$，可以使用伽马函数 (Gamma function) 的性质以及狄利克雷分布可表示为归一化伽马随机变量的特性来推导其标准矩的结果。具体来说，令 $Y_j \\sim \\text{Gamma}(\\alpha'_j, 1)$ 相互独立，并定义 $S = \\sum_{k=1}^K Y_k$。那么 $p_j = Y_j / S$。使用这种表示法，可以得到\n$$\n\\mathbb{E}[p_j] = \\frac{\\alpha'_j}{\\alpha'_0},\n$$\n以及二阶矩\n$$\n\\mathbb{E}[p_j^2] = \\frac{\\alpha'_j(\\alpha'_j + 1)}{\\alpha'_0(\\alpha'_0 + 1)}.\n$$\n因此，方差为\n$$\n\\mathrm{Var}(p_j) = \\mathbb{E}[p_j^2] - (\\mathbb{E}[p_j])^2 = \\frac{\\alpha'_j(\\alpha'_0 - \\alpha'_j)}{\\alpha'^2_0(\\alpha'_0 + 1)}.\n$$\n这些表达式可以从已知的狄利克雷矩得到，或者通过使用狄利克雷密度和贝塔/伽马恒等式进行积分推导得出。\n\n为了在贝叶斯解卷积设置中编码关于稀有细胞类型的先验知识，我们考虑改变单个先验集中度参数 $\\alpha_j$，同时保持所有其他 $\\alpha_k$（$k \\ne j$）固定不变。给定观测计数 $x$，这一改变会产生一个后验分布，其更新后的参数为 $\\alpha'_j = \\alpha_j^{(\\text{new})} + x_j$ 和 $\\alpha'_0 = (\\alpha_0^{(\\text{new})}) + N$，其中 $\\alpha_0^{(\\text{new})}$ 反映了被修改的单个分量。$p_j$ 的后验均值和方差会通过上述公式对这一变化作出响应。\n\n为每个测试用例计算所需输出的算法步骤：\n1. 解析 $K$、先验集中度向量 $(\\alpha_1, \\dots, \\alpha_K)$、稀有细胞类型索引 $j$、$\\alpha_j$ 的替换值列表以及观测计数 $(x_1, \\dots, x_K)$。\n2. 对于列表中的每个替换值 $v$：\n   - 构造一个新的先验向量 $\\tilde{\\alpha}$，它与给定的先验向量相同，只是 $\\tilde{\\alpha}_j = v$。\n   - 计算后验参数 $\\alpha'_k = \\tilde{\\alpha}_k + x_k$（对所有 $k$）和 $\\alpha'_0 = \\sum_{k=1}^K \\alpha'_k$。\n   - 计算后验均值 $\\mu_j = \\alpha'_j / \\alpha'_0$ 和方差 $\\sigma_j^2 = \\alpha'_j(\\alpha'_0 - \\alpha'_j)/(\\alpha'^2_0(\\alpha'_0 + 1))$。\n   - 将 $\\mu_j$ 和 $\\sigma_j^2$ 追加到该测试用例的结果列表中。\n3. 将所有数值输出四舍五入到小数点后六位。\n4. 将所有测试用例的结果聚合到一个外部列表中，并按指定格式单行打印。\n\n此过程确定性地量化了在共轭狄利克雷-多项式模型下，改变稀有细胞类型的单个狄利克雷集中度参数如何影响其比例估计的后验均值和方差。该测试套件涵盖了一般情况、观测计数为零的边界条件、先验占主导地位的情况以及用于探测对先验设定敏感性的小样本场景。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef posterior_mean_variance(alpha_vec, counts_vec, j_index):\n    \"\"\"\n    Compute posterior mean and variance for p_j under a Dirichlet posterior\n    given prior alpha_vec and observed counts counts_vec, for index j_index.\n    \"\"\"\n    alpha_vec = np.asarray(alpha_vec, dtype=float)\n    counts_vec = np.asarray(counts_vec, dtype=float)\n    alpha_post = alpha_vec + counts_vec\n    alpha0_post = float(np.sum(alpha_post))\n    aj_post = float(alpha_post[j_index])\n    mean_j = aj_post / alpha0_post\n    var_j = aj_post * (alpha0_post - aj_post) / (alpha0_post**2 * (alpha0_post + 1.0))\n    return mean_j, var_j\n\ndef format_results_nested(nested_lists):\n    \"\"\"\n    Format nested list of floats into a single-line string with required structure,\n    rounding to six decimals.\n    \"\"\"\n    def fmt_float(x):\n        # Round to six decimal places\n        return f\"{x:.6f}\"\n    inner_strs = []\n    for inner in nested_lists:\n        inner_fmt = \",\".join(fmt_float(val) for val in inner)\n        inner_strs.append(f\"[{inner_fmt}]\")\n    return f\"[{','.join(inner_strs)}]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (K, prior_alpha, j_index, alpha_j_variants, counts)\n    test_cases = [\n        # Test Case 1\n        (5, [0.5, 2.0, 2.0, 1.0, 0.1], 4, [0.05, 0.1, 1.0], [60, 180, 140, 15, 5]),\n        # Test Case 2\n        (4, [1.5, 1.5, 1.5, 0.05], 3, [0.01, 0.05, 5.0], [120, 80, 50, 0]),\n        # Test Case 3\n        (3, [0.5, 0.5, 100.0], 2, [10.0, 100.0, 1000.0], [30, 20, 10]),\n        # Test Case 4\n        (6, [0.2, 0.2, 0.2, 0.2, 0.2, 0.2], 2, [0.01, 0.2, 2.0], [2, 1, 0, 0, 1, 0]),\n    ]\n\n    results = []\n    for K, prior_alpha, j_index, variants, counts in test_cases:\n        # Sanity checks\n        assert len(prior_alpha) == K\n        assert len(counts) == K\n        assert j_index >= 0 and j_index  K\n        inner_results = []\n        for v in variants:\n            # Replace only the single concentration parameter for the rare cell type.\n            alpha_new = list(prior_alpha)\n            # Ensure positivity of Dirichlet parameters\n            if v = 0:\n                raise ValueError(\"Dirichlet concentration parameters must be strictly positive.\")\n            alpha_new[j_index] = v\n            mean_j, var_j = posterior_mean_variance(alpha_new, counts, j_index)\n            inner_results.extend([mean_j, var_j])\n        results.append(inner_results)\n\n    # Final print statement in the exact required format.\n    print(format_results_nested(results))\n\nsolve()\n```"
        }
    ]
}