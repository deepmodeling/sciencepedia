{
    "hands_on_practices": [
        {
            "introduction": "在任何单细胞RNA测序分析流程中，首要且最关键的步骤是质量控制（QC）。本练习将指导您使用稳健的统计方法，识别并过滤掉可能影响下游分析结果的低质量细胞。您将学习如何基于中位数绝对偏差（MAD）建立离群点检测规则，这是一种不受极端值影响的强大技术，以确保我们分析的起点是高质量、可靠的数据集。",
            "id": "4382174",
            "problem": "给定单细胞核糖核酸测序 (scRNA-seq) 数据的三个质量控制指标：每个细胞的唯一分子标识符 (UMI) 计数、每个细胞检测到的基因数，以及每个细胞中映射到线粒体基因的读段比例（线粒体分数）。您的目标是设计一个基于稳健统计学的稳健异常值过滤规则，并将其应用于具体的、指定的测试数据集。从第一性原理出发，从中位数和中位数绝对偏差 (MAD) 的定义开始，在正态模型下（其中标准差通过一个固定的一致性常数与 MAD 相关），为 UMI 计数和检测到的基因数推导一个对称的异常值规则，并为线粒体分数推导一个单侧的异常值规则。选择一个异常值调整参数 $k$ 并证明其选择的合理性。通过使用具有科学合理性的下限来正则化尺度，以解决由离散计数或相同值引起的尺度估计中的退化问题。然后实施该过滤规则，以确定应移除哪些细胞。\n\n使用以下基本定义和事实：\n- 数据集的中位数是这样一个值 $m$：一半的观测值不大于 $m$，另一半不小于 $m$。\n- 中位数绝对偏差 (MAD) 定义为 $\\mathrm{MAD} = \\mathrm{median}(|x_i - m|)$，其中 $m$ 是数据集 $\\{x_i\\}$ 的中位数。\n- 对于正态分布，标准差 $\\sigma$ 通过一个已知常数 $c$ 与中位数绝对偏差相关：$\\sigma \\approx c \\cdot \\mathrm{MAD}$。\n- 线粒体分数是一个比例，要求表示为 $[0,1]$ 范围内的小数，而不是百分比。\n\n设计要求：\n1. 从 $\\mathrm{MAD}$ 推导出一个在正态模型下与标准差一致的稳健尺度估计量，并使用所选的 $k$ 值为 UMI 计数和检测到的基因数构建围绕中位数的对称阈值。使用相同的尺度概念和 $k$ 值为线粒体分数构建一个单侧上阈值。\n2. 当由于相同值或离散计数导致 $\\mathrm{MAD}$ 计算为 $0$ 时，正则化尺度以避免退化。对于计数类指标，使用一个按中位数缩放的分数下限。对于有界比例，如果存在，则使用观测到的与中位数的最小正偏差作为下限，否则使用一个遵循 $[0,1]$ 边界的微小正常数。\n3. 应用该规则确定应被过滤的细胞索引集合，如果一个细胞在三个指标中的任何一个上违反了阈值，则该细胞被过滤。\n\n解释和预期下游影响：逻辑上解释过滤此类异常值如何影响 scRNA-seq 流水线中的下游聚类，包括双细胞去除和排除以高线粒体分数为特征的受压或濒死细胞，以及过于严格的阈值可能如何改变簇边界。\n\n调整参数：\n- 使用 $k = 3$。\n\n测试套件和输入：\n您必须实现并运行一个包含以下三个测试用例的程序。每个测试用例为三个指标指定了等长的数组：UMI 计数、检测到的基因数和线粒体分数。细胞索引是基于 $0$ 的。所有数字都必须视为无单位的标量；线粒体分数必须视为小数，而不是百分比。\n\n测试用例 1（数据集的中位数接近 $5{,}000$ 个 UMI、$1{,}600$ 个基因，线粒体分数集中在 $0.08$）：\n- UMI: $[5200,4800,5100,4950,5050,5300,4700,5000,5150,4850,5080,4920,4995,5010,4975,16000,600,5400,4600,5005]$\n- 基因: $[1650,1580,1620,1590,1610,1700,1550,1600,1630,1570,1615,1595,1605,1608,1592,3500,400,1680,1520,1602]$\n- 线粒体分数: $[0.07,0.09,0.08,0.085,0.075,0.06,0.1,0.08,0.07,0.09,0.082,0.078,0.08,0.081,0.079,0.04,0.25,0.065,0.11,0.08]$\n\n测试用例 2（在指定中位数附近存在退化的相同值，以及少量偏差）：\n- UMI: $[5000,5000,5000,5000,5000,5000,5000,5000,5000,2000,8000,5000]$\n- 基因: $[1600,1600,1600,1600,1600,1600,1600,1600,1600,900,2800,1600]$\n- 线粒体分数: $[0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.08,0.2,0.06,0.08]$\n\n测试用例 3（在指定中心附近的重尾混合分布）：\n- UMI: $[5100,4950,5300,4700,5500,4800,6200,3000,5800,4900,5050,5150,4000,7000,5200]$\n- 基因: $[1620,1580,1700,1500,1750,1550,1800,1100,1720,1590,1610,1630,1200,1900,1600]$\n- 线粒体分数: $[0.09,0.07,0.06,0.12,0.05,0.08,0.04,0.18,0.06,0.09,0.08,0.07,0.16,0.03,0.085]$\n\n输出规范：\n- 对于每个测试用例，输出按升序排序的被过滤细胞索引列表（作为整数）。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素本身是对应测试用例的整数列表，例如：$[[i\\_1,i\\_2],[],[j\\_1]]$。",
            "solution": "任务是为单细胞 RNA 测序 (scRNA-seq) 的质量控制 (QC) 指标设计并实现一种稳健的异常值过滤方法。该过滤方法必须基于稳健的统计学原理，特别是使用中位数和中位数绝对偏差 (MAD)，并且必须对尺度估计退化为零的情况具有稳健性。我们将从第一性原理推导过滤规则，证明所有参数选择的合理性，并将其应用于所提供的测试用例。\n\n首先，我们为我们的方法建立统计基础。在 scRNA-seq 分析中，异常细胞会严重扭曲下游分析，如归一化、降维和聚类。常见的异常细胞类型包括空液滴（UMI/基因计数极低）、细胞双体或多体（UMI/基因计数被人为地抬高）以及受压或濒死的细胞（线粒体基因表达比例高）。基于均值和标准差的经典异常值检测方法本身对异常值的存在很敏感。因此，需要使用稳健的统计方法。\n\n中位数是衡量集中趋势的稳健指标。对于一个数据集 $\\{x_1, x_2, \\dots, x_n\\}$，中位数 $m$ 是将数据较高的一半与较低的一半分开的值。对于偶数个数据点，它是两个中心值的平均值。\n\n中位数绝对偏差 (MAD) 是衡量统计离散度的稳健指标。它被定义为与数据中位数的绝对偏差的中位数：\n$$\n\\mathrm{MAD} = \\mathrm{median}(|x_i - m|)\n$$\n其中 $m = \\mathrm{median}(\\{x_i\\})$。\n\n为了在类似于流行的“三西格玛”法则的框架中使用 MAD，我们必须建立它与标准差 $\\sigma$ 的关系。对于一个服从正态分布 $\\mathcal{N}(\\mu, \\sigma^2)$ 的连续随机变量 $X$，其中位数是 $\\mu$。变量 $Y = |X - \\mu|$ 服从折叠正态分布。$Y$ 的中位数是满足 $P(Y \\le y_m) = 1/2$ 的值 $y_m$。这等价于 $P(|X - \\mu| \\le y_m) = 1/2$，或 $P(-y_m \\le X - \\mu \\le y_m) = 1/2$。标准化后，我们得到 $P(-y_m/\\sigma \\le Z \\le y_m/\\sigma) = 1/2$，其中 $Z \\sim \\mathcal{N}(0, 1)$。这意味着 $P(Z \\le y_m/\\sigma) - P(Z \\le -y_m/\\sigma) = 1/2$。根据正态分布的对称性，这可以简化为 $2 \\cdot P(Z \\le y_m/\\sigma) - 1 = 1/2$，从而得出 $P(Z \\le y_m/\\sigma) = 3/4$。\n因此，$y_m/\\sigma = \\Phi^{-1}(0.75)$，其中 $\\Phi^{-1}$ 是标准正态分布的分位数函数（或概率单位函数）。该值为 $\\Phi^{-1}(0.75) \\approx 0.6745$。\nMAD 是 $y_m$ 的估计量，所以我们有 $\\mathrm{MAD} \\approx \\sigma \\cdot \\Phi^{-1}(0.75)$。\n由此，我们通过缩放 MAD 推导出一个稳健的标准差估计量 $\\hat{\\sigma}_{\\mathrm{rob}}$：\n$$\n\\hat{\\sigma}_{\\mathrm{rob}} = c \\cdot \\mathrm{MAD} = \\frac{1}{\\Phi^{-1}(0.75)} \\cdot \\mathrm{MAD} \\approx 1.4826 \\cdot \\mathrm{MAD}\n$$\n这个经过缩放的 MAD，即 $\\hat{\\sigma}_{\\mathrm{rob}}$，提供了一个标准差的估计，它在正态模型下与 $\\sigma$ 一致，但对极端异常值保持稳健。\n\n现在我们构建异常值检测规则。异常值通常被定义为距离中心点几个标准差之外的数据点。使用我们的稳健估计量，如果一个值 $x_i$ 满足 $|x_i - m| > k \\cdot \\hat{\\sigma}_{\\mathrm{rob}}$，则将其标记。问题指定了一个调整参数 $k=3$。这个选择是“三西格玛”法则的稳健类似物，它将位于正态分布中心 $99.7\\%$ 之外的值识别为异常值。它为异常值检测提供了一个严格但标准的阈值。\n\n对于 UMI 计数和检测到的基因数，异常低和异常高的值都表示质量不佳。低值表明是空液滴或单细胞捕获失败，而高值则表明存在双细胞或多细胞体。因此，我们使用对称的过滤规则。如果一个细胞的指标值 $x_i$ 落在区间之外，则被过滤：\n$$\n[m - k \\cdot \\hat{\\sigma}_{\\mathrm{rob}}, m + k \\cdot \\hat{\\sigma}_{\\mathrm{rob}}] = [m - 3 \\cdot c \\cdot \\mathrm{MAD}, m + 3 \\cdot c \\cdot \\mathrm{MAD}]\n$$\n\n对于线粒体分数，高值表示细胞受压、损伤或凋亡，此时细胞质 mRNA 丢失，导致线粒体转录本的比例更高。低值不是质量问题。因此，我们采用单侧上阈值。如果一个细胞的线粒体分数 $x_i$ 超过以下值，则被过滤：\n$$\nm + k \\cdot \\hat{\\sigma}_{\\mathrm{rob}} = m + 3 \\cdot c \\cdot \\mathrm{MAD}\n$$\n\n当 $\\mathrm{MAD} = 0$ 时，会出现一个关键问题。如果超过一半的数据点相同，就会发生这种情况，这在离散计数数据或具有许多相同值的数据集中很常见。如果 $\\mathrm{MAD}=0$，则 $\\hat{\\sigma}_{\\mathrm{rob}}=0$，过滤区间会退化为 $[m, m]$，可能过滤掉所有非中位数的值。为了防止这种情况，我们必须对尺度估计进行正则化。\n1. 对于计数指标（UMI、基因），零尺度是没有信息的。我们为尺度估计量 $\\hat{\\sigma}_{\\mathrm{rob}}$ 引入一个与中位数成比例的下限。一个合理的选择是中位数的一个小分数，确保尺度具有上下文相关性。我们将使用中位数的 $5\\%$，这个值足够小，在非退化情况下不会占主导地位，但又足够大，可以定义一个合理的范围。正则化后的尺度是 $\\max(\\hat{\\sigma}_{\\mathrm{rob}}, 0.05 \\cdot m)$。这仅在 $\\hat{\\sigma}_{\\mathrm{rob}}$ 计算为 $0$ 时应用。\n2. 对于线粒体分数，它是一个在 $[0,1]$ 范围内的比例，我们遵循指定的规则。如果 $\\mathrm{MAD}=0$，则将尺度设置为与中位数的最小正偏差，即 $\\min(\\{|x_i-m| : |x_i-m|>0\\})$。如果所有值都相同且不存在正偏差，我们使用一个微小正常数，考虑到指标的 $[0,1]$ 范围，$0.01$ 是一个合理的选择。\n\n一个细胞的最终过滤决定是基于三个指标的异常值集合的并集。如果一个细胞因其 UMI 计数、基因计数**或**线粒体分数而被标记为异常值，则该细胞被移除。\n\n这种过滤对下游分析的影响是深远的。通过移除低质量细胞、双细胞和受压细胞，我们确保后续的归一化和聚类是基于一组更同质的、有活力的单细胞。这可以防止由技术伪影（例如，“受压细胞”簇或“双细胞”簇）驱动的虚假簇的形成，并有助于恢复真实的生物学变异。然而，过于严格的过滤（例如，一个很小的 $k$）可能会移除稀有的细胞群体或处于有效生物学分布尾部的细胞，这可能导致组织细胞组成的有偏表示和簇边界的改变。使用基于 MAD 的稳健阈值和 $k=3$ 是一种标准做法，它在数据清洁的需求与保护生物异质性之间取得了平衡。\n\n我们现在着手实施该方法并将其应用于指定的测试用例。对于所有计算，将使用常数 $c = 1/\\Phi^{-1}(0.75)$，其中 $\\Phi^{-1}(0.75)$ 由高精度数值库提供。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the scRNA-seq QC filtering problem for the given test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"umi\": np.array([5200, 4800, 5100, 4950, 5050, 5300, 4700, 5000, 5150, 4850, 5080, 4920, 4995, 5010, 4975, 16000, 600, 5400, 4600, 5005]),\n            \"genes\": np.array([1650, 1580, 1620, 1590, 1610, 1700, 1550, 1600, 1630, 1570, 1615, 1595, 1605, 1608, 1592, 3500, 400, 1680, 1520, 1602]),\n            \"mito\": np.array([0.07, 0.09, 0.08, 0.085, 0.075, 0.06, 0.1, 0.08, 0.07, 0.09, 0.082, 0.078, 0.08, 0.081, 0.079, 0.04, 0.25, 0.065, 0.11, 0.08])\n        },\n        {\n            \"umi\": np.array([5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000, 2000, 8000, 5000]),\n            \"genes\": np.array([1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 1600, 900, 2800, 1600]),\n            \"mito\": np.array([0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.08, 0.2, 0.06, 0.08])\n        },\n        {\n            \"umi\": np.array([5100, 4950, 5300, 4700, 5500, 4800, 6200, 3000, 5800, 4900, 5050, 5150, 4000, 7000, 5200]),\n            \"genes\": np.array([1620, 1580, 1700, 1500, 1750, 1550, 1800, 1100, 1720, 1590, 1610, 1630, 1200, 1900, 1600]),\n            \"mito\": np.array([0.09, 0.07, 0.06, 0.12, 0.05, 0.08, 0.04, 0.18, 0.06, 0.09, 0.08, 0.07, 0.16, 0.03, 0.085])\n        }\n    ]\n\n    results = []\n    \n    # Tuning parameters and constants\n    k = 3\n    # Consistency constant c = 1 / Φ⁻¹(0.75)\n    c = 1 / norm.ppf(0.75)\n\n    def find_outliers(data, is_symmetric, is_proportion, k_val, c_val):\n        \"\"\"\n        Identifies outliers based on the median and MAD.\n        \n        Args:\n            data (np.array): The input data vector.\n            is_symmetric (bool): True for two-sided filtering, False for one-sided (upper).\n            is_proportion (bool): True if the data is a proportion [0,1], for degeneracy handling.\n            k_val (float): The number of scaled MADs to use for the threshold.\n            c_val (float): The consistency constant for scaling MAD.\n\n        Returns:\n            set: A set of indices corresponding to outlier cells.\n        \"\"\"\n        median = np.median(data)\n        deviations = np.abs(data - median)\n        mad = np.median(deviations)\n        \n        scaled_mad = c_val * mad\n        \n        # Handle degeneracy (MAD = 0)\n        if scaled_mad == 0:\n            if is_proportion:\n                positive_devs = deviations[deviations > 0]\n                if len(positive_devs) > 0:\n                    # Regularize scale with the minimum positive deviation\n                    scaled_mad = np.min(positive_devs)\n                else:\n                    # All values are identical, use a small constant floor\n                    scaled_mad = 0.01 \n            else: # Count data\n                # Regularize scale with a fraction of the median, if median is non-zero\n                if median > 0:\n                    scaled_mad = max(scaled_mad, 0.05 * median)\n                # If median is also 0, a minimal absolute scale might be needed, but\n                # this case is unlikely for UMI/gene counts in a real pre-filtered dataset.\n                # Here, a scale of 0 would lead to no non-zero values being accepted.\n\n        # Define thresholds\n        upper_bound = median + k_val * scaled_mad\n        \n        if is_symmetric:\n            lower_bound = median - k_val * scaled_mad\n            outlier_indices = np.where((data  lower_bound) | (data > upper_bound))[0]\n        else: # One-sided upper threshold\n            outlier_indices = np.where(data > upper_bound)[0]\n            \n        return set(outlier_indices.tolist())\n\n    for case in test_cases:\n        umi_data = case[\"umi\"]\n        genes_data = case[\"genes\"]\n        mito_data = case[\"mito\"]\n        \n        umi_outliers = find_outliers(umi_data, is_symmetric=True, is_proportion=False, k_val=k, c_val=c)\n        genes_outliers = find_outliers(genes_data, is_symmetric=True, is_proportion=False, k_val=k, c_val=c)\n        mito_outliers = find_outliers(mito_data, is_symmetric=False, is_proportion=True, k_val=k, c_val=c)\n        \n        # A cell is filtered if it violates any of the three metric thresholds\n        total_outliers = sorted(list(umi_outliers | genes_outliers | mito_outliers))\n        results.append(total_outliers)\n\n    # Format the final output string exactly as specified\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "在对高质量的细胞数据进行降维处理时，一个核心挑战是如何确定数据中包含多少真实的生物学信号。本练习将引导您应用主成分分析（PCA）来捕捉基因表达中的主要变化模式，并利用基于置换检验的统计学方法，严格区分有意义的主成分与随机噪声。掌握这项技能对于后续准确的细胞聚类和生物学解释至关重要。",
            "id": "4382117",
            "problem": "您的任务是设计一个可复现的、自包含的计算流程，使用主成分分析（PCA）从标准化的单细胞核糖核酸测序（scRNA-seq）表达矩阵中提取结构，使用基于置换的零模型来决定要保留的主成分数量，并根据预定义的生物学程序来解释主成分载荷。此任务属于精准医疗和基因组诊断流程的一部分，必须仅使用数学和算法原语进行形式化。\n\n该问题的基础是：分子生物学的中心法则（脱氧核糖核酸到核糖核酸到蛋白质），方差和协方差的统计定义，以及通过协方差矩阵的特征分解找到最大方差正交方向的、经过充分检验的PCA程序。这些原则在单细胞数据集的基因表达解释和降维中被广泛接受和依赖。定义：主成分分析（PCA）被构建为一种对角化协方差矩阵的正交变换；其成分得分和载荷分别反映了细胞水平的投影和基因水平的贡献。此问题中的所有变量均被视为实值。\n\n您的程序必须在每个测试案例中遵循以下步骤：\n\n1. 数据模型和预处理：\n   - 设标准化表达矩阵为 $X \\in \\mathbb{R}^{n \\times g}$，其中 $n$ 是细胞数，$g$ 是基因数。列索引基因，行索引细胞。输入数据被模拟为与scRNA-seq流程一致的对数标准化表达。\n   - 执行按列标准化：对于每个基因 $j \\in \\{1,\\dots,g\\}$，计算样本均值 $\\mu_j = \\frac{1}{n}\\sum_{i=1}^n X_{ij}$，和样本标准差 $\\sigma_j = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (X_{ij}-\\mu_j)^2}$。通过 $Z_{ij} = \\frac{X_{ij}-\\mu_j}{\\sigma_j}$（对所有 $i,j$）定义标准化矩阵 $Z$。如果任何 $\\sigma_j = 0$，则将其替换为 $1$，以避免除以零，同时保留该列。\n   - 理由：标准化均衡了基因特异性的尺度，这些尺度在scRNA-seq中因基因长度、捕获效率和生物学动态范围而异，确保PCA捕获的是协变结构而非绝对尺度。\n\n2. 主成分分析：\n   - 计算 $Z$ 的奇异值分解：$Z = U \\Sigma V^\\top$，其中 $U \\in \\mathbb{R}^{n \\times r}$，$ \\Sigma \\in \\mathbb{R}^{r \\times r}$ 是对角矩阵，其非负奇异值为 $\\{s_1,\\dots,s_r\\}$，$V \\in \\mathbb{R}^{g \\times r}$ 具有正交标准列，且 $r = \\min(n,g)$。\n   - 样本协方差矩阵 $C = \\frac{1}{n-1}Z^\\top Z$ 的特征值为 $\\lambda_i = \\frac{s_i^2}{n-1}$（对于 $i \\in \\{1,\\dots,r\\}$），这些特征值量化了每个主成分解释的方差。\n   - 定义细胞得分为 $S = U \\Sigma \\in \\mathbb{R}^{n \\times r}$，基因载荷为 $L = V \\in \\mathbb{R}^{g \\times r}$，其中 $L_{\\cdot,i}$ 是主成分 $i$ 的载荷向量。\n\n3. 基于置换的零分布和成分保留：\n   - 通过独立地置换每个基因列中跨细胞的条目来构建一个零模型，以打破细胞间的相关性，同时保留每个基因的边际分布。对于每个置换 $b \\in \\{1,\\dots,K\\}$，设 $X^{(b)}$ 为置换后的矩阵，使用与上述相同的定义将其标准化为 $Z^{(b)}$，计算其奇异值 $\\{s_i^{(b)}\\}$，并计算零特征值 $\\lambda_i^{(b)} = \\frac{(s_i^{(b)})^2}{n-1}$（对所有 $i \\in \\{1,\\dots,r\\}$）。\n   - 对于给定的分位数水平 $q \\in (0,1)$（以小数表示），将第 $i$ 个成分的零阈值定义为 $T_i(q) = \\operatorname{Quantile}_q\\left(\\{\\lambda_i^{(b)}\\}_{b=1}^K\\right)$。\n   - 从 $i=1$ 开始按顺序保留成分，只要 $\\lambda_i > T_i(q)$；在第一个不满足此不等式的 $i$ 处停止。设保留的成分数量为 $R$（一个整数）。\n\n4. 通过生物学程序进行解释：\n   - 给定 $P$ 个生物学程序，表示为不相交的基因索引集 $S_1, S_2, \\dots, S_P \\subset \\{1,\\dots,g\\}$。对于每个保留的主成分 $i \\in \\{1,\\dots,R\\}$，计算程序贡献分数 $s_{i,p} = \\sum_{j \\in S_p} L_{j,i}^2$（对所有 $p \\in \\{1,\\dots,P\\}$）。将使 $s_{i,p}$ 最大化的 $p$ 确定为成分 $i$ 的顶级程序。若出现平局，必须选择最小的 $p$ 来解决。\n   - 报告程序标识符为整数 $(0,1,\\dots,P-1)$，对应于 $(S_1,S_2,\\dots,S_P)$。\n\n测试套件规范：\n- 使用由带种子的正态分布完全指定的随机生成，以确保确定性输出。每个测试案例的潜变量生成模型模拟了每个细胞的潜变量因子，这些因子线性映射到基因子集，并加上独立的高斯噪声，从而生成与对数标准化的scRNA-seq结构一致的矩阵 $X$。所有随机数均使用按指定种子初始化的现代伪随机数生成器生成。\n\n- 全局超参数：\n  - 置换次数 $K = \\;200$（整数）。\n  - 分位数水平 $q = \\;0.95$（小数）。\n\n- 测试案例 1（理想路径；多个结构化程序）：\n  - 维度：$n = \\;120$, $g = \\;30$。\n  - 种子：$s = \\;314159$。\n  - 程序集 ($P = \\;3$)：\n    - $S_1 = \\;\\{0,1,2,3,4,5,6,7,8,9\\}$,\n    - $S_2 = \\;\\{10,11,12,13,14,15,16,17,18,19\\}$,\n    - $S_3 = \\;\\{20,21,22,23,24\\}$。\n  - 仅含噪声的基因：$\\{25,26,27,28,29\\}$。\n  - 每个细胞 $i$ 的潜变量因子生成：\n    - 独立抽取 $z_{0,i} \\sim \\mathcal{N}(0,1)$，$z_{1,i} \\sim \\mathcal{N}(0,1)$，$z_{2,i} \\sim \\mathcal{N}(0,1)$。\n  - 数据生成：\n    - 对于 $j \\in S_1$：$X_{ij} = \\;2.0 \\cdot z_{0,i} + \\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,0.3^2)$。\n    - 对于 $j \\in S_2$：$X_{ij} = \\;1.8 \\cdot z_{1,i} + \\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,0.3^2)$。\n    - 对于 $j \\in S_3$：$X_{ij} = \\;1.2 \\cdot z_{2,i} + \\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,0.3^2)$。\n    - 对于噪声基因：$X_{ij} = \\;\\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,1.0^2)$。\n\n- 测试案例 2（边缘案例；接近零结构）：\n  - 维度：$n = \\;120$, $g = \\;30$。\n  - 种子：$s = \\;271828$。\n  - 程序集 ($P = \\;3$) 与测试案例1相同：\n    - $S_1 = \\;\\{0,1,2,3,4,5,6,7,8,9\\}$,\n    - $S_2 = \\;\\{10,11,12,13,14,15,16,17,18,19\\}$,\n    - $S_3 = \\;\\{20,21,22,23,24\\}$。\n  - 所有基因都是噪声：\n    - 对于所有 $j \\in \\{0,1,\\dots,29\\}$ 和细胞 $i$：$X_{ij} = \\;\\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,1.0^2)$。\n\n- 测试案例 3（边界案例；单个主导程序）：\n  - 维度：$n = \\;120$, $g = \\;30$。\n  - 种子：$s = \\;161803$。\n  - 程序集 ($P = \\;3$)：\n    - $S_1 = \\;\\{0,1,2,3,4,5,6,7\\}$,\n    - $S_2 = \\;\\{10,11,12,13,14,15,16\\}$,\n    - $S_3 = \\;\\{20,21,22,23,24\\}$。\n  - 仅含噪声的基因：所有不在 $S_1 \\cup S_2 \\cup S_3$ 中的其他索引。\n  - 每个细胞 $i$ 的潜变量因子生成：\n    - 独立抽取 $z_{0,i} \\sim \\mathcal{N}(0,1)$。\n  - 数据生成：\n    - 对于 $j \\in S_1$：$X_{ij} = \\;2.5 \\cdot z_{0,i} + \\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,0.2^2)$。\n    - 对于所有其他基因：$X_{ij} = \\;\\epsilon_{ij}$，其中 $\\epsilon_{ij} \\sim \\mathcal{N}(0,1.0^2)$。\n\n程序输出规范：\n- 对于每个测试案例，计算保留的主成分数量 $R$（整数），以及按顺序为保留的成分计算出的顶级程序标识符列表（整数列表）。如果 $R = 0$，则程序列表为空。\n- 您的程序应生成单行输出，其中包含三个测试案例的结果，格式为包含在方括号中的逗号分隔列表，无空格。每个测试案例的结果必须格式化为 $[R,[p_1,p_2,\\dots,p_R]]$。例如，最终输出应类似于 $[[2,[0,1]],[0,[]],[1,[0]]]$，尽管实际数字将由计算确定。",
            "solution": "问题陈述已经过仔细验证。所有给定条件，包括数学定义、程序步骤和数值参数，都已提取和评估。\n\n**结论：** 问题是 **有效的**。\n\n该问题具有科学依据，采用了计算生物学和统计学中标准且成熟的技术，如主成分分析（PCA）、用于显著性估计的置换检验以及用于解释的基因集富集分析。该问题是良构的，所有参数、数据生成模型和算法步骤都定义得明确无误，确保在给定指定随机种子的情况下，每个测试案例都有唯一、确定性的解。语言客观、精确。它没有任何在验证清单中列出的缺陷，如科学上不健全、不完整或模糊不清。\n\n因此，下面提供了完整的解决方案。\n\n### 方法论框架\n\n指定的过程构成了一个严格的流程，用于识别和解释单细胞基因表达矩阵内变异的显著轴。这是通过四个连续的、有原则的步骤实现的：数据标准化、通过PCA进行降维、对成分进行统计显著性评估，以及对那些被认为显著的成分进行生物学解释。\n\n#### 步骤1：数据模型与标准化\n\n输入是一个标准化的基因表达矩阵 $X \\in \\mathbb{R}^{n \\times g}$，其中 $n$ 代表细胞数量，$g$ 代表基因数量。条目 $X_{ij}$ 量化了基因 $j$ 在细胞 $i$ 中的表达。为确保后续分析捕获的是基因表达的相关性结构，而不是受不同基因间表达值宽动态范围的偏倚影响，每个基因的表达向量（$X$ 中的一列）都进行标准化。\n\n对于每个基因 $j \\in \\{1,\\dots,g\\}$，我们计算其在所有 $n$ 个细胞中的样本均值 $\\mu_j$ 和样本标准差 $\\sigma_j$：\n$$\n\\mu_j = \\frac{1}{n}\\sum_{i=1}^n X_{ij}\n$$\n$$\n\\sigma_j = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (X_{ij}-\\mu_j)^2}\n$$\n在 $\\sigma_j$ 的分母中使用 $n-1$ 对应于贝塞尔校正，用于对总体方差进行无偏估计。然后构建一个标准化矩阵 $Z$，其中每个元素 $Z_{ij}$ 由下式给出：\n$$\nZ_{ij} = \\frac{X_{ij}-\\mu_j}{\\sigma_j}\n$$\n这种变换，也称为计算Z-分数，将每个基因的表达谱重新缩放，使其均值为0，标准差为1。如果出现基因方差为零的罕见情况（即 $\\sigma_j = 0$），其标准差将设置为1，以防止除以零。由于减去均值后的值将为零，这将使该列全为零。\n\n#### 步骤2：主成分分析\n\nPCA应用于标准化矩阵 $Z$，以找到高维基因空间中方差最大的正交方向。执行PCA的计算上最稳定的方法是通过 $Z$ 的奇异值分解（SVD）：\n$$\nZ = U \\Sigma V^\\top\n$$\n在这里，$U \\in \\mathbb{R}^{n \\times r}$ 是一个具有正交标准列的矩阵，代表细胞层面的投影；$\\Sigma \\in \\mathbb{R}^{r \\times r}$ 是一个非负奇异值 $s_1 \\ge s_2 \\ge \\dots \\ge s_r \\ge 0$ 的对角矩阵；$V \\in \\mathbb{R}^{g \\times r}$ 是一个具有正交标准列的矩阵，代表基因空间中的主轴。秩 $r$ 是 $n$ 和 $g$ 的最小值。\n\nPCA的关键输出派生自SVD的各组成部分：\n- **基因载荷（$L$）：** 矩阵 $L = V$ 包含每个主成分的载荷向量。$L$ 的第 $i$ 列，表示为 $L_{\\cdot,i}$，是第 $i$ 个主轴，并指示每个基因对该成分的贡献。\n- **细胞得分（$S$）：** 矩阵 $S = U \\Sigma$ 包含每个细胞在新的主成分空间中的坐标。第 $i$ 列给出了所有细胞在第 $i$ 个主成分上的投影。\n- **解释方差：** 第 $i$ 个主成分捕获的方差是其在样本协方差矩阵 $C = \\frac{1}{n-1}Z^\\top Z$ 中对应的特征值 $\\lambda_i$。这些特征值通过以下公式与 $Z$ 的SVD奇异值直接相关：\n    $$\n    \\lambda_i = \\frac{s_i^2}{n-1}\n    $$\n\n#### 步骤3：基于置换的成分保留\n\n虽然PCA总能找到成分，但并非所有成分都必然代表真实的生物学信号；许多可能仅仅捕获了随机噪声。为了区分显著成分和虚假成分，我们为特征值构建一个零分布。零假设是细胞间基因之间不存在系统的相关性结构。\n\n这是通过置换检验实现的。我们生成 $K = 200$ 个零数据集。对于每个零数据集 $b \\in \\{1, \\dots, K\\}$，我们通过独立地对每个基因（列）的表达值在细胞间进行混洗，创建一个置换矩阵 $X^{(b)}$。这个过程破坏了真实的细胞级基因-基因相关性，同时保留了每个基因表达的边际分布。\n\n对于每个置换矩阵 $X^{(b)}$，我们重复标准化和PCA过程，以获得一组零特征值 $\\{\\lambda_i^{(b)}\\}_{i=1}^r$。经过 $K$ 次置换后，我们为每个特征值 $\\lambda_i$ 得到了一个经验零分布。然后，将每个成分的显著性阈值 $T_i(q)$ 定义为其相应零分布的上 $q$ 分位数，其中 $q=0.95$：\n$$\nT_i(q) = \\operatorname{Quantile}_q\\left(\\{\\lambda_i^{(b)}\\}_{b=1}^K\\right)\n$$\n如果一个主成分 $i$ 的观测特征值 $\\lambda_i$ 超过了这个零阈值，即 $\\lambda_i > T_i(q)$，则该成分被认为是显著的。成分按其方差贡献的降序（从 $i=1$ 到 $r$）进行评估，我们保留所有成分，直到遇到第一个未通过此测试的成分。保留的成分总数表示为 $R$。\n\n#### 步骤4：通过生物学程序进行解释\n\n最后一步是为 $R$ 个显著主成分赋予生物学意义。这是通过检查它们的基因载荷向量来完成的。一个大的绝对载荷值 $|L_{j,i}|$ 意味着基因 $j$ 与成分 $i$ 强相关。\n\n我们被提供了 $P$ 个预定义的生物学程序，每个程序由一组基因索引 $S_p$ 表示。为了量化一个成分 $i$ 在多大程度上代表了程序 $p$，我们计算一个程序贡献分数 $s_{i,p}$。这个分数是属于该程序的所有基因的载荷平方和：\n$$\ns_{i,p} = \\sum_{j \\in S_p} L_{j,i}^2\n$$\n对载荷进行平方确保了贡献是通过关联的强度来衡量的，而不管基因与成分得分是正相关还是负相关。对于每个保留的成分 $i \\in \\{1,\\dots,R\\}$，我们确定使该分数最大化的程序 $p$，$p^* = \\arg\\max_{p} s_{i,p}$。这个程序被指定为该成分的主导生物学主题。如果出现平局，则选择索引 $p$ 最小的程序。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to execute all test cases and print the final result.\n    \"\"\"\n\n    # Global hyperparameters specified in the problem\n    K = 200  # Number of permutations\n    Q = 0.95  # Quantile level\n\n    # Test Case 1 Specifications\n    case1 = {\n        'n': 120, 'g': 30, 'seed': 314159,\n        'programs': [\n            set(range(0, 10)),\n            set(range(10, 20)),\n            set(range(20, 25))\n        ],\n        'gen_rules': {\n            'latent_factors': 3,\n            'noise_std_global': 1.0,\n            'program_rules': [\n                {'indices': set(range(0, 10)), 'factor_idx': 0, 'weight': 2.0, 'noise_std': 0.3},\n                {'indices': set(range(10, 20)), 'factor_idx': 1, 'weight': 1.8, 'noise_std': 0.3},\n                {'indices': set(range(20, 25)), 'factor_idx': 2, 'weight': 1.2, 'noise_std': 0.3},\n            ]\n        }\n    }\n\n    # Test Case 2 Specifications\n    case2 = {\n        'n': 120, 'g': 30, 'seed': 271828,\n        'programs': [\n            set(range(0, 10)),\n            set(range(10, 20)),\n            set(range(20, 25))\n        ],\n        'gen_rules': {\n            'latent_factors': 0,\n            'noise_std_global': 1.0,\n            'program_rules': []\n        }\n    }\n\n    # Test Case 3 Specifications\n    case3 = {\n        'n': 120, 'g': 30, 'seed': 161803,\n        'programs': [\n            set(range(0, 8)),\n            set(range(10, 17)),\n            set(range(20, 25))\n        ],\n        'gen_rules': {\n            'latent_factors': 1,\n            'noise_std_global': 1.0,\n            'program_rules': [\n                {'indices': set(range(0, 8)), 'factor_idx': 0, 'weight': 2.5, 'noise_std': 0.2},\n            ]\n        }\n    }\n    \n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        X = generate_data(case['n'], case['g'], case['seed'], case['gen_rules'])\n        R, top_programs = perform_pca_pipeline(X, K, Q, case['programs'])\n        results.append(f\"[{R},[{','.join(map(str, top_programs))}]]\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef generate_data(n, g, seed, gen_rules):\n    \"\"\"\n    Generates the expression matrix X based on the specified generative model.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    \n    # Initialize with global noise\n    noise_std_global = gen_rules['noise_std_global']\n    X = rng.normal(loc=0, scale=noise_std_global, size=(n, g))\n\n    # Generate latent factors\n    num_latent = gen_rules['latent_factors']\n    if num_latent > 0:\n        latent_factors = rng.normal(loc=0, scale=1, size=(n, num_latent))\n\n    # Add program-specific signals\n    for rule in gen_rules['program_rules']:\n        indices = list(rule['indices'])\n        factor = latent_factors[:, rule['factor_idx']]\n        weight = rule['weight']\n        noise_std = rule['noise_std']\n        \n        # Override global noise with specific noise for these genes\n        noise = rng.normal(loc=0, scale=noise_std, size=(n, len(indices)))\n        \n        signal = np.outer(factor, np.ones(len(indices))) * weight\n        X[:, indices] = signal + noise\n        \n    return X\n\n\ndef perform_pca_pipeline(X, K, q, programs):\n    \"\"\"\n    Executes the full analysis pipeline: standardization, PCA, permutation test, and interpretation.\n    \"\"\"\n    n, g = X.shape\n    r = min(n, g)\n\n    # Step 1: Standardization\n    def standardize(mat):\n        mean = mat.mean(axis=0)\n        std = mat.std(axis=0, ddof=1)\n        std[std == 0] = 1.0\n        return (mat - mean) / std\n\n    Z = standardize(X)\n    \n    # Step 2: PCA on real data\n    _, s, Vt = np.linalg.svd(Z, full_matrices=False)\n    lambdas = (s**2) / (n - 1)\n    L = Vt.T  # Gene loadings matrix V\n\n    # Step 3: Permutation test\n    null_lambdas = np.zeros((K, r))\n    rng = np.random.default_rng(sum(X.shape) + X.size) # A deterministic seed based on data\n\n    for b in range(K):\n        X_perm = np.zeros_like(X)\n        for j in range(g):\n            X_perm[:, j] = rng.permutation(X[:, j])\n        \n        Z_perm = standardize(X_perm)\n        _, s_perm, _ = np.linalg.svd(Z_perm, full_matrices=False)\n        null_lambdas[b, :] = (s_perm**2) / (n - 1)\n\n    # Component retention\n    thresholds = np.quantile(null_lambdas, q, axis=0)\n    R = 0\n    for i in range(r):\n        if lambdas[i] > thresholds[i]:\n            R += 1\n        else:\n            break\n            \n    # Step 4: Interpretation\n    if R == 0:\n        return 0, []\n\n    top_programs = []\n    for i in range(R):\n        loadings_i = L[:, i]\n        \n        program_scores = []\n        for p_set in programs:\n            p_indices = list(p_set)\n            score = np.sum(loadings_i[p_indices]**2)\n            program_scores.append(score)\n            \n        # argmax breaks ties by smallest index, as required.\n        top_p = np.argmax(program_scores)\n        top_programs.append(top_p)\n        \n    return R, top_programs\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "这个高级练习让您亲手实现RNA速度分析的核心概念，将静态的细胞快照转变为动态的发育轨迹图。您将学习如何从基本的动力学模型出发，估计基因的动力学参数，推断细胞的“速度”，并将其投影到低维空间中，从而预测细胞未来的分化方向。通过这项实践，您将能够揭示驱动细胞过程的潜在转录动态。",
            "id": "4382250",
            "problem": "您的任务是设计并实现一个完整的、可运行的程序，该程序构建一个简化的单细胞核糖核酸（RNA）速度分析流程，以支持精准医疗和基因组诊断。目标是从基本的转录和剪接生物化学动力学出发，根据按时间排序的细胞中已剪接和未剪接的计数来估计基因级动力学参数，推断表达空间中的瞬时速度，并将这些速度局部投影到二维统一流形逼近与投影（UMAP）嵌入上，以评估细胞转变的方向性。\n\n基础和定义：\n- 分子生物学的中心法则指出，脱氧核糖核酸（DNA）被转录为信使核糖核酸（mRNA），后者被翻译为蛋白质。对于含内含子的基因，前体mRNA（未剪接）经过剪接成为成熟mRNA（已剪接）。\n- 在单细胞水平上，对于每个基因，根据质量作用动力学，一个标准的线性动力学系统将未剪接和已剪接的计数建模为时间的函数。用 $u(t)$ 表示未剪接计数，用 $s(t)$ 表示已剪接计数。转录速率为 $\\alpha$，剪接速率为 $\\beta$，降解速率为 $\\gamma$，得到以下系统\n$$\n\\frac{\\mathrm{d}u}{\\mathrm{d}t} = \\alpha - \\beta\\,u,\\qquad\n\\frac{\\mathrm{d}s}{\\mathrm{d}t} = \\beta\\,u - \\gamma\\,s.\n$$\n所有参数 $\\alpha,\\beta,\\gamma$ 均为非负。该模型被广泛用于解释单细胞RNA测序的动力学动态，并且是RNA速度推断的基础。\n- 您可以假设，当时间采样足够密集时，从按时间排序的细胞中对 $\\mathrm{d}u/\\mathrm{d}t$ 和 $\\mathrm{d}s/\\mathrm{d}t$ 进行小的有限差分近似是合理的。\n- 非线性嵌入的局部线性化是一种经过充分检验的方法：在每个细胞周围，通过对邻居差异进行最小二乘拟合一个局部雅可比矩阵，将嵌入近似为一个从已剪接表达空间到 $\\mathbb{R}^2$ 的局部线性映射。\n\n程序要求：\n从这些原则出发，纯粹用数学和算法术语实现以下流程。\n\n1) 通过聚合提供的读数元组来计算已剪接和未剪接的计数矩阵：\n- 您将获得一个测试套件，其中每个测试用例指定：\n  - 一组 $N$ 个细胞（索引从 $0$ 到 $N-1$）。\n  - 一组 $G$ 个基因（索引从 $0$ 到 $G-1$）。\n  - 一个聚合读数元组列表，形式为 $(c, g, T, k)$，其中 $c$ 是细胞索引，$g$ 是基因索引，$T \\in \\{\\text{'S'},\\text{'U'}\\}$ 表示已剪接或未剪接，$k$ 是一个非负整数计数。根据这些元组，通过对每个 $(c,g)$ 的计数求和，构建两个矩阵 $U \\in \\mathbb{N}^{N \\times G}$ 和 $S \\in \\mathbb{N}^{N \\times G}$，分别包含未剪接和已剪接的计数。\n\n2) 使用从动力学模型推导出的普通最小二乘法估计基因级动力学参数：\n- 对于每个基因 $g$，以及每个时间为 $t_i$（小时）的细胞 $i$，使用时间序列 $\\{(t_i, u_i), (t_i, s_i)\\}$ 上的有限差分来近似导数 $\\left.\\frac{\\mathrm{d}u}{\\mathrm{d}t}\\right\\vert_{t_i}$ 和 $\\left.\\frac{\\mathrm{d}s}{\\mathrm{d}t}\\right\\vert_{t_i}$，其中 $u_i = U[i,g]$ 且 $s_i = S[i,g]$。对内部点使用中心差分，对端点使用单侧差分。时间必须以小时为单位明确处理。\n- 通过普通最小二乘法拟合线性关系 $\\frac{\\mathrm{d}u}{\\mathrm{d}t} = \\alpha - \\beta u$ 以估计 $\\alpha$ 和 $\\beta$。在适当情况下，通过截断为 $\\max(\\cdot,0)$ 来强制非负性。\n- 给定先前估计的 $\\beta$，通过普通最小二乘法拟合 $\\frac{\\mathrm{d}s}{\\mathrm{d}t} = \\beta u - \\gamma s$ 以估计 $\\gamma$，同样强制非负性。\n- 细胞 $i$ 中基因 $g$ 的瞬时已剪接速度则为\n$$\nv_{i,g} = \\beta_g\\,u_{i,g} - \\gamma_g\\,s_{i,g}.\n$$\n\n3) 将基因空间速度向量投影到二维嵌入上：\n- 对于每个测试用例，您会得到一个 $N \\times 2$ 的矩阵 $X$，表示细胞的UMAP坐标。\n- 对于每个细胞 $i$，使用欧几里得距离在已剪接表达空间中找到其 $k$ 个最近邻，其中 $k = \\min(3, N-1)$。\n- 对于 $i$ 的这些邻居 $j$，计算差异 $\\Delta S_{j} = S[j,\\cdot] - S[i,\\cdot]$ 和 $\\Delta X_{j} = X[j,\\cdot] - X[i,\\cdot]$。通过最小二乘法拟合一个局部线性映射 $B_i \\in \\mathbb{R}^{G \\times 2}$，以最小化弗罗贝尼乌斯范数\n$$\n\\lVert \\Delta S B_i - \\Delta X \\rVert_F^2。\n$$\n将基因速度向量 $v_i \\in \\mathbb{R}^{G}$ 投影到嵌入上，得到 $w_i = v_i^\\top B_i \\in \\mathbb{R}^2$。\n\n4) 评估转变的方向性：\n- 对于每个细胞 $i$，使用相同的有限差分方案（内部点用中心差分，端点用单侧差分）对 $X$ 相对于时间 $t$ 应用，计算嵌入上的局部时间梯度 $g_i = \\frac{\\mathrm{d}X}{\\mathrm{d}t}\\big\\vert_{t_i}$。\n- 计算余弦相似度\n$$\n\\cos\\theta_i = \\frac{w_i \\cdot g_i}{\\lVert w_i \\rVert_2\\,\\lVert g_i \\rVert_2},\n$$\n约定如果任一范数为零，则设 $\\cos\\theta_i = 0$。\n- 对于每个测试用例，报告平均余弦相似度 $\\overline{c} = \\frac{1}{N}\\sum_{i=1}^N \\cos\\theta_i$，作为一个浮点数。\n\n测试套件：\n实现您的程序，使其内部运行以下三个测试用例，所有数组和元组都严格按照下文规定。时间单位为小时。\n\n- 测试用例A：\n  - 细胞 $N = 6$，基因 $G = 3$。\n  - 时间 $t = [0, 1, 2, 3, 4, 5]$，单位为小时。\n  - 嵌入 $X$ 的行对应于细胞 $0\\dots 5$：\n    $$\n    X = \\begin{bmatrix}\n    0.0  0.0 \\\\\n    1.0  0.1 \\\\\n    2.0  0.0 \\\\\n    3.0  -0.1 \\\\\n    4.0  -0.1 \\\\\n    5.0  0.0\n    \\end{bmatrix}.\n    $$\n  - 聚合读数元组 $(c,g,T,k)$，其中 $T \\in \\{\\text{'U'},\\text{'S'}\\}$：\n    - 基因 $0$ 在细胞 $0\\dots 5$ 中的计数：未剪接计数 $[0, 2, 4, 6, 7, 8]$，已剪接计数 $[0, 1, 3, 6, 9, 12]$。\n    - 基因 $1$ 在细胞 $0\\dots 5$ 中的计数：未剪接计数 $[4, 4, 4, 4, 4, 4]$，已剪接计数 $[8, 8, 8, 8, 8, 8]$。\n    - 基因 $2$ 在细胞 $0\\dots 5$ 中的计数：未剪接计数 $[6, 5, 4, 3, 2, 1]$，已剪接计数 $[12, 10, 8, 6, 5, 4]$。\n\n- 测试用例B：\n  - 细胞 $N = 5$，基因 $G = 2$。\n  - 时间 $t = [0.0, 0.5, 1.5, 3.0, 5.0]$，单位为小时。\n  - 嵌入 $X$：\n    $$\n    X = \\begin{bmatrix}\n    0.0  0.0 \\\\\n    0.7  0.8 \\\\\n    1.8  1.9 \\\\\n    3.2  3.1 \\\\\n    5.0  5.1\n    \\end{bmatrix}.\n    $$\n  - 聚合读数元组：\n    - 基因 $0$：未剪接计数 $[0, 1, 2, 3, 3]$，已剪接计数 $[0, 1, 2, 3, 4]$。\n    - 基因 $1$：未剪接计数 $[3, 3, 3, 2, 2]$，已剪接计数 $[6, 6, 6, 5, 5]$。\n\n- 测试用例C：\n  - 细胞 $N = 6$，基因 $G = 2$。\n  - 时间 $t = [0, 1, 2, 3, 4, 5]$，单位为小时。\n  - 嵌入 $X$：\n    $$\n    X = \\begin{bmatrix}\n    5.0  0.0 \\\\\n    4.0  0.0 \\\\\n    3.0  0.0 \\\\\n    2.0  0.0 \\\\\n    1.0  0.0 \\\\\n    0.0  0.0\n    \\end{bmatrix}.\n    $$\n  - 聚合读数元组：\n    - 基因 $0$：未剪接计数 $[1, 2, 3, 4, 5, 6]$，已剪接计数 $[1, 2, 3, 5, 7, 9]$。\n    - 基因 $1$：未剪接计数 $[5, 4, 3, 2, 1, 1]$，已剪接计数 $[10, 8, 7, 6, 5, 5]$。\n\n实现说明：\n- 您的程序必须实现上述完整的流程，并将其应用于三个测试用例。\n- 在投影步骤中选择邻居时，请使用已剪接表达空间 $\\mathbb{R}^G$ 中的欧几里得距离，并为每个细胞选择 $k = \\min(3, N-1)$ 个邻居。\n- 通过使用最小二乘求解器来处理数值稳定性，并将任何分母为零的余弦相似度定义为零。\n- 不允许外部输入；所有数据必须作为取自上述测试套件的常量嵌入。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，依次为测试用例 A、B 和 C 的平均余弦相似度，每个值都精确到小数点后四位并用方括号括起来，例如 $[0.8123,0.7450,-0.1122]$。",
            "solution": "该问题要求实现一个简化的RNA速度分析流程。该流程从一个基本的基因表达动力学模型开始，从单细胞RNA测序的计数数据中估计模型参数，推断表达速度，并在一个低维细胞嵌入中根据已知的时间进程验证这些速度。因此，解决方案被构建为一个多步骤的计算工作流，遵循问题陈述中概述的原则。\n\n分析的基础是一个线性动力学系统，该系统为给定基因随时间 $t$ 建模未剪接前体mRNA $u(t)$ 和已剪接mRNA $s(t)$ 的丰度。该系统由以下耦合常微分方程描述：\n$$\n\\frac{du}{dt} = \\alpha - \\beta u(t)\n$$\n$$\n\\frac{ds}{dt} = \\beta u(t) - \\gamma s(t)\n$$\n这里，$\\alpha$ 是转录速率，$\\beta$ 是剪接速率，$\\gamma$ 是已剪接mRNA的降解速率。所有参数都是非负的。\n\n该流程包括以下主要阶段：\n\n**1. 动力学参数估计**\n\n对于每个基因，动力学参数 $\\alpha$、$\\beta$ 和 $\\gamma$ 是根据所有细胞中未剪接（$U$）和已剪接（$S$）计数的时间序列数据来估计的。细胞按给定的时间变量 $t$ 排序。\n\n首先，使用有限差分方案从离散的时间序列数据中近似连续导数 $\\frac{du}{dt}$ 和 $\\frac{ds}{dt}$。对于数据序列 $y(t_i)$，在时间 $t_i$ 的导数使用中心差分估计内部点（$0  i  N-1$），并使用单侧（前向/后向）差分估计端点（$i=0$ 和 $i=N-1$）：\n- 前向差分（$i=0$）：$\\frac{dy}{dt}\\big\\vert_{t_0} \\approx \\frac{y(t_1) - y(t_0)}{t_1 - t_0}$\n- 中心差分（$0  i  N-1$）：$\\frac{dy}{dt}\\big\\vert_{t_i} \\approx \\frac{y(t_{i+1}) - y(t_{i-1})}{t_{i+1} - t_{i-1}}$\n- 后向差分（$i=N-1$）：$\\frac{dy}{dt}\\big\\vert_{t_{N-1}} \\approx \\frac{y(t_{N-1}) - y(t_{N-2})}{t_{N-1} - t_{N-2}}$\n\n在近似导数后，通过普通最小二乘法（OLS）估计参数。对于每个基因 $g$：\n- 为了找到 $\\alpha_g$ 和 $\\beta_g$，方程 $\\frac{du_g}{dt} = \\alpha_g - \\beta_g u_g$ 被视为一个线性回归问题。我们求解 $(\\alpha_g, \\beta_g)$，使其最能拟合所有细胞 $i=0, \\dots, N-1$ 的数据对 $\\{(\\frac{du_g}{dt})_i, u_{g,i}\\}$。所得估计值在 $0$ 处截断以强制非负性。\n- 利用估计出的 $\\beta_g$，通过拟合第二个方程（重排为 $\\frac{ds_g}{dt} - \\beta_g u_g = -\\gamma_g s_g$）来找到参数 $\\gamma_g$。这是一个通过原点的 $\\gamma_g$ 线性回归，使用数据 $\\{(\\frac{ds_g}{dt})_i, u_{g,i}, s_{g,i}\\}$。同样，对 $\\gamma_g$ 的估计强制为非负。\n\n一旦确定了基因特异性参数 $(\\alpha_g, \\beta_g, \\gamma_g)$，细胞 $i$ 中基因 $g$ 的瞬时RNA速度就计算为已剪接mRNA的变化率，由下式给出：\n$$\nv_{i,g} = \\beta_g u_{i,g} - \\gamma_g s_{i,g}\n$$\n这为每个细胞 $i$ 产生一个速度向量 $v_i \\in \\mathbb{R}^G$。\n\n**2. 速度投影到嵌入上**\n\n推断出的速度存在于高维基因表达空间（$\\mathbb{R}^G$）中。为了在低维细胞状态流形（以二维UMAP嵌入 $X$ 的形式给出）的背景下对其进行可视化和解释，必须对它们进行投影。这是通过假设UMAP嵌入是基因表达空间的局部线性变换来实现的。\n\n对于每个细胞 $i$，我们使用欧几里得距离在已剪接表达空间（$\\mathbb{R}^G$）中找到其 $k$ 个最近邻，其中 $k = \\min(3, N-1)$。设这些邻居的索引为 $j \\in \\mathcal{N}_i$。然后我们构建细胞与其邻居在已剪接表达空间（$\\Delta S$，一个 $k \\times G$ 矩阵）和UMAP空间（$\\Delta X$，一个 $k \\times 2$ 矩阵）中的差异矩阵。这些矩阵的行是 $\\Delta S_j = S[j,:] - S[i,:]$ 和 $\\Delta X_j = X[j,:] - X[i,:]$。\n\n我们寻求一个线性映射（一个转移矩阵）$B_i \\in \\mathbb{R}^{G \\times 2}$，通过解决最小二乘问题来最好地解释这些差异之间的关系：\n$$\n\\min_{B_i} \\lVert \\Delta S B_i - \\Delta X \\rVert_F^2\n$$\n解由 $B_i = (\\Delta S^\\dagger) \\Delta X$ 给出，其中 $\\Delta S^\\dagger$ 是 $\\Delta S$ 的摩尔-彭若斯伪逆。即使 $\\Delta S$ 不是满秩的，这种方法也很稳健。\n\n然后，通过应用这个学习到的局部变换，将细胞 $i$ 的高维速度向量 $v_i$ 投影到二维嵌入空间中：\n$$\nw_i = v_i^\\top B_i\n$$\n这为每个细胞产生一个二维速度向量 $w_i \\in \\mathbb{R}^2$，代表了UMAP图内细胞状态变化的方向和速度。\n\n**3. 方向性验证**\n\n最后一步是评估推断出的速度方向是否与细胞的已知时间进程一致。通过对嵌入坐标关于时间 $t$ 求导，为每个细胞在UMAP空间中计算一个“基准真相”方向向量。这个时间梯度 $g_i = \\frac{dX}{dt}\\big\\vert_{t_i}$ 使用与之前相同的有限差分方案计算。\n\n投影速度 $w_i$ 和时间梯度 $g_i$ 之间的一致性通过它们的余弦相似度来量化：\n$$\n\\cos\\theta_i = \\frac{w_i \\cdot g_i}{\\lVert w_i \\rVert_2 \\lVert g_i \\rVert_2}\n$$\n接近 $1$ 的值表示速度指向时间进程的方向，接近 $-1$ 的值表示指向相反方向，接近 $0$ 的值表示正交。按照惯例，如果任一向量的范数为零，则余弦相似度定义为 $0$。\n\n然后，通过对所有 $N$ 个细胞求平均余弦相似度 $\\overline{c} = \\frac{1}{N}\\sum_{i=0}^{N-1} \\cos\\theta_i$，来总结给定数据集的速度模型的整体性能。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the RNA velocity pipeline on all test cases.\n    \"\"\"\n\n    def compute_derivatives(y_data, t_data):\n        \"\"\"\n        Computes derivatives of a time series using finite differences.\n        y_data can be a 1D array or a 2D array (for multiple dimensions).\n        \"\"\"\n        if y_data.ndim == 1:\n            y_data = y_data.reshape(-1, 1)\n\n        N = y_data.shape[0]\n        dy_dt = np.zeros_like(y_data, dtype=float)\n\n        # Forward difference for the first point\n        dy_dt[0, :] = (y_data[1, :] - y_data[0, :]) / (t_data[1] - t_data[0])\n\n        # Central differences for interior points\n        for i in range(1, N - 1):\n            dy_dt[i, :] = (y_data[i + 1, :] - y_data[i - 1, :]) / (t_data[i + 1] - t_data[i - 1])\n\n        # Backward difference for the last point\n        dy_dt[N - 1, :] = (y_data[N - 1, :] - y_data[N - 2, :]) / (t_data[N - 1] - t_data[N - 2])\n        \n        if dy_dt.shape[1] == 1:\n            return dy_dt.flatten() # Return as 1D if input was 1D\n        return dy_dt\n\n    def process_case(N, G, t, U, S, X):\n        \"\"\"\n        Processes a single test case for the RNA velocity pipeline.\n        \"\"\"\n        # --- 1. Estimate gene-wise kinetic parameters ---\n        alpha_params = np.zeros(G)\n        beta_params = np.zeros(G)\n        gamma_params = np.zeros(G)\n\n        for g in range(G):\n            u_g = U[:, g]\n            s_g = S[:, g]\n\n            du_dt = compute_derivatives(u_g, t)\n            ds_dt = compute_derivatives(s_g, t)\n\n            # Fit alpha and beta: du/dt = alpha - beta * u\n            design_matrix_alpha_beta = np.vstack([np.ones(N), -u_g]).T\n            params_ab, _, _, _ = np.linalg.lstsq(design_matrix_alpha_beta, du_dt, rcond=None)\n            alpha_g = max(0, params_ab[0])\n            beta_g = max(0, params_ab[1])\n            \n            alpha_params[g] = alpha_g\n            beta_params[g] = beta_g\n\n            # Fit gamma: ds/dt - beta * u = -gamma * s\n            target_gamma = ds_dt - beta_g * u_g\n            design_matrix_gamma = -s_g.reshape(-1, 1)\n            \n            if np.sum(design_matrix_gamma**2) > 1e-9:\n                params_g, _, _, _ = np.linalg.lstsq(design_matrix_gamma, target_gamma, rcond=None)\n                gamma_g = max(0, params_g[0])\n            else:\n                gamma_g = 0.0\n            \n            gamma_params[g] = gamma_g\n\n        # --- 2. Compute instantaneous velocity matrix V ---\n        V = beta_params * U - gamma_params * S\n\n        # --- 3. Project velocities to embedding ---\n        k = min(3, N - 1)\n        w_vectors = np.zeros((N, 2))\n\n        for i in range(N):\n            # Find k nearest neighbors in spliced expression space\n            dists = np.linalg.norm(S - S[i, :], axis=1)\n            neighbor_indices = np.argsort(dists)[1:k+1] # Exclude self (dist=0)\n\n            delta_S = S[neighbor_indices] - S[i, :]\n            delta_X = X[neighbor_indices] - X[i, :]\n\n            # Solve for the local linear map B_i\n            B_i, _, _, _ = np.linalg.lstsq(delta_S, delta_X, rcond=None)\n\n            # Project velocity vector\n            v_i = V[i, :]\n            w_i = v_i @ B_i\n            w_vectors[i, :] = w_i\n            \n        # --- 4. Assess directionality ---\n        # Compute temporal gradient of the embedding\n        g_vectors = compute_derivatives(X, t)\n\n        # Compute cosine similarities\n        cos_sims = np.zeros(N)\n        for i in range(N):\n            w_i = w_vectors[i, :]\n            g_i = g_vectors[i, :]\n            \n            norm_w = np.linalg.norm(w_i)\n            norm_g = np.linalg.norm(g_i)\n\n            if norm_w > 1e-9 and norm_g > 1e-9:\n                cos_sims[i] = np.dot(w_i, g_i) / (norm_w * norm_g)\n            else:\n                cos_sims[i] = 0.0\n        \n        return np.mean(cos_sims)\n\n    # --- Test Suite ---\n    test_cases = []\n\n    # Test Case A\n    N_A, G_A = 6, 3\n    t_A = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n    X_A = np.array([[0.0, 0.0], [1.0, 0.1], [2.0, 0.0], [3.0, -0.1], [4.0, -0.1], [5.0, 0.0]], dtype=float)\n    U_A = np.array([\n        [0, 4, 6], [2, 4, 5], [4, 4, 4], \n        [6, 4, 3], [7, 4, 2], [8, 4, 1]\n    ], dtype=float)\n    S_A = np.array([\n        [0, 8, 12], [1, 8, 10], [3, 8, 8], \n        [6, 8, 6], [9, 8, 5], [12, 8, 4]\n    ], dtype=float)\n    test_cases.append((N_A, G_A, t_A, U_A, S_A, X_A))\n\n    # Test Case B\n    N_B, G_B = 5, 2\n    t_B = np.array([0.0, 0.5, 1.5, 3.0, 5.0], dtype=float)\n    X_B = np.array([[0.0, 0.0], [0.7, 0.8], [1.8, 1.9], [3.2, 3.1], [5.0, 5.1]], dtype=float)\n    U_B = np.array([[0, 3], [1, 3], [2, 3], [3, 2], [3, 2]], dtype=float)\n    S_B = np.array([[0, 6], [1, 6], [2, 6], [3, 5], [4, 5]], dtype=float)\n    test_cases.append((N_B, G_B, t_B, U_B, S_B, X_B))\n\n    # Test Case C\n    N_C, G_C = 6, 2\n    t_C = np.array([0, 1, 2, 3, 4, 5], dtype=float)\n    X_C = np.array([[5.0, 0.0], [4.0, 0.0], [3.0, 0.0], [2.0, 0.0], [1.0, 0.0], [0.0, 0.0]], dtype=float)\n    U_C = np.array([[1, 5], [2, 4], [3, 3], [4, 2], [5, 1], [6, 1]], dtype=float)\n    S_C = np.array([[1, 10], [2, 8], [3, 7], [5, 6], [7, 5], [9, 5]], dtype=float)\n    test_cases.append((N_C, G_C, t_C, U_C, S_C, X_C))\n\n    results = []\n    for case in test_cases:\n        N, G, t, U, S, X = case\n        result = process_case(N, G, t, U, S, X)\n        results.append(f\"{result:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}