{
    "hands_on_practices": [
        {
            "introduction": "在将连续的生理信号（如光电容积描记图(PPG)）转化为离散的数字序列时，一个核心挑战是确保信号的保真度。如果采样率不足，可能会出现一种称为“混叠”的严重失真，导致我们观察到的频率与真实的生理频率完全不同。本练习将引导你从第一性原理出发，推导混叠现象的条件，从而深刻理解为何选择合适的采样率对于可穿戴设备的设计和数据解读至关重要 。",
            "id": "4396363",
            "problem": "一款腕戴式光电容积脉搏波（PPG）传感器被用于一项精准健康研究，以推导出心律的数字表型。其底层的纯净动脉血容量波形可以建模为一个单频正弦波，其连续时间频率为 $f_0$（单位为$\\mathrm{Hz}$），振幅为 $A$，相位为 $\\phi$，因此生理信号为 $s(t)=A\\sin(2\\pi f_0 t+\\phi)$。该可穿戴设备以速率 $f_s$（单位为$\\mathrm{Hz}$）对该信号进行均匀采样，采样周期为 $T_s=1/f_s$，从而生成离散时间序列 $x[n]=s(nT_s)$。\n\n从均匀采样的定义 $x[n]=s(nT_s)$、正弦函数的周期性以及离散时间正弦波在角频率上以 $2\\pi$ 为模定义这一事实出发，推导描述能产生相同离散时间样本的连续时间频率集合的混叠条件。然后，从第一性原理出发，得到主低通频带 $[0,\\,f_s/2]$ 内观测到的混叠频率的闭式表达式，该表达式仅用 $f_0$ 和 $f_s$ 表示。\n\n最后，计算当 $f_0=3.2\\,\\mathrm{Hz}$ 且 $f_s=5\\,\\mathrm{Hz}$ 时观测到的混叠频率。最终数值答案以 $\\mathrm{Hz}$ 为单位表示。无需四舍五入。",
            "solution": "该问题陈述被认为是有效的。其科学基础在于数字信号处理的原理，特别是均匀采样中的混叠现象。该问题提法恰当、客观，并为完整的推导和求解提供了所有必要信息。\n\n推导过程按要求分为三部分：首先，建立混叠条件；其次，推导主频带内观测到的混叠频率的表达式；第三，针对给定的数值计算该表达式的值。\n\n**第一部分：混叠条件的推导**\n\n连续时间生理信号由以下模型给出：\n$$\ns(t) = A\\sin(2\\pi f_0 t + \\phi)\n$$\n其中 $f_0$ 是以 $\\mathrm{Hz}$ 为单位的连续时间频率。\n\n该信号以 $f_s$ $\\mathrm{Hz}$ 的速率进行均匀采样，采样周期为 $T_s = 1/f_s$。通过在时间点 $t = nT_s$（其中 $n$ 为整数索引）处对 $s(t)$ 求值，得到离散时间序列 $x[n]$。\n$$\nx[n] = s(nT_s) = A\\sin(2\\pi f_0 nT_s + \\phi)\n$$\n代入 $T_s = 1/f_s$，表达式变为：\n$$\nx[n] = A\\sin\\left(2\\pi \\frac{f_0}{f_s} n + \\phi\\right)\n$$\n这是离散时间正弦波的标准形式 $x[n] = A\\sin(\\omega_0 n + \\phi)$，其中离散时间角频率为 $\\omega_0 = 2\\pi \\frac{f_0}{f_s}$。\n\n离散时间正弦波的一个基本性质是其在频域上的周期性。具体来说，对于任意整数 $k$，离散时间角频率 $\\omega$ 与任何频率 $\\omega + 2\\pi k$ 等效，因为对于任意整数采样索引 $n$：\n$$\n\\sin((\\omega + 2\\pi k)n + \\phi) = \\sin(\\omega n + 2\\pi kn + \\phi) = \\sin(\\omega n + \\phi)\n$$\n$2\\pi kn$ 项是 $2\\pi$ 的整数倍，而正弦函数的周期为 $2\\pi$，因此该项不改变函数的值。\n\n现在，考虑两个不同的连续时间频率 $f_a$ 和 $f_b$，它们以相同的速率 $f_s$ 进行采样。对应的离散时间角频率为 $\\omega_a = 2\\pi (f_a/f_s)$ 和 $\\omega_b = 2\\pi (f_b/f_s)$。要使这两个频率产生相同的离散时间样本（即，它们互为混叠），它们的离散时间角频率必须以 $2\\pi$ 为模等效。也就是说，必须存在某个整数 $k$ 使得：\n$$\n\\omega_a = \\omega_b + 2\\pi k\n$$\n代入 $\\omega_a$ 和 $\\omega_b$ 的表达式：\n$$\n2\\pi \\frac{f_a}{f_s} = 2\\pi \\frac{f_b}{f_s} + 2\\pi k\n$$\n将整个方程除以 $2\\pi$ 可得：\n$$\n\\frac{f_a}{f_s} = \\frac{f_b}{f_s} + k\n$$\n乘以 $f_s$，我们得到混叠条件：\n$$\nf_a = f_b + kf_s\n$$\n该条件描述了当以速率 $f_s$ 采样时，所有与频率 $f_b$ 无法区分的连续时间频率的集合。\n\n此外，我们还必须考虑恒等式 $\\sin(\\theta) = -\\sin(-\\theta)$，这意味着频率 $f$ 也可能与 $-f$ 混淆。相位会发生偏移，但频率分量的幅度相同。完整的混叠条件指出，如果两个连续频率 $f_a$ 和 $f_b$ 对于某个整数 $k$ 满足 $f_a = \\pm f_b + kf_s$，则它们互为混叠。\n\n**第二部分：观测到的混叠频率的推导**\n\n观测到的混叠频率（我们记为 $f_{obs}$）通常定义为主低通频带 $[0, f_s/2]$ 内的唯一频率，该频率产生的样本集与原始频率 $f_0$ 相同。这对应于能够表示采样数据的最低频率实正弦波。\n\n基于完整的混叠条件，我们寻找满足两个标准的频率 $f_{obs}$：\n1. $0 \\le f_{obs} \\le f_s/2$\n2. 对于某个整数 $k$，$f_0 = \\pm f_{obs} + kf_s$。\n\n根据第二个标准，我们可以写出 $f_{obs} = \\pm(f_0 - kf_s)$。由于 $f_{obs}$ 必须为非负数，这可以简化为：\n$$\nf_{obs} = |f_0 - kf_s|\n$$\n我们需要找到一个特定的整数 $k$，使得 $f_{obs}$ 的这个表达式落在 $[0, f_s/2]$ 的范围内。这等价于找到 $f_s$ 的整数倍（记为 $kf_s$），使其最接近原始频率 $f_0$。$f_0$ 与这个最接近的倍数之间的绝对差就是我们观测到的频率。\n\n将 $kf_s$ 带到最接近 $f_0$ 的整数 $k$ 是通过将比率 $f_0/f_s$ 四舍五入到最接近的整数来找到的。设这个整数为：\n$$\nk = \\text{round}\\left(\\frac{f_0}{f_s}\\right)\n$$\n算子 $\\text{round}(y)$ 给出最接近 $y$ 的整数。将这个 $k$ 的值代回我们对 $f_{obs}$ 的表达式，得到最终的闭式表达式：\n$$\nf_{obs} = \\left|f_0 - f_s \\cdot \\text{round}\\left(\\frac{f_0}{f_s}\\right)\\right|\n$$\n这个公式将任何正的连续时间频率 $f_0$ 映射到其在主频带 $[0, f_s/2]$ 内的混叠频率。\n\n**第三部分：数值计算**\n\n我们被要求计算当 $f_0 = 3.2\\,\\mathrm{Hz}$ 和 $f_s = 5\\,\\mathrm{Hz}$ 这两个特定值时观测到的混叠频率。\n\n首先，我们计算频率之比：\n$$\n\\frac{f_0}{f_s} = \\frac{3.2}{5} = 0.64\n$$\n接下来，我们找到最接近这个比率的整数：\n$$\nk = \\text{round}(0.64) = 1\n$$\n最后，我们将这些值代入推导出的 $f_{obs}$ 表达式中：\n$$\nf_{obs} = |f_0 - k \\cdot f_s| = |3.2 - 1 \\cdot 5| = |3.2 - 5| = |-1.8|\n$$\n观测到的频率是这个结果的绝对值：\n$$\nf_{obs} = 1.8\\,\\mathrm{Hz}\n$$\n这个结果在主频带 $[0, f_s/2]$ 内，即 $[0, 2.5\\,\\mathrm{Hz}]$，符合要求。$5\\,\\mathrm{Hz}$ 的采样率不足以唯一地表示 $3.2\\,\\mathrm{Hz}$ 的真实频率（因为 $3.2 > 5/2$），导致它混叠到更低的频率 $1.8\\,\\mathrm{Hz}$。",
            "answer": "$$\\boxed{1.8}$$"
        },
        {
            "introduction": "获得可靠的数字信号后，下一步是从中提取有意义的生物标志物。本练习聚焦于心率变异性（Heart Rate Variability, HRV）的计算，它反映了自主神经系统的功能，是精准健康领域一个重要的数字生物标志物。通过推导并计算两个关键的时域HRV指标——RMSSD和SDNN，你将把抽象的统计概念与具体的生理指标联系起来，掌握从原始RR间期序列中量化生理状态的核心技能 。",
            "id": "4396329",
            "problem": "一个精准健康研究团队正在验证源自腕戴式光电容积描记 (PPG) 传感器的心率变异性 (HRV) 特征，旨在为与精准医疗和基因组诊断学相关的自主神经功能建立数字表型。经过伪影筛查和异位搏动去除后，该团队从一名处于静息状态的参与者身上，在一个稳定的短记录窗口中，获得了一系列以毫秒 (ms) 为单位的正常至正常 RR 间期（连续正常心搏之间的时间）序列。\n\n从适用于生理学中时间序列分析的基本定义出发，为一个有限的 RR 间期样本推导连续差分均方根 (RMSSD) 和 NN 间期标准差 (SDNN) 的表达式。您的推导必须从样本均值的定义、作为期望的经验代理的均方概念，以及平稳过程的无偏样本方差开始。清楚地说明任何按样本量进行归一化的理由。\n\n然后，使用推导出的表达式，为以下 $N=10$ 的 RR 间期序列（所有值单位为毫秒）计算 RMSSD 和 SDNN：$910$、$915$、$905$、$920$、$900$、$910$、$905$、$915$、$900$、$925$。假设这些间期是从一个趋势可忽略的平稳段中采样的，因此使用无偏估计量是合适的。\n\n报告 RMSSD 和 SDNN 的最终数值，四舍五入到四位有效数字。两个量均以毫秒为单位表示。在您的最终答案中，按 RMSSD 在前、SDNN 在后的顺序列出这两个值。",
            "solution": "该问题是有效的，因为它具有科学依据、问题良定、客观，并包含足够的信息以获得唯一解。心率变异性 (HRV) 分析的背景是生物医学信号处理和精准健康领域的一个标准课题。所要求的指标，连续差分均方根 (RMSSD) 和 NN 间期标准差 (SDNN)，在该领域中是定义明确且基础的。\n\n我们首先按照要求，从基本统计学原理出发，推导 SDNN 和 RMSSD 的表达式。设 $N$ 个正常至正常 (NN) RR 间期的序列表示为时间序列 $\\{RR_i\\}_{i=1}^{N}$。\n\n**NN 间期标准差 (SDNN) 的推导**\n\nSDNN 定义为 RR 间期序列的标准差。其推导始于对样本来源的潜在平稳过程的均值和方差的估计。\n\n1.  **样本均值 ($\\bar{RR}$):** 样本均值是观测值的算术平均值，用作过程真实均值 $\\mu$ 的经验估计。其定义为：\n    $$ \\bar{RR} = \\frac{1}{N} \\sum_{i=1}^{N} RR_i $$\n\n2.  **无偏样本方差 ($s^2$):** 问题指定使用无偏样本方差。当真实均值 $\\mu$ 未知并由样本均值 $\\bar{RR}$ 估计时，离差平方和 $\\sum_{i=1}^{N} (RR_i - \\bar{RR})^2$ 具有 $N-1$ 个自由度。为了获得真实总体方差 $\\sigma^2$ 的无偏估计量（即其期望值为 $\\sigma^2$ 的估计量），我们用 $N-1$ 而不是 $N$ 来归一化这个和。这被称为贝塞尔校正 (Bessel's correction)。因此，无偏样本方差为：\n    $$ s^2 = \\frac{1}{N-1} \\sum_{i=1}^{N} (RR_i - \\bar{RR})^2 $$\n\n3.  **SDNN:** SDNN 是无偏样本方差的平方根。\n    $$ \\text{SDNN} = \\sqrt{s^2} = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N} (RR_i - \\bar{RR})^2} $$\n    这是 SDNN 的最终表达式。\n\n**连续差分均方根 (RMSSD) 的推导**\n\nRMSSD 量化了短期、高频变异性，它是根据连续 RR 间期之间的差异推导出来的。\n\n1.  **连续差分 ($\\Delta RR_i$):** 首先，我们计算相邻 RR 间期之间的差分序列。对于一个包含 $N$ 个间期的序列，存在 $N-1$ 个这样的差分：\n    $$ \\Delta RR_i = RR_{i+1} - RR_i \\quad \\text{for } i = 1, 2, \\dots, N-1 $$\n\n2.  **连续差分均方 (MSSD):** 问题要求使用均方概念作为期望的经验代理。我们旨在估计连续差分平方的期望值 $E[(\\Delta RR)^2]$。经验估计是样本中观测到的差分平方的平均值。由于存在 $N-1$ 个连续差分，其均值通过将这些差分的平方求和再除以 $N-1$ 来计算。\n    $$ \\text{MSSD} = \\frac{1}{N-1} \\sum_{i=1}^{N-1} (\\Delta RR_i)^2 = \\frac{1}{N-1} \\sum_{i=1}^{N-1} (RR_{i+1} - RR_i)^2 $$\n    对于这 $N-1$ 个差分平方值，除以 $N-1$ 进行归一化是样本均值定义本身所固有的。\n\n3.  **RMSSD:** 根据定义，RMSSD 是 MSSD 的平方根。\n    $$ \\text{RMSSD} = \\sqrt{\\text{MSSD}} = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N-1} (RR_{i+1} - RR_i)^2} $$\n    这是 RMSSD 的最终表达式。\n\n**针对给定数据的计算**\n\n提供的 $N=10$ 的 RR 间期序列（单位为毫秒）是：\n$RR = \\{910, 915, 905, 920, 900, 910, 905, 915, 900, 925\\}$。\n\n**SDNN 的计算：**\n\n1.  计算样本均值 $\\bar{RR}$：\n    $$ \\sum_{i=1}^{10} RR_i = 910 + 915 + 905 + 920 + 900 + 910 + 905 + 915 + 900 + 925 = 9105 $$\n    $$ \\bar{RR} = \\frac{9105}{10} = 910.5 \\text{ ms} $$\n\n2.  计算与均值的离差平方和 $\\sum_{i=1}^{10} (RR_i - \\bar{RR})^2$：\n    $$ (910 - 910.5)^2 + (915 - 910.5)^2 + (905 - 910.5)^2 + (920 - 910.5)^2 + (900 - 910.5)^2 \\\\ + (910 - 910.5)^2 + (905 - 910.5)^2 + (915 - 910.5)^2 + (900 - 910.5)^2 + (925 - 910.5)^2 \\\\ = (-0.5)^2 + (4.5)^2 + (-5.5)^2 + (9.5)^2 + (-10.5)^2 + (-0.5)^2 + (-5.5)^2 + (4.5)^2 + (-10.5)^2 + (14.5)^2 \\\\ = 0.25 + 20.25 + 30.25 + 90.25 + 110.25 + 0.25 + 30.25 + 20.25 + 110.25 + 210.25 = 622.5 \\text{ ms}^2 $$\n\n3.  使用推导出的公式和 $N=10$ 计算 SDNN：\n    $$ \\text{SDNN} = \\sqrt{\\frac{1}{10-1} \\sum_{i=1}^{10} (RR_i - \\bar{RR})^2} = \\sqrt{\\frac{622.5}{9}} = \\sqrt{69.166...} \\approx 8.31665 \\text{ ms} $$\n    四舍五入到四位有效数字，$\\text{SDNN} = 8.317 \\text{ ms}$。\n\n**RMSSD 的计算：**\n\n1.  计算连续差分 $\\Delta RR_i = RR_{i+1} - RR_i$：\n    $$ \\Delta RR_1 = 915 - 910 = 5 $$\n    $$ \\Delta RR_2 = 905 - 915 = -10 $$\n    $$ \\Delta RR_3 = 920 - 905 = 15 $$\n    $$ \\Delta RR_4 = 900 - 920 = -20 $$\n    $$ \\Delta RR_5 = 910 - 900 = 10 $$\n    $$ \\Delta RR_6 = 905 - 910 = -5 $$\n    $$ \\Delta RR_7 = 915 - 905 = 10 $$\n    $$ \\Delta RR_8 = 900 - 915 = -15 $$\n    $$ \\Delta RR_9 = 925 - 900 = 25 $$\n\n2.  计算这 $N-1=9$ 个差分的平方和 $\\sum_{i=1}^{9} (\\Delta RR_i)^2$：\n    $$ 5^2 + (-10)^2 + 15^2 + (-20)^2 + 10^2 + (-5)^2 + 10^2 + (-15)^2 + 25^2 \\\\ = 25 + 100 + 225 + 400 + 100 + 25 + 100 + 225 + 625 = 1825 \\text{ ms}^2 $$\n\n3.  使用推导出的公式计算 RMSSD：\n    $$ \\text{RMSSD} = \\sqrt{\\frac{1}{10-1} \\sum_{i=1}^{9} (\\Delta RR_i)^2} = \\sqrt{\\frac{1825}{9}} = \\sqrt{202.777...} \\approx 14.2399... \\text{ ms} $$\n    四舍五入到四位有效数字，$\\text{RMSSD} = 14.24 \\text{ ms}$。\n\n最终值为 RMSSD $\\approx 14.24$ ms 和 SDNN $\\approx 8.317$ ms。",
            "answer": "$$\\boxed{\\begin{pmatrix} 14.24  8.317 \\end{pmatrix}}$$"
        },
        {
            "introduction": "真实世界中的可穿戴设备数据通常是纵向和分层的，即多次测量数据嵌套在不同个体之内。这项高级实践介绍了线性混合效应模型（Linear Mixed-Effects Models, LMMs），这是一种分析此类复杂数据结构的强大统计工具。通过构建并检验一个用于分析每日步数的LMM，你将学习如何同时为群体趋势（如每周的活动节律）和个体特异性差异进行建模，这是实现精准健康分析的基石 。",
            "id": "4396397",
            "problem": "一个包含 $S$ 个个体的队列通过佩戴基于加速度计的腕戴式可穿戴传感器进行监测，这些传感器报告每日步数，这是一种与精准健康相关的客观数字表型。由于行为习惯（例如，工作日与周末），每日步数通常表现出周季节性。任务是构建并拟合一个线性混合模型（LMM），该模型使用固定效应捕捉周季节性，并允许特定于受试者的随机截距和随机周末斜率，然后在一个预先指定的显著性水平上检验是否存在统计上显著的周末效应。分析必须完全以数学和算法术语来构建，并且必须依赖于高斯建模框架。\n\n使用的基本基础：\n- 假设每日活动水平遵循高斯线性混合建模框架：观测到的每日步数 $y$ 被建模为固定效应和随机效应的线性组合加上高斯噪声。\n- 假设每日的测量噪声是独立同分布的高斯噪声，且不同受试者之间的随机效应是独立的。\n- 假设周季节性可以使用谐波基来表示，该基由作为星期几角度（以弧度为单位）的函数的余弦和正弦分量组成。\n\n建模要求：\n- 构建固定效应设计矩阵 $X$，其列包括：一个截距项、一个周末指示符，以及谐波项 $\\cos\\!\\left(2\\pi d/7\\right)$ 和 $\\sin\\!\\left(2\\pi d/7\\right)$，其中 $d \\in \\{0,1,2,3,4,5,6\\}$ 是星期几的索引，角度必须以弧度为单位。周末指示符对于周六和周日必须为 $1$，否则为 $0$。所有涉及角度的答案都必须以弧度计算。\n- 构建随机效应设计，使得每个受试者都有一个随机截距和一个与周末指示符相关的随机斜率。必须假设随机效应在受试者之间是独立的，并且在受试者内部，截距和斜率之间也是独立的。\n- 在高斯假设下，通过最大似然（ML）拟合LMM。残差方差和两个随机效应方差都必须被视为待从数据中估计的未知参数，并受限于严格为正的约束。\n- 通过比较完整模型（包括固定周末效应）与嵌套的零模型（固定周末效应被约束为零），进行似然比检验以确定是否存在固定周末效应，同时在两个模型中保持相同的随机效应结构。在自由度为1的卡方分布下，计算似然比统计量及其对应的 $p$ 值。使用 $\\alpha = 0.05$ 的显著性阈值（将 $\\alpha$ 表示为小数）。\n\n程序内的合成数据生成协议：\n- 对于受试者 $s \\in \\{1,\\dots,S\\}$ 和日索引 $t \\in \\{0,1,\\dots,D-1\\}$，令星期几的索引为 $d_t = t \\bmod 7$。如果 $d_t \\in \\{5,6\\}$，则周末指示符 $w_t = 1$，否则 $w_t = 0$。每日步数按如下方式生成\n$$\ny_{s,t} = \\beta_0 + b_{0,s} + (\\beta_w + b_{1,s})\\, w_t + \\beta_c \\cos\\!\\left(\\frac{2\\pi d_t}{7}\\right) + \\beta_s \\sin\\!\\left(\\frac{2\\pi d_t}{7}\\right) + \\varepsilon_{s,t},\n$$\n其中 $b_{0,s} \\sim \\mathcal{N}(0,\\sigma_{b0}^2)$，$b_{1,s} \\sim \\mathcal{N}(0,\\sigma_{b1}^2)$，$\\varepsilon_{s,t} \\sim \\mathcal{N}(0,\\sigma_e^2)$，且所有随机量都是独立的。在生成过程中，每日步数是物理单位，但本问题要求的输出是无量纲的统计量（布尔值），因此最终输出中无需表达任何物理单位。\n\n测试套件规范：\n- 程序必须生成并分析三个测试用例。在每个用例中，设置随机种子以确保可复现性，并使用以下参数（所有数字的单位均为每日步数或每日步数的平方，视情况而定）：\n    1. 情况A（理想路径）：$S=20$，$D=28$，$\\beta_0=7000$，$\\beta_w=2000$，$\\beta_c=400$，$\\beta_s=-200$，$\\sigma_{b0}=800$，$\\sigma_{b1}=300$，$\\sigma_e=500$，固定随机种子为 $12345$。\n    2. 情况B（周末效应为空，边界条件）：$S=20$，$D=28$，$\\beta_0=7000$，$\\beta_w=0$，$\\beta_c=400$，$\\beta_s=-200$，$\\sigma_{b0}=800$，$\\sigma_{b1}=400$，$\\sigma_e=600$，固定随机种子为 $23456$。\n    3. 情况C（小样本和高随机斜率方差的边缘情况）：$S=6$，$D=14$，$\\beta_0=7000$，$\\beta_w=500$，$\\beta_c=300$, $\\beta_s=100$，$\\sigma_{b0}=900$, $\\sigma_{b1}=1000$，$\\sigma_e=700$，固定随机种子为 $34567$。\n\n测试统计量的计算和决策规则：\n- 对于每种情况，通过最大似然法拟合完整模型和嵌套的零模型，计算似然比统计量\n$$\n\\lambda = 2\\big(\\ell_{\\text{full}} - \\ell_{\\text{null}}\\big),\n$$\n并根据自由度为 $1$ 的卡方分布评估其对应的 $p$ 值。如果 $p$ 值严格小于 $\\alpha = 0.05$，则宣布周末效应是显著的。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的 Python 布尔值列表，其顺序与上面列出的情况一致。例如，输出必须看起来像 $\\texttt{[True,False,True]}$（此示例仅为说明，并非正确答案；您的程序必须计算实际结果）。",
            "solution": "该问题要求构建并拟合一个高斯线性混合模型（LMM），以分析合成的每日步数数据，然后对一个特定的固定效应进行假设检验。解决方案首先定义模型的数学结构，然后详细说明最大似然（ML）估计过程，最后指定针对目标假设的似然比检验（LRT）。\n\n### 1. 线性混合模型公式\n\n对于受试者 $s \\in \\{1, \\dots, S\\}$ 在第 $t \\in \\{0, \\dots, D-1\\}$ 天的每日步数 $y_{s,t}$，其LMM模型如下：\n$$\ny_{s,t} = \\boldsymbol{x}_{s,t}^T \\boldsymbol{\\beta} + \\boldsymbol{z}_{s,t}^T \\boldsymbol{b}_s + \\varepsilon_{s,t}\n$$\n这可以为每个受试者以矩阵形式表示。令 $\\boldsymbol{y}_s = [y_{s,0}, \\dots, y_{s,D-1}]^T$ 为受试者 $s$ 的 $D \\times 1$ 观测向量。受试者 $s$ 的模型为：\n$$\n\\boldsymbol{y}_s = \\boldsymbol{X}_s \\boldsymbol{\\beta} + \\boldsymbol{Z}_s \\boldsymbol{b}_s + \\boldsymbol{\\varepsilon}_s\n$$\n该模型的组成部分定义如下：\n\n- **固定效应**：受试者 $s$ 的固定效应设计矩阵为 $\\boldsymbol{X}_s \\in \\mathbb{R}^{D \\times p}$，$\\boldsymbol{\\beta} \\in \\mathbb{R}^p$ 是固定效应系数向量。对于完整模型，我们有 $p=4$ 个固定效应：一个截距项、一个周末效应和两个用于周季节性的谐波项。令 $d_t = t \\pmod 7$ 为星期几的索引。如果 $d_t \\in \\{5, 6\\}$（周六、周日），周末指示符 $w_t=1$，否则 $w_t=0$。$\\boldsymbol{X}_s$ 的行为 $\\boldsymbol{x}_{s,t}^T = [1, w_t, \\cos(2\\pi d_t/7), \\sin(2\\pi d_t/7)]$。对应的固定效应向量为 $\\boldsymbol{\\beta} = [\\beta_0, \\beta_w, \\beta_c, \\beta_s]^T$。\n\n- **随机效应**：受试者 $s$ 的随机效应设计矩阵为 $\\boldsymbol{Z}_s \\in \\mathbb{R}^{D \\times q}$，$\\boldsymbol{b}_s \\in \\mathbb{R}^q$ 是特定于受试者的随机效应向量。模型为每个受试者包含一个随机截距和一个随机周末斜率，因此 $q=2$。$\\boldsymbol{Z}_s$ 的行为 $\\boldsymbol{z}_{s,t}^T = [1, w_t]$。随机效应向量为 $\\boldsymbol{b}_s = [b_{0,s}, b_{1,s}]^T$。\n\n- **分布假设**：随机效应和测量误差被假定为独立的正态分布：\n    - $\\boldsymbol{b}_s \\sim \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{G})$，其中 $\\boldsymbol{G}$ 是随机效应的 $q \\times q$ 协方差矩阵。由于指定的随机截距和斜率之间是独立的，$\\boldsymbol{G}$ 是一个对角矩阵：\n      $$\n      \\boldsymbol{G} = \\begin{pmatrix} \\sigma_{b0}^2  0 \\\\ 0  \\sigma_{b1}^2 \\end{pmatrix}\n      $$\n    - $\\boldsymbol{\\varepsilon}_s \\sim \\mathcal{N}(\\boldsymbol{0}, \\boldsymbol{R}_s)$，其中 $\\boldsymbol{R}_s$ 是残差的 $D \\times D$ 协方差矩阵。在独立同分布的噪声下，$\\boldsymbol{R}_s = \\sigma_e^2 \\boldsymbol{I}_D$，其中 $\\boldsymbol{I}_D$ 是 $D \\times D$ 的单位矩阵。\n\n待估计的未知方差分量是 $\\sigma_{b0}^2$、$\\sigma_{b1}^2$ 和 $\\sigma_e^2$。\n\n### 2. 最大似然估计\n\n在这些假设下，受试者 $s$ 的观测向量 $\\boldsymbol{y}_s$ 的边缘分布是一个多元正态分布：\n$$\n\\boldsymbol{y}_s \\sim \\mathcal{N}(\\boldsymbol{X}_s \\boldsymbol{\\beta}, \\boldsymbol{V}_s)\n$$\n其中边缘协方差矩阵 $\\boldsymbol{V}_s$ 由下式给出：\n$$\n\\boldsymbol{V}_s = \\boldsymbol{Z}_s \\boldsymbol{G} \\boldsymbol{Z}_s^T + \\boldsymbol{R}_s = \\sigma_{b0}^2 (\\boldsymbol{Z}_s \\boldsymbol{J}_1 \\boldsymbol{Z}_s^T) + \\sigma_{b1}^2 (\\boldsymbol{Z}_s \\boldsymbol{J}_2 \\boldsymbol{Z}_s^T) + \\sigma_e^2 \\boldsymbol{I}_D\n$$\n其中 $\\boldsymbol{J}_1 = \\text{diag}(1,0)$ 且 $\\boldsymbol{J}_2 = \\text{diag}(0,1)$。\n\n由于受试者是独立的，整个数据集 $\\boldsymbol{y} = \\{\\boldsymbol{y}_1, \\dots, \\boldsymbol{y}_S\\}$ 的总对数似然是各个对数似然之和：\n$$\n\\ell(\\boldsymbol{\\beta}, \\sigma_{b0}^2, \\sigma_{b1}^2, \\sigma_e^2 | \\boldsymbol{y}) = \\sum_{s=1}^S \\ell_s(\\boldsymbol{\\beta}, \\sigma_{b0}^2, \\sigma_{b1}^2, \\sigma_e^2 | \\boldsymbol{y}_s)\n$$\n其中\n$$\n\\ell_s = -\\frac{D}{2}\\ln(2\\pi) - \\frac{1}{2}\\ln|\\boldsymbol{V}_s| - \\frac{1}{2}(\\boldsymbol{y}_s - \\boldsymbol{X}_s\\boldsymbol{\\beta})^T \\boldsymbol{V}_s^{-1} (\\boldsymbol{y}_s - \\boldsymbol{X}_s\\boldsymbol{\\beta})\n$$\n为了找到最大似然估计（MLEs），我们相对于 $\\boldsymbol{\\theta} = (\\boldsymbol{\\beta}, \\sigma_{b0}^2, \\sigma_{b1}^2, \\sigma_e^2)$ 最大化 $\\ell$。这通常使用剖面似然方法来完成。对于固定的方差分量 $\\boldsymbol{\\psi} = (\\sigma_{b0}^2, \\sigma_{b1}^2, \\sigma_e^2)$，$\\boldsymbol{\\beta}$ 的MLE是广义最小二乘（GLS）估计量：\n$$\n\\hat{\\boldsymbol{\\beta}}(\\boldsymbol{\\psi}) = \\left( \\sum_{s=1}^S \\boldsymbol{X}_s^T \\boldsymbol{V}_s^{-1} \\boldsymbol{X}_s \\right)^{-1} \\left( \\sum_{s=1}^S \\boldsymbol{X}_s^T \\boldsymbol{V}_s^{-1} \\boldsymbol{y}_s \\right)\n$$\n将 $\\hat{\\boldsymbol{\\beta}}(\\boldsymbol{\\psi})$ 代入对数似然函数，得到仅依赖于方差分量的剖面对数似然 $\\ell_p(\\boldsymbol{\\psi})$。然后我们在约束条件 $\\sigma_{b0}^2 > 0$、$\\sigma_{b1}^2 > 0$ 和 $\\sigma_e^2 > 0$ 下，对 $\\ell_p(\\boldsymbol{\\psi})$ 关于 $\\boldsymbol{\\psi}$ 进行数值优化。在最小化负对数剖面似然时，目标函数在最小值点的值可以用来计算最大化的对数似然 $\\ell_{\\text{max}}$。\n\n### 3. 固定周末效应的似然比检验\n\n我们检验原假设 $H_0: \\beta_w = 0$ 相对于备择假设 $H_1: \\beta_w \\neq 0$。\n\n- **完整模型 ($H_1$)**：如上所述，具有 $p=4$ 个固定效应的模型，包括周末系数 $\\beta_w$。MLE过程产生一个最大化的对数似然 $\\ell_{\\text{full}}$。\n\n- **零模型 ($H_0$)**：一个嵌套模型，其中 $\\beta_w$ 被约束为零。固定效应设计矩阵 $\\boldsymbol{X}_{s, \\text{null}}$ 有 $p=3$ 列（截距项、余弦项和正弦项），相应的固定效应向量为 $\\boldsymbol{\\beta}_{\\text{null}} = [\\beta_0, \\beta_c, \\beta_s]^T$。随机效应结构保持不变。通过ML拟合此模型，得到一个最大化的对数似然 $\\ell_{\\text{null}}$。\n\n似然比检验统计量 $\\lambda$ 计算如下：\n$$\n\\lambda = 2(\\ell_{\\text{full}} - \\ell_{\\text{null}})\n$$\n根据威尔克斯定理，在原假设下，$\\lambda$ 渐近服从卡方分布，其自由度等于两个模型之间参数数量的差异。在这里，一个参数（$\\beta_w$）被约束，因此自由度为 $df = 1$。\n\n$p$ 值计算为在 $\\lambda$ 处评估的 $\\chi^2_1$ 分布的生存函数，即 $p = P(\\chi^2_1 \\ge \\lambda)$。如果这个 $p$ 值严格小于预先指定的显著性水平 $\\alpha = 0.05$，则认为周末效应具有统计显著性。\n\n算法实现将包括：\n1.  根据指定的协议为每个测试用例生成合成数据。\n2.  定义一个函数，用于计算给定一组方差参数的负剖面似然。\n3.  使用数值优化器（`scipy.optimize.minimize`，方法为 'L-BFGS-B'）为完整模型和零模型找到方差分量的MLE。\n4.  计算LRT统计量 $\\lambda$ 及其对应的 $p$ 值。\n5.  将 $p$ 值与 $\\alpha=0.05$ 进行比较，以决定每个测试用例的统计显著性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\n\ndef generate_synthetic_data(S, D, beta_0, beta_w, beta_c, beta_s, sigma_b0, sigma_b1, sigma_e, seed):\n    \"\"\"Generates synthetic data according to the problem specification.\"\"\"\n    rng = np.random.default_rng(seed)\n    \n    Y_subjects = []\n    \n    # Common design matrix components for all subjects\n    t_indices = np.arange(D)\n    d_indices = t_indices % 7\n    weekend_indicator = np.isin(d_indices, [5, 6]).astype(int)\n\n    intercept_col = np.ones(D)\n    weekend_col = weekend_indicator\n    cos_col = np.cos(2 * np.pi * d_indices / 7)\n    sin_col = np.sin(2 * np.pi * d_indices / 7)\n    \n    X_full_template = np.stack([intercept_col, weekend_col, cos_col, sin_col], axis=1)\n    Z_template = np.stack([intercept_col, weekend_col], axis=1)\n    \n    beta_vector = np.array([beta_0, beta_w, beta_c, beta_s])\n    \n    for s in range(S):\n        b0_s = rng.normal(0, sigma_b0)\n        b1_s = rng.normal(0, sigma_b1)\n        epsilon_s = rng.normal(0, sigma_e, size=D)\n        \n        y_s = (X_full_template @ beta_vector + \n               Z_template @ np.array([b0_s, b1_s]) +\n               epsilon_s)\n               \n        Y_subjects.append(y_s)\n        \n    return Y_subjects\n\ndef get_design_matrices(S, D):\n    \"\"\"Constructs the design matrices X_full, X_null, and Z for S subjects over D days.\"\"\"\n    t_indices = np.arange(D)\n    d_indices = t_indices % 7\n    weekend_indicator = np.isin(d_indices, [5, 6]).astype(int)\n\n    intercept_col = np.ones(D)\n    weekend_col = weekend_indicator\n    cos_col = np.cos(2 * np.pi * d_indices / 7)\n    sin_col = np.sin(2 * np.pi * d_indices / 7)\n    \n    X_full_template = np.stack([intercept_col, weekend_col, cos_col, sin_col], axis=1)\n    X_null_template = np.stack([intercept_col, cos_col, sin_col], axis=1)\n    Z_template = np.stack([intercept_col, weekend_col], axis=1)\n    \n    X_full_subjects = [X_full_template] * S\n    X_null_subjects = [X_null_template] * S\n    Z_subjects = [Z_template] * S\n    \n    return X_full_subjects, X_null_subjects, Z_subjects\n\n\ndef negative_log_likelihood(var_params, Y_subjects, X_subjects, Z_subjects):\n    \"\"\"Calculates the negative profile log-likelihood for the LMM.\"\"\"\n    sigma2_b0, sigma2_b1, sigma2_e = var_params\n    \n    S = len(Y_subjects)\n    if S == 0:\n        return 0.\n    D = Y_subjects[0].shape[0]\n    p = X_subjects[0].shape[1]\n    \n    G = np.diag([sigma2_b0, sigma2_b1])\n    I_D = np.eye(D)\n\n    sum_Xt_V_inv_X = np.zeros((p, p))\n    sum_Xt_V_inv_y = np.zeros(p)\n    profile_loglik_val = 0\n    \n    try:\n        V_inv_list = []\n        for s in range(S):\n            Z_s = Z_subjects[s]\n            V_s = Z_s @ G @ Z_s.T + sigma2_e * I_D\n            \n            V_s_inv = np.linalg.inv(V_s)\n            sign, logdet_V_s = np.linalg.slogdet(V_s)\n            \n            if sign = 0:\n                return np.inf\n\n            profile_loglik_val += logdet_V_s\n            V_inv_list.append(V_s_inv)\n            \n            X_s = X_subjects[s]\n            y_s = Y_subjects[s]\n            \n            sum_Xt_V_inv_X += X_s.T @ V_s_inv @ X_s\n            sum_Xt_V_inv_y += X_s.T @ V_s_inv @ y_s\n\n        beta_hat = np.linalg.solve(sum_Xt_V_inv_X, sum_Xt_V_inv_y)\n\n        for s in range(S):\n            X_s = X_subjects[s]\n            y_s = Y_subjects[s]\n            V_s_inv = V_inv_list[s]\n            \n            residuals = y_s - X_s @ beta_hat\n            profile_loglik_val += residuals.T @ V_s_inv @ residuals\n    \n    except np.linalg.LinAlgError:\n        return np.inf\n\n    return 0.5 * profile_loglik_val\n\n\ndef fit_lmm(Y_subjects, X_subjects, Z_subjects):\n    \"\"\"Fits the LMM by ML and returns the minimized negative profile log-likelihood value.\"\"\"\n    # Use variance of all data points as a scale for initial guesses\n    initial_scale = np.var(np.concatenate(Y_subjects))\n    initial_guesses = [initial_scale * 0.3, initial_scale * 0.3, initial_scale * 0.4]\n\n    bounds = [(1e-9, None), (1e-9, None), (1e-9, None)]\n    \n    result = minimize(\n        negative_log_likelihood,\n        x0=initial_guesses,\n        args=(Y_subjects, X_subjects, Z_subjects),\n        method='L-BFGS-B',\n        bounds=bounds\n    )\n    return result.fun\n\n\ndef solve():\n    \"\"\"Main function to run the analysis for all test cases.\"\"\"\n    test_cases = [\n        # S, D, beta_0, beta_w, beta_c, beta_s, sigma_b0, sigma_b1, sigma_e, seed\n        (20, 28, 7000, 2000, 400, -200, 800, 300, 500, 12345),\n        (20, 28, 7000, 0, 400, -200, 800, 400, 600, 23456),\n        (6, 14, 7000, 500, 300, 100, 900, 1000, 700, 34567),\n    ]\n\n    alpha = 0.05\n    results = []\n\n    for S, D, b0, bw, bc, bs, sb0, sb1, se, seed in test_cases:\n        Y_subjects = generate_synthetic_data(S, D, b0, bw, bc, bs, sb0, sb1, se, seed)\n        X_full_subjects, X_null_subjects, Z_subjects = get_design_matrices(S, D)\n        \n        # Fit the full model\n        min_neg_loglik_full = fit_lmm(Y_subjects, X_full_subjects, Z_subjects)\n        \n        # Fit the null model\n        min_neg_loglik_null = fit_lmm(Y_subjects, X_null_subjects, Z_subjects)\n        \n        # Likelihood Ratio Test\n        # lambda = 2 * (l_full - l_null)\n        # l = - (SD/2)log(2pi) - min_neg_loglik\n        # lambda = 2 * ((-min_neg_loglik_full) - (-min_neg_loglik_null))\n        lambda_stat = 2 * (min_neg_loglik_null - min_neg_loglik_full)\n        \n        # Handle cases where optimization might fail or result in non-positive lambda\n        if lambda_stat  0:\n            lambda_stat = 0\n\n        p_value = chi2.sf(lambda_stat, df=1)\n        \n        results.append(p_value  alpha)\n        \n    # The final print statement must match the specified format\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}