{
    "hands_on_practices": [
        {
            "introduction": "The journey from a neural command to a physical movement begins at the muscle. This exercise explores the fundamental biomechanics of torque generation using a classic Hill-type muscle model. You will see firsthand how muscle force is not a simple function of its activation, but is dynamically modulated by its length and velocity, and how this force is transformed into joint torque through the musculoskeletal geometry . This practice provides a concrete foundation for understanding the complex, non-linear nature of the body's actuators.",
            "id": "3971475",
            "problem": "Consider a single-degree-of-freedom planar elbow joint actuated by one flexor muscle modeled as a Hill-type actuator. The following well-tested components characterize the muscle mechanics: the active contractile force scales with maximal isometric force, activation, an active force–length multiplier, and a force–velocity multiplier; a passive parallel elastic element contributes force that grows exponentially with extension beyond optimal length; the joint torque equals the scalar moment arm multiplied by the muscle–tendon force.\n\nAssume the muscle has maximal isometric force $F_{0} = 1500\\,\\mathrm{N}$ and activation $a = 0.60$. The fiber length is expressed in units normalized by optimal fiber length, $\\ell = 1.10$, and the fiber velocity is normalized by maximal shortening velocity, $v = 0$. The active force–length multiplier is given by\n$$\nf_{\\ell}(\\ell) = \\exp\\!\\left(-\\left(\\frac{\\ell - 1}{w}\\right)^{2}\\right),\n$$\nwith width parameter $w = 0.25$. The passive elastic force is modeled as\n$$\nF_{\\mathrm{passive}}(\\ell) = \n\\begin{cases}\nF_{0}\\,c_{p}\\!\\left(\\exp\\!\\big(k_{p}(\\ell - 1)\\big) - 1\\right), & \\ell \\ge 1,\\\n$$6pt]\n0, & \\ell < 1,\n\\end{cases}\n$$\nwith $c_{p} = 0.01$ and $k_{p} = 4.0$. For the force–velocity effect, use the standard normalization convention that $f_{v}(0) = 1$ at zero velocity.\n\nThe joint angle is $q = \\pi/3\\,\\mathrm{rad}$. The scalar moment arm as a function of angle is\n$$\nR(q) = r_{0} + r_{1}\\cos(q),\n$$\nwith $r_{0} = 0.030\\,\\mathrm{m}$ and $r_{1} = 0.010\\,\\mathrm{m}$.\n\nUsing only these definitions and fundamental mechanics, compute the net elbow flexion torque $\\tau$ at the given posture. Express your final answer in $\\mathrm{N\\cdot m}$ and round to four significant figures. Angles are in radians.",
            "solution": "The problem statement provides a complete and scientifically consistent description of a biomechanical system based on a standard Hill-type muscle model. All parameters and functions required to calculate the joint torque are specified, rendering the problem valid and well-posed. The solution proceeds by systematically calculating the components that contribute to the net joint torque.\n\nThe net elbow flexion torque, $\\tau$, is the product of the total muscle force, $F_{\\text{total}}$, and the muscle's moment arm, $R(q)$, about the joint axis.\n$$ \\tau = F_{\\text{total}} \\cdot R(q) $$\nThe total force generated by the muscle is the sum of the active force, $F_{\\text{active}}$, and the passive force, $F_{\\text{passive}}$.\n$$ F_{\\text{total}} = F_{\\text{active}} + F_{\\text{passive}} $$\n\nFirst, we calculate the moment arm, $R(q)$, at the specified joint angle $q = \\pi/3\\,\\mathrm{rad}$. The formula for the moment arm is given as:\n$$ R(q) = r_{0} + r_{1}\\cos(q) $$\nSubstituting the given parameter values $r_{0} = 0.030\\,\\mathrm{m}$ and $r_{1} = 0.010\\,\\mathrm{m}$:\n$$ R(\\pi/3) = 0.030\\,\\mathrm{m} + (0.010\\,\\mathrm{m})\\cos(\\pi/3) $$\nThe cosine of $\\pi/3$ radians is exactly $0.5$.\n$$ R(\\pi/3) = 0.030\\,\\mathrm{m} + (0.010\\,\\mathrm{m})(0.5) = 0.030\\,\\mathrm{m} + 0.005\\,\\mathrm{m} = 0.035\\,\\mathrm{m} $$\n\nNext, we calculate the total muscle force, $F_{\\text{total}}$. This requires computing its active and passive components.\n\nThe active force, $F_{\\text{active}}$, is defined by the product of several factors:\n$$ F_{\\text{active}} = F_{0} \\cdot a \\cdot f_{\\ell}(\\ell) \\cdot f_{v}(v) $$\nwhere $F_{0}$ is the maximal isometric force, $a$ is the muscle activation, $f_{\\ell}(\\ell)$ is the active force-length multiplier, and $f_{v}(v)$ is the force-velocity multiplier.\nThe problem states that the fiber velocity is zero, corresponding to a normalized velocity $v=0$. Per the problem's convention, the force-velocity multiplier at zero velocity is unity:\n$$ f_{v}(0) = 1 $$\nThe active force-length multiplier, $f_{\\ell}(\\ell)$, is given by the function:\n$$ f_{\\ell}(\\ell) = \\exp\\left(-\\left(\\frac{\\ell - 1}{w}\\right)^{2}\\right) $$\nUsing the given normalized fiber length $\\ell = 1.10$ and width parameter $w = 0.25$, we compute:\n$$ f_{\\ell}(1.10) = \\exp\\left(-\\left(\\frac{1.10 - 1}{0.25}\\right)^{2}\\right) = \\exp\\left(-\\left(\\frac{0.10}{0.25}\\right)^{2}\\right) = \\exp\\left(-(0.4)^{2}\\right) = \\exp(-0.16) $$\nNow, we can assemble the active force using the given values $F_{0} = 1500\\,\\mathrm{N}$ and $a = 0.60$:\n$$ F_{\\text{active}} = (1500\\,\\mathrm{N}) \\cdot (0.60) \\cdot \\exp(-0.16) \\cdot 1 = 900 \\cdot \\exp(-0.16)\\,\\mathrm{N} $$\n\nThe passive force, $F_{\\text{passive}}$, is determined by the muscle's extension. Since the normalized fiber length is $\\ell = 1.10$, which is greater than or equal to $1$, we use the first case of the provided piecewise function:\n$$ F_{\\text{passive}}(\\ell) = F_{0}\\,c_{p}\\!\\left(\\exp\\!\\big(k_{p}(\\ell - 1)\\big) - 1\\right) \\quad \\text{for } \\ell \\ge 1 $$\nSubstituting the parameters $F_{0} = 1500\\,\\mathrm{N}$, $c_{p} = 0.01$, and $k_{p} = 4.0$, along with $\\ell = 1.10$:\n$$ F_{\\text{passive}}(1.10) = (1500\\,\\mathrm{N}) \\cdot (0.01) \\left(\\exp\\big(4.0 \\cdot (1.10 - 1)\\big) - 1\\right) $$\n$$ F_{\\text{passive}}(1.10) = 15 \\left(\\exp\\big(4.0 \\cdot 0.10\\big) - 1\\right)\\,\\mathrm{N} = 15 \\left(\\exp(0.4) - 1\\right)\\,\\mathrm{N} $$\n\nThe total muscle force is the sum of the active and passive forces:\n$$ F_{\\text{total}} = F_{\\text{active}} + F_{\\text{passive}} = \\left(900 \\cdot \\exp(-0.16) + 15 \\left(\\exp(0.4) - 1\\right)\\right)\\,\\mathrm{N} $$\nWe evaluate this expression numerically:\n$$ \\exp(-0.16) \\approx 0.8521405 $$\n$$ \\exp(0.4) \\approx 1.4918247 $$\n$$ F_{\\text{active}} \\approx 900 \\cdot 0.8521405\\,\\mathrm{N} \\approx 766.92645\\,\\mathrm{N} $$\n$$ F_{\\text{passive}} \\approx 15 \\left(1.4918247 - 1\\right)\\,\\mathrm{N} = 15 \\cdot 0.4918247\\,\\mathrm{N} \\approx 7.37737\\,\\mathrm{N} $$\n$$ F_{\\text{total}} \\approx 766.92645\\,\\mathrm{N} + 7.37737\\,\\mathrm{N} = 774.30382\\,\\mathrm{N} $$\n\nFinally, we compute the net elbow flexion torque $\\tau$ by multiplying the total force by the calculated moment arm:\n$$ \\tau = F_{\\text{total}} \\cdot R(\\pi/3) \\approx (774.30382\\,\\mathrm{N}) \\cdot (0.035\\,\\mathrm{m}) $$\n$$ \\tau \\approx 27.1006337\\,\\mathrm{N\\cdot m} $$\nThe problem requires the answer to be rounded to four significant figures.\n$$ \\tau \\approx 27.10\\,\\mathrm{N\\cdot m} $$",
            "answer": "$$\n\\boxed{27.10}\n$$"
        },
        {
            "introduction": "Effective motor control relies on an accurate understanding of the body's state, which the brain must estimate from multiple, often noisy, sensory sources. This problem delves into the principle of optimal cue combination, a cornerstone of Bayesian models of perception and action. By deriving the optimal weights for fusing visual and proprioceptive information, you will uncover the elegant strategy the nervous system uses to form the most reliable possible estimate from unreliable data .",
            "id": "3971512",
            "problem": "A subject performs planar reaching with endpoint position denoted by the random variable $x$ in meters. Two sensory channels provide independent measurements of $x$: vision and proprioception. Vision returns $x_{v} = x + \\varepsilon_{v}$ and proprioception returns $x_{p} = x + \\varepsilon_{p}$, where $\\varepsilon_{v}$ and $\\varepsilon_{p}$ are independent zero-mean Gaussian noises with variances $\\sigma_{v}^{2}$ and $\\sigma_{p}^{2}$, respectively. Assume both channels are unbiased so that $\\mathbb{E}[x_{v}] = \\mathbb{E}[x_{p}] = x$.\n\nYou will construct a linear estimator $\\hat{x} = w_{v} x_{v} + w_{p} x_{p}$ subject to the unbiasedness constraint $w_{v} + w_{p} = 1$. Starting from first principles—linearity, unbiasedness, independence, and the variance of a linear combination—derive the optimal cue weights $w_{v}$ and $w_{p}$ that minimize the estimator’s variance. Then, using those optimal weights, predict the variance of the fused estimate $\\mathrm{Var}(\\hat{x})$.\n\nFor a specific instantiation, use $\\sigma_{v}^{2} = 9 \\times 10^{-6}\\ \\mathrm{m}^{2}$ and $\\sigma_{p}^{2} = 36 \\times 10^{-6}\\ \\mathrm{m}^{2}$. Round all numerical entries of your final answer to four significant figures. Express the fused variance in $\\mathrm{m}^{2}$. Do not include units in your final boxed answer; include only the numerical values.\n\nYour final answer must be a single row matrix containing, in order, the vision weight $w_{v}$, the proprioceptive weight $w_{p}$, and the fused variance $\\mathrm{Var}(\\hat{x})$.",
            "solution": "The problem asks for the derivation of optimal weights for a linear, unbiased estimator that fuses two independent sensory measurements, and for the calculation of the resulting variance of the fused estimate.\n\nLet the linear estimator for the true position $x$ be $\\hat{x} = w_{v} x_{v} + w_{p} x_{p}$. The measurements are $x_v = x + \\varepsilon_v$ and $x_p = x + \\varepsilon_p$, where $\\varepsilon_v$ and $\\varepsilon_p$ are independent, zero-mean noises with variances $\\sigma_v^2$ and $\\sigma_p^2$.\n\n**1. Unbiasedness Constraint**\nThe problem states that the estimator must be unbiased, meaning $\\mathbb{E}[\\hat{x}] = x$.\n$$ \\mathbb{E}[\\hat{x}] = \\mathbb{E}[w_v x_v + w_p x_p] = w_v \\mathbb{E}[x_v] + w_p \\mathbb{E}[x_p] $$\nSince the channels are unbiased, $\\mathbb{E}[x_v] = x$ and $\\mathbb{E}[x_p] = x$.\n$$ \\mathbb{E}[\\hat{x}] = w_v x + w_p x = (w_v + w_p)x $$\nFor this to equal $x$, we must have $w_v + w_p = 1$. This confirms the constraint provided. We can write $w_p = 1 - w_v$.\n\n**2. Minimizing Estimator Variance**\nThe variance of the estimator is what we aim to minimize. First, express $\\hat{x}$ in terms of the true value and noise:\n$$ \\hat{x} = w_v(x + \\varepsilon_v) + w_p(x + \\varepsilon_p) = (w_v + w_p)x + w_v\\varepsilon_v + w_p\\varepsilon_p = x + w_v\\varepsilon_v + w_p\\varepsilon_p $$\nThe variance of $\\hat{x}$ is the variance of the noise terms, as $x$ is a constant for a given estimation. Since $\\varepsilon_v$ and $\\varepsilon_p$ are independent:\n$$ \\mathrm{Var}(\\hat{x}) = \\mathrm{Var}(w_v\\varepsilon_v + w_p\\varepsilon_p) = w_v^2 \\mathrm{Var}(\\varepsilon_v) + w_p^2 \\mathrm{Var}(\\varepsilon_p) = w_v^2 \\sigma_v^2 + w_p^2 \\sigma_p^2 $$\nSubstitute $w_p = 1 - w_v$ to get the variance as a function of $w_v$ only:\n$$ V(w_v) = w_v^2 \\sigma_v^2 + (1 - w_v)^2 \\sigma_p^2 $$\nTo find the minimum, we take the derivative with respect to $w_v$ and set it to zero:\n$$ \\frac{dV}{dw_v} = 2w_v \\sigma_v^2 + 2(1 - w_v)(-1)\\sigma_p^2 = 2w_v \\sigma_v^2 - 2\\sigma_p^2 + 2w_v\\sigma_p^2 = 0 $$\n$$ w_v(\\sigma_v^2 + \\sigma_p^2) = \\sigma_p^2 \\implies w_v = \\frac{\\sigma_p^2}{\\sigma_v^2 + \\sigma_p^2} $$\nThe optimal weight $w_p$ is then:\n$$ w_p = 1 - w_v = \\frac{\\sigma_v^2}{\\sigma_v^2 + \\sigma_p^2} $$\nThis shows the optimal weights are proportional to the precision (inverse variance) of the *other* cue.\n\n**3. Fused Variance**\nSubstitute the optimal weights back into the variance expression:\n$$ \\mathrm{Var}(\\hat{x}) = \\left(\\frac{\\sigma_p^2}{\\sigma_v^2 + \\sigma_p^2}\\right)^2 \\sigma_v^2 + \\left(\\frac{\\sigma_v^2}{\\sigma_v^2 + \\sigma_p^2}\\right)^2 \\sigma_p^2 = \\frac{\\sigma_p^4 \\sigma_v^2 + \\sigma_v^4 \\sigma_p^2}{(\\sigma_v^2 + \\sigma_p^2)^2} $$\n$$ \\mathrm{Var}(\\hat{x}) = \\frac{\\sigma_v^2 \\sigma_p^2 (\\sigma_p^2 + \\sigma_v^2)}{(\\sigma_v^2 + \\sigma_p^2)^2} = \\frac{\\sigma_v^2 \\sigma_p^2}{\\sigma_v^2 + \\sigma_p^2} = \\frac{1}{1/\\sigma_v^2 + 1/\\sigma_p^2} $$\nThe precision of the combined estimate is the sum of the individual precisions.\n\n**4. Numerical Calculation**\nGiven $\\sigma_v^2 = 9 \\times 10^{-6}\\ \\mathrm{m}^2$ and $\\sigma_p^2 = 36 \\times 10^{-6}\\ \\mathrm{m}^2$:\n- **Weights**:\n$$ w_v = \\frac{36 \\times 10^{-6}}{9 \\times 10^{-6} + 36 \\times 10^{-6}} = \\frac{36}{45} = 0.8 $$\n$$ w_p = 1 - 0.8 = 0.2 $$\n- **Fused Variance**:\n$$ \\mathrm{Var}(\\hat{x}) = \\frac{(9 \\times 10^{-6})(36 \\times 10^{-6})}{9 \\times 10^{-6} + 36 \\times 10^{-6}} = \\frac{324 \\times 10^{-12}}{45 \\times 10^{-6}} = 7.2 \\times 10^{-6}\\ \\mathrm{m}^2 $$\nRounding to four significant figures gives $w_v=0.8000$, $w_p=0.2000$, and $\\mathrm{Var}(\\hat{x}) = 7.200 \\times 10^{-6}$.",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 0.8000 & 0.2000 & 7.200 \\times 10^{-6} \\end{pmatrix} } $$"
        },
        {
            "introduction": "How does the brain maintain stability in inherently unstable systems, such as the upright human body? This problem introduces the Linear Quadratic Regulator (LQR), a powerful framework from optimal control theory used to model this process. By designing an LQR controller for a linearized inverted pendulum, you will explore how the nervous system might generate stabilizing motor commands that efficiently balance task goals (staying upright) against control effort . This exercise provides a hands-on experience with a normative model that has profoundly shaped our understanding of feedback control in the brain.",
            "id": "3971477",
            "problem": "Consider a torque-driven rigid pendulum used as a simplified model of a single-joint limb in motor control. The rotational dynamics about an equilibrium angle are given by the second-order ordinary differential equation\n$$\nI\\,\\ddot{\\theta}(t) + b\\,\\dot{\\theta}(t) + m g l\\,\\sin(\\theta(t)) = u(t),\n$$\nwhere $m$ is the mass, $l$ is the length, $I = m l^2$ is the moment of inertia about the pivot, $b$ is the viscous damping coefficient, $g$ is the gravitational acceleration, and $u(t)$ is the applied torque. Linearize about an equilibrium angle $\\theta_e$ with small deviation $\\phi(t) = \\theta(t) - \\theta_e$ using the small-angle approximation $\\sin(\\theta_e + \\phi) \\approx \\sin(\\theta_e) + \\cos(\\theta_e)\\,\\phi$. For equilibria where $\\sin(\\theta_e) = 0$ and $\\cos(\\theta_e) \\in \\{+1, -1\\}$, the linearized continuous-time state-space model with state $x(t) = [\\phi(t), \\dot{\\phi}(t)]^\\top$ has the form\n$$\n\\dot{x}(t) = A x(t) + B u(t),\n$$\nwith\n$$\nA = \\begin{bmatrix}\n0 & 1 \\\\\n- \\dfrac{g}{l}\\,\\cos(\\theta_e) & -\\dfrac{b}{I}\n\\end{bmatrix},\\quad\nB = \\begin{bmatrix}\n0 \\\\\n\\dfrac{1}{I}\n\\end{bmatrix}.\n$$\nDefine the regulation objective by the infinite-horizon quadratic cost\n$$\nJ = \\int_0^\\infty \\left( x(t)^\\top Q\\, x(t) + u(t)^\\top R\\, u(t) \\right)\\, dt,\n$$\nwhere $Q \\succeq 0$ is a symmetric positive semidefinite state-weight matrix and $R \\succ 0$ is a symmetric positive definite control-weight matrix. The Linear Quadratic Regulator (LQR) aims to find a state-feedback law $u(t) = -K x(t)$ that minimizes $J$. Assess motor control stability and damping by examining the closed-loop matrix $A_{\\mathrm{cl}} = A - B K$ and its eigenvalues.\n\nStarting only from the definitions above and first principles of linear systems and optimal control, implement an algorithm to:\n- Construct $A$ and $B$ from given physical parameters and equilibrium type.\n- Compute the LQR gain $K$ that minimizes $J$ under the given $(A,B,Q,R)$.\n- Form the closed-loop matrix $A_{\\mathrm{cl}}$ and compute its eigenvalues.\n- Determine stability by checking whether all eigenvalue real parts are strictly negative.\n- Quantify damping by computing, for each eigenvalue $\\lambda$, a damping ratio surrogate defined by\n$$\n\\zeta(\\lambda) =\n\\begin{cases}\n-\\dfrac{\\operatorname{Re}(\\lambda)}{\\lvert \\lambda \\rvert}, & \\text{if } \\operatorname{Im}(\\lambda) \\neq 0, \\\\\n1, & \\text{if } \\operatorname{Im}(\\lambda) = 0 \\text{ and } \\operatorname{Re}(\\lambda) < 0, \\\\\n0, & \\text{if } \\operatorname{Im}(\\lambda) = 0 \\text{ and } \\operatorname{Re}(\\lambda) \\ge 0,\n\\end{cases}\n$$\nand report the minimum value across all eigenvalues of $A_{\\mathrm{cl}}$ as the system's worst-case damping ratio. Additionally, report the maximum eigenvalue real part (units: $1/\\mathrm{s}$).\n\nYour program must evaluate the following test suite of physically plausible cases using the International System of Units (SI), with $g = 9.81\\,\\mathrm{m}/\\mathrm{s}^2$, angles in radians, and time in seconds. For each case, the equilibrium type is either \"upright\" ($\\cos(\\theta_e) = -1$) or \"downward\" ($\\cos(\\theta_e) = +1$), and the matrices $Q$ and $R$ are specified by diagonal entries such that $Q = \\mathrm{diag}(q_\\phi, q_{\\dot{\\phi}})$ and $R = [r]$ is a scalar ($1 \\times 1$) matrix.\n\nTest suite (each case is $(\\text{equilibrium}, m, l, b, q_\\phi, q_{\\dot{\\phi}}, r)$):\n- Case $1$: $(\\text{upright},\\, 1.0\\,\\mathrm{kg},\\, 1.0\\,\\mathrm{m},\\, 0.05\\,\\mathrm{N·m·s},\\, 15.0,\\, 1.5,\\, 0.2)$.\n- Case $2$: $(\\text{upright},\\, 2.0\\,\\mathrm{kg},\\, 1.5\\,\\mathrm{m},\\, 0.01\\,\\mathrm{N·m·s},\\, 120.0,\\, 12.0,\\, 0.05)$.\n- Case $3$: $(\\text{downward},\\, 1.0\\,\\mathrm{kg},\\, 0.8\\,\\mathrm{m},\\, 0.02\\,\\mathrm{N·m·s},\\, 2.0,\\, 0.2,\\, 0.5)$.\n- Case $4$: $(\\text{downward},\\, 1.0\\,\\mathrm{kg},\\, 1.0\\,\\mathrm{m},\\, 0.0\\,\\mathrm{N·m·s},\\, 5.0,\\, 0.5,\\, 10.0)$.\n- Case $5$: $(\\text{upright},\\, 1.0\\,\\mathrm{kg},\\, 1.0\\,\\mathrm{m},\\, 0.5\\,\\mathrm{N·m·s},\\, 30.0,\\, 3.0,\\, 0.1)$.\n\nFor each case, compute:\n- The boolean stability indicator (all real parts of eigenvalues of $A_{\\mathrm{cl}}$ strictly negative).\n- The maximum real part among eigenvalues of $A_{\\mathrm{cl}}$ (expressed in $1/\\mathrm{s}$ as a float).\n- The minimum damping ratio surrogate $\\min_{\\lambda} \\zeta(\\lambda)$ (dimensionless as a float).\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is itself a list of the form $[\\text{stable}, \\text{max\\_real\\_part}, \\text{min\\_damping\\_ratio}]$ with the two floats rounded to six decimal places, for example, $[[\\text{True}, -1.234567, 0.789012],[\\dots],\\dots]$.",
            "solution": "The problem requires the design and analysis of a Linear Quadratic Regulator (LQR) for a linearized pendulum model. The solution involves a sequence of steps derived from linear systems and optimal control theory.\n\n**1. System Modeling**\nFirst, the continuous-time linear state-space model $\\dot{x}(t) = A x(t) + B u(t)$ must be constructed from the given physical parameters. For each test case, we compute the moment of inertia $I = m l^2$. Based on the specified equilibrium type (\"upright\" or \"downward\"), we set $\\cos(\\theta_e)$ to either $-1$ or $+1$, respectively. These values, along with $g$, $l$, and $b$, are substituted into the provided formulas to populate the state matrix $A$ and the input matrix $B$. The cost matrices $Q$ and $R$ are constructed from the diagonal entries provided.\n\n**2. LQR Controller Design**\nThe core of the problem is to find the optimal state-feedback gain matrix $K$ for the control law $u(t) = -K x(t)$ that minimizes the infinite-horizon quadratic cost function $J$. For a linear time-invariant system, this is achieved by first solving the **Continuous Algebraic Riccati Equation (CARE)** for a unique, symmetric, positive semi-definite matrix $P$:\n$$ A^\\top P + P A - P B R^{-1} B^\\top P + Q = 0 $$\nThis matrix equation is typically solved using robust numerical algorithms (e.g., as found in scientific computing libraries for Python or MATLAB). Once the solution $P$ is found, the optimal LQR gain matrix $K$ is computed as:\n$$ K = R^{-1} B^\\top P $$\n\n**3. Closed-Loop System Analysis**\nWith the gain matrix $K$ computed, the control law is applied to the system. The dynamics of the resulting **closed-loop system** are given by $\\dot{x}(t) = A x(t) + B(-Kx(t)) = (A - B K)x(t)$. The stability and dynamic properties of the controlled system are determined by the eigenvalues of the closed-loop matrix $A_{\\mathrm{cl}} = A - B K$.\n- **Stability**: The system is asymptotically stable if and only if all eigenvalues of $A_{\\mathrm{cl}}$ have strictly negative real parts ($\\operatorname{Re}(\\lambda_i) < 0$ for all $i$). This condition is checked for each test case.\n- **Maximum Real Part**: The maximum real part among all eigenvalues, $\\max_i \\operatorname{Re}(\\lambda_i)$, provides a measure of the \"least stable\" mode of the system. A larger negative value indicates faster convergence to equilibrium.\n\n**4. Damping Ratio Calculation**\nThe damping characteristics of the system's response are quantified using the provided surrogate damping ratio, $\\zeta(\\lambda)$. This metric is calculated for each eigenvalue of $A_{\\mathrm{cl}}$ based on its real and imaginary parts. The minimum value across all eigenvalues, $\\min_\\lambda \\zeta(\\lambda)$, is reported. This represents the worst-case damping in any of the system's response modes. A value near 0 indicates a highly oscillatory mode, while a value near 1 indicates a well-damped, non-oscillatory mode.\n\nThe Python code provided in the answer implements these four steps for each case in the test suite, using numerical libraries to solve the CARE and compute eigenvalues, and then formats the results as required.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are\n\ndef solve():\n    \"\"\"\n    Solves the LQR problem for a linearized pendulum for a suite of test cases.\n    \"\"\"\n    g = 9.81  # Gravitational acceleration in m/s^2\n\n    test_cases = [\n        # (equilibrium, m, l, b, q_phi, q_dphi, r)\n        (\"upright\", 1.0, 1.0, 0.05, 15.0, 1.5, 0.2),    # Case 1\n        (\"upright\", 2.0, 1.5, 0.01, 120.0, 12.0, 0.05),  # Case 2\n        (\"downward\", 1.0, 0.8, 0.02, 2.0, 0.2, 0.5),    # Case 3\n        (\"downward\", 1.0, 1.0, 0.0, 5.0, 0.5, 10.0),   # Case 4\n        (\"upright\", 1.0, 1.0, 0.5, 30.0, 3.0, 0.1),    # Case 5\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        eq_type, m, l, b, q_phi, q_dphi, r = case\n\n        # Step 1: Construct state-space matrices A and B\n        I = m * l**2\n        cos_theta_e = -1.0 if eq_type == \"upright\" else 1.0\n\n        A = np.array([\n            [0.0, 1.0],\n            [-g/l * cos_theta_e, -b/I]\n        ])\n\n        B = np.array([\n            [0.0],\n            [1.0/I]\n        ])\n        \n        # Construct cost matrices Q and R\n        Q = np.diag([q_phi, q_dphi])\n        R = np.array([[r]])\n\n        # Step 2: Compute the LQR gain K\n        # Solve the Continuous Algebraic Riccati Equation (CARE) for P\n        # A.T*P + P*A - P*B*R_inv*B.T*P + Q = 0\n        P = solve_continuous_are(A, B, Q, R)\n\n        # Compute the optimal LQR gain K = R_inv * B.T * P\n        R_inv = np.linalg.inv(R)\n        K = R_inv @ B.T @ P\n\n        # Step 3: Form the closed-loop matrix and compute its eigenvalues\n        A_cl = A - B @ K\n        eigenvalues = np.linalg.eigvals(A_cl)\n\n        # Step 4: Determine stability and maximum eigenvalue real part\n        real_parts = np.real(eigenvalues)\n        is_stable = np.all(real_parts < 0)\n        max_real_part = np.max(real_parts)\n\n        # Step 5: Compute the minimum damping ratio surrogate\n        damping_ratios = []\n        for lam in eigenvalues:\n            if np.imag(lam) != 0:\n                zeta = -np.real(lam) / np.abs(lam)\n            else: # Real eigenvalue\n                if np.real(lam) < 0:\n                    zeta = 1.0\n                else:\n                    zeta = 0.0\n            damping_ratios.append(zeta)\n        \n        min_damping_ratio = np.min(damping_ratios)\n\n        all_results.append([is_stable, max_real_part, min_damping_ratio])\n    \n    # Format the final output string as specified\n    formatted_results = []\n    for res in all_results:\n        # res[0] is bool, res[1] and res[2] are floats\n        formatted_results.append(f\"[{res[0]}, {res[1]:.6f}, {res[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}