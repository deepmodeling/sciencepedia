{
    "hands_on_practices": [
        {
            "introduction": "A fundamental step in characterizing a neuron's function is to describe its tuning curve, which plots its response strength against a stimulus parameter. For direction selectivity, this curve is often well-approximated by simple trigonometric functions. This exercise provides foundational analytical practice by asking you to derive the Direction Selectivity Index (DSI) directly from the parameters of such a model tuning curve . By working through the derivation, you will gain a deeper intuition for how the symmetric (cosine) and asymmetric (sine) components of a neuron's tuning curve distinctly contribute to the magnitude of its selectivity and the orientation of its preferred direction.",
            "id": "3999450",
            "problem": "A neuron in a motion-processing area exhibits direction tuning described by the firing rate function $R(\\theta) = A + B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$, where $\\theta$ is the stimulus motion direction, $\\theta_0$ is a reference direction, and $A$, $B$, $C$ are real parameters. Angles are measured in radians. Assume $A > 0$ and $\\sqrt{B^{2} + C^{2}} < A$ so that the modulation is bounded by the positive baseline. In computational neuroscience, a widely used definition of the Direction Selectivity Index (DSI) is\n$$\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})},$$\nwhere $\\theta_{\\mathrm{pref}}$ is the direction that maximizes $R(\\theta)$ and $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$ is the opposite direction.\n\nStarting only from this definition, trigonometric identities, and the properties of maxima and minima of smooth functions, derive a closed-form expression for $\\mathrm{DSI}$ in terms of $A$, $B$, and $C$. Then, using your derivation, identify how the odd term $C\\sin(\\theta - \\theta_0)$ influences direction selectivity: does it change the magnitude of the Direction Selectivity Index, the preferred direction, both, or neither? Justify your conclusion from first principles. Express the final Direction Selectivity Index as a single analytical expression. No rounding is required, and no units should be included with your final answer.",
            "solution": "The problem provides the firing rate function of a direction-tuned neuron, $R(\\theta) = A + B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$, where $\\theta$ is the direction of stimulus motion. We are tasked with deriving a closed-form expression for the Direction Selectivity Index (DSI), defined as $\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})}$, where $\\theta_{\\mathrm{pref}}$ is the direction eliciting the maximum response and $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$. The derivation must proceed from first principles.\n\nFirst, we simplify the expression for the firing rate $R(\\theta)$. The sum of a cosine and a sine term can be expressed as a single phase-shifted cosine function using the harmonic addition theorem. Let the variable part of the rate function be $f(\\theta) = B\\cos(\\theta - \\theta_0) + C\\sin(\\theta - \\theta_0)$.\nWe can write this in the form $M\\cos(\\theta - \\theta_0 - \\delta)$, where $M$ is the amplitude and $\\delta$ is a phase shift.\nExpanding $M\\cos(\\theta - \\theta_0 - \\delta)$ gives:\n$M\\cos(\\theta - \\theta_0 - \\delta) = M[\\cos(\\theta - \\theta_0)\\cos(\\delta) + \\sin(\\theta - \\theta_0)\\sin(\\delta)]$\n$= (M\\cos\\delta)\\cos(\\theta - \\theta_0) + (M\\sin\\delta)\\sin(\\theta - \\theta_0)$.\nBy comparing coefficients with $f(\\theta)$, we must have:\n$B = M\\cos(\\delta)$\n$C = M\\sin(\\delta)$\nTo find the amplitude $M$, we square and add these two equations:\n$B^2 + C^2 = (M\\cos\\delta)^2 + (M\\sin\\delta)^2 = M^2(\\cos^2\\delta + \\sin^2\\delta) = M^2$.\nThus, the amplitude of the modulation is $M = \\sqrt{B^2 + C^2}$. Since $B$ and $C$ are real, $M$ is real and non-negative.\nThe phase shift $\\delta$ is determined by $\\tan(\\delta) = \\frac{M\\sin\\delta}{M\\cos\\delta} = \\frac{C}{B}$. The specific quadrant for $\\delta$ is determined by the signs of $B$ and $C$.\nThe firing rate function can now be written in a more compact form:\n$R(\\theta) = A + M\\cos(\\theta - \\theta_0 - \\delta)$.\n\nThe preferred direction, $\\theta_{\\mathrm{pref}}$, is the direction $\\theta$ that maximizes $R(\\theta)$. The function $R(\\theta)$ is maximal when the term $\\cos(\\theta - \\theta_0 - \\delta)$ is maximal, which occurs when its value is $1$.\n$\\cos(\\theta_{\\mathrm{pref}} - \\theta_0 - \\delta) = 1$.\nThis condition is met when the argument of the cosine is an integer multiple of $2\\pi$, i.e., $\\theta_{\\mathrm{pref}} - \\theta_0 - \\delta = 2k\\pi$ for an integer $k$. We can select the principal angle by setting $k=0$, which yields:\n$\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$.\nAt this preferred direction, the maximum firing rate is:\n$R(\\theta_{\\mathrm{pref}}) = A + M\\cos(0) = A + M = A + \\sqrt{B^2 + C^2}$.\n\nThe null direction is defined as $\\theta_{\\mathrm{null}} = \\theta_{\\mathrm{pref}} + \\pi$. The firing rate at the null direction is:\n$R(\\theta_{\\mathrm{null}}) = R(\\theta_{\\mathrm{pref}} + \\pi) = A + M\\cos(\\theta_{\\mathrm{pref}} + \\pi - \\theta_0 - \\delta)$.\nSubstituting $\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$, the argument of the cosine becomes $(\\theta_0 + \\delta) + \\pi - \\theta_0 - \\delta = \\pi$.\nTherefore, the firing rate at the null direction is:\n$R(\\theta_{\\mathrm{null}}) = A + M\\cos(\\pi) = A - M = A - \\sqrt{B^2 + C^2}$.\nThe problem states that $A > 0$ and $\\sqrt{B^2 + C^2}  A$, which ensures that $R(\\theta)$ is always positive, a necessary condition for a firing rate.\n\nNow we can substitute the expressions for $R(\\theta_{\\mathrm{pref}})$ and $R(\\theta_{\\mathrm{null}})$ into the definition of the DSI:\n$\\mathrm{DSI} = \\frac{R(\\theta_{\\mathrm{pref}}) - R(\\theta_{\\mathrm{null}})}{R(\\theta_{\\mathrm{pref}}) + R(\\theta_{\\mathrm{null}})} = \\frac{(A + M) - (A - M)}{(A + M) + (A - M)}$.\nSimplifying the numerator and denominator:\n$\\mathrm{DSI} = \\frac{2M}{2A} = \\frac{M}{A}$.\nSubstituting back the expression for $M$:\n$\\mathrm{DSI} = \\frac{\\sqrt{B^2 + C^2}}{A}$.\nThis is the closed-form expression for the Direction Selectivity Index in terms of the parameters $A$, $B$, and $C$.\n\nFinally, we analyze the influence of the odd term, $C\\sin(\\theta - \\theta_0)$, on direction selectivity. This is equivalent to analyzing the influence of the parameter $C$.\n1.  **Influence on the magnitude of the DSI**: The magnitude is given by $\\mathrm{DSI} = \\frac{\\sqrt{B^2 + C^2}}{A}$. The term $C^2$ appears under the square root in the numerator. For any non-zero value of $C$, $C^2 > 0$, which increases the value of the numerator $\\sqrt{B^2+C^2}$ compared to the case where $C=0$. Therefore, the term $C\\sin(\\theta - \\theta_0)$ directly influences and, for $C \\neq 0$, increases the magnitude of the DSI.\n2.  **Influence on the preferred direction**: The preferred direction is given by $\\theta_{\\mathrm{pref}} = \\theta_0 + \\delta$, where the phase shift $\\delta$ is determined by $\\tan(\\delta) = C/B$. If $C=0$ (and assuming $B > 0$), then $\\tan(\\delta) = 0$, which implies $\\delta = 0$. In this case, $\\theta_{\\mathrm{pref}} = \\theta_0$. However, if $C \\neq 0$, then $\\tan(\\delta) \\neq 0$, which implies $\\delta \\neq 0$. This means the preferred direction $\\theta_{\\mathrm{pref}}$ is shifted away from the reference direction $\\theta_0$. Thus, the term $C\\sin(\\theta - \\theta_0)$ changes the preferred direction.\n\nIn conclusion, the presence of the odd sinusoidal term, characterized by the coefficient $C$, influences **both** the magnitude of the Direction Selectivity Index and the preferred direction of the neuron.",
            "answer": "$$\\boxed{\\frac{\\sqrt{B^{2} + C^{2}}}{A}}$$"
        },
        {
            "introduction": "While analytical models provide a clean theoretical picture, real neural responses are shaped by biophysical constraints. Neurons exhibit spontaneous firing even without a stimulus, and their firing rates cannot be negativeâ€”a nonlinearity known as rectification. This practice problem offers a concrete, calculation-based exploration of how these factors influence the measurement of selectivity . By comparing the raw DSI to a baseline-corrected version, you will see firsthand how an uncorrected measure can misrepresent the underlying stimulus-driven selectivity, underscoring a critical principle in neural data analysis.",
            "id": "3999440",
            "problem": "In models of direction selectivity in visual cortex, an oriented motion stimulus elicits a firing rate that can be represented by a linear direction-tuned component added to a spontaneous baseline and then passed through a biophysical nonlinearity that enforces non-negativity. Specifically, suppose the instantaneous firing rate under motion in the preferred direction and the null direction are, respectively, $R_{\\mathrm{pref}}$ and $R_{\\mathrm{null}}$, measured in $\\text{spikes/s}$. The spontaneous baseline (spontaneous rate) is $r_0$. The half-wave rectifier is modeled by $[x]_+ = \\max(0,x)$, consistent with the non-negativity of firing rates.\n\nThe Direction Selectivity Index (DSI) is defined from two direction-specific responses as $$\\mathrm{DSI} = \\frac{R_{\\mathrm{pref}} - R_{\\mathrm{null}}}{R_{\\mathrm{pref}} + R_{\\mathrm{null}}}$$. Baseline firing and rectification can bias this index because they elevate both $R_{\\mathrm{pref}}$ and $R_{\\mathrm{null}}$ and can prevent negative values after subtracting $r_0$.\n\nUsing the following scientifically plausible measurements:\n- $R_{\\mathrm{pref}} = 38\\ \\text{spikes/s}$,\n- $R_{\\mathrm{null}} = 12\\ \\text{spikes/s}$,\n- $r_0 = 10\\ \\text{spikes/s}$,\n\ncompute:\n1. The raw Direction Selectivity Index, $\\mathrm{DSI}_{\\mathrm{raw}}$, using $R_{\\mathrm{pref}}$ and $R_{\\mathrm{null}}$ directly.\n2. The baseline-corrected Direction Selectivity Index, $\\mathrm{DSI}_{\\mathrm{corr}}$, obtained by first subtracting $r_0$ from each measured rate, half-wave rectifying the result, and then forming the same index from the baseline-subtracted rectified responses.\n\nExpress both $\\mathrm{DSI}_{\\mathrm{raw}}$ and $\\mathrm{DSI}_{\\mathrm{corr}}$ as unitless decimals, rounding each to four significant figures. Report both values in the order $\\mathrm{DSI}_{\\mathrm{raw}}$, $\\mathrm{DSI}_{\\mathrm{corr}}$.",
            "solution": "This problem requires calculating the Direction Selectivity Index (DSI) in two ways: once using the raw firing rates and once using rates that have been corrected for baseline spontaneous activity.\n\n**1. Raw DSI Calculation ($\\mathrm{DSI}_{\\mathrm{raw}}$)**\n\nThe raw DSI is computed directly from the measured firing rates $R_{\\mathrm{pref}} = 38\\ \\text{spikes/s}$ and $R_{\\mathrm{null}} = 12\\ \\text{spikes/s}$ using the standard formula:\n$$\\mathrm{DSI}_{\\mathrm{raw}} = \\frac{R_{\\mathrm{pref}} - R_{\\mathrm{null}}}{R_{\\mathrm{pref}} + R_{\\mathrm{null}}} = \\frac{38 - 12}{38 + 12} = \\frac{26}{50} = 0.52$$\nRounded to four significant figures, this is $0.5200$.\n\n**2. Baseline-Corrected DSI Calculation ($\\mathrm{DSI}_{\\mathrm{corr}}$)**\n\nTo compute the corrected DSI, we first determine the stimulus-driven responses by subtracting the spontaneous rate $r_0 = 10\\ \\text{spikes/s}$ from the measured rates and applying half-wave rectification ($[x]_+ = \\max(0,x)$).\n\nThe corrected response in the preferred direction is:\n$$R'_{\\mathrm{pref}} = [R_{\\mathrm{pref}} - r_0]_+ = [38 - 10]_+ = [28]_+ = 28\\ \\text{spikes/s}$$\n\nThe corrected response in the null direction is:\n$$R'_{\\mathrm{null}} = [R_{\\mathrm{null}} - r_0]_+ = [12 - 10]_+ = [2]_+ = 2\\ \\text{spikes/s}$$\n\nNow, we compute the DSI using these corrected responses:\n$$\\mathrm{DSI}_{\\mathrm{corr}} = \\frac{R'_{\\mathrm{pref}} - R'_{\\mathrm{null}}}{R'_{\\mathrm{pref}} + R'_{\\mathrm{null}}} = \\frac{28 - 2}{28 + 2} = \\frac{26}{30} \\approx 0.86666...$$\nRounded to four significant figures, this is $0.8667$.\n\nThe results demonstrate that accounting for the baseline firing rate reveals a higher underlying selectivity of the neuron to the motion stimulus. The final reported values are $0.5200$ and $0.8667$.",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.5200  0.8667 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving beyond description and measurement, the ultimate goal is to understand the mechanisms that generate neural computations. This advanced practice guides you through the process of building a biophysically-inspired, computational model of a Direction-Selective Ganglion Cell (DSGC) in the retina . You will implement a model that incorporates key biological features, including excitatory and inhibitory spatiotemporal dynamics and the space-dependent delays of Starburst Amacrine Cell inputs. This simulation provides invaluable hands-on experience in translating circuit architecture into a functional model, allowing you to manipulate parameters and directly observe how they shape the emergent property of direction selectivity.",
            "id": "3999419",
            "problem": "Consider a simplified, mechanistic model of Direction-Selective Ganglion Cell (DSGC) responses driven by a moving luminance spot, where direction selectivity arises from the interplay of excitatory bipolar input and inhibitory input from Starburst Amacrine Cells (SACs). The retina is modeled as a two-dimensional spatial domain with the DSGC located at the origin. A stimulus spot moves at a constant speed along a straight path at a direction angle specified in degrees.\n\nThe stimulus intensity is defined by the spatial-temporal function\n$$\nS(\\mathbf{r}, t) = A \\exp\\left( -\\frac{\\|\\mathbf{r} - \\mathbf{s}(t)\\|^2}{2\\sigma_s^2} \\right),\n$$\nwhere $\\mathbf{r} = (x, y)$ is the spatial position in degrees of visual angle, $t$ is time in seconds, $A$ is the stimulus amplitude, $\\sigma_s$ is the spatial standard deviation of the spot in degrees, and $\\mathbf{s}(t) = \\mathbf{r}_0 + v t \\mathbf{u}(\\varphi)$ is the center of the moving spot with initial position $\\mathbf{r}_0 = -L \\mathbf{u}(\\varphi)$, speed $v$ in degrees per second, and unit direction vector $\\mathbf{u}(\\varphi) = (\\cos\\varphi, \\sin\\varphi)$, with $\\varphi$ specified in degrees.\n\nThe DSGC excitatory drive is modeled as linear spatial weighting followed by a causal temporal low-pass filter. The spatial weight is\n$$\nW_e(\\mathbf{r}) = \\exp\\left( -\\frac{\\|\\mathbf{r}\\|^2}{2\\sigma_e^2} \\right),\n$$\nand the excitatory temporal kernel is\n$$\nk_e(t) = H(t)\\frac{1}{\\tau_e} \\exp\\left( -\\frac{t}{\\tau_e} \\right),\n$$\nwhere $H(t)$ is the Heaviside step function, $\\tau_e$ is the excitatory time constant in seconds, and $\\sigma_e$ is the excitatory spatial standard deviation in degrees. The excitatory current is\n$$\nE(t) = \\left( \\iint W_e(\\mathbf{r}) S(\\mathbf{r}, t) \\, d\\mathbf{r} \\right) * k_e(t),\n$$\nwhere $*$ denotes convolution in time.\n\nThe SAC-mediated inhibition is modeled by a direction-gated spatial weighting with dendritic delay and a causal temporal kernel. Define the unit radial vector\n$$\n\\hat{\\mathbf{r}} = \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|},\n$$\nfor $\\mathbf{r} \\neq \\mathbf{0}$. Let a mild azimuthal anisotropy modulate the inhibitory weight, with bias angle $\\theta_{\\text{bias}}$ and modulation depth $\\eta$:\n$$\nM(\\mathbf{r}) = 1 + \\eta \\cos(\\theta(\\mathbf{r}) - \\theta_{\\text{bias}}), \\quad \\theta(\\mathbf{r}) = \\operatorname{atan2}(y, x),\n$$\nand let the centrifugal gating be\n$$\nG(\\mathbf{r}, \\varphi) = H\\left( \\mathbf{u}(\\varphi) \\cdot \\hat{\\mathbf{r}} \\right).\n$$\nThe inhibitory spatial weight is\n$$\nW_i(\\mathbf{r}, \\varphi) = \\exp\\left( -\\frac{\\|\\mathbf{r}\\|}{\\lambda} \\right) M(\\mathbf{r}) G(\\mathbf{r}, \\varphi),\n$$\nwith spatial falloff constant $\\lambda$ in degrees. The SAC dendritic delay is\n$$\n\\tau_d(\\mathbf{r}) = \\tau_{\\text{sac0}} + d \\, \\|\\mathbf{r}\\|,\n$$\nwhere $\\tau_{\\text{sac0}}$ is a base delay in seconds and $d$ is a delay-per-distance parameter in seconds per degree. The inhibitory temporal kernel is\n$$\nk_i(t) = H(t)\\frac{1}{\\tau_i} \\exp\\left( -\\frac{t}{\\tau_i} \\right),\n$$\nwith inhibitory time constant $\\tau_i$ in seconds. The raw inhibitory drive (before filtering) is the delayed spatial integration\n$$\nI_{\\text{raw}}(t; \\varphi) = \\iint W_i(\\mathbf{r}, \\varphi) S(\\mathbf{r}, t - \\tau_d(\\mathbf{r})) \\, d\\mathbf{r},\n$$\nand the filtered inhibitory current is\n$$\nI(t; \\varphi) = I_{\\text{raw}}(\\cdot; \\varphi) * k_i(t).\n$$\n\nThe net synaptic drive is modeled as\n$$\ng(t; \\varphi) = E(t) - g_i I(t; \\varphi),\n$$\nwith inhibitory gain $g_i$ (dimensionless), and the response proxy for direction $\\varphi$ is taken as the half-wave-rectified integral\n$$\nR(\\varphi) = \\int_{0}^{T_{\\text{end}}} \\max\\{0, g(t; \\varphi)\\} \\, dt,\n$$\nover a fixed simulation window $[0, T_{\\text{end}}]$.\n\nDefine the preferred direction (PD) as the angle $\\varphi$ (in degrees) that maximizes $R(\\varphi)$ over a discrete set of directions. Let the discrete set be\n$$\n\\Phi = \\{0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330\\}.\n$$\n\nYour task is to implement a program that computes $R(\\varphi)$ for each $\\varphi \\in \\Phi$ for a baseline parameter set and for three altered parameter sets that change Starburst Amacrine Cell (SAC) kinetics, then extracts the preferred direction for each set and quantifies the shift in preferred direction caused by each alteration relative to the baseline.\n\nUse the following fixed constants across all test cases unless otherwise specified:\n- $A = 1.0$ (unitless intensity),\n- $\\sigma_s = 0.1$ degrees,\n- $\\sigma_e = 0.2$ degrees,\n- $\\tau_e = 0.010$ seconds,\n- $\\tau_i = 0.020$ seconds,\n- $g_i = 1.2$ (dimensionless),\n- $v = 5.0$ degrees per second,\n- $L = 0.8$ degrees,\n- $\\eta = 0.2$ (dimensionless),\n- $\\theta_{\\text{bias}} = 60$ degrees,\n- $T_{\\text{end}} = 0.5$ seconds,\n- spatial domain is a square grid spanning $[-1.5, 1.5]$ degrees in both coordinates with uniform spacing $0.05$ degrees,\n- time step is $\\Delta t = 0.001$ seconds.\n\nThe baseline parameter set is:\n- $\\tau_{\\text{sac0}} = 0.030$ seconds,\n- $d = 0.010$ seconds per degree,\n- $\\lambda = 0.50$ degrees.\n\nThe three altered parameter sets are:\n1. Slower base SAC delay: $\\tau_{\\text{sac0}} = 0.060$ seconds, $d = 0.010$ seconds per degree, $\\lambda = 0.50$ degrees.\n2. Stronger dendritic delay scaling: $\\tau_{\\text{sac0}} = 0.030$ seconds, $d = 0.025$ seconds per degree, $\\lambda = 0.50$ degrees.\n3. Tighter inhibitory spatial falloff: $\\tau_{\\text{sac0}} = 0.030$ seconds, $d = 0.010$ seconds per degree, $\\lambda = 0.25$ degrees.\n\nYou must:\n- Compute $R(\\varphi)$ for all $\\varphi \\in \\Phi$ for the baseline and each altered set.\n- Determine the preferred direction angle for the baseline, denoted $\\varphi_{\\text{PD,base}}$ in degrees.\n- Determine the preferred direction angle for each altered set, denoted $\\varphi_{\\text{PD,case}k}$ for $k \\in \\{1,2,3\\}$ in degrees.\n- Quantify the angular shift $\\Delta_k$ in degrees for each case $k$ as the minimal absolute difference on the circle between $\\varphi_{\\text{PD,case}k}$ and $\\varphi_{\\text{PD,base}}$, that is\n$$\n\\Delta_k = \\min_{m \\in \\mathbb{Z}} \\left| \\varphi_{\\text{PD,case}k} - \\varphi_{\\text{PD,base}} + 360 m \\right|,\n$$\nrestricted to the interval $[0, 180]$ degrees.\n\nAll angles in the program must be treated and reported in degrees. Time must be treated in seconds. Distances must be treated in degrees of visual angle.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the following order and types:\n- $\\varphi_{\\text{PD,base}}$ as a float in degrees,\n- $\\Delta_1$ as a float in degrees,\n- $\\Delta_2$ as a float in degrees,\n- $\\Delta_3$ as a float in degrees.\n\nFor example, the output format must be exactly like\n$$\n[\\text{baseline\\_PD}, \\text{shift\\_case1}, \\text{shift\\_case2}, \\text{shift\\_case3}],\n$$\nwith each entry a float.\n\nTest Suite:\n- Baseline: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.010$, $\\lambda = 0.50$.\n- Case 1: $\\tau_{\\text{sac0}} = 0.060$, $d = 0.010$, $\\lambda = 0.50$.\n- Case 2: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.025$, $\\lambda = 0.50$.\n- Case 3: $\\tau_{\\text{sac0}} = 0.030$, $d = 0.010$, $\\lambda = 0.25$.\n\nYour solution must be a complete, runnable program that performs these computations numerically via discretization and prints the final line exactly as specified. No user input is needed.",
            "solution": "The provided Python script implements a numerical simulation of the Direction-Selective Ganglion Cell (DSGC) model described in the problem statement. The solution follows these key steps:\n\n1.  **Grid and Parameter Setup**: The script begins by defining all fixed constants (e.g., stimulus properties, neural time constants) and numerical parameters (spatial and temporal step sizes). It then initializes the spatial grid (`X`, `Y`) and time vector (`t_coords`) for the simulation.\n\n2.  **Iterative Simulation**: The main part of the program consists of nested loops. The outer loop iterates through the four specified parameter sets (baseline, case 1, case 2, case 3). The inner loop iterates through the 12 stimulus directions (`phi_deg` from 0 to 330 degrees).\n\n3.  **Stimulus and Pathway Computation**: For each direction `phi_deg` within each parameter set:\n    *   A \"movie\" of the moving Gaussian spot, `S_movie`, is pre-computed over the spatial and temporal grids.\n    *   The **excitatory current** `E_t` is calculated by first performing a weighted spatial sum of the stimulus at each time step, then convolving the resulting time series with the excitatory temporal kernel `kernel_e`.\n    *   The **inhibitory current** `I_t` is calculated in a more complex manner. First, the direction-dependent inhibitory weight `W_i` and the space-dependent dendritic delays `tau_d_grid` are computed. Then, for each time step, the raw inhibitory drive `I_raw_t` is found by integrating the stimulus at past, spatially-dependent times. This requires temporal interpolation of the `S_movie` for each point on the spatial grid. Finally, `I_raw_t` is convolved with the inhibitory kernel `kernel_i`.\n    \n4.  **Response and Preferred Direction**:\n    *   The net synaptic drive `g_t` is computed by subtracting the weighted inhibitory current from the excitatory current.\n    *   The total response `R_phi` for the direction `phi_deg` is calculated by integrating the half-wave rectified net drive over time.\n    *   After looping through all 12 directions, the preferred direction (PD) for the current parameter set is identified as the angle that yielded the maximum total response.\n\n5.  **Final Analysis and Output**: After running all four parameter sets, the script calculates the angular shift of the PD for each of the three altered cases relative to the baseline PD. The final result, containing the baseline PD and the three shifts, is printed to the console in the specified format. The code uses `numpy` for efficient array operations, which is crucial for handling the multi-dimensional computations.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the preferred direction (PD) of a model DSGC for a baseline and three\n    altered parameter sets, and calculates the shift in PD for each alteration.\n    \"\"\"\n\n    # --- Fixed constants and numerical parameters ---\n    A = 1.0  # Stimulus amplitude\n    SIGMA_S = 0.1  # Stimulus spatial std dev (deg)\n    SIGMA_E = 0.2  # Excitatory spatial std dev (deg)\n    TAU_E = 0.010  # Excitatory time constant (s)\n    TAU_I = 0.020  # Inhibitory time constant (s)\n    G_I = 1.2  # Inhibitory gain\n    V = 5.0  # Stimulus speed (deg/s)\n    L = 0.8  # Stimulus path start distance (deg)\n    ETA = 0.2  # Inhibitory modulation depth\n    THETA_BIAS_DEG = 60.0  # Inhibitory bias angle (deg)\n    T_END = 0.5  # Simulation end time (s)\n\n    # Discretization parameters\n    DX = 0.05  # Spatial step (deg)\n    DT = 0.001  # Time step (s)\n    \n    # Set of directions to test\n    PHI_DIRECTIONS = np.array([0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330], dtype=float)\n\n    # --- Parameter sets for the four cases ---\n    param_sets = [\n        # Baseline\n        {'tau_sac0': 0.030, 'd': 0.010, 'lambda': 0.50},\n        # Case 1: Slower base SAC delay\n        {'tau_sac0': 0.060, 'd': 0.010, 'lambda': 0.50},\n        # Case 2: Stronger dendritic delay scaling\n        {'tau_sac0': 0.030, 'd': 0.025, 'lambda': 0.50},\n        # Case 3: Tighter inhibitory spatial falloff\n        {'tau_sac0': 0.030, 'd': 0.010, 'lambda': 0.25},\n    ]\n\n    # --- Set up grids (do once to save computation) ---\n    x_coords = np.arange(-1.5, 1.5 + DX / 2, DX)\n    y_coords = np.arange(-1.5, 1.5 + DX / 2, DX)\n    t_coords = np.arange(0, T_END + DT / 2, DT)\n    \n    X, Y = np.meshgrid(x_coords, y_coords)\n    R = np.sqrt(X**2 + Y**2)\n    Theta = np.arctan2(Y, X) # atan2(y,x)\n    y_indices, x_indices = np.indices(X.shape)\n    \n    # Pre-compute static components\n    W_e = np.exp(-(R**2) / (2 * SIGMA_E**2))\n    \n    # Temporal kernels\n    kernel_e = (1 / TAU_E) * np.exp(-t_coords / TAU_E)\n    kernel_i = (1 / TAU_I) * np.exp(-t_coords / TAU_I)\n    \n    preferred_directions = []\n\n    for params in param_sets:\n        tau_sac0 = params['tau_sac0']\n        d_delay = params['d']\n        lambda_falloff = params['lambda']\n\n        responses = []\n        for phi_deg in PHI_DIRECTIONS:\n            phi_rad = np.deg2rad(phi_deg)\n            u = np.array([np.cos(phi_rad), np.sin(phi_rad)])\n\n            # --- Calculate Stimulus Movie S(t, y, x) ---\n            s_0 = -L * u\n            s_t = s_0[:, np.newaxis] + V * t_coords * u[:, np.newaxis] # Shape (2, N_t)\n            \n            # Use broadcasting for efficiency\n            dist_sq = (X[np.newaxis, :, :] - s_t[0, :, np.newaxis, np.newaxis])**2 + \\\n                      (Y[np.newaxis, :, :] - s_t[1, :, np.newaxis, np.newaxis])**2\n            \n            S_movie = A * np.exp(-dist_sq / (2 * SIGMA_S**2))\n\n            # --- Excitatory Pathway E(t) ---\n            Ie_t = np.sum(W_e * S_movie, axis=(1, 2)) * DX * DX\n            E_t = np.convolve(Ie_t, kernel_e, 'full')[:len(t_coords)] * DT\n\n            # --- Inhibitory Pathway I(t) ---\n            tau_d_grid = tau_sac0 + d_delay * R\n            \n            theta_bias_rad = np.deg2rad(THETA_BIAS_DEG)\n            M = 1 + ETA * np.cos(Theta - theta_bias_rad)\n            \n            dot_prod_over_R = np.divide(u[0] * X + u[1] * Y, R, out=np.zeros_like(R), where=R != 0)\n            G = np.heaviside(dot_prod_over_R, 0)\n            \n            W_i = np.exp(-R / lambda_falloff) * M * G\n\n            # Calculate I_raw(t) with time-delay interpolation\n            I_raw_t = np.zeros_like(t_coords)\n            for k, t_k in enumerate(t_coords):\n                delayed_times = t_k - tau_d_grid\n                delayed_indices_float = delayed_times / DT\n                \n                idx0 = np.floor(delayed_indices_float).astype(int)\n                idx1 = idx0 + 1\n                \n                # Interpolation weights\n                w1 = delayed_indices_float - idx0\n                w0 = 1.0 - w1\n                \n                # Clip indices to be within bounds of S_movie\n                np.clip(idx0, 0, len(t_coords) - 1, out=idx0)\n                np.clip(idx1, 0, len(t_coords) - 1, out=idx1)\n\n                # Advanced indexing to gather values for interpolation\n                S0 = S_movie[idx0, y_indices, x_indices]\n                S1 = S_movie[idx1, y_indices, x_indices]\n                \n                S_interp_k = S0 * w0 + S1 * w1\n                I_raw_t[k] = np.sum(W_i * S_interp_k * DX * DX)\n                \n            I_t = np.convolve(I_raw_t, kernel_i, 'full')[:len(t_coords)] * DT\n\n            # --- Net Drive and Response ---\n            g_t = E_t - G_I * I_t\n            R_phi = np.sum(np.maximum(0, g_t)) * DT\n            responses.append(R_phi)\n\n        pd_index = np.argmax(responses)\n        preferred_directions.append(PHI_DIRECTIONS[pd_index])\n\n    # --- Final Analysis ---\n    pd_base = preferred_directions[0]\n    pd_cases = preferred_directions[1:]\n    \n    shifts = []\n    for pd_case in pd_cases:\n        diff = np.abs(pd_case - pd_base)\n        shift = min(diff, 360.0 - diff)\n        shifts.append(shift)\n\n    results = [pd_base] + shifts\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, [float(r) for r in results]))}]\")\n\nsolve()\n\n```"
        }
    ]
}