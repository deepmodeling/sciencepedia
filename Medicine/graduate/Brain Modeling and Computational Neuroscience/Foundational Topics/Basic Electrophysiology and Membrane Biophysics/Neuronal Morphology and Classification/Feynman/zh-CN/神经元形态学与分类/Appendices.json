{
    "hands_on_practices": [
        {
            "introduction": "神经元形态的量化分析始于对其基本几何特征的测量。迂曲度（tortuosity），定义为路径长度 $\\ell$ 与端点间直线距离 $d$ 之比，即 $\\tau=\\ell/d$，是描述神经纤维（如轴突）弯曲程度的一个基本指标。这项实践将引导你根据原始测量数据计算迂曲度，并利用它对轴突段进行分类，这是理解信号传导路径和发育过程中的一个重要技能 。",
            "id": "4004783",
            "problem": "轴突几何学的一个核心形态计量学指标是曲折度，它由曲线几何学的基本原理和三角不等式定义。考虑一个由空间曲线表示的轴突段，其总路径长度为 $\\ell$，端到端欧几里得距离为 $d$。曲折度定义为无量纲比值 $\\tau=\\ell/d$。因为两点之间任意曲线的长度至少等于它们之间的直线距离，所以根据三角不等式，有 $\\ell \\ge d$，因此 $\\tau \\ge 1$。这个无量纲特性在均匀空间缩放下是不变的，因此适合用于比较不同大小的轴突。\n\n给定 $N=7$ 个轴突段的测量值，每个轴突段的总路径长度 $\\ell$ 和端到端距离 $d$ 的单位均为微米 ($\\mu\\mathrm{m}$):\n- 轴突段 1: $\\ell=820\\,\\mu\\mathrm{m}$， $d=800\\,\\mu\\mathrm{m}$。\n- 轴突段 2: $\\ell=1200\\,\\mu\\mathrm{m}$， $d=900\\,\\mu\\mathrm{m}$。\n- 轴突段 3: $\\ell=450\\,\\mu\\mathrm{m}$， $d=440\\,\\mu\\mathrm{m}$。\n- 轴突段 4: $\\ell=2000\\,\\mu\\mathrm{m}$， $d=1500\\,\\mu\\mathrm{m}$。\n- 轴突段 5: $\\ell=600\\,\\mu\\mathrm{m}$， $d=590\\,\\mu\\mathrm{m}$。\n- 轴突段 6: $\\ell=1300\\,\\mu\\mathrm{m}$， $d=1000\\,\\mu\\mathrm{m}$。\n- 轴突段 7: $\\ell=950\\,\\mu\\mathrm{m}$， $d=900\\,\\mu\\mathrm{m}$。\n\n使用曲折度定义 $\\tau=\\ell/d$ 计算每个轴突段的 $\\tau$ 值，如果 $\\tau > \\tau_{\\mathrm{th}}$ 则将其分类为蜿蜒段，否则为平直段，其中阈值为 $\\tau_{\\mathrm{th}}=1.2$。根据这些分类，计算蜿蜒轴突段总路径长度的长度加权分数，该分数定义为被分类为蜿蜒段的轴突段贡献的总 $\\ell$ 与所有轴突段的总 $\\ell$ 的比值。将最终结果表示为小数（无单位），并四舍五入到 $4$ 位有效数字。",
            "solution": "该问题要求计算被分类为蜿蜒段的轴突总路径长度的长度加权分数。分析过程分三个阶段：首先，计算每个轴突段的曲折度；其次，根据给定阈值对每个轴突段进行分类；第三，根据分类后的轴突段计算所需的分数。\n\n曲折度 $\\tau$ 定义为总路径长度 $\\ell$ 与端到端欧几里得距离 $d$ 的比值：\n$$\n\\tau = \\frac{\\ell}{d}\n$$\n给定 $N=7$ 个轴突段的数据，索引为 $i \\in \\{1, 2, 3, 4, 5, 6, 7\\}$。对于每个轴突段 $i$，我们有一对测量值 $(\\ell_i, d_i)$。\n\n所提供的数据如下：\n- 轴突段 1: $\\ell_1=820\\,\\mu\\mathrm{m}$， $d_1=800\\,\\mu\\mathrm{m}$\n- 轴突段 2: $\\ell_2=1200\\,\\mu\\mathrm{m}$， $d_2=900\\,\\mu\\mathrm{m}$\n- 轴突段 3: $\\ell_3=450\\,\\mu\\mathrm{m}$， $d_3=440\\,\\mu\\mathrm{m}$\n- 轴突段 4: $\\ell_4=2000\\,\\mu\\mathrm{m}$， $d_4=1500\\,\\mu\\mathrm{m}$\n- 轴突段 5: $\\ell_5=600\\,\\mu\\mathrm{m}$， $d_5=590\\,\\mu\\mathrm{m}$\n- 轴突段 6: $\\ell_6=1300\\,\\mu\\mathrm{m}$， $d_6=1000\\,\\mu\\mathrm{m}$\n- 轴突段 7: $\\ell_7=950\\,\\mu\\mathrm{m}$， $d_7=900\\,\\mu\\mathrm{m}$\n\n首先，我们计算每个轴突段 $i$ 的曲折度 $\\tau_i$：\n$$\n\\tau_1 = \\frac{\\ell_1}{d_1} = \\frac{820}{800} = 1.025\n$$\n$$\n\\tau_2 = \\frac{\\ell_2}{d_2} = \\frac{1200}{900} = \\frac{4}{3} \\approx 1.333...\n$$\n$$\n\\tau_3 = \\frac{\\ell_3}{d_3} = \\frac{450}{440} = \\frac{45}{44} \\approx 1.0227...\n$$\n$$\n\\tau_4 = \\frac{\\ell_4}{d_4} = \\frac{2000}{1500} = \\frac{4}{3} \\approx 1.333...\n$$\n$$\n\\tau_5 = \\frac{\\ell_5}{d_5} = \\frac{600}{590} = \\frac{60}{59} \\approx 1.0169...\n$$\n$$\n\\tau_6 = \\frac{\\ell_6}{d_6} = \\frac{1300}{1000} = 1.3\n$$\n$$\n\\tau_7 = \\frac{\\ell_7}{d_7} = \\frac{950}{900} = \\frac{19}{18} \\approx 1.055...\n$$\n\n接下来，我们根据每个轴突段的曲折度 $\\tau_i$ 是否大于阈值 $\\tau_{\\mathrm{th}} = 1.2$ 将其分类为“蜿蜒段”或“平直段”。\n- 轴突段 1：$\\tau_1 = 1.025 \\le 1.2 \\implies$ 平直段\n- 轴突段 2：$\\tau_2 \\approx 1.333... > 1.2 \\implies$ 蜿蜒段\n- 轴突段 3：$\\tau_3 \\approx 1.0227... \\le 1.2 \\implies$ 平直段\n- 轴突段 4：$\\tau_4 \\approx 1.333... > 1.2 \\implies$ 蜿蜒段\n- 轴突段 5：$\\tau_5 \\approx 1.0169... \\le 1.2 \\implies$ 平直段\n- 轴突段 6：$\\tau_6 = 1.3 > 1.2 \\implies$ 蜿蜒段\n- 轴突段 7：$\\tau_7 \\approx 1.055... \\le 1.2 \\implies$ 平直段\n\n对应于蜿蜒段的索引集合为 $M = \\{2, 4, 6\\}$。\n\n我们被要求计算蜿蜒轴突总路径长度的长度加权分数，我们将其表示为 $F$。这个分数是蜿蜒段的长度总和与所有轴突段的长度总和的比值。\n$$\nF = \\frac{\\sum_{i \\in M} \\ell_i}{\\sum_{i=1}^{7} \\ell_i}\n$$\n\n首先，我们计算蜿蜒段的总路径长度 $L_{\\mathrm{meander}}$：\n$$\nL_{\\mathrm{meander}} = \\ell_2 + \\ell_4 + \\ell_6 = 1200 + 2000 + 1300 = 4500\\,\\mu\\mathrm{m}\n$$\n\n接下来，我们计算所有轴突段的总路径长度 $L_{\\mathrm{total}}$：\n$$\nL_{\\mathrm{total}} = \\sum_{i=1}^{7} \\ell_i = 820 + 1200 + 450 + 2000 + 600 + 1300 + 950 = 7320\\,\\mu\\mathrm{m}\n$$\n\n最后，我们计算分数 $F$：\n$$\nF = \\frac{L_{\\mathrm{meander}}}{L_{\\mathrm{total}}} = \\frac{4500}{7320} = \\frac{450}{732} = \\frac{225}{366} = \\frac{75}{122}\n$$\n\n为了将其表示为小数，我们进行除法运算：\n$$\nF \\approx 0.614754098...\n$$\n\n问题要求结果四舍五入到 $4$ 位有效数字。第五位有效数字是 $5$，所以我们将第四位数字向上取整。\n$$\nF \\approx 0.6148\n$$",
            "answer": "$$\n\\boxed{0.6148}\n$$"
        },
        {
            "introduction": "超越纯粹的几何描述，神经元形态的许多特征都深刻地反映了其电生理功能。在树突分叉点，直径的匹配对于信号的有效传递至关重要，以避免信号反射造成的衰减。本练习将引导你从电缆理论的第一性原理出发，推导出著名的 Rall 氏 $3/2$ 次幂法则，该法则描述了为实现阻抗匹配，母枝与子枝直径之间必须满足的关系 。通过这一实践，你将深刻理解神经元形态与其电学特性之间的内在联系。",
            "id": "4508610",
            "problem": "在一个由电缆理论建模的无源树突树中，其比膜电阻率 $R_{m}$ 和胞内（轴向）电阻率 $R_{i}$ 在空间上是均匀的。可以从分叉点的阻抗匹配要求（从而使得在连接点处不发生反射，并且电紧张长度得以保持）推导出其形态测量约束。从单位长度轴向电阻和单位长度膜电阻的基本电缆定义出发，推导在树突分叉处，一个直径为 $d_{0}$ 的母分支与两个直径分别为 $d_{1}$ 和 $d_{2}$ 的子分支之间实现阻抗匹配所需的直径关系。假设每个分支在连接点附近局部可被视为半无限长，且膜特性是均匀的。\n\n给定一个在皮层锥体神经元顶树突上测得的特定分叉，其母分支直径 $d_{0} = 3.0\\,\\mu\\text{m}$，子分支直径分别为 $d_{1} = 2.5\\,\\mu\\text{m}$ 和 $d_{2} = 1.2\\,\\mu\\text{m}$。使用你推导出的关系，计算与精确阻抗匹配条件的绝对分数偏差，其定义为\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})},$$\n其中 $f(\\cdot)$ 是由你推导的阻抗匹配条件所隐含的与直径相关的量。将 $\\varepsilon$ 以小数形式报告（例如，对于百分之五的偏差，报告为 $0.05$）。将你的答案四舍五入到四位有效数字。在最终报告的值中不要包含任何单位或百分号。",
            "solution": "该问题要求推导在树突分叉处实现阻抗匹配的直径关系，并计算一个特定案例的分数偏差。\n\n### 第一部分：直径关系的推导\n\n问题是在应用于树突树的无源电缆理论的背景下提出的。我们已知比膜电阻率 $R_m$（单位为 $\\Omega \\cdot \\text{m}^2$）和比胞内（轴向）电阻率 $R_i$（单位为 $\\Omega \\cdot \\text{m}$）在空间上是均匀的。\n\n首先，我们必须定义直径为 $d$ 的圆柱形树突的相关电学特性。\n单位长度的轴向电阻 $r_a$ 是胞内电阻率 $R_i$ 除以横截面积 $A = \\pi (d/2)^2$。\n$$r_a = \\frac{R_i}{A} = \\frac{R_i}{\\pi (d/2)^2} = \\frac{4 R_i}{\\pi d^2}$$\n单位长度圆柱体的膜电阻 $r_m$ 是比膜电阻率 $R_m$ 除以圆柱体的周长 $\\pi d$。\n$$r_m = \\frac{R_m}{\\pi d}$$\n问题陈述，在分叉处的每个分支局部可被视为半无限电缆。对于半无限无源电缆，其直流或稳态输入电阻 $R_{in}$ 由电缆的特征电阻给出：\n$$R_{in} = \\sqrt{r_a r_m}$$\n将 $r_a$ 和 $r_m$ 关于直径 $d$ 的表达式代入：\n$$R_{in}(d) = \\sqrt{\\left(\\frac{4 R_i}{\\pi d^2}\\right) \\left(\\frac{R_m}{\\pi d}\\right)} = \\sqrt{\\frac{4 R_i R_m}{\\pi^2 d^3}} = \\frac{2}{\\pi} \\sqrt{\\frac{R_i R_m}{d^3}}$$\n在分叉点实现阻抗匹配的条件是没有反射。当母分支的输入电导等于子分支的输入电导之和时，即可实现此条件。输入电导 $G_{in}$ 是输入电阻的倒数，即 $G_{in} = 1/R_{in}$。\n$$G_{in}(d) = \\frac{1}{R_{in}(d)} = \\frac{\\pi}{2} \\sqrt{\\frac{d^3}{R_i R_m}}$$\n设母分支的直径为 $d_0$，两个子分支的直径分别为 $d_1$ 和 $d_2$。阻抗匹配条件是：\n$$G_{in}(d_0) = G_{in}(d_1) + G_{in}(d_2)$$\n代入 $G_{in}(d)$ 的表达式：\n$$\\frac{\\pi}{2} \\sqrt{\\frac{d_0^3}{R_i R_m}} = \\frac{\\pi}{2} \\sqrt{\\frac{d_1^3}{R_i R_m}} + \\frac{\\pi}{2} \\sqrt{\\frac{d_2^3}{R_i R_m}}$$\n由于问题陈述膜和胞内特性（$R_m$ 和 $R_i$）在整个树突树中是均匀的，常数项 $\\frac{\\pi}{2\\sqrt{R_i R_m}}$ 对所有项都是公共的，可以消去。这就得出了所需的直径关系：\n$$\\sqrt{d_0^3} = \\sqrt{d_1^3} + \\sqrt{d_2^3}$$\n这通常被称为 Rall 的 3/2 次幂法则，也可以写成：\n$$d_0^{3/2} = d_1^{3/2} + d_2^{3/2}$$\n\n### 第二部分：分数偏差的计算\n\n问题将与精确阻抗匹配条件的绝对分数偏差定义为：\n$$\\varepsilon \\equiv \\frac{\\left|\\,f(d_{1},d_{2}) - f(d_{0})\\,\\right|}{f(d_{0})}$$\n根据我们的推导，决定电导的、与直径相关的量 $f(\\cdot)$ 是 $d^{3/2}$。因此，$f(d_0) = d_0^{3/2}$，而来自子分支的组合贡献是 $f(d_1, d_2) = d_1^{3/2} + d_2^{3/2}$。$\\varepsilon$ 的公式变为：\n$$\\varepsilon = \\frac{\\left| (d_1^{3/2} + d_2^{3/2}) - d_0^{3/2} \\right|}{d_0^{3/2}} = \\left| \\frac{d_1^{3/2} + d_2^{3/2}}{d_0^{3/2}} - 1 \\right|$$\n对于一个特定的分叉，我们被给予了以下直径：\n$d_0 = 3.0\\,\\mu\\text{m}$\n$d_1 = 2.5\\,\\mu\\text{m}$\n$d_2 = 1.2\\,\\mu\\text{m}$\n\n微米（$\\mu\\text{m}$）的单位在比率中会相消，所以我们可以直接使用数值。\n首先，我们计算所需的各项：\n母分支的项为：\n$$f(d_0) = d_0^{3/2} = (3.0)^{3/2} \\approx 5.196152$$\n子分支的项为：\n$$d_1^{3/2} = (2.5)^{3/2} \\approx 3.952847$$\n$$d_2^{3/2} = (1.2)^{3/2} \\approx 1.314534$$\n子分支的和为：\n$$f(d_1, d_2) = d_1^{3/2} + d_2^{3/2} \\approx 3.952847 + 1.314534 = 5.267381$$\n现在，我们将这些值代入 $\\varepsilon$ 的表达式中：\n$$\\varepsilon = \\frac{\\left| 5.267381 - 5.196152 \\right|}{5.196152} = \\frac{0.071229}{5.196152} \\approx 0.01370798$$\n问题要求答案四舍五入到四位有效数字。\n$$\\varepsilon \\approx 0.01371$$\n对于给定的树突分叉，该值表示与理想阻抗匹配条件的绝对分数偏差约为 $1.371\\%$。",
            "answer": "$$\\boxed{0.01371}$$"
        },
        {
            "introduction": "在现代计算神经科学中，对神经元进行分类和建模通常依赖于从其复杂的三维结构中提取一组丰富的形态学特征。单一的度量标准往往不足以捕捉细胞类型的多样性。这项综合性实践将指导你编写一个计算程序，从一个神经元的数字重建数据中，提取出一个包含分支角度、路径长度、曲率和锥度等多维度信息的特征向量 。这个过程模拟了神经形态学分析的真实工作流程，是连接形态数据和细胞功能分类的关键一步。",
            "id": "4004748",
            "problem": "您将获得来自神经元重建的节点三维坐标，以及每个节点的父节点指针和半径。该重建在三维空间中定义了一个有根树，其中每个节点 $i$ 的位置为 $(x_i, y_i, z_i)$（单位：微米，$\\mu m$），半径为 $r_i$（单位：微米，$\\mu m$），父节点索引为 $p_i$，其中 $p_i = -1$ 表示根节点。假设该树在解剖学上是合理的：它是一个具有单一根节点的有向无环图，并且除根节点外的每个节点都有且仅有一个父节点。\n\n您的任务是根据第一性原理推导并实现一个适用于下游分类任务的形态学特征向量的计算。从基本的欧几里得几何和由多段线离散化的曲线定义出发，您必须构建以下特征：\n\n1. 分支角直方图：\n- 对于任何至少有两个子节点的节点 $b$，定义其子节点 $c$ 的出射段向量为 $\\mathbf{v}_c = \\mathbf{x}_c - \\mathbf{x}_b$，其中 $\\mathbf{x}_j = (x_j, y_j, z_j)$ 是节点 $j$ 的笛卡尔坐标。\n- 对于每对无序子节点 $(c_1, c_2)$，定义分支角\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\, \\|\\mathbf{v}_{c_2}\\|}\\right),\n$$\n其中 $\\theta$ 以弧度为单位。\n- 累积整个树中所有此类角度，并使用以下区间边界计算归一化直方图\n$$\nB_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi],\n$$\n解释为半开区间 $[b_k, b_{k+1})$，但最后一个区间为闭区间 $[b_6, b_7]$。直方图必须归一化，使其总和为 $1$。如果没有分叉角，直方图必须是一个长度为 $6$ 的零向量。\n\n2. 根到叶路径长度分布：\n- 将没有任何子节点的节点定义为叶节点。\n- 对于每个叶节点 $t$，定义从根节点到 $t$ 的唯一路径 $P(t)$ 及其长度\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|,\n$$\n其中 $\\|\\cdot\\|$ 是欧几里得范数，长度单位为微米 ($\\mu m$)。\n- 使用以下区间边界计算集合 $\\{L(t)\\}$ 的归一化直方图\n$$\nB_L = [0, 20, 40, 60, 80, 100],\n$$\n其半开区间的解释与之前相同，即 $[b_k, b_{k+1})$，但最后一个区间为 $[b_5, b_6]$。直方图的总和必须为 $1$。如果没有叶节点，直方图必须是一个长度为 $5$ 的零向量。\n\n3. 曲率估计：\n- 对于每个具有有序点 $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$ 的根到叶路径，通过以下离散公式估算内部点 $k = 1, \\dots, n-1$ 处的曲率\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)},\n$$\n其中 $\\kappa_k$ 的单位为弧度/微米。将所有路径的所有曲率样本聚合到一个集合 $\\{\\kappa_k\\}$ 中。定义平均曲率\n$$\n\\bar{\\kappa} = \\frac{1}{M}\\sum_{m=1}^{M} \\kappa_m\n$$\n和总体标准差\n$$\n\\sigma_{\\kappa} = \\sqrt{\\frac{1}{M}\\sum_{m=1}^{M} (\\kappa_m - \\bar{\\kappa})^2},\n$$\n其中 $M$ 是所有路径上曲率样本的总数。如果没有内部点，则将 $\\bar{\\kappa}$ 和 $\\sigma_{\\kappa}$ 均设为 $0$。\n\n4. 锥度剖面：\n- 对于每个根到叶路径，设 $s_k$ 为从根节点沿路径测量到节点 $k$ 的累积路径长度（单位：微米），$r_k$ 为节点 $k$ 的半径（单位：微米）。\n- 对于每个至少有 $2$ 个点的路径，计算 $r$ 相对于 $s$ 的普通最小二乘法斜率 $m$，由下式给出\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2},\n$$\n其中 $\\bar{s}$ 和 $\\bar{r}$ 分别是 $\\{s_k\\}$ 和 $\\{r_k\\}$ 的均值。如果分母为零或路径上的点少于 $2$ 个，则定义 $m = 0$。将所有路径的斜率聚合到一个集合 $\\{m\\}$ 中，并定义平均斜率\n$$\n\\bar{m} = \\frac{1}{P}\\sum_{p=1}^{P} m_p\n$$\n和总体标准差\n$$\n\\sigma_m = \\sqrt{\\frac{1}{P}\\sum_{p=1}^{P} (m_p - \\bar{m})^2},\n$$\n其中 $P$ 是路径的数量。\n\n通过按顺序串联以下部分来构建特征向量：分支角直方图（长度 $6$）、路径长度直方图（长度 $5$）、曲率的均值和标准差（长度 $2$）以及锥度斜率的均值和标准差（长度 $2$）。总特征向量长度为 $15$。所有长度必须以微米 ($\\mu m$) 为单位；所有角度必须以弧度为单位；曲率必须以弧度/微米为单位；锥度斜率必须以微米/微米为单位。\n\n测试套件：\n使用以下四个测试用例，每个用例由一个节点列表 $(i, x_i, y_i, z_i, r_i, p_i)$ 定义，其中所有坐标和半径的单位均为微米 ($\\mu m$)，索引为整数。父节点索引 $p_i = -1$ 表示根节点。\n\n- 测试用例 1 (直线电缆):\n  - $(0, 0, 0, 0, 2, -1)$\n  - $(1, 0, 0, 10, 2, 0)$\n  - $(2, 0, 0, 20, 2, 1)$\n  - $(3, 0, 0, 30, 2, 2)$\n\n- 测试用例 2 (对称Y形):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 0, 10, 2.5, 0)$\n  - $(2, 10, 0, 20, 2, 1)$\n  - $(3, -10, 0, 20, 2, 1)$\n\n- 测试用例 3 (带分叉的弯曲路径):\n  - $(0, 0, 0, 0, 3, -1)$\n  - $(1, 0, 5, 5, 2.8, 0)$\n  - $(2, 0, 10, 10, 2.6, 1)$\n  - $(3, 0, 15, 10, 2.4, 2)$\n  - $(4, 4, 22, 10, 2.2, 3)$\n  - $(5, -2, 22, 10, 2.2, 3)$\n\n- 测试用例 4 (长分支):\n  - $(0, 0, 0, 0, 4, -1)$\n  - $(1, 0, 0, 20, 3.5, 0)$\n  - $(2, 0, 0, 40, 3.0, 1)$\n  - $(3, 10, 0, 55, 2.5, 2)$\n  - $(4, 20, 0, 70, 2.0, 3)$\n  - $(5, -10, 0, 55, 2.5, 2)$\n  - $(6, -20, 0, 70, 2.0, 5)$\n\n您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，列表的每个元素是对应一个测试用例的特征向量（一个包含 $15$ 个浮点数的列表），所有这些都聚合在一个顶层列表中。例如：\"[[f1,f2,...,f15],[g1,g2,...,g15],[h1,h2,...,h15],[k1,k2,...,k15]]\"。角度必须以弧度为单位；长度必须以微米 ($\\mu m$) 为单位；曲率必须以弧度/微米为单位；锥度斜率必须以微米/微米为单位。不应打印任何额外文本。\n\n实现必须是一个完整的、可运行的程序，并且只使用指定的运行时环境。所有数值答案都必须是浮点数。算法必须对边界情况具有鲁棒性，包括没有分叉的节点、半径恒定的路径以及因太短而无法定义曲率或斜率的路径。",
            "solution": "所提出的问题是有效的。它在计算神经科学领域，特别是在神经元重建的形态计量分析方面，具有科学依据。所有提供的定义、公式和条件在数学和算法上都是合理的、适定的，并且没有歧义或矛盾。任务是从第一性原理出发实现一个特征提取流程，这是一个标准且可验证的过程。\n\n该解决方案是通过一个系统的、多步骤的过程开发的。首先，将输入数据（一个节点属性列表）解析为表示神经元树状形态的图数据结构。随后，基于此结构计算四组不同的形态学特征：分支角直方图、根到叶路径长度分布、局部曲率统计量以及树突锥度统计量。最后，将这些特征串联成一个维度为 $15$ 的单一特征向量。\n\n**1. 数据结构化**\n\n初始输入是一个节点列表，每个节点由其索引 $i$、笛卡尔坐标 $\\mathbf{x}_i = (x_i, y_i, z_i)$、半径 $r_i$ 和父节点索引 $p_i$ 定义。为了便于遍历和邻域查询，我们首先将这个扁平列表转换为更具结构化的表示。一个将每个节点索引映射到其属性（坐标、半径、父节点）的字典提供了高效的查找。然后构建第二个字典，表示一个邻接表，用于将每个父节点索引映射到其子节点索引的列表。这是通过遍历所有节点，并对每个父节点为 $p_i \\neq -1$ 的节点 $i$，将其追加到 $p_i$ 的子节点列表中来实现的。具有 $p_i = -1$ 的单个节点被识别为树的根。\n\n**2. 特征推导与计算**\n\n四个特征组的计算过程如下，严格遵守所提供的定义。\n\n**2.1. 分支角直方图**\n\n此特征量化了树突分叉的几何形状。\n- 分支点或分叉节点 $b$ 定义为任何具有两个或更多子节点的节点。我们通过检查先前构建的子节点映射来识别所有此类节点。\n- 对于每个分叉节点 $b$，我们考虑其每一对无序子节点 $(c_1, c_2)$。\n- 每个子分支初始段的方向由从父节点到子节点的向量给出：$\\mathbf{v}_{c_1} = \\mathbf{x}_{c_1} - \\mathbf{x}_b$ 和 $\\mathbf{v}_{c_2} = \\mathbf{x}_{c_2} - \\mathbf{x}_b$。\n- 这两个向量之间的夹角 $\\theta$ 是衡量分支张开宽度的度量。它根据点积的定义计算得出：\n$$\n\\theta(b; c_1, c_2) = \\arccos\\left(\\frac{\\mathbf{v}_{c_1} \\cdot \\mathbf{v}_{c_2}}{\\|\\mathbf{v}_{c_1}\\| \\|\\mathbf{v}_{c_2}\\|}\\right)\n$$\n其中 $\\|\\cdot\\|$ 表示欧几里得范数。$\\arccos$ 函数的参数被裁剪到 $[-1, 1]$ 范围内，以防止由浮点不精确性引起的数值错误。\n- 收集树中所有分叉点的所有此类角度，形成一个列表。\n- 使用指定的区间边界 $B_\\theta = [0, \\pi/6, \\pi/3, \\pi/2, 2\\pi/3, 5\\pi/6, \\pi]$ 计算这些角度的直方图。这将产生一个 $6$ 维的计数向量。\n- 为了使特征与神经元的大小（即分叉总数）无关，通过将每个区间的计数除以角度总数来对直方图进行归一化，确保各分量之和为 $1$。如果不存在分叉点，则按照问题规范返回一个长度为 $6$ 的零向量。\n\n**2.2. 根到叶路径长度分布**\n\n此特征捕捉了从胞体（根）到树突末梢的电紧张距离的分布。\n- 叶节点 $t$ 定义为任何没有子节点的节点。我们识别所有此类节点。\n- 对于每个叶节点 $t$，我们使用父节点指针追溯其回到根的唯一路径。这会产生构成路径的节点序列 $P(t) = (\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n=t)$。\n- 此路径的总长度 $L(t)$ 是其组成线段的欧几里得长度之和：\n$$\nL(t) = \\sum_{(i \\rightarrow j) \\in P(t)} \\|\\mathbf{x}_j - \\mathbf{x}_i\\|\n$$\n- 收集所有此类根到叶路径的长度。\n- 使用指定的区间边界 $B_L = [0, 20, 40, 60, 80, 100]$ 对这些路径长度计算归一化直方图，得到一个 $5$ 维向量。通过除以叶节点总数进行归一化。如果没有叶节点，则返回一个长度为 $5$ 的零向量。\n\n**2.3. 曲率估计**\n\n此特征测量树突路径的曲折度。\n- 我们重用上一步中识别的根到叶路径。\n- 对于每个至少有 $3$ 个节点的路径 $(\\mathbf{x}_0, \\mathbf{x}_1, \\dots, \\mathbf{x}_n)$，我们可以在内部节点 $k = 1, \\dots, n-1$ 处估计曲率。\n- 节点 $\\mathbf{x}_k$ 处的离散曲率 $\\kappa_k$ 定义为单位路径长度的转向角。转向角是入向量 $(\\mathbf{x}_k - \\mathbf{x}_{k-1})$ 和出向量 $(\\mathbf{x}_{k+1} - \\mathbf{x}_k)$ 之间的夹角。路径长度单位由这两个线段的平均长度近似。由此得出公式：\n$$\n\\kappa_k = \\frac{\\arccos\\left(\\frac{(\\mathbf{x}_k - \\mathbf{x}_{k-1}) \\cdot (\\mathbf{x}_{k+1} - \\mathbf{x}_k)}{\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| \\, \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|}\\right)}{\\frac{1}{2}\\left(\\|\\mathbf{x}_k - \\mathbf{x}_{k-1}\\| + \\|\\mathbf{x}_{k+1} - \\mathbf{x}_k\\|\\right)}\n$$\n- 进行检查以确保线段长度非零，以避免除以零。\n- 聚合所有路径的所有有效曲率样本 $\\kappa_k$。\n- 从这个样本集合中，我们计算两个汇总统计量：平均曲率 $\\bar{\\kappa}$ 和总体标准差 $\\sigma_{\\kappa}$。如果整个树中不存在内部点（即所有路径的节点数都少于 $3$ 个），则这两个统计量都设为 $0$。\n\n**2.4. 锥度剖面**\n\n此特征描述树突分支的半径如何随与根节点距离的变化而变化，这与 Rall 幂定律有关。\n- 对于每个至少有 $2$ 个节点的根到叶路径，我们分析半径 $r$ 和与根的累积路径距离 $s$ 之间的关系。\n- 对于具有节点 $(_0, _1, ..., _n)$ 的路径，节点 $k$ 处的累积距离为 $s_k = \\sum_{i=0}^{k-1} \\|\\mathbf{x}_{i+1} - \\mathbf{x}_i\\|$，其中 $s_0=0$。相应的半径为 $\\{r_0, r_1, \\dots, r_n\\}$。\n- 对于每个路径，我们计算半径 $r$ 对距离 $s$ 进行普通最小二乘线性回归的斜率 $m$。该公式由 $s$ 和 $r$ 的协方差与 $s$ 的方差之比给出：\n$$\nm = \\frac{\\sum_{k}(s_k - \\bar{s})(r_k - \\bar{r})}{\\sum_{k}(s_k - \\bar{s})^2}\n$$\n- 根据规定，如果路径的点数少于 $2$ 个，或者分母为零（即所有累积距离都相同，意味着线段长度为零），则斜率 $m$ 定义为 $0$。\n- 收集所有有效路径的斜率。\n- 计算平均斜率 $\\bar{m}$ 和斜率的总体标准差 $\\sigma_m$。如果没有可以计算斜率的路径，则这两个统计量都设为 $0$。\n\n**3. 特征向量组装**\n\n最终的 $15$ 维特征向量通过按指定顺序串联上述计算结果而构建：\n1.  分支角直方图 (6 个浮点数)\n2.  路径长度直方图 (5 个浮点数)\n3.  曲率的均值和标准差 (2 个浮点数)\n4.  锥度斜率的均值和标准差 (2 个浮点数)\n\n此过程提供了对神经元形态的全面、定量的描述，适用于机器学习模型中的细胞类型分类。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport itertools\n\ndef compute_features(nodes_data):\n    \"\"\"\n    Computes morphological features for a single neuron reconstruction.\n    \"\"\"\n    if not nodes_data:\n        return [0.0] * 15\n\n    # 1. Data Structuring\n    num_nodes = len(nodes_data)\n    nodes = {}\n    children = {i: [] for i in range(num_nodes)}\n    root_id = -1\n\n    node_list = sorted(nodes_data, key=lambda n: n[0])\n\n    for (node_id, x, y, z, r, p) in node_list:\n        nodes[node_id] = {\n            'pos': np.array([x, y, z], dtype=float),\n            'radius': float(r),\n            'parent': int(p)\n        }\n        if p != -1:\n            if p in children:\n                children[p].append(node_id)\n        else:\n            root_id = node_id\n\n    # 2. Feature Calculation\n\n    # 2.1. Branch Angle Histogram\n    branch_angles = []\n    bifurcation_node_ids = [i for i, c in children.items() if len(c) >= 2]\n    for b_id in bifurcation_node_ids:\n        b_pos = nodes[b_id]['pos']\n        for c1_id, c2_id in itertools.combinations(children[b_id], 2):\n            v1 = nodes[c1_id]['pos'] - b_pos\n            v2 = nodes[c2_id]['pos'] - b_pos\n            norm_v1 = np.linalg.norm(v1)\n            norm_v2 = np.linalg.norm(v2)\n            if norm_v1 > 0 and norm_v2 > 0:\n                cos_theta = np.dot(v1, v2) / (norm_v1 * norm_v2)\n                cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                angle = np.arccos(cos_theta)\n                branch_angles.append(angle)\n\n    angle_bins = [0, np.pi/6, np.pi/3, np.pi/2, 2*np.pi/3, 5*np.pi/6, np.pi]\n    if branch_angles:\n        hist_angles, _ = np.histogram(branch_angles, bins=angle_bins)\n        hist_angles = hist_angles.astype(float) / len(branch_angles)\n    else:\n        hist_angles = np.zeros(len(angle_bins) - 1, dtype=float)\n\n    # 2.2, 2.3, 2.4: Path-based features\n    leaf_ids = [i for i in range(num_nodes) if not children[i]]\n    \n    path_lengths = []\n    curvatures = []\n    taper_slopes = []\n\n    for leaf_id in leaf_ids:\n        path = []\n        curr_id = leaf_id\n        while curr_id != -1:\n            path.append(curr_id)\n            curr_id = nodes[curr_id]['parent']\n        path.reverse()\n        \n        if not path:\n            continue\n        \n        # Path length and cumulative length calculation\n        total_length = 0.0\n        segment_lengths = []\n        if len(path) > 1:\n            for i in range(len(path) - 1):\n                p1_pos = nodes[path[i]]['pos']\n                p2_pos = nodes[path[i+1]]['pos']\n                length = np.linalg.norm(p2_pos - p1_pos)\n                segment_lengths.append(length)\n            total_length = sum(segment_lengths)\n        path_lengths.append(total_length)\n        \n        # Curvature calculation\n        if len(path) >= 3:\n            for i in range(1, len(path) - 1):\n                p_prev_pos = nodes[path[i-1]]['pos']\n                p_curr_pos = nodes[path[i]]['pos']\n                p_next_pos = nodes[path[i+1]]['pos']\n                \n                v_in = p_curr_pos - p_prev_pos\n                v_out = p_next_pos - p_curr_pos\n                \n                norm_in = np.linalg.norm(v_in)\n                norm_out = np.linalg.norm(v_out)\n                \n                if norm_in > 0 and norm_out > 0:\n                    cos_theta = np.dot(v_in, v_out) / (norm_in * norm_out)\n                    cos_theta = np.clip(cos_theta, -1.0, 1.0)\n                    angle = np.arccos(cos_theta)\n                    avg_len = (norm_in + norm_out) / 2.0\n                    curvatures.append(angle / avg_len)\n\n        # Tapering calculation\n        if len(path) >= 2:\n            s = np.concatenate(([0.0], np.cumsum(segment_lengths)))\n            r = np.array([nodes[node_id]['radius'] for node_id in path])\n            \n            s_mean = np.mean(s)\n            denominator = np.sum((s - s_mean)**2)\n            \n            if denominator > 0:\n                r_mean = np.mean(r)\n                numerator = np.sum((s - s_mean) * (r - r_mean))\n                slope = numerator / denominator\n                taper_slopes.append(slope)\n            else:\n                taper_slopes.append(0.0)\n        elif len(path) > 0:\n             # Path has only 1 node, so less than 2 points.\n             taper_slopes.append(0.0)\n\n    # Post-processing path features\n    length_bins = [0, 20, 40, 60, 80, 100]\n    if path_lengths:\n        hist_lengths, _ = np.histogram(path_lengths, bins=length_bins)\n        hist_lengths = hist_lengths.astype(float) / len(path_lengths)\n    else:\n        hist_lengths = np.zeros(len(length_bins) - 1, dtype=float)\n\n    if curvatures:\n        mean_kappa = np.mean(curvatures)\n        std_kappa = np.std(curvatures)\n    else:\n        mean_kappa, std_kappa = 0.0, 0.0\n\n    if taper_slopes:\n        mean_m = np.mean(taper_slopes)\n        std_m = np.std(taper_slopes)\n    else:\n        mean_m, std_m = 0.0, 0.0\n    \n    # 3. Assemble Feature Vector\n    feature_vector = np.concatenate([\n        hist_angles,\n        hist_lengths,\n        [mean_kappa, std_kappa],\n        [mean_m, std_m]\n    ])\n    \n    return feature_vector.tolist()\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (straight cable)\n        [\n            (0, 0, 0, 0, 2, -1),\n            (1, 0, 0, 10, 2, 0),\n            (2, 0, 0, 20, 2, 1),\n            (3, 0, 0, 30, 2, 2)\n        ],\n        # Test case 2 (symmetric Y-shape)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 0, 10, 2.5, 0),\n            (2, 10, 0, 20, 2, 1),\n            (3, -10, 0, 20, 2, 1)\n        ],\n        # Test case 3 (curved path with bifurcation)\n        [\n            (0, 0, 0, 0, 3, -1),\n            (1, 0, 5, 5, 2.8, 0),\n            (2, 0, 10, 10, 2.6, 1),\n            (3, 0, 15, 10, 2.4, 2),\n            (4, 4, 22, 10, 2.2, 3),\n            (5, -2, 22, 10, 2.2, 3)\n        ],\n        # Test case 4 (long branches)\n        [\n            (0, 0, 0, 0, 4, -1),\n            (1, 0, 0, 20, 3.5, 0),\n            (2, 0, 0, 40, 3.0, 1),\n            (3, 10, 0, 55, 2.5, 2),\n            (4, 20, 0, 70, 2.0, 3),\n            (5, -10, 0, 55, 2.5, 2),\n            (6, -20, 0, 70, 2.0, 5)\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_features(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}