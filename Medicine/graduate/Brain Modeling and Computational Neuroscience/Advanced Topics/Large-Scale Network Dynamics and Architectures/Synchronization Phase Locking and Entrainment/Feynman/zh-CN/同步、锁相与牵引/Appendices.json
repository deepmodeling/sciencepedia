{
    "hands_on_practices": [
        {
            "introduction": "要掌握同步动力学，我们首先从其最基本的构件入手：一个由外部周期性力量驱动的单个振子。这项练习  将指导你通过解析推导来获得锁相的条件。通过将系统转化为一个更简单的自治方程，你将确定振子与驱动之间稳定的相位关系，从而揭示频率牵引（entrainment）背后的核心数学原理。",
            "id": "4026095",
            "problem": "考虑一个受弱正弦驱动的单相位约化神经振子，其模型为强迫相位方程 $ \\dot{\\phi}(t) = \\omega + F \\sin\\!\\big(\\Omega t - \\phi(t)\\big) $，其中 $ \\phi(t) $ 是振子相位，$ \\omega $ 是无强迫振子的固有频率，$ F \\ge 0 $ 是驱动振幅，$ \\Omega $ 是驱动频率。拖曳现象指的是一种长时间演化过程，在此过程中振子频率与驱动频率相匹配，且振子与驱动之间的相位差趋近于一个不随时间变化的常数。假设发生 $ 1\\!:\\!1 $ 拖曳（频率锁定，平均相位漂移为零），并定义相位差 $ \\delta(t) = \\phi(t) - \\Omega t $。仅使用标准相位约化假设和一维自治系统不动点的线性稳定性分析，推导确定锁定相位差的不动点条件，并确定锁定状态的线性稳定性。作为最终答案，请提供一个关于稳定锁定相位差 $ \\delta^{\\ast} $ 的、用 $ \\omega $、$ \\Omega $ 和 $ F $ 表示的单一闭式解析表达式。最终答案以弧度表示。",
            "solution": "首先根据指定标准对问题进行验证。\n\n### 步骤1：提取已知条件\n- **模型方程**：$ \\dot{\\phi}(t) = \\omega + F \\sin\\!\\big(\\Omega t - \\phi(t)\\big) $\n- **变量**：\n    - $ \\phi(t) $：$t$ 时刻的振子相位\n    - $ \\omega $：无强迫振子的固有频率\n    - $ F $：驱动振幅，$F \\ge 0$\n    - $ \\Omega $：驱动频率\n- **定义**：\n    - **拖曳**：振子频率与驱动频率相匹配，且相位差趋于一个不随时间变化的常数的长时间演化过程。\n    - **相位差**：$ \\delta(t) = \\phi(t) - \\Omega t $\n- **假设**：发生 $ 1\\!:\\!1 $ 拖曳。\n- **任务**：\n    1. 推导锁定相位差的不动点条件。\n    2. 确定锁定状态的线性稳定性。\n    3. 提供稳定锁定相位差 $ \\delta^{\\ast} $ 的闭式解析表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n评估问题的有效性：\n- **科学依据**：所提供的模型 $ \\dot{\\phi} = \\omega + F \\sin(\\Omega t - \\phi) $ 是Adler方程的一种典范形式。它是物理学、工程学和计算神经科学中一个基础且广泛使用的模型，用于研究弱驱动或耦合振子中的同步、锁相和拖曳现象。该问题基于已建立的科学原理。\n- **良定性**：问题陈述清晰。它要求在拖曳的假设下，从给定的微分方程中推导一个特定量（$ \\delta^{\\ast} $）。其数学结构是一个一阶非自治常微分方程，可以转化为一个自治方程，从而适用标准分析方法（不动点和稳定性分析）。在所述条件下，预期会有一个唯一的稳定解。\n- **客观性**：语言精确且定量，没有任何主观或模糊的术语。\n- **完整性与一致性**：问题提供了所有必要的信息：控制方程、所有变量和参数的定义，以及拖曳的关键假设。内容没有矛盾之处。\n- **现实性**：该模型是该领域的标准理想化模型。参数是通用的，不代表物理上不可能的值。\n\n### 步骤3：结论与行动\n该问题是**有效的**。它在科学上是合理的、良定的、客观的且自洽的。可以开始求解过程。\n\n### 解题推导\n振子相位的动力学由以下方程给出：\n$$ \\dot{\\phi}(t) = \\omega + F \\sin(\\Omega t - \\phi(t)) $$\n问题将相位差定义为 $ \\delta(t) = \\phi(t) - \\Omega t $。我们希望找到控制 $ \\delta(t) $ 的动力学。为此，我们将 $ \\delta(t) $ 对时间 $ t $ 求导：\n$$ \\dot{\\delta}(t) = \\frac{d}{dt} \\big( \\phi(t) - \\Omega t \\big) = \\dot{\\phi}(t) - \\Omega $$\n将 $ \\dot{\\phi}(t) $ 的表达式代入此方程，得到：\n$$ \\dot{\\delta}(t) = \\big( \\omega + F \\sin(\\Omega t - \\phi(t)) \\big) - \\Omega $$\n正弦函数内部的项可以用 $ \\delta(t) $ 表示：\n$$ \\Omega t - \\phi(t) = -(\\phi(t) - \\Omega t) = -\\delta(t) $$\n利用正弦函数的性质 $ \\sin(-x) = -\\sin(x) $， $ \\dot{\\delta}(t) $ 的方程变为：\n$$ \\dot{\\delta}(t) = \\omega - \\Omega - F \\sin(\\delta(t)) $$\n这是一个关于相位差 $ \\delta(t) $ 的一阶自治常微分方程。\n\n拖曳（或锁相）的条件是相位差趋于一个与时间无关的恒定值，我们将其记为 $ \\delta^{\\ast} $。这对应于 $ \\delta(t) $ 动力学的一个不动点。当 $ \\dot{\\delta}(t) = 0 $ 时，出现不动点。\n令 $ \\dot{\\delta}(t) = 0 $ 得到不动点条件：\n$$ 0 = \\omega - \\Omega - F \\sin(\\delta^{\\ast}) $$\n整理此方程，得到确定锁定相位差的条件：\n$$ F \\sin(\\delta^{\\ast}) = \\omega - \\Omega $$\n$$ \\sin(\\delta^{\\ast}) = \\frac{\\omega - \\Omega}{F} $$\n为使 $ \\delta^{\\ast} $ 存在实数解，等式右侧的值必须在正弦函数的取值范围 $ [-1, 1] $ 内。这导出了频率锁定的条件：\n$$ \\left| \\frac{\\omega - \\Omega}{F} \\right| \\le 1 \\quad \\implies \\quad |\\omega - \\Omega| \\le F $$\n问题陈述假设拖曳发生，因此我们在此条件满足的假设下继续进行。\n\n为确定不动点 $ \\delta^{\\ast} $ 的稳定性，我们进行线性稳定性分析。设 $ \\delta $ 的自治常微分方程的右侧为 $g(\\delta)$：\n$$ g(\\delta) = \\omega - \\Omega - F \\sin(\\delta) $$\n如果 $ g(\\delta) $ 在不动点处的导数为负，即 $ g'(\\delta^{\\ast})  0 $，则不动点 $ \\delta^{\\ast} $ 是线性稳定的。如果 $ g'(\\delta^{\\ast}) > 0 $，则它是不稳定的。\n$ g(\\delta) $ 的导数是：\n$$ g'(\\delta) = \\frac{d}{d\\delta} \\big( \\omega - \\Omega - F \\sin(\\delta) \\big) = -F \\cos(\\delta) $$\n因此，对于一个稳定的不动点，我们必须有：\n$$ g'(\\delta^{\\ast}) = -F \\cos(\\delta^{\\ast})  0 $$\n因为给定的驱动振幅 $ F \\ge 0 $，且 $ F=0 $ 的情况是平凡的（无驱动），我们考虑 $ F > 0 $。稳定性条件简化为：\n$$ \\cos(\\delta^{\\ast}) > 0 $$\n方程 $ \\sin(\\delta^{\\ast}) = \\frac{\\omega - \\Omega}{F} $ 在任何长度为 $ 2\\pi $ 的区间内通常有两个不同的解 $ \\delta^{\\ast} $，前提是 $ |\\omega - \\Omega|  F $。令 $ C = \\frac{\\omega - \\Omega}{F} $。\n\n第一个解是主值，由反正弦函数给出：\n$$ \\delta_1^{\\ast} = \\arcsin(C) = \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n根据定义，$ \\arcsin $ 函数的值域是 $ [-\\frac{\\pi}{2}, \\frac{\\pi}{2}] $。对于任何值 $ \\theta \\in [-\\frac{\\pi}{2}, \\frac{\\pi}{2}] $，其余弦值 $ \\cos(\\theta) $ 是非负的 ($ \\cos(\\theta) \\ge 0 $) 。具体来说，如果 $ |\\omega - \\Omega|  F $，则 $ |C|  1 $ 且 $ \\delta_1^{\\ast} \\in (-\\frac{\\pi}{2}, \\frac{\\pi}{2}) $，这意味着 $ \\cos(\\delta_1^{\\ast}) > 0 $。因此，不动点 $ \\delta_1^{\\ast} $ 是稳定的。\n\n在区间 $ [-\\frac{\\pi}{2}, \\frac{3\\pi}{2}) $ 内的第二个解是：\n$$ \\delta_2^{\\ast} = \\pi - \\delta_1^{\\ast} = \\pi - \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n这个解位于范围 $ [\\frac{\\pi}{2}, \\frac{3\\pi}{2}] $ 内。对于任何值 $ \\theta \\in [\\frac{\\pi}{2}, \\frac{3\\pi}{2}] $，其余弦值 $ \\cos(\\theta) $ 是非正的 ($ \\cos(\\theta) \\le 0 $) 。具体来说，如果 $ |\\omega - \\Omega|  F $，则 $ \\delta_2^{\\ast} \\in (\\frac{\\pi}{2}, \\frac{3\\pi}{2}) $，这意味着 $ \\cos(\\delta_2^{\\ast})  0 $。对于这个不动点，稳定性判据变为 $ g'(\\delta_2^{\\ast}) = -F \\cos(\\delta_2^{\\ast}) > 0 $。因此，不动点 $ \\delta_2^{\\ast} $ 是不稳定的。\n\n问题要求的是稳定锁定相位差。根据线性稳定性分析，这个解是 $ \\delta_1^{\\ast} $。\n\n因此，稳定锁定相位差为：\n$$ \\delta^{\\ast} = \\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right) $$\n该表达式给出了当振子被拖曳时，其相对于外部驱动所保持的恒定相位差（以弧度为单位）。",
            "answer": "$$ \\boxed{\\arcsin\\left(\\frac{\\omega - \\Omega}{F}\\right)} $$"
        },
        {
            "introduction": "在理解了单个单元的动力学之后，我们现在将尺度放大，探索同步如何在一个大型网络中作为一种集体现象涌现。这项练习  使用经典的 Kuramoto 模型来模拟一个相互作用的振子群。你将通过一个数值实验，来确定系统自发地从无序状态转变为全局同步状态的临界耦合强度 $K_{c}$，这是许多生物系统中自组织的标志。",
            "id": "4026154",
            "problem": "要求您编写一个完整、可运行的程序，该程序使用基于动力系统理论中经过充分检验的定义的、有原则的数值方法，来估计 Kuramoto 模型中相位振子网络的部分同步起始点。考虑一个由 $N$ 个相位振子组成的总体，其相位为 $\\theta_{i}(t)$，自然频率 $\\omega_{i}$ 从一个以 $\\omega_{0} = 0$ 为中心、半高半宽为 $\\Delta  0$ 的洛伦兹（柯西）分布中独立抽取，即其概率密度为\n$$\ng(\\omega) = \\frac{\\Delta}{\\pi}\\,\\frac{1}{\\omega^{2} + \\Delta^{2}}.\n$$\n动力学由 Kuramoto 相位振子方程描述\n$$\n\\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\frac{K}{N}\\sum_{j=1}^{N}\\sin\\!\\big(\\theta_{j} - \\theta_{i}\\big),\n$$\n其中 $K \\ge 0$ 是全局耦合强度，角度以弧度为单位。定义复数序参量为\n$$\nre^{i\\psi} = \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{j}},\n$$\n其中 $r \\in [0,1]$ 衡量相位相干性，$\\psi$ 是平均相位。您的任务是在以下规范下，数值估计系统从非相干态（对于大的 $N$，$r \\approx 0$）过渡到部分同步态（$r  0$）的临界耦合强度 $K_{c}$。\n\n从上述定义和定律出发，实现振子动力学的直接时域仿真，以获得给定 $K$ 值下的时间平均序参量 $\\langle r \\rangle_{t}$，其中时间平均不包括初始暂态。整个过程中角度使用弧度，并在 $[0,2\\pi)$ 上对 $\\theta_{i}(0)$ 进行均匀随机初始化。为确保检测起始点的科学真实性，定义一个随有限尺寸涨落缩放的数值检测阈值；设置阈值为\n$$\nr_{\\mathrm{th}} = \\frac{c}{\\sqrt{N}},\n$$\n其中 $c$ 为一个固定常数。数值上，将 $K_{c}$ 定义为使时间平均序参量 $\\langle r \\rangle_{t}$ 严格超过 $r_{\\mathrm{th}}$ 的最小 $K$ 值。使用一种自适应搜索策略，首先在粗糙网格上框定交叉点，然后通过对 $K$ 进行二分法来精化估计值。\n\n您的程序必须遵守以下数值选择：\n- 使用显式欧拉时间步进法，时间步长 $dt = 0.02$，总积分时间 $T = 25.0$，在计算 $\\langle r \\rangle_{t}$ 平均值前舍弃暂态时间 $T_{\\mathrm{trans}} = 10.0$。\n- 在阈值 $r_{\\mathrm{th}}$ 中使用 $c = 3.5$。\n- 为了从洛伦兹分布中采样 $\\omega_{i}$，使用逆变换采样法：\n$$\n\\omega_{i} = \\Delta \\tan\\!\\big(\\pi(u_{i} - \\tfrac{1}{2})\\big),\n$$\n其中 $u_{i}$ 在 $[0,1]$ 上独立均匀分布。对于所有测试，中心都设为 $\\omega_{0} = 0$。\n- 对于 $K$ 的自适应搜索，在 $[0, K_{\\max}]$（其中 $K_{\\max} = 6\\Delta$）上使用一个包含 $M=24$ 个均匀间隔点的粗糙网格来框定交叉点；如果成功框定，则执行 $J=12$ 次二分法迭代来精化 $K_{c}$。\n- 在扫描 $K$ 值时，对每个测试用例的所有 $K$ 值使用相同的随机种子，以保持网络实现不变。程序应按照下面测试套件中的规定，在内部固定这些种子。\n\n严格按照上述定义实现序参量和动力学，并确保角度以弧度处理。在此表述中，除了角度的弧度外没有其他物理单位；时间和耦合是无量纲的。所有数学计算必须直接遵循所提供的定义，不得调用任何未提供的快捷表达式。\n\n测试套件：\n针对以下测试用例估计 $K_{c}$，每个用例由 $(N,\\Delta,\\text{seed})$ 指定：\n- 用例 1：$(N,\\Delta,\\text{seed}) = (256, 0.5, 1337)$。\n- 用例 2：$(N,\\Delta,\\text{seed}) = (512, 1.0, 2021)$。\n- 用例 3：$(N,\\Delta,\\text{seed}) = (1024, 2.0, 7)$。\n- 边界用例 4：$(N,\\Delta,\\text{seed}) = (64, 0.2, 99)$。\n\n答案规格：\n- 对于每个测试用例，返回估计的临界耦合 $K_{c}$，形式为浮点数，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，按测试用例的顺序排列，例如 $\\,[K_{c}^{(1)}, K_{c}^{(2)}, K_{c}^{(3)}, K_{c}^{(4)}]\\,.$。\n- 输出必须是且仅是一行，包含方括号列表，无任何附加文本。\n\n您的程序必须是自包含的，无需输入，并在给定上述固定种子的情况下确定性地运行。角度必须以弧度为单位；报告的浮点数需保留三位小数且不带单位。",
            "solution": "问题陈述已经过分析，并被确定为有效。它具有科学依据、良定、客观，并为数值实验提供了一套完整且一致的规范。任务是估计 Kuramoto 振子网络中同步起始的临界耦合强度 $K_c$。这将通过直接时域仿真和系统性搜索算法来实现。\n\n解决方案基于以下原则构建：\n\n1.  **Kuramoto 模型与同步**\n    该系统由 $N$ 个相位振子组成，其中每个振子 $i$ 的状态由其相位角 $\\theta_i(t)$ 描述。每个相位的时间演化由 Kuramoto 方程控制：\n    $$\n    \\frac{d\\theta_{i}}{dt} = \\omega_{i} + \\frac{K}{N}\\sum_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i})\n    $$\n    此处，$\\omega_i$ 是振子 $i$ 的内在自然频率，从中心在 $\\omega_0=0$、半高宽为 $\\Delta$ 的洛伦兹分布 $g(\\omega)$ 中抽取。项 $\\frac{K}{N}\\sum\\limits_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i})$ 代表了所有其他振子对振子 $i$ 的影响，其中 $K \\ge 0$ 是均匀耦合强度。\n    网络的集体行为由复数序参量 $z(t) = r(t)e^{i\\psi(t)}$ 量化，定义为：\n    $$\n    re^{i\\psi} = \\frac{1}{N}\\sum_{j=1}^{N} e^{i\\theta_{j}}\n    $$\n    幅值 $r \\in [0,1]$ 衡量相位相干的程度。对于非相干态，相位是随机分布的，当 $N$ 很大时 $r \\approx 0$。对于部分同步态，宏观比例的振子会一起旋转，导致 $r  0$。临界耦合 $K_c$ 是系统从非相干态过渡到部分同步态时的 $K$ 值。\n\n2.  **高效的数值积分**\n    该微分方程组使用显式欧拉法进行数值求解。对每个振子动力学中的求和项进行直接计算，每个时间步的计算复杂度为 $O(N^2)$，这是低效的。该求和项可重写为：\n    $$\n    \\frac{K}{N}\\sum_{j=1}^{N}\\sin(\\theta_{j} - \\theta_{i}) = \\frac{K}{N} \\text{Im}\\left( \\sum_{j=1}^{N} e^{i(\\theta_{j}-\\theta_{i})} \\right) = \\frac{K}{N} \\text{Im}\\left( e^{-i\\theta_{i}} \\sum_{j=1}^{N} e^{i\\theta_{j}} \\right)\n    $$\n    代入序参量的定义，上式变为：\n    $$\n    \\frac{K}{N} \\text{Im}\\left( e^{-i\\theta_{i}} (Nre^{i\\psi}) \\right) = K \\text{Im}\\left( r e^{i(\\psi - \\theta_{i})} \\right) = K r \\sin(\\psi - \\theta_{i})\n    $$\n    运动方程简化为一种高效的形式：\n    $$\n    \\frac{d\\theta_{i}}{dt} = \\omega_{i} + K r(t) \\sin(\\psi(t) - \\theta_{i}(t))\n    $$\n    因此，时间步长为 $dt$ 的显式欧拉离散化形式为：\n    $$\n    \\theta_i(t+\\Delta t) = \\theta_i(t) + dt \\left( \\omega_{i} + K r(t) \\sin(\\psi(t) - \\theta_{i}(t)) \\right)\n    $$\n    对于给定的 $K$，仿真将以 $dt=0.02$ 的时间步长运行总时间 $T=25.0$。\n\n3.  **同步起始的检测**\n    对于一个尺寸为 $N$ 的有限系统，即使在非相干状态下，统计涨落也会导致序参量 $r$ 非零，其标度关系通常为 $r \\sim O(1/\\sqrt{N})$。为了将真正的部分同步与这些有限尺寸效应区分开，建立了一个数值阈值：\n    $$\n    r_{\\mathrm{th}} = \\frac{c}{\\sqrt{N}}\n    $$\n    使用指定的常数 $c=3.5$，该阈值为同步的起始提供了一个鲁棒的判据。临界耦合 $K_c$ 随之被定义为使得时间平均序参量 $\\langle r \\rangle_t$ 严格超过此阈值的最小 $K$ 值。时间平均是在仿真的后半部分（从 $T_{\\mathrm{trans}} = 10.0$ 到 $T = 25.0$）计算的，以排除初始暂态行为。\n\n4.  **临界耦合 $K_c$ 的自适应搜索**\n    采用一种高效的两阶段自适应搜索策略来寻找 $K_c$。\n    - **区间框定：** $K$ 的搜索范围设定为 $[0, K_{\\max}]$，其中 $K_{\\max} = 6\\Delta$。该范围被划分为一个有 $M=24$ 个点的粗糙网格。对于网格上的每个点 $K$，都运行一次完整仿真来计算 $\\langle r \\rangle_t$。然后，算法识别出第一对框定转变的相邻网格点 $(K_{low}, K_{high})$，即满足 $\\langle r \\rangle_t(K_{low}) \\le r_{\\mathrm{th}}$ 和 $\\langle r \\rangle_t(K_{high})  r_{\\mathrm{th}}$。\n    - **二分法：** 一旦找到区间 $[K_{low}, K_{high}]$，就使用二分法来精化 $K_c$ 的估计值。这个迭代过程重复 $J=12$ 步。在每一步中，测试中点 $K_{mid} = (K_{low} + K_{high})/2$。如果 $\\langle r \\rangle_t(K_{mid})  r_{\\mathrm{th}}$，则新的上界变为 $K_{mid}$；否则，新的下界变为 $K_{mid}$。经过 $J$ 次迭代后，搜索区间的最终上界被作为 $K_c$ 的估计值。\n\n5.  **可复现性与实现**\n    为确保确定性和可复现的结果，对每个测试用例都为随机数生成器设置了种子。通过逆变换采样生成的自然频率 $\\omega_i$ 和初始相位 $\\theta_i(0)$，在每个测试用例中只生成一次，并在该用例的 $K$ 值扫描中的所有仿真中重复使用。此过程确保了观察到的 $\\langle r \\rangle_t$ 的变化仅由 $K$ 的变化引起，而非网络实现的随机变化。使用了 `numpy` 库的矢量化操作来高效地实现仿真。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Kuramoto critical coupling estimation problem for all test cases.\n    \"\"\"\n    \n    def get_time_avg_order_param(K, N, omega, theta_0, dt, T, T_trans):\n        \"\"\"\n        Simulates the Kuramoto model and calculates the time-averaged order parameter.\n        \"\"\"\n        theta = np.copy(theta_0)\n        num_steps = int(round(T / dt))\n        trans_steps = int(round(T_trans / dt))\n        r_sum = 0.0\n        \n        for step in range(num_steps):\n            # Calculate order parameter r and psi using complex numbers\n            z = np.mean(np.exp(1j * theta))\n            r = np.abs(z)\n            psi = np.angle(z)\n\n            # Update phases using the efficient mean-field form of Euler's method\n            d_theta = omega + K * r * np.sin(psi - theta)\n            theta += d_theta * dt\n            theta %= (2 * np.pi)  # Keep phases in [0, 2*pi)\n            \n            # Sum order parameter magnitude for averaging after transient\n            if step >= trans_steps:\n                r_sum += r\n        \n        avg_r = r_sum / (num_steps - trans_steps)\n        return avg_r\n\n    def find_critical_k(N, delta, seed):\n        \"\"\"\n        Performs the adaptive search for the critical coupling Kc.\n        \"\"\"\n        # --- Fixed parameters from problem spec ---\n        dt = 0.02\n        T = 25.0\n        T_trans = 10.0\n        c = 3.5\n        K_max = 6.0 * delta\n        M = 24\n        J = 12\n\n        # --- Setup network, initial conditions, and threshold ---\n        rng = np.random.default_rng(seed)\n        u = rng.random(N)\n        omega = delta * np.tan(np.pi * (u - 0.5))\n        theta_0 = rng.uniform(0, 2 * np.pi, N)\n        r_th = c / np.sqrt(N)\n        \n        # --- Phase 1: Coarse search to bracket the critical point ---\n        k_grid = np.linspace(0, K_max, M)\n        r_values = [get_time_avg_order_param(k, N, omega, theta_0, dt, T, T_trans) for k in k_grid]\n        \n        K_low, K_high = -1.0, -1.0\n        for i in range(M - 1):\n            if r_values[i] = r_th and r_values[i+1] > r_th:\n                K_low, K_high = k_grid[i], k_grid[i+1]\n                break\n        \n        # Handle cases where the transition is not bracketed in the initial scan\n        if K_low == -1.0:\n            if r_values[0] > r_th: return 0.0\n            if r_values[-1] = r_th: return K_max\n            return K_max # Fallback\n\n        # --- Phase 2: Bisection search to refine the estimate ---\n        for _ in range(J):\n            K_mid = (K_low + K_high) / 2\n            r_mid = get_time_avg_order_param(K_mid, N, omega, theta_0, dt, T, T_trans)\n            if r_mid > r_th:\n                K_high = K_mid\n            else:\n                K_low = K_mid\n        \n        return K_high\n\n    # --- Test Suite ---\n    test_cases = [\n        (256, 0.5, 1337),\n        (512, 1.0, 2021),\n        (1024, 2.0, 7),\n        (64, 0.2, 99)\n    ]\n    \n    results = [find_critical_k(*params) for params in test_cases]\n    \n    # --- Format and Print Final Output ---\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "现实世界中的振子，尤其是在大脑中，永远不会与噪声隔绝。这最后一个练习  将随机性引入到受迫振子模型中，从理想的完美锁相情况过渡到更真实的噪声引起的相位滑动（phase slips）场景。你将模拟一个随机微分方程，以观察随机波动如何使系统脱离其锁定状态，然后应用统计方法来量化这些重要的“滑动”事件的速率和方向。",
            "id": "4026105",
            "problem": "给定一个在加性高斯白噪声 (GWN) 下的弱驱动神经振子的随机相位模型。在弱耦合和近共振区域，振子与驱动之间的相位差 $\\,\\phi(t)\\,$ 可以由带噪声的 Adler 方程很好地近似，这是一个一阶随机微分方程 (SDE)：\n$$\n\\mathrm{d}\\phi(t) \\;=\\; \\big(\\Delta\\omega \\;-\\; K \\,\\sin\\phi(t)\\big)\\,\\mathrm{d}t \\;+\\; \\sigma\\,\\mathrm{d}W_t,\n$$\n其中 $\\,\\Delta\\omega\\,$ 是以弧度/秒为单位的失谐，$\\,K\\,$ 是以弧度/秒为单位的耦合强度，$\\,\\sigma\\,$ 是以弧度/根号秒为单位的噪声振幅，$\\,W_t\\,$ 是一个标准维纳过程。角度单位必须是弧度，时间单位必须是秒。\n\n您的任务是实现一个程序，对下方测试套件中的每一组参数，使用 Euler–Maruyama 方案模拟上述 SDE，并量化近锁定区域及其边界情况下的相位滑动统计数据。相位滑动定义为未绕卷相位差 $\\,\\phi(t)\\,$ 的 $\\,\\pm 2\\pi\\,$ 绕卷。为稳健地检测滑动，请使用绕卷指数\n$$\nN(t) \\;=\\; \\left\\lfloor \\frac{\\phi(t) + \\pi}{2\\pi} \\right\\rfloor,\n$$\n并将此指数随时间的正增量 $\\,\\Delta N > 0\\,$ 计为前向滑动，负增量 $\\,\\Delta N  0\\,$ 计为后向滑动。在开始计数前，请使用一个老化区间以使瞬态衰减。\n\n对于每组参数，您必须在老化区间之后计算以下三个统计量：\n- 每秒总滑动率，定义为 $\\,\\big(N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}\\big)/T_{\\mathrm{eff}}\\,$, 其中 $\\,N_{\\mathrm{fwd}}\\,$ 和 $\\,N_{\\mathrm{bwd}}\\,$ 分别是前向和后向滑动计数，$\\,T_{\\mathrm{eff}}\\,$ 是老化后的有效时间（以秒为单位）。\n- 前向滑动分数，定义为 $\\,N_{\\mathrm{fwd}}/\\big(N_{\\mathrm{fwd}}+N_{\\mathrm{bwd}}\\big)\\,$，并约定当 $\\,N_{\\mathrm{fwd}}+N_{\\mathrm{bwd}}=0\\,$ 时，其值为 $\\,0\\,$。\n- 每秒净绕卷率，定义为 $\\,\\big(N_{\\mathrm{fwd}} - N_{\\mathrm{bwd}}\\big)/T_{\\mathrm{eff}}\\,$。\n\n模拟要求：\n- 使用 Euler–Maruyama 更新规则离散化时间\n$$\n\\phi_{n+1} \\;=\\; \\phi_{n} \\;+\\; \\big(\\Delta\\omega \\;-\\; K\\sin\\phi_n\\big)\\,\\Delta t \\;+\\; \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n,\n$$\n其中 $\\,\\Delta t\\,$ 是以秒为单位的时间步长，$\\,\\xi_n \\sim \\mathcal{N}(0,1)\\,$ 是独立的标准正态随机变量。\n- 如果 $\\,|\\Delta\\omega|  K\\,$, 将 $\\,\\phi(0)\\,$ 初始化为稳定不动点 $\\,\\phi^\\star = \\arcsin(\\Delta\\omega/K)\\,$，否则初始化为 $\\,0\\,$。\n- 为保证可复现性，请使用指定的随机种子。\n- 角度单位必须是弧度，时间单位必须是秒。\n- 滑动率以秒的倒数表示，前向滑动分数以小数表示。\n- 将报告的每个浮点数四舍五入到恰好三位小数。\n\n测试套件：\n- 情况 $\\,1\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.12$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 老化时间 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 1$。\n- 情况 $\\,2\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.1$ rad/s, $\\sigma = 0.02$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 老化时间 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 2$。\n- 情况 $\\,3\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.2$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 老化时间 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 3$。\n- 情况 $\\,4\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.15$ rad/s, $\\sigma = 0.0$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 600$ s, 老化时间 $T_{\\mathrm{burn}} = 100$ s, 种子 $= 4$。\n- 情况 $\\,5\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.05$ rad/s, $\\sigma = 0.0$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 600$ s, 老化时间 $T_{\\mathrm{burn}} = 100$ s, 种子 $= 5$。\n- 情况 $\\,6\\,$：$\\Delta\\omega = 0.1$ rad/s, $K = 0.05$ rad/s, $\\sigma = 0.04$ rad/s$^{1/2}$, $\\Delta t = 0.01$ s, 总时长 $T = 1200$ s, 老化时间 $T_{\\mathrm{burn}} = 200$ s, 种子 $= 6$。\n\n最终输出规范：\n- 您的程序必须生成单行输出，其中包含一个由子列表组成的逗号分隔列表。每个子列表按顺序为 $[$总滑动率 (s$^{-1}$), 前向滑动分数, 净绕卷率 (s$^{-1}$)$]$，并四舍五入至三位小数。总输出必须是与测试套件顺序相同的单个列表。例如，两个假设情况的输出应如下所示：$[[0.012,0.600,0.004],[0.000,0.000,0.000]]$。",
            "solution": "该问题要求对带噪声的神经振子的随机 Adler 方程进行模拟，并随后计算相位滑动统计量。解决方案可根据随机微积分、数值方法和时间序列分析的原理分解为以下步骤。\n\n### 1. 问题阐述与模型\n系统的动力学由关于相位差 $\\phi(t)$ 的一阶随机微分方程 (SDE) 描述：\n$$\n\\mathrm{d}\\phi(t) = \\big(\\Delta\\omega - K \\sin\\phi(t)\\big)\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W_t\n$$\n此处，$\\phi(t)$ 是以弧度为单位的相位差，$\\Delta\\omega$ 是频率失谐 (rad/s)，$K$ 是耦合强度 (rad/s)，$\\sigma$ 是高斯白噪声的振幅 (rad/s$^{1/2}$)。项 $\\mathrm{d}W_t$ 代表标准维纳过程的一个增量。\n\n### 2. 数值模拟：Euler-Maruyama 方案\n为模拟此 SDE，我们以步长 $\\Delta t$ 对时间进行离散化。问题指定使用 Euler-Maruyama 方法，这是一种用于 SDE 的标准数值方案。相位 $\\phi$ 从时间步 $n$ 到 $n+1$ 的更新规则如下：\n$$\n\\phi_{n+1} = \\phi_{n} + \\big(\\Delta\\omega - K\\sin\\phi_n\\big)\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n\n$$\n其中 $\\phi_n$ 是在时间 $t_n = n\\Delta t$ 时的相位，$\\xi_n$ 是从标准正态分布 $\\mathcal{N}(0,1)$ 中抽取的独立随机变量。此更新规则在一个循环中实现，该循环的总步数对应于总模拟时长 $T$。为保证可复现性，随机数序列 $\\xi_n$ 使用一个为每个测试用例以特定种子初始化的伪随机数生成器生成。\n\n### 3. 初始条件\n模拟从初始相位 $\\phi_0 = \\phi(0)$ 开始。$\\phi_0$ 的选择取决于系统的确定性动力学（即 $\\sigma=0$ 的情况）。\n- 如果 $|\\Delta\\omega|  K$，系统存在一个稳定不动点，代表锁相状态。我们将系统初始化于此稳定点：$\\phi_0 = \\arcsin(\\Delta\\omega/K)$。\n- 如果 $|\\Delta\\omega| \\geq K$，系统不存在稳定不动点且相位会发生漂移。在此区域，使用中性初始条件 $\\phi_0 = 0$。\n\n### 4. 相位滑动的检测与计数\n一次相位滑动对应于未绕卷相位 $\\phi(t)$ 变化 $\\pm 2\\pi$ 的倍数。为稳健地检测这些事件，我们在每个时间步 $t_n$ 计算绕卷指数：\n$$\nN_n = \\left\\lfloor \\frac{\\phi_n + \\pi}{2\\pi} \\right\\rfloor\n$$\n连续时间步之间绕卷指数的变化 $\\Delta N = N_{n+1} - N_n$ 表明发生了一次或多次滑动。\n- 前向滑动对应于 $\\Delta N > 0$。\n- 后向滑动对应于 $\\Delta N  0$。\n\n在整个模拟过程中，会累积前向 ($N_{\\mathrm{fwd}}$) 和后向 ($N_{\\mathrm{bwd}}$) 滑动的计数。然而，计数仅在指定的老化周期 $T_{\\mathrm{burn}}$ 结束后才开始。这确保了在收集统计数据之前，任何初始瞬态都已衰减，并且系统已进入其稳态或准稳态行为。\n\n### 5. 统计量计算\n模拟完成后，收集到的滑动计数被用于计算在有效模拟时间 $T_{\\mathrm{eff}} = T - T_{\\mathrm{burn}}$ 内的三个关键统计量：\n1.  **总滑动率**：该指标衡量滑动事件的总频率，不分方向。其计算公式为：\n    $$ \\text{Rate}_{\\text{total}} = \\frac{N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}}{T_{\\mathrm{eff}}} $$\n2.  **前向滑动分数**：该指标量化了滑动的方向偏置。它是前向滑动次数与总滑动次数的比率：\n    $$ F_{\\text{fwd}} = \\begin{cases} \\frac{N_{\\mathrm{fwd}}}{N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}}}  \\text{if } N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}} > 0 \\\\ 0  \\text{if } N_{\\mathrm{fwd}} + N_{\\mathrm{bwd}} = 0 \\end{cases} $$\n3.  **净绕卷率**：该指标衡量相位的平均漂移率，单位为“滑动次数/秒”。其计算公式为：\n    $$ \\text{Rate}_{\\text{net}} = \\frac{N_{\\mathrm{fwd}} - N_{\\mathrm{bwd}}}{T_{\\mathrm{eff}}} $$\n\n### 6. 实现\n整个算法在一个 Python 函数中实现。该函数遍历测试套件中提供的每一组参数。对于每一组参数，它都如上所述运行模拟，执行滑动分析，并计算所需的三个统计量。最终结果被收集并按照问题要求格式化为单个字符串，其中每个数值都四舍五入到三位小数。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stochastic Adler equation problem for all specified test cases.\n    \"\"\"\n\n    def calculate_slip_statistics(params):\n        \"\"\"\n        Simulates the stochastic Adler equation for one set of parameters\n        and computes the required phase slip statistics.\n        \"\"\"\n        delta_omega, K, sigma, dt, T, T_burn, seed = params\n\n        # --- Setup ---\n        num_steps = int(round(T / dt))\n        burn_in_steps = int(round(T_burn / dt))\n        rng = np.random.default_rng(seed)\n\n        # --- Initial Condition ---\n        if np.abs(delta_omega)  K and K > 0:\n            phi_0 = np.arcsin(delta_omega / K)\n        else:\n            phi_0 = 0.0\n\n        # --- Simulation (vectorized for efficiency) ---\n        # Generate all random numbers at once\n        xi_all = rng.standard_normal(num_steps)\n        \n        # Pre-allocate phase history array\n        phi_history = np.zeros(num_steps + 1)\n        phi_history[0] = phi_0\n        \n        # Euler-Maruyama integration loop\n        for n in range(num_steps):\n            phi = phi_history[n]\n            drift_term = (delta_omega - K * np.sin(phi)) * dt\n            noise_term = sigma * np.sqrt(dt) * xi_all[n]\n            phi_history[n+1] = phi + drift_term + noise_term\n            \n        # --- Slip Counting ---\n        # Calculate winding index over the entire history\n        winding_indices = np.floor((phi_history + np.pi) / (2 * np.pi))\n        \n        # Analyze only the part after the burn-in period\n        analysis_indices = winding_indices[burn_in_steps:]\n        \n        # Calculate changes between consecutive steps in the analysis window\n        deltas = np.diff(analysis_indices)\n        \n        # Sum up positive (forward) and negative (backward) changes\n        N_fwd = np.sum(deltas[deltas > 0])\n        N_bwd = -np.sum(deltas[deltas  0])\n\n        # --- Calculate Final Statistics ---\n        T_eff = T - T_burn\n        if T_eff = 0:\n            return [0.0, 0.0, 0.0]\n\n        total_slips = N_fwd + N_bwd\n        total_slip_rate = total_slips / T_eff\n        net_winding_rate = (N_fwd - N_bwd) / T_eff\n\n        # Forward-slip fraction with convention for zero total slips\n        if total_slips > 0:\n            fwd_slip_fraction = N_fwd / total_slips\n        else:\n            fwd_slip_fraction = 0.0\n            \n        return [total_slip_rate, fwd_slip_fraction, net_winding_rate]\n\n    # --- Test Suite ---\n    test_cases = [\n        # (Δω, K, σ, Δt, T, T_burn, seed)\n        (0.1, 0.12, 0.04, 0.01, 1200, 200, 1),\n        (0.1, 0.1,  0.02, 0.01, 1200, 200, 2),\n        (0.1, 0.2,  0.04, 0.01, 1200, 200, 3),\n        (0.1, 0.15, 0.0,  0.01, 600,  100, 4),\n        (0.1, 0.05, 0.0,  0.01, 600,  100, 5),\n        (0.1, 0.05, 0.04, 0.01, 1200, 200, 6),\n    ]\n\n    all_results = [calculate_slip_statistics(case) for case in test_cases]\n\n    # --- Format Output ---\n    formatted_sublists = []\n    for sublist in all_results:\n        formatted_nums = [f\"{num:.3f}\" for num in sublist]\n        formatted_sublists.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_sublists)}]\"\n    print(final_output_str)\n\nsolve()\n```"
        }
    ]
}