{
    "hands_on_practices": [
        {
            "introduction": "平衡网络模型的一个基石是平均兴奋性输入和抑制性输入的抵消。这个练习将引导你通过一个直接的计算，来确定实现这种理想平衡所需的精确抑制突触强度 $g^{\\ast}$ 。通过这个计算，你将从第一性原理层面理解该模型的核心机制——即网络如何通过精巧的参数调谐来维持一个动态平衡的平均输入。",
            "id": "3966912",
            "problem": "考虑一个Brunel平衡网络模型中的大型稀疏循环网络，该网络由兴奋性神经元和抑制性神经元组成，并由外部泊松输入驱动。每个突触前脉冲产生瞬时的突触后膜电位变化，该变化被建模为一个固定幅度的跳变。兴奋性突触贡献幅度为$J$的正向跳变，抑制性突触贡献幅度为$-gJ$的负向跳变，其中$g$是表征抑制性突触与兴奋性突触相对强度的无量纲比率，外部输入贡献幅度为$J_{ext}$的正向跳变。突触前脉冲序列被建模为独立的齐次泊松过程。\n\n从齐次泊松过程的定义和独立散粒噪声过程的线性叠加出发，推导一个代表性神经元单位时间的净平均输入的表达式，该表达式为来自兴奋性、抑制性和外部来源的期望增量之和。施加单位时间净平均输入为零的平均平衡条件，并求解使净平均输入为零的抑制性强度比率$g^{\\ast}$。\n\n使用以下与Brunel模型一致的、科学上合理的参数：\n- 兴奋性突触幅度: $J = 0.1 \\mathrm{mV}$。\n- 外部突触幅度: $J_{ext} = 0.08 \\mathrm{mV}$。\n- 兴奋性突触前伙伴数量: $K_{E} = 800$。\n- 抑制性突触前伙伴数量: $K_{I} = 200$。\n- 外部突触前输入数量: $K_{ext} = 800$。\n- 兴奋性突触前神经元的平均发放率: $\\nu_{E} = 4 \\mathrm{Hz}$。\n- 抑制性突触前神经元的平均发放率: $\\nu_{I} = 6 \\mathrm{Hz}$。\n- 外部突触前输入的平均发放率: $\\nu_{ext} = 4 \\mathrm{Hz}$。\n\n计算满足平均平衡要求的$g^{\\ast}$。将最终值表示为无量纲标量，并将您的答案四舍五入到4位有效数字。",
            "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 问题验证\n**步骤1：提取已知条件**\n- 模型：一个基于Brunel平衡网络模型的大型稀疏循环网络。\n- 神经元类型：兴奋性和抑制性。\n- 输入：外部泊松输入。\n- 突触机制：突触前脉冲产生固定幅度的瞬时突触后电位跳变。\n- 兴奋性突触幅度：$J$。\n- 抑制性突触幅度：$-gJ$，其中$g$是相对强度比率。\n- 外部突触幅度：$J_{ext}$。\n- 脉冲序列模型：独立的齐次泊松过程。\n- 任务：推导单位时间的净平均输入，施加平均平衡条件（$\\text{净平均输入} = 0$），并求解抑制性强度比率$g^{\\ast}$。\n- 参数：\n    - $J = 0.1\\,\\mathrm{mV}$\n    - $J_{ext} = 0.08\\,\\mathrm{mV}$\n    - $K_{E} = 800$（兴奋性突触前伙伴数量）\n    - $K_{I} = 200$（抑制性突触前伙伴数量）\n    - $K_{ext} = 800$（外部突触前输入数量）\n    - $\\nu_{E} = 4\\,\\mathrm{Hz}$（兴奋性神经元的平均发放率）\n    - $\\nu_{I} = 6\\,\\mathrm{Hz}$（抑制性神经元的平均发放率）\n    - $\\nu_{ext} = 4\\,\\mathrm{Hz}$（外部输入的平均发放率）\n- 最终计算：计算$g^{\\ast}$并四舍五入到4位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是计算神经科学领域一个标准的、典型的练习，植根于Brunel（2000）关于平衡皮层网络的基础模型。所有概念，包括泊松过程、突触整合以及兴奋和抑制的平衡，都是已被广泛接受的原则。所提供的参数被明确表述为“科学上合理的”，并且与文献中用于建模皮层回路的值一致。\n- **良态问题：** 问题陈述清晰。它提供了所有必要的参数和一个精确的条件（平均平衡），以推导出一个唯一的解析表达式，并随后计算出$g^{\\ast}$的单个数值。\n- **客观性：** 该问题用客观的、数学的语言表达，没有任何主观或模糊的术语。\n\n**步骤3：结论与行动**\n该问题在科学上是合理的，问题是良态的、客观的且完整的。因此，它被判定为**有效**。现在开始求解过程。\n\n### 推导与求解\n一个代表性神经元的总传入输入是来自三个不同群体的输入之和：循环兴奋性群体、循环抑制性群体和外部兴奋性群体。来自每个源的突触前脉冲序列被建模为独立的齐次泊松过程。\n\n对于一个以平均速率$\\nu$作为泊松过程发放的单一源，在微小时间间隔$dt$内，期望的脉冲数为$\\nu dt$。如果每个脉冲引起幅度为$A$的突触后电位变化，则在此时间间隔$dt$内，来自该单一源的膜电位期望变化为$A(\\nu dt)$。因此，来自该源的单位时间平均输入为$A\\nu$。\n\n基于独立脉冲序列的假设，单位时间的总平均输入（我们记为$\\mu_{net}$）是来自所有突触前伙伴的平均输入的线性叠加。\n\n1.  **来自兴奋性群体的平均输入($\\mu_E$)**：有$K_E$个兴奋性突触前伙伴，每个伙伴以$\\nu_E$的平均速率发放。每个兴奋性脉冲引起幅度为$J$的电位跳变。来自该群体的单位时间总平均输入是所有$K_E$个神经元贡献的总和：\n    $$ \\mu_E = K_E \\nu_E J $$\n\n2.  **来自抑制性群体的平均输入($\\mu_I$)**：有$K_I$个抑制性突触前伙伴，每个伙伴以$\\nu_I$的平均速率发放。每个抑制性脉冲引起幅度为$-gJ$的电位跳变。来自该群体的单位时间总平均输入是：\n    $$ \\mu_I = K_I \\nu_I (-gJ) = -g K_I \\nu_I J $$\n\n3.  **来自外部群体的平均输入($\\mu_{ext}$)**：有$K_{ext}$个外部输入，每个输入以$\\nu_{ext}$的平均速率发放。每个外部脉冲引起幅度为$J_{ext}$的电位跳变。来自该群体的单位时间总平均输入是：\n    $$ \\mu_{ext} = K_{ext} \\nu_{ext} J_{ext} $$\n\n单位时间的净平均输入$\\mu_{net}$是这三个分量的和：\n$$ \\mu_{net} = \\mu_E + \\mu_I + \\mu_{ext} = K_E \\nu_E J - g K_I \\nu_I J + K_{ext} \\nu_{ext} J_{ext} $$\n该表达式代表了神经元单位时间的净平均输入。\n\n平均平衡条件要求这个净平均输入为零。我们将满足此条件的$g$的特定值记为$g^{\\ast}$。\n$$ \\mu_{net} = K_E \\nu_E J - g^{\\ast} K_I \\nu_I J + K_{ext} \\nu_{ext} J_{ext} = 0 $$\n\n我们求解该方程以得到$g^{\\ast}$：\n$$ g^{\\ast} K_I \\nu_I J = K_E \\nu_E J + K_{ext} \\nu_{ext} J_{ext} $$\n$$ g^{\\ast} = \\frac{K_E \\nu_E J + K_{ext} \\nu_{ext} J_{ext}}{K_I \\nu_I J} $$\n\n现在，我们代入所提供的数值：\n- $J = 0.1$\n- $J_{ext} = 0.08$\n- $K_E = 800$\n- $K_I = 200$\n- $K_{ext} = 800$\n- $\\nu_E = 4$\n- $\\nu_I = 6$\n- $\\nu_{ext} = 4$\n\n将这些值代入$g^{\\ast}$的表达式中：\n$$ g^{\\ast} = \\frac{(800)(4)(0.1) + (800)(4)(0.08)}{(200)(6)(0.1)} $$\n\n首先，计算分子：\n$$ \\text{分子} = (3200)(0.1) + (3200)(0.08) = 320 + 256 = 576 $$\n\n接下来，计算分母：\n$$ \\text{分母} = (1200)(0.1) = 120 $$\n\n最后，计算比率：\n$$ g^{\\ast} = \\frac{576}{120} = 4.8 $$\n\n问题要求答案四舍五入到4位有效数字。精确值$4.8$写作$4.800$以满足此要求。",
            "answer": "$$\\boxed{4.800}$$"
        },
        {
            "introduction": "在真实的神经网络中，神经元接收到的输入不仅有平均成分，还有显著的波动，并且神经元本身的响应是非线性的。本练习将带你超越简化的平均场平衡概念，通过编写程序来寻找网络完整的自洽工作点（即异步不规则固定点）。在这一固定点上，网络产生的发放率所导致的突触输入，能够反过来精确地维持同样的发放率，这个过程将让你掌握计算神经科学中一种强大的数值求解方法。",
            "id": "3966869",
            "problem": "您的任务是实现一个完整的程序，该程序针对 Brunel 平衡网络模型，通过迭代单神经元传递函数直至收敛，来为一组参数配置计算异步不规则（AI）不动点。该网络包含两个同质群体：兴奋性群体和抑制性群体，每个群体都建模为漏泄整合发放（LIF）神经元，接收来自兴奋性神经元、抑制性神经元和外部泊松源的输入。AI 不动点被定义为自洽的稳态发放率对 $\\left(r_E, r_I\\right)$，其中每个群体的输出发放率等于在当前所有源产生的所有突触输入的均值和方差下，由单神经元传递函数预测的发放率。\n\n您的程序必须遵循以下模型假设和基本依据：\n\n- 神经元动力学由漏泄整合发放（LIF）模型控制，该模型具有恒定的膜时间常数、在重置电位下的硬重置以及绝对不应期。\n- 每个神经元的输入是许多独立脉冲序列（兴奋性、抑制性和外部）的叠加，根据中心极限定理，这被近似为一个具有明确均值和方差的高斯白噪声驱动。\n- 在高斯白噪声输入下，LIF 神经元的单神经元稳态发放率（传递函数）是通过膜电位首次穿越阈值的公式，并加上一个绝对不应期得到的。\n- 连接是随机且同质的。每个神经元平均接收 $K_E = p_E N_E$ 个兴奋性输入和 $K_I = p_I N_I$ 个抑制性输入；外部输入由 $K_{\\mathrm{ext}}$ 个独立的泊松源以速率 $\\nu_{\\mathrm{ext}}$ 组成。\n\n定义和参数化：\n\n- $N_E$ 和 $N_I$ 分别是兴奋性群体和抑制性群体的大小。\n- $p_E$ 和 $p_I$ 分别是来自兴奋性群体和抑制性群体的连接概率。\n- $J$ 是兴奋性突触效能，单位为毫伏；抑制性突触的效能为 $-g J$，其中 $g > 0$。\n- $\\tau_m$ 是膜时间常数，单位为秒。\n- $\\theta$ 是发放阈值，单位为毫伏。\n- $V_r$ 是重置电位，单位为毫伏。\n- $\\tau_{\\mathrm{ref}}$ 是绝对不应期，单位为秒。\n- $K_{\\mathrm{ext}}$ 是每个神经元的外部泊松输入数量。\n- $\\nu_{\\mathrm{ext}}$ 是外部泊松速率，单位为 $\\mathrm{s}^{-1}$。\n- AI 不动点是满足以下条件的率对 $\\left(r_E, r_I\\right)$（单位为 $\\mathrm{s}^{-1}$）：将 LIF 传递函数应用于每个群体的输入统计量，会产生相同的发放率。\n\n实现要求：\n\n- 对于每个测试用例，使用具有瞬时突触的扩散近似，计算来自其源的兴奋性和抑制性神经元的总突触输入的均值和方差。您必须使用基于参数 $\\left(N_E, N_I, p_E, p_I, J, g, \\tau_m, \\theta, V_r, \\tau_{\\mathrm{ref}}, K_{\\mathrm{ext}}, \\nu_{\\mathrm{ext}}\\right)$ 和当前发放率 $\\left(r_E, r_I\\right)$ 的科学上一致的输入均值和方差表达式。\n- 实现 LIF 传递函数，将输入均值和方差映射到稳态发放率。对于高斯输入下的 LIF 神经元，请使用数值稳定的首次穿越时间积分形式。\n- 使用带松弛的不动点迭代来更新 $\\left(r_E, r_I\\right)$ 直至收敛。收敛标准：连续迭代之间率的最大绝对变化小于 $10^{-9}$ $\\mathrm{s}^{-1}$，或达到最大迭代次数 $200$ 次。使用在开区间 $(0, 1)$ 内的松弛系数。\n- 最终输出中的所有发放率必须以 $\\mathrm{s}^{-1}$ 表示。\n\n测试套件：\n\n您的程序必须为以下三组参数求解 AI 不动点。对于每一组，从初始猜测 $r_E^{(0)} = r_I^{(0)} = \\nu_{\\mathrm{ext}}$ 开始迭代。\n\n- 测试用例 1（典型平衡态）：\n  - $N_E = 4000$， $N_I = 1000$， $p_E = 0.1$， $p_I = 0.1$， $J = 0.1$ $\\mathrm{mV}$， $g = 5$， $\\tau_m = 0.02$ $\\mathrm{s}$， $\\theta = 20$ $\\mathrm{mV}$， $V_r = 10$ $\\mathrm{mV}$， $\\tau_{\\mathrm{ref}} = 0.002$ $\\mathrm{s}$， $K_{\\mathrm{ext}} = 1000$， $\\nu_{\\mathrm{ext}} = 10$ $\\mathrm{s}^{-1}$。\n- 测试用例 2（弱突触，更强抑制和更强外部驱动）：\n  - $N_E = 8000$， $N_I = 2000$， $p_E = 0.05$， $p_I = 0.05$， $J = 0.05$ $\\mathrm{mV}$， $g = 6$， $\\tau_m = 0.02$ $\\mathrm{s}$， $\\theta = 20$ $\\mathrm{mV}$， $V_r = 10$ $\\mathrm{mV}$， $\\tau_{\\mathrm{ref}} = 0.002$ $\\mathrm{s}$， $K_{\\mathrm{ext}} = 1200$， $\\nu_{\\mathrm{ext}} = 12$ $\\mathrm{s}^{-1}$。\n- 测试用例 3（减少外部驱动，中等抑制）：\n  - $N_E = 4000$， $N_I = 1000$， $p_E = 0.1$， $p_I = 0.1$， $J = 0.1$ $\\mathrm{mV}$， $g = 4$， $\\tau_m = 0.02$ $\\mathrm{s}$， $\\theta = 20$ $\\mathrm{mV}$， $V_r = 10$ $\\mathrm{mV}$， $\\tau_{\\mathrm{ref}} = 0.002$ $\\mathrm{s}$， $K_{\\mathrm{ext}} = 800$， $\\nu_{\\mathrm{ext}} = 8$ $\\mathrm{s}^{-1}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是相应测试用例的率对 $\\left[r_E, r_I\\right]$，以 $\\mathrm{s}^{-1}$ 表示。例如，输出格式必须是 $\\left[\\left[r_{E,1},r_{I,1}\\right],\\left[r_{E,2},r_{I,2}\\right],\\left[r_{E,3},r_{I,3}\\right]\\right]$，不含任何额外文本。",
            "solution": "用户提供的问题是计算神经科学领域一个有效且适定的任务。它要求数值计算 Brunel 网络模型的稳态（异步不规则不动点）。问题陈述在科学上是有根据的、内部一致的，并提供了所有必要的参数和方法论约束，以得出一个唯一的、可验证的解。\n\n问题的核心是找到一对发放率 $(r_E, r_I)$，分别对应兴奋性群体和抑制性群体，这对发放率是自洽的。这意味着，如果网络群体以这些速率发放，那么输入到任何给定神经元的突触输入，必须反过来产生一个等于所假设的输出发放率。这个自洽条件定义了一个不动点问题。\n\n求解过程主要分为三个阶段：\n1.  **突触输入建模**：神经元的总突触输入被近似为一个高斯白噪声过程。这是“扩散近似”，其合理性基于中心极限定理，即神经元接收大量独立的脉冲序列。输入完全由其均值 ($\\mu$) 和方差 ($\\sigma^2$) 表征。\n2.  **神经元传递函数**：单个漏泄整合发放（LIF）神经元对此统计输入的响应由一个传递函数 $\\Phi(\\mu, \\sigma)$ 捕获，该函数给出神经元的稳态输出发放率。该函数源于神经元膜电位首次穿越发放阈值的平均时间。\n3.  **不动点迭代**：通过迭代应用传递函数来找到不动点速率 $(r_E, r_I)$。从一个初始猜测开始，计算当前速率产生的输入统计量 $(\\mu, \\sigma^2)$，然后使用传递函数找到更新后的速率，并重复此过程直到速率收敛。\n\n让我们将这些步骤形式化。\n\n**1. 输入统计量 $(\\mu, \\sigma^2)$**\n\n任一群（E 或 I）中的一个神经元接收来自 $K_E = p_E N_E$ 个以速率 $r_E$ 发放的兴奋性神经元、 $K_I = p_I N_I$ 个以速率 $r_I$ 发放的抑制性神经元，以及 $K_{\\mathrm{ext}}$ 个以速率 $\\nu_{\\mathrm{ext}}$ 发放的外部神经元的输入。\n突触效能分别为 $J$（兴奋性）、$-gJ$（抑制性）和 $J$（外部）。动力学用瞬时突触来描述。\n在扩散近似下，平均输入电位 $\\mu_V$ 及其方差 $\\sigma_V^2$ 为：\n$$\n\\mu_V(r_E, r_I) = \\tau_m \\left( (p_E N_E) J r_E - (p_I N_I) g J r_I + K_{\\mathrm{ext}} J \\nu_{\\mathrm{ext}} \\right)\n$$\n$$\n\\sigma_V^2(r_E, r_I) = \\tau_m \\left( (p_E N_E) J^2 r_E + (p_I N_I) (-gJ)^2 r_I + K_{\\mathrm{ext}} J^2 \\nu_{\\mathrm{ext}} \\right)\n$$\n由于问题规定连接概率 ($p_E, p_I$) 仅取决于源群体而非目标群体，且所有其他参数 ($J, g, K_{\\mathrm{ext}}, \\nu_{\\mathrm{ext}}$) 也是全局的，因此兴奋性神经元和抑制性神经元的输入统计量是相同的。我们将其表示为 $\\mu(r_E, r_I)$ 和 $\\sigma^2(r_E, r_I)$。\n$$\n\\mu(r_E, r_I) = \\tau_m J (p_E N_E r_E - g p_I N_I r_I + K_{\\mathrm{ext}} \\nu_{\\mathrm{ext}})\n$$\n$$\n\\sigma^2(r_E, r_I) = \\tau_m J^2 (p_E N_E r_E + g^2 p_I N_I r_I + K_{\\mathrm{ext}} \\nu_{\\mathrm{ext}})\n$$\n\n**2. LIF 传递函数 $\\Phi(\\mu, \\sigma)$**\n\nLIF 神经元的稳态发放率 $\\nu$ 是平均首次穿越时间与绝对不应期 $\\tau_{\\mathrm{ref}}$ 之和的倒数。平均首次穿越时间 $\\langle T \\rangle$ 由 Siegert 公式给出：\n$$\n\\langle T \\rangle = \\tau_m \\sqrt{\\pi} \\int_{\\frac{V_r - \\mu}{\\sigma}}^{\\frac{\\theta - \\mu}{\\sigma}} e^{x^2} (1 + \\mathrm{erf}(x)) dx\n$$\n其中 $\\theta$ 是阈值， $V_r$ 是重置电位， $\\mathrm{erf}(x)$ 是误差函数。发放率则为：\n$$\n\\nu = \\Phi(\\mu, \\sigma) = \\left( \\tau_{\\mathrm{ref}} + \\langle T \\rangle \\right)^{-1}\n$$\n此积分必须进行数值计算。需要小心处理，因为如果积分上限 $(\\theta - \\mu)/\\sigma$ 是大的正数， $e^{x^2}$ 项可能导致溢出。这对应于平均输入 $\\mu$ 远低于阈值 $\\theta$ 的情况，此时发放率几乎为零。我们实现了一个检查来处理这种情况，直接返回零速率。对于零噪声（$\\sigma \\to 0$）的特殊情况也进行了处理。\n\n**3. 不动点迭代**\n\n我们寻求满足自洽方程的速率 $(r_E, r_I)$：\n$$\nr_E = \\Phi(\\mu(r_E, r_I), \\sigma(r_E, r_I))\n$$\n$$\nr_I = \\Phi(\\mu(r_E, r_I), \\sigma(r_E, r_I))\n$$\n如前所述，输入统计量以及传递函数的输出对于两个群体都是相同的。如果我们以 $r_E^{(0)} = r_I^{(0)}$ （按问题规定，使用 $\\nu_{\\mathrm{ext}}$）开始迭代，所有后续的迭代结果也将有 $r_E^{(k)} = r_I^{(k)}$。因此，问题简化为求解单个不动点速率 $r = r_E = r_I$。\n\n迭代方案如下：\n1.  初始化 $r^{(0)} = \\nu_{\\mathrm{ext}}$。\n2.  对于 $k=0, 1, 2, ...$：\n    a. 计算 $\\mu_k = \\mu(r^{(k)}, r^{(k)})$ 和 $\\sigma_k = \\sqrt{\\sigma^2(r^{(k)}, r^{(k)})}$。\n    b. 计算候选新速率 $r'_{new} = \\Phi(\\mu_k, \\sigma_k)$。\n    c. 使用松弛法更新速率以提高稳定性： $r^{(k+1)} = (1-\\alpha) r^{(k)} + \\alpha r'_{new}$，其中 $\\alpha \\in (0,1)$ 是松弛系数（选择为 $0.5$）。\n3.  当 $|r^{(k+1)} - r^{(k)}|  10^{-9}$ 或达到 $200$ 次迭代后停止。\n\n最终收敛的速率 $r$ 给出了解 $[r_E, r_I] = [r, r]$。此过程将应用于测试套件中提供的每一组参数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.integrate import quad\n\ndef lif_transfer_function(mu, sigma, tau_m, V_r, theta, tau_ref):\n    \"\"\"\n    Calculates the stationary firing rate of a Leaky Integrate-and-Fire (LIF) neuron\n    driven by Gaussian white noise.\n\n    Args:\n        mu (float): Mean input potential (mV).\n        sigma (float): Standard deviation of input potential fluctuations (mV).\n        tau_m (float): Membrane time constant (s).\n        V_r (float): Reset potential (mV).\n        theta (float): Firing threshold (mV).\n        tau_ref (float): Absolute refractory period (s).\n\n    Returns:\n        float: The stationary firing rate in s^-1.\n    \"\"\"\n    # Handle the deterministic (zero noise) case\n    if sigma  1e-12:\n        if mu = theta:\n            return 0.0\n        else:\n            # Rate for constant super-threshold input\n            t_isi = tau_ref + tau_m * np.log((mu - V_r) / (mu - theta))\n            # Avoid division by zero or negative ISI\n            if t_isi = 1e-12: return 1e9  # Effectively infinite rate, capped\n            return 1.0 / t_isi\n\n    # Define integration bounds for the first-passage time formula\n    low_bound = (V_r - mu) / sigma\n    high_bound = (theta - mu) / sigma\n\n    # If the mean input is far below threshold, the rate is effectively zero.\n    # This also prevents numerical overflow from exp(x^2) for large positive x.\n    if high_bound > 8: # A conservative heuristic cutoff\n        return 0.0\n        \n    # The integrand in the Siegert formula for the mean first-passage time\n    integrand = lambda x: np.exp(x**2) * (1.0 + erf(x))\n    \n    try:\n        integral_val, _ = quad(integrand, low_bound, high_bound)\n    except Exception:\n        # In case of integration failure, assume a negligible rate\n        return 0.0\n\n    # Mean first-passage time\n    tau_fp = tau_m * np.sqrt(np.pi) * integral_val\n    \n    # Total mean inter-spike interval\n    mean_isi = tau_ref + tau_fp\n    \n    # Avoid division by zero or negative ISI (due to numerical inaccuracies)\n    if mean_isi = 1e-12:\n        return 1e9  # Capped \"infinite\" rate for safety\n        \n    rate = 1.0 / mean_isi\n    \n    return rate\n\ndef solve_fixed_point_brunel(params):\n    \"\"\"\n    Solves for the AI fixed-point of the Brunel network model using fixed-point iteration.\n    \"\"\"\n    # Unpack model parameters\n    N_E, N_I, p_E, p_I, J, g, tau_m, theta, V_r, tau_ref, K_ext, nu_ext = params\n\n    # Iteration control parameters\n    max_iter = 200\n    tolerance = 1e-9\n    relaxation = 0.5  # Relaxation coefficient for stability\n\n    # As derived in the solution, the input statistics for E and I populations\n    # are identical, leading to r_E = r_I at the fixed point. We solve for a single rate `r`.\n    r = float(nu_ext) # Initial guess\n\n    # Pre-calculate constant connection numbers\n    K_E_conn = p_E * N_E\n    K_I_conn = p_I * N_I\n\n    for _ in range(max_iter):\n        r_old = r\n        \n        # Calculate mean and variance of the input potential based on current rate `r`\n        mu_r_term = K_E_conn * r - g * K_I_conn * r\n        sigma_sq_r_term = K_E_conn * r + (g**2) * K_I_conn * r\n        \n        ext_input_mean_contrib = K_ext * nu_ext\n        ext_input_var_contrib = K_ext * nu_ext\n        \n        mu = tau_m * J * (mu_r_term + ext_input_mean_contrib)\n        sigma_sq = tau_m * J**2 * (sigma_sq_r_term + ext_input_var_contrib)\n        \n        sigma = np.sqrt(sigma_sq) if sigma_sq > 0 else 0.0\n        \n        # Compute the new candidate rate from the transfer function\n        r_new_candidate = lif_transfer_function(mu, sigma, tau_m, V_r, theta, tau_ref)\n        \n        # Apply relaxation to the update step\n        r = (1.0 - relaxation) * r_old + relaxation * r_new_candidate\n        \n        # Check for convergence\n        if abs(r - r_old)  tolerance:\n            break\n    \n    # The fixed-point rates for E and I populations are the same\n    return [r, r]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N_E, N_I, p_E, p_I, J, g, tau_m, theta, V_r, tau_ref, K_ext, nu_ext)\n        (4000, 1000, 0.1, 0.1, 0.1, 5.0, 0.02, 20.0, 10.0, 0.002, 1000, 10.0),\n        (8000, 2000, 0.05, 0.05, 0.05, 6.0, 0.02, 20.0, 10.0, 0.002, 1200, 12.0),\n        (4000, 1000, 0.1, 0.1, 0.1, 4.0, 0.02, 20.0, 10.0, 0.002, 800, 8.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Calculate the fixed-point rates for the current case.\n        result = solve_fixed_point_brunel(case)\n        results.append(result)\n\n    # Format the results into the exact required string format.\n    results_str_list = [f\"[{r_e},{r_i}]\" for r_e, r_i in results]\n    final_output = f\"[{','.join(results_str_list)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "找到了一个网络状态的固定点，但这并不意味着故事的结束；我们还必须确定这个状态是否稳定。这个最终练习将向你介绍包含时间延迟的系统线性稳定性分析，这是一个关键工具，用于判断我们找到的平衡态是否能在微小扰动下得以维持 。通过求解系统的特征方程，你将学会如何判断网络是会回归平衡，还是会演化出振荡等其他复杂的动态行为。",
            "id": "3966918",
            "problem": "考虑在群体发放率水平上建模的Brunel平衡网络模型围绕一个异步不动点的线性化。令 $W \\in \\mathbb{C}^{n \\times n}$ 表示 $n$ 个群体（兴奋性和抑制性）之间的有效突触连接矩阵，令 $g \\in \\mathbb{R}$ 是通过对脉冲发放群体的输入输出关系进行线性化得到的恒定神经元传递函数增益。假设所有连接共享一个均匀的轴突和突触传输延迟 $D > 0$。在群体发放率的微小扰动 $\\delta r(t)$ 下，线性化的延迟系统可以表示为\n$$\n\\delta r(t) - g\\,W\\,\\delta r(t-D) = 0.\n$$\n寻求形如 $\\delta r(t) = v e^{\\lambda t}$（其中 $v \\neq 0$）的模态解，可导出特征方程\n$$\n\\det\\!\\left(I - g\\,W\\,e^{-\\lambda D}\\right) = 0,\n$$\n其中 $I$ 是单位矩阵，$\\lambda \\in \\mathbb{C}$ 是延迟线性化系统的一个特征值，$e^{-\\lambda D}$ 被理解为角度以弧度计的复指数。当且仅当所有特征根 $\\lambda$ 的实部 $\\mathrm{Re}(\\lambda)  0$ 时，系统是线性稳定的；如果存在至少一个 $\\lambda$ 使得 $\\mathrm{Re}(\\lambda) > 0$，则系统不稳定。实部 $\\mathrm{Re}(\\lambda) = 0$ 的临界情况不被视为稳定。\n\n从带有时滞的线性系统的基本原理和上述特征方程出发，实现一个程序，对每个测试用例：\n- 在有界的虚频率窗口 $|\\mathrm{Im}(\\lambda)| \\leq \\Omega_{\\max}$ 内，计算特征方程所蕴含的所有特征值 $\\lambda \\in \\mathbb{C}$，其中角度以弧度为单位。\n- 严格按照上文所述，根据实部 $\\mathrm{Re}(\\lambda)$ 来解释稳定性。\n\n使用以下测试套件，其中矩阵以列表的列表形式给出。所有延迟 $D$ 的单位必须是秒，$g$ 是无量纲的，$\\Omega_{\\max}$ 是以弧度/秒为单位的角频率界限。\n\n测试用例：\n1. $W = \\begin{bmatrix}0.6  0.0 \\\\ 0.0  -0.7\\end{bmatrix}$，$g = 0.8$，$D = 0.003$ 秒，$\\Omega_{\\max} = 6000$ 弧度/秒。\n2. $W = \\begin{bmatrix}1.6  0.0 \\\\ 0.0  -0.9\\end{bmatrix}$，$g = 0.9$，$D = 0.004$ 秒，$\\Omega_{\\max} = 6000$ 弧度/秒。\n3. $W = \\begin{bmatrix}1.25  0.0 \\\\ 0.0  0.0\\end{bmatrix}$，$g = 0.8$，$D = 0.005$ 秒，$\\Omega_{\\max} = 6000$ 弧度/秒。\n4. $W = \\begin{bmatrix}0.5  -0.8 \\\\ 0.8  0.5\\end{bmatrix}$，$g = 0.9$，$D = 0.0025$ 秒，$\\Omega_{\\max} = 8000$ 弧度/秒。\n\n计算和输出要求：\n- 对每个测试用例，将连接性视为 $g\\,W$，并在指定的虚部界限内计算所有特征根 $\\lambda$。您的算法必须考虑到由延迟引起的复对数的多值性，确保窗口内的所有解的分支都被覆盖。\n- 通过检查所有计算出的 $\\lambda$ 中的最大实部是否严格为负来确定稳定性。\n- 您的程序的最终输出必须是单行文本，包含一个方括号括起来的、逗号分隔的列表，其中按顺序列出了每个测试用例的稳定性结果。每个结果都必须是布尔值。例如，一个可能的输出格式是 $[{\\tt True},{\\tt False},{\\tt True},{\\tt True}]$。\n\n您的程序必须是自包含的，且不能要求任何用户输入。在整个过程中，角度必须以弧度解释，延迟必须以秒为单位。",
            "solution": "该问题要求分析一个延迟网络模型的线性稳定性。其稳定性由特征方程的根 $\\lambda \\in \\mathbb{C}$ 决定：\n$$\n\\det\\!\\left(I - g\\,W\\,e^{-\\lambda D}\\right) = 0\n$$\n其中 $I$ 是 $n \\times n$ 单位矩阵，$W \\in \\mathbb{C}^{n \\times n}$ 是有效连接矩阵，$g \\in \\mathbb{R}$ 是神经元增益，$D > 0$ 是一个均匀延迟。形如 $\\delta r(t) = v e^{\\lambda t}$ 的解代表了线性化系统的一个模态。当且仅当所有这些特征根 $\\lambda$ 的实部 $\\mathrm{Re}(\\lambda)  0$ 时，系统是稳定的。一个实部 $\\mathrm{Re}(\\lambda) \\geq 0$ 的根意味着不稳定性。\n\n问题的核心是求解这个超越方程的根 $\\lambda$。通过考虑矩阵 $W$ 的特征值，可以简化此问题。令 $\\mu_j$（$j=1, \\dots, n$）为 $W$ 的特征值。那么矩阵 $I - g\\,W\\,e^{-\\lambda D}$ 的特征值就是 $1 - g\\,\\mu_j\\,e^{-\\lambda D}$。矩阵的行列式是其特征值的乘积。因此，当且仅当这些特征值中至少有一个为零时，特征方程成立：\n$$\n1 - g\\,\\mu_j\\,e^{-\\lambda D} = 0 \\quad \\text{对于某个 } j \\in \\{1, \\dots, n\\}\n$$\n这将问题从求解一个复数矩阵值方程简化为求解一组标量方程，每个方程对应于 $W$ 的一个特征值 $\\mu_j$。\n\n对于任何非零特征值 $\\mu_j$，我们可以将该标量方程重排为：\n$$\ng\\,\\mu_j\\,e^{-\\lambda D} = 1\n$$\n或\n$$\ne^{\\lambda D} = g\\,\\mu_j\n$$\n如果 $\\mu_j = 0$，方程变为 $1 = 0$，这是不可能的。因此，$W$ 的零特征值不会为系统产生任何特征根 $\\lambda$。\n\n为了求解 $\\lambda \\in \\mathbb{C}$，我们对等式两边取复自然对数。对于一个非零复数 $z = |z|e^{i\\arg(z)}$，其对数是一个多值函数，由 $\\ln(z) = \\ln|z| + i(\\arg(z) + 2\\pi k)$ 给出，其中 $k \\in \\mathbb{Z}$ 是任意整数。将此应用于我们的方程可得：\n$$\n\\lambda D = \\ln(g\\,\\mu_j) = \\ln|g\\,\\mu_j| + i(\\arg(g\\,\\mu_j) + 2\\pi k)\n$$\n这为 $\\lambda$ 产生了一个无限解集，由 $j$ 和 $k$ 索引：\n$$\n\\lambda_{j,k} = \\frac{\\ln|g\\,\\mu_j|}{D} + i \\frac{\\arg(g\\,\\mu_j) + 2\\pi k}{D}\n$$\n每个根的实部 $\\mathrm{Re}(\\lambda)$ 和虚部 $\\mathrm{Im}(\\lambda)$ 分别是：\n$$\n\\mathrm{Re}(\\lambda_{j,k}) = \\frac{\\ln|g\\,\\mu_j|}{D}\n$$\n$$\n\\mathrm{Im}(\\lambda_{j,k}) = \\frac{\\arg(g\\,\\mu_j) + 2\\pi k}{D}\n$$\n一个关键的观察是，对于 $W$ 的一个给定特征值 $\\mu_j$，所有相应根 $\\lambda_{j,k}$ 的实部都是恒定的，与分支指数 $k$ 无关。稳定性由该实部的符号决定。系统稳定当且仅当对所有的 $j$ 和 $k$ 都有 $\\mathrm{Re}(\\lambda_{j,k})  0$。这等价于要求对所有 $j$ 都有 $\\ln|g\\,\\mu_j|/D  0$，可简化为对 $W$ 的所有特征值 $\\mu_j$ 都有 $|g\\,\\mu_j|  1$。\n\n问题要求我们找到指定频率窗口 $|\\mathrm{Im}(\\lambda)| \\leq \\Omega_{\\max}$ 内的所有根。对于每个特征值 $\\mu_j$，我们必须找到满足此条件的所有整数 $k$：\n$$\n\\left| \\frac{\\arg(g\\,\\mu_j) + 2\\pi k}{D} \\right| \\leq \\Omega_{\\max}\n$$\n这个不等式可以解出 $k$：\n$$\n-D\\Omega_{\\max} \\leq \\arg(g\\,\\mu_j) + 2\\pi k \\leq D\\Omega_{\\max}\n$$\n$$\n\\frac{-D\\Omega_{\\max} - \\arg(g\\,\\mu_j)}{2\\pi} \\leq k \\leq \\frac{D\\Omega_{\\max} - \\arg(g\\,\\mu_j)}{2\\pi}\n$$\n通过对下界取上整（ceiling）和对上界取下整（floor），可以找到 $k$ 的有效整数范围。\n\n每个测试用例的计算算法如下：\n1.  给定参数 $W$、$g$、$D$ 和 $\\Omega_{\\max}$。\n2.  计算矩阵 $W$ 的特征值集合 $\\{\\mu_j\\}$。\n3.  初始化一个空列表来存储计算出的特征根 $\\lambda$。\n4.  对每个特征值 $\\mu_j$：\n    a. 如果 $|\\mu_j|$ 接近 $0$，该分支不贡献任何根，因此跳过。\n    b. 计算复数值 $c_j = g\\,\\mu_j$。\n    c. 计算该族根的实部：$\\alpha_j = \\ln|c_j|/D$。\n    d. 使用从 $\\Omega_{\\max}$ 导出的界限，确定索引 $k$ 的整数范围 $[k_{\\min}, k_{\\max}]$。\n    e. 对从 $k_{\\min}$ 到 $k_{\\max}$ 的每个整数 $k$，计算虚部 $\\omega_{j,k} = (\\arg(c_j) + 2\\pi k)/D$。\n    f. 构建根 $\\lambda_{j,k} = \\alpha_j + i \\omega_{j,k}$ 并将其添加到根列表中。\n5.  遍历所有 $\\mu_j$ 后，在列表中找到所有计算出的根中的最大实部。\n6.  如果根列表为空，则稳定性条件空洞地满足，系统被认为是稳定的。当所有 $\\mu_j=0$ 时可能发生这种情况。\n7.  如果最大实部严格小于 $0$，则系统是稳定的。否则，它是不稳定的。结果被记录为布尔值。\n\n此过程正确地识别了指定频率窗口内的所有特征根，并根据指定的准则确定了系统的稳定性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the stability of a linearized Brunel balanced network model\n    for a series of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"W\": np.array([[0.6, 0.0], [0.0, -0.7]]),\n            \"g\": 0.8,\n            \"D\": 0.003,\n            \"Omega_max\": 6000.0,\n        },\n        {\n            \"W\": np.array([[1.6, 0.0], [0.0, -0.9]]),\n            \"g\": 0.9,\n            \"D\": 0.004,\n            \"Omega_max\": 6000.0,\n        },\n        {\n            \"W\": np.array([[1.25, 0.0], [0.0, 0.0]]),\n            \"g\": 0.8,\n            \"D\": 0.005,\n            \"Omega_max\": 6000.0,\n        },\n        {\n            \"W\": np.array([[0.5, -0.8], [0.8, 0.5]]),\n            \"g\": 0.9,\n            \"D\": 0.0025,\n            \"Omega_max\": 8000.0,\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        W = case[\"W\"]\n        g = case[\"g\"]\n        D = case[\"D\"]\n        Omega_max = case[\"Omega_max\"]\n\n        # Step 1: Compute eigenvalues of the connectivity matrix W\n        mu_eigenvalues = np.linalg.eigvals(W)\n\n        all_lambdas = []\n        \n        # Step 2: For each eigenvalue mu_j of W, find all system roots lambda\n        for mu_j in mu_eigenvalues:\n            # A zero eigenvalue mu_j leads to 1 = 0, so no solutions.\n            # We use a small tolerance for floating point comparison.\n            if np.abs(mu_j)  1e-15:\n                continue\n\n            # Calculate the complex factor c_j = g * mu_j\n            c_j = g * mu_j\n            \n            # The real part of lambda is constant for all branches k from mu_j\n            alpha_j = np.log(np.abs(c_j)) / D\n            \n            # The principal argument of c_j\n            arg_c_j = np.angle(c_j)\n            \n            # Step 3: Determine the range of integer indices k for the frequency window\n            k_lower_bound = (-D * Omega_max - arg_c_j) / (2 * np.pi)\n            k_upper_bound = (D * Omega_max - arg_c_j) / (2 * np.pi)\n            \n            k_min = int(np.ceil(k_lower_bound))\n            k_max = int(np.floor(k_upper_bound))\n\n            # Step 4: Compute all lambda roots within the window\n            if k_min = k_max:\n                for k in range(k_min, k_max + 1):\n                    omega_jk = (arg_c_j + 2 * np.pi * k) / D\n                    lambda_jk = alpha_j + 1j * omega_jk\n                    all_lambdas.append(lambda_jk)\n\n        # Step 5: Determine stability based on the maximum real part\n        is_stable = True\n        if not all_lambdas:\n            # If no roots are found (e.g., all mu_j are 0), the condition\n            # Re(lambda)  0 for all lambda is vacuously true.\n            is_stable = True\n        else:\n            max_real_part = -np.inf\n            for lam in all_lambdas:\n                if lam.real > max_real_part:\n                    max_real_part = lam.real\n            \n            # Stability requires the maximum real part to be strictly negative.\n            # Borderline cases Re(lambda) = 0 are considered unstable.\n            if max_real_part >= 0:\n                is_stable = False\n        \n        results.append(is_stable)\n\n    # Format the final output as a string representing a list of booleans\n    output_str = f\"[{','.join(map(lambda x: str(x).lower(), results))}]\"\n    print(output_str.replace(\"'\", \"\"))\n\nsolve()\n```"
        }
    ]
}