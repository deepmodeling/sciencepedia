{
    "hands_on_practices": [
        {
            "introduction": "为了将神经元尖峰生成的物理直觉与可行的数学模型联系起来，我们可以将低噪声环境下的尖峰发放想象成一个粒子逃离势阱的过程。这个练习将指导你应用来自统计物理学的克拉默斯率理论 (Kramers’ rate theory)，从一个通用的随机动态系统出发，推导出瞬时发放率（或风险函数）所具有的指数形式 。通过这个过程，你将理解许多现象学模型中广泛使用的指数风险函数背后的物理基础，并明确决定其电压敏感性的关键参数。",
            "id": "3975121",
            "problem": "考虑在突触轰击下膜电位动力学的一维过阻尼随机描述，其模型为伊藤随机微分方程\n$$\n\\mathrm{d}V(t) \\;=\\; -\\partial_{V}U(V)\\,\\mathrm{d}t \\;+\\; \\sqrt{2D}\\,\\mathrm{d}W_t,\n$$\n其中 $V$ 是膜电位，$U(V)$ 是一个编码了确定性跨膜电流的有效势，$D>0$ 是由突触噪声引起的有效扩散强度，$W_t$ 是一个标准维纳过程。假设尖峰发放可以被视为从一个阈下电位的亚稳阱越过一个位于电压 $V_{\\mathrm{th}}$ 的势垒的逃逸过程，并将状态依赖的风险率 $h(V)$ 定义为在膜电位为 $V$ 的条件下，从该势阱的吸引盆中逃逸的瞬时速率。\n\n在小噪声情形下，越垒速率由 Kramers 的一维过阻尼动力学速率理论所决定，其中速率的主要指数依赖关系由势垒高度控制。在刚好低于 $V_{\\mathrm{th}}$ 的一个狭窄电压邻域内，假设从当前状态 $V$ 测量的势垒高度可以使用线性近似\n$$\n\\Delta U(V) \\;\\equiv\\; U(V_{\\mathrm{b}}) - U(V) \\;\\approx\\; \\alpha\\bigl(V_{\\mathrm{th}} - V\\bigr),\n$$\n其中 $\\alpha>0$ 是一个由有效势的局部斜率决定的常数，$V_{\\mathrm{b}}$ 是势垒顶点的电压。此外，假设 Kramers 指前因子在这个邻域内随 $V$ 缓慢变化，可以被视为一个常数 $h_0>0$。\n\n使用这些假设，推导风险率 $h(V)$ 对电压的主阶依赖关系，并确定控制该依赖关系的特征指数尺度。请用一个包含 $D$ 和 $\\alpha$ 的单个闭式表达式给出特征尺度的最终答案。最终答案需使用与 $V$ 相同的电压单位表示。无需进行数值计算。",
            "solution": "出发点是过阻尼朗之万方程\n$$\n\\mathrm{d}V(t) \\;=\\; -\\partial_{V}U(V)\\,\\mathrm{d}t \\;+\\; \\sqrt{2D}\\,\\mathrm{d}W_t,\n$$\n在小噪声情形下，该方程允许使用 Kramers 类型的描述来刻画从亚稳阱到阈值势垒的逃逸事件。风险率 $h(V)$ 定义为，在当前状态处于势阱吸引盆内电压为 $V$ 的条件下，逃逸发生的瞬时速率。在一维过阻尼动力学的经典 Kramers 框架中，在小噪声极限下，从势阱越过势垒的逃逸速率的主导阶由以下形式的表达式给出\n$$\nh(V) \\;\\approx\\; A(V)\\,\\exp\\!\\left(-\\frac{\\Delta U(V)}{D}\\right),\n$$\n其中 $\\Delta U(V)$ 是从当前状态 $V$ 测量的势垒高度，$A(V)$ 是一个指前因子，它依赖于势阱和势垒附近的势的局部曲率以及摩擦系数。在当前假设下，摩擦已被吸收到单位中，因此 $D$ 扮演了有效温度的角色，并且 $A(V)$ 随 $V$ 缓慢变化。\n\n我们关注指数依赖关系，在适当单位下的小噪声极限 $D \\ll 1$ 中，该关系起主导作用。在阈值附近，势垒高度可近似为\n$$\n\\Delta U(V) \\;\\approx\\; \\alpha\\bigl(V_{\\mathrm{th}} - V\\bigr),\n$$\n其中 $\\alpha>0$ 表征了势垒顶点与当前状态之间的有效势差的局部斜率。将这个线性近似代入 Kramers 速率公式，得到\n$$\nh(V) \\;\\approx\\; A(V)\\,\\exp\\!\\left(-\\frac{\\alpha(V_{\\mathrm{th}} - V)}{D}\\right).\n$$\n如果 $A(V)$ 在所考虑的狭窄阈下邻域内随 $V$ 缓慢变化，我们可以用一个在 $V=V_{\\mathrm{th}}$ （势垒消失处）取值的常数 $h_0$ 来代替它，即\n$$\nh(V) \\;\\approx\\; h_0\\,\\exp\\!\\left(-\\frac{\\alpha(V_{\\mathrm{th}} - V)}{D}\\right).\n$$\n重写指数部分，我们得到指数形式的风险率\n$$\nh(V) \\;\\approx\\; h_0\\,\\exp\\!\\left(\\frac{V - V_{\\mathrm{th}}}{\\Delta}\\right),\n$$\n其中特征指数尺度 $\\Delta$ 的定义满足\n$$\n\\frac{1}{\\Delta} \\;=\\; \\frac{\\alpha}{D}.\n$$\n因此，\n$$\n\\Delta \\;=\\; \\frac{D}{\\alpha}.\n$$\n\n更一般地，如果势垒高度表示为 $\\Delta U(V)$ 而不局限于使用线性近似常数 $\\alpha$，同样的推理可得出\n$$\n\\Delta \\;=\\; \\left.\\frac{D}{\\partial_{V}\\Delta U(V)}\\right|_{V=V_{\\mathrm{th}}},\n$$\n条件是 $\\partial_{V}\\Delta U(V)$ 在阈值电压处求值且为正。在 $\\Delta U(V) \\approx \\alpha(V_{\\mathrm{th}} - V)$ 的特殊情况下，我们有 $\\partial_{V}\\Delta U(V) = -\\alpha$，斜率的量值以 $\\alpha>0$ 的形式进入，给出相同的 $\\Delta = D/\\alpha$，它设定了决定风险率在阈值附近随 $V$ 增长速度的电压尺度。\n\n因此，在小噪声 Kramers 情形下，控制状态依赖风险率对膜电位的指数敏感性的特征尺度 $\\Delta$ 是扩散强度与局部势垒高度相对于电压的斜率之比。",
            "answer": "$$\\boxed{\\frac{D}{\\alpha}}$$"
        },
        {
            "introduction": "理论模型是连续时间的，但计算机模拟本质上是离散的，这种差异会引入数值伪影。本练习将带你直面一个常见问题：在离散时间模拟中，膜电位在尖峰时刻会“过冲”超过阈值 。你将首先量化这个由离散步长引起的系统性误差，然后学习并实践一种基于布朗桥理论的精妙校正方法，该方法能有效地推断在两个离散观测点之间的连续路径行为，从而显著提高模拟的准确性。",
            "id": "3975080",
            "problem": "考虑一个在恒定输入和漏泄下神经元膜电位的随机模型，该模型由一个Ornstein–Uhlenbeck (OU) 过程表示。设膜电位为 $V(t)$，漏泄反转电位为 $V_{\\mathrm{L}}$，膜时间常数为 $\\tau_{\\mathrm{m}}$，恒定平均输入为 $\\mu$，噪声振幅为 $\\sigma$。其连续时间动态由以下随机微分方程定义\n$$\n\\mathrm{d}V(t) = -\\frac{V(t) - V_{\\mathrm{L}}}{\\tau_{\\mathrm{m}}}\\,\\mathrm{d}t + \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W(t),\n$$\n其中 $\\mathrm{d}W(t)$ 表示维纳过程（标准布朗运动）的增量。当 $V(t)$ 首次达到阈值 $V_{\\mathrm{th}}$ 时，记录一个尖峰，之后 $V(t)$ 被重置为 $V_{\\mathrm{reset}}$。\n\n在具有均匀时间步长 $\\Delta t$ 的离散时间内，使用 Euler–Maruyama 方法近似该动态。定义离散状态 $V_n \\approx V(n\\,\\Delta t)$ 和高斯增量 $\\xi_n \\sim \\mathcal{N}(0,1)$，使得\n$$\nV_{n+1} = V_n + \\Delta t\\left(-\\frac{V_n - V_{\\mathrm{L}}}{\\tau_{\\mathrm{m}}} + \\mu\\right) + \\sigma \\sqrt{\\Delta t}\\,\\xi_n.\n$$\n在标准的离散时间检测下，如果在步骤 $n+1$ 时满足 $V_n < V_{\\mathrm{th}}$ 且 $V_{n+1} \\ge V_{\\mathrm{th}}$，则宣告一个尖峰。在宣告的尖峰处，阈值的离散时间超调量定义为\n$$\nO_i = V_{n+1} - V_{\\mathrm{th}},\n$$\n对于第 $i$ 个尖峰事件，它量化了在穿越发生时，电位在时间步结束时超出阈值的程度。所有尖峰的平均超调量为\n$$\n\\overline{O} = \\frac{1}{N_{\\mathrm{spk}}}\\sum_{i=1}^{N_{\\mathrm{spk}}} O_i,\n$$\n其中 $N_{\\mathrm{spk}}$ 是检测到的尖峰总数。\n\n任务：\n1. 从给定的连续时间 OU 动态出发，推导离散时间更新方程，并实现一个模拟，该模拟迭代更新方程，使用步末准则 $V_{n+1} \\ge V_{\\mathrm{th}}$ 且 $V_n < V_{\\mathrm{th}}$ 检测尖峰，在每次尖峰后将 $V$ 重置为 $V_{\\mathrm{reset}}$，并计算以毫伏 (mV) 为单位的平均超调量 $\\overline{O}$。将 $\\overline{O}$ 报告为一个以 mV 为单位的浮点数。\n\n2. 使用单个时间步上的布朗桥理论，推导一个近似概率，用于计算即使离散端点满足 $V_n < V_{\\mathrm{th}}$ 和 $V_{n+1} < V_{\\mathrm{th}}$，连续路径仍在步长内穿越 $V_{\\mathrm{th}}$ 的情况。当端点跨越阈值时，即 $V_n < V_{\\mathrm{th}} < V_{n+1}$，也推导一个在该步长内的首次穿越时间的估计量。基于这些，提出并实现一个校正方法，该方法通过使用推导出的穿越概率来宣告步长内的穿越，从而减少超调偏差。当宣告穿越时，通过将尖峰精确地置于步长内的阈值处，将超调量设为零。计算校正后的平均超调量 $\\overline{O}_{\\mathrm{bb}}$（以毫伏 mV 为单位），并将其报告为一个以 mV 为单位的浮点数。\n\n物理和数值单位：\n- 以毫伏 (mV) 报告平均超调量。\n- 时间单位为毫秒 (ms)；此问题中不出现角度。\n\n测试套件：\n对于以下每个参数集，运行模拟并计算朴素平均超调量 $\\overline{O}$ 和布朗桥校正后的平均超调量 $\\overline{O}_{\\mathrm{bb}}$。\n\n- 情况 1（理想情况，小 $\\Delta t$）：\n  - $V_{\\mathrm{L}} = -65$ mV, $V_{\\mathrm{th}} = -50$ mV, $V_{\\mathrm{reset}} = -65$ mV\n  - $\\tau_{\\mathrm{m}} = 20$ ms, $\\mu = 1$ mV/ms, $\\sigma = 2$ mV/\\sqrt{\\mathrm{ms}}\n  - $\\Delta t = 0.1$ ms，总模拟时间 $T = 5000$ ms\n  - 随机种子 $42$\n\n- 情况 2（粗糙时间步长，预期有较大超调）：\n  - $V_{\\mathrm{L}} = -65$ mV, $V_{\\mathrm{th}} = -50$ mV, $V_{\\mathrm{reset}} = -65$ mV\n  - $\\tau_{\\mathrm{m}} = 20$ ms, $\\mu = 1$ mV/ms, $\\sigma = 2$ mV/\\sqrt{\\mathrm{ms}}\n  - $\\Delta t = 1.0$ ms, $T = 5000$ ms\n  - 随机种子 $7$\n\n- 情况 3（更强的噪声）：\n  - $V_{\\mathrm{L}} = -65$ mV, $V_{\\mathrm{th}} = -50$ mV, $V_{\\mathrm{reset}} = -65$ mV\n  - $\\tau_{\\mathrm{m}} = 20$ ms, $\\mu = 1$ mV/ms, $\\sigma = 5$ mV/\\sqrt{\\mathrm{ms}}\n  - $\\Delta t = 0.2$ ms, $T = 5000$ ms\n  - 随机种子 $123$\n\n- 情况 4（更弱的漂移，中等噪声）：\n  - $V_{\\mathrm{L}} = -65$ mV, $V_{\\mathrm{th}} = -50$ mV, $V_{\\mathrm{reset}} = -65$ mV\n  - $\\tau_{\\mathrm{m}} = 20$ ms, $\\mu = 0.5$ mV/ms, $\\sigma = 3$ mV/\\sqrt{\\mathrm{ms}}\n  - $\\Delta t = 0.1$ ms, $T = 5000$ ms\n  - 随机种子 $2024$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含所有四种情况的结果，形式为一个用方括号括起来的逗号分隔列表。对于每种情况，依次附加朴素平均超调量 $\\overline{O}$ 和校正后的平均超调量 $\\overline{O}_{\\mathrm{bb}}$，两者均以 mV 表示并四舍五入到 $6$ 位小数。因此，最终输出包含 $8$ 个数字，顺序为\n$$\n[\\overline{O}_1,\\overline{O}_{\\mathrm{bb},1},\\overline{O}_2,\\overline{O}_{\\mathrm{bb},2},\\overline{O}_3,\\overline{O}_{\\mathrm{bb},3},\\overline{O}_4,\\overline{O}_{\\mathrm{bb},4}],\n$$\n不含任何其他文本。",
            "solution": "Ornstein–Uhlenbeck (OU) 过程是一个线性随机微分方程，用于模拟具有恒定输入和噪声的有漏泄的膜。从基本动态方程出发\n$$\n\\mathrm{d}V(t) = -\\frac{V(t) - V_{\\mathrm{L}}}{\\tau_{\\mathrm{m}}}\\,\\mathrm{d}t + \\mu\\,\\mathrm{d}t + \\sigma\\,\\mathrm{d}W(t),\n$$\n我们可以通过 Euler–Maruyama 方法构建一个离散时间近似。在一个小的时间步长 $\\Delta t$ 内，增量 $\\mathrm{d}W(t)$ 被近似为 $\\sqrt{\\Delta t}\\,\\xi_n$，其中 $\\xi_n \\sim \\mathcal{N}(0,1)$，得到\n$$\nV_{n+1} = V_n + \\Delta t\\left(-\\frac{V_n - V_{\\mathrm{L}}}{\\tau_{\\mathrm{m}}} + \\mu\\right) + \\sigma \\sqrt{\\Delta t}\\,\\xi_n.\n$$\n这是针对具有加性噪声的线性随机微分方程的经过充分检验的方案，并构成了我们模拟的计算基础。\n\n离散时间尖峰检测在每个时间步结束时执行：当 $V_n < V_{\\mathrm{th}}$ 且 $V_{n+1} \\ge V_{\\mathrm{th}}$ 时，宣告一个尖峰，并将电压重置为 $V_{\\mathrm{reset}}$。该事件的超调量为\n$$\nO_i = V_{n+1} - V_{\\mathrm{th}}.\n$$\n因为真正的阈值穿越发生在 $t_n$ 和 $t_{n+1}$ 之间的某个时刻，对于有限的 $\\Delta t$，步末测量值 $V_{n+1}$ 在 $O_i$ 中引入了正偏差。平均超调量为\n$$\n\\overline{O} = \\frac{1}{N_{\\mathrm{spk}}} \\sum_{i=1}^{N_{\\mathrm{spk}}} O_i,\n$$\n我们以毫伏 (mV) 报告此值。\n\n为了减少这种偏差，我们引用单个时间步上的布朗桥理论。在区间 $[t_n, t_{n+1}]$ 上，以端点为条件，随机路径可以表示为\n$$\nV(t_n + s) = V_n + \\frac{s}{\\Delta t}(V_{n+1} - V_n) + \\sigma\\,B(s),\n$$\n对于 $s \\in [0,\\Delta t]$，其中 $B(s)$ 是一个布朗桥，满足 $B(0) = 0$ 和 $B(\\Delta t) = 0$。这种分解将路径表示为一个确定性线性插值加上一个在端点处消失的零均值波动。由此可得两个关键结论：\n\n1. 当端点均低于阈值时，步长内的穿越概率。如果 $V_n < V_{\\mathrm{th}}$ 且 $V_{n+1} < V_{\\mathrm{th}}$，则布朗桥在某个 $s \\in (0,\\Delta t)$ 穿越 $V_{\\mathrm{th}}$ 的条件概率具有一个通过高斯桥的反射原理推导出的著名闭合形式。记 $d_n = V_{\\mathrm{th}} - V_n > 0$，$d_{n+1} = V_{\\mathrm{th}} - V_{n+1} > 0$，以及步长方差 $s^2 = \\sigma^2 \\Delta t$。穿越概率为\n$$\np_{\\mathrm{hit}} = \\exp\\left(-\\frac{2\\,d_n\\,d_{n+1}}{s^2}\\right) = \\exp\\left(-\\frac{2\\,(V_{\\mathrm{th}} - V_n)(V_{\\mathrm{th}} - V_{n+1})}{\\sigma^2 \\Delta t}\\right).\n$$\n这个公式源于布朗桥在区间上的最大值分布，当步长内的漂移相对于噪声较小或 $\\Delta t$ 足够小时，它提供了一个 $\\mathcal{O}(\\Delta t)$ 精度的校正。\n\n2. 当端点跨越阈值时的首次穿越时间估计量。如果 $V_n < V_{\\mathrm{th}} < V_{n+1}$，则步长内的穿越是确定的。布朗桥表示法建议将路径分解为确定性线性部分和中心化的桥；通过将确定性部分等于阈值，可以获得一个易于处理且无偏的穿越时间 $s^\\ast$ 估计量：\n$$\ns^\\ast \\approx \\Delta t \\cdot \\frac{V_{\\mathrm{th}} - V_n}{V_{n+1} - V_n}.\n$$\n当阈值位于端点之间时，该估计量是触碰时间的条件期望，并被广泛用于首次穿越校正。在离散记录尖峰的模拟中，可以通过在 $t_n + s^\\ast$ 宣告尖峰，并将状态精确地置于步长内的 $V_{\\mathrm{th}}$ 处，从而将超调量设为零，以减少超调偏差。\n\n减少超调偏差的算法校正：\n- 对于每个步骤，通过 Euler–Maruyama 更新计算 $V_{n+1}$。\n- 如果 $V_n < V_{\\mathrm{th}}$ 且 $V_{n+1} \\ge V_{\\mathrm{th}}$，则使用布朗桥时间估计量 $s^\\ast$ 在步长内定位事件来宣告一个尖峰，并通过将尖峰置于 $V_{\\mathrm{th}}$ 将超调量设为零。\n- 如果 $V_n < V_{\\mathrm{th}}$ 且 $V_{n+1} < V_{\\mathrm{th}}$，则从均匀分布 $u \\in (0,1)$ 中抽样一个随机变量，如果 $u < p_{\\mathrm{hit}}$，则在步长内宣告一个尖峰；当宣告这样一个尖峰时，将其置于 $V_{\\mathrm{th}}$ 处，并将超调量设为零。\n- 在任何宣告的尖峰之后，将 $V$ 重置为 $V_{\\mathrm{reset}}$ 并继续。\n\n这种基于布朗桥的校正通过避免步末测量偏差，并通过恢复即使在 $V_{n+1}$ 仍低于 $V_{\\mathrm{th}}$ 时也发生在步长内的穿越，从而减少了平均超调量。在极限 $\\Delta t \\to 0$ 下，朴素和校正后的平均超调量都趋近于零，但对于有限的 $\\Delta t$ 和现实的 $\\sigma$，朴素平均超调量 $\\overline{O}$ 严格为正，而校正后的平均超调量 $\\overline{O}_{\\mathrm{bb}}$ 通过构造被驱动到接近零。\n\n实现细节：\n- 我们使用 $\\Delta t$ 对每个测试案例进行总时间 $T$ 的模拟，从 $V_0 = V_{\\mathrm{reset}}$ 开始，并使用指定的随机种子为独立高斯增量 $\\xi_n \\sim \\mathcal{N}(0,1)$ 以确保可复现性。\n- 朴素超调量计算仅使用步末准则。\n- 校正方法在两个端点都低于阈值时使用布朗桥穿越概率，在端点跨越阈值时使用布朗桥穿越时间估计量，对宣告的尖峰将超调量设为零。\n\n输出：\n- 对于每种情况，我们计算并报告两个数字：朴素平均超调量 $\\overline{O}$ 和校正后的平均超调量 $\\overline{O}_{\\mathrm{bb}}$，两者均以毫伏 (mV) 表示并四舍五入到 $6$ 位小数，聚合成一个指定的方括号列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_mean_overshoot_naive(V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed):\n    \"\"\"\n    Simulate OU process with naive end-of-step spike detection and compute mean overshoot.\n    Units:\n      - Voltages in mV\n      - Time in ms\n      - mu in mV/ms\n      - sigma in mV/sqrt(ms)\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    n_steps = int(T / dt)\n    V = V_reset\n    overshoots = []\n    sqrt_dt = np.sqrt(dt)\n    for _ in range(n_steps):\n        # Euler–Maruyama update\n        drift = dt * (-(V - V_L) / tau_m + mu)\n        noise = sigma * sqrt_dt * rng.standard_normal()\n        V_next = V + drift + noise\n\n        # Naive detection: end-of-step threshold crossing\n        if V < V_th and V_next >= V_th:\n            overshoots.append(V_next - V_th)\n            V = V_reset\n        else:\n            V = V_next\n    if len(overshoots) == 0:\n        return 0.0\n    return float(np.mean(overshoots))\n\ndef simulate_mean_overshoot_bb_corrected(V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed):\n    \"\"\"\n    Simulate OU process with Brownian bridge correction:\n      - Declare crossings within a step using bridge crossing probability when both endpoints are below.\n      - When a crossing is declared (either straddling or via probability), set overshoot to zero.\n    Returns mean overshoot (which will be ~0.0 by construction).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    n_steps = int(T / dt)\n    V = V_reset\n    overshoots = []\n    sqrt_dt = np.sqrt(dt)\n    sigma2_dt = (sigma ** 2) * dt\n\n    for _ in range(n_steps):\n        # Euler–Maruyama update\n        drift = dt * (-(V - V_L) / tau_m + mu)\n        noise = sigma * sqrt_dt * rng.standard_normal()\n        V_next = V + drift + noise\n\n        crossed = False\n        if V < V_th and V_next >= V_th:\n            # Straddling, crossing is certain; set overshoot to zero by placing spike at threshold\n            crossed = True\n        elif V < V_th and V_next < V_th:\n            # Both below; Brownian bridge crossing probability within the step\n            d_n = V_th - V\n            d_np1 = V_th - V_next\n            # p_hit formula for Brownian bridge maximum crossing\n            if sigma2_dt > 0:\n                p_hit = np.exp(-2.0 * d_n * d_np1 / sigma2_dt)\n                if rng.random() < p_hit:\n                    crossed = True\n\n        if crossed:\n            overshoots.append(0.0)  # By correction, overshoot is set to zero\n            V = V_reset\n        else:\n            V = V_next\n\n    if len(overshoots) == 0:\n        return 0.0\n    return float(np.mean(overshoots))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed)\n    test_cases = [\n        (-65.0, -50.0, -65.0, 20.0, 1.0, 2.0, 0.1, 5000.0, 42),    # Case 1\n        (-65.0, -50.0, -65.0, 20.0, 1.0, 2.0, 1.0, 5000.0, 7),      # Case 2\n        (-65.0, -50.0, -65.0, 20.0, 1.0, 5.0, 0.2, 5000.0, 123),    # Case 3\n        (-65.0, -50.0, -65.0, 20.0, 0.5, 3.0, 0.1, 5000.0, 2024),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed = case\n        \n        # In the bb_corrected simulation, add a check for sigma2_dt > 0 to avoid division by zero\n        # when calculating p_hit, though not strictly necessary for given test cases.\n        \n        naive_mean = simulate_mean_overshoot_naive(\n            V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed\n        )\n        bb_mean = simulate_mean_overshoot_bb_corrected(\n            V_L, V_th, V_reset, tau_m, mu, sigma, dt, T, seed\n        )\n        \n        # Round to 6 decimal places as specified\n        results.append(f\"{naive_mean:.6f}\")\n        results.append(f\"{bb_mean:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在更符合生物物理现实的模型中，噪声的强度往往取决于神经元自身的状态，这被称为乘性噪声 (multiplicative noise)。本练习将在前一个实践的基础上更进一步，探讨在这种更复杂的情况下如何选择合适的数值积分方案 。你将对比简单但可能不准确的欧拉-丸山 (Euler-Maruyama) 格式和更高阶的米尔斯坦 (Milstein) 格式，并通过比较两种方法预测的发放率，亲身体会到为随机微分方程选择正确积分方法对模拟结果准确性的重要影响。",
            "id": "3975122",
            "problem": "考虑一个标量伊藤随机微分方程 (SDE) 模型，该模型用于描述在扩散近似下，带有乘性突触噪声的、基于电导的漏电积分发放 (LIF) 神经元。设膜电压为 $V(t)$ (单位：毫伏)，静息电位为 $E_L$ (单位：毫伏)，兴奋性反转电位为 $E_e$ (单位：毫伏)，抑制性反转电位为 $E_i$ (单位：毫伏)，阈值为 $V_{\\mathrm{th}}$ (单位：毫伏)。膜时间常数为 $\\tau$ (单位：毫秒)。兴奋性和抑制性平均电导增益 (单位：每毫秒) 分别为 $g_e$ 和 $g_i$。扩散强度 (单位：每毫秒) 为 $D_e$ 和 $D_i$。噪声由一个单一的有效维纳过程 $W(t)$ 建模，该过程是通过聚合独立的兴奋性和抑制性波动得到的。该 SDE 为：\n$$\n\\mathrm{d}V = a(V)\\,\\mathrm{d}t + b(V)\\,\\mathrm{d}W,\n$$\n其中\n$$\na(V) = -\\frac{V - E_L}{\\tau} + g_e\\,(E_e - V) + g_i\\,(E_i - V),\n$$\n以及\n$$\nb(V) = \\sqrt{2 D_e (E_e - V)^2 + 2 D_i (E_i - V)^2}.\n$$\n当 $V$ 从下方穿过 $V_{\\mathrm{th}}$ 时，会产生尖峰；尖峰发生后，电压瞬间重置为 $V_r$ (单位：毫伏)，并继续演化，没有不应期。初始条件为 $V(0) = V_r$。\n\n任务：从上述伊藤 SDE 的基本定义和数值 SDE 积分器的标准离散时间解释出发，为该乘性噪声 LIF 模型推导并实现两种数值格式。这两种格式将在持续时间为 $T$ 毫秒的有限时间区间上，以固定的时间步长 $\\Delta t$ 毫秒进行计算：\n\n- 欧拉-丸山 (Euler–Maruyama, EM) 格式。\n- 适用于状态依赖扩散的标量伊藤 SDE 的 Milstein 格式。\n\n您的程序必须：\n- 在每个测试案例中，对两种格式使用相同的高斯增量序列（即，在给定的测试案例中，相同的 $\\Delta W_n \\sim \\mathcal{N}(0,\\Delta t)$ 应用于 EM 和 Milstein 格式），以便仅分离由离散化引起的差异。\n- 在持续时间 $T$ 内模拟 LIF 动力学，并在每个步骤结束时进行尖峰检测：如果一个步骤结束时更新的电压大于或等于 $V_{\\mathrm{th}}$，则记录一个尖峰，并立即为下一步重置为 $V_r$。每步最多计算一个尖峰。\n- 计算每种格式的发放率，即尖峰数量除以 $T$ (单位：秒)，即赫兹 (Hertz)。发放率以 $\\mathrm{Hz}$ 表示，发放率之间的差异以浮点数表示。\n\n物理和数值参数 (电压单位为毫伏，时间单位为毫秒)：\n- $E_L = -65$,\n- $E_e = 0$,\n- $E_i = -75$,\n- $V_{\\mathrm{th}} = -50$,\n- $V_r = -65$,\n- $\\tau = 20$,\n- $g_e = 0.02$,\n- $g_i = 0.02$.\n\n测试组：对于下面的每个元组 $(\\Delta t, T, \\text{seed}, D_e, D_i)$，运行两种格式，计算发放率，然后报告定义为 $(\\text{Milstein 发放率}) - (\\text{Euler–Maruyama 发放率})$ 的差值 (单位：Hz)，结果四舍五入到三位小数。\n- 案例 1：$(0.01, 5000, 123, 0.0005, 0.0002)$,\n- 案例 2：$(0.1, 5000, 456, 0.0005, 0.0002)$,\n- 案例 3：$(0.5, 5000, 789, 0.0005, 0.0002)$,\n- 案例 4 (无噪声的边缘案例)：$(0.1, 5000, 999, 0, 0)$。\n\n角度单位不适用。百分比不适用。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试案例的顺序排列结果，例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$，其中每个 $\\text{result}_k$ 四舍五入到三位小数，单位为 $\\mathrm{Hz}$。",
            "solution": "该问题要求推导并实现两种数值格式——欧拉-丸山 (EM) 格式和 Milstein 格式——以求解一个带有乘性噪声的漏电积分发放 (LIF) 神经元的随机微分方程 (SDE) 模型。目标是在不同的模拟参数下，比较这两种格式预测的发放率。\n\n控制膜电压 $V(t)$ 的 SDE 由下式给出：\n$$\n\\mathrm{d}V = a(V)\\,\\mathrm{d}t + b(V)\\,\\mathrm{d}W\n$$\n其中漂移系数 $a(V)$ 和扩散系数 $b(V)$ 分别为：\n$$\na(V) = -\\frac{V - E_L}{\\tau} + g_e\\,(E_e - V) + g_i\\,(E_i - V)\n$$\n$$\nb(V) = \\sqrt{2 D_e (E_e - V)^2 + 2 D_i (E_i - V)^2}\n$$\n我们首先将为两种数值格式推导离散时间更新规则。SDE 的离散时间近似将状态从时间 $t_n$ 更新到 $t_{n+1} = t_n + \\Delta t$，其中时间 $t_n$ 的电压表示为 $V_n$。维纳过程增量 $\\Delta W_n = W(t_{n+1}) - W(t_n)$ 是一个随机变量，服从均值为 $0$、方差为 $\\Delta t$ 的正态分布，即 $\\Delta W_n \\sim \\mathcal{N}(0, \\Delta t)$。这可以写成 $\\Delta W_n = \\sqrt{\\Delta t} Z_n$，其中 $Z_n \\sim \\mathcal{N}(0, 1)$。\n\n**1. 欧拉-丸山 (EM) 格式推导**\n\n欧拉-丸山格式是确定性前向欧拉法到 SDE 的最直接扩展。它通过近似 SDE 的积分形式推导得出：\n$$\nV(t_{n+1}) = V(t_n) + \\int_{t_n}^{t_{n+1}} a(V(s))\\,\\mathrm{d}s + \\int_{t_n}^{t_{n+1}} b(V(s))\\,\\mathrm{d}W(s)\n$$\n即假设系数 $a(V)$ 和 $b(V)$ 在区间 $[t_n, t_{n+1}]$ 上是常数，且等于它们在区间开始时的值 $V_n$。由此可得更新规则：\n$$\nV_{n+1} = V_n + a(V_n)\\Delta t + b(V_n)\\Delta W_n\n$$\n代入给定的 $a(V)$ 和 $b(V)$ 表达式：\n$$\nV_{n+1} = V_n + \\left(-\\frac{V_n - E_L}{\\tau} + g_e\\,(E_e - V_n) + g_i\\,(E_i - V_n)\\right)\\Delta t + \\sqrt{2 D_e (E_e - V_n)^2 + 2 D_i (E_i - V_n)^2} \\Delta W_n\n$$\n这是 EM 格式的更新规则。\n\n**2. Milstein 格式推导**\n\n对于具有状态依赖扩散（乘性噪声）的 SDE，Milstein 格式通过引入一个来自伊藤-泰勒展开的高阶项，改进了 EM 格式。对于一个标量 SDE，通用的 Milstein 格式为：\n$$\nV_{n+1} = V_n + a(V_n)\\Delta t + b(V_n)\\Delta W_n + \\frac{1}{2} b(V_n) b'(V_n) \\left( (\\Delta W_n)^2 - \\Delta t \\right)\n$$\n其中 $b'(V) = \\frac{\\mathrm{d}b}{\\mathrm{d}V}$。最后一项是“Milstein 修正项”。为应用此格式，我们必须计算 $b(V)$ 的导数。直接计算乘积 $b(V)b'(V)$ 在数值上更稳定，在分析上也更方便。让我们从 $b(V)^2$ 开始：\n$$\nb(V)^2 = 2 D_e (E_e - V)^2 + 2 D_i (E_i - V)^2\n$$\n使用链式法则对两边关于 $V$ 求导，得到：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}V} [b(V)^2] = 2 b(V) b'(V)\n$$\n对右侧表达式求导：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}V} \\left[ 2 D_e (E_e - V)^2 + 2 D_i (E_i - V)^2 \\right] = 2 D_e \\cdot 2(E_e - V)(-1) + 2 D_i \\cdot 2(E_i - V)(-1)\n$$\n$$\n= -4 D_e (E_e - V) - 4 D_i (E_i - V) = -4 [D_e (E_e - V) + D_i (E_i - V)]\n$$\n将两个导数表达式相等，我们得到：\n$$\n2 b(V) b'(V) = -4 [D_e (E_e - V) + D_i (E_i - V)]\n$$\n$$\nb(V) b'(V) = -2 [D_e (E_e - V) + D_i (E_i - V)]\n$$\n现在，我们将这个乘积代入 Milstein 修正项：\n$$\n\\text{修正项} = \\frac{1}{2} \\left( -2 [D_e (E_e - V_n) + D_i (E_i - V_n)] \\right) \\left( (\\Delta W_n)^2 - \\Delta t \\right)\n$$\n$$\n= - [D_e (E_e - V_n) + D_i (E_i - V_n)] \\left( (\\Delta W_n)^2 - \\Delta t \\right)\n$$\n这种形式避免了除以 $b(V)$，从而防止了当 $b(V)$ 变为零时（如在无噪声情况下，$D_e=D_i=0$）可能出现的问题。\n完整的 Milstein 更新规则是 EM 更新规则加上此修正项：\n$$\nV_{n+1} = V_n + a(V_n)\\Delta t + b(V_n)\\Delta W_n - [D_e (E_e - V_n) + D_i (E_i - V_n)] \\left( (\\Delta W_n)^2 - \\Delta t \\right)\n$$\n在 $D_e = 0$ 和 $D_i = 0$ 的特殊情况下，$b(V)$ 和修正项的系数都为零。因此，Milstein 格式正确地简化为 EM 格式，而 EM 格式又进一步简化为对最终得到的常微分方程的确定性前向欧拉法。\n\n**3. 模拟算法**\n\n模拟在总时间 $T$ 内以固定时间步长 $\\Delta t$ 进行，总步数为 $N = T/\\Delta t$。为了公平地比较这两种格式，两者使用相同的维纳增量序列 $\\{\\Delta W_n\\}_{n=0}^{N-1}$。\n\n单个测试案例的算法如下：\n1. 将两种格式的电压初始化为重置电位：$V_{\\text{EM}, 0} = V_r$ 和 $V_{\\text{Mil}, 0} = V_r$。\n2. 将两种格式的尖峰计数初始化为零：$N_{\\text{spikes, EM}} = 0$ 和 $N_{\\text{spikes, Mil}} = 0$。\n3. 生成一个包含 $N$ 个随机数 $Z_n \\sim \\mathcal{N}(0, 1)$ 的数组，并计算维纳增量 $\\Delta W_n = \\sqrt{\\Delta t} Z_n$。\n4. 对每个时间步 $n$ (从 $0$ 到 $N-1$)：\n    a. **欧拉-丸山步骤**：\n        i. 计算 $a(V_{\\text{EM}, n})$ 和 $b(V_{\\text{EM}, n})$。\n        ii. 更新电压：$V_{\\text{EM}, n+1}^{*} = V_{\\text{EM}, n} + a(V_{\\text{EM}, n})\\Delta t + b(V_{\\text{EM}, n})\\Delta W_n$。\n        iii. 检查是否有尖峰：如果 $V_{\\text{EM}, n+1}^{*} \\ge V_{\\text{th}}$，则增加 $N_{\\text{spikes, EM}}$ 并设置 $V_{\\text{EM}, n+1} = V_r$。否则，设置 $V_{\\text{EM}, n+1} = V_{\\text{EM}, n+1}^{*}$。\n    b. **Milstein 步骤**：\n        i. 计算 $a(V_{\\text{Mil}, n})$、$b(V_{\\text{Mil}, n})$ 和 Milstein 修正项。\n        ii. 更新电压：$V_{\\text{Mil}, n+1}^{*} = V_{\\text{Mil}, n} + a(V_{\\text{Mil}, n})\\Delta t + b(V_{\\text{Mil}, n})\\Delta W_n + \\text{修正项}$。\n        iii. 检查是否有尖峰：如果 $V_{\\text{Mil}, n+1}^{*} \\ge V_{\\text{th}}$，则增加 $N_{\\text{spikes, Mil}}$ 并设置 $V_{\\text{Mil}, n+1} = V_r$。否则，设置 $V_{\\text{Mil}, n+1} = V_{\\text{Mil}, n+1}^{*}$。\n5. 循环结束后，计算以赫兹为单位的发放率。由于 $T$ 的单位是毫秒，因此以秒为单位的时间是 $T_{sec} = T/1000$。\n   - $f_{\\text{EM}} = N_{\\text{spikes, EM}} / T_{\\text{sec}}$\n   - $f_{\\text{Mil}} = N_{\\text{spikes, Mil}} / T_{\\text{sec}}$\n6. 计算该测试案例的最终结果，即差值：$f_{\\text{Mil}} - f_{\\text{EM}}$。\n\n此过程将对测试组中提供的每组参数实施。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # --- Neuron and simulation parameters from the problem statement ---\n    # These are fixed for all test cases.\n    params = {\n        'EL': -65.0,   # Resting potential (mV)\n        'Ee': 0.0,     # Excitatory reversal potential (mV)\n        'Ei': -75.0,   # Inhibitory reversal potential (mV)\n        'Vth': -50.0,  # Threshold potential (mV)\n        'Vr': -65.0,   # Reset potential (mV)\n        'tau': 20.0,   # Membrane time constant (ms)\n        'ge': 0.02,    # Excitatory conductance gain (ms^-1)\n        'gi': 0.02,    # Inhibitory conductance gain (ms^-1)\n    }\n    \n    # Test cases: (dt, T, seed, De, Di)\n    test_cases = [\n        (0.01, 5000.0, 123, 0.0005, 0.0002),\n        (0.1, 5000.0, 456, 0.0005, 0.0002),\n        (0.5, 5000.0, 789, 0.0005, 0.0002),\n        (0.1, 5000.0, 999, 0.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, T, seed, De, Di = case\n        rate_diff = run_simulation(dt, T, seed, De, Di, params)\n        results.append(f\"{rate_diff:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_simulation(dt, T, seed, De, Di, params):\n    \"\"\"\n    Simulates the LIF neuron using both Euler-Maruyama and Milstein schemes.\n\n    Args:\n        dt (float): Time step in ms.\n        T (float): Total simulation time in ms.\n        seed (int): Seed for the random number generator.\n        De (float): Excitatory diffusion strength.\n        Di (float): Inhibitory diffusion strength.\n        params (dict): Dictionary of neuron model parameters.\n\n    Returns:\n        float: The difference in firing rates (Milstein - EM) in Hz.\n    \"\"\"\n    EL, Ee, Ei = params['EL'], params['Ee'], params['Ei']\n    Vth, Vr = params['Vth'], params['Vr']\n    tau, ge, gi = params['tau'], params['ge'], params['gi']\n    \n    n_steps = int(T / dt)\n    \n    # Generate a shared sequence of Wiener increments\n    rng = np.random.default_rng(seed)\n    Z = rng.standard_normal(size=n_steps)\n    dW = np.sqrt(dt) * Z\n    \n    # Initialize state variables and spike counters\n    V_em = Vr\n    V_mil = Vr\n    spikes_em = 0\n    spikes_mil = 0\n    \n    # --- Main simulation loop ---\n    for i in range(n_steps):\n        dw_i = dW[i]\n        \n        # --- Euler-Maruyama (EM) Step ---\n        # Drift term a(V)\n        a_em = -(V_em - EL) / tau + ge * (Ee - V_em) + gi * (Ei - V_em)\n        \n        # Diffusion term b(V)\n        b_em_sq = 2.0 * De * (Ee - V_em)**2 + 2.0 * Di * (Ei - V_em)**2\n        b_em = np.sqrt(b_em_sq) if b_em_sq > 0 else 0.0\n        \n        # Update voltage\n        V_em_next = V_em + a_em * dt + b_em * dw_i\n        \n        # Spike and reset\n        if V_em_next >= Vth:\n            spikes_em += 1\n            V_em = Vr\n        else:\n            V_em = V_em_next\n            \n        # --- Milstein Step ---\n        # Drift term a(V)\n        a_mil = -(V_mil - EL) / tau + ge * (Ee - V_mil) + gi * (Ei - V_mil)\n        \n        # Diffusion term b(V)\n        b_mil_sq = 2.0 * De * (Ee - V_mil)**2 + 2.0 * Di * (Ei - V_mil)**2\n        b_mil = np.sqrt(b_mil_sq) if b_mil_sq > 0 else 0.0\n        \n        # Milstein correction term\n        # C = -[De*(Ee - V) + Di*(Ei - V)] * (dW^2 - dt)\n        milstein_correction_coeff = -(De * (Ee - V_mil) + Di * (Ei - V_mil))\n        correction = milstein_correction_coeff * (dw_i**2 - dt)\n        \n        # Update voltage\n        V_mil_next = V_mil + a_mil * dt + b_mil * dw_i + correction\n        \n        # Spike and reset\n        if V_mil_next >= Vth:\n            spikes_mil += 1\n            V_mil = Vr\n        else:\n            V_mil = V_mil_next\n            \n    # Calculate firing rates in Hz (T is in ms)\n    T_sec = T / 1000.0\n    rate_em = spikes_em / T_sec\n    rate_mil = spikes_mil / T_sec\n    \n    return rate_mil - rate_em\n\nsolve()\n```"
        }
    ]
}