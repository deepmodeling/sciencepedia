{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的神经元模型之前，我们必须首先掌握其基本构件。本练习将引导你推导最简单的点过程模型——齐次泊松过程——的似然函数。通过推导其恒定发放率的最大似然估计（MLE），你将为理解点过程似然的两个核心组成部分——发放时刻的速率乘积与事件间的“存活”概率——奠定坚实的直觉基础。这个基础练习是后续所有高级建模方法的起点 。",
            "id": "4010017",
            "problem": "您观测一个在区间 $\\left[0, T\\right]$（其中 $T>0$ 以秒为单位）内的单神经元脉冲序列，其记录的脉冲时间为 $\\{t_i\\}_{i=1}^{N}$，满足 $0 < t_1 < t_2 < \\cdots < t_N < T$，其中 $N \\in \\mathbb{N}$ 是观测到的脉冲总数。假设该脉冲序列由一个简单点过程生成，该过程具有一个明确定义的条件强度函数 $\\lambda(t \\mid \\mathcal{H}_t)$，其中 $\\mathcal{H}_t$ 表示该过程直到时间 $t$ 的历史。考虑这样一类模型，其中条件强度不随时间变化且独立于历史，即对于所有 $t \\in [0, T]$ 都有 $\\lambda(t \\mid \\mathcal{H}_t) = \\lambda_0$，其中 $\\lambda_0 > 0$ 的单位为 $\\text{s}^{-1}$。\n\n从简单点过程的条件强度函数的核心定义出发——即，对于足够小的 $\\Delta t>0$，在给定 $\\mathcal{H}_t$ 的条件下，区间 $\\left[t, t + \\Delta t\\right)$ 内发生一个事件的概率满足 $\\mathbb{P}\\{\\text{在 } [t, t+\\Delta t) \\text{ 内有事件} \\mid \\mathcal{H}_t\\} = \\lambda(t \\mid \\mathcal{H}_t)\\,\\Delta t + o(\\Delta t)$，而该区间内没有事件的概率为 $1 - \\lambda(t \\mid \\mathcal{H}_t)\\,\\Delta t + o(\\Delta t)$——请推导在恒定强度模型下，观测到的脉冲序列的精确对数似然。然后，使用此对数似然，解析地推导出 $\\lambda_0$ 的最大似然估计量 (MLE)。\n\n将您的最终答案表示为 MLE 的一个单一闭式解析表达式。如果需要单位，请以 $\\text{s}^{-1}$ 表示。无需四舍五入。",
            "solution": "该问题要求在恒定强度点过程模型下，为观测到的脉冲序列推导对数似然，并随后推导模型单一参数——恒定强度 $\\lambda_0$ 的最大似然估计量 (MLE)。\n\n这个问题是有效的，因为它在科学上基于点过程理论和统计估计，这些都是计算神经科学的基础。问题是良定的、客观的，并包含获得唯一且有意義的解所需的所有信息。\n\n设观测到的脉冲序列为区间 $[0, T]$ 上的脉冲时间集合 $\\{t_i\\}_{i=1}^{N}$，其中 $N$ 是观测到的脉冲总数。模型假设该脉冲序列由一个过程生成，其条件强度函数是恒定的且独立于历史 $\\mathcal{H}_t$：\n$$ \\lambda(t \\mid \\mathcal{H}_t) = \\lambda_0 $$\n其中 $\\lambda_0$ 是一个单位为 $\\text{s}^{-1}$ 的正常数。该模型也被称为齐次泊松过程。\n\n在区间 $[0, T]$ 内观测到一个由事件时间集合 $\\{t_i\\}_{i=1}^{N}$ 指定的点过程特定实现的似然，由点过程似然密度的一般公式给出：\n$$ L(\\theta; \\{t_i\\}_{i=1}^N) = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}; \\theta) \\right) \\exp\\left( -\\int_{0}^{T} \\lambda(s \\mid \\mathcal{H}_s; \\theta) \\, ds \\right) $$\n其中 $\\theta$ 代表模型参数的集合。\n\n在我们的特定情况下，参数集仅包含 $\\lambda_0$，因此 $\\theta = \\{\\lambda_0\\}$。条件强度函数就是 $\\lambda(t \\mid \\mathcal{H}_t; \\lambda_0) = \\lambda_0$。我们将此代入通用似然公式。\n\n乘积项变为：\n$$ \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}; \\lambda_0) = \\prod_{i=1}^{N} \\lambda_0 = \\lambda_0^N $$\n\n指数中的积分项变为：\n$$ \\int_{0}^{T} \\lambda(s \\mid \\mathcal{H}_s; \\lambda_0) \\, ds = \\int_{0}^{T} \\lambda_0 \\, ds = \\lambda_0 [s]_0^T = \\lambda_0 T $$\n\n将这两个分量代回似然公式，得到在恒定强度模型下观测数据的似然函数：\n$$ L(\\lambda_0; \\{t_i\\}_{i=1}^N, T) = \\lambda_0^N \\exp(-\\lambda_0 T) $$\n此表达式表示在特定时间 $\\{t_i\\}$ 观测到 $N$ 个脉冲，并且在区间 $[0, T]$ 内没有其他脉冲的联合概率密度。请注意，似然仅通过充分统计量 $N$ 和 $T$ 依赖于数据。\n\n任务的第一部分是推导对数似然。它是似然函数的自然对数，记为 $\\ell(\\lambda_0)$：\n$$ \\ell(\\lambda_0) = \\ln\\left( L(\\lambda_0) \\right) = \\ln\\left( \\lambda_0^N \\exp(-\\lambda_0 T) \\right) $$\n使用对数的性质 $\\ln(ab) = \\ln(a) + \\ln(b)$ 和 $\\ln(x^y) = y\\ln(x)$，我们得到：\n$$ \\ell(\\lambda_0) = \\ln(\\lambda_0^N) + \\ln(\\exp(-\\lambda_0 T)) $$\n$$ \\ell(\\lambda_0) = N \\ln(\\lambda_0) - \\lambda_0 T $$\n这就是在恒定强度模型下观测到的脉冲序列的精确对数似然。\n\n任务的第二部分是找到 $\\lambda_0$ 的最大似然估计量 (MLE)。MLE，我们记为 $\\hat{\\lambda}_0$，是使对数似然函数 $\\ell(\\lambda_0)$ 最大化的 $\\lambda_0$ 的值。为了找到这个值，我们对 $\\ell(\\lambda_0)$ 关于 $\\lambda_0$ 求导，并将其设为零。\n$$ \\frac{d\\ell(\\lambda_0)}{d\\lambda_0} = \\frac{d}{d\\lambda_0} \\left( N \\ln(\\lambda_0) - \\lambda_0 T \\right) $$\n应用微分法则：\n$$ \\frac{d\\ell(\\lambda_0)}{d\\lambda_0} = N \\left(\\frac{1}{\\lambda_0}\\right) - T = \\frac{N}{\\lambda_0} - T $$\n将此导数设为零以找到临界点：\n$$ \\frac{N}{\\hat{\\lambda}_0} - T = 0 $$\n$$ \\frac{N}{\\hat{\\lambda}_0} = T $$\n解出 $\\hat{\\lambda}_0$ 得到 MLE：\n$$ \\hat{\\lambda}_0 = \\frac{N}{T} $$\n\n为了确认这个值对应于一个最大值，我们必须检查对数似然函数的二阶导数：\n$$ \\frac{d^2\\ell(\\lambda_0)}{d\\lambda_0^2} = \\frac{d}{d\\lambda_0} \\left( \\frac{N}{\\lambda_0} - T \\right) = - \\frac{N}{\\lambda_0^2} $$\n问题陈述了 $N \\in \\mathbb{N}$，并且通常会观测到脉冲，所以我们可以假设 $N > 0$。由于根据定义 $\\lambda_0 > 0$，所以 $\\lambda_0^2$ 是正的。因此，对于 $\\lambda_0$ 的所有有效值，二阶导数都为负：\n$$ \\frac{d^2\\ell(\\lambda_0)}{d\\lambda_0^2} = - \\frac{N}{\\lambda_0^2} < 0 $$\n负的二阶导数证实了对数似然函数是凹函数，并且我们找到的临界点确实是一个最大值。在 $N=0$ 的情况下，对数似然为 $\\ell(\\lambda_0) = -\\lambda_0 T$，它在 $\\lambda_0 \\rightarrow 0$ 时最大化。公式 $\\hat{\\lambda}_0 = N/T = 0/T = 0$ 与这种极限情况是一致的。\n\n因此，恒定强度 $\\lambda_0$ 的最大似然估计量是脉冲总数 $N$ 除以观测区间的时长 $T$。这个结果直观上是合理的：事件率的最佳估计就是观测到的平均事件率。$\\hat{\\lambda}_0$ 的单位是单位时间内的脉冲数，即 $\\text{s}^{-1}$，符合要求。",
            "answer": "$$\\boxed{\\frac{N}{T}}$$"
        },
        {
            "introduction": "建立在恒定速率模型的基础之上，我们现在转向功能更强大的广义线性模型（GLM）框架。GLM 使我们能够模拟神经元的发放率如何受到各种协变量（如外部刺激或其自身的历史活动）的动态影响。此练习的核心任务是推导 GLM 对数似然函数相对于模型权重的梯度，这个梯度是利用数值优化算法（如梯度上升法）拟合这些模型的数学引擎 。",
            "id": "4009974",
            "problem": "考虑一个在固定窗口 $[0,T]$ 内观测的单个神经元，其脉冲时间为 $0 < t_{1} < t_{2} < \\cdots < t_{N} \\leq T$。其条件强度函数 $\\lambda(t \\mid \\mathcal{H}_{t})$ 由一个广义线性模型 (GLM) 建模，其中广义线性模型 (GLM) 指的是一类模型，在这类模型中，一个连接函数将线性预测器映射到响应的均值。具体来说，假设\n$$\n\\lambda(t \\mid \\mathcal{H}_{t}) \\;=\\; \\exp\\!\\big\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t)\\big\\},\n$$\n其中 $\\beta_{0} \\in \\mathbb{R}$ 是一个基线参数，$\\mathbf{w} \\in \\mathbb{R}^{p}$ 是耦合权重，$\\mathbf{x}(t) \\in \\mathbb{R}^{p}$ 是连续时间协变量，可能包括刺激驱动项、通过将神经元自身的脉冲序列与自身历史滤波器进行卷积而构建的脉冲历史项，以及通过将其他神经元的脉冲序列与耦合滤波器进行卷积而构建的耦合项。假设 $\\mathbf{x}(t)$ 在 $[0,T]$ 上是分段连续且可积的，并且 $\\lambda(t \\mid \\mathcal{H}_{t})$ 对于所有 $t \\in [0,T]$ 都是良定义且有限的。\n\n从点过程的第一性原理出发，推导在该模型下观测到的脉冲序列的对数似然 $\\ell(\\beta_{0},\\mathbf{w})$ 的显式表达式，然后推导对数似然关于 $\\mathbf{w}$ 的梯度。您的推导必须从点过程的条件强度和生存的基本定义开始，而不是从任何预先给定的闭式似然或梯度表达式开始。请用 $\\beta_{0}$、$\\mathbf{w}$、$\\mathbf{x}(t)$、脉冲时间 $\\{t_{i}\\}_{i=1}^{N}$ 和观测窗口 $[0,T]$ 来表示您的最终结果，形式为闭式解析表达式。最终答案必须是精确解析表达式形式的计算。不要引入任何正则化项。如果您发现中间的向量或矩阵导数，您必须通过解析方式将其贯穿计算，以得出所要求的最终表达式。",
            "solution": "该问题要求为一个由具有指数连接函数的广义线性模型 (GLM) 建模的神经脉冲序列，推导其对数似然函数及其梯度。推导必须从点过程理论的第一性原理开始。\n\n### 第一部分：对数似然函数 $\\ell(\\beta_0, \\mathbf{w})$ 的推导\n\n在区间 $[0, T]$ 上的一个时间点过程由其条件强度函数 $\\lambda(t \\mid \\mathcal{H}_{t})$ 来表征，该函数表示在给定先前事件的历史 $\\mathcal{H}_{t}$ 的条件下，在时间 $t$ 发生一个事件（一个脉冲）的瞬时概率。\n\n从第一性原理出发，观测到特定脉冲时间序列 $0 < t_1 < t_2 < \\dots < t_N \\leq T$ 的似然可以通过考虑这些事件的联合概率密度来构建。这可以表示为每个脉冲的条件密度的乘积，再乘以在各脉冲之间以及最后一个脉冲之后的区间内没有脉冲发生的概率。\n\n令 $t_0 = 0$。观测到第一个脉冲在 $t_1$ 发生的概率密度由 $t_1$ 时的瞬时率与在区间 $(0, t_1]$ 内*没有*脉冲发生的概率的乘积给出。这个“生存”概率由 $S(t_1 \\mid 0)$ 给出。因此，密度为 $p(t_1) = \\lambda(t_1 \\mid \\mathcal{H}_{t_1}) S(t_1 \\mid 0)$。\n\n更一般地，在第 $(i-1)$ 个脉冲发生在 $t_{i-1}$ 的条件下，第 $i$ 个脉冲发生在 $t_i$ 的条件概率密度为：\n$$\np(t_i \\mid t_{i-1}, \\mathcal{H}_{t_{i-1}}) = \\lambda(t_i \\mid \\mathcal{H}_{t_i}) S(t_i \\mid t_{i-1})\n$$\n其中 $S(t_i \\mid t_{i-1})$ 是在区间 $(t_{i-1}, t_i]$ 内生存（即不发放脉冲）的概率。生存函数与积分条件强度相关：\n$$\nS(t_b \\mid t_a) = \\exp \\left( - \\int_{t_a}^{t_b} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n\n在窗口 $[0, T]$ 内观测到脉冲序列 $\\{t_1, \\dots, t_N\\}$ 的完整似然 $L$ 是每个脉冲的条件密度的乘积，再乘以从最后一个脉冲 $t_N$ 到观测窗口结束 $T$ 的生存概率：\n$$\nL = \\left( \\prod_{i=1}^{N} p(t_i \\mid t_{i-1}, \\mathcal{H}_{t_{i-1}}) \\right) S(T \\mid t_N)\n$$\n代入条件密度的表达式：\n$$\nL = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) S(t_i \\mid t_{i-1}) \\right) S(T \\mid t_N)\n$$\n我们可以将各项分组：\n$$\nL = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) \\right) \\left( \\prod_{i=1}^{N} S(t_i \\mid t_{i-1}) \\right) S(T \\mid t_N)\n$$\n生存项的乘积为：\n$$\n\\left( \\prod_{i=1}^{N} \\exp \\left( - \\int_{t_{i-1}}^{t_i} \\lambda(u \\mid \\mathcal{H}_u) du \\right) \\right) \\exp \\left( - \\int_{t_N}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n$$\n= \\exp \\left( - \\sum_{i=1}^{N} \\int_{t_{i-1}}^{t_i} \\lambda(u \\mid \\mathcal{H}_u) du - \\int_{t_N}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n根据积分的可加性，指数中的和就是整个观测窗口 $[0, T]$ 上的积分：\n$$\n= \\exp \\left( - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n因此，似然函数为：\n$$\nL(\\beta_0, \\mathbf{w}) = \\left( \\prod_{i=1}^{N} \\lambda(t_i \\mid \\mathcal{H}_{t_i}) \\right) \\exp \\left( - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du \\right)\n$$\n对数似然 $\\ell = \\ln(L)$ 则为：\n$$\n\\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\ln(\\lambda(t_i \\mid \\mathcal{H}_{t_i})) - \\int_{0}^{T} \\lambda(u \\mid \\mathcal{H}_u) du\n$$\n现在，我们将给定的 GLM 形式代入条件强度：$\\lambda(t \\mid \\mathcal{H}_t) = \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t)\\}$。在每个脉冲时间 $t_i$ 的强度对数为：\n$$\n\\ln(\\lambda(t_i \\mid \\mathcal{H}_{t_i})) = \\ln \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)\\} \\right) = \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)\n$$\n将此式以及 $\\lambda(u)$ 的表达式代入对数似然方程，我们得到对数似然的最终表达式：\n$$\n\\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\left( \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i) \\right) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du\n$$\n\n### 第二部分：梯度 $\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w})$ 的推导\n\n为了求得对数似然关于权重向量 $\\mathbf{w}$ 的梯度，我们将 $\\ell(\\beta_0, \\mathbf{w})$ 对 $\\mathbf{w}$ 求导。\n$$\n\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w}) = \\nabla_{\\mathbf{w}} \\left( \\sum_{i=1}^{N} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du \\right)\n$$\n我们逐项求导。首先，是求和项：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\sum_{i=1}^{N} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i)) \\right) = \\sum_{i=1}^{N} \\nabla_{\\mathbf{w}} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(t_i))\n$$\n由于 $\\beta_0$ 不依赖于 $\\mathbf{w}$，并使用向量微积分恒等式 $\\nabla_{\\mathbf{z}} (\\mathbf{z}^{\\top} \\mathbf{a}) = \\mathbf{a}$，我们有：\n$$\n= \\sum_{i=1}^{N} \\mathbf{x}(t_i)\n$$\n接下来，我们对积分项求导。由于积分限 $0$ 和 $T$ 不是 $\\mathbf{w}$ 的函数，我们可以使用莱布尼茨积分法则（在积分号下求导）：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} du \\right) = \\int_{0}^{T} \\nabla_{\\mathbf{w}} \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\right) du\n$$\n我们对被积函数应用链式法则。令 $f(\\mathbf{w}) = \\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)$。外部指数函数的梯度为 $\\nabla_{\\mathbf{w}} \\exp(f(\\mathbf{w})) = \\exp(f(\\mathbf{w})) \\nabla_{\\mathbf{w}} f(\\mathbf{w})$。\n指数的梯度为：\n$$\n\\nabla_{\\mathbf{w}} f(\\mathbf{w}) = \\nabla_{\\mathbf{w}} (\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)) = \\mathbf{x}(u)\n$$\n因此，被积函数的梯度为：\n$$\n\\nabla_{\\mathbf{w}} \\left( \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\right) = \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) = \\lambda(u \\mid \\mathcal{H}_u) \\mathbf{x}(u)\n$$\n将其代回积分，积分项的梯度为：\n$$\n\\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n$$\n结合两部分的梯度，我们得到对数似然关于 $\\mathbf{w}$ 的梯度：\n$$\n\\nabla_{\\mathbf{w}} \\ell(\\beta_0, \\mathbf{w}) = \\sum_{i=1}^{N} \\mathbf{x}(t_i) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n$$\n该表达式表示在观测到的脉冲时刻的协变量向量之和与它们在整个观测窗口内按模型的预测发放率加权的期望积分之差。",
            "answer": "$$\n\\boxed{\n\\sum_{i=1}^{N} \\mathbf{x}(t_i) - \\int_{0}^{T} \\exp\\{\\beta_{0} + \\mathbf{w}^{\\top} \\mathbf{x}(u)\\} \\mathbf{x}(u) du\n}\n$$"
        },
        {
            "introduction": "模型的构建和拟合只是分析过程的一半，一个关键的后续问题是：“我们如何判断模型的好坏？” 本练习将重点放在模型评估上，介绍一种称为拟合优度（Goodness-of-Fit）检验的统计方法。通过这个计算实践，你将学习如何计算和分析皮尔逊残差——即模型未能捕捉的“剩余”信息——并使用严格的统计检验来判断模型是否充分描述了数据的结构 。",
            "id": "4010013",
            "problem": "考虑一个神经元点过程的离散时间近似，其中时间被划分为宽度为 $\\Delta$ 秒的均匀时间窗。令 $n_t$ 表示时间窗 $t$ 内的脉冲计数，令 $\\lambda_t$ 表示从一个先前估计的模型（该模型可能包含刺激驱动和历史耦合）中得到的拟合条件强度（单位：脉冲/秒）。假设以下基本事实：(i) 在一个为条件强度正确设定的广义线性模型下，以过去历史为条件，分箱计数具有独立增量；(ii) 对于足够小的 $\\Delta$，时间窗 $t$ 内的期望计数为 $\\mu_t \\approx \\lambda_t \\Delta$；以及 (iii) 在分箱计数服从泊松分布的假设下，$n_t$ 相对于 $\\mu_t$ 的偏差可以通过适当的方差缩放进行标准化。从这些基础出发，从第一性原理推导时间分箱皮尔逊残差，推导一个序列在固定延迟下的样本自相关函数，并推导一个聚合了跨延迟的自相关的波特曼图统计量，以检验无残差自相关的原假设。\n\n你的程序必须：\n- 针对给定的分箱计数序列 $\\{n_t\\}_{t=1}^T$、拟合强度序列 $\\{\\lambda_t\\}_{t=1}^T$ 和固定的时间窗宽度 $\\Delta$，实现推导出的皮尔逊残差。如果任何时间窗的 $\\mu_t = \\lambda_t \\Delta = 0$，你必须通过引入一个极小的正常数 $\\varepsilon$ 来避免除以零，从而以科学上合理的方式进行数值处理。\n- 计算皮尔逊残差序列在延迟 $1$ 到 $L$ 上的样本自相关，然后计算一个聚合这些自相关的波特曼图统计量，以在原假设下检验残差自相关。使用固定的显著性水平 $\\alpha$ 进行检验，并返回一个布尔值，指示是否拒绝原假设（即，残差中是否仍存在统计上显著的自相关）。\n\n你必须使用以下具有科学上合理的参数的测试套件。所有随机性必须通过使用指定的伪随机种子来保证可复现。不涉及角度；时间单位为秒，强度单位为脉冲/秒。\n\n测试用例 1（正确设定的模型，独立增量）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 10000$。\n- 对所有 $t$，拟合强度为常数 $\\lambda_t = 20$。\n- 使用伪随机种子 $12345$ 生成计数 $n_t$，作为均值为 $\\mu_t = \\lambda_t \\Delta$ 的独立泊松分布抽样。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n测试用例 2（模型失配，具有正一阶依赖）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 4000$。\n- 对所有 $t$，拟合强度为常数 $\\lambda_t = 20$。\n- 使用转移概率为 $P(n_t=1 \\mid n_{t-1}=0) = p_0$ 和 $P(n_t=1 \\mid n_{t-1}=1) = p_1$ 的二元一阶马尔可夫过程生成计数 $n_t \\in \\{0,1\\}$，其中 $p_0 = 0.1$ 且 $p_1 = 0.5$。初始化 $n_1 = 0$，并使用伪随机种子 $54321$ 进行后续抽样。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n测试用例 3（边缘情况，具有结构性脉冲簇和预测强度为零的片段）：\n- 时间窗宽度 $\\Delta = 0.01$。\n- 时间窗数量 $T = 800$。\n- 对于 $t \\in \\{1,\\dots,100\\}$，拟合强度 $\\lambda_t = 0$；对于 $t \\in \\{101,\\dots,800\\}$，拟合强度 $\\lambda_t = 5$。\n- 对于 $t \\in \\{1,\\dots,100\\}$，确定性计数 $n_t = 0$；对于 $t \\in \\{101,\\dots,800\\}$，设置 $n_t$ 遵循一个由四个1后跟四个0的重复模式（即，非随机地重复 $1,1,1,1,0,0,0,0$），以表示拟合强度未能捕捉到的脉冲簇结构。\n- 最大延迟 $L = 1$，显著性水平 $\\alpha = 0.05$，数值稳定器 $\\varepsilon = 10^{-12}$。\n\n算法要求：\n- 根据基本假设推导皮尔逊残差，并实现它以获得每个测试用例的残差序列 $\\{r_t\\}_{t=1}^T$。\n- 推导样本自相关估计量，并实现延迟 $1$ 到 $L$ 的自相关计算。\n- 推导并实现一个波特曼图统计量，该统计量在无自相关的原假设下服从一个适当的参考分布，并用它来计算在显著性水平 $\\alpha$ 下的决策规则，以输出一个指示是否拒绝原假设的布尔值。\n\n最终输出规范：\n- 你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[result1,result2,result3]`），其中每个条目是一个布尔值，指示对于相应的测试用例，在指定延迟下使用波特曼图检验是否在皮尔逊残差中检测到统计上显著的自相关。\n\n你的实现必须是自包含的，且不得需要任何用户输入。最终输出格式必须严格符合上述规范。",
            "solution": "我们从一个在离散时间中观察到的点过程模型开始。令 $\\Delta$ 表示以秒为单位的时间窗宽度，令 $n_t$ 表示时间窗 $t$ 内的脉冲计数，令 $\\lambda(t \\mid \\mathcal{H}_t)$ 表示在给定历史 $\\mathcal{H}_t$ 的情况下，在时间 $t$ 的条件强度。在一个强度近似恒定的时间窗内，我们记为 $\\lambda_t \\approx \\lambda(t \\mid \\mathcal{H}_t)$，并使用经过充分检验的近似，即时间窗 $t$ 内的期望计数为 $\\mu_t = \\mathbb{E}[n_t \\mid \\mathcal{H}_t] \\approx \\lambda_t \\Delta$。在小时间窗内计数服从泊松模型的假设下，我们有 $\\operatorname{Var}(n_t \\mid \\mathcal{H}_t) \\approx \\mu_t$，并且当模型被正确设定时，以历史为条件，增量是独立的。\n\n从这些基础出发，一种将观测计数 $n_t$ 与其期望计数 $\\mu_t$ 进行比较的标准化残差是皮尔逊残差。为了推导它，定义偏差 $d_t = n_t - \\mu_t$，并注意到在每个时间窗服从泊松分布的假设下，适当的方差尺度为 $\\sigma_t^2 \\approx \\mu_t$。因此，标准化偏差为\n$$\nr_t = \\frac{d_t}{\\sqrt{\\sigma_t^2}} \\approx \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t}}.\n$$\n在一个正确设定的模型下，这个序列 $\\{r_t\\}$ 应近似不相关且均值为零。在数值上，为了避免在 $\\mu_t = 0$ 的时间窗中出现除以零的情况，我们引入一个极小的稳定器 $\\varepsilon > 0$ 并使用\n$$\nr_t = \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t + \\varepsilon}},\n$$\n当 $\\mu_t > 0$ 时，这恢复了标准定义，并且当 $n_t = \\mu_t = 0$ 时，得到 $r_t \\approx 0$。\n\n为了评估剩余的结构，我们测量残差中的自相关。对于一个样本均值为 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ 的有限序列 $\\{r_t\\}_{t=1}^T$，在延迟 $k$ 时的样本自协方差为\n$$\n\\hat{\\gamma}_k = \\frac{1}{T} \\sum_{t=k+1}^T (r_t - \\bar{r})(r_{t-k} - \\bar{r}),\n$$\n样本方差为\n$$\n\\hat{\\gamma}_0 = \\frac{1}{T} \\sum_{t=1}^T (r_t - \\bar{r})^2.\n$$\n那么，在延迟 $k$ 时的样本自相关为\n$$\n\\hat{\\rho}_k = \\frac{\\hat{\\gamma}_k}{\\hat{\\gamma}_0}.\n$$\n在残差是白噪声的原假设下，对于所有小的延迟，$\\hat{\\rho}_k$ 应接近于 $0$。\n\n对于跨多个延迟的联合检验，我们使用一个通过聚合自相关得到的波特曼图统计量。一个广泛使用的选择是 Box–Ljung 统计量，为最大延迟 $L$ 定义为\n$$\nQ = T(T+2)\\sum_{k=1}^L \\frac{\\hat{\\rho}_k^2}{T-k}.\n$$\n在无自相关的原假设下，对于大的 $T$，$Q$ 近似服从自由度为 $L$ 的卡方随机变量分布。因此，在显著性水平 $\\alpha$ 下的一个有原则的决策规则是在\n$$\nQ > \\chi^2_{1-\\alpha}(L),\n$$\n时拒绝原假设，其中 $\\chi^2_{1-\\alpha}(L)$ 是自由度为 $L$ 的卡方分布的 $(1-\\alpha)$ 分位数。等价地，我们通过生存函数计算p值，并在 $p < \\alpha$ 时拒绝原假设。\n\n算法设计：\n- 对每个测试用例，计算所有 $t$ 的 $\\mu_t = \\lambda_t \\Delta$。\n- 通过 $r_t = \\frac{n_t - \\mu_t}{\\sqrt{\\mu_t + \\varepsilon}}$ 计算皮尔逊残差。\n- 计算样本均值 $\\bar{r}$，然后按上述定义计算 $k \\in \\{1,\\dots,L\\}$ 的 $\\hat{\\rho}_k$。\n- 通过对缩放后的自相关平方求和来计算 Box-Ljung $Q$ 统计量。\n- 使用自由度为 $L$ 的卡方参考分布，计算p值并返回一个指示是否 $p < \\alpha$ 的布尔值。\n\n测试套件解释和科学真实性：\n- 在测试用例1中，计数是从一个与拟合强度具有相同期望计数的泊松模型生成的，因此残差应近似为白噪声，检验通常不应拒绝原假设。\n- 在测试用例2中，计数是从一个具有正相关性的二元马尔可夫过程生成的，而拟合强度是恒定的且未包含耦合，因此残差应显示出正的延迟1自相关，从而导致拒绝原假设。\n- 在测试用例3中，计数具有由连续的1和0组成的确定性脉冲簇结构，而拟合强度未能捕捉到该结构（包括一个 $\\lambda_t = 0$ 的片段）。残差将在脉冲簇内表现出正自相关，波特曼图检验应拒绝原假设，而 $\\varepsilon$ 确保了在零强度时间窗内的数值稳定残差。\n\n程序为指定参数实现这些步骤，并以 $[result1,result2,result3]$ 的格式打印单行，其中每个条目是一个布尔值，指示是否使用最大延迟为 $L$ 的 Box-Ljung 统计量在水平 $\\alpha$ 下检测到残差自相关。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef pearson_residuals(counts, lambdas, delta, epsilon=1e-12):\n    \"\"\"\n    Compute Pearson residuals r_t = (n_t - mu_t) / sqrt(mu_t + epsilon),\n    where mu_t = lambda_t * delta.\n    \"\"\"\n    mu = lambdas * delta\n    # Residuals with numerical stabilizer for zero expected counts\n    resid = (counts - mu) / np.sqrt(mu + epsilon)\n    return resid\n\ndef sample_autocorrelations(x, max_lag):\n    \"\"\"\n    Compute sample autocorrelations rho_k for k=1..max_lag.\n    Uses mean-centered sequence and variance normalization.\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    T = x.shape[0]\n    m = x.mean()\n    x_centered = x - m\n    var = np.sum(x_centered ** 2) / T\n    # If variance is numerically zero, return zeros to avoid division by zero\n    if var == 0.0:\n        return np.zeros(max_lag, dtype=float)\n    rhos = []\n    for k in range(1, max_lag + 1):\n        cov = np.sum(x_centered[k:] * x_centered[:-k]) / T\n        rhos.append(cov / var)\n    return np.array(rhos, dtype=float)\n\ndef box_ljung_q(rhos, T):\n    \"\"\"\n    Compute the Box-Ljung Q statistic for given autocorrelations rhos (lags 1..L)\n    and series length T.\n    Q = T(T+2) sum_{k=1}^L rhos_k^2 / (T - k)\n    \"\"\"\n    L = len(rhos)\n    denom = np.array([T - k for k in range(1, L + 1)], dtype=float)\n    Q = T * (T + 2) * np.sum((rhos ** 2) / denom)\n    return Q\n\ndef test_case_1():\n    # Well-specified model: Poisson counts matching fitted intensity\n    delta = 0.01\n    T = 10000\n    lam = 20.0\n    lambdas = np.full(T, lam, dtype=float)\n    rng = np.random.default_rng(12345)\n    mu = lam * delta\n    counts = rng.poisson(mu, size=T)\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval < alpha\n\ndef test_case_2():\n    # Model misfit: binary Markov counts with positive dependence; fitted intensity constant\n    delta = 0.01\n    T = 4000\n    lam = 20.0\n    lambdas = np.full(T, lam, dtype=float)\n    p0 = 0.1\n    p1 = 0.5\n    rng = np.random.default_rng(54321)\n    counts = np.zeros(T, dtype=int)\n    # Initialize state\n    state = 0\n    counts[0] = state\n    for t in range(1, T):\n        if state == 0:\n            state = 1 if rng.random() < p0 else 0\n        else:\n            state = 1 if rng.random() < p1 else 0\n        counts[t] = state\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval < alpha\n\ndef test_case_3():\n    # Edge case: zero predicted intensity segment and deterministic bursts\n    delta = 0.01\n    T = 800\n    lambdas = np.zeros(T, dtype=float)\n    lambdas[100:] = 5.0\n    counts = np.zeros(T, dtype=int)\n    # Bursty pattern: for t >= 101, repeat [1,1,1,1,0,0,0,0]\n    pattern = [1, 1, 1, 1, 0, 0, 0, 0]\n    idx = 100\n    while idx < T:\n        for v in pattern:\n            if idx >= T:\n                break\n            counts[idx] = v\n            idx += 1\n    L = 1\n    alpha = 0.05\n    eps = 1e-12\n    resid = pearson_residuals(counts, lambdas, delta, eps)\n    rhos = sample_autocorrelations(resid, L)\n    Q = box_ljung_q(rhos, T)\n    pval = chi2.sf(Q, df=L)\n    return pval < alpha\n\ndef solve():\n    results = []\n    results.append(test_case_1())\n    results.append(test_case_2())\n    results.append(test_case_3())\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}