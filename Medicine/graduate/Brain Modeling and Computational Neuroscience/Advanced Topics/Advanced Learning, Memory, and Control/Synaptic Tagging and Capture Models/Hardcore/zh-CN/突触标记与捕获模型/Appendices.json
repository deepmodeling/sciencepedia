{
    "hands_on_practices": [
        {
            "introduction": "这项基础练习将指导你将突触标记与捕获（STC）的核心原理——标记设定、蛋白质合成和基于巧合的巩固——转化为一个常微分方程（ODE）系统。通过实现一个数值模拟，你将直接观察到标记和蛋白质的时间常数如何决定长时程增强的时间窗口，这是STC理论的基石。",
            "id": "4025821",
            "problem": "考虑突触标记与捕获（Synaptic Tagging and Capture, STC）的最小形式化模型，其中突触标记和可塑性相关蛋白由刺激产生，并根据一级动力学进行衰减，而突触权重的长期巩固则源于它们在时间上的重合。任务是从第一性原理构建演化方程，并为“先弱后强”刺激方案实现一个模拟，然后在一系列时间常数组合中对巩固结果进行分类。\n\n假设以下基本规则源自经过充分检验的生物化学和生物物理学原理：在线性泄漏下浓度的一级指数松弛、与刺激输入成正比的线性产生，以及伴随线性泄漏的巩固突触权重的符合依赖性累积。具体来说，每个量都表现出以下特性：\n\n- 突触标记 $T(t)$ 以时间常数 $\\tau_{T}$ 进行一级衰减，并由有限时长的弱刺激输入驱动。\n- 可塑性相关蛋白 $P(t)$ 以时间常数 $\\tau_{P}$ 进行一级衰减，并由有限时长的强刺激输入驱动。\n- 巩固的突触权重 $W(t)$ 的增加与 $T(t)$ 和 $P(t)$ 的瞬时重合度成正比，并表现出线性泄漏。\n\n刺激方案和输入被定义为方波脉冲：\n- 弱刺激发生在区间 $t \\in [0,\\delta)$ 内，振幅为 $A_{w}$。\n- 强刺激发生在区间 $t \\in [d,d+\\delta)$ 内，振幅为 $A_{s}$。\n- 在这些区间之外，不施加刺激。\n\n您的程序必须：\n1. 针对由弱输入和强输入分别驱动的 $T(t)$、$P(t)$ 和 $W(t)$，推导出与上述假设一致的最小常微分方程（ODE）系统。使用符合上下文的构造：带时间常数的一级衰减、与输入振幅成比例并带产生增益的线性产生，以及针对 $W(t)$ 的符合驱动累积（带线性泄漏）。\n2. 使用具有固定时间步长 $dt$ 的显式前向欧拉法实现一个数值求解器，从 $t=0$ 到 $t=t_{\\mathrm{end}}$ 对系统进行模拟，初始条件为 $T(0)=0$、$P(0)=0$ 和 $W(0)=0$。\n3. 通过对最终突触权重进行阈值化来对巩固进行分类：输出一个布尔值，指示 $W(t_{\\mathrm{end}}) \\ge \\theta$ 是否成立。\n\n使用以下参数值和单位：\n- 弱脉冲振幅 $A_{w} = 1.0$（无量纲）。\n- 强脉冲振幅 $A_{s} = 3.0$（无量纲）。\n- 产生增益 $k_{T} = 0.05\\,\\mathrm{s}^{-1}$ 和 $k_{P} = 0.05\\,\\mathrm{s}^{-1}$。\n- 符合增益 $\\gamma = 1\\times 10^{-5}\\,\\mathrm{s}^{-1}$ 和泄漏率 $\\lambda = 1\\times 10^{-5}\\,\\mathrm{s}^{-1}$。\n- “先弱后强”延迟 $d = 600\\,\\mathrm{s}$ 和脉冲持续时间 $\\delta = 30\\,\\mathrm{s}$。\n- 模拟时间步长 $dt = 0.5\\,\\mathrm{s}$ 和结束时间 $t_{\\mathrm{end}} = 7200\\,\\mathrm{s}$。\n- 巩固阈值 $\\theta = 0.05$（无量纲）。\n\n您的程序应评估以下针对 $(\\tau_{T},\\tau_{P})$ 的时间常数（单位：秒）测试套件：\n- 情况 1：$(1200,1800)$。\n- 情况 2：$(180,1800)$。\n- 情况 3：$(1800,180)$。\n- 情况 4：$(2400,2400)$。\n- 情况 5：$(60,60)$。\n- 情况 6：$(600,600)$。\n\n对于每种情况，模拟“先弱后强”方案，计算 $W(t_{\\mathrm{end}})$，并如上所述对巩固进行分类。您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表作为结果（例如，$\\texttt{[result1,result2,\\dots]}$），其中每个元素是对应案例的巩固结果的布尔值。所有时间量必须以秒为单位处理和计算，最终分类必须是无单位的布尔值。",
            "solution": "该问题要求为突触标记与捕获（STC）构建并模拟一个最小数学模型。解决方案涉及从给定的第一性原理推导常微分方程（ODE）系统，实现一个数值求解器，并用它来对一组参数下的巩固结果进行分类。\n\n### 1. 模型方程的推导\n\n该模型基于三个量的时间动态：突触标记浓度 $T(t)$、可塑性相关蛋白浓度 $P(t)$ 和巩固的突触权重 $W(t)$。这些动态源于生物化学动力学的基本原理。\n\n**刺激输入函数：**\n该系统由弱刺激和强刺激驱动，它们被建模为方波脉冲。弱刺激函数 $S_w(t)$ 和强刺激函数 $S_s(t)$ 定义如下：\n$$ S_w(t) = \\begin{cases} A_w  \\text{if } 0 \\le t  \\delta \\\\ 0  \\text{otherwise} \\end{cases} $$\n$$ S_s(t) = \\begin{cases} A_s  \\text{if } d \\le t  d+\\delta \\\\ 0  \\text{otherwise} \\end{cases} $$\n其中 $A_w$ 和 $A_s$ 分别是各自的振幅，$\\delta$ 是脉冲持续时间，而 $d$ 是弱刺激和强刺激开始之间的延迟。\n\n**突触标记 $T(t)$ 的方程：**\n问题描述指出，突触标记 $T(t)$ 是对弱刺激的响应而产生的，并经历一级衰减。该过程由一个一阶线性常微分方程描述。代表线性泄漏的衰减项与当前浓度成正比，记为 $-\\frac{T(t)}{\\tau_T}$，其中 $\\tau_T$ 是标记的特征时间常数。产生项与弱刺激输入 $k_T S_w(t)$ 呈线性正比，其中 $k_T$ 是产生增益。结合这些项，$T(t)$ 的演化由以下方程决定：\n$$ \\frac{dT}{dt} = k_T S_w(t) - \\frac{T(t)}{\\tau_T} $$\n\n**可塑性相关蛋白 $P(t)$ 的方程：**\n类似地，可塑性相关蛋白的浓度 $P(t)$ 由强刺激产生，并且也经历一级衰减。衰减项为 $-\\frac{P(t)}{\\tau_P}$，其中 $\\tau_P$ 是蛋白的时间常数。产生由强刺激驱动，由项 $k_P S_s(t)$ 表示，其中 $k_P$ 是产生增益。$P(t)$ 对应的常微分方程是：\n$$ \\frac{dP}{dt} = k_P S_s(t) - \\frac{P(t)}{\\tau_P} $$\n\n**巩固的突触权重 $W(t)$ 的方程：**\n突触权重 $W(t)$ 的巩固取决于标记 $T(t)$ 和蛋白 $P(t)$ 在时间上的重合。这种依赖于重合的增长被建模为与它们的浓度乘积 $\\gamma T(t)P(t)$ 成正比，其中 $\\gamma$ 是符合增益。突触权重也表现出线性泄漏，由衰减项 $-\\lambda W(t)$ 建模，其中 $\\lambda$ 是泄漏率。因此，$W(t)$ 的常微分方程为：\n$$ \\frac{dW}{dt} = \\gamma T(t)P(t) - \\lambda W(t) $$\n\n**完整的常微分方程组：**\n完整的STC模型由以下耦合常微分方程组描述，其初始条件为突触处于静息状态：\n$$\n\\begin{align*}\n\\frac{dT}{dt} = k_T S_w(t) - \\frac{T(t)}{\\tau_T},  \\quad T(0) = 0 \\\\\n\\frac{dP}{dt} = k_P S_s(t) - \\frac{P(t)}{\\tau_P},  \\quad P(0) = 0 \\\\\n\\frac{dW}{dt} = \\gamma T(t)P(t) - \\lambda W(t),  \\quad W(0) = 0\n\\end{align*}\n$$\n\n### 2. 数值模拟\n\n问题指定使用显式前向欧拉法来数值求解该系统。对于一个形如 $\\frac{dy}{dt} = f(y, t)$ 的通用常微分方程，下一个时间步的值 $y_{i+1} = y(t_{i+1})$ 是根据当前步的值 $y_i = y(t_i)$ 使用固定时间步长 $dt$ 来近似的：\n$$ y_{i+1} \\approx y_i + dt \\cdot f(y_i, t_i) $$\n将此离散化方案应用于我们的方程组，得到以下迭代更新规则：\n$$ T_{i+1} = T_i + dt \\left( k_T S_w(t_i) - \\frac{T_i}{\\tau_T} \\right) $$\n$$ P_{i+1} = P_i + dt \\left( k_P S_s(t_i) - \\frac{P_i}{\\tau_P} \\right) $$\n$$ W_{i+1} = W_i + dt \\left( \\gamma T_i P_i - \\lambda W_i \\right) $$\n模拟从 $t=0$ 执行到 $t=t_{\\text{end}}$，时间步长为 $dt=0.5\\,\\mathrm{s}$，使用给定的参数值：$A_w=1.0$、$A_s=3.0$、$k_T=0.05\\,\\mathrm{s}^{-1}$、$k_P=0.05\\,\\mathrm{s}^{-1}$、$\\gamma=1\\times 10^{-5}\\,\\mathrm{s}^{-1}$、$\\lambda=1\\times 10^{-5}\\,\\mathrm{s}^{-1}$、$d=600\\,\\mathrm{s}$ 和 $\\delta=30\\,\\mathrm{s}$。\n\n### 3. 巩固标准\n\n最后一步是对每次模拟运行的结果进行分类。如果在模拟期结束时 $t_{\\text{end}}=7200\\,\\mathrm{s}$，最终的突触权重 $W(t_{\\text{end}})$ 大于或等于预设阈值 $\\theta=0.05$，则认为巩固成功。每个参数集 $(\\tau_T, \\tau_P)$ 的输出是一个布尔值，代表此比较的结果：\n$$ \\text{巩固} = \\left( W(t_{\\text{end}}) \\ge \\theta \\right) $$\n对六个指定的测试案例中的每一个都执行此过程，并将结果汇编成一个最终列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_stc(tau_T, tau_P):\n    \"\"\"\n    Simulates the Synaptic Tagging and Capture (STC) model for a given set\n    of time constants using the forward Euler method.\n\n    Args:\n        tau_T (float): Time constant for the synaptic tag in seconds.\n        tau_P (float): Time constant for the plasticity proteins in seconds.\n\n    Returns:\n        float: The final consolidated synaptic weight W(t_end).\n    \"\"\"\n    # Fixed parameters as specified in the problem\n    A_w = 1.0       # Weak pulse amplitude (dimensionless)\n    A_s = 3.0       # Strong pulse amplitude (dimensionless)\n    k_T = 0.05      # Tag production gain (s^-1)\n    k_P = 0.05      # Protein production gain (s^-1)\n    gamma = 1.0e-5  # Coincidence gain (s^-1)\n    lmbda = 1.0e-5  # Weight leakage rate (s^-1)\n    d = 600.0       # Weak-then-strong delay (s)\n    delta = 30.0    # Pulse duration (s)\n    dt = 0.5        # Simulation time step (s)\n    t_end = 7200.0  # Final time (s)\n    \n    # Simulation time setup\n    num_steps = int(t_end / dt)\n    \n    # Initialize state variable arrays\n    # T, P, and W start at 0, which np.zeros handles\n    T = np.zeros(num_steps + 1)\n    P = np.zeros(num_steps + 1)\n    W = np.zeros(num_steps + 1)\n    \n    # Pre-calculate stimulus pulse indices for efficiency and robustness\n    weak_stim_start_idx = int(0 / dt)\n    weak_stim_end_idx = int(delta / dt)\n    strong_stim_start_idx = int(d / dt)\n    strong_stim_end_idx = int((d + delta) / dt)\n\n    # Main simulation loop to iterate through time steps\n    for i in range(num_steps):\n        current_time = i * dt\n        # Determine stimulus input values at the current time step\n        S_w = A_w if weak_stim_start_idx = i  weak_stim_end_idx else 0.0\n        S_s = A_s if strong_stim_start_idx = i  strong_stim_end_idx else 0.0\n            \n        # Apply the forward Euler update rules\n        # Update synaptic tag T\n        dT_dt = k_T * S_w - T[i] / tau_T\n        T[i+1] = T[i] + dt * dT_dt\n        \n        # Update plasticity proteins P\n        dP_dt = k_P * S_s - P[i] / tau_P\n        P[i+1] = P[i] + dt * dP_dt\n        \n        # Update consolidated weight W\n        dW_dt = gamma * T[i] * P[i] - lmbda * W[i]\n        W[i+1] = W[i] + dt * dW_dt\n        \n    return W[-1]\n\n\ndef solve():\n    \"\"\"\n    Main function to run the STC simulation for all test cases and print results.\n    \"\"\"\n    # Define the consolidation threshold\n    theta = 0.05\n    \n    # Define the test suite of time constants (tau_T, tau_P) in seconds\n    test_cases = [\n        (1200.0, 1800.0), # Case 1\n        (180.0, 1800.0),  # Case 2\n        (1800.0, 180.0),  # Case 3\n        (2400.0, 2400.0), # Case 4\n        (60.0, 60.0),     # Case 5\n        (600.0, 600.0),   # Case 6\n    ]\n\n    results = []\n    # Iterate through each case, run the simulation, and classify the outcome\n    for tau_T, tau_P in test_cases:\n        final_weight = simulate_stc(tau_T, tau_P)\n        consolidation_occurs = final_weight >= theta\n        results.append(consolidation_occurs)\n\n    # Format and print the final output as a single-line string\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution\nsolve()\n```"
        },
        {
            "introduction": "真实的树突包含许多突触。这项练习探讨了多个突触如何竞争一个共享的可塑性相关产物（PRP）池。你将推导出一个简单而有力的解析结果，揭示突触标记的相对强度如何决定这些资源的分配，这是理解突触协同性和竞争性的一个关键见解。",
            "id": "4025805",
            "problem": "考虑一个突触标记与捕获 (synaptic tagging and capture, STC) 模型，在该模型中，一个短暂的诱导刺激会生成一个可塑性相关产物 (plasticity-related products, PRPs) 池，其浓度为 $R(t)$，并且在一段树突上空间同质分布。两个突触，索引为 $i \\in \\{1,2\\}$，在捕获窗口期内具有时间不变的标记强度 $T_{1}$ 和 $T_{2}$。PRP池由合成和损耗过程控制：PRPs由刺激驱动的通量 $S(t) \\ge 0$ 合成，以速率常数 $\\kappa  0$ 进行一级衰变，并通过标记-PRP结合被突触不可逆地捕获。假设以下基于化学动力学和生物物理模型的基本原则：\n- 质量作用定律控制突触 $i$ 处不可逆的标记-PRP捕获，捕获速率常数为 $\\eta  0$，除了 $R(t)$ 的耗尽外没有其他饱和效应。\n- 突触 $i$ 处的捕获通量 $c_{i}(t)$ 与 $T_{i}$ 和 $R(t)$ 的瞬时乘积成正比。\n- PRP池 $R(t)$ 在捕获窗口期内是充分混合的，并且对两个突触是共有的。\n- 总捕获的PRP等于时间积分总和 $\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t$。\n\n将突触1的预期分配分数定义为\n$$\nA_{1} \\equiv \\frac{\\int_{0}^{\\infty} c_{1}(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t}.\n$$\n在不求解 $R(t)$ 或指定 $S(t)$ 的情况下，仅用标记强度 $T_{1}$ 和 $T_{2}$ 推导 $A_{1}$ 的封闭形式表达式，然后确定当 $T_{1} \\gg T_{2}$ 时 $A_{1}$ 的优势极限值。\n\n使用LaTeX的 $\\mathrm{pmatrix}$ 环境，将最终答案表示为一个双元素行矩阵，第一个元素为 $A_{1}(T_{1},T_{2})$ 的通用表达式，第二个元素为 $T_{1} \\gg T_{2}$ 条件下 $A_{1}$ 的极限值。无需四舍五入。无需单位。",
            "solution": "问题要求我们求出分配给突触1的可塑性相关产物 (PRPs) 的分数，定义为 $A_{1}$。该分数由突触1在无限时间范围内捕获的总PRPs与两个突触捕获的总PRPs之比给出。\n$$\nA_{1} \\equiv \\frac{\\int_{0}^{\\infty} c_{1}(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t}\n$$\n\n根据问题陈述，突触 $i$ 的捕获通量 $c_{i}(t)$ 受质量作用定律支配。它与标记强度 $T_{i}$ 和公共PRP浓度 $R(t)$ 的瞬时乘积成正比。我们可以用一个对两个突触都适用的单一速率常数 $\\eta  0$ 来写出这个关系：\n$$\nc_{i}(t) = \\eta T_{i} R(t)\n$$\n其中 $i \\in \\{1,2\\}$。常数 $\\eta$ 包含了标记对PRP的内在结合亲和力，而 $T_i$ 代表突触 $i$ 处标记位点的数量或可用性。\n\n现在我们可以将这些捕获通量的表达式代入 $A_{1}$ 的定义中。\n对于分子，突触1捕获的总PRP为：\n$$\n\\int_{0}^{\\infty} c_{1}(t)\\,\\mathrm{d}t = \\int_{0}^{\\infty} \\eta T_{1} R(t)\\,\\mathrm{d}t\n$$\n对于分母，两个突触捕获的总PRP为：\n$$\n\\int_{0}^{\\infty} \\big(c_{1}(t) + c_{2}(t)\\big)\\,\\mathrm{d}t = \\int_{0}^{\\infty} \\big(\\eta T_{1} R(t) + \\eta T_{2} R(t)\\big)\\,\\mathrm{d}t\n$$\n我们可以从分母的被积函数中提出公因式：\n$$\n\\int_{0}^{\\infty} \\eta (T_{1} + T_{2}) R(t)\\,\\mathrm{d}t\n$$\n现在，我们构建 $A_{1}$ 的分数形式：\n$$\nA_{1} = \\frac{\\int_{0}^{\\infty} \\eta T_{1} R(t)\\,\\mathrm{d}t}{\\int_{0}^{\\infty} \\eta (T_{1} + T_{2}) R(t)\\,\\mathrm{d}t}\n$$\n问题陈述指出，标记强度 $T_{1}$ 和 $T_{2}$ 是不随时间变化的。捕获速率常数 $\\eta$ 也是一个常数。由于积分是线性运算，我们可以将这些常数从积分中提出来：\n$$\nA_{1} = \\frac{\\eta T_{1} \\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t}{\\eta (T_{1} + T_{2}) \\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t}\n$$\n项 $\\int_{0}^{\\infty} R(t)\\,\\mathrm{d}t$ 代表PRPs的总时间积分浓度。对于任何涉及瞬时合成脉冲 $S(t)$ 和衰变/捕获过程的物理现实情景，该积分将是一个有限的正值。只要该积分不为零（这意味着对所有 $t$ 都有 $R(t)=0$，这是一个平凡情况），它就可以从分子和分母中约去。常数 $\\eta$ 也被约去。\n\n这个约分是关键步骤，它避免了求解 $R(t)$ 的完整微分方程 $\\frac{\\mathrm{d}R}{\\mathrm{d}t} = S(t) - (\\kappa + \\eta T_1 + \\eta T_2)R(t)$ 的需要。$A_1$ 的比率结构使得解独立于 $R(t)$ 的详细时间进程、其合成 $S(t)$ 及其衰变 $\\kappa$。\n\n约分后，我们得到了一个仅依赖于标记强度 $T_{1}$ 和 $T_{2}$ 的 $A_{1}$ 的简单表达式：\n$$\nA_{1} = \\frac{T_{1}}{T_{1} + T_{2}}\n$$\n这是所需答案的第一部分。这个结果展示了竞争性结合的一个基本原理：一方捕获的共享资源的分数是其相对强度与所有竞争者总强度的比值。\n\n接下来，我们必须确定当 $T_{1} \\gg T_{2}$ 时 $A_{1}$ 的优势极限值。这个条件意味着比率 $\\frac{T_{2}}{T_{1}}$ 趋近于 $0$。为了评估这个极限，我们可以通过将分子和分母同时除以 $T_{1}$ 来对 $A_{1}$ 的表达式进行代数变换：\n$$\nA_{1} = \\frac{T_{1}/T_{1}}{(T_{1} + T_{2})/T_{1}} = \\frac{1}{1 + \\frac{T_{2}}{T_{1}}}\n$$\n现在，我们取 $T_{1} \\gg T_{2}$ 的极限，这等价于 $\\frac{T_{2}}{T_{1}} \\to 0$：\n$$\n\\lim_{\\frac{T_{2}}{T_{1}} \\to 0} A_{1} = \\lim_{\\frac{T_{2}}{T_{1}} \\to 0} \\frac{1}{1 + \\frac{T_{2}}{T_{1}}} = \\frac{1}{1 + 0} = 1\n$$\n这个结果在直觉上是正确的：如果突触1的标记强度远大于突触2的标记，那么它预计会捕获几乎所有可用的PRPs，使其分配分数趋近于 $1$。\n\n所需的两个量是 $A_{1}$ 的通用表达式及其极限值。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{T_{1}}{T_{1} + T_{2}}  1\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一个模型的最终价值在于其解释和预测实验结果的能力。在这项最后的实践中，你将扮演一名计算神经科学家的角色：基于时间重叠推导出一个关于巩固率的理论曲线，然后将此模型与模拟的实验数据进行拟合，以估计潜在的标记和蛋白质寿命。这项练习弥合了抽象理论与实际数据分析之间的鸿沟。",
            "id": "4025852",
            "problem": "您被要求在突触标记与捕获 (Synaptic Tagging and Capture, STC) 模型的背景下，对一个时间扫描实验进行形式化和计算分析。该实验通过改变弱突触事件（设置一个瞬时标记）和强突触事件（诱导一个可塑性相关产物池）之间的时间差 $\\,\\Delta t\\,$，并测量巩固率作为 $\\,\\Delta t\\,$ 的函数。您的目标是，从适用于STC的第一性原理出发，推导出一个由衰减动力学驱动的、基于重叠的巩固曲线，并将模型参数与给定数据进行拟合，以提取标记和产物池的特征衰减时间常数，分别表示为 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。\n\n请使用以下基本依据进行推导：\n- 弱事件设置一个初始大小为 $\\,T_{0}\\,$ 的突触标记，该标记以时间常数 $\\,\\tau_{T}\\,$ 指数衰减，因此在时间 $\\,t\\,$ 的标记大小为 $\\,T(t) = T_{0}\\,e^{-t/\\tau_{T}}$（当 $\\,t \\ge 0\\,$ 时）。\n- 强事件在时间 $\\,t = \\Delta t\\,$ 产生一个初始大小为 $\\,P_{0}\\,$ 的可塑性相关产物池，该产物池以时间常数 $\\,\\tau_{P}\\,$ 指数衰减，因此 $\\,P(t) = P_{0}\\,e^{-(t-\\Delta t)/\\tau_{P}}$（当 $\\,t \\ge \\Delta t\\,$ 时），且 $\\,P(t) = 0\\,$（当 $\\,t  \\Delta t\\,$ 时）。\n- 巩固由重叠捕获驱动，即有效巩固驱动力与乘积 $\\,T(t)P(t)\\,$ 对 $\\,t\\,$ 的时间积分成正比，再乘以一个恒定的捕获效率 $\\,k  0\\,$。\n\n您必须：\n1. 仅从上述基础推导依赖于 $\\Delta t$ 的巩固曲线，不引入这些定义未包含的任何额外目标公式。\n2. 实现一个非线性曲线拟合程序，从提供的关于 $\\,\\Delta t\\,$ 的巩固率数据中估计 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。假设一个未知的振幅参数 $\\,A  0\\,$，该参数吸收了诸如 $\\,T_{0}\\,$、$\\,P_{0}\\,$ 和 $\\,k\\,$ 等常数以及任何比例因子，因此待拟合的模型参数为 $\\,(\\tau_{T}, \\tau_{P}, A)\\,$。将 $\\,\\tau_{T}\\,$、$\\,\\tau_{P}\\,$ 和 $\\,A\\,$ 约束为严格为正。\n3. 所有时间常数 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$ 以秒为单位表示，并以四舍五入到三位小数的浮点数形式返回。\n4. 您的程序应生成单行输出，其中包含一个由列表组成的列表，格式为 $\\,[[\\tau_{T}^{(1)},\\tau_{P}^{(1)}],[\\tau_{T}^{(2)},\\tau_{P}^{(2)}],\\ldots]\\,$。\n\n测试套件和数据：\n您将把模型拟合到三个独立的数据集，每个数据集指定了一系列 $\\,\\Delta t\\,$ 值（单位：秒）和相应的测量巩固率（无量纲浮点数，范围在 $[0,1]$）。对于每个数据集，计算并返回估计的 $\\,\\tau_{T}\\,$ 和 $\\,\\tau_{P}\\,$。\n\n- 数据集 $\\,1\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-200, -100, -50, -25, 0, 25, 50, 100, 200]\\,$（秒）。\n  - 巩固率：$\\,[0.158158,\\,0.308050,\\,0.429919,\\,0.507889,\\,0.600000,\\,0.321157,\\,0.171903,\\,0.049251,\\,0.004043]\\,$。\n\n- 数据集 $\\,2\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-400, -200, -100, -50, 0, 50, 100, 200, 400]\\,$（秒）。\n  - 巩固率：$\\,[0.012820,\\,0.094735,\\,0.257515,\\,0.424572,\\,0.700000,\\,0.424572,\\,0.257515,\\,0.094735,\\,0.012820]\\,$。\n\n- 数据集 $\\,3\\,$：\n  - $\\,\\Delta t\\,$ 值：$\\,[-60, -30, -10, 0, 10, 30, 60]\\,$（秒）。\n  - 巩固率：$\\,[0.039830,\\,0.178504,\\,0.485225,\\,0.800000,\\,0.294303,\\,0.039830,\\,0.001983]\\,$。\n\n设计的曲线拟合应测试不同方面：\n- 具有不对称时间常数的通用识别（数据集 $\\,1\\,$）。\n- 具有相等时间常数的边界条件（数据集 $\\,2\\,$）。\n- 具有窄巩固窗口和快速衰减的边缘情况（数据集 $\\,3\\,$）。\n\n您的程序必须是自包含的，不得读取任何外部输入，并且必须精确打印单行，其中包含一个列表的列表，内容是按上述要求以秒为单位、四舍五入到三位小数的估计时间常数。不涉及角度单位。不涉及百分比；所有输出必须是浮点数。给定上述数据，计算应完全可复现。",
            "solution": "该问题要求在突触标记与捕获 (STC) 模型的背景下，推导并计算拟合一个巩固率曲线。该过程包括两个主要步骤：首先，推导巩固率作为弱刺激和强刺激之间时间延迟 $\\Delta t$ 的函数的解析形式；其次，实现一个数值程序，将此模型与提供的实验数据进行拟合，以估计一组生物物理参数。\n\n### 步骤1：巩固曲线 $C(\\Delta t)$ 的推导\n\n模型的基本原理已提供。在时间 $t=0$ 的弱刺激建立一个突触标记 $T(t)$，在时间 $t=\\Delta t$ 的强刺激生成一个可塑性相关产物池 $P(t)$。\n\n标记大小定义为：\n$$ T(t) = \\begin{cases} T_0 e^{-t/\\tau_T}  \\text{for } t \\ge 0 \\\\ 0  \\text{for } t  0 \\end{cases} $$\n其中 $T_0$ 是初始标记大小，$\\tau_T$ 是标记的衰减时间常数。\n\n可塑性产物池浓度定义为：\n$$ P(t) = \\begin{cases} P_0 e^{-(t-\\Delta t)/\\tau_P}  \\text{for } t \\ge \\Delta t \\\\ 0  \\text{for } t  \\Delta t \\end{cases} $$\n其中 $P_0$ 是初始产物大小，$\\tau_P$ 是产物的衰减时间常数。\n\n假设巩固与标记和产物信号的重叠积分成正比。因此，我们表示为 $C(\\Delta t)$ 的巩固率与乘积 $T(t)P(t)$ 的时间积分成正比：\n$$ C(\\Delta t) = k \\int_{-\\infty}^{\\infty} T(t)P(t) dt $$\n其中 $k0$ 是表示捕获效率的常数。\n\n为了计算该积分，我们首先注意到被积函数 $T(t)P(t)$ 仅在 $T(t)$ 和 $P(t)$ 均不为零时才不为零。这要求 $t \\ge 0$ 和 $t \\ge \\Delta t$。因此，积分的下限必须是 $\\max(0, \\Delta t)$。\n\n该积分（我们表示为 $I(\\Delta t)$）是：\n$$ I(\\Delta t) = \\int_{\\max(0, \\Delta t)}^{\\infty} \\left( T_0 e^{-t/\\tau_T} \\right) \\left( P_0 e^{-(t-\\Delta t)/\\tau_P} \\right) dt $$\n我们可以从被积函数中分离出不依赖时间的部分：\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t/\\tau_T} e^{-t/\\tau_P} dt $$\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t(1/\\tau_T + 1/\\tau_P)} dt $$\n我们为组合衰减定义一个有效时间常数 $\\tau_{eff}$：\n$$ \\frac{1}{\\tau_{eff}} = \\frac{1}{\\tau_T} + \\frac{1}{\\tau_P} = \\frac{\\tau_T + \\tau_P}{\\tau_T \\tau_P} \\implies \\tau_{eff} = \\frac{\\tau_T \\tau_P}{\\tau_T + \\tau_P} $$\n积分计算结果为：\n$$ \\int_{\\max(0, \\Delta t)}^{\\infty} e^{-t/\\tau_{eff}} dt = \\left[ -\\tau_{eff} e^{-t/\\tau_{eff}} \\right]_{\\max(0, \\Delta t)}^{\\infty} = 0 - (-\\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}}) = \\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}} $$\n将此结果代入 $I(\\Delta t)$ 的表达式中：\n$$ I(\\Delta t) = T_0 P_0 e^{\\Delta t/\\tau_P} \\tau_{eff} e^{-\\max(0, \\Delta t)/\\tau_{eff}} $$\n我们现在分析这个表达式在时间延迟 $\\Delta t$ 为正和为负时的两种情况。\n\n**情况1：$\\Delta t \\ge 0$ (弱刺激先于或同时于强刺激)**\n在这种情况下，$\\max(0, \\Delta t) = \\Delta t$。表达式变为：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} e^{-\\Delta t/\\tau_{eff}} = T_0 P_0 \\tau_{eff} e^{\\Delta t(1/\\tau_P - 1/\\tau_{eff})} $$\n代入 $1/\\tau_{eff}$ 的定义：\n$$ \\frac{1}{\\tau_P} - \\frac{1}{\\tau_{eff}} = \\frac{1}{\\tau_P} - \\left(\\frac{1}{\\tau_T} + \\frac{1}{\\tau_P}\\right) = -\\frac{1}{\\tau_T} $$\n因此，对于 $\\Delta t \\ge 0$：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{-\\Delta t/\\tau_T} $$\n\n**情况2：$\\Delta t  0$ (强刺激先于弱刺激)**\n在这种情况下，$\\max(0, \\Delta t) = 0$。表达式变为：\n$$ I(\\Delta t) = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} e^{-0/\\tau_{eff}} = T_0 P_0 \\tau_{eff} e^{\\Delta t/\\tau_P} $$\n\n结合这两种情况，巩固率 $C(\\Delta t) = k I(\\Delta t)$ 由下式给出：\n$$ C(\\Delta t) = k T_0 P_0 \\tau_{eff} \\times \\begin{cases} e^{\\Delta t/\\tau_P}  \\text{if } \\Delta t  0 \\\\ e^{-\\Delta t/\\tau_T}  \\text{if } \\Delta t \\ge 0 \\end{cases} $$\n问题指示我们定义一个未知的振幅参数 $A$，该参数吸收了所有常数和比例因子。项 $k T_0 P_0 \\tau_{eff}$ 包含初始大小 ($T_0, P_0$)、效率 ($k$) 以及一个依赖于待拟合参数 $\\tau_T$ 和 $\\tau_P$ 的因子 $\\tau_{eff}$。将整个项吸收到单个振幅参数 $A$ 中是一种标准的简化，可以使拟合过程更加稳定。因此，我们定义 $A = k T_0 P_0 \\tau_{eff} = k T_0 P_0 \\left(\\frac{\\tau_T \\tau_P}{\\tau_T + \\tau_P}\\right)$。\n\n最终用于数据拟合的模型函数是：\n$$ f(\\Delta t; A, \\tau_T, \\tau_P) = \\begin{cases} A e^{\\Delta t/\\tau_P}  \\text{if } \\Delta t  0 \\\\ A e^{-\\Delta t/\\tau_T}  \\text{if } \\Delta t \\ge 0 \\end{cases} $$\n该函数表示一个双边指数衰减，在 $\\Delta t=0$ 处达到峰值，振幅为 $A$，并且对于正 $\\Delta t$ 和负 $\\Delta t$ 可能具有不同的衰减常数 $\\tau_T$ 和 $\\tau_P$。\n\n### 步骤2：参数估计的计算策略\n\n任务是找到最能拟合所提供数据集的参数 $(A, \\tau_T, \\tau_P)$。这是一个非线性最小二乘回归问题。我们将使用 `scipy.optimize` 模块中的 `curve_fit` 函数。\n\n对每个数据集的程序如下：\n1.  **定义模型函数**：创建一个实现 $f(\\Delta t; A, \\tau_T, \\tau_P)$ 的 Python 函数。该函数将接受自变量 $\\Delta t$ 和三个参数作为输入。\n2.  **提供初始猜测值 ($p_0$)**：`curve_fit` 算法需要参数的初始猜测值。我们可以从数据中估算这些值：\n    *   $A_{guess}$：观测到的最大巩固率是 $A$ 的一个良好估计。\n    *   $\\tau_{T,guess}$：对于一个数据点 $(\\Delta t_i, y_i)$ 且 $\\Delta t_i  0$，我们有 $y_i \\approx A e^{-\\Delta t_i / \\tau_T}$。可以将其反转以估计 $\\tau_T \\approx -\\Delta t_i / \\ln(y_i/A)$。我们将使用具有最大正 $\\Delta t_i$ 的点来进行稳定估计。\n    *   $\\tau_{P,guess}$：类似地，对于一个数据点 $(\\Delta t_j, y_j)$ 且 $\\Delta t_j  0$，我们有 $y_j \\approx A e^{\\Delta t_j / \\tau_P}$，从而得到估计值 $\\tau_P \\approx \\Delta t_j / \\ln(y_j/A)$。我们将使用具有最负 $\\Delta t_j$ 的点。\n3.  **设置参数边界**：问题规定 $A, \\tau_T,$ 和 $\\tau_P$ 必须严格为正。这通过 `curve_fit` 的 `bounds` 参数来强制执行。所有三个参数的下界将设置为一个小的正数（例如 $10^{-9}$）以确保正性和数值稳定性，而上界将是无穷大。\n4.  **执行拟合**：使用实验数据（$\\Delta t$ 值和巩固率）、模型函数、初始猜测值和边界调用 `curve_fit`。该函数返回最小化残差平方和的最优参数值。\n5.  **提取并格式化结果**：从拟合的参数中，我们提取 $\\tau_T$ 和 $\\tau_P$ 的值，按照要求将它们四舍五入到三位小数，并存储它们。对所有三个数据集重复此过程。最后，将收集到的参数对格式化为指定的字符串格式。\n\n这种方法论提供了一条从第一性原理推导到模型关键参数定量估计的稳健路径，并遵守了问题的所有约束和要求。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import curve_fit\n\ndef solve():\n    \"\"\"\n    Derives and fits a synaptic tagging and capture model to three datasets.\n\n    The model function for the consolidation rate C as a function of the\n    time difference dt is a double exponential:\n    C(dt) = A * exp(dt / tau_P) for dt  0\n    C(dt) = A * exp(-dt / tau_T) for dt >= 0\n\n    The function fits parameters A, tau_T, and tau_P for each dataset\n    using nonlinear least squares and returns the estimated time constants.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"delta_t\": np.array([-200, -100, -50, -25, 0, 25, 50, 100, 200]),\n            \"rates\": np.array([0.158158, 0.308050, 0.429919, 0.507889, 0.600000, 0.321157, 0.171903, 0.049251, 0.004043])\n        },\n        {\n            \"delta_t\": np.array([-400, -200, -100, -50, 0, 50, 100, 200, 400]),\n            \"rates\": np.array([0.012820, 0.094735, 0.257515, 0.424572, 0.700000, 0.424572, 0.257515, 0.094735, 0.012820])\n        },\n        {\n            \"delta_t\": np.array([-60, -30, -10, 0, 10, 30, 60]),\n            \"rates\": np.array([0.039830, 0.178504, 0.485225, 0.800000, 0.294303, 0.039830, 0.001983])\n        }\n    ]\n\n    def stc_model(delta_t, A, tau_T, tau_P):\n        \"\"\"\n        Synaptic Tagging and Capture consolidation model function.\n\n        Args:\n            delta_t (np.ndarray): Time difference(s) between weak and strong stimuli.\n            A (float): Amplitude parameter.\n            tau_T (float): Decay time constant for the synaptic tag (for delta_t >= 0).\n            tau_P (float): Decay time constant for the plasticity product (for delta_t  0).\n\n        Returns:\n            np.ndarray: The predicted consolidation rates.\n        \"\"\"\n        # np.where selects between the two exponential decay forms based on the sign of delta_t.\n        # This creates the asymmetric double-exponential curve.\n        return A * np.exp(np.where(delta_t  0, delta_t / tau_P, -delta_t / tau_T))\n\n    results = []\n    \n    for case in test_cases:\n        x_data = case[\"delta_t\"]\n        y_data = case[\"rates\"]\n\n        # 1. Generate initial guesses (p0) for the fitting parameters.\n        A_guess = np.max(y_data)\n        \n        # Estimate tau_T from the last positive-time data point.\n        pos_time_mask = x_data > 0\n        if np.any(pos_time_mask):\n            last_pos_x = x_data[pos_time_mask][-1]\n            last_pos_y = y_data[pos_time_mask][-1]\n            # tau_T = -t / ln(y/A)\n            tau_T_guess = -last_pos_x / np.log(np.clip(last_pos_y / A_guess, 1e-9, 1-1e-9))\n        else: # Fallback if no positive time points\n            tau_T_guess = 100.0\n\n        # Estimate tau_P from the first negative-time data point.\n        neg_time_mask = x_data  0\n        if np.any(neg_time_mask):\n            first_neg_x = x_data[neg_time_mask][0]\n            first_neg_y = y_data[neg_time_mask][0]\n            # tau_P = t / ln(y/A)\n            tau_P_guess = first_neg_x / np.log(np.clip(first_neg_y / A_guess, 1e-9, 1-1e-9))\n        else: # Fallback if no negative time points\n            tau_P_guess = 100.0\n            \n        p0 = [A_guess, tau_T_guess, tau_P_guess]\n\n        # 2. Define bounds for the parameters (must be strictly positive).\n        # We use a small positive number instead of 0 for numerical stability.\n        lower_bounds = [1e-9, 1e-9, 1e-9]\n        upper_bounds = [np.inf, np.inf, np.inf]\n        bounds = (lower_bounds, upper_bounds)\n\n        # 3. Perform the nonlinear least-squares fit.\n        try:\n            popt, _ = curve_fit(stc_model, x_data, y_data, p0=p0, bounds=bounds, method='trf')\n            A_fit, tau_T_fit, tau_P_fit = popt\n        except RuntimeError:\n            # Fallback in case the fit fails, though unlikely with these data\n            tau_T_fit, tau_P_fit = -1.0, -1.0\n\n        # 4. Store the rounded results.\n        results.append([round(tau_T_fit, 3), round(tau_P_fit, 3)])\n\n    # Final print statement in the exact required format.\n    string_results = [f\"[{res_pair[0]},{res_pair[1]}]\" for res_pair in results]\n    print(f\"[{','.join(string_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}