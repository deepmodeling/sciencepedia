{
    "hands_on_practices": [
        {
            "introduction": "本练习是一项基础任务，旨在将系统巩固的核心原则——快速的海马体学习和缓慢的皮层学习——转化为一个精确的数学模型。通过此实践，您将掌握将概念性思想形式化为微分方程组的关键技能，这是计算神经科学的基石 。",
            "id": "4026522",
            "problem": "您正在使用两个相互作用的突触群体来模拟单个记忆痕迹的系统性巩固：一个海马权重 $w_h(t)$ 和一个皮层权重 $w_c(t)$。使用以下在大脑建模和计算神经科学中被广泛接受的基本出发点：(i) 在没有输入的情况下，由于稳态和生化更新过程，一个可塑性突触会指数级地松弛至基线水平，在小幅度下，这可以由一个带有衰减率 $\\lambda0$ 的线性“漏积分器” $\\frac{dw}{dt}=-\\lambda w$ 来描述；(ii) 小的、短暂的可塑性事件可以使用狄拉克δ函数 $\\delta(t)$ 作为冲激输入来描述；(iii) 当一个网络通过重新激活来“教导”另一个网络时，学习者的可塑性速率与教导者的当前痕迹成正比，这与小权重的线性化赫布驱动一致。对于在 $t=0$ 时刻发生的单个情景事件，采用以下额外的建模假设：(a) 海马系统通过一个幅度为 $\\eta0$ 的瞬时增量来编码该事件，该增量表示为一个与 $\\delta(t)$ 成正比的冲激输入；(b) 皮层不直接接收此冲激，而是通过一个耦合强度 $\\kappa0$ 从海马学习；(c) 在所关心的时间尺度上，没有从皮层到海马的反馈；(d) 海马和皮层的被动衰减率分别为 $\\alpha0$ 和 $\\beta0$；(e) 初始条件为 $w_h(0^-)=0$ 和 $w_c(0^-)=0$。在这些假设下，该双网络巩固模型必须是一个由 $t=0$ 时的事件驱动的耦合线性时不变系统。哪个选项正确地指明了控制微分方程、为实现系统性巩固（海马比皮层快）所需的参数符号和顺序约束，以及对于这个单个事件，在 $t0$ 时 $w_h(t)$ 和 $w_c(t)$ 的闭式响应？\n\nA. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。\n\nB. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c-\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=-\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。\n\nC. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\kappa\\,w_c+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=0$。\n\nD. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\beta\\alpha0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\alpha+\\beta}\\,e^{-(\\alpha+\\beta)t}$。",
            "solution": "### 问题验证\n\n#### 第1步：提取已知条件\n- **变量**：海马权重 $w_h(t)$ 和皮层权重 $w_c(t)$。\n- **基本原理 (i)**：一个可塑性突触在没有输入的情况下会指数级地松弛，这由线性“漏积分器”模型描述：$\\frac{dw}{dt}=-\\lambda w$，衰减率为 $\\lambda  0$。\n- **基本原理 (ii)**：小的、短暂的可塑性事件被建模为使用狄拉克δ函数 $\\delta(t)$ 的冲激输入。\n- **基本原理 (iii)**：当一个网络“教导”另一个网络时，学习者的可塑性速率与教导者的当前痕迹成正比（线性化赫布驱动）。\n- **建模假设 (a)**：在 $t=0$ 时，海马系统编码一个事件，其瞬时增量幅度为 $\\eta  0$，表示为与 $\\delta(t)$ 成正比的冲激输入。\n- **建模假设 (b)**：皮层从海马学习，耦合强度为 $\\kappa  0$。皮层不直接接收冲激。\n- **建模假设 (c)**：没有从皮层到海马的反馈。\n- **建模假设 (d)**：海马和皮层的被动衰减率分别为 $\\alpha  0$ 和 $\\beta  0$。\n- **建模假设 (e)**：初始条件为 $w_h(0^-)=0$ 和 $w_c(0^-)=0$。\n- **约束**：最终模型必须是一个耦合线性时不变系统。\n- **目标**：确定正确的控制微分方程组、实现“海马比皮层快”的参数约束，以及对于 $t0$ 时 $w_h(t)$ 和 $w_c(t)$ 的闭式解。\n\n#### 第2步：使用提取的已知条件进行验证\n问题陈述具有科学依据、是良定的、客观且内部一致。\n- **科学依据**：该问题描述了一个计算神经科学中关于系统记忆巩固的简化但标准且广泛使用的模型。使用漏积分器来描述突触衰减和使用耦合线性微分方程来模拟网络相互作用是理论神经科学的基石。\n- **良定性**：该问题定义了一个具有指定初始条件和强迫函数（一个冲激）的线性常微分方程组。这构成了一个良定的初值问题，其存在唯一、稳定且有意义的解。\n- **完整性和一致性**：该问题提供了构建和求解模型所需的所有必要组成部分。各项原理和假设是相互一致的，并且可以直接且无歧义地导出一个特定的数学公式。例如，假设(c)（无反馈）与假设(b)（皮层从海马学习）是一致的。术语“海马比皮层快”在衰减率的相对大小方面有清晰的解释。\n\n#### 第3步：结论和行动\n问题陈述是**有效的**。将继续进行求解过程。\n\n### 模型和解的推导\n\n#### 1. 控制微分方程\n根据所提供的原理和假设，我们构建方程组。\n\n- **对于海马权重 $w_h(t)$**：\n  - 被动衰减（原理 i，假设 d）：变化率包含一个项 $-\\alpha w_h(t)$。\n  - 事件编码（原理 ii，假设 a）：在 $t=0$ 时有一个强度为 $\\eta$ 的冲激输入，得到一个项 $+\\eta\\,\\delta(t)$。\n  - 无皮层反馈（假设 c）：没有依赖于 $w_c(t)$ 的项。\n  将这些结合起来，得到 $w_h(t)$ 的方程：\n  $$ \\frac{dw_h}{dt} = -\\alpha w_h(t) + \\eta\\,\\delta(t) $$\n\n- **对于皮层权重 $w_c(t)$**：\n  - 被动衰减（原理 i，假设 d）：变化率包含一个项 $-\\beta w_c(t)$。\n  - 从海马学习（原理 iii，假设 b）：皮层从海马学习，所以其可塑性速率与教导者的痕迹 $w_h(t)$ 成正比。耦合强度为 $\\kappa0$。这种“教导”意味着一个正向驱动，因此该项为 $+\\kappa\\,w_h(t)$。\n  - 无直接冲激（假设 b）：在 $w_c(t)$ 的方程中没有 $\\delta(t)$ 项。\n  将这些结合起来，得到 $w_c(t)$ 的方程：\n  $$ \\frac{dw_c}{dt} = -\\beta w_c(t) + \\kappa\\,w_h(t) $$\n\n#### 2. 参数约束\n- 常数 $\\eta$、$\\kappa$、$\\alpha$ 和 $\\beta$ 都被给定为正数。\n- 条件“海马比皮层快”指的是记忆痕迹的内在动力学。一个“更快”的系统具有更短的时间常数，或者等效地，更大的衰减率。海马的衰减率是 $\\alpha$，皮层的衰减率是 $\\beta$。因此，这个条件要求 $\\alpha  \\beta$。\n- 完整的约束集是：$\\eta0$，$\\kappa0$ 和 $\\alpha\\beta0$。\n\n#### 3. 对于 $t0$ 的解\n我们求解具有初始条件 $w_h(0^-)=0$ 和 $w_c(0^-)=0$ 的微分方程组。\n\n- **求解 $w_h(t)$**：\n  方程为 $\\frac{dw_h}{dt} + \\alpha w_h = \\eta\\,\\delta(t)$。\n  为了找到在 $t=0^+$ 时的初始条件，我们对冲激从 $t=0^-$ 到 $t=0^+$ 进行积分：\n  $$ \\int_{0^-}^{0^+} \\frac{dw_h}{dt} dt + \\alpha \\int_{0^-}^{0^+} w_h(t) dt = \\int_{0^-}^{0^+} \\eta\\,\\delta(t) dt $$\n  $$ [w_h(t)]_{0^-}^{0^+} + 0 = \\eta $$\n  $$ w_h(0^+) - w_h(0^-) = \\eta $$\n  给定 $w_h(0^-)=0$，我们得到 $w_h(0^+) = \\eta$。\n  对于 $t0$，δ函数为零，方程变为齐次的：$\\frac{dw_h}{dt} = -\\alpha w_h$。\n  这个具有初始条件 $w_h(0^+) = \\eta$ 的一阶常微分方程的解是：\n  $$ w_h(t) = \\eta\\,e^{-\\alpha t} \\quad \\text{对于 } t0 $$\n\n- **求解 $w_c(t)$**：\n  将 $w_h(t)$ 的解代入 $t0$ 时 $w_c(t)$ 的方程中：\n  $$ \\frac{dw_c}{dt} + \\beta w_c = \\kappa\\,\\eta\\,e^{-\\alpha t} $$\n  这是一个一阶线性非齐次常微分方程。初始条件是 $w_c(0)=0$（因为这个方程的输入 $w_h(t)$ 在 $t0$ 时是有限的，所以在 $t=0$ 时 $w_c$ 没有跳变，因此 $w_c(0^+)=w_c(0^-)=0$）。\n  我们使用积分因子法。积分因子是 $I(t) = e^{\\int \\beta dt} = e^{\\beta t}$。\n  将常微分方程乘以 $I(t)$：\n  $$ e^{\\beta t}\\frac{dw_c}{dt} + \\beta e^{\\beta t} w_c = \\kappa\\,\\eta\\,e^{\\beta t} e^{-\\alpha t} $$\n  $$ \\frac{d}{dt}(w_c e^{\\beta t}) = \\kappa\\,\\eta\\,e^{(\\beta - \\alpha)t} $$\n  对两边从 $0$ 到 $t$ 进行积分：\n  $$ \\int_0^t \\frac{d}{d\\tau}(w_c(\\tau)e^{\\beta \\tau}) d\\tau = \\int_0^t \\kappa\\,\\eta\\,e^{(\\beta - \\alpha)\\tau} d\\tau $$\n  $$ [w_c(\\tau)e^{\\beta \\tau}]_0^t = \\kappa\\,\\eta \\left[ \\frac{e^{(\\beta-\\alpha)\\tau}}{\\beta-\\alpha} \\right]_0^t $$\n  注意 $\\beta - \\alpha \\neq 0$，因为我们已经确定 $\\alpha  \\beta$。\n  $$ w_c(t)e^{\\beta t} - w_c(0)e^0 = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{(\\beta-\\alpha)t} - e^0) $$\n  使用 $w_c(0)=0$：\n  $$ w_c(t)e^{\\beta t} = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{(\\beta-\\alpha)t} - 1) $$\n  $$ w_c(t) = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{-\\beta t}e^{(\\beta-\\alpha)t} - e^{-\\beta t}) $$\n  $$ w_c(t) = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{-\\alpha t} - e^{-\\beta t}) $$\n  这就是对于 $t0$ 时 $w_c(t)$ 的解。\n\n### 选项评估\n\n- **A. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。**\n  - 控制方程与我们的推导完全匹配。\n  - 参数约束与我们的推导匹配，正确地将“海马比皮层快”解释为 $\\alpha  \\beta$。\n  - 对于 $t0$ 时 $w_h(t)$ 和 $w_c(t)$ 的闭式解与我们求解出的表达式匹配。\n  - 结论：**正确**。\n\n- **B. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c-\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=-\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。**\n  - $w_c(t)$ 的方程不正确。项 $-\\kappa\\,w_h$ 代表来自海马的抑制性或去增强效应，这与问题设定的海马“教导”皮层（巩固）的前提相矛盾。\n  - 结论：**不正确**。\n\n- **C. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\kappa\\,w_c+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c$。 约束: $\\eta0$, $\\kappa0$, $\\alpha\\beta0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=0$。**\n  - 方程不正确。$w_h$ 方程包含一个反馈项 $+\\kappa\\,w_c$，这被假设(c)明确禁止。$w_c$ 方程缺少来自海马的学习项，这与假设(b)和原理(iii)相矛盾。\n  - 提出的解也与提出的方程不一致。\n  - 结论：**不正确**。\n\n- **D. 方程: $\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。 约束: $\\eta0$, $\\kappa0$, $\\beta\\alpha0$。 对于 $t0$ 的解: $w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\alpha+\\beta}\\,e^{-(\\alpha+\\beta)t}$。**\n  - 约束 $\\beta\\alpha0$ 不正确。这将意味着皮层比海马“更快”，与系统性巩固的前提相矛盾。\n  - $w_c(t)$ 的解在数学上是不正确的；它不是给定微分方程的解。正确的函数形式涉及两个指数的差，而不是单个指数。\n  - 结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在构建了基础模型之后，下一步自然是利用它来生成可检验的预测，从而区分相互竞争的科学理论。本练习将通过简化版的标准巩固理论（Standard Consolidation Theory, SCT）和多重痕迹理论（Multiple Trace Theory, MTT）模型，展示计算建模的强大之处，揭示它们如何预测海马体损伤后截然不同的逆行性遗忘模式 。",
            "id": "4026464",
            "problem": "单个情景记忆由两个相互作用的子系统支持：一个海马迹和一个新皮层迹。它们对编码后回忆的贡献 $H(t)$ 和 $C(t)$ 随时间变化，其中 $t \\ge 0$ 表示测试时的记忆年龄。总体回忆概率被建模为 $R(t) = \\alpha C(t) + \\beta H(t)$，其中参数 $\\alpha  0$ 和 $\\beta  0$ 反映了子系统的读出增益。测试时的完全海马损伤被建模为一个乘性损伤影响因子 $s_H = 0$，该因子仅作用于海马项，而皮层贡献保持不变 ($s_C = 1$)。\n\n假设存在以下广泛使用的动力学假设：\n\n- 根据标准巩固理论 (SCT)，海马支持以时间常数 $\\tau  0$ 的一级过程衰减，而随着巩固的进行，皮层支持达到饱和。这由耦合线性常微分方程建模：$ \\frac{dH}{dt} = -\\frac{1}{\\tau} H$（其中 $H(0) = 1$），以及 $ \\frac{dC}{dt} = \\frac{1}{\\tau} \\left(1 - C\\right)$（其中 $C(0) = 0$）。\n\n- 根据多重痕迹理论 (MTT)，海马的参与不随记忆年龄衰减，即 $ \\frac{dH}{dt} = 0$（其中 $H(0) = 1$），而随着特定于记忆的新皮层表征逐渐增强，皮层支持仍然会饱和，$ \\frac{dC}{dt} = \\frac{1}{\\tau_c} \\left(1 - C\\right)$（其中 $C(0) = 0$ 且 $\\tau_c  0$）。你可以假设 $\\tau_c$ 是有限的正数。请注意，在此模型下，对于海马损伤，只有 $H(t)$ 将决定逆行性损害。\n\n将完全海马损伤后的逆行性遗忘梯度定义为损害函数 $I(t) = R_{\\mathrm{control}}(t) - R_{\\mathrm{lesion}}(t)$，其中 $R_{\\mathrm{control}}(t)$ 是无损伤时的回忆，$R_{\\mathrm{lesion}}(t)$ 是在测试时施加海马损伤后的回忆。考虑一个有限的逆行窗口 $[0, T]$（其中 $T  0$），并将给定理论在此窗口内的平均损害定义为 $\\bar{I} = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt$。\n\n从上述动力学假设以及 $R(t)$ 和 $I(t)$ 的定义出发，推导海马损伤逆行性遗忘梯度 $I_{\\mathrm{SCT}}(t)$ 和 $I_{\\mathrm{MTT}}(t)$，然后计算比率\n$$\nQ(\\tau, T) \\equiv \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt}.\n$$\n请用 $\\tau$ 和 $T$ 表示你的最终答案，形式为一个单一的闭式解析表达式。不需要进行数值计算，也不需要单位。结果应为一个简化的表达式。最终答案中不需要包含将预测梯度与 Ribot 法则进行比较的解释性讨论。",
            "solution": "首先验证问题陈述，以确保其在科学上成立、适定、客观且完整。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件：**\n- 子系统对回忆的贡献：海马 $H(t)$ 和新皮层 $C(t)$，记忆年龄 $t \\ge 0$。\n- 总体回忆概率：$R(t) = \\alpha C(t) + \\beta H(t)$，增益 $\\alpha  0$, $\\beta  0$。\n- 海马损伤模型：海马项上的乘性因子 $s_H = 0$。\n- 标准巩固理论 (SCT) 动力学：\n  - $\\frac{dH}{dt} = -\\frac{1}{\\tau} H$，其中 $H(0) = 1$，时间常数 $\\tau  0$。\n  - $\\frac{dC}{dt} = \\frac{1}{\\tau} (1 - C)$，其中 $C(0) = 0$。\n- 多重痕迹理论 (MTT) 动力学：\n  - $\\frac{dH}{dt} = 0$，其中 $H(0) = 1$。\n  - $\\frac{dC}{dt} = \\frac{1}{\\tau_c} (1 - C)$，其中 $C(0) = 0$，时间常数 $\\tau_c  0$。\n- 逆行性遗忘损害：$I(t) = R_{\\mathrm{control}}(t) - R_{\\mathrm{lesion}}(t)$。\n- 在窗口 $[0, T]$（其中 $T0$）上的平均损害：$\\bar{I} = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt$。\n- 待计算量：$Q(\\tau, T) = \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt}$。\n\n**1.2. 根据标准进行验证：**\n- **科学上成立：** 该问题使用已建立的（尽管是简化的）数学模型（一级线性常微分方程）来表示记忆巩固的两个主要且相互竞争的科学理论的核心宗旨：标准巩固理论 (SCT) 和多重痕迹理论 (MTT)。这种方法在计算神经科学中是标准做法。\n- **适定的：** 该问题包含求解线性常微分方程的初值问题，这些问题具有唯一且稳定的解。后续对损害函数、其积分以及最终比率的计算都是明确定义的数学过程。该问题是自洽的，并导向一个唯一的解。\n- **客观的：** 该问题以精确、正式且无偏见的数学语言陈述。\n\n**1.3. 结论：**\n该问题有效。这是一个定义明确的数学练习，其基础是计算神经科学中已建立的概念。\n\n### 步骤 2：求解推导\n\n求解过程需要推导损害函数 $I_{\\mathrm{SCT}}(t)$ 和 $I_{\\mathrm{MTT}}(t)$，然后计算它们在区间 $[0, T]$ 上的平均值之比。\n\n**2.1. 标准巩固理论 (SCT) 分析**\n\n首先，我们求解 SCT 下关于 $H(t)$ 和 $C(t)$ 的微分方程。\n海马迹的方程是 $\\frac{dH}{dt} = -\\frac{1}{\\tau} H$，其中 $H(0) = 1$。这是一个标准的指数衰减模型，其解为：\n$$ H_{\\mathrm{SCT}}(t) = H(0) \\exp\\left(-\\frac{t}{\\tau}\\right) = \\exp\\left(-\\frac{t}{\\tau}\\right) $$\n皮层迹的方程是 $\\frac{dC}{dt} = \\frac{1}{\\tau}(1 - C)$，可以改写为 $\\frac{dC}{dt} + \\frac{1}{\\tau}C = \\frac{1}{\\tau}$，其中 $C(0) = 0$。这是一个一级线性常微分方程。其解的形式为 $C(t) = 1 - \\exp(-\\frac{t}{\\tau'})$，对于某个时间常数 $\\tau'$。代入常微分方程，我们发现 $\\tau' = \\tau$。使用初始条件 $C(0)=0$：$0 = 1-\\exp(0) = 1-1=0$，条件满足。因此：\n$$ C_{\\mathrm{SCT}}(t) = 1 - \\exp\\left(-\\frac{t}{\\tau}\\right) $$\n在对照条件下，回忆概率为：\n$$ R_{\\mathrm{control, SCT}}(t) = \\alpha C_{\\mathrm{SCT}}(t) + \\beta H_{\\mathrm{SCT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) + \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) $$\n对于完全的海马损伤（$s_H=0$），回忆概率为：\n$$ R_{\\mathrm{lesion, SCT}}(t) = \\alpha C_{\\mathrm{SCT}}(t) + \\beta \\cdot 0 \\cdot H_{\\mathrm{SCT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) $$\nSCT 的损害函数是对照和损伤回忆之间的差值：\n$$ I_{\\mathrm{SCT}}(t) = R_{\\mathrm{control, SCT}}(t) - R_{\\mathrm{lesion, SCT}}(t) = \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) $$\n这个结果表明，在 SCT 模型下，由海马损伤引起的损害对于近期记忆（$t$ 较小）最大，并对更早的记忆呈指数衰减，这就是典型的时间梯度逆行性遗忘，即 Ribot 法则。\n\n**2.2. 多重痕迹理论 (MTT) 分析**\n\n接下来，我们求解 MTT 下关于 $H(t)$ 和 $C(t)$ 的微分方程。\n海马迹的方程是 $\\frac{dH}{dt} = 0$，其中 $H(0) = 1$。其解为一个常数：\n$$ H_{\\mathrm{MTT}}(t) = 1 $$\n皮层迹的方程是 $\\frac{dC}{dt} = \\frac{1}{\\tau_c}(1-C)$，其中 $C(0)=0$。这与 SCT 的皮层方程形式相同，只是用 $\\tau_c$ 替换了 $\\tau$。其解为：\n$$ C_{\\mathrm{MTT}}(t) = 1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right) $$\n在对照条件下，回忆概率为：\n$$ R_{\\mathrm{control, MTT}}(t) = \\alpha C_{\\mathrm{MTT}}(t) + \\beta H_{\\mathrm{MTT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right)\\right) + \\beta $$\n对于完全的海马损伤，回忆概率为：\n$$ R_{\\mathrm{lesion, MTT}}(t) = \\alpha C_{\\mathrm{MTT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right)\\right) $$\nMTT 的损害函数是两者之差：\n$$ I_{\\mathrm{MTT}}(t) = R_{\\mathrm{control, MTT}}(t) - R_{\\mathrm{lesion, MTT}}(t) = \\beta $$\n这个结果表明，在 MTT 模型下，损害是恒定的，不依赖于记忆年龄，预测出一个平坦的逆行性遗忘梯度。\n\n**2.3. 计算比率 $Q(\\tau, T)$**\n\n问题要求计算平均损害的比率：\n$$ Q(\\tau, T) = \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt} $$\n分子和分母中的因子 $\\frac{1}{T}$ 会消掉，所以我们可以计算定积分的比率。\n$$ Q(\\tau, T) = \\frac{\\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt} $$\n首先，我们计算分子中的积分：\n$$ \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt = \\int_{0}^{T} \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) \\, dt = \\beta \\left[ -\\tau\\exp\\left(-\\frac{t}{\\tau}\\right) \\right]_{0}^{T} $$\n$$ = \\beta \\left( -\\tau\\exp\\left(-\\frac{T}{\\tau}\\right) - (-\\tau\\exp(0)) \\right) = \\beta\\tau \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right) $$\n接下来，我们计算分母中的积分：\n$$ \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt = \\int_{0}^{T} \\beta \\, dt = \\beta [t]_{0}^{T} = \\beta T $$\n现在，我们构建比率 $Q(\\tau, T)$：\n$$ Q(\\tau, T) = \\frac{\\beta\\tau \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right)}{\\beta T} $$\n参数 $\\beta$ 从分子和分母中消去。最终的表达式是：\n$$ Q(\\tau, T) = \\frac{\\tau}{T} \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right) $$\n这是以 $\\tau$ 和 $T$ 表示的最终闭式解析表达式。",
            "answer": "$$ \\boxed{\\frac{\\tau}{T} \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right)} $$"
        },
        {
            "introduction": "前面的练习将记忆痕迹建模为单个变量，而本练习则更深入地探讨了记忆提取的机制，将皮层视为一个神经元群体。您的目标是实现一个模型，其中海马体的“指针”触发皮层重激活，并探索噪声和激活阈值如何影响提取成功率，从而将抽象的痕迹动态与更具体的神经机制联系起来 。",
            "id": "4026436",
            "problem": "考虑一个系统性巩固的指针驱动再激活模型，其中海马体 (HPC) 提供索引式线索，触发皮层记忆印迹的恢复。将皮层建模为由 $N$ 个二元单元组成的群体，其中 $S$ 个单元属于目标印迹，而 $N - S$ 个单元为非印迹单元。当呈现单个 HPC 索引时，每个皮层单元接收一个标量输入，该输入由一个确定性均值加上代表指针不精确性的附加、独立高斯噪声组成。具体来说，对于印迹单元，输入均值为 $\\mu_s$；对于非印迹单元，输入均值为 $\\mu_n$。指针噪声被建模为方差为 $\\sigma^2$、均值为 $0$ 的高斯分布，且在各单元间独立。每个皮层单元采用固定的阈值激活规则：如果其输入至少为 $\\theta$，则该单元被激活，否则保持非激活状态。如果至少有 $m$ 个印迹单元被激活，并且最多有 $r$ 个非印迹单元被激活，则检索被判定为成功。\n\n您的任务是，在单元输入在 HPC 指针条件下独立的假设下，从应用于高斯噪声和阈值检测的概率论第一性原理出发，推导出一个检索概率的表达式，该表达式是 $(N, S, \\mu_s, \\mu_n, \\sigma^2, \\theta, m, r)$ 的函数。然后，实现一个程序，对提供的一组测试用例进行该概率的数值计算。\n\n仅使用以下基本事实：\n- 附加的独立高斯噪声：对于每个单元 $i$，输入为 $X_i = \\mu_i + \\xi_i$，其中 $\\xi_i \\sim \\mathcal{N}(0,\\sigma^2)$，并且根据单元 $i$ 是印迹单元还是非印迹单元，$\\mu_i \\in \\{\\mu_s, \\mu_n\\}$。\n- 标准正态分布的累积分布函数 (CDF) 与跨越阈值的概率相关：如果 $Z \\sim \\mathcal{N}(0,1)$，则 $\\Pr(Z \\le z) = \\Phi(z)$，其中 $\\Phi(\\cdot)$ 是标准正态分布的 CDF。\n- 独立伯努利随机变量之和产生二项分布：在 $n$ 次独立的伯努利试验中，若单次成功概率为 $p$，则成功次数服从 $\\mathrm{Binomial}(n,p)$ 分布。\n\n将检索表述为一个联合事件，该事件涉及两个独立的计数：跨越阈值的印迹单元数量和跨越阈值的非印迹单元数量。根据阈值激活规则和高斯噪声的暗示，将检索概率表示为满足成功标准的二项式概率的双重求和。\n\n您的程序应计算以下参数集的检索概率，这些参数集作为测试套件：\n- 测试用例 $1$：$N = 100$, $S = 20$, $\\mu_s = 1.5$, $\\mu_n = 0.0$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 15$, $r = 5$。\n- 测试用例 $2$：$N = 50$, $S = 10$, $\\mu_s = 1.0$, $\\mu_n = 0.0$, $\\sigma^2 = 1.0$, $\\theta = 1.0$, $m = 5$, $r = 2$。\n- 测试用例 $3$：$N = 100$, $S = 20$, $\\mu_s = 1.5$, $\\mu_n = 0.0$, $\\sigma^2 = 4.0$, $\\theta = 1.0$, $m = 12$, $r = 8$。\n- 测试用例 $4$：$N = 80$, $S = 30$, $\\mu_s = 0.0$, $\\mu_n = 0.0$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 20$, $r = 3$。\n- 测试用例 $5$：$N = 60$, $S = 10$, $\\mu_s = 2.0$, $\\mu_n = -0.5$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 8$, $r = 0$。\n\n所有变量都是无量纲的，且不涉及角度。对于每个测试用例，输出必须是代表检索概率的单个实数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4,result_5]$）。顺序必须与上述测试套件的顺序相匹配。不应打印任何其他文本。",
            "solution": "该问题要求在一个指针驱动的系统巩固再激活模型中，推导检索概率的表达式，并实现程序对几个测试用例进行计算。该问题具有科学依据，定义明确，且所有必要的参数和定义均已提供。因此，该问题被认定为有效。\n\n推导过程从第一性原理开始，如下所示。\n\n**1. 单个单元的激活概率**\n\n设 $X_i$ 为皮层单元 $i$ 的输入。该输入是平均信号 $\\mu_i$ 和独立高斯噪声 $\\xi_i \\sim \\mathcal{N}(0, \\sigma^2)$ 的和。如果一个单元的输入 $X_i$ 超过阈值 $\\theta$，它就会被激活。我们需要为印迹单元和非印迹单元分别计算此事件的概率。\n\n对于一个**印迹单元**，输入均值为 $\\mu_s$。输入为 $X_s = \\mu_s + \\xi_i$，其中 $\\xi_i$ 是从 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的样本。如果 $X_s \\ge \\theta$，该单元被激活。单个印迹单元的激活概率，记为 $p_s$，是：\n$$ p_s = \\Pr(X_s \\ge \\theta) = \\Pr(\\mu_s + \\xi_i \\ge \\theta) = \\Pr(\\xi_i \\ge \\theta - \\mu_s) $$\n为了使用标准正态累积分布函数 (CDF) $\\Phi(z) = \\Pr(Z \\le z)$，其中 $Z \\sim \\mathcal{N}(0, 1)$，我们通过将随机变量 $\\xi_i$ 除以其标准差 $\\sigma = \\sqrt{\\sigma^2}$ 来对其进行标准化。\n$$ p_s = \\Pr\\left(\\frac{\\xi_i}{\\sigma} \\ge \\frac{\\theta - \\mu_s}{\\sigma}\\right) $$\n由于 $\\frac{\\xi_i}{\\sigma} \\sim \\mathcal{N}(0, 1)$，我们可以写成：\n$$ p_s = \\Pr\\left(Z \\ge \\frac{\\theta - \\mu_s}{\\sigma}\\right) = 1 - \\Pr\\left(Z  \\frac{\\theta - \\mu_s}{\\sigma}\\right) = 1 - \\Phi\\left(\\frac{\\theta - \\mu_s}{\\sigma}\\right) $$\n\n对于一个**非印迹单元**，输入均值为 $\\mu_n$。输入为 $X_n = \\mu_n + \\xi_i$。单个非印迹单元的激活概率，记为 $p_n$，推导过程类似：\n$$ p_n = \\Pr(X_n \\ge \\theta) = \\Pr(\\mu_n + \\xi_i \\ge \\theta) = 1 - \\Phi\\left(\\frac{\\theta - \\mu_n}{\\sigma}\\right) $$\n\n**2. 激活单元的数量**\n\n皮层包含 $S$ 个印迹单元和 $N-S$ 个非印迹单元。由于加到每个单元输入的噪声是独立的，因此每个单元的激活是一个独立的伯努利试验。\n\n设 $K_s$ 为激活的印迹单元数量的随机变量。由于有 $S$ 个印迹单元，每个单元以概率 $p_s$ 激活，因此 $K_s$ 服从二项分布：\n$$ K_s \\sim \\mathrm{Binomial}(S, p_s) $$\n恰好有 $k_s$ 个印迹单元被激活的概率由二项概率质量函数 (PMF) 给出：\n$$ \\Pr(K_s = k_s) = \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} $$\n\n类似地，设 $K_n$ 为激活的非印迹单元数量的随机变量。有 $N-S$ 个非印迹单元，每个单元以概率 $p_n$ 激活。因此，$K_n$ 服从二项分布：\n$$ K_n \\sim \\mathrm{Binomial}(N-S, p_n) $$\n恰好有 $k_n$ 个非印迹单元被激活的概率是：\n$$ \\Pr(K_n = k_n) = \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} $$\n\n**3. 检索成功概率**\n\n检索成功需要同时满足两个条件：\n1. 激活的印迹单元数量至少为 $m$：$K_s \\ge m$。\n2. 激活的非印迹单元数量最多为 $r$：$K_n \\le r$。\n\n设 $P_s$ 为满足第一个条件的概率，$P_n$ 为满足第二个条件的概率。总检索概率 $P_{\\text{retrieval}}$ 是联合事件 $(K_s \\ge m) \\cap (K_n \\le r)$ 的概率。由于印迹和非印迹群体不相交，且单元激活是独立的，因此随机变量 $K_s$ 和 $K_n$ 是独立的。所以，联合概率是个体概率的乘积：\n$$ P_{\\text{retrieval}} = \\Pr(K_s \\ge m \\text{ and } K_n \\le r) = \\Pr(K_s \\ge m) \\times \\Pr(K_n \\le r) = P_s \\times P_n $$\n\n我们可以将 $P_s$ 和 $P_n$ 表示为二项概率的和：\n$$ P_s = \\Pr(K_s \\ge m) = \\sum_{k_s=m}^{S} \\Pr(K_s = k_s) = \\sum_{k_s=m}^{S} \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} $$\n$$ P_n = \\Pr(K_n \\le r) = \\sum_{k_n=0}^{r} \\Pr(K_n = k_n) = \\sum_{k_n=0}^{r} \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} $$\n这些和对应于相应二项分布的生存函数（或互补 CDF）和累积分布函数 (CDF)。\n\n具体来说，$P_s$ 是 $\\mathrm{Binomial}(S, p_s)$ 在 $m-1$ 处的生存函数，即 $1 - F_{K_s}(m-1)$，其中 $F_{K_s}$ 是 $K_s$ 的 CDF。而 $P_n$ 是 $\\mathrm{Binomial}(N-S, p_n)$ 在 $r$ 处的 CDF，即 $F_{K_n}(r)$。\n\n**4. 最终表达式**\n\n检索概率的最终表达式为：\n$$ P_{\\text{retrieval}} = \\left( \\sum_{k_s=m}^{S} \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} \\right) \\times \\left( \\sum_{k_n=0}^{r} \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} \\right) $$\n其中\n$$ p_s = 1 - \\Phi\\left(\\frac{\\theta - \\mu_s}{\\sqrt{\\sigma^2}}\\right) \\quad \\text{和} \\quad p_n = 1 - \\Phi\\left(\\frac{\\theta - \\mu_n}{\\sqrt{\\sigma^2}}\\right) $$\n\n该公式将使用用于正态 CDF 和二项分布的统计函数进行数值实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, binom\n\ndef calculate_retrieval_probability(N, S, mu_s, mu_n, sigma_sq, theta, m, r):\n    \"\"\"\n    Calculates the retrieval probability based on the pointer-driven reactivation model.\n\n    Args:\n        N (int): Total number of cortical units.\n        S (int): Number of engram units.\n        mu_s (float): Mean input for engram units.\n        mu_n (float): Mean input for non-engram units.\n        sigma_sq (float): Variance of the Gaussian noise.\n        theta (float): Activation threshold for cortical units.\n        m (int): Minimum number of active engram units for successful retrieval.\n        r (int): Maximum number of active non-engram units for successful retrieval.\n\n    Returns:\n        float: The probability of successful retrieval.\n    \"\"\"\n    # Standard deviation of the noise\n    sigma = np.sqrt(sigma_sq)\n\n    # Calculate the activation probability for a single engram unit (p_s) and\n    # a single non-engram unit (p_n).\n    # If sigma is zero, the activation is deterministic.\n    if sigma == 0:\n        p_s = 1.0 if mu_s = theta else 0.0\n        p_n = 1.0 if mu_n = theta else 0.0\n    else:\n        # Standardize the variable to use the standard normal CDF\n        z_s = (theta - mu_s) / sigma\n        p_s = 1.0 - norm.cdf(z_s)\n\n        z_n = (theta - mu_n) / sigma\n        p_n = 1.0 - norm.cdf(z_n)\n\n    # Number of non-engram units\n    num_non_engram = N - S\n    \n    # Calculate the probability of the engram success condition:\n    # at least m engram units become active.\n    # This is P(K_s = m), where K_s ~ Binomial(S, p_s).\n    # This is equivalent to the survival function (1 - CDF) evaluated at m-1.\n    prob_engram_success = binom.sf(m - 1, S, p_s)\n\n    # Calculate the probability of the non-engram success condition:\n    # at most r non-engram units become active.\n    # This is P(K_n = r), where K_n ~ Binomial(N-S, p_n).\n    # This is the cumulative distribution function (CDF) evaluated at r.\n    prob_non_engram_success = binom.cdf(r, num_non_engram, p_n)\n\n    # The total retrieval probability is the product of the probabilities of\n    # these two independent events.\n    total_probability = prob_engram_success * prob_non_engram_success\n    \n    return total_probability\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the test cases provided in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (N, S, mu_s, mu_n, sigma_sq, theta, m, r)\n    test_cases = [\n        (100, 20, 1.5, 0.0, 0.25, 1.0, 15, 5),\n        (50, 10, 1.0, 0.0, 1.0, 1.0, 5, 2),\n        (100, 20, 1.5, 0.0, 4.0, 1.0, 12, 8),\n        (80, 30, 0.0, 0.0, 0.25, 1.0, 20, 3),\n        (60, 10, 2.0, -0.5, 0.25, 1.0, 8, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, S, mu_s, mu_n, sigma_sq, theta, m, r = case\n        result = calculate_retrieval_probability(N, S, mu_s, mu_n, sigma_sq, theta, m, r)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}