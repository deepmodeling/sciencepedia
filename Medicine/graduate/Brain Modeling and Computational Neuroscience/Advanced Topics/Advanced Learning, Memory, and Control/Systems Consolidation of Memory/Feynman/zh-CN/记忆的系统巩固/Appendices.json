{
    "hands_on_practices": [
        {
            "introduction": "系统巩固理论的核心思想是记忆从海马体逐渐转移到新皮层。这个过程可以通过数学模型来精确描述。本练习将指导您构建一个基础的双网络模型，利用微分方程来捕捉海马体和皮层记忆痕迹之间的动态相互作用。通过将“海马体快速衰减”和“皮层从海马体学习”等基本原则转化为一个可解的线性系统，您将掌握系统层面建模的基石 。",
            "id": "4026522",
            "problem": "您正在使用两个相互作用的突触群体来建模单个记忆痕迹的系统性巩固：一个海马权重 $w_h(t)$ 和一个皮层权重 $w_c(t)$。请使用以下在脑模型和计算神经科学中被广泛接受的通用起点：(i) 在没有输入的情况下，由于稳态和生化更新过程，一个可塑性突触会指数级地松弛到基线水平，在小幅度下，这可以被一个衰减率 $\\lambda0$ 的线性“漏泄积分器” $\\frac{dw}{dt}=-\\lambda w$ 捕捉；(ii) 小的、瞬态的可塑性事件可以使用狄拉克δ函数 $\\delta(t)$ 捕捉为脉冲输入；(iii) 当一个网络通过再激活“教导”另一个网络时，学习者的可塑性速率与教导者的当前痕迹成正比，这与小权重的线性化赫布驱动一致。对于 $t=0$ 时的单个情景事件，采用以下额外的建模假设：(a) 海马系统编码该事件，伴随着一个幅度为 $\\eta0$ 的瞬时增量，表示为与 $\\delta(t)$ 成正比的脉冲输入；(b) 皮层不直接接收此脉冲，而是通过一个耦合强度 $\\kappa0$ 从海马体学习；(c) 在我们感兴趣的时间尺度上，没有皮层反馈到海马体；(d) 海马和皮层的被动衰减率分别为 $\\alpha0$ 和 $\\beta0$；(e) 初始条件为 $w_h(0^-)=0$ 和 $w_c(0^-)=0$。在这些假设下，双网络巩固模型必须是一个由 $t=0$ 时的事件驱动的耦合线性时不变系统。哪个选项正确地指明了控制微分方程、实现系统性巩固（海马体快于皮层）所需的参数符号和排序约束，以及对于这个单一事件在 $t0$ 时的闭式响应 $w_h(t)$ 和 $w_c(t)$？\n\nA. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。约束：$\\eta0$，$\\kappa0$，$\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。\n\nB. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c-\\kappa\\,w_h$。约束：$\\eta0$，$\\kappa0$，$\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=-\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。\n\nC. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\kappa\\,w_c+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c$。约束：$\\eta0$，$\\kappa0$，$\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=0$。\n\nD. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。约束：$\\eta0$, $\\kappa0$, $\\beta\\alpha0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\alpha+\\beta}\\,e^{-(\\alpha+\\beta)t}$。",
            "solution": "### 问题验证\n\n#### 第1步：提取已知条件\n- **变量**：海马权重 $w_h(t)$ 和皮层权重 $w_c(t)$。\n- **通用原理 (i)**：在没有输入的情况下，一个可塑性突触会指数级地松弛，由线性“漏泄积分器”模型描述：$\\frac{dw}{dt}=-\\lambda w$，衰减率为 $\\lambda  0$。\n- **通用原理 (ii)**：小的、瞬态的可塑性事件被建模为使用狄拉克δ函数 $\\delta(t)$ 的脉冲输入。\n- **通用原理 (iii)**：当一个网络“教导”另一个网络时，学习者的可塑性速率与教导者的当前痕迹成正比（线性化的赫布驱动）。\n- **建模假设 (a)**：在 $t=0$ 时，海马系统编码一个事件，伴随着幅度为 $\\eta  0$ 的瞬时增量，表示为与 $\\delta(t)$ 成正比的脉冲输入。\n- **建模假设 (b)**：皮层以耦合强度 $\\kappa  0$ 从海马体学习。皮层不直接接收脉冲。\n- **建模假设 (c)**：没有皮层反馈到海马体。\n- **建模假设 (d)**：海马和皮层的被动衰减率分别为 $\\alpha  0$ 和 $\\beta  0$。\n- **建模假设 (e)**：初始条件为 $w_h(0^-)=0$ 和 $w_c(0^-)=0$。\n- **约束**：最终模型必须是一个耦合线性时不变系统。\n- **目标**：确定正确的控制微分方程组、实现“海马体快于皮层”的参数约束，以及对于 $t0$ 时 $w_h(t)$ 和 $w_c(t)$ 的闭式解。\n\n#### 第2步：使用提取的已知条件进行验证\n问题陈述具有科学依据、良构、客观且内部一致。\n- **科学依据**：该问题描述了一个简化但标准且广泛使用的计算神经科学中的系统性记忆巩固模型。使用漏泄积分器来模拟突触衰减和使用耦合线性微分方程来建模网络交互是理论神经科学的基石。\n- **良构性**：该问题定义了一个具有指定初始条件和驱动函数（脉冲）的线性常微分方程组。这构成了一个良构的初值问题，它允许一个唯一的、稳定的和有意义的解。\n- **完整性和一致性**：该问题提供了构建和求解模型所需的所有必要组件。原理和假设相互一致，并直接导出一个没有歧义的特定数学公式。例如，假设（c）（无反馈）与假设（b）（皮层从海马体学习）是一致的。“海马体快于皮层”这一术语在衰减率的相对大小方面有明确的解释。\n\n#### 第3步：结论和行动\n问题陈述是 **有效的**。将继续进行求解过程。\n\n### 模型和解的推导\n\n#### 1. 控制微分方程\n基于所提供的原理和假设，我们构建方程组。\n\n- **对于海马权重 $w_h(t)$**：\n  - 被动衰减（原理 i，假设 d）：变化率包含一个项 $-\\alpha w_h(t)$。\n  - 事件编码（原理 ii，假设 a）：在 $t=0$ 时有一个强度为 $\\eta$ 的脉冲输入，得到一个项 $+\\eta\\,\\delta(t)$。\n  - 无皮层反馈（假设 c）：没有依赖于 $w_c(t)$ 的项。\n  结合这些，得到 $w_h(t)$ 的方程：\n  $$ \\frac{dw_h}{dt} = -\\alpha w_h(t) + \\eta\\,\\delta(t) $$\n\n- **对于皮层权重 $w_c(t)$**：\n  - 被动衰减（原理 i，假设 d）：变化率包含一个项 $-\\beta w_c(t)$。\n  - 从海马体学习（原理 iii，假设 b）：皮层从海马体学习，因此其可塑性速率与教导者的痕迹 $w_h(t)$ 成正比。耦合强度为 $\\kappa0$。这种“教导”意味着一个正向驱动，所以该项为 $+\\kappa\\,w_h(t)$。\n  - 无直接脉冲（假设 b）：在 $w_c(t)$ 的方程中没有 $\\delta(t)$ 项。\n  结合这些，得到 $w_c(t)$ 的方程：\n  $$ \\frac{dw_c}{dt} = -\\beta w_c(t) + \\kappa\\,w_h(t) $$\n\n#### 2. 参数约束\n- 常数 $\\eta$, $\\kappa$, $\\alpha$, 和 $\\beta$ 都被给定为正数。\n- “海马体快于皮层”的条件指的是记忆痕迹的内在动力学。一个“更快”的系统有更短的时间常数，或者等价地，有更大的衰减率。海马的衰减率是 $\\alpha$，皮层的衰减率是 $\\beta$。因此，这个条件要求 $\\alpha  \\beta$。\n- 完整的约束集是：$\\eta0$, $\\kappa0$, 以及 $\\alpha\\beta0$。\n\n#### 3. 对于 $t0$ 的解\n我们求解具有初始条件 $w_h(0^-)=0$ 和 $w_c(0^-)=0$ 的微分方程组。\n\n- **求解 $w_h(t)$**：\n  方程为 $\\frac{dw_h}{dt} + \\alpha w_h = \\eta\\,\\delta(t)$。\n  为了找到 $t=0^+$ 时的初始条件，我们在脉冲上从 $t=0^-$ 到 $t=0^+$ 进行积分：\n  $$ \\int_{0^-}^{0^+} \\frac{dw_h}{dt} dt + \\alpha \\int_{0^-}^{0^+} w_h(t) dt = \\int_{0^-}^{0^+} \\eta\\,\\delta(t) dt $$\n  $$ [w_h(t)]_{0^-}^{0^+} + 0 = \\eta $$\n  $$ w_h(0^+) - w_h(0^-) = \\eta $$\n  给定 $w_h(0^-)=0$，我们有 $w_h(0^+) = \\eta$。\n  对于 $t0$，δ函数为零，方程变为齐次的：$\\frac{dw_h}{dt} = -\\alpha w_h$。\n  这个具有初始条件 $w_h(0^+) = \\eta$ 的一阶常微分方程的解是：\n  $$ w_h(t) = \\eta\\,e^{-\\alpha t} \\quad \\text{for } t0 $$\n\n- **求解 $w_c(t)$**：\n  将 $w_h(t)$ 的解代入 $t0$ 时 $w_c(t)$ 的方程中：\n  $$ \\frac{dw_c}{dt} + \\beta w_c = \\kappa\\,\\eta\\,e^{-\\alpha t} $$\n  这是一个一阶线性非齐次常微分方程。初始条件是 $w_c(0)=0$（因为这个方程的输入 $w_h(t)$ 在 $t0$ 时是有限的，所以在 $t=0$ 时 $w_c$ 没有跳跃，因此 $w_c(0^+)=w_c(0^-)=0$）。\n  我们使用积分因子法。积分因子是 $I(t) = e^{\\int \\beta dt} = e^{\\beta t}$。\n  将常微分方程乘以 $I(t)$：\n  $$ e^{\\beta t}\\frac{dw_c}{dt} + \\beta e^{\\beta t} w_c = \\kappa\\,\\eta\\,e^{\\beta t} e^{-\\alpha t} $$\n  $$ \\frac{d}{dt}(w_c e^{\\beta t}) = \\kappa\\,\\eta\\,e^{(\\beta - \\alpha)t} $$\n  对两边从 $0$ 到 $t$ 积分：\n  $$ \\int_0^t \\frac{d}{d\\tau}(w_c(\\tau)e^{\\beta \\tau}) d\\tau = \\int_0^t \\kappa\\,\\eta\\,e^{(\\beta - \\alpha)\\tau} d\\tau $$\n  $$ [w_c(\\tau)e^{\\beta \\tau}]_0^t = \\kappa\\,\\eta \\left[ \\frac{e^{(\\beta-\\alpha)\\tau}}{\\beta-\\alpha} \\right]_0^t $$\n  注意 $\\beta - \\alpha \\neq 0$ 因为我们已经确定 $\\alpha  \\beta$。\n  $$ w_c(t)e^{\\beta t} - w_c(0)e^0 = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{(\\beta-\\alpha)t} - e^0) $$\n  使用 $w_c(0)=0$：\n  $$ w_c(t)e^{\\beta t} = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{(\\beta-\\alpha)t} - 1) $$\n  $$ w_c(t) = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{-\\beta t}e^{(\\beta-\\alpha)t} - e^{-\\beta t}) $$\n  $$ w_c(t) = \\frac{\\kappa\\,\\eta}{\\beta-\\alpha} (e^{-\\alpha t} - e^{-\\beta t}) $$\n  这是 $t0$ 时 $w_c(t)$ 的解。\n\n### 选项评估\n\n- **A. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。约束：$\\eta0$, $\\kappa0$, $\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。**\n  - 控制方程与我们的推导完全匹配。\n  - 参数约束与我们的推导匹配，正确地将“海马体快于皮层”解释为 $\\alpha  \\beta$。\n  - 对于 $t0$ 的 $w_h(t)$ 和 $w_c(t)$ 的闭式解与我们求解的表达式匹配。\n  - 结论：**正确**。\n\n- **B. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c-\\kappa\\,w_h$。约束：$\\eta0$, $\\kappa0$, $\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=-\\frac{\\kappa\\,\\eta}{\\beta-\\alpha}\\left(e^{-\\alpha t}-e^{-\\beta t}\\right)$。**\n  - $w_c(t)$ 的方程不正确。项 $-\\kappa\\,w_h$ 表示来自海马体的抑制或去增强效应，这与问题前提中海马体“教导”皮层（巩固）相矛盾。\n  - 结论：**不正确**。\n\n- **C. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\kappa\\,w_c+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c$。约束：$\\eta0$, $\\kappa0$, $\\alpha\\beta0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=0$。**\n  - 方程不正确。$w_h$ 方程包含一个反馈项 $+\\kappa\\,w_c$，这被假设(c)明确禁止。$w_c$ 方程缺少来自海马体的学习项，与假设(b)和原理(iii)相矛盾。\n  - 提出的解也与提出的方程不一致。\n  - 结论：**不正确**。\n\n- **D. 方程：$\\frac{dw_h}{dt}=-\\alpha w_h+\\eta\\,\\delta(t)$ 和 $\\frac{dw_c}{dt}=-\\beta w_c+\\kappa\\,w_h$。约束：$\\eta0$, $\\kappa0$, $\\beta\\alpha0$。对于 $t0$ 的解：$w_h(t)=\\eta\\,e^{-\\alpha t}$ 和 $w_c(t)=\\frac{\\kappa\\,\\eta}{\\alpha+\\beta}\\,e^{-(\\alpha+\\beta)t}$。**\n  - 约束 $\\beta\\alpha0$ 不正确。这将意味着皮层比海马体“更快”，与系统性巩固的前提相矛盾。\n  - $w_c(t)$ 的解在数学上是不正确的；它不是给定微分方程的解。正确的函数形式涉及两个指数的差，而不是单个指数。\n  - 结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "计算模型的一个强大功能是能够从相互竞争的理论中推导出可检验的定量预测。本练习将运用上一节建立的动力学模型框架，来形式化地比较关于记忆巩固的两个主要理论：标准巩固理论（SCT）和多重痕迹理论（MTT）。您将通过为每个理论设定不同的动力学方程，推导出它们对海马体损伤后逆行性遗忘梯度的独特预测。这项实践深刻地揭示了数学模型如何帮助我们辨别和测试宏观层面的神经科学理论 。",
            "id": "4026464",
            "problem": "单个情景记忆由两个相互作用的子系统支持：一个海马痕迹和一个新皮层痕迹。在编码后，它们对回忆的贡献 $H(t)$ 和 $C(t)$ 随时间变化，其中 $t \\ge 0$ 表示测试时的记忆年龄。总体回忆概率被建模为 $R(t) = \\alpha C(t) + \\beta H(t)$，其中参数 $\\alpha  0$ 和 $\\beta  0$ 反映了子系统的读出增益。测试时发生的完全性海马损伤通过一个乘性损伤影响因子 $s_H = 0$ 来建模，该因子仅作用于海马项，而皮层贡献保持不变 ($s_C = 1$)。\n\n假设以下广泛使用的动力学假设：\n\n- 根据标准巩固理论 (Standard Consolidation Theory, SCT)，海马的支持以时间常数为 $\\tau  0$ 的一阶过程衰减，而随着巩固的进行，皮层的支持趋于饱和。这由以下耦合线性常微分方程建模：$ \\frac{dH}{dt} = -\\frac{1}{\\tau} H$（初始条件为 $H(0) = 1$），以及 $ \\frac{dC}{dt} = \\frac{1}{\\tau} \\left(1 - C\\right)$（初始条件为 $C(0) = 0$）。\n\n- 根据多重痕迹理论 (Multiple Trace Theory, MTT)，海马的参与不随记忆年龄衰减，即 $ \\frac{dH}{dt} = 0$（初始条件为 $H(0) = 1$），而随着记忆特异性的新皮层表征被逐渐加强，皮层的支持仍然趋于饱和，$ \\frac{dC}{dt} = \\frac{1}{\\tau_c} \\left(1 - C\\right)$（初始条件为 $C(0) = 0$，且 $\\tau_c  0$）。您可以假设 $\\tau_c$ 是有限正数。注意，对于海马损伤，在该模型下只有 $H(t)$ 会决定逆行性损伤。\n\n将完全性海马损伤后的逆行性遗忘梯度定义为损伤函数 $I(t) = R_{\\mathrm{control}}(t) - R_{\\mathrm{lesion}}(t)$，其中 $R_{\\mathrm{control}}(t)$ 是无损伤时的回忆，而 $R_{\\mathrm{lesion}}(t)$ 是在测试时施加海马损伤后的回忆。考虑一个有限的逆行性窗口 $[0, T]$（其中 $T  0$），并将给定理论在该窗口内的平均损伤定义为 $\\bar{I} = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt$。\n\n从上述动力学假设以及 $R(t)$ 和 $I(t)$ 的定义出发，推导海马损伤逆行性遗忘梯度 $I_{\\mathrm{SCT}}(t)$ 和 $I_{\\mathrm{MTT}}(t)$，然后计算比率\n$$\nQ(\\tau, T) \\equiv \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt}.\n$$\n将您的最终答案表示为关于 $\\tau$ 和 $T$ 的单个闭式解析表达式。无需进行数值评估，也不需要单位。结果应为单个简化表达式。最终答案中无需包含将预测梯度与Ribot定律进行比较的解释性讨论。",
            "solution": "首先验证问题陈述，以确保其具有科学依据、良构、客观和完整。\n\n### 步骤1：问题验证\n\n**1.1. 提取已知条件：**\n- 对回忆的子系统贡献：海马 $H(t)$ 和新皮层 $C(t)$，记忆年龄 $t \\ge 0$。\n- 总体回忆概率：$R(t) = \\alpha C(t) + \\beta H(t)$，增益 $\\alpha  0$, $\\beta  0$。\n- 海马损伤模型：作用于海马项的乘性因子 $s_H = 0$。\n- 标准巩固理论 (SCT) 动力学：\n  - $\\frac{dH}{dt} = -\\frac{1}{\\tau} H$，初始条件 $H(0) = 1$，时间常数 $\\tau  0$。\n  - $\\frac{dC}{dt} = \\frac{1}{\\tau} (1 - C)$，初始条件 $C(0) = 0$。\n- 多重痕迹理论 (MTT) 动力学：\n  - $\\frac{dH}{dt} = 0$，初始条件 $H(0) = 1$。\n  - $\\frac{dC}{dt} = \\frac{1}{\\tau_c} (1 - C)$，初始条件 $C(0) = 0$，时间常数 $\\tau_c  0$。\n- 逆行性遗忘损伤：$I(t) = R_{\\mathrm{control}}(t) - R_{\\mathrm{lesion}}(t)$。\n- 在窗口 $[0, T]$（其中 $T0$）上的平均损伤：$\\bar{I} = \\frac{1}{T} \\int_{0}^{T} I(t) \\, dt$。\n- 待计算量：$Q(\\tau, T) = \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt}$。\n\n**1.2. 根据标准进行验证：**\n- **科学依据：** 该问题使用已建立但简化的数学模型（一阶线性常微分方程）来表示两种主要的、相互竞争的记忆巩固科学理论——标准巩固理论 (SCT) 和多重痕迹理论 (MTT)——的核心宗旨。这种方法在计算神经科学中是标准做法。\n- **良构性：** 该问题在于求解线性常微分方程的初值问题，这类问题有唯一且稳定的解。随后对损伤函数、其积分以及最终比率的计算都是明确定义的数学过程。问题是自洽的，并能导出一个唯一的解。\n- **客观性：** 问题以精确、正式且无偏见的数学语言陈述。\n\n**1.3. 结论：**\n问题有效。这是一个定义明确的数学练习，其基础是计算神经科学中的既定概念。\n\n### 步骤2：求解推导\n\n求解需要推导损伤函数 $I_{\\mathrm{SCT}}(t)$ 和 $I_{\\mathrm{MTT}}(t)$，然后计算它们在区间 $[0, T]$ 上的均值之比。\n\n**2.1. 标准巩固理论 (SCT) 分析**\n\n首先，我们求解SCT下的 $H(t)$ 和 $C(t)$ 的微分方程。\n海马痕迹的方程是 $\\frac{dH}{dt} = -\\frac{1}{\\tau} H$，初始条件为 $H(0) = 1$。这是一个标准的指数衰减模型，其解为：\n$$ H_{\\mathrm{SCT}}(t) = H(0) \\exp\\left(-\\frac{t}{\\tau}\\right) = \\exp\\left(-\\frac{t}{\\tau}\\right) $$\n皮层痕迹的方程是 $\\frac{dC}{dt} = \\frac{1}{\\tau}(1 - C)$，它可以改写为 $\\frac{dC}{dt} + \\frac{1}{\\tau}C = \\frac{1}{\\tau}$，初始条件为 $C(0) = 0$。这是一个一阶线性常微分方程。对于某个时间常数 $\\tau'$，解的形式为 $C(t) = 1 - \\exp(-\\frac{t}{\\tau'})$。代入常微分方程，我们发现 $\\tau' = \\tau$。使用初始条件 $C(0)=0$：$0 = 1-\\exp(0) = 1-1=0$，该条件得到满足。因此：\n$$ C_{\\mathrm{SCT}}(t) = 1 - \\exp\\left(-\\frac{t}{\\tau}\\right) $$\n在控制条件下，回忆概率为：\n$$ R_{\\mathrm{control, SCT}}(t) = \\alpha C_{\\mathrm{SCT}}(t) + \\beta H_{\\mathrm{SCT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) + \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) $$\n在完全性海马损伤（$s_H=0$）下，回忆概率为：\n$$ R_{\\mathrm{lesion, SCT}}(t) = \\alpha C_{\\mathrm{SCT}}(t) + \\beta \\cdot 0 \\cdot H_{\\mathrm{SCT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau}\\right)\\right) $$\nSCT的损伤函数是控制条件和损伤条件回忆概率之差：\n$$ I_{\\mathrm{SCT}}(t) = R_{\\mathrm{control, SCT}}(t) - R_{\\mathrm{lesion, SCT}}(t) = \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) $$\n这个结果表明，在SCT下，海马损伤引起的损伤对近期记忆（$t$ 较小）最大，对更久远的记忆则呈指数衰减，这就是经典的时间梯度性逆行性遗忘或称Ribot定律。\n\n**2.2. 多重痕迹理论 (MTT) 分析**\n\n接下来，我们求解MTT下的 $H(t)$ 和 $C(t)$ 的微分方程。\n海马痕迹的方程是 $\\frac{dH}{dt} = 0$，初始条件为 $H(0) = 1$。其解为一个常数：\n$$ H_{\\mathrm{MTT}}(t) = 1 $$\n皮层痕迹的方程是 $\\frac{dC}{dt} = \\frac{1}{\\tau_c}(1-C)$，初始条件为 $C(0)=0$。这与SCT的皮层方程形式相同，只是 $\\tau$ 被 $\\tau_c$ 替换。其解为：\n$$ C_{\\mathrm{MTT}}(t) = 1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right) $$\n在控制条件下，回忆概率为：\n$$ R_{\\mathrm{control, MTT}}(t) = \\alpha C_{\\mathrm{MTT}}(t) + \\beta H_{\\mathrm{MTT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right)\\right) + \\beta $$\n在完全性海马损伤下，回忆概率为：\n$$ R_{\\mathrm{lesion, MTT}}(t) = \\alpha C_{\\mathrm{MTT}}(t) = \\alpha\\left(1 - \\exp\\left(-\\frac{t}{\\tau_c}\\right)\\right) $$\nMTT的损伤函数是两者之差：\n$$ I_{\\mathrm{MTT}}(t) = R_{\\mathrm{control, MTT}}(t) - R_{\\mathrm{lesion, MTT}}(t) = \\beta $$\n这个结果表明，在MTT下，损伤是恒定的，不依赖于记忆年龄，从而预测了一个平坦的逆行性遗忘梯度。\n\n**2.3. 计算比率 $Q(\\tau, T)$**\n\n问题要求计算平均损伤的比率：\n$$ Q(\\tau, T) = \\frac{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\frac{1}{T} \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt} $$\n分子和分母中的因子 $\\frac{1}{T}$ 被约去，所以我们可以计算定积分的比率。\n$$ Q(\\tau, T) = \\frac{\\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt}{\\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt} $$\n首先，我们计算分子中的积分：\n$$ \\int_{0}^{T} I_{\\mathrm{SCT}}(t) \\, dt = \\int_{0}^{T} \\beta\\exp\\left(-\\frac{t}{\\tau}\\right) \\, dt = \\beta \\left[ -\\tau\\exp\\left(-\\frac{t}{\\tau}\\right) \\right]_{0}^{T} $$\n$$ = \\beta \\left( -\\tau\\exp\\left(-\\frac{T}{\\tau}\\right) - (-\\tau\\exp(0)) \\right) = \\beta\\tau \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right) $$\n接下来，我们计算分母中的积分：\n$$ \\int_{0}^{T} I_{\\mathrm{MTT}}(t) \\, dt = \\int_{0}^{T} \\beta \\, dt = \\beta [t]_{0}^{T} = \\beta T $$\n现在，我们构建比率 $Q(\\tau, T)$：\n$$ Q(\\tau, T) = \\frac{\\beta\\tau \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right)}{\\beta T} $$\n参数 $\\beta$ 从分子和分母中约去。最终表达式为：\n$$ Q(\\tau, T) = \\frac{\\tau}{T} \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right) $$\n这就是最终的关于 $\\tau$ 和 $T$ 的闭式解析表达式。",
            "answer": "$$ \\boxed{\\frac{\\tau}{T} \\left(1 - \\exp\\left(-\\frac{T}{\\tau}\\right)\\right)} $$"
        },
        {
            "introduction": "在宏观动力学模型之下，是神经元群体层面的具体机制。记忆的重激活被认为是系统巩固的关键过程，其中海马体的线索能够触发皮层记忆印迹的重现。本练习将带您从抽象的动力学方程转向一个更具机制性的“指针驱动重激活”模型，在充满噪声的神经元群体中模拟这一过程。您将运用概率论和信号检测论的原理，计算在指针不精确的情况下成功检索记忆的概率，从而获得构建和评估群体编码模型的实践经验 。",
            "id": "4026436",
            "problem": "考虑一个指针驱动的系统巩固再激活模型，其中海马体（HPC）提供类索引的线索，触发皮层记忆印迹的恢复。将皮层建模为一个由 $N$ 个二元单元组成的群体，其中 $S$ 个单元属于目标印迹，而 $N - S$ 个单元为非印迹单元。当单个HPC索引出现时，每个皮层单元接收一个标量输入，该输入由一个确定性均值加上代表指针不精确性的附加独立高斯噪声组成。具体来说，对于一个印迹单元，其输入均值为 $\\mu_s$；对于一个非印迹单元，其输入均值为 $\\mu_n$。指针噪声被建模为方差为 $\\sigma^2$、均值为 $0$ 的高斯噪声，且在各单元间独立。每个皮层单元应用一个固定的阈值激活规则：如果其输入至少为 $\\theta$，则该单元被激活，否则保持非激活状态。如果至少有 $m$ 个印迹单元被激活，并且最多有 $r$ 个非印迹单元被激活，则称提取成功。\n\n您的任务是，在单元输入在HPC指针条件下独立的假设下，从应用于高斯噪声和阈值检测的概率论第一性原理出发，推导出一个作为 $(N, S, \\mu_s, \\mu_n, \\sigma^2, \\theta, m, r)$ 函数的提取概率表达式。然后，实现一个程序，对给定的一组测试用例进行该概率的数值计算。\n\n仅使用以下基本事实：\n- 附加独立高斯噪声：对于每个单元 $i$，其输入 $X_i = \\mu_i + \\xi_i$，其中 $\\xi_i \\sim \\mathcal{N}(0,\\sigma^2)$，而 $\\mu_i \\in \\{\\mu_s, \\mu_n\\}$ 取决于单元 $i$ 是印迹单元还是非印迹单元。\n- 标准正态分布的累积分布函数（CDF）与跨越阈值的概率相关：如果 $Z \\sim \\mathcal{N}(0,1)$，则 $\\Pr(Z \\le z) = \\Phi(z)$，其中 $\\Phi(\\cdot)$ 是标准正态CDF。\n- 独立伯努利随机变量之和产生二项分布：在 $n$ 次独立的伯努利试验中，若单次成功概率为 $p$，则成功次数服从 $\\mathrm{Binomial}(n,p)$ 分布。\n\n将提取表述为一个联合事件，该事件涉及两个独立的计数：跨越阈值的印迹单元数量和跨越阈值的非印迹单元数量。根据阈值激活规则和高斯噪声的含义，将提取概率表示为满足成功标准的二项式概率的双重求和。\n\n您的程序应为以下参数集计算提取概率，这些参数集作为测试套件：\n- 测试用例 $1$：$N = 100$, $S = 20$, $\\mu_s = 1.5$, $\\mu_n = 0.0$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 15$, $r = 5$。\n- 测试用例 $2$：$N = 50$, $S = 10$, $\\mu_s = 1.0$, $\\mu_n = 0.0$, $\\sigma^2 = 1.0$, $\\theta = 1.0$, $m = 5$, $r = 2$。\n- 测试用例 $3$：$N = 100$, $S = 20$, $\\mu_s = 1.5$, $\\mu_n = 0.0$, $\\sigma^2 = 4.0$, $\\theta = 1.0$, $m = 12$, $r = 8$。\n- 测试用例 $4$：$N = 80$, $S = 30$, $\\mu_s = 0.0$, $\\mu_n = 0.0$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 20$, $r = 3$。\n- 测试用例 $5$：$N = 60$, $S = 10$, $\\mu_s = 2.0$, $\\mu_n = -0.5$, $\\sigma^2 = 0.25$, $\\theta = 1.0$, $m = 8$, $r = 0$。\n\n所有变量都是无量纲的，并且不涉及角度。对于每个测试用例，输出必须是代表提取概率的单个实数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4,result_5]$）。顺序必须与上述测试套件的顺序匹配。不应打印任何额外文本。",
            "solution": "该问题要求在一个指针驱动的系统巩固再激活模型中，给出一个提取概率的表达式，并实现一个程序来为几个测试用例计算此概率。该问题具有科学依据，定义明确，并且提供了所有必要的参数和定义。因此，该问题被认为是有效的。\n\n推导过程从第一性原理开始，如下所示。\n\n**1. 单个单元的激活概率**\n\n设 $X_i$ 为皮层单元 $i$ 的输入。该输入是平均信号 $\\mu_i$ 和独立高斯噪声 $\\xi_i \\sim \\mathcal{N}(0, \\sigma^2)$ 的和。如果输入 $X_i$ 超过阈值 $\\theta$，则单元被激活。我们需要为印迹单元和非印迹单元找到此事件的概率。\n\n对于一个**印迹单元**，其输入均值为 $\\mu_s$。输入为 $X_s = \\mu_s + \\xi_i$，其中 $\\xi_i$ 是从 $\\mathcal{N}(0, \\sigma^2)$ 中抽取的样本。如果 $X_s \\ge \\theta$，单元激活。单个印迹单元的激活概率，记作 $p_s$，为：\n$$ p_s = \\Pr(X_s \\ge \\theta) = \\Pr(\\mu_s + \\xi_i \\ge \\theta) = \\Pr(\\xi_i \\ge \\theta - \\mu_s) $$\n为了使用标准正态累积分布函数（CDF），$\\Phi(z) = \\Pr(Z \\le z)$，其中 $Z \\sim \\mathcal{N}(0, 1)$，我们通过将随机变量 $\\xi_i$ 除以其标准差 $\\sigma = \\sqrt{\\sigma^2}$ 来对其进行标准化。\n$$ p_s = \\Pr\\left(\\frac{\\xi_i}{\\sigma} \\ge \\frac{\\theta - \\mu_s}{\\sigma}\\right) $$\n由于 $\\frac{\\xi_i}{\\sigma} \\sim \\mathcal{N}(0, 1)$，我们可以写成：\n$$ p_s = \\Pr\\left(Z \\ge \\frac{\\theta - \\mu_s}{\\sigma}\\right) = 1 - \\Pr\\left(Z  \\frac{\\theta - \\mu_s}{\\sigma}\\right) = 1 - \\Phi\\left(\\frac{\\theta - \\mu_s}{\\sigma}\\right) $$\n\n对于一个**非印迹单元**，其输入均值为 $\\mu_n$。输入为 $X_n = \\mu_n + \\xi_i$。单个非印迹单元的激活概率，记作 $p_n$，可以用类似方法推导：\n$$ p_n = \\Pr(X_n \\ge \\theta) = \\Pr(\\mu_n + \\xi_i \\ge \\theta) = 1 - \\Phi\\left(\\frac{\\theta - \\mu_n}{\\sigma}\\right) $$\n\n**2. 激活单元的数量**\n\n皮层包含 $S$ 个印迹单元和 $N-S$ 个非印迹单元。由于添加到每个单元输入的噪声是独立的，因此每个单元的激活都是一次独立的伯努利试验。\n\n设 $K_s$ 为激活的印迹单元数量的随机变量。由于有 $S$ 个印迹单元，每个单元以概率 $p_s$ 激活，所以 $K_s$ 服从二项分布：\n$$ K_s \\sim \\mathrm{Binomial}(S, p_s) $$\n恰好有 $k_s$ 个印迹单元被激活的概率由二项概率质量函数（PMF）给出：\n$$ \\Pr(K_s = k_s) = \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} $$\n\n类似地，设 $K_n$ 为激活的非印迹单元数量的随机变量。有 $N-S$ 个非印迹单元，每个单元以概率 $p_n$ 激活。因此，$K_n$ 服从二项分布：\n$$ K_n \\sim \\mathrm{Binomial}(N-S, p_n) $$\n恰好有 $k_n$ 个非印迹单元被激活的概率是：\n$$ \\Pr(K_n = k_n) = \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} $$\n\n**3. 提取成功概率**\n\n如果同时满足两个条件，则提取成功：\n1. 激活的印迹单元数量至少为 $m$：$K_s \\ge m$。\n2. 激活的非印迹单元数量最多为 $r$：$K_n \\le r$。\n\n设 $P_s$ 为第一个条件的概率，$P_n$ 为第二个条件的概率。总提取概率 $P_{\\text{retrieval}}$ 是联合事件 $(K_s \\ge m) \\cap (K_n \\le r)$ 的概率。由于印迹和非印迹群体不相交，且单元激活是独立的，因此随机变量 $K_s$ 和 $K_n$ 是独立的。所以，联合概率是个体概率的乘积：\n$$ P_{\\text{retrieval}} = \\Pr(K_s \\ge m \\text{ and } K_n \\le r) = \\Pr(K_s \\ge m) \\times \\Pr(K_n \\le r) = P_s \\times P_n $$\n\n我们可以将 $P_s$ 和 $P_n$ 表示为二项式概率的和：\n$$ P_s = \\Pr(K_s \\ge m) = \\sum_{k_s=m}^{S} \\Pr(K_s = k_s) = \\sum_{k_s=m}^{S} \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} $$\n$$ P_n = \\Pr(K_n \\le r) = \\sum_{k_n=0}^{r} \\Pr(K_n = k_n) = \\sum_{k_n=0}^{r} \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} $$\n这些和分别对应于相应二项分布的生存函数（或互补CDF）和累积分布函数（CDF）。\n\n具体来说，$P_s$ 是 $\\mathrm{Binomial}(S, p_s)$ 在 $m-1$ 处评估的生存函数，即 $1 - F_{K_s}(m-1)$，其中 $F_{K_s}$ 是 $K_s$ 的CDF。而 $P_n$ 是 $\\mathrm{Binomial}(N-S, p_n)$ 在 $r$ 处评估的CDF，即 $F_{K_n}(r)$。\n\n**4. 最终表达式**\n\n提取概率的最终表达式为：\n$$ P_{\\text{retrieval}} = \\left( \\sum_{k_s=m}^{S} \\binom{S}{k_s} p_s^{k_s} (1-p_s)^{S-k_s} \\right) \\times \\left( \\sum_{k_n=0}^{r} \\binom{N-S}{k_n} p_n^{k_n} (1-p_n)^{N-S-k_n} \\right) $$\n其中\n$$ p_s = 1 - \\Phi\\left(\\frac{\\theta - \\mu_s}{\\sqrt{\\sigma^2}}\\right) \\quad \\text{和} \\quad p_n = 1 - \\Phi\\left(\\frac{\\theta - \\mu_n}{\\sqrt{\\sigma^2}}\\right) $$\n\n该公式将使用用于正态CDF和二项分布的统计函数进行数值实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, binom\n\ndef calculate_retrieval_probability(N, S, mu_s, mu_n, sigma_sq, theta, m, r):\n    \"\"\"\n    Calculates the retrieval probability based on the pointer-driven reactivation model.\n\n    Args:\n        N (int): Total number of cortical units.\n        S (int): Number of engram units.\n        mu_s (float): Mean input for engram units.\n        mu_n (float): Mean input for non-engram units.\n        sigma_sq (float): Variance of the Gaussian noise.\n        theta (float): Activation threshold for cortical units.\n        m (int): Minimum number of active engram units for successful retrieval.\n        r (int): Maximum number of active non-engram units for successful retrieval.\n\n    Returns:\n        float: The probability of successful retrieval.\n    \"\"\"\n    # Standard deviation of the noise\n    sigma = np.sqrt(sigma_sq)\n\n    # Calculate the activation probability for a single engram unit (p_s) and\n    # a single non-engram unit (p_n).\n    # If sigma is zero, the activation is deterministic.\n    if sigma == 0:\n        p_s = 1.0 if mu_s >= theta else 0.0\n        p_n = 1.0 if mu_n >= theta else 0.0\n    else:\n        # Standardize the variable to use the standard normal CDF\n        z_s = (theta - mu_s) / sigma\n        p_s = 1.0 - norm.cdf(z_s)\n\n        z_n = (theta - mu_n) / sigma\n        p_n = 1.0 - norm.cdf(z_n)\n\n    # Number of non-engram units\n    num_non_engram = N - S\n    \n    # Calculate the probability of the engram success condition:\n    # at least m engram units become active.\n    # This is P(K_s >= m), where K_s ~ Binomial(S, p_s).\n    # This is equivalent to the survival function (1 - CDF) evaluated at m-1.\n    prob_engram_success = binom.sf(m - 1, S, p_s)\n\n    # Calculate the probability of the non-engram success condition:\n    # at most r non-engram units become active.\n    # This is P(K_n = r), where K_n ~ Binomial(N-S, p_n).\n    # This is the cumulative distribution function (CDF) evaluated at r.\n    prob_non_engram_success = binom.cdf(r, num_non_engram, p_n)\n\n    # The total retrieval probability is the product of the probabilities of\n    # these two independent events.\n    total_probability = prob_engram_success * prob_non_engram_success\n    \n    return total_probability\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the test cases provided in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (N, S, mu_s, mu_n, sigma_sq, theta, m, r)\n    test_cases = [\n        (100, 20, 1.5, 0.0, 0.25, 1.0, 15, 5),\n        (50, 10, 1.0, 0.0, 1.0, 1.0, 5, 2),\n        (100, 20, 1.5, 0.0, 4.0, 1.0, 12, 8),\n        (80, 30, 0.0, 0.0, 0.25, 1.0, 20, 3),\n        (60, 10, 2.0, -0.5, 0.25, 1.0, 8, 0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, S, mu_s, mu_n, sigma_sq, theta, m, r = case\n        result = calculate_retrieval_probability(N, S, mu_s, mu_n, sigma_sq, theta, m, r)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}