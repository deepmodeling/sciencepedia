{
    "hands_on_practices": [
        {
            "introduction": "在将任何理论模型应用于实际数据之前，一个关键的步骤是确定其核心参数。这个练习将引导您完成一个在计算神经科学中至关重要的任务：从模拟的实验数据中拟合标准的基于脉冲对的STDP（Spike-Timing-Dependent Plasticity）模型的参数。通过这个过程，您将学习如何将描述LTP和LTD的指数窗口函数与可测量的突触权重变化联系起来，这是构建更高级模型的基础。",
            "id": "4007206",
            "problem": "您将执行一个基于脉冲时间依赖可塑性（STDP）原理的模型拟合任务。脉冲时间依赖可塑性（STDP）将突触权重变化 $\\Delta w$ 定义为突触后脉冲（发生在时间 $t_{\\text{post}}$）和突触前脉冲（发生在时间 $t_{\\text{pre}}$）之间的相对时间差 $\\Delta t = t_{\\text{post}} - t_{\\text{pre}}$ 的函数。在基于脉冲对的STDP模型中，突触更新在因果机制（$\\Delta t > 0$）和反因果机制（$\\Delta t < 0$）下通过一个指数核进行建模。该指数窗口源于突触前和突触后活动轨迹的相互作用，这些轨迹以特征时间常数衰减；这些轨迹的时间常数和幅度随后用于参数化更高阶的三联体和四联体STDP模型。在本问题中，您将推断指数窗口的参数，并在新的脉冲对上验证预测结果。\n\n假设采用以下经过充分检验的基于脉冲对的STDP模型：当 $\\Delta t > 0$ 时，突触增强为 $\\Delta w(\\Delta t) = A_{+} \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)$；当 $\\Delta t < 0$ 时，突触抑制为 $\\Delta w(\\Delta t) = -A_{-} \\exp\\!\\left(\\frac{\\Delta t}{\\tau_{-}}\\right)$。其中 $A_{+} > 0$ 和 $A_{-} > 0$ 是幅度参数（无量纲），$\\tau_{+} > 0$ 和 $\\tau_{-} > 0$ 是时间常数（单位为秒）。所有时间 $\\Delta t$ 必须以秒为单位表示，所有突触变化 $\\Delta w$ 均为无量纲。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从已知的真实参数集 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$ 出发，为指定的训练时间差 $\\Delta t$ 构建一个测量的 $\\Delta w$ 值训练数据集。构建方法是在每个训练 $\\Delta w$ 值上添加指定的微小附加测量噪声。测量噪声值已提供，并且必须直接相加（它们是无量纲的）。\n2. 根据与指数窗口假设一致的原则，通过对数变换后的幅值进行最小二乘拟合，从带噪声的训练数据中拟合参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$。\n3. 使用拟合的参数，为一个提供的验证集中的新 $\\Delta t$ 值（无噪声）预测 $\\Delta w$。\n4. 计算预测的 $\\Delta w$ 值与根据已知参数集为验证 $\\Delta t$ 值导出的真实（无噪声）$\\Delta w$ 值之间的均方根误差（RMSE）。\n5. 报告每个测试用例的RMSE。\n\n单位和数值说明：\n- 所有 $\\Delta t$ 值均以秒为单位提供，并且必须照此使用。\n- 所有 $\\Delta w$ 值均为无量纲。\n- 本问题不涉及角度。\n- 最终的数值输出必须是浮点数，并四舍五入到六位小数。\n\n测试套件：\n- 用例1（中等采样和微小噪声的一般情况）：\n  - 真实参数：$A_{+} = 0.0100$，$\\tau_{+} = 0.0200$ s， $A_{-} = 0.0120$，$\\tau_{-} = 0.0250$ s。\n  - 训练时间差：\n    - 正分支（$\\Delta t > 0$）：$\\{0.001, 0.005, 0.010, 0.020, 0.030\\}$ s。\n    - 负分支（$\\Delta t < 0$）：$\\{-0.001, -0.005, -0.010, -0.020, -0.030\\}$ s。\n  - 对训练 $\\Delta w$ 的附加测量噪声（按元素应用）：\n    - 正分支：$\\{0.000020, -0.000015, 0.000010, -0.000002, 0.000000\\}$。\n    - 负分支：$\\{-0.000020, 0.000012, -0.000010, 0.000002, 0.000000\\}$。\n  - 验证时间差：\n    - 正分支：$\\{0.004, 0.015, 0.025\\}$ s。\n    - 负分支：$\\{-0.004, -0.015, -0.025\\}$ s。\n- 用例2（最少采样且无噪声的边界情况）：\n  - 真实参数：$A_{+} = 0.0120$，$\\tau_{+} = 0.0100$ s， $A_{-} = 0.0110$，$\\tau_{-} = 0.0350$ s。\n  - 训练时间差：\n    - 正分支：$\\{0.005, 0.030\\}$ s。\n    - 负分支：$\\{-0.005, -0.030\\}$ s。\n  - 附加测量噪声：两个分支均为全零。\n  - 验证时间差：\n    - 正分支：$\\{0.012\\}$ s。\n    - 负分支：$\\{-0.012\\}$ s。\n- 用例3（非对称时间常数和微小噪声的边缘情况）：\n  - 真实参数：$A_{+} = 0.0065$，$\\tau_{+} = 0.0050$ s， $A_{-} = 0.0130$，$\\tau_{-} = 0.0500$ s。\n  - 训练时间差：\n    - 正分支：$\\{0.001, 0.003, 0.007\\}$ s。\n    - 负分支：$\\{-0.010, -0.030, -0.050\\}$ s。\n  - 附加测量噪声：\n    - 正分支：$\\{0.000005, -0.000003, 0.000000\\}$。\n    - 负分支：$\\{0.000020, -0.000010, 0.000000\\}$。\n  - 验证时间差：\n    - 正分支：$\\{0.0025, 0.0060\\}$ s。\n    - 负分支：$\\{-0.020, -0.040\\}$ s。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列，并四舍五入到六位小数：$[\\text{rmse\\_case1},\\text{rmse\\_case2},\\text{rmse\\_case3}]$。",
            "solution": "用户希望解决一个基于脉冲时间依赖可塑性（STDP）模型的模型拟合问题。\n\n### 1. 问题验证\n\n首先根据所需标准对问题进行验证。\n\n*   **提取已知条件**：\n    *   **模型**：突触权重变化 $\\Delta w$ 被给出为时间差 $\\Delta t = t_{\\text{post}} - t_{\\text{pre}}$ 的函数。\n        *   对于增强（$\\Delta t > 0$）：$\\Delta w(\\Delta t) = A_{+} \\exp(-\\Delta t / \\tau_{+})$。\n        *   对于抑制（$\\Delta t < 0$）：$\\Delta w(\\Delta t) = -A_{-} \\exp(\\Delta t / \\tau_{-})$。\n        *   参数为幅度 $A_{+}, A_{-} > 0$ 和时间常数 $\\tau_{+}, \\tau_{-} > 0$。\n    *   **任务**：为三个不同的测试用例定义了一个多步骤过程，包括数据生成、参数拟合、预测和误差计算。\n        1.  根据给定的真实参数生成带噪声的训练数据。\n        2.  使用对数变换后训练数据幅值的最小二乘法拟合四个模型参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$。\n        3.  使用拟合的参数为验证集中的 $\\Delta t$ 值预测 $\\Delta w$。\n        4.  计算这些预测与无噪声真实值之间的均方根误差（RMSE）。\n    *   **数据**：为三个独立的测试用例明确提供了所有真实参数、训练时间差、附加噪声值和验证时间差。\n    *   **输出**：最终结果必须是三个用例的RMSE值列表，四舍五入到六位小数。\n\n*   **验证结论**：\n    *   **科学依据**：该问题基于标准的基于脉冲对的STDP指数模型，这是计算神经科学中一个基本且成熟的概念。模型及其参数与科学文献一致。此标准已满足。\n    *   **良定性**：问题是良定的。任务是实现一个明确定义的数值过程。指定了拟合方法，即对数线性回归，对于给定的数据，该方法可以得出唯一的参数解。所提供的数据集，即使是用例2中的最小数据集，也包含足够的点（至少两个）来拟合线性模型，确保解的存在。\n    *   **客观性**：问题以精确、客观的数学和程序术语陈述。所有数据都是数值的，没有主观因素。此标准已满足。\n    *   **完整性与一致性**：问题是自洽的。提供了所有必需的公式、参数和数据集。噪声值足够小，不会改变训练 $\\Delta w$ 值的符号，这对数变换至关重要。设置是一致且完整的。\n\n*   **结论**：问题是有效的。这是一个基于既定科学原理的、定义明确的计算任务。我将继续进行求解设计。\n\n### 2. 求解设计\n\n问题的核心是通过将指数模型转换为线性模型来拟合其参数。STDP曲线的正分支和负分支是独立的，可以分开拟合。\n\n*   **正分支 ($\\Delta t > 0$)**：\n    *   模型为 $\\Delta w = A_{+} \\exp(-\\Delta t / \\tau_{+})$。\n    *   对两边取自然对数，得到：$\\ln(\\Delta w) = \\ln(A_{+}) - (1/\\tau_{+}) \\Delta t$。\n    *   这是一个形如 $y = c + m x$ 的线性方程，其中 $y = \\ln(\\Delta w)$，$x = \\Delta t$，截距为 $c = \\ln(A_{+})$，斜率为 $m = -1/\\tau_{+}$。\n    *   我们可以对训练数据对 $(\\Delta t_{\\text{train}}, \\ln(\\Delta w_{\\text{train}}))$ 进行线性回归，以找到最佳拟合斜率 $\\hat{m}_{+}$ 和截距 $\\hat{c}_{+}$。\n    *   然后，拟合的参数可恢复为：$\\hat{A}_{+} = \\exp(\\hat{c}_{+})$ 和 $\\hat{\\tau}_{+} = -1/\\hat{m}_{+}$。\n\n*   **负分支 ($\\Delta t < 0$)**：\n    *   模型为 $\\Delta w = -A_{-} \\exp(\\Delta t / \\tau_{-})$。我们处理其幅值 $|\\Delta w| = A_{-} \\exp(\\Delta t / \\tau_{-})$。\n    *   取自然对数得到：$\\ln(|\\Delta w|) = \\ln(A_{-}) + (1/\\tau_{-}) \\Delta t$。\n    *   这同样是一个线性方程 $y = c + m x$，其中 $y = \\ln(|\\Delta w|)$，$x = \\Delta t$，截距为 $c = \\ln(A_{-})$，斜率为 $m = 1/\\tau_{-}$。\n    *   我们对训练数据对 $(\\Delta t_{\\text{train}}, \\ln(|\\Delta w_{\\text{train}}|))$ 进行线性回归，以找到最佳拟合斜率 $\\hat{m}_{-}$ 和截距 $\\hat{c}_{-}$。\n    *   然后，拟合的参数可恢复为：$\\hat{A}_{-} = \\exp(\\hat{c}_{-})$ 和 $\\hat{\\tau}_{-} = 1/\\hat{m}_{-}$。\n\n*   **每个测试用例的算法**：\n    1.  **数据生成**：\n        *   对于正的训练 $\\Delta t$ 值，使用给定的 $A_{+}$ 和 $\\tau_{+}$ 计算真实的 $\\Delta w$。加上指定的噪声以获得训练 $\\Delta w$ 值。\n        *   同样，对于负的训练 $\\Delta t$ 值，使用 $A_{-}$ 和 $\\tau_{-}$ 计算真实的 $\\Delta w$ 并加上相应的噪声。\n    2.  **参数拟合**：\n        *   使用正的训练数据 $(\\Delta t, \\Delta w)$，计算 $(\\Delta t, \\ln(\\Delta w))$ 并执行线性回归（例如，使用`numpy.polyfit`，阶数为1）以获得 $\\hat{m}_{+}$ 和 $\\hat{c}_{+}$。计算 $\\hat{A}_{+}$ 和 $\\hat{\\tau}_{+}$。\n        *   使用负的训练数据 $(\\Delta t, \\Delta w)$，计算 $(\\Delta t, \\ln(|\\Delta w|))$ 并执行线性回归以获得 $\\hat{m}_{-}$ 和 $\\hat{c}_{-}$。计算 $\\hat{A}_{-}$ 和 $\\hat{\\tau}_{-}$。\n    3.  **预测**：\n        *   使用带有参数 $(\\hat{A}_{+}, \\hat{\\tau}_{+}, \\hat{A}_{-}, \\hat{\\tau}_{-})$ 的完整拟合模型，为验证集中的所有 $\\Delta t$ 值计算预测的 $\\Delta w_{\\text{pred}}$。\n    4.  **误差计算**：\n        *   使用带有参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$ 的真实模型，为验证集中的所有 $\\Delta t$ 值计算真实的 $\\Delta w_{\\text{gt}}$。\n        *   计算RMSE：$\\text{RMSE} = \\sqrt{\\text{mean}[(\\Delta w_{\\text{pred}} - \\Delta w_{\\text{gt}})^2]}$。\n    5.  **输出**：存储计算出的RMSE值，四舍五入到六位小数。\n\n此过程将为提供的三个测试用例分别实现。无噪声的用例2作为一个对照组，其中拟合参数应与真实参数完全匹配，从而得到 $0$ 的RMSE。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the STDP model-fitting problem for three test cases.\n    For each case, it:\n    1. Generates noisy training data from ground-truth parameters.\n    2. Fits the STDP model parameters via log-linear regression.\n    3. Predicts weight changes for a validation set using the fitted model.\n    4. Computes the RMSE between predictions and ground-truth values.\n    \"\"\"\n    test_cases = [\n        {\n            \"gt_params\": {\"A_p\": 0.0100, \"tau_p\": 0.0200, \"A_n\": 0.0120, \"tau_n\": 0.0250},\n            \"train_dt_p\": [0.001, 0.005, 0.010, 0.020, 0.030],\n            \"train_dt_n\": [-0.001, -0.005, -0.010, -0.020, -0.030],\n            \"noise_p\": [0.000020, -0.000015, 0.000010, -0.000002, 0.000000],\n            \"noise_n\": [-0.000020, 0.000012, -0.000010, 0.000002, 0.000000],\n            \"val_dt\": [0.004, 0.015, 0.025, -0.004, -0.015, -0.025],\n        },\n        {\n            \"gt_params\": {\"A_p\": 0.0120, \"tau_p\": 0.0100, \"A_n\": 0.0110, \"tau_n\": 0.0350},\n            \"train_dt_p\": [0.005, 0.030],\n            \"train_dt_n\": [-0.005, -0.030],\n            \"noise_p\": [0.0, 0.0],\n            \"noise_n\": [0.0, 0.0],\n            \"val_dt\": [0.012, -0.012],\n        },\n        {\n            \"gt_params\": {\"A_p\": 0.0065, \"tau_p\": 0.0050, \"A_n\": 0.0130, \"tau_n\": 0.0500},\n            \"train_dt_p\": [0.001, 0.003, 0.007],\n            \"train_dt_n\": [-0.010, -0.030, -0.050],\n            \"noise_p\": [0.000005, -0.000003, 0.000000],\n            \"noise_n\": [0.000020, -0.000010, 0.000000],\n            \"val_dt\": [0.0025, 0.0060, -0.20, -0.040],\n        },\n    ]\n\n    results = []\n\n    def stdp_model(dt, A_p, tau_p, A_n, tau_n):\n        \"\"\"Calculates delta_w based on the STDP model.\"\"\"\n        if dt > 0:\n            return A_p * np.exp(-dt / tau_p)\n        elif dt  0:\n            return -A_n * np.exp(dt / tau_n)\n        else:\n            return 0.0\n\n    for case in test_cases:\n        gt_params = case[\"gt_params\"]\n        \n        # 1. Construct training dataset\n        train_dt_p = np.array(case[\"train_dt_p\"])\n        train_dt_n = np.array(case[\"train_dt_n\"])\n        noise_p = np.array(case[\"noise_p\"])\n        noise_n = np.array(case[\"noise_n\"])\n\n        # Positive branch training data\n        dw_gt_p = gt_params[\"A_p\"] * np.exp(-train_dt_p / gt_params[\"tau_p\"])\n        dw_train_p = dw_gt_p + noise_p\n\n        # Negative branch training data\n        dw_gt_n = -gt_params[\"A_n\"] * np.exp(train_dt_n / gt_params[\"tau_n\"])\n        dw_train_n = dw_gt_n + noise_n\n\n        # 2. Fit parameters from noisy training data\n        \n        # Fit positive branch\n        # y = ln(dw) = ln(A_p) - (1/tau_p)*dt. This is a line y = c + m*x\n        # m = -1/tau_p, c = ln(A_p)\n        log_dw_train_p = np.log(dw_train_p)\n        m_p, c_p = np.polyfit(train_dt_p, log_dw_train_p, 1)\n        \n        tau_p_fit = -1 / m_p\n        A_p_fit = np.exp(c_p)\n\n        # Fit negative branch\n        # y = ln(|dw|) = ln(A_n) + (1/tau_n)*dt. This is a line y = c + m*x\n        # m = 1/tau_n, c = ln(A_n)\n        log_abs_dw_train_n = np.log(np.abs(dw_train_n))\n        m_n, c_n = np.polyfit(train_dt_n, log_abs_dw_train_n, 1)\n\n        tau_n_fit = 1 / m_n\n        A_n_fit = np.exp(c_n)\n        \n        fitted_params = {\n            \"A_p\": A_p_fit, \"tau_p\": tau_p_fit, \n            \"A_n\": A_n_fit, \"tau_n\": tau_n_fit\n        }\n\n        # 3. Predict dw for validation set\n        val_dt = np.array(case[\"val_dt\"])\n        dw_pred = np.array([stdp_model(dt, **fitted_params) for dt in val_dt])\n\n        # 4. Compute RMSE against ground-truth values\n        dw_gt_val = np.array([stdp_model(dt, **gt_params) for dt in val_dt])\n        \n        rmse = np.sqrt(np.mean((dw_pred - dw_gt_val)**2))\n        \n        results.append(f\"{rmse:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "从简单的脉冲对模型扩展到更复杂的脉冲三联体和四联体模型，会引入新的实现细节。在离散时间的计算机模拟中，一个特别微妙的问题是如何处理同时发生的突触前和突触后脉冲。这个练习将探讨在这种临界情况下，事件更新的顺序如何显著影响突触可塑性的最终结果，从而加深您对模型力学及其计算实现的理解。",
            "id": "4007284",
            "problem": "一个基于脉冲对、三联体和四联体的脉冲时间依赖可塑性 (STDP) 模型是使用事件触发更新和指数衰减迹来实现的。脉冲时间依赖可塑性 (STDP) 在突触前和突触后脉冲发放时，根据从衰减迹获得的局部因果测量来指定突触权重变化 $\\Delta w$：一个突触前迹 $x(t)$ 和一个突触后迹 $y(t)$，以及捕获爆发样或高阶时间背景的较慢迹 $x_s(t)$ 和 $y_s(t)$。长时程增强 (LTP) 在突触后脉冲发放时应用，而长时程抑制 (LTD) 在突触前脉冲发放时应用。使用以下基于事件的规则：\n\n- 在时间 $t$ 发生突触后脉冲时，根据当前迹计算 LTP，然后增加突触后迹：\n  $$\\Delta w_{\\text{post}}(t) = +A_{+}\\,x(t) + A_{3+}\\,x(t)\\,y_s(t) + A_{4+}\\,x(t)\\,y(t)\\,y_s(t),$$\n  然后\n  $$y(t) \\leftarrow y(t) + 1,\\quad y_s(t) \\leftarrow y_s(t) + 1.$$\n\n- 在时间 $t$ 发生突触前脉冲时，根据当前迹计算 LTD，然后增加突触前迹：\n  $$\\Delta w_{\\text{pre}}(t) = -A_{-}\\,y(t) - A_{3-}\\,y(t)\\,x_s(t) - A_{4-}\\,y(t)\\,x(t)\\,x_s(t),$$\n  然后\n  $$x(t) \\leftarrow x(t) + 1,\\quad x_s(t) \\leftarrow x_s(t) + 1.$$\n\n在脉冲之间，迹会指数衰减，但对于本问题，在感兴趣的时间窗口内不发生脉冲间的衰减。考虑一个几乎同时发生的突触前脉冲和突触后脉冲，它们在完全相同的时间戳 $t_0$ 到达。当两个事件占据同一个离散时间仓时，有两种可能的更新顺序策略：\n\n- 策略 $\\mathcal{P}_{\\text{pre}\\rightarrow\\text{post}}$：在时间 $t_0$ 先处理突触前脉冲，然后在时间 $t_0$ 处理突触后脉冲。\n- 策略 $\\mathcal{P}_{\\text{post}\\rightarrow\\text{pre}}$：在时间 $t_0$ 先处理突触后脉冲，然后在时间 $t_0$ 处理突触前脉冲。\n\n在 $t_0$ 之前，迹和参数具有以下值：\n$$x(t_0^{-}) = 0.30,\\quad y(t_0^{-}) = 0.25,\\quad x_s(t_0^{-}) = 0.50,\\quad y_s(t_0^{-}) = 0.20,$$\n$$A_{+} = 0.010,\\quad A_{-} = 0.012,\\quad A_{3+} = 0.006,\\quad A_{3-} = 0.004,\\quad A_{4+} = 0.003,\\quad A_{4-} = 0.002.$$\n\n假设惯例为：在每个脉冲事件中，权重更新使用该事件发生瞬间存在的迹值，并且只有在计算完事件的 $\\Delta w$ 之后，相应的迹增量才会发生。计算在每种策略下 $t_0$ 时的净权重变化 $\\Delta w_{\\text{net}}$，并从下面关于每种策略下 $\\Delta w_{\\text{net}}$ 的符号和近似大小的陈述中，确定正确的陈述。\n\nA. 在策略 $\\mathcal{P}_{\\text{pre}\\rightarrow\\text{post}}$下，$\\Delta w_{\\text{net}} \\approx +0.01118$ (增强)；在策略 $\\mathcal{P}_{\\text{post}\\rightarrow\\text{pre}}$下，$\\Delta w_{\\text{net}} \\approx -0.01447$ (抑制)。\n\nB. 两种策略产生相同的 $\\Delta w_{\\text{net}} \\approx 0$，因为同时发生的脉冲消除了因果关系，且高阶项会抵消。\n\nC. 在策略 $\\mathcal{P}_{\\text{pre}\\rightarrow\\text{post}}$下，$\\Delta w_{\\text{net}} \\approx -0.01788$ (抑制)；在策略 $\\mathcal{P}_{\\text{post}\\rightarrow\\text{pre}}$下，$\\Delta w_{\\text{net}} \\approx +0.00341$ (增强)。\n\nD. 策略选择仅轻微影响四联体项，因此差异可忽略不计，两种策略间的 $\\Delta w_{\\text{net}}$ 相差约 $0.00005$；基于脉冲对的贡献在两种策略下是相同的。",
            "solution": "该解答的中文翻译暂不可用。我们正在努力解决这个问题。请稍后再试。",
            "answer": "该解答的中文翻译暂不可用。我们正在努力解决这个问题。请稍后再试。"
        },
        {
            "introduction": "计算模型的验证是确保其科学严谨性的基石。数值模拟，例如使用欧拉法的模拟，本质上是真实动态的近似，因此会引入误差。本练习要求您同时构建一个基于精确解析解的计算器和一个基于时间步进的数值模拟器，以直接量化和理解数值误差的来源和大小。通过将模拟结果与“基准真相”进行比较，您将掌握验证计算模型保真度的关键技能。",
            "id": "4007267",
            "problem": "一个计算神经科学的验证任务是，在多种参数体系下，比较基于核的脉冲时间依赖可塑性 (STDP) 公式的解析预测与受控脉冲序列的时间步进模拟结果，并量化两者之间的差异。脉冲时间依赖可塑性 (STDP) 通过使用表示为狄拉克δ函数之和的突触前和突触后脉冲序列进行建模。设突触前脉冲序列为 $s_{\\mathrm{pre}}(t) = \\sum_{i} \\delta(t - t^{\\mathrm{pre}}_{i})$，突触后脉冲序列为 $s_{\\mathrm{post}}(t) = \\sum_{j} \\delta(t - t^{\\mathrm{post}}_{j})$。设突触前轨迹 $x(t)$ 和突触后轨迹 $y(t)$ 服从线性常微分方程 $dx/dt = -x/\\tau_{x} + s_{\\mathrm{pre}}(t)$ 和 $dy/dt = -y/\\tau_{y} + s_{\\mathrm{post}}(t)$，其中 $x(t)$ 和 $y(t)$ 在各自脉冲发生时增加1，并以时间常数 $\\tau_{x}  0$ 和 $\\tau_{y}  0$ 指数衰减。\n\n突触权重变化 $\\Delta w$ 通过三种相互作用阶在脉冲事件时累积：\n- 基于脉冲对的相互作用：在每个 $t^{\\mathrm{post}}_{j}$ 时刻的突触后脉冲处，增加一个增量 $A_{+} \\, x(t^{\\mathrm{post}}_{j})$；在每个 $t^{\\mathrm{pre}}_{i}$ 时刻的突触前脉冲处，增加一个带负号的减量 $A_{-} \\, y(t^{\\mathrm{pre}}_{i})$（即 $-A_{-} \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{+} \\ge 0$ 和 $A_{-} \\ge 0$ 是幅度。\n- 三联体相互作用：在每个 $t^{\\mathrm{post}}_{j}$ 时刻的突触后脉冲处，增加一个增量 $A_{3+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})$；在每个 $t^{\\mathrm{pre}}_{i}$ 时刻的突触前脉冲处，增加一个带负号的减量 $A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i})$（即 $-A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{3+} \\ge 0$ 和 $A_{3-} \\ge 0$ 是幅度。\n- 四联体相互作用：在每个 $t^{\\mathrm{post}}_{j}$ 时刻的突触后脉冲处，增加一个增量 $A_{4+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})^{2}$；在每个 $t^{\\mathrm{pre}}_{i}$ 时刻的突触前脉冲处，增加一个带负号的减量 $A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$（即 $-A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{4+} \\ge 0$ 和 $A_{4-} \\ge 0$ 是幅度。\n\n脉冲时刻轨迹的解析预测来自于带δ输入的线性常微分方程的指数衰减解。具体来说，对于任何时间 $t$，轨迹满足 $x(t) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t} \\exp\\!\\big(-(t - t^{\\mathrm{pre}}_{i})/\\tau_{x}\\big)$ 和 $y(t) = \\sum_{j: t^{\\mathrm{post}}_{j}  t} \\exp\\!\\big(-(t - t^{\\mathrm{post}}_{j})/\\tau_{y}\\big)$，这确保了在时间 $t$ 更新之前，只有严格早于该时刻的脉冲做出贡献。使用这些表达式，通过对所有脉冲时刻指定的基于脉冲对、三联体和四联体的增量求和，可以得到解析权重变化。\n\n需要使用固定的基本步长 $\\Delta t  0$ 实现一个时间步进数值模拟。在时间网格点之间，使用显式欧拉步更新轨迹的衰减动力学；在精确的脉冲时刻，使用在该时刻脉冲引起的任何增量之前一刻的当前轨迹值来更新权重 $\\Delta w$，之后轨迹再根据该瞬间发生的脉冲数量进行增加。允许对基本步长进行划分，以使网格精确地包含所有脉冲时刻，同时在连续的网格点之间保持显式欧拉更新。\n\n你的程序必须为每个测试用例计算：\n- 使用脉冲时刻的闭式轨迹值计算的解析权重变化 $\\Delta w_{\\mathrm{analytic}}$。\n- 使用带有所述事件处理的显式欧拉法计算的模拟权重变化 $\\Delta w_{\\mathrm{sim}}$。\n- 定义为绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$ 的差异值。\n\n所有脉冲时间必须以秒为单位，所有时间常数也以秒为单位。突触权重变化是无量纲的。最终输出必须是浮点数。\n\n使用以下包含受控脉冲序列和参数的测试套件：\n- 测试用例1（正常路径）：突触前脉冲时刻为 $[0.0, 0.03, 0.06]$ 秒；突触后脉冲时刻为 $[0.01, 0.04, 0.07]$ 秒；时间常数 $\\tau_{x} = 0.02$ 秒和 $\\tau_{y} = 0.02$ 秒；幅度 $A_{+} = 0.005$, $A_{-} = 0.006$, $A_{3+} = 0.002$, $A_{3-} = 0.001$, $A_{4+} = 0.0005$, $A_{4-} = 0.0004$；基本步长 $\\Delta t = 0.0005$ 秒。\n- 测试用例2（同步事件和对称性）：突触前脉冲时刻为 $[0.0, 0.05]$ 秒；突触后脉冲时刻为 $[0.0, 0.05]$ 秒；时间常数 $\\tau_{x} = 0.02$ 秒和 $\\tau_{y} = 0.02$ 秒；幅度 $A_{+} = 0.010$, $A_{-} = 0.010$, $A_{3+} = 0.002$, $A_{3-} = 0.002$, $A_{4+} = 0.0001$, $A_{4-} = 0.0001$；基本步长 $\\Delta t = 0.001$ 秒。\n- 测试用例3（快速动力学，密集脉冲）：突触前脉冲时刻为 $[0.0, 0.004, 0.008, 0.012]$ 秒；突触后脉冲时刻为 $[0.002, 0.006, 0.010]$ 秒；时间常数 $\\tau_{x} = 0.003$ 秒和 $\\tau_{y} = 0.003$ 秒；幅度 $A_{+} = 0.004$, $A_{-} = 0.004$, $A_{3+} = 0.0015$, $A_{3-} = 0.0010$, $A_{4+} = 0.0003$, $A_{4-} = 0.00025$；基本步长 $\\Delta t = 0.001$ 秒。\n- 测试用例4（慢速动力学，稀疏脉冲）：突触前脉冲时刻为 $[0.0, 0.1, 0.2]$ 秒；突触后脉冲时刻为 $[0.05, 0.15, 0.25]$ 秒；时间常数 $\\tau_{x} = 0.05$ 秒和 $\\tau_{y} = 0.05$ 秒；幅度 $A_{+} = 0.006$, $A_{-} = 0.005$, $A_{3+} = 0.0025$, $A_{3-} = 0.0015$, $A_{4+} = 0.0006$, $A_{4-} = 0.0005$；基本步长 $\\Delta t = 0.002$ 秒。\n\n你的程序应生成单行输出，其中包含四个测试用例的差异结果，格式为方括号括起来的逗号分隔列表（例如，$[d_{1},d_{2},d_{3},d_{4}]$），其中每个 $d_{k}$ 是测试用例 $k$ 的绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$，表示为无单位的浮点数。",
            "solution": "用户提供了一个计算神经科学问题，要求将一个脉冲时间依赖可塑性 (STDP) 模型的数值模拟与其解析解进行验证。该模型包含基于脉冲对、三联体和四联体的相互作用。任务是使用解析公式和时间步进数值模拟两种方法计算总突触权重变化 $\\Delta w$，然后找出几个测试用例下两种结果之间的绝对差。\n\n### 问题验证\n\n首先，必须严格验证问题陈述。\n\n**第1步：提取的已知条件**\n- 突触前脉冲序列：$s_{\\mathrm{pre}}(t) = \\sum_{i} \\delta(t - t^{\\mathrm{pre}}_{i})$。\n- 突触后脉冲序列：$s_{\\mathrm{post}}(t) = \\sum_{j} \\delta(t - t^{\\mathrm{post}}_{j})$。\n- 突触前轨迹动力学：$dx/dt = -x/\\tau_{x} + s_{\\mathrm{pre}}(t)$，其中 $\\tau_{x}  0$。\n- 突触后轨迹动力学：$dy/dt = -y/\\tau_{y} + s_{\\mathrm{post}}(t)$，其中 $\\tau_{y}  0$。\n- 轨迹更新规则：轨迹在脉冲时刻增加1。\n- 权重变化规则 ($\\Delta w$)：\n  - 在突触后脉冲 $t^{\\mathrm{post}}_{j}$ 时：$\\Delta w$ 增加 $A_{+} \\, x(t^{\\mathrm{post}}_{j}) + A_{3+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j}) + A_{4+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})^{2}$，其中 $A_{+}, A_{3+}, A_{4+} \\ge 0$。\n  - 在突触前脉冲 $t^{\\mathrm{pre}}_{i}$ 时：$\\Delta w$ 减少 $A_{-} \\, y(t^{\\mathrm{pre}}_{i}) + A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i}) + A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$，其中 $A_{-}, A_{3-}, A_{4-} \\ge 0$。\n- 解析轨迹解：$x(t) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t} \\exp\\!\\big(-(t - t^{\\mathrm{pre}}_{i})/\\tau_{x}\\big)$ 和 $y(t) = \\sum_{j: t^{\\mathrm{post}}_{j}  t} \\exp\\!\\big(-(t - t^{\\mathrm{post}}_{j})/\\tau_{y}\\big)$。\n- 数值模拟方法：使用固定基本步长 $\\Delta t$ 的显式欧拉法，时间网格保证包含所有脉冲时刻。$\\Delta w$ 的更新使用脉冲引起的增量之前的轨迹值，之后轨迹再增加。\n- 目标：计算 $\\Delta w_{\\mathrm{analytic}}$、$\\Delta w_{\\mathrm{sim}}$ 以及差异 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$。\n- 测试用例为脉冲时间、时间常数、幅度和 $\\Delta t$ 提供了具体值。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了计算神经科学中一个公认的STDP模型族。轨迹的微分方程是漏积分器的标准模型，而脉冲对、三联体和四联体相互作用项在相关科学文献中可以找到（例如，Pfister  Gerstner, 2006）。该问题在科学上是合理的。\n- **良定性和完整性**：所有必需的参数、初始条件 ($x(0)=0, y(0)=0$)、方程和更新规则都已明确提供。解析计算和数值计算之间的区别很清楚，模拟的操作顺序（先更新权重，再更新轨迹）也很明确。该问题是自洽且良定的。\n- **客观性和一致性**：术语精确客观，没有矛盾。例如，解析解中“只有严格早于的脉冲做出贡献”的指令是一个无歧义的定义，而模拟规则中“使用在任何增量之前的轨迹值”同样清晰。\n\n**第3步：结论和行动**\n该问题在科学上有效、良定且内部一致。没有缺陷。因此，我将着手制定和实施解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案需要实施两种不同的方法来计算总突触权重变化 $\\Delta w$。\n\n**1. 解析计算 ($\\Delta w_{\\mathrm{analytic}}$)**\n\n解析计算依赖于突触轨迹 $x(t)$ 和 $y(t)$ 的闭式解。总权重变化是每个脉冲时刻发生的所有单个变化的总和。\n\n算法如下：\n1. 识别所有唯一脉冲时间的集合 $\\{t_k\\} = \\{t^{\\mathrm{pre}}_{i}\\} \\cup \\{t^{\\mathrm{post}}_{j}\\}$，并按时间顺序排序。\n2. 初始化总权重变化 $\\Delta w_{\\mathrm{analytic}} = 0$。\n3. 遍历排序后列表中的每个唯一脉冲时间 $t_k$。\n4. 在每个 $t_k$ 时刻，使用提供的解析公式计算突触前轨迹 $x(t_k)$ 和突触后轨迹 $y(t_k)$ 的值。这些公式对所有*严格早于* $t_k$ 发生的脉冲的贡献进行求和：\n    $$x(t_k) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t_k} \\exp\\!\\left(-\\frac{t_k - t^{\\mathrm{pre}}_{i}}{\\tau_{x}}\\right)$$\n    $$y(t_k) = \\sum_{j: t^{\\mathrm{post}}_{j}  t_k} \\exp\\!\\left(-\\frac{t_k - t^{\\mathrm{post}}_{j}}{\\tau_{y}}\\right)$$\n5. 如果 $t_k$ 是一个突触后脉冲时刻，计算增强增量并将其加到 $\\Delta w_{\\mathrm{analytic}}$ 上。如果在 $t_k$ 时刻发生多个脉冲，则对每个脉冲都应用此操作：\n    $$\\Delta w_{\\mathrm{pot}}(t_k) = A_{+} x(t_k) + A_{3+} x(t_k) y(t_k) + A_{4+} x(t_k) y(t_k)^2$$\n6. 如果 $t_k$ 是一个突触前脉冲时刻，计算抑制减量并将其加到 $\\Delta w_{\\mathrm{analytic}}$ 上。注意总体的负号：\n    $$\\Delta w_{\\mathrm{dep}}(t_k) = - \\left( A_{-} y(t_k) + A_{3-} x(t_k) y(t_k) + A_{4-} x(t_k)^2 y(t_k) \\right)$$\n7. 最终的 $\\Delta w_{\\mathrm{analytic}}$ 是所有脉冲时刻上所有此类增量和减量的总和。\n\n**2. 数值模拟 ($\\Delta w_{\\mathrm{sim}}$)**\n\n数值模拟使用离散时间步进方法和显式欧拉法来近似轨迹动力学。问题指定了一个将动力学分为离散事件（脉冲）和连续演化（衰减）的程序。\n\n算法如下：\n1. 根据给定的脉冲序列确定最大模拟时间 $t_{\\mathrm{max}}$。\n2. 将时间离散化为大小为 $\\Delta t$ 的步长，从 $t=0$ 到 $t_{\\mathrm{max}}$。测试用例的设计使得所有脉冲时间都是 $\\Delta t$ 的整数倍，从而简化了网格。我们创建一个从模拟步骤索引 $i$ 到在时间 $t_i = i \\cdot \\Delta t$ 发生的突触前和突触后脉冲数量的映射。\n3. 初始化轨迹 $x=0$, $y=0$ 和总权重变化 $\\Delta w_{\\mathrm{sim}} = 0$。\n4. 从步骤 $i=0$ 迭代到 $i=t_{\\mathrm{max}}/\\Delta t$。在每个步骤中，设当前时间为 $t_i = i \\cdot \\Delta t$。变量 $x$ 和 $y$ 保存着时间步开始时的轨迹值，即在处理 $t_i$ 时的任何事件之前。\n    a. **权重更新：** 检查在时间 $t_i$ 是否有突触前和突触后脉冲。使用当前的轨迹值 $x$ 和 $y$ 计算权重变化。\n        - 对于每个突触后脉冲：$\\Delta w_{\\mathrm{sim}} \\mathrel{+}= A_{+} x + A_{3+} x y + A_{4+} x y^2$。\n        - 对于每个突触前脉冲：$\\Delta w_{\\mathrm{sim}} \\mathrel{-}= A_{-} y + A_{3-} x y + A_{4-} x^2 y$。\n    b. **轨迹增量：** 在权重更新后，轨迹根据 $t_i$ 时的脉冲数量瞬时增加。设 $n_{\\mathrm{pre}}$ 和 $n_{\\mathrm{post}}$ 为脉冲计数。\n        $$x \\leftarrow x + n_{\\mathrm{pre}}$$\n        $$y \\leftarrow y + n_{\\mathrm{post}}$$\n    c. **轨迹演化：** 使用显式欧拉法对衰减动力学 $dx/dt=-x/\\tau_x$ 和 $dy/dt=-y/\\tau_y$ 在时间间隔 $\\Delta t$ 内演化新的轨迹值。更新后的值成为下一个时间步 $t_{i+1}$ 开始时的轨迹状态。\n        $$x \\leftarrow x \\cdot \\left(1 - \\frac{\\Delta t}{\\tau_x}\\right)$$\n        $$y \\leftarrow y \\cdot \\left(1 - \\frac{\\Delta t}{\\tau_y}\\right)$$\n5. 循环完成后，$\\Delta w_{\\mathrm{sim}}$ 即为总的模拟权重变化。\n\n**3. 差异计算**\n\n最终要求的值是解析结果和模拟结果之间的绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$。这个差异量化了由显式欧拉近似引入的数值误差，该近似用其一阶泰勒展开 $1 - \\Delta t/\\tau$ 来近似真实的指数衰减 $e^{-\\Delta t/\\tau}$。\n\n以下 Python 代码为每个测试用例实现了这三个组件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the STDP model validation.\n    \"\"\"\n    test_cases = [\n        {\n            \"t_pre\": [0.0, 0.03, 0.06], \"t_post\": [0.01, 0.04, 0.07],\n            \"tau_x\": 0.02, \"tau_y\": 0.02,\n            \"A_p\": 0.005, \"A_m\": 0.006, \"A_3p\": 0.002, \"A_3m\": 0.001,\n            \"A_4p\": 0.0005, \"A_4m\": 0.0004, \"dt\": 0.0005\n        },\n        {\n            \"t_pre\": [0.0, 0.05], \"t_post\": [0.0, 0.05],\n            \"tau_x\": 0.02, \"tau_y\": 0.02,\n            \"A_p\": 0.010, \"A_m\": 0.010, \"A_3p\": 0.002, \"A_3m\": 0.002,\n            \"A_4p\": 0.0001, \"A_4m\": 0.0001, \"dt\": 0.001\n        },\n        {\n            \"t_pre\": [0.0, 0.004, 0.008, 0.012], \"t_post\": [0.002, 0.006, 0.010],\n            \"tau_x\": 0.003, \"tau_y\": 0.003,\n            \"A_p\": 0.004, \"A_m\": 0.004, \"A_3p\": 0.0015, \"A_3m\": 0.0010,\n            \"A_4p\": 0.0003, \"A_4m\": 0.00025, \"dt\": 0.001\n        },\n        {\n            \"t_pre\": [0.0, 0.1, 0.2], \"t_post\": [0.05, 0.15, 0.25],\n            \"tau_x\": 0.05, \"tau_y\": 0.05,\n            \"A_p\": 0.006, \"A_m\": 0.005, \"A_3p\": 0.0025, \"A_3m\": 0.0015,\n            \"A_4p\": 0.0006, \"A_4m\": 0.0005, \"dt\": 0.002\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        dw_analytic = calculate_analytic_dw(**params)\n        dw_sim = calculate_simulated_dw(**params)\n        discrepancy = abs(dw_analytic - dw_sim)\n        results.append(discrepancy)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_analytic_dw(t_pre, t_post, tau_x, tau_y, A_p, A_m, A_3p, A_3m, A_4p, A_4m, dt):\n    \"\"\"\n    Calculates the total weight change using the analytical formulas.\n    \"\"\"\n    t_pre_np = np.array(t_pre)\n    t_post_np = np.array(t_post)\n    \n    all_spike_times = sorted(list(set(t_pre) | set(t_post)))\n    \n    delta_w = 0.0\n\n    post_spike_counts = Counter(t_post)\n    pre_spike_counts = Counter(t_pre)\n\n    for t_event in all_spike_times:\n        # Calculate traces using spikes that occurred strictly before t_event\n        pre_spikes_before = t_pre_np[t_pre_np  t_event]\n        post_spikes_before = t_post_np[t_post_np  t_event]\n\n        x_t = np.sum(np.exp(-(t_event - pre_spikes_before) / tau_x)) if pre_spikes_before.size > 0 else 0.0\n        y_t = np.sum(np.exp(-(t_event - post_spikes_before) / tau_y)) if post_spikes_before.size > 0 else 0.0\n\n        # Process post-synaptic events at t_event\n        if t_event in post_spike_counts:\n            num_spikes = post_spike_counts[t_event]\n            dw_potentiation = A_p * x_t + A_3p * x_t * y_t + A_4p * x_t * y_t**2\n            delta_w += num_spikes * dw_potentiation\n\n        # Process pre-synaptic events at t_event\n        if t_event in pre_spike_counts:\n            num_spikes = pre_spike_counts[t_event]\n            dw_depression = A_m * y_t + A_3m * x_t * y_t + A_4m * x_t**2 * y_t\n            delta_w -= num_spikes * dw_depression\n            \n    return delta_w\n\ndef calculate_simulated_dw(t_pre, t_post, tau_x, tau_y, A_p, A_m, A_3p, A_3m, A_4p, A_4m, dt):\n    \"\"\"\n    Calculates the total weight change using time-stepped simulation.\n    \"\"\"\n    all_times = list(set(t_pre) | set(t_post))\n    if not all_times:\n        return 0.0\n    \n    t_max = max(all_times)\n\n    # Use rounding to map spike times to integer grid indices robustly\n    pre_spike_indices = {int(round(t / dt)): count for t, count in Counter(t_pre).items()}\n    post_spike_indices = {int(round(t / dt)): count for t, count in Counter(t_post).items()}\n    \n    num_steps = int(round(t_max / dt)) + 1\n    \n    x, y, delta_w = 0.0, 0.0, 0.0\n\n    for i in range(num_steps):\n        # x and y represent the trace values at the beginning of the step t=i*dt,\n        # evolved from the previous step.\n\n        # Check for spikes at current time step i and update weight\n        n_post = post_spike_indices.get(i, 0)\n        n_pre = pre_spike_indices.get(i, 0)\n\n        if n_post > 0:\n            dw_potentiation = A_p * x + A_3p * x * y + A_4p * x * y**2\n            delta_w += n_post * dw_potentiation\n        if n_pre > 0:\n            dw_depression = A_m * y + A_3m * x * y + A_4m * x**2 * y\n            delta_w -= n_pre * dw_depression\n\n        # Instantaneously increment traces due to spikes\n        x += n_pre\n        y += n_post\n\n        # Evolve traces over dt using explicit Euler method for the next step\n        x *= (1.0 - dt / tau_x)\n        y *= (1.0 - dt / tau_y)\n\n    return delta_w\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}