{
    "hands_on_practices": [
        {
            "introduction": "理论模型的力量在于其能够解释和预测实验数据。本练习将理论与实践相结合，模拟了从实验数据中提取关键模型参数的过程。你将从带有噪声的合成数据入手，通过对数线性回归来拟合标准配对STDP模型（）的参数，例如振幅 $A_+$ 和时间常数 $\\tau_+$。这个练习不仅能加深你对STDP指数窗口的理解，还能让你掌握计算神经科学中一项核心的建模技能：参数估计。",
            "id": "4007206",
            "problem": "您将执行一个基于脉冲时间依赖可塑性 (STDP) 原理的模型拟合任务。脉冲时间依赖可塑性 (STDP) 将突触权重变化 $\\Delta w$ 定义为在时间 $t_{\\text{post}}$ 发生的突触后脉冲与在时间 $t_{\\text{pre}}$ 发生的突触前脉冲之间的相对时间 $\\Delta t = t_{\\text{post}} - t_{\\text{pre}}$ 的函数。在基于脉冲对的 STDP 模型中，突触更新由因果区域 ($\\Delta t > 0$) 和反因果区域 ($\\Delta t  0$) 中的指数核建模。这个指数窗口源于突触前和突触后活动轨迹的相互作用，这些轨迹以特征时间常数衰减；这些轨迹的时间常数和振幅随后用于参数化更高阶的三联体和四联体 STDP 模型。在此问题中，您将推断指数窗口的参数，并对新的脉冲对进行预测验证。\n\n假设采用以下经过充分检验的基于脉冲对的 STDP 模型：对于 $\\Delta t > 0$，突触增强为 $\\Delta w(\\Delta t) = A_{+} \\exp\\!\\left(-\\frac{\\Delta t}{\\tau_{+}}\\right)$；对于 $\\Delta t  0$，突触抑制为 $\\Delta w(\\Delta t) = -A_{-} \\exp\\!\\left(\\frac{\\Delta t}{\\tau_{-}}\\right)$，其中 $A_{+} > 0$ 和 $A_{-} > 0$ 是振幅参数（无量纲），$\\tau_{+} > 0$ 和 $\\tau_{-} > 0$ 是时间常数（单位为秒）。所有时间 $\\Delta t$ 必须以秒为单位表示，所有突触变化 $\\Delta w$ 均为无量纲。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 从一个已知的真实参数集 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$ 开始，通过向每个训练 $\\Delta w$ 值添加指定的小的加性测量噪声，为指定的训练时间差 $\\Delta t$ 构建一个测量的 $\\Delta w$ 值训练数据集。测量噪声值已提供，必须直接相加（它们是无量纲的）。\n2. 根据指数窗口假设，通过对数变换后的幅值进行最小二乘法拟合，从带噪声的训练数据中拟合参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$。\n3. 使用拟合的参数，为提供的一组新的 $\\Delta t$ 值（无噪声）的验证集预测 $\\Delta w$。\n4. 计算预测的 $\\Delta w$ 值与从已知参数集为验证 $\\Delta t$ 值导出的真实（无噪声）$\\Delta w$ 值之间的均方根误差 (RMSE)。\n5. 报告每个测试用例的 RMSE。\n\n单位和数值规范：\n- 所有 $\\Delta t$ 值均以秒为单位提供，并且必须按此使用。\n- 所有 $\\Delta w$ 值均为无量纲。\n- 本问题不涉及角度。\n- 最终的数值输出必须是四舍五入到六位小数的浮点数。\n\n测试套件：\n- 用例 1（中等采样和小噪声的一般情况）：\n  - 真实参数：$A_{+} = 0.0100$，$\\tau_{+} = 0.0200$ s，$A_{-} = 0.0120$，$\\tau_{-} = 0.0250$ s。\n  - 训练时间差：\n    - 正分支 ($\\Delta t > 0$)：$\\{0.001, 0.005, 0.010, 0.020, 0.030\\}$ s。\n    - 负分支 ($\\Delta t  0$)：$\\{-0.001, -0.005, -0.010, -0.020, -0.030\\}$ s。\n  - 训练 $\\Delta w$ 的加性测量噪声（逐元素应用）：\n    - 正分支：$\\{0.000020, -0.000015, 0.000010, -0.000002, 0.000000\\}$。\n    - 负分支：$\\{-0.000020, 0.000012, -0.000010, 0.000002, 0.000000\\}$。\n  - 验证时间差：\n    - 正分支：$\\{0.004, 0.015, 0.025\\}$ s。\n    - 负分支：$\\{-0.004, -0.015, -0.025\\}$ s。\n- 用例 2（最少采样和无噪声的边界情况）：\n  - 真实参数：$A_{+} = 0.0120$，$\\tau_{+} = 0.0100$ s，$A_{-} = 0.0110$，$\\tau_{-} = 0.0350$ s。\n  - 训练时间差：\n    - 正分支：$\\{0.005, 0.030\\}$ s。\n    - 负分支：$\\{-0.005, -0.030\\}$ s。\n  - 加性测量噪声：两个分支均为零。\n  - 验证时间差：\n    - 正分支：$\\{0.012\\}$ s。\n    - 负分支：$\\{-0.012\\}$ s。\n- 用例 3（非对称时间常数和小噪声的边缘情况）：\n  - 真实参数：$A_{+} = 0.0065$，$\\tau_{+} = 0.0050$ s，$A_{-} = 0.0130$，$\\tau_{-} = 0.0500$ s。\n  - 训练时间差：\n    - 正分支：$\\{0.001, 0.003, 0.007\\}$ s。\n    - 负分支：$\\{-0.010, -0.030, -0.050\\}$ s。\n  - 加性测量噪声：\n    - 正分支：$\\{0.000005, -0.000003, 0.000000\\}$。\n    - 负分支：$\\{0.000020, -0.000010, 0.000000\\}$。\n  - 验证时间差：\n    - 正分支：$\\{0.0025, 0.0060\\}$ s。\n    - 负分支：$\\{-0.020, -0.040\\}$ s。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列，结果四舍五入到六位小数：$[\\text{rmse\\_case1},\\text{rmse\\_case2},\\text{rmse\\_case3}]$。",
            "solution": "用户希望解决一个基于脉冲时间依赖可塑性 (STDP) 模型的模型拟合问题。\n\n### 1. 问题验证\n\n首先根据所需标准对问题进行验证。\n\n*   **已知条件提取**：\n    *   **模型**：突触权重变化 $\\Delta w$ 被给出为时间差 $\\Delta t = t_{\\text{post}} - t_{\\text{pre}}$ 的函数。\n        *   对于增强 ($\\Delta t > 0$)：$\\Delta w(\\Delta t) = A_{+} \\exp(-\\Delta t / \\tau_{+})$。\n        *   对于抑制 ($\\Delta t  0$)：$\\Delta w(\\Delta t) = -A_{-} \\exp(\\Delta t / \\tau_{-})$。\n        *   参数是振幅 $A_{+}, A_{-} > 0$ 和时间常数 $\\tau_{+}, \\tau_{-} > 0$。\n    *   **任务**：为三个不同的测试用例定义了一个多步骤过程，包括数据生成、参数拟合、预测和误差计算。\n        1.  从给定的真实参数生成带噪声的训练数据。\n        2.  使用对训练数据的对数变换幅值进行最小二乘法，拟合四个模型参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$。\n        3.  使用拟合的参数为验证集中的 $\\Delta t$ 值预测 $\\Delta w$。\n        4.  计算这些预测值与无噪声的真实值之间的均方根误差 (RMSE)。\n    *   **数据**：所有真实参数、训练时间差、加性噪声值和验证时间差都为三个独立的测试用例明确提供。\n    *   **输出**：最终结果必须是三个用例的 RMSE 值列表，四舍五入到六位小数。\n\n*   **验证结论**：\n    *   **科学依据**：该问题基于 STDP 的标准基于脉冲对的指数模型，这是计算神经科学中的一个基本且公认的概念。模型及其参数与科学文献一致。此标准已满足。\n    *   **适定性**：该问题是适定的。任务是实现一个明确定义的数值程序。拟合方法，即对数线性回归，已被指定，它能为给定数据得出唯一的参数解。所提供的数据集，即使是用例2中的最简数据集，也包含足够的点（至少两个）来拟合线性模型，从而确保解的存在。\n    *   **客观性**：该问题以精确、客观的数学和程序术语陈述。所有数据都是数值型的，没有主观因素。此标准已满足。\n    *   **完整性和一致性**：该问题是自洽的。所有必要的公式、参数和数据集都已提供。噪声值足够小，不会改变训练 $\\Delta w$ 值的符号，这对数变换至关重要。设置是一致且完整的。\n\n*   **结论**：该问题是有效的。它是一个基于已确立科学原理的、定义明确的计算任务。我将着手开发解决方案。\n\n### 2. 解决方案设计\n\n问题的核心是通过将指数模型转换为线性模型来拟合其参数。STDP 曲线的正负分支是独立的，可以分开进行拟合。\n\n*   **正分支 ($\\Delta t > 0$)**：\n    *   模型是 $\\Delta w = A_{+} \\exp(-\\Delta t / \\tau_{+})$。\n    *   对两边取自然对数得到：$\\ln(\\Delta w) = \\ln(A_{+}) - (1/\\tau_{+}) \\Delta t$。\n    *   这是一个 $y = c + m x$ 形式的线性方程，其中 $y = \\ln(\\Delta w)$，$x = \\Delta t$，截距为 $c = \\ln(A_{+})$，斜率为 $m = -1/\\tau_{+}$。\n    *   我们可以对训练数据对 $(\\Delta t_{\\text{train}}, \\ln(\\Delta w_{\\text{train}}))$ 进行线性回归，以找到最佳拟合斜率 $\\hat{m}_{+}$ 和截距 $\\hat{c}_{+}$。\n    *   然后拟合参数可恢复为：$\\hat{A}_{+} = \\exp(\\hat{c}_{+})$ 和 $\\hat{\\tau}_{+} = -1/\\hat{m}_{+}$。\n\n*   **负分支 ($\\Delta t  0$)**：\n    *   模型是 $\\Delta w = -A_{-} \\exp(\\Delta t / \\tau_{-})$。我们处理幅值 $|\\Delta w| = A_{-} \\exp(\\Delta t / \\tau_{-})$。\n    *   取自然对数得到：$\\ln(|\\Delta w|) = \\ln(A_{-}) + (1/\\tau_{-}) \\Delta t$。\n    *   这同样是一个 $y = c + m x$ 形式的线性方程，其中 $y = \\ln(|\\Delta w|)$，$x = \\Delta t$，截距为 $c = \\ln(A_{-})$，斜率为 $m = 1/\\tau_{-}$。\n    *   我们对训练数据对 $(\\Delta t_{\\text{train}}, \\ln(|\\Delta w_{\\text{train}}|))$ 进行线性回归，以找到最佳拟合斜率 $\\hat{m}_{-}$ 和截距 $\\hat{c}_{-}$。\n    *   然后拟合参数可恢复为：$\\hat{A}_{-} = \\exp(\\hat{c}_{-})$ 和 $\\hat{\\tau}_{-} = 1/\\hat{m}_{-}$。\n\n*   **每个测试用例的算法**：\n    1.  **数据生成**：\n        *   对于正训练 $\\Delta t$ 值，使用给定的 $A_{+}$ 和 $\\tau_{+}$ 计算真实 $\\Delta w$。添加指定的噪声以获得训练 $\\Delta w$ 值。\n        *   同样，对于负训练 $\\Delta t$ 值，使用 $A_{-}$ 和 $\\tau_{-}$ 计算真实 $\\Delta w$ 并添加相应的噪声。\n    2.  **参数拟合**：\n        *   使用正训练数据 $(\\Delta t, \\Delta w)$，计算 $(\\Delta t, \\ln(\\Delta w))$ 并执行线性回归（例如，使用 `numpy.polyfit`，阶数为1）以获得 $\\hat{m}_{+}$ 和 $\\hat{c}_{+}$。计算 $\\hat{A}_{+}$ 和 $\\hat{\\tau}_{+}$。\n        *   使用负训练数据 $(\\Delta t, \\Delta w)$，计算 $(\\Delta t, \\ln(|\\Delta w|))$ 并执行线性回归以获得 $\\hat{m}_{-}$ 和 $\\hat{c}_{-}$。计算 $\\hat{A}_{-}$ 和 $\\hat{\\tau}_{-}$。\n    3.  **预测**：\n        *   使用带有参数 $(\\hat{A}_{+}, \\hat{\\tau}_{+}, \\hat{A}_{-}, \\hat{\\tau}_{-})$ 的完整拟合模型来计算验证集中所有 $\\Delta t$ 值的预测 $\\Delta w_{\\text{pred}}$。\n    4.  **误差计算**：\n        *   使用带有参数 $(A_{+}, \\tau_{+}, A_{-}, \\tau_{-})$ 的真实模型来计算验证集中所有 $\\Delta t$ 值的真实 $\\Delta w_{\\text{gt}}$。\n        *   计算 RMSE：$\\text{RMSE} = \\sqrt{\\text{mean}[(\\Delta w_{\\text{pred}} - \\Delta w_{\\text{gt}})^2]}$。\n    5.  **输出**：存储计算出的RMSE值，四舍五入到六位小数。\n\n此程序将为提供的三个测试用例中的每一个实施。无噪声的用例（用例2）作为对照，其中拟合的参数应与真实参数完全匹配，从而导致 RMSE 为 $0$。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the STDP model-fitting problem for three test cases.\n    For each case, it:\n    1. Generates noisy training data from ground-truth parameters.\n    2. Fits the STDP model parameters via log-linear regression.\n    3. Predicts weight changes for a validation set using the fitted model.\n    4. Computes the RMSE between predictions and ground-truth values.\n    \"\"\"\n    test_cases = [\n        {\n            \"gt_params\": {\"A_p\": 0.0100, \"tau_p\": 0.0200, \"A_n\": 0.0120, \"tau_n\": 0.0250},\n            \"train_dt_p\": [0.001, 0.005, 0.010, 0.020, 0.030],\n            \"train_dt_n\": [-0.001, -0.005, -0.010, -0.020, -0.030],\n            \"noise_p\": [0.000020, -0.000015, 0.000010, -0.000002, 0.000000],\n            \"noise_n\": [-0.000020, 0.000012, -0.000010, 0.000002, 0.000000],\n            \"val_dt\": [0.004, 0.015, 0.025, -0.004, -0.015, -0.025],\n        },\n        {\n            \"gt_params\": {\"A_p\": 0.0120, \"tau_p\": 0.0100, \"A_n\": 0.0110, \"tau_n\": 0.0350},\n            \"train_dt_p\": [0.005, 0.030],\n            \"train_dt_n\": [-0.005, -0.030],\n            \"noise_p\": [0.0, 0.0],\n            \"noise_n\": [0.0, 0.0],\n            \"val_dt\": [0.012, -0.012],\n        },\n        {\n            \"gt_params\": {\"A_p\": 0.0065, \"tau_p\": 0.0050, \"A_n\": 0.0130, \"tau_n\": 0.0500},\n            \"train_dt_p\": [0.001, 0.003, 0.007],\n            \"train_dt_n\": [-0.010, -0.030, -0.050],\n            \"noise_p\": [0.000005, -0.000003, 0.000000],\n            \"noise_n\": [0.000020, -0.000010, 0.000000],\n            \"val_dt\": [0.0025, 0.0060, -0.020, -0.040],\n        },\n    ]\n\n    results = []\n\n    def stdp_model(dt, A_p, tau_p, A_n, tau_n):\n        \"\"\"Calculates delta_w based on the STDP model.\"\"\"\n        if dt > 0:\n            return A_p * np.exp(-dt / tau_p)\n        elif dt  0:\n            return -A_n * np.exp(dt / tau_n)\n        else:\n            return 0.0\n\n    for case in test_cases:\n        gt_params = case[\"gt_params\"]\n        \n        # 1. Construct training dataset\n        train_dt_p = np.array(case[\"train_dt_p\"])\n        train_dt_n = np.array(case[\"train_dt_n\"])\n        noise_p = np.array(case[\"noise_p\"])\n        noise_n = np.array(case[\"noise_n\"])\n\n        # Positive branch training data\n        dw_gt_p = gt_params[\"A_p\"] * np.exp(-train_dt_p / gt_params[\"tau_p\"])\n        dw_train_p = dw_gt_p + noise_p\n\n        # Negative branch training data\n        dw_gt_n = -gt_params[\"A_n\"] * np.exp(train_dt_n / gt_params[\"tau_n\"])\n        dw_train_n = dw_gt_n + noise_n\n\n        # 2. Fit parameters from noisy training data\n        \n        # Fit positive branch\n        # y = ln(dw) = ln(A_p) - (1/tau_p)*dt. This is a line y = c + m*x\n        # m = -1/tau_p, c = ln(A_p)\n        log_dw_train_p = np.log(dw_train_p)\n        m_p, c_p = np.polyfit(train_dt_p, log_dw_train_p, 1)\n        \n        tau_p_fit = -1 / m_p\n        A_p_fit = np.exp(c_p)\n\n        # Fit negative branch\n        # y = ln(|dw|) = ln(A_n) + (1/tau_n)*dt. This is a line y = c + m*x\n        # m = 1/tau_n, c = ln(A_n)\n        log_abs_dw_train_n = np.log(np.abs(dw_train_n))\n        m_n, c_n = np.polyfit(train_dt_n, log_abs_dw_train_n, 1)\n\n        tau_n_fit = 1 / m_n\n        A_n_fit = np.exp(c_n)\n        \n        fitted_params = {\n            \"A_p\": A_p_fit, \"tau_p\": tau_p_fit, \n            \"A_n\": A_n_fit, \"tau_n\": tau_n_fit\n        }\n\n        # 3. Predict dw for validation set\n        val_dt = np.array(case[\"val_dt\"])\n        dw_pred = np.array([stdp_model(dt, **fitted_params) for dt in val_dt])\n\n        # 4. Compute RMSE against ground-truth values\n        dw_gt_val = np.array([stdp_model(dt, **gt_params) for dt in val_dt])\n        \n        rmse = np.sqrt(np.mean((dw_pred - dw_gt_val)**2))\n        \n        results.append(f\"{rmse:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在为复杂的神经动力学建立计算模型后，一个至关重要的步骤是验证我们的数值模拟是否忠实于其背后的数学理论。本练习旨在让你直面这一挑战，比较一个包含配对、三重态和四重态相互作用的STDP模型的精确解析解与一个时间步进的数值模拟结果（）。通过计算两者之间的差异，你将亲身体会到数值方法（如欧拉法）引入的近似误差，并理解模型验证在确保模拟可靠性方面的重要性。",
            "id": "4007267",
            "problem": "一项计算神经科学的验证任务是，在多种参数体系下，比较基于核的脉冲时间依赖可塑性（STDP）公式的解析预测与受控脉冲序列的时间步长模拟结果，并量化两者之间的差异。脉冲时间依赖可塑性（STDP）通过突触前和突触后脉冲序列进行建模，这些脉冲序列表示为狄拉克δ函数的和。设突触前脉冲序列为 $s_{\\mathrm{pre}}(t) = \\sum_{i} \\delta(t - t^{\\mathrm{pre}}_{i})$，突触后脉冲序列为 $s_{\\mathrm{post}}(t) = \\sum_{j} \\delta(t - t^{\\mathrm{post}}_{j})$。设突触前轨迹 $x(t)$ 和突触后轨迹 $y(t)$ 服从线性常微分方程 $dx/dt = -x/\\tau_{x} + s_{\\mathrm{pre}}(t)$ 和 $dy/dt = -y/\\tau_{y} + s_{\\mathrm{post}}(t)$，其中 $x(t)$ 和 $y(t)$ 在各自脉冲的时刻增加1，并以时间常数 $\\tau_{x} > 0$ 和 $\\tau_{y} > 0$ 指数衰减。\n\n突触权重变化 $\\Delta w$ 通过三种交互阶在脉冲事件时累积：\n- 基于脉冲对的交互：在每个时刻为 $t^{\\mathrm{post}}_{j}$ 的突触后脉冲处，增加一个增量 $A_{+} \\, x(t^{\\mathrm{post}}_{j})$；在每个时刻为 $t^{\\mathrm{pre}}_{i}$ 的突触前脉冲处，增加一个量 $A_{-} \\, y(t^{\\mathrm{pre}}_{i})$，并带负号（即 $-A_{-} \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{+} \\ge 0$ 和 $A_{-} \\ge 0$ 是幅度。\n- 基于三联体的交互：在每个时刻为 $t^{\\mathrm{post}}_{j}$ 的突触后脉冲处，增加一个增量 $A_{3+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})$；在每个时刻为 $t^{\\mathrm{pre}}_{i}$ 的突触前脉冲处，增加一个量 $A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i})$，并带负号（即 $-A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{3+} \\ge 0$ 和 $A_{3-} \\ge 0$ 是幅度。\n- 基于四联体的交互：在每个时刻为 $t^{\\mathrm{post}}_{j}$ 的突触后脉冲处，增加一个增量 $A_{4+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})^{2}$；在每个时刻为 $t^{\\mathrm{pre}}_{i}$ 的突触前脉冲处，增加一个量 $A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$，并带负号（即 $-A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$），其中 $A_{4+} \\ge 0$ 和 $A_{4-} \\ge 0$ 是幅度。\n\n脉冲时刻轨迹的解析预测可以从带δ输入的线性常微分方程的指数衰减解中得出。具体来说，对于任何时刻 $t$，轨迹满足 $x(t) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t} \\exp\\!\\big(-(t - t^{\\mathrm{pre}}_{i})/\\tau_{x}\\big)$ 和 $y(t) = \\sum_{j: t^{\\mathrm{post}}_{j}  t} \\exp\\!\\big(-(t - t^{\\mathrm{post}}_{j})/\\tau_{y}\\big)$，这确保了在时刻 $t$ 更新之前，只有严格早于该时刻的脉冲才会产生影响。使用这些表达式，通过对所有脉冲时刻指定的基于脉冲对、三联体和四联体的增量求和，可以得到解析权重变化。\n\n将使用固定的基本步长 $\\Delta t > 0$ 来实现一个时间步长数值模拟。在时间网格点之间，使用显式欧拉步长对衰减动态进行更新；在精确的脉冲时刻，使用在该时刻脉冲引起的任何增量之前的当前轨迹值来应用对权重 $\\Delta w$ 的更新，之后轨迹会根据该瞬间发生的脉冲数量增加。基本步长可以被划分，以使网格精确包含所有脉冲时间，同时在连续的网格点之间保持显式欧拉更新。\n\n你的程序必须为每个测试用例计算：\n- 使用脉冲时刻的闭式轨迹值计算的解析权重变化 $\\Delta w_{\\mathrm{analytic}}$。\n- 使用带有所述事件处理的显式欧拉方法计算的模拟权重变化 $\\Delta w_{\\mathrm{sim}}$。\n- 定义为绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$ 的差异值。\n\n所有脉冲时间必须以秒为单位，所有时间常数也以秒为单位。突触权重变化是无量纲的。最终输出必须是浮点数。\n\n使用以下带有受控脉冲序列和参数的测试套件：\n- 测试用例1（正常路径）：突触前脉冲时刻为 $[0.0, 0.03, 0.06]$ 秒；突触后脉冲时刻为 $[0.01, 0.04, 0.07]$ 秒；时间常数 $\\tau_{x} = 0.02$ 秒和 $\\tau_{y} = 0.02$ 秒；幅度 $A_{+} = 0.005$，$A_{-} = 0.006$，$A_{3+} = 0.002$，$A_{3-} = 0.001$，$A_{4+} = 0.0005$，$A_{4-} = 0.0004$；基本步长 $\\Delta t = 0.0005$ 秒。\n- 测试用例2（同步事件与对称性）：突触前脉冲时刻为 $[0.0, 0.05]$ 秒；突触后脉冲时刻为 $[0.0, 0.05]$ 秒；时间常数 $\\tau_{x} = 0.02$ 秒和 $\\tau_{y} = 0.02$ 秒；幅度 $A_{+} = 0.010$，$A_{-} = 0.010$，$A_{3+} = 0.002$，$A_{3-} = 0.002$，$A_{4+} = 0.0001$，$A_{4-} = 0.0001$；基本步长 $\\Delta t = 0.001$ 秒。\n- 测试用例3（快速动态，密集脉冲）：突触前脉冲时刻为 $[0.0, 0.004, 0.008, 0.012]$ 秒；突触后脉冲时刻为 $[0.002, 0.006, 0.010]$ 秒；时间常数 $\\tau_{x} = 0.003$ 秒和 $\\tau_{y} = 0.003$ 秒；幅度 $A_{+} = 0.004$，$A_{-} = 0.004$，$A_{3+} = 0.0015$，$A_{3-} = 0.0010$，$A_{4+} = 0.0003$，$A_{4-} = 0.00025$；基本步长 $\\Delta t = 0.001$ 秒。\n- 测试用例4（慢速动态，稀疏脉冲）：突触前脉冲时刻为 $[0.0, 0.1, 0.2]$ 秒；突触后脉冲时刻为 $[0.05, 0.15, 0.25]$ 秒；时间常数 $\\tau_{x} = 0.05$ 秒和 $\\tau_{y} = 0.05$ 秒；幅度 $A_{+} = 0.006$，$A_{-} = 0.005$，$A_{3+} = 0.0025$，$A_{3-} = 0.0015$，$A_{4+} = 0.0006$，$A_{4-} = 0.0005$；基本步长 $\\Delta t = 0.002$ 秒。\n\n你的程序应生成单行输出，其中包含四个测试用例的差异结果，格式为方括号内以逗号分隔的列表（例如 $[d_{1},d_{2},d_{3},d_{4}]$），其中每个 $d_{k}$ 是测试用例 $k$ 的绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$，表示为无单位的浮点数。",
            "solution": "用户提供了一个计算神经科学问题，要求将脉冲时间依赖可塑性（STDP）模型的数值模拟与其解析解进行验证。该模型包含基于脉冲对、三联体和四联体的交互。任务是使用解析公式和时间步长数值模拟两种方法计算总突触权重变化 $\\Delta w$，然后找出几个测试用例下两种结果之间的绝对差。\n\n### 问题验证\n\n首先，必须严格验证问题陈述。\n\n**步骤1：提取已知条件**\n- 突触前脉冲序列：$s_{\\mathrm{pre}}(t) = \\sum_{i} \\delta(t - t^{\\mathrm{pre}}_{i})$。\n- 突触后脉冲序列：$s_{\\mathrm{post}}(t) = \\sum_{j} \\delta(t - t^{\\mathrm{post}}_{j})$。\n- 突触前轨迹动态：$dx/dt = -x/\\tau_{x} + s_{\\mathrm{pre}}(t)$，其中 $\\tau_{x}  0$。\n- 突触后轨迹动态：$dy/dt = -y/\\tau_{y} + s_{\\mathrm{post}}(t)$，其中 $\\tau_{y}  0$。\n- 轨迹更新规则：轨迹在脉冲时刻增加1。\n- 权重变化规则（$\\Delta w$）：\n  - 在突触后脉冲 $t^{\\mathrm{post}}_{j}$ 处：$\\Delta w$ 增加 $A_{+} \\, x(t^{\\mathrm{post}}_{j}) + A_{3+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j}) + A_{4+} \\, x(t^{\\mathrm{post}}_{j}) \\, y(t^{\\mathrm{post}}_{j})^{2}$，其中 $A_{+}, A_{3+}, A_{4+} \\ge 0$。\n  - 在突触前脉冲 $t^{\\mathrm{pre}}_{i}$ 处：$\\Delta w$ 减少 $A_{-} \\, y(t^{\\mathrm{pre}}_{i}) + A_{3-} \\, x(t^{\\mathrm{pre}}_{i}) \\, y(t^{\\mathrm{pre}}_{i}) + A_{4-} \\, x(t^{\\mathrm{pre}}_{i})^{2} \\, y(t^{\\mathrm{pre}}_{i})$，其中 $A_{-}, A_{3-}, A_{4-} \\ge 0$。\n- 解析轨迹解：$x(t) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t} \\exp\\!\\big(-(t - t^{\\mathrm{pre}}_{i})/\\tau_{x}\\big)$ 和 $y(t) = \\sum_{j: t^{\\mathrm{post}}_{j}  t} \\exp\\!\\big(-(t - t^{\\mathrm{post}}_{j})/\\tau_{y}\\big)$。\n- 数值模拟方法：使用固定基本步长 $\\Delta t$ 的显式欧拉法，其中时间网格保证包含所有脉冲时间。对 $\\Delta w$ 的更新使用脉冲引起的增量之前的轨迹值，之后轨迹再增加。\n- 目标：计算 $\\Delta w_{\\mathrm{analytic}}$、$\\Delta w_{\\mathrm{sim}}$ 以及差异 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$。\n- 测试用例提供了脉冲时间、时间常数、幅度和 $\\Delta t$ 的具体值。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了计算神经科学中一类成熟的STDP模型。轨迹的微分方程是漏积分器的标准模型，而基于脉冲对、三联体和四联体的交互项可以在相关科学文献中找到（例如，Pfister  Gerstner, 2006）。该问题在科学上是合理的。\n- **适定性和完整性**：所有必需的参数、初始条件（$x(0)=0, y(0)=0$）、方程和更新规则都已明确提供。解析计算和数值计算之间的区别是清晰的，模拟的操作顺序（先更新权重，后更新轨迹）也是明确的。该问题是自洽且适定的。\n- **客观性和一致性**：所用术语精确客观，没有矛盾之处。例如，对于解析解，“只有严格较早的脉冲才有贡献”的指令是一个无歧义的定义，而“使用任何增量之前的轨迹值”的模拟规则同样清晰。\n\n**步骤3：结论与行动**\n问题在科学上有效、适定且内部一致，没有缺陷。因此，我将继续制定和实施解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案需要实现两种不同的方法来计算总突触权重变化 $\\Delta w$。\n\n**1. 解析计算（$\\Delta w_{\\mathrm{analytic}}$）**\n\n解析计算依赖于突触轨迹 $x(t)$ 和 $y(t)$ 的闭式解。总权重变化是在每个脉冲时刻发生的所有单个变化的总和。\n\n算法如下：\n1.  识别所有唯一脉冲时间的集合 $\\{t_k\\} = \\{t^{\\mathrm{pre}}_{i}\\} \\cup \\{t^{\\mathrm{post}}_{j}\\}$，并按时间顺序排序。\n2.  初始化总权重变化 $\\Delta w_{\\mathrm{analytic}} = 0$。\n3.  在排序后的列表中遍历每个唯一的脉冲时间 $t_k$。\n4.  在每个 $t_k$ 处，使用提供的解析公式计算突触前轨迹 $x(t_k)$ 和突触后轨迹 $y(t_k)$ 的值。这些公式对所有在 $t_k$ *之前* 发生的脉冲的贡献求和：\n    $$x(t_k) = \\sum_{i: t^{\\mathrm{pre}}_{i}  t_k} \\exp\\!\\left(-\\frac{t_k - t^{\\mathrm{pre}}_{i}}{\\tau_{x}}\\right)$$\n    $$y(t_k) = \\sum_{j: t^{\\mathrm{post}}_{j}  t_k} \\exp\\!\\left(-\\frac{t_k - t^{\\mathrm{post}}_{j}}{\\tau_{y}}\\right)$$\n5.  如果 $t_k$ 是一个突触后脉冲时间，计算增强增量并将其加到 $\\Delta w_{\\mathrm{analytic}}$ 中。如果在 $t_k$ 处发生多个脉冲，则对每个脉冲都应用此操作：\n    $$\\Delta w_{\\mathrm{pot}}(t_k) = A_{+} x(t_k) + A_{3+} x(t_k) y(t_k) + A_{4+} x(t_k) y(t_k)^2$$\n6.  如果 $t_k$ 是一个突触前脉冲时间，计算抑制减量并将其加到 $\\Delta w_{\\mathrm{analytic}}$ 中。注意总的负号：\n    $$\\Delta w_{\\mathrm{dep}}(t_k) = - \\left( A_{-} y(t_k) + A_{3-} x(t_k) y(t_k) + A_{4-} x(t_k)^2 y(t_k) \\right)$$\n7.  最终的 $\\Delta w_{\\mathrm{analytic}}$ 是在所有脉冲时间内所有此类增量和减量的总和。\n\n**2. 数值模拟（$\\Delta w_{\\mathrm{sim}}$）**\n\n数值模拟使用带有显式欧拉方法的离散时间步长方法来近似轨迹动态。问题指定了一个将动态分为离散事件（脉冲）和连续演化（衰减）的过程。\n\n算法如下：\n1.  根据给定的脉冲序列确定最大模拟时间 $t_{\\mathrm{max}}$。\n2.  将时间离散化为大小为 $\\Delta t$ 的步长，从 $t=0$到 $t_{\\mathrm{max}}$。测试用例的设计使得所有脉冲时间都是 $\\Delta t$ 的整数倍，从而简化了网格。我们创建一个从模拟步长索引 $i$ 到在时间 $t_i = i \\cdot \\Delta t$ 发生的突触前和突触后脉冲数量的映射。\n3.  初始化轨迹 $x=0$，$y=0$，以及总权重变化 $\\Delta w_{\\mathrm{sim}} = 0$。\n4.  从步骤 $i=0$ 迭代到 $i=t_{\\mathrm{max}}/\\Delta t$。在每个步骤中，设当前时间为 $t_i = i \\cdot \\Delta t$。变量 $x$ 和 $y$ 保存时间步开始时的轨迹值，即在处理 $t_i$ 处的任何事件之前的值。\n    a.  **权重更新：** 检查在时间 $t_i$ 的突触前和突触后脉冲。权重变化使用当前的轨迹值 $x$ 和 $y$ 计算。\n        - 对于每个突触后脉冲：$\\Delta w_{\\mathrm{sim}} \\mathrel{+}= A_{+} x + A_{3+} x y + A_{4+} x y^2$。\n        - 对于每个突触前脉冲：$\\Delta w_{\\mathrm{sim}} \\mathrel{-}= A_{-} y + A_{3-} x y + A_{4-} x^2 y$。\n    b.  **轨迹增量：** 权重更新后，轨迹根据 $t_i$ 处的脉冲数量瞬时增加。设 $n_{\\mathrm{pre}}$ 和 $n_{\\mathrm{post}}$ 为脉冲计数。\n        $$x \\leftarrow x + n_{\\mathrm{pre}}$$\n        $$y \\leftarrow y + n_{\\mathrm{post}}$$\n    c.  **轨迹演化：** 使用显式欧拉方法对衰减动态 $dx/dt=-x/\\tau_x$ 和 $dy/dt=-y/\\tau_y$ 在区间 $\\Delta t$ 上演化新的轨迹值。更新后的值成为下一个时间步长 $t_{i+1}$ 开始时的轨迹状态。\n        $$x \\leftarrow x \\cdot \\left(1 - \\frac{\\Delta t}{\\tau_x}\\right)$$\n        $$y \\leftarrow y \\cdot \\left(1 - \\frac{\\Delta t}{\\tau_y}\\right)$$\n5.  循环完成后，$\\Delta w_{\\mathrm{sim}}$ 保存了总的模拟权重变化。\n\n**3. 差异计算**\n\n最终要求的值是解析结果和模拟结果之间的绝对差 $|\\Delta w_{\\mathrm{analytic}} - \\Delta w_{\\mathrm{sim}}|$。这个差值量化了由显式欧拉近似引入的数值误差，该近似用其一阶泰勒展开式 $1 - \\Delta t/\\tau$ 来逼近真实的指数衰减 $e^{-\\Delta t/\\tau}$。\n\n以下Python代码为每个测试用例实现了这三个组件。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import Counter\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for the STDP model validation.\n    \"\"\"\n    test_cases = [\n        {\n            \"t_pre\": [0.0, 0.03, 0.06], \"t_post\": [0.01, 0.04, 0.07],\n            \"tau_x\": 0.02, \"tau_y\": 0.02,\n            \"A_p\": 0.005, \"A_m\": 0.006, \"A_3p\": 0.002, \"A_3m\": 0.001,\n            \"A_4p\": 0.0005, \"A_4m\": 0.0004, \"dt\": 0.0005\n        },\n        {\n            \"t_pre\": [0.0, 0.05], \"t_post\": [0.0, 0.05],\n            \"tau_x\": 0.02, \"tau_y\": 0.02,\n            \"A_p\": 0.010, \"A_m\": 0.010, \"A_3p\": 0.002, \"A_3m\": 0.002,\n            \"A_4p\": 0.0001, \"A_4m\": 0.0001, \"dt\": 0.001\n        },\n        {\n            \"t_pre\": [0.0, 0.004, 0.008, 0.012], \"t_post\": [0.002, 0.006, 0.010],\n            \"tau_x\": 0.003, \"tau_y\": 0.003,\n            \"A_p\": 0.004, \"A_m\": 0.004, \"A_3p\": 0.0015, \"A_3m\": 0.0010,\n            \"A_4p\": 0.0003, \"A_4m\": 0.00025, \"dt\": 0.001\n        },\n        {\n            \"t_pre\": [0.0, 0.1, 0.2], \"t_post\": [0.05, 0.15, 0.25],\n            \"tau_x\": 0.05, \"tau_y\": 0.05,\n            \"A_p\": 0.006, \"A_m\": 0.005, \"A_3p\": 0.0025, \"A_3m\": 0.0015,\n            \"A_4p\": 0.0006, \"A_4m\": 0.0005, \"dt\": 0.002\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        dw_analytic = calculate_analytic_dw(**params)\n        dw_sim = calculate_simulated_dw(**params)\n        discrepancy = abs(dw_analytic - dw_sim)\n        results.append(discrepancy)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_analytic_dw(t_pre, t_post, tau_x, tau_y, A_p, A_m, A_3p, A_3m, A_4p, A_4m, dt):\n    \"\"\"\n    Calculates the total weight change using the analytical formulas.\n    \"\"\"\n    t_pre_np = np.array(t_pre)\n    t_post_np = np.array(t_post)\n    \n    all_spike_times = sorted(list(set(t_pre) | set(t_post)))\n    \n    delta_w = 0.0\n\n    post_spike_counts = Counter(t_post)\n    pre_spike_counts = Counter(t_pre)\n\n    for t_event in all_spike_times:\n        # Calculate traces using spikes that occurred strictly before t_event\n        pre_spikes_before = t_pre_np[t_pre_np  t_event]\n        post_spikes_before = t_post_np[t_post_np  t_event]\n\n        x_t = np.sum(np.exp(-(t_event - pre_spikes_before) / tau_x)) if pre_spikes_before.size > 0 else 0.0\n        y_t = np.sum(np.exp(-(t_event - post_spikes_before) / tau_y)) if post_spikes_before.size > 0 else 0.0\n\n        # Process post-synaptic events at t_event\n        if t_event in post_spike_counts:\n            num_spikes = post_spike_counts[t_event]\n            dw_potentiation = A_p * x_t + A_3p * x_t * y_t + A_4p * x_t * y_t**2\n            delta_w += num_spikes * dw_potentiation\n\n        # Process pre-synaptic events at t_event\n        if t_event in pre_spike_counts:\n            num_spikes = pre_spike_counts[t_event]\n            dw_depression = A_m * y_t + A_3m * x_t * y_t + A_4m * x_t**2 * y_t\n            delta_w -= num_spikes * dw_depression\n            \n    return delta_w\n\ndef calculate_simulated_dw(t_pre, t_post, tau_x, tau_y, A_p, A_m, A_3p, A_3m, A_4p, A_4m, dt):\n    \"\"\"\n    Calculates the total weight change using time-stepped simulation.\n    \"\"\"\n    all_times = list(set(t_pre) | set(t_post))\n    if not all_times:\n        return 0.0\n    \n    t_max = max(all_times)\n\n    # Use rounding to map spike times to integer grid indices robustly\n    pre_spike_indices = {int(round(t / dt)): count for t, count in Counter(t_pre).items()}\n    post_spike_indices = {int(round(t / dt)): count for t, count in Counter(t_post).items()}\n    \n    num_steps = int(round(t_max / dt)) + 1\n    \n    x, y, delta_w = 0.0, 0.0, 0.0\n\n    for i in range(num_steps):\n        # x and y represent the trace values at the beginning of the step t=i*dt,\n        # evolved from the previous step.\n\n        # Check for spikes at current time step i and update weight\n        n_post = post_spike_indices.get(i, 0)\n        n_pre = pre_spike_indices.get(i, 0)\n\n        if n_post > 0:\n            dw_potentiation = A_p * x + A_3p * x * y + A_4p * x * y**2\n            delta_w += n_post * dw_potentiation\n        if n_pre > 0:\n            dw_depression = A_m * y + A_3m * x * y + A_4m * x**2 * y\n            delta_w -= n_pre * dw_depression\n\n        # Instantaneously increment traces due to spikes\n        x += n_pre\n        y += n_post\n\n        # Evolve traces over dt using explicit Euler method for the next step\n        x *= (1.0 - dt / tau_x)\n        y *= (1.0 - dt / tau_y)\n\n    return delta_w\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}