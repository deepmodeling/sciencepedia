{
    "hands_on_practices": [
        {
            "introduction": "The spread of misfolded proteins in Alzheimer's disease is often modeled as a process of diffusion along the brain's structural connectome, coupled with local clearance mechanisms. This dynamic can be elegantly captured by a linear differential equation involving the graph Laplacian. This foundational exercise  will guide you through the analytical solution of this model for a small, illustrative network, providing a concrete understanding of how to predict the evolution of pathology over time using the powerful technique of eigen-decomposition.",
            "id": "3962308",
            "problem": "Consider a linear network degeneration model for Alzheimer’s Disease (AD) pathology where the concentration vector $x(t) \\in \\mathbb{R}^{3}$ evolves on a three-region structural network governed by the ordinary differential equation\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\nwith diffusion strength $\\kappa > 0$, uniform clearance rate $\\lambda > 0$, graph Laplacian $L \\in \\mathbb{R}^{3 \\times 3}$, and identity matrix $I \\in \\mathbb{R}^{3 \\times 3}$. The three nodes correspond to the entorhinal cortex, hippocampus, and posterior cingulate, respectively. Assume the Laplacian is the symmetric path-graph Laplacian\n$$\nL = \\begin{pmatrix}\n1 & -1 & 0 \\\\\n-1 & 2 & -1 \\\\\n0 & -1 & 1\n\\end{pmatrix},\n$$\nand the initial AD pathology concentration at time $t=0$ is\n$$\nx(0) = \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n$$\nin Standardized Uptake Value Ratio (SUVR) units. Let the biophysical parameters be $\\kappa = 0.5$ $\\text{year}^{-1}$, $\\lambda = 0.2$ $\\text{year}^{-1}$, and evaluate the state at time $t = 3$ years.\n\nStarting from the fundamental properties of symmetric matrices and linear time-invariant systems, derive the analytic solution via eigen-decomposition of the Laplacian and compute the state $x(t)$ at $t=3$ years. Express each component of the final state in SUVR units and round each component to four significant figures. Your final answer must be a single row vector.",
            "solution": "The model is a linear time-invariant system:\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\nwhere $L$ is symmetric. For symmetric matrices, there exists an orthonormal eigenbasis $U \\in \\mathbb{R}^{3 \\times 3}$ such that\n$$\nL = U \\Lambda U^{\\top},\n$$\nwhere $\\Lambda = \\operatorname{diag}(\\lambda_{0}, \\lambda_{1}, \\lambda_{2})$ contains the eigenvalues of $L$, and $U^{\\top}U = I$.\n\nDefine the modal coordinates $y(t) = U^{\\top} x(t)$. Substituting $x(t) = U y(t)$ into the differential equation yields\n$$\n\\frac{d}{dt}(U y(t)) = -\\left( \\kappa U \\Lambda U^{\\top} + \\lambda I \\right) U y(t).\n$$\nUsing $U^{\\top}U = I$ and left-multiplying by $U^{\\top}$,\n$$\n\\frac{d}{dt} y(t) = -\\left( \\kappa \\Lambda + \\lambda I \\right) y(t),\n$$\nwhich decouples into three scalar ordinary differential equations\n$$\n\\frac{d}{dt} y_{i}(t) = -\\left( \\kappa \\lambda_{i} + \\lambda \\right) y_{i}(t), \\quad i = 0,1,2.\n$$\nThese have solutions\n$$\ny_{i}(t) = \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) y_{i}(0).\n$$\nTransforming back to the original coordinates,\n$$\nx(t) = U y(t) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) y(0) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) U^{\\top} x(0),\n$$\nwhich is the spectral form of the matrix exponential solution.\n\nWe now compute the eigen-decomposition of the given path-graph Laplacian\n$$\nL = \\begin{pmatrix}\n1 & -1 & 0 \\\\\n-1 & 2 & -1 \\\\\n0 & -1 & 1\n\\end{pmatrix}.\n$$\nThe eigenvalues are known for the path graph of three nodes, or can be obtained by solving $\\det(L - \\mu I) = 0$, yielding\n$$\n\\lambda_{0} = 0, \\quad \\lambda_{1} = 1, \\quad \\lambda_{2} = 3.\n$$\nA corresponding set of orthonormal eigenvectors is\n$$\nv_{0} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nv_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\quad\nv_{2} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ -2 \\\\ 1 \\end{pmatrix}.\n$$\nCollect these as columns of $U = [v_{0}\\; v_{1}\\; v_{2}]$.\n\nProject the initial condition into modal coordinates:\n$$\ny(0) = U^{\\top} x(0) = \\begin{pmatrix}\nv_{0}^{\\top} x(0) \\\\\nv_{1}^{\\top} x(0) \\\\\nv_{2}^{\\top} x(0)\n\\end{pmatrix}.\n$$\nCompute each component:\n- For $v_{0}$,\n$$\ny_{0}(0) = v_{0}^{\\top} x(0) = \\frac{1}{\\sqrt{3}} (1.0 + 0.3 + 0.1) = \\frac{1.4}{\\sqrt{3}}.\n$$\n- For $v_{1}$,\n$$\ny_{1}(0) = v_{1}^{\\top} x(0) = \\frac{1}{\\sqrt{2}} (1.0 - 0.1) = \\frac{0.9}{\\sqrt{2}}.\n$$\n- For $v_{2}$,\n$$\ny_{2}(0) = v_{2}^{\\top} x(0) = \\frac{1}{\\sqrt{6}} (1.0 - 2 \\cdot 0.3 + 0.1) = \\frac{0.5}{\\sqrt{6}}.\n$$\n\nWith $\\kappa = 0.5$ $\\text{year}^{-1}$, $\\lambda = 0.2$ $\\text{year}^{-1}$, and $t = 3$ $\\text{years}$, the modal decay factors are\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{0} + \\lambda) t \\right) = \\exp(-0.2 \\cdot 3) = \\exp(-0.6),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{1} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 1 + 0.2) \\cdot 3) = \\exp(-2.1),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{2} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 3 + 0.2) \\cdot 3) = \\exp(-5.1).\n$$\nHence\n$$\ny(t) = \\begin{pmatrix}\n\\exp(-0.6)\\, \\frac{1.4}{\\sqrt{3}} \\\\\n\\exp(-2.1)\\, \\frac{0.9}{\\sqrt{2}} \\\\\n\\exp(-5.1)\\, \\frac{0.5}{\\sqrt{6}}\n\\end{pmatrix}.\n$$\nReconstruct $x(t)$ as\n$$\nx(t) = U y(t) = \\sum_{i=0}^{2} \\left[ \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) \\, y_{i}(0) \\, v_{i} \\right].\n$$\nFor numerical evaluation, it is convenient to use projection matrices $v_{i} v_{i}^{\\top}$ acting on $x(0)$. The contributions are:\n- For $v_{0}$,\n$$\nv_{0} v_{0}^{\\top} x(0) = \\frac{1}{3} \\begin{pmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{3} \\begin{pmatrix} 1.4 \\\\ 1.4 \\\\ 1.4 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-0.6)$ gives the $v_{0}$-contribution to each component:\n$$\n\\exp(-0.6) \\cdot \\frac{1.4}{3} \\approx 0.5488116360940264 \\cdot 0.4666666666666667 \\approx 0.256112096843879.\n$$\n- For $v_{1}$,\n$$\nv_{1} v_{1}^{\\top} x(0) = \\frac{1}{2} \\begin{pmatrix} 1 & 0 & -1 \\\\ 0 & 0 & 0 \\\\ -1 & 0 & 1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{2} \\begin{pmatrix} 0.9 \\\\ 0 \\\\ -0.9 \\end{pmatrix}\n= \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-2.1)$ yields\n$$\n\\exp(-2.1) \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n\\approx 0.1224564282529819 \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n= \\begin{pmatrix} 0.055105392713841 \\\\ 0 \\\\ -0.055105392713841 \\end{pmatrix}.\n$$\n- For $v_{2}$,\n$$\nv_{2} v_{2}^{\\top} x(0) = \\frac{1}{6} \\begin{pmatrix} 1 & -2 & 1 \\\\ -2 & 4 & -2 \\\\ 1 & -2 & 1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{6} \\begin{pmatrix} 0.5 \\\\ -1.0 \\\\ 0.5 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-5.1)$ gives\n$$\n\\exp(-5.1) \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n\\approx 0.00609678 \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n= \\begin{pmatrix} \\frac{0.00609678}{12} \\\\ -\\frac{0.00609678}{6} \\\\ \\frac{0.00609678}{12} \\end{pmatrix}\n\\approx \\begin{pmatrix} 0.000508065 \\\\ -0.001016130 \\\\ 0.000508065 \\end{pmatrix}.\n$$\n\nSumming the three contributions component-wise yields\n$$\nx_{1}(3) \\approx 0.256112096843879 + 0.055105392713841 + 0.000508065 \\approx 0.3117255547,\n$$\n$$\nx_{2}(3) \\approx 0.256112096843879 + 0 - 0.001016130 \\approx 0.2550959668,\n$$\n$$\nx_{3}(3) \\approx 0.256112096843879 - 0.055105392713841 + 0.000508065 \\approx 0.2015147692.\n$$\n\nRounded to four significant figures and expressed in Standardized Uptake Value Ratio (SUVR) units, the final state vector at $t = 3$ years is\n$$\n\\begin{pmatrix}\n0.3117 & 0.2551 & 0.2015\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.3117 & 0.2551 & 0.2015 \\end{pmatrix}}$$"
        },
        {
            "introduction": "A crucial decision in network neuroscience is how to represent the brain's complex, directed pathways. This practice  explores the profound impact of this choice by comparing pathology spread on a directed connectome versus its simplified, symmetrized counterpart. By implementing a linear spread model and calculating the resulting \"staging\" of pathology, you will gain direct insight into how the directionality of network connections can fundamentally alter the predicted sequence of regional vulnerability.",
            "id": "3962345",
            "problem": "You are tasked with implementing and analyzing a principled network-based staging model for Alzheimer's disease (AD) network degeneration. The central question is whether and why early staging order can differ between a directed connectivity representation and its symmetrized counterpart when seeding pathology at node $A$. Your program must derive a continuous-time linear spread model from first principles, compute threshold-crossing times for each node under both directed and symmetrized propagators, and aggregate results across a provided test suite.\n\nFundamental base and modeling requirements:\n- Begin from the definition of a directed adjacency matrix $A$ for a network of brain regions, where $A_{ij}$ is the nonnegative weight assigned to the directed edge from node $i$ to node $j$. Use the convention that seeding at node $A$ corresponds to an initial state vector $x(0)$ equal to the unit vector with $1$ at the index of node $A$ and $0$ elsewhere.\n- Use principles of linear time-invariant positive systems: nonnegative connectivity, superposition, and continuous-time evolution with a generator that yields nonnegative rates of change at each node proportional to nonnegative incoming connectivity and current states. From these principles, derive the minimal set of equations that govern a continuous-time linear spread consistent with propagation along directed edges. Do not assume or import any shortcut formulas; derive them.\n- Define a symmetrized adjacency $S$ by combining $A$ and its transpose via the standard undirected symmetrization rule $S = \\frac{1}{2}(A + A^\\top)$.\n- Define the staging time for each node $i$ as the earliest nonnegative time $t_i$ at which its state $x_i(t)$ reaches or exceeds a node-wise threshold $\\theta$. If $x_i(t)$ never reaches $\\theta$ within a specified finite time horizon $T_{\\max}$, assign $t_i = \\infty$.\n- All times are to be reported in arbitrary time units; no physical unit conversion is required.\n\nComputational requirements:\n- Implement the derived continuous-time model to compute $x(t)$ for both the directed case and the symmetrized case. Use an exact matrix solution method suitable for linear time-invariant systems with constant generators. For each node and each case, determine the threshold-crossing time via a robust numerical search on $[0, T_{\\max}]$ that respects monotonicity implied by positivity of the propagator on nonnegative initial conditions. Use a well-defined numerical stopping criterion.\n- Seeding is always at node $A$.\n- Return results for each test case as two lists of floats: first the list of threshold-crossing times under the directed model, then the list under the symmetrized model. The node order must match the order in which nodes are defined for the test case.\n- If a node never reaches threshold by $T_{\\max}$, encode its time as $\\infty$.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a pair of bracketed lists. For example, the structure should look like $[[\\dots,\\dots],[\\dots,\\dots],[\\dots,\\dots]]$, with no spaces. Floats must be printed with exactly six digits after the decimal point and $\\infty$ represented as the string $inf$.\n\nTest suite:\n- Test case $1$ (directed asymmetry with a strong incoming connection to the seed):\n  - Nodes and order: $[A,B,C,D,E]$.\n  - Directed edges and weights: $A \\to B$ with weight $0.6$, $B \\to C$ with weight $0.5$, $D \\to A$ with weight $1.2$, all other entries are $0.0$.\n  - Threshold $\\theta = 0.1$, rate constant $\\beta = 1.0$, horizon $T_{\\max} = 4.0$.\n  - Expectation: Under directed propagation, node $D$ is not early-involved when seeding at $A$ because $D$ only connects into $A$. Under symmetrization, the $D \\to A$ edge contributes an effective $A \\to D$ component, potentially reversing the early involvement order relative to $B$ and $C$.\n- Test case $2$ (bidirectional balance where directionality should not matter):\n  - Nodes and order: $[A,B,C]$.\n  - Directed edges and weights: $A \\leftrightarrow B$ both with weight $0.7$, $A \\leftrightarrow C$ both with weight $0.7$, all other entries are $0.0$.\n  - Threshold $\\theta = 0.2$, rate constant $\\beta = 1.0$, horizon $T_{\\max} = 3.0$.\n  - Expectation: Directed and symmetrized models yield identical staging due to inherent bidirectionality.\n- Test case $3$ (directionality reversal of early involvement):\n  - Nodes and order: $[A,B,C,D]$.\n  - Directed edges and weights: $A \\to B$ with weight $0.2$, $C \\to A$ with weight $1.0$, all other entries are $0.0$.\n  - Threshold $\\theta = 0.05$, rate constant $\\beta = 1.0$, horizon $T_{\\max} = 2.0$.\n  - Expectation: Under directed propagation seeded at $A$, node $C$ has no outgoing path from $A$ and is late or unreachable. Under symmetrization, $C$ and $A$ become connected in both directions with effective undirected weight, potentially making node $C$ earlier than node $B$ and thereby reversing the order of early involvement.\n\nAnswer type and aggregation:\n- For each test case, produce two lists of floats corresponding to $[t^{\\text{directed}}_A, \\dots]$ and $[t^{\\text{sym}}_A, \\dots]$ in the node order specified for that case.\n- Your program must produce a single line of output with the three test case results aggregated into one bracketed list, with no spaces, and each float printed with exactly six digits after the decimal point, and unreachable nodes printed as $inf$. For example: $[[t_{1,\\text{dir}},t_{1,\\text{sym}}],[t_{2,\\text{dir}},t_{2,\\text{sym}}],[t_{3,\\text{dir}},t_{3,\\text{sym}}]]$ where each $t_{\\cdot}$ is itself a list in the node order for that test.",
            "solution": "The problem requires the derivation and implementation of a continuous-time linear model for network degeneration, specifically to compare disease staging between a directed and a symmetrized brain network.\n\n### Principle-Based Model Derivation\n\nThe model describes the evolution of a pathology concentration, represented by a state vector $\\mathbf{x}(t) \\in \\mathbb{R}^N$, where $N$ is the number of brain regions (nodes) and $x_i(t)$ is the pathology concentration at node $i$ at time $t$. The derivation follows from first principles of linear time-invariant (LTI) positive systems.\n\n1.  **System Dynamics from First Principles**: The core modeling assumption is that the rate of change of pathology at a node is proportional to the pathology flowing in from connected nodes. The problem statement specifies that a \"generator yields nonnegative rates of change at each node proportional to nonnegative incoming connectivity and current states.\"\n\n    Let $A$ be the directed adjacency matrix, where $A_{ij} \\ge 0$ is the connection weight from node $i$ to node $j$. The incoming connection to node $i$ from node $j$ is therefore given by the weight $A_{ji}$.\n\n    The rate of change of pathology at node $i$, $\\dot{x}_i(t)$, is the sum of contributions from all other nodes. The contribution from node $j$ is proportional to its current state, $x_j(t)$, and the strength of the incoming connection from $j$ to $i$, which is $A_{ji}$. With a global rate constant $\\beta > 0$, this relationship is expressed as:\n    $$ \\dot{x}_i(t) = \\beta \\sum_{j=1}^{N} A_{ji} x_j(t) $$\n    This model adheres to the principle of \"nonnegative rates of change.\" Since $\\beta > 0$, $A_{ji} \\ge 0$, and we operate in a positive system where $x_j(t) \\ge 0$ for all $t \\ge 0$ (given $x_j(0) \\ge 0$), it follows that $\\dot{x}_i(t) \\ge 0$. This means the pathology concentration at any node is a non-decreasing function of time, representing a pure accumulation process. This interpretation is the most direct and minimal one consistent with all stipulations, ruling out other common network models like the graph Laplacian diffusion ($\\dot{\\mathbf{x}} = -\\beta L \\mathbf{x}$), which do not guarantee non-negative rates of change.\n\n2.  **Matrix Formulation**: The system of $N$ differential equations can be written in matrix form. Recognizing that the summation $\\sum_{j=1}^{N} A_{ji} x_j(t)$ is the $i$-th element of the matrix-vector product $A^\\top \\mathbf{x}(t)$, we obtain the LTI system:\n    $$ \\dot{\\mathbf{x}}(t) = \\beta A^\\top \\mathbf{x}(t) $$\n    The system's generator is $G = \\beta A^\\top$. A system is \"positive\" if its generator has non-negative off-diagonal elements. Here, for $i \\neq j$, the elements of $G$ are $G_{ij} = \\beta A_{ji} \\ge 0$, satisfying the positivity condition.\n\n3.  **Directed vs. Symmetrized Models**:\n    -   For the **directed model**, the generator is $G_{\\text{dir}} = \\beta A^\\top$.\n    -   For the **symmetrized model**, we first define the symmetrized adjacency matrix $S$ using the standard rule: $S = \\frac{1}{2}(A + A^\\top)$. The corresponding generator is derived by substituting $S$ for $A$ in the general form. As $S$ is symmetric ($S=S^\\top$), the generator is $G_{\\text{sym}} = \\beta S^\\top = \\beta S$.\n\n4.  **System Solution**: The solution to the LTI system $\\dot{\\mathbf{x}}(t) = G \\mathbf{x}(t)$ with initial condition $\\mathbf{x}(0)$ is given by the matrix exponential:\n    $$ \\mathbf{x}(t) = e^{tG} \\mathbf{x}(0) $$\n    Seeding pathology at a specific node (say, index $k$) corresponds to an initial state vector $\\mathbf{x}(0)$ being the standard basis vector $\\mathbf{e}_k$, which has a $1$ at index $k$ and $0$ elsewhere.\n\n### Staging Time Computation\n\nThe staging time $t_i$ for a node $i$ is the earliest time its state $x_i(t)$ reaches a threshold $\\theta$. This requires finding the root of the equation $f(t) = x_i(t) - \\theta = 0$.\n\n1.  **State Calculation**: The state of a single node $i$ at time $t$ is the $i$-th component of the state vector $\\mathbf{x}(t)$:\n    $$ x_i(t) = \\mathbf{e}_i^\\top \\mathbf{x}(t) = \\mathbf{e}_i^\\top e^{tG} \\mathbf{x}(0) $$\n    Computationally, we calculate the full vector $\\mathbf{x}(t)$ using a library function for the matrix exponential (e.g., `scipy.linalg.expm`) and then extract the $i$-th component.\n\n2.  **Numerical Search**: Since $x_i(t)$ is a monotonic, non-decreasing function, and the equation $x_i(t) = \\theta$ may not have a simple analytical solution, a numerical root-finding method is appropriate. The bisection method provides a robust approach.\n    -   **Initialization**: We search for $t_i$ in the interval $[0, T_{\\max}]$.\n    -   **Boundary Checks**:\n        -   If $x_i(0) \\ge \\theta$ (true for the seed node, as $\\theta < 1$), then $t_i = 0$.\n        -   If $x_i(T_{\\max}) < \\theta$, the threshold is not reached within the time horizon, so $t_i = \\infty$.\n    -   **Bisection Algorithm**: If a solution exists in $(0, T_{\\max}]$, we iteratively halve the search interval $[t_{low}, t_{high}]$. In each step, we compute $x_i(t_{mid})$ for $t_{mid} = (t_{low} + t_{high})/2$. If $x_i(t_{mid}) < \\theta$, the root is in $[t_{mid}, t_{high}]$; otherwise, it is in $[t_{low}, t_{mid}]$. This process is repeated for a fixed number of iterations (e.g., 100) to achieve sufficient precision. The final estimate for $t_i$ is the upper bound of the final interval, $t_{high}$.\n\nThis combined approach of principled model derivation and robust numerical solution allows for a direct comparison of staging times between the directed and symmetrized network representations, as required by the problem.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Derives, implements, and analyzes a network-based staging model for Alzheimer's disease.\n    Computes and compares threshold-crossing times for pathology spread on directed and\n    symmetrized networks.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"nodes\": ['A', 'B', 'C', 'D', 'E'],\n            \"edges\": {('A', 'B'): 0.6, ('B', 'C'): 0.5, ('D', 'A'): 1.2},\n            \"seed_node\": 'A',\n            \"theta\": 0.1,\n            \"beta\": 1.0,\n            \"T_max\": 4.0\n        },\n        {\n            \"nodes\": ['A', 'B', 'C'],\n            \"edges\": {('A', 'B'): 0.7, ('B', 'A'): 0.7, ('A', 'C'): 0.7, ('C', 'A'): 0.7},\n            \"seed_node\": 'A',\n            \"theta\": 0.2,\n            \"beta\": 1.0,\n            \"T_max\": 3.0\n        },\n        {\n            \"nodes\": ['A', 'B', 'C', 'D'],\n            \"edges\": {('A', 'B'): 0.2, ('C', 'A'): 1.0},\n            \"seed_node\": 'A',\n            \"theta\": 0.05,\n            \"beta\": 1.0,\n            \"T_max\": 2.0\n        }\n    ]\n\n    def compute_staging_times(G, x0, theta, T_max, n_nodes):\n        \"\"\"\n        Computes the threshold-crossing time for each node.\n        \n        Args:\n            G (np.ndarray): The system generator matrix.\n            x0 (np.ndarray): The initial state vector.\n            theta (float): The pathology threshold.\n            T_max (float): The maximum time horizon.\n            n_nodes (int): The number of nodes in the network.\n            \n        Returns:\n            list: A list of threshold-crossing times for each node.\n        \"\"\"\n        times = []\n        for i in range(n_nodes):\n            # Check if threshold is met or exceeded at t=0\n            if x0[i] >= theta:\n                times.append(0.0)\n                continue\n\n            # Define the function whose root we want to find: x_i(t) - theta = 0\n            def get_state_at_t(t):\n                if t == 0.0:\n                    return x0[i]\n                xt = expm(t * G) @ x0\n                return xt[i]\n\n            # Check if threshold is reached by T_max\n            if get_state_at_t(T_max) < theta:\n                times.append(float('inf'))\n                continue\n            \n            # Bisection search for the crossing time\n            t_low = 0.0\n            t_high = T_max\n            for _ in range(100):  # 100 iterations provides high precision\n                t_mid = (t_low + t_high) / 2\n                if get_state_at_t(t_mid) < theta:\n                    t_low = t_mid\n                else:\n                    t_high = t_mid\n            times.append(t_high)\n        return times\n\n    all_results = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        n_nodes = len(nodes)\n        node_map = {name: i for i, name in enumerate(nodes)}\n\n        # Build directed adjacency matrix A\n        A = np.zeros((n_nodes, n_nodes))\n        for (u, v), w in case[\"edges\"].items():\n            A[node_map[u], node_map[v]] = w\n\n        # Build symmetrized adjacency matrix S\n        S = 0.5 * (A + A.T)\n\n        # Get parameters\n        beta = case[\"beta\"]\n        theta = case[\"theta\"]\n        T_max = case[\"T_max\"]\n\n        # Set initial condition (seed)\n        x0 = np.zeros(n_nodes)\n        x0[node_map[case[\"seed_node\"]]] = 1.0\n\n        # Define generators\n        G_dir = beta * A.T\n        G_sym = beta * S  # S is symmetric, so S.T = S\n\n        # Compute staging times for both models\n        times_dir = compute_staging_times(G_dir, x0, theta, T_max, n_nodes)\n        times_sym = compute_staging_times(G_sym, x0, theta, T_max, n_nodes)\n\n        all_results.append([times_dir, times_sym])\n\n    # Format the output string\n    def format_times_list(times):\n        s_times = []\n        for t in times:\n            if t == float('inf'):\n                s_times.append('inf')\n            else:\n                s_times.append(f'{t:.6f}')\n        return '[' + ','.join(s_times) + ']'\n    \n    result_strings = []\n    for dir_list, sym_list in all_results:\n        result_strings.append(f'[{format_times_list(dir_list)},{format_times_list(sym_list)}]')\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "A powerful application of network degeneration models is their use in testing hypotheses against empirical data, such as the stereotyped progression of pathology described by Braak staging. This capstone exercise  places you in the role of a computational modeler, tasking you with finding the optimal model parameters that best reproduce a known staging sequence. By performing a systematic parameter search to maximize the correlation between your model's predictions and the target data, you will engage in the essential scientific practice of model fitting and validation.",
            "id": "3962311",
            "problem": "You are given a family of linear network degeneration models for Alzheimer’s disease that couples diffusive spread along a structural brain network with local clearance. The state vector is $\\mathbf{x}(t) \\in \\mathbb{R}^n$, where $x_i(t)$ denotes the predicted local pathology burden at region $i$ at time $t$. The structural network is encoded by a symmetric adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$ with nonnegative entries and zero diagonal, and the corresponding combinatorial graph Laplacian is $L = D - A$, where $D$ is the diagonal degree matrix with entries $D_{ii} = \\sum_{j=1}^n A_{ij}$. The dynamics are defined by the linear ordinary differential equation\n$$\n\\frac{d \\mathbf{x}(t)}{dt} = -\\lambda \\mathbf{x}(t) - \\kappa L \\mathbf{x}(t),\n$$\nwith initial condition $\\mathbf{x}(0) = \\mathbf{e}_s$, where $\\mathbf{e}_s$ is the unit vector that is $1$ at the seed index $s$ and $0$ elsewhere. Here $\\kappa \\ge 0$ quantifies the strength of diffusive propagation along the network and $\\lambda \\ge 0$ quantifies local clearance. For each region $i$, the predicted threshold-crossing time $T_i(\\kappa,\\lambda)$ is defined as the minimal $t \\ge 0$ such that $x_i(t) \\ge \\theta$ for a specified threshold $\\theta > 0$. If $x_i(t) < \\theta$ for all $t \\in [0, T_{\\max}]$, set $T_i(\\kappa,\\lambda) = T_{\\max} + \\Delta t$ to enforce a maximal finite rank. The ordering of Alzheimer’s disease progression can be represented by an integer-valued Braak stage order vector $\\mathbf{b} \\in \\{1,2,\\dots,n\\}^n$, where $b_i$ is the nominal stage index for region $i$.\n\nThe goal is, for each test case, to search over a discrete grid of $\\kappa$ and $\\lambda$ values and find the pair that maximizes the Kendall’s $\\tau_b$ rank correlation (use Kendall’s $\\tau_b$ that is robust to ties) between the predicted threshold-crossing times $\\{T_i(\\kappa,\\lambda)\\}_{i=1}^n$ and the Braak order $\\{b_i\\}_{i=1}^n$. In case of ties in the objective value, choose the solution with the smallest $\\lambda$; if a tie still remains, choose the one with the smallest $\\kappa$.\n\nFundamental base to be used:\n- The graph Laplacian $L = D - A$ for diffusion on networks.\n- The linear ordinary differential equation solution for time-invariant systems: if $d\\mathbf{x}/dt = B \\mathbf{x}$, then $\\mathbf{x}(t) = e^{Bt} \\mathbf{x}(0)$, where $e^{Bt}$ is the matrix exponential.\n- Kendall’s $\\tau_b$ rank correlation between two real-valued lists.\n\nCompute the threshold-crossing times by evaluating $\\mathbf{x}(t)$ on a uniform time grid $\\{0, \\Delta t, 2 \\Delta t, \\dots, T_{\\max}\\}$ and recording the first time that $x_i(t)$ exceeds the threshold. Use the closed-form solution\n$$\n\\mathbf{x}(t) = e^{-(\\lambda I + \\kappa L)t} \\mathbf{x}(0),\n$$\nand the eigendecomposition $L = V \\,\\mathrm{diag}(\\alpha_1,\\dots,\\alpha_n)\\, V^\\top$ with $V^\\top V = I$ to compute $\\mathbf{x}(t)$ efficiently as\n$$\n\\mathbf{x}(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right) V^\\top \\mathbf{x}(0).\n$$\n\nPhysical units: interpret $t$ as time in years, $\\lambda$ and $\\kappa$ as rates in $1/\\text{year}$, and $\\theta$ as a dimensionless threshold. When reporting the final best-fit parameters, express $\\kappa$ and $\\lambda$ as decimal floats in $1/\\text{year}$ rounded to six decimal places. Do not include unit strings in the output.\n\nAngle units: not applicable.\n\nPercentages: not applicable.\n\nTest suite:\n- Test case $1$ (chain network, “happy path”):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(1)} =\n    \\begin{pmatrix}\n    0 & 1 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 1 & 0 & 0 & 0 \\\\\n    0 & 1 & 0 & 1 & 0 & 0 \\\\\n    0 & 0 & 1 & 0 & 1 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 1 \\\\\n    0 & 0 & 0 & 0 & 1 & 0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$ (zero-based indexing in the implementation).\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(1)} = [1, 2, 3, 4, 5, 6]$.\n\n- Test case $2$ (star network, fast spread from a hub):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(2)} =\n    \\begin{pmatrix}\n    0 & 1 & 1 & 1 & 1 & 1 \\\\\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 0 & 0 & 0 & 0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$.\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(2)} = [1, 2, 3, 4, 5, 6]$.\n\n- Test case $3$ (partially disconnected network, edge case with non-crossing possibility):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(3)} =\n    \\begin{pmatrix}\n    0 & 1 & 0 & 0 & 0 & 0 \\\\\n    1 & 0 & 1 & 0 & 0 & 0 \\\\\n    0 & 1 & 0 & 0 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 1 & 0 \\\\\n    0 & 0 & 0 & 1 & 0 & 0 \\\\\n    0 & 0 & 0 & 0 & 0 & 0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$.\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(3)} = [1, 2, 3, 4, 5, 6]$.\n\nParameter search grid (discrete, to be used identically in all test cases):\n- Diffusion strengths: $\\kappa \\in \\{0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20\\}$.\n- Clearance rates: $\\lambda \\in \\{0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of three floats $[\\kappa^\\ast,\\lambda^\\ast,\\tau^\\ast]$ representing the best-fit diffusion strength in $1/\\text{year}$, the best-fit clearance rate in $1/\\text{year}$, and the maximized Kendall’s $\\tau$ value. All three floats must be rounded to six decimal places. For example, a valid output might look like\n$$\n[\\,[0.500000,0.100000,0.733333],\\,[0.800000,0.050000,0.600000],\\,[0.350000,0.150000,0.466667]\\,],\n$$\nbut with values computed from the specified test cases.",
            "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in established network diffusion models used in computational neuroscience, well-posed with a clear objective and constraints, and formulated with objective, unambiguous language. All necessary data and parameters are provided.\n\nThe problem requires finding the optimal parameters $(\\kappa, \\lambda)$ for a network-based model of Alzheimer's disease progression that best reproduce a given pathological staging order. The model describes the spread of pathology, represented by a concentration vector $\\mathbf{x}(t) \\in \\mathbb{R}^n$, over a structural brain network. The dynamics are governed by a linear ordinary differential equation (ODE):\n$$\n\\frac{d \\mathbf{x}(t)}{dt} = -\\lambda \\mathbf{x}(t) - \\kappa L \\mathbf{x}(t) = -(\\lambda I + \\kappa L) \\mathbf{x}(t)\n$$\nHere, $n$ is the number of brain regions. The parameter $\\kappa \\ge 0$ represents the rate of diffusive spread along the network's connections, and $\\lambda \\ge 0$ represents the rate of local clearance or decay of pathology. The network structure is encoded in the graph Laplacian $L = D - A$, where $A$ is the adjacency matrix and $D$ is the diagonal degree matrix. The system starts with a seed of pathology in a single region $s$, corresponding to the initial condition $\\mathbf{x}(0) = \\mathbf{e}_s$, where $\\mathbf{e}_s$ is the standard basis vector with a $1$ at index $s$ and $0$ elsewhere.\n\nThis is a time-invariant linear system, and its solution is given by the matrix exponential:\n$$\n\\mathbf{x}(t) = e^{-(\\lambda I + \\kappa L)t} \\mathbf{x}(0)\n$$\nTo compute this efficiently, we use the spectral properties of the symmetric graph Laplacian $L$. Let the eigendecomposition of $L$ be $L = V \\Lambda V^\\top$, where $\\Lambda = \\mathrm{diag}(\\alpha_1, \\dots, \\alpha_n)$ is the diagonal matrix of eigenvalues and $V$ is the orthogonal matrix of corresponding eigenvectors ($V^\\top V = I$). The solution can then be expressed as:\n$$\n\\mathbf{x}(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right)_{j=1}^n V^\\top \\mathbf{x}(0)\n$$\nThis formulation allows for rapid computation of the state vector $\\mathbf{x}(t)$ at any time $t$ once the eigendecomposition of $L$ is known.\n\nThe model's output is a set of predicted threshold-crossing times, $\\{T_i(\\kappa, \\lambda)\\}_{i=1}^n$. For each region $i$, $T_i$ is the earliest time $t \\ge 0$ at which its pathology level $x_i(t)$ reaches or exceeds a given threshold $\\theta$. Computationally, we evaluate $\\mathbf{x}(t)$ on a discrete time grid $t_k = k \\cdot \\Delta t$ for $k=0, 1, \\dots, T_{\\max}/\\Delta t$. The first time point $t_k$ where $x_i(t_k) \\ge \\theta$ is recorded as $T_i$. If the threshold is never reached within the time horizon $[0, T_{\\max}]$, a penalty value $T_i = T_{\\max} + \\Delta t$ is assigned to ensure a finite rank and distinguish these regions from those that cross late but within the horizon.\n\nThe objective is to find the parameter pair $(\\kappa, \\lambda)$ from a specified discrete grid that maximizes the concordance between the model-predicted progression order (given by the ranking of $T_i$ values) and an empirical pathological progression order, represented by the Braak stage vector $\\mathbf{b}$. This concordance is measured using Kendall's $\\tau_b$ rank correlation coefficient, which is suitable for data with tied ranks. Ties in crossing times are expected, particularly for symmetric regions or disconnected components.\n\nThe optimization procedure is a grid search. For each test case, we will perform the following steps:\n1.  Construct the adjacency matrix $A$ and the corresponding graph Laplacian $L$.\n2.  Compute the eigenvalues $\\alpha_j$ and eigenvectors $V$ of $L$.\n3.  Initialize the best parameter set $(\\kappa^\\ast, \\lambda^\\ast)$ and the maximum correlation $\\tau^\\ast = -2$ (a value lower than any possible $\\tau$).\n4.  Iterate through each pair of $(\\kappa, \\lambda)$ from their respective search grids.\n5.  For each $(\\kappa, \\lambda)$ pair:\n    a.  Compute the state vector evolution $x_i(t_k)$ for all regions $i$ and all time steps $t_k$ in the grid $[0, \\Delta t, \\dots, T_{\\max}]$.\n    b.  Determine the threshold-crossing time vector $T(\\kappa, \\lambda)$ by finding the first $t_k \\ge \\theta$ for each region.\n    c.  Calculate the Kendall's $\\tau_b$ correlation between the vector of crossing times $T(\\kappa, \\lambda)$ and the given Braak stage vector $\\mathbf{b}$.\n6.  Update the optimal parameters based on the computed $\\tau_b$ value. If the current $\\tau_b$ is greater than $\\tau^\\ast$, update $(\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast)$. If $\\tau_b$ is equal to $\\tau^\\ast$, apply the specified tie-breaking rule: choose the solution with the smaller $\\lambda$; if $\\lambda$ is also tied, choose the smaller $\\kappa$.\n\nThis full procedure is applied independently to each of the three test cases provided, each with its unique network structure and Braak staging. The final result for each test case is the triplet $[\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast]$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.stats import kendalltau\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Parameter search grids (identical for all test cases)\n    kappa_grid = [0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20]\n    lambda_grid = [0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80]\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 1, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        A = case[\"A\"]\n        s = case[\"s\"]\n        theta = case[\"theta\"]\n        T_max = case[\"T_max\"]\n        dt = case[\"dt\"]\n        b = case[\"b\"]\n\n        # 1. Construct Graph Laplacian L = D - A\n        D = np.diag(np.sum(A, axis=1))\n        L = D - A\n\n        # 2. Compute eigendecomposition of L\n        # eigh is used for symmetric matrices\n        eigenvalues, eigenvectors = eigh(L)\n        V = eigenvectors\n        V_T = V.T\n\n        # 3. Prepare initial condition and time grid\n        x0 = np.zeros(n)\n        x0[s] = 1.0\n        time_grid = np.arange(0, T_max + dt, dt)\n        \n        # Pre-compute part of the solution for efficiency\n        V_T_x0 = V_T @ x0\n\n        best_kappa = -1.0\n        best_lambda = -1.0\n        max_tau = -2.0  # Kendall's tau is in [-1, 1]\n\n        # 4. Grid search over kappa and lambda\n        for lambda_val in lambda_grid:\n            for kappa_val in kappa_grid:\n                \n                # 5a. Compute state vector evolution x(t)\n                exponent_diagonals = -(lambda_val + kappa_val * eigenvalues)\n                \n                # Create a matrix of x(t) values: rows are regions, columns are time steps\n                # x(t) = V @ diag(exp(exponent_diagonals*t)) @ V.T @ x0\n                # Efficient computation:\n                exp_term = np.exp(np.outer(exponent_diagonals, time_grid))\n                x_t = V @ (exp_term * V_T_x0[:, np.newaxis])\n\n                # 5b. Determine threshold-crossing times\n                crossing_times = np.full(n, T_max + dt)\n                # Find where pathology exceeds threshold\n                pathology_over_threshold = (x_t >= theta)\n                \n                for i in range(n):\n                    # Find the first time index where the threshold is crossed\n                    indices = np.where(pathology_over_threshold[i, :])[0]\n                    if len(indices) > 0:\n                        first_idx = indices[0]\n                        crossing_times[i] = time_grid[first_idx]\n                \n                # 5c. Calculate Kendall's tau\n                tau_result = kendalltau(crossing_times, b, variant='b')\n                current_tau = tau_result.correlation\n\n                # 6. Update best parameters based on tie-breaking rules\n                if current_tau > max_tau:\n                    max_tau = current_tau\n                    best_lambda = lambda_val\n                    best_kappa = kappa_val\n                elif current_tau == max_tau:\n                    if lambda_val < best_lambda:\n                        max_tau = current_tau\n                        best_lambda = lambda_val\n                        best_kappa = kappa_val\n                    elif lambda_val == best_lambda:\n                        if kappa_val < best_kappa:\n                            max_tau = current_tau\n                            best_lambda = lambda_val\n                            best_kappa = kappa_val\n\n        all_results.append([best_kappa, best_lambda, max_tau])\n\n    # Format the final output string as specified.\n    def format_result(res_list):\n        formatted_nums = [f\"{x:.6f}\" for x in res_list]\n        return f\"[{','.join(formatted_nums)}]\"\n\n    results_str = [format_result(r) for r in all_results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}