{
    "hands_on_practices": [
        {
            "introduction": "This first exercise grounds you in the fundamental mathematics of the linear network diffusion model. By solving for the model's dynamics on a simple three-region network, you will gain a concrete understanding of how network structure, represented by the graph Laplacian, governs the evolution of pathology. This practice () focuses on the crucial role of eigendecomposition in breaking down complex network dynamics into simpler, independent modes.",
            "id": "3962308",
            "problem": "Consider a linear network degeneration model for Alzheimer’s Disease (AD) pathology where the concentration vector $x(t) \\in \\mathbb{R}^{3}$ evolves on a three-region structural network governed by the ordinary differential equation\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\nwith diffusion strength $\\kappa  0$, uniform clearance rate $\\lambda  0$, graph Laplacian $L \\in \\mathbb{R}^{3 \\times 3}$, and identity matrix $I \\in \\mathbb{R}^{3 \\times 3}$. The three nodes correspond to the entorhinal cortex, hippocampus, and posterior cingulate, respectively. Assume the Laplacian is the symmetric path-graph Laplacian\n$$\nL = \\begin{pmatrix}\n1  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  1\n\\end{pmatrix},\n$$\nand the initial AD pathology concentration at time $t=0$ is\n$$\nx(0) = \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n$$\nin Standardized Uptake Value Ratio (SUVR) units. Let the biophysical parameters be $\\kappa = 0.5$ $\\text{year}^{-1}$, $\\lambda = 0.2$ $\\text{year}^{-1}$, and evaluate the state at time $t = 3$ years.\n\nStarting from the fundamental properties of symmetric matrices and linear time-invariant systems, derive the analytic solution via eigen-decomposition of the Laplacian and compute the state $x(t)$ at $t=3$ years. Express each component of the final state in SUVR units and round each component to four significant figures. Your final answer must be a single row vector.",
            "solution": "The model is a linear time-invariant system:\n$$\n\\frac{d}{dt}x(t) = -\\left( \\kappa L + \\lambda I \\right) x(t),\n$$\nwhere $L$ is symmetric. For symmetric matrices, there exists an orthonormal eigenbasis $U \\in \\mathbb{R}^{3 \\times 3}$ such that\n$$\nL = U \\Lambda U^{\\top},\n$$\nwhere $\\Lambda = \\operatorname{diag}(\\lambda_{0}, \\lambda_{1}, \\lambda_{2})$ contains the eigenvalues of $L$, and $U^{\\top}U = I$.\n\nDefine the modal coordinates $y(t) = U^{\\top} x(t)$. Substituting $x(t) = U y(t)$ into the differential equation yields\n$$\n\\frac{d}{dt}(U y(t)) = -\\left( \\kappa U \\Lambda U^{\\top} + \\lambda I \\right) U y(t).\n$$\nUsing $U^{\\top}U = I$ and left-multiplying by $U^{\\top}$,\n$$\n\\frac{d}{dt} y(t) = -\\left( \\kappa \\Lambda + \\lambda I \\right) y(t),\n$$\nwhich decouples into three scalar ordinary differential equations\n$$\n\\frac{d}{dt} y_{i}(t) = -\\left( \\kappa \\lambda_{i} + \\lambda \\right) y_{i}(t), \\quad i = 0,1,2.\n$$\nThese have solutions\n$$\ny_{i}(t) = \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) y_{i}(0).\n$$\nTransforming back to the original coordinates,\n$$\nx(t) = U y(t) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) y(0) = U \\exp\\!\\left( -(\\kappa \\Lambda + \\lambda I) t \\right) U^{\\top} x(0),\n$$\nwhich is the spectral form of the matrix exponential solution.\n\nWe now compute the eigen-decomposition of the given path-graph Laplacian\n$$\nL = \\begin{pmatrix}\n1  -1  0 \\\\\n-1  2  -1 \\\\\n0  -1  1\n\\end{pmatrix}.\n$$\nThe eigenvalues are known for the path graph of three nodes, or can be obtained by solving $\\det(L - \\mu I) = 0$, yielding\n$$\n\\lambda_{0} = 0, \\quad \\lambda_{1} = 1, \\quad \\lambda_{2} = 3.\n$$\nA corresponding set of orthonormal eigenvectors is\n$$\nv_{0} = \\frac{1}{\\sqrt{3}} \\begin{pmatrix} 1 \\\\ 1 \\\\ 1 \\end{pmatrix}, \\quad\nv_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 0 \\\\ -1 \\end{pmatrix}, \\quad\nv_{2} = \\frac{1}{\\sqrt{6}} \\begin{pmatrix} 1 \\\\ -2 \\\\ 1 \\end{pmatrix}.\n$$\nCollect these as columns of $U = [v_{0}\\; v_{1}\\; v_{2}]$.\n\nProject the initial condition into modal coordinates:\n$$\ny(0) = U^{\\top} x(0) = \\begin{pmatrix}\nv_{0}^{\\top} x(0) \\\\\nv_{1}^{\\top} x(0) \\\\\nv_{2}^{\\top} x(0)\n\\end{pmatrix}.\n$$\nCompute each component:\n- For $v_{0}$,\n$$\ny_{0}(0) = v_{0}^{\\top} x(0) = \\frac{1}{\\sqrt{3}} (1.0 + 0.3 + 0.1) = \\frac{1.4}{\\sqrt{3}}.\n$$\n- For $v_{1}$,\n$$\ny_{1}(0) = v_{1}^{\\top} x(0) = \\frac{1}{\\sqrt{2}} (1.0 - 0.1) = \\frac{0.9}{\\sqrt{2}}.\n$$\n- For $v_{2}$,\n$$\ny_{2}(0) = v_{2}^{\\top} x(0) = \\frac{1}{\\sqrt{6}} (1.0 - 2 \\cdot 0.3 + 0.1) = \\frac{0.5}{\\sqrt{6}}.\n$$\n\nWith $\\kappa = 0.5$ $\\text{year}^{-1}$, $\\lambda = 0.2$ $\\text{year}^{-1}$, and $t = 3$ $\\text{years}$, the modal decay factors are\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{0} + \\lambda) t \\right) = \\exp(-0.2 \\cdot 3) = \\exp(-0.6),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{1} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 1 + 0.2) \\cdot 3) = \\exp(-2.1),\n$$\n$$\n\\exp\\!\\left( -(\\kappa \\lambda_{2} + \\lambda) t \\right) = \\exp(-(0.5 \\cdot 3 + 0.2) \\cdot 3) = \\exp(-5.1).\n$$\nHence\n$$\ny(t) = \\begin{pmatrix}\n\\exp(-0.6)\\, \\frac{1.4}{\\sqrt{3}} \\\\\n\\exp(-2.1)\\, \\frac{0.9}{\\sqrt{2}} \\\\\n\\exp(-5.1)\\, \\frac{0.5}{\\sqrt{6}}\n\\end{pmatrix}.\n$$\nReconstruct $x(t)$ as\n$$\nx(t) = U y(t) = \\sum_{i=0}^{2} \\left[ \\exp\\!\\left( -(\\kappa \\lambda_{i} + \\lambda) t \\right) \\, y_{i}(0) \\, v_{i} \\right].\n$$\nFor numerical evaluation, it is convenient to use projection matrices $v_{i} v_{i}^{\\top}$ acting on $x(0)$. The contributions are:\n- For $v_{0}$,\n$$\nv_{0} v_{0}^{\\top} x(0) = \\frac{1}{3} \\begin{pmatrix} 1  1  1 \\\\ 1  1  1 \\\\ 1  1  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{3} \\begin{pmatrix} 1.4 \\\\ 1.4 \\\\ 1.4 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\\\ \\frac{1.4}{3} \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-0.6)$ gives the $v_{0}$-contribution to each component:\n$$\n\\exp(-0.6) \\cdot \\frac{1.4}{3} \\approx 0.5488116360940264 \\cdot 0.4666666666666667 \\approx 0.256112096843879.\n$$\n- For $v_{1}$,\n$$\nv_{1} v_{1}^{\\top} x(0) = \\frac{1}{2} \\begin{pmatrix} 1  0  -1 \\\\ 0  0  0 \\\\ -1  0  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{2} \\begin{pmatrix} 0.9 \\\\ 0 \\\\ -0.9 \\end{pmatrix}\n= \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-2.1)$ yields\n$$\n\\exp(-2.1) \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n\\approx 0.1224564282529819 \\cdot \\begin{pmatrix} 0.45 \\\\ 0 \\\\ -0.45 \\end{pmatrix}\n= \\begin{pmatrix} 0.055105392713841 \\\\ 0 \\\\ -0.055105392713841 \\end{pmatrix}.\n$$\n- For $v_{2}$,\n$$\nv_{2} v_{2}^{\\top} x(0) = \\frac{1}{6} \\begin{pmatrix} 1  -2  1 \\\\ -2  4  -2 \\\\ 1  -2  1 \\end{pmatrix} \\begin{pmatrix} 1.0 \\\\ 0.3 \\\\ 0.1 \\end{pmatrix}\n= \\frac{1}{6} \\begin{pmatrix} 0.5 \\\\ -1.0 \\\\ 0.5 \\end{pmatrix}\n= \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}.\n$$\nMultiplying by $\\exp(-5.1)$ gives\n$$\n\\exp(-5.1) \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n\\approx 0.00609678 \\cdot \\begin{pmatrix} \\frac{1}{12} \\\\ -\\frac{1}{6} \\\\ \\frac{1}{12} \\end{pmatrix}\n= \\begin{pmatrix} \\frac{0.00609678}{12} \\\\ -\\frac{0.00609678}{6} \\\\ \\frac{0.00609678}{12} \\end{pmatrix}\n\\approx \\begin{pmatrix} 0.000508065 \\\\ -0.001016130 \\\\ 0.000508065 \\end{pmatrix}.\n$$\n\nSumming the three contributions component-wise yields\n$$\nx_{1}(3) \\approx 0.256112096843879 + 0.055105392713841 + 0.000508065 \\approx 0.3117255547,\n$$\n$$\nx_{2}(3) \\approx 0.256112096843879 + 0 - 0.001016130 \\approx 0.2550959668,\n$$\n$$\nx_{3}(3) \\approx 0.256112096843879 - 0.055105392713841 + 0.000508065 \\approx 0.2015147692.\n$$\n\nRounded to four significant figures and expressed in Standardized Uptake Value Ratio (SUVR) units, the final state vector at $t = 3$ years is\n$$\n\\begin{pmatrix}\n0.3117  0.2551  0.2015\n\\end{pmatrix}.\n$$",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.3117  0.2551  0.2015 \\end{pmatrix}}$$"
        },
        {
            "introduction": "Moving from a single simulation to understanding general behavior, this practice explores the concept of a phase transition in disease spread. By implementing a linearized propagation model, you will derive and compute the basic reproduction number, $R_0$, a critical threshold that determines whether pathology will eventually die out or persist across the network. This exercise () connects the spectral properties of the network's connectivity matrix to the long-term fate of the disease, a cornerstone of epidemiological modeling.",
            "id": "3962354",
            "problem": "Consider a simplified networked propagation model of Alzheimer's disease (AD) pathology on a structural brain network. Let the network be represented by a real, symmetric, nonnegative adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$, where $A_{ij}$ quantifies the strength of anatomical connectivity between brain regions $i$ and $j$ (dimensionless). Pathology concentration across regions is represented by a vector $x(t) \\in \\mathbb{R}^n$. Assume a Susceptible-Infected-Susceptible (SIS) style linearized propagation near the disease-free state, where the per-edge spread rate is $\\beta$ (per day, units $\\text{day}^{-1}$) and the per-region clearance rate is $\\delta$ (per day, units $\\text{day}^{-1}$).\n\nStarting from fundamental linear stability analysis of the disease-free equilibrium, derive a decision criterion for whether pathology will die out or persist in terms of the largest eigenvalue of $A$ and the parameters $\\beta$ and $\\delta$. Identify the phase transition (critical threshold) and specify the corresponding critical parameter values that mark the boundary between die-out and persistence.\n\nThen, implement a program that, for each test case, computes:\n- The basic reproduction number $R_0$ associated with the largest linear mode of the networked system (dimensionless).\n- A boolean prediction indicating whether pathology will persist ($R_0$ strictly greater than $1$) or die out (otherwise).\n- The critical spread rate $\\beta_{\\mathrm{c}}$ (in $\\text{day}^{-1}$) at which the phase transition occurs for the given $A$ and $\\delta$.\n- The critical clearance rate $\\delta_{\\mathrm{c}}$ (in $\\text{day}^{-1}$) at which the phase transition occurs for the given $A$ and $\\beta$.\n\nAll floating-point outputs must be rounded to six decimal places. Units must be respected exactly as specified: $\\beta$ and $\\delta$ in $\\text{day}^{-1}$, and $R_0$ dimensionless. Angles do not appear in this problem. The prediction must be expressed as a boolean value $True$ or $False$ without quotation marks. The results for each test case must be returned as a list in the form $[R_0,\\mathrm{persist},\\beta_{\\mathrm{c}},\\delta_{\\mathrm{c}}]$, where $R_0$, $\\beta_{\\mathrm{c}}$, and $\\delta_{\\mathrm{c}}$ are floats rounded to six decimals, and $\\mathrm{persist}$ is a boolean.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result1,result2,result3]$), where each $resultk$ is itself a list in the exact form described above.\n\nUse the following test suite of scientifically plausible adjacency matrices and parameter sets, all consistent with an undirected anatomical network and per-day kinetics:\n\n- Test case $1$ (happy path, die-out expected):\n  $$A_1=\\begin{bmatrix} 0  1  0 \\\\ 1  0  1 \\\\ 0  1  0 \\end{bmatrix},\\quad \\beta=0.2\\ \\text{day}^{-1},\\quad \\delta=0.4\\ \\text{day}^{-1}.$$\n- Test case $2$ (happy path, persistence expected):\n  $$A_2=\\begin{bmatrix} 0  1  1 \\\\ 1  0  1 \\\\ 1  1  0 \\end{bmatrix},\\quad \\beta=0.6\\ \\text{day}^{-1},\\quad \\delta=1.0\\ \\text{day}^{-1}.$$\n- Test case $3$ (boundary condition, exactly critical):\n  $$A_2\\ \\text{as above},\\quad \\beta=0.5\\ \\text{day}^{-}^{-1}.$$\n- Test case $4$ (edge case, zero spread rate):\n  $$A_3=\\begin{bmatrix} 0  2  0 \\\\ 2  0  0 \\\\ 0  0  0 \\end{bmatrix},\\quad \\beta=0.0\\ \\text{day}^{-1},\\quad \\delta=0.3\\ \\text{day}^{-1}.$$\n\nIn all cases, treat $A$ as dimensionless connectivity weights. The final output must be a single line containing a top-level list with one item per test case, each item itself a list $[R_0,\\mathrm{persist},\\beta_{\\mathrm{c}},\\delta_{\\mathrm{c}}]$, with floats rounded to six decimals and the boolean strictly $True$ or $False$.",
            "solution": "The model for pathology concentration $x_i(t)$ in region $i$ is determined by a balance between local clearance and spread from connected neighbors. The dynamics for region $i$ are given by:\n$$\n\\frac{dx_i}{dt} = \\left( \\text{inflow from neighbors} \\right) - \\left( \\text{local clearance} \\right)\n$$\nThe clearance term is a first-order decay process, given by $-\\delta x_i$. The inflow, or spread, from neighbors is proportional to the pathology concentration $x_j$ in each neighboring region $j$, the connection strength $A_{ij}$, and the spread rate $\\beta$. Summing over all neighbors gives the total inflow as $\\beta \\sum_j A_{ij} x_j$. Combining these terms, the full system of $n$ coupled ordinary differential equations can be written in vector form:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\beta \\mathbf{A} \\mathbf{x} - \\delta \\mathbf{I} \\mathbf{x} = (\\beta \\mathbf{A} - \\delta \\mathbf{I}) \\mathbf{x}\n$$\nwhere $\\mathbf{x} = [x_1, \\dots, x_n]^\\top$ is the pathology vector, $\\mathbf{A}$ is the adjacency matrix, and $\\mathbf{I}$ is the identity matrix.\n\nThis is a linear time-invariant system. The stability of the disease-free equilibrium, $\\mathbf{x} = \\mathbf{0}$, is determined by the eigenvalues of the system's Jacobian matrix, $\\mathbf{J} = \\beta \\mathbf{A} - \\delta \\mathbf{I}$. The equilibrium is stable (pathology dies out) if all eigenvalues of $\\mathbf{J}$ have negative real parts. It is unstable (pathology persists and grows) if at least one eigenvalue has a positive real part.\n\nThe eigenvalues of $\\mathbf{J}$, denoted $\\mu_k$, are related to the eigenvalues of $\\mathbf{A}$, denoted $\\lambda_k^{(A)}$, by the relation $\\mu_k = \\beta \\lambda_k^{(A)} - \\delta$. Since the adjacency matrix $\\mathbf{A}$ is real, symmetric, and has non-negative entries, the Perron-Frobenius theorem guarantees that its largest eigenvalue, $\\lambda_{\\max}^{(A)}$, is real and non-negative. The stability of the entire system is governed by the largest eigenvalue of $\\mathbf{J}$, which corresponds to $\\lambda_{\\max}^{(A)}$:\n$$\n\\mu_{\\max} = \\beta \\lambda_{\\max}^{(A)} - \\delta\n$$\n-   **Persistence (Growth):** Pathology will persist and grow if $\\mu_{\\max} > 0$, which implies $\\beta \\lambda_{\\max}^{(A)} > \\delta$.\n-   **Die-out (Decay):** Pathology will die out if $\\mu_{\\max}  0$, which implies $\\beta \\lambda_{\\max}^{(A)}  \\delta$.\n-   **Phase Transition (Criticality):** The boundary between these two regimes occurs when $\\mu_{\\max} = 0$, which implies $\\beta \\lambda_{\\max}^{(A)} = \\delta$.\n\nThe **basic reproduction number, $R_0$**, is defined as the ratio of the production rate to the clearance rate for the system's most unstable mode. This corresponds to the ratio of the two terms in the criticality condition:\n$$\nR_0 = \\frac{\\beta \\lambda_{\\max}^{(A)}}{\\delta}\n$$\nThe system exhibits persistence if $R_0 > 1$ and dies out if $R_0 \\le 1$. The problem specifies persistence only if $R_0$ is *strictly* greater than $1$.\n\nFrom the criticality condition $\\beta \\lambda_{\\max}^{(A)} = \\delta$, we can derive the critical parameter values:\n-   The **critical spread rate, $\\beta_c$**, is the value of $\\beta$ that makes the system critical for a given $\\delta$ and $\\mathbf{A}$. Solving for $\\beta_c$ gives:\n    $$ \\beta_c = \\frac{\\delta}{\\lambda_{\\max}^{(A)}} $$\n-   The **critical clearance rate, $\\delta_c$**, is the value of $\\delta$ that makes the system critical for a given $\\beta$ and $\\mathbf{A}$. Solving for $\\delta_c$ gives:\n    $$ \\delta_c = \\beta \\lambda_{\\max}^{(A)} $$\n\nThe computational task for each test case is to:\n1.  Numerically compute the largest eigenvalue, $\\lambda_{\\max}^{(A)}$, of the given matrix $\\mathbf{A}$.\n2.  Use the given $\\beta$ and $\\delta$ to calculate $R_0$, $\\beta_c$, and $\\delta_c$ using the formulas above.\n3.  Determine the boolean persistence flag by checking if $R_0 > 1$.\n4.  Format the results as a list: $[R_0, \\text{persist}, \\beta_c, \\delta_c]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Alzheimer's network degeneration model problem for a given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        (np.array([[0.0, 1.0, 0.0], [1.0, 0.0, 1.0], [0.0, 1.0, 0.0]], dtype=float), 0.2, 0.4),\n        # Test case 2\n        (np.array([[0.0, 1.0, 1.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.0]], dtype=float), 0.6, 1.0),\n        # Test case 3\n        (np.array([[0.0, 1.0, 1.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.0]], dtype=float), 0.5, 1.0),\n        # Test case 4\n        (np.array([[0.0, 2.0, 0.0], [2.0, 0.0, 0.0], [0.0, 0.0, 0.0]], dtype=float), 0.0, 0.3)\n    ]\n\n    all_results = []\n    for A, beta, delta in test_cases:\n        # Step 1: Compute the largest eigenvalue of the adjacency matrix A.\n        # Since A is specified as real and symmetric, np.linalg.eigvalsh is efficient\n        # and guarantees real eigenvalues.\n        eigenvalues = np.linalg.eigvalsh(A)\n        lambda_max_A = np.max(eigenvalues)\n\n        # Step 2: Compute the basic reproduction number R0.\n        # R0 = (beta * lambda_max_A) / delta\n        # A check for delta == 0 is good practice, though not required by the test cases.\n        if delta == 0.0:\n            # If delta is 0, any spread leads to infinite R0 if beta*lambda_max_A > 0.\n            # If beta*lambda_max_A is also 0, R0 is taken as 0.\n            R0 = float('inf') if beta * lambda_max_A > 0.0 else 0.0\n        else:\n            R0 = (beta * lambda_max_A) / delta\n\n        # Step 3: Determine the persistence prediction.\n        # Pathology persists if R0 is strictly greater than 1.\n        persist = R0 > 1.0\n\n        # Step 4: Compute the critical spread rate beta_c.\n        # beta_c = delta / lambda_max_A\n        # A check for lambda_max_A == 0 is good practice for generality.\n        # This occurs for a network with no connections (zero matrix).\n        if lambda_max_A == 0.0:\n            # If lambda_max_A is 0, no finite spread rate can overcome clearance.\n            beta_c = float('inf') if delta > 0.0 else 0.0\n        else:\n            beta_c = delta / lambda_max_A\n\n        # Step 5: Compute the critical clearance rate delta_c.\n        # delta_c = beta * lambda_max_A\n        delta_c = beta * lambda_max_A\n        \n        # Step 6: Round all floating-point results to six decimal places.\n        R0_rounded = round(R0, 6)\n        beta_c_rounded = round(beta_c, 6)\n        delta_c_rounded = round(delta_c, 6)\n\n        # Step 7: Assemble the results for the current test case.\n        case_result = [R0_rounded, persist, beta_c_rounded, delta_c_rounded]\n        all_results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The str() function correctly formats the inner lists, including the boolean.\n    # 'map' applies str() to each sublist, and 'join' creates the comma-separated string.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "This final practice bridges theory and application by fitting a network model to empirical data. You will optimize the parameters of the linear diffusion model to best replicate the well-known pathological staging sequence of Alzheimer's disease, known as the Braak stages. This exercise () simulates a core task in computational neuroscience: using models to explain real-world data patterns and estimate underlying biophysical parameters.",
            "id": "3962311",
            "problem": "You are given a family of linear network degeneration models for Alzheimer’s disease that couples diffusive spread along a structural brain network with local clearance. The state vector is $x(t) \\in \\mathbb{R}^n$, where $x_i(t)$ denotes the predicted local pathology burden at region $i$ at time $t$. The structural network is encoded by a symmetric adjacency matrix $A \\in \\mathbb{R}^{n \\times n}$ with nonnegative entries and zero diagonal, and the corresponding combinatorial graph Laplacian is $L = D - A$, where $D$ is the diagonal degree matrix with entries $D_{ii} = \\sum_{j=1}^n A_{ij}$. The dynamics are defined by the linear ordinary differential equation\n$$\n\\frac{d x(t)}{dt} = -\\lambda x(t) - \\kappa L x(t),\n$$\nwith initial condition $x(0) = e_s$, where $e_s$ is the unit vector that is $1$ at the seed index $s$ and $0$ elsewhere. Here $\\kappa \\ge 0$ quantifies the strength of diffusive propagation along the network and $\\lambda \\ge 0$ quantifies local clearance. For each region $i$, the predicted threshold-crossing time $T_i(\\kappa,\\lambda)$ is defined as the minimal $t \\ge 0$ such that $x_i(t) \\ge \\theta$ for a specified threshold $\\theta  0$. If $x_i(t)  \\theta$ for all $t \\in [0, T_{\\max}]$, set $T_i(\\kappa,\\lambda) = T_{\\max} + \\Delta t$ to enforce a maximal finite rank. The ordering of Alzheimer’s disease progression can be represented by an integer-valued Braak stage order vector $b \\in \\{1,2,\\dots,n\\}^n$, where $b_i$ is the nominal stage index for region $i$.\n\nThe goal is, for each test case, to search over a discrete grid of $\\kappa$ and $\\lambda$ values and find the pair that maximizes the Kendall’s $\\tau$ rank correlation (use Kendall’s $\\tau_b$ that is robust to ties) between the predicted threshold-crossing times $\\{T_i(\\kappa,\\lambda)\\}_{i=1}^n$ and the Braak order $\\{b_i\\}_{i=1}^n$. In case of ties in the objective value, choose the solution with the smallest $\\lambda$; if a tie still remains, choose the one with the smallest $\\kappa$.\n\nFundamental base to be used:\n- The graph Laplacian $L = D - A$ for diffusion on networks.\n- The linear ordinary differential equation solution for time-invariant systems: if $\\frac{dx}{dt} = B x$, then $x(t) = e^{Bt} x(0)$, where $e^{Bt}$ is the matrix exponential.\n- Kendall’s $\\tau$ rank correlation $\\tau_b$ between two real-valued lists.\n\nCompute the threshold-crossing times by evaluating $x(t)$ on a uniform time grid $\\{0, \\Delta t, 2 \\Delta t, \\dots, T_{\\max}\\}$ and recording the first time that $x_i(t)$ exceeds the threshold. Use the closed-form solution\n$$\nx(t) = e^{-(\\lambda I + \\kappa L)t} x(0),\n$$\nand the eigendecomposition $L = V \\,\\mathrm{diag}(\\alpha_1,\\dots,\\alpha_n)\\, V^\\top$ with $V^\\top V = I$ to compute $x(t)$ efficiently as\n$$\nx(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right) V^\\top x(0).\n$$\n\nPhysical units: interpret $t$ as time in years, $\\lambda$ and $\\kappa$ as rates in $1/\\text{year}$, and $\\theta$ as a dimensionless threshold. When reporting the final best-fit parameters, express $\\kappa$ and $\\lambda$ as decimal floats in $1/\\text{year}$ rounded to six decimal places. Do not include unit strings in the output.\n\nAngle units: not applicable.\n\nPercentages: not applicable.\n\nTest suite:\n- Test case $1$ (chain network, “happy path”):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(1)} =\n    \\begin{pmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  1  0  0 \\\\\n    0  0  1  0  1  0 \\\\\n    0  0  0  1  0  1 \\\\\n    0  0  0  0  1  0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$ (zero-based indexing in the implementation).\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(1)} = [1, 2, 3, 4, 5, 6]$.\n\n- Test case $2$ (star network, fast spread from a hub):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(2)} =\n    \\begin{pmatrix}\n    0  1  1  1  1  1 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0 \\\\\n    1  0  0  0  0  0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$.\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(2)} = [1, 2, 3, 4, 5, 6]$.\n\n- Test case $3$ (partially disconnected network, edge case with non-crossing possibility):\n  - Number of regions: $n = 6$.\n  - Adjacency:\n    $$\n    A^{(3)} =\n    \\begin{pmatrix}\n    0  1  0  0  0  0 \\\\\n    1  0  1  0  0  0 \\\\\n    0  1  0  0  0  0 \\\\\n    0  0  0  0  1  0 \\\\\n    0  0  0  1  0  0 \\\\\n    0  0  0  0  0  0\n    \\end{pmatrix}.\n    $$\n  - Seed index: $s = 0$.\n  - Threshold: $\\theta = 0.02$.\n  - Time horizon: $T_{\\max} = 30$ years.\n  - Time step: $\\Delta t = 0.1$ years.\n  - Braak stage order: $b^{(3)} = [1, 2, 3, 4, 5, 6]$.\n\nParameter search grid (discrete, to be used identically in all test cases):\n- Diffusion strengths: $\\kappa \\in \\{0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20\\}$.\n- Clearance rates: $\\lambda \\in \\{0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a list of three floats $[\\kappa^\\ast,\\lambda^\\ast,\\tau^\\ast]$ representing the best-fit diffusion strength in $1/\\text{year}$, the best-fit clearance rate in $1/\\text{year}$, and the maximized Kendall’s $\\tau$ value. All three floats must be rounded to six decimal places. For example, a valid output might look like\n$$\n[\\,[0.500000,0.100000,0.733333],\\,[0.800000,0.050000,0.600000],\\,[0.350000,0.150000,0.466667]\\,],\n$$\nbut with values computed from the specified test cases.",
            "solution": "The problem has been validated and is deemed sound. It is scientifically grounded in established network diffusion models used in computational neuroscience, well-posed with a clear objective and constraints, and formulated with objective, unambiguous language. All necessary data and parameters are provided.\n\nThe problem requires finding the optimal parameters $(\\kappa, \\lambda)$ for a network-based model of Alzheimer's disease progression that best reproduce a given pathological staging order. The model describes the spread of pathology, represented by a concentration vector $x(t) \\in \\mathbb{R}^n$, over a structural brain network. The dynamics are governed by a linear ordinary differential equation (ODE):\n$$\n\\frac{d x(t)}{dt} = -\\lambda x(t) - \\kappa L x(t) = -(\\lambda I + \\kappa L) x(t)\n$$\nHere, $n$ is the number of brain regions. The parameter $\\kappa \\ge 0$ represents the rate of diffusive spread along the network's connections, and $\\lambda \\ge 0$ represents the rate of local clearance or decay of pathology. The network structure is encoded in the graph Laplacian $L = D - A$, where $A$ is the adjacency matrix and $D$ is the diagonal degree matrix. The system starts with a seed of pathology in a single region $s$, corresponding to the initial condition $x(0) = e_s$, where $e_s$ is the standard basis vector with a $1$ at index $s$ and $0$ elsewhere.\n\nThis is a time-invariant linear system, and its solution is given by the matrix exponential:\n$$\nx(t) = e^{-(\\lambda I + \\kappa L)t} x(0)\n$$\nTo compute this efficiently, we use the spectral properties of the symmetric graph Laplacian $L$. Let the eigendecomposition of $L$ be $L = V \\Lambda V^\\top$, where $\\Lambda = \\mathrm{diag}(\\alpha_1, \\dots, \\alpha_n)$ is the diagonal matrix of eigenvalues and $V$ is the orthogonal matrix of corresponding eigenvectors ($V^\\top V = I$). The solution can then be expressed as:\n$$\nx(t) = V \\,\\mathrm{diag}\\left(e^{-(\\lambda + \\kappa \\alpha_j) t}\\right)_{j=1}^n V^\\top x(0)\n$$\nThis formulation allows for rapid computation of the state vector $x(t)$ at any time $t$ once the eigendecomposition of $L$ is known.\n\nThe model's output is a set of predicted threshold-crossing times, $\\{T_i(\\kappa, \\lambda)\\}_{i=1}^n$. For each region $i$, $T_i$ is the earliest time $t \\ge 0$ at which its pathology level $x_i(t)$ reaches or exceeds a given threshold $\\theta$. Computationally, we evaluate $x(t)$ on a discrete time grid $t_k = k \\cdot \\Delta t$ for $k=0, 1, \\dots, T_{\\max}/\\Delta t$. The first time point $t_k$ where $x_i(t_k) \\ge \\theta$ is recorded as $T_i$. If the threshold is never reached within the time horizon $[0, T_{\\max}]$, a penalty value $T_i = T_{\\max} + \\Delta t$ is assigned to ensure a finite rank and distinguish these regions from those that cross late but within the horizon.\n\nThe objective is to find the parameter pair $(\\kappa, \\lambda)$ from a specified discrete grid that maximizes the concordance between the model-predicted progression order (given by the ranking of $T_i$ values) and an empirical pathological progression order, represented by the Braak stage vector $b$. This concordance is measured using Kendall's $\\tau_b$ rank correlation coefficient, which is suitable for data with tied ranks. Ties in crossing times are expected, particularly for symmetric regions or disconnected components.\n\nThe optimization procedure is a grid search. For each test case, we will perform the following steps:\n1.  Construct the adjacency matrix $A$ and the corresponding graph Laplacian $L$.\n2.  Compute the eigenvalues $\\alpha_j$ and eigenvectors $V$ of $L$.\n3.  Initialize the best parameter set $(\\kappa^\\ast, \\lambda^\\ast)$ and the maximum correlation $\\tau^\\ast = -2$ (a value lower than any possible $\\tau$).\n4.  Iterate through each pair of $(\\kappa, \\lambda)$ from their respective search grids.\n5.  For each $(\\kappa, \\lambda)$ pair:\n    a.  Compute the state vector evolution $x_i(t_k)$ for all regions $i$ and all time steps $t_k$ in the grid $[0, \\Delta t, \\dots, T_{\\max}]$.\n    b.  Determine the threshold-crossing time vector $T(\\kappa, \\lambda)$ by finding the first $t_k \\ge \\theta$ for each region.\n    c.  Calculate the Kendall's $\\tau_b$ correlation between the vector of crossing times $T(\\kappa, \\lambda)$ and the given Braak stage vector $b$.\n6.  Update the optimal parameters based on the computed $\\tau_b$ value. If the current $\\tau_b$ is greater than $\\tau^\\ast$, update $(\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast)$. If $\\tau_b$ is equal to $\\tau^\\ast$, apply the specified tie-breaking rule: choose the solution with the smaller $\\lambda$; if $\\lambda$ is also tied, choose the smaller $\\kappa$.\n\nThis full procedure is applied independently to each of the three test cases provided, each with its unique network structure and Braak staging. The final result for each test case is the triplet $[\\kappa^\\ast, \\lambda^\\ast, \\tau^\\ast]$.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh\nfrom scipy.stats import kendalltau\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    # Parameter search grids (identical for all test cases)\n    kappa_grid = [0.05, 0.10, 0.20, 0.35, 0.50, 0.80, 1.20]\n    lambda_grid = [0.02, 0.05, 0.10, 0.15, 0.25, 0.40, 0.80]\n\n    # Test cases defined in the problem statement.\n    test_cases = [\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 1, 0, 0],\n                [0, 0, 1, 0, 1, 0],\n                [0, 0, 0, 1, 0, 1],\n                [0, 0, 0, 0, 1, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 1, 1, 1, 1],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0],\n                [1, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        },\n        {\n            \"n\": 6,\n            \"A\": np.array([\n                [0, 1, 0, 0, 0, 0],\n                [1, 0, 1, 0, 0, 0],\n                [0, 1, 0, 0, 0, 0],\n                [0, 0, 0, 0, 1, 0],\n                [0, 0, 0, 1, 0, 0],\n                [0, 0, 0, 0, 0, 0]\n            ]),\n            \"s\": 0,\n            \"theta\": 0.02,\n            \"T_max\": 30.0,\n            \"dt\": 0.1,\n            \"b\": np.array([1, 2, 3, 4, 5, 6]),\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        n = case[\"n\"]\n        A = case[\"A\"]\n        s = case[\"s\"]\n        theta = case[\"theta\"]\n        T_max = case[\"T_max\"]\n        dt = case[\"dt\"]\n        b = case[\"b\"]\n\n        # 1. Construct Graph Laplacian L = D - A\n        D = np.diag(np.sum(A, axis=1))\n        L = D - A\n\n        # 2. Compute eigendecomposition of L\n        # eigh is used for symmetric matrices\n        eigenvalues, eigenvectors = eigh(L)\n        V = eigenvectors\n        V_T = V.T\n\n        # 3. Prepare initial condition and time grid\n        x0 = np.zeros(n)\n        x0[s] = 1.0\n        time_grid = np.arange(0, T_max + dt, dt)\n        \n        # Pre-compute part of the solution for efficiency\n        V_T_x0 = V_T @ x0\n\n        best_kappa = -1.0\n        best_lambda = -1.0\n        max_tau = -2.0  # Kendall's tau is in [-1, 1]\n\n        # 4. Grid search over kappa and lambda\n        for lambda_val in lambda_grid:\n            for kappa_val in kappa_grid:\n                \n                # 5a. Compute state vector evolution x(t)\n                exponent_diagonals = -(lambda_val + kappa_val * eigenvalues)\n                \n                # Create a matrix of x(t) values: rows are regions, columns are time steps\n                # x(t) = V @ diag(exp(exponent_diagonals*t)) @ V.T @ x0\n                # Efficient computation:\n                exp_term = np.exp(np.outer(exponent_diagonals, time_grid))\n                x_t = V @ (exp_term * V_T_x0[:, np.newaxis])\n\n                # 5b. Determine threshold-crossing times\n                crossing_times = np.full(n, T_max + dt)\n                # Find where pathology exceeds threshold\n                pathology_over_threshold = (x_t >= theta)\n                \n                for i in range(n):\n                    # Find the first time index where the threshold is crossed\n                    indices = np.where(pathology_over_threshold[i, :])[0]\n                    if len(indices) > 0:\n                        first_idx = indices[0]\n                        crossing_times[i] = time_grid[first_idx]\n                \n                # 5c. Calculate Kendall's tau\n                tau_result = kendalltau(crossing_times, b, variant='b')\n                current_tau = tau_result.correlation\n\n                # 6. Update best parameters based on tie-breaking rules\n                if current_tau > max_tau:\n                    max_tau = current_tau\n                    best_lambda = lambda_val\n                    best_kappa = kappa_val\n                elif current_tau == max_tau:\n                    if lambda_val  best_lambda:\n                        max_tau = current_tau\n                        best_lambda = lambda_val\n                        best_kappa = kappa_val\n                    elif lambda_val == best_lambda:\n                        if kappa_val  best_kappa:\n                            max_tau = current_tau\n                            best_lambda = lambda_val\n                            best_kappa = kappa_val\n\n        all_results.append([best_kappa, best_lambda, max_tau])\n\n    # Format the final output string as specified.\n    def format_result(res_list):\n        formatted_nums = [f\"{x:.6f}\" for x in res_list]\n        return f\"[{','.join(formatted_nums)}]\"\n\n    results_str = [format_result(r) for r in all_results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n\n```"
        }
    ]
}