{
    "hands_on_practices": [
        {
            "introduction": "本练习是理解LATER模型的核心。LATER模型的一个关键预测是，反应时间数据的倒数在经过特定变换后（reciprobit图）应呈现为一条直线。 这个练习将引导你推导这条直线的斜率，并探索它如何随着决策阈值 $S$ 的变化而变化，从而在数学上建立起认知策略（如速度-准确率权衡）与可观测数据特征之间的直接联系。",
            "id": "4012834",
            "problem": "考虑反应时间的具有遍历速率的线性阈值逼近 (LATER) 模型。在该模型中，一个决策信号从初始水平 $S_{0}$ 开始，以随机速率 $r$ 线性上升，直至达到决策阈值 $S$。\n\n假设在每次试验中，$r$ 独立地从一个均值为 $\\mu$、标准差为 $\\sigma$ 的正态（高斯）分布中抽取，并且测得的反应时间 (RT) 由公式 $T = (S - S_{0})/r$ 给出，没有附加的非决策部分。reciprobit表示法将延迟的倒数 $x = 1/T$ 作为横轴，将累积概率的概率单位（probit，即正态累积分布的反函数）作为纵轴。在这种表示法中，$x$ 的累积分布被映射为一条直线。\n\n从这些定义出发，推导reciprobit斜率作为 $S$、$S_{0}$ 和 $\\sigma$ 的函数的通用表达式。然后，假设 $S$ 翻倍至 $2S$，而 $S_{0}$、$\\mu$ 和 $\\sigma$ 保持不变。计算reciprobit斜率的倍数变化（即新斜率与原斜率的比值），并根据LATER模型所蕴含的速度-准确率权衡来解释这个结果。\n\n请以斜率比值的单个闭式解析表达式形式给出您的最终答案。所求比值为无量纲，因此不需要单位。无需四舍五入。",
            "solution": "用户希望我解决一个与计算神经科学中的LATER模型相关的问题。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n-   模型：反应时间的具有遍历速率的线性阈值逼近 (LATER) 模型。\n-   决策信号从初始水平 $S_{0}$ 开始。\n-   信号线性上升至决策阈值 $S$。\n-   上升速率 $r$ 是一个随机变量。\n-   $r$ 的分布是正态（高斯）分布，均值为 $\\mu$，标准差为 $\\sigma$，即 $r \\sim N(\\mu, \\sigma^2)$。\n-   反应时间 (RT) 由公式 $T = (S - S_{0})/r$ 给出。\n-   非决策时间为零。\n-   Reciprobit表示法：$z$ 对 $x$ 的图，其中：\n    -   横轴：延迟的倒数， $x = 1/T$。\n    -   纵轴：累积概率的概率单位（probit），$z = \\Phi^{-1}(P(X \\le x))$，其中 $\\Phi$ 是标准正态累积分布函数 (CDF)。\n-   前提：在这种表示法中，$x$ 的累积分布映射为一条直线。\n-   任务1：推导reciprobit斜率作为 $S$、$S_{0}$ 和 $\\sigma$ 的函数的通用表达式。\n-   任务2：假设 $S$ 翻倍至 $2S$，而 $S_{0}$、$\\mu$ 和 $\\sigma$ 保持不变。计算reciprobit斜率的倍数变化（比率）。\n-   任务3：根据速度-准确率权衡来解释这个结果。\n\n**步骤2：使用提取的已知条件进行验证**\n-   **科学依据**：LATER模型是计算神经科学中用于分析反应时间的一个标准且成熟的模型。模型各组成部分（阈值、速率）的定义以及reciprobit图在该领域都是标准的。该问题具有科学依据。\n-   **适定性**：该问题要求基于所提供的模型定义进行推导和计算。正如解题过程所示，reciprobit图是一条直线的前提是模型假设的直接数学结果。这证实了问题的内部一致性。目标明确，并能导出一个唯一解。该问题是适定的。\n-   **客观性**：该问题以精确、客观的数学语言陈述，没有主观性论断。\n-   **完整性与一致性**：所有必要的定义和参数（$S_0, S, r, \\mu, \\sigma, T, x, z$）都已提供。没有矛盾之处。速率 $r$ 服从正态分布的假设理论上可能导致非物理的负速率，但这在该模型中是一个标准的理想化处理，在 $\\mu \\gg \\sigma$ 的假设下有效，这使得 $r \\le 0$ 的概率可以忽略不计。这种理想化处理并不会使问题无效，因为它是被测试模型的一个核心特征。\n-   **其他缺陷**：该问题并非无足轻重、非隐喻性或超出科学验证的范畴。它是竞赛模型主题下的一个标准推导。\n\n**步骤3：结论与行动**\n该问题有效。我将继续进行解答。\n\n**解题过程**\n\n该问题要求推导LATER模型的reciprobit斜率，并分析当决策阈值改变时该斜率如何变化。\n\n首先，我们定义关键量。达到阈值所需的决策信号变化量为 $\\Delta S = S - S_{0}$。反应时间 $T$ 由下式给出：\n$$T = \\frac{\\Delta S}{r} = \\frac{S - S_{0}}{r}$$\n分析在reciprobit空间中进行，该空间使用延迟的倒数 $x$作为横轴。\n$$x = \\frac{1}{T} = \\frac{r}{S - S_{0}}$$\n上升速率 $r$ 是一个随机变量，服从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布：\n$$r \\sim N(\\mu, \\sigma^2)$$\n由于 $x$ 是正态分布随机变量 $r$ 的线性变换（即 $x = a \\cdot r$，其中对于任何给定的试验，$a = 1/(S-S_0)$ 是一个常数），$x$ 也是一个服从正态分布的随机变量。我们可以如下求出它的均值 $\\mu_x$ 和标准差 $\\sigma_x$：\n$x$ 的均值为：\n$$\\mu_x = E[x] = E\\left[\\frac{r}{S - S_{0}}\\right] = \\frac{E[r]}{S - S_{0}} = \\frac{\\mu}{S - S_{0}}$$\n$x$ 的方差为：\n$$\\sigma_x^2 = \\text{Var}(x) = \\text{Var}\\left(\\frac{r}{S - S_{0}}\\right) = \\frac{\\text{Var}(r)}{(S - S_{0})^2} = \\frac{\\sigma^2}{(S - S_{0})^2}$$\n因此，$x$ 的标准差为：\n$$\\sigma_x = \\sqrt{\\frac{\\sigma^2}{(S - S_{0})^2}} = \\frac{\\sigma}{|S - S_{0}|}$$\n由于决策信号是上升至阈值，我们必须有 $S > S_{0}$，所以 $|S - S_{0}| = S - S_{0}$。因此：\n$$\\sigma_x = \\frac{\\sigma}{S - S_{0}}$$\n所以，倒数延迟的分布为 $x \\sim N(\\mu_x, \\sigma_x^2)$。\n\nReciprobit图在纵轴上显示累积概率的概率单位（probit）$z = \\Phi^{-1}(P(X \\le x))$，横轴为倒数延迟 $x$。这里，$\\Phi^{-1}$ 是标准正态累积分布函数 (CDF) 的反函数，也称为概率单位函数。\n\n对于服从正态分布的变量 $x \\sim N(\\mu_x, \\sigma_x^2)$，其累积概率由下式给出：\n$$P(X \\le x) = \\Phi\\left(\\frac{x - \\mu_x}{\\sigma_x}\\right)$$\n将此代入纵轴变量 $z$ 的定义中：\n$$z = \\Phi^{-1}\\left( \\Phi\\left(\\frac{x - \\mu_x}{\\sigma_x}\\right) \\right) = \\frac{x - \\mu_x}{\\sigma_x}$$\n这个方程可以重排成直线标准形式 $z = mx + c$：\n$$z = \\left(\\frac{1}{\\sigma_x}\\right) x - \\frac{\\mu_x}{\\sigma_x}$$\n这证实了问题的前提，即reciprobit图是一条直线。这条线的斜率，我们称之为 $m_{\\text{recip}}$，是 $x$ 的系数。\n\n**第一部分：Reciprobit斜率的通用表达式**\n斜率由下式给出：\n$$m_{\\text{recip}} = \\frac{1}{\\sigma_x}$$\n代入我们为 $\\sigma_x$ 推导出的表达式：\n$$m_{\\text{recip}} = \\frac{1}{\\frac{\\sigma}{S - S_{0}}} = \\frac{S - S_{0}}{\\sigma}$$\n这就是reciprobit斜率作为阈值 $S$、起始水平 $S_{0}$ 以及速率标准差 $\\sigma$ 的函数的通用表达式。\n\n**第二部分：斜率的倍数变化**\n原始斜率，决策阈值为 $S$ 时，是：\n$$m_{orig} = \\frac{S - S_{0}}{\\sigma}$$\n现在，阈值翻倍至 $S' = 2S$，而所有其他参数（$S_{0}$, $\\mu$, $\\sigma$）保持不变。新的斜率 $m_{new}$ 是：\n$$m_{new} = \\frac{S' - S_{0}}{\\sigma} = \\frac{2S - S_{0}}{\\sigma}$$\n问题要求的是倍数变化，即新斜率与原斜率的比值：\n$$\\text{Ratio} = \\frac{m_{new}}{m_{orig}} = \\frac{\\frac{2S - S_{0}}{\\sigma}}{\\frac{S - S_{0}}{\\sigma}}$$\n因子 $\\sigma$被消去，剩下：\n$$\\text{Ratio} = \\frac{2S - S_{0}}{S - S_{0}}$$\n\n**第三部分：解释**\n在像LATER这样的决策模型背景下，速度-准确率权衡描述了这样一种现象：更快的决策通常更容易出错，而更准确的决策需要更长的时间。在LATER模型中，这种权衡是通过调整决策阈值 $S$ 来实现的。\n\n更高的阈值 $S$ 意味着在做出决策之前必须积累更多的证据。这会导致更长的平均反应时间（$E[T] \\approx (S - S_0)/\\mu$），但通过减少基于噪声证据做出过早决策的机会来提高准确性。\n\n推导过程表明，将阈值从 $S$ 增加到 $2S$（向着提高准确率的方向转变）会使reciprobit斜率增加一个因子 $(2S - S_0)/(S - S_0)$。由于决策发生需要 $S > S_0$，这个比率总是大于1。例如，在决策过程从零开始的常见情况下（$S_0 = 0$），该比率为 $(2S - 0)/(S - 0) = 2$，意味着斜率加倍。\n\n这一结果提供了LATER模型的一个直接的、定量的预测：被试为提高准确性而进行的策略性调整（即增加其内部阈值 $S$）将在实验数据中表现为reciprobit图陡峭程度的一个特定的、可预测的增加。该图的斜率是一个可观测的量，可以从一组反应时间数据中估计出来。因此，推导出的比率将一个理论上的认知参数（$S$）与行为数据的可测量特征联系起来，为检验该模型关于速度-准确率调整的神经实现方式的假设提供了一种强有力的方法。",
            "answer": "$$\\boxed{\\frac{2S - S_{0}}{S - S_{0}}}$$"
        },
        {
            "introduction": "在掌握了基础LATER模型的特性后，我们将探索当模型的基本假设不成立时会发生什么。 本练习假设决策速率来源于一个更复杂的双高斯混合分布，并要求你分析这种复杂性如何在reciprobit图上表现为非线性的曲率。通过这个推导，你将学会如何将reciprobit图从一个简单的数据可视化工具，转变为一个能够揭示潜在认知过程（如存在多种决策策略）的强大诊断工具。",
            "id": "4012871",
            "problem": "考虑遍历速率线性阈值（LATER）模型，其中决策信号以遍历速率 $R$ 线性上升至一个固定的阈值 $S0$，产生的反应时 $T$ 由 $T=S/R$ 给出。假设在每次试验中，$R$ 从一个具有相等方差的双组分高斯混合分布中抽取：\n$$\nR \\sim w\\,\\mathcal{N}(\\mu_{1},\\sigma^{2}) + (1-w)\\,\\mathcal{N}(\\mu_{2},\\sigma^{2}),\n$$\n其中 $0w1$。\n\n1.  当混合权重相等 ($w=\\tfrac{1}{2}$) 且均值对称地位于全局均值 $\\mu$ 周围 ($\\mu_{1}=\\mu-d, \\mu_{2}=\\mu+d$，$d0$) 时，确定速率分布 $R$ 是单峰还是双峰的精确条件。该条件应涉及均值之间的半分离度 $d$ 和公共标准差 $\\sigma$。\n2.  推导倒数反应时 $U = 1/T = R/S$ 上的倒数概率单位变换 $y(u)=\\Phi^{-1}(F_{U}(u))$ 的二阶导数 $y''(u)$ 的闭式表达式。其中，$F_U(u)$ 是 $U$ 的累积分布函数，$\\Phi^{-1}$ 是标准正态累积分布函数的反函数（概率单位函数）。这个表达式将证明，当基础速率分布是高斯混合分布时，倒数概率单位图通常是弯曲的，而不是像标准 LATER 模型那样是直线的。",
            "solution": "我们从LATER模型的假设开始，即 $T=S/R$，其中 $S0$ 是一个固定的阈值，遍历速率 $R$ 在不同试验中变化。分布假设意味着 $U=R/S$ 是 $R$ 的一个标度化版本，因此是一个高斯混合分布：\n$$\nU \\sim w\\,\\mathcal{N}\\!\\left(m_{1}, s^{2}\\right) + (1-w)\\,\\mathcal{N}\\!\\left(m_{2}, s^{2}\\right),\n\\quad \\text{其中} \\quad m_{i}=\\frac{\\mu_{i}}{S}, \\quad s=\\frac{\\sigma}{S}.\n$$\n我们定义标准正态概率密度函数和累积分布函数如下：\n$$\n\\phi(x)=\\frac{1}{\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{x^{2}}{2}\\right), \\quad \\Phi(x)=\\int_{-\\infty}^{x}\\phi(t)\\,dt,\n$$\n以及倒数概率单位变换 $y(u)$ 为\n$$\ny(u)=\\Phi^{-1}\\!\\left(F_{U}(u)\\right),\n\\quad \\text{其中} \\quad\nF_{U}(u)=w\\,\\Phi\\!\\left(\\frac{u-m_{1}}{s}\\right) + (1-w)\\,\\Phi\\!\\left(\\frac{u-m_{2}}{s}\\right).\n$$\n\n第1部分：对称、等权重情况下混合密度的模态。考虑 $w=\\tfrac{1}{2}$ 和对称均值 $\\mu_{1}=\\mu-d, \\mu_{2}=\\mu+d$，$d0$。$R$ 的混合密度为\n$$\nf_{R}(r)=\\frac{1}{2}\\,f_{1}(r) + \\frac{1}{2}\\,f_{2}(r),\n\\quad \\text{其中} \\quad\nf_{i}(r)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(r-\\mu_{i})^{2}}{2\\sigma^{2}}\\right).\n$$\n我们分析中心点 $r=\\mu$ 处的曲率以推断其模态。高斯密度 $f_{i}(r)$ 的一阶和二阶导数是\n$$\nf_{i}'(r)=-\\frac{r-\\mu_{i}}{\\sigma^{2}}\\,f_{i}(r), \\quad\nf_{i}''(r)=\\left(\\frac{(r-\\mu_{i})^{2}}{\\sigma^{4}}-\\frac{1}{\\sigma^{2}}\\right)\\,f_{i}(r).\n$$\n根据对称性，$f_{R}'(\\mu)=\\frac{1}{2}(f_{1}'(\\mu)+f_{2}'(\\mu))=0$。在 $r=\\mu$ 处的二阶导数是\n$$\nf_{R}''(\\mu)=\\frac{1}{2}\\left(f_{1}''(\\mu)+f_{2}''(\\mu)\\right).\n$$\n在 $r=\\mu$ 处，我们有 $r-\\mu_{1}=d$ 和 $r-\\mu_{2}=-d$，所以 $f_{1}(\\mu)=f_{2}(\\mu)=\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{d^{2}}{2\\sigma^{2}}\\right)$ 并且\n$$\nf_{1}''(\\mu)=\\left(\\frac{d^{2}}{\\sigma^{4}}-\\frac{1}{\\sigma^{2}}\\right)f_{1}(\\mu), \\quad\nf_{2}''(\\mu)=\\left(\\frac{d^{2}}{\\sigma^{4}}-\\frac{1}{\\sigma^{2}}\\right)f_{2}(\\mu).\n$$\n因此，\n$$\nf_{R}''(\\mu)=\\left(\\frac{d^{2}}{\\sigma^{4}}-\\frac{1}{\\sigma^{2}}\\right)\\,f_{1}(\\mu).\n$$\n由于 $f_{1}(\\mu)0$，$f_{R}''(\\mu)$ 的符号由 $\\frac{d^{2}}{\\sigma^{4}}-\\frac{1}{\\sigma^{2}}=\\frac{d^{2}-\\sigma^{2}}{\\sigma^{4}}$ 决定。因此\n- 如果 $d\\sigma$，则 $f_{R}''(\\mu)0$ 且 $r=\\mu$ 是一个局部极大值，这意味着一个单峰混合分布；\n- 如果 $d\\sigma$，则 $f_{R}''(\\mu)0$ 且 $r=\\mu$ 是一个局部极小值，这意味着两个对称的极大值（双峰性）；\n- 如果 $d=\\sigma$，则 $f_{R}''(\\mu)=0$，表示在 $r=\\mu$ 处有一个拐点，这是单峰性与双峰性之间的过渡。\n\n因此，当两个具有相等权重和相等方差的高斯速率的混合分布，其分离度 $d$ 超过 $\\sigma$ 时，该混合分布在 $R$ 上精确地变为双峰的，并且当 $d=\\sigma$ 时，中心点通过一个拐点过渡。\n\n第2部分：倒数关系与倒数概率单位图上的曲率。定义 $U=R/S$；$U$ 的累积分布函数为\n$$\nF_{U}(u)=w\\,\\Phi\\!\\left(\\frac{u-m_{1}}{s}\\right) + (1-w)\\,\\Phi\\!\\left(\\frac{u-m_{2}}{s}\\right),\n$$\n其中 $m_{i}=\\mu_{i}/S$ 且 $s=\\sigma/S$。倒数概率单位变换为 $y(u)=\\Phi^{-1}(F_{U}(u))$。为分析曲率，我们计算二阶导数 $y''(u)$。\n\n令\n$$\na(u)=\\frac{u-m_{1}}{s}, \\quad b(u)=\\frac{u-m_{2}}{s}, \\quad p(u)=F_{U}(u)=w\\,\\Phi(a(u))+(1-w)\\,\\Phi(b(u)).\n$$\n通过对 $u$ 求导并使用链式法则，我们得到\n$$\np'(u)=w\\,\\phi(a(u))\\,\\frac{1}{s}+(1-w)\\,\\phi(b(u))\\,\\frac{1}{s}\n=\\frac{w\\,\\phi(a(u))+(1-w)\\,\\phi(b(u))}{s},\n$$\n并且，利用 $\\phi'(x)=-x\\,\\phi(x)$，\n$$\np''(u)=w\\,\\phi'(a(u))\\,\\frac{1}{s^{2}}+(1-w)\\,\\phi'(b(u))\\,\\frac{1}{s^{2}}\n=\\frac{-w\\,a(u)\\,\\phi(a(u))-(1-w)\\,b(u)\\,\\phi(b(u))}{s^{2}}.\n$$\n由于 $y(u)=\\Phi^{-1}(p(u))$，对 $\\Phi(y(u))=p(u)$ 求导可得\n$$\n\\phi(y(u))\\,y'(u)=p'(u)\n\\quad \\Rightarrow \\quad\ny'(u)=\\frac{p'(u)}{\\phi(y(u))}.\n$$\n再次求导并利用 $\\phi'(y)=-y\\,\\phi(y)$，我们得到\n$$\ny''(u)=\\frac{p''(u)}{\\phi(y(u))} + \\frac{y(u)\\,\\big(p'(u)\\big)^{2}}{\\big(\\phi(y(u))\\big)^{2}}.\n$$\n代入 $p'(u)$ 和 $p''(u)$ 的表达式，得到显式的闭式形式\n$$\ny''(u)=\\frac{-\\,w\\,a(u)\\,\\phi\\!\\big(a(u)\\big)\\,-\\,(1-w)\\,b(u)\\,\\phi\\!\\big(b(u)\\big)}{s^{2}\\,\\phi\\!\\big(y(u)\\big)} \\;+\\; \\frac{y(u)}{\\big(\\phi\\!\\big(y(u)\\big)\\big)^{2}}\\,\\left(\\frac{w\\,\\phi\\!\\big(a(u)\\big)+(1-w)\\,\\phi\\!\\big(b(u)\\big)}{s}\\right)^{2}.\n$$\n该表达式表明，当基础速率分布是单一高斯分布时（这使得 $p(u)$ 是关于 $u$ 的单一 $\\Phi$ 函数），变换 $y(u)$ 是 $u$ 的线性函数，并且 $y''(u)$ 恒等于0。相比之下，对于混合分布，$y''(u)$ 通常不为零，并会在两个组分的贡献交换主导地位的区域改变符号。在对称等权重的情况下，在中点 $u=\\tfrac{m_{1}+m_{2}}{2}$ 处求值得到 $a(u)=-b(u)$ 和 $p''(u)=0$，因此在该点 $y''(u)=0$，这在倒数概率单位空间中确定了一个拐点。远离中点时，$y''(u)\\neq 0$，产生可见的曲率；这种曲率（及其符号变化）是 LATER 框架中混合结构的诊断特征。\n\n所要求的 $y''(u)$ 的最终表达式就是上面的闭式形式。",
            "answer": "$$\\boxed{\\frac{-\\,w\\,\\frac{u-m_{1}}{s}\\,\\phi\\!\\left(\\frac{u-m_{1}}{s}\\right)\\,-\\,(1-w)\\,\\frac{u-m_{2}}{s}\\,\\phi\\!\\left(\\frac{u-m_{2}}{s}\\right)}{s^{2}\\,\\phi\\!\\left(\\Phi^{-1}\\!\\left(w\\,\\Phi\\!\\left(\\frac{u-m_{1}}{s}\\right)+(1-w)\\,\\Phi\\!\\left(\\frac{u-m_{2}}{s}\\right)\\right)\\right)}\\;+\\;\\frac{\\Phi^{-1}\\!\\left(w\\,\\Phi\\!\\left(\\frac{u-m_{1}}{s}\\right)+(1-w)\\,\\Phi\\!\\left(\\frac{u-m_{2}}{s}\\right)\\right)}{\\left(\\phi\\!\\left(\\Phi^{-1}\\!\\left(w\\,\\Phi\\!\\left(\\frac{u-m_{1}}{s}\\right)+(1-w)\\,\\Phi\\!\\left(\\frac{u-m_{2}}{s}\\right)\\right)\\right)\\right)^{2}}\\,\\left(\\frac{w\\,\\phi\\!\\left(\\frac{u-m_{1}}{s}\\right)+(1-w)\\,\\phi\\!\\left(\\frac{u-m_{2}}{s}\\right)}{s}\\right)^{2}}$$"
        },
        {
            "introduction": "最后一个练习将我们的视野从LATER模型的具体推导扩展到对整个竞争模型框架进行严格的统计检验。我们将关注冗余信号范式，并利用经典的竞争不等式（Miller界限）来判断是否存在超越独立竞争的协同激活效应。 这个编码练习要求你实现一个基于自举法（bootstrap）的假设检验，为你提供使用现代计算统计方法来严谨验证认知模型预测的实战经验。",
            "id": "4012824",
            "problem": "给定在冗余信号范式下三种条件的独立反应时间样本：单独刺激 $A$、单独刺激 $B$ 和冗余刺激 $AB$。假设反应时间严格为正，并以秒为单位测量。线性阈值遍历速率 (LATER) 模型假定决策时间 $T$ 可以表示为 $T = S / R$，其中 $S$ 是一个固定的决策边界，$R$ 是一个随机速率变量；在实践中，将直接使用 $A$ 和 $B$ 的经验分布。\n\n定义三种条件下反应时间的累积分布函数 $F_A(t)$、$F_B(t)$ 和 $F_{AB}(t)$。经典的竞争不等式（Miller 界限）指出，在没有协同激活的情况下，冗余条件 $AB$ 必须满足以下逐点界限\n$$\nF_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), \\, 1\\big) \\quad \\text{for all } t \\in \\mathbb{R}_{\\ge 0}.\n$$\n你必须设计并实现一个统计程序，以检验基于有限样本的对此界限的违规情况，该程序使用经验累积分布函数和在最不利零模型下校准的 bootstrap 法。\n\n将假设表述如下：\n- 零假设 $H_0$：对于所有 $t \\in \\mathbb{R}_{\\ge 0}$，$F_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), \\, 1\\big)$。\n- 备择假设 $H_1$：存在 $t \\in \\mathbb{R}_{\\ge 0}$ 使得 $F_{AB}(t)  \\min\\big(F_A(t) + F_B(t), \\, 1\\big)$。\n\n你的检验必须使用以下要素：\n- 从样本计算得出的经验累积分布函数 $\\hat F_A(t)$、$\\hat F_B(t)$ 和 $\\hat F_{AB}(t)$。\n- 一个检验统计量，定义为经验冗余累积分布超过经验 Miller 界限的逐点超额的上确界：\n$$\nT_n \\equiv \\sup_{t \\in \\mathcal{T}} \\left\\{ \\hat F_{AB}(t) - \\min\\big(\\hat F_A(t) + \\hat F_B(t), \\, 1\\big) \\right\\},\n$$\n其中 $\\mathcal{T}$ 是一个有限网格，由所有三个条件中观测到的所有样本时间组成。\n- 一个 bootstrap 程序，通过在由经验边际分布构建的最不利零模型下模拟 bootstrap 数据集来近似 $T_n$ 的零分布。具体来说，对于每次 bootstrap 复制：\n  1. 从仅含 $A$ 的样本中有放回地重抽样 $n_A$ 次，形成一个 bootstrap 样本 $A^\\ast$；从仅含 $B$ 的样本中有放回地重抽样 $n_B$ 次，形成一个 bootstrap 样本 $B^\\ast$。\n  2. 在 $A^\\ast \\cup B^\\ast$ 中观测到的唯一时间的网格上，计算 bootstrap 经验界限 $G^\\ast(t) = \\min\\big(\\hat F_{A^\\ast}(t) + \\hat F_{B^\\ast}(t), \\, 1\\big)$。\n  3. 从累积分布函数为 $G^\\ast(t)$ 的离散分布中抽样 $n_{AB}$ 个冗余时间 $AB^\\ast$，通过在该网格上进行逆变换实现。\n  4. 使用 $A^\\ast$、$B^\\ast$ 和 $AB^\\ast$ 计算 bootstrap 统计量 $T_n^\\ast$，方法与计算 $T_n$ 完全相同。\n- bootstrap $p$ 值估计为\n$$\n\\hat p = \\frac{1 + \\sum_{b=1}^B \\mathbf{1}\\{T_{n,b}^\\ast \\ge T_n\\}}{1 + B},\n$$\n如果 $\\hat p \\le \\alpha$，则检验在水平 $\\alpha$ 上拒绝 $H_0$。使用 $\\alpha = 0.05$。\n\n实现此检验，并将其应用于以下合成数据集测试套件，每个数据集均由用于 $A$ 和 $B$ 的 LATER 模型以及用于 $AB$ 的两个 LATER 过程的竞争生成，带有一个可选的乘法协同激活因子 $\\gamma$：\n- 对于每个条件 $X \\in \\{A, B\\}$，生成速率 $R_X \\sim \\mathcal{N}(\\mu_X, \\sigma_X^2)$，截断至 $R_X  0$，设置 $S = 1$，并计算 $T_X = S / R_X$。对于冗余条件，以相同方式生成独立抽样 $T_A'$ 和 $T_B'$，并设置 $T_{AB} = \\gamma \\cdot \\min(T_A', T_B')$。所有时间必须以秒为单位测量。\n- 测试套件由以下参数集组成，每个参数集都有一个固定的随机种子以确保可复现性：\n  1. 案例1（竞争，大样本）：$n_A = n_B = n_{AB} = 600$，$\\mu_A = 3.0$，$\\sigma_A = 0.4$，$\\mu_B = 3.0$，$\\sigma_B = 0.4$，$\\gamma = 1.0$。\n  2. 案例2（协同激活，违规）：$n_A = n_B = n_{AB} = 400$，$\\mu_A = 3.0$，$\\sigma_A = 0.4$，$\\mu_B = 3.0$，$\\sigma_B = 0.4$，$\\gamma = 0.8$。\n  3. 案例3（竞争，小样本）：$n_A = n_B = n_{AB} = 120$，$\\mu_A = 3.0$，$\\sigma_A = 0.5$，$\\mu_B = 3.0$，$\\sigma_B = 0.5$，$\\gamma = 1.0$。\n  4. 案例4（非对称，近边界）：$n_A = n_B = n_{AB} = 400$，$\\mu_A = 2.5$，$\\sigma_A = 0.5$，$\\mu_B = 4.0$，$\\sigma_B = 0.5$，$\\gamma = 0.95$。\n- 每个案例使用 $B = 1000$ 次 bootstrap 复制，并在所有案例中使用单一固定种子，以便结果完全可复现。\n\n你的程序必须：\n- 根据上述规范生成以秒为单位的合成数据集。\n- 计算每个案例的检验统计量和 bootstrap $p$ 值。\n- 对每个案例，在水平 $\\alpha = 0.05$ 上决定是否拒绝 $H_0$。\n\n最终输出格式：\n- 你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例1到4的顺序列出结果，每个条目是一个布尔值，指示该案例是否拒绝 $H_0$。例如：“[True,False,False,True]”。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它在科学上基于认知建模和计算统计学的原理，问题提法明确，并为一项非平凡的统计检验提供了一套完整且一致的要求。\n\n任务是针对反应时间数据，为竞争模型不等式（也称为 Miller 界限）实现一个 bootstrap 假设检验。该不等式是并行竞争模型的一个基本预测，这些模型假设对于冗余刺激 $A$ 和 $B$，反应是由两个独立处理通道中首先完成的那个触发的。\n\n设 $F_A(t)$、$F_B(t)$ 和 $F_{AB}(t)$ 分别是单独刺激 $A$、单独刺激 $B$ 和冗余刺激 $AB$ 的反应时间的累积分布函数 (CDF)。竞争模型不等式指出，对于所有非负时间 $t \\ge 0$，\n$$F_{AB}(t) \\le \\min\\big(F_A(t) + F_B(t), 1\\big)$$\n违反此不等式，特别是 $F_{AB}(t)  F_A(t) + F_B(t)$ 的情况，表明存在一种协同激活机制，其中两个刺激的存在导致处理速度比独立过程之间的简单竞争所预测的要快。\n\n假设检验表述为：\n- 零假设 $H_0$：对于所有 $t \\ge 0$，$F_{AB}(t) \\le \\min(F_A(t) + F_B(t), 1)$。观测数据与竞争模型一致。\n- 备择假设 $H_1$：存在 $t \\ge 0$ 使得 $F_{AB}(t)  \\min(F_A(t) + F_B(t), 1)$。数据与竞争模型不一致，表明存在协同激活。\n\n由于真实的 CDF 是未知的，我们使用它们的经验对应物，即经验累积分布函数 (ECDF)，记为 $\\hat{F}_A(t)$、$\\hat{F}_B(t)$ 和 $\\hat{F}_{AB}(t)$，它们从大小为 $n_A$、$n_B$ 和 $n_{AB}$ 的有限样本中计算得出。\n\n解决方案的核心包括以下步骤：\n\n1.  **检验统计量计算**：观测数据中不等式的违规程度由检验统计量 $T_n$ 量化。它被定义为冗余 ECDF 与经验 Miller 界限之间的最大观测差异，该差异在数据中观测到的所有唯一时间点上取值。设 $\\mathcal{T}$ 为三个实验条件中所有唯一反应时间的集合。该统计量为：\n    $$T_n = \\sup_{t \\in \\mathcal{T}} \\left\\{ \\hat{F}_{AB}(t) - \\min\\big(\\hat{F}_A(t) + \\hat{F}_B(t), 1\\big) \\right\\}$$\n    $T_n$ 的正值越大，提供反对零假设 $H_0$ 的证据就越强。\n\n2.  **零分布的 Bootstrap 估计**：在 $H_0$ 下，$T_n$ 的抽样分布通常是难以处理的。因此我们使用 bootstrap 程序来近似它。此程序的关键方面是生成符合零假设的 bootstrap 样本。我们从一个“最不利”的零模型进行模拟，该模型位于不等式的边界上，即 $F_{AB}(t) = \\min(F_A(t) + F_B(t), 1)$。这种选择使得检验对任何违规都敏感。对于 $B=1000$ 次 bootstrap 复制中的每一次，程序如下：\n    a. 通过从原始的单一刺激条件 $A$ 和 $B$ 的样本中进行有放回的重抽样，分别生成 bootstrap 样本 $A^\\ast$ 和 $B^\\ast$。\n    b. 为 bootstrap 边际分布构建 ECDF，即 $\\hat{F}_{A^\\ast}(t)$ 和 $\\hat{F}_{B^\\ast}(t)$。\n    c. 定义一个 bootstrap 零 CDF，$G^\\ast(t) = \\min\\big(\\hat{F}_{A^\\ast}(t) + \\hat{F}_{B^\\ast}(t), 1\\big)$。这在 $A^\\ast \\cup B^\\ast$ 中观测到的时间点上定义了一个离散概率分布。这个分布代表了在基于 bootstrap 边际分布的竞争模型下仍然一致的最快可能的冗余反应时间。\n    d. 使用逆变换采样方法，从由 $G^\\ast(t)$ 定义的离散分布中抽样，生成一个大小为 $n_{AB}$ 的 bootstrap 冗余样本 $AB^\\ast$。根据构造，样本三元组 $(A^\\ast, B^\\ast, AB^\\ast)$ 满足零假设。\n    e. 为此 bootstrap 三元组计算 bootstrap 检验统计量 $T_n^\\ast$，其方式与观测统计量 $T_n$ 相同。\n\n3.  **P值计算和决策**：在生成 $B$ 个 bootstrap 统计量 $\\{T_{n,1}^\\ast, \\dots, T_{n,B}^\\ast\\}$ 后，我们得到了 $T_n$ 零分布的经验近似。单侧 $p$ 值被估计为等于或大于原始观测统计量 $T_n$ 的 bootstrap 统计量的比例：\n    $$\\hat{p} = \\frac{1 + \\sum_{b=1}^{B} \\mathbf{1}\\{T_{n,b}^\\ast \\ge T_n\\}}{1 + B}$$\n    在分子和分母上加 1 是一种标准惯例，以防止 $p$ 值为 0 并确保保守的行为。如果 $\\hat{p} \\le \\alpha$，则在显著性水平 $\\alpha=0.05$ 上拒绝零假设 $H_0$。\n\n4.  **数据生成**：测试案例的合成数据集是使用 LATER 模型生成的。对于每个单一刺激条件 $X \\in \\{A, B\\}$，反应时间 $T_X$ 计算为 $T_X=S/R_X$，其中决策边界 $S$ 固定为 1，速率 $R_X$ 从截断正态分布 $\\mathcal{N}(\\mu_X, \\sigma_X^2)$ 中抽取，并满足约束 $R_X  0$。对于冗余条件，生成两个独立的 RT，$T_A'$ 和 $T_B'$，冗余 RT 取为 $T_{AB} = \\gamma \\cdot \\min(T_A', T_B')$。协同激活因子 $\\gamma  1$ 会导致比纯竞争模型（$\\gamma = 1$）更快的反应，这预计将导致对 Miller 界限的违反。\n\n该实现将把这个统计程序应用于四个不同的测试案例，为每个案例确定是否拒绝竞争模型的零假设。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import truncnorm\n\n# Define global parameters as specified in the problem\nB = 1000\nALPHA = 0.05\n# A single fixed seed for reproducibility across all cases\nRANDOM_SEED = 42\n\ndef generate_LATER_RTs(rng, n, mu, sigma, S=1.0):\n    \"\"\"\n    Generates reaction times from the LATER model S/R, where R is from a\n    truncated normal distribution.\n    \"\"\"\n    # The lower bound is 0. In standard-normal units for truncnorm, this is (0 - mu) / sigma.\n    a = -mu / sigma\n    b = np.inf\n    rates = truncnorm.rvs(a, b, loc=mu, scale=sigma, size=n, random_state=rng)\n    # Ensure rates are strictly positive to avoid division by zero\n    rates[rates == 0] = 1e-9  # A small positive floor\n    return S / rates\n\ndef generate_dataset(rng, n_a, n_b, n_ab, mu_a, sigma_a, mu_b, sigma_b, gamma):\n    \"\"\"\n    Generates a full dataset for conditions A, B, and AB based on LATER model parameters.\n    \"\"\"\n    sample_a = generate_LATER_RTs(rng, n_a, mu_a, sigma_a)\n    sample_b = generate_LATER_RTs(rng, n_b, mu_b, sigma_b)\n\n    # For the redundant condition, generate two sets of latent RTs for the race\n    t_a_prime = generate_LATER_RTs(rng, n_ab, mu_a, sigma_a)\n    t_b_prime = generate_LATER_RTs(rng, n_ab, mu_b, sigma_b)\n    \n    # The redundant RT is the coactivated minimum of the two latent RTs\n    sample_ab = gamma * np.minimum(t_a_prime, t_b_prime)\n\n    return sample_a, sample_b, sample_ab\n\ndef ecdf(sample, t_grid):\n    \"\"\"\n    Computes the Empirical Cumulative Distribution Function values for a sample\n    at specified time points.\n    \"\"\"\n    if len(sample) == 0:\n        return np.zeros_like(t_grid, dtype=float)\n    # Using np.searchsorted is efficient for this task\n    sample_sorted = np.sort(sample)\n    return np.searchsorted(sample_sorted, t_grid, side='right') / len(sample)\n\ndef compute_test_statistic(sample_a, sample_b, sample_ab):\n    \"\"\"\n    Computes the test statistic T_n, the supremum of the violation of the Miller bound.\n    The supremum is taken over the grid of all observed time points.\n    \"\"\"\n    # Create the grid of all unique observed time points\n    t_grid = np.unique(np.concatenate((sample_a, sample_b, sample_ab)))\n\n    # Compute ECDFs for all three conditions on the common grid\n    ecdf_a = ecdf(sample_a, t_grid)\n    ecdf_b = ecdf(sample_b, t_grid)\n    ecdf_ab = ecdf(sample_ab, t_grid)\n\n    # Calculate the Miller bound\n    miller_bound = np.minimum(ecdf_a + ecdf_b, 1.0)\n    \n    # The test statistic is the maximum positive deviation from the bound\n    test_statistic = np.max(ecdf_ab - miller_bound)\n    \n    return test_statistic\n\ndef perform_bootstrap_test(rng, sample_a, sample_b, sample_ab):\n    \"\"\"\n    Performs the full bootstrap hypothesis test.\n    \"\"\"\n    n_a, n_b, n_ab = len(sample_a), len(sample_b), len(sample_ab)\n\n    # 1. Compute the observed test statistic\n    T_n_obs = compute_test_statistic(sample_a, sample_b, sample_ab)\n\n    bootstrap_stats = []\n    for _ in range(B):\n        # 2a. Resample A and B\n        A_star = rng.choice(sample_a, size=n_a, replace=True)\n        B_star = rng.choice(sample_b, size=n_b, replace=True)\n        \n        # 2b. Construct the least-favorable null CDF, G*(t)\n        t_grid_star_gen = np.unique(np.concatenate((A_star, B_star)))\n        ecdf_a_star_gen = ecdf(A_star, t_grid_star_gen)\n        ecdf_b_star_gen = ecdf(B_star, t_grid_star_gen)\n        g_star_cdf = np.minimum(ecdf_a_star_gen + ecdf_b_star_gen, 1.0)\n\n        # 2c. Sample AB* from G*(t) via inverse transform sampling\n        # First, get the PMF from the CDF\n        g_star_pmf = np.diff(g_star_cdf, prepend=0)\n        # Normalize to correct for potential floating-point inaccuracies\n        g_star_pmf /= np.sum(g_star_pmf)\n        \n        AB_star = rng.choice(t_grid_star_gen, size=n_ab, replace=True, p=g_star_pmf)\n        \n        # 2d. Compute the bootstrap statistic T_n*\n        T_n_star = compute_test_statistic(A_star, B_star, AB_star)\n        bootstrap_stats.append(T_n_star)\n\n    # 3. Calculate the p-value\n    bootstrap_stats = np.array(bootstrap_stats)\n    num_exceed = np.sum(bootstrap_stats >= T_n_obs)\n    p_value = (1 + num_exceed) / (1 + B)\n\n    # 4. Make a decision based on the significance level\n    return p_value = ALPHA\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print the results.\n    \"\"\"\n    rng = np.random.default_rng(RANDOM_SEED)\n\n    test_cases = [\n        # Case 1 (race, large sample)\n        {'n_a': 600, 'n_b': 600, 'n_ab': 600, 'mu_a': 3.0, 'sigma_a': 0.4, 'mu_b': 3.0, 'sigma_b': 0.4, 'gamma': 1.0},\n        # Case 2 (coactivation, violation)\n        {'n_a': 400, 'n_b': 400, 'n_ab': 400, 'mu_a': 3.0, 'sigma_a': 0.4, 'mu_b': 3.0, 'sigma_b': 0.4, 'gamma': 0.8},\n        # Case 3 (race, small sample)\n        {'n_a': 120, 'n_b': 120, 'n_ab': 120, 'mu_a': 3.0, 'sigma_a': 0.5, 'mu_b': 3.0, 'sigma_b': 0.5, 'gamma': 1.0},\n        # Case 4 (asymmetric, near-boundary)\n        {'n_a': 400, 'n_b': 400, 'n_ab': 400, 'mu_a': 2.5, 'sigma_a': 0.5, 'mu_b': 4.0, 'sigma_b': 0.5, 'gamma': 0.95},\n    ]\n\n    results = []\n    for params in test_cases:\n        sample_a, sample_b, sample_ab = generate_dataset(rng, **params)\n        reject_h0 = perform_bootstrap_test(rng, sample_a, sample_b, sample_ab)\n        results.append(reject_h0)\n\n    # Print the final result in the exact specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}