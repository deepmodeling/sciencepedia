{
    "hands_on_practices": [
        {
            "introduction": "本练习直击“吸引子”概念的核心。一个连续吸引子模型不仅需要生成空间模式，还必须保证其稳定性。通过一个简化的范式模型 ，您将学习如何分析网格模式的线性稳定性，从而揭示为何模式的振幅是稳定的，而其相位却可以自由漂移——这正是实现路径积分的关键特性。",
            "id": "3985883",
            "problem": "考虑一个用于内侧内嗅皮层网格细胞的二维、平移不变的神经场模型，该模型支持稳态六边形放电率模式。令放电率场由 $u(\\mathbf{x}, t)$ 表示，其中 $\\mathbf{x} \\in \\mathbb{R}^{2}$。在标准的对称性和弱非线性假设下，模式形成初期的粗粒化动力学可以简化为一个描述全局模式振幅和相位（晶格位移）的低维系统。具体来说，假设模式振幅 $A(t) \\in \\mathbb{R}$ 和全局相位（晶格位移）$\\boldsymbol{\\phi}(t) = (\\phi_{x}(t), \\phi_{y}(t)) \\in \\mathbb{R}^{2}$ 的慢动力学由截断的范式控制\n$$\n\\frac{dA}{dt} = \\mu A - \\gamma A^{3}, \\qquad \\frac{d\\phi_{x}}{dt} = 0, \\qquad \\frac{d\\phi_{y}}{dt} = 0,\n$$\n其中 $\\mu > 0$ 是线性增长参数（由临界状态下突触核和神经增益的光谱特性设定），$\\gamma > 0$ 是主导阶的非线性饱和系数（由神经传递函数和循环相互作用中的高阶项设定）。具有非零振幅的稳态六边形模式对应于 $A^{\\ast} > 0$ 和一个任意常数 $\\boldsymbol{\\phi}^{\\ast} \\in \\mathbb{R}^{2}$，这反映了连续的平移对称性。\n\n计算此 $(A, \\phi_{x}, \\phi_{y})$ 系统的向量场在具有 $A^{\\ast} > 0$ 和任意 $\\boldsymbol{\\phi}^{\\ast}$ 的稳态点处的雅可比矩阵，并确定其特征值。使用这些特征值来评估稳态模式对振幅和相位扰动的线性稳定性。提供在非平凡稳态振幅处计算的特征值的有序三元组 $(\\lambda_{A}, \\lambda_{\\phi_{x}}, \\lambda_{\\phi_{y}})$。将您的最终答案表示为仅含 $\\mu$ 的单行矩阵。不需要数值近似，也不需要单位。最终答案必须是单个解析表达式。",
            "solution": "用户希望我分析一个简化的网格细胞活动模型中稳态模式的稳定性。\n\n### 步骤 1：问题验证\n\n**1.1. 提取已知条件**\n- **状态变量**：系统由振幅 $A(t) \\in \\mathbb{R}$ 和相位 $\\boldsymbol{\\phi}(t) = (\\phi_{x}(t), \\phi_{y}(t)) \\in \\mathbb{R}^{2}$ 描述。状态向量实际上是 $(A, \\phi_x, \\phi_y)$。\n- **动力学方程**：\n$$\n\\frac{dA}{dt} = \\mu A - \\gamma A^{3}\n$$\n$$\n\\frac{d\\phi_{x}}{dt} = 0\n$$\n$$\n\\frac{d\\phi_{y}}{dt} = 0\n$$\n- **参数**：$\\mu > 0$ 和 $\\gamma > 0$。\n- **目标**：计算 $(A, \\phi_{x}, \\phi_{y})$ 系统的向量场在振幅 $A^{\\ast} > 0$ 的稳态点处的雅可比矩阵。\n- **目标**：确定该雅可比矩阵的特征值。\n- **目标**：使用特征值评估稳态模式的线性稳定性。\n- **输出要求**：提供有序三元组特征值 $(\\lambda_{A}, \\lambda_{\\phi_{x}}, \\lambda_{\\phi_{y}})$，表示为仅含 $\\mu$ 的单行矩阵。\n\n**1.2. 使用提取的已知条件进行验证**\n- **科学依据**：该问题对图灵不稳定性附近的模式形成系统使用了标准的范式约简。这是理论物理学和计算神经科学中用于研究连续吸引子的一个经典模型，据推测连续吸引子是网格细胞放电模式的基础。该模型在科学上是合理且相关的。\n- **适定性**：该问题是适定的。它提供了一整套常微分方程，并要求在特定不动点进行标准的线性稳定性分析。该不动点的存在由条件 $\\mu > 0$ 和 $\\gamma > 0$ 保证。所要求的计算是标准的，并且会得到唯一的结果。\n- **客观性**：语言精确、技术性强，没有任何主观或含糊的陈述。\n\n**1.3. 结论与行动**\n该问题是有效的。它具有科学依据、适定性和客观性。没有矛盾、信息缺失或其他缺陷。我将继续进行求解。\n\n### 步骤 2：求解推导\n\n微分方程组由以下公式给出：\n$$\n\\frac{dA}{dt} = f_A(A, \\phi_x, \\phi_y) = \\mu A - \\gamma A^3\n$$\n$$\n\\frac{d\\phi_x}{dt} = f_{\\phi_x}(A, \\phi_x, \\phi_y) = 0\n$$\n$$\n\\frac{d\\phi_y}{dt} = f_{\\phi_y}(A, \\phi_x, \\phi_y) = 0\n$$\n\n首先，我们找到系统的稳态点（或不动点），记为 $(A^{\\ast}, \\phi_x^{\\ast}, \\phi_y^{\\ast})$。稳态点满足 $\\frac{dA}{dt} = 0$，$\\frac{d\\phi_x}{dt} = 0$ 和 $\\frac{d\\phi_y}{dt} = 0$。\n\n对于相位分量的方程 $\\frac{d\\phi_x}{dt} = 0$ 和 $\\frac{d\\phi_y}{dt} = 0$，任何恒定的 $\\phi_x$ 和 $\\phi_y$ 值都满足。这反映了系统的连续平移对称性，即任何相位移 $\\boldsymbol{\\phi}$ 都同样有效。\n\n振幅的方程为：\n$$\n\\mu A - \\gamma A^3 = 0\n$$\n$$\nA(\\mu - \\gamma A^2) = 0\n$$\n该方程对于 $A$ 有两个解。一个是平凡解 $A = 0$。另一个解是通过将括号中的项设为零来找到的：\n$$\n\\mu - \\gamma A^2 = 0 \\implies A^2 = \\frac{\\mu}{\\gamma}\n$$\n问题指明我们关心的是具有非零振幅的稳态模式，即 $A^{\\ast} > 0$。由于 $\\mu > 0$ 和 $\\gamma > 0$，我们可以取正平方根：\n$$\nA^{\\ast} = \\sqrt{\\frac{\\mu}{\\gamma}}\n$$\n因此，我们感兴趣的稳态点构成一个由 $(A^{\\ast}, \\phi_x^{\\ast}, \\phi_y^{\\ast}) = (\\sqrt{\\frac{\\mu}{\\gamma}}, c_x, c_y)$ 描述的连续族（一个流形），其中 $c_x$ 和 $c_y$ 是任意实常数。\n\n接下来，我们计算向量场 $\\mathbf{F} = (f_A, f_{\\phi_x}, f_{\\phi_y})$ 关于状态变量 $(A, \\phi_x, \\phi_y)$ 的雅可比矩阵 $J$。\n$$\nJ = \\begin{pmatrix}\n\\frac{\\partial f_A}{\\partial A}  \\frac{\\partial f_A}{\\partial \\phi_x}  \\frac{\\partial f_A}{\\partial \\phi_y} \\\\\n\\frac{\\partial f_{\\phi_x}}{\\partial A}  \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_x}  \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_y} \\\\\n\\frac{\\partial f_{\\phi_y}}{\\partial A}  \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_x}  \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_y}\n\\end{pmatrix}\n$$\n我们计算偏导数：\n$$\n\\frac{\\partial f_A}{\\partial A} = \\mu - 3\\gamma A^2\n$$\n所有其他偏导数都为零，因为 $f_A$ 不依赖于 $\\phi_x$ 或 $\\phi_y$，而 $f_{\\phi_x}$ 和 $f_{\\phi_y}$ 恒为零。\n$$\n\\frac{\\partial f_A}{\\partial \\phi_x} = 0, \\quad \\frac{\\partial f_A}{\\partial \\phi_y} = 0\n$$\n$$\n\\frac{\\partial f_{\\phi_x}}{\\partial A} = \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_x} = \\frac{\\partial f_{\\phi_x}}{\\partial \\phi_y} = 0\n$$\n$$\n\\frac{\\partial f_{\\phi_y}}{\\partial A} = \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_x} = \\frac{\\partial f_{\\phi_y}}{\\partial \\phi_y} = 0\n$$\n因此，雅可比矩阵为：\n$$\nJ = \\begin{pmatrix}\n\\mu - 3\\gamma A^2  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n现在，我们在稳态点 $A = A^{\\ast} = \\sqrt{\\frac{\\mu}{\\gamma}}$ 处评估此雅可比矩阵。我们称之为 $J^{\\ast}$。\n唯一非平凡的元素是左上角的元素：\n$$\n\\frac{\\partial f_A}{\\partial A}\\bigg|_{A=A^{\\ast}} = \\mu - 3\\gamma (A^{\\ast})^2 = \\mu - 3\\gamma \\left(\\frac{\\mu}{\\gamma}\\right) = \\mu - 3\\mu = -2\\mu\n$$\n所以，在稳态点评估的雅可比矩阵为：\n$$\nJ^{\\ast} = \\begin{pmatrix}\n-2\\mu  0  0 \\\\\n0  0  0 \\\\\n0  0  0\n\\end{pmatrix}\n$$\n对角矩阵的特征值 $(\\lambda)$ 是其对角线上的元素。因此，$J^{\\ast}$ 的特征值为：\n$$\n\\lambda_1 = -2\\mu, \\quad \\lambda_2 = 0, \\quad \\lambda_3 = 0\n$$\n第一个特征值 $\\lambda_A = -2\\mu$ 对应于振幅 $A$ 的动力学。由于 $\\mu > 0$，该特征值为负，这表明稳态振幅 $A^{\\ast}$ 对小扰动是稳定的。振幅的任何微小偏差都将指数衰减回到不动点值。\n\n另外两个特征值 $\\lambda_{\\phi_x} = 0$ 和 $\\lambda_{\\phi_y} = 0$ 对应于相位分量 $\\phi_x$ 和 $\\phi_y$ 的动力学。这些零特征值表示中性或临界稳定性。物理上，这意味着如果相位受到扰动，它既不会返回其原始值，也不会无限增长。它只会稳定在新的值上。这是连续吸引子的标志，其中零特征值对应于沿着不动点连续流形（“吸引子状态”）的运动方向。这些是与系统连续平移对称性自发破缺相关的戈德斯通模。\n\n特征值的有序三元组是 $(\\lambda_{A}, \\lambda_{\\phi_{x}}, \\lambda_{\\phi_{y}}) = (-2\\mu, 0, 0)$。问题要求将其表示为单行矩阵。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2\\mu  0  0\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "基于中性稳定相位模式的思想，本实践聚焦于网格细胞网络的核心功能：路径积分。您将基于一个降维动力学模型  进行仿真，追踪动物的速度输入如何驱动活动“鼓包”在环面上移动。这项任务不仅揭示了神经动力学与空间表征之间的直接联系，也展示了模型中的不完美之处（如增益或方向失配）如何导致累积误差。",
            "id": "3985930",
            "problem": "给定一个速度时间序列和一个平移对称的神经场，该神经场实现了一种二维路径整合机制，这是网格细胞连续吸引子模型的典型特征。您的任务是推导环面上“颠簸”（bump）相位的降维动力学描述，并实现一个模拟，量化模拟相位轨迹与通过直接积分物理位移预测的相位之间的差异。请使用以下基本原理：二维神经场中的平移不变性意味着存在一个连续的“颠簸”解族，而相应的 Goldstone 模态产生了由输入驱动的“颠簸”中心的低维中性动力学。从连续吸引子神经网络 (CANN) 方程出发，推导由速度输入驱动的低维相位动力学。比较必须在二维环面上进行，角度以弧度表示。\n\n定义与设置：\n- 考虑一个用于描述活动 $u(\\mathbf{x}, t)$ 的二维连续吸引子神经场，其中 $\\mathbf{x} \\in \\mathbb{R}^2$，具有空间平移不变的循环连接和一个编码速度的外部输入。周期性边界条件将活动“颠簸”的中心识别为环面 $\\mathbb{T}^2$ 上的一个相位点。\n- 物理速度为 $\\mathbf{v}(t) = (v_x(t), v_y(t))$，单位为 $\\mathrm{m/s}$；物理位移为 $\\mathbf{s}(t) = \\int_0^t \\mathbf{v}(\\tau)\\, d\\tau$，单位为 $\\mathrm{m}$。\n- 环面坐标是角度 $\\boldsymbol{\\phi}(t) = (\\phi_x(t), \\phi_y(t))$，单位为弧度，每个分量都以 $2\\pi$ 为模。沿两个轴的空间周期为 $\\boldsymbol{\\lambda} = (\\lambda_x, \\lambda_y)$，单位为 $\\mathrm{m}$，因此沿轴 $i$ 的位移 $\\lambda_i$ 对应于 $\\phi_i$ 中 $2\\pi$ 的相位前进。\n- 降维的低维动力学应通过投影到中性平移模态上，并根据 $\\mathbf{v}(t)$ 和一个与空间周期 $\\boldsymbol{\\lambda}$ 一致的耦合矩阵来表示相位演化 $\\boldsymbol{\\phi}(t)$，从而从 CANN 中推导出来。角度必须卷绕到区间 $[0, 2\\pi)$。\n\n误差度量：\n- 给定模拟的相位轨迹 $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$ 和通过使用空间周期 $\\boldsymbol{\\lambda}$ 将物理位移 $\\mathbf{s}(t)$ 映射到环面角度而获得的“真实”相位轨迹 $\\boldsymbol{\\phi}_{\\mathrm{true}}(t)$，定义分量级卷绕相位差 $\\Delta_i(t) = \\mathrm{wrap}\\big(\\phi_{\\mathrm{model}, i}(t) - \\phi_{\\mathrm{true}, i}(t)\\big)$，其中 $\\mathrm{wrap}(\\cdot)$ 将角度映射到 $(-\\pi, \\pi]$。在 $\\mathbb{T}^2$ 上的瞬时测地线误差为 $e(t) = \\sqrt{\\Delta_x(t)^2 + \\Delta_y(t)^2}$。所需的标量度量是均方根误差 $E = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} e(t_n)^2}$，其中 $t_n$ 是离散时间样本，$N$ 是总样本数。将 $E$ 报告为四舍五入到六位小数的浮点数。\n\n角度单位是弧度。速度和空间周期的物理单位按规定分别为米/秒和米；最终误差 $E$ 是一个无量纲（以弧度为单位）的浮点数。\n\n模拟要求：\n- 使用固定时间步长 $dt$ 的离散时间积分，通过对 $\\mathbf{v}(t) dt$ 求和来计算 $\\mathbf{s}(t)$，并使用从连续吸引子神经场推导出的降维相位动力学来推进模型的相位 $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$。在每一步，将 $\\boldsymbol{\\phi}_{\\mathrm{model}}(t)$ 的各分量卷绕到 $[0, 2\\pi)$。\n- 通过使用空间周期 $\\boldsymbol{\\lambda}$ 将 $\\mathbf{s}(t)$ 映射到角度来计算 $\\boldsymbol{\\phi}_{\\mathrm{true}}(t)$：每个分量 $\\phi_{\\mathrm{true}, i}(t)$ 是物理位移 $s_i(t)$ 根据周期 $\\lambda_i$ 缩放到弧度的值，然后卷绕到 $[0, 2\\pi)$。\n- 实现如上定义的卷绕差和均方根误差 $E$。\n\n测试套件：\n实现您的程序以运行以下五个案例，每个案例都由离散时间持续时长 $T$、时间步长 $dt$、空间周期 $\\boldsymbol{\\lambda}$、速度时间序列规范以及一个用于从推导中获得的降维相位动力学的模型耦合矩阵完全指定。所有角度单位为弧度；速度单位为 $\\mathrm{m/s}$；空间周期单位为 $\\mathrm{m}$。\n\n- 案例 1 (通用“理想路径”)：\n  - $T = 10.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$。\n  - 速度：对于所有 $t \\in [0, T]$，恒定速度 $\\mathbf{v}(t) = (0.1, 0.05)$。\n  - 模型耦合矩阵等于与 $\\boldsymbol{\\lambda}$ 一致的从速度到相位变化率的真实映射。\n- 案例 2 (高速下的边界卷绕)：\n  - $T = 2.0$, $dt = 0.005$, $\\boldsymbol{\\lambda} = (0.25, 0.30)$。\n  - 速度：对于所有 $t \\in [0, T]$，恒定速度 $\\mathbf{v}(t) = (1.2, -0.8)$。\n  - 模型耦合矩阵等于与 $\\boldsymbol{\\lambda}$ 一致的从速度到相位变化率的真实映射。\n- 案例 3 (增益失配)：\n  - $T = 10.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$。\n  - 速度：对于所有 $t \\in [0, T]$，恒定速度 $\\mathbf{v}(t) = (0.09, 0.07)$。\n  - 模型耦合矩阵是真实映射的缩放版本，其 $x$ 和 $y$ 分量的缩放因子分别为 $1.02$ 和 $0.97$。\n- 案例 4 (零速度边缘情况)：\n  - $T = 3.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.5, 0.5)$。\n  - 速度：对于所有 $t \\in [0, T]$，恒定速度 $\\mathbf{v}(t) = (0.0, 0.0)$。\n  - 模型耦合矩阵等于与 $\\boldsymbol{\\lambda}$ 一致的从速度到相位变化率的真实映射。\n- 案例 5 (旋转失配和正弦速度)：\n  - $T = 8.0$, $dt = 0.01$, $\\boldsymbol{\\lambda} = (0.45, 0.60)$。\n  - 速度：对于所有 $t \\in [0, T]$，$\\mathbf{v}(t) = \\big(0.4 \\sin(2\\pi \\cdot 0.5 \\, t),\\; 0.3 \\cos(2\\pi \\cdot 0.75 \\, t)\\big)$。\n  - 模型耦合矩阵是真实映射在输出（相位）空间中旋转角度 $\\theta = \\pi/12$ 后的版本。\n\n您的程序必须：\n- 对于每个案例，生成速度时间序列，使用推导出的降维模型模拟 $\\mathbb{T}^2$ 上的相位动力学，根据位移和空间周期计算“真实”相位，然后计算均方根测地线误差 $E$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个浮点数四舍五入到六位小数，并且没有空格。例如，输出应类似于 $[\\text{case1},\\text{case2},\\text{case3},\\text{case4},\\text{case5}]$，其中每个条目是相应案例的标量 $E$。",
            "solution": "我们从描述活动 $u(\\mathbf{x}, t)$ 的连续吸引子神经网络 (CANN) 神经场方程开始，该方程定义在 $\\mathbb{R}^2$ 上，具有空间平移不变的循环连接、一个静态非线性和一个外部输入：\n$$\n\\tau \\frac{\\partial u(\\mathbf{x}, t)}{\\partial t} = -u(\\mathbf{x}, t) + \\int_{\\mathbb{R}^2} w(\\mathbf{x} - \\mathbf{x}') \\, \\phi\\big(u(\\mathbf{x}', t)\\big)\\, d\\mathbf{x}' + I(\\mathbf{x}, t),\n$$\n其中 $\\tau$ 是时间常数，$w(\\mathbf{x} - \\mathbf{x}')$ 是一个平移不变核，$\\phi(\\cdot)$ 是一个静态增益函数，$I(\\mathbf{x}, t)$ 是一个外部输入。在类似于网格细胞的连续吸引子的标准假设下，由于平移对称性，存在一个由连续平移 $\\boldsymbol{\\theta} \\in \\mathbb{R}^2$ 参数化的稳态“颠簸”解 $u_0(\\mathbf{x} - \\boldsymbol{\\theta})$。连续解族的存在意味着存在一对与无穷小平移相关的中性 (Goldstone) 模态，由空间导数 $\\partial u_0 / \\partial x$ 和 $\\partial u_0 / \\partial y$ 给出。\n\n为了获得“颠簸”中心（环面上的相位）的低维动力学，我们将全动力学投影到由这些中性模态张成的子空间上。设与零本征值相关的伴随本征函数表示为 $\\psi_x(\\mathbf{x})$ 和 $\\psi_y(\\mathbf{x})$，并考虑一个使“颠簸”中心平移的微扰。将神经场方程乘以 $\\psi_i(\\mathbf{x})$ 并在空间上积分，可以分离出移动“颠簸”的贡献：\n$$\n\\frac{d\\theta_i}{dt} = \\kappa_i \\int_{\\mathbb{R}^2} I(\\mathbf{x}, t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial x_i}\\, d\\mathbf{x}, \\quad i \\in \\{x, y\\},\n$$\n其中 $\\kappa_i$ 是由伴随模态与 $u_0$ 导数的内积决定的归一化常数。如果外部输入通过与“颠簸”的空间导数耦合来编码物理速度，一个广泛使用的公式是\n$$\nI(\\mathbf{x}, t) = a_x v_x(t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial x} + a_y v_y(t)\\, \\frac{\\partial u_0(\\mathbf{x} - \\boldsymbol{\\theta})}{\\partial y},\n$$\n其中 $a_x$ 和 $a_y$ 是沿各轴的增益，$\\mathbf{v}(t) = (v_x(t), v_y(t))$ 是物理速度。代入此输入并利用模态的正交性，可得到“颠簸”中心速度与物理速度之间的线性关系：\n$$\n\\frac{d\\boldsymbol{\\theta}}{dt} = \\mathbf{B}\\, \\mathbf{v}(t),\n$$\n其中 $\\mathbf{B} \\in \\mathbb{R}^{2 \\times 2}$ 是一个由神经场、增益选择和“颠簸”形状决定的耦合矩阵。周期性边界条件将“颠簸”位置以各轴上的空间周期为模进行识别，从而产生一个环面 $\\mathbb{T}^2$。位移的每个分量 $\\theta_i$ 通过缩放与相位 $\\phi_i$ 相关，使得由空间周期 $\\lambda_i$ 引起的物理位移对应于 $2\\pi$ 的相位前进：\n$$\n\\phi_i = \\frac{2\\pi}{\\lambda_i} \\theta_i \\quad \\Rightarrow \\quad \\frac{d\\phi_i}{dt} = \\frac{2\\pi}{\\lambda_i} \\frac{d\\theta_i}{dt} = \\sum_{j \\in \\{x,y\\}} K_{ij}\\, v_j(t),\n$$\n其中\n$$\n\\mathbf{K} = \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)\\, \\mathbf{B}.\n$$\n对于一个能忠实地将速度转换为与空间周期一致的相位变化率的理想积分器，位移与相位之间的“真实”映射是\n$$\n\\boldsymbol{\\phi}_{\\mathrm{true}}(t) = \\operatorname{wrap}_{2\\pi}\\left(\\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right) \\, \\mathbf{s}(t)\\right),\n$$\n其中 $\\mathbf{s}(t) = \\int_0^t \\mathbf{v}(\\tau)\\, d\\tau$ 是物理位移，$\\operatorname{wrap}_{2\\pi}(\\cdot)$ 将每个角度分量卷绕到 $[0, 2\\pi)$。模拟模型的相位根据以下方式演化\n$$\n\\boldsymbol{\\phi}_{\\mathrm{model}}(t+\\Delta t) = \\operatorname{wrap}_{2\\pi}\\left(\\boldsymbol{\\phi}_{\\mathrm{model}}(t) + \\Delta t \\, \\mathbf{K}_{\\mathrm{model}} \\, \\mathbf{v}(t)\\right),\n$$\n其中 $\\mathbf{K}_{\\mathrm{model}}$ 是从降维动力学中获得的耦合矩阵（由于增益或方向失配，它可能与真实映射不同）。请注意，从 CANN 的推导通过对称性和模态投影证明了这种线性关系的存在；测试套件中使用的具体值实例化了不同的机制（完美映射、增益失配、旋转失配）。\n\n为了将模拟相位与“真实”相位进行比较，我们逐分量计算卷绕差\n$$\n\\Delta_i(t) = \\operatorname{wrap}_{\\pi}\\left(\\phi_{\\mathrm{model}, i}(t) - \\phi_{\\mathrm{true}, i}(t)\\right),\n$$\n其中 $\\operatorname{wrap}_{\\pi}(\\alpha) = ((\\alpha + \\pi) \\bmod 2\\pi) - \\pi$ 映射到 $(-\\pi, \\pi]$。瞬时测地线误差是\n$$\ne(t) = \\sqrt{\\Delta_x(t)^2 + \\Delta_y(t)^2},\n$$\n均方根误差是\n$$\nE = \\sqrt{\\frac{1}{N} \\sum_{n=1}^{N} e(t_n)^2},\n$$\n我们将其报告为四舍五入到六位小数的浮点数。\n\n算法设计：\n- 将时间离散化为 $N = \\lfloor T / dt \\rfloor$ 个步长，样本为 $t_n = n \\cdot dt$，其中 $n = 0, 1, \\ldots, N-1$。\n- 根据每个案例的规范生成速度时间序列 $\\mathbf{v}(t_n)$。\n- 初始化 $\\boldsymbol{\\phi}_{\\mathrm{model}}(0) = (0, 0)$ 和 $\\mathbf{s}(0) = (0, 0)$。\n- 在每个时间步，更新位移 $\\mathbf{s}(t_{n+1}) = \\mathbf{s}(t_n) + dt \\cdot \\mathbf{v}(t_n)$。\n- 通过用 $\\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$ 将 $\\mathbf{s}(t_{n+1})$ 缩放为弧度并卷绕到 $[0, 2\\pi)$ 来计算 $\\boldsymbol{\\phi}_{\\mathrm{true}}(t_{n+1})$。\n- 通过将 $dt \\cdot \\mathbf{K}_{\\mathrm{model}}\\mathbf{v}(t_n)$ 加到 $\\boldsymbol{\\phi}_{\\mathrm{model}}(t_n)$ 上并卷绕到 $[0, 2\\pi)$ 来更新 $\\boldsymbol{\\phi}_{\\mathrm{model}}(t_{n+1})$。\n- 计算卷绕差 $\\Delta_i(t_n)$、瞬时误差 $e(t_n)$，最后计算所有样本的均方根 $E$。\n- 对每个案例重复上述步骤，使用指定的 $\\boldsymbol{\\lambda}$ 和 $\\mathbf{K}_{\\mathrm{model}}$：\n  - 对于具有理想映射的案例，使用 $\\mathbf{K}_{\\mathrm{model}} = \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$。\n  - 对于增益失配，用指定的因子对分量进行缩放。\n  - 对于旋转失配，左乘一个旋转矩阵\n    $$\n    \\mathbf{R}(\\theta) = \\begin{bmatrix}\n    \\cos \\theta  -\\sin \\theta \\\\\n    \\sin \\theta  \\cos \\theta\n    \\end{bmatrix}\n    $$\n    以获得 $\\mathbf{K}_{\\mathrm{model}} = \\mathbf{R}(\\theta) \\operatorname{diag}\\left(\\frac{2\\pi}{\\lambda_x}, \\frac{2\\pi}{\\lambda_y}\\right)$。\n\n数值方面：\n- 使用模运算对 $[0, 2\\pi)$ 和 $(-\\pi, \\pi]$ 逐分量执行卷绕。\n- 通过选择相对于速度信号时间尺度足够小的 $dt$ 来最小化离散化误差。\n- 输出是单行文本，包含每个案例的 $E$ 值，形式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到六位小数，无空格。\n\n该设计整合了基于 CANN 对称性的降维方法，并实现了模拟环面相位轨迹与物理积分位移对应相位之间的原则性比较。",
            "answer": "```python\nimport numpy as np\n\ndef wrap_to_2pi(angle):\n    # Wrap angles to [0, 2*pi)\n    return (angle % (2.0 * np.pi))\n\ndef wrap_to_pi(angle):\n    # Wrap angles to (-pi, pi]\n    return ((angle + np.pi) % (2.0 * np.pi)) - np.pi\n\ndef simulate_case(T, dt, lam, velocity_fn, K_model):\n    \"\"\"\n    Simulate phase dynamics on T^2 for a given velocity time series and model coupling.\n    Compute RMS geodesic error against true displacement-derived phase.\n\n    Parameters:\n    - T: duration (seconds)\n    - dt: timestep (seconds)\n    - lam: spatial periods (lambda_x, lambda_y) in meters\n    - velocity_fn: function returning velocity array shape (N, 2)\n    - K_model: 2x2 matrix mapping velocity to phase rate (radians per second)\n    \"\"\"\n    N = int(np.round(T / dt))\n    t = np.arange(N) * dt\n    v = velocity_fn(t)  # shape (N,2)\n\n    # True mapping from displacement to phase\n    K_true = np.diag(2.0 * np.pi / np.array(lam))\n\n    # Initialize displacement and phases\n    s = np.zeros(2)              # physical displacement (m)\n    phi_model = np.zeros(2)      # model phase (rad)\n    phi_true = np.zeros(2)       # true phase (rad)\n\n    errors_sq = np.zeros(N)\n\n    for n in range(N):\n        vn = v[n]\n\n        # Update displacement\n        s = s + dt * vn  # integrate velocity\n\n        # True phase from displacement\n        phi_true = wrap_to_2pi(K_true @ s)\n\n        # Model phase update from velocity\n        phi_model = wrap_to_2pi(phi_model + dt * (K_model @ vn))\n\n        # Wrapped difference and instantaneous geodesic error\n        delta = wrap_to_pi(phi_model - phi_true)\n        errors_sq[n] = np.sum(delta**2)\n\n    rms_error = float(np.sqrt(np.mean(errors_sq)))\n    return rms_error\n\ndef velocity_constant_factory(vx, vy):\n    def vfn(t):\n        return np.column_stack((np.full_like(t, vx, dtype=float),\n                                np.full_like(t, vy, dtype=float)))\n    return vfn\n\ndef velocity_sinusoidal_factory(ax, fx, ay, fy):\n    def vfn(t):\n        vx = ax * np.sin(2.0 * np.pi * fx * t)\n        vy = ay * np.cos(2.0 * np.pi * fy * t)\n        return np.column_stack((vx, vy))\n    return vfn\n\ndef solve():\n    # Define test cases as tuples: (T, dt, lambda, velocity_fn, K_model)\n    test_cases = []\n\n    # Case 1: Happy path\n    T1, dt1 = 10.0, 0.01\n    lam1 = (0.5, 0.5)\n    vfn1 = velocity_constant_factory(0.1, 0.05)\n    K_true1 = np.diag(2.0 * np.pi / np.array(lam1))\n    K_model1 = K_true1.copy()\n    test_cases.append((T1, dt1, lam1, vfn1, K_model1))\n\n    # Case 2: High velocity wrapping\n    T2, dt2 = 2.0, 0.005\n    lam2 = (0.25, 0.30)\n    vfn2 = velocity_constant_factory(1.2, -0.8)\n    K_true2 = np.diag(2.0 * np.pi / np.array(lam2))\n    K_model2 = K_true2.copy()\n    test_cases.append((T2, dt2, lam2, vfn2, K_model2))\n\n    # Case 3: Gain mismatch\n    T3, dt3 = 10.0, 0.01\n    lam3 = (0.5, 0.5)\n    vfn3 = velocity_constant_factory(0.09, 0.07)\n    K_true3 = np.diag(2.0 * np.pi / np.array(lam3))\n    scale = np.diag([1.02, 0.97])\n    K_model3 = scale @ K_true3\n    test_cases.append((T3, dt3, lam3, vfn3, K_model3))\n\n    # Case 4: Zero velocity\n    T4, dt4 = 3.0, 0.01\n    lam4 = (0.5, 0.5)\n    vfn4 = velocity_constant_factory(0.0, 0.0)\n    K_true4 = np.diag(2.0 * np.pi / np.array(lam4))\n    K_model4 = K_true4.copy()\n    test_cases.append((T4, dt4, lam4, vfn4, K_model4))\n\n    # Case 5: Rotational mismatch + sinusoidal velocity\n    T5, dt5 = 8.0, 0.01\n    lam5 = (0.45, 0.60)\n    vfn5 = velocity_sinusoidal_factory(ax=0.4, fx=0.5, ay=0.3, fy=0.75)\n    K_true5 = np.diag(2.0 * np.pi / np.array(lam5))\n    theta = np.pi / 12.0\n    R = np.array([[np.cos(theta), -np.sin(theta)],\n                  [np.sin(theta),  np.cos(theta)]])\n    K_model5 = R @ K_true5\n    test_cases.append((T5, dt5, lam5, vfn5, K_model5))\n\n    results = []\n    for (T, dt, lam, vfn, K_model) in test_cases:\n        rms_err = simulate_case(T, dt, lam, vfn, K_model)\n        results.append(f\"{rms_err:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "理论模型的价值在于其与数据的联系。本练习将让您扮演实验科学家的角色，尝试标定一个网格细胞的路径积分机制。您将利用一组模拟的相位移位测量数据——这些数据源于沿不同方向的运动——通过线性回归  来估计模型中潜在的速度通道增益。这是验证连续吸引子理论和确定其参数的关键一步。",
            "id": "3985846",
            "problem": "您正在对网格细胞的连续吸引子神经网络（CANN）模型中的速度-相位耦合进行建模。在一个常见的公式中，沿物理方向角度为 $\\alpha$（以弧度为单位）的平移运动会驱动三个具有优先方向 $\\theta_1$、$\\theta_2$、$\\theta_3$（以弧度为单位）的速度通道，每个通道都对内部相移产生线性贡献。假设以下经过充分检验的基本假设：(i) 通道对内部相位速度贡献的线性叠加，(ii) 运动在具有优先方向 $\\theta_i$ 的通道上的投影与 $\\cos(\\alpha - \\theta_i)$ 成正比，以及 (iii) 观测到的相移上存在独立同分布的高斯测量噪声。\n\n设在固定位移大小 $D$（以米为单位）上观测到的标量内部相移为 $y(\\alpha)$（以弧度为单位）。对于角度为 $\\{\\alpha_k\\}_{k=1}^K$ 的运动，假设模型为\n$$\ny_k \\equiv y(\\alpha_k) \\;=\\; D \\sum_{i=1}^3 g_i \\, \\cos(\\alpha_k - \\theta_i) \\;+\\; \\varepsilon_k,\n$$\n其中 $g_i$（单位为弧度/米）是待估计的未知通道增益，而 $\\varepsilon_k \\sim \\mathcal{N}(0,\\sigma^2)$ 是具有已知方差 $\\sigma^2$（单位为弧度的平方）的独立高斯测量误差。定义 $K \\times 3$ 的设计矩阵 $X$，其元素为\n$$\nX_{k,i} \\;=\\; D \\, \\cos(\\alpha_k - \\theta_i).\n$$\n给定测量值 $\\mathbf{y} \\in \\mathbb{R}^K$，高斯噪声下的最大似然估计（MLE）与最小二乘解一致\n$$\n\\widehat{\\mathbf{g}} \\;=\\; \\arg\\min_{\\mathbf{g} \\in \\mathbb{R}^3} \\, \\|X \\mathbf{g} - \\mathbf{y}\\|_2^2,\n$$\n并且估计器的不确定性（协方差）为\n$$\n\\mathrm{Cov}(\\widehat{\\mathbf{g}}) \\;=\\; \\sigma^2 (X^\\top X)^{-1},\n$$\n前提是 $X^\\top X$ 是可逆的。当 $X^\\top X$ 是病态的（ill-conditioned）时，使用 Moore–Penrose 伪逆来计算 $(X^\\top X)^{-1}$。\n\n任务：编写一个完整的程序，对下面的每个测试用例，构建 $X$，通过最小二乘法拟合 $\\widehat{\\mathbf{g}}$，并报告估计的增益及其一倍标准差不确定性，即从 $\\mathrm{Cov}(\\widehat{\\mathbf{g}})$ 计算的逐元素标准差 $\\sqrt{\\mathrm{diag}(\\mathrm{Cov}(\\widehat{\\mathbf{g}}))}$。角度必须以弧度为单位，增益必须以弧度/米为单位报告。将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n使用以下测试套件。在所有情况下，优先通道方向固定为 $\\theta_1 = 0$、$\\theta_2 = \\pi/3$、$\\theta_3 = 2\\pi/3$，位移大小为 $D = 1$ 米。对于每个用例，测量数据 $y_k$ 是使用给定的真实增益通过模型 $y_k = \\sum_{i=1}^3 g_i \\cos(\\alpha_k - \\theta_i)$ 合成的，没有添加噪声（即，为生成数据设置 $\\varepsilon_k = 0$），但已知的测量噪声标准差 $\\sigma$ 仍应用于计算不确定性。\n\n- 测试用例 1（良态采样）：\n  - 真实增益 $\\mathbf{g}^\\star = [\\,0.8,\\, 1.1,\\, 0.5\\,]$，单位为弧度/米。\n  - 角度 $\\{\\alpha_k\\}$（以弧度为单位）：$\\{\\,0,\\; \\pi/4,\\; \\pi/2,\\; 3\\pi/4,\\; \\pi,\\; 5\\pi/4,\\; 3\\pi/2,\\; 7\\pi/4\\,\\}$。\n  - 已知噪声标准差 $\\sigma = 0.05$ 弧度。\n\n- 测试用例 2（最小样本量 $K=3$）：\n  - 真实增益 $\\mathbf{g}^\\star = [\\,1.0,\\, 0.2,\\, -0.1\\,]$，单位为弧度/米。\n  - 角度 $\\{\\alpha_k\\}$（以弧度为单位）：$\\{\\,0,\\; \\pi/3,\\; 2\\pi/3\\,\\}$。\n  - 已知噪声标准差 $\\sigma = 0.05$ 弧度。\n\n- 测试用例 3（近共线采样）：\n  - 真实增益 $\\mathbf{g}^\\star = [\\,0.3,\\, 0.9,\\, 1.2\\,]$，单位为弧度/米。\n  - 角度 $\\{\\alpha_k\\}$（以弧度为单位）：$\\{\\, \\pi/6 - 0.2,\\; \\pi/6 - 0.1,\\; \\pi/6,\\; \\pi/6 + 0.1,\\; \\pi/6 + 0.2 \\,\\}$。\n  - 已知噪声标准差 $\\sigma = 0.2$ 弧度。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个包含六个浮点数的列表，顺序为 $[\\,\\widehat{g}_1,\\widehat{g}_2,\\widehat{g}_3, u_1,u_2,u_3\\,]$，其中 $u_i$ 是 $\\widehat{g}_i$ 的一倍标准差不确定性。因此，总输出必须是表示包含三个列表的列表的单行：\n$$\n[\\,[\\widehat{g}_1,\\widehat{g}_2,\\widehat{g}_3,u_1,u_2,u_3],\\;[\\cdots],\\;[\\cdots]\\,].\n$$\n将每个浮点数四舍五入到 $6$ 位小数。所有角度都必须以弧度为单位，增益和不确定性必须以弧度/米为单位报告。",
            "solution": "该问题要求对网格细胞的连续吸引子神经网络模型估计通道增益及其相应的不确定性。其潜在的数学框架是线性回归。\n\n在给定运动角度 $\\alpha_k$ 时，观测到的相移 $y_k$ 的模型由下式给出\n$$\ny_k = D \\sum_{i=1}^3 g_i \\, \\cos(\\alpha_k - \\theta_i) + \\varepsilon_k\n$$\n其中 $g_i$ 是未知增益，$D$ 是位移大小，$\\theta_i$ 是优先通道方向，$\\varepsilon_k$ 是独立同分布的高斯噪声项，$\\varepsilon_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n这可以用矩阵形式表示为一个线性模型：\n$$\n\\mathbf{y} = X \\mathbf{g} + \\boldsymbol{\\varepsilon}\n$$\n这里，$\\mathbf{y} \\in \\mathbb{R}^K$ 是 $K$ 个相移测量的向量，$\\mathbf{g} = [g_1, g_2, g_3]^\\top$ 是未知增益的向量，$\\boldsymbol{\\varepsilon} \\in \\mathbb{R}^K$ 是噪声项的向量，而 $X \\in \\mathbb{R}^{K \\times 3}$ 是设计矩阵。设计矩阵的元素由 $X_{k,i} = D \\cos(\\alpha_k - \\theta_i)$ 给出。\n\n在高斯噪声假设下，$\\mathbf{g}$ 的最大似然估计（MLE）对应于普通最小二乘（OLS）解，该解最小化残差平方和：\n$$\n\\widehat{\\mathbf{g}} = \\arg\\min_{\\mathbf{g} \\in \\mathbb{R}^3} \\|X \\mathbf{g} - \\mathbf{y}\\|_2^2\n$$\n这个最小化问题的解由正规方程给出：$\\widehat{\\mathbf{g}} = (X^\\top X)^{-1} X^\\top \\mathbf{y}$，前提是矩阵 $X^\\top X$ 是可逆的。在 $X^\\top X$ 是奇异或病态（即其列线性相关或近似线性相关）的情况下，无法确定 $\\mathbf{g}$ 的唯一解。在这种情况下，标准方法是使用 Moore-Penrose 伪逆，用上标 ‘$+$’ 表示。估计器则由 $\\widehat{\\mathbf{g}} = X^+ \\mathbf{y}$ 给出，它提供了具有最小欧几里得范数 $\\|\\mathbf{g}\\|_2$ 的解。由于此问题的合成数据是在没有噪声的情况下生成的，即 $\\mathbf{y} = X \\mathbf{g}^\\star$，因此最小二乘拟合将完美匹配数据点。如果 $X^\\top X$ 是可逆的，估计器将精确恢复真实增益，$\\widehat{\\mathbf{g}} = \\mathbf{g}^\\star$。如果 $X^\\top X$ 是奇异的，$\\widehat{\\mathbf{g}}$ 将是最小范数解，这不一定等于 $\\mathbf{g}^\\star$。\n\n估计器 $\\widehat{\\mathbf{g}}$ 的不确定性由其协方差矩阵捕获。对于 OLS 估计器，协方差为：\n$$\n\\mathrm{Cov}(\\widehat{\\mathbf{g}}) = \\sigma^2 (X^\\top X)^{-1}\n$$\n与估计器本身的处理方式一致，如果 $X^\\top X$ 不可逆，我们使用其伪逆：\n$$\n\\mathrm{Cov}(\\widehat{\\mathbf{g}}) = \\sigma^2 (X^\\top X)^+\n$$\n每个估计增益 $\\widehat{g}_i$ 的一倍标准差不确定性是协方差矩阵对应对角线项的平方根：\n$$\nu_i = \\sqrt{(\\mathrm{Cov}(\\widehat{\\mathbf{g}}))_{i,i}}\n$$\n\n每个测试用例的计算过程如下：\n1.  定义固定参数：$D=1$，$\\theta = [0, \\pi/3, 2\\pi/3]^\\top$。\n2.  对于给定的运动角度集 $\\{\\alpha_k\\}_{k=1}^K$，构建 $K \\times 3$ 的设计矩阵 $X$，其元素为 $X_{k,i} = D \\cos(\\alpha_k - \\theta_i)$。\n3.  使用真实增益 $\\mathbf{g}^\\star$ 生成无噪声的测量向量 $\\mathbf{y} = X \\mathbf{g}^\\star$。\n4.  通过求解线性最小二乘问题来计算估计增益 $\\widehat{\\mathbf{g}}$，例如，使用一个标准的数值库函数，该函数将通过寻找最小范数解来隐式处理秩亏问题。\n5.  计算矩阵乘积 $C = X^\\top X$。\n6.  计算伪逆 $C^+$。\n7.  使用给定的噪声标准差 $\\sigma$ 计算协方差矩阵 $\\mathrm{Cov}(\\widehat{\\mathbf{g}}) = \\sigma^2 C^+$。\n8.  通过取 $\\mathrm{Cov}(\\widehat{\\mathbf{g}})$ 对角线元素的平方根来提取不确定性 $u_i$。\n9.  收集并报告估计的增益 $\\widehat{\\mathbf{g}}$ 和不确定性 $\\mathbf{u} = [u_1,u_2,u_3]^\\top$，并四舍五入到指定的精度。此过程系统地应用于所有测试用例。不同的测试用例探讨了具有良态、秩亏和病态设计矩阵的场景，从而测试了此过程的稳健性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves for the estimated gains and their uncertainties in a grid cell\n    continuous attractor model for three test cases.\n    \"\"\"\n    \n    # Fixed parameters for all test cases\n    D = 1.0  # meters\n    thetas = np.array([0, np.pi/3, 2*np.pi/3]) # radians\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"true_gains\": np.array([0.8, 1.1, 0.5]),\n            \"alphas\": np.array([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi, 5*np.pi/4, 3*np.pi/2, 7*np.pi/4]),\n            \"sigma\": 0.05\n        },\n        {\n            \"true_gains\": np.array([1.0, 0.2, -0.1]),\n            \"alphas\": np.array([0, np.pi/3, 2*np.pi/3]),\n            \"sigma\": 0.05\n        },\n        {\n            \"true_gains\": np.array([0.3, 0.9, 1.2]),\n            \"alphas\": np.array([np.pi/6 - 0.2, np.pi/6 - 0.1, np.pi/6, np.pi/6 + 0.1, np.pi/6 + 0.2]),\n            \"sigma\": 0.2\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        g_star = case[\"true_gains\"]\n        alphas = case[\"alphas\"]\n        sigma = case[\"sigma\"]\n        \n        K = len(alphas)\n        \n        # 1. Construct the design matrix X\n        X = np.zeros((K, 3))\n        for k in range(K):\n            for i in range(3):\n                X[k, i] = D * np.cos(alphas[k] - thetas[i])\n        \n        # 2. Generate the measurement vector y (noise-free)\n        y = X @ g_star\n        \n        # 3. Estimate gains g_hat using least squares\n        # np.linalg.lstsq returns the minimum-norm solution for rank-deficient cases\n        g_hat, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        # 4. Calculate the covariance matrix and uncertainties\n        # Use Moore-Penrose pseudoinverse as specified\n        XTX = X.T @ X\n        XTX_pinv = np.linalg.pinv(XTX)\n        cov_g_hat = sigma**2 * XTX_pinv\n        \n        # Uncertainties are the sqrt of the diagonal elements\n        uncertainties = np.sqrt(np.diag(cov_g_hat))\n        \n        # 5. Format and store results\n        # Round all floats to 6 decimal places\n        g_hat_rounded = np.round(g_hat, 6)\n        uncertainties_rounded = np.round(uncertainties, 6)\n        \n        result_for_case = g_hat_rounded.tolist() + uncertainties_rounded.tolist()\n        all_results.append(result_for_case)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to its string representation\n    # This avoids adding spaces after commas within the inner lists\n    str_results = [str(res).replace(\" \", \"\") for res in all_results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```"
        }
    ]
}