{
    "hands_on_practices": [
        {
            "introduction": "要掌握像渗漏竞争累积（LCA）模型这样的复杂模型，一个有效的方法是从一个简化的确定性版本入手。这个练习旨在通过分析决策变量的动态演化，揭示证据渗漏和相互竞争之间的基本相互作用。通过完成这项实践，您将推导决策信号差异的解析解，并深入理解渗漏和竞争如何共同作用，形成一个有效的速率参数，从而决定系统的稳定性以及决策信息是累积、衰减还是放大。",
            "id": "3993653",
            "problem": "考虑一个双择一强迫选择 (2AFC) 渗漏竞争累积器 (LCA) 模型，其中有两个累积器 $x_1(t)$ 和 $x_2(t)$，在恒定输入 $s_1$ 和 $s_2$ 的作用下演化。该动力学由一个线性时不变常微分方程组控制，该方程组结合了渗漏、相互抑制（竞争）和恒定输入，具体如下：\n$$\n\\frac{dx_1}{dt} = -\\lambda x_1 - \\beta x_2 + s_1,\\quad\n\\frac{dx_2}{dt} = -\\lambda x_2 - \\beta x_1 + s_2,\n$$\n其中 $\\lambda \\ge 0$ 是渗漏率，$\\beta \\ge 0$ 是竞争强度，$s_1, s_2$ 是恒定输入幅值。假设对于所有 $t \\ge 0$，初始条件为 $x_1(0) = x_2(0) = 0$，且输入为恒定值。定义决策相关差分信号 $d(t) \\triangleq x_1(t) - x_2(t)$ 和输入差值 $\\Delta s \\triangleq s_1 - s_2$。\n\n仅从上述定义以及“具有常数系数和常数驱动项的线性一阶常微分方程存在闭式解”这一基本法则出发，推导出 $d(t)$ 的时间进程，并刻画在不相等的输入 $(s_1,s_2)$ 下，由参数组合 $k \\triangleq \\lambda - \\beta$ 量化的渗漏与竞争之间的相互作用如何塑造 $d(t)$ 的行为。\n\n你的任务是：\n1. 在所述初始条件下，针对 $k$ 的所有情况（严格为正、为零和严格为负），推导出 $d(t)$ 的闭式表达式。\n2. 对于任意 $T  0$，推导出积分 $I(T) \\triangleq \\int_0^T d(t)\\,dt$ 的闭式表达式。\n3. 定义一个有效特征时间常数 $\\tau$，用于量化当 $d(t)$ 存在向稳态值的指数趋近过程时该过程的速率。在其良定义时，将其值指定为浮点数；在其未定义时，指定一个哨兵值。当特征时间常数不存在时，使用哨兵值 $-1.0$。\n4. 实现一个程序，对于下面给出的测试套件，为每种情况计算三元组 $\\left[d(T), I(T), \\tau\\right]$。\n\n时间应以秒为单位表示。所有输出都应为不带单位的实数。使用以下参数值测试套件：\n- 情况 1（稳定，不相等输入）：$\\lambda = 1.0$，$\\beta = 0.3$， $s_1 = 0.8$， $s_2 = 0.2$，$T = 1.0$ s。\n- 情况 2（边界，渗漏与竞争相等）：$\\lambda = 0.5$，$\\beta = 0.5$， $s_1 = 0.6$，$s_2 = 0.4$，$T = 1.5$ s。\n- 情况 3（不稳定差分模式）：$\\lambda = 0.4$，$\\beta = 0.9$，$s_1 = 0.5$，$s_2 = 0.2$，$T = 1.0$ s。\n- 情况 4（稳定，负输入差值）：$\\lambda = 1.2$，$\\beta = 0.6$，$s_1 = 0.1$，$s_2 = 0.4$，$T = 2.0$ s。\n- 情况 5（强渗漏主导竞争）：$\\lambda = 2.0$，$\\beta = 0.1$，$s_1 = 1.0$，$s_2 = 0.9$，$T = 0.5$ s。\n\n你的程序应生成单行输出，其中包含一个由五个三元列表组成的逗号分隔列表，每个子列表按 $\\left[d(T), I(T), \\tau\\right]$ 的顺序列出，并用方括号括起来。例如，一个有效的输出格式是\n$$\n\\left[ [d_1, I_1, \\tau_1], [d_2, I_2, \\tau_2], [d_3, I_3, \\tau_3], [d_4, I_4, \\tau_4], [d_5, I_5, \\tau_5] \\right],\n$$\n其中每个 $d_i$、$I_i$ 和 $\\tau_i$ 是以标准十进制表示法打印的实数。",
            "solution": "用户希望我分析一个双择一强迫选择 (2AFC) 渗漏竞争累积器 (LCA) 模型。\n\n### 第 1 步：问题验证\n\n我将首先提取已知条件，然后验证问题陈述。\n\n#### 已知条件提取\n- **模型动力学**：两个累积器 $x_1(t)$ 和 $x_2(t)$ 的动力学由以下常微分方程组 (ODEs) 给出：\n  $$\n  \\frac{dx_1}{dt} = -\\lambda x_1 - \\beta x_2 + s_1\n  $$\n  $$\n  \\frac{dx_2}{dt} = -\\lambda x_2 - \\beta x_1 + s_2\n  $$\n- **参数**：\n  - 渗漏率：$\\lambda \\ge 0$\n  - 竞争强度：$\\beta \\ge 0$\n  - 恒定输入：$s_1$, $s_2$\n- **初始条件**：对于所有 $t \\ge 0$，$x_1(0) = 0$ 且 $x_2(0) = 0$。\n- **定义**：\n  - 决策相关差分信号：$d(t) \\triangleq x_1(t) - x_2(t)$\n  - 输入差值：$\\Delta s \\triangleq s_1 - s_2$\n  - 有效速率参数：$k \\triangleq \\lambda - \\beta$\n- **任务**：\n  1. 推导 $d(t)$ 的闭式表达式。\n  2. 推导积分 $I(T) \\triangleq \\int_0^T d(t)\\,dt$ 的闭式表达式。\n  3. 定义并推导有效特征时间常数 $\\tau$。如果未定义，则使用哨兵值 $-1.0$。\n  4. 实现一个程序，为给定的测试套件计算 $[d(T), I(T), \\tau]$。\n- **测试套件**：\n  - 情况 1: $\\lambda = 1.0, \\beta = 0.3, s_1 = 0.8, s_2 = 0.2, T = 1.0$\n  - 情况 2: $\\lambda = 0.5, \\beta = 0.5, s_1 = 0.6, s_2 = 0.4, T = 1.5$\n  - 情况 3: $\\lambda = 0.4, \\beta = 0.9, s_1 = 0.5, s_2 = 0.2, T = 1.0$\n  - 情况 4: $\\lambda = 1.2, \\beta = 0.6, s_1 = 0.1, s_2 = 0.4, T = 2.0$\n  - 情况 5: $\\lambda = 2.0, \\beta = 0.1, s_1 = 1.0, s_2 = 0.9, T = 0.5$\n- **输出格式**：包含由五个三元列表组成的逗号分隔列表的单行：`[[d1, I1, tau1], [d2, I2, tau2], [d3, I3, tau3], [d4, I4, tau4], [d5, I5, tau5]]`。\n\n#### 验证与结论\n- **科学依据**：该问题描述了计算神经科学中的一个简化但标准的模型，即渗漏竞争累积器。其动力学由一个线性一阶常微分方程组表示，这是一个基本且已被充分理解的数学框架。该问题在科学上和数学上都是合理的。\n- **良定性**：该问题是良定的。它提供了两个具有常数系数、恒定驱动项和指定初始条件的一阶常微分方程。这种结构保证了对于所有时间 $t \\ge 0$ 都存在唯一解。各项任务是基于此系统的特定数学推导和计算。\n- **客观性**：语言精确、定量，且无主观成分。所有术语都有明确定义。\n- **完整性与一致性**：问题陈述是完整的，提供了推导所需量所需的所有必要参数、定义和初始条件。没有矛盾之处。\n\n该问题是有效的。我将继续进行求解。\n\n### 第 2 步：推导与求解\n\n#### 任务 1：差分信号 $d(t)$ 的推导\n已知 $x_1(t)$ 和 $x_2(t)$ 的常微分方程组为：\n$$\n\\frac{dx_1}{dt} = -\\lambda x_1 - \\beta x_2 + s_1\n$$\n$$\n\\frac{dx_2}{dt} = -\\lambda x_2 - \\beta x_1 + s_2\n$$\n决策相关差分信号定义为 $d(t) \\triangleq x_1(t) - x_2(t)$。我们可以通过求其时间导数 $\\frac{d}{dt} d(t)$ 来找到 $d(t)$ 的微分方程：\n$$\n\\frac{d}{dt}d(t) = \\frac{dx_1}{dt} - \\frac{dx_2}{dt}\n$$\n代入 $\\frac{dx_1}{dt}$ 和 $\\frac{dx_2}{dt}$ 的表达式：\n$$\n\\frac{d}{dt}d(t) = (-\\lambda x_1 - \\beta x_2 + s_1) - (-\\lambda x_2 - \\beta x_1 + s_2)\n$$\n重新整理各项：\n$$\n\\frac{d}{dt}d(t) = -\\lambda (x_1 - x_2) - \\beta (x_2 - x_1) + (s_1 - s_2)\n$$\n$$\n\\frac{d}{dt}d(t) = -\\lambda (x_1 - x_2) + \\beta (x_1 - x_2) + (s_1 - s_2)\n$$\n提取公因式 $(x_1 - x_2)$：\n$$\n\\frac{d}{dt}d(t) = -(\\lambda - \\beta)(x_1 - x_2) + (s_1 - s_2)\n$$\n使用定义 $d(t) = x_1(t) - x_2(t)$、$k = \\lambda - \\beta$ 和 $\\Delta s = s_1 - s_2$，我们得到关于 $d(t)$ 的一个一阶线性常微分方程：\n$$\n\\frac{dd}{dt} = -k d(t) + \\Delta s\n$$\n$d(t)$ 的初始条件为 $d(0) = x_1(0) - x_2(0) = 0 - 0 = 0$。\n\n我们通过考虑参数 $k$ 的两种情况来求解此常微分方程。\n\n**情况 1：$k \\neq 0$**\n该常微分方程为 $\\frac{dd}{dt} + k d = \\Delta s$。这是一个标准的非齐次线性常微分方程。其通解是齐次解 ($d_h$) 和一个特解 ($d_p$) 的和。\n齐次方程为 $\\frac{dd_h}{dt} + k d_h = 0$，其解为 $d_h(t) = C e^{-kt}$，其中 $C$ 是某个常数。\n对于特解，由于驱动项 $\\Delta s$ 是常数，我们尝试一个常数解 $d_p(t) = A$。代入常微分方程得到 $0 + kA = \\Delta s$，因此 $A = \\frac{\\Delta s}{k}$。\n通解为 $d(t) = d_h(t) + d_p(t) = C e^{-kt} + \\frac{\\Delta s}{k}$。\n应用初始条件 $d(0) = 0$：\n$0 = C e^{0} + \\frac{\\Delta s}{k} \\implies C = -\\frac{\\Delta s}{k}$。\n因此，当 $k \\neq 0$ 时，解为：\n$$\nd(t) = \\frac{\\Delta s}{k} (1 - e^{-kt})\n$$\n\n**情况 2：$k = 0$**\n常微分方程简化为 $\\frac{dd}{dt} = \\Delta s$。\n对 $t$ 积分得到 $d(t) = (\\Delta s)t + C$。\n应用初始条件 $d(0) = 0$：\n$0 = (\\Delta s)(0) + C \\implies C = 0$。\n因此，当 $k = 0$ 时，解为：\n$$\nd(t) = (\\Delta s)t\n$$\n综合两种情况，$d(t)$ 的闭式表达式为：\n$$\nd(t) = \\begin{cases} \\frac{\\Delta s}{k} (1 - e^{-kt})  \\text{若 } k \\neq 0 \\\\ (\\Delta s) t  \\text{若 } k = 0 \\end{cases}\n$$\n\n#### 任务 2：积分 $I(T)$ 的推导\n我们需要计算 $I(T) \\triangleq \\int_0^T d(t)\\,dt$。我们再次考虑 $k$ 的两种情况。\n\n**情况 1：$k \\neq 0$**\n$$\nI(T) = \\int_0^T \\frac{\\Delta s}{k} (1 - e^{-kt}) dt = \\frac{\\Delta s}{k} \\int_0^T (1 - e^{-kt}) dt\n$$\n$$\nI(T) = \\frac{\\Delta s}{k} \\left[ t - \\frac{e^{-kt}}{-k} \\right]_0^T = \\frac{\\Delta s}{k} \\left[ t + \\frac{e^{-kt}}{k} \\right]_0^T\n$$\n$$\nI(T) = \\frac{\\Delta s}{k} \\left( \\left( T + \\frac{e^{-kT}}{k} \\right) - \\left( 0 + \\frac{e^{0}}{k} \\right) \\right)\n$$\n$$\nI(T) = \\frac{\\Delta s}{k} \\left( T + \\frac{e^{-kT} - 1}{k} \\right)\n$$\n\n**情况 2：$k = 0$**\n$$\nI(T) = \\int_0^T (\\Delta s)t \\, dt = \\Delta s \\left[ \\frac{t^2}{2} \\right]_0^T\n$$\n$$\nI(T) = \\frac{\\Delta s T^2}{2}\n$$\n综合两种情况，$I(T)$ 的闭式表达式为：\n$$\nI(T) = \\begin{cases} \\frac{\\Delta s}{k} \\left( T + \\frac{e^{-kT} - 1}{k} \\right)  \\text{若 } k \\neq 0 \\\\ \\frac{\\Delta s T^2}{2}  \\text{若 } k = 0 \\end{cases}\n$$\n\n#### 任务 3：时间常数 $\\tau$ 的推导\n特征时间常数 $\\tau$ 量化了向稳态值指数趋近的速率。这种情况发生在动力学系统稳定时。\n查看当 $k \\neq 0$ 时 $d(t)$ 的解，$d(t) = \\frac{\\Delta s}{k} (1 - e^{-kt})$。\n项 $e^{-kt}$ 代表解的暂态部分。\n- 如果 $k  0$，那么当 $t \\to \\infty$ 时，$e^{-kt} \\to 0$，并且 $d(t)$ 趋近于稳态值 $d_{ss} = \\frac{\\Delta s}{k}$。系统是稳定的。时间进程是向该值的指数趋近。指数项的形式为 $e^{-t/\\tau}$，这意味着 $-kt = -t/\\tau$，所以 $\\tau = 1/k$。\n- 如果 $k  0$，令 $k = -|\\gamma|$，其中 $\\gamma  0$。那么 $d(t) = \\frac{\\Delta s}{-|\\gamma|} (1 - e^{|\\gamma|t})$。当 $t \\to \\infty$ 时，$d(t)$ 呈指数发散。系统是不稳定的，不会趋近于一个稳态值。因此，趋近稳态的特征时间常数没有定义。\n- 如果 $k = 0$，$d(t) = (\\Delta s)t$。信号线性增长或衰减（如果 $\\Delta s \\neq 0$），并且不趋近于一个稳态值。时间常数没有定义。\n\n因此，有效特征时间常数 $\\tau$ 仅在 $k  0$ 时有良定义。对于其未定义的情况，使用指定的哨兵值 $-1.0$：\n$$\n\\tau = \\begin{cases} 1/k = 1/(\\lambda - \\beta)  \\text{若 } k  0 \\\\ -1.0  \\text{若 } k \\le 0 \\end{cases}\n$$\n这个形式化完全刻画了 $d(t)$ 行为与 $k = \\lambda - \\beta$ 的关系：\n- $k  0$（渗漏大于竞争）：差分信号 $d(t)$ 指数趋近于一个稳定的稳态值 $\\frac{\\Delta s}{k}$。系统是稳定的。\n- $k = 0$（渗漏等于竞争）：差分信号 $d(t)$ 对输入差值 $\\Delta s$ 进行完美积分，导致线性增长/衰减。\n- $k  0$（竞争大于渗漏）：差分信号 $d(t)$ 在输入差值 $\\Delta s$ 的驱动下表现出指数增长。系统是不稳定的。\n\n#### 任务 4：实现\n推导出的公式将在 Python 中实现，以计算测试套件所需的值。该实现将根据推导，将 $k=0$ 的特殊情况与 $k \\ne 0$ 的情况分开处理。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the difference signal d(T), its integral I(T), and the\n    characteristic time constant tau for a 2AFC Leaky Competing Accumulator model\n    for several parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda, beta, s1, s2, T)\n    test_cases = [\n        # Case 1 (stable, unequal inputs)\n        (1.0, 0.3, 0.8, 0.2, 1.0),\n        # Case 2 (boundary, equal leak and competition)\n        (0.5, 0.5, 0.6, 0.4, 1.5),\n        # Case 3 (unstable difference mode)\n        (0.4, 0.9, 0.5, 0.2, 1.0),\n        # Case 4 (stable, negative input difference)\n        (1.2, 0.6, 0.1, 0.4, 2.0),\n        # Case 5 (strong leak dominating competition)\n        (2.0, 0.1, 1.0, 0.9, 0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lmbda, beta, s1, s2, T = case\n        \n        # Calculate intermediate parameters\n        delta_s = s1 - s2\n        k = lmbda - beta\n        \n        # Calculate d(T), I(T), and tau based on the value of k\n        \n        # Case 1: k is non-zero\n        if k != 0:\n            # Derived formula for d(t) = (delta_s / k) * (1 - exp(-k * t))\n            d_T = (delta_s / k) * (1 - np.exp(-k * T))\n            \n            # Derived formula for I(T) = (delta_s / k) * (T + (exp(-k*T) - 1) / k)\n            I_T = (delta_s / k) * (T + (np.exp(-k * T) - 1) / k)\n\n        # Case 2: k is zero\n        else: # k == 0\n            # Derived formula for d(t) = delta_s * t\n            d_T = delta_s * T\n            \n            # Derived formula for I(T) = (delta_s * T^2) / 2\n            I_T = (delta_s * T**2) / 2\n\n        # Calculate the characteristic time constant tau\n        # tau is well-defined only if k > 0 (stable system)\n        if k > 0:\n            tau = 1.0 / k\n        else:\n            # Sentinel value for undefined tau (unstable or perfect integrator)\n            tau = -1.0\n            \n        results.append([d_T, I_T, tau])\n\n    # Format the results into the required string format\n    # Example: [[d1, I1, tau1], [d2, I2, tau2], ...]\n    result_str = \"[\" + \", \".join([str(res) for res in results]) + \"]\"\n\n    # Final print statement in the exact required format.\n    print(result_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在理解了LCA模型的基本动态后，我们可以进一步探究其内部“布线”如何影响其输出。这个练习将说明，即使在外部输入完全平衡的情况下，竞争连接中的不对称性也会造成一种内在的选择偏好。这为解释决策中预先存在的倾向或偏差提供了一个关键的神经计算机制。",
            "id": "3993704",
            "problem": "考虑一个由漏泄竞争累加器 (Leaky Competing Accumulator, LCA) 框架建模的双选择决策电路。每个选择由一个累加器表示，其激活值分别为 $x_{1}(t)$ 和 $x_{2}(t)$。这些累加器接收恒定输入 $I_{1}$ 和 $I_{2}$，每个输入都通过一个速率为 $ \\alpha  0 $ 的漏泄积分过程，并通过一个非对称侧向抑制矩阵 $W = [w_{ij}]$ 相互抑制，该矩阵的非对角线项为 $w_{12} \\ge 0$ 和 $w_{21} \\ge 0$，对角线项为零。其连续时间动态由以下基本速率方程指定：\n$$\n\\frac{d x_{1}}{d t} = -\\alpha x_{1} - w_{12} x_{2} + I_{1}, \\qquad\n\\frac{d x_{2}}{d t} = -\\alpha x_{2} - w_{21} x_{1} + I_{2}.\n$$\n假设输入为相等的常数 $I_{1} = I_{2} = I$ 且 $I \\ge 0$，并且参数满足稳定性和唯一性条件 $ \\alpha^{2}  w_{12} w_{21} $。通过平衡条件 $ \\frac{d x_{1}}{d t} = 0 $ 和 $ \\frac{d x_{2}}{d t} = 0 $ 定义稳态激活值 $x_{1}^{\\ast}$ 和 $x_{2}^{\\ast}$。选择偏差被量化为稳态差值 $ b = x_{1}^{\\ast} - x_{2}^{\\ast} $。\n\n仅从给定的 LCA 速率方程、线性和平衡条件出发，推导 $b$ 作为 $\\alpha$、$w_{12}$、$w_{21}$ 和 $I$ 的函数的解析表达式。在你的推理中解释 $W$ 中的不对称性（即 $w_{12} \\neq w_{21}$）如何在输入相等的情况下也能引起非零偏差。\n\n将最终偏差 $b$ 表示为单个闭式解析表达式。不需要进行数值四舍五入。",
            "solution": "首先验证问题的科学性、适定性和客观性。问题陈述描述了一个标准的双节点漏泄竞争累加器 (LCA) 模型，这是计算神经科学中一个成熟的框架。其控制方程是线性常微分方程。所给条件 $\\alpha^2  w_{12} w_{21}$ 确保了系统系数矩阵是非奇异的，并且动力系统有一个唯一的、稳定的不动点（稳态）。所有术语都经过了正式定义，并提供了所有必要的参数。因此，该问题被认为是有效的。\n\n选择偏差 $b$ 的推导从系统的平衡条件开始。稳态激活值，表示为 $x_{1}^{\\ast}$ 和 $x_{2}^{\\ast}$，是系统处于平衡状态时 $x_{1}(t)$ 和 $x_{2}(t)$ 的值。这通过将时间导数设为零来定义：\n$$\n\\frac{d x_{1}}{d t} = 0 \\qquad \\text{和} \\qquad \\frac{d x_{2}}{d t} = 0\n$$\n将这些条件代入给定的速率方程，得到一个由两个线性代数方程组成的方程组：\n$$\n0 = -\\alpha x_{1}^{\\ast} - w_{12} x_{2}^{\\ast} + I_{1}\n$$\n$$\n0 = -\\alpha x_{2}^{\\ast} - w_{21} x_{1}^{\\ast} + I_{2}\n$$\n问题指定了相等的恒定输入 $I_{1} = I_{2} = I$。代入此条件并将各项重新排列成标准线性方程组形式，得到：\n$$\n\\alpha x_{1}^{\\ast} + w_{12} x_{2}^{\\ast} = I\n$$\n$$\nw_{21} x_{1}^{\\ast} + \\alpha x_{2}^{\\ast} = I\n$$\n这是一个关于两个未知稳态激活值 $x_{1}^{\\ast}$ 和 $x_{2}^{\\ast}$ 的二元线性方程组。我们可以解这个方程组来求得 $x_{1}^{\\ast}$ 和 $x_{2}^{\\ast}$ 的显式表达式。使用克莱姆法则是一种有效的方法。系数矩阵的行列式为：\n$$\nD = \\det \\begin{pmatrix} \\alpha  w_{12} \\\\ w_{21}  \\alpha \\end{pmatrix} = \\alpha \\cdot \\alpha - w_{12} w_{21} = \\alpha^{2} - w_{12} w_{21}\n$$\n问题陈述提供了条件 $\\alpha^{2}  w_{12} w_{21}$，这确保了 $D  0$（因为 $\\alpha  0$，$w_{12} \\ge 0$，$w_{21} \\ge 0$）。这保证了唯一解的存在。\n\n现在我们求解 $x_{1}^{\\ast}$ 和 $x_{2}^{\\ast}$：\n$$\nx_{1}^{\\ast} = \\frac{\\det \\begin{pmatrix} I  w_{12} \\\\ I  \\alpha \\end{pmatrix}}{D} = \\frac{I\\alpha - I w_{12}}{\\alpha^{2} - w_{12} w_{21}} = \\frac{I(\\alpha - w_{12})}{\\alpha^{2} - w_{12} w_{21}}\n$$\n$$\nx_{2}^{\\ast} = \\frac{\\det \\begin{pmatrix} \\alpha  I \\\\ w_{21}  I \\end{pmatrix}}{D} = \\frac{I\\alpha - I w_{21}}{\\alpha^{2} - w_{12} w_{21}} = \\frac{I(\\alpha - w_{21})}{\\alpha^{2} - w_{12} w_{21}}\n$$\n选择偏差 $b$ 定义为这些稳态激活值之间的差，$b = x_{1}^{\\ast} - x_{2}^{\\ast}$。我们使用刚刚推导出的表达式来计算这个差值：\n$$\nb = x_{1}^{\\ast} - x_{2}^{\\ast} = \\frac{I(\\alpha - w_{12})}{\\alpha^{2} - w_{12} w_{21}} - \\frac{I(\\alpha - w_{21})}{\\alpha^{2} - w_{12} w_{21}}\n$$\n由于分母相同，我们可以合并分子：\n$$\nb = \\frac{I(\\alpha - w_{12}) - I(\\alpha - w_{21})}{\\alpha^{2} - w_{12} w_{21}}\n$$\n展开分子中的各项：\n$$\nb = \\frac{I\\alpha - I w_{12} - I\\alpha + I w_{21}}{\\alpha^{2} - w_{12} w_{21}}\n$$\n包含 $I\\alpha$ 的项相互抵消，得到简化表达式：\n$$\nb = \\frac{I w_{21} - I w_{12}}{\\alpha^{2} - w_{12} w_{21}} = \\frac{I(w_{21} - w_{12})}{\\alpha^{2} - w_{12} w_{21}}\n$$\n这就是选择偏差 $b$ 的最终解析表达式。\n\n问题还要求解释抑制矩阵 $W$ 中的不对称性如何引起非零偏差。通过检查推导出的 $b$ 的表达式，我们可以分析 $b \\neq 0$ 的条件。根据问题的稳定性条件，分母 $\\alpha^{2} - w_{12} w_{21}$ 非零。输入 $I$ 被给定为非负，$I \\ge 0$。如果 $I = 0$，则 $b=0$，这是平凡的，因为没有输入来驱动系统。假设存在非平凡输入 $I  0$，偏差 $b$ 非零当且仅当项 $(w_{21} - w_{12})$ 非零。\n该项非零当且仅当 $w_{21} \\neq w_{12}$。\n条件 $w_{21} \\neq w_{12}$ 表示从累加器 1 到累加器 2 的抑制权重 ($w_{21}$) 不同于从累加器 2 到累加器 1 的抑制权重 ($w_{12}$)。这就是非对称抑制结构的定义。\n\n因此，即使输入完全平衡 ($I_1 = I_2 = I$)，侧向抑制中的不对称性 ($w_{12} \\neq w_{21}$) 也会在累加器之间的相互抑制中造成不平衡。\n- 如果 $w_{21}  w_{12}$，从累加器2到1的抑制强于从1到2的抑制。这会使累加器1处于劣势，导致 $x_{1}^{\\ast}  x_{2}^{\\ast}$ 和负偏差 $b  0$。注意：我之前的思路搞反了。让我们重新验证一下。这一项是 $w_{21} - w_{12}$。如果 $w_{21}  w_{12}$，那么 $b  0$。项 $w_{ij}$ 表示单元 $j$ 对单元 $i$ 的影响。所以 $w_{21}$ 是 $x_1$ 对 $x_2$ 动态的影响。它是*从* $1$ *到* $2$ 的抑制。如果 $w_{21}  w_{12}$，累加器 1 对累加器 2 的抑制比反向的抑制更强。这给了累加器 1 一个竞争优势，导致 $x_{1}^{\\ast}  x_{2}^{\\ast}$，从而产生正偏差 $b  0$。\n- 相反，如果 $w_{12}  w_{21}$，累加器 2 对累加器 1 的抑制更强，使累加器 2 具有优势，从而导致 $x_{2}^{\\ast}  x_{1}^{\\ast}$ 和负偏差 $b  0$。\n- 如果抑制是对称的，即 $w_{12} = w_{21}$，则项 $(w_{21} - w_{12})$ 变为零，导致 $b = 0$。在这种对称竞争的情况下，相等的输入不会在稳态激活值中产生偏差。\n\n总之，当输入相同时，抑制连接中的不对称性是产生非零选择偏差的直接原因。",
            "answer": "$$\n\\boxed{\\frac{I(w_{21} - w_{12})}{\\alpha^{2} - w_{12}w_{21}}}\n$$"
        },
        {
            "introduction": "这项练习将理论与实际应用联系起来，突出了在将计算模型与真实数据拟合时遇到的一个核心挑战。通过一项随机模拟，您将探索参数的非唯一性问题——即不同的内部参数设置如何能产生几乎无法区分的行为输出。理解这一概念对于任何试图将LCA这类模型与实验数据进行拟合的研究者来说都至关重要。",
            "id": "3993686",
            "problem": "考虑一个由两个耦合随机微分方程定义的漏泄竞争累加器 (LCA) 模型建模的双选择决策过程。令 $x_1(t)$ 和 $x_2(t)$ 表示两个备选项的决策变量，初始条件为 $x_1(0)=0$ 和 $x_2(0)=0$。其动力学由以下方程给出：\n$$\n\\mathrm{d}x_1(t) = \\left(\\gamma I_1 - \\alpha x_1(t) - \\beta x_2(t)\\right)\\mathrm{d}t + \\sigma \\mathrm{d}W_1(t),\n$$\n$$\n\\mathrm{d}x_2(t) = \\left(\\gamma I_2 - \\alpha x_2(t) - \\beta x_1(t)\\right)\\mathrm{d}t + \\sigma \\mathrm{d}W_2(t),\n$$\n其中，$I_1$ 和 $I_2$ 是恒定输入（$I_1I_2$），$\\alpha$ 是漏泄系数，$\\beta$ 是侧向抑制系数，$\\gamma$ 是输入增益，$\\sigma$ 是扩散幅度，$W_1(t)$ 和 $W_2(t)$ 是独立的维纳过程（高斯白噪声，GWN）。当 $x_1(t)$ 或 $x_2(t)$ 首次达到一个正边界 $B$ 时，就记录一个决策。决策时间是到达边界的首次穿越时间，而选择由首先触及边界的变量决定。如果在最大时间 $T_{\\max}$ 内两个变量都没有到达边界，则将决策分配给在 $T_{\\max}$ 时值较大的变量，并将决策时间设为 $T_{\\max}$。\n\n从上述模型定义和使用 Euler–Maruyama 方法离散化随机微分方程的基本原理出发，设计一个程序，执行敏感性分析，以经验性地展示可识别性权衡。具体来说，展示在固定证据输入下，$(\\alpha,B)$ 和 $(\\beta,\\gamma)$ 的变化可以对平均决策时间和准确率（选择较强输入备选项的试验比例）产生相似的模型预测。\n\n你的程序必须：\n- 实现 Euler–Maruyama 积分，时间步长 $dt=0.001$ 秒，最大时间 $T_{\\max}=3.0$ 秒。使用 $\\sigma$ 作为扩散项的标准差，以便离散时间更新使用按 $\\sigma \\sqrt{dt}$ 缩放的独立正态增量。\n- 为了可复现性，使用固定的随机种子 $s=12345$。\n- 对每组参数集，模拟 $N=800$ 次独立试验，并计算两个预测指标：以秒为单位的平均决策时间和以 $[0,1]$ 范围内的十进制小数表示的准确率。\n- 使用输入 $I_1=0.25$ 和 $I_2=0.20$（以一致的证据单位/秒计），以及扩散幅度 $\\sigma=0.10$（以一致的单位计）。\n- 使用参考参数集 $(\\alpha_0,\\beta_0,\\gamma_0,B_0)=(1.0,\\,0.6,\\,1.0,\\,0.15)$。\n- 通过检查以下两个条件是否同时成立，将每个测试参数集与参考集进行比较：平均决策时间的绝对差小于 $\\tau_t=0.15$ 秒，且准确率的绝对差小于 $\\tau_a=0.10$。\n- 生成一个单行输出，该输出以下面指定的确切格式汇总所有测试用例的布尔结果。\n\n测试套件：\n1. $(\\alpha,B)$ 权衡，中等：$(\\alpha,B)=(0.75,\\,0.1125)$，其中 $(\\beta,\\gamma)=(0.6,\\,1.0)$。\n2. $(\\alpha,B)$ 权衡，中等：$(\\alpha,B)=(1.25,\\,0.1875)$，其中 $(\\beta,\\gamma)=(0.6,\\,1.0)$。\n3. $(\\alpha,B)$ 权衡，边缘：$(\\alpha,B)=(1.50,\\,0.225)$，其中 $(\\beta,\\gamma)=(0.6,\\,1.0)$。\n4. $(\\beta,\\gamma)$ 权衡，中等：$(\\beta,\\gamma)=(0.90,\\,1.50)$，其中 $(\\alpha,B)=(1.0,\\,0.15)$。\n5. $(\\beta,\\gamma)$ 权衡，边缘-低：$(\\beta,\\gamma)=(0.30,\\,0.50)$，其中 $(\\alpha,B)=(1.0,\\,0.15)$。\n6. $(\\beta,\\gamma)$ 权衡，中等：$(\\beta,\\gamma)=(0.75,\\,1.25)$，其中 $(\\alpha,B)=(1.0,\\,0.15)$。\n\n答案格式：\n- 你的程序应生成一个单行输出，其中包含一个用方括号括起来的、逗号分隔的布尔值列表，例如 `[True,False,True,False,True,True]`。\n- 每个布尔值按上面列出的顺序对应一个测试用例。当且仅当相对于参考集的两个接近度条件（时间在 $\\tau_t$ 内，准确率在 $\\tau_a$ 内）都满足时，值为 True。否则为 False。\n- 时间的内部计算以秒表示，准确率以小数表示。最终输出仅包含布尔值，如指定。",
            "solution": "该问题要求对一个双选择漏泄竞争累加器 (LCA) 模型中的参数可识别性权衡进行经验性研究。这通过在不同参数集下模拟该模型，并将所得的预测指标——平均决策时间和准确率——与一个参考案例进行比较来完成。\n\nLCA 模型描述了两个决策变量 $x_1(t)$ 和 $x_2(t)$ 的演化过程，这两个变量为两个竞争备选项累积证据。其动力学由一个耦合随机微分方程 (SDE) 系统控制：\n$$\n\\mathrm{d}x_1(t) = \\left(\\gamma I_1 - \\alpha x_1(t) - \\beta x_2(t)\\right)\\mathrm{d}t + \\sigma \\mathrm{d}W_1(t)\n$$\n$$\n\\mathrm{d}x_2(t) = \\left(\\gamma I_2 - \\alpha x_2(t) - \\beta x_1(t)\\right)\\mathrm{d}t + \\sigma \\mathrm{d}W_2(t)\n$$\n此处，$I_1$ 和 $I_2$ 是恒定的证据输入，$\\alpha$ 是漏泄率，$\\beta$ 是侧向抑制强度，$\\gamma$ 是输入增益，$\\sigma$ 是独立维纳过程 $W_1(t)$ 和 $W_2(t)$ 的幅度。初始条件指定为 $x_1(0)=0$ 和 $x_2(0)=0$。\n\n为了在计算机上模拟这些连续时间动力学，我们必须将其离散化。问题指定使用 Euler-Maruyama 方法。对于一个形如 $\\mathrm{d}X(t) = f(X, t)\\mathrm{d}t + g(X, t)\\mathrm{d}W(t)$ 的一般 SDE，在一个小时间步长 $dt$ 上的离散时间更新由下式给出：\n$$\nX_{k+1} = X_k + f(X_k, t_k)dt + g(X_k, t_k)\\sqrt{dt}Z_k\n$$\n其中 $Z_k$ 是从标准正态分布 $N(0, 1)$ 中抽取的随机变量。将此方法应用于 LCA 系统，我们得到在时间步 $k$ 时状态 $(x_{1,k}, x_{2,k})$ 的迭代更新规则：\n$$\nx_{1, k+1} = x_{1, k} + \\left(\\gamma I_1 - \\alpha x_{1, k} - \\beta x_{2, k}\\right)dt + \\sigma\\sqrt{dt}Z_{1, k}\n$$\n$$\nx_{2, k+1} = x_{2, k} + \\left(\\gamma I_2 - \\alpha x_{2, k} - \\beta x_{1, k}\\right)dt + \\sigma\\sqrt{dt}Z_{2, k}\n$$\n其中 $Z_{1, k}$ 和 $Z_{2, k}$ 是从 $N(0, 1)$ 中抽取的独立样本。\n\n单次决策试验的模拟按如下方式进行。从 $(x_1, x_2) = (0, 0)$ 开始，状态在每个时间步长 $dt$ 更新。当满足以下两个条件之一时，试验结束：\n1.  **边界穿越**：如果任一累加器达到预定义的正决策边界 $B$（即 $x_1 \\ge B$ 或 $x_2 \\ge B$），则做出决策。选择对应于到达边界的累加器，决策时间是穿越发生的时间。\n2.  **超时**：如果在最大时间 $T_{\\max} = 3.0$ 秒内两个累加器都未到达边界，则试验终止。决策时间设为 $T_{\\max}$，并将选择给予当时值较大的累加器。\n\n对于每个参数集，使用固定的随机种子以保证可复现性，执行 $N=800$ 次独立试验。从这些试验中，计算出两个关键指标：\n- **平均决策时间**：所有 $N$ 次试验的决策时间的算术平均值。\n- **准确率**：选择对应于较强输入 $I_1$ 的试验所占的比例。\n\n分析的核心在于将来自几个测试参数集的指标与参考集 $(\\alpha_0, \\beta_0, \\gamma_0, B_0) = (1.0, 0.6, 1.0, 0.15)$ 进行比较。设参考集的指标为 $\\text{MDT}_{\\text{ref}}$ 和 $\\text{Acc}_{\\text{ref}}$，测试集的指标为 $\\text{MDT}_{\\text{test}}$ 和 $\\text{Acc}_{\\text{test}}$。如果以下两个条件同时成立，则认为该测试集产生了相似的模型预测：\n$$\n|\\text{MDT}_{\\text{test}} - \\text{MDT}_{\\text{ref}}|  \\tau_t, \\quad \\text{with } \\tau_t = 0.15 \\text{ seconds}\n$$\n$$\n|\\text{Acc}_{\\text{test}} - \\text{Acc}_{\\text{ref}}|  \\tau_a, \\quad \\text{with } \\tau_a = 0.10\n$$\n最终输出是一个布尔列表，为每个测试用例指示此相似性条件是否满足。这展示了不同的参数组合如何能够产生几乎相同的可观测行为，这是模型验证和拟合中的一个关键概念，称为参数不可识别性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_lca_simulation(params, I1, I2, sigma, dt, T_max, N, seed):\n    \"\"\"\n    Simulates the Leaky Competing Accumulator (LCA) model for N trials.\n\n    Args:\n        params (dict): A dictionary containing model parameters 'alpha', 'beta',\n                       'gamma', and 'B'.\n        I1, I2 (float): Constant inputs.\n        sigma (float): Diffusion amplitude.\n        dt (float): Time step for integration.\n        T_max (float): Maximum simulation time per trial.\n        N (int): Number of trials.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        tuple: A tuple containing the mean decision time (float) and accuracy\n               (float).\n    \"\"\"\n    alpha = params['alpha']\n    beta = params['beta']\n    gamma = params['gamma']\n    B = params['B']\n\n    rng = np.random.default_rng(seed)\n    \n    decision_times = []\n    correct_choices = 0\n    \n    num_steps = int(T_max / dt)\n    sqrt_dt = np.sqrt(dt)\n\n    for _ in range(N):\n        x1, x2 = 0.0, 0.0\n        \n        trial_time = T_max\n        choice = 0 # 0 for no decision, 1 for x1, 2 for x2\n\n        for k in range(num_steps):\n            t = (k + 1) * dt\n\n            # Generate independent Wiener process increments\n            dW1 = rng.normal(0.0, 1.0)\n            dW2 = rng.normal(0.0, 1.0)\n            \n            noise1 = sigma * sqrt_dt * dW1\n            noise2 = sigma * sqrt_dt * dW2\n\n            # Calculate drift terms\n            drift1 = (gamma * I1 - alpha * x1 - beta * x2)\n            drift2 = (gamma * I2 - alpha * x2 - beta * x1)\n\n            # Update decision variables using Euler-Maruyama\n            x1 += drift1 * dt + noise1\n            x2 += drift2 * dt + noise2\n            \n            # Check for bound crossing\n            if x1 >= B:\n                trial_time = t\n                choice = 1\n                break\n            elif x2 >= B:\n                trial_time = t\n                choice = 2\n                break\n        \n        decision_times.append(trial_time)\n\n        # If no bound was crossed, determine winner at T_max\n        if choice == 0:\n            if x1 > x2:\n                correct_choices += 1\n        elif choice == 1:\n            correct_choices += 1\n            \n    mean_dt = np.mean(decision_times)\n    accuracy = correct_choices / N\n    \n    return mean_dt, accuracy\n\ndef solve():\n    \"\"\"\n    Main function to run the sensitivity analysis and produce the final output.\n    \"\"\"\n    # Fixed parameters\n    I1 = 0.25\n    I2 = 0.20\n    sigma = 0.10\n    dt = 0.001\n    T_max = 3.0\n    N = 800\n    seed = 12345\n    \n    # Tolerances for comparison\n    tau_t = 0.15\n    tau_a = 0.10\n\n    # Reference parameter set\n    ref_params = {'alpha': 1.0, 'beta': 0.6, 'gamma': 1.0, 'B': 0.15}\n    \n    # Test cases\n    test_cases = [\n        # 1. (alpha, B) trade-off, moderate\n        {'alpha': 0.75, 'beta': 0.6, 'gamma': 1.0, 'B': 0.1125},\n        # 2. (alpha, B) trade-off, moderate\n        {'alpha': 1.25, 'beta': 0.6, 'gamma': 1.0, 'B': 0.1875},\n        # 3. (alpha, B) trade-off, edge\n        {'alpha': 1.50, 'beta': 0.6, 'gamma': 1.0, 'B': 0.225},\n        # 4. (beta, gamma) trade-off, moderate\n        {'alpha': 1.0, 'beta': 0.90, 'gamma': 1.50, 'B': 0.15},\n        # 5. (beta, gamma) trade-off, edge-low\n        {'alpha': 1.0, 'beta': 0.30, 'gamma': 0.50, 'B': 0.15},\n        # 6. (beta, gamma) trade-off, moderate\n        {'alpha': 1.0, 'beta': 0.75, 'gamma': 1.25, 'B': 0.15},\n    ]\n\n    # Run simulation for the reference case\n    ref_dt, ref_acc = run_lca_simulation(ref_params, I1, I2, sigma, dt, T_max, N, seed)\n    \n    results = []\n    \n    # Run simulations for test cases and compare with reference\n    for test_params in test_cases:\n        test_dt, test_acc = run_lca_simulation(test_params, I1, I2, sigma, dt, T_max, N, seed)\n        \n        # Check if the differences are within the tolerances\n        dt_diff = abs(test_dt - ref_dt)\n        acc_diff = abs(test_acc - ref_acc)\n        \n        is_similar = (dt_diff  tau_t) and (acc_diff  tau_a)\n        results.append(is_similar)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}