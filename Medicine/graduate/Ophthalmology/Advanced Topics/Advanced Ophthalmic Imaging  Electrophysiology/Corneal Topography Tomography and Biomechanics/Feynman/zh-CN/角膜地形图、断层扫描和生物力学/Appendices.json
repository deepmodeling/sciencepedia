{
    "hands_on_practices": [
        {
            "introduction": "虽然简单的模型将角膜视为单一的折射面，但更精确的光学描述必须同时考虑其前、后表面以及中心厚度。本练习将引导您运用近轴光学的第一性原理，推导角膜作为厚透镜的总等效光焦度。通过完成此练习 ，您将量化忽略后表面和角膜厚度所带来的显著误差，从而突显出全面的断层扫描分析相对于简单角膜曲率测量的必要性。",
            "id": "4667557",
            "problem": "透明角膜被建模为一个旋转对称的双表面折射体，其前球面界面的半径为 $R_{a}$，后球面界面的半径为 $R_{p}$。光线从空气进入角膜，然后进入房水。假设为单色傍轴光线和小角度条件。使用以下折射率：空气 $n_{a} = 1.000$，角膜基质 $n_{c} = 1.376$，房水 $n_{h} = 1.336$。几何参数为：前曲率半径 $R_{a} = 7.80~\\text{mm}$，后曲率半径 $R_{p} = 6.50~\\text{mm}$，以及中央角膜厚度 $t = 0.55~\\text{mm}$。采用以下符号约定：在每个折射界面，当从入射介质看，曲率中心位于光传播方向上时，曲率半径 $R$ 为正，否则为负。对于角膜，当光线从空气入射到前表面，以及从基质入射到后表面时，根据此约定，$R_{a}$ 和 $R_{p}$ 均为正值。\n\n从球面界面的斯涅尔定律和傍轴近似出发，首先用 $n_{a}$、$n_{c}$ 和 $R_{a}$ 推导出傍轴前表面光焦度 $P_{a}$，并计算其数值。然后，使用序列傍轴折射和在均匀介质中平移的第一性原理（不使用捷径），推导由两个折射表面（在介质 $n_{c}$ 中相隔厚度 $t$）构成的厚角膜的等效傍轴光焦度，并计算其数值。\n\n最后，通过报告仅考虑前表面的值与推导出的厚角膜等效光焦度之间的绝对差，来量化当简单地使用前表面光焦度 $P_{a}$ 作为角膜总等效光焦度的近似值时所产生的建模误差。将您的最终答案四舍五入至四位有效数字，并以屈光度（D）为单位表示。最终结果只提供这个实数值。",
            "solution": "该问题陈述经验证是科学上合理、定义明确且客观的。这是一个应用于人眼角膜模型的傍轴光学标准问题。所有提供的数据在物理上都是真实的，并且足以得到唯一解。因此，该问题是有效的。\n\n解题过程按要求分三部分进行：首先，推导并计算前表面光焦度 $P_a$；其次，推导并计算厚角膜的等效光焦度 $P_{eq}$；最后，计算建模误差。所有长度必须转换为米，以便以屈光度（$D$）计算光焦度，其中 $1~\\text{D} = 1~\\text{m}^{-1}$。\n\n已知条件如下：\n空气折射率：$n_{a} = 1.000$\n角膜基质折射率：$n_{c} = 1.376$\n房水折射率：$n_{h} = 1.336$\n前曲率半径：$R_{a} = 7.80~\\text{mm} = 7.80 \\times 10^{-3}~\\text{m}$\n后曲率半径：$R_{p} = 6.50~\\text{mm} = 6.50 \\times 10^{-3}~\\text{m}$\n中央角膜厚度：$t = 0.55~\\text{mm} = 0.55 \\times 10^{-3}~\\text{m}$\n\n符号约定规定 $R_a > 0$ 且 $R_p > 0$。\n\n**第一部分：前表面光焦度 ($P_a$)**\n\n对于折射率分别为 $n_1$ 和 $n_2$ 的两种介质之间的单个球面界面，其傍轴折射方程为：\n$$ \\frac{n_2}{s'} - \\frac{n_1}{s} = \\frac{n_2 - n_1}{R} $$\n其中 $s$ 是物距，$s'$ 是像距，$R$ 是曲率半径。一个表面的光焦度 $P$ 是为入射平行光线定义的，意味着物体在无穷远处 ($s \\to \\infty$)。在这种情况下，$\\frac{n_1}{s} \\to 0$，方程简化为：\n$$ \\frac{n_2}{s'} = \\frac{n_2 - n_1}{R} $$\n这里，$s'$ 是第二焦距，$f'$。光焦度 $P$ 由右侧的表达式给出。\n\n对于角膜前表面，光线从空气 ($n_1 = n_a$) 传播到角膜基质 ($n_2 = n_c$)。半径为 $R_a$。因此，前表面光焦度 $P_a$ 为：\n$$ P_a = \\frac{n_c - n_a}{R_a} $$\n代入给定的数值：\n$$ P_a = \\frac{1.376 - 1.000}{7.80 \\times 10^{-3}~\\text{m}} = \\frac{0.376}{0.0078}~\\text{D} \\approx 48.205128~\\text{D} $$\n\n**第二部分：厚角膜的等效光焦度 ($P_{eq}$)**\n\n我们将通过追迹一条傍轴光线，从第一性原理出发，推导厚透镜系统的等效光焦度公式。考虑一条初始平行于光轴、高度为 $y_1$ 的光线。设光线与光轴的夹角为 $\\theta$，向上倾斜的光线为正。按照惯例，一个正光焦度表面会将一条初始平行于光轴且在其上方（正高度）的光线向光轴弯曲，导致产生一个负角度。在光焦度为 $P = (n_2-n_1)/R$ 的表面发生折射以及平移距离 $d$ 的傍轴光线追迹方程为：\n折射：$n_2\\theta_2 = n_1\\theta_1 - yP$\n平移：$y_2 = y_1 + d\\theta_1$\n\n1.  **在前表面发生折射**：\n    一条平行于光轴的入射光线在高度 $y_1$ 处有 $\\theta_1 = 0$。光线从空气 ($n_a$) 进入角膜 ($n_c$)。在角膜内的角度 $\\theta_1'$ 由下式给出：\n    $$ n_c \\theta_1' = n_a \\theta_1 - y_1 P_a = n_a(0) - y_1 P_a = -y_1 P_a $$\n    $$ \\theta_1' = -\\frac{y_1 P_a}{n_c} $$\n\n2.  **在角膜内平移**：\n    光线在角膜（折射率 $n_c$）中传播距离 $t$ 到达后表面。其在后表面的高度 $y_2$ 为：\n    $$ y_2 = y_1 + t \\theta_1' = y_1 + t \\left(-\\frac{y_1 P_a}{n_c}\\right) = y_1 \\left(1 - \\frac{t P_a}{n_c}\\right) $$\n    在后表面的入射角为 $\\theta_2 = \\theta_1'$。\n\n3.  **在后表面发生折射**：\n    后表面的光焦度 $P_p$，其中光线从角膜 ($n_c$) 进入房水 ($n_h$)，为：\n    $$ P_p = \\frac{n_h - n_c}{R_p} = \\frac{1.336 - 1.376}{6.50 \\times 10^{-3}~\\text{m}} = \\frac{-0.040}{0.0065}~\\text{D} \\approx -6.153846~\\text{D} $$\n    在房水中的最终角度 $\\theta_2'$ 由此表面的折射方程给出：\n    $$ n_h \\theta_2' = n_c \\theta_2 - y_2 P_p $$\n    代入 $\\theta_2$ 和 $y_2$ 的表达式：\n    $$ n_h \\theta_2' = n_c \\left(-\\frac{y_1 P_a}{n_c}\\right) - y_1\\left(1 - \\frac{t P_a}{n_c}\\right)P_p $$\n    $$ n_h \\theta_2' = -y_1 P_a - y_1 P_p + \\frac{y_1 t P_a P_p}{n_c} = -y_1 \\left(P_a + P_p - \\frac{t P_a P_p}{n_c}\\right) $$\n    对于一条初始平行于光轴、高度为 $y_1$ 的光线，整个系统的等效光焦度 $P_{eq}$ 由关系式 $n_h \\theta_2' = -y_1 P_{eq}$ 定义。将此与我们推导出的表达式进行比较，我们得到：\n    $$ P_{eq} = P_a + P_p - \\frac{t}{n_c} P_a P_p $$\n    这就是 Gullstrand 光焦度公式。现在，我们代入数值：\n    $$ P_{eq} = (48.205128...) + (-6.153846...) - \\frac{0.55 \\times 10^{-3}}{1.376} (48.205128...) (-6.153846...) $$\n    $$ P_{eq} = 42.051282... - (0.000399709...) (-296.64756...) $$\n    $$ P_{eq} = 42.051282... + 0.118573... $$\n    $$ P_{eq} \\approx 42.169855~\\text{D} $$\n\n**第三部分：建模误差**\n\n建模误差是前表面光焦度 $P_a$ 与厚角膜等效光焦度 $P_{eq}$ 之间的绝对差。\n$$ \\text{Error} = |P_a - P_{eq}| $$\n$$ \\text{Error} = |48.205128... - 42.169855...|~\\text{D} $$\n$$ \\text{Error} = 6.035273...~\\text{D} $$\n将最终答案四舍五入到四位有效数字，得到 $6.035~\\text{D}$。",
            "answer": "$$\\boxed{6.035}$$"
        },
        {
            "introduction": "现代断层扫描仪主要测量角膜相对于参考球面的高度分布，但临床医生依赖曲率图进行诊断和手术规划。这项计算练习  旨在弥合这一差距，要求您实现一个稳健的算法，将离散的高度数据转换为连续的曲率分布。成功解决此问题将使您深入了解地形图系统核心数据处理的原理，包括通过局部多项式拟合进行数值微分和噪声处理等关键步骤。",
            "id": "4667523",
            "problem": "您将获得沿单一子午线相对于最佳拟合球面的采样角膜高程剖面。您的任务是通过重建真实的矢状剖面并以物理上一致的方式对其进行微分，将高程转换为子午曲率。\n\n从以下基本原理出发：\n\n- 旋转对称表面的子午线可以被视为一个平面曲线，由图 $z = s(r)$ 给出，其中 $r$ 是径向（半弦）坐标，$s(r)$ 是相对于顶点的矢状高。\n- 平面曲线的曲率定义为单位切向量相对于弧长的变化率。\n- 最佳拟合球面的矢状高可以通过经典圆几何获得。\n\n以此为基础，推导一种从已知半弦处采样的高程数据计算带符号子午曲率的方法。您的算法必须：\n\n1. 从采样的高程 $e(r)$ 和已知的最佳拟合球面半径 $R_{\\text{bfs}}$ 重建真实的矢状剖面 $s_{\\text{true}}(r)$。\n2. 仅使用给定的样本点，估计指定目标半弦处 $s_{\\text{true}}(r)$ 的一阶和二阶导数。\n3. 根据平面曲线曲率的定义，计算这些半弦处的带符号子午曲率。\n4. 以数值稳定的方式处理采样域中的内部点和边界点。\n\n物理单位和约定：\n\n- 所有距离必须以米（$\\mathrm{m}$）为单位。\n- 曲率必须以米分之一（$\\mathrm{m}^{-1}$）为单位报告。\n- 对于数值结果，将每个曲率值四舍五入到六位小数。\n\n测试套件的数据生成：\n\n- 设球面矢状高函数定义为\n  $$ s_{\\text{sphere}}(r; R) = R - \\sqrt{R^2 - r^2}, $$\n  这源于以光轴为中心、顶点在 $r = 0$ 处的圆方程。\n- 设圆锥曲面矢状高函数（旋转对称圆锥曲线）定义为\n  $$ s_{\\text{conicoid}}(r; R_0, Q) = \\frac{r^2}{R_0\\left(1 + \\sqrt{1 - \\frac{(1+Q) r^2}{R_0^2}}\\right)}, $$\n  其中 $R_0$ 是顶点曲率半径，$Q$ 是圆锥常数。\n- 相对于最佳拟合球面的高程为\n  $$ e(r) = s_{\\text{true}}(r) - s_{\\text{sphere}}(r; R_{\\text{bfs}}). $$\n\n您的实现必须通过以下方式重建 $s_{\\text{true}}(r)$\n$$ s_{\\text{true}}(r) = e(r) + s_{\\text{sphere}}(r; R_{\\text{bfs}}). $$\n\n导数估计要求：\n\n- 您必须通过对邻近样本点进行最小二乘拟合一个至少为 $3$ 次的局部多项式来估计指定目标半弦处的导数。对每个目标点，使用其最近的 $p$ 个样本点组成的固定窗口（其中，在可用情况下，$p \\ge 5$ 且 $p \\le 7$）。为保证数值稳定性，通过将多项式原点平移到目标点来评估拟合多项式及其在该目标半弦处的导数。\n- 此要求旨在测试内部和边界稳定性，而不假设采样是均匀的。\n\n测试套件：\n\n精确实现以下五个测试用例。对于每个用例，构建 $r$ 样本，计算 $e(r)$，重建 $s_{\\text{true}}(r)$，然后计算指定目标点的曲率。\n\n- 用例 A（非球面，长球面）：\n  - 参数：$R_0 = 0.0078\\,\\mathrm{m}$，$Q = -0.26$，$R_{\\text{bfs}} = 0.0078\\,\\mathrm{m}$。\n  - 半弦样本：$r_j = 0.0000, 0.0005, 0.0010, \\dots, 0.0040\\,\\mathrm{m}$。\n  - 真实矢状高：$s_{\\text{true}}(r) = s_{\\text{conicoid}}(r; R_0, Q)$。\n  - 高程：$e(r) = s_{\\text{true}}(r) - s_{\\text{sphere}}(r; R_{\\text{bfs}})$。\n  - 目标点：$r^\\ast = [0.0000, 0.0020, 0.0040]\\,\\mathrm{m}$。\n\n- 用例 B（完美球面）：\n  - 参数：$R = 0.0080\\,\\mathrm{m}$，$R_{\\text{bfs}} = 0.0080\\,\\mathrm{m}$。\n  - 半弦样本：$r_j = 0.0000, 0.0005, 0.0010, \\dots, 0.0040\\,\\mathrm{m}$。\n  - 真实矢状高：$s_{\\text{true}}(r) = s_{\\text{sphere}}(r; R)$。\n  - 高程：对于所有样本，$e(r) = 0$。\n  - 目标点：$r^\\ast = [0.0000, 0.0020, 0.0040]\\,\\mathrm{m}$。\n\n- 用例 C（平面）：\n  - 参数：$R_{\\text{bfs}} = 0.0080\\,\\mathrm{m}$。\n  - 半弦样本：$r_j = 0.0000, 0.0005, 0.0010, \\dots, 0.0040\\,\\mathrm{m}$。\n  - 真实矢状高：对于所有 $r$，$s_{\\text{true}}(r) = 0$。\n  - 高程：$e(r) = - s_{\\text{sphere}}(r; R_{\\text{bfs}})$。\n  - 目标点：$r^\\ast = [0.0000, 0.0020, 0.0040]\\,\\mathrm{m}$。\n\n- 用例 D（带噪声的非球面，包含边界）：\n  - 参数：$R_0 = 0.0078\\,\\mathrm{m}$，$Q = -0.50$，$R_{\\text{bfs}} = 0.0078\\,\\mathrm{m}$。\n  - 半弦样本：$r_j = 0.0000, 0.0005, 0.0010, \\dots, 0.0040\\,\\mathrm{m}$。\n  - 真实矢状高：$s_{\\text{true}}(r) = s_{\\text{conicoid}}(r; R_0, Q)$。\n  - 加噪前的高程：$e_0(r) = s_{\\text{true}}(r) - s_{\\text{sphere}}(r; R_{\\text{bfs}})$。\n  - 噪声：向每个高程样本添加独立的、标准差为 $\\sigma = 1\\times 10^{-6}\\,\\mathrm{m}$ 的高斯噪声 $\\mathcal{N}(0, \\sigma^2)$；使用固定的随机种子 $12345$ 使噪声具有确定性。\n  - 加噪后的高程：$e(r) = e_0(r) + \\text{noise}$。\n  - 目标点：$r^\\ast = [0.0000, 0.0035, 0.0040]\\,\\mathrm{m}$。\n\n- 用例 E（不规则间距，球面）：\n  - 参数：$R = 0.0080\\,\\mathrm{m}$，$R_{\\text{bfs}} = 0.0080\\,\\mathrm{m}$。\n  - 不规则半弦样本（单位：米）：\n    $[0.0000, 0.0003, 0.0007, 0.0012, 0.0020, 0.0028, 0.0036, 0.0040]$。\n  - 真实矢状高：$s_{\\text{true}}(r) = s_{\\text{sphere}}(r; R)$。\n  - 高程：对于所有样本，$e(r) = 0$。\n  - 目标点：$r^\\ast = [0.0000, 0.0028, 0.0040]\\,\\mathrm{m}$。\n\n数值和算法约束：\n\n- 对于每个用例中的每个目标半弦，通过对目标点最近的 $p$ 个样本进行 $3$ 次多项式的最小二乘拟合来估计导数（其中 $N$ 为该用例中可用样本数，选择 $p = \\min(7, N)$，并确保在 $N \\ge 5$ 时 $p \\ge 5$）。\n- 使用平移坐标 $x = r - r^\\ast$ 进行局部多项式拟合，以改善条件数。\n- 根据该目标点的拟合导数计算每个目标点的带符号曲率。\n- 将每个曲率值四舍五入到六位小数，并以 $\\mathrm{m}^{-1}$ 报告。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例对应一个内部列表，按顺序包含其在指定目标点的曲率值。例如：\n  - 输出格式：$[[c_{A1}, c_{A2}, c_{A3}], [c_{B1}, c_{B2}, c_{B3}], [c_{C1}, c_{C2}, c_{C3}], [c_{D1}, c_{D2}, c_{D3}], [c_{E1}, c_{E2}, c_{E3}]]$\n- 每个 $c$ 必须四舍五入到六位小数并以数字表示（输出行中不含百分号或单位）。",
            "solution": "核心任务是从角膜表面相对于最佳拟合球面的离散高程剖面计算其带符号的子午曲率。这涉及到重建真实的表面形状，然后应用微分几何原理，并通过稳健的数值方法来实现。\n\n该问题的理论基础在于将角膜子午线描述为一个平面曲线 $z = s(r)$，其中 $r$ 是距光轴的径向距离（半弦），$s(r)$ 是表面的矢状高。这样一条曲线的带符号曲率 $\\kappa(r)$ 由微积分中的标准公式给出：\n$$\n\\kappa(r) = \\frac{\\frac{d^2s}{dr^2}}{\\left(1 + \\left(\\frac{ds}{dr}\\right)^2\\right)^{3/2}} = \\frac{s''(r)}{\\left(1 + \\left[s'(r)\\right]^2\\right)^{3/2}}\n$$\n该公式表明，要计算曲率，我们必须确定矢状高函数在所需位置的一阶和二阶导数，$s'(r)$ 和 $s''(r)$。\n\n提供的输入数据不是直接的真实矢状高 $s_{\\text{true}}(r)$，而是相对于一个已知半径为 $R_{\\text{bfs}}$ 的最佳拟合球面（BFS）的高程 $e(r)$。它们之间的关系定义为：\n$$\ne(r) = s_{\\text{true}}(r) - s_{\\text{sphere}}(r; R_{\\text{bfs}})\n$$\n其中 $s_{\\text{sphere}}(r; R_{\\text{bfs}})$ 是最佳拟合球面的矢状高。根据初等几何，半径为 $R$ 的球面的矢状高为：\n$$\ns_{\\text{sphere}}(r; R) = R - \\sqrt{R^2 - r^2}\n$$\n因此，算法的第一步是从给定的高程数据重建真实的矢状高剖面。给定在相应半弦 $r_j$ 处的离散高程样本 $e_j$，我们计算真实的矢状高样本 $s_j$：\n$$\ns_j = s_{\\text{true}}(r_j) = e_j + s_{\\text{sphere}}(r_j; R_{\\text{bfs}}) = e_j + \\left( R_{\\text{bfs}} - \\sqrt{R_{\\text{bfs}}^2 - r_j^2} \\right)\n$$\n这样就得到了一组位于真实角膜子午线上的离散点 $(r_j, s_j)$。\n\n问题的核心在于如何从这些离散且可能带噪声的数据中准确估计导数 $s'(r)$ 和 $s''(r)$。问题指定了一种数值稳健的方法：局部多项式回归。对于每个需要计算曲率的目标半弦 $r^\\ast$，应用以下步骤：\n\n1.  **局部数据选择**：通过识别径向坐标 $r_k$ 与目标 $r^\\ast$ 最接近的 $p$ 个样本点 $(r_k, s_k)$ 来选择一个局部数据邻域。问题指定使用一个 $3$ 次多项式和一个包含 $p=7$ 个最近样本的窗口，这足以提供一个稳定的最小二乘拟合。\n\n2.  **坐标系平移**：为了增强数值稳定性并避免病态问题，通过将原点平移到目标点来建立一个局部坐标系：$x = r - r^\\ast$。在这个新系统中，局部数据点为 $(x_k, s_k)$，其中 $x_k = r_k - r^\\ast$。\n\n3.  **局部多项式拟合**：在平移坐标系中，局部矢状剖面由一个三次多项式近似：\n    $$\n    s(x) \\approx P(x) = c_0 + c_1 x + c_2 x^2 + c_3 x^3\n    $$\n    系数 $\\mathbf{c} = [c_0, c_1, c_2, c_3]^T$ 通过求解一个线性最小二乘问题来确定，该问题旨在最小化多项式与局部数据样本 $s_k$ 之间的平方差之和：\n    $$\n    \\min_{\\mathbf{c}} \\sum_{k=1}^{p} \\left(s_k - P(x_k)\\right)^2\n    $$\n    这等价于求解矩阵方程 $\\min_{\\mathbf{c}} \\|\\mathbf{A}\\mathbf{c} - \\mathbf{s}_{\\text{local}}\\|_2^2$，其中 $\\mathbf{s}_{\\text{local}}$ 是局部矢状高值的向量，$\\mathbf{A}$ 是范德蒙式设计矩阵：\n    $$\n    \\mathbf{A} = \\begin{pmatrix} 1  x_1  x_1^2  x_1^3 \\\\ 1  x_2  x_2^2  x_2^3 \\\\ \\vdots  \\vdots  \\vdots  \\vdots \\\\ 1  x_p  x_p^2  x_p^3 \\end{pmatrix}\n    $$\n    这个超定系统的解给出了局部多项式 $P(x)$ 的最优系数。\n\n4.  **导数评估**：真实矢状高函数 $s(r)$ 在目标点 $r^\\ast$ 处的导数，由拟合多项式 $P(x)$ 在 $x=0$ 处的导数来近似。\n    $$\n    s'(r^\\ast) \\approx P'(0) \\quad \\text{和} \\quad s''(r^\\ast) \\approx P''(0)\n    $$\n    $P(x)$ 的导数为 $P'(x) = c_1 + 2c_2x + 3c_3x^2$ 和 $P''(x) = 2c_2 + 6c_3x$。在 $x=0$ 处求值，我们得到非常简洁的估计值：\n    $$\n    s'(r^\\ast) \\approx c_1 \\quad \\text{和} \\quad s''(r^\\ast) \\approx 2c_2\n    $$\n\n5.  **曲率计算**：最后，将估计的导数代入曲率公式：\n    $$\n    \\kappa(r^\\ast) = \\frac{s''(r^\\ast)}{(1 + [s'(r^\\ast)]^2)^{3/2}} \\approx \\frac{2c_2}{(1 + c_1^2)^{3/2}}\n    $$\n    对每个测试用例中的每个目标点重复此过程，并将最终结果按要求四舍五入到六位小数。这种方法对内部点和边界点都具有稳健性，并能有效处理非均匀采样和噪声。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the corneal curvature problem by implementing the specified algorithm\n    for all test cases.\n    \"\"\"\n\n    def s_sphere(r, R):\n        \"\"\"Calculates the sagittal height of a sphere.\"\"\"\n        r = np.asarray(r)\n        # Ensure that sqrt is taken of non-negative values.\n        # This condition holds for all test cases.\n        arg = R**2 - r**2\n        return R - np.sqrt(arg)\n\n    def s_conicoid(r, R0, Q):\n        \"\"\"Calculates the sagittal height of a conicoid surface.\"\"\"\n        r = np.asarray(r)\n        # Handle the apex r=0 separately to avoid potential 0/0 issues in some contexts,\n        # although with numpy vectorization it's handled correctly as long as r is an array.\n        if np.isscalar(r) and r == 0:\n            return 0.0\n        \n        val_under_sqrt = 1 - (1 + Q) * r**2 / R0**2\n        # This condition holds for all test cases.\n        denominator = R0 * (1 + np.sqrt(val_under_sqrt))\n        sag = np.zeros_like(r)\n        # Avoid division by zero if r contains 0\n        non_zero_mask = r != 0\n        sag[non_zero_mask] = (r[non_zero_mask]**2) / denominator[non_zero_mask]\n        return sag\n\n    def compute_curvature_at_target(r_samples, s_samples, r_target, p, deg):\n        \"\"\"\n        Computes curvature at a target point using local polynomial fitting.\n        \"\"\"\n        # 1. Find p nearest neighbors\n        distances = np.abs(r_samples - r_target)\n        nearest_indices = np.argsort(distances)[:p]\n        \n        r_local = r_samples[nearest_indices]\n        s_local = s_samples[nearest_indices]\n        \n        # 2. Shift coordinates for numerical stability\n        x_local = r_local - r_target\n        \n        # 3. Construct Vandermonde matrix for least squares\n        # increasing=True gives [1, x, x^2, ...], so c[i] is the coeff of x^i\n        A = np.vander(x_local, N=deg + 1, increasing=True)\n        \n        # 4. Solve for polynomial coefficients c\n        c, _, _, _ = np.linalg.lstsq(A, s_local, rcond=None)\n        \n        # 5. Get derivatives at x=0 (which is r=r_target)\n        # For P(x) = c0 + c1*x + c2*x^2 + c3*x^3\n        # P'(0) = c1\n        # P''(0) = 2*c2\n        s_prime = c[1]\n        s_double_prime = 2 * c[2]\n        \n        # 6. Compute signed curvature\n        kappa = s_double_prime / (1 + s_prime**2)**(3/2)\n        \n        return kappa\n\n    # --- Test Case Definitions ---\n    # Common parameters\n    poly_deg = 3\n    \n    # Case A\n    case_A_params = {\n        \"R0\": 0.0078, \"Q\": -0.26, \"R_bfs\": 0.0078,\n        \"r_samples\": np.linspace(0.0, 0.004, 9),\n        \"targets\": [0.0000, 0.0020, 0.0040],\n        \"sag_func\": lambda r, p: s_conicoid(r, p[\"R0\"], p[\"Q\"])\n    }\n\n    # Case B\n    case_B_params = {\n        \"R\": 0.0080, \"R_bfs\": 0.0080,\n        \"r_samples\": np.linspace(0.0, 0.004, 9),\n        \"targets\": [0.0000, 0.0020, 0.0040],\n        \"sag_func\": lambda r, p: s_sphere(r, p[\"R\"])\n    }\n\n    # Case C\n    case_C_params = {\n        \"R_bfs\": 0.0080,\n        \"r_samples\": np.linspace(0.0, 0.004, 9),\n        \"targets\": [0.0000, 0.0020, 0.0040],\n        \"sag_func\": lambda r, p: np.zeros_like(r)\n    }\n\n    # Case D\n    case_D_params = {\n        \"R0\": 0.0078, \"Q\": -0.50, \"R_bfs\": 0.0078,\n        \"r_samples\": np.linspace(0.0, 0.004, 9),\n        \"targets\": [0.0000, 0.0035, 0.0040],\n        \"sag_func\": lambda r, p: s_conicoid(r, p[\"R0\"], p[\"Q\"]),\n        \"noise_sigma\": 1e-6,\n        \"noise_seed\": 12345\n    }\n\n    # Case E\n    case_E_params = {\n        \"R\": 0.0080, \"R_bfs\": 0.0080,\n        \"r_samples\": np.array([0.0000, 0.0003, 0.0007, 0.0012, 0.0020, 0.0028, 0.0036, 0.0040]),\n        \"targets\": [0.0000, 0.0028, 0.0040],\n        \"sag_func\": lambda r, p: s_sphere(r, p[\"R\"])\n    }\n\n    test_cases = [case_A_params, case_B_params, case_C_params, case_D_params, case_E_params]\n    all_results = []\n\n    for case_params in test_cases:\n        r_samples = case_params[\"r_samples\"]\n        R_bfs = case_params[\"R_bfs\"]\n        targets = case_params[\"targets\"]\n        N = len(r_samples)\n        p_neighbors = min(7, N)\n\n        # Generate true sag and elevation data\n        s_true_samples = case_params[\"sag_func\"](r_samples, case_params)\n        e_samples = s_true_samples - s_sphere(r_samples, R_bfs)\n\n        # Add noise for Case D\n        if \"noise_sigma\" in case_params:\n            rng = np.random.default_rng(case_params[\"noise_seed\"])\n            noise = rng.normal(0, case_params[\"noise_sigma\"], size=e_samples.shape)\n            e_samples += noise\n\n        # Reconstruct true sag from elevation data (the \"measured\" data)\n        s_reconstructed = e_samples + s_sphere(r_samples, R_bfs)\n        \n        case_curvatures = []\n        for r_target in targets:\n            kappa = compute_curvature_at_target(\n                r_samples, s_reconstructed, r_target, p_neighbors, poly_deg\n            )\n            # Round to six decimal places\n            case_curvatures.append(round(kappa, 6))\n        \n        all_results.append(case_curvatures)\n\n    # Format output string\n    # Using str() on a list of lists and removing spaces meets the exact format\n    output_str = str(all_results).replace(\" \", \"\")\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "角膜地形图仪可以生成多种类型的曲率图，其中轴向图和切向图最为常见，但它们对于同一角膜表面可能呈现出截然不同的形态。这项高级练习  深入探讨了区分这两种绘图方法的根本几何定义。通过为一个具有局部陡峭区域的假设角膜推导两种曲率类型，您将分析并量化轴向图如何显著低估峰值曲率——这是正确诊断和分级如圆锥角膜等角膜扩张性疾病的关键概念。",
            "id": "4667536",
            "problem": "基于普拉西多盘的角膜地形图仪测量角膜前表面沿单一子午线相对于光轴的斜率场。考虑一个由矢高函数建模的旋转对称子午线轮廓\n$$\nz(r) \\;=\\; \\frac{A}{2}\\,r^{2} \\;-\\; h\\,\\exp\\!\\Big(-\\frac{(r-r_{c})^{2}}{2\\sigma^{2}}\\Big),\n$$\n其中 $r$ 是距光轴的径向距离，$A$ 是基线二次系数，$h$ 和 $\\sigma$ 分别设定了中心位于 $r=r_{c}$ 的局部陡峭化的振幅和宽度。假设 $A = 1/R_{0}$，基线半径 $R_{0} = 7.8\\,\\mathrm{mm}$，$r_{c} = 3.0\\,\\mathrm{mm}$，$h = 0.05\\,\\mathrm{mm}$，且 $\\sigma = 0.50\\,\\mathrm{mm}$。所有角度均以弧度为单位处理，曲率以 $\\mathrm{mm}^{-1}$ 为单位表示。\n\n仅从基本定义出发：\n- 子午线轮廓相对于光轴的切线角 $\\theta(r)$ 满足 $\\tan\\!\\theta(r) = dz/dr$。\n- 沿子午线的弧长微分是 $ds = \\sqrt{1 + (dz/dr)^{2}}\\,dr$。\n- 子午（瞬时）曲率等于 $d\\theta/ds$。\n- 半径 $r$ 处的轴向（矢状）曲率的定义是：约束局部密切圆的圆心位于光轴上，并与局部切线角 $\\theta(r)$ 相匹配。\n\n以这些为基础，根据给定的矢高函数，推导局部陡峭化中心 $r=r_{c}$ 处的子午曲率和轴向曲率的表达式。然后计算在 $r=r_{c}$ 处，轴向图对曲率峰值的分数低估值，其定义为\n$$\nU \\;=\\; \\frac{\\kappa_{t}(r_{c}) - \\kappa_{a}(r_{c})}{\\kappa_{t}(r_{c})},\n$$\n其中 $\\kappa_{t}$ 表示子午曲率，$\\kappa_{a}$ 表示轴向曲率。将您的最终结果 $U$ 四舍五入至四位有效数字。将 $U$ 表示为无单位的小数。",
            "solution": "用户想要解决一个眼科学领域的问题。该问题已被验证，并被确定为一个有效的、可解的问题。解决方案如下。\n\n该问题要求计算在建模的角膜表面上某特定点处，轴向曲率对子午曲率的分数低估值。分数低估值 $U$ 定义为：\n$$\nU \\;=\\; \\frac{\\kappa_{t}(r_{c}) - \\kappa_{a}(r_{c})}{\\kappa_{t}(r_{c})} \\;=\\; 1 - \\frac{\\kappa_{a}(r_{c})}{\\kappa_{t}(r_{c})}\n$$\n其中 $\\kappa_t$ 是子午曲率，$\\kappa_a$ 是轴向曲率，$r_c$ 是局部陡峭化特征中心的径向位置。\n\n首先，我们必须根据所提供的定义和矢高函数 $z(r)$ 推导出子午曲率和轴向曲率的通用表达式。\n\n矢高函数由下式给出：\n$$\nz(r) \\;=\\; \\frac{A}{2}\\,r^{2} \\;-\\; h\\,\\exp\\!\\Big(-\\frac{(r-r_{c})^{2}}{2\\sigma^{2}}\\Big)\n$$\n切线角 $\\theta(r)$ 由 $\\tan\\theta(r) = dz/dr$ 定义。令 $z'(r) = dz/dr$ 且 $z''(r) = d^2z/dr^2$。\n\n子午曲率 $\\kappa_t$ 定义为 $\\kappa_t = d\\theta/ds$。使用链式法则，我们可以写出 $\\kappa_t = \\frac{d\\theta/dr}{ds/dr}$。\n从 $\\theta(r) = \\arctan(z'(r))$ 出发，我们对 $r$ 求导：\n$$\n\\frac{d\\theta}{dr} = \\frac{d}{dr}\\arctan(z'(r)) = \\frac{z''(r)}{1 + (z'(r))^2}\n$$\n弧长微分由 $ds = \\sqrt{1 + (z'(r))^{2}}\\,dr$ 给出，这意味着 $\\frac{ds}{dr} = \\sqrt{1 + (z'(r))^{2}}$。\n将这些代入 $\\kappa_t$ 的表达式中：\n$$\n\\kappa_t(r) = \\frac{d\\theta/dr}{ds/dr} = \\frac{z''(r) / (1 + (z'(r))^2)}{\\sqrt{1 + (z'(r))^2}} = \\frac{z''(r)}{\\left[1 + (z'(r))^2\\right]^{3/2}}\n$$\n这是旋转对称曲面子午曲率的通用公式。\n\n轴向曲率 $\\kappa_a$ 由一个圆心在光轴上的密切圆定义。对于子午线上的一个点 $(r, z(r))$，轴向圆的半径 $R_a$ 是从该点到轴上曲率中心的距离。几何构造表明 $r = R_a \\sin\\theta(r)$。\n因此，轴向曲率 $\\kappa_a = 1/R_a$ 由下式给出：\n$$\n\\kappa_a(r) = \\frac{\\sin\\theta(r)}{r}\n$$\n我们可以用 $\\tan\\theta(r) = z'(r)$ 来表示 $\\sin\\theta(r)$。假设斜率为正，$\\sin\\theta(r) = \\frac{\\tan\\theta(r)}{\\sqrt{1+\\tan^2\\theta(r)}} = \\frac{z'(r)}{\\sqrt{1+(z'(r))^2}}$。\n将此代入 $\\kappa_a(r)$ 的表达式中：\n$$\n\\kappa_a(r) = \\frac{1}{r}\\frac{z'(r)}{\\sqrt{1+(z'(r))^2}}\n$$\n这是轴向曲率的通用公式。\n\n接下来，我们计算给定矢高函数 $z(r)$ 的一阶和二阶导数。\n$$\nz'(r) = \\frac{d}{dr}\\left[ \\frac{A}{2}r^2 - h\\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right) \\right] = Ar - h \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right) \\left(-\\frac{2(r-r_c)}{2\\sigma^2}\\right)\n$$\n$$\nz'(r) = Ar + \\frac{h(r-r_c)}{\\sigma^2} \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right)\n$$\n再次求导以求得 $z''(r)$：\n$$\nz''(r) = A + \\frac{h}{\\sigma^2} \\frac{d}{dr}\\left[ (r-r_c) \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right) \\right]\n$$\n使用乘法法则：\n$$\nz''(r) = A + \\frac{h}{\\sigma^2}\\left[ \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right) + (r-r_c) \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right) \\left(-\\frac{r-r_c}{\\sigma^2}\\right) \\right]\n$$\n$$\nz''(r) = A + \\frac{h}{\\sigma^2}\\left[1 - \\frac{(r-r_c)^2}{\\sigma^2}\\right] \\exp\\left(-\\frac{(r-r_c)^2}{2\\sigma^2}\\right)\n$$\n\n问题要求在陡峭化中心 $r=r_c$ 处进行求值。在这一点，$(r-r_c)$ 项为零，这显著简化了导数。\n$$\nz'(r_c) = A r_c + \\frac{h(r_c-r_c)}{\\sigma^2} \\exp(0) = Ar_c\n$$\n$$\nz''(r_c) = A + \\frac{h}{\\sigma^2}\\left[1 - 0\\right] \\exp(0) = A + \\frac{h}{\\sigma^2}\n$$\n\n现在我们可以写出在 $r=r_c$ 处的曲率表达式：\n$$\n\\kappa_t(r_c) = \\frac{z''(r_c)}{\\left[1 + (z'(r_c))^2\\right]^{3/2}} = \\frac{A + h/\\sigma^2}{\\left[1 + (Ar_c)^2\\right]^{3/2}}\n$$\n$$\n\\kappa_a(r_c) = \\frac{z'(r_c)}{r_c\\sqrt{1+(z'(r_c))^2}} = \\frac{Ar_c}{r_c\\sqrt{1+(Ar_c)^2}} = \\frac{A}{\\sqrt{1+(Ar_c)^2}}\n$$\n\n现在我们可以计算比率 $\\kappa_a(r_c)/\\kappa_t(r_c)$：\n$$\n\\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = \\frac{A/\\sqrt{1+(Ar_c)^2}}{(A+h/\\sigma^2)/[1+(Ar_c)^2]^{3/2}} = \\frac{A}{\\sqrt{1+(Ar_c)^2}} \\cdot \\frac{[1+(Ar_c)^2]^{3/2}}{A+h/\\sigma^2}\n$$\n$$\n\\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = \\frac{A}{A+h/\\sigma^2} \\cdot \\frac{[1+(Ar_c)^2]^{3/2}}{[1+(Ar_c)^2]^{1/2}} = \\frac{A\\left(1+(Ar_c)^2\\right)}{A+h/\\sigma^2}\n$$\n现在，我们代入给定的数值：\n$A = 1/R_0 = 1/7.8\\,\\mathrm{mm}^{-1}$\n$r_c = 3.0\\,\\mathrm{mm}$\n$h = 0.05\\,\\mathrm{mm}$\n$\\sigma = 0.50\\,\\mathrm{mm}$，所以 $\\sigma^2 = 0.25\\,\\mathrm{mm}^2$。\n\n让我们计算比率表达式的各个组成部分：\n$$\nAr_c = \\frac{1}{7.8} \\times 3.0 = \\frac{3.0}{7.8} = \\frac{30}{78} = \\frac{5}{13}\n$$\n$$\n\\frac{h}{\\sigma^2} = \\frac{0.05}{0.25} = 0.2\\,\\mathrm{mm}^{-1}\n$$\n将这些代入比率公式中：\n$$\n\\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = \\frac{A\\left(1+(Ar_c)^2\\right)}{A+h/\\sigma^2} = \\frac{(1/7.8)\\left(1+(5/13)^2\\right)}{1/7.8 + 0.2}\n$$\n为避免舍入误差，我们使用分数进行计算。$A = 1/7.8 = 10/78 = 5/39$。$h/\\sigma^2 = 0.2 = 1/5$。\n$$\nA + \\frac{h}{\\sigma^2} = \\frac{5}{39} + \\frac{1}{5} = \\frac{25+39}{195} = \\frac{64}{195}\n$$\n$$\n1 + (Ar_c)^2 = 1 + \\left(\\frac{5}{13}\\right)^2 = 1 + \\frac{25}{169} = \\frac{169+25}{169} = \\frac{194}{169}\n$$\n现在将这些代回比率计算中：\n$$\n\\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = \\frac{A(1+(Ar_c)^2)}{A+h/\\sigma^2} = \\frac{(5/39)(194/169)}{64/195} = \\frac{5}{39} \\cdot \\frac{194}{169} \\cdot \\frac{195}{64}\n$$\n由于 $195 = 5 \\times 39$：\n$$\n\\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = \\frac{5}{39} \\cdot \\frac{194}{169} \\cdot \\frac{5 \\times 39}{64} = \\frac{25 \\times 194}{169 \\times 64} = \\frac{25 \\times (2 \\times 97)}{169 \\times (2 \\times 32)} = \\frac{25 \\times 97}{169 \\times 32} = \\frac{2425}{5408}\n$$\n最后，我们计算分数低估值 $U$：\n$$\nU = 1 - \\frac{\\kappa_a(r_c)}{\\kappa_t(r_c)} = 1 - \\frac{2425}{5408} = \\frac{5408 - 2425}{5408} = \\frac{2983}{5408}\n$$\n将此分数转换为小数：\n$$\nU = \\frac{2983}{5408} \\approx 0.5515902366...\n$$\n按要求将结果四舍五入到四位有效数字，得到 $0.5516$。",
            "answer": "$$\n\\boxed{0.5516}\n$$"
        }
    ]
}