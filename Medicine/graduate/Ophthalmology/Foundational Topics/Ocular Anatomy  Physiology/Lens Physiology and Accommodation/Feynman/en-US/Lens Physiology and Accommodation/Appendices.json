{
    "hands_on_practices": [
        {
            "introduction": "Understanding accommodation begins with quantifying its effect. This first practice grounds your understanding in the fundamental language of clinical optics: vergence. By treating the eye as a simplified optical system, you will derive the definition of accommodative amplitude from first principles and use it to calculate a key clinical parameter, the near point of vision . This exercise is crucial for connecting the abstract concept of dioptric power to the tangible experience of clear near vision.",
            "id": "4688669",
            "problem": "An emmetropic human eye at distance viewing has its far point at optical infinity and focuses distant objects onto the retina without any accommodative effort. Accommodation increases the eye’s optical power via ciliary muscle contraction, making the crystalline lens more convex. In clinical and physiological optics, optical power is measured in diopters, where one diopter is defined as the reciprocal of focal length in meters. Treat the eye as a single thin optical system whose principal plane coincides with the corneal vertex, and use the vergence formulation in paraxial optics with air as the object space of refractive index $n = 1$.\n\nStarting from first principles (vergence addition and the condition for retinal conjugacy in an emmetropic eye), formally define the accommodative amplitude in diopters as a quantitative measure, and then derive the near point object distance (measured from the corneal vertex) for an eye whose distance refraction is emmetropia and whose accommodative amplitude equals $3\\,\\mathrm{D}$. Assume zero lag of accommodation and ignore depth-of-field and finite pupil size effects.\n\nRound your final distance to four significant figures and express it in centimeters. Your final numerical result must be a single real number.",
            "solution": "The analysis begins with the fundamental paraxial optics equation for a thin optical system, expressed in terms of vergence. The vergence-refraction equation, also known as the vergence form of the thin lens equation, is given by:\n$$L' = L + P$$\nHere, $L$ represents the object vergence, $P$ is the optical power of the system, and $L'$ is the image vergence. Vergence is defined as the ratio of the refractive index of the medium to the distance from a reference plane (in this case, the principal plane of the optical system). For an object in air with refractive index $n=1$ at a distance $l$ from the principal plane, the object vergence is $L = \\frac{1}{l}$. Similarly, for the image at a distance $l'$ in a medium of refractive index $n'$, the image vergence is $L' = \\frac{n'}{l'}$. All distances are measured in meters ($\\mathrm{m}$), and all vergences and powers are measured in diopters ($\\mathrm{D}$), where $1 \\, \\mathrm{D} = 1 \\, \\mathrm{m}^{-1}$. By convention, distances for real objects to the left of the optical system are negative, and distances for real images to the right are positive.\n\nFor the human eye, the image must be focused on the retina. The distance from the principal plane to the retina, $l'_{retina}$, is fixed. The refractive index of the vitreous humor, $n'_{vit}$, is also constant. Therefore, the image vergence required for clear vision is a constant value for a given eye:\n$$L'_{retina} = \\frac{n'_{vit}}{l'_{retina}} = K$$\nwhere $K$ is a constant representing the ocular vergence requirement. The fundamental condition for the eye to be in focus is thus:\n$$K = L + P_{eye}$$\nwhere $P_{eye}$ is the total optical power of the eye, which can vary through accommodation.\n\nFirst, we analyze the unaccommodated (fully relaxed) emmetropic eye. An emmetropic eye is one that focuses parallel light from a distant object (at optical infinity) onto the retina without any accommodative effort.\nThe object distance for a distant object is $l \\to -\\infty$.\nThe corresponding object vergence is $L_{fp} = \\frac{1}{-\\infty} = 0 \\, \\mathrm{D}$. This defines the far point ($fp$) vergence.\nLet $P_{unacc}$ be the power of the unaccommodated eye. The focusing condition becomes:\n$$K = L_{fp} + P_{unacc} = 0 + P_{unacc}$$\nThus, for an emmetropic eye, its unaccommodated power is exactly equal to the required ocular vergence: $P_{unacc} = K$.\n\nNext, we analyze the fully accommodated eye. When the eye exerts its maximum accommodative effort, it is focused on its near point ($np$). Let the near point be at an object distance $l_{np}$ from the principal plane.\nThe object vergence for the near point is $L_{np} = \\frac{1}{l_{np}}$.\nLet $P_{acc}$ be the power of the fully accommodated eye. The focusing condition for the near point is:\n$$K = L_{np} + P_{acc}$$\n\nAccommodative amplitude, denoted by $A$, is formally defined as the maximum increase in the eye's optical power from the unaccommodated state to the fully accommodated state.\n$$A = P_{acc} - P_{unacc}$$\nWe can now substitute the expressions derived from the focusing conditions into this definition. From the near point condition, we have $P_{acc} = K - L_{np}$. From the far point condition for emmetropia, we have $P_{unacc} = K$.\nSubstituting these into the definition of $A$:\n$$A = (K - L_{np}) - K = -L_{np}$$\nThis is the formal definition of accommodative amplitude derived from first principles: the accommodative amplitude is equal to the negative of the object vergence of the near point.\n\nThe near point object *distance*, which we will denote as $d_{np}$, is the conventionally positive distance from the corneal vertex (our principal plane) to the near point. Following the sign convention, the object position is $l_{np} = -d_{np}$.\nThe near point vergence is therefore $L_{np} = \\frac{1}{l_{np}} = \\frac{1}{-d_{np}}$.\nSubstituting this into our definition of $A$:\n$$A = -L_{np} = -\\left(\\frac{1}{-d_{np}}\\right) = \\frac{1}{d_{np}}$$\nThis result shows that the accommodative amplitude in diopters is equal to the reciprocal of the near point distance measured in meters.\n\nThe problem requires the calculation of the near point object distance for an emmetropic eye with an accommodative amplitude of $A = 3 \\, \\mathrm{D}$.\nUsing the derived relationship:\n$$A = \\frac{1}{d_{np}}$$\nWe solve for the near point distance $d_{np}$:\n$$d_{np} = \\frac{1}{A}$$\nSubstituting the given value for $A$:\n$$d_{np} = \\frac{1}{3 \\, \\mathrm{D}} = \\frac{1}{3} \\, \\mathrm{m}$$\nThe problem asks for the distance to be expressed in centimeters ($\\mathrm{cm}$) and rounded to four significant figures. We perform the unit conversion:\n$$d_{np} = \\frac{1}{3} \\, \\mathrm{m} \\times \\frac{100 \\, \\mathrm{cm}}{1 \\, \\mathrm{m}} = \\frac{100}{3} \\, \\mathrm{cm}$$\nNow, we perform the division and rounding:\n$$d_{np} = 33.3333... \\, \\mathrm{cm}$$\nRounding to four significant figures gives:\n$$d_{np} = 33.33 \\, \\mathrm{cm}$$",
            "answer": "$$\\boxed{33.33}$$"
        },
        {
            "introduction": "While the thin-lens model is useful, the crystalline lens is a substantial physical structure. This exercise advances our model to a thick lens, providing a more accurate representation of its optical properties . You will derive the formula for a thick lens's power and apply it to a hypothetical scenario that mimics the shape change during accommodation, directly linking the lens's physical geometry to its function.",
            "id": "4688647",
            "problem": "A young human crystalline lens is modeled as a homogeneous, rotationally symmetric thick lens immersed in the same isotropic medium on both sides (aqueous humor and vitreous body), each with refractive index $n_{m}$. The lens material has uniform refractive index $n_{\\ell}$. Light propagates from left to right. Adopt the standard paraxial sign convention: a surface radius of curvature $R$ is positive if its center of curvature lies to the right of the surface, negative otherwise; the central thickness $t$ is measured along the optical axis and is positive. Assume the paraxial approximation holds.\n\nStarting only from the first principles of paraxial Gaussian optics for centered systems (namely, refraction at spherical interfaces between media of refractive indices $n_{1}$ and $n_{2}$ and free-space propagation in a homogeneous medium), derive the expression for the equivalent paraxial optical power of a thick lens formed by two spherical refracting surfaces separated by a finite central thickness, when the surrounding media on both sides have the same refractive index $n_{m}$. Then, using that expression, compute the change in optical power for the following accommodation-like change in curvatures while central thickness is held fixed by an external constraint.\n\nThe surrounding medium refractive index is $n_{m} = 1.336$, the lens refractive index is $n_{\\ell} = 1.42$, and the central thickness is $t = 3.6\\,\\mathrm{mm}$. In the baseline state, the anterior and posterior radii are $R_{1,0} = +10.0\\,\\mathrm{mm}$ and $R_{2,0} = -6.0\\,\\mathrm{mm}$, respectively. In the altered state mimicking increased curvature with constrained thickness, the anterior and posterior radii change to $R_{1,1} = +8.5\\,\\mathrm{mm}$ and $R_{2,1} = -5.3\\,\\mathrm{mm}$, respectively. All distances are along the optical axis; use meters in all calculations.\n\nCompute the signed change in total optical power $\\Delta F = F_{1} - F_{0}$ between the altered and baseline states. Round your final numerical answer to four significant figures and express it in diopters ($\\mathrm{D}$). State your final answer as a single number.",
            "solution": "The solution proceeds in two parts. First, we derive the expression for the equivalent optical power of a thick lens from first principles. Second, we apply this formula to the given numerical data for the two states of the lens and compute the change in power.\n\n**Part 1: Derivation of the Thick Lens Power Formula**\n\nWe consider a centered optical system consisting of two spherical surfaces with radii of curvature $R_1$ and $R_2$, separated by a distance $t$ along the optical axis. The lens material has a refractive index $n_{\\ell}$, and it is immersed in a medium of refractive index $n_m$ on both sides. The equivalent power $F$ of an optical system is defined for a ray incident parallel to the optical axis at a height $y_1$. The ray emerges from the system with a final angle $\\alpha'$ relative to the axis. The power is then given by the relation $F = -\\frac{n_m \\alpha'}{y_1}$.\n\nLet's trace such a ray through the system.\n1.  **Refraction at the first surface (anterior, radius $R_1$)**:\n    An incident ray parallel to the axis ($\\alpha_1 = 0$) at height $y_1$ strikes the first surface. The paraxial refraction equation at an interface between media $n_a$ and $n_b$ is $n_b \\alpha_b = n_a \\alpha_a - y \\frac{n_b - n_a}{R}$.\n    Here, $n_a = n_m$, $n_b = n_{\\ell}$, $\\alpha_a = 0$, and the ray height is $y_1$. The angle of the ray inside the lens, $\\alpha_{\\ell}$, is given by:\n    $$n_{\\ell} \\alpha_{\\ell} = n_m (0) - y_1 \\frac{n_{\\ell} - n_m}{R_1}$$\n    The power of the first surface is $P_1 = \\frac{n_{\\ell} - n_m}{R_1}$. Thus:\n    $$n_{\\ell} \\alpha_{\\ell} = -y_1 P_1 \\implies \\alpha_{\\ell} = -\\frac{y_1 P_1}{n_{\\ell}}$$\n\n2.  **Propagation through the lens**:\n    The ray propagates a distance $t$ through the lens medium (refractive index $n_{\\ell}$). The height of the ray at the second surface, $y_2$, is given by the paraxial translation equation $y_{final} = y_{initial} + d \\cdot \\alpha$, where $d$ is the axial distance.\n    $$y_2 = y_1 + t \\alpha_{\\ell} = y_1 + t \\left(-\\frac{y_1 P_1}{n_{\\ell}}\\right) = y_1 \\left(1 - \\frac{t P_1}{n_{\\ell}}\\right)$$\n\n3.  **Refraction at the second surface (posterior, radius $R_2$)**:\n    The ray with angle $\\alpha_{\\ell}$ and height $y_2$ strikes the second surface. It refracts from the lens ($n_{\\ell}$) back into the surrounding medium ($n_m$). The final emergent angle is $\\alpha'$. The paraxial refraction equation is:\n    $$n_m \\alpha' = n_{\\ell} \\alpha_{\\ell} - y_2 \\frac{n_m - n_{\\ell}}{R_2}$$\n    The power of the second surface is $P_2 = \\frac{n_m - n_{\\ell}}{R_2}$. Substituting this, we get:\n    $$n_m \\alpha' = n_{\\ell} \\alpha_{\\ell} - y_2 P_2$$\n    Now, we substitute the expressions for $\\alpha_{\\ell}$ and $y_2$ from the previous steps:\n    $$n_m \\alpha' = n_{\\ell} \\left(-\\frac{y_1 P_1}{n_{\\ell}}\\right) - y_1 \\left(1 - \\frac{t P_1}{n_{\\ell}}\\right) P_2$$\n    $$n_m \\alpha' = -y_1 P_1 - y_1 P_2 + y_1 \\frac{t P_1 P_2}{n_{\\ell}}$$\n    $$n_m \\alpha' = -y_1 \\left(P_1 + P_2 - \\frac{t P_1 P_2}{n_{\\ell}}\\right)$$\n\n4.  **Equivalent Power**:\n    From the definition of equivalent power, $F = -\\frac{n_m \\alpha'}{y_1}$. Comparing this with the expression above, we find the formula for the equivalent power of the thick lens:\n    $$F = P_1 + P_2 - \\frac{t}{n_{\\ell}} P_1 P_2$$\n    This is Gullstrand's equation, which we have derived from first principles.\n\n**Part 2: Calculation of the Change in Optical Power**\n\nWe are given the following parameters. All lengths must be converted to meters for calculations in diopters ($1\\,\\mathrm{D} = 1\\,\\mathrm{m}^{-1}$).\n- $n_{m} = 1.336$ (dimensionless)\n- $n_{\\ell} = 1.42$ (dimensionless)\n- $t = 3.6\\,\\mathrm{mm} = 3.6 \\times 10^{-3}\\,\\mathrm{m}$\n\nThe surface powers are given by $P_1 = \\frac{n_{\\ell} - n_m}{R_1}$ and $P_2 = \\frac{n_m - n_{\\ell}}{R_2}$.\nLet's compute the constant difference in refractive indices: $n_{\\ell} - n_m = 1.42 - 1.336 = 0.084$.\n\n**Baseline State (State 0)**\nThe radii are $R_{1,0} = +10.0\\,\\mathrm{mm} = 0.010\\,\\mathrm{m}$ and $R_{2,0} = -6.0\\,\\mathrm{mm} = -0.006\\,\\mathrm{m}$.\nThe surface powers are:\n$$P_{1,0} = \\frac{0.084}{0.010} = 8.4\\,\\text{D}$$\n$$P_{2,0} = \\frac{1.336 - 1.42}{-0.006} = \\frac{-0.084}{-0.006} = 14.0\\,\\text{D}$$\nThe total power of the lens in the baseline state, $F_0$, is:\n$$F_0 = P_{1,0} + P_{2,0} - \\frac{t}{n_{\\ell}} P_{1,0} P_{2,0}$$\n$$F_0 = 8.4 + 14.0 - \\frac{3.6 \\times 10^{-3}}{1.42} (8.4)(14.0)$$\n$$F_0 = 22.4 - \\frac{3.6 \\times 10^{-3}}{1.42} (117.6)$$\n$$F_0 = 22.4 - \\frac{0.42336}{1.42} \\approx 22.4 - 0.298140845$$\n$$F_0 \\approx 22.10185915\\,\\text{D}$$\n\n**Altered State (State 1)**\nThe radii are $R_{1,1} = +8.5\\,\\mathrm{mm} = 0.0085\\,\\mathrm{m}$ and $R_{2,1} = -5.3\\,\\mathrm{mm} = -0.0053\\,\\mathrm{m}$.\nThe surface powers are:\n$$P_{1,1} = \\frac{0.084}{0.0085} \\approx 9.88235294\\,\\text{D}$$\n$$P_{2,1} = \\frac{-0.084}{-0.0053} \\approx 15.84905660\\,\\text{D}$$\nThe total power of the lens in the altered state, $F_1$, is:\n$$F_1 = P_{1,1} + P_{2,1} - \\frac{t}{n_{\\ell}} P_{1,1} P_{2,1}$$\n$$F_1 \\approx (9.88235294 + 15.84905660) - \\frac{3.6 \\times 10^{-3}}{1.42} (9.88235294)(15.84905660)$$\n$$F_1 \\approx 25.73140954 - \\frac{3.6 \\times 10^{-3}}{1.42} (156.6259711)$$\n$$F_1 \\approx 25.73140954 - (0.002535211268)(156.6259711)$$\n$$F_1 \\approx 25.73140954 - 0.397143173$$\n$$F_1 \\approx 25.33426637\\,\\text{D}$$\n\n**Change in Optical Power**\nThe change in power is $\\Delta F = F_{1} - F_{0}$.\n$$\\Delta F \\approx 25.33426637 - 22.10185915$$\n$$\\Delta F \\approx 3.23240722\\,\\text{D}$$\n\nThe problem requires the final answer to be rounded to four significant figures.\n$$\\Delta F \\approx 3.232\\,\\text{D}$$",
            "answer": "$$\\boxed{3.232}$$"
        },
        {
            "introduction": "The optical changes during accommodation are driven by complex biomechanics, where forces from the ciliary body deform the elastic lens. This advanced practice invites you to build a computational thought experiment using a simplified finite element model to simulate this process . By programming a discrete elastic network, you will investigate how regional changes in lens stiffness—a hallmark of aging and presbyopia—directly impact the pattern of surface curvature change, bridging the gap between material science and clinical optics.",
            "id": "4688585",
            "problem": "You are asked to design and implement a finite element thought experiment to study how regional stiffening of the crystalline lens nucleus affects the pattern of surface curvature change under identical zonular load. The problem must be solved by constructing a simplified, small-strain, axisymmetric discrete elastic network that approximates the lens’s meridional cross-section and then computing the curvature change of the anterior and posterior surfaces from the deformed boundary. The experiment must be encoded as a complete, runnable program that produces a single-line output aggregating results for a provided test suite.\n\nBegin from the following fundamental base and core definitions:\n\n- Linear elasticity in the small-strain regime and static equilibrium: internal elastic forces balance external loads at equilibrium with no inertial terms. If $\\mathbf{f}_i$ denotes the net force on node $i$, then equilibrium requires $\\sum_i \\mathbf{f}_i = \\mathbf{0}$ and, for each internal connection, force follows Hooke’s law.\n- Hooke’s law for a linear axial spring: a spring connecting nodes $i$ and $j$ aligned along the unit vector $\\mathbf{u}_{ij}$ exerts an axial force of magnitude $k_{ij} \\,\\Delta \\ell_{ij}$, where $k_{ij}$ is the spring stiffness in $\\mathrm{N}/\\mathrm{m}$ and $\\Delta \\ell_{ij}$ is the change in projected length along $\\mathbf{u}_{ij}$ due to displacement. In the linearized small-displacement regime, the spring force contribution can be written as $k_{ij}\\, \\mathbf{u}_{ij} \\mathbf{u}_{ij}^{\\top} (\\mathbf{d}_j - \\mathbf{d}_i)$, where $\\mathbf{d}_i$ and $\\mathbf{d}_j$ are the displacement vectors of nodes $i$ and $j$ from their initial positions.\n- Static equilibrium for the assembled network: if $\\mathbf{K}$ is the global stiffness matrix and $\\mathbf{d}$ is the concatenated displacement vector, then $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$, where $\\mathbf{f}$ is the vector of externally applied nodal forces. Appropriate constraints are applied to remove rigid-body modes (for instance, fixing the central node).\n\nModeling assumptions and construction:\n\n1. Represent the lens meridional cross-section by concentric circular layers of nodes with angular divisions, forming an axisymmetric network. The initial outer boundary (cortex surface) is a circle of radius $R_0 = 0.005\\,\\mathrm{m}$. The nucleus radius is $r_n = 0.002\\,\\mathrm{m}$. Use three material layers: a central node at radius $0$ (nucleus center), an inner ring at radius $r_n$, a middle ring at radius $0.0035\\,\\mathrm{m}$, and an outer ring at radius $R_0$. Use $M = 32$ uniformly spaced angular nodes per ring. Angles are measured in radians.\n\n2. Springs and stiffness:\n   - Radial springs connect each node to its neighbor in the adjacent inner and outer layers along the same angle. The inner ring connects radially to the central node.\n   - Circumferential springs connect neighboring nodes within the same ring.\n   - Base cortex stiffnesses are $k_{\\text{rad,cortex}} = 50\\,\\mathrm{N}/\\mathrm{m}$ for radial springs and $k_{\\text{circ,cortex}} = 25\\,\\mathrm{N}/\\mathrm{m}$ for circumferential springs. Nucleus stiffening is represented by a multiplicative factor $\\phi$ applied to the nucleus spring stiffnesses: $k_{\\text{rad,nucleus}} = \\phi\\,k_{\\text{rad,cortex}}$ and $k_{\\text{circ,nucleus}} = \\phi\\,k_{\\text{circ,cortex}}$. For springs crossing the nucleus-cortex boundary, use the arithmetic mean of the corresponding region stiffnesses.\n\n3. Zonular load:\n   - Apply outward equatorial forces to outer boundary nodes with angular positions $\\theta$ satisfying $|\\theta| \\le \\theta_{\\text{eq}}$ or $|\\theta - \\pi| \\le \\theta_{\\text{eq}}$, where $\\theta_{\\text{eq}} = \\pi/9$ (radians).\n   - The load per affected boundary node is a constant $\\mathbf{F}_\\text{z}$ directed radially outward with magnitude $F_\\text{z} = 0.002\\,\\mathrm{N}$, identical across all test cases.\n\n4. Constraints:\n   - Fix the central node at the origin (both $x$ and $y$ displacements set to zero) to remove rigid-body translation. Angles are specified in radians.\n\n5. Surface curvature estimation:\n   - After solving for the equilibrium displacement field $\\mathbf{d}$, update node positions and extract the deformed outer boundary nodes. Split the boundary nodes into anterior nodes with $y>0$ and posterior nodes with $y<0$.\n   - Fit circles to the anterior and posterior boundary node sets using an algebraic least-squares fit to the form $x^2 + y^2 + A x + B y + C = 0$; the circle center is $(a,b) = (-A/2,-B/2)$ and radius $R=\\sqrt{(A^2+B^2)/4 - C}$.\n   - Let $R_a$ be the fitted anterior radius and $R_p$ be the fitted posterior radius. Compute changes from the initial radius $R_0$: $\\Delta R_a = R_a - R_0$ and $\\Delta R_p = R_p - R_0$.\n\n6. Physical units and answer specification:\n   - All lengths and radii must be treated in $\\mathrm{m}$ and forces in $\\mathrm{N}$. The program must output the curvature radius changes in meters (i.e., $\\Delta R_a$ and $\\Delta R_p$) for each test case.\n   - Angles must be handled in radians.\n\n7. Test suite:\n   - Evaluate $\\phi$ values $[1.0, 3.0, 10.0, 0.5, 100.0]$ with the same load $F_\\text{z}$ and identical mesh and constraints. These cover a general case, moderate stiffening, strong stiffening, nucleus softening, and an extreme stiffening boundary case.\n\n8. Final output format:\n   - Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result corresponds to one test case and is a two-element list with the anterior and posterior curvature radius changes in meters. For example: \"[[deltaRa1,deltaRp1],[deltaRa2,deltaRp2],...]\" where each \"deltaR\" is a float in meters. No additional text is permitted in the output.\n\nYour task: Implement the discrete elastic network, assemble the global stiffness matrix using the linearized axial spring model, solve for the static equilibrium under the specified boundary forces, fit circles to the deformed anterior and posterior boundaries, and report $\\Delta R_a$ and $\\Delta R_p$ for each $\\phi$ in the test suite. Ensure scientific realism through consistent units and small-strain linearization. Angles must be in radians. The final output must be a single-line list as specified above. No user input or external files are permitted.",
            "solution": "The problem has been validated and is determined to be self-contained, scientifically grounded, and well-posed. The following solution provides a complete implementation of the specified finite element thought experiment.\n\nThe core of this problem is to model the static mechanical response of a simplified crystalline lens to external forces and to quantify how this response changes with regional material properties. We employ a discrete elastic network, a simplified form of the finite element method, to represent the lens's meridional cross-section. The equilibrium deformation is found by solving the linear system of equations that arises from Hooke's law under the small-strain assumption.\n\n**1. Model Discretization and Network Topology**\n\nThe continuous meridional cross-section of the lens is discretized into a finite number of nodes arranged in concentric layers. This structure respects the specified axisymmetric simplification.\n- A single central node is placed at the origin, with radius $r=0\\,\\mathrm{m}$.\n- Three concentric rings of nodes are defined at radii $r_1 = r_n = 0.002\\,\\mathrm{m}$ (nucleus boundary), $r_2 = 0.0035\\,\\mathrm{m}$ (intermediate cortex), and $r_3 = R_0 = 0.005\\,\\mathrm{m}$ (outer surface).\n- Each ring contains $M = 32$ nodes, uniformly distributed by angle $\\theta_k = 2\\pi k/M$ for $k \\in \\{0, 1, ..., M-1\\}$.\n\nThis results in a total of $N_{\\text{nodes}} = 1 + 3M = 97$ nodes. Each node has two translational degrees of freedom (DOFs), $(d_x, d_y)$, resulting in a total of $N_{\\text{DOF}} = 2 N_{\\text{nodes}} = 194$ system DOFs.\n\nThe nodes are connected by linear axial springs to form the elastic network:\n- **Radial springs:** Connect each node to its neighbors in adjacent inner and outer rings at the same angular position. The nodes of the innermost ring ($r=r_n$) are connected radially to the central node.\n- **Circumferential springs:** Connect adjacent nodes within the same ring.\n\n**2. Constitutive Relations and Stiffness Matrix Assembly**\n\nThe mechanical behavior of the network is governed by linear elasticity in the small-strain regime. The force $\\mathbf{F}_{ij}$ exerted by a spring connecting nodes $i$ and $j$ is given by a linearized form of Hooke's law. The force vector on node $j$ due to this spring is $\\mathbf{f}_j = k_{ij}\\, \\mathbf{u}_{ij} \\mathbf{u}_{ij}^{\\top} (\\mathbf{d}_j - \\mathbf{d}_i)$, where $k_{ij}$ is the spring stiffness, $\\mathbf{d}_i$ and $\\mathbf{d}_j$ are the displacement vectors of nodes $i$ and $j$, and $\\mathbf{u}_{ij}$ is the unit vector along the spring's initial orientation.\n\nThe static equilibrium of the entire network is expressed by the matrix equation:\n$$ \\mathbf{K}\\mathbf{d} = \\mathbf{f} $$\nwhere $\\mathbf{d}$ is the global vector of all nodal displacements, $\\mathbf{f}$ is the global vector of externally applied nodal forces, and $\\mathbf{K}$ is the $194 \\times 194$ global stiffness matrix.\n\nThe matrix $\\mathbf{K}$ is assembled by summing the contributions of all individual springs. For a spring between nodes $p$ and $q$, its contribution to the global stiffness matrix involves adding and subtracting its $2 \\times 2$ local stiffness matrix $\\mathbf{k}_{\\text{spring}} = k_{pq} \\mathbf{u}_{pq} \\mathbf{u}_{pq}^\\top$ to the appropriate $2 \\times 2$ blocks of $\\mathbf{K}$ corresponding to the DOFs of nodes $p$ and $q$.\n\nSpring stiffness values are determined by their location:\n- **Cortex:** Springs entirely within the cortical region ($r > r_n = 0.002\\,\\mathrm{m}$) have base stiffnesses $k_{\\text{rad,cortex}} = 50\\,\\mathrm{N}/\\mathrm{m}$ and $k_{\\text{circ,cortex}} = 25\\,\\mathrm{N}/\\mathrm{m}$.\n- **Nucleus:** Springs entirely within the nucleus ($r \\le r_n$) have their stiffnesses scaled by the factor $\\phi$: $k_{\\text{rad,nucleus}} = \\phi\\,k_{\\text{rad,cortex}}$ and $k_{\\text{circ,nucleus}} = \\phi\\,k_{\\text{circ,cortex}}$.\n- **Boundary:** Radial springs connecting the nucleus ring ($r_1=r_n$) to the first cortical ring ($r_2=0.0035\\,\\mathrm{m}$) have a stiffness equal to the arithmetic mean of the two regions: $k_{\\text{boundary}} = \\frac{1}{2}(k_{\\text{rad,nucleus}} + k_{\\text{rad,cortex}}) = \\frac{\\phi+1}{2}k_{\\text{rad,cortex}}$.\n\n**3. Loads and Constraints**\n\n- **Zonular Load:** The external load from the zonular fibers is modeled as a set of forces applied to nodes on the outer boundary ($r=R_0$). A constant radial force of magnitude $F_z = 0.002\\,\\mathrm{N}$ is applied to each outer node whose angular position $\\theta$ satisfies $|\\theta| \\le \\theta_{\\text{eq}}$ or $|\\theta - \\pi| \\le \\theta_{\\text{eq}}$, where $\\theta_{\\text{eq}} = \\pi/9\\,\\text{radians}$. These forces are assembled into the global force vector $\\mathbf{f}$.\n- **Essential Boundary Conditions:** To prevent rigid-body motion and ensure a unique solution, the central node (at $r=0$) is fixed. This is implemented by setting its displacement components, $d_x$ and $d_y$, to zero. Computationally, this is handled by removing the corresponding rows and columns from the global system $\\mathbf{K}\\mathbf{d} = \\mathbf{f}$ before solving.\n\n**4. Solution and Curvature Estimation**\n\nFor each value of the stiffening parameter $\\phi$ in the test suite, the following procedure is executed:\n1. The global stiffness matrix $\\mathbf{K}$ and force vector $\\mathbf{f}$ are assembled.\n2. The reduced linear system is solved for the unknown nodal displacements $\\mathbf{d}$.\n3. The initial coordinates of all nodes are updated with the computed displacements to obtain the deformed configuration of the network.\n4. The deformed nodes of the outer boundary are segregated into an anterior set ($y>0$) and a posterior set ($y<0$).\n5. For each set of points $(x_i, y_i)$, an algebraic least-squares method is used to fit a circle of the form $x^2 + y^2 + Ax + By + C = 0$. This is equivalent to solving the linear system $\\mathbf{M}\\mathbf{p} = \\mathbf{b}$ for the parameter vector $\\mathbf{p} = [A, B, C]^\\top$, where each row of $\\mathbf{M}$ is $[x_i, y_i, 1]$ and the corresponding entry in $\\mathbf{b}$ is $-(x_i^2 + y_i^2)$.\n6. The radius of the fitted circle is calculated as $R = \\sqrt{(A^2+B^2)/4 - C}$. This gives the anterior radius $R_a$ and posterior radius $R_p$.\n7. The final output quantities are the changes in these radii from the initial, undeformed radius $R_0$:\n   $$ \\Delta R_a = R_a - R_0 $$\n   $$ \\Delta R_p = R_p - R_0 $$\n\nThis process is repeated for all specified values of $\\phi$, and the results are aggregated into the required output format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a finite element model to study lens accommodation.\n    \"\"\"\n\n    # 1. Define constants and model parameters\n    R0 = 0.005  # m, outer radius\n    R_MID = 0.0035 # m, middle ring radius\n    RN = 0.002  # m, nucleus radius\n    M = 32  # angular nodes per ring\n    K_RAD_CORTEX = 50.0  # N/m\n    K_CIRC_CORTEX = 25.0  # N/m\n    FZ = 0.002  # N, force magnitude per node\n    THETA_EQ = np.pi / 9.0  # radians, equatorial load zone angle\n\n    # Test suite for nucleus stiffening factor\n    test_cases = [1.0, 3.0, 10.0, 0.5, 100.0]\n\n    # Helper function for circle fitting\n    def fit_circle_radius(points):\n        \"\"\"\n        Fits a circle to a set of points using algebraic least-squares.\n        The equation is x^2 + y^2 + Ax + By + C = 0.\n        This is solved as a linear system M * p = b where p = [A, B, C]^T.\n        \"\"\"\n        x = points[:, 0]\n        y = points[:, 1]\n        \n        M_matrix = np.vstack([x, y, np.ones(len(x))]).T\n        b_vector = -(x**2 + y**2)\n        \n        p, _, _, _ = np.linalg.lstsq(M_matrix, b_vector, rcond=None)\n        A, B, C = p\n        \n        # Radius R = sqrt((A^2 + B^2)/4 - C)\n        radius = np.sqrt((A**2 + B**2) / 4.0 - C)\n        return radius\n\n    # 2. Generate initial node coordinates\n    N_RINGS = 3\n    N_NODES = 1 + N_RINGS * M\n    N_DOF = 2 * N_NODES\n    initial_coords = np.zeros((N_NODES, 2))\n    \n    # Rings radii and node indices\n    radii = [RN, R_MID, R0]\n    ring_start_indices = [1, 1 + M, 1 + 2 * M]\n    \n    for i in range(N_RINGS):\n        radius = radii[i]\n        start_idx = ring_start_indices[i]\n        for k in range(M):\n            angle = 2.0 * np.pi * k / M\n            initial_coords[start_idx + k] = [radius * np.cos(angle), radius * np.sin(angle)]\n\n    results = []\n    \n    for phi in test_cases:\n        # 3. Assemble Stiffness Matrix K\n        K = np.zeros((N_DOF, N_DOF))\n        \n        # Define stiffness values for current phi\n        k_rad_nuc = phi * K_RAD_CORTEX\n        k_circ_nuc = phi * K_CIRC_CORTEX\n        k_boundary = 0.5 * (k_rad_nuc + K_RAD_CORTEX)\n        \n        def add_spring_to_K(p_idx, q_idx, k_spring):\n            pos_p = initial_coords[p_idx]\n            pos_q = initial_coords[q_idx]\n            vec = pos_q - pos_p\n            length = np.linalg.norm(vec)\n            if length == 0: return\n            u = vec / length\n            \n            k_mat = k_spring * np.outer(u, u)\n            \n            dof_p = slice(2 * p_idx, 2 * p_idx + 2)\n            dof_q = slice(2 * q_idx, 2 * q_idx + 2)\n            \n            K[dof_p, dof_p] += k_mat\n            K[dof_q, dof_q] += k_mat\n            K[dof_p, dof_q] -= k_mat\n            K[dof_q, dof_p] -= k_mat\n\n        # Radial springs\n        for k in range(M):\n            # Center to Nucleus Ring (Ring 1)\n            add_spring_to_K(0, 1 + k, k_rad_nuc)\n            # Nucleus Ring (1) to Cortex Ring (2)\n            add_spring_to_K(1 + k, 1 + M + k, k_boundary)\n            # Cortex Ring (2) to Outer Ring (3)\n            add_spring_to_K(1 + M + k, 1 + 2 * M + k, K_RAD_CORTEX)\n\n        # Circumferential springs\n        k_circ_values = [k_circ_nuc, K_CIRC_CORTEX, K_CIRC_CORTEX]\n        for i in range(N_RINGS):\n            start_idx = ring_start_indices[i]\n            k_circ = k_circ_values[i]\n            for k in range(M):\n                p_idx = start_idx + k\n                q_idx = start_idx + (k + 1) % M\n                add_spring_to_K(p_idx, q_idx, k_circ)\n\n        # 4. Assemble Force Vector f\n        f = np.zeros(N_DOF)\n        outer_ring_start_idx = 1 + 2 * M\n        for k in range(M):\n            angle = 2.0 * np.pi * k / M\n            \n            # Normalize angle to [-pi, pi] for easier checking\n            angle_norm = (angle + np.pi) % (2 * np.pi) - np.pi\n            \n            is_loaded = abs(angle_norm) <= THETA_EQ or abs(abs(angle_norm) - np.pi) <= THETA_EQ\n            \n            if is_loaded:\n                node_idx = outer_ring_start_idx + k\n                force_vec = np.array([np.cos(angle), np.sin(angle)]) * FZ\n                f[2 * node_idx : 2 * node_idx + 2] = force_vec\n\n        # 5. Apply Constraints and Solve\n        # Central node (index 0) is fixed.\n        constrained_dof = [0, 1]\n        active_dof = np.setdiff1d(np.arange(N_DOF), constrained_dof)\n        \n        K_reduced = K[np.ix_(active_dof, active_dof)]\n        f_reduced = f[active_dof]\n        \n        d_reduced = np.linalg.solve(K_reduced, f_reduced)\n        \n        d_full = np.zeros(N_DOF)\n        d_full[active_dof] = d_reduced\n        \n        # 6. Post-processing: Compute deformed curvature\n        displacements = d_full.reshape((N_NODES, 2))\n        deformed_coords = initial_coords + displacements\n        \n        outer_nodes_deformed = deformed_coords[outer_ring_start_idx:]\n        \n        # Split into anterior (y > 0) and posterior (y < 0)\n        # Exclude equatorial nodes (y=0) from the fit\n        y_coords = outer_nodes_deformed[:, 1]\n        anterior_points = outer_nodes_deformed[y_coords > 1e-9]\n        posterior_points = outer_nodes_deformed[y_coords < -1e-9]\n        \n        R_a = fit_circle_radius(anterior_points)\n        R_p = fit_circle_radius(posterior_points)\n        \n        delta_Ra = R_a - R0\n        delta_Rp = R_p - R0\n        \n        results.append([delta_Ra, delta_Rp])\n        \n    # 7. Format and print the final output\n    output_str = '[' + ','.join([f'[{r[0]},{r[1]}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```"
        }
    ]
}