{
    "hands_on_practices": [
        {
            "introduction": "角膜上皮的组织学特征，特别是其最表层细胞之间的紧密连接，是其发挥屏障功能的结构基础。我们可以通过物理学原理将这种微观结构与可测量的宏观功能联系起来。本练习旨在通过应用电路理论，将上皮层建模为并联电阻通路，从而量化其屏障功能，具体体现为跨上皮电阻（Transepithelial Electrical Resistance, TEER）的计算。这项实践有助于将细胞连接的形态学知识转化为对其生理功能的定量理解。",
            "id": "4680209",
            "problem": "角膜上皮层由基底层、翼状层和表层细胞层组成，通过表层细胞中的顶端紧密连接（闭锁小带, ZO）形成一道屏障，限制了细胞旁离子的运动。总的跨上皮电阻（TEER）来自两个并行的通路：一个是由紧密连接主导的细胞旁通路，另一个是穿过细胞膜和细胞质的跨细胞通路。在面积归一化的测量中，细胞旁通路的电阻为 $R_p$，跨细胞通路的电阻为 $R_t$。考虑在施加一个小的跨上皮电位差下的稳态条件，此时电流-电压呈线性关系，且上皮层表现为一个无源、时不变系统。\n\n从欧姆定律和跨并行通路的电流守恒定律出发，推导上皮层的等效跨上皮电阻 $R_T$ 的表达式，不要使用任何现成的网络公式。然后计算当 $R_p = 2000\\,\\Omega\\cdot\\text{cm}^{2}$ 且 $R_t = 10000\\,\\Omega\\cdot\\text{cm}^{2}$ 时的 $R_T$ 值。你的最终答案需要用 $\\Omega\\cdot\\text{cm}^{2}$ 作为单位，并四舍五入到四位有效数字。",
            "solution": "该问题是有效的，因为它具有科学依据、问题明确且客观。它提供了一个标准的上皮层生物物理模型，并要求从第一性原理出发进行推导，然后进行计算。所有必要的数据均已提供，其背景与细胞生理学和生物物理学中的既定原则一致。\n\n我们的任务是推导角膜上皮的总跨上皮电阻 $R_T$ 的表达式。该上皮被建模为两个并行的电气通路：一个电阻为 $R_p$ 的细胞旁通路和一个电阻为 $R_t$ 的跨细胞通路。“并行通路”一词意味着它们是并联的。这意味着施加在整个上皮层上的跨上皮电位差（我们称之为 $\\Delta V$）与施加在每个独立通路上的电位差是相同的。\n\n推导必须从基本原理开始：欧姆定律和电流守恒定律。\n\n设 $I_p$ 为流过细胞旁通路的电流，$I_t$ 为流过跨细胞通路的电流。根据欧姆定律，流过每个通路的电流等于其两端的电位差除以其电阻。由于两个通路的电位差 $\\Delta V$ 相同，我们可以写出：\n$$\nI_p = \\frac{\\Delta V}{R_p}\n$$\n和\n$$\nI_t = \\frac{\\Delta V}{R_t}\n$$\n问题设定在电流守恒的稳态条件下。这是 Kirchhoff 电流定律在总电流分流到两个通路上的节点的应用。流过上皮层的总电流 $I_T$ 必须是流过各个并行通路的电流之和：\n$$\nI_T = I_p + I_t\n$$\n现在，我们将欧姆定律中 $I_p$ 和 $I_t$ 的表达式代入电流守恒方程：\n$$\nI_T = \\frac{\\Delta V}{R_p} + \\frac{\\Delta V}{R_t}\n$$\n我们可以提出公因式 $\\Delta V$：\n$$\nI_T = \\Delta V \\left( \\frac{1}{R_p} + \\frac{1}{R_t} \\right)\n$$\n等效或总跨上皮电阻 $R_T$ 是通过对整个系统应用欧姆定律来定义的。它将总电流 $I_T$ 与总电位差 $\\Delta V$ 联系起来：\n$$\n\\Delta V = I_T R_T\n$$\n这可以重新整理以表达 $I_T$：\n$$\nI_T = \\frac{\\Delta V}{R_T}\n$$\n我们现在有两个关于总电流 $I_T$ 的表达式。令它们相等可得：\n$$\n\\frac{\\Delta V}{R_T} = \\Delta V \\left( \\frac{1}{R_p} + \\frac{1}{R_t} \\right)\n$$\n由于施加了一个小的电位差，$\\Delta V$ 不为零，我们可以将方程两边同时除以 $\\Delta V$：\n$$\n\\frac{1}{R_T} = \\frac{1}{R_p} + \\frac{1}{R_t}\n$$\n这个方程表明，总电阻的倒数等于各个并联电阻倒数之和。为了解出 $R_T$，我们首先对右边进行通分：\n$$\n\\frac{1}{R_T} = \\frac{R_t}{R_p R_t} + \\frac{R_p}{R_p R_t} = \\frac{R_p + R_t}{R_p R_t}\n$$\n最后，将两边取倒数，得到等效跨上皮电阻 $R_T$ 的所需表达式：\n$$\nR_T = \\frac{R_p R_t}{R_p + R_t}\n$$\n这样就完成了从第一性原理出发的推导。\n\n问题的第二部分是根据给定的值 $R_p = 2000\\,\\Omega\\cdot\\text{cm}^{2}$ 和 $R_t = 10000\\,\\Omega\\cdot\\text{cm}^{2}$ 计算 $R_T$ 的数值。我们将这些值代入推导出的公式中。注意单位是 $\\Omega\\cdot\\text{cm}^{2}$，这是面积归一化的电阻单位，在整个计算过程中将保持不变。\n$$\nR_T = \\frac{(2000)(10000)}{2000 + 10000}\n$$\n分子是：\n$$\n2000 \\times 10000 = 2 \\times 10^3 \\times 1 \\times 10^4 = 2 \\times 10^7\n$$\n分母是：\n$$\n2000 + 10000 = 12000 = 1.2 \\times 10^4\n$$\n所以，$R_T$ 是：\n$$\nR_T = \\frac{2 \\times 10^7}{1.2 \\times 10^4} = \\frac{20000000}{12000} = \\frac{20000}{12}\n$$\n简化分数：\n$$\nR_T = \\frac{5000}{3}\n$$\n换算成小数，结果是 $1666.666... \\,\\Omega\\cdot\\text{cm}^{2}$。问题要求最终答案四舍五入到四位有效数字。前四位数字是 $1$、$6$、$6$、$6$。第五位数字是 $6$，大于或等于 $5$，所以我们将第四位数字向上取整。\n$$\nR_T \\approx 1667\\,\\Omega\\cdot\\text{cm}^{2}\n$$\n计算得出的总跨上皮电阻值为 $1667\\,\\Omega\\cdot\\text{cm}^{2}$。正如预期的那样，并联电阻的等效电阻小于最小的单个电阻（$1667  2000$）。",
            "answer": "$$\\boxed{1667}$$"
        },
        {
            "introduction": "从静态特性转向动态过程，我们来研究角膜内皮细胞随年龄变化的规律。内皮细胞层对维持角膜透明至关重要，但其在出生后几乎不进行有丝分裂，因此细胞数量会随着时间逐渐减少。本练习将一个关键的组织学观察——即年龄相关的细胞损耗——转化为一个确定性的一阶动力学模型。通过求解这个模型，你将能够预测在给定的损耗率下，细胞密度如何随时间演变，这是将生物过程数学化的一个经典范例。",
            "id": "4680273",
            "problem": "在角膜内皮中，一层单层六角形细胞维持角膜的去肿胀状态，并且在早期发育后，其在体内的有丝分裂可以忽略不计。根据经验，角膜内皮细胞与年龄相关的损耗可以很好地用一个一阶（单位细胞）损失过程来近似，这意味着任何时刻的瞬时损失率与当前的细胞密度成正比。对于一个符合生理实际的眼睛，假设以下条件：\n- 在生理年龄$20$岁时，角膜内皮细胞密度为 $3000\\,\\text{cells}/\\text{mm}^{2}$。\n- 从$20$岁起，该过程遵循每年$0.6\\%$的恒定单位细胞损失率，这被解释为一个单位为 $\\text{year}^{-1}$ 的连续速率 $k$。\n- 我们感兴趣的年龄是$70$岁。\n\n从群体密度 $N(t)$ 的一阶动力学损失过程的定义出发，其中 $t$ 是自$20$岁以来经过的时间（以年为单位），推导其控制方程，并求解$70$岁时的角膜内皮细胞密度。在$20$岁时取 $t=0$，并设连续单位细胞损失率为 $k=0.006\\,\\text{year}^{-1}$。将您的结果四舍五入到四位有效数字。以 $\\text{cells}/\\text{mm}^{2}$ 为单位表示最终密度。",
            "solution": "首先对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n- 过程为一阶（单位细胞）损失。\n- 生理年龄$20$岁时的角膜内皮细胞密度为 $3000\\,\\text{cells}/\\text{mm}^{2}$。\n- 从$20$岁起的连续单位细胞损失率为每年$k = 0.6\\%$，即 $k=0.006\\,\\text{year}^{-1}$。\n- 时间 $t$ 是从$20$岁开始经过的年数，因此 $t=0$ 对应$20$岁。\n- 我们感兴趣的年龄是$70$岁。\n- 最终结果应四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题使用一阶动力学模型来模拟角膜内皮中与年龄相关的细胞损失。这在细胞生物学和眼科学中是一种常见且生理上合理的近似。所提供的初始细胞密度（$3000\\,\\text{cells}/\\text{mm}^{2}$）和年损失率（$0.6\\%$）均在健康人角膜的既定临床数据范围内。该问题在科学上是合理的。\n- **适定性**：该问题定义了一个初始条件、一个控制微分方程（由“一阶损失过程”所隐含），并要求在特定未来时间点的解。这构成了一个适定的初值问题，该问题存在唯一且稳定的解。\n- **客观性**：该问题使用精确、定量且无偏见的语言陈述。所有术语都得到了明确定义。\n\n### 步骤3：结论与行动\n该问题具有科学依据、适定性和客观性，因此是有效的。下面将推导解答。\n\n该问题描述了角膜内皮细胞密度的一阶损失过程，记为 $N(t)$，其中 $t$ 代表从$20$岁开始经过的时间（以年为单位）。一阶损失过程的定义是，数量的变化率与数量本身成正比。在数学上，这表示为一个一阶常微分方程：\n$$\n\\frac{dN(t)}{dt} = -k N(t)\n$$\n其中 $k$ 是恒定的单位细胞损失率。负号表示群体数量在减少。\n\n给定的初始条件是$20$岁时的细胞密度，对应于 $t=0$。设这个初始密度为 $N_0$。\n$$\nN(0) = N_0 = 3000\\,\\text{cells}/\\text{mm}^{2}\n$$\n恒定的单位细胞损失率给定为 $k = 0.006\\,\\text{year}^{-1}$。\n\n为了求出任意时刻 $t$ 的细胞密度，我们必须解这个微分方程。这是一个可分离变量的方程：\n$$\n\\frac{1}{N(t)} dN(t) = -k dt\n$$\n我们对等式两边从初始状态（$t=0, N=N_0$）积分到一般状态（$t, N(t)$）：\n$$\n\\int_{N_0}^{N(t)} \\frac{1}{N'} dN' = \\int_0^t -k dt'\n$$\n积分得到：\n$$\n[\\ln|N'|]_{N_0}^{N(t)} = [-kt']_0^t\n$$\n由于细胞密度 $N(t)$ 必须为正，绝对值是多余的。\n$$\n\\ln(N(t)) - \\ln(N_0) = -kt\n$$\n利用对数的性质，这可以写成：\n$$\n\\ln\\left(\\frac{N(t)}{N_0}\\right) = -kt\n$$\n为了解出 $N(t)$，我们对等式两边取指数：\n$$\n\\frac{N(t)}{N_0} = \\exp(-kt)\n$$\n这就给出了细胞密度作为时间函数的显式解：\n$$\nN(t) = N_0 \\exp(-kt)\n$$\n这个方程描述了细胞总数的指数衰减。\n\n我们需要求解$70$岁时的细胞密度。由于 $t=0$ 对应$20$岁，到达$70$岁所经过的时间为：\n$$\nt = 70\\,\\text{years} - 20\\,\\text{years} = 50\\,\\text{years}\n$$\n现在，我们将已知值代入解的方程中：\n- 初始密度 $N_0 = 3000$\n- 经过时间 $t = 50$\n- 损失率常数 $k = 0.006$\n\n$$\nN(50) = 3000 \\times \\exp(-0.006 \\times 50)\n$$\n首先，我们计算指数部分：\n$$\n-k \\times t = -0.006 \\times 50 = -0.3\n$$\n所以，方程变为：\n$$\nN(50) = 3000 \\times \\exp(-0.3)\n$$\n现在，我们计算数值：\n$$\n\\exp(-0.3) \\approx 0.74081822068\n$$\n$$\nN(50) \\approx 3000 \\times 0.74081822068 \\approx 2222.45466204\n$$\n问题要求结果四舍五入到四位有效数字。前四位数字是$2$、$2$、$2$和$2$。第五位数字是$4$，小于$5$，所以我们向下舍入（即，不改变第四位数字）。\n$$\nN(70\\,\\text{years old}) = N(t=50) \\approx 2222\\,\\text{cells}/\\text{mm}^{2}\n$$",
            "answer": "$$\\boxed{2222}$$"
        },
        {
            "introduction": "生物过程本质上常常是随机的，而非确定性的。本练习将模型复杂度从确定性模型提升至随机模型，以探索角膜缘干细胞的克隆动态。角膜缘是角膜上皮更新的干细胞“微环境”，其中单个干细胞的分裂和分化决策是概率性事件。这项高阶练习要求你将这些单细胞层面的概率行为，构建为一个连续时间的生灭过程模型，并计算克隆大小的概率分布。通过编程实现，你将亲身体验微观随机性如何塑造宏观的细胞群体行为。",
            "id": "4680295",
            "problem": "您将使用一个基于组织学原理的连续时间分支框架，对眼表的一个特化干细胞微环境——角巩膜缘中的角膜缘上皮干细胞的克隆动态进行建模。根本上，角膜缘上皮基底层中的角膜缘干细胞会进行分裂，分裂的结果要么是自我更新，要么是产生注定要用于角膜上皮更新的分化后代细胞。具有组织学意义的假设是：每个干细胞以恒定速率进行分裂，分裂是无记忆的，并且分化会将细胞从干细胞室中移除。\n\n初始假设与定义（基本基础）：\n- 一个标记的角膜缘干细胞在时间 $t = 0$ 时启动一个克隆。\n- 每个干细胞以每天 $r$ 次分裂的速率进行分裂，分裂间隔时间呈指数分布，且细胞间的行为相互独立，这与连续时间马尔可夫过程一致。\n- 每次分裂时，会发生以下三种结果之一：\n  1. 对称性自我更新，概率为 $p_{\\mathrm{sym\\_self}}$，产生 $2$ 个干细胞。\n  2. 不对称分裂，概率为 $p_{\\mathrm{asym}}$，产生 $1$ 个干细胞和 $1$ 个分化祖细胞（瞬时扩增细胞）；此结果不改变干细胞数量。\n  3. 对称性分化，概率为 $p_{\\mathrm{sym\\_diff}}$，产生 $0$ 个干细胞和 $2$ 个分化祖细胞，有效地减少了干细胞数量。\n- 概率满足 $p_{\\mathrm{sym\\_self}} + p_{\\mathrm{asym}} + p_{\\mathrm{sym\\_diff}} = 1$。\n- 就本问题而言，克隆大小定义为时间 $t$ 时克隆中的干细胞数量，不包括分化后代。这反映了在角膜缘微环境的组织学和谱系追踪分析中可检测到的干细胞室。\n\n在这些假设下，干细胞数量 $N(t)$ 是一个连续时间生灭过程，其单位细胞出生率为 $\\lambda = r \\, p_{\\mathrm{sym\\_self}}$，单位细胞死亡率为 $\\mu = r \\, p_{\\mathrm{sym\\_diff}}$，因为不对称分裂不改变干细胞数量。这产生了一个从 $N(0) = 1$ 开始的线性生灭过程。\n\n任务：\n- 推导并实现时间范围 $T = 180$ 天（即 $6$ 个月）时，对于 $n \\in \\{0,1,2,\\dots,K\\}$ 的预期克隆大小分布 $P(N(T) = n)$，并报告累积尾部概率 $P(N(T)  K)$。所有概率必须以十进制浮点数形式报告。\n- 使用 $K = 50$ 作为分布的有限报告截止值。\n- 所有参数值在科学上都是合理的，并且必须严格按照规定处理。除了有限截止值 $K$ 外，模型实现不得包含其他近似。\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个用方括号括起来的逗号分隔的浮点数列表，表示 $\\left[P(N(T) = 0), P(N(T) = 1), \\dots, P(N(T) = K), P(N(T)  K)\\right]$。将每个浮点数四舍五入到 $6$ 位小数。\n\n数学和逻辑要求：\n- 从由分裂率 $r$ 和分裂结果概率推导出的单位细胞速率为 $\\lambda$ 和 $\\mu$ 的连续时间分支过程开始。\n- 对于 $\\lambda \\neq \\mu$ 的情况，使用从 $N(0) = 1$ 开始的线性生灭过程的闭式瞬态分布。\n- 对于 $\\lambda = \\mu$（临界情况），使用时间 $t = T$ 时瞬态分布的适当极限形式。\n- 确保单位使用准确：$r$ 的单位是 $\\text{day}^{-1}$，$T$ 的单位是天。\n\n测试套件：\n- 所有情况均使用 $r = 0.05 \\,\\text{day}^{-1}$ 和 $T = 180 \\,\\text{days}$。提供以下四个参数集以测试不同的生物学机制：\n  1. 出生主导机制：$p_{\\mathrm{sym\\_self}} = 0.6$, $p_{\\mathrm{asym}} = 0.2$, $p_{\\mathrm{sym\\_diff}} = 0.2$。\n  2. 死亡主导机制：$p_{\\mathrm{sym\\_self}} = 0.1$, $p_{\\mathrm{asym}} = 0.3$, $p_{\\mathrm{sym\\_diff}} = 0.6$。\n  3. 临界平衡机制：$p_{\\mathrm{sym\\_self}} = 0.4$, $p_{\\mathrm{asym}} = 0.2$, $p_{\\mathrm{sym\\_diff}} = 0.4$。\n  4. 纯不对称机制 (边界情况)：$p_{\\mathrm{sym\\_self}} = 0.0$, $p_{\\mathrm{asym}} = 1.0$, $p_{\\mathrm{sym\\_diff}} = 0.0$。\n\n答案格式：\n- 您的程序必须按照上述格式计算并打印单行结果，即一个包含四个内部方括号向量（每个测试用例一个）的外部方括号列表，其中每个内部向量有 $K+2 = 52$ 个条目，对应于 $n = 0,1,\\dots,50$ 的概率和累积尾部 $n  50$ 的概率。",
            "solution": "该问题要求将角膜缘上皮干细胞的克隆动态建模为一个连续时间生灭过程。我们必须验证问题陈述，如果有效，则推导并实现指定时间干细胞克隆大小的概率分布解决方案。\n\n## 问题验证\n\n### 第 1 步：提取已知条件\n- 初始条件：时间 $t=0$ 时有单个干细胞，因此 $N(0) = 1$。\n- 过程类型：连续时间马尔可夫过程（生灭过程）。\n- 分裂率：每个细胞以恒定速率 $r$ 分裂。\n- 分裂结果及概率：\n  1. 对称性自我更新（$2$ 个干细胞）：$p_{\\mathrm{sym\\_self}}$\n  2. 不对称分裂（$1$ 个干细胞）：$p_{\\mathrm{asym}}$\n  3. 对称性分化（$0$ 个干细胞）：$p_{\\mathrm{sym\\_diff}}$\n- 约束条件：$p_{\\mathrm{sym\\_self}} + p_{\\mathrm{asym}} + p_{\\mathrm{sym\\_diff}} = 1$。\n- 单位细胞出生率：$\\lambda = r \\cdot p_{\\mathrm{sym\\_self}}$（干细胞数量增加的速率）。\n- 单位细胞死亡率：$\\mu = r \\cdot p_{\\mathrm{sym\\_diff}}$（干细胞数量减少的速率）。\n- 任务：计算 $n \\in \\{0, 1, \\dots, K\\}$ 的概率分布 $P(N(T) = n)$ 和尾部概率 $P(N(T)  K)$。\n- 常量：\n  - 时间范围：$T = 180$ 天。\n  - 分布截止值：$K = 50$。\n  - 分裂率：$r = 0.05 \\, \\text{day}^{-1}$。\n- $(p_{\\mathrm{sym\\_self}}, p_{\\mathrm{asym}}, p_{\\mathrm{sym\\_diff}})$ 的测试用例：\n  1. $(0.6, 0.2, 0.2)$\n  2. $(0.1, 0.3, 0.6)$\n  3. $(0.4, 0.2, 0.4)$\n  4. $(0.0, 1.0, 0.0)$\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据：** 该模型是一个线性生灭过程，是定量生物学中用于建模种群动态（包括干细胞种群）的标准和基本工具。其假设（马尔可夫动态、恒定速率）是常见的，并构成了该领域的基础模型。生物学背景得到了正确表述。\n- **适定性：** 该问题提供了明确的初始条件（$N(0)=1$），并要求计算一个已知随机过程在未来时间 $T$ 的瞬态概率分布。参数被完全指定。问题明确要求处理一般情况（$\\lambda \\neq \\mu$）和临界情况（$\\lambda = \\mu$），确保所有提供的测试用例都存在唯一解。\n- **客观性：** 问题以精确、定量的术语陈述，所有参数和变量都得到了清晰的定义。没有主观或模糊的语言。\n\n### 第 3 步：结论与行动\n该问题具有科学依据、适定性、客观性且自成体系。所有提供的参数集都与约束条件 $p_{\\mathrm{sym\\_self}} + p_{\\mathrm{asym}} + p_{\\mathrm{sym\\_diff}} = 1$ 一致。因此，该问题是**有效**的。我将继续推导并实现解决方案。\n\n## 数学推导与求解设计\n\n克隆中的干细胞数量 $N(t)$ 遵循一个线性生灭过程，每个细胞的出生率为 $\\lambda$，死亡率为 $\\mu$，初始种群为 $N(0)=1$。我们需要找到对于 $n \\ge 0$ 的概率质量函数 $p_n(t) = P(N(t)=n | N(0)=1)$。解法根据 $\\lambda = \\mu$ 是否成立而有所不同。\n\n### 情况 1：非临界过程（$\\lambda \\neq \\mu$）\n对于一个 $N(0)=1$ 且 $\\lambda \\neq \\mu$ 的线性生灭过程，瞬态概率由一个修正的几何分布给出。克隆在时间 $t$ 前灭绝的概率 $p_0(t)$ 为：\n$$p_0(t) = \\frac{\\mu(e^{(\\lambda-\\mu)t} - 1)}{\\lambda e^{(\\lambda-\\mu)t} - \\mu}$$\n对于种群大小 $n \\ge 1$，概率由下式给出：\n$$p_n(t) = \\frac{(\\lambda-\\mu)^2 e^{(\\lambda-\\mu)t}}{(\\lambda e^{(\\lambda-\\mu)t}-\\mu)^2} \\left( \\frac{\\lambda(e^{(\\lambda-\\mu)t} - 1)}{\\lambda e^{(\\lambda-\\mu)t} - \\mu} \\right)^{n-1}$$\n这可以更紧凑地表示。让我们定义一个公比项 $\\xi(t)$：\n$$\\xi(t) = \\frac{\\lambda(e^{(\\lambda-\\mu)t} - 1)}{\\lambda e^{(\\lambda-\\mu)t} - \\mu}$$\n那么，对于 $n \\ge 1$，概率形成一个几何级数：\n$$p_n(t) = p_1(t) \\cdot [\\xi(t)]^{n-1}$$\n其中 $p_1(t)$ 由下式给出：\n$$p_1(t) = \\frac{(\\lambda-\\mu)^2 e^{(\\lambda-\\mu)t}}{(\\lambda e^{(\\lambda-\\mu)t}-\\mu)^2}$$\n这些公式对于所有 $\\lambda \\neq \\mu$ 和 $t  0$ 的情况都是数值稳定的且定义良好。它们也能正确处理纯出生（$\\mu=0$）和纯死亡（$\\lambda=0$）过程作为特殊情况。\n\n### 情况 2：临界过程（$\\lambda = \\mu$）\n当出生率和死亡率相等时，该过程是临界的。其概率可通过在上述表达式中取极限 $\\lambda \\to \\mu$ 得到。令 $\\lambda = \\mu$。在时间 $t$ 前灭绝的概率为：\n$$p_0(t) = \\frac{\\mu t}{1 + \\mu t}$$\n对于 $n \\ge 1$，概率由下式给出：\n$$p_n(t) = \\frac{1}{(1+\\mu t)^2} \\left( \\frac{\\mu t}{1+\\mu t} \\right)^{n-1}$$\n与非临界情况类似，我们可以定义一个比率项 $\\xi(t)$：\n$$\\xi(t) = \\frac{\\mu t}{1 + \\mu t}$$\n并且对于 $n \\ge 1$ 的概率是：\n$$p_n(t) = p_1(t) \\cdot [\\xi(t)]^{n-1}$$\n其中 $p_1(t)$ 是：\n$$p_1(t) = \\frac{1}{(1+\\mu t)^2}$$\n一个特殊的子情况是 $\\lambda = \\mu = 0$，这对应于纯不对称分裂的情景。在这种情况下，干细胞的数量永远不会改变。由于 $N(0)=1$，我们必须有 $N(t)=1$ 对所有 $t  0$ 成立。因此，$p_1(t)=1$ 且对于所有 $n \\neq 1$ 都有 $p_n(t)=0$。当 $\\mu=0$ 时，临界情况的通用公式能正确地简化为这个结果。\n\n### 实现算法\n对于每个测试用例，算法按以下步骤进行：\n1. 使用给定参数 $r=0.05$、$p_{\\mathrm{sym\\_self}}$ 和 $p_{\\mathrm{sym\\_diff}}$，计算单位细胞出生率 $\\lambda = r \\cdot p_{\\mathrm{sym\\_self}}$ 和死亡率 $\\mu = r \\cdot p_{\\mathrm{sym\\_diff}}$。\n2. 通过检查 $\\lambda$ 和 $\\mu$ 是否在一个小的数值容差内相等，来判断过程是否为临界过程。\n3. 根据情况（$\\lambda = \\mu$ 或 $\\lambda \\neq \\mu$），使用相应的公式集计算在时间范围 $T=180$ 天时，$p_0(T)$ 以及分布的几何部分的参数（$p_1(T)$ 和 $\\xi(T)$）。\n4. 生成 $n = 0, 1, \\dots, K$（其中 $K=50$）的概率分布。具体做法是：首先存储 $p_0(T)$，然后计算 $p_1(T)$，并对 $n = 2, \\dots, K$ 迭代计算 $p_n(T) = p_{n-1}(T) \\cdot \\xi(T)$。\n5. 通过将从 $n=0$ 到 $K$ 计算出的概率求和，然后用 $1$ 减去该和，来计算累积尾部概率 $P(N(T)  K)$。\n$$P(N(T)  K) = 1 - \\sum_{n=0}^{K} P(N(T)=n)$$\n6. 存储得到的包含 $K+2$ 个概率的向量：$[p_0(T), p_1(T), \\dots, p_K(T), P(N(T)K)]$。\n7. 对所有测试用例重复上述步骤，并按规定格式化最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_distribution(r, T, K, p_sym_self, p_sym_diff):\n    \"\"\"\n    Calculates the probability distribution P(N(T)=n) for a linear birth-death process.\n\n    Args:\n        r (float): Division rate per cell per day.\n        T (float): Time horizon in days.\n        K (int): Cutoff for the distribution size.\n        p_sym_self (float): Probability of symmetric self-renewal.\n        p_sym_diff (float): Probability of symmetric differentiation.\n\n    Returns:\n        list: A list of K+2 floats representing [P(N=0), ..., P(N=K), P(N>K)].\n    \"\"\"\n    lambda_rate = r * p_sym_self\n    mu_rate = r * p_sym_diff\n\n    probabilities = []\n\n    # Use a small tolerance for floating point comparison\n    if abs(lambda_rate - mu_rate)  1e-15:\n        # Critical case: lambda = mu\n        if mu_rate == 0:  # Also implies lambda_rate == 0\n            # Purely asymmetric divisions, clone size is constant at 1\n            p0 = 0.0\n            p1 = 1.0\n            xi = 0.0\n        else:\n            C = mu_rate * T\n            p0 = C / (1.0 + C)\n            p1 = 1.0 / (1.0 + C)**2\n            xi = C / (1.0 + C)\n    else:\n        # Non-critical case: lambda != mu\n        delta = lambda_rate - mu_rate\n        exp_term = np.exp(delta * T)\n        denominator = lambda_rate * exp_term - mu_rate\n\n        if denominator == 0:\n            # This case should not be reached for t > 0 and lambda != mu\n            # but handle defensively.\n            # This would imply log(mu/lambda) / (lambda - mu) = T, which is impossible.\n            raise ValueError(\"Denominator is zero in non-critical case calculation.\")\n\n        p0 = mu_rate * (exp_term - 1.0) / denominator\n        p1 = (delta**2 * exp_term) / (denominator**2)\n        xi = lambda_rate * (exp_term - 1.0) / denominator\n\n    probabilities.append(p0)\n    \n    if K >= 1:\n        probabilities.append(p1)\n        current_p = p1\n        for _ in range(2, K + 1):\n            current_p *= xi\n            probabilities.append(current_p)\n\n    # Calculate tail probability\n    sum_p = sum(probabilities)\n    p_tail = 1.0 - sum_p\n    # Ensure tail probability is not negative due to floating point error\n    p_tail = max(0.0, p_tail)\n\n    probabilities.append(p_tail)\n\n    return probabilities\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define constants from the problem statement\n    r = 0.05  # divisions per day\n    T = 180   # days\n    K = 50    # finite reporting cutoff\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of (p_sym_self, p_asym, p_sym_diff).\n    # p_asym is not directly used in the rate calculations but is listed for completeness.\n    test_cases = [\n        (0.6, 0.2, 0.2),  # Birth-dominant regime\n        (0.1, 0.3, 0.6),  # Death-dominant regime\n        (0.4, 0.2, 0.4),  # Critical balanced regime\n        (0.0, 1.0, 0.0),  # Purely asymmetric regime\n    ]\n\n    all_results = []\n    for case in test_cases:\n        p_sym_self, _, p_sym_diff = case\n        \n        prob_dist = calculate_distribution(r, T, K, p_sym_self, p_sym_diff)\n        \n        # Format probabilities to 6 decimal places and create the string for the case\n        formatted_probs = [f\"{p:.6f}\" for p in prob_dist]\n        result_str = f\"[{','.join(formatted_probs)}]\"\n        all_results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[[{','.join(all_results)}]]\")\n\nsolve()\n```"
        }
    ]
}