{
    "hands_on_practices": [
        {
            "introduction": "A crucial first step in analyzing neural oscillations is to convert the raw, digitized output of a recording instrument into physically meaningful units of power. This exercise guides you through the fundamental principles of Power Spectral Density (PSD) estimation, from the effect of windowing functions to the correct scaling for units like $\\mu\\text{V}^2/\\text{Hz}$. Mastering these calculations  is essential for accurately quantifying and comparing oscillatory power across different conditions or experiments.",
            "id": "4138609",
            "problem": "An Electroencephalography (EEG) channel is digitized to integer counts, denoted by $x[n]$, with a sampling frequency $F_s = 512$ Hz. A single $N = 4096$-sample segment ($8$ seconds) is analyzed using a Hann window $w[n]$ applied prior to a Discrete Fourier Transform (DFT), producing a one-sided Power Spectral Density (PSD) estimate. The instrument reports the one-sided PSD of the raw counts as $S_{x,1}(f)$ in units of counts$^{2}$/Hz. In the alpha band from $8$ Hz to $12$ Hz, the reported PSD is approximately flat at the level $S_{x,1}(f) = 1.2 \\times 10^{3}$ counts$^{2}$/Hz.\n\nThe analog front end is calibrated such that each count corresponds to $g = 0.09$ $\\mu$V/count, so the physical EEG signal is $y[n] = g\\,x[n]$ in $\\mu$V. You may assume the instrument’s PSD computation uses a standard energy-conserving periodogram with proper window power normalization and one-sided conversion.\n\nStarting from the fundamental definitions of the DFT, Parseval’s theorem, and the notion that integrating a power spectral density over frequency yields signal power (variance), do the following:\n\n- Derive the unit-consistent scaling that produces a PSD in $\\mu\\text{V}^{2}/\\text{Hz}$ from the windowed DFT of $y[n]$, explicitly identifying the window power factor in your reasoning, and explain how to convert the reported counts$^{2}$/Hz PSD to $\\mu\\text{V}^{2}$/Hz using the calibration $g$.\n- Using the derived unit conversion and the principle that integrating a PSD over a frequency band yields the band power, compute the alpha-band power by integrating $S_{y,1}(f)$ over $f \\in [8, 12]$ Hz.\n\nExpress the final band power in $\\mu\\text{V}^{2}$ and round your answer to four significant figures.",
            "solution": "The problem statement is evaluated to be valid. All provided data and conditions are scientifically grounded, consistent, and sufficient for a unique solution. The problem is well-posed and objective, framed within standard digital signal processing (DSP) practices for analyzing neurophysiological data like EEG.\n\nThe problem requires two main steps: first, to derive the scaling factor for converting a windowed Discrete Fourier Transform (DFT) into a one-sided Power Spectral Density (PSD) in physical units, and explain the conversion from the instrument-reported PSD to the physical PSD; second, to calculate the power in the alpha frequency band.\n\n**Part 1: Derivation of PSD Scaling and Unit Conversion**\n\nLet the discrete-time EEG signal in physical units be $y[n]$, with units of $\\mu$V. The signal is sampled at a frequency $F_s$ and a segment of $N$ samples is analyzed. The analysis involves applying a window function, $w[n]$, to the signal segment, yielding the windowed signal $y_w[n] = y[n]w[n]$.\n\nThe DFT of the windowed signal is given by:\n$$ Y_w[k] = \\sum_{n=0}^{N-1} y_w[n] \\exp\\left(-j \\frac{2\\pi nk}{N}\\right) $$\nThe units of $Y_w[k]$ are $\\mu$V, as $w[n]$ is dimensionless.\n\nThe total power of a signal is equivalent to its variance, $\\sigma_y^2$. A fundamental principle of PSD analysis is that the total power of a signal is the integral of its two-sided PSD, $S_{y,2}(f)$, over all frequencies:\n$$ P_{\\text{total}} = \\sigma_y^2 = \\int_{-F_s/2}^{F_s/2} S_{y,2}(f) \\, df $$\nIn the discrete domain, this integral is approximated by a sum over the DFT frequency bins:\n$$ P_{\\text{total}} \\approx \\sum_{k=0}^{N-1} S_{y,2}[k] \\Delta f $$\nwhere $\\Delta f = F_s/N$ is the frequency resolution of the DFT.\n\nThe periodogram is a common estimator of the PSD. For a windowed signal, the PSD estimator must be scaled to conserve power. The appropriate scaling factor accounts for the sampling frequency and the power of the window function. The two-sided PSD estimate, $S_{y,2}[k]$, at frequency bin $k$ is defined as:\n$$ S_{y,2}[k] = \\frac{1}{F_s S_2} |Y_w[k]|^2 $$\nwhere $S_2 = \\sum_{n=0}^{N-1} w[n]^2$ is the sum of the squares of the window coefficients, which we identify as the **window power factor**. This factor ensures that the total power estimated from the PSD matches the power estimated from the time-domain signal. The units of this expression are $(\\mu\\text{V})^2 / \\text{Hz}$, which are correct for a PSD.\n\nFor the specified Hann window, $w[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right)$, the window power factor $S_2$ has a well-known value. Its exact value is derived from the sum:\n$$ S_2 = \\sum_{n=0}^{N-1} \\left[ \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N}\\right)\\right) \\right]^2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 - 2\\cos\\left(\\frac{2\\pi n}{N}\\right) + \\cos^2\\left(\\frac{2\\pi n}{N}\\right)\\right) $$\nUsing the identity $\\cos^2(\\theta) = \\frac{1}{2}(1 + \\cos(2\\theta))$ and the fact that the sum of a cosine over an integer number of full periods is zero ($\\sum_{n=0}^{N-1} \\cos(\\frac{2\\pi nk}{N}) = 0$ for integer $k$ not a multiple of $N$), the sum simplifies to:\n$$ S_2 = \\frac{1}{4} \\sum_{n=0}^{N-1} \\left(1 + \\frac{1}{2}\\right) = \\frac{1}{4} \\sum_{n=0}^{N-1} \\frac{3}{2} = \\frac{3}{8}N $$\n\nThe problem specifies a one-sided PSD, $S_{y,1}(f)$, which is common for real-valued signals. For a real signal, the DFT is conjugate symmetric ($Y_w[k] = Y_w^*[N-k]$), so its power spectrum $|Y_w[k]|^2$ is symmetric. The one-sided PSD is typically defined by folding the power from negative frequencies onto the positive frequencies. For frequencies $f_k > 0$ and not the Nyquist frequency, this means:\n$$ S_{y,1}(f_k) = 2 S_{y,2}(f_k) $$\nSubstituting our expressions for $S_{y,2}[k]$ and $S_2$:\n$$ S_{y,1}[k] = 2 \\left( \\frac{1}{F_s (\\frac{3}{8}N)} |Y_w[k]|^2 \\right) = \\frac{16}{3 F_s N} |Y_w[k]|^2 $$\nThis is the required scaling that produces a one-sided PSD in $\\mu\\text{V}^2/\\text{Hz}$ from the windowed DFT of $y[n]$.\n\nNext, we explain how to convert the reported counts-based PSD, $S_{x,1}(f)$, to the physical PSD, $S_{y,1}(f)$. The physical signal $y[n]$ is related to the raw count signal $x[n]$ by the calibration factor $g$:\n$$ y[n] = g \\cdot x[n] $$\nwhere $g = 0.09 \\, \\mu\\text{V/count}$. The DFT is a linear operation. Therefore, the DFT of the windowed physical signal relates to the DFT of the windowed count signal:\n$$ Y_w[k] = \\text{DFT}\\{y[n]w[n]\\} = \\text{DFT}\\{g \\cdot x[n]w[n]\\} = g \\cdot \\text{DFT}\\{x[n]w[n]\\} = g \\cdot X_w[k] $$\nThe squared magnitudes are related by $g^2$:\n$$ |Y_w[k]|^2 = g^2 |X_w[k]|^2 $$\nSince the PSD is proportional to the squared magnitude of the DFT with the same scaling constant for both signals (as the scaling depends only on $F_s$, $N$, and $w[n]$), the PSDs are directly related by $g^2$:\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) $$\nThis provides the direct conversion from a PSD in $\\text{counts}^2/\\text{Hz}$ to one in $\\mu\\text{V}^2/\\text{Hz}$.\n\n**Part 2: Calculation of Alpha-Band Power**\n\nThe power in a specific frequency band is found by integrating the one-sided PSD over that band. The alpha band is specified as $f \\in [8, 12]$ Hz.\n$$ P_{\\alpha} = \\int_{8\\,\\text{Hz}}^{12\\,\\text{Hz}} S_{y,1}(f) \\, df $$\nFirst, we convert the reported PSD, $S_{x,1}(f) = 1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}$, to physical units.\n$$ S_{y,1}(f) = g^2 S_{x,1}(f) = (0.09 \\, \\mu\\text{V/count})^2 \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = (8.1 \\times 10^{-3} \\, \\mu\\text{V}^2/\\text{count}^2) \\times (1.2 \\times 10^3 \\, \\text{counts}^2/\\text{Hz}) $$\n$$ S_{y,1}(f) = 9.72 \\, \\mu\\text{V}^2/\\text{Hz} $$\nThe problem states that the PSD is approximately flat over the alpha band. This simplifies the integral to a multiplication of the constant PSD value by the bandwidth of the interval.\nThe bandwidth is $\\Delta B = 12\\,\\text{Hz} - 8\\,\\text{Hz} = 4\\,\\text{Hz}$.\n$$ P_{\\alpha} = S_{y,1} \\times \\Delta B = (9.72 \\, \\mu\\text{V}^2/\\text{Hz}) \\times (4 \\, \\text{Hz}) $$\n$$ P_{\\alpha} = 38.88 \\, \\mu\\text{V}^2 $$\nThe problem requires the answer to be rounded to four significant figures. The calculated value of $38.88$ already has four significant figures.",
            "answer": "$$ \\boxed{38.88} $$"
        },
        {
            "introduction": "Neural oscillations are often transient events, such as brief bursts of activity, which are invisible to standard power spectra that average over long time periods. To capture these dynamics, we use time-frequency analysis, where the central challenge is balancing temporal and spectral resolution. This practice  provides a principled framework for designing a Short-Time Fourier Transform (STFT) by formalizing this trade-off, enabling you to optimize your analysis for resolving specific neural events.",
            "id": "4138622",
            "problem": "You are tasked with configuring a Short-Time Fourier Transform (STFT) for analyzing beta-band dynamics in neural signals. The goal is to resolve bursts of approximately $100$ milliseconds duration in the beta-band between $15$ and $30$ Hertz while balancing time resolution and spectral leakage. The program you write must derive the window length and hop size based on fundamental definitions and well-tested facts, without relying on shortcut formulas provided to you in the problem statement.\n\nDefinitions and assumptions:\n- Short-Time Fourier Transform (STFT) uses a windowed segment of the signal to compute local spectra. Let the sampling rate be $f_s$ (in Hertz), window length be $N$ (in samples), and hop size be $H$ (in samples).\n- Let the window function be the Hann window, which is commonly used in neural time-frequency analysis for its smooth tapering and reduced sidelobes.\n- The beta-band is defined as $[f_l, f_h] = [15, 30]$ Hertz.\n- The target burst duration is denoted by $\\tau$ (in seconds).\n- Time resolution is directly related to the window duration $T_w = N / f_s$ (in seconds).\n- Discrete Fourier transform frequency-bin width is $\\Delta f = f_s / N$ (in Hertz).\n- For the Hann window, the width of the main-lobe between its first zeros in the discrete-time Fourier transform is equal to $4 \\Delta f$ (in Hertz), and this main-lobe width is a practical proxy for spectral leakage near a tone.\n- The window and hop size must be returned in samples (unitless integer counts). All durations must be specified in seconds, and all frequencies in Hertz.\n\nDesign objective:\n- Resolve bursts of duration $\\tau$ by ensuring time resolution is sufficiently fine, which requires $T_w$ not exceeding $\\tau$ (i.e., $N / f_s \\le \\tau$).\n- Limit spectral leakage in the beta-band by bounding the Hann-window main-lobe width by a tolerance $W_{\\max} = \\alpha (f_h - f_l)$, with $\\alpha$ chosen to represent a tolerable fraction of the beta-band width. Use $\\alpha = 0.5$ so that $W_{\\max} = 0.5 \\times (30 - 15)$ Hertz. This bound is a design tolerance, not a hard physical limit.\n- Construct a dimensionless, convex trade-off objective that equally weights the normalized time resolution penalty and the normalized main-lobe width penalty. Derive an analytic choice for $N$ that minimizes this objective under the constraints $N \\le f_s \\tau$ and integer $N \\ge 4$ (to ensure a non-trivial window).\n- The hop size must satisfy two conditions: \n  1) Maintain overlap suitable for stable STFT analysis with the Hann window (use $50\\%$ overlap, which implies $H \\approx N/2$), \n  2) Provide multiple analysis frames across a burst to resolve its onset and offset; ensure at least four frames across a burst by choosing $H \\le f_s \\tau / 4$. The hop size must be an integer with $H \\ge 1$.\n\nFeasibility flag:\n- For each parameter set, determine whether both the time-resolution constraint $N / f_s \\le \\tau$ and the leakage constraint $4 f_s / N \\le W_{\\max}$ can be simultaneously satisfied. Return a boolean flag indicating feasibility.\n\nTest suite:\nImplement your program to process the following test parameter sets, expressed as $(f_s, \\tau)$ pairs, where $f_s$ is in Hertz and $\\tau$ is in seconds:\n1) $(1000, 0.1)$\n2) $(256, 0.1)$\n3) $(1200, 0.6)$\n4) $(500, 0.08)$\n\nOutput specification:\n- For each test case, compute and return a list of three values $[N, H, \\text{feasible}]$, where $N$ and $H$ are integers (in samples), and $\\text{feasible}$ is a boolean.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets (e.g., $[[N_1,H_1,\\text{feasible}_1],[N_2,H_2,\\text{feasible}_2],\\dots]$).\n\nNotes:\n- No user input is permitted; the program must be self-contained and produce the specified output directly.\n- All physical quantities must be handled in their appropriate units: Hertz for frequencies and seconds for durations; window length and hop size must be returned in samples.\n- Angles are not used in this problem.\n- Express any fractional quantities in decimal form if needed; do not use percentages in the output.",
            "solution": "We proceed from first principles and well-tested facts about the Short-Time Fourier Transform (STFT) and windowed spectral analysis to design a window length and hop size that balance time resolution and spectral leakage for beta-band dynamics.\n\nFundamental base:\n1) Short-Time Fourier Transform (STFT) constructs local spectra by multiplying the signal $x[n]$ with a window $w[n]$ of length $N$ samples and computing a discrete-time Fourier transform at successive time shifts (hops) of $H$ samples. The time resolution is governed by the window duration $T_w = N / f_s$.\n2) The discrete frequency bin width of the discrete-time Fourier transform of a length-$N$ segment is $\\Delta f = f_s / N$.\n3) For the Hann window, a well-tested property is that the main-lobe width from the first zero to the first zero is $$W(N) = 4 \\Delta f = \\frac{4 f_s}{N}.$$ This main-lobe width serves as a practical proxy for spectral leakage: a sinusoid’s power spreads across frequencies within approximately this width around the true frequency in the windowed spectrum.\n4) The target burst duration is $\\tau$ seconds; to resolve such bursts in time, we require $$T_w = \\frac{N}{f_s} \\le \\tau,$$ which avoids smearing the burst beyond its duration.\n5) The beta-band is $[f_l, f_h] = [15, 30]$ Hertz, and we tolerate a fraction of this bandwidth for the main-lobe width. Set $$W_{\\max} = \\alpha (f_h - f_l), \\quad \\alpha = 0.5,$$ hence $$W_{\\max} = 0.5 \\times (30 - 15) = 7.5 \\text{ Hertz}.$$\n\nBalancing time resolution and leakage:\nWe seek a principled compromise between time resolution and leakage. Construct a dimensionless convex cost that equally weights the normalized time duration and the normalized main-lobe width:\n$$J(N) = \\frac{1}{2}\\left(\\frac{T_w}{\\tau} + \\frac{W(N)}{W_{\\max}}\\right) = \\frac{1}{2}\\left(\\frac{N}{f_s \\tau} + \\frac{4 f_s}{N W_{\\max}}\\right).$$\nThe function $J(N)$ is convex for $N > 0$ because it is the sum of a term linear in $N$ and a term proportional to $1/N$. Minimizing $J(N)$ with respect to $N$ yields an analytic solution. Take the derivative with respect to $N$ and set to zero:\n$$\\frac{dJ}{dN} = \\frac{1}{2}\\left(\\frac{1}{f_s \\tau} - \\frac{4 f_s}{W_{\\max} N^2}\\right) = 0.$$\nSolving gives:\n$$N^2 = \\frac{4 f_s^2 \\tau}{W_{\\max}} \\quad \\Rightarrow \\quad N^\\star = f_s \\sqrt{\\frac{4 \\tau}{W_{\\max}}}.$$\nThis $N^\\star$ balances the normalized time resolution and leakage penalties.\n\nConstraints and integrality:\n- We must enforce the time-resolution constraint $N \\le f_s \\tau$ so that $T_w \\le \\tau$. Define the upper bound $$N_{\\text{time}} = \\left\\lfloor f_s \\tau \\right\\rfloor.$$\n- To enforce the leakage tolerance bound $W(N) \\le W_{\\max}$, we require $$\\frac{4 f_s}{N} \\le W_{\\max} \\quad \\Rightarrow \\quad N \\ge \\frac{4 f_s}{W_{\\max}}.$$ Define the frequency-leakage lower bound $$N_{\\text{freq}} = \\left\\lceil \\frac{4 f_s}{W_{\\max}} \\right\\rceil.$$\n- The analytic minimizer $N^\\star$ must be reconciled with these bounds and integrality. A balanced and feasible integer selection is\n$$N = \n\\begin{cases}\n\\min\\left(\\max\\left(\\left\\lfloor N^\\star \\right\\rceil, N_{\\text{freq}}\\right), N_{\\text{time}}\\right), & \\text{if } N_{\\text{freq}} \\le N_{\\text{time}},\\\\\nN_{\\text{time}}, & \\text{if } N_{\\text{freq}} > N_{\\text{time}} \\text{ (time resolution prioritized, leakage tolerance not met)}.\n\\end{cases}$$\nHere $\\lfloor \\cdot \\rceil$ denotes rounding to the nearest integer. We also enforce a minimal window length of $N \\ge 4$ to avoid degenerate windows.\n\nFeasibility flag:\nWe set a boolean feasibility indicator\n$$\\text{feasible} = \\left( \\frac{N}{f_s} \\le \\tau \\right) \\land \\left( \\frac{4 f_s}{N} \\le W_{\\max} \\right) \\equiv \\left( N \\le N_{\\text{time}} \\right) \\land \\left( N \\ge N_{\\text{freq}} \\right).$$\n\nHop size selection:\nTwo principled conditions guide hop size $H$:\n1) For the Hann window, $50\\%$ overlap ensures stable amplitude estimation and perfect reconstruction in standard STFT overlap-add, which suggests $H \\approx N/2$. Let $$H_{\\text{ola}} = \\left\\lfloor \\frac{N}{2} \\right\\rfloor.$$\n2) To resolve a burst with multiple analysis frames across its duration, require at least four frames per burst, yielding $$H \\le \\frac{f_s \\tau}{4} \\quad \\Rightarrow \\quad H_{\\text{burst}} = \\left\\lfloor \\frac{f_s \\tau}{4} \\right\\rfloor.$$\nWe choose\n$$H = \\max\\left(1, \\min\\left( H_{\\text{ola}}, H_{\\text{burst}} \\right)\\right).$$\nThis enforces integer hop size and prevents $H=0$ in extreme low-duration cases.\n\nAlgorithm summary:\nGiven $(f_s, \\tau)$ and fixed $[f_l, f_h] = [15,30]$ Hertz with $\\alpha = 0.5$, compute:\n- $W_{\\max} = \\alpha (f_h - f_l)$,\n- $N^\\star = f_s \\sqrt{4 \\tau / W_{\\max}}$,\n- $N_{\\text{time}} = \\lfloor f_s \\tau \\rfloor$,\n- $N_{\\text{freq}} = \\lceil 4 f_s / W_{\\max} \\rceil$,\n- $N$ by the selection rule above (with $N \\ge 4$),\n- $H = \\max(1, \\min(\\lfloor N/2 \\rfloor, \\lfloor f_s \\tau / 4 \\rfloor))$,\n- $\\text{feasible} = (N \\le N_{\\text{time}}) \\land (N \\ge N_{\\text{freq}})$.\n\nThis principled design balances time resolution and spectral leakage under realistic constraints. In typical neurophysiological sampling rates and short burst durations (e.g., $\\tau \\approx 0.1$ seconds), the leakage tolerance $W_{\\max} = 7.5$ Hertz is often not simultaneously satisfiable with $T_w \\le \\tau$, which is reflected by the feasibility flag being false in those cases. Larger $\\tau$ values can make the constraints simultaneously feasible.\n\nThe program implements this logic for the test suite:\n1) $(f_s,\\tau) = (1000, 0.1)$,\n2) $(256, 0.1)$,\n3) $(1200, 0.6)$,\n4) $(500, 0.08)$,\nand outputs $[N, H, \\text{feasible}]$ per case in a single-line list format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef configure_stft(fs, tau, f_l=15.0, f_h=30.0, alpha=0.5):\n    \"\"\"\n    Configure STFT window length N and hop size H for beta-band analysis.\n    Parameters:\n        fs (float): Sampling rate in Hz.\n        tau (float): Target burst duration in seconds.\n        f_l (float): Lower bound of beta band (Hz).\n        f_h (float): Upper bound of beta band (Hz).\n        alpha (float): Fraction of band width tolerated for main-lobe width.\n    Returns:\n        (N, H, feasible): window length (samples), hop size (samples), feasibility boolean.\n    \"\"\"\n    # Tolerable main-lobe width (Hz)\n    W_max = alpha * (f_h - f_l)\n\n    # Analytic minimizer from balancing normalized time and leakage terms\n    N_star_cont = fs * np.sqrt((4.0 * tau) / W_max)\n\n    # Bounds from constraints\n    N_time_max = int(np.floor(fs * tau))\n    N_freq_min = int(np.ceil((4.0 * fs) / W_max))\n\n    # Round N_star to nearest integer\n    N_star = int(np.round(N_star_cont))\n\n    # Select N under constraints; prioritize time resolution if infeasible\n    if N_time_max < 4:  # ensure non-trivial window\n        N_time_max = 4\n\n    if N_freq_min <= N_time_max:\n        N = max(N_star, N_freq_min)\n        N = min(N, N_time_max)\n    else:\n        # Constraints cannot be simultaneously satisfied; prioritize time resolution\n        N = N_time_max\n\n    # Ensure minimum N\n    N = max(N, 4)\n\n    # Hop size: 50% overlap and at least four frames per burst\n    H_ola = N // 2\n    H_burst = int(np.floor(fs * tau / 4.0))\n    # Ensure H >= 1\n    H = max(1, min(H_ola, H_burst))\n\n    # Feasibility flag: both constraints satisfied\n    feasible = (N <= N_time_max) and (N >= N_freq_min)\n\n    return int(N), int(H), bool(feasible)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (fs in Hz, tau in seconds)\n    test_cases = [\n        (1000.0, 0.1),\n        (256.0, 0.1),\n        (1200.0, 0.6),\n        (500.0, 0.08),\n    ]\n\n    results = []\n    for fs, tau in test_cases:\n        N, H, feasible = configure_stft(fs, tau)\n        results.append([N, H, feasible])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real-world electrophysiological recordings are inevitably contaminated by non-neural artifacts, such as muscle activity, which can obscure or be mistaken for genuine brain oscillations. This advanced practice challenges you to build a complete artifact removal pipeline using Independent Component Analysis (ICA). You will learn how the distinct spectral characteristics of artifacts can be used to identify and separate them from underlying neural sources , a critical skill for robust data analysis.",
            "id": "4138598",
            "problem": "You are given the task of constructing a fully specified program that synthesizes multichannel neuroelectric recordings containing neural oscillations and muscle artifacts, identifies elevated broadband high-frequency power components via Independent Component Analysis (ICA), removes those components, and verifies that neural oscillations are preserved after cleaning. The program must be based on first principles and standard definitions in signal processing and statistical modeling.\n\nFundamental base and definitions:\n\n- Assume a linear instantaneous mixing model for multichannel recordings. Let $s(t) \\in \\mathbb{R}^{n_s}$ denote $n_s$ source processes and $x(t) \\in \\mathbb{R}^{n_c}$ denote $n_c$ observed channels. The model is\n$$\nx(t) = A s(t) + \\epsilon(t),\n$$\nwhere $A \\in \\mathbb{R}^{n_c \\times n_s}$ is a full-column-rank mixing matrix, and $\\epsilon(t)$ is additive sensor noise. Observations are sampled at a sampling frequency $f_s$ in hertz (Hz), producing $N$ samples with time index $t_k = k/f_s$ for $k \\in \\{0,1,\\dots,N-1\\}$.\n\n- The Power Spectral Density (PSD) $S_{xx}(f)$ of a stationary process $x(t)$ is defined, in terms of the Fourier transform $X_T(f)$ over duration $T$, by\n$$\nS_{xx}(f) = \\lim_{T \\to \\infty} \\frac{\\mathbb{E}\\left[|X_T(f)|^2\\right]}{T}.\n$$\nThe bandpower $P_{B}$ in a frequency band $B=[f_l,f_h]$ is\n$$\nP_{B} = \\int_{f_l}^{f_h} S_{xx}(f) \\, df.\n$$\nIn numerical practice, you will approximate $S_{xx}(f)$ using Welch’s method and approximate the integral by a Riemann sum with resolution $\\Delta f$.\n\n- Independent Component Analysis (ICA) assumes that sources are statistically independent and non-Gaussian. After centering and whitening, ICA identifies an unmixing matrix $W$ such that\n$$\nS = W X_{\\text{white}},\n$$\nwith $S$ approximating the independent sources. Whitening uses the eigen-decomposition of the covariance matrix. Non-Gaussianity is operationalized via a contrast function (for example, a hyperbolic tangent nonlinearity) and solved by a fixed-point iteration with orthogonalization. Removal of identified artifact components is achieved by zeroing those components in $S$ and back-projecting to the sensor space using the inverse operations of ICA and whitening.\n\nScenario:\n\n- Synthesize $n_s = 4$ sources: a neural oscillation at $f_{\\alpha} = 10$ Hz, one or two muscle artifacts modeled as band-limited broadband noise in a high-frequency band $[f_{m1,l}, f_{m1,h}]$ and optionally $[f_{m2,l}, f_{m2,h}]$, a $1/f$-like background noise process, and a low-frequency ocular-like artifact near $f_o = 1$ Hz. Mix these sources into $n_c = 8$ channels via a fixed random mixing matrix $A$ and add small sensor noise. Use $f_s = 512$ Hz and a duration $T = 10$ s, so $N = T \\cdot f_s$ samples. All amplitude quantities are in microvolts.\n\n- Identify independent components with elevated broadband high-frequency power using a decision criterion based on the fraction\n$$\nr_i = \\frac{P_{HF,i}}{P_{\\text{tot},i}},\n$$\nwhere $P_{HF,i}$ is the bandpower of component $i$ in a high-frequency band $[70,100]$ Hz, and $P_{\\text{tot},i}$ is the total bandpower in $[1,150]$ Hz. Components with $r_i$ exceeding a fixed threshold should be marked as muscle artifacts. Remove them by setting their time courses to zero and reconstruct cleaned channel signals.\n\n- Verification: Compute, for each channel, the high-frequency bandpower in $[70,100]$ Hz before and after cleaning to obtain an average fractional reduction across channels\n$$\nR = \\frac{\\overline{P_{HF}^{\\text{pre}}} - \\overline{P_{HF}^{\\text{post}}}}{\\overline{P_{HF}^{\\text{pre}}}},\n$$\nand compute the average relative change in the alpha band $[8,12]$ Hz across channels\n$$\n\\Delta_{\\alpha} = \\left|\\frac{\\overline{P_{\\alpha}^{\\text{post}}} - \\overline{P_{\\alpha}^{\\text{pre}}}}{\\overline{P_{\\alpha}^{\\text{pre}}}}\\right|.\n$$\nDeclare success for a test case if $R \\ge 0.3$ and $\\Delta_{\\alpha} \\le 0.1$. The angle unit for any phase computations is radians; frequency is in Hz; time is in seconds; amplitude is in microvolts. The final outputs are booleans per test case and have no units.\n\nImplementation requirements:\n\n- Implement centering, whitening via eigen-decomposition of the covariance matrix, and a deflationary fixed-point ICA with a hyperbolic tangent nonlinearity. Use Welch’s method to compute PSDs and bandpowers. Model muscle artifacts by band-pass filtering white noise into prescribed high-frequency bands.\n\n- Use only the Python language and the libraries specified in the final answer requirements. Ensure numerical stability with appropriate regularization where needed.\n\nTest suite:\n\nProvide a program that runs the following four test parameter sets, each specified as a tuple $(\\text{seed}, A_{\\alpha}, A_{m1}, A_{m2}, A_{\\text{bg}})$, where $A_{\\alpha}$ is the amplitude of the alpha oscillation, $A_{m1}$ and $A_{m2}$ are the amplitudes of one or two muscle artifacts, and $A_{\\text{bg}}$ is the amplitude of the $1/f$ background, all in microvolts:\n\n- Case $1$: $(0, 20, 0, 0, 5)$, no muscle artifact; edge case testing preservation with no removal.\n- Case $2$: $(1, 20, 10, 0, 5)$, mild muscle artifact; happy path detection and removal.\n- Case $3$: $(2, 25, 25, 15, 7)$, strong dual muscle artifacts; significant removal required.\n- Case $4$: $(3, 15, 5, 0, 10)$, borderline artifact with higher background; tests threshold behavior.\n\nFinal output format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$), where each $\\text{result}$ is a boolean indicating whether the artifact removal was successful while preserving neural oscillations for the corresponding test case.",
            "solution": "The problem statement is evaluated as valid. It is scientifically grounded, well-posed, and objective, describing a standard task in computational neuroscience: the simulation and cleaning of multichannel neuroelectric data. The model, definitions, and proposed methodology—including the linear mixing model, Power Spectral Density (PSD) estimation via Welch's method, and artifact removal using Independent Component Analysis (ICA)—are all based on established principles in signal processing and statistical modeling. The problem provides a clear, quantitative framework for both implementation and verification. Minor ambiguities, such as the precise value for the artifact identification threshold, are resolvable with reasonable, explicitly stated assumptions and do not compromise the problem's integrity. We will proceed with a full solution.\n\nThe solution is implemented in three principal stages: signal synthesis, ICA-based artifact removal, and quantitative verification.\n\n**1. Synthesis of Multichannel Data**\n\nThe synthetic data is generated based on a linear instantaneous mixing model:\n$$x(t) = A s(t) + \\epsilon(t)$$\nwhere $s(t) \\in \\mathbb{R}^{n_s}$ represents $n_s=4$ source signals, $x(t) \\in \\mathbb{R}^{n_c}$ represents $n_c=8$ observed channel signals, $A \\in \\mathbb{R}^{n_c \\times n_s}$ is a random, full-column-rank mixing matrix, and $\\epsilon(t)$ is additive Gaussian sensor noise. The signals are generated for a duration of $T=10$ seconds at a sampling rate of $f_s=512$ Hz, resulting in $N=T \\cdot f_s = 5120$ samples. The time vector is $t_k = k/f_s$ for $k \\in \\{0, 1, \\dots, N-1\\}$.\n\nThe four source signals $s(t)$ are constructed as follows to model distinct neurophysiological and artifactual activities:\n-   **Neural Oscillation:** A pure sinusoidal signal representing an alpha-band rhythm, defined as $s_{0}(t) = A_{\\alpha} \\sin(2\\pi f_{\\alpha} t + \\phi)$, with frequency $f_{\\alpha}=10$ Hz and amplitude $A_{\\alpha}$ specified by the test case. The phase $\\phi$ is chosen randomly.\n-   **Muscle Artifacts:** These are modeled as band-limited high-frequency noise. Gaussian white noise is generated and then band-pass filtered. For this implementation, a fourth-order Butterworth filter is used. Muscle source $1$ occupies the frequency band $[70, 100]$ Hz. If a second muscle source is specified ($A_{m2} > 0$), it occupies the band $[80, 110]$ Hz. The amplitudes are $A_{m1}$ and $A_{m2}$.\n-   **Ocular Artifact:** This low-frequency artifact is used in place of the second muscle source when $A_{m2}=0$. It is modeled as low-pass filtered Gaussian white noise with a cutoff frequency of $2$ Hz to simulate slow eye movements or blinks. A fixed amplitude is used.\n-   **Background $1/f$ Brain Activity:** This source models the scale-free nature of background brain noise. It is synthesized by generating a complex-valued white noise signal in the frequency domain, scaling the amplitude of each frequency component $f$ by $1/\\sqrt{f}$, and then transforming back to the time domain via the inverse Fast Fourier Transform (iFFT). Hermitian symmetry is enforced to ensure a real-valued time signal. The amplitude is given by $A_{\\text{bg}}$.\n\nThese four sources are combined into a source matrix $S \\in \\mathbb{R}^{4 \\times N}$. A fixed random mixing matrix $A \\in \\mathbb{R}^{8 \\times 4}$ is generated once and used for all test cases to ensure consistency. The mixed signals $X = AS$ are then contaminated with weak, independent Gaussian noise on each channel to form the final observed data $X_{\\text{obs}}$.\n\n**2. Artifact Identification and Removal**\n\nArtifact removal is performed using ICA, which aims to find a linear transformation that separates the mixed signals into statistically independent components.\n\n-   **Preprocessing (Centering and Whitening):** First, the data is centered by subtracting the mean from each channel: $X_c = X_{\\text{obs}} - \\mathbb{E}[X_{\\text{obs}}]$. Second, the data is whitened. This is achieved via Principal Component Analysis (PCA). The covariance matrix $C_X = \\text{cov}(X_c)$ is computed and its eigen-decomposition $C_X = E D E^T$ is found. The whitening transformation projects the centered data onto the $n_s=4$ principal eigenvectors and scales the result by the inverse square root of the corresponding eigenvalues. The whitening matrix is $M_{\\text{white}} = D_{1:n_s}^{-1/2} E_{1:n_s}^T$, where $E_{1:n_s}$ contains the eigenvectors and $D_{1:n_s}$ is a diagonal matrix of eigenvalues. A small regularization term is added to the eigenvalues to ensure numerical stability. The whitened data is $X_w = M_{\\text{white}} X_c$.\n\n-   **FastICA Algorithm:** A deflationary fixed-point algorithm is used to find the unmixing matrix $W_{\\text{ICA}} \\in \\mathbb{R}^{n_s \\times n_s}$. The algorithm iteratively estimates vectors $w_i$ (rows of $W_{\\text{ICA}}$) that maximize the non-Gaussianity of the projected data $w_i^T X_w$. The update rule for a vector $w$ is based on a contrast function, in this case $g(u) = \\tanh(u)$:\n    $$w^{+} \\leftarrow \\mathbb{E}[X_w g(w^T X_w)] - \\mathbb{E}[g'(w^T X_w)]w$$\n    After each update, the vector $w^{+}$ is decorrelated from previously found vectors and normalized. This process is repeated until all $n_s$ component vectors are estimated. The final estimated sources are $S_{\\text{est}} = W_{\\text{ICA}} X_w$.\n\n-   **Artifact Component Identification:** Each estimated source component in $S_{\\text{est}}$ is analyzed in the frequency domain. Its PSD is computed using Welch's method. The criterion for identifying a muscle artifact is the ratio $r_i$ of its power in a high-frequency band to its total power:\n    $$r_i = \\frac{P_{\\text{HF},i}}{P_{\\text{tot},i}} = \\frac{\\int_{70 \\text{Hz}}^{100 \\text{Hz}} S_{ii}(f) \\, df}{\\int_{1 \\text{Hz}}^{150 \\text{Hz}} S_{ii}(f) \\, df}$$\n    A component $i$ is classified as an artifact if $r_i > 0.3$. This threshold assumes that muscle activity contributes a significant fraction of its power in the high-frequency range.\n\n-   **Signal Reconstruction:** The time series of the identified artifactual components in $S_{\\text{est}}$ are set to zero, yielding a cleaned source matrix $S_{\\text{clean}}$. To reconstruct the signal in the sensor space, the overall unmixing transformation is inverted. The full unmixing matrix is $W_{\\text{unmix}} = W_{\\text{ICA}} M_{\\text{white}}$. The estimated mixing matrix is its Moore-Penrose pseudo-inverse, $A_{\\text{est}} = W_{\\text{unmix}}^{\\dagger}$. The cleaned channel data is then reconstructed by mixing the cleaned sources, $X_{c, \\text{clean}} = A_{\\text{est}} S_{\\text{clean}}$, and adding back the channel means: $X_{\\text{clean}} = X_{c, \\text{clean}} + \\mathbb{E}[X_{\\text{obs}}]$.\n\n**3. Verification of Cleaning Performance**\n\nThe success of the procedure is evaluated against two criteria, as specified in the problem. The bandpower computations are performed using PSDs from Welch's method, with the integral approximated by a Riemann sum.\n\n-   **High-Frequency Artifact Reduction ($R$):** This metric quantifies the removal of artifactual power in the $[70, 100]$ Hz band. The bandpower for each channel is calculated before ($P_{HF,j}^{\\text{pre}}$) and after ($P_{HF,j}^{\\text{post}}$) cleaning. The metric is the fractional reduction averaged across channels:\n    $$R = \\frac{\\overline{P_{HF}^{\\text{pre}}} - \\overline{P_{HF}^{\\text{post}}}}{\\overline{P_{HF}^{\\text{pre}}}}$$\n-   **Alpha-Band Oscillation Preservation ($\\Delta_{\\alpha}$):** This metric quantifies the preservation of the neural signal of interest in the alpha band, $[8, 12]$ Hz. It is the absolute relative change in average alpha-band power:\n    $$\\Delta_{\\alpha} = \\left|\\frac{\\overline{P_{\\alpha}^{\\text{post}}} - \\overline{P_{\\alpha}^{\\text{pre}}}}{\\overline{P_{\\alpha}^{\\text{pre}}}}\\right|$$\n\nA test case is considered successful if and only if both conditions are met: $R \\ge 0.3$ and $\\Delta_{\\alpha} \\le 0.1$. According to this strict rule, the first test case (with no muscle artifact) is expected to fail, as $R$ will be near zero.",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\n\ndef bandpass_filter(data, lowcut, highcut, fs, order=4):\n    \"\"\"Applies a band-pass Butterworth filter to data.\"\"\"\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    b, a = signal.butter(order, [low, high], btype='band')\n    y = signal.filtfilt(b, a, data)\n    return y\n\ndef lowpass_filter(data, cutoff, fs, order=4):\n    \"\"\"Applies a low-pass Butterworth filter to data.\"\"\"\n    nyq = 0.5 * fs\n    normal_cutoff = cutoff / nyq\n    b, a = signal.butter(order, normal_cutoff, btype='low', analog=False)\n    y = signal.filtfilt(b, a, data)\n    return y\n\ndef generate_pink_noise(N, rng, amplitude=1.0, beta=1.0):\n    \"\"\"Generates pink (1/f) noise.\"\"\"\n    freqs = np.fft.rfftfreq(N)\n    # Generate complex noise with Hermitian symmetry\n    noise_fft = rng.standard_normal(len(freqs)) + 1j * rng.standard_normal(len(freqs))\n    noise_fft[0] = 0  # No DC component\n    \n    # Scale amplitudes by 1/f^beta\n    with np.errstate(divide='ignore'):\n        scaling = 1.0 / (freqs**(beta/2.0))\n    scaling[0] = 0\n    noise_fft *= scaling\n    \n    # Ensure Hermitian symmetry for real output\n    if N % 2 == 0:\n        noise_fft[-1] = np.conj(noise_fft[-1])\n\n    y = np.fft.irfft(noise_fft, n=N)\n    y /= np.std(y) # Normalize to std=1\n    return y * amplitude\n\ndef synthesize_data(case_params, fs, T, n_c, rng_mix):\n    \"\"\"Synthesizes multichannel data based on the problem specification.\"\"\"\n    seed, A_alpha, A_m1, A_m2, A_bg = case_params\n    N = int(fs * T)\n    t = np.arange(N) / fs\n    rng = np.random.default_rng(seed)\n\n    # 1. Alpha oscillation\n    phi_alpha = rng.uniform(0, 2 * np.pi)\n    s_alpha = A_alpha * np.sin(2 * np.pi * 10 * t + phi_alpha)\n\n    # 2. Muscle artifacts\n    s_m1 = generate_pink_noise(N, rng, amplitude=0) # Initialize as zero\n    if A_m1 > 0:\n        noise_m1 = rng.standard_normal(N)\n        s_m1_filtered = bandpass_filter(noise_m1, 70, 100, fs)\n        s_m1 = (s_m1_filtered / np.std(s_m1_filtered)) * A_m1\n\n    # 3. Muscle artifact 2 OR Ocular artifact\n    if A_m2 > 0:\n        noise_m2 = rng.standard_normal(N)\n        s_m2_filtered = bandpass_filter(noise_m2, 80, 110, fs)\n        s_alternate = (s_m2_filtered / np.std(s_m2_filtered)) * A_m2\n    else:\n        # Ocular artifact\n        A_ocular = 50.0  # Ocular artifacts have large amplitude\n        noise_ocular = rng.standard_normal(N)\n        s_ocular_filtered = lowpass_filter(noise_ocular, 2, fs)\n        s_alternate = (s_ocular_filtered / np.std(s_ocular_filtered)) * A_ocular\n\n    # 4. 1/f background noise\n    s_bg = generate_pink_noise(N, rng, amplitude=A_bg, beta=1.0)\n    \n    sources = np.vstack([s_alpha, s_m1, s_alternate, s_bg])\n    n_s = sources.shape[0]\n\n    # 5. Mixing\n    A = rng_mix.standard_normal((n_c, n_s))\n    x_mixed = A @ sources\n\n    # 6. Sensor noise\n    sensor_noise_amp = 1.0\n    noise = rng.standard_normal(x_mixed.shape) * sensor_noise_amp\n    x_obs = x_mixed + noise\n\n    return x_obs\n\ndef calculate_bandpower(data, fs, band, nperseg=512):\n    \"\"\"Calculates power in a frequency band using Welch's method.\"\"\"\n    freqs, psd = signal.welch(data, fs, nperseg=nperseg)\n    freq_res = freqs[1] - freqs[0]\n    band_idx = np.where((freqs >= band[0]) & (freqs <= band[1]))[0]\n    if len(band_idx) == 0:\n        return 0.0\n    band_power = np.sum(psd[band_idx]) * freq_res\n    return band_power\n\ndef fast_ica(X, n_components, max_iter=200, tol=1e-6, rng=None):\n    \"\"\"Performs FastICA using deflation and tanh contrast.\"\"\"\n    if rng is None:\n        rng = np.random.default_rng()\n    \n    n_features, n_samples = X.shape\n    W = np.zeros((n_components, n_components))\n\n    for i in range(n_components):\n        w = rng.standard_normal(n_components)\n        w /= np.linalg.norm(w)\n        \n        for _ in range(max_iter):\n            w_T_X = w.T @ X\n            g_w_T_X = np.tanh(w_T_X)\n            g_prime_w_T_X = 1 - g_w_T_X**2\n            \n            w_new = np.mean(X * g_w_T_X, axis=1) - np.mean(g_prime_w_T_X) * w\n            \n            # Decorrelate with previous components\n            w_new -= W[:i, :].T @ (W[:i, :] @ w_new)\n            w_new /= np.linalg.norm(w_new)\n            \n            # Check for convergence\n            if np.abs(np.abs(w_new @ w) - 1) < tol:\n                break\n            w = w_new\n        W[i, :] = w\n        \n    return W\n\ndef ica_clean(x_obs, n_components=4):\n    \"\"\"Applies ICA, identifies and removes artifacts, and reconstructs the signal.\"\"\"\n    n_channels, n_samples = x_obs.shape\n    fs = 512.0\n    \n    # 1. Centering\n    x_mean = np.mean(x_obs, axis=1, keepdims=True)\n    x_centered = x_obs - x_mean\n    \n    # 2. Whitening via PCA\n    cov = np.cov(x_centered)\n    eig_vals, eig_vecs = np.linalg.eigh(cov)\n    \n    # Sort in descending order\n    idx = np.argsort(eig_vals)[::-1]\n    eig_vals = eig_vals[idx]\n    eig_vecs = eig_vecs[:, idx]\n\n    # Select top n_components\n    W_pca = eig_vecs[:, :n_components]\n    D_sqrt_inv = np.diag(1.0 / np.sqrt(eig_vals[:n_components] + 1e-12))\n    \n    # Whitening matrix and whitened data\n    whitening_matrix = D_sqrt_inv @ W_pca.T\n    x_whitened = whitening_matrix @ x_centered\n\n    # 3. FastICA\n    W_ica = fast_ica(x_whitened, n_components)\n    s_est = W_ica @ x_whitened\n    \n    # 4. Identify artifact components\n    artifact_indices = []\n    hf_band = [70, 100]\n    total_band = [1, 150]\n    ratio_threshold = 0.3\n    \n    for i in range(n_components):\n        p_hf = calculate_bandpower(s_est[i, :], fs, hf_band)\n        p_total = calculate_bandpower(s_est[i, :], fs, total_band)\n        if p_total > 1e-9: # Avoid division by zero\n            ratio = p_hf / p_total\n            if ratio > ratio_threshold:\n                artifact_indices.append(i)\n\n    # 5. Remove artifacts and reconstruct\n    s_clean = s_est.copy()\n    s_clean[artifact_indices, :] = 0.0\n    \n    # Reconstruct signal\n    full_unmixing_matrix = W_ica @ whitening_matrix\n    # Estimated mixing matrix is the pseudo-inverse\n    A_est = np.linalg.pinv(full_unmixing_matrix)\n    x_c_clean = A_est @ s_clean\n    \n    # 6. Add mean back\n    x_clean = x_c_clean + x_mean\n    \n    return x_clean\n\ndef verify(x_pre, x_post, fs):\n    \"\"\"Verifies cleaning performance against the specified criteria.\"\"\"\n    n_channels = x_pre.shape[0]\n    hf_band = [70, 100]\n    alpha_band = [8, 12]\n    \n    p_hf_pre_list, p_hf_post_list = [], []\n    p_alpha_pre_list, p_alpha_post_list = [], []\n    \n    for i in range(n_channels):\n        p_hf_pre_list.append(calculate_bandpower(x_pre[i, :], fs, hf_band))\n        p_hf_post_list.append(calculate_bandpower(x_post[i, :], fs, hf_band))\n        p_alpha_pre_list.append(calculate_bandpower(x_pre[i, :], fs, alpha_band))\n        p_alpha_post_list.append(calculate_bandpower(x_post[i, :], fs, alpha_band))\n\n    avg_p_hf_pre = np.mean(p_hf_pre_list)\n    avg_p_hf_post = np.mean(p_hf_post_list)\n    avg_p_alpha_pre = np.mean(p_alpha_pre_list)\n    avg_p_alpha_post = np.mean(p_alpha_post_list)\n\n    if avg_p_hf_pre < 1e-9:\n        R = 0.0\n    else:\n        R = (avg_p_hf_pre - avg_p_hf_post) / avg_p_hf_pre\n        \n    if avg_p_alpha_pre < 1e-9:\n        delta_alpha = 0.0\n    else:\n        delta_alpha = np.abs(avg_p_alpha_post - avg_p_alpha_pre) / avg_p_alpha_pre\n        \n    success = R >= 0.3 and delta_alpha <= 0.1\n    return success\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        (0, 20, 0, 0, 5),   # Case 1: No muscle artifact\n        (1, 20, 10, 0, 5),  # Case 2: Mild muscle artifact\n        (2, 25, 25, 15, 7), # Case 3: Strong dual muscle artifacts\n        (3, 15, 5, 0, 10)    # Case 4: Borderline artifact\n    ]\n\n    fs = 512.0\n    T = 10.0\n    n_c = 8\n    \n    # A fixed random mixing matrix for all cases\n    rng_mix = np.random.default_rng(42)\n\n    results = []\n    for case in test_cases:\n        # 1. Synthesize data\n        x_obs = synthesize_data(case, fs, T, n_c, rng_mix)\n        \n        # 2. Clean data using ICA\n        x_clean = ica_clean(x_obs, n_components=4)\n        \n        # 3. Verify the result\n        success = verify(x_obs, x_clean, fs)\n        results.append(success)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}