{
    "hands_on_practices": [
        {
            "introduction": "第一个实践通过将尖峰去卷积构建为一个凸优化问题，介绍了解决该问题的基本方法 。我们将观测到的钙荧光信号建模为潜在尖峰序列与衰减核的线性卷积，并受噪声污染。你将学习通过最小化一个最小二乘误差项与一个促进神经尖峰固有稀疏性的 $\\ell_1$ 惩罚项来求解这个逆问题，并从零开始实现强大的快速迭代收缩阈值算法 (FISTA)。",
            "id": "4154479",
            "problem": "给定一个通过荧光成像记录的单个神经元的细胞内钙动力学离散时间模型。钙离子浓度被建模为一个由非负脉冲序列驱动的稳定线性时不变过程。设 $t \\in \\{0,1,2,\\dots,T-1\\}$。潜在的钙离子浓度 $c_t$ 遵循 $c_t = \\alpha \\, c_{t-1} + s_t$，其中 $c_{-1} = 0$，$0 < \\alpha < 1$ 是每个时间步的衰减因子，$s_t \\ge 0$ 是以任意单位表示的非负脉冲率。观测到的荧光信号 $y_t$ 为 $y_t = c_t + \\varepsilon_t$，其中 $\\varepsilon_t$ 是一个加性干扰。\n\n编写一个完整的程序，针对下方的每个测试用例，通过求解一个凸优化问题来估计脉冲序列，然后报告一个定量的误差度量。您的程序必须不接受任何输入，并且必须打印一行包含汇总结果的字符串。\n\n基本原理和定义：\n- 由 $c_t = \\alpha \\, c_{t-1} + s_t$ 和 $c_{-1}=0$ 推导出的离散时间卷积前向模型得出 $c_t = \\sum_{k=0}^{t} \\alpha^{t-k} s_k$。定义下三角托普利兹矩阵 $G \\in \\mathbb{R}^{T \\times T}$，其第一列为 $[1,\\alpha,\\alpha^2,\\dots,\\alpha^{T-1}]^\\top$，第一行为 $[1,0,0,\\dots,0]$。那么荧光时间序列为 $y = G s + \\varepsilon$，其中 $s \\in \\mathbb{R}_{\\ge 0}^{T}$ 是非负脉冲向量，$y \\in \\mathbb{R}^{T}$ 是观测值。\n- 脉冲推断被构建为一个带惩罚的最小二乘估计问题：最小化 $f(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2 + \\lambda \\lVert s \\rVert_1$，约束条件为 $s \\ge 0$，其中 $\\lambda > 0$ 通过非负最小绝对收缩和选择算子（LASSO）惩罚项来控制稀疏程度。\n\n您的任务：\n1. 严格从上述基本定义出发，推导平滑项相对于 $s$ 的梯度、该梯度的利普希茨常数，以及对应于非负约束 $\\ell_1$ 惩罚项的邻近算子。利用这些推导设计一个带 Nesterov 加速的一阶方法，即快速迭代收缩阈值算法（FISTA），以在 $s \\ge 0$ 的约束下最小化目标函数。\n2. 在代码中实现所推导的算法，并遵循以下数值规定：\n   - 使用固定步长，其大小等于平滑项梯度的利普希茨常数的倒数。\n   - 在 $s^{(0)} = 0$ 处初始化，并对迭代使用标准的 Nesterov 加速。\n   - 使用基于连续迭代之间相对 $\\ell_2$ 变化的终止准则：当 $\\lVert s^{(k)} - s^{(k-1)} \\rVert_2 / \\max\\{1,\\lVert s^{(k-1)} \\rVert_2\\} \\le \\tau$ 时停止，其中 $\\tau$ 是一个容差。\n   - 在每次迭代中通过相应的邻近算子施加非负性和 $\\ell_1$ 正则化。\n3. 对于下方的每个测试用例，根据 $\\alpha$ 和 $T$ 构建 $G$，构建真实脉冲序列 $s_{\\mathrm{true}}$，构建 $y = G s_{\\mathrm{true}} + \\varepsilon$，运行您的求解器以获得 $\\hat{s}$，并报告平均绝对误差 $\\mathrm{MAE} = \\frac{1}{T} \\sum_{t=0}^{T-1} | \\hat{s}_t - s_{\\mathrm{true},t} |$，结果为保留六位小数的浮点数。\n\n使用以下确定性测试套件（下文提及的所有角度均以弧度为单位）：\n- 测试 A（理想路径，模型精确匹配）：\n  - 长度 $T = 60$，衰减因子 $\\alpha = 0.95$，正则化参数 $\\lambda = 0.001$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲序列 $s_{\\mathrm{true}}$ 在各处均为零，除了 $s_{\\mathrm{true},5} = 1.0$，$s_{\\mathrm{true},20} = 0.5$ 和 $s_{\\mathrm{true},40} = 1.5$。\n  - 所有 $t$ 的干扰 $\\varepsilon_t = 0$。\n- 测试 B（带有结构化干扰的脉冲簇）：\n  - 长度 $T = 80$，衰减因子 $\\alpha = 0.9$，正则化参数 $\\lambda = 0.1$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲序列 $s_{\\mathrm{true}}$ 在各处均为零，除了 $s_{\\mathrm{true},10} = 0.3$，$s_{\\mathrm{true},11} = 0.3$，$s_{\\mathrm{true},12} = 0.3$。\n  - 对于 $t \\in \\{0,\\dots,79\\}$，干扰为 $\\varepsilon_t = 0.02 \\cos\\!\\big(2\\pi t / 11\\big)$。\n- 测试 C（无脉冲，强正则化，微小干扰）：\n  - 长度 $T = 50$，衰减因子 $\\alpha = 0.98$，正则化参数 $\\lambda = 0.2$，容差 $\\tau = 10^{-9}$。\n  - 真实脉冲序列 $s_{\\mathrm{true}}$ 全部为零。\n  - 对于 $t \\in \\{0,\\dots,49\\}$，干扰为 $\\varepsilon_t = 0.001 \\left[\\sin\\!\\big(2\\pi t / 7\\big) + 0.5 \\sin\\!\\big(2\\pi t / 3\\big)\\right]$。\n\n您的程序必须：\n- 实现一次求解器，并在三个测试用例中复用它。\n- 为每个测试用例计算上文定义的平均绝对误差，并将其四舍五入到六位小数。\n- 生成单行输出，其中包含三个结果，以逗号分隔，并用方括号括起来，顺序为 A、B、C。例如，您的程序应在一行上输出类似 $[0.000123,0.045678,0.000000]$ 的值（这仅是示例；请计算实际值）。",
            "solution": "该问题是有效的，因为它在计算神经科学和信号处理领域提出了一个适定、有科学依据且自洽的任务。它要求将标准的凸优化技术应用于一个线性逆问题。所有模型、参数和测试用例都以数学精度定义，没有歧义。\n\n目标是从观测到的荧光时间序列 $y \\in \\mathbb{R}^{T}$ 中估计一个非负脉冲序列 $s \\in \\mathbb{R}_{\\ge 0}^{T}$。该问题被表述为以下凸优化问题：\n$$\n\\underset{s \\ge 0}{\\text{minimize}} \\quad f(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2 + \\lambda \\lVert s \\rVert_1\n$$\n其中 $G$ 是表示钙动力学的卷积矩阵，$\\lambda > 0$ 是一个正则化参数，用于促进估计的脉冲序列 $s$ 的稀疏性。\n\n该问题使用快速迭代收缩阈值算法（FISTA）来求解，这是一种一阶邻近梯度法，非常适用于形如 $f(s) = L(s) + R(s)$ 的复合目标函数，其中 $L(s)$ 是一个光滑凸函数，$R(s)$ 是一个凸函数（可能非光滑）。\n\n对于我们的问题，我们定义：\n- 光滑分量（数据保真项）：$L(s) = \\frac{1}{2} \\lVert G s - y \\rVert_2^2$。\n- 非光滑分量（正则化项和约束）：$R(s) = \\lambda \\lVert s \\rVert_1 + I_+(s)$，其中 $I_+(s)$ 是非负象限的指示函数，如果 $s \\ge 0$（逐分量），则为 $0$，否则为 $\\infty$。该项通过 $\\ell_1$ 范数强制稀疏性，并强制脉冲序列的非负性。\n\nFISTA 算法需要从该公式推导出的三个关键组成部分：光滑项的梯度、该梯度的利普希茨常数，以及非光滑项的邻近算子。\n\n1.  **光滑项的梯度, $\\nabla L(s)$**\n    光滑项是一个标准的最小二乘目标函数。其相对于 $s$ 的梯度推导如下：\n    $$\n    L(s) = \\frac{1}{2} (Gs - y)^\\top (Gs - y) = \\frac{1}{2} (s^\\top G^\\top G s - 2 y^\\top G s + y^\\top y)\n    $$\n    对向量 $s$求导得出：\n    $$\n    \\nabla L(s) = G^\\top G s - G^\\top y = G^\\top(Gs - y)\n    $$\n\n2.  **梯度的利普希茨常数, $K$**\n    如果步长选择得当，FISTA 算法的收敛性是有保证的。一个常见的选择是 $\\nabla L(s)$ 的利普希茨常数的倒数。对于具有连续二阶导数的函数，利普希茨常数是其海森矩阵范数的最大值。$L(s)$ 的海森矩阵是：\n    $$\n    \\nabla^2 L(s) = G^\\top G\n    $$\n    利普希茨常数 $K$ 是这个半正定矩阵 $G^\\top G$ 的最大特征值 $\\lambda_{\\max}$。这等价于矩阵 $G$ 的最大奇异值 $\\sigma_{\\max}$ 的平方。\n    $$\n    K = \\lambda_{\\max}(G^\\top G) = \\sigma_{\\max}(G)^2\n    $$\n    梯度下降更新的步长将固定为 $\\gamma = 1/K$。\n\n3.  **非光滑项的邻近算子, $\\text{prox}_{\\gamma R}(v)$**\n    $\\gamma R(s)$ 的邻近算子定义为：\n    $$\n    \\text{prox}_{\\gamma R}(v) = \\underset{s}{\\text{argmin}} \\left( \\frac{1}{2} \\lVert s - v \\rVert_2^2 + \\gamma R(s) \\right)\n    $$\n    代入 $R(s) = \\lambda \\lVert s \\rVert_1 + I_+(s)$，我们得到：\n    $$\n    \\text{prox}_{\\gamma R}(v) = \\underset{s \\ge 0}{\\text{argmin}} \\left( \\frac{1}{2} \\lVert s - v \\rVert_2^2 + \\gamma \\lambda \\lVert s \\rVert_1 \\right)\n    $$\n    这个问题是可分的，可以对每个分量 $s_i$ 独立求解：\n    $$\n    \\underset{s_i \\ge 0}{\\text{argmin}} \\left( \\frac{1}{2} (s_i - v_i)^2 + \\gamma \\lambda s_i \\right)\n    $$\n    目标函数是关于 $s_i$ 的抛物线，其最小值在 $s_i = v_i - \\gamma \\lambda$ 处。由于我们有约束 $s_i \\ge 0$，解可以通过将这个最小值投影到非负半轴上找到。如果 $v_i - \\gamma \\lambda > 0$，最小值位于 $s_i = v_i - \\gamma \\lambda$。如果 $v_i - \\gamma \\lambda \\le 0$，目标函数对于所有 $s_i \\ge 0$ 都是递增的，因此最小值出现在边界 $s_i = 0$ 处。这可以紧凑地写为：\n    $$\n    s_i = \\max(0, v_i - \\gamma \\lambda)\n    $$\n    这个操作等价于软阈值处理，然后投影到非负象限上。\n\n有了这些组件，FISTA 算法的实现如下：\n\n**算法：快速迭代收缩阈值算法 (FISTA)**\n\n1.  **初始化**：\n    - 迭代计数器 $k=1$。\n    - 脉冲估计 $s^{(0)} = \\mathbf{0}$，$s^{(-1)} = \\mathbf{0}$。\n    - 辅助序列 $z^{(1)} = s^{(0)}$。\n    - 动量序列 $t_1 = 1$。\n    - 步长 $\\gamma = 1/K = 1/\\sigma_{\\max}(G)^2$。\n\n2.  **迭代循环 (对 $k=1, 2, \\dots$)**：\n    a. 计算在辅助点 $z^{(k)}$ 处的梯度：$\\nabla_k = G^\\top(G z^{(k)} - y)$。\n    b. 执行梯度步：$v^{(k)} = z^{(k)} - \\gamma \\nabla_k$。\n    c. 应用邻近算子找到下一个脉冲估计 $s^{(k)}$：对于每个分量 $i$，$s^{(k)}_i = \\max(0, v^{(k)}_i - \\gamma \\lambda)$。\n    d. 检查收敛性：如果 $\\lVert s^{(k)} - s^{(k-1)} \\rVert_2 / \\max(1, \\lVert s^{(k-1)} \\rVert_2) \\le \\tau$，则停止。\n    e. 更新动量项：$t_{k+1} = \\frac{1 + \\sqrt{1 + 4 t_k^2}}{2}$。\n    f. 更新下一次迭代的辅助序列：$z^{(k+1)} = s^{(k)} + \\frac{t_k - 1}{t_{k+1}}(s^{(k)} - s^{(k-1)})$。\n    g. 设置 $s^{(k-1)} \\leftarrow s^{(k)}$，$t_k \\leftarrow t_{k+1}$，并增加 $k$。\n\n3.  **输出**：最终估计值 $\\hat{s} = s^{(k)}$。\n\n该算法为每个测试用例实现。卷积矩阵 $G$ 根据其作为下三角托普利茲矩阵的定义来构建。利普希茨常数 $K$ 通过找到 $G$ 的最大奇异值来计算。然后求解器运行直到满足指定的容差 $\\tau$。最后，计算估计的脉冲序列 $\\hat{s}$ 与真实值 $s_{\\mathrm{true}}$ 之间的平均绝对误差（MAE）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import toeplitz, svd\n\ndef fista_solver(G, y, lam, tau, K):\n    \"\"\"\n    Solves the non-negative LASSO problem using FISTA.\n\n    min_s 0.5 * ||Gs - y||_2^2 + lam * ||s||_1  subject to s >= 0.\n\n    Args:\n        G (np.ndarray): The forward model matrix.\n        y (np.ndarray): The observed data vector.\n        lam (float): The regularization parameter.\n        tau (float): The convergence tolerance.\n        K (float): The Lipschitz constant of the gradient of the smooth term.\n\n    Returns:\n        np.ndarray: The estimated spike train s_hat.\n    \"\"\"\n    T = G.shape[0]\n    \n    # Initialization\n    s_prev = np.zeros(T)\n    z = np.zeros(T)\n    t_prev = 1.0\n\n    # Pre-compute G transpose for efficiency\n    GT = G.T\n    \n    # Fixed step size\n    step_size = 1.0 / K\n    \n    # Set a maximum number of iterations as a safeguard\n    max_iter = 200000 \n    \n    for _ in range(max_iter):\n        # Compute gradient at the auxiliary point z\n        grad_z = GT @ (G @ z - y)\n        \n        # Perform gradient descent step from z\n        v = z - step_size * grad_z\n        \n        # Apply proximal operator to get the current estimate s_curr\n        s_curr = np.maximum(0, v - step_size * lam)\n        \n        # Check for convergence using the specified criterion\n        norm_s_prev = np.linalg.norm(s_prev)\n        rel_diff = np.linalg.norm(s_curr - s_prev) / max(1.0, norm_s_prev)\n        \n        if rel_diff = tau:\n            break\n            \n        # Nesterov acceleration update\n        t_curr = (1.0 + np.sqrt(1.0 + 4.0 * t_prev**2)) / 2.0\n        z = s_curr + ((t_prev - 1.0) / t_curr) * (s_curr - s_prev)\n        \n        # Update variables for the next iteration\n        s_prev = s_curr\n        t_prev = t_curr\n        \n    return s_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    \n    # --- Test Case A: Happy path, exact model match ---\n    T_A = 60\n    alpha_A = 0.95\n    lambda_A = 0.001\n    tau_A = 1e-9\n    s_true_A = np.zeros(T_A)\n    s_true_A[5] = 1.0\n    s_true_A[20] = 0.5\n    s_true_A[40] = 1.5\n    epsilon_A = np.zeros(T_A)\n    \n    # --- Test Case B: Burst with structured disturbance ---\n    T_B = 80\n    alpha_B = 0.9\n    lambda_B = 0.1\n    tau_B = 1e-9\n    s_true_B = np.zeros(T_B)\n    s_true_B[10:13] = 0.3\n    t_vals_B = np.arange(T_B)\n    epsilon_B = 0.02 * np.cos(2 * np.pi * t_vals_B / 11)\n    \n    # --- Test Case C: No spikes, strong regularization, tiny disturbance ---\n    T_C = 50\n    alpha_C = 0.98\n    lambda_C = 0.2\n    tau_C = 1e-9\n    s_true_C = np.zeros(T_C)\n    t_vals_C = np.arange(T_C)\n    epsilon_C = 0.001 * (np.sin(2 * np.pi * t_vals_C / 7) + 0.5 * np.sin(2 * np.pi * t_vals_C / 3))\n    \n    test_cases = [\n        (T_A, alpha_A, lambda_A, tau_A, s_true_A, epsilon_A),\n        (T_B, alpha_B, lambda_B, tau_B, s_true_B, epsilon_B),\n        (T_C, alpha_C, lambda_C, tau_C, s_true_C, epsilon_C)\n    ]\n    \n    results = []\n    \n    for T, alpha, lam, tau, s_true, epsilon in test_cases:\n        # 1. Construct the convolution matrix G\n        g_first_col = alpha**np.arange(T)\n        g_first_row = np.zeros(T)\n        g_first_row[0] = 1.0\n        G = toeplitz(g_first_col, g_first_row)\n        \n        # 2. Compute the Lipschitz constant K\n        singular_values = svd(G, compute_uv=False)\n        K = singular_values[0]**2\n        \n        # 3. Construct the observed fluorescence y\n        y = G @ s_true + epsilon\n        \n        # 4. Run the solver to obtain the spike estimate s_hat\n        s_hat = fista_solver(G, y, lam, tau, K)\n        \n        # 5. Compute the Mean Absolute Error (MAE)\n        mae = np.mean(np.abs(s_hat - s_true))\n        results.append(f\"{mae:.6f}\")\n        \n    # Print the final results in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在基础去卷积框架之上，这个实践将探索如何将更符合生物学现实的约束整合到我们的模型中 。你将构建一个最大后验 (MAP) 估计问题，其中包含神经元不应期和簇状放电活动的先验知识。核心任务是实现一个动态规划算法，该算法利用问题结构来精确找到最优的尖峰序列，为处理涉及复杂结构化先验的推断问题提供了一个强大的工具。",
            "id": "4154477",
            "problem": "给定一个一维时间序列，它代表一个由脉冲诱发的钙瞬变产生的荧光钙信号，该信号由一个线性动力学系统建模。生成模型在离散时间样本上定义，具有固定的采样间隔（秒）和已知的参数。任务是，在一个不应期约束和一个簇发先验下，计算一个受约束的脉冲序列的最大后验 (MAP) 估计，并为多个指定的测试案例输出脉冲样本索引的集合。\n\n基本模型和数据模型：\n- 令 $t \\in \\{0,1,\\dots,T-1\\}$ 表示由采样间隔 $\\Delta t$（秒）分隔的离散时间样本。\n- 令 $s_t$ 表示在样本 $t$ 处的脉冲序列。在此问题中，$s_t$ 被约束为 $0$ 或一个固定的振幅 $a  0$。\n- 钙动力学被建模为一个线性系统，其冲激响应核为 $h_k = \\alpha \\gamma^k$，其中 $k \\in \\{0,1,\\dots,K-1\\}$，$\\alpha  0$ 是每个脉冲的瞬时钙增量，$\\gamma \\in (0,1)$ 是由钙衰减时间常数 $\\tau_c$ 导出的离散时间衰减因子，通过 $\\gamma = \\exp(-\\Delta t / \\tau_c)$ 计算。\n- 预测的荧光是离散卷积 $(h * s)_t = \\sum_{k=0}^{K-1} h_k s_{t-k}$，其中小于 $0$ 的索引被视为零。\n- 观测到的荧光 $y_t$ 被建模为 $y_t = (h * s)_t + \\varepsilon_t$，其中 $\\varepsilon_t$ 是独立的、均值为零、方差为 $\\sigma^2$ 的高斯噪声样本。\n\n带有不应期约束和簇发偏好的结构化先验：\n- 在任意两个簇发的开始之间强制执行一个 $r$ 个样本的不应期，且 $r \\ge K$，确保来自不同簇发的冲激响应的支撑集在时间上不重叠。\n- 脉冲序列 $s_t$ 被限制为簇发的并集，其中一个簇发定义为长度为 $L \\in \\{L_{\\min}, \\dots, L_{\\max}\\}$、振幅为 $a$ 的连续脉冲样本块。在一个簇发内，在簇发区间上 $s_t = a$，在区间外 $s_t = 0$。\n- 负对数先验成本定义为 $\\lambda \\sum_t \\mathbf{1}[s_t = a] - \\rho \\sum_t \\mathbf{1}[s_t = a, s_{t+1} = a]$，其中 $\\lambda \\ge 0$ 惩罚脉冲样本的总数，而 $\\rho \\ge 0$ 为相邻的脉冲对提供折扣，以偏好更长的连续簇发。\n\nMAP 目标函数：\n- 给定 $y_t$，MAP 估计最小化目标函数\n$$\nJ(s) = \\frac{1}{2 \\sigma^2} \\sum_{t=0}^{T-1} \\left( y_t - (h * s)_t \\right)^2 \\;+\\; \\lambda \\sum_{t=0}^{T-1} \\mathbf{1}[s_t=a] \\;-\\; \\rho \\sum_{t=0}^{T-2} \\mathbf{1}[s_t=a, s_{t+1}=a],\n$$\n在上述不应期约束和簇发结构，以及 $s_t \\in \\{0,a\\}$ 的条件下。\n\n算法要求：\n- 因为 $r \\ge K$，不同簇发对似然函数的贡献在时间上不重叠。您必须实现一个沿时间线的精确动态规划，在每个位置 $t$，该规划要么选择一个从 $t$ 开始的、长度为 $L \\in [L_{\\min}, L_{\\max}]$ 的簇发，要么选择一个单样本间隙（在 $t$ 处没有脉冲），累积相应的似然成本和先验成本，并相应地推进时间索引。当选择一个簇发时，下一个可能的簇发开始索引是 $t + L + r$。当选择一个间隙时，下一个索引是 $t + 1$。从 $t$ 开始、长度为 $L$ 的簇发的似然成本是在其长度为 $W = \\min(L + K - 1, T - t)$ 的覆盖窗口上计算的，即 $y_t$ 与该簇发的预测卷积之间的残差平方和。您还必须加上从覆盖窗口结束到不应期所施加的下一个允许开始时间之间的任何间隙样本的纯噪声成本。使用按 $\\frac{1}{2 \\sigma^2}$ 缩放的高斯负对数似然。\n\n输出规范：\n- 对于每个测试案例，输出估计的脉冲样本索引，形式为一个按升序排列的整数列表，其中每个整数是一个样本索引 $t$，使得在 MAP 解中 $s_t = a$。将所有测试案例的结果合并到单行输出中，该输出包含用方括号括起来的逗号分隔列表形式的结果。例如，一个有效的输出格式是 \"[[i_1,i_2,...],[j_1,j_2,...],...]\"。所有索引都是样本索引（无量纲整数）。最终答案中不需要进行物理单位转换。\n\n测试套件：\n您必须实现您的程序来解决以下四个测试案例。在每个案例中，您必须：\n1. 使用提供的 $K$ 构建核 $h_k = \\alpha \\gamma^k$。\n2. 通过从指定的真实簇发生成 $s_t$，并与 $h_k$ 进行卷积，然后添加标准差为 $\\sigma$ 的独立高斯噪声来模拟 $y_t$。\n3. 使用给定的参数运行动态规划，以计算 MAP 估计并报告脉冲样本索引。\n\n测试案例 1 (理想路径):\n- $T = 80$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.7$ 秒，$\\alpha = 1.0$， $K = 12$， $a = 0.8$， $\\sigma = 0.05$，不应期 $r = 12$， $\\lambda = 0.2$， $\\rho = 0.1$， $L_{\\min} = 2$， $L_{\\max} = 6$。\n- 真实簇发：起始和长度 $(10,3)$, $(35,4)$, $(60,2)$。\n\n测试案例 2 (无先验影响):\n- $T = 80$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.7$ 秒，$\\alpha = 1.0$， $K = 12$， $a = 0.8$， $\\sigma = 0.08$，不应期 $r = 12$， $\\lambda = 0.0$， $\\rho = 0.0$， $L_{\\min} = 1$， $L_{\\max} = 5$。\n- 真实簇发：$(20,2)$, $(50,3)$。\n\n测试案例 3 (簇发先验占主导):\n- $T = 100$，$\\Delta t = 0.1$ 秒，$\\tau_c = 1.0$ 秒，$\\alpha = 1.0$， $K = 10$， $a = 0.7$， $\\sigma = 0.06$，不应期 $r = 10$， $\\lambda = 0.5$， $\\rho = 0.45$， $L_{\\min} = 1$， $L_{\\max} = 8$。\n- 真实簇发：$(15,6)$, $(40,1)$, $(70,5)$。\n\n测试案例 4 (边界与更高噪声):\n- $T = 30$，$\\Delta t = 0.1$ 秒，$\\tau_c = 0.5$ 秒，$\\alpha = 1.0$， $K = 8$， $a = 0.9$， $\\sigma = 0.15$，不应期 $r = 8$， $\\lambda = 0.15$， $\\rho = 0.05$， $L_{\\min} = 1$, $L_{\\max} = 4$。\n- 真实簇发：$(5,3)$。\n\n角度单位不适用。所有与时间相关的量在内部以样本为单位表示；最终输出是作为整数的样本索引。您的程序应生成单行输出，其中包含按上述确切格式、用方括号括起来的逗号分隔列表形式的结果。",
            "solution": "该问题要求从带噪的荧光钙信号中计算脉冲序列的最大后验 (MAP) 估计。其底层模型是一个线性动力学系统，其中信号是脉冲序列与指数衰减核的卷积，并受到加性高斯噪声的干扰。脉冲序列被构造成具有特定长度的簇发，并在簇发之间强制执行不应期。MAP 目标函数结合了一个高斯似然项和一个结构化先验，该先验惩罚脉冲的总数，但奖励形成簇发的连续脉冲。\n\n首先，我们验证问题陈述。模型和优化的所有参数都为四个测试案例明确提供。该模型本身基于线性系统理论和贝叶斯估计 (MAP)，在计算神经科学中是标准的。使用动态规划的算法要求是定义明确且可行的，这得益于一个关键约束，即不应期 $r$ 不短于核长度 $K$ ($r \\ge K$)。这个约束确保了从不同推断簇发产生的钙瞬变在时间上不重叠，使得似然项在对应于每个簇发及其间间隙的不相交时间区间上是可分的。该问题具有科学依据、自成体系且适定。因此，该问题被认为是有效的。\n\n解决方案通过实现一个精确的动态规划 (DP) 算法来推进。令 $V(t)$ 为在时间区间 $[t, T-1]$ 上观测信号 $y$ 的最小成本（负对数后验），其中 $T$ 是总样本数。我们的目标是找到对应于 $V(0)$ 的脉冲序列。我们可以通过从时间 $t = T-1$ 向后递推至 $0$ 来递归计算 $V(t)$。基本情况是对于所有 $t \\ge T$，$V(t) = 0$。\n\n对于任何时间 $t  T$，我们有两种选择：\n1.  **在 $t$ 时刻没有脉冲簇发开始**。这对应于一个单样本间隙。在这种情况下，我们假设脉冲值 $s_t=0$。在 $t$ 时刻的预测信号为 $0$。产生的成本是在信号为 $0$ 的条件下观测到 $y_t$ 的负对数似然，即 $\\frac{1}{2\\sigma^2} y_t^2$。此选择的总成本是这个单样本成本加上信号其余部分的最小成本 $V(t+1)$。\n    $$V_{\\text{gap}}(t) = \\frac{1}{2\\sigma^2} y_t^2 + V(t+1)$$\n\n2.  **一个长度为 $L$ 的簇发从 $t$ 开始**，其中 $L \\in [L_{\\min}, L_{\\max}]$。为了使此选择有效，簇发必须在时间序列内结束，即 $t+L \\le T$。此选择的总成本是三个部分的和：\n    a.  **先验成本**：一个长度为 $L$、振幅为 $a$ 的簇发的先验项是 $\\lambda \\sum \\mathbf{1}[s_t=a] - \\rho \\sum \\mathbf{1}[s_t=a, s_{t+1}=a]$。这计算为 $\\lambda L - \\rho(L-1)$。\n    b.  **似然成本**：由于 $r \\ge K$ 条件，成本是可分的。\n        i.   *与簇发相关的成本*：我们计算观测信号 $y_t$ 与这个单一簇发在其完整“覆盖窗口”内的预测信号之间的残差平方和。一个从 $t$ 开始、长度为 $L$ 的簇发的影响持续到时间 $t+L+K-2$。令 $W = \\min(L+K-1, T-t)$ 为此窗口的有效长度。成本是 $\\frac{1}{2\\sigma^2} \\sum_{k=0}^{W-1} (y_{t+k} - c_{t+k}^{\\text{burst}})^2$，其中 $c^{\\text{burst}}$ 是单个簇发与核 $h$ 的卷积。\n        ii.  *不应期间隙成本*：不应期 $r$ 强制在簇发后有一个零值的间隙。下一个可能的簇发只能在 $t' = t+L+r$ 开始。当前簇发覆盖窗口结束与下一个决策点开始之间的时间区间包含被约束为没有脉冲的样本。这个强制间隙的成本是纯噪声似然：$\\frac{1}{2\\sigma^2} \\sum_{k=t+W}^{t'-1} y_k^2$。\n    c.  **未来成本**：从下一个决策点 $t' = t+L+r$ 开始的信号剩余部分最优解的成本，即 $V(t' = t+L+r)$。\n\nDP的递推关系是：\n$$V(t) = \\min \\left( V_{\\text{gap}}(t), \\min_{L \\in [L_{\\min}, L_{\\max}], t+L \\le T} V_{\\text{burst}}(t, L) \\right)$$\n其中 $V_{\\text{burst}}(t, L)$ 封装了描述的从 $t$ 开始、长度为 $L$ 的簇发的三个成本组成部分。\n\n为了高效地实现这一点，我们首先如所述为每个测试案例模拟带噪信号 $y_t$。然后，对于DP，我们预计算辅助量：核 $h_k=\\alpha\\gamma^k$、缩放后的信号平方 $\\frac{1}{2\\sigma^2} y_t^2$、其用于快速计算间隙成本的累积和，以及对于每种可能的长度 $L$ 的簇发的预测荧光信号。然后我们填充一个DP表来存储成本 $V(t)$ 和另一个表来存储每个 $t$ 的最优选择（间隙或簇发长度 $L$）。\n\n在从 $t=T-1$ 向下填充到 $0$ 后，我们从 $t=0$ 开始执行一个回溯过程。我们跟随存储的最优选择来重建簇发序列。如果时间 $t$ 的选择是长度为 $L$ 的簇发，我们将索引 $[t, t+1, \\dots, t+L-1]$ 添加到我们的解集中，并跳转到下一个决策点 $t' = t+L+r$。如果选择是间隙，我们简单地前进到 $t+1$。这个过程产生了解码出的脉冲索引的最终集合。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    # Use a fixed seed for the random number generator to ensure that the\n    # simulated noisy calcium traces are reproducible.\n    np.random.seed(0)\n\n    # Define test cases as a list of dictionaries.\n    test_cases = [\n        {\n            \"T\": 80, \"dt\": 0.1, \"tau_c\": 0.7, \"alpha\": 1.0, \"K\": 12, \"a\": 0.8,\n            \"sigma\": 0.05, \"r\": 12, \"lam\": 0.2, \"rho\": 0.1, \"L_min\": 2, \"L_max\": 6,\n            \"ground_truth_bursts\": [(10, 3), (35, 4), (60, 2)]\n        },\n        {\n            \"T\": 80, \"dt\": 0.1, \"tau_c\": 0.7, \"alpha\": 1.0, \"K\": 12, \"a\": 0.8,\n            \"sigma\": 0.08, \"r\": 12, \"lam\": 0.0, \"rho\": 0.0, \"L_min\": 1, \"L_max\": 5,\n            \"ground_truth_bursts\": [(20, 2), (50, 3)]\n        },\n        {\n            \"T\": 100, \"dt\": 0.1, \"tau_c\": 1.0, \"alpha\": 1.0, \"K\": 10, \"a\": 0.7,\n            \"sigma\": 0.06, \"r\": 10, \"lam\": 0.5, \"rho\": 0.45, \"L_min\": 1, \"L_max\": 8,\n            \"ground_truth_bursts\": [(15, 6), (40, 1), (70, 5)]\n        },\n        {\n            \"T\": 30, \"dt\": 0.1, \"tau_c\": 0.5, \"alpha\": 1.0, \"K\": 8, \"a\": 0.9,\n            \"sigma\": 0.15, \"r\": 8, \"lam\": 0.15, \"rho\": 0.05, \"L_min\": 1, \"L_max\": 4,\n            \"ground_truth_bursts\": [(5, 3)]\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        spikes = run_deconvolution_case(params)\n        all_results.append(spikes)\n\n    # Format the final output string as specified: [[i_1,i_2,...],[j_1,j_2,...],...]\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\ndef simulate_signal(T, dt, tau_c, alpha, K, a, sigma, ground_truth_bursts):\n    \"\"\"\n    Generates a noisy calcium signal based on the generative model.\n    \"\"\"\n    # Construct spike train s_t from ground-truth bursts\n    s = np.zeros(T)\n    for start, length in ground_truth_bursts:\n        if start + length = T:\n            s[start:start + length] = a\n\n    # Construct impulse response kernel h_k\n    gamma = np.exp(-dt / tau_c)\n    k = np.arange(K)\n    h = alpha * (gamma ** k)\n\n    # Compute clean fluorescence signal by convolution\n    c = np.convolve(h, s)[:T]\n\n    # Generate and add Gaussian noise\n    noise = np.random.normal(0, sigma, T)\n    y = c + noise\n    return y\n\ndef run_deconvolution_case(params):\n    \"\"\"\n    Solves the MAP estimation problem for a single test case.\n    \"\"\"\n    # Unpack parameters\n    T = params[\"T\"]; dt = params[\"dt\"]; tau_c = params[\"tau_c\"]; alpha = params[\"alpha\"]\n    K = params[\"K\"]; a = params[\"a\"]; sigma = params[\"sigma\"]; r = params[\"r\"]\n    lam = params[\"lam\"]; rho = params[\"rho\"]; L_min = params[\"L_min\"]; L_max = params[\"L_max\"]\n    ground_truth_bursts = params[\"ground_truth_bursts\"]\n\n    # 1. Simulate the observed fluorescence signal y_t\n    y = simulate_signal(T, dt, tau_c, alpha, K, a, sigma, ground_truth_bursts)\n\n    # 2. Pre-computation for the dynamic programming algorithm\n    gamma = np.exp(-dt / tau_c)\n    k = np.arange(K)\n    h = alpha * (gamma ** k)\n    cost_scale = 1.0 / (2.0 * sigma**2)\n    y_sq_cumsum = np.zeros(T + 1)\n    y_sq_cumsum[1:] = np.cumsum(y**2)\n\n    burst_responses = {}\n    for L in range(L_min, L_max + 1):\n        s_burst = np.zeros(L + K - 1)\n        s_burst[:L] = a\n        burst_responses[L] = np.convolve(h, s_burst)[:L + K - 1]\n\n    # 3. Dynamic Programming to find the MAP estimate\n    dp_cost = np.full(T + 1, np.inf)\n    dp_choices = np.zeros(T, dtype=int)\n    dp_cost[T] = 0.0\n\n    for t in range(T - 1, -1, -1):\n        # Option 1: Place a gap (no spike) at time t\n        cost_gap = cost_scale * y[t]**2 + dp_cost[t + 1]\n        min_cost = cost_gap\n        best_choice = 0\n\n        # Option 2: Place a burst of length L starting at time t\n        for L in range(L_min, L_max + 1):\n            if t + L > T:\n                continue\n\n            prior_cost = lam * L - (rho * (L - 1) if L > 1 else 0)\n\n            c_burst = burst_responses[L]\n            W = min(L + K - 1, T - t)\n            y_window = y[t : t + W]\n            c_window = c_burst[:W]\n            ll_burst = cost_scale * np.sum((y_window - c_window)**2)\n\n            t_next = t + L + r\n            \n            gap_start_idx = t + W\n            gap_end_idx = min(t_next, T)\n            ll_refractory_gap = 0.0\n            if gap_start_idx  gap_end_idx:\n                ll_refractory_gap = cost_scale * (y_sq_cumsum[gap_end_idx] - y_sq_cumsum[gap_start_idx])\n            \n            future_cost = dp_cost[min(t_next, T)]\n            cost_burst = prior_cost + ll_burst + ll_refractory_gap + future_cost\n\n            if cost_burst  min_cost:\n                min_cost = cost_burst\n                best_choice = L\n        \n        dp_cost[t] = min_cost\n        dp_choices[t] = best_choice\n\n    # 4. Backtracking to reconstruct the optimal spike train\n    spike_indices = []\n    current_t = 0\n    while current_t  T:\n        choice = dp_choices[current_t]\n        if choice == 0:  # Gap\n            current_t += 1\n        else:  # Burst of length L = choice\n            L = choice\n            spike_indices.extend(range(current_t, current_t + L))\n            current_t += L + r\n    \n    return spike_indices\n\nsolve()\n```"
        },
        {
            "introduction": "我们的最后一个实践解决了一个钙成像中的关键挑战：如何克服相机帧率造成的时间限制，以实现“超分辨率”的尖峰计时 。这个练习将指导你推导出一个精确的正向模型，该模型将连续时间中的高分辨率尖峰序列映射到离散的、帧平均的荧光测量值。通过对这个精确模型进行反演，你将实现一个完整的流程，以比成像帧本身更高的分辨率估计尖峰时间，这是基于模型的信号处理的一个强有力例证。",
            "id": "4154469",
            "problem": "给定一个由神经元脉冲驱动的钙荧光连续时间生成模型和一个帧平均测量过程。潜在的细胞内钙离子浓度由以下线性时不变常微分方程建模：\n$$\n\\frac{d c(t)}{d t} = -\\frac{1}{\\tau} c(t) + \\alpha\\, s(t),\n$$\n其中 $c(t)$ 是钙离子浓度，$s(t)$ 是脉冲序列，建模为在未知脉冲时刻的一系列狄拉克脉冲之和，$\\tau$ 是钙衰减时间常数，$\\alpha$ 是每次脉冲发生时 $c(t)$ 的瞬时跳变幅度。成像系统在持续时间为 $\\Delta$ 秒的帧上对 $c(t)$ 进行积分，并返回帧平均荧光：\n$$\ny_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} c(t) \\, dt + \\eta_k,\n$$\n对于帧索引 $k \\in \\{0,1,\\dots, K-1\\}$，其中附加了零均值高斯噪声 $\\eta_k$，其已知标准差为 $\\sigma$。\n\n您的任务是通过假设一个均匀的子帧网格来实现帧内的时间超分辨率，该网格每帧有 $R$ 个子区间，子区间的持续时间为 $\\delta = \\Delta / R$。设总帧数为 $K$，则总子区间数为 $N = K R$，并定义子区间时间 $t_n = n \\delta$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。假设脉冲发生在此子区间网格上。从上述钙动力学微分方程和帧平均测量定义出发，通过对每个帧上的脉冲响应进行解析积分，推导出将长度为 $N$ 的非负子区间脉冲向量映射到 $K$ 个帧平均荧光样本的精确线性正向算子。\n\n实现一个程序，该程序：\n- 根据模型所蕴含的解析积分精确地构建正向算子，不进行任何离散时间欧拉近似。\n- 通过将正向算子与真实的子区间脉冲向量相乘并添加具有指定 $\\sigma$ 的独立高斯噪声，为每个测试用例模拟 $y_k$。\n- 通过求解一个非负最小二乘（NNLS）问题来估计非负的子区间脉冲振幅，即在非负性约束下最小化平方误差。\n- 通过使用一个固定的阈值 $\\max(\\alpha/2, 3\\sigma)$ 对估计的子区间振幅进行阈值处理来检测脉冲时间，并仅选择子区间格点上的局部最大值以避免每次脉冲产生多次检测。通过对局部最大值周围的三点邻域拟合一个局部抛物线，并使用其顶点位置来估计一个在 $[-\\delta/2, \\delta/2]$ 内的子区间偏移量，从而精化每个检测到的脉冲时间（前提是两个邻居都存在）；否则，使用子区间的中心。所有报告的脉冲时间都以秒为单位表示。\n- 为每个测试用例输出一个估计的脉冲时间列表（以秒为单位），按升序排序并四舍五入到 $4$ 位小数。\n\n物理单位和输出规范：\n- 时间必须以秒为单位表示，并四舍五入到 $4$ 位小数。\n- 荧光振幅单位是任意单位（a.u.），但只需输出脉冲时间。\n\n测试套件：\n使用以下四个科学上合理的测试用例，每个用例描述了 $(\\Delta, \\tau, \\alpha, R, K, \\sigma)$ 和以秒为单位的真实脉冲时间。所有给定的脉冲时间都位于相应的子区间网格上。\n\n- 用例 $1$（理想情况）：$\\Delta = 0.1$ 秒, $\\tau = 0.8$ 秒, $\\alpha = 1.0$ a.u., $R = 5$, $K = 25$, $\\sigma = 0.02$ a.u., 真实脉冲位于 $[1.22]$ 秒。\n- 用例 $2$（帧边缘的边界条件）：$\\Delta = 0.1$ 秒, $\\tau = 1.0$ 秒, $\\alpha = 1.0$ a.u., $R = 8$, $K = 20$, $\\sigma = 0.05$ a.u., 真实脉冲位于 $[1.0]$ 秒。\n- 用例 $3$（一帧内有两个脉冲）：$\\Delta = 0.1$ 秒, $\\tau = 0.5$ 秒, $\\alpha = 1.0$ a.u., $R = 10$, $K = 15$, $\\sigma = 0.01$ a.u., 真实脉冲位于 $[0.62, 0.66]$ 秒。\n- 用例 $4$（无脉冲，仅噪声的边缘情况）：$\\Delta = 0.1$ 秒, $\\tau = 1.2$ 秒, $\\alpha = 1.0$ a.u., $R = 5$, $K = 10$, $\\sigma = 0.03$ a.u., 真实脉冲位于 $[]$ 秒（空列表）。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个元素是对应测试用例的脉冲时间列表（以秒为单位），四舍五入到 $4$ 位小数，例如 `[[0.6200,0.6600],[1.0000],[1.2200],[]]`。输出中测试用例的顺序必须与上面列出的顺序相匹配。",
            "solution": "该问题要求推导并实现一种反卷积算法，以从帧平均的钙荧光数据中估计神经元脉冲时间。该过程首先对问题陈述进行正式验证，然后详细推导正向模型，并描述逆问题和脉冲检测算法。\n\n### 问题验证\n\n**第1步：提取的已知条件**\n-   **钙动力学模型：** 细胞内钙离子浓度 $c(t)$ 由以下线性常微分方程（ODE）控制：\n    $$ \\frac{d c(t)}{d t} = -\\frac{1}{\\tau} c(t) + \\alpha\\, s(t) $$\n    其中 $\\tau$ 是钙衰减时间常数，$\\alpha$ 是每次脉冲的浓度跳变，而 $s(t)$ 是脉冲序列，建模为狄拉克δ函数的和。\n-   **测量模型：** 第 $k$ 帧的测量荧光 $y_k$ 是 $c(t)$ 在帧持续时间 $\\Delta$ 上的时间平均，并带有附加的高斯噪声 $\\eta_k$：\n    $$ y_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} c(t) \\, dt + \\eta_k $$\n    其中 $k \\in \\{0, 1, \\dots, K-1\\}$ 且 $\\eta_k \\sim \\mathcal{N}(0, \\sigma^2)$。\n-   **离散化方案：** 假设脉冲发生在一个均匀的子帧网格上，每帧有 $R$ 个区间。子区间的持续时间为 $\\delta = \\Delta / R$，总子区间数为 $N = K R$。脉冲序列由该网格上的一个非负振幅向量表示。\n-   **任务：** 目标是推导将子区间脉冲向量映射到荧光样本的精确线性算子，模拟数据，然后使用非负最小二乘法（NNLS）对模型进行逆运算以估计脉冲时间，随后进行阈值处理、局部最大值查找和抛物线时间精化。\n-   **脉冲检测标准：**\n    -   阈值：在估计的脉冲振幅上应用 $\\max(\\alpha/2, 3\\sigma)$。\n    -   峰值查找：仅选择局部最大值。\n    -   精化：对峰值的3点邻域拟合抛物线，以找到子区间内的时间偏移。\n-   **测试用例：** 提供了四个特定的参数集 $(\\Delta, \\tau, \\alpha, R, K, \\sigma)$ 和相应的真实脉冲时间。\n\n**第2步：使用提取的已知条件进行验证**\n根据验证标准评估问题陈述：\n1.  **科学基础：** 该模型是计算神经科学中对钙动力学和荧光成像的标准且被广泛接受的表示。所有原理在科学上都是合理的。\n2.  **适定性：** 该问题的结构使其具有唯一且稳定的解。正向模型的推导是一个直接的解析任务。逆问题被构建为一个凸优化问题（NNLS），该问题有唯一解。后续处理步骤是确定性的。\n3.  **客观性：** 问题以精确的数学形式和客观、可量化的任务进行了规定。\n4.  **不完整或矛盾的设置：** 提供了所有必要的参数和模型定义。测试用例数据（例如，网格上的脉冲时间）与模型的假设一致。\n5.  **不切实际或不可行：** 指定的参数和要求的计算是现实且计算上可行的。\n6.  **病态或结构不良：** 问题结构良好，从理论到实现提供了指引。\n7.  **伪深刻、琐碎或同义反复：** 该问题涉及一个不平凡的解析推导和标准、实质性数据分析流程的实现。它既不琐碎也不做作。\n8.  **相关性和可验证性：** 该问题与指定主题直接相关，其解决方案在数学上和计算上都是可验证的。\n\n**第3步：结论与行动**\n该问题在所有标准上均被视为**有效**。我将继续进行推导和求解。\n\n### 正向算子的推导\n\n目标是构建一个线性算子（一个矩阵）$A$，它根据模型 $\\mathbf{y} = A\\mathbf{s} + \\boldsymbol{\\eta}$，将脉冲振幅的离散向量 $\\mathbf{s}$ 映射到帧平均荧光测量的向量 $\\mathbf{y}$。\n\n**1. 脉冲响应函数**\n首先，我们求解在时间 $t_j = j\\delta$ 发生单个脉冲时的ODE，该脉冲由输入 $\\alpha \\delta(t-t_j)$ 表示。方程为：\n$$ \\frac{d c(t)}{d t} + \\frac{1}{\\tau} c(t) = \\alpha \\, \\delta(t-t_j) $$\n假设系统在 $t  t_j$ 时处于静止状态（即 $c(t)=0$），对于 $t \\ge t_j$ 的解是一个因果指数衰减。狄拉克δ输入导致 $c(t)$ 在 $t=t_j$ 时从 $0$ 瞬时跳变到 $\\alpha$。对于 $tt_j$，方程是齐次的，$\\frac{dc}{dt} = -\\frac{c}{\\tau}$，初始条件为 $c(t_j^+) = \\alpha$。解为：\n$$ c(t) = \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\quad \\text{for } t \\ge t_j $$\n我们可以将对在 $t_j$ 时刻脉冲的完整响应（也称为脉冲响应）写为：\n$$ h(t; t_j) = \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) $$\n其中 $U(\\cdot)$ 是亥维赛阶跃函数。\n\n**2. 脉冲序列的钙离子浓度**\n根据线性叠加原理，由在离散时间 $t_j = j\\delta$ 处具有振幅 $s_j$ 的脉冲序列产生的钙离子浓度 $c(t)$ 是各个响应的总和：\n$$ c(t) = \\sum_{j=0}^{N-1} s_j h(t; t_j) = \\sum_{j=0}^{N-1} s_j \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) $$\n\n**3. 帧平均荧光测量**\n测量值 $y_k$ 是 $c(t)$ 在第 $k$ 帧（从 $T_k^{\\text{start}} = k\\Delta$ 到 $T_k^{\\text{end}} = (k+1)\\Delta$）上的积分，并由帧持续时间 $\\Delta$ 归一化。代入 $c(t)$ 的表达式并暂时忽略噪声项：\n$$ y_k = \\frac{1}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\left( \\sum_{j=0}^{N-1} s_j \\alpha \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) \\right) dt $$\n我们可以交换求和与积分的顺序：\n$$ y_k = \\sum_{j=0}^{N-1} s_j \\left[ \\frac{\\alpha}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) dt \\right] $$\n这个方程的形式是 $y_k = \\sum_{j=0}^{N-1} A_{kj} s_j$，其中 $A_{kj}$ 是正向算子矩阵 $A$ 的第 $k$ 行和第 $j$ 列的元素。\n\n**4. 矩阵元素 $A_{kj}$ 的解析计算**\n矩阵元素 $A_{kj}$ 表示子区间 $j$ 中单位振幅脉冲对第 $k$ 帧平均荧光的贡献。\n$$ A_{kj} = \\frac{\\alpha}{\\Delta} \\int_{k\\Delta}^{(k+1)\\Delta} \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) U(t-t_j) dt $$\n亥维赛函数 $U(t-t_j)$ 使得被积函数仅在 $t \\ge t_j$ 时非零。因此，积分的有效下限是 $\\max(k\\Delta, t_j)$。只有当 $\\max(k\\Delta, t_j)  (k+1)\\Delta$ 时，积分才非零。这意味着 $t_j  (k+1)\\Delta$。\n\n我们来计算不定积分：\n$$ \\int \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) dt = -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) + C $$\n现在我们根据脉冲（$t_j$）和帧区间 $[k\\Delta, (k+1)\\Delta]$ 的相对时间考虑三种情况：\n\n情况1：脉冲发生在帧开始之前（$t_j  k\\Delta$）。\n积分区间是 $[k\\Delta, (k+1)\\Delta]$。\n\\begin{align*} A_{kj} = \\frac{\\alpha}{\\Delta} \\left[ -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\right]_{k\\Delta}^{(k+1)\\Delta} \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left[ \\exp\\left(-\\frac{k\\Delta-t_j}{\\tau}\\right) - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right] \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\exp\\left(-\\frac{k\\Delta-t_j}{\\tau}\\right) \\left(1 - \\exp\\left(-\\frac{\\Delta}{\\tau}\\right)\\right)\\end{align*}\n\n情况2：脉冲发生在帧内部（$k\\Delta \\le t_j  (k+1)\\Delta$）。\n积分区间是 $[t_j, (k+1)\\Delta]$。\n\\begin{align*} A_{kj} = \\frac{\\alpha}{\\Delta} \\left[ -\\tau \\exp\\left(-\\frac{t-t_j}{\\tau}\\right) \\right]_{t_j}^{(k+1)\\Delta} \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left[ \\exp\\left(-\\frac{t_j-t_j}{\\tau}\\right) - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right] \\\\ = \\frac{\\alpha\\tau}{\\Delta} \\left( 1 - \\exp\\left(-\\frac{(k+1)\\Delta-t_j}{\\tau}\\right) \\right) \\end{align*}\n\n情况3：脉冲发生在帧结束之后（$t_j \\ge (k+1)\\Delta$）。\n积分区间为空。\n$$ A_{kj} = 0 $$\n\n这三种情况完整地定义了正向算子矩阵 $A$。\n\n### 逆问题与脉冲估计算法\n构建了正向算子 $A$ 后，从带噪测量值 $\\mathbf{y}$ 估计脉冲振幅 $\\mathbf{s}$ 就成了一个逆问题。\n\n1.  **非负最小二乘法（NNLS）：** 鉴于脉冲振幅必须为非负，我们求解以下约束优化问题：\n    $$ \\hat{\\mathbf{s}} = \\arg\\min_{\\mathbf{s} \\ge 0} || A\\mathbf{s} - \\mathbf{y} ||_2^2 $$\n    这是一个标准的NNLS问题，可以使用数值库高效求解。\n\n2.  **脉冲检测：** 得到的向量 $\\hat{\\mathbf{s}}$ 包含每个子区间的估计振幅。通过以下方式识别脉冲：\n    a. **阈值处理：** 选择所有估计振幅 $\\hat{s}_n$ 超过阈值 $T = \\max(\\alpha/2, 3\\sigma)$ 的子区间 $n$。\n    b. **局部最大值（非极大值抑制）：** 从经过阈值处理的区间中，仅保留那些是局部最大值的区间，即 $\\hat{s}_n  \\hat{s}_{n-1}$ 且 $\\hat{s}_n  \\hat{s}_{n+1}$（适当地处理边界条件）。这确保了估计中对应于一个真实脉冲的单个较宽的峰不会被多次检测。\n\n3.  **脉冲时间精化：** 为了在子区间内实现时间超分辨率，我们对每个检测到的脉冲的时间进行精化。对于在子区间 $n$ 的峰值，我们对三点 $(\\hat{t}_{n-1}, \\hat{s}_{n-1})$、$(\\hat{t}_{n}, \\hat{s}_{n})$ 和 $(\\hat{t}_{n+1}, \\hat{s}_{n+1})$ 拟合一个抛物线 $f(t) = at^2+bt+c$，其中 $\\hat{t}_n = n\\delta$。精化后的脉冲时间是抛物线顶点的水平坐标。与区间 $n$ 中心的偏移量 $\\Delta t$ 由下式给出：\n    $$ \\Delta t = \\frac{\\hat{s}_{n-1} - \\hat{s}_{n+1}}{2(\\hat{s}_{n-1} + \\hat{s}_{n+1} - 2\\hat{s}_n)} \\delta $$\n    精化后的脉冲时间是 $t_{\\text{refined}} = \\hat{t}_n + \\Delta t$。仅对具有两个邻居的峰值执行此精化；否则，使用子区间中心时间 $\\hat{t}_n$。算法设计至此结束。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: (Delta, tau, alpha, R, K, sigma, true_spike_times)\n        (0.1, 0.8, 1.0, 5, 25, 0.02, [1.22]),\n        # Case 2\n        (0.1, 1.0, 1.0, 8, 20, 0.05, [1.0]),\n        # Case 3\n        (0.1, 0.5, 1.0, 10, 15, 0.01, [0.62, 0.66]),\n        # Case 4\n        (0.1, 1.2, 1.0, 5, 10, 0.03, []),\n    ]\n\n    all_results = []\n    for i, case in enumerate(test_cases):\n        # Use a fixed seed for each case for reproducibility, although not strictly required\n        np.random.seed(i)\n        \n        Delta, tau, alpha, R, K, sigma, true_spike_times = case\n\n        # Derived parameters\n        delta = Delta / R\n        N = K * R  # Total number of sub-bins\n\n        # 1. Construct the forward operator A\n        A = build_forward_operator(Delta, tau, alpha, R, K, N, delta)\n\n        # 2. Build ground-truth spike vector s_true\n        s_true = np.zeros(N)\n        if true_spike_times:\n            # Note: problem statement guarantees spikes are on the grid\n            spike_indices = np.round(np.array(true_spike_times) / delta).astype(int)\n            s_true[spike_indices] = 1.0\n\n        # 3. Simulate fluorescence data y\n        y_clean = A @ s_true\n        noise = np.random.normal(0, sigma, K)\n        y = y_clean + noise\n\n        # 4. Estimate spike amplitudes s_est via NNLS\n        s_est, _ = nnls(A, y)\n\n        # 5. Detect and refine spike times\n        estimated_times = detect_and_refine_spikes(s_est, delta, N, alpha, sigma)\n        \n        # Format results to 4 decimal places\n        formatted_times = [f\"{t:.4f}\" for t in estimated_times]\n        all_results.append(f\"[{','.join(formatted_times)}]\")\n\n    # Print final output in the required format\n    print(f\"[{','.join(all_results)}]\")\n\ndef build_forward_operator(Delta, tau, alpha, R, K, N, delta):\n    \"\"\"\n    Constructs the exact K x N forward operator matrix A.\n    \"\"\"\n    A = np.zeros((K, N))\n    \n    # Grid of time points and frame indices\n    k_grid, j_grid = np.meshgrid(np.arange(K), np.arange(N), indexing='ij')\n\n    t_j = j_grid * delta\n    T_k_start = k_grid * Delta\n    T_k_end = (k_grid + 1) * Delta\n\n    # Case 1: Spike before frame (t_j  T_k_start)\n    idx1 = t_j  T_k_start\n    term1 = (alpha * tau / Delta)\n    # The exponential term can be large, but the product is well-behaved\n    # exp((t_j - T_k_start)/tau) = exp((j*delta - k*Delta)/tau)\n    # = exp((j/R - k)*Delta/tau)\n    exp_decay_across_frame = np.exp(-Delta / tau)\n    A[idx1] = term1 * np.exp((t_j[idx1] - T_k_start[idx1]) / tau) * (1 - exp_decay_across_frame)\n\n    # Case 2: Spike within frame (T_k_start = t_j  T_k_end)\n    idx2 = (t_j >= T_k_start)  (t_j  T_k_end)\n    A[idx2] = term1 * (1 - np.exp(-(T_k_end[idx2] - t_j[idx2]) / tau))\n\n    # Case 3 (spike after frame) is implicitly handled as A is initialized to zeros.\n    \n    return A\n\ndef detect_and_refine_spikes(s_est, delta, N, alpha, sigma):\n    \"\"\"\n    Detects spikes from estimated amplitudes via thresholding, non-maximum\n    suppression, and refines their timing using parabolic interpolation.\n    \"\"\"\n    if N == 0:\n        return []\n\n    threshold = max(alpha / 2.0, 3.0 * sigma)\n    \n    # Find indices of potential peaks (above threshold)\n    potential_peak_indices = np.where(s_est > threshold)[0]\n    \n    peak_indices = []\n    for n in potential_peak_indices:\n        # Check for local maximum property (non-maximum suppression)\n        is_local_max = True\n        # Check left neighbor\n        if n > 0 and s_est[n] = s_est[n-1]:\n            is_local_max = False\n        # Check right neighbor\n        if n  N - 1 and s_est[n] = s_est[n+1]:\n            is_local_max = False\n        \n        if is_local_max:\n            peak_indices.append(n)\n\n    estimated_times = []\n    for n in peak_indices:\n        t_n = n * delta\n        \n        # Perform parabolic refinement if neighbors exist\n        if 0  n  N - 1:\n            s_left, s_peak, s_right = s_est[n-1], s_est[n], s_est[n+1]\n            \n            # The denominator is 2 * (s_left + s_right - 2*s_peak)\n            # which is proportional to the second derivative (curvature)\n            denominator = 2 * (s_left + s_right - 2 * s_peak)\n            \n            if np.abs(denominator)  1e-9: # Avoid division by zero (collinear points)\n                offset = 0.0\n            else:\n                offset = delta * (s_left - s_right) / denominator\n                \n            # As per problem, offset is expected within [-delta/2, delta/2].\n            # Clip for robustness.\n            offset = np.clip(offset, -delta / 2.0, delta / 2.0)\n\n            refined_time = t_n + offset\n        else:\n            # Use sub-bin center for boundary peaks\n            refined_time = t_n\n        \n        estimated_times.append(refined_time)\n\n    estimated_times.sort()\n    return estimated_times\n\nsolve()\n```"
        }
    ]
}