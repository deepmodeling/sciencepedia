{
    "hands_on_practices": [
        {
            "introduction": "在功能连接分析中，两个时间序列之间的高相关性并不总是意味着它们之间存在直接的功能耦合。这种表观上的关联可能由第三个共同驱动信号（即“混杂变量”）引起，导致伪相关。为了辨别直接与间接连接，部分相关性是一种至关重要的工具，它通过移除一个或多个控制变量的线性影响来评估两个变量之间的剩余关系。本练习将通过一个具体的数值例子，让你亲手计算并理解当一个潜在的共同驱动因素存在时，一个很高的皮尔逊相关性是如何在考虑该驱动因素后，其部分相关性降至接近零的 。",
            "id": "4165717",
            "problem": "考虑一个简单的功能连接 (FC) 场景，其中一个潜在的共同驱动信号在两个观测节点之间引起强相关性。假设有三个标量时间序列，在 $n=5$ 个时间点采样，记为 $X(t)$、$Y(t)$ 和 $Z(t)$，其中 $t \\in \\{1,2,3,4,5\\}$。假设存在以下生成结构：$X(t) = Z(t) + \\epsilon_{X}(t)$ 和 $Y(t) = Z(t) + \\epsilon_{Y}(t)$，其中 $\\epsilon_{X}(t)$ 和 $\\epsilon_{Y}(t)$ 是小扰动。观测值为：\n- $Z$：$(-2, -1, 0, 1, 2)$，\n- $\\epsilon_{X}$：$(0.1, -0.2, 0, 0.2, -0.1)$，\n- $\\epsilon_{Y}$：$(0.15, -0.15, 0, -0.15, 0.15)$，\n因此\n- $X$：$(-1.9, -1.2, 0, 1.2, 1.9)$，\n- $Y$：$(-1.85, -1.15, 0, 0.85, 2.15)$。\n\n从样本均值、样本协方差、Pearson 相关性和普通最小二乘线性回归（即将 $X$ 拟合为 $Z$ 的线性函数，将 $Y$ 拟合为 $Z$ 的线性函数，然后形成残差）的核心定义出发，完成以下任务：\n1. 计算 $X$ 和 $Y$ 之间的 Pearson 相关性，以说明由共同驱动 $Z$ 引起的明显强功能连接。\n2. 通过先将 $X$ 对 $Z$ 进行回归，再将 $Y$ 对 $Z$ 进行回归，形成残差时间序列，然后计算这些残差之间的 Pearson 相关性，来计算以 $Z$ 为条件的 $X$ 和 $Y$ 之间的偏相关性。\n\n将最终答案表示为偏相关值，它是一个无量纲的量。如果需要四舍五入，将最终数值答案四舍五入到四位有效数字。其他中间结果无需四舍五入。",
            "solution": "该问题被验证为具有科学依据、提法恰当、客观且自洽。所提供的数据和生成模型是说明功能连接分析中概念的标准模型。我们可以继续进行解答。\n\n目标是计算时间序列 $X(t)$ 和 $Y(t)$ 之间的 Pearson 相关性，然后计算以 $Z(t)$ 为条件的 $X(t)$ 和 $Y(t)$ 之间的偏相关性。该问题涉及 $n=5$ 个时间点。\n\n给定的时间序列是：\n$X = (-1.9, -1.2, 0, 1.2, 1.9)$\n$Y = (-1.85, -1.15, 0, 0.85, 2.15)$\n$Z = (-2, -1, 0, 1, 2)$\n\n首先，我们计算每个时间序列的样本均值。对于长度为 $n$ 的时间序列 $V(t)$，样本均值 $\\bar{V}$ 定义为 $\\bar{V} = \\frac{1}{n} \\sum_{t=1}^{n} V(t)$。\n对于 $X(t)$:\n$$ \\bar{X} = \\frac{1}{5} (-1.9 - 1.2 + 0 + 1.2 + 1.9) = \\frac{0}{5} = 0 $$\n对于 $Y(t)$:\n$$ \\bar{Y} = \\frac{1}{5} (-1.85 - 1.15 + 0 + 0.85 + 2.15) = \\frac{0}{5} = 0 $$\n对于 $Z(t)$:\n$$ \\bar{Z} = \\frac{1}{5} (-2 - 1 + 0 + 1 + 2) = \\frac{0}{5} = 0 $$\n所有样本均值均为零这一事实简化了后续计算。\n\n**1. $X$ 和 $Y$ 之间的 Pearson 相关性**\n\n两个序列 $X(t)$ 和 $Y(t)$ 之间的 Pearson 相关系数 $\\rho_{XY}$ 定义为：\n$$ \\rho_{XY} = \\frac{\\sum_{t=1}^{n}(X(t) - \\bar{X})(Y(t) - \\bar{Y})}{\\sqrt{\\sum_{t=1}^{n}(X(t) - \\bar{X})^2 \\sum_{t=1}^{n}(Y(t) - \\bar{Y})^2}} $$\n由于 $\\bar{X} = 0$ 和 $\\bar{Y} = 0$，上式简化为：\n$$ \\rho_{XY} = \\frac{\\sum_{t=1}^{n}X(t)Y(t)}{\\sqrt{\\left(\\sum_{t=1}^{n}X(t)^2\\right) \\left(\\sum_{t=1}^{n}Y(t)^2\\right)}} $$\n我们计算必要的总和：\n分子项，即乘积之和：\n$$ \\sum_{t=1}^{5}X(t)Y(t) = (-1.9)(-1.85) + (-1.2)(-1.15) + (0)(0) + (1.2)(0.85) + (1.9)(2.15) $$\n$$ = 3.515 + 1.38 + 0 + 1.02 + 4.085 = 10.0 $$\n$X(t)$ 的平方和：\n$$ \\sum_{t=1}^{5}X(t)^2 = (-1.9)^2 + (-1.2)^2 + 0^2 + 1.2^2 + 1.9^2 $$\n$$ = 3.61 + 1.44 + 0 + 1.44 + 3.61 = 10.1 $$\n$Y(t)$ 的平方和：\n$$ \\sum_{t=1}^{5}Y(t)^2 = (-1.85)^2 + (-1.15)^2 + 0^2 + (0.85)^2 + (2.15)^2 $$\n$$ = 3.4225 + 1.3225 + 0 + 0.7225 + 4.6225 = 10.09 $$\n现在，我们计算 Pearson 相关性：\n$$ \\rho_{XY} = \\frac{10.0}{\\sqrt{(10.1)(10.09)}} = \\frac{10.0}{\\sqrt{101.909}} \\approx 0.99058 $$\n这证实了由共同驱动 $Z(t)$ 引起的明显强功能连接。\n\n**2. 以 $Z$ 为条件的 $X$ 和 $Y$ 之间的偏相关性**\n\n为了求出偏相关 $\\rho_{XY|Z}$，我们首先对 $X$ 于 $Z$ 以及 $Y$ 于 $Z$ 进行普通最小二乘 (OLS) 回归，然后计算所得残差的 Pearson 相关性。\n\n**$X$ 对 $Z$ 的回归**：\n我们拟合模型 $X(t) = \\alpha_{XZ} + \\beta_{XZ} Z(t)$。截距 $\\alpha_{XZ}$ 和斜率 $\\beta_{XZ}$ 的 OLS 估计值为：\n$$ \\beta_{XZ} = \\frac{\\sum_{t=1}^{n}(X(t) - \\bar{X})(Z(t) - \\bar{Z})}{\\sum_{t=1}^{n}(Z(t) - \\bar{Z})^2} \\quad \\text{和} \\quad \\alpha_{XZ} = \\bar{X} - \\beta_{XZ} \\bar{Z} $$\n由于 $\\bar{X} = 0$ 和 $\\bar{Z} = 0$，我们有 $\\alpha_{XZ} = 0$。斜率简化为：\n$$ \\beta_{XZ} = \\frac{\\sum_{t=1}^{n}X(t)Z(t)}{\\sum_{t=1}^{n}Z(t)^2} $$\n我们计算所需的总和：\n$$ \\sum_{t=1}^{5}Z(t)^2 = (-2)^2 + (-1)^2 + 0^2 + 1^2 + 2^2 = 4 + 1 + 0 + 1 + 4 = 10 $$\n$$ \\sum_{t=1}^{5}X(t)Z(t) = (-1.9)(-2) + (-1.2)(-1) + (0)(0) + (1.2)(1) + (1.9)(2) $$\n$$ = 3.8 + 1.2 + 0 + 1.2 + 3.8 = 10 $$\n所以，斜率为 $\\beta_{XZ} = \\frac{10}{10} = 1$。预测值为 $\\hat{X}(t) = 1 \\cdot Z(t) = Z(t)$。\n$X$ 的残差，我们记为 $R_X(t)$，是：\n$$ R_X(t) = X(t) - \\hat{X}(t) = X(t) - Z(t) $$\n使用给定值，残差序列为：\n$R_X = (-1.9 - (-2), -1.2 - (-1), 0 - 0, 1.2 - 1, 1.9 - 2) = (0.1, -0.2, 0, 0.2, -0.1)$。\n根据构造，这就是噪声序列 $\\epsilon_X(t)$。\n\n**$Y$ 对 $Z$ 的回归**：\n类似地，对于模型 $Y(t) = \\alpha_{YZ} + \\beta_{YZ} Z(t)$，由于 $\\bar{Y} = 0$ 和 $\\bar{Z} = 0$，我们有 $\\alpha_{YZ} = 0$。斜率为：\n$$ \\beta_{YZ} = \\frac{\\sum_{t=1}^{n}Y(t)Z(t)}{\\sum_{t=1}^{n}Z(t)^2} $$\n分母已知为 $10$。我们计算分子：\n$$ \\sum_{t=1}^{5}Y(t)Z(t) = (-1.85)(-2) + (-1.15)(-1) + (0)(0) + (0.85)(1) + (2.15)(2) $$\n$$ = 3.7 + 1.15 + 0 + 0.85 + 4.3 = 10 $$\n所以，斜率为 $\\beta_{YZ} = \\frac{10}{10} = 1$。预测值为 $\\hat{Y}(t) = 1 \\cdot Z(t) = Z(t)$。\n$Y$ 的残差，我们记为 $R_Y(t)$，是：\n$$ R_Y(t) = Y(t) - \\hat{Y}(t) = Y(t) - Z(t) $$\n使用给定值，残差序列为：\n$R_Y = (-1.85 - (-2), -1.15 - (-1), 0 - 0, 0.85 - 1, 2.15 - 2) = (0.15, -0.15, 0, -0.15, 0.15)$。\n根据构造，这就是噪声序列 $\\epsilon_Y(t)$。\n\n**残差的相关性**：\n偏相关 $\\rho_{XY|Z}$ 是残差序列 $R_X(t)$ 和 $R_Y(t)$ 之间的 Pearson 相关性。\n首先，我们计算残差的均值：\n$$ \\bar{R}_X = \\frac{1}{5}(0.1 - 0.2 + 0 + 0.2 - 0.1) = 0 $$\n$$ \\bar{R}_Y = \\frac{1}{5}(0.15 - 0.15 + 0 - 0.15 + 0.15) = 0 $$\n由于均值为零，相关性公式再次简化为：\n$$ \\rho_{XY|Z} = \\rho_{R_X R_Y} = \\frac{\\sum_{t=1}^{n}R_X(t)R_Y(t)}{\\sqrt{\\left(\\sum_{t=1}^{n}R_X(t)^2\\right) \\left(\\sum_{t=1}^{n}R_Y(t)^2\\right)}} $$\n我们计算分子，即残差的乘积之和：\n$$ \\sum_{t=1}^{5}R_X(t)R_Y(t) = (0.1)(0.15) + (-0.2)(-0.15) + (0)(0) + (0.2)(-0.15) + (-0.1)(0.15) $$\n$$ = 0.015 + 0.03 + 0 - 0.03 - 0.015 = 0 $$\n由于相关性表达式的分子为 $0$，且分母不为零（因为残差序列不完全为零），所以偏相关性必须为 $0$。\n这个结果表明，在考虑了共同驱动 $Z(t)$ 的线性效应后，$X(t)$ 和 $Y(t)$ 之间不存在剩余的线性关系。这种明显的强相关性是虚假的，完全由 $Z(t)$ 介导。\n最终答案就是这个偏相关性的值。",
            "answer": "$$\n\\boxed{0}\n$$"
        },
        {
            "introduction": "将成对分析的思想扩展到包含许多脑区的高维数据集时，我们需要一种更有效的方法来描绘整个网络的条件独立结构。高斯图模型（Gaussian Graphical Model, GGM）提供了一个优雅的框架，其中协方差矩阵的逆——即精度矩阵（precision matrix）$ \\Theta $——直接编码了变量之间的条件独立性。这个练习将指导你如何从一个给定的协方差矩阵出发，通过计算精度矩阵来推导部分相关网络，并最终通过阈值化来识别稀疏的连接模式，这是现代网络神经科学中的一项核心技能 。",
            "id": "4165697",
            "problem": "给定一个从多元时间序列估计的对称半正定协方差矩阵 $\\Sigma \\in \\mathbb{R}^{p \\times p}$，其中每个变量代表一个感兴趣的脑区。在高斯图模型 (GGM) 的假设下，条件独立结构由精度矩阵 $\\Theta = \\Sigma^{-1}$ 编码，而功能连接性可以通过变量之间的偏相关进行量化。从多元正态分布中协方差和条件独立性的基本定义出发，推导一个算法，该算法通过 $\\Theta$ 从 $\\Sigma$ 计算偏相关矩阵，并通过对偏相关进行阈值化来解释稀疏模式。\n\n你的程序必须为每个测试用例实现以下步骤：\n- 给定 $\\Sigma$，为保证数值稳定性，构造一个岭正则化协方差 $\\Sigma_{\\epsilon} = \\Sigma + \\epsilon I_p$，其中 $I_p$ 是 $p \\times p$ 的单位矩阵，$\\epsilon \\ge 0$ 已给出。\n- 计算精度矩阵 $\\Theta = \\Sigma_{\\epsilon}^{-1}$。\n- 从 $\\Theta$ 推导偏相关矩阵 $\\Pi$，使得每个非对角线元素 $\\Pi_{ij}$ 等于在所有其他变量为条件下，变量 $i$ 和变量 $j$ 之间的偏相关。按照惯例，对角线元素可以设置为 $1$。\n- 通过对偏相关的绝对值进行阈值化来定义一个无向邻接矩阵 $A$：如果 $|\\Pi_{ij}| \\ge \\tau$ 且 $i \\ne j$，则 $A_{ij} = 1$，否则 $A_{ij} = 0$，其中阈值 $\\tau > 0$ 已给出。\n- 计算整数 $E$，它等于无向边的数量，即 $E = \\sum_{1 \\le i < j \\le p} A_{ij}$。\n- 计算整数 $C$，它等于由 $A$ 导出的无向图中的连通分量数量。\n\n你的程序必须处理以下矩阵和参数的测试套件：\n- 测试用例 1（理想路径，三对角精度矩阵导致链式结构）：\n  协方差矩阵为\n  $$\\Sigma^{(1)} = \\begin{bmatrix}\n  1.2352941176470589  0.5882352941176471  0.23529411764705885 \\\\\n  0.5882352941176471  1.4705882352941178  0.5882352941176471 \\\\\n  0.23529411764705885  0.5882352941176471  1.2352941176470589\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(1)} = 10^{-12}$ 且 $\\tau^{(1)} = 0.05$。\n- 测试用例 2（近奇异边界，具有强共线性的复合对称性）：\n  协方差矩阵为\n  $$\\Sigma^{(2)} = \\begin{bmatrix}\n  1.0  0.95  0.95  0.95 \\\\\n  0.95  1.0  0.95  0.95 \\\\\n  0.95  0.95  1.0  0.95 \\\\\n  0.95  0.95  0.95  1.0\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(2)} = 10^{-6}$ 且 $\\tau^{(2)} = 0.2$。\n- 测试用例 3（边界情况，块对角结构意味着分离的子网络）：\n  协方差矩阵为\n  $$\\Sigma^{(3)} = \\begin{bmatrix}\n  1.0  0.6  0.0  0.0 \\\\\n  0.6  1.0  0.0  0.0 \\\\\n  0.0  0.0  1.0  0.6 \\\\\n  0.0  0.0  0.6  1.0\n  \\end{bmatrix},$$\n  其中 $\\epsilon^{(3)} = 0.0$ 且 $\\tau^{(3)} = 0.2$。\n\n你的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中每个测试用例按顺序贡献一个包含两个整数的列表 $[E, C]$。例如，输出格式必须严格为\n$$[[E^{(1)},C^{(1)}],[E^{(2)},C^{(2)}],[E^{(3)},C^{(3)}]].$$\n不应打印任何额外文本。",
            "solution": "其根本基础是多元正态模型以及协方差和条件独立性的定义。设 $\\mathbf{x} \\in \\mathbb{R}^{p}$ 服从联合高斯分布，其均值为 $\\mathbf{0}$，协方差为 $\\Sigma \\in \\mathbb{R}^{p \\times p}$，即 $\\mathbf{x} \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma)$。精度矩阵定义为 $\\Theta = \\Sigma^{-1}$。高斯图模型 (GGM) 中一个经过充分检验的结论是：$\\Theta_{ij} = 0$ 当且仅当变量 $i$ 和 $j$ 在给定所有其他变量的条件下是条件独立的。这将 $\\Theta$ 中的稀疏性与条件独立结构联系起来，这是通过偏相关来解释功能连接性的基础。\n\n我们从第一性原理推导偏相关公式。将 $\\mathbf{x}$ 划分为 $(x_i, x_j, \\mathbf{x}_{-ij})$，其中 $\\mathbf{x}_{-ij}$ 表示除 $x_i$ 和 $x_j$ 之外的所有变量。在给定 $\\mathbf{x}_{-ij}$ 的条件下，$(x_i, x_j)$ 的条件分布是二元正态分布。条件协方差由 $\\Sigma$ 中对应于 $(i,j)$ 的块的舒尔补给出，但一个等价且更直接的途径是使用精度矩阵。对于一个高斯向量，$x_i$ 对所有其他变量的回归的系数向量与 $\\Theta$ 的相应行成正比。特别地，$x_i$ 对 $x_j$ 的偏回归系数（控制了所有其他变量）是\n$$\\beta_{i \\leftarrow j \\mid -ij} = -\\frac{\\Theta_{ij}}{\\Theta_{ii}}.$$\n对称地，\n$$\\beta_{j \\leftarrow i \\mid -ij} = -\\frac{\\Theta_{ij}}{\\Theta_{jj}}.$$\n在给定 $\\mathbf{x}_{-ij}$ 的条件下，$x_i$ 和 $x_j$ 之间的偏相关 $\\Pi_{ij}$ 是它们回归残差之间的相关性。对于高斯变量，该相关性等于非对角精度元素的归一化负值：\n$$\\Pi_{ij} = -\\frac{\\Theta_{ij}}{\\sqrt{\\Theta_{ii} \\Theta_{jj}}}, \\quad i \\ne j,$$\n且按照惯例 $\\Pi_{ii} = 1$。这种归一化是因为残差方差与 $\\Theta$ 对应的对角线元素成反比，而相关性是通过标准差的几何平均值进行归一化的协方差。\n\n算法上：\n- 当 $\\Sigma$ 近奇异时，数值稳定性可能需要正则化。我们为一个小的岭参数 $\\epsilon \\ge 0$ 构造 $\\Sigma_{\\epsilon} = \\Sigma + \\epsilon I_p$，这能保持对称性并改善条件数。\n- 使用一个稳定的求逆程序计算 $\\Theta = \\Sigma_{\\epsilon}^{-1}$，并通过 $(\\Theta + \\Theta^\\top)/2$ 进行对称化以减少浮点不对称性。\n- 使用上述公式计算 $\\Pi$。设 $d = \\sqrt{\\operatorname{diag}(\\Theta)} \\in \\mathbb{R}^p$，则\n$$\\Pi = -\\Theta \\oslash (d d^\\top),$$\n其中 $\\oslash$ 表示逐元素除法，我们将 $\\Pi$ 的对角线设置为 $1$。\n- 为了解释稀疏性，我们对非对角线元素的绝对值进行阈值化：如果 $|\\Pi_{ij}| \\ge \\tau$ 且 $i \\ne j$，则 $A_{ij} = 1$，否则 $A_{ij} = 0$。这会产生一个无向图。$\\Theta$ 中的零意味着精确的条件独立性，因此在总体中偏相关为零；在有限样本和有数值误差的情况下，小幅度的 $\\Pi_{ij}$ 表明直接功能连接很弱或不存在，因此阈值化可以捕捉稀疏性。\n- 边的数量是 $E = \\sum_{1 \\le i < j \\le p} A_{ij}$，每条无向边只计数一次。\n- 连通分量的数量 $C$ 是通过在邻接图上进行图遍历（例如，深度优先搜索或广度优先搜索）计算得出的，孤立节点也算作一个连通分量。\n\n应用于测试套件：\n- 测试用例 1 是由一个在 $(1,3)$ 位置有零元素的三对角精度矩阵构造的；其给定的协方差 $\\Sigma^{(1)}$ 是一个精度矩阵的逆，该精度矩阵满足 $\\Theta^{(1)}_{12} = \\Theta^{(1)}_{23} \\ne 0$ 和 $\\Theta^{(1)}_{13} = 0$。当使用一个小的阈值 $\\tau^{(1)} = 0.05$ 时，结果是一个具有两条边和一个连通分量的链式图。\n- 测试用例 2 表现出具有强共线性的复合对称性（$\\Sigma^{(2)}$ 的非对角线元素为 $0.95$），这是病态的。岭参数 $\\epsilon^{(2)} = 10^{-6}$ 稳定了求逆过程。大多数变量对的偏相关不为零，产生一个有许多边的稠密图；当 $\\tau^{(2)} = 0.2$ 时，该图预计是完全连通的。\n- 测试用例 3 是块对角的，意味着两个分离的子网络。使用 $\\tau^{(3)} = 0.2$ 进行阈值化处理，仅在块内产生边，并生成两个连通分量。\n\n程序实现了这一流程，并按规定输出列表 $[[E^{(1)},C^{(1)}],[E^{(2)},C^{(2)}],[E^{(3)},C^{(3)}]]$，通过从精度矩阵推导偏相关，并在 GGM 框架中通过条件独立结构解释稀疏性，从而确保了科学真实性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_partial_correlation_from_cov(Sigma: np.ndarray, eps: float = 0.0) -> tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Compute the partial correlation matrix from a covariance matrix via the precision matrix.\n    Returns (Pi, Theta), where Pi is the partial correlation matrix and Theta is the precision.\n    \"\"\"\n    p = Sigma.shape[0]\n    # Ridge regularization for numerical stability\n    Sigma_reg = Sigma + eps * np.eye(p)\n    # Invert to get precision\n    Theta = np.linalg.inv(Sigma_reg)\n    # Symmetrize to reduce numerical asymmetry\n    Theta = (Theta + Theta.T) / 2.0\n    # Compute partial correlations: Pi_ij = -Theta_ij / sqrt(Theta_ii * Theta_jj)\n    d = np.sqrt(np.diag(Theta))\n    # Avoid division by zero: if any diagonal is zero (should not happen for SPD), fallback to tiny epsilon\n    d = np.where(d == 0.0, 1e-18, d)\n    denom = np.outer(d, d)\n    Pi = -Theta / denom\n    # Set diagonal to 1 by convention\n    np.fill_diagonal(Pi, 1.0)\n    return Pi, Theta\n\ndef adjacency_from_partial_corr(Pi: np.ndarray, tau: float) -> np.ndarray:\n    \"\"\"\n    Build undirected adjacency matrix by thresholding absolute partial correlations.\n    \"\"\"\n    p = Pi.shape[0]\n    A = (np.abs(Pi) >= tau)\n    # No self-loops\n    np.fill_diagonal(A, False)\n    # Symmetrize adjacency\n    A = np.logical_or(A, A.T)\n    return A\n\ndef count_edges(A: np.ndarray) -> int:\n    \"\"\"\n    Count undirected edges in adjacency matrix (upper triangle).\n    \"\"\"\n    return int(np.sum(np.triu(A, 1)))\n\ndef count_connected_components(A: np.ndarray) -> int:\n    \"\"\"\n    Count connected components in an undirected graph with adjacency matrix A.\n    \"\"\"\n    p = A.shape[0]\n    visited = np.zeros(p, dtype=bool)\n    components = 0\n    for start in range(p):\n        if not visited[start]:\n            components += 1\n            # BFS\n            queue = [start]\n            visited[start] = True\n            while queue:\n                u = queue.pop(0)\n                neighbors = np.where(A[u])[0]\n                for v in neighbors:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n    return components\n\ndef solve():\n    # Define the test cases from the problem statement.\n    Sigma1 = np.array([\n        [1.2352941176470589, 0.5882352941176471, 0.23529411764705885],\n        [0.5882352941176471, 1.4705882352941178, 0.5882352941176471],\n        [0.23529411764705885, 0.5882352941176471, 1.2352941176470589]\n    ], dtype=float)\n    eps1 = 1e-12\n    tau1 = 0.05\n\n    Sigma2 = np.array([\n        [1.0, 0.95, 0.95, 0.95],\n        [0.95, 1.0, 0.95, 0.95],\n        [0.95, 0.95, 1.0, 0.95],\n        [0.95, 0.95, 0.95, 1.0]\n    ], dtype=float)\n    eps2 = 1e-6\n    tau2 = 0.2\n\n    Sigma3 = np.array([\n        [1.0, 0.6, 0.0, 0.0],\n        [0.6, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.6],\n        [0.0, 0.0, 0.6, 1.0]\n    ], dtype=float)\n    eps3 = 0.0\n    tau3 = 0.2\n\n    test_cases = [\n        (Sigma1, eps1, tau1),\n        (Sigma2, eps2, tau2),\n        (Sigma3, eps3, tau3),\n    ]\n\n    results = []\n    for Sigma, eps, tau in test_cases:\n        Pi, Theta = compute_partial_correlation_from_cov(Sigma, eps)\n        A = adjacency_from_partial_corr(Pi, tau)\n        E = count_edges(A)\n        C = count_connected_components(A)\n        results.append([E, C])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "功能连接不仅限于信号振幅的同步波动，还包括神经振荡相位之间的一致性。锁相值（Phase Locking Value, PLV）是衡量这种相位同步性的常用无向性指标，它对于研究大脑中基于节律的通信至关重要。本练习将带你实践一个完整的时间序列分析流程：使用希尔伯特变换（Hilbert transform）从信号中提取瞬时相位，并在滑动窗口内计算PLV，从而评估时变的相位同步关系 。",
            "id": "4165636",
            "problem": "给定多对离散时间信号，旨在模拟具有窄带振荡内容的神经时间序列。对于每对信号，您必须通过希尔伯特变换得到的解析信号计算瞬时相位，形成逐样本的相位差，并通过在连续、重叠的滑动窗口上评估相位锁定值来评价时变相位同步性。角度必须以弧度处理。所有计算都应以无量纲单位表示。\n\n应使用的基本和核心定义：\n- 设 $x[n]$ 为一个实值采样时间序列，并设 $f_s$ 表示以 $\\mathrm{Hz}$ 为单位的采样频率。与 $x(t)$ 相关的连续时间解析信号定义为 $x_a(t) = x(t) + i \\, \\mathcal{H}\\{x(t)\\}$，其中 $\\mathcal{H}\\{\\cdot\\}$ 是希尔伯特变换，$i$ 是虚数单位。在离散时间中，解析信号 $z_x[n]$ 是通过使用标准的离散近似将希尔伯特变换应用于 $x[n]$ 而获得的。瞬时相位则为 $\\phi_x[n] = \\arg(z_x[n])$，其中 $\\arg(\\cdot)$ 返回以弧度为单位的复数辐角。\n- 给定两个信号 $x[n]$ 和 $y[n]$，将逐样本相位差定义为 $\\Delta \\phi[n] = \\phi_x[n] - \\phi_y[n]$（以弧度为单位）。时变同步性应在滑动窗口上进行评估，每个窗口由持续时间 $L$ 秒和步长 $S$ 秒指定。设 $L_s = \\mathrm{round}(L \\cdot f_s)$ 为每个窗口的样本数， $S_s = \\mathrm{round}(S \\cdot f_s)$ 为以样本为单位的步进。仅使用完全位于信号内部的窗口，其起始索引为 $s_m = m \\, S_s$，对于整数 $m$，使得 $s_m + L_s \\leq N$，其中 $N$ 是总样本数。\n- 在每个窗口中，使用根据该窗口内的逐样本相位差构建的平均单位相量的模来量化相位同步的程度。在整个过程中，角度必须以弧度处理。\n\n严格遵循上述基本定义，实现算法流程。程序必须在内部合成测试信号，通过标准的离散希尔伯特变换计算解析信号，提取瞬时相位，计算逐样本相位差，然后按所述方法评估每个窗口的同步性度量。\n\n使用以下测试套件。每个测试用例都是一个参数集；在所有情况下，使用以 $\\mathrm{Hz}$ 为单位的 $f_s$ 和以秒为单位的持续时间。每当使用随机性时，将您的随机数生成器初始化为固定种子，以确保输出可复现。在下面的每个案例中，$t[n] = n / f_s$ 对于 $n = 0, 1, \\dots, N-1$。\n\n- 测试用例 A (完全相位锁定):\n    - $N = 2048$, $f_s = 512$, $f = 10$。\n    - $x[n] = \\sin(2\\pi f \\, t[n])$。\n    - $y[n] = \\sin(2\\pi f \\, t[n] + \\Delta)$，其中 $\\Delta = \\pi / 4$。\n    - 窗口持续时间 $L = 1.0$，步长 $S = 0.5$。\n    - 无附加噪声。\n- 测试用例 B (频率失配，低同步性):\n    - $N = 2048$, $f_s = 512$, $f_x = 10$, $f_y = 12$。\n    - $x[n] = \\sin(2\\pi f_x \\, t[n])$。\n    - $y[n] = \\sin(2\\pi f_y \\, t[n])$。\n    - 窗口持续时间 $L = 2.0$，步长 $S = 0.5$。\n    - 无附加噪声。\n- 测试用例 C (带噪声的瞬时同步):\n    - $N = 4096$, $f_s = 512$, $f_1 = 8$, $f_2 = 8.5$。\n    - $x[n] = \\sin(2\\pi f_1 \\, t[n]) + \\eta_x[n]$，其中 $\\eta_x[n]$ 是标准差为 $0.1$ 无量纲单位的零均值高斯噪声。\n    - $y[n]$ 是分段的：\n        - 对于 $t[n] \\in [0, 1.5)$ 秒：$y[n] = \\sin(2\\pi f_1 \\, t[n] + 0)$。\n        - 对于 $t[n] \\in [1.5, 5.5)$ 秒：$y[n] = \\sin(2\\pi f_2 \\, t[n] + 0)$。\n        - 对于 $t[n] \\in [5.5, 8.0)$ 秒：$y[n] = \\sin(2\\pi f_1 \\, t[n] + \\pi / 6)$。\n      然后添加与 $\\eta_x[n]$ 具有相同分布的独立噪声 $\\eta_y[n]$。\n    - 窗口持续时间 $L = 1.0$，步长 $S = 0.25$。\n- 测试用例 D (带噪声的单个全长窗口):\n    - $N = 1024$, $f_s = 512$, $f = 6$, $\\Delta = \\pi / 3$。\n    - $x[n] = \\sin(2\\pi f \\, t[n]) + \\xi_x[n]$，$y[n] = \\sin(2\\pi f \\, t[n] + \\Delta) + \\xi_y[n]$，其中 $\\xi_x[n]$ 和 $\\xi_y[n]$ 是标准差为 $0.2$ 无量纲单位的独立零均值高斯噪声。\n    - 窗口持续时间 $L = 2.0$，步长 $S = 2.0$。\n\n您的程序必须生成单行输出，其中包含四个测试用例的结果，形式为方括号内包含的逗号分隔列表，其中每个元素本身是对应于该测试用例每个窗口同步性度量的浮点值列表。每个浮点值必须四舍五入到六位小数。例如，输出格式必须为 $[[r_{A,1},r_{A,2},\\dots],[r_{B,1},\\dots],[r_{C,1},\\dots],[r_{D,1},\\dots]]$，行内任何地方都不能有空格。在所有步骤中，角度必须解释为弧度，输出是四舍五入到六位小数的无量纲浮点数。",
            "solution": "该问题要求实现一个计算流程，以评估离散时间信号对之间时变的相位同步性。该方法基于解析信号的概念，解析信号通过希尔伯特变换获得，并从中导出瞬时相位。同步程度由在一系列滑动窗口上计算的相位锁定值（PLV）来量化。\n\n分析过程主要分为四个阶段：\n1.  **解析信号和瞬时相位提取：** 对于给定的实值离散信号 $x[n]$，其相关的解析信号 $z_x[n]$ 是一个复值信号，其实部是 $x[n]$，虚部是 $x[n]$ 的希尔伯特变换，记为 $\\mathcal{H}\\{x[n]\\}$。因此，$z_x[n] = x[n] + i\\mathcal{H}\\{x[n]\\}$。希尔伯特变换通过标准的离散近似实现，通常基于快速傅里叶变换（FFT）。信号 $x[n]$ 在每个时间点 $n$ 的瞬时相位 $\\phi_x[n]$ 则是相应解析信号样本的辐角：\n    $$\n    \\phi_x[n] = \\arg(z_x[n])\n    $$\n    此操作对信号对中的两个信号 $x[n]$ 和 $y[n]$ 都执行，以产生它们各自的瞬时相位序列 $\\phi_x[n]$ 和 $\\phi_y[n]$。所有角度都以弧度计算。\n\n2.  **逐样本相位差：** 两个信号相位之间的关系由它们的逐样本差 $\\Delta\\phi[n]$ 捕获：\n    $$\n    \\Delta\\phi[n] = \\phi_x[n] - \\phi_y[n]\n    $$\n    如果两个信号是相位锁定的，这个差值将随时间趋于恒定。如果它们的频率不同，这个相位差将会漂移。\n\n3.  **滑动窗口分析：** 为了捕捉相位同步的时变特性，分析被分段为连续、重叠的窗口。每个窗口的持续时间为 $L$ 秒，对应于 $L_s = \\mathrm{round}(L \\cdot f_s)$ 个样本，窗口以 $S$ 秒的步长前进，对应于 $S_s = \\mathrm{round}(S \\cdot f_s)$ 个样本的步进。分析在所有完全位于总信号长度 $N$ 内的窗口上执行。第 $m$ 个窗口（对于 $m=0, 1, 2, \\dots$）的起始索引由 $s_m = m \\cdot S_s$ 给出，最后一个有效窗口是满足 $s_m + L_s \\leq N$ 的窗口。\n\n4.  **相位锁定值（PLV）计算：** 在每个窗口内，计算一个单一的值来量化相位差的一致性。这个度量，即PLV，定义为由该窗口内相位差构成的单位相量均值的模。对于起始索引为 $s_m$、长度为 $L_s$ 的第 $m$ 个窗口，PLV为：\n    $$\n    \\mathrm{PLV}_m = \\left| \\frac{1}{L_s} \\sum_{k=0}^{L_s-1} e^{i \\Delta\\phi[s_m + k]} \\right|\n    $$\n    PLV 的范围是 $0$ 到 $1$。值为 $1$ 表示完美的相位锁定（相位差 $\\Delta\\phi$ 在窗口内是恒定的），而接近 $0$ 的值表示缺乏锁定（相位差均匀分布，导致单位矢量相互抵消）。\n\n该实现将处理四个不同的测试用例，旨在评估算法在不同条件下的性能：\n- **测试用例 A：** 两个频率相同但具有恒定相位偏移的正弦波。这应该在所有窗口中产生非常接近 $1.0$ 的 PLV，表明完美的相位同步。\n- **测试用例 B：** 两个频率不同的正弦波。相位差将线性漂移，导致低的 PLV 值，正确地识别为非同步性。\n- **测试用例 C：** 一个更复杂的场景，包含噪声和分段信号定义，模拟瞬时同步。在频率匹配的时期，PLV 预计会很高，而在频率不同时则较低，噪声会轻微降低整体值。\n- **测试用例 D：** 两个频率相同的含噪正弦波，在覆盖整个信号的单个窗口上进行分析。这测试了该度量对加性噪声的鲁棒性。\n\n为保证可复现性，在创建含噪声的信号时，为伪随机数生成器使用了固定种子。算法流程严格遵循所提供的定义，最终为每个测试用例生成一系列 PLV 值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for phase synchrony analysis.\n    \"\"\"\n\n    # Use a fixed seed for the random number generator for reproducibility.\n    rng = np.random.default_rng(0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case A (perfect phase locking)\n        {\n            \"N\": 2048, \"fs\": 512, \"L\": 1.0, \"S\": 0.5,\n            \"signal_params\": {\"type\": \"A\", \"f\": 10, \"delta\": np.pi / 4}\n        },\n        # Test Case B (frequency mismatch, low synchrony)\n        {\n            \"N\": 2048, \"fs\": 512, \"L\": 2.0, \"S\": 0.5,\n            \"signal_params\": {\"type\": \"B\", \"fx\": 10, \"fy\": 12}\n        },\n        # Test Case C (transient synchrony with noise)\n        {\n            \"N\": 4096, \"fs\": 512, \"L\": 1.0, \"S\": 0.25,\n            \"signal_params\": {\"type\": \"C\", \"f1\": 8, \"f2\": 8.5, \"noise_std\": 0.1}\n        },\n        # Test Case D (single full-length window with noise)\n        {\n            \"N\": 1024, \"fs\": 512, \"L\": 2.0, \"S\": 2.0,\n            \"signal_params\": {\"type\": \"D\", \"f\": 6, \"delta\": np.pi / 3, \"noise_std\": 0.2}\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N = params[\"N\"]\n        fs = params[\"fs\"]\n        L = params[\"L\"]\n        S = params[\"S\"]\n        sp = params[\"signal_params\"]\n\n        # Generate signals\n        t = np.arange(N) / fs\n        if sp[\"type\"] == \"A\":\n            x = np.sin(2 * np.pi * sp[\"f\"] * t)\n            y = np.sin(2 * np.pi * sp[\"f\"] * t + sp[\"delta\"])\n        elif sp[\"type\"] == \"B\":\n            x = np.sin(2 * np.pi * sp[\"fx\"] * t)\n            y = np.sin(2 * np.pi * sp[\"fy\"] * t)\n        elif sp[\"type\"] == \"C\":\n            x = np.sin(2 * np.pi * sp[\"f1\"] * t) + rng.normal(0, sp[\"noise_std\"], N)\n            \n            y = np.zeros(N)\n            t1_end_idx = int(1.5 * fs)\n            t2_end_idx = int(5.5 * fs)\n            \n            y[:t1_end_idx] = np.sin(2 * np.pi * sp[\"f1\"] * t[:t1_end_idx])\n            y[t1_end_idx:t2_end_idx] = np.sin(2 * np.pi * sp[\"f2\"] * t[t1_end_idx:t2_end_idx])\n            y[t2_end_idx:] = np.sin(2 * np.pi * sp[\"f1\"] * t[t2_end_idx:] + np.pi / 6)\n            \n            y += rng.normal(0, sp[\"noise_std\"], N)\n        elif sp[\"type\"] == \"D\":\n            noise_x = rng.normal(0, sp[\"noise_std\"], N)\n            noise_y = rng.normal(0, sp[\"noise_std\"], N)\n            x = np.sin(2 * np.pi * sp[\"f\"] * t) + noise_x\n            y = np.sin(2 * np.pi * sp[\"f\"] * t + sp[\"delta\"]) + noise_y\n        \n        # Calculate analytic signals and instantaneous phases\n        z_x = signal.hilbert(x)\n        z_y = signal.hilbert(y)\n        phi_x = np.angle(z_x)\n        phi_y = np.angle(z_y)\n\n        # Calculate phase difference\n        delta_phi = phi_x - phi_y\n        \n        # Calculate window and step sizes in samples\n        L_s = int(np.round(L * fs))\n        S_s = int(np.round(S * fs))\n\n        # Perform sliding window PLV calculation\n        window_results = []\n        start_idx = 0\n        while start_idx + L_s = N:\n            delta_phi_window = delta_phi[start_idx : start_idx + L_s]\n            \n            # PLV = |mean(exp(i * delta_phi))|\n            plv = np.abs(np.mean(np.exp(1j * delta_phi_window)))\n            window_results.append(plv)\n            \n            start_idx += S_s\n            \n        all_results.append(window_results)\n\n    # Format output according to specifications\n    outer_list = []\n    for res_list in all_results:\n        inner_list = [f\"{x:.6f}\" for x in res_list]\n        outer_list.append(f\"[{','.join(inner_list)}]\")\n    final_string = f\"[{','.join(outer_list)}]\"\n    print(final_string)\n\nsolve()\n```"
        }
    ]
}