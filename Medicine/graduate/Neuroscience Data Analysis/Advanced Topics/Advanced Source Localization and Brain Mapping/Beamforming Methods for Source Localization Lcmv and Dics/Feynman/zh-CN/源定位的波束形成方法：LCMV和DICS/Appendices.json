{
    "hands_on_practices": [
        {
            "introduction": "波束形成器的一个核心特性是其空间分辨率，即其区分空间中不同点的能力。点扩散函数（PSF）是评估这种能力的关键工具，它描述了当只有一个点源活动时，波束形成器在整个源空间中重建出的功率分布。这个练习将指导你从头开始，在一个简化的模型中实现波束形成器算法，计算其点扩散函数，并得出一个“焦度指数”来量化定位的锐度，从而为你提供关于波束形成器空间选择性的直观理解。",
            "id": "4141741",
            "problem": "给定一个用于脑磁图/脑电图波束形成的简化线性混合模型，其中测量的传感器信号 $x(t) \\in \\mathbb{R}^m$ 被建模为 $x(t) = L s(t) + n(t)$，其中 $L \\in \\mathbb{R}^{m \\times n}$ 是将 $n$ 个假定源映射到 $m$ 个传感器的导联场矩阵，$s(t) \\in \\mathbb{R}^n$ 是源活动，$n(t) \\in \\mathbb{R}^m$ 是加性噪声。假设平稳性，因此传感器协方差 $C \\in \\mathbb{R}^{m \\times m}$ 满足 $C = \\mathbb{E}[x(t) x(t)^\\top]$，并且在固定频率 $f$ 下，（实值）互谱密度 $S \\in \\mathbb{R}^{m \\times m}$ 满足 $S = \\mathbb{E}[X(f) X(f)^\\top]$，其中 $X(f)$ 是 $x(t)$ 的傅里叶变换。考虑两种波束形成器：作用于 $C$ 的线性约束最小方差(LCMV)波束形成器，以及作用于 $S$ 的相干源动态成像(DICS)波束形成器。\n\n您的任务是提出并实现一种方法，通过在单个位置模拟单位功率源，应用波束形成器，并映射所有候选源位置的重建功率，来计算LCMV或DICS的点扩散函数(PSF)。PSF的定义如下：对于每个候选位置索引 $j \\in \\{0,1,\\dots,n-1\\}$，形成一个空间滤波器 $w_j \\in \\mathbb{R}^m$，该滤波器在位置 $j$ 处强制施加单位增益约束，并相对于矩阵 $M \\in \\mathbb{R}^{m \\times m}$ 最小化波束形成器的输出功率，其中对于LCMV，$M=C$，对于DICS，$M=S$。位置 $j$ 的重建功率为 $\\hat{p}_j = w_j^\\top M w_j$。将所有 $j$ 的 $\\hat{p}_j$ 收集起来，得到PSF向量 $\\hat{p} \\in \\mathbb{R}^n$。从 $\\hat{p}$ 中，定义局灶性指数 $F$ 为 $F = \\hat{p}_{j^\\ast} \\big/ \\sum_{j=0}^{n-1} \\hat{p}_j$，其中 $j^\\ast$ 是真实源索引。局灶性指数 $F$ 必须报告为小数（无单位）。\n\n您必须遵守以下建模和计算约束：\n\n- 源模拟：通过将源功率对角矩阵 $P_s \\in \\mathbb{R}^{n \\times n}$ 设置为除 $(P_s)_{j^\\ast,j^\\ast} = 1$ 外全为零，来模拟在索引 $j^\\ast$ 处的单个单位功率源。噪声被建模为空间白噪声，方差为 $\\sigma^2$，因此 $C = L P_s L^\\top + \\sigma^2 I_m$ 和 $S = L P_s L^\\top + \\sigma^2 I_m$，其中 $I_m$ 是 $m \\times m$ 的单位矩阵。所有量均无单位。\n- 导联场构建：传感器和源位于一维直线上。传感器位置为 $s_i = i \\cdot d_s$，其中 $i \\in \\{0,1,\\dots,m-1\\}$，源位置为 $r_j = (j \\cdot d_r) + \\delta$，其中 $j \\in \\{0,1,\\dots,n-1\\}$。导联场条目由 $L_{i,j} = \\frac{1}{1 + \\lvert s_i - r_j \\rvert}$ 给出，适用于所有 $i,j$。\n- 正则化：为确保 $M$ 的可逆性，使用Tikhonov型对角加载 $M_{\\text{reg}} = M + \\alpha \\cdot \\frac{\\operatorname{tr}(M)}{m} I_m$，其中 $\\alpha$ 是一个非负标量。空间滤波器 $w_j$ 必须使用 $M_{\\text{reg}}$ 计算，而重建功率 $\\hat{p}_j$ 则使用未正则化的 $M$ 进行评估。\n\n您的程序必须实现以上内容，并为以下每个测试用例计算局灶性指数 $F$。每个测试用例由 $(\\text{method}, m, n, d_s, d_r, \\delta, \\sigma^2, \\alpha, j^\\ast)$ 完全指定：\n\n- 测试用例1（正常路径，LCMV）：$(\\text{LCMV}, m=6, n=5, d_s=1.0, d_r=1.0, \\delta=0.5, \\sigma^2=0.01, \\alpha=0.05, j^\\ast=2)$。\n- 测试用例2（近奇异协方差，LCMV）：$(\\text{LCMV}, m=6, n=5, d_s=1.0, d_r=1.0, \\delta=0.5, \\sigma^2=0.000001, \\alpha=0.10, j^\\ast=3)$。\n- 测试用例3（频域模拟，DICS）：$(\\text{DICS}, m=6, n=5, d_s=1.0, d_r=1.0, \\delta=0.5, \\sigma^2=0.05, \\alpha=0.05, j^\\ast=1)$。\n- 测试用例4（导联场中的高共线性，DICS）：$(\\text{DICS}, m=6, n=5, d_s=1.0, d_r=0.2, \\delta=0.1, \\sigma^2=0.001, \\alpha=0.05, j^\\ast=4)$。\n\n算法要求：\n\n- 对于每个测试用例，使用 $s_i = i \\cdot d_s$ 和 $r_j = (j \\cdot d_r) + \\delta$，通过 $L_{i,j} = \\frac{1}{1 + \\lvert s_i - r_j \\rvert}$ 从指定的 $(m, n, d_s, d_r, \\delta)$ 构建 $L$。\n- 形成 $P_s$，其中 $(P_s)_{j^\\ast,j^\\ast} = 1$，其余为零。如果方法是LCMV，则计算 $M = C$，如果方法是DICS，则计算 $M = S$，公式为 $M = L P_s L^\\top + \\sigma^2 I_m$。\n- 对于每个 $j \\in \\{0,1,\\dots,n-1\\}$，计算一个空间滤波器 $w_j$，其在约束条件 $w^\\top l_j = 1$ 下最小化 $w^\\top M_{\\text{reg}} w$，其中 $l_j$ 是 $L$ 的第 $j$ 列。使用 $M_{\\text{reg}} = M + \\alpha \\cdot \\frac{\\operatorname{tr}(M)}{m} I_m$。\n- 计算 $\\hat{p}_j = w_j^\\top M w_j$，然后计算局灶性指数 $F = \\hat{p}_{j^\\ast} \\big/ \\sum_{j=0}^{n-1} \\hat{p}_j$ 并表示为小数。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含四个测试用例的局灶性指数，格式为逗号分隔的列表，包含在方括号中，例如 $[\\ldots]$。条目必须是小数。确切的输出格式为 $[F_1,F_2,F_3,F_4]$，其中 $F_k$ 是测试用例 $k$ 的局灶性指数。\n\n不允许外部输入；所有值必须完全按照上述规定在程序内部生成。",
            "solution": "用户提供的问题经评估为有效。它在科学上基于信号处理中源定位的原理，是适定的，并为计算任务提供了一套完整、自洽的规范。所做的简化，如一维模型和互谱密度矩阵的特定公式，对于一个已定义的计算问题是适当的，不构成科学缺陷。\n\n该问题要求计算波束形成源定位任务的局灶性指数。这涉及几个步骤：定义物理模型、建立数据协方差矩阵、通过约束优化计算空间滤波器，最后评估重建功率的空间扩散。\n\n波束形成方法的核心是为每个假定源位置 $j$ 计算空间滤波器 $w_j \\in \\mathbb{R}^m$。该滤波器是一个约束优化问题的解：最小化输出功率，约束条件为对感兴趣源的单位增益。输出功率由 $w^\\top M_{\\text{reg}} w$ 给出，其中 $M_{\\text{reg}} \\in \\mathbb{R}^{m \\times m}$ 是正则化的数据协方差（对于LCMV）或互谱密度（对于DICS）矩阵。单位增益约束表示为 $w^\\top l_j = 1$，其中 $l_j \\in \\mathbb{R}^m$ 是第 $j$ 个源位置的导联场向量，即导联场矩阵 $L$ 的第 $j$ 列。\n\n该优化问题正式表述为：\n$$\n\\text{最小化 } w^\\top M_{\\text{reg}} w \\quad \\text{约束条件为} \\quad w^\\top l_j = 1\n$$\n这是一个标准问题，可以使用拉格朗日乘子法求解。拉格朗日函数 $\\mathcal{L}$ 为：\n$$\n\\mathcal{L}(w, \\lambda) = w^\\top M_{\\text{reg}} w - \\lambda(w^\\top l_j - 1)\n$$\n其中 $\\lambda$ 是拉格朗日乘子。为找到最小值，我们计算关于 $w$ 的梯度并将其设为零：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial w} = 2 M_{\\text{reg}} w - \\lambda l_j = 0\n$$\n假设 $M_{\\text{reg}}$ 是可逆的，这由问题的正则化方案保证，我们可以解出 $w$：\n$$\nw = \\frac{\\lambda}{2} M_{\\text{reg}}^{-1} l_j\n$$\n为了找到 $\\lambda$，我们将此 $w$ 的表达式代回约束方程 $w^\\top l_j = 1$：\n$$\n\\left( \\frac{\\lambda}{2} M_{\\text{reg}}^{-1} l_j \\right)^\\top l_j = 1 \\implies \\frac{\\lambda}{2} (l_j^\\top M_{\\text{reg}}^{-1} l_j) = 1\n$$\n解出项 $\\frac{\\lambda}{2}$ 得：\n$$\n\\frac{\\lambda}{2} = \\frac{1}{l_j^\\top M_{\\text{reg}}^{-1} l_j}\n$$\n将此代回 $w$ 的表达式，得到最优空间滤波器 $w_j$：\n$$\nw_j = \\frac{M_{\\text{reg}}^{-1} l_j}{l_j^\\top M_{\\text{reg}}^{-1} l_j}\n$$\n问题规定，位置 $j$ 的重建功率 $\\hat{p}_j$ 是使用未正则化的矩阵 $M$ 计算的：\n$$\n\\hat{p}_j = w_j^\\top M w_j\n$$\n通过代入 $w_j$ 的表达式，我们得到：\n$$\n\\hat{p}_j = \\left( \\frac{M_{\\text{reg}}^{-1} l_j}{l_j^\\top M_{\\text{reg}}^{-1} l_j} \\right)^\\top M \\left( \\frac{M_{\\text{reg}}^{-1} l_j}{l_j^\\top M_{\\text{reg}}^{-1} l_j} \\right) = \\frac{l_j^\\top (M_{\\text{reg}}^{-1})^\\top M M_{\\text{reg}}^{-1} l_j}{(l_j^\\top M_{\\text{reg}}^{-1} l_j)^2}\n$$\n由于 $M_{\\text{reg}}$ 是对称的，其逆矩阵也是对称的，所以 $(M_{\\text{reg}}^{-1})^\\top = M_{\\text{reg}}^{-1}$。功率的表达式变为：\n$$\n\\hat{p}_j = \\frac{l_j^\\top M_{\\text{reg}}^{-1} M M_{\\text{reg}}^{-1} l_j}{(l_j^\\top M_{\\text{reg}}^{-1} l_j)^2}\n$$\n为每个测试用例实现的总体算法如下：\n\n1.  **构建矩阵**：\n    a.  基于传感器位置 $s_i = i \\cdot d_s$（其中 $i \\in \\{0, \\dots, m-1\\}$）和源位置 $r_j = (j \\cdot d_r) + \\delta$（其中 $j \\in \\{0, \\dots, n-1\\}$）构建导联场矩阵 $L \\in \\mathbb{R}^{m \\times n}$。每个元素由 $L_{i,j} = \\frac{1}{1 + \\lvert s_i - r_j \\rvert}$ 给出。\n    b.  生成模拟数据矩阵 $M \\in \\mathbb{R}^{m \\times m}$（代表LCMV的 $C$ 或DICS的 $S$）。对于索引为 $j^\\ast$ 且具有单位功率的单个活动源，源功率矩阵 $P_s$ 是一个对角矩阵，其 $(P_s)_{j^\\ast, j^\\ast} = 1$，其余元素为零。然后数据矩阵为 $M = L P_s L^\\top + \\sigma^2 I_m$。这可以高效地计算为 $M = l_{j^\\ast} l_{j^\\ast}^\\top + \\sigma^2 I_m$，其中 $l_{j^\\ast}$ 是 $L$ 的第 $j^\\ast$ 列，$I_m$ 是 $m \\times m$ 的单位矩阵。\n    c.  使用Tikhonov型正则化计算正则化矩阵 $M_{\\text{reg}}$：$M_{\\text{reg}} = M + \\alpha \\cdot \\frac{\\operatorname{tr}(M)}{m} I_m$。在 $M$ 中包含噪声项 $\\sigma^2 I_m$ 和额外的对角加载确保 $M_{\\text{reg}}$ 是良态且可逆的。\n\n2.  **计算点扩散函数(PSF)**：\n    a.  对于每个候选源位置 $j \\in \\{0, 1, \\dots, n-1\\}$，从 $L$ 中提取相应的导联场向量 $l_j$。\n    b.  使用推导出的公式 $w_j = (M_{\\text{reg}}^{-1} l_j) / (l_j^\\top M_{\\text{reg}}^{-1} l_j)$ 计算空间滤波器 $w_j$。这需要计算 $M_{\\text{reg}}$ 的逆矩阵。\n    c.  计算重建功率 $\\hat{p}_j = w_j^\\top M w_j$。\n    d.  所有功率值 $\\{\\hat{p}_j\\}_{j=0}^{n-1}$ 的集合构成PSF向量 $\\hat{p}$。\n\n3.  **计算局灶性指数**：\n    a.  局灶性指数 $F$ 计算为真实源位置处的功率与所有位置总重建功率之比：\n        $$\n        F = \\frac{\\hat{p}_{j^\\ast}}{\\sum_{j=0}^{n-1} \\hat{p}_j}\n        $$\n此过程应用于问题中指定的四个测试用例中的每一个，从而产生四个不同的局灶性指数。值得注意的是，在此问题中，LCMV和DICS之间的区别是名义上的，因为根据所提供的模拟模型，两种方法计算数据矩阵 $M$ 的过程是相同的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the beamforming focality index problem.\n    It iterates through predefined test cases and prints the results.\n    \"\"\"\n\n    def compute_focality(method, m, n, d_s, d_r, delta, sigma2, alpha, j_star):\n        \"\"\"\n        Computes the focality index for a single beamformer configuration.\n\n        Args:\n            method (str): 'LCMV' or 'DICS'. Nominal in this problem.\n            m (int): Number of sensors.\n            n (int): Number of sources.\n            d_s (float): Distance between sensors.\n            d_r (float): Distance between sources.\n            delta (float): Offset for source positions.\n            sigma2 (float): Noise variance.\n            alpha (float): Regularization parameter.\n            j_star (int): Index of the true source.\n\n        Returns:\n            float: The computed focality index.\n        \"\"\"\n        # Step 1: Construct Matrices\n\n        # 1a. Construct Lead Field Matrix L\n        # Sensor and source positions are generated as 1D arrays.\n        s_pos = np.arange(m, dtype=float) * d_s\n        r_pos = np.arange(n, dtype=float) * d_r + delta\n        # L is computed using broadcasting for efficiency.\n        L = 1.0 / (1.0 + np.abs(s_pos[:, np.newaxis] - r_pos))\n\n        # 1b. Construct Data Matrix M\n        # The model is M = L @ P_s @ L.T + sigma2 * I.\n        # With a single unit-power source at j_star, P_s has only one non-zero\n        # element, P_s[j_star, j_star] = 1. This simplifies the product\n        # L @ P_s @ L.T to an outer product of the j_star-th column of L.\n        l_j_star = L[:, j_star]\n        M = np.outer(l_j_star, l_j_star) + sigma2 * np.identity(m)\n\n        # 1c. Construct Regularized Matrix M_reg\n        trace_M = np.trace(M)\n        reg_term = alpha * (trace_M / m)\n        M_reg = M + reg_term * np.identity(m)\n        \n        # Step 2: Compute Point Spread Function (PSF)\n        p_hat_vec = np.zeros(n)\n        \n        # The inverse of the regularized matrix is pre-computed.\n        M_reg_inv = np.linalg.inv(M_reg)\n\n        for j in range(n):\n            l_j = L[:, j]\n            \n            # 2b. Compute spatial filter w_j using the derived formula.\n            numerator_w = M_reg_inv @ l_j\n            denominator_w = l_j.T @ numerator_w\n            \n            # The denominator should not be zero due to regularization,\n            # but this check ensures robustness.\n            if np.isclose(denominator_w, 0):\n                w_j = np.zeros(m)\n            else:\n                w_j = numerator_w / denominator_w\n            \n            # 2c. Compute reconstructed power p_hat_j using unregularized M.\n            p_hat_j = w_j.T @ M @ w_j\n            p_hat_vec[j] = p_hat_j\n            \n        # Step 3: Compute Focality Index F\n        p_hat_at_true_source = p_hat_vec[j_star]\n        sum_of_all_powers = np.sum(p_hat_vec)\n        \n        # Avoid division by zero if all reconstructed powers are zero.\n        if np.isclose(sum_of_all_powers, 0):\n            return 0.0\n            \n        focality_index = p_hat_at_true_source / sum_of_all_powers\n        \n        return focality_index\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (method, m, n, d_s, d_r, delta, sigma2, alpha, j_star)\n        (\"LCMV\", 6, 5, 1.0, 1.0, 0.5, 0.01, 0.05, 2),\n        (\"LCMV\", 6, 5, 1.0, 1.0, 0.5, 0.000001, 0.10, 3),\n        (\"DICS\", 6, 5, 1.0, 1.0, 0.5, 0.05, 0.05, 1),\n        (\"DICS\", 6, 5, 1.0, 0.2, 0.1, 0.001, 0.05, 4),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and compute focality for each case.\n        focality = compute_focality(*case)\n        results.append(focality)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts each float result to its string representation.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在实践中，我们常常需要区分来自大脑中邻近区域的神经信号，这给源定位带来了挑战。波束形成器将信号从一个源“泄露”或“串扰”到邻近源的估计中是不可避免的。这个练习通过理论推导，旨在量化两个相邻源之间的串扰程度。你将推导出一个解析表达式，揭示串扰如何依赖于源间距和信噪比等关键参数，从而深刻理解波束形成器空间分辨率的内在局限性。",
            "id": "4141721",
            "problem": "在用于源定位的脑磁图/脑电图波束形成中，考虑位于$\\mathbf{r}_{1}$和$\\mathbf{r}_{2}$处的两个邻近的皮层偶极子，每个偶极子都建模为单位振幅、固定方向的电流偶极子，其传感器空间导联场分别为$\\mathbf{l}_{1} \\in \\mathbb{R}^{M}$和$\\mathbf{l}_{2} \\in \\mathbb{R}^{M}$。假设$\\|\\mathbf{l}_{1}\\|_{2} = \\|\\mathbf{l}_{2}\\|_{2} = 1$且$\\mathbf{l}_{1}^{\\top}\\mathbf{l}_{2} = \\rho(d)$，其中$d = \\|\\mathbf{r}_{1} - \\mathbf{r}_{2}\\|_{2}$是源间距离，并且导联场相似度随距离按$\\rho(d) = \\exp(-d/\\lambda)$衰减，其中$\\lambda > 0$为某个空间尺度。传感器噪声为零均值、时间白噪声和各向同性噪声，其协方差为$\\sigma^{2}\\mathbf{I}_{M}$。\n\n假设两个源同时以平稳功率$s^{2}$激活，因此经验传感器协方差可以建模为$\\mathbf{C} = s^{2}(\\mathbf{l}_{1}\\mathbf{l}_{1}^{\\top} + \\mathbf{l}_{2}\\mathbf{l}_{2}^{\\top}) + \\sigma^{2}\\mathbf{I}_{M}$。线性约束最小方差(LCMV)波束形成器为每个候选位置$\\mathbf{r}_{k}$构建一个权重向量$\\mathbf{w}_{k} \\in \\mathbb{R}^{M}$，该向量在单位增益约束$\\mathbf{w}_{k}^{\\top}\\mathbf{l}_{k} = 1$下最小化输出方差$\\mathbf{w}_{k}^{\\top}\\mathbf{C}\\mathbf{w}_{k}$。相干源动态成像(DICS)方法类似地在频域中使用互谱密度进行操作，但在此您将专注于时域的LCMV情况。\n\n定义分辨率矩阵$\\mathbf{R}$，其元素为$R_{ij} = \\mathbf{w}_{i}^{\\top}\\mathbf{l}_{j}$。非对角线元素$R_{21}$量化了从位于$\\mathbf{r}_{1}$的源到位于$\\mathbf{r}_{2}$的波束形成器输出的串扰（泄漏）。请提出一个基于$\\mathbf{R}$的无量纲泄漏度量$L(d)$，该度量概括了作为源间距离$d$的函数的串扰，并在上述假设下，推导$L(d)$关于$d$、空间尺度$\\lambda$以及信噪比参数$\\gamma = s^{2}/\\sigma^{2}$的闭式解析表达式。\n\n将您的最终答案表示为关于$d$、$\\lambda$和$\\gamma$的单一简化解析表达式。无需四舍五入，由于该度量是无量纲的，因此不需要物理单位。",
            "solution": "问题陈述构成了神经科学信号处理领域中一个适定的理论问题。它在科学上基于脑磁图/脑电图(MEG/EEG)源定位的标准模型，提供了一套完整且一致的给定条件，并且不包含任何歧义或事实错误。因此，该问题被认为是有效的，有必要给出完整解答。\n\n我们的目标是首先提出一个无量纲泄漏度量$L(d)$，然后推导其解析表达式。问题指出，从位置$\\mathbf{r}_1$的源到聚焦于位置$\\mathbf{r}_2$的波束形成器的串扰，由分辨率矩阵元素$R_{21} = \\mathbf{w}_{2}^{\\top}\\mathbf{l}_{1}$来量化。波束形成器的单位增益约束$\\mathbf{w}_{2}^{\\top}\\mathbf{l}_{2}=1$意味着分辨率矩阵的对角线元素为1，即$R_{22}=1$。因此，$R_{21}$本身就是一个无量纲量，表示相对于目标源增益的泄漏增益。因此，一个自然且直接的泄漏度量选择是$L(d) = R_{21}$。\n\n位于位置$\\mathbf{r}_k$的线性约束最小方差(LCMV)波束形成器的权重向量$\\mathbf{w}_k$可通过求解以下优化问题找到：\n$$\n\\min_{\\mathbf{w}_k} \\mathbf{w}_k^{\\top}\\mathbf{C}\\mathbf{w}_k \\quad \\text{约束条件为} \\quad \\mathbf{w}_k^{\\top}\\mathbf{l}_k = 1\n$$\n使用拉格朗日乘子法，其解是已知的：\n$$\n\\mathbf{w}_k = \\frac{\\mathbf{C}^{-1}\\mathbf{l}_k}{\\mathbf{l}_k^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_k}\n$$\n其中$\\mathbf{C}^{-1}$是传感器协方差矩阵的逆矩阵。\n\n使用$\\mathbf{w}_2$的这个表达式，我们提出的泄漏度量变为：\n$$\nL(d) = R_{21} = \\mathbf{w}_2^{\\top}\\mathbf{l}_1 = \\frac{(\\mathbf{C}^{-1}\\mathbf{l}_2)^{\\top}\\mathbf{l}_1}{\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2} = \\frac{\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_1}{\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2}\n$$\n最后一步利用了协方差矩阵$\\mathbf{C}$及其逆矩阵$\\mathbf{C}^{-1}$的对称性。\n\n为了继续，我们必须计算$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_1$和$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2$这两项。协方差矩阵由$\\mathbf{C} = s^{2}(\\mathbf{l}_{1}\\mathbf{l}_{1}^{\\top} + \\mathbf{l}_{2}\\mathbf{l}_{2}^{\\top}) + \\sigma^{2}\\mathbf{I}_{M}$给出。令信噪比参数为$\\gamma = s^2/\\sigma^2$。我们可以将$\\mathbf{C}$写为$\\mathbf{C} = \\sigma^2(\\gamma(\\mathbf{l}_1\\mathbf{l}_1^{\\top} + \\mathbf{l}_2\\mathbf{l}_2^{\\top}) + \\mathbf{I}_{M})$。\n\n让我们找到$\\mathbf{C}^{-1}\\mathbf{v}$的一个通用表达式，其中$\\mathbf{v}$位于由$\\mathbf{l}_1$和$\\mathbf{l}_2$张成的子空间中。任何这样的向量都可以写成$\\mathbf{v} = v_1 \\mathbf{l}_1 + v_2 \\mathbf{l}_2$。由于算子$\\gamma(\\mathbf{l}_1\\mathbf{l}_1^{\\top} + \\mathbf{l}_2\\mathbf{l}_2^{\\top})$仅作用于此子空间内，其逆映射$\\mathbf{C}^{-1}\\mathbf{v}$也必定位于此子空间中。因此，我们可以将$\\mathbf{C}^{-1}\\mathbf{v}$写成$\\mathbf{C}^{-1}\\mathbf{v} = a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2$，其中$a_1, a_2$是某些系数。我们从方程$\\mathbf{C}(a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2) = \\mathbf{v}$中解出这些系数：\n$$\n\\sigma^2(\\gamma(\\mathbf{l}_1\\mathbf{l}_1^{\\top} + \\mathbf{l}_2\\mathbf{l}_2^{\\top}) + \\mathbf{I}_{M})(a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2) = v_1\\mathbf{l}_1 + v_2\\mathbf{l}_2\n$$\n令$\\rho = \\mathbf{l}_1^{\\top}\\mathbf{l}_2$。使用给定的归一化条件$\\|\\mathbf{l}_1\\|_2 = 1$和$\\|\\mathbf{l}_2\\|_2 = 1$，我们展开左侧：\n$$\n\\sigma^2\\{\\gamma\\mathbf{l}_1(a_1\\|\\mathbf{l}_1\\|^2 + a_2\\mathbf{l}_1^{\\top}\\mathbf{l}_2) + \\gamma\\mathbf{l}_2(a_1\\mathbf{l}_2^{\\top}\\mathbf{l}_1 + a_2\\|\\mathbf{l}_2\\|^2) + a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2\\} = v_1\\mathbf{l}_1 + v_2\\mathbf{l}_2\n$$\n$$\n\\sigma^2\\{(\\gamma(a_1 + a_2\\rho) + a_1)\\mathbf{l}_1 + (\\gamma(a_1\\rho + a_2) + a_2)\\mathbf{l}_2\\} = v_1\\mathbf{l}_1 + v_2\\mathbf{l}_2\n$$\n假设$\\mathbf{l}_1$和$\\mathbf{l}_2$不共线（即$\\rho^2 \\neq 1$），我们可以令$\\mathbf{l}_1$和$\\mathbf{l}_2$的系数相等：\n$$\n\\begin{cases} \\sigma^2((1+\\gamma)a_1 + \\gamma\\rho a_2) = v_1 \\\\ \\sigma^2(\\gamma\\rho a_1 + (1+\\gamma)a_2) = v_2 \\end{cases}\n$$\n这可以写成矩阵形式：\n$$\n\\sigma^2 \\begin{pmatrix} 1+\\gamma  \\gamma\\rho \\\\ \\gamma\\rho  1+\\gamma \\end{pmatrix} \\begin{pmatrix} a_1 \\\\ a_2 \\end{pmatrix} = \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix}\n$$\n令$\\mathbf{M} = \\begin{pmatrix} 1+\\gamma  \\gamma\\rho \\\\ \\gamma\\rho  1+\\gamma \\end{pmatrix}$。解为$\\begin{pmatrix} a_1 \\\\ a_2 \\end{pmatrix} = \\frac{1}{\\sigma^2} \\mathbf{M}^{-1} \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix}$。\n\n为计算$L(d)$的分子$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_1$，我们设$\\mathbf{v}=\\mathbf{l}_1$，因此$v_1=1, v_2=0$。那么$\\mathbf{C}^{-1}\\mathbf{l}_1 = a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2$。我们需要计算$\\mathbf{l}_2^{\\top}(a_1\\mathbf{l}_1 + a_2\\mathbf{l}_2) = a_1\\rho + a_2$。根据矩阵方程，$a_1$和$a_2$是$\\frac{1}{\\sigma^2}\\mathbf{M}^{-1}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$的元素。$\\mathbf{M}$的行列式是$D_M = (1+\\gamma)^2 - (\\gamma\\rho)^2$。\n$\\mathbf{M}^{-1} = \\frac{1}{D_M}\\begin{pmatrix} 1+\\gamma  -\\gamma\\rho \\\\ -\\gamma\\rho  1+\\gamma \\end{pmatrix}$。\n$\\begin{pmatrix} a_1 \\\\ a_2 \\end{pmatrix} = \\frac{1}{\\sigma^2 D_M}\\begin{pmatrix} 1+\\gamma \\\\ -\\gamma\\rho \\end{pmatrix}$。\n分子是$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_1 = a_1\\rho + a_2 = \\frac{(1+\\gamma)\\rho}{\\sigma^2 D_M} - \\frac{\\gamma\\rho}{\\sigma^2 D_M} = \\frac{\\rho}{\\sigma^2 D_M}$。\n\n为计算$L(d)$的分母$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2$，我们设$\\mathbf{v}=\\mathbf{l}_2$，因此$v_1=0, v_2=1$。令$\\mathbf{C}^{-1}\\mathbf{l}_2 = a_1'\\mathbf{l}_1 + a_2'\\mathbf{l}_2$。分母是$\\mathbf{l}_2^{\\top}(a_1'\\mathbf{l}_1 + a_2'\\mathbf{l}_2) = a_1'\\rho + a_2'$。\n$\\begin{pmatrix} a_1' \\\\ a_2' \\end{pmatrix} = \\frac{1}{\\sigma^2}\\mathbf{M}^{-1}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{\\sigma^2 D_M}\\begin{pmatrix} -\\gamma\\rho \\\\ 1+\\gamma \\end{pmatrix}$。\n分母是$\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2 = a_1'\\rho + a_2' = \\frac{-\\gamma\\rho^2}{\\sigma^2 D_M} + \\frac{1+\\gamma}{\\sigma^2 D_M} = \\frac{1+\\gamma-\\gamma\\rho^2}{\\sigma^2 D_M}$。\n\n现在，我们计算$L(d)$的比率：\n$$\nL(d) = \\frac{\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_1}{\\mathbf{l}_2^{\\top}\\mathbf{C}^{-1}\\mathbf{l}_2} = \\frac{\\rho/(\\sigma^2 D_M)}{(1+\\gamma-\\gamma\\rho^2)/(\\sigma^2 D_M)} = \\frac{\\rho}{1+\\gamma-\\gamma\\rho^2} = \\frac{\\rho}{1+\\gamma(1-\\rho^2)}\n$$\n最后，我们代入给定的导联场相似度表达式$\\rho(d) = \\exp(-d/\\lambda)$：\n$$\nL(d) = \\frac{\\exp(-d/\\lambda)}{1+\\gamma(1 - (\\exp(-d/\\lambda))^2)} = \\frac{\\exp(-d/\\lambda)}{1+\\gamma(1 - \\exp(-2d/\\lambda))}\n$$\n这就是所提出的泄漏度量的闭式解析表达式，它是源间距离$d$、空间尺度$\\lambda$和信噪比参数$\\gamma$的函数。",
            "answer": "$$\n\\boxed{\\frac{\\exp(-d/\\lambda)}{1+\\gamma(1 - \\exp(-2d/\\lambda))}}\n$$"
        },
        {
            "introduction": "理论分析和基础实现是理解算法的第一步，但要在实际研究中应用这些方法，必须对其在不同条件下的性能有定量的认识。本练习是一个综合性的实践项目，你将设计并执行一个蒙特卡洛模拟，系统地评估LCMV波束形成器的定位精度。通过生成合成数据，应用波束形成算法，并统计分析定位误差与数据长度、正则化强度等关键参数的关系，你将体验到研究者验证和表征其分析方法的全过程。",
            "id": "4141681",
            "problem": "您的任务是设计并实现一个蒙特卡洛模拟，在一个受控的合成脑电图（EEG）传感器阵列场景中，量化线性约束最小方差（LCMV）波束形成器在不同样本量和正则化强度下的定位误差分布。该模拟必须从线性前向模型和LCMV优化问题的定义开始，推导出源扫描所需的算法步骤，并计算定位误差分布的汇总统计数据。所有涉及物理距离的量都必须以米为单位表示。您的最终程序必须为预定义的测试套件生成指定的聚合汇总输出。\n\n基本和模型假设：\n- 对多通道神经测量使用线性前向模型。假设有$M$个传感器，在$N$个时间样本上采集了测量数据。传感器阵列被建模为在平面上一个半径为$R$的圆上放置$M$个传感器。位于$\\mathbf{r}_{\\text{true}}$处的单个神经源生成一个标量时间序列$s(t)$，它通过一个导联场向量$\\mathbf{l}(\\mathbf{r}_{\\text{true}}) \\in \\mathbb{R}^M$线性映射到传感器。在时间$t$观测到的数据由下式给出\n$$\n\\mathbf{x}(t) = s(t)\\,\\mathbf{l}(\\mathbf{r}_{\\text{true}}) + \\mathbf{n}(t),\n$$\n其中$\\mathbf{n}(t)$是加性传感器噪声。\n- 样本协方差矩阵$\\widehat{\\mathbf{C}} \\in \\mathbb{R}^{M \\times M}$是使用标准估计器根据去均值后的数据计算得出的\n$$\n\\widehat{\\mathbf{C}} = \\frac{1}{N} \\sum_{t=1}^{N} \\left( \\mathbf{x}(t) - \\bar{\\mathbf{x}} \\right)\\left( \\mathbf{x}(t) - \\bar{\\mathbf{x}} \\right)^\\top,\n$$\n其中$\\bar{\\mathbf{x}}$是跨时间的样本均值。\n- 正则化以加性Tikhonov正则化的形式应用\n$$\n\\widehat{\\mathbf{C}}_{\\lambda} = \\widehat{\\mathbf{C}} + \\lambda \\,\\alpha\\, \\mathbf{I},\n$$\n其中$\\lambda \\ge 0$是正则化强度，$\\alpha = \\frac{\\operatorname{trace}(\\widehat{\\mathbf{C}})}{M}$提供单位缩放，$\\mathbf{I}$是单位矩阵。\n\n波束形成目标：\n- 线性约束最小方差（LCMV）波束形成器由以下约束优化问题定义\n$$\n\\min_{\\mathbf{w} \\in \\mathbb{R}^M} \\quad \\mathbf{w}^\\top \\widehat{\\mathbf{C}}_{\\lambda}\\, \\mathbf{w} \\quad \\text{subject to} \\quad \\mathbf{w}^\\top \\mathbf{l}(\\mathbf{r}) = 1,\n$$\n对于预定义扫描网格中的每个候选源位置$\\mathbf{r}$。您必须从此公式中推导出用于对每个位置进行评分并选择估计源位置$\\widehat{\\mathbf{r}}$的所有必要量。\n\n导联场：\n- 在均匀介质中使用简化的准静态前向模型，其中对于位于$\\mathbf{r}$的标量源，其导联场在传感器位置$\\mathbf{s}_m$处的分量定义为\n$$\nl_m(\\mathbf{r}) = \\frac{1}{\\|\\mathbf{r} - \\mathbf{s}_m\\|^2},\n$$\n对于$m = 1, \\ldots, M$，其中$\\|\\cdot\\|$是欧几里得范数。这一选择确保了物理上随距离的衰减以及传感器间非平凡的空间模式。\n\n传感器阵列和扫描网格：\n- 将$M = 12$个传感器放置在一个半径为$R = 0.09$米的圆上，在$z=0$平面上角度均匀分布，并以原点为中心。真实源位置为$\\mathbf{r}_{\\text{true}} = (0.03, -0.02, 0)$米。\n- 在$z=0$平面中定义一个二维扫描网格，包含候选源位置，其范围覆盖$x,y \\in [-0.06, 0.06]$米，均匀步长为$0.01$米。对于每个网格位置$\\mathbf{r}$，计算导联场$\\mathbf{l}(\\mathbf{r})$。\n\n噪声和信号生成：\n- 对于每次蒙特卡洛试验，将源样本$s(t)$生成为均值为零、方差为$\\sigma_s^2$的独立高斯随机变量，即\n$$\ns(t) \\sim \\mathcal{N}(0, \\sigma_s^2).\n$$\n- 从一个均值为零、协方差为\n$$\n\\boldsymbol{\\Sigma}_n = \\sigma_n^2 \\left[ (1-\\rho)\\,\\mathbf{I} + \\rho\\,\\mathbf{1}\\mathbf{1}^\\top \\right],\n$$\n的多元高斯分布中生成传感器噪声$\\mathbf{n}(t)$，其中$\\mathbf{1} \\in \\mathbb{R}^M$是一个全为1的向量，$\\rho \\in [0,1)$控制传感器间的相关性，$\\sigma_n^2$控制噪声功率。使用$\\sigma_s^2 = 1.0$，$\\sigma_n = 0.1$和$\\rho = 0.1$。这些设置提供了真实的信噪比，并确保了$\\boldsymbol{\\Sigma}_n$的正定性。\n\n定位误差度量：\n- 对于每次试验，使用从上述优化问题中推导出的LCMV准则，在网格上执行源扫描，以选择估计位置$\\widehat{\\mathbf{r}}$。计算定位误差\n$$\ne = \\left\\| \\widehat{\\mathbf{r}} - \\mathbf{r}_{\\text{true}} \\right\\|,\n$$\n以米为单位表示。\n\n蒙特卡洛协议：\n- 对于每个参数对$(N, \\lambda)$，运行$T$次独立试验（具有独立的信号和噪声抽取），计算样本协方差$\\widehat{\\mathbf{C}}$，应用正则化，执行源扫描以找到$\\widehat{\\mathbf{r}}$，并记录以米为单位的定位误差$e$。\n- 对每个参数对使用$T = 200$次试验。\n\n测试套件：\n- 评估以下参数对$(N, \\lambda)$：\n    1. $(24, 0.0)$\n    2. $(24, 10^{-3})$\n    3. $(64, 0.0)$\n    4. $(64, 10^{-3})$\n    5. $(256, 0.0)$\n    6. $(256, 10^{-2})$\n\n要求输出：\n- 对于每个参数对，计算并返回在$T$次试验中定位误差分布的以下汇总统计数据：\n    1. 平均定位误差$\\overline{e}$，单位为米。\n    2. 定位误差的标准差$\\operatorname{std}(e)$，单位为米。\n    3. 定位误差的经验$0.95$分位数（第95百分位数）$q_{0.95}$，单位为米。\n- 您的程序应生成单行输出，包含所有参数对的结果，格式化为方括号内以逗号分隔的列表。每个对应于一个参数对的元素本身必须是一个形式为$[N, \\lambda, \\overline{e}, \\operatorname{std}(e), q_{0.95}]$的列表，例如：\n$$\n\\left[ [24, 0.0, 0.0123, 0.0045, 0.0199], [24, 0.001, \\ldots], \\ldots \\right]\n$$\n所有距离都必须以米表示，所有数值输出都应为十进制形式（不涉及百分比或角度单位）。",
            "solution": "该问题定义明确且具有科学依据。我们将着手提供解决方案。\n\n目标是通过蒙特卡洛模拟来量化线性约束最小方差（LCMV）波束形成器的定位性能。该分析基于一个合成脑电图（EEG）场景，该场景由一个线性前向模型、特定的传感器几何形状以及信号和噪声的统计模型定义。\n\n**1. 理论框架**\n\n**1.1. 前向模型与数据生成**\n神经源活动与传感器测量值之间的关系由线性前向模型描述。对于位于$\\mathbf{r}_{\\text{true}}$处、时间序列为$s(t)$的单个源，来自$M$个传感器的阵列的测量值$\\mathbf{x}(t) \\in \\mathbb{R}^M$由下式给出：\n$$\n\\mathbf{x}(t) = s(t)\\,\\mathbf{l}(\\mathbf{r}_{\\text{true}}) + \\mathbf{n}(t)\n$$\n这里，$\\mathbf{l}(\\mathbf{r}_{\\text{true}}) \\in \\mathbb{R}^M$是导联场向量，它将源映射到传感器，而$\\mathbf{n}(t) \\in \\mathbb{R}^M$是加性传感器噪声。\n\n在模拟中，每个时间样本$t$的源信号$s(t)$是从一个均值为零、方差为$\\sigma_s^2 = 1.0$的高斯分布中独立抽取的：\n$$\ns(t) \\sim \\mathcal{N}(0, \\sigma_s^2)\n$$\n传感器噪声$\\mathbf{n}(t)$是从一个均值为零、具有结构化协方差矩阵$\\boldsymbol{\\Sigma}_n$的多元高斯分布中抽取的：\n$$\n\\mathbf{n}(t) \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_n)\n$$\n其中$\\boldsymbol{\\Sigma}_n = \\sigma_n^2 \\left[ (1-\\rho)\\,\\mathbf{I} + \\rho\\,\\mathbf{1}\\mathbf{1}^\\top \\right]$。参数设置为$\\sigma_n = 0.1$和$\\rho = 0.1$，这引入了基线噪声水平和传感器间的空间相关性。$\\mathbf{I}$是$M \\times M$的单位矩阵，$\\mathbf{1}$是一个全为1的向量。假设信号和噪声不相关。\n\n**1.2. 导联场模型**\n导联场模型描述了每个传感器对源的灵敏度。对于位于$\\mathbf{r}$的源，第$m$个传感器（位于$\\mathbf{s}_m$）的导联场分量$l_m(\\mathbf{r})$由一个简化的准静态模型给出：\n$$\nl_m(\\mathbf{r}) = \\frac{1}{\\|\\mathbf{r} - \\mathbf{s}_m\\|^2}\n$$\n该模型表示信号强度随距离平方衰减，这是物理场中的一个共同特征。\n\n**1.3. 协方差估计与正则化**\nLCMV波束形成器依赖于数据的二阶统计量，由协方差矩阵捕获。给定$N$个时间样本的数据，样本协方差矩阵$\\widehat{\\mathbf{C}}$估计为：\n$$\n\\widehat{\\mathbf{C}} = \\frac{1}{N} \\sum_{t=1}^{N} \\left( \\mathbf{x}(t) - \\bar{\\mathbf{x}} \\right)\\left( \\mathbf{x}(t) - \\bar{\\mathbf{x}} \\right)^\\top\n$$\n其中$\\bar{\\mathbf{x}}$是时间平均的测量向量。在实践中，特别是当样本数量$N$较小时，$\\widehat{\\mathbf{C}}$可能是病态的。为提高其稳定性，应用了Tikhonov正则化：\n$$\n\\widehat{\\mathbf{C}}_{\\lambda} = \\widehat{\\mathbf{C}} + \\lambda \\,\\alpha\\, \\mathbf{I}\n$$\n正则化参数为$\\lambda \\ge 0$。缩放因子$\\alpha = \\frac{\\operatorname{trace}(\\widehat{\\mathbf{C}})}{M}$将正则化强度相对于平均传感器功率进行归一化，使得$\\lambda$的选择对整体信号幅度的依赖性降低。\n\n**2. LCMV波束形成器推导与源定位**\n\n**2.1. 优化问题**\nLCMV波束形成器通过构建一个空间滤波器$\\mathbf{w}(\\mathbf{r}) \\in \\mathbb{R}^M$来估计特定位置$\\mathbf{r}$处的源活动。该滤波器被设计为以单位增益通过来自位置$\\mathbf{r}$的信号，同时最小化滤波器的输出功率（方差），从而抑制来自噪声和其他位置的贡献。这被表述为一个约束优化问题：\n$$\n\\min_{\\mathbf{w} \\in \\mathbb{R}^M} \\mathbf{w}^\\top \\widehat{\\mathbf{C}}_{\\lambda}\\, \\mathbf{w} \\quad \\text{subject to} \\quad \\mathbf{w}^\\top \\mathbf{l}(\\mathbf{r}) = 1\n$$\n**2.2. 空间滤波器的推导**\n这个问题可以使用拉格朗日乘子法求解。拉格朗日函数为：\n$$\n\\mathcal{L}(\\mathbf{w}, \\mu) = \\mathbf{w}^\\top \\widehat{\\mathbf{C}}_{\\lambda}\\, \\mathbf{w} - \\mu \\left(\\mathbf{w}^\\top \\mathbf{l}(\\mathbf{r}) - 1\\right)\n$$\n对$\\mathbf{w}$求梯度并令其为零，得到：\n$$\n\\nabla_{\\mathbf{w}} \\mathcal{L} = 2 \\widehat{\\mathbf{C}}_{\\lambda} \\mathbf{w} - \\mu \\mathbf{l}(\\mathbf{r}) = \\mathbf{0} \\implies \\mathbf{w} = \\frac{\\mu}{2} \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})\n$$\n通过施加约束$\\mathbf{w}^\\top \\mathbf{l}(\\mathbf{r}) = 1$来找到拉格朗日乘子$\\mu$：\n$$\n\\left(\\frac{\\mu}{2} \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})\\right)^\\top \\mathbf{l}(\\mathbf{r}) = 1 \\implies \\frac{\\mu}{2} \\left( \\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r}) \\right) = 1\n$$\n求解$\\frac{\\mu}{2}$可得$\\frac{\\mu}{2} = \\frac{1}{\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})}$。将其代回$\\mathbf{w}$的表达式，得到位置$\\mathbf{r}$的最优空间滤波器：\n$$\n\\mathbf{w}(\\mathbf{r}) = \\frac{\\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})}{\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})}\n$$\n\n**2.3. 通过功率扫描进行源定位**\n对于位于位置$\\mathbf{r}$的源，波束形成器的输出功率为$P(\\mathbf{r}) = \\mathbf{w}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda} \\mathbf{w}(\\mathbf{r})$。代入最优滤波器$\\mathbf{w}(\\mathbf{r})$得到：\n$$\nP(\\mathbf{r}) = \\frac{\\left(\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1}\\right) \\widehat{\\mathbf{C}}_{\\lambda} \\left(\\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})\\right)}{\\left(\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})\\right)^2} = \\frac{\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})}{\\left(\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})\\right)^2} = \\frac{1}{\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})}\n$$\n为了定位源，我们在一个预定义的候选位置网格上进行扫描。对于每个网格点$\\mathbf{r}_j$，我们计算输出功率$P(\\mathbf{r}_j)$。产生最大功率的位置被选为估计的源位置$\\widehat{\\mathbf{r}}$：\n$$\n\\widehat{\\mathbf{r}} = \\arg\\max_{\\mathbf{r} \\in \\text{grid}} P(\\mathbf{r}) = \\arg\\max_{\\mathbf{r} \\in \\text{grid}} \\left( \\frac{1}{\\mathbf{l}(\\mathbf{r})^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r})} \\right)\n$$\n\n**3. 蒙特卡洛模拟协议**\n\n该模拟量化了对于不同样本量$N$和正则化强度$\\lambda$的定位误差$e = \\| \\widehat{\\mathbf{r}} - \\mathbf{r}_{\\text{true}} \\|$的分布。\n\n**设置：**\n- 传感器阵列：$M = 12$个传感器放置在半径为$R = 0.09$米的圆上，位于$z=0$平面，以原点为中心。坐标为$\\mathbf{s}_m = (R \\cos(2\\pi m/M), R \\sin(2\\pi m/M), 0)$，其中$m=0, \\ldots, 11$。\n- 真实源位置：$\\mathbf{r}_{\\text{true}} = (0.03, -0.02, 0)$米。\n- 扫描网格：一个在$z=0$平面内的二维网格，其$x$和$y$坐标范围为$[-0.06, 0.06]$米，步长为$0.01$米。\n- 试验：对于每个$(N, \\lambda)$对，运行$T = 200$次独立试验。\n\n**对于每次试验：**\n1.  **生成数据**：对于给定的$N$，根据指定的模型生成$N$个源信号$s(t)$和传感器噪声$\\mathbf{n}(t)$的样本。构建$M \\times N$的数据矩阵$\\mathbf{X}$。\n2.  **估计协方差**：从$\\mathbf{X}$计算样本协方差矩阵$\\widehat{\\mathbf{C}}$。\n3.  **正则化协方差**：计算$\\widehat{\\mathbf{C}}_{\\lambda} = \\widehat{\\mathbf{C}} + \\lambda \\frac{\\operatorname{trace}(\\widehat{\\mathbf{C}})}{M} \\mathbf{I}$。\n4.  **执行扫描**：\n    - 对正则化协方差矩阵求逆以得到$\\widehat{\\mathbf{C}}_{\\lambda}^{-1}$。\n    - 对于扫描网格上的每个点$\\mathbf{r}_j$，计算导联场$\\mathbf{l}(\\mathbf{r}_j)$，然后计算波束形成器功率$P(\\mathbf{r}_j) = (\\mathbf{l}(\\mathbf{r}_j)^\\top \\widehat{\\mathbf{C}}_{\\lambda}^{-1} \\mathbf{l}(\\mathbf{r}_j))^{-1}$。\n    - 将具有最大功率的网格点确定为估计的源位置$\\widehat{\\mathbf{r}}$。\n5.  **计算误差**：计算欧几里得距离$e = \\| \\widehat{\\mathbf{r}} - \\mathbf{r}_{\\text{true}} \\|$。\n\n**分析：**\n对于测试套件中的每个$(N, \\lambda)$对，收集$T=200$个定位误差的集合$\\{e_i\\}_{i=1}^{200}$。然后计算以下汇总统计数据：\n- 平均误差：$\\overline{e} = \\frac{1}{T} \\sum_{i=1}^T e_i$。\n- 误差的标准差：$\\operatorname{std}(e) = \\sqrt{\\frac{1}{T-1} \\sum_{i=1}^T (e_i - \\overline{e})^2}$。\n- 误差的第$95$百分位数：$q_{0.95}$，即$95\\%$的观测误差低于此值。\n\n这些步骤通过编程实现，以生成指定测试套件所需的输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a Monte Carlo simulation to quantify the localization\n    error distribution of the LCMV beamformer.\n    \"\"\"\n    # Set a seed for reproducibility of random number generation.\n    np.random.seed(0)\n\n    # --- Fixed Parameters ---\n    M = 12  # Number of sensors\n    R = 0.09  # Radius of sensor circle in meters\n    r_true = np.array([0.03, -0.02, 0.0])  # True source location in meters\n    sigma_s2 = 1.0  # Source signal variance\n    sigma_n = 0.1  # Sensor noise standard deviation\n    rho = 0.1  # Sensor noise correlation\n    T = 200  # Number of Monte Carlo trials per condition\n\n    # --- Sensor Array and Scanning Grid Setup ---\n    # Sensor positions\n    thetas = np.linspace(0, 2 * np.pi, M, endpoint=False)\n    sensor_pos = np.zeros((M, 3))\n    sensor_pos[:, 0] = R * np.cos(thetas)\n    sensor_pos[:, 1] = R * np.sin(thetas)\n\n    # Scanning grid positions\n    grid_coords = np.arange(-0.06, 0.061, 0.01) # Use 0.061 to include endpoint\n    grid_x, grid_y = np.meshgrid(grid_coords, grid_coords)\n    grid_points = np.vstack([grid_x.ravel(), grid_y.ravel(), np.zeros(grid_x.size)]).T\n\n    # --- Pre-computation ---\n    # Lead fields for all grid points\n    # L_grid has shape (M, num_grid_points)\n    dist_sq_grid = np.sum((grid_points[np.newaxis, :, :] - sensor_pos[:, np.newaxis, :])**2, axis=2)\n    # Avoid division by zero if a grid point coincides with a sensor\n    dist_sq_grid[dist_sq_grid == 0] = 1e-12 \n    L_grid = 1.0 / dist_sq_grid\n    \n    # Lead field for the true source location\n    dist_sq_true = np.sum((r_true - sensor_pos)**2, axis=1)\n    l_true = 1.0 / dist_sq_true\n    l_true = l_true[:, np.newaxis] # Shape (M, 1)\n\n    # Noise covariance matrix\n    I = np.eye(M)\n    ones_vec = np.ones((M, M))\n    Sigma_n = sigma_n**2 * ((1 - rho) * I + rho * ones_vec)\n    noise_mean = np.zeros(M)\n    \n    # Test suite from the problem statement\n    test_cases = [\n        (24, 0.0),\n        (24, 10**-3),\n        (64, 0.0),\n        (64, 10**-3),\n        (256, 0.0),\n        (256, 10**-2),\n    ]\n\n    results = []\n\n    for N, lam in test_cases:\n        localization_errors = np.zeros(T)\n\n        for t in range(T):\n            # 1. Data Generation\n            s = np.random.normal(0, np.sqrt(sigma_s2), size=N)\n            n = np.random.multivariate_normal(noise_mean, Sigma_n, size=N).T # Shape (M, N)\n            x = l_true * s + n  # Signal + Noise, shape (M, N)\n\n            # 2. Covariance Estimation\n            x_demeaned = x - np.mean(x, axis=1, keepdims=True)\n            C_hat = (x_demeaned @ x_demeaned.T) / N\n\n            # 3. Regularization\n            alpha = np.trace(C_hat) / M\n            C_lam = C_hat + lam * alpha * I\n\n            # 4. Source Scanning\n            try:\n                C_lam_inv = np.linalg.inv(C_lam)\n                # Denominator of power expression: l(r)^T * C_inv * l(r)\n                # Vectorized computation for all grid points\n                denominators = np.sum(L_grid * (C_lam_inv @ L_grid), axis=0)\n                # Power is 1/denominator; find max power\n                best_idx = np.argmax(1.0 / denominators)\n            except np.linalg.LinAlgError:\n                # If matrix is singular (can happen with lambda=0), localization fails.\n                # A robust simulation would handle this, but for this specific problem\n                # setup, N > M so the matrix is invertible with probability 1.\n                # We add the handler as a safeguard.\n                max_grid_err = np.max(np.linalg.norm(grid_points - r_true, axis=1))\n                localization_errors[t] = max_grid_err\n                continue\n\n            r_hat = grid_points[best_idx]\n\n            # 5. Error Calculation\n            error = np.linalg.norm(r_hat - r_true)\n            localization_errors[t] = error\n        \n        # --- Summary Statistics ---\n        mean_e = np.mean(localization_errors)\n        std_e = np.std(localization_errors, ddof=1) # Sample standard deviation\n        q95_e = np.quantile(localization_errors, 0.95)\n        \n        result_tuple = [N, lam, mean_e, std_e, q95_e]\n        results.append(result_tuple)\n\n    # Format the final output string\n    # str(list) produces '[val1, val2, ...]' which matches the format\n    formatted_results = ','.join(map(str, results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}