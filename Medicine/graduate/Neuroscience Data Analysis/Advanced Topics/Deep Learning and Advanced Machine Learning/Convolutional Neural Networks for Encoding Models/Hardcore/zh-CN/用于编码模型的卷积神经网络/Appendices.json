{
    "hands_on_practices": [
        {
            "introduction": "要有效地将卷积神经网络（CNN）用作编码模型，我们必须首先掌握其基本机制。这个初步练习聚焦于最基础的操作：单个卷积层的前向传播。通过推导并应用输出维度的计算公式，您将具体理解核尺寸、步幅和填充等超参数如何改变刺激的空间表征 。",
            "id": "4149684",
            "problem": "神经科学中的一个视觉编码模型使用卷积神经网络 (CNN) 将二维刺激转换为排列在视网膜拓扑网格上的预测响应。考虑一个应用于空间高度为 $H$、空间宽度为 $W$、通道数为 $C$ 的输入张量（形状记为 $(H, W, C)$）的二维卷积层。该层使用空间尺寸为 $k \\times k$ 的方形卷积核，在两个空间维度上的步幅均为 $s$，并在空间边界上对称应用宽度为 $p$ 的零填充。该层有 $F$ 个滤波器，每个滤波器产生一个输出特征图。假设卷积以带有步幅和零填充的标准离散形式实现，并且卷积核不会延伸到填充后的输入之外。\n\n从零填充输入上的离散卷积定义以及将步幅解释为连续卷积核放置之间的步长出发，推导出当卷积核仅放置在与填充后的输入完全重叠的位置时，所产生的输出空间维度的一般表达式。然后，在一个具体的编码场景中，刺激是一个单通道视网膜拓扑图，其参数为 $H=95$，$W=127$，$C=1$，卷积层参数为 $k=11$，$s=4$，$p=3$，$F=32$，计算由此产生的输出张量形状 $(H_{\\text{out}}, W_{\\text{out}}, F)$。请将你的最终答案表示为有序三元组 $(H_{\\text{out}}, W_{\\text{out}}, F)$。无需进行四舍五入。",
            "solution": "该问题要求推导二维卷积层输出维度的一般公式，并针对一组特定参数计算这些维度。\n\n首先，我们推导通用表达式。让我们考虑单个空间维度，例如高度。输入的高度为 $H$。应用宽度为 $p$ 的对称零填充，意味着在顶部和底部各添加 $p$ 行零。因此，这个填充后输入张量的有效高度为 $H' = H + 2p$。\n\n卷积核的空间高度为 $k$。我们需要确定该卷积核在填充后的输入上可以放置的可能位置的数量。卷积核以步幅 $s$ 为间隔在不同位置上应用。这些位置由卷积核的左上角确定。\n\n设填充后高度维度的索引从 $0$ 到 $H' - 1$。卷积核的第一次放置，其顶部边缘将在索引 $0$ 处。第二次放置将在索引 $s$ 处，第三次在 $2s$ 处，依此类推。设第 $j$ 次放置的顶部边缘位于索引 $i_j = j \\cdot s$ 处，其中 $j$ 是一个从零开始的索引（$j = 0, 1, 2, \\dots$）。\n\n问题陈述，卷积核必须完全重叠填充后的输入。这意味着整个高度为 $k$ 的卷积核必须完全位于高度为 $H'$ 的填充后输入的边界之内。如果卷积核的顶部边缘位于索引 $i_j$ 处，则卷积核跨越的索引范围为从 $i_j$ 到 $i_j + k - 1$。为了使卷积核被完全包含，我们必须有：\n$$i_j + k - 1 \\leq H' - 1$$\n$$i_j \\leq H' - k$$\n代入 $i_j = j \\cdot s$ 和 $H' = H + 2p$，我们得到：\n$$j \\cdot s \\leq (H + 2p) - k$$\n为了找到有效放置位置的最大数量，我们需要找到满足此不等式的 $j$ 的最大整数值，我们称之为 $j_{\\max}$。\n$$j_{\\max} = \\left\\lfloor \\frac{H + 2p - k}{s} \\right\\rfloor$$\n$j$ 的可能取值为 $0, 1, 2, \\dots, j_{\\max}$。这些值的总数是 $j_{\\max} + 1$。$j$ 的每个值对应输出特征图中的一个位置。因此，输出特征图的高度 $H_{\\text{out}}$ 为：\n$$H_{\\text{out}} = j_{\\max} + 1 = \\left\\lfloor \\frac{H + 2p - k}{s} \\right\\rfloor + 1$$\n相同的逻辑独立地适用于宽度维度。宽度为 $W$ 的输入经过对称填充 $p$ 后，变为宽度为 $W' = W + 2p$ 的填充后输入。输出宽度 $W_{\\text{out}}$ 由类似的公式给出：\n$$W_{\\text{out}} = \\left\\lfloor \\frac{W + 2p - k}{s} \\right\\rfloor + 1$$\n输出张量的通道数（或深度）由滤波器的数量 $F$ 决定。每个滤波器与输入体（跨越所有 $C$ 个输入通道）进行卷积，以产生一个二维特征图。因此，使用 $F$ 个滤波器，输出张量的深度将为 $F$。因此，输出张量的形状为 $(H_{\\text{out}}, W_{\\text{out}}, F)$。\n\n现在，我们将这些推导出的公式应用于所提供的具体场景。给定参数如下：\n- 输入高度 $H = 95$\n- 输入宽度 $W = 127$\n- 输入通道数 $C = 1$\n- 卷积核大小 $k = 11$\n- 步幅 $s = 4$\n- 填充宽度 $p = 3$\n- 滤波器数量 $F = 32$\n\n我们计算输出高度 $H_{\\text{out}}$：\n$$H_{\\text{out}} = \\left\\lfloor \\frac{H + 2p - k}{s} \\right\\rfloor + 1$$\n$$H_{\\text{out}} = \\left\\lfloor \\frac{95 + 2(3) - 11}{4} \\right\\rfloor + 1$$\n$$H_{\\text{out}} = \\left\\lfloor \\frac{95 + 6 - 11}{4} \\right\\rfloor + 1$$\n$$H_{\\text{out}} = \\left\\lfloor \\frac{90}{4} \\right\\rfloor + 1$$\n$$H_{\\text{out}} = \\lfloor 22.5 \\rfloor + 1$$\n$$H_{\\text{out}} = 22 + 1 = 23$$\n接下来，我们计算输出宽度 $W_{\\text{out}}$：\n$$W_{\\text{out}} = \\left\\lfloor \\frac{W + 2p - k}{s} \\right\\rfloor + 1$$\n$$W_{\\text{out}} = \\left\\lfloor \\frac{127 + 2(3) - 11}{4} \\right\\rfloor + 1$$\n$$W_{\\text{out}} = \\left\\lfloor \\frac{127 + 6 - 11}{4} \\right\\rfloor + 1$$\n$$W_{\\text{out}} = \\left\\lfloor \\frac{122}{4} \\right\\rfloor + 1$$\n$$W_{\\text{out}} = \\lfloor 30.5 \\rfloor + 1$$\n$$W_{\\text{out}} = 30 + 1 = 31$$\n输出通道数等于滤波器数量，即 $F = 32$。\n\n因此，得到的输出张量形状 $(H_{\\text{out}}, W_{\\text{out}}, F)$ 为 $(23, 31, 32)$。最终答案要求以有序三元组形式给出。",
            "answer": "$$ \\boxed{ \\begin{pmatrix} 23  31  32 \\end{pmatrix} } $$"
        },
        {
            "introduction": "编码模型的一个强大应用不仅在于预测神经活动，还在于检验关于神经表征性质的假设。这项高级实践将指导您实现表征相似性分析（Representational Similarity Analysis, RSA），这是一种核心方法，用于比较 CNN 层与大脑区域的表征几何。您将构建一个完整的统计流程，从建立相异度矩阵到执行置换检验，再到多重比较校正，从而严格评估模型与大脑之间的对齐程度 。",
            "id": "4149629",
            "problem": "您的任务是设计并实现一个完整的、基于置换的假设检验，以在神经科学编码模型的背景下，评估卷积神经网络 (CNN) 层与大脑感兴趣区域 (ROIs) 之间的表征相似性分析 (RSA) 对齐的显著性，然后使用错误发现率 (FDR) 进行多重比较校正。解决方案必须是一个可运行的程序，并且必须产生确定性的输出。\n\n请从适用于该领域的以下基本基础开始：\n- RSA 通过量化两个空间（例如，一个 CNN 层的特征空间和一个神经 ROI 的响应空间）的表征非相似性矩阵 (RDM) 的上三角元素之间的统计关联，来比较这两个 RDM。\n- 对于 $n$ 个刺激，RDM 是一个对角线为零的对称矩阵，其位于 $(i,j)$ 的条目是在给定特征空间中刺激 $i$ 和刺激 $j$ 之间的非相似性。一个广泛使用的非相似性度量是欧几里得距离：对于特征向量 $\\mathbf{x}_i \\in \\mathbb{R}^d$ 和 $\\mathbf{x}_j \\in \\mathbb{R}^d$，欧几里得距离是 $d_{ij} = \\left\\|\\mathbf{x}_i - \\mathbf{x}_j\\right\\|_2$。\n- 斯皮尔曼等级相关通过首先将值替换为其秩，然后计算这些秩之间的皮尔逊相关，来衡量两个变量之间的统计关联。向量 $\\mathbf{u}$ 和 $\\mathbf{v}$ 之间的皮尔逊相关定义为\n$$\n\\rho(\\mathbf{u},\\mathbf{v}) = \\frac{\\sum_{k=1}^{m} (u_k - \\bar{u})(v_k - \\bar{v})}{\\sqrt{\\sum_{k=1}^{m}(u_k - \\bar{u})^2}\\sqrt{\\sum_{k=1}^{m}(v_k - \\bar{v})^2}},\n$$\n其中 $\\bar{u}$ 和 $\\bar{v}$ 分别表示 $\\mathbf{u}$ 和 $\\mathbf{v}$ 的均值。\n- 置换检验通过打破跨空间的刺激之间的映射来构建一个零分布。对于 RDM，这是通过在一个 RDM 中联合置换刺激索引，保持其对称性，然后重新计算对齐度量来实现的。用于正向对齐的单侧检验的经验 $p$-值计算如下\n$$\np = \\frac{1 + \\sum_{b=1}^{K} \\mathbb{I}\\big(r_b \\ge r_{\\text{obs}}\\big)}{1 + K},\n$$\n其中 $r_{\\text{obs}}$ 是两个 RDM 之间观察到的斯皮尔曼相关性，$r_b$ 是在 $K$ 次随机置换下的相关性，$\\mathbb{I}$ 是指示函数。分子和分母中的加性 $1$ 确保了即使在没有零样本超过 $r_{\\text{obs}}$ 的情况下也能得到有效的估计。\n- 用于在 $m$ 个假设上将错误发现率 (FDR) 控制在目标水平 $q$（以小数表示，而非百分比）的 Benjamini–Hochberg 程序操作如下：将 $p$-值排序 $p_{(1)} \\le p_{(2)} \\le \\cdots \\le p_{(m)}$，找到满足 $p_{(i^\\star)} \\le \\frac{i^\\star}{m}q$ 的最大索引 $i^\\star$，并宣布所有 $p \\le p_{(i^\\star)}$ 的假设为显著。如果不存在这样的索引，则没有假设被宣布为显著。\n\n请精确实现以下要求：\n1. 根据下文描述，从合成的刺激特征响应中为 CNN 层和神经 ROI 构建 RDM。对于每个层-区域对，计算其 RDM 的向量化上三角元素之间的斯皮尔曼等级相关，作为 RSA 对齐度量。\n2. 对于每个层-区域对，根据无对齐的零假设（通过随机置换每对中恰好一个 RDM 的刺激索引来实现），执行包含 $K$ 次置换的置换检验。使用上面给出的公式计算正向对齐的单侧经验 $p$-值。\n3. 对于每个测试用例，使用目标水平 $q$ 对该用例中所有层-区域对分别应用 Benjamini–Hochberg FDR 校正。\n4. 对于每个测试用例，输出一个等于经过 FDR 校正后显著的层-区域对数量的整数。\n\n合成数据生成协议：\n- 为每个测试用例使用独立的、固定的随机种子，以确保确定性。\n- 对于每个区域，通过从标准正态分布中抽样条目，为 $n$ 个刺激生成一个特征响应矩阵 $\\mathbf{X}^{(r)} \\in \\mathbb{R}^{n \\times d_r}$。\n- 对于每个层，根据下面每个测试用例指定的设计，生成一个特征响应矩阵 $\\mathbf{Y}^{(l)} \\in \\mathbb{R}^{n \\times d_l}$，旨在产生对齐和未对齐场景的混合。\n\n表征非相似性计算：\n- 对于任何特征矩阵 $\\mathbf{Z} \\in \\mathbb{R}^{n \\times d}$，构建 RDM $\\mathbf{D} \\in \\mathbb{R}^{n \\times n}$，其中对于 $i \\neq j$，$\\mathbf{D}_{ij} = \\left\\|\\mathbf{z}_i - \\mathbf{z}_j\\right\\|_2$，且 $\\mathbf{D}_{ii} = 0$。\n\nRSA 对齐度量：\n- 对于两个 RDM $\\mathbf{D}^{(1)}$ 和 $\\mathbf{D}^{(2)}$，将其严格上三角元素向量化为 $\\mathbf{v}^{(1)}$ 和 $\\mathbf{v}^{(2)}$，计算 $\\mathbf{v}^{(1)}$ 和 $\\mathbf{v}^{(2)}$ 之间的斯皮尔曼等级相关，并将结果表示为 $r_{\\text{obs}}$。\n\n置换检验：\n- 对于每次置换 $b \\in \\{1,\\dots,K\\}$，抽样一个 $\\{1,\\dots,n\\}$ 的随机置换 $\\pi_b$，并通过将 $\\pi_b$ 同时应用于 $\\mathbf{D}^{(2)}$ 的行和列来构建置换后的 RDM $\\tilde{\\mathbf{D}}^{(2)}$，即 $\\tilde{\\mathbf{D}}^{(2)}_{ij} = \\mathbf{D}^{(2)}_{\\pi_b(i),\\pi_b(j)}$。将 $r_b$ 计算为 $\\mathbf{D}^{(1)}$ 和 $\\tilde{\\mathbf{D}}^{(2)}$ 的上三角向量之间的斯皮尔曼相关。使用上面的经验 $p$-值公式。\n\n多重比较校正：\n- 在每个测试用例中，汇集所有层-区域对的所有 $p$-值（总共 $m$ 个），并按上述方法在水平 $q$ 上应用 Benjamini–Hochberg，为每对生成一个布尔决策。\n\n测试套件和数据设计：\n精确实现以下三个测试用例。\n- 测试用例 1 (理想路径): $n=12$ 个刺激, $L=3$ 个 CNN 层, $R=2$ 个 ROIs, $K=300$ 次置换, $q=0.1$ (小数)。随机种子 $0$。数据设计：生成 $\\mathbf{X}^{(1)}$ 和 $\\mathbf{X}^{(2)}$，维度分别为 $d_1=5$ 和 $d_2=5$。如下生成 CNN 层特征：第 1 层通过 $\\mathbf{Y}^{(1)} = \\mathbf{X}^{(1)} + \\boldsymbol{\\epsilon}$ 与 ROI 1 对齐，其中 $\\boldsymbol{\\epsilon}$ 是标准差为 $0.01$ 的独立同分布正态噪声；第 2 层未对齐（独立的标准正态特征，维度 $d_2'=6$）；第 3 层通过 $\\mathbf{Y}^{(3)} = \\mathbf{X}^{(2)} + \\boldsymbol{\\epsilon}'$ 与 ROI 2 对齐，其中 $\\boldsymbol{\\epsilon}'$ 是标准差为 $0.01$ 的独立同分布正态噪声。对所有 $L \\times R = 6$ 对计算 FDR。\n- 测试用例 2 (边界条件): $n=5$ 个刺激, $L=1$ 个 CNN 层, $R=1$ 个 ROI, $K=100$ 次置换, $q=0.05$ (小数)。随机种子 $1$。数据设计：生成 $\\mathbf{X}^{(1)}$，维度 $d_1=4$；精确设置 $\\mathbf{Y}^{(1)} = \\mathbf{X}^{(1)}$。对 $1$ 对计算 FDR。\n- 测试用例 3 (无对齐的边缘情况): $n=10$ 个刺激, $L=2$ 个 CNN 层, $R=2$ 个 ROIs, $K=200$ 次置换, $q=0.1$ (小数)。随机种子 $2$。数据设计：生成 $\\mathbf{X}^{(1)}$ 和 $\\mathbf{X}^{(2)}$，维度分别为 $d_1=6$ 和 $d_2=6$；将两个层都设置为独立的标准正态特征，维度分别为 $d'_1=7$ 和 $d'_2=8$（未对齐）。对所有 $L \\times R = 4$ 对计算 FDR。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中 $r_t$ 是一个整数，等于测试用例 $t \\in \\{1,2,3\\}$ 经过 FDR 校正后显著的层-区域对的数量。",
            "solution": "问题陈述是计算神经科学数据分析中一个有效、适定且有科学依据的练习。它要求实现一个标准的、尽管复杂的统计流程：表征相似性分析 (RSA)、基于置换的假设检验，以及使用 Benjamini-Hochberg 错误发现率 (FDR) 程序进行多重比较校正。所有组件都以数学和算法的精度进行了定义，并且测试用例的详细程度（包括随机种子）足以确保一个独特的、确定性的和可验证的结果。\n\n该过程将遵循以下科学和数学原则来实现。\n\n**步骤 1：问题验证**\n\n*   **提取已知信息**：\n    *   **核心方法**：表征相似性分析 (RSA)，用于比较卷积神经网络 (CNN) 层和大脑感兴趣区域 (ROI)。\n    *   **表征非相似性矩阵 (RDM)**：对于 $n$ 个刺激，一个 $n \\times n$ 的对称矩阵 $\\mathbf{D}$，其中 $\\mathbf{D}_{ii}=0$。对于特征向量 $\\mathbf{x}_i, \\mathbf{x}_j \\in \\mathbb{R}^d$，非相似性是欧几里得距离 $\\mathbf{D}_{ij} = \\left\\|\\mathbf{x}_i - \\mathbf{x}_j\\right\\|_2$。\n    *   **对齐度量**：两个 RDM 的向量化上三角元素之间的斯皮尔曼等级相关 $\\rho$。\n    *   **置换检验**：通过为一个 RDM 置换刺激标签来创建零分布。对于 $K$ 次置换，正向对齐的单侧经验 $p$-值为 $p = \\frac{1 + \\sum_{b=1}^{K} \\mathbb{I}(r_b \\ge r_{\\text{obs}})}{1 + K}$，其中 $r_{\\text{obs}}$ 是观察到的相关性，$r_b$ 是来自零分布的相关性，$\\mathbb{I}$ 是指示函数。置换 $\\pi_b$ 应用于 RDM $\\mathbf{D}^{(2)}$ 的方式为 $\\tilde{\\mathbf{D}}^{(2)}_{ij} = \\mathbf{D}^{(2)}_{\\pi_b(i),\\pi_b(j)}$。\n    *   **多重比较校正**：在目标 FDR 水平 $q$ 下的 Benjamini–Hochberg 程序。对于 $m$ 个排序后的 $p$-值 $p_{(1)} \\le \\cdots \\le p_{(m)}$，找到满足 $p_{(i^\\star)} \\le \\frac{i^\\star}{m}q$ 的最大索引 $i^\\star$。$p \\le p_{(i^\\star)}$ 的假设被认为是显著的。\n    *   **合成数据**：使用固定的随机种子生成。ROI 特征 $\\mathbf{X}^{(r)} \\in \\mathbb{R}^{n \\times d_r}$ 来自标准正态分布。CNN 特征 $\\mathbf{Y}^{(l)} \\in \\mathbb{R}^{n \\times d_l}$ 按每个案例的指定生成。\n    *   **测试用例 1**：$n=12$, $L=3$ 层, $R=2$ ROIs, $K=300$ 次置换, $q=0.1$, 种子=$0$。ROI 特征 $\\mathbf{X}^{(1)}, \\mathbf{X}^{(2)} \\in \\mathbb{R}^{12 \\times 5}$。CNN 特征：$\\mathbf{Y}^{(1)} = \\mathbf{X}^{(1)} + \\boldsymbol{\\epsilon}$ (噪声标准差 $0.01$)，$\\mathbf{Y}^{(2)} \\in \\mathbb{R}^{12 \\times 6}$ (独立标准正态)，$\\mathbf{Y}^{(3)} = \\mathbf{X}^{(2)} + \\boldsymbol{\\epsilon}'$ (噪声标准差 $0.01$)。\n    *   **测试用例 2**：$n=5$, $L=1$ 层, $R=1$ ROI, $K=100$ 次置换, $q=0.05$, 种子=$1$。ROI 特征 $\\mathbf{X}^{(1)} \\in \\mathbb{R}^{5 \\times 4}$。CNN 特征：$\\mathbf{Y}^{(1)} = \\mathbf{X}^{(1)}$。\n    *   **测试用例 3**：$n=10$, $L=2$ 层, $R=2$ ROIs, $K=200$ 次置换, $q=0.1$, 种子=$2$。ROI 特征 $\\mathbf{X}^{(1)}, \\mathbf{X}^{(2)} \\in \\mathbb{R}^{10 \\times 6}$。CNN 特征：$\\mathbf{Y}^{(1)} \\in \\mathbb{R}^{10 \\times 7}$，$\\mathbf{Y}^{(2)} \\in \\mathbb{R}^{10 \\times 8}$ (均为独立标准正态)。\n    *   **输出**：对于每个测试用例，输出经过 FDR 校正后显著的层-区域对的整数数量。\n\n*   **验证结论**：该问题是 **有效** 的。它在科学上基于计算神经科学中已建立的统计方法，是适定的，有清晰且确定性的解决方案路径，其定义客观且明确。它没有违反任何无效性标准。\n\n**基于原则的解决方案设计**\n\n该任务需要一个由多个计算和统计模块组成的流程，我们将逐步构建这些模块。\n\n**1. RDM 构建**\n对于给定的 $n$ 个特征向量（刺激响应）集合 $\\{\\mathbf{z}_1, \\dots, \\mathbf{z}_n\\}$，其中每个 $\\mathbf{z}_i \\in \\mathbb{R}^d$，表征非相似性矩阵 (RDM)，表示为 $\\mathbf{D}$，是一个 $n \\times n$ 的矩阵。每个条目 $\\mathbf{D}_{ij}$ 量化了刺激 $i$ 和刺激 $j$ 的表征之间的非相似性。按照规定，我们使用欧几里得距离：\n$$\n\\mathbf{D}_{ij} = \\left\\| \\mathbf{z}_i - \\mathbf{z}_j \\right\\|_2\n$$\n对角线元素 $\\mathbf{D}_{ii}$ 必然为 $0$，因为一个向量到其自身的距离为零。该矩阵是对称的，因为 $\\mathbf{D}_{ij} = \\mathbf{D}_{ji}$。\n\n**2. 使用斯皮尔曼相关进行 RSA 对齐**\n为了比较两种表征几何（一种来自 CNN 层，一种来自神经 ROI），我们计算它们各自 RDM 的相似性，即 $\\mathbf{D}^{(\\text{CNN})}$ 和 $\\mathbf{D}^{(\\text{ROI})}$。由于 RDM 是对角线为零的对称矩阵，所有信息都包含在上（或下）三角部分。我们将每个 RDM 的严格上三角元素提取成向量，称之为 $\\mathbf{v}^{(\\text{CNN})}$ 和 $\\mathbf{v}^{(\\text{ROI})}$。这些元素的数量是 $m_{\\text{RDM}} = n(n-1)/2$。\n\n然后，通过这两个向量之间的斯皮尔曼等级相关来量化对齐程度。斯皮尔曼的 $\\rho$ 等同于在经过秩变换的变量上计算的皮尔逊相关系数。这个选择是基于原则的，因为它对两个空间非相似性之间的非线性但单调的关系具有鲁棒性，这在神经数据分析中是常见情况。\n\n**3. 通过置换进行假设检验**\n为了评估观察到的相关性 $r_{\\text{obs}}$ 是否具有统计显著性，我们必须将其与一个零分布进行比较。零假设 $H_0$ 是 CNN 层和大脑 ROI 中的刺激表征之间没有系统性关系。置换检验是一种用于在该零假设下生成数据的非参数方法。\n\n过程如下：我们取其中一个 RDM，比如 $\\mathbf{D}^{(\\text{CNN})}$，并根据相同的刺激标签置换随机地置换其行和列。如果 $\\pi$ 是索引 $\\{0, 1, \\dots, n-1\\}$ 的一个置换，则置换后的 RDM $\\tilde{\\mathbf{D}}^{(\\text{CNN})}$ 的条目为 $\\tilde{\\mathbf{D}}_{ij}^{(\\text{CNN})} = \\mathbf{D}_{\\pi(i), \\pi(j)}^{(\\text{CNN})}$。此操作打破了两个 RDM 中刺激之间的对应关系，同时保留了被置换 RDM 的内部几何结构。\n\n我们重复这个过程 $K$ 次，每次生成一个新的随机置换 $\\pi_b$，并计算 $\\mathbf{D}^{(\\text{ROI})}$ 和置换后的 $\\tilde{\\mathbf{D}}^{(\\text{CNN})}$ 的向量化上三角之间的零相关系数 $r_b$。这产生了一个零分布 $\\{r_1, r_2, \\dots, r_K\\}$。\n\n检验正相关的单侧经验 $p$-值是大于或等于观察相关性的零相关性的比例。所提供的公式，\n$$\np = \\frac{1 + \\sum_{b=1}^{K} \\mathbb{I}(r_b \\ge r_{\\text{obs}})}{1 + K}\n$$\n是计算这个值的标准方法。在分子和分母中加 1 作为伪计数，确保如果 $r_{\\text{obs}}$ 大于所有 $r_b$，则 $p$-值为 $1/(K+1)$ 而不是 $0$，从而提供一个更保守和稳定的估计。\n\n**4. 使用 FDR 进行多重比较校正**\n当同时执行多个假设检验时（在我们的案例中，每个 CNN 层-ROI 对一个），做出至少一个错误发现（第一类错误）的概率会膨胀。Benjamini-Hochberg (BH) 程序控制错误发现率 (FDR)，即在所有被拒绝的零假设中，假阳性的预期比例。\n\n对于每个测试用例，我们有 $m = L \\times R$ 个比较，产生 $m$ 个 p-值 $\\{p_1, \\dots, p_m\\}$。BH 程序是：\n1.  对 $p$-值进行排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。让与这些排序后的 $p$-值对应的原始假设为 $H_{(1)}, \\dots, H_{(m)}$。\n2.  对于给定的 FDR 水平 $q$，找到最大的整数 $i^\\star$，使得第 $i^\\star$ 个最小的 $p$-值满足：\n    $$\n    p_{(i^\\star)} \\le \\frac{i^\\star}{m} q\n    $$\n3.  如果存在这样的 $i^\\star$，我们拒绝所有检验 $j$ 中 $p_j \\le p_{(i^\\star)}$ 的零假设。这意味着所有假设 $H_{(1)}, \\dots, H_{(i^\\star)}$ 都被宣布为显著。\n4.  如果不存在这样的 $i^\\star$，我们不拒绝任何零假设。\n\n每个测试用例的最终输出是其 $p$-值满足此标准的配对总数。实现将仔细处理 BH 公式的 1-based 索引与编程数组的 0-based 索引之间的转换。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import spearmanr\nfrom scipy.spatial.distance import pdist, squareform\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the execution of all test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path)\n        {\n            \"n\": 12, \"L\": 3, \"R\": 2, \"K\": 300, \"q\": 0.1, \"seed\": 0,\n            \"data_dims\": {\n                \"rois\": [5, 5],\n                \"layers\": [None, 6, None] # Dim depends on aligned ROI\n            },\n            \"alignments\": {\n                0: 0, # Layer 0 aligns with ROI 0\n                2: 1  # Layer 2 aligns with ROI 1\n            },\n            \"noise_std\": 0.01\n        },\n        # Test case 2 (boundary condition)\n        {\n            \"n\": 5, \"L\": 1, \"R\": 1, \"K\": 100, \"q\": 0.05, \"seed\": 1,\n            \"data_dims\": {\n                \"rois\": [4],\n                \"layers\": [None]\n            },\n            \"alignments\": {\n                0: 0 # Layer 0 aligns with ROI 0\n            },\n            \"noise_std\": 0.0 # Perfect alignment\n        },\n        # Test case 3 (edge case with no alignment)\n        {\n            \"n\": 10, \"L\": 2, \"R\": 2, \"K\": 200, \"q\": 0.1, \"seed\": 2,\n            \"data_dims\": {\n                \"rois\": [6, 6],\n                \"layers\": [7, 8]\n            },\n            \"alignments\": {}, # No alignments\n            \"noise_std\": 0.0\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(**case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_test_case(n, L, R, K, q, seed, data_dims, alignments, noise_std):\n    \"\"\"\n    Executes a single test case for RSA significance testing.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Generate synthetic data\n    roi_features = [rng.standard_normal(size=(n, d)) for d in data_dims[\"rois\"]]\n    \n    cnn_features = []\n    for l in range(L):\n        aligned_roi_idx = alignments.get(l)\n        if aligned_roi_idx is not None:\n            # Aligned layer\n            base_features = roi_features[aligned_roi_idx]\n            noise = rng.normal(scale=noise_std, size=base_features.shape)\n            cnn_features.append(base_features + noise)\n        else:\n            # Unaligned layer\n            d_l = data_dims[\"layers\"][l]\n            cnn_features.append(rng.standard_normal(size=(n, d_l)))\n\n    # 2. Compute RDMs\n    roi_rdms = [compute_rdm(features) for features in roi_features]\n    cnn_rdms = [compute_rdm(features) for features in cnn_features]\n\n    # Get upper triangle indices, which are constant for a given n\n    triu_indices = np.triu_indices(n, k=1)\n\n    p_values = []\n    # 3. Perform permutation test for each layer-region pair\n    for l in range(L):\n        rdm_cnn_vec = cnn_rdms[l][triu_indices]\n        for r in range(R):\n            rdm_roi_vec = roi_rdms[r][triu_indices]\n\n            # Observed correlation\n            r_obs, _ = spearmanr(rdm_cnn_vec, rdm_roi_vec)\n            \n            # Null distribution\n            null_correlations = np.zeros(K)\n            for b in range(K):\n                perm = rng.permutation(n)\n                # Permute one RDM (e.g., the CNN rdm)\n                rdm_cnn_permuted = cnn_rdms[l][perm, :][:, perm]\n                rdm_cnn_permuted_vec = rdm_cnn_permuted[triu_indices]\n                r_b, _ = spearmanr(rdm_cnn_permuted_vec, rdm_roi_vec)\n                null_correlations[b] = r_b\n            \n            # Empirical p-value\n            p_val = (1.0 + np.sum(null_correlations >= r_obs)) / (1.0 + K)\n            p_values.append(p_val)\n\n    # 4. Apply Benjamini-Hochberg FDR correction\n    p_values = np.array(p_values)\n    m = len(p_values)\n    \n    if m == 0:\n        return 0\n\n    # Sort p-values while keeping original indices\n    sorted_indices = np.argsort(p_values)\n    sorted_p_values = p_values[sorted_indices]\n    \n    # Find the largest i* such that p_(i*) = (i*/m)*q\n    i = np.arange(1, m + 1)\n    thresholds = (i / m) * q\n    \n    significant_mask = sorted_p_values = thresholds\n    \n    if not np.any(significant_mask):\n        return 0\n    else:\n        # Find the rank of the last p-value that was below its threshold\n        max_significant_index_in_sorted_array = np.where(significant_mask)[0].max()\n        # The p-value at this index is our significance threshold\n        p_threshold = sorted_p_values[max_significant_index_in_sorted_array]\n        \n        # Count how many of the original p-values are = this threshold\n        num_significant = np.sum(p_values = p_threshold)\n        return int(num_significant)\n\ndef compute_rdm(feature_matrix):\n    \"\"\"\n    Computes the Representational Dissimilarity Matrix (RDM)\n    from a feature matrix using Euclidean distance.\n    \"\"\"\n    # pdist computes the condensed distance matrix (upper triangle)\n    distances = pdist(feature_matrix, 'euclidean')\n    # squareform converts it to a full, symmetric matrix with zero diagonal\n    rdm = squareform(distances)\n    return rdm\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}