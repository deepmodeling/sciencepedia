{
    "hands_on_practices": [
        {
            "introduction": "移动平均滤波器在根本上是通过卷积运算定义的。然而，对卷积的直接、朴素实现可能计算效率低下，特别是对于长滤波器窗口。本练习将引导您从第一性原理出发，推导出移动平均滤波器优雅且高效的递归形式，这是处理大规模或实时数据流的基石。",
            "id": "4153544",
            "problem": "某神经生理学实验室通过以固定采样间隔 $\\Delta t$ 对脉冲进行分箱，采集到一个离散时间神经元放电率序列 $x[n]$，$n \\in \\mathbb{Z}$。为了在保留慢速漂移的同时减少高频变异，该团队应用了一个因果 $M$ 点简单移动平均滤波器。该滤波器实现为一个线性时不变 (LTI) 系统，其脉冲响应 $h[n]$ 由 $h[n] = \\frac{1}{M}$（对于 $n = 0, 1, \\dots, M-1$）和 $h[n] = 0$（其他情况）给出。输出 $y[n]$ 由离散时间卷积 $y[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]$ 定义。假设对输入进行零填充，即当 $n  0$ 时，$x[n] = 0$。\n\n仅从离散时间卷积的定义和指定的脉冲响应出发，推导出一个用于计算运行和 $s[n]$ 的高效因果递推关系，该关系可用于以每个样本恒定的成本计算 $y[n]$，并将 $y[n]$ 用 $s[n]$ 和 $M$ 表示。不要假设任何未经证明的快捷公式。\n\n然后，假设输入是一个斜坡加偏置信号 $x[n] = \\alpha n + \\beta$（对于所有整数 $n \\geq 0$）和 $x[n] = 0$（对于 $n  0$），其中 $\\alpha$ 和 $\\beta$ 是实数常数。使用您推导出的递推关系，确定平滑后的输出 $y[n]$ 的闭式表达式，该表达式对所有整数 $n \\geq M-1$ 有效。将您的最终结果明确表示为关于 $n$、$M$、$\\alpha$ 和 $\\beta$ 的单个闭式解析表达式。不需要进行四舍五入。",
            "solution": "该问题被评估为有效。它在科学上基于标准的线性系统理论，是适定的、客观的，并包含得出唯一解所需的所有必要信息。\n\n该问题包含两部分。首先，我们必须为一个简单移动平均滤波器推导出一个高效的递推算法。其次，我们必须将此滤波器应用于一个特定的输入信号，并求出其输出的闭式表达式。\n\n第1部分：递推算法的推导\n\n线性时不变 (LTI) 系统的输出 $y[n]$ 由输入信号 $x[n]$ 和系统脉冲响应 $h[n]$ 的离散时间卷积给出：\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n一个因果 $M$ 点简单移动平均滤波器的脉冲响应 $h[n]$ 如下：\n$$\nh[n] = \\begin{cases} \\frac{1}{M}  \\text{for } 0 \\le n \\le M-1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n卷积和中的项 $h[n-k]$ 仅当其自变量 $n-k$ 在范围 $[0, M-1]$ 内时才非零。这意味着 $0 \\le n-k \\le M-1$。对 $k$ 求解，我们得到 $n-M+1 \\le k \\le n$。\n因此，卷积和可以用有限的限值重写为：\n$$\ny[n] = \\sum_{k=n-M+1}^{n} x[k]\\,h[n-k]\n$$\n在此求和范围内，$h[n-k] = \\frac{1}{M}$。因此，我们有：\n$$\ny[n] = \\sum_{k=n-M+1}^{n} x[k]\\,\\frac{1}{M} = \\frac{1}{M} \\sum_{k=n-M+1}^{n} x[k]\n$$\n为了创建一种高效的计算方法，我们定义一个运行和 $s[n]$ 为：\n$$\ns[n] = \\sum_{k=n-M+1}^{n} x[k]\n$$\n根据这个定义，输出 $y[n]$ 可以简单地用 $s[n]$ 和 $M$ 表示为：\n$$\ny[n] = \\frac{s[n]}{M}\n$$\n为了找到 $s[n]$ 的递推关系，我们考察 $s[n]$ 和 $s[n-1]$ 之间的关系。$s[n-1]$ 的表达式为：\n$$\ns[n-1] = \\sum_{k=(n-1)-M+1}^{n-1} x[k] = \\sum_{k=n-M}^{n-1} x[k]\n$$\n我们可以写出 $s[n]$ 的各项：\n$$\ns[n] = x[n] + x[n-1] + \\dots + x[n-M+1]\n$$\n以及 $s[n-1]$ 的各项：\n$$\ns[n-1] = x[n-1] + x[n-2] + \\dots + x[n-M]\n$$\n通过比较这两个和，我们可以看到 $s[n]$ 可以通过在 $s[n-1]$ 的基础上加上新样本 $x[n]$ 并减去前一个窗口中最旧的样本 $x[n-M]$ 来获得。这就得到了递推关系：\n$$\ns[n] = s[n-1] + x[n] - x[n-M]\n$$\n这个递推关系非常高效，因为对于每个新样本 $n$，它只需要一次加法和一次减法，而与滤波器长度 $M$ 无关。这构成了每个样本恒定的计算成本。注意，由于输入是零填充的（当 $n0$ 时，$x[n]=0$），对于 $n  M$ 的情况，项 $x[n-M]$ 为零。该递推关系对 $n \\ge M$ 完全有效。\n\n第2部分：应用于斜坡加偏置输入\n\n给定输入信号 $x[n] = \\alpha n + \\beta$（对于 $n \\ge 0$），以及 $x[n]=0$（对于 $n0$）。我们需要为所有整数 $n \\ge M-1$ 求出 $y[n]$ 的闭式表达式。我们将使用为运行和 $s[n]$ 推导出的递推关系。\n\n$s[n]$ 的递推关系由差值 $x[n] - x[n-M]$ 驱动。对于 $n \\ge M$，$n$ 和 $n-M$ 都是非负的，所以我们可以使用表达式 $x[n] = \\alpha n + \\beta$。\n$$\nx[n] - x[n-M] = (\\alpha n + \\beta) - (\\alpha(n-M) + \\beta)\n$$\n$$\nx[n] - x[n-M] = \\alpha n + \\beta - \\alpha n + \\alpha M - \\beta = \\alpha M\n$$\n对于 $n \\ge M$，运行和的差分方程变为：\n$$\ns[n] = s[n-1] + \\alpha M\n$$\n这是一个带常数强制项的一阶线性非齐次差分方程。其解表明，对于 $n \\ge M$，$s[n]$ 构成一个等差数列。\n\n为了求出 $n \\ge M-1$ 时 $s[n]$ 的闭式，我们可以用一个初始值 $s[M-1]$ 和后续的增量来表示 $s[n]$。\n$$\ns[n] = s[M-1] + \\sum_{j=M}^{n} (s[j] - s[j-1])\n$$\n对于 $j \\ge M$，我们有 $s[j] - s[j-1] = \\alpha M$。这个和从 $j=M$ 到 $n$，包含 $n-M+1$ 项。\n$$\ns[n] = s[M-1] + \\sum_{j=M}^{n} \\alpha M = s[M-1] + (n-M+1)\\alpha M\n$$\n此公式对 $n \\ge M-1$ 有效。当 $n=M-1$ 时，和是空的（或有零项），所以 $s[M-1]=s[M-1]$。\n\n接下来，我们必须通过直接求和来计算初始值 $s[M-1]$。由于 $n=M-1$，计算 $s[M-1]$ 的和从 $k=(M-1)-M+1=0$ 到 $k=M-1$。\n$$\ns[M-1] = \\sum_{k=0}^{M-1} x[k]\n$$\n对于这个 $k$ 的范围，$k \\ge 0$，所以 $x[k] = \\alpha k + \\beta$。\n$$\ns[M-1] = \\sum_{k=0}^{M-1} (\\alpha k + \\beta) = \\alpha \\sum_{k=0}^{M-1} k + \\beta \\sum_{k=0}^{M-1} 1\n$$\n使用前几个整数的和以及常数的和的公式：\n$$\n\\sum_{k=0}^{M-1} k = \\frac{(M-1)M}{2}\n$$\n$$\n\\sum_{k=0}^{M-1} 1 = M\n$$\n代入这些结果，我们得到：\n$$\ns[M-1] = \\alpha \\frac{(M-1)M}{2} + \\beta M\n$$\n现在我们将 $s[M-1]$ 的这个表达式代回到 $s[n]$ 的方程中：\n$$\ns[n] = \\left(\\alpha \\frac{(M-1)M}{2} + \\beta M\\right) + (n-M+1)\\alpha M\n$$\n我们可以提出公因子 $\\alpha M$ 并合并各项：\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{M-1}{2} + (n-M+1) \\right]\n$$\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{M-1 + 2n - 2M + 2}{2} \\right]\n$$\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{2n - M + 1}{2} \\right]\n$$\n最后，我们计算输出 $y[n] = s[n]/M$：\n$$\ny[n] = \\frac{1}{M} \\left( \\beta M + \\alpha M \\left[ \\frac{2n - M + 1}{2} \\right] \\right)\n$$\n$$\ny[n] = \\beta + \\alpha \\left( \\frac{2n - M + 1}{2} \\right)\n$$\n这个表达式可以被重新整理成一个更易于解释的形式：\n$$\ny[n] = \\beta + \\alpha \\left( n - \\frac{M-1}{2} \\right) = \\alpha n + \\beta - \\frac{\\alpha(M-1)}{2}\n$$\n这就是对所有整数 $n \\ge M-1$ 有效的输出 $y[n]$ 的闭式表达式。它表明，平滑后的输出也是一个斜率为 $\\alpha$ 的斜坡信号，但其偏置有所改变。项 $-\\frac{\\alpha(M-1)}{2}$ 代表一个恒定的垂直位移，这与移动平均滤波器的群延迟有关。",
            "answer": "$$\\boxed{\\alpha n + \\beta - \\frac{\\alpha(M-1)}{2}}$$"
        },
        {
            "introduction": "理论算法通常假设信号是无限的，但现实世界的数据总是有限的。当将滤波器应用于信号边界时，会出现关键的挑战。本练习  将指导您实现一个“重新归一化”的平滑器，它能正确处理边缘以防止人为失真，并将其与可能给结果带来显著偏差的朴素方法进行对比。",
            "id": "4153595",
            "problem": "给定一个有限离散时间信号，你需要实现一种适用于神经科学时间序列（如神经元荧光轨迹或瞬时脉冲发放率估计）的平滑操作。考虑一个长度为 $N$、由 $n \\in \\{0,1,\\dots,N-1\\}$ 索引的实值离散时间信号 $x[n]$。半宽为 $w \\in \\mathbb{Z}_{\\ge 0}$ 的移动平均平滑使用一个以每个样本为中心、名义长度为 $2w+1$ 的对称窗口。在边界附近（$n$ 接近 $0$ 或 $N-1$ 时），该窗口会超出可用样本的范围。你必须实现一种重归一化移动平均，对于每个索引 $n$，它将除以截断窗口中实际包含的样本数，而不是名义窗口长度。你还必须证明这种归一化方法对于恒定信号能保持单位增益。\n\n从离散时间信号和线性平滑算子的基本定义出发。将平滑过程视为一个操作，该操作用围绕 $n$ 的对称邻域上计算的局部均值来替换每个 $x[n]$。不要假设信号是无限长的，也不要使用任何在边界之外插入人工值的假设。算法必须只使用可用数据，并且必须在边缘处根据实际包含的样本数进行重归一化。\n\n程序要求：\n- 实现一个函数，输入为 $x[n]$ 和整数半宽 $w$，并为所有 $n \\in \\{0,1,\\dots,N-1\\}$ 返回重归一化移动平均输出 $y[n]$。该实现必须对所有 $w \\ge 0$ 都正确，包括 $2w+1 > N$ 的情况。\n- 为了进行比较，实现一个朴素的零填充移动平均。该方法使用长度为 $2w+1$ 的均匀窗口，除以 $2w+1$，并通过与矩形核的标准离散卷积，隐式地将越界样本视为零。\n- 使用这些实现来计算下面测试套件中指定的量。\n- 通过量化重归一化移动平均值与原始恒定值之间的偏差，来证明其对恒定信号的单位增益保持特性。\n\n测试套件：\n- 情况 1（恒定信号，内部-边缘行为）：设 $N=100$, $w=5$, 且对所有 $n$ 有 $x[n]=3.7$。计算重归一化移动平均输出 $y[n]$，并返回最大绝对偏差 $\\max_{0 \\le n \\le N-1} |y[n]-3.7|$，结果为浮点数。\n- 情况 2（窗口长于信号）：设 $N=20$, $w=20$, 且对所有 $n$ 有 $x[n]=n$。计算重归一化移动平均输出 $y[n]$，并返回其与全局均值 $\\mu=\\frac{1}{N}\\sum_{n=0}^{N-1} x[n]$ 的最大绝对偏差，即 $\\max_{0 \\le n \\le N-1} |y[n]-\\mu|$，结果为浮点数。\n- 情况 3（单位操作边界情况）：设 $N=15$, $w=0$, 且对所有 $n$ 有 $x[n]=(-1)^n$。计算重归一化移动平均输出 $y[n]$，并返回最大绝对偏差 $\\max_{0 \\le n \\le N-1} |y[n]-x[n]|$，结果为浮点数。\n- 情况 4（单位增益比较，朴素方法）：设 $N=50$, $w=3$, 且对所有 $n$ 有 $x[n]=5$。计算朴素零填充移动平均输出 $y_{\\text{naive}}[n]$。返回第一个样本点的增益 $g_{\\text{naive}} = \\frac{y_{\\text{naive}}[0]}{5}$，结果为浮点数。\n- 情况 5（单位增益比较，重归一化方法）：使用与情况 4 相同的设置，计算重归一化移动平均输出 $y[n]$。返回第一个样本点的增益 $g_{\\text{renorm}} = \\frac{y[0]}{5}$，结果为浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4,r_5]$），$r_1$ 到 $r_5$ 分别对应上述情况 1 到情况 5 的输出。所有值必须打印为 Python 浮点数。不涉及物理单位；将所有量视为无量纲量。",
            "solution": "该问题要求实现并分析两种应用于有限离散时间信号的移动平均滤波器，重点关注它们在信号边界处的行为。这种分析在神经科学等领域尤为重要，因为在这些领域中，保持生理信号的基线至关重要。\n\n一个有限实值离散时间信号是一个长度为 $N$ 的数字序列 $x[n]$，其中索引 $n$ 属于集合 $\\{0, 1, \\dots, N-1\\}$。平滑此信号涉及将每个样本 $x[n]$ 替换为其邻近值的平均值。\n\n首先，我们定义**重归一化移动平均**。此方法旨在为恒定信号保持单位增益（也称为保留直流分量），并覆盖整个信号，包括其边界。对于给定的半宽 $w \\in \\mathbb{Z}_{\\ge 0}$，滤波器考虑一个以每个索引 $n$ 为中心、名义长度为 $2w+1$ 的对称窗口。输出信号 $y[n]$ 的计算方法如下：\n\n对于每个样本索引 $n \\in \\{0, 1, \\dots, N-1\\}$，要求平均的索引集合由窗口 $[n-w, n+w]$ 与有效信号域 $[0, N-1]$ 的交集确定。这个有效窗口的起始和结束索引是：\n$$k_{start}(n) = \\max(0, n-w)$$\n$$k_{end}(n) = \\min(N-1, n+w)$$\n\n此窗口内信号值的未归一化总和为：\n$$S[n] = \\sum_{k=k_{start}(n)}^{k_{end}(n)} x[k]$$\n\n重归一化的关键步骤是将此总和除以求和中实际包含的样本数，而不是名义窗口长度 $2w+1$。有效窗口中的样本数量为：\n$$C[n] = k_{end}(n) - k_{start}(n) + 1$$\n\n于是，重归一化移动平均输出 $y[n]$ 由下式给出：\n$$y[n] = \\frac{S[n]}{C[n]} = \\frac{\\sum_{k=\\max(0, n-w)}^{\\min(N-1, n+w)} x[k]}{\\min(N-1, n+w) - \\max(0, n-w) + 1}$$\n\n这种归一化方案保证了恒定信号的单位增益。为了证明这一点，设对所有 $n$ 都有 $x[n] = c$，其中 $c$ 是一个常数。总和 $S[n]$ 变为：\n$$S[n] = \\sum_{k=k_{start}(n)}^{k_{end}(n)} c = c \\cdot (k_{end}(n) - k_{start}(n) + 1) = c \\cdot C[n]$$\n因此，输出为：\n$$y[n] = \\frac{c \\cdot C[n]}{C[n]} = c$$\n这表明对于所有 $n$，$y[n] = x[n]$，意味着恒定信号未经改变地通过了滤波器。此属性对于避免数据集边缘处的人为衰减至关重要。一个能为所有 $n$ 高效计算 $S[n]$ 的算法涉及预先计算 $x[n]$ 的累积和，这使得每个 $S[n]$ 都能在 $O(1)$ 时间内计算出来，从而使整个算法的时间复杂度为 $O(N)$。\n\n其次，我们考虑**朴素的零填充移动平均**。这种方法反映了带有零填充的标准离散卷积的行为。滤波器核（或脉冲响应）$h[k]$ 定义为一个归一化的矩形窗口：\n$$\nh[k] = \\begin{cases}\n\\frac{1}{2w+1}  \\text{for } -w \\le k \\le w \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n输出 $y_{\\text{naive}}[n]$ 是信号 $x[n]$ 与核 $h[k]$ 的离散卷积，形式上记为 $(x*h)[n]$。对于有限信号，此操作通常通过在其边界之外用零扩展信号来实现。输出为：\n$$y_{\\text{naive}}[n] = \\sum_{k=-w}^{w} x_{\\text{padded}}[n-k] \\cdot \\frac{1}{2w+1}$$\n其中，如果 $0 \\le m \\le N-1$，则 $x_{\\text{padded}}[m] = x[m]$，否则 $x_{\\text{padded}}[m] = 0$。与重归一化滤波器不同，除数始终是常数 $2w+1$。\n\n除数的这种恒定性导致了边界处的增益衰减。考虑一个恒定信号 $x[n]=c0$。在左边界处，对于 $n=0$，求和项包含 $k \\in [-w, w]$ 的 $x_{\\text{padded}}[-k]$。非零项对应于 $k \\in [0, w]$，总共有 $w+1$ 项。\n$$y_{\\text{naive}}[0] = \\frac{1}{2w+1} \\sum_{k=0}^{w} x[k] = \\frac{1}{2w+1} \\sum_{k=0}^{w} c = \\frac{c(w+1)}{2w+1}$$\n$n=0$ 处的增益是输出与输入的比值，$g_{\\text{naive}} = \\frac{y_{\\text{naive}}[0]}{c}$：\n$$g_{\\text{naive}} = \\frac{w+1}{2w+1}$$\n对于任何 $w  0$，此增益都小于 $1$，这显示了衰减效应。相比之下，重归一化滤波器在所有点上都产生 $1$ 的增益。\n\n所提供的测试套件旨在验证这些确切的属性：\n- 情况 1：确认重归一化滤波器对恒定信号的单位增益属性。在浮点精度允许的范围内，偏差应为零。\n- 情况 2：探讨当窗口宽度超过信号长度时的行为。重归一化滤波器应对每个输出样本计算信号的全局均值。\n- 情况 3：$w=0$ 的情况对应于长度为 $1$ 的窗口，这应导致单位操作（$y[n]=x[n]$）。\n- 情况 4 和 5：直接比较朴素滤波器和重归一化滤波器在信号边界处的增益，突显前者的衰减和后者的单位增益。\n\n实现将遵循这些原则，对重归一化滤波器使用累积和方法，对朴素滤波器使用库函数中的卷积。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef renormalized_moving_average(x: np.ndarray, w: int) - np.ndarray:\n    \"\"\"\n    Computes the renormalized moving average of a signal.\n    \n    For each sample, the output is the average of the valid signal values\n    within a symmetric window of half-width w. The divisor is the number\n    of valid samples, which may be less than 2w+1 at the boundaries.\n    \n    Args:\n        x: The 1D input signal as a numpy array.\n        w: The integer half-width of the moving average window.\n        \n    Returns:\n        The smoothed signal as a numpy array.\n    \"\"\"\n    N = len(x)\n    if w == 0:\n        return x.copy()\n\n    # Use cumulative sum for an efficient O(N) implementation.\n    # The cumulative sum X[k] = sum(x[0]...x[k-1]).\n    # We pad with a 0 at the beginning to handle sums starting from index 0.\n    # Sum over x[a..b] is X[b+1] - X[a].\n    x_cumsum = np.concatenate(([0], np.cumsum(x)))\n    \n    y = np.zeros(N)\n    \n    for n in range(N):\n        k_start = max(0, n - w)\n        k_end = min(N - 1, n + w)\n        \n        # Calculate sum from pre-computed cumulative sum\n        current_sum = x_cumsum[k_end + 1] - x_cumsum[k_start]\n        \n        # Calculate the number of points in the truncated window\n        count = k_end - k_start + 1\n        \n        y[n] = current_sum / count\n        \n    return y\n\ndef naive_zero_padded_moving_average(x: np.ndarray, w: int) - np.ndarray:\n    \"\"\"\n    Computes a naive zero-padded moving average using standard convolution.\n    \n    The output is computed by convolving the signal with a rectangular\n    kernel of length 2w+1, normalized by 2w+1. The 'same' mode implicitly\n    pads the signal with zeros.\n    \n    Args:\n        x: The 1D input signal as a numpy array.\n        w: The integer half-width of the moving average window.\n        \n    Returns:\n        The smoothed signal as a numpy array.\n    \"\"\"\n    if w == 0:\n        return x.copy()\n\n    window_len = 2 * w + 1\n    kernel = np.ones(window_len) / window_len\n    \n    # 'same' mode ensures output is same size as input, and handles\n    # boundaries by assuming the signal is zero-padded.\n    return np.convolve(x, kernel, mode='same')\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        # Case 1: constant signal, interior-edge behavior\n        {'N': 100, 'w': 5, 'x_func': lambda N: np.full(N, 3.7), 'id': 'case1'},\n        # Case 2: window longer than signal\n        {'N': 20, 'w': 20, 'x_func': lambda N: np.arange(N, dtype=float), 'id': 'case2'},\n        # Case 3: identity boundary case\n        {'N': 15, 'w': 0, 'x_func': lambda N: (-1.0)**np.arange(N), 'id': 'case3'},\n        # Case 4: unit gain comparison, naive method\n        {'N': 50, 'w': 3, 'x_func': lambda N: np.full(N, 5.0), 'id': 'case4'},\n        # Case 5: unit gain comparison, renormalized method\n        {'N': 50, 'w': 3, 'x_func': lambda N: np.full(N, 5.0), 'id': 'case5'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        w = case['w']\n        x = case['x_func'](N)\n        \n        if case['id'] == 'case1':\n            y = renormalized_moving_average(x, w)\n            result = np.max(np.abs(y - 3.7))\n            results.append(result)\n            \n        elif case['id'] == 'case2':\n            y = renormalized_moving_average(x, w)\n            mu = np.mean(x)\n            result = np.max(np.abs(y - mu))\n            results.append(result)\n\n        elif case['id'] == 'case3':\n            y = renormalized_moving_average(x, w)\n            result = np.max(np.abs(y - x))\n            results.append(result)\n\n        elif case['id'] == 'case4':\n            y_naive = naive_zero_padded_moving_average(x, w)\n            # Gain at the first sample\n            g_naive = y_naive[0] / 5.0\n            results.append(g_naive)\n            \n        elif case['id'] == 'case5':\n            y_renorm = renormalized_moving_average(x, w)\n            # Gain at the first sample\n            g_renorm = y_renorm[0] / 5.0\n            results.append(g_renorm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "鲁棒平滑算法的实现需要对其设计背后的统计学原理有深刻的理解。不同的边界处理技术，例如零填充与反射填充，会引入不同的统计偏差。本练习  要求您严格分析这些技术所产生的偏差和方差，从而将实际的实现选择与其基本的统计学后果联系起来。",
            "id": "4153568",
            "problem": "一段皮层局部场电位 (LFP) 被记录为一个离散时间序列 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$ 且 $N \\geq 1$。你应用一个长度为奇数 $L = 2M + 1$（其中 $M \\geq 1$）的中心移动平均滤波器来估计局部均值。对于内部索引 $n$（其所有 $L$ 个样本都位于 $\\{0, 1, \\dots, N-1\\}$ 内），该估计量由均匀核定义：\n$$\n\\hat{\\mu}[n] = \\frac{1}{2M+1} \\sum_{k=-M}^{M} x[n+k].\n$$\n在边界处，你必须使用以下两种填充方案之一来处理超出序列段的缺失样本：\n- 补零：对于任何超出范围的索引，滤波器使用的缺失样本值被设为 $0$。\n- 反射填充：序列段通过对称性进行扩展，使得对于所有整数 $t \\geq 1$，都有 $x[-t] = x[t]$ 和 $x[N-1 + t] = x[N-1 - t]$。\n\n假设使用标准的概率定义：期望算子为 $\\mathbb{E}[\\cdot]$，估计量 $\\hat{\\theta}$ 对于目标量 $\\theta$ 的偏差定义为 $b = \\mathbb{E}[\\hat{\\theta}] - \\theta$。当你从第一性原理出发进行推理时，请考虑以下场景：\n- 场景 1：$x[n]$ 是一个宽平稳 (WSS) 过程的一个实现，具有恒定均值 $\\mathbb{E}[x[n]] = m$ 和有限方差，且该 LFP 段是此过程的一个有限片段。\n- 场景 2：$x[n]$ 包含一个确定性线性趋势 $x[n] = a n + b$（其中 $a$ 和 $b$ 为常数），该趋势代表一个缓慢变化的基线，可能还叠加了零均值噪声。\n- 场景 3：$x[n]$ 是零均值（$m = 0$），并且在滤波器半长范围内的延迟上的自协方差可以忽略不计（即，在长度为 $L$ 的窗口上近似为白噪声）。\n\n选择所有关于补零和反射填充对中心移动平均在边界附近的偏差影响的正确陈述：\n\nA. 在场景 1 中，使用补零时，靠近边界的索引处的中心移动平均的期望值等于 $m$ 乘以窗口内域内样本的比例，因此在边缘附近会向 $0$ 产生偏差，但在内部是无偏的。\n\nB. 在场景 1 中，使用反射填充时，中心移动平均对于恒定均值 $m$ 在所有索引（包括边界）上都保持无偏。\n\nC. 在场景 2 中，在左边界索引 $n = 0$ 处使用反射填充时，中心移动平均等于 $b + \\dfrac{a M (M+1)}{2M+1}$，这意味着除非 $a = 0$，否则存在非零的边界偏差。\n\nD. 在场景 1 中，相对于内部，补零在边界处是方差中性的，因为移动平均核的权重总和为 1。\n\nE. 在场景 3 中，补零和反射填充都产生无偏估计；然而，在边界处，补零产生的方差比内部平均值低，而反射填充由于反射窗口中存在重复样本，产生的方差比内部平均值高。",
            "solution": "用户希望我验证问题陈述，然后解决问题。\n\n### 步骤 1：提取已知条件\n\n-   **信号**：一个离散时间序列 $x[n]$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$ 且 $N \\geq 1$。\n-   **滤波器**：一个长度为奇数 $L = 2M + 1$ 的中心移动平均滤波器，其中 $M \\geq 1$ 是一个整数。\n-   **内部估计量**：对于窗口 $[n-M, n+M]$ 完全包含在 $[0, N-1]$ 内的索引 $n$，估计量为 $\\hat{\\mu}[n] = \\frac{1}{2M+1} \\sum_{k=-M}^{M} x[n+k]$。\n-   **边界填充方案**：\n    -   **补零**：对于任何在 $[0, N-1]$ 之外的索引 $i$，滤波器使用的值为 $x[i] = 0$。\n    -   **反射填充**：序列被扩展，使得对于整数 $t \\geq 1$，有 $x[-t] = x[t]$ 和 $x[N-1+t] = x[N-1-t]$。\n-   **定义**：\n    -   期望算子：$\\mathbb{E}[\\cdot]$。\n    -   估计量 $\\hat{\\theta}$ 对于量 $\\theta$ 的偏差：$b = \\mathbb{E}[\\hat{\\theta}] - \\theta$。\n-   **场景**：\n    1.  $x[n]$ 是一个宽平稳 (WSS) 过程的实现，具有恒定均值 $\\mathbb{E}[x[n]] = m$ 和有限方差。\n    2.  $x[n]$ 包含一个确定性线性趋势 $x[n] = a n + b$（其中 $a, b$ 为常数），可能还叠加了零均值噪声。\n    3.  $x[n]$ 是零均值 ($m=0$) 且在最大为 $M$ 的延迟上自协方差可忽略不计（近似为白噪声）。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学依据**：该问题在数字信号处理和时间序列分析的原理上有充分的依据。移动平均滤波器、填充方法（补零、反射）、宽平稳过程以及偏差和方差的分析都是标准和基础的概念，尤其是在分析像 LFP 这样的含噪数据的背景下。\n-   **适定性**：该问题是适定的。滤波器、信号模型（场景）和填充方案都给出了精确的数学定义。问题要求分析偏差和方差，这些都是明确定义的统计量，可以从所提供的信息中推导出来。\n-   **客观性**：问题陈述使用客观、正式的语言表达，没有歧义或主观论断。\n\n### 步骤 3：结论与行动\n\n问题陈述是有效的。它在科学上是合理的、适定的、客观且完整的。我将继续推导解答并评估每个选项。\n\n### 推导与选项分析\n\n令滤波器长度为 $L = 2M+1$。我们将分析估计量 $\\hat{\\mu}[n]$ 在左边界索引 $n$（满足 $0 \\le n  M$）处的行为。对于这样的索引，窗口 $[n-M, n+M]$ 需要用到负索引的样本。需要的超出范围的样本数量为 $M-n$。范围内的样本数量为 $(n+M) - 0 + 1 = n+M+1$。\n\n**A. 在场景 1 中，使用补零时，靠近边界的索引处的中心移动平均的期望值等于 $m$ 乘以窗口内域内样本的比例，因此在边缘附近会向 $0$ 产生偏差，但在内部是无偏的。**\n\n-   **分析**：在场景 1 中，对于所有 $n \\in \\{0, \\dots, N-1\\}$，$\\mathbb{E}[x[n]] = m$。对于索引 $n$ 满足 $0 \\leq n  M$，补零估计量 $\\hat{\\mu}_{zp}[n]$ 为：\n    $$\n    \\hat{\\mu}_{zp}[n] = \\frac{1}{L} \\left( \\sum_{k=n-M}^{-1} 0 + \\sum_{k=0}^{n+M} x[k] \\right) = \\frac{1}{2M+1} \\sum_{k=0}^{n+M} x[k]\n    $$\n-   其期望值为：\n    $$\n    \\mathbb{E}[\\hat{\\mu}_{zp}[n]] = \\frac{1}{2M+1} \\sum_{k=0}^{n+M} \\mathbb{E}[x[k]] = \\frac{1}{2M+1} \\sum_{k=0}^{n+M} m\n    $$\n-   该和包含 $n+M+1$ 项。因此：\n    $$\n    \\mathbb{E}[\\hat{\\mu}_{zp}[n]] = \\frac{n+M+1}{2M+1} m\n    $$\n-   域内样本在长度为 $L=2M+1$ 的窗口中的比例确实是 $\\frac{n+M+1}{2M+1}$。陈述的第一部分是正确的。\n-   偏差为 $b[n] = \\mathbb{E}[\\hat{\\mu}_{zp}[n]] - m = \\left(\\frac{n+M+1}{2M+1} - 1\\right) m = \\frac{n-M}{2M+1} m$。\n-   因为 $0 \\leq n  M$，项 $n-M$ 是负数。如果 $m \\neq 0$，则偏差非零。例如，如果 $m>0$，偏差为负，意味着 $\\mathbb{E}[\\hat{\\mu}_{zp}[n]]  m$。这表明估计量向 0 偏差。这对左右边界都成立。\n-   在内部（$M \\le n \\le N-1-M$），所有 $2M+1$ 个样本都在域内。比例为 $1$，所以 $\\mathbb{E}[\\hat{\\mu}[n]] = m$，偏差为 $0$。\n-   **结论**：该陈述是正确的。\n\n**B. 在场景 1 中，使用反射填充时，中心移动平均对于恒定均值 $m$ 在所有索引（包括边界）上都保持无偏。**\n\n-   **分析**：对于 $0 \\leq n  M$，反射填充估计量 $\\hat{\\mu}_{rp}[n]$ 使用 $x[-t] = x[t]$（当 $t \\ge 1$）。\n    $$\n    \\hat{\\mu}_{rp}[n] = \\frac{1}{L} \\sum_{k=-M}^{M} x_{padded}[n+k]\n    $$\n-   我们来求期望。对于和中的任何索引 $j$，$x_{padded}[j]$ 要么是 $x[j]$（如果 $j \\ge 0$），要么是 $x[-j]$（如果 $j  0$）。在这两种情况下，原始序列的索引都是非负的。\n-   因此，对于任何 $j$，都有 $\\mathbb{E}[x_{padded}[j]] = m$。\n-   因此，该估计量的期望是：\n    $$\n    \\mathbb{E}[\\hat{\\mu}_{rp}[n]] = \\mathbb{E}\\left[ \\frac{1}{L} \\sum_{k=-M}^{M} x_{padded}[n+k] \\right] = \\frac{1}{L} \\sum_{k=-M}^{M} \\mathbb{E}[x_{padded}[n+k]] = \\frac{1}{L} \\sum_{k=-M}^{M} m\n    $$\n-   该和有 $L=2M+1$ 项。\n    $$\n    \\mathbb{E}[\\hat{\\mu}_{rp}[n]] = \\frac{1}{L} (L \\cdot m) = m\n    $$\n-   偏差为 $b[n] = \\mathbb{E}[\\hat{\\mu}_{rp}[n]] - m = m - m = 0$。这对所有 $n$ 都成立，包括边界和内部。\n-   **结论**：该陈述是正确的。\n\n**C. 在场景 2 中，在左边界索引 $n = 0$ 处使用反射填充时，中心移动平均等于 $b + \\dfrac{a M (M+1)}{2M+1}$，这意味着除非 $a = 0$，否则存在非零的边界偏差。**\n\n-   **分析**：在场景 2 中，$x[n] = an+b$。问题中的措辞“等于”表明需要研究该确定性信号的滤波器输出（或者等价地，如果存在零均值噪声，则研究期望输出）。在 $n=0$ 处，窗口是 $[-M, M]$。我们使用反射填充，$x_p[k] = x[-k]$（对于 $k0$）。\n    $$\n    \\hat{\\mu}_{rp}[0] = \\frac{1}{L} \\sum_{k=-M}^{M} x_p[k] = \\frac{1}{L} \\left( x[0] + \\sum_{k=1}^{M} x_p[k] + \\sum_{k=-M}^{-1} x_p[k] \\right)\n    $$\n    $$\n    \\hat{\\mu}_{rp}[0] = \\frac{1}{L} \\left( x[0] + \\sum_{k=1}^{M} x[k] + \\sum_{j=1}^{M} x_p[-j] \\right) = \\frac{1}{L} \\left( x[0] + \\sum_{k=1}^{M} x[k] + \\sum_{j=1}^{M} x[j] \\right) = \\frac{1}{L} \\left( x[0] + 2 \\sum_{k=1}^{M} x[k] \\right)\n    $$\n-   代入 $x[k] = ak+b$：\n    $$\n    \\hat{\\mu}_{rp}[0] = \\frac{1}{2M+1} \\left( (a\\cdot 0 + b) + 2 \\sum_{k=1}^{M} (ak+b) \\right)\n    $$\n    $$\n    \\hat{\\mu}_{rp}[0] = \\frac{1}{2M+1} \\left( b + 2a \\sum_{k=1}^{M} k + 2 \\sum_{k=1}^{M} b \\right)\n    $$\n-   使用求和恒等式 $\\sum_{k=1}^{M} k = \\frac{M(M+1)}{2}$：\n    $$\n    \\hat{\\mu}_{rp}[0] = \\frac{1}{2M+1} \\left( b + 2a \\frac{M(M+1)}{2} + 2Mb \\right) = \\frac{1}{2M+1} \\left( (2M+1)b + aM(M+1) \\right)\n    $$\n    $$\n    \\hat{\\mu}_{rp}[0] = b + \\frac{aM(M+1)}{2M+1}\n    $$\n-   公式是正确的。真实的信号值为 $x[0] = b$。偏差为 $b[0] = \\hat{\\mu}_{rp}[0] - x[0] = \\frac{aM(M+1)}{2M+1}$。由于 $M \\ge 1$，如果 $a \\neq 0$，此偏差非零。\n-   **结论**：该陈述是正确的。\n\n**D. 在场景 1 中，相对于内部，补零在边界处是方差中性的，因为移动平均核的权重总和为 1。**\n\n-   **分析**：这个陈述是关于方差的。让我们使用场景 3 的简化（近似方差为 $\\sigma^2$ 的白噪声）来分析其核心效应。在这种情况下，$\\text{Var}(x[n]) = \\sigma^2$ 且对于 $n \\neq k$，$\\text{Cov}(x[n], x[k])=0$。\n-   **内部方差**：$\\hat{\\mu}_{int}[n] = \\frac{1}{L} \\sum_{k=n-M}^{n+M} x[k]$。由于这 $L$ 个样本是不相关的，\n    $$\n    \\text{Var}(\\hat{\\mu}_{int}[n]) = \\frac{1}{L^2} \\sum_{k=n-M}^{n+M} \\text{Var}(x[k]) = \\frac{L\\sigma^2}{L^2} = \\frac{\\sigma^2}{L}\n    $$\n-   **边界方差（补零）**：在 $0 \\le n  M$ 处，$\\hat{\\mu}_{zp}[n] = \\frac{1}{L} \\sum_{k=0}^{n+M} x[k]$。该和包含 $n+M+1$ 个随机变量。填充的零是常数，方差为零。\n    $$\n    \\text{Var}(\\hat{\\mu}_{zp}[n]) = \\frac{1}{L^2} \\sum_{k=0}^{n+M} \\text{Var}(x[k]) = \\frac{(n+M+1)\\sigma^2}{L^2}\n    $$\n-   因为 $n  M$，我们有 $n+M+1  2M+1 = L$。因此：\n    $$\n    \\text{Var}(\\hat{\\mu}_{zp}[n]) = \\frac{(n+M+1)\\sigma^2}{L^2}  \\frac{L\\sigma^2}{L^2} = \\text{Var}(\\hat{\\mu}_{int}[n])\n    $$\n-   边界处的方差低于内部。因此，补零不是方差中性的。所给出的原因（“因为移动平均核的权重总和为 1”）与此处的方差比较无关；该性质关系到恒定信号的偏差，而不是边界处的方差行为。\n-   **结论**：该陈述是不正确的。\n\n**E. 在场景 3 中，补零和反射填充都产生无偏估计；然而，在边界处，补零产生的方差比内部平均值低，而反射填充由于反射窗口中存在重复样本，产生的方差比内部平均值高。**\n\n-   **分析**：场景 3 指定了一个零均值（$m=0$）且近似白噪声的过程。我们假设理想白噪声，其 $\\mathbb{E}[x[n]]=0$ 且 $\\text{Var}(x[n])=\\sigma^2$。\n-   **偏差**：\n    -   补零：根据 A 的分析，$\\mathbb{E}[\\hat{\\mu}_{zp}[n]] = \\frac{n+M+1}{L} m$。当 $m=0$ 时，结果为 0。无偏。\n    -   反射填充：根据 B 的分析，$\\mathbb{E}[\\hat{\\mu}_{rp}[n]] = m$。当 $m=0$ 时，结果为 0。无偏。\n    -   所以，陈述的第一部分是正确的。\n-   **方差（补零）**：\n    -   正如在 D 的分析中所示，$\\text{Var}(\\hat{\\mu}_{zp}[n])  \\text{Var}(\\hat{\\mu}_{int}[n])$ 在边界处成立。陈述“补零产生的方差比内部平均值低”是正确的。\n-   **方差（反射填充）**：\n    -   我们来分析边界处的方差，例如 $n=0$。根据 C 的分析，$\\hat{\\mu}_{rp}[0] = \\frac{1}{L} \\left( x[0] + 2 \\sum_{k=1}^{M} x[k] \\right)$。项 $x[0], x[1], \\dots, x[M]$ 是不相关的。\n    $$\n    \\text{Var}(\\hat{\\mu}_{rp}[0]) = \\frac{1}{L^2} \\text{Var}\\left(x[0] + 2 \\sum_{k=1}^{M} x[k]\\right) = \\frac{1}{L^2} \\left(\\text{Var}(x[0]) + 4 \\sum_{k=1}^{M} \\text{Var}(x[k])\\right)\n    $$\n    $$\n    \\text{Var}(\\hat{\\mu}_{rp}[0]) = \\frac{1}{L^2} (\\sigma^2 + 4M\\sigma^2) = \\frac{(4M+1)\\sigma^2}{(2M+1)^2}\n    $$\n    -   与内部方差 $\\text{Var}(\\hat{\\mu}_{int}) = \\frac{\\sigma^2}{L} = \\frac{\\sigma^2}{2M+1} = \\frac{(2M+1)\\sigma^2}{(2M+1)^2}$ 比较。\n    -   由于 $M \\ge 1$，我们有 $4M+1 > 2M+1$。因此，$\\text{Var}(\\hat{\\mu}_{rp}[0]) > \\text{Var}(\\hat{\\mu}_{int})$。方差更高。这是由于“重复样本”（$x[k]$ 在和中同时用于 $k$ 和 $-k$ 项），这在求和中引入了正相关（一个变量与自身完全相关），与独立样本的平均值相比，增加了方差。\n-   **结论**：该陈述是正确的。\n\n### 正确陈述总结\n\n根据分析，陈述 A、B、C 和 E 是正确的。陈述 D 是不正确的。",
            "answer": "$$\\boxed{ABCE}$$"
        }
    ]
}