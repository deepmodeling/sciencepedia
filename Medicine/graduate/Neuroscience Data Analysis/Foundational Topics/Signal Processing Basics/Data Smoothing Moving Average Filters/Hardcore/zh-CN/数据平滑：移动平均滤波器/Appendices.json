{
    "hands_on_practices": [
        {
            "introduction": "移动平均滤波器本质上是信号与一个矩形脉冲响应的卷积。对于较长的滤波窗口，直接计算卷积的成本很高，因此开发高效的算法至关重要。本练习将指导您从离散时间卷积的基本定义出发，推导出一个高效的递归算法，即“运行总和”法，这是实时信号处理中的一个基本技巧。",
            "id": "4153544",
            "problem": "一个神经生理学实验室通过以固定的采样间隔 $\\Delta t$ 对神经脉冲进行分箱，获得了一个离散时间的神经元发放率序列 $x[n]$，$n \\in \\mathbb{Z}$。为了在保留慢速漂移的同时减少高频变异，该团队应用了一个因果的 $M$ 点简单移动平均滤波器。该滤波器实现为一个线性时不变 (LTI) 系统，其脉冲响应 $h[n]$ 由 $h[n] = \\frac{1}{M}$（对于 $n = 0, 1, \\dots, M-1$）和 $h[n] = 0$（其他情况）给出。输出 $y[n]$ 由离散时间卷积 $y[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]$ 定义。假设输入进行了零填充，即对于 $n  0$ 有 $x[n] = 0$。\n\n仅从离散时间卷积的定义和指定的脉冲响应出发，推导一个可用于以恒定每样本成本计算 $y[n]$ 的滑动和 $s[n]$ 的高效因果递归关系，并将 $y[n]$ 用 $s[n]$ 和 $M$ 表示。不要假定任何未经证明的快捷公式。\n\n然后，假设输入是一个斜坡加偏移信号 $x[n] = \\alpha n + \\beta$（对于所有整数 $n \\geq 0$）和 $x[n] = 0$（对于 $n  0$），其中 $\\alpha$ 和 $\\beta$ 是实常数。使用你推导的递归关系，确定对所有整数 $n \\geq M - 1$ 有效的平滑后输出 $y[n]$ 的闭式表达式。将你的最终结果明确表示为一个关于 $n$、$M$、$\\alpha$ 和 $\\beta$ 的单一闭式解析表达式。无需进行舍入。",
            "solution": "该问题被评估为有效。它在科学上基于标准的线性系统理论，是良构的、客观的，并包含了得出唯一解所需的所有必要信息。\n\n该问题包括两个部分。首先，我们必须为简单移动平均滤波器推导一个高效的递归算法。其次，我们必须将此滤波器应用于一个特定的输入信号，并找出输出的闭式表达式。\n\n第1部分：递归算法的推导\n\n线性时不变 (LTI) 系统的输出 $y[n]$ 由输入信号 $x[n]$ 和系统脉冲响应 $h[n]$ 的离散时间卷积给出：\n$$\ny[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n一个因果 $M$ 点简单移动平均滤波器的脉冲响应 $h[n]$ 如下：\n$$\nh[n] = \\begin{cases} \\frac{1}{M}  \\text{对于 } 0 \\le n \\le M-1 \\\\ 0  \\text{其他情况} \\end{cases}\n$$\n卷积和中的 $h[n-k]$ 项仅在其自变量 $n-k$ 位于区间 $[0, M-1]$ 内时非零。这意味着 $0 \\le n-k \\le M-1$。对 $k$ 求解，我们得到 $n-M+1 \\le k \\le n$。\n因此，卷积和可以重写为具有有限界限的形式：\n$$\ny[n] = \\sum_{k=n-M+1}^{n} x[k]\\,h[n-k]\n$$\n在此求和范围内，$h[n-k] = \\frac{1}{M}$。因此，我们有：\n$$\ny[n] = \\sum_{k=n-M+1}^{n} x[k]\\,\\frac{1}{M} = \\frac{1}{M} \\sum_{k=n-M+1}^{n} x[k]\n$$\n为创建一种高效的计算方法，我们定义一个滑动和 $s[n]$ 为：\n$$\ns[n] = \\sum_{k=n-M+1}^{n} x[k]\n$$\n根据此定义，输出 $y[n]$ 可以简单地用 $s[n]$ 和 $M$ 表示为：\n$$\ny[n] = \\frac{s[n]}{M}\n$$\n为了找到 $s[n]$ 的递归关系，我们考察 $s[n]$ 和 $s[n-1]$ 之间的关系。$s[n-1]$ 的表达式为：\n$$\ns[n-1] = \\sum_{k=(n-1)-M+1}^{n-1} x[k] = \\sum_{k=n-M}^{n-1} x[k]\n$$\n我们可以写出 $s[n]$ 的各项：\n$$\ns[n] = x[n] + x[n-1] + \\dots + x[n-M+1]\n$$\n以及 $s[n-1]$ 的各项：\n$$\ns[n-1] = x[n-1] + x[n-2] + \\dots + x[n-M]\n$$\n通过比较这两个和，我们可以看到 $s[n]$ 可以通过在 $s[n-1]$ 的基础上加上新样本 $x[n]$ 并减去前一个窗口中最旧的样本 $x[n-M]$ 来获得。这就得到了如下递归关系：\n$$\ns[n] = s[n-1] + x[n] - x[n-M]\n$$\n这个递归关系非常高效，因为对于每个新样本 $n$，无论滤波器长度 $M$ 为何，它都只需要一次加法和一次减法。这构成了恒定的每样本计算成本。注意，因为输入是零填充的（对于 $n0$ 有 $x[n]=0$），所以当 $n  M$ 时 $x[n-M]$ 项为零。该递归关系对 $n \\ge M$ 完全有效。\n\n第2部分：应用于斜坡加偏移输入\n\n我们给定的输入信号是 $x[n] = \\alpha n + \\beta$（对于 $n \\ge 0$）和 $x[n]=0$（对于 $n0$）。我们需要找到对于所有整数 $n \\ge M-1$ 的 $y[n]$ 的闭式表达式。我们将使用为滑动和 $s[n]$ 推导出的递归关系。\n\n$s[n]$ 的递归是由差值 $x[n] - x[n-M]$ 驱动的。对于 $n \\ge M$， $n$ 和 $n-M$ 都是非负的，所以我们可以使用表达式 $x[n] = \\alpha n + \\beta$。\n$$\nx[n] - x[n-M] = (\\alpha n + \\beta) - (\\alpha(n-M) + \\beta)\n$$\n$$\nx[n] - x[n-M] = \\alpha n + \\beta - \\alpha n + \\alpha M - \\beta = \\alpha M\n$$\n对于 $n \\ge M$，滑动和的差分方程变为：\n$$\ns[n] = s[n-1] + \\alpha M\n$$\n这是一个带常数强迫项的一阶线性非齐次差分方程。其解表明，对于 $n \\ge M$，$s[n]$ 构成一个等差数列。\n\n为了找到对于 $n \\ge M-1$ 的 $s[n]$ 的闭式表达式，我们可以用一个初始值 $s[M-1]$ 和随后的增量来表示 $s[n]$。\n$$\ns[n] = s[M-1] + \\sum_{j=M}^{n} (s[j] - s[j-1])\n$$\n对于 $j \\ge M$，我们有 $s[j] - s[j-1] = \\alpha M$。这个和从 $j=M$ 到 $n$，共包含 $n-M+1$ 项。\n$$\ns[n] = s[M-1] + \\sum_{j=M}^{n} \\alpha M = s[M-1] + (n-M+1)\\alpha M\n$$\n这个公式对 $n \\ge M-1$ 有效。当 $n=M-1$ 时，和是空的（或有零项），所以 $s[M-1]=s[M-1]$。\n\n接下来，我们必须通过直接求和来计算初始值 $s[M-1]$。由于 $n=M-1$， $s[M-1]$ 的求和范围是从 $k=(M-1)-M+1=0$ 到 $k=M-1$。\n$$\ns[M-1] = \\sum_{k=0}^{M-1} x[k]\n$$\n在这个 $k$ 的范围内，$k \\ge 0$，所以 $x[k] = \\alpha k + \\beta$。\n$$\ns[M-1] = \\sum_{k=0}^{M-1} (\\alpha k + \\beta) = \\alpha \\sum_{k=0}^{M-1} k + \\beta \\sum_{k=0}^{M-1} 1\n$$\n使用等差数列求和公式和常数数列求和公式：\n$$\n\\sum_{k=0}^{M-1} k = \\frac{(M-1)M}{2}\n$$\n$$\n\\sum_{k=0}^{M-1} 1 = M\n$$\n代入这些结果，我们得到：\n$$\ns[M-1] = \\alpha \\frac{(M-1)M}{2} + \\beta M\n$$\n现在我们将 $s[M-1]$ 的这个表达式代回到 $s[n]$ 的方程中：\n$$\ns[n] = \\left(\\alpha \\frac{(M-1)M}{2} + \\beta M\\right) + (n-M+1)\\alpha M\n$$\n我们可以提出因子 $\\alpha M$ 并合并各项：\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{M-1}{2} + (n-M+1) \\right]\n$$\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{M-1 + 2n - 2M + 2}{2} \\right]\n$$\n$$\ns[n] = \\beta M + \\alpha M \\left[ \\frac{2n - M + 1}{2} \\right]\n$$\n最后，我们计算输出 $y[n] = s[n]/M$：\n$$\ny[n] = \\frac{1}{M} \\left( \\beta M + \\alpha M \\left[ \\frac{2n - M + 1}{2} \\right] \\right)\n$$\n$$\ny[n] = \\beta + \\alpha \\left( \\frac{2n - M + 1}{2} \\right)\n$$\n这个表达式可以重新整理成一个更易于解释的形式：\n$$\ny[n] = \\beta + \\alpha \\left( n - \\frac{M-1}{2} \\right) = \\alpha n + \\beta - \\frac{\\alpha(M-1)}{2}\n$$\n这就是对所有整数 $n \\ge M-1$ 有效的输出 $y[n]$ 的闭式表达式。它表明，平滑后的输出也是一个斜率同为 $\\alpha$ 的斜坡信号，但其偏移量有所修正。$-\\frac{\\alpha(M-1)}{2}$ 项代表一个恒定的垂直位移，这与移动平均滤波器的群延迟有关。",
            "answer": "$$\\boxed{\\alpha n + \\beta - \\frac{\\alpha(M-1)}{2}}$$"
        },
        {
            "introduction": "理解了如何高效地计算移动平均后，我们需要探究它对信号频率成分的具体影响。本练习将通过推导移动平均滤波器的频率响应，揭示其作为低通滤波器的本质。通过计算一个假设的神经信号中不同频率成分的衰减程度，您将直观地理解平滑如何选择性地抑制快速波动，同时保留慢速变化的趋势。",
            "id": "4153579",
            "problem": "一个神经科学实验室记录了来自大脑皮层的阵发性群体脉冲序列，并将其瞬时放电强度建模为一个确定性平均速率加上代表阵发调制和快速微观结构的振荡分量。具体而言，该速率建模为 $r(t) = r_{0} + b \\cos(2 \\pi f_{b} t) + c \\cos(2 \\pi f_{h} t)$，其中 $r_{0}$ 是一个非负常数基线，$b$ 和 $c$ 是非负振幅，$f_{b}$ 和 $f_{h}$ 是以赫兹为单位的正频率，且 $f_{h}  f_{b}$。为了在进行阵发检测前减少高频波动，该实验室应用了一个因果移动平均平滑器，其矩形核的持续时间为 $T$，定义为当 $0 \\leq t \\leq T$ 时，$h(t) = \\frac{1}{T}$，其他情况下 $h(t) = 0$，通过时域卷积产生平滑后的速率 $\\tilde{r}(t) = (r * h)(t)$。\n\n仅使用时域卷积和傅里叶变换的基本定义，推导移动平均平滑器的频率响应幅值作为角频率 $\\omega$ 的函数的解析表达式。然后，利用该结果，计算高频分量与阵发分量的衰减幅值之比，\n$$\\rho = \\frac{A(f_{h})}{A(f_{b})},$$\n其中 $A(f)$ 是平滑器对频率为 $f$ 的余弦波所施加的振幅增益。对 $T = 0.075$ s, $f_{b} = 20$ Hz, 和 $f_{h} = 70$ Hz 计算 $\\rho$ 的值，并将最终答案表示为单个精确的解析表达式。不要对最终答案进行四舍五入或近似。该比值不带单位。",
            "solution": "所述问题具有科学依据、客观且适定。所有提供的信息都是一致的，并且足以得到唯一解。所引用的概念——卷积、傅里叶变换和频率响应——是信号处理中的基本原理，并恰当地应用于神经科学数据分析的背景中。因此，将推导出解答。\n\n第一个任务是推导因果移动平均平滑器的频率响应幅值 $|H(\\omega)|$。该平滑器由其脉冲响应，即矩形核定义：\n$$h(t) = \\begin{cases} \\frac{1}{T}  \\text{for } 0 \\leq t \\leq T \\\\ 0  \\text{其他情况} \\end{{cases}$$\n频率响应 $H(\\omega)$ 是脉冲响应 $h(t)$ 的傅里叶变换。傅里叶变换的定义是：\n$$H(\\omega) = \\mathcal{F}\\{h(t)\\} = \\int_{-\\infty}^{\\infty} h(t) e^{-i\\omega t} dt$$\n将 $h(t)$ 的表达式代入积分中：\n$$H(\\omega) = \\int_{0}^{T} \\frac{1}{T} e^{-i\\omega t} dt$$\n我们可以直接计算这个积分。对于 $\\omega \\neq 0$：\n$$H(\\omega) = \\frac{1}{T} \\left[ \\frac{e^{-i\\omega t}}{-i\\omega} \\right]_{0}^{T} = \\frac{1}{T} \\left( \\frac{e^{-i\\omega T} - e^{0}}{-i\\omega} \\right) = \\frac{e^{-i\\omega T} - 1}{-i\\omega T} = \\frac{1 - e^{-i\\omega T}}{i\\omega T}$$\n为了分离幅度和相位，我们通过提出一个对称的相位因子来重写这个复数表达式：\n$$H(\\omega) = \\frac{e^{-i\\omega T/2}(e^{i\\omega T/2} - e^{-i\\omega T/2})}{i\\omega T}$$\n使用欧拉公式 $e^{i\\phi} - e^{-i\\phi} = 2i\\sin(\\phi)$，我们可以将分子中的括号项简化为：\n$$e^{i\\omega T/2} - e^{-i\\omega T/2} = 2i\\sin\\left(\\frac{\\omega T}{2}\\right)$$\n将此代回 $H(\\omega)$ 的表达式中：\n$$H(\\omega) = \\frac{e^{-i\\omega T/2} \\left( 2i\\sin\\left(\\frac{\\omega T}{2}\\right) \\right)}{i\\omega T} = e^{-i\\omega T/2} \\frac{2\\sin\\left(\\frac{\\omega T}{2}\\right)}{\\omega T}$$\n这个表达式可以用sinc函数 $\\text{sinc}(x) = \\frac{\\sin(\\pi x)}{\\pi x}$ 来表示，但我们将继续使用当前的形式。频率响应的幅值是：\n$$|H(\\omega)| = \\left| e^{-i\\omega T/2} \\frac{2\\sin(\\frac{\\omega T}{2})}{\\omega T} \\right| = |e^{-i\\omega T/2}| \\left| \\frac{2\\sin(\\frac{\\omega T}{2})}{\\omega T} \\right|$$\n因为对于任意实数 $\\phi$，都有 $|e^{-i\\phi}| = 1$，并注意到 $\\frac{2\\sin(\\frac{\\omega T}{2})}{\\omega T} = \\frac{\\sin(\\frac{\\omega T}{2})}{\\frac{\\omega T}{2}}$，我们有：\n$$|H(\\omega)| = \\left| \\frac{\\sin(\\frac{\\omega T}{2})}{\\frac{\\omega T}{2}} \\right|$$\n这就是频率响应幅值作为角频率 $\\omega$ 函数的解析表达式。\n\n问题将 $A(f)$ 定义为平滑器施加于频率为 $f$ 的余弦波上的振幅增益。对于一个线性时不变 (LTI) 系统，在给定频率下的振幅增益恰好是在相应角频率 $\\omega = 2\\pi f$ 处计算的频率响应的幅值。因此：\n$$A(f) = |H(2\\pi f)| = \\left| \\frac{\\sin(\\frac{2\\pi f T}{2})}{\\frac{2\\pi f T}{2}} \\right| = \\left| \\frac{\\sin(\\pi f T)}{\\pi f T} \\right|$$\n我们需要计算衰减幅值的比率 $\\rho = \\frac{A(f_h)}{A(f_b)}$。将 $A(f)$ 的表达式代入：\n$$\\rho = \\frac{\\left| \\frac{\\sin(\\pi f_{h} T)}{\\pi f_{h} T} \\right|}{\\left| \\frac{\\sin(\\pi f_{b} T)}{\\pi f_{b} T} \\right|}$$\n由于 $f_b$、$f_h$ 和 $T$ 均为正值，分母 $\\pi f_h T$ 和 $\\pi f_b T$ 也为正值。我们可以将表达式重写为：\n$$\\rho = \\frac{|\\sin(\\pi f_{h} T)|}{\\pi f_{h} T} \\cdot \\frac{\\pi f_{b} T}{|\\sin(\\pi f_{b} T)|} = \\frac{f_b}{f_h} \\frac{|\\sin(\\pi f_{h} T)|}{|\\sin(\\pi f_{b} T)|} = \\frac{f_b}{f_h} \\left| \\frac{\\sin(\\pi f_{h} T)}{\\sin(\\pi f_{b} T)} \\right|$$\n现在，我们代入给定的数值：$T = 0.075$ s, $f_b = 20$ Hz, 以及 $f_h = 70$ Hz。\n首先，我们计算正弦函数的自变量：\n对于阵发分量频率 $f_b$：\n$$\\pi f_b T = \\pi (20) (0.075) = \\pi (1.5) = \\frac{3\\pi}{2}$$\n对于高频分量 $f_h$：\n$$\\pi f_h T = \\pi (70) (0.075) = \\pi (5.25) = \\frac{21\\pi}{4}$$\n接下来，我们计算这些自变量的正弦函数值：\n$$\\sin(\\pi f_b T) = \\sin\\left(\\frac{3\\pi}{2}\\right) = -1$$\n$$\\sin(\\pi f_h T) = \\sin\\left(\\frac{21\\pi}{4}\\right) = \\sin\\left(\\frac{16\\pi + 5\\pi}{4}\\right) = \\sin\\left(4\\pi + \\frac{5\\pi}{4}\\right) = \\sin\\left(\\frac{5\\pi}{4}\\right)$$\n由于 $\\frac{5\\pi}{4}$ 位于第三象限，其正弦值为负。参考角是 $\\frac{\\pi}{4}$。\n$$\\sin\\left(\\frac{5\\pi}{4}\\right) = -\\sin\\left(\\frac{\\pi}{4}\\right) = -\\frac{\\sqrt{2}}{2}$$\n最后，我们将这些值代入 $\\rho$ 的表达式中：\n$$\\rho = \\frac{20}{70} \\left| \\frac{-\\frac{\\sqrt{2}}{2}}{-1} \\right| = \\frac{2}{7} \\left| \\frac{\\sqrt{2}}{2} \\right| = \\frac{2}{7} \\cdot \\frac{\\sqrt{2}}{2}$$\n化简该表达式得到最终的精确答案：\n$$\\rho = \\frac{\\sqrt{2}}{7}$$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{7}}$$"
        },
        {
            "introduction": "理论推导通常假设信号是无限长的，但真实世界的神经科学数据总是有限的。最后的这个练习将解决处理信号边界这一关键问题。通过编程实现并比较一个“朴素的”零填充滤波器和一个科学上更合理的“重归一化”滤波器，您将看到不正确的边界处理如何引入人为误差（如边界处的增益衰减），从而深刻理解保留信号统计特性的重要性。",
            "id": "4153595",
            "problem": "给定一个有限离散时间信号，要求你实现一种平滑操作，该操作适用于神经科学时间序列，例如神经元荧光轨迹或瞬时脉冲发放率估计。考虑一个长度为 $N$ 的实值离散时间信号 $x[n]$，其索引为 $n \\in \\{0,1,\\dots,N-1\\}$。半宽度为 $w \\in \\mathbb{Z}_{\\ge 0}$ 的移动平均平滑在每个样本点上使用一个以该点为中心、名义长度为 $2w+1$ 的对称窗口。在边界附近（$n$ 接近 $0$ 或 $N-1$），这个窗口会超出可用样本的范围。你必须实现一种重归一化移动平均，对于每个索引 $n$，该方法用截断窗口中包含的实际样本数量进行除法运算，而不是使用名义窗口长度。并且，你必须证明这种归一化方法对于常数信号能够保持单位增益。\n\n从离散时间信号和线性平滑算子的基本定义开始。将平滑过程视为一个操作，该操作将每个 $x[n]$ 替换为在其对称邻域内计算的局部均值。不要假设信号是无限长的，也不要使用任何在边界之外插入人为值的假设。算法必须只使用可用数据，并且在边缘处必须通过实际包含的样本数量进行重归一化。\n\n程序要求：\n- 实现一个函数，输入为 $x[n]$ 和整数半宽度 $w$，返回所有 $n \\in \\{0,1,\\dots,N-1\\}$ 的重归一化移动平均输出 $y[n]$。该实现必须对所有 $w \\ge 0$ 都正确，包括 $2w+1  N$ 的情况。\n- 为了进行比较，实现一个朴素的零填充移动平均，该方法使用长度为 $2w+1$ 的均匀窗口，除以 $2w+1$，并通过与矩形核的标准离散卷积隐式地将越界样本视为零。\n- 使用这些实现来计算下面测试套件中指定的量。\n- 通过量化重归一化移动平均与原始常数值的偏差，来证明对常数信号的单位增益保持特性。\n\n测试套件：\n- 情况 1（常数信号，内部-边缘行为）：设 $N=100$，$w=5$，且对所有 $n$ 有 $x[n]=3.7$。计算重归一化移动平均输出 $y[n]$，并返回最大绝对偏差 $\\max_{0 \\le n \\le N-1} |y[n]-3.7|$，结果为浮点数。\n- 情况 2（窗口长于信号）：设 $N=20$，$w=20$，且对所有 $n$ 有 $x[n]=n$。计算重归一化移动平均输出 $y[n]$，并返回其与全局均值 $\\mu=\\frac{1}{N}\\sum_{n=0}^{N-1} x[n]$ 的最大绝对偏差，即 $\\max_{0 \\le n \\le N-1} |y[n]-\\mu|$，结果为浮点数。\n- 情况 3（恒等边界情况）：设 $N=15$，$w=0$，且对所有 $n$ 有 $x[n]=(-1)^n$。计算重归一化移动平均输出 $y[n]$，并返回最大绝对偏差 $\\max_{0 \\le n \\le N-1} |y[n]-x[n]|$，结果为浮点数。\n- 情况 4（单位增益比较，朴素方法）：设 $N=50$，$w=3$，且对所有 $n$ 有 $x[n]=5$。计算朴素零填充移动平均输出 $y_{\\text{naive}}[n]$。返回第一个样本点的增益 $g_{\\text{naive}} = \\frac{y_{\\text{naive}}[0]}{5}$，结果为浮点数。\n- 情况 5（单位增益比较，重归一化方法）：使用与情况 4 相同的设置，计算重归一化移动平均输出 $y[n]$。返回第一个样本点的增益 $g_{\\text{renorm}} = \\frac{y[0]}{5}$，结果为浮点数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），$r_1$ 到 $r_5$ 分别对应于上述情况 1 到 5 的输出。所有值必须打印为 Python 浮点数。不涉及物理单位；将所有量视为无量纲量。",
            "solution": "该问题要求实现并分析应用于有限离散时间信号的两种移动平均滤波器，重点关注它们在信号边界处的行为。这种分析在神经科学等领域尤其重要，因为在这些领域中，保持生理信号的基线至关重要。\n\n一个有限的、实值的离散时间信号是一个长度为 $N$ 的数字序列 $x[n]$，其中索引 $n$ 属于集合 $\\{0, 1, \\dots, N-1\\}$。平滑此信号涉及将每个样本 $x[n]$ 替换为其邻近值的平均值。\n\n首先，我们定义**重归一化移动平均**。这种方法旨在为常数信号保持单位增益（也称为保留直流分量），这一特性贯穿整个信号，包括其边界。对于给定的半宽度 $w \\in \\mathbb{Z}_{\\ge 0}$，滤波器在每个索引 $n$ 处考虑一个名义长度为 $2w+1$ 的对称窗口。输出信号 $y[n]$ 的计算如下：\n\n对于每个样本索引 $n \\in \\{0, 1, \\dots, N-1\\}$，要求平均的索引集由窗口 $[n-w, n+w]$ 和有效信号域 $[0, N-1]$ 的交集确定。该有效窗口的起始和结束索引为：\n$$k_{start}(n) = \\max(0, n-w)$$\n$$k_{end}(n) = \\min(N-1, n+w)$$\n\n此窗口内信号值的未归一化总和为：\n$$S[n] = \\sum_{k=k_{start}(n)}^{k_{end}(n)} x[k]$$\n\n重归一化的关键步骤是用总和中实际包含的样本数来除以这个总和，而不是用名义窗口长度 $2w+1$。有效窗口中的样本数量为：\n$$C[n] = k_{end}(n) - k_{start}(n) + 1$$\n\n则重归一化移动平均输出 $y[n]$ 由下式给出：\n$$y[n] = \\frac{S[n]}{C[n]} = \\frac{\\sum_{k=\\max(0, n-w)}^{\\min(N-1, n+w)} x[k]}{\\min(N-1, n+w) - \\max(0, n-w) + 1}$$\n\n这种归一化方案保证了对常数信号的单位增益。为了证明这一点，设对所有 $n$ 都有 $x[n] = c$，其中 $c$ 是一个常数。总和 $S[n]$ 变为：\n$$S[n] = \\sum_{k=k_{start}(n)}^{k_{end}(n)} c = c \\cdot (k_{end}(n) - k_{start}(n) + 1) = c \\cdot C[n]$$\n因此，输出为：\n$$y[n] = \\frac{c \\cdot C[n]}{C[n]} = c$$\n这表明对所有 $n$ 都有 $y[n] = x[n]$，意味着常数信号未经改变地通过了滤波器。这个特性对于避免在数据集边缘产生人为衰减至关重要。一个高效计算所有 $n$ 的 $S[n]$ 的算法是预先计算 $x[n]$ 的累积和，这使得每个 $S[n]$ 可以在 $O(1)$ 时间内计算出来，从而得到一个整体时间复杂度为 $O(N)$ 的算法。\n\n其次，我们考虑**朴素的零填充移动平均**。这种方法反映了带有零填充的标准离散卷积的行为。滤波器核（或冲激响应）$h[k]$ 被定义为一个归一化的矩形窗口：\n$$\nh[k] = \\begin{cases}\n\\frac{1}{2w+1}  \\text{for } -w \\le k \\le w \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n输出 $y_{\\text{naive}}[n]$ 是信号 $x[n]$ 与核 $h[k]$ 的离散卷积，形式上写为 $(x*h)[n]$。对于有限信号，此操作通常通过在其边界之外用零扩展信号来实现。输出为：\n$$y_{\\text{naive}}[n] = \\sum_{k=-w}^{w} x_{\\text{padded}}[n-k] \\cdot \\frac{1}{2w+1}$$\n其中，如果 $0 \\le m \\le N-1$，则 $x_{\\text{padded}}[m] = x[m]$，否则 $x_{\\text{padded}}[m] = 0$。与重归一化滤波器不同，这里的除数始终是常数 $2w+1$。\n\n除数的这种恒定性导致了边界处的增益衰减。考虑一个常数信号 $x[n]=c0$。在左边界 $n=0$ 处，总和包括了 $k \\in [-w, w]$ 的项 $x_{\\text{padded}}[-k]$。非零项是对于 $k \\in [0, w]$ 的项，总共有 $w+1$ 项。\n$$y_{\\text{naive}}[0] = \\frac{1}{2w+1} \\sum_{k=0}^{w} x[k] = \\frac{1}{2w+1} \\sum_{k=0}^{w} c = \\frac{c(w+1)}{2w+1}$$\n在 $n=0$ 处的增益是输出与输入的比值，$g_{\\text{naive}} = \\frac{y_{\\text{naive}}[0]}{c}$：\n$$g_{\\text{naive}} = \\frac{w+1}{2w+1}$$\n对于任何 $w  0$，此增益都小于 $1$，这证明了衰减效应。相比之下，重归一化滤波器在所有点上都产生 $1$ 的增益。\n\n所提供的测试套件旨在验证这些确切的属性：\n- 情况 1：确认重归一化滤波器对常数信号的单位增益属性。在浮点精度允许的范围内，偏差应为零。\n- 情况 2：探讨当窗口宽度超过信号长度时的行为。重归一化滤波器应该为每个输出样本计算信号的全局均值。\n- 情况 3：$w=0$ 的情况对应于长度为 $1$ 的窗口，这应该导致恒等操作（$y[n]=x[n]$）。\n- 情况 4 和 5：直接比较朴素滤波器和重归一化滤波器在信号边界处的增益，突显前者的衰减和后者的单位增益。\n\n实现将遵循这些原则，对重归一化滤波器使用累积和方法，对朴素滤波器使用库函数卷积。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef renormalized_moving_average(x: np.ndarray, w: int) - np.ndarray:\n    \"\"\"\n    Computes the renormalized moving average of a signal.\n    \n    For each sample, the output is the average of the valid signal values\n    within a symmetric window of half-width w. The divisor is the number\n    of valid samples, which may be less than 2w+1 at the boundaries.\n    \n    Args:\n        x: The 1D input signal as a numpy array.\n        w: The integer half-width of the moving average window.\n        \n    Returns:\n        The smoothed signal as a numpy array.\n    \"\"\"\n    N = len(x)\n    if w == 0:\n        return x.copy()\n\n    # Use cumulative sum for an efficient O(N) implementation.\n    # The cumulative sum X[k] = sum(x[0]...x[k-1]).\n    # We pad with a 0 at the beginning to handle sums starting from index 0.\n    # Sum over x[a..b] is X[b+1] - X[a].\n    x_cumsum = np.concatenate(([0], np.cumsum(x)))\n    \n    y = np.zeros(N)\n    \n    for n in range(N):\n        k_start = max(0, n - w)\n        k_end = min(N - 1, n + w)\n        \n        # Calculate sum from pre-computed cumulative sum\n        current_sum = x_cumsum[k_end + 1] - x_cumsum[k_start]\n        \n        # Calculate the number of points in the truncated window\n        count = k_end - k_start + 1\n        \n        y[n] = current_sum / count\n        \n    return y\n\ndef naive_zero_padded_moving_average(x: np.ndarray, w: int) - np.ndarray:\n    \"\"\"\n    Computes a naive zero-padded moving average using standard convolution.\n    \n    The output is computed by convolving the signal with a rectangular\n    kernel of length 2w+1, normalized by 2w+1. The 'same' mode implicitly\n    pads the signal with zeros.\n    \n    Args:\n        x: The 1D input signal as a numpy array.\n        w: The integer half-width of the moving average window.\n        \n    Returns:\n        The smoothed signal as a numpy array.\n    \"\"\"\n    if w == 0:\n        return x.copy()\n\n    window_len = 2 * w + 1\n    kernel = np.ones(window_len) / window_len\n    \n    # 'same' mode ensures output is same size as input, and handles\n    # boundaries by assuming the signal is zero-padded.\n    return np.convolve(x, kernel, mode='same')\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        # Case 1: constant signal, interior-edge behavior\n        {'N': 100, 'w': 5, 'x_func': lambda N: np.full(N, 3.7), 'id': 'case1'},\n        # Case 2: window longer than signal\n        {'N': 20, 'w': 20, 'x_func': lambda N: np.arange(N, dtype=float), 'id': 'case2'},\n        # Case 3: identity boundary case\n        {'N': 15, 'w': 0, 'x_func': lambda N: (-1.0)**np.arange(N), 'id': 'case3'},\n        # Case 4: unit gain comparison, naive method\n        {'N': 50, 'w': 3, 'x_func': lambda N: np.full(N, 5.0), 'id': 'case4'},\n        # Case 5: unit gain comparison, renormalized method\n        {'N': 50, 'w': 3, 'x_func': lambda N: np.full(N, 5.0), 'id': 'case5'},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case['N']\n        w = case['w']\n        x = case['x_func'](N)\n        \n        if case['id'] == 'case1':\n            y = renormalized_moving_average(x, w)\n            result = np.max(np.abs(y - 3.7))\n            results.append(result)\n            \n        elif case['id'] == 'case2':\n            y = renormalized_moving_average(x, w)\n            mu = np.mean(x)\n            result = np.max(np.abs(y - mu))\n            results.append(result)\n\n        elif case['id'] == 'case3':\n            y = renormalized_moving_average(x, w)\n            result = np.max(np.abs(y - x))\n            results.append(result)\n\n        elif case['id'] == 'case4':\n            y_naive = naive_zero_padded_moving_average(x, w)\n            # Gain at the first sample\n            g_naive = y_naive[0] / 5.0\n            results.append(g_naive)\n            \n        elif case['id'] == 'case5':\n            y_renorm = renormalized_moving_average(x, w)\n            # Gain at the first sample\n            g_renorm = y_renorm[0] / 5.0\n            results.append(g_renorm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}