{
    "hands_on_practices": [
        {
            "introduction": "任何谱分析的第一步都是理解时域中的信号功率如何映射到频域。这个练习将通过推导和数值验证来巩固这一基本原理 。你将通过实践证明，对于一个经过正确归一化的周期图，其在所有频率上的总和精确地等于信号在时域中的方差，这是基于帕塞瓦尔定理的一个直接结果。",
            "id": "4187236",
            "problem": "设一个实值、有限长度的神经时间序列表示为 $x[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，以赫兹 (Hz) 为单位的采样频率 $F_s$ 进行均匀采样。定义去均值序列 $y[n] = x[n] - \\bar{x}$，其中 $\\bar{x} = \\frac{1}{N} \\sum_{n=0}^{N-1} x[n]$。有限样本方差定义为 $\\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2$（注意：这不是分母为 $N-1$ 的无偏估计量）。设 $Y[k]$ 表示 $y[n]$ 的离散傅里叶变换 (DFT)，使用非幺正正变换和 $1/N$ 缩放的反变换。并设基于周期图的功率谱密度 (PSD) 根据第一性原理构建，使其在频率上的积分等于根据能量守恒的时域平均功率。\n\n从离散傅里叶变换 (DFT) 和离散傅里叶反变换 (IDFT) 的基本定义出发，并根据 DFT 的时域和频域之间能量守恒的陈述（帕塞瓦尔定理），推导以赫兹为单位的双边周期图的归一化方法，该方法需与 PSD 在频率上的积分和 $y[n]$ 的有限样本方差之间的等式相一致。然后，实现一个数值验证，证明所有 DFT 频箱上的周期图值之和乘以频箱宽度等于 $y[n]$ 的有限样本方差。\n\n您的实现必须：\n- 使用非幺正 DFT 约定 $Y[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2 \\pi k n / N}$ 和 $y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi k n / N}$，其中角度单位为弧度。\n- 构建一个以赫兹为单位的双边周期图，该周期图直接从 $Y[k]$ 获得，使得对所有 $N$ 个频率箱求和并乘以以赫兹为单位的频率箱宽度后，等于有限样本方差 $\\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2$。\n- 不应用任何锥形窗；使用原始的去均值信号。\n- 使用以赫兹为单位的采样频率 $F_s$；周期图值的单位必须是信号单位的平方每赫兹（例如，如果 $x[n]$ 的单位是微伏，则为 $\\mu\\mathrm{V}^2/\\mathrm{Hz}$）。最终的数值检查比较的是无量纲的量（方差和积分后的 PSD），因此输出中不需要物理单位。\n\n数值验证要求和容差：\n- 对每个测试用例，计算绝对误差 $E_\\mathrm{abs} = \\left| \\sum_{k=0}^{N-1} S[k] \\, \\Delta f \\;-\\; \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2 \\right|$，其中 $S[k]$ 是以赫兹为单位的双边周期图，$\\Delta f = \\frac{F_s}{N}$ 是以赫兹为单位的频箱宽度。\n- 同时计算相对误差 $E_\\mathrm{rel} = \\frac{E_\\mathrm{abs}}{\\max\\left(\\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2,\\; \\epsilon\\right)}$，其中 $\\epsilon$ 是一个小的正常数以避免除以零。\n- 对每个用例报告一个布尔值，指示 $\\max(E_\\mathrm{abs}, E_\\mathrm{rel})  10^{-10}$ 是否成立。\n\n测试套件（三角函数的角度单位为弧度；频率单位为赫兹）：\n- 用例 1：$N=1024$，$F_s=1000$。信号 $x[n] = 0.5 + 2.0 \\sin\\!\\left(2\\pi \\cdot 50 \\cdot \\frac{n}{F_s}\\right) + 1.0 \\sin\\!\\left(2\\pi \\cdot 120 \\cdot \\frac{n}{F_s} + 0.3\\right)$。\n- 用例 2：$N=1000$，$F_s=800$。信号 $x[n]$ 是均值为零、标准差为 0.8 的白高斯噪声；为保证可复现性，使用固定的随机种子。\n- 用例 3：$N=4096$，$F_s=2000$。信号 $x[n] = 1.23$（常数）。\n- 用例 4：$N=1501$，$F_s=600$。信号 $x[n]$ 是分段定义的：当 $n  \\lfloor N/3 \\rfloor$ 时，$x[n]=0$；当 $\\lfloor N/3 \\rfloor \\le n  \\lfloor 2N/3 \\rfloor$ 时，$x[n]=3.0$；当 $n \\ge \\lfloor 2N/3 \\rfloor$ 时，$x[n]=3.0 + 0.001 \\cdot \\left(n - \\lfloor 2N/3 \\rfloor \\right)$（一个小的线性斜坡）。\n- 用例 5：$N=2048$，$F_s=1000$。信号 $x[n] = 1.5 \\cos\\!\\left(\\pi n\\right) + 0.7 \\sin\\!\\left(2\\pi \\cdot 70 \\cdot \\frac{n}{F_s} + 0.1\\right) + 0.4 \\sin\\!\\left(2\\pi \\cdot 125.5 \\cdot \\frac{n}{F_s} + 1.7\\right) + 0.05 \\cdot \\eta[n]$，其中 $\\eta[n]$ 是均值为零、单位方差的白高斯噪声；为保证可复现性，使用固定的随机种子。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序排列，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是指示该用例是否通过数值验证的布尔值。",
            "solution": "该问题要求推导双边周期图 $S[k]$ 的归一化因子，使得在频域中计算的总功率等于去均值时间序列 $y[n]$ 的有限样本方差。这个等式是离散傅里叶变换 (DFT) 的帕塞瓦尔定理所表达的能量守恒原理的直接推论。\n\n首先，我们使用指定 DFT 对的帕塞瓦尔定理来建立时域和频域之间的关系。问题将正向和反向 DFT 定义为：\n- 正向 DFT: $Y[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2 \\pi k n / N}$\n- 反向 DFT (IDFT): $y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi k n / N}$\n\n为了推导帕塞瓦尔关系式，我们从信号的总能量开始，即其幅值平方和。由于 $y[n]$ 是实值的，这即为平方和 $\\sum_{n=0}^{N-1} y[n]^2$。\n我们将 IDFT 的定义代入其中一个 $y[n]$ 项：\n$$ \\sum_{n=0}^{N-1} y[n]^2 = \\sum_{n=0}^{N-1} y[n] \\cdot y[n] = \\sum_{n=0}^{N-1} y[n] \\left( \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi k n / N} \\right) $$\n通过交换求和顺序，我们可以对各项进行分组：\n$$ \\sum_{n=0}^{N-1} y[n]^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\left( \\sum_{n=0}^{N-1} y[n] e^{j 2 \\pi k n / N} \\right) $$\n我们识别出内部的和是正向 DFT 的复共轭 $Y^*[k]$。对于实信号 $y[n]$，项 $\\sum_{n=0}^{N-1} y[n] e^{j 2 \\pi k n / N}$ 等价于 $Y[-k]$，即 $Y^*[k]$。一个更直接的方法是代入 IDFT 的共轭：\n$$ \\sum_{n=0}^{N-1} y[n]^2 = \\sum_{n=0}^{N-1} y[n] \\cdot y^*[n] = \\sum_{n=0}^{N-1} y[n] \\left( \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{j 2 \\pi k n / N} \\right)^* = \\sum_{n=0}^{N-1} y[n] \\left( \\frac{1}{N} \\sum_{k=0}^{N-1} Y^*[k] e^{-j 2 \\pi k n / N} \\right) $$\n交换求和顺序：\n$$ \\sum_{n=0}^{N-1} y[n]^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} Y^*[k] \\left( \\sum_{n=0}^{N-1} y[n] e^{-j 2 \\pi k n / N} \\right) $$\n现在内部的和恰好是正向 DFT 的定义，$Y[k]$。由此得出：\n$$ \\sum_{n=0}^{N-1} y[n]^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} Y^*[k] Y[k] = \\frac{1}{N} \\sum_{k=0}^{N-1} |Y[k]|^2 $$\n这就是给定 DFT 约定下的帕塞瓦尔定理。\n\n问题将时域平均功率定义为 $y[n]$ 的有限样本方差：\n$$ P_{\\text{avg}} = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2 $$\n利用推导出的帕塞瓦尔关系式，我们可以用 DFT 系数来表示这个平均功率：\n$$ P_{\\text{avg}} = \\frac{1}{N} \\left( \\frac{1}{N} \\sum_{k=0}^{N-1} |Y[k]|^2 \\right) = \\frac{1}{N^2} \\sum_{k=0}^{N-1} |Y[k]|^2 $$\n问题要求功率谱密度 (PSD) 的积分（通过对周期图 $S[k]$ 的离散频率箱求和来近似）必须等于这个平均功率：\n$$ \\int \\text{PSD}(f) df \\approx \\sum_{k=0}^{N-1} S[k] \\Delta f = P_{\\text{avg}} $$\n频率箱宽度 $\\Delta f$ 是 DFT 中相邻频率分量之间的间距，由 $\\Delta f = F_s / N$ 给出，其中 $F_s$ 是以赫兹为单位的采样频率，N 是样本数。\n\n将 $\\Delta f$ 和 $P_{\\text{avg}}$ 的表达式代入所要求的等式中，得到：\n$$ \\sum_{k=0}^{N-1} S[k] \\left( \\frac{F_s}{N} \\right) = \\frac{1}{N^2} \\sum_{k=0}^{N-1} |Y[k]|^2 $$\n为使此等式成立，我们可以建立逐项关系，将周期图 $S[k]$ 定义为 DFT 系数平方模 $|Y[k]|^2$ 的函数。\n$$ S[k] \\frac{F_s}{N} = \\frac{1}{N^2} |Y[k]|^2 $$\n求解 $S[k]$ 得到归一化公式：\n$$ S[k] = \\frac{1}{N F_s} |Y[k]|^2 $$\n这个表达式定义了双边周期图。我们来验证一下单位。如果信号 $y[n]$ 的单位是 $\\mu\\mathrm{V}$，那么它的 DFT $Y[k]$（作为一个和）的单位也是 $\\mu\\mathrm{V}$。因此， $|Y[k]|^2$ 的单位是 $\\mu\\mathrm{V}^2$。$N$ 是无量纲的，$F_s$ 的单位是赫兹。所以，$S[k]$ 的单位是 $\\mu\\mathrm{V}^2/\\mathrm{Hz}$，即单位频率的功率，这符合 PSD 的要求。\n\n对于每个测试用例，数值实现将遵循以下步骤：\n1.  以采样频率 $F_s$ 生成长度为 $N$ 的时间序列 $x[n]$。\n2.  计算去均值序列 $y[n] = x[n] - \\bar{x}$。\n3.  计算时域平均功率（有限样本方差）$P_{\\text{avg}} = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]^2$。这可以高效地计算为 `np.mean(y**2)`。\n4.  使用 `numpy.fft.fft` 计算 $y[n]$ 的 DFT $Y[k]$，该函数与指定的 DFT 定义相匹配。\n5.  使用推导出的公式计算双边周期图 $S[k]$：$S[k] = \\frac{1}{N F_s} |Y[k]|^2$。\n6.  通过对周期图值求和并乘以频率箱宽度 $\\Delta f = F_s/N$ 来近似 PSD 积分。频域中的总功率为 $P_{\\text{freq}} = \\sum_{k=0}^{N-1} S[k] \\Delta f$。\n7.  通过计算绝对误差 $E_{\\text{abs}} = |P_{\\text{freq}} - P_{\\text{avg}}|$ 和相对误差 $E_{\\text{rel}} = E_{\\text{abs}} / \\max(P_{\\text{avg}}, \\epsilon)$ 来验证等式。如果 $\\max(E_{\\text{abs}}, E_{\\text{rel}})$ 低于 $10^{-10}$ 的容差，则测试通过。使用双精度浮点运算，这个直接的数学恒等式应能以非常高的精度成立，仅受限于机器精度。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and numerically verifies the normalization of a periodogram-based PSD.\n    The verification confirms that the integral of the PSD over frequency equals the\n    time-domain finite-sample variance of the signal, based on Parseval's theorem.\n    \"\"\"\n\n    test_cases_params = [\n        {'N': 1024, 'Fs': 1000.0, 'case_id': 1, 'info': 'Sinusoids'},\n        {'N': 1000, 'Fs': 800.0,  'case_id': 2, 'info': 'White noise'},\n        {'N': 4096, 'Fs': 2000.0, 'case_id': 3, 'info': 'Constant signal'},\n        {'N': 1501, 'Fs': 600.0,  'case_id': 4, 'info': 'Piecewise signal'},\n        {'N': 2048, 'Fs': 1000.0, 'case_id': 5, 'info': 'Mixed signal with noise'},\n    ]\n\n    results = []\n    \n    # Use a fixed random seed for reproducibility of noise-based signals.\n    rng = np.random.default_rng(seed=0)\n\n    for params in test_cases_params:\n        N = params['N']\n        Fs = params['Fs']\n        n = np.arange(N)\n        t = n / Fs\n\n        if params['case_id'] == 1:\n            x = 0.5 + 2.0 * np.sin(2 * np.pi * 50 * t) + 1.0 * np.sin(2 * np.pi * 120 * t + 0.3)\n        \n        elif params['case_id'] == 2:\n            x = rng.normal(loc=0.0, scale=0.8, size=N)\n        \n        elif params['case_id'] == 3:\n            x = np.full(N, 1.23)\n        \n        elif params['case_id'] == 4:\n            x = np.zeros(N, dtype=np.float64)\n            n1 = int(np.floor(N / 3))\n            n2 = int(np.floor(2 * N / 3))\n            x[n1:n2] = 3.0\n            ramp_indices = np.arange(n2, N)\n            x[ramp_indices] = 3.0 + 0.001 * (ramp_indices - n2)\n            \n        elif params['case_id'] == 5:\n            eta = rng.normal(loc=0.0, scale=1.0, size=N)\n            x = 1.5 * np.cos(np.pi * n) + \\\n                0.7 * np.sin(2 * np.pi * 70 * t + 0.1) + \\\n                0.4 * np.sin(2 * np.pi * 125.5 * t + 1.7) + \\\n                0.05 * eta\n\n        # Step 1: Mean-remove the signal to get y[n].\n        y = x - np.mean(x)\n\n        # Step 2: Calculate the finite-sample variance (time-domain average power).\n        # Variance = (1/N) * sum(y[n]^2)\n        time_domain_power = np.mean(y**2)\n\n        # Step 3: Compute the DFT of y[n].\n        # Y[k] = sum_{n=0}^{N-1} y[n] * exp(-j*2*pi*k*n/N)\n        Y = np.fft.fft(y)\n\n        # Step 4: Construct the two-sided periodogram S[k].\n        # From derivation: S[k] = (1 / (N * Fs)) * |Y[k]|^2\n        S = (1 / (N * Fs)) * np.abs(Y)**2\n        \n        # Step 5: Define the frequency bin width, delta_f.\n        delta_f = Fs / N\n\n        # Step 6: Calculate total power by integrating the PSD (sum * bin_width).\n        freq_domain_power = np.sum(S) * delta_f\n\n        # Step 7: Perform numerical verification.\n        epsilon = 1e-12\n        E_abs = np.abs(freq_domain_power - time_domain_power)\n        \n        # The denominator must not be zero.\n        denominator = np.maximum(time_domain_power, epsilon)\n        E_rel = E_abs / denominator\n\n        # Check if the maximum of the absolute and relative errors is within tolerance.\n        verification_passed = np.maximum(E_abs, E_rel)  1e-10\n        \n        results.append(verification_passed)\n\n    # Final print statement in the exact required format.\n    # Booleans are converted to lowercase strings 'true'/'false'.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个常见的误解是，通过零填充（zero-padding）可以提高谱估计的“分辨率”。本练习旨在澄清一个关键区别：由记录长度决定的基本频谱分辨率，与通过零填充获得的更精细的频率网格 。通过推导和计算这两个量，你将深刻理解为什么我们只能观察到被窗口函数“平滑”过的频谱，而零填充只是更密集地对这个平滑后的频谱进行采样。",
            "id": "4187294",
            "problem": "记录来自大鼠海马体的局部场电位，以使用周期图法估计功率谱密度（PSD）。采样的离散时间信号为 $x[n]$，其中 $n=0,1,\\dots,N-1$。在采样频率 $f_{s}=1000\\,\\mathrm{Hz}$ 下采集了 $N=4096$ 个样本。经典周期图法使用矩形窗（即，观测被时间限制在有限的记录长度内）。在通过快速傅里叶变换（FFT）计算离散傅里叶变换（DFT）之前，您需要考虑将记录补零至更长的长度 $L=65536$。\n\n从以下基本依据出发：\n- 观测值是无限长度的底层信号与时域中矩形窗的乘积，时域中的乘法对应于频域中的卷积。\n- 离散时间傅里叶变换在由变换长度和采样频率决定的离散网格上对连续谱进行采样。\n\n完成以下任务：\n1. 根据矩形窗频域包络的特性，推导出周期图的基本频率分辨率极限（以赫兹为单位），并将其表示为 $N$ 和 $f_{s}$ 的函数。您的推导应明确说明为什么该分辨率由记录长度决定，而不是由补零决定。\n2. 根据 DFT 频率采样的定义，推导出补零至 $L$ 个点后的表观频率网格间距（以赫兹为单位），并说明该网格间距如何依赖于 $L$ 和 $f_{s}$。\n\n然后，根据给定的 $N$、$f_{s}$ 和 $L$ 对这两个量进行数值计算，并以赫兹为单位提供最终的数值结果。将每个数值四舍五入到八位有效数字。将您的最终答案表示为一个双元素行向量，其中第一个元素是周期图的基本分辨率，第二个元素是补零后的表观网格间距。所有中间和最终频率均以 $\\mathrm{Hz}$（赫兹）表示。",
            "solution": "该问题要求推导和计算与基于周期图法的离散时间信号功率谱密度（PSD）估计相关的两个不同频率度量：基本频率分辨率和补零后的表观频率网格间距。\n\n首先，确立问题陈述的有效性。\n\n**步骤 1：提取已知条件**\n- 采样离散时间信号：$x[n]$\n- 原始记录中的样本数：$N=4096$\n- 采样频率：$f_{s}=1000\\,\\mathrm{Hz}$\n- 窗类型：矩形窗\n- 用于 DFT 计算的补零后长度：$L=65536$\n- 基本依据 1：观测值是无限长度的底层信号与时域中矩形窗的乘积，对应于频域中的卷积。\n- 基本依据 2：离散时间傅里叶变换在由变换长度和采样频率决定的离散网格上对连续谱进行采样。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题基于数字信号处理的基本原理，特别是傅里叶分析和谱估计。加窗、频谱泄漏、频率分辨率、补零和离散傅里叶变换（DFT）等概念都是标准的、科学上合理的。应用于局部场电位（LFP）数据是现实且在神经科学中常见的。\n- **适定性**：该问题提供了所有必需的参数（$N$、$f_s$、$L$）和明确的目标来推导和计算所需的两个量。解是唯一的且稳定的。\n- **客观性**：问题使用精确、无歧义的技术语言陈述。它不含主观或基于观点的断言。\n- 该问题未违反任何无效性标准。它不是不合理、不完整、不现实或不适定的。\n\n**结论与行动**\n该问题是有效的。将提供完整的解答。\n\n**第 1 部分：基本频率分辨率的推导**\n\n谱估计的基本频率分辨率是指其区分两个不同且频率相近的分量的能力。对于周期图法，此分辨率由观测窗的长度决定，而不是由用于计算频谱的 DFT 长度决定。\n\n问题陈述，观测到的有限长度信号（我们称之为 $x_w[n]$）是真实的、可能无限长的底层信号 $x_{true}[n]$ 与长度为 $N$ 的矩形窗 $w_R[n]$ 的乘积。\n$$x_w[n] = x_{true}[n] \\cdot w_R[n]$$\n其中矩形窗定义为：\n$$w_R[n] = \\begin{cases} 1  \\text{for } n = 0, 1, \\dots, N-1 \\\\ 0  \\text{otherwise} \\end{cases}$$\n时域中的乘法对应于频域中的循环卷积。加窗信号的离散时间傅里叶变换（DTFT）$X_w(e^{j\\omega})$ 表示离散时间信号的连续谱，它是真实信号频谱 $X_{true}(e^{j\\omega})$ 与窗频谱 $W_R(e^{j\\omega})$ 的卷积：\n$$X_w(e^{j\\omega}) = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X_{true}(e^{j\\theta}) W_R(e^{j(\\omega-\\theta)}) d\\theta$$\n这种卷积运算会用窗频谱 $W_R(e^{j\\omega})$ 的形状来“涂抹”真实频谱 $X_{true}(e^{j\\omega})$。$W_R(e^{j\\omega})$ 主瓣的宽度决定了这种涂抹的程度，从而设定了频率分辨率的极限。\n\n矩形窗 $w_R[n]$ 的 DTFT 由下式给出：\n$$W_R(e^{j\\omega}) = \\sum_{n=0}^{N-1} 1 \\cdot e^{-j\\omega n} = e^{-j\\omega\\frac{N-1}{2}} \\frac{\\sin(N\\omega/2)}{\\sin(\\omega/2)}$$\n该函数是狄利克雷核的一种形式。其幅值 $|W_R(e^{j\\omega})|$ 的主瓣中心位于 $\\omega=0$。分辨率通常根据该主瓣的宽度来定义。主瓣的第一个零点出现在分子 $\\sin(N\\omega/2)$ 等于零，而分母 $\\sin(\\omega/2)$ 不为零时。此条件在以下情况下满足：\n$$\\frac{N\\omega}{2} = k\\pi, \\quad \\text{for any non-zero integer } k$$\n主瓣两侧的第一个零点对应于 $k=\\pm 1$。因此，第一个零点的位置是：\n$$\\omega_{\\text{null}} = \\pm \\frac{2\\pi}{N} \\quad (\\text{radians per sample})$$\n频率分辨率 $\\Delta f_{res}$ 是区分两个频率分量所需的最小间隔。根据 Rayleigh 判据，如果一个分量谱响应的最大值与另一个分量谱响应的第一个最小值（零点）重合，则这两个分量刚好可分辨。这个间隔对应于从主瓣中心（$\\omega=0$）到第一个零点的距离，即每样本 $\\frac{2\\pi}{N}$ 弧度。\n\n为了将此分辨率从归一化角频率（弧度/样本）转换为物理频率（赫兹），我们使用关系式 $\\omega = 2\\pi f / f_s$，其中 $f$ 是物理频率，$f_s$ 是采样频率。\n设 $\\Delta \\omega_{res}$ 是以弧度/样本为单位的分辨率，$\\Delta f_{res}$ 是以赫兹为单位的分辨率。\n$$\\Delta \\omega_{res} = \\frac{2\\pi}{N}$$\n$$2\\pi \\frac{\\Delta f_{res}}{f_s} = \\frac{2\\pi}{N}$$\n求解 $\\Delta f_{res}$，我们得到基本频率分辨率：\n$$\\Delta f_{res} = \\frac{f_s}{N}$$\n该推导明确表明，分辨率仅取决于采样频率 $f_s$ 和原始记录长度 $N$。在进行 DFT 之前将信号补零至长度 $L  N$ 并不会改变原始时域窗的持续时间。因此，它不会改变窗变换 $W_R(e^{j\\omega})$ 的形状，也无法改善由其施加的基本分辨率限制。补零仅仅是对被涂抹的频谱 $X_w(e^{j\\omega})$ 进行了更密集的采样。\n\n**第 2 部分：表观频率网格间距的推导**\n\nDFT 计算的是 DTFT 在离散频率点上的样本。这些点的间距取决于变换序列的总长度，在本例中即为补零后的长度 $L$。\n\n信号 $x[n]$（假设长度为 $L$）的 $L$ 点 DFT 定义为：\n$$X[k] = \\sum_{n=0}^{L-1} x[n] e^{-j \\frac{2\\pi k n}{L}}, \\quad \\text{for } k = 0, 1, \\dots, L-1$$\n每个 DFT 频率仓索引 $k$ 对应一个特定的分析频率。DFT 在离散的归一化角频率上对连续谱 $X(e^{j\\omega})$ 进行采样：\n$$\\omega_k = \\frac{2\\pi k}{L} \\quad (\\text{radians per sample})$$\n为了找到与这些频率仓对应的物理频率 $f_k$（以赫兹为单位），我们再次使用关系式 $\\omega_k = 2\\pi f_k / f_s$：\n$$2\\pi \\frac{f_k}{f_s} = \\frac{2\\pi k}{L}$$\n这得出了第 $k$ 个频率仓的频率：\n$$f_k = k \\cdot \\frac{f_s}{L}$$\n表观频率网格间距 $\\Delta f_{grid}$ 是相邻 DFT 频率仓之间的频率差，例如频率仓 $k$ 和频率仓 $k+1$ 之间：\n$$\\Delta f_{grid} = f_{k+1} - f_k = (k+1)\\frac{f_s}{L} - k\\frac{f_s}{L}$$\n简化后可得：\n$$\\Delta f_{grid} = \\frac{f_s}{L}$$\n此结果表明，DFT 频率网格的间距由采样频率 $f_s$ 和总变换长度 $L$（包括补零）决定，与原始信号长度 $N$ 无关。\n\n**数值计算**\n\n给定的值为：\n- $N=4096$\n- $f_s=1000\\,\\mathrm{Hz}$\n- $L=65536$\n\n1.  **基本频率分辨率 ($\\Delta f_{res}$):**\n    $$\\Delta f_{res} = \\frac{f_s}{N} = \\frac{1000}{4096} = 0.244140625\\,\\mathrm{Hz}$$\n    四舍五入到八位有效数字，我们得到 $0.24414063\\,\\mathrm{Hz}$。\n\n2.  **表观频率网格间距 ($\\Delta f_{grid}$):**\n    $$\\Delta f_{grid} = \\frac{f_s}{L} = \\frac{1000}{65536} = 0.0152587890625\\,\\mathrm{Hz}$$\n    四舍五入到八位有效数字，我们得到 $0.015258789\\,\\mathrm{Hz}$。\n\n最终答案将以一个包含这两个数值的双元素行向量形式呈现。",
            "answer": "$$\\boxed{\\begin{pmatrix} 0.24414063  0.015258789 \\end{pmatrix}}$$"
        },
        {
            "introduction": "原始周期图的方差很高，在实践中通常使用韦尔奇（Welch）平均周期图法来获得更平滑、更可靠的谱估计。这个练习将带你进入一个真实的工程设计场景，你需要在相互制约的频谱分辨率和方差缩减之间做出权衡 。通过为给定的神经科学信号分析任务选择最佳的段长度、窗函数和重叠率，你将掌握设计稳健谱估计器的核心技能。",
            "id": "4187289",
            "problem": "给定一段局部场电位 (LFP) 记录，其持续时间为 $T_{\\text{total}} = 120$ 秒，采样率为 $f_s = 1000$ 赫兹，共产生 $L = T_{\\text{total}} \\cdot f_s$ 个样本。任务是通过 Welch 平均周期图法设计一个基于周期图的功率谱密度 (PSD) 估计器，以解析 beta 频段中紧密间隔的振荡峰值，同时满足指定的目标方差缩减要求。设计必须选择段长度 $N$（以样本为单位）、窗函数类型 $w[n]$ 和重叠分数 $p \\in [0,1)$，并定量地证明所选参数同时满足频谱分辨率和方差缩减的要求。\n\n使用以下基本原理：\n- 一个宽平稳离散时间过程 $x[n]$ 的功率谱密度 (PSD) $S_{xx}(f)$ 定义为其自协方差函数的傅里叶变换。\n- 周期图是通过计算一个有限长度段的离散傅里叶变换 (DFT) 的幅值平方得到的。Welch 方法通过对跨段的周期图进行平均来减小方差。\n- 对于长度为 $N$、采样频率为 $f_s$ 的段，其频谱分辨率受由窗函数决定的有效主瓣宽度的限制。对于矩形窗，Rayleigh 频率分辨率为 $\\Delta f_{\\text{rect}} = \\frac{f_s}{N}$。对于 Hann 窗和 Hamming 窗，主瓣宽度大约加倍，得到 $\\Delta f_{\\text{hann}} \\approx \\Delta f_{\\text{hamming}} \\approx \\frac{2 f_s}{N}$。\n- 使用段长度 $N$ 和跳跃大小 $H = \\lfloor N (1 - p) \\rfloor$ 从 $L$ 个样本中形成的段数 $K$ 为 $K = \\left\\lfloor \\frac{L - N}{H} \\right\\rfloor + 1$，前提是 $H \\ge 1$ 且 $L \\ge N$。\n- 在给定频率下，平均 PSD 估计器的方差相对于单个周期图而言，通过平均得到了减小。对于因重叠而产生的相关段估计，可以使用相关随机变量平均值的方差来近似有效平均次数 $K_{\\text{eff}}$：\n$$\nK_{\\text{eff}} \\approx \\frac{K}{1 + 2 \\rho},\n$$\n其中 $\\rho$ 是由重叠引起的相邻加窗段之间的归一化相关系数，近似为\n$$\n\\rho = \\frac{\\sum_{n=0}^{N-H-1} w[n]\\,w[n+H]}{\\sum_{n=0}^{N-1} w[n]^2}。\n$$\n- 目标归一化方差 $\\tau$ 通过不等式强制执行：\n$$\n\\frac{\\operatorname{Var}[\\hat{S}(f)]}{S(f)^2} \\lesssim \\frac{1}{K_{\\text{eff}}} \\le \\tau,\n$$\n等价于 $K_{\\text{eff}} \\ge \\frac{1}{\\tau}$。\n\n设计约束与选择：\n1. 考虑的窗函数为矩形窗、Hann 窗和 Hamming 窗。使用代码 $0$ 代表矩形窗，$1$ 代表 Hann 窗，$2$ 代表 Hamming 窗。\n2. 频谱分辨率要求是，所选窗函数和段长度的有效分辨率 $\\Delta f_{\\text{eff}}$ 必须满足\n$$\n\\Delta f_{\\text{eff}} \\le |f_2 - f_1|,\n$$\n其中 $f_1$ 和 $f_2$ 是测试案例中两个 beta 频段的峰值频率，单位为赫兹。\n3. 方差缩减要求是，有效平均次数必须满足\n$$\nK_{\\text{eff}} \\ge \\frac{1}{\\tau}。\n$$\n4. 可用的重叠分数限制在集合 $\\{0.0, 0.5, 0.75, 0.875\\}$ 中。跳跃大小为 $H = \\lfloor N(1-p)\\rfloor$，并强制 $H \\ge 1$。\n5. 窗函数选择策略：优先选择 Hann 窗以控制神经科学分析中典型的频谱泄漏。如果 Hann 窗在 $N \\le L$ 的条件下无法满足频谱分辨率约束，则优先选择 Hamming 窗；如果两者都无法满足约束，则优先选择矩形窗。\n\n算法要求：\n- 对于每个测试案例，计算满足所选窗函数分辨率约束的最小段长度 $N$（整数，单位为样本）。具体来说，对于矩形窗使用 $\\Delta f_{\\text{eff}} = \\frac{f_s}{N}$，对于 Hann 窗和 Hamming 窗使用 $\\Delta f_{\\text{eff}} = \\frac{2 f_s}{N}$。选择满足 $\\Delta f_{\\text{eff}} \\le |f_2-f_1|$ 且受 $N \\le L$ 约束的最小整数 $N$。\n- 使用选定的 $N$ 和窗函数，按升序遍历重叠分数，计算 $H$、$K$、$\\rho$ 和 $K_{\\text{eff}}$，并选择能够满足 $K_{\\text{eff}} \\ge \\frac{1}{\\tau}$ 的最小 $p$ 值。\n- 计算最终选择方案所达到的有效分辨率 $\\Delta f_{\\text{eff}}$，单位为赫兹。\n\n测试套件：\n- 案例 1 (理想情况)：$f_1 = 20.0$ 赫兹, $f_2 = 23.0$ 赫兹, $\\tau = 0.15$。\n- 案例 2 (更近的峰值)：$f_1 = 20.0$ 赫兹, $f_2 = 21.0$ 赫兹, $\\tau = 0.05$。\n- 案例 3 (严格的分辨率，强的方差缩减)：$f_1 = 13.0$ 赫兹, $f_2 = 13.5$ 赫兹, $\\tau = 0.02$。\n- 案例 4 (边界分辨率)：$f_1 = 25.0$ 赫兹, $f_2 = 27.0$ 赫兹, $\\tau = 0.10$。\n\n输出规范：\n- 对于每个测试案例，按以下顺序输出一个包含五个元素的列表：\n$[N, \\text{window\\_code}, p, K_{\\text{eff}}, \\Delta f_{\\text{eff}}]$, \n其中 $N$ 是一个整数（样本数），$\\text{window\\_code}$ 是一个整数（如指定），$p$ 是一个浮点数（重叠分数），$K_{\\text{eff}}$ 是一个浮点数，$\\Delta f_{\\text{eff}}$ 是一个以赫兹为单位的浮点数。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应一个测试案例的五项列表（例如，`[[...],[...],[...],[...]]`）。所有与频率相关的量必须以赫兹表示，所有与重叠相关的量必须以小数表示，而非百分比。",
            "solution": "用户提供了一个问题，要求使用 Welch 平均周期图法设计一个功率谱密度 (PSD) 估计器。任务是选择合适的参数——段长度 $N$、窗函数类型 $w[n]$ 和重叠分数 $p$——以在分析模拟的局部场电位 (LFP) 信号时，满足指定的频谱分辨率和方差缩减标准。\n\n### 步骤 1：提取已知条件\n-   **信号参数**：总持续时间 $T_{\\text{total}} = 120$ 秒，采样频率 $f_s = 1000$ 赫兹。\n-   **总样本数**：$L = T_{\\text{total}} \\cdot f_s = 120000$ 个样本。\n-   **设计变量**：段长度 $N$（样本数）、窗函数类型 $w[n]$、重叠分数 $p$。\n-   **频谱分辨率公式**：\n    -   矩形窗：$\\Delta f_{\\text{rect}} = \\frac{f_s}{N}$。\n    -   Hann/Hamming 窗：$\\Delta f_{\\text{hann}} \\approx \\Delta f_{\\text{hamming}} \\approx \\frac{2 f_s}{N}$。\n-   **分段公式**：\n    -   跳跃大小：$H = \\lfloor N (1 - p) \\rfloor$，约束为 $H \\ge 1$。\n    -   段数：$K = \\left\\lfloor \\frac{L - N}{H} \\right\\rfloor + 1$，约束为 $L \\ge N$。\n-   **方差缩减公式**：\n    -   有效平均次数：$K_{\\text{eff}} \\approx \\frac{K}{1 + 2 \\rho}$。\n    -   相邻段之间的相关性：$\\rho = \\frac{\\sum_{n=0}^{N-H-1} w[n]\\,w[n+H]}{\\sum_{n=0}^{N-1} w[n]^2}$。\n-   **设计约束**：\n    1.  **窗函数**：矩形窗（代码 $0$）、Hann 窗（代码 $1$）、Hamming 窗（代码 $2$）。\n    2.  **频谱分辨率要求**：$\\Delta f_{\\text{eff}} \\le |f_2 - f_1|$，其中 $f_1, f_2$ 是给定的峰值频率。\n    3.  **方差缩减要求**：$K_{\\text{eff}} \\ge \\frac{1}{\\tau}$，其中 $\\tau$ 是目标归一化方差。\n    4.  **可用重叠分数**：$p \\in \\{0.0, 0.5, 0.75, 0.875\\}$。\n    5.  **窗函数选择策略**：优先选择 Hann 窗。如果它在 $N \\le L$ 的条件下无法满足分辨率标准，则尝试 Hamming 窗。如果 Hamming 窗也失败，则尝试矩形窗。\n-   **算法要求**：\n    1.  为所选窗函数找到满足分辨率约束的最小整数段长度 $N$。\n    2.  使用此 $N$，从可用集合中找到满足方差缩减要求的最小重叠分数 $p$。\n    3.  报告最终参数：$[N, \\text{window\\_code}, p, K_{\\text{eff}}, \\Delta f_{\\text{eff}}]$。\n-   **测试套件**：\n    -   案例 1：$f_1 = 20.0$ 赫兹, $f_2 = 23.0$ 赫兹, $\\tau = 0.15$。\n    -   案例 2：$f_1 = 20.0$ 赫兹, $f_2 = 21.0$ 赫兹, $\\tau = 0.05$。\n    -   案例 3：$f_1 = 13.0$ 赫兹, $f_2 = 13.5$ 赫兹, $\\tau = 0.02$。\n    -   案例 4：$f_1 = 25.0$ 赫兹, $f_2 = 27.0$ 赫兹, $\\tau = 0.10$。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学基础**：该问题牢固地植根于数字信号处理的原理，特别是非参数谱估计。Welch 方法是一种典型技术。基于窗函数主瓣宽度的频谱分辨率公式、带重叠的段数计算，以及考虑段相关性的平均估计方差近似，都是文献（例如，Stoica  Moses 的《Spectral Analysis of Signals》；Oppenheim  Schafer 的《Discrete-Time Signal Processing》）中的标准内容。该问题在科学上和事实上都是合理的。\n-   **良置性**：该问题为选择参数定义了一个清晰的、确定性的程序。对于每个测试案例，约束和优化标准（最小化 $N$，然后最小化 $p$）导致一个唯一的解。问题设置是自洽且逻辑清晰的。\n-   **客观性**：语言技术性强且精确。所有要求都是定量和客观的。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。这是一个在信号处理领域中定义明确的工程设计问题，具有清晰、有科学依据的原则和约束。可以构建一个逐步的解决方案。\n\n### 基于原则的 PSD 估计器设计\n\n目标是解决谱估计中频谱分辨率和统计稳定性（方差）之间的基本权衡。\n\n**1. 频谱分辨率和段长度（$N$）的选择**\n区分两个紧密间隔的频率分量的能力被称为频谱分辨率。在傅里叶分析中，这由观测窗口的长度 $N$ 决定。更长的段（更大的 $N$）产生更精细的频率网格和更窄的窗函数频谱响应主瓣，从而提高分辨率。所提供的公式体现了这一点：\n-   $\\Delta f_{\\text{rect}} = \\frac{f_s}{N}$\n-   $\\Delta f_{\\text{hann/hamming}} \\approx \\frac{2 f_s}{N}$\n\n相比矩形窗，Hann 和 Hamming 等锥形窗（或称平滑窗）更受青睐，因为它们的频谱泄漏显著更低（即旁瓣更小），这可以防止弱的频谱分量被附近强的分量所掩盖。然而，这一好处的代价是主瓣更宽，宽度大约增加一倍，从而降低了给定 $N$ 下的分辨率。\n\n设计算法首先解决分辨率约束，$\\Delta f_{\\text{eff}} \\le |f_2 - f_1|$。我们重排分辨率公式以找到所需的最小段长度 $N_{\\text{min}}$。\n\n根据指定的策略，我们首先尝试使用 Hann 窗。最小段长度为：\n$$\nN_{\\text{hann}} = \\left\\lceil \\frac{2 f_s}{|f_2 - f_1|} \\right\\rceil\n$$\n如果这个 $N_{\\text{hann}}$ 是可行的（即 $N_{\\text{hann}} \\le L$），我们选择 Hann 窗，并设 $N = N_{\\text{hann}}$。如果不可行，我们对 Hamming 窗（其分辨率公式相同，因此 $N$ 也相同）重复此过程，然后是矩形窗，其最小段长度为：\n$$\nN_{\\text{rect}} = \\left\\lceil \\frac{f_s}{|f_2 - f_1|} \\right\\rceil\n$$\n在优先级列表（Hann $\\rightarrow$ Hamming $\\rightarrow$ 矩形窗）中，第一个能产生可行 $N$ 的窗函数将被选中。\n\n**2. 方差缩减和重叠分数（$p$）的选择**\n单个段的原始周期图是真实 PSD 的一个高方差估计。Welch 方法通过对多个段的周期图进行平均来缓解这个问题。对于总长度为 $L$ 的信号和长度为 $N$ 的段，可用段数 $K$ 随着跳跃大小 $H$ 的减小而增加。跳跃大小由重叠分数 $p$ 决定：$H = \\lfloor N(1-p) \\rfloor$。更大的重叠（更大的 $p$）产生更小的 $H$，从而产生更大的 $K$。\n\n然而，重叠的段是相关的，这意味着每个额外的段提供的新信息会递减。因此，方差缩减与 $K$ 不成正比，而是与一个考虑了这种相关性的有效平均次数 $K_{\\text{eff}}$ 成正比：\n$$\nK_{\\text{eff}} \\approx \\frac{K}{1 + 2 \\rho}\n$$\n相关性 $\\rho$ 取决于窗函数的形状和重叠的程度。设计要求 $K_{\\text{eff}}$ 达到或超过由指定归一化方差 $\\tau$ 确定的目标值：\n$$\nK_{\\text{eff}} \\ge \\frac{1}{\\tau}\n$$\n在从分辨率步骤确定了 $N$ 和窗函数类型后，我们现在按升序遍历允许的重叠分数 $p \\in \\{0.0, 0.5, 0.75, 0.875\\}$。对于每个 $p$，我们计算 $H$、$K$、$\\rho$，最后计算 $K_{\\text{eff}}$。第一个满足方差缩减不等式的 $p$ 值被选中。这种选择在满足统计稳定性要求的同时，最小化了与更高重叠相关的计算成本。\n\n**3. 最终参数化**\n一旦确定了三元组（$N$，窗函数，$p$），就计算实际达到的有效分辨率 $\\Delta f_{\\text{eff}}$ 和有效平均次数 $K_{\\text{eff}}$，并与所选参数一起报告。这便完成了一个给定测试案例的设计。这个结构化的、两步走的优化过程确保了两个设计约束都以系统且合理的方式得到满足。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs a Welch's PSD estimator by selecting segment length, window type,\n    and overlap fraction to meet specified spectral resolution and variance\n    reduction constraints.\n    \"\"\"\n    # Global parameters from the problem statement\n    T_total = 120.0\n    fs = 1000.0\n    L = int(T_total * fs)  # Total number of samples\n\n    # Available design choices\n    overlap_fractions = [0.0, 0.5, 0.75, 0.875]\n    window_specs = {\n        'hann': {'code': 1, 'C': 2.0, 'func': np.hanning},\n        'hamming': {'code': 2, 'C': 2.0, 'func': np.hamming},\n        'rectangular': {'code': 0, 'C': 1.0, 'func': np.ones}\n    }\n    window_selection_order = ['hann', 'hamming', 'rectangular']\n\n    # Test suite from the problem statement\n    test_cases = [\n        (20.0, 23.0, 0.15),  # Case 1\n        (20.0, 21.0, 0.05),  # Case 2\n        (13.0, 13.5, 0.02),  # Case 3\n        (25.0, 27.0, 0.10),  # Case 4\n    ]\n\n    all_results = []\n    for case in test_cases:\n        f1, f2, tau = case\n        df_target = abs(f2 - f1)\n        k_eff_target = 1.0 / tau\n\n        # --- Step 1: Select Window and Segment Length N ---\n        chosen_window_name = None\n        N = -1\n\n        for window_name in window_selection_order:\n            C = window_specs[window_name]['C']\n            # Calculate minimum N to satisfy the resolution constraint\n            N_candidate = int(np.ceil(C * fs / df_target))\n            \n            if N_candidate = L:\n                chosen_window_name = window_name\n                N = N_candidate\n                break\n        \n        # This case should not be reached with the given test suite\n        if chosen_window_name is None:\n            raise ValueError(\"No window can satisfy resolution constraints.\")\n\n        # --- Step 2: Select Overlap Fraction p ---\n        chosen_p = -1.0\n        final_k_eff = -1.0\n        \n        # Generate the chosen window function of length N\n        window_func = window_specs[chosen_window_name]['func']\n        w = window_func(N)\n        denom_rho = np.sum(w**2)\n\n        for p in overlap_fractions:\n            # Calculate hop size, must be at least 1\n            H = int(np.floor(N * (1.0 - p)))\n            if H  1:\n                continue\n\n            # Calculate the number of segments\n            K = int(np.floor((L - N) / H)) + 1\n            \n            # Calculate correlation coefficient rho\n            if p == 0.0 or H >= N: # Non-overlapping\n                rho = 0.0\n            else:\n                # Summation: sum_{n=0}^{N-H-1} w[n] w[n+H]\n                # This corresponds to dot product of two slices of the window\n                num_rho = np.sum(w[0 : N - H] * w[H : N])\n                rho = num_rho / denom_rho\n\n            # Calculate effective number of averages\n            k_eff = K / (1.0 + 2.0 * rho)\n\n            # Check if variance reduction target is met\n            if k_eff >= k_eff_target:\n                chosen_p = p\n                final_k_eff = k_eff\n                break\n        \n        # This case should not be reached with the given test suite\n        if chosen_p  0.0:\n            raise ValueError(f\"Could not meet variance target K_eff > {k_eff_target} for N={N}.\")\n\n        # --- Step 3: Calculate Final Parameters ---\n        window_code = window_specs[chosen_window_name]['code']\n        C_final = window_specs[chosen_window_name]['C']\n        delta_f_eff = C_final * fs / N\n        \n        result = [N, window_code, chosen_p, final_k_eff, delta_f_eff]\n        all_results.append(result)\n\n    # Format the final output as a single-line string representation of a list of lists.\n    # e.g., [[val1, val2, ...], [val1, val2, ...]]\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```"
        }
    ]
}