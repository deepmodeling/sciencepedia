{
    "hands_on_practices": [
        {
            "introduction": "第一个实践是神经科学数据贝叶斯推断的一项基础练习。通过推导神经元发放率 $\\lambda$ 的后验分布 ()，您将亲身体验贝叶斯定理如何将先验知识与观测到的脉冲计数相结合。这项练习将巩固泊松 (Poisson) 似然函数与其共轭伽马 (Gamma) 先验之间的数学关系，这是脉冲序列分析的基石。",
            "id": "4140543",
            "problem": "在一个稳定的行为时期，对一个单个孤立的神经元进行细胞外记录，持续时间为 $\\,\\tau>0\\,$ 秒。设 $\\,K\\,$ 表示在此时间窗口内观测到的脉冲计数，其模型是在给定未知放电率 $\\,\\lambda>0\\,$（单位：脉冲/秒）的条件下服从条件泊松分布，即 $\\,K \\mid \\lambda \\sim \\mathrm{Poisson}(\\lambda \\tau)\\,$。为了捕捉基于先前实验的关于 $\\,\\lambda\\,$ 的先验不确定性，假设一个形状参数为 $\\,a>0\\,$、速率参数为 $\\,b>0\\,$ 的 Gamma 先验，其先验密度为 $\\,p(\\lambda) = \\frac{b^{a}}{\\Gamma(a)} \\lambda^{a-1} \\exp(-b \\lambda)\\,$（对于 $\\,\\lambda>0\\,$）。使用贝叶斯定理和条件概率的核心定义，推导后验密度 $\\,p(\\lambda \\mid K=k)\\,$，它是一个关于 $\\,\\lambda\\,$ 的归一化函数，其中观测值 $\\,k \\in \\{0,1,2,\\dots\\}\\,$ 和 $\\,\\tau,a,b>0\\,$ 为固定值。通过在 $\\,\\lambda \\in (0,\\infty)\\,$ 上积分来显式计算归一化常数，并验证后验积分结果为 $\\,1\\,$。将你的最终结果表示为关于 $\\,a,b,\\tau,k,\\lambda\\,$ 的单个闭式解析表达式 $\\,p(\\lambda \\mid K=k)\\,$。不需要数值近似，也不需要四舍五入。陈述答案时请不要带单位。",
            "solution": "目标是推导放电率 $\\lambda$ 的后验密度 $p(\\lambda \\mid K=k)$。根据贝叶斯定理，后验密度与给定参数的数据似然和参数的先验密度的乘积成正比。\n$$p(\\lambda \\mid K=k) = \\frac{p(K=k \\mid \\lambda) p(\\lambda)}{\\int_{0}^{\\infty} p(K=k \\mid \\lambda) p(\\lambda) d\\lambda}$$\n\n首先，我们确定分子的两个组成部分：似然 $p(K=k \\mid \\lambda)$ 和先验 $p(\\lambda)$。\n\n似然由泊松分布给出。问题陈述，在持续时间为 $\\tau$ 的时间窗口内的脉冲计数 $K$ 被建模为 $K \\mid \\lambda \\sim \\mathrm{Poisson}(\\lambda \\tau)$。对于一个观测到的计数 $K=k$，其中 $k \\in \\{0, 1, 2, \\dots\\}$，其概率质量函数，当视为固定 $k$ 时关于 $\\lambda$ 的函数，即为似然函数 $L(\\lambda; k)$：\n$$L(\\lambda; k) = p(K=k \\mid \\lambda) = \\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau)}{k!}$$\n此式对 $\\lambda > 0$ 有效。\n\n放电率 $\\lambda$ 的先验分布被给定为一个形状参数为 $a>0$ 且速率参数为 $b>0$ 的 Gamma 分布。其概率密度函数为：\n$$p(\\lambda) = \\frac{b^a}{\\Gamma(a)} \\lambda^{a-1} \\exp(-b\\lambda)$$\n此式对 $\\lambda > 0$ 有效。\n\n接下来，我们通过将似然与先验相乘来构建未归一化的后验密度：\n$$p(\\lambda \\mid K=k) \\propto p(K=k \\mid \\lambda) p(\\lambda)$$\n$$p(\\lambda \\mid K=k) \\propto \\left( \\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau)}{k!} \\right) \\left( \\frac{b^a}{\\Gamma(a)} \\lambda^{a-1} \\exp(-b\\lambda) \\right)$$\n我们可以将依赖于 $\\lambda$ 的项和相对于 $\\lambda$ 为常数的项分组。项 $1/k!$、$\\tau^k$、 $b^a$ 和 $1/\\Gamma(a)$ 都是相对于 $\\lambda$ 的常数，可以被吸收到比例常数中。\n$$p(\\lambda \\mid K=k) \\propto (\\lambda^k \\exp(-\\lambda\\tau)) (\\lambda^{a-1} \\exp(-b\\lambda))$$\n合并含 $\\lambda$ 的项：\n$$p(\\lambda \\mid K=k) \\propto \\lambda^{k+a-1} \\exp(-\\lambda\\tau - b\\lambda)$$\n$$p(\\lambda \\mid K=k) \\propto \\lambda^{(a+k)-1} \\exp(-(b+\\tau)\\lambda)$$\n这个表达式是 $\\lambda$ 的一个概率分布的核。我们识别出这是 Gamma 分布的核，形式为 $\\lambda^{\\text{shape}-1} \\exp(-\\text{rate} \\cdot \\lambda)$。通过比较各项，我们可以确定后验分布的参数。后验分布是一个 Gamma 分布，其更新后的形状参数为 $a' = a+k$，更新后的速率参数为 $b' = b+\\tau$。\n\n设该后验为 $\\mathrm{Gamma}(a', b')$。Gamma 分布的归一化概率密度函数由 $p(x) = \\frac{\\beta^\\alpha}{\\Gamma(\\alpha)} x^{\\alpha-1} \\exp(-\\beta x)$ 给出。代入我们的后验参数 $a'$ 和 $b'$，我们得到 $\\lambda$ 的归一化后验密度：\n$$p(\\lambda \\mid K=k) = \\frac{(b+\\tau)^{a+k}}{\\Gamma(a+k)} \\lambda^{a+k-1} \\exp(-(b+\\tau)\\lambda)$$\n\n问题要求我们显式计算归一化常数。归一化常数是未归一化后验在 $\\lambda$ 的定义域 $(0, \\infty)$ 上的积分。设此常数为 $C$。\n$$C = \\int_{0}^{\\infty} p(K=k \\mid \\lambda) p(\\lambda) d\\lambda$$\n$$C = \\int_{0}^{\\infty} \\left( \\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau)}{k!} \\right) \\left( \\frac{b^a}{\\Gamma(a)} \\lambda^{a-1} \\exp(-b\\lambda) \\right) d\\lambda$$\n我们可以提出所有不含 $\\lambda$ 的因子：\n$$C = \\frac{\\tau^k b^a}{k! \\Gamma(a)} \\int_{0}^{\\infty} \\lambda^k \\exp(-\\lambda\\tau) \\lambda^{a-1} \\exp(-b\\lambda) d\\lambda$$\n合并积分内的项：\n$$C = \\frac{\\tau^k b^a}{k! \\Gamma(a)} \\int_{0}^{\\infty} \\lambda^{a+k-1} \\exp(-(b+\\tau)\\lambda) d\\lambda$$\n该积分是 Gamma 函数的形式。积分部分可以使用 Gamma 函数的定义 $\\Gamma(z) = \\int_0^\\infty t^{z-1} e^{-t} dt$ 来求解。我们可以使用换元法，令 $u = (b+\\tau)\\lambda$，这意味着 $d\\lambda = du/(b+\\tau)$ 和 $\\lambda = u/(b+\\tau)$。\n$$\\int_{0}^{\\infty} \\lambda^{a+k-1} \\exp(-(b+\\tau)\\lambda) d\\lambda = \\int_{0}^{\\infty} \\left(\\frac{u}{b+\\tau}\\right)^{a+k-1} \\exp(-u) \\frac{du}{b+\\tau}$$\n$$= \\frac{1}{(b+\\tau)^{a+k}} \\int_{0}^{\\infty} u^{a+k-1} \\exp(-u) du = \\frac{\\Gamma(a+k)}{(b+\\tau)^{a+k}}$$\n将此结果代回 $C$ 的表达式中：\n$$C = \\frac{\\tau^k b^a}{k! \\Gamma(a)} \\frac{\\Gamma(a+k)}{(b+\\tau)^{a+k}}$$\n这个常数 $C$ 是边缘似然 $p(K=k)$。那么后验密度是 $p(\\lambda \\mid K=k) = \\frac{p(K=k \\mid \\lambda)p(\\lambda)}{C}$。\n$$p(\\lambda \\mid K=k) = \\frac{\\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau)}{k!} \\frac{b^a}{\\Gamma(a)} \\lambda^{a-1} \\exp(-b\\lambda)}{\\frac{\\tau^k b^a \\Gamma(a+k)}{k! \\Gamma(a) (b+\\tau)^{a+k}}} = \\frac{(\\lambda\\tau)^k \\exp(-\\lambda\\tau) b^a \\lambda^{a-1} \\exp(-b\\lambda) k! \\Gamma(a) (b+\\tau)^{a+k}}{k! \\Gamma(a) \\tau^k b^a \\Gamma(a+k)}$$\n$$p(\\lambda \\mid K=k) = \\frac{\\lambda^{a+k-1} \\exp(-\\lambda(b+\\tau)) (b+\\tau)^{a+k}}{\\Gamma(a+k)}$$\n这与通过识别后验核推导出的表达式相匹配。\n\n最后，我们验证该后验密度积分为 $1$。\n$$\\int_{0}^{\\infty} p(\\lambda \\mid K=k) d\\lambda = \\int_{0}^{\\infty} \\frac{(b+\\tau)^{a+k}}{\\Gamma(a+k)} \\lambda^{a+k-1} \\exp(-(b+\\tau)\\lambda) d\\lambda$$\n$$= \\frac{(b+\\tau)^{a+k}}{\\Gamma(a+k)} \\int_{0}^{\\infty} \\lambda^{a+k-1} \\exp(-(b+\\tau)\\lambda) d\\lambda$$\n使用我们之前的积分计算结果：\n$$= \\frac{(b+\\tau)^{a+k}}{\\Gamma(a+k)} \\left( \\frac{\\Gamma(a+k)}{(b+\\tau)^{a+k}} \\right) = 1$$\n验证成功。该后验是一个有效的概率密度。\n\n因此，后验密度 $p(\\lambda \\mid K=k)$ 的最终闭式解析表达式是形状为 $a+k$、速率为 $b+\\tau$ 的 Gamma 分布的概率密度函数。",
            "answer": "$$\\boxed{\\frac{(b+\\tau)^{a+k}}{\\Gamma(a+k)} \\lambda^{a+k-1} \\exp\\left(-(b+\\tau)\\lambda\\right)}$$"
        },
        {
            "introduction": "真实的神经科学实验通常会随时间顺序产生数据流。本实践 () 在前一练习的基础上，将我们的分析方法调整为“在线”模式，即每当有新的观测数据时，知识便会进行递归更新。您不仅将实现这种高效的更新方案，还将学习如何计算后验预测分布，从而能够基于模型预测未来的神经活动。",
            "id": "4140604",
            "problem": "您正在分析在具有可变时长的离散时间区间内记录的单个神经元的脉冲序列数据。在每个区间中，您观察到一个非负整数的脉冲计数。科学模型如下：给定一个以赫兹 (Hz) 为单位的恒定放电率参数 $\\lambda$，各个区间的脉冲计数在给定 $\\lambda$ 的条件下是条件独立的，并且每个区间 $t$ 的计数 $k_t$ 服从泊松分布，其均值为 $\\lambda d_t$，其中 $d_t$ 是区间 $t$ 的时长，单位为秒。截至区间 $t$ 的完整数据表示为 $D_{1:t} = \\{(k_1,d_1),\\ldots,(k_t,d_t)\\}$。放电率 $\\lambda$ 的先验分布是伽马分布，由形状参数 $\\alpha_0$ 和率参数 $\\beta_0$ 参数化，其密度与 $\\lambda^{\\alpha_0 - 1} \\exp(-\\beta_0 \\lambda)$ 成正比。所有变量和数字都应在其所述的数学定义内进行解释。\n\n从条件概率的定义和应用于观测序列的贝叶斯定理出发，并基于给定 $\\lambda$ 的区间条件独立性假设，推导在线形式的递归后验更新，其中时间 $t$ 的后验可以从时间 $t-1$ 的后验和新的观测值 $(k_t,d_t)$ 更新得到，而无需重新访问过去的数据。仅使用条件概率、贝叶斯定理、泊松分布和伽马分布的定义和性质；不要调用任何关于后验或预测分布的预先推导出的公式。然后，推导一步后验预测概率，即下一个时长为 $d_{\\text{next}}$ 秒的区间将包含至少一个脉冲的概率，表示为小数（而非百分比）。\n\n实现一个算法，该算法：\n- 使用伽马先验参数 $\\alpha_0$ 和 $\\beta_0$ 初始化后验。\n- 在线处理序列 $D_{1:t}$（一次一个区间），对泊松观测值应用递归后验更新。\n- 处理完所有 $t$ 个区间后，计算后验平均放电率 $m_t = \\mathbb{E}[\\lambda \\mid D_{1:t}]$，单位为每秒脉冲数 (Hz)。\n- 计算后验预测概率 $q_t$，即下一个时长为 $d_{\\text{next}}$ 秒的区间包含至少一个脉冲的概率。\n\n将 $m_t$ 以赫兹 (Hz) 为单位表示。将 $q_t$ 表示为 $[0,1]$ 范围内的小数。在最终输出中，$m_t$ 和 $q_t$ 都必须四舍五入到六位小数。\n\n测试套件：\n- 案例 1 (一般情况)：先验 $(\\alpha_0,\\beta_0) = (2.0, 1.0)$，数据 $k$ 序列 $[0, 1, 0, 2]$，时长 $[0.2, 0.2, 0.2, 0.4]$ 秒，下一时长 $d_{\\text{next}} = 0.5$ 秒。\n- 案例 2 (边界情况：无数据)：先验 $(\\alpha_0,\\beta_0) = (1.5, 0.5)$，数据 $k$ 序列 $[]$，时长 $[]$，下一时长 $d_{\\text{next}} = 0.1$ 秒。\n- 案例 3 (边缘情况：大量零值)：先验 $(\\alpha_0,\\beta_0) = (5.0, 2.0)$，数据 $k$ 序列 $[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$，时长 $[0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$ 秒，下一时长 $d_{\\text{next}} = 1.0$ 秒。\n- 案例 4 (高计数和不同时长)：先验 $(\\alpha_0,\\beta_0) = (0.5, 0.1)$，数据 $k$ 序列 $[5, 7, 3, 4, 6]$，时长 $[1.0, 1.0, 0.5, 0.5, 2.0]$ 秒，下一时长 $d_{\\text{next}} = 0.5$ 秒。\n- 案例 5 (强先验，稀疏数据)：先验 $(\\alpha_0,\\beta_0) = (20.0, 10.0)$，数据 $k$ 序列 $[0, 0, 1, 0, 0]$，时长 $[0.1, 0.1, 0.1, 0.1, 0.1]$ 秒，下一时长 $d_{\\text{next}} = 0.2$ 秒。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内是双元素列表，并用方括号括起来，顺序与测试套件相同，其中每个内部列表为 $[m_t,q_t]$。例如，输出格式必须类似于 $[[m_1,q_1],[m_2,q_2],\\ldots]$，所有浮点数都四舍五入到六位小数。",
            "solution": "该问题要求推导神经放电率 $\\lambda$ 的后验分布参数的递归贝叶斯更新方案，并随后推导后验预测概率。\n\n设放电率 $\\lambda$ 的先验分布为伽马分布，记为 $\\text{Gamma}(\\lambda; \\alpha_0, \\beta_0)$。其概率密度函数 (PDF) 为：\n$$p(\\lambda) = \\frac{\\beta_0^{\\alpha_0}}{\\Gamma(\\alpha_0)} \\lambda^{\\alpha_0 - 1} e^{-\\beta_0 \\lambda}$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n在时长为 $d_t$ 的区间中观测到 $k_t$ 个脉冲的似然由泊松分布给出：\n$$P(k_t | \\lambda, d_t) = \\frac{(\\lambda d_t)^{k_t} e^{-\\lambda d_t}}{k_t!}$$\n\n#### 递归后验更新\n\n我们的目标是找到在观测到截至时间 $t$ 的数据 $D_{1:t} = \\{(k_1, d_1), \\dots, (k_t, d_t)\\}$ 后 $\\lambda$ 的后验分布。我们将推导递归形式，使用新的观测值 $(k_t, d_t)$ 将时间 $t-1$ 的后验更新为时间 $t$ 的后验。\n\n设观测到 $D_{1:t-1}$ 后的后验分布为 $p(\\lambda | D_{1:t-1})$。根据贝叶斯定理，观测到 $D_{1:t}$ 后的后验为：\n$$p(\\lambda | D_{1:t}) = p(\\lambda | D_{1:t-1}, (k_t, d_t)) \\propto p((k_t, d_t) | \\lambda, D_{1:t-1}) p(\\lambda | D_{1:t-1})$$\n问题陈述中指出，给定 $\\lambda$，观测值是条件独立的。因此，新观测值 $(k_t, d_t)$ 的似然仅取决于 $\\lambda$，而不取决于过去的数据 $D_{1:t-1}$。\n$$p((k_t, d_t) | \\lambda, D_{1:t-1}) = P(k_t | \\lambda, d_t)$$\n后验的表达式变为：\n$$p(\\lambda | D_{1:t}) \\propto P(k_t | \\lambda, d_t) p(\\lambda | D_{1:t-1})$$\n这个递归关系构成了在线更新的基础。我们假设时间 $t-1$ 的后验是伽马分布，$p(\\lambda | D_{1:t-1}) = \\text{Gamma}(\\lambda; \\alpha_{t-1}, \\beta_{t-1})$。基准情况是 $t=0$（没有任何数据之前），此时后验即为先验，因此 $(\\alpha_0, \\beta_0)$ 是初始参数。\n$$p(\\lambda | D_{1:t-1}) \\propto \\lambda^{\\alpha_{t-1} - 1} e^{-\\beta_{t-1} \\lambda}$$\n将似然和先验代入递归公式：\n$$p(\\lambda | D_{1:t}) \\propto \\left( \\frac{(\\lambda d_t)^{k_t} e^{-\\lambda d_t}}{k_t!} \\right) \\left( \\lambda^{\\alpha_{t-1} - 1} e^{-\\beta_{t-1} \\lambda} \\right)$$\n我们可以对项进行分组，并舍去不依赖于 $\\lambda$ 的常数（即 $d_t^{k_t}$ 和 $k_t!$）：\n$$p(\\lambda | D_{1:t}) \\propto \\left( \\lambda^{k_t} e^{-\\lambda d_t} \\right) \\left( \\lambda^{\\alpha_{t-1} - 1} e^{-\\beta_{t-1} \\lambda} \\right)$$\n$$p(\\lambda | D_{1:t}) \\propto \\lambda^{k_t + \\alpha_{t-1} - 1} e^{-(\\beta_{t-1} + d_t)\\lambda}$$\n这个表达式是伽马分布的核。因此，后验 $p(\\lambda | D_{1:t})$ 也是一个伽马分布，我们将其表示为 $\\text{Gamma}(\\lambda; \\alpha_t, \\beta_t)$，其更新后的参数为：\n$$\\alpha_t = \\alpha_{t-1} + k_t$$\n$$\\beta_t = \\beta_{t-1} + d_t$$\n这证实了伽马分布是泊松似然的共轭先验，并提供了所需的递归更新规则。从 $(\\alpha_0, \\beta_0)$ 开始，在处理所有 $t$ 个观测值后，最终的后验参数为 $\\alpha_t = \\alpha_0 + \\sum_{i=1}^t k_i$ 和 $\\beta_t = \\beta_0 + \\sum_{i=1}^t d_i$。\n\n#### 后验平均放电率 ($m_t$)\n\n伽马分布 $\\text{Gamma}(x; \\alpha, \\beta)$ 的均值为 $\\mathbb{E}[x] = \\alpha/\\beta$。因此，观测到 $D_{1:t}$ 后的后验平均放电率为：\n$$m_t = \\mathbb{E}[\\lambda | D_{1:t}] = \\frac{\\alpha_t}{\\beta_t} = \\frac{\\alpha_0 + \\sum_{i=1}^t k_i}{\\beta_0 + \\sum_{i=1}^t d_i}$$\n\n#### 后验预测概率 ($q_t$)\n\n我们需要计算在给定数据 $D_{1:t}$ 的情况下，在未来一个时长为 $d_{\\text{next}}$ 的时间区间内观测到至少一个脉冲的概率。这表示为 $q_t = P(k_{\\text{next}} \\geq 1 | D_{1:t}, d_{\\text{next}})$。将其计算为 $1 - P(k_{\\text{next}} = 0 | D_{1:t}, d_{\\text{next}})$ 会更容易。\n\n新观测值 $k_{\\text{next}}$ 的后验预测概率是通过将新数据点的似然函数在参数 $\\lambda$ 的后验分布上进行边缘化得到的：\n$$P(k_{\\text{next}} | D_{1:t}, d_{\\text{next}}) = \\int_{0}^{\\infty} P(k_{\\text{next}} | \\lambda, d_{\\text{next}}) p(\\lambda | D_{1:t}) d\\lambda$$\n这里，$P(k_{\\text{next}} | \\lambda, d_{\\text{next}})$ 是泊松似然，$p(\\lambda | D_{1:t})$ 是伽马后验 $\\text{Gamma}(\\lambda; \\alpha_t, \\beta_t)$。\n代入各自的概率密度函数表达式：\n$$P(k_{\\text{next}}=k | D_{1:t}, d_{\\text{next}}) = \\int_{0}^{\\infty} \\left( \\frac{(\\lambda d_{\\text{next}})^k e^{-\\lambda d_{\\text{next}}}{k!} \\right) \\left( \\frac{\\beta_t^{\\alpha_t}}{\\Gamma(\\alpha_t)} \\lambda^{\\alpha_t - 1} e^{-\\beta_t \\lambda} \\right) d\\lambda$$\n$$= \\frac{d_{\\text{next}}^k \\beta_t^{\\alpha_t}}{k! \\Gamma(\\alpha_t)} \\int_{0}^{\\infty} \\lambda^{k+\\alpha_t-1} e^{-(\\beta_t + d_{\\text{next}})\\lambda} d\\lambda$$\n该积分是伽马概率密度函数的未归一化核。使用恒等式 $\\int_0^\\infty x^{z-1} e^{-ax} dx = \\frac{\\Gamma(z)}{a^z}$，其中 $z = k+\\alpha_t$ 且 $a = \\beta_t + d_{\\text{next}}$，积分结果为 $\\frac{\\Gamma(k+\\alpha_t)}{(\\beta_t + d_{\\text{next}})^{k+\\alpha_t}}$。\n将此结果代回，我们得到后验预测分布的概率质量函数，这是一个负二项分布：\n$$P(k_{\\text{next}}=k | \\dots) = \\frac{\\Gamma(k+\\alpha_t)}{k! \\Gamma(\\alpha_t)} \\left( \\frac{\\beta_t}{\\beta_t + d_{\\text{next}}} \\right)^{\\alpha_t} \\left( \\frac{d_{\\text{next}}}{\\beta_t + d_{\\text{next}}} \\right)^k$$\n为了找到 $q_t$，我们首先通过在上述公式中设置 $k=0$ 来计算 $P(k_{\\text{next}}=0 | \\dots)$：\n$$P(k_{\\text{next}}=0 | \\dots) = \\frac{\\Gamma(\\alpha_t)}{0! \\Gamma(\\alpha_t)} \\left( \\frac{\\beta_t}{\\beta_t + d_{\\text{next}}} \\right)^{\\alpha_t} \\left( \\frac{d_{\\text{next}}}{\\beta_t + d_{\\text{next}}} \\right)^0$$\n由于 $0! = 1$ 且任何数的0次幂都为1：\n$$P(k_{\\text{next}}=0 | \\dots) = \\left( \\frac{\\beta_t}{\\beta_t + d_{\\text{next}}} \\right)^{\\alpha_t}$$\n最后，观测到至少一个脉冲的概率为：\n$$q_t = P(k_{\\text{next}} \\geq 1 | \\dots) = 1 - P(k_{\\text{next}}=0 | \\dots) = 1 - \\left( \\frac{\\beta_t}{\\beta_t + d_{\\text{next}}} \\right)^{\\alpha_t}$$\n\n### 算法实现\n\n对于每个测试案例，算法按以下步骤进行：\n1.  用先验参数初始化后验参数：$\\alpha \\leftarrow \\alpha_0$, $\\beta \\leftarrow \\beta_0$。\n2.  遍历观测数据对 $(k_i, d_i)$，$i=1, \\dots, t$。在每次迭代中，使用推导出的递归规则更新参数：\n    -   $\\alpha \\leftarrow \\alpha + k_i$\n    -   $\\beta \\leftarrow \\beta + d_i$\n3.  处理完所有数据后，最终参数为 $\\alpha_t$ 和 $\\beta_t$。\n4.  计算后验平均放电率：$m_t = \\alpha_t / \\beta_t$。\n5.  计算至少一个脉冲的后验预测概率：$q_t = 1 - (\\beta_t / (\\beta_t + d_{\\text{next}}))^{\\alpha_t}$。\n6.  将 $m_t$ 和 $q_t$ 都四舍五入到六位小数并存储结果。\n\n此过程在下面的 Python 代码中实现。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Bayesian inference problem for spike train data for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general)\n        {'alpha0': 2.0, 'beta0': 1.0, 'k_seq': [0, 1, 0, 2], 'd_seq': [0.2, 0.2, 0.2, 0.4], 'd_next': 0.5},\n        # Case 2 (boundary: no data)\n        {'alpha0': 1.5, 'beta0': 0.5, 'k_seq': [], 'd_seq': [], 'd_next': 0.1},\n        # Case 3 (edge: many zeros)\n        {'alpha0': 5.0, 'beta0': 2.0, 'k_seq': [0]*20, 'd_seq': [0.05]*20, 'd_next': 1.0},\n        # Case 4 (high counts and varied durations)\n        {'alpha0': 0.5, 'beta0': 0.1, 'k_seq': [5, 7, 3, 4, 6], 'd_seq': [1.0, 1.0, 0.5, 0.5, 2.0], 'd_next': 0.5},\n        # Case 5 (strong prior, sparse data)\n        {'alpha0': 20.0, 'beta0': 10.0, 'k_seq': [0, 0, 1, 0, 0], 'd_seq': [0.1, 0.1, 0.1, 0.1, 0.1], 'd_next': 0.2},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha0 = case['alpha0']\n        beta0 = case['beta0']\n        k_seq = case['k_seq']\n        d_seq = case['d_seq']\n        d_next = case['d_next']\n        \n        # Initialize posterior parameters with prior parameters\n        alpha_t = float(alpha0)\n        beta_t = float(beta0)\n        \n        # Perform online update for each observation\n        # This is equivalent to summing up all counts and durations\n        if k_seq:\n            total_k = sum(k_seq)\n            total_d = sum(d_seq)\n            alpha_t += total_k\n            beta_t += total_d\n        \n        # Calculate posterior mean firing rate (m_t)\n        # Handle the case where beta_t is zero, though unlikely with given constraints\n        if beta_t == 0:\n            m_t = float('inf') # Or handle as an error\n        else:\n            m_t = alpha_t / beta_t\n        \n        # Calculate posterior predictive probability of at least one spike (q_t)\n        if beta_t + d_next == 0:\n             # This can't happen if d_next > 0 and beta_0 >= 0\n             q_t = 1.0\n        else:\n            # The formula is 1 - (beta_t / (beta_t + d_next)) ** alpha_t\n            base = beta_t / (beta_t + d_next)\n            prob_zero_spikes = np.power(base, alpha_t)\n            q_t = 1.0 - prob_zero_spikes\n            \n        # Round results to six decimal places\n        m_t_rounded = round(m_t, 6)\n        q_t_rounded = round(q_t, 6)\n        \n        results.append([m_t_rounded, q_t_rounded])\n\n    # Format the final output string as specified\n    # Example: [[1.23,0.45],[6.78,0.90]]\n    output_str = \"[\" + \",\".join([f\"[{m},{q}]\" for m, q in results]) + \"]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "拟合模型只是第一步；任何严谨分析的关键部分是检查模型是否充分地描述了数据。本实践 () 引入了后验预测检验这一强大技术，用于评估我们的脉冲计数泊松模型。通过从您拟合的模型中模拟生成重复数据集，您将学习如何诊断潜在的模型失配问题，并评估模型的假设（例如均值与方差之间的关系）是否与观测数据一致。",
            "id": "4140541",
            "problem": "您将使用贝叶斯定理和条件概率，为一个泊松模型下的脉冲计数数据实现一个后验预测检验。考虑一个重复试验的实验，每次试验都会产生一个脉冲计数值。假设在给定一个共同的速率参数的条件下，各次试验的计数值是条件独立的。其生成模型为：在给定的潜在速率参数 $\\lambda$ 的条件下，每个脉冲计数值 $y_i$ 都是从参数为 $\\lambda$ 的泊松分布中独立抽取的。对 $\\lambda$ 采用形状-速率参数化的伽马先验分布。您的任务是使用一个离散度统计量，通过后验预测检验来评估模型的充分性。\n\n从以下基本理论出发：\n- 条件独立性：给定 $\\lambda$，观测值是独立同分布的。\n- 泊松概率质量函数：对于整数 $k \\ge 0$ 和速率 $\\lambda > 0$，取值为 $k$ 的概率是 $p(k \\mid \\lambda) = \\exp(-\\lambda)\\lambda^{k}/k!$。\n- 伽马先验（形状-速率）：对于 $\\lambda > 0$，形状参数 $\\alpha_0 > 0$ 和速率参数 $\\beta_0 > 0$，其概率密度为 $p(\\lambda \\mid \\alpha_0,\\beta_0) = \\dfrac{\\beta_0^{\\alpha_0}}{\\Gamma(\\alpha_0)} \\lambda^{\\alpha_0-1}\\exp(-\\beta_0 \\lambda)$。\n- 贝叶斯定理：$p(\\lambda \\mid y) \\propto p(y \\mid \\lambda)\\,p(\\lambda)$，其中 $p(y \\mid \\lambda)$ 是似然函数，$p(\\lambda)$ 是先验分布。\n\n对于一个计数向量 $y = (y_1,\\dots,y_n)$，其样本均值为 $\\bar{y}$，无偏样本方差为 $s^2$（自由度为1），定义其离散度统计量为\n$$\nD(y) \\;=\\; \\frac{s^2(y)}{\\bar{y}}.\n$$\n如果 $\\bar{y} = 0$，则 $D(y)$ 未定义；对于本问题，所有提供的观测数据集都将满足 $\\bar{y} > 0$。\n\n实现以下后验预测检验：\n1. 使用贝叶斯定理和指定的伽马先验分布，计算后验分布 $p(\\lambda \\mid y)$。\n2. 对于 $S$ 个独立的后验预测重复样本，重复以下步骤：\n   - 从后验分布 $p(\\lambda \\mid y)$ 中抽取 $\\lambda^{(s)}$。\n   - 抽取一个重复数据集 $y^{(s)}_{\\mathrm{rep}} = (y^{(s)}_{\\mathrm{rep},1},\\dots,y^{(s)}_{\\mathrm{rep},n})$，其中每个 $y^{(s)}_{\\mathrm{rep},i} \\mid \\lambda^{(s)}$ 均独立地从 $\\text{Poisson}(\\lambda^{(s)})$ 分布中抽取。\n   - 使用与上述相同的定义计算 $D\\!\\left(y^{(s)}_{\\mathrm{rep}}\\right)$。如果 $\\bar{y}^{(s)}_{\\mathrm{rep}} = 0$，则 $D\\!\\left(y^{(s)}_{\\mathrm{rep}}\\right)$ 未定义；在计算尾部概率时应忽略此类重复样本。\n3. 令 $D_{\\mathrm{obs}} = D(y)$。通过有效重复样本中满足 $D\\!\\left(y^{(s)}_{\\mathrm{rep}}\\right) \\ge D_{\\mathrm{obs}}$ 的比例来估计上尾后验预测概率\n$$\np_{\\mathrm{upper}} \\;=\\; \\mathbb{P}\\!\\left(D\\!\\left(y_{\\mathrm{rep}}\\right) \\ge D_{\\mathrm{obs}} \\,\\middle|\\, y\\right)\n$$\n。类似地，通过有效重复样本中满足 $D\\!\\left(y^{(s)}_{\\mathrm{rep}}\\right) \\le D_{\\mathrm{obs}}$ 的比例来估计下尾后验预测概率\n$$\np_{\\mathrm{lower}} \\;=\\; \\mathbb{P}\\!\\left(D\\!\\left(y_{\\mathrm{rep}}\\right) \\le D_{\\mathrm{obs}} \\,\\middle|\\, y\\right)\n$$\n。\n\n您的程序必须：\n- 在每个测试用例中，使用提供的形状-速率参数 $(\\alpha_0,\\beta_0)$ 的伽马先验分布。\n- 在计算 $s^2$ 时，使用自由度为1的无偏样本方差。\n- 为了可复现性，使用固定的随机种子 $2025$。\n- 在估计尾部概率时，忽略均值为零的后验预测重复样本；如果在特殊情况下没有剩余的有效重复样本，则该测试用例返回 $p_{\\mathrm{upper}} = 0.5$ 和 $p_{\\mathrm{lower}} = 0.5$。\n- 以小数形式（而非百分比）返回结果。\n\n测试集：\n- 案例 $1$：$y = [\\,3,\\,2,\\,5,\\,4,\\,1,\\,0,\\,6,\\,2,\\,4,\\,3\\,]$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0$，$S = 20000$。\n- 案例 $2$（相对于泊松分布呈过离散）：$y = [\\,0,\\,7,\\,0,\\,12,\\,3,\\,9,\\,1,\\,15,\\,2,\\,0\\,]$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0$，$S = 20000$。\n- 案例 $3$（相对于泊松分布呈欠离散）：$y = [\\,5,\\,5,\\,4,\\,5,\\,6,\\,5,\\,5,\\,5,\\,5,\\,4\\,]$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0$，$S = 20000$。\n- 案例 $4$（边界行为）：$y = [\\,0,\\,1\\,]$，$\\alpha_0 = 1.0$，$\\beta_0 = 1.0$，$S = 20000$。\n- 案例 $5$（强先验影响）：$y = [\\,2,\\,2\\,]$，$\\alpha_0 = 10.0$，$\\beta_0 = 5.0$，$S = 20000$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例对应一个双元素列表 $[p_{\\mathrm{upper}}, p_{\\mathrm{lower}}]$，每个概率值四舍五入到六位小数，例如：\n\"[ [p1_upper,p1_lower], [p2_upper,p2_lower], ... ]\"，不含多余空格。具体来说，确切要求的格式为单行：\n\"[[p1_upper,p1_lower],[p2_upper,p2_lower],[p3_upper,p3_lower],[p4_upper,p4_lower],[p5_upper,p5_lower]]\"。",
            "solution": "该问题要求为一个关于脉冲计数数据的分层泊松-伽马模型实现后验预测检验。其目标是通过将从观测数据计算出的离散度统计量与从模型的后验预测分布中模拟的重复数据计算出的同一统计量的分布进行比较，来评估模型的充分性。\n\n首先，必须正式指定贝叶斯模型。数据由一个包含 $n$ 个脉冲计数值的向量 $y = (y_1, \\dots, y_n)$ 组成。生成模型假定，在给定的潜在速率参数 $\\lambda > 0$ 的条件下，每个计数值 $y_i$ 都是从泊松分布中独立抽取的。因此，似然函数为：\n$$\np(y \\mid \\lambda) = \\prod_{i=1}^{n} p(y_i \\mid \\lambda) = \\prod_{i=1}^{n} \\frac{e^{-\\lambda} \\lambda^{y_i}}{y_i!} = \\frac{e^{-n\\lambda} \\lambda^{\\sum_{i=1}^{n} y_i}}{\\prod_{i=1}^{n} y_i!}\n$$\n对于速率参数 $\\lambda$，选择伽马分布作为先验分布，其参数为形状参数 $\\alpha_0 > 0$ 和速率参数 $\\beta_0 > 0$。由于伽马分布是泊松似然函数的共轭先验，这一选择是标准的。先验概率密度函数为：\n$$\np(\\lambda \\mid \\alpha_0, \\beta_0) = \\frac{\\beta_0^{\\alpha_0}}{\\Gamma(\\alpha_0)} \\lambda^{\\alpha_0-1} e^{-\\beta_0 \\lambda}\n$$\n根据贝叶斯定理，$\\lambda$ 的后验分布与似然函数和先验分布的乘积成正比：$p(\\lambda \\mid y) \\propto p(y \\mid \\lambda) p(\\lambda)$。我们可以通过组合涉及 $\\lambda$ 的项来推导后验分布的函数形式：\n$$\np(\\lambda \\mid y) \\propto \\left( e^{-n\\lambda} \\lambda^{\\sum_{i=1}^{n} y_i} \\right) \\left( \\lambda^{\\alpha_0-1} e^{-\\beta_0 \\lambda} \\right)\n$$\n$$\np(\\lambda \\mid y) \\propto \\lambda^{(\\alpha_0 + \\sum_{i=1}^{n} y_i) - 1} e^{-(\\beta_0 + n) \\lambda}\n$$\n该表达式是伽马分布的核。通过观察，我们可以确定后验分布的参数，我们将其表示为 $\\alpha_n$ 和 $\\beta_n$：\n- 后验形状参数：$\\alpha_n = \\alpha_0 + \\sum_{i=1}^{n} y_i$\n- 后验速率参数：$\\beta_n = \\beta_0 + n$\n因此，$\\lambda$ 的后验分布为 $p(\\lambda \\mid y) = \\text{Gamma}(\\lambda \\mid \\alpha_n, \\beta_n)$。\n\n下一步是定义用于模型检验的检验统计量。问题指定了一个离散度统计量 $D(y)$，定义为样本方差与样本均值之比：\n$$\nD(y) = \\frac{s^2(y)}{\\bar{y}}\n$$\n其中 $\\bar{y} = \\frac{1}{n} \\sum_{i=1}^{n} y_i$ 是样本均值。$s^2(y)$ 项是无偏样本方差。问题陈述中描述其具有“自由度等于1”。这被解释为对使用除数 $n-1$ 的无偏样本方差标准公式的一个稍欠精确的引用，该公式对应于像 NumPy 这样的数值计算库中的 `ddof=1`（自由度差值）参数。该估计量与一个具有 $n-1$ 自由度的抽样分布相关联。对于大小为 $n$ 的样本，其公式为：\n$$\ns^2(y) = \\frac{1}{n-1} \\sum_{i=1}^{n} (y_i - \\bar{y})^2\n$$\n我们采纳此解释，因为它是“无偏样本方差”的标准定义。对于观测数据 $y$，所有提供的测试用例都满足 $n \\ge 2$ 和 $\\bar{y} > 0$，从而确保 $D(y)$ 是良定义的。\n\n后验预测检验通过一个基于模拟的算法来执行：\n1.  计算观测数据的离散度统计量，$D_{\\mathrm{obs}} = D(y)$。\n2.  生成大量的（$S$ 个）独立的后验预测重复样本。对于从 $1$ 到 $S$ 的每个重复样本 $s$：\n    a. 从后验分布中抽取一个速率参数 $\\lambda^{(s)}$：$\\lambda^{(s)} \\sim \\text{Gamma}(\\alpha_n, \\beta_n)$。\n    b. 通过从以抽样速率为参数的泊松分布中独立抽取每个计数值，来生成一个重复数据集 $y^{(s)}_{\\mathrm{rep}} = (y^{(s)}_{\\mathrm{rep},1}, \\dots, y^{(s)}_{\\mathrm{rep},n})$：$y^{(s)}_{\\mathrm{rep},i} \\sim \\text{Poisson}(\\lambda^{(s)})$。\n    c. 计算该重复样本的离散度统计量 $D(y^{(s)}_{\\mathrm{rep}})$。样本均值 $\\bar{y}^{(s)}_{\\mathrm{rep}}$ 为 $0$ 的重复样本被视为无效，并从后续分析中省略，因为 $D(y^{(s)}_{\\mathrm{rep}})$ 在这种情况下未定义。\n3.  估计上尾和下尾后验预测概率（$p$-值）。这些量度量了根据所选统计量，重复数据与观测数据同样极端或更极端的概率。它们通过满足条件的有效重复样本的比例来估计：\n$$\np_{\\mathrm{upper}} = \\mathbb{P}(D(y_{\\mathrm{rep}}) \\ge D_{\\mathrm{obs}} \\mid y) \\approx \\frac{1}{N_{\\mathrm{valid}}} \\sum_{s=1}^{S} \\mathbb{I}\\left(\\bar{y}^{(s)}_{\\mathrm{rep}} > 0 \\text{ and } D(y^{(s)}_{\\mathrm{rep}}) \\ge D_{\\mathrm{obs}}\\right)\n$$\n$$\np_{\\mathrm{lower}} = \\mathbb{P}(D(y_{\\mathrm{rep}}) \\le D_{\\mathrm{obs}} \\mid y) \\approx \\frac{1}{N_{\\mathrm{valid}}} \\sum_{s=1}^{S} \\mathbb{I}\\left(\\bar{y}^{(s)}_{\\mathrm{rep}} > 0 \\text{ and } D(y^{(s)}_{\\mathrm{rep}}) \\le D_{\\mathrm{obs}}\\right)\n$$\n此处，$\\mathbb{I}(\\cdot)$ 是指示函数，$N_{\\mathrm{valid}}$ 是有效重复样本的总数（其中 $\\bar{y}^{(s)}_{\\mathrm{rep}} > 0$）。如果 $N_{\\mathrm{valid}} = 0$，则根据问题规定，概率被设置为 $0.5$。\n\n此过程将对每个测试用例实施，并使用固定的随机种子 $2025$ 以确保模拟结果的可复现性。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a posterior predictive check for spike count data modeled\n    with a Poisson-Gamma hierarchical model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'y': np.array([3, 2, 5, 4, 1, 0, 6, 2, 4, 3]), 'alpha0': 1.0, 'beta0': 1.0, 'S': 20000},\n        {'y': np.array([0, 7, 0, 12, 3, 9, 1, 15, 2, 0]), 'alpha0': 1.0, 'beta0': 1.0, 'S': 20000},\n        {'y': np.array([5, 5, 4, 5, 6, 5, 5, 5, 5, 4]), 'alpha0': 1.0, 'beta0': 1.0, 'S': 20000},\n        {'y': np.array([0, 1]), 'alpha0': 1.0, 'beta0': 1.0, 'S': 20000},\n        {'y': np.array([2, 2]), 'alpha0': 10.0, 'beta0': 5.0, 'S': 20000},\n    ]\n\n    # Initialize a random number generator with the specified seed.\n    rng = np.random.default_rng(2025)\n    \n    results = []\n\n    def dispersion_statistic(counts):\n        \"\"\"\n        Calculates the dispersion statistic D(y) = s^2(y) / y_bar.\n        Returns None if y_bar is 0 or if variance is ill-defined (n2).\n        \"\"\"\n        n = len(counts)\n        if n  2:\n            return 0.0 # Variance is 0 for n=1, or undefined. Treat as 0. \n                       # Problem cases all have n>=2, so this is for internal robustness.\n        \n        mean_val = np.mean(counts)\n        if mean_val == 0.0:\n            return None # Undefined\n        \n        # Use ddof=1 for unbiased sample variance (divisor n-1).\n        var_val = np.var(counts, ddof=1)\n        return var_val / mean_val\n\n    for case in test_cases:\n        y_obs = case['y']\n        alpha0 = case['alpha0']\n        beta0 = case['beta0']\n        S = case['S']\n        n = len(y_obs)\n\n        # 1. Compute observed statistic\n        d_obs = dispersion_statistic(y_obs)\n\n        # 2. Compute posterior parameters for lambda ~ Gamma(alpha_n, beta_n)\n        alpha_post = alpha0 + np.sum(y_obs)\n        beta_post = beta0 + n\n\n        # 3. Draw S samples from the posterior predictive distribution\n        # Draw lambda samples from the Gamma posterior\n        # numpy.random.gamma uses shape and scale, where scale = 1 / rate.\n        lambda_samples = rng.gamma(shape=alpha_post, scale=1.0/beta_post, size=S)\n\n        # Draw replicated datasets y_rep from Poisson(lambda_sample)\n        # Reshape lambda_samples to (S, 1) to broadcast for generating (S, n) replicates\n        y_reps = rng.poisson(lam=lambda_samples[:, np.newaxis], size=(S, n))\n        \n        # 4. Compute dispersion statistic for each replicate\n        mean_reps = np.mean(y_reps, axis=1)\n        \n        # Create a mask for valid replicates (mean > 0)\n        valid_mask = mean_reps > 0\n        \n        if not np.any(valid_mask):\n            # Special case: no valid replicates generated.\n            p_upper, p_lower = 0.5, 0.5\n        else:\n            valid_y_reps = y_reps[valid_mask]\n            valid_mean_reps = mean_reps[valid_mask]\n            \n            # Using ddof=1 for unbiased sample variance\n            var_reps = np.var(valid_y_reps, axis=1, ddof=1)\n\n            # Handle cases where mean is > 0 but var is 0 (e.g., [1, 1, 1])\n            # The calculation is still valid: D_rep will be 0.\n            d_reps = var_reps / valid_mean_reps\n            \n            # 5. Estimate tail probabilities\n            num_valid_reps = len(d_reps)\n            \n            p_upper = np.sum(d_reps >= d_obs) / num_valid_reps\n            p_lower = np.sum(d_reps = d_obs) / num_valid_reps\n\n        # Format results for the final output string\n        results.append(f\"[{p_upper:.6f},{p_lower:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}