{
    "hands_on_practices": [
        {
            "introduction": "在神经科学中，许多复杂的生物过程可以被建模为一系列更简单的线性系统。一个核心原理是，级联系统的总冲激响应是其各组成部分冲激响应的卷积。这项练习将通过一个两室模型推导出一个广泛使用的双指数核函数，从而为这一数学函数提供了坚实的生物物理基础，这是理解卷积如何从基本原理构建复杂系统模型的关键一步。",
            "id": "4149344",
            "problem": "在神经科学数据分析中，通常使用简化的双室级联模型来模拟树突膜和胞体膜对突触电流的滤波作用。考虑两个串联的因果线性时不变（LTI）一阶室。第一个室接收一个模拟为狄拉克-德尔塔函数输入$\\delta(t)$的刺激，其状态$x_1(t)$满足常微分方程$\\tau_1\\frac{d x_1}{d t} + x_1 = \\delta(t)$，且初始条件为零。第二个室以$x_1(t)$为输入，其状态$x_2(t)$满足$\\tau_2\\frac{d x_2}{d t} + x_2 = x_1(t)$，且初始条件为零。此处$\\tau_1 > 0$和$\\tau_2 > 0$是室的时间常数，$\\delta(t)$是具有通常分布性质的狄拉克-德尔塔函数。令$H(t)$表示赫维赛德阶跃函数。\n\n仅从LTI脉冲响应和级联系统卷积的核心定义出发，推导该级联系统的总脉冲响应$h(t)$（即第二个室对其输入端的$\\delta(t)$的响应输出），并将其表示为包含$\\tau_1$、$\\tau_2$和$t$的封闭形式解析表达式。然后，通过确定其因果性、曲线下面积以及定性形状来解释所得核函数，包括当$\\tau_1 \\neq \\tau_2$时其峰值的存在和位置，以及当$\\tau_1 \\to \\tau_2$时的极限形式。\n\n将最终的核函数$h(t)$表示为单个解析表达式。将时间$t$视为以秒为单位，但最终表达式中不包含任何单位。无需四舍五入。",
            "solution": "问题陈述已经过验证，被认为是科学上合理的、适定的、客观的且自洽的。它描述了系统理论和计算神经科学中的一个标准模型，任务是明确定义的数学推导和解释。该问题是有效的。\n\n该问题要求解一个由两个一阶因果LTI系统级联而成的总脉冲响应 $h(t)$。此类系统的核心原理是，总脉冲响应是各独立脉冲响应的卷积。设 $h_1(t)$ 是第一个室的脉冲响应，$h_2(t)$ 是第二个室的脉冲响应。则总系统响应 $h(t)$ 由卷积分给出：\n$$h(t) = (h_1 * h_2)(t) = \\int_{-\\infty}^{\\infty} h_1(\\tau) h_2(t-\\tau) d\\tau$$\n\n首先，我们必须确定各个脉冲响应 $h_1(t)$ 和 $h_2(t)$。\n\n第一个室由一个以狄拉克-德尔塔函数为输入的常微分方程（ODE）描述：\n$$\\tau_{1}\\,\\frac{d x_{1}}{d t} + x_{1} = \\delta(t)$$\n初始条件为零。根据定义，其脉冲响应 $h_1(t)$ 就是解 $x_1(t)$。我们可以使用拉普拉斯变换来求解，记为 $\\mathcal{L}\\{\\cdot\\}$。设 $X_1(s) = \\mathcal{L}\\{x_1(t)\\}$。\n$$\\mathcal{L}\\left\\{\\tau_{1}\\,\\frac{d x_{1}}{d t} + x_{1}\\right\\} = \\mathcal{L}\\{\\delta(t)\\}$$\n$$\\tau_1 (s X_1(s) - x_1(0^-)) + X_1(s) = 1$$\n给定初始条件为零，$x_1(0^-) = 0$。\n$$X_1(s) (\\tau_1 s + 1) = 1$$\n$$X_1(s) = \\frac{1}{\\tau_1 s + 1} = \\frac{1/\\tau_1}{s + 1/\\tau_1}$$\n拉普拉斯逆变换给出脉冲响应 $h_1(t)$。包含赫维赛德阶跃函数 $H(t)$ 以反映系统的因果性。\n$$h_1(t) = x_1(t) = \\mathcal{L}^{-1}\\{X_1(s)\\} = \\frac{1}{\\tau_1} \\exp\\left(-\\frac{t}{\\tau_1}\\right) H(t)$$\n\n第二个室在形式上与第一个室相同，只是时间常数不同，为 $\\tau_2$。如果其输入为 $\\delta(t)$，则其脉冲响应 $h_2(t)$ 就是其输出。以此类推：\n$$h_2(t) = \\frac{1}{\\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) H(t)$$\n\n现在，我们计算卷积 $h(t) = (h_1 * h_2)(t)$。\n$$h(t) = \\int_{-\\infty}^{\\infty} \\left[\\frac{1}{\\tau_1} \\exp\\left(-\\frac{\\tau}{\\tau_1}\\right) H(\\tau)\\right] \\left[\\frac{1}{\\tau_2} \\exp\\left(-\\frac{t-\\tau}{\\tau_2}\\right) H(t-\\tau)\\right] d\\tau$$\n赫维赛德函数的乘积 $H(\\tau)H(t-\\tau)$ 仅在 $\\tau \\ge 0$ 且 $t-\\tau \\ge 0$（即 $\\tau \\le t$）时非零。这意味着对于 $t  0$，积分为零，因此 $h(t) = 0$。对于 $t \\ge 0$，积分上下限变为 $0$ 到 $t$。\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\int_0^t \\exp\\left(-\\frac{\\tau}{\\tau_1}\\right) \\exp\\left(-\\frac{t-\\tau}{\\tau_2}\\right) d\\tau \\quad \\text{for } t \\ge 0$$\n我们可以将与积分变量 $\\tau$ 无关的项提出来：\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\int_0^t \\exp\\left(-\\frac{\\tau}{\\tau_1} + \\frac{\\tau}{\\tau_2}\\right) d\\tau$$\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\int_0^t \\exp\\left(\\tau \\left(\\frac{1}{\\tau_2} - \\frac{1}{\\tau_1}\\right)\\right) d\\tau$$\n\n我们现在评估这个积分，分两种情况考虑。\n\n情况1：$\\tau_1 \\neq \\tau_2$。\n积分中的指数非零。设 $\\tau$ 的系数为 $k = \\frac{1}{\\tau_2} - \\frac{1}{\\tau_1} = \\frac{\\tau_1 - \\tau_2}{\\tau_1 \\tau_2}$。\n$$\\int_0^t \\exp(k\\tau) d\\tau = \\left[\\frac{1}{k} \\exp(k\\tau)\\right]_0^t = \\frac{1}{k} (\\exp(kt) - 1) = \\frac{\\tau_1 \\tau_2}{\\tau_1 - \\tau_2} \\left(\\exp\\left(t\\frac{\\tau_1-\\tau_2}{\\tau_1\\tau_2}\\right) - 1\\right)$$\n将此结果代回 $h(t)$ 的表达式中：\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\left[ \\frac{\\tau_1 \\tau_2}{\\tau_1 - \\tau_2} \\left(\\exp\\left(\\frac{t}{\\tau_2} - \\frac{t}{\\tau_1}\\right) - 1\\right) \\right]$$\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\exp\\left(\\frac{t}{\\tau_2} - \\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right)$$\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) \\quad \\text{for } t \\ge 0$$\n结合 $t  0$ 的情况，完整的表达式为：\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) H(t)$$\n\n情况2：当 $\\tau_1 \\to \\tau_2$ 时的极限形式。设 $\\tau_1 = \\tau_2 = \\tau$。\n情况1中 $h(t)$ 的表达式变成了 $0/0$ 的不定形式。我们可以通过对分子和分母分别关于 $\\tau_1$ 求导，然后取极限 $\\tau_1 \\to \\tau_2$，使用洛必达法则来求极限。\n$$h(t) = \\lim_{\\tau_1 \\to \\tau_2} \\frac{\\frac{d}{d\\tau_1}\\left( \\exp\\left(-t/\\tau_1\\right) - \\exp\\left(-t/\\tau_2\\right) \\right)}{\\frac{d}{d\\tau_1}(\\tau_1 - \\tau_2)} H(t)$$\n$$\\frac{d}{d\\tau_1}\\left( \\exp\\left(-t/\\tau_1\\right) \\right) = \\exp\\left(-t/\\tau_1\\right) \\cdot \\left(\\frac{t}{\\tau_1^2}\\right)$$\n$$\\frac{d}{d\\tau_1}(\\tau_1 - \\tau_2) = 1$$\n取极限 $\\tau_1 \\to \\tau_2 = \\tau$：\n$$h(t) = \\frac{\\exp(-t/\\tau) \\cdot (t/\\tau^2)}{1} H(t) = \\frac{t}{\\tau^2} \\exp\\left(-\\frac{t}{\\tau}\\right) H(t)$$\n这个函数在神经科学中被称为alpha函数。\n\n现在，我们解释在一般情况 $\\tau_1 \\neq \\tau_2$ 下推导出的核函数 $h(t)$。\n\n因果性：赫维赛德函数 $H(t)$ 的存在确保了对于所有 $t  0$ 都有 $h(t) = 0$。这意味着系统的输出不会早于其输入，这是因果系统的定义。\n\n曲线下面积：这由 $h(t)$ 在所有时间上的积分给出。\n$$\\text{Area} = \\int_{-\\infty}^{\\infty} h(t) dt = \\int_0^{\\infty} \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) dt$$\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} \\left[ \\int_0^{\\infty} \\exp\\left(-\\frac{t}{\\tau_1}\\right) dt - \\int_0^{\\infty} \\exp\\left(-\\frac{t}{\\tau_2}\\right) dt \\right]$$\n使用标准积分 $\\int_0^\\infty \\exp(-at) dt = 1/a$（对于 $a>0$）：\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} \\left[ \\left(-\\tau_1 \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)_0^{\\infty} - \\left(-\\tau_2 \\exp\\left(-\\frac{t}{\\tau_2}\\right)\\right)_0^{\\infty} \\right]$$\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} [ (0 - (-\\tau_1)) - (0 - (-\\tau_2)) ] = \\frac{\\tau_1 - \\tau_2}{\\tau_1 - \\tau_2} = 1$$\n脉冲响应下的总面积为 $1$。\n\n定性形状和峰值位置（$\\tau_1 \\neq \\tau_2$）：函数 $h(t)$ 从 $h(0)=0$ 开始，上升到一个最大值，然后随着 $t \\to \\infty$ 指数衰减到 $0$。为了找到峰值时间 $t_{peak}$，我们将 $h(t)$ 的导数设为零。\n$$\\frac{dh}{dt} = \\frac{d}{dt} \\left[ \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) \\right] = 0$$\n$$\\frac{1}{\\tau_1 - \\tau_2} \\left( -\\frac{1}{\\tau_1}\\exp\\left(-\\frac{t}{\\tau_1}\\right) + \\frac{1}{\\tau_2}\\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) = 0$$\n$$\\frac{1}{\\tau_2}\\exp\\left(-\\frac{t}{\\tau_2}\\right) = \\frac{1}{\\tau_1}\\exp\\left(-\\frac{t}{\\tau_1}\\right)$$\n$$\\frac{\\tau_1}{\\tau_2} = \\frac{\\exp(-t/\\tau_2)}{\\exp(-t/\\tau_1)} = \\exp\\left(t\\left(\\frac{1}{\\tau_1} - \\frac{1}{\\tau_2}\\right)\\right)$$\n对两边取自然对数：\n$$\\ln\\left(\\frac{\\tau_1}{\\tau_2}\\right) = t \\left(\\frac{1}{\\tau_1} - \\frac{1}{\\tau_2}\\right) = t \\frac{\\tau_2 - \\tau_1}{\\tau_1 \\tau_2}$$\n求解 $t = t_{peak}$：\n$$t_{peak} = \\frac{\\tau_1 \\tau_2}{\\tau_2 - \\tau_1} \\ln\\left(\\frac{\\tau_1}{\\tau_2}\\right) = \\frac{\\tau_1 \\tau_2 (\\ln\\tau_1 - \\ln\\tau_2)}{\\tau_2 - \\tau_1} = \\frac{\\tau_1 \\tau_2 (\\ln\\tau_2 - \\ln\\tau_1)}{\\tau_1 - \\tau_2}$$\n对于 $\\tau_1, \\tau_2 > 0$ 和 $\\tau_1 \\neq \\tau_2$，这个时间总是正的。\n当 $\\tau_1 \\to \\tau_2 = \\tau$ 时，此表达式的极限是 $t_{peak}=\\tau$，这是alpha函数的正确峰值时间。\n\n因此，级联系统的最终推导脉冲响应得到了证实。",
            "answer": "$$\n\\boxed{ \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) H(t) }\n$$"
        },
        {
            "introduction": "从推导核函数转向应用核函数，下一步是利用卷积进行正向建模。一旦我们有了一个系统的冲激响应函数（例如血液动力学响应函数，HRF），我们就可以通过卷积预测系统对任意输入的响应。这项练习演示了这一过程，通过将一个经典的块状设计（block-design）刺激与HRF进行卷积，来预测功能磁共振成像（fMRI）中的血氧水平依赖（BOLD）信号，这是fMRI数据分析的基石。",
            "id": "4149331",
            "problem": "给定一个在线性系统框架内的功能性磁共振成像 (fMRI) 中血氧水平依赖 (BOLD) 信号生成的离散时间模型。\n\n神经血管耦合将被建模为一个线性时不变 (LTI) 系统：该系统完全由其脉冲响应来表征，且对于任何输入的输出都由缩放、时移的脉冲响应的叠加确定。输入是组块设计的神经活动信号，输出是预测的 BOLD 信号。时间必须以秒为单位表示。\n\n将经典血液动力学响应函数 (HRF) $h(t)$ 定义为两个伽马函数的差，其参数选择为生理上合理的。对于 $t \\ge 0$，令\n$$\nh(t) = \\frac{t^{a_1-1} e^{-t/b_1}}{b_1^{a_1}\\,\\Gamma(a_1)} \\;-\\; c \\,\\frac{t^{a_2-1} e^{-t/b_2}}{b_2^{a_2}\\,\\Gamma(a_2)},\n$$\n参数为 $a_1 = 6$，$b_1 = 1$，$a_2 = 12$，$b_2 = 1$，$c = 0.35$。对于 $t  0$，设 $h(t) = 0$。通过除以其在 $t \\in [0, t_{\\max}]$ 上的积分，将 $h(t)$ 归一化至单位面积，其中 $t_{\\max} = 32\\,s$。\n\n组块设计的神经活动 $n(t)$ 定义为一个分段常数函数，在预先指定的刺激块期间取值为 $A$，在其他时间取值为 $0$。对于一个起始时间为 $s$，持续时间为 $D$ 的组块，$n(t) = A$ 当 $t \\in [s, s + D)$，否则 $n(t) = 0$。假设在本问题的所有情况中 $A = 1$。\n\n预测的 BOLD 信号 $y(t)$ 是 LTI 系统对输入 $n(t)$ 的输出。您必须使用与 LTI 定义一致的离散时间近似，在均匀离散时间网格上计算 $y(t)$。使用采样间隔 $\\Delta t = 0.1\\,s$。对于数值卷积，在给定网格上实现连续时间运算的黎曼和近似，确保通过 $\\Delta t$ 进行正确缩放。\n\n为了分析 $h(t)$ 在不同组块间的重叠如何导致持续响应，为给定的组块安排定义“持续指数” $S$ 如下。设组块起始时间集合为 $\\{s_i\\}$，共同持续时间为 $D$。对于每个满足 $s_{i+1} > s_i + D$ 的连续对 $(s_i, s_{i+1})$，定义组块间隙区间 $G_i = [s_i + D, s_{i+1})$，在此区间上 $n(t) = 0$。计算每个间隙区间上预测的 BOLD 信号的平均值，\n$$\n\\overline{y}(G_i) \\;=\\; \\frac{1}{|G_i|} \\int_{G_i} y(t)\\, dt,\n$$\n其中 $|G_i|$ 是间隙区间的持续时间（以秒为单位）。令 $y_{\\max} = \\max_{t} y(t)$ 为完整分析窗口内的最大值。持续指数为\n$$\nS \\;=\\; \\begin{cases}\n\\displaystyle \\max_i \\left( \\frac{\\overline{y}(G_i)}{y_{\\max}} \\right),  \\text{如果存在至少一个间隙区间 } G_i, \\\\\n0,  \\text{如果不存在间隙区间。}\n\\end{cases}\n$$\n持续指数 $S$ 是一个在 $[0,1]$ 范围内的无量纲小数，它量化了由于 $h(t)$ 的重叠导致 BOLD 信号在组块之间保持升高的程度。\n\n实现一个程序，该程序能够：\n- 在 $[0, t_{\\max}]$ 上构建 $h(t)$，将其归一化至单位面积，并为每个测试用例在 $[0, T_{\\text{total}}]$ 上构建 $n(t)$。\n- 通过与 LTI 框架和黎曼和近似一致的离散时间卷积来计算预测的 BOLD 信号 $y(t)$。\n- 为每个测试用例计算如上定义的持续指数 $S$。\n\n所有时间值均以秒表示。所有返回的数值必须是浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，\"[result1,result2,result3]\"）。\n\n使用以下测试套件，其中每个测试用例都由组块起始时间、共同的组块持续时间和总分析窗口完全指定：\n1. 单个组块的正常情况，无间隙：起始时间 $\\{20\\}$，持续时间 $D = 20\\,s$，总时间 $T_{\\text{total}} = 100\\,s$。\n2. 两个组块间隔远超 HRF 支撑区间的边界情况：起始时间 $\\{10, 90\\}$，持续时间 $D = 10\\,s$，总时间 $T_{\\text{total}} = 150\\,s$。\n3. 两个组块间隙短于 HRF 尾部的重叠情况：起始时间 $\\{10, 25\\}$，持续时间 $D = 15\\,s$，总时间 $T_{\\text{total}} = 90\\,s$。\n4. 包含许多短组块和小编组块刺激间隔的高度重叠边缘情况：起始时间 $\\{0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112\\}$，持续时间 $D = 6\\,s$，总时间 $T_{\\text{total}} = 120\\,s$。\n\n您的程序必须按上述顺序列出每个测试用例的持续指数 $S$，格式为单行 \"[S1,S2,S3,S4]\"。",
            "solution": "该问题被验证为有科学依据、适定且客观的。所有定义和参数都足以构建一个唯一、可计算的解。分析过程通过实现指定的模型和度量来进行。\n\n解决方案分为以下四个主要步骤：\n1.  构建归一化的血液动力学响应函数 (HRF)。\n2.  为每个测试用例生成组块设计的神经活动信号。\n3.  通过离散卷积计算预测的血氧水平依赖 (BOLD) 信号。\n4.  从得到的 BOLD 信号中计算持续指数 $S$。\n\n### 步骤1：血液动力学响应函数 (HRF) 构建\n\n经典 HRF，记为 $h(t)$，模拟了对短暂、脉冲状神经事件的血管响应。它被定义为两个伽马函数之差，对于 $t \\ge 0$：\n$$\nh(t) = \\frac{t^{a_1-1} e^{-t/b_1}}{b_1^{a_1}\\,\\Gamma(a_1)} \\;-\\; c \\,\\frac{t^{a_2-1} e^{-t/b_2}}{b_2^{a_2}\\,\\Gamma(a_2)}\n$$\n其中 $\\Gamma(\\cdot)$ 是标准伽马函数。给定的参数为 $a_1 = 6$，$b_1 = 1$，$a_2 = 12$，$b_2 = 1$，$c = 0.35$。对于 $t  0$，$h(t) = 0$。\n\n该函数在从 $t=0$到 $t_{\\max} = 32\\,s$ 的时间网格上进行离散化，采样间隔为 $\\Delta t = 0.1\\,s$。设此离散序列为 $h[k] = h(k \\Delta t)$。\n\n问题要求将 $h(t)$ 归一化，使其在区间 $[0, t_{\\max}]$ 上的面积为单位1。该积分使用离散网格上的黎曼和进行近似：\n$$\nI = \\int_{0}^{t_{\\max}} h(t) \\,dt \\approx \\sum_{k=0}^{N_{\\text{hrf}}-1} h(t_k) \\Delta t\n$$\n其中 $t_k = k \\Delta t$，$N_{\\text{hrf}}$ 是 HRF 时间向量中的点数。归一化的 HRF，$h_{\\text{norm}}(t)$，则为：\n$$\nh_{\\text{norm}}(t) = \\frac{h(t)}{I}\n$$\n离散的归一化序列为 $h_{\\text{norm}}[k] = h[k] / I$。\n\n### 步骤2：神经活动信号构建\n\n系统的输入，即神经活动 $n(t)$，被建模为组块设计。它是一个分段常数函数，在指定的刺激块期间等于振幅 $A=1$，在其他时间等于 $0$。对于给定的起始时间集合 $\\{s_i\\}$ 和共同的持续时间 $D$，信号定义为：\n$$\nn(t) = \\begin{cases} 1  \\text{如果 } t \\in [s_i, s_i + D) \\text{ 对于某个 } i \\\\ 0  \\text{否则} \\end{cases}\n$$\n对于每个测试用例，我们在总分析窗口 $[0, T_{\\text{total}}]$ 上构建一个离散信号 $n[k] = n(k \\Delta t)$。\n\n### 步骤3：通过卷积计算 BOLD 信号\n\n预测的 BOLD 信号 $y(t)$ 是线性时不变 (LTI) 系统的输出，由输入信号 $n(t)$ 与系统的脉冲响应 $h_{\\text{norm}}(t)$ 的卷积给出：\n$$\ny(t) = (n * h_{\\text{norm}})(t) = \\int_{-\\infty}^{\\infty} n(\\tau) h_{\\text{norm}}(t - \\tau) \\,d\\tau\n$$\n问题指定使用与黎曼和一致的离散时间近似来计算此值。离散卷积为：\n$$\ny[k] = y(t_k) \\approx \\sum_{j} n(\\tau_j) h_{\\text{norm}}(t_k - \\tau_j) \\Delta \\tau\n$$\n其中 $t_k = k\\Delta t$，$\\tau_j = j\\Delta t$，且 $\\Delta \\tau = \\Delta t$。这对应于执行序列 $n[k]$ 和 $h_{\\text{norm}}[k]$ 的标准离散卷积，然后将结果乘以 $\\Delta t$：\n$$\ny[k] = \\Delta t \\cdot \\sum_{j=0}^{M-1} n[j] h_{\\text{norm}}[k-j]\n$$\n其中 $M$ 是信号 $n[k]$ 的长度。对每个测试用例执行此操作。卷积的输出被截断以匹配输入信号 $n[k]$ 的长度。\n\n### 步骤4：持续指数计算\n\n持续指数 $S$ 量化了 BOLD 信号在刺激块间隙中的升高程度。首先，在整个分析窗口内确定 BOLD 信号的全局最大值 $y_{\\max} = \\max_k y[k]$。\n\n接下来，我们识别所有的组块间隙区间。对于每一对具有共同持续时间 $D$ 的连续起始时间 $(s_i, s_{i+1})$，如果 $s_{i+1} > s_i + D$，则存在一个间隙区间 $G_i$。该区间定义为 $G_i = [s_i + D, s_{i+1})$。\n\n对于每个这样的间隙 $G_i$，计算平均 BOLD 信号。连续定义为：\n$$\n\\overline{y}(G_i) \\;=\\; \\frac{1}{|G_i|} \\int_{G_i} y(t)\\, dt,\n$$\n其中 $|G_i| = s_{i+1} - (s_i+D)$ 是间隙的持续时间。其离散近似是间隙区间内 BOLD 信号样本的算术平均值：\n$$\n\\overline{y}(G_i) \\approx \\frac{1}{N_{G_i}} \\sum_{t_k \\in G_i} y[k]\n$$\n其中 $N_{G_i}$ 是间隙区间 $G_i$ 中的时间点数。\n\n为每个间隙计算一个比率 $r_i = \\overline{y}(G_i) / y_{\\max}$。持续指数 $S$ 是所有间隙中这些比率的最大值。如果不存在这样的间隙（例如，单个组块或连续的组块），则 $S$ 定义为 $0$。\n$$\nS \\;=\\; \\begin{cases}\n\\displaystyle \\max_i (r_i),  \\text{如果存在至少一个间隙区间 } G_i, \\\\\n0,  \\text{如果不存在间隙区间。}\n\\end{cases}\n$$\n将此过程应用于问题陈述中指定的四个测试用例中的每一个，以获得最终结果。\n\n对于案例1（单个组块）和案例3（其中 $s_{i+1} = s_i+D$ 的连续组块），条件 $s_{i+1} > s_i+D$ 不被满足。因此，不存在间隙区间，根据定义，这两种情况下的持续指数 $S$ 均为 $0$。对于案例2和案例4，存在间隙区间，$S$ 按上述最大比率计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Solves the BOLD signal modeling problem by computing the sustained index\n    for several block-design experiments.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"onsets\": [20.0], \"D\": 20.0, \"T_total\": 100.0},\n        {\"onsets\": [10.0, 90.0], \"D\": 10.0, \"T_total\": 150.0},\n        {\"onsets\": [10.0, 25.0], \"D\": 15.0, \"T_total\": 90.0},\n        {\"onsets\": [0.0, 8.0, 16.0, 24.0, 32.0, 40.0, 48.0, 56.0, 64.0, 72.0, 80.0, 88.0, 96.0, 104.0, 112.0], \"D\": 6.0, \"T_total\": 120.0}\n    ]\n\n    results = []\n    \n    # Global parameters\n    delta_t = 0.1\n    t_max_hrf = 32.0\n    a1, b1, a2, b2, c = 6.0, 1.0, 12.0, 1.0, 0.35\n    A = 1.0\n\n    # 1. Construct and normalize the Hemodynamic Response Function (HRF)\n    \n    def gamma_pdf_term(t, a, b):\n        \"\"\"\n        Computes the unscaled gamma PDF term.\n        Note: t must be a numpy array. a-1 > 0 is assumed.\n        \"\"\"\n        # The expression t**(a-1) is numerically safe for t=0 since a>1.\n        numerator = t**(a-1) * np.exp(-t/b)\n        denominator = b**a * gamma(a)\n        # Handle division by zero just in case, though not expected here.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            term = np.true_divide(numerator, denominator)\n        term[denominator == 0] = 0.0 # defensive\n        return term\n\n    t_hrf = np.arange(0, t_max_hrf + delta_t / 2, delta_t)\n    \n    h_unnormalized = gamma_pdf_term(t_hrf, a1, b1) - c * gamma_pdf_term(t_hrf, a2, b2)\n    \n    integral_h = np.sum(h_unnormalized) * delta_t\n    h_norm = h_unnormalized / integral_h\n\n    # Process each test case\n    for case in test_cases:\n        onsets = case[\"onsets\"]\n        D = case[\"D\"]\n        T_total = case[\"T_total\"]\n\n        # 2. Construct the neural activity signal n(t)\n        num_points = int(round(T_total / delta_t)) + 1\n        t_vec = np.linspace(0, T_total, num_points)\n        n = np.zeros_like(t_vec)\n\n        for s in onsets:\n            start_idx = int(round(s / delta_t))\n            # The interval is [s, s+D), so the end index is exclusive.\n            end_idx = int(round((s + D) / delta_t))\n            n[start_idx:end_idx] = A\n            \n        # 3. Compute predicted BOLD signal y(t) via discrete convolution\n        y = np.convolve(n, h_norm, mode='full')\n        # Truncate to original signal length and scale by delta_t for Riemann sum\n        y = y[:len(n)] * delta_t\n        \n        # 4. Compute the sustained index S\n        y_max = np.max(y)\n        \n        # If no activity, y_max can be 0. Avoid division by zero.\n        if y_max = 0:\n            S = 0.0\n            results.append(S)\n            continue\n            \n        # According to the definition, S=0 if there are no gaps.\n        # This occurs if there is only one block or no blocks.\n        if len(onsets) = 1:\n            S = 0.0\n            results.append(S)\n            continue\n            \n        gap_ratios = []\n        for i in range(len(onsets) - 1):\n            s_i = onsets[i]\n            s_i_plus_1 = onsets[i+1]\n\n            # A gap interval exists only if s_{i+1} > s_i + D\n            if s_i_plus_1 > s_i + D:\n                gap_start_t = s_i + D\n                gap_end_t = s_i_plus_1\n                \n                gap_start_idx = int(round(gap_start_t / delta_t))\n                gap_end_idx = int(round(gap_end_t / delta_t))\n                \n                # Ensure the indices define a non-empty slice\n                if gap_start_idx >= gap_end_idx:\n                    continue\n                \n                y_gap_segment = y[gap_start_idx:gap_end_idx]\n                \n                # Compute mean BOLD over the gap and its ratio to max BOLD\n                mean_y_gap = np.mean(y_gap_segment)\n                gap_ratios.append(mean_y_gap / y_max)\n        \n        if not gap_ratios:\n            S = 0.0\n        else:\n            S = max(gap_ratios)\n            \n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们来应对“逆问题”，即解卷积。在神经科学研究中，我们常常可以测量输入（刺激）和输出（神经信号），但系统本身的特性（即冲激响应）是未知的。这项高级练习将展示如何将卷积表示为一个线性系统，并利用正则化最小二乘法从含噪声的数据中估计未知的HRF，这是一种用于系统辨识的强大技术。",
            "id": "4149352",
            "problem": "考虑一个离散时间线性时不变系统，该系统用于模拟功能性磁共振成像中的血氧水平依赖 (BOLD) 测量值。设 $s[n]$ 表示已知的刺激序列，$h[k]$ 表示未知的脉冲响应（血流动力学响应函数），$y[n]$ 表示测得的 BOLD 信号。该系统遵循离散时间卷积关系\n$$\ny[n] = \\sum_{k=0}^{M-1} s[n-k]\\, h[k] + \\varepsilon[n],\n$$\n对于 $n = 0, 1, \\dots, N-1$，其中 $M$ 是 $h[k]$ 的支撑长度，$N$ 是时间点的数量，$\\varepsilon[n]$ 代表加性测量噪声。假设 $s[n]$ 和 $y[n]$ 已知，而 $h[k]$ 待估计。目标是通过正则化最小二乘法估计 $h[k]$，该方法根据一个线性算子对解进行惩罚。算法必须从第一性原理出发，通过构建卷积所蕴含的相应线性系统，并选择一个施加幅度控制或平滑性的二次惩罚项，而不依赖于题目陈述中提供的任何快捷公式。\n\n假设用于生成测试数据的真实脉冲响应 $h_{\\text{true}}[k]$ 是离散时间的双伽马血流动力学响应函数，以 $\\Delta t$ 秒的均匀间隔采样，对于 $k = 0, 1, \\dots, M-1$ 定义为\n$$\nh_{\\text{true}}[k] = \\alpha_1 \\frac{t_k^{p_1 - 1} e^{-t_k / b_1}}{b_1^{p_1}\\,\\Gamma(p_1)} - \\alpha_2 \\frac{t_k^{p_2 - 1} e^{-t_k / b_2}}{b_2^{p_2}\\,\\Gamma(p_2)},\n$$\n其中 $t_k = k\\,\\Delta t$，$\\Gamma(\\cdot)$ 是伽马函数，$\\alpha_1, \\alpha_2, p_1, p_2, b_1, b_2$ 是固定常数。将 $h_{\\text{true}}[k]$ 归一化，使其最大值等于 $1$（此归一化仅用于生成一致的测试数据）。待估计的未知 $h[k]$ 不假定被归一化。\n\n双伽马函数使用以下常数：\n- $\\alpha_1 = 1.0$, $\\alpha_2 = 0.5$,\n- $p_1 = 6$, $p_2 = 16$,\n- $b_1 = 1.0$, $b_2 = 1.0$,\n- 采样间隔 $\\Delta t = 1.0$ 秒。\n\n噪声 $\\varepsilon[n]$ 独立地从零均值高斯分布中抽取，其标准差在每个测试用例中指定。为保证可复现性，请使用指定的随机种子。\n\n正则化由线性算子 $L$ 定义，它可以是：\n- 用于幅度控制的单位算子：$L = I_M$（一个 $M \\times M$ 的单位矩阵），\n- 用于平滑性的一阶差分算子：$L \\in \\mathbb{R}^{(M-1)\\times M}$，其中对于 $i = 0, \\dots, M-2$，第 $i$ 行在第 $i$ 列的元素为 $-1$，在第 $i+1$ 列的元素为 $+1$，其余元素为零。\n\n对于每个测试用例，你的程序必须构建模型所蕴含的卷积设计，推导并求解正则化最小二乘问题以估计长度为 $M$ 的 $h[k]$，并报告 $h[k]$ 和 $h_{\\text{true}}[k]$ 之间的均方根误差：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{k=0}^{M-1} \\left(h[k] - h_{\\text{true}}[k]\\right)^2 }.\n$$\n所有输出均为无量纲。\n\n测试套件：\n1. 正常路径事件相关设计：\n   - $N = 120$，$M = 30$，$\\Delta t = 1.0$ 秒，\n   - 刺激事件位于索引 $\\{10, 30, 50, 70, 90, 110\\}$：在这些索引处 $s[n] = 1$，否则为 $0$，\n   - 噪声标准差 $\\sigma = 0.05$，\n   - 正则化参数 $\\lambda = 0.1$，\n   - 算子 $L = I_M$，\n   - 随机种子 $= 0$。\n\n2. 边界情况（无刺激）：\n   - $N = 120$，$M = 30$，$\\Delta t = 1.0$ 秒，\n   - 对所有 $n$，$s[n] = 0$，\n   - 噪声标准差 $\\sigma = 0.05$，\n   - 正则化参数 $\\lambda = 1.0$，\n   - 算子 $L = I_M$，\n   - 随机种子 $= 1$。\n\n3. 脉冲刺激：\n   - $N = 120$，$M = 30$，$\\Delta t = 1.0$ 秒，\n   - 在索引 $10$ 处有单个脉冲：$s[10] = 1$，否则 $s[n] = 0$，\n   - 噪声标准差 $\\sigma = 0.01$，\n   - 正则化参数 $\\lambda = 0.001$，\n   - 算子 $L = I_M$，\n   - 随机种子 $= 2$。\n\n4. 带平滑正则化的病态组块设计：\n   - $N = 200$，$M = 30$，$\\Delta t = 1.0$ 秒，\n   - 从 $n=0$ 开始，组块刺激以 $20$ 个开和 $20$ 个关交替（即，对于 $n \\in [0,19], [40,59], [80,99], [120,139], [160,179]$，$s[n] = 1$，否则 $s[n] = 0$），\n   - 噪声标准差 $\\sigma = 0.10$，\n   - 正则化参数 $\\lambda = 1.0$，\n   - 算子 $L$ 是一阶差分算子，\n   - 随机种子 $= 3$。\n\n实现要求：\n- 对于每个测试用例，构建离散卷积所蕴含的线性系统，使用指定的算子 $L$ 和参数 $\\lambda$ 建立正则化最小二乘目标函数，并求解 $h[k]$，过程中不得使用本题目陈述中提供的任何闭式解。\n- 计算估计值 $h[k]$ 和真实值 $h_{\\text{true}}[k]$ 之间的 $\\text{RMSE}$。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[0.123456,0.234567,0.345678,0.456789]”），其中每个值是一个测试用例的 $\\text{RMSE}$，格式化为恰好六位小数。",
            "solution": "用户提供了一个有效且适定的问题。该问题在科学上基于线性系统理论的原理及其在 fMRI 数据分析中的应用。所有参数和条件都已指定，从而可以得到唯一且可验证的解。\n\n问题的核心是在给定已知输入刺激 $s[n]$ 和带噪声的输出信号 $y[n]$ 的情况下，估计线性时不变 (LTI) 系统的未知脉冲响应 $h[k]$。这个过程称为反卷积。\n\n控制方程是离散时间卷积：\n$$\ny[n] = \\sum_{k=0}^{M-1} s[n-k]\\, h[k] + \\varepsilon[n]\n$$\n其中 $h[k]$ 是长度为 $M$ 的脉冲响应，$s[n]$ 是刺激序列，$y[n]$ 是在 $N$ 个时间点上测量的信号，$\\varepsilon[n]$ 是加性噪声。\n\n第一步是将此卷积运算重构为矩阵-向量乘积形式，以便于使用线性代数方法处理。我们定义向量 $\\mathbf{y} \\in \\mathbb{R}^{N}$、$\\mathbf{h} \\in \\mathbb{R}^{M}$ 和 $\\mathbf{\\varepsilon} \\in \\mathbb{R}^{N}$ 如下：\n$$\n\\mathbf{y} = \\begin{pmatrix} y[0] \\\\ y[1] \\\\ \\vdots \\\\ y[N-1] \\end{pmatrix}, \\quad\n\\mathbf{h} = \\begin{pmatrix} h[0] \\\\ h[1] \\\\ \\vdots \\\\ h[M-1] \\end{pmatrix}, \\quad\n\\mathbf{\\varepsilon} = \\begin{pmatrix} \\varepsilon[0] \\\\ \\varepsilon[1] \\\\ \\vdots \\\\ \\varepsilon[N-1] \\end{pmatrix}\n$$\n卷积可以表示为 $\\mathbf{y} = S\\mathbf{h} + \\mathbf{\\varepsilon}$，其中 $S$ 是一个 $N \\times M$ 的卷积矩阵，通常称为设计矩阵。$S$ 的元素由 $S_{nk} = s[n-k]$ 给出，假设当 $j0$ 时 $s[j]=0$。这种结构意味着 $S$ 的每一列都是刺激序列 $s[n]$ 的一个时移版本。\n\n估计 $\\mathbf{h}$ 的问题被构建为一个正则化最小二乘问题。我们旨在找到一个估计值 $\\hat{\\mathbf{h}}$，使其最小化成本函数 $J(\\mathbf{h})$。该函数平衡了数据保真项（模型拟合数据的程度）和正则化项（惩罚解的不良属性）。成本函数为：\n$$\nJ(\\mathbf{h}) = \\|S\\mathbf{h} - \\mathbf{y}\\|_2^2 + \\lambda \\|L\\mathbf{h}\\|_2^2\n$$\n此处，$\\| \\cdot \\|_2^2$ 表示欧几里得范数的平方。第一项 $\\|S\\mathbf{h} - \\mathbf{y}\\|_2^2$ 是残差平方和，用于衡量模型预测值 $S\\mathbf{h}$ 与观测数据 $\\mathbf{y}$ 之间的失配程度。第二项 $\\lambda \\|L\\mathbf{h}\\|_2^2$ 是惩罚项。标量 $\\lambda \\ge 0$ 是控制权衡的正则化参数，$L$ 是定义待惩罚属性的线性算子。\n\n为了找到 $J(\\mathbf{h})$ 的最小值，我们求其关于 $\\mathbf{h}$ 的梯度并令其为零。首先，我们展开成本函数：\n$$\nJ(\\mathbf{h}) = (S\\mathbf{h} - \\mathbf{y})^T(S\\mathbf{h} - \\mathbf{y}) + \\lambda (L\\mathbf{h})^T(L\\mathbf{h})\n$$\n$$\nJ(\\mathbf{h}) = (\\mathbf{h}^T S^T - \\mathbf{y}^T)(S\\mathbf{h} - \\mathbf{y}) + \\lambda \\mathbf{h}^T L^T L \\mathbf{h}\n$$\n$$\nJ(\\mathbf{h}) = \\mathbf{h}^T S^T S \\mathbf{h} - 2\\mathbf{h}^T S^T \\mathbf{y} + \\mathbf{y}^T \\mathbf{y} + \\lambda \\mathbf{h}^T L^T L \\mathbf{h}\n$$\n关于 $\\mathbf{h}$ 的梯度是：\n$$\n\\frac{\\partial J(\\mathbf{h})}{\\partial \\mathbf{h}} = 2S^T S \\mathbf{h} - 2S^T \\mathbf{y} + 2\\lambda L^T L \\mathbf{h}\n$$\n将梯度设为零向量，得到该正则化问题的正规方程：\n$$\n(S^T S + \\lambda L^T L) \\mathbf{h} = S^T \\mathbf{y}\n$$\n这是一个 $A\\mathbf{x}=\\mathbf{b}$ 形式的线性方程组，其中 $A = S^T S + \\lambda L^T L$，$b = S^T \\mathbf{y}$。求解该方程组即可得到所需的估计值 $\\hat{\\mathbf{h}}$。\n\n指定了两种形式的正则化算子 $L$：\n1.  $L = I_M$，$M \\times M$ 的单位矩阵。惩罚项变为 $\\lambda \\|\\mathbf{h}\\|_2^2$，该项惩罚 $\\mathbf{h}$ 中系数的幅度。这被称为 Tikhonov 正则化或岭回归。\n2.  $L$ 是 $(M-1) \\times M$ 的一阶差分算子。惩罚项变为 $\\lambda \\sum_{k=0}^{M-2}(h[k+1]-h[k])^2$，该项惩罚相邻系数之间的巨大差异，从而促进解的平滑性。\n\n对于每个测试用例，执行以下步骤：\n1.  使用提供的双伽马公式合成真实血流动力学响应函数 $h_{\\text{true}}[k]$ 并将其归一化。\n2.  根据测试用例的规范构建刺激序列 $s[n]$。\n3.  从 $s[n]$ 构建 $N \\times M$ 的设计矩阵 $S$。\n4.  “干净”的 BOLD 信号计算为 $\\mathbf{y}_{\\text{clean}} = S \\mathbf{h}_{\\text{true}}$。\n5.  添加标准差为 $\\sigma$ 的可复现、零均值高斯噪声 $\\mathbf{\\varepsilon}$，以创建测量信号 $\\mathbf{y} = \\mathbf{y}_{\\text{clean}} + \\mathbf{\\varepsilon}$。\n6.  构建相应的正则化算子矩阵 $L$。\n7.  构建矩阵 $A = S^T S + \\lambda L^T L$ 和向量 $\\mathbf{b} = S^T \\mathbf{y}$。\n8.  求解线性系统 $A\\hat{\\mathbf{h}} = \\mathbf{b}$ 以得到估计的脉冲响应 $\\hat{\\mathbf{h}}$。\n9.  最后，计算估计值与真实值之间的均方根误差 (RMSE)：\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M}\\sum_{k=0}^{M-1} \\left(\\hat{h}[k] - h_{\\text{true}}[k]\\right)^2 }\n$$\n这种基于原理的方法确保了即使在设计矩阵 $S$ 是病态或奇异的情况下也能得到稳健的解，正如所提供的测试用例所示。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Solves the regularized deconvolution problem for a set of test cases.\n    \"\"\"\n\n    test_cases = [\n        {'N': 120, 'M': 30, 'dt': 1.0, 'stim_spec': {10, 30, 50, 70, 90, 110},\n         'sigma': 0.05, 'lam': 0.1, 'L_type': 'identity', 'seed': 0},\n        {'N': 120, 'M': 30, 'dt': 1.0, 'stim_spec': set(),\n         'sigma': 0.05, 'lam': 1.0, 'L_type': 'identity', 'seed': 1},\n        {'N': 120, 'M': 30, 'dt': 1.0, 'stim_spec': {10},\n         'sigma': 0.01, 'lam': 0.001, 'L_type': 'identity', 'seed': 2},\n        {'N': 200, 'M': 30, 'dt': 1.0, 'stim_spec': 'block',\n         'sigma': 0.10, 'lam': 1.0, 'L_type': 'difference', 'seed': 3},\n    ]\n\n    results = []\n\n    def generate_h_true(M, dt):\n        \"\"\"Generates the ground-truth double-gamma HRF.\"\"\"\n        p1, p2 = 6, 16\n        b1, b2 = 1.0, 1.0\n        a1, a2 = 1.0, 0.5\n\n        t = np.arange(0, M * dt, dt)\n\n        # Gamma PDF-like function part\n        with np.errstate(divide='ignore', invalid='ignore'):\n            term1 = (t**(p1 - 1) * np.exp(-t / b1)) / (b1**p1 * gamma(p1))\n            term2 = (t**(p2 - 1) * np.exp(-t / b2)) / (b2**p2 * gamma(p2))\n        \n        term1[np.isnan(term1)] = 0\n        term2[np.isnan(term2)] = 0\n\n        h_unnormalized = a1 * term1 - a2 * term2\n        \n        # Normalize to have a maximum value of 1\n        max_val = np.max(h_unnormalized)\n        if max_val > 0:\n            h_true = h_unnormalized / max_val\n        else:\n            h_true = h_unnormalized # Avoid division by zero if all values are = 0\n        \n        return h_true\n\n    for case in test_cases:\n        N, M, dt, stim_spec, sigma, lam, L_type, seed = \\\n            case['N'], case['M'], case['dt'], case['stim_spec'], \\\n            case['sigma'], case['lam'], case['L_type'], case['seed']\n\n        # 1. Generate ground-truth HRF\n        h_true = generate_h_true(M, dt)\n\n        # 2. Construct stimulus sequence s[n]\n        s = np.zeros(N)\n        if stim_spec == 'block':\n            for i in range(N // 40):\n                start = i * 40\n                s[start:start+20] = 1\n        else: # set of indices\n            for idx in stim_spec:\n                if idx  N:\n                    s[idx] = 1\n        \n        # 3. Construct the design matrix S\n        S = np.zeros((N, M))\n        for k in range(M):\n            if N > k:\n                S[k:, k] = s[:N-k]\n\n        # 4. Generate the measured BOLD signal y[n]\n        rng = np.random.default_rng(seed)\n        noise = rng.normal(loc=0.0, scale=sigma, size=N)\n        y_clean = S @ h_true\n        y = y_clean + noise\n\n        # 5. Construct the regularization operator L\n        if L_type == 'identity':\n            L = np.eye(M)\n        elif L_type == 'difference':\n            L = np.zeros((M - 1, M))\n            for i in range(M - 1):\n                L[i, i] = -1\n                L[i, i+1] = 1\n        else:\n            raise ValueError(\"Unknown L_type\")\n\n        # 6. Formulate and solve the regularized least squares problem\n        # (S^T S + lambda * L^T L) h = S^T y\n        A = S.T @ S + lam * (L.T @ L)\n        b = S.T @ y\n        h_hat = np.linalg.solve(A, b)\n\n        # 7. Compute the RMSE\n        rmse = np.sqrt(np.mean((h_hat - h_true)**2))\n        results.append(f\"{rmse:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}