{
    "hands_on_practices": [
        {
            "introduction": "在计算神经科学中，复杂的生物过程常被建模为一系列更简单的处理阶段。通过将这些阶段表示为线性时不变（LTI）系统，我们可以通过对其各部分脉冲响应进行卷积来确定整个系统的行为。这个练习  提供了一个基础范例，要求你推导一个双室模型的脉冲响应，这对于理解突触滤波等现象如何塑造神经信号至关重要。",
            "id": "4149344",
            "problem": "一种简化的双室级联模型常用于神经科学数据分析中，以模拟树突膜和胞体膜对突触电流的滤波作用。考虑两个串联的因果线性时不变（LTI）一阶室。第一个室接收一个建模为狄拉克δ输入 $\\,\\delta(t)\\,$ 的刺激，其状态 $\\,x_{1}(t)\\,$ 遵循常微分方程 $\\,\\tau_{1}\\,\\frac{d x_{1}}{d t} + x_{1} = \\delta(t)\\,$，且初始条件为零。第二个室以 $\\,x_{1}(t)\\,$ 为输入，其状态 $\\,x_{2}(t)\\,$ 遵循 $\\,\\tau_{2}\\,\\frac{d x_{2}}{d t} + x_{2} = x_{1}(t)\\,$，且初始条件为零。此处 $\\,\\tau_{1}  0\\,$ 和 $\\,\\tau_{2}  0\\,$ 是室时间常数，$\\,\\delta(t)\\,$ 是具有通常分布性质的狄拉克δ函数。令 $\\,H(t)\\,$ 表示亥维赛阶跃函数。\n\n仅从LTI脉冲响应和级联系统卷积的核心定义出发，推导该级联的总脉冲响应 $\\,h(t)\\,$（即第二个室对其输入端的 $\\,\\delta(t)\\,$ 的响应输出），并以 $\\,\\tau_{1}\\,$、$\\,\\tau_{2}\\,$ 和 $\\,t\\,$ 表示为一个闭式解析表达式。然后，通过确定其因果性、曲线下的总面积、以及定性形状来解释所得的核函数，包括在 $\\,\\tau_{1} \\neq \\tau_{2}\\,$ 时其峰值的存在性和位置，以及当 $\\,\\tau_{1} \\to \\tau_{2}\\,$ 时的极限形式。\n\n将最终的核函数 $\\,h(t)\\,$ 表示为单一的解析表达式。将时间 $\\,t\\,$ 的单位视为秒，但不要在最终表达式中包含任何单位。无需进行四舍五入。",
            "solution": "问题陈述已经过验证，被认为是具有科学依据、良定、客观且自洽的。它描述了系统理论和计算神经科学中的一个标准模型，其任务是明确定义的数学推导和解释。该问题是有效的。\n\n该问题要求解一个由两个一阶因果LTI系统级联而成的总脉冲响应 $h(t)$。此类系统的核心原理是，总脉冲响应是各个独立脉冲响应的卷积。设 $h_1(t)$ 是第一个室的脉冲响应，$h_2(t)$ 是第二个室的脉冲响应。那么，系统的总响应 $h(t)$ 由以下卷积积分给出：\n$$h(t) = (h_1 * h_2)(t) = \\int_{-\\infty}^{\\infty} h_1(\\tau) h_2(t-\\tau) d\\tau$$\n\n首先，我们必须确定单个的脉冲响应 $h_1(t)$ 和 $h_2(t)$。\n\n第一个室由以狄拉克δ函数为输入的常微分方程（ODE）描述：\n$$\\tau_{1}\\,\\frac{d x_{1}}{d t} + x_{1} = \\delta(t)$$\n初始条件为零。根据定义，其脉冲响应 $h_1(t)$ 就是解 $x_1(t)$。我们可以使用拉普拉斯变换（用 $\\mathcal{L}\\{\\cdot\\}$ 表示）来求解。令 $X_1(s) = \\mathcal{L}\\{x_1(t)\\}$。\n$$\\mathcal{L}\\left\\{\\tau_{1}\\,\\frac{d x_{1}}{d t} + x_{1}\\right\\} = \\mathcal{L}\\{\\delta(t)\\}$$\n$$\\tau_1 (s X_1(s) - x_1(0^-)) + X_1(s) = 1$$\n给定零初始条件，$x_1(0^-) = 0$。\n$$X_1(s) (\\tau_1 s + 1) = 1$$\n$$X_1(s) = \\frac{1}{\\tau_1 s + 1} = \\frac{1/\\tau_1}{s + 1/\\tau_1}$$\n拉普拉斯逆变换给出脉冲响应 $h_1(t)$。包含亥维赛阶跃函数 $H(t)$ 是为了反映系统的因果性。\n$$h_1(t) = x_1(t) = \\mathcal{L}^{-1}\\{X_1(s)\\} = \\frac{1}{\\tau_1} \\exp\\left(-\\frac{t}{\\tau_1}\\right) H(t)$$\n\n第二个室的形式与第一个室相同，只是时间常数不同，为 $\\tau_2$。如果其输入为 $\\delta(t)$，则其脉冲响应 $h_2(t)$ 就是其输出。以此类推：\n$$h_2(t) = \\frac{1}{\\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) H(t)$$\n\n现在，我们计算卷积 $h(t) = (h_1 * h_2)(t)$。\n$$h(t) = \\int_{-\\infty}^{\\infty} \\left[\\frac{1}{\\tau_1} \\exp\\left(-\\frac{\\tau}{\\tau_1}\\right) H(\\tau)\\right] \\left[\\frac{1}{\\tau_2} \\exp\\left(-\\frac{t-\\tau}{\\tau_2}\\right) H(t-\\tau)\\right] d\\tau$$\n亥维赛函数之积 $H(\\tau)H(t-\\tau)$ 仅在 $\\tau \\ge 0$ 且 $t-\\tau \\ge 0$（即 $\\tau \\le t$）时非零。这意味着当 $t  0$ 时，积分为零，因此 $h(t) = 0$。当 $t \\ge 0$ 时，积分上下限变为 $0$ 到 $t$。\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\int_0^t \\exp\\left(-\\frac{\\tau}{\\tau_1}\\right) \\exp\\left(-\\frac{t-\\tau}{\\tau_2}\\right) d\\tau \\quad \\text{for } t \\ge 0$$\n我们可以将与积分变量 $\\tau$ 无关的项提取出来：\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\int_0^t \\exp\\left(-\\frac{\\tau}{\\tau_1} + \\frac{\\tau}{\\tau_2}\\right) d\\tau$$\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\int_0^t \\exp\\left(\\tau \\left(\\frac{1}{\\tau_2} - \\frac{1}{\\tau_1}\\right)\\right) d\\tau$$\n\n现在我们计算这个积分，分两种情况讨论。\n\n情况1：$\\tau_1 \\neq \\tau_2$。\n积分中的指数非零。令 $\\tau$ 的系数为 $k = \\frac{1}{\\tau_2} - \\frac{1}{\\tau_1} = \\frac{\\tau_1 - \\tau_2}{\\tau_1 \\tau_2}$。\n$$\\int_0^t \\exp(k\\tau) d\\tau = \\left[\\frac{1}{k} \\exp(k\\tau)\\right]_0^t = \\frac{1}{k} (\\exp(kt) - 1) = \\frac{\\tau_1 \\tau_2}{\\tau_1 - \\tau_2} \\left(\\exp\\left(t\\frac{\\tau_1-\\tau_2}{\\tau_1\\tau_2}\\right) - 1\\right)$$\n将此结果代回 $h(t)$ 的表达式中：\n$$h(t) = \\frac{1}{\\tau_1 \\tau_2} \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\left[ \\frac{\\tau_1 \\tau_2}{\\tau_1 - \\tau_2} \\left(\\exp\\left(\\frac{t}{\\tau_2} - \\frac{t}{\\tau_1}\\right) - 1\\right) \\right]$$\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\exp\\left(\\frac{t}{\\tau_2} - \\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right)$$\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) \\quad \\text{for } t \\ge 0$$\n结合 $t  0$ 的情况，完整的表达式是：\n$$h(t) = \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) H(t)$$\n\n情况2：当 $\\tau_1 \\to \\tau_2$ 时的极限形式。令 $\\tau_1 = \\tau_2 = \\tau$。\n情况1中 $h(t)$ 的表达式变为不定式 $0/0$。我们可以通过对分子和分母关于 $\\tau_1$ 求导，然后取极限 $\\tau_1 \\to \\tau_2$ 的方式，使用洛必达法则来求解极限。\n$$h(t) = \\lim_{\\tau_1 \\to \\tau_2} \\frac{\\frac{d}{d\\tau_1}\\left( \\exp\\left(-t/\\tau_1\\right) - \\exp\\left(-t/\\tau_2\\right) \\right)}{\\frac{d}{d\\tau_1}(\\tau_1 - \\tau_2)} H(t)$$\n$$\\frac{d}{d\\tau_1}\\left( \\exp\\left(-t/\\tau_1\\right) \\right) = \\exp\\left(-t/\\tau_1\\right) \\cdot \\left(\\frac{t}{\\tau_1^2}\\right)$$\n$$\\frac{d}{d\\tau_1}(\\tau_1 - \\tau_2) = 1$$\n取极限 $\\tau_1 \\to \\tau_2 = \\tau$：\n$$h(t) = \\frac{\\exp(-t/\\tau) \\cdot (t/\\tau^2)}{1} H(t) = \\frac{t}{\\tau^2} \\exp\\left(-\\frac{t}{\\tau}\\right) H(t)$$\n这个函数在神经科学中被称为alpha函数。\n\n现在，我们来解释在 $\\tau_1 \\neq \\tau_2$ 的一般情况下推导出的核函数 $h(t)$。\n\n因果性：亥维赛函数 $H(t)$ 的存在确保了对于所有 $t  0$，$h(t) = 0$。这意味着系统的输出不会先于其输入，这正是因果系统的定义。\n\n曲线下的总面积：这由 $h(t)$ 在所有时间上的积分给出。\n$$\\text{Area} = \\int_{-\\infty}^{\\infty} h(t) dt = \\int_0^{\\infty} \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) dt$$\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} \\left[ \\int_0^{\\infty} \\exp\\left(-\\frac{t}{\\tau_1}\\right) dt - \\int_0^{\\infty} \\exp\\left(-\\frac{t}{\\tau_2}\\right) dt \\right]$$\n使用标准积分 $\\int_0^\\infty \\exp(-at) dt = 1/a$（对于 $a0$）：\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} \\left[ \\left(-\\tau_1 \\exp\\left(-\\frac{t}{\\tau_1}\\right)\\right)_0^{\\infty} - \\left(-\\tau_2 \\exp\\left(-\\frac{t}{\\tau_2}\\right)\\right)_0^{\\infty} \\right]$$\n$$\\text{Area} = \\frac{1}{\\tau_1 - \\tau_2} [ (0 - (-\\tau_1)) - (0 - (-\\tau_2)) ] = \\frac{\\tau_1 - \\tau_2}{\\tau_1 - \\tau_2} = 1$$\n脉冲响应下的总面积为 $1$。\n\n定性形状和峰值位置（$\\tau_1 \\neq \\tau_2$）：函数 $h(t)$ 从 $h(0)=0$ 开始，上升到一个唯一的最大值，然后随着 $t \\to \\infty$ 指数衰减到 $0$。为了找到峰值时间 $t_{peak}$，我们将 $h(t)$ 的导数设为零。\n$$\\frac{dh}{dt} = \\frac{d}{dt} \\left[ \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) \\right] = 0$$\n$$\\frac{1}{\\tau_1 - \\tau_2} \\left( -\\frac{1}{\\tau_1}\\exp\\left(-\\frac{t}{\\tau_1}\\right) + \\frac{1}{\\tau_2}\\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) = 0$$\n$$\\frac{1}{\\tau_2}\\exp\\left(-\\frac{t}{\\tau_2}\\right) = \\frac{1}{\\tau_1}\\exp\\left(-\\frac{t}{\\tau_1}\\right)$$\n$$\\frac{\\tau_1}{\\tau_2} = \\frac{\\exp(-t/\\tau_2)}{\\exp(-t/\\tau_1)} = \\exp\\left(t\\left(\\frac{1}{\\tau_1} - \\frac{1}{\\tau_2}\\right)\\right)$$\n对两边取自然对数：\n$$\\ln\\left(\\frac{\\tau_1}{\\tau_2}\\right) = t \\left(\\frac{1}{\\tau_1} - \\frac{1}{\\tau_2}\\right) = t \\frac{\\tau_2 - \\tau_1}{\\tau_1 \\tau_2}$$\n解出 $t = t_{peak}$：\n$$t_{peak} = \\frac{\\tau_1 \\tau_2}{\\tau_2 - \\tau_1} \\ln\\left(\\frac{\\tau_1}{\\tau_2}\\right) = \\frac{\\tau_1 \\tau_2 (\\ln\\tau_1 - \\ln\\tau_2)}{\\tau_2 - \\tau_1} = \\frac{\\tau_1 \\tau_2 (\\ln\\tau_2 - \\ln\\tau_1)}{\\tau_1 - \\tau_2}$$\n对于 $\\tau_1, \\tau_2  0$ 且 $\\tau_1 \\neq \\tau_2$，这个时间总是正的。\n当 $\\tau_1 \\to \\tau_2 = \\tau$ 时，此表达式的极限为 $t_{peak}=\\tau$，这正是alpha函数的正确峰值时间。\n\n由此，级联的最终推导脉冲响应得到确认。",
            "answer": "$$\n\\boxed{ \\frac{1}{\\tau_1 - \\tau_2} \\left( \\exp\\left(-\\frac{t}{\\tau_1}\\right) - \\exp\\left(-\\frac{t}{\\tau_2}\\right) \\right) H(t) }\n$$"
        },
        {
            "introduction": "虽然线性卷积是 LTI 系统的正确数学模型，但大多数高效的计算算法（例如基于快速傅里叶变换 FFT 的算法）实际上实现的是循环卷积。这个练习  将引导你亲手对这两种运算进行计算比较，帮助你理解和量化那些若处理不当便会污染分析结果的“回卷”伪影。对于任何处理真实世界有限长度数据的研究者来说，掌握这一区别至关重要。",
            "id": "4149361",
            "problem": "神经科学数据分析中的一个核心操作是离散时间卷积，它将一个有限的神经活动序列和一个有限的突触脉冲响应核映射为一个突触后电流或滤波后的活动。为确保科学上的真实性和严谨性，我们从最基本的基础开始：离散线性卷积的定义以及作为周期性操作的离散循环卷积的定义。\n\n设 $x[n]$ 是一个长度为 $N$ 的有限序列，设 $h[n]$ 是一个长度为 $M$ 的有限序列。离散线性卷积 $y_{\\mathrm{lin}}[n]$ 定义为\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{r=-\\infty}^{\\infty} x[r]\\,h[n-r],\n$$\n其中约定，当 $r \\notin \\{0,1,\\dots,N-1\\}$ 时 $x[r]=0$，当 $\\ell \\notin \\{0,1,\\dots,M-1\\}$ 时 $h[\\ell]=0$，因此 $y_{\\mathrm{lin}}[n]$ 仅在 $n \\in \\{0,1,\\dots,N+M-2\\}$ 时非零。\n\n对于整数 $L \\ge 1$，$L$点离散循环卷积 $y_{\\mathrm{circ}}^{(L)}[n]$ 定义为\n$$\ny_{\\mathrm{circ}}^{(L)}[n] = \\sum_{r=0}^{L-1} x[r]\\,h\\big((n-r)\\bmod L\\big), \\quad n \\in \\{0,1,\\dots,L-1\\},\n$$\n其中 $x[r]$ 和 $h[\\ell]$ 被解释为其前 $L$ 个样本的 $L$ 周期性扩展。\n\n在计算神经科学中常用的基于快速傅里叶变换的实现中，如果在离散傅里叶变换域中通过乘法执行卷积而没有进行足够的零填充，那么实际实现的是 $L$点循环卷积，这在 $L  N+M-1$ 时会引入环绕失真。\n\n你的任务是：\n\n$1.$ 对于每个提供的测试用例，计算离散线性卷积 $y_{\\mathrm{lin}}$ 和 $L$点离散循环卷积 $y_{\\mathrm{circ}}^{(L)}$。\n\n$2.$ 对于每个测试用例，定义差异向量\n$$\nd^{(L)}[n] = y_{\\mathrm{lin}}[n] - y_{\\mathrm{circ}}^{(L)}[n], \\quad n \\in \\{0,1,\\dots,L-1\\},\n$$\n和环绕混叠向量\n$$\na^{(L)}[n] = \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n + qL],\n$$\n其中约定，当 $m \\notin \\{0,1,\\dots,N+M-2\\}$ 时 $y_{\\mathrm{lin}}[m]=0$，因此只有有限多项有贡献。通过数值验证\n$$\nd^{(L)}[n] = -\\,a^{(L)}[n]\n$$\n对所有 $n \\in \\{0,1,\\dots,L-1\\}$ 成立，将差异 $d^{(L)}$ 与环绕失真联系起来。\n\n$3.$ 通过计算欧几里得范数\n$$\n\\|d^{(L)}\\|_2 = \\left(\\sum_{n=0}^{L-1} \\big(d^{(L)}[n]\\big)^2\\right)^{1/2}\n$$\n和无穷范数\n$$\n\\|d^{(L)}\\|_{\\infty} = \\max_{0 \\le n \\le L-1} \\left|d^{(L)}[n]\\right|,\n$$\n量化每个测试用例中环绕失真的幅度，并列出 $|d^{(L)}[n]|$ 超过数值容差 $10^{-12}$ 的索引 $n$。\n\n使用以下测试套件，该套件旨在探查与神经科学信号处理工作流程相关的典型情况、边界条件和边缘情况：\n\n测试用例 1 （典型的有限脉冲序列与短突触核进行卷积；$L$ 太短，存在环绕失真）：\n$$\nx^{(1)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], \\quad h^{(1)} = [0.0, 0.7, 0.5, 0.3, 0.1], \\quad L^{(1)} = 12.\n$$\n\n测试用例 2 （相同输入，但选择的 $L$ 通过零填充至完整线性长度来避免环绕失真）：\n$$\nx^{(2)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], \\quad h^{(2)} = [0.0, 0.7, 0.5, 0.3, 0.1], \\quad L^{(2)} = 16.\n$$\n\n测试用例 3 （相同输入，但更小的 $L$ 增加了混叠的严重性）：\n$$\nx^{(3)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], \\quad h^{(3)} = [0.0, 0.7, 0.5, 0.3, 0.1], \\quad L^{(3)} = 8.\n$$\n\n测试用例 4 （零信号的边缘情况，此时线性和循环卷积都恒等于零）：\n$$\nx^{(4)} = [0, 0, 0, 0, 0, 0, 0], \\quad h^{(4)} = [0.2, 0.5, 0.2, 0.1], \\quad L^{(4)} = 7.\n$$\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，你的程序必须输出一个列表，其中包含：\n$[$在 $10^{-12}$ 容差范围内对 $d^{(L)}$ 和 $-a^{(L)}$ 的布尔等价性检查，$\\|d^{(L)}\\|_2$，$\\|d^{(L)}\\|_{\\infty}$，以及满足 $|d^{(L)}[n]|  10^{-12}$ 的索引 $n$ 的列表$]$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身也是一个按上述顺序排列的列表，例如 $[\\text{result}^{(1)},\\text{result}^{(2)},\\text{result}^{(3)},\\text{result}^{(4)}]$。不应打印任何单位或文本注释，所有数值都应为十进制数。",
            "solution": "用户在数字信号处理领域提供了一个定义明确的问题，具体涉及线性和循环离散时间卷积之间的关系，这是计算神经科学和其他依赖时间序列分析的领域中的一个基础概念。\n\n### 步骤 1：提取已知信息\n- **序列**：一个长度为 $N$ 的有限神经活动序列 $x[n]$，以及一个长度为 $M$ 的有限突触脉冲响应核 $h[n]$。\n- **线性卷积**：离散线性卷积 $y_{\\mathrm{lin}}[n]$ 定义为 $y_{\\mathrm{lin}}[n] = \\sum_{r=-\\infty}^{\\infty} x[r]\\,h[n-r]$。结果序列的长度为 $N+M-1$，在 $n \\in \\{0, 1, \\dots, N+M-2\\}$ 范围内非零。\n- **循环卷积**：对于整数 $L \\ge 1$，$L$点离散循环卷积 $y_{\\mathrm{circ}}^{(L)}[n]$ 定义为 $y_{\\mathrm{circ}}^{(L)}[n] = \\sum_{r=0}^{L-1} x[r]\\,h\\big((n-r)\\bmod L\\big)$，其中 $n \\in \\{0, 1, \\dots, L-1\\}$，使用 $x$ 和 $h$ 的前 $L$ 个样本的 $L$ 周期性扩展。\n- **差异向量**：$d^{(L)}[n] = y_{\\mathrm{lin}}[n] - y_{\\mathrm{circ}}^{(L)}[n]$，其中 $n \\in \\{0, 1, \\dots, L-1\\}$。\n- **环绕混叠向量**：$a^{(L)}[n] = \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n + qL]$。\n- **验证任务**：数值验证对于所有 $n \\in \\{0, 1, \\dots, L-1\\}$，$d^{(L)}[n] = -a^{(L)}[n]$ 成立。\n- **量化任务**：计算欧几里得范数 $\\|d^{(L)}\\|_2 = \\left(\\sum_{n=0}^{L-1} (d^{(L)}[n])^2\\right)^{1/2}$ 和无穷范数 $\\|d^{(L)}\\|_{\\infty} = \\max_{0 \\le n \\le L-1} |d^{(L)}[n]|$。\n- **索引识别任务**：列出满足 $|d^{(L)}[n]|  10^{-12}$ 的索引 $n$。\n- **测试用例**：\n    1.  $x^{(1)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1]$, $h^{(1)} = [0.0, 0.7, 0.5, 0.3, 0.1]$, $L^{(1)} = 12$。\n    2.  $x^{(2)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1]$, $h^{(2)} = [0.0, 0.7, 0.5, 0.3, 0.1]$, $L^{(2)} = 16$。\n    3.  $x^{(3)} = [0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1]$, $h^{(3)} = [0.0, 0.7, 0.5, 0.3, 0.1]$, $L^{(3)} = 8$。\n    4.  $x^{(4)} = [0, 0, 0, 0, 0, 0, 0]$, $h^{(4)} = [0.2, 0.5, 0.2, 0.1]$, $L^{(4)} = 7$。\n- **数值容差**：$10^{-12}$。\n- **输出格式**：对于每个用例，输出一个列表，包含等价性检查的布尔值、$\\|d^{(L)}\\|_2$、$\\|d^{(L)}\\|_{\\infty}$ 以及索引列表。最终输出是这些列表的列表。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学依据**：该问题从根本上基于线性和循环卷积的定义及其关系，这些是数字信号处理中核心且完善的原理。神经科学的应用背景是恰当且现实的。\n- **良构性**：该问题是完全自洽的。所有必要的定义、公式、数据和任务都已明确提供。对于每个测试用例，输入都已指定，所需的计算将导出一个唯一的、明确定义的数值结果。\n- **客观性**：问题陈述使用精确的数学语言编写，没有歧义或主观论断。\n\n该问题通过了所有验证标准。这是一个有效、良构且具有科学合理性的问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n需要展示的核心原理是，$L$点循环卷积在数学上等同于相应线性卷积的时间混叠版本。具体来说，循环卷积 $y_{\\mathrm{circ}}^{(L)}[n]$ 可以用线性卷积 $y_{\\mathrm{lin}}[n]$ 表示为：\n$$\ny_{\\mathrm{circ}}^{(L)}[n] = \\sum_{q=-\\infty}^{\\infty} y_{\\mathrm{lin}}[n+qL]\n$$\n由于序列 $y_{\\mathrm{lin}}[n]$ 是因果的且具有 $N+M-1$ 的有限长度，这个无穷和可以简化。当 $q  0$ 时（因为 $n \\ge 0$ 且 $y_{\\mathrm{lin}}$ 在负索引处为零），以及当 $q$ 足够大以致于 $n+qL \\ge N+M-1$ 时，项 $y_{\\mathrm{lin}}[n+qL]$ 为零。因此，该和变为：\n$$\ny_{\\mathrm{circ}}^{(L)}[n] = \\sum_{q=0}^{\\infty} y_{\\mathrm{lin}}[n+qL] = y_{\\mathrm{lin}}[n] + \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n+qL]\n$$\n问题将差异向量定义为 $d^{(L)}[n] = y_{\\mathrm{lin}}[n] - y_{\\mathrm{circ}}^{(L)}[n]$，将环绕混叠向量定义为 $a^{(L)}[n] = \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n+qL]$。将 $y_{\\mathrm{circ}}^{(L)}[n]$ 的表达式代入 $d^{(L)}[n]$ 的定义中，我们得到：\n$$\nd^{(L)}[n] = y_{\\mathrm{lin}}[n] - \\left( y_{\\mathrm{lin}}[n] + \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n+qL] \\right) = - \\sum_{q=1}^{\\infty} y_{\\mathrm{lin}}[n+qL] = -a^{(L)}[n]\n$$\n我们的任务是数值化地实现这一验证，并为指定的测试用例量化由此产生的差异。由 $\\|d^{(L)}\\|_2$ 和 $\\|d^{(L)}\\|_{\\infty}$ 量化的差异大小是环绕失真的直接度量。这种失真为零当且仅当 $L \\ge N+M-1$，这对应于为频域卷积方法提供足够的零填充以正确复现线性卷积。\n\n对每个测试用例 $(x, h, L)$ 的实现将按以下步骤进行：\n1.  **计算线性卷积**：将使用线性卷积的定义计算序列 $y_{\\mathrm{lin}}$。其长度为 $N+M-1$，其中 $N=\\text{length}(x)$，$M=\\text{length}(h)$。\n2.  **计算循环卷积**：将直接根据其求和定义计算序列 $y_{\\mathrm{circ}}^{(L)}$。这涉及使用 $x$ 和 $h$ 的前 $L$ 个样本（如果其原始长度小于 $L$ 则进行零填充）并对核索引执行模运算。\n3.  **计算差异**：通过从 $y_{\\mathrm{lin}}$ 的前 $L$ 个样本中减去 $y_{\\mathrm{circ}}^{(L)}$ 来找到向量 $d^{(L)}$。必须注意处理 $y_{\\mathrm{lin}}$ 长度小于 $L$ 的情况。\n4.  **计算混叠向量**：根据其定义，通过对 $y_{\\mathrm{lin}}$ 序列的时间混叠“尾部”求和来计算向量 $a^{(L)}$。\n5.  **验证和量化**：使用 $10^{-12}$ 的数值容差检查等式 $d^{(L)} = -a^{(L)}$。计算 $d^{(L)}$ 所需的范数，并识别出显著差异的索引。\n\n此过程将应用于所有四个测试用例，这些用例旨在探查 $L  N+M-1$（混叠）、$L \\ge N+M-1$（无混叠）、$L \\ll N+M-1$（严重混叠）以及零输入信号的平凡情况下的行为。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], dtype=np.float64),\n         np.array([0.0, 0.7, 0.5, 0.3, 0.1], dtype=np.float64),\n         12),\n        (np.array([0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], dtype=np.float64),\n         np.array([0.0, 0.7, 0.5, 0.3, 0.1], dtype=np.float64),\n         16),\n        (np.array([0, 1, 0, 2, 0, 1, 0, 0, 3, 0, 0, 1], dtype=np.float64),\n         np.array([0.0, 0.7, 0.5, 0.3, 0.1], dtype=np.float64),\n         8),\n        (np.array([0, 0, 0, 0, 0, 0, 0], dtype=np.float64),\n         np.array([0.2, 0.5, 0.2, 0.1], dtype=np.float64),\n         7),\n    ]\n\n    results = []\n    for x, h, L in test_cases:\n        result = process_case(x, h, L)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The str() representation of a list is standard and sufficient.\n    # e.g., str([True, 1.23, [0, 1]]) - '[True, 1.23, [0, 1]]'\n    final_output = f\"[{','.join(map(str, results))}]\"\n    print(final_output)\n\ndef process_case(x, h, L):\n    \"\"\"\n    Performs all computations for a single test case.\n    \n    Args:\n        x (np.ndarray): The input signal sequence.\n        h (np.ndarray): The kernel sequence.\n        L (int): The length for circular convolution.\n        \n    Returns:\n        list: A list containing [equality_check, norm2, norm_inf, indices].\n    \"\"\"\n    N = len(x)\n    M = len(h)\n    tolerance = 1e-12\n\n    # 1. Compute discrete linear convolution y_lin\n    y_lin = np.convolve(x, h)\n    \n    # 2. Compute L-point discrete circular convolution y_circ_L\n    # Prepare L-length versions of x and h by zero-padding or truncating\n    x_L = np.zeros(L, dtype=np.float64)\n    h_L = np.zeros(L, dtype=np.float64)\n    n_x_copy = min(N, L)\n    n_h_copy = min(M, L)\n    x_L[:n_x_copy] = x[:n_x_copy]\n    h_L[:n_h_copy] = h[:n_h_copy]\n\n    y_circ_L = np.zeros(L, dtype=np.float64)\n    for n in range(L):\n        for r in range(L):\n            y_circ_L[n] += x_L[r] * h_L[(n - r) % L]\n\n    # 3. Compute the discrepancy vector d_L\n    # d_L[n] = y_lin[n] - y_circ_L[n] for n in {0, ..., L-1}\n    # We must pad y_lin if its length is less than L\n    y_lin_prefix = np.zeros(L, dtype=np.float64)\n    copy_len = min(len(y_lin), L)\n    y_lin_prefix[:copy_len] = y_lin[:copy_len]\n    d_L = y_lin_prefix - y_circ_L\n\n    # 4. Compute the wrap-around alias vector a_L\n    # a_L[n] = sum_{q=1 to inf} y_lin[n + qL]\n    a_L = np.zeros(L, dtype=np.float64)\n    len_y_lin = len(y_lin)\n    if len_y_lin > L:\n        for n in range(L):\n            for q in range(1, (len_y_lin // L) + 2):\n                idx = n + q * L\n                if idx  len_y_lin:\n                    a_L[n] += y_lin[idx]\n                else:\n                    break\n    \n    # 5. Verify the relationship d_L = -a_L\n    is_equal = np.allclose(d_L, -a_L, rtol=0, atol=tolerance)\n\n    # 6. Quantify the magnitude of wrap-around artifacts\n    norm2 = np.linalg.norm(d_L, ord=2)\n    norm_inf = np.linalg.norm(d_L, ord=np.inf)\n\n    # 7. List indices n where |d_L[n]| exceeds tolerance\n    significant_indices = np.where(np.abs(d_L) > tolerance)[0].tolist()\n\n    return [is_equal, norm2, norm_inf, significant_indices]\n\nsolve()\n```"
        },
        {
            "introduction": "卷积是功能性磁共振成像（fMRI）数据分析的核心，它作为前向模型，将神经活动与测得的血氧水平依赖（BOLD）信号联系起来。在这个练习  中，你将通过将预定义的神经活动模式与经典的血液动力学响应函数（HRF）进行卷积来预测最终的 BOLD 时间序列，从而模拟这一过程。此实践具体展示了卷积如何帮助我们检验关于大脑功能的假设，并理解神经血管耦合的时间动态。",
            "id": "4149331",
            "problem": "在线性系统框架内，您将获得一个功能性磁共振成像 (fMRI) 中血氧水平依赖 (BOLD) 信号生成的离散时间模型。\n\n神经血管耦合将被建模为一个线性时不变 (LTI) 系统：该系统完全由其脉冲响应来表征，且任何输入的输出都通过缩放、时移的脉冲响应的叠加来确定。输入是分块设计的神经活动信号，输出是预测的 BOLD 信号。时间必须以秒为单位表示。\n\n将经典血液动力学响应函数 (HRF) $h(t)$ 定义为两个伽马函数之差，其参数选择为生理上合理的。对于 $t \\ge 0$，令\n$$\nh(t) = \\frac{t^{a_1-1} e^{-t/b_1}}{b_1^{a_1}\\,\\Gamma(a_1)} \\;-\\; c \\,\\frac{t^{a_2-1} e^{-t/b_2}}{b_2^{a_2}\\,\\Gamma(a_2)},\n$$\n参数为 $a_1 = 6$，$b_1 = 1$，$a_2 = 12$，$b_2 = 1$ 以及 $c = 0.35$。对于 $t  0$，设 $h(t) = 0$。通过除以 $h(t)$ 在 $t \\in [0, t_{\\max}]$ 上的积分，将其归一化至单位面积，其中 $t_{\\max} = 32\\,\\mathrm{s}$。\n\n分块设计的神经活动 $n(t)$ 被定义为一个分段常数函数，在预设的刺激块期间取值为 $A$，在其他时间取值为 $0$。对于一个起始时间为 $s$、持续时间为 $D$ 的块，$n(t) = A$ 当 $t \\in [s, s + D)$ 时成立，否则 $n(t) = 0$。在本问题的所有情况中，假设 $A = 1$。\n\n预测的 BOLD 信号 $y(t)$ 是 LTI 系统对输入 $n(t)$ 的输出。您必须使用与 LTI 定义一致的离散时间近似，在均匀离散时间网格上计算 $y(t)$。使用采样间隔 $\\Delta t = 0.1\\,\\mathrm{s}$。对于数值卷积，在给定网格上实现连续时间操作的黎曼和近似，并确保通过 $\\Delta t$ 进行正确的缩放。\n\n为分析跨块的 $h(t)$ 重叠如何导致持续响应，为给定的块调度定义“持续指数”$S$ 如下。设块起始时间的集合为 $\\{s_i\\}$，其共同持续时间为 $D$。对于每个满足 $s_{i+1}  s_i + D$ 的连续对 $(s_i, s_{i+1})$，定义块间间隙区间 $G_i = [s_i + D, s_{i+1})$，在此区间上 $n(t) = 0$。计算每个间隙区间上预测的 BOLD 信号的均值，\n$$\n\\overline{y}(G_i) \\;=\\; \\frac{1}{|G_i|} \\int_{G_i} y(t)\\, dt,\n$$\n其中 $|G_i|$ 是间隙区间的持续时间（以秒为单位）。令 $y_{\\max} = \\max_{t} y(t)$ 为整个分析窗口内的最大值。持续指数为\n$$\nS \\;=\\; \\begin{cases}\n\\displaystyle \\max_i \\left( \\frac{\\overline{y}(G_i)}{y_{\\max}} \\right),  \\text{如果存在至少一个间隙区间 } G_i, \\\\\n0,  \\text{如果没有间隙区间。}\n\\end{cases}\n$$\n持续指数 $S$ 是一个在 $[0,1]$ 范围内的无量纲小数，它量化了由于 $h(t)$ 的重叠导致 BOLD 信号在块之间保持升高的程度。\n\n实现一个程序，该程序：\n- 在 $[0, t_{\\max}]$ 上构建 $h(t)$，将其归一化至单位面积，并为每个测试用例在 $[0, T_{\\text{total}}]$ 上构建 $n(t)$。\n- 通过与 LTI 框架和黎曼和近似一致的离散时间卷积计算预测的 BOLD 信号 $y(t)$。\n- 为每个测试用例计算如上定义的持续指数 $S$。\n\n所有时间值均以秒表示。所有返回的数值必须是浮点数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[result1,result2,result3]”）。\n\n使用以下测试套件，其中每个测试用例都由块起始时间、共同块持续时间和总分析窗口完全指定：\n1. 正常路径案例，单个块，无间隙：起始时间 $\\{20\\}$，持续时间 $D = 20\\,\\mathrm{s}$，总时间 $T_{\\text{total}} = 100\\,\\mathrm{s}$。\n2. 边界案例，两个块的间隔远超 HRF 的支撑范围：起始时间 $\\{10, 90\\}$，持续时间 $D = 10\\,\\mathrm{s}$，总时间 $T_{\\text{total}} = 150\\,\\mathrm{s}$。\n3. 重叠案例，两个块的间隙短于 HRF 的尾部：起始时间 $\\{10, 25\\}$，持续时间 $D = 15\\,\\mathrm{s}$，总时间 $T_{\\text{total}} = 90\\,\\mathrm{s}$。\n4. 高重叠边缘案例，包含许多短块和小的刺激间间隔：起始时间 $\\{0, 8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112\\}$，持续时间 $D = 6\\,\\mathrm{s}$，总时间 $T_{\\text{total}} = 120\\,\\mathrm{s}$。\n\n您的程序必须按照上面列出的顺序为每个测试用例输出持续指数 $S$，格式为单行“[S1,S2,S3,S4]”。",
            "solution": "该问题被验证为具有科学依据、定义明确且客观。所有定义和参数都足以构建一个唯一、可计算的解决方案。分析过程通过实现指定的模型和指标来进行。\n\n解决方案分为四个主要步骤：\n1.  构建归一化的血液动力学响应函数 (HRF)。\n2.  为每个测试用例生成分块设计的神经活动信号。\n3.  通过离散卷积计算预测的血氧水平依赖 (BOLD) 信号。\n4.  根据得到的 BOLD 信号计算持续指数 $S$。\n\n### 步骤 1：血液动力学响应函数 (HRF) 的构建\n\n经典 HRF，记为 $h(t)$，模拟了血管对短暂、脉冲式神经事件的响应。它被定义为两个伽马函数之差，对于 $t \\ge 0$：\n$$\nh(t) = \\frac{t^{a_1-1} e^{-t/b_1}}{b_1^{a_1}\\,\\Gamma(a_1)} \\;-\\; c \\,\\frac{t^{a_2-1} e^{-t/b_2}}{b_2^{a_2}\\,\\Gamma(a_2)}\n$$\n其中 $\\Gamma(\\cdot)$ 是标准伽马函数。给定的参数为 $a_1 = 6$，$b_1 = 1$，$a_2 = 12$，$b_2 = 1$ 以及 $c = 0.35$。对于 $t  0$，$h(t) = 0$。\n\n此函数在从 $t=0$ 到 $t_{\\max} = 32\\,\\mathrm{s}$ 的时间网格上进行离散化，采样间隔为 $\\Delta t = 0.1\\,\\mathrm{s}$。设这个离散序列为 $h[k] = h(k \\Delta t)$。\n\n问题要求将 $h(t)$ 归一化，使其在区间 $[0, t_{\\max}]$ 上的面积为1。该积分使用离散网格上的黎曼和进行近似：\n$$\nI = \\int_{0}^{t_{\\max}} h(t) \\,dt \\approx \\sum_{k=0}^{N_{\\text{hrf}}-1} h(t_k) \\Delta t\n$$\n其中 $t_k = k \\Delta t$ 且 $N_{\\text{hrf}}$ 是 HRF 时间向量中的点数。归一化后的 HRF，$h_{\\text{norm}}(t)$，则为：\n$$\nh_{\\text{norm}}(t) = \\frac{h(t)}{I}\n$$\n离散的归一化序列是 $h_{\\text{norm}}[k] = h[k] / I$。\n\n### 步骤 2：神经活动信号的构建\n\n系统的输入，即神经活动 $n(t)$，被建模为分块设计。它是一个分段常数函数，在指定的刺激块期间等于振幅 $A=1$，在其他时间等于 $0$。对于给定的起始时间集合 $\\{s_i\\}$ 和共同的持续时间 $D$，信号定义为：\n$$\nn(t) = \\begin{cases} 1  \\text{if } t \\in [s_i, s_i + D) \\text{ for some } i \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n对于每个测试用例，我们在总分析窗口 $[0, T_{\\text{total}}]$ 上构建一个离散信号 $n[k] = n(k \\Delta t)$。\n\n### 步骤 3：通过卷积计算 BOLD 信号\n\n预测的 BOLD 信号 $y(t)$ 是线性时不变 (LTI) 系统的输出，它由输入信号 $n(t)$ 与系统的脉冲响应 $h_{\\text{norm}}(t)$ 的卷积给出：\n$$\ny(t) = (n * h_{\\text{norm}})(t) = \\int_{-\\infty}^{\\infty} n(\\tau) h_{\\text{norm}}(t - \\tau) \\,d\\tau\n$$\n问题指定使用与黎曼和一致的离散时间近似来计算。离散卷积为：\n$$\ny[k] = y(t_k) \\approx \\sum_{j} n(\\tau_j) h_{\\text{norm}}(t_k - \\tau_j) \\Delta \\tau\n$$\n其中 $t_k = k\\Delta t$，$\\tau_j = j\\Delta t$，以及 $\\Delta \\tau = \\Delta t$。这对应于对序列 $n[k]$ 和 $h_{\\text{norm}}[k]$ 执行标准离散卷积，然后将结果乘以 $\\Delta t$：\n$$\ny[k] = \\Delta t \\cdot \\sum_{j=0}^{M-1} n[j] h_{\\text{norm}}[k-j]\n$$\n其中 $M$ 是信号 $n[k]$ 的长度。对每个测试用例都执行此操作。卷积的输出被截断以匹配输入信号 $n[k]$ 的长度。\n\n### 步骤 4：持续指数的计算\n\n持续指数 $S$ 量化了刺激块之间间隙中 BOLD 信号的升高程度。\n首先，在整个分析窗口内确定 BOLD 信号的全局最大值 $y_{\\max} = \\max_k y[k]$。\n\n接下来，我们识别所有块间间隙区间。对于每一对具有共同持续时间 $D$ 的连续起始时间 $(s_i, s_{i+1})$，如果 $s_{i+1}  s_i + D$，则存在一个间隙区间 $G_i$。该区间定义为 $G_i = [s_i + D, s_{i+1})$。\n\n对于每个这样的间隙 $G_i$，计算平均 BOLD 信号。其连续定义为：\n$$\n\\overline{y}(G_i) \\;=\\; \\frac{1}{|G_i|} \\int_{G_i} y(t)\\, dt,\n$$\n其中 $|G_i| = s_{i+1} - (s_i+D)$ 是间隙的持续时间。其离散近似是间隙区间内 BOLD 信号样本的算术平均值：\n$$\n\\overline{y}(G_i) \\approx \\frac{1}{N_{G_i}} \\sum_{t_k \\in G_i} y[k]\n$$\n其中 $N_{G_i}$ 是间隙区间 $G_i$ 中的时间点数。\n\n为每个间隙计算一个比率 $r_i = \\overline{y}(G_i) / y_{\\max}$。持续指数 $S$ 是所有间隙中这些比率的最大值。如果不存在这样的间隙（例如，单个块或连续的块），则 $S$ 定义为 $0$。\n$$\nS \\;=\\; \\begin{cases}\n\\displaystyle \\max_i (r_i),  \\text{如果存在至少一个间隙区间 } G_i, \\\\\n0,  \\text{如果没有间隙区间。}\n\\end{cases}\n$$\n将此程序应用于问题陈述中指定的四个测试用例中的每一个，以获得最终结果。\n\n对于案例1（单个块）和案例3（其中 $s_{i+1} = s_i+D$ 的连续块），条件 $s_{i+1}  s_i+D$ 不满足。因此，不存在间隙区间，根据定义，这两种情况的持续指数 $S$ 均为 $0$。对于案例2和案例4，存在间隙区间，$S$ 按上述最大比率计算。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Solves the BOLD signal modeling problem by computing the sustained index\n    for several block-design experiments.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\"onsets\": [20.0], \"D\": 20.0, \"T_total\": 100.0},\n        {\"onsets\": [10.0, 90.0], \"D\": 10.0, \"T_total\": 150.0},\n        {\"onsets\": [10.0, 25.0], \"D\": 15.0, \"T_total\": 90.0},\n        {\"onsets\": [0.0, 8.0, 16.0, 24.0, 32.0, 40.0, 48.0, 56.0, 64.0, 72.0, 80.0, 88.0, 96.0, 104.0, 112.0], \"D\": 6.0, \"T_total\": 120.0}\n    ]\n\n    results = []\n    \n    # Global parameters\n    delta_t = 0.1\n    t_max_hrf = 32.0\n    a1, b1, a2, b2, c = 6.0, 1.0, 12.0, 1.0, 0.35\n    A = 1.0\n\n    # 1. Construct and normalize the Hemodynamic Response Function (HRF)\n    \n    def gamma_pdf_term(t, a, b):\n        \"\"\"\n        Computes the unscaled gamma PDF term.\n        Note: t must be a numpy array. a-1 > 0 is assumed.\n        \"\"\"\n        # The expression t**(a-1) is numerically safe for t=0 since a>1.\n        numerator = t**(a-1) * np.exp(-t/b)\n        denominator = b**a * gamma(a)\n        # Handle division by zero just in case, though not expected here.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            term = np.true_divide(numerator, denominator)\n        term[denominator == 0] = 0.0 # defensive\n        return term\n\n    t_hrf = np.arange(0, t_max_hrf + delta_t / 2, delta_t)\n    \n    h_unnormalized = gamma_pdf_term(t_hrf, a1, b1) - c * gamma_pdf_term(t_hrf, a2, b2)\n    \n    integral_h = np.sum(h_unnormalized) * delta_t\n    h_norm = h_unnormalized / integral_h\n\n    # Process each test case\n    for case in test_cases:\n        onsets = case[\"onsets\"]\n        D = case[\"D\"]\n        T_total = case[\"T_total\"]\n\n        # 2. Construct the neural activity signal n(t)\n        num_points = int(round(T_total / delta_t)) + 1\n        t_vec = np.linspace(0, T_total, num_points)\n        n = np.zeros_like(t_vec)\n\n        for s in onsets:\n            start_idx = int(round(s / delta_t))\n            # The interval is [s, s+D), so the end index is exclusive.\n            end_idx = int(round((s + D) / delta_t))\n            n[start_idx:end_idx] = A\n            \n        # 3. Compute predicted BOLD signal y(t) via discrete convolution\n        y = np.convolve(n, h_norm, mode='full')\n        # Truncate to original signal length and scale by delta_t for Riemann sum\n        y = y[:len(n)] * delta_t\n        \n        # 4. Compute the sustained index S\n        y_max = np.max(y)\n        \n        # If no activity, y_max can be 0. Avoid division by zero.\n        if y_max == 0:\n            S = 0.0\n            results.append(S)\n            continue\n            \n        # According to the definition, S=0 if there are no gaps.\n        # This occurs if there is only one block or no blocks.\n        if len(onsets) = 1:\n            S = 0.0\n            results.append(S)\n            continue\n            \n        gap_ratios = []\n        for i in range(len(onsets) - 1):\n            s_i = onsets[i]\n            s_i_plus_1 = onsets[i+1]\n\n            # A gap interval exists only if s_{i+1} > s_i + D\n            if s_i_plus_1 > s_i + D:\n                gap_start_t = s_i + D\n                gap_end_t = s_i_plus_1\n                \n                gap_start_idx = int(round(gap_start_t / delta_t))\n                gap_end_idx = int(round(gap_end_t / delta_t))\n                \n                # Ensure the indices define a non-empty slice\n                if gap_start_idx >= gap_end_idx:\n                    continue\n                \n                y_gap_segment = y[gap_start_idx:gap_end_idx]\n                \n                # Compute mean BOLD over the gap and its ratio to max BOLD\n                mean_y_gap = np.mean(y_gap_segment)\n                gap_ratios.append(mean_y_gap / y_max)\n        \n        if not gap_ratios:\n            S = 0.0\n        else:\n            S = max(gap_ratios)\n            \n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}