{
    "hands_on_practices": [
        {
            "introduction": "Before we can fully appreciate the computational advantages offered by the Convolution Theorem, it is essential to have a concrete understanding of the convolution operation itself. This first practice provides a foundational exercise in calculating a discrete convolution directly in the time domain. By manually computing the output of convolving two simple, finite sequences, you will build a strong intuition for the \"flip-and-slide\" mechanism that underlies this fundamental signal processing operation. ",
            "id": "26438",
            "problem": "In digital signal processing and mathematics, the discrete convolution is a fundamental operation that combines two sequences to produce a third sequence. For two finite, discrete-time sequences $x[n]$ and $h[n]$, their convolution, denoted by $y[n] = (x * h)[n]$, is defined by the sum:\n\n$$y[n] = \\sum_{k=-\\infty}^{\\infty} x[k]h[n-k]$$\n\nHere, $n$ and $k$ are integer indices. For finite sequences, we assume the values are zero outside of their specified range.\n\nConsider the two finite sequences:\n1. $x[n]$, which is non-zero only for $n=0, 1, 2$, with values $x[0]=1$, $x[1]=2$, and $x[2]=1$.\n2. $h[n]$, which is non-zero only for $n=0, 1, 2$, with values $h[0]=1$, $h[1]=0$, and $h[2]=-1$.\n\nThese sequences can be represented in set notation as $x[n] = \\{1, 2, 1\\}$ and $h[n] = \\{1, 0, -1\\}$, where the first element corresponds to index $n=0$.\n\nDerive the resulting sequence $y[n] = (x * h)[n]$.",
            "solution": "The discrete convolution of finite sequences $x[n]$ and $h[n]$ is defined by  \n$$y[n]=\\sum_{k=-\\infty}^{\\infty}x[k]\\,h[n-k].$$  \nSince $x[k]$ and $h[k]$ vanish outside $0\\le k\\le2$, the sum reduces to $k=0\\ldots2$. Moreover $h[n-k]=0$ unless $0\\le n-k\\le2$, so $y[n]\\neq0$ only for $0\\le n\\le4$.\n\nFor $n=0$:  \n$$y[0]=\\sum_{k=0}^{2}x[k]\\,h[0-k]=x[0]\\,h[0]=1\\cdot1=1.$$\n\nFor $n=1$:  \n$$y[1]=\\sum_{k=0}^{2}x[k]\\,h[1-k]\n=x[0]\\,h[1]+x[1]\\,h[0]\n=1\\cdot0+2\\cdot1=2.$$\n\nFor $n=2$:  \n$$y[2]=x[0]\\,h[2]+x[1]\\,h[1]+x[2]\\,h[0]\n=1\\cdot(-1)+2\\cdot0+1\\cdot1=0.$$\n\nFor $n=3$:  \n$$y[3]=x[1]\\,h[2]+x[2]\\,h[1]\n=2\\cdot(-1)+1\\cdot0=-2.$$\n\nFor $n=4$:  \n$$y[4]=x[2]\\,h[2]=1\\cdot(-1)=-1.$$\n\nHence the resulting sequence is  \n$$y[n]=\\{1,2,0,-2,-1\\}\\quad,\\;0\\le n\\le4.$$",
            "answer": "$$\\boxed{\\{1,2,0,-2,-1\\}}$$"
        },
        {
            "introduction": "The true power of the Convolution Theorem shines when it is used to solve problems that are intractable in the time domain. This exercise challenges you to perform a deconvolution, which is the process of recovering an original signal from its convolved output. Determining a function $f(t)$ from its autoconvolution $(f*f)(t)$ is a difficult inverse problem, but the Convolution Theorem elegantly converts it into a simple algebraic manipulation in the frequency domain, demonstrating its profound utility for analysis and system identification. ",
            "id": "540100",
            "problem": "Given that the autoconvolution of a function $f(t)$ is $e^{-|t|}$, determine $f(t)$ using the Convolution Theorem and Fourier transforms. The Convolution Theorem states that if $(f * f)(t) = g(t)$, then the Fourier transform satisfies $\\mathcal{F}\\{g\\}(\\omega) = [\\mathcal{F}\\{f\\}(\\omega)]^2$. The Fourier transform $\\mathcal{F}\\{h\\}(\\omega)$ of a function $h(t)$ is defined as $\\int_{-\\infty}^{\\infty} h(t) e^{-i\\omega t}  dt$. Express the final answer in closed form, which may involve special functions such as the modified Bessel function $K_0$.",
            "solution": "1. Convolution and Fourier‚Äêtransform relations  \n   - If $g(t)=(f*f)(t)$, then by the Convolution Theorem  \n     \n$$\n       \\mathcal F\\{g\\}(\\omega)=\\bigl[\\mathcal F\\{f\\}(\\omega)\\bigr]^2\\,.\n     $$\n  \n   - Definitions  \n     \n$$\n       G(\\omega)=\\mathcal F\\{g\\}(\\omega)=\\int_{-\\infty}^{\\infty}g(t)e^{-i\\omega t}\\,dt,\n       \\quad\n       f(t)=\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}F(\\omega)e^{i\\omega t}\\,d\\omega.\n     $$\n\n\n2. Fourier transform of $g(t)=e^{-|t|}$  \n   \n$$\n     G(\\omega)=\\int_{-\\infty}^{\\infty}e^{-|t|}e^{-i\\omega t}\\,dt\n     =\\frac{2}{1+\\omega^2}\\,.\n   $$\n\n\n3. Solve for $F(\\omega)$  \n   \n$$\n     F(\\omega)^2=G(\\omega)=\\frac{2}{1+\\omega^2}\n     \\quad\\Longrightarrow\\quad\n     F(\\omega)=\\sqrt{\\frac{2}{1+\\omega^2}},\n   $$\n  \n   choosing the positive branch for a real, even $f(t)$.\n\n4. Inverse Fourier transform to get $f(t)$  \n   \n$$\n     f(t)\n     =\\frac{1}{2\\pi}\\int_{-\\infty}^{\\infty}\\sqrt{\\frac{2}{1+\\omega^2}}\\,e^{i\\omega t}\\,d\\omega\n     =\\frac{\\sqrt{2}}{2\\pi}\\int_{-\\infty}^{\\infty}\\frac{e^{i\\omega t}}{\\sqrt{1+\\omega^2}}\\,d\\omega.\n   $$\n\n\n5. Use evenness and the integral representation of the modified Bessel function  \n   \n$$\n     f(t)\n     =\\frac{\\sqrt{2}}{\\pi}\\int_{0}^{\\infty}\\frac{\\cos(\\omega t)}{\\sqrt{1+\\omega^2}}\\,d\\omega\n     =\\frac{\\sqrt{2}}{\\pi}K_{0}(|t|)\\,,\n   $$\n  \n   since $\\displaystyle\\int_{0}^{\\infty}\\frac{\\cos(\\omega t)}{\\sqrt{\\omega^2+1}}\\,d\\omega=K_{0}(|t|).$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{\\pi}K_{0}(|t|)}$$"
        },
        {
            "introduction": "This final practice bridges the gap between abstract theory and the practical realities of computational neuroscience. You will implement FFT-based convolution, a cornerstone of efficient signal processing, and confront critical implementation details such as the distinction between linear and circular convolution and the role of zero-padding. By applying these techniques to realistic neuroscience signals like spike trains and local field potentials (LFPs), this exercise solidifies your understanding of how the Convolution Theorem is applied in real-world data analysis workflows. ",
            "id": "4198907",
            "problem": "Consider discretely sampled neural time series and their processing using the Discrete Fourier Transform (DFT) and the Fast Fourier Transform (FFT) in the context of neuroscience data analysis. Let a discrete-time signal be denoted by $x[n]$ for integer index $n$, sampled at sampling frequency $f_s$ (in $\\mathrm{Hz}$) over duration $T$ (in $\\mathrm{s}$). Let a kernel (impulse response) be denoted by $h[n]$ of length $M$. The linear convolution is defined by $y[n] = \\sum_{m=0}^{M-1} h[m] x[n-m]$ for those indices $n$ where the sum is well-defined, with $y[n] = 0$ when indices fall outside the support of $x[n]$. The $N$-point Discrete Fourier Transform (DFT) of a sequence $x[n]$ of length $N$ is $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N}$ for $k = 0,1,\\dots,N-1$, and the inverse DFT is $x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] e^{i 2 \\pi k n / N}$.\n\nYour task is to start from the above fundamental definitions and:\n\n1. Using only the definitions of linear convolution, circular convolution induced by the $N$-point DFT, and the DFT/inverse DFT pair, derive the precise relationship between applying the DFT to a linearly convolved pair $x[n]$ and $h[n]$ and the frequency-domain operation that results when appropriate zero-padding is used. Explicitly state the minimal padding criterion in terms of $L$ and $M$, where $L$ is the length of $x[n]$, needed to ensure that the time-domain operation computed via the inverse DFT reproduces linear convolution without time-domain aliasing, and explain how insufficient padding manifests as circular wrap-around of the linear convolution. Then, reason about sampling at frequency $f_s$ and the Nyquist frequency $f_N = \\frac{f_s}{2}$: explain under what conditions time-domain convolution (filtering) will not introduce frequency-domain aliasing given $h[n]$ designed to be low-pass with cutoff frequency $f_c$ relative to $f_N$.\n\n2. Implement a program that computes FFT-based convolution and compares it to direct time-domain convolution on the following test suite. Angles in trigonometric functions must be in radians. All physical rates must be expressed in $\\mathrm{Hz}$ and durations in $\\mathrm{s}$. The program must produce all final results as dimensionless floats.\n\nTest Suite:\n- Test Case $1$ (spike train and exponential kernel):\n    - Sampling frequency $f_s = 1000$ $\\mathrm{Hz}$, duration $T = 10$ $\\mathrm{s}$, so $L = 10000$ samples.\n    - Generate a binary spike train $x[n]$ with independent samples using a Poisson rate $\\lambda = 10$ $\\mathrm{Hz}$, i.e., spike probability per sample $p = \\lambda / f_s = 10 / 1000$. Use a fixed pseudo-random seed $12345$ for reproducibility.\n    - Use a causal exponential kernel $h[n] = \\exp\\left(-\\frac{n}{\\tau f_s}\\right)$ for $n = 0,1,\\dots,M-1$ with time constant $\\tau = 0.02$ $\\mathrm{s}$ and support $0.2$ $\\mathrm{s}$; specifically, set $M = \\lfloor 0.2 f_s \\rfloor + 1$.\n    - Define $N_{\\text{lin}} = L + M - 1$, $N_{\\text{circ}} = \\max(L, M)$, and $N_{\\text{pow2}} = 2^{\\lceil \\log_2(N_{\\text{lin}}) \\rceil}$.\n    - Compute three errors:\n        - $E_{\\text{circ}}$: the maximum absolute difference between the $N_{\\text{circ}}$-point circular convolution computed via FFT and the circular wrap of the linear convolution $y[n]$ (obtained by folding $y[n]$ modulo $N_{\\text{circ}}$).\n        - $E_{\\text{lin}}$: the maximum absolute difference between the FFT-based convolution with $N_{\\text{lin}}$ zero-padding and the direct linear convolution $y[n]$.\n        - $E_{\\text{pow2}}$: the maximum absolute difference between the FFT-based convolution with $N_{\\text{pow2}}$ zero-padding and the direct linear convolution $y[n]$.\n- Test Case $2$ (Local Field Potential filtering):\n    - Sampling frequency $f_s = 1000$ $\\mathrm{Hz}$, duration $T = 8$ $\\mathrm{s}$, angle arguments in radians, so $L = 8000$ samples.\n    - Generate $x[n] = 1.0 \\cdot \\sin(2 \\pi \\cdot 10 \\cdot n/f_s) + 0.5 \\cdot \\sin(2 \\pi \\cdot 80 \\cdot n/f_s) + \\eta[n]$ where $\\eta[n]$ is independent identically distributed Gaussian noise with zero mean and standard deviation $0.2$. Use a fixed pseudo-random seed $54321$ for reproducibility.\n    - Design a length-$M = 801$ finite impulse response low-pass kernel $h[n]$ with cutoff $f_c = 40$ $\\mathrm{Hz}$ using a Hann-windowed sinc method; ensure passband is low-pass ($0$ to $f_c$). You may use a standard, well-tested windowed-sinc filter design routine that accepts $f_s$ and produces $h[n]$.\n    - Let $N_{\\text{pow2}} = 2^{\\lceil \\log_2(L + M - 1) \\rceil}$. Compute the FFT-based convolution $y_{\\text{fft}}[n]$ with zero-padding to $N_{\\text{pow2}}$, and the direct linear convolution $y_{\\text{dir}}[n]$.\n    - Compute the relative error $E_{\\text{lfp}} = \\frac{\\|y_{\\text{fft}} - y_{\\text{dir}}\\|_2}{\\|y_{\\text{dir}}\\|_2}$.\n- Test Case $3$ (boundary case, minimal lengths):\n    - $x[n] = [1.0]$, $h[n] = [0.5]$. Set $N_{\\text{lin}} = 2$.\n    - Compute $E_{\\text{short}}$ as the absolute difference between the FFT-based convolution with padding length $N_{\\text{lin}}$ and the direct linear convolution.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4,result_5]$) in the exact order $[E_{\\text{circ}},E_{\\text{lin}},E_{\\text{pow2}},E_{\\text{lfp}},E_{\\text{short}}]$. All outputs must be floats. No additional text should be printed. The results are dimensionless and unitless floats.",
            "solution": "The problem posed is valid, as it is scientifically grounded in digital signal processing theory, well-posed with specific numerical parameters and seeds for reproducibility, and formulated using objective, standard terminology. We will proceed first with the requested theoretical derivation, followed by the implementation details which will be encapsulated in the final answer.\n\n### 1. The Convolution Theorem: From Circular to Linear Convolution\n\nWe begin by establishing the relationship between linear convolution, which is the desired filtering operation in the time domain, and circular convolution, which is the operation naturally represented by multiplication in the Discrete Fourier Transform (DFT) domain.\n\nLet $x[n]$ be a discrete-time signal of length $L$, meaning it is non-zero only for $n \\in \\{0, 1, \\dots, L-1\\}$, and let $h[n]$ be a filter kernel (impulse response) of length $M$, non-zero only for $n \\in \\{0, 1, \\dots, M-1\\}$.\n\nThe **linear convolution** of $x[n]$ and $h[n]$, denoted $(x * h)[n]$, is defined as:\n$$\ny[n] = (x * h)[n] = \\sum_{m=0}^{M-1} h[m] x[n-m]\n$$\nThe resulting sequence $y[n]$ is of length $N_{\\text{lin}} = L + M - 1$, with non-zero values for indices $n \\in \\{0, 1, \\dots, L+M-2\\}$.\n\nThe **Convolution Theorem for the DFT** states that the DFT of the circular convolution of two signals is the element-wise product of their individual DFTs. Let $x_p[n]$ and $h_p[n]$ be two signals, both of length $N$. Their $N$-point **circular convolution** is:\n$$\n(x_p \\circledast_N h_p)[n] = \\sum_{m=0}^{N-1} x_p[m] h_p[(n-m) \\pmod N]\n$$\nwhere $(n-m) \\pmod N$ indicates the remainder of the division of $(n-m)$ by $N$. The theorem states:\n$$\n\\text{DFT}_N\\{(x_p \\circledast_N h_p)[n]\\} = X_p[k] \\cdot H_p[k]\n$$\nwhere $X_p[k] = \\text{DFT}_N\\{x_p[n]\\}$ and $H_p[k] = \\text{DFT}_N\\{h_p[n]\\}$. Consequently, we can compute the circular convolution using the Inverse DFT (IDFT):\n$$\n(x_p \\circledast_N h_p)[n] = \\text{IDFT}_N\\{X_p[k] \\cdot H_p[k]\\}\n$$\nThis property is powerful because the DFT can be computed efficiently using the Fast Fourier Transform (FFT) algorithm, making frequency-domain multiplication much faster than direct time-domain convolution for large signals.\n\nOur goal is to use this efficient method to compute the *linear* convolution $y[n]$. The key is to recognize the relationship between linear and circular convolution. The $N$-point circular convolution of two sequences can be expressed as a \"wrapped\" or aliased version of their linear convolution:\n$$\n(x_p \\circledast_N h_p)[n] = \\sum_{j=-\\infty}^{\\infty} y[n + jN]\n$$\nwhere $y[n]$ is the linear convolution result. The term $y[n+jN]$ represents the \"tails\" of the linear convolution that are wrapped around and added to the first $N$ samples. This phenomenon is called **time-domain aliasing**.\n\nTo ensure that the circular convolution result is identical to the linear convolution result, we must prevent this aliasing. This is achieved by making the DFT length $N$ large enough to hold the entire linear convolution result without any wrap-around. Since the linear convolution $y[n]$ has a length of $L+M-1$, we must choose a DFT length $N$ such that $N \\ge L+M-1$.\n\n**Minimal Padding Criterion:** To compute the linear convolution of a length-$L$ signal $x[n]$ and a length-$M$ signal $h[n]$ using the DFT/FFT, both signals must be zero-padded to a common length $N$ that satisfies $N \\ge L+M-1$.\n\nThe procedure is as follows:\n1.  Choose a transform length $N \\ge L+M-1$. For computational efficiency with FFT algorithms, $N$ is often chosen as the next highest power of $2$, i.e., $N = 2^{\\lceil \\log_2(L+M-1) \\rceil}$.\n2.  Create padded signals $x_p[n]$ and $h_p[n]$ of length $N$ by appending zeros to the original signals $x[n]$ and $h[n]$.\n3.  Compute their $N$-point FFTs: $X_p[k] = \\text{FFT}\\{x_p[n]\\}$ and $H_p[k] = \\text{FFT}\\{h_p[n]\\}$.\n4.  Multiply the results element-wise: $Y_p[k] = X_p[k] \\cdot H_p[k]$.\n5.  Compute the $N$-point Inverse FFT (IFFT): $y_p[n] = \\text{IFFT}\\{Y_p[k]\\}$.\n\nThe resulting sequence $y_p[n]$ will be real-valued (within machine precision) and its first $L+M-1$ samples will be identical to the linear convolution $y[n]$. The remaining $N - (L+M-1)$ samples will be zero.\n\nIf an insufficient padding length $N < L+M-1$ is used, the result of the IFFT will be the aliased circular convolution, where the values of the linear convolution $y[k]$ for $k \\ge N$ are wrapped around and added to the values $y[k \\pmod N]$. This is the circular wrap-around effect described in the problem.\n\n### 2. Filtering and Frequency-Domain Aliasing\n\nThe problem asks about the conditions under which time-domain convolution (filtering) does not introduce **frequency-domain aliasing**. This requires careful use of terminology.\n\nFrequency-domain aliasing is an artifact of the **sampling process**, i.e., the conversion of a continuous-time signal $x_c(t)$ to a discrete-time signal $x[n] = x_c(nT_s)$, where $T_s = 1/f_s$ is the sampling period. According to the Nyquist-Shannon sampling theorem, if the highest frequency component in $x_c(t)$, denoted $f_{\\text{max}}$, is greater than the Nyquist frequency $f_N = f_s/2$, the frequency components above $f_N$ will \"fold\" into the frequency range $[0, f_N]$, getting mixed with the lower frequencies. This is aliasing. Once a signal is sampled and aliasing has occurred, it cannot be undone.\n\nLinear convolution, $y[n] = (x * h)[n]$, is a **Linear Time-Invariant (LTI)** operation. A fundamental property of LTI systems is that they cannot create new frequency components in the output that were not present in the input. The frequency spectrum of the output signal, $Y(e^{j\\omega})$, is simply the product of the input signal's spectrum, $X(e^{j\\omega})$, and the filter's frequency response, $H(e^{j\\omega})$:\n$$\nY(e^{j\\omega}) = X(e^{j\\omega}) H(e^{j\\omega})\n$$\nTherefore, the discrete-time linear convolution operation **does not, by itself, introduce frequency-domain aliasing**. Aliasing is a characteristic determined by the initial sampling of the signal $x[n]$.\n\nThe role of a low-pass filter with a cutoff frequency $f_c$ (where $f_c < f_N$) is not to prevent aliasing from being *introduced* by the convolution, but rather to *remove* or *attenuate* frequency components from the signal $x[n]$ that are above $f_c$.\n- If $x[n]$ was already properly sampled (i.e., not aliased), the low-pass filter simply removes its high-frequency content. The resulting signal $y[n]$ is band-limited to approximately $f_c$. This is a standard procedure for isolating specific frequency bands of interest.\n- If $x[n]$ is an aliased signal, the low-pass filter will act on its folded spectrum. It will pass the low-frequency content, which may include original high-frequency content that was aliased into the low-frequency band, and attenuate the higher frequencies in the $[0, f_N]$ range. It cannot correct the aliasing that has already occurred.\n- A common use of such a filter is as an **anti-aliasing filter** *before* downsampling. If one wishes to reduce the sampling rate of a signal, one must first low-pass filter it with a cutoff below the new target Nyquist frequency to prevent aliasing in the downsampled signal.\n\nIn summary, the condition under which time-domain convolution does not introduce frequency-domain aliasing is that the operation is linear, which is true by definition for the convolution specified. The properties of the filter $h[n]$ and the sampling rate $f_s$ determine the spectral content of the output, but the filtering operation itself is not a source of new aliasing.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft, ifft\nfrom scipy.signal import convolve, firwin\n\ndef solve():\n    \"\"\"\n    Solves the problem by performing theoretical derivations and numerical computations\n    for three test cases related to FFT-based convolution.\n    \"\"\"\n    \n    # --- Test Case 1: Spike train and exponential kernel ---\n    \n    # Parameters\n    fs_1 = 1000.0  # Hz\n    T_1 = 10.0   # s\n    L_1 = int(fs_1 * T_1)\n    lambda_rate = 10.0  # Hz\n    p_spike = lambda_rate / fs_1\n    seed_1 = 12345\n    \n    # Generate spike train\n    rng_1 = np.random.default_rng(seed_1)\n    x_1 = rng_1.binomial(1, p_spike, size=L_1).astype(float)\n    \n    # Generate kernel\n    tau_1 = 0.02  # s\n    support_dur = 0.2 # s\n    M_1 = int(np.floor(support_dur * fs_1)) + 1\n    n_h1 = np.arange(M_1)\n    h_1 = np.exp(-n_h1 / (tau_1 * fs_1))\n    \n    # Define convolution lengths\n    N_lin_1 = L_1 + M_1 - 1\n    N_circ_1 = max(L_1, M_1)\n    N_pow2_1 = 1 << (N_lin_1 - 1).bit_length() # Equivalent to 2**ceil(log2(N_lin))\n\n    # Direct linear convolution\n    y_lin_1 = convolve(x_1, h_1, mode='full', method='direct')\n\n    # E_circ computation\n    # 1. FFT-based circular convolution\n    h_pad_circ = np.zeros(N_circ_1)\n    h_pad_circ[:M_1] = h_1\n    y_fft_circ = ifft(fft(x_1, n=N_circ_1) * fft(h_pad_circ, n=N_circ_1)).real\n\n    # 2. Wrapped linear convolution\n    y_wrap = np.copy(y_lin_1[:N_circ_1])\n    if len(y_lin_1) > N_circ_1:\n         y_wrap[:len(y_lin_1) - N_circ_1] += y_lin_1[N_circ_1:]\n\n    E_circ = np.max(np.abs(y_fft_circ - y_wrap))\n    \n    # E_lin computation\n    y_fft_lin = ifft(fft(x_1, n=N_lin_1) * fft(h_1, n=N_lin_1)).real\n    E_lin = np.max(np.abs(y_fft_lin - y_lin_1))\n\n    # E_pow2 computation\n    y_fft_pow2 = ifft(fft(x_1, n=N_pow2_1) * fft(h_1, n=N_pow2_1)).real\n    E_pow2 = np.max(np.abs(y_fft_pow2[:N_lin_1] - y_lin_1))\n\n    # --- Test Case 2: LFP filtering ---\n\n    # Parameters\n    fs_2 = 1000.0  # Hz\n    T_2 = 8.0    # s\n    L_2 = int(fs_2 * T_2)\n    seed_2 = 54321\n\n    # Generate LFP-like signal\n    rng_2 = np.random.default_rng(seed_2)\n    n_2 = np.arange(L_2)\n    t_2 = n_2 / fs_2\n    x_2 = (1.0 * np.sin(2 * np.pi * 10.0 * t_2) + \n           0.5 * np.sin(2 * np.pi * 80.0 * t_2) +\n           rng_2.normal(0, 0.2, size=L_2))\n\n    # Design FIR filter\n    M_2 = 801\n    fc_2 = 40.0  # Hz\n    h_2 = firwin(numtaps=M_2, cutoff=fc_2, fs=fs_2, window='hann', pass_zero='lowpass')\n\n    # Define convolution length\n    N_lin_2 = L_2 + M_2 - 1\n    N_pow2_2 = 1 << (N_lin_2 - 1).bit_length()\n\n    # Direct and FFT-based convolution\n    y_dir_2 = convolve(x_2, h_2, mode='full', method='direct')\n    y_fft_2 = ifft(fft(x_2, n=N_pow2_2) * fft(h_2, n=N_pow2_2)).real\n    y_fft_2_trimmed = y_fft_2[:len(y_dir_2)]\n    \n    # Compute relative error\n    norm_diff = np.linalg.norm(y_fft_2_trimmed - y_dir_2)\n    norm_dir = np.linalg.norm(y_dir_2)\n    E_lfp = norm_diff / norm_dir if norm_dir > 0 else 0.0\n\n    # --- Test Case 3: Boundary case ---\n\n    x_3 = np.array([1.0])\n    h_3 = np.array([0.5])\n    N_lin_3 = 2 # As per problem statement\n    \n    # Direct convolution\n    y_dir_3 = convolve(x_3, h_3, mode='full')\n    \n    # FFT-based convolution\n    y_fft_3 = ifft(fft(x_3, n=N_lin_3) * fft(h_3, n=N_lin_3)).real\n    \n    # Compute absolute difference\n    E_short = np.max(np.abs(y_fft_3[:len(y_dir_3)] - y_dir_3))\n\n    # --- Final Output ---\n    results = [E_circ, E_lin, E_pow2, E_lfp, E_short]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}