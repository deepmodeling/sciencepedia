{
    "hands_on_practices": [
        {
            "introduction": "神经调谐分析的一个核心任务是确定神经元的“偏好方向”——即能够引发最强反应的刺激方向。这个练习将指导你从基本原理出发，计算加权圆形平均值，这是一种估计中心趋势的稳健方法。通过将神经脉冲与局部场电位（LFP）的相位信息结合作为权重，我们可以得到一个更精确的估计，这在神经科学研究中是一种常见且强大的技术 。",
            "id": "4202390",
            "problem": "给定一个神经元的多个记录会话。每个会话包含一组尖峰-相位对，其中每一对包含尖峰时刻的头部方向角和局部场电位θ波相位。令每一对表示为 $(\\theta_i, \\phi_i)$，其中 $\\theta_i \\in [0, 2\\pi)$ 和 $\\phi_i \\in [0, 2\\pi)$，单位均为弧度。目标是使用循环均值来估计每个会话的偏好头部方向，该均值将尖峰-相位信息作为可靠性权重纳入计算，然后使用循环距离度量评估偏好方向在不同会话间的稳定性。\n\n仅从基本定义出发，即角度 $\\theta$ 对应平面上笛卡尔分量为 $(\\cos\\theta, \\sin\\theta)$ 的单位向量，且向量的加权平均由每个向量乘以其非负权重后的总和给出，推导出每个会话的偏好头部方向，作为由头部方向单位向量形成的加权合向量的辐角。使用由尖峰相位围绕参考相位的余弦调制定义的非负权重：\n$$\nw_i = 1 + \\alpha \\cos(\\phi_i - \\phi_{\\text{ref}}),\n$$\n其中 $0 \\le \\alpha  1$ 和 $\\phi_{\\text{ref}} \\in [0, 2\\pi)$ 是指定参数。您必须将偏好头部方向 $\\hat{\\mu}$ 表示为单位向量加权和的辐角，并确保 $\\hat{\\mu} \\in [0, 2\\pi)$，单位为弧度。\n\n为了评估会话间的稳定性，将两个偏好方向 $\\hat{\\mu}_1$ 和 $\\hat{\\mu}_2$ 之间的循环距离定义为圆周上的最小绝对角差：\n$$\nd = \\left| \\operatorname{wrap}(\\hat{\\mu}_1 - \\hat{\\mu}_2) \\right|,\n$$\n其中 $\\operatorname{wrap}(\\Delta)$ 将任意实数 $\\Delta$ 映射到 $(-\\pi, \\pi]$ 区间内唯一一个与 $\\Delta$ 模 $2\\pi$ 同余的代表值。如果一对会话的 $d  \\tau$，则称其为稳定的，其中 $\\tau$ 是以弧度为单位给定的阈值。\n\n实现一个程序，对每个提供的测试用例计算：\n- 会话1的偏好头部方向 $\\hat{\\mu}_1$（以弧度为单位）；\n- 会话2的偏好头部方向 $\\hat{\\mu}_2$（以弧度为单位）；\n- 循环距离 $d$（以弧度为单位）；\n- 一个由 $d  \\tau$ 是否成立给出的布尔稳定性指标。\n\n所有角度必须以弧度为单位。所有浮点数输出必须四舍五入到6位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果格式化为列表 $[\\hat{\\mu}_1, \\hat{\\mu}_2, d, \\text{stable}]$。\n\n使用以下测试套件，它涵盖了典型、边界和边缘情况的场景：\n\n测试用例1（未加权均值，中等集中度）：\n- 参数： $\\alpha = 0.0$, $\\phi_{\\text{ref}} = 0.0$, $\\tau = 0.5$。\n- 会话1数据对 $(\\theta_i, \\phi_i)$:\n  $(0.9, 2.2)$, $(1.1, 0.5)$, $(0.95, 4.7)$, $(1.2, 1.0)$, $(1.05, 3.3)$。\n- 会话2数据对 $(\\theta_i, \\phi_i)$:\n  $(0.8, 3.1)$, $(1.0, 2.5)$, $(1.15, 3.8)$, $(0.95, 0.2)$, $(1.05, 5.4)$。\n\n测试用例2（相位加权均值，强调 $\\phi \\approx \\phi_{\\text{ref}}$）：\n- 参数： $\\alpha = 0.6$, $\\phi_{\\text{ref}} = 0.0$, $\\tau = 0.5$。\n- 会话1数据对 $(\\theta_i, \\phi_i)$:\n  $(1.4, 0.1)$, $(1.5, 0.05)$, $(1.6, 0.2)$, $(0.5, 3.1)$, $(0.6, 3.0)$, $(0.4, 2.9)$, $(1.55, 0.0)$, $(0.45, 3.2)$。\n- 会话2数据对 $(\\theta_i, \\phi_i)$:\n  $(1.65, 0.0)$, $(1.7, 0.1)$, $(1.75, 0.05)$, $(0.6, 3.0)$, $(0.5, 3.1)$, $(0.4, 3.2)$, $(1.68, 0.15)$, $(0.55, 2.9)$。\n\n测试用例3（接近 $0$ 和 $2\\pi$ 的环绕边界）：\n- 参数： $\\alpha = 0.3$, $\\phi_{\\text{ref}} = \\pi$, $\\tau = 0.5$。\n- 会话1数据对 $(\\theta_i, \\phi_i)$:\n  $(0.02, 3.10)$, $(0.04, 3.05)$, $(0.06, 3.20)$, $(6.27, 3.15)$。\n- 会话2数据对 $(\\theta_i, \\phi_i)$:\n  $(6.22, 3.00)$, $(6.25, 3.05)$, $(0.01, 3.10)$, $(6.20, 3.00)$。\n\n测试用例4（单尖峰边缘情况）：\n- 参数： $\\alpha = 0.9$, $\\phi_{\\text{ref}} = 0.0$, $\\tau = 0.5$。\n- 会话1数据对 $(\\theta_i, \\phi_i)$: $(2.0, 0.5)$。\n- 会话2数据对 $(\\theta_i, \\phi_i)$: $(2.3, 1.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如 $[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4]$），其中每个 $\\text{result}_k$ 是一个列表 $[\\hat{\\mu}_1, \\hat{\\mu}_2, d, \\text{stable}]$，所有角度以弧度为单位，浮点数四舍五入到6位小数。",
            "solution": "用户提供的问题是有效的，因为它在循环统计学方面有科学依据，问题陈述清晰，包含了所有必要信息，并且没有矛盾或含糊之处。我们现在将着手提供一个完整的解决方案。\n\n该问题要求我们为每个测试用例执行两项主要任务，每个测试用例涉及两个神经元记录会话：首先，计算每个会话的偏好头部方向；其次，评估这些偏好方向在两个会话间的稳定性。\n\n### 第1部分：偏好头部方向 $\\hat{\\mu}$ 的估计\n\n问题指出，我们必须从角度 $\\theta$ 的基本定义——即笛卡尔平面上的单位向量 $(\\cos\\theta, \\sin\\theta)$——开始。一个会话的偏好方向 $\\hat{\\mu}$ 被定义为由头部方向单位向量形成的加权合向量的辐角。\n\n假设一个会话包含 $N$ 个尖峰-相位对 $(\\theta_i, \\phi_i)$，其中 $i=1, \\dots, N$。\n\n**步骤1：将头部方向表示为单位向量**\n每个头部方向角 $\\theta_i$ 对应于二维笛卡尔平面中的一个单位向量 $\\vec{v}_i$：\n$$\n\\vec{v}_i = \\begin{pmatrix} \\cos\\theta_i \\\\ \\sin\\theta_i \\end{pmatrix}\n$$\n\n**步骤2：根据尖峰相位定义权重**\n每个向量 $\\vec{v}_i$ 的贡献由一个值 $w_i$ 加权，该值由相应的尖峰相位 $\\phi_i$ 导出。权重 $w_i$ 由围绕参考相位 $\\phi_{\\text{ref}}$ 的余弦调制给出：\n$$\nw_i = 1 + \\alpha \\cos(\\phi_i - \\phi_{\\text{ref}})\n$$\n问题规定参数 $\\alpha$ 满足 $0 \\le \\alpha  1$。由于余弦函数的范围是 $[-1, 1]$，权重 $w_i$ 的界限为：\n$$\n1 + \\alpha(-1) \\le w_i \\le 1 + \\alpha(1) \\implies 1 - \\alpha \\le w_i \\le 1 + \\alpha\n$$\n鉴于 $\\alpha  1$，可得 $1 - \\alpha  0$，这确保了所有权重 $w_i$ 均为严格正数，因此对于加权平均是良定义的。\n\n**步骤3：计算加权合向量**\n加权合向量 $\\vec{R}$ 是所有单位向量 $\\vec{v}_i$ 乘以其相应权重 $w_i$ 后的总和：\n$$\n\\vec{R} = \\sum_{i=1}^{N} w_i \\vec{v}_i = \\sum_{i=1}^{N} w_i \\begin{pmatrix} \\cos\\theta_i \\\\ \\sin\\theta_i \\end{pmatrix} = \\begin{pmatrix} \\sum_{i=1}^{N} w_i \\cos\\theta_i \\\\ \\sum_{i=1}^{N} w_i \\sin\\theta_i \\end{pmatrix}\n$$\n令 $\\vec{R}$ 的笛卡尔分量为 $R_x$ 和 $R_y$：\n$$\nR_x = \\sum_{i=1}^{N} w_i \\cos\\theta_i\n$$\n$$\nR_y = \\sum_{i=1}^{N} w_i \\sin\\theta_i\n$$\n\n**步骤4：确定偏好方向 $\\hat{\\mu}$**\n偏好方向 $\\hat{\\mu}$ 是合向量 $\\vec{R}$ 的角度（或辐角）。该角度使用双参数反正切函数 $\\operatorname{atan2}(y, x)$ 确定，该函数能在所有四个象限中正确解析角度。结果 $\\hat{\\mu}_{\\text{raw}}$ 通常在区间 $(-\\pi, \\pi]$ 内。\n$$\n\\hat{\\mu}_{\\text{raw}} = \\operatorname{atan2}(R_y, R_x)\n$$\n问题要求最终角度 $\\hat{\\mu}$ 在范围 $[0, 2\\pi)$ 内。我们可以通过将任何负结果加上 $2\\pi$ 来将 $\\hat{\\mu}_{\\text{raw}}$ 映射到此范围：\n$$\n\\hat{\\mu} = \\begin{cases}\n\\hat{\\mu}_{\\text{raw}}  \\text{if } \\hat{\\mu}_{\\text{raw}} \\ge 0 \\\\\n\\hat{\\mu}_{\\text{raw}} + 2\\pi  \\text{if } \\hat{\\mu}_{\\text{raw}}  0\n\\end{cases}\n$$\n如果编程语言的模运算符能恰当处理负数以产生非负结果，这等同于模运算 $(\\hat{\\mu}_{\\text{raw}} \\pmod{2\\pi})$。在Python/NumPy中，`(mu_raw + 2*np.pi) % (2*np.pi)` 可以实现此映射。\n\n### 第2部分：评估会话间的稳定性\n\n稳定性通过使用循环距离度量比较两个会话的偏好方向 $\\hat{\\mu}_1$ 和 $\\hat{\\mu}_2$ 来评估。\n\n**步骤1：定义循环距离**\n循环距离 $d$ 是圆周上的最小绝对角差。给定两个角度 $\\hat{\\mu}_1, \\hat{\\mu}_2 \\in [0, 2\\pi)$，它们的差为 $\\Delta = \\hat{\\mu}_1 - \\hat{\\mu}_2$。循环距离基于将此差值环绕（wrap）到区间 $(-\\pi, \\pi]$。\n`wrap` 函数定义为：\n$$\n\\operatorname{wrap}(\\Delta) = (\\Delta + \\pi) \\pmod{2\\pi} - \\pi\n$$\n此操作将任意实数 $\\Delta$ 映射到其在 $(-\\pi, \\pi]$ 中的唯一同余值。例如，如果 $\\Delta = 1.9\\pi$，则 $\\operatorname{wrap}(\\Delta)$ 为 $-0.1\\pi$。如果 $\\Delta= -1.9\\pi$，则 $\\operatorname{wrap}(\\Delta)$ 为 $0.1\\pi$。\n\n循环距离 $d$ 是这个环绕后差值的绝对值：\n$$\nd = |\\operatorname{wrap}(\\hat{\\mu}_1 - \\hat{\\mu}_2)|\n$$\n这确保了 $d \\in [0, \\pi]$。\n\n**步骤2：应用稳定性准则**\n如果一对会话的循环距离 $d$ 小于给定的阈值 $\\tau$，则认为它们是稳定的。\n$$\n\\text{stable} = (d  \\tau)\n$$\n结果是一个布尔值（`True` 或 `False`）。\n\n### 单个测试用例的算法步骤摘要\n1.  对每个会话（会话1和会话2）：\n    a. 提取尖峰-相位对 $(\\theta_i, \\phi_i)$ 以及参数 $\\alpha, \\phi_{\\text{ref}}$。\n    b. 计算所有尖峰的权重 $w_i = 1 + \\alpha \\cos(\\phi_i - \\phi_{\\text{ref}})$。\n    c. 计算合向量的分量，$R_x = \\sum w_i \\cos\\theta_i$ 和 $R_y = \\sum w_i \\sin\\theta_i$。\n    d. 计算偏好方向 $\\hat{\\mu}_{\\text{raw}} = \\operatorname{atan2}(R_y, R_x)$ 并将其映射到 $[0, 2\\pi)$ 以得到 $\\hat{\\mu}$。\n2.  计算出 $\\hat{\\mu}_1$ 和 $\\hat{\\mu}_2$ 后：\n    a. 计算循环距离 $d = |\\operatorname{wrap}(\\hat{\\mu}_1 - \\hat{\\mu}_2)|$。\n    b. 通过将 $d$ 与阈值 $\\tau$ 比较来确定稳定性。\n3.  将所有浮点数结果（$\\hat{\\mu}_1, \\hat{\\mu}_2, d$）四舍五入到6位小数，并组装成最终列表 $[\\hat{\\mu}_1, \\hat{\\mu}_2, d, \\text{stable}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the neuroscience tuning analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"alpha\": 0.0,\n            \"phi_ref\": 0.0,\n            \"tau\": 0.5,\n            \"session1_pairs\": np.array([\n                (0.9, 2.2), (1.1, 0.5), (0.95, 4.7), (1.2, 1.0), (1.05, 3.3)\n            ]),\n            \"session2_pairs\": np.array([\n                (0.8, 3.1), (1.0, 2.5), (1.15, 3.8), (0.95, 0.2), (1.05, 5.4)\n            ]),\n        },\n        {\n            \"alpha\": 0.6,\n            \"phi_ref\": 0.0,\n            \"tau\": 0.5,\n            \"session1_pairs\": np.array([\n                (1.4, 0.1), (1.5, 0.05), (1.6, 0.2), (0.5, 3.1), (0.6, 3.0),\n                (0.4, 2.9), (1.55, 0.0), (0.45, 3.2)\n            ]),\n            \"session2_pairs\": np.array([\n                (1.65, 0.0), (1.7, 0.1), (1.75, 0.05), (0.6, 3.0), (0.5, 3.1),\n                (0.4, 3.2), (1.68, 0.15), (0.55, 2.9)\n            ]),\n        },\n        {\n            \"alpha\": 0.3,\n            \"phi_ref\": np.pi,\n            \"tau\": 0.5,\n            \"session1_pairs\": np.array([\n                (0.02, 3.10), (0.04, 3.05), (0.06, 3.20), (6.27, 3.15)\n            ]),\n            \"session2_pairs\": np.array([\n                (6.22, 3.00), (6.25, 3.05), (0.01, 3.10), (6.20, 3.00)\n            ]),\n        },\n        {\n            \"alpha\": 0.9,\n            \"phi_ref\": 0.0,\n            \"tau\": 0.5,\n            \"session1_pairs\": np.array([(2.0, 0.5)]),\n            \"session2_pairs\": np.array([(2.3, 1.0)]),\n        },\n    ]\n\n    results = []\n\n    def compute_preferred_direction(pairs, alpha, phi_ref):\n        \"\"\"\n        Computes the weighted circular mean for a set of spike-phase pairs.\n        \n        Args:\n            pairs (np.ndarray): An array of (theta, phi) pairs.\n            alpha (float): The modulation strength parameter.\n            phi_ref (float): The reference phase.\n\n        Returns:\n            float: The preferred direction mu in [0, 2*pi).\n        \"\"\"\n        if pairs.shape[0] == 0:\n            return 0.0 # Or handle as an error, though not specified for this problem\n\n        thetas = pairs[:, 0]\n        phis = pairs[:, 1]\n\n        # Calculate weights based on phase\n        weights = 1 + alpha * np.cos(phis - phi_ref)\n\n        # Calculate components of the weighted resultant vector\n        Rx = np.sum(weights * np.cos(thetas))\n        Ry = np.sum(weights * np.sin(thetas))\n\n        # Calculate the raw angle using atan2\n        mu_raw = np.arctan2(Ry, Rx)\n        \n        # Map the angle to the range [0, 2*pi)\n        mu = (mu_raw + 2 * np.pi) % (2 * np.pi)\n        \n        return mu\n\n    def compute_circular_distance(mu1, mu2):\n        \"\"\"\n        Computes the circular distance between two angles.\n        \n        Args:\n            mu1 (float): First angle in radians.\n            mu2 (float): Second angle in radians.\n\n        Returns:\n            float: The circular distance d in [0, pi].\n        \"\"\"\n        delta = mu1 - mu2\n        # Wrap the difference to the interval (-pi, pi]\n        wrapped_delta = (delta + np.pi) % (2 * np.pi) - np.pi\n        # The distance is the absolute value of the wrapped difference\n        distance = np.abs(wrapped_delta)\n        return distance\n\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        phi_ref = case[\"phi_ref\"]\n        tau = case[\"tau\"]\n\n        # Compute preferred direction for session 1\n        mu1 = compute_preferred_direction(case[\"session1_pairs\"], alpha, phi_ref)\n\n        # Compute preferred direction for session 2\n        mu2 = compute_preferred_direction(case[\"session2_pairs\"], alpha, phi_ref)\n        \n        # Compute circular distance\n        d = compute_circular_distance(mu1, mu2)\n\n        # Check for stability\n        stable = d  tau\n\n        # Round float outputs to 6 decimal places\n        mu1_rounded = round(mu1, 6)\n        mu2_rounded = round(mu2, 6)\n        d_rounded = round(d, 6)\n\n        results.append([mu1_rounded, mu2_rounded, d_rounded, stable])\n\n    # Format the output as a single-line string representation of a list of lists.\n    # The map(str, ...) will convert each inner list like [1.2, 3.4, 0.5, True]\n    # into its string representation, e.g., \"'[1.2, 3.4, 0.5, True]'\".\n    # Joining these with commas and enclosing in brackets gives the desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "在量化神经元的偏好方向之前，我们必须首先回答一个更基本的问题：这个神经元真的表现出调谐特性吗，还是它的放电模式与随机均匀分布无法区分？本练习将引导你实现两种经典的圆形统计检验方法——瑞利检验（Rayleigh test）和V检验（V test），以进行假设检验。通过这个练习，你将学会如何统计地判断一个神经元是否具有方向选择性，并理解这两种检验在不同情况下的统计功效差异 。",
            "id": "4202325",
            "problem": "给定几个表示在调谐分析背景下记录的刺激方向的有限角度样本。目标是实现一个程序，对每个样本应用圆形统计学中的两个经典检验，以评估角度在圆周上偏离均匀分布的程度，并在指定平均方向时，比较它们相对于单峰备择假设的相对功效。具体来说，您将应用指定了平均方向的 Rayleigh 检验和 V 检验，并计算它们在圆周上均匀分布的原假设下的相关单侧尾部概率（p值）。角度必须以弧度处理。\n\n您必须从基本原理出发，推导出两种检验所需的检验统计量和尾部概率，而不能假定任何简便公式。您可以依赖以下核心定义和经过充分检验的事实：\n- 角度的单位圆表示法，其中每个角度对应平面上单位圆的一个点。\n- 通过对与每个角度相关联的单位向量求和得到的角度平均合向量。\n- 在圆周上均匀分布的原假设下，归一化合向量的实部和虚部独立同分布，均值为 $0$，并服从大样本近似，从而能够推导出 Rayleigh 检验统计量的尾部概率。\n- 中心极限定理 (CLT) 以及在原假设下余弦函数的性质，使得在指定平均方向时，能够为 V 检验推导出单侧正态近似。\n\n对于每个样本，您必须计算：\n- 针对圆周上均匀分布原假设的 Rayleigh 检验 p 值。\n- 针对均匀分布原假设的 V 检验 p 值，该检验是为指定平均方向设计的单侧检验，旨在检测在给定方向上的集中趋势。\n- 在显著性水平 $\\alpha = 0.05$ 下，对每个检验的统计显著性的布尔决策。\n\n角度单位说明：所有角度都以弧度为单位。您的程序必须假设给定的角度在 $[0, 2\\pi)$ 范围内，但您应该能稳健地处理任何提供的角度并将其包裹到此范围内。\n\n测试套件：\n- 情况 $1$（边界均匀性）：角度在圆周上均匀分布，$n = 16$，对于 $k \\in \\{0, 1, \\dots, 15\\}$，$\\theta_k = \\frac{2\\pi k}{16}$，指定的平均方向为 $\\mu_0 = \\frac{\\pi}{4}$。\n- 情况 $2$（与指定方向对齐的单峰分布）：$n = 12$，角度为 $\\theta_i = \\mu_0 + \\delta_i$，其中 $\\mu_0 = \\frac{\\pi}{3}$，$\\delta_i \\in \\{-0.10, -0.08, -0.06, -0.04, -0.02, 0.00, 0.02, 0.04, 0.06, 0.08, 0.10, 0.00\\}$，结果包裹到 $[0, 2\\pi)$。\n- 情况 $3$（与指定方向未对齐的单峰分布）：$n = 10$，真实集中趋势在 $\\mu_{\\text{true}} = \\frac{\\pi}{2}$ 附近，但指定的平均方向为 $\\mu_0 = 0.00$，角度为 $\\theta_i = \\mu_{\\text{true}} + \\delta_i$，其中 $\\delta_i \\in \\{-0.12, -0.08, -0.04, 0.00, 0.04, 0.08, 0.12, 0.00, 0.00, 0.00\\}$，结果包裹到 $[0, 2\\pi)$。\n- 情况 $4$（作为边界情况的轴向双峰）：$n = 6$，两个簇分别以 $\\mu_0$ 和 $\\mu_0 + \\pi$ 为中心，其中 $\\mu_0 = \\frac{\\pi}{6}$，每个中心周围的偏移量为 $\\{-0.05, 0.00, 0.05\\}$，角度是这两个簇的并集，结果包裹到 $[0, 2\\pi)$。\n- 情况 $5$（小样本对齐单峰）：$n = 5$，指定的平均方向为 $\\mu_0 = -\\frac{\\pi}{3}$，偏移量为 $\\{-0.20, -0.10, 0.00, 0.10, 0.20\\}$，角度为 $\\theta_i = \\mu_0 + \\delta_i$，结果包裹到 $[0, 2\\pi)$。\n\n从第一性原理出发，推导基于与角度对应的单位向量的平均合向量长度的 Rayleigh 检验统计量，及其大样本零分布，以获得尾部概率。利用中心极限定理和到指定方向上的余弦投影的性质，推导 V 检验统计量及其单侧尾部概率。然后实现一个程序，为每个测试用例计算：\n- Rayleigh 检验的 p 值（浮点数），\n- V 检验的 p 值（浮点数），\n- 在 $\\alpha = 0.05$ 下对 Rayleigh 检验的布尔决策，\n- 在 $\\alpha = 0.05$ 下对 V 检验的布尔决策。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含上述顺序的四个条目的列表。p 值必须四舍五入到六位小数，布尔值必须打印为 True 或 False。例如，您的程序必须打印类似 $[\\,[p_1, p_1', d_1, d_1'],\\,[p_2, p_2', d_2, d_2'],\\,\\dots\\,]$ 的形式，不含空格。",
            "solution": "我们首先将单位圆上的每个角度表示为一个单位向量。给定角度 $\\{\\theta_i\\}_{i=1}^n$，可以通过复数表示或等价地通过其笛卡尔分量来定义单位向量的和。合向量的笛卡尔分量是\n$$\nC = \\sum_{i=1}^n \\cos(\\theta_i), \\quad S = \\sum_{i=1}^n \\sin(\\theta_i).\n$$\n平均合向量长度是\n$$\n\\bar{R} = \\frac{1}{n} \\left\\| \\sum_{i=1}^n (\\cos(\\theta_i), \\sin(\\theta_i)) \\right\\| = \\frac{1}{n} \\sqrt{C^2 + S^2}.\n$$\n在圆周上均匀分布的原假设下，每个单位向量指向任何方向的概率均等，根据对称性，期望合向量为零。对于大的 $n$，中心极限定理意味着归一化分量 $C/n$ 和 $S/n$ 的行为类似于均值为 $0$、方差为 $1/2n$ 的独立随机变量的平均值。更精确地说，缩放后的量 $\\sqrt{n}\\,C/n$ 和 $\\sqrt{n}\\,S/n$ 趋向于独立的均值为 $0$、方差为 $1/2$ 的正态分布。因此，统计量\n$$\nT_R = 2n \\,\\bar{R}^2 = 2n \\left(\\frac{C^2 + S^2}{n^2}\\right)\n$$\n在原假设下渐近地服从自由度为 $2$ 的卡方分布。自由度为 $2$ 的卡方分布的生存函数是 $\\exp(-x/2)$。因此，基于大样本近似的 Rayleigh 检验的尾部概率（p值）为\n$$\np_R = \\Pr\\left(\\chi^2_2 \\ge T_R\\right) = \\exp\\left(-\\frac{T_R}{2}\\right) = \\exp\\left(-n \\bar{R}^2\\right).\n$$\n这提供了一种从第一性原理出发，使用平均合向量长度和渐近零分布来计算 Rayleigh 检验 p 值的方法。\n\n对于 V 检验，我们假设有一个指定的平均方向 $\\mu_0$，它代表了检验功效所针对的方向。其思想是将每个单位向量投影到由 $\\mu_0$ 定义的轴上，然后评估平均投影值是否为正，并且相对于均匀分布下的期望值而言是否足够大。定义投影平均值为\n$$\nu = \\frac{1}{n} \\sum_{i=1}^n \\cos(\\theta_i - \\mu_0).\n$$\n在均匀分布的原假设下，根据对称性，$\\cos(\\Theta - \\mu_0)$ 的均值为 $0$，方差为 $1/2$（因为当 $\\Theta \\sim \\text{Uniform}(0, 2\\pi)$ 时，$\\cos(\\Theta)$ 的均值为 $0$，方差为 $1/2$）。根据中心极限定理，样本均值 $u$ 近似服从均值为 $0$、方差为 $1/(2n)$ 的正态分布。因此，标准化统计量\n$$\nT_V = \\sqrt{2n}\\,u\n$$\n在原假设下近似服从标准正态分布。由于备择假设是单侧的（在方向 $\\mu_0$ 上的集中意味着 $u  0$），V 检验的单侧尾部概率（p值）为\n$$\np_V = \\Pr\\left(Z \\ge T_V\\right) = 1 - \\Phi(T_V),\n$$\n其中 $\\Phi(\\cdot)$ 表示标准正态分布的累积分布函数。在数值上，这可以通过互补误差函数计算为\n$$\np_V = \\frac{1}{2}\\,\\operatorname{erfc}\\left(\\frac{T_V}{\\sqrt{2}}\\right).\n$$\n\n算法设计：\n- 将所有角度 $\\theta_i$ 包裹到 $[0, 2\\pi)$ 以确保三角函数求值的一致性。\n- 计算 $C$、$S$ 和 $\\bar{R}$；然后计算 $p_R = \\exp(-n \\bar{R}^2)$。\n- 计算 $u = (1/n)\\sum \\cos(\\theta_i - \\mu_0)$；然后计算 $T_V = \\sqrt{2n}\\,u$ 和 $p_V = \\frac{1}{2}\\,\\operatorname{erfc}\\left(T_V/\\sqrt{2}\\right)$。\n- 将每个 p 值与 $\\alpha = 0.05$ 进行比较，以获得显著性的布尔决策。\n- 将 p 值四舍五入到六位小数以供输出。\n- 将每个案例的结果聚合到指定的无空格单行字符串格式中。\n\n功效差异的解释：\n- Rayleigh 检验对广泛的单峰备择假设具有很强的功效，因为它能检测到任何非零的平均合向量长度，而不管其方向如何。对于轴向双峰或合向量相互抵消的分布（例如，两个在相反方向上的对称簇），它的效果较差，这会导致较小的 $\\bar{R}$ 和较大的 $p_R$。\n- 当真实平均方向与指定的 $\\mu_0$ 对齐时，V 检验的功效更强，因为对 $\\cos(\\theta_i - \\mu_0)$ 求平均直接针对该轴上的集中趋势。如果真实平均方向与 $\\mu_0$ 不同，V 检验相对于 Rayleigh 检验会失去功效，因为即使分布是单峰但未对齐，投影 $u$ 也可能接近于零，从而产生较大的 $p_V$。\n\n应用于测试套件：\n- 情况 1：完全均匀的间距产生 $\\bar{R} = 0$，因此 $p_R = 1$，而 $u = 0$ 也产生 $p_V = 0.5$。在 $\\alpha = 0.05$ 的水平下，两个检验均不显著。\n- 情况 2：集中在 $\\mu_0$ 附近的角度产生大的 $\\bar{R}$ 和大的 $u$，因此 $p_R$ 和 $p_V$ 都很小；两个检验均显著。\n- 情况 3：角度集中在 $\\mu_{\\text{true}} = \\pi/2$ 附近，而 $\\mu_0 = 0$，这会产生大的 $\\bar{R}$（小的 $p_R$）但 $u \\approx 0$（大的 $p_V$），因此 Rayleigh 检验显著而 V 检验不显著，这说明了目标功效的差异。\n- 情况 4：轴向双峰导致合向量（$\\bar{R}$ 很小）和平均投影（$u$ 很小）中的抵消，从而得出大的 $p_R$ 和大的 $p_V$；两个检验均不显著，显示了针对具有单一合向量的单峰性的检验的经典局限性。\n- 情况 5：集中在 $\\mu_0$ 附近的小样本产生中等大小的 $\\bar{R}$ 和 $u$，其中 $p_V$ 通常小于 $p_R$，因为它利用了指定的方向，这说明了 V 检验在对齐的小样本中功效有所提高。\n\n程序实现了这些计算，并以 $[\\,[p_R, p_V, d_R, d_V],\\,\\dots\\,]$ 的格式打印每个案例的结果，其中 p 值四舍五入到六位小数，决策在 $\\alpha = 0.05$ 的水平下做出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef wrap_angles(theta):\n    \"\"\"\n    Wrap angles to [0, 2*pi).\n    \"\"\"\n    two_pi = 2.0 * math.pi\n    return np.mod(theta, two_pi)\n\ndef rayleigh_p_value(theta):\n    \"\"\"\n    Compute the Rayleigh test p-value using the large-sample approximation:\n    p = exp(-n * Rbar^2), where Rbar is the mean resultant length.\n    \"\"\"\n    n = theta.size\n    C = np.sum(np.cos(theta))\n    S = np.sum(np.sin(theta))\n    Rbar = math.sqrt(C**2 + S**2) / n\n    Z = n * (Rbar**2)\n    p = math.exp(-Z)\n    return p\n\ndef v_test_p_value(theta, mu0):\n    \"\"\"\n    Compute the V test p-value with specified mean direction mu0.\n    Statistic T_V = sqrt(2n) * u, where u = (1/n) sum cos(theta_i - mu0).\n    One-sided p = 0.5 * erfc(T_V / sqrt(2)).\n    \"\"\"\n    n = theta.size\n    # Projection onto specified direction\n    u = np.mean(np.cos(theta - mu0))\n    T_V = math.sqrt(2.0 * n) * u\n    # One-sided tail probability for standard normal\n    p = 0.5 * math.erfc(T_V / math.sqrt(2.0))\n    return p\n\ndef format_nested_list(lst):\n    \"\"\"\n    Format a nested list into a single-line string with no spaces,\n    floats rounded to 6 decimals, and booleans as True/False.\n    \"\"\"\n    def fmt(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        elif isinstance(item, float):\n            return f\"{item:.6f}\"\n        elif isinstance(item, bool):\n            # Use Python's capitalization for booleans\n            return \"True\" if item else \"False\"\n        else:\n            return str(item)\n    return \"[\" + \",\".join(fmt(x) for x in lst) + \"]\"\n\ndef solve():\n    two_pi = 2.0 * math.pi\n    # Define the test cases from the problem statement.\n    # Each case: (angles array in radians, specified mean direction mu0)\n    # Case 1: Uniform spacing\n    case1_angles = np.array([2.0 * math.pi * k / 16.0 for k in range(16)], dtype=float)\n    case1_mu0 = math.pi / 4.0\n\n    # Case 2: Unimodal aligned with specified direction\n    case2_mu0 = math.pi / 3.0\n    case2_offsets = np.array([-0.10, -0.08, -0.06, -0.04, -0.02, 0.00,\n                               0.02,  0.04,  0.06,  0.08,  0.10, 0.00], dtype=float)\n    case2_angles = case2_mu0 + case2_offsets\n\n    # Case 3: Unimodal misaligned with specified direction\n    case3_mu_true = math.pi / 2.0\n    case3_mu0 = 0.0\n    case3_offsets = np.array([-0.12, -0.08, -0.04, 0.00, 0.04,\n                               0.08,  0.12, 0.00, 0.00, 0.00], dtype=float)\n    case3_angles = case3_mu_true + case3_offsets\n\n    # Case 4: Axial bimodality (two opposite clusters)\n    case4_mu0 = math.pi / 6.0\n    case4_offsets = np.array([-0.05, 0.00, 0.05], dtype=float)\n    case4_angles = np.concatenate([\n        case4_mu0 + case4_offsets,\n        (case4_mu0 + math.pi) + case4_offsets\n    ])\n\n    # Case 5: Small sample unimodal aligned\n    case5_mu0 = -math.pi / 3.0\n    case5_offsets = np.array([-0.20, -0.10, 0.00, 0.10, 0.20], dtype=float)\n    case5_angles = case5_mu0 + case5_offsets\n\n    test_cases = [\n        (case1_angles, case1_mu0),\n        (wrap_angles(case2_angles), case2_mu0),\n        (wrap_angles(case3_angles), case3_mu0),\n        (wrap_angles(case4_angles), case4_mu0),\n        (wrap_angles(case5_angles), case5_mu0),\n    ]\n\n    alpha = 0.05\n    results = []\n    for angles, mu0 in test_cases:\n        angles_wrapped = wrap_angles(angles)\n        p_rayleigh = rayleigh_p_value(angles_wrapped)\n        p_v = v_test_p_value(angles_wrapped, mu0)\n        decision_rayleigh = p_rayleigh  alpha\n        decision_v = p_v  alpha\n        results.append([p_rayleigh, p_v, decision_rayleigh, decision_v])\n\n    # Round p-values to six decimals in the output and remove spaces as specified.\n    print(format_nested_list(results))\n\nsolve()\n```"
        },
        {
            "introduction": "超越简单的描述性统计和假设检验，我们可以构建一个完整的参数模型来描述神经元的调谐曲线。本练习将介绍一种在现代计算神经科学中极为重要的工具：广义线性模型（Generalized Linear Model, GLM）。你将学习如何使用泊松GLM来拟合脉冲计数数据，并将圆形预测变量（如谐波）纳入线性模型框架，最后通过似然比检验来严谨地评估不同调谐成分的显著性 。",
            "id": "4202411",
            "problem": "你的任务是在神经科学数据分析中，使用单位圆上的循环预测变量来评估神经元发放率的方向调谐。其基本原理是泊松广义线性模型 (GLM) 及其规范对数连接函数的定义、循环变量的谐波预测变量的构建，以及基于 Wilks 定理的嵌套模型间的似然比检验。\n\n你必须实现一个程序，对一组合成数据集执行以下操作：\n\n1. 在泊松模型下生成脉冲计数数据。对每个数据集，在 $[0,2\\pi)$ 上定义均匀间隔的角度 $\\theta_i$（以弧度为单位），并从均值为\n$$\n\\lambda_i = \\exp\\left(\\beta_0 + A_1 \\cos(\\theta_i - \\phi_1) + A_2 \\cos\\left(2(\\theta_i - \\phi_2)\\right)\\right).\n$$\n的泊松分布中抽样模拟计数 $y_i$。所有角度都必须以弧度处理。必须为随机数生成器确定性地设置种子以确保可复现性。\n\n2. 使用迭代重加权最小二乘法 (IRLS) 拟合两个具有对数连接函数的嵌套泊松广义线性模型：\n   - 简化模型（不含一次谐波）：\n     $$\n     \\eta_i^{\\text{red}} = \\beta_0 + \\gamma_c \\cos(2\\theta_i) + \\gamma_s \\sin(2\\theta_i),\n     $$\n     对应于预测变量集 $\\{1, \\cos(2\\theta_i), \\sin(2\\theta_i)\\}$。\n   - 完整模型（加入一次谐波）：\n     $$\n     \\eta_i^{\\text{full}} = \\beta_0 + \\beta_c \\cos(\\theta_i) + \\beta_s \\sin(\\theta_i) + \\gamma_c \\cos(2\\theta_i) + \\gamma_s \\sin(2\\theta_i),\n     $$\n     对应于预测变量集 $\\{1, \\cos(\\theta_i), \\sin(\\theta_i), \\cos(2\\theta_i), \\sin(2\\theta_i)\\}$。\n\n   对数似然（在不考虑与参数无关的加性常数的情况下）为\n   $$\n   \\ell(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n} \\left( y_i \\eta_i - \\exp(\\eta_i) \\right),\n   $$\n   其中 $\\eta_i$ 是模型的线性预测器，$\\boldsymbol{\\beta}$ 表示参数向量。\n\n3. 在原假设 $H_0: \\beta_c = 0, \\beta_s = 0$ 与备择假设（两者中至少有一个非零）下，计算似然比统计量，以检验一次谐波的显著性：\n   $$\n   T = 2\\left(\\ell_{\\text{full}} - \\ell_{\\text{reduced}}\\right).\n   $$\n   在正则性条件和 $H_0$ 下，$T$ 渐近服从自由度为 $k=2$ 的卡方分布。使用自由度为 $k=2$ 的卡方生存函数计算 $p$ 值，并在显著性水平 $\\alpha = 0.05$ 下判断显著性。\n\n你的程序必须从基本原理出发，为泊松 GLM 实现 IRLS。具体来说，从一个初始参数向量开始，使用泊松对数连接模型的 Fisher 评分步骤来更新参数估计：\n- 在每次迭代中，计算 $\\eta_i = \\mathbf{x}_i^\\top \\boldsymbol{\\beta}$，$\\mu_i = \\exp(\\eta_i)$，权重 $w_i = \\mu_i$，工作响应 $z_i = \\eta_i + \\frac{y_i - \\mu_i}{\\mu_i}$，并求解加权最小二乘系统\n$$\n\\left(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\\right) \\boldsymbol{\\beta}^{\\text{new}} = \\mathbf{X}^\\top \\mathbf{W} \\mathbf{z},\n$$\n其中 $\\mathbf{X}$ 是设计矩阵，$\\mathbf{W} = \\mathrm{diag}(w_i)$，$\\mathbf{z}$ 是工作响应向量。迭代直至参数范数收敛。\n\n角度单位：所有角度都必须以弧度为单位。\n\n测试套件规范：\n实现以下四个数据集，每个数据集由元组 $(n, \\beta_0, A_1, \\phi_1, A_2, \\phi_2)$ 指定，其中 $n$ 是角度数量，$\\beta_0$ 是基线对数率，$A_1$ 和 $\\phi_1$ 分别是一次谐波的振幅和偏好方向，$A_2$ 和 $\\phi_2$ 分别是二次谐波的振幅和偏好方向。在所有数据集中使用相同的确定性随机种子。每个数据集的数据生成必须使用指定的 $\\lambda_i$ 公式。\n\n- 情况 1（具有强一次谐波调谐的一般情况）：$(60, 1.2, 0.8, 0.7, 0.3, 2.0)$\n- 情况 2（无一次谐波调谐但有强二次谐波）：$(60, 1.2, 0.0, 1.0, 0.9, 0.5)$\n- 情况 3（弱一次谐波、无二次谐波的小样本）：$(24, 0.1, 0.2, 2.5, 0.0, 1.0)$\n- 情况 4（两种谐波都存在的中等样本）：$(36, 2.0, 0.4, -1.0, 0.6, 1.7)$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个测试用例的结果，形式为方括号括起来的逗号分隔列表。列表中的每个元素都是一个布尔值，表示在该测试用例中，一次谐波在显著性水平 $\\alpha = 0.05$ 下是否显著（即 $p  0.05$），顺序与上述测试用例一致。例如：\"[True,False,True,False]\"。不应打印任何其他文本。",
            "solution": "本任务旨在实现一个统计程序，用于检验合成神经元脉冲计数数据中方向调谐的显著性。这包括从已知的泊松过程中生成数据，使用迭代重加权最小二乘法 (IRLS) 算法的自定义实现来拟合两个嵌套的广义线性模型 (GLM)，并执行似然比检验。整个过程基于统计建模和假设检验的基本原理。\n\n### 1. 数据生成\n\n第一步是生成合成的脉冲计数数据。对于每个数据集，一组 $n$ 个角度 $\\theta_i$ 在区间 $[0, 2\\pi)$ 上均匀分布。每个角度的脉冲计数 $y_i$ 是从泊松分布 $y_i \\sim \\text{Poisson}(\\lambda_i)$ 中随机抽取的。平均发放率 $\\lambda_i$ 是角度 $\\theta_i$ 的函数，由一个包含角度的一阶和二阶谐波的对数线性模型定义：\n$$\n\\lambda_i = \\exp\\left(\\beta_0 + A_1 \\cos(\\theta_i - \\phi_1) + A_2 \\cos\\left(2(\\theta_i - \\phi_2)\\right)\\right)\n$$\n在此，$\\beta_0$ 是基线对数发放率。$A_1$ 和 $\\phi_1$ 分别是一次谐波分量的振幅和偏好方向（相位），通常用于模拟单峰调谐。$A_2$ 和 $\\phi_2$ 是二次谐波的振幅和偏好方向，可以捕捉双峰调谐模式。所有角度量均以弧度为单位。数据生成需要一个确定性的随机数生成器以保证可复现性。\n\n### 2. 模型设定\n\n为了检验一次谐波分量的显著性，我们拟合两个嵌套的泊松 GLM，其对数连接函数为 $\\log(\\mu_i) = \\eta_i$，其中 $\\mu_i = E[y_i]$，$\\eta_i$ 是线性预测器。\n\n线性预测器是使用三角恒等式构建的。项 $A_k \\cos(k(\\theta_i - \\phi_k))$ 可以展开为 $A_k (\\cos(k\\theta_i)\\cos(k\\phi_k) + \\sin(k\\theta_i)\\sin(k\\phi_k))$。这是 $\\cos(k\\theta_i)$ 和 $\\sin(k\\theta_i)$ 的线性组合，其系数取决于 $A_k$ 和 $\\phi_k$。\n\n**完整模型 ($M_{\\text{full}}$)：** 该模型同时包含一次和二次谐波。其线性预测器为：\n$$\n\\eta_i^{\\text{full}} = \\beta_0 + \\beta_c \\cos(\\theta_i) + \\beta_s \\sin(\\theta_i) + \\gamma_c \\cos(2\\theta_i) + \\gamma_s \\sin(2\\theta_i)\n$$\n这对应于一个设计矩阵 $\\mathbf{X}_{\\text{full}}$，包含五列：一个截距项 ($1$)、$\\cos(\\theta_i)$、$\\sin(\\theta_i)$、$\\cos(2\\theta_i)$ 和 $\\sin(2\\theta_i)$。参数向量为 $\\boldsymbol{\\beta}_{\\text{full}} = [\\beta_0, \\beta_c, \\beta_s, \\gamma_c, \\gamma_s]^\\top$。\n\n**简化模型 ($M_{\\text{red}}$)：** 该模型嵌套在完整模型之内，代表原假设，即一次谐波分量不存在（$A_1=0$，意味着 $\\beta_c = 0$ 且 $\\beta_s = 0$）。其线性预测器省略了一次谐波项：\n$$\n\\eta_i^{\\text{red}} = \\beta_0 + \\gamma_c \\cos(2\\theta_i) + \\gamma_s \\sin(2\\theta_i)\n$$\n相应的设计矩阵 $\\mathbf{X}_{\\text{red}}$ 有三列：一个截距项、$\\cos(2\\theta_i)$ 和 $\\sin(2\\theta_i)$。参数向量为 $\\boldsymbol{\\beta}_{\\text{red}} = [\\beta_0, \\gamma_c, \\gamma_s]^\\top$。\n\n### 3. 通过迭代重加权最小二乘法 (IRLS) 进行模型拟合\n\n两个模型的参数都是通过最大化泊松对数似然来估计的。对于泊松 GLM，其对数似然函数（忽略与参数 $\\boldsymbol{\\beta}$ 无关的常数项）为：\n$$\n\\ell(\\boldsymbol{\\beta}) = \\sum_{i=1}^{n} \\left( y_i \\eta_i - \\exp(\\eta_i) \\right) = \\sum_{i=1}^{n} \\left( y_i (\\mathbf{x}_i^\\top \\boldsymbol{\\beta}) - \\exp(\\mathbf{x}_i^\\top \\boldsymbol{\\beta}) \\right)\n$$\n其中 $\\mathbf{x}_i^\\top$ 是设计矩阵 $\\mathbf{X}$ 的第 $i$ 行。IRLS 算法是一种寻找 $\\boldsymbol{\\beta}$ 的最大似然估计的数值方法。它通过迭代求解一系列加权最小二乘问题来实现。对于具有规范对数连接的泊松模型，每次迭代中 $\\boldsymbol{\\beta}$ 的更新步骤由 Fisher 评分算法给出，在此情况下它等价于 Newton-Raphson 方法。\n\n该算法流程如下：\n1.  初始化参数向量 $\\boldsymbol{\\beta}$，例如，初始化为零向量。\n2.  迭代直至收敛：\n    a.  为每个观测值计算线性预测器：$\\boldsymbol{\\eta} = \\mathbf{X} \\boldsymbol{\\beta}$。\n    b.  使用逆连接函数计算估计的均值响应：$\\boldsymbol{\\mu} = \\exp(\\boldsymbol{\\eta})$。\n    c.  定义对角权重矩阵 $\\mathbf{W}$，其对角元素为 $w_i = \\text{Var}(y_i) / (\\text{g}'(\\mu_i))^2$。对于泊松分布，$\\text{Var}(y_i)=\\mu_i$；对于对数连接函数，$g(\\mu_i)=\\log(\\mu_i)$，因此 $g'(\\mu_i)=1/\\mu_i$。这得到 $w_i = \\mu_i / (1/\\mu_i)^2 = \\mu_i^2 / \\mu_i = \\mu_i$。\n    d.  计算工作响应（或“调整后的因变量”）：$z_i = \\eta_i + (y_i - \\mu_i) / \\mu_i$。\n    e.  求解加权最小二乘系统以获得新的参数估计 $\\boldsymbol{\\beta}^{\\text{new}}$：\n       $$\n       \\left(\\mathbf{X}^\\top \\mathbf{W} \\mathbf{X}\\right) \\boldsymbol{\\beta}^{\\text{new}} = \\mathbf{X}^\\top \\mathbf{W} \\mathbf{z}\n       $$\n    f.  通过检查参数变化的范数 $\\|\\boldsymbol{\\beta}^{\\text{new}} - \\boldsymbol{\\beta}\\|$ 来判断是否收敛。如果该范数低于指定的容差，则终止迭代。否则，更新 $\\boldsymbol{\\beta} \\leftarrow \\boldsymbol{\\beta}^{\\text{new}}$ 并继续。\n\n此过程分别应用于拟合完整模型和简化模型，从而分别得到参数估计值 $\\hat{\\boldsymbol{\\beta}}_{\\text{full}}$ 和 $\\hat{\\boldsymbol{\\beta}}_{\\text{red}}$。\n\n### 4. 似然比检验\n\n利用两个模型的最大化对数似然值 $\\ell_{\\text{full}} = \\ell(\\hat{\\boldsymbol{\\beta}}_{\\text{full}})$ 和 $\\ell_{\\text{red}} = \\ell(\\hat{\\boldsymbol{\\beta}}_{\\text{red}})$，我们可以检验原假设 $H_0: \\beta_c = \\beta_s = 0$。似然比检验 (LRT) 统计量为：\n$$\nT = 2(\\ell_{\\text{full}} - \\ell_{\\text{reduced}})\n$$\n根据 Wilks 定理，在原假设下，$T$ 渐近服从卡方 ($\\chi^2$) 分布。该分布的自由度 $k$ 是完整模型和简化模型之间的参数数量之差。在本例中，$k = 5 - 3 = 2$。\n\n$p$ 值是在原假设为真的前提下，观测到等于或比当前计算出的检验统计量更极端的统计量的概率。这可以通过 $\\chi^2_2$ 分布的生存函数（1 减去累积分布函数）来计算：\n$$\np = P(\\chi^2_2 \\ge T)\n$$\n最后，我们将 $p$ 值与预定义的显著性水平 $\\alpha = 0.05$ 进行比较。如果 $p  0.05$，我们拒绝原假设，并得出一次谐波分量具有统计显著性的结论。否则，我们未能拒绝原假设。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef fit_poisson_glm_irls(y, X, max_iter=100, tol=1e-8):\n    \"\"\"\n    Fits a Poisson GLM with a log link using IRLS from first principles.\n\n    Args:\n        y (np.ndarray): The response variable (spike counts), shape (n_samples,).\n        X (np.ndarray): The design matrix, shape (n_samples, n_features).\n        max_iter (int): Maximum number of iterations for the IRLS algorithm.\n        tol (float): Convergence tolerance for the norm of parameter updates.\n\n    Returns:\n        tuple[np.ndarray, float]: Tuple containing the fitted coefficients (beta)\n                                  and the maximized log-likelihood.\n    \"\"\"\n    # Initialize beta coefficients to zero\n    beta = np.zeros(X.shape[1])\n    \n    for _ in range(max_iter):\n        eta = X @ beta\n        # Clamp eta to prevent numerical overflow/underflow in np.exp\n        eta = np.clip(eta, -25, 25)\n        mu = np.exp(eta)\n        \n        # Guard against division by zero if mu is very small\n        mu[mu  1e-10] = 1e-10\n        \n        # Compute weights and working response for Poisson with log link\n        weights = mu\n        z = eta + (y - mu) / mu\n        \n        # Form and solve the weighted least squares system\n        # X.T @ W @ X * beta_new = X.T @ W @ z\n        # W is a diagonal matrix, so we can use broadcasting for efficiency\n        X_T_W = X.T * weights[np.newaxis, :]  # (p, n)\n        \n        # Left-hand side: Hessian or Fisher Information Matrix\n        hessian = X_T_W @ X  # (p, p)\n        \n        # Right-hand side\n        rhs = X_T_W @ z  # (p,)\n        \n        try:\n            beta_new = np.linalg.solve(hessian, rhs)\n        except np.linalg.LinAlgError:\n            # If solver fails, use pseudo-inverse as a fallback\n            beta_new = np.linalg.pinv(hessian) @ rhs\n\n        # Check for convergence\n        if np.linalg.norm(beta_new - beta)  tol:\n            beta = beta_new\n            break\n        \n        beta = beta_new\n    \n    # Calculate final log-likelihood\n    final_eta = X @ beta\n    log_likelihood = np.sum(y * final_eta - np.exp(final_eta))\n    \n    return beta, log_likelihood\n\n\ndef solve():\n    \"\"\"\n    Main function to run the tuning analysis for all specified test cases.\n    \"\"\"\n    # Test suite specification: (n, beta0, A1, phi1, A2, phi2)\n    test_cases = [\n        (60, 1.2, 0.8, 0.7, 0.3, 2.0),\n        (60, 1.2, 0.0, 1.0, 0.9, 0.5),\n        (24, 0.1, 0.2, 2.5, 0.0, 1.0),\n        (36, 2.0, 0.4, -1.0, 0.6, 1.7)\n    ]\n    \n    # Use a deterministic random seed for reproducibility\n    rng = np.random.default_rng(seed=42)\n    alpha = 0.05\n    results = []\n\n    for n, beta0, A1, phi1, A2, phi2 in test_cases:\n        # 1. Generate synthetic data\n        theta = np.linspace(0, 2 * np.pi, n, endpoint=False)\n        \n        log_lambda = beta0 + A1 * np.cos(theta - phi1) + A2 * np.cos(2 * (theta - phi2))\n        lambda_i = np.exp(log_lambda)\n        \n        y = rng.poisson(lam=lambda_i)\n        \n        # 2. Define design matrices for reduced and full models\n        # Reduced model: Intercept, cos(2*theta), sin(2*theta)\n        X_red = np.c_[np.ones(n), np.cos(2 * theta), np.sin(2 * theta)]\n        \n        # Full model: Intercept, cos/sin(theta), cos/sin(2*theta)\n        X_full = np.c_[\n            np.ones(n), \n            np.cos(theta), \n            np.sin(theta), \n            np.cos(2 * theta), \n            np.sin(2 * theta)\n        ]\n        \n        # 3. Fit both models using IRLS\n        _, ll_red = fit_poisson_glm_irls(y, X_red)\n        _, ll_full = fit_poisson_glm_irls(y, X_full)\n        \n        # 4. Perform the Likelihood Ratio Test\n        # Test statistic\n        lrt_statistic = 2 * (ll_full - ll_red)\n        \n        # Degrees of freedom: difference in number of parameters\n        dof = X_full.shape[1] - X_red.shape[1]\n        \n        # Compute p-value from chi-square survival function\n        p_value = chi2.sf(lrt_statistic, df=dof)\n        \n        # 5. Decide significance\n        is_significant = p_value  alpha\n        results.append(is_significant)\n        \n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}