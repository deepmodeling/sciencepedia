{
    "hands_on_practices": [
        {
            "introduction": "在现代神经科学中，我们通常同时记录大量神经元的活动。这项实践将指导你如何使用高效的矩阵运算，对大规模数据集进行交叉相关分析和置换校正，从而避免在多个神经元对和试验中进行缓慢的循环计算，这是神经数据分析的一项关键技能。",
            "id": "4192301",
            "problem": "给定多个神经元在重复试验和时间箱中的分箱脉冲计数数据。目标是使用矩阵运算，以完全向量化的方式为许多神经元对和试验计算随机重排校正的互相关图。这里提到的随机重排校正是“位移预测子”（shift predictor），它基于试验的循环位移。任务是从第一性原理推导出一个算法，并用代码实现它，该代码仅使用数组操作以及在试验和神经元对上的广播，而不使用对试验或神经元对的显式 Python 循环。\n\n从基本定义开始。设 $N_A$ 表示群体 A 中的神经元数量， $N_B$ 表示群体 B 中的神经元数量。设 $R$ 表示重复试验的次数， $T$ 表示时间箱的数量。设 $L$ 是要考虑的最大绝对延迟（以时间箱为单位），其中 $0 \\le L  T$。分箱脉冲计数数组为：\n- $X \\in \\mathbb{R}^{N_A \\times R \\times T}$，其中 $X_{i,r,t}$ 是群体 A 中神经元 $i$ 在试验 $r$ 的时间箱 $t$ 处的脉冲计数。\n- $Y \\in \\mathbb{R}^{N_B \\times R \\times T}$，为群体 B 类似定义。\n\n设 $\\mathcal{P}$ 是一个包含 $P$ 个有序神经元索引对 $(i,j)$ 的列表，其中 $i \\in \\{0,\\dots,N_A-1\\}$ 且 $j \\in \\{0,\\dots,N_B-1\\}$，表示为一个形状为 $P \\times 2$ 的数组。\n\n定义单个对 $(i,j)$ 在延迟 $\\tau \\in \\{-L, \\dots, 0, \\dots, +L\\}$ 处的原始互相关图，通过无偏（按箱、按试验平均）估计量：\n- 对于 $\\tau \\ge 0$，\n$$\nC_{ij}(\\tau) \\;=\\; \\frac{1}{R \\, (T - \\tau)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-\\tau-1} X_{i,r,t} \\; Y_{j,r,t+\\tau}.\n$$\n- 对于 $\\tau  0$，\n$$\nC_{ij}(\\tau) \\;=\\; \\frac{1}{R \\, (T - |\\tau|)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-|\\tau|-1} X_{i,r,t+|\\tau|} \\; Y_{j,r,t}.\n$$\n\n通过将群体 B 的试验索引循环位移 $+1$（即 $\\sigma(r) = (r+1) \\bmod R$）来定义位移预测子（随机重排预测子）互相关图，同时保持群体 A 不变。将试验位移后的数组表示为 $Y^{\\mathrm{shift}}$，其中 $Y^{\\mathrm{shift}}_{j,r,t} = Y_{j,(r+1)\\bmod R,t}$。那么：\n- 对于 $\\tau \\ge 0$，\n$$\nS_{ij}(\\tau) \\;=\\; \\frac{1}{R \\, (T - \\tau)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-\\tau-1} X_{i,r,t} \\; Y^{\\mathrm{shift}}_{j,r,t+\\tau}.\n$$\n- 对于 $\\tau  0$，\n$$\nS_{ij}(\\tau) \\;=\\; \\frac{1}{R \\, (T - |\\tau|)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-|\\tau|-1} X_{i,r,t+|\\tau|} \\; Y^{\\mathrm{shift}}_{j,r,t}.\n$$\n\n随机重排校正的互相关图是差值\n$$\n\\tilde{C}_{ij}(\\tau) \\;=\\; C_{ij}(\\tau) \\;-\\; S_{ij}(\\tau),\n$$\n对于每个 $(i,j) \\in \\mathcal{P}$ 和每个延迟 $\\tau \\in \\{-L,\\dots,+L\\}$。\n\n您的实现必须：\n- 完全按照规定使用数据结构：形状为 $N_A \\times R \\times T$ 的 $X$，形状为 $N_B \\times R \\times T$ 的 $Y$，以及形状为 $P \\times 2$ 的 $\\mathcal{P}$。\n- 对所有 $(i,j) \\in \\mathcal{P}$ 和所有 $\\tau \\in \\{-L,\\dots,+L\\}$，使用在神经元对和试验上向量化的矩阵运算来计算 $C_{ij}(\\tau)$ 和 $S_{ij}(\\tau)$。您可以使用一个关于 $\\tau$ 的循环，但不得使用关于 $r$ 或 $(i,j)$ 的显式 Python 循环。\n- 使用如上定义的除数 $R \\, (T - |\\tau|)$进行归一化。\n- 对于每个测试用例，返回一个标量：$\\mathcal{P}$ 中第一个对在所有 $\\tau \\in \\{-L,\\dots,+L\\}$ 上的 $\\tilde{C}_{ij}(\\tau)$ 的最大值，四舍五入到 $6$ 位小数。此标量必须是 `float` 类型。\n\n测试套件。您的程序必须在内部定义以下测试用例并按顺序运行它们：\n- 用例 1（包含刺激锁定成分和试验内同时事件的正常路径）：\n  - $N_A = 2$, $N_B = 2$, $R = 4$, $T = 16$, $L = 3$, $\\mathcal{P} = \\big[ (0,1) \\big]$。\n  - 构建 $X$ 和 $Y$，除以下位置外均为零：\n    - 对于所有 $r \\in \\{0,1,2,3\\}$，设置 $X_{0,r,5} = 1$ 和 $Y_{1,r,5} = 1$（刺激锁定的事件）。\n    - 此外，设置 $X_{0,2,8} = 1$ 和 $Y_{1,2,8} = 1$（仅在试验 $r = 2$ 上的一个额外同时事件）。所有其他条目保持为 $0$。\n  - 预期定性行为：位移预测子移除了刺激锁定的零延迟相关；试验内的额外同时事件保留在 $\\tilde{C}_{01}(0)$ 中。返回的标量是 $\\tilde{C}_{01}(\\tau)$ 在 $\\tau \\in \\{-3,\\dots,+3\\}$ 上的最大值。\n- 用例 2（边界情况：$A$ 中没有脉冲）：\n  - $N_A = 1$, $N_B = 1$, $R = 3$, $T = 10$, $L = 4$, $\\mathcal{P} = \\big[ (0,0) \\big]$。\n  - 构建 $X$ 为全零。构建 $Y$ 为任意固定的非零模式，例如，设置 $Y_{0,0,1} = 1$, $Y_{0,1,5} = 1$, $Y_{0,2,7} = 1$，所有其他条目为 $0$。\n  - 预期行为：所有相关都为 $0$，因此返回的标量是 $0.0$。\n- 用例 3（边界情况：单个试验）：\n  - $N_A = 1$, $N_B = 1$, $R = 1$, $T = 8$, $L = 2$, $\\mathcal{P} = \\big[ (0,0) \\big]$。\n  - 构建相同的 $X$ 和 $Y$，其中 $X_{0,0,2} = 1$, $X_{0,0,6} = 1$ 和 $Y_{0,0,2} = 1$, $Y_{0,0,6} = 1$，所有其他条目为 $0$。\n  - 预期行为：位移预测子等于原始相关（因为在 $R=1$ 上的试验位移是恒等操作），因此返回的标量是 $0.0$。\n- 用例 4（边缘延迟覆盖：最大延迟 $L = T - 1$）：\n  - $N_A = 1$, $N_B = 1$, $R = 2$, $T = 4$, $L = 3$, $\\mathcal{P} = \\big[ (0,0) \\big]$。\n  - 构建 $X$ 和 $Y$ 具有跨试验的反同步模式：\n    - 设置 $X_{0,0,0} = 1$, $X_{0,1,3} = 1$。\n    - 设置 $Y_{0,0,3} = 1$, $Y_{0,1,0} = 1$。\n    - 所有其他条目均为 $0$。\n  - 预期行为：在位移预测子校正后，在 $\\tau = +3$ 处仍存在一个强的正校正相关，因此返回的标量是正数。\n\n最终输出格式。您的程序应生成单行输出，其中包含测试套件的结果，形式为方括号内由逗号分隔的列表，其中每个元素是每个测试用例中 $\\mathcal{P}$ 的第一个对的 `float` 类型结果，四舍五入到 $6$ 位小数，并按顺序排列。例如，输出应为 $[x_1,x_2,x_3,x_4]$ 的形式，其中每个 $x_k$ 是一个 `float`。\n\n角度和物理单位不适用于此问题；所有延迟和时间箱都是离散箱中的计数。确保您的实现是自包含的，并且仅使用矩阵运算进行对和试验的聚合，如所指定，并遵守上面给出的归一化常数。",
            "solution": "### 步骤 1：提取给定信息\n\n问题提供了以下数据、定义和约束：\n- **数据结构**：\n  - 群体 A 的分箱脉冲计数：$X \\in \\mathbb{R}^{N_A \\times R \\times T}$，其中 $X_{i,r,t}$ 是群体 A 中神经元 $i$ 在试验 $r$ 的时间箱 $t$ 处的脉冲计数。\n  - 群体 B 的分箱脉冲计数：$Y \\in \\mathbb{R}^{N_B \\times R \\times T}$，定义类似。\n- **参数**：\n  - $N_A$：群体 A 中的神经元数量。\n  - $N_B$：群体 B 中的神经元数量。\n  - $R$：重复试验的次数。\n  - $T$：时间箱的数量。\n  - $L$：最大绝对延迟，其中 $0 \\le L  T$。\n- **神经元对**：一个包含 $P$ 个有序神经元索引对 $(i,j)$ 的列表 $\\mathcal{P}$，其中 $i \\in \\{0,\\dots,N_A-1\\}$ 且 $j \\in \\{0,\\dots,N_B-1\\}$，表示为一个形状为 $P \\times 2$ 的数组。\n- **定义**：\n  - **原始互相关图 ($C_{ij}(\\tau)$)**，对于 $\\tau \\in \\{-L, \\dots, +L\\}$：\n    - 对于 $\\tau \\ge 0$：$C_{ij}(\\tau) = \\frac{1}{R \\, (T - \\tau)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-\\tau-1} X_{i,r,t} \\; Y_{j,r,t+\\tau}$。\n    - 对于 $\\tau  0$：$C_{ij}(\\tau) = \\frac{1}{R \\, (T - |\\tau|)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-|\\tau|-1} X_{i,r,t+|\\tau|} \\; Y_{j,r,t}$。\n  - **位移预测子 ($S_{ij}(\\tau)$)**：\n    - 试验位移后的数组 $Y^{\\mathrm{shift}}$ 定义为 $Y^{\\mathrm{shift}}_{j,r,t} = Y_{j,(r+1)\\bmod R,t}$。\n    - 对于 $\\tau \\ge 0$：$S_{ij}(\\tau) = \\frac{1}{R \\, (T - \\tau)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-\\tau-1} X_{i,r,t} \\; Y^{\\mathrm{shift}}_{j,r,t+\\tau}$。\n    - 对于 $\\tau  0$：$S_{ij}(\\tau) = \\frac{1}{R \\, (T - |\\tau|)} \\sum_{r=0}^{R-1} \\sum_{t=0}^{T-|\\tau|-1} X_{i,r,t+|\\tau|} \\; Y^{\\mathrm{shift}}_{j,r,t}$。\n  - **随机重排校正的互相关图 ($\\tilde{C}_{ij}(\\tau)$)**：$\\tilde{C}_{ij}(\\tau) = C_{ij}(\\tau) - S_{ij}(\\tau)$。\n- **实现约束**：\n  - 必须使用指定的数据结构。\n  - 必须对 $\\mathcal{P}$ 中的所有对和 $\\{-L,\\dots,+L\\}$ 中的所有延迟，使用在神经元对和试验上向量化的矩阵运算来计算 $C_{ij}(\\tau)$ 和 $S_{ij}(\\tau)$。\n  - 禁止使用关于试验 $r$ 或对 $(i,j)$ 的显式 Python 循环。允许使用关于延迟 $\\tau$ 的循环。\n  - 必须使用指定的归一化因子 $1 / (R \\, (T - |\\tau|))$。\n- **输出要求**：对于每个测试用例，返回 $\\mathcal{P}$ 中第一个对在所有延迟上的 $\\tilde{C}_{ij}(\\tau)$ 的最大值，四舍五入到 6 位小数，作为 `float` 类型。最终的程序输出是这些标量的列表。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准评估问题陈述。\n\n- **科学基础**：该问题在计算神经科学中有坚实的基础。“位移预测子”是一种标准且基础的技术，用于校正互相关图中的刺激锁定或缓慢共变成分，旨在分离出由直接的、试验内的相互作用产生的相关性。所提供的无偏估计量公式是正确的。\n- **适定性**：该问题在数学上是适定的。所有变量、常数和函数都得到了精确的规定。输入被清晰描述，期望的输出是一个唯一可确定的量。条件 $L  T$ 确保了归一化因子的分母 $T-|\\tau|$ 始终至少为 $1$，从而防止了除以零。\n- **客观性**：问题以精确、客观、数学化的语言陈述，没有任何主观性或歧义。\n- **缺陷清单**：\n  1.  **科学或事实上的不健全**：无。该方法是标准实践。\n  2.  **非形式化或不相关**：无。该问题是指定主题的直接且可形式化的实现。\n  3.  **不完整或矛盾的设置**：无。所有必要信息都已提供且内部一致。\n  4.  **不切实际或不可行**：无。该任务是神经科学数据分析中一个常见的计算问题。\n  5.  **病态或结构不良**：无。存在唯一解且可计算。\n  6.  **伪深刻、琐碎或同义反复**：无。向量化的要求构成了一个不平凡的算法挑战。\n  7.  **超出科学可验证性**：无。结果在数值上是可验证的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。将着手开发解决方案。\n\n### 基于原理的设计和算法推导\n\n目标是为一组神经元对 $\\mathcal{P}$ 计算随机重排校正的互相关图 $\\tilde{C}_{ij}(\\tau)$，其方式是在对和试验上都进行向量化。问题的核心在于如何有效地计算 $C_{ij}(\\tau)$ 和 $S_{ij}(\\tau)$ 定义中出现的求和，而无需显式循环。\n\n设对索引数组为 $\\mathcal{P}$，形状为 $P \\times 2$。群体 A 的索引是 $\\mathcal{P}[:,0]$，群体 B 的索引是 $\\mathcal{P}[:,1]$。\n\n首先，我们使用高级索引来同时选择所有指定对的时间序列数据。\n令 `indices_A = P[:,0]` 和 `indices_B = P[:,1]`。\n`X_pairs = X[indices_A, :, :]`\n`Y_pairs = Y[indices_B, :, :]`\n这将创建两个新数组 `X_pairs` 和 `Y_pairs`，它们的形状都是 $P \\times R \\times T$。这些数组的第一个维度现在对应于对的列表，有效地将每对的数据堆叠起来。\n\n位移预测子项需要一个试验位移版的 $Y$ 数据，$Y^{\\mathrm{shift}}$。这可以通过将试验轴（轴 1）循环位移一个位置来实现。`numpy.roll` 函数对此非常理想：\n`Y_shift = np.roll(Y, shift=-1, axis=1)`\n然后选择指定对的相应数据：\n`Y_shift_pairs = Y_shift[indices_B, :, :]`\n\n现在可以在一个关于允许的延迟 $\\tau \\in \\{-L, \\dots, +L\\}$ 的循环中进行计算。对于每个延迟 $\\tau$，我们必须一次性为所有对和试验计算在试验 $r$ 和时间 $t$ 上的双重求和。\n\n让我们分析 $\\tau \\ge 0$ 的情况。核心操作是乘积之和：$\\sum_{r,t} X_{i,r,t} Y_{j,r,t+\\tau}$。这个操作必须一次性为所有对和试验执行。这是一个批处理的点积。我们可以通过切片和逐元素乘法来实现：\n1.  对 `X_pairs` 进行切片以获取相关的时间窗口：`X_slice = X_pairs[:, :, 0:T-\\tau]`。其形状为 $P \\times R \\times (T-\\tau)$。\n2.  对 `Y_pairs` 进行切片以获取时间位移后的窗口：`Y_slice = Y_pairs[:, :, \\tau:T]`。其形状也为 $P \\times R \\times (T-\\tau)$。\n3.  逐元素乘积 `X_slice * Y_slice` 产生一个形状为 $P \\times R \\times (T-\\tau)$ 的数组，其中索引 $(p, r, t')$ 处的元素是 $X_{i_p,r,t'} Y_{j_p,r,t'+\\tau}$。\n4.  然后可以使用 `numpy.sum` 在最后两个轴（试验和时间）上求和来计算所需的 $r$ 和 $t$ 的总和：`raw_sum = np.sum(X_slice * Y_slice, axis=(1, 2))`。结果是一个形状为 $(P,)$ 的数组，包含每个对的未归一化相关总和。\n\n使用 `Y_shift_pairs` 应用相同的过程来计算未归一化的随机重排预测子总和 `shuffled_sum`。\n`Y_shift_slice = Y_shift_pairs[:, :, \\tau:T]`\n`shuffled_sum = np.sum(X_slice * Y_shift_slice, axis=(1, 2))`\n\n$\\tau  0$ 的情况是类似的。设 $\\tau' = |\\tau|$。求和为 $\\sum_{r,t} X_{i,r,t+\\tau'} Y_{j,r,t}$。相应地调整切片：\n1.  `X_slice = X_pairs[:, :, \\tau':T]`\n2.  `Y_slice = Y_pairs[:, :, 0:T-\\tau']`\n计算的其余部分遵循相同的逻辑。\n\n对于每个延迟 $\\tau$，所有对的随机重排校正互相关图计算如下：\n$\\tilde{C}(\\tau) = (\\text{raw\\_sum} - \\text{shuffled\\_sum}) \\times \\frac{1}{R \\, (T - |\\tau|)}$。\n这将产生一个长度为 $P$ 的向量。\n\n将每个延迟 $\\tau$ 的这些向量收集到一个形状为 $P \\times (2L+1)$ 的结果矩阵 $\\tilde{C}$ 中。最后，对于第一个对（索引 0），我们找到在所有计算的延迟中的最大值。整个过程通过将对和试验的循环委托给高度优化的 NumPy 操作，遵守了向量化约束。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_corrected_crosscorr(X, Y, P_indices, L):\n    \"\"\"\n    Computes the shuffle-corrected cross-correlogram for specified neuron pairs.\n\n    This implementation is fully vectorized over neuron pairs and trials.\n    A Python loop is used only for iterating over time lags, as permitted.\n    \"\"\"\n    # Extract shape parameters from the input arrays.\n    # Note: The problem statement guarantees N_A, N_B = 1, so inputs are 3D.\n    _NA, R, T = X.shape\n    _NB = Y.shape[0]\n\n    # Use advanced indexing to select data for all specified pairs at once.\n    # This creates views of the data, avoiding explicit loops over pairs.\n    indices_A = P_indices[:, 0]\n    indices_B = P_indices[:, 1]\n    X_pairs = X[indices_A]  # Shape: (P, R, T)\n    Y_pairs = Y[indices_B]  # Shape: (P, R, T)\n\n    # Create the trial-shifted version of Y for the shuffle predictor.\n    # np.roll performs a circular shift along the specified axis.\n    # axis=1 is the trial axis. shift=-1 corresponds to (r+1) mod R.\n    Y_shift = np.roll(Y, shift=-1, axis=1)\n    Y_shift_pairs = Y_shift[indices_B] # Shape: (P, R, T)\n\n    # Initialize storage for the results.\n    num_pairs = P_indices.shape[0]\n    lag_range = np.arange(-L, L + 1)\n    num_lags = 2 * L + 1\n    C_tilde = np.zeros((num_pairs, num_lags), dtype=np.float64)\n\n    # Loop over time lags tau.\n    for i, tau in enumerate(lag_range):\n        abs_tau = abs(tau)\n\n        # The problem constraint L  T ensures T - abs_tau = 1,\n        # so no division by zero will occur.\n        norm = 1.0 / (R * (T - abs_tau))\n\n        # Select time slices based on the sign of the lag.\n        if tau = 0:\n            # For tau = 0, we correlate X(t) with Y(t+tau).\n            X_slice = X_pairs[:, :, 0 : T - tau]\n            Y_slice = Y_pairs[:, :, tau : T]\n            Y_shift_slice = Y_shift_pairs[:, :, tau : T]\n        else:  # tau  0\n            # For tau  0, we correlate X(t+|tau|) with Y(t).\n            X_slice = X_pairs[:, :, abs_tau : T]\n            Y_slice = Y_pairs[:, :, 0 : T - abs_tau]\n            Y_shift_slice = Y_shift_pairs[:, :, 0 : T - abs_tau]\n\n        # Vectorized computation of sums.\n        # Element-wise product followed by summing over trial and time axes.\n        raw_sum = np.sum(X_slice * Y_slice, axis=(1, 2))\n        shuffled_sum = np.sum(X_slice * Y_shift_slice, axis=(1, 2))\n\n        # Compute and store the shuffle-corrected correlogram for the current lag tau.\n        C_tilde[:, i] = (raw_sum - shuffled_sum) * norm\n\n    # Extract the maximum value across all lags for the first pair in the list.\n    if num_pairs  0:\n        max_val_first_pair = np.max(C_tilde[0, :])\n    else:\n        # Handle case with no pairs, though test cases prevent this.\n        max_val_first_pair = 0.0\n\n    # Return the result rounded to 6 decimal places as a float.\n    return round(max_val_first_pair, 6)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = []\n\n    # Case 1: Happy path\n    N_A1, N_B1, R1, T1, L1 = 2, 2, 4, 16, 3\n    P1 = np.array([[0, 1]])\n    X1 = np.zeros((N_A1, R1, T1))\n    Y1 = np.zeros((N_B1, R1, T1))\n    X1[0, :, 5] = 1\n    Y1[1, :, 5] = 1\n    X1[0, 2, 8] = 1\n    Y1[1, 2, 8] = 1\n    test_cases.append((X1, Y1, P1, L1))\n\n    # Case 2: Boundary (zero spikes in A)\n    N_A2, N_B2, R2, T2, L2 = 1, 1, 3, 10, 4\n    P2 = np.array([[0, 0]])\n    X2 = np.zeros((N_A2, R2, T2))\n    Y2 = np.zeros((N_B2, R2, T2))\n    Y2[0, 0, 1] = 1\n    Y2[0, 1, 5] = 1\n    Y2[0, 2, 7] = 1\n    test_cases.append((X2, Y2, P2, L2))\n\n    # Case 3: Boundary (single trial)\n    N_A3, N_B3, R3, T3, L3 = 1, 1, 1, 8, 2\n    P3 = np.array([[0, 0]])\n    X3 = np.zeros((N_A3, R3, T3))\n    Y3 = np.zeros((N_B3, R3, T3))\n    X3[0, 0, 2] = 1\n    X3[0, 0, 6] = 1\n    Y3[0, 0, 2] = 1\n    Y3[0, 0, 6] = 1\n    test_cases.append((X3, Y3, P3, L3))\n\n    # Case 4: Edge lag coverage (L = T - 1)\n    N_A4, N_B4, R4, T4, L4 = 1, 1, 2, 4, 3\n    P4 = np.array([[0, 0]])\n    X4 = np.zeros((N_A4, R4, T4))\n    Y4 = np.zeros((N_B4, R4, T4))\n    X4[0, 0, 0] = 1\n    X4[0, 1, 3] = 1\n    Y4[0, 0, 3] = 1\n    Y4[0, 1, 0] = 1\n    test_cases.append((X4, Y4, P4, L4))\n\n    results = []\n    for X, Y, P_indices, L in test_cases:\n        result = calculate_corrected_crosscorr(X, Y, P_indices, L)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "除了直接在时域中计算，我们还可以采用一种更高效的方法来获得完整的互相关函数。这项实践将探讨互相关与卷积之间的深刻联系，并展示如何利用快速傅里叶变换（FFT）来快速完成计算。这是一种源于信号处理的强大技术，对于处理长时间序列的神经数据尤为重要。",
            "id": "4192278",
            "problem": "给定在多个试次中记录的两个神经元 $A$ 和 $B$ 的离散时间脉冲序列。每个脉冲序列表示为一个长度为 $T$ 的二进制序列，其中 $1$ 表示在一个时间窗内有脉冲，$0$ 表示没有脉冲。对于试次 $i \\in \\{1,\\dots,R\\}$，将脉冲序列表示为 $a_i[t]$ 和 $b_i[t]$，其中 $t \\in \\{0,\\dots,T-1\\}$。\n\n从离散互相关的定义出发，通过使用基于快速傅里叶变换 (FFT) 的卷积，设计一个算法来计算跨试次平均互相关 $C_{AB}(\\tau)$，该算法对每对序列的计算复杂度为 $O(T \\log T)$。然后调整此算法，以计算跨试次的移位预测量 $S_{AB}(\\tau)$，其定义为在试次索引循环移位的条件下，将试次 $i$ 的神经元 $A$ 与试次 $i+1$ 的神经元 $B$ 配对。\n\n定义：\n- 两个长度为 $T$ 的序列 $x[t]$ 和 $y[t]$ 之间的离散互相关，对于整数延迟 $\\tau$ 定义为\n$$\nC_{xy}(\\tau) = \\sum_{t=0}^{T-1} x[t]\\, y[t+\\tau],\n$$\n其中当 $t+\\tau \\notin \\{0,\\dots,T-1\\}$ 时，$y[t+\\tau]$ 被视为 $0$。\n- 对于 $R$ 个试次，跨试次平均互相关为\n$$\n\\overline{C}_{AB}(\\tau) = \\frac{1}{R} \\sum_{i=1}^{R} C_{a_i b_i}(\\tau).\n$$\n- 在循环试次索引下的移位预测量（重洗矫正基线）为\n$$\nS_{AB}(\\tau) = \\frac{1}{R} \\sum_{i=1}^{R} C_{a_i b_{i+1}}(\\tau),\n$$\n其中 $b_{R+1} \\equiv b_1$。\n- 重洗矫正的互相关为\n$$\nC^{\\mathrm{SC}}_{AB}(\\tau) = \\overline{C}_{AB}(\\tau) - S_{AB}(\\tau).\n$$\n\n要求：\n1. 通过将互相关简化为通过快速傅里叶变换 (FFT) 计算的卷积，推导、实现并使用一个 $O(T \\log T)$ 的方法来计算所有整数延迟 $\\tau \\in \\{-(T-1), \\dots, T-1\\}$ 的 $C_{xy}(\\tau)$。您的方法必须指定补零到适合循环卷积的长度，以重现线性卷积的结果，并且必须确定对应于 $\\tau=0$ 的数组索引。\n2. 按照规定实现调整，对每个所需的配对使用相同的 $O(T \\log T)$ 计算策略来计算 $S_{AB}(\\tau)$。\n3. 对于下方的每个测试用例，使用上述未归一化的计数定义（无发放率归一化），计算重洗矫正互相关的零延迟值 $C^{\\mathrm{SC}}_{AB}(0)$。\n4. 您的程序必须产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,\\dots]$），其中每个 $r_k$ 是一个对应于测试用例 $k$ 的浮点数。\n\n测试套件规范（每个测试用例提供 $T$、试次数 $R$ 以及每个试次的脉冲索引）：\n- 测试用例 1（刺激锁定的脉冲加上试次内同步）：\n    - $T = 16$, $R = 3$。\n    - 神经元 A 试次脉冲索引：\n        - 试次 1：$[3, 8]$\n        - 试次 2：$[3, 7]$\n        - 试次 3：$[3, 9]$\n    - 神经元 B 试次脉冲索引：\n        - 试次 1：$[3, 8]$\n        - 试次 2：$[3, 7]$\n        - 试次 3：$[3, 10]$\n- 测试用例 2（纯粹的刺激锁定；无试次内额外同步）：\n    - $T = 12$, $R = 4$。\n    - 神经元 A 试次脉冲索引：\n        - 试次 1：$[5]$\n        - 试次 2：$[5]$\n        - 试次 3：$[5]$\n        - 试次 4：$[5]$\n    - 神经元 B 试次脉冲索引：\n        - 试次 1：$[5]$\n        - 试次 2：$[5]$\n        - 试次 3：$[5]$\n        - 试次 4：$[5]$\n- 测试用例 3（无重叠）：\n    - $T = 10$, $R = 2$。\n    - 神经元 A 试次脉冲索引：\n        - 试次 1：$[2]$\n        - 试次 2：$[7]$\n    - 神经元 B 试次脉冲索引：\n        - 试次 1：$[4]$\n        - 试次 2：$[9]$\n- 测试用例 4（空脉冲序列边界情况）：\n    - $T = 8$, $R = 2$。\n    - 神经元 A 试次脉冲索引：\n        - 试次 1：$[]$\n        - 试次 2：$[]$\n    - 神经元 B 试次脉冲索引：\n        - 试次 1：$[]$\n        - 试次 2：$[]$\n- 测试用例 5（单个时间窗边界情况，循环移位等于自身）：\n    - $T = 1$, $R = 1$。\n    - 神经元 A 试次脉冲索引：\n        - 试次 1：$[0]$\n    - 神经元 B 试次脉冲索引：\n        - 试次 1：$[0]$\n\n输出规范：\n- 您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须包含值 $[$测试 $1$ 的 $C^{\\mathrm{SC}}_{AB}(0)$，测试 $2$ 的 $C^{\\mathrm{SC}}_{AB}(0)$，测试 $3$ 的 $C^{\\mathrm{SC}}_{AB}(0)$，测试 $4$ 的 $C^{\\mathrm{SC}}_{AB}(0)$，测试 $5$ 的 $C^{\\mathrm{SC}}_{AB}(0)]$。",
            "solution": "该问题被评估为有效。它在科学上基于计算神经科学的标准方法，问题陈述清晰，包含了所有必要的定义和数据，并且表述客观。\n\n主要目标是为几个测试用例计算零延迟重洗矫正互相关 $C^{\\mathrm{SC}}_{AB}(0)$。该量定义为：\n$$\nC^{\\mathrm{SC}}_{AB}(0) = \\overline{C}_{AB}(0) - S_{AB}(0)\n$$\n其中 $\\overline{C}_{AB}(0)$ 是零延迟互相关的跨试次平均值，而 $S_{AB}(0)$ 是移位预测量的零延迟值。\n\n首先，我们解决使用快速傅里叶变换 (FFT) 推导一个计算完整互相关图 $C_{xy}(\\tau)$ 的 $O(T \\log T)$ 算法的要求。离散互相关定义为：\n$$\nC_{xy}(\\tau) = \\sum_{t=0}^{T-1} x[t]\\, y[t+\\tau]\n$$\n这种形式的相关性被称为线性或“有效”互相关，其中对于其域外的索引，$y$ 的值被视为零。该操作与卷积密切相关。两个序列 $f[t]$ 和 $g[t]$ 的离散卷积是 $(f*g)[n] = \\sum_{k} f[k] g[n-k]$。通过将 $x$ 的时间反转版本（比如说 $x_{rev}[t] = x[-t]$）代入与 $y$ 的卷积中，我们得到：\n$$\n(x_{rev} * y)[\\tau] = \\sum_{k} x_{rev}[k] y[\\tau-k] = \\sum_{k} x[-k] y[\\tau-k]\n$$\n令 $m = -k$，我们得到 $\\sum_{m} x[m] y[\\tau+m]$，这正是 $C_{yx}(-\\tau)$ 的定义。一个更直接的恒等式是 $C_{xy}(\\tau)$ 等价于 $x_{rev}$ 与 $y$ 的卷积，即 $C_{xy}(\\tau) = (x_{rev}*y)[\\tau]$，前提是对于有限序列，求和得到正确处理。\n\n卷积定理指出，时域中的卷积等价于频域中的逐元素相乘：$\\mathcal{F}\\{f*g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}$，其中 $\\mathcal{F}$ 表示傅里叶变换。对于离散傅里叶变换（DFT）的一个相关性质是，时间反转序列的变换是原始序列变换的复共轭：$\\mathcal{F}\\{x_{rev}\\} = (\\mathcal{F}\\{x\\})^*$。\n\n结合这些原理，我们可以通过 FFT 计算互相关：\n$$\n\\mathcal{F}\\{C_{xy}\\} = \\mathcal{F}\\{x_{rev}*y\\} = \\mathcal{F}\\{x_{rev}\\} \\cdot \\mathcal{F}\\{y\\} = (\\mathcal{F}\\{x\\})^* \\cdot \\mathcal{F}\\{y\\}\n$$\n因此，互相关函数 $C_{xy}(\\tau)$ 可以通过对 $x$ 的 FFT 的共轭与 $y$ 的 FFT 的乘积进行傅里叶逆变换 (IFFT) 来找到：\n$$\nC_{xy} = \\text{IFFT}\\left( (\\text{FFT}(x))^* \\cdot \\text{FFT}(y) \\right)\n$$\n对于长度为 $N$ 的序列，FFT 算法的复杂度为 $O(N \\log N)$。\n\n此过程计算的是*循环*互相关。要计算长度为 $T$ 的序列的*线性*互相关，我们必须将输入序列 $x[t]$ 和 $y[t]$ 补零至长度 $N \\ge T+T-1$。为了效率，通常选择 $N=2T-1$ 或下一个 2 的幂。设 $x_{pad}$ 和 $y_{pad}$ 为长度为 $N$ 的补零序列。算法如下：\n1.  计算 $X = \\text{FFT}(x_{pad})$ 和 $Y = \\text{FFT}(y_{pad})$。\n2.  计算逐元素乘积 $Z = X^* \\cdot Y$。\n3.  计算逆变换 $C = \\text{IFFT}(Z)$。$C$ 的结果的实部，表示为 $C[\\tau']$，即为互相关图。\n\n长度为 $N$ 的输出数组 $C[\\tau']$ 映射到延迟 $\\tau$ 的方式如下：\n-   对于 $k \\in \\{0, \\dots, T-1\\}$，$C[k]$ 对应于非负延迟 $\\tau = k$。\n-   对于 $k \\in \\{N-T+1, \\dots, N-1\\}$，$C[k]$ 对应于负延迟 $\\tau = k-N$。\n因此，延迟 $\\tau=0$ 对应于输出数组的第一个元素 $C[0]$。\n\n对于这个问题，我们只需要零延迟值 $C_{xy}(0)$。根据基于 FFT 的算法，这是 IFFT 结果的第 0 个元素。序列 $Z$ 的 IFFT 的 $k=0$ 项由 $(\\text{IFFT}(Z))[0] = \\frac{1}{N} \\sum_{j=0}^{N-1} Z_j$ 给出。将此应用于我们的互相关：\n$$\nC_{xy}(0) = \\frac{1}{N} \\sum_{k=0}^{N-1} ((\\text{FFT}(x_{pad}))_k^* \\cdot (\\text{FFT}(y_{pad}))_k)\n$$\n根据 DFT 的帕塞瓦尔定理，这等价于时域中的点积：\n$$\nC_{xy}(0) = \\sum_{t=0}^{N-1} x_{pad}[t] y_{pad}[t]\n$$\n由于填充部分由零组成，此总和等价于原始未补零序列的点积：\n$$\nC_{xy}(0) = \\sum_{t=0}^{T-1} x[t] y[t]\n$$\n对于二进制脉冲序列，其中 $x[t], y[t] \\in \\{0, 1\\}$，此总和只是计算 $x[t]=1$ 和 $y[t]=1$ 同时发生的时间窗 $t$ 的数量，即同时脉冲的数量。鉴于脉冲时间是以索引形式提供的，最有效的计算方法是计算脉冲时间索引集合的交集的大小。\n\n设 $A_i$ 和 $B_j$ 分别为试次 $i$ 中神经元 $A$ 和试次 $j$ 中神经元 $B$ 的脉冲时间索引集合。那么，$C_{a_i b_j}(0) = |A_i \\cap B_j|$。\n\n最终的算法如下：\n1.  对每个测试用例，将试次数 $R$ 和每个试次的脉冲时间索引解析为集合，例如 $\\{A_1, \\dots, A_R\\}$ 和 $\\{B_1, \\dots, B_R\\}$。\n2.  计算同一试次配对的零延迟互相关之和：\n    $$\n    \\text{TotalRawCorr} = \\sum_{i=1}^{R} |A_i \\cap B_i|\n    $$\n3.  计算平均原始互相关：$\\overline{C}_{AB}(0) = \\text{TotalRawCorr} / R$。\n4.  计算重洗试次配对（循环移位）的零延迟互相关之和：\n    $$\n    \\text{TotalShiftCorr} = \\sum_{i=1}^{R} |A_i \\cap B_{i+1}|\n    $$\n    其中 $B$ 的索引对 $R$ 取模（为方便实现，从 $\\{1, \\dots, R\\}$ 到 $\\{0, \\dots, R-1\\}$ 进行一对一映射，因此在基于 1 的索引中 $B_{i+1}$ 变为 $B_{(i \\pmod R)+1}$，或在基于 0 的索引中变为 $B_{(i+1) \\pmod R}$）。\n5.  计算平均移位预测量：$S_{AB}(0) = \\text{TotalShiftCorr} / R$。\n6.  最终结果是 $C^{\\mathrm{SC}}_{AB}(0) = \\overline{C}_{AB}(0) - S_{AB}(0)$。\n\n对于所要求的特定值，这种方法既计算高效，又完全符合问题陈述所要求的一般性的、基于 FFT 的 $O(T \\log T)$ 互相关框架。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the zero-lag shuffle-corrected cross-correlation for a series of test cases.\n    \"\"\"\n    # Test suite specification\n    # Each case is a tuple: (T, R, a_spike_indices, b_spike_indices)\n    test_cases = [\n        (\n            16, 3,\n            [[3, 8], [3, 7], [3, 9]],\n            [[3, 8], [3, 7], [3, 10]]\n        ),\n        (\n            12, 4,\n            [[5], [5], [5], [5]],\n            [[5], [5], [5], [5]]\n        ),\n        (\n            10, 2,\n            [[2], [7]],\n            [[4], [9]]\n        ),\n        (\n            8, 2,\n            [[], []],\n            [[], []]\n        ),\n        (\n            1, 1,\n            [[0]],\n            [[0]]\n        ),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        T, R, a_trials_indices, b_trials_indices = case\n        \n        # Convert spike time indices to sets for efficient intersection\n        a_sets = [set(indices) for indices in a_trials_indices]\n        b_sets = [set(indices) for indices in b_trials_indices]\n        \n        # Calculate C_bar_AB(0)\n        # C_{a_i b_i}(0) is the number of coincident spikes,\n        # which is the cardinality of the intersection of spike time sets.\n        total_C_0 = 0\n        if R  0:\n            for i in range(R):\n                total_C_0 += len(a_sets[i].intersection(b_sets[i]))\n            C_bar_0 = total_C_0 / R\n        else:\n            C_bar_0 = 0.0\n\n        # Calculate S_AB(0)\n        # S_{AB}(0) uses shifted trial pairings: a_i with b_{i+1}\n        # We use 0-based indexing, so a_i is paired with b_{(i+1) % R}.\n        total_S_0 = 0\n        if R  0:\n            for i in range(R):\n                shuffled_b_index = (i + 1) % R\n                total_S_0 += len(a_sets[i].intersection(b_sets[shuffled_b_index]))\n            S_0 = total_S_0 / R\n        else:\n            S_0 = 0.0\n\n        # Calculate the shuffle-corrected cross-correlation at lag 0\n        C_sc_0 = C_bar_0 - S_0\n        results.append(C_sc_0)\n\n    # Format the output as a comma-separated list in brackets\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        }
    ]
}