{
    "hands_on_practices": [
        {
            "introduction": "任何功能性磁共振成像（fMRI）模型的基础，都是对大脑响应实验事件的精确表示。本练习将带您体验从离散事件时间点到连续回归量的基本转换过程，即卷积模型。通过亲手实现这一过程，您将对假定的血液动力学响应（Hemodynamic Response Function, HRF）如何塑造您的设计矩阵有一个根本性的理解，而这一过程在现成的分析软件包中通常是隐藏的。",
            "id": "4191942",
            "problem": "您正在为一个功能性磁共振成像 (fMRI) 的设计矩阵建立一列模型，该模型是在微时间分辨率下采样的离散事件脉冲函数与离散血氧动力学响应函数 (HRF) 之间的卷积。fMRI 建模的假设是，血氧水平依赖 (BOLD) 信号可以由一个线性时不变 (LTI) 系统很好地近似，这意味着系统对于一个输入的输出由卷积给出。事件脉冲函数将神经事件表示为在指定起始时间的脉冲，而 HRF 则表征了系统的脉冲响应。目标是通过在微时间分辨率下计算此卷积，并降采样至重复时间采样网格，来构建设计矩阵的单列。\n\n从以下定义和事实开始：\n- 该系统是线性时不变 (LTI) 的，因此对于输入 $u[n]$ 和脉冲响应 $h[n]$，其输出是离散卷积 $y[n] = \\sum_{k=-\\infty}^{\\infty} u[k] \\, h[n-k]$，对于有限长度的序列需要进行适当的零填充。\n- 设重复时间为 $T_R$ 秒，微时间因子为 $m \\in \\mathbb{N}$，这意味着微时间步长为 $\\Delta t = T_R / m$ 秒。\n- 设有 $N_{\\text{TR}}$ 次扫描，因此总微时间长度为 $N_{\\mu} = N_{\\text{TR}} \\cdot m$ 个样本。\n- 事件起始时间以秒为单位，相对于扫描周期的开始时间给出。事件脉冲函数定义在微时间网格上，通过在索引 $n_e = \\lfloor t_e / \\Delta t \\rfloor$ 处放置一个幅度为 $1$ 的脉冲来定义，其中 $t_e$ 是事件的起始时间（秒）。只包含满足 $0 \\le n_e  N_{\\mu}$ 的索引；超出范围的事件将被忽略。\n- HRF $h[n]$ 是一个以相同微时间步长 $\\Delta t$ 采样的离散序列，长度有限为 $L$。微时间域响应 $y[n]$ 是通过计算 $u[n]$ 与 $h[n]$ 的完全离散卷积，然后裁剪为前 $N_{\\mu}$ 个样本：$y[0], y[1], \\dots, y[N_{\\mu}-1]$ 来得到的。\n- 降采样至重复时间网格，得到设计列 $x[j] = y[j \\cdot m]$，其中 $j = 0, 1, \\dots, N_{\\text{TR}} - 1$。\n\n实现一个程序，对于每个给定的测试用例，构建事件脉冲函数 $u[n]$，与提供的 HRF $h[n]$ 进行离散卷积，将结果裁剪为 $N_{\\mu}$，并通过从索引 $0$ 开始每隔 $m$ 个样本选择一个样本进行降采样，以形成设计列 $x[j]$。对于事件起始时间 $t_e$，使用映射 $n_e = \\lfloor t_e / \\Delta t \\rfloor$。所有时间量都必须以秒为单位处理。\n\n测试套件：\n对于每个测试用例，参数为 $(T_R, m, N_{\\text{TR}}, \\text{events}, h)$，其中 $T_R$ 是重复时间（秒），$m$ 是微时间因子（无单位整数），$N_{\\text{TR}}$ 是扫描次数（无单位整数），events 是起始时间的列表（秒），$h$ 是在微时间分辨率下采样的离散 HRF（无单位幅度）。使用以下测试用例：\n\n1. 一般情况：\n   - $T_R = 2.0$\n   - $m = 5$\n   - $N_{\\text{TR}} = 10$\n   - $\\text{events} = [4.0, 12.0]$\n   - $h = [0.0, 0.005, 0.020, 0.050, 0.090, 0.140, 0.180, 0.220, 0.250, 0.270, 0.280, 0.280, 0.270, 0.250, 0.220, 0.190, 0.160, 0.130, 0.100, 0.080, 0.060, 0.045, 0.030, 0.020, 0.010, 0.005, 0.000, -0.005, -0.008, -0.010]$\n\n2. 靠近开始和结束的边界事件：\n   - $T_R = 2.0$\n   - $m = 10$\n   - $N_{\\text{TR}} = 10$\n   - $\\text{events} = [0.0, 19.6]$\n   - $h = [0.0, 0.003, 0.012, 0.028, 0.050, 0.075, 0.100, 0.125, 0.145, 0.160, 0.170, 0.175, 0.176, 0.172, 0.165, 0.155, 0.140, 0.120, 0.100, 0.085, 0.070, 0.058, 0.047, 0.038, 0.030, 0.024, 0.019, 0.015, 0.012, 0.009, 0.007, 0.005, 0.003, 0.001, 0.000, -0.002, -0.004, -0.006, -0.008, -0.010]$\n\n3. 无事件：\n   - $T_R = 1.5$\n   - $m = 4$\n   - $N_{\\text{TR}} = 8$\n   - $\\text{events} = []$\n   - $h = [0.0, 0.010, 0.040, 0.090, 0.140, 0.180, 0.200, 0.210, 0.200, 0.180, 0.150, 0.120, 0.090, 0.070, 0.050, 0.035, 0.025, 0.015, 0.005, 0.000]$\n\n4. 多个紧密间隔的事件及一个靠近末尾的事件：\n   - $T_R = 1.25$\n   - $m = 8$\n   - $N_{\\text{TR}} = 16$\n   - $\\text{events} = [3.10, 3.25, 3.30, 19.99]$\n   - $h = [0.0, 0.002, 0.008, 0.018, 0.034, 0.055, 0.082, 0.115, 0.150, 0.180, 0.205, 0.220, 0.228, 0.230, 0.225, 0.215, 0.200, 0.180, 0.160, 0.140, 0.120, 0.105, 0.090, 0.078, 0.067, 0.057, 0.048, 0.040, 0.033, 0.027, 0.022, 0.018, 0.014, 0.011, 0.009, 0.007, 0.005, 0.004, 0.003, 0.002, 0.001, 0.0005, 0.0000, -0.0010, -0.0020, -0.0030, -0.0040, -0.0050, -0.0060, -0.0070]$\n\n您的程序必须为每个测试用例计算降采样后的设计列 $x[j]$ (其中 $j = 0, 1, \\dots, N_{\\text{TR}} - 1$)，并生成单行输出。该输出包含一个由方括号括起来的逗号分隔列表，其中每个元素对应一个测试用例的结果，其本身也是一个由方括号括起来的浮点数逗号分隔列表。所有浮点数表示为四舍五入到六位小数，并且输出中不包含任何空格。例如，包含两个测试用例的输出可能如下所示： \"[[0.000000,0.123456],[0.000000,0.654321]]\"。",
            "solution": "该问题要求为功能性磁共振成像 (fMRI) 分析中使用的设计矩阵构建单列。该过程基于以下原理：测得的血氧水平依赖 (BOLD) 信号可以建模为线性时不变 (LTI) 系统的输出。解决方案涉及一系列信号处理步骤：生成神经事件模型，将其与血氧动力学响应函数进行卷积，并在扫描仪的采集时间点对结果进行采样。\n\n该过程首先定义时间网格。实验包含 $N_{\\text{TR}}$ 次扫描，每次扫描的采集间隔为 $T_R$ 秒。为了以比扫描分辨率更高的保真度来模拟生物反应，我们建立了一个更精细的“微时间”网格。该网格的时间分辨率为 $\\Delta t = T_R / m$，其中 $m$ 是整数微时间因子。实验在微时间样本中的总持续时间为 $N_{\\mu} = N_{\\text{TR}} \\cdot m$。\n\nLTI 系统的输入是神经活动的理想化表示，称为“事件脉冲函数”，记为 $u[n]$。这是一个在微时间网格上长度为 $N_{\\mu}$ 的离散时间信号。对于在连续时间 $t_e$（秒）发生的每个刺激或认知事件，我们在微时间网格上放置一个幅度为 $1$ 的离散脉冲。相应的离散时间索引 $n_e$ 通过量化事件时间来确定：\n$$n_e = \\lfloor t_e / \\Delta t \\rfloor$$\n向下取整函数 $\\lfloor \\cdot \\rfloor$ 确保连续时间 $t_e$ 被映射到相应微时间仓的开始处。然后，事件脉冲函数被构建为一个除这些索引外全为零的向量。如果多个事件落入同一个微时间仓内，它们对应的脉冲会相加，这是线性假设的直接结果。形式上，对于一组事件时间 $\\{t_{e_i}\\}$，脉冲函数为：\n$$u[n] = \\sum_i \\delta[n - \\lfloor t_{e_i} / \\Delta t \\rfloor]$$\n其中 $\\delta[k]$ 是克罗内克δ函数。起始时间在扫描窗口之外的事件（即 $n_e  0$ 或 $n_e \\ge N_{\\mu}$）将被忽略。\n\nLTI 系统本身由其脉冲响应，即血氧动力学响应函数 (HRF) 来表征，记为 $h[n]$。问题将 $h[n]$ 提供为一个长度为 $L$ 的有限长度离散序列，以相同的微时间分辨率 $\\Delta t$ 采样。\n\nLTI 模型的核心是卷积运算。在微时间分辨率下预测的 BOLD 信号 $y[n]$ 是输入 $u[n]$ 与系统脉冲响应 $h[n]$ 的离散卷积：\n$$y[n] = (u * h)[n] = \\sum_{k=-\\infty}^{\\infty} u[k] h[n-k]$$\n对于有限长度序列 $u[n]$（长度 $N_{\\mu}$）和 $h[n]$（长度 $L$），“完全”卷积产生一个长度为 $N_{\\mu} + L - 1$ 的序列。这正确地模拟了对扫描后期发生的事件的响应，其中 HRF 可能会延伸到最终时间点 $N_{\\mu}-1$ 之后。然而，由于 fMRI 数据只采集到这个最终时间点，问题规定所得的卷积信号必须被裁剪为前 $N_{\\mu}$ 个样本。我们将这个裁剪后的信号称为 $y'[n]$，其中对于 $n \\in \\{0, 1, \\dots, N_{\\mu}-1\\}$，$y'[n] = y[n]$。\n\n最后，这个高分辨率的 BOLD 信号模型必须在与实际 fMRI 扫描仪采集相对应的时间点进行采样。扫描以 $T_R$ 的时间间隔进行采集，对应于时间 $t_j = j \\cdot T_R$，其中 $j \\in \\{0, 1, \\dots, N_{\\text{TR}}-1\\}$。在微时间域中，这些采集时间对应于索引 $j \\cdot m$。因此，最终的设计矩阵列 $x[j]$ 是通过对微时间信号 $y'[n]$ 进行降采样得到的：\n$$x[j] = y'[j \\cdot m] \\quad \\text{对于 } j = 0, 1, \\dots, N_{\\text{TR}}-1$$\n该过程产生一个长度为 $N_{\\text{TR}}$ 的向量 $x$，它在广义线性模型 (GLM) 中用作回归量，以解释测量的 fMRI 时间序列中的方差。实现将为每个给定的测试用例精确遵循这些步骤，使用数值库高效地执行卷积和数组操作。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and formats the fMRI design matrix columns for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            2.0, 5, 10, [4.0, 12.0],\n            [0.0, 0.005, 0.020, 0.050, 0.090, 0.140, 0.180, 0.220, 0.250, 0.270, 0.280, 0.280, 0.270, 0.250, 0.220, 0.190, 0.160, 0.130, 0.100, 0.080, 0.060, 0.045, 0.030, 0.020, 0.010, 0.005, 0.000, -0.005, -0.008, -0.010]\n        ),\n        (\n            2.0, 10, 10, [0.0, 19.6],\n            [0.0, 0.003, 0.012, 0.028, 0.050, 0.075, 0.100, 0.125, 0.145, 0.160, 0.170, 0.175, 0.176, 0.172, 0.165, 0.155, 0.140, 0.120, 0.100, 0.085, 0.070, 0.058, 0.047, 0.038, 0.030, 0.024, 0.019, 0.015, 0.012, 0.009, 0.007, 0.005, 0.003, 0.001, 0.000, -0.002, -0.004, -0.006, -0.008, -0.010]\n        ),\n        (\n            1.5, 4, 8, [],\n            [0.0, 0.010, 0.040, 0.090, 0.140, 0.180, 0.200, 0.210, 0.200, 0.180, 0.150, 0.120, 0.090, 0.070, 0.050, 0.035, 0.025, 0.015, 0.005, 0.000]\n        ),\n        (\n            1.25, 8, 16, [3.10, 3.25, 3.30, 19.99],\n            [0.0, 0.002, 0.008, 0.018, 0.034, 0.055, 0.082, 0.115, 0.150, 0.180, 0.205, 0.220, 0.228, 0.230, 0.225, 0.215, 0.200, 0.180, 0.160, 0.140, 0.120, 0.105, 0.090, 0.078, 0.067, 0.057, 0.048, 0.040, 0.033, 0.027, 0.022, 0.018, 0.014, 0.011, 0.009, 0.007, 0.005, 0.004, 0.003, 0.002, 0.001, 0.0005, 0.0000, -0.0010, -0.0020, -0.0030, -0.0040, -0.0050, -0.0060, -0.0070]\n        )\n    ]\n    \n    results = []\n    for case in test_cases:\n        T_R, m, N_TR, events, h = case\n\n        # Calculate microtime parameters\n        dt = T_R / m\n        N_micro = N_TR * m\n\n        # Create the event stick function u[n]\n        u = np.zeros(N_micro)\n        for t_e in events:\n            n_e = int(np.floor(t_e / dt))\n            if 0 = n_e  N_micro:\n                u[n_e] += 1\n        \n        # Ensure h is a numpy array\n        h_np = np.array(h)\n        \n        # Compute the full discrete convolution\n        y_full = np.convolve(u, h_np, mode='full')\n        \n        # Crop the result to the first N_micro samples\n        y = y_full[:N_micro]\n        \n        # Downsample to the repetition time grid\n        x = y[::m]\n        \n        # Format the result as a string\n        formatted_list = [f\"{val:.6f}\" for val in x]\n        result_str = \"[\" + \",\".join(formatted_list) + \"]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一旦您能够生成单个回归量，下一步就是将它们组合起来以代表您的实验设计。本练习侧重于虚拟编码（dummy coding），这是一种对具有多个水平的分类因素进行建模的常用方法。您将从第一性原理出发，推导这种编码方案如何决定模型参数的含义，以及至关重要的一点——如何构建对比向量（contrast vectors）以检验关于条件间差异的特定科学假设。",
            "id": "4191947",
            "problem": "一位研究人员设计了一项功能性磁共振成像 (fMRI) 研究，旨在研究一个具有三个有序水平的单一认知因素，标记为低 ($L$)、中 ($M$) 和高 ($H$)。该研究采用区组设计 (block design)，重复时间 (repetition time) 为每卷 $2$ 秒，总共采集了 $60$ 卷，平均分配到三个条件下：$L$ 条件 $20$ 卷，$M$ 条件 $20$ 卷，$H$ 条件 $20$ 卷。为了明确关注设计的分类编码结构，研究人员将回归量构建为不含血流动力学卷积的箱形指示函数 (boxcar indicator functions)，并指出这种选择可以在广义线性模型 (GLM) 的一般假设框架内，分离出线性模型的编码部分。\n\n建模框架是广义线性模型 (General Linear Model, GLM)，其中测量的血氧水平依赖 (blood-oxygen-level-dependent) 信号 $y \\in \\mathbb{R}^{n}$ 被建模为 $y = X \\beta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^{2} I)$，$X \\in \\mathbb{R}^{n \\times p}$ 是设计矩阵，$\\beta \\in \\mathbb{R}^{p}$ 是参数矢量，$\\epsilon$ 是一个均值为零的高斯误差矢量。研究人员使用带有截距项的虚拟编码 (dummy coding)，并选择 $L$ 作为基线条件。具体来说，设计矩阵 $X$ 有三列：一个截距项 $x_{0}$，对所有 $n=60$ 个观测值均为1；一个虚拟回归量 $x_{M}$，对于分配给 $M$ 条件的卷，其值为 $1$，否则为 $0$；以及一个虚拟回归量 $x_{H}$，对于分配给 $H$ 条件的卷，其值为 $1$，否则为 $0$。基线水平 $L$ 没有自己的列，其均值被吸收到截距项中。\n\n根据 GLM 的第一性原理，推导检验三种条件均值之间两两差异（$L$ vs $M$、$L$ vs $H$ 和 $M$ vs $H$）以及三水平因素的总体效应（即，非基线水平相对于基线的任何偏差的综合检验）所需的对比结构。仅使用 GLM 的定义、虚拟编码的含义以及在此编码下 $\\beta$ 的可解释性来构建适当的对比向量和对比矩阵。\n\n最后，考虑在这种平衡配置下设计矩阵 $X$ 的信息含量。将 $x_{0}$、$x_{M}$ 和 $x_{H}$ 视为上述规定，计算在给定 $n=60$ 和平衡计数 $n_{L} = 20$、$n_{M} = 20$ 和 $n_{H} = 20$ 的情况下，格拉姆矩阵 (Gram matrix) $X^{\\top} X$ 的行列式。将最终答案表示为一个无单位的实数。无需四舍五入。",
            "solution": "在进行解答之前，首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **模型**：广义线性模型 (GLM)，$y = X \\beta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^{2} I)$。\n- **因素**：具有三个有序水平的单一认知因素：低 ($L$)、中 ($M$)、高 ($H$)。\n- **总扫描次数 ($n$)**: $n=60$。\n- **扫描分布**：平衡设计，条件 $L$ 有 $n_{L} = 20$ 次扫描，条件 $M$ 有 $n_{M} = 20$ 次扫描，条件 $H$ 有 $n_{H} = 20$ 次扫描。\n- **重复时间 (TR)**：$2$ 秒（背景信息）。\n- **回归量**：箱形指示函数，无血流动力学卷积。\n- **设计矩阵 ($X$)**：$X \\in \\mathbb{R}^{60 \\times 3}$。编码方式为虚拟编码，以 $L$ 为基线。\n  - 第 $1$ 列 ($x_0$)：截距项，一个包含 $60$ 个 1 的向量。\n  - 第 $2$ 列 ($x_M$)：条件 $M$ 的虚拟回归量。对于对应于 $M$ 的 $20$ 次扫描，其值为 $1$，否则为 $0$。\n  - 第 $3$ 列 ($x_H$)：条件 $H$ 的虚拟回归量。对于对应于 $H$ 的 $20$ 次扫描，其值为 $1$，否则为 $0$。\n- **参数矢量 ($\\beta$)**：$\\beta = [\\beta_0, \\beta_M, \\beta_H]^T \\in \\mathbb{R}^3$。\n- **目标**：\n  1. 推导用于两两差异比较的对比向量：$L$ vs $M$、$L$ vs $H$ 和 $M$ vs $H$。\n  2. 推导用于因素效应综合检验的对比矩阵。\n  3. 计算格拉姆矩阵的行列式 $\\det(X^{\\top} X)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学性**：该问题是广义线性模型的标准应用，而广义线性模型是 fMRI 数据统计分析的基石。虚拟编码的使用和对比的构建是该领域的基本概念。使用箱形函数进行简化的做法被明确说明是一种教学工具，旨在分离出代数结构，这是一种有效的方法。\n- **适定性**：该问题提供了推导对比和计算行列式所需的所有必要信息。设计矩阵定义明确，其各列线性无关，确保了 $X^{\\top} X$ 是可逆的且其行列式不为零。目标清晰明确。\n- **客观性**：问题以精确、正式的语言陈述，没有主观性或歧义。\n\n### 步骤 3：结论与行动\n该问题有效。这是一个关于神经影像数据线性建模的适定且具有科学依据的练习。将提供完整的解答。\n\n### 解答推导\n解答分为两部分，与问题的目标一致。\n\n#### 第 1 部分：对比结构的推导\n广义线性模型由 $y = X \\beta + \\epsilon$ 给出。对于给定的观测值，信号 $y$ 的期望值为 $E[y] = X_{row} \\beta$，其中 $X_{row}$ 是设计矩阵 $X$ 的相应行。我们必须首先通过检查每种条件下的模型来解释参数 $\\beta = [\\beta_0, \\beta_M, \\beta_H]^T$。\n\n设 $\\mu_L$、$\\mu_M$ 和 $\\mu_H$ 分别为低、中、高条件的真实平均激活水平。\n\n1.  **对于条件 $L$（基线）中的一次扫描**：$X$ 中的对应行为 $[1, 0, 0]$。因此，期望信号为：\n    $$E[y_L] = [1, 0, 0] \\begin{pmatrix} \\beta_0 \\\\ \\beta_M \\\\ \\beta_H \\end{pmatrix} = 1 \\cdot \\beta_0 + 0 \\cdot \\beta_M + 0 \\cdot \\beta_H = \\beta_0$$\n    因此，$\\mu_L = \\beta_0$。截距项 $\\beta_0$ 代表了基线条件 $L$ 的平均激活水平。\n\n2.  **对于条件 $M$ 中的一次扫描**：$X$ 中的对应行为 $[1, 1, 0]$。期望信号为：\n    $$E[y_M] = [1, 1, 0] \\begin{pmatrix} \\beta_0 \\\\ \\beta_M \\\\ \\beta_H \\end{pmatrix} = 1 \\cdot \\beta_0 + 1 \\cdot \\beta_M + 0 \\cdot \\beta_H = \\beta_0 + \\beta_M$$\n    因此，$\\mu_M = \\beta_0 + \\beta_M$。这意味着 $\\beta_M = \\mu_M - \\beta_0 = \\mu_M - \\mu_L$。参数 $\\beta_M$ 代表条件 $M$ 的平均激活水平与基线条件 $L$ 的平均激活水平之间的差异。\n\n3.  **对于条件 $H$ 中的一次扫描**：$X$ 中的对应行为 $[1, 0, 1]$。期望信号为：\n    $$E[y_H] = [1, 0, 1] \\begin{pmatrix} \\beta_0 \\\\ \\beta_M \\\\ \\beta_H \\end{pmatrix} = 1 \\cdot \\beta_0 + 0 \\cdot \\beta_M + 1 \\cdot \\beta_H = \\beta_0 + \\beta_H$$\n    因此，$\\mu_H = \\beta_0 + \\beta_H$。这意味着 $\\beta_H = \\mu_H - \\beta_0 = \\mu_H - \\mu_L$。参数 $\\beta_H$ 代表条件 $H$ 的平均激活水平与基线条件 $L$ 的平均激活水平之间的差异。\n\n基于这些解释，我们可以为形如 $H_0: c^T\\beta = 0$ 的零假设构建对比向量 $c$。\n\n- **$L$ 与 $M$ 的对比**：我们检验 $L$ 和 $M$ 的均值没有差异的零假设，即 $H_0: \\mu_M - \\mu_L = 0$。根据我们的参数解释，这等价于 $H_0: \\beta_M = 0$。对应的参数线性组合是 $0 \\cdot \\beta_0 + 1 \\cdot \\beta_M + 0 \\cdot \\beta_H$。所需的对比向量是：\n  $$c_{M-L} = \\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n\n- **$L$ 与 $H$ 的对比**：我们检验 $H_0: \\mu_H - \\mu_L = 0$。这等价于 $H_0: \\beta_H = 0$。线性组合是 $0 \\cdot \\beta_0 + 0 \\cdot \\beta_M + 1 \\cdot \\beta_H$。对比向量是：\n  $$c_{H-L} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix}$$\n\n- **$M$ 与 $H$ 的对比**：我们检验 $H_0: \\mu_H - \\mu_M = 0$。用 $\\beta$ 参数表示条件均值：$(\\beta_0 + \\beta_H) - (\\beta_0 + \\beta_M) = \\beta_H - \\beta_M$。所以，我们检验 $H_0: \\beta_H - \\beta_M = 0$。线性组合是 $0 \\cdot \\beta_0 - 1 \\cdot \\beta_M + 1 \\cdot \\beta_H$。对比向量是：\n  $$c_{H-M} = \\begin{pmatrix} 0 \\\\ -1 \\\\ 1 \\end{pmatrix}$$\n\n- **综合检验 (Omnibus Test)**：因素总体效应的综合检验旨在探究非基线水平与基线之间是否存在任何差异。这是一个关于零假设 $H_0: \\beta_M = 0$ 和 $H_0: \\beta_H = 0$ 的联合检验。这两个假设是线性无关的。我们可以构建一个对比矩阵 $C$，其中每一行对应这些假设中的一个。\n  $$C_{omnibus} = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$$\n该矩阵用于检验联合零假设 $C_{omnibus}\\beta = \\mathbf{0}$。\n\n#### 第 2 部分：$\\det(X^{\\top} X)$ 的计算\n格拉姆矩阵是 $X^{\\top} X$，一个 $p \\times p$ 的对称矩阵，其中第 $(i, j)$ 个元素是 $X$ 的第 $i$ 列和第 $j$ 列的内积，记作 $x_{i-1}^{\\top} x_{j-1}$。给定我们的 3 列设计矩阵 $X = [x_0, x_M, x_H]$，格拉姆矩阵为：\n$$X^{\\top} X = \\begin{pmatrix} x_0^{\\top} x_0  x_0^{\\top} x_M  x_0^{\\top} x_H \\\\ x_M^{\\top} x_0  x_M^{\\top} x_M  x_M^{\\top} x_H \\\\ x_H^{\\top} x_0  x_H^{\\top} x_M  x_H^{\\top} x_H \\end{pmatrix}$$\n我们使用给定的计数 $n=60$, $n_L=20$, $n_M=20$, $n_H=20$ 来计算每个元素：\n\n- $x_0^{\\top} x_0 = \\sum_{i=1}^{n} 1 \\cdot 1 = n = 60$.\n- $x_0^{\\top} x_M = \\sum_{i \\in M} 1 \\cdot 1 + \\sum_{i \\notin M} 1 \\cdot 0 = n_M = 20$.\n- $x_0^{\\top} x_H = \\sum_{i \\in H} 1 \\cdot 1 + \\sum_{i \\notin H} 1 \\cdot 0 = n_H = 20$.\n- $x_M^{\\top} x_M = \\sum_{i \\in M} 1^2 + \\sum_{i \\notin M} 0^2 = n_M = 20$.\n- $x_H^{\\top} x_H = \\sum_{i \\in H} 1^2 + \\sum_{i \\notin H} 0^2 = n_H = 20$.\n- $x_M^{\\top} x_H = \\sum_{i=1}^{n} x_{Mi} x_{Hi}$。由于这些条件是互斥的，对于任何一次扫描 $i$，$x_{Mi}$ 或 $x_{Hi}$ 中至少有一个必须为零。因此，它们的乘积始终为零，总和也为 $0$。\n\n将这些值代入矩阵中：\n$$X^{\\top} X = \\begin{pmatrix} 60  20  20 \\\\ 20  20  0 \\\\ 20  0  20 \\end{pmatrix}$$\n我们现在沿第一行使用代数余子式展开来计算行列式：\n\\begin{align*}\n\\det(X^{\\top} X) = 60 \\cdot \\det \\begin{pmatrix} 20  0 \\\\ 0  20 \\end{pmatrix} - 20 \\cdot \\det \\begin{pmatrix} 20  0 \\\\ 20  20 \\end{pmatrix} + 20 \\cdot \\det \\begin{pmatrix} 20  20 \\\\ 20  0 \\end{pmatrix} \\\\\n= 60 \\cdot (20 \\cdot 20 - 0 \\cdot 0) - 20 \\cdot (20 \\cdot 20 - 0 \\cdot 20) + 20 \\cdot (20 \\cdot 0 - 20 \\cdot 20) \\\\\n= 60 \\cdot (400) - 20 \\cdot (400) + 20 \\cdot (-400) \\\\\n= 24000 - 8000 - 8000 \\\\\n= 8000\n\\end{align*}\n另外，对于这种特定的虚拟编码结构，可以证明行列式具有一般形式 $\\det(X^{\\top}X) = n_L n_M n_H$。当 $n_L=20$，$n_M=20$ 且 $n_H=20$ 时，结果为 $20 \\times 20 \\times 20 = 8000$，这验证了计算结果。",
            "answer": "$$\\boxed{8000}$$"
        },
        {
            "introduction": "一个真实的设计矩阵不仅必须考虑任务效应，还必须能解释非神经噪声的来源。本练习展示了包含干扰回归量（nuisance regressors）以防止结果出现系统性偏差的至关重要性，例如，用以区分不同实验区段（run）的截距项。通过代数方法比较一个忽略这些回归量的模型与一个包含它们的模型，您将直接量化“遗漏变量偏差”（omitted variable bias），并理解为何正确的模型设定对于获得有效的统计推断至关重要。",
            "id": "4192019",
            "problem": "一位研究者进行了一项包含两个会话的功能性磁共振成像 (fMRI) 实验，以估计一种条件效应，同时控制会话均值的差异。观测到的血氧水平依赖 (blood-oxygen-level dependent) 时间序列 $y \\in \\mathbb{R}^{N}$ 在样本水平上通过通用线性模型 (General Linear Model, GLM) 进行建模，其中扫描数据按运行 (run) 进行拼接。假设对于每次扫描的均值水平，以下数据生成过程成立：\n$$\n\\mathbb{E}[y] \\;=\\; \\alpha_{1}\\, r_{1} \\;+\\; \\alpha_{2}\\, r_{2} \\;+\\; \\beta\\, s,\n$$\n其中 $r_{1}, r_{2} \\in \\mathbb{R}^{N}$ 是运行 $1$ 和运行 $2$ 的指示变量（因此，如果扫描 $i$ 属于运行 $1$，则 $r_{1,i} = 1$，否则为 $0$；$r_{2}$ 与此类似），$\\alpha_{1}, \\alpha_{2} \\in \\mathbb{R}$ 是特定于运行的平均水平（会话均值），$\\beta \\in \\mathbb{R}$ 是我们感兴趣的真实条件效应，而 $s \\in \\mathbb{R}^{N}$ 是一个条件回归量，它已经包含了典型的血液动力学响应函数 (Hemodynamic Response Function, HRF) 并且经过缩放，使得 $s_{i} \\in \\{+1,-1\\}$ 表示在扫描 $i$ 时是条件 $A$ ($+1$) 还是条件 $B$ ($-1$)。噪声为零均值，其他方面未指定。\n\n实验在运行 $1$ 中有 $N_{1} = 60$ 次扫描，在运行 $2$ 中有 $N_{2} = 40$ 次扫描（因此 $N = N_{1} + N_{2} = 100$）。在运行 $1$ 中，有 $N_{A1} = 40$ 次扫描标记为 $A$，有 $N_{B1} = 20$ 次扫描标记为 $B$；在运行 $2$ 中，有 $N_{A2} = 10$ 次扫描标记为 $A$，有 $N_{B2} = 30$ 次扫描标记为 $B$。因此，在所有运行中，共有 $N_{A} = 50$ 次 $A$ 的扫描和 $N_{B} = 50$ 次 $B$ 的扫描，所以 $\\sum_{i=1}^{N} s_{i} = 0$。\n\n考虑使用两种 GLM 设定进行普通最小二乘 (Ordinary Least Squares, OLS) 估计：\n- 模型 $\\mathcal{M}_{0}$（无特定于运行的截距）：设计矩阵 $X_{0} = [\\mathbf{1}_{N},\\, s]$，其中 $\\mathbf{1}_{N}$ 是元素全为 1 的 $N$ 维向量。\n- 模型 $\\mathcal{M}_{1}$（有特定于运行的截距）：设计矩阵 $X_{1} = [r_{1},\\, r_{2},\\, s]$。\n\n仅从 GLM 定义 $y = X\\theta + \\varepsilon$（其中 $\\mathbb{E}[\\varepsilon] = 0$）和 OLS 估计量 $\\hat{\\theta} = (X^{\\top}X)^{-1}X^{\\top}y$ 出发，且不使用任何快捷公式，推导在每个模型下估计的条件效应的期望值，即 $\\mathcal{M}_{0}$ 的 $\\mathbb{E}[\\hat{\\beta}_{0}]$ 和 $\\mathcal{M}_{1}$ 的 $\\mathbb{E}[\\hat{\\beta}_{1}]$。利用这些推导，从第一性原理出发解释为什么包含特定于运行的截距可以控制运行内部条件 $A$ 与 $B$ 对比的会话均值差异，并描述跨运行对比（运行 $1$ 与运行 $2$）如何在 $\\mathcal{M}_{1}$ 中表示，而在 $\\mathcal{M}_{0}$ 中则不然。\n\n最后，计算在省略特定于运行的截距时，条件效应估计中的偏差项，其定义为\n$$\n\\text{Bias} \\;=\\; \\mathbb{E}[\\hat{\\beta}_{0}] \\;-\\; \\beta,\n$$\n针对指定的计数和编码进行计算。请将您的最终答案表示为关于 $\\alpha_{1}$ 和 $\\alpha_{2}$ 的单个封闭形式解析表达式。不要包含单位。",
            "solution": "经评估，问题陈述有效。它在科学上基于应用于 fMRI 数据分析的通用线性模型 (GLM) 原理，问题设定良好，提供了充分且一致的信息以获得唯一解，并以客观、正式的语言表达。该问题是理解统计分析中模型设定后果的标准练习。\n\n分析从普通最小二乘 (OLS) 估计量 $\\hat{\\theta} = (X^{\\top}X)^{-1}X^{\\top}y$ 的定义及其期望值出发，给定均值信号 $\\mathbb{E}[y]$ 的真实数据生成过程。估计量的期望值为 $\\mathbb{E}[\\hat{\\theta}] = (X^{\\top}X)^{-1}X^{\\top}\\mathbb{E}[y]$。\n\n真实的均值信号由下式给出：\n$$\n\\mathbb{E}[y] \\;=\\; \\alpha_{1}\\, r_{1} \\;+\\; \\alpha_{2}\\, r_{2} \\;+\\; \\beta\\, s\n$$\n提供的数值如下：\n- 运行 $1$：$N_{1} = 60$ 次扫描，其中 $N_{A1} = 40$（条件 $A$，$s_i=+1$）和 $N_{B1} = 20$（条件 $B$，$s_i=-1$）。\n- 运行 $2$：$N_{2} = 40$ 次扫描，其中 $N_{A2} = 10$（条件 $A$，$s_i=+1$）和 $N_{B2} = 30$（条件 $B$，$s_i=-1$）。\n- 总扫描次数：$N = N_{1} + N_{2} = 100$。\n\n根据这些计数，我们可以计算回归量所需的内积：\n- $r_{1}^{\\top}r_{1} = N_{1} = 60$\n- $r_{2}^{\\top}r_{2} = N_{2} = 40$\n- $r_{1}^{\\top}r_{2} = 0$，因为运行是不同的。\n- $\\mathbf{1}_{N}^{\\top}\\mathbf{1}_{N} = N = 100$，其中 $\\mathbf{1}_{N} = r_{1} + r_{2}$。\n- $s^{\\top}s = \\sum_{i=1}^{N} s_{i}^{2} = \\sum_{i=1}^{N} (\\pm 1)^{2} = N = 100$。\n- $s^{\\top}\\mathbf{1}_{N} = \\sum_{i=1}^{N} s_{i} = (N_{A1}+N_{A2}) - (N_{B1}+N_{B2}) = (40+10) - (20+30) = 50 - 50 = 0$。\n- $s^{\\top}r_{1} = \\sum_{i \\in \\text{run } 1} s_{i} = N_{A1} - N_{B1} = 40 - 20 = 20$。\n- $s^{\\top}r_{2} = \\sum_{i \\in \\text{run } 2} s_{i} = N_{A2} - N_{B2} = 10 - 30 = -20$。\n\n### 模型 $\\mathcal{M}_{0}$ 的分析（无特定于运行的截距）\n\n对于模型 $\\mathcal{M}_{0}$，设计矩阵为 $X_{0} = [\\mathbf{1}_{N}, s]$，参数向量为 $\\theta_{0} = [\\alpha_{0}, \\beta_{0}]^{\\top}$。\n\n首先，我们计算 $X_{0}^{\\top}X_{0}$：\n$$\nX_{0}^{\\top}X_{0} = \\begin{pmatrix} \\mathbf{1}_{N}^{\\top}\\mathbf{1}_{N}  \\mathbf{1}_{N}^{\\top}s \\\\ s^{\\top}\\mathbf{1}_{N}  s^{\\top}s \\end{pmatrix} = \\begin{pmatrix} 100  0 \\\\ 0  100 \\end{pmatrix}\n$$\n该矩阵是对角矩阵，因为回归量 $s$ 与截距 $\\mathbf{1}_{N}$ 正交（$s^{\\top}\\mathbf{1}_{N} = 0$）。\n其逆矩阵为：\n$$\n(X_{0}^{\\top}X_{0})^{-1} = \\begin{pmatrix} 1/100  0 \\\\ 0  1/100 \\end{pmatrix}\n$$\n接下来，我们计算 $X_{0}^{\\top}\\mathbb{E}[y]$：\n$$\nX_{0}^{\\top}\\mathbb{E}[y] = \\begin{pmatrix} \\mathbf{1}_{N}^{\\top} \\\\ s^{\\top} \\end{pmatrix} (\\alpha_{1}r_{1} + \\alpha_{2}r_{2} + \\beta s) = \\begin{pmatrix} \\alpha_{1}\\mathbf{1}_{N}^{\\top}r_{1} + \\alpha_{2}\\mathbf{1}_{N}^{\\top}r_{2} + \\beta\\mathbf{1}_{N}^{\\top}s \\\\ \\alpha_{1}s^{\\top}r_{1} + \\alpha_{2}s^{\\top}r_{2} + \\beta s^{\\top}s \\end{pmatrix}\n$$\n代入内积值：\n$$\nX_{0}^{\\top}\\mathbb{E}[y] = \\begin{pmatrix} \\alpha_{1}N_{1} + \\alpha_{2}N_{2} + \\beta(0) \\\\ \\alpha_{1}(20) + \\alpha_{2}(-20) + \\beta(100) \\end{pmatrix} = \\begin{pmatrix} 60\\alpha_{1} + 40\\alpha_{2} \\\\ 20\\alpha_{1} - 20\\alpha_{2} + 100\\beta \\end{pmatrix}\n$$\n参数估计值 $\\hat{\\theta}_{0} = [\\hat{\\alpha}_{0}, \\hat{\\beta}_{0}]^{\\top}$ 的期望值为：\n$$\n\\mathbb{E}[\\hat{\\theta}_{0}] = (X_{0}^{\\top}X_{0})^{-1} X_{0}^{\\top}\\mathbb{E}[y] = \\begin{pmatrix} 1/100  0 \\\\ 0  1/100 \\end{pmatrix} \\begin{pmatrix} 60\\alpha_{1} + 40\\alpha_{2} \\\\ 20\\alpha_{1} - 20\\alpha_{2} + 100\\beta \\end{pmatrix} = \\begin{pmatrix} \\frac{60\\alpha_{1} + 40\\alpha_{2}}{100} \\\\ \\frac{20\\alpha_{1} - 20\\alpha_{2} + 100\\beta}{100} \\end{pmatrix}\n$$\n估计的条件效应 $\\hat{\\beta}_{0}$ 的期望值是第二个元素：\n$$\n\\mathbb{E}[\\hat{\\beta}_{0}] = \\frac{20\\alpha_{1} - 20\\alpha_{2} + 100\\beta}{100} = \\beta + \\frac{20}{100}(\\alpha_{1} - \\alpha_{2}) = \\beta + \\frac{1}{5}(\\alpha_{1} - \\alpha_{2})\n$$\n\n### 模型 $\\mathcal{M}_{1}$ 的分析（有特定于运行的截距）\n\n对于模型 $\\mathcal{M}_{1}$，设计矩阵为 $X_{1} = [r_{1}, r_{2}, s]$，待估计的参数向量为 $\\theta_{1} = [\\alpha'_{1}, \\alpha'_{2}, \\beta_{1}]^{\\top}$。\n\n真实的均值信号 $\\mathbb{E}[y] = \\alpha_{1}r_{1} + \\alpha_{2}r_{2} + \\beta s$ 可以写成 $\\mathbb{E}[y] = X_{1}\\theta_{\\text{true}}$，其中 $\\theta_{\\text{true}} = [\\alpha_{1}, \\alpha_{2}, \\beta]^{\\top}$。这意味着均值的真实数据生成模型被设计矩阵 $X_{1}$ 完美地指定了。在这种情况下，OLS 估计量对于真实参数是无偏的。我们可以从第一性原理证明这一点：\n$$\n\\mathbb{E}[\\hat{\\theta}_{1}] = (X_{1}^{\\top}X_{1})^{-1}X_{1}^{\\top}\\mathbb{E}[y] = (X_{1}^{\\top}X_{1})^{-1}X_{1}^{\\top}(X_{1}\\theta_{\\text{true}}) = [(X_{1}^{\\top}X_{1})^{-1}(X_{1}^{\\top}X_{1})]\\theta_{\\text{true}} = I\\theta_{\\text{true}} = \\theta_{\\text{true}}\n$$\n这要求 $X_{1}^{\\top}X_{1}$ 是可逆的，这是成立的，因为 $X_{1}$ 的列是线性无关的。\n因此，参数估计值的期望值等于真实参数：\n$$\n\\mathbb{E}[\\hat{\\theta}_{1}] = \\begin{pmatrix} \\mathbb{E}[\\hat{\\alpha}'_{1}] \\\\ \\mathbb{E}[\\hat{\\alpha}'_{2}] \\\\ \\mathbb{E}[\\hat{\\beta}_{1}] \\end{pmatrix} = \\begin{pmatrix} \\alpha_{1} \\\\ \\alpha_{2} \\\\ \\beta \\end{pmatrix}\n$$\n由此，估计的条件效应的期望值为：\n$$\n\\mathbb{E}[\\hat{\\beta}_{1}] = \\beta\n$$\n\n### 结果解释\n\n推导表明 $\\mathbb{E}[\\hat{\\beta}_{1}] = \\beta$，而 $\\mathbb{E}[\\hat{\\beta}_{0}] = \\beta + \\frac{1}{5}(\\alpha_{1} - \\alpha_{2})$。\n\n**控制会话均值**：模型 $\\mathcal{M}_{1}$ 被称为“控制”了会话均值差异，因为其对条件效应的估计 $\\hat{\\beta}_{1}$ 相对于真实效应 $\\beta$ 是无偏的，无论特定于运行的均值 $\\alpha_{1}$ 和 $\\alpha_{2}$ 的值是多少。这是因为 $\\hat{\\beta}_{1}$ 的 GLM 估计过程实际上只考虑了任务回归量 $s$ 中与干扰回归量（$r_{1}$ 和 $r_{2}$）所张成的空间正交的部分。这个由 Frisch-Waugh-Lovell 定理描述的正交化过程，等同于在每个运行内对回归量 $s$ 进行去均值化。由于结果回归量在每个运行内的均值为零，其与特定于运行的平均水平的相关性在数学上为零，因此其系数（$\\beta$）的估计不会被这些均值所污染。\n\n相比之下，模型 $\\mathcal{M}_{0}$ 未能控制会话均值。估计量 $\\hat{\\beta}_{0}$ 因项 $\\frac{1}{5}(\\alpha_{1} - \\alpha_{2})$ 而存在偏差。这是一个典型的遗漏变量偏差案例。真实模型包含独立的运行均值（$\\alpha_{1}, \\alpha_{2}$），但 $\\mathcal{M}_{0}$ 忽略了这一结构，迫使任何真实的运行均值差异被包含的回归量所吸收。任务回归量 $s$ 与运行之间的差异并不正交（因为 $s^{\\top}r_{1} \\neq 0$ 且 $s^{\\top}r_{2} \\neq 0$），因此 $(\\alpha_{1} - \\alpha_{2})$ 的部分效应被错误地归因于 $s$，从而产生偏差。只有当 $\\alpha_{1} = \\alpha_{2}$ 时，或者当任务在每个运行内是平衡的，使得 $s$ 与 $r_1$ 和 $r_2$ 正交时，偏差才为零。\n\n**跨运行对比的表示**：在 $\\mathcal{M}_{1}$ 中，参数 $\\hat{\\alpha}'_{1}$ 和 $\\hat{\\alpha}'_{2}$ 分别是运行 $1$ 和运行 $2$ 的平均 BOLD 信号的直接估计（在考虑了任务效应之后）。像会话均值差异这样的跨运行对比，可以使用一个对比向量（如 $c=[1, -1, 0]^{\\top}$）来正式检验假设 $\\alpha'_{1} - \\alpha'_{2} = 0$。因此，$\\mathcal{M}_{1}$ 明确地建模并允许对跨运行效应进行统计推断。在 $\\mathcal{M}_{0}$ 中，不存在这样的参数。只有一个截距 $\\hat{\\alpha}_{0}$，代表所有扫描的平均信号。无法构建一个对比来检验运行间的差异，因为这部分信息已被压缩并与 $\\beta$ 的估计相混淆。\n\n### 偏差计算\n\n当省略特定于运行的截距时，条件效应估计中的偏差定义为 $\\text{Bias} = \\mathbb{E}[\\hat{\\beta}_{0}] - \\beta$。\n使用我们推导出的 $\\mathbb{E}[\\hat{\\beta}_{0}]$ 的表达式：\n$$\n\\text{Bias} = \\left( \\beta + \\frac{1}{5}(\\alpha_{1} - \\alpha_{2}) \\right) - \\beta = \\frac{1}{5}(\\alpha_{1} - \\alpha_{2})\n$$\n该表达式量化了估计的条件效应中的系统误差，将其表示为真实的、未观测到的会话均值差异的函数。偏差与差异 $\\alpha_1 - \\alpha_2$ 成正比，其符号取决于该差异的方向以及任务不平衡的性质。在这里，由于运行 $1$ 中有更多的 'A' 试验，运行 $2$ 中有更多的 'B' 试验，如果运行 $1$ 的平均信号更高（$\\alpha_1  \\alpha_2$），那么估计值 $\\hat{\\beta}_0$ 将被人为地抬高。\n用一般的符号术语来说，偏差是：\n$$\n\\text{Bias} = \\frac{(N_{A1} - N_{B1})\\alpha_{1} + (N_{A2} - N_{B2})\\alpha_{2}}{N} = \\frac{20\\alpha_1 - 20\\alpha_2}{100} = \\frac{1}{5}(\\alpha_{1} - \\alpha_{2})\n$$",
            "answer": "$$\\boxed{\\frac{1}{5}(\\alpha_{1} - \\alpha_{2})}$$"
        }
    ]
}