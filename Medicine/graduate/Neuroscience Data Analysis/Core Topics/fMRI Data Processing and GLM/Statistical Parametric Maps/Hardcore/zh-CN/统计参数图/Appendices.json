{
    "hands_on_practices": [
        {
            "introduction": "在功能磁共振成像(fMRI)数据分析中，空间平滑是一个至关重要的预处理步骤，用于提高信噪比并弥补被试间解剖结构的差异。尽管研究者通常使用半高全宽（FWHM）来设定平滑程度，但其底层数学操作涉及由标准差 $\\sigma$ 定义的高斯核。本练习旨在阐明这两个参数之间的直接关系，帮助您深入理解这一常用分析选择的技术实现和控制原理 。",
            "id": "4196035",
            "problem": "在对高分辨率功能性磁共振成像（fMRI）进行的统计参数图（SPM）分析中，会使用各向同性的三维高斯核进行空间平滑，以适应被试间的解剖学变异性并满足随机场理论的假设。考虑一个三维各向同性高斯核，其标准差为 $\\sigma$，沿任意笛卡尔坐标轴的线性剖面可表示为一维高斯函数形式 $g(x) = A \\exp\\!\\big(-x^{2}/(2\\sigma^{2})\\big)$，其中 $A$ 是一个正的归一化常数。SPM 软件使用半峰全宽（FWHM）来报告平滑的程度，FWHM 定义为沿任意坐标轴上，$g(x)$ 达到其最大值一半的两个点之间的距离。\n\n从高斯函数和半峰全宽的定义出发，推导 $\\sigma$ 和 FWHM 之间的解析关系。然后，利用此关系，计算当各向同性 FWHM 为 $8.0$ 毫米时，$\\sigma$ 的值（单位：毫米）。将最终数值答案四舍五入至四位有效数字。以毫米（mm）为单位表示最终答案。",
            "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**第一步：提取已知条件**\n-   **背景**：功能性磁共振成像（fMRI）数据的统计参数图（SPM）分析。\n-   **平滑核**：各向同性的三维高斯核。\n-   **标准差**：$\\sigma$。\n-   **核的线性剖面**：$g(x) = A \\exp(-x^2 / (2\\sigma^2))$，其中 $A$ 是一个正的归一化常数。\n-   **半峰全宽（FWHM）的定义**：沿任意坐标轴，$g(x)$ 达到其最大值一半的两个点之间的距离。\n-   **任务1**：推导 $\\sigma$ 和 FWHM 之间的解析关系。\n-   **任务2**：对于 $8.0$ 毫米的各向同性 FWHM，计算 $\\sigma$ 的值（单位：毫米）。\n-   **精度要求**：将最终数值答案四舍五入到四位有效数字。\n\n**第二步：使用提取的已知条件进行验证**\n-   **科学依据**：该问题具有科学合理性。它描述了神经影像数据分析中的一个标准流程（fMRI 数据的空间平滑），该流程使用高斯核。高斯函数、其标准差 $\\sigma$ 以及其半峰全宽（FWHM）的概念在物理学和统计学中是基础且明确定义的。这些量之间的关系是一个标准的数学推导。\n-   **适定性**：该问题是适定的。它为高斯核的剖面提供了清晰的函数形式，并对 FWHM 进行了精确定义。目标是明确的：推导一个公式，然后用它来计算一个值。确定唯一解所需的所有信息均已提供。\n-   **客观性**：该问题以客观、正式的语言陈述，没有歧义或主观论断。\n\n**第三步：结论与行动**\n-   **结论**：该问题有效。它具有科学依据、适定、客观且完整。\n-   **行动**：继续进行求解。\n\n求解过程按要求分为两部分：首先，推导 $\\sigma$ 和 FWHM 之间的关系；其次，根据给定的 FWHM 计算 $\\sigma$。\n\n**第一部分：推导 $\\sigma$ 和 FWHM 之间的关系**\n\n高斯核的一维剖面由以下函数给出：\n$$g(x) = A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)$$\n其中 $A > 0$ 且 $\\sigma > 0$。\n\n首先，我们确定 $g(x)$ 的最大值，记为 $g_{\\text{max}}$。指数函数 $\\exp(u)$ 在其参数 $u$ 最大化时取得最大值。这里的参数是 $u = -x^2 / (2\\sigma^2)$。由于 $x^2 \\ge 0$ 且 $\\sigma^2 > 0$，该参数始终为非正数，即 $-x^2 / (2\\sigma^2) \\le 0$。参数的最大值为 $0$，此时 $x=0$。\n因此，函数 $g(x)$ 的最大值为：\n$$g_{\\text{max}} = g(0) = A \\exp\\left(-\\frac{0^2}{2\\sigma^2}\\right) = A \\exp(0) = A \\cdot 1 = A$$\n\n接下来，我们找出使 $g(x)$ 等于其最大值一半的 $x$ 值，即 $g(x) = \\frac{1}{2} g_{\\text{max}}$。\n$$\\frac{g_{\\text{max}}}{2} = \\frac{A}{2}$$\n我们将 $g(x)$ 设为该值并求解 $x$：\n$$A \\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) = \\frac{A}{2}$$\n由于 $A$ 是一个正常数，我们可以将等式两边同除以 $A$：\n$$\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right) = \\frac{1}{2}$$\n为了求解 $x$，我们对等式两边取自然对数 ($\\ln$)：\n$$\\ln\\left[\\exp\\left(-\\frac{x^2}{2\\sigma^2}\\right)\\right] = \\ln\\left(\\frac{1}{2}\\right)$$\n使用性质 $\\ln(\\exp(y)) = y$ 和 $\\ln(1/z) = -\\ln(z)$，我们得到：\n$$-\\frac{x^2}{2\\sigma^2} = -\\ln(2)$$\n两边乘以 $-1$：\n$$\\frac{x^2}{2\\sigma^2} = \\ln(2)$$\n现在，我们求解 $x^2$：\n$$x^2 = 2\\sigma^2 \\ln(2)$$\n这给出了 $x$ 的两个解：\n$$x = \\pm \\sqrt{2\\sigma^2 \\ln(2)} = \\pm \\sigma \\sqrt{2 \\ln(2)}$$\n设这两个点为 $x_1 = -\\sigma \\sqrt{2 \\ln(2)}$ 和 $x_2 = +\\sigma \\sqrt{2 \\ln(2)}$。\n\nFWHM 定义为这两点之间的距离：\n$$\\text{FWHM} = x_2 - x_1 = \\left(\\sigma \\sqrt{2 \\ln(2)}\\right) - \\left(-\\sigma \\sqrt{2 \\ln(2)}\\right)$$\n$$\\text{FWHM} = 2 \\sigma \\sqrt{2 \\ln(2)}$$\n这就是高斯函数的 FWHM 和 $\\sigma$ 之间的解析关系。\n\n**第二部分：$\\sigma$ 的计算**\n\n给定 $\\text{FWHM} = 8.0$ mm，要求计算 $\\sigma$。我们重新整理推导出的关系式以求解 $\\sigma$：\n$$\\sigma = \\frac{\\text{FWHM}}{2 \\sqrt{2 \\ln(2)}}$$\n代入给定的 FWHM 值：\n$$\\sigma = \\frac{8.0}{2 \\sqrt{2 \\ln(2)}} \\text{ mm}$$\n$2 \\sqrt{2 \\ln(2)}$ 这一项是一个常数。其近似值为：\n$$2 \\sqrt{2 \\ln(2)} \\approx 2 \\sqrt{2 \\times 0.693147} \\approx 2 \\sqrt{1.386294} \\approx 2 \\times 1.177410 \\approx 2.354820$$\n现在，我们计算 $\\sigma$：\n$$\\sigma \\approx \\frac{8.0}{2.354820} \\text{ mm} \\approx 3.397354 \\text{ mm}$$\n题目要求答案四舍五入到四位有效数字。前四位有效数字是 $3$、$3$、$9$ 和 $7$。第五位有效数字是 $3$，所以我们向下取整。\n$$\\sigma \\approx 3.397 \\text{ mm}$$",
            "answer": "$$\\boxed{3.397}$$"
        },
        {
            "introduction": "统计参数图（SPM）中的通用线性模型（GLM）通常通过将神经活动与标准血流动力学响应函数（HRF）进行卷积来建模。然而，真实 BOLD 响应的时间在不同脑区和个体之间可能存在差异。本练习将探讨一种应对此类延迟变化的标准技术，即在模型中引入 HRF 的时间导数作为额外的回归量，并通过简明的推导揭示其估计系数如何优雅地量化响应的延迟 。",
            "id": "4196024",
            "problem": "考虑一个在统计参数图 (SPM) 中使用通用线性模型 (GLM) 建模的事件相关血氧水平依赖 (BOLD) 时间序列。令典范血液动力学响应函数 (HRF) 回归量为一个列向量 $c \\in \\mathbb{R}^{T}$，它通过将刺激序列与典范 HRF进行卷积并在间隔 $\\Delta > 0$ 处采样而形成，并令时间导数回归量为一个列向量 $d \\in \\mathbb{R}^{T}$，它通过在相同时间点对典范 HRF 的时间导数进行采样而形成。为简化起见，假设只有一个条件且没有混淆变量。假设真实的无噪声信号由一个振幅 $A \\in \\mathbb{R}$ 和一个小的延迟位移 $\\tau \\in \\mathbb{R}$ (其中 $|\\tau| \\ll \\Delta$) 生成，因此采样后的响应遵循一阶泰勒近似 $c(t - \\tau) \\approx c(t) - \\tau \\, c^{\\prime}(t)$，这在采样设计中转化为列向量模型 $y = A \\left(c - \\tau d\\right) \\in \\mathbb{R}^{T}$。\n\n在 GLM 中，你构建一个包含两列的设计矩阵：典范回归量 $c$ 和时间导数回归量 $d$（经由 Gram–Schmidt 方法对 $c$ 进行正交化后得到 $d_{\\perp}$，满足 $c^{\\top} d_{\\perp} = 0$）。然后，你通过普通最小二乘法估计 GLM 系数 $\\beta_{\\text{canon}}$ 和 $\\beta_{\\text{deriv}}$。\n\n仅从响应位移的一阶泰勒近似以及正交投影和正交设计矩阵最小二乘法的标准性质出发，推导导数系数的普通最小二乘估计值 $\\hat{\\beta}_{\\text{deriv}}$ 的闭式解析表达式，该表达式仅含 $A$ 和 $\\tau$。你的最终答案必须是单一的解析表达式。不需要进行数值取整，最终表达式中也不应包含任何单位。",
            "solution": "用户要求我解决一个与统计参数图 (SPM) 和通用线性模型 (GLM) 相关的问题。我必须首先验证问题陈述，如果有效，则提供详细的推导过程和最终的方框答案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **模型：** 用于事件相关血氧水平依赖 (BOLD) 时间序列的通用线性模型 (GLM)。\n*   **回归量：**\n    *   $c \\in \\mathbb{R}^{T}$: 典范血液动力学响应函数 (HRF) 回归量。\n    *   $d \\in \\mathbb{R}^{T}$: 时间导数回归量。\n*   **数据模型（真实信号）：** 无噪声的采样响应通过一阶泰勒近似建模为 $y = A(c - \\tau d)$，其中：\n    *   $A \\in \\mathbb{R}$ 是信号振幅。\n    *   $\\tau \\in \\mathbb{R}$ 是一个小的延迟位移。\n*   **设计矩阵：** GLM 使用一个包含两列的设计矩阵 $X$：\n    *   第一列是典范回归量 $c$。\n    *   第二列是 $d_{\\perp}$，它是时间导数回归量 $d$ 经过 Gram-Schmidt 过程对 $c$ 正交化后的结果。这意味着性质 $c^{\\top} d_{\\perp} = 0$ 成立。\n*   **估计：** GLM 系数 $\\beta_{\\text{canon}}$ 和 $\\beta_{\\text{deriv}}$ 使用普通最小二乘法 (OLS) 进行估计。\n*   **目标：** 推导导数系数的 OLS 估计值 $\\hat{\\beta}_{\\text{deriv}}$ 的闭式解析表达式，该表达式仅包含 $A$ 和 $\\tau$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n*   **科学依据：** 该问题牢固地植根于 fMRI 数据分析的标准方法。使用带有典范 HRF 及其时间导数的 GLM 来建模延迟位移是 SPM 中一种成熟的基础技术。一阶泰勒级数近似是该方法的数学基础。该设定在科学上是合理的。\n*   **适定性：** 该问题提供了清晰的数据模型、定义明确的设计矩阵、指定的估计方法 (OLS) 和精确的目标。它包含了推导所请求参数的唯一解所需的所有必要信息。\n*   **目标：** 语言正式、精确，没有任何主观或模糊的术语。所有变量和过程（GLM、OLS、Gram-Schmidt）都是统计学和信号处理中的标准概念。\n\n该问题不具有任何无效性标志：\n1.  它在科学或事实上并非不合理。\n2.  它可以直接形式化，并与 SPM 的主题相关。\n3.  设定是完整且一致的。\n4.  所给条件是 fMRI 信号建模中使用的标准、公认的简化。\n5.  它是适定的，并允许一个唯一且有意义的解。\n6.  问题并非微不足道；它需要使用线性代数进行正式推导。\n7.  推导过程在数学上是可验证的。\n\n**步骤 3：结论与行动**\n\n问题是 **有效的**。现在开始推导解答。\n\n### 推导\n\n通用线性模型 (GLM) 表示为 $y = X\\beta + \\epsilon$，其中 $y$ 是数据向量，$X$ 是设计矩阵，$\\beta$ 是系数向量，$\\epsilon$ 是误差项。在本问题中，我们考虑无噪声情况，因此数据由 $y = A(c - \\tau d)$ 给出。\n\n设计矩阵为 $X = \\begin{pmatrix} c  d_{\\perp} \\end{pmatrix}$。待估计的系数向量为 $\\beta = \\begin{pmatrix} \\beta_{\\text{canon}} \\\\ \\beta_{\\text{deriv}} \\end{pmatrix}$。\n\n$\\beta$ 的普通最小二乘 (OLS) 估计由正规方程给出：\n$$ \\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y $$\n\n问题陈述设计矩阵的列是正交的，即 $c^{\\top}d_{\\perp} = 0$。这极大地简化了 $X^{\\top}X$ 项：\n$$ X^{\\top}X = \\begin{pmatrix} c^{\\top} \\\\ d_{\\perp}^{\\top} \\end{pmatrix} \\begin{pmatrix} c  d_{\\perp} \\end{pmatrix} = \\begin{pmatrix} c^{\\top}c  c^{\\top}d_{\\perp} \\\\ d_{\\perp}^{\\top}c  d_{\\perp}^{\\top}d_{\\perp} \\end{pmatrix} = \\begin{pmatrix} c^{\\top}c  0 \\\\ 0  d_{\\perp}^{\\top}d_{\\perp} \\end{pmatrix} $$\n该矩阵是对角矩阵。其逆矩阵也是对角矩阵：\n$$ (X^{\\top}X)^{-1} = \\begin{pmatrix} (c^{\\top}c)^{-1}  0 \\\\ 0  (d_{\\perp}^{\\top}d_{\\perp})^{-1} \\end{pmatrix} $$\n\n将此代回 OLS 估计量公式：\n$$ \\hat{\\beta} = \\begin{pmatrix} (c^{\\top}c)^{-1}  0 \\\\ 0  (d_{\\perp}^{\\top}d_{\\perp})^{-1} \\end{pmatrix} \\begin{pmatrix} c^{\\top} \\\\ d_{\\perp}^{\\top} \\end{pmatrix} y = \\begin{pmatrix} (c^{\\top}c)^{-1} c^{\\top}y \\\\ (d_{\\perp}^{\\top}d_{\\perp})^{-1} d_{\\perp}^{\\top}y \\end{pmatrix} $$\n\n我们感兴趣的是导数系数的估计值 $\\hat{\\beta}_{\\text{deriv}}$，它对应于 $\\hat{\\beta}$ 向量的第二个元素：\n$$ \\hat{\\beta}_{\\text{deriv}} = (d_{\\perp}^{\\top}d_{\\perp})^{-1} d_{\\perp}^{\\top}y = \\frac{d_{\\perp}^{\\top}y}{d_{\\perp}^{\\top}d_{\\perp}} $$\n\n现在，我们将给定的真实信号模型 $y = A(c - \\tau d)$ 代入此表达式：\n$$ \\hat{\\beta}_{\\text{deriv}} = \\frac{d_{\\perp}^{\\top} \\left[ A(c - \\tau d) \\right]}{d_{\\perp}^{\\top}d_{\\perp}} $$\n振幅 $A$ 是一个标量，可以提取出来：\n$$ \\hat{\\beta}_{\\text{deriv}} = \\frac{A}{d_{\\perp}^{\\top}d_{\\perp}} \\left( d_{\\perp}^{\\top}c - \\tau d_{\\perp}^{\\top}d \\right) $$\n\n根据构造，$d_{\\perp}$与 $c$ 正交，因此它们的点积 $d_{\\perp}^{\\top}c$ 为 $0$。表达式简化为：\n$$ \\hat{\\beta}_{\\text{deriv}} = \\frac{A}{d_{\\perp}^{\\top}d_{\\perp}} \\left( 0 - \\tau d_{\\perp}^{\\top}d \\right) = -A\\tau \\frac{d_{\\perp}^{\\top}d}{d_{\\perp}^{\\top}d_{\\perp}} $$\n\n最后一步是分析 $d_{\\perp}$、$d$ 和 $c$ 之间的关系。回归量 $d_{\\perp}$ 是通过使用 Gram-Schmidt 过程将 $d$ 相对于 $c$ 进行正交化得到的。这意味着我们从 $d$ 中减去 $d$ 在 $c$ 上的投影：\n$$ d_{\\perp} = d - \\text{proj}_{c}(d) = d - \\frac{c^{\\top}d}{c^{\\top}c}c $$\n\n现在我们来计算 $\\hat{\\beta}_{\\text{deriv}}$ 表达式分子中的项 $d_{\\perp}^{\\top}d$：\n$$ d_{\\perp}^{\\top}d = \\left( d - \\frac{c^{\\top}d}{c^{\\top}c}c \\right)^{\\top} d = d^{\\top}d - \\frac{c^{\\top}d}{c^{\\top}c}c^{\\top}d = \\|d\\|^2 - \\frac{(c^{\\top}d)^2}{\\|c\\|^2} $$\n\n接下来，我们计算分母中的项 $d_{\\perp}^{\\top}d_{\\perp}$ (即 $d_{\\perp}$ 的平方范数)。这种构造的一个关键特性是 $d_{\\perp}$ 与从 $d$ 中减去的那个分量正交。我们可以写出 $d = d_{\\perp} + \\text{proj}_{c}(d)$。由于 $d_{\\perp}$ 和 $\\text{proj}_{c}(d)$ 正交，向量的勾股定理适用：$\\|d\\|^2 = \\|d_{\\perp}\\|^2 + \\|\\text{proj}_{c}(d)\\|^2$。或者，我们可以直接计算 $d_{\\perp}^{\\top}d_{\\perp}$：\n$$ d_{\\perp}^{\\top}d_{\\perp} = d_{\\perp}^{\\top} \\left( d - \\frac{c^{\\top}d}{c^{\\top}c}c \\right) = d_{\\perp}^{\\top}d - \\frac{c^{\\top}d}{c^{\\top}c}d_{\\perp}^{\\top}c $$\n由于 $d_{\\perp}^{\\top}c=0$，第二项消失。这就给我们留下了一个至关重要的恒等式：\n$$ d_{\\perp}^{\\top}d_{\\perp} = d_{\\perp}^{\\top}d $$\n\n只要 $d_{\\perp}$ 不是零向量，这个恒等式就成立（这种情况仅在 $d$ 与 $c$ 完全共线时发生，对于此模型我们可以排除这种不切实际的情况）。\n\n将这个恒等式代回 $\\hat{\\beta}_{\\text{deriv}}$ 的表达式中：\n$$ \\hat{\\beta}_{\\text{deriv}} = -A\\tau \\frac{d_{\\perp}^{\\top}d}{d_{\\perp}^{\\top}d_{\\perp}} = -A\\tau \\frac{d_{\\perp}^{\\top}d_{\\perp}}{d_{\\perp}^{\\top}d_{\\perp}} = -A\\tau $$\n\n导数系数的 OLS 估计值直接是真实信号振幅和延迟位移的负乘积。",
            "answer": "$$ \\boxed{-A \\tau} $$"
        },
        {
            "introduction": "分析统计参数图时的一个核心挑战是多重比较问题：在数以万计的体素上进行假设检验会急剧增加假阳性的概率。本练习将实现一种强大的非参数解决方案——“最大t统计量”置换检验，以严格控制全族误差（FWE）。通过经验性地构建全脑最大统计量的零分布，该方法能够在不依赖数据空间属性的参数假设的情况下，进行有效的统计推断 。",
            "id": "4196015",
            "problem": "给定代表两组研究设计中统计参数图 (SPMs) 的逐体素数据矩阵。每个矩阵行对应一个受试者，每列对应一个体素。您的任务是使用体素间的最大绝对 t 统计量（max-t 方法）实现一个非参数族系误差 (FWE) 控制程序。程序必须为每个测试用例，通过穷举所有与所提供组大小一致的标签分配，构建最大绝对 t 统计量的经验置换分布。使用此置换分布，为每个体素分配一个双边 FWE 校正 p 值。\n\n使用的基本依据和假设：\n- 使用经典的两样本设计，其中两组由二元标签定义，并假设在原假设下标签是可交换的。\n- 在每个体素处使用合并方差双样本 t 统计量来量化组均值差异。该统计量必须根据当前标签分配得出的两组样本均值和样本方差，在每个体素处独立计算。\n- 通过考虑每个体素处 t 统计量的绝对值来进行双边检验。\n- 对于每次置换，计算所有体素中的最大绝对 t 统计量；这定义了来自 max-t 统计量零分布的一个样本。\n- 使用关于 max-t 统计量置换分布的包含性计数规则来计算 FWE 校正 p 值。\n\n您必须为每个测试用例实现以下步骤：\n1. 为两组构建观测标签集，并从数据矩阵中计算观测的逐体素 t 统计量。\n2. 穷举所有将指定数量的受试者精确地分到组1，其余受试者分到组2的唯一标签分配。对于每个这样的标签分配，计算逐体素 t 统计量，并保留所有体素中的最大绝对 t 统计量。这样就得到了 max-t 统计量的经验置换分布。\n3. 对于每个体素，将其 FWE 校正 p 值计算为置换 max-t 值中大于或等于该体素观测绝对 t 统计量的数值所占的比例，并根据包含性调整规则在分子和分母上都加 $1$。\n4. 如果在任何标签分配下，任何体素的 t 统计量计算中的分母等于 $0$，则对于该体素-标签组合，将相应的 t 统计量视为 $0$。\n5. 将报告的每个 p 值四舍五入到恰好六位小数。\n\n测试套件：\n实现您的程序以评估以下三个测试用例。在每个用例中，令 $Y \\in \\mathbb{R}^{n \\times v}$ 表示数据矩阵，其中有 $n$ 个受试者（行）和 $v$ 个体素（列）。观测标签由组1的索引集合给出；其补集构成组2。\n\n- 用例1（通用多体素）：\n  - $n = 8$, $v = 5$。\n  - 观测的组1索引：$\\{0, 1, 2, 3\\}$。\n  - 数据矩阵 $Y$，行按受试者 $0$ 到受试者 $7$ 的顺序列出：\n    - 受试者 $0$：$[0.5, 1.2, 2.5, -0.4, 0.1]$\n    - 受试者 $1$：$[-0.2, 0.9, 2.7, -0.6, -0.3]$\n    - 受试者 $2$：$[0.3, 1.1, 2.9, -0.7, 0.2]$\n    - 受试者 $3$：$[0.1, 1.0, 2.6, -0.5, 0.0]$\n    - 受试者 $4$：$[0.4, 0.8, 1.0, 0.2, -0.1]$\n    - 受试者 $5$：$[-0.1, 1.1, 0.9, 0.3, 0.1]$\n    - 受试者 $6$：$[0.2, 0.7, 1.1, 0.4, 0.0]$\n    - 受试者 $7$：$[0.0, 0.9, 0.8, 0.1, 0.2]$\n\n- 用例2（小样本，可能存在相同值）：\n  - $n = 4$, $v = 3$。\n  - 观测的组1索引：$\\{0, 1\\}$。\n  - 数据矩阵 $Y$：\n    - 受试者 $0$：$[1.0, 0.0, -0.2]$\n    - 受试者 $1$：$[1.1, 0.1, -0.1]$\n    - 受试者 $2$：$[0.9, -0.1, -0.2]$\n    - 受试者 $3$：$[1.2, 0.0, -0.1]$\n\n- 用例3（单体素边界情况）：\n  - $n = 6$, $v = 1$。\n  - 观测的组1索引：$\\{0, 1, 2\\}$。\n  - 数据矩阵 $Y$：\n    - 受试者 $0$：$[0.3]$\n    - 受试者 $1$：$[0.4]$\n    - 受试者 $2$：$[0.2]$\n    - 受试者 $3$：$[-0.1]$\n    - 受试者 $4$：$[0.0]$\n    - 受试者 $5$：$[0.1]$\n\n置换策略：\n- 对每个用例，穷举所有将指定数量的受试者分配到组1的唯一分配方式（即，所有所需大小的索引子集），并将每个分配视为一次独立的置换。\n\nFWE 校正 p 值策略：\n- 对于体素 $j$，令 $t^{\\mathrm{obs}}_j$ 为观测 t 统计量。令 $M$ 表示所有置换的最大绝对 t 统计量的多重集。FWE 校正 p 值是 $M$ 中大于或等于 $\\lvert t^{\\mathrm{obs}}_j \\rvert$ 的值的包含性比例，分子和分母均加 $1$。\n\n输出规范：\n- 最终的程序输出必须是单行，包含按顺序排列的三个用例的结果列表，其中每个用例的结果是其体素的 FWE 校正 p 值列表，四舍五入到六位小数。\n- 确切的输出格式为单行，不含多余文本和空格：例如，对于三个用例，它应该看起来像\n  - $[[p\\_{1,1},p\\_{1,2},\\dots],[p\\_{2,1},p\\_{2,2},\\dots],[p\\_{3,1},\\dots]]$\n  其中每个 $p\\_{i,j}$ 是一个四舍五入到六位的小数。\n\n角度和物理单位不适用。不得使用百分比；概率必须以小数形式报告。\n\n您的程序不得读取任何输入，并且必须按所提供的方式确定性地运行。它必须仅依赖于标准库和指定的数值库。",
            "solution": "该问题要求实现一个非参数置换检验程序，以在神经影像学背景下跨多个体素进行统计检验时控制族系误差率 (FWE)。指定的方法是最大绝对t统计量 (max-t) 方法，应用于两组研究设计。该解决方案涉及基于经验生成的零分布，为每个体素计算 FWE 校正 p 值。\n\n该方法的基本原理是在原假设 ($H_0$)下的可交换性概念。$H_0$ 假定两个实验组之间没有真实差异。如果这是真的，那么将组标签分配给单个受试者是任意的。因此，这些标签的任何置换都是等可能的。通过系统地重新分配标签，为每次重新分配计算一个检验统计量，并观察这些统计量的分布，我们可以构建一个经验零分布。该分布代表了在 $H_0$ 为真的假设下，纯粹由机遇预期的结果范围。\n\n为了控制 FWE——即在所有体素中犯一个或多个 I 类错误的概率——我们不能简单地使用单个体素的 t 统计量分布。相反，我们必须将整个检验族视为一个整体。max-t 方法通过构建*最大*统计量的零分布来实现这一点。对于标签的每次置换，我们计算每个体素的 t 统计量，并找出其绝对值的最大值。这个单一的值 $T_{\\text{max}}$ 是从零分布中抽取的一个样本，代表了在体积中任何位置偶然发现的最极端效应。\n\n分步过程如下：\n\n1.  **观测统计量计算**：首先，我们为原始的、未置换的数据计算检验统计量。对于每个体素 $j$，其中 $j \\in \\{1, \\dots, v\\}$，我们使用合并方差双样本 t 统计量。给定来自大小为 $n_1$ 的 $G_1$ 组和大小为 $n_2$ 的 $G_2$ 组的数据，体素 $j$ 的 t 统计量为：\n    $$ t_j = \\frac{\\bar{y}_{1j} - \\bar{y}_{2j}}{s_{p,j} \\sqrt{\\frac{1}{n_1} + \\frac{1}{n_2}}} $$\n    其中 $\\bar{y}_{1j}$ 和 $\\bar{y}_{2j}$ 分别是 $G_1$ 组和 $G_2$ 组在体素 $j$ 中数据的样本均值。$s_{p,j}$ 项是体素 $j$ 的合并标准差，由两组的样本方差 $s_{1j}^2$ 和 $s_{2j}^2$ 计算得出：\n    $$ s_{p,j} = \\sqrt{\\frac{(n_1-1)s_{1j}^2 + (n_2-1)s_{2j}^2}{n_1+n_2-2}} $$\n    对于数据为 $\\{y_i\\}$ 且均值为 $\\bar{y}$ 的组，其样本方差为 $s^2 = \\frac{1}{n-1}\\sum_{i=1}^{n}(y_i - \\bar{y})^2$。在 t 统计量的分母为零（即 $s_{p,j} = 0$）的特定情况下，问题要求将 t 统计量视为 $0$。这种情况仅当该体素的每个组内方差都为零时才会发生。我们为所有 $v$ 个体素计算这些观测统计量 $t^{\\text{obs}}_j$。\n\n2.  **最大统计量的置换分布**：我们生成将 $n$ 个受试者划分为大小为 $n_1$ 和 $n_2$ 的两组的所有唯一划分。此类划分（置换）的总数为 $N_{\\text{perm}} = \\binom{n}{n_1}$。对于每次置换：\n    a. 我们使用新的分组为每个体素 $j=1, \\dots, v$ 重新计算 t 统计量 $t_j^{\\text{perm}}$。\n    b. 我们找到这次置换中所有体素的最大绝对 t 统计量：\n       $$ T_{\\text{max}}^{\\text{perm}} = \\max_{j=1,\\dots,v} |t_j^{\\text{perm}}| $$\n    c. 存储该值。所有 $N_{\\text{perm}}$ 个这样的最大值集合构成了经验零分布 $M = \\{T_{\\text{max}}^{\\text{perm}_1}, T_{\\text{max}}^{\\text{perm}_2}, \\dots, T_{\\text{max}}^{\\text{perm}_{N_{\\text{perm}}}}\\}$。\n\n3.  **FWE 校正 p 值计算**：给定体素 $j$ 的 FWE 校正 p 值 $p_{\\text{FWE}, j}$，是在零分布中观测到至少与该体素的观测统计量 $|t^{\\text{obs}}_j|$ 一样极端的最大统计量的概率。这可以从我们的经验分布 $M$ 中估计。我们计算 $M$ 中大于或等于 $|t^{\\text{obs}}_j|$ 的元素数量。设此计数为 $k_j$。根据问题对包含性计算的规范，p 值由下式给出：\n    $$ p_{\\text{FWE}, j} = \\frac{k_j + 1}{N_{\\text{perm}} + 1} $$\n    该公式对有限的置换次数进行了调整，并确保 p 值永远不会为零，这是置换检验的一个理想属性。对每个体素 $j=1, \\dots, v$ 重复此过程。\n\n4.  **最终输出**：将每个测试用例得到的 p 值四舍五入到六位小数，并按指定格式输出。此过程提供了一种严格且可解释的统计显著性度量，它解决了全脑数据分析中固有的海量多重比较问题。",
            "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef solve():\n    \"\"\"\n    Main function to run the FWE correction procedure on all test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"Y\": np.array([\n                [0.5, 1.2, 2.5, -0.4, 0.1],\n                [-0.2, 0.9, 2.7, -0.6, -0.3],\n                [0.3, 1.1, 2.9, -0.7, 0.2],\n                [0.1, 1.0, 2.6, -0.5, 0.0],\n                [0.4, 0.8, 1.0, 0.2, -0.1],\n                [-0.1, 1.1, 0.9, 0.3, 0.1],\n                [0.2, 0.7, 1.1, 0.4, 0.0],\n                [0.0, 0.9, 0.8, 0.1, 0.2]\n            ]),\n            \"group1_indices\": {0, 1, 2, 3}\n        },\n        {\n            \"Y\": np.array([\n                [1.0, 0.0, -0.2],\n                [1.1, 0.1, -0.1],\n                [0.9, -0.1, -0.2],\n                [1.2, 0.0, -0.1]\n            ]),\n            \"group1_indices\": {0, 1}\n        },\n        {\n            \"Y\": np.array([\n                [0.3], [0.4], [0.2], [-0.1], [0.0], [0.1]\n            ]),\n            \"group1_indices\": {0, 1, 2}\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        Y = case[\"Y\"]\n        observed_group1_indices = case[\"group1_indices\"]\n        \n        n, v = Y.shape\n        n1 = len(observed_group1_indices)\n        all_indices = set(range(n))\n        \n        # Step 1: Compute observed t-statistics\n        observed_group2_indices = all_indices - observed_group1_indices\n        observed_t_stats = _compute_t_stats_for_labeling(Y, list(observed_group1_indices), list(observed_group2_indices))\n        abs_observed_t_stats = np.abs(observed_t_stats)\n\n        # Step 2: Enumerate permutations and build max-t distribution\n        max_t_distribution = []\n        all_possible_group1s = combinations(range(n), n1)\n        \n        num_permutations = 0\n        for g1_indices_perm_tuple in all_possible_group1s:\n            num_permutations += 1\n            g1_indices_perm = list(g1_indices_perm_tuple)\n            g2_indices_perm = list(all_indices - set(g1_indices_perm))\n            \n            t_stats_perm = _compute_t_stats_for_labeling(Y, g1_indices_perm, g2_indices_perm)\n            max_abs_t = np.max(np.abs(t_stats_perm))\n            max_t_distribution.append(max_abs_t)\n            \n        max_t_distribution = np.array(max_t_distribution)\n\n        # Step 3: Compute FWE-corrected p-values\n        p_values = []\n        for j in range(v):\n            observed_t_val = abs_observed_t_stats[j]\n            # Inclusive counting\n            k = np.sum(max_t_distribution >= observed_t_val)\n            # Add 1 to numerator and denominator\n            p_val = (k + 1) / (num_permutations + 1)\n            p_values.append(p_val)\n            \n        all_results.append(p_values)\n\n    # Format output string\n    case_strings = []\n    for p_list in all_results:\n        # Step 5: Round each p-value to exactly six decimal places\n        formatted_p_values = [f\"{p:.6f}\" for p in p_list]\n        case_strings.append(f\"[{','.join(formatted_p_values)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\ndef _compute_t_stats_for_labeling(Y, g1_indices, g2_indices):\n    \"\"\"\n    Computes pooled-variance two-sample t-statistics for all voxels.\n    \"\"\"\n    n, v = Y.shape\n    n1 = len(g1_indices)\n    n2 = len(g2_indices)\n    \n    # This should not happen in this problem's cases, but is good practice\n    if n1  2 or n2  2:\n        return np.zeros(v)\n\n    g1_data = Y[g1_indices, :]\n    g2_data = Y[g2_indices, :]\n\n    mean1 = np.mean(g1_data, axis=0)\n    mean2 = np.mean(g2_data, axis=0)\n    \n    var1 = np.var(g1_data, axis=0, ddof=1)\n    var2 = np.var(g2_data, axis=0, ddof=1)\n    \n    # Pooled standard deviation\n    s_p_squared_num = (n1 - 1) * var1 + (n2 - 1) * var2\n    s_p_squared_den = n1 + n2 - 2\n    \n    # Handle cases where denominator is zero (i.e. all data points are same)\n    if s_p_squared_den == 0:\n        return np.zeros(v)\n\n    pooled_var = s_p_squared_num / s_p_squared_den\n    \n    # Avoid sqrt of negative due to floating point inaccuracies\n    pooled_var[pooled_var  0] = 0\n    pooled_std = np.sqrt(pooled_var)\n\n    # t-statistic denominator\n    t_stat_den_factor = np.sqrt(1/n1 + 1/n2)\n    t_stat_denominator = pooled_std * t_stat_den_factor\n    \n    # Compute t-statistic, handling zero denominator as per problem spec\n    t_stats = np.zeros(v)\n    non_zero_den_mask = t_stat_denominator != 0\n    t_stats[non_zero_den_mask] = (mean1[non_zero_den_mask] - mean2[non_zero_den_mask]) / t_stat_denominator[non_zero_den_mask]\n    \n    return t_stats\n\nsolve()\n```"
        }
    ]
}