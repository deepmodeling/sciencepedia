{
    "hands_on_practices": [
        {
            "introduction": "在多重检验中，控制族系误差率 (FWER) 是最严格的标准，确保了在整个检验族中犯下任何一个I类错误的概率都低于预设水平。Hochberg 升阶程序是一种经典且强大的 FWER 控制方法，它通常比传统的 Bonferroni 校正更具统计功效。通过这个练习 ，你将亲手操作 p 值的排序、阈值计算和决策过程，从而牢固掌握该程序的运作机制。",
            "id": "4179693",
            "problem": "一个实验室正在分析四个皮层区域的尖峰序列衍生特征，以评估与条件相关的神经活动变化。每个区域都会产生一个单独的假设检验，将特定条件与基线进行比较。设有 $m=4$ 个零假设，其观测到的 $p$ 值为 $p=(0.001, 0.02, 0.03, 0.2)$。分析目标是控制族系误差率 (FWER)，其定义为在 $m$ 个零假设中至少做出一次错误拒绝的概率 $P(V \\ge 1)$。在大规模神经生理学中，标准的做法是依赖于有效的 $p$ 值，即在原假设为真的情况下，每个 $p$ 值都随机地被一个 $\\text{Uniform}(0,1)$ 随机变量所控制。此外，联合分布条件（如独立性或某些形式的正相关性）可以从数据生成过程中评估（例如，通过研究设计或预白化后的残差诊断）。\n\n从这些基本定义和事实出发，并且不假设任何快捷公式，请完成以下任务：\n\n1. 陈述用于控制 FWER 的 Hochberg 升阶多重检验程序，包括 $p$ 值的排序、决策规则和临界值族。您的陈述必须明确包括保证 FWER 控制的联合依赖结构要求（独立性或指定的正相关条件）。\n2. 将所述程序应用于给定的 $p$ 值 $p=(0.001, 0.02, 0.03, 0.2)$，在 $\\alpha=0.05$ 的水平下，确定要拒绝的零假设的总数。\n\n将您的最终答案报告为等于拒绝数量的单个整数。无需四舍五入。最终答案中不应包含任何单位。",
            "solution": "所陈述的问题在形式上是合理且定义明确的。它提出了一个基于多重假设检验既定原则的标准统计任务。所有必要的数据和条件都已提供，不存在科学或逻辑上的不一致。\n\n该问题需要两部分的回答：首先，对 Hochberg 升阶程序的正式陈述；其次，将其应用于所提供的数据。\n\n### 第1部分：Hochberg 升阶程序\n\n设有 $m$ 个零假设 $H_1, H_2, \\dots, H_m$，以及对应的观测 $p$ 值 $p_1, p_2, \\dots, p_m$。目标是在预先指定的显著性水平 $\\alpha$ 下控制族系误差率 (FWER)。FWER 是在一族假设中犯一个或多个 I 型错误（错误拒绝）的概率。Hochberg 程序是一种升阶方法，在特定条件下提供这种控制。\n\n该程序按以下步骤执行：\n\n1.  **$p$ 值排序**：将 $m$ 个观测到的 $p$ 值从小到大排序：\n    $$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$$\n    令 $H_{(1)}, H_{(2)}, \\dots, H_{(m)}$ 为与这些排序后的 $p$ 值相对应的零假设。\n\n2.  **临界值族**：对于每个排序后的 $p$ 值 $p_{(i)}$，其中 $i \\in \\{1, 2, \\dots, m\\}$，定义一个临界值。Hochberg 程序使用由下式给出的临界值族 $c_i$：\n    $$c_i = \\frac{\\alpha}{m - i + 1}$$\n    这些临界值与 Holm-Bonferroni 降阶程序中的临界值相同，但应用方式不同。\n\n3.  **决策规则**：Hochberg 升阶程序的决策规则如下：\n    找到满足不等式\n    $$p_{(k)} \\le \\frac{\\alpha}{m - k + 1}$$\n    的最大索引 $k \\in \\{1, 2, \\dots, m\\}$。\n    - 如果存在这样的索引 $k$，则拒绝所有零假设 $H_{(j)}$，其中 $j = 1, 2, \\dots, k$。\n    - 如果不存在这样的索引 $k$（即，对于任何 $i \\in \\{1, \\dots, m\\}$，不等式都不成立），则不拒绝任何零假设。\n\n4.  **依赖条件**：Hochberg 程序被证明在对应于真零假设的 $p$ 值是独立的假设下，能将 FWER 控制在水平 $\\alpha$（即 $FWER \\le \\alpha$）。Sarkar (1998) 后来将此保证扩展到适用于子集正回归依赖 (PRDS) 的情况，这是一种在许多生物和物理系统中都具有相关性的正相关形式。\n\n### 第2部分：应用于给定数据\n\n我们得到以下信息：\n- 假设数量：$m=4$\n- 观测到的 $p$ 值：$p=(0.001, 0.02, 0.03, 0.2)$\n- 期望的 FWER 控制水平：$\\alpha=0.05$\n\n我们现在逐步应用 Hochberg 程序。\n\n1.  **对 $p$ 值进行排序**：给定的 $p$ 值已经排好序。排序后的集合是：\n    $$p_{(1)} = 0.001$$\n    $$p_{(2)} = 0.02$$\n    $$p_{(3)} = 0.03$$\n    $$p_{(4)} = 0.2$$\n\n2.  **应用决策规则**：Hochberg 是一种升阶（step-up）程序，我们从最大的 $p$ 值开始反向搜索，寻找满足条件 $p_{(k)} \\le \\frac{\\alpha}{m - k + 1}$ 的最大索引 $k$。\n\n    - 对于 $k=4$：我们检验 $p_{(4)} \\le \\frac{0.05}{4-4+1}$。$0.2 \\not\\le 0.05$。条件不满足。\n    - 对于 $k=3$：我们检验 $p_{(3)} \\le \\frac{0.05}{4-3+1}$。$0.03 \\not\\le 0.025$。条件不满足。\n    - 对于 $k=2$：我们检验 $p_{(2)} \\le \\frac{0.05}{4-2+1}$。$0.02 \\not\\le 0.01667$。条件不满足。\n    - 对于 $k=1$：我们检验 $p_{(1)} \\le \\frac{0.05}{4-1+1}$。$0.001 \\le 0.0125$。条件满足。\n\n3.  **确定拒绝**：满足条件的最大的索引是 $k=1$。根据 Hochberg 的决策规则，我们拒绝所有 $j=1, \\dots, k$ 的假设。因此，我们仅拒绝假设 $H_{(1)}$，它对应于 $p$ 值 $0.001$。\n\n因此，要拒绝的零假设总数为 $1$。",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "在神经科学的大规模探索性研究中，控制错误发现率 (FDR) 通常比控制 FWER 更为合适，因为它在发现真实效应方面提供了更大的统计功效。本练习  不仅要求你应用 Benjamini-Hochberg (BH) 程序计算调整后的 q 值，更重要的是，它促使你思考一个核心的实际问题：测试之间的统计依赖性（例如，频域分析中的谱泄漏）如何影响 BH 程序的有效性。",
            "id": "4179721",
            "problem": "您正在分析两种神经活动条件下的频谱功率差异，分析涵盖 $m=100$ 个离散傅里叶频率点。您使用每个条件下试验平均的功率估计，并在每个频率点上进行双样本 $t$-检验。假设在标准条件下，$p$-值是有效的：在给定频率的原假设下，$p$-值是连续的，并且随机地大于或等于一个在 $[0,1]$ 区间上的均匀随机变量；在备择假设下，$p$-值倾向于较小。在计算出所有频率的 $p$-值并将其从小到大排序为 $p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(m)}$ 后，您凭经验发现在顺序统计量中存在一个近似线性的关系，该关系与 $p_{(k)} = \\lambda k$ (对于所有 $k \\in \\{1,2,\\dots,100\\}$) 相符，其中 $\\lambda = 5 \\times 10^{-3}$。\n\n使用 Benjamini–Hochberg (BH) 错误发现率程序，当 $p_{(k)} = \\lambda k$ 时，从第一性原理推导出一个用 $m$ 和 $\\lambda$ 表示的 BH 校正后 $q$-值 $q_{(k)}$ 的表达式，然后计算 BH 校正后 $q$-值 $q_{(40)}$ 的数值。\n\n另外，请讨论频谱功率中跨频率的依赖性（例如，由周期图或 Welch 方法中的加窗和频谱泄漏引起的依赖性）如何影响 BH 错误发现率控制的有效性。您的讨论应指明 BH 方法在何种依赖条件下被证明是有效的，以及违反这些条件如何促使人们采用替代程序。\n\n将 $q_{(40)}$ 的最终数值答案表示为一个无单位的纯数。无需四舍五入，请报告精确值。",
            "solution": "该问题要求分三部分作答：首先，在排序后的 $p$-值遵循指定线性模型的情况下，推导 Benjamini-Hochberg (BH) 校正后 $q$-值的表达式；其次，计算其中一个 $q$-值的具体数值；第三，讨论统计依赖性对 BH 程序有效性的理论影响。\n\n**第一部分：BH 校正后 $q$-值表达式的推导**\n\nBenjamini-Hochberg (BH) 程序提供了对错误发现率 (FDR) 的控制。实现该程序的一种方法是计算校正后的 $p$-值，通常称为 $q$-值。对于一组 $m$ 个原始 $p$-值 $p_1, p_2, \\dots, p_m$，将其排序得到 $p_{(1)} \\leq p_{(2)} \\leq \\dots \\leq p_{(m)}$，第 $k$ 个排序后 $p$-值 $p_{(k)}$ 对应的 BH 校正后 $q$-值 $q_{(k)}$ 的定义是为了确保原始调整的单调性。其定义为：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( \\frac{m}{j} p_{(j)} \\right)\n$$\n这也可以通过一个保证 $q_{(1)} \\leq q_{(2)} \\leq \\dots \\leq q_{(m)}$ 的递归过程来表示：令 $q'_{(k)} = \\frac{m}{k} p_{(k)}$。那么校正后的 $q$-值为 $q_{(m)} = p_{(m)}$ 以及 $q_{(k)} = \\min(q_{(k+1)}, p_{(k)} \\frac{m}{k})$，其中 $k = m-1, \\dots, 1$。这两种表述是等价的。我们将使用第一种更直接的定义进行推导。\n\n问题指出，排序后的 $p$-值凭经验遵循以下线性关系：\n$$\np_{(k)} = \\lambda k\n$$\n对于所有 $k \\in \\{1, 2, \\dots, m\\}$，其中 $m=100$ 是检验次数（频率点），$\\lambda = 5 \\times 10^{-3}$ 是一个常数。首先，我们必须确保这些是有效的 $p$-值，即它们位于区间 $[0,1]$ 内。最大的 $p$-值是 $p_{(m)} = \\lambda m = (5 \\times 10^{-3}) \\times 100 = 0.5$，该值小于或等于 $1$，因此该模型是良定义的。\n\n我们将给定的 $p_{(j)}$ 表达式代入 $q_{(k)}$ 的定义中：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( \\frac{m}{j} (\\lambda j) \\right)\n$$\n分子和分母中的索引变量 $j$ 相互抵消：\n$$\nq_{(k)} = \\min_{j=k, \\dots, m} \\left( m \\lambda \\right)\n$$\n最小值运算符内的表达式 $m \\lambda$ 是一个相对于索引 $j$ 的常数。因此，在从 $k$ 到 $m$ 的任何索引 $j$ 范围内，这个常数值的最小值就是该常数值本身。\n\n这就得出了 BH 校正后 $q$-值的推导表达式：\n$$\nq_{(k)} = m \\lambda\n$$\n该表达式对所有 $k \\in \\{1, 2, \\dots, m\\}$ 都成立。这表明，对于这个特定的 $p$-值线性模型，BH 校正后的 $q$-值对于所有假设都是一个常数。\n\n**第二部分：$q_{(40)}$ 的数值计算**\n\n使用推导出的表达式 $q_{(k)} = m \\lambda$，我们可以计算 $q_{(40)}$ 的数值。给定值为：\n- 检验次数（频率点），$m=100$。\n- 比例常数，$\\lambda = 5 \\times 10^{-3}$。\n\n将这些值代入我们的表达式中：\n$$\nq_{(40)} = m \\lambda = 100 \\times (5 \\times 10^{-3}) = 100 \\times 0.005 = 0.5\n$$\n因此，第 40 个排序后 $p$-值对应的 BH 校正后 $q$-值的数值为 0.5。\n\n**第三部分：关于依赖性与 BH 程序的讨论**\n\nBenjamini-Hochberg (BH) 程序被证明在针对 $m$ 次检验的两个主要条件下，能够将错误发现率 (FDR) 控制在 $\\alpha$ 水平（即 $\\text{FDR} \\leq \\alpha$）：\n$1$. $m$ 次检验在统计上是独立的。\n$2$. $m$ 次检验表现出一种被称为“在真实原假设子集上的正回归依赖性”(Positive Regression Dependency on the Subset of true null hypotheses, PRDS) 的特定正依赖形式。\n\nPRDS 条件是一个技术性要求，但在许多检验统计量呈正相关的常见场景下，该条件是满足的，例如检验统计量服从具有非负相关矩阵的多元正态分布。\n\n在分析神经数据频谱功率的背景下，跨不同频率点的独立性假设通常是不成立的。由于方法学和生理学两方面的原因，相邻频率的功率估计通常呈正相关：\n- **方法学相关性（频谱泄漏）：** 使用快速傅里叶变换等方法（例如在周期图或 Welch 方法中）分析有限长度的时间序列时，需要对数据进行加窗。这个过程等同于将真实频谱与窗函数的傅里叶变换进行卷积。这种卷积会导致特定频率的功率“泄漏”到相邻频点中，从而在相邻频率的功率估计之间引起正相关。\n- **生理学相关性：** 神经振荡并非单一频率上的完美正弦波，而是通常具有一定的带宽。因此，单个振荡过程可以为一系列相邻的频率点贡献功率，从而产生一种生理学来源的正相关。\n\n鉴于频谱功率分析中的依赖性主要是正向的，PRDS 条件通常被假定为满足。因此，标准的 BH 程序被认为是该领域控制 FDR 的一种有效且稳健的方法，并在神经科学中得到广泛应用。\n\n然而，如果检验之间的依赖结构是任意的或包含显著的负相关，BH 程序就不能保证控制 FDR。在这种情况下，实际的 FDR 可能会超过名义水平 $\\alpha$。为解决此问题，已开发出一些替代程序：\n- **Benjamini-Yekutieli (BY) 程序：** 这是对 BH 程序的一种更为保守的修正，它被证明可以在任意依赖结构下控制 FDR。它通过将一个更严格的校正因子（通常为 $c(m) = \\sum_{i=1}^{m} \\frac{1}{i}$）应用于显著性阈值来实现这一点。与标准 BH 程序相比，这种得到保证的控制是以降低统计功效为代价的。\n- **基于置换的方法：** 在存在复杂且未知的依赖结构时，非参数方法（如置换检验）为控制错误率（无论是族总错误率 FWER 还是 FDR）提供了一种强大的替代方案。通过多次置换条件标签并重新计算检验统计量，这些方法可以生成一个经验零分布，该分布保留了数据中固有的复杂相关模式。基于聚类的置换检验在电生理学中尤其常用，用于处理强烈的时空或频谱相关性。",
            "answer": "$$\\boxed{0.5}$$"
        },
        {
            "introduction": "统计方法的理论保证往往依赖于在实践中难以完全验证的假设。本练习  将带你从理论计算转向经验验证，这是现代神经数据分析师的一项关键技能。你将通过编写代码来模拟相关的检验数据，并凭经验检验 Simes 全局检验在存在相关性的情况下是否仍能将其 I 类错误率控制在名义水平附近，从而深入理解其稳健性。",
            "id": "4179770",
            "problem": "考虑一个全局零假设的多重检验场景，其中 $m$ 个同时进行的检验统计量联合呈高斯分布，均值为 $0$，相关矩阵的对角线元素为 $1$，所有元素对的非对角线相关系数为常数 $\\rho$。在全局零假设下，每个单独的检验统计量边际上服从标准正态分布，因此可以得出一个有效的双边 $p$ 值。在这种设置下，Simes 全局零假设检验的动机源于第一类错误（拒绝一个为真的全局零假设）的基本定义，以及在零假设下每个 $p$ 值随机不小于从区间 $(0,1)$ 上的均匀分布中抽取的样本这一事实。目标是通过模拟来经验性地验证，在存在具有非负成对相关性的等相关高斯检验统计量的情况下，Simes 决策规则是否能将第一类错误率维持在名义显著性水平附近。\n\n基本原理：\n- 在全局零假设下，每个检验统计量边际上服从 $\\mathcal{N}(0,1)$ 分布，其双边 $p$ 值是有效的，意味着在连续极限下它在 $(0,1)$ 上均匀分布。\n- Simes 全局零假设检验的定义是：对观测到的 $p$ 值进行排序，并将它们的有序组合与显著性水平进行比较。具体来说，如果 $p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$ 是排序后的 $p$ 值，当 $\\min_{1 \\le i \\le m} \\left\\{ \\frac{m\\,p_{(i)}}{i} \\right\\} \\le \\alpha$ 时，Simes 决策规则拒绝全局零假设，其中 $\\alpha$ 是选定的显著性水平。\n- 经验第一类错误率是指，在全局零假设实际上为真的情况下，决策规则拒绝该假设的模拟实验所占的比例。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n1. 对于下面测试套件中的每个参数集，生成 $n$ 个独立的 $m$ 维高斯检验统计量的实现。这些统计量的均值向量为 $0$，协方差矩阵 $\\Sigma$ 为等相关矩阵，即 $\\Sigma_{ii} = 1$ 且对于 $i \\ne j$ 有 $\\Sigma_{ij} = \\rho$。所有模拟都在全局零假设下进行。\n2. 使用边际标准正态分布将每个检验统计量转换为双边 $p$ 值。\n3. 实现上述的 Simes 全局零假设决策规则。\n4. 通过计算被拒绝的模拟实现的比例，以小数形式估计经验第一类错误率。\n5. 生成单行输出，其中包含所有测试用例的结果，形式为方括号内以逗号分隔的列表。每个值必须四舍五入到四位小数，并以小数表示，而非百分比。\n\n角度单位不适用。无物理单位适用。所有最终结果均以小数表示。\n\n测试套件（每个用例是一个元组 $(m,\\rho,\\alpha,n,\\text{seed})$）：\n- 用例 A (happy path): $(5,\\,0.4,\\,0.05,\\,200000,\\,12345)$。\n- 用例 B (independence baseline): $(5,\\,0.0,\\,0.05,\\,100000,\\,271828)$。\n- 用例 C (strong positive correlation): $(5,\\,0.9,\\,0.05,\\,100000,\\,1618033)$。\n- 用例 D (small family size): $(2,\\,0.4,\\,0.05,\\,100000,\\,101)$。\n- 用例 E (higher nominal level): $(5,\\,0.4,\\,0.10,\\,100000,\\,2025)$。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，$\"[0.0512,0.0498,0.0501,0.0499,0.0987]\"$）。每个条目对应于相应测试用例的经验第一类错误率，四舍五入到四位小数。",
            "solution": "该问题要求在检验统计量之间存在特定依赖结构的情况下，对 Simes 全局零假设检验的第一类错误率进行经验估计。所用方法涉及蒙特卡洛模拟，这是计算统计学中一种标准而强大的技术，用于在解析解难以获得时研究统计程序的性质。解决方案是通过执行一系列基于统计理论的步骤构建的。\n\n首先，我们对相关的检验统计量进行建模。问题假设了一个包含 $m$ 个同时假设检验的场景。在全局零假设（即所有单个零假设都为真）下，相应的检验统计量 $Z = (Z_1, Z_2, \\dots, Z_m)$ 从一个多元正态分布中抽取，其均值向量为零向量 $\\mathbf{0}$，协方差矩阵为特定的 $\\Sigma$。这表示为 $Z \\sim \\mathcal{N}_m(\\mathbf{0}, \\Sigma)$。该协方差矩阵被指定为具有等相关结构：所有对角线元素为 $1$，即 $\\Sigma_{ii} = 1$，所有非对角线元素为常数 $\\rho$，即对于 $i \\neq j$ 有 $\\Sigma_{ij} = \\rho$。这种结构意味着每个检验统计量边际上服从标准正态分布 $Z_k \\sim \\mathcal{N}(0,1)$，并且任意一对检验统计量 $(Z_i, Z_j)$ 的相关系数为 $\\rho$。为使 $\\Sigma$ 成为一个有效（半正定）的协方差矩阵，$\\rho$ 必须满足条件 $-\\frac{1}{m-1} \\le \\rho \\le 1$。测试套件中给出的 $\\rho$ 值均满足此条件。为实现这一步，我们首先为给定的 $m$ 和 $\\rho$ 构建 $m \\times m$ 矩阵 $\\Sigma$。然后，我们从该 $\\mathcal{N}_m(\\mathbf{0}, \\Sigma)$ 分布中生成 $n$ 个独立的随机向量，从而得到一个 $n \\times m$ 的模拟检验统计量数组。\n\n其次，我们将生成的检验统计量转换为 $p$ 值。由于在零假设下，每个检验统计量 $Z_k$ 边际上服从标准正态分布 $\\mathcal{N}(0,1)$，我们可以为每个观测到的统计量 $z_k$ 计算一个双边 $p$ 值。$p$ 值定义为：假设零假设为真时，观测到至少与已观测到的检验统计量一样极端的统计量的概率。对于双边检验，这个概率是 $p_k = P(|Z_k| \\ge |z_k|)$。考虑到标准正态分布的对称性，这可以计算为 $p_k = 2 \\times P(Z_k \\le -|z_k|) = 2 \\times \\Phi(-|z_k|)$，其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。此转换被逐元素地应用于整个 $n \\times m$ 的模拟检验统计量数组，生成一个 $n \\times m$ 的 $p$ 值数组。\n\n第三，我们应用 Simes 全局零假设决策规则。Simes 检验提供了一种结合 $m$ 个单独的 $p$ 值以对全局零假设做出单一决策的方法。该过程首先将每次模拟的 $p$ 值按非递减顺序排序：$p_{(1)} \\le p_{(2)} \\le \\dots \\le p_{(m)}$。然后，如果至少有一个排序后的 $p$ 值相对于其秩“足够小”，Simes 检验便会拒绝全局零假设。形式上，在显著性水平 $\\alpha$ 下，如果 Simes 统计量小于或等于 $\\alpha$，则满足拒绝条件：\n$$\n\\min_{1 \\le i \\le m} \\left\\{ \\frac{m\\,p_{(i)}}{i} \\right\\} \\le \\alpha\n$$\n这在逻辑上等同于检查是否存在任何索引 $i \\in \\{1, \\dots, m\\}$ 使得 $p_{(i)} \\le \\frac{i\\alpha}{m}$。对于 $n$ 次模拟中的每一次（即 $p$ 值矩阵的每一行），我们对 $p$ 值进行排序，计算项序列 $\\frac{m p_{(i)}}{i}$，找到该序列中的最小值，并检查它是否小于或等于指定的 $\\alpha$。这个过程确定了 $n$ 次试验中哪些导致了对全局零假设的拒绝。\n\n最后，我们估计经验第一类错误率。在此背景下，第一类错误指的是在全局零假设实际上为真的情况下拒绝它。由于我们的整个模拟都是在全局零假设下构建的，因此 Simes 规则的任何拒绝都是第一类错误。经验第一类错误率（在这种多重检验背景下通常表示为族内错误率 FWER）被估计为导致拒绝的模拟所占的比例。其计算公式为：\n$$\n\\widehat{\\text{FWER}} = \\frac{\\text{拒绝次数}}{n}\n$$\n其中 $n$ 是模拟实验的总次数。这个蒙特卡洛估计为 Simes 检验的性能提供了经验性验证。对测试套件中提供的每个参数集重复整个过程，并为每个用例重置随机数生成器的种子以确保可复现性。然后将每个用例的最终结果四舍五入到四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Empirically estimates the type I error rate of the Simes global null test\n    for equicorrelated Gaussian test statistics through Monte Carlo simulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (m, rho, alpha, n, seed)\n        (5, 0.4, 0.05, 200000, 12345),\n        (5, 0.0, 0.05, 100000, 271828),\n        (5, 0.9, 0.05, 100000, 1618033),\n        (2, 0.4, 0.05, 100000, 101),\n        (5, 0.4, 0.10, 100000, 2025),\n    ]\n\n    results = []\n    for m, rho, alpha, n, seed in test_cases:\n        # Step 1: Initialize random number generator for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Step 2: Generate m-dimensional Gaussian test statistics.\n        # Define the mean vector (all zeros under the null).\n        mean_vector = np.zeros(m)\n        \n        # Construct the equicorrelation covariance matrix.\n        cov_matrix = np.full((m, m), rho)\n        np.fill_diagonal(cov_matrix, 1)\n\n        # Generate n realizations from the multivariate normal distribution.\n        # test_stats is an (n, m) array.\n        test_stats = rng.multivariate_normal(mean_vector, cov_matrix, size=n)\n\n        # Step 3: Transform test statistics to two-sided p-values.\n        # p = 2 * P(Z > |z|) = 2 * (1 - CDF(|z|))\n        p_values = 2 * (1 - norm.cdf(np.abs(test_stats)))\n\n        # Step 4: Implement the Simes global null decision rule.\n        # Sort p-values for each simulation (along rows).\n        sorted_p = np.sort(p_values, axis=1)\n\n        # Create an array of indices [1, 2, ..., m].\n        i_array = np.arange(1, m + 1)\n\n        # Calculate the Simes terms {m*p_(i) / i} for each simulation.\n        # Broadcasting rules apply i_array to each row of sorted_p.\n        simes_terms = (m * sorted_p) / i_array\n        \n        # Find the Simes statistic for each simulation (minimum term).\n        simes_statistics = np.min(simes_terms, axis=1)\n\n        # Count the number of rejections (where statistic = alpha).\n        num_rejections = np.sum(simes_statistics = alpha)\n\n        # Step 5: Estimate the empirical type I error rate.\n        error_rate = num_rejections / n\n        \n        # Store the result, formatted to four decimal places.\n        results.append(f\"{error_rate:.4f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}