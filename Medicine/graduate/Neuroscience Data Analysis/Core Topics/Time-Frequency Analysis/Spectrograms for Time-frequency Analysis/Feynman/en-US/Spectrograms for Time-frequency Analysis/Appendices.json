{
    "hands_on_practices": [
        {
            "introduction": "The core challenge in time-frequency analysis is balancing temporal and spectral precision, a manifestation of the uncertainty principle. This exercise provides a practical application of this principle, guiding you to determine the minimum analysis window duration required to resolve distinct neural oscillations. By working through this calculation , you will gain an intuitive and quantitative grasp of how window length ($L$) directly governs frequency resolution ($\\Delta f$).",
            "id": "4194060",
            "problem": "A cortical local field potential (LFP) recording is sampled at a rate of $f_{s} = 2000$ Hz and analyzed with a spectrogram computed via the Short-Time Fourier Transform (STFT). The time-frequency tiles are produced by applying a length-$L$ Hann window to successive data segments. You aim to resolve narrowband high-gamma activity centered near $80$ Hz such that distinct components separated by $5$ Hz are not smeared together by the window’s spectral main lobe. Using only fundamental definitions of the STFT and the windowed Fourier transform, and the well-tested approximation that for a Hann window the main-lobe width between the first zeros in digital angular frequency is approximately $\\Delta \\omega_{\\mathrm{ML}} \\approx 8\\pi/L$, derive from first principles the minimum window duration $T_{\\min}$ (in seconds) such that the Hann main-lobe width in Hertz does not exceed $5$ Hz. Then, compute the corresponding minimal integer window length $L_{\\min}$ (in samples) at $f_{s} = 2000$ Hz. Report only the integer $L_{\\min}$ in samples as your final answer. No rounding by significant figures is required beyond taking the minimal integer number of samples.",
            "solution": "The problem is to determine the minimum window length in samples, $L_{\\min}$, for a Short-Time Fourier Transform (STFT) analysis that provides a specified frequency resolution. The analysis uses a Hann window.\n\nFirst, we must establish the relationship between the different domains of frequency. The continuous-time (analog) frequency $f$, measured in Hertz (Hz), is related to the discrete-time (digital) angular frequency $\\omega$, measured in radians per sample, through the sampling rate $f_s$ (in Hz) or, equivalently, the sampling period $T_s = 1/f_s$ (in seconds). The relationship is given by:\n$$ \\omega = 2\\pi f T_s = \\frac{2\\pi f}{f_s} $$\nThis equation defines the mapping from the analog frequency axis to the digital frequency axis. Consequently, a frequency interval $\\Delta f$ in the analog domain corresponds to a digital angular frequency interval $\\Delta \\omega$ in the digital domain. By differentiating the above expression, or by considering the interval between two frequencies, we find the conversion for frequency widths:\n$$ \\Delta \\omega = \\frac{2\\pi \\Delta f}{f_s} $$\nRearranging this equation allows us to convert a width in the digital angular frequency domain ($\\Delta \\omega$) to a width in the analog frequency domain ($\\Delta f$):\n$$ \\Delta f = \\frac{f_s}{2\\pi} \\Delta \\omega $$\nThe problem provides a well-known approximation for the main-lobe width of a Hann window of length $L$ samples. This width, measured between the first nulls (zeros) of its Fourier transform in the digital angular frequency domain, is:\n$$ \\Delta \\omega_{\\mathrm{ML}} \\approx \\frac{8\\pi}{L} $$\nTo find the main-lobe width in Hertz, $\\Delta f_{\\mathrm{ML}}$, we substitute this expression into our conversion formula:\n$$ \\Delta f_{\\mathrm{ML}} = \\frac{f_s}{2\\pi} \\Delta \\omega_{\\mathrm{ML}} \\approx \\frac{f_s}{2\\pi} \\left(\\frac{8\\pi}{L}\\right) = \\frac{4f_s}{L} $$\nThe problem requires that we can resolve spectral components separated by $5$ Hz. A common criterion for resolving two frequencies is that the main-lobe width of the spectral analysis window must be less than or equal to the frequency separation of interest. This ensures that the peak of one component does not fall within the main lobe of the other, preventing them from being smeared into a single peak. Therefore, we must satisfy the condition:\n$$ \\Delta f_{\\mathrm{ML}} \\le 5 \\, \\text{Hz} $$\nSubstituting our derived expression for $\\Delta f_{\\mathrm{ML}}$ gives the inequality:\n$$ \\frac{4f_s}{L} \\le 5 $$\nThe problem asks for the minimum window duration $T_{\\min}$ as part of the derivation. The duration of the window in seconds, $T$, is related to its length in samples, $L$, by $T = L T_s = L/f_s$. We can rewrite the inequality in terms of $T$:\n$$ \\frac{4}{L/f_s} \\le 5 \\implies \\frac{4}{T} \\le 5 $$\nSolving for $T$, we get:\n$$ T \\ge \\frac{4}{5} \\, \\text{s} = 0.8 \\, \\text{s} $$\nThus, the minimum required window duration is $T_{\\min} = 0.8$ seconds.\n\nThe primary goal is to find the minimum integer window length $L_{\\min}$. We return to the inequality involving $L$:\n$$ \\frac{4f_s}{L} \\le 5 $$\nWe solve for $L$:\n$$ L \\ge \\frac{4f_s}{5} $$\nNow, we substitute the given sampling rate, $f_s = 2000$ Hz:\n$$ L \\ge \\frac{4 \\times 2000}{5} = \\frac{8000}{5} = 1600 $$\nThe window length $L$ must be an integer number of samples. The minimum integer value of $L$ that satisfies this condition is $1600$. Therefore, the minimal integer window length is:\n$$ L_{\\min} = 1600 $$",
            "answer": "$$\\boxed{1600}$$"
        },
        {
            "introduction": "Once an appropriate window length is chosen, the window's *shape* becomes the next critical parameter, as it dictates how spectral energy is distributed. This hands-on coding exercise  allows you to directly compare the performance of a simple rectangular window versus a tapered Hann window. You will numerically quantify the phenomenon of spectral leakage and understand why the choice of window is crucial for accurately representing narrowband neural rhythms that do not align perfectly with DFT frequency bins.",
            "id": "4194014",
            "problem": "Consider the analysis of narrowband neural rhythms in a spectrogram computed via the Short-Time Fourier Transform (STFT), where each time slice is obtained by windowing a segment of a discrete-time signal and computing its Discrete Fourier Transform (DFT). Let the discrete-time signal be a single real sinusoid of amplitude $A$, frequency $f_0$ in Hertz, and sampling frequency $f_s$ in Hertz, given by $x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$ for $n \\in \\{0,1,\\dots,N-1\\}$, where $N$ is the window length in samples. A window $w[n]$ is applied to form $x_w[n] = x[n]\\,w[n]$. The $N$-point DFT of $x_w[n]$ is defined by\n$$\nX[k] = \\sum_{n=0}^{N-1} x_w[n] \\, e^{-\\mathrm{j} 2\\pi \\frac{k}{N} n}, \\quad k \\in \\{0,1,\\dots,N-1\\}.\n$$\nFor a given $f_0$ that is not exactly bin-centered, define the nearest DFT bin index $k^\\star = \\operatorname{round}\\!\\left(\\frac{f_0 N}{f_s}\\right)$, and its two adjacent bins $k^\\star - 1$ and $k^\\star + 1$. Define the windowed spectral leakage into adjacent bins as the ratio\n$$\nL(w) = \\frac{|X[k^\\star - 1]|^2 + |X[k^\\star + 1]|^2}{|X[k^\\star - 1]|^2 + |X[k^\\star]|^2 + |X[k^\\star + 1]|^2},\n$$\nwhich is unitless and lies in $[0,1]$. Two windows are to be compared:\n- Rectangular window: $w_{\\mathrm{rect}}[n] = 1$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n- Hann window: $w_{\\mathrm{hann}}[n] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$ for $n \\in \\{0,1,\\dots,N-1\\}$.\n\nStarting only from the definitions above and the fundamental properties that time-domain multiplication corresponds to frequency-domain convolution, design a program that computes $L(w_{\\mathrm{rect}})$ and $L(w_{\\mathrm{hann}})$ for each of the following test cases. All angles are in radians, and all frequencies are in Hertz. Use $A = 1$. Ensure that $k^\\star - 1 \\ge 0$ and $k^\\star + 1 \\le N-1$ hold for each test, which is true for the parameters below.\n\nTest suite:\n- Case $1$ (general off-bin case): $f_s = 1000$, $N = 256$, $f_0 = 123.45$.\n- Case $2$ (near bin-centered small detuning): $f_s = 1000$, $N = 512$, define $k_0 = 40$ and $\\delta = 0.01$, and set $f_0 = (k_0 + \\delta)\\,\\frac{f_s}{N}$.\n- Case $3$ (short window edge case): $f_s = 1000$, $N = 64$, set $f_0 = (12 + 0.37)\\,\\frac{f_s}{N}$.\n- Case $4$ (low-frequency narrowband rhythm typical of electroencephalography (EEG)): $f_s = 250$, $N = 250$, $f_0 = 10.4$.\n\nYour program must:\n- Implement the definitions above to compute $L(w_{\\mathrm{rect}})$ and $L(w_{\\mathrm{hann}})$ for each case without using any shortcut formulas beyond the DFT and window definitions.\n- Produce a single line of output containing a flat list of eight decimal values rounded to six digits after the decimal point, in the exact order\n[$L_{\\mathrm{rect},1}, L_{\\mathrm{hann},1}, L_{\\mathrm{rect},2}, L_{\\mathrm{hann},2}, L_{\\mathrm{rect},3}, L_{\\mathrm{hann},3}, L_{\\mathrm{rect},4}, L_{\\mathrm{hann},4}$],\nwhere the subscript denotes the case index. The output is unitless.\nAdditionally, use your reasoning in the solution to argue, based on the computed values and first principles, which window is justified for analyzing narrowband rhythms in spectrograms when the true oscillation frequency is not bin-centered.",
            "solution": "The central problem is to quantify and compare the spectral leakage of a pure sinusoidal signal when analyzed using a Short-Time Fourier Transform (STFT) with two different window functions: the rectangular window and the Hann window. Spectral leakage is a fundamental artifact in Fourier analysis of finite-duration signals, and its management is critical in applications like neuroscience, where accurately estimating the power of specific frequency bands (e.g., neural rhythms) is paramount.\n\nThe analysis begins with the discrete-time signal, a real-valued sinusoid of amplitude $A$, frequency $f_0$, and sampling frequency $f_s$, given by the formula:\n$$x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$$\nUsing Euler's formula, we can express the cosine as a sum of two complex exponentials:\n$$x[n] = \\frac{A}{2} \\left( e^{\\mathrm{j} 2\\pi \\frac{f_0}{f_s} n} + e^{-\\mathrm{j} 2\\pi \\frac{f_0}{f_s} n} \\right)$$\nThe Fourier transform of an infinite-duration sinusoid consists of two infinitesimally narrow delta functions in the frequency domain, located at frequencies $+f_0$ and $-f_0$. However, in practice, we can only analyze a finite segment of the signal. This is achieved by multiplying the signal $x[n]$ by a finite-length window function $w[n]$ of length $N$. The resulting windowed signal is $x_w[n] = x[n]w[n]$.\n\nA fundamental property of the Fourier transform, the convolution theorem, states that multiplication in the time domain corresponds to convolution in the frequency domain. Therefore, the spectrum of the windowed signal, $X_w(f)$, is the convolution of the spectrum of the original signal, $X(f)$, and the spectrum of the window function, $W(f)$.\n$$X_w(f) = X(f) * W(f)$$\nConvolving the pair of delta functions from the sinusoid's spectrum with the window's spectrum $W(f)$ replaces each delta function with a scaled and shifted version of $W(f)$. The result is a spectrum containing two copies of the window's spectral shape, centered at $+f_0$ and $-f_0$. This \"smearing\" of the signal's concentrated energy across a range of frequencies is the essence of spectral leakage.\n\nThe Discrete Fourier Transform (DFT) computes samples of this continuous spectrum at discrete frequency bins $f_k = k \\frac{f_s}{N}$ for $k \\in \\{0, 1, \\dots, N-1\\}$. If the signal frequency $f_0$ happens to coincide perfectly with a DFT bin frequency (i.e., $\\frac{f_0 N}{f_s}$ is an integer), and the window is chosen carefully, the leakage might be minimal. However, in typical scenarios, especially with biological signals, $f_0$ is arbitrary and falls between two DFT bins. In this case, the peak of the window's spectral shape lies between two sample points, and its energy \"leaks\" into all nearby frequency bins. The magnitude of this leakage is determined by the shape of $W(f)$.\n\nThe two windows under consideration have markedly different spectral properties:\n$1$. **Rectangular window**, $w_{\\mathrm{rect}}[n] = 1$: Its spectrum is characterized by a narrow main lobe but very high side lobes that decay slowly (as $1/f$). The narrow main lobe provides good frequency resolution, but the high side lobes cause significant spectral leakage when the signal is off-bin.\n$2$. **Hann window**, $w_{\\mathrm{hann}}[n] = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$: This window tapers smoothly to zero at its edges. Its spectrum has a wider main lobe (about twice as wide as the rectangular window's) but substantially lower side lobes that decay much more rapidly. The wider main lobe implies slightly poorer frequency resolution, but the low side lobes result in much-reduced spectral leakage.\n\nThe specified leakage ratio, $L(w)$, measures the proportion of power in the two bins adjacent to the peak bin relative to the total power in all three bins.\n$$\nL(w) = \\frac{|X[k^\\star - 1]|^2 + |X[k^\\star + 1]|^2}{|X[k^\\star - 1]|^2 + |X[k^\\star]|^2 + |X[k^\\star + 1]|^2}\n$$\nHere, $k^\\star = \\operatorname{round}\\!\\left(\\frac{f_0 N}{f_s}\\right)$ is the index of the DFT bin closest to the true signal frequency. A smaller value of $L(w)$ indicates better containment of spectral energy and thus less leakage.\n\nThe computational procedure to determine $L(w)$ for each test case is as follows, adhering strictly to the provided definitions:\nFirst, for each case, we define the parameters $f_s$, $N$, and $f_0$. We set the amplitude $A=1$.\nSecond, we generate the discrete time indices $n = \\{0, 1, \\dots, N-1\\}$.\nThird, we construct the signal $x[n] = \\cos\\left(2\\pi \\frac{f_0}{f_s} n\\right)$.\nFourth, we define the two window functions, $w_{\\mathrm{rect}}[n]$ and $w_{\\mathrm{hann}}[n]$, over the same time indices.\nFifth, we create the two windowed signals, $x_{w,\\mathrm{rect}}[n] = x[n]w_{\\mathrm{rect}}[n]$ and $x_{w,\\mathrm{hann}}[n] = x[n]w_{\\mathrm{hann}}[n]$.\nSixth, we compute the $N$-point DFT for each windowed signal using the formula $X[k] = \\sum_{n=0}^{N-1} x_w[n] \\, e^{-\\mathrm{j} 2\\pi \\frac{k}{N} n}$, which is implemented efficiently by the Fast Fourier Transform (FFT) algorithm.\nSeventh, we calculate the nearest bin index $k^\\star$ and identify the DFT coefficients at $k^\\star-1$, $k^\\star$, and $k^\\star+1$.\nFinally, we compute the leakage ratio $L(w)$ for both the rectangular and Hann windows using the squared magnitudes of these coefficients.\n\nBy executing this procedure for the given test cases, we numerically demonstrate the theoretical properties of these windows. The computed values of $L(w_{\\mathrm{rect}})$ are consistently and significantly higher than those of $L(w_{\\mathrm{hann}})$. This shows that the power from a single, narrowband rhythm leaks substantially into adjacent frequency channels when using a rectangular window, potentially leading to misinterpretation of the spectrogram (e.g., seeing activity in multiple frequency bands when only one is present). The Hann window, by concentrating the leaked power much more effectively, provides a more faithful representation of the underlying spectral content. For analyzing narrowband rhythms in neuroscience, where signal frequencies are never perfectly stationary or bin-centered, the trade-off of slightly lower frequency resolution for a massive reduction in spectral leakage is highly advantageous. Therefore, the Hann window (and other similar tapered windows) is unequivocally justified and preferred for such applications.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the spectral leakage ratio for rectangular and Hann windows\n    for a set of test cases involving a pure sinusoidal signal.\n    \"\"\"\n\n    def calculate_leakage(f0, fs, N):\n        \"\"\"\n        Calculates the leakage ratio L(w) for rectangular and Hann windows.\n\n        Args:\n            f0 (float): Signal frequency in Hz.\n            fs (float): Sampling frequency in Hz.\n            N (int): Window length in samples.\n\n        Returns:\n            tuple: A tuple containing (L_rect, L_hann).\n        \"\"\"\n        A = 1.0\n        n = np.arange(N)\n\n        # Generate the sinusoidal signal\n        x_n = A * np.cos(2 * np.pi * f0 / fs * n)\n\n        # 1. Rectangular window analysis\n        w_rect = np.ones(N)\n        xw_rect = x_n * w_rect\n        X_rect = np.fft.fft(xw_rect, n=N)\n\n        # 2. Hann window analysis\n        # Using the definition from the problem: w[n] = 0.5 - 0.5*cos(2*pi*n/(N-1))\n        w_hann = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        xw_hann = x_n * w_hann\n        X_hann = np.fft.fft(xw_hann, n=N)\n\n        # Find the nearest DFT bin index\n        k_star = int(np.round(f0 * N / fs))\n        \n        # Define adjacent bins\n        k_minus_1 = k_star - 1\n        k_plus_1 = k_star + 1\n        \n        # Ensure indices are within bounds (guaranteed by problem statement but good practice)\n        if not (k_minus_1 >= 0 and k_plus_1  N):\n            raise ValueError(\"k* indices are out of bounds.\")\n\n        def compute_L(X_k):\n            \"\"\"Computes the leakage ratio from DFT coefficients.\"\"\"\n            # Get squared magnitudes at the three bins of interest\n            mag_sq_km1 = np.abs(X_k[k_minus_1])**2\n            mag_sq_k = np.abs(X_k[k_star])**2\n            mag_sq_kp1 = np.abs(X_k[k_plus_1])**2\n            \n            # Calculate the leakage ratio L(w)\n            numerator = mag_sq_km1 + mag_sq_kp1\n            denominator = mag_sq_km1 + mag_sq_k + mag_sq_kp1\n            \n            # Handle potential division by zero, though unlikely in this problem\n            if denominator == 0:\n                return 0.0\n                \n            return numerator / denominator\n\n        L_rect = compute_L(X_rect)\n        L_hann = compute_L(X_hann)\n\n        return L_rect, L_hann\n\n    # Test suite from the problem statement\n    test_cases = [\n        # Case 1: general off-bin case\n        {'fs': 1000, 'N': 256, 'f0': 123.45},\n        # Case 2: near bin-centered small detuning\n        {'fs': 1000, 'N': 512, 'f0': (40 + 0.01) * 1000 / 512},\n        # Case 3: short window edge case\n        {'fs': 1000, 'N': 64, 'f0': (12 + 0.37) * 1000 / 64},\n        # Case 4: low-frequency narrowband rhythm\n        {'fs': 250, 'N': 250, 'f0': 10.4},\n    ]\n\n    results = []\n    for case in test_cases:\n        L_rect, L_hann = calculate_leakage(case['f0'], case['fs'], case['N'])\n        results.append(round(L_rect, 6))\n        results.append(round(L_hann, 6))\n\n    # Format the final output string as specified\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond generating a spectrogram, the ultimate goal in many neuroscience experiments is to perform robust statistical inference. This comprehensive exercise  simulates a realistic research scenario, tasking you with implementing a full pipeline to detect stimulus-induced changes in neural power. You will apply the powerful cluster-based permutation test to solve the multiple comparisons problem, a critical skill for drawing valid conclusions from complex time-frequency data.",
            "id": "4194056",
            "problem": "You are given a simulated multitrial electrophysiology dataset representing time series $\\{x_i[t]\\}_{i=1}^{N}$, each $x_i[t]$ measured in volts over time $t$ in seconds, where $N$ denotes the number of trials. The sampling rate is $f_s$ in Hertz (Hz). A stimulus occurs at time $t_0$ (in seconds), and some trials include an induced oscillation in the gamma band (defined as $30$–$80$ Hz). Your task is to compute a time-frequency spectrogram, construct a trial-wise baseline-corrected gamma power difference, and perform a cluster-based permutation test to detect increases in gamma power after the stimulus. You must then report significant time-frequency clusters with family-wise error corrected $p$-values.\n\nStart from the Short-Time Fourier Transform (STFT) definition. For a discrete-time signal $x[t]$ sampled at $f_s$ Hz and a window $w[n]$ of length $L$, the STFT at time frame index $m$ and frequency bin index $k$ is\n$$\nX[m,k] = \\sum_{n=0}^{L-1} x[n + mR] \\, w[n] \\, e^{-j 2 \\pi k n / L},\n$$\nwhere $R$ is the hop size in samples and $j$ is the imaginary unit. The spectrogram power is $P[m,k] = |X[m,k]|^2$. Let $f[k]$ denote the frequency (in Hz) for bin $k$ and $t[m]$ denote the center time (in seconds) for frame $m$.\n\nDefine a post-stimulus time window $W_{\\text{post}} = [t_0 + \\Delta_1, t_0 + \\Delta_2]$ and a baseline window $W_{\\text{base}} = [t_0 - \\Delta_2, t_0 - \\Delta_1]$ with $\\Delta_1$ and $\\Delta_2$ specified in seconds. Restrict analysis to the gamma band, i.e., frequencies $f[k] \\in [30,80]$ Hz. For each trial $i$, each gamma frequency bin $k$, and each post-stimulus time frame $m$ with $t[m] \\in W_{\\text{post}}$, compute a baseline-corrected power difference\n$$\nD_i[k,m] = P_i[k,m] - \\frac{1}{|M_{\\text{base}}(k)|} \\sum_{m' \\in M_{\\text{base}}(k)} P_i[k,m'],\n$$\nwhere $P_i$ is the spectrogram power for trial $i$ and $M_{\\text{base}}(k)$ is the index set of baseline frames with $t[m'] \\in W_{\\text{base}}$. This yields a time-frequency grid of differences $\\{D_i[k,m]\\}$ across trials.\n\nFormulate the one-sample null hypothesis that there is no increase in gamma power after the stimulus, i.e., for each time-frequency bin $(k,m)$,\n$$\nH_0: \\mu_{D}[k,m] = 0,\n$$\nwhere $\\mu_{D}[k,m]$ is the across-trial mean of $D_i[k,m]$. Compute the Student’s $t$-statistic at each $(k,m)$ across trials using\n$$\nt[k,m] = \\frac{\\overline{D}[k,m]}{s_D[k,m]/\\sqrt{N}},\n$$\nwhere $\\overline{D}[k,m]$ is the sample mean and $s_D[k,m]$ is the sample standard deviation across trials, with $N$ trials.\n\nApply a cluster-forming threshold using the one-sided critical value for the Student’s $t$-distribution at level $\\alpha_{\\text{cf}}$ with $N-1$ degrees of freedom, keeping only bins where $t[k,m]$ exceeds this threshold. Define clusters as sets of contiguous bins in the time-frequency grid using $4$-connectivity (adjacent in time or frequency). For each cluster $C$, define its mass as the sum of $t$-statistics:\n$$\nS(C) = \\sum_{(k,m) \\in C} t[k,m].\n$$\n\nPerform a cluster-based permutation test using sign-flips across trials (valid under the symmetric null for paired differences). For each permutation $p = 1, \\dots, P$, draw independent random signs $\\sigma_i^{(p)} \\in \\{-1, +1\\}$ for trials $i = 1, \\dots, N$, form $\\tilde{D}_i^{(p)}[k,m] = \\sigma_i^{(p)} \\cdot D_i[k,m]$, recompute the $t$-map and cluster masses, and record the maximum cluster mass\n$$\nM^{(p)} = \\max_{C^{(p)}} S\\left(C^{(p)}\\right),\n$$\nwith $M^{(p)} = 0$ if no cluster forms under permutation $p$. For each observed cluster $C$, compute a family-wise error corrected $p$-value using the maximum-statistic distribution,\n$$\np_{\\text{corr}}(C) = \\frac{1 + \\left|\\left\\{p : M^{(p)} \\ge S(C)\\right\\}\\right|}{P + 1}.\n$$\nDeclare $C$ significant if $p_{\\text{corr}}(C)  \\alpha$ for a specified $\\alpha$.\n\nImplement the above as a complete, runnable program that simulates trials with and without a stimulus-induced gamma burst. Use the following fixed analysis parameters: sampling rate $f_s = 500$ Hz, total duration $T = 2.0$ seconds, stimulus time $t_0 = 1.0$ seconds, STFT window length $L = 256$ samples, hop size $R = 64$ samples, Hann window $w[n]$. Use $W_{\\text{base}} = [0.6, 0.9]$ seconds and $W_{\\text{post}} = [1.1, 1.5]$ seconds. The gamma burst, when present, is a sinusoid at frequency $f_{\\gamma} = 40$ Hz whose amplitude is tapered with a Hanning envelope over $[1.15, 1.45]$ seconds.\n\nYour program should implement the test suite with the following parameter sets, each specified as a tuple $(N, A_{\\gamma}, P, \\alpha_{\\text{cf}}, \\alpha, \\text{seed})$:\n- Test Case $1$: $(60, 2.0, 500, 0.05, 0.05, 42)$.\n- Test Case $2$: $(60, 0.0, 500, 0.05, 0.05, 43)$.\n- Test Case $3$: $(20, 0.8, 300, 0.05, 0.05, 44)$.\n\nHere, $N$ is the number of trials, $A_{\\gamma}$ is the gamma burst amplitude (unitless relative to noise, where $A_{\\gamma} = 0.0$ means no gamma burst), $P$ is the number of permutations, $\\alpha_{\\text{cf}}$ is the cluster-forming threshold level, $\\alpha$ is the family-wise error level, and $\\text{seed}$ is the random seed controlling reproducibility.\n\nFor each test case, compute the number of significant clusters within the gamma band and the smallest corrected $p$-value across all observed clusters (report $1.0$ if no cluster is observed). Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case’s result is reported as a two-element list [$n_{\\text{sig}}$, $p_{\\text{min}}$]. For example, the output format should be like $[[n_{\\text{sig}}^{(1)}, p_{\\text{min}}^{(1)}],[n_{\\text{sig}}^{(2)}, p_{\\text{min}}^{(2)}],[n_{\\text{sig}}^{(3)}, p_{\\text{min}}^{(3)}]]$. No physical unit is required in the output, since counts and $p$-values are unitless. Angles, if any were to be used, must be in radians, but no angle quantities appear in this task.",
            "solution": "The user has provided a problem that requires the implementation of a complete pipeline for analyzing simulated electrophysiology data, culminating in a cluster-based permutation test to identify significant time-frequency patterns. The problem is scientifically sound, well-posed, and all necessary parameters are specified. I will proceed with a full solution.\n\nThe solution is structured around fundamental principles of time-frequency analysis and non-parametric statistics commonly applied in neuroscience.\n\n1.  **Principle 1: Data Simulation for Method Validation**\n    To test and validate the analysis pipeline, we first synthesize a dataset that mimics key features of real neural data. Each trial consists of a signal plus noise.\n    -   **Noise**: The background neural activity is modeled as Gaussian white noise, $\\mathcal{N}(0,1)$. This represents the stochastic, non-stimulus-related fluctuations in the recorded signal.\n    -   **Signal**: The stimulus-induced effect is a gamma-band oscillation. This is represented by a sinusoid at frequency $f_{\\gamma} = 40$ Hz. The sinusoid's amplitude is modulated by a Hanning window, $A_{\\gamma} w_{\\text{Hanning}}(t)$, to create a transient burst that is localized in a specific post-stimulus time interval, $[1.15, 1.45]$ seconds. The parameter $A_{\\gamma}$ controls the signal-to-noise ratio. The signal for trial $i$ is $x_i[t] = \\text{signal}[t] + \\text{noise}_i[t]$.\n\n2.  **Principle 2: Time-Frequency Decomposition via STFT**\n    Neural signals are non-stationary, meaning their frequency content changes over time. The Short-Time Fourier Transform (STFT) is a standard method to analyze such signals. It works by dividing the signal into short, overlapping segments, applying a window function, and computing the Fourier Transform for each segment.\n    -   **Spectrogram**: For a signal $x[t]$, the STFT, $X[m,k]$, gives a complex value for each time frame $m$ and frequency bin $k$. The power spectrogram, $P[m,k] = |X[m,k]|^2$, quantifies the signal's energy at that specific time-frequency coordinate.\n    -   **Implementation**: We use a Hann window of length $L=256$ samples and a hop size of $R=64$ samples. This choice balances temporal resolution (determined by $R$) and frequency resolution (determined by $L$).\n\n3.  **Principle 3: Baseline Correction to Isolate Stimulus Effects**\n    To isolate power changes induced by the stimulus, we compare the power in a post-stimulus window to the power in a pre-stimulus baseline window.\n    -   **Difference Metric**: For each trial $i$ and frequency bin $k$, we compute the average power within the baseline window $W_{\\text{base}} = [0.6, 0.9]$ s. Let this be $\\bar{P}_{i, \\text{base}}[k]$. We then compute the difference $D_i[k,m] = P_i[k,m] - \\bar{P}_{i, \\text{base}}[k]$ for each time frame $m$ in the post-stimulus window $W_{\\text{post}} = [1.1, 1.5]$ s. This subtractive correction helps to account for trial-to-trial variability and frequency-specific power differences that are not related to the stimulus.\n\n4.  **Principle 4: Point-wise Hypothesis Testing**\n    To assess whether the observed power increase is statistically meaningful, we formulate a hypothesis test at each time-frequency point $(k,m)$ in the analysis window.\n    -   **Null Hypothesis**: The null hypothesis, $H_0: \\mu_{D}[k,m] = 0$, states that there is no average change in power from baseline to the post-stimulus period.\n    -   **Test Statistic**: We use a one-sample Student's $t$-statistic to test this hypothesis, computed across the $N$ trials:\n        $$\n        t[k,m] = \\frac{\\overline{D}[k,m]}{s_D[k,m]/\\sqrt{N}}\n        $$\n        where $\\overline{D}[k,m]$ and $s_D[k,m]$ are the sample mean and standard deviation of $D_i[k,m]$ across trials. A large positive $t$-value suggests a significant increase in power.\n\n5.  **Principle 5: Cluster-Based Permutation Test for Multiple Comparisons Correction**\n    Performing thousands of $t$-tests (one for each time-frequency bin) creates a severe multiple comparisons problem, leading to a high rate of false positives if uncorrected. The cluster-based permutation test is a powerful method to address this by incorporating the spatial structure (i.e., contiguity in time and frequency) of the data.\n    -   **Step 5a: Cluster Formation**: We first identify candidate clusters. The observed $t$-map, $\\{t[k,m]\\}$, is thresholded using a critical value from the Student’s $t$-distribution (e.g., at $\\alpha_{\\text{cf}} = 0.05$). Spatially adjacent points that exceed this threshold are grouped into clusters. The \"mass\" of a cluster $C$ is defined as the sum of the $t$-values within it, $S(C) = \\sum_{(k,m) \\in C} t[k,m]$.\n    -   **Step 5b: Generation of a Null Distribution via Permutations**: To determine if the observed cluster masses are larger than what would be expected by chance, we generate a null distribution. This is done by repeatedly permuting the data. Under the null hypothesis, the sign of the difference value $D_i[k,m]$ for any given trial is arbitrary. We can therefore create a surrogate dataset by randomly flipping the signs of the entire data for a random subset of trials: $\\tilde{D}_i[k,m] = \\sigma_i \\cdot D_i[k,m]$, where $\\sigma_i \\in \\{-1, +1\\}$.\n    -   **Step 5c: The Maximum Statistic**: For each of the $P$ permutations, we re-compute the entire $t$-map, form clusters, and find the maximum cluster mass, $M^{(p)} = \\max_{C^{(p)}} S(C^{(p)})$. If no clusters form, $M^{(p)}=0$. The distribution of these maximum statistics, $\\{M^{(p)}\\}_{p=1}^P$, serves as our empirical null distribution. Using the maximum statistic automatically corrects for searching across all possible clusters.\n    -   **Step 5d: Family-Wise Error (FWE) Corrected P-value**: The significance of an original, observed cluster $C$ is assessed by comparing its mass $S(C)$ to the null distribution of maximum masses. The FWE-corrected $p$-value is:\n        $$\n        p_{\\text{corr}}(C) = \\frac{1 + \\left|\\left\\{p : M^{(p)} \\ge S(C)\\right\\}\\right|}{P + 1}\n        $$\n    -   **Inference**: An observed cluster is declared statistically significant if its corrected $p$-value is below the desired family-wise error rate, $\\alpha$.\n\nThis comprehensive procedure, from data simulation to statistical inference, is implemented in the following Python code, adhering to the specified parameters for each test case.",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\nfrom scipy import stats\n\ndef find_clusters(grid):\n    \"\"\"\n    Finds 4-connectivity clusters in a 2D boolean grid using BFS.\n\n    Args:\n        grid (np.ndarray): A 2D boolean numpy array.\n\n    Returns:\n        list: A list of clusters, where each cluster is a list of (row, col) tuples.\n    \"\"\"\n    rows, cols = grid.shape\n    visited = np.zeros_like(grid, dtype=bool)\n    clusters = []\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r, c] and not visited[r, c]:\n                # Start of a new cluster\n                cluster = []\n                q = [(r, c)]\n                visited[r, c] = True\n                \n                head = 0\n                while head  len(q):\n                    curr_r, curr_c = q[head]\n                    head += 1\n                    cluster.append((curr_r, curr_c))\n                    \n                    # Check 4 neighbors (up, down, left, right)\n                    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        next_r, next_c = curr_r + dr, curr_c + dc\n                        \n                        if 0 = next_r  rows and 0 = next_c  cols:\n                            if grid[next_r, next_c] and not visited[next_r, next_c]:\n                                visited[next_r, next_c] = True\n                                q.append((next_r, next_c))\n                clusters.append(cluster)\n    return clusters\n\ndef run_analysis(N, A_gamma, P, alpha_cf, alpha, seed):\n    \"\"\"\n    Runs the full simulation and cluster-based permutation test for one test case.\n    \"\"\"\n    # 1. Set up RNG and constants\n    rng = np.random.default_rng(seed)\n    fs = 500\n    T = 2.0\n    t0 = 1.0\n    L = 256\n    R = 64\n    noverlap = L - R\n    \n    w_base = [0.6, 0.9]\n    w_post = [1.1, 1.5]\n    f_gamma_band = [30, 80]\n    f_gamma_burst = 40\n    t_burst_window = [1.15, 1.45]\n\n    # 2. Simulate data\n    t_vec = np.arange(0, T, 1 / fs)\n    n_samples = len(t_vec)\n    data = rng.standard_normal((N, n_samples))\n\n    if A_gamma > 0:\n        gamma_signal = np.sin(2 * np.pi * f_gamma_burst * t_vec)\n        burst_indices = (t_vec >= t_burst_window[0])  (t_vec = t_burst_window[1])\n        hanning_taper = np.zeros(n_samples)\n        hanning_taper[burst_indices] = np.hanning(np.sum(burst_indices))\n        gamma_burst = A_gamma * gamma_signal * hanning_taper\n        data += gamma_burst[np.newaxis, :]\n\n    # 3. Compute STFT and power for all trials\n    f_stft, t_stft, Zxx = signal.stft(data, fs=fs, window='hann', nperseg=L, noverlap=noverlap)\n    power_spectrograms = np.abs(Zxx)**2\n\n    # 4. Select frequency and time windows\n    gamma_freq_mask = (f_stft >= f_gamma_band[0])  (f_stft = f_gamma_band[1])\n    base_time_mask = (t_stft >= w_base[0])  (t_stft = w_base[1])\n    post_time_mask = (t_stft >= w_post[0])  (t_stft = w_post[1])\n    \n    # 5. Baseline Correction\n    power_gamma = power_spectrograms[:, gamma_freq_mask, :]\n    baseline_mean_power = np.mean(power_gamma[:, :, base_time_mask], axis=2, keepdims=True)\n    post_stim_power = power_gamma[:, :, post_time_mask]\n    \n    D = post_stim_power - baseline_mean_power\n\n    # 6. Compute observed t-statistics and find clusters\n    mean_D = np.mean(D, axis=0)\n    std_D = np.std(D, axis=0, ddof=1)\n    \n    # Handle division by zero\n    t_obs = np.zeros_like(mean_D)\n    non_zero_std = std_D > np.finfo(float).eps\n    t_obs[non_zero_std] = mean_D[non_zero_std] / (std_D[non_zero_std] / np.sqrt(N))\n    \n    t_crit = stats.t.ppf(1 - alpha_cf, df=N - 1)\n    t_map_thresh = t_obs > t_crit\n    \n    observed_clusters = find_clusters(t_map_thresh)\n    observed_masses = [np.sum(t_obs[tuple(zip(*c))]) for c in observed_clusters]\n\n    # 7. Permutation Test\n    max_perm_masses = np.zeros(P)\n    d_shape_for_perm = D.shape\n    \n    for i in range(P):\n        signs = rng.choice([-1, 1], size=(N, 1, 1))\n        D_perm = D * signs\n        \n        mean_D_perm = np.mean(D_perm, axis=0)\n        std_D_perm = np.std(D_perm, axis=0, ddof=1)\n        \n        t_perm = np.zeros_like(mean_D_perm)\n        non_zero_std_perm = std_D_perm > np.finfo(float).eps\n        t_perm[non_zero_std_perm] = mean_D_perm[non_zero_std_perm] / (std_D_perm[non_zero_std_perm] / np.sqrt(N))\n        \n        t_perm_thresh = t_perm > t_crit\n        perm_clusters = find_clusters(t_perm_thresh)\n        \n        if perm_clusters:\n            perm_masses = [np.sum(t_perm[tuple(zip(*c))]) for c in perm_clusters]\n            max_perm_masses[i] = np.max(perm_masses)\n\n    # 8. Compute FWE-corrected p-values\n    if not observed_clusters:\n        return [0, 1.0]\n\n    p_values = []\n    for mass in observed_masses:\n        p_val = (1 + np.sum(max_perm_masses >= mass)) / (P + 1)\n        p_values.append(p_val)\n    \n    p_values = np.array(p_values)\n    n_sig = np.sum(p_values  alpha)\n    p_min = np.min(p_values)\n\n    return [int(n_sig), p_min]\n\ndef solve():\n    # Test cases: (N, A_gamma, P, alpha_cf, alpha, seed)\n    test_cases = [\n        (60, 2.0, 500, 0.05, 0.05, 42),\n        (60, 0.0, 500, 0.05, 0.05, 43),\n        (20, 0.8, 300, 0.05, 0.05, 44),\n    ]\n\n    results = []\n    for case in test_cases:\n        n_sig, p_min = run_analysis(*case)\n        results.append([n_sig, p_min])\n    \n    # Format the output string as per requirements\n    formatted_results = [f\"[{n},{p}]\" for n, p in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}