{
    "hands_on_practices": [
        {
            "introduction": "要真正理解希尔伯特变换，最好的方法是观察它如何作用于最简单的振荡信号：纯粹的正弦和余弦函数。这项练习将引导你从第一性原理出发，推导这些基本信号的希尔伯特变换，并构建相应的解析信号。通过这个过程，你将巩固信号与其正交分量之间的基础数学关系，并从理论上验证解析信号的关键特性——单边频谱，为后续更复杂的应用打下坚实的数学基础。",
            "id": "4199768",
            "problem": "在颅内电生理学和脑电图（EEG）中，窄带振荡通常在局部被近似为确定性正弦波，以便通过希尔伯特变换研究瞬时振幅和瞬时相位。考虑实值信号 $x(t) = \\cos(\\omega_{0} t)$，其中 $\\omega_{0} > 0$ 是一个以弧度/秒为单位的恒定角频率，$t$ 是以秒为单位的时间。一个实信号 $x(t)$ 的希尔伯特变换 $\\mathcal{H}\\{x\\}(t)$ 定义为与核 $h(t) = \\frac{1}{\\pi t}$ 的柯西主值卷积，即 $\\mathcal{H}\\{x\\}(t) = \\bigl(x * h\\bigr)(t)$，而相关的解析信号 $z(t)$ 是通过将 $x(t)$ 与其正交分量 $\\mathcal{H}\\{x\\}(t)$ 组合而成的。\n\n仅使用基本变换定义以及线性时不变系统和分布的性质，推导 $\\mathcal{H}\\{\\cos(\\omega_{0} t)\\}(t)$ 和相应的解析信号 $z_{\\cos}(t)$，并使用傅里叶变换严格验证 $z_{\\cos}(t)$ 具有单边谱（即没有负频率支撑）。然后将此推导推广到 $x(t) = \\sin(\\omega_{0} t)$，以获得 $\\mathcal{H}\\{\\sin(\\omega_{0} t)\\}(t)$ 和 $z_{\\sin}(t)$，并验证其同样的单边谱性质。\n\n最后，提供解析信号 $z_{\\cos}(t)$ 和 $z_{\\sin}(t)$ 关于 $\\omega_{0}$ 和 $t$ 的精确闭式表达式。角度必须以弧度为单位。最终表达式中不要求进行数值舍入，也不应出现单位。",
            "solution": "该问题是有效的，因为它在科学上基于信号处理理论，问题设定良好，定义和目标清晰，并且没有任何事实或逻辑上的不一致。我们将使用傅里叶变换的性质进行推导。\n\n希尔伯特变换 $\\mathcal{H}\\{x(t)\\}$ 由卷积 $x(t) * h(t)$ 定义，其中核为 $h(t) = \\frac{1}{\\pi t}$。根据卷积定理，此运算对应于频域中的乘法。我们将傅里叶变换及其逆变换定义为：\n$$\nX(\\omega) = \\mathcal{F}\\{x(t)\\} = \\int_{-\\infty}^{\\infty} x(t) e^{-i\\omega t} dt\n$$\n$$\nx(t) = \\mathcal{F}^{-1}\\{X(\\omega)\\} = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} X(\\omega) e^{i\\omega t} d\\omega\n$$\n核 $h(t)$ 的傅里叶变换是一个标准结果：\n$$\nH(\\omega) = \\mathcal{F}\\left\\{\\frac{1}{\\pi t}\\right\\}(\\omega) = -i \\cdot \\text{sgn}(\\omega)\n$$\n其中 $\\text{sgn}(\\omega)$ 是符号函数。因此，希尔伯特变换可以计算为：\n$$\n\\mathcal{H}\\{x\\}(t) = \\mathcal{F}^{-1}\\{ -i \\cdot \\text{sgn}(\\omega) \\cdot X(\\omega) \\}\n$$\n那么解析信号 $z(t)$ 是 $z(t) = x(t) + i\\mathcal{H}\\{x\\}(t)$。在频域中，其变换 $Z(\\omega)$ 为：\n$$\nZ(\\omega) = \\mathcal{F}\\{x(t) + i\\mathcal{H}\\{x\\}(t)\\} = X(\\omega) + i(-i \\cdot \\text{sgn}(\\omega) \\cdot X(\\omega)) = X(\\omega) + \\text{sgn}(\\omega)X(\\omega)\n$$\n这可以简化为：\n$$\nZ(\\omega) = (1 + \\text{sgn}(\\omega))X(\\omega) = \\begin{cases} 2X(\\omega), & \\omega > 0 \\\\ X(0), & \\omega = 0 \\\\ 0, & \\omega < 0 \\end{cases}\n$$\n这个关系内在地表明，对于任何没有直流分量（$X(0)=0$）的实信号 $x(t)$，其解析信号都具有单边谱。我们现在将对给定的正弦信号明确地验证这一点。\n\n**第1部分：对 $x(t) = \\cos(\\omega_{0} t)$ 的推导**\n\n首先，我们求 $x(t) = \\cos(\\omega_{0} t)$ 的傅里叶变换。使用欧拉恒等式 $\\cos(\\omega_{0} t) = \\frac{1}{2}(\\exp(i\\omega_{0} t) + \\exp(-i\\omega_{0} t))$ 和已知的变换 $\\mathcal{F}\\{\\exp(i\\omega_{c}t)\\} = 2\\pi\\delta(\\omega - \\omega_{c})$，我们得到：\n$$\nX_{\\cos}(\\omega) = \\mathcal{F}\\{\\cos(\\omega_{0} t)\\} = \\frac{1}{2} [2\\pi\\delta(\\omega - \\omega_{0}) + 2\\pi\\delta(\\omega + \\omega_{0})] = \\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\n现在，我们求希尔伯特变换后信号的傅里叶变换，记为 $Y_{\\cos}(\\omega)$：\n$$\nY_{\\cos}(\\omega) = H(\\omega)X_{\\cos}(\\omega) = -i \\cdot \\text{sgn}(\\omega) \\cdot \\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\n使用狄拉克δ分布的筛选性质 $\\phi(\\omega)\\delta(\\omega - a) = \\phi(a)\\delta(\\omega - a)$，并注意到 $\\omega_{0} > 0$：\n$$\nY_{\\cos}(\\omega) = -i\\pi[\\text{sgn}(\\omega_{0})\\delta(\\omega - \\omega_{0}) + \\text{sgn}(-\\omega_{0})\\delta(\\omega + \\omega_{0})]\n$$\n$$\nY_{\\cos}(\\omega) = -i\\pi[(1)\\delta(\\omega - \\omega_{0}) + (-1)\\delta(\\omega + \\omega_{0})] = -i\\pi[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\n为了在时域中找到希尔伯特变换，我们对 $Y_{\\cos}(\\omega)$ 进行傅里叶逆变换。认识到 $\\mathcal{F}\\{\\sin(\\omega_{0} t)\\} = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]$，我们可以写出：\n$$\nY_{\\cos}(\\omega) = -i\\pi[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] = \\mathcal{F}\\{\\sin(\\omega_{0} t)\\}\n$$\n因此，$\\cos(\\omega_{0} t)$ 的希尔伯特变换是：\n$$\n\\mathcal{H}\\{\\cos(\\omega_{0} t)\\}(t) = \\sin(\\omega_{0} t)\n$$\n相应的解析信号 $z_{\\cos}(t)$ 是：\n$$\nz_{\\cos}(t) = x(t) + i\\mathcal{H}\\{x(t)\\}(t) = \\cos(\\omega_{0} t) + i\\sin(\\omega_{0} t) = \\exp(i\\omega_{0} t)\n$$\n为了验证其单边谱，我们计算其傅里叶变换 $Z_{\\cos}(\\omega)$：\n$$\nZ_{\\cos}(\\omega) = \\mathcal{F}\\{\\exp(i\\omega_{0} t)\\} = 2\\pi\\delta(\\omega - \\omega_{0})\n$$\n因为 $\\omega_{0} > 0$，频谱 $Z_{\\cos}(\\omega)$ 仅在正频率 $\\omega = \\omega_{0}$ 处非零。它在负频率上没有支撑，这证实了它是一个单边谱。\n\n**第2部分：对 $x(t) = \\sin(\\omega_{0} t)$ 的推导**\n\n我们对 $x(t) = \\sin(\\omega_{0} t)$ 遵循相同的步骤。使用欧拉恒等式 $\\sin(\\omega_{0} t) = \\frac{1}{2i}(\\exp(i\\omega_{0} t) - \\exp(-i\\omega_{0} t))$，其傅里叶变换为：\n$$\nX_{\\sin}(\\omega) = \\mathcal{F}\\{\\sin(\\omega_{0} t)\\} = \\frac{1}{2i} [2\\pi\\delta(\\omega - \\omega_{0}) - 2\\pi\\delta(\\omega + \\omega_{0})] = \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\n其希尔伯特变换的傅里叶变换 $Y_{\\sin}(\\omega)$ 是：\n$$\nY_{\\sin}(\\omega) = H(\\omega)X_{\\sin}(\\omega) = (-i \\cdot \\text{sgn}(\\omega)) \\left( \\frac{\\pi}{i}[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})] \\right)\n$$\n$$\nY_{\\sin}(\\omega) = -\\pi \\cdot \\text{sgn}(\\omega)[\\delta(\\omega - \\omega_{0}) - \\delta(\\omega + \\omega_{0})]\n$$\n应用筛选性质并使用 $\\omega_{0} > 0$：\n$$\nY_{\\sin}(\\omega) = -\\pi[\\text{sgn}(\\omega_{0})\\delta(\\omega - \\omega_{0}) - \\text{sgn}(-\\omega_{0})\\delta(\\omega + \\omega_{0})]\n$$\n$$\nY_{\\sin}(\\omega) = -\\pi[(1)\\delta(\\omega - \\omega_{0}) - (-1)\\delta(\\omega + \\omega_{0})] = -\\pi[\\delta(\\omega - \\omega_{0}) + \\delta(\\omega + \\omega_{0})]\n$$\n我们认识到这正好是 $\\cos(\\omega_{0} t)$ 的傅里叶变换的负值：\n$$\nY_{\\sin}(\\omega) = -\\mathcal{F}\\{\\cos(\\omega_{0} t)\\}\n$$\n因此，$\\sin(\\omega_{0} t)$ 的希尔伯特变换是：\n$$\n\\mathcal{H}\\{\\sin(\\omega_{0} t)\\}(t) = -\\cos(\\omega_{0} t)\n$$\n相应的解析信号 $z_{\\sin}(t)$ 是：\n$$\nz_{\\sin}(t) = x(t) + i\\mathcal{H}\\{x(t)\\}(t) = \\sin(\\omega_{0} t) + i(-\\cos(\\omega_{0} t)) = \\sin(\\omega_{0} t) - i\\cos(\\omega_{0} t)\n$$\n这可以重写为：\n$$\nz_{\\sin}(t) = -i(\\cos(\\omega_{0} t) + i\\sin(\\omega_{0} t)) = -i\\exp(i\\omega_{0} t)\n$$\n为了验证其单边谱，我们计算其傅里叶变换 $Z_{\\sin}(\\omega)$：\n$$\nZ_{\\sin}(\\omega) = \\mathcal{F}\\{-i\\exp(i\\omega_{0} t)\\} = -i \\mathcal{F}\\{\\exp(i\\omega_{0} t)\\} = -i \\cdot 2\\pi\\delta(\\omega - \\omega_{0})\n$$\n因为 $\\omega_{0} > 0$，频谱 $Z_{\\sin}(\\omega)$ 也仅在正频率 $\\omega = \\omega_{0}$ 处非零，这证实了它是一个单边谱。\n\n**最终表达式**\n\n解析信号的精确闭式表达式为：\n对于 $x(t) = \\cos(\\omega_{0} t)$，解析信号是 $z_{\\cos}(t) = \\exp(i\\omega_{0} t)$。\n对于 $x(t) = \\sin(\\omega_{0} t)$，解析信号是 $z_{\\sin}(t) = -i\\exp(i\\omega_{0} t)$。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\exp(i \\omega_{0} t) & -i \\exp(i \\omega_{0} t)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "理论知识必须通过实践来巩固。在神经科学数据分析中，我们处理的是离散且有限长度的时间序列，而非连续的无穷信号。这项练习将理论与实践联系起来，指导你使用快速傅里叶变换（FFT）实现解析信号的计算。你需要亲手构建频域算法，特别注意处理直流（DC）和奈奎斯特（Nyquist）频率分量的细节，这是精确实现希尔伯特变换的关键步骤。",
            "id": "4199809",
            "problem": "给定一个均匀采样、实值、有限长度的时间序列 $x[n]$，它代表一个脑电图 (EEG) 时段。采样率为 $f_s = 1000$ Hz，时段长度为 $N = 2048$ 个样本点。目标是通过频域构建方法计算 $x[n]$ 的复值解析信号 $z[n]$，该方法需与解析信号的定义以及实数输入的离散傅里叶变换 (DFT) 的对称性属性保持一致。根据 $z[n]$，您必须计算瞬时振幅 $A[n]$ 和瞬时相位 $\\phi[n]$（以弧度为单位），然后通过计算解缠相位的时间导数并除以 $2\\pi$ 来估计瞬时频率 $f_{\\mathrm{inst}}[n]$（以赫兹为单位）。\n\n您的程序必须使用快速傅里叶变换 (FFT) 库来实现解析信号的计算，并且必须明确处理实数输入的对称性以及与偶数 $N$ 相关的特殊情况，例如直流 (DC) 分量 $k = 0$ 和奈奎斯特分量 $k = N/2$。不要使用内置的希尔伯特变换函数；请自行构建频域构造。\n\n使用以下四个信号组成的测试套件，所有信号均定义在 $n = 0,1,\\dots,N-1$ 上，其中 $t[n] = n / f_s$：\n- 测试用例 1 (调幅窄带信号): $x_1[n] = \\left(1 + 0.5 \\cos\\left(2\\pi \\cdot 0.5 \\cdot t[n]\\right)\\right)\\cos\\left(2\\pi \\cdot 10 \\cdot t[n] + 0.3\\right)$。在索引 $n_1 = 1000$ 处求值。\n- 测试用例 2 (常数信号): $x_2[n] = 2.0$。在索引 $n_2 = 500$ 处求值。\n- 测试用例 3 (低于奈奎斯特频率的高频正弦波): $x_3[n] = \\cos\\left(2\\pi \\cdot 450 \\cdot t[n]\\right)$。在索引 $n_3 = 256$ 处求值。\n- 测试用例 4 (零信号): $x_4[n] = 0$。在索引 $n_4 = 100$ 处求值。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $A_i = A[n_i] = |z[n_i]|$ (无单位),\n- $\\phi_i = \\phi[n_i]$ (以弧度为单位),\n- $f_i = f_{\\mathrm{inst}}[n_i]$ (以赫兹为单位)。\n\n通过首先计算解缠相位 $\\tilde{\\phi}[n]$，然后构建其关于时间 $t[n]$ 的数值导数来定义瞬时频率的估计值；以赫兹 (Hz) 表示 $f_{\\mathrm{inst}}[n]$。$\\phi[n]$ 的角度单位必须是弧度。采样间隔为 $\\Delta t = 1/f_s$ 秒。所有输出必须是实数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[A_1,\\phi_1,f_1,A_2,\\phi_2,f_2,A_3,\\phi_3,f_3,A_4,\\phi_4,f_4]$。\n\n确保科学真实性和数值鲁棒性，包括对偶数 $N$ 的直流分量和奈奎斯特分量的适当处理。此任务必须纯粹从数学和算法角度，利用实信号离散傅里叶变换的定义和性质来解决。角度值必须以弧度为单位，瞬时频率值必须以赫兹为单位。不允许外部输入；程序必须是自包含的，并使用指定的测试套件。",
            "solution": "用户提供的问题已经过分析和验证。该问题具有科学依据，定义明确且客观。它不包含任何矛盾、缺失信息或不切实际的前提。该任务是数字信号处理中的一个标准问题，特别是计算离散时间序列的解析信号及其相关的瞬时参数。所规定的方法——通过快速傅里叶变换 (FFT) 进行频域构建——是一种正确且标准的方法。问题指定了所有必要的参数和测试用例，以获得唯一且可验证的解。\n\n解题过程如下：首先，我们建立连续时间和离散时间中解析信号的理论基础。其次，我们详细说明使用离散傅里叶变换 (DFT) 进行数值计算的算法，并特别关注偶数长度实值信号的 DFT 性质。最后，我们定义从计算出的解析信号中计算瞬时振幅、相位和频率的步骤。\n\n**1. 解析信号的理论基础**\n\n对于一个实值连续时间信号 $x(t)$，其解析信号 $z(t)$ 是一个复值信号，定义为：\n$$\nz(t) = x(t) + i \\hat{x}(t)\n$$\n其中 $\\hat{x}(t)$ 是 $x(t)$ 的希尔伯特变换。希尔伯特变换由卷积定义：\n$$\n\\hat{x}(t) = \\mathcal{H}\\{x(t)\\} = \\frac{1}{\\pi} \\text{P.V.} \\int_{-\\infty}^{\\infty} \\frac{x(\\tau)}{t-\\tau} d\\tau\n$$\n其中 $\\text{P.V.}$ 表示积分的 Cauchy 主值。在频域中，希尔伯特变换对应于正频率分量的 $-\\pi/2$ 相移和负频率分量的 $+\\pi/2$ 相移。如果 $X(f)$ 是 $x(t)$ 的傅里叶变换，那么 $\\hat{x}(t)$ 的傅里叶变换是 $\\hat{X}(f) = -i \\cdot \\text{sgn}(f) \\cdot X(f)$，其中 $\\text{sgn}(f)$ 是符号函数。\n\n因此，解析信号的傅里叶变换 $Z(f)$ 为：\n$$\nZ(f) = X(f) + i\\hat{X}(f) = X(f) + i(-i \\cdot \\text{sgn}(f) \\cdot X(f)) = X(f)(1 + \\text{sgn}(f))\n$$\n这导致：\n$$\nZ(f) = \n\\begin{cases} \n2X(f), & f > 0 \\\\\nX(f), & f = 0 \\\\\n0, & f < 0 \n\\end{cases}\n$$\n因此，解析信号完全抑制了负频率分量，将正频率分量的幅度加倍，并保留了直流分量。\n\n**2. 通过离散傅里叶变换 (DFT) 的离散时间实现**\n\n对于一个长度为 $N$、以速率 $f_s$ 采样的有限长度实值离散时间信号 $x[n]$，我们使用 DFT 转换到频域。令 $X[k]$ 为 $x[n]$ 的 DFT：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi kn/N}, \\quad k = 0, 1, \\dots, N-1\n$$\n对于实信号 $x[n]$，其 DFT 表现出厄米共轭对称性：$X[k] = X^*[N-k]$，其中 $k=1, \\dots, N-1$。频率点 $k=0$ 对应直流分量，频率点 $k=1, \\dots, \\lfloor (N-1)/2 \\rfloor$ 对应正频率。对于偶数 $N$（如问题中指定的 $N=2048$），频率点 $k=N/2$ 对应奈奎斯特频率。频率点 $k=N/2+1, \\dots, N-1$ 对应负频率。\n\n为了构建解析信号的 DFT $Z[k]$，我们将连续情况下的逻辑应用于离散频谱 $X[k]$。对于偶数长度 $N$：\n1.  **直流分量 ($k=0$)：** 保留该分量。$Z[0] = X[0]$。\n2.  **正频率 ($k=1, \\dots, N/2 - 1$)：** 将这些分量加倍，以确保所得解析信号的实部能量守恒。$Z[k] = 2X[k]$。\n3.  **奈奎斯特分量 ($k=N/2$)：** 此频率是其自身的负频率对应物。一种通用且一致的约定是保留此分量。$Z[N/2] = X[N/2]$。\n4.  **负频率 ($k=N/2 + 1, \\dots, N-1$)：** 将这些分量置零。$Z[k] = 0$。\n\n一旦频域表示 $Z[k]$ 构建完成，就可使用离散傅里叶逆变换 (IDFT) 恢复离散时间解析信号 $z[n]$：\n$$\nz[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Z[k] e^{i 2\\pi kn/N}\n$$\n问题指定使用快速傅里叶变换 (FFT) 库，这是一种计算 DFT 和 IDFT 的高效算法。\n\n**3. 瞬时参数的计算**\n\n从复值解析信号 $z[n]$ 中，我们可以提取瞬时振幅 $A[n]$ 和瞬时相位 $\\phi[n]$。\n\n**瞬时振幅**是 $z[n]$ 的模：\n$$\nA[n] = |z[n]| = \\sqrt{(\\text{Re}\\{z[n]\\})^2 + (\\text{Im}\\{z[n]\\})^2}\n$$\n\n**瞬时相位**（或辐角）由下式给出：\n$$\n\\phi[n] = \\arg(z[n]) = \\text{atan2}(\\text{Im}\\{z[n]\\}, \\text{Re}\\{z[n]\\})\n$$\n`atan2` 函数能正确计算所有四个象限的角度，产生一个在区间 $(-\\pi, \\pi]$ 内的结果。这是缠绕相位。\n\n**瞬时频率** $f_{\\mathrm{inst}}[n]$ 定义为相位的变化率，并经过适当缩放。为了计算有意义的导数，必须首先对相位进行“解缠”。解缠，记为 $\\tilde{\\phi}[n]$，校正了当相位穿过 `atan2` 函数的支割线时发生的 $\\pm 2\\pi$ 的人为跳变。这是通过对连续的相位值加上或减去 $2\\pi$ 的整数倍来实现的，以使连续样本之间的绝对跳变小于或等于 $\\pi$。\n\n以赫兹 (Hz) 为单位的瞬时频率定义为：\n$$\nf_{\\mathrm{inst}}(t) = \\frac{1}{2\\pi} \\frac{d\\tilde{\\phi}(t)}{dt}\n$$\n对于采样间隔为 $\\Delta t = 1/f_s$ 的离散信号 $x[n]$，我们使用数值有限差分来近似导数。对于信号的内部点，二阶中心差分格式提供了良好的精度：\n$$\nf_{\\mathrm{inst}}[n] = \\frac{1}{2\\pi} \\frac{\\tilde{\\phi}[n+1] - \\tilde{\\phi}[n-1]}{2\\Delta t} = \\frac{f_s}{4\\pi} (\\tilde{\\phi}[n+1] - \\tilde{\\phi}[n-1])\n$$\n测试用例中提供的求值点 $n_i$ 都是内部点，这使得中心差分法既适用又鲁棒。\n\n**4. 在测试用例上的应用**\n\n该程序应用于四个测试信号中的每一个。参数为 $f_s = 1000$ Hz 和 $N=2048$。对于每个信号 $x_i[n]$，我们计算 $z_i[n]$，然后在指定的索引 $n_i$ 处计算 $A_i = |z_i[n_i]|$，$\\phi_i = \\arg(z_i[n_i])$ 和 $f_i = f_{\\mathrm{inst}}[n_i]$。对于零信号，所有结果值都确定为零。对于常数信号 $x_2[n]=2.0$，其解析信号为 $z_2[n]=2.0$，导致振幅为 2.0，相位和频率均为零。对于振荡信号，结果将近似于载波的参数，其偏差由调制（情况1）和有限长度分析引起的光谱泄漏（情况3）造成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing instantaneous amplitude, phase, and frequency\n    for a suite of test signals using a frequency-domain construction of the\n    analytic signal.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    fs = 1000  # Sampling rate in Hz\n    N = 2048   # Number of samples\n    t = np.arange(N) / fs  # Time vector in seconds\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"signal_func\": lambda t: (1 + 0.5 * np.cos(2 * np.pi * 0.5 * t)) * np.cos(2 * np.pi * 10 * t + 0.3),\n            \"eval_n\": 1000,\n            \"label\": \"AM Narrowband\"\n        },\n        {\n            \"signal_func\": lambda t: np.full(t.shape, 2.0),\n            \"eval_n\": 500,\n            \"label\": \"Constant\"\n        },\n        {\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 450 * t),\n            \"eval_n\": 256,\n            \"label\": \"High-Frequency Sinusoid\"\n        },\n        {\n            \"signal_func\": lambda t: np.zeros(t.shape),\n            \"eval_n\": 100,\n            \"label\": \"Zero Signal\"\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # --- Signal Generation ---\n        x = case[\"signal_func\"](t)\n        eval_n = case[\"eval_n\"]\n        \n        # --- Analytic Signal Computation ---\n        # 1. Compute the DFT of the real-valued signal x[n].\n        # The result from SciPy's FFT is a complex array X[k].\n        X = fft(x)\n\n        # 2. Construct the DFT of the analytic signal, Z[k].\n        # For an even N, we follow the specified frequency-domain construction rule.\n        Z = np.zeros_like(X, dtype=np.complex128)\n        \n        # Preserve DC component (k=0)\n        Z[0] = X[0]\n        \n        # Double positive frequency components (k=1 to N/2-1)\n        Z[1:N//2] = 2.0 * X[1:N//2]\n        \n        # Preserve Nyquist component (k=N/2)\n        Z[N//2] = X[N//2]\n        \n        # Zero out negative frequency components (k=N/2+1 to N-1)\n        # This is already handled by initializing Z with zeros.\n\n        # 3. Compute the inverse DFT to get the time-domain analytic signal z[n].\n        z = ifft(Z)\n\n        # --- Instantaneous Parameter Calculation ---\n        \n        # Special handling for the zero signal to avoid potential NaN/instability,\n        # although numpy handles angle(0) and gradient(zeros) gracefully.\n        if np.all(x == 0):\n            A_n = 0.0\n            phi_n = 0.0\n            f_inst_n = 0.0\n        else:\n            # Instantaneous Amplitude: A[n] = |z[n]|\n            amplitude = np.abs(z)\n            A_n = amplitude[eval_n]\n\n            # Instantaneous Phase (wrapped): phi[n] = arg(z[n]) in [-pi, pi]\n            phase = np.angle(z)\n            phi_n = phase[eval_n]\n\n            # Instantaneous Frequency: f_inst[n] = (1/2pi) * d(phi_unwrapped)/dt\n            # 1. Unwrap phase to get a continuous phase angle\n            unwrapped_phase = np.unwrap(phase)\n            \n            # 2. Compute the time derivative of the unwrapped phase using\n            # a second-order central difference for interior points.\n            # np.gradient handles this robustly. dt = 1/fs.\n            dt = 1.0 / fs\n            d_phi_dt = np.gradient(unwrapped_phase, dt)\n            \n            # 3. Convert angular frequency (rad/s) to frequency (Hz)\n            instantaneous_frequency = d_phi_dt / (2 * np.pi)\n            f_inst_n = instantaneous_frequency[eval_n]\n\n        results.extend([A_n, phi_n, f_inst_n])\n\n    # --- Final Output Formatting ---\n    # Format the results into the required single-line string.\n    output_str = \"[\" + \",\".join(f\"{v:.10f}\" for v in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "希尔伯特变换并非万能的，它准确分离瞬时幅度和相位的能力依赖于严格的数学假设。这项练习将深入探讨当这些假设被违反时的后果，特别是当幅度和载波信号的频谱发生重叠时，即违反了贝德罗西安定理（Bedrosian’s theorem）的条件。通过构建一个频谱重叠的反例并量化估计偏差，你将学会批判性地审视希尔伯特变换的应用场景，并理解其在真实数据分析中的局限性。",
            "id": "4199775",
            "problem": "考虑一个由窄带载波经振幅调制形成的实值神经时间序列模型 $x(t)$，定义为 $x(t) = A(t)\\cos\\left(\\phi(t)\\right)$，其中真实瞬时振幅为 $A(t)$，真实瞬时相位为 $\\phi(t)$。$x(t)$ 的解析信号 $z(t)$ 由 $z(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)$ 给出，其中 $\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换 (HT)，其定义为主值卷积 $\\mathcal{H}\\{x\\}(t) = \\left(x * \\frac{1}{\\pi t}\\right)(t)$。基于希尔伯特的标准振幅和相位估计器分别为 $\\widehat{A}(t) = |z(t)|$ 和 $\\widehat{\\phi}(t) = \\arg\\big(z(t)\\big)$。Bedrosian 定理指出，如果 $A(t)$ 和 $\\cos\\left(\\phi(t)\\right)$ 的傅里叶变换支撑集在频率上不相交（即，$A(t)$ 是严格的低通信道，而 $\\cos\\left(\\phi(t)\\right)$ 是严格的高通信道，且支撑集不重叠），那么 $\\mathcal{H}\\{A(t)\\cos\\left(\\phi(t)\\right)\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos\\left(\\phi(t)\\right)\\}(t)$，并且基于希尔伯特的估计器可以精确地恢复 $A(t)$ 和 $\\phi(t)$。在实践中，神经信号的 $A(t)$ 和载波之间可能表现出频谱重叠，这违反了 Bedrosian 定理的条件，并在 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$ 中引入偏差。\n\n您的任务是构建具有重叠频谱的反例，并计算偏差度量，以量化基于希尔伯特的估计器与真实值之间的偏差。在离散时间下工作，采样频率为 $f_s$ (单位 $\\mathrm{Hz}$)，持续时间为 $T$ (单位 $\\mathrm{s}$)，角度量以弧度为单位。使用以下模型组件：\n\n- 真实相位：$\\phi(t) = 2\\pi f_c t$，载波频率为 $f_c$ (单位 $\\mathrm{Hz}$)。\n- 真实振幅：$A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$，其中 $a_\\ell, a_h, a_{h2} \\in [0,1)$ 是振幅系数，$f_\\ell, f_h, f_{h2}$ (单位 $\\mathrm{Hz}$) 是调制频率。确保对所有 $t$ 都有 $A(t) > 0$，以避免无关紧要的包络符号模糊性。\n\n给定 $x(t) = A(t)\\cos(2\\pi f_c t)$，根据上述定义构建解析信号 $z(t)$ 并计算基于希尔伯特的估计值 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$。为减轻希尔伯特变换固有的末端效应，在计算度量时舍弃前 $10\\%$ 和后 $10\\%$ 的样本。\n\n定义以下偏差度量：\n- 振幅偏差 $b_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)$，其中 $N$ 是保留样本的数量。\n- 相位偏差 $b_\\phi$ 定义为相位差 $\\Delta\\phi[n] = \\mathrm{arg}\\left(e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$ 的循环均值，即\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right).\n$$\n这个 $b_\\phi$ 是一个以弧度为单位的有符号角，表示单位圆上相位误差的集中趋势。\n\n实现一个程序，构建以下四个测试用例，并为每个用例计算 $(b_A, b_\\phi)$：\n\n- 用例 1 (不相交频谱；满足 Bedrosian 条件)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.4$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.0$，$f_h = 0\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 用例 2 (在载波处有轻微重叠)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.4$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.1$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 用例 3 (在载波处有强重叠)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.2$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.4$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 用例 4 (在载波处及其附近有重叠)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.2$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.3$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.2$，$f_{h2} = 41\\,\\mathrm{Hz}$。\n\n您的程序应生成单行输出，其中包含八个浮点数结果，以逗号分隔的列表形式并用方括号括起来，按测试用例和度量排序：$[b_{A,1},b_{\\phi,1},b_{A,2},b_{\\phi,2},b_{A,3},b_{\\phi,3},b_{A,4},b_{\\phi,4}]$。角度必须以弧度为单位。不应打印任何其他文本。",
            "solution": "该问题要求计算一个模拟神经时间序列的瞬时振幅和相位的基于希尔伯特的估计器中的偏差。当振幅包络和载波信号之间的频谱重叠导致 Bedrosian 定理的条件被违反时，就会产生偏差。一个系统性的解决方案包括构建信号，通过希尔伯特变换计算解析信号，提取估计的属性，然后计算指定的偏差度量。\n\n实值信号的模型为 $x(t) = A(t)\\cos(\\phi(t))$，其中 $A(t)$ 是瞬时振幅，$\\phi(t)$ 是瞬时相位。目标是从 $x(t)$ 中估计 $A(t)$ 和 $\\phi(t)$。标准方法利用解析信号 $z(t)$，它是一个复信号，其实部是 $x(t)$，虚部是 $x(t)$ 的希尔伯特变换，记为 $\\mathcal{H}\\{x\\}(t)$。\n$$\nz(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)\n$$\n希尔伯特变换由卷积 $\\mathcal{H}\\{x\\}(t) = (x * \\frac{1}{\\pi t})(t)$ 定义。从解析信号中，瞬时振幅和相位估计如下：\n$$\n\\widehat{A}(t) = |z(t)| \\quad \\text{和} \\quad \\widehat{\\phi}(t) = \\arg\\left(z(t)\\right)\n$$\nBedrosian 定理为这些估计器的精确性（即 $\\widehat{A}(t) = A(t)$ 和 $\\widehat{\\phi}(t) = \\phi(t)$）提供了充分条件。该定理指出，如果低通信号 $A(t)$ 的傅里叶谱被限制在某个 $f_{max}$ 以下的频率，而高通信号 $\\cos(\\phi(t))$ 的频谱包含在 $f_{min}$ 以上的频率，且 $f_{max} < f_{min}$（即它们的傅里叶变换支撑集不相交），那么它们乘积的希尔伯特变换可以分离：\n$$\n\\mathcal{H}\\{A(t)\\cos(\\phi(t))\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos(\\phi(t))\\}\n$$\n对于特定载波 $\\cos(\\phi(t)) = \\cos(2\\pi f_c t)$，其希尔伯特变换为 $\\mathcal{H}\\{\\cos(2\\pi f_c t)\\}(t) = \\sin(2\\pi f_c t)$。在 Bedrosian 条件下，解析信号变为：\n$$\nz(t) = A(t)\\cos(2\\pi f_c t) + i\\,A(t)\\sin(2\\pi f_c t) = A(t)e^{i2\\pi f_c t}\n$$\n取这个理想 $z(t)$ 的幅度和角度可以正确地得到 $\\widehat{A}(t) = A(t)$ 和 $\\widehat{\\phi}(t) = 2\\pi f_c t = \\phi(t)$。\n\n该问题研究了频谱不相交条件被违反的场景。真实振幅定义为 $A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$。$A(t)$ 的频谱包含频率 $f_\\ell$、$f_h$ 和 $f_{h2}$。载波频率为 $f_c$。如果 $A(t)$ 中的任何调制频率与 $f_c$ 相当或更大，它们的频谱将会重叠，Bedrosian 定理将不成立，估计器 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$ 将会产生偏差。\n\n为给定的离散时间测试用例量化此偏差的算法步骤如下：\n1. 对每个用例，定义参数：采样频率 $f_s$、持续时间 $T$、载波频率 $f_c$ 以及振幅调制参数 $a_\\ell, f_\\ell, a_h, f_h, a_{h2}, f_{h2}$。\n2. 生成离散时间向量 $t[n] = n/f_s$，其中 $n = 0, 1, \\dots, N_{total}-1$，$N_{total} = \\lfloor f_s T \\rfloor$。\n3. 使用提供的方程构建真实值信号：真实振幅 $A[n]$ 和真实相位 $\\phi[n]$。\n4. 构建时间序列信号 $x[n] = A[n]\\cos(\\phi[n])$。\n5. 计算 $x[n]$ 的离散解析信号 $z[n]$。这可以通过使用快速傅里叶变换 (FFT) 方法高效完成，如 `scipy.signal.hilbert` 中的实现。该函数计算 $x[n]$ 的 FFT，将对应于负频率的系数置零，将正频率的系数加倍（特别处理直流和奈奎斯特频率），然后计算逆 FFT。\n6. 从 $z[n]$ 计算估计振幅 $\\widehat{A}[n] = |z[n]|$ 和估计相位 $\\widehat{\\phi}[n] = \\arg(z[n])$。\n7. 为了减轻基于 FFT 的希尔伯特变换中固有的循环卷积带来的边界伪影，所有时间序列（$A[n]$, $\\phi[n]$, $\\widehat{A}[n]$, 和 $\\widehat{\\phi}[n]$）的前 $10\\%$ 和后 $10\\%$ 被舍弃。\n8. 在剩余的 $N$ 个样本上，计算偏差度量。振幅偏差 $b_A$ 是误差的简单算术平均值：\n$$\nb_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)\n$$\n相位偏差 $b_\\phi$ 是一个循环均值，它能正确处理相位的缠绕特性。它是单位圆上相位误差的平均合向量的角度：\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right)\n$$\n其中相位差 $\\Delta\\phi[n]$ 通过计算 $\\Delta\\phi[n] = \\arg(e^{i(\\widehat{\\phi}[n] - \\phi[n])})$ 被缠绕到区间 $(-\\pi, \\pi]$。这在计算上等同于求代表相位误差的复相量平均值的角度：$b_\\phi = \\arg\\left(\\frac{1}{N}\\sum_{n=1}^{N} e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$。\n\n这四个测试用例旨在说明频谱重叠增加的效果：\n- 用例 1：$A(t)$ 中的最大频率为 $f_\\ell = 3\\,\\mathrm{Hz}$，远小于载波频率 $f_c = 40\\,\\mathrm{Hz}$。频谱分离良好，满足 Bedrosian 条件。我们预期偏差可以忽略不计。\n- 用例 2：在 $f_h = 40\\,\\mathrm{Hz}$ 处引入一个调制分量，该频率等于载波频率 $f_c$。这会产生直接的频谱重叠，违反了定理的条件。我们预期会出现非零偏差。\n- 用例 3：通过增加系数 $a_h$ 来加强用例 2 中的重叠条件。预计偏差会更大。\n- 用例 4：通过一个非常接近载波频率的调制频率 $f_{h2} = 41\\,\\mathrm{Hz}$ 引入额外的重叠。这创建了一个涉及多个干扰频谱分量的复杂重叠场景。\n\n以下程序实现了计算所有四个用例所需偏差度量的完整过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef calculate_biases(fs, T, fc, al, fl, ah, fh, ah2, fh2):\n    \"\"\"\n    Constructs a signal and computes amplitude and phase biases.\n\n    Args:\n        fs (float): Sampling frequency in Hz.\n        T (float): Signal duration in seconds.\n        fc (float): Carrier frequency in Hz.\n        al (float): Amplitude coefficient for low-frequency modulation.\n        fl (float): Frequency for low-frequency modulation in Hz.\n        ah (float): Amplitude coefficient for high-frequency modulation.\n        fh (float): Frequency for high-frequency modulation in Hz.\n        ah2 (float): Amplitude coefficient for second high-frequency modulation.\n        fh2 (float): Frequency for second high-frequency modulation in Hz.\n\n    Returns:\n        tuple[float, float]: A tuple containing the amplitude bias (b_A) and\n                             phase bias (b_phi) in radians.\n    \"\"\"\n    # 1. Create time vector and ground-truth signal components\n    n_total = int(fs * T)\n    t = np.arange(n_total) / fs\n\n    A_t = 1.0 + al * np.cos(2 * np.pi * fl * t) + \\\n          ah * np.cos(2 * np.pi * fh * t) + \\\n          ah2 * np.cos(2 * np.pi * fh2 * t)\n\n    phi_t = 2 * np.pi * fc * t\n    x_t = A_t * np.cos(phi_t)\n\n    # 2. Compute the analytic signal and extract estimated attributes\n    z_t = hilbert(x_t)\n    A_hat = np.abs(z_t)\n    phi_hat = np.angle(z_t)  # This is the wrapped instantaneous phase\n\n    # 3. Trim data to mitigate end effects\n    trim_samples = int(0.1 * n_total)\n    retained_slice = slice(trim_samples, -trim_samples)\n\n    A_t_trimmed = A_t[retained_slice]\n    A_hat_trimmed = A_hat[retained_slice]\n    phi_t_trimmed = phi_t[retained_slice]\n    phi_hat_trimmed = phi_hat[retained_slice]\n\n    # 4. Compute bias metrics\n    # Amplitude bias: simple mean of the error\n    b_A = np.mean(A_hat_trimmed - A_t_trimmed)\n\n    # Phase bias: circular mean of the phase error\n    phase_diff = phi_hat_trimmed - phi_t_trimmed\n    # The mean of complex phasors gives the resultant vector; its angle is the circular mean.\n    b_phi = np.angle(np.mean(np.exp(1j * phase_diff)))\n\n    return b_A, b_phi\n\ndef solve():\n    \"\"\"\n    Runs the four test cases and prints the results in the specified format.\n    \"\"\"\n    # (fs, T, fc, al, fl, ah, fh, ah2, fh2)\n    test_cases = [\n        # Case 1: Disjoint spectra (Bedrosian conditions satisfied)\n        (1000, 2, 40, 0.4, 3, 0.0, 0, 0.0, 0),\n        # Case 2: Mild overlap at the carrier\n        (1000, 2, 40, 0.4, 3, 0.1, 40, 0.0, 0),\n        # Case 3: Strong overlap at the carrier\n        (1000, 2, 40, 0.2, 3, 0.4, 40, 0.0, 0),\n        # Case 4: Overlap at and near the carrier\n        (1000, 2, 40, 0.2, 3, 0.3, 40, 0.2, 41),\n    ]\n\n    results = []\n    for params in test_cases:\n        b_A, b_phi = calculate_biases(*params)\n        results.extend([b_A, b_phi])\n\n    # Format the final output string as per the problem specification.\n    # A precision of 8 decimal places is used for clear representation.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}