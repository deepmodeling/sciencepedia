{
    "hands_on_practices": [
        {
            "introduction": "这项实践是将希尔伯特变换应用于真实世界数据的基石。我们将从连续时间的定义转向一个使用快速傅里叶变换（FFT）的具体、离散时间的算法。本练习将指导你完成正确的频域构建过程，包括处理直流（DC）和奈奎斯特（Nyquist）分量，以计算解析信号及其派生量()。",
            "id": "4199809",
            "problem": "给定一个均匀采样、实值、有限长度的时间序列 $x[n]$，它代表一个脑电图 (EEG) 时段。采样率为 $f_s = 1000$ Hz，时段长度为 $N = 2048$ 个样本。目标是通过频域构建方法计算 $x[n]$ 的复值解析信号 $z[n]$。该方法需与解析信号的定义以及实数输入的离散傅里叶变换 (DFT) 的对称性属性保持一致。根据 $z[n]$，你必须计算瞬时振幅 $A[n]$ 和瞬时相位 $\\phi[n]$（以弧度为单位），然后通过计算解缠相位的关于时间的导数并除以 $2\\pi$ 来估计瞬时频率 $f_{\\mathrm{inst}}[n]$（以赫兹为单位）。\n\n你的程序必须使用快速傅里叶变换 (FFT) 库来实现解析信号的计算，并且必须明确处理实数输入的对称性以及与偶数 $N$ 相关的特殊情况，例如直流 (DC) 分量 $k = 0$ 和奈奎斯特分量 $k = N/2$。不要使用内置的希尔伯特变换例程；请自行构建频域方法。\n\n使用以下包含四个信号的测试套件，所有信号均定义在 $n = 0,1,\\dots,N-1$ 上，其中 $t[n] = n / f_s$：\n- 测试用例 1 (窄带调幅): $x_1[n] = \\left(1 + 0.5 \\cos\\left(2\\pi \\cdot 0.5 \\cdot t[n]\\right)\\right)\\cos\\left(2\\pi \\cdot 10 \\cdot t[n] + 0.3\\right)$。在索引 $n_1 = 1000$ 处求值。\n- 测试用例 2 (常数): $x_2[n] = 2.0$。在索引 $n_2 = 500$ 处求值。\n- 测试用例 3 (低于奈奎斯特频率的高频正弦波): $x_3[n] = \\cos\\left(2\\pi \\cdot 450 \\cdot t[n]\\right)$。在索引 $n_3 = 256$ 处求值。\n- 测试用例 4 (零信号): $x_4[n] = 0$。在索引 $n_4 = 100$ 处求值。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- $A_i = A[n_i] = |z[n_i]|$ (无单位),\n- $\\phi_i = \\phi[n_i]$ (以弧度为单位),\n- $f_i = f_{\\mathrm{inst}}[n_i]$ (以赫兹为单位)。\n\n通过先计算解缠相位 $\\tilde{\\phi}[n]$，然后构建关于时间 $t[n]$ 的数值导数来定义瞬时频率的估计值；以赫兹 (Hz) 表示 $f_{\\mathrm{inst}}[n]$。$\\phi[n]$ 的角度单位必须是弧度。采样间隔为 $\\Delta t = 1/f_s$ 秒。所有输出必须是实数。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按 $[A_1,\\phi_1,f_1,A_2,\\phi_2,f_2,A_3,\\phi_3,f_3,A_4,\\phi_4,f_4]$ 的顺序排列。\n\n确保科学真实性和数值稳健性，包括对偶数 $N$ 的直流和奈奎斯特分量进行适当处理。此任务必须使用实数信号的 DFT 定义和性质，以纯粹的数学和算法方式解决。角度值必须以弧度为单位，瞬时频率值必须以赫兹为单位。不允许外部输入；程序必须是自包含的，并使用指定的测试套件。",
            "solution": "用户提供的问题已经过分析和验证。该问题具有科学依据，定义明确且客观。它不包含任何矛盾、缺失信息或不切实际的前提。此任务是数字信号处理中的一个标准问题，具体而言是计算离散时间序列的解析信号及其相关的瞬时参数。所规定的方法——通过快速傅里叶变换 (FFT) 进行频域构建——是一种正确且标准的方法。问题指定了所有必要的参数和测试用例，以获得唯一且可验证的解。\n\n解决方案如下：首先，我们为连续时间和离散时间中的解析信号建立理论基础。其次，我们详细说明使用离散傅里叶变换 (DFT) 进行数值计算的算法，并特别关注偶数长度实值信号的 DFT 性质。最后，我们定义从计算出的解析信号中计算瞬时振幅、相位和频率的步骤。\n\n**1. 解析信号的理论基础**\n\n对于一个实值连续时间信号 $x(t)$，其解析信号 $z(t)$ 是一个复值信号，定义为：\n$$\nz(t) = x(t) + i \\hat{x}(t)\n$$\n其中 $\\hat{x}(t)$ 是 $x(t)$ 的希尔伯特变换。希尔伯特变换由卷积定义：\n$$\n\\hat{x}(t) = \\mathcal{H}\\{x(t)\\} = \\frac{1}{\\pi} \\text{P.V.} \\int_{-\\infty}^{\\infty} \\frac{x(\\tau)}{t-\\tau} d\\tau\n$$\n其中 $\\text{P.V.}$ 表示积分的 Cauchy 主值。在频域中，希尔伯特变换对应于正频率的 $-\\pi/2$ 相移和负频率的 $+\\pi/2$ 相移。如果 $X(f)$ 是 $x(t)$ 的傅里叶变换，那么 $\\hat{x}(t)$ 的傅里叶变换是 $\\hat{X}(f) = -i \\cdot \\text{sgn}(f) \\cdot X(f)$，其中 $\\text{sgn}(f)$ 是符号函数。\n\n因此，解析信号的傅里叶变换 $Z(f)$ 为：\n$$\nZ(f) = X(f) + i\\hat{X}(f) = X(f) + i(-i \\cdot \\text{sgn}(f) \\cdot X(f)) = X(f)(1 + \\text{sgn}(f))\n$$\n这导致：\n$$\nZ(f) = \n\\begin{cases} \n2X(f), & f > 0 \\\\\nX(f), & f = 0 \\\\\n0, & f < 0 \n\\end{cases}\n$$\n因此，解析信号完全抑制了负频率分量，将正频率分量的幅度加倍，并保留了直流分量。\n\n**2. 通过离散傅里叶变换 (DFT) 的离散时间实现**\n\n对于一个长度为 $N$、以速率 $f_s$ 采样的有限长度实值离散时间信号 $x[n]$，我们使用 DFT 转换到频域。令 $X[k]$ 为 $x[n]$ 的 DFT：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi kn/N}, \\quad k = 0, 1, \\dots, N-1\n$$\n对于实数信号 $x[n]$，其 DFT 表现出厄米对称性：$X[k] = X^*[N-k]$ 对于 $k=1, \\dots, N-1$。$k=0$ 处的频率点对应直流分量，$k=1, \\dots, \\lfloor (N-1)/2 \\rfloor$ 处的频率点对应正频率。对于问题中指定的偶数 $N$（$N=2048$），$k=N/2$ 处的频率点对应奈奎斯特频率。$k=N/2+1, \\dots, N-1$ 处的频率点对应负频率。\n\n为了构建解析信号的 DFT $Z[k]$，我们将连续情况下的逻辑应用于离散频谱 $X[k]$。对于偶数长度 $N$：\n1.  **直流分量 ($k=0$):** 保留此分量。$Z[0] = X[0]$。\n2.  **正频率 ($k=1, \\dots, N/2 - 1$):** 将这些分量加倍，以确保所得解析信号的实部能量守恒。$Z[k] = 2X[k]$。\n3.  **奈奎斯特分量 ($k=N/2$):** 这个频率是其自身的负频率对应物。一个通用且一致的约定是保留此分量。$Z[N/2] = X[N/2]$。\n4.  **负频率 ($k=N/2 + 1, \\dots, N-1$):** 将这些分量置零。$Z[k] = 0$。\n\n一旦频域表示 $Z[k]$ 构建完成，便可使用逆 DFT (IDFT) 恢复离散时间解析信号 $z[n]$：\n$$\nz[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Z[k] e^{i 2\\pi kn/N}\n$$\n问题指定使用快速傅里叶变换 (FFT) 库，这是一种计算 DFT 和 IDFT 的高效算法。\n\n**3. 瞬时参数的计算**\n\n从复值解析信号 $z[n]$ 中，我们可以提取瞬时振幅 $A[n]$ 和瞬时相位 $\\phi[n]$。\n\n**瞬时振幅**是 $z[n]$ 的模：\n$$\nA[n] = |z[n]| = \\sqrt{(\\text{Re}\\{z[n]\\})^2 + (\\text{Im}\\{z[n]\\})^2}\n$$\n\n**瞬时相位**（或辐角）由以下公式给出：\n$$\n\\phi[n] = \\arg(z[n]) = \\text{atan2}(\\text{Im}\\{z[n]\\}, \\text{Re}\\{z[n]\\})\n$$\n`atan2` 函数可以正确计算所有四个象限的角度，产生一个在 $(-\\pi, \\pi]$ 区间内的结果。这是缠绕相位。\n\n**瞬时频率** $f_{\\mathrm{inst}}[n]$ 定义为相位的变化率，经过适当缩放。为了计算一个有意义的导数，必须首先对相位进行“解缠”。解缠（表示为 $\\tilde{\\phi}[n]$）修正了当相位穿过 `atan2` 函数的支割线时发生的人为的 $\\pm 2\\pi$ 跳变。这是通过对连续的相位值加上或减去 $2\\pi$ 的整数倍来实现的，以使连续样本之间的绝对跳变小于或等于 $\\pi$。\n\n以赫兹 (Hz) 为单位的瞬时频率定义为：\n$$\nf_{\\mathrm{inst}}(t) = \\frac{1}{2\\pi} \\frac{d\\tilde{\\phi}(t)}{dt}\n$$\n对于我们的离散信号 $x[n]$，其采样间隔为 $\\Delta t = 1/f_s$，我们使用数值有限差分来近似导数。二阶中心差分格式为信号的内部点提供了良好的精度：\n$$\nf_{\\mathrm{inst}}[n] = \\frac{1}{2\\pi} \\frac{\\tilde{\\phi}[n+1] - \\tilde{\\phi}[n-1]}{2\\Delta t} = \\frac{f_s}{4\\pi} (\\tilde{\\phi}[n+1] - \\tilde{\\phi}[n-1])\n$$\n测试用例中提供的求值点 $n_i$ 都是内部点，这使得中心差分法既适用又稳健。\n\n**4. 应用于测试用例**\n\n将此过程应用于四个测试信号中的每一个。参数为 $f_s = 1000$ Hz 和 $N=2048$。对于每个信号 $x_i[n]$，我们计算 $z_i[n]$，然后在指定的索引 $n_i$ 处计算 $A_i = |z_i[n_i]|$、$ \\phi_i = \\arg(z_i[n_i]) $ 和 $f_i = f_{\\mathrm{inst}}[n_i]$。对于零信号，所有结果值都确定为零。对于常数信号 $x_2[n]=2.0$，其解析信号为 $z_2[n]=2.0$，导致振幅为 $2.0$，相位和频率为零。对于振荡信号，结果将近似于载波的参数，其偏差由调制（用例1）和有限长度分析引起的光谱泄漏（用例3）造成。",
            "answer": "```python\nimport numpy as np\nfrom scipy.fft import fft, ifft\n\ndef solve():\n    \"\"\"\n    Solves the problem of computing instantaneous amplitude, phase, and frequency\n    for a suite of test signals using a frequency-domain construction of the\n    analytic signal.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    fs = 1000  # Sampling rate in Hz\n    N = 2048   # Number of samples\n    t = np.arange(N) / fs  # Time vector in seconds\n\n    # --- Test Case Definitions ---\n    test_cases = [\n        {\n            \"signal_func\": lambda t: (1 + 0.5 * np.cos(2 * np.pi * 0.5 * t)) * np.cos(2 * np.pi * 10 * t + 0.3),\n            \"eval_n\": 1000,\n            \"label\": \"AM Narrowband\"\n        },\n        {\n            \"signal_func\": lambda t: np.full(t.shape, 2.0),\n            \"eval_n\": 500,\n            \"label\": \"Constant\"\n        },\n        {\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 450 * t),\n            \"eval_n\": 256,\n            \"label\": \"High-Frequency Sinusoid\"\n        },\n        {\n            \"signal_func\": lambda t: np.zeros(t.shape),\n            \"eval_n\": 100,\n            \"label\": \"Zero Signal\"\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # --- Signal Generation ---\n        x = case[\"signal_func\"](t)\n        eval_n = case[\"eval_n\"]\n        \n        # --- Analytic Signal Computation ---\n        # 1. Compute the DFT of the real-valued signal x[n].\n        # The result from SciPy's FFT is a complex array X[k].\n        X = fft(x)\n\n        # 2. Construct the DFT of the analytic signal, Z[k].\n        # For an even N, we follow the specified frequency-domain construction rule.\n        Z = np.zeros_like(X, dtype=np.complex128)\n        \n        # Preserve DC component (k=0)\n        Z[0] = X[0]\n        \n        # Double positive frequency components (k=1 to N/2-1)\n        Z[1:N//2] = 2.0 * X[1:N//2]\n        \n        # Preserve Nyquist component (k=N/2)\n        Z[N//2] = X[N//2]\n        \n        # Zero out negative frequency components (k=N/2+1 to N-1)\n        # This is already handled by initializing Z with zeros.\n\n        # 3. Compute the inverse DFT to get the time-domain analytic signal z[n].\n        z = ifft(Z)\n\n        # --- Instantaneous Parameter Calculation ---\n        \n        # Special handling for the zero signal to avoid potential NaN/instability,\n        # although numpy handles angle(0) and gradient(zeros) gracefully.\n        if np.all(x == 0):\n            A_n = 0.0\n            phi_n = 0.0\n            f_inst_n = 0.0\n        else:\n            # Instantaneous Amplitude: A[n] = |z[n]|\n            amplitude = np.abs(z)\n            A_n = amplitude[eval_n]\n\n            # Instantaneous Phase (wrapped): phi[n] = arg(z[n]) in [-pi, pi]\n            phase = np.angle(z)\n            phi_n = phase[eval_n]\n\n            # Instantaneous Frequency: f_inst[n] = (1/2pi) * d(phi_unwrapped)/dt\n            # 1. Unwrap phase to get a continuous phase angle\n            unwrapped_phase = np.unwrap(phase)\n            \n            # 2. Compute the time derivative of the unwrapped phase using\n            # a second-order central difference for interior points.\n            # np.gradient handles this robustly. dt = 1/fs.\n            dt = 1.0 / fs\n            d_phi_dt = np.gradient(unwrapped_phase, dt)\n            \n            # 3. Convert angular frequency (rad/s) to frequency (Hz)\n            instantaneous_frequency = d_phi_dt / (2 * np.pi)\n            f_inst_n = instantaneous_frequency[eval_n]\n\n        results.extend([A_n, phi_n, f_inst_n])\n\n    # --- Final Output Formatting ---\n    # Format the results into the required single-line string.\n    output_str = \"[\" + \",\".join(f\"{v:.10f}\" for v in results) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "通过希尔伯特变换来估计瞬时振幅和相位的优雅方法，依赖于一个被称为贝德罗西安定理（Bedrosian's theorem）的关键条件，该定理要求振幅包络和载波的频谱是不相交的。这项实践将挑战你去探索当此条件被违反时会发生什么()。通过构建频谱重叠的信号，你将量化由此产生的偏差，并更深刻地理解这个强大工具在何时可能会误导你。",
            "id": "4199775",
            "problem": "考虑一个通过窄带载波的幅度调制形成的实值神经时间序列模型 $x(t)$，其定义为 $x(t) = A(t)\\cos\\left(\\phi(t)\\right)$，其中真实的瞬时幅度为 $A(t)$，真实的瞬时相位为 $\\phi(t)$。$x(t)$ 的解析信号 $z(t)$ 由 $z(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)$ 给出，其中 $\\mathcal{H}\\{\\cdot\\}$ 表示希尔伯特变换 (HT)，其定义为主值卷积 $\\mathcal{H}\\{x\\}(t) = \\left(x * \\frac{1}{\\pi t}\\right)(t)$。幅度和相位的标准基于希尔伯特的估计量分别为 $\\widehat{A}(t) = |z(t)|$ 和 $\\widehat{\\phi}(t) = \\arg\\big(z(t)\\big)$。Bedrosian 定理指出，如果 $A(t)$ 和 $\\cos\\left(\\phi(t)\\right)$ 的傅里叶变换支撑集在频率上是不相交的（即，$A(t)$ 是严格低通的，而 $\\cos\\left(\\phi(t)\\right)$ 是严格高通的，其支撑集不重叠），那么 $\\mathcal{H}\\{A(t)\\cos\\left(\\phi(t)\\right)\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos\\left(\\phi(t)\\right)\\}(t)$，并且基于希尔伯特的估计量可以精确地恢复 $A(t)$ 和 $\\phi(t)$。在实践中，神经信号的 $A(t)$ 与载波之间可能表现出重叠的频谱，这违反了 Bedrosian 定理的条件，并在 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$ 中引入偏差。\n\n你的任务是构建具有重叠频谱的反例，并计算偏差度量，以量化基于希尔伯特的估计量与真实值之间的偏差。在离散时间内进行操作，采样频率为 $f_s$（单位 $\\mathrm{Hz}$），持续时间为 $T$（单位 $\\mathrm{s}$），角度量以弧度为单位。使用以下模型组件：\n\n- 真实相位：$\\phi(t) = 2\\pi f_c t$，载波频率为 $f_c$（单位 $\\mathrm{Hz}$）。\n- 真实幅度：$A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$，其中 $a_\\ell, a_h, a_{h2} \\in [0,1)$ 是幅度系数，$f_\\ell, f_h, f_{h2}$（单位 $\\mathrm{Hz}$）是调制频率。确保对所有 $t$ 都有 $A(t) > 0$，以避免平凡的包络符号模糊性。\n\n给定 $x(t) = A(t)\\cos(2\\pi f_c t)$，构建解析信号 $z(t)$，并根据上述定义计算基于希尔伯特的估计值 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$。为减轻希尔伯特变换固有的终端效应，在计算度量时丢弃最初和最后的 $10\\%$ 樣本。\n\n定义以下偏差度量：\n- 幅度偏差 $b_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)$，其中 $N$ 是保留样本的数量。\n- 相位偏差 $b_\\phi$ 定义为相位差 $\\Delta\\phi[n] = \\mathrm{arg}\\left(e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$ 的循环均值，即\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right).\n$$\n这个 $b_\\phi$ 是一个以弧度为单位的带符号角度，表示单位圆上相位误差的中心趋势。\n\n实现一个程序，构建以下四个测试用例，并为每个用例计算 $(b_A, b_\\phi)$：\n\n- 情况 1 (不相交频谱；满足 Bedrosian 条件)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.4$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.0$，$f_h = 0\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 情况 2 (载波处轻度重叠)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.4$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.1$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 情况 3 (载波处强烈重叠)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.2$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.4$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.0$，$f_{h2} = 0\\,\\mathrm{Hz}$。\n- 情况 4 (载波處及附近重疊)：$f_s = 1000\\,\\mathrm{Hz}$，$T = 2\\,\\mathrm{s}$，$f_c = 40\\,\\mathrm{Hz}$，$a_\\ell = 0.2$，$f_\\ell = 3\\,\\mathrm{Hz}$，$a_h = 0.3$，$f_h = 40\\,\\mathrm{Hz}$，$a_{h2} = 0.2$，$f_{h2} = 41\\,\\mathrm{Hz}$。\n\n你的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，列表包含八个浮点数结果，按测试用例和度量排序：$[b_{A,1},b_{\\phi,1},b_{A,2},b_{\\phi,2},b_{A,3},b_{\\phi,3},b_{A,4},b_{\\phi,4}]$。角度必须以弧度为单位。不应打印任何其他文本。",
            "solution": "该问题要求计算用于模拟神经时间序列的瞬时幅度和相位的基于希尔伯特的估计量中的偏差。当幅度包络和载波信号之间的频谱重叠导致 Bedrosian 定理的条件被违反时，就会产生偏差。一个系统性的解决方案包括构建信号，通过希尔伯特变换计算解析信号，提取估计的属性，然后计算指定的偏差度量。\n\n实值信号的模型是 $x(t) = A(t)\\cos(\\phi(t))$，其中 $A(t)$ 是瞬时幅度，$\\phi(t)$ 是瞬时相位。目标是从 $x(t)$ 中估计 $A(t)$ 和 $\\phi(t)$。标准方法利用解析信号 $z(t)$，它是一个复数信号，其实部是 $x(t)$，虚部是 $x(t)$ 的希尔伯特变换，记作 $\\mathcal{H}\\{x\\}(t)$。\n$$\nz(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)\n$$\n希尔伯特变换由卷积 $\\mathcal{H}\\{x\\}(t) = (x * \\frac{1}{\\pi t})(t)$ 定义。从解析信号中，瞬时幅度和相位被估计为：\n$$\n\\widehat{A}(t) = |z(t)| \\quad \\text{和} \\quad \\widehat{\\phi}(t) = \\arg\\left(z(t)\\right)\n$$\nBedrosian 定理为这些估计量的精确性（即 $\\widehat{A}(t) = A(t)$ 和 $\\widehat{\\phi}(t) = \\phi(t)$）提供了充分条件。该定理指出，如果低通信号 $A(t)$ 的傅里叶频谱被限制在某个 $f_{max}$ 以下的频率，而高通信号 $\\cos(\\phi(t))$ 的频谱包含在某个 $f_{min}$ 以上的频率中，且 $f_{max} < f_{min}$（即它们的频谱支撑集不相交），那么它们乘积的希尔伯特变换可以分离：\n$$\n\\mathcal{H}\\{A(t)\\cos(\\phi(t))\\}(t) = A(t)\\,\\mathcal{H}\\{\\cos(\\phi(t))\\}\n$$\n对于特定载波 $\\cos(\\phi(t)) = \\cos(2\\pi f_c t)$，其希尔伯特变换为 $\\mathcal{H}\\{\\cos(2\\pi f_c t)\\}(t) = \\sin(2\\pi f_c t)$。在 Bedrosian 条件下，解析信号变为：\n$$\nz(t) = A(t)\\cos(2\\pi f_c t) + i\\,A(t)\\sin(2\\pi f_c t) = A(t)e^{i2\\pi f_c t}\n$$\n对这个理想的 $z(t)$ 取幅度和角度，可以正确地得到 $\\widehat{A}(t) = A(t)$ 和 $\\widehat{\\phi}(t) = 2\\pi f_c t = \\phi(t)$。\n\n该问题研究了频谱不相交条件被违反的场景。真实幅度定义为 $A(t) = 1 + a_\\ell \\cos(2\\pi f_\\ell t) + a_h \\cos(2\\pi f_h t) + a_{h2} \\cos(2\\pi f_{h2} t)$。$A(t)$ 的频谱包含频率 $f_\\ell$、$f_h$ 和 $f_{h2}$。载波频率为 $f_c$。如果 $A(t)$ 中的任何调制频率与 $f_c$ 相当或大于 $f_c$，它们的频谱将会重叠，Bedrosian 定理将不成立，估计量 $\\widehat{A}(t)$ 和 $\\widehat{\\phi}(t)$ 将会产生偏差。\n\n为给定的离散时间测试用例量化此偏差的算法步骤如下：\n1. 对于每个用例，定义参数：采样频率 $f_s$、持续时间 $T$、载波频率 $f_c$ 以及幅度调制参数 $a_\\ell, f_\\ell, a_h, f_h, a_{h2}, f_{h2}$。\n2. 生成一个离散时间向量 $t[n] = n/f_s$，其中 $n = 0, 1, \\dots, N_{total}-1$，且 $N_{total} = \\lfloor f_s T \\rfloor$。\n3. 使用提供的方程构建真实值信号：真实幅度 $A[n]$ 和真实相位 $\\phi[n]$。\n4. 构建时间序列信号 $x[n] = A[n]\\cos(\\phi[n])$。\n5. 计算 $x[n]$ 的离散解析信号 $z[n]$。这可以通过使用快速傅里叶变换 (FFT) 方法高效完成，如 `scipy.signal.hilbert` 中的实现。该函数计算 $x[n]$ 的 FFT，将对应于负频率的系数置零，将正频率的系数加倍（对直流和奈奎斯特频率进行特殊处理），然后计算逆 FFT。\n6. 从 $z[n]$ 计算估计幅度 $\\widehat{A}[n] = |z[n]|$ 和估计相位 $\\widehat{\\phi}[n] = \\arg(z[n])$。\n7. 为了减轻基于 FFT 的希尔伯特变换中固有的循环卷积所带来的边界伪影，所有时间序列（$A[n]$、$\\phi[n]$、$\\widehat{A}[n]$ 和 $\\widehat{\\phi}[n]$）的最初和最后 $10\\%$ 的样本都将被丢弃。\n8. 在剩余的 $N$ 个样本上，计算偏差度量。幅度偏差 $b_A$ 是误差的简单算术平均值：\n$$\nb_A = \\frac{1}{N}\\sum_{n=1}^N \\left(\\widehat{A}[n] - A[n]\\right)\n$$\n相位偏差 $b_\\phi$ 是一个循环均值，它能恰当地处理相位的环绕特性。它是单位圆上相位误差的平均合向量的角度：\n$$\nb_\\phi = \\mathrm{atan2}\\!\\left(\\frac{1}{N}\\sum_{n=1}^N \\sin\\left(\\Delta\\phi[n]\\right),\\;\\frac{1}{N}\\sum_{n=1}^N \\cos\\left(\\Delta\\phi[n]\\right)\\right)\n$$\n其中相位差 $\\Delta\\phi[n]$ 通过计算 $\\Delta\\phi[n] = \\arg(e^{i(\\widehat{\\phi}[n] - \\phi[n])})$ 被包裹到区间 $(-\\pi, \\pi]$。这在计算上等效于求代表相位误差的复相量平均值的角度：$b_\\phi = \\arg\\left(\\frac{1}{N}\\sum_{n=1}^{N} e^{i(\\widehat{\\phi}[n] - \\phi[n])}\\right)$。\n\n这四个测试用例旨在说明频谱重叠增加的影响：\n- 情况 1：$A(t)$ 中的最大频率为 $f_\\ell = 3\\,\\mathrm{Hz}$，远小于载波频率 $f_c = 40\\,\\mathrm{Hz}$。频谱分离良好，满足 Bedrosian 条件。我们预期偏差可忽略不计。\n- 情况 2：在 $f_h = 40\\,\\mathrm{Hz}$ 处引入了一个调制分量，这等于载波频率 $f_c$。这造成了直接的频谱重叠，违反了定理的条件。我们预期偏差为非零值。\n- 情况 3：通过增加系数 $a_h$ 来加强情况 2 的重叠条件。预计会产生更大的偏差。\n- 情况 4：通过调制频率 $f_{h2} = 41\\,\\mathrm{Hz}$ 引入了额外的重叠，该频率非常接近载波频率。这创建了一个涉及多个干扰频谱分量的复杂重叠场景。\n\n以下程序实现了计算所有四个情况下所需偏差度量的完整过程。",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal import hilbert\n\ndef calculate_biases(fs, T, fc, al, fl, ah, fh, ah2, fh2):\n    \"\"\"\n    Constructs a signal and computes amplitude and phase biases.\n\n    Args:\n        fs (float): Sampling frequency in Hz.\n        T (float): Signal duration in seconds.\n        fc (float): Carrier frequency in Hz.\n        al (float): Amplitude coefficient for low-frequency modulation.\n        fl (float): Frequency for low-frequency modulation in Hz.\n        ah (float): Amplitude coefficient for high-frequency modulation.\n        fh (float): Frequency for high-frequency modulation in Hz.\n        ah2 (float): Amplitude coefficient for second high-frequency modulation.\n        fh2 (float): Frequency for second high-frequency modulation in Hz.\n\n    Returns:\n        tuple[float, float]: A tuple containing the amplitude bias (b_A) and\n                             phase bias (b_phi) in radians.\n    \"\"\"\n    # 1. Create time vector and ground-truth signal components\n    n_total = int(fs * T)\n    t = np.arange(n_total) / fs\n\n    A_t = 1.0 + al * np.cos(2 * np.pi * fl * t) + \\\n          ah * np.cos(2 * np.pi * fh * t) + \\\n          ah2 * np.cos(2 * np.pi * fh2 * t)\n\n    phi_t = 2 * np.pi * fc * t\n    x_t = A_t * np.cos(phi_t)\n\n    # 2. Compute the analytic signal and extract estimated attributes\n    z_t = hilbert(x_t)\n    A_hat = np.abs(z_t)\n    phi_hat = np.angle(z_t)  # This is the wrapped instantaneous phase\n\n    # 3. Trim data to mitigate end effects\n    trim_samples = int(0.1 * n_total)\n    retained_slice = slice(trim_samples, -trim_samples)\n\n    A_t_trimmed = A_t[retained_slice]\n    A_hat_trimmed = A_hat[retained_slice]\n    phi_t_trimmed = phi_t[retained_slice]\n    phi_hat_trimmed = phi_hat[retained_slice]\n\n    # 4. Compute bias metrics\n    # Amplitude bias: simple mean of the error\n    b_A = np.mean(A_hat_trimmed - A_t_trimmed)\n\n    # Phase bias: circular mean of the phase error\n    phase_diff = phi_hat_trimmed - phi_t_trimmed\n    # The mean of complex phasors gives the resultant vector; its angle is the circular mean.\n    b_phi = np.angle(np.mean(np.exp(1j * phase_diff)))\n\n    return b_A, b_phi\n\ndef solve():\n    \"\"\"\n    Runs the four test cases and prints the results in the specified format.\n    \"\"\"\n    # (fs, T, fc, al, fl, ah, fh, ah2, fh2)\n    test_cases = [\n        # Case 1: Disjoint spectra (Bedrosian conditions satisfied)\n        (1000, 2, 40, 0.4, 3, 0.0, 0, 0.0, 0),\n        # Case 2: Mild overlap at the carrier\n        (1000, 2, 40, 0.4, 3, 0.1, 40, 0.0, 0),\n        # Case 3: Strong overlap at the carrier\n        (1000, 2, 40, 0.2, 3, 0.4, 40, 0.0, 0),\n        # Case 4: Overlap at and near the carrier\n        (1000, 2, 40, 0.2, 3, 0.3, 40, 0.2, 41),\n    ]\n\n    results = []\n    for params in test_cases:\n        b_A, b_phi = calculate_biases(*params)\n        results.extend([b_A, b_phi])\n\n    # Format the final output string as per the problem specification.\n    # A precision of 8 decimal places is used for clear representation.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "“瞬时振幅”和“瞬时频率”这两个概念，其物理意义仅在处理一类被称为单分量信号的特定信号时才明确。这最后一项实践将展示当这一假设被违反时，这些概念是如何失效的，并可能导致诸如负瞬时频率等看似矛盾的结果()。通过这次探索，你将学会在解释结果之前，如何批判性地评估一个信号是否适合进行基于希尔伯特变换的分析。",
            "id": "4199794",
            "problem": "您的任务是分析从实值信号的希尔伯特变换导出的瞬时量，以确定瞬时频率 $f(t)$ 在何种条件下会变为负值或无定义，并在一个构造的多分量信号上展示单分量假设的失效。基本定义仅限于以下几点：希尔伯特变换、解析信号、瞬时振幅和瞬时相位。您必须从这些基本定义中推导出所有后续量，不得使用任何绕过这些基本定义所隐含的推导步骤的快捷公式。\n\n起点与定义：对于一个实值信号 $x(t)$，定义其希尔伯特变换 $\\mathcal{H}\\{x\\}(t)$ 和相关的解析信号 $z(t) = x(t) + i\\,\\mathcal{H}\\{x\\}(t)$，其中 $i$ 是虚数单位。然后，通过 $A(t) = |z(t)|$ 和 $\\phi(t) = \\arg(z(t))$ 定义瞬时振幅 $A(t)$ 和瞬时相位 $\\phi(t)$，角度以弧度为单位。最后，从解卷绕的瞬时相位的时间导数定义瞬时频率 $f(t)$，并适当归一化到单位赫兹 (Hz)。所有频率都必须以赫兹表示。\n\n您的程序必须为每个给定的测试用例实现以下步骤：\n1. 根据测试用例规范，在均匀网格 $t_n = n / f_s$（$n = 0,1,\\dots,N-1$）上构建实值信号 $x(t)$，其中采样率为 $f_s$（单位：赫兹），时长为 $T$（单位：秒），$N = \\lfloor T \\cdot f_s \\rfloor$。\n2. 使用希尔伯特变换计算 $x(t)$ 的解析信号 $z(t)$。\n3. 从 $z(t)$ 计算 $A(t)$ 和 $\\phi(t)$，对 $\\phi(t)$ 进行解卷绕以消除 $2\\pi$ 不连续性，并从解卷绕相位的时间导数计算 $f(t)$（单位：赫兹）。\n4. 识别 $f(t)$ 为负值和 $f(t)$ 无定义的时间样本。如果 $A(t) \\le \\epsilon$（$\\epsilon$ 是一个小的振幅阈值），或者计算出的 $f(t)$ 不是有限实数，则认为该样本是无定义的。使用 $\\epsilon = 10^{-8}$，并将任何具有非有限值的 $f(t)$ 视为无定义。\n5. 量化 $f(t)$ 为负值和 $f(t)$ 无定义的样本占总样本的分数（以小数表示）。如果 $f(t) < -\\delta$（容差 $\\delta = 10^{-6}$），则样本被计为负值；不要将无定义的样本计为负值。\n6. 使用频域准则评估单分量假设是否失效：计算 $x(t)$ 在非负频率上的实值离散傅里叶变换幅值，并计算高于相对阈值的显著峰值数量。如果高于阈值的显著峰值多于一个，则宣告失效。使用峰值高度阈值为最大幅值的 $0.6$ 倍，并忽略低于 $1\\,\\mathrm{Hz}$ 的任何峰值以排除直流分量。\n\n测试套件规范（所有角度以弧度为单位；所有频率以赫兹为单位）：\n- 情况 A（理想情况，窄带单分量）：$f_s = 1000$，$T = 2.0$，且 $x(t) = \\cos(2\\pi \\cdot 10\\, t)$。\n- 情况 B（包络过零导致 $f(t)$ 无定义）：$f_s = 1000$，$T = 2.0$，且 $x(t) = \\big(1 - \\cos(2\\pi \\cdot 1\\, t)\\big)\\cos(2\\pi \\cdot 10\\, t)$。\n- 情况 C（显式多分量混合）：$f_s = 1000$，$T = 2.0$，且 $x(t) = \\cos(2\\pi \\cdot 10\\, t) + 0.8\\cos(2\\pi \\cdot 30\\, t)$。\n- 情况 D（快包络违反慢包络条件）：$f_s = 1000$，$T = 2.0$，且 $x(t) = \\big(1 + 0.9\\cos(2\\pi \\cdot 15\\, t)\\big)\\cos(2\\pi \\cdot 20\\, t)$。\n\n对于每种情况，您的程序必须生成一个包含三个值的列表：$f(t)$ 为负的样本分数（以小数表示），$f(t)$ 无定义的样本分数（以小数表示），以及一个布尔值，指示单分量假设是否失效（true 表示失效）。您的程序应生成一行输出，其中包含所有四种情况的结果，形式为一个逗号分隔的列表，该列表由这些按情况分类的列表组成，并用方括号括起来，例如 `[[r_{A1},r_{A2},r_{A3}],[r_{B1},r_{B2},r_{B3}],[r_{C1},r_{C2},r_{C3}],[r_{D1},r_{D2},r_{D3}]]`，其中每个 $r_{\\cdot}$ 是对应情况的指定输出之一。在整个过程中，角度必须以弧度为单位，频率必须以赫兹为单位。",
            "solution": "目标是分析几个测试信号的瞬时频率（通过希尔伯特变换导出），以确定该频率在何种条件下会变为负值或无定义。我们还将使用傅里叶分析来评估单分量信号假设的有效性。本分析严格遵循所提供的基本定义。\n\n一个实值信号 $x(t)$ 可以与一个唯一的复值信号相关联，这个复值信号称为解析信号 $z(t)$，其虚部是 $x(t)$ 的希尔伯特变换。希尔伯特变换，记作 $\\mathcal{H}\\{x\\}(t)$，其形式定义为 $x(t)$ 与函数 $1/(\\pi t)$ 的卷积：\n$$ \\mathcal{H}\\{x\\}(t) = \\frac{1}{\\pi} \\text{p.v.} \\int_{-\\infty}^{\\infty} \\frac{x(\\tau)}{t - \\tau} d\\tau $$\n其中 p.v. 表示积分的柯西主值。在计算上，在频域中实现希尔伯特变换更高效。如果 $X(f)$ 是 $x(t)$ 的傅里叶变换，那么 $\\mathcal{H}\\{x\\}(t)$ 的傅里叶变换由 $-i \\cdot \\text{sgn}(f) \\cdot X(f)$ 给出，其中 $\\text{sgn}(f)$ 是符号函数。\n\n解析信号 $z(t)$ 定义为：\n$$ z(t) = x(t) + i\\mathcal{H}\\{x\\}(t) $$\n这个复信号用瞬时振幅和相位来表示原始实信号。瞬时振幅 $A(t)$ 是 $z(t)$ 的幅值，瞬时相位 $\\phi(t)$ 是它的辐角：\n$$ A(t) = |z(t)| = \\sqrt{x(t)^2 + (\\mathcal{H}\\{x\\}(t))^2} $$\n$$ \\phi(t) = \\arg(z(t)) = \\text{atan2}(\\mathcal{H}\\{x\\}(t), x(t)) $$\n函数 $\\text{atan2}$ 在所有四个象限中都能正确计算角度。原始相位 $\\phi(t)$ 通常被卷绕在区间 $(-\\pi, \\pi]$ 内。为了获得一个适合微分的连续相位函数，我们必须通过在相位跳变处加减 $2\\pi$ 的整数倍来“解卷绕”它。将这个解卷绕后的相位记为 $\\phi_{\\text{unw}}(t)$。\n\n以赫兹表示的瞬时频率 $f(t)$ 定义为解卷绕瞬时相位的经过缩放的时间导数：\n$$ f(t) = \\frac{1}{2\\pi} \\frac{d\\phi_{\\text{unw}}(t)}{dt} $$\n这个定义提供了对每个时间点相位局部变化率的度量。\n\n对于以速率 $f_s$ 采样的离散信号 $x[n]$，时间步长为 $\\Delta t = 1/f_s$。连续导数使用有限差分法进行近似。对于一个解卷绕相位值序列 $\\phi_{\\text{unw}}[n]$，瞬时频率序列 $f[n]$ 计算如下：\n$$ f[n] \\approx \\frac{1}{2\\pi} \\left( \\frac{\\phi_{\\text{unw}}[n+1] - \\phi_{\\text{unw}}[n-1]}{2\\Delta t} \\right) = \\frac{f_s}{4\\pi} (\\phi_{\\text{unw}}[n+1] - \\phi_{\\text{unw}}[n-1]) $$\n这种中心差分格式由 `numpy.gradient` 高效实现。\n\n仅当信号是“单分量”时，瞬时频率的概念才具有物理意义。单分量信号是指可以明确地表示为 $x(t) = A(t)\\cos(\\theta(t))$ 的信号，其中包络 $A(t)$ 是非负、缓变的，相位 $\\theta(t)$ 是单调递增的。\n\n1.  **无定义频率**：当 $z(t) = 0$ 时，瞬时相位 $\\phi(t)$ 在数学上是无定义的，这当且仅当瞬时振幅 $A(t) = 0$ 时发生。在有限精度的实际情况中，我们检查 $A(t) \\le \\epsilon$（其中 $\\epsilon = 10^{-8}$ 是一个小的阈值）。这种情况出现在例如调幅信号中，其包络穿过零点。\n\n2.  **负频率**：当单分量假设被违反时，可能会出现负的瞬时频率。这发生在多分量信号（两个或多个正弦波的总和）或调幅带宽与载波频率没有充分分离的信号中。后一种情况违反了 Bedrosian 定理的条件，该定理指定了两个函数乘积的希尔伯特变换何时能够清晰地分离。$f(t)$ 的负值表示相位旋转方向的瞬时反转。\n\n3.  **单分量假设测试**：一个真正的单分量信号应该其能量集中在频域中的单个频带内。一个直接的测试是计算信号的傅里叶谱并计算显著峰值的数量。如果发现多于一个显著峰值（忽略直流和非常低的频率），则该信号是多分量的，单分量假设失效。问题指定峰值阈值为最大谱幅值的 $0.6$ 倍。\n\n每个测试用例的算法流程如下：\n1.  对于 $n = 0, \\ldots, N-1$（其中 $N = \\lfloor T \\cdot f_s \\rfloor$），生成离散信号 $x[n]$。\n2.  使用 `scipy.signal.hilbert` 计算离散解析信号 $z[n]$。\n3.  使用 `np.abs`、`np.angle` 和 `np.unwrap` 计算瞬时振幅 $A[n] = |z[n]|$ 和解卷绕的瞬时相位 $\\phi_{\\text{unw}}[n]$。\n4.  对 $\\phi_{\\text{unw}}[n]$ 使用 `np.gradient`，并通过 $f_s/(2\\pi)$ 进行适当缩放，计算瞬时频率 $f[n]$。\n5.  识别 $f[n]$ 无定义的样本（如果 $A[n] \\le \\epsilon$ 或 $f[n]$ 不是有限的）和为负的样本（如果 $f[n] < -\\delta$（容差 $\\delta=10^{-6}$），且不是无定义的）。然后计算它们占总样本数的分数。\n6.  计算 $x[n]$ 的实值离散傅里叶变换的幅值。使用 `scipy.signal.find_peaks` 识别频率大于等于 $1\\,\\mathrm{Hz}$ 且高于最大幅值 $0.6$ 倍的谱峰。如果存在多于一个这样的峰值，则宣告单分量假设失效。\n7.  每种情况的最终结果是一个列表，包含负频率样本的分数、无定义频率样本的分数以及一个指示单分量假设是否失效的布尔值。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import hilbert, find_peaks\nfrom scipy.fft import rfftfreq\n\ndef solve():\n    \"\"\"\n    Analyzes instantaneous frequency and monocomponent assumption for given signals.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (happy path, narrowband monocomponent)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 10 * t),\n            \"name\": \"Case A\"\n        },\n        # Case B (envelope crossing zero)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: (1 - np.cos(2 * np.pi * 1 * t)) * np.cos(2 * np.pi * 10 * t),\n            \"name\": \"Case B\"\n        },\n        # Case C (explicit multi-component mixture)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: np.cos(2 * np.pi * 10 * t) + 0.8 * np.cos(2 * np.pi * 30 * t),\n            \"name\": \"Case C\"\n        },\n        # Case D (fast envelope violating slow-envelope condition)\n        {\n            \"fs\": 1000, \"T\": 2.0,\n            \"signal_func\": lambda t: (1 + 0.9 * np.cos(2 * np.pi * 15 * t)) * np.cos(2 * np.pi * 20 * t),\n            \"name\": \"Case D\"\n        }\n    ]\n\n    results = []\n    \n    # Constants from the problem\n    epsilon = 1e-8\n    delta = 1e-6\n    peak_threshold_ratio = 0.6\n    min_peak_freq = 1.0\n\n    for case in test_cases:\n        fs = case[\"fs\"]\n        T = case[\"T\"]\n        signal_func = case[\"signal_func\"]\n\n        # 1. Construct the signal\n        N = int(T * fs)\n        t = np.arange(N) / fs\n        x = signal_func(t)\n\n        # 2. Compute the analytic signal\n        z = hilbert(x)\n\n        # 3. Compute instantaneous amplitude, phase, and frequency\n        A = np.abs(z)\n        phi = np.angle(z)\n        phi_unwrapped = np.unwrap(phi)\n        \n        # Derivative of phase: d(phi)/dt. \n        # np.gradient computes the difference, which needs to be divided by dt.\n        # dt = 1/fs, so dividing by dt is multiplying by fs.\n        # f = (1/(2*pi)) * d(phi)/dt\n        inst_freq = (np.gradient(phi_unwrapped) * fs) / (2 * np.pi)\n\n        # 4. Identify negative and undefined samples\n        is_undefined = (A = epsilon) | (~np.isfinite(inst_freq))\n        \n        # A sample is negative only if it's not undefined\n        is_negative = (inst_freq  -delta)  (~is_undefined)\n\n        # 5. Quantify fractions\n        frac_negative = np.sum(is_negative) / N\n        frac_undefined = np.sum(is_undefined) / N\n\n        # 6. Assess monocomponent assumption failure\n        # Compute DFT\n        yf = np.abs(np.fft.rfft(x))\n        xf = rfftfreq(N, 1/fs)\n        \n        # Find peaks above the relative threshold\n        peak_height_threshold = np.max(yf) * peak_threshold_ratio\n        peaks_indices, _ = find_peaks(yf, height=peak_height_threshold)\n        \n        # Filter out peaks below the minimum frequency\n        significant_peaks_indices = peaks_indices[xf[peaks_indices] >= min_peak_freq]\n        \n        monocomp_fails = len(significant_peaks_indices) > 1\n\n        results.append([frac_negative, frac_undefined, monocomp_fails])\n\n    # Format the final output string exactly as required\n    case_strings = []\n    for res in results:\n        # Format boolean as 'true' or 'false'\n        formatted_bool = str(res[2]).lower()\n        # Format the list for one case\n        s = f\"[{res[0]},{res[1]},{formatted_bool}]\"\n        case_strings.append(s)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}