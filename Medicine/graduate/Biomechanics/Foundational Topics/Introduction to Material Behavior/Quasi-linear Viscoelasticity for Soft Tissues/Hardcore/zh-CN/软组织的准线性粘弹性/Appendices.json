{
    "hands_on_practices": [
        {
            "introduction": "虽然准线性粘弹性 (QLV) 模型本质上是非线性的，但其时间依赖性部分是通过线性卷积积分来描述的。这为我们运用线性粘弹性理论中的强大工具（如拉普拉斯变换）提供了可能。本练习将引导您运用拉普拉斯变换，在线性化近似下，建立松弛模量 $G(t)$ 和蠕变柔量 $J(t)$ 之间的基本关系，从而加深对粘弹性理论基础的理解 ()。",
            "id": "4201121",
            "problem": "考虑对软生物组织进行的单轴小应变测试，该测试在准线性粘弹性 (QLV) 框架内建模，其中准线性粘弹性 (QLV) 是一种将时间依赖性（通过松弛函数）与应变依赖性（通过弹性响应）分离开的粘弹性本构理论。在线性化设置中，假设适用于小应变的应力-应变关系遵循零初始条件下的玻尔兹曼叠加原理。将松弛函数记为 $G(t)$，蠕变函数记为 $J(t)$，两者都是适用于单轴加载的标量函数。将单边拉普拉斯变换定义为 $\\mathcal{L}\\{f(t)\\}(s) = \\int_{0}^{\\infty} \\exp(-s t) f(t) \\, dt$ (对于 $s>0$)。\n\n从基于历史变量时间导数的卷积的基本线性粘弹性原理出发，具体来说，应力是松弛函数与应变率的因果卷积，应变是蠕变函数与应力率的因果卷积，推导出一个在拉普拉斯域中连接 $\\mathcal{L}\\{G(t)\\}(s)$ 和 $\\mathcal{L}\\{J(t)\\}(s)$ 的代数关系。\n\n然后，考虑一个由瞬时模量 $G_{0}>0$、一个长时分数 $g_{\\infty}$（其中 $0 < g_{\\infty} < 1$）和一个单一的松弛时间常数 $\\tau>0$ 组成的标准线性固体（Zener 模型），其松弛函数由下式给出\n$$\nG(t) = G_{0} \\left[ g_{\\infty} + \\left(1 - g_{\\infty}\\right) \\exp\\!\\left(-\\frac{t}{\\tau}\\right) \\right]\n$$\n求出对应的蠕变柔量 $J(t)$，用 $G_{0}$、$g_{\\infty}$ 和 $\\tau$ 表示。",
            "solution": "### 解题思路\n\n**第1步：在拉普拉斯域中推导 G(t) 和 J(t) 之间的关系**\n\n线性粘弹性理论的本构关系可以通过玻尔兹曼叠加积分来表示。对于零初始条件，应力-应变关系可以写成卷积形式：\n1.  应力作为松弛模量 $G(t)$ 和应变率 $\\dot{\\varepsilon}(t)$ 的卷积：\n    $$\n    \\sigma(t) = \\int_{0}^{t} G(t-\\tau) \\frac{d\\varepsilon(\\tau)}{d\\tau} d\\tau = (G * \\dot{\\varepsilon})(t)\n    $$\n2.  应变作为蠕变柔量 $J(t)$ 和应力率 $\\dot{\\sigma}(t)$ 的卷积：\n    $$\n    \\varepsilon(t) = \\int_{0}^{t} J(t-\\tau) \\frac{d\\sigma(\\tau)}{d\\tau} d\\tau = (J * \\dot{\\sigma})(t)\n    $$\n\n我们将拉普拉斯变换应用于这两个方程。利用拉普拉斯变换的卷积定理 $\\mathcal{L}\\{f*g\\} = \\mathcal{L}\\{f\\}\\mathcal{L}\\{g\\}$ 和导数定理 $\\mathcal{L}\\{\\dot{f}(t)\\} = s\\mathcal{L}\\{f(t)\\} - f(0)$，其中零初始条件意味着 $\\varepsilon(0)=0$ 和 $\\sigma(0)=0$。\n\n对第一个方程进行变换：\n$$\n\\mathcal{L}\\{\\sigma(t)\\} = \\mathcal{L}\\{G(t)\\} \\mathcal{L}\\{\\dot{\\varepsilon}(t)\\}\n$$\n$$\n\\bar{\\sigma}(s) = \\bar{G}(s) \\cdot (s \\bar{\\varepsilon}(s) - \\varepsilon(0)) = s \\bar{G}(s) \\bar{\\varepsilon}(s)\n$$\n\n对第二个方程进行变换：\n$$\n\\mathcal{L}\\{\\varepsilon(t)\\} = \\mathcal{L}\\{J(t)\\} \\mathcal{L}\\{\\dot{\\sigma}(t)\\}\n$$\n$$\n\\bar{\\varepsilon}(s) = \\bar{J}(s) \\cdot (s \\bar{\\sigma}(s) - \\sigma(0)) = s \\bar{J}(s) \\bar{\\sigma}(s)\n$$\n\n现在我们有两个代数方程：\n1.  $\\bar{\\sigma}(s) = s \\bar{G}(s) \\bar{\\varepsilon}(s)$\n2.  $\\bar{\\varepsilon}(s) = s \\bar{J}(s) \\bar{\\sigma}(s)$\n\n将方程 (2) 代入方程 (1)：\n$$\n\\bar{\\sigma}(s) = s \\bar{G}(s) \\left[ s \\bar{J}(s) \\bar{\\sigma}(s) \\right] = s^2 \\bar{G}(s) \\bar{J}(s) \\bar{\\sigma}(s)\n$$\n假设存在非零应力，我们可以消去 $\\bar{\\sigma}(s)$：\n$$\n1 = s^2 \\bar{G}(s) \\bar{J}(s)\n$$\n因此，在拉普拉斯域中的关系是：\n$$\n\\bar{G}(s) \\bar{J}(s) = \\frac{1}{s^2}\n$$\n\n**第2步：计算给定 G(t) 的拉普拉斯变换**\n\n给定的松弛函数是：\n$$\nG(t) = G_{0} \\left[ g_{\\infty} + \\left(1 - g_{\\infty}\\right) e^{-t/\\tau} \\right]\n$$\n我们计算其拉普拉斯变换 $\\bar{G}(s) = \\mathcal{L}\\{G(t)\\}$：\n$$\n\\bar{G}(s) = G_{0} \\left[ g_{\\infty} \\mathcal{L}\\{1\\} + (1 - g_{\\infty}) \\mathcal{L}\\{e^{-t/\\tau}\\} \\right]\n$$\n$$\n\\bar{G}(s) = G_{0} \\left[ \\frac{g_{\\infty}}{s} + \\frac{1 - g_{\\infty}}{s + 1/\\tau} \\right]\n$$\n将方括号内的项合并：\n$$\n\\bar{G}(s) = G_{0} \\left[ \\frac{g_{\\infty}(s + 1/\\tau) + (1 - g_{\\infty})s}{s(s + 1/\\tau)} \\right] = G_{0} \\left[ \\frac{g_{\\infty}s + g_{\\infty}/\\tau + s - g_{\\infty}s}{s(s + 1/\\tau)} \\right]\n$$\n$$\n\\bar{G}(s) = G_{0} \\frac{s + g_{\\infty}/\\tau}{s(s + 1/\\tau)}\n$$\n\n**第3步：求解蠕变柔量 J(t)**\n\n利用第一步中导出的关系求解 $\\bar{J}(s)$：\n$$\n\\bar{J}(s) = \\frac{1}{s^2 \\bar{G}(s)} = \\frac{1}{s^2} \\frac{s(s+1/\\tau)}{G_{0}(s+g_{\\infty}/\\tau)} = \\frac{1}{G_{0}} \\frac{s+1/\\tau}{s(s+g_{\\infty}/\\tau)}\n$$\n为了求逆拉普拉斯变换，我们使用部分分式展开：\n$$\n\\frac{s+1/\\tau}{s(s+g_{\\infty}/\\tau)} = \\frac{A}{s} + \\frac{B}{s+g_{\\infty}/\\tau}\n$$\n解出系数 A 和 B：\n-   $A = \\lim_{s\\to 0} s \\frac{s+1/\\tau}{s(s+g_{\\infty}/\\tau)} = \\frac{1/\\tau}{g_{\\infty}/\\tau} = \\frac{1}{g_{\\infty}}$\n-   $B = \\lim_{s\\to -g_{\\infty}/\\tau} (s+g_{\\infty}/\\tau) \\frac{s+1/\\tau}{s(s+g_{\\infty}/\\tau)} = \\frac{-g_{\\infty}/\\tau + 1/\\tau}{-g_{\\infty}/\\tau} = \\frac{(1-g_{\\infty})/\\tau}{-g_{\\infty}/\\tau} = -\\frac{1-g_{\\infty}}{g_{\\infty}}$\n\n将系数代回：\n$$\n\\bar{J}(s) = \\frac{1}{G_{0}} \\left[ \\frac{1/g_{\\infty}}{s} - \\frac{(1-g_{\\infty})/g_{\\infty}}{s+g_{\\infty}/\\tau} \\right] = \\frac{1}{G_{0}g_{\\infty}} \\left[ \\frac{1}{s} - \\frac{1-g_{\\infty}}{s+g_{\\infty}/\\tau} \\right]\n$$\n现在，我们对 $\\bar{J}(s)$ 进行逆拉普拉斯变换：\n$$\nJ(t) = \\mathcal{L}^{-1}\\{\\bar{J}(s)\\} = \\frac{1}{G_{0}g_{\\infty}} \\left[ \\mathcal{L}^{-1}\\left\\{\\frac{1}{s}\\right\\} - (1-g_{\\infty})\\mathcal{L}^{-1}\\left\\{\\frac{1}{s+g_{\\infty}/\\tau}\\right\\} \\right]\n$$\n$$\nJ(t) = \\frac{1}{G_{0}g_{\\infty}} \\left[ 1 - (1-g_{\\infty}) e^{-(g_{\\infty}/\\tau)t} \\right]\n$$",
            "answer": "$$\n\\boxed{\\frac{1}{G_{0} g_{\\infty}} \\left[ 1 - (1 - g_{\\infty}) \\exp\\left(-\\frac{g_{\\infty} t}{\\tau}\\right) \\right]}\n$$"
        },
        {
            "introduction": "应变与时间依赖性的“可分离性”是 Fung 准线性粘弹性 (QLV) 模型的基石假设。作为一名生物力学研究者，关键技能不仅在于应用模型，更在于懂得如何通过实验验证其核心假设。本练习将引导您思考一个旨在检验可分离性假设的应力松弛实验，通过分析如何对不同应变水平下的数据进行归一化和比较，您将学会如何批判性地评估 QLV 模型是否适用于特定的软组织 ()。",
            "id": "4201072",
            "problem": "一个软组织样本在单轴拉伸下进行测试，该测试方案旨在检验准线性粘弹性（QLV）理论所依据的可分离性假设。可分离性假设假定，历史依赖性由一个应变无关的折减松弛函数 $G(t)$ 捕捉，而应变依赖性则由一个非线性弹性响应 $\\sigma_e(\\varepsilon)$ 捕捉。假设该组织遵循遗传材料的玻尔兹曼叠加原理，并且用于施加阶跃式应变变化的加载斜坡与松弛时间相比足够快，因此该斜坡可被视为瞬时。\n\n一位实验者在几个预应变水平 $\\varepsilon_p$ 下进行了一系列应力松弛试验（每个水平都保持足够长的时间以达到稳定的基线应力），然后在时间 $t=0$ 时施加一个小的、快速的阶跃增量 $\\Delta \\varepsilon$，以产生增量应变 $\\varepsilon(t)=\\varepsilon_p+\\Delta \\varepsilon\\,H(t)$，其中 $H(t)$ 是亥维赛德阶跃函数。对于 $t>0$，增量应力响应被记录为 $\\Delta \\sigma(t) \\equiv \\sigma(t)-\\sigma_{\\text{baseline}}$。实验者在所有预应变水平上保持阶跃幅度相同，即每个试验的 $\\Delta \\varepsilon$ 都是一样的。\n\n哪个选项最能描述一个科学上合理的方案和归一化方法，通过证明曲线 $\\Delta \\sigma(t) / [\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p) \\Delta\\varepsilon]$ 重叠到单一的折减松弛函数 $G(t)$ 上来检验可分离性假设，并指出了需要避免的关键陷阱？\n\nA. 在每个 $\\varepsilon_p$ 下，施加一个相同的小而快速的阶跃 $\\Delta \\varepsilon$ 并记录 $\\Delta \\sigma(t)$。通过在相同预应变下进行的瞬时应力-应变表征（使用非常快的加载斜坡以最小化松弛）独立估计切线弹性模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$。对所有的 $\\varepsilon_p$，绘制 $\\Delta \\sigma(t)/\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 对 $t$ 的图像；如果曲线重合，则重叠后的曲线与 $G(t)$ 成正比，这支持了可分离性假设。阶跃幅度相同意味着重叠后的曲线等于 $\\Delta \\varepsilon\\,G(t)$。避免从慢速斜坡（反映平衡刚度）估计 $\\partial_{\\varepsilon}\\sigma_e$，并确保斜坡足够快，以使记录的响应不被加载过程中的松弛所污染。\n\nB. 在每个 $\\varepsilon_p$ 下，施加阶跃并将总应力 $\\sigma(t)$ 除以瞬时总应力值 $\\sigma(0^{+})$ 作图，而不减去基线。$\\sigma(t)/\\sigma(0^{+})$ 重叠到单一曲线上证明了可分离性，并且不需要独立估计 $\\partial_{\\varepsilon}\\sigma_e$。从慢速斜坡估计刚度是可接受的，因为该比率消除了误差。\n\nC. 在每个 $\\varepsilon_p$ 下，以任何方便的幅度施加阶跃（不同试验的幅度可以不同）。用从准静态试验中评估出的割线模量 $\\sigma_e(\\varepsilon_p)/\\varepsilon_p$ 对松弛曲线进行归一化；$\\Delta \\sigma(t)/(\\sigma_e(\\varepsilon_p)/\\varepsilon_p)$ 的重叠证明了可分离性，因为割线模量捕捉了 $\\sigma_e(\\varepsilon)$ 的应变依赖性。\n\nD. 在每个 $\\varepsilon_p$ 下，施加阶跃并用 $\\partial_{\\varepsilon}\\sigma_e(0)$（即在零应变下评估的切线模量，这是一个材料常数）对 $\\Delta \\sigma(t)$ 进行归一化。如果归一化后的曲线重叠，则可分离性成立；如果它们不重叠，则 $\\sigma_e(\\varepsilon)$ 中的非线性是可忽略的，并且在测试可分离性时可以忽略。确保加载斜坡足够慢以避免惯性伪影，即使在斜坡期间发生松弛。",
            "solution": "### 从第一性原理推导\n\n由 Fung 提出的通用一维 QLV 本构律形式是一个遗传积分：\n$$ \\sigma(t) = \\int_{-\\infty}^{t} G(t-\\tau) \\frac{d\\sigma_e(\\varepsilon(\\tau))}{d\\tau} d\\tau $$\n其中 $\\sigma(t)$ 是时间 $t$ 的应力，$G(t)$ 是折减松弛函数（归一化使得 $G(0)=1$），$\\sigma_e(\\varepsilon)$ 是瞬时弹性响应（应变 $\\varepsilon$ 的函数），$\\tau$ 是积分的时间变量。\n\n使用链式法则，积分内的导数可以表示为：\n$$ \\frac{d\\sigma_e(\\varepsilon(\\tau))}{d\\tau} = \\frac{d\\sigma_e}{d\\varepsilon} \\frac{d\\varepsilon}{d\\tau} = \\partial_{\\varepsilon}\\sigma_e(\\varepsilon(\\tau)) \\dot{\\varepsilon}(\\tau) $$\n这里，$\\partial_{\\varepsilon}\\sigma_e$ 是瞬时切线弹性模量，通常是应变的函数。\n\n该问题描述了一个实验，其中一个小阶跃应变 $\\Delta\\varepsilon$ 叠加在一个静态预应变 $\\varepsilon_p$ 上。总应变历史为 $\\varepsilon(t) = \\varepsilon_p + \\Delta\\varepsilon H(t)$。对于此分析，我们假设组织已在 $\\varepsilon_p$ 下保持了足够长的时间以达到具有基线应力 $\\sigma_{\\text{baseline}}$ 的平衡状态。扰动 $\\Delta\\varepsilon$ 在 $t=0$ 时施加。\n\n我们感兴趣的是对于 $t > 0$ 的增量应力响应 $\\Delta\\sigma(t) = \\sigma(t) - \\sigma_{\\text{baseline}}$。由于扰动 $\\Delta\\varepsilon$ 很小，我们可以在预应变 $\\varepsilon_p$ 周围对弹性响应的变化进行线性化。由小阶跃引起的应力贡献被加到预先存在的基线应力上。\n\n与阶跃对应的应变率为 $\\dot{\\varepsilon}(t) = \\Delta\\varepsilon \\, \\delta(t)$，其中 $\\delta(t)$ 是狄拉克δ函数。这个脉冲发生在 $t=0$。在脉冲发生的瞬间，应变水平从 $\\varepsilon_p$ 变为 $\\varepsilon_p + \\Delta\\varepsilon$。对于小阶跃，切线模量可以在预应变水平 $\\varepsilon_p$ 处进行评估。\n\n增量应力 $\\Delta\\sigma(t)$ 是对应变脉冲的响应。我们可以从叠加积分中写出它。对于 $t>0$：\n$$ \\Delta\\sigma(t) = \\int_{0^{-}}^{t} G(t-\\tau) \\partial_{\\varepsilon}\\sigma_e(\\varepsilon(\\tau)) \\dot{\\varepsilon}(\\tau) d\\tau $$\n代入 $\\dot{\\varepsilon}(\\tau) = \\Delta\\varepsilon \\, \\delta(\\tau)$:\n$$ \\Delta\\sigma(t) = \\int_{0^{-}}^{t} G(t-\\tau) \\partial_{\\varepsilon}\\sigma_e(\\varepsilon(\\tau)) [\\Delta\\varepsilon \\, \\delta(\\tau)] d\\tau $$\n项 $\\partial_{\\varepsilon}\\sigma_e$ 在脉冲发生的应变水平处评估。由于 $\\Delta\\varepsilon$ 很小，我们可以近似认为在 $\\tau=0$ 的脉冲期间 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon(\\tau)) \\approx \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$。此项相对于积分变量 $\\tau$ 是常数，可以提到积分外：\n$$ \\Delta\\sigma(t) \\approx \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p) \\Delta\\varepsilon \\int_{0^{-}}^{t} G(t-\\tau) \\delta(\\tau) d\\tau $$\n使用狄拉克δ函数的筛选性质，积分结果为 $G(t)$。因此，增量应力响应为：\n$$ \\Delta\\sigma(t) \\approx [\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p) \\Delta\\varepsilon] G(t) $$\n这是 QLV 理论对该实验的核心预测。它表明增量应力松弛曲线 $\\Delta\\sigma(t)$ 的形状由折减松弛函数 $G(t)$ 给出，其幅度由预应变下的瞬时切线模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 和阶跃大小 $\\Delta\\varepsilon$ 的乘积决定。\n\n为了检验可分离性假设，必须验证函数 $G(t)$ 是否确实与应变水平 $\\varepsilon_p$ 无关。我们可以重新排列方程以求解 $G(t)$:\n$$ G(t) \\approx \\frac{\\Delta\\sigma(t)}{\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p) \\Delta\\varepsilon} $$\n实验方案包括在几个不同的预应变水平 $\\varepsilon_p$ 下进行此测试，同时保持 $\\Delta\\varepsilon$ 不变。如果可分离性成立，那么对于在预应变 $\\varepsilon_{p,i}$ 下进行的每个试验 $i$，计算出的函数 $G_i(t)$ 应该是相同的。因此，将所有试验的归一化量 $\\Delta\\sigma(t) / \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 对时间作图，应导致所有曲线重叠成一条主曲线。由于 $\\Delta\\varepsilon$ 在所有试验中都是一个常数因子，它不影响重叠。得到的主曲线将等于 $\\Delta\\varepsilon \\, G(t)$。\n\n这证实了一个有效的检验需要：\n1.  测量增量应力松弛 $\\Delta\\sigma(t)$。\n2.  在每个预应变水平下独立测量瞬时切线模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$。这需要非常快的加载以最小化测量期间的粘性松弛。\n3.  用 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 对 $\\Delta\\sigma(t)$ 进行归一化。\n\n### 逐项分析\n\n**A. 在每个 $\\varepsilon_p$ 下，施加一个相同的小而快速的阶跃 $\\Delta \\varepsilon$ 并记录 $\\Delta \\sigma(t)$。通过在相同预应变下进行的瞬时应力-应变表征（使用非常快的加载斜坡以最小化松弛）独立估计切线弹性模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$。对所有的 $\\varepsilon_p$，绘制 $\\Delta \\sigma(t)/\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 对 $t$ 的图像；如果曲线重合，则重叠后的曲线与 $G(t)$ 成正比，这支持了可分离性假设。阶跃幅度相同意味着重叠后的曲线等于 $\\Delta \\varepsilon\\,G(t)$。避免从慢速斜坡（反映平衡刚度）估计 $\\partial_{\\varepsilon}\\sigma_e$，并确保斜坡足够快，以使记录的响应不被加载过程中的松弛所污染。**\n\n该选项精确匹配从第一性原理推导出的过程。它正确地指出了(1)需要测量 $\\Delta\\sigma(t)$，(2)正确的归一化因子是瞬时切线模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$，(3)测量该模量的正确方法（快速斜坡），(4)对重叠曲线与 $G(t)$ 成正比的正确解释，以及(5)使用平衡属性或慢速斜坡的关键陷阱。\n**结论：正确**\n\n**B. 在每个 $\\varepsilon_p$ 下，施加阶跃并将总应力 $\\sigma(t)$ 除以瞬时总应力值 $\\sigma(0^{+})$ 作图，而不减去基线。$\\sigma(t)/\\sigma(0^{+})$ 重叠到单一曲线上证明了可分离性，并且不需要独立估计 $\\partial_{\\varepsilon}\\sigma_e$。从慢速斜坡估计刚度是可接受的，因为该比率消除了误差。**\n\n该选项是有缺陷的。建议的归一化是 $\\sigma(t)/\\sigma(0^+)$。让我们分析这个比率：\n$\\sigma(t) = \\sigma_{\\text{baseline}} + \\Delta\\sigma(t) = G(\\infty)\\sigma_e(\\varepsilon_p) + \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)\\Delta\\varepsilon G(t)$。\n$\\sigma(0^+) = \\sigma_{\\text{baseline}} + \\Delta\\sigma(0^+) = G(\\infty)\\sigma_e(\\varepsilon_p) + \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)\\Delta\\varepsilon G(0) = G(\\infty)\\sigma_e(\\varepsilon_p) + \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)\\Delta\\varepsilon$。\n该比率为：\n$$ \\frac{\\sigma(t)}{\\sigma(0^+)} = \\frac{G(\\infty)\\sigma_e(\\varepsilon_p) + \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)\\Delta\\varepsilon G(t)}{G(\\infty)\\sigma_e(\\varepsilon_p) + \\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)\\Delta\\varepsilon} $$\n对于一般的非线性弹性函数 $\\sigma_e(\\varepsilon)$，这个表达式通过 $\\sigma_e(\\varepsilon_p)$ 和 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$ 两项依赖于 $\\varepsilon_p$。该比率不会独立于 $\\varepsilon_p$。因此，曲线不会重叠。声称这证明了可分离性是错误的。此外，声称从慢速斜坡估计刚度是可接受的，这在根本上是不正确的。\n**结论：不正确**\n\n**C. 在每个 $\\varepsilon_p$ 下，以任何方便的幅度施加阶跃（不同试验的幅度可以不同）。用从准静态试验中评估出的割线模量 $\\sigma_e(\\varepsilon_p)/\\varepsilon_p$ 对松弛曲线进行归一化；$\\Delta \\sigma(t)/(\\sigma_e(\\varepsilon_p)/\\varepsilon_p)$ 的重叠证明了可分离性，因为割线模量捕捉了 $\\sigma_e(\\varepsilon)$ 的应变依赖性。**\n\n该选项有多个错误。首先，增量响应的正确模量是切线模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$，而不是割线模量 $\\sigma_e(\\varepsilon_p)/\\varepsilon_p$。其次，它建议从准静态试验中评估模量。这将得到平衡模量，而不是所需的瞬时模量 $\\sigma_e$。使用不同的幅度 $\\Delta\\varepsilon$ 还需要用 $\\Delta\\varepsilon$ 进行归一化，这一点没有提及。建议的归一化方案在物理上是不正确的。\n**结论：不正确**\n\n**D. 在每个 $\\varepsilon_p$ 下，施加阶跃并用 $\\partial_{\\varepsilon}\\sigma_e(0)$（即在零应变下评估的切线模量，这是一个材料常数）对 $\\Delta \\sigma(t)$ 进行归一化。如果归一化后的曲线重叠，则可分离性成立；如果它们不重叠，则 $\\sigma_e(\\varepsilon)$ 中的非线性是可忽略的，并且在测试可分离性时可以忽略。确保加载斜坡足够慢以避免惯性伪影，即使在斜坡期间发生松弛。**\n\n该选项不正确。归一化因子必须是应变依赖的切线模量 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)$，以解释每个预应变下变化的刚度。用一个常数 $\\partial_{\\varepsilon}\\sigma_e(0)$ 进行归一化，将得到幅度按 $\\partial_{\\varepsilon}\\sigma_e(\\varepsilon_p)/\\partial_{\\varepsilon}\\sigma_e(0)$ 缩放的曲线，这是 $\\varepsilon_p$ 的函数。因此，如果 $\\sigma_e$ 是非线性的，曲线将不会重叠。随后的逻辑陈述也是有缺陷和颠倒的：不重叠将*证明*非线性是显著的，而不是可忽略的。最关键的是，使用慢速斜坡的建议与测试的要求直接对立，因为它会将松弛与弹性响应混为一谈，使得无法将 $G(t)$ 与 $\\sigma_e(\\varepsilon)$ 分开。\n**结论：不正确**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "QLV 模型为从已知的应变历史计算应力响应提供了直接的路径，但其逆问题——从给定的应力历史（例如蠕变）计算应变历史——由于其固有的非线性而要困难得多。这项高级练习将直面这一实际挑战。您将首先理解为何蠕变问题难以获得解析解，然后构建一个数值算法来求解相应的 Volterra 积分方程，这是模拟真实组织行为时一项至关重要的计算技能 ()。",
            "id": "4201082",
            "problem": "考虑由冯元桢 (Yuan-Cheng Fung) 最初引入的准线性粘弹性（QLV）模型所描述的软组织，其应力响应由一个包含可分离的含时折减松弛函数的遗传积分描述。设应变历史表示为 $\\,\\varepsilon(t)\\,$，柯西应力表示为 $\\,\\sigma(t)\\,$。QLV 假设指出，粘弹性应力可以表示为折减松弛函数 $\\,G(t)\\,$ 与瞬时弹性应力响应 $\\,\\sigma^{e}(\\varepsilon)\\,$ 的时间变化率的卷积，即\n$$\n\\sigma(t) \\;=\\; \\int_{0}^{t} G(t-\\tau)\\,\\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau}\\,d\\tau,\n$$\n其中根据折减松弛函数的定义，有 $\\,G(0)=1\\,$。假设瞬时弹性响应 $\\,\\sigma^{e}(\\varepsilon)\\,$ 是 $\\,\\varepsilon\\,$ 的一个单调可微函数。\n\n任务1（解释与推导）：从上述遗传积分所体现的第一性原理和准线性粘弹性（QLV）的可分离性假设出发，解释为什么在恒定应力 $\\,\\sigma(t)=\\sigma_{0}\\,$ 条件下获得蠕变函数并非易事。你的解释应阐明，恒定应力条件不能直接得出 $\\,\\varepsilon(t)\\,$，因为遗传关系式是以复合函数 $\\,\\sigma^{e}(\\varepsilon(t))\\,$ 的形式定义 $\\,\\sigma(t)\\,$ 的，这导致了一个关于 $\\,\\varepsilon(t)\\,$ 的隐式非线性 Volterra 积分方程。然后，提出一个完整的数值方案，通过乘积积分离散化方法对遗传关系式进行时间上的迭代反演来计算蠕变，该方法在每个时间步长分离出未知量 $\\,\\sigma^{e}(\\varepsilon_{n})\\,$，随后对 $\\,\\sigma^{e}\\,$ 进行数值反演以恢复 $\\,\\varepsilon_{n}\\,$。使用右端点法则，以便 $\\,G(0)\\,$ 乘以 $\\,\\sigma^{e}\\,$ 的最新增量。\n\n任务2（算法详述）：将时间区间 $[0,T]$ 用均匀时间步长 $\\,\\Delta t\\,$ 和网格点 $\\,t_{n}=n\\Delta t\\,$（其中 $\\,n=0,1,\\dots,N\\,$）进行离散化。令 $\\,\\Delta \\sigma_{k}^{e}=\\sigma^{e}(\\varepsilon_{k})-\\sigma^{e}(\\varepsilon_{k-1})\\,$。证明右端点乘积积分法可得出离散遗传关系式\n$$\n\\sigma_{n} \\;\\approx\\; \\sum_{k=1}^{n} G(t_{n}-t_{k})\\,\\Delta \\sigma_{k}^{e},\n$$\n并利用在 $\\,t=0^{+}\\,$ 施加的恒定应力阶跃下的蠕变条件 $\\,\\sigma_{n}=\\sigma_{0}\\,$，推导出显式递推公式\n$$\n\\sigma^{e}(\\varepsilon_{n}) \\;=\\; \\sigma^{e}(\\varepsilon_{n-1}) \\;+\\; \\sigma_{0} \\;-\\; \\sum_{k=1}^{n-1} G(t_{n}-t_{k})\\,\\big(\\sigma^{e}(\\varepsilon_{k})-\\sigma^{e}(\\varepsilon_{k-1})\\big),\n$$\n其中对 $\\,k=n\\,$ 的项使用 $\\,G(0)=1\\,$。指定一个稳健的数值求根方法，在每个时间步中反演 $\\,\\sigma^{e}(\\varepsilon)\\,$，从递推式提供的目标值 $\\,\\sigma^{e}(\\varepsilon_{n})\\,$ 中求得 $\\,\\varepsilon_{n}\\,$。你的数值方法必须确保对正应变具有单调收敛性（例如，在 $[0,\\infty)$ 上使用带自适应区间的二分法），并且必须是完全可实现的。\n\n任务3（使用物理一致参数的实现）：实现该数值方案，为以下材料模型和折减松弛函数计算蠕变应变历史。瞬时弹性应力响应是非线性弹性的，\n$$\n\\sigma^{e}(\\varepsilon) \\;=\\; E_{0}\\,\\varepsilon\\,e^{\\alpha \\varepsilon},\n$$\n其中 $\\,E_{0}>0\\,$ 且 $\\,\\alpha>0\\,$。折减松弛函数是一个 Prony 级数，\n$$\nG(t) \\;=\\; g_{\\infty} \\;+\\; \\sum_{i=1}^{m} g_{i}\\,e^{-t/\\tau_{i}},\n$$\n其中 $\\,g_{\\infty}+\\sum_{i=1}^{m}g_{i}=1\\,$，$\\,g_{i}\\ge 0\\,$，特征时间 $\\,\\tau_{i}>0\\,$。时间单位为秒，应力单位为帕斯卡，应变为无量纲。你必须计算在 $\\,t=0^{+}\\,$ 时施加恒定应力 $\\,\\sigma(t)=\\sigma_{0}\\,$ 的蠕变应变历史 $\\,\\varepsilon(t)\\,$。\n\n测试套件：对于下方的每组参数，计算在指定的最终时间 $\\,T\\,$ 时的最终蠕变应变 $\\,\\varepsilon(T)\\,$。所有应力单位为帕斯卡（Pa），时间单位为秒（s），应变为无量纲。使用给定的均匀时间步长 $\\,\\Delta t\\,$。\n\n- 情况 A（一般情况）：$\\,\\sigma_{0}=5000\\,$, $\\,E_{0}=10000\\,$, $\\,\\alpha=3.0\\,$, $\\,g_{\\infty}=0.2\\,$, Prony 级数项 $\\,[(\\tau_{1},g_{1})=(0.5,0.5),(\\tau_{2},g_{2})=(5.0,0.3)]\\,$, $\\,T=20.0\\,$, $\\,\\Delta t=0.1\\,$.\n- 情况 B（近零应力边界）：$\\,\\sigma_{0}=1.0\\,$, $\\,E_{0}=10000\\,$, $\\,\\alpha=3.0\\,$, $\\,g_{\\infty}=0.2\\,$, Prony 级数项 $\\,[(0.5,0.5),(5.0,0.3)]\\,$, $\\,T=10.0\\,$, $\\,\\Delta t=0.1\\,$.\n- 情况 C（高应力边界）：$\\,\\sigma_{0}=50000\\,$, $\\,E_{0}=10000\\,$, $\\,\\alpha=3.0\\,$, $\\,g_{\\infty}=0.2\\,$, Prony 级数项 $\\,[(0.5,0.5),(5.0,0.3)]\\,$, $\\,T=20.0\\,$, $\\,\\Delta t=0.05\\,$.\n- 情况 D（慢松弛边界）：$\\,\\sigma_{0}=10000\\,$, $\\,E_{0}=10000\\,$, $\\,\\alpha=2.0\\,$, $\\,g_{\\infty}=0.1\\,$, Prony 级数项 $\\,[(100.0,0.9)]\\,$, $\\,T=100.0\\,$, $\\,\\Delta t=0.5\\,$.\n\n程序要求：实现该方案并计算每种情况下的 $\\,\\varepsilon(T)\\,$。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序为 $[\\,\\varepsilon_{A}(T),\\varepsilon_{B}(T),\\varepsilon_{C}(T),\\varepsilon_{D}(T)\\,]$。最终应变 $\\,\\varepsilon_{A}(T),\\varepsilon_{B}(T),\\varepsilon_{C}(T),\\varepsilon_{D}(T)\\,$ 必须以浮点数（无量纲）形式输出。不应打印任何其他文本。",
            "solution": "由 Fung 建立的准线性粘弹性（QLV）模型是软组织生物力学领域的基石。本回答按要求分三部分来解决所提问题：解释计算蠕变响应的理论挑战，详述一种数值算法，及其实现。\n\n### 任务1：计算蠕变的挑战之解释\n\n一维 QLV 材料的本构关系由以下遗传积分给出：\n$$\n\\sigma(t) = \\int_{0}^{t} G(t-\\tau) \\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau} d\\tau\n$$\n其中 $\\sigma(t)$ 是柯西应力，$\\varepsilon(t)$ 是应变，$G(t)$ 是折减松弛函数且 $G(0)=1$，$\\sigma^{e}(\\varepsilon)$ 是与时间无关的（瞬时）弹性应力响应，对于大多数软组织而言，它是应变的非线性函数。\n\n蠕变测试包括对一个先前无应力无应变的样本施加恒定应力 $\\sigma(t) = \\sigma_{0}$（当 $t>0$ 时），并测量由此产生的应变历史 $\\varepsilon(t)$。将蠕变条件代入 QLV 积分可得：\n$$\n\\sigma_{0} = \\int_{0}^{t} G(t-\\tau) \\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau} d\\tau, \\quad \\text{for } t>0\n$$\n该方程是关于未知函数 $f(t) = \\frac{d\\sigma^{e}(\\varepsilon(t))}{dt}$ 的第一类 Volterra 积分方程。获得应变 $\\varepsilon(t)$ 并非易事，原因有几点：\n\n1.  **隐式和非线性性质**：未知函数 $\\varepsilon(t)$ 嵌入在非线性函数 $\\sigma^{e}(\\varepsilon)$ 之中，该函数随后被微分和积分。该方程未提供 $\\varepsilon(t)$ 的直接表达式。相反，它通过一个复杂的积分关系隐式地定义了 $\\varepsilon(t)$。\n2.  **关于导数的积分方程**：积分中的直接未知量不是 $\\varepsilon(t)$，而是弹性应力的变化率 $\\frac{d\\sigma^{e}}{d\\tau}$。为了求得 $\\varepsilon(t)$，需要首先解此积分方程以得到 $\\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau}$，然后将结果对时间积分以求得 $\\sigma^{e}(\\varepsilon(t))$，最后反演非线性函数 $\\sigma^{e}$ 以解出 $\\varepsilon(t)$。这些步骤中的每一步都非同小可。\n3.  **需要数值反演**：在线性粘弹性中，蠕变柔量 $J(t)$ 通常可以从松弛模量通过解析方法或拉普拉斯变换求得，但 QLV 模型中 $\\sigma^{e}(\\varepsilon)$ 的非线性特性阻止了此类直接方法的使用。定义 QLV 的时间与应变效应的可分离性，在蠕变测试中并不能简化为应变的可分离解。\n\n由于这些解析上的困难，需要采用数值方法。一种稳健的方法是将积分在时间上离散化，并逐步求解未知应变。我们提出一个乘积积分方案。将时间区间 $[0, T]$ 离散为 $N$ 个大小为 $\\Delta t$ 的步长，其中 $t_n = n\\Delta t$。积分被近似为在这些时间步上的总和。通过在每个子区间 $[t_{k-1}, t_k]$ 的右端点计算核函数 $G(t_n-\\tau)$，我们可以分离出最新的未知弹性应力增量 $\\sigma^{e}(\\varepsilon_n) - \\sigma^{e}(\\varepsilon_{n-1})$，从而实现迭代求解。这将在下一节中详细介绍。\n\n### 任务2：数值方案与算法详述\n\n我们将时域离散为 $t_n = n\\Delta t$，其中 $n=0, 1, \\dots, N$。令 $\\varepsilon_k = \\varepsilon(t_k)$ 且 $\\sigma_n = \\sigma(t_n)$。在时间 $t_n$ 的遗传积分为：\n$$\n\\sigma_n = \\int_{0}^{t_n} G(t_n-\\tau) \\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau} d\\tau = \\sum_{k=1}^{n} \\int_{t_{k-1}}^{t_k} G(t_n-\\tau) \\frac{d\\sigma^{e}(\\varepsilon(\\tau))}{d\\tau} d\\tau\n$$\n使用乘积右端点法则，我们通过在右端点 $\\tau=t_k$ 处计算相对平滑的函数 $G(t_n-\\tau)$ 的值，来近似每个子区间 $[t_{k-1}, t_k]$ 上的积分：\n$$\n\\int_{t_{k-1}}^{t_k} G(t_n-\\tau) \\frac{d\\sigma^{e}}{d\\tau} d\\tau \\approx G(t_n-t_k) \\int_{t_{k-1}}^{t_k} \\frac{d\\sigma^{e}}{d\\tau} d\\tau = G(t_n-t_k) \\left[ \\sigma^{e}(\\varepsilon_k) - \\sigma^{e}(\\varepsilon_{k-1}) \\right]\n$$\n令 $\\Delta \\sigma_{k}^{e} = \\sigma^{e}(\\varepsilon_{k}) - \\sigma^{e}(\\varepsilon_{k-1})$，遗传关系的离散形式变为：\n$$\n\\sigma_n \\approx \\sum_{k=1}^{n} G(t_n-t_k) \\Delta \\sigma_{k}^{e}\n$$\n对于蠕变测试，当 $n \\ge 1$ 时 $\\sigma_n = \\sigma_0$。在 $t_0=0$ 时的初始条件为 $\\varepsilon_0=0$，因此 $\\sigma^{e}(\\varepsilon_0)=0$。代入蠕变条件并将求和的最后一项（$k=n$）分离出来，可得：\n$$\n\\sigma_0 = G(t_n-t_n)\\Delta \\sigma_{n}^{e} + \\sum_{k=1}^{n-1} G(t_n-t_k) \\Delta \\sigma_{k}^{e}\n$$\n使用 $G(0) = 1$ 并展开 $\\Delta \\sigma_{n}^{e} = \\sigma^{e}(\\varepsilon_{n}) - \\sigma^{e}(\\varepsilon_{n-1})$，我们得到：\n$$\n\\sigma_0 = \\left[ \\sigma^{e}(\\varepsilon_{n}) - \\sigma^{e}(\\varepsilon_{n-1}) \\right] + \\sum_{k=1}^{n-1} G(t_n-t_k) \\left( \\sigma^{e}(\\varepsilon_{k}) - \\sigma^{e}(\\varepsilon_{k-1}) \\right)\n$$\n重排此方程以求解当前时间步的未知弹性应力 $\\sigma^{e}(\\varepsilon_{n})$，可得到以下显式递推式：\n$$\n\\sigma^{e}(\\varepsilon_{n}) = \\sigma^{e}(\\varepsilon_{n-1}) + \\sigma_{0} - \\sum_{k=1}^{n-1} G(t_{n}-t_{k})\\left(\\sigma^{e}(\\varepsilon_{k}) - \\sigma^{e}(\\varepsilon_{k-1})\\right)\n$$\n在每个时间步 $n$，右侧完全由施加的应力 $\\sigma_0$ 和直到第 $n-1$ 步的弹性应力历史决定。设右侧的目标值为 $\\sigma^{e}_{\\text{target}}$。我们必须求解非线性代数方程\n$$\n\\sigma^{e}(\\varepsilon_{n}) = \\sigma^{e}_{\\text{target}}\n$$\n以求得未知应变 $\\varepsilon_{n}$。对于指定形式 $\\sigma^e(\\varepsilon) = E_0 \\varepsilon e^{\\alpha\\varepsilon}$ 且 $E_0, \\alpha > 0$，该函数在 $\\varepsilon \\ge 0$ 时是严格单调的。这保证了对于任何正的 $\\sigma^{e}_{\\text{target}}$ 都存在唯一的正根。\n\n一个求解此根的稳健数值方法是**二分法**。要应用此方法，我们需要找到一个包含根的区间 $[a, b]$。\n1.  定义要求解其零点的函数：$f(\\varepsilon) = \\sigma^e(\\varepsilon) - \\sigma^{e}_{\\text{target}}$。\n2.  搜索区间的下界是 $a=0$。由于在蠕变测试中 $\\sigma^e(0)=0$ 且 $\\sigma^{e}_{\\text{target}}>0$，所以 $f(0) = -\\sigma^{e}_{\\text{target}}  0$。\n3.  必须找到一个上界 $b$ 使得 $f(b)  0$。我们可以使用自适应搜索：从一个初始猜测开始，例如 $b=0.1$。如果 $f(b) \\le 0$，则重复将 $b$ 加倍，直到 $f(b)  0$。鉴于 $\\sigma^e(\\varepsilon)$ 的指数增长特性，此搜索保证能快速终止。\n4.  当根被限定在 $[a,b]$ 区间内后，即可应用二分算法在指定公差范围内收敛到 $\\varepsilon_n$。\n\n递推式中的求和项如果每一步都直接计算，将导致一个 $O(N^2)$ 算法。对于 Prony 级数形式的 $G(t)$，可以通过使用递推更新方案将此计算优化到 $O(N)$。该求和项可以写为：\n$$\n\\sum_{k=1}^{n-1} G(t_n-t_k) \\Delta \\sigma_{k}^{e} = g_{\\infty}\\sigma^{e}(\\varepsilon_{n-1}) + \\sum_{i=1}^{m} g_i \\sum_{k=1}^{n-1} e^{-(n-k)\\Delta t/\\tau_i} \\Delta \\sigma_{k}^{e}\n$$\n内部的和可以与历史变量 $H_{n,i} = \\sum_{k=1}^{n} e^{-(n-k)\\Delta t/\\tau_i} \\Delta \\sigma_{k}^{e}$ 相关联，这些变量可以递推更新：\n$$\nH_{n,i} = \\Delta\\sigma_n^e + e^{-\\Delta t/\\tau_i} H_{n-1,i}\n$$\n这使得每一步中历史项的计算成为一个 $O(m)$ 操作，其中 $m$ 是 Prony 级数的项数，从而得到一个整体的 $O(Nm)$ 算法。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import bisect\n\ndef solve():\n    \"\"\"\n    Main function to solve the QLV creep problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"sigma0\": 5000.0,\n            \"E0\": 10000.0,\n            \"alpha\": 3.0,\n            \"g_inf\": 0.2,\n            \"prony\": [(0.5, 0.5), (5.0, 0.3)],\n            \"T\": 20.0,\n            \"dt\": 0.1,\n        },\n        {\n            \"name\": \"Case B\",\n            \"sigma0\": 1.0,\n            \"E0\": 10000.0,\n            \"alpha\": 3.0,\n            \"g_inf\": 0.2,\n            \"prony\": [(0.5, 0.5), (5.0, 0.3)],\n            \"T\": 10.0,\n            \"dt\": 0.1,\n        },\n        {\n            \"name\": \"Case C\",\n            \"sigma0\": 50000.0,\n            \"E0\": 10000.0,\n            \"alpha\": 3.0,\n            \"g_inf\": 0.2,\n            \"prony\": [(0.5, 0.5), (5.0, 0.3)],\n            \"T\": 20.0,\n            \"dt\": 0.05,\n        },\n        {\n            \"name\": \"Case D\",\n            \"sigma0\": 10000.0,\n            \"E0\": 10000.0,\n            \"alpha\": 2.0,\n            \"g_inf\": 0.1,\n            \"prony\": [(100.0, 0.9)],\n            \"T\": 100.0,\n            \"dt\": 0.5,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        final_strain = compute_creep_strain(**case)\n        results.append(final_strain)\n    \n    # Format the final output as a comma-separated list in brackets.\n    output_str = \"[\" + \",\".join(f\"{res:.8f}\" for res in results) + \"]\"\n    print(output_str)\n\n\ndef compute_creep_strain(name, sigma0, E0, alpha, g_inf, prony, T, dt, **kwargs):\n    \"\"\"\n    Computes the creep strain history using a recursive time-stepping scheme.\n    \"\"\"\n    \n    # Unpack Prony series parameters\n    taus = np.array([p[0] for p in prony])\n    gs = np.array([p[1] for p in prony])\n    num_prony_terms = len(prony)\n\n    # Time integration parameters\n    num_steps = int(round(T / dt))\n    \n    # Pre-compute exponential decay factors for the recursive update\n    exp_decay_factors = np.exp(-dt / taus) if num_prony_terms > 0 else np.array([])\n    \n    # History variables (H_i) for the recursive update scheme\n    history_vars = np.zeros(num_prony_terms)\n\n    # Initial conditions\n    sigma_e_prev = 0.0\n    eps_final = 0.0\n\n    # Instantaneous elastic stress function\n    def sigma_e_func(eps):\n        return E0 * eps * np.exp(alpha * eps)\n\n    # Time-stepping loop\n    for n in range(1, num_steps + 1):\n        # Calculate the convolution sum S_n using the recursive update formulation.\n        # S_n = g_inf * sigma_e_{n-1} + sum_i g_i * exp(-dt/tau_i) * H_{n-1,i}\n        if num_prony_terms > 0:\n            sum_hist = g_inf * sigma_e_prev + np.sum(gs * exp_decay_factors * history_vars)\n        else:\n            sum_hist = g_inf * sigma_e_prev\n        \n        # Calculate the target elastic stress for the current step\n        sigma_e_target = sigma_e_prev + sigma0 - sum_hist\n        \n        # Define the function for the root-finder\n        f_root = lambda eps: sigma_e_func(eps) - sigma_e_target\n        \n        # Find the strain by inverting the nonlinear elastic stress-strain relation\n        # Bracket the root adaptively to ensure convergence\n        lower_bound, upper_bound = 0.0, 0.1\n        try:\n            # Since f(0) is negative, find an upper_bound where f(upper_bound) is positive\n            while f_root(upper_bound)  0:\n                upper_bound *= 2.0\n            eps_n = bisect(f_root, lower_bound, upper_bound, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # Fallback for difficult cases or very large strains\n            upper_bound = 0.1\n            while f_root(upper_bound)  0:\n                upper_bound *= 10.0\n                if upper_bound > 1e10: # Safety break\n                    raise RuntimeError(\"Root finding failed to find an upper bound.\")\n            eps_n = bisect(f_root, lower_bound, upper_bound, xtol=1e-12, rtol=1e-12)\n\n        # Update state variables for the next step\n        sigma_e_curr = sigma_e_target\n        delta_sigma_e = sigma_e_curr - sigma_e_prev\n        \n        # Update history variables using the recursive formula: H_n = H_{n-1}*exp(-dt/tau) + delta_sigma_e_n\n        if num_prony_terms > 0:\n            history_vars = exp_decay_factors * history_vars + delta_sigma_e\n        \n        sigma_e_prev = sigma_e_curr\n        eps_final = eps_n\n\n    return eps_final\n\n# Execute the solver function\n# This block will be executed when the script is run.\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}