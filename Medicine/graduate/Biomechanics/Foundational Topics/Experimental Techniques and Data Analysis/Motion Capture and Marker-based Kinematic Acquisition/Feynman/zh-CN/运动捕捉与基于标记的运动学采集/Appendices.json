{
    "hands_on_practices": [
        {
            "introduction": "光学动作捕捉系统的精度并非无限，它受到相机物理设置和传感器噪声的根本限制。理解这些因素如何共同影响三维重建的精度，对于设计有效的实验和正确解读数据至关重要。本实践将通过第一性原理推导，帮助您量化相机基线长度、焦距和标记点定位噪声对深度测量不确定性的影响，从而建立起对立体视觉系统误差来源的直观理解。",
            "id": "4192313",
            "problem": "在一个使用两台已校正的针孔相机观察单个逆反射标记点的校准光学运动捕捉系统中，每台相机的光轴相互平行，且相机中心由一条水平基线分隔。世界坐标系附着在左相机的中心，基线沿世界坐标系的$X$轴，光轴与世界坐标系的$Z$轴对齐。标记点位于深度$Z$处，并分别投影到左、右相机的水平图像坐标$u_L$和$u_R$上。相机经过校正，使得对极线是水平的，视差$d$定义为$d = u_L - u_R$。假设采用针孔模型，并且每台相机水平图像坐标的测量噪声为小的、无偏的、独立同分布的高斯噪声，其标准差为$\\sigma_{\\text{pix}}$（单位：像素）。\n\n已知：\n- 基线长度$b$（单位：米），\n- 物方相机焦距$f_c$（单位：米），\n- 正方形像素间距$p$（单位：米/像素），因此以像素为单位的焦距为$f_{\\text{pix}} = f_c / p$，\n- 工作深度$Z$（单位：米），\n- 每台相机水平定位噪声的标准差$\\sigma_{\\text{pix}}$（单位：像素），\n\n请从第一性原理出发，推导重建深度方差$\\operatorname{Var}(Z)$的一阶近似，将其表示为$b$、$f_{\\text{pix}}$、$Z$和视差方差$\\operatorname{Var}(d)$的函数。然后，利用左、右相机测量值的独立性，用$\\sigma_{\\text{pix}}$表示$\\operatorname{Var}(d)$。最后，对以下科学上合理的参数进行数值计算，求出深度方差：\n- $b = 1.0$ $\\text{m}$，\n- $f_c = 20 \\times 10^{-3}$ $\\text{m}$，\n- $p = 5 \\times 10^{-6}$ $\\text{m/pixel}$，\n- $Z = 5.0$ $\\text{m}$，\n- $\\sigma_{\\text{pix}} = 0.10$ $\\text{pixels}$。\n\n将最终方差以 $\\text{m}^2$ 为单位表示，并将答案四舍五入到三位有效数字。",
            "solution": "我们从校正后的立体针孔几何模型开始。对于一个世界坐标为$(X,Y,Z)$的点，其在左、右相机中的水平图像坐标（以传感器长度单位表示，记为$x_L$和$x_R$）满足针孔关系式\n$$\nx_L = \\frac{f X}{Z}, \\quad x_R = \\frac{f (X - b)}{Z},\n$$\n其中，$f$是以与$x_L$和$x_R$相同的长度单位表示的焦距，$b$是相机中心之间的水平基线。以传感器长度单位表示的视差是\n$$\nd_{\\ell} = x_L - x_R = \\frac{f X}{Z} - \\frac{f (X - b)}{Z} = \\frac{f b}{Z}.\n$$\n如果像素间距为$p$（米/像素），那么像素域的视差$d$和像素域的焦距$f_{\\text{pix}}$为\n$$\nd = \\frac{d_{\\ell}}{p}, \\quad f_{\\text{pix}} = \\frac{f}{p}.\n$$\n因此，\n$$\nd = \\frac{f b}{p Z} = \\frac{f_{\\text{pix}} b}{Z}.\n$$\n将$Z$用$d$表示，得到重建公式\n$$\nZ(d) = \\frac{f_{\\text{pix}} b}{d}.\n$$\n\n为了将视差不确定性传播到深度不确定性，我们对一个标量随机变量的可微函数应用一阶（线性）不确定性传播。如果$Z = g(d)$且$d$的方差很小，则\n$$\n\\operatorname{Var}(Z) \\approx \\left(\\frac{\\partial g}{\\partial d}\\right)^{2} \\operatorname{Var}(d).\n$$\n此处，$g(d) = \\frac{f_{\\text{pix}} b}{d}$，所以\n$$\n\\frac{\\partial Z}{\\partial d} = - \\frac{f_{\\text{pix}} b}{d^{2}}.\n$$\n将导数用$Z$本身来重新表示是很有用的。使用$d = \\frac{f_{\\text{pix}} b}{Z}$，我们有\n$$\n\\frac{\\partial Z}{\\partial d} = - \\frac{f_{\\text{pix}} b}{\\left(\\frac{f_{\\text{pix}} b}{Z}\\right)^{2}} = - \\frac{Z^{2}}{f_{\\text{pix}} b}.\n$$\n因此，深度方差作为视差方差的函数是\n$$\n\\operatorname{Var}(Z) \\approx \\left(\\frac{Z^{2}}{f_{\\text{pix}} b}\\right)^{2} \\operatorname{Var}(d) = \\frac{Z^{4}}{f_{\\text{pix}}^{2} b^{2}} \\operatorname{Var}(d).\n$$\n\n接下来，将视差方差与每台相机的像素定位噪声联系起来。设测得的水平像素坐标为\n$$\nU_L = u_L^{\\ast} + \\epsilon_L, \\quad U_R = u_R^{\\ast} + \\epsilon_R,\n$$\n其中$u_L^{\\ast}$和$u_R^{\\ast}$是无噪声的坐标，$\\epsilon_L, \\epsilon_R$是独立的、零均值的高斯噪声，且$\\operatorname{Var}(\\epsilon_L) = \\operatorname{Var}(\\epsilon_R) = \\sigma_{\\text{pix}}^{2}$。测得的视差为$D = U_L - U_R$，因此\n$$\n\\operatorname{Var}(D) = \\operatorname{Var}(U_L) + \\operatorname{Var}(U_R) - 2\\,\\operatorname{Cov}(U_L,U_R).\n$$\n独立性意味着$\\operatorname{Cov}(U_L,U_R) = 0$，所以\n$$\n\\operatorname{Var}(d) = \\operatorname{Var}(D) = \\sigma_{\\text{pix}}^{2} + \\sigma_{\\text{pix}}^{2} = 2 \\sigma_{\\text{pix}}^{2}.\n$$\n\n综合起来，一阶深度方差为\n$$\n\\operatorname{Var}(Z) \\approx \\frac{Z^{4}}{f_{\\text{pix}}^{2} b^{2}} \\cdot 2 \\sigma_{\\text{pix}}^{2}.\n$$\n\n现在对给定参数进行数值计算。从$f_c$和$p$计算$f_{\\text{pix}}$：\n$$\nf_{\\text{pix}} = \\frac{f_c}{p} = \\frac{20 \\times 10^{-3}}{5 \\times 10^{-6}} = 4000.\n$$\n给定$b = 1.0$，$Z = 5.0$和$\\sigma_{\\text{pix}} = 0.10$，我们有\n$$\n\\operatorname{Var}(d) = 2 \\sigma_{\\text{pix}}^{2} = 2 \\times (0.10)^{2} = 0.02,\n$$\n并且\n$$\n\\operatorname{Var}(Z) \\approx \\frac{(5.0)^{4}}{(4000)^{2} (1.0)^{2}} \\times 0.02.\n$$\n计算各项因子：\n$$\n(5.0)^{4} = 625, \\quad (4000)^{2} = 16{,}000{,}000,\n$$\n所以\n$$\n\\operatorname{Var}(Z) \\approx \\frac{625}{16{,}000{,}000} \\times 0.02 = 3.90625 \\times 10^{-5} \\times 0.02 = 7.8125 \\times 10^{-7}.\n$$\n因此，深度方差为\n$$\n\\operatorname{Var}(Z) \\approx 7.8125 \\times 10^{-7} \\ \\text{m}^{2}.\n$$\n四舍五入到三位有效数字，得到\n$$\n\\operatorname{Var}(Z) \\approx 7.81 \\times 10^{-7} \\ \\text{m}^{2}.\n$$",
            "answer": "$$\\boxed{7.81 \\times 10^{-7}}$$"
        },
        {
            "introduction": "在实际的动作捕捉实验中，数据丢失是一个常见问题，通常由标记点被遮挡引起。这些数据缺口必须通过插值等方法进行填补，但这个过程本身会引入新的误差。本实践模拟了标记点脱落的典型情景，要求您使用稳健的插值技术来重建缺失的轨迹，并定量评估这一过程对位置、姿态角和角速度等关键运动学变量的精度影响。",
            "id": "4192317",
            "problem": "给定一个合成的二维基于标记的节段模型，该模型代表生物力学中的一个肢体节段。该节段由一个关节中心和沿节段线等距放置的两个标记点定义：一个近端标记点和一个远端标记点。节段长度是固定的。真实运动由平滑的时间函数控制。您必须通过在远端标记点轨迹中引入不同长度的间隙，通过插值重建缺失数据，并评估相对于完整数据的重建误差，来分析标记点丢失对计算运动学的影响。任务详情在下面完整说明。\n\n假设采样频率为 $f_s = 120\\,\\text{Hz}$，持续时间为 $T = 5\\,\\text{s}$，得到 $N = f_s \\cdot T = 600$ 个样本。设时间向量为 $t_n = n / f_s$，其中 $n = 0, 1, \\dots, N-1$，采样间隔为 $\\Delta t = 1/f_s$。所有角度必须以弧度表示，线性量以米表示，角速度以弧度/秒表示。\n\n通过以下平滑函数定义关节中心位置 $\\mathbf{C}(t)$ 和节段方向 $\\theta(t)$：\n- $\\mathbf{C}(t) = \\big(C_x(t), C_y(t)\\big)$，其中 $C_x(t) = 0.50\\,\\sin\\!\\big(2\\pi \\cdot 0.40 \\cdot t\\big)$ 且 $C_y(t) = 0.80 + 0.10\\,\\cos\\!\\big(2\\pi \\cdot 0.60 \\cdot t\\big)$。\n- $\\theta(t) = \\theta_0 + A\\,\\sin\\!\\big(2\\pi b t\\big) + B\\,\\sin\\!\\big(2\\pi c t\\big)$，其中 $\\theta_0 = 0.50$，$A = 0.60$，$b = 1.50$，$B = 0.20$，$c = 3.00$。\n\n设节段长度为 $L = 0.40\\,\\text{m}$。定义近端和远端标记点的位置为\n$$\n\\mathbf{P}(t) = \\mathbf{C}(t) - \\frac{L}{2} \\begin{bmatrix}\\cos\\theta(t) \\\\ \\sin\\theta(t)\\end{bmatrix}, \\quad\n\\mathbf{D}(t) = \\mathbf{C}(t) + \\frac{L}{2} \\begin{bmatrix}\\cos\\theta(t) \\\\ \\sin\\theta(t)\\end{bmatrix}.\n$$\n从标记点恢复的真实节段方向为 $\\phi(t) = \\mathrm{atan2}\\!\\big(D_y(t) - P_y(t), D_x(t) - P_x(t)\\big)$，根据构造，它等于 $\\theta(t)$。真实角速度为 $\\omega(t) = \\frac{d\\theta}{dt} = 2\\pi A b \\cos\\!\\big(2\\pi b t\\big) + 2\\pi B c \\cos\\!\\big(2\\pi c t\\big)$。\n\n仅在远端标记点中引入数据丢失间隙。对于每个测试用例，将索引为 $n = s, s+1, \\dots, s+\\ell-1$（含）的连续帧块的 $\\mathbf{D}(t)$ 设置为缺失，其中 $s$ 是间隙起始索引，$\\ell$ 是以帧为单位的间隙长度。通过对 $D_x(t)$ 和 $D_y(t)$ 关于时间执行保形分段三次插值（一种单调分段三次 Hermite 插值多项式），使用所有可用的非缺失样本，并在边界情况下必要时进行外插，来重建缺失的远端标记点坐标 $\\mathbf{\\hat D}(t)$。使用没有数据丢失的近端标记点 $\\mathbf{P}(t)$。\n\n根据重建的轨迹，计算重建的方向 $\\hat\\phi(t) = \\mathrm{atan2}\\!\\big(\\hat D_y(t) - P_y(t), \\hat D_x(t) - P_x(t)\\big)$ 和重建的角速度 $\\hat\\omega(t)$。角速度通过数值微分计算，对内部点使用二阶精确中心差分，对边界点使用一阶差分，这等效于一个具有均匀间距 $\\Delta t$ 的标准梯度算子。\n\n定义信号 $x(t)$ 相对于真实信号 $x_{\\text{true}}(t)$ 的均方根误差 (RMSE) 为\n$$\n\\mathrm{RMSE}(x) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left(x(t_n)-x_{\\text{true}}(t_n)\\right)^2}.\n$$\n对于位置误差，使用每个时间点的欧几里得范数：\n$$\n\\mathrm{RMSE}(\\mathbf{D}) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left[\\big(\\hat D_x(t_n)-D_x(t_n)\\big)^2 + \\big(\\hat D_y(t_n)-D_y(t_n)\\big)^2\\right]}.\n$$\n对于方向误差，为遵循角度周期性，计算环绕差值 $\\Delta\\phi(t) = \\mathrm{atan2}\\!\\big(\\sin(\\hat\\phi(t)-\\phi(t)), \\cos(\\hat\\phi(t)-\\phi(t))\\big)$，然后由 $\\Delta\\phi(t)$ 计算 $\\mathrm{RMSE}(\\phi)$。对于角速度，使用根据 $\\hat\\omega(t)$ 和 $\\omega(t)$ 计算的 $\\mathrm{RMSE}(\\omega)$。\n\n实现以上步骤并评估以下数据丢失场景的测试套件，每个场景由起始索引 $s$ 和长度 $\\ell$（以帧为单位）指定：\n- 情况 1：$s = 180$，$\\ell = 12$。\n- 情况 2：$s = 0$，$\\ell = 60$。\n- 情况 3：$s = 360$，$\\ell = 120$。\n- 情况 4：$s = 540$，$\\ell = 60$。\n\n对于每种情况，计算三个 RMSE 值：位置 RMSE（单位：米），方向 RMSE（单位：弧度），以及角速度 RMSE（单位：弧度/秒）。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个情况的三个浮点数按顺序连接。因此，最终输出的长度必须为 $3 \\times 4 = 12$，顺序如下\n$$\n\\big[\\mathrm{RMSE}(\\mathbf{D})_{\\text{case 1}},\\, \\mathrm{RMSE}(\\phi)_{\\text{case 1}},\\, \\mathrm{RMSE}(\\omega)_{\\text{case 1}},\\, \\mathrm{RMSE}(\\mathbf{D})_{\\text{case 2}},\\, \\mathrm{RMSE}(\\phi)_{\\text{case 2}},\\, \\mathrm{RMSE}(\\omega)_{\\text{case 2}},\\, \\mathrm{RMSE}(\\mathbf{D})_{\\text{case 3}},\\, \\mathrm{RMSE}(\\phi)_{\\text{case 3}},\\, \\mathrm{RMSE}(\\omega)_{\\text{case 3}},\\, \\mathrm{RMSE}(\\mathbf{D})_{\\text{case 4}},\\, \\mathrm{RMSE}(\\phi)_{\\text{case 4}},\\, \\mathrm{RMSE}(\\omega)_{\\text{case 4}}\\big].\n$$\n该行不得包含任何空格。",
            "solution": "该问题是有效的。它提出了一个定义明确的生物力学仿真研究，该研究基于运动学和信号处理的既定原则。所有参数、方程和评估指标都以足够的精度指定，从而可以得到唯一且可验证的解。\n\n解决方案分为五个主要阶段进行开发：\n1.  **生成基准真实运动学数据**：首先，我们生成完整、无噪声的运动学数据，作为“基准真实值”。这包括在指定的时间域上对所提供的连续函数进行离散化。\n2.  **模拟数据丢失**：对于每个测试用例，我们通过在远端标记点的轨迹数据中引入一个指定长度和起始时间的连续间隙来模拟标记点丢失。\n3.  **数据重建**：使用保形分段三次 Hermite 插值多项式 (PCHIP) 重建有间隙的远端标记点轨迹中的缺失数据点。\n4.  **计算重建的运动学数据**：根据重建的远端标记点数据和完整的近端标记点数据，我们计算重建的节段方向和角速度。\n5.  **误差量化**：最后，我们通过计算重建的标记点位置、节段方向和节段角速度的均方根误差 (RMSE)，并将每个值与其各自的基准真实信号进行比较，来量化数据丢失和重建的影响。\n\n以下是每个阶段方法的详细分解。\n\n**1. 基准真实值生成**\n仿真是基于 $T = 5\\,\\text{s}$ 的持续时间内 $f_s = 120\\,\\text{Hz}$ 的采样频率，从而产生 $N = f_s T = 600$ 个离散时间样本。时间向量为 $t = [t_0, t_1, \\dots, t_{N-1}]$，其中 $t_n = n \\Delta t$，采样间隔为 $\\Delta t = 1/f_s$。\n\n基准真实运动学数据定义如下：\n-   关节中心位置：$\\mathbf{C}(t) = \\big(C_x(t), C_y(t)\\big)$，其中 $C_x(t) = 0.50\\,\\sin(2\\pi \\cdot 0.40 \\cdot t)$，$C_y(t) = 0.80 + 0.10\\,\\cos(2\\pi \\cdot 0.60 \\cdot t)$。\n-   节段方向：$\\theta(t) = 0.50 + 0.60\\,\\sin(2\\pi \\cdot 1.50 \\cdot t) + 0.20\\,\\sin(2\\pi \\cdot 3.00 \\cdot t)$。\n-   解析角速度：方向的时间导数，$\\omega(t) = \\frac{d\\theta}{dt} = 2\\pi(0.60)(1.50)\\cos(2\\pi \\cdot 1.50 \\cdot t) + 2\\pi(0.20)(3.00)\\cos(2\\pi \\cdot 3.00 \\cdot t)$。\n\n由此，计算出近端标记点 $\\mathbf{P}(t)$ 和远端标记点 $\\mathbf{D}(t)$ 的位置。给定节段长度 $L = 0.40\\,\\text{m}$，通过将标记点放置在沿节段轴距关节中心 $L/2$ 的距离处来确定其位置：\n$$\n\\mathbf{P}(t) = \\mathbf{C}(t) - \\frac{L}{2}\\mathbf{u}(t) \\quad \\text{和} \\quad \\mathbf{D}(t) = \\mathbf{C}(t) + \\frac{L}{2}\\mathbf{u}(t)\n$$\n其中 $\\mathbf{u}(t) = [\\cos\\theta(t), \\sin\\theta(t)]^T$ 是沿节段方向的单位向量。真实的节段方向可以通过标记点位置恢复，即 $\\phi(t) = \\mathrm{atan2}(D_y(t) - P_y(t), D_x(t) - P_x(t))$，根据构造，它等于 $\\theta(t)$。\n\n**2. 模拟数据丢失**\n对于每个由起始帧索引 $s$ 和间隙长度 $\\ell$ 定义的测试用例，将远端标记点的两个分量 $D_x(t_n)$ 和 $D_y(t_n)$ 的时间序列数据，对所有从 $s$ 到 $s+\\ell-1$ 的索引 $n$，设置为“非数值”(NaN) 值。近端标记点数据 $\\mathbf{P}(t)$ 保持完整。\n\n**3. 通过 PCHIP 进行数据重建**\n重建过程的核心是使用 `scipy.interpolate.PchipInterpolator`。选择此方法是因为它旨在保持原始数据的单调性，防止标准三次样条可能引入的人为振荡（过冲）。在对标记点轨迹等物理数据进行插值时，此属性尤其有价值。\n构建了两个独立的插值器：一个用于远端标记点轨迹的 $x$ 分量，另一个用于 $y$ 分量。每个插值器都是使用所有可用（非 NaN）数据点的时间戳 ($t_n$) 和相应的坐标值构建的。对于间隙出现在试验开始或结束处的测试用例，插值器被配置为可以外插，为已知点域外的缺失数据提供估计值。然后，在整个时间向量 $t$ 上对插值器进行求值，以生成完整的重建远端标记点轨迹 $\\mathbf{\\hat D}(t) = (\\hat D_x(t), \\hat D_y(t))$。\n\n**4. 计算重建的运动学数据**\n利用重建的远端标记点轨迹 $\\mathbf{\\hat D}(t)$ 和真实的近端标记点轨迹 $\\mathbf{P}(t)$，计算所有时间点的重建节段方向 $\\hat\\phi(t)$：\n$$\n\\hat\\phi(t) = \\mathrm{atan2}(\\hat D_y(t) - P_y(t), \\hat D_x(t) - P_x(t))\n$$\n然后通过对 $\\hat\\phi(t)$ 关于时间进行数值微分来确定重建的角速度 $\\hat\\omega(t)$。微分的一个关键先决条件是处理角度的周期性。`atan2` 函数返回的值在 $(-\\pi, \\pi]$ 范围内，这可能导致人为的不连续性（例如，从 $\\pi$ 跳到 $-\\pi$）。为了获得物理上有意义的速度，首先对角度时间序列 $\\hat\\phi(t)$ 进行“解缠绕”以产生一个连续的相位角。然后使用 `numpy.gradient` 和已知的时间步长 $\\Delta t$ 对这个解缠绕后的角度信号进行数值微分。此函数对内部点实现二阶精确的中心差分，并在边界处使用精度较低的一阶前向/后向差分，如规范所述。\n\n**5. 误差量化**\n通过计算在整个持续时间 $T$ 内重建信号与基准真实信号之间的 RMSE 来评估重建的准确性。\n-   **位置 RMSE**：误差是重建的标记点位置 $\\mathbf{\\hat D}(t)$ 与真实位置 $\\mathbf{D}(t)$ 之间均方欧几里得距离的平方根：\n    $$\n    \\mathrm{RMSE}(\\mathbf{D}) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}\\left( (\\hat D_x(t_n)-D_x(t_n))^2 + (\\hat D_y(t_n)-D_y(t_n))^2 \\right)}\n    $$\n-   **方向 RMSE**：为了正确处理角度的 $2\\pi$ 周期性，误差是基于 $\\hat\\phi(t_n)$ 和 $\\phi(t_n)$ 之间的最短夹角计算的。这是通过计算环绕差值 $\\Delta\\phi(t_n) = \\mathrm{atan2}(\\sin(\\hat\\phi(t_n)-\\phi(t_n)), \\cos(\\hat\\phi(t_n)-\\phi(t_n)))$ 来实现的。然后 RMSE 为：\n    $$\n    \\mathrm{RMSE}(\\phi) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}(\\Delta\\phi(t_n))^2}\n    $$\n-   **角速度 RMSE**：这是重建信号 $\\hat\\omega(t)$ 与解析基准真实值 $\\omega(t)$ 之间的直接 RMSE 计算：\n    $$\n    \\mathrm{RMSE}(\\omega) = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1}(\\hat\\omega(t_n) - \\omega(t_n))^2}\n    $$\n为四个指定的间隙场景中的每一个计算这三个 RMSE 值，从而提供了一个关于不同间隙特性（位置和持续时间）如何影响运动学精度的定量度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import PchipInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the biomechanics marker dropout simulation problem.\n    \"\"\"\n    # ------------------\n    # 1. Define Givens and Generate Ground Truth\n    # ------------------\n    \n    # System parameters\n    f_s = 120.0  # Sampling frequency in Hz\n    T = 5.0      # Duration in seconds\n    N = int(f_s * T) # Number of samples\n    delta_t = 1.0 / f_s # Sampling interval\n    L = 0.40     # Segment length in meters\n\n    # Motion function parameters\n    theta_0 = 0.50\n    A = 0.60\n    b = 1.50\n    B = 0.20\n    c = 3.00\n\n    # Time vector\n    t = np.arange(N) * delta_t\n\n    # True joint center position C(t)\n    Cx_t = 0.50 * np.sin(2 * np.pi * 0.40 * t)\n    Cy_t = 0.80 + 0.10 * np.cos(2 * np.pi * 0.60 * t)\n    C_t = np.vstack((Cx_t, Cy_t)).T\n\n    # True segment orientation theta(t)\n    theta_t = theta_0 + A * np.sin(2 * np.pi * b * t) + B * np.sin(2 * np.pi * c * t)\n\n    # True analytical angular velocity omega(t)\n    omega_t = 2 * np.pi * A * b * np.cos(2 * np.pi * b * t) + \\\n              2 * np.pi * B * c * np.cos(2 * np.pi * c * t)\n\n    # True unit vector along the segment\n    u_t = np.vstack((np.cos(theta_t), np.sin(theta_t))).T\n\n    # True proximal and distal marker positions P(t) and D(t)\n    P_t = C_t - (L / 2) * u_t\n    D_t = C_t + (L / 2) * u_t\n\n    # True orientation from markers (equals theta_t by construction)\n    phi_t = np.arctan2(D_t[:, 1] - P_t[:, 1], D_t[:, 0] - P_t[:, 0])\n    \n    # Test cases: (start_index, length_in_frames)\n    test_cases = [\n        (180, 12),\n        (0, 60),\n        (360, 120),\n        (540, 60),\n    ]\n\n    results = []\n    \n    # ------------------\n    # 2. Process each test case\n    # ------------------\n    for s, l in test_cases:\n        # Create gapped distal marker data\n        D_gapped_x = D_t[:, 0].copy()\n        D_gapped_y = D_t[:, 1].copy()\n        \n        gap_indices = np.arange(s, min(s + l, N))\n        D_gapped_x[gap_indices] = np.nan\n        D_gapped_y[gap_indices] = np.nan\n        \n        # Identify non-missing data points for interpolation\n        known_indices = np.where(~np.isnan(D_gapped_x))[0]\n        t_known = t[known_indices]\n        Dx_known = D_t[known_indices, 0]\n        Dy_known = D_t[known_indices, 1]\n        \n        # Reconstruct missing data using PCHIP interpolation\n        interp_x = PchipInterpolator(t_known, Dx_known, extrapolate=True)\n        interp_y = PchipInterpolator(t_known, Dy_known, extrapolate=True)\n        \n        D_hat_x = interp_x(t)\n        D_hat_y = interp_y(t)\n        \n        # Calculate reconstructed kinematics\n        # Reconstructed orientation\n        phi_hat_t = np.arctan2(D_hat_y - P_t[:, 1], D_hat_x - P_t[:, 0])\n        \n        # Reconstructed angular velocity (differentiate unwrapped angle)\n        phi_hat_unwrapped = np.unwrap(phi_hat_t)\n        omega_hat_t = np.gradient(phi_hat_unwrapped, delta_t)\n\n        # ------------------\n        # 3. Calculate and store RMSE values\n        # ------------------\n        \n        # Position RMSE\n        pos_sq_err = (D_hat_x - D_t[:, 0])**2 + (D_hat_y - D_t[:, 1])**2\n        rmse_pos = np.sqrt(np.mean(pos_sq_err))\n        \n        # Orientation RMSE (using wrapped difference)\n        orient_diff = phi_hat_t - phi_t\n        orient_wrapped_diff = np.arctan2(np.sin(orient_diff), np.cos(orient_diff))\n        rmse_orient = np.sqrt(np.mean(orient_wrapped_diff**2))\n\n        # Angular Velocity RMSE\n        ang_vel_sq_err = (omega_hat_t - omega_t)**2\n        rmse_ang_vel = np.sqrt(np.mean(ang_vel_sq_err))\n        \n        results.extend([rmse_pos, rmse_orient, rmse_ang_vel])\n\n    # ------------------\n    # 4. Format and print the final output\n    # ------------------\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}