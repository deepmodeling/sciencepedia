{
    "hands_on_practices": [
        {
            "introduction": "掌握信号处理的第一步是理解采样过程本身。当信号的采样频率不足以捕捉其最高频率分量时，就会发生混叠——高频信息会伪装成低频分量，从而污染数据。这个练习将通过第一性原理推导，帮助你量化这种现象，这是确保生物力学数据保真度的关键技能。",
            "id": "4202751",
            "problem": "您正在分析一个用于生物力学的高保真肌电图(EMG)采集系统中由运动引起的干扰。该肌电图前置放大器无意中通过了一个连续时间频率为 $f_0$ 的单音正弦波，该频率大于奈奎斯特频率 $f_N$，其中奈奎斯特频率定义为 $f_N = \\frac{f_s}{2}$，而 $f_s$ 是均匀采样率。在采样之前没有模拟抗混叠滤波器。从周期为 $T_s = \\frac{1}{f_s}$ 的采样以及采样后正弦波的离散时间频率的定义出发，推导当一个频率为 $f_0 > f_N$ 的正弦波以速率 $f_s$ 采样时，在采样后的肌电图数据的基带区间 $[0, f_N]$ 内将观察到的混叠频率 $f_{\\mathrm{alias}}$ 的解析表达式。然后，计算当 $f_0 = 80\\,\\text{Hz}$ 和 $f_s = 100\\,\\text{Hz}$ 时的 $f_{\\mathrm{alias}}$。以赫兹 (Hz) 为单位表示最终的混叠频率。无需四舍五入。",
            "solution": "所述问题具有科学依据、提法恰当且客观。它涉及数字信号处理中的混叠基本原理，这是生物力学数据采集中一个常见且关键的问题。该问题为求得唯一解提供了所有必要的参数。因此，我们着手进行推导和计算。\n\n设代表干扰的连续时间正弦信号为 $x_c(t)$：\n$$x_c(t) = A \\cos(2\\pi f_0 t + \\phi)$$\n其中 $A$ 是幅度，$f_0$ 是以赫兹为单位的连续时间频率，$t$ 是时间，$\\phi$ 是相位。\n\n该信号以每秒 $f_s$ 个样本的速率进行均匀采样，对应的采样周期为 $T_s = \\frac{1}{f_s}$。离散时间信号 $x[n]$ 是通过在离散时间点 $t = nT_s$ 处对 $x_c(t)$ 求值得到的，其中 $n$ 是一个整数索引。\n$$x[n] = x_c(nT_s) = A \\cos(2\\pi f_0 n T_s + \\phi)$$\n将 $T_s = \\frac{1}{f_s}$ 代入该方程，得到用采样频率表示的采样后信号的表达式：\n$$x[n] = A \\cos\\left(2\\pi \\frac{f_0}{f_s} n + \\phi\\right)$$\n项 $2\\pi \\frac{f_0}{f_s}$ 是归一化离散时间角频率，可表示为 $\\omega_0$。\n\n离散时间正弦波的一个基本属性是其频谱的周期性。在归一化角频率域中，离散时间傅里叶变换的周期为 $2\\pi$。因此，如果任意两个角频率 $\\omega_1$ 和 $\\omega_2$ 相差 $2\\pi$ 的整数倍，那么它们是不可区分的。对于一个实值余弦信号，这由以下恒等式表示：\n$$\\cos(\\omega n + \\phi) = \\cos(\\omega n \\pm 2\\pi k n + \\phi) = \\cos((\\omega \\pm 2\\pi k)n + \\phi)$$\n对任意整数 $k$。\n\n这一性质意味着在采样后，一个连续时间频率 $f_0$ 与集合 $\\{f_0 + k f_s \\mid k \\in \\mathbb{Z}\\}$ 中的任何频率都是不可区分的。采样过程将这个无限的连续时间频率集合映射到一个单一的离散时间表示上。\n\n问题要求找到混叠频率 $f_{\\mathrm{alias}}$，它是 $f_0$ 在基带区间 $[0, f_N]$ 内的唯一表示。奈奎斯特频率 $f_N$ 定义为 $f_N = \\frac{f_s}{2}$。对于实信号，该区间代表了可以无歧义地分辨的唯一频率范围。\n\n为了找到 $f_{\\mathrm{alias}}$，我们必须在区间 $[0, \\frac{f_s}{2}]$ 内确定一个频率，该频率在等价关系 $f \\sim f + kf_s$ 下与 $f_0$ 等价。这可以被看作是在奈奎斯特频率 $f_N = f_s/2$ 的每个整数倍处“折叠”频率轴。从解析上讲，这对应于找到原始频率 $f_0$ 到采样频率 $f_s$ 的最近整数倍的绝对距离。\n\n设采样频率的整数倍集合为 $M = \\{k f_s \\mid k \\in \\mathbb{Z}\\}$。我们必须找到这个集合中离 $f_0$ 最近的成员 $k^* f_s$。使距离 $|f_0 - k f_s|$ 最小化的整数 $k^*$ 是通过将比率 $\\frac{f_0}{f_s}$ 四舍五入到最近的整数得到的：\n$$k^* = \\text{round}\\left(\\frac{f_0}{f_s}\\right)$$\n其中 $\\text{round}(x)$ 是将其参数 $x$ 四舍五入到最近整数的函数。\n\n混叠频率 $f_{\\mathrm{alias}}$ 是 $f_0$ 与这个最近的 $f_s$ 倍数之差的绝对值：\n$$f_{\\mathrm{alias}} = \\left|f_0 - k^* f_s\\right| = \\left|f_0 - \\text{round}\\left(\\frac{f_0}{f_s}\\right) f_s\\right|$$\n这个通用表达式给出了区间 $[0, \\frac{f_s}{2}]$ 内的混叠频率。\n\n现在我们将这个推导出的公式应用于问题陈述中给出的具体数值：\n- 原始连续时间频率：$f_0 = 80\\,\\text{Hz}$\n- 均匀采样率：$f_s = 100\\,\\text{Hz}$\n\n首先，我们确定奈奎斯特频率以确认发生了混叠：\n$$f_N = \\frac{f_s}{2} = \\frac{100}{2} = 50\\,\\text{Hz}$$\n由于 $f_0 = 80\\,\\text{Hz}$ 大于 $f_N = 50\\,\\text{Hz}$，信号被欠采样，其频率将会混叠到基带中。\n\n接下来，我们计算原始频率与采样频率的比率：\n$$\\frac{f_0}{f_s} = \\frac{80}{100} = 0.8$$\n我们将该比率四舍五入到最近的整数以找到 $k^*$：\n$$k^* = \\text{round}(0.8) = 1$$\n最后，我们将这些值代入混叠频率的表达式中：\n$$f_{\\mathrm{alias}} = |80 - (1) \\times 100| = |80 - 100| = |-20| = 20$$\n得到的混叠频率是 $20\\,\\text{Hz}$。该值位于所要求的基带区间 $[0, 50\\,\\text{Hz}]$ 内。因此，这个 $80\\,\\text{Hz}$ 的正弦干扰将作为频率为 $20\\,\\text{Hz}$ 的伪影出现在采样后的肌电图数据中。",
            "answer": "$$\\boxed{20}$$"
        },
        {
            "introduction": "在识别了数据中的噪声后，下一步是设计滤波器来精确地分离有效信号。这个练习模拟了一个核心工程任务：根据通带和阻带的性能指标，确定满足生物力学数据处理所需的最简切比雪夫I型滤波器的阶数，从而将抽象的滤波要求转化为具体的设计参数。",
            "id": "4202801",
            "problem": "一个胫骨惯性测量单元 (IMU) 在跑步过程中以 $f_{\\mathrm{samp}} = 200$ Hz 的采样频率记录矢状面膝关节角度。生理上有意义的运动内容集中在 $f_{\\mathrm{p}} = 8$ Hz 以下，而传感器微振动和软组织伪影在 $f_{\\mathrm{sb}} = 35$ Hz 以上贡献能量。为了在保留运动学信号的同时衰减这些伪影，您将通过双线性变换从一个模拟切比雪夫I型原型设计一个数字低通滤波器。设计指标为通带波纹不大于 $0.5$ 分贝 (dB)，阻带衰减不小于 $40$ dB。通带边缘设置在 $f_{\\mathrm{p}}$，阻带边缘设置在 $f_{\\mathrm{sb}}$。对双线性变换使用频率预畸，其中模拟原型频率变量定义为 $\\Omega = 2 f_{\\mathrm{samp}} \\tan\\!\\left( \\pi f / f_{\\mathrm{samp}} \\right)$，对于以赫兹表示的数字频率 $f$。\n\n从第一性原理出发——即基于第一类切比雪夫多项式的切比雪夫I型幅值平方响应的定义、波纹和衰减的分贝关系以及双线性变换映射——推导同时满足这些通带和阻带指标的最小滤波器阶数 $N$。将您的最终答案表示为满足两个约束的最小整数 $N$。无需四舍五入到指定的有效数字位数。报告单个整数值 $N$，不带单位。",
            "solution": "所述问题具有科学依据、提法明确且客观。它提出了数字信号处理中的一个标准任务：基于模拟原型设计无限脉冲响应 (IIR) 滤波器，以满足特定的频域标准。其应用领域是生物力学，在该领域此类滤波是常规操作。所有提供的数据（$f_{\\mathrm{samp}}$、$f_{\\mathrm{p}}$、$f_{\\mathrm{sb}}$、$A_{\\mathrm{p}}$、$A_{\\mathrm{s}}$）、定义（切比雪夫I型滤波器）和方法（带预畸的双线性变换）都是标准的、一致的，并且足以确定一个唯一的最小滤波器阶数。因此，该问题被认为是有效的，可以制定解决方案。\n\n任务是找到满足给定指标的切比雪夫I型低通滤波器的最小整数阶数 $N$。设计过程包括将数字滤波器指标映射到模拟原型域，确定模拟滤波器所需的阶数，然后将其变换回数字域。滤波器阶数 $N$ 在双线性变换下是不变的。\n\n一个 $N$ 阶模拟切比雪夫I型低通滤波器的幅值平方频率响应由下式给出：\n$$ |H_a(j\\Omega)|^2 = \\frac{1}{1 + \\epsilon^2 T_N^2(\\frac{\\Omega}{\\Omega_{\\mathrm{p}}})} $$\n其中 $\\Omega$ 是以弧度/秒为单位的模拟频率，$\\Omega_{\\mathrm{p}}$ 是模拟通带边缘频率，$T_N(x)$ 是 $N$ 阶第一类切比雪夫多项式，$\\epsilon$ 是一个决定通带波纹的参数。\n\n首先，我们将以分贝 (dB) 给出的设计指标与滤波器响应的参数联系起来。\n\n通带波纹指标为 $A_{\\mathrm{p}} \\le 0.5$ dB。在通带边缘 $\\Omega = \\Omega_{\\mathrm{p}}$ 处，$T_N^2(1) = 1$，幅值平方响应在通带内达到其最小值，即 $|H_a(j\\Omega_{\\mathrm{p}})|^2 = \\frac{1}{1+\\epsilon^2}$。以 dB 表示的通带波纹定义为 $A_{\\mathrm{p}} = 10 \\log_{10}(1+\\epsilon^2)$。我们使用允许的最大波纹来求得所需的 $\\epsilon$：\n$$ A_{\\mathrm{p}} = 0.5 \\, \\text{dB} $$\n$$ 10 \\log_{10}(1 + \\epsilon^2) = 0.5 $$\n$$ 1 + \\epsilon^2 = 10^{0.05} $$\n$$ \\epsilon^2 = 10^{0.05} - 1 $$\n这得到 $\\epsilon = \\sqrt{10^{0.05} - 1}$。\n\n阻带衰减指标为在阻带边缘频率 $\\Omega_{\\mathrm{s}}$ 处 $A_{\\mathrm{s}} \\ge 40$ dB。衰减是幅度响应的倒数。以 dB 表示，这可以写成 $A_{\\mathrm{s}} \\le -20 \\log_{10}(|H_a(j\\Omega_{\\mathrm{s}})|)$。这等价于 $|H_a(j\\Omega_{\\mathrm{s}})|^2 \\le 10^{-A_{\\mathrm{s}}/10}$。\n$$ A_{\\mathrm{s}} = 40 \\, \\text{dB} $$\n$$ \\frac{1}{1 + \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}})} \\le 10^{-40/10} = 10^{-4} $$\n重新整理这个不等式以求解 $T_N$：\n$$ 1 + \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}) \\ge 10^4 $$\n$$ \\epsilon^2 T_N^2(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}) \\ge 10^4 - 1 $$\n$$ |T_N(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}})| \\ge \\frac{\\sqrt{10^4 - 1}}{\\epsilon} $$\n\n接下来，我们必须使用指定的预畸公式 $\\Omega = 2 f_{\\mathrm{samp}} \\tan(\\pi f / f_{\\mathrm{samp}})$，从给定的数字频率 $f_{\\mathrm{p}} = 8$ Hz 和 $f_{\\mathrm{sb}} = 35$ Hz 确定模拟频率 $\\Omega_{\\mathrm{p}}$ 和 $\\Omega_{\\mathrm{s}}$，其中 $f_{\\mathrm{samp}} = 200$ Hz。\n模拟通带边缘频率为：\n$$ \\Omega_{\\mathrm{p}} = 2 f_{\\mathrm{samp}} \\tan\\left(\\frac{\\pi f_{\\mathrm{p}}}{f_{\\mathrm{samp}}}\\right) = 2(200) \\tan\\left(\\frac{\\pi \\cdot 8}{200}\\right) = 400 \\tan(0.04\\pi) \\, \\frac{\\text{rad}}{\\text{s}} $$\n模拟阻带边缘频率为：\n$$ \\Omega_{\\mathrm{s}} = 2 f_{\\mathrm{samp}} \\tan\\left(\\frac{\\pi f_{\\mathrm{sb}}}{f_{\\mathrm{samp}}}\\right) = 2(200) \\tan\\left(\\frac{\\pi \\cdot 35}{200}\\right) = 400 \\tan(0.175\\pi) \\, \\frac{\\text{rad}}{\\text{s}} $$\n因此，比率 $\\Omega_{\\mathrm{s}}/\\Omega_{\\mathrm{p}}$ 为：\n$$ \\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}} = \\frac{400 \\tan(0.175\\pi)}{400 \\tan(0.04\\pi)} = \\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)} $$\n由于 $f_{\\mathrm{sb}} > f_{\\mathrm{p}}$，因此 $\\Omega_{\\mathrm{s}} > \\Omega_{\\mathrm{p}}$，且切比雪夫多项式的自变量大于 1。对于 $x > 1$，切比雪夫多项式可以用双曲余弦表示：$T_N(x) = \\cosh(N \\operatorname{arccosh}(x))$。\n将此代入我们的不等式：\n$$ \\cosh\\left(N \\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right)\\right) \\ge \\frac{\\sqrt{10^4 - 1}}{\\epsilon} $$\n由于 $\\operatorname{arccosh}(x)$ 对于 $x \\ge 1$ 是一个单调递增函数：\n$$ N \\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right) \\ge \\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\epsilon}\\right) $$\n求解 $N$：\n$$ N \\ge \\frac{\\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\epsilon}\\right)}{\\operatorname{arccosh}\\left(\\frac{\\Omega_{\\mathrm{s}}}{\\Omega_{\\mathrm{p}}}\\right)} $$\n现在，我们代入 $\\epsilon$ 和频率比的表达式：\n$$ N \\ge \\frac{\\operatorname{arccosh}\\left(\\frac{\\sqrt{10^4 - 1}}{\\sqrt{10^{0.05} - 1}}\\right)}{\\operatorname{arccosh}\\left(\\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)}\\right)} $$\n我们继续进行数值计算。\n分子中 $\\operatorname{arccosh}$ 的自变量是：\n$$ \\frac{\\sqrt{10000 - 1}}{\\sqrt{10^{0.05} - 1}} \\approx \\frac{\\sqrt{9999}}{\\sqrt{1.122018 - 1}} \\approx \\frac{99.995}{\\sqrt{0.122018}} \\approx \\frac{99.995}{0.34931} \\approx 286.265 $$\n分母中 $\\operatorname{arccosh}$ 的自变量是：\n$$ \\frac{\\tan(0.175\\pi)}{\\tan(0.04\\pi)} \\approx \\frac{\\tan(0.549779)}{\\tan(0.125664)} \\approx \\frac{0.62487}{0.12633} \\approx 4.94623 $$\n现在我们计算 $\\operatorname{arccosh}$ 函数。我们可以使用恒等式 $\\operatorname{arccosh}(x) = \\ln(x + \\sqrt{x^2-1})$。\n分子：\n$$ \\operatorname{arccosh}(286.265) \\approx \\ln(286.265 + \\sqrt{286.265^2 - 1}) \\approx \\ln(572.528) \\approx 6.3500 $$\n分母：\n$$ \\operatorname{arccosh}(4.94623) \\approx \\ln(4.94623 + \\sqrt{4.94623^2 - 1}) \\approx \\ln(9.7903) \\approx 2.2814 $$\n最后，我们计算 $N$ 的下界：\n$$ N \\ge \\frac{6.3500}{2.2814} \\approx 2.7834 $$\n由于滤波器阶数 $N$ 必须是整数，我们必须选择满足此条件的最小整数，即计算值的向上取整。\n$$ N = \\lceil 2.7834 \\rceil = 3 $$\n因此，满足通带和阻带指标所需的最小滤波器阶数为 $3$。",
            "answer": "$$\\boxed{3}$$"
        },
        {
            "introduction": "信号处理的最终目标之一是提取有意义的生物力学信息，而功率谱密度($\\text{PSD}$)是揭示信号中周期性模式（如步态周期）的关键工具。本练习将指导你通过编程实现韦尔奇方法（一种鲁棒的$\\text{PSD}$估计技术），来分析合成的膝关节角度数据。你将学习如何处理有限且含噪的数据，并应用峰值检测算法来识别主导频率分量。",
            "id": "4202813",
            "problem": "膝关节屈伸角时间序列是一种一维运动学信号，可建模为实值函数 $x(t)$，单位为度，随时间 $t$（单位为秒）变化。当以赫兹为单位的采样频率 $f_{s}$ 进行离散采样时，该序列变为 $x[n]$，其中 $n$ 为整数采样索引，采样间隔为 $\\Delta t = 1/f_{s}$。目标是估计该信号的功率谱密度（PSD），并解读反映步态周期等周期性生物力学模式的主导频率分量。功率谱密度（PSD）量化了信号功率在频率上的分布情况。对于离散时间信号，通常采用一致性方法进行估计，通过加窗和平均来减少方差和频谱泄漏。在本问题中，必须使用 Welch 方法计算 PSD，并采用汉宁窗（Hanning window，也称 Hann 窗）以及连续段之间 $50\\%$ 的重叠。角度单位必须为度，频率必须以赫兹报告。\n\n从基本原理出发，假设信号 $x[n]$ 在分析窗口内是宽平稳的，并且离散时间傅里叶变换（DTFT）将时域测量与其频域表示联系起来。对于有限长度的含噪数据，为减少方差和抑制泄漏，需要采用加窗和分段平均。Welch 方法通过将 $x[n]$ 分割成长度为 $L$ 的段，对每段应用一个窗口 $w[n]$，计算段周期图，并对所有段进行平均来实现这一目的。汉宁窗是一种平滑的余弦锥形窗，与矩形窗相比，能减少频谱泄漏。将各段重叠 $50\\%$ 会增加平均次数，从而进一步减小估计量的方差。\n\n您必须实现以下任务：\n- 对于每个测试用例，合成一个膝关节角度时间序列 $x[n]$（单位为度），该序列是指定振幅和频率的正弦波之和，可选地包含一个小的线性漂移项和指定标准差（单位为度）的加性零均值高斯噪声。\n- 使用 Welch 方法计算 PSD $S_{xx}(f)$，采用汉宁窗、段长度 $L$（以样本为单位）和 $L/2$ 的重叠（如有必要，向下取整）。使用密度缩放，使 PSD 的单位为 $\\text{degrees}^{2}/\\text{Hz}$。\n- 在指定的生物力学相关频带 $[f_{\\min}, f_{\\max}]$（单位为赫兹）内识别主导频率分量，使用一个峰值选择标准，该标准要求峰值超过频带内最大 PSD 的 $\\alpha$ 倍的相对阈值，并且超过频带内 PSD 中位数的 $\\beta$ 倍的噪声基底因子。只有在这些阈值下是局部最大值的频率才应作为主导频率返回。报告每个主导频率，四舍五入到两位小数，单位为赫兹。\n- 角度单位必须是度。所有频率输出的单位必须是赫兹。最终输出必须是一行，将所有测试用例的结果汇总到一个方括号列表中，其中每个项目本身都是一个方括号列表，包含为该测试用例发现的主导频率的浮点数，整行中不得有任何空格。因此，最终输出必须看起来像一个由浮点数组成的方括号列表的方括号列表，每个浮点数四舍五入到两位小数。\n\n测试套件：\n为以下四个用例提供结果；每个用例必须使用下述确切参数独立地进行合成和分析。为保证可复现性，每个用例使用固定的随机种子。\n\n- 案例 1（正常路径，多分量类步态信号）：\n  - 采样频率 $f_{s} = 120$ Hz，持续时间 $T = 12$ s，总样本数 $N = f_{s} \\cdot T$。\n  - 分量：振幅和频率 $(A_{1}, f_{1}) = (25, 1.80)$、$(A_{2}, f_{2}) = (8, 3.60)$、$(A_{3}, f_{3}) = (5, 3.20)$（单位为度和赫兹），相位 $(\\phi_{1}, \\phi_{2}, \\phi_{3}) = (0.00, 0.50, 1.00)$（单位为弧度）。\n  - 加性噪声：标准差 $\\sigma = 1.50$ 度，零均值。\n  - 窗长 $L = 512$ 样本，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.20$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 12345$。\n\n- 案例 2（边界条件，单分段）：\n  - 采样频率 $f_{s} = 100$ Hz，持续时间 $T = 2.56$ s，总样本数 $N = 256$。\n  - 分量：$(A_{1}, f_{1}) = (30, 2.00)$（单位为度和赫兹），相位 $\\phi_{1} = 0.00$ 弧度。\n  - 加性噪声：$\\sigma = 0.50$ 度。\n  - 窗长 $L = 256$ 样本，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.30$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 23456$。\n\n- 案例 3（边缘情况，步态带外的低频趋势）：\n  - 采样频率 $f_{s} = 100$ Hz，持续时间 $T = 15.00$ s，总样本数 $N = 1500$。\n  - 分量：$(A_{1}, f_{1}) = (15, 0.20)$（单位为度和赫兹），相位 $\\phi_{1} = 0.00$ 弧度。\n  - 线性漂移：速率 $d = 0.50$ 度/秒。\n  - 加性噪声：$\\sigma = 1.00$ 度。\n  - 窗长 $L = 512$ 样本，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.40$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 34567$。\n\n- 案例 4（边缘情况，频率接近分辨率极限）：\n  - 采样频率 $f_{s} = 90$ Hz，持续时间 $T = 5.00$ s，总样本数 $N = 450$。\n  - 分量：$(A_{1}, f_{1}) = (15, 1.95)$（单位为度和赫兹），相位 $\\phi_{1} = 0.00$ 弧度。\n  - 加性噪声：$\\sigma = 1.50$ 度。\n  - 窗长 $L = 256$ 样本，重叠 $L/2$。\n  - 频带限制 $[f_{\\min}, f_{\\max}] = [0.50, 10.00]$ Hz。\n  - 相对阈值 $\\alpha = 0.25$，噪声基底因子 $\\beta = 3.00$。\n  - 随机种子 $s = 45678$。\n\n您的程序必须：\n- 根据提供的参数合成每个信号 $x[n]$（单位为度）。\n- 使用 Welch 方法，配合汉宁（Hann）窗和 $50\\%$ 的重叠来计算 PSD。\n- 在每个用例的指定频带内，找到超过上述两个阈值的局部最大值，并返回它们的频率，四舍五入到两位小数。\n- 生成单行输出，其中包含四个结果，以逗号分隔并用方括号括起。每个结果本身是一个包含浮点数的方括号列表，其中没有任何空格。例如，外层列表有四个项目，如果根据指定标准未检测到主导分量，内层列表可能为空。数值频率必须以赫兹为单位。\n\n所有测试用例的最终输出必须是浮点数或浮点数列表。不得打印任何其他文本。",
            "solution": "问题陈述已经过严格验证，被认为是有效的。它科学地植根于数字信号处理的原理，特别是功率谱密度（PSD）估计，并将这些原理应用于生物力学中一个明确定义的问题。该问题是自包含的，为每个测试用例明确提供了所有必要的参数、条件和约束。语言客观、精确，结构清晰，从而导向一个唯一且可验证的解决方案。\n\n任务是实现一个算法，用于在一个合成的生物力学信号中（具体为膝关节屈伸角时间序列）识别主导频率。解决方案包括三个主要阶段：信号合成、使用Welch方法进行PSD估计，以及一个基于规则的峰值检测算法。\n\n首先，根据定义的模型进行信号合成。在持续时间 $T$ 内以采样频率 $f_s$ 生成一个离散时间信号 $x[n]$。总样本数为 $N = f_s T$。时间向量为 $t_n = n/f_s$，其中 $n = 0, 1, \\dots, N-1$。信号模型是正弦波的叠加，并可能包含线性趋势和加性噪声：\n$$x[n] = \\sum_{i} A_i \\sin(2\\pi f_i t_n + \\phi_i) + d \\cdot t_n + \\epsilon[n]$$\n在此， $A_i$、$f_i$ 和 $\\phi_i$ 分别是第 $i$ 个正弦分量的振幅、频率和相位。项 $d \\cdot t_n$ 表示速率为 $d$（单位为度/秒）的线性漂移。噪声项 $\\epsilon[n]$ 被建模为一个独立同分布序列，从标准差为 $\\sigma$ 的零均值高斯分布中抽取。为了保证可复现性，在生成 $\\epsilon[n]$ 时，每个案例都使用特定的随机种子。\n\n其次，使用 Welch 方法估计合成信号 $x[n]$ 的功率谱密度（PSD）。与对整个信号进行简单周期图计算相比，该技术旨在减少 PSD 估计的方差。该方法包括以下步骤：\n1. 将长度为 $N$ 的信号 $x[n]$ 分割成 $K$ 个可能重叠的长度为 $L$ 的段。对于本问题，重叠指定为段长度的 $50\\%$，即 $L/2$ 个样本。\n2. 每个段乘以一个窗函数 $w[n]$，这里是汉宁窗，以减少由数据段有限长度引起的频谱泄漏。汉宁窗定义为：\n$$ w[n] = 0.5 \\left(1 - \\cos\\left(\\frac{2\\pi n}{L-1}\\right)\\right), \\quad 0 \\le n \\le L-1 $$\n3. 对每个加窗段计算周期图。使用 `density` 缩放，第 $k$ 段的周期图 $I_k(f)$ 被归一化，单位为 $\\text{power}/\\text{Hz}$（这里是 $\\text{degrees}^2/\\text{Hz}$）。此归一化通过除以采样频率 $f_s$ 和窗口样本平方和 $U = \\sum_{n=0}^{L-1} w[n]^2$ 来实现。\n4. 最终的 PSD 估计 $S_{xx}(f)$ 是通过对所有 $K$ 段的周期图进行平均得到的：\n$$ S_{xx}(f) = \\frac{1}{K} \\sum_{k=0}^{K-1} I_k(f) $$\n这个平均过程减少了估计的方差。所得 PSD 的频率分辨率为 $\\Delta f = f_s/L$。\n\n第三，从估计的 PSD $S_{xx}(f)$ 中，在指定的生物力学相关频带 $[f_{\\min}, f_{\\max}]$ 内识别主导频率。如果一个频率仓满足多条件准则，则被认为是主导的。频率 $f_p$ 处的峰值必须是局部最大值，并且其幅值 $S_{xx}(f_p)$ 必须同时满足两个阈值：\n1. 相对幅值阈值，峰值的功率必须超过频带内最大功率的一部分 $\\alpha$：\n$$ S_{xx}(f_p) > \\alpha \\cdot \\max_{f \\in [f_{\\min}, f_{\\max}]} \\{S_{xx}(f)\\} $$\n2. 噪声基底阈值，峰值的功率必须显著大于背景噪声水平，该水平由频带内的功率中位数估计：\n$$ S_{xx}(f_p) > \\beta \\cdot \\text{median}_{f \\in [f_{\\min}, f_{\\max}]} \\{S_{xx}(f)\\} $$\n只有当两个条件都满足时，才会报告一个峰值。这等同于要求其幅值大于两个阈值中的最大值。\n\n实现过程将通过迭代四个指定的测试用例来进行。对于每个用例，将合成信号，并使用 `scipy.signal.welch` 计算其 PSD。然后，使用 `scipy.signal.find_peaks` 在指定频带内识别 PSD 中的局部最大值，并将其 `height` 参数设置为强制执行两个检测阈值。所识别峰值的频率将被收集并根据指定的输出要求进行格式化。",
            "answer": "```python\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Solves the problem by synthesizing signals, computing PSDs, \n    and identifying dominant frequencies for four test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"fs\": 120, \"T\": 12,\n            \"components\": [\n                {\"A\": 25, \"f\": 1.80, \"phi\": 0.00},\n                {\"A\": 8,  \"f\": 3.60, \"phi\": 0.50},\n                {\"A\": 5,  \"f\": 3.20, \"phi\": 1.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 1.50,\n            \"L\": 512,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.20, \"beta\": 3.00,\n            \"seed\": 12345\n        },\n        {\n            \"fs\": 100, \"T\": 2.56,\n            \"components\": [\n                {\"A\": 30, \"f\": 2.00, \"phi\": 0.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 0.50,\n            \"L\": 256,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.30, \"beta\": 3.00,\n            \"seed\": 23456\n        },\n        {\n            \"fs\": 100, \"T\": 15.00,\n            \"components\": [\n                {\"A\": 15, \"f\": 0.20, \"phi\": 0.00}\n            ],\n            \"drift\": 0.50,\n            \"noise_sigma\": 1.00,\n            \"L\": 512,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.40, \"beta\": 3.00,\n            \"seed\": 34567\n        },\n        {\n            \"fs\": 90, \"T\": 5.00,\n            \"components\": [\n                {\"A\": 15, \"f\": 1.95, \"phi\": 0.00}\n            ],\n            \"drift\": 0.0,\n            \"noise_sigma\": 1.50,\n            \"L\": 256,\n            \"f_min\": 0.50, \"f_max\": 10.00,\n            \"alpha\": 0.25, \"beta\": 3.00,\n            \"seed\": 45678\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        # Set seed for reproducibility\n        np.random.seed(case[\"seed\"])\n\n        # Signal Synthesis\n        fs = case[\"fs\"]\n        T = case[\"T\"]\n        N = int(fs * T)\n        t = np.arange(N) / fs\n        \n        x = np.zeros(N)\n\n        # Add sinusoidal components\n        for comp in case[\"components\"]:\n            x += comp[\"A\"] * np.sin(2 * np.pi * comp[\"f\"] * t + comp[\"phi\"])\n        \n        # Add linear drift\n        if case[\"drift\"] > 0:\n            x += case[\"drift\"] * t\n\n        # Add Gaussian noise\n        x += np.random.normal(0, case[\"noise_sigma\"], N)\n\n        # PSD Computation using Welch's method\n        L = case[\"L\"]\n        overlap = L // 2\n        f, Pxx = signal.welch(x, fs=fs, window='hann', nperseg=L, noverlap=overlap, scaling='density')\n\n        # Dominant Frequency Identification\n        f_min, f_max = case[\"f_min\"], case[\"f_max\"]\n        band_indices = np.where((f >= f_min) & (f <= f_max))\n        \n        f_band = f[band_indices]\n        Pxx_band = Pxx[band_indices]\n        \n        dominant_freqs = []\n        if len(f_band) > 0:\n            # Calculate thresholds\n            max_psd_in_band = np.max(Pxx_band)\n            rel_threshold = case[\"alpha\"] * max_psd_in_band\n            \n            median_psd_in_band = np.median(Pxx_band)\n            noise_floor_threshold = case[\"beta\"] * median_psd_in_band\n            \n            # Combined threshold for peak finding\n            min_height = max(rel_threshold, noise_floor_threshold)\n\n            # Find peaks that satisfy the height requirement\n            peak_indices, _ = signal.find_peaks(Pxx_band, height=min_height)\n            \n            dominant_freqs = [round(f_band[i], 2) for i in peak_indices]\n        \n        all_results.append(dominant_freqs)\n\n    # Format the final output string\n    # e.g., [[1.88,3.28,3.52],[2.00],[],[2.11]]\n    output_parts = []\n    for res_list in all_results:\n        inner_list_str = '[' + ','.join([f\"{freq:.2f}\" for freq in res_list]) + ']'\n        output_parts.append(inner_list_str)\n    \n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n\n```"
        }
    ]
}