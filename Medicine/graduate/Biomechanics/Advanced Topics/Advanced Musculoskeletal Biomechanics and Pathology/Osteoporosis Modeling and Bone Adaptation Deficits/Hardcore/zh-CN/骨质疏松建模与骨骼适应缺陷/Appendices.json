{
    "hands_on_practices": [
        {
            "introduction": "骨质疏松症的一个关键特征是骨形成受损。硬化蛋白（Sclerostin）是一种由骨细胞产生的分子，它能有效抑制Wnt信号通路，从而减少成骨细胞的活化和骨形成。本练习将引导你使用一个简化的数学模型来量化一种靶向疗法——硬化蛋白抗体的效果。通过这个练习，你将学会如何将复杂的生物化学相互作用转化为一个可计算的框架，并评估治疗干预对细胞活性的影响。",
            "id": "4196997",
            "problem": "在骨质疏松骨中，骨细胞产生的增加的硬化素会抑制Wingless/Integrated (Wnt)信号通路，从而减少成骨细胞的活化并损害骨形成。考虑一个力学生物学模型，其中Wnt通路的活化受硬化素水平的抑制，其活化由饱和抑制关系式 $$W = \\frac{W_{\\mathrm{max}}}{1 + s/s_0},$$ 给出，其中 $W$ 是Wnt活化水平，$W_{\\mathrm{max}}$ 是在没有硬化素时的最大活化水平，$s$ 是有效硬化素水平，$s_0$ 是一个参考硬化素水平，在该水平下活化相对于最大值减半。假设成骨细胞活化 $A$ 与Wnt活化 $W$ 呈线性正比关系，$$A = \\alpha W,$$ 其中 $\\alpha$ 是一个反映下游转导效率的正比例常数。一种针对硬化素的单克隆抗体疗法将有效硬化素水平降低了$1/2$倍，即 $s \\mapsto s' = \\frac{1}{2}s$。\n\n从相对变化的基本定义出发，计算成骨细胞活化的分数相对变化 $$\\frac{\\Delta A}{A} = \\frac{A(s') - A(s)}{A(s)},$$ 并将您的最终结果表示为基线归一化硬化素水平 $$x = \\frac{s}{s_0}$$ 的闭式函数。请以无量纲分数的形式提供您的答案。无需四舍五入。",
            "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- Wnt通路活化作为硬化素水平 $s$ 的函数：$$W(s) = \\frac{W_{\\mathrm{max}}}{1 + s/s_0}$$\n- $W_{\\mathrm{max}}$: 最大Wnt活化水平。\n- $s_0$: 参考硬化素水平。\n- 成骨细胞活化 $A$ 作为Wnt活化 $W$ 的函数：$$A = \\alpha W$$\n- $\\alpha$: 正比例常数。\n- 治疗引起的硬化素水平变化：$$s' = \\frac{1}{2}s$$\n- 待计算量：成骨细胞活化的分数相对变化，$$\\frac{\\Delta A}{A} = \\frac{A(s') - A(s)}{A(s)}$$\n- 最终结果的自变量：归一化硬化素水平，$$x = \\frac{s}{s_0}$$\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了一个简化但机理上有效的骨重塑调节模型。硬化素对Wnt活化的抑制关系是生物化学动力学中使用的标准形式（类似于竞争性抑制）。硬化素、Wnt信号通路和成骨细胞在骨质疏松症中的作用是骨生物学中一个公认的领域，也是现有疗法（如罗莫索珠单抗）的靶点。该模型具有科学依据。\n- **适定性：** 问题提供了推导所需量所必需的所有数学定义和关系。初始和最终状态定义清晰，目标变量明确。存在唯一、稳定的解。\n- **客观性：** 问题使用精确、客观的数学语言陈述。所有术语均已定义。\n- **缺陷分析：**\n  - 该问题在科学上是合理的，可形式化，并与生物力学和骨质疏松症建模直接相关。\n  - 它是完整的、自洽的，并且没有矛盾。参数 $\\alpha$ 和 $W_{\\mathrm{max}}$ 预计在相对变化计算中会消掉，因此不需要它们的具体值。\n  - 在数学模型的背景下，这些条件在生物学上是合理的。\n  - 问题结构清晰，可导出唯一解。\n\n**步骤3：结论与行动**\n问题有效。将推导解答。\n\n成骨细胞活化 $A$ 是硬化素水平 $s$ 的函数。我们首先明确表示出 $A(s)$。通过将Wnt活化 $W$ 的表达式代入成骨细胞活化 $A$ 的方程中，我们得到：\n$$A(s) = \\alpha W(s) = \\alpha \\left( \\frac{W_{\\mathrm{max}}}{1 + s/s_0} \\right) = \\frac{\\alpha W_{\\mathrm{max}}}{1 + s/s_0}$$\n该疗法将有效硬化素水平降低至 $s' = \\frac{1}{2}s$。新的成骨细胞活化水平 $A(s')$，可以通过将 $s'$ 代入 $A(s)$ 的表达式中求得：\n$$A(s') = \\frac{\\alpha W_{\\mathrm{max}}}{1 + s'/s_0} = \\frac{\\alpha W_{\\mathrm{max}}}{1 + (\\frac{1}{2}s)/s_0} = \\frac{\\alpha W_{\\mathrm{max}}}{1 + \\frac{s}{2s_0}}$$\n我们需要计算成骨细胞活化的分数相对变化，定义为：\n$$\\frac{\\Delta A}{A} = \\frac{A(s') - A(s)}{A(s)}$$\n该表达式可以改写为：\n$$\\frac{\\Delta A}{A} = \\frac{A(s')}{A(s)} - 1$$\n让我们首先计算比率 $\\frac{A(s')}{A(s)}$：\n$$\\frac{A(s')}{A(s)} = \\frac{\\frac{\\alpha W_{\\mathrm{max}}}{1 + s/(2s_0)}}{\\frac{\\alpha W_{\\mathrm{max}}}{1 + s/s_0}}$$\n项 $\\alpha W_{\\mathrm{max}}$ 从分子和分母中消去，得到：\n$$\\frac{A(s')}{A(s)} = \\frac{1 + s/s_0}{1 + s/(2s_0)}$$\n问题要求最终答案用基线归一化硬化素水平 $x = s/s_0$ 表示。将 $x$ 代入该比率中得到：\n$$\\frac{A(s')}{A(s)} = \\frac{1 + x}{1 + x/2}$$\n现在，我们可以计算分数相对变化 $\\frac{\\Delta A}{A}$：\n$$\\frac{\\Delta A}{A} = \\frac{1 + x}{1 + x/2} - 1$$\n为了简化此表达式，我们使用公分母 $1 + x/2$：\n$$\\frac{\\Delta A}{A} = \\frac{1 + x}{1 + x/2} - \\frac{1 + x/2}{1 + x/2} = \\frac{(1 + x) - (1 + x/2)}{1 + x/2}$$\n简化分子：\n$$\\frac{\\Delta A}{A} = \\frac{1 + x - 1 - x/2}{1 + x/2} = \\frac{x - x/2}{1 + x/2} = \\frac{x/2}{1 + x/2}$$\n为了消除复合分数，我们将分子和分母同乘以 $2$：\n$$\\frac{\\Delta A}{A} = \\frac{2 \\cdot (x/2)}{2 \\cdot (1 + x/2)} = \\frac{x}{2(1) + 2(x/2)} = \\frac{x}{2 + x}$$\n这就是成骨细胞活化的分数相对变化作为归一化基线硬化素水平 $x$ 的函数的最终闭式表达式。",
            "answer": "$$\\boxed{\\frac{x}{2 + x}}$$"
        },
        {
            "introduction": "骨骼具有卓越的自我调节能力，这一过程通常通过“力学稳态”（mechanostat）理论来描述，即骨骼会调整其密度以维持一个理想的力学刺激“设定点”。然而，衰老等因素会导致骨细胞对力学信号的敏感性下降，相当于提高了这个生物学设定点。本练习将通过一个基于物理原理的模型，让你推导出这种设定点漂移如何不可避免地导致骨密度下降，为年龄相关性骨质疏松提供了一个简洁而深刻的力学解释。",
            "id": "4197054",
            "problem": "建立一个骨细胞调节的力学稳态器模型，用于一个理想化的单轴加载骨小梁隔室，其中表观骨密度（用 $\\rho$ 表示）通过重塑过程演变，以平衡机械刺激与生物设定点。机械刺激定义为 $S(\\rho) = \\beta\\,E(\\rho)\\,\\epsilon(\\rho)^{2}$，其中 $E(\\rho)$ 是表观弹性模量，$\\epsilon(\\rho)$ 是日常活动中习惯性负载引起的宏观应变幅。表观模量遵循幂律关系 $E(\\rho) = \\alpha\\,\\rho^{n}$，其中 $\\alpha > 0$ 且 $n > 0$。假设在所关注的时间尺度上，习惯性负载近似为应力控制的，具有恒定的宏观应力幅 $\\sigma > 0$，因此根据单轴应力下的线弹性理论，有 $\\epsilon(\\rho) = \\sigma / E(\\rho)$。\n\n设健康状态下的生物力学稳态器设定点为 $S_{0} > 0$。由于衰老引起的脱敏，设定点增加了 $\\Delta S_{0} \\ge 0$，因此新的设定点为 $S_{0}^{\\text{new}} = S_{0} + \\Delta S_{0}$。当机械刺激等于设定点时，净重塑为零，此时定义为平衡状态。在这些假设下，请确定新的平衡密度 $\\rho^{*}$，并用 $\\alpha$、$\\beta$、$n$、$\\sigma$、$S_{0}$ 和 $\\Delta S_{0}$ 表示为一个闭式表达式。请提供一个单一的解析表达式；无需进行数值计算，最终表达式中也无需包含单位。",
            "solution": "该问题被验证为具有科学依据、适定、客观和完整。它描述了骨重塑的标准力学稳态器模型，这是生物力学中的一个核心概念。所有变量和条件都得到了明确定义，从而导出一个可解且具有唯一、有意义解的问题。所用术语正式，并与该领域保持一致。\n\n该问题要求找出新的平衡骨密度 $\\rho^{*}$，它在机械刺激 $S(\\rho^{*})$ 等于新的生物设定点 $S_{0}^{\\text{new}}$ 时达到。因此，平衡条件是：\n$$S(\\rho^{*}) = S_{0}^{\\text{new}}$$\n新的设定点由 $S_{0}^{\\text{new}} = S_{0} + \\Delta S_{0}$ 给出。机械刺激定义为 $S(\\rho) = \\beta\\,E(\\rho)\\,\\epsilon(\\rho)^{2}$。为了求解 $\\rho^{*}$，我们必须首先将刺激 $S$ 表示为密度 $\\rho$ 和给定参数的函数。\n\n问题指出，习惯性负载是应力控制的，具有恒定的宏观应力幅 $\\sigma$。在此条件下，应变 $\\epsilon(\\rho)$ 由线弹性理论给出：\n$$\\epsilon(\\rho) = \\frac{\\sigma}{E(\\rho)}$$\n我们将此应变表达式代入机械刺激的定义中：\n$$S(\\rho) = \\beta\\,E(\\rho)\\,\\left(\\frac{\\sigma}{E(\\rho)}\\right)^{2} = \\beta\\,E(\\rho)\\,\\frac{\\sigma^{2}}{E(\\rho)^{2}} = \\frac{\\beta\\,\\sigma^{2}}{E(\\rho)}$$\n这个中间结果表明，对于一个应力控制的系统，机械刺激与表观弹性模量成反比。\n\n接下来，我们将给定的弹性模量幂律关系 $E(\\rho) = \\alpha\\,\\rho^{n}$ 代入刺激的表达式中：\n$$S(\\rho) = \\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,\\rho^{n}}$$\n现在，我们得到了仅用密度 $\\rho$ 和参数 $\\alpha$、$\\beta$、$n$ 和 $\\sigma$ 表示的机械刺激 $S$。\n\n我们现在可以在新的平衡密度 $\\rho^{*}$ 处应用平衡条件：\n$$S(\\rho^{*}) = \\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,(\\rho^{*})^{n}} = S_{0}^{\\text{new}}$$\n代入 $S_{0}^{\\text{new}} = S_{0} + \\Delta S_{0}$，我们得到：\n$$\\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,(\\rho^{*})^{n}} = S_{0} + \\Delta S_{0}$$\n我们的目标是解出该方程中的 $\\rho^{*}$。我们进行代数重排。首先，我们分离出包含 $\\rho^{*}$ 的项：\n$$(\\rho^{*})^{n} = \\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,(S_{0} + \\Delta S_{0})}$$\n为了求解 $\\rho^{*}$，我们对等式两边取 $n$ 次方根，这等价于将两边同时提高到 $\\frac{1}{n}$ 次幂：\n$$\\rho^{*} = \\left( \\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,(S_{0} + \\Delta S_{0})} \\right)^{\\frac{1}{n}}$$\n这就是用给定参数表示的新的平衡密度 $\\rho^{*}$ 的最终闭式表达式。该表达式具有物理意义，因为所有参数 $\\alpha$、$\\sigma$、$S_0$ 均为严格正值，$n$ 为正值，且 $\\Delta S_0$ 为非负值，这确保了根号内的参数是一个正实数。",
            "answer": "$$\\boxed{\\left( \\frac{\\beta\\,\\sigma^{2}}{\\alpha\\,(S_{0} + \\Delta S_{0})} \\right)^{\\frac{1}{n}}}$$"
        },
        {
            "introduction": "骨骼的适应过程并非瞬时完成，细胞信号传导、招募和分化都需要时间，这些生理延迟在骨质疏松症中可能更为显著，构成了一种“适应缺陷”。与之前关注静态平衡的模型不同，本计算练习要求你构建一个包含时间延迟的动态系统模型。通过数值模拟，你将探索这些延迟如何导致骨密度在应对负荷变化时出现“超调”和“振荡”等不稳定行为，从而揭示受损适应系统背后的动力学机制。",
            "id": "4197032",
            "problem": "考虑一个用于皮质骨量适应外部载荷突变的简化力学生物学模型，其中包含一个延迟的成骨细胞响应，该响应代表了在骨质疏松症中观察到的骨细胞信号传导和募集缺陷。使用以下基础和经验关系作为您的起点，并从中推导出一个可运行的数值模拟，以量化骨矿物质密度的超调和振荡。\n\n基本基础和核心定义：\n- 均质弹性连续体的胡克定律断言，轴向应变与弹性模量成反比，因此对于固定的轴向载荷，应变大小与弹性模量的倒数成比例。\n- 骨骼的弹性模量通过幂律关系随密度变化，即$$E(\\rho) = E_0 \\left(\\frac{\\rho}{\\rho_0}\\right)^\\alpha,$$，其中$\\rho$是骨密度，$\\rho_0$是基线密度，$\\alpha > 0$是一个有经验支持的指数，$E_0$是基线模量。\n- 在力学感受器范式中，成骨细胞的激活由与应变或应变能成比例的骨细胞刺激驱动（相差一个比例常数）。对于固定的外部载荷比$L/L_0$，假设无量纲力学感受刺激为$$s(t) = \\frac{L(t)/L_0}{\\left(\\rho(t)/\\rho_0\\right)^\\alpha},$$，这与胡克定律和模量-密度关系相符。\n- 成骨细胞的响应不是瞬时的；将成骨细胞活动代理$b(t)$建模为对刺激的一阶弛豫，并带有纯延迟$\\tau_d$，因此其变化率服从对延迟刺激的线性弛豫。\n- 骨密度的变化由骨形成减去骨吸收决定。将骨形成建模为与成骨细胞活动代理$b(t)$成正比，骨吸收建模为与当前密度$\\rho(t)$成正比。\n\n您必须根据上述原理构建以下耦合延迟动力学，表示为带有时滞的常微分方程（ODE）系统：\n1. $b(t)$对力学感受刺激$s(t - \\tau_d)$的延迟一阶弛豫，弛豫时间为$\\tau_b$。\n2. $\\rho(t)$的一阶质量平衡，结合了与$b(t)$成正比（系数为$k_b$）的骨形成和与$\\rho(t)$成正比（系数为$k_r$）的骨吸收。\n\n在时间区间$t \\in [0,T]$上，使用固定的均匀时间步长，实现该延迟系统的数值模拟。采用鲁棒的ODE步进方案（例如，四阶龙格-库塔法），同时将延迟输入$s(t - \\tau_d)$在每个步长内视为分段常数，并从存储的历史数据中获取。对于延迟所需的$t=0$之前的时间，假设系统处于基线稳态。\n\n加载方案：\n- 当$t  t_{\\mathrm{change}}$时，外部载荷比$L(t)/L_0$为$1$；当$t \\ge t_{\\mathrm{change}}$时，突然阶跃到一个常数$L_1/L_0$。\n\n单位和输出：\n- 骨密度$\\rho$必须以$\\mathrm{g}/\\mathrm{cm}^3$为单位。\n- 时间$t$必须以天为单位。\n- 将超调幅度报告为相对于阶跃变化后新稳态密度的十进制分数。即，计算$\\max\\{0, \\max_{t \\ge t_{\\mathrm{change}}} \\rho(t) - \\rho_{\\mathrm{ss}}\\}/\\rho_{\\mathrm{ss}}$，其中$\\rho_{\\mathrm{ss}}$是加载阶跃后的稳态密度。\n- 通过计算$t \\ge t_{\\mathrm{change}}$时$\\rho(t) - \\rho_{\\mathrm{ss}}$的符号变化次数来检测振荡；如果在模拟区间内该差异至少有两次符号变化，则定义系统为振荡系统。\n\n稳态表征：\n- 从模型及其基本关系所蕴含的平衡条件中推导出$\\rho_{\\mathrm{ss}}$；在超调和振荡计算中使用得到的$\\rho_{\\mathrm{ss}}$。\n\n数值要求：\n- 使用固定的时间步长，并进行足够长时间的模拟，以使瞬态响应合理衰减。\n- 确保参数在科学上是合理的，并与皮质骨重塑的时间尺度（数十到数百天）和密度（约$1.0$–$2.0$ $\\mathrm{g}/\\mathrm{cm}^3$）相符。\n\n测试套件：\n模拟以下四个参数集，每个参数集指定为$[\\rho_0, \\alpha, k_r, \\tau_b, \\tau_d, L_1/L_0, t_{\\mathrm{change}}, T, \\Delta t]$，其中$k_b$必须选择为使得基线稳态为$\\rho_0$（即$k_b = k_r \\rho_0$），所有时间单位均为天。对于每种情况，请精确使用给定的参数。\n\n- 情况A（理想情况，轻度延迟）：$[1.50,\\, 2.00,\\, 0.010,\\, 30.0,\\, 10.0,\\, 1.50,\\, 200.0,\\, 1200.0,\\, 0.25]$\n- 情况B（骨质疏松缺陷：更长延迟和更慢形成）：$[1.20,\\, 2.00,\\, 0.012,\\, 80.0,\\, 60.0,\\, 1.50,\\, 200.0,\\, 1200.0,\\, 0.25]$\n- 情况C（边界情况：非常长的延迟，更大幅度阶跃）：$[1.50,\\, 1.80,\\, 0.010,\\, 50.0,\\, 120.0,\\, 2.00,\\, 200.0,\\, 1200.0,\\, 0.25]$\n- 情况D（边界条件：无延迟）：$[1.50,\\, 2.00,\\, 0.010,\\, 20.0,\\, 0.0,\\, 1.50,\\, 200.0,\\, 1200.0,\\, 0.25]$\n\n答案规范和最终输出格式：\n- 对于每种情况，输出一个双元素列表$[\\text{overshoot},\\, \\text{oscillatory}]$，其中$\\text{overshoot}$是一个保留六位小数的浮点数，$\\text{oscillatory}$是一个布尔值。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来，例如：$[[o_A,\\, \\mathrm{True}],\\,[o_B,\\, \\mathrm{False}],\\,[o_C,\\, \\mathrm{True}],\\,[o_D,\\, \\mathrm{False}]]$，其中$o_A, o_B, o_C, o_D$是相应情况下的超调值，每个值都保留六位小数。",
            "solution": "用户提供了一个关于骨量适应的明确的计算生物力学问题。任务是基于首要原则和经验关系，推导并模拟一个简化的力学生物学模型，然后分析系统对机械载荷突然变化的响应。\n\n### 1. 数学模型构建\n\n该问题明确了构建一个包含两个耦合延迟微分方程（DDEs）系统的基础，该系统描述骨矿物质密度$\\rho(t)$和成骨细胞活动代理$b(t)$的时间演化。\n\n首先，骨密度变化率被建模为骨形成与骨吸收之间的质量平衡。骨形成由成骨细胞活动驱动，与$b(t)$成正比，速率常数为$k_b$。骨吸收被假设为一个一阶衰减过程，与当前密度$\\rho(t)$成正比，速率常数为$k_r$。这引出第一个方程：\n$$\n\\frac{d\\rho(t)}{dt} = k_b b(t) - k_r \\rho(t)\n$$\n\n其次，成骨细胞活动代理$b(t)$被建模为一个一阶弛豫过程。它的值朝着目标刺激$s$弛豫，特征弛豫时间为$\\tau_b$。一个关键特征是包含了一个纯时间延迟$\\tau_d$，代表细胞信号传导和募集中的生理滞后。因此，在时间$t$的活动$b(t)$响应的是在时间$t - \\tau_d$发生的刺激。其控制方程为：\n$$\n\\frac{db(t)}{dt} = \\frac{1}{\\tau_b} \\left( s(t - \\tau_d) - b(t) \\right)\n$$\n\n力学感受刺激$s(t)$源自骨骼所承受的应变。根据所提供的原则，应变与弹性模量$E$成反比。而模量又通过幂律关系随密度变化：$E(\\rho) = E_0 (\\rho/\\rho_0)^\\alpha$。对于给定的外部载荷比$L(t)/L_0$，刺激因此与$E$成反比，得出表达式：\n$$\ns(t) = \\frac{L(t)/L_0}{\\left(\\rho(t)/\\rho_0\\right)^\\alpha}\n$$\n\n将刺激的表达式代入$b(t)$的方程中，得到第二个DDE的最终形式：\n$$\n\\frac{db(t)}{dt} = \\frac{1}{\\tau_b} \\left( \\frac{L(t - \\tau_d)/L_0}{\\left(\\rho(t - \\tau_d)/\\rho_0\\right)^\\alpha} - b(t) \\right)\n$$\n\n完整的DDE系统是：\n$$\n\\begin{cases}\n\\frac{d\\rho}{dt} = k_b b(t) - k_r \\rho(t) \\\\\n\\frac{db}{dt} = \\frac{1}{\\tau_b} \\left( \\frac{L(t - \\tau_d)/L_0}{\\left(\\rho(t - \\tau_d)/\\rho_0\\right)^\\alpha} - b(t) \\right)\n\\end{cases}\n$$\n\n### 2. 稳态分析\n\n为了分析该系统，我们首先确定其所有时间导数都为零的稳态。\n\n**基线稳态：** 对于$t  t_{\\mathrm{change}}$，载荷比为$L/L_0 = 1$。问题指出系统处于密度为$\\rho_0$的基线稳态。让我们验证一下条件。将导数设为零，并令$\\rho = \\rho_0$和$L/L_0=1$：\n从$b(t)$方程，稳态活动$b_{ss,0}$是$b_{ss,0} = s(\\rho_0) = \\frac{1}{(\\rho_0/\\rho_0)^\\alpha} = 1$。\n从$\\rho(t)$方程，我们必须有$0 = k_b b_{ss,0} - k_r \\rho_0$。代入$b_{ss,0}=1$，我们得到$k_b = k_r \\rho_0$。这证实了速率常数之间所需的关系，确保了模型的一致性。因此，模拟的初始状态是$\\rho(t\\le0) = \\rho_0$和$b(t\\le0)=1$。\n\n**新稳态：** 在$t = t_{\\mathrm{change}}$发生载荷变化后，载荷比变为一个新的常数$L_1/L_0$。当$t \\to \\infty$时，系统接近一个新的稳态，$\\rho_{\\mathrm{ss}}$和$b_{\\mathrm{ss}}$。在此平衡点：\n$$\n0 = k_b b_{\\mathrm{ss}} - k_r \\rho_{\\mathrm{ss}} \\implies b_{\\mathrm{ss}} = \\frac{k_r \\rho_{\\mathrm{ss}}}{k_b} = \\frac{k_r \\rho_{\\mathrm{ss}}}{k_r \\rho_0} = \\frac{\\rho_{\\mathrm{ss}}}{\\rho_0}\n$$\n并且\n$$\nb_{\\mathrm{ss}} = \\frac{L_1/L_0}{(\\rho_{\\mathrm{ss}}/\\rho_0)^\\alpha}\n$$\n将$b_{\\mathrm{ss}}$的两个表达式相等：\n$$\n\\frac{\\rho_{\\mathrm{ss}}}{\\rho_0} = \\frac{L_1/L_0}{(\\rho_{\\mathrm{ss}}/\\rho_0)^\\alpha}\n$$\n这得到$\\left(\\frac{\\rho_{\\mathrm{ss}}}{\\rho_0}\\right)^{\\alpha+1} = \\frac{L_1}{L_0}$。求解$\\rho_{\\mathrm{ss}}$，我们找到目标稳态密度：\n$$\n\\rho_{\\mathrm{ss}} = \\rho_0 \\left( \\frac{L_1}{L_0} \\right)^{\\frac{1}{\\alpha+1}}\n$$\n根据问题要求，该值对于计算超调和检测振荡至关重要。\n\n### 3. 数值模拟方案\n\nDDE系统使用步进法结合四阶龙格-库塔（RK4）积分器和固定时间步长$\\Delta t$进行数值求解。系统状态由向量$\\mathbf{y}(t) = [\\rho(t), b(t)]^T$表示。\n\n对于从$t_i$到$t_{i+1} = t_i + \\Delta t$的每个积分步骤，延迟项$s(t - \\tau_d)$被视为分段常数，固定为步长开始时的值：$s(t_i - \\tau_d)$。这有效地将DDE在该步长期间转换为标准的常微分方程（ODE）。\n\nRK4算法的步骤如下：\n1.  在时间$t_i$，确定延迟状态。延迟时间为$t_{d} = t_i - \\tau_d$。从模拟的存储历史中检索延迟密度$\\rho(t_d)$。如果$t_d  0$，则使用基线值$\\rho_0$。延迟载荷$L(t_d)/L_0$也根据$t_d  t_{\\mathrm{change}}$来确定。\n2.  计算该步长的恒定延迟刺激：$s_{delayed} = \\frac{L(t_d)/L_0}{(\\rho(t_d)/\\rho_0)^\\alpha}$。\n3.  定义该步长的ODE右侧函数：$\\mathbf{f}(\\mathbf{y}) = [k_b b - k_r \\rho, (s_{delayed} - b)/\\tau_b]^T$。\n4.  使用RK4更新规则计算下一个状态$\\mathbf{y}_{i+1}$：\n    $$\n    \\begin{align*}\n    \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{y}_i) \\\\\n    \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{y}_i + \\mathbf{k}_1/2) \\\\\n    \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{y}_i + \\mathbf{k}_2/2) \\\\\n    \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(\\mathbf{y}_i + \\mathbf{k}_3) \\\\\n    \\mathbf{y}_{i+1} = \\mathbf{y}_i + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n    \\end{align*}\n    $$\n5.  将$\\mathbf{y}_{i+1}=[\\rho_{i+1}, b_{i+1}]^T$存储在历史数组中，并进行下一步。\n\n模拟完成后，分析$t \\ge t_{\\mathrm{change}}$时$\\rho(t)$的轨迹。超调量计算为$\\max\\{0, \\max(\\rho) - \\rho_{\\mathrm{ss}}\\}/\\rho_{\\mathrm{ss}}$。通过计算$\\rho(t) - \\rho_{\\mathrm{ss}}$的符号改变次数来检测振荡。如果至少有两次这样的变化，则认为系统是振荡的。最终的实现封装了这整个过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bone remodeling DDE problem for the given test cases.\n    \"\"\"\n    # Test cases defined as:\n    # [rho_0, alpha, k_r, tau_b, tau_d, L1/L0, t_change, T, dt]\n    test_cases = [\n        # Case A: ideal case, mild delay\n        [1.50, 2.00, 0.010, 30.0, 10.0, 1.50, 200.0, 1200.0, 0.25],\n        # Case B: osteoporotic deficit: longer delay and slower formation\n        [1.20, 2.00, 0.012, 80.0, 60.0, 1.50, 200.0, 1200.0, 0.25],\n        # Case C: edge case: very long delay, larger step\n        [1.50, 1.80, 0.010, 50.0, 120.0, 2.00, 200.0, 1200.0, 0.25],\n        # Case D: boundary condition: no delay\n        [1.50, 2.00, 0.010, 20.0, 0.0, 1.50, 200.0, 1200.0, 0.25],\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        rho0, alpha, kr, taub, taud, L1_L0, t_change, T, dt = params\n\n        # Derived parameter\n        kb = kr * rho0\n\n        # New steady-state density\n        rho_ss = rho0 * (L1_L0)**(1.0 / (alpha + 1.0))\n\n        # Simulation setup\n        time_points = np.arange(0, T + dt, dt)\n        num_steps = len(time_points)\n        \n        rho_history = np.zeros(num_steps)\n        b_history = np.zeros(num_steps)\n\n        # Initial conditions (baseline steady state)\n        rho_history[0] = rho0\n        b_history[0] = 1.0\n\n        delay_steps = int(round(taud / dt))\n\n        # RK4 implementation for the DDE system\n        for i in range(num_steps - 1):\n            t_current = time_points[i]\n            y_current = np.array([rho_history[i], b_history[i]])\n\n            # Determine delayed values\n            t_delayed = t_current - taud\n            \n            if t_delayed  t_change:\n                L_delayed_ratio = 1.0\n            else:\n                L_delayed_ratio = L1_L0\n\n            delayed_idx = i - delay_steps\n            if delayed_idx  0:\n                rho_delayed = rho0\n            else:\n                rho_delayed = rho_history[delayed_idx]\n\n            s_delayed = L_delayed_ratio / ((rho_delayed / rho0)**alpha)\n\n            # Define the derivative function for the current step\n            def f(y, s_d):\n                rho, b = y\n                d_rho_dt = kb * b - kr * rho\n                d_b_dt = (s_d - b) / taub\n                return np.array([d_rho_dt, d_b_dt])\n\n            # RK4 substeps\n            k1 = dt * f(y_current, s_delayed)\n            k2 = dt * f(y_current + 0.5 * k1, s_delayed)\n            k3 = dt * f(y_current + 0.5 * k2, s_delayed)\n            k4 = dt * f(y_current + k3, s_delayed)\n            \n            y_next = y_current + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n            \n            rho_history[i+1], b_history[i+1] = y_next\n\n        # Post-processing: Analyze overshoot and oscillations\n        \n        # Find index from which to start analysis\n        change_idx = int(round(t_change / dt))\n        rho_post_change = rho_history[change_idx:]\n        \n        # 1. Calculate overshoot\n        max_rho = np.max(rho_post_change)\n        overshoot = max(0.0, max_rho - rho_ss) / rho_ss\n        \n        # 2. Detect oscillations\n        diff_from_ss = rho_post_change - rho_ss\n        # Ignore zero crossings near machine precision\n        signs = np.sign(diff_from_ss[np.abs(diff_from_ss) > 1e-9])\n        sign_changes = np.sum(np.diff(signs) != 0)\n        oscillatory = bool(sign_changes >= 2)\n        \n        all_results.append(f\"[{overshoot:.6f},{str(oscillatory).lower()}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[[{','.join(all_results)}]]\")\n\n\nsolve()\n```"
        }
    ]
}