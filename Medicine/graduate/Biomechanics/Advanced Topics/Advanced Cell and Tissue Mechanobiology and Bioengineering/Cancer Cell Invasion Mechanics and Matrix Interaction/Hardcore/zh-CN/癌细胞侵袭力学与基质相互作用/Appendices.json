{
    "hands_on_practices": [
        {
            "introduction": "细胞与细胞外基质（ECM）的粘附是其迁移、力感知和信号转导的基础。本练习将引导你从统计力学的第一性原理出发，推导描述分子键在力作用下解离速率的经典贝尔模型 (Bell model)。进一步地，我们将探讨更为复杂的“捕获键”（catch bond）模型，这种键在一定拉力范围内反而会变得更加稳定，这对于理解整合素等粘附分子的复杂生物力学行为至关重要 。",
            "id": "4162323",
            "problem": "考虑癌细胞侵袭过程中的一个整合素-细胞外基质（ECM）键，其被建模为在一维反应坐标上越过能垒的热激活逃逸过程。假设沿反应坐标 $x$ 施加一个外部拉伸力 $F$，使能量景观从 $U(x)$ 倾斜为 $U_{F}(x)=U(x)-F x$。假设在温度 $T$ 下存在热噪声的过阻尼动力学，并设零力时的能垒高度为 $\\Delta U_{0}$，位于沿反应坐标从结合态最小值算起的投影距离 $x_{b}$ 处。在所施加的力足够小的情况下进行研究，即能垒位置和指前因子（尝试频率和阻尼贡献）不受 $F$ 的显著影响，但能垒高度随 $F$ 近似线性降低。\n\n利用热激活逃逸和力致能垒倾斜的原理，推导单路径滑移键的力依赖性解离速率的函数关系，用零力解离速率 $k_{0}$、投影距离 $x_{b}$、玻尔兹曼常数 $k_{B}$、绝对温度 $T$ 和力 $F$ 来表示。\n\n接下来，为了捕捉在整合素捕获键中观察到的非单调力依赖性，用一个双态门控模型来扩展单路径描述，在该模型中存在两种结合构象：一个滑移态 $S$ 和一个捕获态 $C$。该键可以通过任一路径解离，其力依赖性解离速率为\n$$\nk_{s}(F)=k_{s0}\\,\\exp\\!\\left(\\frac{F x_{s}}{k_{B} T}\\right),\\qquad x_{s}>0,\n$$\n$$\nk_{c}(F)=k_{c0}\\,\\exp\\!\\left(-\\frac{F x_{c}}{k_{B} T}\\right),\\qquad x_{c}>0,\n$$\n反映了一个被力去稳定化的类滑移路径和一个在有限范围内被力稳定化的类捕获路径。该键可以在两种结合构象之间转换，其力依赖性转变速率为\n$$\nk_{SC}(F)=k_{SC}^{0}\\,\\exp\\!\\left(\\frac{F d_{SC}}{k_{B} T}\\right),\\qquad d_{SC}>0,\n$$\n$$\nk_{CS}(F)=k_{CS}^{0}\\,\\exp\\!\\left(-\\frac{F d_{CS}}{k_{B} T}\\right),\\qquad d_{CS}>0,\n$$\n其中 $k_{SC}(F)$ 在张力下使占据偏向于 $C$，而 $k_{CS}(F)$ 在张力下减少了向 $S$ 的反向转变。假设在解离之前，$S$ 和 $C$ 之间存在准稳态门控，其中 $P_{s}(F)$ 和 $P_{c}(F)$ 分别表示占据 $S$ 和 $C$ 的稳态概率，满足 $P_{s}(F)+P_{c}(F)=1$ 和细致流平衡 $k_{SC}(F) P_{s}(F)=k_{CS}(F) P_{c}(F)$。\n\n在这些假设下，推导总有效解离速率 $k_{\\mathrm{off}}(F)$ 的闭式解析表达式，其为 $F$、$k_{s0}$、$x_{s}$、$k_{c0}$、$x_{c}$、$k_{SC}^{0}$、$d_{SC}$、$k_{CS}^{0}$、$d_{CS}$、$k_{B}$ 和 $T$ 的函数。以 $k_{\\mathrm{off}}(F)$ 的简化解析表达式形式给出你的最终答案。不需要单位转换或四舍五入；只给出符号表达式。",
            "solution": "该问题分为两部分。第一部分要求推导单路径滑移键的解离速率，即著名的 Bell 模型。第二部分要求推导一个更复杂的双态捕获键模型的有效解离速率。\n\n第一部分：单路径滑移键\n\n生物分子键的解离可以被建模为从一个能阱越过一个能垒的热激活逃逸过程。根据 Kramers 理论，对于一个过阻尼系统，逃逸速率 $k$ 由一个类阿伦尼乌斯表达式给出：\n$$k = A \\exp\\left(-\\frac{\\Delta U}{k_B T}\\right)$$\n其中 $A$ 是一个指前因子，取决于势阱和能垒的形状，以及阻尼系数（与粘度相关），通常称为尝试频率。$\\Delta U$ 是能垒的高度（活化能），$k_B$ 是玻尔兹曼常数，$T$ 是绝对温度。\n\n在零外力（$F=0$）时，解离速率记为 $k_0$。能垒高度为 $\\Delta U_0$。因此，我们可以写出：\n$$k_0 = A \\exp\\left(-\\frac{\\Delta U_0}{k_B T}\\right)$$\n\n当沿反应坐标 $x$ 施加一个外部拉伸力 $F$ 时，能量景观 $U(x)$ 会发生倾斜。新的势能由 $U_F(x) = U(x) - Fx$ 给出。我们将能量最小值（结合态）的位置定义为 $x=0$，能量最大值（过渡态）的位置定义为 $x=x_b$。量 $x_b$ 表示从最小值到能垒沿反应坐标的投影距离。\n\n在力存在的情况下，能垒的高度 $\\Delta U(F)$ 是过渡态和结合态之间的势能差：\n$$\\Delta U(F) = U_F(x_b) - U_F(0)$$\n代入 $U_F(x)$ 的表达式，我们得到：\n$$\\Delta U(F) = [U(x_b) - Fx_b] - [U(0) - F \\cdot 0]$$\n零力能垒为 $\\Delta U_0 = U(x_b) - U(0)$。因此，依赖于力的能垒高度为：\n$$\\Delta U(F) = \\Delta U_0 - Fx_b$$\n该表达式假设力足够小，以至于最小值和能垒沿反应坐标的位置没有显著改变。题目陈述中明确包含了这个假设。\n\n依赖于力的解离速率 $k(F)$ 则由下式给出：\n$$k(F) = A \\exp\\left(-\\frac{\\Delta U(F)}{k_B T}\\right)$$\n题目陈述还假设指前因子 $A$ 不受力的显著影响。代入 $\\Delta U(F)$ 的表达式：\n$$k(F) = A \\exp\\left(-\\frac{\\Delta U_0 - Fx_b}{k_B T}\\right) = A \\exp\\left(-\\frac{\\Delta U_0}{k_B T}\\right) \\exp\\left(\\frac{Fx_b}{k_B T}\\right)$$\n认识到 $k_0 = A \\exp(-\\Delta U_0 / k_B T)$，我们可以用零力解离速率来表示依赖于力的解离速率：\n$$k(F) = k_0 \\exp\\left(\\frac{Fx_b}{k_B T}\\right)$$\n这就是经典的滑移键 Bell 模型，其中解离速率随施加的力呈指数增长。参数 $x_b$ 通常被称为反应柔量或到过渡态的距离。\n\n第二部分：双态捕获键模型\n\n问题的第二部分描述了一个捕获键的双态模型，该模型表现出非单调的寿命-力行为。该键可以存在于两种结合构象中，即滑移态 $S$ 和捕获态 $C$。解离可以从任一状态发生。状态之间的转变也依赖于力。\n\n总有效解离速率 $k_{\\mathrm{off}}(F)$ 是结合态总布居数的衰减速率。假设状态 $S$ 和 $C$ 之间的转变远快于解离速率 ($k_{SC}(F), k_{CS}(F) \\gg k_s(F), k_c(F)$)，则系统在发生显著解离之前，在 $S$ 和 $C$ 之间达到准稳态分布。\n\n在此准稳态假设下，总解离速率是每个状态解离速率的加权平均值，权重是占据这些状态的稳态概率 $P_s(F)$ 和 $P_c(F)$：\n$$k_{\\mathrm{off}}(F) = k_s(F) P_s(F) + k_c(F) P_c(F)$$\n稳态概率由状态间的细致流平衡和归一化条件确定。题目给出了这些条件：\n1. 归一化： $P_s(F) + P_c(F) = 1$\n2. 细致流平衡： $k_{SC}(F) P_s(F) = k_{CS}(F) P_c(F)$\n\n从第二个方程，我们可以用 $P_s(F)$ 来表示 $P_c(F)$：\n$$P_c(F) = \\frac{k_{SC}(F)}{k_{CS}(F)} P_s(F)$$\n将其代入归一化方程：\n$$P_s(F) + \\frac{k_{SC}(F)}{k_{CS}(F)} P_s(F) = 1$$\n$$P_s(F) \\left(1 + \\frac{k_{SC}(F)}{k_{CS}(F)}\\right) = 1 \\implies P_s(F) \\left(\\frac{k_{CS}(F) + k_{SC}(F)}{k_{CS}(F)}\\right) = 1$$\n解出 $P_s(F)$ 得到：\n$$P_s(F) = \\frac{k_{CS}(F)}{k_{SC}(F) + k_{CS}(F)}$$\n使用 $P_c(F) = 1 - P_s(F)$，我们求得 $P_c(F)$：\n$$P_c(F) = 1 - \\frac{k_{CS}(F)}{k_{SC}(F) + k_{CS}(F)} = \\frac{k_{SC}(F) + k_{CS}(F) - k_{CS}(F)}{k_{SC}(F) + k_{CS}(F)} = \\frac{k_{SC}(F)}{k_{SC}(F) + k_{CS}(F)}$$\n现在，我们将这些概率表达式代回到总有效解离速率的方程中：\n$$k_{\\mathrm{off}}(F) = k_s(F) \\left(\\frac{k_{CS}(F)}{k_{SC}(F) + k_{CS}(F)}\\right) + k_c(F) \\left(\\frac{k_{SC}(F)}{k_{SC}(F) + k_{CS}(F)}\\right)$$\n将各项合并到公分母上，得到：\n$$k_{\\mathrm{off}}(F) = \\frac{k_s(F) k_{CS}(F) + k_c(F) k_{SC}(F)}{k_{SC}(F) + k_{CS}(F)}$$\n最后一步是代入每个速率给定的力依赖性表达式：\n- $k_{s}(F)=k_{s0}\\,\\exp\\left(\\frac{F x_{s}}{k_{B} T}\\right)$\n- $k_{c}(F)=k_{c0}\\,\\exp\\left(-\\frac{F x_{c}}{k_{B} T}\\right)$\n- $k_{SC}(F)=k_{SC}^{0}\\,\\exp\\left(\\frac{F d_{SC}}{k_{B} T}\\right)$\n- $k_{CS}(F)=k_{CS}^{0}\\,\\exp\\left(-\\frac{F d_{CS}}{k_{B} T}\\right)$\n\n$k_{\\mathrm{off}}(F)$ 的分母是：\n$$k_{SC}(F) + k_{CS}(F) = k_{SC}^{0}\\,\\exp\\left(\\frac{F d_{SC}}{k_{B} T}\\right) + k_{CS}^{0}\\,\\exp\\left(-\\frac{F d_{CS}}{k_{B} T}\\right)$$\n$k_{\\mathrm{off}}(F)$ 的分子有两项。第一项是：\n$$k_s(F) k_{CS}(F) = \\left(k_{s0}\\,\\exp\\left(\\frac{F x_{s}}{k_{B} T}\\right)\\right) \\left(k_{CS}^{0}\\,\\exp\\left(-\\frac{F d_{CS}}{k_{B} T}\\right)\\right) = k_{s0} k_{CS}^{0} \\exp\\left(\\frac{F(x_s - d_{CS})}{k_B T}\\right)$$\n分子的第二项是：\n$$k_c(F) k_{SC}(F) = \\left(k_{c0}\\,\\exp\\left(-\\frac{F x_{c}}{k_{B} T}\\right)\\right) \\left(k_{SC}^{0}\\,\\exp\\left(\\frac{F d_{SC}}{k_{B} T}\\right)\\right) = k_{c0} k_{SC}^{0} \\exp\\left(\\frac{F(d_{SC} - x_c)}{k_B T}\\right)$$\n将这些部分组合起来，得到总有效解离速率的最终表达式：\n$$k_{\\mathrm{off}}(F) = \\frac{k_{s0} k_{CS}^{0} \\exp\\left(\\frac{F(x_s - d_{CS})}{k_B T}\\right) + k_{c0} k_{SC}^{0} \\exp\\left(\\frac{F(d_{SC} - x_c)}{k_B T}\\right)}{k_{SC}^{0}\\,\\exp\\left(\\frac{F d_{SC}}{k_{B} T}\\right) + k_{CS}^{0}\\,\\exp\\left(-\\frac{F d_{CS}}{k_{B} T}\\right)}$$\n这就是双态捕获键的有效解离速率作为施加的力和模型参数的函数的闭式解析表达式。",
            "answer": "$$\\boxed{\\frac{k_{s0} k_{CS}^{0} \\exp\\left(\\frac{F(x_s - d_{CS})}{k_B T}\\right) + k_{c0} k_{SC}^{0} \\exp\\left(\\frac{F(d_{SC} - x_c)}{k_B T}\\right)}{k_{SC}^{0}\\exp\\left(\\frac{F d_{SC}}{k_{B} T}\\right) + k_{CS}^{0}\\exp\\left(-\\frac{F d_{CS}}{k_{B} T}\\right)}}$$"
        },
        {
            "introduction": "细胞外基质（ECM）的力学特性直接影响着癌细胞的侵袭行为。然而，ECM并非均质材料，而是一种由胶原纤维、透明质酸等多组分构成的复杂复合材料。本练习将带你应用经典的复合材料力学理论，计算ECM有效杨氏模量的Voigt上限和Reuss下限，并通过将这些理论预测值与模拟的实验数据进行比较，学会评估不同力学假设（如等应变或等应力）的适用性，从而对ECM的力学行为建立更深刻的直觉 。",
            "id": "4162354",
            "problem": "在癌细胞侵袭过程中，使用基于共聚焦激光扫描显微镜 (CLSM) 的微观力学技术，对一种经过力学表征的细胞外基质 (ECM) 进行探测。该ECM由胶原纤维网络和透明质酸凝胶组成。在小应变下，将该ECM视为一种各向同性、线性弹性的两相复合材料。胶原相的杨氏模量为 $E_{c} = 1.8 \\times 10^{3}$ Pa，透明质酸相的杨氏模量为 $E_{h} = 1.2 \\times 10^{2}$ Pa。基于图像的分割得出胶原的体积分数为 $\\phi_{c} = 0.38$，透明质酸的体积分数为 $\\phi_{h} = 0.62$。\n\n在施加于ECM上的均匀、单轴、宏观柯西应力 $\\sigma_{\\mathrm{app}} = 1.5 \\times 10^{2}$ Pa 作用下，CLSM位移场解析出感兴趣区域的平均轴向工程应变为 $\\varepsilon_{\\mathrm{meas}} = 0.8067$。\n\n从各相的胡克定律以及Voigt（等应变）和Reuss（等应力）边界的适当均质化假设出发，推导计算每种边界条件下有效复合杨氏模量 $E_{\\mathrm{eff}}$ 所需的表达式。然后，利用上述CLSM微观力学测量数据，计算表观有效模量 $E_{\\mathrm{meas}} = \\sigma_{\\mathrm{app}} / \\varepsilon_{\\mathrm{meas}}$，并确定哪个边界提供了更接近 $E_{\\mathrm{meas}}$ 的估计值。作为最终答案，报告与CLSM数据更匹配的边界所对应的 $E_{\\mathrm{eff}}$ 值。\n\n最终答案以帕斯卡为单位，并四舍五入至四位有效数字。",
            "solution": "ECM被建模为一个两相线性弹性复合材料，其相分别用 $c$ (胶原) 和 $h$ (透明质酸) 索引。我们假设小应变和各向同性，因此在单轴加载下，各相均遵循胡克定律，$\\sigma_{i} = E_{i} \\varepsilon_{i}$，其中 $i \\in \\{c,h\\}$。\n\n为了获得有效模量 $E_{\\mathrm{eff}}$ 的边界，我们考虑两种经典的均质化极限：\n\n1. Voigt边界 (等应变): 在并联载荷分担模式下，各相的应变是均匀的，$\\varepsilon_{c} = \\varepsilon_{h} = \\varepsilon$。复合材料的应力是各相应力的体积分数加权和，\n$$\n\\sigma = \\phi_{c} \\sigma_{c} + \\phi_{h} \\sigma_{h} = \\phi_{c} E_{c} \\varepsilon + \\phi_{h} E_{h} \\varepsilon = \\left( \\phi_{c} E_{c} + \\phi_{h} E_{h} \\right) \\varepsilon.\n$$\n因此，Voigt有效模量为\n$$\nE_{\\mathrm{V}} = \\phi_{c} E_{c} + \\phi_{h} E_{h}.\n$$\n\n2. Reuss边界 (等应力): 在串联载荷分担模式下，各相的应力是均匀的，$\\sigma_{c} = \\sigma_{h} = \\sigma$。复合材料的应变是各相应变的体积分数加权和，\n$$\n\\varepsilon = \\phi_{c} \\varepsilon_{c} + \\phi_{h} \\varepsilon_{h} = \\phi_{c} \\frac{\\sigma}{E_{c}} + \\phi_{h} \\frac{\\sigma}{E_{h}} = \\sigma \\left( \\frac{\\phi_{c}}{E_{c}} + \\frac{\\phi_{h}}{E_{h}} \\right).\n$$\n因此，Reuss有效模量为\n$$\nE_{\\mathrm{R}} = \\left( \\frac{\\phi_{c}}{E_{c}} + \\frac{\\phi_{h}}{E_{h}} \\right)^{-1}.\n$$\n\n现在我们使用给定的参数 $\\phi_{c} = 0.38$, $\\phi_{h} = 0.62$, $E_{c} = 1.8 \\times 10^{3}$ Pa, 和 $E_{h} = 1.2 \\times 10^{2}$ Pa 来计算这些边界。\n\nVoigt边界：\n$$\nE_{\\mathrm{V}} = \\phi_{c} E_{c} + \\phi_{h} E_{h} = (0.38)(1.8 \\times 10^{3}) + (0.62)(1.2 \\times 10^{2}).\n$$\n计算每一项：\n$$\n(0.38)(1.8 \\times 10^{3}) = 684 \\quad \\text{Pa}, \\qquad (0.62)(1.2 \\times 10^{2}) = 74.4 \\quad \\text{Pa}.\n$$\n因此，\n$$\nE_{\\mathrm{V}} = 684 + 74.4 = 758.4 \\quad \\text{Pa}.\n$$\n\nReuss边界：\n$$\nE_{\\mathrm{R}} = \\left( \\frac{0.38}{1.8 \\times 10^{3}} + \\frac{0.62}{1.2 \\times 10^{2}} \\right)^{-1}.\n$$\n使用精确的分数运算计算括号内的和：\n$$\n\\frac{0.38}{1.8 \\times 10^{3}} = \\frac{38}{180000} = \\frac{19}{90000}, \\qquad \\frac{0.62}{1.2 \\times 10^{2}} = \\frac{62}{12000} = \\frac{31}{6000}.\n$$\n和：\n$$\n\\frac{19}{90000} + \\frac{31}{6000} = \\frac{19}{90000} + \\frac{465}{90000} = \\frac{484}{90000}.\n$$\n因此，\n$$\nE_{\\mathrm{R}} = \\left( \\frac{484}{90000} \\right)^{-1} = \\frac{90000}{484} \\approx 185.950413223 \\quad \\text{Pa}.\n$$\n\n接下来，我们根据CLSM微观力学数据计算表观有效模量。在施加应力 $\\sigma_{\\mathrm{app}} = 1.5 \\times 10^{2}$ Pa 下测得的轴向应变为 $\\varepsilon_{\\mathrm{meas}} = 0.8067$，所以\n$$\nE_{\\mathrm{meas}} = \\frac{\\sigma_{\\mathrm{app}}}{\\varepsilon_{\\mathrm{meas}}} = \\frac{1.5 \\times 10^{2}}{0.8067} \\approx 186.0359 \\quad \\text{Pa}.\n$$\n\n现在我们通过比较绝对差值来评估哪个边界更符合CLSM的估计值：\n$$\n|E_{\\mathrm{V}} - E_{\\mathrm{meas}}| = |758.4 - 186.0359| \\approx 572.3641 \\quad \\text{Pa},\n$$\n$$\n|E_{\\mathrm{R}} - E_{\\mathrm{meas}}| = |185.9504 - 186.0359| \\approx 0.0855 \\quad \\text{Pa}.\n$$\nReuss边界显然更接近从CLSM推导出的模量，这表明在测量条件下，载荷分担方式类似于等应力情况，与柔性凝胶主导变形的情况一致。\n\n因此，要报告的有效模量是Reuss边界值 $E_{\\mathrm{R}} \\approx 185.9504$ Pa。按要求四舍五入到四位有效数字，得到\n$$\nE_{\\mathrm{eff}} = 186.0 \\quad \\text{Pa}.\n$$",
            "answer": "$$\\boxed{186.0}$$"
        },
        {
            "introduction": "掌握了分子粘附的动力学和基质的宏观力学特性后，我们自然会问：细胞如何在这样一个复杂而不均匀的环境中选择其迁移路径？细胞的迁移可能遵循某种“最优”策略，以平衡移动距离和克服基质力学阻力所需能量消耗。本练习将指导你从第一性原理出发，构建一个描述这种权衡的数学目标泛函，并将其离散化，最终通过编写计算程序来模拟细胞在异质基质中的最优侵袭路径 。",
            "id": "4162313",
            "problem": "一个侵袭性癌细胞在异质性细胞外基质（ECM）中迁移。假设该 ECM 在一个二维域上表现出由场 $E(\\mathbf{x})$ 给出的空间变化的弹性模量。该细胞在低雷诺数下准静态地前进，其主要的机械能耗是其在突出时形变并粘附于基质所需的功，这与牛顿第二定律、功的定义 $W = \\int \\mathbf{F} \\cdot d\\mathbf{x}$ 以及应力通过 $E(\\mathbf{x})$ 与应变成比例的线性弹性理论相一致。基本假设如下：\n- 局部阻力与基质刚度和接触依赖的摩擦力成正比。\n- 移动所需的瞬时机械功率与阻力和速度的乘积成正比。\n- 在一条路径上，累积的机械能耗是沿该曲线对局部成本的积分。\n\n从这些原理出发，推导出一个针对路径 $\\Gamma$ 的无量纲目标泛函，该泛函使用位置依赖的加权方法来平衡几何路径长度和由 $E(\\mathbf{x})$ 产生的机械能耗。使用特征长度 $L_0$ 对距离进行无量纲化，并使用特征模量 $E_0$ 对刚度进行无量纲化。设该平衡由正常数权重 $w_L$ 和 $w_M$ 以及刚度依赖性中的非线性指数 $\\beta > 0$ 控制。您的推导必须以沿 $\\Gamma$ 的线积分形式清晰地陈述泛函形式，并且必须是无量纲的。从第一性原理出发，解释由 $E(\\mathbf{x})$ 编码的异质性如何在该泛函下塑造最优路径，并使用变分法来证明空间加权在最优路径中引起了类似折射的行为。\n\n然后，在一个大小为 $N \\times N$ 的方形网格上实现一个数值程序，该程序使用 8 连通性来近似计算在指定的起始和结束网格节点之间，您推导的目标泛函的最小值。通过为每条边赋予一个权重来离散化积分，该权重等于局部被积函数的梯形法则近似值乘以欧几里得边长。在网格图上使用 Dijkstra 算法来获得最小目标值。\n\n使用以下测试套件（在所选的 $L_0$ 和 $E_0$ 标度下，所有量均为无量纲）：\n- 所有测试的通用参数：$N = 50$，$L_0 = 1$，$E_0 = 1$，$w_L = 1$，$w_M = 2$，$\\beta = 1$。\n- 测试 1 (均匀基质)：所有网格节点的 $E(\\mathbf{x}) = 1$。起点为 $(0, 0)$，终点为 $(49, 49)$。\n- 测试 2 (刚性水平带)：第 24 行和第 25 行的 $E(\\mathbf{x}) = 10$，其他地方的 $E(\\mathbf{x}) = 1$。起点为 $(0, 0)$，终点为 $(49, 49)$。\n- 测试 3 (垂直刚度梯度)：$E(\\mathbf{x}) = 1 + 3 \\cdot \\frac{y}{49}$，其中 $y$ 是行索引（底部 $y = 0$，顶部 $y = 49$）。起点为 $(25, 0)$，终点为 $(25, 49)$。\n- 测试 4 (刚性基质中的软性走廊)：除第 25 列 $E(\\mathbf{x}) = 0.5$ 外，其他所有地方的 $E(\\mathbf{x}) = 100$。起点为 $(0, 25)$，终点为 $(49, 25)$。\n\n您的程序必须计算每个测试用例的最小目标值，并将结果输出为无量纲浮点数，保留六位小数。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。不应打印任何其他文本。",
            "solution": "我们从适用于异质环境中细胞迁移的基本力学原理开始。相关的基础是牛顿第二定律、线性弹性和功-能关系。\n\n在低雷诺数下，惯性效应可以忽略不计，细胞以准静态方式前进。机械能耗主要用于克服由基质变形和粘附产生的阻力。单位长度上的局部阻力，记为 $F_r(\\mathbf{x})$，通过接触力学和摩擦耦合与基质刚度 $E(\\mathbf{x})$ 成比例。具体来说，在线性弹性理论下，应力 $\\sigma$ 通过 $\\sigma = E(\\mathbf{x}) \\epsilon$ 与应变 $\\epsilon$ 成比例。突出结构必须局部地使基质变形才能前进；因此，能量耗散率取决于 $E(\\mathbf{x})$ 和细胞的速度 $v$。瞬时机械功率满足 $P(\\mathbf{x}) \\propto F_r(\\mathbf{x}) v$。在一个轨迹段 $d\\mathbf{x}$ 上，功的微分为 $dW = F_r(\\mathbf{x}) \\, d\\ell$，其中 $d\\ell$ 是弧长微分。\n\n为了平衡几何与力学，我们定义一条由弧长 $s$ 参数化的路径 $\\Gamma$，其位置为 $\\mathbf{x}(s)$。几何长度的贡献通过对 $d\\ell$ 积分来捕捉。沿路径的机械能耗通过对 $E(\\mathbf{x})$ 的一个正函数积分来捕捉。为了形成一个无量纲目标，我们引入特征长度 $L_0$ 和特征刚度 $E_0$，并用正常数系数 $w_L$ 和 $w_M$ 对各项进行加权。根据经验，刚度的增加可能引起机械阻力的非线性增长；我们用一个幂律指数 $\\beta > 0$ 来对此建模。\n\n一个平衡几何和力学效应的无量纲被积函数是\n$$\nm(\\mathbf{x}) = w_L + w_M \\left( \\frac{E(\\mathbf{x})}{E_0} \\right)^{\\beta}.\n$$\n那么，路径 $\\Gamma$ 的无量纲目标泛函是\n$$\nJ[\\Gamma] = \\int_{\\Gamma} m(\\mathbf{x}) \\, \\frac{d\\ell}{L_0}.\n$$\n该表达式将无量纲的局部“成本”$m(\\mathbf{x})$ 按无量纲的微分长度 $d\\ell/L_0$ 加权求和。带有 $w_L$ 的项惩罚更长的几何路径；带有 $w_M$ 的项惩罚穿越更刚性区域的行为。\n\n异质性通过 $m(\\mathbf{x})$ 的空间依赖性来塑造最优路径。从变分法可知，最小化 $J[\\Gamma]$ 会在一个位置依赖的度量中产生一条测地线。考虑一个参数化 $\\mathbf{x}(t)$，其中 $t$ 是任意的；其拉格朗日量为\n$$\n\\mathcal{L}(\\mathbf{x}, \\dot{\\mathbf{x}}) = m(\\mathbf{x}) \\, \\frac{\\|\\dot{\\mathbf{x}}\\|}{L_0}.\n$$\n欧拉-拉格朗日方程意味着最优路径会弯曲以避开 $m(\\mathbf{x})$ 值较大的区域（类似于光线在具有空间变化折射率的介质中发生折射）。这可以被重写为一个关于传播时间（或累积成本）函数 $T(\\mathbf{x})$ 的程函型关系：\n$$\n\\|\\nabla T(\\mathbf{x})\\| \\, m(\\mathbf{x}) = 1,\n$$\n并带有源点的边界条件。解遵循使 $J$ 最小化的特征线，这表明更刚性的区域（$E(\\mathbf{x})$ 值高）会使最优路径偏向更软的走廊。\n\n对于网格上的数值计算，我们将域离散化为一个 $N \\times N$ 的晶格，其单位间距为 $L_0 = 1$。在每个节点 $(i,j)$，我们计算\n$$\nm_{i,j} = w_L + w_M \\left( \\frac{E_{i,j}}{E_0} \\right)^{\\beta}.\n$$\n为了离散化线积分，我们通过梯形法则乘以欧几里得边长来近似计算沿相邻节点 $(i,j)$ 和 $(i',j')$ 之间移动的成本：\n$$\nw_{(i,j)\\to(i',j')} = \\frac{m_{i,j} + m_{i',j'}}{2} \\cdot \\frac{\\Delta \\ell_{(i,j)\\to(i',j')}}{L_0},\n$$\n其中，在 8 连通性下，对于轴对齐的移动，$\\Delta \\ell_{(i,j)\\to(i',j')}$ 为 $1$，对于对角线移动，则为 $\\sqrt{2}$。在这种求积法下，从起始节点到结束节点的最小离散路径成本等于 $J$ 的最小值。在这个加权图上使用 Dijkstra 算法可以为每个测试用例得出最小的 $J$ 值。\n\n我们现在指定测试套件并讨论预期的影响：\n- 测试 1 使用 $E(\\mathbf{x}) = 1$，因此 $m(\\mathbf{x})$ 是一个常数：$m(\\mathbf{x}) = w_L + w_M \\cdot 1^{\\beta} = w_L + w_M$。在 8 连通性下，最优路径是直线对角线路径，总目标值等于常数 $m$ 乘以几何长度。\n- 测试 2 在第 24 和 25 行引入了一个刚性带，其 $E(\\mathbf{x}) = 10$，导致该带内的 $m$ 值大得多。最优路径会绕过该带以减少机械成本，在有利的情况下接受额外的几何长度。\n- 测试 3 具有垂直梯度 $E(\\mathbf{x}) = 1 + 3 \\cdot \\frac{y}{49}$，因此刚度向上增加。根据变分法，可以预期路径会停留在较软（较低 $y$ 值）的区域，并在稍后上升，以此用增加的几何距离换取减少的机械能耗。\n- 测试 4 具有一个几乎均匀刚性的基质（$E(\\mathbf{x}) = 100$），除了在第 25 列有一个软性走廊，其 $E(\\mathbf{x}) = 0.5$。该走廊创造了一个低 $m$ 值的通道，最优路径会紧密跟随它以最小化机械成本，即使存在其他几何上的替代路径。\n\n使用通用参数 $N = 50$，$L_0 = 1$，$E_0 = 1$，$w_L = 1$，$w_M = 2$ 和 $\\beta = 1$，程序通过 Dijkstra 算法计算指定起始和结束节点的最小目标值，并以要求的单行格式输出四个无量纲结果，保留六位小数。该计算过程实现了所推导的泛函，并演示了 $E(\\mathbf{x})$ 的异质性如何塑造最优路径。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef dijkstra_min_objective(m_field, start, goal):\n    \"\"\"\n    Compute minimal path integral on a grid using Dijkstra's algorithm with 8-connectivity.\n    Edge weights are trapezoidal averages of m_field times Euclidean edge lengths.\n    \"\"\"\n    nrows, ncols = m_field.shape\n    # Distance (objective) array\n    dist = np.full((nrows, ncols), np.inf, dtype=float)\n    visited = np.zeros((nrows, ncols), dtype=bool)\n\n    # Priority queue: (current_cost, (i, j))\n    pq = []\n    si, sj = start\n    gi, gj = goal\n    dist[si, sj] = 0.0\n    heapq.heappush(pq, (0.0, (si, sj)))\n\n    # Neighbor offsets and corresponding Euclidean distances\n    neighbors = [\n        (-1, -1, np.sqrt(2.0)),\n        (-1,  0, 1.0),\n        (-1,  1, np.sqrt(2.0)),\n        ( 0, -1, 1.0),\n        ( 0,  1, 1.0),\n        ( 1, -1, np.sqrt(2.0)),\n        ( 1,  0, 1.0),\n        ( 1,  1, np.sqrt(2.0)),\n    ]\n\n    while pq:\n        current_cost, (i, j) = heapq.heappop(pq)\n        if visited[i, j]:\n            continue\n        visited[i, j] = True\n\n        if (i, j) == (gi, gj):\n            return current_cost  # Found minimal objective to goal\n\n        mi = m_field[i, j]\n        for di, dj, dlen in neighbors:\n            ni, nj = i + di, j + dj\n            if 0 = ni  nrows and 0 = nj  ncols:\n                if visited[ni, nj]:\n                    continue\n                mn = m_field[ni, nj]\n                # Trapezoidal rule for integrand times edge length\n                edge_weight = 0.5 * (mi + mn) * dlen\n                new_cost = current_cost + edge_weight\n                if new_cost  dist[ni, nj]:\n                    dist[ni, nj] = new_cost\n                    heapq.heappush(pq, (new_cost, (ni, nj)))\n\n    # If goal not reachable (should not happen with full connectivity), return inf\n    return float('inf')\n\ndef construct_m_field(E_field, wL=1.0, wM=2.0, beta=1.0, E0=1.0):\n    \"\"\"\n    Construct the dimensionless local cost field m(x) = wL + wM * (E/E0)^beta.\n    \"\"\"\n    return wL + wM * (E_field / E0) ** beta\n\ndef test_cases():\n    N = 50\n    wL = 1.0\n    wM = 2.0\n    beta = 1.0\n    E0 = 1.0\n\n    cases = []\n\n    # Test 1: Uniform matrix E = 1 everywhere\n    E1 = np.ones((N, N), dtype=float)\n    start1 = (0, 0)\n    goal1 = (N - 1, N - 1)\n    cases.append((E1, start1, goal1, wL, wM, beta, E0))\n\n    # Test 2: Stiff horizontal band at rows 24 and 25, E=10; elsewhere E=1\n    E2 = np.ones((N, N), dtype=float)\n    E2[24, :] = 10.0\n    E2[25, :] = 10.0\n    start2 = (0, 0)\n    goal2 = (N - 1, N - 1)\n    cases.append((E2, start2, goal2, wL, wM, beta, E0))\n\n    # Test 3: Vertical stiffness gradient: E = 1 + 3 * (y/49), where y increases from bottom (y=0) to top (y=49).\n    # This means E is soft at the bottom and stiff at the top.\n    # The path is from bottom-middle to top-middle.\n    y_indices_numpy = np.arange(N, dtype=float) # In numpy, index 0 is top, 49 is bottom.\n    # We want y-coordinate to be 0 at bottom (row 49) and 49 at top (row 0). So, y_coord = (N-1) - row_index.\n    y_coords = (N - 1) - y_indices_numpy\n    y_frac = y_coords / (N - 1)\n    E3_gradient = 1.0 + 3.0 * y_frac\n    E3 = np.tile(E3_gradient.reshape(N, 1), (1, N)) # E=4 at top (row 0), E=1 at bottom (row 49)\n    # In (row, col) indexing, path is from (49, 25) to (0, 25).\n    start3 = (N - 1, 25)\n    goal3 = (0, 25)\n    cases.append((E3, start3, goal3, wL, wM, beta, E0))\n\n    # Test 4: Soft corridor at column 25, stiff elsewhere E=100, corridor E=0.5\n    # Path is horizontal along row 25.\n    E4 = np.full((N, N), 100.0, dtype=float)\n    E4[:, 25] = 0.5\n    start4 = (25, 0)\n    goal4 = (25, N - 1)\n    cases.append((E4, start4, goal4, wL, wM, beta, E0))\n\n    return cases\n\ndef solve():\n    cases = test_cases()\n    results = []\n    for E_field, start, goal, wL, wM, beta, E0 in cases:\n        m_field = construct_m_field(E_field, wL=wL, wM=wM, beta=beta, E0=E0)\n        min_obj = dijkstra_min_objective(m_field, start, goal)\n        results.append(f\"{min_obj:.6f}\")\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}