{
    "hands_on_practices": [
        {
            "introduction": "成功的假肢适配在很大程度上取决于残肢与接受腔之间的机械交互。本练习将假肢系统简化为一个由多个弹性元件串联而成的力学模型，用以分析“活塞运动”——即使用者在行走过程中感受到的残肢在接受腔内的相对位移。通过运用材料变形和串联弹簧系统的基本原理，您将定量计算这一位移，并评估其是否能被用户感知，从而将工程力学分析与临床实际效果紧密联系起来 。",
            "id": "4200494",
            "problem": "经胫骨假肢被建模为一个由线性弹性部件组成的轴向链：一个顺应性义足、一个薄壁金属连接管，以及将接受腔连接到残肢的接受腔-内衬-悬吊系统界面。将每个部件视为一个细长元件，在步态支撑期承受相同的压缩力作用下，发生微小的准静态轴向变形。此处，残肢感知到的“活塞运动”定义为接受腔与残肢之间的轴向相对运动，其大小等于接受腔-内衬-悬吊系统界面内的轴向变形之和。\n\n假设连接管是一根直的薄壁钛合金管，长度为 $0.40$ 米，外径为 $0.030$ 米，壁厚为 $0.0020$ 米，杨氏模量为 $110 \\times 10^{9}$ Pa。义足、内衬和悬吊系统均被近似为串联的线性弹簧，其轴向刚度分别为 $1.0 \\times 10^{6}$ N/m、$1.5 \\times 10^{6}$ N/m 和 $3.0 \\times 10^{6}$ N/m。该个体的体重质量为 $78$ kg。在支撑中期，垂直地面反作用力 (GRF) 的峰值是体重的 $1.25$ 倍。为进行心理物理学解释，采用残肢-接受腔相对运动的最小可觉察轴向位移阈值 (JND) 为 $0.35$ mm。\n\n从轴向受载弹性构件的应力、应变和位移相关的基本定义出发，并根据串联元件在共同轴向载荷下受力相同而总位移为各部分位移之和的规则，推导在 GRF 峰值时连接管的轴向位移和活塞运动位移。然后将可检测性指数 $D$ 定义为 GRF 峰值时的活塞运动位移与 JND 的比值。仅报告可检测性指数 $D$。\n\n最终答案以无量纲数表示。将答案四舍五入至四位有效数字。",
            "solution": "问题陈述已经过严格验证，并被认为是有效的。它基于固体力学和生物力学原理，具有科学依据，问题适定，有唯一且有意义的解，是客观的，并包含一套完整且一致的数据以供规范求解。诸如线性弹性和准静态加载等假设对于此类问题是标准的。因此，我们可以继续进行求解。\n\n问题要求计算可检测性指数 $D$，该指数定义为在地面反作用力 (GRF) 峰值时的活塞运动位移 $\\delta_{piston}$ 与最小可觉察轴向位移阈值 $\\delta_{JND}$ 的比值。计算需要几个步骤，从基本原理开始。\n\n首先，我们计算峰值压缩力，即 GRF 峰值 $F_{GRF}$。GRF 被设定为体重的 $1.25$ 倍。体重质量为 $m = 78$ kg。使用标准重力加速度 $g = 9.81 \\, \\text{m/s}^2$，体重 $W$ 为：\n$$W = m g = (78 \\, \\text{kg}) \\times (9.81 \\, \\text{m/s}^2) = 765.18 \\, \\text{N}$$\n那么 GRF 峰值为：\n$$F_{GRF} = 1.25 \\times W = 1.25 \\times 765.18 \\, \\text{N} = 956.475 \\, \\text{N}$$\n这个力通过假肢的所有部件进行轴向传递，这些部件被建模为串联形式。\n\n其次，根据问题陈述的要求，我们推导在 GRF 峰值时连接管的轴向位移 $\\delta_p$。一个细长弹性构件在力 $F$ 作用下的轴向位移由公式 $\\delta = \\frac{FL}{AE}$ 给出，其中 $L$ 是长度，$A$ 是横截面积，$E$ 是杨氏模量。\n对于连接管，我们有：\n长度 $L_p = 0.40$ m\n杨氏模量 $E_p = 110 \\times 10^{9}$ Pa\n连接管是一个薄壁管，外径 $d_o = 0.030$ m，壁厚 $t = 0.0020$ m。外半径为 $r_o = d_o/2 = 0.015$ m。内半径为 $r_i = r_o - t = 0.015 \\, \\text{m} - 0.0020 \\, \\text{m} = 0.013$ m。\n横截面积 $A_p$ 为：\n$$A_p = \\pi (r_o^2 - r_i^2) = \\pi ((0.015 \\, \\text{m})^2 - (0.013 \\, \\text{m})^2)$$\n$$A_p = \\pi (0.000225 \\, \\text{m}^2 - 0.000169 \\, \\text{m}^2) = \\pi (5.6 \\times 10^{-5} \\, \\text{m}^2) \\approx 1.7593 \\times 10^{-4} \\, \\text{m}^2$$\n现在，我们可以计算连接管的轴向位移：\n$$\\delta_p = \\frac{F_{GRF} L_p}{A_p E_p} = \\frac{(956.475 \\, \\text{N}) \\times (0.40 \\, \\text{m})}{(\\pi \\times 5.6 \\times 10^{-5} \\, \\text{m}^2) \\times (110 \\times 10^{9} \\, \\text{Pa})}$$\n$$\\delta_p \\approx \\frac{382.59 \\, \\text{N}\\cdot\\text{m}}{1.9352 \\times 10^7 \\, \\text{N}} \\approx 1.977 \\times 10^{-5} \\, \\text{m}$$\n该位移约等于 $0.020$ mm。\n\n第三，我们推导活塞运动位移 $\\delta_{piston}$。问题将其定义为接受腔-内衬-悬吊系统界面内的轴向变形之和。对此有贡献的部件是内衬和悬吊系统，它们被建模为线性弹簧，刚度分别为 $k_l = 1.5 \\times 10^{6}$ N/m 和 $k_s = 3.0 \\times 10^{6}$ N/m。由于它们是串联的，它们承受相同的轴向力 $F_{GRF}$。\n弹簧的变形由 $\\delta = F/k$ 给出。因此，总活塞运动位移是各个弹簧变形的总和：\n$$\\delta_{piston} = \\delta_l + \\delta_s = \\frac{F_{GRF}}{k_l} + \\frac{F_{GRF}}{k_s} = F_{GRF} \\left( \\frac{1}{k_l} + \\frac{1}{k_s} \\right)$$\n代入数值：\n$$\\delta_{piston} = (956.475 \\, \\text{N}) \\left( \\frac{1}{1.5 \\times 10^{6} \\, \\text{N/m}} + \\frac{1}{3.0 \\times 10^{6} \\, \\text{N/m}} \\right)$$\n首先，我们计算括号中的项：\n$$\\frac{1}{1.5 \\times 10^{6}} + \\frac{1}{3.0 \\times 10^{6}} = \\frac{2}{3.0 \\times 10^{6}} + \\frac{1}{3.0 \\times 10^{6}} = \\frac{3}{3.0 \\times 10^{6}} = 1.0 \\times 10^{-6} \\, \\text{m/N}$$\n现在，我们可以求出活塞运动位移：\n$$\\delta_{piston} = 956.475 \\, \\text{N} \\times (1.0 \\times 10^{-6} \\, \\text{m/N}) = 9.56475 \\times 10^{-4} \\, \\text{m}$$\n这等于 $0.956475$ mm。\n\n最后，我们计算可检测性指数 $D$。这是活塞运动位移与最小可觉察位移阈值 $\\delta_{JND} = 0.35$ mm 的比值。\n首先，我们必须确保单位一致。$\\delta_{JND} = 0.35 \\, \\text{mm} = 0.35 \\times 10^{-3}$ m。\n$$D = \\frac{\\delta_{piston}}{\\delta_{JND}} = \\frac{9.56475 \\times 10^{-4} \\, \\text{m}}{0.35 \\times 10^{-3} \\, \\text{m}} = \\frac{9.56475}{3.5}$$\n$$D \\approx 2.7327857...$$\n问题要求将答案四舍五入到四位有效数字。\n$$D \\approx 2.733$$\n可检测性指数是一个无量纲量，符合要求。",
            "answer": "$$\\boxed{2.733}$$"
        },
        {
            "introduction": "本练习将我们的关注点从单个部件的力学性能提升至整个“人-假肢”系统的动态稳定性。我们将运用线性倒立摆模型（Linear Inverted Pendulum Model, LIPM）这一分析动态平衡的经典工具，并引入外推质心（Extrapolated Center of Mass, XCoM）和稳定裕度（Margin of Stability, MoS）等关键概念。通过计算稳定裕度，您将学会如何运用一个强大的预测模型来评估使用者在特定状态下是能够保持稳定，还是需要通过迈步来避免摔倒，这是步态分析与假肢设计中的一个核心议题 。",
            "id": "4200444",
            "problem": "在单腿静立期间，对一名使用被动式假脚的单侧小腿截肢者进行评估。矢状轴上的支撑基底（BoS）其前端边界在脚趾处，由一个地面接触点限定，该点距离踝关节的地面投影点的水平位置为 $x_{\\text{edge}}$，其中 $x$ 轴正方向指向前方。在同一坐标系中测得的质心（COM）的水平位置和速度分别为 $x$ 和 $\\dot{x}$。在小幅摆动期间，质心高度近似恒定为 $z_0$。重力加速度为 $g$。线性倒立摆模型（LIPM）假设小角度、刚性站姿和恒定的质心高度，因此质心的水平运动由牛顿定律以及质心位移与围绕压力中心的转动之间的几何关系所决定。\n\n仅使用适用于线性倒立摆模型的第一性原理，定义一个矢状面内的稳定裕度（MoS），该裕度能够捕捉假肢站立时的动态可行性，并确定如何根据质心状态和支撑基底边界计算其值。然后，对于以下测量值：\n$x_{\\text{edge}} = 0.20\\,\\mathrm{m}$，$x = 0.12\\,\\mathrm{m}$，$\\dot{x} = 0.80\\,\\mathrm{m/s}$，$z_0 = 0.95\\,\\mathrm{m}$，$g = 9.81\\,\\mathrm{m/s^2}$，\n选择一个选项，该选项既正确定义了MoS（包括其正负号约定），又给出了其在前向方向上的数值。\n\nA. $\\text{MoS}$ 是从 BoS 前边界到外推质心的有符号距离，$\\text{MoS} = x_{\\text{edge}} - x_{\\text{XCoM}}$，其中 $x_{\\text{XCoM}}$ 由 LIPM 的动力学一致流形定义；数值上，$\\text{MoS} \\approx -0.169\\,\\mathrm{m}$。\n\nB. $\\text{MoS}$ 是从质心投影点到 BoS 前边界的有符号距离，忽略了质心速度，$\\text{MoS} = x - x_{\\text{edge}}$；数值上，$\\text{MoS} \\approx -0.080\\,\\mathrm{m}$。\n\nC. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但外推质心的计算中速度的贡献为负；数值上，$\\text{MoS} \\approx +0.329\\,\\mathrm{m}$。\n\nD. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但使用了由 $\\omega_0 = \\sqrt{z_0/g}$ 推导出的一个较低的固有频率 $\\omega_0$；数值上，$\\text{MoS} \\approx -2.49\\,\\mathrm{m}$。\n\nE. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但外推质心的计算中省略了质心位置；数值上，$\\text{MoS} \\approx -0.049\\,\\mathrm{m}$。",
            "solution": "用户希望我扮演一位严谨的STEM教授来解决一个生物力学问题。我将首先验证问题陈述的有效性，如果有效，则继续进行详细解答。\n\n### 第一步：提取已知条件\n- **模型：** 用于单侧小腿截肢者单腿静立的线性倒立摆模型（LIPM）。\n- **假设：** 小角度、刚性站姿、恒定的质心高度（$z_0$）。\n- **坐标系：** 矢状面，x轴正方向指向前方，原点位于踝关节的地面投影点。\n- **边界条件：** 支撑基底（BoS）的前边界位于 $x_{\\text{edge}}$。\n- **状态变量：**\n  - 质心水平位置：$x$\n  - 质心水平速度：$\\dot{x}$\n- **常数和参数：**\n  - $x_{\\text{edge}} = 0.20\\,\\mathrm{m}$\n  - $x = 0.12\\,\\mathrm{m}$\n  - $\\dot{x} = 0.80\\,\\mathrm{m/s}$\n  - $z_0 = 0.95\\,\\mathrm{m}$\n  - $g = 9.81\\,\\mathrm{m/s^2}$\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题基于线性倒立摆模型（LIPM），这是生物力学和机器人学中动态稳定性分析的基石。质心（COM）、支撑基底（BoS）和稳定裕度（MoS）等概念在此背景下是标准且明确定义的。其基础物理学（应用于摆的牛顿定律）是基础性的。所提供的数值对于人体受试者来说是生理上现实的。该问题具有科学合理性。\n2.  **良态问题（Well-Posed）：** 该问题提供了一个明确的目标：基于LIPM定义MoS并计算其值。推导唯一解所需的所有数据（$x$、$\\dot{x}$、$z_0$、$g$、$x_{\\text{edge}}$）均已提供。\n3.  **客观性：** 问题以精确、技术性的语言陈述，没有主观或模糊的术语。\n4.  **完整性和一致性：** 问题的设定是自洽的，没有矛盾。单位是一致的（国际单位制）。\n\n### 第三步：结论与行动\n问题陈述有效。我将从第一性原理开始推导解答。\n\n### 稳定裕度（MoS）的推导\n\n线性倒立摆模型（LIPM）用于分析质心（COM）的动力学。在此模型中，身体被简化为一个点质量 $m$，该点质量位于地面上方恒定高度 $z_0$ 处，并围绕地面上一个称为压力中心（CoP）的点进行摆动，该点的位置为 $x_{CoP}$。\n\n质心的水平运动由牛顿第二定律 $F_x = m\\ddot{x}$ 决定。水平地面反作用力 $F_x$ 可以与身体的几何形状相关联。假设角度很小，水平力 $F_x$ 与竖直力 $F_z$（为保持平衡，等于 $mg$）之比，等于质心相对于压力中心的水平位移与质心高度之比：\n$$ \\frac{F_x}{F_z} = \\frac{x - x_{CoP}}{z_0} $$\n代入 $F_x = m\\ddot{x}$ 和 $F_z = mg$：\n$$ \\frac{m\\ddot{x}}{mg} = \\frac{x - x_{CoP}}{z_0} $$\n这简化为LIPM的基本运动方程：\n$$ \\ddot{x} = \\frac{g}{z_0} (x - x_{CoP}) $$\n我们可以将倒立摆的固有频率定义为 $\\omega_0 = \\sqrt{g/z_0}$。方程变为：\n$$ \\ddot{x} = \\omega_0^2 (x - x_{CoP}) $$\n为了保持平衡，压力中心（CoP）必须被主动控制在支撑基底（BoS）内。评估动态稳定性的一个关键概念是外推质心（XCoM），此处表示为 $x_{XCoM}$。XCoM 代表了为了使身体完全停止（即停止质心的前向动量）而必须放置压力中心（CoP）的地面位置。它是一个将质心的位置和速度组合成单一空间度量的量。\n\nXCoM 定义为：\n$$ x_{XCoM} = x + \\frac{\\dot{x}}{\\omega_0} $$\n只要这个所需的CoP位置 $x_{XCoM}$ 位于解剖学上的BoS内，动态稳定性就能维持。\n\n稳定裕度（MoS）是从BoS的边界到XCoM的有符号距离。对于前向，边界在 $x_{\\text{edge}}$。正的MoS表示XCoM位于BoS内部，表明是稳定的。负的MoS表示XCoM位于BoS外部，表明需要采取纠正措施（例如，迈出一步）以避免摔倒。其定义为：\n$$ \\text{MoS} = x_{\\text{edge}} - x_{XCoM} $$\n\n### 数值计算\n\n首先，我们计算固有频率 $\\omega_0$：\n$$ \\omega_0 = \\sqrt{\\frac{g}{z_0}} = \\sqrt{\\frac{9.81\\,\\mathrm{m/s^2}}{0.95\\,\\mathrm{m}}} \\approx \\sqrt{10.3263\\,\\mathrm{s^{-2}}} \\approx 3.21346\\,\\mathrm{s^{-1}} $$\n\n接下来，我们计算外推质心的位置 $x_{XCoM}$：\n$$ x_{XCoM} = x + \\frac{\\dot{x}}{\\omega_0} = 0.12\\,\\mathrm{m} + \\frac{0.80\\,\\mathrm{m/s}}{3.21346\\,\\mathrm{s^{-1}}} \\approx 0.12\\,\\mathrm{m} + 0.24895\\,\\mathrm{m} = 0.36895\\,\\mathrm{m} $$\n\n最后，我们计算稳定裕度 MoS：\n$$ \\text{MoS} = x_{\\text{edge}} - x_{XCoM} = 0.20\\,\\mathrm{m} - 0.36895\\,\\mathrm{m} = -0.16895\\,\\mathrm{m} $$\n保留三位有效数字，我们得到 $\\text{MoS} \\approx -0.169\\,\\mathrm{m}$。\n\n### 选项评估\n\n**A. $\\text{MoS}$ 是从 BoS 前边界到外推质心的有符号距离，$\\text{MoS} = x_{\\text{edge}} - x_{\\text{XCoM}}$，其中 $x_{\\text{XCoM}}$ 由 LIPM 的动力学一致流形定义；数值上，$\\text{MoS} \\approx -0.169\\,\\mathrm{m}$。**\n- **定义：** 定义 $\\text{MoS} = x_{\\text{edge}} - x_{\\text{XCoM}}$ 是正确的。短语“动力学一致流形”正确地描述了 XCoM 是捕捉 LIPM 系统状态的变量。\n- **数值：** 计算出的值 $\\text{MoS} \\approx -0.169\\,\\mathrm{m}$ 与我们的推导相符。\n- **结论：** **正确**。\n\n**B. $\\text{MoS}$ 是从质心投影点到 BoS 前边界的有符号距离，忽略了质心速度，$\\text{MoS} = x - x_{\\text{edge}}$；数值上，$\\text{MoS} \\approx -0.080\\,\\mathrm{m}$。**\n- **定义：** 公式 $\\text{MoS} = x - x_{\\text{edge}}$ 代表一个*静态*稳定裕度，因为它完全忽略了运动的动态分量（$\\dot{x}$）。这与问题中使用LIPM进行动态分析的前提不一致。此外，其正负号约定与标准定义相反。\n- **数值：** 对于这个错误的公式，计算 $0.12\\,\\mathrm{m} - 0.20\\,\\mathrm{m} = -0.080\\,\\mathrm{m}$ 在算术上是正确的。\n- **结论：** **不正确**。对于动态稳定性分析，该定义在物理上是不正确的。\n\n**C. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但外推质心的计算中速度的贡献为负；数值上，$\\text{MoS} \\approx +0.329\\,\\mathrm{m}$。**\n- **定义：** 这意味着一个错误的 XCoM 定义，可能是 $x_{XCoM} = x - \\dot{x}/\\omega_0$。这在物理上是不正确的，因为正的速度必须使外推位置在正方向上增加。\n- **数值：** 使用这个错误的定义：$x_{XCoM} = 0.12\\,\\mathrm{m} - 0.24895\\,\\mathrm{m} = -0.12895\\,\\mathrm{m}$。那么，$\\text{MoS} = 0.20\\,\\mathrm{m} - (-0.12895\\,\\mathrm{m}) = 0.32895\\,\\mathrm{m} \\approx +0.329\\,\\mathrm{m}$。该数值与错误的定义是一致的。\n- **结论：** **不正确**。$x_{XCoM}$ 的公式是错误的。\n\n**D. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但使用了由 $\\omega_0 = \\sqrt{z_0/g}$ 推导出的一个较低的固有频率 $\\omega_0$；数值上，$\\text{MoS} \\approx -2.49\\,\\mathrm{m}$。**\n- **定义：** 固有频率的定义被给出为 $\\omega_0 = \\sqrt{z_0/g}$。正确的定义是 $\\omega_0 = \\sqrt{g/z_0}$。所提议的公式是特征时间周期的倒数，而不是角频率，并且在量纲上对于频率来说是不正确的。\n- **数值：** 使用这个错误的值，$\\omega_0' = \\sqrt{0.95/9.81} \\approx 0.3112\\,\\mathrm{s}$（注意单位）。用这个值计算得到 $x_{XCoM} = 0.12 + 0.80/0.3112 \\approx 2.691\\,\\mathrm{m}$。$\\text{MoS} = 0.20 - 2.691 = -2.491\\,\\mathrm{m} \\approx -2.49\\,\\mathrm{m}$。该数值与错误的前提是一致的。\n- **结论：** **不正确**。$\\omega_0$ 的公式根本上是错误的。\n\n**E. $\\text{MoS}$ 是 $x_{\\text{edge}} - x_{\\text{XCoM}}$，但外推质心的计算中省略了质心位置；数值上，$\\text{MoS} \\approx -0.049\\,\\mathrm{m}$。**\n- **定义：** 这意味着一个错误的 XCoM 定义，$x_{XCoM} = \\dot{x}/\\omega_0$。XCoM 必须是*从*当前位置 $x$ 进行的外推；省略 $x$ 使该定义不完整且在物理上无意义。\n- **数值：** 使用这个错误的定义：$x_{XCoM} = 0.24895\\,\\mathrm{m}$。那么，$\\text{MoS} = 0.20\\,\\mathrm{m} - 0.24895\\,\\mathrm{m} = -0.04895\\,\\mathrm{m} \\approx -0.049\\,\\mathrm{m}$。该数值与错误的定义是一致的。\n- **结论：** **不正确**。$x_{XCoM}$ 的公式是不完整的。",
            "answer": "$$\n\\boxed{A}\n$$"
        },
        {
            "introduction": "为了精确设计和评估假肢，我们必须能够从实验数据中准确地表征其机械性能。这项高级练习将引导您进入系统辨识这一生物力学研发领域的核心计算技术。您将通过编写代码，实现一个基于最小二乘法优化的参数辨识算法，从模拟的实验数据中提取假肢足踝的等效质量 $m$、刚度 $k$ 和阻尼 $c$ 等关键参数。这项实践将锻炼您将物理模型转化为计算框架，并用其解决实际工程问题的能力 。",
            "id": "4200452",
            "problem": "您的任务是实现一个完整的、可运行的程序，为支撑期假脚的简化垂直柔度模型执行参数辨识。辨识过程必须使用最小二乘优化来最小化模拟地面反作用力（GRF）与实测地面反作用力之间的平方误差。该模型基于压力中心处假脚和下肢段的物理上合理的表示。程序必须估计参数，并按以下规定格式单行输出结果。\n\n基本原理：使用牛顿第二定律和开尔文-沃伊特 (Kelvin–Voigt) 粘弹性表示。假设垂直GRF由压力中心处足-肢垂直柔度坐标的位移、速度和加速度的线性组合加上一个静态载荷偏移量来表示。将测量的GRF表示为 $F_{\\text{meas}}(t)$，模拟的GRF表示为 $F_{\\text{sim}}(t)$。坐标位移为 $y(t)$，速度为 $ \\dot{y}(t)$，加速度为 $ \\ddot{y}(t)$。要辨识的参数向量为 $\\boldsymbol{\\theta} = [k, c, m, b]^{\\top}$，其中 $k$ 是刚度，单位为 $\\,\\mathrm{N/m}$；$c$ 是阻尼，单位为 $\\,\\mathrm{N \\cdot s/m}$；$m$ 是有效质量，单位为 $\\,\\mathrm{kg}$；$b$ 是恒定偏移，单位为 $\\,\\mathrm{N}$。在开尔文-沃伊特假设和牛顿第二定律下，假设模拟的GRF为\n$$\nF_{\\text{sim}}(t) = k\\,y(t) + c\\,\\dot{y}(t) + m\\,\\ddot{y}(t) + b.\n$$\n给定时间样本 $t_k$，其中 $k = 0,1,\\dots,N-1$，构建回归矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times 4}$，其列为 $[y(t_k), \\dot{y}(t_k), \\ddot{y}(t_k), 1]$，并求解最小二乘问题\n$$\n\\min_{\\boldsymbol{\\theta}} \\sum_{k=0}^{N-1} \\left( F_{\\text{sim}}(t_k) - F_{\\text{meas}}(t_k) \\right)^2,\n$$\n这等价于\n$$\n\\min_{\\boldsymbol{\\theta}} \\left\\| \\mathbf{A}\\,\\boldsymbol{\\theta} - \\mathbf{F} \\right\\|_2^2,\n$$\n其中 $\\mathbf{F} = [F_{\\text{meas}}(t_0), \\dots, F_{\\text{meas}}(t_{N-1})]^{\\top}$。解必须通过最小二乘优化计算。\n\n您的程序必须实现以下四个测试用例。对于每个用例，按照规定生成时间序列 $y(t)$、$\\dot{y}(t)$ 和 $\\ddot{y}(t)$，然后使用真实的参数值和定义的确定性噪声项 $\\varepsilon(t)$ 生成测量的GRF $F_{\\text{meas}}(t)$。所有量必须使用国际单位制（SI单位）的基本单位：位移以 $\\,\\mathrm{m}$ 为单位，时间以 $\\,\\mathrm{s}$ 为单位，刚度以 $\\,\\mathrm{N/m}$ 为单位，阻尼以 $\\,\\mathrm{N \\cdot s/m}$ 为单位，质量以 $\\,\\mathrm{kg}$ 为单位，GRF/偏移以 $\\,\\mathrm{N}$ 为单位。不使用角度量。程序必须使用最小二乘法为每个用例估计 $\\boldsymbol{\\theta}$，并以指定格式生成最终输出。\n\n用例 $1$（具有多谐波激励的一般情况）：\n- 真实参数：$k = 30000\\,\\mathrm{N/m}$，$c = 1200\\,\\mathrm{N\\cdot s/m}$，$m = 2.5\\,\\mathrm{kg}$，$b = 800\\,\\mathrm{N}$。\n- 信号定义：令 $A = 0.02\\,\\mathrm{m}$ 和 $f = 1.5\\,\\mathrm{Hz}$。定义\n$$\ny(t) = A \\sin(2\\pi f t) + \\tfrac{1}{2} A \\sin(4\\pi f t),\n$$\n$$\n\\dot{y}(t) = A (2\\pi f) \\cos(2\\pi f t) + \\tfrac{1}{2} A (4\\pi f) \\cos(4\\pi f t),\n$$\n$$\n\\ddot{y}(t) = -A (2\\pi f)^2 \\sin(2\\pi f t) - \\tfrac{1}{2} A (4\\pi f)^2 \\sin(4\\pi f t).\n$$\n- 噪声：$\\varepsilon(t) = E \\sin(2\\pi f_n t)$，其中 $E = 5\\,\\mathrm{N}$ 和 $f_n = 5\\,\\mathrm{Hz}$。\n- 采样：$N = 500$，$\\Delta t = 0.01\\,\\mathrm{s}$，$t_k = k \\Delta t$。\n- 测量的GRF：$F_{\\text{meas}}(t) = b + k y(t) + c \\dot{y}(t) + m \\ddot{y}(t) + \\varepsilon(t)$。\n\n用例 $2$（位移平滑阶跃的边界偏置情况）：\n- 真实参数：$k = 28000\\,\\mathrm{N/m}$，$c = 500\\,\\mathrm{N\\cdot s/m}$，$m = 2.2\\,\\mathrm{kg}$，$b = 790\\,\\mathrm{N}$。\n- 信号定义：令 $y_0 = 0.015\\,\\mathrm{m}$，$t_0 = 0.1\\,\\mathrm{s}$，和 $\\tau = 0.05\\,\\mathrm{s}$。定义\n$$\ny(t) = \\begin{cases}\n0  \\text{if } t  t_0, \\\\\ny_0 \\left( 1 - e^{-(t - t_0)/\\tau} \\right)  \\text{if } t \\ge t_0,\n\\end{cases}\n$$\n$$\n\\dot{y}(t) = \\begin{cases}\n0  \\text{if } t  t_0, \\\\\n\\frac{y_0}{\\tau} e^{-(t - t_0)/\\tau}  \\text{if } t \\ge t_0,\n\\end{cases}\n$$\n$$\n\\ddot{y}(t) = \\begin{cases}\n0  \\text{if } t  t_0, \\\\\n-\\frac{y_0}{\\tau^2} e^{-(t - t_0)/\\tau}  \\text{if } t \\ge t_0.\n\\end{cases}\n$$\n- 噪声：$\\varepsilon(t) = E \\sin(2\\pi f_n t)$，其中 $E = 2\\,\\mathrm{N}$ 和 $f_n = 3\\,\\mathrm{Hz}$。\n- 采样：$N = 500$，$\\Delta t = 0.01\\,\\mathrm{s}$，$t_k = k \\Delta t$。\n- 测量的GRF：$F_{\\text{meas}}(t) = b + k y(t) + c \\dot{y}(t) + m \\ddot{y}(t) + \\varepsilon(t)$。\n\n用例 $3$（较大阻尼的高频激励）：\n- 真实参数：$k = 40000\\,\\mathrm{N/m}$，$c = 3000\\,\\mathrm{N\\cdot s/m}$，$m = 1.8\\,\\mathrm{kg}$，$b = 850\\,\\mathrm{N}$。\n- 信号定义：令 $A = 0.015\\,\\mathrm{m}$ 和 $f = 6\\,\\mathrm{Hz}$。定义\n$$\ny(t) = A \\sin(2\\pi f t), \\quad \\dot{y}(t) = A (2\\pi f) \\cos(2\\pi f t), \\quad \\ddot{y}(t) = -A (2\\pi f)^2 \\sin(2\\pi f t).\n$$\n- 噪声：$\\varepsilon(t) = E \\sin(2\\pi f_n t)$，其中 $E = 10\\,\\mathrm{N}$ 和 $f_n = 7\\,\\mathrm{Hz}$。\n- 采样：$N = 400$，$\\Delta t = 0.005\\,\\mathrm{s}$，$t_k = k \\Delta t$。\n- 测量的GRF：$F_{\\text{meas}}(t) = b + k y(t) + c \\dot{y}(t) + m \\ddot{y}(t) + \\varepsilon(t)$。\n\n用例 $4$（样本数最少且运动学为多项式的边缘情况）：\n- 真实参数：$k = 35000\\,\\mathrm{N/m}$，$c = 1000\\,\\mathrm{N\\cdot s/m}$，$m = 2.0\\,\\mathrm{kg}$，$b = 780\\,\\mathrm{N}$。\n- 信号定义：令 $p_3 = 0.5\\,\\mathrm{m/s^3}$，$p_2 = -0.05\\,\\mathrm{m/s^2}$，$p_1 = 0\\,\\mathrm{m/s}$，$p_0 = 0\\,\\mathrm{m}$。定义\n$$\ny(t) = p_3 t^3 + p_2 t^2 + p_1 t + p_0, \\quad \\dot{y}(t) = 3 p_3 t^2 + 2 p_2 t + p_1, \\quad \\ddot{y}(t) = 6 p_3 t + 2 p_2.\n$$\n- 噪声：$\\varepsilon(t) = 0$。\n- 采样：使用确切的时间 $t \\in \\{0, 0.1, 0.2, 0.3\\}\\,\\mathrm{s}$（即 $N = 4$）。\n- 测量的GRF：$F_{\\text{meas}}(t) = b + k y(t) + c \\dot{y}(t) + m \\ddot{y}(t)$。\n\n算法要求：\n- 对于每个用例，构建矩阵 $\\mathbf{A}$（其列为 $y(t_k)$、$\\dot{y}(t_k)$、$\\ddot{y}(t_k)$ 和 $1$）和测量GRF样本的向量 $\\mathbf{F}$。\n- 使用最小二乘法求解 $\\boldsymbol{\\theta}$。任何数值稳定的最小二乘法都是可接受的（例如，使用摩尔-彭若斯伪逆 (Moore-Penrose pseudoinverse) 或正规方程的求解器）。\n- 估计的参数应以下列单位表示：$k$ 为 $\\,\\mathrm{N/m}$，$c$ 为 $\\,\\mathrm{N\\cdot s/m}$，$m$ 为 $\\,\\mathrm{kg}$，$b$ 为 $\\,\\mathrm{N}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含四个用例的串联估计参数：\n$$\n[\\hat{k}_1, \\hat{c}_1, \\hat{m}_1, \\hat{b}_1, \\hat{k}_2, \\hat{c}_2, \\hat{m}_2, \\hat{b}_2, \\hat{k}_3, \\hat{c}_3, \\hat{m}_3, \\hat{b}_3, \\hat{k}_4, \\hat{c}_4, \\hat{m}_4, \\hat{b}_4].\n$$\n\n测试套件覆盖理由：\n- 用例1是典型场景，具有多谐波内容，可激励刚度、阻尼和惯性。\n- 用例2通过 $y(t)$ 中的平滑阶跃探测近奇异行为，导致速度和加速度衰减，测试在偏置激励下的稳定性。\n- 用例3通过更高频率的内容强调阻尼，测试估计器解析 $c$ 和 $m$ 的能力。\n- 用例4测试了样本数与参数数量相等的精确数据场景，探测求解器对方形系统的处理能力。\n\n您的程序不得读取输入，并且必须使用确定性的信号和噪声。输出必须是数值浮点数。单位由数值隐式编码，并且必须与上述SI单位相对应。",
            "solution": "该问题要求为一个简化的假脚垂直柔度生物力学模型进行参数辨识。该模型基于一个开尔文-沃伊特 (Kelvin-Voigt) 粘弹性元件与一个惯性项的组合，这与牛顿第二定律一致。模拟的地面反作用力 $F_{\\text{sim}}(t)$ 表示为柔度坐标的垂直位移 $y(t)$、速度 $\\dot{y}(t)$ 和加速度 $\\ddot{y}(t)$ 的线性函数，外加一个恒定偏移。\n\n模拟力的控制方程为：\n$$\nF_{\\text{sim}}(t) = k\\,y(t) + c\\,\\dot{y}(t) + m\\,\\ddot{y}(t) + b\n$$\n在此，待辨识的参数是刚度 $k$ (单位 $\\mathrm{N/m}$)、阻尼 $c$ (单位 $\\mathrm{N \\cdot s/m}$)、有效质量 $m$ (单位 $\\mathrm{kg}$) 和静态载荷偏移 $b$ (单位 $\\mathrm{N}$)。这些参数被收集到一个向量 $\\boldsymbol{\\theta} = [k, c, m, b]^{\\top}$ 中。\n\n任务是通过最小化模拟力 $F_{\\text{sim}}(t)$ 与给定的测量力 $F_{\\text{meas}}(t)$ 之间的平方误差和来估计 $\\boldsymbol{\\theta}$。数据在离散时间点 $t_k$（其中 $k = 0, 1, \\dots, N-1$）上提供。这种表述导出了一个经典的线性最小二乘问题。\n\n在每个时间样本 $t_k$，模型方程可以写成：\n$$\nF_{\\text{sim}}(t_k) = y(t_k) k + \\dot{y}(t_k) c + \\ddot{y}(t_k) m + 1 \\cdot b\n$$\n这代表一个包含 $N$ 个线性方程的系统。我们可以将此系统表示为矩阵形式：\n$$\n\\mathbf{F}_{\\text{sim}} = \\mathbf{A} \\boldsymbol{\\theta}\n$$\n其中 $\\mathbf{F}_{\\text{sim}}$ 是模拟力向量，$\\boldsymbol{\\theta}$ 是参数向量，$\\mathbf{A}$ 是回归矩阵（或设计矩阵）。矩阵 $\\mathbf{A} \\in \\mathbb{R}^{N \\times 4}$ 和测量力向量 $\\mathbf{F} \\in \\mathbb{R}^{N \\times 1}$ 的构造如下：\n$$\n\\mathbf{A} = \\begin{pmatrix}\ny(t_0)  \\dot{y}(t_0)  \\ddot{y}(t_0)  1 \\\\\ny(t_1)  \\dot{y}(t_1)  \\ddot{y}(t_1)  1 \\\\\n\\vdots  \\vdots  \\vdots  \\vdots \\\\\ny(t_{N-1})  \\dot{y}(t_{N-1})  \\ddot{y}(t_{N-1})  1\n\\end{pmatrix}, \\quad\n\\mathbf{F} = \\begin{pmatrix}\nF_{\\text{meas}}(t_0) \\\\\nF_{\\text{meas}}(t_1) \\\\\n\\vdots \\\\\nF_{\\text{meas}}(t_{N-1})\n\\end{pmatrix}\n$$\n目标是找到参数向量 $\\hat{\\boldsymbol{\\theta}}$，以最小化成本函数 $J(\\boldsymbol{\\theta})$，该函数定义为残差平方和，等价于残差向量 $\\mathbf{r} = \\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{F}$ 的欧几里得范数的平方：\n$$\n\\min_{\\boldsymbol{\\theta}} J(\\boldsymbol{\\theta}) = \\sum_{k=0}^{N-1} \\left( F_{\\text{sim}}(t_k) - F_{\\text{meas}}(t_k) \\right)^2 = \\| \\mathbf{A}\\boldsymbol{\\theta} - \\mathbf{F} \\|_2^2\n$$\n这个最小化问题的解可以通过求解正规方程得到：\n$$\n\\mathbf{A}^{\\top}\\mathbf{A} \\boldsymbol{\\theta} = \\mathbf{A}^{\\top}\\mathbf{F}\n$$\n假设矩阵 $\\mathbf{A}^{\\top}\\mathbf{A}$ 可逆（这要求 $\\mathbf{A}$ 的列是线性无关的），则估计参数 $\\hat{\\boldsymbol{\\theta}}$ 的唯一解是：\n$$\n\\hat{\\boldsymbol{\\theta}} = (\\mathbf{A}^{\\top}\\mathbf{A})^{-1}\\mathbf{A}^{\\top}\\mathbf{F}\n$$\n矩阵 $(\\mathbf{A}^{\\top}\\mathbf{A})^{-1}\\mathbf{A}^{\\top}$ 是 $\\mathbf{A}$ 的摩尔-彭若斯伪逆，记作 $\\mathbf{A}^{+}$。为了数值稳定性和效率，特别是在处理病态矩阵时，最好使用如QR分解或奇异值分解 (SVD) 等方法来解决最小二乘问题，这些方法通常在数值库函数如 `numpy.linalg.lstsq` 中实现。\n\n四个测试用例中每个用例的总体流程如下：\n1.  根据指定的采样参数（$N$ 和 $\\Delta t$，或显式的时间列表）生成离散时间向量 $\\mathbf{t}$。\n2.  对于每个时间点 $t_k \\in \\mathbf{t}$，使用其提供的解析定义计算运动学变量 $y(t_k)$、$\\dot{y}(t_k)$ 和 $\\ddot{y}(t_k)$ 的值。这将产生三个向量：$\\mathbf{y}$、$\\mathbf{\\dot{y}}$ 和 $\\mathbf{\\ddot{y}}$。\n3.  通过水平堆叠向量 $\\mathbf{y}$、$\\mathbf{\\dot{y}}$、$\\mathbf{\\ddot{y}}$ 和一个全为1的列向量来构造回归矩阵 $\\mathbf{A}$。\n4.  首先使用*真实*参数 $(k, c, m, b)$ 计算无噪声力，然后加上指定的确定性噪声项 $\\varepsilon(t_k)$，来生成“测量的”地面反作用力向量 $\\mathbf{F}$。\n5.  以最小二乘意义求解线性系统 $\\mathbf{A}\\boldsymbol{\\theta} = \\mathbf{F}$，以获得估计的参数向量 $\\hat{\\boldsymbol{\\theta}} = [\\hat{k}, \\hat{c}, \\hat{m}, \\hat{b}]^{\\top}$。\n6.  收集每个用例的四个估计参数。\n\n对于用例4，样本数 $N=4$ 等于参数个数，因此矩阵 $\\mathbf{A}$ 是方阵。只要 $\\mathbf{A}$ 非奇异，该系统就是恰好确定的，最小二乘解将与精确解 $\\hat{\\boldsymbol{\\theta}} = \\mathbf{A}^{-1}\\mathbf{F}$ 相吻合。由于此用例中没有噪声（$\\varepsilon(t) = 0$），预计估计参数将与真实参数相同，误差在浮点运算精度范围内。对于其他用例，噪声项 $\\varepsilon(t)$ 的存在意味着估计参数会与真实值略有偏差。拟合质量取决于信噪比和激励信号的频谱内容，这些信号被设计得足够丰富，以确保 $\\mathbf{A}$ 的列不是共线的，从而保证唯一解的存在。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs parameter identification for a prosthetic foot compliance model\n    across four specified test cases using least squares optimization.\n    \"\"\"\n\n    def solve_case(case_params):\n        \"\"\"\n        Solves a single parameter identification case.\n        \n        Args:\n            case_params (dict): A dictionary containing all parameters for the case.\n            \n        Returns:\n            numpy.ndarray: The estimated parameter vector [k, c, m, b].\n        \"\"\"\n        # Unpack parameters\n        true_params = case_params['true_params']\n        signal_def = case_params['signal_def']\n        noise_def = case_params['noise_def']\n        sampling = case_params['sampling']\n        case_id = case_params['id']\n\n        # Generate time vector\n        if 'times' in sampling:\n            t = np.array(sampling['times'])\n        else:\n            N = sampling['N']\n            dt = sampling['Delta_t']\n            t = np.arange(N) * dt\n\n        # Generate kinematic signals (y, y_dot, y_ddot)\n        if case_id == 1:\n            A = signal_def['A']\n            f = signal_def['f']\n            omega = 2 * np.pi * f\n            y = A * np.sin(omega * t) + 0.5 * A * np.sin(2 * omega * t)\n            y_dot = A * omega * np.cos(omega * t) + 0.5 * A * (2 * omega) * np.cos(2 * omega * t)\n            y_ddot = -A * omega**2 * np.sin(omega * t) - 0.5 * A * (2 * omega)**2 * np.sin(2 * omega * t)\n        elif case_id == 2:\n            y0 = signal_def['y0']\n            t0 = signal_def['t0']\n            tau = signal_def['tau']\n            \n            y = np.zeros_like(t)\n            y_dot = np.zeros_like(t)\n            y_ddot = np.zeros_like(t)\n\n            mask = t = t0\n            t_shifted = t[mask] - t0\n            \n            exp_term = np.exp(-t_shifted / tau)\n            y[mask] = y0 * (1 - exp_term)\n            y_dot[mask] = (y0 / tau) * exp_term\n            y_ddot[mask] = -(y0 / tau**2) * exp_term\n        elif case_id == 3:\n            A = signal_def['A']\n            f = signal_def['f']\n            omega = 2 * np.pi * f\n            y = A * np.sin(omega * t)\n            y_dot = A * omega * np.cos(omega * t)\n            y_ddot = -A * omega**2 * np.sin(omega * t)\n        elif case_id == 4:\n            p3, p2, p1, p0 = signal_def['p3'], signal_def['p2'], signal_def['p1'], signal_def['p0']\n            y = p3 * t**3 + p2 * t**2 + p1 * t + p0\n            y_dot = 3 * p3 * t**2 + 2 * p2 * t + p1\n            y_ddot = 6 * p3 * t + 2 * p2\n        \n        # Generate noise signal\n        E = noise_def['E']\n        if E != 0:\n            f_n = noise_def['f_n']\n            epsilon = E * np.sin(2 * np.pi * f_n * t)\n        else:\n            epsilon = np.zeros_like(t)\n\n        # Construct measured GRF vector (F)\n        k_true, c_true, m_true, b_true = true_params.values()\n        F_meas = k_true * y + c_true * y_dot + m_true * y_ddot + b_true + epsilon\n        \n        # Construct regression matrix (A)\n        # Columns are [y(t), y_dot(t), y_ddot(t), 1]\n        A = np.c_[y, y_dot, y_ddot, np.ones_like(t)]\n        \n        # Solve the least squares problem: A * theta = F_meas\n        theta_est, _, _, _ = np.linalg.lstsq(A, F_meas, rcond=None)\n        \n        return theta_est\n\n    # Define test cases\n    test_cases = [\n        {\n            \"id\": 1,\n            \"true_params\": {\"k\": 30000.0, \"c\": 1200.0, \"m\": 2.5, \"b\": 800.0},\n            \"signal_def\": {\"A\": 0.02, \"f\": 1.5},\n            \"noise_def\": {\"E\": 5.0, \"f_n\": 5.0},\n            \"sampling\": {\"N\": 500, \"Delta_t\": 0.01}\n        },\n        {\n            \"id\": 2,\n            \"true_params\": {\"k\": 28000.0, \"c\": 500.0, \"m\": 2.2, \"b\": 790.0},\n            \"signal_def\": {\"y0\": 0.015, \"t0\": 0.1, \"tau\": 0.05},\n            \"noise_def\": {\"E\": 2.0, \"f_n\": 3.0},\n            \"sampling\": {\"N\": 500, \"Delta_t\": 0.01}\n        },\n        {\n            \"id\": 3,\n            \"true_params\": {\"k\": 40000.0, \"c\": 3000.0, \"m\": 1.8, \"b\": 850.0},\n            \"signal_def\": {\"A\": 0.015, \"f\": 6.0},\n            \"noise_def\": {\"E\": 10.0, \"f_n\": 7.0},\n            \"sampling\": {\"N\": 400, \"Delta_t\": 0.005}\n        },\n        {\n            \"id\": 4,\n            \"true_params\": {\"k\": 35000.0, \"c\": 1000.0, \"m\": 2.0, \"b\": 780.0},\n            \"signal_def\": {\"p3\": 0.5, \"p2\": -0.05, \"p1\": 0.0, \"p0\": 0.0},\n            \"noise_def\": {\"E\": 0.0},\n            \"sampling\": {\"times\": [0.0, 0.1, 0.2, 0.3]}\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        estimated_params = solve_case(case)\n        all_results.extend(estimated_params)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}