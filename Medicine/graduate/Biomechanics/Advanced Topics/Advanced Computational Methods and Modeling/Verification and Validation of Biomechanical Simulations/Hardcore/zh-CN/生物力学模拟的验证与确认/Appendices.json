{
    "hands_on_practices": [
        {
            "introduction": "在我们信任任何仿真结果之前，我们必须首先验证软件是否正确地实现了其底层的数学模型。这个过程被称为代码验证，它涉及根据已知的解析解或基本原理来测试求解器的各个组件。本练习将为一个典型的肌肉骨骼求解器构建一套最小化的验证测试，涵盖运动学、动力学和驱动子系统，以确保计算的正确性。",
            "id": "4210770",
            "problem": "肌肉骨骼动力学求解器可分解为运动学、动力学和驱动子系统。代码验证通过对照从基本原理推导出的解析不变量和精确解，来评估这些子系统的数值正确性。请构建一套最小的验证测试集，并实现一个程序来计算每个测试的通过或失败，使用的容差应能反映双精度数值极限和预期的数值积分精度。所有角度必须以弧度为单位。所有物理单位必须是国际单位制（SI单位）：米、千克、秒和牛顿。\n\n仅使用以下基本原理：\n- 牛顿第二运动定律：$F = m a$ 及其旋转模拟量 $ \\tau = I \\alpha $，其中 $ \\tau $ 是扭矩，$ I $ 是转动惯量，$ \\alpha $ 是角加速度。\n- 平面刚体运动学：角度 $ \\theta $ 的旋转矩阵为 $ R(\\theta) = \\begin{bmatrix}\\cos \\theta  -\\sin \\theta\\\\ \\sin \\theta  \\cos \\theta \\end{bmatrix} $。\n- 对于长度为 $ l_1 $ 和 $ l_2 $ 的平面二连杆，其末端执行器的位置为 $ p(\\theta_1,\\theta_2) = \\begin{bmatrix} l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2) \\\\ l_1 \\sin \\theta_1 + l_2 \\sin(\\theta_1+\\theta_2) \\end{bmatrix} $，其雅可比矩阵 $ J(\\theta_1,\\theta_2) $ 是 $ p $ 关于 $ \\theta_1 $ 和 $ \\theta_2 $ 的偏导数矩阵。\n- 无阻尼单摆动力学：对于长度为 $ L $ 的无质量杆末端的点质量 $ m $，其运动方程为 $ m L^2 \\ddot{\\theta} + m g L \\sin \\theta = 0 $，当只有重力作用时，其哈密顿力学能 $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos \\theta) $ 守恒。\n- 建模为一阶常微分方程（ODE）的肌肉激活-动力学：$ \\dot{a} = \\frac{u - a}{\\tau} $，其中神经输入 $ u $ 和时间常数 $ \\tau $ 为常数，对于常数 $ u $，其精确解为 $ a(t) = u + (a_0 - u) e^{-t/\\tau} $。\n- 建模为线性弹簧-阻尼器的肌腱力：$ F = k (l - l_0) + c v $，使用恒定力臂 $ r $ 计算的关节扭矩为 $ \\tau = r F $。\n\n您的程序必须实现以下最小验证测试，每个测试返回一个布尔值，表示通过（True）或失败（False）：\n\n1. 运动学：平面旋转矩阵在 $ \\theta = 0 $ 时的正交性。验证 $ R(\\theta)^\\top R(\\theta) $ 在矩阵 $ 2 $-范数下是否为单位矩阵，容差为 $ 10^{-12} $。\n2. 运动学：平面旋转矩阵在 $ \\theta = \\pi $ 时的正交性。标准和容差与测试1相同。\n3. 运动学：使用雅可比矩阵验证二连杆末端执行器速度的一致性。设 $ l_1 = 0.4 \\,\\text{m} $，$ l_2 = 0.4 \\,\\text{m} $，$ \\theta_1(t) = \\omega_1 t $（其中 $ \\omega_1 = 1.5 \\,\\text{rad/s} $），以及 $ \\theta_2(t) = \\omega_2 t $（其中 $ \\omega_2 = -0.7 \\,\\text{rad/s} $）。在 $ t = 1.0 \\,\\text{s} $ 时，计算解析速度 $ \\dot{p} = J(\\theta_1,\\theta_2) \\begin{bmatrix} \\omega_1 \\\\ \\omega_2 \\end{bmatrix} $，并与使用 $ \\Delta t = 10^{-5} \\,\\text{s} $ 的有限差分估计 $ \\frac{p(t+\\Delta t)-p(t-\\Delta t)}{2\\Delta t} $ 进行比较。如果差值的欧几里得范数 $ \\leq 10^{-8} \\,\\text{m/s} $，则通过。\n4. 动力学：零扭矩下的自由刚体旋转。对于一个转动惯量为 $ I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2 $，初始角度 $ \\theta(0) = 0.3 \\,\\text{rad} $，初始角速度 $ \\dot{\\theta}(0) = 2.0 \\,\\text{rad/s} $ 的刚体，使用步长为 $ \\Delta t = 10^{-3} \\,\\text{s} $ 的固定步长四阶 Runge-Kutta 方法对 $ I \\ddot{\\theta} = 0 $ 进行积分，时长为 $ T = 2.0 \\,\\text{s} $。如果 $ |\\dot{\\theta}(T) - \\dot{\\theta}(0)| \\leq 10^{-12} \\,\\text{rad/s} $，则通过。\n5. 动力学：单摆的能量一致性。设 $ m = 1.0 \\,\\text{kg} $，$ L = 1.0 \\,\\text{m} $，$ g = 9.81 \\,\\text{m/s}^2 $，初始角度 $ \\theta(0) = 0.2 \\,\\text{rad} $，初始角速度 $ \\dot{\\theta}(0) = 0.0 \\,\\text{rad/s} $。使用步长为 $ \\Delta t = 10^{-4} \\,\\text{s} $ 的固定步长四阶 Runge-Kutta 方法积分 $ T = 2.0 \\,\\text{s} $。如果力学能的最大相对漂移 $ \\max_{t \\in [0,T]} \\left| \\frac{E(t) - E(0)}{E(0)} \\right| \\leq 10^{-6} $，则通过。\n6. 驱动：激活-常微分方程的正确性。在 $ a(0) = 0.1 $，$ u = 0.7 $，$ \\tau = 0.05 \\,\\text{s} $ 的条件下，使用步长为 $ \\Delta t = 10^{-4} \\,\\text{s} $ 的固定步长四阶 Runge-Kutta 方法对 $ \\dot{a} = \\frac{u - a}{\\tau} $ 积分 $ T = 1.0 \\,\\text{s} $，并将 $ a(T) $ 与精确解 $ a_{\\text{exact}}(T) = u + (a(0) - u) e^{-T/\\tau} $ 进行比较。如果 $ |a(T) - a_{\\text{exact}}(T)| \\leq 10^{-9} $，则通过。\n7. 驱动：肌腱扭矩映射。对于参数 $ k = 1500.0 \\,\\text{N/m} $，$ c = 25.0 \\,\\text{N}\\cdot\\text{s/m} $，$ l_0 = 0.30 \\,\\text{m} $，$ l = 0.33 \\,\\text{m} $，$ v = 0.0 \\,\\text{m/s} $，以及力臂 $ r = 0.04 \\,\\text{m} $，计算 $ F = k (l - l_0) + c v $ 和 $ \\tau = r F $。如果数值计算出的扭矩与 $ \\tau $ 的差值在 $ 10^{-12} \\,\\text{N}\\cdot\\text{m} $ 以内，则通过。\n\n测试套件：\n- 测试 1：$ \\theta = 0 $。\n- 测试 2：$ \\theta = \\pi $。\n- 测试 3：$ l_1 = 0.4 \\,\\text{m} $，$ l_2 = 0.4 \\,\\text{m} $，$ \\omega_1 = 1.5 \\,\\text{rad/s} $，$ \\omega_2 = -0.7 \\,\\text{rad/s} $，$ t = 1.0 \\,\\text{s} $，$ \\Delta t = 10^{-5} \\,\\text{s} $。\n- 测试 4：$ I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2 $，$ \\theta(0) = 0.3 \\,\\text{rad} $，$ \\dot{\\theta}(0) = 2.0 \\,\\text{rad/s} $，$ T = 2.0 \\,\\text{s} $，$ \\Delta t = 10^{-3} \\,\\text{s} $。\n- 测试 5：$ m = 1.0 \\,\\text{kg} $，$ L = 1.0 \\,\\text{m} $，$ g = 9.81 \\,\\text{m/s}^2 $，$ \\theta(0) = 0.2 \\,\\text{rad} $，$ \\dot{\\theta}(0) = 0.0 \\,\\text{rad/s} $，$ T = 2.0 \\,\\text{s} $，$ \\Delta t = 10^{-4} \\,\\text{s} $。\n- 测试 6：$ a(0) = 0.1 $，$ u = 0.7 $，$ \\tau = 0.05 \\,\\text{s} $，$ T = 1.0 \\,\\text{s} $，$ \\Delta t = 10^{-4} \\,\\text{s} $。\n- 测试 7：$ k = 1500.0 \\,\\text{N/m} $，$ c = 25.0 \\,\\text{N}\\cdot\\text{s/m} $，$ l_0 = 0.30 \\,\\text{m} $，$ l = 0.33 \\,\\text{m} $，$ v = 0.0 \\,\\text{m/s} $，$ r = 0.04 \\,\\text{m} $。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，`[result1,result2,...,result7]`），其中每个结果都是一个布尔值，表示测试 1 到 7 按顺序通过或失败。",
            "solution": "验证肌肉骨骼动力学求解器的过程包括确保其每个计算子系统都正确地实现了底层的数学模型。这通过将求解器的输出与从基本原理推导出的已知解析解或守恒量进行比较来实现。以下各节详细介绍了一套用于此类求解器的运动学、动力学和驱动组件的最小验证测试。\n\n我们采用四阶 Runge-Kutta（RK4）积分器来求解出现的常微分方程（ODE）。对于给定的一阶 ODE 系统 $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$，从时间 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的单个积分步骤计算如下：\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\n其中\n$$ \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2}) $$\n$$ \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2}) $$\n$$ \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3) $$\n\n**测试 1 和 2：运动学 — 平面旋转矩阵的正交性**\n此测试的目的是验证二维刚体旋转矩阵的正确实现。任何旋转矩阵 $R$ 的一个基本属性是其正交性，这意味着它的转置也是它的逆，即 $R^\\top R = I$，其中 $I$ 是单位矩阵。此属性确保变换保持长度和角度不变，这是刚体旋转的定义性特征。\n我们针对平面旋转矩阵测试此属性，该矩阵由下式给出：\n$$ R(\\theta) = \\begin{bmatrix}\\cos \\theta  -\\sin \\theta\\\\ \\sin \\theta  \\cos \\theta \\end{bmatrix} $$\n测试在两个基本角度 $\\theta = 0$ 和 $\\theta = \\pi$ 下进行。验证检查计算矩阵差 $D = R(\\theta)^\\top R(\\theta) - I$，并断言其矩阵 $2$-范数 $\\|D\\|_2$ 小于 $10^{-12}$ 的容差，该容差考虑了浮点精度极限。对于 $\\theta=0$，$R(0)=I$；对于 $\\theta=\\pi$，$R(\\pi)=-I$。在这两种情况下，$R^\\top R = I$ 在解析上成立，因此数值误差应接近机器精度。\n\n**测试 3：运动学 — 二连杆末端执行器速度的一致性**\n此测试通过雅可比矩阵验证了关节空间速度与笛卡尔空间速度之间的关系。对于一个运动学链，末端执行器的速度 $\\dot{\\mathbf{p}}$ 与关节角速度向量 $\\dot{\\mathbf{\\theta}}$ 通过线性映射 $\\dot{\\mathbf{p}} = J(\\mathbf{\\theta})\\dot{\\mathbf{\\theta}}$ 相关联。这里，$J(\\mathbf{\\theta})$ 是雅可比矩阵，包含末端执行器位置相对于关节角度的偏导数。\n指定的二连杆臂的位置向量为：\n$$ \\mathbf{p}(\\theta_1,\\theta_2) = \\begin{bmatrix} l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2) \\\\ l_1 \\sin \\theta_1 + l_2 \\sin(\\theta_1+\\theta_2) \\end{bmatrix} $$\n相应的雅可比矩阵是：\n$$ J(\\theta_1, \\theta_2) = \\frac{\\partial \\mathbf{p}}{\\partial (\\theta_1, \\theta_2)} = \\begin{bmatrix} -l_1 \\sin \\theta_1 - l_2 \\sin(\\theta_1+\\theta_2)  -l_2 \\sin(\\theta_1+\\theta_2) \\\\ l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2)  l_2 \\cos(\\theta_1+\\theta_2) \\end{bmatrix} $$\n测试将解析计算的速度 $\\dot{\\mathbf{p}}_{\\text{analytical}} = J(\\mathbf{\\theta}(t))\\dot{\\mathbf{\\theta}}$ 与使用二阶中心有限差分法计算的数值近似速度 $\\dot{\\mathbf{p}}_{\\text{numerical}}$进行比较：\n$$ \\dot{\\mathbf{p}}_{\\text{numerical}} \\approx \\frac{\\mathbf{p}(\\mathbf{\\theta}(t+\\Delta t)) - \\mathbf{p}(\\mathbf{\\theta}(t-\\Delta t))}{2\\Delta t} $$\n对于给定的参数 $l_1 = 0.4 \\,\\text{m}$，$l_2 = 0.4 \\,\\text{m}$，$\\dot{\\theta}_1 = \\omega_1 = 1.5 \\,\\text{rad/s}$，$\\dot{\\theta}_2 = \\omega_2 = -0.7 \\,\\text{rad/s}$，在时间 $t=1.0 \\,\\text{s}$ 和有限差分步长 $\\Delta t = 10^{-5} \\,\\text{s}$ 的条件下，要通过测试，要求差值的欧几里得范数 $\\|\\dot{\\mathbf{p}}_{\\text{analytical}} - \\dot{\\mathbf{p}}_{\\text{numerical}}\\|_2$ 不大于 $10^{-8} \\,\\text{m/s}$。此近似的预期误差与 $(\\Delta t)^2$ 成正比，使得该容差是合适的。\n\n**测试 4：动力学 — 自由刚体旋转**\n此测试验证了动力学求解器保持角动量守恒的能力。根据牛顿第二旋转定律，$\\tau = I \\alpha = I \\ddot{\\theta}$，其中 $\\tau$ 是净外力矩，$I$ 是转动惯量，$\\ddot{\\theta}$ 是角加速度。在没有任何扭矩（$\\tau=0$）的情况下，角加速度为零，即 $\\ddot{\\theta} = 0$。对此方程积分得到一个恒定的角速度：$\\dot{\\theta}(t) = \\dot{\\theta}(0)$。\n测试模拟了一个具有 $I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2$ 和初始条件 $\\theta(0) = 0.3 \\,\\text{rad}$ 及 $\\dot{\\theta}(0) = 2.0 \\,\\text{rad/s}$ 的刚体，时长为 $T = 2.0 \\,\\text{s}$。方程使用 RK4 方法进行积分。要通过测试，要求最终角速度 $\\dot{\\theta}(T)$ 与初始角速度 $\\dot{\\theta}(0)$ 的差值在 $10^{-12} \\,\\text{rad/s}$ 的严格容差之内，这反映了 RK4 可以精确积分最高4次多项式的事实，而 $\\ddot{\\theta}=0$ 是一个平凡的情况。\n\n**测试 5：动力学 — 单摆的能量一致性**\n此测试验证了数值积分器对于保守系统的能量守恒特性。单摆由运动方程 $m L^2 \\ddot{\\theta} + m g L \\sin \\theta = 0$ 控制，是总机械能守恒系统的经典例子。哈密顿量，或总机械能 $E$，是动能和势能之和：\n$$ E = \\underbrace{\\frac{1}{2} m L^2 \\dot{\\theta}^2}_{\\text{动能}} + \\underbrace{m g L (1 - \\cos \\theta)}_{\\text{势能}} $$\n测试使用 RK4 方法，从静止状态（$\\dot{\\theta}(0)=0$）和初始角度 $\\theta(0)=0.2 \\,\\text{rad}$ 开始积分摆的运动。尽管 RK4 不是一个辛积分器，也不是为长期完美保持能量守恒而设计的，但其高阶精度应能确保在合理的积分时间内能量漂移保持非常小。如果最大相对能量漂移 $\\max_{t \\in [0,T]} |(E(t) - E(0))/E(0)|$ 在 $T = 2.0 \\,\\text{s}$ 的时长内不超过 $10^{-6}$，则测试通过。\n\n**测试 6：驱动 — 激活-常微分方程的正确性**\n此测试通过与一个已知的解析解进行比较，来验证 ODE 求解器对于一个常见的生物力学模型：一阶肌肉激活-动力学。该模型由线性一阶 ODE 给出：\n$$ \\dot{a} = \\frac{u - a}{\\tau} $$\n其中 $a(t)$ 是肌肉激活水平，$u$ 是恒定的神经输入，$\\tau$ 是时间常数。对于恒定输入 $u$ 和初始条件 $a(0)=a_0$，此方程有精确的解析解：\n$$ a(t) = u + (a_0 - u) \\exp(-t/\\tau) $$\n测试使用 RK4 从 $a(0) = 0.1$ 开始，在参数 $u=0.7$ 和 $\\tau=0.05\\,\\text{s}$ 的条件下，对 ODE 进行数值积分，时长为 $T=1.0\\,\\text{s}$。将数值结果 $a(T)$ 与精确解 $a_{\\text{exact}}(T)$ 进行比较。如果绝对误差 $|a(T) - a_{\\text{exact}}(T)|$ 不超过 $10^{-9}$，则测试通过，这个容差反映了 RK4 方法对于一个良态 ODE 的预期高精度。\n\n**测试 7：驱动 — 肌腱扭矩映射**\n这最后一项测试是对从肌腱属性代数计算关节扭矩的简单单元级验证。它检查一个线性 Hill 型肌肉模型的实现，其中力 $F$ 是长度 $l$ 和速度 $v$ 的函数：\n$$ F = k (l - l_0) + c v $$\n这里，$k$ 是刚度，$l_0$ 是静息长度，$c$ 是阻尼系数。然后通过将此力乘以一个恒定的力臂 $r$ 来计算关节扭矩 $\\tau$：\n$$ \\tau = r F $$\n测试涉及为一组给定参数计算扭矩。这类测试对于确保模型最基本的组件都得到正确实现至关重要，因为这些简单映射中的错误会传播并破坏整个模拟。要通过测试，要求数值计算的扭矩与解析计算值 $1.8 \\,\\text{N}\\cdot\\text{m}$ 的差值在 $10^{-12} \\,\\text{N}\\cdot\\text{m}$ 的容差范围内，这对于直接的浮点计算是合适的。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes a suite of verification tests for a musculoskeletal dynamics solver.\n    \"\"\"\n\n    def rk4_step(f, y, t, dt, *args):\n        \"\"\"\n        Performs a single step of the fourth-order Runge-Kutta method.\n        f: function for dy/dt = f(t, y, *args)\n        y: current state (numpy array)\n        t: current time\n        dt: time step\n        args: additional constant arguments for f\n        \"\"\"\n        k1 = dt * f(t, y, *args)\n        k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1, *args)\n        k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2, *args)\n        k4 = dt * f(t + dt, y + k3, *args)\n        return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\n    def test1():\n        \"\"\"Kinematics: Orthonormality of planar rotation matrix at theta = 0.\"\"\"\n        theta = 0.0\n        R = np.array([\n            [np.cos(theta), -np.sin(theta)],\n            [np.sin(theta),  np.cos(theta)]\n        ])\n        I = np.identity(2)\n        diff_matrix = R.T @ R - I\n        norm = np.linalg.norm(diff_matrix, 2)\n        return norm = 1e-12\n\n    def test2():\n        \"\"\"Kinematics: Orthonormality of planar rotation matrix at theta = pi.\"\"\"\n        theta = np.pi\n        R = np.array([\n            [np.cos(theta), -np.sin(theta)],\n            [np.sin(theta),  np.cos(theta)]\n        ])\n        I = np.identity(2)\n        diff_matrix = R.T @ R - I\n        norm = np.linalg.norm(diff_matrix, 2)\n        return norm = 1e-12\n\n    def test3(params):\n        \"\"\"Kinematics: Two-link end-effector velocity consistency using the Jacobian.\"\"\"\n        l1, l2, w1, w2, t_eval, dt_fd = params\n\n        def p_func(th1, th2):\n            return np.array([\n                l1 * np.cos(th1) + l2 * np.cos(th1 + th2),\n                l1 * np.sin(th1) + l2 * np.sin(th1 + th2)\n            ])\n\n        def J_func(th1, th2):\n            s1, c1 = np.sin(th1), np.cos(th1)\n            s12, c12 = np.sin(th1 + th2), np.cos(th1 + th2)\n            return np.array([\n                [-l1 * s1 - l2 * s12, -l2 * s12],\n                [ l1 * c1 + l2 * c12,  l2 * c12]\n            ])\n\n        th1_t, th2_t = w1 * t_eval, w2 * t_eval\n        J = J_func(th1_t, th2_t)\n        v_analytical = J @ np.array([w1, w2])\n\n        p_plus = p_func(w1 * (t_eval + dt_fd), w2 * (t_eval + dt_fd))\n        p_minus = p_func(w1 * (t_eval - dt_fd), w2 * (t_eval - dt_fd))\n        v_numerical = (p_plus - p_minus) / (2 * dt_fd)\n\n        error = np.linalg.norm(v_analytical - v_numerical)\n        return error = 1e-8\n\n    def test4(params):\n        \"\"\"Dynamics: Free rigid rotation under zero torque.\"\"\"\n        I, theta0, dtheta0, T, dt = params\n        \n        def ode_free_rotation(t, y, *args):\n            return np.array([y[1], 0.0])\n\n        y = np.array([theta0, dtheta0])\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_free_rotation, y, current_time, dt)\n            current_time += dt\n        \n        dtheta_final = y[1]\n        error = abs(dtheta_final - dtheta0)\n        return error = 1e-12\n\n    def test5(params):\n        \"\"\"Dynamics: Energy consistency of a simple pendulum.\"\"\"\n        m, L, g, theta0, dtheta0, T, dt = params\n\n        def ode_pendulum(t, y, g_val, L_val):\n            return np.array([y[1], -(g_val / L_val) * np.sin(y[0])])\n        \n        def energy_func(y_state, m_val, L_val, g_val):\n            theta, dtheta = y_state\n            kinetic = 0.5 * m_val * (L_val * dtheta)**2\n            potential = m_val * g_val * L_val * (1.0 - np.cos(theta))\n            return kinetic + potential\n\n        y = np.array([theta0, dtheta0])\n        E0 = energy_func(y, m, L, g)\n        if E0 == 0: return False # Relative error is undefined, but implies non-moving test fails\n\n        max_relative_drift = 0.0\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_pendulum, y, current_time, dt, g, L)\n            current_time += dt\n            Et = energy_func(y, m, L, g)\n            relative_drift = abs((Et - E0) / E0)\n            if relative_drift > max_relative_drift:\n                max_relative_drift = relative_drift\n                \n        return max_relative_drift = 1e-6\n\n    def test6(params):\n        \"\"\"Actuation: Activation ODE correctness.\"\"\"\n        a0, u, tau, T, dt = params\n        \n        def ode_activation(t, y, u_val, tau_val):\n            return np.array([(u_val - y[0]) / tau_val])\n\n        y = np.array([a0])\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_activation, y, current_time, dt, u, tau)\n            current_time += dt\n            \n        a_numerical = y[0]\n        a_exact = u + (a0 - u) * np.exp(-T / tau)\n        \n        error = abs(a_numerical - a_exact)\n        return error = 1e-9\n\n    def test7(params):\n        \"\"\"Actuation: Muscle-tendon torque mapping.\"\"\"\n        k, c, l0, l, v, r = params\n        \n        # \"Numerically computed\" means computed by the function under test\n        force = k * (l - l0) + c * v\n        torque_computed = r * force\n        \n        # Analytical value is the same calculation, for self-consistency check\n        torque_analytical = r * (k * (l - l0) + c * v)\n        \n        error = abs(torque_computed - torque_analytical)\n        return error = 1e-12\n\n    # Define test cases from the problem statement.\n    test_cases_params = [\n        (),  # Test 1 has no params\n        (),  # Test 2 has no params\n        (0.4, 0.4, 1.5, -0.7, 1.0, 1e-5),  # Test 3\n        (0.25, 0.3, 2.0, 2.0, 1e-3),        # Test 4\n        (1.0, 1.0, 9.81, 0.2, 0.0, 2.0, 1e-4), # Test 5\n        (0.1, 0.7, 0.05, 1.0, 1e-4),          # Test 6\n        (1500.0, 25.0, 0.30, 0.33, 0.0, 0.04) # Test 7\n    ]\n\n    test_functions = [test1, test2, test3, test4, test5, test6, test7]\n    \n    results = []\n    for i, func in enumerate(test_functions):\n        params = test_cases_params[i]\n        if params:\n            result = func(params)\n        else:\n            result = func()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "代码验证通过后，我们必须评估特定仿真解的准确性，这通常会受到离散化误差（例如，来自网格划分）的影响。本练习介绍理查德森外推法 (Richardson extrapolation)，这是一种强大的解验证技术，用于根据系统化加密网格上的结果来估计精确解并确定数值方法的收敛速度。掌握此方法对于量化和报告计算模型中的数值不确定性至关重要。",
            "id": "4210759",
            "problem": "一个计算生物力学团队正在验证一项关于水平步行过程中胫股接触力的有限元法（FEM）模拟。他们分析了一个标量可观测量——峰值胫股接触力——的网格细化行为。该力记为 $Q(h)$，其中 $h$ 是一个特征网格尺寸，定义为接触区域内的最大边长。对于一致的离散化，在网格收敛的渐近区域内，假设主阶离散误差满足以下模型\n$$\nQ(h) = Q_0 + C h^{p},\n$$\n其中 $Q_0$ 是连续介质（网格无关）值，$C$ 是一个未知常数，$p$ 是该方法的观测精度阶。该团队在连续的网格之间采用固定的细化比 $r1$，并在其他物理和数值设置均相同的情况下，在三个网格层级 $h$、$h/r$ 和 $h/r^{2}$ 上获取 $Q(h)$。假设随着 $h$ 的减小，收敛是单调的，这与 $C0$ 和 $p0$ 一致。\n\n任务：\n1. 仅从误差模型 $Q(h) = Q_0 + C h^{p}$ 和细化比 $r$ 的定义出发，推导一个双网格理查森外推公式，该公式通过消去主阶项来用 $Q(h)$、$Q(h/r)$、$r$ 和 $p$ 表示 $Q_0$。\n2. 同样仅从误差模型出发，推导一个用 $Q(h)$、$Q(h/r)$、$Q(h/r^{2})$ 和 $r$ 表示观测阶 $p$ 的三网格估计量。\n3. 在 $h_1 = 2.0\\ \\mathrm{mm}$、$h_2 = 1.0\\ \\mathrm{mm}$ 和 $h_3 = 0.5\\ \\mathrm{mm}$ 的网格上测量了峰值胫股接触力的 FEM 输出，对应的细化比为 $r = 2$。报告值为 $Q(h_1) = 2146.5\\ \\mathrm{N}$、$Q(h_2) = 2010\\ \\mathrm{N}$ 和 $Q(h_3) = 1973.41\\ \\mathrm{N}$。使用你推导的公式，估计 $p$，然后计算理查森外推的连续介质值 $Q_0$。以 $\\mathrm{N}$ 为单位表示最终的 $Q_0$，并将你的最终答案四舍五入到四位有效数字。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、适定且客观。所给的问题陈述描述了一项标准的网格收敛性研究，该研究使用理查森外推法，这是一种用于验证计算模型的成熟数值分析技术。主导误差模型 $Q(h) = Q_0 + C h^{p}$ 是对渐近区域内离散误差的一个基本假设。提供的数据是自洽且一致的；峰值胫股接触力的值随着网格尺寸的减小而减小（$2146.5\\ \\mathrm{N}  2010\\ \\mathrm{N}  1973.41\\ \\mathrm{N}$），这与 $C0$ 时的单调收敛是一致的。因此，该问题被认为是有效的，解答构建如下。\n\n问题分为三个部分：推导双网格理查森外推公式，推导观测精度阶的三网格估计量，以及将这些公式应用于给定的数值数据。\n\n**1. $Q_0$ 的理查森外推公式推导**\n\n我们从给定的离散误差模型开始：\n$$\nQ(h) = Q_0 + C h^{p}\n$$\n其中 $Q(h)$ 是特征网格尺寸为 $h$ 时的数值解，$Q_0$ 是精确（连续介质）解，$C$ 是一个常数，$p$ 是精度阶。\n\n我们考虑两个网格层级，一个网格尺寸为 $h$，另一个更细的网格尺寸为 $h/r$，其中 $r  1$ 是细化比。该模型提供了一个包含两个方程的方程组：\n\\begin{enumerate}\n    \\item 对于网格尺寸 $h$：$Q(h) = Q_0 + C h^{p}$\n    \\item 对于网格尺寸 $h/r$：$Q(h/r) = Q_0 + C \\left(\\frac{h}{r}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{p}}$\n\\end{enumerate}\n\n我们的目标是消去含有未知常数 $C$ 的项，即 $C h^{p}$。我们可以从第一个方程中将此项表示为 $C h^{p} = Q(h) - Q_0$。将其代入第二个方程得到：\n$$\nQ(h/r) = Q_0 + \\frac{Q(h) - Q_0}{r^{p}}\n$$\n现在，我们求解 $Q_0$。两边同乘以 $r^{p}$：\n$$\nr^{p} Q(h/r) = r^{p} Q_0 + Q(h) - Q_0\n$$\n合并含有 $Q_0$ 的项：\n$$\nr^{p} Q(h/r) - Q(h) = (r^{p} - 1) Q_0\n$$\n分离出 $Q_0$ 即可得到双网格理查森外推公式：\n$$\nQ_0 = \\frac{r^{p} Q(h/r) - Q(h)}{r^{p} - 1}\n$$\n该公式基于两个网格层级的解和精度阶 $p$，提供了对连续介质值 $Q_0$ 的一个估计。\n\n**2. $p$ 的三网格估计量推导**\n\n为了估计观测精度阶 $p$，我们需要来自三个网格层级的数据。设网格尺寸为 $h$、$h/r$ 和 $h/r^{2}$。为清晰起见，我们将相应的数值解记为：\n- $Q_1 = Q(h)$\n- $Q_2 = Q(h/r)$\n- $Q_3 = Q(h/r^{2})$\n\n该误差模型提供了一个包含三个方程的方程组：\n\\begin{align*}\nQ_1 = Q_0 + C h^{p} \\\\\nQ_2 = Q_0 + C \\left(\\frac{h}{r}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{p}} \\\\\nQ_3 = Q_0 + C \\left(\\frac{h}{r^{2}}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{2p}}\n\\end{align*}\n\n我们可以通过考虑连续解之间的差值来消去 $Q_0$ 和 $C$。\n首先，最粗网格和中等网格上解的差值为：\n$$\nQ_1 - Q_2 = (Q_0 + C h^{p}) - \\left(Q_0 + \\frac{C h^{p}}{r^{p}}\\right) = C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)\n$$\n其次，中等网格和最细网格上解的差值为：\n$$\nQ_2 - Q_3 = \\left(Q_0 + \\frac{C h^{p}}{r^{p}}\\right) - \\left(Q_0 + \\frac{C h^{p}}{r^{2p}}\\right) = \\frac{C h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)\n$$\n现在，计算这两个差值的比率可以消去未知项 $C h^{p}$ 和 $\\left(1 - 1/r^{p}\\right)$：\n$$\n\\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)}{\\frac{C h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)} = r^{p}\n$$\n为了求解 $p$，我们对两边取自然对数：\n$$\n\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right) = \\ln(r^{p}) = p \\ln(r)\n$$\n分离出 $p$ 即可得到观测精度阶的三网格估计量：\n$$\np = \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right)}{\\ln(r)}\n$$\n\n**3. $p$ 和 $Q_0$ 的数值计算**\n\n问题提供了来自 FEM 模拟的以下数据：\n- 细化比：$r = 2$\n- 对于网格尺寸 $h_1 = 2.0\\ \\mathrm{mm}$：$Q_1 = Q(h_1) = 2146.5\\ \\mathrm{N}$\n- 对于网格尺寸 $h_2 = 1.0\\ \\mathrm{mm}$：$Q_2 = Q(h_2) = 2010\\ \\mathrm{N}$\n- 对于网格尺寸 $h_3 = 0.5\\ \\mathrm{mm}$：$Q_3 = Q(h_3) = 1973.41\\ \\mathrm{N}$\n这些网格尺寸对应于一个粗网格 $h_1$、一个细化网格 $h_2 = h_1/r$ 和一个进一步细化的网格 $h_3 = h_1/r^2$。\n\n首先，我们使用推导出的公式来估计观测精度阶 $p$：\n$$\np = \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{2146.5 - 2010}{2010 - 1973.41}\\right)}{\\ln(2)}\n$$\n计算差值：\n$$\nQ_1 - Q_2 = 136.5\n$$\n$$\nQ_2 - Q_3 = 36.59\n$$\n代入这些值：\n$$\np = \\frac{\\ln\\left(\\frac{136.5}{36.59}\\right)}{\\ln(2)} \\approx \\frac{\\ln(3.7305274665)}{\\ln(2)} \\approx \\frac{1.3165819}{0.69314718} \\approx 1.90001\n$$\n\n接下来，我们计算理查森外推的连续介质值 $Q_0$。标准做法是使用两个最细的网格进行此项外推，因为它们预计更深入收敛的渐近区域。因此，我们使用解 $Q_2$ 和 $Q_3$ 来应用双网格公式。在这种情况下，公式中的“粗”网格对应于 $h_2$，而“细”网格对应于 $h_3 = h_2/r$。公式变为：\n$$\nQ_0 = \\frac{r^{p} Q_3 - Q_2}{r^{p} - 1}\n$$\n从 $p$ 的计算中，我们已经知道 $r^p = \\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{136.5}{36.59}$。我们可以直接代入此式，以避免由 $p$ 的中间值带来的舍入误差。\n$$\nQ_0 = \\frac{\\left(\\frac{136.5}{36.59}\\right) Q_3 - Q_2}{\\left(\\frac{136.5}{36.59}\\right) - 1}\n$$\n代入 $Q_2$ 和 $Q_3$ 的数值：\n$$\nQ_0 = \\frac{\\left(\\frac{136.5}{36.59}\\right) (1973.41) - 2010}{\\left(\\frac{136.5}{36.59}\\right) - 1} \\approx \\frac{(3.7305274665)(1973.41) - 2010}{3.7305274665 - 1}\n$$\n$$\nQ_0 \\approx \\frac{7362.011038 - 2010}{2.7305274665} = \\frac{5352.011038}{2.7305274665} \\approx 1960.0900\n$$\n问题要求将 $Q_0$ 的最终答案四舍五入到四位有效数字。\n$$\nQ_0 \\approx 1960\\ \\mathrm{N}\n$$",
            "answer": "$$\\boxed{1960}$$"
        },
        {
            "introduction": "从验证 (verification) 转向确认 (validation)，本练习旨在解决将模型预测与现实世界现象进行比较时所面临的挑战，而现实世界本质上是不确定的。我们将通过对摩擦系数进行概率建模来分析步态仿真中足部滑移的预测。此练习演示了如何量化特定结果（滑移）的风险并评估模型对不确定参数的敏感性，这是在不确定性量化 (UQ) 框架下建立模型可信度的关键环节。",
            "id": "4210771",
            "problem": "一项双足步态模拟预测了支撑相期间随时间变化的地面反作用力 (GRF: Ground Reaction Forces)。验证和确认需要评估在摩擦系数不确定的情况下，预测的足-地接触是保持静摩擦（“粘滞”）还是转变为动摩擦（“滑动”）。使用以下基本原理：作用力适用牛顿第二运动定律，干接触适用库侖摩擦定律。库侖摩擦定律指出，只要切向接触力的大小不超过与法向载荷成正比的最大可用静摩擦力，静摩擦就可以维持。\n\n考虑支撑相期间由 $t$ 索引的离散时间样本，其中切向地面反作用力 $F_{\\mathrm{t}}(t)$ 和法向地面反作用力 $F_{\\mathrm{n}}(t)$ 均以牛顿为单位表示。时间点 $t$ 的需求摩擦系数 (RCOF: Required Coefficient of Friction) 定义为比率 $|F_{\\mathrm{t}}(t)|/F_{\\mathrm{n}}(t)$，该值为无量纲。如果表面摩擦系数 $\\mu$ 超过支撑相期间的最大 RCOF，则模拟预测整个支撑相都不会发生滑动。在实际使用中，由于表面异质性和测量变异性，$\\mu$ 是不确定的；将 $\\mu$ 建模为一个与时间无关的高斯随机变量，其均值为 $\\bar{\\mu}$，标准差为 $\\sigma_{\\mu}$。\n\n需要实现的任务：\n- 计算时间序列 $|F_{\\mathrm{t}}(t)|/F_{\\mathrm{n}}(t)$ 及其在支撑相期间的最大值，记为 $\\mu_{\\mathrm{req}}^{\\max}$。\n- 根据准静态滑动准则，通过比较 $\\mu$ 与 $\\mu_{\\mathrm{req}}^{\\max}$，对整个支撑相的滑动与粘滞状态进行分类。由于 $\\mu$ 不确定，需要量化滑动概率，该概率定义为在假设的高斯模型下，$\\mu  \\mu_{\\mathrm{req}}^{\\max}$ 的概率。\n- 通过计算给定参数值下滑动概率相对于平均摩擦系数 $\\bar{\\mu}$ 的灵敏度，来量化阈值行为。具体而言，计算滑动概率相对于 $\\bar{\\mu}$ 的导数，同时保持 $\\sigma_{\\mu}$ 不变。\n- 为每个测试用例提供以下四个输出：$\\mu_{\\mathrm{req}}^{\\max}$（无量纲），滑动概率（$[0,1]$ 范围内的十进制小数，无量纲），灵敏度 $\\mathrm{d}(\\text{slip probability})/\\mathrm{d}\\bar{\\mu}$（无量綱），以及一个布尔分类，指示在平均摩擦系数下是否会预测发生滑动（如果 $\\bar{\\mu} \\ge \\mu_{\\mathrm{req}}^{\\max}$ 则为粘滞，否则为滑动）。\n\n物理单位要求：\n- $F_{\\mathrm{t}}(t)$ 和 $F_{\\mathrm{n}}(t)$ 必须以牛顿（$\\mathrm{N}$）为单位。\n- 所有摩擦系数和概率均为无量纲，且必须表示为十进制小数。\n- 不涉及角度；无需角度单位。\n\n实现一个程序，为以下测试套件执行这些计算。每个用例由单位为 $\\mathrm{N}$ 的 $F_{\\mathrm{t}}(t)$ 和 $F_{\\mathrm{n}}(t)$ 数组以及 $\\bar{\\mu}$ 和 $\\sigma_{\\mu}$ 定义：\n1. 用例 $1$：$F_{\\mathrm{n}} = [300,800,1200,1000,700,400]$, $F_{\\mathrm{t}} = [0,120,300,200,-150,-50]$, $\\bar{\\mu} = 0.60$, $\\sigma_{\\mu} = 0.08$.\n2. 用例 $2$：$F_{\\mathrm{n}} = [300,800,1200,1000,700,400]$, $F_{\\mathrm{t}} = [0,180,420,260,-210,-70]$, $\\bar{\\mu} = 0.36$, $\\sigma_{\\mu} = 0.02$.\n3. 用例 $3$：$F_{\\mathrm{n}} = [300,800,1200,1000,700,400]$, $F_{\\mathrm{t}} = [0,180,420,260,-210,-70]$, $\\bar{\\mu} = 0.25$, $\\sigma_{\\mu} = 0.05$.\n4. 用例 $4$：$F_{\\mathrm{n}} = [300,800,1200,1000,700,400]$, $F_{\\mathrm{t}} = [0,180,420,260,-210,-70]$, $\\bar{\\mu} = 0.60$, $\\sigma_{\\mu} = 0.30$.\n5. 用例 $5$：$F_{\\mathrm{n}} = [400,900,1300,1100,800,500]$, $F_{\\mathrm{t}} = [0,150,500,250,-200,-80]$, $\\bar{\\mu} = 0.90$, $\\sigma_{\\mu} = 0.005$.\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。此顶层列表中的每个元素对应一个测试用例，并且其本身必须是格式为 $[\\mu_{\\mathrm{req}}^{\\max}, \\text{slip\\_probability}, \\mathrm{d}(\\text{slip probability})/\\mathrm{d}\\bar{\\mu}, \\text{slip\\_at\\_mean}]$ 的列表。例如，打印的整个字符串必须看起来像 $[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$，并且只包含这一行。",
            "solution": "问题陈述已经过仔细验证，并被确定为有效。它在科学上基于经典力学原理（库仑摩擦），问题设定良好，数据充分且一致，表述客观。该问题要求在生物力学背景下对滑动风险进行定量分析，这是步态模拟验证和确认中的一项标准且相关的任务。因此，我们可以着手提供一个完整、合理的解决方案。\n\n该分析针对每个测试用例，包含四个不同的计算步骤，这些步骤基于固体力学和概率论的原理。\n\n1.  **最大需求摩擦系数 ($\\mu_{\\mathrm{req}}^{\\max}$)**\n\n    库仑摩擦模型假定，一个物体要与表面保持静接触（即“粘滞”），切向摩擦力的大小 $|F_{\\mathrm{t}}(t)|$ 必须不超过最大可用静摩擦力。该最大力与法向力 $F_{\\mathrm{n}}(t)$ 成正比，比例常数即为静摩擦系数 $\\mu$。因此，在任何时刻 $t$ 不发生滑动的条件是：\n    $$\n    |F_{\\mathrm{t}}(t)| \\le \\mu F_{\\mathrm{n}}(t)\n    $$\n    假设 $F_{\\mathrm{n}}(t) > 0$，这个不等式可以重新整理，定义在时间 $t$ 防止滑动所需的最小摩擦系数，即需求摩擦系数 (RCOF)：\n    $$\n    \\mathrm{RCOF}(t) = \\frac{|F_{\\mathrm{t}}(t)|}{F_{\\mathrm{n}}(t)} \\le \\mu\n    $$\n    为了使足部在整个支撑相期间避免滑动，可用摩擦系数 $\\mu$ 必須大于或等于所有时间点的 RCOF。这等同于说 $\\mu$ 必須大于或等于在支撑相期间观察到的最大 RCOF。我们将这个最大值记为 $\\mu_{\\mathrm{req}}^{\\max}$：\n    $$\n    \\mu_{\\mathrm{req}}^{\\max} = \\max_{t} \\left( \\mathrm{RCOF}(t) \\right) = \\max_{t} \\left( \\frac{|F_{\\mathrm{t}}(t)|}{F_{\\mathrm{n}}(t)} \\right)\n    $$\n    该值代表了整个模拟接触期间内最苛刻的单一摩擦要求。\n\n2.  **滑动概率 ($P_{\\mathrm{slip}}$)**\n\n    问题指定表面的摩擦系数 $\\mu$ 不是一个确定性值，而是不确定的，并被建模为一个均值为 $\\bar{\\mu}$、标准差为 $\\sigma_{\\mu}$ 的高斯（正态）随机变量。我们记为 $\\mu \\sim \\mathcal{N}(\\bar{\\mu}, \\sigma_{\\mu}^2)$。\n\n    如果可用摩擦系数 $\\mu$ 小于最大需求摩擦系数 $\\mu_{\\mathrm{req}}^{\\max}$，则发生滑动事件。因此，此事件的概率 $P_{\\mathrm{slip}}$ 为：\n    $$\n    P_{\\mathrm{slip}} = P(\\mu  \\mu_{\\mathrm{req}}^{\\max})\n    $$\n    为了计算此概率，我们使用正态分布的累积分布函数 (CDF)。首先，我们通过定义一个标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$ 来标准化该变量：\n    $$\n    Z = \\frac{\\mu - \\bar{\\mu}}{\\sigma_{\\mu}}\n    $$\n    不等式 $\\mu  \\mu_{\\mathrm{req}}^{\\max}$ 变为：\n    $$\n    \\frac{\\mu - \\bar{\\mu}}{\\sigma_{\\mu}}  \\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\n    $$\n    因此，滑动概率由标准正态分布的 CDF（通常表示为 $\\Phi(z)$）在 $\\mu_{\\mathrm{req}}^{\\max}$ 的标准化值处求得：\n    $$\n    P_{\\mathrm{slip}} = P\\left(Z  \\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) = \\Phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right)\n    $$\n    函数 $\\Phi(z)$ 通过 $\\Phi(z) = \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right)$ 与误差函数 $\\mathrm{erf}(x)$ 相关，并且在标准科学计算库中随时可用。\n\n3.  **滑动概率的灵敏度 ($\\mathrm{d}P_{\\mathrm{slip}}/\\mathrm{d}\\bar{\\mu}$)**\n\n    滑动概率相对于平均摩擦系数 $\\bar{\\mu}$ 的灵敏度，量化了平均表面摩擦的微小变化如何影响滑动的可能性。它就是这个导数：\n    $$\n    \\text{Sensitivity} = \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}}{\\mathrm{d}\\bar{\\mu}} \\left[ \\Phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) \\right]\n    $$\n    我们应用链式求导法则。设 $u(\\bar{\\mu}) = (\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}) / \\sigma_{\\mu}$。导数为：\n    $$\n    \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}\\Phi(u)}{\\mathrm{d}u} \\cdot \\frac{\\mathrm{d}u}{\\mathrm{d}\\bar{\\mu}}\n    $$\n    标准正态 CDF $\\Phi(u)$ 的导数是其概率密度函数 (PDF) $\\phi(u)$：\n    $$\n    \\frac{\\mathrm{d}\\Phi(u)}{\\mathrm{d}u} = \\phi(u) = \\frac{1}{\\sqrt{2\\pi}} e^{-u^2/2}\n    $$\n    $u$ 相对于 $\\bar{\\mu}$ 的导数是：\n    $$\n    \\frac{\\mathrm{d}u}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}}{\\mathrm{d}\\bar{\\mu}} \\left(\\frac{\\mu_{\\mathrm{req}}^{\\max}}{\\sigma_{\\mu}} - \\frac{1}{\\sigma_{\\mu}}\\bar{\\mu}\\right) = -\\frac{1}{\\sigma_{\\mu}}\n    $$\n    结合这些表达式可得出灵敏度：\n    $$\n    \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) \\cdot \\left(-\\frac{1}{\\sigma_{\\mu}}\\right) = -\\frac{1}{\\sigma_{\\mu}\\sqrt{2\\pi}} \\exp\\left(-\\frac{1}{2}\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right)^2\\right)\n    $$\n    这个值总是非正的，这在物理上是直观的：增加平均摩擦系数只会降低或保持滑动概率不变。\n\n4.  **平均值下的滑动分类 ($\\text{slip\\_at\\_mean}$)**\n\n    这是一个基于摩擦系数均值 $\\bar{\\mu}$ 作为代表值的确定性检查。根据准静态滑动准则，如果可用摩擦小于需求摩擦，则预测发生滑动。将平均可用摩擦与最大需求摩擦进行比较可得：\n    -   **滑动** 如果 $\\bar{\\mu}  \\mu_{\\mathrm{req}}^{\\max}$。\n    -   **粘滞** 如果 $\\bar{\\mu} \\ge \\mu_{\\mathrm{req}}^{\\max}$。\n\n    这将为每个用例产生一个布尔分类。\n\n将对所提供的五个测试用例系统地执行这四项计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the biomechanical slip analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 120, 300, 200, -150, -50]),\n         'mu_bar': 0.60, 'sigma_mu': 0.08},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.36, 'sigma_mu': 0.02},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.25, 'sigma_mu': 0.05},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.60, 'sigma_mu': 0.30},\n        {'Fn': np.array([400, 900, 1300, 1100, 800, 500]),\n         'Ft': np.array([0, 150, 500, 250, -200, -80]),\n         'mu_bar': 0.90, 'sigma_mu': 0.005}\n    ]\n\n    results = []\n    for case in test_cases:\n        Fn = case['Fn']\n        Ft = case['Ft']\n        mu_bar = case['mu_bar']\n        sigma_mu = case['sigma_mu']\n\n        # Task 1: Compute the maximum Required Coefficient of Friction (mu_req_max)\n        # Ensure F_n is not zero to avoid division by zero, which is guaranteed by the problem's data.\n        rcof = np.abs(Ft) / Fn\n        mu_req_max = np.max(rcof)\n\n        # Task 2: Compute the probability of slip\n        # P(slip) = P(mu  mu_req_max) where mu ~ N(mu_bar, sigma_mu^2)\n        # Standardize the variable for the CDF calculation\n        z_score = (mu_req_max - mu_bar) / sigma_mu\n        slip_probability = norm.cdf(z_score)\n\n        # Task 3: Compute the sensitivity of slip probability to mu_bar\n        # d(P_slip)/d(mu_bar) = -1/sigma_mu * PDF(z_score)\n        sensitivity = (-1 / sigma_mu) * norm.pdf(z_score)\n        \n        # Task 4: Classify slip vs. stick at the mean friction coefficient\n        # Slip predicted if mu_bar  mu_req_max\n        slip_at_mean = mu_bar  mu_req_max\n\n        results.append([mu_req_max, slip_probability, sensitivity, slip_at_mean])\n\n    # Final print statement in the exact required format.\n    # The formatting of the list of lists to string is handled by `str`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}