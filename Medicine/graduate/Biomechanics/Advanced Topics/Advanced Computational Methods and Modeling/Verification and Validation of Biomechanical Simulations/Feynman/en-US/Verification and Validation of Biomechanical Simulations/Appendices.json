{
    "hands_on_practices": [
        {
            "introduction": "Before we can trust the results of any simulation, we must first ensure that the underlying code correctly implements its intended mathematical models. This practice, known as code verification, involves systematically testing software components against known analytical solutions or fundamental physical principles. This exercise  guides you through constructing a minimal suite of verification tests for a musculoskeletal dynamics solver, building confidence in the tool's numerical correctness from the ground up.",
            "id": "4210770",
            "problem": "A musculoskeletal dynamics solver decomposes into kinematics, dynamics, and actuation subsystems. Code verification assesses numerical correctness of these subsystems against analytical invariants and exact solutions derived from foundational principles. Construct a minimal set of verification tests and implement a program to compute pass or fail for each test, using tolerances that reflect double-precision numerical limits and expected numerical integration accuracy. All angles must be in radians. All physical units must be International System of Units (SI units): meters, kilograms, seconds, and Newtons.\n\nUse the following foundational bases only:\n- Newton's Second Law of Motion: $F = m a$ and its rotational analog $ \\tau = I \\alpha $, where $ \\tau $ is torque, $ I $ is moment of inertia, and $ \\alpha $ is angular acceleration.\n- Rigid body kinematics in a plane: the rotation matrix for an angle $ \\theta $ is $ R(\\theta) = \\begin{bmatrix}\\cos \\theta & -\\sin \\theta\\\\ \\sin \\theta & \\cos \\theta \\end{bmatrix} $.\n- For a planar two-link chain with lengths $ l_1 $ and $ l_2 $, the end-effector position is $ p(\\theta_1,\\theta_2) = \\begin{bmatrix} l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2) \\\\ l_1 \\sin \\theta_1 + l_2 \\sin(\\theta_1+\\theta_2) \\end{bmatrix} $, and its Jacobian $ J(\\theta_1,\\theta_2) $ is the matrix of partial derivatives of $ p $ with respect to $ \\theta_1 $ and $ \\theta_2 $.\n- Simple pendulum dynamics without damping: for a point mass $ m $ at the end of a massless rod of length $ L $, the equation of motion is $ m L^2 \\ddot{\\theta} + m g L \\sin \\theta = 0 $, with Hamiltonian mechanical energy $ E = \\frac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos \\theta) $ conserved when only gravity acts.\n- Muscle activation dynamics modeled as a first-order Ordinary Differential Equation (ODE): $ \\dot{a} = \\frac{u - a}{\\tau} $ with constant neural input $ u $ and time constant $ \\tau $, which has exact solution $ a(t) = u + (a_0 - u) e^{-t/\\tau} $ for constant $ u $.\n- Muscle-tendon force modeled as a linear spring-damper: $ F = k (l - l_0) + c v $, and joint torque computed with a constant moment arm $ r $ is $ \\tau = r F $.\n\nYour program must implement the following minimal verification tests, each returning a boolean indicating pass (True) or fail (False):\n\n1. Kinematics: Orthonormality of planar rotation matrix at $ \\theta = 0 $. Verify that $ R(\\theta)^\\top R(\\theta) $ is the identity matrix within a tolerance of $ 10^{-12} $ in the matrix $ 2 $-norm.\n2. Kinematics: Orthonormality of planar rotation matrix at $ \\theta = \\pi $. Same criterion and tolerance as Test 1.\n3. Kinematics: Two-link end-effector velocity consistency using the Jacobian. Let $ l_1 = 0.4 \\,\\text{m} $, $ l_2 = 0.4 \\,\\text{m} $, $ \\theta_1(t) = \\omega_1 t $ with $ \\omega_1 = 1.5 \\,\\text{rad/s} $, and $ \\theta_2(t) = \\omega_2 t $ with $ \\omega_2 = -0.7 \\,\\text{rad/s} $. At $ t = 1.0 \\,\\text{s} $, compute the analytical velocity $ \\dot{p} = J(\\theta_1,\\theta_2) \\begin{bmatrix} \\omega_1 \\\\ \\omega_2 \\end{bmatrix} $ and compare to the finite-difference estimate $ \\frac{p(t+\\Delta t)-p(t-\\Delta t)}{2\\Delta t} $ with $ \\Delta t = 10^{-5} \\,\\text{s} $. Pass if the Euclidean norm of the difference is $ \\leq 10^{-8} \\,\\text{m/s} $.\n4. Dynamics: Free rigid rotation under zero torque. For a rigid body with moment of inertia $ I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2 $, initial angle $ \\theta(0) = 0.3 \\,\\text{rad} $, and initial angular velocity $ \\dot{\\theta}(0) = 2.0 \\,\\text{rad/s} $, integrate $ I \\ddot{\\theta} = 0 $ for $ T = 2.0 \\,\\text{s} $ using a fixed-step fourth-order Runge-Kutta method with $ \\Delta t = 10^{-3} \\,\\text{s} $. Pass if $ |\\dot{\\theta}(T) - \\dot{\\theta}(0)| \\leq 10^{-12} \\,\\text{rad/s} $.\n5. Dynamics: Energy consistency of a simple pendulum. Let $ m = 1.0 \\,\\text{kg} $, $ L = 1.0 \\,\\text{m} $, $ g = 9.81 \\,\\text{m/s}^2 $, initial angle $ \\theta(0) = 0.2 \\,\\text{rad} $, and initial angular velocity $ \\dot{\\theta}(0) = 0.0 \\,\\text{rad/s} $. Integrate for $ T = 2.0 \\,\\text{s} $ using a fixed-step fourth-order Runge-Kutta method with $ \\Delta t = 10^{-4} \\,\\text{s} $. Pass if the maximum relative drift of mechanical energy $ \\max_{t \\in [0,T]} \\left| \\frac{E(t) - E(0)}{E(0)} \\right| $ is $ \\leq 10^{-6} $.\n6. Actuation: Activation ODE correctness. With $ a(0) = 0.1 $, $ u = 0.7 $, and $ \\tau = 0.05 \\,\\text{s} $, integrate $ \\dot{a} = \\frac{u - a}{\\tau} $ over $ T = 1.0 \\,\\text{s} $ using fixed-step fourth-order Runge-Kutta with $ \\Delta t = 10^{-4} \\,\\text{s} $, and compare $ a(T) $ to the exact solution $ a_{\\text{exact}}(T) = u + (a(0) - u) e^{-T/\\tau} $. Pass if $ |a(T) - a_{\\text{exact}}(T)| \\leq 10^{-9} $.\n7. Actuation: Muscle-tendon torque mapping. For parameters $ k = 1500.0 \\,\\text{N/m} $, $ c = 25.0 \\,\\text{N}\\cdot\\text{s/m} $, $ l_0 = 0.30 \\,\\text{m} $, $ l = 0.33 \\,\\text{m} $, $ v = 0.0 \\,\\text{m/s} $, and moment arm $ r = 0.04 \\,\\text{m} $, compute $ F = k (l - l_0) + c v $ and $ \\tau = r F $. Pass if the numerically computed torque equals $ \\tau $ within $ 10^{-12} \\,\\text{N}\\cdot\\text{m} $.\n\nTest Suite:\n- Test 1: $ \\theta = 0 $.\n- Test 2: $ \\theta = \\pi $.\n- Test 3: $ l_1 = 0.4 \\,\\text{m} $, $ l_2 = 0.4 \\,\\text{m} $, $ \\omega_1 = 1.5 \\,\\text{rad/s} $, $ \\omega_2 = -0.7 \\,\\text{rad/s} $, $ t = 1.0 \\,\\text{s} $, $ \\Delta t = 10^{-5} \\,\\text{s} $.\n- Test 4: $ I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2 $, $ \\theta(0) = 0.3 \\,\\text{rad} $, $ \\dot{\\theta}(0) = 2.0 \\,\\text{rad/s} $, $ T = 2.0 \\,\\text{s} $, $ \\Delta t = 10^{-3} \\,\\text{s} $.\n- Test 5: $ m = 1.0 \\,\\text{kg} $, $ L = 1.0 \\,\\text{m} $, $ g = 9.81 \\,\\text{m/s}^2 $, $ \\theta(0) = 0.2 \\,\\text{rad} $, $ \\dot{\\theta}(0) = 0.0 \\,\\text{rad/s} $, $ T = 2.0 \\,\\text{s} $, $ \\Delta t = 10^{-4} \\,\\text{s} $.\n- Test 6: $ a(0) = 0.1 $, $ u = 0.7 $, $ \\tau = 0.05 \\,\\text{s} $, $ T = 1.0 \\,\\text{s} $, $ \\Delta t = 10^{-4} \\,\\text{s} $.\n- Test 7: $ k = 1500.0 \\,\\text{N/m} $, $ c = 25.0 \\,\\text{N}\\cdot\\text{s/m} $, $ l_0 = 0.30 \\,\\text{m} $, $ l = 0.33 \\,\\text{m} $, $ v = 0.0 \\,\\text{m/s} $, $ r = 0.04 \\,\\text{m} $.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...,result7]\"), where each result is a boolean indicating pass or fail in the exact order of Tests 1 through 7.",
            "solution": "The process of verifying a musculoskeletal dynamics solver involves ensuring that each of its computational subsystems correctly implements the underlying mathematical models. This is achieved by comparing the solver's output against known analytical solutions or conserved quantities derived from fundamental principles. The following sections detail a minimal suite of verification tests for the kinematics, dynamics, and actuation components of such a solver.\n\nA fourth-order Runge-Kutta (RK4) integrator is employed for solving the ordinary differential equations (ODEs) that arise. For a given first-order ODE system $\\dot{\\mathbf{y}} = \\mathbf{f}(t, \\mathbf{y})$, a single integration step from time $t_n$ to $t_{n+1} = t_n + \\Delta t$ is computed as:\n$$ \\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{1}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4) $$\nwhere\n$$ \\mathbf{k}_1 = \\Delta t \\cdot \\mathbf{f}(t_n, \\mathbf{y}_n) $$\n$$ \\mathbf{k}_2 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_1}{2}) $$\n$$ \\mathbf{k}_3 = \\Delta t \\cdot \\mathbf{f}(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\mathbf{k}_2}{2}) $$\n$$ \\mathbf{k}_4 = \\Delta t \\cdot \\mathbf{f}(t_n + \\Delta t, \\mathbf{y}_n + \\mathbf{k}_3) $$\n\n**Test 1 & 2: Kinematics — Orthonormality of Planar Rotation Matrix**\nThe purpose of this test is to verify the correct implementation of a $2$D rigid body rotation matrix. A fundamental property of any rotation matrix $R$ is its orthonormality, which means its transpose is also its inverse, i.e., $R^\\top R = I$, where $I$ is the identity matrix. This property ensures that the transformation preserves lengths and angles, which is definitional for a rigid body rotation.\nWe test this property for a planar rotation matrix, given by:\n$$ R(\\theta) = \\begin{bmatrix}\\cos \\theta & -\\sin \\theta\\\\ \\sin \\theta & \\cos \\theta \\end{bmatrix} $$\nThe test is performed for two fundamental angles, $\\theta = 0$ and $\\theta = \\pi$. The verification check computes the matrix difference $D = R(\\theta)^\\top R(\\theta) - I$ and asserts that its matrix $2$-norm, $\\|D\\|_2$, is less than a tolerance of $10^{-12}$, which accounts for floating-point precision limits. For $\\theta=0$, $R(0)=I$, and for $\\theta=\\pi$, $R(\\pi)=-I$. In both cases, $R^\\top R = I$ analytically, so the numerical error should be close to machine epsilon.\n\n**Test 3: Kinematics — Two-Link End-Effector Velocity Consistency**\nThis test verifies the relationship between joint-space velocities and Cartesian-space velocities via the Jacobian matrix. For a kinematic chain, the velocity of the end-effector, $\\dot{\\mathbf{p}}$, is related to the vector of joint angular velocities, $\\dot{\\mathbf{\\theta}}$, by the linear mapping $\\dot{\\mathbf{p}} = J(\\mathbf{\\theta})\\dot{\\mathbf{\\theta}}$. Here, $J(\\mathbf{\\theta})$ is the Jacobian matrix, containing the partial derivatives of the end-effector position with respect to the joint angles.\nThe position vector for the specified two-link arm is:\n$$ \\mathbf{p}(\\theta_1,\\theta_2) = \\begin{bmatrix} l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2) \\\\ l_1 \\sin \\theta_1 + l_2 \\sin(\\theta_1+\\theta_2) \\end{bmatrix} $$\nThe corresponding Jacobian matrix is:\n$$ J(\\theta_1, \\theta_2) = \\frac{\\partial \\mathbf{p}}{\\partial (\\theta_1, \\theta_2)} = \\begin{bmatrix} -l_1 \\sin \\theta_1 - l_2 \\sin(\\theta_1+\\theta_2) & -l_2 \\sin(\\theta_1+\\theta_2) \\\\ l_1 \\cos \\theta_1 + l_2 \\cos(\\theta_1+\\theta_2) & l_2 \\cos(\\theta_1+\\theta_2) \\end{bmatrix} $$\nThe test compares the analytically computed velocity $\\dot{\\mathbf{p}}_{\\text{analytical}} = J(\\mathbf{\\theta}(t))\\dot{\\mathbf{\\theta}}$ with a numerically approximated velocity, $\\dot{\\mathbf{p}}_{\\text{numerical}}$, calculated using a second-order central finite difference scheme:\n$$ \\dot{\\mathbf{p}}_{\\text{numerical}} \\approx \\frac{\\mathbf{p}(\\mathbf{\\theta}(t+\\Delta t)) - \\mathbf{p}(\\mathbf{\\theta}(t-\\Delta t))}{2\\Delta t} $$\nFor the given parameters $l_1 = 0.4 \\,\\text{m}$, $l_2 = 0.4 \\,\\text{m}$, $\\dot{\\theta}_1 = \\omega_1 = 1.5 \\,\\text{rad/s}$, $\\dot{\\theta}_2 = \\omega_2 = -0.7 \\,\\text{rad/s}$ at time $t=1.0 \\,\\text{s}$ with a finite difference step of $\\Delta t = 10^{-5} \\,\\text{s}$, a passing result requires the Euclidean norm of the difference, $\\|\\dot{\\mathbf{p}}_{\\text{analytical}} - \\dot{\\mathbf{p}}_{\\text{numerical}}\\|_2$, to be no greater than $10^{-8} \\,\\text{m/s}$. The expected error for this approximation is proportional to $(\\Delta t)^2$, making the tolerance appropriate.\n\n**Test 4: Dynamics — Free Rigid Rotation**\nThis test verifies the dynamics solver's ability to conserve angular momentum. According to Newton's Second Law for rotation, $\\tau = I \\alpha = I \\ddot{\\theta}$, where $\\tau$ is net external torque, $I$ is moment of inertia, and $\\ddot{\\theta}$ is angular acceleration. In the absence of any torque ($\\tau=0$), the angular acceleration is zero, i.e., $\\ddot{\\theta} = 0$. Integrating this equation yields a constant angular velocity: $\\dot{\\theta}(t) = \\dot{\\theta}(0)$.\nThe test simulates a rigid body with $I = 0.25 \\,\\text{kg}\\cdot\\text{m}^2$ and initial conditions $\\theta(0) = 0.3 \\,\\text{rad}$ and $\\dot{\\theta}(0) = 2.0 \\,\\text{rad/s}$ for $T = 2.0 \\,\\text{s}$. The equation is integrated using the RK4 method. A passing result requires that the final angular velocity $\\dot{\\theta}(T)$ be equal to the initial angular velocity $\\dot{\\theta}(0)$ within a strict tolerance of $10^{-12} \\,\\text{rad/s}$, reflecting the fact that RK4 can integrate polynomials of degree up to $4$ exactly, and $\\ddot{\\theta}=0$ is a trivial case.\n\n**Test 5: Dynamics — Energy Consistency of a Simple Pendulum**\nThis test verifies the energy conservation properties of the numerical integrator for a conservative system. The simple pendulum, governed by the equation of motion $m L^2 \\ddot{\\theta} + m g L \\sin \\theta = 0$, is a classical example of a system where total mechanical energy is conserved. The Hamiltonian, or total mechanical energy $E$, is the sum of kinetic and potential energy:\n$$ E = \\underbrace{\\frac{1}{2} m L^2 \\dot{\\theta}^2}_{\\text{Kinetic}} + \\underbrace{m g L (1 - \\cos \\theta)}_{\\text{Potential}} $$\nThe test integrates the pendulum's motion from rest ($\\dot{\\theta}(0)=0$) at an initial angle $\\theta(0)=0.2 \\,\\text{rad}$ using the RK4 method. Although RK4 is not a symplectic integrator and is not designed to conserve energy perfectly over long periods, its high order of accuracy should ensure that the energy drift remains very small for a reasonable integration time. The test passes if the maximum relative energy drift, $\\max_{t \\in [0,T]} |(E(t) - E(0))/E(0)|$, does not exceed $10^{-6}$ over a duration of $T = 2.0 \\,\\text{s}$.\n\n**Test 6: Actuation — Activation ODE Correctness**\nThis test verifies the ODE solver against a known analytical solution for a common biomechanical model: first-order muscle activation dynamics. The model is given by the linear first-order ODE:\n$$ \\dot{a} = \\frac{u - a}{\\tau} $$\nwhere $a(t)$ is the muscle activation level, $u$ is the constant neural input, and $\\tau$ is a time constant. For a constant input $u$ and initial condition $a(0)=a_0$, this equation has the exact analytical solution:\n$$ a(t) = u + (a_0 - u) \\exp(-t/\\tau) $$\nThe test integrates the ODE numerically using RK4 from $a(0) = 0.1$ with parameters $u=0.7$ and $\\tau=0.05\\,\\text{s}$ over a period of $T=1.0\\,\\text{s}$. The numerical result $a(T)$ is compared to the exact solution $a_{\\text{exact}}(T)$. The test passes if the absolute error $|a(T) - a_{\\text{exact}}(T)|$ is no more than $10^{-9}$, a tolerance that reflects the expected high accuracy of the RK4 method for a well-behaved ODE.\n\n**Test 7: Actuation — Muscle-Tendon Torque Mapping**\nThis final test is a simple unit-level verification for the algebraic calculation of joint torque from muscle-tendon properties. It checks the implementation of a linear Hill-type muscle model, where force $F$ is a function of length $l$ and velocity $v$:\n$$ F = k (l - l_0) + c v $$\nHere, $k$ is the stiffness, $l_0$ is the resting length, and $c$ is the damping coefficient. The joint torque $\\tau$ is then computed by multiplying this force by a constant moment arm $r$:\n$$ \\tau = r F $$\nThe test involves computing the torque for a given set of parameters. This type of test is crucial for ensuring that even the most basic components of the model are implemented correctly, as errors in these simple mappings can propagate and corrupt the entire simulation. A passing result requires the numerically computed torque to match the analytically calculated value of $1.8 \\,\\text{N}\\cdot\\text{m}$ to within a tolerance of $10^{-12} \\,\\text{N}\\cdot\\text{m}$, which is appropriate for a direct floating-point calculation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Executes a suite of verification tests for a musculoskeletal dynamics solver.\n    \"\"\"\n\n    def rk4_step(f, y, t, dt, *args):\n        \"\"\"\n        Performs a single step of the fourth-order Runge-Kutta method.\n        f: function for dy/dt = f(t, y, *args)\n        y: current state (numpy array)\n        t: current time\n        dt: time step\n        args: additional constant arguments for f\n        \"\"\"\n        k1 = dt * f(t, y, *args)\n        k2 = dt * f(t + 0.5 * dt, y + 0.5 * k1, *args)\n        k3 = dt * f(t + 0.5 * dt, y + 0.5 * k2, *args)\n        k4 = dt * f(t + dt, y + k3, *args)\n        return y + (k1 + 2 * k2 + 2 * k3 + k4) / 6.0\n\n    def test1():\n        \"\"\"Kinematics: Orthonormality of planar rotation matrix at theta = 0.\"\"\"\n        theta = 0.0\n        R = np.array([\n            [np.cos(theta), -np.sin(theta)],\n            [np.sin(theta),  np.cos(theta)]\n        ])\n        I = np.identity(2)\n        diff_matrix = R.T @ R - I\n        norm = np.linalg.norm(diff_matrix, 2)\n        return norm <= 1e-12\n\n    def test2():\n        \"\"\"Kinematics: Orthonormality of planar rotation matrix at theta = pi.\"\"\"\n        theta = np.pi\n        R = np.array([\n            [np.cos(theta), -np.sin(theta)],\n            [np.sin(theta),  np.cos(theta)]\n        ])\n        I = np.identity(2)\n        diff_matrix = R.T @ R - I\n        norm = np.linalg.norm(diff_matrix, 2)\n        return norm <= 1e-12\n\n    def test3(params):\n        \"\"\"Kinematics: Two-link end-effector velocity consistency using the Jacobian.\"\"\"\n        l1, l2, w1, w2, t_eval, dt_fd = params\n\n        def p_func(th1, th2):\n            return np.array([\n                l1 * np.cos(th1) + l2 * np.cos(th1 + th2),\n                l1 * np.sin(th1) + l2 * np.sin(th1 + th2)\n            ])\n\n        def J_func(th1, th2):\n            s1, c1 = np.sin(th1), np.cos(th1)\n            s12, c12 = np.sin(th1 + th2), np.cos(th1 + th2)\n            return np.array([\n                [-l1 * s1 - l2 * s12, -l2 * s12],\n                [ l1 * c1 + l2 * c12,  l2 * c12]\n            ])\n\n        th1_t, th2_t = w1 * t_eval, w2 * t_eval\n        J = J_func(th1_t, th2_t)\n        v_analytical = J @ np.array([w1, w2])\n\n        p_plus = p_func(w1 * (t_eval + dt_fd), w2 * (t_eval + dt_fd))\n        p_minus = p_func(w1 * (t_eval - dt_fd), w2 * (t_eval - dt_fd))\n        v_numerical = (p_plus - p_minus) / (2 * dt_fd)\n\n        error = np.linalg.norm(v_analytical - v_numerical)\n        return error <= 1e-8\n\n    def test4(params):\n        \"\"\"Dynamics: Free rigid rotation under zero torque.\"\"\"\n        I, theta0, dtheta0, T, dt = params\n        \n        def ode_free_rotation(t, y):\n            return np.array([y[1], 0.0])\n\n        y = np.array([theta0, dtheta0])\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_free_rotation, y, current_time, dt)\n            current_time += dt\n        \n        dtheta_final = y[1]\n        error = abs(dtheta_final - dtheta0)\n        return error <= 1e-12\n\n    def test5(params):\n        \"\"\"Dynamics: Energy consistency of a simple pendulum.\"\"\"\n        m, L, g, theta0, dtheta0, T, dt = params\n\n        def ode_pendulum(t, y, g_val, L_val):\n            return np.array([y[1], -(g_val / L_val) * np.sin(y[0])])\n        \n        def energy_func(y_state, m_val, L_val, g_val):\n            theta, dtheta = y_state\n            kinetic = 0.5 * m_val * (L_val * dtheta)**2\n            potential = m_val * g_val * L_val * (1.0 - np.cos(theta))\n            return kinetic + potential\n\n        y = np.array([theta0, dtheta0])\n        E0 = energy_func(y, m, L, g)\n        if E0 == 0: return False # Relative error is undefined, but implies non-moving test fails\n\n        max_relative_drift = 0.0\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_pendulum, y, current_time, dt, g, L)\n            current_time += dt\n            Et = energy_func(y, m, L, g)\n            relative_drift = abs((Et - E0) / E0)\n            if relative_drift > max_relative_drift:\n                max_relative_drift = relative_drift\n                \n        return max_relative_drift <= 1e-6\n\n    def test6(params):\n        \"\"\"Actuation: Activation ODE correctness.\"\"\"\n        a0, u, tau, T, dt = params\n        \n        def ode_activation(t, y, u_val, tau_val):\n            return np.array([(u_val - y[0]) / tau_val])\n\n        y = np.array([a0])\n        num_steps = int(np.round(T / dt))\n        current_time = 0.0\n        for _ in range(num_steps):\n            y = rk4_step(ode_activation, y, current_time, dt, u, tau)\n            current_time += dt\n            \n        a_numerical = y[0]\n        a_exact = u + (a0 - u) * np.exp(-T / tau)\n        \n        error = abs(a_numerical - a_exact)\n        return error <= 1e-9\n\n    def test7(params):\n        \"\"\"Actuation: Muscle-tendon torque mapping.\"\"\"\n        k, c, l0, l, v, r = params\n        \n        # \"Numerically computed\" means computed by the function under test\n        force = k * (l - l0) + c * v\n        torque_computed = r * force\n        \n        # Analytical value is the same calculation, for self-consistency check\n        torque_analytical = r * (k * (l - l0) + c * v)\n        \n        error = abs(torque_computed - torque_analytical)\n        return error <= 1e-12\n\n    # Define test cases from the problem statement.\n    test_cases_params = [\n        (),  # Test 1 has no params\n        (),  # Test 2 has no params\n        (0.4, 0.4, 1.5, -0.7, 1.0, 1e-5),  # Test 3\n        (0.25, 0.3, 2.0, 2.0, 1e-3),        # Test 4\n        (1.0, 1.0, 9.81, 0.2, 0.0, 2.0, 1e-4), # Test 5\n        (0.1, 0.7, 0.05, 1.0, 1e-4),          # Test 6\n        (1500.0, 25.0, 0.30, 0.33, 0.0, 0.04) # Test 7\n    ]\n\n    test_functions = [test1, test2, test3, test4, test5, test6, test7]\n    \n    results = []\n    for i, func in enumerate(test_functions):\n        params = test_cases_params[i]\n        if params:\n            result = func(params)\n        else:\n            result = func()\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Once we have verified that our code is free of bugs, we must then verify the accuracy of the solution for a specific problem, a process called solution verification. Since most biomechanical simulations rely on discretizing continuous domains, it is crucial to quantify the discretization error and estimate the \"true\" solution that would be obtained with an infinitely fine mesh. This practice  introduces Richardson extrapolation, a powerful technique to estimate the convergence rate and the mesh-independent solution from a series of simulations on systematically refined grids.",
            "id": "4210759",
            "problem": "A computational biomechanics team is verifying a finite element method (FEM) simulation of tibiofemoral contact force during level walking. They analyze the mesh refinement behavior of a scalar observable, the peak tibiofemoral contact force, denoted by $Q(h)$, where $h$ is a characteristic mesh size defined as the maximum edge length in the contact region. In the asymptotic regime of grid convergence for a consistent discretization, it is assumed that the leading-order discretization error admits the model\n$$\nQ(h) = Q_0 + C h^{p},\n$$\nwhere $Q_0$ is the continuum (mesh-independent) value, $C$ is an unknown constant, and $p$ is the observed order of accuracy of the method. The team employs a fixed refinement ratio $r>1$ between successive meshes and acquires $Q(h)$ at three grid levels $h$, $h/r$, and $h/r^{2}$ under otherwise identical physical and numerical settings. Assume monotonic convergence with decreasing $h$ consistent with $C>0$ and $p>0$.\n\nTasks:\n1. Starting only from the error model $Q(h) = Q_0 + C h^{p}$ and the definition of the refinement ratio $r$, derive a two-grid Richardson extrapolation formula that eliminates the leading-order term to express $Q_0$ in terms of $Q(h)$, $Q(h/r)$, $r$, and $p$.\n2. Derive a three-grid estimator for the observed order $p$ in terms of $Q(h)$, $Q(h/r)$, $Q(h/r^{2})$, and $r$, again starting only from the error model.\n3. The FEM outputs for peak tibiofemoral contact force are measured on meshes with $h_1 = 2.0\\ \\mathrm{mm}$, $h_2 = 1.0\\ \\mathrm{mm}$, and $h_3 = 0.5\\ \\mathrm{mm}$, corresponding to a refinement ratio $r = 2$. The reported values are $Q(h_1) = 2146.5\\ \\mathrm{N}$, $Q(h_2) = 2010\\ \\mathrm{N}$, and $Q(h_3) = 1973.41\\ \\mathrm{N}$. Using your derived formulas, estimate $p$ and then compute the Richardson-extrapolated continuum value $Q_0$. Express the final $Q_0$ in $\\mathrm{N}$ and round your final answer to four significant figures.",
            "solution": "The problem is first validated to ensure it is scientifically grounded, well-posed, and objective. The provided problem statement describes a standard grid convergence study using Richardson extrapolation, a well-established technique in numerical analysis for verifying computational models. The governing error model, $Q(h) = Q_0 + C h^{p}$, is a fundamental assumption for discretization error in the asymptotic regime. The data provided are self-contained and consistent; the values for the peak tibiofemoral contact force decrease with decreasing mesh size ($2146.5\\ \\mathrm{N} > 2010\\ \\mathrm{N} > 1973.41\\ \\mathrm{N}$), which is consistent with monotonic convergence for $C>0$. The problem is therefore deemed valid, and a solution is constructed as follows.\n\nThe problem is divided into three parts: the derivation of a two-grid Richardson extrapolation formula, the derivation of a three-grid estimator for the observed order of accuracy, and the application of these formulas to the given numerical data.\n\n**1. Derivation of the Richardson Extrapolation Formula for $Q_0$**\n\nWe start with the provided error model for the discretization error:\n$$\nQ(h) = Q_0 + C h^{p}\n$$\nwhere $Q(h)$ is the numerical solution for a characteristic mesh size $h$, $Q_0$ is the exact (continuum) solution, $C$ is a constant, and $p$ is the order of accuracy.\n\nWe consider two grid levels, one with mesh size $h$ and a finer one with mesh size $h/r$, where $r > 1$ is the refinement ratio. The model provides a system of two equations:\n\\begin{enumerate}\n    \\item For mesh size $h$: $Q(h) = Q_0 + C h^{p}$\n    \\item For mesh size $h/r$: $Q(h/r) = Q_0 + C \\left(\\frac{h}{r}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{p}}$\n\\end{enumerate}\n\nOur goal is to eliminate the term containing the unknown constant $C$, which is $C h^{p}$. We can express this term from the first equation as $C h^{p} = Q(h) - Q_0$. Substituting this into the second equation gives:\n$$\nQ(h/r) = Q_0 + \\frac{Q(h) - Q_0}{r^{p}}\n$$\nNow, we solve for $Q_0$. Multiply both sides by $r^{p}$:\n$$\nr^{p} Q(h/r) = r^{p} Q_0 + Q(h) - Q_0\n$$\nGroup the terms involving $Q_0$:\n$$\nr^{p} Q(h/r) - Q(h) = (r^{p} - 1) Q_0\n$$\nIsolating $Q_0$ yields the two-grid Richardson extrapolation formula:\n$$\nQ_0 = \\frac{r^{p} Q(h/r) - Q(h)}{r^{p} - 1}\n$$\nThis formula provides an estimate of the continuum value $Q_0$ based on solutions from two grid levels and the order of accuracy $p$.\n\n**2. Derivation of the Three-Grid Estimator for $p$**\n\nTo estimate the observed order of accuracy $p$, we require data from three grid levels. Let the mesh sizes be $h$, $h/r$, and $h/r^{2}$. For clarity, we denote the corresponding numerical solutions as:\n- $Q_1 = Q(h)$\n- $Q_2 = Q(h/r)$\n- $Q_3 = Q(h/r^{2})$\n\nThe error model provides a system of three equations:\n\\begin{align*}\nQ_1 &= Q_0 + C h^{p} \\\\\nQ_2 &= Q_0 + C \\left(\\frac{h}{r}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{p}} \\\\\nQ_3 &= Q_0 + C \\left(\\frac{h}{r^{2}}\\right)^{p} = Q_0 + \\frac{C h^{p}}{r^{2p}}\n\\end{align*}\n\nWe can eliminate $Q_0$ and $C$ by considering the differences between successive solutions.\nFirst, the difference between the solutions on the coarsest and medium grids:\n$$\nQ_1 - Q_2 = (Q_0 + C h^{p}) - \\left(Q_0 + \\frac{C h^{p}}{r^{p}}\\right) = C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)\n$$\nNext, the difference between the solutions on the medium and finest grids:\n$$\nQ_2 - Q_3 = \\left(Q_0 + \\frac{C h^{p}}{r^{p}}\\right) - \\left(Q_0 + \\frac{C h^{p}}{r^{2p}}\\right) = \\frac{C h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)\n$$\nNow, taking the ratio of these two differences eliminates the unknown terms $C h^{p}$ and $\\left(1 - 1/r^{p}\\right)$:\n$$\n\\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{C h^{p} \\left(1 - \\frac{1}{r^{p}}\\right)}{\\frac{C h^{p}}{r^{p}} \\left(1 - \\frac{1}{r^{p}}\\right)} = r^{p}\n$$\nTo solve for $p$, we take the natural logarithm of both sides:\n$$\n\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right) = \\ln(r^{p}) = p \\ln(r)\n$$\nIsolating $p$ gives the three-grid estimator for the observed order of accuracy:\n$$\np = \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{Q(h) - Q(h/r)}{Q(h/r) - Q(h/r^2)}\\right)}{\\ln(r)}\n$$\n\n**3. Numerical Calculation of $p$ and $Q_0$**\n\nThe problem provides the following data from the FEM simulation:\n- Refinement ratio: $r = 2$\n- For mesh size $h_1 = 2.0\\ \\mathrm{mm}$: $Q_1 = Q(h_1) = 2146.5\\ \\mathrm{N}$\n- For mesh size $h_2 = 1.0\\ \\mathrm{mm}$: $Q_2 = Q(h_2) = 2010\\ \\mathrm{N}$\n- For mesh size $h_3 = 0.5\\ \\mathrm{mm}$: $Q_3 = Q(h_3) = 1973.41\\ \\mathrm{N}$\nThese mesh sizes correspond to a coarse mesh $h_1$, a refined mesh $h_2 = h_1/r$, and a further refined mesh $h_3 = h_1/r^2$.\n\nFirst, we use the derived formula to estimate the observed order of accuracy $p$:\n$$\np = \\frac{\\ln\\left(\\frac{Q_1 - Q_2}{Q_2 - Q_3}\\right)}{\\ln(r)} = \\frac{\\ln\\left(\\frac{2146.5 - 2010}{2010 - 1973.41}\\right)}{\\ln(2)}\n$$\nCalculating the differences:\n$$\nQ_1 - Q_2 = 136.5\n$$\n$$\nQ_2 - Q_3 = 36.59\n$$\nSubstituting these values:\n$$\np = \\frac{\\ln\\left(\\frac{136.5}{36.59}\\right)}{\\ln(2)} \\approx \\frac{\\ln(3.7305274665)}{\\ln(2)} \\approx \\frac{1.3165819}{0.69314718} \\approx 1.90001\n$$\n\nNext, we calculate the Richardson-extrapolated continuum value $Q_0$. It is standard practice to use the two finest grids for this extrapolation, as they are expected to be deeper within the asymptotic regime of convergence. We therefore apply the two-grid formula using the solutions $Q_2$ and $Q_3$. In this case, the \"coarse\" grid in the formula corresponds to $h_2$ and the \"fine\" grid corresponds to $h_3 = h_2/r$. The formula becomes:\n$$\nQ_0 = \\frac{r^{p} Q_3 - Q_2}{r^{p} - 1}\n$$\nFrom the calculation of $p$, we already know that $r^p = \\frac{Q_1 - Q_2}{Q_2 - Q_3} = \\frac{136.5}{36.59}$. We can substitute this directly to avoid rounding errors from the intermediate value of $p$.\n$$\nQ_0 = \\frac{\\left(\\frac{136.5}{36.59}\\right) Q_3 - Q_2}{\\left(\\frac{136.5}{36.59}\\right) - 1}\n$$\nSubstituting the numerical values for $Q_2$ and $Q_3$:\n$$\nQ_0 = \\frac{\\left(\\frac{136.5}{36.59}\\right) (1973.41) - 2010}{\\left(\\frac{136.5}{36.59}\\right) - 1} \\approx \\frac{(3.7305274665)(1973.41) - 2010}{3.7305274665 - 1}\n$$\n$$\nQ_0 \\approx \\frac{7362.011038 - 2010}{2.7305274665} = \\frac{5352.011038}{2.7305274665} \\approx 1960.0900\n$$\nThe problem requires the final answer for $Q_0$ to be rounded to four significant figures.\n$$\nQ_0 \\approx 1960\\ \\mathrm{N}\n$$",
            "answer": "$$\\boxed{1960}$$"
        },
        {
            "introduction": "The final step in establishing model credibility is validation: determining the degree to which a model is an accurate representation of the real world for its intended use. This process is complicated by the fact that many real-world parameters, like the coefficient of friction $\\mu$, are not known with certainty. This exercise  challenges you to go beyond deterministic predictions by incorporating parameter uncertainty into your analysis, allowing you to calculate the probability of an event (like a slip during gait) and assess the model's sensitivity to uncertain inputs.",
            "id": "4210771",
            "problem": "A bipedal gait simulation predicts time-resolved Ground Reaction Forces (GRF: Ground Reaction Forces) during the stance phase. Verification and validation require assessing whether the predicted foot–ground contact remains in static friction (\"stick\") or transitions to kinetic friction (\"slip\") under uncertainty in the friction coefficient. Use the following fundamental base: Newton's Second Law of Motion for forces and the Coulomb friction law for dry contact. The Coulomb friction law states that static friction can be maintained so long as the magnitude of tangential contact force does not exceed the maximum available static friction proportional to the normal load.\n\nConsider discrete time samples indexed by $t$ over stance for the tangential GRF $F_{\\mathrm{t}}(t)$ and normal GRF $F_{\\mathrm{n}}(t)$, both expressed in Newtons. The Required Coefficient of Friction (RCOF: Required Coefficient of Friction) at time $t$ is defined as the ratio $|F_{\\mathrm{t}}(t)|/F_{\\mathrm{n}}(t)$, which is unitless. The simulation predicts no slip throughout stance if the surface friction coefficient $\\mu$ exceeds the maximum RCOF over stance. In realistic use, $\\mu$ is uncertain due to surface heterogeneity and measurement variability; model $\\mu$ as a Gaussian random variable with mean $\\bar{\\mu}$ and standard deviation $\\sigma_{\\mu}$, independent of time.\n\nTasks to implement:\n- Compute the time series $|F_{\\mathrm{t}}(t)|/F_{\\mathrm{n}}(t)$ and its maximum over stance, denoted $\\mu_{\\mathrm{req}}^{\\max}$.\n- Under the quasi-static slip criterion, classify slip versus stick across stance by comparing $\\mu$ to $\\mu_{\\mathrm{req}}^{\\max}$. Because $\\mu$ is uncertain, quantify the probability of slip, defined as the probability that $\\mu$ is less than $\\mu_{\\mathrm{req}}^{\\max}$, assuming the specified Gaussian model.\n- Quantify threshold behavior by computing the sensitivity of the slip probability with respect to the mean friction coefficient $\\bar{\\mu}$ at the given parameter values. Specifically, compute the derivative of the slip probability with respect to $\\bar{\\mu}$ while holding $\\sigma_{\\mu}$ constant.\n- Provide, for each test case, the following four outputs: $\\mu_{\\mathrm{req}}^{\\max}$ (unitless), the slip probability as a decimal in $[0,1]$ (unitless), the sensitivity $\\mathrm{d}(\\text{slip probability})/\\mathrm{d}\\bar{\\mu}$ (unitless), and a boolean classification indicating whether slip would be predicted at the mean friction coefficient (stick if $\\bar{\\mu} \\ge \\mu_{\\mathrm{req}}^{\\max}$, slip otherwise).\n\nPhysical unit requirements:\n- $F_{\\mathrm{t}}(t)$ and $F_{\\mathrm{n}}(t)$ must be treated in Newtons ($\\mathrm{N}$).\n- All coefficients of friction and probabilities are unitless and must be expressed as decimals.\n- No angles appear; no angle unit is required.\n\nImplement a program that performs these computations for the following test suite. Each case is defined by arrays of $F_{\\mathrm{t}}(t)$ and $F_{\\mathrm{n}}(t)$ in $\\mathrm{N}$, together with $\\bar{\\mu}$ and $\\sigma_{\\mu}$:\n1. Case $1$: $F_{\\mathrm{n}} = [300, 800, 1200, 1000, 700, 400]$, $F_{\\mathrm{t}} = [0, 120, 300, 200, -150, -50]$, $\\bar{\\mu} = 0.60, \\sigma_{\\mu} = 0.08$.\n2. Case $2$: $F_{\\mathrm{n}} = [300, 800, 1200, 1000, 700, 400]$, $F_{\\mathrm{t}} = [0, 180, 420, 260, -210, -70]$, $\\bar{\\mu} = 0.36, \\sigma_{\\mu} = 0.02$.\n3. Case $3$: $F_{\\mathrm{n}} = [300, 800, 1200, 1000, 700, 400]$, $F_{\\mathrm{t}} = [0, 180, 420, 260, -210, -70]$, $\\bar{\\mu} = 0.25, \\sigma_{\\mu} = 0.05$.\n4. Case $4$: $F_{\\mathrm{n}} = [300, 800, 1200, 1000, 700, 400]$, $F_{\\mathrm{t}} = [0, 180, 420, 260, -210, -70]$, $\\bar{\\mu} = 0.60, \\sigma_{\\mu} = 0.30$.\n5. Case $5$: $F_{\\mathrm{n}} = [400, 900, 1300, 1100, 800, 500]$, $F_{\\mathrm{t}} = [0, 150, 500, 250, -200, -80]$, $\\bar{\\mu} = 0.90, \\sigma_{\\mu} = 0.005$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this top-level list corresponds to a test case and must itself be a list with the format $[\\mu_{\\mathrm{req}}^{\\max}, \\text{slip\\_probability}, \\mathrm{d}(\\text{slip probability})/\\mathrm{d}\\bar{\\mu}, \\text{slip\\_at\\_mean}]$. For example, the overall printed string must look like $[\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots],\\,[\\dots]\\,]$ and contain only this single line.",
            "solution": "The problem statement has been meticulously validated and is determined to be valid. It is scientifically grounded in the principles of classical mechanics (Coulomb friction), well-posed with sufficient and consistent data, and objectively formulated. The problem requires a quantitative analysis of slip risk in a biomechanical context, which is a standard and relevant task in the verification and validation of gait simulations. We may therefore proceed with a complete, reasoned solution.\n\nThe analysis involves four distinct computational steps for each test case, grounded in the principles of solid mechanics and probability theory.\n\n1.  **Maximum Required Coefficient of Friction ($\\mu_{\\mathrm{req}}^{\\max}$)**\n\n    The Coulomb friction model posits that for a body to remain in static contact (i.e., to \"stick\") with a surface, the magnitude of the tangential friction force, $|F_{\\mathrm{t}}(t)|$, must not exceed the maximum available static friction force. This maximum force is proportional to the normal force, $F_{\\mathrm{n}}(t)$, where the constant of proportionality is the static coefficient of friction, $\\mu$. The condition for no slip at any time instant $t$ is thus:\n    $$\n    |F_{\\mathrm{t}}(t)| \\le \\mu F_{\\mathrm{n}}(t)\n    $$\n    Assuming $F_{\\mathrm{n}}(t) > 0$, this inequality can be rearranged to define the minimum coefficient of friction required to prevent slip at time $t$, known as the Required Coefficient of Friction (RCOF):\n    $$\n    \\mathrm{RCOF}(t) = \\frac{|F_{\\mathrm{t}}(t)|}{F_{\\mathrm{n}}(t)} \\le \\mu\n    $$\n    For the foot to avoid slipping throughout the entire stance phase, the available friction coefficient $\\mu$ must be greater than or equal to the RCOF at all time points. This is equivalent to stating that $\\mu$ must be greater than or equal to the maximum RCOF observed during the stance phase. We denote this maximum value as $\\mu_{\\mathrm{req}}^{\\max}$:\n    $$\n    \\mu_{\\mathrm{req}}^{\\max} = \\max_{t} \\left( \\mathrm{RCOF}(t) \\right) = \\max_{t} \\left( \\frac{|F_{\\mathrm{t}}(t)|}{F_{\\mathrm{n}}(t)} \\right)\n    $$\n    This value represents the single most demanding friction requirement over the entire simulated contact period.\n\n2.  **Probability of Slip ($P_{\\mathrm{slip}}$)**\n\n    The problem specifies that the surface's coefficient of friction, $\\mu$, is not a deterministic value but is uncertain and modeled as a Gaussian (normal) random variable with mean $\\bar{\\mu}$ and standard deviation $\\sigma_{\\mu}$. We write this as $\\mu \\sim \\mathcal{N}(\\bar{\\mu}, \\sigma_{\\mu}^2)$.\n\n    A slip event occurs if the available friction coefficient $\\mu$ is less than the maximum required friction coefficient $\\mu_{\\mathrm{req}}^{\\max}$. The probability of this event, $P_{\\mathrm{slip}}$, is therefore:\n    $$\n    P_{\\mathrm{slip}} = P(\\mu < \\mu_{\\mathrm{req}}^{\\max})\n    $$\n    To compute this probability, we use the cumulative distribution function (CDF) of the normal distribution. First, we standardize the variable by defining a standard normal variable $Z \\sim \\mathcal{N}(0, 1)$ as:\n    $$\n    Z = \\frac{\\mu - \\bar{\\mu}}{\\sigma_{\\mu}}\n    $$\n    The inequality $\\mu < \\mu_{\\mathrm{req}}^{\\max}$ becomes:\n    $$\n    \\frac{\\mu - \\bar{\\mu}}{\\sigma_{\\mu}} < \\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\n    $$\n    Thus, the slip probability is given by the CDF of the standard normal distribution, typically denoted $\\Phi(z)$, evaluated at the standardized value of $\\mu_{\\mathrm{req}}^{\\max}$:\n    $$\n    P_{\\mathrm{slip}} = P\\left(Z < \\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) = \\Phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right)\n    $$\n    The function $\\Phi(z)$ is related to the error function $\\mathrm{erf}(x)$ by $\\Phi(z) = \\frac{1}{2}\\left(1 + \\mathrm{erf}\\left(\\frac{z}{\\sqrt{2}}\\right)\\right)$ and is readily available in standard scientific computing libraries.\n\n3.  **Sensitivity of Slip Probability ($\\mathrm{d}P_{\\mathrm{slip}}/\\mathrm{d}\\bar{\\mu}$)**\n\n    The sensitivity of the slip probability with respect to the mean friction coefficient, $\\bar{\\mu}$, quantifies how a small change in the average surface friction affects the likelihood of slip. It is the derivative:\n    $$\n    \\text{Sensitivity} = \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}}{\\mathrm{d}\\bar{\\mu}} \\left[ \\Phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) \\right]\n    $$\n    We apply the chain rule for differentiation. Let $u(\\bar{\\mu}) = (\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}) / \\sigma_{\\mu}$. The derivative is:\n    $$\n    \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}\\Phi(u)}{\\mathrm{d}u} \\cdot \\frac{\\mathrm{d}u}{\\mathrm{d}\\bar{\\mu}}\n    $$\n    The derivative of the standard normal CDF, $\\Phi(u)$, is its probability density function (PDF), $\\phi(u)$:\n    $$\n    \\frac{\\mathrm{d}\\Phi(u)}{\\mathrm{d}u} = \\phi(u) = \\frac{1}{\\sqrt{2\\pi}} e^{-u^2/2}\n    $$\n    The derivative of $u$ with respect to $\\bar{\\mu}$ is:\n    $$\n    \\frac{\\mathrm{d}u}{\\mathrm{d}\\bar{\\mu}} = \\frac{\\mathrm{d}}{\\mathrm{d}\\bar{\\mu}} \\left(\\frac{\\mu_{\\mathrm{req}}^{\\max}}{\\sigma_{\\mu}} - \\frac{1}{\\sigma_{\\mu}}\\bar{\\mu}\\right) = -\\frac{1}{\\sigma_{\\mu}}\n    $$\n    Combining these expressions yields the sensitivity:\n    $$\n    \\frac{\\mathrm{d}P_{\\mathrm{slip}}}{\\mathrm{d}\\bar{\\mu}} = \\phi\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right) \\cdot \\left(-\\frac{1}{\\sigma_{\\mu}}\\right) = -\\frac{1}{\\sigma_{\\mu}\\sqrt{2\\pi}} \\exp\\left(-\\frac{1}{2}\\left(\\frac{\\mu_{\\mathrm{req}}^{\\max} - \\bar{\\mu}}{\\sigma_{\\mu}}\\right)^2\\right)\n    $$\n    This value is always non-positive, which is physically intuitive: increasing the mean friction coefficient can only decrease or hold constant the probability of slip.\n\n4.  **Slip Classification at the Mean ($\\text{slip\\_at\\_mean}$)**\n\n    This is a deterministic check based on the mean value of the friction coefficient, $\\bar{\\mu}$, as a representative value. According to the quasi-static slip criterion, slip is predicted if the available friction is less than the required friction. Comparing the mean available friction to the maximum required friction gives:\n    -   **Slip** if $\\bar{\\mu} < \\mu_{\\mathrm{req}}^{\\max}$.\n    -   **Stick** if $\\bar{\\mu} \\ge \\mu_{\\mathrm{req}}^{\\max}$.\n\n    This results in a boolean classification for each case.\n\nThese four computations will be systematically performed for each of the five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the biomechanical slip analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 120, 300, 200, -150, -50]),\n         'mu_bar': 0.60, 'sigma_mu': 0.08},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.36, 'sigma_mu': 0.02},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.25, 'sigma_mu': 0.05},\n        {'Fn': np.array([300, 800, 1200, 1000, 700, 400]),\n         'Ft': np.array([0, 180, 420, 260, -210, -70]),\n         'mu_bar': 0.60, 'sigma_mu': 0.30},\n        {'Fn': np.array([400, 900, 1300, 1100, 800, 500]),\n         'Ft': np.array([0, 150, 500, 250, -200, -80]),\n         'mu_bar': 0.90, 'sigma_mu': 0.005}\n    ]\n\n    results = []\n    for case in test_cases:\n        Fn = case['Fn']\n        Ft = case['Ft']\n        mu_bar = case['mu_bar']\n        sigma_mu = case['sigma_mu']\n\n        # Task 1: Compute the maximum Required Coefficient of Friction (mu_req_max)\n        # Ensure F_n is not zero to avoid division by zero, which is guaranteed by the problem's data.\n        rcof = np.abs(Ft) / Fn\n        mu_req_max = np.max(rcof)\n\n        # Task 2: Compute the probability of slip\n        # P(slip) = P(mu < mu_req_max) where mu ~ N(mu_bar, sigma_mu^2)\n        # Standardize the variable for the CDF calculation\n        z_score = (mu_req_max - mu_bar) / sigma_mu\n        slip_probability = norm.cdf(z_score)\n\n        # Task 3: Compute the sensitivity of slip probability to mu_bar\n        # d(P_slip)/d(mu_bar) = -1/sigma_mu * PDF(z_score)\n        sensitivity = (-1 / sigma_mu) * norm.pdf(z_score)\n        \n        # Task 4: Classify slip vs. stick at the mean friction coefficient\n        # Slip predicted if mu_bar < mu_req_max\n        slip_at_mean = mu_bar < mu_req_max\n\n        results.append([mu_req_max, slip_probability, sensitivity, slip_at_mean])\n\n    # Final print statement in the exact required format.\n    # The formatting of the list of lists to string is handled by `str`.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}