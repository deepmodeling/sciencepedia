{
    "hands_on_practices": [
        {
            "introduction": "理解发放率编码的第一步是掌握单个运动单位如何响应神经脉冲序列。我们可以将运动单位简化为一个线性时不变（LTI）系统，其对单个动作电位的响应是一个“抽搐”力。通过模拟不同发放率下的脉冲序列并叠加产生的抽搐响应，我们可以直观地看到发放率如何调节力输出。这个练习让您亲手实现这一基本模型，从而深入理解力-频率关系，包括非融合性强直收缩和融合性强直收缩等现象。",
            "id": "4192798",
            "problem": "考虑一个运动单元，其模型为一个线性时不变 (LTI) 系统，它对单个动作电位的力响应即为抽搐冲激响应。设抽搐冲激响应在时间 $t \\ge 0$ 时定义为 $$h(t) = A \\left(e^{-t/\\tau_d} - e^{-t/\\tau_r}\\right)$$ 且在 $t  0$ 时 $h(t) = 0$。其中 $\\tau_r$ 是上升时间常数，$\\tau_d$ 是衰减时间常数。已知常数值为：$\\tau_r = 0.020$ s 和 $\\tau_d = 0.060$ s。抽搐振幅经过归一化，使得峰值抽搐力等于 $F_{\\text{peak}} = 0.2$ N。假设运动单元的力生成遵循抽搐的线性叠加原理，且脉冲序列被建模为在各脉冲时刻的一系列狄拉克δ函数之和。\n\n您必须通过生成恒定放电频率的脉冲序列，并利用抽搐冲激响应的叠加来计算合力，从而在 $T = 5$ s 的仿真时长内，以 $\\Delta t = 0.0005$ s 的均匀时间步长，模拟力的输出。对于频率为 $f$ 赫兹的放电，其脉冲序列是严格周期的，脉冲间期为 $1/f$。脉冲序列从时间 $t = 0$ 开始，脉冲位于区间 $[0, T)$ 内 $1/f$ 的倍数时刻。\n\n在数值实现中，您需要以 $\\Delta t$ 为步长将时间离散化，并将脉冲序列表示为一个长度为 $N = T/\\Delta t$ 的向量 $s[n]$，其中如果在时间索引 $n$ 处有脉冲，则 $s[n] = 1$，否则 $s[n] = 0$。离散抽搐冲激响应 $h[n]$ 是通过在 $t = n \\Delta t$（$n \\ge 0$）处对 $h(t)$ 进行采样并截断至长度 $N$ 得到的。在离散时间点，运动单元的力 $F[n]$ 是由脉冲引起的抽搐的离散叠加。计算仿真区间的最后 $1$ 秒内的平均力，即对应于时间区间 $[T-1, T)$ 的索引范围内的平均力。\n\n要求的输出是针对以下放电频率测试集的平均力：\n- 情况1：$f = 8$ Hz（正常情况，中等程度叠加）。\n- 情况2：$f = 20$ Hz（增强的叠加）。\n- 情况3：$f = 40$ Hz（接近融合的强叠加）。\n- 情况4：$f = 0$ Hz（边界情况，无脉冲）。\n- 情况5：$f = 100$ Hz（边缘情况，接近完全融合）。\n\n所有力必须以牛顿为单位，并报告为四舍五入到四位小数的浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），每个结果是按上述顺序列出的相应情况的平均力，单位为牛顿，并四舍五入到四位小数。",
            "solution": "用户提供了一个问题陈述，在尝试解决方案之前需要进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n以下是逐字从问题陈述中提取的已知条件：\n-   **系统模型**：一个运动单元，建模为线性时不变 (LTI) 系统。\n-   **抽搐冲激响应**：$h(t) = A \\left(e^{-t/\\tau_d} - e^{-t/\\tau_r}\\right)$，当 $t \\ge 0$ 时；当 $t  0$ 时，$h(t) = 0$。\n-   **上升时间常数**：$\\tau_r = 0.020$ s。\n-   **衰减时间常数**：$\\tau_d = 0.060$ s。\n-   **峰值抽搐力**：$F_{\\text{peak}} = 0.2$ N。抽搐振幅经过归一化以达到此峰值。\n-   **力生成原理**：抽搐的线性叠加。\n-   **脉冲序列模型**：在各脉冲时刻的一系列狄拉克δ函数之和。\n-   **仿真时长**：$T = 5$ s。\n-   **时间步长**：$\\Delta t = 0.0005$ s。\n-   **脉冲序列特性**：严格周期性，对于放电频率 $f$，脉冲间期为 $1/f$。\n-   **脉冲序列时间**：从 $t = 0$ 开始，脉冲位于区间 $[0, T)$ 内 $1/f$ 的倍数时刻。\n-   **数值离散化**：\n    -   时间以 $\\Delta t$ 为步长离散化。\n    -   脉冲序列是一个长度为 $N = T/\\Delta t$ 的向量 $s[n]$，其中有脉冲时 $s[n] = 1$，否则 $s[n] = 0$。\n    -   离散抽搐响应 $h[n]$ 是通过在 $t = n \\Delta t$ 处对 $h(t)$ 进行采样并截断至长度 $N$ 得到的。\n    -   离散力 $F[n]$ 是抽搐的离散叠加。\n-   **所需计算**：仿真最后 $1$ 秒内的平均力，对应时间区间 $[T-1, T)$。\n-   **测试用例**：放电频率 $f$ 为 $8$ Hz、$20$ Hz、$40$ Hz、$0$ Hz 和 $100$ Hz。\n-   **输出格式**：结果报告为四舍五入到四位小数的浮点数，形式为用方括号括起来的逗号分隔列表。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题基于生物力学中一个标准且被广泛接受的运动单元力产生简化模型。LTI系统方法、双指数抽搐函数 $h(t)$ 以及线性叠加原理是该领域的基石概念。所提供的时间常数对于肌肉的收缩特性在生理上是现实的。\n-   **适定性**：该问题定义清晰，提供了所有必要的参数和条件。其目标——计算几种指定放电频率下的平均力——是明确的。常数 $A$ 没有直接给出，但问题陈述指出抽搐被归一化到峰值力 $F_{\\text{peak}}$，这提供了一个可解的约束来确定 $A$。这使得问题是自洽的。对于每个测试用例，都存在一个唯一、稳定且有意义的解。\n-   **客观性**：该问题以精确、定量和客观的语言陈述，没有任何主观或模棱两可的术语。\n\n对照无效缺陷列表进行审查，确认了该问题的有效性：\n1.  **科学/事实不健全**：无。该模型是一个有效的科学抽象。\n2.  **无法形式化/不相关**：无。该问题是一个与运动单元力学直接相关的形式化计算任务。\n3.  **不完整/矛盾的设定**：无。设定是完整的且内部一致。\n4.  **不现实/不可行**：无。所有参数都在物理上现实的范围内。\n5.  **不适定/结构不良**：无。问题结构良好，能导向唯一解。\n6.  **伪深刻/过于简单**：无。该问题需要一个标准但并非无足轻重的数值模拟（卷积）。\n7.  **超出科学可验证性**：无。结果是可通过计算验证的。\n\n**步骤3：结论与行动**\n\n此问题是**有效的**。将提供一个解决方案。\n\n### 解决方案\n\n该问题要求通过将运动单元建模为线性时不变 (LTI) 系统来模拟其力的输出。力输出 $F(t)$ 是输入脉冲序列 $s(t)$ 与运动单元的抽搐冲激响应 $h(t)$ 的卷积。对于离散时间仿真，这转化为离散卷积。\n\n**1. 抽搐冲激响应的归一化**\n\n抽搐冲激响应由 $h(t) = A \\left(e^{-t/\\tau_d} - e^{-t/\\tau_r}\\right)$ 给出。振幅标量 $A$ 必须根据单个抽搐的峰值力为 $F_{\\text{peak}} = 0.2$ N 的条件来确定。\n\n首先，我们通过将其导数设为零来找到 $h(t)$ 达到峰值的时间 $t_{\\text{peak}}$：\n$$ \\frac{dh}{dt} = A \\left(-\\frac{1}{\\tau_d}e^{-t/\\tau_d} + \\frac{1}{\\tau_r}e^{-t/\\tau_r}\\right) = 0 $$\n$$ \\frac{1}{\\tau_r}e^{-t/\\tau_r} = \\frac{1}{\\tau_d}e^{-t/\\tau_d} $$\n对两边取自然对数，得到：\n$$ \\ln\\left(\\frac{\\tau_d}{\\tau_r}\\right) = t\\left(\\frac{1}{\\tau_r} - \\frac{1}{\\tau_d}\\right) = t\\left(\\frac{\\tau_d - \\tau_r}{\\tau_r\\tau_d}\\right) $$\n解出 $t = t_{\\text{peak}}$：\n$$ t_{\\text{peak}} = \\frac{\\tau_r\\tau_d}{\\tau_d - \\tau_r}\\ln\\left(\\frac{\\tau_d}{\\tau_r}\\right) $$\n代入给定值 $\\tau_r = 0.020$ s 和 $\\tau_d = 0.060$ s：\n$$ t_{\\text{peak}} = \\frac{(0.020)(0.060)}{0.060 - 0.020}\\ln\\left(\\frac{0.060}{0.020}\\right) = \\frac{0.0012}{0.04}\\ln(3) \\approx 0.03296 \\text{ s} $$\n现在，我们计算 $h(t_{\\text{peak}})$ 并使其等于 $F_{\\text{peak}}$ 来求得 $A$：\n$$ F_{\\text{peak}} = h(t_{\\text{peak}}) = A \\left(e^{-t_{\\text{peak}}/\\tau_d} - e^{-t_{\\text{peak}}/\\tau_r}\\right) $$\n$$ A = \\frac{F_{\\text{peak}}}{e^{-t_{\\text{peak}}/\\tau_d} - e^{-t_{\\text{peak}}/\\tau_r}} $$\n利用 $F_{\\text{peak}} = 0.2$ N，我们可以计算出 $A$ 的数值。\n\n**2. 离散化**\n\n仿真是以时间步长 $\\Delta t = 0.0005$ s 在时长 $T=5$ s 内进行的。离散时间点的总数为 $N = T/\\Delta t = 5/0.0005 = 10000$。离散时间向量为 $t_n = n\\Delta t$，其中 $n \\in \\{0, 1, ..., N-1\\}$。\n\n对连续抽搐响应 $h(t)$ 进行采样，以创建一个长度为 $N$ 的离散冲激响应向量 $h[n]$：\n$$ h[n] = h(t_n) = A \\left(e^{-n\\Delta t/\\tau_d} - e^{-n\\Delta t/\\tau_r}\\right) $$\n\n**3. 脉冲序列生成**\n\n对于给定的放电频率 $f$ (单位Hz)，脉冲间期为 $ISI = 1/f$。脉冲时间为 $t_k = k \\cdot ISI$，其中整数 $k \\ge 0$ 且满足 $t_k  T$。离散脉冲序列 $s[n]$ 是一个长度为 $N$ 的向量，其中如果在时间 $t_n$ 处有脉冲，则 $s[n]=1$，否则 $s[n]=0$。与脉冲时间 $t_k$ 对应的时间索引 $n_k$ 可通过 $n_k = \\text{round}(t_k / \\Delta t)$ 找到。对于 $f=0$ Hz，脉冲序列全为零。\n\n**4. 通过离散卷积计算力**\n\n总力输出 $F[n]$ 是对每个脉冲的抽搐响应的线性叠加。这通过脉冲序列 $s[n]$ 与抽搐响应 $h[n]$ 的离散卷积来计算：\n$$ F[n] = (s * h)[n] = \\sum_{k=0}^{n} s[k]h[n-k] $$\n此卷积的结果将是一个表示每个时间步长上力的向量。标准卷积算法的输出长度为 $2N-1$；必须将其截断至仿真长度 $N$。\n\n**5. 平均力的计算**\n\n最后一步是计算仿真最后 $1$ 秒内的平均力，这对应于时间区间 $[T-1, T) = [4, 5)$。该区间的起始索引是 $n_{\\text{start}} = (T-1)/\\Delta t = 4/0.0005 = 8000$。平均力 $\\bar{F}$ 是从索引 $n_{\\text{start}}$ 到 $N-1$ 的力值的均值：\n$$ \\bar{F} = \\frac{1}{N - n_{\\text{start}}} \\sum_{n=n_{\\text{start}}}^{N-1} F[n] $$\n对测试集中的每个放电频率重复此过程。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates motor unit force output for various firing rates based on an LTI model.\n    \"\"\"\n    # Define constants from the problem statement\n    T = 5.0  # s, simulation duration\n    dt = 0.0005  # s, time step\n    tau_r = 0.020  # s, twitch rise time constant\n    tau_d = 0.060  # s, twitch decay time constant\n    F_peak = 0.2  # N, peak twitch force\n\n    # Test suite of firing rates\n    test_firing_rates = [8.0, 20.0, 40.0, 0.0, 100.0]  # Hz\n\n    # --- Pre-computation Steps ---\n\n    # 1. Calculate the normalization constant A for the twitch response function\n    # The peak of the twitch h(t) occurs at t_peak where the derivative h'(t) = 0.\n    # The analytical solution for t_peak is:\n    t_peak = (tau_r * tau_d) / (tau_d - tau_r) * np.log(tau_d / tau_r)\n    \n    # Evaluate the unscaled twitch response at its peak\n    h_peak_unscaled = np.exp(-t_peak / tau_d) - np.exp(-t_peak / tau_r)\n    \n    # Determine the scaling factor A to match the specified F_peak\n    A = F_peak / h_peak_unscaled\n\n    # 2. Set up discrete time vector and compute discrete twitch response\n    N = int(T / dt)\n    time_vector = np.arange(N) * dt\n    \n    # The discrete twitch impulse response h[n] is obtained by sampling h(t)\n    h_discrete = A * (np.exp(-time_vector / tau_d) - np.exp(-time_vector / tau_r))\n\n    # --- Simulation Loop ---\n    \n    results = []\n    for f in test_firing_rates:\n        # Handle the boundary case of zero firing rate\n        if f == 0.0:\n            results.append(0.0)\n            continue\n\n        # 1. Generate the discrete spike train s[n]\n        s_discrete = np.zeros(N)\n        isi = 1.0 / f  # Inter-spike interval\n        \n        # Calculate spike times, ensuring they are within the simulation interval [0, T)\n        spike_times = np.arange(0, T, isi)\n        \n        # Convert spike times to discrete time indices, rounding to the nearest index\n        spike_indices = np.round(spike_times / dt).astype(int)\n        \n        # Ensure indices are within the valid range [0, N-1]\n        spike_indices = spike_indices[spike_indices  N]\n        \n        # Populate the spike train vector\n        s_discrete[spike_indices] = 1.0\n\n        # 2. Compute the force output F[n] via discrete convolution\n        # Force F[n] is the convolution of the spike train s[n] with the twitch response h[n].\n        # The output is truncated to the simulation length N.\n        force_output = np.convolve(s_discrete, h_discrete)[:N]\n\n        # 3. Calculate the average force over the final 1 second of the simulation\n        # The time interval is [T-1, T), starting at index (T-1)/dt\n        start_index_avg = int((T - 1.0) / dt)\n        \n        # Compute the mean of the force values in the specified interval\n        average_force = np.mean(force_output[start_index_avg:])\n        \n        results.append(average_force)\n\n    # Format the final output as a comma-separated list of strings,\n    # with each number rounded to four decimal places.\n    formatted_results = [\"{:.4f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在单个运动单位的基础上，我们现在将视野扩展到整个运动单位池。神经系统通过两种主要策略来调节肌肉力量：改变已激活单位的发放率（发放率编码），以及招募新的单位（招募）。这个练习整合了赫纳曼尺寸原理（Henneman's size principle）和一个线性发放率编码模型，来模拟在逐渐增加的突触驱动下整个肌肉的力输出。通过这个实践，您将能够模拟招募曲线和总力量输出，从而看到这两种策略是如何协同作用以平滑地控制肌肉力量的。",
            "id": "4192755",
            "problem": "您的任务是基于体积原则和公认的生理学关系，实现一个当突触驱动斜坡式增加时运动单位募集和频率编码的机制性模拟。目标是使用确定性的运动单位池和指定的参数值，生成募集曲线并计算作为突触驱动函数的累积肌肉力。\n\n请从以下基本且广为接受的基础出发：(i) Henneman 的体积原则，即具有较低基强度的运动单位首先被募集；(ii) 基强度的定义，即产生持续发放所需的最小突触驱动；(iii) 在生理范围内，发放频率随超出阈值的净驱动近似线性增加的近似；以及 (iv) 由于抽搐融合，重复抽搐产生的力总和会随着发放频率的增加而饱和的观察结果。\n\n使用以下与这些基础一致的模型定义和参数化：\n\n- 运动单位池和基强度分布：\n  - 存在 $N$ 个运动单位，由 $i \\in \\{1,\\dots,N\\}$ 索引。\n  - 突触驱动是一个标量输入 $I$，单位为任意单位 (a.u.)。\n  - 每个运动单位都有一个基强度（阈值）$I_{\\mathrm{th},i}$，它按等比数列确定性地排列，以反映生理上观察到的宽泛、近似对数间隔的分布：\n    $$I_{\\mathrm{th},i} \\;=\\; I_{\\min}\\,\\left(\\frac{I_{\\max}}{I_{\\min}}\\right)^{\\frac{i-1}{N-1}}.$$\n  - 募集规则（体积原则）：当且仅当 $I \\ge I_{\\mathrm{th},i}$ 时，运动单位 $i$ 被募集。\n\n- 发放频率模型（频率编码）：\n  - 对于未被募集的单位（$I  I_{\\mathrm{th},i}$），发放频率为 $f_i(I) = 0$。\n  - 对于已募集的单位（$I \\ge I_{\\mathrm{th},i}$），发放频率随超出阈值的剩余驱动线性增加，并受代表生理发放极限的上下界限制：\n    $$f_i(I) \\;=\\; \\min\\!\\left(f_{\\max},\\,\\max\\!\\left(f_{\\min},\\, f_{\\min} + k\\,[\\,I - I_{\\mathrm{th},i}\\,]\\right)\\right).$$\n  - 此处，$f_{\\min}$ 和 $f_{\\max}$ 的单位是赫兹 (Hz)，$k$ 的单位是赫兹/任意单位 (Hz/a.u.)。\n\n- 运动单位力模型：\n  - 随着基强度的增加，运动单位 $i$ 的最大强直收缩力在整个池中单调增加（反映了阈值更高的更大型运动单位），使用以下公式：\n    $$F_{0,i} \\;=\\; F_{\\min}\\,\\left(\\frac{I_{\\mathrm{th},i}}{I_{\\min}}\\right)^{\\gamma},$$\n    其中 $F_{\\min}$ 的单位是牛顿 (N)，$\\gamma > 0$ 调节分布范围。\n  - 归一化的力-频率关系由一个饱和的 Hill 型函数建模：\n    $$\\phi(f) \\;=\\; \\frac{f}{f + f_{1/2}},$$\n    其中 $f$ 的单位是赫兹 (Hz)，$f_{1/2}$ 是半融合频率，单位是赫兹 (Hz)。\n  - 在驱动 $I$ 下，单位 $i$ 的力为：\n    $$F_i(I) \\;=\\; F_{0,i}\\,\\phi\\!\\left(f_i(I)\\right).$$\n\n- 聚合输出：\n  - 募集分数为：\n    $$r(I) \\;=\\; \\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{1}\\!\\left[I \\ge I_{\\mathrm{th},i}\\right],$$\n    其中 $\\mathbf{1}[\\cdot]$ 是指示函数。\n  - 累积力为：\n    $$F_{\\mathrm{tot}}(I) \\;=\\; \\sum_{i=1}^{N} F_i(I),$$\n    单位为牛顿 (N)。\n\n实现一个程序，根据下面指定的参数值和突触驱动测试输入，计算 $r(I)$ 和 $F_{\\mathrm{tot}}(I)$。\n\n所有测试用例使用的参数：\n- $N = 10$\n- $I_{\\min} = 1.0$ a.u.\n- $I_{\\max} = 5.0$ a.u.\n- $F_{\\min} = 0.1$ N\n- $\\gamma = 2.0$\n- $f_{\\min} = 8.0$ Hz\n- $f_{\\max} = 35.0$ Hz\n- $k = 20.0$ Hz/a.u.\n- $f_{1/2} = 12.0$ Hz\n\n测试套件（突触驱动输入，单位为任意单位）：\n- 用例 A: $I = 0.8$\n- 用例 B: $I = 1.0$\n- 用例 C: $I = 3.0$\n- 用例 D: $I = 6.0$\n\n数值和输出要求：\n- 以牛顿 (N) 表示力。\n- 对于每个用例，返回两个值：$r(I)$ 和 $F_{\\mathrm{tot}}(I)$。\n- 将 $r(I)$ 和 $F_{\\mathrm{tot}}(I)$ 均四舍五入到 3 位小数。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来，顺序为 [用例 A 的 $r$，用例 A 的 $F_{\\mathrm{tot}}$，用例 B 的 $r$，用例 B 的 $F_{\\mathrm{tot}}$，用例 C 的 $r$，用例 C 的 $F_{\\mathrm{tot}}$，用例 D 的 $r$，用例 D 的 $F_{\\mathrm{tot}}$]。例如，格式必须完全如下：\n  $$[x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8]$$\n其中每个 $x_j$ 是一个四舍五入到 3 位小数的浮点数。",
            "solution": "问题陈述提出了一个用于模拟总肌肉力作为突触驱动函数的确定性机制模型，该模型涉及运动单位的募集和频率编码。该模型基于已建立的神经生理学原理，包括 Henneman 的体积原则，并通过一整套数学方程和参数值进行了完全指定。所有组件都定义清晰、有科学依据且内部一致。不存在歧义、矛盾或信息缺失。因此，该问题被认为是有效且适定的。解决方案通过实现指定的模型并将其应用于给定的测试用例来展开。\n\n解决方案需要为四种不同水平的突触驱动 $I$ 计算募集分数 $r(I)$ 和累积肌肉力 $F_{\\mathrm{tot}}(I)$。对于每个 $I$ 值，这通过一个三步过程实现：\n1. 确定运动单位池的属性。\n2. 对每个运动单位，计算其募集状态、发放频率和单个力的贡献。\n3. 聚合整个池的结果，以找到总募集分数和总力。\n\n**步骤 1：运动单位池参数化**\n\n首先，我们定义 $N=10$ 个运动单位的内在属性。这些属性对所有测试用例都是恒定的。\n\n每个运动单位 $i \\in \\{1, \\dots, 10\\}$ 的基强度（募集阈值）由一个等比数列给出：\n$$I_{\\mathrm{th},i} \\;=\\; I_{\\min}\\,\\left(\\frac{I_{\\max}}{I_{\\min}}\\right)^{\\frac{i-1}{N-1}}$$\n使用提供的参数 $N=10$，$I_{\\min}=1.0$ a.u. 和 $I_{\\max}=5.0$ a.u.，阈值为：\n$$I_{\\mathrm{th},i} \\;=\\; 1.0 \\times \\left(\\frac{5.0}{1.0}\\right)^{\\frac{i-1}{9}} \\;=\\; 5^{\\frac{i-1}{9}}$$\n这将创建一组阈值，范围从 $I_{\\mathrm{th},1} = 5^0 = 1.0$ a.u. 到 $I_{\\mathrm{th},10} = 5^1 = 5.0$ a.u.。\n\n每个运动单位的最大强直收缩力 $F_{0,i}$ 取决于其基强度：\n$$F_{0,i} \\;=\\; F_{\\min}\\,\\left(\\frac{I_{\\mathrm{th},i}}{I_{\\min}}\\right)^{\\gamma}$$\n当 $F_{\\min}=0.1$ N，$I_{\\min}=1.0$ a.u. 和 $\\gamma=2.0$ 时，这简化为：\n$$F_{0,i} \\;=\\; 0.1 \\times \\left(\\frac{I_{\\mathrm{th},i}}{1.0}\\right)^{2.0} \\;=\\; 0.1\\,(I_{\\mathrm{th},i})^2$$\n这表明具有更高募集阈值的运动单位能够产生更大的最大力。\n\n**步骤 2：针对给定的突触驱动 $I$ 进行单位计算**\n\n对于每个运动单位 $i$ 和给定的突触驱动 $I$，我们依次确定其状态。\n\n- **募集：** 当且仅当 $I \\ge I_{\\mathrm{th},i}$ 时，运动单位 $i$ 被激活。\n\n- **发放频率 $f_i(I)$：** 如果单位未被募集（$I  I_{\\mathrm{th},i}$），其发放频率为 $f_i(I) = 0$ Hz。如果单位被募集（$I \\ge I_{\\mathrm{th},i}$），其发放频率由线性频率编码模型确定，并受生理极限 $f_{\\min}$ 和 $f_{\\max}$ 的限制：\n$$f_i(I) \\;=\\; \\min\\!\\left(f_{\\max},\\,\\max\\!\\left(f_{\\min},\\, f_{\\min} + k\\,[\\,I - I_{\\mathrm{th},i}\\,]\\right)\\right)$$\n代入给定参数 $f_{\\min}=8.0$ Hz，$f_{\\max}=35.0$ Hz 和 $k=20.0$ Hz/a.u.，我们得到：\n$$f_i(I) \\;=\\; \\min\\!\\left(35.0,\\,\\max\\!\\left(8.0,\\, 8.0 + 20.0\\,[\\,I - I_{\\mathrm{th},i}\\,]\\right)\\right)$$\n\n- **单个力 $F_i(I)$：** 运动单位 $i$ 产生的力是其最大力 $F_{0,i}$ 受其当前发放频率 $f_i(I)$ 调控的结果。力-频率关系由 Hill 型函数 $\\phi(f)$ 给出：\n$$F_i(I) \\;=\\; F_{0,i}\\,\\phi\\!\\left(f_i(I)\\right) \\;=\\; F_{0,i}\\,\\frac{f_i(I)}{f_i(I) + f_{1/2}}$$\n当 $f_{1/2}=12.0$ Hz 时，方程变为：\n$$F_i(I) \\;=\\; F_{0,i}\\,\\frac{f_i(I)}{f_i(I) + 12.0}$$\n如果一个单位未被募集，$f_i(I) = 0$，因此 $F_i(I) = 0$ N。\n\n**步骤 3：聚合及应用于测试用例**\n\n对所有 $N=10$ 个运动单位执行步骤 2 的过程。然后计算给定 $I$ 的聚合输出。\n\n- **募集分数 $r(I)$：** 这是满足 $I \\ge I_{\\mathrm{th},i}$ 的运动单位所占的比例。\n$$r(I) \\;=\\; \\frac{1}{N}\\sum_{i=1}^{N}\\mathbf{1}\\!\\left[I \\ge I_{\\mathrm{th},i}\\right]$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数。\n\n- **累积力 $F_{\\mathrm{tot}}(I)$：** 这是所有单个运动单位产生的力的总和。\n$$F_{\\mathrm{tot}}(I) \\;=\\; \\sum_{i=1}^{N} F_i(I)$$\n\n对四个测试用例中的每一个（$I=0.8$，$I=1.0$，$I=3.0$ 和 $I=6.0$）重复这整个过程。然后按要求将最终数值结果四舍五入到 3 位小数。例如：\n\n- **用例 A ($I = 0.8$)：** 由于 $I  I_{\\mathrm{th},1} = 1.0$，没有单位被募集。因此，$r(0.8) = 0.0$ 且 $F_{\\mathrm{tot}}(0.8) = 0.0$ N。\n- **用例 B ($I = 1.0$)：** 只有运动单位 $i=1$ 被募集，因为 $I = I_{\\mathrm{th},1}$。因此，$r(1.0) = 1/10 = 0.1$。其发放频率为 $f_1(1.0) = \\max(8.0, 8.0 + 20(1.0-1.0)) = 8.0$ Hz。产生的力为 $F_1(1.0) = F_{0,1} \\frac{8.0}{8.0+12.0} = 0.1\\cdot (1.0)^2 \\cdot 0.4 = 0.04$ N。总力 $F_{\\mathrm{tot}}(1.0) = 0.04$ N。\n- **用例 C ($I = 3.0$)：** 所有满足 $I_{\\mathrm{th},i} \\le 3.0$ 的单位都被募集。总力是它们各自贡献的总和。\n- **用例 D ($I = 6.0$)：** 由于 $I > I_{\\mathrm{th},10}=5.0$，所有 10 个单位都被募集。$r(6.0) = 1.0$。所有单位都发放，许多单位以最大速率 $f_{\\max}$ 发放，总力是它们所有贡献的总和。\n\n该实现为所有用例自动执行这些计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates motor unit recruitment and rate coding to calculate recruitment\n    fraction and cumulative muscle force for a series of synaptic drive inputs.\n    \"\"\"\n    # Define the model parameters from the problem statement.\n    N = 10         # Number of motor units\n    I_min = 1.0    # Minimum rheobase (a.u.)\n    I_max = 5.0    # Maximum rheobase (a.u.)\n    F_min = 0.1    # Minimum maximal tetanic force (N)\n    gamma = 2.0    # Force-rheobase scaling exponent\n    f_min = 8.0    # Minimum firing rate (Hz)\n    f_max = 35.0   # Maximum firing rate (Hz)\n    k = 20.0       # Firing rate gain (Hz/a.u.)\n    f_half = 12.0  # Half-fusion frequency (Hz)\n\n    # Define the test cases for synaptic drive.\n    test_cases_I = [0.8, 1.0, 3.0, 6.0]\n\n    # --- Step 1: Motor Unit Pool Parameterization ---\n    # Create an array for motor unit indices from 1 to N.\n    i = np.arange(1, N + 1)\n    \n    # Calculate the rheobase (recruitment threshold) for each motor unit.\n    # I_th,i = I_min * (I_max / I_min)**((i - 1) / (N - 1))\n    I_th = I_min * (I_max / I_min)**((i - 1) / (N - 1))\n    \n    # Calculate the maximal tetanic force for each motor unit.\n    # F_0,i = F_min * (I_th,i / I_min)**gamma\n    F_0 = F_min * (I_th / I_min)**gamma\n\n    # List to store the results for all test cases.\n    results = []\n    \n    # --- Main Loop: Iterate through each test case ---\n    for I in test_cases_I:\n        # --- Step 2: Per-Unit Calculations ---\n        \n        # Determine which motor units are recruited.\n        # A boolean array where True means the unit is recruited.\n        is_recruited = I >= I_th\n\n        # Calculate firing rate f_i(I) for each motor unit.\n        f_i = np.zeros(N) # Initialize all rates to 0.\n        \n        # Only calculate firing rates for recruited units.\n        if np.any(is_recruited):\n            # Calculate surplus drive for recruited units.\n            surplus_drive = I - I_th[is_recruited]\n            \n            # Linear rate coding model for recruited units.\n            # f_i(I) = f_min + k * (I - I_th,i)\n            uncapped_rate = f_min + k * surplus_drive\n            \n            # Apply lower and upper bounds (clamping).\n            # f_i(I) = min(f_max, max(f_min, ...))\n            # The max(f_min, ...) is intrinsically handled because surplus_drive >= 0\n            # for recruited units, so uncapped_rate >= f_min. We only need to check f_max.\n            # However, for robustness, we implement the full logic.\n            recruited_rates = np.maximum(f_min, uncapped_rate)\n            recruited_rates = np.minimum(f_max, recruited_rates)\n            \n            # Update the firing rate array for the recruited units.\n            f_i[is_recruited] = recruited_rates\n\n        # Calculate force F_i(I) for each motor unit.\n        # phi(f) = f / (f + f_1/2)\n        # We add a small epsilon to the denominator to avoid division by zero\n        # in the theoretical case that f_half could be 0, though it's not here.\n        # For f_i=0, phi will correctly be 0.\n        phi = f_i / (f_i + f_half + 1e-9)\n        \n        # F_i(I) = F_0,i * phi(f_i(I))\n        F_i = F_0 * phi\n\n        # --- Step 3: Aggregation ---\n        \n        # Calculate recruitment fraction r(I).\n        r_I = np.sum(is_recruited) / N\n        \n        # Calculate cumulative force F_tot(I).\n        F_tot_I = np.sum(F_i)\n        \n        # Append the rounded results to the list.\n        results.append(round(r_I, 3))\n        results.append(round(F_tot_I, 3))\n\n    # Final print statement in the exact required format.\n    # Using f-strings with a format specifier ensures trailing zeros.\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实运动神经元的行为比简单的线性模型更为复杂。一个关键的非线性特性是持续性内向电流（Persistent Inward Currents, PICs），它能显著改变神经元的兴奋性。这个练习将引导您从生物物理学的角度，通过分析推导来探究PICs如何导致招募和去招募阈值的差异，即所谓的“滞后现象”。这项实践将挑战您运用基本的电路理论来揭示运动单位行为中一个重要非线性现象的细胞机制，这对于理解肌肉在持续收缩过程中的自我维持活动至关重要。",
            "id": "4192837",
            "problem": "在一个缓慢的三角形注入电流斜坡作用下，对一个处于准稳态的单个人类α-运动神经元进行建模。细胞膜由一个被动漏电导和一个条件性持续内向电流 (PIC) 并联表示。漏电流通路的电导为 $g_{L}$，反转电位为 $E_{L}$。PIC 通路的最大电导为 $g_{P}$，反转电位为 $E_{P}$，并且在斜坡的时间尺度上，它要么是完全失活的 ($s=0$)，要么是完全激活的 ($s=1$)。注入电流 $I_{\\mathrm{inj}}(t)$ 从 $0$ 线性增加到一个峰值，然后以一个恒定的斜率大小线性减少回 $0$。该斜率相对于膜时间常数而言是缓慢的，因此在每个 $I_{\\mathrm{inj}}$ 值下，膜电压 $V$ 可以很好地用其稳态值来近似。当 $V$ 达到锋电位阈值 $V_{\\mathrm{th}}$ 时，神经元开始重复放电；当 $V$ 降回 $V_{\\mathrm{th}}$ 以下时，神经元停止放电。\n\n在此实验标本中的观察表明，PIC 仅在神经元于上升支开始放电后才激活（即，在去极化水平 $V_{\\mathrm{act}}$，且 $V_{\\mathrm{act}} > V_{\\mathrm{th}}$），并且一旦激活，在整个下降支期间都保持激活状态，直到电压降至一个更超极化的失活水平 $V_{\\mathrm{deact}}$ 以下（$V_{\\mathrm{deact}}  V_{\\mathrm{th}}$），并且在这些条件下，上升支的募入发生在 PIC 失活时，而下降支的解除募入则发生在 PIC 激活时。\n\n仅从并联电导的欧姆定律所蕴含的稳态电流平衡出发，并假设在斜坡期间 $V$ 准稳态地跟踪其稳态值，推导募入电流阈值（上升支）和解除募入电流阈值（下降支）之间的差值 $\\Delta I$ 的解析表达式，用 $g_{L}$、$g_{P}$、$E_{L}$、$E_{P}$ 和 $V_{\\mathrm{th}}$ 来表示。然后，使用以下对于人类运动神经元生理上合理的参数值，对该表达式进行数值计算：$g_{L} = 0.5\\,\\mu\\text{S}$、$E_{L} = -65\\,\\text{mV}$、$V_{\\mathrm{th}} = -50\\,\\text{mV}$、$g_{P} = 0.2\\,\\mu\\text{S}$ 和 $E_{P} = -20\\,\\text{mV}$。\n\n将最终差值 $\\Delta I$ 表示为一个以纳安为单位的正值，并将您的答案四舍五入到三位有效数字。以纳安 (nA) 为单位说明最终结果。",
            "solution": "该问题要求推导一个简化的人类α-运动神经元模型中，募入和解除募入电流阈值之间的差值。该解法基于稳态电流平衡原理，这是欧姆定律和基尔霍夫电流定律的应用。\n\n该神经元膜模型由一个漏电流通路和一个持续性内向电流 (PIC) 通路组成。在任意给定的膜电压 $V$ 下，通过漏电流通路的电流为 $I_{L} = g_{L} (V - E_{L})$，通过 PIC 通路的电流为 $I_{P} = s \\cdot g_{P} (V - E_{P})$。变量 $s$ 代表 PIC 的激活状态，其中 $s=0$ 表示 PIC 失活，$s=1$ 表示 PIC 完全激活。\n\n在准稳态假设下，总注入电流 $I_{\\mathrm{inj}}$ 必须平衡流过细胞膜的这些离子电流的总和。\n控制方程为：\n$$I_{\\mathrm{inj}} = I_{L} + I_{P} = g_{L} (V - E_{L}) + s \\cdot g_{P} (V - E_{P})$$\n\n我们现在将这个通用方程应用于两个具体事件：募入和解除募入。\n\n首先，考虑电流斜坡上升支的募入阈值。当膜电压 $V$ 达到锋电位阈值 $V_{\\mathrm{th}}$ 时，发生募入。问题陈述，在募入点，PIC 是失活的。因此，我们设 $V = V_{\\mathrm{th}}$ 和 $s=0$。此时的注入电流即为募入电流阈值 $I_{\\mathrm{rec}}$。\n$$I_{\\mathrm{rec}} = g_{L} (V_{\\mathrm{th}} - E_{L}) + (0) \\cdot g_{P} (V_{\\mathrm{th}} - E_{P})$$\n$$I_{\\mathrm{rec}} = g_{L} (V_{\\mathrm{th}} - E_{L})$$\n\n接下来，考虑电流斜坡下降支的解除募入阈值。当膜电压 $V$ 降回锋电位阈值 $V_{\\mathrm{th}}$ 时，发生解除募入。问题陈述，在下降支，PIC 保持激活状态，直到电压降至 $V_{\\mathrm{deact}}$ 以下，其中 $V_{\\mathrm{deact}}  V_{\\mathrm{th}}$。因此，在解除募入点（$V = V_{\\mathrm{th}}$），PIC 仍然是激活的。因此，我们设 $V = V_{\\mathrm{th}}$ 和 $s=1$。此时的注入电流即为解除募入电流阈值 $I_{\\mathrm{derec}}$。\n$$I_{\\mathrm{derec}} = g_{L} (V_{\\mathrm{th}} - E_{L}) + (1) \\cdot g_{P} (V_{\\mathrm{th}} - E_{P})$$\n$$I_{\\mathrm{derec}} = g_{L} (V_{\\mathrm{th}} - E_{L}) + g_{P} (V_{\\mathrm{th}} - E_{P})$$\n\n问题要求计算募入和解除募入电流阈值之间的差值 $\\Delta I$。这个差值，通常称为电流滞后，计算为 $\\Delta I = I_{\\mathrm{rec}} - I_{\\mathrm{derec}}$。\n$$\\Delta I = \\left[ g_{L} (V_{\\mathrm{th}} - E_{L}) \\right] - \\left[ g_{L} (V_{\\mathrm{th}} - E_{L}) + g_{P} (V_{\\mathrm{th}} - E_{P}) \\right]$$\n对应于漏电流的项 $g_{L} (V_{\\mathrm{th}} - E_{L})$ 在两个表达式中是共同的，因此可以消掉。\n$$\\Delta I = -g_{P} (V_{\\mathrm{th}} - E_{P})$$\n按照要求，为了得到一个正值，可以通过颠倒电压差中的项来重写该式：\n$$\\Delta I = g_{P} (E_{P} - V_{\\mathrm{th}})$$\n这就是电流阈值差的解析表达式。它仅取决于 PIC 的参数和电压阈值，因为在募入和解除募入时，漏电流在 $V_{\\mathrm{th}}$ 处的贡献是相同的。\n\n现在，我们使用提供的参数值对该表达式进行数值计算：\n$g_{L} = 0.5\\,\\mu\\text{S}$\n$E_{L} = -65\\,\\text{mV}$\n$V_{\\mathrm{th}} = -50\\,\\text{mV}$\n$g_{P} = 0.2\\,\\mu\\text{S}$\n$E_{P} = -20\\,\\text{mV}$\n\n我们将相关值代入推导出的 $\\Delta I$ 表达式中。请注意，此计算不需要参数 $g_L$ 和 $E_L$。单位是兼容的，电导（单位为微西门子，$\\mu\\text{S}$）乘以电位（单位为毫伏，$\\text{mV}$）得到电流（单位为纳安，$\\text{nA}$），因为 $(10^{-6}\\,\\text{S}) \\times (10^{-3}\\,\\text{V}) = 10^{-9}\\,\\text{A} = 1\\,\\text{nA}$。\n$$\\Delta I = (0.2\\,\\mu\\text{S}) \\times ((-20\\,\\text{mV}) - (-50\\,\\text{mV}))$$\n$$\\Delta I = 0.2 \\times (-20 + 50)\\,\\text{nA}$$\n$$\\Delta I = 0.2 \\times (30)\\,\\text{nA}$$\n$$\\Delta I = 6\\,\\text{nA}$$\n问题要求答案四舍五入到三位有效数字。计算出的值是精确整数 $6$。为了以三位有效数字的精度表示，我们将其写为 $6.00$。因此，电流阈值的差值为 $6.00\\,\\text{nA}$。",
            "answer": "$$\n\\boxed{6.00}\n$$"
        }
    ]
}