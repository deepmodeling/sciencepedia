{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of analyzing planar joint motion is determining the Instantaneous Center of Rotation (ICR), the point about which a rigid body is purely rotating at a given instant. This exercise provides hands-on practice applying fundamental kinematic principles to calculate the ICR and its path (the centrode) from hypothetical motion capture data . Mastering this technique is crucial for interpreting experimental data and understanding the quality of joint motion, as the ICR's behavior is often linked to joint stability and health.",
            "id": "4196806",
            "problem": "A planar model of a tibiofemoral joint is observed during a flexion cycle. The femur is treated as a fixed reference frame, and the tibia moves as a rigid body in the plane. Two retroreflective markers rigidly affixed to the tibia are tracked, producing their trajectories in the femur-fixed frame as functions of the flexion angle $\\theta$ (in radians). The measured trajectories are\n$$\n\\mathbf{r}_{A}(\\theta) = \n\\begin{pmatrix}\nL \\cos\\theta + \\alpha\\,\\theta \\\\\nL \\sin\\theta\n\\end{pmatrix}\n\\quad\\text{and}\\quad\n\\mathbf{r}_{B}(\\theta) = \n\\begin{pmatrix}\n-\\,L \\sin\\theta + \\alpha\\,\\theta \\\\\nL \\cos\\theta\n\\end{pmatrix},\n$$\nwhere $L$ and $\\alpha$ are constants with $L = 40\\,\\mathrm{mm}$ and $\\alpha = 5\\,\\mathrm{mm}$. Assume $\\theta$ increases monotonically with time over the flexion cycle.\n\nUsing only fundamental principles of planar rigid-body kinematics and the Reuleaux method (instantaneous center of rotation defined by perpendicularity of position vectors to instantaneous velocities), determine the instantaneous center of rotation $\\mathbf{r}_{C}(\\theta)$ at each $\\theta$ by intersecting the lines through $\\mathbf{r}_{A}(\\theta)$ and $\\mathbf{r}_{B}(\\theta)$ that are perpendicular to their instantaneous velocity directions. Then, quantify the geometric path of the instantaneous center of rotation over the flexion range $\\theta \\in [0, \\theta_{f}]$ with $\\theta_{f} = 1.2\\,\\mathrm{rad}$ by computing its arc length.\n\nExpress the final arc length in $\\mathrm{mm}$ and round your answer to four significant figures. Angles are in radians.",
            "solution": "The problem statement is evaluated to be valid. It is scientifically grounded in the principles of planar rigid-body kinematics, is well-posed with sufficient and consistent information, and is expressed objectively. The a-priori check of the distance between markers $\\mathbf{r}_{A}$ and $\\mathbf{r}_{B}$ confirms the rigid-body assumption:\n$$\n\\|\\mathbf{r}_{B}(\\theta) - \\mathbf{r}_{A}(\\theta)\\|^2 = ((-L\\sin\\theta + \\alpha\\theta) - (L\\cos\\theta + \\alpha\\theta))^2 + (L\\cos\\theta - L\\sin\\theta)^2\n$$\n$$\n= (-L(\\cos\\theta + \\sin\\theta))^2 + (L(\\cos\\theta - \\sin\\theta))^2\n$$\n$$\n= L^2(\\cos^2\\theta + 2\\cos\\theta\\sin\\theta + \\sin^2\\theta) + L^2(\\cos^2\\theta - 2\\cos\\theta\\sin\\theta + \\sin^2\\theta)\n$$\n$$\n= L^2(1 + 2\\cos\\theta\\sin\\theta) + L^2(1 - 2\\cos\\theta\\sin\\theta) = 2L^2\n$$\nThe distance $\\|\\mathbf{r}_{B}(\\theta) - \\mathbf{r}_{A}(\\theta)\\| = L\\sqrt{2}$ is constant, as required for a rigid body. We may now proceed to the solution.\n\nThe problem asks for two main tasks: first, to determine the trajectory of the instantaneous center of rotation (ICR), $\\mathbf{r}_{C}(\\theta)$, and second, to compute the arc length of this trajectory over a specified range of motion.\n\nFirst, we find the instantaneous velocity vectors of the markers $\\mathbf{r}_{A}(\\theta)$ and $\\mathbf{r}_{B}(\\theta)$. Since the flexion angle $\\theta$ is a function of time $t$, we use the chain rule. Let $\\dot{\\theta} = \\frac{d\\theta}{dt}$ be the angular speed of flexion.\nThe velocity of marker A is:\n$$\n\\mathbf{v}_{A}(\\theta) = \\frac{d\\mathbf{r}_{A}}{dt} = \\frac{d\\mathbf{r}_{A}}{d\\theta}\\frac{d\\theta}{dt} = \\begin{pmatrix}\n-L\\sin\\theta + \\alpha \\\\\nL\\cos\\theta\n\\end{pmatrix} \\dot{\\theta}\n$$\nThe velocity of marker B is:\n$$\n\\mathbf{v}_{B}(\\theta) = \\frac{d\\mathbf{r}_{B}}{dt} = \\frac{d\\mathbf{r}_{B}}{d\\theta}\\frac{d\\theta}{dt} = \\begin{pmatrix}\n-L\\cos\\theta + \\alpha \\\\\n-L\\sin\\theta\n\\end{pmatrix} \\dot{\\theta}\n$$\nThe Reuleaux method states that the ICR lies on the line passing through a point and perpendicular to its velocity vector. A more direct approach is to use the fundamental kinematic equation for a rigid body undergoing planar motion: $\\mathbf{v}_{P} = \\vec{\\omega} \\times (\\mathbf{r}_{P} - \\mathbf{r}_{C})$, where $\\vec{\\omega} = \\omega\\mathbf{k}$ is the angular velocity of the body (tibia) and $\\mathbf{r}_{C}$ is the position of the ICR.\n\nWe can determine the angular velocity $\\omega$ from the relative velocity of the two markers:\n$$\n\\mathbf{v}_{B} - \\mathbf{v}_{A} = \\vec{\\omega} \\times (\\mathbf{r}_{B} - \\mathbf{r}_{A})\n$$\nThe relative position vector is:\n$$\n\\mathbf{r}_{B} - \\mathbf{r}_{A} = \\begin{pmatrix} -L(\\cos\\theta + \\sin\\theta) \\\\ L(\\cos\\theta - \\sin\\theta) \\end{pmatrix}\n$$\nThe relative velocity vector is:\n$$\n\\mathbf{v}_{B} - \\mathbf{v}_{A} = \\dot{\\theta} \\begin{pmatrix} (-L\\cos\\theta + \\alpha) - (-L\\sin\\theta + \\alpha) \\\\ -L\\sin\\theta - L\\cos\\theta \\end{pmatrix} = \\dot{\\theta} \\begin{pmatrix} L(\\sin\\theta - \\cos\\theta) \\\\ -L(\\sin\\theta + \\cos\\theta) \\end{pmatrix}\n$$\nThe cross product in 2D for $\\vec{a} = a_x\\mathbf{i} + a_y\\mathbf{j}$ and $\\vec{b} = b_x\\mathbf{i} + b_y\\mathbf{j}$ is $\\vec{a} \\times \\vec{b} = (a_x b_y - a_y b_x)\\mathbf{k}$. For $\\vec{\\omega} \\times (\\mathbf{r}_{B} - \\mathbf{r}_{A})$, we have:\n$$\n\\omega\\mathbf{k} \\times ((\\mathbf{r}_{B} - \\mathbf{r}_{A})_{x}\\mathbf{i} + (\\mathbf{r}_{B} - \\mathbf{r}_{A})_{y}\\mathbf{j}) = \\omega(-(\\mathbf{r}_{B} - \\mathbf{r}_{A})_{y}\\mathbf{i} + (\\mathbf{r}_{B} - \\mathbf{r}_{A})_{x}\\mathbf{j})\n$$\nComparing the x-component of the relative velocity equation:\n$$\n\\dot{\\theta}L(\\sin\\theta - \\cos\\theta) = \\omega (-(L(\\cos\\theta - \\sin\\theta))) = \\omega L(\\sin\\theta - \\cos\\theta)\n$$\nAssuming $\\sin\\theta \\neq \\cos\\theta$, we find $\\omega = \\dot{\\theta}$. Let's re-examine my thought process. The velocity of flexion $\\dot{\\theta}$ is usually defined positive for flexion, but the rotation of the tibia relative to the femur is often clockwise, hence negative. Let's re-check the definition of the cross product for rigid body rotation. Often, it is $\\mathbf{v}_P = \\mathbf{v}_C + \\vec{\\omega} \\times (\\mathbf{r}_P - \\mathbf{r}_C)$. Since the ICR is stationary, $\\mathbf{v}_C = 0$.\nThe components of $\\vec{\\omega} \\times \\vec{r}$ are $(\\omega_y r_z - \\omega_z r_y, \\omega_z r_x - \\omega_x r_z, \\omega_x r_y - \\omega_y r_x)$. For planar motion in the xy-plane, $\\vec{\\omega} = (0,0,\\omega)$ and $\\vec{r} = (r_x, r_y, 0)$. The cross product is $(-\\omega r_y, \\omega r_x, 0)$.\nSo, $(\\mathbf{v}_B - \\mathbf{v}_A)_x = -\\omega ((\\mathbf{r}_{B}-\\mathbf{r}_{A})_y)$\n$$\n\\dot{\\theta}L(\\sin\\theta - \\cos\\theta) = -\\omega (L(\\cos\\theta - \\sin\\theta)) = \\omega L(\\sin\\theta - \\cos\\theta)\n$$\nThis gives $\\omega = \\dot{\\theta}$. Let's check with the y-component:\n$(\\mathbf{v}_B - \\mathbf{v}_A)_y = \\omega ((\\mathbf{r}_{B}-\\mathbf{r}_{A})_x)$\n$$\n-\\dot{\\theta}L(\\sin\\theta + \\cos\\theta) = \\omega (-L(\\cos\\theta + \\sin\\theta))\n$$\nThis also yields $\\omega = \\dot{\\theta}$. My previous thought of $\\omega = -\\dot{\\theta}$ seems to be an error in a calculation step. The correct relation is $\\omega = \\dot{\\theta}$.\n\nNow, we can find $\\mathbf{r}_{C} = \\begin{pmatrix} x_C \\\\ y_C \\end{pmatrix}$ using marker A:\n$$\n\\mathbf{v}_{A} = \\vec{\\omega} \\times (\\mathbf{r}_{A} - \\mathbf{r}_{C})\n$$\nIn component form:\n$$\nv_{A,x} = -\\omega (y_A - y_C) = -\\dot{\\theta}(y_A - y_C)\n$$\n$$\nv_{A,y} = \\omega (x_A - x_C) = \\dot{\\theta}(x_A - x_C)\n$$\nSubstituting the components of $\\mathbf{v}_A$:\n$$\n(-L\\sin\\theta + \\alpha)\\dot{\\theta} = -\\dot{\\theta}(L\\sin\\theta - y_C)\n$$\n$$\n-L\\sin\\theta + \\alpha = -L\\sin\\theta + y_C \\implies y_C = \\alpha\n$$\nAnd for the x-component:\n$$\n(L\\cos\\theta)\\dot{\\theta} = \\dot{\\theta}((L\\cos\\theta + \\alpha\\theta) - x_C)\n$$\n$$\nL\\cos\\theta = L\\cos\\theta + \\alpha\\theta - x_C \\implies x_C = \\alpha\\theta\n$$\nThus, the instantaneous center of rotation is located at:\n$$\n\\mathbf{r}_{C}(\\theta) = \\begin{pmatrix} \\alpha\\theta \\\\ \\alpha \\end{pmatrix}\n$$\nThe path of the ICR is a horizontal line at height $y = \\alpha$.\n\nThe second task is to compute the arc length, $S$, of this path over the interval $\\theta \\in [0, \\theta_f]$, where $\\theta_f = 1.2\\,\\mathrm{rad}$. The formula for arc length of a parametric curve $\\mathbf{r}(\\theta)$ is:\n$$\nS = \\int_{0}^{\\theta_f} \\left\\| \\frac{d\\mathbf{r}_{C}}{d\\theta} \\right\\| d\\theta\n$$\nFirst, we find the derivative of $\\mathbf{r}_{C}(\\theta)$ with respect to $\\theta$:\n$$\n\\frac{d\\mathbf{r}_{C}}{d\\theta} = \\begin{pmatrix} \\alpha \\\\ 0 \\end{pmatrix}\n$$\nThe magnitude (norm) of this vector is:\n$$\n\\left\\| \\frac{d\\mathbf{r}_{C}}{d\\theta} \\right\\| = \\sqrt{\\alpha^2 + 0^2} = \\alpha\n$$\nNow we integrate this constant value over the given interval:\n$$\nS = \\int_{0}^{\\theta_f} \\alpha \\, d\\theta = \\alpha [\\theta]_{0}^{\\theta_f} = \\alpha (\\theta_f - 0) = \\alpha \\theta_f\n$$\nThis result is expected, as the path is a straight line segment from $\\mathbf{r}_{C}(0) = (0, \\alpha)$ to $\\mathbf{r}_{C}(\\theta_f) = (\\alpha\\theta_f, \\alpha)$, the length of which is simply the change in the x-coordinate.\n\nFinally, we substitute the given numerical values: $L = 40\\,\\mathrm{mm}$, $\\alpha = 5\\,\\mathrm{mm}$, and $\\theta_f = 1.2\\,\\mathrm{rad}$.\n$$\nS = (5\\,\\mathrm{mm}) \\times (1.2) = 6\\,\\mathrm{mm}\n$$\nThe problem requires the answer to be rounded to four significant figures.\n$$\nS = 6.000\\,\\mathrm{mm}\n$$",
            "answer": "$$\\boxed{6.000}$$"
        },
        {
            "introduction": "Beyond simply describing motion, a key goal in biomechanics is to understand the physical principles that govern it. This practice explores how the coupling between arthrokinematic roll and glide can be modeled using the principle of minimum potential energy, where the joint's equilibrium state represents a balance between competing elastic constraints like capsular tension and contact surface deformation . By deriving the roll-glide ratio from this energetic perspective, you will gain a deeper appreciation for how passive tissue properties dictate kinematic patterns and how pathology, such as capsular stiffening, can disrupt normal joint function.",
            "id": "4196753",
            "problem": "A synovial joint is idealized in the sagittal plane as a convex condyle of radius $R$ articulating with a congruent concavity. An imposed small osteokinematic rotation of the distal bone by angle $\\theta$ (assume $\\theta$ is measured in radians) about its own center is decomposed arthrokinematically into a surface roll of arc length $s_{r}$ and a tangential glide (translation along the contact tangent) of magnitude $g$. The joint capsule resists tangential glide with linear stiffness $K$ (modeled as a one-dimensional linear spring opposing $g$). Inter-surface tangential slip at the contact is penalized by an elastic conformity term with stiffness $E_{c}$, representing the resistance of the congruent articular surfaces to relative sliding. Assume small deformations and linear elasticity.\n\nUse the following modeling assumptions grounded in first principles:\n- The tangential slip at the contact equals the difference between the roll-induced arc length and the glide, so that the contact slip is $\\delta = s_{r} - g$.\n- The potential energy stored in the capsule due to glide is $\\frac{1}{2} K g^{2}$.\n- The penalty energy due to contact slip is $\\frac{1}{2} E_{c} \\delta^{2}$.\n- The roll arc length is $s_{r} = R \\theta$.\n\nBy invoking Hooke’s law and the principle of minimum potential energy, perform the following:\n- Derive the glide $g^{\\ast}$ that minimizes the total potential energy for a prescribed $\\theta$.\n- Define the roll–glide ratio as $\\rho = \\frac{s_{r}}{s_{g}}$, where $s_{g}$ is the magnitude of glide used by the system at equilibrium, and express $\\rho$ as a function of $K$ and $E_{c}$.\n- Suppose pathological stiffening scales the capsular stiffness from $K$ to $\\alpha K$, where $\\alpha > 1$ is dimensionless. Compute the change in roll–glide ratio $\\Delta \\rho = \\rho(\\alpha K) - \\rho(K)$ and express it in closed form in terms of $\\alpha$, $K$, and $E_{c}$.\n\nProvide your final answer as a single analytical expression for $\\Delta \\rho$. No numerical evaluation is required, and no units are needed in the final answer.",
            "solution": "The total potential energy of the system, $U_{total}$, is the sum of the energy stored in the capsule due to glide and the penalty energy from contact slip.\n$$\nU_{total} = U_{K} + U_{E} = \\frac{1}{2} K g^{2} + \\frac{1}{2} E_{c} \\delta^{2}\n$$\nThe contact slip $\\delta$ is given as the difference between the roll arc length $s_{r}$ and the glide $g$, so $\\delta = s_{r} - g$. Substituting this into the potential energy expression gives the total potential energy as a function of the glide $g$ for a given imposed roll $s_{r}$.\n$$\nU_{total}(g) = \\frac{1}{2} K g^{2} + \\frac{1}{2} E_{c} (s_{r} - g)^{2}\n$$\nAccording to the principle of minimum potential energy, the system will adopt the glide magnitude $g^{\\ast}$ that minimizes $U_{total}(g)$. To find this minimum, we compute the first derivative of $U_{total}$ with respect to $g$ and set it to zero.\n$$\n\\frac{dU_{total}}{dg} = \\frac{d}{dg} \\left( \\frac{1}{2} K g^{2} + \\frac{1}{2} E_{c} (s_{r} - g)^{2} \\right) = 0\n$$\nUsing the chain rule for differentiation, we get:\n$$\n\\frac{dU_{total}}{dg} = K g + E_{c} (s_{r} - g) \\cdot (-1) = K g - E_{c} s_{r} + E_{c} g\n$$\nSetting the derivative to zero to find the equilibrium glide $g^{\\ast}$:\n$$\nK g^{\\ast} + E_{c} g^{\\ast} - E_{c} s_{r} = 0\n$$\n$$\ng^{\\ast} (K + E_{c}) = E_{c} s_{r}\n$$\nSolving for $g^{\\ast}$:\n$$\ng^{\\ast} = \\frac{E_{c}}{K + E_{c}} s_{r}\n$$\nTo confirm this is a minimum, we check the second derivative:\n$$\n\\frac{d^{2}U_{total}}{dg^{2}} = \\frac{d}{dg} (K g + E_{c} g - E_{c} s_{r}) = K + E_{c}\n$$\nSince $K$ and $E_{c}$ are stiffness constants, they are inherently positive ($K > 0$, $E_{c} > 0$). Therefore, $K + E_{c} > 0$, confirming that $g^{\\ast}$ corresponds to a minimum of the potential energy.\n\nNext, we derive the roll–glide ratio $\\rho$. The problem defines $\\rho = \\frac{s_{r}}{s_{g}}$, where $s_{g}$ is the equilibrium glide, which we have found to be $g^{\\ast}$. Thus, $s_{g} = g^{\\ast}$.\n$$\n\\rho = \\frac{s_{r}}{g^{\\ast}} = \\frac{s_{r}}{\\frac{E_{c}}{K + E_{c}} s_{r}}\n$$\nAssuming a non-zero rotation ($s_{r} \\neq 0$), we can cancel $s_{r}$ from the numerator and denominator:\n$$\n\\rho(K) = \\frac{1}{\\frac{E_{c}}{K + E_{c}}} = \\frac{K + E_{c}}{E_{c}}\n$$\nThis can also be written as $\\rho(K) = \\frac{K}{E_{c}} + 1$. This is the roll-glide ratio as a function of the normal capsular stiffness $K$ and the conformity stiffness $E_{c}$.\n\nNow, we consider the pathological stiffening where the capsular stiffness becomes $\\alpha K$. To find the new roll-glide ratio, $\\rho(\\alpha K)$, we substitute $\\alpha K$ for $K$ in our expression for $\\rho$:\n$$\n\\rho(\\alpha K) = \\frac{(\\alpha K) + E_{c}}{E_{c}}\n$$\nThe change in the roll-glide ratio, $\\Delta \\rho$, is the difference between the new ratio and the original ratio:\n$$\n\\Delta \\rho = \\rho(\\alpha K) - \\rho(K)\n$$\nSubstituting the expressions we derived:\n$$\n\\Delta \\rho = \\left( \\frac{\\alpha K + E_{c}}{E_{c}} \\right) - \\left( \\frac{K + E_{c}}{E_{c}} \\right)\n$$\nSince the terms have a common denominator, we can combine them:\n$$\n\\Delta \\rho = \\frac{(\\alpha K + E_{c}) - (K + E_{c})}{E_{c}}\n$$\n$$\n\\Delta \\rho = \\frac{\\alpha K + E_{c} - K - E_{c}}{E_{c}}\n$$\nThe $E_{c}$ terms in the numerator cancel out:\n$$\n\\Delta \\rho = \\frac{\\alpha K - K}{E_{c}}\n$$\nFinally, we factor out $K$ to obtain the closed-form expression for $\\Delta \\rho$:\n$$\n\\Delta \\rho = \\frac{K(\\alpha - 1)}{E_{c}}\n$$\nThis is the final analytical expression for the change in the roll–glide ratio in terms of $\\alpha$, $K$, and $E_{c}$.",
            "answer": "$$\n\\boxed{\\frac{K(\\alpha - 1)}{E_{c}}}\n$$"
        },
        {
            "introduction": "This final practice synthesizes kinematic principles and physical constraints into a comprehensive computational model, a task representative of modern biomechanics research. You will formulate and implement an inverse kinematics solver for a multi-segment limb, where the goal is to achieve a target pose while adhering to realistic arthrokinematic coupling rules at each joint . Solving this advanced constrained optimization problem demonstrates how the detailed principles of osteokinematics and arthrokinematics are not merely theoretical but serve as essential, functional constraints in predictive simulations of biological movement.",
            "id": "4196783",
            "problem": "Consider a planar two-segment limb whose joints are modeled as synovial joints exhibiting coupled osteokinematic rotation and arthrokinematic accessory translation. The limb is anchored at a fixed base at the origin of a two-dimensional Cartesian coordinate system. The proximal segment has length $L_1$ and the distal segment has length $L_2$. Each joint $i \\in \\{1,2\\}$ has an osteokinematic rotation angle $\\theta_i$ (in radians) and an arthrokinematic accessory translation $s_i$ (in meters) along the local tangential direction of the joint contact. The accessory translation is constrained by a linear roll-glide coupling derived from contact geometry: $s_i = \\sigma_i \\kappa_i R_i \\theta_i$, where $R_i$ is the effective joint surface radius (in meters), $\\kappa_i$ is a dimensionless roll-glide ratio, and $\\sigma_i \\in \\{-1,+1\\}$ encodes the convex-on-concave ($-1$) or concave-on-convex ($+1$) contact sign convention.\n\nThe limb kinematics are defined by rigid body transformations. Let $R(\\theta)$ denote the planar rotation matrix\n$$\nR(\\theta) = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\ \\cos\\theta\n\\end{bmatrix}.\n$$\nUnder the assumption that accessory translation at each joint occurs along the local $x$-axis after rotation (tangential to the contact), the end-effector (hand) position $\\mathbf{p}(\\theta_1,\\theta_2,s_1,s_2) \\in \\mathbb{R}^2$ is given by\n$$\n\\mathbf{p}(\\theta_1,\\theta_2,s_1,s_2) = R(\\theta_1)\\left(\\begin{bmatrix}s_1 + L_1 \\\\ 0\\end{bmatrix} + R(\\theta_2)\\begin{bmatrix}s_2 + L_2 \\\\ 0\\end{bmatrix}\\right).\n$$\nThe end-effector orientation (in radians) is\n$$\n\\phi(\\theta_1,\\theta_2) = \\theta_1 + \\theta_2.\n$$\n\nGiven a target pose specified by a target position $\\mathbf{p}_{\\mathrm{t}} = \\begin{bmatrix}p_x \\\\ p_y\\end{bmatrix}$ (in meters) and target orientation $\\psi_{\\mathrm{t}}$ (in radians), formulate an inverse kinematics problem that minimizes the pose error while enforcing arthrokinematic feasibility via equality constraints. The error to be minimized is\n$$\nE(\\theta_1,\\theta_2,s_1,s_2) = w_{\\mathrm{pos}}\\left\\|\\mathbf{p}(\\theta_1,\\theta_2,s_1,s_2) - \\mathbf{p}_{\\mathrm{t}}\\right\\|_2^2 + w_{\\mathrm{ori}}\\left(\\ell_{\\mathrm{eq}}(\\phi(\\theta_1,\\theta_2) - \\psi_{\\mathrm{t}})\\right)^2,\n$$\nwhere $w_{\\mathrm{pos}}$ and $w_{\\mathrm{ori}}$ are nonnegative weights, and $\\ell_{\\mathrm{eq}}$ (in meters per radian) is a length scale used to map orientation error in radians to an equivalent arc-length scale so that the two error terms are commensurate in units.\n\nSubject to:\n- Equality constraints (arthrokinematic feasibility):\n$$\ng_1(\\theta_1,s_1) = s_1 - \\sigma_1 \\kappa_1 R_1 \\theta_1 = 0, \\quad g_2(\\theta_2,s_2) = s_2 - \\sigma_2 \\kappa_2 R_2 \\theta_2 = 0.\n$$\n- Joint angle bounds representing physiological range of motion:\n$$\n\\theta_1^{\\min} \\le \\theta_1 \\le \\theta_1^{\\max}, \\quad \\theta_2^{\\min} \\le \\theta_2 \\le \\theta_2^{\\max}.\n$$\n- Accessory translation bounds representing capsuloligamentous feasibility:\n$$\n|s_1| \\le s_1^{\\max}, \\quad |s_2| \\le s_2^{\\max}.\n$$\n\nUse the following parameter values for the limb and constraints:\n- Segment lengths: $L_1 = 0.30\\,\\mathrm{m}$, $L_2 = 0.25\\,\\mathrm{m}$.\n- Joint contact geometry and roll-glide parameters: $R_1 = 0.020\\,\\mathrm{m}$, $R_2 = 0.015\\,\\mathrm{m}$; $\\kappa_1 = 0.60$, $\\kappa_2 = 0.40$; $\\sigma_1 = -1$, $\\sigma_2 = -1$.\n- Range of motion bounds (radians): $\\theta_1^{\\min} = -\\frac{\\pi}{2}$, $\\theta_1^{\\max} = \\frac{\\pi}{2}$; $\\theta_2^{\\min} = 0$, $\\theta_2^{\\max} = \\frac{3\\pi}{4}$.\n- Accessory translation bounds: $s_1^{\\max} = 0.030\\,\\mathrm{m}$, $s_2^{\\max} = 0.030\\,\\mathrm{m}$.\n- Error weights and equivalent length scale: $w_{\\mathrm{pos}} = 1.0$, $w_{\\mathrm{ori}} = 1.0$, $\\ell_{\\mathrm{eq}} = 0.10\\,\\mathrm{m}/\\mathrm{rad}$.\n\nImplement a program that, for each test case below, solves the optimization problem, returns whether the solution is arthrokinematically feasible (i.e., the equality constraints are satisfied within a tolerance of $10^{-6}$ and all bounds are respected), and computes the final end-effector position error $\\left\\|\\mathbf{p} - \\mathbf{p}_{\\mathrm{t}}\\right\\|_2$ in meters.\n\nAngle units must be in radians throughout. All position results must be expressed in meters. The final error must be returned in meters as a floating-point number.\n\nTest suite (targets):\n1. Happy path: $\\mathbf{p}_{\\mathrm{t}} = \\begin{bmatrix}0.40 \\\\ 0.10\\end{bmatrix}\\,\\mathrm{m}$, $\\psi_{\\mathrm{t}} = 1.00\\,\\mathrm{rad}$.\n2. Boundary reach: $\\mathbf{p}_{\\mathrm{t}} = \\begin{bmatrix}0.55 \\\\ 0.00\\end{bmatrix}\\,\\mathrm{m}$, $\\psi_{\\mathrm{t}} = 0.00\\,\\mathrm{rad}$.\n3. Unreachable target: $\\mathbf{p}_{\\mathrm{t}} = \\begin{bmatrix}0.70 \\\\ 0.00\\end{bmatrix}\\,\\mathrm{m}$, $\\psi_{\\mathrm{t}} = 0.00\\,\\mathrm{rad}$.\n4. Orientation-challenging: $\\mathbf{p}_{\\mathrm{t}} = \\begin{bmatrix}0.20 \\\\ 0.35\\end{bmatrix}\\,\\mathrm{m}$, $\\psi_{\\mathrm{t}} = 2.00\\,\\mathrm{rad}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where results for each test case are output in sequence as a boolean followed by a float for the position error in meters. For the four test cases, the final output must be of the form\n$$\n[\\text{b}_1,\\text{e}_1,\\text{b}_2,\\text{e}_2,\\text{b}_3,\\text{e}_3,\\text{b}_4,\\text{e}_4],\n$$\nwhere each $\\text{b}_i$ is either $\\text{True}$ or $\\text{False}$, and each $\\text{e}_i$ is a floating-point number in meters.",
            "solution": "The solution proceeds by first simplifying the problem, then applying a numerical optimization method.\n\n### 1. Problem Simplification and Reformulation\n\nThe initial problem involves four optimization variables, $(\\theta_1, \\theta_2, s_1, s_2)$, and two equality constraints which define the arthrokinematic coupling:\n$$g_1(\\theta_1,s_1) = s_1 - \\sigma_1 \\kappa_1 R_1 \\theta_1 = 0$$\n$$g_2(\\theta_2,s_2) = s_2 - \\sigma_2 \\kappa_2 R_2 \\theta_2 = 0$$\n\nThese constraints can be used to eliminate the accessory translation variables $s_1$ and $s_2$. Let us define the coupling coefficients $C_i = \\sigma_i \\kappa_i R_i$ for $i \\in \\{1, 2\\}$.\nUsing the given parameter values:\n- $L_1 = 0.30\\,\\mathrm{m}$, $L_2 = 0.25\\,\\mathrm{m}$\n- $R_1 = 0.020\\,\\mathrm{m}$, $R_2 = 0.015\\,\\mathrm{m}$\n- $\\kappa_1 = 0.60$, $\\kappa_2 = 0.40$\n- $\\sigma_1 = -1$, $\\sigma_2 = -1$\n\nThe coupling coefficients are calculated as:\n$$C_1 = \\sigma_1 \\kappa_1 R_1 = (-1)(0.60)(0.020\\,\\mathrm{m}) = -0.012\\,\\mathrm{m}/\\mathrm{rad}$$\n$$C_2 = \\sigma_2 \\kappa_2 R_2 = (-1)(0.40)(0.015\\,\\mathrm{m}) = -0.006\\,\\mathrm{m}/\\mathrm{rad}$$\n\nThus, the accessory translations are directly proportional to their corresponding joint angles:\n$$s_1 = C_1 \\theta_1$$\n$$s_2 = C_2 \\theta_2$$\n\nSubstituting these into the forward kinematics equation for the end-effector position $\\mathbf{p}$:\n$$ \\mathbf{p}(\\theta_1, \\theta_2) = R(\\theta_1)\\left(\\begin{bmatrix}C_1\\theta_1 + L_1 \\\\ 0\\end{bmatrix} + R(\\theta_2)\\begin{bmatrix}C_2\\theta_2 + L_2 \\\\ 0\\end{bmatrix}\\right) $$\nExpanding this expression, where $R(\\theta) = \\begin{bmatrix} \\cos\\theta & -\\sin\\theta \\\\ \\sin\\theta & \\cos\\theta \\end{bmatrix}$:\nFirst, the term in parentheses:\n$$ \\begin{bmatrix}C_1\\theta_1 + L_1 \\\\ 0\\end{bmatrix} + \\begin{bmatrix} \\cos\\theta_2 & -\\sin\\theta_2 \\\\ \\sin\\theta_2 & \\cos\\theta_2 \\end{bmatrix} \\begin{bmatrix}C_2\\theta_2 + L_2 \\\\ 0\\end{bmatrix} = \\begin{bmatrix}C_1\\theta_1 + L_1 \\\\ 0\\end{bmatrix} + \\begin{bmatrix}(C_2\\theta_2 + L_2)\\cos\\theta_2 \\\\ (C_2\\theta_2 + L_2)\\sin\\theta_2\\end{bmatrix} $$\n$$ = \\begin{bmatrix}C_1\\theta_1 + L_1 + (C_2\\theta_2 + L_2)\\cos\\theta_2 \\\\ (C_2\\theta_2 + L_2)\\sin\\theta_2\\end{bmatrix} $$\nNow, premultiplying by $R(\\theta_1)$:\n$$ \\mathbf{p}(\\theta_1, \\theta_2) = \\begin{bmatrix} \\cos\\theta_1 & -\\sin\\theta_1 \\\\ \\sin\\theta_1 & \\cos\\theta_1 \\end{bmatrix} \\begin{bmatrix}C_1\\theta_1 + L_1 + (C_2\\theta_2 + L_2)\\cos\\theta_2 \\\\ (C_2\\theta_2 + L_2)\\sin\\theta_2\\end{bmatrix} $$\nThe components of the position vector $\\mathbf{p} = \\begin{bmatrix}p_x \\\\ p_y\\end{bmatrix}$ are:\n$$ p_x(\\theta_1,\\theta_2) = \\cos\\theta_1(C_1\\theta_1 + L_1 + (C_2\\theta_2 + L_2)\\cos\\theta_2) - \\sin\\theta_1(C_2\\theta_2 + L_2)\\sin\\theta_2 $$\n$$ p_y(\\theta_1,\\theta_2) = \\sin\\theta_1(C_1\\theta_1 + L_1 + (C_2\\theta_2 + L_2)\\cos\\theta_2) + \\cos\\theta_1(C_2\\theta_2 + L_2)\\sin\\theta_2 $$\nUsing the angle sum identities, this simplifies to:\n$$ p_x(\\theta_1,\\theta_2) = (C_1\\theta_1 + L_1)\\cos\\theta_1 + (C_2\\theta_2 + L_2)\\cos(\\theta_1+\\theta_2) $$\n$$ p_y(\\theta_1,\\theta_2) = (C_1\\theta_1 + L_1)\\sin\\theta_1 + (C_2\\theta_2 + L_2)\\sin(\\theta_1+\\theta_2) $$\n\nThe problem is now reduced to an optimization over two variables, $\\theta_1$ and $\\theta_2$. The objective function $E(\\theta_1, \\theta_2)$ becomes:\n$$ E(\\theta_1, \\theta_2) = w_{\\mathrm{pos}}\\|\\mathbf{p}(\\theta_1,\\theta_2) - \\mathbf{p}_{\\mathrm{t}}\\|_2^2 + w_{\\mathrm{ori}}\\left(\\ell_{\\mathrm{eq}}(\\theta_1 + \\theta_2 - \\psi_{\\mathrm{t}})\\right)^2 $$\nwith $w_{\\mathrm{pos}} = 1.0$, $w_{\\mathrm{ori}} = 1.0$, and $\\ell_{\\mathrm{eq}} = 0.10\\,\\mathrm{m}/\\mathrm{rad}$.\n\n### 2. Constraint Analysis\n\nThe original constraints include bounds on both angles and translations. With the substitution, the translation bounds become bounds on the angles:\n- $|s_1| \\le s_1^{\\max} \\implies |C_1 \\theta_1| \\le s_1^{\\max} \\implies |\\theta_1| \\le \\frac{s_1^{\\max}}{|C_1|} = \\frac{0.030}{|-0.012|} = 2.5\\,\\mathrm{rad}$.\n- $|s_2| \\le s_2^{\\max} \\implies |C_2 \\theta_2| \\le s_2^{\\max} \\implies |\\theta_2| \\le \\frac{s_2^{\\max}}{|C_2|} = \\frac{0.030}{|-0.006|} = 5.0\\,\\mathrm{rad}$.\n\nWe must combine these with the physiological range of motion bounds:\n- For $\\theta_1$: The problem states $\\theta_1 \\in [-\\frac{\\pi}{2}, \\frac{\\pi}{2}] \\approx [-1.571, 1.571]\\,\\mathrm{rad}$. The translation-derived bound is $\\theta_1 \\in [-2.5, 2.5]\\,\\mathrm{rad}$. The intersection, and thus the effective bound, is $\\theta_1 \\in [-\\frac{\\pi}{2}, \\frac{\\pi}{2}]$.\n- For $\\theta_2$: The problem states $\\theta_2 \\in [0, \\frac{3\\pi}{4}] \\approx [0, 2.356]\\,\\mathrm{rad}$. The translation-derived bound is $\\theta_2 \\in [-5.0, 5.0]\\,\\mathrm{rad}$. The intersection gives the effective bound $\\theta_2 \\in [0, \\frac{3\\pi}{4}]$.\n\nTherefore, if the solution respects the original angle bounds, the translation bounds are automatically satisfied. The simplified optimization problem is to minimize $E(\\theta_1, \\theta_2)$ subject to the box constraints:\n$$ -\\frac{\\pi}{2} \\le \\theta_1 \\le \\frac{\\pi}{2} $$\n$$ 0 \\le \\theta_2 \\le \\frac{3\\pi}{4} $$\n\n### 3. Numerical Solution Strategy\n\nThis is a non-convex, constrained nonlinear optimization problem. We will use the `scipy.optimize.minimize` function with the Sequential Least Squares Programming (`SLSQP`) method, which handles box constraints efficiently. To enhance the likelihood of finding a good solution rather than a poor local minimum, a multi-start strategy is employed: the optimization is performed multiple times from different, randomly chosen initial points $(\\theta_1^{(0)}, \\theta_2^{(0)})$ within the valid domains. The solution yielding the lowest objective function value across all starts is selected as the final result.\n\n### 4. Feasibility and Error Calculation\n\nFor each test case, after finding the optimal angles $(\\theta_1^*, \\theta_2^*)$:\n1.  **Feasibility Check**: The solution is deemed \"arthrokinematically feasible\" if all original constraints are met.\n    - The equality constraints $s_i - C_i \\theta_i = 0$ are satisfied by construction (within floating-point precision). We verify this to a tolerance of $10^{-6}$.\n    - The angle bounds on $\\theta_1^*$ and $\\theta_2^*$ are checked to ensure they were respected by the optimizer.\n    - The accessory translation bounds $|s_i^*| \\le s_i^{\\max}$ (where $s_i^*=C_i\\theta_i^*$) are also checked. As analyzed above, this is implied by the angle bounds but verified for robustness.\n2.  **Position Error**: The final end-effector position error is calculated as $\\|\\mathbf{p}(\\theta_1^*,\\theta_2^*) - \\mathbf{p}_{\\mathrm{t}}\\|_2$.\n\nThis procedure is applied to each of the four target poses provided in the test suite.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the inverse kinematics problem for a two-segment limb with\n    coupled arthrokinematics for a series of target poses.\n    \"\"\"\n\n    # --- Problem Parameters ---\n    L1 = 0.30  # m\n    L2 = 0.25  # m\n    R1 = 0.020 # m\n    R2 = 0.015 # m\n    kappa1 = 0.60\n    kappa2 = 0.40\n    sigma1 = -1\n    sigma2 = -1\n    w_pos = 1.0\n    w_ori = 1.0\n    l_eq = 0.10  # m/rad\n\n    # Angle bounds (rad)\n    theta1_min, theta1_max = -np.pi / 2, np.pi / 2\n    theta2_min, theta2_max = 0, 3 * np.pi / 4\n    bounds = [(theta1_min, theta1_max), (theta2_min, theta2_max)]\n\n    # Accessory translation bounds (m)\n    s1_max = 0.030\n    s2_max = 0.030\n    \n    # Feasibility tolerance\n    tolerance = 1e-6\n\n    # Derived coupling constants (m/rad)\n    C1 = sigma1 * kappa1 * R1\n    C2 = sigma2 * kappa2 * R2\n\n    # --- Test Cases ---\n    test_cases = [\n        # (target_pos, target_ori)\n        (np.array([0.40, 0.10]), 1.00),  # Happy path\n        (np.array([0.55, 0.00]), 0.00),  # Boundary reach\n        (np.array([0.70, 0.00]), 0.00),  # Unreachable target\n        (np.array([0.20, 0.35]), 2.00),  # Orientation-challenging\n    ]\n\n    # --- Helper Functions ---\n    def forward_kinematics(theta):\n        \"\"\"Computes end-effector position and orientation.\"\"\"\n        theta1, theta2 = theta\n        \n        # Position\n        pos_x = (C1 * theta1 + L1) * np.cos(theta1) + (C2 * theta2 + L2) * np.cos(theta1 + theta2)\n        pos_y = (C1 * theta1 + L1) * np.sin(theta1) + (C2 * theta2 + L2) * np.sin(theta1 + theta2)\n        p = np.array([pos_x, pos_y])\n        \n        # Orientation\n        phi = theta1 + theta2\n        \n        return p, phi\n\n    def objective_function(theta, p_target, phi_target):\n        \"\"\"Computes the total weighted error.\"\"\"\n        p_current, phi_current = forward_kinematics(theta)\n        \n        pos_error_sq = np.sum((p_current - p_target)**2)\n        ori_error_sq = (l_eq * (phi_current - phi_target))**2\n        \n        total_error = w_pos * pos_error_sq + w_ori * ori_error_sq\n        return total_error\n\n    # --- Main Loop ---\n    final_results = []\n    num_starts = 20  # Number of random starts for optimization\n    np.random.seed(0) # For reproducibility\n\n    for p_t, phi_t in test_cases:\n        best_result = {'fun': np.inf}\n\n        for i in range(num_starts):\n            # Generate a random initial guess within the bounds\n            theta1_0 = np.random.uniform(theta1_min, theta1_max)\n            theta2_0 = np.random.uniform(theta2_min, theta2_max)\n            initial_guess = [theta1_0, theta2_0]\n\n            res = minimize(\n                objective_function,\n                initial_guess,\n                args=(p_t, phi_t),\n                method='SLSQP',\n                bounds=bounds,\n                tol=1e-9\n            )\n\n            if res.success and res.fun < best_result['fun']:\n                best_result = res\n        \n        # If no start was successful, use the one with the lowest error\n        if best_result['fun'] == np.inf:\n             # Fallback if no start succeeds (unlikely)\n             res = minimize(objective_function, [0,0], args=(p_t, phi_t), method='SLSQP', bounds=bounds)\n             theta_opt = res.x\n        else:\n            theta_opt = best_result.x\n        \n        theta1_opt, theta2_opt = theta_opt\n\n        # --- Feasibility Check ---\n        s1_opt = C1 * theta1_opt\n        s2_opt = C2 * theta2_opt\n\n        # Check equality constraints\n        g1_ok = abs(s1_opt - C1 * theta1_opt) < tolerance\n        g2_ok = abs(s2_opt - C2 * theta2_opt) < tolerance\n        \n        # Check all bounds with a small tolerance for numerical stability\n        theta1_ok = (theta1_min - tolerance) <= theta1_opt <= (theta1_max + tolerance)\n        theta2_ok = (theta2_min - tolerance) <= theta2_opt <= (theta2_max + tolerance)\n        s1_ok = abs(s1_opt) <= (s1_max + tolerance)\n        s2_ok = abs(s2_opt) <= (s2_max + tolerance)\n\n        is_feasible = g1_ok and g2_ok and theta1_ok and theta2_ok and s1_ok and s2_ok\n\n        # --- Calculate Final Position Error ---\n        p_final, _ = forward_kinematics(theta_opt)\n        pos_error = np.linalg.norm(p_final - p_t)\n\n        final_results.append(is_feasible)\n        final_results.append(pos_error)\n\n    # --- Format and Print Final Output ---\n    output_str = ','.join([str(r) for r in final_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}