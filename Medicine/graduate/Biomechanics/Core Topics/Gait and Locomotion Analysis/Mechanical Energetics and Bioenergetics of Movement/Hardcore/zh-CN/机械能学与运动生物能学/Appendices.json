{
    "hands_on_practices": [
        {
            "introduction": "理解运动中的能量流，首先要掌握在单个关节处产生机械功率的基本原理。这项练习将从力和平移的基本定义出发，推导出旋转运动中瞬时机械功率的表达式 $P = M \\omega$。通过这个过程，你将加深对力矩 $M$ 和角速度 $\\omega$ 如何共同决定能量产生（向心收缩）或吸收（离心收缩）的理解，这是所有运动生物力学能量分析的基石。",
            "id": "4187216",
            "problem": "一名受试者围绕固定的膝关节轴进行等速膝关节伸展。由伸肌产生的膝关节净内力矩随时间恒定，其大小为 $M=50\\ \\text{N}\\cdot\\text{m}$。膝关节以恒定的角速度旋转，其大小为 $\\omega=2\\ \\text{rad/s}$。采用膝关节伸展为正的符号约定，因此净伸展力矩为 $M>0$，伸展角速度为 $\\omega>0$。\n\n仅从机械功 $W$ 作为力在位移上的线积分以及瞬时功率 $P$ 作为做功的时间变化率 $P=\\mathrm{d}W/\\mathrm{d}t$ 的基本定义出发，推导以净关节力矩 $M$ 和关节角速度 $\\omega$ 表示的膝关节瞬时机械功率的表达式。然后，根据给定值计算该功率，并根据所述符号约定，解释向心与离心膝关节伸肌活动下功率的符号。\n\n以瓦特为单位表示最终的功率数值。无需四舍五入。向心与离心活动下功率的符号应在您的推导和解释中得到证明，但您的最终答案必须仅为与给定数据相对应的单一功率数值。",
            "solution": "该问题是有效的，因为它科学地基于旋转力学原理，问题提出得当，数据充分且一致，陈述客观。我们可以开始求解。\n\n该问题要求从平移背景下的功和功率的基本定义出发，推导旋转系统中瞬时机械功率的表达式。\n\n首先，我们从力 $\\vec{F}$ 在无穷小位移 $\\mathrm{d}\\vec{s}$ 上所做的微分机械功 $\\mathrm{d}W$ 的定义开始：\n$$\n\\mathrm{d}W = \\vec{F} \\cdot \\mathrm{d}\\vec{s}\n$$\n瞬时功率 $P$ 定义为做功的时间变化率：\n$$\nP = \\frac{\\mathrm{d}W}{\\mathrm{d}t}\n$$\n将 $\\mathrm{d}W$ 的表达式代入 $P$ 的定义，我们得到：\n$$\nP = \\frac{\\vec{F} \\cdot \\mathrm{d}\\vec{s}}{\\mathrm{d}t} = \\vec{F} \\cdot \\frac{\\mathrm{d}\\vec{s}}{\\mathrm{d}t}\n$$\n认识到位移的时间导数是瞬时速度 $\\vec{v} = \\mathrm{d}\\vec{s}/\\mathrm{d}t$，以线性运动变量表示的功率表达式为：\n$$\nP = \\vec{F} \\cdot \\vec{v}\n$$\n下一步是为绕固定轴纯旋转的系统重新构建此表达式，正如对膝关节的描述。设 $\\vec{r}$ 是从旋转轴上一点到力 $\\vec{F}$ 作用点的位矢。对于通过无穷小角度 $\\mathrm{d}\\vec{\\theta}$ 的纯旋转，相应的无穷小线性位移 $\\mathrm{d}\\vec{s}$ 由叉积给出：\n$$\n\\mathrm{d}\\vec{s} = \\mathrm{d}\\vec{\\theta} \\times \\vec{r}\n$$\n将此代入微分功的表达式中：\n$$\n\\mathrm{d}W = \\vec{F} \\cdot (\\mathrm{d}\\vec{\\theta} \\times \\vec{r})\n$$\n我们可以应用标量三重积恒等式 $\\vec{A} \\cdot (\\vec{B} \\times \\vec{C}) = (\\vec{A} \\times \\vec{B}) \\cdot \\vec{C}$。然而，在此背景下，一个更有用的置换是 $\\vec{A} \\cdot (\\vec{B} \\times \\vec{C}) = \\vec{B} \\cdot (\\vec{C} \\times \\vec{A})$。设 $\\vec{A} = \\vec{F}$，$\\vec{B} = \\mathrm{d}\\vec{\\theta}$，$\\vec{C} = \\vec{r}$。应用此恒等式可得：\n$$\n\\mathrm{d}W = \\mathrm{d}\\vec{\\theta} \\cdot (\\vec{r} \\times \\vec{F})\n$$\n项 $\\vec{r} \\times \\vec{F}$ 是力 $\\vec{F}$ 绕旋转轴产生的力矩（或扭矩）$\\vec{M}$ 的定义。\n$$\n\\vec{M} = \\vec{r} \\times \\vec{F}\n$$\n因此，旋转过程中所做的微分功为：\n$$\n\\mathrm{d}W = \\vec{M} \\cdot \\mathrm{d}\\vec{\\theta}\n$$\n现在，我们可以通过求时间导数来找到瞬时旋转功率：\n$$\nP = \\frac{\\mathrm{d}W}{\\mathrm{d}t} = \\frac{\\mathrm{d}}{\\mathrm{d}t} (\\vec{M} \\cdot \\mathrm{d}\\vec{\\theta})\n$$\n由于在此问题中力矩 $\\vec{M}$ 是恒定的，我们可以写出：\n$$\nP = \\vec{M} \\cdot \\frac{\\mathrm{d}\\vec{\\theta}}{\\mathrm{d}t}\n$$\n角位移的时间变化率是角速度 $\\vec{\\omega} = \\mathrm{d}\\vec{\\theta}/\\mathrm{d}t$。这给出了旋转系统中瞬时机械功率的最终推导表达式：\n$$\nP = \\vec{M} \\cdot \\vec{\\omega}\n$$\n对于绕单一固定轴旋转的特定情况，向量 $\\vec{M}$ 和 $\\vec{\\omega}$ 是共线的。它们的点积简化为其标量大小 $M$ 和 $\\omega$ 的代数乘积：\n$$\nP = M \\omega\n$$\n问题规定了膝关节伸展为正的符号约定。我们已知：\n- 净伸展力矩，根据约定为正：$M = +50\\ \\text{N}\\cdot\\text{m}$。\n- 膝关节伸展角速度，根据约定也为正：$\\omega = +2\\ \\text{rad/s}$。\n\n我们现在可以计算功率：\n$$\nP = (50\\ \\text{N}\\cdot\\text{m}) \\times (2\\ \\text{rad/s}) = 100\\ \\text{N}\\cdot\\text{m/s}\n$$\n单位 $\\text{N}\\cdot\\text{m/s}$ 等效于焦耳每秒 ($\\text{J/s}$)，即定义为瓦特 ($\\text{W}$)。\n$$\nP = 100\\ \\text{W}\n$$\n功率的符号很重要，它表示能量传递的方向。\n- **向心活动**：当产生力矩的肌群引起的旋转方向与其产生的力矩方向相同时，就会发生这种情况。肌肉有效地“战胜”负荷并缩短。在这种情况下，$M$ 和 $\\omega$ 的符号相同（$M>0$ 且 $\\omega>0$，或 $M0$ 且 $\\omega0$）。由此产生的功率 $P = M \\omega$ 为正（$P>0$）。正功率表示肌肉骨骼系统正在对环境做功（即产生机械能）。给定的问题中，伸展力矩（$M>0$）和伸展速度（$\\omega>0$）描述了膝关节伸肌的向心收缩。\n\n- **离心活动**：当产生力矩的肌群作用以抵抗由外部负荷引起的旋转时，就会发生这种情况。肌肉有效地“输给”负荷，在张力下伸长，起到制动作用。在这种情况下，$M$ 和 $\\omega$ 的符号相反（$M>0$ 且 $\\omega0$，或 $M0$ 且 $\\omega>0$）。由此产生的功率 $P = M \\omega$ 为负（$P0$）。负功率表示环境正在对肌肉骨骼系统做功，而肌肉骨骼系统吸收了这种机械能。一个例子是，在放下重物时，膝关节伸肌产生伸展力矩（$M>0$）来控制膝关节屈曲的速率（$\\omega0$）。\n\n问题中描述的情景是向心膝关节伸展，其计算出的功率必须为正，这与我们得到的结果 $100\\ \\text{W}$ 一致。",
            "answer": "$$\\boxed{100}$$"
        },
        {
            "introduction": "在掌握了单个关节的功率计算后，下一步是分析整个运动周期中多个关节的协同作用。这项实践模拟了真实的步态分析任务，你需要处理时变的关节功率数据，通过积分计算出每个关节所做的正功和负功。这项练习将使你能够量化和解释在步态的不同阶段（如早期支撑的碰撞吸收和晚期支撑的蹬伸发力）髋、膝、踝关节各自的能量功能。",
            "id": "4187203",
            "problem": "您将获得步态周期中支撑相期间髋、膝、踝关节的时间序列关节功率曲线，这些曲线由逆动力学推导得出。支撑相区间由固定时长内的均匀采样点表示。您的任务是计算整个支撑相期间每个关节的时间积分正功和负功，并确定哪个关节在支撑相末期的蹬伸阶段和支撑相早期的碰撞阶段中占主导地位。所有结果必须以焦耳（J）为单位，并遵循指定的输出格式。\n\n基本原理和定义：\n- 根据牛顿定律和刚体动力学，一个关节的净关节功率等于净关节力矩与关节角速度的乘积；若关节力矩用 $M(t)$（单位：牛顿米）表示，角速度用 $\\omega(t)$（单位：弧度/秒）表示，则机械功率为 $P(t) = M(t)\\,\\omega(t)$（单位：瓦特）。\n- 一段时间内的机械功是功率的时间积分：$W = \\int P(t)\\,dt$。\n- 功率的正分量和负分量分别为 $P^{+}(t) = \\max(P(t), 0)$ 和 $P^{-}(t) = \\min(P(t), 0)$。正关节功为 $W^{+} = \\int P^{+}(t)\\,dt$，负关节功的量值为 $W^{-} = -\\int P^{-}(t)\\,dt$，两者单位均为焦耳。\n- 将碰撞阶段解释为区间的支撑相早期部分，将蹬伸阶段解释为区间的支撑相末期部分。对于此问题，定义碰撞窗口为支撑相的前 $20\\%$（即归一化时间 $n \\in [0, 0.2]$），蹬伸窗口为支撑相的后 $20\\%$（即归一化时间 $n \\in [0.8, 1.0]$）。角度（如果适用）以弧度为单位。\n\n测试套件的输入生成：\n您不会收到外部输入；相反，您的程序必须使用以下参数形式在内部生成三个代表合理的逆动力学功率曲线的合成测试用例。对于每个用例，定义支撑持续时间 $T$（单位：秒）、整数采样点数 $N$、时间数组 $t$（在 $[0,T]$ 上有 $N$ 个均匀采样点）以及归一化时间 $n = t/T$。关节功率曲线定义为一个早期支撑相的负高斯“碰撞”波瓣和一个晚期支撑相的正高斯“蹬伸”波瓣之和：\n\n对于髋关节：\n$$\nP_{\\mathrm{hip}}(t) = -A_h \\exp\\left(-\\frac{(n - \\mu_{h1})^2}{\\sigma_{h1}^2}\\right) + B_h \\exp\\left(-\\frac{(n - \\mu_{h2})^2}{\\sigma_{h2}^2}\\right)\n$$\n\n对于膝关节：\n$$\nP_{\\mathrm{knee}}(t) = -A_k \\exp\\left(-\\frac{(n - \\mu_{k1})^2}{\\sigma_{k1}^2}\\right) + B_k \\exp\\left(-\\frac{(n - \\mu_{k2})^2}{\\sigma_{k2}^2}\\right)\n$$\n\n对于踝关节：\n$$\nP_{\\mathrm{ankle}}(t) = -A_{a\\_neg} \\exp\\left(-\\frac{(n - \\mu_{a1})^2}{\\sigma_{a1}^2}\\right) + B_a \\exp\\left(-\\frac{(n - \\mu_{a2})^2}{\\sigma_{a2}^2}\\right)\n$$\n\n所有幅值 $A_h$、$A_k$、$A_{a\\_neg}$ 和 $B_h$、$B_k$、$B_a$ 的单位均为瓦特；参数 $\\mu$ 和 $\\sigma$ 在归一化时间 $n$ 中是无量纲的。\n\n测试套件规范：\n使用具有科学合理性的参数值定义以下三种情况。\n\n- 情况 $1$（类步行）：\n  - $T = 0.7\\,\\mathrm{s}$，$N = 101$\n  - 髋关节：$A_h = 200$，$B_h = 150$，$\\mu_{h1} = 0.12$，$\\sigma_{h1} = 0.08$，$\\mu_{h2} = 0.82$，$\\sigma_{h2} = 0.10$\n  - 膝关节：$A_k = 250$，$B_k = 120$，$\\mu_{k1} = 0.15$，$\\sigma_{k1} = 0.10$，$\\mu_{k2} = 0.65$，$\\sigma_{k2} = 0.12$\n  - 踝关节：$A_{a\\_neg} = 80$，$B_a = 250$，$\\mu_{a1} = 0.10$，$\\sigma_{a1} = 0.08$，$\\mu_{a2} = 0.88$，$\\sigma_{a2} = 0.08$\n\n- 情况 $2$（类跑步，具有更大的蹬伸和碰撞量值）：\n  - $T = 0.4\\,\\mathrm{s}$，$N = 161$\n  - 髋关节：$A_h = 220$，$B_h = 180$，$\\mu_{h1} = 0.10$，$\\sigma_{h1} = 0.07$，$\\mu_{h2} = 0.78$，$\\sigma_{h2} = 0.09$\n  - 膝关节：$A_k = 380$，$B_k = 150$，$\\mu_{k1} = 0.12$，$\\sigma_{k1} = 0.09$，$\\mu_{k2} = 0.60$，$\\sigma_{k2} = 0.12$\n  - 踝关节：$A_{a\\_neg} = 90$，$B_a = 500$，$\\mu_{a1} = 0.10$，$\\sigma_{a1} = 0.06$，$\\mu_{a2} = 0.87$，$\\sigma_{a2} = 0.07$\n\n- 情况 $3$（边缘情况：踝关节蹬伸较弱，膝关节吸收显著）：\n  - $T = 0.6\\,\\mathrm{s}$，$N = 101$\n  - 髋关节：$A_h = 50$，$B_h = 40$，$\\mu_{h1} = 0.12$，$\\sigma_{h1} = 0.09$，$\\mu_{h2} = 0.80$，$\\sigma_{h2} = 0.11$\n  - 膝关节：$A_k = 220$，$B_k = 60$，$\\mu_{k1} = 0.14$，$\\sigma_{k1} = 0.10$，$\\mu_{k2} = 0.62$，$\\sigma_{k2} = 0.13$\n  - 踝关节：$A_{a\\_neg} = 30$，$B_a = 20$，$\\mu_{a1} = 0.10$，$\\sigma_{a1} = 0.08$，$\\mu_{a2} = 0.88$，$\\sigma_{a2} = 0.08$\n\n计算要求：\n- 对于每种情况，计算整个支撑相期间每个关节的 $W^{+}$ 和 $W^{-}$。报告髋、膝、踝关节的 $W^{+}$ 和 $W^{-}$，以焦耳为单位的正量值表示。\n- 计算在 $n \\in [0.8, 1.0]$ 窗口内每个关节的蹬伸正功，并确定具有最大蹬伸正功的关节索引。计算在 $n \\in [0.0, 0.2]$ 窗口内每个关节的碰撞负功量值，并确定具有最大碰撞负功量值的关节索引。\n- 关节索引编码必须为：髋关节 $\\rightarrow 0$，膝关节 $\\rightarrow 1$，踝关节 $\\rightarrow 2$。\n\n数值方法和单位：\n- 使用梯形法则来近似所有时间积分。\n- 所有功值以焦耳（J）表示，四舍五入到三位小数。\n- 角度以弧度为单位；时间以秒为单位；功率以瓦特为单位；功以焦耳为单位。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，列表用方括号括起来，其中每个测试用例的结果本身是一个包含八个浮点数和两个整数的列表：$[W^{+}_{\\mathrm{hip}}, W^{-}_{\\mathrm{hip}}, W^{+}_{\\mathrm{knee}}, W^{-}_{\\mathrm{knee}}, W^{+}_{\\mathrm{ankle}}, W^{-}_{\\mathrm{ankle}}, i_{\\mathrm{push}}, i_{\\mathrm{coll}}]$。将三个测试用例聚合到一个顶层列表中。例如：$[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "所提出的问题在科学上是合理的、良定的和客观的。它基于刚体动力学和生物力学能量学的基本原理。该问题提供了所有必要的参数、定义和计算要求，以得出一个唯一的、可验证的解。因此，该问题被认为是有效的，下面将给出完整的解。\n\n目标是分析步态支撑相期间髋、膝、踝关节的合成关节功率曲线。这涉及计算每个关节的总正功和负功，并确定哪个关节主要负责支撑相末期（蹬伸）的能量生成和支撑相早期（碰撞）的能量吸收。\n\n对所提供的三个测试用例中的每一个，分析都分三个主要阶段进行。\n\n**1. 关节功率曲线的生成**\n对于每种情况，我们都给定了支撑持续时间 $T$ 和采样点数 $N$。我们首先为支撑相建立一个离散时间域。时间向量 $t$ 由区间 $[0, T]$ 上的 $N$ 个均匀间隔的点组成。\n$$\nt_i = i \\cdot \\Delta t, \\quad \\text{for } i = 0, 1, \\dots, N-1 \\quad \\text{where } \\Delta t = \\frac{T}{N-1}\n$$\n然后定义一个归一化时间向量 $n = t/T$，它将支撑相映射到单位区间 $[0, 1]$。\n\n髋关节（$P_{\\mathrm{hip}}$）、膝关节（$P_{\\mathrm{knee}}$）和踝关节（$P_{\\mathrm{ankle}}$）的功率曲线使用提供的参数方程合成，这些方程模拟了支撑相早期的负（吸收性）功率波瓣和支撑相晚期的正（生成性）功率波瓣。例如，髋关节功率 $P_{\\mathrm{hip}}(t)$ 是归一化时间 $n$ 的函数：\n$$\nP_{\\mathrm{hip}}(t) = -A_h \\exp\\left(-\\frac{(n - \\mu_{h1})^2}{\\sigma_{h1}^2}\\right) + B_h \\exp\\left(-\\frac{(n - \\mu_{h2})^2}{\\sigma_{h2}^2}\\right)\n$$\n类似的方程用于膝关节和踝关节，使用它们各自的参数集 $(A_k, B_k, \\dots)$ 和 $(A_{a\\_neg}, B_a, \\dots)$。\n\n**2. 机械功的计算**\n机械功 $W$ 是机械功率 $P(t)$ 的时间积分。\n$$\nW = \\int P(t) \\, dt\n$$\n问题要求计算正功 $W^{+}$（能量生成）和负功的量值 $W^{-}$（能量吸收）。这些是通过分别对功率曲线的正部和负部进行积分来定义的。\n- 正功率：$P^{+}(t) = \\max(P(t), 0)$\n- 负功率：$P^{-}(t) = \\min(P(t), 0)$\n\n正功是正功率的积分：\n$$\nW^{+} = \\int_{0}^{T} P^{+}(t) \\, dt\n$$\n负功的量值定义为负功率绝对值的积分，或等效地：\n$$\nW^{-} = - \\int_{0}^{T} P^{-}(t) \\, dt\n$$\n按照规定，这些定积分使用梯形法则进行数值逼近。对于在离散点 $(t_i, f_i)$ 处采样的函数 $f(t)$，积分近似为：\n$$\n\\int_{t_0}^{t_{N-1}} f(t) \\, dt \\approx \\sum_{i=1}^{N-1} \\frac{f_{i-1} + f_i}{2} (t_i - t_{i-1})\n$$\n由于时间步长是均匀的，$\\Delta t = t_i - t_{i-1}$，这可以简化计算。对三个关节中的每一个都执行此计算，以找到 $(W^{+}_{\\mathrm{hip}}, W^{-}_{\\mathrm{hip}})$、$(W^{+}_{\\mathrm{knee}}, W^{-}_{\\mathrm{knee}})$ 和 $(W^{+}_{\\mathrm{ankle}}, W^{-}_{\\mathrm{ankle}})$。\n\n**3. 碰撞和蹬伸阶段的分析**\n问题定义了用于分析的特定子区间：\n- 碰撞阶段：支撑相的最初 $20\\%$，对应于归一化时间 $n \\in [0, 0.2]$。\n- 蹬伸阶段：支撑相的最后 $20\\%$，对应于归一化时间 $n \\in [0.8, 1.0]$。\n\n为了量化每个阶段的主导关节，我们在这些特定时间窗口内计算每个关节所做的相关功。\n\n对于碰撞阶段，我们关心的是最大的能量吸收。我们计算每个关节在区间 $[0, 0.2T]$ 内的负功量值。令 $t_{\\mathrm{coll\\_end}} = 0.2T$。给定关节的碰撞功为：\n$$\nW^{-}_{\\mathrm{coll}} = - \\int_{0}^{t_{\\mathrm{coll\\_end}}} P^{-}(t) \\, dt\n$$\n具有最大 $W^{-}_{\\mathrm{coll}}$ 的关节被确定为主要吸收能量的关节。其索引表示为 $i_{\\mathrm{coll}}$（髋关节：$0$，膝关节：$1$，踝关节：$2$）。\n\n对于蹬伸阶段，我们关心的是最大的能量生成。我们计算每个关节在区间 $[0.8T, T]$ 内的正功。令 $t_{\\mathrm{push\\_start}} = 0.8T$。蹬伸功为：\n$$\nW^{+}_{\\mathrm{push}} = \\int_{t_{\\mathrm{push\\_start}}}^{T} P^{+}(t) \\, dt\n$$\n具有最大 $W^{+}_{\\mathrm{push}}$ 的关节被确定为主要生成能量的关节。其索引表示为 $i_{\\mathrm{push}}$。\n\n对三个测试用例中的每一个都执行这些计算，并根据规范汇总和格式化结果。所有功值均以焦耳（J）报告。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the biomechanics problem for three test cases.\n    Generates joint power profiles, computes positive and negative work,\n    and identifies dominant joints for collision and push-off phases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (walking-like)\n        {\n            \"T\": 0.7, \"N\": 101,\n            \"hip\":   {\"A\": 200, \"B\": 150, \"mu1\": 0.12, \"sigma1\": 0.08, \"mu2\": 0.82, \"sigma2\": 0.10},\n            \"knee\":  {\"A\": 250, \"B\": 120, \"mu1\": 0.15, \"sigma1\": 0.10, \"mu2\": 0.65, \"sigma2\": 0.12},\n            \"ankle\": {\"A\": 80,  \"B\": 250, \"mu1\": 0.10, \"sigma1\": 0.08, \"mu2\": 0.88, \"sigma2\": 0.08}\n        },\n        # Case 2 (running-like)\n        {\n            \"T\": 0.4, \"N\": 161,\n            \"hip\":   {\"A\": 220, \"B\": 180, \"mu1\": 0.10, \"sigma1\": 0.07, \"mu2\": 0.78, \"sigma2\": 0.09},\n            \"knee\":  {\"A\": 380, \"B\": 150, \"mu1\": 0.12, \"sigma1\": 0.09, \"mu2\": 0.60, \"sigma2\": 0.12},\n            \"ankle\": {\"A\": 90,  \"B\": 500, \"mu1\": 0.10, \"sigma1\": 0.06, \"mu2\": 0.87, \"sigma2\": 0.07}\n        },\n        # Case 3 (edge case)\n        {\n            \"T\": 0.6, \"N\": 101,\n            \"hip\":   {\"A\": 50,  \"B\": 40,  \"mu1\": 0.12, \"sigma1\": 0.09, \"mu2\": 0.80, \"sigma2\": 0.11},\n            \"knee\":  {\"A\": 220, \"B\": 60,  \"mu1\": 0.14, \"sigma1\": 0.10, \"mu2\": 0.62, \"sigma2\": 0.13},\n            \"ankle\": {\"A\": 30,  \"B\": 20,  \"mu1\": 0.10, \"sigma1\": 0.08, \"mu2\": 0.88, \"sigma2\": 0.08}\n        }\n    ]\n    \n    # Joint index encoding: hip -> 0, knee -> 1, ankle -> 2\n    joint_names = [\"hip\", \"knee\", \"ankle\"]\n    \n    all_results = []\n\n    for case in test_cases:\n        T, N = case[\"T\"], case[\"N\"]\n        t = np.linspace(0, T, N)\n        n = t / T\n\n        case_results = []\n        \n        # Store work done in specific phases for later comparison\n        push_off_works = []\n        collision_works = []\n\n        for joint_name in joint_names:\n            params = case[joint_name]\n            A, B = params[\"A\"], params[\"B\"]\n            mu1, sigma1 = params[\"mu1\"], params[\"sigma1\"]\n            mu2, sigma2 = params[\"mu2\"], params[\"sigma2\"]\n\n            # Generate power profile\n            P = -A * np.exp(-((n - mu1)**2) / sigma1**2) + B * np.exp(-((n - mu2)**2) / sigma2**2)\n            \n            # Separate into positive and negative components\n            P_pos = np.maximum(0, P)\n            P_neg = np.minimum(0, P)\n\n            # Compute total positive and negative work over the entire stance\n            W_pos_total = np.trapz(P_pos, x=t)\n            W_neg_total = -np.trapz(P_neg, x=t)\n            \n            case_results.extend([round(W_pos_total, 3), round(W_neg_total, 3)])\n            \n            # --- Analysis of collision and push-off phases ---\n            \n            # Collision window: n in [0.0, 0.2]\n            coll_indices = np.where(n = 0.2)[0]\n            t_coll = t[coll_indices]\n            P_neg_coll = P_neg[coll_indices]\n            W_neg_coll = -np.trapz(P_neg_coll, x=t_coll)\n            collision_works.append(W_neg_coll)\n\n            # Push-off window: n in [0.8, 1.0]\n            push_indices = np.where(n >= 0.8)[0]\n            t_push = t[push_indices]\n            P_pos_push = P_pos[push_indices]\n            W_pos_push = np.trapz(P_pos_push, x=t_push)\n            push_off_works.append(W_pos_push)\n\n        # Identify dominant joints by index\n        i_push = int(np.argmax(push_off_works))\n        i_coll = int(np.argmax(collision_works))\n        \n        case_results.extend([i_push, i_coll])\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required\n    formatted_results = []\n    for res_list in all_results:\n        # Separate floats and ints for formatting\n        floats = res_list[:-2]\n        ints = res_list[-2:]\n        # Format floats to 3 decimal places, ints as they are\n        float_strs = [f\"{f:.3f}\" for f in floats]\n        int_strs = [str(i) for i in ints]\n        formatted_list_str = f\"[{','.join(float_strs + int_strs)}]\"\n        formatted_results.append(formatted_list_str)\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```"
        },
        {
            "introduction": "机械功的分析最终与生物体的代谢能耗紧密相关。这项练习将你的视角从纯粹的机械能学提升到生物能量学，引入了衡量运动经济性的关键指标——运输成本（Cost of Transport, COT）。你将学习如何使用数值方法（如样条插值和优化算法）来处理实验数据，以确定最小化代谢能量消耗的最佳步行速度。",
            "id": "4187152",
            "problem": "一个体重为 $m = 70\\ \\text{kg}$ 的受试者在水平地面上以速度 $v$ 行走。设总代谢功率表示为 $P_{\\mathrm{gross}}(v)$，定义为行走期间测得的总代谢功率，包括其静息分量。此处，运输成本 (COT) 定义为每单位身体质量、每单位距离的总代谢能量，由下式给出：\n$$\n\\mathrm{COT}(v) = \\frac{P_{\\mathrm{gross}}(v)}{m\\,v},\n$$\n当 $P_{\\mathrm{gross}}(v)$ 以 $\\text{W}$ 表示，$v$ 以 $\\text{m}/\\text{s}$ 表示时，$\\mathrm{COT}(v)$ 以 $\\text{J}/\\text{kg}/\\text{m}$ 表示。假设在水平地面上稳定行走，且速度域严格大于零。\n\n你的任务是，对于一组给定的离散测量值 $(v_i, P_{\\mathrm{gross},i})$，在 $v \\in [\\min_i v_i,\\ \\max_i v_i]$ 上对 $P_{\\mathrm{gross}}(v)$ 进行连续可微插值，并计算出能使 $\\mathrm{COT}(v)$ 最小化的速度 $v^\\star$。然后，你必须将 $v^\\star$ 与给定的偏好步行速度 $v_{\\mathrm{pref}}$ 进行比较，报告其绝对差 $\\Delta v = |v^\\star - v_{\\mathrm{pref}}|$ 以及该差值是否在容差 $\\delta = 0.1\\ \\text{m}/\\text{s}$ 之内。\n\n需使用的基本原理：\n- 速度的运动学定义：$v = \\frac{dx}{dt}$。\n- 功率的定义：$P = \\frac{dE}{dt}$。\n- 总运输成本的定义：$\\mathrm{COT}(v) = \\frac{P_{\\mathrm{gross}}(v)}{m\\,v}$。\n- 在测量的速度域内对一个连续可微插值函数进行优化。\n\n数值与算法要求：\n- 在测量的 $v$ 域上构建一个二次连续可微插值函数 $P_{\\mathrm{gross}}(v)$（使用自然三次样条），并在闭区间 $[\\min_i v_i,\\ \\max_i v_i]$ 上最小化 $\\mathrm{COT}(v)$。\n- 如果无约束最小化解位于区间之外，则约束最小化解将在边界上。你的数值方法必须返回约束最小化解。\n- $v^\\star$ 以 $\\text{m}/\\text{s}$ 表示，$\\mathrm{COT}(v^\\star)$ 以 $\\text{J}/\\text{kg}/\\text{m}$ 表示，$\\Delta v$ 以 $\\text{m}/\\text{s}$ 表示。\n- 将所有报告的浮点值四舍五入到三位小数。\n\n测试套件（所有功率单位为 $\\text{W}$，速度单位为 $\\text{m}/\\text{s}$）：\n- 情况 A（内部最优，典型步行）：\n  - $v$ 值：$\\{0.8,\\ 1.0,\\ 1.2,\\ 1.4,\\ 1.6,\\ 1.8\\}$\n  - $P_{\\mathrm{gross}}(v)$ 值：由 $P_{\\mathrm{gross}}(v) = 90 + 80\\,v + 50\\,v^2$ 计算得出：\n    - $\\{186.0,\\ 220.0,\\ 258.0,\\ 300.0,\\ 346.0,\\ 396.0\\}$\n  - $v_{\\mathrm{pref}} = 1.30$\n- 情况 B（最优点超出测量范围；边界约束）：\n  - $v$ 值：$\\{0.5,\\ 0.7,\\ 0.9,\\ 1.1,\\ 1.3,\\ 1.5,\\ 1.8\\}$\n  - $P_{\\mathrm{gross}}(v)$ 值：由 $P_{\\mathrm{gross}}(v) = 120 + 70\\,v + 30\\,v^2$ 计算得出：\n    - $\\{162.5,\\ 183.7,\\ 207.3,\\ 233.3,\\ 261.7,\\ 293.0,\\ 343.2\\}$\n  - $v_{\\mathrm{pref}} = 1.60$\n- 情况 C（内部最优，接近低速）：\n  - $v$ 值：$\\{0.6,\\ 0.7,\\ 0.8,\\ 0.9,\\ 1.1,\\ 1.3,\\ 1.6,\\ 1.9\\}$\n  - $P_{\\mathrm{gross}}(v)$ 值：由 $P_{\\mathrm{gross}}(v) = 90 + 30\\,v + 120\\,v^2$ 计算得出：\n    - $\\{151.2,\\ 169.8,\\ 190.8,\\ 214.2,\\ 268.2,\\ 331.8,\\ 445.2,\\ 580.2\\}$\n  - $v_{\\mathrm{pref}} = 0.80$\n\n要求的最终输出：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$$\n[\\ v^\\star_{\\mathrm{A}},\\ \\mathrm{COT}^\\star_{\\mathrm{A}},\\ \\Delta v_{\\mathrm{A}},\\ \\text{is\\_close}_{\\mathrm{A}},\\ v^\\star_{\\mathrm{B}},\\ \\mathrm{COT}^\\star_{\\mathrm{B}},\\ \\Delta v_{\\mathrm{B}},\\ \\text{is\\_close}_{\\mathrm{B}},\\ v^\\star_{\\mathrm{C}},\\ \\mathrm{COT}^\\star_{\\mathrm{C}},\\ \\Delta v_{\\mathrm{C}},\\ \\text{is\\_close}_{\\mathrm{C}}\\ ]\n$$\n其中每个 $v^\\star$、$\\mathrm{COT}^\\star$ 和 $\\Delta v$ 都四舍五入到三位小数，每个 $\\text{is\\_close}$ 是一个布尔值，表示 $\\Delta v \\le \\delta$ 是否成立。",
            "solution": "该问题被评估为有效，因为它科学地基于生物力学原理，问题定义良好、客观，并包含一套完整且一致的数据和约束，可用于有意义的求解。\n\n目标是确定能使体重为 $m = 70\\ \\text{kg}$ 的受试者的总运输成本 (COT) 最小化的步行速度 $v^\\star$。COT 定义为每单位身体质量、每单位行进距离所消耗的总代谢能量：\n$$\n\\mathrm{COT}(v) = \\frac{P_{\\mathrm{gross}}(v)}{m\\,v}\n$$\n其中 $P_{\\mathrm{gross}}(v)$ 是速度为 $v$ 时的总代谢功率。最小化过程将在一个闭区间上执行，该区间由给定离散测量集中的最小和最大速度定义，即 $[v_{\\min}, v_{\\max}]$。\n\n为了找到函数 $\\mathrm{COT}(v)$ 的最小值，我们通过对其关于 $v$ 求导并令其为零来分析其临界点。假设 $P_{\\mathrm{gross}}(v)$ 是一个关于 $v$ 的可微函数，并且由于 $m$ 是常数且我们关心的是 $v  0$ 的情况，我们可以最小化简化后的函数 $f(v) = \\frac{P_{\\mathrm{gross}}(v)}{v}$。使用微分的商法则：\n$$\n\\frac{d}{dv} \\left( \\frac{P_{\\mathrm{gross}}(v)}{v} \\right) = \\frac{v \\cdot \\frac{d P_{\\mathrm{gross}}(v)}{dv} - P_{\\mathrm{gross}}(v) \\cdot 1}{v^2} = 0\n$$\n为了使该表达式在 $v  0$ 时为零，其分子必须为零：\n$$\nv \\cdot P'_{\\mathrm{gross}}(v) - P_{\\mathrm{gross}}(v) = 0\n$$\n其中 $P'_{\\mathrm{gross}}(v)$ 是 $P_{\\mathrm{gross}}(v)$ 对 $v$ 的导数。这导出了最优速度 $v^\\star$ 的基本条件：\n$$\nP'_{\\mathrm{gross}}(v^{\\star}) = \\frac{P_{\\mathrm{gross}}(v^{\\star})}{v^{\\star}}\n$$\n从几何上看，这个条件意味着 $P_{\\mathrm{gross}}(v)$ 曲线在最优速度 $v^\\star$ 处的切线必须穿过原点 $(0, 0)$。\n\n该问题提供了离散数据点 $(v_i, P_{\\mathrm{gross},i})$。为了应用微积分，我们必须首先构建一个穿过这些点的连续可微函数 $P_{\\mathrm{gross}}(v)$。问题指定使用自然三次样条插值。三次样条是一个由三次多项式组成的分段函数，它是二次连续可微的（$C^2$）。这一选择确保了功率曲线的平滑表示，适用于微分和优化。设此样条函数表示为 $S(v)$。\n\n因此，优化任务是在约束区间 $[v_{\\min}, v_{\\max}]$ 内找到使 $\\mathrm{COT}(v) = \\frac{S(v)}{mv}$ 最小化的值 $v^{\\star}$，其中 $v_{\\min} = \\min_i v_i$ 且 $v_{\\max} = \\max_i v_i$。根据极值定理，闭合有界区间上的连续函数保证能达到最小值。该最小值将出现在导数为零的内点，或出现在边界点 $v_{\\min}$ 或 $v_{\\max}$ 之一。\n\n解决每个测试用例的算法流程如下：\n1.  对于一组给定的速度测量值 $\\{v_i\\}$ 和一个用于生成相应功率值 $\\{P_{\\mathrm{gross},i}\\}$ 的函数，建立离散数据点 $(v_i, P_{\\mathrm{gross},i})$。\n2.  使用 `scipy.interpolate.CubicSpline` 构建自然三次样条 $S(v)$ 来插值这些数据点。此函数作为我们的 $P_{\\mathrm{gross}}(v)$ 模型。\n3.  定义目标函数 $\\mathrm{COT}(v) = \\frac{S(v)}{mv}$。对于此问题，$m = 70 \\text{ kg}$。\n4.  使用数值优化程序 `scipy.optimize.minimize_scalar` 及其 `bounded` 方法，在区间 $[v_{\\min}, v_{\\max}]$ 上寻找使 $\\mathrm{COT}(v)$ 最小化的速度 $v^\\star$。无论最小值位于区间内部还是边界，此方法都能正确识别。\n5.  一旦找到 $v^\\star$，最小运输成本计算为 $\\mathrm{COT}^\\star = \\mathrm{COT}(v^\\star)$。\n6.  计算最优速度与偏好速度之间的绝对差 $\\Delta v = |v^\\star - v_{\\mathrm{pref}}|$。\n7.  将此差值与给定的容差 $\\delta = 0.1\\ \\text{m}/\\text{s}$ 进行比较，以确定布尔值 `is_close`（$\\Delta v \\le \\delta$）。\n8.  所有得到的浮点值（$v^\\star$、$\\mathrm{COT}^\\star$、$\\Delta v$）都按要求四舍五入到三位小数。\n9.  所有测试用例的结果被汇总到一个列表中，并格式化以供输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import CubicSpline\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Validates and solves the biomechanics problem of finding the optimal walking speed.\n    \"\"\"\n    \n    # Define problem constants\n    m = 70.0  # kg, body mass\n    delta = 0.1 # m/s, tolerance for speed comparison\n\n    # Define the power generation functions for each test case\n    def get_P_A(v):\n        return 90.0 + 80.0 * v + 50.0 * v**2\n\n    def get_P_B(v):\n        return 120.0 + 70.0 * v + 30.0 * v**2\n\n    def get_P_C(v):\n        return 90.0 + 30.0 * v + 120.0 * v**2\n\n    # Define the test cases from the problem statement.\n    # Each case is a dictionary containing the speed data, the function to generate power,\n    # and the preferred walking speed.\n    test_cases = [\n        {\n            \"v_data\": np.array([0.8, 1.0, 1.2, 1.4, 1.6, 1.8]),\n            \"p_func\": get_P_A,\n            \"v_pref\": 1.30,\n        },\n        {\n            \"v_data\": np.array([0.5, 0.7, 0.9, 1.1, 1.3, 1.5, 1.8]),\n            \"p_func\": get_P_B,\n            \"v_pref\": 1.60,\n        },\n        {\n            \"v_data\": np.array([0.6, 0.7, 0.8, 0.9, 1.1, 1.3, 1.6, 1.9]),\n            \"p_func\": get_P_C,\n            \"v_pref\": 0.80,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        v_i = case[\"v_data\"]\n        p_func = case[\"p_func\"]\n        v_pref = case[\"v_pref\"]\n\n        # 1. Generate the discrete power data from the given formula\n        p_i = p_func(v_i)\n        \n        # 2. Define the optimization interval\n        v_min, v_max = v_i.min(), v_i.max()\n        \n        # 3. Construct the natural cubic spline for P_gross(v)\n        p_spline = CubicSpline(v_i, p_i, bc_type='natural')\n        \n        # 4. Define the objective function, COT(v)\n        cot_func = lambda v: p_spline(v) / (m * v)\n        \n        # 5. Find the speed v_star that minimizes COT(v) in the bounded interval\n        opt_result = minimize_scalar(\n            cot_func, \n            bounds=(v_min, v_max), \n            method='bounded'\n        )\n        \n        v_star = opt_result.x\n        cot_star = opt_result.fun\n        \n        # 6. Calculate the difference from preferred speed and check tolerance\n        delta_v = abs(v_star - v_pref)\n        is_close = delta_v = delta\n        \n        # 7. Append rounded results to the list\n        results.extend([\n            round(v_star, 3),\n            round(cot_star, 3),\n            round(delta_v, 3),\n            is_close\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}