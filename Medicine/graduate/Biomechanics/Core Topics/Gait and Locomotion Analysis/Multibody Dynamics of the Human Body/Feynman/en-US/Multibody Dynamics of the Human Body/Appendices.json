{
    "hands_on_practices": [
        {
            "introduction": "Before we can model the dynamics of the human body, we must first be able to precisely describe its orientation in 3D space. This exercise delves into the exponential map, a powerful tool for representing rotations, by deriving the famous Rodrigues' rotation formula from first principles . Understanding this relationship and its approximations is crucial for accurately implementing and interpreting the kinematics of body segments.",
            "id": "4193035",
            "problem": "A lower-limb segment in a human gait model is treated as a rigid body whose orientation evolves in time using the exponential coordinates of rotation. Let $\\hat{u} \\in \\mathbb{R}^{3}$ be a unit vector describing the instantaneous axis of rotation (e.g., the knee flexion-extension axis measured by an Inertial Measurement Unit (IMU)), and let $\\theta \\in \\mathbb{R}$ be the corresponding right-handed rotation angle in radians. Define the skew-symmetric cross-product matrix $[\\hat{u}]_{\\times} \\in \\mathbb{R}^{3 \\times 3}$ by the property $[\\hat{u}]_{\\times} v = \\hat{u} \\times v$ for any $v \\in \\mathbb{R}^{3}$. The rigid-body rotation associated with $(\\hat{u}, \\theta)$ is represented by the matrix exponential $R(\\hat{u},\\theta) = \\exp\\!\\big(\\theta\\,[\\hat{u}]_{\\times}\\big) \\in \\mathbb{R}^{3 \\times 3}$.\n\nStarting only from the definition of the matrix exponential and the vector triple product identity, perform the following:\n\n1. Derive a closed-form expression for $R(\\hat{u},\\theta)$ in terms of $\\hat{u}$, $\\theta$, and elementary trigonometric functions, without invoking any pre-stated closed-form rotation formula.\n\n2. Obtain the first-order small-angle approximation for $R(\\hat{u},\\theta)$ as $\\theta \\to 0$ by systematically truncating the series expansions of the relevant functions, and clearly identify the leading-order term of the approximation error $E(\\hat{u},\\theta) := R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)$.\n\n3. To quantify the effect of the small-angle approximation on numerical stability in segment orientation updates, evaluate the dimensionless constant\n$$\nC \\;=\\; \\lim_{\\theta \\to 0} \\frac{\\big\\|\\,R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)\\,\\big\\|_{F}}{\\theta^{2}},\n$$\nwhere $\\|\\cdot\\|_{F}$ denotes the Frobenius norm. Your derivation must make clear whether $C$ depends on $\\hat{u}$.\n\nProvide your final answer as the exact value of $C$ in simplified closed form. State angles in radians. The final value of $C$ is dimensionless. Do not round; provide the exact expression.",
            "solution": "The problem requires a three-part derivation concerning the exponential map representation of rotations. The process begins with validating the problem statement, which is found to be scientifically sound, well-posed, and objective, based on fundamental principles of rigid-body kinematics and Lie group theory as applied to biomechanics.\n\n**Part 1: Derivation of the Closed-Form Expression for $R(\\hat{u},\\theta)$**\n\nThe rotation matrix $R(\\hat{u},\\theta)$ is defined by the matrix exponential $R(\\hat{u},\\theta) = \\exp(\\theta\\,[\\hat{u}]_{\\times})$, where $\\hat{u}$ is a unit vector and $[\\hat{u}]_{\\times}$ is the corresponding skew-symmetric matrix. The derivation starts from the Taylor series expansion of the matrix exponential:\n$$\nR(\\hat{u},\\theta) = \\sum_{k=0}^{\\infty} \\frac{(\\theta\\,[\\hat{u}]_{\\times})^{k}}{k!} = I + \\theta\\,[\\hat{u}]_{\\times} + \\frac{\\theta^{2}}{2!}[\\hat{u}]_{\\times}^{2} + \\frac{\\theta^{3}}{3!}[\\hat{u}]_{\\times}^{3} + \\dots\n$$\nTo find a closed form, we investigate the powers of the matrix $K = [\\hat{u}]_{\\times}$. For any vector $v \\in \\mathbb{R}^{3}$, the action of $K^{2}$ is:\n$$\nK^{2}v = [\\hat{u}]_{\\times}([\\hat{u}]_{\\times}v) = \\hat{u} \\times (\\hat{u} \\times v)\n$$\nUsing the vector triple product identity, $a \\times (b \\times c) = b(a \\cdot c) - c(a \\cdot b)$, we get:\n$$\n\\hat{u} \\times (\\hat{u} \\times v) = \\hat{u}(\\hat{u} \\cdot v) - v(\\hat{u} \\cdot \\hat{u})\n$$\nSince $\\hat{u}$ is a unit vector, $\\hat{u} \\cdot \\hat{u} = \\|\\hat{u}\\|^{2} = 1$. The term $\\hat{u}(\\hat{u} \\cdot v)$ can be written in matrix form as $(\\hat{u}\\hat{u}^{T})v$. Thus:\n$$\nK^{2}v = (\\hat{u}\\hat{u}^{T})v - v = (\\hat{u}\\hat{u}^{T} - I)v\n$$\nAs this holds for any $v \\in \\mathbb{R}^{3}$, we have the matrix identity:\n$$\n[\\hat{u}]_{\\times}^{2} = \\hat{u}\\hat{u}^{T} - I\n$$\nNext, we compute the third power:\n$$\n[\\hat{u}]_{\\times}^{3} = [\\hat{u}]_{\\times}[\\hat{u}]_{\\times}^{2} = [\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T} - I) = [\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T}) - [\\hat{u}]_{\\times}\n$$\nThe first term $[\\hat{u}]_{\\times}(\\hat{u}\\hat{u}^{T})$ operating on a vector $v$ gives $\\hat{u} \\times (\\hat{u}(\\hat{u} \\cdot v)) = (\\hat{u} \\cdot v)(\\hat{u} \\times \\hat{u})$. Since $\\hat{u} \\times \\hat{u} = 0$, this term is the zero matrix. Therefore:\n$$\n[\\hat{u}]_{\\times}^{3} = -[\\hat{u}]_{\\times}\n$$\nThis result establishes a cyclic pattern for higher powers: $[\\hat{u}]_{\\times}^{4} = -[\\hat{u}]_{\\times}^{2}$, $[\\hat{u}]_{\\times}^{5} = -[\\hat{u}]_{\\times}^{3} = [\\hat{u}]_{\\times}$, and so on. We can now group the terms in the series expansion:\n$$\nR(\\hat{u},\\theta) = I + \\left(\\theta[\\hat{u}]_{\\times} - \\frac{\\theta^3}{3!} [\\hat{u}]_{\\times} + \\frac{\\theta^5}{5!} [\\hat{u}]_{\\times} - \\dots\\right) + \\left(\\frac{\\theta^2}{2!} [\\hat{u}]_{\\times}^2 - \\frac{\\theta^4}{4!} [\\hat{u}]_{\\times}^2 + \\frac{\\theta^6}{6!} [\\hat{u}]_{\\times}^2 - \\dots\\right)\n$$\nFactoring out the constant matrices $[\\hat{u}]_{\\times}$ and $[\\hat{u}]_{\\times}^{2}$:\n$$\nR(\\hat{u},\\theta) = I + \\left(\\theta - \\frac{\\theta^{3}}{3!} + \\frac{\\theta^{5}}{5!} - \\dots \\right)[\\hat{u}]_{\\times} + \\left(\\frac{\\theta^{2}}{2!} - \\frac{\\theta^{4}}{4!} + \\frac{\\theta^{6}}{6!} - \\dots \\right)[\\hat{u}]_{\\times}^{2}\n$$\nThe series in parentheses are the Taylor series for $\\sin(\\theta)$ and $1-\\cos(\\theta)$, respectively.\n$$\n\\sin(\\theta) = \\sum_{k=0}^{\\infty} \\frac{(-1)^{k}\\theta^{2k+1}}{(2k+1)!} \\quad \\text{and} \\quad 1-\\cos(\\theta) = \\sum_{k=1}^{\\infty} \\frac{(-1)^{k-1}\\theta^{2k}}{(2k)!}\n$$\nSubstituting these into the expression for $R(\\hat{u},\\theta)$ yields the celebrated Rodrigues' rotation formula:\n$$\nR(\\hat{u},\\theta) = I + \\sin(\\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\n$$\n\n**Part 2: Small-Angle Approximation and Leading-Order Error Term**\n\nThe problem defines the first-order small-angle approximation as $I + \\theta\\,[\\hat{u}]_{\\times}$. The approximation error is $E(\\hat{u},\\theta) = R(\\hat{u},\\theta) - (I + \\theta\\,[\\hat{u}]_{\\times})$. Using the result from Part 1:\n$$\nE(\\hat{u},\\theta) = \\big(I + \\sin(\\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\\big) - (I + \\theta\\,[\\hat{u}]_{\\times})\n$$\n$$\nE(\\hat{u},\\theta) = (\\sin(\\theta) - \\theta)[\\hat{u}]_{\\times} + (1-\\cos(\\theta))[\\hat{u}]_{\\times}^{2}\n$$\nTo find the leading-order term of the error as $\\theta \\to 0$, we use the Taylor series expansions of the trigonometric functions around $\\theta=0$:\n$$\n\\sin(\\theta) = \\theta - \\frac{\\theta^{3}}{6} + O(\\theta^{5}) \\implies \\sin(\\theta) - \\theta = -\\frac{\\theta^{3}}{6} + O(\\theta^{5})\n$$\n$$\n\\cos(\\theta) = 1 - \\frac{\\theta^{2}}{2} + \\frac{\\theta^{4}}{24} + O(\\theta^{6}) \\implies 1 - \\cos(\\theta) = \\frac{\\theta^{2}}{2} - \\frac{\\theta^{4}}{24} + O(\\theta^{6})\n$$\nSubstituting these into the expression for $E(\\hat{u},\\theta)$:\n$$\nE(\\hat{u},\\theta) = \\left(-\\frac{\\theta^{3}}{6} + O(\\theta^{5})\\right)[\\hat{u}]_{\\times} + \\left(\\frac{\\theta^{2}}{2} + O(\\theta^{4})\\right)[\\hat{u}]_{\\times}^{2}\n$$\nThe leading-order term is the one with the lowest power of $\\theta$, which is the term proportional to $\\theta^{2}$. Thus, the leading-order error term is:\n$$\nE_{\\text{leading}}(\\hat{u},\\theta) = \\frac{\\theta^{2}}{2}[\\hat{u}]_{\\times}^{2}\n$$\n\n**Part 3: Evaluation of the Constant $C$**\n\nThe constant $C$ is defined by the limit:\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\big\\|R(\\hat{u},\\theta) - \\big(I + \\theta\\,[\\hat{u}]_{\\times}\\big)\\big\\|_{F}}{\\theta^{2}} = \\lim_{\\theta \\to 0} \\frac{\\|E(\\hat{u},\\theta)\\|_{F}}{\\theta^{2}}\n$$\nUsing the expansion of the error term from Part 2:\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\left\\| \\frac{\\theta^{2}}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta^{3}}{6}[\\hat{u}]_{\\times} + O(\\theta^{4}) \\right\\|_{F}}{\\theta^{2}}\n$$\nBy the homogeneity property of norms, $\\|\\alpha A\\|_{F} = |\\alpha|\\|A\\|_{F}$, we can factor out $\\theta^{2}$ (since $\\theta^{2} \\ge 0$):\n$$\nC = \\lim_{\\theta \\to 0} \\frac{\\theta^{2} \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2}) \\right\\|_{F}}{\\theta^{2}} = \\lim_{\\theta \\to 0} \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2}) \\right\\|_{F}\n$$\nThe Frobenius norm is a continuous function of its matrix entries, which are continuous in $\\theta$. We can thus take the limit inside the norm:\n$$\nC = \\left\\| \\lim_{\\theta \\to 0} \\left(\\frac{1}{2}[\\hat{u}]_{\\times}^{2} - \\frac{\\theta}{6}[\\hat{u}]_{\\times} + O(\\theta^{2})\\right) \\right\\|_{F} = \\left\\| \\frac{1}{2}[\\hat{u}]_{\\times}^{2} \\right\\|_{F} = \\frac{1}{2} \\|[\\hat{u}]_{\\times}^{2}\\|_{F}\n$$\nTo evaluate $\\|[\\hat{u}]_{\\times}^{2}\\|_{F}$, we use the property $\\|A\\|_{F}^{2} = \\text{tr}(A^{T}A)$. The matrix $[\\hat{u}]_{\\times}^{2}$ is symmetric, so $([\\hat{u}]_{\\times}^{2})^{T} = [\\hat{u}]_{\\times}^{2}$.\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = \\text{tr}\\big(([\\hat{u}]_{\\times}^{2})^{T}[\\hat{u}]_{\\times}^{2}\\big) = \\text{tr}\\big(([\\hat{u}]_{\\times}^{2})^{2}\\big) = \\text{tr}([\\hat{u}]_{\\times}^{4})\n$$\nUsing the relation $[\\hat{u}]_{\\times}^{4} = -[\\hat{u}]_{\\times}^{2}$:\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = \\text{tr}(-[\\hat{u}]_{\\times}^{2}) = -\\text{tr}([\\hat{u}]_{\\times}^{2})\n$$\nWe substitute the identity $[\\hat{u}]_{\\times}^{2} = \\hat{u}\\hat{u}^{T} - I$:\n$$\n\\text{tr}([\\hat{u}]_{\\times}^{2}) = \\text{tr}(\\hat{u}\\hat{u}^{T} - I) = \\text{tr}(\\hat{u}\\hat{u}^{T}) - \\text{tr}(I)\n$$\nUsing the cyclic property of the trace, $\\text{tr}(\\hat{u}\\hat{u}^{T}) = \\text{tr}(\\hat{u}^{T}\\hat{u}) = \\hat{u}^{T}\\hat{u} = \\|\\hat{u}\\|^{2} = 1$. The trace of the $3 \\times 3$ identity matrix is $\\text{tr}(I)=3$.\n$$\n\\text{tr}([\\hat{u}]_{\\times}^{2}) = 1-3 = -2\n$$\nTherefore, the squared Frobenius norm is:\n$$\n\\|[\\hat{u}]_{\\times}^{2}\\|_{F}^{2} = -(-2) = 2\n$$\nThis gives $\\|[\\hat{u}]_{\\times}^{2}\\|_{F} = \\sqrt{2}$. Importantly, this value is independent of the choice of the unit vector $\\hat{u}$.\nFinally, we substitute this value back into the expression for $C$:\n$$\nC = \\frac{1}{2} \\|[\\hat{u}]_{\\times}^{2}\\|_{F} = \\frac{1}{2}\\sqrt{2} = \\frac{\\sqrt{2}}{2}\n$$",
            "answer": "$$\\boxed{\\frac{\\sqrt{2}}{2}}$$"
        },
        {
            "introduction": "A free-floating body possesses numerous degrees of freedom, but interactions with the environment—such as a foot contacting the ground—impose constraints that reduce this freedom. This practice challenges you to analyze a realistic double-support stance to determine exactly how many independent motions remain . Such analysis is fundamental for setting up correct models for inverse dynamics or predictive simulation and understanding the structure of constrained multibody systems.",
            "id": "4193025",
            "problem": "Consider a three-dimensional free-floating multibody model of a human, where the generalized coordinate vector $q \\in \\mathbb{R}^{n+6}$ comprises a six-dimensional free base for the pelvis (three translational and three rotational components) and $n$ internal joint coordinates. The internal joints are as follows: bilateral hip joints with $3$ rotational components each ($6$ total), bilateral knee joints with $1$ rotational component each ($2$ total), bilateral ankle joints with $2$ rotational components each ($4$ total), a lumbar joint with $3$ rotational components ($3$ total), a cervical joint with $3$ rotational components ($3$ total), bilateral shoulder joints with $3$ rotational components each ($6$ total), bilateral elbow joints with $1$ rotational component each ($2$ total), and bilateral wrist joints with $2$ rotational components each ($4$ total). Assume the joints are ideal and frictionless and that the segments are rigid.\n\nDuring a double-support stance phase on a level rigid ground, the left and right foot frames $F_{L}$ and $F_{R}$ are each in rigid, stationary, non-slipping, non-rolling contact with the ground, so that for each foot the spatial position and spatial orientation relative to the inertial ground frame are constant in time. Let $\\boldsymbol{\\phi}_{L}(q)$ and $\\boldsymbol{\\phi}_{R}(q)$ denote the holonomic contact constraints for the left and right feet, respectively, each comprising the three translational and three rotational constraints that fix the corresponding foot pose. Differentiating these constraints with respect to time yields the velocity-level linear constraints\n$$\n\\mathbf{J}_{L}(q)\\,\\dot{q} = \\mathbf{0}, \\qquad \\mathbf{J}_{R}(q)\\,\\dot{q} = \\mathbf{0},\n$$\nwhere $\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ and $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times (n+6)}$ are the foot spatial-velocity Jacobians. Define the combined contact constraint Jacobian\n$$\n\\mathbf{J}_{c}(q) \\coloneqq \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix} \\in \\mathbb{R}^{12 \\times (n+6)}.\n$$\n\nAssume a generic, non-singular stance configuration in which neither leg is kinematically singular, the two foot frames are distinct and non-coincident, and the ground is rigid, level, and inertial. Determine the reduction in the number of independent Degrees of Freedom (DOFs) relative to the open-chain model by computing the rank of the combined contact constraint Jacobian $\\mathbf{J}_{c}(q)$. Express your final answer as a unitless integer. No rounding is required.",
            "solution": "The problem asks for the reduction in the number of independent Degrees of Freedom (DOFs) of a multibody human model during a double-support phase. This reduction is equivalent to the number of independent constraints imposed on the system, which can be determined by finding the rank of the combined contact constraint Jacobian, $\\mathbf{J}_{c}(q)$.\n\nFirst, we determine the total number of generalized coordinates for the free-floating, open-chain model. The generalized coordinate vector $q$ has $n+6$ components, where $6$ corresponds to the free-floating base of the pelvis and $n$ is the number of internal joint coordinates. The value of $n$ is the sum of the DOFs of all internal joints:\n- Bilateral hip joints: $2 \\times 3 = 6$ DOFs\n- Bilateral knee joints: $2 \\times 1 = 2$ DOFs\n- Bilateral ankle joints: $2 \\times 2 = 4$ DOFs\n- Lumbar joint: $3$ DOFs\n- Cervical joint: $3$ DOFs\n- Bilateral shoulder joints: $2 \\times 3 = 6$ DOFs\n- Bilateral elbow joints: $2 \\times 1 = 2$ DOFs\n- Bilateral wrist joints: $2 \\times 2 = 4$ DOFs\n\nSumming these gives the total number of internal DOFs:\n$$n = 6 + 2 + 4 + 3 + 3 + 6 + 2 + 4 = 30$$\nThe total number of DOFs for the unconstrained open-chain system is therefore $N_{open} = n + 6 = 30 + 6 = 36$. The generalized coordinate vector is $q \\in \\mathbb{R}^{36}$.\n\nThe system is subjected to holonomic constraints due to both feet being in stationary contact with the ground. These constraints are expressed at the velocity level as $\\mathbf{J}_{c}(q)\\,\\dot{q} = \\mathbf{0}$, where $\\mathbf{J}_{c}(q) \\in \\mathbb{R}^{12 \\times 36}$ is the combined Jacobian:\n$$\n\\mathbf{J}_{c}(q) = \\begin{bmatrix} \\mathbf{J}_{L}(q) \\\\ \\mathbf{J}_{R}(q) \\end{bmatrix}\n$$\nHere, $\\mathbf{J}_{L}(q) \\in \\mathbb{R}^{6 \\times 36}$ and $\\mathbf{J}_{R}(q) \\in \\mathbb{R}^{6 \\times 36}$ are the Jacobians for the left and right foot, respectively. Each Jacobian maps the system's generalized velocities $\\dot{q}$ to the $6$-dimensional spatial velocity of the corresponding foot.\n\nThe number of independent constraints is equal to the rank of $\\mathbf{J}_{c}(q)$. The rank of a block matrix is given by:\n$$\n\\text{rank}(\\mathbf{J}_{c}) = \\text{rank}(\\mathbf{J}_{L}) + \\text{rank}(\\mathbf{J}_{R}) - \\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T))\n$$\nwhere $\\mathcal{R}(\\mathbf{A}^T)$ denotes the row space of a matrix $\\mathbf{A}$.\n\nLet us first determine the rank of an individual foot Jacobian, for instance, $\\mathbf{J}_{L}(q)$. This matrix represents the linear transformation from the $36$-dimensional space of generalized velocities to the $6$-dimensional space of spatial velocities of the left foot. The problem states the system is in a \"non-singular stance configuration\" and \"neither leg is kinematically singular\". This implies that the kinematic chain from the pelvis to the foot is not in a singular pose. Given the large number of DOFs of the entire body model ($36$), it is possible to control the $6$ DOFs of the foot to achieve any arbitrary spatial velocity. For example, motions of the pelvis, hip, knee, and ankle can be coordinated to produce any desired translation and rotation of the foot. Therefore, the mapping defined by $\\mathbf{J}_{L}(q)$ is surjective, and its image is the full $6$-dimensional space of spatial velocities. Consequently, the rank of the Jacobian is $6$.\n$$\n\\text{rank}(\\mathbf{J}_{L}(q)) = 6\n$$\nBy the same reasoning, the rank of the right foot Jacobian is also $6$:\n$$\n\\text{rank}(\\mathbf{J}_{R}(q)) = 6\n$$\n\nNext, we must determine the dimension of the intersection of the row spaces of $\\mathbf{J}_{L}$ and $\\mathbf{J}_{R}$. The rows of $\\mathbf{J}_{L}$ and $\\mathbf{J}_{R}$ are linearly independent if and only if the constraints imposed by fixing the left foot are independent of the constraints imposed by fixing the right foot.\nPhysically, this means that even when one foot is fixed, the other foot can still move with $6$ degrees of freedom. Let's consider the left foot to be fixed to the ground. The kinematic chain connecting the left foot to the right foot passes through the left leg, the pelvis, and the right leg. The joints in this chain are: left ankle ($2$ DOFs), left knee ($1$ DOF), left hip ($3$ DOFs), right hip ($3$ DOFs), right knee ($1$ DOF), and right ankle ($2$ DOFs). The total number of degrees of freedom in this chain is $2+1+3+3+1+2=12$.\nThis $12$-DOF kinematic chain is tasked with controlling the $6$-DOF pose of the right foot relative to the fixed left foot. The problem specifies a \"generic, non-singular stance\" and that the \"foot frames are distinct and non-coincident\". This ensures that the $12$-DOF chain is not in a singular configuration that would prevent it from generating an arbitrary $6$-DOF motion at its end-effector (the right foot).\nSince it is possible to move the right foot with full $6$-DOF motion while the left foot is stationary, the constraints on the right foot's velocity are independent of the constraints on the left foot's velocity. This implies that the row vectors of $\\mathbf{J}_{L}(q)$ are linearly independent from the row vectors of $\\mathbf{J}_{R}(q)$. The intersection of their row spaces contains only the zero vector.\n$$\n\\dim(\\mathcal{R}(\\mathbf{J}_{L}^T) \\cap \\mathcal{R}(\\mathbf{J}_{R}^T)) = 0\n$$\n\nTherefore, the rank of the combined Jacobian is the sum of the individual ranks:\n$$\n\\text{rank}(\\mathbf{J}_{c}(q)) = \\text{rank}(\\mathbf{J}_{L}(q)) + \\text{rank}(\\mathbf{J}_{R}(q)) = 6 + 6 = 12\n$$\n\nThe rank of the combined constraint Jacobian is $12$. This means that the double-support contact imposes $12$ independent holonomic constraints on the system. The reduction in the number of degrees of freedom is equal to this number. The number of DOFs of the constrained system is $N_{constrained} = N_{open} - \\text{rank}(\\mathbf{J}_{c}) = 36 - 12 = 24$.\nThe question asks for the reduction in the number of DOFs, which is $\\text{rank}(\\mathbf{J}_{c}(q))$.",
            "answer": "$$\n\\boxed{12}\n$$"
        },
        {
            "introduction": "The equations of motion describe accelerations at an instant, but to simulate movement over time, we must employ numerical integration. This coding exercise explores two fundamental methods, explicit and implicit Euler, revealing their profoundly different effects on a core physical principle: the conservation of energy . This hands-on simulation provides critical insight into the stability and physical plausibility of the dynamic simulations that are central to biomechanics.",
            "id": "4192970",
            "problem": "Consider a planar, uniform rigid pendulum segment that represents a single human limb segment (for example, a shank) rotating about a frictionless hinge under gravity without any actuation. Let the mass be $m$ in kilograms, the length be $L$ in meters, and the constant gravitational acceleration be $g = 9.81$ in meters per second squared. Let the generalized coordinate be the angle $\\theta$ in radians measured from the downward vertical, with positive counterclockwise rotation. The angular velocity is $\\dot{\\theta}$ in radians per second. Under these assumptions, Newton's second law for rotation and the absence of external driving torques lead to the ordinary differential equation (ODE)\n$$ m L^2 \\ddot{\\theta} = - m g L \\sin(\\theta), $$\nor equivalently\n$$ \\ddot{\\theta} = - \\frac{g}{L} \\sin(\\theta). $$\nThe total mechanical energy $E$ of the pendulum is the sum of kinetic energy and gravitational potential energy, given by\n$$ E(\\theta, \\dot{\\theta}) = \\tfrac{1}{2} m L^2 \\dot{\\theta}^2 + m g L (1 - \\cos(\\theta)). $$\nFor this passive, conservative system, the exact continuous-time dynamics conserve total mechanical energy, so any deviation from constant $E$ arises entirely from numerical time integration error.\n\nYour task is to implement two one-step numerical time integration schemes for the above ODE: an explicit forward Euler scheme and an implicit backward Euler scheme, both applied to the first-order state $[\\theta, \\dot{\\theta}]$. The explicit forward Euler scheme advances $[\\theta, \\dot{\\theta}]$ using the current state. The implicit backward Euler scheme computes the next state using the acceleration evaluated at the next state; this requires solving a scalar nonlinear equation for $\\theta$ at the new time step. Use Newton's method with a sensible initial guess to solve the implicit equation for $\\theta$ and then update $\\dot{\\theta}$ accordingly.\n\nDefine a simulated gait cycle duration $T_{\\mathrm{c}}$ as the small-angle linearized pendulum period\n$$ T_{\\mathrm{c}} = 2 \\pi \\sqrt{\\frac{L}{g}}, $$\nwhich is a scientifically standard approximation for near-small-amplitude passive swing and serves here as a consistent reference duration. For each simulation, advance the state for $N = \\lceil T_{\\mathrm{c}} / \\Delta t \\rceil$ time steps of size $\\Delta t$ seconds. Angles must be in radians, lengths in meters, masses in kilograms, and time in seconds.\n\nFor each scheme and test case, compute the following two quantitative measures of energy behavior over the simulated gait cycle:\n- The maximum relative energy deviation over the cycle,\n$$ \\varepsilon_{\\mathrm{max}} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|, $$\nwhere $E_k$ is the energy after $k$ steps and $E_0$ is the initial energy.\n- The signed end-of-cycle relative energy drift,\n$$ \\varepsilon_{\\mathrm{end}} = \\frac{E_N - E_0}{E_0}. $$\n\nImplement a runnable program that uses the following test suite. In all cases, use radians for angles and seconds for time:\n1. $m = 10.0$, $L = 1.0$, $\\theta_0 = 0.2$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.005$.\n2. $m = 50.0$, $L = 0.9$, $\\theta_0 = 1.0$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.02$.\n3. $m = 5.0$, $L = 1.2$, $\\theta_0 = 0.01$, $\\dot{\\theta}_0 = 0.0$, $\\Delta t = 0.0005$.\n4. $m = 70.0$, $L = 1.0$, $\\theta_0 = 0.6$, $\\dot{\\theta}_0 = 0.3$, $\\Delta t = 0.01$.\n\nYour program must, for each test case, simulate the pendulum over one reference gait cycle using both integrators, compute $\\varepsilon_{\\mathrm{max}}$ and $\\varepsilon_{\\mathrm{end}}$ for each scheme, and produce a single line of output containing the results as a comma-separated list of lists in the following order per test case:\n$[\\varepsilon_{\\mathrm{max}}^{\\mathrm{exp}}, \\varepsilon_{\\mathrm{max}}^{\\mathrm{imp}}, \\varepsilon_{\\mathrm{end}}^{\\mathrm{exp}}, \\varepsilon_{\\mathrm{end}}^{\\mathrm{imp}}]$.\nAll values must be decimal numbers rounded to six decimal places. The final printed output must be of the form\n$$ [ [a_1, b_1, c_1, d_1], [a_2, b_2, c_2, d_2], [a_3, b_3, c_3, d_3], [a_4, b_4, c_4, d_4] ] $$\nwith no additional text. Ensure numerical robustness of the implicit solver and scientific realism of all parameters and computations.",
            "solution": "The problem requires the implementation and comparison of two numerical integration schemes, explicit forward Euler and implicit backward Euler, for simulating the dynamics of a simple pendulum. The pendulum's motion is described by a second-order ordinary differential equation (ODE), which must first be converted into a system of two first-order ODEs for integration.\n\nThe state of the pendulum at any time $t$ can be described by a state vector $y(t) = [\\theta(t), \\omega(t)]^T$, where $\\theta(t)$ is the angle and $\\omega(t) = \\dot{\\theta}(t)$ is the angular velocity. The given second-order ODE is $\\ddot{\\theta} = - \\frac{g}{L} \\sin(\\theta)$. We can express this as a first-order system $\\dot{y} = f(y)$:\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} \\theta \\\\ \\omega \\end{pmatrix}\n=\n\\begin{pmatrix} \\omega \\\\ -\\frac{g}{L} \\sin(\\theta) \\end{pmatrix}\n= f(\\theta, \\omega)\n$$\nWe will numerically integrate this system from an initial state $y_0 = [\\theta_0, \\omega_0]^T$ over a series of time steps of size $\\Delta t$. Let $y_k = [\\theta_k, \\omega_k]^T$ denote the state at time $t_k = k \\Delta t$.\n\nThe explicit forward Euler method is a first-order, explicit integration scheme. It computes the state at the next time step, $y_{k+1}$, using the derivative evaluated at the current state, $y_k$. The update rule is:\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_k)\n$$\nIn component form, this translates to:\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_k\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_k)\n$$\nThis scheme is straightforward to implement as each new state variable is calculated directly from the previous state.\n\nThe implicit backward Euler method is a first-order, implicit integration scheme. It computes the state at the next time step, $y_{k+1}$, using the derivative evaluated at that same (unknown) future state, $y_{k+1}$. The update rule is:\n$$\ny_{k+1} = y_k + \\Delta t \\cdot f(y_{k+1})\n$$\nIn component form, this yields a system of coupled equations for the unknown state $[\\theta_{k+1}, \\omega_{k+1}]$:\n$$\n\\theta_{k+1} = \\theta_k + \\Delta t \\cdot \\omega_{k+1} \\quad (1)\n$$\n$$\n\\omega_{k+1} = \\omega_k - \\Delta t \\cdot \\frac{g}{L} \\sin(\\theta_{k+1}) \\quad (2)\n$$\nTo solve this system, we can substitute for $\\omega_{k+1}$ to obtain a single nonlinear algebraic equation for $\\theta_{k+1}$. From equation $(1)$, we express $\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$. Substituting this into equation $(2)$ gives:\n$$\n\\frac{\\theta_{k+1} - \\theta_k}{\\Delta t} = \\omega_k - \\frac{g \\Delta t}{L} \\sin(\\theta_{k+1})\n$$\nRearranging this equation gives a root-finding problem for $\\theta_{k+1}$. Let $\\theta_{\\text{new}} \\equiv \\theta_{k+1}$. We must find the root of the function $F(\\theta_{\\text{new}})$:\n$$\nF(\\theta_{\\text{new}}) = \\theta_{\\text{new}} - \\theta_k - \\Delta t \\cdot \\omega_k + \\frac{g (\\Delta t)^2}{L} \\sin(\\theta_{\\text{new}}) = 0\n$$\nAs specified, we use Newton's method to solve this equation. The iterative update for a variable $z$ is $z_{j+1} = z_j - F(z_j)/F'(z_j)$. The derivative of $F$ with respect to $\\theta_{\\text{new}}$ is:\n$$\nF'(\\theta_{\\text{new}}) = 1 + \\frac{g (\\Delta t)^2}{L} \\cos(\\theta_{\\text{new}})\n$$\nA sensible initial guess for the iteration is the result from an explicit Euler step, $z_0 = \\theta_k + \\Delta t \\cdot \\omega_k$. The iteration proceeds until the change between successive estimates of $\\theta_{\\text{new}}$ is below a small tolerance. Once a converged value for $\\theta_{k+1}$ is found, $\\omega_{k+1}$ is computed algebraically from equation $(1)$: $\\omega_{k+1} = (\\theta_{k+1} - \\theta_k) / \\Delta t$.\n\nFor each test case, the simulation runs for a duration defined by the linearized small-angle pendulum period, $T_c = 2 \\pi \\sqrt{L/g}$. The number of steps is $N = \\lceil T_c / \\Delta t \\rceil$. The state is advanced for $N$ steps, from $k=0$ to $k=N$.\n\nAt each step $k$ of the simulation for both schemes, the total mechanical energy is calculated using the formula:\n$$\nE_k = \\frac{1}{2} m L^2 \\omega_k^2 + m g L (1 - \\cos(\\theta_k))\n$$\nThe initial energy is $E_0 = E(\\theta_0, \\dot{\\theta}_0)$. Two metrics are computed over the simulation trajectory $(k=0, 1, \\dots, N)$:\n1. The maximum relative energy deviation, $\\varepsilon_{\\text{max}} = \\max_{0 \\le k \\le N} \\left| \\frac{E_k - E_0}{E_0} \\right|$. This metric captures the largest fluctuation in energy, regardless of sign.\n2. The signed end-of-cycle relative energy drift, $\\varepsilon_{\\text{end}} = \\frac{E_N - E_0}{E_0}$. This metric measures the net energy gain or loss after one full reference cycle. A positive value indicates energy gain (typical of explicit Euler), while a negative value indicates energy dissipation (typical of implicit Euler).\n\nThese calculations are performed for each test case provided, and the results are aggregated and formatted as specified. A small numerical tolerance (e.g., $10^{-14}$) and a maximum iteration count (e.g., $20$) are used for Newton's method to ensure robustness and prevent infinite loops. The case where $E_0 = 0$ must be handled to avoid division by zero, but given the test cases, $E_0$ is always positive.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the pendulum dynamics problem for all test cases.\n    \"\"\"\n    g = 9.81  # Gravitational acceleration in m/s^2\n\n    test_cases = [\n        # (m, L, theta0, omega0, dt)\n        (10.0, 1.0, 0.2, 0.0, 0.005),\n        (50.0, 0.9, 1.0, 0.0, 0.02),\n        (5.0, 1.2, 0.01, 0.0, 0.0005),\n        (70.0, 1.0, 0.6, 0.3, 0.01),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        m, L, theta0, omega0, dt = case\n        results = run_simulation(m, L, theta0, omega0, dt, g)\n        all_results.append([f\"{val:.6f}\" for val in results])\n\n    # Format the final output string exactly as required.\n    formatted_results = \", \".join([f\"[{', '.join(res)}]\" for res in all_results])\n    print(f\"[{formatted_results}]\")\n\ndef calculate_energy(m, L, g, theta, omega):\n    \"\"\"\n    Calculates the total mechanical energy of the pendulum.\n    \"\"\"\n    kinetic = 0.5 * m * (L**2) * (omega**2)\n    potential = m * g * L * (1.0 - np.cos(theta))\n    return kinetic + potential\n\ndef forward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the explicit forward Euler method.\n    \"\"\"\n    theta_kp1 = theta_k + dt * omega_k\n    omega_kp1 = omega_k - dt * (g / L) * np.sin(theta_k)\n    return theta_kp1, omega_kp1\n\ndef backward_euler_step(theta_k, omega_k, L, g, dt):\n    \"\"\"\n    Performs one step of the implicit backward Euler method using Newton's method.\n    \"\"\"\n    # Initial guess for theta_{k+1} using a forward Euler prediction\n    theta_new = theta_k + dt * omega_k\n    \n    # Newton's method to solve for theta_{k+1}\n    max_iter = 20\n    tolerance = 1e-14\n    \n    for _ in range(max_iter):\n        # F(theta_new) = theta_new - theta_k - dt*omega_k + (g*dt^2/L)*sin(theta_new) = 0\n        f_val = theta_new - theta_k - dt * omega_k + (g * dt**2 / L) * np.sin(theta_new)\n        \n        # F'(theta_new) = 1 + (g*dt^2/L)*cos(theta_new)\n        f_deriv = 1.0 + (g * dt**2 / L) * np.cos(theta_new)\n        \n        delta_theta = f_val / f_deriv\n        theta_new -= delta_theta\n        \n        if abs(delta_theta)  tolerance:\n            break\n            \n    theta_kp1 = theta_new\n    # Update omega_{k+1} from the discretized position update equation\n    omega_kp1 = (theta_kp1 - theta_k) / dt\n    \n    return theta_kp1, omega_kp1\n\ndef run_simulation(m, L, theta0, omega0, dt, g):\n    \"\"\"\n    Runs the simulation for a single test case using both integration schemes.\n    \"\"\"\n    # Simulation duration setup\n    Tc = 2.0 * np.pi * np.sqrt(L / g)\n    N = int(np.ceil(Tc / dt))\n\n    # Initial conditions\n    E0 = calculate_energy(m, L, g, theta0, omega0)\n    \n    # Run Explicit Euler Simulation\n    exp_states = np.zeros((N + 1, 2))\n    exp_states[0] = [theta0, omega0]\n    exp_energies = np.zeros(N + 1)\n    exp_energies[0] = E0\n    \n    for k in range(N):\n        theta_k, omega_k = exp_states[k]\n        theta_kp1, omega_kp1 = forward_euler_step(theta_k, omega_k, L, g, dt)\n        exp_states[k+1] = [theta_kp1, omega_kp1]\n        exp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n\n    # Run Implicit Euler Simulation\n    imp_states = np.zeros((N + 1, 2))\n    imp_states[0] = [theta0, omega0]\n    imp_energies = np.zeros(N + 1)\n    imp_energies[0] = E0\n\n    for k in range(N):\n        theta_k, omega_k = imp_states[k]\n        theta_kp1, omega_kp1 = backward_euler_step(theta_k, omega_k, L, g, dt)\n        imp_states[k+1] = [theta_kp1, omega_kp1]\n        imp_energies[k+1] = calculate_energy(m, L, g, theta_kp1, omega_kp1)\n        \n    # Handle the case E0 = 0 to avoid division by zero\n    if E0 == 0:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # Calculate metrics for explicit scheme\n    rel_err_exp = np.abs((exp_energies - E0) / E0)\n    eps_max_exp = np.max(rel_err_exp)\n    eps_end_exp = (exp_energies[-1] - E0) / E0\n\n    # Calculate metrics for implicit scheme\n    rel_err_imp = np.abs((imp_energies - E0) / E0)\n    eps_max_imp = np.max(rel_err_imp)\n    eps_end_imp = (imp_energies[-1] - E0) / E0\n    \n    return [eps_max_exp, eps_max_imp, eps_end_exp, eps_end_imp]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}