{
    "hands_on_practices": [
        {
            "introduction": "在有限元分析中，像压力这样的分布式物理载荷必须被转换成作用于模型节点的离散力。本练习就这一转换提供了基础性实践，它应用虚功原理来为一个均布载荷的三角形单元计算其等效节点力向量。掌握这项技术对于在任何生物力学模型中准确表示如流体压力或接触力等表面载荷至关重要。",
            "id": "4162011",
            "problem": "一个髋臼软骨块的三维生物力学有限元(FE)模型包含一个三角形的边界面，在该边界面上施加均匀的压缩压力以模拟滑液载荷。该三角形表面单元是线性的（三节点），位于实体边界上，其全局节点坐标以米为单位如下：节点 $1$ 位于 $(0, 0, 0)$，节点 $2$ 位于 $(0.04, 0, 0)$，节点 $3$ 位于 $(0, 0.03, 0.02)$。表面的外向单位法向量由与节点顺序 $(1 \\rightarrow 2 \\rightarrow 3)$ 一致的右手定则定义，即与从节点 $1$ 到节点 $2$ 的边向量和从节点 $1$ 到节点 $3$ 的边向量的叉积成正比，然后进行归一化。\n\n一个大小为 $p = 60\\,\\text{kPa}$ 的均匀压缩压力向内作用于表面（即，面力向量与外向单位法向量方向相反）。使用虚功原理和有限元法（FEM）中用于表面面力的协调载荷向量积分方法，通过在单元面积上对由线性三角形形函数加权的面力进行积分，计算此三角形表面单元的等效全局节点力向量。\n\n假设表面上使用标准的线性三角形形函数，并将最终的堆叠节点力向量表示为 $(f_{1x}, f_{1y}, f_{1z}, f_{2x}, f_{2y}, f_{2z}, f_{3x}, f_{3y}, f_{3z})$，单位为牛顿。如果您的结果需要近似，请将分量四舍五入到四位有效数字。否则，请给出精确值。最终答案必须以单行矩阵的形式给出。",
            "solution": "首先对问题进行验证，以确保其具有科学依据、提法恰当，并提供了所有必要的信息。\n\n**步骤 1：提取已知条件**\n- 单元类型：$3$节点线性三角形表面单元。\n- 全局节点坐标（米）：\n  - 节点 $1$：$P_1 = (0, 0, 0)$\n  - 节点 $2$：$P_2 = (0.04, 0, 0)$\n  - 节点 $3$：$P_3 = (0, 0.03, 0.02)$\n- 外向单位法向量：由从节点 $1$到 $2$ 和从节点 $1$ 到 $3$ 的边向量的叉积定义，与序列 $(1 \\rightarrow 2 \\rightarrow 3)$ 的右手定则一致。\n- 载荷：均匀压缩压力 $p = 60\\,\\text{kPa}$。\n- 面力：面力向量 $\\vec{t}$ 向内作用，因此 $\\vec{t} = -p\\vec{n}$，其中 $\\vec{n}$ 是外向单位法向量。\n- 方法：通过对由形函数加权的面力进行积分，计算协调节点力向量。\n- 输出：一个 $9 \\times 1$ 的堆叠节点力向量 $(f_{1x}, f_{1y}, f_{1z}, f_{2x}, f_{2y}, f_{2z}, f_{3x}, f_{3y}, f_{3z})$，单位为牛顿。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，基于应用于生物力学领域的有限元法（FEM）的标准原理。给定的数据（节点坐标、压力）在物理上是合理的，在数学上是一致的。问题提法恰当，具有足够的信息来确定唯一解。语言客观、精确。因此，该问题被认为是有效的。\n\n**步骤 3：求解过程**\n\n对于承受面力场 $\\vec{t}$ 的表面单元，其等效节点力向量 $\\vec{f}$ 由虚功原理给出：\n$$\n\\vec{f} = \\int_A \\mathbf{N}^T \\vec{t} \\, dA\n$$\n其中 $A$ 是单元的面积，$\\mathbf{N}$ 是形函数矩阵。对于三维空间中的一个 $3$ 节点单元，形函数矩阵为：\n$$\n\\mathbf{N} = \\begin{bmatrix} N_1  0  0  N_2  0  0  N_3  0  0 \\\\ 0  N_1  0  0  N_2  0  0  N_3  0 \\\\ 0  0  N_1  0  0  N_2  0  0  N_3 \\end{bmatrix}\n$$\n$N_1$、$N_2$ 和 $N_3$ 是节点 $1$、$2$ 和 $3$ 的标量线性形函数。面力向量 $\\vec{t}$ 在整个表面上是均匀（恒定）的。因此，可以将其从积分中提出：\n$$\n\\vec{f} = \\left( \\int_A \\mathbf{N}^T \\, dA \\right) \\vec{t}\n$$\n转置形函数矩阵的积分计算结果为：\n$$\n\\int_A \\mathbf{N}^T \\, dA = \\int_A \\begin{bmatrix} N_1 \\mathbf{I} \\\\ N_2 \\mathbf{I} \\\\ N_3 \\mathbf{I} \\end{bmatrix} dA = \\begin{bmatrix} (\\int_A N_1 dA) \\mathbf{I} \\\\ (\\int_A N_2 dA) \\mathbf{I} \\\\ (\\int_A N_3 dA) \\mathbf{I} \\end{bmatrix}\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 的单位矩阵。线性三角形形函数的一个基本性质是，任何形函数 $N_i$ 在单元面积 $A$ 上的积分都是 $\\frac{A}{3}$。\n$$\n\\int_A N_i \\, dA = \\frac{A}{3} \\quad \\text{for } i=1, 2, 3\n$$\n这意味着作用在单元上的总力 $\\vec{F}_{\\text{total}} = \\vec{t}A$ 在三个节点之间平均分配。每个节点 $i$ 上的力向量为：\n$$\n\\vec{f}_i = \\frac{A}{3}\\vec{t} = \\frac{1}{3} \\vec{F}_{\\text{total}}\n$$\n为了求得节点力，我们必须首先计算总力向量 $\\vec{F}_{\\text{total}}$。这需要计算单元的面积 $A$ 和面力向量 $\\vec{t}$。\n\n**A. 计算几何属性（面积和法向量）**\n\n首先，定义从节点 $1$ 出发的边向量：\n$$\n\\vec{v}_{12} = P_2 - P_1 = (0.04-0, 0-0, 0-0) = (0.04, 0, 0) \\, \\text{m}\n$$\n$$\n\\vec{v}_{13} = P_3 - P_1 = (0-0, 0.03-0, 0.02-0) = (0, 0.03, 0.02) \\, \\text{m}\n$$\n与序列 $(1 \\rightarrow 2 \\rightarrow 3)$ 的右手定则一致的表面法向量，与叉积 $\\vec{v}_{12} \\times \\vec{v}_{13}$ 成正比：\n$$\n\\vec{N}_{\\text{un-norm}} = \\vec{v}_{12} \\times \\vec{v}_{13} = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ 0.04  0  0 \\\\ 0  0.03  0.02 \\end{vmatrix}\n$$\n$$\n\\vec{N}_{\\text{un-norm}} = \\mathbf{i}(0 \\cdot 0.02 - 0 \\cdot 0.03) - \\mathbf{j}(0.04 \\cdot 0.02 - 0 \\cdot 0) + \\mathbf{k}(0.04 \\cdot 0.03 - 0 \\cdot 0)\n$$\n$$\n\\vec{N}_{\\text{un-norm}} = (0, -0.0008, 0.0012) \\, \\text{m}^2\n$$\n三角形的面积 $A$ 是该叉积向量大小的一半：\n$$\nA = \\frac{1}{2} |\\vec{N}_{\\text{un-norm}}| = \\frac{1}{2} \\sqrt{0^2 + (-0.0008)^2 + (0.0012)^2}\n$$\n$$\nA = \\frac{1}{2} \\sqrt{6.4 \\times 10^{-7} + 1.44 \\times 10^{-6}} = \\frac{1}{2} \\sqrt{2.08 \\times 10^{-6}} = \\frac{\\sqrt{208 \\times 10^{-8}}}{2} = \\frac{10^{-4}\\sqrt{16 \\times 13}}{2} = \\frac{4\\sqrt{13} \\times 10^{-4}}{2}\n$$\n$$\nA = 2\\sqrt{13} \\times 10^{-4} \\, \\text{m}^2\n$$\n外向单位法向量 $\\vec{n}$ 通过对 $\\vec{N}_{\\text{un-norm}}$ 进行归一化得到：\n$$\n\\vec{n} = \\frac{\\vec{N}_{\\text{un-norm}}}{|\\vec{N}_{\\text{un-norm}}|} = \\frac{(0, -0.0008, 0.0012)}{2A} = \\frac{(0, -0.0008, 0.0012)}{4\\sqrt{13} \\times 10^{-4}} = \\frac{10^{-4}(0, -8, 12)}{4\\sqrt{13} \\times 10^{-4}} = \\frac{1}{\\sqrt{13}}(0, -2, 3)\n$$\n\n**B. 计算总力**\n\n施加的压力为 $p = 60\\,\\text{kPa} = 60 \\times 10^3 \\, \\text{N/m}^2$。压力是压缩性的，因此面力向量 $\\vec{t}$ 向内作用，与外向单位法向量 $\\vec{n}$ 方向相反：\n$$\n\\vec{t} = -p\\vec{n} = -(60 \\times 10^3) \\frac{1}{\\sqrt{13}}(0, -2, 3) = \\frac{60 \\times 10^3}{\\sqrt{13}}(0, 2, -3) \\, \\text{N/m}^2\n$$\n作用在单元上的总力向量为 $\\vec{F}_{\\text{total}} = A \\times \\vec{t}$：\n$$\n\\vec{F}_{\\text{total}} = (2\\sqrt{13} \\times 10^{-4}) \\times \\left( \\frac{60 \\times 10^3}{\\sqrt{13}}(0, 2, -3) \\right) \\, \\text{N}\n$$\n$\\sqrt{13}$ 项相互抵消：\n$$\n\\vec{F}_{\\text{total}} = (2 \\times 10^{-4}) \\times (60 \\times 10^3) \\times (0, 2, -3) \\, \\text{N}\n$$\n$$\n\\vec{F}_{\\text{total}} = (120 \\times 10^{-1}) \\times (0, 2, -3) \\, \\text{N} = 12 \\times (0, 2, -3) \\, \\text{N}\n$$\n$$\n\\vec{F}_{\\text{total}} = (0, 24, -36) \\, \\text{N}\n$$\n\n**C. 将力分配到节点**\n\n总力在三个节点之间平均分配：\n$$\n\\vec{f}_1 = \\vec{f}_2 = \\vec{f}_3 = \\frac{1}{3} \\vec{F}_{\\text{total}} = \\frac{1}{3}(0, 24, -36) \\, \\text{N} = (0, 8, -12) \\, \\text{N}\n$$\n每个节点力向量的分量为 $(f_{ix}, f_{iy}, f_{iz})$：\n- 节点 $1$ 处的力：$(f_{1x}, f_{1y}, f_{1z}) = (0, 8, -12) \\, \\text{N}$\n- 节点 $2$ 处的力：$(f_{2x}, f_{2y}, f_{2z}) = (0, 8, -12) \\, \\text{N}$\n- 节点 $3$ 处的力：$(f_{3x}, f_{3y}, f_{3z}) = (0, 8, -12) \\, \\text{N}$\n\n最终组装的全局节点力向量是这三个向量的串联。分量是精确的整数，因此无需四舍五入。\n$$\n\\vec{f} = (0, 8, -12, 0, 8, -12, 0, 8, -12)\n$$",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0  8  -12  0  8  -12  0  8  -12 \\end{pmatrix}}\n$$"
        },
        {
            "introduction": "在有限元建模中，一个常见的挑战是创建一个能够唯一求解的稳定系统。本实践深入探讨了刚体运动的概念，在没有足够约束的情况下，刚体运动会导致刚度矩阵奇异。你将通过编程识别这些运动模式，并施加稳定模型所需的最小边界条件集合，这是进行任何有效的静态或动态分析的关键技能。",
            "id": "4161989",
            "problem": "考虑通过有限元 (FE) 分析建模的软生物组织的小应变线性弹性。全局刚度矩阵源于虚功原理，对于线性材料，该原理指出其弱形式可导出一个离散系统 $K u = f$，其中 $K$ 是由单元贡献组装而成的全局刚度矩阵，$u$ 是全局位移向量，$f$ 是全局载荷向量。在没有狄利克雷约束（本质边界条件）的情况下，系统是约束不足的，并且由于刚体运动，$K$ 是奇异的。\n\n您必须根据标准线性弹性理论，通过组装单元刚度来构建刚度矩阵。使用以下基本关系：\n\n- 对于二维 (2D) 平面应力问题中的各向同性材料，其本构矩阵为\n$$\nD = \\frac{E}{1-\\nu^2} \\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n其中 $E$ 是以帕斯卡为单位的杨氏模量，$\\nu$ 是泊松比。对于节点坐标为 $(x_i,y_i)$（$i=1,2,3$）的常应变三角形，其应变-位移矩阵 $B$ 是一个常数，由下式给出\n$$\nB = \\frac{1}{2A}\n\\begin{bmatrix}\ny_2 - y_3  0  y_3 - y_1  0  y_1 - y_2  0 \\\\\n0  x_3 - x_2  0  x_1 - x_3  0  x_2 - x_1 \\\\\nx_3 - x_2  y_2 - y_3  x_1 - x_3  y_3 - y_1  x_2 - x_1  y_1 - y_2\n\\end{bmatrix},\n$$\n其中三角形面积为\n$$\nA = \\frac{1}{2} \\left| \\det \\begin{bmatrix} 1  x_1  y_1 \\\\ 1  x_2  y_2 \\\\ 1  x_3  y_3 \\end{bmatrix} \\right|.\n$$\n对于厚度为 $t$ 米的单元，其单元刚度为\n$$\nk_e = t \\, A \\, B^\\top D B.\n$$\n\n- 对于三维 (3D) 各向同性线性弹性，定义拉梅参数\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad G = \\frac{E}{2(1+\\nu)},\n$$\n以及本构矩阵\n$$\nC =\n\\begin{bmatrix}\n\\lambda+2G  \\lambda  \\lambda  0  0  0 \\\\\n\\lambda  \\lambda+2G  \\lambda  0  0  0 \\\\\n\\lambda  \\lambda  \\lambda+2G  0  0  0 \\\\\n0  0  0  G  0  0 \\\\\n0  0  0  0  G  0 \\\\\n0  0  0  0  0  G\n\\end{bmatrix}.\n$$\n对于节点坐标为 $(x_i,y_i,z_i)$（$i=1,2,3,4$）的线性四面体单元，定义矩阵\n$$\nM = \\begin{bmatrix}\n1  x_1  y_1  z_1 \\\\\n1  x_2  y_2  z_2 \\\\\n1  x_3  y_3  z_3 \\\\\n1  x_4  y_4  z_4\n\\end{bmatrix}, \\quad C_M = M^{-1}.\n$$\n节点 $j$ 的形函数为 $N_j(x,y,z) = C_{M,0j} + C_{M,1j} x + C_{M,2j} y + C_{M,3j} z$，其梯度为 $\\nabla N_j = \\begin{bmatrix} C_{M,1j}  C_{M,2j}  C_{M,3j} \\end{bmatrix}^\\top$。应变-位移矩阵 $B$ 是一个常数，由 $\\nabla N_j$ 按照 Voigt 序 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\varepsilon_{zz}, \\gamma_{xy}, \\gamma_{yz}, \\gamma_{zx})$ 组装而成，如下所示：\n$$\nB = \\begin{bmatrix}\n\\partial_x N_1  0  0  \\partial_x N_2  0  0  \\partial_x N_3  0  0  \\partial_x N_4  0  0 \\\\\n0  \\partial_y N_1  0  0  \\partial_y N_2  0  0  \\partial_y N_3  0  0  \\partial_y N_4  0 \\\\\n0  0  \\partial_z N_1  0  0  \\partial_z N_2  0  0  \\partial_z N_3  0  0  \\partial_z N_4 \\\\\n\\partial_y N_1  \\partial_x N_1  0  \\partial_y N_2  \\partial_x N_2  0  \\partial_y N_3  \\partial_x N_3  0  \\partial_y N_4  \\partial_x N_4  0 \\\\\n0  \\partial_z N_1  \\partial_y N_1  0  \\partial_z N_2  \\partial_y N_2  0  \\partial_z N_3  \\partial_y N_3  0  \\partial_z N_4  \\partial_y N_4 \\\\\n\\partial_z N_1  0  \\partial_x N_1  \\partial_z N_2  0  \\partial_x N_2  \\partial_z N_3  0  \\partial_x N_3  \\partial_z N_4  0  \\partial_x N_4\n\\end{bmatrix}.\n$$\n设单元体积为\n$$\nV = \\frac{1}{6} \\left| \\det \\begin{bmatrix}\nx_2-x_1  x_3-x_1  x_4-x_1 \\\\\ny_2-y_1  y_3-y_1  y_4-y_1 \\\\\nz_2-z_1  z_3-z_1  z_4-z_1\n\\end{bmatrix} \\right|.\n$$\n则单元刚度为\n$$\nk_e = V \\, B^\\top C B.\n$$\n\n全局刚度矩阵 $K$ 是通过将各单元的贡献累加到相应的全局自由度上组装而成的。\n\n在没有本质边界条件的情况下，刚体运动构成了 $K$ 的零空间。对于节点坐标为 $\\{r_i\\}$ 的网格，按如下方式构建刚体位移基 $R$：\n\n- 在 $2\\text{D}$ (二维) 中，使用三列：\n$$\nt_x = \\begin{bmatrix} 1 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\cdots \\end{bmatrix}, \\quad\nt_y = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 1 \\\\ \\cdots \\end{bmatrix}, \\quad\nr_z = \\begin{bmatrix} -y_1 \\\\ x_1 \\\\ -y_2 \\\\ x_2 \\\\ \\cdots \\end{bmatrix}.\n$$\n\n- 在 $3\\text{D}$ (三维) 中，使用六列：\n$$\nt_x, \\ t_y, \\ t_z \\text{ 其中 } t_x = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ \\cdots \\end{bmatrix}, \\ t_y = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\cdots \\end{bmatrix}, \\ t_z = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ \\cdots \\end{bmatrix},\n$$\n以及绕坐标轴的旋转，这些旋转通过 $v_i = \\omega \\times r_i$ 获得，其中 $\\omega$ 是与笛卡尔坐标轴对齐的单位向量，即，\n$$\nr_x: v_i = \\begin{bmatrix} 0 \\\\ -z_i \\\\ y_i \\end{bmatrix}, \\quad\nr_y: v_i = \\begin{bmatrix} z_i \\\\ 0 \\\\ -x_i \\end{bmatrix}, \\quad\nr_z: v_i = \\begin{bmatrix} -y_i \\\\ x_i \\\\ 0 \\end{bmatrix}.\n$$\n\n您的任务是：\n1. 根据单元刚度 $k_e$ 为每个提供的测试网格组装全局刚度矩阵 $K$。\n2. 使用奇异值分解 (SVD) 计算 $K$ 的零空间维度。使用数值容差 $\\tau = \\alpha \\, \\sigma_{\\max} \\, n$，其中 $\\sigma_{\\max}$ 是 $K$ 的最大奇异值，$n$ 是 $\\max(n_{\\text{rows}}, n_{\\text{cols}})$，且 $\\alpha = 10^{-9}$。\n3. 根据上述定义构建刚体运动矩阵 $R$。\n4. 通过选择 $n_{\\text{rbm}}$ 个全局自由度（$R$ 的行）来确定一个最小狄利克雷约束集，使得 $R$ 限制在这些行上的子矩阵具有满列秩 $n_{\\text{rbm}}$。通过对 $R^\\top$ 进行列主元 $QR$ 分解来实现此选择，选取前 $n_{\\text{rbm}}$ 个主元索引作为约束自由度。\n5. 通过从 $K$ 中消除约束自由度来施加约束（即，形成与齐次本质边界条件下的非约束自由度相对应的缩减矩阵 $K_{ff}$）。\n6. 使用相同的基于 SVD 的容差计算 $K_{ff}$ 的零空间维度。\n\n请注意：\n- 所有物理量必须采用国际单位制 (SI)。杨氏模量 $E$ 的单位必须是帕斯卡，坐标单位是米，厚度 $t$ 的单位是米。\n- 没有需要单位的角度计算；刚体旋转由单位轴向量参数化，不使用显式的角度值。\n\n测试套件：\n为您的程序提供以下测试用例：\n\n- 用例 1（二维单三角形，平面应力）：$E = 5.0 \\times 10^4$ Pa, $\\nu = 0.45$, $t = 2.0 \\times 10^{-3}$ m, 节点 $\\{(0.0, 0.0), (1.0, 0.0), (0.0, 1.0)\\}$, 一个单元，连接关系为 $(0,1,2)$。\n\n- 用例 2（二维正方形，分裂为两个三角形，平面应力）：$E = 1.0 \\times 10^5$ Pa, $\\nu = 0.45$, $t = 2.0 \\times 10^{-3}$ m, 节点 $\\{(0.0, 0.0), (1.0, 0.0), (1.0, 1.0), (0.0, 1.0)\\}$, 单元为 $(0,1,2)$ 和 $(0,2,3)$。\n\n- 用例 3（三维单四面体）：$E = 1.0 \\times 10^5$ Pa, $\\nu = 0.45$, 节点 $\\{(0.0, 0.0, 0.0), (1.0, 0.0, 0.0), (0.0, 1.0, 0.0), (0.0, 0.0, 1.0)\\}$, 一个单元，连接关系为 $(0,1,2,3)$。\n\n答案规格：\n对于每个测试用例，输出一个列表，其中包含：\n- 施加约束前 $K$ 的整数零空间维度。\n- 施加所选最小约束后，缩减矩阵 $K_{ff}$ 的整数零空间维度。\n- 算法实际选择的约束全局自由度索引（整数）列表，按升序排列。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的结果，格式为方括号括起来的逗号分隔列表，每个测试用例表示为 $[d_{\\text{before}}, d_{\\text{after}}, [i_1, i_2, \\dots]]$。例如：$[[3,0,[0,1,3]], [3,0,[0,1,4]], [6,0,[0,1,2,3,4,5]]]$。数值输出是无单位的整数和索引列表。",
            "solution": "用户的请求是验证并解决一个来自计算生物力学领域的问题，具体涉及线性弹性材料的有限元 (FE) 分析。这需要组装全局刚度矩阵，分析其性质，并施加约束以确保存在唯一解。该问题被认为是有效的，因为它科学地基于连续介质力学和有限元法的原理，问题设定良好，指令清晰完整，并使用标准的、可验证的数学公式。\n\n解决方案通过逐步实现指定任务来推进，其基于以下原则。\n\n1.  **有限元公式和单元刚度**\n\n线性静力分析的有限元方法的基础是虚功原理，当其被离散化后，会得到线性系统 $K u = f$。在此系统中，$K$ 代表全局刚度矩阵，$u$ 是未知的节点位移向量，$f$ 是施加的节点力向量。全局刚度矩阵 $K$ 是通过组装各个单元刚度矩阵 $k_e$ 来构建的。\n\n对于占据体积 $V_e$ 的单元，其刚度矩阵由以下积分给出：\n$$\nk_e = \\int_{V_e} B^\\top D B \\, dV\n$$\n其中 $B$ 是应变-位移矩阵，$D$ 是材料本构矩阵（在 3D 中也表示为 $C$）。\n\n对于指定的简单单元类型——2D 中的常应变三角形 (CST) 和 3D 中的线性四面体——矩阵 $B$ 在每个单元内部是恒定的。这将积分简化为乘法：对于面积为 $A$、厚度为 $t$ 的 2D 单元，$k_e = (A \\cdot t) B^\\top D B$；对于体积为 $V$ 的 3D 单元，$k_e = V B^\\top C B$。\n\n**对于 $2\\text{D}$ 平面应力：** 问题提供了各向同性材料在平面应力条件下的标准本构矩阵 $D$：\n$$\nD = \\frac{E}{1-\\nu^2} \\begin{bmatrix}\n1  \\nu  0 \\\\\n\\nu  1  0 \\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中 $E$ 是杨氏模量，$\\nu$ 是泊松比。问题也给出了 CST 单元的应变-位移矩阵 $B$，它由插值三角形内部位移的线性形函数导出。它将三个工程应变 $(\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})$ 与六个节点位移 $(u_{1x}, u_{1y}, u_{2x}, u_{2y}, u_{3x}, u_{3y})$ 联系起来。\n\n**对于 $3\\text{D}$ 弹性：** 各向同性材料的本构矩阵 $C$ 用拉梅参数 $\\lambda$ 和 $G$ 表示：\n$$\n\\lambda = \\frac{E \\nu}{(1+\\nu)(1-2\\nu)}, \\quad G = \\frac{E}{2(1+\\nu)}\n$$\n线性四面体单元的应变-位移矩阵 $B$ 是从其四个线性形函数 $N_j(x,y,z)$ 的梯度导出的。每个形函数 $N_j$ 是一个线性多项式，其系数由条件决定：$N_j$ 在节点 $j$ 处等于 1，在所有其他节点处等于 0。正如问题中所定义的，所有四个形函数的这些系数可以通过对一个由节点坐标构建的矩阵 $M$ 求逆来找到。矩阵 $B$ 将 Voigt 记法中的六个工程应变与四面体的 12 个节点位移联系起来。\n\n2.  **全局刚度矩阵的组装**\n\n整个网格的全局刚度矩阵 $K$ 是通过将所有单元刚度矩阵 $k_e$ 的贡献相加而形成的。这个过程通常称为组装，它涉及将每个单元的局部自由度 (DOF) 映射到其相应的全局自由度。对于一个有 $N_{nodes}$ 个节点且每个节点有 $d$ 个自由度（在 2D 中 $d=2$，在 3D 中 $d=3$）的系统，$K$ 的大小为 $(N_{nodes} \\cdot d) \\times (N_{nodes} \\cdot d)$。全局矩阵的一个条目 $K_{ij}$ 表示由于全局自由度 $j$ 处的单位位移而在全局自由度 $i$ 处产生的力。\n\n3.  **刚体模态与 $K$ 的奇异性**\n\n在没有任何规定的位移约束（狄利克雷边界条件）的情况下，结构可以作为刚体自由平移和旋转。这些运动被称为刚体模态 (RBMs)，它们不引起变形，因此不产生应变或应力。在数学上，如果 $u_{rbm}$ 是对应于刚体运动的位移向量，则产生的应变为零：$\\varepsilon = B u_{rbm} = 0$。因此，应变能也为零，乘积 $K u_{rbm}$ 是一个零向量。这意味着任何 $u_{rbm}$ 都是 $K$ 的零空间中的一个向量。一个具有非平凡零空间的矩阵是奇异的（即，其行列式为零，且不可逆）。\n\n在 2D 中，有 $n_{rbm}=3$ 个刚体模态：两个平移 ($t_x, t_y$) 和一个旋转 ($r_z$)。在 3D 中，有 $n_{rbm}=6$ 个：三个平移 ($t_x, t_y, t_z$) 和三个旋转 ($r_x, r_y, r_z$)。问题提供了零空间基的显式构造，构成了矩阵 $R$ 的列。对于一个无约束的、连通的物体，$K$ 的零空间维度等于 $n_{rbm}$。这可以通过使用奇异值分解 (SVD) 计算 $K$ 的数值秩来验证。接近于零（相对于定义的容差）的奇异值的数量给出了零空间的维度。\n\n4.  **施加约束以消除奇异性**\n\n为了获得位移向量 $u$ 的唯一解，必须消除 $K$ 的奇异性。这在物理上等同于固定物体以防止刚体运动。一个最小约束集涉及固定刚好足够的自由度 (DOF) 来抑制所有刚体模态 (RBMs)。所需的约束数量为 $n_{rbm}$。\n\n这些自由度的选择至关重要：它们必须共同约束所有的刚体模态。选择这些自由度的一个有效方法是分析刚体模态矩阵 $R$。$R$ 的行对应于全局自由度。为确保所有刚体模态（$R$ 的列）都受到约束，我们必须从 $R$ 中选择 $n_{rbm}$ 个线性无关的行。一种数值稳健的方法来识别这样一组行是对 $R$ 的转置（表示为 $R^\\top$）执行列主元 QR 分解。该算法贪婪地选择 $R^\\top$ 的列（也就是 $R$ 的行），这些列与先前选择的列最大程度地线性无关。算法选择的前 $n_{rbm}$ 个主元列的索引对应于一组适合约束的自由度。\n\n5.  **缩减系统的形成**\n\n一旦选定了约束自由度，我们通过将其位移设置为零来施加齐次狄利克雷边界条件。这对应于基于自由 ($f$) 和约束 ($c$) 自由度对全局系统 $K u = f$进行分区：\n$$\n\\begin{bmatrix} K_{ff}  K_{fc} \\\\ K_{cf}  K_{cc} \\end{bmatrix}\n\\begin{bmatrix} u_f \\\\ u_c \\end{bmatrix}\n=\n\\begin{bmatrix} f_f \\\\ f_c \\end{bmatrix}\n$$\n当 $u_c = 0$ 时，关于自由自由度的系统变为：\n$$\nK_{ff} u_f = f_f\n$$\n矩阵 $K_{ff}$ 是缩减刚度矩阵。如果约束成功消除了所有刚体模态，$K_{ff}$ 将是非奇异的（可逆的），并且系统对于 $u_f$ 将有唯一解。这可以通过再次计算 $K_{ff}$ 的 SVD 并检查其零空间维度是否为零来验证。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr, svd\n\ndef get_null_space_dim(matrix, alpha=1e-9):\n    \"\"\"\n    Computes the null space dimension of a matrix using SVD.\n    A singular value is considered zero if it's smaller than a tolerance.\n    \"\"\"\n    if matrix.size == 0:\n        return 0\n\n    m, n = matrix.shape\n    try:\n        singular_values = svd(matrix, compute_uv=False)\n    except np.linalg.LinAlgError:\n        # Handle cases where SVD does not converge\n        return n # Assume full rank deficiency if SVD fails\n\n    sigma_max = singular_values[0] if len(singular_values) > 0 else 0\n    if sigma_max == 0: # a zero matrix\n        return n\n        \n    tol = alpha * sigma_max * max(m, n)\n    null_dim = np.sum(singular_values < tol)\n    return int(null_dim)\n\ndef get_2d_cst_stiffness_matrix(nodes_coords, E, nu, t):\n    \"\"\"\n    Computes the stiffness matrix for a 2D Constant Strain Triangle (CST) element.\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = nodes_coords\n    \n    A_mat = np.array([[1, x1, y1], [1, x2, y2], [1, x3, y3]])\n    area = 0.5 * np.abs(np.linalg.det(A_mat))\n\n    # Strain-displacement matrix (B)\n    B = np.zeros((3, 6))\n    B[0, 0] = y2 - y3\n    B[0, 2] = y3 - y1\n    B[0, 4] = y1 - y2\n    B[1, 1] = x3 - x2\n    B[1, 3] = x1 - x3\n    B[1, 5] = x2 - x1\n    B[2, 0] = x3 - x2\n    B[2, 1] = y2 - y3\n    B[2, 2] = x1 - x3\n    B[2, 3] = y3 - y1\n    B[2, 4] = x2 - x1\n    B[2, 5] = y1 - y2\n    B /= (2 * area)\n\n    # Constitutive matrix (D) for plane stress\n    D_factor = E / (1 - nu**2)\n    D = D_factor * np.array([\n        [1, nu, 0],\n        [nu, 1, 0],\n        [0, 0, (1 - nu) / 2]\n    ])\n\n    # Element stiffness matrix (ke)\n    ke = t * area * (B.T @ D @ B)\n    return ke\n\ndef get_3d_tet_stiffness_matrix(nodes_coords, E, nu):\n    \"\"\"\n    Computes the stiffness matrix for a 3D linear tetrahedral element.\n    \"\"\"\n    lame_lambda = (E * nu) / ((1 + nu) * (1 - 2 * nu))\n    lame_G = E / (2 * (1 + nu))\n\n    C = np.array([\n        [lame_lambda + 2*lame_G, lame_lambda, lame_lambda, 0, 0, 0],\n        [lame_lambda, lame_lambda + 2*lame_G, lame_lambda, 0, 0, 0],\n        [lame_lambda, lame_lambda, lame_lambda + 2*lame_G, 0, 0, 0],\n        [0, 0, 0, lame_G, 0, 0],\n        [0, 0, 0, 0, lame_G, 0],\n        [0, 0, 0, 0, 0, lame_G]\n    ])\n\n    M = np.ones((4, 4))\n    M[:, 1:] = nodes_coords\n    C_M = np.linalg.inv(M)\n    \n    grads = C_M[1:, :]\n\n    B = np.zeros((6, 12))\n    for i in range(4):\n        dNx_i, dNy_i, dNz_i = grads[0, i], grads[1, i], grads[2, i]\n        \n        B[0, 3*i]     = dNx_i\n        B[1, 3*i + 1] = dNy_i\n        B[2, 3*i + 2] = dNz_i\n        B[3, 3*i]     = dNy_i\n        B[3, 3*i + 1] = dNx_i\n        B[4, 3*i + 1] = dNz_i\n        B[4, 3*i + 2] = dNy_i\n        B[5, 3*i]     = dNz_i\n        B[5, 3*i + 2] = dNx_i\n    \n    v_mat = np.array([\n        nodes_coords[1] - nodes_coords[0],\n        nodes_coords[2] - nodes_coords[0],\n        nodes_coords[3] - nodes_coords[0]\n    ])\n    volume = np.abs(np.linalg.det(v_mat)) / 6.0\n    \n    ke = volume * (B.T @ C @ B)\n    return ke\n\ndef assemble_global_stiffness(nodes, elements, E, nu, t, dim):\n    num_nodes = len(nodes)\n    num_dofs = num_nodes * dim\n    K = np.zeros((num_dofs, num_dofs))\n\n    for el_nodes in elements:\n        node_coords = np.array([nodes[i] for i in el_nodes])\n        if dim == 2:\n            ke = get_2d_cst_stiffness_matrix(node_coords, E, nu, t)\n            dofs_per_node = 2\n        else:\n            ke = get_3d_tet_stiffness_matrix(node_coords, E, nu)\n            dofs_per_node = 3\n        \n        dof_indices = []\n        for node_idx in el_nodes:\n            start_dof = node_idx * dofs_per_node\n            dof_indices.extend(range(start_dof, start_dof + dofs_per_node))\n        \n        ix = np.ix_(dof_indices, dof_indices)\n        K[ix] += ke\n    \n    return K\n\ndef get_rbm_matrix(nodes, dim):\n    num_nodes = len(nodes)\n    if dim == 2:\n        num_dofs = num_nodes * 2\n        num_rbm = 3\n        R = np.zeros((num_dofs, num_rbm))\n        R[0::2, 0] = 1\n        R[1::2, 1] = 1\n        for i, (x, y) in enumerate(nodes):\n            R[2*i, 2] = -y\n            R[2*i+1, 2] = x\n    else:\n        num_dofs = num_nodes * 3\n        num_rbm = 6\n        R = np.zeros((num_dofs, num_rbm))\n        R[0::3, 0] = 1 \n        R[1::3, 1] = 1\n        R[2::3, 2] = 1\n        for i, (x, y, z) in enumerate(nodes):\n            R[3*i+1, 3] = -z\n            R[3*i+2, 3] = y\n            R[3*i, 4] = z\n            R[3*i+2, 4] = -x\n            R[3*i, 5] = -y\n            R[3*i+1, 5] = x\n    return R\n\ndef solve():\n    test_cases = [\n        {\n            \"dim\": 2, \"E\": 5.0e4, \"nu\": 0.45, \"t\": 2.0e-3,\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0]]),\n            \"elements\": [[0, 1, 2]]\n        },\n        {\n            \"dim\": 2, \"E\": 1.0e5, \"nu\": 0.45, \"t\": 2.0e-3,\n            \"nodes\": np.array([[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]),\n            \"elements\": [[0, 1, 2], [0, 2, 3]]\n        },\n        {\n            \"dim\": 3, \"E\": 1.0e5, \"nu\": 0.45, \"t\": None,\n            \"nodes\": np.array([[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]]),\n            \"elements\": [[0, 1, 2, 3]]\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        dim, nodes, elements = case[\"dim\"], case[\"nodes\"], case[\"elements\"]\n        E, nu, t = case[\"E\"], case[\"nu\"], case[\"t\"]\n        \n        K = assemble_global_stiffness(nodes, elements, E, nu, t, dim)\n        d_before = get_null_space_dim(K)\n\n        R = get_rbm_matrix(nodes, dim)\n        num_rbm = R.shape[1]\n\n        _, _, p = qr(R.T, pivoting=True, check_finite=False)\n        constrained_dofs = sorted(p[:num_rbm])\n\n        num_dofs = K.shape[0]\n        free_dofs = np.setdiff1d(np.arange(num_dofs), constrained_dofs)\n        K_ff = K[np.ix_(free_dofs, free_dofs)]\n\n        d_after = get_null_space_dim(K_ff)\n\n        results.append([d_before, d_after, constrained_dofs])\n\n    formatted_results = [f\"[{res[0]},{res[1]},[{','.join(map(str, res[2]))}]]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "生物力学载荷，例如步态中的地面反作用力，具有内在的可变性。这个高级实践超越了确定性分析，探讨了如何利用概率论将这种不确定性融入模型。通过在线性有限元系统中传播不确定载荷的统计特性，你将学会计算关键输出量的置信区间，从而对模型预测提供更真实和稳健的评估。",
            "id": "4161973",
            "problem": "考虑一个关于人足的静态线性有限元法 (FEM) 模型。在施加了固定跟骨和相关后足自由度的本质 (狄利克雷) 边界条件后，得到的缩减刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 通过线性系统 $K u = f$ 将以毫米 (mm) 为单位的节点位移向量 $u \\in \\mathbb{R}^{n}$ 与以牛顿 (N) 为单位的地面反作用力 (GRF) 向量 $f \\in \\mathbb{R}^{n}$ 在准静态平衡下关联起来。由于步态变异性、接触条件变异性和测量噪声，地面反作用力 (GRF) 是不确定的，并被建模为一个多元正态随机向量 $f \\sim \\mathcal{N}(\\mu_f, \\Sigma_f)$，其中 $\\mu_f$ 是平均力向量，$\\Sigma_f$ 是力协方差矩阵，该矩阵编码了边界节点和方向间的互相关性。\n\n您的任务是将边界载荷不确定性从 $f$ 通过缩减的 FEM 系统传播到位移 $u$，然后计算指定位移分量 $u_j$ 的双侧 $95$ 置信区间（单位为毫米 mm）。请使用从基本原理出发的推导：静态平衡、线弹性以及随机变量线性变换的性质。不要引入任何未经这些原理论证的外部经验性捷径或预先推导的传播公式。\n\n物理单位必须遵循如下规定：$K$ 的单位是 N/mm，$f$ 的单位是 N，$u$ 的单位是 mm。所有最终的置信区间界限均以毫米 (mm) 表示，并四舍五入到三位小数。角度（如果有）不涉及此问题。不要使用百分号；置信水平 $95$ 应被视为源自标准正态分位数的十进制置信度规范。\n\n请实现一个程序，为下面提供的每个测试用例计算指定位移分量 $u_j$ 的双侧 $95$ 置信区间的下界和上界（单位为 mm）。该测试套件涵盖了典型情况、确定性载荷情景以及一个具有奇异（但为半正定）载荷协方差的案例，以测试在约束不确定性下的鲁棒性。\n\n测试套件：\n1. 案例 A (理想情况，三自由度)：\n   - 缩减刚度矩阵 $K_1$ (N/mm):\n     $$K_1 = \\begin{bmatrix}\n     8000  -1200  0 \\\\\n     -1200  9000  -1500 \\\\\n     0  -1500  7000\n     \\end{bmatrix}$$\n   - 平均 GRF 向量 $\\mu_{f1}$ (N):\n     $$\\mu_{f1} = \\begin{bmatrix} 120 \\\\ 100 \\\\ 80 \\end{bmatrix}$$\n   - GRF 协方差 $\\Sigma_{f1}$ ($\\text{N}^2$):\n     $$\\Sigma_{f1} = \\begin{bmatrix}\n     400  100  0 \\\\\n     100  300  50 \\\\\n     0  50  200\n     \\end{bmatrix}$$\n   - 位移分量索引 $j_1 = 1$ (从零开始的索引)。\n2. 案例 B (确定性载荷，二自由度)：\n   - 缩减刚度矩阵 $K_2$ (N/mm):\n     $$K_2 = \\begin{bmatrix}\n     10000  -2000 \\\\\n     -2000  8000\n     \\end{bmatrix}$$\n   - 平均 GRF 向量 $\\mu_{f2}$ (N):\n     $$\\mu_{f2} = \\begin{bmatrix} 200 \\\\ 200 \\end{bmatrix}$$\n   - GRF 协方差 $\\Sigma_{f2}$ ($\\text{N}^2$):\n     $$\\Sigma_{f2} = \\begin{bmatrix}\n     0  0 \\\\\n     0  0\n     \\end{bmatrix}$$\n   - 位移分量索引 $j_2 = 0$ (从零开始的索引)。\n3. 案例 C (奇异协方差，四自由度)：\n   - 缩减刚度矩阵 $K_3$ (N/mm):\n     $$K_3 = \\begin{bmatrix}\n     15000  -3000  0  0 \\\\\n     -3000  12000  -2500  0 \\\\\n     0  -2500  11000  -2000 \\\\\n     0  0  -2000  9000\n     \\end{bmatrix}$$\n   - 平均 GRF 向量 $\\mu_{f3}$ (N):\n     $$\\mu_{f3} = \\begin{bmatrix} 150 \\\\ 0 \\\\ 200 \\\\ 50 \\end{bmatrix}$$\n   - GRF 协方差 $\\Sigma_{f3}$ ($\\text{N}^2$):\n     $$\\Sigma_{f3} = \\begin{bmatrix}\n     0  0  0  0 \\\\\n     0  500  200  0 \\\\\n     0  200  600  0 \\\\\n     0  0  0  0\n     \\end{bmatrix}$$\n   - 位移分量索引 $j_3 = 2$ (从零开始的索引)。\n\n输出规范：\n- 对于每个案例，使用对应于中心覆盖率 $0.95$ 的标准正态分位数 $z$ 计算 $u_j$ 的双侧 $95$ 置信区间界限。将两个界限以毫米 (mm) 表示，并四舍五入到三位小数。\n- 您的程序应生成单行输出，包含三个案例的结果，形式为逗号分隔的子列表列表，每个子列表包含下界和上界。格式必须严格如下：\n  $$[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3]]$$\n其中 $\\ell_k$ 和 $u_k$ 分别是案例 $k$ 的下界和上界，格式化时无空格，并保留三位小数（单位为 mm）。",
            "solution": "我们从准静态生物力学中的静态平衡出发：节点上的净内力与施加的外部载荷相平衡。在小应变、均匀线性弹性本构行为和适当运动学约束的条件下，使用有限元法 (FEM) 对线性弹性连续体进行离散化，得到代数关系 $K u = f$。其中，$K \\in \\mathbb{R}^{n \\times n}$ 是施加本质 (狄利克雷) 边界条件后的缩减刚度矩阵，$u \\in \\mathbb{R}^{n}$ 是位移向量，$f \\in \\mathbb{R}^{n}$ 是外部节点力向量。单位保持一致：$[K] = \\text{N/mm}$，$[f] = \\text{N}$，$[u] = \\text{mm}$。\n\n由于步态变异性和接触条件变异性，地面反作用力 (GRF) $f$ 是不确定的。我们将其建模为一个多元正态随机向量：\n$$\nf \\sim \\mathcal{N}(\\mu_f, \\Sigma_f),\n$$\n其均值为 $\\mu_f$，协方差为 $\\Sigma_f$。求解确定性线性系统得到 $u = K^{-1} f$。因为 $u$ 是高斯随机向量 $f$ 的线性变换，所以 $u$ 也是高斯分布的。具体来说，如果 $f$ 是高斯分布的，而 $A$ 是一个确定性矩阵，那么 $A f$ 也是高斯分布的，其均值为 $A \\mu_f$，协方差为 $A \\Sigma_f A^\\top$。使用 $A = K^{-1}$，我们得到：\n$$\nu \\sim \\mathcal{N}(\\mu_u, \\Sigma_u), \\quad \\mu_u = K^{-1} \\mu_f, \\quad \\Sigma_u = K^{-1} \\Sigma_f K^{-\\top}.\n$$\n\n对于指定的位移分量索引 $j$，标量 $u_j$ 是一个单变量正态随机变量，其均值和方差由 $\\mu_u$ 和 $\\Sigma_u$ 的相应条目给出：\n$$\nu_j \\sim \\mathcal{N}\\big(\\mu_u^{(j)}, \\sigma_u^{2 (j)}\\big), \\quad \\text{其中 } \\mu_u^{(j)} = (\\mu_u)_j, \\; \\sigma_u^{2 (j)} = (\\Sigma_u)_{jj}.\n$$\n$u_j$ 的双侧 $95$ 置信区间是使用满足 $P(|Z| \\le z) = 0.95$ 的标准正态分位数 $z$（即 $z \\approx 1.959964$）构建的。该区间为：\n$$\n\\left[\\mu_u^{(j)} - z \\, \\sigma_u^{(j)}, \\; \\mu_u^{(j)} + z \\, \\sigma_u^{(j)}\\right],\n$$\n其中 $\\sigma_u^{(j)} = \\sqrt{(\\Sigma_u)_{jj}}$。在确定性情况下，$\\Sigma_f = 0$，因此 $\\Sigma_u = 0$，得到一个退化的区间，其上下界均等于 $\\mu_u^{(j)}$。\n\n每个测试用例的算法步骤：\n1. 读取 $K$、$\\mu_f$、$\\Sigma_f$ 和 $j$。\n2. 通过求解线性系统计算平均位移\n   $$\n   K \\, \\mu_u = \\mu_f \\quad \\Rightarrow \\quad \\mu_u = K^{-1} \\mu_f,\n   $$\n   使用线性求解器以避免显式矩阵求逆。\n3. 计算位移协方差矩阵 $\\Sigma_u = K^{-1} \\Sigma_f K^{-\\top}$。由于有限元刚度矩阵 $K$ 是对称的 ($K=K^T$)，其逆矩阵也是对称的，因此 $K^{-\\top} = (K^T)^{-1} = K^{-1}$。表达式可简化为 $\\Sigma_u = K^{-1} \\Sigma_f K^{-1}$。为了在数值计算中避免显式求逆，该过程可以通过两次求解线性系统来高效完成。代码中的实现通过求解 $K^T Y = \\Sigma_f^T$ 和 $K S = Y^T$ 来计算 $S = K^{-1} \\Sigma_f K^{-1}$，该结果等价于所求的 $\\Sigma_u$。\n4. 提取标量方差 $(\\Sigma_u)_{jj}$，取其平方根得到 $\\sigma_u^{(j)}$，并用 $z \\approx 1.959964$ 计算区间界限。\n5. 将两个界限四舍五入到三位小数，并以毫米 (mm) 为单位报告。\n\n将此程序应用于提供的测试套件，会产生三对界限。程序必须打印一行，其中包含三个界限的子列表，格式化为无空格且保留三位小数，如下所示：\n$$\n[[\\ell_1,u_1],[\\ell_2,u_2],[\\ell_3,u_3]].\n$$\n该方法遵循基本原理：静态平衡 ($K u = f$)、导致线性刚度的线弹性，以及高斯随机变量线性变换的性质。约束通过反映足部模型固定部分狄利克雷边界条件的缩减矩阵 $K$ 来体现。",
            "answer": "```python\nimport numpy as np\n\ndef compute_ci_for_case(K, mu_f, Sigma_f, j, z=1.959964, decimals=3):\n    \"\"\"\n    Compute the two-sided 95% confidence interval for displacement component u_j\n    given reduced stiffness K (N/mm), mean force mu_f (N), covariance Sigma_f (N^2).\n    Returns (lower_bound_mm, upper_bound_mm), rounded to specified decimals.\n    \"\"\"\n    # Mean displacement: solve K * mu_u = mu_f\n    mu_u = np.linalg.solve(K, mu_f)\n\n    # Displacement covariance: Sigma_u = K^{-1} Sigma_f K^{-T}\n    # Compute with two linear solves to avoid explicit inversion.\n    # Since K is symmetric, K^{-T} = K^{-1}. So Sigma_u = K^{-1} Sigma_f K^{-1}.\n    # The implementation below computes this robustly.\n    Y = np.linalg.solve(K.T, Sigma_f.T)\n    B = Y.T\n    Sigma_u = np.linalg.solve(K, B)\n\n    # Extract mean and standard deviation for component j\n    mu_j = float(mu_u[j])\n    var_j = float(Sigma_u[j, j])\n    # Numerical guard: variance cannot be negative; clip small negatives due to roundoff\n    if var_j < 0 and abs(var_j) < 1e-12:\n        var_j = 0.0\n    sigma_j = np.sqrt(var_j)\n\n    # Two-sided CI\n    lower = mu_j - z * sigma_j\n    upper = mu_j + z * sigma_j\n\n    # Round to specified decimals\n    fmt = \"{:.\" + str(decimals) + \"f}\"\n    lower_s = float(fmt.format(lower))\n    upper_s = float(fmt.format(upper))\n    return lower_s, upper_s\n\ndef format_results_no_spaces(list_of_pairs, decimals=3):\n    \"\"\"\n    Format [[l1,u1],[l2,u2],...] without spaces and with fixed decimal formatting.\n    \"\"\"\n    fmt = \"{:.\" + str(decimals) + \"f}\"\n    inner = \",\".join(\"[\" + fmt.format(p[0]) + \",\" + fmt.format(p[1]) + \"]\" for p in list_of_pairs)\n    return \"[\" + inner + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Case A\n    K1 = np.array([\n        [8000.0, -1200.0,    0.0],\n        [-1200.0, 9000.0, -1500.0],\n        [   0.0, -1500.0, 7000.0]\n    ], dtype=float)\n    mu_f1 = np.array([120.0, 100.0, 80.0], dtype=float)\n    Sigma_f1 = np.array([\n        [400.0, 100.0,   0.0],\n        [100.0, 300.0,  50.0],\n        [  0.0,  50.0, 200.0]\n    ], dtype=float)\n    j1 = 1\n\n    # Case B\n    K2 = np.array([\n        [10000.0, -2000.0],\n        [ -2000.0,  8000.0]\n    ], dtype=float)\n    mu_f2 = np.array([200.0, 200.0], dtype=float)\n    Sigma_f2 = np.zeros((2, 2), dtype=float)\n    j2 = 0\n\n    # Case C\n    K3 = np.array([\n        [15000.0, -3000.0,     0.0,    0.0],\n        [ -3000.0, 12000.0, -2500.0,    0.0],\n        [    0.0,  -2500.0, 11000.0, -2000.0],\n        [    0.0,      0.0, -2000.0,  9000.0]\n    ], dtype=float)\n    mu_f3 = np.array([150.0, 0.0, 200.0, 50.0], dtype=float)\n    Sigma_f3 = np.array([\n        [  0.0,   0.0,   0.0,   0.0],\n        [  0.0, 500.0, 200.0,   0.0],\n        [  0.0, 200.0, 600.0,   0.0],\n        [  0.0,   0.0,   0.0,   0.0]\n    ], dtype=float)\n    j3 = 2\n\n    test_cases = [\n        (K1, mu_f1, Sigma_f1, j1),\n        (K2, mu_f2, Sigma_f2, j2),\n        (K3, mu_f3, Sigma_f3, j3),\n    ]\n\n    results = []\n    for K, mu_f, Sigma_f, j in test_cases:\n        lower, upper = compute_ci_for_case(K, mu_f, Sigma_f, j, z=1.959964, decimals=3)\n        results.append((lower, upper))\n\n    # Final print statement in the exact required format.\n    print(format_results_no_spaces(results, decimals=3))\n\nsolve()\n```"
        }
    ]
}