{
    "hands_on_practices": [
        {
            "introduction": "纳米孔测序的原始数据是一段嘈杂的电流信号。为了将此信号转化为碱基序列，我们使用隐马尔可夫模型（HMMs）等计算模型。这项练习将指导你实现维特比算法（Viterbi algorithm），这是计算生物学中的一个基石，用于从观测到的电流数据中找出最可能的隐藏状态序列（代表DNA），让你亲身体验碱基识别（basecalling）的核心过程。",
            "id": "5138906",
            "problem": "您将获得一个纳米孔链测序读数的简化模型。在该模型中，离子电流被建模为一个隐马尔可夫模型 (HMM)，其中隐状态代表链的离散步进状态（例如，短核苷酸上下文），而发射值是每个步进的带噪声的平均离子电流测量值。其物理背景是分子和免疫诊断学中的一个纳米孔系统，其中以皮安 (pA) 为单位测量的离子电流水平是局部链构象的特征，并且链在马达蛋白的控制下以离散的步长前进。您必须基于高斯发射模型为步进状态构建似然，并实现一个 Viterbi 解码器，从带噪声的平均电流轨迹中推断出最可能的步进状态序列。\n\n使用的基本原理和定义：\n- 隐马尔可夫模型 (HMM)：一个具有隐状态和观测发射值的随机模型。设时间索引 $t$ 处的隐状态为 $s_t \\in \\{0,1,\\dots,M-1\\}$，状态转移概率为 $A_{ij} = \\mathbb{P}(s_t = j \\mid s_{t-1} = i)$，初始分布为 $\\pi_j = \\mathbb{P}(s_0 = j)$。\n- 发射模型：对于每个状态 $j$，每步的平均离子电流 $\\bar{I}_t$ 被建模为一个均值为 $\\mu_j$、方差为 $\\sigma^2/K$ 的高斯（正态）随机变量，即 $\\bar{I}_t \\sim \\mathcal{N}(\\mu_j, \\sigma^2/K)$，其中 $\\sigma$ 是每个样本的标准差，$K$ 是每步平均的样本数。似然为\n$$\np(\\bar{I}_t \\mid s_t=j) = \\frac{1}{\\sqrt{2\\pi \\sigma^2/K}}\\exp\\left(-\\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\\right).\n$$\n- 通过 Viterbi 算法进行最大后验解码：在给定观测值 $\\bar{I}_0,\\bar{I}_1,\\dots,\\bar{I}_{T-1}$ 的情况下，使用自然对数，在对数域中通过动态规划计算最可能的状态路径 $s_0,s_1,\\dots,s_{T-1}$。\n\n您的任务：\n1. 对每个测试用例，使用上述高斯模型（方差为 $\\sigma^2/K$）构建发射对数似然 $\\log p(\\bar{I}_t \\mid s_t=j)$。然后实现 Viterbi 动态规划递推式：\n$$\n\\delta_t(j) = \\max_i \\left[\\delta_{t-1}(i) + \\log A_{ij}\\right] + \\log p(\\bar{I}_t \\mid s_t=j),\n$$\n初始化为\n$$\n\\delta_0(j) = \\log \\pi_j + \\log p(\\bar{I}_0 \\mid s_0=j),\n$$\n并维护回溯指针以重建最大化路径。所有对数运算均使用自然对数。\n2. 为每个测试用例独立地解码出最可能的状态序列。\n3. 将最终解码的序列表示为整数列表（状态索引），输出中不含任何物理单位。下面提到的所有物理单位仅用于模型规范说明；输出是无单位的。\n4. 您的程序应生成单行输出，其中包含所有测试用例的解码序列，形式为一个用方括号括起来的逗号分隔列表，其中每个解码序列表示为一个整数列表，例如 `[[0,1,2],[1,1,0]]`。\n\n测试套件：\n- 测试用例 1 (通用“理想路径”)：\n  - 状态数：$M = 4$。\n  - 状态均值 (皮安)：$\\mu = [64.8, 67.6, 62.9, 70.5]$。\n  - 每样本标准差 (皮安)：$\\sigma = 2.0$。\n  - 每步样本数：$K = 5$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.70  0.25  0.03  0.02 \\\\\n    0.15  0.70  0.13  0.02 \\\\\n    0.02  0.15  0.70  0.13 \\\\\n    0.02  0.03  0.25  0.70\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [0.25, 0.25, 0.25, 0.25]$。\n  - 步数：$T = 8$。\n  - 平均观测值 (皮安)：$\\bar{I} = [65.1, 67.3, 67.8, 62.2, 70.3, 69.8, 63.1, 66.9]$。\n\n- 测试用例 2 (状态均值重叠，有挑战性的发射)：\n  - 状态数：$M = 3$。\n  - 状态均值 (皮安)：$\\mu = [66.0, 66.6, 66.9]$。\n  - 每样本标准差 (皮安)：$\\sigma = 1.2$。\n  - 每步样本数：$K = 10$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.60  0.35  0.05 \\\\\n    0.20  0.60  0.20 \\\\\n    0.05  0.35  0.60\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}]$。\n  - 步数：$T = 6$。\n  - 平均观测值 (皮安)：$\\bar{I} = [65.8, 66.9, 66.6, 66.5, 66.7, 66.1]$。\n\n- 测试用例 3 (边界和短序列)：\n  - 状态数：$M = 2$。\n  - 状态均值 (皮安)：$\\mu = [63.0, 69.0]$。\n  - 每样本标准差 (皮安)：$\\sigma = 3.0$。\n  - 每步样本数：$K = 2$。\n  - 转移矩阵：\n    $$\n    A = \\begin{bmatrix}\n    0.80  0.20 \\\\\n    0.20  0.80\n    \\end{bmatrix}.\n    $$\n  - 初始分布：$\\pi = [0.5, 0.5]$。\n  - 步数：$T = 1$。\n  - 平均观测值 (皮安)：$\\bar{I} = [68.2]$。\n\n角度单位不适用。输出中不出现百分比。模型中使用的离子电流值以皮安 (pA) 为单位，但您的程序输出必须是无单位的解码状态索引序列。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 `[[0,1,2],[2,1,0],[1]]`。",
            "solution": "所提出的问题要求从一系列带噪声的观测值中解码出最可能的隐状态序列，这是序列数据分析中的一个典型任务。该系统被建模为一个隐马尔可夫模型 (HMM)，这个框架非常适合描述纳米孔测序背后的随机过程，其中像 DNA 这样的生物聚合物穿过一个纳米孔，从而产生一系列特征性的离子电流水平。Viterbi 算法通过动态规划为这个解码问题提供了一个精确且计算高效的解决方案。\n\n解决方案的步骤是首先将 HMM 的各组件形式化，然后在数值稳定的对数域中实现 Viterbi 算法。\n\n隐马尔可夫模型由一组参数 $(\\mathcal{S}, \\mathcal{V}, A, B, \\pi)$ 定义，其中：\n- $\\mathcal{S} = \\{0, 1, \\dots, M-1\\}$ 是 $M$ 个隐状态的有限集合，代表局部链构象。\n- $\\mathcal{V}$ 是可能观测值的集合。在这个问题中，观测值是连续的，代表平均离子电流 $\\bar{I}_t \\in \\mathbb{R}$。\n- $A$ 是状态转移概率矩阵，其中 $A_{ij} = \\mathbb{P}(s_t = j \\mid s_{t-1} = i)$ 是从状态 $i$ 转移到状态 $j$ 的概率。\n- $B$ 代表发射概率，$p(\\bar{I}_t \\mid s_t=j)$，即系统处于状态 $j$ 时观测到电流 $\\bar{I}_t$ 的概率。\n- $\\pi$ 是初始状态分布，其中 $\\pi_j = \\mathbb{P}(s_0 = j)$。\n\n该问题为时间步 $t$ 的平均离子电流 $\\bar{I}_t$ 指定了一个高斯发射模型。给定隐状态为 $s_t=j$，观测值 $\\bar{I}_t$ 从一个正态分布 $\\mathcal{N}(\\mu_j, \\sigma_{avg}^2)$ 中抽取，其中 $\\mu_j$ 是状态 $j$ 的平均电流，$\\sigma_{avg}^2 = \\sigma^2/K$ 是平均测量值的方差。这里，$\\sigma$ 是每个样本的标准差，$K$ 是每步平均的样本数。\n\n给定状态 $j$ 时，观测值 $\\bar{I}_t$ 的概率密度函数为：\n$$\np(\\bar{I}_t \\mid s_t=j) = \\frac{1}{\\sqrt{2\\pi \\sigma^2/K}}\\exp\\left(-\\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\\right)\n$$\n对于长序列，直接将这些概率相乘可能导致数值下溢。因此，所有计算都使用自然对数在对数域中进行。一次发射的对数似然为：\n$$\n\\log p(\\bar{I}_t \\mid s_t=j) = -\\frac{1}{2}\\log(2\\pi \\sigma^2/K) - \\frac{(\\bar{I}_t - \\mu_j)^2}{2\\sigma^2/K}\n$$\n这些对数似然是为每个时间步 $t \\in \\{0, \\dots, T-1\\}$ 和每个状态 $j \\in \\{0, \\dots, M-1\\}$ 计算的。\n\nViterbi 算法通过最大化状态序列和观测值的联合对数概率来找到最优状态序列 $S^* = (s_0^*, s_1^*, \\dots, s_{T-1}^*)$。这是通过动态规划实现的。我们定义两个表：\n1. $\\delta_t(j)$: 任何长度为 $t+1$、结束于状态 $j$ 并生成观测值 $\\bar{I}_0, \\dots, \\bar{I}_t$ 的路径的最大对数概率。\n2. $\\psi_t(j)$: 一个回溯指针表，用于存储在时间 $t-1$ 时能够以最大概率在时间 $t$ 到达状态 $j$ 的那个状态。\n\n该算法分三个阶段进行：\n\n**1. 初始化 ($t=0$)：**\n对于每个状态 $j \\in \\{0, \\dots, M-1\\}$，初始对数概率是初始概率的对数与第一次观测 $\\bar{I}_0$ 的发射对数概率之和。\n$$\n\\delta_0(j) = \\log \\pi_j + \\log p(\\bar{I}_0 \\mid s_0=j)\n$$\n\n**2. 递推 ($t=1, \\dots, T-1$)：**\n对于每个后续的时间步 $t$，我们从时间 $t-1$ 扩展最优路径。对于每个状态 $j$，我们找到前一个状态 $i$，该状态能够以最大概率转移到 $j$ 并生成观测值 $\\bar{I}_t$。\n$$\n\\delta_t(j) = \\max_{i \\in \\{0, \\dots, M-1\\}} \\left[ \\delta_{t-1}(i) + \\log A_{ij} \\right] + \\log p(\\bar{I}_t \\mid s_t=j)\n$$\n时间 $t$ 状态 $j$ 的回溯指针存储了这个最大化前一状态 $i$ 的索引：\n$$\n\\psi_t(j) = \\arg\\max_{i \\in \\{0, \\dots, M-1\\}} \\left[ \\delta_{t-1}(i) + \\log A_{ij} \\right]\n$$\n\n**3. 终止和路径重建：**\n在为所有状态 $j$ 计算完 $\\delta_{T-1}(j)$ 后，最可能的最终状态是具有最高对数概率的那个状态：\n$$\ns^*_{T-1} = \\arg\\max_{j \\in \\{0, \\dots, M-1\\}} \\delta_{T-1}(j)\n$$\n最可能路径的其余部分通过使用存储的回溯指针从这个最终状态开始回溯来找到：\n$$\ns^*_{t-1} = \\psi_t(s^*_t) \\quad \\text{for } t = T-1, \\dots, 1\n$$\n这个过程产生完整的最优状态序列 $S^*=(s_0^*, s_1^*, \\dots, s_{T-1}^*)$，这就是给定测试用例的解。实现将使用此算法独立处理问题陈述中提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef viterbi_decode(M, mu, sigma, K, A, pi, T, I_bar):\n    \"\"\"\n    Decodes the most probable sequence of hidden states in an HMM using the Viterbi algorithm.\n    All calculations are performed in the log domain for numerical stability.\n\n    Args:\n        M (int): Number of hidden states.\n        mu (list or np.ndarray): Mean ionic current for each state.\n        sigma (float): Per-sample standard deviation of the ionic current.\n        K (int): Number of samples averaged per step.\n        A (list of lists or np.ndarray): State transition probability matrix.\n        pi (list or np.ndarray): Initial state probability distribution.\n        T (int): Number of observations (time steps).\n        I_bar (list or np.ndarray): Sequence of averaged ionic current observations.\n\n    Returns:\n        list: The most probable sequence of state indices.\n    \"\"\"\n    num_states = M\n    num_observations = T\n\n    # Convert inputs to numpy arrays for vectorized operations\n    mu = np.array(mu)\n    # Ensure A and pi are numpy arrays for log operations\n    A = np.array(A)\n    pi = np.array(pi)\n    I_bar = np.array(I_bar)\n\n    # 1. Preparation: Compute log probabilities\n    # Use np.errstate to suppress warnings for log(0), which is correctly handled as -np.inf\n    with np.errstate(divide='ignore'):\n        log_A = np.log(A)\n        log_pi = np.log(pi)\n\n    # Compute emission log-likelihoods for all observations and states.\n    # The matrix emission_log_lik will have shape (T, M), where B[t, j] = log p(I_bar[t] | s_t = j).\n    var_avg = (sigma**2) / K\n    std_avg = np.sqrt(var_avg)\n    \n    emission_log_lik = np.zeros((num_observations, num_states))\n    for t in range(num_observations):\n        # norm.logpdf calculates the log probability density for I_bar[t] under\n        # a normal distribution for each state's mean mu[j] and the common scale std_avg.\n        emission_log_lik[t, :] = norm.logpdf(I_bar[t], loc=mu, scale=std_avg)\n\n    # 2. Dynamic Programming tables\n    # delta[t, j]: max log-prob of a path ending in state j at time t\n    delta = np.zeros((num_observations, num_states))\n    # psi[t, j]: backpointer to the previous state on the optimal path to j at t\n    psi = np.zeros((num_observations, num_states), dtype=int)\n\n    # 3. Initialization step (t=0)\n    delta[0, :] = log_pi + emission_log_lik[0, :]\n\n    # 4. Recursion step (t=1 to T-1)\n    if num_observations > 1:\n        for t in range(1, num_observations):\n            for j in range(num_states):\n                # For each current state j, find the best previous state i.\n                # The term inside the max is delta[t-1, i] + log_A[i, j].\n                temp_log_prob = delta[t-1, :] + log_A[:, j]\n                \n                # Find the maximum log probability and the corresponding state index\n                max_log_prob = np.max(temp_log_prob)\n                argmax_index = np.argmax(temp_log_prob)\n                \n                # Update the DP tables\n                delta[t, j] = max_log_prob + emission_log_lik[t, j]\n                psi[t, j] = argmax_index\n\n    # 5. Termination and Path Reconstruction (Backtracking)\n    path = np.zeros(num_observations, dtype=int)\n    \n    # Find the most probable final state\n    path[num_observations - 1] = np.argmax(delta[num_observations - 1, :])\n    \n    # Backtrack to find the rest of the optimal path\n    for t in range(num_observations - 2, -1, -1):\n        path[t] = psi[t + 1, path[t + 1]]\n\n    return path.tolist()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        (\n            4, # M\n            [64.8, 67.6, 62.9, 70.5], # mu\n            2.0, # sigma\n            5, # K\n            [[0.70, 0.25, 0.03, 0.02],\n             [0.15, 0.70, 0.13, 0.02],\n             [0.02, 0.15, 0.70, 0.13],\n             [0.02, 0.03, 0.25, 0.70]], # A\n            [0.25, 0.25, 0.25, 0.25], # pi\n            8, # T\n            [65.1, 67.3, 67.8, 62.2, 70.3, 69.8, 63.1, 66.9] # I_bar\n        ),\n        # Test Case 2\n        (\n            3, # M\n            [66.0, 66.6, 66.9], # mu\n            1.2, # sigma\n            10, # K\n            [[0.60, 0.35, 0.05],\n             [0.20, 0.60, 0.20],\n             [0.05, 0.35, 0.60]], # A\n            [1/3, 1/3, 1/3], # pi\n            6, # T\n            [65.8, 66.9, 66.6, 66.5, 66.7, 66.1] # I_bar\n        ),\n        # Test Case 3\n        (\n            2, # M\n            [63.0, 69.0], # mu\n            3.0, # sigma\n            2, # K\n            [[0.80, 0.20],\n             [0.20, 0.80]], # A\n            [0.5, 0.5], # pi\n            1, # T\n            [68.2] # I_bar\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        M, mu, sigma, K, A, pi, T, I_bar = case\n        decoded_path = viterbi_decode(M, mu, sigma, K, A, pi, T, I_bar)\n        results.append(decoded_path)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list of lists contains spaces.\n    # The required format is compact, without spaces.\n    print(str(results).replace(' ', ''))\n\nsolve()\n\n```"
        },
        {
            "introduction": "单条纳米孔读长的错误率相对较高，但我们可以通过对同一DNA分子进行多次测序（即增加覆盖度）来克服这一局限。在本练习中，你将使用二项概率模型来计算一致性序列的准确度如何随覆盖度的增加而提高，并确定达到临床级质量标准所需的测序深度。这项练习揭示了准确进行变异检测背后的统计学基础。",
            "id": "5138841",
            "problem": "一个分子与免疫诊断实验室使用纳米孔单链测序技术，通过独立的单链读数组装逐个碱基的共识序列，以检测临床相关位点上的单核苷酸变异。假设覆盖某一碱基的每个独立读数都具有相同且独立的碱基检出性能：它有 $a$ 的概率报告正确的碱基，有 $1-a$ 的概率报告某个不正确的碱基。为抑制来自错误模式异质性的偏差，假设错误在三个不正确的碱基之间是对称的。该实验室通过对 $N$ 个碱基检出结果进行多数投票来构建覆盖深度为 $N$（为避免平局，$N$ 是一个奇数）的共识碱基。共识检出的 Phred 质量分数 (PQS) 定义为：如果共识错误的概率是 $e$，那么共识质量为 $Q=-10\\log_{10}(e)$。\n\n从独立性、二项分布和 Phred 质量分数的定义出发，推导共识准确度 $A(N)$ 作为覆盖深度 $N$ 和单次读取正确率 $a$ 的函数的解析表达式。然后，在 $a=0.95$ 的特定情况下，确定所需的最小奇数覆盖深度 $N$，以使共识 Phred 质量至少为 $Q=30$（即，共识错误概率 $e$ 不大于 $10^{-3}$）。将最小奇数 $N$ 作为最终答案报告。无需四舍五入。",
            "solution": "该问题被验证为具有科学依据、问题明确且客观。它是二项概率在一个简化的基因测序共识模型中的标准应用，这是生物信息学和诊断学中的一个核心概念。所有提供的信息都是自洽的，并足以得出一个唯一的解。\n\n设 $a$ 为单个独立读数正确识别一个碱基的概率。那么，不正确碱基检出的概率是 $1-a$。覆盖深度 $N$ 是覆盖该碱基的独立读数的数量，且已知为一个奇数。\n\n共识检出由多数投票决定。设 $k$ 为 $N$ 个总读数中正确识别真实碱基的读数数量。这 $N$ 个读数是独立的伯努利试验，因此正确读数的数量 $k$ 服从二项分布：\n$$P(k; N, a) = \\binom{N}{k} a^k (1-a)^{N-k}$$\n要使共识检出正确，真实碱基被检出的频率必须高于任何其他碱基。问题说明错误是对称的，意味着 $1-a$ 的错误概率在其他三个可能的碱基中均等分布。如果正确读数的数量 $k$ 大于总读数的一半 $N/2$，那么不正确读数的数量 $N-k$ 必定小于 $N/2$。由于这 $N-k$ 个读数分布在三个不正确的碱基上，没有任何一个不正确的碱基可能获得比 $k$ 更多的票数。因此，一个正确的共识检出的条件是正确读数的数量 $k$ 构成多数。\n\n由于 $N$ 是奇数，如果 $k > N/2$，就达到多数。满足这个条件的最小整数 $k$ 是 $k = (N+1)/2$。如果 $k$ 是从 $(N+1)/2$ 到 $N$ 的任何整数，那么共识结果就是正确的。\n\n共识准确度 $A(N)$ 是共识检出正确的概率。这是导致正确共识结果的所有 $k$ 值的概率之和：\n$$A(N) = P\\left(k \\ge \\frac{N+1}{2}\\right) = \\sum_{k=(N+1)/2}^{N} P(k; N, a)$$\n代入二项概率质量函数，我们得到共识准确度 $A(N)$ 作为 $N$ 和 $a$ 的函数的解析表达式：\n$$A(N) = \\sum_{k=(N+1)/2}^{N} \\binom{N}{k} a^k (1-a)^{N-k}$$\n这是所要求推导的第一部分。\n\n共识错误的概率 $e$ 是准确度的补集：$e(N) = 1 - A(N)$。这对应于正确读数数量占少数的情况，即 $k  (N+1)/2$。由于 $k$ 是整数，这等价于 $k \\le (N-1)/2$。\n$$e(N) = P\\left(k \\le \\frac{N-1}{2}\\right) = \\sum_{k=0}^{(N-1)/2} \\binom{N}{k} a^k (1-a)^{N-k}$$\nPhred 质量分数 $Q$ 定义为 $Q = -10\\log_{10}(e)$。问题要求在单次读取准确度 $a=0.95$ 的情况下，找到满足 $Q \\ge 30$ 的最小奇数 $N$。\n条件 $Q \\ge 30$ 可转换为：\n$$-10\\log_{10}(e) \\ge 30$$\n$$\\log_{10}(e) \\le -3$$\n$$e \\le 10^{-3}$$\n我们需要找到最小的奇数 $N$，使得在 $a=0.95$ 和 $1-a=0.05$ 的条件下，$e(N) \\le 0.001$。我们将逐个测试连续的奇数 $N$ 值。\n\n当 $N=1$ 时：\n错误条件为 $k \\le (1-1)/2 = 0$，所以 $k=0$。\n$e(1) = \\binom{1}{0} a^0 (1-a)^1 = 1-a = 0.05$。\n$0.05  0.001$，因此 $N=1$ 不足够。\n\n当 $N=3$ 时：\n错误条件为 $k \\le (3-1)/2 = 1$，所以 $k=0$ 或 $k=1$。\n$e(3) = \\sum_{k=0}^{1} \\binom{3}{k} a^k (1-a)^{3-k} = \\binom{3}{0}a^0(1-a)^3 + \\binom{3}{1}a^1(1-a)^2$\n$e(3) = (1-a)^3 + 3a(1-a)^2 = (0.05)^3 + 3(0.95)(0.05)^2$\n$e(3) = 0.000125 + 3(0.95)(0.0025) = 0.000125 + 0.007125 = 0.00725$。\n$0.00725  0.001$，因此 $N=3$ 不足够。\n\n当 $N=5$ 时：\n错误条件为 $k \\le (5-1)/2 = 2$，所以 $k=0, 1, 2$。\n$e(5) = \\sum_{k=0}^{2} \\binom{5}{k} a^k (1-a)^{5-k} = \\binom{5}{0}(1-a)^5 + \\binom{5}{1}a(1-a)^4 + \\binom{5}{2}a^2(1-a)^3$\n$e(5) = (0.05)^5 + 5(0.95)(0.05)^4 + 10(0.95)^2(0.05)^3$\n$e(5) = 3.125 \\times 10^{-7} + 5(0.95)(6.25 \\times 10^{-6}) + 10(0.9025)(1.25 \\times 10^{-4})$\n$e(5) = 3.125 \\times 10^{-7} + 2.96875 \\times 10^{-5} + 1.128125 \\times 10^{-3}$\n$e(5) = 0.0000003125 + 0.0000296875 + 0.001128125 = 0.001158125$。\n$0.001158125  0.001$，因此 $N=5$ 不足够。\n\n当 $N=7$ 时：\n错误条件为 $k \\le (7-1)/2 = 3$，所以 $k=0, 1, 2, 3$。\n$e(7) = \\sum_{k=0}^{3} \\binom{7}{k} a^k (1-a)^{7-k}$\n$e(7) = \\binom{7}{0}(1-a)^7 + \\binom{7}{1}a(1-a)^6 + \\binom{7}{2}a^2(1-a)^5 + \\binom{7}{3}a^3(1-a)^4$\n$e(7) = (0.05)^7 + 7(0.95)(0.05)^6 + 21(0.95)^2(0.05)^5 + 35(0.95)^3(0.05)^4$\n$e(7) = (7.8125 \\times 10^{-10}) + 7(0.95)(1.5625 \\times 10^{-8}) + 21(0.9025)(3.125 \\times 10^{-7}) + 35(0.857375)(6.25 \\times 10^{-6})$\n$e(7) = 7.8125 \\times 10^{-10} + 1.0390625 \\times 10^{-7} + 5.9228515625 \\times 10^{-6} + 1.8754296875 \\times 10^{-4}$\n$e(7) \\approx 1.9357 \\times 10^{-4}$。\n$1.9357 \\times 10^{-4} = 0.00019357$，小于 $0.001$。\n因此，$N=7$ 足以达到所需的质量分数。\n\n由于覆盖深度 $N=5$ 不足够而 $N=7$ 足够，因此所需的最小奇数覆盖深度是 $N=7$。",
            "answer": "$$\\boxed{7}$$"
        },
        {
            "introduction": "一次成功的测序实验，其关键在于精确设置实验条件。本练习模拟了一个核心的权衡过程：在保证纳米孔高效测序的同时，避免因DNA浓度过高而频繁堵塞。你将运用更新理论和优化原理，确定能够最大化读长通量且同时维持纳米孔可靠性的理想DNA浓度，从而深入了解运行纳米孔实验的实践技巧。",
            "id": "5138899",
            "problem": "一个 Oxford Nanopore Technologies (ONT) 流动池中的单个纳米孔在可捕获状态和因测序或恢复而不可用状态之间交替。考虑一个双链DNA分子文库，其平均读长为 $L$，整体浓度为 $c$（单位为纳摩尔，nM）。当纳米孔可用时，捕获事件遵循速率为 $\\lambda(c) = k c$ 的泊松过程（质量作用捕获），其中 $k$ 是一个浓度归一化的捕获速率常数，单位为 $\\mathrm{s}^{-1}\\,\\mathrm{nM}^{-1}$。捕获后，纳米孔会花费固定的测序时间 $\\tau_{s}$ 来转运该分子。测序完成后，纳米孔可能因瞬时堵塞而进入恢复状态，其概率为 $p(c)$，在此期间，它将在固定的时间 $\\tau_{r}$ 内不可用，然后返回可用状态。假设 (i) 捕获仅在纳米孔可用时发生，(ii) 每次捕获都会产生一个持续时间为 $\\tau_{s}$ 的完整读长，无论后续是否恢复，(iii) 恢复事件在每次读取后独立发生，概率为 $p(c)$，且该概率随 $c$ 增加而增加，(iv) 纳米孔可用时等待捕获的时间呈指数分布，均值为 $1/\\lambda(c)$。\n\n一个广泛使用的恢复经验风险函数是 $p(c) = 1 - \\exp(-\\gamma c)$，其中 $\\gamma$ 是一个正参数，用于编码堵塞的有效浓度依赖性。在这些假设下，将纳米孔建模为一个交替更新过程，其包含独立同分布（i.i.d.）的循环，每个循环包括一个可用期（等待下一次捕获）、一个长度为 $\\tau_{s}$ 的测序期，以及一个以概率 $p(c)$ 发生的长度为 $\\tau_{r}$ 的恢复期。设每个纳米孔的长期读长通量定义为期望循环长度的倒数。为确保分子和免疫诊断工作流程的稳健运行，恢复状态所占的总时间分数不得超过可靠性阈值 $\\alpha$。\n\n仅使用上述基本原理（质量作用捕获、可用时的泊松到达、固定的测序和恢复时间、恢复事件的独立性以及用于长期平均的更新理论），推导出通量和恢复时间分数作为 $c$ 的函数，然后确定在恢复时间分数不大于 $\\alpha$ 的约束下，使通量最大化的上样浓度 $c^{\\star}$。使用以下参数值：$k = 0.05\\,\\mathrm{s}^{-1}\\,\\mathrm{nM}^{-1}$，$\\tau_{s} = 2\\,\\mathrm{s}$，$\\tau_{r} = 10\\,\\mathrm{s}$，$\\gamma = 0.03\\,\\mathrm{nM}^{-1}$，以及 $\\alpha = 0.20$。将您的 $c^{\\star}$ 答案四舍五入到 $3$ 位有效数字。最终浓度以纳摩尔（nM）表示。",
            "solution": "我们从所述原理开始。设 $c$ 表示整体浓度，单位为纳摩尔（nM）。当纳米孔可用时，捕获以速率 $\\lambda(c) = k c$ 发生。因此，当纳米孔可用时，等待下一次捕获的时间 $W$ 服从指数分布，其均值为 $\\mathbb{E}[W] = 1/\\lambda(c) = \\frac{1}{k c}$。每个循环包括随机等待时间 $W$，然后是固定的测序时间 $\\tau_{s}$，再然后是以概率 $p(c)$ 发生的固定恢复时间 $\\tau_{r}$。\n\n根据期望的线性和独立性，期望循环长度 $E[C(c)]$ 为\n$$\nE[C(c)] = \\mathbb{E}[W] + \\tau_{s} + p(c)\\,\\tau_{r} = \\frac{1}{k c} + \\tau_{s} + p(c)\\,\\tau_{r}.\n$$\n根据更新理论（更新回报定理），单位时间的长期平均完成读长数等于期望循环长度的倒数。因此，每个纳米孔的读长通量 $T(c)$（单位：读长/秒）为\n$$\nT(c) = \\frac{1}{E[C(c)]} = \\frac{1}{\\frac{1}{k c} + \\tau_{s} + p(c)\\,\\tau_{r}}.\n$$\n在恢复状态下花费的时间分数，记为 $F_{\\mathrm{rec}}(c)$，是每个循环中归因于恢复的停机时间的长期分数，即，\n$$\nF_{\\mathrm{rec}}(c) = \\frac{p(c)\\,\\tau_{r}}{E[C(c)]} = \\frac{p(c)\\,\\tau_{r}}{\\frac{1}{k c} + \\tau_{s} + p(c)\\,\\tau_{r}}.\n$$\n可靠性约束要求 $F_{\\mathrm{rec}}(c) \\leq \\alpha$。因为 $p(c)$ 随 $c$ 单调增加，而 $\\frac{1}{k c}$ 随 $c$ 单调减少，所以在我们感兴趣的参数范围内，$F_{\\mathrm{rec}}(c)$ 随 $c$ 单调增加。同时，由于 $\\frac{1}{k c}$ 项的存在，$E[C(c)]$ 最初随 $c$ 减小，然后通过 $p(c)\\,\\tau_{r}$ 缓慢增加，这可能在某个内部点 $c$ 处产生一个无约束的最优解，该点满足 $\\frac{\\mathrm{d}}{\\mathrm{d}c}E[C(c)] = 0$。然而，如果无约束的最大化解违反了 $F_{\\mathrm{rec}}(c) \\leq \\alpha$，那么有约束的最大化解就是满足 $F_{\\mathrm{rec}}(c) = \\alpha$ 的最大 $c$ 值。\n\n我们现在将 $p(c)$ 具体化为 $p(c) = 1 - \\exp(-\\gamma c)$，并使用给定的参数 $k = 0.05\\,\\mathrm{s}^{-1}\\,\\mathrm{nM}^{-1}$，$\\tau_{s} = 2\\,\\mathrm{s}$，$\\tau_{r} = 10\\,\\mathrm{s}$，$\\gamma = 0.03\\,\\mathrm{nM}^{-1}$，以及 $\\alpha = 0.20$。\n\n首先，我们验证 $E[C(c)]$ 的无约束最小化解是否可行。对 $E[C(c)]$ 求导：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}c}E[C(c)] = -\\frac{1}{k c^{2}} + \\tau_{r}\\,\\frac{\\mathrm{d}}{\\mathrm{d}c}p(c) = -\\frac{1}{k c^{2}} + \\tau_{r}\\,\\gamma\\,\\exp(-\\gamma c).\n$$\n令 $\\frac{\\mathrm{d}}{\\mathrm{d}c}E[C(c)] = 0$ 可得\n$$\n\\tau_{r}\\,\\gamma\\,\\exp(-\\gamma c) = \\frac{1}{k c^{2}}.\n$$\n这个超越方程有一个以朗伯W函数表示的闭式解。重新整理，\n$$\n\\exp(\\gamma c) = k \\tau_{r} \\gamma\\, c^{2}.\n$$\n设 $y = \\gamma c$。那么 $\\exp(y) = \\frac{k \\tau_{r} \\gamma}{\\gamma^{2}}\\, y^{2} = \\frac{k \\tau_{r}}{\\gamma}\\, y^{2}$，所以 $y^{2}\\exp(-y) = \\frac{\\gamma}{k \\tau_{r}}$。设 $y = 2 z$ 可得 $(z \\exp(-z))^{2} = \\frac{\\gamma}{4 k \\tau_{r}}$，因此 $z \\exp(-z) = \\frac{1}{2}\\sqrt{\\frac{\\gamma}{k \\tau_{r}}}$。设 $u = -z$，则 $u \\exp(u) = -\\frac{1}{2}\\sqrt{\\frac{\\gamma}{k \\tau_{r}}}$ 且 $u = W\\!\\left(-\\frac{1}{2}\\sqrt{\\frac{\\gamma}{k \\tau_{r}}}\\right)$。因此，\n$$\nc_{\\mathrm{uncon}} = -\\frac{2}{\\gamma}\\,W\\!\\left(-\\frac{1}{2}\\sqrt{\\frac{\\gamma}{k \\tau_{r}}}\\right).\n$$\n代入参数，在主分支 $W_{0}$ 上得到一个实数值。数值计算得出 $c_{\\mathrm{uncon}} \\approx 9.4$ 纳摩尔。在此 $c$ 值下计算 $F_{\\mathrm{rec}}(c)$，得到的恢复分数大于 $\\alpha = 0.20$，因此无约束最优解是不可行的。\n\n因此，有约束的最优解在边界 $F_{\\mathrm{rec}}(c) = \\alpha$ 处取得，即，\n$$\n\\frac{p(c)\\,\\tau_{r}}{\\frac{1}{k c} + \\tau_{s} + p(c)\\,\\tau_{r}} = \\alpha,\n$$\n其中 $p(c) = 1 - \\exp(-\\gamma c)$。求解这个关于 $c$ 的方程：\n$$\n\\alpha\\left(\\frac{1}{k c} + \\tau_{s} + p(c)\\,\\tau_{r}\\right) = p(c)\\,\\tau_{r}\n\\quad\\Rightarrow\\quad\n\\alpha\\left(\\frac{1}{k c} + \\tau_{s}\\right) = p(c)\\,\\tau_{r}(1 - \\alpha).\n$$\n因此，\n$$\np(c) = \\frac{\\alpha\\left(\\frac{1}{k c} + \\tau_{s}\\right)}{\\tau_{r}(1 - \\alpha)}.\n$$\n令其等于 $1 - \\exp(-\\gamma c)$，得到标量方程\n$$\n1 - \\exp(-\\gamma c) = \\frac{\\alpha\\left(\\frac{1}{k c} + \\tau_{s}\\right)}{\\tau_{r}(1 - \\alpha)}.\n$$\n使用给定参数，该方程变为\n$$\n1 - \\exp(-0.03\\, c) = \\frac{0.20\\left(\\frac{1}{0.05\\, c} + 2\\right)}{10\\,(1 - 0.20)} = \\frac{0.20\\left(\\frac{1}{0.05\\, c} + 2\\right)}{8} = \\frac{\\frac{0.20}{0.05\\, c} + 0.40}{8} = \\frac{\\frac{4}{c} + 0.40}{8} = \\frac{0.5}{c} + 0.05.\n$$\n我们求解\n$$\n1 - \\exp(-0.03\\, c) = 0.05 + \\frac{0.5}{c}.\n$$\n方程左边是 $c$ 的增函数，右边是 $c$ 的减函数，因此存在唯一解。通过单调区间套法和优化可得：\n\n- 当 $c = 5$ 时，左侧 = $1 - \\exp(-0.15) \\approx 0.139$，右侧 = $0.05 + 0.1 = 0.15$ (左侧  右侧)。\n- 当 $c = 5.5$ 时，左侧 = $1 - \\exp(-0.165) \\approx 0.152$，右侧 $\\approx 0.05 + 0.0909 = 0.1409$ (左侧  右侧)。\n- 优化后，当 $c = 5.24$ 时，左侧 = $1 - \\exp(-0.1572) \\approx 0.1454$，右侧 $\\approx 0.05 + 0.09542 = 0.14542$。\n\n这给出 $c^{\\star} \\approx 5.24$ 纳摩尔。四舍五入到 $3$ 位有效数字，得到 $c^{\\star} = 5.24$ 纳摩尔。该值满足 $F_{\\mathrm{rec}}(c^{\\star}) = \\alpha$ 并且在可靠性约束下最大化了通量。",
            "answer": "$$\\boxed{5.24}$$"
        }
    ]
}