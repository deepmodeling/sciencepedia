{
    "hands_on_practices": [
        {
            "introduction": "宏基因组鸟枪法测序本质上是一个随机抽样过程。即使样本中确实存在病原体，如果其丰度较低或测序深度不足，我们仍有可能因偶然因素而未能测序到任何源自该病原体的片段。本练习将引导您从第一性原理出发，运用基础概率论来量化这种假阴性风险，从而深刻理解病原体相对丰度 $f$、测序深度 $D$ 与检测极限之间的内在联系。",
            "id": "5131994",
            "problem": "在用于病原体发现的宏基因组鸟枪法测序中，假设测序读数是从可进行测序的核酸分子池中独立且均匀采样的。设样本中目标病原体的真实相对丰度为 $f$，定义为任何一个读数来源于该病原体的概率；设测序深度为 $D$，定义为产生的读数总数。在这些条件下，定义随机变量 $X$ 为观测到的源于病原体的读数数量。\n\n从伯努利抽样和独立性的基本原理出发，推导观测到零个源于病原体的读数的概率。然后，使用给定值 $f = 10^{-6}$ 和 $D = 10^{8}$，计算此概率。如果参数支持，您可以使用适当的渐近近似，但必须清楚地阐述理由。将最终的数值概率四舍五入到3位有效数字，并以小数形式表示。\n\n最后，简要讨论您的结果对于宏基因组下一代测序（NGS）中临床报告阈值的影响，例如当实验室要求至少有 $k$ 个读数才报告阳性时。您的讨论应围绕抽样方差及其在所述假设下对假阴性的贡献展开，不要引用任何未提供的快捷公式或经验法则。",
            "solution": "问题陈述已经过验证，被确定为是合理的、适定的且有科学依据的。\n\n该问题要求在一个宏基因组鸟枪法测序实验中，推导并计算观测到零个源于病原体的读数的概率，并讨论其结果的影响。\n\n核心假设是测序读数是从核酸分子池中独立且均匀采样的。这个过程可以被建模为一系列伯努利试验。\n\n设 $D$ 为测序读数的总数（测序深度），这对应于试验的次数。设 $f$ 为病原体的真实相对丰度，即任何单个读数来源于该病原体的概率。这对应于单次伯努利试验中“成功”的概率。\n\n随机变量 $X$ 表示在 $D$ 次试验中观测到的源于病原体的读数总数。由于各次试验是独立的，且每次试验的成功概率 $f$ 是恒定的，所以 $X$ 服从二项分布，记作 $X \\sim B(D, f)$。\n\n二项分布的概率质量函数（PMF）给出了在 $n$ 次试验中观测到恰好 $k$ 次成功的概率：\n$$P(X=k) = \\binom{n}{k} p^k (1-p)^{n-k}$$\n在我们的情境中，$n=D$，$p=f$，并且我们关心的是 $k=0$ 的情况。将这些值代入PMF，我们推导出观测到零个源于病原体的读数的概率：\n$$P(X=0) = \\binom{D}{0} f^0 (1-f)^{D-0}$$\n根据定义，$\\binom{D}{0} = 1$ 且 $f^0 = 1$。因此，精确概率为：\n$$P(X=0) = (1-f)^D$$\n\n现在，我们被要求用给定的值 $f = 10^{-6}$ 和 $D = 10^{8}$ 来计算这个概率。\n直接计算 $(1 - 10^{-6})^{10^{8}}$ 在计算上很繁琐。题目允许在有理由的情况下使用渐近近似。二项分布的泊松近似条件是试验次数 $D$ 非常大，且成功概率 $f$ 非常小。在我们的例子中，$D = 10^8$ 确实非常大，而 $f = 10^{-6}$ 非常小。因此，使用泊松近似是理由充分的。\n\n二项分布 $B(D, f)$ 可以用参数为 $\\lambda$ 的泊松分布来近似，其中 $\\lambda$ 是期望的成功次数。\n$$\\lambda = E[X] = Df$$\n让我们用给定的值计算 $\\lambda$：\n$$\\lambda = (10^8) \\times (10^{-6}) = 10^{2} = 100$$\n泊松分布的PMF是：\n$$P(X=k) \\approx \\frac{\\lambda^k \\exp(-\\lambda)}{k!}$$\n我们想要找到观测到零个读数的概率，即 $k=0$。\n$$P(X=0) \\approx \\frac{\\lambda^0 \\exp(-\\lambda)}{0!}$$\n由于 $\\lambda^0 = 1$ 且 $0! = 1$，这可以简化为：\n$$P(X=0) \\approx \\exp(-\\lambda) = \\exp(-Df)$$\n这个近似源于众所周知的指数函数的极限定义：\n$$P(X=0) = (1-f)^D = \\left(1 - \\frac{Df}{D}\\right)^D = \\left(1 - \\frac{\\lambda}{D}\\right)^D$$\n对于大的 $D$，该表达式收敛于 $\\exp(-\\lambda)$。\n\n现在，我们计算其数值：\n$$P(X=0) \\approx \\exp(-100)$$\n计算这个值并四舍五入到3位有效数字：\n$$\\exp(-100) \\approx 3.7200759... \\times 10^{-44}$$\n四舍五入到3位有效数字，概率为 $3.72 \\times 10^{-44}$。\n\n最后，关于其影响的讨论，结果 $P(X=0) \\approx 3.72 \\times 10^{-44}$ 是当病原体以 $f = 10^{-6}$ 的相对丰度存在且测序深度为 $D = 10^8$ 时，出现假阴性（完全未能检测到病原体）的概率。期望的病原体读数数量为 $\\lambda = Df = 100$。\n\n$P(X=0)$ 是非零的这一事实，即使在本例中其值无穷小，也说明了一个基本原理：测序的随机性引入了抽样方差。即使当病原体存在且期望的读数数量很高（100）时，也存在一个有限的、因偶然性而观测到零个读数的概率。\n\n如果一个临床实验室设定了一个报告阈值，要求至少有 $k$ 个读数才能报告阳性（例如，$k=3$），那么当观测到的读数数量 $X$ 小于 $k$ 时，就会发生假阴性。这一事件的概率 $P(X  k)$ 是概率 $P(X=0), P(X=1), \\dots, P(X=k-1)$ 的总和。我们计算出的 $P(X=0)$ 的值代表了对于任何阈值 $k \\ge 1$ 的绝对最小假阴性率。\n\n虽然对于给定的参数，假阴性率极低，但如果乘积 $\\lambda=Df$ 很小，情况就会发生巨大变化。例如，如果对相同的病原体丰度（$f=10^{-6}$）使用较低的测序深度（例如，$D=10^6$），那么期望的读数数量将是 $\\lambda = 1$。此时，观测到零个读数的概率将是 $P(X=0) \\approx \\exp(-1) \\approx 0.368$。在这种情况下，将有 $36.8\\%$ 的几率完全漏检该病原体，这是一个临床上不可接受的假阴性率。\n\n这表明，抽样方差是宏基因组诊断中假阴性的一个关键因素。可靠地检测病原体的能力并非仅由其存在就能保证；它受到观测读数的概率分布的支配，而这个分布从根本上取决于病原体丰度（$f$）和测序深度（$D$）之间的相互作用。设定报告阈值 $k$ 时，必须与假阴性的风险进行权衡，而这个风险是由参数 $\\lambda=Df$ 在数学上决定的。",
            "answer": "$$\\boxed{3.72 \\times 10^{-44}}$$"
        },
        {
            "introduction": "在临床实践中，仅仅判断病原体“是否存在”往往不够，了解其“数量多少”对于病情评估和治疗监控至关重要。本练习将向您展示如何通过添加已知数量的“内参”（spike-in）DNA，将相对的测序读数转化为每毫升样本中病原体基因组拷贝数等绝对浓度。掌握这一从头推导的校准方法是实现准确定量宏基因组学分析的核心技能。",
            "id": "5132005",
            "problem": "一份脑脊液样本通过宏基因组鸟枪法测序进行分析，以发现病原体。在裂解前立即加入一种合成的双链DNA内参（spike-in control），以实现绝对定量。您可以假设以下基本原则：在鸟枪法文库制备和测序过程中，片段是从输入的核酸分子池中进行无放回抽样；在均匀无偏的抽样下，分配给任一来源的测序读段（reads）的期望数量与该来源贡献的总输入核苷酸数量成正比；并且，对于单倍体生物，该来源贡献的总核苷酸数等于基因组拷贝数乘以单倍体基因组长度。内部对照的绝对定量使用内参来校准未知量。\n\n实验得出以下测量和已知量：\n- 处理的输入样本体积：$V_{\\text{in}} = 1.00 \\ \\mathrm{mL}$。\n- 裂解时添加的内参分子：$N_{\\text{spike}} = 5.00 \\times 10^{7}$ 个基因组拷贝，为长度 $L_{\\text{spike}} = 3.000 \\times 10^{3} \\ \\mathrm{bp}$ 的线性化质粒。\n- 测序配置：整个运行过程中为等长的双末端读段（paired-end reads）；在进行物种分类分配前，重复和低质量的读段已被移除。\n- 通过竞争性比对分配的后处理读段计数：\n  - 人：$2.70 \\times 10^{7}$ 个读段对。\n  - 内参：$6.00 \\times 10^{4}$ 个读段对。\n  - 一种目标细菌病原体（单倍体）：$4.00 \\times 10^{2}$ 个读段对。\n  - 所有其他物种的总和：对于本计算可忽略不计。\n- 检测到的细菌病原体的单倍体基因组长度为 $L_{\\text{path}} = 2.000 \\times 10^{6} \\ \\mathrm{bp}$。\n\n使用第一性原理且仅基于上述基本原则，从头推导一个表达式来估算原始样本中每毫升的细菌病原体基因组拷贝数，并计算其值。您必须在推导过程中明确证明您引入的每个建模步骤的合理性。将最终数值答案四舍五入至三位有效数字。以 拷贝/毫升（copies $\\mathrm{mL}^{-1}$）为单位表示最终浓度。\n\n除计算外，简要指出在该情境下内部标准校准有效所需的核心假设，并从概念层面解释其必要性。不要使用任何预先记下的快捷公式；相反，仅根据给定的基本原则和定义来构建您的推理过程。您最终报告的答案必须是一个实数。",
            "solution": "问题陈述已经过严格验证，被认为是自洽的、有科学依据且定义明确的。为得出唯一且有意义的解所需的所有必要数据和基本原则均已提供。因此，我们可以进行推导和计算。\n\n本分析的核心基本原则是，分配给任一来源的测序读段的期望数量与该来源贡献的总输入核苷酸数量成正比。设 $C_i$ 表示分配给来源 $i$ 的测序读段对的数量，设 $T_i$ 为来源 $i$ 在测序前对初始核酸池贡献的总核苷酸数。这种正比关系可以表示为：\n$$E[C_i] = k \\cdot T_i$$\n其中 $E[C_i]$ 是来源 $i$ 的读段计数的期望值，$k$ 是一个比例常数，它取决于总测序深度和其他系统性因素，但假设对样本中所有DNA来源都是相同的。\n\n该原则应用于我们感兴趣的两个非宿主来源：细菌病原体（记为 'path'）和内部内参（记为 'spike'）。\n对于病原体：\n$$E[C_{\\text{path}}] = k \\cdot T_{\\text{path}}$$\n对于内参：\n$$E[C_{\\text{spike}}] = k \\cdot T_{\\text{spike}}$$\n通过将这两个方程相除，未知的比例常数 $k$ 被消去。这是内部校准的基本原理，因为它将未知分析物（病原体）的测量值相对于已知的内部参照物（内参）进行了归一化。\n$$\\frac{E[C_{\\text{path}}]}{E[C_{\\text{spike}}]} = \\frac{k \\cdot T_{\\text{path}}}{k \\cdot T_{\\text{spike}}} = \\frac{T_{\\text{path}}}{T_{\\text{spike}}}$$\n在实际实验中，我们使用观测到的读段计数作为其期望值的估计，即 $C_i \\approx E[C_i]$。对于足够大的读段计数，这种近似是合理的。\n$$\\frac{C_{\\text{path}}}{C_{\\text{spike}}} = \\frac{T_{\\text{path}}}{T_{\\text{spike}}}$$\n第二个基本原则指出，对于单倍体生物，总核苷酸数是基因组拷贝数与单倍体基因组长度的乘积。设 $N_i$ 为基因组拷贝数，$L_i$ 为来源 $i$ 的基因组长度（单位为碱基对 bp）。\n病原体的总核苷酸数为：\n$$T_{\\text{path}} = N_{\\text{path}} \\cdot L_{\\text{path}}$$\n内参的总核苷酸数为：\n$$T_{\\text{spike}} = N_{\\text{spike}} \\cdot L_{\\text{spike}}$$\n这里，$N_{\\text{path}}$ 表示存在于初始样本体积 $V_{\\text{in}}$ 中的病原体基因组总拷贝数。\n\n将这些表达式代回比例方程，得到：\n$$\\frac{C_{\\text{path}}}{C_{\\text{spike}}} = \\frac{N_{\\text{path}} \\cdot L_{\\text{path}}}{N_{\\text{spike}} \\cdot L_{\\text{spike}}}$$\n我们的目标是确定病原体的浓度，这首先需要求解病原体基因组的绝对拷贝数 $N_{\\text{path}}$。整理方程得：\n$$N_{\\text{path}} = N_{\\text{spike}} \\cdot \\frac{C_{\\text{path}}}{C_{\\text{spike}}} \\cdot \\frac{L_{\\text{spike}}}{L_{\\text{path}}}$$\n这个推导出的表达式允许我们通过将观测到的读段计数比率与已知的基因组长度比率相关联，并用已知的内参数量进行缩放，来计算处理样本体积中的病原体基因组数量。\n\n问题要求最终答案以每毫升拷贝数（copies per milliliter）的浓度形式给出。设此浓度为 $\\rho_{\\text{path}}$。它被定义为病原体总拷贝数 $N_{\\text{path}}$ 除以输入样本体积 $V_{\\text{in}}$。\n$$\\rho_{\\text{path}} = \\frac{N_{\\text{path}}}{V_{\\text{in}}}$$\n代入 $N_{\\text{path}}$ 的表达式：\n$$\\rho_{\\text{path}} = \\frac{1}{V_{\\text{in}}} \\left( N_{\\text{spike}} \\cdot \\frac{C_{\\text{path}}}{C_{\\text{spike}}} \\cdot \\frac{L_{\\text{spike}}}{L_{\\text{path}}} \\right)$$\n现在我们将给定的数值代入此表达式。\n已知：\n- 输入体积：$V_{\\text{in}} = 1.00 \\ \\mathrm{mL}$\n- 内参拷贝数：$N_{\\text{spike}} = 5.00 \\times 10^{7}$ 拷贝\n- 内参读段对：$C_{\\text{spike}} = 6.00 \\times 10^{4}$\n- 病原体读段对：$C_{\\text{path}} = 4.00 \\times 10^{2}$\n- 内参长度：$L_{\\text{spike}} = 3.000 \\times 10^{3} \\ \\mathrm{bp}$\n- 病原体长度：$L_{\\text{path}} = 2.000 \\times 10^{6} \\ \\mathrm{bp}$\n\n计算：\n$$\\rho_{\\text{path}} = \\frac{1}{1.00 \\ \\mathrm{mL}} \\left( (5.00 \\times 10^{7}) \\cdot \\frac{4.00 \\times 10^{2}}{6.00 \\times 10^{4}} \\cdot \\frac{3.000 \\times 10^{3}}{2.000 \\times 10^{6}} \\right)$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times 10^{7} \\right) \\cdot \\left( \\frac{4.00}{6.00} \\times 10^{2-4} \\right) \\cdot \\left( \\frac{3.000}{2.000} \\times 10^{3-6} \\right) \\ \\mathrm{copies} \\cdot \\mathrm{mL}^{-1}$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times \\frac{2}{3} \\times 1.5 \\right) \\cdot \\left( 10^{7} \\times 10^{-2} \\times 10^{-3} \\right) \\ \\mathrm{copies} \\cdot \\mathrm{mL}^{-1}$$\n$$\\rho_{\\text{path}} = \\left( 5.00 \\times \\frac{2}{3} \\times \\frac{3}{2} \\right) \\cdot 10^{7-2-3} \\ \\mathrm{copies} \\cdot \\mathrm{mL}^{-1}$$\n$$\\rho_{\\text{path}} = 5.00 \\cdot 10^{2} \\ \\mathrm{copies} \\cdot \\mathrm{mL}^{-1}$$\n$$\\rho_{\\text{path}} = 500 \\ \\mathrm{copies} \\cdot \\mathrm{mL}^{-1}$$\n根据要求四舍五入到三位有效数字，其值为 $5.00 \\times 10^2$。\n\n除计算外，我们还需确定该内部标准校准有效所需的核心假设。\n\n1.  **从裂解开始的等效处理效率**：内参是一种合成裸露DNA分子，在样本裂解前加入。基本假设是，病原体的基因组DNA一旦从细胞中释放出来，其行为就与内参DNA在所有后续工作流程步骤中完全相同。这包括DNA提取/纯化、片段化、文库构建（末端修复、A尾添加、接头连接）和PCR扩增。至关重要的是，这要求裂解步骤本身是无偏的，并且能有效地从病原体中释放出核酸。如果病原体具有对裂解方法有抗性的坚固细胞壁，其DNA在初始池中将被低估，导致其浓度被严重低估。校准模型隐含地假设了100%的裂解效率，或者对所有生物的裂解效率都相同，这是一个很强的假设。\n\n2.  **无偏的测序和比对**：该模型基于“均匀无偏抽样”。这假设来自病原体和内参的DNA片段被测序的概率相等，与其一级序列无关。诸如极端的GC含量（$(\\text{G}+\\text{C})/(\\text{A}+\\text{T}+\\mathrm{G}+\\text{C})$）等因素会在PCR扩增和测序过程中引入已知的偏好。此外，生物信息学分析也必须是无偏的。用于竞争性比对的算法必须以同等的准确度和精密度将读段分配到其正确的来源，无论对于病原体还是内参序列。如果病原体序列更有可能因为模糊或错误比对（例如，由于与人类基因组的同源性）而被丢弃，则计数 $C_{\\text{path}}$ 将被人为地降低，再次导致对病原体载量的低估。\n\n3.  **对基因组长度的准确了解**：计算明确地依赖于基因组长度 $L_{\\text{path}}$ 和 $L_{\\text{spike}}$。该方法假设所使用的值是准确的。虽然内参的长度是通过设计精确已知的，但病原体的基因组长度是基于参考基因组的估计值。检测到的菌株与参考基因组之间在基因组大小上的显著差异可能会在定量中引入系统误差。其假设是参考基因组的长度能够足够准确地代表样本中病原体的实际基因组长度。",
            "answer": "$$\n\\boxed{5.00 \\times 10^{2}}\n$$"
        },
        {
            "introduction": "实际检测中，我们不仅要面对检测不到病原体的风险，还需处理来自环境或宿主的背景读数所造成的干扰。因此，我们需要一个理性的标准来判定一个样本是否为“阳性”。本计算练习将带您综合运用泊松（Poisson）分布模型、ROC曲线分析和决策理论，通过编程实践来确定一个最优的检出阈值，该阈值能够在假阳性和假阴性所带来的不同临床代价之间取得最佳平衡。",
            "id": "5132078",
            "problem": "您的任务是编写一个完整的、可运行的程序，该程序在分子与免疫诊断学领域内，为宏基因组鸟枪法测序中的病原体存在性建立二元检测决策模型。背景设定如下：测序分析为每个样本产生一个病原体特异性读取的计数，该计数被建模为在两种条件下源于泊松过程。在背景（无病原体）条件下，该计数被建模为速率为 $\\lambda_0$ 的泊松随机变量。在病原体存在条件下，该计数被建模为速率为 $\\lambda_1$ 的泊松随机变量。速率 $\\lambda_0$ 和 $\\lambda_1$ 表示以每百万读取数（RPM）为单位测量的期望计数，而观测到的计数是整数个读取数。决策规则由一个整数阈值 $\\tau$ 参数化：当且仅当观测到的计数 $k$ 满足 $k \\ge \\tau$ 时，预测病原体存在。\n\n您的程序必须为每个测试用例计算受试者工作特征（ROC）曲线和曲线下面积（AUC），然后根据指定的损失函数优化阈值。ROC曲线是当 $\\tau$ 在非负整数上变化时，假阳性率（FPR）和真阳性率（TPR）的参数图。AUC是ROC曲线从FPR为 $1$ 到FPR为 $0$ 的积分，根据离散的ROC点进行数值计算。阈值的优化需要最小化期望损失\n$$\nL(\\tau) = c_{\\mathrm{FP}} \\cdot (1 - \\pi) \\cdot \\mathrm{FPR}(\\tau) + c_{\\mathrm{FN}} \\cdot \\pi \\cdot \\big(1 - \\mathrm{TPR}(\\tau)\\big)\n$$\n其中 $\\pi$ 是患病率（样本中含有病原体的先验概率），$c_{\\mathrm{FP}}$ 是假阳性（FP）的成本，而 $c_{\\mathrm{FN}}$ 是假阴性（FN）的成本。优化阈值 $\\tau^*$ 定义为能达到最小期望损失的任何整数阈值。如果出现平局，选择能达到最小期望损失的最小 $\\tau$。\n\n您的推导应基于以下基础定义和广为接受的事实，这些是出发点：\n- 在宏基因组鸟枪法测序中，唯一映射到病原体基因组的读取数计数可以被建模为计数过程的结果。在固定的分析条件下，以恒定速率独立生成读取数会产生计数的泊松模型，其概率质量函数为 $$P(K = k \\mid \\lambda) = e^{-\\lambda} \\frac{\\lambda^k}{k!}$$ (对于整数 $k \\ge 0$ 和速率 $\\lambda  0$）。\n- 受试者工作特征（ROC）曲线关联了二元分类器在不同决策阈值下的 $\\mathrm{TPR}$ 和 $\\mathrm{FPR}$。曲线下面积（AUC）是一个标量性能摘要，对于完美分离等于 $1$，对于对称排序下无法区分的类别等于 $\\tfrac{1}{2}$。\n- 决策理论风险最小化结合了先验概率和错分类成本，以选择最小化期望损失的阈值。\n\n您的程序必须为每个测试用例实现以下步骤：\n1. 通过在整数阈值 $\\tau \\in \\{0,1,2,\\dots, T_{\\max}\\}$ 上评估 $\\mathrm{TPR}(\\tau)$ 和 $\\mathrm{FPR}(\\tau)$ 来构建离散的ROC曲线，其中 $T_{\\max}$ 是一个足够大的整数，使得在 $T_{\\max}$ 处及其之后，两个分布的尾部在数值上都可以忽略不计。使用基于由 $\\lambda_0$ 和 $\\lambda_1$ 参数化的泊松分布的上分位数的原则性方法来选择 $T_{\\max}$。\n2. 使用一致的数值积分方法，根据离散的ROC点计算数值AUC，确保 $\\mathrm{AUC} \\in [0,1]$。\n3. 对于给定的患病率 $\\pi$ 和损失权重 $c_{\\mathrm{FP}}$ 与 $c_{\\mathrm{FN}}$，计算每个阈值的期望损失 $L(\\tau)$，并根据上述平局处理规则选择最优阈值 $\\tau^*$。\n4. 为每个测试用例报告元组 [$\\tau^*$, $\\mathrm{AUC}$, $\\mathrm{FPR}(\\tau^*)$, $\\mathrm{TPR}(\\tau^*)$, $L(\\tau^*)$]，其中浮点数条目四舍五入到 $6$ 位小数，$\\tau^*$ 为整数。\n\n定义、单位和澄清：\n- 速率 $\\lambda_0$ 和 $\\lambda_1$ 是每百万总读取数的期望读取数，单位为每百万读取数（RPM），但阈值 $\\tau$ 和观测计数是原始读取数（整数计数）。\n- 假阳性率（FPR）是 $P(\\text{宣布有病原体} \\mid \\text{背景})$，真阳性率（TPR）是 $P(\\text{宣布有病原体} \\mid \\text{病原体存在})$。\n- 受试者工作特征（ROC）代表受试者工作特征（ROC），曲线下面积（AUC）代表曲线下面积（AUC）。\n- 假阳性（FP）和假阴性（FN）在上方首次出现时已定义。\n- 所有概率必须表示为小数，不使用百分号。\n\n要实现的测试套件：\n- 用例 1：$\\lambda_0 = 0.5$，$\\lambda_1 = 5.0$，$\\pi = 0.05$， $c_{\\mathrm{FP}} = 1.0$， $c_{\\mathrm{FN}} = 10.0$。\n- 用例 2（边界条件）：$\\lambda_0 = 2.0$，$\\lambda_1 = 2.0$，$\\pi = 0.5$， $c_{\\mathrm{FP}} = 1.0$， $c_{\\mathrm{FN}} = 1.0$。\n- 用例 3（微弱信号）：$\\lambda_0 = 0.8$，$\\lambda_1 = 1.2$，$\\pi = 0.1$， $c_{\\mathrm{FP}} = 1.0$， $c_{\\mathrm{FN}} = 3.0$。\n- 用例 4（高背景，中等分离度）：$\\lambda_0 = 10.0$，$\\lambda_1 = 20.0$，$\\pi = 0.2$， $c_{\\mathrm{FP}} = 2.0$， $c_{\\mathrm{FN}} = 1.0$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试用例，并且每个元素本身都是 [$\\tau^*$, $\\mathrm{AUC}$, $\\mathrm{FPR}(\\tau^*)$, $\\mathrm{TPR}(\\tau^*)$, $L(\\tau^*)$] 形式的列表。例如：[[1,0.900000,0.100000,0.950000,0.600000],[...]]。",
            "solution": "用户提供的问题已被评估并确定为有效。它具有科学依据，问题阐述清晰，客观且内部一致。因此，我们可以进行完整解答。\n\n该问题要求对基于测序读取数的病原体检测二元分类任务进行决策理论分析。问题的核心是对此过程进行建模，使用受试者工作特征（ROC）曲线和曲线下面积（AUC）评估分类器的性能，最后通过最小化指定的损失函数来选择一个最优决策阈值 $\\tau$。\n\n### 1. 检测问题的数学公式化\n\n该问题围绕两个相互竞争的假设构建：\n-   $H_0$：样本来自背景条件（无病原体）。观测到的读取数 $K$ 是一个遵循泊松分布的随机变量，其速率为 $\\lambda_0$。\n-   $H_1$：样本含有病原体。观测到的读取数 $K$ 是一个遵循泊松分布的随机变量，其速率为 $\\lambda_1$。\n\n一个速率参数为 $\\lambda$ 的泊松分布随机变量 $K$ 的概率质量函数（PMF）由下式给出：\n$$\nP(K=k \\mid \\lambda) = \\frac{e^{-\\lambda} \\lambda^k}{k!} \\quad \\text{for } k \\in \\{0, 1, 2, \\dots\\}\n$$\n决策规则基于一个整数阈值 $\\tau \\ge 0$ 建立。如果观测到的计数 $k$ 大于或等于 $\\tau$，则宣布病原体存在。\n$$\n\\text{决策} = \\begin{cases} \\text{病原体存在 (阳性)}   \\text{如果 } k \\ge \\tau \\\\ \\text{背景 (阴性)}  \\text{如果 } k  \\tau \\end{cases}\n$$\n\n### 2. 真阳性率和假阳性率\n\n该决策规则的性能由真阳性率（TPR）和假阳性率（FPR）来表征，它们是如下定义的条件概率：\n\n-   **真阳性率 (TPR)**，或灵敏度，是正确识别出含有病原体样本的概率。它是在状态为 $H_1$ 的条件下，观测到 $K \\ge \\tau$ 的概率。\n    $$\n    \\mathrm{TPR}(\\tau) = P(K \\ge \\tau \\mid H_1) = P(K \\ge \\tau \\mid \\lambda_1) = \\sum_{k=\\tau}^{\\infty} \\frac{e^{-\\lambda_1} \\lambda_1^k}{k!}\n    $$\n    这是速率为 $\\lambda_1$ 的泊松分布的生存函数（或互补累积分布函数，CCDF）。它可以计算为 $\\mathrm{TPR}(\\tau) = 1 - P(K  \\tau \\mid \\lambda_1) = 1 - P(K \\le \\tau - 1 \\mid \\lambda_1) = 1 - F_{\\text{Poisson}(\\lambda_1)}(\\tau-1)$，其中 $F$ 是累积分布函数（CDF）。\n\n-   **假阳性率 (FPR)**，或 $1 - \\text{特异性}$，是错误地将背景样本识别为含有病原体的概率。它是在状态为 $H_0$ 的条件下，观测到 $K \\ge \\tau$ 的概率。\n    $$\n    \\mathrm{FPR}(\\tau) = P(K \\ge \\tau \\mid H_0) = P(K \\ge \\tau \\mid \\lambda_0) = \\sum_{k=\\tau}^{\\infty} \\frac{e^{-\\lambda_0} \\lambda_0^k}{k!}\n    $$\n    类似地，这是速率为 $\\lambda_0$ 的泊松分布的生存函数，计算为 $\\mathrm{FPR}(\\tau) = 1 - F_{\\text{Poisson}(\\lambda_0)}(\\tau-1)$。\n\n当阈值 $\\tau$ 从 $0$ 增加到 $\\infty$ 时，$\\mathrm{TPR}(\\tau)$ 和 $\\mathrm{FPR}(\\tau)$ 都是非增的，范围从 $1$（对于 $\\tau=0$）到 $0$（当 $\\tau \\to \\infty$ 时）。\n\n### 3. ROC曲线和曲线下面积（AUC）\n\nROC曲线是在二维平面上，对于所有可能的阈值 $\\tau$ 所绘制的 $(\\mathrm{FPR}(\\tau), \\mathrm{TPR}(\\tau))$ 的参数图。对于我们的离散整数阈值集合 $\\tau \\in \\{0, 1, 2, \\dots, T_{\\max}\\}$，这会生成一组离散点。该曲线通常包括点 $(0,0)$（对于 $\\tau \\to \\infty$）和 $(1,1)$（对于 $\\tau=0$）。\n\n要计算ROC曲线和AUC：\n1.  选择一个足够大的上阈值 $T_{\\max}$，使得对于 $\\lambda_0$ 和 $\\lambda_1$，泊松概率 $P(K  T_{\\max})$ 都可以忽略不计。这可以通过寻找速率为 $\\max(\\lambda_0, \\lambda_1)$ 的泊松分布的高分位数来确定。\n2.  为一系列阈值（通常从 $T_{\\max}+1$ 递减到 $0$）计算ROC点 $(\\mathrm{FPR}(\\tau), \\mathrm{TPR}(\\tau))$。这将生成一组按x坐标（FPR）排序的 $(x,y)$ 坐标。\n3.  曲线下面积（AUC）是一个标量度量，总结了分类器的性能，代表其区分两个类别的能力。它是ROC曲线从 $\\mathrm{FPR}=0$到 $\\mathrm{FPR}=1$的积分。对于按 $x_i$ 排序的一组离散ROC点 $(x_i, y_i)$，AUC可以使用梯形法则进行数值计算：\n    $$\n    \\mathrm{AUC} = \\sum_{i=1}^{N} \\frac{y_i + y_{i-1}}{2} (x_i - x_{i-1})\n    $$\n    其中点为 $(x_0, y_0), (x_1, y_1), \\dots, (x_N, y_N)$。AUC为 $1.0$ 表示一个完美的分类器，而AUC为 $0.5$ 表示性能不优于随机猜测。\n\n### 4. 通过损失最小化选择最优阈值\n\n选择最优阈值 $\\tau^*$ 是为了最小化与错分类相关的期望损失或风险。损失函数 $L(\\tau)$ 如下：\n$$\nL(\\tau) = c_{\\mathrm{FP}} \\cdot (1 - \\pi) \\cdot \\mathrm{FPR}(\\tau) + c_{\\mathrm{FN}} \\cdot \\pi \\cdot \\mathrm{FNR}(\\tau)\n$$\n其中 $\\pi$ 是病原体存在的先验概率（患病率），$c_{\\mathrm{FP}}$ 是假阳性的成本， $c_{\\mathrm{FN}}$ 是假阴性的成本，而 $\\mathrm{FNR}(\\tau)$ 是假阴性率。\n\n假阴性率是在病原体存在时未能检测到它的概率：\n$$\n\\mathrm{FNR}(\\tau) = P(K  \\tau \\mid H_1) = 1 - P(K \\ge \\tau \\mid H_1) = 1 - \\mathrm{TPR}(\\tau)\n$$\n将此代入损失函数得到：\n$$\nL(\\tau) = c_{\\mathrm{FP}} \\cdot (1 - \\pi) \\cdot \\mathrm{FPR}(\\tau) + c_{\\mathrm{FN}} \\cdot \\pi \\cdot \\big(1 - \\mathrm{TPR}(\\tau)\\big)\n$$\n为了找到最优阈值 $\\tau^*$，我们将：\n1.  对于范围 $[0, T_{\\max}]$ 内的每个整数阈值 $\\tau$，计算 $L(\\tau)$。\n2.  识别该损失函数的最小值 $L_{\\min} = \\min_{\\tau} L(\\tau)$。\n3.  最优阈值 $\\tau^*$ 是使 $L(\\tau) = L_{\\min}$ 的最小整数 $\\tau$。\n\n该算法首先计算 $\\tau \\in [0, T_{\\max}]$ 的 $\\mathrm{FPR}(\\tau)$ 和 $\\mathrm{TPR}(\\tau)$ 向量，然后使用这些向量计算AUC和损失向量 $L(\\tau)$，从而确定最优阈值及相关的性能指标。对每个提供的测试用例都应用此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Solves the pathogen detection problem for a suite of test cases.\n    For each case, it calculates the optimal detection threshold, AUC,\n    and associated performance metrics by modeling read counts with\n    Poisson distributions and minimizing an expected loss function.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda_0, lambda_1, pi, c_fp, c_fn)\n        (0.5, 5.0, 0.05, 1.0, 10.0), # Case 1\n        (2.0, 2.0, 0.5, 1.0, 1.0),   # Case 2 (boundary condition)\n        (0.8, 1.2, 0.1, 1.0, 3.0),   # Case 3 (subtle signal)\n        (10.0, 20.0, 0.2, 2.0, 1.0)  # Case 4 (high background)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda0, lambda1, pi, c_fp, c_fn = case\n        \n        # 1. Construct the discrete ROC curve\n        # Choose T_max to ensure tails are negligible.\n        # We use the 1 - 1e-12 quantile of the larger Poisson lambda,\n        # plus a small buffer. We use max(..., 1) to handle small lambdas.\n        t_max = int(poisson.ppf(1 - 1e-12, max(lambda0, lambda1, 1))) + 10\n        \n        # Thresholds to evaluate for optimization\n        taus_opt = np.arange(0, t_max + 1)\n        \n        # Calculate FPR and TPR for each threshold.\n        # P(K = tau) = 1 - P(K = tau - 1) = 1 - CDF(tau - 1)\n        fprs = 1 - poisson.cdf(taus_opt - 1, lambda0)\n        tprs = 1 - poisson.cdf(taus_opt - 1, lambda1)\n        \n        # 2. Compute the numerical AUC\n        # For AUC calculation, we need ROC points sorted by ascending FPR.\n        # This is achieved by evaluating thresholds from high to low.\n        taus_roc = np.arange(t_max + 1, -1, -1)\n        roc_fpr = 1 - poisson.cdf(taus_roc - 1, lambda0)\n        roc_tpr = 1 - poisson.cdf(taus_roc - 1, lambda1)\n        \n        # Use a consistent numerical integration method (trapezoidal rule).\n        auc = np.trapz(roc_tpr, roc_fpr)\n        \n        # 3. Optimize the threshold under the loss function\n        # L(tau) = c_FP * (1 - pi) * FPR(tau) + c_FN * pi * (1 - TPR(tau))\n        losses = c_fp * (1 - pi) * fprs + c_fn * pi * (1 - tprs)\n        \n        # Find the index of the minimum loss. np.argmin() breaks ties\n        # by choosing the smallest index, which corresponds to the smallest tau.\n        opt_idx = np.argmin(losses)\n        \n        tau_star = taus_opt[opt_idx]\n        min_loss = losses[opt_idx]\n        fpr_at_tau_star = fprs[opt_idx]\n        tpr_at_tau_star = tprs[opt_idx]\n        \n        # 4. Report the tuple of results\n        result_tuple = [\n            int(tau_star),           # tau* as integer\n            auc,                     # AUC\n            fpr_at_tau_star,         # FPR(tau*)\n            tpr_at_tau_star,         # TPR(tau*)\n            min_loss                 # L(tau*)\n        ]\n        results.append(result_tuple)\n\n    # Final print statement in the exact required format.\n    # Floating-point entries are rounded to 6 decimal places.\n    output_parts = []\n    for r in results:\n        formatted_r = (\n            f\"[{r[0]},\"\n            f\"{r[1]:.6f},\"\n            f\"{r[2]:.6f},\"\n            f\"{r[3]:.6f},\"\n            f\"{r[4]:.6f}]\"\n        )\n        output_parts.append(formatted_r)\n    \n    print(f\"[{','.join(output_parts)}]\")\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}