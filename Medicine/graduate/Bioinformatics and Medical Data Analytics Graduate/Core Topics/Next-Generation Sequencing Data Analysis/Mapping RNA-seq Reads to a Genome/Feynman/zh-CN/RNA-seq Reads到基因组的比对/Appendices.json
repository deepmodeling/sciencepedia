{
    "hands_on_practices": [
        {
            "introduction": "在将RNA测序 (RNA-seq) 读段映射到基因组之前，首要的关键步骤是数据预处理。原始测序数据中常常混杂着接头序列和低质量碱基等技术噪音，这些噪音会严重干扰后续的比对准确性。本练习将指导您实现一个严谨的、基于算法的质量控制流程，它涵盖了从接头切除到质量剪切的各个方面，旨在加深您对序列预处理核心逻辑的理解。",
            "id": "4580665",
            "problem": "给定一组 FASTQ 格式的合成脱氧核糖核酸（DNA）测序读段，您的任务是实现一个严格的预处理和质量过滤流程，该流程与下游将核糖核酸测序（RNA-seq）读段映射到基因组的操作直接相关。该流程必须严格按照规定实现，并应用于所提供的测试套件。目标是基于经过充分检验的生物信息学原理，使用纯粹的数学和算法术语来形式化预处理逻辑。\n\n基本原理和定义：\n- Phred 质量得分定义：对于每次碱基检出，Phred 得分 $Q$ 定义为 $Q = -10 \\log_{10}(p_{\\mathrm{error}})$，其中 $p_{\\mathrm{error}}$ 是该碱基检出错误的概率。Sanger FASTQ 编码（Phred+33）将一个质量字符 $q$ 映射到 $Q = \\mathrm{ord}(q) - 33$，其中 $\\mathrm{ord}(\\cdot)$ 是整数代码点函数。\n- 独立性假设：在许多预处理工具使用的标准近似下，一个读段片段上的预期错误数可以计算为所有保留碱基的错误概率 $p_i = 10^{-Q_i/10}$ 之和。\n\n需要实现的目标预处理流程：\n1. $3'$ 端接头修剪：\n   - 设接头序列为固定字符串 $A$，读段序列为长度为 $n$ 的字符串 $S$，其对应的质量字符为 $q_1,\\dots,q_n$。\n   - 对于重叠长度 $L$（从 $|A|$ 向下迭代至 $k_{\\min}$），计算读段的后缀 $S[n-L+1,\\dots,n]$ 与接头的前缀 $A[1,\\dots,L]$ 之间按位置比较的错配数。如果对于遇到的第一个此类 $L$，错配数小于或等于 $m_{\\max}$，则从读段中精确修剪掉最后 $L$ 个碱基以及对应的最后 $L$ 个质量字符。如果没有找到这样的 $L$，则不进行修剪。\n2. 从两端进行滑动窗口质量修剪：\n   - 将每个质量字符映射到其 Phred 得分 $Q_i = \\mathrm{ord}(q_i)-33$。\n   - 左侧修剪规则：对于窗口大小 $w$ 和最低平均质量阈值 $Q_{\\min}$，扫描窗口 $[i,i+w-1]$（其中 $i=0,\\dots,n-w$）。找出最小的索引 $s$，使得在 $i=s$ 时算术平均值 $\\frac{1}{w}\\sum_{j=i}^{i+w-1} Q_j \\ge Q_{\\min}$ 成立。将保留的起始位置设为 $s$。如果没有窗口满足该阈值，则该读段被丢弃，输出为零。\n   - 右侧修剪规则：从右到左扫描窗口 $[e-w,e-1]$（其中 $e=w,\\dots,n$）。找出最大的索引 $e$，使得 $\\frac{1}{w}\\sum_{j=e-w}^{e-1} Q_j \\ge Q_{\\min}$ 成立。将保留的结束位置设为 $e$。如果没有窗口满足该阈值，则该读段被丢弃，输出为零。\n   - 保留的片段是 $S[s,\\dots,e-1]$，其质量得分为 $Q_s,\\dots,Q_{e-1}$。如果 $s \\ge e$，则该读段被丢弃，输出为零。\n3. 不明确碱基和长度过滤器：\n   - 设不明确碱基的比例为 $f_N = \\frac{\\text{count of 'N' in }S[s,\\dots,e-1]}{e-s}$。如果 $f_N > f_{N,\\max}$，则丢弃该读段。\n   - 如果保留长度 $\\ell = e-s$ 严格小于最小长度 $L_{\\min}$，则丢弃该读段。\n4. 为保留的读段报告的指标：\n   - 保留长度 $\\ell$，为整数。\n   - 平均碱基质量 $\\bar{Q} = \\frac{1}{\\ell}\\sum_{i=s}^{e-1} Q_i$，四舍五入到三位小数。\n   - 碱基检出预期错误数 $E = \\sum_{i=s}^{e-1} 10^{-Q_i/10}$，四舍五入到三位小数。\n   - 通过指示符，为一个布尔值。如果读段被保留，则为真（true）；如果被任何过滤器丢弃，则为假（false）。\n5. 对于被丢弃的读段的输出：\n   - 如果读段未通过任何过滤器，则输出四元组 $[\\ell,\\bar{Q},E,\\mathrm{pass}]$ 为 $[0,0.0,0.0,\\mathrm{false}]$。\n\n您的程序必须实现上述逻辑并处理以下测试套件。每个测试用例提供 $(S, q\\_str, A, w, Q_{\\min}, L_{\\min}, f_{N,\\max}, k_{\\min}, m_{\\max})$：\n- 测试用例 1（带接头修剪的正常流程）：\n  - $S$：字符串 \"ACGT\" 重复 $15$ 次，后跟 \"AGATCGGAAG\"。即 $S = \\text{\"ACGT\"} \\times 15 \\, \\Vert \\, \\text{\"AGATCGGAAG\"}$。\n  - $q\\_str$：字符 \"I\" 重复 $60$ 次，后跟 \"!\" 重复 $10$ 次。即 $q\\_str = \\text{\"I\"} \\times 60 \\, \\Vert \\, \\text{\"!\"} \\times 10$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 20$, $L_{\\min} = 30$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 2（高质量但不明碱基过多）：\n  - $S$：\"N\" 重复 $15$ 次，后跟 \"A\" 重复 $35$ 次。即 $S = \\text{\"N\"} \\times 15 \\, \\Vert \\, \\text{\"A\"} \\times 35$。\n  - $q\\_str$：\"I\" 重复 $50$ 次。即 $q\\_str = \\text{\"I\"} \\times 50$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 20$, $L_{\\min} = 30$, $f_{N,\\max} = 0.2$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 3（修剪后长度不足）：\n  - $S$：字符串 \"ACGT\" 重复 $10$ 次。即 $S = \\text{\"ACGT\"} \\times 10$。\n  - $q\\_str$：\"!\" 重复 $20$ 次，后跟 \"I\" 重复 $20$ 次。即 $q\\_str = \\text{\"!\"} \\times 20 \\, \\Vert \\, \\text{\"I\"} \\times 20$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 5$, $Q_{\\min} = 25$, $L_{\\min} = 30$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 0$。\n- 测试用例 4（无接头，两端混合质量，中等不明确碱基）：\n  - $S$：字符串 \"ACGT\" 重复 $10$ 次，后跟 \"NNNNN\"，再后跟 \"TGCA\" 重复 $5$ 次，最后是 \"ACGTA\"。即 $S = \\text{\"ACGT\"} \\times 10 \\, \\Vert \\, \\text{\"NNNNN\"} \\, \\Vert \\, \\text{\"TGCA\"} \\times 5 \\, \\Vert \\, \\text{\"ACGTA\"}$。\n  - $q\\_str$：\"!\" 重复 $3$ 次，后跟 \"I\" 重复 $64$ 次，再后跟 \"!\" 重复 $3$ 次。即 $q\\_str = \\text{\"!\"} \\times 3 \\, \\Vert \\, \\text{\"I\"} \\times 64 \\, \\Vert \\, \\text{\"!\"} \\times 3$。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 4$, $Q_{\\min} = 30$, $L_{\\min} = 50$, $f_{N,\\max} = 0.1$, $k_{\\min} = 8$, $m_{\\max} = 1$。\n- 测试用例 5（$w=1$ 的边界情况，用于逐碱基阈值处理）：\n  - $S$：\"ACGTACGTACGT\"。\n  - $q\\_str$：\"A5?@B?A=A>5?\"，其中每个字符通过 Phred+33 编码进行映射。\n  - $A$：\"AGATCGGAAGAGC\"。\n  - $w = 1$, $Q_{\\min} = 30$, $L_{\\min} = 5$, $f_{N,\\max} = 0.0$, $k_{\\min} = 6$, $m_{\\max} = 0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是 $[\\ell,\\bar{Q},E,\\mathrm{pass}]$ 形式的列表，其中 $\\ell$ 是整数，$\\bar{Q}$ 和 $E$ 是四舍五入到三位小数的浮点数，$\\mathrm{pass}$ 是布尔值。对于被丢弃的读段，输出 $[0,0.0,0.0,\\mathrm{false}]$。\n- 格式示例（非实际答案）：$[[12,35.200,0.015,\\mathrm{true}],[0,0.0,0.0,\\mathrm{false}],\\dots]$。",
            "solution": "问题陈述提出了一个来自生物信息学领域的、定义明确且有科学依据的任务：为 DNA 测序读段实现一个特定的序列预处理流程。该流程的组成部分——接头修剪、滑动窗口质量过滤以及基于长度和不明确碱基含量的过滤——都是为下游分析（例如将读段映射到参考基因组）准备原始测序数据的标准程序。所有参数、定义和算法步骤都以足够的精度进行了规定，可以实现唯一且确定性的实现。因此，该问题被认为是有效的。\n\n解决方案将以分步算法过程的形式呈现，将问题陈述中描述的逻辑形式化。所有数学实体都按要求使用 LaTeX 渲染。\n\n### I. 预处理算法的形式化\n\n设单个读段由碱基序列 $S$ 和相应的质量字符串 $q_{str}$ 表示。设流程参数为接头序列 $A$、窗口大小 $w$、最低平均质量阈值 $Q_{\\min}$、最小保留长度 $L_{\\min}$、最大不明确碱基比例 $f_{N,\\max}$、最小接头重叠长度 $k_{\\min}$ 和最大错配数 $m_{\\max}$。\n\n丢弃操作将导致输出 $[0, 0.0, 0.0, \\mathrm{false}]$。\n\n**步骤 0：初始转换**\n首先，使用 Sanger (Phred+33) 编码将输入的质量字符串 $q_{str}$ 转换为 Phred 质量得分数组 $Q_{arr}$：\n$$\n(Q_{arr})_i = \\mathrm{ord}((q_{str})_i) - 33\n$$\n其中 $\\mathrm{ord}(\\cdot)$ 是 ASCII 码点函数。设初始读段长度为 $n_0 = |S|$。\n\n**步骤 1：3' 端接头修剪**\n此步骤从读段的 $3'$ 端移除接头序列。\n1.  设当前读段为 $S'$，质量字符串为 $q'_{str}$。初始时，$S' \\leftarrow S$ 且 $q'_{str} \\leftarrow q_{str}$。\n2.  将重叠长度 $L$ 从 $L_{start} = \\min(|A|, |S'|)$ 向下迭代至 $k_{\\min}$。\n3.  对于每个 $L$，将读段长度为 $L$ 的后缀 $S'[\\text{end}-L+1 : \\text{end}]$ 与接头长度为 $L$ 的前缀 $A[1:L]$ 进行比较。\n4.  设错配数为 $m$。如果 $m \\le m_{\\max}$，则认为匹配成功。由于我们从最长的可能重叠向下迭代，因此找到的第一个匹配项即为我们接受的匹配项。\n5.  当找到长度为 $L$ 的此类匹配时，通过移除最后 $L$ 个字符来修剪读段及其质量字符串。\n    -   $S_{new} \\leftarrow S'[1 : \\text{end}-L]$\n    -   $q_{new\\_str} \\leftarrow q'_{str}[1 : \\text{end}-L]$\n    然后，此读段的处理终止，并使用修剪后的序列进入下一步。\n6.  如果循环完成仍未找到匹配项，则不修剪该读段。\n\n设此步骤后的读段序列和质量数组为 $S_1$ 和 $Q_1$，长度为 $n_1 = |S_1|$。如果 $n_1  w$，则该读段无法被滑动窗口过滤器处理，将被丢弃。\n\n**步骤 2：滑动窗口质量修剪**\n此步骤从读段的两端修剪低质量区域。\n1.  **左侧修剪（寻找起始位置 $s$）：**\n    我们从左到右扫描大小为 $w$ 的窗口。第一个平均质量达到阈值 $Q_{\\min}$ 的窗口定义了高质量区域的起点。\n    -   我们寻找最小的索引 $s \\in [0, n_1-w]$，使得：\n        $$\n        \\frac{1}{w} \\sum_{j=s}^{s+w-1} (Q_1)_j \\ge Q_{\\min}\n        $$\n    -   如果不存在这样的索引 $s$，则丢弃该读段。\n2.  **右侧修剪（寻找结束位置 $e$）：**\n    我们从右到左扫描大小为 $w$ 的窗口。最后一个平均质量达到阈值 $Q_{\\min}$ 的窗口定义了高质量区域的终点。\n    -   我们寻找最大的索引 $e \\in [w, n_1]$，使得以 $e-1$ 结尾的窗口满足条件：\n        $$\n        \\frac{1}{w} \\sum_{j=e-w}^{e-1} (Q_1)_j \\ge Q_{\\min}\n        $$\n    -   如果不存在这样的索引 $e$，则丢弃该读段。\n3.  **最终片段：** 保留的片段由区间 $[s, e)$ 定义。新的读段是 $S_2 = S_1[s:e]$，其质量得分是 $Q_2 = Q_1[s:e]$。如果 $s \\ge e$，则结果片段为空或无效，该读段被丢弃。\n\n**步骤 3：不明确碱基和长度过滤**\n对保留的读段 $S_2$ 进行最终检查。\n1.  **长度过滤器：**\n    保留读段的长度为 $\\ell = |S_2| = e-s$。如果 $\\ell  L_{\\min}$，则该读段太短，将被丢弃。\n2.  **不明确碱基过滤器：**\n    计算保留读段中不明确碱基（'N'）的比例 $f_N$：\n    $$\n    f_N = \\frac{\\text{count of 'N' in } S_2}{\\ell}\n    $$\n    如果 $f_N  f_{N,\\max}$，则该读段含有过多不明确碱基，将被丢弃。此检查仅在 $\\ell0$ 时执行。\n\n**步骤 4：为保留的读段计算指标**\n如果一个读段通过了所有过滤器，我们对最终序列 $S_2$ 及其长度为 $\\ell$ 的质量 $Q_2$ 计算以下指标：\n1.  **保留长度：** $\\ell$。\n2.  **平均碱基质量：** 保留碱基的 Phred 得分的算术平均值。\n    $$\n    \\bar{Q} = \\frac{1}{\\ell} \\sum_{i=0}^{\\ell-1} (Q_2)_i\n    $$\n3.  **预期错误数：** 每个保留碱基的错误概率之和。对于质量得分为 $(Q_2)_i$ 的碱基，其错误概率 $p_i$ 为 $p_i = 10^{-(Q_2)_i/10}$。\n    $$\n    E = \\sum_{i=0}^{\\ell-1} 10^{-(Q_2)_i/10}\n    $$\n4.  **通过指示符：** 一个布尔值，`true`。\n\n对于通过的读段，最终输出为 $[\\ell, \\mathrm{round}(\\bar{Q}, 3), \\mathrm{round}(E, 3), \\mathrm{true}]$。\n\n这个严格的多阶段流程确保只有高质量、具有生物学信息的序列被传递给后续计算更为密集的分析。下面的实现将精确遵循此描述的逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_read(S, q_str, A, w, Q_min, L_min, f_N_max, k_min, m_max):\n    \"\"\"\n    Implements the full preprocessing pipeline for a single DNA sequencing read.\n    \"\"\"\n    \n    # --- Step 1: Adapter Trimming ---\n    s_current, q_current = S, q_str\n    \n    # Iterate from longest possible overlap down to the minimum\n    adapter_len = len(A)\n    read_len_initial = len(s_current)\n    \n    trimmed = False\n    for L in range(min(adapter_len, read_len_initial), k_min - 1, -1):\n        if L == 0: continue\n        read_suffix = s_current[read_len_initial - L:]\n        adapter_prefix = A[:L]\n        \n        mismatches = sum(1 for i in range(L) if read_suffix[i] != adapter_prefix[i])\n        \n        if mismatches = m_max:\n            s_current = s_current[:read_len_initial - L]\n            q_current = q_current[:read_len_initial - L]\n            trimmed = True\n            break\n            \n    # --- Step 2: Quality Trimming ---\n    read_len_after_adapter = len(s_current)\n    \n    if read_len_after_adapter  w:\n        return [0, 0.0, 0.0, False]\n        \n    q_scores = np.array([ord(c) - 33 for c in q_current], dtype=float)\n    \n    if read_len_after_adapter == 0:\n        return [0, 0.0, 0.0, False]\n\n    if read_len_after_adapter == w:\n        window_avgs = np.array([np.mean(q_scores)])\n    else:\n        # Check if q_scores is empty which can happen if read_len_after_adapter > 0 but is very small\n        if q_scores.size == 0:\n            return [0, 0.0, 0.0, False]\n        window_avgs = np.convolve(q_scores, np.ones(w, dtype=float), 'valid') / w\n\n    qualifying_indices = np.where(window_avgs >= Q_min)[0]\n    \n    if qualifying_indices.size == 0:\n        return [0, 0.0, 0.0, False]\n        \n    s = qualifying_indices[0]\n    # The end of the retained segment is the end of the last qualifying window.\n    # The last qualifying window starts at index `qualifying_indices[-1]`.\n    # A window starting at index `i` ends at index `i+w-1`. The slice is `[i:i+w]`.\n    e = qualifying_indices[-1] + w\n    \n    if s >= e:\n        return [0, 0.0, 0.0, False]\n\n    # Apply the trim\n    s_trimmed = s_current[s:e]\n    q_trimmed_scores = q_scores[s:e]\n    \n    # --- Step 3: Ambiguity and Length Filters ---\n    retained_len = len(s_trimmed)\n    \n    if retained_len  L_min:\n        return [0, 0.0, 0.0, False]\n        \n    n_count = s_trimmed.count('N')\n    if retained_len > 0:\n      f_N = n_count / retained_len\n      if f_N > f_N_max:\n          return [0, 0.0, 0.0, False]\n\n    # --- Step 4: Metric Calculation ---\n    ell = retained_len\n    if ell == 0: # Should be caught by s>=e, but as a safeguard\n        return [0, 0.0, 0.0, False]\n\n    q_bar = np.mean(q_trimmed_scores)\n    expected_errors = np.sum(10**(-q_trimmed_scores / 10.0))\n    passed = True\n    \n    return [ell, round(q_bar, 3), round(expected_errors, 3), passed]\n    \n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the pipeline, and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (happy path with adapter trimming)\n        (\"ACGT\" * 15 + \"AGATCGGAAG\", \"I\" * 60 + \"!\" * 10, \"AGATCGGAAGAGC\", 5, 20, 30, 0.1, 8, 1),\n        # Test case 2 (high quality but excessive ambiguity)\n        (\"N\" * 15 + \"A\" * 35, \"I\" * 50, \"AGATCGGAAGAGC\", 5, 20, 30, 0.2, 8, 1),\n        # Test case 3 (insufficient length after trimming)\n        (\"ACGT\" * 10, \"!\" * 20 + \"I\" * 20, \"AGATCGGAAGAGC\", 5, 25, 30, 0.1, 8, 0),\n        # Test case 4 (adapter absent, mixed ends, moderate ambiguity)\n        (\"ACGT\" * 10 + \"NNNNN\" + \"TGCA\" * 5 + \"ACGTA\", \"!\" * 3 + \"I\" * 64 + \"!\" * 3, \"AGATCGGAAGAGC\", 4, 30, 50, 0.1, 8, 1),\n        # Test case 5 (boundary case with w=1 for base-wise thresholding)\n        (\"ACGTACGTACGT\", \"A5?@B?A=A>5?\", \"AGATCGGAAGAGC\", 1, 30, 5, 0.0, 6, 0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_read(*case)\n        results.append(result)\n\n    # Format the final output string as specified.\n    result_strings = []\n    for res in results:\n        l, q, E, p = res\n        if not p:\n            result_strings.append(\"[0,0.0,0.0,false]\")\n        else:\n            result_strings.append(f\"[{l},{q:.3f},{E:.3f},{str(p).lower()}]\")\n            \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "基因组的复杂性，例如加工假基因 (processed pseudogenes) 的存在，为RNA-seq读段的准确映射带来了挑战。本练习聚焦于一个核心比对难题：如何区分一个读段的真实来源是来自一个功能性的、经过剪接的基因，还是其不含内含子的假基因副本。通过应用贝叶斯定理，您将学习如何在一个统一的概率框架下，权衡序列错配和剪接位点等结构信息这两种不同类型的证据，从而做出有原则的推断。",
            "id": "4580753",
            "problem": "一个长度为 $L=100$ 个核苷酸的单端核糖核酸测序（RNA-seq）读段，其每个位置的Phred质量分均为 $Q=30$。考虑关于该读段在基因组中来源的两个互斥假设：$H_G$（它来源于一个已注释的蛋白质编码基因转录本）和 $H_P$（它来源于一个加工假基因位点）。该读段有两个候选比对：与基因位点的最佳比对是跨越一个已知的外显子-外显子连接的剪接比对，在 $L$ 个比对上的碱基中有 $m_G=1$ 个错配；与加工假基因位点的最佳比对是连续的，在 $L$ 个比对上的碱基中有 $m_P=0$ 个错配。\n\n使用以下基本假设，从第一性原理出发，推导出一个后验概率 $P(H_G \\mid D)$，该概率支持基因来源假设而非假基因来源假设，其中 $D$ 表示观测到的碱基检出以及存在与已注释的外显子-外显子连接一致的剪接比对：\n1. 每个碱基的测序错误是独立的，单个碱基的错误概率为 $\\epsilon_i = 10^{-Q_i/10}$。对于与参考序列匹配的碱基，发射概率为 $1-\\epsilon_i$。对于与参考序列不匹配的碱基，假设在三个不正确的核苷酸之间错误是均匀分布的，则发射概率为 $\\epsilon_i/3$。\n2. 结构比对证据被建模为一个独立的观测：如果读段确实来源于基因并跨越了连接点，则产生与注释一致的剪接比对的概率为 $\\rho_G$。如果它确实来源于加工假基因，则产生这样一个剪接比对的概率为 $\\rho_P$（加工假基因不含内含子，因此 $\\rho_P$ 小到可以忽略不计）。\n3. 来源的先验概率为：$H_G$ 的先验概率是 $\\pi_G$，$H_P$ 的先验概率是 $\\pi_P$，且 $\\pi_G+\\pi_P=1$。\n\n参数值为：对所有 $i \\in \\{1,\\dots, L\\}$，$Q_i=30$，$\\rho_G=0.9$，$\\rho_P=10^{-6}$，$\\pi_G=0.95$，以及 $\\pi_P=0.05$。\n\n仅从这些假设出发，推导后验概率 $P(H_G \\mid D)$ 的精确表达式，并将其数值计算为一个无单位的小数。将最终数值答案四舍五入到四位有效数字。",
            "solution": "用户要求推导和评估后验概率，这需要对问题陈述进行初步验证。\n\n### 步骤1：提取已知条件\n-   读段类型：单端核糖核酸测序（RNA-seq）\n-   读段长度：$L=100$ 个核苷酸\n-   Phred质量分：在每个位置均为 $Q=30$。\n-   假设 $H_G$：读段来源于一个已注释的蛋白质编码基因转录本。\n-   假设 $H_P$：读段来源于一个加工假基因位点。\n-   假设是互斥的。\n-   $H_G$ 的比对：跨越一个已知的外显子-外显子连接，有 $m_G=1$ 个错配。\n-   $H_P$ 的比对：连续的，有 $m_P=0$ 个错配。\n-   观测数据 $D$：观测到的碱基检出以及存在与已注释的外显子-外显子连接一致的剪接比对。\n-   假设1（测序错误模型）：错误是独立的。单个碱基错误概率为 $\\epsilon_i = 10^{-Q_i/10}$。匹配的发射概率为 $1-\\epsilon_i$。错配的发射概率为 $\\epsilon_i/3$。\n-   假设2（结构比对模型）：给定 $H_G$，产生剪接比对的概率为 $\\rho_G$。给定 $H_P$，产生剪接比对的概率为 $\\rho_P$。这是一个独立的观测。\n-   假设3（先验）：$H_G$ 的先验概率为 $\\pi_G$。$H_P$ 的先验概率为 $\\pi_P$。$\\pi_G+\\pi_P=1$。\n-   参数值：对所有 $i$，$Q_i=30$，$L=100$，$m_G=1$，$m_P=0$，$\\rho_G=0.9$，$\\rho_P=10^{-6}$，$\\pi_G=0.95$，$\\pi_P=0.05$。\n\n### 步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，采用了生物信息学中的标准模型和概念，如Phred分数、用于读段定位的贝叶斯推断，以及基因与加工假基因之间的区别。问题表述清晰，提供了推导所要求的后验概率唯一解所需的所有参数和假设。陈述客观，术语精确。没有内部矛盾、缺失数据或不符合科学常理的数值。该问题是将贝叶斯概率论应用于一个现实的基因组学场景的非平凡应用。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供完整的解答。\n\n### 解答推导\n目标是计算在给定观测数据 $D$ 的情况下，基因来源假设的后验概率 $P(H_G \\mid D)$。我们将使用贝叶斯定理。\n\n根据贝叶斯定理，后验概率为：\n$$ P(H_G \\mid D) = \\frac{P(D \\mid H_G) P(H_G)}{P(D)} $$\n分母 $P(D)$ 是观测到数据的总概率，也称为证据（evidence）。由于假设 $H_G$ 和 $H_P$ 是互斥的并且涵盖了整个模型空间（$\\pi_G + \\pi_P = 1$），我们可以使用全概率定律来表示证据：\n$$ P(D) = P(D \\mid H_G) P(H_G) + P(D \\mid H_P) P(H_P) $$\n先验概率给定为 $P(H_G) = \\pi_G$ 和 $P(H_P) = \\pi_P$。将这些代入后验概率的公式中得到：\n$$ P(H_G \\mid D) = \\frac{P(D \\mid H_G) \\pi_G}{P(D \\mid H_G) \\pi_G + P(D \\mid H_P) \\pi_P} $$\n数据 $D$ 由两个独立的部分组成：序列数据（我们将其表示为 $D_{\\text{seq}}$）和结构比对证据（我们将其表示为 $D_{\\text{struct}}$）。根据假设2，这些是独立的观测。因此，似然 $P(D \\mid H)$ 可以被分解为：\n$$ P(D \\mid H) = P(D_{\\text{seq}}, D_{\\text{struct}} \\mid H) = P(D_{\\text{seq}} \\mid H) P(D_{\\text{struct}} \\mid H) $$\n我们现在必须为每个假设推导似然项。\n\n首先，我们根据给定的均一Phred分数 $Q=30$ 计算均一的单个碱基错误概率 $\\epsilon$：\n$$ \\epsilon = 10^{-Q/10} = 10^{-30/10} = 10^{-3} $$\n一个正确的碱基检出（匹配）的概率是 $1-\\epsilon$。任何特定的不正确碱基检出（错配）的概率是 $\\epsilon/3$。\n\n假设 $H_G$ (基因来源)的似然：\n-   给定读段来源于一个基因，观测到剪接比对的概率为 $P(D_{\\text{struct}} \\mid H_G) = \\rho_G$。\n-   基因比对的序列数据在长度 $L=100$ 上有 $m_G=1$ 个错配和 $L-m_G = 99$ 个匹配。由于独立性假设，从基因模板生成这个特定序列的概率是每个碱基发射概率的乘积：\n$$ P(D_{\\text{seq}} \\mid H_G) = (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G} $$\n-   结合这些， $H_G$ 的总似然为：\n$$ P(D \\mid H_G) = \\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G} $$\n\n假设 $H_P$ (假基因来源)的似然：\n-   从一个连续的假基因位点观测到剪接比对的概率为 $P(D_{\\text{struct}} \\mid H_P) = \\rho_P$。\n-   假基因比对的序列数据有 $m_P=0$ 个错配和 $L-m_P=100$ 个匹配。从假基因模板生成此序列的概率为：\n$$ P(D_{\\text{seq}} \\mid H_P) = (1-\\epsilon)^{L-m_P} \\left(\\frac{\\epsilon}{3}\\right)^{m_P} = (1-\\epsilon)^{L} $$\n-   结合这些， $H_P$ 的总似然为：\n$$ P(D \\mid H_P) = \\rho_P (1-\\epsilon)^{L} $$\n\n现在，我们将这些完整的似然表达式代入后验概率公式：\n$$ P(H_G \\mid D) = \\frac{\\left[\\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G}\\right] \\pi_G}{\\left[\\rho_G (1-\\epsilon)^{L-m_G} \\left(\\frac{\\epsilon}{3}\\right)^{m_G}\\right] \\pi_G + \\left[\\rho_P (1-\\epsilon)^{L}\\right] \\pi_P} $$\n我们可以通过将分子和分母同除以公因式 $(1-\\epsilon)^{L-m_G}$ 来简化这个表达式：\n$$ P(H_G \\mid D) = \\frac{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G}}{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G} + \\rho_P \\pi_P (1-\\epsilon)^{L - (L-m_G)}} $$\n$$ P(H_G \\mid D) = \\frac{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G}}{\\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{m_G} + \\rho_P \\pi_P (1-\\epsilon)^{m_G}} $$\n这就是后验概率的最终简化解析表达式。\n\n最后，我们将给定的数值代入此表达式：\n-   $\\epsilon = 10^{-3}$\n-   $m_G = 1$\n-   $\\rho_G = 0.9$\n-   $\\pi_G = 0.95$\n-   $\\rho_P = 10^{-6}$\n-   $\\pi_P = 0.05$\n\n设分子为 $A$，分母中的第二项为 $B$。\n$$ A = \\rho_G \\pi_G \\left(\\frac{\\epsilon}{3}\\right)^{1} = (0.9)(0.95)\\left(\\frac{10^{-3}}{3}\\right) = (0.855)\\left(\\frac{1}{3} \\times 10^{-3}\\right) = 0.285 \\times 10^{-3} $$\n$$ B = \\rho_P \\pi_P (1-\\epsilon)^{1} = (10^{-6})(0.05)(1-10^{-3}) = (5 \\times 10^{-8})(0.999) = 4.995 \\times 10^{-8} $$\n现在，我们计算后验概率 $P(H_G \\mid D) = \\frac{A}{A+B}$：\n$$ P(H_G \\mid D) = \\frac{0.285 \\times 10^{-3}}{0.285 \\times 10^{-3} + 4.995 \\times 10^{-8}} $$\n为了计算这个值，我们可以将两个数表示成一致的格式：\n$$ P(H_G \\mid D) = \\frac{2.85 \\times 10^{-4}}{2.85 \\times 10^{-4} + 0.04995 \\times 10^{-6}} = \\frac{2.85 \\times 10^{-4}}{2.85 \\times 10^{-4} + 0.0004995 \\times 10^{-4}} $$\n$$ P(H_G \\mid D) = \\frac{2.85 \\times 10^{-4}}{2.85004995 \\times 10^{-4}} = \\frac{2.85}{2.85004995} $$\n$$ P(H_G \\mid D) \\approx 0.9999824767... $$\n将最终数值答案四舍五入到四位有效数字，我们得到 $0.9998$。",
            "answer": "$$\\boxed{0.9998}$$"
        },
        {
            "introduction": "在读段比对中，一个常见的问题是模糊性 (ambiguity)，即单个读段可以同等地、高质量地比对到基因组的多个位置。简单丢弃这些“多重映射”的读段会造成信息损失，尤其是在分析基因家族或重复序列时。本练习将引导您运用贝叶斯方法来解决这一难题，通过结合基因表达水平等先验知识，为每个候选比对位置计算后验概率。这种概率分配方法能够更准确地对基因表达进行定量，是高级RNA-seq分析的关键一步。",
            "id": "4580744",
            "problem": "给定一个核糖核酸测序 (RNA-seq) 读段比对的场景，其中单个读段的多个候选比对在与脱氧核糖核酸 (DNA) 参考序列比对时，达到了相同的最高比对分数。任务是使用从第一性原理推导出的、有原则的概率规则来解决这些等分候选对象之间的歧义，而非使用任意的平局打破规则。你必须使用的基本依据包括以下经过充分检验的事实和定义：(i) 用于计算后验概率的贝叶斯定理，(ii) 普遍接受的 RNA-seq 抽样模型，即从一个转录本中抽样一个片段的概率与其表达量乘以有效长度成正比，以及 (iii) 一个独立的错误模型，其中错配和插入缺失事件 (indel) 以每个事件固定的概率发生。\n\n具体来说，假设一个读段有 $n$ 个候选的基因组位点或剪接点比对，索引为 $i \\in \\{1,\\dots,n\\}$。每个候选比对都由比对中的错配数 $m_i$ 和 indel 事件数 $d_i$ 来表征。存在严格为正的错配事件错误概率 $e$ 和 indel 事件错误概率 $g$，满足 $0  e  1$ 和 $0  g  1$。对于每个位点 $i$，给定一个非负的表达量 $E_i$ 和一个有效长度 $L_i  0$。等分条件意味着所有考虑的候选比对都达到了某个比对评分函数的相同最大值；你不应再使用分数本身，而只应使用提供的错误计数以及从表达量和有效长度推导出的先验信息。\n\n仅从这些基础出发，推导一个歧义解决规则，该规则为每个读段计算候选对象上的后验概率向量，并以分数分配的形式输出这些后验概率，使得所有候选对象的概率之和为 $1$。你的程序应为下面描述的每个测试用例精确实现此规则。\n\n你不能在陈述之外发明任何额外的假设。你必须从贝叶斯定理、与表达量乘以有效长度成正比的抽样模型，以及独立错误模型出发，推导出一个可实现的计算方法，以产生候选比对上的归一化后验概率。\n\n为以下参数集的测试套件实现该计算。在每个测试用例中，给定元组 $(e, g, \\mathbf{E}, \\mathbf{L}, \\mathbf{m}, \\mathbf{d})$，其中 $\\mathbf{E}$、$\\mathbf{L}$、$\\mathbf{m}$ 和 $\\mathbf{d}$ 是按候选索引对齐的数组。\n\n- 测试用例 1 (理想情况；先验不同，错误计数相同):\n  - $e = 0.01$, $g = 0.001$\n  - $\\mathbf{E} = [50, 25]$\n  - $\\mathbf{L} = [1500, 1500]$\n  - $\\mathbf{m} = [1, 1]$\n  - $\\mathbf{d} = [0, 0]$\n- 测试用例 2 (先验相同；三个候选对象的错误概况不同):\n  - $e = 0.02$, $g = 0.001$\n  - $\\mathbf{E} = [10, 10, 10]$\n  - $\\mathbf{L} = [1000, 1000, 1000]$\n  - $\\mathbf{m} = [2, 1, 1]$\n  - $\\mathbf{d} = [0, 0, 1]$\n- 测试用例 3 (先验和错误精确抵消，导致两个候选对象上的后验质量相等):\n  - $e = 0.05$, $g = 0.001$\n  - $\\mathbf{E} = [50, 100]$\n  - $\\mathbf{L} = [100, 1000]$\n  - $\\mathbf{m} = [0, 1]$\n  - $\\mathbf{d} = [0, 0]$\n- 测试用例 4 (边界情况，一个候选对象的先验为零):\n  - $e = 0.01$, $g = 0.001$\n  - $\\mathbf{E} = [0, 20]$\n  - $\\mathbf{L} = [1000, 1000]$\n  - $\\mathbf{m} = [0, 0]$\n  - $\\mathbf{d} = [0, 0]$\n- 测试用例 5 (四路歧义，同时存在错配和 indel 事件):\n  - $e = 0.02$, $g = 0.02$\n  - $\\mathbf{E} = [100, 98, 102, 100]$\n  - $\\mathbf{L} = [100, 100, 100, 100]$\n  - $\\mathbf{m} = [1, 1, 1, 0]$\n  - $\\mathbf{d} = [0, 1, 0, 0]$\n\n对于每个测试用例，你的程序必须按给定顺序计算候选对象上的归一化后验概率向量，并四舍五入到 $6$ 位小数。四舍五入应独立应用于后验向量的每个分量。你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素是对应测试用例的、四舍五入后的后验概率向量，不含空格。例如，格式必须类似于 ‘[[a11,a12,...],[a21,a22,...],...]’，其中每个 $a_{ij}$ 是一个四舍五入到 $6$ 位的小数。\n\n此任务不涉及物理单位或角度。所有数字输出必须是指定的小数；输出的任何地方都不要使用百分号。通过严格遵守上述基本事实和假设来确保科学真实性，不要添加任何未经检验的启发式方法或任意的平局打破规则。",
            "solution": "目标是计算单个 RNA 测序读段在一组 $n$ 个候选比对上的后验概率分布，前提是所有候选比对共享相同的最高比对分数。令 $R$ 表示观测到该读段的事件，令 $C_i$（其中 $i \\in \\{1, \\dots, n\\}$）表示该读段起源于第 $i$ 个候选位点的事件。问题是为每个候选 $i$ 计算后验概率 $P(C_i | R)$。\n\n解决方案从第一性原理推导得出，始于贝叶斯定理。该定理提供了所求后验概率、每个候选的先验概率以及给定每个候选时观测到读段的似然之间的形式关系：\n$$\nP(C_i | R) = \\frac{P(R | C_i) P(C_i)}{\\sum_{j=1}^{n} P(R | C_j) P(C_j)}\n$$\n分母是一个归一化常数，确保后验概率之和为 $1$。为解决此问题，我们必须根据所提供的信息定义先验 $P(C_i)$ 和似然 $P(R | C_i)$ 的表达式。\n\n先验概率 $P(C_i)$ 表示在考虑读段本身的比对证据之前，一个读段起源于位点 $i$ 的概率。问题陈述指出，从一个转录本中抽样一个片段的概率与其表达量 $E_i$ 和有效长度 $L_i$ 成正比。这直接转化为先验概率的模型：\n$$\nP(C_i) \\propto E_i L_i\n$$\n我们可以为每个候选 $i$ 定义一个未归一化的先验权重 $\\pi_i = E_i L_i$。由于任何比例常数对于所有候选都是相同的，它将在最终的归一化步骤中被抵消。因此，我们可以使用这些未归一化的先验权重继续进行。\n\n似然 $P(R | C_i)$ 是在给定读段起源于位点 $i$ 的条件下，观测到特定读段序列 $R$ 的概率。问题指定了一个独立错误模型，其中错配和 indel 是独立事件，分别以每个事件固定的概率 $e$ 和 $g$ 发生。候选 $i$ 的比对以 $m_i$ 次错配和 $d_i$ 次 indel 事件为特征。“每个事件”模型最直接的解释是，一个读段从一个模板产生的似然与观测到的错误事件的联合概率成正比。在独立性假设下，这是单个事件概率的乘积。\n$$\nP(R | C_i) \\propto e^{m_i} g^{d_i}\n$$\n该似然模型关注错误的发生。其他因素，如匹配的概率，被隐含地假设在所有高分比对中是恒定的，或者被吸收到一个会被抵消的归一化常数中。问题框架本身将比对分数放在一边，这也支持了这种基于错误的聚焦似然模型。\n\n结合先验和似然，我们可以为每个候选 $i$ 计算一个未归一化的后验权重 $W_i$。这个权重与真实的后验概率 $P(C_i|R)$ 成正比。\n$$\nW_i \\propto P(R | C_i) P(C_i)\n$$\n代入我们推导的表达式，得到：\n$$\nW_i = (E_i L_i) \\cdot (e^{m_i} g^{d_i})\n$$\n在这里，我们通过将 $W_i$ 定义为未归一化的先验和成比例的似然项的乘积来使用等式。\n\n最后，为了获得后验概率向量，我们将这些权重归一化，使它们的和为 $1$。候选 $i$ 的后验概率是其权重除以所有权重的总和：\n$$\nP(C_i | R) = \\frac{W_i}{\\sum_{j=1}^{n} W_j} = \\frac{E_i L_i e^{m_i} g^{d_i}}{\\sum_{j=1}^{n} E_j L_j e^{m_j} g^{d_j}}\n$$\n这个公式提供了一个完整、有原则的歧义解决规则。\n\n实现此规则的算法如下：\n对于每个由参数 $(e, g, \\mathbf{E}, \\mathbf{L}, \\mathbf{m}, \\mathbf{d})$ 指定的测试用例：\n1. 对于从 $1$ 到 $n$ 的每个候选 $i$，计算未归一化的后验权重 $W_i = E_i L_i e^{m_i} g^{d_i}$。\n2. 计算总权重 $W_{total} = \\sum_{j=1}^{n} W_j$。\n3. 如果 $W_{total}$ 为 $0$（如果所有先验表达水平 $E_j$ 都为 $0$，则会发生这种情况），则后验概率未定义。一个合理的约定是为每个候选分配一个均匀概率 $1/n$。\n4. 如果 $W_{total}  0$，则计算每个候选的后验概率为 $P(C_i|R) = W_i / W_{total}$。\n5. 将所得后验概率向量的每个分量四舍五入到 $6$ 位小数。\n\n此过程严格遵守问题陈述中提供的原则和数据。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RNA-seq read mapping ambiguity problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'e': 0.01, 'g': 0.001, 'E': np.array([50, 25]), 'L': np.array([1500, 1500]), 'm': np.array([1, 1]), 'd': np.array([0, 0])},\n        # Test case 2\n        {'e': 0.02, 'g': 0.001, 'E': np.array([10, 10, 10]), 'L': np.array([1000, 1000, 1000]), 'm': np.array([2, 1, 1]), 'd': np.array([0, 0, 1])},\n        # Test case 3\n        {'e': 0.05, 'g': 0.001, 'E': np.array([50, 100]), 'L': np.array([100, 1000]), 'm': np.array([0, 1]), 'd': np.array([0, 0])},\n        # Test case 4\n        {'e': 0.01, 'g': 0.001, 'E': np.array([0, 20]), 'L': np.array([1000, 1000]), 'm': np.array([0, 0]), 'd': np.array([0, 0])},\n        # Test case 5\n        {'e': 0.02, 'g': 0.02, 'E': np.array([100, 98, 102, 100]), 'L': np.array([100, 100, 100, 100]), 'm': np.array([1, 1, 1, 0]), 'd': np.array([0, 1, 0, 0])},\n    ]\n\n    results = []\n    for case in test_cases:\n        e, g, E, L, m, d = case['e'], case['g'], case['E'], case['L'], case['m'], case['d']\n\n        # Calculate unnormalized prior weights: proportional to Expression * Length\n        prior_weights = E * L\n\n        # Calculate likelihoods: proportional to e^m * g^d\n        likelihoods = (e ** m) * (g ** d)\n\n        # Calculate unnormalized posterior weights\n        unnormalized_posteriors = prior_weights * likelihoods\n\n        # Normalize to get posterior probabilities\n        total_weight = np.sum(unnormalized_posteriors)\n\n        if total_weight == 0:\n            # This case occurs if all prior probabilities are zero (e.g., all E_i are 0).\n            # The posterior is ill-defined. A uniform distribution is a reasonable default.\n            num_candidates = len(E)\n            if num_candidates > 0:\n                posterior_probs = np.full(num_candidates, 1.0 / num_candidates)\n            else:\n                posterior_probs = np.array([])\n        else:\n            posterior_probs = unnormalized_posteriors / total_weight\n        \n        # Round each probability to 6 decimal places\n        rounded_probs = np.round(posterior_probs, 6).tolist()\n        results.append(rounded_probs)\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in results:\n        num_strs = [f\"{num:.6f}\" for num in res_list]\n        case_str = f\"[{','.join(num_strs)}]\"\n        case_strs.append(case_str)\n    \n    final_output = f\"[{','.join(case_strs)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}