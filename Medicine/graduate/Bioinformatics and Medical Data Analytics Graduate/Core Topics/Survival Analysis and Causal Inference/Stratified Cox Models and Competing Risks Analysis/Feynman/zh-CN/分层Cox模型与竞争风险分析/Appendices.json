{
    "hands_on_practices": [
        {
            "introduction": "在竞争风险分析中，一个常见但违反直觉的概念是原因别风险（cause-specific hazard）与其对应的累积发生率函数（cumulative incidence function）之间的关系。增加某一特定原因的瞬时风险率，并不总能导致该事件的累积发生概率增加。本练习  促使我们从第一性原理出发，深入探讨这些核心定义，以揭示竞争事件如何通过影响总体生存率，从而对特定原因的累积发生率产生看似矛盾的影响。",
            "id": "4610326",
            "problem": "一个生物信息学联盟研究一个多中心肿瘤学队列中的事件发生时间结局，该队列存在两种互斥的失败原因：心血管死亡（$k=1$）和癌症相关死亡（$k=2$）。个体因管理原因被右删失，且在给定协变量的情况下，删失与失败是独立的。在每个临床中心分层 $s$ 内，分析师们拟合了形式为 $h_k^{(s)}(t \\mid Z)=h_{0k}^{(s)}(t)\\exp(\\beta_k Z)$ 的特定原因分层比例风险（PH）模型，其中 $Z$ 是一个二元治疗指示变量，$h_{0k}^{(s)}(t)$ 是原因 $k$ 的一个未指定的、特定于分层的基线风险。分层 $s$ 中的总风险为 $h^{(s)}(t \\mid Z)=\\sum_{j=1}^{2} h_j^{(s)}(t \\mid Z)$。令 $S^{(s)}(t \\mid Z)$ 表示无事件生存率，$F_k^{(s)}(t \\mid Z)$ 表示分层 $s$ 中原因 $k$ 的累积发生率函数（CIF）。\n\n仅从竞争风险中特定原因风险、无事件生存率和累积发生率函数（CIF）的核心定义出发，论证当 $j \\neq k$ 时，$h_k^{(s)}(t \\mid Z)$ 和 $h_j^{(s)}(t \\mid Z)$ 的变化是否以及如何对 $F_k^{(s)}(t \\mid Z)$ 产生反直觉的效应。特别地，评估当其他原因的风险也发生变化时，增加 $h_k^{(s)}(t \\mid Z)$ 是否会导致在某个固定时间 $t$，$F_k^{(s)}(t \\mid Z)$ 反而减小。您的推理必须从第一性原理（竞争风险下的风险、生存率和累积发生率的定义）出发，并以科学合理的方程为基础。\n\n哪些陈述是正确的？\n\nA. 在一个双原因模型中，对于分层 $s$ 内风险不随时间变化的情况，存在这样的参数值：即使增加原因 $k$ 风险的治疗乘数，在某个有限时间 $t$ 仍会导致一个更低的 $F_k^{(s)}(t \\mid Z)$，因为其他原因风险的变化可以充分降低无事件生存率。\n\nB. 累积发生率函数 $F_k^{(s)}(t \\mid Z)$ 通过无事件生存率 $S^{(s)}(t \\mid Z)$ 同时依赖于 $h_k^{(s)}(t \\mid Z)$ 和其他原因的风险；因此，即使 $h_k^{(s)}(t \\mid Z)$ 增加，改变竞争原因的风险也可以改变 $F_k^{(s)}(t \\mid Z)$。\n\nC. 在分层 Cox 框架中，因为 $h_{0k}^{(s)}(t)$ 是未指定的，所以 $\\beta_k$ 的估计确保了增加 $h_k^{(s)}(t \\mid Z)$ 必然会在每个分层的每个时间点 $t$ 都增加 $F_k^{(s)}(t \\mid Z)$，无论其他原因风险如何变化。\n\nD. 如果在某个给定的分层中，其他原因的风险保持不变，那么在 $t$ 上逐点增加 $h_k^{(s)}(t \\mid Z)$ 会在每个时间点 $t$ 都增加 $F_k^{(s)}(t \\mid Z)$。\n\nE. 原因 $k$ 的 Fine–Gray 子分布风险与特定原因风险 $h_k^{(s)}(t \\mid Z)$ 是相同的，因此增加其中一个总是会以完全相同的方式在各个分层中增加另一个。",
            "solution": "必须首先确定问题陈述的有效性。\n\n### 步骤1：提取已知条件\n-   **背景：** 一项多中心肿瘤学研究，涉及两种互斥的失败原因：心血管死亡（$k=1$）和癌症相关死亡（$k=2$）。\n-   **删失：** 因管理原因进行右删失，且在给定协变量的情况下，删失与失败独立。\n-   **模型：** 对每个临床中心分层 $s$ 使用特定原因分层比例风险（PH）模型。\n-   **特定原因风险：** 在分层 $s$ 内，原因 $k$ 的风险为 $h_k^{(s)}(t \\mid Z)=h_{0k}^{(s)}(t)\\exp(\\beta_k Z)$。\n-   **协变量：** $Z$ 是一个二元治疗指示变量。\n-   **基线风险：** $h_{0k}^{(s)}(t)$ 是原因 $k$ 的一个未指定的、特定于分层的基线风险。\n-   **总风险：** 分层 $s$ 中任何失败的总风险为 $h^{(s)}(t \\mid Z)=\\sum_{j=1}^{2} h_j^{(s)}(t \\mid Z)$。\n-   **无事件生存率：** $S^{(s)}(t \\mid Z)$ 是在分层 $s$ 中到时间 $t$ 仍无事件的概率。\n-   **累积发生率函数 (CIF)：** $F_k^{(s)}(t \\mid Z)$ 是在分层 $s$ 中到时间 $t$ 时原因 $k$ 的累积发生率。\n-   **核心问题：** 任务是从第一性原理出发，评估增加特定原因风险 $h_k^{(s)}(t \\mid Z)$ 是否会在某个固定时间 $t$ 导致相应的累积发生率函数 $F_k^{(s)}(t \\mid Z)$ 减小，特别是在其他特定原因风险也发生变化的情况下。\n\n### 步骤2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题牢固地建立在竞争风险生存分析的既定统计理论框架内。所描述的定义和模型（$h_k$, $S$, $F_k$, 分层Cox模型）是生物统计学和医学数据分析中的标准方法。其前提是科学合理的。\n-   **适定性：** 这是一个理论性问题，要求基于所提供的数学定义来回答某一现象“是否以及如何”发生。这是一个适定的问题，可以通过逻辑推演和数学推导来回答。\n-   **客观性：** 问题以精确、客观和形式化的数学语言陈述。像“反直觉”这样的术语是在特定数学行为的背景下使用的（即一个速率函数的增加导致其相关累积函数的减少），这是该领域的一个众所周知特征。\n-   **结论：** 问题陈述没有科学缺陷、矛盾和歧义。它是一个有效的、适定的问题，适合进行严谨的分析。\n\n### 步骤3：裁决与行动\n问题是有效的。将进行完整的推导和选项评估。\n\n### 从第一性原理推导\n为了分析特定原因风险（$h_k$）和累积发生率函数（$F_k$）之间的关系，我们必须从它们在单个分层 $s$ 内的定义开始。为简化符号，推导过程中将省略分层上标 $(s)$，因为该逻辑在任何给定的分层内都同样适用。\n\n$1$. **无事件生存函数，$S(t \\mid Z)$：** 到时间 $t$ 为止未经历任何类型事件的概率。它由总风险 $h(t \\mid Z) = h_1(t \\mid Z) + h_2(t \\mid Z)$ 决定。\n其关系由下式给出：\n$$S(t \\mid Z) = \\exp\\left(-\\int_0^t h(u \\mid Z) \\, du\\right) = \\exp\\left(-\\int_0^t [h_1(u \\mid Z) + h_2(u \\mid Z)] \\, du\\right)$$\n\n$2$. **累积发生率函数，$F_k(t \\mid Z)$：** 到时间 $t$ 为止因原因 $k$ 而失败的概率。它是特定原因失败率对时间的积分，其中在任何时间 $u$ 的速率是特定原因风险 $h_k(u \\mid Z)$ 乘以当时处于风险中的概率 $S(u \\mid Z)$。\n$$F_k(t \\mid Z) = \\int_0^t h_k(u \\mid Z) S(u \\mid Z) \\, du$$\n\n将 $S(u \\mid Z)$ 的表达式代入 $F_k(t \\mid Z)$ 的定义中，揭示了以下依赖关系：\n$$F_k(t \\mid Z) = \\int_0^t h_k(u \\mid Z) \\exp\\left(-\\int_0^u [h_1(v \\mid Z) + h_2(v \\mid Z)] \\, dv\\right) \\, du$$\n这个方程表明，$F_k(t \\mid Z)$ 既通过被积函数的前置因子直接依赖于其自身的特定原因风险 $h_k$，也通过指数中的生存函数间接依赖于它。关键是，它还通过生存函数依赖于竞争原因的风险 $h_j(t \\mid Z)$（$j \\neq k$）。\n\n核心问题是，增加 $h_k(t \\mid Z)$ 是否会导致 $F_k(t \\mid Z)$ 减少。如果 $h_j(t \\mid Z)$ ($j \\neq k$) 的同时变化导致 $S(t \\mid Z)$ 的减少幅度足够大，超过了 $h_k(t \\mid Z)$ 项的增加，这种情况就可能发生。\n\n### 逐项分析\n\n**A. 在一个双原因模型中，对于分层 $s$ 内风险不随时间变化的情况，存在这样的参数值：即使增加原因 $k$ 风险的治疗乘数，在某个有限时间 $t$ 仍会导致一个更低的 $F_k^{(s)}(t \\mid Z)$，因为其他原因风险的变化可以充分降低无事件生存率。**\n\n为评估此项，我们构建一个具有恒定风险（指数模型）的数值示例，并为清晰起见省略分层上标。设原因 $k=1$，竞争原因为 $j=2$。风险为 $h_k(t \\mid Z) = \\lambda_k(Z)$。\n累积发生率函数为 $F_k(t \\mid Z) = \\int_0^t \\lambda_k(Z) e^{-(\\lambda_1(Z) + \\lambda_2(Z))u} du = \\frac{\\lambda_k(Z)}{\\lambda_1(Z) + \\lambda_2(Z)} [1 - e^{-(\\lambda_1(Z) + \\lambda_2(Z))t}]$。\n\n-   **情景1（未治疗，$Z=0$）：** 设基线风险为 $\\lambda_1(0) = 0.1$ 和 $\\lambda_2(0) = 0.1$。\n    原因1的累积发生率函数为 $F_1(t \\mid Z=0) = \\frac{0.1}{0.1+0.1}[1 - e^{-0.2t}] = 0.5[1 - e^{-0.2t}]$。\n    在时间 $t=5$ 时，$F_1(5 \\mid Z=0) = 0.5(1 - e^{-1}) \\approx 0.5 \\times 0.6321 = 0.316$。\n\n-   **情景2（治疗，$Z=1$）：** 假设治疗增加了原因1的风险，例如增加到 $\\lambda_1(1) = 0.2$。这对应于风险比为 $2$。现在，假设该治疗对竞争风险也有非常强的影响，将其增加到 $\\lambda_2(1) = 1.8$。\n    此时原因1的累积发生率函数为 $F_1(t \\mid Z=1) = \\frac{0.2}{0.2+1.8}[1 - e^{-(0.2+1.8)t}] = \\frac{0.2}{2.0}[1 - e^{-2t}] = 0.1[1 - e^{-2t}]$。\n    在时间 $t=5$ 时，$F_1(5 \\mid Z=1) = 0.1(1-e^{-10}) \\approx 0.1 \\times 0.99995 = 0.1$。\n\n比较在 $t=5$ 时的两种情景，我们得到 $F_1(5 \\mid Z=1) \\approx 0.1  0.316 \\approx F_1(5 \\mid Z=0)$，尽管治疗使原因1的特定原因风险增加了一倍（$\\lambda_1(1) > \\lambda_1(0)$）。这种悖论效应的发生是因为竞争风险 $\\lambda_2$ 的大幅增加急剧降低了无事件生存率，使得因原因1而失败的风险个体减少。因此，该陈述是正确的。\n\n**结论：正确。**\n\n**B. 累积发生率函数 $F_k^{(s)}(t \\mid Z)$ 通过无事件生存率 $S^{(s)}(t \\mid Z)$ 同时依赖于 $h_k^{(s)}(t \\mid Z)$ 和其他原因的风险；因此，即使 $h_k^{(s)}(t \\mid Z)$ 增加，改变竞争原因的风险也可以改变 $F_k^{(s)}(t \\mid Z)$。**\n\n该陈述是对从第一性原理推導出的数学结构的直接阐述。如前所示，$F_k(t \\mid Z) = \\int_0^t h_k(u \\mid Z) S(u \\mid Z) \\, du$。生存函数 $S(u \\mid Z)$ 是累积总风险的函数，而累积总风险是所有特定原因风险的总和。因此，$F_k$ 明确地依赖于 $h_k$ 和所有竞争风险 $h_j$（通过 $S$）。其结论是，当 $h_k$ 增加时，改变竞争风险可以改变 $F_k$（并且如A选项所示，甚至可以使其减小），这是一个正确的逻辑推论。\n\n**结论：正确。**\n\n**C. 在分层 Cox 框架中，因为 $h_{0k}^{(s)}(t)$ 是未指定的，所以 $\\beta_k$ 的估计确保了增加 $h_k^{(s)}(t \\mid Z)$ 必然会在每个分层的每个时间点 $t$ 都增加 $F_k^{(s)}(t \\mid Z)$，无论其他原因风险如何变化。**\n\n该陈述是错误的。核心问题是底层概率模型的属性，而不是估计方法的属性。对A选项的分析表明，如果竞争风险也发生变化，增加 $h_k$ 不必然增加 $F_k$。使用偏似然法估计特定原因风险模型中的 $\\beta_k$ 时，会将其他原因的事件视为删失数据。这种方法能正确估计协变量对 $h_k$ 的瞬时效应，但它并不能改变累积发生率函数 $F_k$ 依赖于所有风险这一基本数学事实。声称该估计方法“确保”了一个对于模型本身在数学上是错误的属性，这是不正确的。\n\n**结论：不正确。**\n\n**D. 如果在某个给定的分层中，其他原因的风险保持不变，那么在 $t$ 上逐点增加 $h_k^{(s)}(t \\mid Z)$ 会在每个时间点 $t$ 都增加 $F_k^{(s)}(t \\mid Z)$。**\n\n这提出了一个不同的、受约束的情景。设 $h_k(t)$ 和 $h_k'(t)$ 是原因 $k$ 的两个风险函数，使得对于所有 $t \\ge 0$ 都有 $h_k'(t) \\ge h_k(t)$，并且在某个区间上为严格不等。设所有竞争原因的风险 $h_j(t)$（$j \\neq k$）保持不变。这可以使用竞争风险的潜在失败时间解释来证明。\n假设存在独立的潜在失败时间 $T_k, T_j$，其风险函数分别为 $h_k(t), h_j(t)$。观测到的事件时间为 $T = \\min(T_k, T_j)$，如果 $T_k  T_j$，则原因为 $C=k$。\n累积发生率函数为 $F_k(t) = P(T_k \\le t, T_k  T_j)$。\n风险从 $h_k(t)$ 增加到 $h_k'(t)$ 对应于一个新的潜在失败时间 $T_k'$，它随机小于 $T_k$。这意味着我们可以在一个共同的概率空间上构造耦合的随机变量，使得对于每个结果 $\\omega$ 都有 $T_k'(\\omega) \\le T_k(\\omega)$，而 $T_j(\\omega)$ 保持不变。\n考虑事件 $\\{T_k \\le t, T_k  T_j\\}$ 发生的任何结果 $\\omega$。对于这个结果，$T_k(\\omega) \\le t$ 且 $T_k(\\omega)  T_j(\\omega)$。\n由于 $T_k'(\\omega) \\le T_k(\\omega)$，可以立即得出 $T_k'(\\omega) \\le t$ 且 $T_k'(\\omega)  T_j(\\omega)$。\n因此，事件 $\\{T_k \\le t, T_k  T_j\\}$ 中的任何结果也都在事件 $\\{T_k' \\le t, T_k'  T_j\\}$ 中。\n这意味着 $\\{T_k \\le t, T_k  T_j\\} \\subseteq \\{T_k' \\le t, T_k'  T_j\\}$。\n因此，$P(\\{T_k \\le t, T_k  T_j\\}) \\le P(\\{T_k' \\le t, T_k'  T_j\\})$，这意味着原因 $k$ 的累积发生率函数必须增加（或保持不变）。这一性质在竞争风险理论中是公认的。该陈述是正确的。\n\n**结论：正确。**\n\n**E. 原因 $k$ 的 Fine–Gray 子分布风险与特定原因风险 $h_k^{(s)}(t \\mid Z)$ 是相同的，因此增加其中一个总是会以完全相同的方式在各个分层中增加另一个。**\n\n该陈述从根本上就是错误的。特定原因风险 $h_k(t)$ 和子分布风险 $\\gamma_k(t)$ 是不同的量。\n-   **特定原因风险：** $h_k(t) = \\lim_{\\Delta t \\to 0} \\frac{1}{\\Delta t} P(t \\le T  t+\\Delta t, \\text{原因}=k \\mid T \\ge t)$。风险集是在时间 $t$ 仍无事件的个体。\n-   **子分布风险：** $\\gamma_k(t) = \\lim_{\\Delta t \\to 0} \\frac{1}{\\Delta t} P(t \\le T  t+\\Delta t, \\text{原因}=k \\mid T \\ge t \\text{ 或 } (T  t \\text{ 且 原因} \\neq k))$。风险集包括无事件的个体*以及*已经因竞争原因而失败的个体。\n\n由于 $\\gamma_k(t)$ 的风险集大于或等于 $h_k(t)$ 的风险集，而分子（原因 $k$ 的事件数）相同，因此对于所有 $t$ 都有 $\\gamma_k(t) \\le h_k(t)$。它们并不相同（除非在 $t=0$ 时）。该陈述的前提是错误的。\n\n**结论：不正确。**",
            "answer": "$$\\boxed{ABD}$$"
        },
        {
            "introduction": "理解了竞争风险的基本概念后，下一步是掌握如何拟合模型以从数据中估计参数。分层Cox模型的拟合核心在于最大化部分对数似然函数，这通常通过牛顿-拉弗森（Newton-Raphson）等数值优化算法实现。这个练习  提供了一个动手实践的机会，通过推导并实现该算法的关键组成部分——梯度（gradient）和黑塞矩阵（Hessian matrix），来揭示模型系数是如何从数据中迭代估计出来的。",
            "id": "4610379",
            "problem": "给定按离散分层进行分层的 Cox 比例风险模型的设置。对于每个分层，基线风险可以任意不同，而回归系数在所有分层中共享。对于特定原因的竞争风险分析，当关注选定的目标原因时，所有由其他原因导致的失败都在其观测时间被视为右删失。考虑一个监督学习问题，任务是计算采用 Breslow 结点处理方法的 Cox 模型的分层部分对数似然的梯度和 Hessian 矩阵，然后针对选定的特定原因的部分对数似然，对回归系数向量执行单次 Newton–Raphson 更新。\n\n从以下基本基础开始：Cox 比例风险模型假定，在任何分层 $s$ 内，对于具有协变量向量 $x \\in \\mathbb{R}^p$ 的受试者，在时间 $t$ 的风险函数为 $h_s(t \\mid x) = h_{0s}(t) \\exp(x^\\top \\beta)$，其中 $h_{0s}(t)$ 是一个未指定的非负基线风险函数，可以因分层而异，而 $\\beta \\in \\mathbb{R}^p$ 是一个共享的回归系数向量。在分层 $s$ 中，时间 $t$ 的风险集是在时间 $t$ 之前尚未失败或被删失的所有受试者的索引集合，对于离散的观测时间，可以实现为观测时间 $T_i \\ge t$ 的那些受试者。对于具有目标原因 $c$ 的竞争风险，将特定原因事件指示符 $\\delta_i^{(c)}$ 定义为：如果受试者 $i$ 在其观测时间因原因 $c$ 而失败，则为 $1$，否则为 $0$；其他原因被视为右删失。对于存在结点的事件时间，使用 Breslow 近似法。\n\n您的任务是：\n- 根据模型定义和部分似然的条件概率论证，推导出在上述 Breslow 结点近似法和特定原因删失条件下，分层部分对数似然关于 $\\beta$ 的梯度向量和 Hessian 矩阵的显式公式。\n- 实现一个程序，对于下面每个指定的测试用例，使用您推导出的公式计算梯度、Hessian 矩阵以及 $\\beta$ 的一次 Newton–Raphson 更新。Newton–Raphson 更新必须是求解得分方程求根问题的方法，即通过在当前迭代点减去 Hessian 矩阵的逆乘以梯度来更新 $\\beta$。\n\n需遵循的约定和实现细节：\n- 所有计算必须分层进行：风险集和事件集在每个分层内部分别形成，对目标函数、梯度和 Hessian 矩阵的贡献则按分层求和。\n- 对存在结点的失败使用 Breslow 近似法：在给定分层中的任何一个不同事件时间 $t$，如果发生 $m$ 个目标原因的事件，则在时间 $t$ 的贡献会将相同的风险集分母重复 $m$ 次。\n- 一个分层内时间 $t$ 的风险集包括该分层中所有观测时间 $T_i \\ge t$ 的受试者。\n- 为了在计算指数和时保持数值稳定性，您可以在每个事件时间减去风险集上的最大线性预测值（这不会改变加权和的比率）。\n- 如果某个测试用例的 Hessian 矩阵是奇异的，请使用 Moore–Penrose 伪逆来计算最小二乘 Newton 步。\n\n测试套件：\n- 测试用例 1 (数据集 A，原因 1)：\n  - 受试者数量 $n = 8$；协变量数量 $p = 2$；分层数量 $= 2$。\n  - 观测时间 $T = [2, 3, 3, 5, 1, 4, 4, 6]$。\n  - 分层标签 $s = [0, 0, 0, 0, 1, 1, 1, 1]$。\n  - 原因标签 $k = [1, 2, 1, 0, 0, 1, 2, 2]$，其中 $0$ 表示右删失，$1, 2$ 表示竞争性失败原因。\n  - 协变量矩阵\n  $\n  X =\n  \\begin{bmatrix}\n  0.5   1.0 \\\\\n  1.0   -0.5 \\\\\n  -0.5   0.5 \\\\\n  0.0   0.0 \\\\\n  1.5   -1.0 \\\\\n  -1.0   1.0 \\\\\n  0.25   0.75 \\\\\n  -0.75   -0.25\n  \\end{bmatrix}.\n  $\n  - 目标原因 $c = 1$。\n  - 初始系数 $\\beta^{(0)} = [0.0, 0.0]$。\n- 测试用例 2 (数据集 A，原因 2)：\n  - $T, s, k, X$ 与数据集 A 相同。\n  - 目标原因 $c = 2$。\n  - 初始系数 $\\beta^{(0)} = [0.2, -0.1]$。\n- 测试用例 3 (数据集 B，原因 1，在第一时间点有同时发生的竞争事件)：\n  - 受试者数量 $n = 3$；协变量数量 $p = 2$；分层数量 $= 1$。\n  - 观测时间 $T = [1, 1, 2]$。\n  - 分层标签 $s = [0, 0, 0]$。\n  - 原因标签 $k = [1, 2, 1]$。\n  - 协变量矩阵\n  $\n  X =\n  \\begin{bmatrix}\n  0.0   0.0 \\\\\n  1.0   0.0 \\\\\n  0.0   1.0\n  \\end{bmatrix}.\n  $\n  - 目标原因 $c = 1$。\n  - 初始系数 $\\beta^{(0)} = [0.1, 0.2]$。\n\n您的程序必须：\n- 对于每个测试用例，计算梯度向量 $g(\\beta^{(0)})$、Hessian 矩阵 $H(\\beta^{(0)})$ 以及更新后的系数向量 $\\beta^{(1)} = \\beta^{(0)} - H(\\beta^{(0)})^{-1} g(\\beta^{(0)})$，其中 $H(\\cdot)^{-1}$ 表示矩阵的逆，如果需要则为 Moore–Penrose 伪逆。\n- 生成单行输出，包含一个由方括号括起来的逗号分隔列表。对于每个测试用例，按顺序将以下序列附加到输出中：梯度向量的分量（按索引升序），然后是 Hessian 矩阵的条目（按行主序，$H_{00}, H_{01}, H_{10}, H_{11}$），然后是更新后的系数向量的分量（按索引升序）。按测试用例 1、2、3 的顺序连接这些序列。\n- 所有输出必须是实数（浮点数）。不涉及物理单位；不要包含任何百分号或单位。\n\n您的代码必须是一个完整的、可运行的程序，对给定的输入执行这些计算，并以指定格式精确打印一行。",
            "solution": "该问题要求在竞争风险设置下，推导并实现分层 Cox 比例风险模型的梯度和 Hessian 矩阵，然后执行单次 Newton-Raphson 更新步骤。分析必须在特定原因删失和处理事件时间结点的 Breslow 近似法下进行。\n\n### 1. 模型和似然公式\n\n分层 Cox 模型假定，在分层 $s$ 中，具有协变量向量 $x_i \\in \\mathbb{R}^p$ 的受试者 $i$ 的风险函数由下式给出：\n$$ h_s(t \\mid x_i) = h_{0s}(t) \\exp(x_i^\\top \\beta) $$\n其中 $h_{0s}(t)$ 是分层 $s$ 的任意非负基线风险函数，而 $\\beta \\in \\mathbb{R}^p$ 是回归系数向量，假定在所有分层中是共同的。\n\n在竞争风险设置中，我们关注特定的失败原因 $c$。所有由其他原因导致的失败都被视为右删失观测。受试者 $i$ 的事件指示符是 $\\delta_i^{(c)}$，如果受试者 $i$ 在其观测时间 $T_i$ 因原因 $c$ 而失败，则为 $1$，否则为 $0$（即，如果他们被右删失或因 $c$ 以外的原因失败）。\n\n部分似然是通过考虑在每个事件时间，以风险集为条件，观测到的失败集合的概率来构建的。对于分层模型，总部分似然是每个分层部分似然的乘积。\n设分层 $s$ 中原因 $c$ 的不同事件时间为 $t_{s,1}  t_{s,2}  \\dots  t_{s, K_s}$。\n设 $D_{s,j}$ 是在分层 $s$ 中于时间 $t_{s,j}$ 因原因 $c$ 失败的受试者集合，并设 $d_{s,j} = |D_{s,j}|$ 为此类失败的数量。\n设 $R_s(t)$ 是分层 $s$ 在时间 $t$ 的风险集，定义为分层 $s$ 中在时间 $t$ 之前尚未失败或被删失的所有受试者 $k$ 的集合，即 $T_k \\ge t$。\n\n在处理结点的 Breslow 近似法下，分层 $s$ 的部分似然为：\n$$ \\mathcal{L}_s(\\beta) = \\prod_{j=1}^{K_s} \\frac{ \\prod_{i \\in D_{s,j}} \\exp(x_i^\\top \\beta) }{ \\left( \\sum_{k \\in R_s(t_{s,j})} \\exp(x_k^\\top \\beta) \\right)^{d_{s,j}} } $$\n总部分似然为 $\\mathcal{L}(\\beta) = \\prod_{s} \\mathcal{L}_s(\\beta)$。相应的总部分对数似然 $L(\\beta) = \\log \\mathcal{L}(\\beta)$ 是各分层特定对数似然之和：\n$$ L(\\beta) = \\sum_{s} L_s(\\beta) = \\sum_{s} \\sum_{j=1}^{K_s} \\left( \\sum_{i \\in D_{s,j}} x_i^\\top \\beta - d_{s,j} \\log \\left( \\sum_{k \\in R_s(t_{s,j})} \\exp(x_k^\\top \\beta) \\right) \\right) $$\n\n### 2. 部分对数似然的梯度（得分向量）\n\n对数似然的梯度，也称为得分向量，是 $g(\\beta) = \\nabla_\\beta L(\\beta)$。我们对 $L(\\beta)$ 关于向量 $\\beta$ 的每个分量 $\\beta_q$ 进行微分。\n为简化符号，我们定义在给定时间的风险集 $R$ 上的以下总和：\n- $S^{(0)}(\\beta, R) = \\sum_{k \\in R} \\exp(x_k^\\top \\beta)$\n- $S^{(1)}(\\beta, R) = \\sum_{k \\in R} x_k \\exp(x_k^\\top \\beta)$（一个 $p \\times 1$ 向量）\n- $S^{(2)}(\\beta, R) = \\sum_{k \\in R} x_k x_k^\\top \\exp(x_k^\\top \\beta)$（一个 $p \\times p$ 矩阵）\n\n对数似然可以写为：\n$$ L(\\beta) = \\sum_s \\sum_{j=1}^{K_s} \\left( \\sum_{i \\in D_{s,j}} x_i^\\top \\beta - d_{s,j} \\log S^{(0)}(\\beta, R_s(t_{s,j})) \\right) $$\n关于 $\\beta$ 微分：\n$$ \\nabla_\\beta L(\\beta) = \\sum_s \\sum_{j=1}^{K_s} \\left( \\sum_{i \\in D_{s,j}} x_i - d_{s,j} \\frac{\\nabla_\\beta S^{(0)}(\\beta, R_s(t_{s,j}))}{S^{(0)}(\\beta, R_s(t_{s,j}))} \\right) $$\n因为 $\\nabla_\\beta S^{(0)}(\\beta, R) = \\sum_{k \\in R} x_k \\exp(x_k^\\top \\beta) = S^{(1)}(\\beta, R)$，我们有：\n$$ g(\\beta) = \\sum_s \\sum_{j=1}^{K_s} \\left( \\sum_{i \\in D_{s,j}} x_i - d_{s,j} \\frac{S^{(1)}(\\beta, R_s(t_{s,j}))}{S^{(0)}(\\beta, R_s(t_{s,j}))} \\right) $$\n设 $E(\\beta, R) = \\frac{S^{(1)}(\\beta, R)}{S^{(0)}(\\beta, R)}$ 为风险集 $R$ 中协变量向量的风险加权平均值。该表达式可以重写为对所有因原因 $c$ 失败的个体 $i$ 的求和：\n$$ g(\\beta) = \\sum_{i \\text{ s.t. } \\delta_i^{(c)}=1} \\left( x_i - E(\\beta, R_{s(i)}(T_i)) \\right) $$\n其中 $s(i)$ 是受试者 $i$ 的分层，$T_i$ 是其失败时间。这是因为项 $\\sum_{i \\in D_{s,j}} x_i$ 是对一组存在结点的失败的求和，而项 $d_{s,j} E(\\beta, R)$ 可以表示为 $\\sum_{i \\in D_{s,j}} E(\\beta, R)$。\n\n### 3. 部分对数似然的 Hessian 矩阵\n\nHessian 矩阵 $H(\\beta)$ 包含 $L(\\beta)$ 的二阶偏导数。它是通过将梯度 $g(\\beta)$ 对 $\\beta^\\top$ 微分得到的。\n$$ H(\\beta) = \\nabla_\\beta g(\\beta)^\\top $$\n梯度表达式中的第一项 $\\sum \\sum \\sum x_i$ 相对于 $\\beta$ 是常数，因此其导数为零。我们只需要对第二项进行微分。\n$$ H(\\beta) = -\\sum_s \\sum_{j=1}^{K_s} d_{s,j} \\nabla_\\beta \\left( \\frac{S^{(1)}(\\beta, R_{s,j})}{S^{(0)}(\\beta, R_{s,j})} \\right)^\\top $$\n使用向量函数的商法则，我们求得该比率的导数：\n$$ \\nabla_\\beta \\left( \\frac{S^{(1)}}{S^{(0)}} \\right)^\\top = \\frac{S^{(2)}}{S^{(0)}} - \\frac{S^{(1)}(S^{(1)})^\\top}{(S^{(0)})^2} = \\frac{S^{(2)}}{S^{(0)}} - \\left(\\frac{S^{(1)}}{S^{(0)}}\\right) \\left(\\frac{S^{(1)}}{S^{(0)}}\\right)^\\top $$\n这个表达式表示风险集上协变量的协方差矩阵，我们称之为 $V(\\beta, R) = E[XX^\\top] - E[X]E[X]^\\top$。\n\n因此，Hessian 矩阵为：\n$$ H(\\beta) = -\\sum_s \\sum_{j=1}^{K_s} d_{s,j} \\left[ \\frac{S^{(2)}(\\beta, R_s(t_{s,j}))}{S^{(0)}(\\beta, R_s(t_{s,j}))} - E(\\beta, R_s(t_{s,j})) E(\\beta, R_s(t_{s,j}))^\\top \\right] $$\nHessian 矩阵是观测信息矩阵 $I(\\beta) = -H(\\beta)$ 的负数，该矩阵是半正定的。\n\n### 4. Newton-Raphson 更新\n\nNewton-Raphson 方法是一种用于寻找得分方程 $g(\\beta) = 0$ 根的迭代过程。从初始猜测 $\\beta^{(0)}$ 到下一个迭代 $\\beta^{(1)}$ 的系数向量 $\\beta$ 的更新规则是：\n$$ \\beta^{(1)} = \\beta^{(0)} - [H(\\beta^{(0)})]^{-1} g(\\beta^{(0)}) $$\n如果 Hessian 矩阵 $H(\\beta^{(0)})$ 是奇异的，则其逆矩阵未定义。在这种情况下，使用 Moore-Penrose 伪逆（表示为 $H(\\beta^{(0)})^+$）代替标准逆矩阵。这为线性系统 $H(\\beta^{(0)}) \\Delta \\beta = -g(\\beta^{(0)})$ 提供了一个最小二乘解，其中 $\\Delta \\beta = \\beta^{(1)} - \\beta^{(0)}$。\n\n### 5. 实现策略\n\n计算过程是通过迭代所有分层，并在每个分层内，迭代目标原因的唯一事件时间。\n1.  对于每个测试用例，识别受试者及其数据：时间 $T$、分层 $s$、原因标签 $k$、协变量 $X$、目标原因 $c$ 和初始 $\\beta^{(0)}$。\n2.  将梯度 $g$ 和 Hessian 矩阵 $H$ 初始化为零向量/矩阵。\n3.  遍历每个唯一的分层标签。\n4.  在每个分层内，识别出因原因 $c$ 发生失败的唯一时间点。\n5.  遍历这些唯一的事件时间 $t$。\n    a. 统计在时间 $t$ 因原因 $c$ 导致的失败次数 $d$。\n    b. 形成该分层中所有满足 $T_i \\ge t$ 的受试者的风险集 $R$。\n    c. 对于风险集 $R$，在 $\\beta^{(0)}$ 处计算总和 $S^{(0)}, S^{(1)}, S^{(2)}$。使用一个数值稳定技巧：对于每个风险集，在进行指数运算前，通过减去其最大值来平移线性预测值 $x_k^\\top \\beta$。这不会改变计算中使用的比率。\n    d. 更新总梯度：$g \\leftarrow g + (\\sum_{i \\in D} x_i) - d \\cdot (S^{(1)}/S^{(0)})$。\n    e. 更新总 Hessian 矩阵：$H \\leftarrow H - d \\cdot [S^{(2)}/S^{(0)} - (S^{(1)}/S^{(0)})(S^{(1)}/S^{(0)})^\\top]$。\n6.  遍历所有分层和事件时间后，计算更新后的系数向量 $\\beta^{(1)} = \\beta^{(0)} - H^+ g$。\n7.  每个测试用例的最终结果由 $g$ 的分量、$H$ 的行主序扁平化分量以及 $\\beta^{(1)}$ 的分量组成。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"T\": np.array([2, 3, 3, 5, 1, 4, 4, 6]),\n            \"s\": np.array([0, 0, 0, 0, 1, 1, 1, 1]),\n            \"k\": np.array([1, 2, 1, 0, 0, 1, 2, 2]),\n            \"X\": np.array([\n                [0.5, 1.0], [1.0, -0.5], [-0.5, 0.5], [0.0, 0.0],\n                [1.5, -1.0], [-1.0, 1.0], [0.25, 0.75], [-0.75, -0.25]\n            ]),\n            \"c\": 1,\n            \"beta0\": np.array([0.0, 0.0])\n        },\n        {\n            \"T\": np.array([2, 3, 3, 5, 1, 4, 4, 6]),\n            \"s\": np.array([0, 0, 0, 0, 1, 1, 1, 1]),\n            \"k\": np.array([1, 2, 1, 0, 0, 1, 2, 2]),\n            \"X\": np.array([\n                [0.5, 1.0], [1.0, -0.5], [-0.5, 0.5], [0.0, 0.0],\n                [1.5, -1.0], [-1.0, 1.0], [0.25, 0.75], [-0.75, -0.25]\n            ]),\n            \"c\": 2,\n            \"beta0\": np.array([0.2, -0.1])\n        },\n        {\n            \"T\": np.array([1, 1, 2]),\n            \"s\": np.array([0, 0, 0]),\n            \"k\": np.array([1, 2, 1]),\n            \"X\": np.array([\n                [0.0, 0.0],\n                [1.0, 0.0],\n                [0.0, 1.0]\n            ]),\n            \"c\": 1,\n            \"beta0\": np.array([0.1, 0.2])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        grad, hess, beta1 = compute_update(\n            case[\"T\"], case[\"s\"], case[\"k\"], case[\"X\"], case[\"c\"], case[\"beta0\"]\n        )\n        \n        # Append results in specified order: grad, hess (row-major), beta1\n        results.extend(grad.tolist())\n        results.extend(hess.flatten().tolist())\n        results.extend(beta1.tolist())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef compute_update(T, s, k, X, c, beta0):\n    \"\"\"\n    Computes the gradient, Hessian, and one Newton-Raphson update for a given test case.\n    \n    Args:\n        T (np.array): Observed times.\n        s (np.array): Strata labels.\n        k (np.array): Cause labels.\n        X (np.array): Covariate matrix.\n        c (int): Cause of interest.\n        beta0 (np.array): Initial coefficient vector.\n        \n    Returns:\n        tuple: (gradient, hessian, beta_updated)\n    \"\"\"\n    n, p = X.shape\n    \n    # Event indicator for the cause of interest\n    delta_c = (k == c)\n    \n    # Initialize gradient and Hessian\n    grad = np.zeros(p)\n    hess = np.zeros((p, p))\n    \n    # Get unique strata\n    strata_labels = np.unique(s)\n    \n    # Loop over strata\n    for stratum_label in strata_labels:\n        stratum_mask = (s == stratum_label)\n        T_stratum = T[stratum_mask]\n        X_stratum = X[stratum_mask]\n        delta_c_stratum = delta_c[stratum_mask]\n        \n        # Get unique event times in this stratum where an event of cause 'c' occurred\n        event_times = np.unique(T_stratum[delta_c_stratum])\n        \n        # Loop over unique event times\n        for t in event_times:\n            # Indices of individuals failing at time t from cause c in this stratum\n            fail_mask_stratum = (T_stratum == t)  delta_c_stratum\n            d = np.sum(fail_mask_stratum)\n            \n            if d == 0:\n                continue\n                \n            # Covariates of failing individuals\n            X_fail = X_stratum[fail_mask_stratum]\n            sum_X_fail = np.sum(X_fail, axis=0)\n            \n            # Risk set at time t in this stratum\n            risk_mask_stratum = (T_stratum = t)\n            X_risk = X_stratum[risk_mask_stratum]\n            \n            if X_risk.shape[0] == 0:\n                continue\n\n            # Calculate S0, S1, S2\n            eta_risk = X_risk @ beta0\n            \n            # Numerical stability: shift eta by its max value\n            if eta_risk.size  0:\n                eta_max = np.max(eta_risk)\n                w = np.exp(eta_risk - eta_max)\n            else:\n                w = np.array([])\n            \n            S0 = np.sum(w)\n\n            if S0 == 0:\n                continue\n            \n            # S1 is a p-dim vector\n            S1 = (X_risk.T @ w)\n            \n            # S2 is a p x p matrix: X_risk.T @ diag(w) @ X_risk\n            S2 = (X_risk.T * w) @ X_risk\n            \n            # Update gradient\n            E = S1 / S0\n            grad += sum_X_fail - d * E\n            \n            # Update Hessian\n            V = (S2 / S0) - np.outer(E, E)\n            hess -= d * V\n            \n    # Perform one Newton-Raphson update\n    # beta_new = beta_old - H^-1 * g\n    # Use pseudoinverse for stability or in case of singularity\n    hess_pinv = np.linalg.pinv(hess)\n    beta1 = beta0 - hess_pinv @ grad\n    \n    return grad, hess, beta1\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "在成功估计模型系数 $\\beta$ 之后，我们便可以将模型应用于预测和解释。这是竞争风险分析的最终目标：为个体提供量化的风险评估。本练习  聚焦于此应用，指导您计算特定协变量值的个体的原因别累积风险函数和累积发生率函数。这些是评估预后和解释协变量在竞争风险框架下效应的关键指标。",
            "id": "4610316",
            "problem": "给定一个竞争风险队列，该队列具有两种失败原因和右删失，在分层 Cox 比例风险框架下进行分析。存在两个层，由标签 $A$ 和 $B$ 表示。在每个层内，基线风险是未指定的，并允许因层而异，而协变量效应被假定为跨层通用，但特定于原因。假设是：(i) 独立的右删失，(ii) 每个层内的比例风险，这是事件时间数据一个经过充分检验的建模原则，以及 (iii) 将风险解释为强度的计数过程。对于一个具有标量协变量值 $x$ 的受试者，在层 $s$ 中原因 $k$ 的特定原因风险建模为 $h_{k,s}(t \\mid x) = h_{0,k,s}(t) \\exp(x \\,\\beta_k)$，其中 $h_{0,k,s}(t)$ 是特定于层和原因的基线风险，而 $\\beta_k$ 是跨层共享的特定原因回归系数。对于一个受试者，原因 $k$ 的累积特定原因风险是其风险的时间聚合。总生存函数由随时间累积的特定原因风险之和决定。原因 $k$ 的累积发生率函数必须通过将总生存与在观测到的事件时间点的特定原因风险增量复合得到。所有积分都将作为相关层中观测到的不同事件时间上的总和进行数值计算，并且基线风险增量将使用 Breslow 型方法从每个层的观测数据中进行非参数估计：在给定层中，对于原因 $k$ 的每个不同事件时间点，基线风险增量等于在该时间点观测到的原因 $k$ 的事件数除以在该层该时间点的风险集上 $\\exp(x \\,\\beta_k)$ 的总和。\n\n数据描述。每条记录是一个元组 $(\\text{stratum}, t, \\delta, x)$，其中 $\\text{stratum} \\in \\{A,B\\}$ 表示层，$t$ 是观测时间，$\\delta \\in \\{0,1,2\\}$ 是事件指示符，其中 $0$ 表示删失，$1$ 表示因原因 $1$ 失败，$2$ 表示因原因 $2$ 失败，$x$ 是一个标量协变量。数据如下：\n\n层 $A$:\n- (A, 1.0, 1, -0.2)\n- (A, 2.0, 0, 0.5)\n- (A, 3.0, 2, 1.2)\n- (A, 4.0, 1, 0.0)\n- (A, 5.0, 0, -1.0)\n- (A, 6.5, 2, 0.7)\n- (A, 7.2, 1, 1.5)\n- (A, 7.8, 0, -0.4)\n- (A, 8.0, 2, 0.3)\n- (A, 9.0, 0, 0.9)\n\n层 $B$:\n- (B, 0.8, 2, -0.1)\n- (B, 1.5, 0, 0.2)\n- (B, 2.2, 1, -0.8)\n- (B, 3.0, 0, 1.1)\n- (B, 3.3, 1, 0.5)\n- (B, 4.1, 2, 1.0)\n- (B, 4.9, 0, -0.6)\n- (B, 5.2, 1, 0.4)\n- (B, 6.0, 2, -1.2)\n- (B, 6.5, 0, 0.0)\n\n模型参数。特定原因的回归系数为：\n- $\\beta_1 = 0.6$\n- $\\beta_2 = -0.4$\n\n计算任务。对于层 $s^\\star$ 中协变量值为 $x^\\star$ 的受试者，仅使用层 $s^\\star$ 中观测到的事件时间来：\n- 如上所述，在这些事件时间点分别为每个原因估计基线风险增量。\n- 在比例风险结构下，聚合这些增量以计算截至给定时间 $t^\\star$ 的受试者特定累积原因风险函数。\n- 基于这些，计算每一步的总生存率，并复合特定原因的风险增量，以获得在 $t^\\star$ 评估的每个原因的累积发生率函数。\n\n测试套件。您的程序必须按此确切顺序，为每个测试案例 ($s^\\star, x^\\star, t^\\star$) 计算四个值\n$[\\Lambda_1(t^\\star \\mid x^\\star, s^\\star),\\; \\Lambda_2(t^\\star \\mid x^\\star, s^\\star),\\; F_1(t^\\star \\mid x^\\star, s^\\star),\\; F_2(t^\\star \\mid x^\\star, s^\\star)]$，\n其中 $\\Lambda_k(\\cdot)$ 表示原因 $k$ 的累积特定原因风险，而 $F_k(\\cdot)$ 表示通过将生存率与截至 $t^\\star$ 的观测事件时间内的特定原因风险增量复合而构建的原因 $k$ 的累积发生率函数。使用以下测试案例：\n- ($s^\\star=A, x^\\star=0.0, t^\\star=4.0$)\n- ($s^\\star=A, x^\\star=1.0, t^\\star=7.0$)\n- ($s^\\star=B, x^\\star=-0.5, t^\\star=3.5$)\n- ($s^\\star=B, x^\\star=0.2, t^\\star=0.0$)\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按给定顺序连接每个测试案例的四个值。即，输出必须是\n$[\\Lambda_1^{(1)},\\Lambda_2^{(1)},F_1^{(1)},F_2^{(1)},\\Lambda_1^{(2)},\\Lambda_2^{(2)},F_1^{(2)},F_2^{(2)},\\Lambda_1^{(3)},\\Lambda_2^{(3)},F_1^{(3)},F_2^{(3)},\\Lambda_1^{(4)},\\Lambda_2^{(4)},F_1^{(4)},F_2^{(4)}]$，\n其中上标表示从 $1$ 到 $4$ 的测试案例索引。\n\n角度单位或物理单位不适用；就本问题而言，时间是无量纲的，所有数值输出必须是纯实数。",
            "solution": "该问题是有效的，因为它在科学上基于竞争风险分析中使用分层Cox比例风险模型的既定生物统计学框架。问题设定良好，为获得唯一的数值解提供了所有必要的数据和参数。语言是客观的，所需的计算遵循该领域的标准方法，即使用Breslow型估计器估计基线风险和使用Aalen-Johansen方法估计累积发生率函数。\n\n解决方案通过为每个测试案例实施指定的计算来进行。分析是分层的，这意味着对给定层中受试者的计算仅使用该层的数据。\n\n首先，我们定义模型的核心组成部分。对于协变量为 $x$ 的受试者，在层 $s \\in \\{A, B\\}$ 中原因 $k \\in \\{1, 2\\}$ 的特定原因风险由比例风险模型给出：\n$$h_{k,s}(t \\mid x) = h_{0,k,s}(t) \\exp(x \\beta_k)$$\n其中 $h_{0,k,s}(t)$ 是层 $s$ 中原因 $k$ 的未知基线风险，而 $\\beta_k$ 是与 $x$ 增加一个单位相关的特定原因对数风险比。问题提供了 $\\beta_1 = 0.6$ 和 $\\beta_2 = -0.4$。\n\n分析在离散时间中进行，步骤对应于数据中观察到的不同事件时间。我们必须首先估计基线风险。问题为累积基线风险的增量指定了一个Breslow型估计器，$\\Delta H_{0,k,s}(t_j) = H_{0,k,s}(t_j) - H_{0,k,s}(t_j^-)$。在层 $s$ 的每个不同事件时间 $t_j$，此增量估计为：\n$$\\Delta \\hat{H}_{0,k,s}(t_j) = \\frac{d_{k,s,j}}{\\sum_{i \\in R_{s,j}} \\exp(x_i \\beta_k)}$$\n在这里，$t_j$ 代表层 $s$ 中的第 $j$ 个不同事件时间。$d_{k,s,j}$ 是在时间 $t_j$ 在层 $s$ 中观察到的原因 $k$ 的事件数。风险集 $R_{s,j}$ 由在时间 $t_j$ 仍然处于观察状态的所有层 $s$ 中的受试者组成（即，他们的事件或删失时间大于或等于 $t_j$）。请注意，$\\Delta \\hat{H}_{0,k,s}(t_j)$ 仅在时间 $t_j$ 发生原因 $k$ 的事件时才为非零。\n\n对于层 $s^\\star$ 中协变量值为 $x^\\star$ 的新受试者，其在时间 $t_j$ 的原因 $k$ 的受试者特定累积风险的增量是从基线增量派生的：\n$$\\Delta \\Lambda_k(t_j \\mid x^\\star, s^\\star) = \\Delta \\hat{H}_{0,k,s^\\star}(t_j) \\times \\exp(x^\\star \\beta_k)$$\n截至时间 $t^\\star$ 的原因 $k$ 的总累积特定原因风险是截至 $t^\\star$ 的所有事件时间内这些增量的总和：\n$$\\Lambda_k(t^\\star \\mid x^\\star, s^\\star) = \\sum_{t_j \\le t^\\star} \\Delta \\Lambda_k(t_j \\mid x^\\star, s^\\star)$$\n\n受试者的总生存函数 $S(t \\mid x^\\star, s^\\star)$ 是到时间 $t$ 为止未经历任何事件的概率。它与累积特定原因风险的总和有关：\n$$S(t \\mid x^\\star, s^\\star) = \\exp\\left(-\\sum_{k=1}^{2} \\Lambda_k(t \\mid x^\\star, s^\\star)\\right)$$\n\n原因 $k$ 的累积发生率函数(CIF)，$F_k(t \\mid x^\\star, s^\\star)$，给出到时间 $t$ 为止因原因 $k$ 失败的概率。它是通过将在每个事件时间点因原因 $k$ 失败的概率相加来计算的，条件是存活到该时间点。这就是 Aalen-Johansen 估计器。在事件时间 $t_j$ 的 CIF 增量是刚好在 $t_j$ 之前的生存概率与在 $t_j$ 的受试者特定原因 $k$ 风险增量的乘积。总 CIF 是这些增量的总和：\n$$F_k(t^\\star \\mid x^\\star, s^\\star) = \\sum_{t_j \\le t^\\star} S(t_{j-1} \\mid x^\\star, s^\\star) \\times \\Delta \\Lambda_k(t_j \\mid x^\\star, s^\\star)$$\n其中 $t_0=0$ 且 $S(t_0 \\mid x^\\star, s^\\star) = S(0 \\mid x^\\star, s^\\star) = 1$。\n\n每个测试案例 $(s^\\star, x^\\star, t^\\star)$ 的计算过程如下：\n1.  筛选数据集，只包括来自层 $s^\\star$ 的记录。按时间对这些记录进行排序。\n2.  在此层中，识别出小于或等于 $t^\\star$ 的唯一事件时间 $t_j$。\n3.  在时间 $t=0$ 初始化各量：$\\Lambda_1=0$, $\\Lambda_2=0$, $F_1=0$, $F_2=0$, 以及第一个事件发生前的生存概率，$S_\\text{prev} = 1$。\n4.  对于每个按升序排列的唯一事件时间 $t_j$：\n    a.  识别风险集 $R_{s^\\star, j}$。\n    b.  计算分母 $\\sum_{i \\in R_{s^\\star, j}} \\exp(x_i \\beta_1)$ 和 $\\sum_{i \\in R_{s^\\star, j}} \\exp(x_i \\beta_2)$。\n    c.  在时间 $t_j$ 统计原因1 ($d_{1,j}$) 和原因2 ($d_{2,j}$) 的事件数。\n    d.  计算基线风险增量 $\\Delta \\hat{H}_{0,1,s^\\star}(t_j)$ 和 $\\Delta \\hat{H}_{0,2,s^\\star}(t_j)$。\n    e.  使用 $\\exp(x^\\star \\beta_k)$ 计算受试者特定的风险增量 $\\Delta \\Lambda_1(t_j)$ 和 $\\Delta \\Lambda_2(t_j)$。\n    f.  更新CIF：$F_k \\leftarrow F_k + S_\\text{prev} \\times \\Delta \\Lambda_k(t_j)$。\n    g.  更新累积风险：$\\Lambda_k \\leftarrow \\Lambda_k + \\Delta \\Lambda_k(t_j)$。\n    h.  更新下一步的生存概率：$S_\\text{prev} = \\exp(-(\\Lambda_1 + \\Lambda_2))$。\n5.  $\\Lambda_1, \\Lambda_2, F_1, F_2$ 的最终值是该测试案例的结果。对于 $t^\\star = 0$ 的测试案例，所有结果均为 $0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the competing risks problem for all test cases.\n    \"\"\"\n    \n    # Each record is a tuple (stratum, t, delta, x)\n    data_A = [\n        ('A', 1.0, 1, -0.2), ('A', 2.0, 0, 0.5), ('A', 3.0, 2, 1.2),\n        ('A', 4.0, 1, 0.0), ('A', 5.0, 0, -1.0), ('A', 6.5, 2, 0.7),\n        ('A', 7.2, 1, 1.5), ('A', 7.8, 0, -0.4), ('A', 8.0, 2, 0.3),\n        ('A', 9.0, 0, 0.9)\n    ]\n    data_B = [\n        ('B', 0.8, 2, -0.1), ('B', 1.5, 0, 0.2), ('B', 2.2, 1, -0.8),\n        ('B', 3.0, 0, 1.1), ('B', 3.3, 1, 0.5), ('B', 4.1, 2, 1.0),\n        ('B', 4.9, 0, -0.6), ('B', 5.2, 1, 0.4), ('B', 6.0, 2, -1.2),\n        ('B', 6.5, 0, 0.0)\n    ]\n    \n    data = {'A': data_A, 'B': data_B}\n    \n    # Cause-specific regression coefficients\n    betas = {1: 0.6, 2: -0.4}\n    \n    # Test suite\n    test_cases = [\n        ('A', 0.0, 4.0),\n        ('A', 1.0, 7.0),\n        ('B', -0.5, 3.5),\n        ('B', 0.2, 0.0)\n    ]\n\n    all_results = []\n    for s_star, x_star, t_star in test_cases:\n        results = calculate_estimates(s_star, x_star, t_star, data, betas)\n        all_results.extend(results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef calculate_estimates(s_star, x_star, t_star, all_data, betas):\n    \"\"\"\n    Calculates cumulative hazards and cumulative incidence functions for a single subject.\n\n    Args:\n        s_star (str): Stratum of the subject.\n        x_star (float): Covariate value of the subject.\n        t_star (float): Time point at which to evaluate the functions.\n        all_data (dict): Dictionary containing the full dataset, keyed by stratum.\n        betas (dict): Dictionary of cause-specific regression coefficients.\n\n    Returns:\n        list: A list of four floats: [Lambda1, Lambda2, F1, F2].\n    \"\"\"\n    if t_star == 0.0:\n        return [0.0, 0.0, 0.0, 0.0]\n\n    # 1. Filter data for the stratum and sort by time\n    stratum_data = sorted(all_data[s_star], key=lambda item: item[1])\n\n    # 2. Identify distinct event times up to t_star\n    event_times = sorted(list(set(\n        d[1] for d in stratum_data if d[2] in [1, 2] and d[1] = t_star\n    )))\n\n    # 3. Initialize outcome variables\n    lambda1, lambda2 = 0.0, 0.0\n    f1, f2 = 0.0, 0.0\n    surv_prev = 1.0\n\n    # 4. Iterate through distinct event times\n    for t_j in event_times:\n        # a. Determine risk set at time t_j\n        risk_set = [d for d in stratum_data if d[1] = t_j]\n        risk_set_x = np.array([d[3] for d in risk_set])\n\n        # b. Calculate risk-set sums (denominators)\n        w1 = np.sum(np.exp(risk_set_x * betas[1]))\n        w2 = np.sum(np.exp(risk_set_x * betas[2]))\n\n        # c. Count events of each cause at t_j\n        events_at_tj = [d for d in stratum_data if d[1] == t_j and d[2] in [1, 2]]\n        d1_j = sum(1 for d in events_at_tj if d[2] == 1)\n        d2_j = sum(1 for d in events_at_tj if d[2] == 2)\n\n        # d. Calculate baseline hazard increments\n        delta_h01 = d1_j / w1 if w1  0 else 0.0\n        delta_h02 = d2_j / w2 if w2  0 else 0.0\n\n        # e. Calculate subject-specific hazard increments\n        delta_lambda1 = delta_h01 * np.exp(x_star * betas[1])\n        delta_lambda2 = delta_h02 * np.exp(x_star * betas[2])\n\n        # f. Update Cumulative Incidence Functions (CIFs)\n        # CIF increment is S(t_j-)*dLambda_k(t_j)\n        f1 += surv_prev * delta_lambda1\n        f2 += surv_prev * delta_lambda2\n\n        # g. Update cumulative hazards\n        lambda1 += delta_lambda1\n        lambda2 += delta_lambda2\n\n        # h. Update overall survival for the start of the next interval\n        surv_prev = np.exp(-(lambda1 + lambda2))\n\n    return [lambda1, lambda2, f1, f2]\n\nsolve()\n```"
        }
    ]
}