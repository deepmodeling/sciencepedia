{
    "hands_on_practices": [
        {
            "introduction": "在应用卷积核（例如用于平滑或边缘检测的核）时，一个基础但至关重要的问题是如何处理图像边界。当卷积核的邻域延伸到图像有效数据范围之外时，我们必须对缺失的像素值做出假设，这就是所谓的边界条件。此练习将引导您从第一性原理出发，分析不同的边界条件（零填充、复制和反射）如何影响在图像边缘处的卷积输出，帮助您深入理解这些选择如何引入偏倚或伪影。",
            "id": "4540825",
            "problem": "考虑一个二维医学图像在视场 (FOV) 左边界处的一维截面，我们分析一条由整数位置 $n \\in \\mathbb{Z}$ 索引的水平扫描线，其内部定义为 $n \\ge 0$。信号 $f[n]$ 与一个有限脉冲响应滤波器 $h[n]$ 的离散卷积定义为 $g[n] = \\sum_{k \\in \\mathbb{Z}} h[k] f[n - k]$。在边界 $n = 0$ 附近，$n  0$ 时的值 $f[n]$ 是不可用的，必须通过边界条件来处理。假设有以下边界条件：\n- 零填充：对于 $n  0$，$f[n] = 0$。\n- 复制：对于 $n  0$，$f[n] = f[0]$。\n- 反射：对于所有整数 $m \\ge 1$，$f[-m] = f[m]$。\n\n假设在基础医学图像处理中使用两种典型的滤波器类型：\n- 一个归一化对称平滑核，其抽头为 $h[-1] = \\frac{1}{4}$，$h[0] = \\frac{1}{2}$，$h[1] = \\frac{1}{4}$，对于所有其他 $k$，$h[k] = 0$。\n- 一个奇对称离散导数核，$h[-1] = -1$，$h[0] = 0$，$h[1] = 1$，对于所有其他 $k$，$h[k] = 0$，它近似于一阶空间导数。\n\n我们将边界 $n = 0$ 处的真实值卷积定义为：假设 $n  0$ 时的信号 $f[n]$ 匹配一个指定的视场外真实强度模型时所能获得的值。在以下每个场景中，视场外的真实强度都将被明确指定。\n\n您需要分析每种边界条件对输出 $g[0]$ 的影响，并确定相对于指定的真实值的偏差方向（高估、低估或无偏）。选择所有正确的陈述。每个陈述提供了一个独立的场景，您必须从第一性原理出发进行评估。\n\nA. 设对于所有 $n \\ge 0$，$f[n] = I$，其中内部强度为常数 $I > 0$。并假设对于 $n  0$，视场外的真实强度为 $0$。使用对称平滑核，在 $n = 0$ 处，复制和反射边界条件产生的输出严格大于真实值卷积，而零填充产生真实值。\n\nB. 设对于所有 $n \\ge 0$，$f[n] = I$，其中内部强度为常数 $I > 0$。并假设对于 $n  0$，视场外的真实强度等于内部强度 $I$。使用奇对称离散导数核，在 $n = 0$ 处，零填充产生非零的边缘响应，而复制和反射产生零，与真实值一致。\n\nC. 对于任何支撑集为 $\\{-1, 0, 1\\}$ 的奇对称滤波器，在 $n=0$ 处的反射边界条件相对于任何视场外模型总是无偏的，因为反射在边界处保持了奇对称性。\n\nD. 对于任何支撑集为 $\\{-1, 0, 1\\}$ 的非负对称平滑核（不一定是归一化的），如果视场外的真实强度等于内部强度 $I > 0$（即，物体延伸到视场之外），那么在 $n = 0$ 处，零填充会产生相对于真实值的平均强度的低估，而复制是无偏的。\n\nE. 设对于所有 $n \\ge 0$，$f[n] = n$（一个单调递增的斜坡信号），并假设对于 $n  0$，视场外的真实强度为 $0$。使用奇对称离散导数核，在 $n = 0$ 处，与零填充和复制相比，反射边界条件抑制了边缘响应，而零填充和复制都与真实值匹配。\n\n选择所有正确的选项。通过对每个场景，直接从卷积定义、指定的边界条件和视场外模型推导出 $g[0]$ 来证明你的选择。",
            "solution": "问题陈述已经过验证，并被认为是合理的。它在数字信号处理方面有科学依据，是适定的、客观的，并包含足够的信息来评估给出的每个陈述。我们将对每个选项进行系统性分析。\n\n在边界位置 $n=0$ 处的离散卷积由公式 $g[0] = \\sum_{k \\in \\mathbb{Z}} h[k] f[-k]$ 给出。问题中指定的两种滤波器都仅在索引集合 $\\{-1, 0, 1\\}$ 上有支撑。因此，卷积和简化为：\n$$g[0] = h[-1]f[1] + h[0]f[0] + h[1]f[-1]$$\n该公式将是所有后续计算的基础。\n\n### 选项A的分析\n\n该场景涉及一个对称平滑核和一个常数内部信号。\n- **信号**：对于 $n \\ge 0$，$f[n] = I$，其中 $I > 0$。因此，$f[0] = I$ 且 $f[1] = I$。\n- **滤波器**：对称平滑核，$h[-1] = \\frac{1}{4}$，$h[0] = \\frac{1}{2}$，$h[1] = \\frac{1}{4}$。\n- **真实值模型**：视场外的真实强度为 $0$。因此，信号扩展的真实值模型为：对于 $n  0$，$f_{true}[n] = 0$。具体来说，$f_{true}[-1] = 0$。\n\n首先，我们计算真实值卷积输出 $g_{gt}[0]$：\n$$g_{gt}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{true}[-1] = \\left(\\frac{1}{4}\\right)(I) + \\left(\\frac{1}{2}\\right)(I) + \\left(\\frac{1}{4}\\right)(0) = \\frac{3}{4}I$$\n\n接下来，我们计算每种指定边界条件下的输出 $g[0]$：\n1.  **零填充**：条件是对于 $n  0$，$f_{zp}[n] = 0$。因此，$f_{zp}[-1] = 0$。\n    $$g_{zp}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{zp}[-1] = \\left(\\frac{1}{4}\\right)(I) + \\left(\\frac{1}{2}\\right)(I) + \\left(\\frac{1}{4}\\right)(0) = \\frac{3}{4}I$$\n    与真实值相比，$g_{zp}[0] = g_{gt}[0]$。输出与真实值匹配。\n\n2.  **复制**：条件是对于 $n  0$，$f_{rep}[n] = f[0]$。因此，$f_{rep}[-1] = f[0] = I$。\n    $$g_{rep}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{rep}[-1] = \\left(\\frac{1}{4}\\right)(I) + \\left(\\frac{1}{2}\\right)(I) + \\left(\\frac{1}{4}\\right)(I) = I$$\n    由于 $I > 0$，我们有 $I > \\frac{3}{4}I$。因此，$g_{rep}[0] > g_{gt}[0]$。这是一个高估。\n\n3.  **反射**：条件是对于 $m \\ge 1$，$f_{ref}[-m] = f[m]$。因此，$f_{ref}[-1] = f[1] = I$。\n    $$g_{ref}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{ref}[-1] = \\left(\\frac{1}{4}\\right)(I) + \\left(\\frac{1}{2}\\right)(I) + \\left(\\frac{1}{4}\\right)(I) = I$$\n    与复制情况类似，$g_{ref}[0] = I > \\frac{3}{4}I = g_{gt}[0]$。这也是一个高估。\n\n该陈述断言，复制和反射条件产生的输出严格大于真实值，而零填充产生真实值。我们的计算证实了这一点。\n**结论：正确。**\n\n### 选项B的分析\n\n该场景涉及奇对称导数核。\n- **信号**：对于 $n \\ge 0$，$f[n] = I$，其中 $I > 0$。因此，$f[0] = I$ 且 $f[1] = I$。\n- **滤波器**：奇对称导数核，$h[-1] = -1$，$h[0] = 0$，$h[1] = 1$。\n- **真实值模型**：视场外的真实强度等于内部强度 $I$。因此，真实信号处处恒定：对于所有 $n \\in \\mathbb{Z}$，$f_{true}[n] = I$。具体来说，$f_{true}[-1] = I$。\n\n此滤波器在 $n=0$ 处的卷积公式为：\n$$g[0] = h[-1]f[1] + h[0]f[0] + h[1]f[-1] = (-1)f[1] + (0)f[0] + (1)f[-1] = f[-1] - f[1]$$\n由于 $f[1] = I$，这简化为 $g[0] = f[-1] - I$。\n\n首先，我们计算真实值输出，它代表一个常数信号的导数：\n$$g_{gt}[0] = f_{true}[-1] - f[1] = I - I = 0$$\n\n接下来，我们计算每种边界条件下的输出 $g[0]$：\n1.  **零填充**：$f_{zp}[-1] = 0$。\n    $$g_{zp}[0] = f_{zp}[-1] - f[1] = 0 - I = -I$$\n    这是一个非零的边缘响应。\n\n2.  **复制**：$f_{rep}[-1] = f[0] = I$。\n    $$g_{rep}[0] = f_{rep}[-1] - f[1] = I - I = 0$$\n    这个输出为零，与真实值一致。\n\n3.  **反射**：$f_{ref}[-1] = f[1] = I$。\n    $$g_{ref}[0] = f_{ref}[-1] - f[1] = I - I = 0$$\n    这个输出也为零，与真实值一致。\n\n该陈述断言，零填充产生非零响应，而复制和反射产生零，与真实值一致。我们的计算证实了这一点。\n**结论：正确。**\n\n### 选项C的分析\n\n该陈述对任何奇对称滤波器和反射边界条件作出了一个普遍性声明。\n- **滤波器**：任何支撑集为 $\\{-1, 0, 1\\}$ 的奇对称滤波器。这意味着 $h[0] = 0$ 且 $h[-1] = -h[1]$。\n- **边界条件**：反射，所以 $f_{ref}[-1] = f[1]$。\n- **主张**：输出 $g_{ref}[0]$ *总是*无偏的，意味着对于*任何*视场外模型，$g_{ref}[0] = g_{gt}[0]$。\n\n让我们使用反射边界条件计算输出：\n$$g_{ref}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{ref}[-1] = (-h[1])f[1] + (0)f[0] + (h[1])(f[1]) = -h[1]f[1] + h[1]f[1] = 0$$\n所以，使用这类滤波器的反射条件在 $n=0$ 处总是产生 $0$ 的输出。\n\n现在让我们为一个 $f_{true}[-1]$ 为任意值的任意视场外模型计算真实值输出。\n$$g_{gt}[0] = h[-1]f[1] + h[0]f[0] + h[1]f_{true}[-1] = -h[1]f[1] + h[1]f_{true}[-1] = h[1](f_{true}[-1] - f[1])$$\n\n要使反射条件“总是无偏”，必须在所有情况下都有 $g_{ref}[0] = g_{gt}[0]$。这意味着我们必须有：\n$$0 = h[1](f_{true}[-1] - f[1])$$\n这个等式通常不成立。对于一个非平凡的滤波器，$h[1] \\neq 0$。真实值 $f_{true}[-1]$ 可以是任何值，不一定等于 $f[1]$。例如，如果 $h[1]=1$，$f[1]=5$，且真实信号值为 $f_{true}[-1]=10$，那么 $g_{gt}[0] = 1(10-5) = 5$，而 $g_{ref}[0]=0$。在这种情况下，反射条件是有偏的。因此，该陈述是错误的。\n**结论：不正确。**\n\n### 选项D的分析\n\n这个场景涉及一个通用的非负对称平滑核。\n- **滤波器**：对称核，$h[-1]=h[1]=\\alpha \\ge 0$，$h[0]=\\beta \\ge 0$。我们假设核是非平凡的，所以 $\\alpha > 0$。\n- **信号**：对于 $n \\ge 0$，$f[n] = I$，其中 $I > 0$。所以 $f[0]=I, f[1]=I$。\n- **真实值模型**：真实信号处处为常数，对于所有 $n$，$f_{true}[n] = I$。因此，$f_{true}[-1] = I$。\n\n在 $n=0$ 处的卷积为 $g[0] = \\alpha f[1] + \\beta f[0] + \\alpha f[-1]$。\n\n首先，我们计算真实值输出：\n$$g_{gt}[0] = \\alpha f[1] + \\beta f[0] + \\alpha f_{true}[-1] = \\alpha I + \\beta I + \\alpha I = (2\\alpha + \\beta)I$$\n\n接下来，我们评估指定的边界条件：\n1.  **零填充**：$f_{zp}[-1] = 0$。\n    $$g_{zp}[0] = \\alpha f[1] + \\beta f[0] + \\alpha f_{zp}[-1] = \\alpha I + \\beta I + \\alpha(0) = (\\alpha + \\beta)I$$\n    为了与真实值进行比较，我们检查其差值：$g_{gt}[0] - g_{zp}[0] = (2\\alpha + \\beta)I - (\\alpha + \\beta)I = \\alpha I$。由于我们假设一个非平凡的平滑核，其中 $\\alpha > 0$，并且给定 $I>0$，这个差值 $\\alpha I$ 是严格为正的。因此，$g_{zp}[0]  g_{gt}[0]$，这是一个低估。\n\n2.  **复制**：$f_{rep}[-1] = f[0] = I$。\n    $$g_{rep}[0] = \\alpha f[1] + \\beta f[0] + \\alpha f_{rep}[-1] = \\alpha I + \\beta I + \\alpha I = (2\\alpha + \\beta)I$$\n    在这种情况下，$g_{rep}[0] = g_{gt}[0]$。复制条件是无偏的。\n\n该陈述断言，零填充产生低估，而复制是无偏的。我们的分析证实了这一点。\n**结论：正确。**\n\n### 选项E的分析\n\n这个场景涉及一个斜坡信号和奇对称导数核。\n- **信号**：对于 $n \\ge 0$，$f[n] = n$。因此，$f[0]=0$ 且 $f[1]=1$。\n- **滤波器**：奇对称导数核，$h[-1] = -1$，$h[0] = 0$，$h[1] = 1$。\n- **真实值模型**：视场外的真实强度为 $0$。所以对于 $n0$，$f_{true}[n]=0$，具体来说 $f_{true}[-1] = 0$。\n\n此滤波器在 $n=0$ 处的卷积公式为 $g[0] = f[-1] - f[1] = f[-1] - 1$。\n\n首先，我们计算真实值输出：\n$$g_{gt}[0] = f_{true}[-1] - f[1] = 0 - 1 = -1$$\n这代表了导数滤波器检测到的在边界处从 $0$ 到 $1$（通过 $f[0]=0$）的阶跃状变化。\n\n接下来，我们计算每种边界条件下的输出：\n1.  **零填充**：$f_{zp}[-1] = 0$。\n    $$g_{zp}[0] = f_{zp}[-1] - f[1] = 0 - 1 = -1$$\n    这与真实值匹配。\n\n2.  **复制**：$f_{rep}[-1] = f[0] = 0$。\n    $$g_{rep}[0] = f_{rep}[-1] - f[1] = 0 - 1 = -1$$\n    这也与真实值匹配。\n\n3.  **反射**：$f_{ref}[-1] = f[1] = 1$。\n    $$g_{ref}[0] = f_{ref}[-1] - f[1] = 1 - 1 = 0$$\n    输出为 $0$。\n\n该陈述声称，与零填充和复制相比，反射条件“抑制了边缘响应”。反射的响应为 $0$，而其他两种为 $-1$。反射响应的幅度 $|0|=0$ 确实小于其他响应的幅度 $|-1|=1$。因此，响应被抑制了。该陈述还声称零填充和复制“都与真实值匹配”。我们的计算表明它们都得到 $-1$，这正是真实值。该陈述与我们的发现完全一致。\n**结论：正确。**\n\n### 总结\n根据所提供定义的直接计算，陈述 A、B、D 和 E 是正确的。陈述 C 是不正确的，因为它作出了一个错误的普遍性声明。",
            "answer": "$$\\boxed{ABDE}$$"
        },
        {
            "introduction": "降噪是医学图像处理中的一项基本任务，但不存在“一刀切”的解决方案。滤波器的选择在很大程度上取决于噪声的统计特性。本练习将通过一个具体的编程实践，让您量化比较线性的高斯平滑和非线性的中值滤波在处理脉冲噪声（椒盐噪声）时的表现差异。通过这个实践，您将深刻体会到为何理解噪声模型对于选择合适的滤波策略、有效去除噪声同时最大程度保留图像（如边缘）等重要结构至关重要。",
            "id": "4540916",
            "problem": "给定一个二维离散图像模型，要求您比较两种滤波器在椒盐噪声下对边缘定位的影响。此任务的核心是构建一个二值阶跃边缘图像，用椒盐噪声对其进行破坏，使用两种不同的策略对其进行滤波，从滤波后的结果中估计边缘位置，并量化哪种滤波器能更好地保留边缘位置。\n\n从以下基础概念开始：\n- 离散图像是一个函数 $I: \\mathbb{Z}^2 \\to [0,1]$，由整数像素坐标索引。\n- 沿列的二值阶跃边缘由一个图像表示，该图像在垂直边界的一侧为常数 $0$，在另一侧为常数 $1$。\n- 椒盐噪声是一种脉冲噪声模型，其中每个像素被独立地破坏：以概率 $p/2$ 被设置为最小值，以概率 $p/2$ 被设置为最大值，并以概率 $1-p$ 保持不变。\n- 中值滤波是一种非线性顺序统计滤波器，它在每个像素处，将该像素的值替换为其局部邻域窗口内所有值的中值。\n- 高斯平滑是一种线性滤波操作，通过与标准差为 $\\sigma$（单位为像素）的各向同性高斯核进行卷积来平滑图像。\n\n您的程序必须精确实现以下场景和计算：\n1. 构建一个高为 $H$、宽为 $W$ 的纯净二值阶跃边缘图像 $I_0 \\in \\{0,1\\}^{H \\times W}$，其垂直边缘位于列索引 $x_0$ 处。对于所有像素坐标 $(y,x)$，其中 $0 \\le y  H$ 且 $0 \\le x  W$，定义 $I_0(y,x) = 0$（如果 $x  x_0$）和 $I_0(y,x) = 1$（如果 $x \\ge x_0$）。\n2. 添加参数为 $p \\in [0,1]$ 的椒盐噪声以获得 $I_\\text{noisy}$。为每个像素独立地从均匀分布中抽取一个随机变量 $r \\in [0,1)$。如果 $r  p/2$，则将像素值设为 $0$；如果 $p/2 \\le r  p$，则将其设为 $1$；否则保持像素值不变。使用指定的整数种子 $s$ 进行伪随机数生成以确保可复现性。所有随机抽取在像素间必须是独立的。所有强度值保持在 $[0,1]$ 范围内。\n3. 对 $I_\\text{noisy}$ 应用一个二维中值滤波器，其方形窗口的奇数边长为 $k$（单位为像素），生成 $I_\\text{med}$。在图像边界处使用反射方式处理。\n4. 对 $I_\\text{noisy}$ 应用高斯平滑，其各向同性标准差为 $\\sigma$（单位为像素），生成 $I_\\text{gauss}$。在图像边界处使用反射方式处理。\n5. 从每个滤波后的图像中，沿中心行估计边缘位置。令 $y_c = \\lfloor H/2 \\rfloor$ 为中心行索引。定义一维行信号 $r_\\text{med}[i] = I_\\text{med}(y_c,i)$ 和 $r_\\text{gauss}[i] = I_\\text{gauss}(y_c,i)$，其中整数 $i$ 满足 $0 \\le i  W$。计算前向离散差分 $d[i] = r[i+1] - r[i]$（其中 $0 \\le i \\le W-2$）及其绝对值 $|d[i]|$。将估计的边缘索引 $\\hat{\\imath}$ 定义为使 $|d[i]|$ 达到其最大值的最小索引 $i$。对中值滤波和高斯平滑的行分别执行此操作，以获得 $\\hat{\\imath}_\\text{med}$ 和 $\\hat{\\imath}_\\text{gauss}$。对于此种前向差分估计器，真值边缘索引是 $i^\\star = x_0 - 1$（真实过渡的左侧像素）。\n6. 对每种滤波器，量化其边缘定位误差，即与真值之间的绝对像素差：$e_\\text{med} = |\\hat{\\imath}_\\text{med} - i^\\star|$ 和 $e_\\text{gauss} = |\\hat{\\imath}_\\text{gauss} - i^\\star|$。报告差值 $d^\\star = e_\\text{gauss} - e_\\text{med}$，单位为像素。正的 $d^\\star$ 值表示在该情况下，中值滤波器比高斯平滑更好地保留了边缘位置。所有误差和差值均以像素为单位测量。\n7. 所有计算都应在有限数组上执行，并在两个滤波步骤中采用反射边界条件。最终的数值答案必须以像素为单位，表示为四舍五入到 $3$ 位小数的浮点数。\n\n测试套件：\n在以下参数集上执行您的程序。每个测试用例是一个元组 $(H, W, x_0, p, k, \\sigma, s)$，其中 $H$ 和 $W$ 是以像素为单位的整数， $x_0$ 是阶跃的整数列索引， $p$ 是 $[0,1]$ 范围内的椒盐噪声概率（小数形式）， $k$ 是以像素为单位的奇数整数窗口大小， $\\sigma$ 是以像素为单位的正实数， $s$ 是一个整数随机种子：\n- 用例 1：$(H,W,x_0,p,k,\\sigma,s) = (\\,64,\\,128,\\,64,\\,0.2,\\,3,\\,1.0,\\,42\\,)$\n- 用例 2：$(\\,64,\\,128,\\,64,\\,0.4,\\,3,\\,1.0,\\,7\\,)$\n- 用例 3：$(\\,64,\\,128,\\,64,\\,0.3,\\,5,\\,2.0,\\,123\\,)$\n- 用例 4：$(\\,64,\\,128,\\,5,\\,0.3,\\,3,\\,1.0,\\,999\\,)$\n- 用例 5：$(\\,64,\\,128,\\,64,\\,0.02,\\,3,\\,1.0,\\,2024\\,)$\n- 用例 6：$(\\,64,\\,128,\\,64,\\,0.6,\\,5,\\,1.5,\\,31415\\,)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，该列表按上述确切顺序包含各个用例的结果。每个条目必须是对应情况下的 $d^\\star$ 值，以像素为单位表示并四舍五入到 $3$ 位小数。例如，一个有效的输出看起来像这样：\"[0.125,-0.500,0.000,0.250,0.125,0.375]\"。",
            "solution": "该问题要求对中值滤波器和高斯滤波器在椒盐噪声破坏的图像中保留边缘位置的能力进行定量比较。解决方案涉及一个多步骤的模拟：创建一个具有已知边缘的合成图像，用噪声对其进行破坏，应用每种滤波器，从滤波后的图像中估计边缘位置，并计算定位误差。所研究的核心科学原理是非线性滤波器与线性滤波器在处理脉冲噪声时的性能差异。\n\n首先，构建一个纯净的数字图像 $I_0$，它是一个大小为 $H \\times W$ 的二维数组。该图像代表一个完美的垂直阶跃边缘。对于坐标为 $(y,x)$ 的任意像素，其中 $0 \\le y  H$ 且 $0 \\le x  W$，其强度定义为：如果 $x  x_0$，则 $I_0(y,x) = 0$；如果 $x \\ge x_0$，则 $I_0(y,x) = 1$。整数 $x_0$ 标记了边缘过渡发生的列。\n\n接下来，对这个纯净图像 $I_0$ 进行破坏，以模拟数据采集过程中的伪影，特别是椒盐噪声。这类噪声由一个概率 $p \\in [0,1]$ 来表征。对于 $I_0$ 中的每个像素，从 $[0,1)$ 上的均匀分布中抽取一个随机数 $r$。如果 $r  p/2$，像素值被设为最小强度 $0$。如果 $p/2 \\le r  p$，则被设为最大强度 $1$。否则，以 $1-p$ 的概率保留像素的原始值。此过程对所有像素独立执行，得到噪声图像 $I_\\text{noisy}$。为了保证可复现性，伪随机数生成器使用一个特定的整数种子 $s$ 进行初始化。\n\n然后，使用两种不同的滤波方法处理噪声图像 $I_\\text{noisy}$。滤波过程中的边界效应通过反射方式处理。\n\n第一种是二维中值滤波器，其方形邻域的边长为 $k$（一个奇数）。这是一种非线性的顺序统计滤波器。在每个像素点，它会考虑其 $k \\times k$ 邻域内的所有值，对它们进行排序，并用排序后列表的中值替换中心像素的值。其基本原理是，像椒盐噪声这样的脉冲噪声在局部邻域中表现为极端值（离群点）。中值对这类离群点具有鲁棒性。因此，中值滤波器在去除此类噪声的同时，能非常有效地保留像边缘这样的锐利特征。此操作的输出是经中值滤波的图像 $I_\\text{med}$。\n\n第二种是高斯平滑滤波器，由一个标准差为 $\\sigma$ 的各向同性高斯核定义。这是一种线性滤波器，通过将图像与该核进行卷积来操作。这相当于用其邻域像素的加权平均值替换每个像素的值，其中权重由高斯函数给出，并随与中心距离的增加而减小。虽然对于加性高斯噪声而言，这是一个最优的线性滤波器，但它并不适合处理脉冲噪声。椒盐噪声的极端值会被包含在平均过程中，这会将它们模糊到周围区域，从而涂抹噪声而不是消除它。同样的模糊效应也会降低锐利边缘的清晰度。此操作的输出是经高斯滤波的图像 $I_\\text{gauss}$。\n\n为了量化每种滤波器的性能，我们从滤波后的图像中估计边缘位置。分析集中在每个图像的中心行，索引为 $y_c = \\lfloor H/2 \\rfloor$。提取一维信号：$r_\\text{med}[i] = I_\\text{med}(y_c,i)$ 和 $r_\\text{gauss}[i] = I_\\text{gauss}(y_c,i)$。物理上，边缘是强度梯度高的位置。梯度通过前向离散差分进行数值近似，$d[i] = r[i+1] - r[i]$，其中 $i$ 从 $0$ 到 $W-2$。估计的边缘位置 $\\hat{\\imath}$ 被定义为该差分幅值最大的索引：$\\hat{\\imath} = \\arg\\max_i |d[i]|$。如果出现平局，则选择最小的索引。此过程产生两个估计值：从 $r_\\text{med}$ 得到的 $\\hat{\\imath}_\\text{med}$ 和从 $r_\\text{gauss}$ 得到的 $\\hat{\\imath}_\\text{gauss}$。\n\n通过前向差分算子检测到的边缘真值位置，位于强度阶跃左侧紧邻的像素处。阶跃发生在列 $x_0-1$（值为 $0$）和列 $x_0$（值为 $1$）之间。前向差分 $d[x_0-1] = r[x_0] - r[x_0-1]$ 将捕捉到这一转变。因此，真值索引为 $i^\\star = x_0-1$。\n\n最后，计算每个滤波器的定位误差，即与真值的绝对偏差：$e_\\text{med} = |\\hat{\\imath}_\\text{med} - i^\\star|$ 和 $e_\\text{gauss} = |\\hat{\\imath}_\\text{gauss} - i^\\star|$。为了直接比较这两个滤波器，计算它们的误差之差：$d^\\star = e_\\text{gauss} - e_\\text{med}$。一个正的 $d^\\star$ 值表示中值滤波器产生了更小的定位误差，因而在给定条件下表现更优。对测试套件中提供的每组参数都执行这整个过程，以生成最终结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import median_filter, gaussian_filter\n\ndef solve():\n    \"\"\"\n    Implements the full simulation pipeline to compare median and Gaussian\n    filters for edge localization under salt-and-pepper noise.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (H, W, x0, p, k, sigma, s)\n        (64, 128, 64, 0.2, 3, 1.0, 42),\n        (64, 128, 64, 0.4, 3, 1.0, 7),\n        (64, 128, 64, 0.3, 5, 2.0, 123),\n        (64, 128, 5, 0.3, 3, 1.0, 999),\n        (64, 128, 64, 0.02, 3, 1.0, 2024),\n        (64, 128, 64, 0.6, 5, 1.5, 31415),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        H, W, x0, p, k, sigma, s = case\n\n        # Step 1: Construct the clean binary step-edge image\n        I0 = np.zeros((H, W), dtype=np.float64)\n        if x0  W:\n            I0[:, x0:] = 1.0\n\n        # Step 2: Add salt-and-pepper noise\n        # Use a modern random number generator for better practice\n        rng = np.random.default_rng(s)\n        noise_map = rng.random((H, W))\n        I_noisy = I0.copy()\n        \n        # Pixels to be set to 0\n        I_noisy[noise_map  p / 2.0] = 0.0\n        # Pixels to be set to 1\n        I_noisy[(noise_map >= p / 2.0)  (noise_map  p)] = 1.0\n\n        # Step 3: Apply median filter\n        I_med = median_filter(I_noisy, size=k, mode='reflect')\n\n        # Step 4: Apply Gaussian filter\n        I_gauss = gaussian_filter(I_noisy, sigma=sigma, mode='reflect')\n\n        # Step 5: Estimate edge location from each filtered image\n        y_c = H // 2\n\n        # For Median Filtered Image\n        r_med = I_med[y_c, :]\n        d_med = np.diff(r_med)\n        # argmax returns the first occurrence of max, fulfilling the \"smallest index\" rule\n        i_hat_med = np.argmax(np.abs(d_med))\n\n        # For Gaussian Filtered Image\n        r_gauss = I_gauss[y_c, :]\n        d_gauss = np.diff(r_gauss)\n        i_hat_gauss = np.argmax(np.abs(d_gauss))\n\n        # Step 6: Quantify edge localization error\n        i_star = x0 - 1\n        \n        e_med = np.abs(i_hat_med - i_star)\n        e_gauss = np.abs(i_hat_gauss - i_star)\n        \n        d_star = float(e_gauss - e_med)\n        results.append(d_star)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{val:.3f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在临床实践中，如CT或MRI等三维医学图像经常具有各向异性的体素间距，即层间分辨率远低于层内分辨率。在这种“厚层”数据上，若天真地应用在物理空间中各向同性的平滑滤波器，将导致沿层间方向的严重模糊，丢失薄层结构的细节。本项高级实践将指导您设计一个各向异性滤波器，利用调制传递函数（MTF）这一频域工具来约束滤波核的形状，使其智能地适应数据的各向异性特性，从而在有效降噪的同时保护关键的层间结构。",
            "id": "4540846",
            "problem": "给定一个用于表示具有各向异性体素间距的计算机断层扫描（CT）采集的三维图像采样网格。沿正交轴的体素间距分别表示为 $s_x$、$s_y$ 和 $s_z$，单位为毫米。您的任务是设计一种使用高斯核的三维线性平滑策略，该策略在保持平面内去噪的同时，避免薄结构在穿透平面方向上的模糊。设计应从卷积、高斯点扩散函数和调制传递函数的定义等第一性原理出发，并应明确论证沿穿透平面方向的采样。\n\n从以下核心定义和事实开始：离散空间中由核函数加权的求和形式的卷积、作为经过充分检验的平滑核的高斯函数、作为线性移不变系统脉冲响应的点扩散函数概念，以及作为点扩散函数傅里叶变换幅值的调制传递函数。使用这些作为基础起点来推导您的设计。除这些基础定义外，不要假设任何预先推导的“捷径”公式。\n\n您的程序必须实现以下规范。\n\n1. 基线设计和各向异性设计\n   - 每个测试用例的输入：\n     - 一个体素间距三元组 $(s_x, s_y, s_z)$，单位均为毫米。\n     - 一个目标平面内平滑尺度 $\\sigma_{\\text{in}}$，单位为毫米。\n   - 基线物理单位各向同性设计：\n     - 使用一个三维高斯函数，其标准差在物理单位下为 $\\sigma_x = \\sigma_{\\text{in}}$、$\\sigma_y = \\sigma_{\\text{in}}$ 和 $\\sigma_z = \\sigma_{\\text{in}}$，单位为毫米。\n   - 提出的各向异性设计：\n     - 保持平面内参数与基线设计相同：$\\sigma_x = \\sigma_{\\text{in}}$ 和 $\\sigma_y = \\sigma_{\\text{in}}$，单位为毫米。\n     - 通过在穿透平面方向的奈奎斯特频率上施加锐度约束来选择 $\\sigma_z$（单位为毫米）。具体来说，要求沿 $z$ 轴在 $f_z = 0.5$ 周期/体素处的调制传递函数至少为一个固定的阈值 $T_0$（一个小数）。在所有满足此约束的高斯 $\\sigma_z$ 中，选择不超过基线值的最大值，即选择 $\\sigma_z$ 使得 $0 \\le \\sigma_z \\le \\sigma_{\\text{in}}$，并且如果可能，使调制传递函数的要求以等式成立。频率变量 $f_z$ 的单位是沿 $z$ 轴的周期/体素，阈值 $T_0$ 必须视为无量纲。\n\n2. 沿穿透平面方向的离散泄漏度量\n   - 对于任何以体素单位 $\\sigma_{\\text{vox}}$ 表示的一维高斯标准差，通过在从 $-R$ 到 $R$ 的整数位置 $n$ 上对连续高斯函数进行采样，构造一个沿 $z$ 轴的对称、归一化的一维离散高斯核 $k[n]$，其中 $R = \\lceil 3 \\sigma_{\\text{vox}} \\rceil$。使用与 $\\exp\\!\\left(-\\frac{n^2}{2 \\sigma_{\\text{vox}}^2}\\right)$ 成比例的权重，然后将权重归一化，使其总和为 $1$。如果 $\\sigma_{\\text{vox}} = 0$，则将核解释为在 $n = 0$ 处的克罗内克δ函数。\n   - 将穿透平面泄漏分数 $L_z$ 定义为中心切片之外的总概率质量：\n     $$L_z = 1 - \\frac{k[0]}{\\sum_{n=-R}^{R} k[n]}.$$\n     在精确归一化下，分母等于 $1$，但您必须明确地实现离散构造，并从得到的归一化核中计算泄漏。\n\n3. 调制传递函数的评估\n   - 使用高斯点扩散函数对沿 $z$ 轴的调制传递函数进行建模，并在频率 $f_z = 0.5$ 周期/体素处进行评估。在您的解决方案中，提供一个有原则的推导，说明如何根据其以体素单位表示的标准差来计算高斯函数的调制传递函数。然后，用它来计算基线设计和各向异性设计在 $f_z = 0.5$ 周期/体素处的调制传递函数值 $M_z$。\n\n4. 比较准则\n   - 对于每个测试用例，输出一个布尔值，指示与基线物理单位各向同性设计相比，所提出的各向异性设计是否严格减少了穿透平面泄漏并在奈奎斯特频率处严格增加了穿透平面调制传递。形式上，计算 $L_z^{\\text{base}}$、$M_z^{\\text{base}}$、$L_z^{\\text{aniso}}$ 和 $M_z^{\\text{aniso}}$。当且仅当 $L_z^{\\text{aniso}}  L_z^{\\text{base}}$ 和 $M_z^{\\text{aniso}} > M_z^{\\text{base}}$ 时输出 true。\n\n5. 单位和转换\n   - 在计算沿 $z$ 轴的离散核和调制传递函数时，将任何以毫米为单位的穿透平面标准差除以 $s_z$（以毫米为单位），转换为体素单位。穿透平面奈奎斯特频率 $f_z = 0.5$ 必须解释为周期/体素。\n\n6. 全局设计常数\n   - 对所有测试用例使用固定的调制传递阈值 $T_0 = 0.9$。\n\n7. 测试套件\n   - 您的程序必须精确评估以下五个测试用例，每个测试用例指定为 $((s_x,s_y,s_z), \\sigma_{\\text{in}})$，其中间距单位为毫米，平滑尺度单位为毫米：\n     - 案例 1: $((0.6, 0.6, 3.0), 1.0)$\n     - 案例 2: $((0.8, 0.8, 1.0), 0.8)$\n     - 案例 3: $((0.5, 0.7, 5.0), 1.2)$\n     - 案例 4: $((0.5, 0.5, 10.0), 1.0)$\n     - 案例 5: $((0.5, 0.5, 3.0), 0.2)$\n\n8. 最终输出格式\n   - 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的小写布尔值列表的结果，例如，“[true,false,true,false,true]”。输出中不允许有额外的文本或空格。不涉及角度，因此不需要角度单位。所有以毫米表示的量必须按上述规定处理，最终输出是无单位的布尔值。",
            "solution": "该问题是有效的。它在科学上基于线性系统和信号处理的原理，信息完备、定义明确，并且表述客观。我们现在将提供一个完整的、有理有据的解决方案。\n\n目标是设计和比较两种用于各向异性三维图像数据的高斯平滑策略，并从基本原理出发。比较的关键在于穿透平面方向的调制传递函数（MTF）和一个离散泄漏度量。\n\n### 基本原理：PSF 和 MTF\n\n线性移不变（LSI）滤波操作由卷积描述。输出信号是输入信号与滤波器脉冲响应（称为点扩散函数，PSF）的卷积。对于我们沿 $z$ 轴的一维分析，PSF 是一个连续的高斯函数 $g(z; \\sigma_z)$，其标准差 $\\sigma_z$ 以物理单位（例如，毫米）表示：\n$$g(z; \\sigma_z) = \\frac{1}{\\sqrt{2\\pi}\\sigma_z} e^{-\\frac{z^2}{2\\sigma_z^2}}$$\n该函数被归一化，使得 $\\int_{-\\infty}^{\\infty} g(z; \\sigma_z) dz = 1$。\n\n调制传递函数（MTF）是表征成像系统或滤波器分辨率的关键度量。它被定义为 PSF 的傅里叶变换的幅值。设 $k_z$ 为沿 $z$ 轴的空间频率，单位为周期/毫米。PSF 的傅里叶变换 $G(k_z)$ 为：\n$$G(k_z) = \\mathcal{F}\\{g(z; \\sigma_z)\\} = \\int_{-\\infty}^{\\infty} g(z; \\sigma_z) e^{-i 2\\pi k_z z} dz$$\n使用已知的高斯函数傅里叶变换对，即 $e^{-ax^2}$ 的傅里叶变换是 $\\sqrt{\\pi/a} e^{-(\\pi k)^2/a}$，我们可以推导出 $G(k_z)$。我们的函数与 $e^{-z^2 / (2\\sigma_z^2)}$ 成比例。其变换为：\n$$G(k_z) = \\frac{1}{\\sqrt{2\\pi}\\sigma_z} \\mathcal{F}\\left\\{e^{-\\frac{z^2}{2\\sigma_z^2}}\\right\\} = \\frac{1}{\\sqrt{2\\pi}\\sigma_z} \\left( \\sqrt{2\\pi\\sigma_z^2} e^{-\\frac{(2\\pi k_z)^2}{4 \\cdot (1/(2\\sigma_z^2))}} \\right) = e^{-2\\pi^2 k_z^2 \\sigma_z^2}$$\nMTF，$M(k_z)$，是 $G(k_z)$ 的幅值。由于 $G(k_z)$ 是实数且为正，MTF 就是：\n$$M(k_z) = |G(k_z)| = e^{-2\\pi^2 k_z^2 \\sigma_z^2}$$\n问题以无量纲单位“周期/体素”指定频率，记为 $f_z$。物理频率 $k_z$（周期/毫米）与离散频率 $f_z$（周期/体素）之间的关系是 $k_z = f_z / s_z$，其中 $s_z$ 是以毫米为单位的体素间距。将此代入 MTF 方程得：\n$$M(f_z) = e^{-2\\pi^2 (f_z/s_z)^2 \\sigma_z^2} = e^{-2\\pi^2 f_z^2 (\\sigma_z/s_z)^2}$$\n我们将以体素为单位的标准差定义为 $\\sigma_{z, \\text{vox}} = \\sigma_z / s_z$。MTF 方程简化为：\n$$M(f_z) = e^{-2\\pi^2 f_z^2 \\sigma_{z, \\text{vox}}^2}$$\n这是我们进行 MTF 计算的核心公式。\n\n### 设计与分析\n\n我们将分析两种设计：一个基线各向同性设计和一个提出的各向异性设计。\n\n#### 1. 基线各向同性设计\n在此设计中，平滑在物理空间中是各向同性的。穿透平面方向的标准差被设置为平面内目标值：\n$$\\sigma_{z, \\text{base}} = \\sigma_{\\text{in}}$$\n为评估其 MTF，我们首先将其转换为体素单位：\n$$\\sigma_{z, \\text{base, vox}} = \\frac{\\sigma_{z, \\text{base}}}{s_z} = \\frac{\\sigma_{\\text{in}}}{s_z}$$\n在穿透平面奈奎斯特频率 $f_z = 0.5$ 周期/体素处的 MTF 是：\n$$M_z^{\\text{base}} = M(f_z=0.5) = e^{-2\\pi^2 (0.5)^2 \\sigma_{z, \\text{base, vox}}^2} = e^{-(\\pi^2/2) (\\sigma_{\\text{in}}/s_z)^2}$$\n\n#### 2. 提出的各向异性设计\n此设计旨在通过约束 MTF 来保持穿透平面方向的锐度。平面内平滑保持为 $\\sigma_x = \\sigma_y = \\sigma_{\\text{in}}$。穿透平面方向的标准差 $\\sigma_{z, \\text{aniso}}$ 被选为满足两个条件的最大值：\n1. 在奈奎斯特频率 ($f_z=0.5$) 处的 MTF 至少为 $T_0$：$M(0.5) \\geq T_0$。\n2. 平滑程度不大于基线：$0 \\le \\sigma_{z, \\text{aniso}} \\le \\sigma_{\\text{in}}$。\n\n让我们求解 MTF 约束以得到 $\\sigma_{z, \\text{aniso, vox}}$：\n$$e^{-(\\pi^2/2) \\sigma_{z, \\text{aniso, vox}}^2} \\geq T_0$$\n对两边取自然对数（并注意对于 $T_0=0.9$，$\\ln(T_0)$ 是负数）：\n$$-(\\pi^2/2) \\sigma_{z, \\text{aniso, vox}}^2 \\geq \\ln(T_0)$$\n$$\\sigma_{z, \\text{aniso, vox}}^2 \\leq -\\frac{2\\ln(T_0)}{\\pi^2}$$\n$$\\sigma_{z, \\text{aniso, vox}} \\leq \\sqrt{-\\frac{2\\ln(T_0)}{\\pi^2}}$$\n为了最大化 $\\sigma_{z, \\text{aniso}}$（从而最大化 $\\sigma_{z, \\text{aniso, vox}}$），我们取其上界。满足 MTF 约束等式的物理单位目标标准差为：\n$$\\sigma_{z, \\text{max_allowed}} = s_z \\cdot \\sqrt{-\\frac{2\\ln(T_0)}{\\pi^2}}$$\n应用第二个条件 $0 \\le \\sigma_{z, \\text{aniso}} \\le \\sigma_{\\text{in}}$，各向异性标准差的最终选择是：\n$$\\sigma_{z, \\text{aniso}} = \\min\\left(\\sigma_{\\text{in}}, \\sigma_{z, \\text{max_allowed}}\\right) = \\min\\left(\\sigma_{\\text{in}}, s_z \\sqrt{-\\frac{2\\ln(0.9)}{\\pi^2}}\\right)$$\n相应的 MTF 使用 $\\sigma_{z, \\text{aniso, vox}} = \\sigma_{z, \\text{aniso}} / s_z$ 计算：\n$$M_z^{\\text{aniso}} = e^{-(\\pi^2/2) \\sigma_{z, \\text{aniso, vox}}^2}$$\n\n#### 3. 穿透平面泄漏度量（$L_z$）\n泄漏分数 $L_z$ 量化了平滑核的质量有多少“泄漏”到相邻的 $z$ 切片中。它是根据离散一维高斯核 $k[n]$ 计算得出的。对于给定的以体素为单位的标准差 $\\sigma_{\\text{vox}}$，核的构造如下。\n首先，确定核的半宽：$R = \\lceil 3\\sigma_{\\text{vox}} \\rceil$。核的支撑集是 $n \\in \\{-R, -R+1, \\dots, R-1, R\\}$。\n未归一化的权重通过在整数位置采样高斯函数得到：\n$$w[n] = e^{-\\frac{n^2}{2\\sigma_{\\text{vox}}^2}}$$\n这些权重的总和是 $S = \\sum_{n=-R}^{R} w[n]$。归一化的核是 $k[n] = w[n]/S$。\n泄漏分数是中心元素（$n=0$）之外的质量：\n$$L_z = 1 - k[0]$$\n由于 $w[0] = e^0 = 1$，我们有 $k[0] = 1/S$。因此，\n$$L_z = 1 - \\frac{1}{\\sum_{n=-R}^{R} e^{-n^2 / (2\\sigma_{\\text{vox}}^2)}}$$\n对 $\\sigma_{z, \\text{base, vox}}$ 和 $\\sigma_{z, \\text{aniso, vox}}$ 都执行此计算，以分别获得 $L_z^{\\text{base}}$ 和 $L_z^{\\text{aniso}}$。如果 $\\sigma_{\\text{vox}}=0$，核是克罗内克δ函数，$k[0]=1$ 且 $L_z=0$。\n\n#### 4. 比较准则\n每个测试用例的最终输出是一个布尔值，指示各向异性设计在锐度和泄漏两个方面是否都严格优于基线设计。当且仅当以下两个严格不等式都成立时，该值为真：\n$$M_z^{\\text{aniso}} > M_z^{\\text{base}} \\quad \\text{和} \\quad L_z^{\\text{aniso}}  L_z^{\\text{base}}$$\nMTF 和泄漏分数都与 $\\sigma_{z, \\text{vox}}$ 单调相关。较小的 $\\sigma_{z, \\text{vox}}$ 会产生更锐利的核，这对应于更高的 MTF 值和更低的泄漏。因此，当且仅当 $\\sigma_{z, \\text{aniso, vox}}  \\sigma_{z, \\text{base, vox}}$ 时，两个不等式同时满足，这等价于 $\\sigma_{z, \\text{aniso}}  \\sigma_{z, \\text{base}}$。这种情况恰好在基线 MTF 低于阈值 $T_0$ 时发生，即 $M_z^{\\text{base}}  T_0 = 0.9$，这迫使各向异性设计使用一个更小的、非基线的 $\\sigma_z$。如果 $M_z^{\\text{base}} \\ge T_0$，那么 $\\sigma_{z, \\text{aniso}} = \\sigma_{z, \\text{base}}$，严格不等式不成立。实现将明确计算所有四个度量并进行比较。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_metrics(sigma_mm: float, s_z: float):\n    \"\"\"\n    Calculates the through-plane MTF and leakage for a given smoothing standard deviation.\n\n    Args:\n        sigma_mm: The Gaussian standard deviation in millimeters.\n        s_z: The voxel spacing along the z-axis in millimeters.\n\n    Returns:\n        A tuple (mtf, leakage).\n    \"\"\"\n    # If sigma_mm is zero, sigma_vox is also zero.\n    # The PSF is a Dirac delta, its Fourier transform is flat (MTF=1).\n    # The discrete kernel is a Kronecker delta, so all mass is at n=0 (leakage=0).\n    if sigma_mm == 0.0 or s_z == 0.0:\n        return 1.0, 0.0\n\n    sigma_vox = sigma_mm / s_z\n\n    # Calculate MTF at the Nyquist frequency (f_z = 0.5 cycles/voxel)\n    # Formula: M(f_z) = exp(-2 * pi^2 * f_z^2 * sigma_vox^2)\n    # With f_z = 0.5, this simplifies to M = exp(-(pi^2 / 2) * sigma_vox^2)\n    mtf = np.exp(-(np.pi**2 / 2.0) * (sigma_vox**2))\n\n    # Calculate through-plane leakage L_z\n    # The kernel radius is R = ceil(3 * sigma_vox)\n    R = int(np.ceil(3.0 * sigma_vox))\n    \n    # integer positions n from -R to R\n    n_values = np.arange(-R, R + 1)\n    \n    # Unnormalized kernel weights w[n] = exp(-n^2 / (2 * sigma_vox^2))\n    weights = np.exp(-(n_values**2) / (2.0 * sigma_vox**2))\n    \n    # Sum of weights for normalization\n    total_weight = np.sum(weights)\n    \n    # The central weight k[0] is w[0]/S. Since w[0] = exp(0) = 1, k[0] = 1/S.\n    # We must handle the case where total_weight is zero or numerically unstable,\n    # though for this problem it should always be >= 1.0.\n    if total_weight == 0.0:\n        k_0 = 0.0\n    else:\n        k_0 = 1.0 / total_weight\n    \n    # Leakage L_z = 1 - k[0]\n    leakage = 1.0 - k_0\n\n    return mtf, leakage\n\ndef solve():\n    \"\"\"\n    Solves the problem for the specified test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: ((s_x, s_y, s_z), sigma_in)\n    test_cases = [\n        ((0.6, 0.6, 3.0), 1.0),\n        ((0.8, 0.8, 1.0), 0.8),\n        ((0.5, 0.7, 5.0), 1.2),\n        ((0.5, 0.5, 10.0), 1.0),\n        ((0.5, 0.5, 3.0), 0.2),\n    ]\n\n    # Global design constant\n    T0 = 0.9\n\n    results = []\n    for case in test_cases:\n        (sx, sy, sz), sigma_in = case\n\n        # 1. Baseline isotropic-in-physical-units design\n        sigma_z_base = sigma_in\n        mtf_base, leakage_base = calculate_metrics(sigma_z_base, sz)\n\n        # 2. Proposed anisotropic design\n        # First, find the maximum sigma_z (in mm) that satisfies MTF >= T0\n        # M = exp(-(pi^2/2) * (sigma_vox^2)) >= T0\n        # sigma_vox = sqrt(-2 * log(T0) / pi^2)\n        # sigma_mm = sz * sqrt(-2 * log(T0) / pi^2)\n        log_T0 = np.log(T0)\n        # Check for invalid log domain, though T0=0.9 is safe.\n        if log_T0 > 0:\n            sigma_z_max_allowed = 0.0 # No positive sigma satisfies the constraint\n        else:\n            sigma_z_max_allowed = sz * np.sqrt(-2.0 * log_T0 / np.pi**2)\n        \n        # The anisotropic sigma_z is the largest value satisfying both constraints\n        # sigma_z = sigma_in AND sigma_z = sigma_z_max_allowed\n        sigma_z_aniso = min(sigma_in, sigma_z_max_allowed)\n\n        mtf_aniso, leakage_aniso = calculate_metrics(sigma_z_aniso, sz)\n        \n        # 3. Comparison Criterion\n        # Output true if anisotropic design is strictly better on both metrics\n        is_strictly_better = (leakage_aniso  leakage_base) and (mtf_aniso > mtf_base)\n        \n        results.append(str(is_strictly_better).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}