{
    "hands_on_practices": [
        {
            "introduction": "任何分类模型的有效性都必须通过定量指标来衡量。本练习将介绍从混淆矩阵中派生出的基本评估指标，包括精确率 (precision)、召回率 (recall) 和 $F_1$ 分数，为评估变异检测模型提供核心的量化语言。通过解决这个问题 ，您将掌握评估任何深度学习变异检测器性能的基础技能。",
            "id": "4554266",
            "problem": "一个用于单核苷酸变异 (SNV) 检出的深度学习分类器，通过将其后验概率输出以 $0.9$ 为阈值，在每个基因组位点上做出二元决策；后验概率至少为 $0.9$ 的位点被检出为变异，否则被检出为非变异。在一个从“瓶中基因组” (Genome in a Bottle, GIAB) 项目整理出的留存基准真实数据集中，有 $200{,}000$ 个位点存在真实标签。该真实数据集包含 $15{,}000$ 个确实含有 SNV 的位点和 $185{,}000$ 个确实不含 SNV 的位点。当应用该分类器时，其检出结果与真实标签相比较，产生以下计数：$12{,}000$ 个真阳性 ($TP$)，$2{,}000$ 个假阳性 ($FP$)，$183{,}000$ 个真阴性 ($TN$)，以及 $3{,}000$ 个假阴性 ($FN$)。\n\n从医学检验评估中二元分类的标准混淆矩阵类别出发，用 $TP$、$FP$、$TN$ 和 $FN$ 定义以下用于变异检出的性能指标：\n- 敏感性 (真阳性率)，\n- 特异性 (真阴性率)，\n- 精确率 (阳性预测值)，\n- 召回率，\n- 以及 $F_{1}$ 分数，定义为精确率和召回率的调和平均值。\n\n然后，使用提供的计数计算这些指标。最终答案仅报告 $F_{1}$ 分数，表示为一个未经四舍五入且无单位的精确分数。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知信息\n- 一个深度学习分类器为单核苷酸变异 (SNV) 提供二元决策（变异/非变异）。\n- 分类阈值：后验概率 $\\ge 0.9$。\n- 具有真实标签的基准位点总数：$200{,}000$。\n- 真实 SNV 位点数（条件阳性，$P$）：$15{,}000$。\n- 真实非 SNV 位点数（条件阴性，$N$）：$185{,}000$。\n- 来自混淆矩阵的分类器性能计数：\n  - 真阳性 ($TP$)：$12{,}000$。\n  - 假阳性 ($FP$)：$2{,}000$。\n  - 真阴性 ($TN$)：$183{,}000$。\n  - 假阴性 ($FN$)：$3{,}000$。\n- 任务是：用 $TP$、$FP$、$TN$ 和 $FN$ 定义敏感性、特异性、精确率、召回率和 $F_1$ 分数，计算它们的值，并以精确分数的形式报告 $F_1$ 分数。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据，提法明确且客观。它描述了生物信息学领域中一个标准的二元分类性能评估任务，使用了明确定义的指标和术语。所提供的数值数据是自洽且完整的。\n\n- **检查内部一致性**：\n  - 条件阳性位点的总数给出为 $15{,}000$。这些位点的结果之和为 $TP + FN = 12{,}000 + 3{,}000 = 15{,}000$。这与已知信息一致。\n  - 条件阴性位点的总数给出为 $185{,}000$。这些位点的结果之和为 $TN + FP = 183{,}000 + 2{,}000 = 185{,}000$。这也与已知信息一致。\n  - 位点总数为 $P + N = 15{,}000 + 185{,}000 = 200{,}000$。所有混淆矩阵元素的总和为 $TP + FP + TN + FN = 12{,}000 + 2{,}000 + 183{,}000 + 3{,}000 = 200{,}000$。这与已知信息一致。\n\n所有数据点都是连贯的，并且足以解决该问题。该问题有效。\n\n### 第 3 步：结论与行动\n该问题被认定为有效。现在将推导解答。\n\n二元分类器的评估基于四种可能结果的计数，这些结果表示在一个混淆矩阵中：\n- **真阳性 ($TP$)**：被正确分类为阳性的阳性实例数量。在这里，是正确检出为变异的真实 SNV 的数量。$TP=12{,}000$。\n- **假阳性 ($FP$)**：被错误分类为阳性的阴性实例数量。在这里，是错误检出为变异的真实非 SNV 的数量。$FP=2{,}000$。\n- **真阴性 ($TN$)**：被正确分类为阴性的阴性实例数量。在这里，是正确检出为非变异的真实非 SNV 的数量。$TN=183{,}000$。\n- **假阴性 ($FN$)**：被错误分类为阴性的阳性实例数量。在这里，是错误检出为非变异的真实 SNV 的数量。$FN=3{,}000$。\n\n条件阳性实例的总数是 $P = TP + FN$。条件阴性实例的总数是 $N = TN + FP$。\n\n我们现在用这些量来定义所要求的性能指标。\n\n**敏感性（真阳性率）**：此指标衡量被正确识别的实际阳性样本的比例。它也称为召回率。\n$$\n\\text{Sensitivity} = \\frac{TP}{P} = \\frac{TP}{TP + FN}\n$$\n\n**特异性（真阴性率）**：此指标衡量被正确识别的实际阴性样本的比例。\n$$\n\\text{Specificity} = \\frac{TN}{N} = \\frac{TN}{TN + FP}\n$$\n\n**精确率（阳性预测值，PPV）**：此指标衡量预测为阳性的样本中实际为阳性的比例。\n$$\n\\text{Precision} = \\frac{TP}{TP + FP}\n$$\n\n**召回率**：如前所述，召回率与敏感性是同义词。它衡量被正确识别的实际阳性样本的比例。\n$$\n\\text{Recall} = \\frac{TP}{P} = \\frac{TP}{TP + FN}\n$$\n\n**$F_1$ 分数**：$F_1$ 分数定义为精确率和召回率的调和平均值。两个数 $a$ 和 $b$ 的调和平均值由 $2 \\cdot \\frac{ab}{a+b}$ 给出。\n$$\nF_1 = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}}\n$$\n代入精确率和召回率的表达式：\n$$\nF_1 = 2 \\cdot \\frac{\\left(\\frac{TP}{TP + FP}\\right) \\cdot \\left(\\frac{TP}{TP + FN}\\right)}{\\left(\\frac{TP}{TP + FP}\\right) + \\left(\\frac{TP}{TP + FN}\\right)} = \\frac{2 TP^2}{TP(TP+FN) + TP(TP+FP)}\n$$\n简化此表达式可得一个更直接的公式：\n$$\nF_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN}\n$$\n\n现在，我们使用提供的数值计算这些指标：$TP=12{,}000$，$FP=2{,}000$，$TN=183{,}000$ 和 $FN=3{,}000$。\n\n首先，我们计算精确率和召回率。\n$$\n\\text{Precision} = \\frac{12{,}000}{12{,}000 + 2{,}000} = \\frac{12{,}000}{14{,}000} = \\frac{12}{14} = \\frac{6}{7}\n$$\n$$\n\\text{Recall} = \\frac{12{,}000}{12{,}000 + 3{,}000} = \\frac{12{,}000}{15{,}000} = \\frac{12}{15} = \\frac{4}{5}\n$$\n虽然最终答案中未要求，但敏感性等于召回率，所以 $\\text{Sensitivity} = \\frac{4}{5}$。特异性为：\n$$\n\\text{Specificity} = \\frac{183{,}000}{183{,}000 + 2{,}000} = \\frac{183{,}000}{185{,}000} = \\frac{183}{185}\n$$\n最后，我们使用精确率和召回率的值计算 $F_1$ 分数。\n$$\nF_1 = 2 \\cdot \\frac{\\text{Precision} \\cdot \\text{Recall}}{\\text{Precision} + \\text{Recall}} = 2 \\cdot \\frac{\\frac{6}{7} \\cdot \\frac{4}{5}}{\\frac{6}{7} + \\frac{4}{5}}\n$$\n分子中的乘积是 $\\frac{6}{7} \\cdot \\frac{4}{5} = \\frac{24}{35}$。\n分母中的和是 $\\frac{6}{7} + \\frac{4}{5} = \\frac{6 \\cdot 5}{35} + \\frac{4 \\cdot 7}{35} = \\frac{30+28}{35} = \\frac{58}{35}$。\n将这些代回 $F_1$ 公式：\n$$\nF_1 = 2 \\cdot \\frac{\\frac{24}{35}}{\\frac{58}{35}} = 2 \\cdot \\frac{24}{58} = \\frac{48}{58} = \\frac{24}{29}\n$$\n或者，使用 $F_1$ 分数的简化公式：\n$$\nF_1 = \\frac{2 \\cdot TP}{2 \\cdot TP + FP + FN} = \\frac{2 \\cdot 12{,}000}{2 \\cdot 12{,}000 + 2{,}000 + 3{,}000} = \\frac{24{,}000}{24{,}000 + 5{,}000} = \\frac{24{,}000}{29{,}000} = \\frac{24}{29}\n$$\n两种方法都得出了相同的精确分数，这符合最终答案的要求。",
            "answer": "$$\n\\boxed{\\frac{24}{29}}\n$$"
        },
        {
            "introduction": "准确的评估不仅取决于计算正确的指标，还取决于对我们所测量内容的深刻理解。在基因组学中，同一个生物学事实（例如一个单倍型）在VCF等数据格式中可能有多种等效的表示方式。本练习  探讨了这些表示上的差异如何使评估过程变得复杂，并阐明了为何变异表示的标准化是进行精确基准测试的关键步骤。",
            "id": "4554271",
            "problem": "一个基因组变异可以建模为应用于参考单倍型的一系列有限的编辑操作。假设局部参考子串在基于1的坐标 $i$ 处定义为 $R[i..i+2] = \\text{\"GAT\"}$，该子串嵌入在非重复性上下文中，以确保左对齐是唯一的。测序读段堆积和组装的单倍型表明，该位点与参考序列的不同之处在于一个相邻的单核苷酸变异 (SNV) 和一个长度为2个碱基对的缺失，所有编辑操作后，在同一位点产生替代单倍型子串 $\\text{\"T\"}$。基于以下基本规则：\n- 编辑语义如下：一个SNV在其坐标处替换单个碱基，一个缺失移除一个连续的碱基块，每个变异都在变异调用格式 (VCF) 中表示，并带有一个锚定碱基，以使参考等位基因和替代等位基因至少共享最左边的碱基。\n- 如果两种表示在应用于参考序列 $R$ 后产生相同的替代单倍型字符串，则认为它们是等效的。\n\n根据这些定义、作为序列编辑重要性生物学基础的分子生物学中心法则（DNA到RNA到蛋白质），以及广泛接受的标准化实践（左对齐和插入缺失的最小表示），选择所有关于构建等效表示及其对使用卷积神经网络（CNNs）在堆积图像上训练的深度学习变异调用器所产生影响的正确陈述。\n\n选项：\n\nA. 一个具有VCF字段 $\\,\\text{POS}=i,\\ \\text{REF}=\\text{\"GAT\"},\\ \\text{ALT}=\\text{\"T\"}\\,$ 的单记录复杂等位基因，与分解为原始事件（包括一个在 $i$ 处、$\\,\\text{REF}=\\text{\"G\"},\\ \\text{ALT}=\\text{\"T\"}\\,$ 的SNV，以及一个从 $i$ 开始、长度为2个碱基的缺失，该缺失使用锚定碱基表示为 $\\,\\text{POS}=i,\\ \\text{REF}=\\text{\"GAT\"},\\ \\text{ALT}=\\text{\"G\"}\\,$）在单倍型上是等效的。\n\nB. 将这个相邻的SNV加上2个碱基对的缺失表示为单个多核苷酸多态性（MNP）是有效的，因为锚定碱基保证了替代等位基因可以表示为与参考等位基因相同的长度。\n\nC. 如果一个深度学习调用器被训练用于输出原始事件（单独的SNV和插入缺失），但评估用的真集将此类位点编码为单个块替换，那么在比较前若未能进行标准化（例如，左对齐并合并为最小块形式），即使预测的单倍型是正确的，也会因表示不匹配而导致假阳性和假阴性的数量膨胀。\n\nD. 在重复序列上下文中，左对齐可能会改变缺失的起始坐标，而将相邻的SNV与该缺失合并为块替换会移动有效改变点，因此朴素的按位点分类可能在不同表示之间产生分歧；单倍型感知调用器通过对产生相同替代单倍型的编辑等价类进行建模来缓解此问题。\n\nE. 基于图的变异调用器固有地为此类复杂事件生成唯一的规范表示，从而使得在跨数据集进行公平评估和训练对齐时无需进行下游标准化。\n\n选择所有正确的选项。",
            "solution": "在尝试任何解决方案之前，首先对问题陈述的有效性进行严格评估。\n\n**步骤1：提取给定条件**\n-   局部参考子串：$R[i..i+2] = \\text{\"GAT\"}$，位于基于1的坐标 $i$ 处。\n-   序列上下文：非重复性，确保左对齐唯一。\n-   观察到的事件：一个相邻的单核苷酸变异 (SNV) 和一个长度为2个碱基对的缺失。\n-   最终的替代单倍型子串：$\\text{\"T\"}$。\n-   编辑语义：\n    -   SNV替换单个碱基。\n    -   缺失移除一个连续的碱基块。\n    -   变异调用格式 (VCF) 表示使用一个锚定碱基，使得参考 (REF) 和替代 (ALT) 等位基因至少共享最左边的碱基。\n-   等效条件：如果两种表示在应用于参考序列 $R$ 后产生相同的替代单倍型字符串，则它们是等效的。\n-   生物学背景：分子生物学中心法则（DNA到RNA到蛋白质）。\n-   标准实践：左对齐和插入缺失的最小表示。\n-   技术背景：使用卷积神经网络 (CNN) 对堆积图像进行分析的深度学习变异调用器。\n\n**步骤2：使用提取的给定条件进行验证**\n-   **科学依据**：该问题在生物信息学、基因组学和计算生物学的既定原则方面有充分的依据。SNV、缺失、变异标准化（左对齐、最小表示）、单倍型等效性、VCF格式以及深度学习在变异调用中的应用等概念，都是该领域内标准且真实的概念。所提供的复杂变异示例是现实的。\n-   **定义明确**：该问题定义明确。它提供了一个清晰的参考状态（$\\text{\"GAT\"}$）、一个清晰的最终状态（$\\text{\"T\"}$）以及一套用于评估陈述的规则（VCF语义、等效性）。它要求对这些表示及其影响进行定性分析，这是科学和工程领域中概念性问题的标准形式。\n-   **客观性**：该问题使用了来自遗传学和生物信息学的精确、标准和客观的术语。问题设置中没有主观或模糊的语言。\n\n**步骤3：结论与行动**\n-   问题陈述是有效的。它在科学上是合理的、定义明确的、客观的，并提出了一个在现代生物信息学中非凡且相关的场景。现在将进行求解过程。\n\n**原理推导**\n\n问题的核心是基因组变异的表示，其中位于坐标 $i$ 开始的位点上的参考序列 $\\text{\"GAT\"}$ 被改变为序列 $\\text{\"T\"}$。这种净变化可以用多种方式描述，其等效性取决于它们是否产生相同的最终单倍型。\n\n1.  **块替换/复杂等位基因表示**：\n    对净变化最直接和最小的表示是描述整个改变的单个VCF记录。\n    -   参考等位基因 (REF)：$\\text{\"GAT\"}$\n    -   替代等位基因 (ALT)：$\\text{\"T\"}$\n    -   VCF记录：$\\text{POS}=i, \\text{REF}=\\text{\"GAT\"}, \\text{ALT}=\\text{\"T\"}$。\n    这种形式在标准化后被认为是规范表示，因为它简洁地描述了净效应。REF的长度为3，ALT的长度为1。\n\n2.  **分解为原始事件的表示**：\n    问题将该事件描述为“一个相邻的SNV和一个长度为2个碱基对的缺失”。我们可以将它们表示为独立的原始事件。\n    -   **SNV**：第一个碱基 $\\text{'G'}$ 被替换为 $\\text{'T'}$。这个位于坐标 $i$ 的SNV的VCF记录是 $\\text{POS}=i, \\text{REF}=\\text{\"G\"}, \\text{ALT}=\\text{\"T\"}$。\n    -   **缺失**：随后的2个碱基 $\\text{\"AT\"}$ 被删除。这个缺失从坐标 $i+1$ 开始。为了在需要锚定碱基的VCF中表示这一点，我们必须包含缺失之前的碱基。前面的碱基是位于坐标 $i$ 的 $\\text{'G'}$。因此，该缺失记录的参考等位基因变为 $\\text{\"GAT\"}$，而移除了 $\\text{\"AT\"}$ 后的替代等位基因变为 $\\text{\"G\"}$。\n    -   缺失的VCF记录：$\\text{POS}=i, \\text{REF}=\\text{\"GAT\"}, \\text{ALT}=\\text{\"G\"}$。\n    为了检查单倍型等效性，我们将这两个转换应用于参考序列。SNV将 $i$ 处的碱基 $\\text{'G'}$ 变为 $\\text{'T'}$。缺失移除了 $i+1$ 和 $i+2$ 处的碱基 $\\text{'A'}$ 和 $\\text{'T'}$。组合效应是将 $\\text{\"GAT\"}$ 替换为 $\\text{\"T\"}$。因此，这两个原始记录的集合与单个复杂记录在单倍型上是等效的。\n\n3.  **变异标准化及其对机器学习的影响**：\n    变异标准化是将不同但等效的变异表示转换为单一规范形式的过程。这通常涉及左对齐和将相邻的原始事件合并为最简洁（最小）的复杂表示。\n    在训练或评估变异调用器（尤其是机器学习模型）时，调用集（预测）和真集（标签）之间的表示差异可能导致不正确的性能指标。例如，如果一个模型预测了两个原始变异，而真集包含一个复杂变异，那么简单的VCF比较会记为2个假阳性和1个假阴性，即使底层预测的单倍型是正确的。这需要进行单倍型感知的比较，或在评估前对两个VCF文件进行标准化。\n\n**逐项分析**\n\n**A. 一个具有VCF字段 $\\,\\text{POS}=i,\\ \\text{REF}=\\text{\"GAT\"},\\ \\text{ALT}=\\text{\"T\"}\\,$ 的单记录复杂等位基因，与分解为原始事件（包括一个在 $i$ 处、$\\,\\text{REF}=\\text{\"G\"},\\ \\text{ALT}=\\text{\"T\"}\\,$ 的SNV，以及一个从 $i$ 开始、长度为2个碱基的缺失，该缺失使用锚定碱基表示为 $\\,\\text{POS}=i,\\ \\text{REF}=\\text{\"GAT\"},\\ \\text{ALT}=\\text{\"G\"}\\,$）在单倍型上是等效的。**\n-   **分析**：如上所述，单个复杂等位基因 `(POS=i, REF=\"GAT\", ALT=\"T\")` 将参考子串 $\\text{\"GAT\"}$ 转换为 $\\text{\"T\"}$。那对原始事件包括一个SNV `(POS=i, REF=\"G\", ALT=\"T\")` 和一个缺失 `(POS=i, REF=\"GAT\", ALT=\"G\")`。将这两个事件应用于参考序列会得到相同的结果：$i$ 处的 $\\text{'G'}$ 被替换为 $\\text{'T'}$，从 $i+1$ 开始的 $\\text{\"AT\"}$ 被移除。最终的单倍型子串是 $\\text{\"T\"}$。因此，这两种表示在单倍型上是等效的。所给出的VCF表示也符合标准惯例。\n-   **结论**：正确。\n\n**B. 将这个相邻的SNV加上2个碱基对的缺失表示为单个多核苷酸多态性（MNP）是有效的，因为锚定碱基保证了替代等位基因可以表示为与参考等位基因相同的长度。**\n-   **分析**：多核苷酸多态性 (MNP) 是一种多个核苷酸被替换的变异类型，意味着参考等位基因的长度等于替代等位基因的长度，且该长度大于1。在我们的例子中，变化是从 $\\text{\"GAT\"}$ 到 $\\text{\"T\"}$，所以 $\\text{length(REF)} = 3$ 且 $\\text{length(ALT)} = 1$。由于 $\\text{length(REF)} \\neq \\text{length(ALT)}$，该事件不是一个MNP。它是一个复杂的插入缺失或块替换。锚定碱基“保证了替代等位基因可以表示为与参考等位基因相同的长度”这一前提是根本错误的。VCF的锚定碱基约定专门用于表示插入缺失（indels），根据定义，插入缺失的 $\\text{length(REF)} \\neq \\text{length(ALT)}$。\n-   **结论**：不正确。\n\n**C. 如果一个深度学习调用器被训练用于输出原始事件（单独的SNV和插入缺失），但评估用的真集将此类位点编码为单个块替换，那么在比较前若未能进行标准化（例如，左对齐并合并为最小块形式），即使预测的单倍型是正确的，也会因表示不匹配而导致假阳性和假阴性的数量膨胀。**\n-   **分析**：这个陈述准确地描述了生物信息学基准测试中的一个关键问题。如果调用器输出了选项A中的两个原始事件，而真集包含单个复杂事件，那么基于文本或位置的朴素比较将找不到匹配的记录。这两个原始调用将被标记为假阳性 (FP)，而单个复杂调用将被标记为假阴性 (FN)。尽管调用器正确地推断出了底层的生物序列（单倍型），这种情况仍然会发生。将调用集和真集都标准化为规范表示是防止这种人为错误率膨胀并实现公平评估所需的标准程序。\n-   **结论**：正确。\n\n**D. 在重复序列上下文中，左对齐可能会改变缺失的起始坐标，而将相邻的SNV与该缺失合并为块替换会移动有效改变点，因此朴素的按位点分类可能在不同表示之间产生分歧；单倍型感知调用器通过对产生相同替代单倍型的编辑等价类进行建模来缓解此问题。**\n-   **分析**：这个陈述正确地将表示问题推广到了重复性上下文。在重复序列中，一个像 $\\text{...TATATA...} \\to \\text{...TATA...}$ 这样的插入缺失可以在多个位置表示。左对齐是将其移动到最左边可能坐标的惯例。当一个SNV与这样一个可移动的插入缺失相邻时，合并后的复杂等位基因的坐标取决于插入缺失对齐后的位置。一个在特定坐标（特定表示）上居中的堆积图像上训练的朴素分类器，如果面对一个等效但移位的表示，可能会失败。单倍型感知方法通过首先组装局部序列，然后基于组装的单倍型来调用变异，因此本质上对这些表示上的模糊性具有鲁棒性。它们比较的是整个单倍型序列，而不是差异的特定VCF编码。\n-   **结论**：正确。\n\n**E. 基于图的变异调用器固有地为此类复杂事件生成唯一的规范表示，从而使得在跨数据集进行公平评估和训练对齐时无需进行下游标准化。**\n-   **分析**：虽然基于图的方法在解决复杂区域的单倍型方面功能强大，但将所选图路径（单倍型）与参考路径之间的差异表示为一系列VCF记录的最后一步，在所有工具中并未标准化。不同的图调用器可能采用不同的算法来执行这个“变异展开”步骤，可能导致不同但单倍型等效的VCF表示。因此，断言它们*固有地*产生一种唯一的规范形式，从而无需所有下游标准化，是不正确的。为了针对规范真集进行严格的、与工具无关的评估，标准化步骤仍然是最佳实践，并且通常是必要的。\n-   **结论**：不正确。",
            "answer": "$$\\boxed{ACD}$$"
        },
        {
            "introduction": "在理解了评估和表示的挑战之后，我们自然会问：如何设计一个能有效处理这些复杂性的深度学习模型？本练习  挑战您以模型架构师的视角进行思考，设计一个先进的 Transformer 模型。您的任务是构思一种能够以感知比对信息的方式，智能地融合参考序列、测序读段和质量分数这三个不同信息模态的架构。",
            "id": "4554204",
            "problem": "您正在设计一个深度学习系统，用于对染色体上的一个候选位点进行基因组变异检测。给定一个以该位点为中心、长度为 $L$ 的参考窗口，一个覆盖该窗口大部分区域的比对读段，以及其每个碱基的 Phred 质量分数。目标是通过使用 Transformer 编码器对参考序列、读段序列和质量分数的联合上下文进行建模，来判断该位点是否存在单核苷酸多态性 (SNP) 或插入或缺失 (indel)。\n\n假设以下基础作为您的出发点。首先，一个 Transformer 编码器层对输入嵌入序列应用自注意力机制。对于带有嵌入 $\\mathbf{x}_{i}$ 和 $\\mathbf{x}_{j}$ 的词元索引 $i$ 和 $j$，缩放点积自注意力计算的注意力权重与 $\\exp(\\langle \\mathbf{q}_{i}, \\mathbf{k}_{j} \\rangle / \\sqrt{d})$ 成正比，其中 $\\mathbf{q}_{i} = \\mathbf{W}_{Q} \\mathbf{x}_{i}$，$\\mathbf{k}_{j} = \\mathbf{W}_{K} \\mathbf{x}_{j}$，$d$ 是键的维度，输出是值 $\\mathbf{v}_{j} = \\mathbf{W}_{V} \\mathbf{x}_{j}$ 的加权和。其次，Phred 质量分数 (Q) 定义为 $Q = -10 \\log_{10} p_{\\mathrm{err}}$，其中 $p_{\\mathrm{err}}$ 是碱基检出错误的概率。第三，读段与参考序列进行配对比对，并由一个简洁异构空位比对报告 (CIGAR) 字符串表示；您可以假设存在一个比对映射函数 $a$，当碱基匹配或错配时，它将读段索引 $r$ 映射到相应的参考坐标 $a(r)$，并在不适用时指示插入或缺失。\n\n您必须提出一个 Transformer 架构，该架构能够以一种感知比对信息、能处理插入和缺失、并以经过概率校准的方式使用质量分数的方式，联合关注参考序列、读段序列和质量分数。该架构应在词元化和嵌入层面进行阐述，任何与比对相关的注意力偏置都应能表示为对注意力 logit 的加法项。您可以自由使用特殊词元、片段嵌入以及位置或相对位置编码。最终输出可以是一个用于预测变异类型的分类词元，但您必须至少详细说明输入词元化、模态编码、位置编码、对插入和缺失的处理、质量分数编码以及感知比对信息的融合所需的任何注意力掩码或偏置。\n\n哪个选项指定了一个满足这些要求的有效 Transformer 设计？\n\nA. 将参考序列和读段序列拼接成一个单一的词元序列，使用分隔符词元和指示模态的片段嵌入。为参考词元和读段词元都分配等于参考坐标的绝对位置；通过在参考序列一侧引入空位词元来表示插入，并为插入的读段词元分配其左侧碱基的参考坐标外加一个学习到的分数偏移嵌入。添加一个依赖于词元间参考坐标有符号差异的相对位置编码。构建一个加性注意力偏置矩阵 $b_{ij}$，其中当词元 $i$ 和 $j$ 在比对映射 $a$ 下对应于比对上的碱基对时，$b_{ij} = \\beta$，否则 $b_{ij} = 0$，$\\beta$ 是可学习的。对于质量分数，将 $Q$ 转换为 $p_{\\mathrm{err}} = 10^{-Q/10}$，计算 logit $\\ell = \\log((1 - p_{\\mathrm{err}})/p_{\\mathrm{err}})$，并通过一个学习到的线性层将 $\\ell$ 投影到嵌入维度；仅将此投影添加到读段碱基词元上。将生成的序列输入一个多层 Transformer 编码器，该编码器具有通过加性偏置 $b_{ij}$ 增强的完全自注意力，并使用一个分类词元来聚合证据。\n\nB. 使用一维卷积神经网络对参考窗口进行编码，以生成单个定长向量。仅将读段词元（每个词元带有其绝对读段索引位置）输入到一个 Transformer 解码器中，该解码器与单个参考向量进行交叉注意力计算。通过获取质量分数字符串的原始 ASCII 字符，按其最大值进行归一化，然后线性投影到嵌入维度，将每个碱基的质量分数附加到词元嵌入上。不使用任何基于比对的位置信息；允许解码器通过其学习到的权重隐式推断插入和缺失。\n\nC. 通过将参考碱基、通过朴素索引相等对齐的读段碱基以及分箱为独热类别的质量分数配对，创建每个参考位置的三元组词元。使用基于参考索引的绝对位置编码。应用一个普通的 Transformer 编码器，不使用片段嵌入，也不对插入和缺失进行特殊处理。模型通过用常数掩盖注意力矩阵的对角线来学习忽略未对齐的位置。质量分数的独热向量与碱基嵌入拼接，并线性投影到模型维度。\n\nD. 构建三个独立的 Transformer 编码器，每个模态（参考序列、读段序列、被视为独立标量序列的质量分数）一个，每个编码器都有自己基于其原生索引的绝对位置编码。经过固定数量的层后，对每个模态内的最终隐藏状态在所有位置上取平均，然后拼接三个模态的摘要信息，并用一个多层感知器 (MLP) 进行分类。不使用跨模态注意力或感知比对的偏置；融合仅在最终的分类器处发生。\n\nE. 将参考词元和读段词元用一个分隔符词元拼接起来，并用学习到的片段嵌入来标记模态。根据各自序列中的原生索引分配绝对位置；不要跨模态同步位置。使用正弦位置编码。添加一个注意力掩码，以阻止每个模态内部距离超过固定值的词元之间的注意力。对于质量分数，使用原始 Phred 值 $Q$ 线性投影到嵌入空间，并加到读段和参考词元的嵌入上。让 Transformer 在没有显式偏置项或特殊插入处理的情况下学习比对。",
            "solution": "问题要求为基因组变异检测设计一个有效的 Transformer 架构，该架构必须满足一系列特定要求：联合模态注意力、比对感知、对插入和缺失 (indel) 的显式处理，以及对 Phred 质量分数的概率上合理的使用。该架构必须在词元化和嵌入层面进行详细说明。\n\n我们将根据这些要求评估每个选项。\n\n**对选项 A 的分析：**\n\n1.  **输入表示**：该选项建议将参考序列和读段词元拼接成一个单一序列，用特殊词元（例如 `[SEP]`）分隔，并使用学习到的片段嵌入来区分两种模态。这是一个标准且有效的方法，在像 BERT 这样的模型中被使用，它能让单个 Transformer 编码器对两个序列执行**联合注意力**，从而满足要求 #1。\n\n2.  **位置编码和比对**：它建议根据比对分配绝对位置：位于某个基因组位点的参考词元和比对上的读段词元都被分配相同的、与参考坐标对应的位置索引。这是一种将比对信息直接注入到模型的空间感知中的强大方式，使其能够**感知比对信息**（要求 #2）。添加基于参考坐标差异的相对位置编码进一步丰富了模型对基因组距离的理解。\n\n3.  **Indel 处理**：对于读段中的插入，在参考序列中引入新的空位词元以保持比对，并且为插入的读段词元分配前一个碱基的参考坐标外加一个学习到的分数偏移。这是一个复杂而明确的机制来**处理插入**（要求 #3），允许模型区分同一位点的多个插入碱基。缺失（存在于参考序列但不在读段中的碱基）在这种方案下被自然地处理，因为会存在一个具有给定坐标的参考词元，但没有相应的读段词元。\n\n4.  **质量分数编码**：首先将 Phred 分数 $Q$ 转换为其概率含义，即碱基检出错误概率 $p_{\\mathrm{err}} = 10^{-Q/10}$。然后，计算碱基正确的对数几率 (logit) 为 $\\ell = \\log((1 - p_{\\mathrm{err}})/p_{\\mathrm{err}})$。这个 logit 被线性投影并添加到读段碱基的嵌入中。这是对质量分数的**经过概率校准的**使用方式（要求 #4），因为它将非线性的、对数尺度的 $Q$ 分数转换为 logit 空间表示，这对于使用 softmax 或 sigmoid 激活函数的神经网络层的输入来说是自然域。只将此信息添加到读段词元是正确的。\n\n5.  **注意力偏置**：提出了一个加性偏置矩阵 $b_{ij}$，其中如果词元 $i$ 和 $j$ 根据比对映射 $a$ 形成一个比对上的碱基对，则 $b_{ij}$ 是一个可学习的标量 $\\beta$，否则为 $0$。这显式地鼓励自注意力机制专注于比对上的碱基之间的比较，直接满足了对**感知比对的注意力偏置**的要求（要求 #6）。\n\n6.  **整体架构**：将这些组件整合到一个标准的多层 Transformer 编码器中，并使用一个最终的分类词元进行预测，完成了一个详细说明且连贯一致的设计，满足了所有问题要求（#5、#7、#8、#9）。\n\n**对 A 的结论：** 该选项描述了一个全面、复杂且技术上合理的架构，以有原则的方式满足了所有指定的要求。**正确**。\n\n**对选项 B 的分析：**\n\n1.  **架构**：它提出了一个 Transformer 解码器，与代表整个参考窗口的单个定长向量进行交叉注意力。这是一个编码器-解码器模型，而不是一个联合自注意力模型。将参考序列压缩成单个向量会造成严重的信息瓶颈，丢失所有位置信息和局部序列上下文，而这对于变异检测至关重要。\n2.  **比对**：它明确指出“不使用任何基于比对的位置信息”，这直接违反了要求 #2。\n3.  **Indel 处理**：它依赖于隐式学习，这不是一个指定的机制，并违反了要求 #3。\n4.  **质量分数**：它建议使用质量分数字符串的原始 ASCII 字符并进行归一化。这完全误解了 Phred 分数的性质。Phred 分数是对数概率（$Q = -10 \\log_{10} p_{\\mathrm{err}}$），它们的 ASCII 表示仅仅是一种存储约定。这种方法没有经过概率校准，违反了要求 #4。\n\n**对 B 的结论：** 这个设计存在根本性缺陷，并违反了多个核心要求。**错误**。\n\n**对选项 C 的分析：**\n\n1.  **词元化和比对**：它建议基于“朴素索引相等”创建“每个参考位置的三元组词元”。这忽略了提供的 CIGAR 比对，并且无法处理 indel，因为在 indel 处，一对一的索引关系会中断。这违反了要求 #2 和 #3。\n2.  **注意力**：“掩盖注意力矩阵的对角线”不是一种标准或合乎逻辑的方式来整合比对信息。对角线代表一个词元对自身的注意力，掩盖它是不合理的。这未能正确实现一个感知比对的注意力机制。\n3.  **质量分数**：将质量分数分箱为独热类别是一种会丢弃信息的量化形式。它不像将它们转换为 logit 那样有原则或“经过概率校准”（要求 #4）。\n\n**对 C 的结论：** 这个设计基于关于比对的错误假设，无法处理 indel，并且对质量分数使用了次优的表示。**错误**。\n\n**对选项 D 的分析：**\n\n1.  **架构**：它提出了三个独立的 Transformer 编码器，融合仅在最终的分类层发生。这种“后期融合”方法完全阻止了模型学习参考序列、读段和质量分数之间细粒度的、按位置的交互。它违反了在词元级别进行**联合注意力**的核心要求（要求 #1）。\n2.  **比对**：通过在每个独立序列中使用原生索引，它完全忽略了比对信息，因此违反了要求 #2。\n\n**对 D 的结论：** 该架构未能对问题所要求的关键跨模态交互进行建模，使其不适合该任务。**错误**。\n\n**对选项 E 的分析：**\n\n1.  **位置编码和比对**：它建议对拼接的参考序列和读段序列使用原生索引（“不要跨模态同步位置”）。这意味着参考序列中索引为 $i$ 的碱基和读段中索引为 $i$ 的碱基在位置上被视为等效，这是不正确的，因为它们通常不是对齐的。这违反了**感知比对**的要求（#2）。\n2.  **Indel 处理**：它建议没有显式的 indel 处理机制，违反了要求 #3。\n3.  **质量分数**：它建议使用线性投影的原始 Phred 值 $Q$。这在概率上是不合理的，因为 $Q$ 是对数尺度的。此外，它建议将质量嵌入同时添加到*读段*和*参考*词元上，这是不正确的，因为质量分数只是读段的属性。这未能满足要求 #4。\n\n**对 E 的结论：** 这个设计以一个合理的拼接方法开始，但在位置编码、比对感知和正确使用质量分数等关键方面失败了。**错误**。\n\n总之，只有选项 A 提出了一个内部一致、科学上合理且满足问题陈述中所有要求的设计。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}