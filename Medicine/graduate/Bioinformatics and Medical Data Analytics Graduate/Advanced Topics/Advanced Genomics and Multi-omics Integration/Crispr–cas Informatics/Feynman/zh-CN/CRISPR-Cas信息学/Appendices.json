{
    "hands_on_practices": [
        {
            "introduction": "在设计 guide RNA 时，一个关键步骤是确保其特异性，以避免在基因组的非预期位置产生编辑。本练习将带你应对预测脱靶结合位点的计算挑战，你需要通过搜索基因组中的相似序列来完成这一任务。这项练习旨在培养你的算法思维，并学会如何使用 k-mer 索引等数据结构进行高效的序列分析 。",
            "id": "4551302",
            "problem": "要求您使用有限字母串模型，形式化并实现一种用于成簇规律间隔短回文重复序列 (CRISPR)–CRISPR 相关蛋白 (Cas) 引导选择的算法程序。基因组被建模为脱氧核糖核酸字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 上的一个字符串，而引导（guide）是一个 $k$-mer，即基因组中长度为 $k$ 的子字符串。一个索引可将基因组中的每个 $k$-mer 映射到其在基因组中所有起始位置（从零开始计数）的列表。错配预算 $r$ 指定了如果两个 $k$-mer 的汉明距离至多为 $r$，则它们被认为是相似的。对于此任务，使用 $r = 2$。\n\n使用的基本原理：\n- 根据分子生物学的中心法则，有限字母表上的字符串可用于模拟核苷酸序列，$k$-mer 是长度为 $k$ 的连续子字符串。\n- 两个等长字符串之间的汉明距离是字符不相等位置的数量。\n- 引导的脱靶风险通过以该引导为中心、半径为 $r$ 的汉明球内的基因组 $k$-mer 数量来近似估算。\n- 基于哈希的 $k$-mer 索引提供了期望常数时间的关联查找。\n\n您的程序必须：\n1. 对于每个测试用例，构建给定基因组的 $k$-mer 索引，将每个 $k$-mer 映射到其出现的所有起始位置的列表。\n2. 对于所提供候选集中的每个候选引导，按如下方式计算其脱靶计数：\n   - 枚举与引导汉明距离至多为 $r$ 的所有 $k$-mer 的集合（包括引导本身）。\n   - 为每个这样的 $k$-mer 查询索引，并对检索到的位置列表的长度求和，以计算有多少个基因组 $k$-mer 实例落在距离至多为 $r$ 的范围内。\n   - 当且仅当候选引导在基因组索引中至少有一个完全匹配时，排除一个预期的靶向实例；在这种情况下，从总计数中减去 $1$。如果候选引导没有完全的基因组匹配，则减去 $0$。\n   - 仅使用规范的大写字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$。\n3. 选择使计算出的脱靶计数最小化的引导。如果出现平局，则选择在候选列表中具有最小零基索引的引导。\n4. 对于选定的引导，计算两个复杂度指标：\n   - $M$，通过枚举围绕引导的半径为 $r$ 的汉明球而生成的不同 $k$-mer 查询的数量（即不同邻居的数量，包括引导本身）。\n   - $L$，扫描的索引出现总次数，定义为对 $M$ 个被查询的 $k$-mer 返回的索引列表长度的总和（在减去靶向排除项之前）。这些量化了在给定哈希索引下的期望时间复杂度的具体实例。\n\n您的程序必须处理以下测试套件，其中每个测试用例是一个元组 $(\\texttt{genome}, k, \\texttt{candidates})$：\n- 测试 1：$\\left(\\texttt{\"ACGTTGCATGTCGCATGATGCATGAGAGCT\"},\\ k = 5,\\ \\texttt{[\"GCATG\",\"CATGA\",\"TGCAT\"]}\\right)$。\n- 测试 2：$\\left(\\texttt{\"AAAAA\"},\\ k = 2,\\ \\texttt{[\"AA\",\"AT\"]}\\right)$。\n- 测试 3：$\\left(\\texttt{\"ATATATATAT\"},\\ k = 4,\\ \\texttt{[\"ATAT\",\"TATA\"]}\\right)$。\n- 测试 4：$\\left(\\texttt{\"GCGCGCGC\"},\\ k = 3,\\ \\texttt{[\"AAA\",\"GCG\"]}\\right)$。\n\n对于每个测试用例，为选定的引导输出一个四元素记录，形式为 $[i, c, M, L]$，其中：\n- $i$ 是所选引导在候选列表中的零基索引，\n- $c$ 是按上述规定计算出的所选引导的最小化脱靶计数，\n- $M$ 是与引导汉明距离至多为 $r$ 的不同邻居 $k$-mer 的数量，\n- $L$ 是在这 $M$ 个邻居中扫描到的索引出现总次数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试的结果。结果是一个逗号分隔的列表，每个元素是每个测试用例的记录，无空格，并用方括号括起来。例如，一个有效的格式是 $\\texttt{[[0,12,93,250],[\\dots],[\\dots],[\\dots]]}$，其中每个数字都是整数，并且该行仅包含此方括号列表。\n\n角度单位和物理单位不适用。所有报告的数值输出必须是指定结构中的整数。该算法必须普遍适用于任何现代编程语言，并遵循上述逻辑规范，不得使用问题陈述中的任何捷径或预先推导的公式。",
            "solution": "所提出的问题要求开发一种算法，用于从候选列表中选择 CRISPR-Cas 引导序列。该选择基于最小化计算出的脱靶分数。此问题定义明确，其科学基础是一个简化但标准的生物信息学模型，并且在算法上是可解的。\n\n本解决方案将对模型进行形式化，并详细说明计算和选择的逐步过程。\n\n问题的核心在于使用离散数学对生物系统进行建模。基因组和引导 RNA 被表示为有限字母表 $\\Sigma = \\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 上的字符串。引导是一个 $k$-mer，即长度为 $k$ 的字符串。引导与基因组中非预期位置（脱靶）结合的可能性，是基于序列相似性来量化的，该相似性通过汉明距离 $d_H$ 来衡量。\n\n对于每个测试用例，算法分三个主要阶段进行：\n1.  **基因组索引构建**：我们首先处理基因组字符串，为其所有组成的 $k$-mer 创建一个高效的查找结构。\n2.  **候选引导评估**：然后通过计算每个候选引导的脱靶分数和相关的复杂度指标来对其进行评估。\n3.  **最优引导选择**：根据指定标准选择得分最佳的引导。\n\n### 1. 基因组索引构建\n设基因组是一个长度为 $N$ 的字符串 $S$。一个 $k$-mer 是 $S$ 中任意一个长度为 $k$ 的子字符串。我们构建一个索引，它是一个哈希映射（或字典），表示为 $\\mathcal{I}$。对于基因组中存在的每个唯一的 $k$-mer $s$，$\\mathcal{I}[s]$ 存储了 $s$ 出现的所有从零开始的起始位置 $i$ 的列表，即 $S[i:i+k] = s$。\n\n这通过从 $i=0$ 迭代到 $N-k$ 来完成，在每个位置提取 $k$-mer $s_i = S[i:i+k]$，并将 $i$ 附加到列表 $\\mathcal{I}[s_i]$ 中。使用哈希映射为查找提供了期望为 $\\mathcal{O}(1)$ 的时间复杂度。\n\n### 2. 候选引导评估\n对于所提供列表中的每个候选引导 $g$，我们计算其脱靶分数 $c$ 以及两个复杂度指标 $M$ 和 $L$。错配预算固定为 $r=2$。\n\n#### a. 汉明球枚举\n首先，我们必须识别出所有与引导 $g$ “相似”的 $k$-mer。相似性定义为汉明距离在 $r$ 之内。所有此类 $k$-mer 的集合是以 $g$ 为中心、半径为 $r$ 的汉明球，记为 $B_r(g)$:\n$$B_r(g) = \\{ s \\in \\Sigma^k \\mid d_H(g, s) \\le r \\}$$\n我们生成这个唯一的相邻 $k$-mer 集合。生成 $B_r(g)$ 的一种系统方法是通过递归算法，该算法在字符串 $g$ 的每个位置上探索替换。从一个为 $r$ 的距离预算开始，在从 $0$ 到 $k-1$ 的每个位置上，算法决定是保留原始字符还是用 $\\Sigma$ 中的其他 $3$ 个字符之一进行替换。一次替换会使距离预算减少 $1$。当到达字符串末尾或预算耗尽时，递归终止。\n\n在这个生成的集合中，不同 $k$-mer 的总数即为指标 $M$:\n$$M = |B_r(g)|$$\n对于给定的 $k$ 和 $r$，以及字母表大小 $|\\Sigma|=4$，$M$ 对于任何长度为 $k$ 的引导 $g$ 都是一个常数。其值由一个公式给出，该公式计算了在字母表大小为 $q=4$ 的 $k$-长度字符串空间中汉明球的大小：\n$$M(k, r, q) = \\sum_{i=0}^{r} \\binom{k}{i} (q-1)^i$$\n对于本问题，当 $r=2$ 和 $q=4$ 时，该公式简化为：\n$$M = \\binom{k}{0}3^0 + \\binom{k}{1}3^1 + \\binom{k}{2}3^2 = 1 + 3k + 9\\frac{k(k-1)}{2}$$\n\n#### b. 脱靶分数计算\n脱靶分数是对非预期结合位点数量的估计。它通过对引导的所有邻居的出现次数求和来计算。\n\n首先，我们计算扫描到的索引出现总次数 $L$。我们遍历每个唯一的邻居 $s \\in B_r(g)$ 并查询我们的基因组索引 $\\mathcal{I}$。$s$ 的出现次数是列表 $\\mathcal{I}[s]$ 的长度（如果 $s$ 不在索引中，则为 $0$）。$L$ 是这些计数在所有 $s \\in B_r(g)$ 上的总和：\n$$L = \\sum_{s \\in B_r(g)} |\\mathcal{I}[s]|$$\n这个值 $L$ 代表了潜在结合位点的总数，包括预期的靶向位点。\n\n最终的脱靶分数 $c$ 是通过对 $L$ 应用一个针对预期靶点的校正得出的。问题规定，如果引导 $g$ 本身在基因组中有一个或多个完全匹配，则其中一个被视为“靶向”位点，并应从脱靶计数中排除。\n$$c = \\begin{cases} L - 1  \\text{若 } g \\in \\mathcal{I} \\\\ L  \\text{若 } g \\notin \\mathcal{I} \\end{cases}$$\n条件 $g \\in \\mathcal{I}$ 等同于检查是否 $|\\mathcal{I}[g]| > 0$。\n\n### 3. 最优引导选择\n对于输入列表中的每个候选引导 $g_j$（索引为 $j$），我们计算元组 $(c_j, M_j, L_j)$。选择标准是找到使脱靶分数 $c_j$ 最小化的引导。如果分数出现平局，则选择索引 $j$ 最小的引导。\n\n评估完所有候选引导后，我们确定最优引导 $g_{j^*}$，使得对于所有 $j$ 都有 $c_{j^*} \\le c_j$，并且如果对于某个 $j > j^*$ 有 $c_{j^*} = c_j$，则保持选择 $j^*$。该测试用例的最终输出是所选引导的记录：$[j^*, c_{j^*}, M_{j^*}, L_{j^*}]$。对所有测试用例重复此过程。",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the CRISPR guide selection problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite as per the problem statement.\n    test_cases = [\n        (\"ACGTTGCATGTCGCATGATGCATGAGAGCT\", 5, [\"GCATG\", \"CATGA\", \"TGCAT\"]),\n        (\"AAAAA\", 2, [\"AA\", \"AT\"]),\n        (\"ATATATATAT\", 4, [\"ATAT\", \"TATA\"]),\n        (\"GCGCGCGC\", 3, [\"AAA\", \"GCG\"]),\n    ]\n\n    # Global parameters\n    R_BUDGET = 2\n    ALPHABET = ['A', 'C', 'G', 'T']\n    \n    all_results = []\n\n    def build_kmer_index(genome, k):\n        \"\"\"Constructs a map of k-mers to their starting positions in the genome.\"\"\"\n        index = defaultdict(list)\n        for i in range(len(genome) - k + 1):\n            kmer = genome[i:i + k]\n            index[kmer].append(i)\n        return index\n\n    def generate_hamming_ball_recursive(kmer_list, r, index, results):\n        \"\"\"\n        Recursively generates all unique k-mers within a given Hamming distance r.\n        \n        Args:\n            kmer_list (list): The starting k-mer as a list of characters.\n            r (int): The remaining Hamming distance budget.\n            index (int): The current position in the k-mer to consider.\n            results (set): A set to store the generated unique k-mers.\n        \"\"\"\n        if r < 0:\n            return\n\n        # Base case: if we have processed the entire k-mer length\n        if index == len(kmer_list):\n            results.add(\"\".join(kmer_list))\n            return\n\n        original_char = kmer_list[index]\n        \n        # Branch 1: Do not change the character at the current index.\n        generate_hamming_ball_recursive(kmer_list, r, index + 1, results)\n        \n        # Branch 2: Change the character at the current index.\n        # This consumes one distance unit from the budget.\n        if r > 0:\n            for char in ALPHABET:\n                if char != original_char:\n                    kmer_list[index] = char\n                    generate_hamming_ball_recursive(kmer_list, r - 1, index + 1, results)\n            # Backtrack to the original character for subsequent recursive calls\n            kmer_list[index] = original_char\n\n    for genome, k, candidates in test_cases:\n        kmer_index = build_kmer_index(genome, k)\n        \n        best_guide_info = {\n            'index': -1,\n            'score': float('inf'),\n            'M': 0,\n            'L': 0\n        }\n\n        candidate_evaluations = []\n\n        for j, guide in enumerate(candidates):\n            # 1. Enumerate the set of all k-mers within the Hamming ball.\n            neighbors = set()\n            generate_hamming_ball_recursive(list(guide), R_BUDGET, 0, neighbors)\n            \n            # 2. Calculate M, the number of distinct neighbor k-mers.\n            M = len(neighbors)\n            \n            # 3. Calculate L, the total number of indexed occurrences scanned.\n            L = 0\n            for neighbor in neighbors:\n                if neighbor in kmer_index:\n                    L += len(kmer_index[neighbor])\n            \n            # 4. Calculate the off-target score c.\n            on_target_count = len(kmer_index.get(guide, []))\n            c = L - 1 if on_target_count > 0 else L\n            \n            candidate_evaluations.append({'score': c, 'index': j, 'M': M, 'L': L})\n\n        # 5. Select the best guide.\n        # Sort by score (ascending), then by index (ascending) as a tie-breaker.\n        best_guide = sorted(candidate_evaluations, key=lambda x: (x['score'], x['index']))[0]\n        \n        result_record = [best_guide['index'], best_guide['score'], best_guide['M'], best_guide['L']]\n        all_results.append(result_record)\n\n    # Format the final output string exactly as specified.\n    string_results = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output = f\"[{','.join(string_results)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的序列匹配，Cas9-sgRNA 复合物与 DNA 的结合稳定性还受到生物物理原理的支配。本练习将探索一个热力学模型，用于量化错配（尤其是在关键的“种子”区域）如何影响结合能和位点占据率。通过这个练习，你将对分子识别过程背后的物理机制建立起更深刻的直观理解 。",
            "id": "4551374",
            "problem": "长度为 $20$ 的单向导RNA (sgRNA) 被Clustered Regularly Interspaced Short Palindromic Repeats–CRISPR associated protein $9$ (CRISPR–Cas$9$) 用于探查一个基因组靶标。位置的索引方式为：位置 $1$ 是紧邻原型间隔子邻近基序 (Protospacer Adjacent Motif, PAM) 的核苷酸，种子区域定义为位置 $1$ 到 $10$。考虑同一靶标相对于sgRNA的两种单错配情景：情况 $\\mathrm{A}$ 在位置 $5$（种子区域内）有一个单错配，情况 $\\mathrm{B}$ 在位置 $15$（种子区域外）有一个单错配。\n\n将靶标的种子匹配分数 $S$ 定义为种子区域（位置 $1$ 到 $10$）内匹配位置的数量。假设以下基于物理原理、热力学上一致的结合自由能和占据率模型：\n- 完全匹配的约化自由能（在温度 $T$ 下，以 $k_{B}T$ 为单位）为 $g_{0} = \\Delta G_{0}/(k_{B}T) = -40$。\n- 种子区域内的每个错配贡献一个加性的约化罚分 $\\delta_{s} = 6$，种子区域外的每个错配贡献一个加性的约化罚分 $\\delta_{d} = 2$。\n- 在巨正则系综中，活化的 Cas$9$–sgRNA 的约化化学势为 $\\tilde{\\mu} = \\mu/(k_{B}T) = -38$。\n\n仅使用统计热力学和分子识别的基本定律及核心定义来：\n- 计算情况 $\\mathrm{A}$ 和情况 $\\mathrm{B}$ 的种子匹配分数 $S$。\n- 从第一性原理推导预测的位点占据概率 $p$ 作为约化自由能和约化化学势的函数，然后评估当错配从种子区域（情况 $\\mathrm{A}$）移动到远端区域（情况 $\\mathrm{B}$）时，预测结合概率的倍数变化 $R$，即 $R = p_{\\mathrm{B}}/p_{\\mathrm{A}}$。\n\n只报告 $R$ 的数值，作为一个无量纲数，四舍五入到四位有效数字。最终报告的值中不要包含任何单位。",
            "solution": "该问题经验证具有科学依据、提法恰当、客观且完整。所有必要的数据和定义都已提供，可用于基于统计热力学的基本原理推导出唯一且有意义的解。因此，我们可以着手求解。\n\n问题要求进行两项主要计算：两种情景下的种子匹配分数，以及它们之间结合概率的倍数变化。我们将按顺序处理这些问题。\n\n首先，我们确定每种情况下的种子匹配分数 $S$。sgRNA 的长度为 $20$ 个核苷酸。种子区域定义为位置 $1$ 到 $10$。分数 $S$ 是这个 $10$ 个核苷酸的种子区域内匹配的碱基对数量。\n\n对于情况 $\\mathrm{A}$，在位置 $5$ 有一个单错配。由于位置 $5$ 在种子区域内（位置 $1$ 到 $10$），这个错配使种子区域中的匹配数减少一。因此，情况 $\\mathrm{A}$ 的种子匹配分数为：\n$$S_{\\mathrm{A}} = 10 - 1 = 9$$\n\n对于情况 $\\mathrm{B}$，在位置 $15$ 有一个单错配。由于位置 $15$ 在种子区域外（它在远端区域，即位置 $11$ 到 $20$），种子区域内的所有位置都是完全匹配的。因此，情况 $\\mathrm{B}$ 的种子匹配分数为：\n$$S_{\\mathrm{B}} = 10 - 0 = 10$$\n\n接下来，我们计算每种情况下的约化结合自由能。约化自由能 $g$ 的模型由 $g = g_{0} + n_{s}\\delta_{s} + n_{d}\\delta_{d}$ 给出，其中 $g_{0}$ 是完全匹配的约化自由能，$n_{s}$ 是种子区域的错配数量，$\\delta_{s}$ 是种子区域错配罚分，$n_{d}$ 是种子区域外的错配数量，$\\delta_{d}$ 是远端区域错配罚分。\n\n给定参数如下：\n- 完全匹配的约化自由能: $g_{0} = -40$\n- 种子区域错配罚分: $\\delta_{s} = 6$\n- 远端区域错配罚分: $\\delta_{d} = 2$\n\n对于情况 $\\mathrm{A}$（错配在位置 $5$），我们有一个种子区域错配和零个远端区域错配。因此，$n_{s} = 1$ 且 $n_{d} = 0$。约化自由能 $g_{\\mathrm{A}}$ 为：\n$$g_{\\mathrm{A}} = g_{0} + (1)\\delta_{s} + (0)\\delta_{d} = -40 + 6 = -34$$\n\n对于情况 $\\mathrm{B}$（错配在位置 $15$），我们有零个种子区域错配和一个远端区域错配。因此，$n_{s} = 0$ 且 $n_{d} = 1$。约化自由能 $g_{\\mathrm{B}}$ 为：\n$$g_{\\mathrm{B}} = g_{0} + (0)\\delta_{s} + (1)\\delta_{d} = -40 + 2 = -38$$\n\n现在，我们必须从统计热力学的第一性原理推导出位点占据概率 $p$。我们考虑巨正则系综中的一个基因组靶位点，它可以与一个大热库交换能量和粒子（Cas$9$–sgRNA 复合物）。该热库的特征是恒定的温度 $T$ 和化学势 $\\mu$。\n\n该靶位点可以存在于两种状态：\n$1$. 未结合态：位点为空。结合能取为参考值，$E_{unbound} = 0$。结合的粒子数为 $N_{unbound} = 0$。\n$2$. 结合态：位点被一个 Cas$9$–sgRNA 复合物占据。结合能为 $E_{bound} = \\Delta G$。结合的粒子数为 $N_{bound} = 1$。\n\n系统处于特定状态 $i$ 的概率由吉布斯分布给出：\n$$P_{i} = \\frac{1}{\\mathcal{Z}} \\exp\\left(-\\frac{E_{i} - \\mu N_{i}}{k_{B}T}\\right)$$\n其中 $\\mathcal{Z}$ 是巨配分函数，是所有可能状态的统计因子的总和。用约化自由能 $g = \\Delta G / (k_{B}T)$ 和约化化学势 $\\tilde{\\mu} = \\mu / (k_{B}T)$ 表示，概率为：\n$$P_{i} = \\frac{1}{\\mathcal{Z}} \\exp(-(g_{i} - \\tilde{\\mu} N_{i}))$$\n\n巨配分函数 $\\mathcal{Z}$ 是对未结合态和结合态求和：\n$$\\mathcal{Z} = \\sum_{i \\in \\{\\text{unbound, bound}\\}} \\exp(-(g_{i} - \\tilde{\\mu} N_{i}))$$\n对于未结合态：$\\exp(-(0 - \\tilde{\\mu} \\cdot 0)) = \\exp(0) = 1$。\n对于结合态：$\\exp(-(g - \\tilde{\\mu} \\cdot 1)) = \\exp(-(g - \\tilde{\\mu}))$。\n因此，配分函数为：\n$$\\mathcal{Z} = 1 + \\exp(-(g - \\tilde{\\mu}))$$\n\n位点占据概率 $p$ 是位点处于结合态的概率：\n$$p = P_{\\text{bound}} = \\frac{\\exp(-(g - \\tilde{\\mu}))}{\\mathcal{Z}} = \\frac{\\exp(-(g - \\tilde{\\mu}))}{1 + \\exp(-(g - \\tilde{\\mu}))}$$\n这个表达式可以重新整理成费米-狄拉克分布的形式：\n$$p = \\frac{1}{\\exp(g - \\tilde{\\mu}) + 1}$$\n这就是所求的位点占据概率的第一性原理表达式。\n\n最后，我们使用这个公式计算概率 $p_{\\mathrm{A}}$ 和 $p_{\\mathrm{B}}$ 以及它们的比率 $R = p_{\\mathrm{B}}/p_{\\mathrm{A}}$。给定的约化化学势为 $\\tilde{\\mu} = -38$。\n\n对于情况 $\\mathrm{A}$，其中 $g_{\\mathrm{A}} = -34$：\n$$p_{\\mathrm{A}} = \\frac{1}{\\exp(g_{\\mathrm{A}} - \\tilde{\\mu}) + 1} = \\frac{1}{\\exp(-34 - (-38)) + 1} = \\frac{1}{\\exp(4) + 1}$$\n\n对于情况 $\\mathrm{B}$，其中 $g_{\\mathrm{B}} = -38$：\n$$p_{\\mathrm{B}} = \\frac{1}{\\exp(g_{\\mathrm{B}} - \\tilde{\\mu}) + 1} = \\frac{1}{\\exp(-38 - (-38)) + 1} = \\frac{1}{\\exp(0) + 1} = \\frac{1}{1 + 1} = \\frac{1}{2}$$\n\n倍数变化 $R$ 是这些概率的比率：\n$$R = \\frac{p_{\\mathrm{B}}}{p_{\\mathrm{A}}} = \\frac{\\frac{1}{2}}{\\frac{1}{\\exp(4) + 1}} = \\frac{\\exp(4) + 1}{2}$$\n\n现在我们计算数值并四舍五入到四位有效数字。\n$$R = \\frac{\\exp(4) + 1}{2} \\approx \\frac{54.59815 + 1}{2} = \\frac{55.59815}{2} \\approx 27.799075$$\n四舍五入到四位有效数字得到 $27.80$。\n这个结果表明，将一个单错配从种子区域移动到远端区域，可以使结合概率增加约 $28$ 倍，这凸显了种子区域对于 CRISPR-Cas$9$ 靶标识别的关键重要性。",
            "answer": "$$\\boxed{27.80}$$"
        },
        {
            "introduction": "大规模 CRISPR 筛选会产生海量数据，其中单个 guide RNA 的结果可能包含噪声或异常值。本练习将演示如何使用稳健的统计方法，将 guide RNA 层面的数据整合为可靠的基因层面评分。你将亲手实践这些对解读功能基因组学实验至关重要的技术 。",
            "id": "4551371",
            "problem": "您正在分析混合的成簇规律间隔短回文重复序列（CRISPR）-CRISPR相关蛋白（Cas）敲除筛选，其中每个基因都由多个单向导RNA（sgRNA）靶向，从而产生向导级别的测量值，例如对数倍数变化。目标是使用对离群向导具有弹性的稳健统计方法，将向导级别的效应聚合为基因级别的评分。您必须实现两种聚合方法，并在指定的测试套件上计算它们的输出。\n\n基本和建模假设：\n- 在混合CRISPR筛选中，向导级别的耗尽或富集通常被总结为对数倍数变化，其中更负的值表示更强的耗尽。这是基因组学实验中经过充分检验的总结指标。\n- 在无基因效应的零模型下，sgRNA在所有$N$个向导中的排名被建模为无放回均匀随机抽样的位置，这等同于超几何抽样方案。这是功能基因组学中稳健秩聚合广泛接受的零模型。\n\n定义和所需计算：\n1. 稳健的截尾均值聚合器。\n   - 给定一个基因的$m$个向导级别效应，表示为实值对数倍数变化$\\{e_1, e_2, \\dots, e_m\\}$，以及一个对称的截尾比例$\\tau \\in [0,1/2)$，定义$k = \\lfloor \\tau m \\rfloor$。\n   - 将效应按升序排序，丢弃$k$个最小值和$k$个最大值，并计算剩余$m - 2k$个值的算术平均值。如果$k = 0$，则不丢弃任何值，并在所有$m$个值上计算平均值。\n   - 在本问题的所有计算中，使用$\\tau = 0.2$。\n\n2. 最小超几何（mHG）稳健秩聚合。\n   - 设一个基因有$m$个向导，在总共$N$个向导中的排名为$\\{r_1, r_2, \\dots, r_m\\}$，其中排名$1$是耗尽最强的，排名$N$是最弱的。对于任何阈值$T \\in \\{1, 2, \\dots, N\\}$，定义$x(T)$为该基因排名$\\leq T$的向导数量。\n   - 在无放回随机排名的零模型下，$X(T) \\sim \\mathrm{Hypergeometric}(N, m, T)$给出了当一个大小为$N$的总体中有$m$个成功事件时，在$T$次抽取中成功的次数。观察到至少$x(T)$次成功的单侧尾概率为$\\mathbb{P}(X(T) \\ge x(T))$。\n   - 将基因级别的mHG统计量定义为$\\min_{T \\in \\mathcal{T}} \\mathbb{P}(X(T) \\ge x(T))$，其中$\\mathcal{T}$是等于该基因观测到的排名的阈值集合，即$\\mathcal{T} = \\{r_1, r_2, \\dots, r_m\\}$。\n\n测试套件：\n- 所有案例均使用总文库大小$N = 20000$个向导。\n- 对于每个案例，基因都有一系列向导级别效应（对数倍数变化）和相应的整数排名。程序必须使用$\\tau = 0.2$计算截尾均值，并使用上述定义计算mHG p值。\n\n案例：\n- 案例A（一致性耗尽，无离群值）：\n  - 效应：$\\{-1.2, -0.9, -1.1, -0.8, -0.7, -1.0\\}$。\n  - 排名：$\\{50, 80, 60, 90, 100, 70\\}$。\n\n- 案例B（与案例A相同，但增加一个强正向离群值）：\n  - 效应：$\\{-1.2, -0.9, -1.1, -0.8, -0.7, -1.0, 3.0\\}$。\n  - 排名：$\\{50, 80, 60, 90, 100, 70, 19000\\}$。\n\n- 案例C（近中性向导中存在一个极端负向离群值）：\n  - 效应：$\\{-0.1, 0.0, 0.1, -5.0, -0.2\\}$。\n  - 排名：$\\{9000, 10000, 11000, 5, 9500\\}$。\n\n- 案例D（所有向导均为近中性）：\n  - 效应：$\\{0.0, 0.0, 0.0, 0.0\\}$。\n  - 排名：$\\{10000, 10500, 10200, 9800\\}$。\n\n答案规范：\n- 对于每个案例，计算两个输出：截尾均值（一个实值浮点数）和mHG p值（一个实值浮点数）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：案例A截尾均值、案例B截尾均值、案例C截尾均值、案例D截尾均值、案例A mHG p值、案例B mHG p值、案例C mHG p值、案例D mHG p值。\n- 将所有结果表示为小数点后保留六位的小数浮点数。输出不得包含空格。例如：$\\texttt{[x_1,x_2,x_3,x_4,y_1,y_2,y_3,y_4]}$，其中每个$x_i$是截尾均值，每个$y_i$是mHG p值。\n\n科学真实性和合理性要求：\n- 您必须根据提供的基本定义来设计实现，并确保根据超几何模型的数值稳定性和正确性。\n- 所选案例包括一个普遍的一致性耗尽场景、一个带有强正向离群值的案例、一个带有强负向离群值的案例以及一个中性案例，从而测试对离群值和边界条件的稳健性。\n\n不需要外部输入。程序必须完全自包含，并可在现代环境中执行。",
            "solution": "用户提供了一个以混合CRISPR敲除筛选数据分析为中心的生物信息学问题。任务是实现并应用两种不同的统计方法，将向导级别的测量值聚合为单一的基因级别评分：稳健的截尾均值和最小超几何（mHG）检验。该问题具有科学依据，定义明确，并为一组测试案例提供了所有必要的参数和数据。因此，该问题被认为是有效的，可以构建解决方案。\n\n解决方案将分两部分介绍，每部分详细说明一种所需聚合方法的原理和实现逻辑。\n\n### 1. 稳健的截尾均值聚合\n\n**原理**：算术平均值虽然是一种常用的集中趋势度量，但对离群值高度敏感。在CRISPR筛选中，单个单向导RNA（sgRNA）可能具有脱靶效应或功能失效，产生不能反映靶基因敲除真实效应的伪对数倍数变化（LFC）值。截尾均值是一种稳健的统计度量，可以减轻此类离群值的影响。它的计算方法是在计算剩余值的平均值之前，从数据集的最小值和最大值中舍弃一定百分比的数据。\n\n**形式化与实现**：\n给定单个基因的$m$个向导级别效应集合$\\{e_1, e_2, \\dots, e_m\\}$，以及一个对称的截尾比例$\\tau \\in [0, 1/2)$，从排序后分布的每一端移除的观测数量为$k = \\lfloor \\tau m \\rfloor$。首先将效应集合按升序排序：$e_{(1)} \\le e_{(2)} \\le \\dots \\le e_{(m)}$。然后丢弃$k$个最小值$\\{e_{(1)}, \\dots, e_{(k)}\\}$和$k$个最大值$\\{e_{(m-k+1)}, \\dots, e_{(m)}\\}$。截尾均值是剩余$m - 2k$个值的算术平均值：\n$$ \\text{截尾均值} = \\frac{1}{m - 2k} \\sum_{i=k+1}^{m-k} e_{(i)} $$\n对于本问题，截尾比例固定为$\\tau=0.2$。\n\n我们来分析**案例B**：\n- 效应：$\\{-1.2, -0.9, -1.1, -0.8, -0.7, -1.0, 3.0\\}$。这里，$m=7$。\n- 值$3.0$是一个强的正向离群值，与其它六个耗尽信号不一致。\n- 从两端截去的向导数量为$k = \\lfloor 0.2 \\times 7 \\rfloor = \\lfloor 1.4 \\rfloor = 1$。\n- 效应排序后为：$e_{()} = \\{-1.2, -1.1, -1.0, -0.9, -0.8, -0.7, 3.0\\}$。\n- 我们丢弃单个最小值（$-1.2$）和单个最大值（$3.0$）。离群值被成功移除。\n- 在剩余集合$\\{-1.1, -1.0, -0.9, -0.8, -0.7\\}$上计算截尾均值。\n- 截尾均值 = $\\frac{-1.1 - 1.0 - 0.9 - 0.8 - 0.7}{5} = \\frac{-4.5}{5} = -0.9$。该结果准确地反映了非离群向导的一致耗尽效应。\n\n### 2. 最小超几何（mHG）稳健秩聚合\n\n**原理**：mHG检验是一种基于秩的方法，用于确定一个项目集合（此处为基因的sgRNA）是否在更大的排名列表（筛选中的所有sgRNA）的顶部显著富集。零假设（$H_0$）是该基因的$m$个向导的排名是从所有可能的排名集合$\\{1, 2, \\dots, N\\}$中无放回随机抽取的样本。该检验量化了观察到基因的向导在列表顶部累积的统计显著性。其稳健性源于其非参数性质（仅使用排名，不使用效应大小）及其检测由部分向导驱动的显著性的能力，这在基因的只有部分向导有效时很常见。\n\n**形式化与实现**：\n设一个基因有$m$个向导，其在总共$N$个向导中的排名为$\\{r_1, r_2, \\dots, r_m\\}$。检验流程如下：\n1. 对于给定的排名阈值$T$，我们计算该基因有多少个向导的排名小于或等于$T$，记为$x(T)$。\n2. 在$H_0$下，在完整列表的前$T$个排名中找到的该基因的向导数量遵循超几何分布。从一个包含$m$个成功事件的大小为$N$的总体中进行$T$次抽取，观察到至少$x(T)$次成功（即该基因的向导）的概率由超几何分布的生存函数给出：\n$$ \\mathbb{P}(X(T) \\ge x(T)) = \\sum_{i=x(T)}^{\\min(m, T)} \\frac{\\binom{m}{i}\\binom{N-m}{T-i}}{\\binom{N}{T}} $$\n   其中$X(T) \\sim \\mathrm{Hypergeometric}(\\text{总体大小}=N, \\text{总体中成功数}=m, \\text{抽取次数}=T)$。\n3. mHG统计量定义为在特定阈值集合（即该基因自身向导的观测排名）上这些p值的最小值，$\\mathcal{T} = \\{r_1, r_2, \\dots, r_m\\}$。\n$$ \\text{mHG p值} = \\min_{T \\in \\mathcal{T}} \\mathbb{P}(X(T) \\ge x(T)) $$\n这种形式化方法可以有效地找到一个排名阈值，在该阈值下，该基因向导的富集最不可能是偶然发生的。计算使用`scipy.stats.hypergeom`中的生存函数（`sf`），其中$\\mathbb{P}(X \\ge x)$计算为`hypergeom.sf(x-1, M, n, K)`。\n\n我们来分析**案例C**：\n- 排名：$\\{9000, 10000, 11000, 5, 9500\\}$。这里，$m=5$，且$N=20000$。\n- 排名$5$是一个极端离群值，表明一个向导具有非常强的耗尽效应，而其他向导则近乎中性。\n- 阈值集合是排序后的排名集合，$\\mathcal{T} = \\{5, 9000, 9500, 10000, 11000\\}$。\n- 在$T=5$处测试：排名$\\le 5$的向导数量为$x(5)=1$。我们计算在前$5$个排名中观察到至少一个向导的p值：\n$$ p_1 = \\mathbb{P}(X(5) \\ge 1) \\quad \\text{其中 } X(5) \\sim \\mathrm{Hypergeometric}(N=20000, m=5, T=5) $$\n这个概率极小，因为仅凭偶然机会，在该基因的$5$个向导中有一个进入前$5$名的可能性极低。\n- 在$T=9000$处测试：排名$\\le 9000$的向导数量为$x(9000)=2$。我们计算：\n$$ p_2 = \\mathbb{P}(X(9000) \\ge 2) \\quad \\text{其中 } X(9000) \\sim \\mathrm{Hypergeometric}(N=20000, m=5, T=9000) $$\n这个p值会很大，因为在前$9000$个排名中找到$5$个向导中的$2$个并不奇怪。\n- 最终的mHG p值将是为五个阈值中每个阈值计算出的p值的最小值。由于排名$5$的极端性，最小p值将是$p_1$，从而得到一个高度显著的基因级别评分，正确地识别了由单个向导介导的强效应。\n\n提供的Python代码将实现这两种方法，并按规定应用于所有四个测试案例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import hypergeom\n\ndef solve():\n    \"\"\"\n    Solves the CRISPR screen analysis problem by calculating trimmed means\n    and minimum hypergeometric (mHG) p-values for a suite of test cases.\n    \"\"\"\n\n    def calculate_trimmed_mean(effects, tau):\n        \"\"\"\n        Computes the trimmed mean for a list of guide effects.\n        \n        Args:\n            effects (list or np.ndarray): Guide-level log fold changes.\n            tau (float): The symmetric trimming proportion.\n\n        Returns:\n            float: The calculated trimmed mean.\n        \"\"\"\n        m = len(effects)\n        if m == 0:\n            return 0.0\n        \n        # Calculate number of items to trim from each end\n        k = int(tau * m)\n        \n        sorted_effects = np.sort(effects)\n        \n        # The condition tau  0.5 ensures the list of trimmed_effects is never empty.\n        if k  0:\n            trimmed_effects = sorted_effects[k:-k]\n        else:\n            trimmed_effects = sorted_effects\n            \n        return np.mean(trimmed_effects)\n\n    def calculate_mhg(ranks, N):\n        \"\"\"\n        Computes the minimum hypergeometric (mHG) p-value.\n        \n        Args:\n            ranks (list or np.ndarray): Ranks of guides for a gene.\n            N (int): Total number of guides in the library.\n\n        Returns:\n            float: The mHG p-value.\n        \"\"\"\n        m = len(ranks)\n        if m == 0:\n            return 1.0\n            \n        sorted_ranks = np.sort(ranks)\n        \n        min_p_value = 1.0\n        \n        # Iterate through the gene's own ranks as thresholds\n        for i, T in enumerate(sorted_ranks):\n            # x is the number of gene's guides with rank = T\n            # Since ranks are sorted, this is simply the 1-based index\n            x = i + 1\n            \n            # Calculate the one-sided hypergeometric p-value P(X >= x).\n            # scipy.stats.hypergeom.sf(k, M, n, K) computes P(X > k).\n            # P(X >= x) is equivalent to P(X > x-1), which is sf(x-1, M, n, K).\n            # Parameters for hypergeom(M, n, K):\n            # M = N (population size)\n            # n = m (successes in population, i.e., guides for this gene)\n            # K = T (number of draws, i.e., rank threshold)\n            p_val = hypergeom.sf(x - 1, N, m, T)\n            \n            if p_val  min_p_value:\n                min_p_value = p_val\n                \n        return min_p_value\n\n    # Define constants from the problem statement\n    N = 20000\n    TAU = 0.2\n\n    # Define the test cases from the problem statement\n    test_cases = {\n        'A': {\n            'effects': [-1.2, -0.9, -1.1, -0.8, -0.7, -1.0],\n            'ranks': [50, 80, 60, 90, 100, 70],\n        },\n        'B': {\n            'effects': [-1.2, -0.9, -1.1, -0.8, -0.7, -1.0, 3.0],\n            'ranks': [50, 80, 60, 90, 100, 70, 19000],\n        },\n        'C': {\n            'effects': [-0.1, 0.0, 0.1, -5.0, -0.2],\n            'ranks': [9000, 10000, 11000, 5, 9500],\n        },\n        'D': {\n            'effects': [0.0, 0.0, 0.0, 0.0],\n            'ranks': [10000, 10500, 10200, 9800],\n        }\n    }\n    \n    trimmed_means = []\n    mhg_p_values = []\n    case_order = ['A', 'B', 'C', 'D']\n    \n    for case_id in case_order:\n        data = test_cases[case_id]\n        \n        # Calculate trimmed mean\n        mean_val = calculate_trimmed_mean(data['effects'], TAU)\n        trimmed_means.append(mean_val)\n        \n        # Calculate mHG p-value\n        mhg_val = calculate_mhg(data['ranks'], N)\n        mhg_p_values.append(mhg_val)\n\n    # Combine results in the specified order\n    final_results = trimmed_means + mhg_p_values\n    \n    # Format results to six decimal places for the final output string\n    result_strings = [f\"{val:.6f}\" for val in final_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```"
        }
    ]
}