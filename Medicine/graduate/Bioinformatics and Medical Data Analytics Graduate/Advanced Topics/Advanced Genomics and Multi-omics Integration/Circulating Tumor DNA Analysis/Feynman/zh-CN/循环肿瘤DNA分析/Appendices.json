{
    "hands_on_practices": [
        {
            "introduction": "本练习探讨了ctDNA测序中基本的统计权衡。它演示了如何确定可靠检测低频变异所需的最小测序深度，从而在假阳性风险与高检测效能的需求之间取得平衡。这是设计任何灵敏的ctDNA检测分析时至关重要的第一步。",
            "id": "4546218",
            "problem": "在一项用于检测循环肿瘤脱氧核糖核酸 (ctDNA) 的靶向深度测序分析中，通过计算支持某个单核苷酸变异的读数数量来评估该变异。假设读数结果是独立的，并且单碱基错配概率是恒定的。在没有真实变异的情况下，一个读数支持该变异的唯一原因是测序错误，其概率为 $e$。当游离脱氧核糖核酸 (DNA) 中存在一个真实变异，其等位基因频率为 $p$ 时，一个读数支持该变异的概率反映了两个方面的贡献：从突变分子中正确观察到该变异，以及从野生型分子中错误地观察到该变异。将存在变异时每个读数支持该变异的概率建模为 $\\theta_{1} = p(1 - e) + (1 - p)e$，不存在变异时建模为 $\\theta_{0} = e$。令 $X$ 表示在 $n$ 次独立试验中支持变异的读数数量，因此 $X \\sim \\operatorname{Bin}(n, \\theta)$，其中 $\\theta \\in \\{\\theta_{0}, \\theta_{1}\\}$ 取决于变异是否存在。\n\n考虑一个单边假设检验，如果 $X \\geq k_{\\alpha}$，则判定变异存在。其中阈值 $k_{\\alpha}$ 的选择要使在没有变异的情况下假阳性概率最多为 $\\alpha$。使用大样本 $n$ 下二项分布的正态近似，确定在显著性水平 $\\alpha = 0.01$ 时，为检测等位基因频率 $p = 0.001$ 的变异达到统计功效 $0.9$ 所需的最小覆盖深度 $n$，已知单碱基错误率 $e = 1 \\times 10^{-3}$。假设背景错误模型和独立性如上所述，并使用不带连续性校正的单边检验。报告满足这些约束的最小整数 $n$。最终答案无需单位。",
            "solution": "用户要求我解决一个关于确定检测 ctDNA 变异所需测序深度的问题。\n\n这是我的计划：\n1.  **验证问题陈述**：\n    *   提取所有给定信息。\n    *   检查科学合理性、一致性和完整性。\n    *   该问题似乎定义明确，并基于生物信息学中用于 NGS 数据分析的标准统计方法。\n\n2.  **步骤1：提取已知条件**\n    *   单碱基错配概率（错误率）：$e = 1 \\times 10^{-3}$\n    *   变异等位基因频率：$p = 0.001$\n    *   显著性水平（I 型错误率）：$\\alpha = 0.01$\n    *   统计功效（1 - II 型错误率）：$1 - \\beta = 0.9$\n    *   存在变异时的模型：$X_1 \\sim \\operatorname{Bin}(n, \\theta_1)$，其中 $\\theta_1 = p(1 - e) + (1 - p)e$\n    *   不存在变异时的模型（原假设）：$X_0 \\sim \\operatorname{Bin}(n, \\theta_0)$，其中 $\\theta_0 = e$\n    *   假设检验：如果 $X \\geq k_{\\alpha}$，则判定变异存在。\n    *   $k_{\\alpha}$ 的选择使 $P(X \\geq k_{\\alpha} | \\text{变异不存在}) \\leq \\alpha$。\n    *   近似方法：使用二项分布的正态近似。\n    *   校正：不使用连续性校正。\n    *   目标：找到最小整数覆盖深度 $n$。\n\n3.  **步骤2：使用提取的已知条件进行验证**\n    *   **科学依据**：是的。用于测序读数计数的模型是一个标准的二项模型。观察到变异读数的概率 $\\theta_1$ 正确地解释了来自突变等位基因的读数 ($p(1-e)$) 和来自被错误识别的野生型等位基因的读数 ($ (1-p)e $)。这是 ctDNA 分析中一个成熟的模型。假设检验、功效和显著性水平的使用也是标准的。\n    *   **适定性**：是的。问题要求基于一组明确定义的约束（$\\alpha$、功效、$p$、$e$）求解一个特定值（$n$）。所有必要信息都已提供。预计会有一个唯一解。\n    *   **客观性**：是的。语言精确且量化，没有使用主观术语。\n    *   **缺陷检查**：\n        1.  **科学上不合理**：否。模型和方法在生物信息学中是标准的。\n        2.  **无法形式化**：否。问题已经被数学形式化。它直接关系到 ctDNA 分析。\n        3.  **不完整/矛盾**：否。所有必要的参数都已给出。\n        4.  **不切实际/不可行**：否。$p$、$e$、$\\alpha$ 和功效的值对于 ctDNA 应用是典型的。\n        5.  **不适定**：否。该结构是假设检验的标准样本量计算。\n        6.  **伪深刻/琐碎**：否。这是一个不平凡的计算，涉及建立并求解从功效和显著性约束导出的两个联立不等式。\n        7.  **超出科学可验证性范围**：否。结果可以通过直接计算来验证。\n\n4.  **步骤3：结论与行动**\n    *   问题是**有效的**。我将继续进行求解。\n\n5.  **构建解决方案**\n\n    *   **定义假设**：\n        *   原假设 ($H_0$)：变异不存在。支持变异的读数数量 $X$ 服从二项分布 $X \\sim \\operatorname{Bin}(n, \\theta_0)$。\n        *   备择假设 ($H_1$)：变异存在。支持变异的读数数量 $X$ 服从二项分布 $X \\sim \\operatorname{Bin}(n, \\theta_1)$。\n\n    *   **计算概率 $\\theta_0$ 和 $\\theta_1$**：\n        *   $\\theta_0 = e = 1 \\times 10^{-3} = 0.001$。\n        *   $\\theta_1 = p(1 - e) + (1 - p)e = p - pe + e - pe = p + e - 2pe$。\n        *   给定 $p = 0.001$ 和 $e = 0.001$：\n        *   $\\theta_1 = 0.001 + 0.001 - 2(0.001)(0.001) = 0.002 - 2 \\times 10^{-6} = 0.001998$。\n\n    *   **应用正态近似**：\n        *   对于大样本 $n$，如果 $X \\sim \\operatorname{Bin}(n, \\theta)$，那么 $X$ 近似服从正态分布：$X \\approx N(n\\theta, n\\theta(1-\\theta))$。\n        *   在 $H_0$ 下：$X_0 \\approx N(\\mu_0, \\sigma_0^2)$，其中 $\\mu_0 = n\\theta_0$ 且 $\\sigma_0^2 = n\\theta_0(1-\\theta_0)$。\n        *   在 $H_1$ 下：$X_1 \\approx N(\\mu_1, \\sigma_1^2)$，其中 $\\mu_1 = n\\theta_1$ 且 $\\sigma_1^2 = n\\theta_1(1-\\theta_1)$。\n\n    *   **建立显著性水平约束**：\n        *   假阳性概率（I 型错误）必须最多为 $\\alpha$。\n        *   $P(X \\geq k_{\\alpha} | H_0) \\leq \\alpha$。\n        *   对 $X_0$ 使用正态近似：$P\\left(\\frac{X_0 - \\mu_0}{\\sigma_0} \\geq \\frac{k_{\\alpha} - \\mu_0}{\\sigma_0}\\right) \\leq \\alpha$。\n        *   令 $Z \\sim N(0, 1)$ 为标准正态随机变量。\n        *   $P\\left(Z \\geq \\frac{k_{\\alpha} - n\\theta_0}{\\sqrt{n\\theta_0(1-\\theta_0)}}\\right) \\leq \\alpha$。\n        *   令 $z_{\\alpha}$ 为标准正态分布的上 $\\alpha$-分位数，即 $P(Z \\geq z_{\\alpha}) = \\alpha$。\n        *   为使不等式成立，我们需要 $\\frac{k_{\\alpha} - n\\theta_0}{\\sqrt{n\\theta_0(1-\\theta_0)}} \\geq z_{\\alpha}$。\n        *   我们将阈值设在临界区的边界上：$\\frac{k_{\\alpha} - n\\theta_0}{\\sqrt{n\\theta_0(1-\\theta_0)}} = z_{\\alpha}$。\n        *   这给了我们临界值 $k_{\\alpha}$ 的表达式：\n            $k_{\\alpha} = n\\theta_0 + z_{\\alpha}\\sqrt{n\\theta_0(1-\\theta_0)}$。（公式1）\n\n    *   **建立统计功效约束**：\n        *   统计功效是在 $H_1$ 为真时正确拒绝 $H_0$ 的概率。功效 = $1 - \\beta$。\n        *   $P(X \\geq k_{\\alpha} | H_1) = 1 - \\beta$。\n        *   对 $X_1$ 使用正态近似：$P\\left(\\frac{X_1 - \\mu_1}{\\sigma_1} \\geq \\frac{k_{\\alpha} - \\mu_1}{\\sigma_1}\\right) = 1 - \\beta$。\n        *   $P\\left(Z \\geq \\frac{k_{\\alpha} - n\\theta_1}{\\sqrt{n\\theta_1(1-\\theta_1)}}\\right) = 1 - \\beta$。\n        *   令 $z_{1-\\beta}$ 为标准正态分布的上 $(1-\\beta)$-分位数。根据正态分布的对称性，$z_{1-\\beta} = -z_{\\beta}$。\n        *   所以，我们需要 $\\frac{k_{\\alpha} - n\\theta_1}{\\sqrt{n\\theta_1(1-\\theta_1)}} = z_{1-\\beta} = -z_{\\beta}$。\n        *   这给出了 $k_{\\alpha}$ 的另一个表达式：\n            $k_{\\alpha} = n\\theta_1 - z_{\\beta}\\sqrt{n\\theta_1(1-\\theta_1)}$。（公式2）\n\n    *   **求解 n**：\n        *   将 $k_{\\alpha}$ 的两个表达式（公式1和公式2）相等：\n            $n\\theta_0 + z_{\\alpha}\\sqrt{n\\theta_0(1-\\theta_0)} = n\\theta_1 - z_{\\beta}\\sqrt{n\\theta_1(1-\\theta_1)}$。\n        *   重新整理各项以求解 $\\sqrt{n}$：\n            $n\\theta_1 - n\\theta_0 = z_{\\alpha}\\sqrt{n\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{n\\theta_1(1-\\theta_1)}$。\n            $n(\\theta_1 - \\theta_0) = \\sqrt{n} \\left( z_{\\alpha}\\sqrt{\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{\\theta_1(1-\\theta_1)} \\right)$。\n            $\\sqrt{n}(\\theta_1 - \\theta_0) = z_{\\alpha}\\sqrt{\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{\\theta_1(1-\\theta_1)}$。\n        *   分离出 $\\sqrt{n}$：\n            $\\sqrt{n} = \\frac{z_{\\alpha}\\sqrt{\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{\\theta_1(1-\\theta_1)}}{\\theta_1 - \\theta_0}$。\n        *   两边平方得到 $n$：\n            $n = \\left( \\frac{z_{\\alpha}\\sqrt{\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{\\theta_1(1-\\theta_1)}}{\\theta_1 - \\theta_0} \\right)^2$。\n\n    *   **代入数值**：\n        *   $\\alpha = 0.01$。我们需要 $z_{0.01}$。通过查标准正态分布表或使用计算器，得到 $z_{0.01} \\approx 2.3263$。\n        *   功效 = $1 - \\beta = 0.9$，所以 $\\beta = 0.1$。我们需要 $z_{0.1}$。通过查表，得到 $z_{0.1} \\approx 1.2816$。\n        *   $\\theta_0 = e = 0.001$。\n        *   $\\theta_1 = p(1-e) + (1-p)e = 0.001(1-0.001) + (1-0.001)(0.001) = 0.001(0.999) + (0.999)(0.001) = 0.000999 + 0.000999 = 0.001998$。\n        *   等等，让我再次检查一下 $\\theta_1$ 的公式。\n            $\\theta_1 = p(1-e) + (1-p)e$。是的，这是正确的。\n            如果一个分子是突变型（概率 $p$），读数是正确的（概率 $1-e$）。所以是 $p(1-e)$。\n            如果一个分子是野生型（概率 $1-p$），读数是错误的（概率 $e$）。所以是 $(1-p)e$。\n            两者之和是观察到变异读数的总概率。\n            $\\theta_1 = 0.001 \\times (1-0.001) + (1-0.001) \\times 0.001 = 0.001 \\times 0.999 + 0.999 \\times 0.001 = 0.000999 + 0.000999 = 0.001998$。\n            这看起来非常接近 $2p$。让我们检查一下另一种写法：$\\theta_1 = p+e-2pe = 0.001 + 0.001 - 2(0.001)(0.001) = 0.002 - 0.000002 = 0.001998$。正确。\n\n    *   **计算 n 公式中的各项**：\n        *   $\\theta_1 - \\theta_0 = 0.001998 - 0.001 = 0.000998$。\n        *   $\\sqrt{\\theta_0(1-\\theta_0)} = \\sqrt{0.001(1-0.001)} = \\sqrt{0.001 \\times 0.999} = \\sqrt{0.000999} \\approx 0.031607$。\n        *   $\\sqrt{\\theta_1(1-\\theta_1)} = \\sqrt{0.001998(1-0.001998)} = \\sqrt{0.001998 \\times 0.998002} = \\sqrt{0.001994007996} \\approx 0.044654$。\n        *   分子 = $z_{\\alpha}\\sqrt{\\theta_0(1-\\theta_0)} + z_{\\beta}\\sqrt{\\theta_1(1-\\theta_1)}$\n            $= (2.3263) \\times (0.031607) + (1.2816) \\times (0.044654)$\n            $= 0.073527 + 0.057229$\n            $= 0.130756$\n        *   分母 = $\\theta_1 - \\theta_0 = 0.000998$。\n        *   $\\sqrt{n} = \\frac{0.130756}{0.000998} \\approx 131.018$。\n        *   $n = (131.018)^2 \\approx 17165.7$。\n\n    *   **使用更高的精度进行精细计算**：\n        *   $z_{0.01} \\approx 2.326347874$\n        *   $z_{0.1} \\approx 1.281551566$\n        *   $\\theta_0 = 0.001$\n        *   $\\theta_1 = 0.001998$\n        *   $\\theta_1 - \\theta_0 = 0.000998$\n        *   $\\theta_0(1-\\theta_0) = 0.001 \\times 0.999 = 0.000999$\n        *   $\\sqrt{\\theta_0(1-\\theta_0)} = \\sqrt{0.000999} \\approx 0.03160696126$\n        *   $\\theta_1(1-\\theta_1) = 0.001998 \\times (1-0.001998) = 0.001998 \\times 0.998002 = 0.001994007996$\n        *   $\\sqrt{\\theta_1(1-\\theta_1)} = \\sqrt{0.001994007996} \\approx 0.0446543166$\n        *   分子：\n            $(2.326347874 \\times 0.03160696126) + (1.281551566 \\times 0.0446543166)$\n            $= 0.073527457 + 0.057228834 = 0.130756291$\n        *   $\\sqrt{n} = \\frac{0.130756291}{0.000998} = 131.01832765$\n        *   $n = (131.01832765)^2 = 17165.806...$\n\n    *   **近似检查**：\n        *   $n$ 的公式是比较两个比例的标准公式。\n        *   如果 $\\theta_0$ 和 $\\theta_1$ 很小，可以进行简化。那么 $1-\\theta_0 \\approx 1$ 且 $1-\\theta_1 \\approx 1$。\n        *   $n \\approx \\left( \\frac{z_{\\alpha}\\sqrt{\\theta_0} + z_{\\beta}\\sqrt{\\theta_1}}{\\theta_1 - \\theta_0} \\right)^2$。\n        *   让我们看看这个会得到什么值。\n        *   $\\sqrt{\\theta_0} = \\sqrt{0.001} \\approx 0.03162277$\n        *   $\\sqrt{\\theta_1} = \\sqrt{0.001998} \\approx 0.04469899$\n        *   分子 $\\approx (2.3263) \\times (0.03162277) + (1.2816) \\times (0.04469899)$\n            $= 0.07356 + 0.05728 = 0.13084$\n        *   分母 = $0.000998$\n        *   $\\sqrt{n} \\approx \\frac{0.13084}{0..000998} \\approx 131.102$\n        *   $n \\approx (131.102)^2 \\approx 17187.7$。\n        *   这很接近，但原始公式更准确。问题没有说明要使用这种简化，所以我将坚持使用完整公式。\n\n    *   **最终答案**：问题要求最小*整数* $n$。由于我们计算出 $n = 17165.806...$，我们需要向上取整到下一个整数，以确保满足功效和显著性水平的约束。\n    *   因此，最小整数 $n$ 是 $17166$。\n\n    *   **再次检查逻辑**：\n        1.  假设是正确的。$H_0: \\theta = \\theta_0$， $H_1: \\theta = \\theta_1$。\n        2.  检验是单边的，对于大的 $X$ 拒绝原假设。\n        3.  指定了正态近似。\n        4.  约束1（显著性）：$P(X \\ge k | H_0) \\le \\alpha$。\n            这导致 $\\frac{k - n\\theta_0}{\\sqrt{n\\theta_0(1-\\theta_0)}} \\ge z_\\alpha$。我们将其设为等式以求边界情况，所以 $k = n\\theta_0 + z_\\alpha \\sqrt{n\\theta_0(1-\\theta_0)}$。\n        5.  约束2（功效）：$P(X \\ge k | H_1) = 1-\\beta$。\n            这导致 $\\frac{k - n\\theta_1}{\\sqrt{n\\theta_1(1-\\theta_1)}} = z_{1-\\beta} = -z_\\beta$。所以 $k = n\\theta_1 - z_\\beta \\sqrt{n\\theta_1(1-\\theta_1)}$。\n        6.  将 $k$ 的两个表达式相等：\n            $n\\theta_0 + z_\\alpha \\sqrt{n\\theta_0(1-\\theta_0)} = n\\theta_1 - z_\\beta \\sqrt{n\\theta_1(1-\\theta_1)}$\n            $n(\\theta_1 - \\theta_0) = z_\\alpha \\sqrt{n\\theta_0(1-\\theta_0)} + z_\\beta \\sqrt{n\\theta_1(1-\\theta_1)}$\n            $\\sqrt{n} (\\theta_1 - \\theta_0) = z_\\alpha \\sqrt{\\theta_0(1-\\theta_0)} + z_\\beta \\sqrt{\\theta_1(1-\\theta_1)}$\n            $\\sqrt{n} = \\frac{z_\\alpha \\sqrt{\\theta_0(1-\\theta_0)} + z_\\beta \\sqrt{\\theta_1(1-\\theta_1)}}{\\theta_1 - \\theta_0}$\n            这是标准公式。推导是正确的。\n\n    *   **最终数值核算**：\n        *   $e = 10^{-3}$\n        *   $p = 10^{-3}$\n        *   $\\alpha = 0.01 \\implies z_\\alpha \\approx 2.3263$\n        *   $1-\\beta = 0.9 \\implies \\beta = 0.1 \\implies z_\\beta \\approx 1.2816$\n        *   $\\theta_0 = e = 0.001$\n        *   $\\theta_1 = p + e - 2pe = 0.001 + 0.001 - 2(0.001)^2 = 0.002 - 0.000002 = 0.001998$\n        *   $\\theta_1 - \\theta_0 = 0.000998$\n        *   $\\sqrt{\\theta_0(1-\\theta_0)} = \\sqrt{0.001 \\times 0.999} = \\sqrt{0.000999} \\approx 0.031607$\n        *   $\\sqrt{\\theta_1(1-\\theta_1)} = \\sqrt{0.001998 \\times 0.998002} = \\sqrt{0.001994007996} \\approx 0.044654$\n        *   $\\sqrt{n} = \\frac{2.3263 \\times 0.031607 + 1.2816 \\times 0.044654}{0.000998}$\n        *   $\\sqrt{n} = \\frac{0.073527 + 0.057229}{0.000998} = \\frac{0.130756}{0.000998} \\approx 131.018$\n        *   $n = (131.018)^2 \\approx 17165.7$\n        *   最小整数 $n$ 为 $17166$。\n\n    *   问题指明“不使用连续性校正”。我的推导直接在离散变量上使用正态近似，这正是“不使用连续性校正”的含义。如果使用连续性校正，条件将是 $P(X \\ge k) \\approx P(X_{cont} \\ge k-0.5)$，这会稍微改变公式。由于明确禁止使用，我当前的方法是正确的。\n\n    *   逻辑和计算看起来很可靠。现在我将把它正式地写出来。我需要注意所有数学表达式的 LaTeX 格式。\n\n    *   **解决方案文本的结构**：\n        1.  将问题表述为假设检验。定义 $H_0$ 和 $H_1$。\n        2.  确定 $H_0$ 和 $H_1$ 下的分布。\n        3.  指明参数 $\\theta_0$ 和 $\\theta_1$ 并计算它们的值。\n        4.  引入二项分布的正态近似。说明两种假设下的均值和方差。\n        5.  形式化显著性水平 $\\alpha$ 的条件。这用 $n$ 和 $z_\\alpha$ 定义了临界值 $k_{\\alpha}$。\n        6.  形式化统计功效 $1-\\beta$ 的条件。这给出了用 $n$ 和 $z_\\beta$ 表示的 $k_{\\alpha}$ 的第二个表达式。\n        7.  将 $k_{\\alpha}$ 的两个表达式相等并求解 $n$。\n        8.  代入给定的数值 $\\alpha$, $1-\\beta$, $p$, and $e$。\n        9.  计算 $n$ 的值并向上取整，以找到所需的最小覆盖深度。\n        10. 按要求格式提供最终答案。\n\n    *   正态近似的合理性是*后验*证明的。\n        *   当 $n \\approx 17166$ 时：\n        *   $n\\theta_0 = 17166 \\times 0.001 = 17.166 > 10$。\n        *   $n(1-\\theta_0) = 17166 \\times 0.999 \\approx 17149 > 10$。\n        *   $n\\theta_1 = 17166 \\times 0.001998 \\approx 34.298 > 10$。\n        *   $n(1-\\theta_1) = 17166 \\times 0.998002 \\approx 17131 > 10$。\n        *   正态近似的合理性是*后验*证明的。\n\n    *   步骤是稳健的。我准备好写解决方案了。这个问题没有缺陷，定义明确。我的推理是合理的，计算也得到了验证。",
            "answer": "$$\\boxed{17166}$$"
        },
        {
            "introduction": "ctDNA分析中的一个主要挑战是区分真正的肿瘤源性体细胞突变与种系变异或意义不明确的克隆性造血（Clonal Hematopoiesis of Indeterminate Potential, CHIP）。本编码实践将指导您使用配对的正常白细胞数据，应用贝叶斯统计来量化证据并创建一个稳健的过滤器，从而构建一个有原则的决策规则。",
            "id": "4546235",
            "problem": "您的任务是设计并实现一个决策规则，利用配对的正常白细胞 (WBC) 测序数据来过滤非肿瘤变异，同时在循环肿瘤脱氧核糖核酸 (ctDNA) 分析中保留肿瘤特异性信号。您需要将来自血浆和配对正常 WBC 的等位基因计数建模为源于具有未知备选等位基因分数的二项式抽样，并使用带有无信息先验的贝叶斯方法来量化证据。目标是构建一个在数学上具有原则性的规则，该规则能过滤种系变异和意义不明确的克隆性造血 (CHIP) 变异，同时保留真正的肿瘤源变异。\n\n从以下基本基础开始：\n- 对于每个位点，具有总深度的样本中备选读数的数量遵循以潜在备选等位基因分数为条件的二项分布。如果 $a$ 是备选读数计数，$n$ 是总深度，则对于某个未知的 $p \\in [0,1]$，有 $a \\sim \\mathrm{Binomial}(n, p)$。\n- 使用二项比例的 Jeffreys 先验，即参数为 $\\alpha_0 = 0.5$ 和 $\\beta_0 = 0.5$ 的贝塔分布 $\\mathrm{Beta}(\\alpha_0, \\beta_0)$。\n- 在此模型下，给定各自的等位基因分数，配对正常 WBC 和血浆的测量结果是条件独立的。\n\n定义：\n- 令 $n_p$ 和 $a_p$ 分别表示某个变异的血浆深度和血浆备选读数。\n- 令 $n_w$ 和 $a_w$ 分别表示同一变异的 WBC 深度和 WBC 备选读数。\n- 令 $p_p$ 和 $p_w$ 分别表示血浆和 WBC 中未知的备选等位基因分数。\n- 定义后验分布 $p_p \\mid (a_p, n_p) \\sim \\mathrm{Beta}(\\alpha_p, \\beta_p)$ 和 $p_w \\mid (a_w, n_w) \\sim \\mathrm{Beta}(\\alpha_w, \\beta_w)$，它们由先验 $\\mathrm{Beta}(0.5, 0.5)$ 和二项似然推导得出。\n\n决策规则要求：\n- 您必须计算 WBC 备选等位基因分数超过 WBC 最小阈值 $\\tau_w \\in (0,1)$ 的后验概率，即 $S_w = \\Pr(p_w > \\tau_w \\mid a_w, n_w)$。\n- 您必须计算血浆相对于 WBC 富集至少 $c > 1$ 倍的后验概率，即 $E = \\Pr(p_p > c \\, p_w \\mid a_p, n_p, a_w, n_w)$，其中 $p_p$ 和 $p_w$ 在各自独立的贝塔后验分布下是后验独立的。\n- 对所有变异使用以下固定超参数：$\\alpha_0 = 0.5$，$\\beta_0 = 0.5$，$\\tau_w = 0.01$，$\\tau_p = 0.005$ (仅用于内部验证)，富集因子 $c = 3.0$，WBC 证据阈值 $\\theta_w = 0.95$，以及富集显著性阈值 $\\theta_{\\mathrm{enrich}} = 0.10$。\n\n过滤决策规则：\n- 当且仅当以下两个条件同时成立时，输出 $1$ (过滤为非肿瘤)：\n  1. $S_w \\ge \\theta_w$ (有强证据表明 WBC 中的信号存在且高于 $\\tau_w$)，\n  2. $E \\le \\theta_{\\mathrm{enrich}}$ (没有强证据表明血浆相对于 WBC 富集了 $c$ 倍)。\n- 否则，输出 $0$ (作为可能的肿瘤特异性变异予以保留)。\n\n本任务的输入数据嵌入在程序中，由一个小型测试套件组成，每个测试用例表示为一个有序四元组 $(n_p, a_p, n_w, a_w)$：\n- 用例 1 (明确的肿瘤特异性)：$(n_p, a_p, n_w, a_w) = (4000, 200, 4000, 2)$。\n- 用例 2 (种系杂合)：$(n_p, a_p, n_w, a_w) = (500, 255, 500, 250)$。\n- 用例 3 (类 CHIP，WBC 高，血浆低)：$(n_p, a_p, n_w, a_w) = (6000, 120, 2000, 200)$。\n- 用例 4 (仅噪声，两者均接近错误率)：$(n_p, a_p, n_w, a_w) = (10000, 5, 10000, 8)$。\n- 用例 5 (两者均存在但血浆富集；保留)：$(n_p, a_p, n_w, a_w) = (3000, 300, 3000, 60)$。\n- 用例 6 (种系纯合备选)：$(n_p, a_p, n_w, a_w) = (200, 198, 200, 199)$。\n- 用例 7 (WBC 证据弱属临界情况，血浆中等；保留)：$(n_p, a_p, n_w, a_w) = (3000, 90, 3000, 18)$。\n\n科学真实性和建模假设：\n- 对于给定的 $n_p$ 和 $p_p$，$a_p$ 的测量过程以及对于给定的 $n_w$ 和 $p_w$，$a_w$ 的测量过程如上所定义，是二项的。\n- 测序错误率通过选择 $\\tau_w$ 和使用一个不会在零附近虚假夸大证据的先验来隐式处理；不要使用任何显式的错误率参数。所有等位基因分数均以 $[0,1]$ 区间内的小数表示。\n- 概率 $E$ 必须根据 $p_p$ 和 $p_w$ 的独立贝塔后验分布从第一性原理计算得出。当有精确的解析表达式时，您可以使用它们，或者通过与定义一致的数值积分来计算 $E$。\n\n您的程序应生成单行输出，其中包含七个测试用例的结果，格式为方括号内由逗号分隔的整数列表（例如，“[1,0,1,0,1,1,0]”）。第 $i$ 个整数必须是第 $i$ 个测试用例的决策，其中 $1$ 表示“过滤”，$0$ 表示“保留”。不应打印任何其他文本。",
            "solution": "我们从二项抽样模型开始。对于一个给定的位点，令 $a_p \\sim \\mathrm{Binomial}(n_p, p_p)$ 且 $a_w \\sim \\mathrm{Binomial}(n_w, p_w)$，其中 $p_p, p_w \\in [0,1]$ 分别代表血浆和白细胞 (WBC) 中未知的备选等位基因分数。我们独立地对 $p_p$ 和 $p_w$ 应用参数为 $\\alpha_0 = 0.5$ 和 $\\beta_0 = 0.5$ 的 Jeffreys 先验 $\\mathrm{Beta}(\\alpha_0, \\beta_0)$。根据共轭性，后验分布为\n$$\np_p \\mid (a_p, n_p) \\sim \\mathrm{Beta}(\\alpha_p, \\beta_p), \\quad \\alpha_p = \\alpha_0 + a_p, \\ \\beta_p = \\beta_0 + (n_p - a_p),\n$$\n$$\np_w \\mid (a_w, n_w) \\sim \\mathrm{Beta}(\\alpha_w, \\beta_w), \\quad \\alpha_w = \\alpha_0 + a_w, \\ \\beta_w = \\beta_0 + (n_w - a_w).\n$$\n因为血浆和 WBC 的测量是在各自参数的条件下由不同的抽样过程生成的，并且先验是独立的，所以 $p_p$ 和 $p_w$ 的后验分布是独立的。\n\n我们需要以下后验概率：\n\n1. WBC 证据统计量 $S_w = \\Pr(p_w > \\tau_w \\mid a_w, n_w)$。由于 $p_w \\mid \\text{data} \\sim \\mathrm{Beta}(\\alpha_w, \\beta_w)$，我们可以表示为\n$$\nS_w = \\int_{\\tau_w}^{1} \\frac{1}{B(\\alpha_w,\\beta_w)} x^{\\alpha_w - 1} (1-x)^{\\beta_w - 1} \\, dx = 1 - I_{\\tau_w}(\\alpha_w,\\beta_w),\n$$\n其中 $B(\\cdot,\\cdot)$ 是贝塔函数，$I_{x}(\\alpha,\\beta)$ 是正则化不完全贝塔函数，它等于在 $x$ 处求值的 $\\mathrm{Beta}(\\alpha,\\beta)$ 分布的累积分布函数。\n\n2. 对于 $c > 1$ 的富集概率 $E = \\Pr(p_p > c \\, p_w \\mid a_p, n_p, a_w, n_w)$。鉴于后验的独立性，这等于\n$$\nE = \\int_{0}^{1} \\int_{c y}^{1} f_{p_p}(x) \\, f_{p_w}(y) \\, dx \\, dy,\n$$\n其中 $f_{p_p}(x) = \\frac{1}{B(\\alpha_p,\\beta_p)} x^{\\alpha_p - 1} (1-x)^{\\beta_p - 1}$ 且 $f_{p_w}(y) = \\frac{1}{B(\\alpha_w,\\beta_w)} y^{\\alpha_w - 1} (1-y)^{\\beta_w - 1}$。因为只有当 $c y \\le 1$ 时，内部积分才非零，所以 $y$ 的积分区域在 $y_{\\max} = 1 / c$ 处截断，得到\n$$\nE = \\int_{0}^{1/c} \\left[ \\int_{c y}^{1} f_{p_p}(x) \\, dx \\right] f_{p_w}(y) \\, dy = \\int_{0}^{1/c} \\left[ 1 - I_{c y}(\\alpha_p, \\beta_p) \\right] \\, f_{p_w}(y) \\, dy.\n$$\n这个积分可以通过数值方法计算到任何期望的精度。内部方括号项是在 $c y$ 处求值的 $\\mathrm{Beta}(\\alpha_p,\\beta_p)$ 分布的互补累积分布函数。\n\n该决策规则旨在过滤两类非肿瘤变异，同时保留肿瘤特异性变异：\n\n- 种系变异：这些变异同时出现在 WBC 和血浆中，具有相似的备选等位基因分数（对于杂合位点，通常接近 $0.5$；对于纯合备选，接近 $1.0$）。在该模型下，对于合理的深度，$S_w$ 将接近 $1$，并且由于 $p_p$ 并不显著大于 $p_w$，对于 $c > 1$，$E$ 将会很小。\n\n- 意义不明确的克隆性造血 (CHIP) 变异：这些是源自白细胞谱系的获得性变异，由于正常的无细胞脱氧核糖核酸背景，它们可以出现在血浆中，但其等位基因分数通常不超过 WBC 中的分数。在该模型下，$S_w$ 将会很大，而 $E$ 将会很小。\n\n- 肿瘤特异性 ctDNA 变异：这些变异相对于 WBC 在血浆中富集，或者当 WBC 中似乎不存在时它们却存在于血浆中。在该模型下，$S_w$ 将会很小或 $E$ 将会很大，从而避免被过滤。\n\n我们选择如下的超参数和阈值：$\\alpha_0 = 0.5$，$\\beta_0 = 0.5$，$\\tau_w = 0.01$，$\\tau_p = 0.005$ (后者提供了一个合理性阈值，但未直接用于最终规则)，富集因子 $c = 3.0$，WBC 证据阈值 $\\theta_w = 0.95$，以及富集显著性阈值 $\\theta_{\\mathrm{enrich}} = 0.10$。\n\n每个测试用例 $(n_p, a_p, n_w, a_w)$ 的算法步骤：\n\n1. 计算后验参数 $\\alpha_p = 0.5 + a_p$，$\\beta_p = 0.5 + (n_p - a_p)$，以及 $\\alpha_w = 0.5 + a_w$，$\\beta_w = 0.5 + (n_w - a_w)$。\n\n2. 使用正则化不完全贝塔函数计算 $S_w = 1 - I_{\\tau_w}(\\alpha_w, \\beta_w)$。\n\n3. 计算 $E = \\int_{0}^{1/c} \\left[ 1 - I_{c y}(\\alpha_p, \\beta_p) \\right] \\, f_{p_w}(y) \\, dy$，其中 $f_{p_w}(y) = \\frac{1}{B(\\alpha_w,\\beta_w)} y^{\\alpha_w - 1} (1-y)^{\\beta_w - 1}$。使用数值求积法进行数值评估。这是一个在有限区间 $[0, 1/c]$ 上对由标准特殊函数构成的光滑被积函数进行的一维积分。\n\n4. 当且仅当 $S_w \\ge \\theta_w$ 且 $E \\le \\theta_{\\mathrm{enrich}}$ 时决定过滤。如果过滤则输出 $1$，否则输出 $0$。\n\n基于基础的理由：\n- 二项模型和 Jeffreys 先验确保后验是正常的，并能适当地反映不确定性，避免在低计数时出现过度自信。\n- 统计量 $S_w$ 识别出 WBC 支持度高于最低变异等位基因分数阈值 $\\tau_w$ 的位点，从而将测序噪声（通常会低于 $\\tau_w$）与真实的 WBC 源信号（种系或 CHIP）分离开来。\n- 富集概率 $E$ 将在肿瘤源 ctDNA 情况下预期的血浆相对于 WBC 的富集概念形式化，这基于独立贝塔后验的相对大小。因子 $c > 1$ 对微小偏差进行惩罚，并侧重于有意义的富集。\n- $S_w \\ge \\theta_w$ 和 $E \\le \\theta_{\\mathrm{enrich}}$ 的联合条件捕获了预期的过滤行为，同时保留了那些在 WBC 中不存在或在血浆中富集的肿瘤特异性信号。\n\n将这些步骤应用于给定的测试套件会生成一个确定性的整数列表，对应于过滤（非肿瘤）和保留（可能是肿瘤特异性）的决策。最终程序精确地实现了这一计算，并以单行逗号分隔的列表形式（包含在方括号内）按指定测试用例顺序打印结果。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\nfrom scipy.special import betainc, beta as beta_fn\n\ndef beta_posterior_params(a, n, alpha0=0.5, beta0=0.5):\n    \"\"\"Return posterior alpha, beta for Beta prior with binomial likelihood.\"\"\"\n    return alpha0 + a, beta0 + (n - a)\n\ndef prob_vaf_gt_tau(alpha, beta, tau):\n    \"\"\"Compute P(X > tau) for X ~ Beta(alpha, beta) using regularized incomplete beta.\"\"\"\n    # betainc(alpha, beta, x) is the CDF at x\n    cdf = betainc(alpha, beta, tau)\n    p = 1.0 - cdf\n    # clip to [0,1] for numerical stability\n    if p  0.0:\n        p = 0.0\n    elif p > 1.0:\n        p = 1.0\n    return p\n\ndef prob_x_gt_cy(alpha_x, beta_x, alpha_y, beta_y, c):\n    \"\"\"\n    Compute P(X > c Y) where X ~ Beta(alpha_x, beta_x), Y ~ Beta(alpha_y, beta_y), independent.\n    Using the 1D integral: ∫_0^{1/c} [1 - I_{c y}(alpha_x, beta_x)] f_Y(y) dy.\n    \"\"\"\n    if c = 0:\n        raise ValueError(\"c must be > 0\")\n    y_max = 1.0 / c\n    norm_y = beta_fn(alpha_y, beta_y)\n\n    def integrand(y):\n        # For y in [0, 1/c], c*y = 1, so no need to clip argument\n        tail_x = 1.0 - betainc(alpha_x, beta_x, c * y)\n        pdf_y = (y ** (alpha_y - 1.0)) * ((1.0 - y) ** (beta_y - 1.0)) / norm_y\n        return tail_x * pdf_y\n\n    # Numerical integration over [0, 1/c]\n    res, _ = quad(integrand, 0.0, y_max, epsabs=1e-12, epsrel=1e-10, limit=200)\n    # Clip to [0,1] for numerical stability\n    if res  0.0:\n        res = 0.0\n    elif res > 1.0:\n        res = 1.0\n    return res\n\ndef decide_filter(n_p, a_p, n_w, a_w,\n                  alpha0=0.5, beta0=0.5,\n                  tau_w=0.01, c=3.0,\n                  theta_w=0.95, theta_enrich=0.10):\n    \"\"\"\n    Return 1 if filter (non-tumor) else 0 (retain).\n    \"\"\"\n    # Posterior params\n    alpha_p, beta_p = beta_posterior_params(a_p, n_p, alpha0, beta0)\n    alpha_w, beta_w = beta_posterior_params(a_w, n_w, alpha0, beta0)\n\n    # WBC evidence above tau_w\n    S_w = prob_vaf_gt_tau(alpha_w, beta_w, tau_w)\n\n    # Plasma enrichment relative to WBC by factor c\n    E = prob_x_gt_cy(alpha_p, beta_p, alpha_w, beta_w, c)\n\n    # Decision\n    filter_flag = 1 if (S_w >= theta_w and E = theta_enrich) else 0\n    return filter_flag\n\ndef solve():\n    # Fixed hyperparameters as specified\n    alpha0 = 0.5\n    beta0 = 0.5\n    tau_w = 0.01\n    c = 3.0\n    theta_w = 0.95\n    theta_enrich = 0.10\n\n    # Define the test cases from the problem statement.\n    # Each case: (n_p, a_p, n_w, a_w)\n    test_cases = [\n        (4000, 200, 4000, 2),    # Case 1: tumor-specific, clear\n        (500, 255, 500, 250),    # Case 2: germline heterozygous\n        (6000, 120, 2000, 200),  # Case 3: CHIP-like\n        (10000, 5, 10000, 8),    # Case 4: noise-only\n        (3000, 300, 3000, 60),   # Case 5: both present, plasma enriched -> retain\n        (200, 198, 200, 199),    # Case 6: germline homozygous alt\n        (3000, 90, 3000, 18),    # Case 7: borderline WBC weak, plasma moderate -> retain\n    ]\n\n    results = []\n    for (n_p, a_p, n_w, a_w) in test_cases:\n        result = decide_filter(\n            n_p, a_p, n_w, a_w,\n            alpha0=alpha0, beta0=beta0,\n            tau_w=tau_w, c=c,\n            theta_w=theta_w, theta_enrich=theta_enrich\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了单核苷酸变异，ctDNA还支持对拷贝数变异（Copy Number Variations, CNV）进行全基因组分析，而CNV是重要的癌症生物标志物。这项高级实践涉及使用动态规划实现一种分割算法，从对数比率覆盖数据中识别增益或缺失的区域，并进一步推断潜在的肿瘤分数和CNV状态。",
            "id": "4546227",
            "problem": "给定一个一维的 log2 覆盖率比值序列，该序列代表了连续基因组区间上的循环肿瘤脱氧核糖核酸 (ctDNA) 数据。每个区间反映了相对于两拷贝二倍体基线的标准化覆盖率，因此偏离零的值源于肿瘤组分中的拷贝数变异 (CNV) 和采样噪声。核心计算目标是，仅从混合模型和基于似然的推断的基本原理和经过充分检验的事实出发，推导出一个有原则的分割算法来推断肿瘤比例和 CNV 状态，并明确断点检测的标准。\n\n要使用的基本依据和定义：\n- 区间中的预期覆盖率与总拷贝数成正比。在一个由肿瘤比例 $f$ 和正常组织比例 $(1-f)$ 组成的混合物中，对于一个肿瘤拷贝数为 $C_{\\mathrm{t}}$、正常组织拷贝数为 $C_{\\mathrm{n}}=2$ 的基因组片段，其预期的总拷贝数为 $f \\, C_{\\mathrm{t}} + (1-f)\\, 2$。\n- 相对于二倍体基线的预期标准化覆盖率比值为 $\\dfrac{f \\, C_{\\mathrm{t}} + (1-f)\\, 2}{2}$，预期的 log2 覆盖率比值为\n$$\nr(C_{\\mathrm{t}}, f) = \\log_2\\!\\left(\\frac{f \\, C_{\\mathrm{t}} + (1-f)\\, 2}{2}\\right).\n$$\n- 在一个同质片段内，log2 覆盖率比值的噪声将被建模为独立同分布的高斯噪声，其均值为零，方差未知。在足够的读取深度下，这是一个经过充分检验的、针对覆盖率衍生比值的近似模型。\n- 分割将通过在分段常数均值模型下进行最大似然估计来推导，并加入一个由贝叶斯信息准则 (BIC) 启发的复杂度惩罚。对于一个包含 $n$ 个观测值、围绕其均值的残差平方和为 $\\mathrm{SSE}$ 的片段，最大化对数似然的负两倍（不计加法常数）是 $n \\, \\log(\\mathrm{SSE}/n)$。BIC 为 $k$ 个自由参数增加了一个惩罚项 $k \\, \\log(N)$，其中 $N$ 是总观测数。\n\n您的任务：\n1. 推导一种算法，通过最小化一个与 BIC 原则一致的全局目标，将 log2 覆盖率比值序列分割成具有恒定均值的连续片段。该目标必须是所有片段的 $n_s \\, \\log(\\mathrm{SSE}_s/n_s)$ 之和，再加上每个片段一个与 $\\log(N)$ 成正比的恒定惩罚，其中 $n_s$ 和 $\\mathrm{SSE}_s$ 分别是片段长度和片段残差平方和，$N$ 是总长度。施加最小片段长度约束以避免过拟合。\n2. 使用单均值模型和在断点处进行双均值分裂之间的广义似然比 (GLR) 来定义断点检测准则。对于一个候选断点，它将一个长度为 $n$ 的合并区域分裂为两个长度为 $n_1$ 和 $n_2$ 的子区域，单均值拟合的残差平方和为 $\\mathrm{SSE}_\\mathrm{one}$，双均值拟合的残差平方和分别为 $\\mathrm{SSE}_1, \\mathrm{SSE}_2$，定义 GLR 统计量\n$$\nT = n \\, \\log\\!\\left(\\frac{\\mathrm{SSE}_\\mathrm{one}}{n}\\right) \\;-\\; n_1 \\, \\log\\!\\left(\\frac{\\mathrm{SSE}_1}{n_1}\\right) \\;-\\; n_2 \\, \\log\\!\\left(\\frac{\\mathrm{SSE}_2}{n_2}\\right).\n$$\n使用 BIC 启发的惩罚来指定与 $N$ 相关的接受阈值，并要求在断点处的片段满足最小长度。该阈值必须表示为 $\\log(N)$ 的函数。\n3. 给定分段后的均值，通过最小化观测到的片段均值与 $r(C_{\\mathrm{t}}, f)$ 之间的加权平方偏差，来推断肿瘤比例 $f$ 和每个片段的整数肿瘤 CNV 状态 $C_{\\mathrm{t}}$，权重等于片段长度。假设 $C_{\\mathrm{t}} \\in \\{0, 1, 2, 3, 4, 5, 6\\}$，并选择一个在 $[0, 1)$ 范围内的十进制数 $f$，以最小化所有片段的总加权平方误差，允许每个片段为选定的 $f$ 选择其最佳整数 $C_{\\mathrm{t}}$。如果所有分段均值都在 $0$ 的一个很小容差范围内，并且推断出的 CNV 状态均为 $2$，则报告肿瘤比例为 $0.0$，因为在没有 CNV 的情况下它是不可识别的。\n4. 将推导出的算法实现为一个完整的、可运行的程序，该程序能在指定参数下生成合成测试数据，运行您的分割和推断流程，应用断点标准，并产生所需的输出。\n\n角度单位不适用。不涉及物理单位。任何可能以百分比表示的量（肿瘤比例）必须表示为十进制数，不得使用百分号。\n\n测试套件：\n为了可复现性，每个测试用例必须根据以下参数生成。在所有情况下，标准差为 $\\sigma = 0.02$ 的高斯噪声被独立地添加到每个区间；随机数生成器必须使用指定的种子进行初始化。每个区间的 log2 覆盖率比值等于片段期望值 $r(C_{\\mathrm{t}}, f)$ 加上噪声。所有区间索引都是从 $0$ 开始的，断点索引定义为上游片段的最后一个索引。\n\n- 测试用例 1 (标准路径)：总区间数 $N=120$，片段长度为 $[40, 40, 40]$，肿瘤 CNV 状态为 $[3, 2, 1]$，肿瘤比例 $f=0.3$，种子 $123$。\n- 测试用例 2 (边界小振幅 CNV)：总区间数 $N=100$，片段长度为 $[60, 40]$，肿瘤 CNV 状态为 $[4, 2]$，肿瘤比例 $f=0.05$，种子 $456$。\n- 测试用例 3 (边缘情况，无 CNV)：总区间数 $N=80$，一个长度为 $[80]$ 的片段，肿瘤 CNV 状态为 $[2]$，肿瘤比例 $f=0.4$ 但无 CNV 存在，种子 $789$。\n- 测试用例 4 (高肿瘤比例，伴有缺失和扩增)：总区间数 $N=150$，片段长度为 $[50, 50, 50]$，肿瘤 CNV 状态为 $[1, 4, 2]$，肿瘤比例 $f=0.6$，种子 $2468$。\n\n需要编码的算法要求：\n- 使用动态规划在满足最小片段长度约束的所有分区上最小化受 BIC 启发的的目标函数。设最小片段长度为 $\\max(3, \\lfloor 0.05 N \\rfloor)$。\n- 使用前缀和在 $O(1)$ 时间内计算任何候选片段的 $\\mathrm{SSE}$。\n- 对于断点验证，如果 GLR 统计量 $T$ 超过 $\\log(N)$ 并且两个相邻片段都满足最小长度约束，则接受该断点。\n- 对于肿瘤比例推断，在 $[0.0, 0.99]$ 范围内以 $0.01$ 的步长对 $f$ 值进行网格搜索，并选择最小化观测到的片段均值与 $r(C_{\\mathrm{t}}, f)$ 之间加权总平方偏差的 $f$。报告四舍五入到三位小数的 $f$。然后报告与所选 $f$ 对应的每个片段的推断整数 CNV 状态 $C_{\\mathrm{t}}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是以下形式的列表：\n$[f_{\\mathrm{est}}, [C_{\\mathrm{t},1}, C_{\\mathrm{t},2}, \\dots], [b_1, b_2, \\dots], \\mathrm{valid}]$,\n其中 $f_{\\mathrm{est}}$ 是推断的肿瘤比例，表示为四舍五入到三位小数的十进制数，$[C_{\\mathrm{t},1}, C_{\\mathrm{t},2}, \\dots]$ 是按顺序排列的每个片段的推断整数 CNV 状态，$[b_1, b_2, \\dots]$ 是断点索引，$\\mathrm{valid}$ 是一个布尔值，指示所有检测到的断点是否都通过了 GLR 阈值。最终的单行不得包含空格，例如：\n$[[0.300,[3,2,1],[39,79],True],[0.050,[4,2],[59],True],[0.000,[2],[],True],[0.600,[1,4,2],[49,99],True]]$。",
            "solution": "用户提供的问题陈述已经过严格验证，并被确定为具有科学依据、良定且客观的。它概述了生物信息学中用于分析循环肿瘤 DNA (ctDNA) 数据的综合性任务，该任务基于已建立的统计学和生物学原理。问题是自洽的，为严谨和可复现的解决方案提供了所有必要的模型、参数和约束。继续进行解决方案。\n\n### 1. 理论阐述\n\n该问题要求开发一个用于 ctDNA 分析的多阶段流程：数据分割、断点验证和生物物理参数推断。\n\n#### 1.1. 数据模型\n\n输入是观测到的 log2 覆盖率比值序列，$\\{y_i\\}_{i=0}^{N-1}$。该模型假设这些观测值来自一个被噪声破坏的分段常数信号。对于一个肿瘤拷贝数为 $C_{\\mathrm{t}}$、肿瘤比例为 $f$ 的基因组片段，其预期的 log-ratio 为：\n$$\nr(C_{\\mathrm{t}}, f) = \\log_2\\left(\\frac{f C_{\\mathrm{t}} + (1-f) 2}{2}\\right)\n$$\n一个片段内的观测值被建模为来自高斯分布的独立同分布 (i.i.d.) 随机变量：\n$$\ny_i = \\mu_s + \\epsilon_i, \\quad \\epsilon_i \\sim \\mathcal{N}(0, \\sigma_s^2)\n$$\n其中 $\\mu_s$ 是片段 $s$ 的真实平均 log-ratio。\n\n#### 1.2. 作为最优分区的分割\n\n分割的目标是找到序列 $\\{y_i\\}$ 到连续片段中的最优分区。这被构建为一个模型选择问题，我们寻求最小化一个在拟合优度与模型复杂性之间取得平衡的成本函数。该成本函数源自贝叶斯信息准则 (BIC)。\n\n对于一个长度为 $n_s$、数据为 $\\{y_i\\}_{i \\in s}$ 的单个片段 $s$，均值的最大似然估计是样本均值，$\\hat{\\mu}_s = \\frac{1}{n_s} \\sum_{i \\in s} y_i$。残差平方和为 $\\mathrm{SSE}_s = \\sum_{i \\in s} (y_i - \\hat{\\mu}_s)^2$。假设方差估计为 $\\hat{\\sigma}_s^2 = \\mathrm{SSE}_s / n_s$，则此片段中数据的最大化对数似然（不计加法常数）与 $-n_s \\log(\\mathrm{SSE}_s / n_s)$ 成正比。\n\n问题指定了将数据划分为 $K$ 个片段 $S_1, \\dots, S_K$ 的成本，作为分段成本之和加上每个片段的惩罚。惩罚项与 $\\log(N)$ 成正比，其中 $N$ 是数据点的总数。我们定义片段 $s$ 的成本为：\n$$\n\\text{Cost}(s) = n_s \\log\\left(\\frac{\\mathrm{SSE}_s}{n_s}\\right) + \\log(N)\n$$\n一个分区 $\\mathcal{P} = \\{S_1, \\dots, S_K\\}$ 的总成本是各个片段成本之和：\n$$\n\\text{TotalCost}(\\mathcal{P}) = \\sum_{s=1}^{K} \\text{Cost}(S_s) = \\sum_{s=1}^{K} \\left[ n_s \\log\\left(\\frac{\\mathrm{SSE}_s}{n_s}\\right) + \\log(N) \\right]\n$$\n最小化此总成本可得出最优分割。\n\n#### 1.3. 用于分割的动态规划\n\n这个最小化问题具有最优子结构和重叠子问题，使其适合使用动态规划 (DP)。令 $C[i]$ 为分割长度为 $i$ 的数据前缀，即 $\\{y_0, \\dots, y_{i-1}\\}$ 的最小成本。DP 递推关系为：\n$$\nC[i] = \\min_{0 \\le j  i} \\{ C[j] + \\text{Cost}(\\text{从 } j \\text{ 到 } i-1 \\text{ 的片段}) \\}\n$$\n我们引入最小片段长度约束，$m = \\max(3, \\lfloor 0.05 N \\rfloor)$。从索引 $j$ 到 $i-1$ 的片段长度为 $n=i-j$，该长度必须至少为 $m$。这将对 $j$ 的搜索范围限制在 $0 \\le j \\le i-m$。\n递推关系变为：\n$$\nC[i] = \\min_{0 \\le j \\le i-m} \\left\\{ C[j] + (i-j) \\log\\left(\\frac{\\mathrm{SSE}(j, i-1)}{i-j}\\right) + \\log(N) \\right\\}\n$$\n基础情况为 $C[0] = 0$。DP 表 $C$ 初始化为 $C[i]=\\infty$ (对于 $i0$)。\n为了重构最优分区，我们存储回溯指针 $B[i]$，该指针记录了为每个 $i$ 最小化成本的索引 $j$。\n\n为了高效计算 $\\mathrm{SSE}(j, i-1)$，我们使用前缀和。令 $P_1[i] = \\sum_{k=0}^{i-1} y_k$ 且 $P_2[i] = \\sum_{k=0}^{i-1} y_k^2$。那么，对于从 $j$ 到 $i-1$ 的片段：\n$$\n\\sum_{k=j}^{i-1} y_k = P_1[i] - P_1[j] \\quad \\text{以及} \\quad \\sum_{k=j}^{i-1} y_k^2 = P_2[i] - P_2[j]\n$$\n残差平方和为 $\\mathrm{SSE}(j, i-1) = (\\sum y_k^2) - \\frac{(\\sum y_k)^2}{n}$，现在可以在 $O(1)$ 时间内计算。DP 算法的总体复杂度为 $O(N^2)$。\n\n#### 1.4. 使用 GLR 检验进行断点验证\n\n使用 DP 确定最优断点集后，使用广义似然比 (GLR) 检验对每个断点进行验证。这确认了每次分裂相比于单片段模型，在拟合优度上都有统计学上的显著改善。对于每个检测到的、分隔两个相邻片段 $S_1$ 和 $S_2$ 的断点，我们考虑合并区域 $R = S_1 \\cup S_2$。我们比较区域 $R$ 中数据的两个模型：一个单均值模型和一个双均值模型（均值分别为 $S_1$ 和 $S_2$ 的均值）。\n\nGLR 统计量 $T$ 是单均值模型和双均值模型之间负两倍最大化对数似然项的差值：\n$$\nT = n \\log\\left(\\frac{\\mathrm{SSE}_\\mathrm{one}}{n}\\right) - \\left[ n_1 \\log\\left(\\frac{\\mathrm{SSE}_1}{n_1}\\right) + n_2 \\log\\left(\\frac{\\mathrm{SSE}_2}{n_2}\\right) \\right]\n$$\n其中 $n=n_1+n_2$ 是 $R$ 的长度，$\\mathrm{SSE}_\\mathrm{one}$、$\\mathrm{SSE}_1$、$\\mathrm{SSE}_2$ 分别是合并区域、片段 $S_1$ 和片段 $S_2$ 的残差平方和。如果成本的减少量 $T$ 超过了增加一个断点的 BIC 惩罚 $\\log(N)$，则该断点被认为是有效的。因此，接受标准为 $T  \\log(N)$。\n\n#### 1.5. 肿瘤比例和拷贝数推断\n\n给定分割和每个片段 $s$ 的平均 log-ratio $\\hat{\\mu}_s$，我们推断一个单一的全局肿瘤比例 $f$ 和每个片段的整数拷贝数 $C_{\\mathrm{t},s}$。这是通过最小化观测到的片段均值与理论均值 $r(C_{\\mathrm{t},s}, f)$ 之间的总加权平方误差来完成的：\n$$\n\\underset{f, \\{C_{\\mathrm{t},s}\\}}{\\text{minimize}} \\sum_s n_s \\left( \\hat{\\mu}_s - r(C_{\\mathrm{t},s}, f) \\right)^2\n$$\n优化是通过在 $f \\in [0.0, 0.99]$ 上以 $0.01$ 为步长进行网格搜索来执行的。对于每个候选 $f$，我们为每个片段独立地找到最优的整数拷贝数 $C_{\\mathrm{t},s} \\in \\{0, 1, \\dots, 6\\}$：\n$$\nC_{\\mathrm{t},s}^*(f) = \\arg\\min_{C \\in \\{0, \\dots, 6\\}} (\\hat{\\mu}_s - r(C, f))^2\n$$\n给定 $f$ 的总误差为 $W(f) = \\sum_s n_s (\\hat{\\mu}_s - r(C_{\\mathrm{t},s}^*(f), f))^2$。估计的肿瘤比例 $f_{\\mathrm{est}}$ 是最小化 $W(f)$ 的 $f$ 值。最终推断的拷贝数是 $\\{C_{\\mathrm{t},s}^*(f_{\\mathrm{est}})\\}.\n\n如果所有推断的拷贝数都是 $2$，则肿瘤比例是不可识别的，因为对于所有 $f$，$r(2, f)=0$。在这种情况下，我们按照惯例报告 $f_{\\mathrm{est}}=0.0$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the full pipeline for all test cases.\n    \"\"\"\n    test_cases = [\n        # (N, seg_lengths, Cts_true, f_true, seed)\n        (120, [40, 40, 40], [3, 2, 1], 0.3, 123),\n        (100, [60, 40], [4, 2], 0.05, 456),\n        (80, [80], [2], 0.4, 789),\n        (150, [50, 50, 50], [1, 4, 2], 0.6, 2468),\n    ]\n    sigma = 0.02\n    \n    results = []\n    for params in test_cases:\n        N, seg_lengths, Cts_true, f_true, seed = params\n        result = _solve_single_case(N, seg_lengths, Cts_true, f_true, sigma, seed)\n        results.append(result)\n\n    result_strings = []\n    for f_est, Cts_est, bps, is_valid in results:\n        f_str = f\"{f_est:.3f}\"\n        Cts_str = \"[\" + \",\".join(map(str, Cts_est)) + \"]\"\n        bps_str = \"[\" + \",\".join(map(str, bps)) + \"]\"\n        valid_str = str(is_valid)\n        result_strings.append(f\"[{f_str},{Cts_str},{bps_str},{valid_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\ndef _r_func(Ct, f):\n    \"\"\"\n    Calculates the expected log2 coverage ratio r(Ct, f).\n    \"\"\"\n    # handle Ct=0, f>0 case where argument of log2 can be = 0\n    arg = (f * Ct + (1. - f) * 2.) / 2.\n    if arg = 0:\n        return -np.inf\n    return np.log2(arg)\n\ndef _generate_data(N, seg_lengths, Cts, f, sigma, seed):\n    \"\"\"\n    Generates synthetic ctDNA data for a test case.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    data = np.zeros(N)\n    start_idx = 0\n    for i, length in enumerate(seg_lengths):\n        end_idx = start_idx + length\n        logr_val = _r_func(Cts[i], f)\n        data[start_idx:end_idx] = logr_val\n        start_idx = end_idx\n    \n    noise = rng.normal(0, sigma, N)\n    data += noise\n    return data\n\ndef _solve_single_case(N, seg_lengths, Cts_true, f_true, sigma, seed):\n    \"\"\"\n    Executes the segmentation and inference pipeline for one test case.\n    \"\"\"\n    # 1. Generate synthetic data\n    data = _generate_data(N, seg_lengths, Cts_true, f_true, sigma, seed)\n    \n    # 2. Segmentation using Dynamic Programming\n    min_len = max(3, int(0.05 * N))\n    penalty = np.log(N)\n    \n    # Prefix sums for O(1) SSE calculation\n    sum1 = np.cumsum(np.concatenate(([0], data)))\n    sum2 = np.cumsum(np.concatenate(([0], data**2)))\n\n    def get_log_likelihood_term(j, i):\n        n = i - j\n        if n == 0: return np.inf\n        s1 = sum1[i] - sum1[j]\n        s2 = sum2[i] - sum2[j]\n        sse = s2 - (s1**2) / n\n        if sse = 1e-12: # Handles near-zero SSE for robustness\n             return -np.inf # Perfect fit, very low cost\n        return n * np.log(sse / n)\n\n    # DP state: dp_costs[i] = min cost to segment data[0...i-1]\n    dp_costs = np.full(N + 1, np.inf)\n    dp_pointers = np.zeros(N + 1, dtype=int)\n    dp_costs[0] = 0\n\n    for i in range(1, N + 1):\n        for j in range(i - min_len + 1):\n            if i - j  min_len:\n                continue\n            \n            log_L_term = get_log_likelihood_term(j, i)\n            cost = dp_costs[j] + log_L_term + penalty\n            \n            if cost  dp_costs[i]:\n                dp_costs[i] = cost\n                dp_pointers[i] = j\n\n    # Backtrack to find breakpoints\n    breakpoints = []\n    curr = N\n    while curr > 0:\n        prev = dp_pointers[curr]\n        if prev > 0:\n            breakpoints.append(prev - 1)\n        curr = prev\n    breakpoints.reverse()\n\n    # Create segments based on breakpoints\n    segment_indices = []\n    start = 0\n    for bp in breakpoints:\n        segment_indices.append((start, bp + 1))\n        start = bp + 1\n    segment_indices.append((start, N))\n    \n    segment_means = [np.mean(data[start:end]) for start, end in segment_indices]\n    segment_lengths = [end - start for start, end in segment_indices]\n\n    # 3. Breakpoint Validation using GLR\n    is_valid = True\n    if len(breakpoints) > 0:\n        all_bps_valid = []\n        seg_start = 0\n        for i in range(len(breakpoints)):\n            bp = breakpoints[i]\n            # Segments around the current breakpoint\n            end1 = bp + 1\n            start2 = bp + 1\n            end2 = breakpoints[i+1] + 1 if i + 1  len(breakpoints) else N\n            \n            n1 = end1 - seg_start\n            n2 = end2 - start2\n            \n            logL1 = get_log_likelihood_term(seg_start, end1)\n            logL2 = get_log_likelihood_term(start2, end2)\n            logL_comb = get_log_likelihood_term(seg_start, end2)\n\n            T = logL_comb - (logL1 + logL2)\n            \n            if T > penalty:\n                all_bps_valid.append(True)\n            else:\n                all_bps_valid.append(False)\n            \n            seg_start = start2\n            \n        is_valid = all(all_bps_valid)\n\n    # 4. Infer tumor fraction f and copy number states Ct\n    possible_Cts = np.arange(7)\n    f_grid = np.linspace(0.0, 0.99, 100)\n    \n    best_f = -1.0\n    min_total_error = np.inf\n    best_Cts = []\n\n    for f_cand in f_grid:\n        current_total_error = 0\n        current_Cts = []\n        r_vals = np.array([_r_func(ct, f_cand) for ct in possible_Cts])\n        for i, seg_mean in enumerate(segment_means):\n            n_s = segment_lengths[i]\n            errors = (seg_mean - r_vals)**2\n            best_Ct_idx = np.argmin(errors)\n            best_Ct = possible_Cts[best_Ct_idx]\n            min_error = errors[best_Ct_idx]\n            \n            current_total_error += n_s * min_error\n            current_Cts.append(best_Ct)\n        \n        if current_total_error  min_total_error:\n            min_total_error = current_total_error\n            best_f = f_cand\n            best_Cts = current_Cts\n\n    # Special case for non-identifiability\n    if all(ct == 2 for ct in best_Cts):\n        best_f = 0.0\n\n    return [best_f, best_Cts, breakpoints, is_valid]\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}