{
    "hands_on_practices": [
        {
            "introduction": "此练习介绍系统动力学中的一项基本任务：校准分子钟。通过完成这个练习，您将应用贝叶斯原理，从带有时间戳的序列中估计病毒的替换速率。这个实践展示了共轭先验的强大功能，说明了伽马先验分布如何与泊松似然函数结合，从而为速率参数生成一个简洁的、解析形式的后验分布。",
            "id": "4542077",
            "problem": "一个实验室正在为一个快速演化的RNA病毒校准严格分子钟，以支持下游的医学分析。从一次特征明确、起源时间已知并设为 $t=0$ 的爆发中，采样了 $n$ 个具有采样时间信息的叶末端序列，并构建了一个长度为 $L$ 个位点的序列比对。对于在时间 $t_i$（自 $t=0$ 以来的年数）采集的每个叶末端 $i \\in \\{1,\\dots,n\\}$，推断出了一个具有已知根的最大似然系统发育树，并将沿着从根到叶末端路径上映射的替换数记录为 $K_i$。假设严格分子钟、位点独立，并且沿着每个从根到叶末端的路径，替换过程是一个时间同质的泊松过程，其速率为 $\\mu$ 替换/位点/年，因此在给定 $\\mu$ 的条件下，计数 $K_i$ 服从一个均值为 $\\mu L t_i$ 的泊松随机变量分布。假设在给定 $\\mu$ 的条件下，$K_i$ 是条件独立的。为了完成贝叶斯校准，为替换率 $\\mu$ 设置一个伽马先验（形状-速率参数化）：$\\mu \\sim \\mathrm{Gamma}(a_0,b_0)$。\n\n仅使用贝叶斯定理和这些模型假设，推导 $\\mu$ 的后验分布，并确定在平方误差损失下的贝叶斯估计量（后验均值）。然后为以下数据集计算其数值：\n- $n=5$ 个叶末端，序列比对长度 $L=10000$ 个位点；\n- 采样时间（自 $t=0$ 以来的年数）：$(t_1,t_2,t_3,t_4,t_5) = (0.8, 1.6, 2.7, 3.9, 5.2)$；\n- 从根到叶末端的替换计数：$(K_1,K_2,K_3,K_4,K_5) = (8, 20, 28, 39, 53)$；\n- 先验超参数：$(a_0,b_0) = (2,2000)$。\n\n将您计算出的替换率的最终数值答案四舍五入到四位有效数字，并以“替换数/位点/年”为单位表示。最终答案必须是一个实数。",
            "solution": "该问题要求推导替换率 $\\mu$ 的后验分布，并计算其后验均值，该均值可作为平方误差损失下的贝叶斯估计量。我们从贝叶斯定理开始，该定理指出后验分布与似然函数和先验分布的乘积成正比：\n$$ P(\\mu | \\mathcal{D}) \\propto P(\\mathcal{D} | \\mu) P(\\mu) $$\n其中 $\\mathcal{D} = \\{K_1, \\dots, K_n\\}$ 代表观测数据，具体来说是替换计数。\n\n似然函数 $P(\\mathcal{D} | \\mu)$ 是根据问题的假设构建的。鉴于每个替换计数 $K_i$ 都是从均值为 $\\lambda_i = \\mu L t_i$ 的独立泊松分布中抽取的，总似然是各个泊松概率质量函数的乘积：\n$$ P(\\mathcal{D} | \\mu) = \\prod_{i=1}^{n} P(K_i | \\mu) = \\prod_{i=1}^{n} \\frac{(\\mu L t_i)^{K_i} \\exp(-\\mu L t_i)}{K_i!} $$\n\n$\\mu$ 的先验分布是形状参数为 $a_0$、速率参数为 $b_0$ 的伽马分布。其概率密度函数为：\n$$ P(\\mu) = \\mathrm{Gamma}(\\mu | a_0, b_0) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n\n为了求得后验分布 $P(\\mu | \\mathcal{D})$，我们将似然函数与先验分布结合起来。我们可以忽略任何不依赖于 $\\mu$ 的项，因为它们将被并入后验分布的归一化常数中。\n$$ P(\\mu | \\mathcal{D}) \\propto \\left( \\prod_{i=1}^{n} (\\mu L t_i)^{K_i} \\exp(-\\mu L t_i) \\right) \\left( \\mu^{a_0-1} \\exp(-b_0 \\mu) \\right) $$\n我们展开此表达式，并将涉及 $\\mu$ 的项组合在一起：\n$$ P(\\mu | \\mathcal{D}) \\propto \\left( \\prod_{i=1}^{n} \\mu^{K_i} \\right) \\left( \\prod_{i=1}^{n} \\exp(-\\mu L t_i) \\right) \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n$$ P(\\mu | \\mathcal{D}) \\propto \\mu^{\\sum_{i=1}^{n} K_i} \\exp\\left(-\\mu L \\sum_{i=1}^{n} t_i\\right) \\mu^{a_0-1} \\exp(-b_0 \\mu) $$\n结合 $\\mu$ 的指数和指数函数的参数，得到后验分布的核：\n$$ P(\\mu | \\mathcal{D}) \\propto \\mu^{(a_0 + \\sum_{i=1}^{n} K_i) - 1} \\exp\\left( - \\mu \\left(b_0 + L \\sum_{i=1}^{n} t_i\\right) \\right) $$\n\n这个表达式是伽马分布的核。这表明伽马分布是泊松似然的速率参数的共轭先验。因此，$\\mu$ 的后验分布也是一个伽马分布，$\\mu | \\mathcal{D} \\sim \\mathrm{Gamma}(a_n, b_n)$，其更新后的参数如下：\n$$ a_n = a_0 + \\sum_{i=1}^{n} K_i $$\n$$ b_n = b_0 + L \\sum_{i=1}^{n} t_i $$\n\n在平方误差损失下，$\\mu$ 的贝叶斯估计量是后验分布的均值。对于一个形状-速率参数化的伽马分布 $\\mathrm{Gamma}(a, b)$，其均值由参数之比 $\\frac{a}{b}$ 给出。因此，估计量 $\\hat{\\mu}_{\\text{Bayes}}$ 为：\n$$ \\hat{\\mu}_{\\text{Bayes}} = E[\\mu | \\mathcal{D}] = \\frac{a_n}{b_n} = \\frac{a_0 + \\sum_{i=1}^{n} K_i}{b_0 + L \\sum_{i=1}^{n} t_i} $$\n\n现在我们代入问题陈述中提供的数值。数据集包括序列比对长度 $L=10000$ 个位点， $n=5$ 个叶末端，其采样时间为 $(t_1,t_2,t_3,t_4,t_5) = (0.8, 1.6, 2.7, 3.9, 5.2)$ 年，从根到叶末端的替换计数为 $(K_1,K_2,K_3,K_4,K_5) = (8, 20, 28, 39, 53)$。先验超参数为 $(a_0,b_0) = (2,2000)$。\n\n首先，我们计算替换计数之和与采样时间之和：\n$$ \\sum_{i=1}^{5} K_i = 8 + 20 + 28 + 39 + 53 = 148 $$\n$$ \\sum_{i=1}^{5} t_i = 0.8 + 1.6 + 2.7 + 3.9 + 5.2 = 14.2 $$\n\n接下来，我们计算后验参数 $a_n$ 和 $b_n$：\n$$ a_n = a_0 + \\sum_{i=1}^{5} K_i = 2 + 148 = 150 $$\n$$ b_n = b_0 + L \\sum_{i=1}^{5} t_i = 2000 + 10000 \\times 14.2 = 2000 + 142000 = 144000 $$\n\n最后，我们计算后验均值，即 $\\mu$ 的贝叶斯估计量：\n$$ \\hat{\\mu}_{\\text{Bayes}} = \\frac{a_n}{b_n} = \\frac{150}{144000} = \\frac{1}{960} \\approx 0.001041666... $$\n\n问题要求将结果四舍五入到四位有效数字。数值为 $1.041666... \\times 10^{-3}$。四舍五入到四位有效数字得到 $1.042 \\times 10^{-3}$ 替换/位点/年。",
            "answer": "$$\\boxed{1.042 \\times 10^{-3}}$$"
        },
        {
            "introduction": "在参数估计的基础上，此练习深入探讨了系统发育学的核心问题——模型选择，特别是如何比较相互竞争的进化树拓扑结构。您将使用单核苷酸多态性（SNP）数据，计算贝叶斯因子来权衡支持一种树结构的证据相对于另一种树结构的证据。关键的是，这个练习还引入了一个现实中的复杂问题：确认偏误（ascertainment bias），这要求您使用经过校正的似然函数来确保您的推断是稳健的。",
            "id": "4542022",
            "problem": "一个研究团队正在对三个分类单元 $\\{A,B,C\\}$ 的双等位基因状态的单核苷酸多态性 (SNP) 数据进行贝叶斯系统发育推断。抽样方案仅包括在这三个分类单元中具有变异的位点（即，在发现阶段排除了所有在样本中不变的位点）。为了明确地考虑这种抽样偏差，他们使用了一种抽样校正似然，该似然以观察到变异位点为条件。假设采用以下模型选择，团队将其视为推断的基础：\n\n- 跨位点的序列演化遵循有根三分类单元树上的 Cavender–Farris–Neyman (CFN) 模型（双状态对称连续时间马尔可夫链），各位点独立同分布，且稳态碱基频率为 $P(0)=P(1)=\\tfrac{1}{2}$。\n- 沿某条边 $e$，状态改变的概率记为 $s_{e} \\in [0, \\tfrac{1}{2}]$，无改变的概率为 $1 - s_{e}$。不同边的演化是独立的。\n- 拓扑结构 $\\mathcal{T}_{1}$ 的有根模型树为 $((A,B),C)$，其中通向 $A$ 的分支、通向 $B$ 的分支和通向 $C$ 的分支的改变概率均为 $s$，而 $\\{A,B\\}$ 祖先与 $C$ 之间的内部枝的改变概率为 $r$。备选拓扑结构 $\\mathcal{T}_{2}$ 为 $((A,C),B)$，其相应的悬垂枝和内部枝也具有相同的边特异性改变概率。\n- 每个位点的抽样校正（Lewis 型）似然是普通位点似然除以模型下该位点为变异位点的概率，从而使推断在变异性的条件下进行。\n\n从 $N$ 个变异的 SNP 中，团队统计了简约信息模式的计数，其中 $n_{AB|C}$ 表示 $A$ 和 $B$ 状态相同但与 $C$ 不同的变异位点数（合并了两种互补的分配情况），$n_{AC|B}$ 和 $n_{BC|A}$ 的定义类似。他们观察到\n$$\nn_{AB|C} = 120,\\quad n_{AC|B} = 80,\\quad n_{BC|A} = 100.\n$$\n假设对于两种拓扑结构，每个悬垂枝的 $s = 0.1$，内部枝的 $r = 0.05$。将位点视为独立的，并对两种拓扑结构采用相等的先验概率。\n\n仅使用上述基本定义和基础概率，推导在 CFN 模型下每种拓扑结构的抽样校正模式概率，并计算支持 $\\mathcal{T}_{1}$ 相对于 $\\mathcal{T}_{2}$ 的贝叶斯因子（边际似然之比，此处由于先验相等且分支改变概率固定，该值等于抽样校正似然之比）。将最终的贝叶斯因子四舍五入至四位有效数字。最终答案必须是一个无单位的实数。",
            "solution": "本问题的目标是计算支持拓扑结构 $\\mathcal{T}_1 = ((A,B),C)$ 相对于 $\\mathcal{T}_2 = ((A,C),B)$ 的贝叶斯因子 $BF_{12}$。贝叶斯因子定义为边际似然之比：\n$$ BF_{12} = \\frac{P(D|\\mathcal{T}_1)}{P(D|\\mathcal{T}_2)} $$\n由于拓扑结构的先验概率相等 ($P(\\mathcal{T}_1) = P(\\mathcal{T}_2)$) 且模型参数（$s$ 和 $r$）被固定，该比值等于在给定参数下的似然之比。数据 $D$ 是三种变异位点模式的计数 $\\{n_{AB|C}, n_{AC|B}, n_{BC|A}\\}$。\n\n数据仅包含变异位点，因此我们需要使用抽样校正的似然。对于一个给定的拓扑结构 $\\mathcal{T}$，观察到特定模式计数的似然是基于多项分布的，其概率为在位点变异条件下观察到每种模式的概率 $\\pi(\\text{pattern}|\\mathcal{T}, \\text{var})$。\n$$ L(D|\\mathcal{T}) \\propto \\pi(AB|C|\\mathcal{T}, \\text{var})^{n_{AB|C}} \\cdot \\pi(AC|B|\\mathcal{T}, \\text{var})^{n_{AC|B}} \\cdot \\pi(BC|A|\\mathcal{T}, \\text{var})^{n_{BC|A}} $$\n其中，抽样校正概率由下式给出：\n$$ \\pi(\\text{pattern}|\\mathcal{T}, \\text{var}) = \\frac{P(\\text{pattern}|\\mathcal{T})}{P(\\text{var}|\\mathcal{T})} $$\n这里 $P(\\text{pattern}|\\mathcal{T})$ 是未校正的模式概率，$P(\\text{var}|\\mathcal{T})$ 是在该模型下，一个位点是变异位点的总概率。\n\n**1. 推导模式概率**\n\n对于 CFN 模型和三分类单元树，存在两种类型的简约信息模式：与拓扑结构一致的（congruent）和不一致的（incongruent）。\n对于拓扑结构 $\\mathcal{T}_1 = ((A,B),C)$：\n-   一致模式是 $AB|C$。其（未校正）概率 $p_{cong}$ 为 $p_{cong} = s(1-s) + r(1-2s)^2$。\n-   不一致模式是 $AC|B$ 和 $BC|A$。它们的概率 $p_{incong}$ 相同，为 $p_{incong} = s(1-s)$。\n\n一个位点为变异位点的总概率是所有变异模式概率的总和：\n$$ P(\\text{var}|\\mathcal{T}_1) = p_{cong} + 2p_{incong} = [s(1-s) + r(1-2s)^2] + 2[s(1-s)] = 3s(1-s) + r(1-2s)^2 $$\n\n因此，对于 $\\mathcal{T}_1$，抽样校正的模式概率为：\n-   $\\pi(AB|C|\\mathcal{T}_1, \\text{var}) = \\frac{p_{cong}}{P(\\text{var}|\\mathcal{T}_1)}$\n-   $\\pi(AC|B|\\mathcal{T}_1, \\text{var}) = \\frac{p_{incong}}{P(\\text{var}|\\mathcal{T}_1)}$\n-   $\\pi(BC|A|\\mathcal{T}_1, \\text{var}) = \\frac{p_{incong}}{P(\\text{var}|\\mathcal{T}_1)}$\n\n对于拓扑结构 $\\mathcal{T}_2 = ((A,C),B)$，分类单元 $B$ 和 $C$ 的角色互换。因此：\n-   一致模式是 $AC|B$。其概率为 $p_{cong}$。\n-   不一致模式是 $AB|C$ 和 $BC|A$。它们的概率为 $p_{incong}$。\n由于参数 $s$ 和 $r$ 相同，变异位点的总概率 $P(\\text{var}|\\mathcal{T}_2)$ 与 $P(\\text{var}|\\mathcal{T}_1)$ 相同。\n\n**2. 计算贝叶斯因子**\n\n$\\mathcal{T}_1$ 的似然函数与以下表达式成正比：\n$$ L(D|\\mathcal{T}_1) \\propto \\left(\\frac{p_{cong}}{P(\\text{var})}\\right)^{n_{AB|C}} \\left(\\frac{p_{incong}}{P(\\text{var})}\\right)^{n_{AC|B}} \\left(\\frac{p_{incong}}{P(\\text{var})}\\right)^{n_{BC|A}} $$\n$\\mathcal{T}_2$ 的似然函数与以下表达式成正比：\n$$ L(D|\\mathcal{T}_2) \\propto \\left(\\frac{p_{incong}}{P(\\text{var})}\\right)^{n_{AB|C}} \\left(\\frac{p_{cong}}{P(\\text{var})}\\right)^{n_{AC|B}} \\left(\\frac{p_{incong}}{P(\\text{var})}\\right)^{n_{BC|A}} $$\n贝叶斯因子是这两个似然的比值。分母中的 $P(\\text{var})$ 项和 $n_{BC|A}$ 项会抵消：\n$$ BF_{12} = \\frac{L(D|\\mathcal{T}_1)}{L(D|\\mathcal{T}_2)} = \\frac{(p_{cong})^{n_{AB|C}} (p_{incong})^{n_{AC|B}}}{(p_{incong})^{n_{AB|C}} (p_{cong})^{n_{AC|B}}} = \\left(\\frac{p_{cong}}{p_{incong}}\\right)^{n_{AB|C} - n_{AC|B}} $$\n\n**3. 数值计算**\n\n我们代入给定的参数值 $s=0.1$ 和 $r=0.05$ 来计算 $p_{cong}$ 和 $p_{incong}$ 的比值：\n$$ \\frac{p_{cong}}{p_{incong}} = \\frac{s(1-s) + r(1-2s)^2}{s(1-s)} = 1 + \\frac{r(1-2s)^2}{s(1-s)} $$\n$$ \\frac{p_{cong}}{p_{incong}} = 1 + \\frac{0.05 \\cdot (1 - 2 \\cdot 0.1)^2}{0.1 \\cdot (1 - 0.1)} = 1 + \\frac{0.05 \\cdot (0.8)^2}{0.1 \\cdot 0.9} = 1 + \\frac{0.05 \\cdot 0.64}{0.09} = 1 + \\frac{0.032}{0.09} = 1 + \\frac{32}{90} = \\frac{122}{90} = \\frac{61}{45} $$\n我们已知 $n_{AB|C} = 120$ 和 $n_{AC|B} = 80$，所以指数为 $120 - 80 = 40$。\n现在计算贝叶斯因子：\n$$ BF_{12} = \\left(\\frac{61}{45}\\right)^{40} \\approx (1.3555...)^{40} \\approx 192618.39 $$\n四舍五入到四位有效数字，结果是 $1.926 \\times 10^5$。",
            "answer": "$$\\boxed{1.926 \\times 10^5}$$"
        },
        {
            "introduction": "最后的这个练习是一个综合性项目，您将从解析解转向计算实现，从零开始构建一个微型贝叶斯系统发育推断引擎。您将实现Felsenstein剪枝算法来计算树的似然值，然后使用数值积分对所有可能的枝长进行边缘化。这个练习能让您深入、实践地理解驱动现代系统发育软件的计算机制。",
            "id": "4542079",
            "problem": "构建一个完整、可运行的程序，该程序在给定四个分类单元（标记为 $A$、$B$、$C$ 和 $D$）的固定脱氧核糖核酸（DNA）比对的情况下，通过在系统发育学中应用贝叶斯推断，计算无根分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率。计算过程需使用指定的先验对分支长度进行边缘化，并采用 Jukes–Cantor 1969 (JC69) 替换模型。目标受众为高阶研究生水平，任务是应用贝叶斯推断、连续参数边缘化以及通过 Felsenstein 剪枝算法计算似然度的第一性原理。\n\n必须以下列经过充分检验的事实和定义为基础：\n- 贝叶斯定理：对于离散拓扑结构 $T$ 和带有先验 $p(\\mathbf{t} \\mid T)$ 的连续分支长度向量 $\\mathbf{t}$，给定数据 $D$ 的后验 $p(T \\mid D)$ 满足\n$$\np(T \\mid D) \\propto p(T) \\int p(D \\mid T, \\mathbf{t}) \\, p(\\mathbf{t} \\mid T) \\, d\\mathbf{t}.\n$$\n- JC69 模型的时间可逆连续时间马尔可夫过程：对于分支长度 $t \\ge 0$，当速率归一化为 1 时，在时间 $t$ 内从核苷酸 $i$ 到核苷酸 $j$ 的转移概率为\n$$\nP_{ij}(t) = \n\\begin{cases}\n\\frac{1}{4} + \\frac{3}{4} e^{-4t/3},  \\text{if } i = j, \\\\\n\\frac{1}{4} - \\frac{1}{4} e^{-4t/3},  \\text{if } i \\ne j,\n\\end{cases}\n$$\n且平稳分布是均匀的，对于所有 $i$，$\\pi_i = \\frac{1}{4}$。\n- Felsenstein 剪枝算法：对于固定的树 $T$ 和分支长度 $\\mathbf{t}$，似然度 $p(D \\mid T, \\mathbf{t})$ 在位点间独立的假设下可分解，并且可以通过动态规划计算，该算法将条件似然向量从叶节点沿树传播到根节点。\n\n除这些基础之外，不得引入任何捷径公式。仅使用这些原理解释计算内容、其正确性以及如何构建算法。\n\n假设采用以下建模选择，且必须精确实现：\n- 四个分类单元上存在三种可能的无根二叉拓扑结构：$T_1 = \\{A,B\\} \\mid \\{C,D\\}$、$T_2 = \\{A,C\\} \\mid \\{B,D\\}$ 和 $T_3 = \\{A,D\\} \\mid \\{B,C\\}$，其先验为 $p(T_k) = \\frac{1}{3}$，对于 $k \\in \\{1,2,3\\}$。\n- 对于每个拓扑结构 $T$，分支长度为 $\\mathbf{t} = (t_A, t_B, t_{\\text{int}}, t_C, t_D)$，分别对应于每个叶节点的悬挂分支和一个内部分支。分支长度的先验是速率为 $\\lambda$ 的独立指数分布，即\n$$\np(\\mathbf{t}\\mid T) = \\prod_{x \\in \\{A,B,\\text{int},C,D\\}} \\lambda e^{-\\lambda t_x}.\n$$\n- 使用 JC69 模型进行核苷酸替换，其平稳分布为均匀分布 $\\pi_i = \\frac{1}{4}$。\n- 为计算 $p(D \\mid T)$，通过对每个分支在提供的网格 $\\mathcal{G} = \\{g_1, g_2, \\dots, g_m\\}$ 上进行离散求积来近似对 $\\mathbf{t}$ 的积分，形成 $m^5$ 的笛卡尔积。使用与先验密度成比例的权重，即近似为\n$$\n\\int p(D \\mid T, \\mathbf{t}) p(\\mathbf{t} \\mid T) \\, d\\mathbf{t} \\approx \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} p(D \\mid T, \\mathbf{t}) \\, e^{-\\lambda \\sum_x t_x},\n$$\n其中，在最终的后验归一化中，所有拓扑结构中保持不变的常数因子会抵消。以数值稳定的方式执行所有求和运算。\n\n通过在与指定分裂兼容的一个内部节点上将树定根，并应用 Felsenstein 剪枝算法来定义位点似然：\n- 对于 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$，在连接 $A$、$B$ 以及到节点 $R$ 的内部分支的内部节点上定根；节点 $R$ 连接到 $C$ 和 $D$。分支长度 $(t_A, t_B, t_{\\text{int}}, t_C, t_D)$ 分别对应边 $(A, B, \\text{内部分支}, C, D)$。\n- 对于 $T_2 = \\{A,C\\} \\mid \\{B,D\\}$，在连接 $A$、$C$ 以及到节点 $R$ 的内部分支的内部节点上定根；节点 $R$ 连接到 $B$ 和 $D$。\n- 对于 $T_3 = \\{A,D\\} \\mid \\{B,C\\}$，在连接 $A$、$D$ 以及到节点 $R$ 的内部分支的内部节点上定根；节点 $R$ 连接到 $B$ 和 $C$。\n\n在一个观测到核苷酸 $b \\in \\{A,C,G,T\\}$ 且分支长度为 $t$ 的叶节点上，其指向父节点的条件似然向量（以父节点核苷酸 $i$ 为索引）是 $P_{i b}(t)$。在一个内部节点 $R$ 上，若其对于核苷酸 $k$ 有两个子信息 $M^{(1)}(k)$ 和 $M^{(2)}(k)$，则该节点的似然向量为 $L_R(k) = M^{(1)}(k) M^{(2)}(k)$，而沿着长度为 $t_{\\text{int}}$ 的分支向其父节点传递的信息为 $M_R(i) = \\sum_{k} P_{i k}(t_{\\text{int}}) L_R(k)$。在根节点处，位点似然为 $\\sum_i \\pi_i \\prod_{\\text{incident edges}} M_{\\text{edge}}(i)$。\n\n您的程序必须实现以上内容，并针对一组给定的测试用例，报告分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率 $p(T_1 \\mid D)$。\n\n测试套件：\n对于每个测试用例，您将获得分类单元 $A$、$B$、$C$ 和 $D$ 的 DNA 序列、指数率 $\\lambda$ 以及分支长度网格 $\\mathcal{G}$。\n\n- 测试用例 1（正常路径，强分支信号）：\n  - $A$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $B$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $C$: \"TGCATGCATGCATGCATGCATGCA\"\n  - $D$: \"TGCATGCATGCATGCATGCATGCA\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n- 测试用例 2（近乎模糊的信号）：\n  - $A$: \"ACGTACGTACGTACGTACGTACGT\"\n  - $B$: \"CGTACGTACGTACGTACGTACGTA\"\n  - $C$: \"GTACGTACGTACGTACGTACGTAC\"\n  - $D$: \"TACGTACGTACGTACGTACGTACG\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n- 测试用例 3（边界情况，最少数据）：\n  - $A$: \"A\"\n  - $B$: \"A\"\n  - $C$: \"C\"\n  - $D$: \"C\"\n  - $\\lambda = 2.0$\n  - $\\mathcal{G} = \\{0.02, 0.15, 0.5\\}$\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3]”）。每个结果必须是对应测试用例中分裂 $\\{A,B\\} \\mid \\{C,D\\}$ 的后验概率，表示为小数点后保留 $6$ 位的小数。不得打印任何其他文本。\n\n所有角度在此问题中均不相关。此问题中没有物理单位。不得使用百分比；请将概率表示为小数。",
            "solution": "我们的目标是在给定DNA序列比对数据 $D$ 的情况下，计算无根拓扑结构 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$ 的后验概率 $p(T_1 \\mid D)$。\n\n根据贝叶斯定理，并考虑到三种可能拓扑结构的先验概率相等，拓扑结构 $T_k$ 的后验概率为：\n$$p(T_k \\mid D) = \\frac{p(D \\mid T_k)}{\\sum_{j=1}^{3} p(D \\mid T_j)}$$\n核心任务是为每种拓扑结构 $T_k$ 计算其边际似然 $p(D \\mid T_k)$。\n\n边际似然是通过对所有可能的分支长度 $\\mathbf{t}$ 上的完整似然进行积分得到的，并由其先验概率密度加权：\n$$p(D \\mid T_k) = \\int p(D \\mid T_k, \\mathbf{t}) \\, p(\\mathbf{t} \\mid T_k) \\, d\\mathbf{t}$$\n该积分通过在分支长度网格 $\\mathcal{G}$ 上的离散和来近似。设 $M_k$ 为拓扑结构 $T_k$ 的（未归一化的）边际似然近似值：\n$$M_k \\approx \\sum_{\\mathbf{t} \\in \\mathcal{G}^5} p(D \\mid T_k, \\mathbf{t}) \\, e^{-\\lambda \\sum_{x} t_x}$$\n其中，$\\mathbf{t}$ 是一个包含五个分支长度的向量，每个长度从网格 $\\mathcal{G}$ 中选取。\n\n**算法步骤如下：**\n\n1.  **计算完整似然 $p(D \\mid T_k, \\mathbf{t})$**：\n    假设位点独立进化，整个序列比对的似然是每个位点似然的乘积：\n    $$p(D \\mid T_k, \\mathbf{t}) = \\prod_{s=1}^{N} p(D_s \\mid T_k, \\mathbf{t})$$\n    为避免数值下溢，我们计算其对数：$\\log p(D \\mid T_k, \\mathbf{t}) = \\sum_{s=1}^{N} \\log p(D_s \\mid T_k, \\mathbf{t})$。\n\n2.  **计算位点似然 $p(D_s \\mid T_k, \\mathbf{t})$**：\n    此计算使用Felsenstein剪枝算法。以拓扑结构 $T_1 = \\{A,B\\} \\mid \\{C,D\\}$ 为例，该无根树可被定根于连接 $A,B$ 的内部节点 $U$。\n    a.  **初始化**：对于每个叶节点（例如 $A$），其条件似然向量 $L_A$ 是一个4元素向量，表示在父节点 $U$ 处于各核苷酸状态的条件下，观察到叶节点 $A$ 核苷酸的概率。这对应于JC69转移概率矩阵 $P(t_A)$ 的相应列。\n    b.  **向上剪枝**：在内部节点 $V$（连接 $C,D$），其条件似然向量 $L_V$ 是其子节点 $C$ 和 $D$ 的条件似然向量的逐元素乘积（Hadamard积）。\n    c.  **跨分支传递**：从节点 $V$ 传递到其父节点 $U$ 的信息 $M_V$ 是通过将 $L_V$ 与连接它们的内部分支的转移矩阵 $P(t_{\\text{int}})$ 相乘（矩阵-向量乘法）得到的。\n    d.  **根节点计算**：在根节点 $U$ 处，合并来自其所有子节点（$A$、$B$ 和 $V$）的信息，通过逐元素乘积得到最终的条件似然向量 $L_U$。\n    e.  **最终似然**：通过对根节点的所有可能状态求和，并用平稳分布 $\\pi_i = 1/4$ 加权，得到该位点的总似然。\n\n3.  **计算边际似然 $M_k$**：\n    该计算嵌套在五个循环中，遍历分支长度网格 $\\mathcal{G}^5$ 上的所有组合。对于每一种组合 $\\mathbf{t}$：\n    a.  计算完整对数似然 $\\log p(D \\mid T_k, \\mathbf{t})$。\n    b.  加上对数先验项 $-\\lambda \\sum t_x$。\n    c.  使用log-sum-exp技巧对所有组合的这些对数项求和，以数值稳定的方式得到 $\\log M_k$。\n\n4.  **计算后验概率**：\n    最后，利用已计算出的三种拓扑结构的对数边际似然 $\\log M_1, \\log M_2, \\log M_3$，使用softmax函数计算 $T_1$ 的后验概率，以确保数值稳定性：\n    $$p(T_1 \\mid D) = \\frac{e^{\\log M_1}}{e^{\\log M_1} + e^{\\log M_2} + e^{\\log M_3}}$$",
            "answer": "```python\nimport numpy as np\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the phylogenetic inference problem for the given test cases.\n    \"\"\"\n\n    NUC_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n    \n    def get_jc69_matrix(t):\n        \"\"\"\n        Computes the JC69 transition probability matrix for a given branch length t.\n        P_ij(t) is the probability of changing from nucleotide i to j.\n        \"\"\"\n        if t  0:\n            raise ValueError(\"Branch length t cannot be negative.\")\n        \n        p_diag = 0.25 + 0.75 * np.exp(-4.0 * t / 3.0)\n        p_off_diag = 0.25 - 0.25 * np.exp(-4.0 * t / 3.0)\n        \n        mat = np.full((4, 4), p_off_diag)\n        np.fill_diagonal(mat, p_diag)\n        return mat\n\n    def compute_site_likelihood(site_data, taxa_split, branch_lengths, p_matrices, nuc_map):\n        \"\"\"\n        Computes the likelihood for a single site using Felsenstein's pruning algorithm.\n        \n        Args:\n            site_data (dict): Nucleotides for each taxon at this site, e.g., {'A': 'C', ...}.\n            taxa_split (tuple): The two clades defining the topology, e.g., (('A', 'B'), ('C', 'D')).\n            branch_lengths (tuple): 5 branch lengths for the tree's branches.\n            p_matrices (dict): Precomputed transition matrices for all branch lengths in the grid.\n            nuc_map (dict): Mapping from nucleotide characters to integer indices.\n        \n        Returns:\n            float: The likelihood for the site.\n        \"\"\"\n        taxa_u = taxa_split[0]  # E.g., ('A', 'B')\n        taxa_v = taxa_split[1]  # E.g., ('C', 'D')\n        \n        # This implementation maps the 5 branch lengths to the specific parts of the tree\n        # based on the topology provided by taxa_split.\n        t_map = {\n            taxa_u[0]: branch_lengths[0],\n            taxa_u[1]: branch_lengths[1],\n            taxa_v[0]: branch_lengths[2],\n            taxa_v[1]: branch_lengths[3],\n            'int': branch_lengths[4],\n        }\n\n        # Step 2: Get conditional likelihood vectors from leaves.\n        # L_X is a 4-element vector of Pr(data at leaf X | parent is in state i)\n        L_leaf_u0 = p_matrices[t_map[taxa_u[0]]][:, nuc_map[site_data[taxa_u[0]]]]\n        L_leaf_u1 = p_matrices[t_map[taxa_u[1]]][:, nuc_map[site_data[taxa_u[1]]]]\n        L_leaf_v0 = p_matrices[t_map[taxa_v[0]]][:, nuc_map[site_data[taxa_v[0]]]]\n        L_leaf_v1 = p_matrices[t_map[taxa_v[1]]][:, nuc_map[site_data[taxa_v[1]]]]\n        \n        # Step 3: Compute conditional likelihood at internal node V\n        # L_V(k) = L_C(k) * L_D(k) (Hadamard product)\n        L_V = L_leaf_v0 * L_leaf_v1\n        \n        # Step 4: Pass message from V to U up the internal branch\n        # M_V(i) = sum_k P_ik(t_int) * L_V(k) (Matrix-vector product)\n        P_int = p_matrices[t_map['int']]\n        M_V = P_int @ L_V\n        \n        # Step 5: Compute conditional likelihood at root node U\n        # L_U(i) = L_A(i) * L_B(i) * M_V(i) (Hadamard product)\n        L_U = L_leaf_u0 * L_leaf_u1 * M_V\n        \n        # Step 6: Compute final site likelihood by averaging over root states\n        # The stationary distribution pi is uniform (1/4 for each state).\n        return np.sum(L_U) * 0.25\n\n    def compute_log_marginal_likelihood(sequences, taxa_split, grid, lmbda, nuc_map):\n        \"\"\"\n        Computes the log of the marginal likelihood for a given topology.\n        This involves summing over all combinations of branch lengths from the grid.\n        \"\"\"\n        num_sites = len(sequences['A'])\n        \n        # Precompute all necessary transition matrices\n        p_matrices = {t: get_jc69_matrix(t) for t in grid}\n\n        grid_size = len(grid)\n        num_combinations = grid_size ** 5\n        log_terms = np.zeros(num_combinations)\n\n        # Iterate over all 5-tuples of branch lengths from the grid\n        for i, branch_lengths_perm in enumerate(product(grid, repeat=5)):\n            \n            # The branch length order corresponds to a fixed assignment based on the topology.\n            # For T1=((A,B),(C,D)), the order is (tA, tB, tC, tD, tint).\n            # For T2=((A,C),(B,D)), the order is (tA, tC, tB, tD, tint).\n            # The code maps this correctly via taxa_split.\n            \n            # For this combination of branch lengths, compute total log-likelihood over all sites\n            total_log_likelihood = 0.0\n            for s in range(num_sites):\n                site_data = {taxon: sequences[taxon][s] for taxon in 'ABCD'}\n                site_likelihood = compute_site_likelihood(site_data, taxa_split, branch_lengths_perm, p_matrices, nuc_map)\n                \n                # To prevent log(0) for extremely unlikely sites, add a small epsilon.\n                if site_likelihood > 0:\n                    total_log_likelihood += np.log(site_likelihood)\n                else:\n                    total_log_likelihood += -np.inf # Effectively makes this branch length combo have 0 probability\n\n            # Calculate the log of the prior term (up to a constant)\n            log_prior_term = -lmbda * sum(branch_lengths_perm)\n            \n            # Store the log of the term to be summed: log(P(D|T,t) * P(t|T))\n            log_terms[i] = total_log_likelihood + log_prior_term\n        \n        # Compute log-sum-exp for numerical stability\n        max_log_term = np.max(log_terms)\n        if max_log_term == -np.inf:\n            return -np.inf\n            \n        log_marginal_lik = max_log_term + np.log(np.sum(np.exp(log_terms - max_log_term)))\n        \n        return log_marginal_lik\n\n    test_cases = [\n        {\n            \"sequences\": {\n                'A': \"ACGTACGTACGTACGTACGTACGT\",\n                'B': \"ACGTACGTACGTACGTACGTACGT\",\n                'C': \"TGCATGCATGCATGCATGCATGCA\",\n                'D': \"TGCATGCATGCATGCATGCATGCA\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        },\n        {\n            \"sequences\": {\n                'A': \"ACGTACGTACGTACGTACGTACGT\",\n                'B': \"CGTACGTACGTACGTACGTACGTA\",\n                'C': \"GTACGTACGTACGTACGTACGTAC\",\n                'D': \"TACGTACGTACGTACGTACGTACG\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        },\n        {\n            \"sequences\": {\n                'A': \"A\",\n                'B': \"A\",\n                'C': \"C\",\n                'D': \"C\",\n            },\n            \"lambda\": 2.0,\n            \"grid\": [0.02, 0.15, 0.5]\n        }\n    ]\n\n    results = []\n    \n    # Define the three unrooted topologies\n    topologies = [\n        (('A', 'B'), ('C', 'D')),  # T1\n        (('A', 'C'), ('B', 'D')),  # T2\n        (('A', 'D'), ('B', 'C')),  # T3\n    ]\n\n    for case in test_cases:\n        sequences = case[\"sequences\"]\n        lmbda = case[\"lambda\"]\n        grid = tuple(sorted(case[\"grid\"])) # Ensure consistent order for memoization of P-matrices\n\n        log_marginal_likelihoods = []\n        for taxa_split in topologies:\n            log_ml = compute_log_marginal_likelihood(sequences, taxa_split, grid, lmbda, NUC_MAP)\n            log_marginal_likelihoods.append(log_ml)\n        \n        log_ml_arr = np.array(log_marginal_likelihoods)\n        \n        # Compute posterior probabilities using softmax for numerical stability\n        max_log_ml = np.max(log_ml_arr)\n        \n        if max_log_ml == -np.inf:\n             posteriors = np.full(3, 1.0/3.0)\n        else:\n            exp_terms = np.exp(log_ml_arr - max_log_ml)\n            sum_exp_terms = np.sum(exp_terms)\n            posteriors = exp_terms / sum_exp_terms\n        \n        # Result for T1 = {A,B}|{C,D} is the first one\n        result_t1 = posteriors[0]\n        results.append(f\"{result_t1:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}