{
    "hands_on_practices": [
        {
            "introduction": "邻接法（Neighbor-Joining, NJ）是距离法系统发育推断中的一种基石算法，它通过迭代地合并最近的分类单元来构建树。本练习将引导你手动执行标准的NJ算法，从计算选择标准 $Q$ 矩阵到更新距离矩阵，从而让你亲身体验如何从距离数据中重建无根树的拓扑结构和分支长度。",
            "id": "4593239",
            "problem": "考虑使用基于距离的邻接法（Neighbor Joining, NJ）从一个对称的分类单元间相异性矩阵重建一个无根系统发育树的任务。假设有六个标记为 $A$、$B$、$C$、$D$、$E$ 和 $F$ 的分类单元。输入是一个对称矩阵 $\\{d_{ij}\\}$，其中对于所有 $i,j$ 都有 $d_{ii} = 0$ 和 $d_{ij} = d_{ji}$，其非零元素如下所示：\n- $d_{AB} = 2$， $d_{AC} = 3.5$， $d_{AD} = 5.2$， $d_{AE} = 5.2$， $d_{AF} = 7.5$，\n- $d_{BC} = 3.5$， $d_{BD} = 5.2$， $d_{BE} = 5.2$， $d_{BF} = 7.5$，\n- $d_{CD} = 4.7$， $d_{CE} = 4.7$， $d_{CF} = 7.0$，\n- $d_{DE} = 2$， $d_{DF} = 4.3$， $d_{EF} = 4.3$。\n\n从第一性原理出发，执行标准的邻接法（NJ）更新过程，以：\n1. 在每次迭代中，确定要连接的一对分类单元（或簇）。\n2. 计算到新引入的内部节点的相应分支（枝）长度。\n3. 为下一次迭代更新简化的距离矩阵。\n\n使用以下确定性平局打破规则：当NJ选择标准产生平局时，选择原始分类单元间距离 $d_{ij}$ 最小的一对；如果仍然存在平局，则按照 $A \\prec B \\prec C \\prec D \\prec E \\prec F$ 的顺序选择字典序最早的一对。\n\n执行NJ过程直至完成，得到一个包含六个原始分类单元的无根树。您的任务是计算最终重建的无根树中所有分支长度的总和（即树中所有边的长度之和）。将最终总和表示为一个实数。不需要四舍五入。距离单位是任意的；答案中不要包含任何单位。",
            "solution": "该问题要求使用邻接法（NJ）算法为六个分类单元 $\\{A, B, C, D, E, F\\}$ 重建一个无根系统发育树。输入是一个对称距离矩阵 $d_{ij}$。目标是求出最终树中所有分支长度的总和。\n\n邻接法是一种迭代过程，它不断连接成对的分类单元（或簇），直到只剩下一个分支，该分支代表完整的无根树。该算法的核心是选择标准，即找到使 $Q_{ij}$ 值最小的一对 $(i, j)$，其定义为：\n$$Q_{ij} = (N-2)d_{ij} - r_i - r_j$$\n其中 $N$ 是当前分类单元/簇的数量，$d_{ij}$ 是分类单元 $i$ 和 $j$ 之间的距离，而 $r_i$ 是从分类单元 $i$ 到所有其他分类单元的距离之和：\n$$r_i = \\sum_{k \\in S, k \\neq i} d_{ik}$$\n其中 $S$ 是当前的分类单元集合。\n\n让我们逐步执行该算法。\n\n### 迭代 1: $N=6$\n\n初始分类单元集合为 $S_1 = \\{A, B, C, D, E, F\\}$。给定的距离矩阵 $d$ 为：\n$$\n\\begin{array}{c|cccccc}\n  & A & B & C & D & E & F \\\\\n\\hline\nA & 0 & 2 & 3.5 & 5.2 & 5.2 & 7.5 \\\\\nB & 2 & 0 & 3.5 & 5.2 & 5.2 & 7.5 \\\\\nC & 3.5 & 3.5 & 0 & 4.7 & 4.7 & 7.0 \\\\\nD & 5.2 & 5.2 & 4.7 & 0 & 2 & 4.3 \\\\\nE & 5.2 & 5.2 & 4.7 & 2 & 0 & 4.3 \\\\\nF & 7.5 & 7.5 & 7.0 & 4.3 & 4.3 & 0\n\\end{array}\n$$\n\n首先，我们为每个分类单元计算距离和 $r_i$：\n$r_A = 2 + 3.5 + 5.2 + 5.2 + 7.5 = 23.4$\n$r_B = 2 + 3.5 + 5.2 + 5.2 + 7.5 = 23.4$\n$r_C = 3.5 + 3.5 + 4.7 + 4.7 + 7.0 = 23.4$\n$r_D = 5.2 + 5.2 + 4.7 + 2 + 4.3 = 21.4$\n$r_E = 5.2 + 5.2 + 4.7 + 2 + 4.3 = 21.4$\n$r_F = 7.5 + 7.5 + 7.0 + 4.3 + 4.3 = 30.6$\n\n接下来，我们使用 $Q_{ij} = (6-2)d_{ij} - r_i - r_j = 4d_{ij} - r_i - r_j$ 计算 $Q$ 矩阵：\n$Q_{AB} = 4(2) - (23.4 + 23.4) = 8 - 46.8 = -38.8$\n$Q_{AC} = 4(3.5) - (23.4 + 23.4) = 14 - 46.8 = -32.8$\n$Q_{AD} = 4(5.2) - (23.4 + 21.4) = 20.8 - 44.8 = -24.0$\n$Q_{AE} = 4(5.2) - (23.4 + 21.4) = 20.8 - 44.8 = -24.0$\n$Q_{AF} = 4(7.5) - (23.4 + 30.6) = 30 - 54.0 = -24.0$\n$Q_{BC} = 4(3.5) - (23.4 + 23.4) = 14 - 46.8 = -32.8$\n$Q_{BD} = 4(5.2) - (23.4 + 21.4) = 20.8 - 44.8 = -24.0$\n$Q_{BE} = 4(5.2) - (23.4 + 21.4) = 20.8 - 44.8 = -24.0$\n$Q_{BF} = 4(7.5) - (23.4 + 30.6) = 30 - 54.0 = -24.0$\n$Q_{CD} = 4(4.7) - (23.4 + 21.4) = 18.8 - 44.8 = -26.0$\n$Q_{CE} = 4(4.7) - (23.4 + 21.4) = 18.8 - 44.8 = -26.0$\n$Q_{CF} = 4(7.0) - (23.4 + 30.6) = 28 - 54.0 = -26.0$\n$Q_{DE} = 4(2) - (21.4 + 21.4) = 8 - 42.8 = -34.8$\n$Q_{DF} = 4(4.3) - (21.4 + 30.6) = 17.2 - 52.0 = -34.8$\n$Q_{EF} = 4(4.3) - (21.4 + 30.6) = 17.2 - 52.0 = -34.8$\n\n$Q$ 矩阵中的最小值为 $Q_{AB} = -38.8$。我们将分类单元 $A$ 和 $B$ 连接到一个新节点，我们称之为 $U_1$。\n\n从 $A$ 和 $B$ 到 $U_1$ 的分支长度计算如下：\n$L_{AU_1} = \\frac{1}{2}d_{AB} + \\frac{1}{2(6-2)}(r_A - r_B) = \\frac{1}{2}(2) + \\frac{1}{8}(23.4 - 23.4) = 1.0$\n$L_{BU_1} = \\frac{1}{2}d_{AB} + \\frac{1}{2(6-2)}(r_B - r_A) = \\frac{1}{2}(2) + \\frac{1}{8}(23.4 - 23.4) = 1.0$\n\n我们更新距离矩阵。新的分类单元集合为 $S_2 = \\{U_1, C, D, E, F\\}$。从 $U_1$ 到其他分类单元的距离为：\n$d_{U_1C} = \\frac{1}{2}(d_{AC} + d_{BC} - d_{AB}) = \\frac{1}{2}(3.5 + 3.5 - 2) = 2.5$\n$d_{U_1D} = \\frac{1}{2}(d_{AD} + d_{BD} - d_{AB}) = \\frac{1}{2}(5.2 + 5.2 - 2) = 4.2$\n$d_{U_1E} = \\frac{1}{2}(d_{AE} + d_{BE} - d_{AB}) = \\frac{1}{2}(5.2 + 5.2 - 2) = 4.2$\n$d_{U_1F} = \\frac{1}{2}(d_{AF} + d_{BF} - d_{AB}) = \\frac{1}{2}(7.5 + 7.5 - 2) = 6.5$\n\n### 迭代 2: $N=5$\n\n分类单元集合为 $S_2 = \\{U_1, C, D, E, F\\}$，简化的距离矩阵为：\n$$\n\\begin{array}{c|ccccc}\n  & U_1 & C & D & E & F \\\\\n\\hline\nU_1 & 0 & 2.5 & 4.2 & 4.2 & 6.5 \\\\\nC & 2.5 & 0 & 4.7 & 4.7 & 7.0 \\\\\nD & 4.2 & 4.7 & 0 & 2 & 4.3 \\\\\nE & 4.2 & 4.7 & 2 & 0 & 4.3 \\\\\nF & 6.5 & 7.0 & 4.3 & 4.3 & 0\n\\end{array}\n$$\n\n我们计算新的距离和 $r_i$：\n$r_{U_1} = 2.5 + 4.2 + 4.2 + 6.5 = 17.4$\n$r_C = 2.5 + 4.7 + 4.7 + 7.0 = 18.9$\n$r_D = 4.2 + 4.7 + 2 + 4.3 = 15.2$\n$r_E = 4.2 + 4.7 + 2 + 4.3 = 15.2$\n$r_F = 6.5 + 7.0 + 4.3 + 4.3 = 22.1$\n\n我们计算 $N=5$ 时的 $Q$ 矩阵，即 $Q_{ij} = (5-2)d_{ij} - r_i - r_j = 3d_{ij} - r_i - r_j$：\n$Q_{U_1C} = 3(2.5) - (17.4 + 18.9) = 7.5 - 36.3 = -28.8$\n$Q_{DE} = 3(2) - (15.2 + 15.2) = 6 - 30.4 = -24.4$\n所有其他的 $Q_{ij}$ 值都大于或等于 $-20.0$。最小值为 $Q_{U_1C} = -28.8$。我们将簇 $U_1$ 和分类单元 $C$ 连接到一个新节点 $U_2$。\n\n到 $U_2$ 的分支长度为：\n$L_{U_1U_2} = \\frac{1}{2}d_{U_1C} + \\frac{1}{2(5-2)}(r_{U_1} - r_C) = \\frac{1}{2}(2.5) + \\frac{1}{6}(17.4 - 18.9) = 1.25 - 0.25 = 1.0$\n$L_{CU_2} = \\frac{1}{2}d_{U_1C} + \\frac{1}{2(5-2)}(r_C - r_{U_1}) = \\frac{1}{2}(2.5) + \\frac{1}{6}(18.9 - 17.4) = 1.25 + 0.25 = 1.5$\n\n新的分类单元集合为 $S_3 = \\{U_2, D, E, F\\}$。到 $U_2 = (U_1, C)$ 的距离为：\n$d_{U_2D} = \\frac{1}{2}(d_{U_1D} + d_{CD} - d_{U_1C}) = \\frac{1}{2}(4.2 + 4.7 - 2.5) = 3.2$\n$d_{U_2E} = \\frac{1}{2}(d_{U_1E} + d_{CE} - d_{U_1C}) = \\frac{1}{2}(4.2 + 4.7 - 2.5) = 3.2$\n$d_{U_2F} = \\frac{1}{2}(d_{U_1F} + d_{CF} - d_{U_1C}) = \\frac{1}{2}(6.5 + 7.0 - 2.5) = 5.5$\n\n### 迭代 3: $N=4$\n\n分类单元集合为 $S_3 = \\{U_2, D, E, F\\}$，距离矩阵为：\n$$\n\\begin{array}{c|cccc}\n  & U_2 & D & E & F \\\\\n\\hline\nU_2 & 0 & 3.2 & 3.2 & 5.5 \\\\\nD & 3.2 & 0 & 2 & 4.3 \\\\\nE & 3.2 & 2 & 0 & 4.3 \\\\\nF & 5.5 & 4.3 & 4.3 & 0\n\\end{array}\n$$\n我们计算距离和 $r_i$：\n$r_{U_2} = 3.2 + 3.2 + 5.5 = 11.9$\n$r_D = 3.2 + 2 + 4.3 = 9.5$\n$r_E = 3.2 + 2 + 4.3 = 9.5$\n$r_F = 5.5 + 4.3 + 4.3 = 14.1$\n\n我们计算 $N=4$ 时的 $Q$ 矩阵，即 $Q_{ij} = (4-2)d_{ij} - r_i - r_j = 2d_{ij} - r_i - r_j$：\n$Q_{U_2D} = 2(3.2) - (11.9 + 9.5) = 6.4 - 21.4 = -15.0$\n$Q_{U_2E} = 2(3.2) - (11.9 + 9.5) = 6.4 - 21.4 = -15.0$\n$Q_{U_2F} = 2(5.5) - (11.9 + 14.1) = 11.0 - 26.0 = -15.0$\n$Q_{DE} = 2(2) - (9.5 + 9.5) = 4.0 - 19.0 = -15.0$\n$Q_{DF} = 2(4.3) - (9.5 + 14.1) = 8.6 - 23.6 = -15.0$\n$Q_{EF} = 2(4.3) - (9.5 + 14.1) = 8.6 - 23.6 = -15.0$\n\n所有配对的 $Q$ 值均为 $-15.0$。我们应用平局打破规则：选择原始距离 $d_{ij}$ 最小的一对。这些距离为 $d_{U_2D}=3.2$，$d_{U_2E}=3.2$，$d_{U_2F}=5.5$，$d_{DE}=2$，$d_{DF}=4.3$，$d_{EF}=4.3$。最小距离是 $d_{DE}=2$。因此，我们将 $D$ 和 $E$ 连接到一个新节点 $U_3$。\n\n到 $U_3$ 的分支长度为：\n$L_{DU_3} = \\frac{1}{2}d_{DE} + \\frac{1}{2(4-2)}(r_D - r_E) = \\frac{1}{2}(2) + \\frac{1}{4}(9.5 - 9.5) = 1.0$\n$L_{EU_3} = \\frac{1}{2}d_{DE} + \\frac{1}{2(4-2)}(r_E - r_D) = \\frac{1}{2}(2) + \\frac{1}{4}(9.5 - 9.5) = 1.0$\n\n新的分类单元集合为 $S_4 = \\{U_2, U_3, F\\}$。涉及 $U_3$ 的距离为：\n$d_{U_2U_3} = \\frac{1}{2}(d_{U_2D} + d_{U_2E} - d_{DE}) = \\frac{1}{2}(3.2 + 3.2 - 2) = 2.2$\n$d_{U_3F} = \\frac{1}{2}(d_{DF} + d_{EF} - d_{DE}) = \\frac{1}{2}(4.3 + 4.3 - 2) = 3.3$\n\n### 迭代 4: $N=3$\n\n分类单元集合为 $S_4 = \\{U_2, U_3, F\\}$，距离矩阵为：\n$$\n\\begin{array}{c|ccc}\n  & U_2 & U_3 & F \\\\\n\\hline\nU_2 & 0 & 2.2 & 5.5 \\\\\nU_3 & 2.2 & 0 & 3.3 \\\\\nF & 5.5 & 3.3 & 0\n\\end{array}\n$$\n当 $N=3$ 时，算法通过将剩下的三个节点连接到一个中心节点来终止。但是，我们可以再进行一个正式的NJ步骤。距离和为：\n$r_{U_2} = 2.2 + 5.5 = 7.7$\n$r_{U_3} = 2.2 + 3.3 = 5.5$\n$r_F = 5.5 + 3.3 = 8.8$\n\n当 $N=3$ 时的 $Q$ 矩阵为 $Q_{ij} = (3-2)d_{ij} - r_i - r_j = d_{ij} - r_i - r_j$：\n$Q_{U_2U_3} = 2.2 - (7.7 + 5.5) = 2.2 - 13.2 = -11.0$\n$Q_{U_2F} = 5.5 - (7.7 + 8.8) = 5.5 - 16.5 = -11.0$\n$Q_{U_3F} = 3.3 - (5.5 + 8.8) = 3.3 - 14.3 = -11.0$\n\n我们再次遇到平局。距离为 $d_{U_2U_3}=2.2$，$d_{U_2F}=5.5$，$d_{U_3F}=3.3$。最小值为 $d_{U_2U_3}=2.2$。我们将 $U_2$ 和 $U_3$ 连接到一个新节点 $U_4$。\n\n到 $U_4$ 的分支长度为：\n$L_{U_2U_4} = \\frac{1}{2}d_{U_2U_3} + \\frac{1}{2(3-2)}(r_{U_2} - r_{U_3}) = \\frac{1}{2}(2.2) + \\frac{1}{2}(7.7 - 5.5) = 1.1 + 1.1 = 2.2$\n$L_{U_3U_4} = \\frac{1}{2}d_{U_2U_3} + \\frac{1}{2(3-2)}(r_{U_3} - r_{U_2}) = \\frac{1}{2}(2.2) + \\frac{1}{2}(5.5 - 7.7) = 1.1 - 1.1 = 0.0$\n\n算法终止时剩下两个节点，$U_4$ 和 $F$。最后的分支将它们连接起来，其长度是最后一个矩阵中它们之间的距离，即 $d_{U_4F}$。计算如下：\n$L_{U_4F} = d_{U_4F} = \\frac{1}{2}(d_{U_2F} + d_{U_3F} - d_{U_2U_3}) = \\frac{1}{2}(5.5 + 3.3 - 2.2) = \\frac{1}{2}(6.6) = 3.3$\n\n### 分支长度总和\n\n我们已经计算了无根树的所有分支长度。分支长度为 $0$（$L_{U_3U_4}=0$）意味着节点 $U_3$ 和 $U_4$ 是相同的。最终的无根树有 $2(6)-3=9$ 个分支，但其中一个长度为 $0$，因此有 $8$ 条长度为正的边。所有分支及其长度的集合如下：\n1. $L_{AU_1} = 1.0$\n2. $L_{BU_1} = 1.0$\n3. $L_{CU_2} = 1.5$\n4. $L_{DU_3} = 1.0$\n5. $L_{EU_3} = 1.0$\n6. $L_{U_1U_2} = 1.0$\n7. $L_{U_2U_4} = 2.2$ （这是连接簇 $(A,B,C)$ 到树其余部分的分支）\n8. $L_{U_3U_4} = 0.0$ （一个长度为零的分支）\n9. $L_{U_4F} = 3.3$ （这连接 $F$ 到树的其余部分）\n\n所有分支长度的总和是这些值的和：\n总长度 $= 1.0 + 1.0 + 1.5 + 1.0 + 1.0 + 1.0 + 2.2 + 0.0 + 3.3$\n总长度 $= (1.0+1.0) + (1.5+1.0) + (1.0+1.0) + 2.2 + 3.3$\n总长度 $= 2.0 + 2.5 + 2.0 + 2.2 + 3.3$\n总长度 $= 4.5 + 2.0 + 2.2 + 3.3 = 6.5 + 2.2 + 3.3 = 8.7 + 3.3 = 12.0$\n\n重建树中所有分支长度的总和为 $12.0$。",
            "answer": "$$\\boxed{12.0}$$"
        },
        {
            "introduction": "最大简约法（Maximum Parsimony, MP）是一种经典的基于特征的推断方法，其目标是寻找需要最少演化改变的演化树。本练习使用Sankoff动态规划算法，在一个给定的有根树上计算一个离散性状的简约性得分，尤其是在转换成本非均等的情况下。通过这个计算，你将掌握在特征演化分析中评估演化成本的核心逻辑。",
            "id": "4593188",
            "problem": "考虑一个具有三种可能状态 $\\{0,1,2\\}$ 的离散形态学性状。给定一个有根的、严格二叉的、包含四个分类单元的系统发育树。根节点为 $\\rho$；其两个子节点是内部节点 $u$ 和 $v$。节点 $u$ 的子节点是叶节点 $t_1$ 和 $t_2$，节点 $v$ 的子节点是叶节点 $t_3$ 和 $t_4$。在叶节点上观察到的性状状态为：$t_1=1$，$t_2=0$，$t_3=2$，$t_4=1$。假设一个有向转移代价矩阵 $C$，给出沿单条边从父代状态 $i$ 变为子代状态 $j$ 的代价 $C(i \\to j)$：\n$$\nC \\;=\\; \\begin{pmatrix}\n0  & 2 & 5 \\\\\n1  & 0 & 2 \\\\\n3  & 1 & 0\n\\end{pmatrix},\n$$\n其中，第 $(i,j)$ 个条目是 $C(i \\to j)$，对于 $i,j \\in \\{0,1,2\\}$。在最大简约法（MP）下，一个祖先状态分配的总分是所有有向边上 $C(\\text{父代} \\to \\text{子代})$ 的总和，而 MP 分数是在与观察到的叶节点状态一致的所有内部节点状态分配中，可能的总分的最小值。\n\n使用 Sankoff 的动态规划方法，计算该性状在给定有根树上的 MP（Sankoff）简约分数 $S$，并指定一个最小祖先重建（即，一个使 $\\rho$、$u$ 和 $v$ 获得最小分数的特定状态分配）。对于叶节点，将其观察到的状态视为固定的。仅报告简约分数 $S$ 的数值作为你的最终答案。无需四舍五入。",
            "solution": "该问题是有效的，因为它提出了一个系统发育推断中定义明确的问题，可以使用标准的、有科学依据的算法来解决。所有必要的数据（树的拓扑结构、叶节点状态和转移代价矩阵）都已提供，并且内部一致。\n\n该问题要求使用 Sankoff 的动态规划算法，计算给定性状在有根树上的最大简约（MP）分数。MP 分数是树的所有边上性状状态变化的总代价的最小值，该最小值是在所有可能的祖先状态分配中取得的。Sankoff 算法通过后序遍历（从叶节点到根节点）来计算这个分数。\n\n对于树中的每个节点 $k$ 和每个可能的性状状态 $i \\in \\{0, 1, 2\\}$，我们定义一个分数 $S_k(i)$，它表示在节点 $k$ 具有状态 $i$ 的条件下，以 $k$ 为根的子树的最小简约分数。\n\n给定的转移代价矩阵是：\n$$\nC(i \\to j) \\;=\\; \\begin{pmatrix}\n0  & 2 & 5 \\\\\n1  & 0 & 2 \\\\\n3  & 1 & 0\n\\end{pmatrix}\n$$\n其中行对应父代状态 $i \\in \\{0,1,2\\}$，列对应子代状态 $j \\in \\{0,1,2\\}$。\n\n该算法分两个阶段进行：一个用于计算分数的前向过程（后序遍历），和一个（最终答案不需要，但对验证有用）用于重建祖先状态的后向过程（前序遍历）。我们将执行前向过程。\n\n**步骤1：在叶节点进行初始化**\n对于一个观察到状态为 $s_k$ 的叶节点 $k$，分数向量 $\\vec{S}_k = (S_k(0), S_k(1), S_k(2))$ 初始化如下：$S_k(s_k) = 0$ 且对于所有 $i \\neq s_k$，有 $S_k(i) = \\infty$。\n观察到的状态为 $t_1=1$，$t_2=0$，$t_3=2$，$t_4=1$。\n- 对于叶节点 $t_1$：状态为 $1$。$\\vec{S}_{t_1} = (\\infty, 0, \\infty)$。\n- 对于叶节点 $t_2$：状态为 $0$。$\\vec{S}_{t_2} = (0, \\infty, \\infty)$。\n- 对于叶节点 $t_3$：状态为 $2$。$\\vec{S}_{t_3} = (\\infty, \\infty, 0)$。\n- 对于叶节点 $t_4$：状态为 $1$。$\\vec{S}_{t_4} = (\\infty, 0, \\infty)$。\n\n**步骤2：后序遍历（向上追溯树）**\n对于一个具有子节点 $c_L$ 和 $c_R$ 的内部节点 $p$，其每个状态 $i$ 的分数 $S_p(i)$ 使用以下公式计算：\n$$\nS_p(i) = \\left[ \\min_{j \\in \\{0,1,2\\}} (S_{c_L}(j) + C(i \\to j)) \\right] + \\left[ \\min_{k \\in \\{0,1,2\\}} (S_{c_R}(k) + C(i \\to k)) \\right]\n$$\n\n**内部节点 $u$（子节点为 $t_1, t_2$）的计算：**\n- $S_u(0) = \\left[ \\min_{j} (S_{t_1}(j) + C(0 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_2}(k) + C(0 \\to k)) \\right]$\n$S_u(0) = (S_{t_1}(1) + C(0 \\to 1)) + (S_{t_2}(0) + C(0 \\to 0)) = (0 + 2) + (0 + 0) = 2$。\n- $S_u(1) = \\left[ \\min_{j} (S_{t_1}(j) + C(1 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_2}(k) + C(1 \\to k)) \\right]$\n$S_u(1) = (S_{t_1}(1) + C(1 \\to 1)) + (S_{t_2}(0) + C(1 \\to 0)) = (0 + 0) + (0 + 1) = 1$。\n- $S_u(2) = \\left[ \\min_{j} (S_{t_1}(j) + C(2 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_2}(k) + C(2 \\to k)) \\right]$\n$S_u(2) = (S_{t_1}(1) + C(2 \\to 1)) + (S_{t_2}(0) + C(2 \\to 0)) = (0 + 1) + (0 + 3) = 4$。\n因此，节点 $u$ 的分数向量为 $\\vec{S}_u = (2, 1, 4)$。\n\n**内部节点 $v$（子节点为 $t_3, t_4$）的计算：**\n- $S_v(0) = \\left[ \\min_{j} (S_{t_3}(j) + C(0 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_4}(k) + C(0 \\to k)) \\right]$\n$S_v(0) = (S_{t_3}(2) + C(0 \\to 2)) + (S_{t_4}(1) + C(0 \\to 1)) = (0 + 5) + (0 + 2) = 7$。\n- $S_v(1) = \\left[ \\min_{j} (S_{t_3}(j) + C(1 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_4}(k) + C(1 \\to k)) \\right]$\n$S_v(1) = (S_{t_3}(2) + C(1 \\to 2)) + (S_{t_4}(1) + C(1 \\to 1)) = (0 + 2) + (0 + 0) = 2$。\n- $S_v(2) = \\left[ \\min_{j} (S_{t_3}(j) + C(2 \\to j)) \\right] + \\left[ \\min_{k} (S_{t_4}(k) + C(2 \\to k)) \\right]$\n$S_v(2) = (S_{t_3}(2) + C(2 \\to 2)) + (S_{t_4}(1) + C(2 \\to 1)) = (0 + 0) + (0 + 1) = 1$。\n因此，节点 $v$ 的分数向量为 $\\vec{S}_v = (7, 2, 1)$。\n\n**根节点 $\\rho$（子节点为 $u, v$）的计算：**\n- $S_\\rho(0) = \\left[ \\min_{j} (S_u(j) + C(0 \\to j)) \\right] + \\left[ \\min_{k} (S_v(k) + C(0 \\to k)) \\right]$\n$S_\\rho(0) = [\\min(S_u(0)+C(0\\to0), S_u(1)+C(0\\to1), S_u(2)+C(0\\to2))] + [\\min(S_v(0)+C(0\\to0), S_v(1)+C(0\\to1), S_v(2)+C(0\\to2))]$\n$S_\\rho(0) = [\\min(2+0, 1+2, 4+5)] + [\\min(7+0, 2+2, 1+5)] = \\min(2, 3, 9) + \\min(7, 4, 6) = 2 + 4 = 6$。\n- $S_\\rho(1) = \\left[ \\min_{j} (S_u(j) + C(1 \\to j)) \\right] + \\left[ \\min_{k} (S_v(k) + C(1 \\to k)) \\right]$\n$S_\\rho(1) = [\\min(S_u(0)+C(1\\to0), S_u(1)+C(1\\to1), S_u(2)+C(1\\to2))] + [\\min(S_v(0)+C(1\\to0), S_v(1)+C(1\\to1), S_v(2)+C(1\\to2))]$\n$S_\\rho(1) = [\\min(2+1, 1+0, 4+2)] + [\\min(7+1, 2+0, 1+2)] = \\min(3, 1, 6) + \\min(8, 2, 3) = 1 + 2 = 3$。\n- $S_\\rho(2) = \\left[ \\min_{j} (S_u(j) + C(2 \\to j)) \\right] + \\left[ \\min_{k} (S_v(k) + C(2 \\to k)) \\right]$\n$S_\\rho(2) = [\\min(S_u(0)+C(2\\to0), S_u(1)+C(2\\to1), S_u(2)+C(2\\to2))] + [\\min(S_v(0)+C(2\\to0), S_v(1)+C(2\\to1), S_v(2)+C(2\\to2))]$\n$S_\\rho(2) = [\\min(2+3, 1+1, 4+0)] + [\\min(7+3, 2+1, 1+0)] = \\min(5, 2, 4) + \\min(10, 3, 1) = 2 + 1 = 3$。\n因此，根节点 $\\rho$ 的分数向量为 $\\vec{S}_\\rho = (6, 3, 3)$。\n\n**步骤3：最终简约分数**\n该性状的总 MP 分数 $S$ 是根节点分数向量中的最小值。\n$$\nS = \\min(S_\\rho(0), S_\\rho(1), S_\\rho(2)) = \\min(6, 3, 3) = 3\n$$\n因此，该性状在给定树上的最小简约分数为 $3$。",
            "answer": "$$\n\\boxed{3}\n$$"
        },
        {
            "introduction": "在系统发育分析中，一个常见的任务是评估和比较不同的拓扑结构假设，以确定哪一个最能解释观测到的数据。本练习将简约法原理应用于这一实际问题，要求你计算并比较两个备选拓扑结构的总简约性得分。此过程还涉及如何处理缺失数据以及更复杂的替换成本模型，展示了如何利用简约性得分来选择最优的系统发育树。",
            "id": "4593241",
            "problem": "对五个患者来源的病毒分离株 $\\mathrm{I}_1,\\mathrm{I}_2,\\mathrm{I}_3,\\mathrm{I}_4,\\mathrm{I}_5$ 的四个独立位点进行基因分型，每个位点都是一个单核苷酸，其状态在字母表 $\\{\\mathrm{A},\\mathrm{C},\\mathrm{G},\\mathrm{T}\\}$ 中。缺失数据记录为 $\\text{?}$，应被视为完全模糊，意味着该叶节点允许所有状态，且罚分为零。假设在加性步长矩阵下采用最大简约法，该矩阵对转换（$\\mathrm{A}\\leftrightarrow \\mathrm{G}$ 和 $\\mathrm{C}\\leftrightarrow \\mathrm{T}$）的代价为 $1$，对颠换的代价为 $2$，相同状态无代价。四个位点（位点索引 $s=1,2,3,4$）的性状矩阵如下：\n- 位点 $1$：$\\mathrm{I}_1=\\mathrm{A}$，$\\mathrm{I}_2=\\mathrm{G}$，$\\mathrm{I}_3=\\text{?}$，$\\mathrm{I}_4=\\mathrm{G}$，$\\mathrm{I}_5=\\mathrm{A}$。\n- 位点 $2$：$\\mathrm{I}_1=\\mathrm{C}$，$\\mathrm{I}_2=\\mathrm{T}$，$\\mathrm{I}_3=\\mathrm{C}$，$\\mathrm{I}_4=\\text{?}$，$\\mathrm{I}_5=\\mathrm{T}$。\n- 位点 $3$：$\\mathrm{I}_1=\\mathrm{G}$，$\\mathrm{I}_2=\\mathrm{G}$，$\\mathrm{I}_3=\\mathrm{T}$，$\\mathrm{I}_4=\\mathrm{T}$，$\\mathrm{I}_5=\\text{?}$。\n- 位点 $4$：$\\mathrm{I}_1=\\mathrm{A}$，$\\mathrm{I}_2=\\mathrm{C}$，$\\mathrm{I}_3=\\mathrm{G}$，$\\mathrm{I}_4=\\mathrm{T}$，$\\mathrm{I}_5=\\mathrm{A}$。\n\n考虑这些分离株的两种备选无根二叉拓扑结构：\n- $\\mathcal{T}_1$: $((\\mathrm{I}_1,\\mathrm{I}_2),(\\mathrm{I}_3,(\\mathrm{I}_4,\\mathrm{I}_5)))$。\n- $\\mathcal{T}_2$: $((\\mathrm{I}_1,(\\mathrm{I}_2,\\mathrm{I}_3)),(\\mathrm{I}_4,\\mathrm{I}_5))$。\n\n从最大简约法和加性步长矩阵的基本原理出发，推导计算给定拓扑结构上每个位点的最小总替换代价所需的动态规划递推式。然后，计算每种拓扑结构在四个位点上的总简约分数，并确定在此标准下哪种拓扑结构更优。最终答案以一个行矩阵的形式表示，按 $\\mathcal{T}_1,\\mathcal{T}_2$ 的顺序列出两个总简约分数。无需四舍五入。",
            "solution": "该问题要求基于五个病毒分离株的性状矩阵，计算并比较两个给定无根拓扑结构 $\\mathcal{T}_1$ 和 $\\mathcal{T}_2$ 的最大简约分数。分数由一个非均匀的替换代价矩阵决定。\n\n首先，我们将通过推导计算最小替换代价（简约分数）的动态规划递推式来建立理论框架。这个方法是 Fitch 算法的推广，称为 Sankoff 算法，它适用于任意的替换代价。\n\n设 $\\mathcal{T}$ 为一个给定的系统发育树。对于单个字符位点，简约分数是解释树叶节点观察到的字符状态所需的最小总替换次数（按其代价加权）。设可能的字符状态集为 $\\Sigma = \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$。从状态 $i$ 到状态 $j$ 的替换代价由代价矩阵 $c(i, j)$ 给出。\n\n问题给出了以下代价矩阵 $c(i,j)$，其中转换（A$\\leftrightarrow$G, C$\\leftrightarrow$T）的代价为 $1$，颠换的代价为 $2$：\n$$\nc = \\begin{pmatrix}\n  & \\mathrm{A} & \\mathrm{C} & \\mathrm{G} & \\mathrm{T} \\\\\n\\mathrm{A} & 0 & 2 & 1 & 2 \\\\\n\\mathrm{C} & 2 & 0 & 2 & 1 \\\\\n\\mathrm{G} & 1 & 2 & 0 & 2 \\\\\n\\mathrm{T} & 2 & 1 & 2 & 0\n\\end{pmatrix}\n$$\n\nSankoff 算法使用树的后序遍历（从叶到根）来计算简约分数。对于树中的每个节点 $k$，我们计算一个代价向量 $S_k$，其中 $S_k(x)$ 是以节点 $k$ 为根的子树的最小代价，假定节点 $k$ 的字符状态为 $x \\in \\Sigma$。\n\n**动态规划递推式：**\n\n1.  **初始化（叶节点）：** 对于对应于观察到字符状态为 $x_k$ 的分离株的叶节点 $k$：\n    - 如果状态 $x_k$ 已知（即 $x_k \\in \\Sigma$），则代价向量为：\n      $$ S_k(x) = \\begin{cases} 0 & \\text{若 } x = x_k \\\\ \\infty & \\text{若 } x \\neq x_k \\end{cases} $$\n    - 如果状态为缺失数据（即 $x_k = \\text{?}$），则视为完全模糊。任何状态都可以被赋予而没有罚分。\n      $$ S_k(x) = 0 \\quad \\forall x \\in \\Sigma $$\n\n2.  **递推（内部节点）：** 对于一个有子节点 $i$ 和 $j$ 的内部节点 $k$，其代价向量 $S_k(x)$ 计算如下：\n    $$ S_k(x) = \\left( \\min_{y \\in \\Sigma} \\{ S_i(y) + c(x, y) \\} \\right) + \\left( \\min_{z \\in \\Sigma} \\{ S_j(z) + c(x, z) \\} \\right) $$\n    该公式将子节点子树的最小代价相加，包括通往它们的支路上的替换代价。\n\n3.  **总分数（有根树）：** 对于根节点为 $R$ 的树，该位点的简约分数是根节点代价向量中的最小值：\n    $$ \\text{分数} = \\min_{x \\in \\Sigma} \\{ S_R(x) \\} $$\n\n4.  **总分数（无根树）：** 一个有 $N$ 个叶节点的无根树有一个任意的中心边。我们可以通过在该边上“定根”来计算分数。设中心边连接内部节点 $u$ 和 $v$。通过移除边 $(u,v)$ 形成的两个子树，我们分别计算其代价向量 $S_u$ 和 $S_v$。无根树的总简约分数是连接这两个子树的最小代价：\n    $$ \\text{分数} = \\min_{x, y \\in \\Sigma} \\{ S_u(x) + S_v(y) + c(x, y) \\} $$\n\n一个拓扑结构的总简约分数是每个位点分数之和。我们现在将此过程应用于给定的两个拓扑结构。代价向量 $S_k(x)$ 将表示为行向量 $(S_k(\\mathrm{A}), S_k(\\mathrm{C}), S_k(\\mathrm{G}), S_k(\\mathrm{T}))$。\n\n**评估拓扑结构 $\\mathcal{T}_1: ((\\mathrm{I}_1,\\mathrm{I}_2),(\\mathrm{I}_3,(\\mathrm{I}_4,\\mathrm{I}_5)))$**\n该拓扑结构有一个中心边，连接节点 $V_A$（$\\mathrm{I}_1, \\mathrm{I}_2$ 的父节点）和节点 $V_C$（$\\mathrm{I}_3$ 和 $V_B$ 的父节点，其中 $V_B$ 是 $\\mathrm{I}_4, \\mathrm{I}_5$ 的父节点）。\n\n**位点 1:** $(\\mathrm{A}, \\mathrm{G}, \\text{?}, \\mathrm{G}, \\mathrm{A})$\n- $V_A$ 处的子树（子节点 $\\mathrm{I}_1=\\mathrm{A}, \\mathrm{I}_2=\\mathrm{G}$）：$S_{V_A}(x) = c(x,\\mathrm{A}) + c(x,\\mathrm{G}) = (0+1, 2+2, 1+0, 2+2) = (1,4,1,4)$。\n- $V_B$ 处的子树（子节点 $\\mathrm{I}_4=\\mathrm{G}, \\mathrm{I}_5=\\mathrm{A}$）：$S_{V_B}(x) = c(x,\\mathrm{G}) + c(x,\\mathrm{A}) = (1+0, 2+2, 0+1, 2+2) = (1,4,1,4)$。\n- $V_C$ 处的子树（子节点 $\\mathrm{I}_3=\\text{?}, V_B$）：\n  - 来自 $\\mathrm{I}_3$ 的代价：$\\min_{y}\\{S_3(y)+c(x,y)\\} = \\min_{y}\\{0+c(x,y)\\} = 0$ 对所有 $x$ 成立。\n  - 来自 $V_B$ 的代价：$T_2(x) = \\min_{z}\\{S_{V_B}(z)+c(x,z)\\}$。$S_{V_B}=(1,4,1,4)$。\n    $T_2(\\mathrm{A}) = \\min\\{1+0, 4+2, 1+1, 4+2\\} = 1$。\n    $T_2(\\mathrm{C}) = \\min\\{1+2, 4+0, 1+2, 4+1\\} = 3$。\n    $T_2(\\mathrm{G}) = \\min\\{1+1, 4+2, 1+0, 4+2\\} = 1$。\n    $T_2(\\mathrm{T}) = \\min\\{1+2, 4+1, 1+2, 4+0\\} = 3$。\n  - $S_{V_C}(x) = 0 + T_2(x) = (1,3,1,3)$。\n- 总分数：$\\min_{x,y}\\{S_{V_A}(x)+S_{V_C}(y)+c(x,y)\\}$。其中 $S_{V_A}=(1,4,1,4)$ 和 $S_{V_C}=(1,3,1,3)$。\n  分数 $= S_{V_A}(\\mathrm{A})+S_{V_C}(\\mathrm{A})+c(\\mathrm{A},\\mathrm{A}) = 1+1+0 = 2$。或者 $S_{V_A}(\\mathrm{G})+S_{V_C}(\\mathrm{G})+c(\\mathrm{G},\\mathrm{G}) = 1+1+0 = 2$。最小值为 $2$。\n  **位点1的分数 = $2$。**\n\n**位点 2:** $(\\mathrm{C}, \\mathrm{T}, \\mathrm{C}, \\text{?}, \\mathrm{T})$\n- $V_A$ 处的子树（$\\mathrm{I}_1=\\mathrm{C}, \\mathrm{I}_2=\\mathrm{T}$）：$S_{V_A}(x) = c(x,\\mathrm{C}) + c(x,\\mathrm{T}) = (2+2, 0+1, 2+2, 1+0) = (4,1,4,1)$。\n- $V_B$ 处的子树（$\\mathrm{I}_4=\\text{?}, \\mathrm{I}_5=\\mathrm{T}$）：$S_{V_B}(x) = \\min_{y}\\{S_4(y)+c(x,y)\\} + c(x,\\mathrm{T}) = 0+c(x,\\mathrm{T})=(2,1,2,0)$。\n- $V_C$ 处的子树（$\\mathrm{I}_3=\\mathrm{C}, V_B$）：$S_{V_C}(x) = c(x,\\mathrm{C}) + \\min_{z}\\{S_{V_B}(z)+c(x,z)\\}$。令 $T_2(x) = \\min_{z}\\{S_{V_B}(z)+c(x,z)\\}$。$S_{V_B}=(2,1,2,0)$。$T_2(\\mathrm{C})=\\min\\{2+2,1+0,2+2,0+1\\}=1$。$T_2(\\mathrm{T})=\\min\\{2+2,1+1,2+2,0+0\\}=0$。经过完整计算：$T_2=(2,1,2,0)$。\n  $S_{V_C} = c(x,\\mathrm{C}) + T_2(x) = (2,0,2,1) + (2,1,2,0) = (4,1,4,1)$。\n- 总分数：$\\min_{x,y}\\{S_{V_A}(x)+S_{V_C}(y)+c(x,y)\\}$。其中 $S_{V_A}=(4,1,4,1)$ 和 $S_{V_C}=(4,1,4,1)$。\n  最小值在 $x=y=\\mathrm{C}$ 或 $x=y=\\mathrm{T}$ 处取得。分数 $= 1+1+0=2$。\n  **位点2的分数 = $2$。**\n\n**位点 3:** $(\\mathrm{G}, \\mathrm{G}, \\mathrm{T}, \\mathrm{T}, \\text{?})$\n- $V_A$ 处的子树（$\\mathrm{I}_1=\\mathrm{G}, \\mathrm{I}_2=\\mathrm{G}$）：$S_{V_A}(x) = c(x,\\mathrm{G}) + c(x,\\mathrm{G}) = (2,4,0,4)$。\n- $V_B$ 处的子树（$\\mathrm{I}_4=\\mathrm{T}, \\mathrm{I}_5=\\text{?}$）：$S_{V_B}(x) = c(x,\\mathrm{T}) + 0 = (2,1,2,0)$。\n- $V_C$ 处的子树（$\\mathrm{I}_3=\\mathrm{T}, V_B$）：$S_{V_C}(x) = c(x,\\mathrm{T}) + \\min_{z}\\{S_{V_B}(z)+c(x,z)\\}$。如同位点2，$\\min_{z}\\{S_{V_B}(z)+c(x,z)\\} = (2,1,2,0)$。\n  $S_{V_C} = (2,1,2,0) + (2,1,2,0) = (4,2,4,0)$。\n- 总分数：$\\min_{x,y}\\{S_{V_A}(x)+S_{V_C}(y)+c(x,y)\\}$。其中 $S_{V_A}=(2,4,0,4)$ 和 $S_{V_C}=(4,2,4,0)$。\n  对于 $x=\\mathrm{G}, y=\\mathrm{T}$，分数为最小：$S_{V_A}(\\mathrm{G})+S_{V_C}(\\mathrm{T})+c(\\mathrm{G},\\mathrm{T}) = 0+0+2=2$。\n  **位点3的分数 = $2$。**\n\n**位点 4:** $(\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A})$\n- $V_A$ 处的子树（$\\mathrm{I}_1=\\mathrm{A}, \\mathrm{I}_2=\\mathrm{C}$）：$S_{V_A}(x) = c(x,\\mathrm{A}) + c(x,\\mathrm{C}) = (2,2,3,3)$。\n- $V_B$ 处的子树（$\\mathrm{I}_4=\\mathrm{T}, \\mathrm{I}_5=\\mathrm{A}$）：$S_{V_B}(x) = c(x,\\mathrm{T}) + c(x,\\mathrm{A}) = (2,3,3,2)$。\n- $V_C$ 处的子树（$\\mathrm{I}_3=\\mathrm{G}, V_B$）：$S_{V_C}(x) = c(x,\\mathrm{G}) + \\min_z\\{S_{V_B}(z)+c(x,z)\\}$。令 $T_2(x)=\\min_z\\{S_{V_B}(z)+c(x,z)\\}$，其中 $S_{V_B}=(2,3,3,2)$。$T_2 = (2,3,3,2)$。\n  $S_{V_C} = c(x,\\mathrm{G}) + T_2(x) = (1,2,0,2) + (2,3,3,2) = (3,5,3,4)$。\n- 总分数：$\\min_{x,y}\\{S_{V_A}(x)+S_{V_C}(y)+c(x,y)\\}$。其中 $S_{V_A}=(2,2,3,3)$ 和 $S_{V_C}=(3,5,3,4)$。\n  对于 $x=\\mathrm{A}, y=\\mathrm{A}$，分数为最小：$S_{V_A}(\\mathrm{A})+S_{V_C}(\\mathrm{A})+c(\\mathrm{A},\\mathrm{A}) = 2+3+0=5$。\n  **位点4的分数 = $5$。**\n\n**$\\mathcal{T}_1$ 的总分数 = $2+2+2+5 = 11$。**\n\n**评估拓扑结构 $\\mathcal{T}_2: ((\\mathrm{I}_1,(\\mathrm{I}_2,\\mathrm{I}_3)),(\\mathrm{I}_4,\\mathrm{I}_5))$**\n该拓扑结构有一个中心边，连接节点 $V_F$（$\\mathrm{I}_1$ 和 $V_E$ 的父节点，其中 $V_E$ 是 $\\mathrm{I}_2, \\mathrm{I}_3$ 的父节点）和节点 $V_D$（$\\mathrm{I}_4, \\mathrm{I}_5$ 的父节点）。\n\n**位点 1:** $(\\mathrm{A}, \\mathrm{G}, \\text{?}, \\mathrm{G}, \\mathrm{A})$\n- $V_D$ 处的子树（$\\mathrm{I}_4=\\mathrm{G}, \\mathrm{I}_5=\\mathrm{A}$）：$S_{V_D}(x) = c(x,\\mathrm{G}) + c(x,\\mathrm{A}) = (1,4,1,4)$。\n- $V_E$ 处的子树（$\\mathrm{I}_2=\\mathrm{G}, \\mathrm{I}_3=\\text{?}$）：$S_{V_E}(x) = c(x,\\mathrm{G}) + 0 = (1,2,0,2)$。\n- $V_F$ 处的子树（$\\mathrm{I}_1=\\mathrm{A}, V_E$）：$S_{V_F}(x) = c(x,\\mathrm{A}) + \\min_z\\{S_{V_E}(z)+c(x,z)\\}$。$S_{V_E}=(1,2,0,2)$。$\\min_z\\{S_{V_E}(z)+c(x,z)\\}=(1,2,0,2)$。\n  $S_{V_F} = (0,2,1,2)+(1,2,0,2) = (1,4,1,4)$。\n- 总分数：$\\min_{x,y}\\{S_{V_F}(x)+S_{V_D}(y)+c(x,y)\\}$。其中 $S_{V_F}=(1,4,1,4), S_{V_D}=(1,4,1,4)$。\n  分数 $= 1+1+0=2$。\n  **位点1的分数 = $2$。**\n\n**位点 2:** $(\\mathrm{C}, \\mathrm{T}, \\mathrm{C}, \\text{?}, \\mathrm{T})$\n- $V_D$ 处的子树（$\\mathrm{I}_4=\\text{?}, \\mathrm{I}_5=\\mathrm{T}$）：$S_{V_D}(x) = c(x,\\mathrm{T}) = (2,1,2,0)$。\n- $V_E$ 处的子树（$\\mathrm{I}_2=\\mathrm{T}, \\mathrm{I}_3=\\mathrm{C}$）：$S_{V_E}(x)=c(x,\\mathrm{T})+c(x,\\mathrm{C}) = (4,1,4,1)$。\n- $V_F$ 处的子树（$\\mathrm{I}_1=\\mathrm{C}, V_E$）：$S_{V_F}(x) = c(x,C) + \\min_z\\{S_{V_E}(z)+c(x,z)\\}$。$S_{V_E}=(4,1,4,1)$。$\\min_z\\{S_{V_E}(z)+c(x,z)\\}=(3,1,3,1)$。\n  $S_{V_F} = (2,0,2,1)+(3,1,3,1) = (5,1,5,2)$。\n- 总分数：$\\min_{x,y}\\{S_{V_F}(x)+S_{V_D}(y)+c(x,y)\\}$。其中 $S_{V_F}=(5,1,5,2), S_{V_D}=(2,1,2,0)$。\n  最小值在 $x=y=\\mathrm{C}$ 或 $x=y=\\mathrm{T}$ 处取得。例如，$S_{V_F}(\\mathrm{C})+S_{V_D}(\\mathrm{C})+c(\\mathrm{C,C}) = 1+1+0 = 2$。\n  **位点2的分数 = $2$。**\n\n**位点 3:** $(\\mathrm{G}, \\mathrm{G}, \\mathrm{T}, \\mathrm{T}, \\text{?})$\n- $V_D$ 处的子树（$\\mathrm{I}_4=\\mathrm{T}, \\mathrm{I}_5=\\text{?}$）：$S_{V_D}(x) = c(x,\\mathrm{T}) = (2,1,2,0)$。\n- $V_E$ 处的子树（$\\mathrm{I}_2=\\mathrm{G}, \\mathrm{I}_3=\\mathrm{T}$）：$S_{V_E}(x)=c(x,\\mathrm{G})+c(x,\\mathrm{T}) = (3,3,2,2)$。\n- $V_F$ 处的子树（$\\mathrm{I}_1=\\mathrm{G}, V_E$）：$S_{V_F}(x) = c(x,\\mathrm{G}) + \\min_z\\{S_{V_E}(z)+c(x,z)\\}$。$S_{V_E}=(3,3,2,2)$。$\\min_z\\{S_{V_E}(z)+c(x,z)\\}=(3,3,2,2)$。\n  $S_{V_F} = (1,2,0,2)+(3,3,2,2) = (4,5,2,4)$。\n- 总分数：$\\min_{x,y}\\{S_{V_F}(x)+S_{V_D}(y)+c(x,y)\\}$。其中 $S_{V_F}=(4,5,2,4), S_{V_D}=(2,1,2,0)$。\n  最小代价的选择是 $x=\\mathrm{G}, y=\\mathrm{T}$：$S_{V_F}(\\mathrm{G})+S_{V_D}(\\mathrm{T})+c(\\mathrm{G,T}) = 2+0+2 = 4$。\n  **位点3的分数 = $4$。**\n\n**位点 4:** $(\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A})$\n- $V_D$ 处的子树（$\\mathrm{I}_4=\\mathrm{T}, \\mathrm{I}_5=\\mathrm{A}$）：$S_{V_D}(x) = c(x,\\mathrm{T})+c(x,\\mathrm{A}) = (2,3,3,2)$。\n- $V_E$ 处的子树（$\\mathrm{I}_2=\\mathrm{C}, \\mathrm{I}_3=\\mathrm{G}$）：$S_{V_E}(x)=c(x,\\mathrm{C})+c(x,\\mathrm{G}) = (3,2,2,3)$。\n- $V_F$ 处的子树（$\\mathrm{I}_1=\\mathrm{A}, V_E$）：$S_{V_F}(x) = c(x,\\mathrm{A}) + \\min_z\\{S_{V_E}(z)+c(x,z)\\}$。$S_{V_E}=(3,2,2,3)$。$\\min_z\\{S_{V_E}(z)+c(x,z)\\}=(3,2,2,3)$。\n  $S_{V_F} = (0,2,1,2)+(3,2,2,3) = (3,4,3,5)$。\n- 总分数：$\\min_{x,y}\\{S_{V_F}(x)+S_{V_D}(y)+c(x,y)\\}$。其中 $S_{V_F}=(3,4,3,5), S_{V_D}=(2,3,3,2)$。\n  最小代价的选择是 $x=\\mathrm{A}, y=\\mathrm{A}$：$S_{V_F}(\\mathrm{A})+S_{V_D}(\\mathrm{A})+c(\\mathrm{A,A}) = 3+2+0 = 5$。\n  **位点4的分数 = $5$。**\n\n**$\\mathcal{T}_2$ 的总分数 = $2+2+4+5 = 13$。**\n\n**结论**\n拓扑结构 $\\mathcal{T}_1$ 的总简约分数为 $11$。\n拓扑结构 $\\mathcal{T}_2$ 的总简约分数为 $13$。\n根据最大简约法标准，分数最低的拓扑结构是更优的。因此，对于此数据集和代价模型，$\\mathcal{T}_1$ 是更简约的拓扑结构。最终答案是 $\\mathcal{T}_1$ 和 $\\mathcal{T}_2$ 的分数对。",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n11 & 13\n\\end{pmatrix}\n}\n$$"
        }
    ]
}