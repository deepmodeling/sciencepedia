{
    "hands_on_practices": [
        {
            "introduction": "任何数字表型的质量从根本上受限于原始传感器数据的保真度。加速度计虽然无处不在，但常常存在系统性的制造缺陷，表现为恒定的偏置、尺度因子错误和轴向错位。本练习  提供了一个关键预处理步骤的实践方法：传感器校准。通过对这些误差进行建模，并利用对恒定重力场的测量，您将学习如何估计和校正这些误差，从而确保下游分析（如活动识别或姿态跟踪）所用数据的完整性。",
            "id": "4557386",
            "problem": "嵌入在移动或可穿戴设备中的三轴加速度计用于数字表型分析，它通过测量在不同方向的静止保持期间以及保持之间的受控旋转期间的重力加速度。该仪器表现出尺度误差、恒定偏置偏移和轴不对齐，这些可以建模为对真实加速度的未知线性变换外加一个加性偏置。假设以下基于物理和统计的模型：在静止保持 $k$ 期间，设备坐标系中的真实比力矢量是已知旋转矩阵 $R_k \\in \\mathbb{R}^{3 \\times 3}$ 应用于固定导航坐标系中重力矢量的结果。设重力大小为标准重力加速度 $g = 9.80665$ $\\mathrm{m/s^2}$，角度以度为单位。将导航坐标系中的重力矢量表示为 $g_0 = [0,0,-g]^\\top$（单位为$\\mathrm{m/s^2}$），相应的设备坐标系重力表示为 $v_k = R_k g_0$。在同一次静止保持期间，设备坐标系中的加速度计测量值建模为 $y_k = A v_k + b + \\epsilon_k$，其中 $A \\in \\mathbb{R}^{3 \\times 3}$ 编码了尺度因子和轴不对齐，$b \\in \\mathbb{R}^{3}$ 编码了恒定偏置，而 $\\epsilon_k$ 是零均值的加性噪声。校准目标是从多个不同方向的静止保持中估计 $A$ 和 $b$。\n\n你必须设计并实现一个校准程序，通过基于上述模型构建一个合适的线性系统，并通过一个有原则的估计器来求解，从而从带噪声的测量中估计 $A$ 和 $b$。此外，你必须确定集合 $\\{v_k\\}$ 的可辨识性条件，在此条件下参数 $(A,b)$ 可以从数据中唯一确定。具体来说，你必须用一个合适的设计矩阵的秩来表达可辨识性，该矩阵捕捉了 $(A,b)$ 和测量值 $\\{y_k\\}$ 之间的线性关系，并且必须对给定的测试案例数值地检验此条件。你的推导必须从基本原理开始：Newton第二定律、地球表面附近重力场强度的恒定性，以及小信号传感器校准模型的线性度。\n\n必须严格遵守物理单位：所有加速度单位为 $\\mathrm{m/s^2}$，所有角度单位为度。计算误差时，应以小数形式表示（而非百分比）。\n\n实现你的程序以处理以下三个测试案例。在所有案例中，真实的校准参数是相同的且已知的，以便你可以计算估计误差。使用由下式定义的 $A_{\\text{true}}$ 和 $b_{\\text{true}}$：\n$$\nA_{\\text{true}} = \\begin{bmatrix}\n1  & 0.02  & -0.01 \\\\\n0.01  & 1  & -0.015 \\\\\n-0.005  & 0.02  & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1.03  & 0  & 0 \\\\\n0  & 0.97  & 0 \\\\\n0  & 0  & 0.99\n\\end{bmatrix}, \\quad\nb_{\\text{true}} = \\begin{bmatrix} 0.05 \\\\ -0.03 \\\\ 0.02 \\end{bmatrix} \\ \\ (\\mathrm{m/s^2}).\n$$\n对于每个测试案例，使用指定的 $R_k$ 构建 $v_k = R_k g_0$，并生成测量值 $y_k = A_{\\text{true}} v_k + b_{\\text{true}} + \\epsilon_k$，其中 $\\epsilon_k$ 是零均值和各向同性协方差 $\\sigma^2 I_3$ 的独立高斯噪声。使用固定的随机种子 $42$，以便噪声是可复现的。\n\n测试案例1（多样化方向，可辨识）：\n- 噪声标准差 $\\sigma = 0.005$ $\\mathrm{m/s^2}$。\n- 方向由 $R_k$ 给出，作为围绕设备轴旋转以下角度（均以度为单位）的复合：\n  $$\n  R_1 = I, \\quad\n  R_2 = R_x(90), \\quad\n  R_3 = R_x(180), \\quad\n  R_4 = R_y(90), \\quad\n  R_5 = R_z(90), \\quad\n  R_6 = R_x(45) R_y(30), \\quad\n  R_7 = R_y(120) R_z(45), \\quad\n  R_8 = R_x(210) R_z(135),\n  $$\n  其中 $R_x(\\theta)$、$R_y(\\theta)$、$R_z(\\theta)$ 分别表示围绕x、y和z轴的右手旋转，角度为 $\\theta$（以度为单位）。\n\n测试案例2（重复单一方向，不可辨识）：\n- 噪声标准差 $\\sigma = 0.005$ $\\mathrm{m/s^2}$。\n- 对于 $k = 1,2,3,4,5,6$，方向由 $R_k = I$ 给出，即设备未重新定向。\n\n测试案例3（近似共面的方向，可辨识但病态）：\n- 噪声标准差 $\\sigma = 0.01$ $\\mathrm{m/s^2}$。\n- 方向由 $R_k = R_z(\\psi_k) R_x(2)$ 给出，其中偏航角 $\\psi_k \\in \\{0,30,60,90,120,150\\}$（以度为单位），俯仰角为 $2$ 度。\n\n根据模型和数据，构建一个线性设计矩阵，其列对应于 $A$ 和 $b$ 的未知条目，并使用数值稳定的方法求解得到的线性系统。通过计算设计矩阵的秩来明确检查可辨识性，并且当且仅当秩等于 $12$ 时声明问题是可辨识的。计算 $A$ 和 $b$ 的相对估计误差：\n$$\n\\text{rel\\_err}_A = \\frac{\\lVert \\hat{A} - A_{\\text{true}} \\rVert_F}{\\lVert A_{\\text{true}} \\rVert_F}, \\quad\n\\text{rel\\_err}_b = \\frac{\\lVert \\hat{b} - b_{\\text{true}} \\rVert_2}{\\lVert b_{\\text{true}} \\rVert_2}.\n$$\n\n最终输出格式：\n你的程序应生成一行输出，包含一个用方括号括起来的逗号分隔列表。对于三个测试案例中的每一个，按顺序附加：\n- 可辨识性布尔值（即，如果秩等于 $12$ 则为 $True$，否则为 $False$），\n- 设计矩阵的整数秩，\n- 浮点数值 $\\text{rel\\_err}_A$，\n- 浮点数值 $\\text{rel\\_err}_b$。\n因此，最终输出总共包含 $12$ 个项目，顺序为 $[id_1,rank_1,relA_1,relb_1,id_2,rank_2,relA_2,relb_2,id_3,rank_3,relA_3,relb_3]$。\n\n角度单位：度。加速度单位：$\\mathrm{m/s^2}$。所有浮点数必须以十进制形式打印。",
            "solution": "加速度计校准问题通过估计一个线性模型的参数来解决，该模型将真实比力（重力）与传感器的测量值关联起来。对于一组静止保持 $k=1, \\dots, N$，模型由 $y_k = A v_k + b + \\epsilon_k$ 给出。这里，$y_k \\in \\mathbb{R}^3$ 是测量的加速度，$v_k \\in \\mathbb{R}^3$ 是设备坐标系中的真实重力矢量，$A \\in \\mathbb{R}^{3 \\times 3}$ 是考虑了尺度和不对齐误差的校准矩阵，$b \\in \\mathbb{R}^3$ 是偏置矢量，$\\epsilon_k$ 是测量噪声。真实重力矢量是通过使用每次保持的已知旋转矩阵 $v_k = R_k g_0$ 旋转一个固定导航坐标系中的重力矢量 $g_0 = [0, 0, -g]^\\top$（其中 $g=9.80665 \\, \\mathrm{m/s^2}$）得到的。目标是估计包含在 $A$ 和 $b$ 中的 $12$ 个参数。\n\n为了求解 $A$ 和 $b$，我们构建一个线性最小二乘问题。模型方程可以为测量矢量 $y_k = [y_{k,x}, y_{k,y}, y_{k,z}]^\\top$ 的每个分量展开。设矩阵 $A$ 的行为 $a_1^\\top, a_2^\\top, a_3^\\top$，偏置矢量为 $b=[b_1, b_2, b_3]^\\top$。对于测量 $k$，三个标量方程为：\n$$\ny_{k,x} = a_1^\\top v_k + b_1 \\\\\ny_{k,y} = a_2^\\top v_k + b_2 \\\\\ny_{k,z} = a_3^\\top v_k + b_3\n$$\n我们可以观察到未知数是按行解耦的。参数 $\\{a_1, b_1\\}$ 只出现在 $y_{k,x}$ 的方程中，其他分量也类似。这允许我们建立三个独立的线性系统。对于第一个系统，涉及所有 $N$ 次保持的x通道测量值，我们有：\n$$\n\\begin{bmatrix} y_{1,x} \\\\ y_{2,x} \\\\ \\vdots \\\\ y_{N,x} \\end{bmatrix} =\n\\begin{bmatrix}\nv_{1,x} & v_{1,y} & v_{1,z} & 1 \\\\\nv_{2,x} & v_{2,y} & v_{2,z} & 1 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots \\\\\nv_{N,x} & v_{N,y} & v_{N,z} & 1\n\\end{bmatrix}\n\\begin{bmatrix} a_{11} \\\\ a_{12} \\\\ a_{13} \\\\ b_1 \\end{bmatrix} +\n\\begin{bmatrix} \\epsilon_{1,x} \\\\ \\epsilon_{2,x} \\\\ \\vdots \\\\ \\epsilon_{N,x} \\end{bmatrix}\n$$\n这可以紧凑地写为 $Y_x = H x_1 + E_x$。设计矩阵 $H \\in \\mathbb{R}^{N \\times 4}$ 对所有三个通道都是相同的。另外两个通道的参数矢量是 $x_2 = [a_{21}, a_{22}, a_{23}, b_2]^\\top$ 和 $x_3 = [a_{31}, a_{32}, a_{33}, b_3]^\\top$。\n\n当且仅当 $x_1, x_2, x_3$ 的三个系统中的每一个都产生唯一解时，全部 $12$ 个参数的集合是可辨识的。这个条件当且仅当设计矩阵 $H$ 具有满列秩时满足，即 $\\text{rank}(H) = 4$。从几何上看，这要求 $N$ 个增广向量 $[v_k^\\top, 1] \\in \\mathbb{R}^4$ 张成一个 $4$ 维空间。这意味着真实重力矢量 $v_k$ 不能是仿射相关的；具体来说，它们不能都位于一个平面或一条直线上。由于对所有 $k$ 都有 $\\|v_k\\|_2=g$，矢量 $v_k$ 位于半径为 $g$ 的球面上。因此，条件 $\\text{rank}(H)=4$ 等价于要求至少有四个非共面的重力矢量 $v_k$。\n\n为了满足问题对检查一个 $12 \\times 12$ 系统的要求，我们可以为一个堆叠的参数矢量 $\\theta = [x_1^\\top, x_2^\\top, x_3^\\top]^\\top$ 构建一个全局设计矩阵 $W \\in \\mathbb{R}^{3N \\times 12}$。这个矩阵由克罗内克积 $W = I_3 \\otimes H$ 给出，其中 $I_3$ 是 $3 \\times 3$ 的单位矩阵。这个块对角矩阵的秩是 $\\text{rank}(W) = 3 \\times \\text{rank}(H)$。因此，当且仅当 $\\text{rank}(H) = 4$ 时，系统是可辨识的，且 $\\text{rank}(W) = 12$。\n\n每个参数子矢量 $x_i$ 的最小二乘估计是通过求解正规方程找到的，或者更稳健地，使用像 `numpy.linalg.lstsq` 中实现的SVD分解等方法。\n$$\n\\hat{x_i} = (H^\\top H)^{-1} H^\\top Y_i, \\quad i \\in \\{x,y,z\\}\n$$\n然后从解 $\\hat{x_1}, \\hat{x_2}, \\hat{x_3}$ 组装估计的参数 $(\\hat{A}, \\hat{b})$。估计误差使用相对Frobenius范数和欧几里得范数来量化。\n\n**测试案例分析：**\n*   **测试案例1**：提供了 $8$ 个多样化并张成三维空间的方向。得到的 $v_k$ 矢量是非共面的，导致 $\\text{rank}(H)=4$ 和 $\\text{rank}(W)=12$。问题是可辨识且良态的，因此估计误差预计会很小，并由噪声水平 $\\sigma$ 驱动。\n*   **测试案例2**：对所有 $6$ 次测量使用单一方向。所有的 $v_k$ 都是相同的：对所有 $k$ 都有 $v_k = v_1$。$H$ 的行是相同的，所以 $\\text{rank}(H)=1$。这导致 $\\text{rank}(W)=3$。系统是严重欠定的（不可辨识）。最小二乘解将对应于一个最小范数解，这个解是任意的，并且不会恢复出真实的参数。\n*   **测试案例3**：采用在围绕x轴进行小的固定倾斜后，再围绕设备的z轴旋转的方向。真实重力矢量由 $v_k = R_z(\\psi_k) R_x(2^\\circ) g_0$ 给出。每个矢量的z分量是 $v_{k,z} = -g \\cos(2^\\circ)$，这对所有 $k$ 都是常数。这意味着所有 $v_k$ 矢量都位于由 $z = -g \\cos(2^\\circ)$ 定义的平面上。它们是共面的。因此，$H$ 的列是线性相关的，因为对所有 $k$ 都有 $1 \\cdot v_{k,z} + (g \\cos(2^\\circ)) \\cdot 1 = 0$。矢量 $[0, 0, 1, g \\cos(2^\\circ)]^\\top$ 在 $H$ 的零空间中。因此，$\\text{rank}(H)=3$，且 $\\text{rank}(W)=9$。系统是不可辨识的。这与问题对此案例“可辨识但病态”的文字描述相矛盾。“病态”的性质源于奇异性（共面性）是精确的，使得条件数为无穷大。一个真正“可辨识但病态”的案例会在矢量*近似*但*不完全*共面时出现。实现将基于旋转的精确数学规范进行，这将导致不可辨识性。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import norm, kron\n\ndef solve():\n    \"\"\"\n    Solves the accelerometer calibration problem for three test cases.\n    \"\"\"\n    # --- Problem Constants and True Parameters ---\n    g = 9.80665  # m/s^2\n    g0 = np.array([0., 0., -g])\n\n    M_true = np.array([\n        [1.0, 0.02, -0.01],\n        [0.01, 1.0, -0.015],\n        [-0.005, 0.02, 1.0]\n    ])\n    S_true_diag = np.array([1.03, 0.97, 0.99])\n    S_true = np.diag(S_true_diag)\n    A_true = M_true @ S_true\n    b_true = np.array([0.05, -0.03, 0.02])\n\n    rng = np.random.default_rng(42)\n\n    # --- Rotation Matrix Helper Functions (angles in degrees) ---\n    def Rx(theta_deg):\n        theta_rad = np.deg2rad(theta_deg)\n        c, s = np.cos(theta_rad), np.sin(theta_rad)\n        return np.array([[1., 0., 0.], [0., c, -s], [0., s, c]])\n\n    def Ry(theta_deg):\n        theta_rad = np.deg2rad(theta_deg)\n        c, s = np.cos(theta_rad), np.sin(theta_rad)\n        return np.array([[c, 0., s], [0., 1., 0.], [-s, 0., c]])\n\n    def Rz(theta_deg):\n        theta_rad = np.deg2rad(theta_deg)\n        c, s = np.cos(theta_rad), np.sin(theta_rad)\n        return np.array([[c, -s, 0.], [s, c, 0.], [0., 0., 1.]])\n\n    # --- Test Case Definitions ---\n    test_cases_params = [\n        {\n            \"sigma\": 0.005,\n            \"rotations\": [\n                np.identity(3),\n                Rx(90),\n                Rx(180),\n                Ry(90),\n                Rz(90),\n                Rx(45) @ Ry(30),\n                Ry(120) @ Rz(45),\n                Rx(210) @ Rz(135),\n            ]\n        },\n        {\n            \"sigma\": 0.005,\n            \"rotations\": [np.identity(3)] * 6\n        },\n        {\n            \"sigma\": 0.01,\n            \"rotations\": [Rz(psi) @ Rx(2) for psi in [0., 30., 60., 90., 120., 150.]]\n        }\n    ]\n\n    results = []\n\n    for params in test_cases_params:\n        rotations = params[\"rotations\"]\n        sigma = params[\"sigma\"]\n        num_measurements = len(rotations)\n\n        # 1. Generate true vectors and noisy measurements\n        v_k_list = [R @ g0 for R in rotations]\n        v_k_array = np.array(v_k_list)\n        \n        noise = rng.normal(0., sigma, size=(num_measurements, 3))\n        y_k_list = [(A_true @ v_k) + b_true + noise[k] for k, v_k in enumerate(v_k_list)]\n        y_k_array = np.array(y_k_list)\n\n        # 2. Construct the design matrix H for the decoupled systems\n        H = np.ones((num_measurements, 4))\n        H[:, :3] = v_k_array\n        \n        # Construct the full 3N x 12 matrix W to check global identifiability\n        W_full = kron(np.identity(3), H)\n\n        # 3. Check identifiability by computing the rank of the design matrix\n        rank_W = np.linalg.matrix_rank(W_full)\n        is_identifiable = (rank_W == 12)\n\n        # 4. Solve for A_hat and b_hat using numerically stable least squares\n        A_hat = np.zeros((3, 3))\n        b_hat = np.zeros(3)\n\n        # Solve for each row of A and element of b independently\n        yx = y_k_array[:, 0]\n        yy = y_k_array[:, 1]\n        yz = y_k_array[:, 2]\n\n        sol_x, _, _, _ = np.linalg.lstsq(H, yx, rcond=None)\n        sol_y, _, _, _ = np.linalg.lstsq(H, yy, rcond=None)\n        sol_z, _, _, _ = np.linalg.lstsq(H, yz, rcond=None)\n\n        A_hat[0, :] = sol_x[:3]\n        b_hat[0] = sol_x[3]\n        A_hat[1, :] = sol_y[:3]\n        b_hat[1] = sol_y[3]\n        A_hat[2, :] = sol_z[:3]\n        b_hat[2] = sol_z[3]\n\n        # 5. Compute relative estimation errors\n        norm_A_true = norm(A_true, 'fro')\n        rel_err_A = norm(A_hat - A_true, 'fro') / norm_A_true\n        \n        norm_b_true = norm(b_true)\n        # Handle division by zero if b_true is the zero vector\n        if norm_b_true == 0:\n            rel_err_b = norm(b_hat)\n        else:\n            rel_err_b = norm(b_hat - b_true) / norm_b_true\n\n        results.extend([is_identifiable, rank_W, rel_err_A, rel_err_b])\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "拥有可靠的传感器数据后，下一步是构建能够捕捉有意义行为构念的特征。移动模式反映了个体在何处以及多大范围内活动，是数字表型的基石，并与抑郁、社交参与等健康结果相关。本练习  要求您将原始的GPS坐标转换为一个简洁而强大的概括性指标。您将推导并计算“回转半径”（radius of gyration），该指标量化了个体位置的空间离散程度，为模拟其日常生活空间提供了一个关键特征。",
            "id": "4557417",
            "problem": "一部用于数字表型分析的智能手机，在一周内每天被动收集一次全球定位系统 (GPS) 坐标（纬度和经度对），从而产生七个位置点。在移动性分析中，需要一个标量摘要来捕捉这些位置点相对于其中心趋势的空间离散度。请从二维欧几里得平面中有限点集的质心定义以及离散分布的二阶中心矩出发，推导出一个用于衡量各点到其质心典型距离的标量表达式。然后，实现一个计算过程，该过程使用小区域切平面近似，将给定周内七个地理坐标从以度为单位的经纬度映射到以米为单位的局部平面坐标系中，并为每个提供的测试用例评估其标量离散度。\n\n对于小区域，请使用以下经过充分测试的大地测量近似。设地球半径为 $R = 6371000$ 米。对于一组 $N$ 个位置，其经纬度以度为单位表示为 $\\{(\\phi_i^{\\text{deg}}, \\lambda_i^{\\text{deg}})\\}_{i=1}^{N}$，首先将角度转换为弧度 $\\phi_i = \\phi_i^{\\text{deg}} \\cdot \\pi/180$ 和 $\\lambda_i = \\lambda_i^{\\text{deg}} \\cdot \\pi/180$。设 $(\\phi_0, \\lambda_0)$ 为该点集以弧度为单位的平均纬度和经度。定义以米为单位的局部东-北坐标如下：\n$$\nx_i = R \\cos(\\phi_0) \\, (\\lambda_i - \\lambda_0), \\quad y_i = R \\, (\\phi_i - \\phi_0).\n$$\n将 $\\mathbf{x}_i = (x_i, y_i)$ 视为平面位置，并继续计算 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$ 所需的标量离散度。\n\n您的程序必须应用上述步骤，并为以下测试套件生成结果。给定的角度单位是度。所有输出必须以米为单位表示，并四舍五入到三位小数。最终输出必须是单行文本，包含一个由方括号括起来的逗号分隔列表。\n\n测试套件（每行为一个周数据集）：\n- 案例 A (城市常规路线，Boston地区，七个每日位置):\n$(\\,$$42.3601$$,\\,$$-71.0589$$\\,)$, $(\\,$$42.3736$$,\\,$$-71.1097$$\\,)$, $(\\,$$42.3467$$,\\,$$-71.0972$$\\,)$, $(\\,$$42.3954$$,\\,$$-71.1056$$\\,)$, $(\\,$$42.3320$$,\\,$$-71.1167$$\\,)$, $(\\,$$42.3521$$,\\,$$-71.0645$$\\,)$, $(\\,$$42.4075$$,\\,$$-71.1190$$\\,)$.\n- 案例 B (退化的相同位置边界情况):\n$(\\,$$42.3601$$,\\,$$-71.0589$$\\,)$ 重复 $7$ 次。\n- 案例 C (近赤道城市常规路线，Singapore地区，七个每日位置):\n$(\\,$$1.3521$$,\\,$$103.8198$$\\,)$, $(\\,$$1.3000$$,\\,$$103.8000$$\\,)$, $(\\,$$1.3700$$,\\,$$103.9500$$\\,)$, $(\\,$$1.2800$$,\\,$$103.8400$$\\,)$, $(\\,$$1.3300$$,\\,$$103.7000$$\\,)$, $(\\,$$1.3600$$,\\,$$103.8200$$\\,)$, $(\\,$$1.3100$$,\\,$$103.7700$$\\,)$.\n- 案例 D (高纬度常规路线，Helsinki地区，七个每日位置):\n$(\\,$$60.1699$$,\\,$$24.9384$$\\,)$, $(\\,$$60.1730$$,\\,$$24.8440$$\\,)$, $(\\,$$60.1840$$,\\,$$24.9500$$\\,)$, $(\\,$$60.2200$$,\\,$$25.0800$$\\,)$, $(\\,$$60.3000$$,\\,$$25.0400$$\\,)$, $(\\,$$60.1500$$,\\,$$25.0100$$\\,)$, $(\\,$$60.1200$$,\\,$$24.7000$$\\,)$.\n- 案例 E (单点边界情况):\n$(\\,$$34.0522$$,\\,$$-118.2437$$\\,)$.\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如 $$[r_A, r_B, r_C, r_D, r_E]$$，其中每个条目是对应案例的标量离散度（以米为单位），四舍五入到三位小数。不应打印任何额外文本。",
            "solution": "用户提供的问题经评估为有效。它基于统计学和大地测量学的标准原理，具有科学依据，是一个目标明确、数据充分的适定问题，并以客观、正式的语言表述。该问题与数字表型分析领域相关，并有唯一且可验证的解。\n\n该问题要求推导并实现一种用于衡量一组全球定位系统 (GPS) 坐标空间离散度的标量度量。推导过程从基本统计概念出发，并应用于通过大地测量近似获得的平面坐标。\n\n**1. 标量离散度度量的推导**\n\n目标是定义一个标量，用于表示一组点与其中心趋势的典型距离。该量基于质心和二阶中心矩的概念推导得出。\n\n设在二维欧几里得平面中，有一组 $N$ 个点，表示为 $\\{\\mathbf{x}_i = (x_i, y_i)\\}_{i=1}^{N}$。\n\n首先，这些点的中心趋势由其质心 $\\bar{\\mathbf{x}}$ 给出，质心是位置向量的算术平均值：\n$$\n\\bar{\\mathbf{x}} = (\\bar{x}, \\bar{y}) = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf{x}_i = \\left( \\frac{1}{N} \\sum_{i=1}^{N} x_i, \\frac{1}{N} \\sum_{i=1}^{N} y_i \\right)\n$$\n\n接下来，我们寻找一个围绕该质心的离散度度量。对于一维数值分布 $\\{z_i\\}_{i=1}^{N}$，其二阶中心矩是方差 $\\sigma_z^2$，定义为各数值与均值 $\\bar{z}$ 离差平方的平均值：\n$$\n\\sigma_z^2 = \\frac{1}{N} \\sum_{i=1}^{N} (z_i - \\bar{z})^2\n$$\n方差的平方根，即标准差 $\\sigma_z$，提供了一个与原始数据单位相同的离散程度度量。\n\n为将此概念推广到二维点分布，我们考虑每个点 $\\mathbf{x}_i$ 到质心 $\\bar{\\mathbf{x}}$ 的欧几里得距离的平方，即 $d_i^2 = ||\\mathbf{x}_i - \\bar{\\mathbf{x}}||^2$。这些平方距离的均值是类似于方差的标量离散度度量：\n$$\n\\text{Mean Squared Distance} = \\frac{1}{N} \\sum_{i=1}^{N} ||\\mathbf{x}_i - \\bar{\\mathbf{x}}||^2 = \\frac{1}{N} \\sum_{i=1}^{N} \\left( (x_i - \\bar{x})^2 + (y_i - \\bar{y})^2 \\right)\n$$\n通过展开求和，该表达式等价于各坐标方差之和：\n$$\n= \\left( \\frac{1}{N} \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\right) + \\left( \\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\bar{y})^2 \\right) = \\sigma_x^2 + \\sigma_y^2\n$$\n这个量 $\\sigma_x^2 + \\sigma_y^2$ 是点分布协方差矩阵的迹，可作为二阶中心矩的标量推广。\n\n为了得到一个以原始长度单位（米）表示的“典型距离”度量，我们取均方距离的平方根。这个我们记为 $S_d$ 的度量，在地理学中通常称为标准距离，在物理学中称为回转半径。\n$$\nS_d = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||\\mathbf{x}_i - \\bar{\\mathbf{x}}||^2} = \\sqrt{\\sigma_x^2 + \\sigma_y^2}\n$$\n这是各点到其质心的均方根距离，也就是需要计算的标量离散度度量。\n\n**2. 计算步骤**\n\n实现过程遵循一个两步流程：首先进行坐标投影，然后评估离散度度量 $S_d$。\n\n**步骤 2a：大地坐标到平面坐标的转换**\n给定一组以度为单位的 $N$ 个地理坐标 $\\{(\\phi_i^{\\text{deg}}, \\lambda_i^{\\text{deg}})\\}_{i=1}^{N}$，应用以下转换。地球半径取为 $R = 6371000$ 米。\n\n1.  将所有纬度和经度值从度转换为弧度：\n    $$ \\phi_i = \\phi_i^{\\text{deg}} \\cdot \\frac{\\pi}{180}, \\quad \\lambda_i = \\lambda_i^{\\text{deg}} \\cdot \\frac{\\pi}{180} $$\n2.  计算参考点 $(\\phi_0, \\lambda_0)$，即弧度坐标的均值：\n    $$ \\phi_0 = \\frac{1}{N} \\sum_{i=1}^{N} \\phi_i, \\quad \\lambda_0 = \\frac{1}{N} \\sum_{i=1}^{N} \\lambda_i $$\n3.  将每个点 $(\\phi_i, \\lambda_i)$ 投影到以参考点为中心的局部切平面，以获得以米为单位的东-北坐标 $(x_i, y_i)$：\n    $$\n    x_i = R \\cos(\\phi_0) \\, (\\lambda_i - \\lambda_0)\n    $$\n    $$\n    y_i = R \\, (\\phi_i - \\phi_0)\n    $$\n\n**步骤 2b：离散度度量的评估**\n有了平面坐标集 $\\{(x_i, y_i)\\}_{i=1}^{N}$，我们现在计算 $S_d$。投影方式的选择带来了一个关键的简化。投影坐标的质心 $(\\bar{x}, \\bar{y})$ 位于原点 $(0, 0)$。这是因为：\n$$\n\\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x_i = \\frac{1}{N} \\sum_{i=1}^{N} R \\cos(\\phi_0) (\\lambda_i - \\lambda_0) = R \\cos(\\phi_0) \\left( \\left(\\frac{1}{N} \\sum_{i=1}^{N} \\lambda_i\\right) - \\lambda_0 \\right) = R \\cos(\\phi_0) (\\lambda_0 - \\lambda_0) = 0\n$$\n同样地，$\\bar{y} = 0$。\n\n将 $\\bar{x}=0$ 和 $\\bar{y}=0$ 代入 $S_d$ 的表达式中：\n$$\nS_d = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^{N} \\left( (x_i - 0)^2 + (y_i - 0)^2 \\right) } = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^{N} (x_i^2 + y_i^2) }\n$$\n因此，标量离散度就是投影平面上位置向量大小的均方根。\n\n特殊情况：对于 $N=1$ 个点（案例 E）或 $N$ 个相同的点（案例 B），每个点都与质心相同。偏差 $(x_i - \\bar{x})$ 和 $(y_i - \\bar{y})$ 均为零，导致离散度 $S_d = 0$。该实现能正确处理这些情况。\n\n以下程序为提供的测试套件实现了这一逻辑。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the scalar dispersion for sets of GPS coordinates.\n    The scalar dispersion is defined as the standard distance (or radius of gyration),\n    which is the root-mean-square distance of points from their centroid.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (urban routine, Boston-area, seven daily positions):\n        [\n            (42.3601, -71.0589), (42.3736, -71.1097), (42.3467, -71.0972),\n            (42.3954, -71.1056), (42.3320, -71.1167), (42.3521, -71.0645),\n            (42.4075, -71.1190)\n        ],\n        # Case B (degenerate identical-positions boundary case):\n        [\n            (42.3601, -71.0589), (42.3601, -71.0589), (42.3601, -71.0589),\n            (42.3601, -71.0589), (42.3601, -71.0589), (42.3601, -71.0589),\n            (42.3601, -71.0589)\n        ],\n        # Case C (near-equator urban routine, Singapore-area, seven daily positions):\n        [\n            (1.3521, 103.8198), (1.3000, 103.8000), (1.3700, 103.9500),\n            (1.2800, 103.8400), (1.3300, 103.7000), (1.3600, 103.8200),\n            (1.3100, 103.7700)\n        ],\n        # Case D (high-latitude routine, Helsinki-area, seven daily positions):\n        [\n            (60.1699, 24.9384), (60.1730, 24.8440), (60.1840, 24.9500),\n            (60.2200, 25.0800), (60.3000, 25.0400), (60.1500, 25.0100),\n            (60.1200, 24.7000)\n        ],\n        # Case E (single-position boundary case):\n        [\n            (34.0522, -118.2437)\n        ]\n    ]\n\n    R = 6371000.0  # Earth's mean radius in meters\n    \n    results = []\n    for case_coords in test_cases:\n        coords_deg = np.array(case_coords, dtype=np.float64)\n        N = coords_deg.shape[0]\n\n        # For a single point or identical points, the dispersion is 0.\n        # The logic below handles the identical points case naturally.\n        # The single point case is a boundary condition worth checking explicitly.\n        if N == 1:\n            result_str = \"0.000\"\n        else:\n            # Step 1: Convert degrees to radians\n            coords_rad = np.deg2rad(coords_deg)\n            \n            # Step 2: Calculate the mean latitude and longitude for the tangent plane center\n            phi0, lambda0 = np.mean(coords_rad, axis=0)\n\n            # Separate latitude (phi) and longitude (lambda) columns for clarity\n            phi_i = coords_rad[:, 0]\n            lambda_i = coords_rad[:, 1]\n            \n            # Step 3: Project to local East-North coordinates (x, y)\n            x_i = R * np.cos(phi0) * (lambda_i - lambda0)\n            y_i = R * (phi_i - phi0)\n            \n            # Step 4: Calculate the scalar dispersion (standard distance)\n            # This is the root-mean-square distance from the centroid.\n            # As derived, the centroid of the (x_i, y_i) coordinates is (0, 0).\n            # So, the formula simplifies to sqrt(mean(x_i^2 + y_i^2)).\n            scalar_dispersion = np.sqrt(np.mean(x_i**2 + y_i**2))\n            \n            # Format the result to three decimal places\n            result_str = f\"{scalar_dispersion:.3f}\"\n        \n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "纵向数字表型研究中的一个重大挑战是数据缺失，这通常由电池耗尽、连接问题或用户依从性差导致。本练习  介绍了一种强大的机器学习技术来处理这类缺失数据，特别是当整个传感器模态在某些时段完全缺失时。我们利用一个核心假设——复杂的人类行为可由少数潜在因素驱动，因此可以将多模态数据矩阵视为近似低秩的。您将实现一个凸优化算法来“补全”这个矩阵，重构缺失的信息，从而对行为进行更全面的分析。",
            "id": "4557361",
            "problem": "考虑一项多模态数字表型研究，其中来自移动和可穿戴传感器的参与者级别特征被汇总成一个矩形数据矩阵。令 $X^\\star \\in \\mathbb{R}^{n \\times p}$ 表示潜在的、无噪声的特征矩阵，其中每一列对应一个来自特定模态块的特征（例如，加速度测量、心率、睡眠）。在实际部署中，由于设备不可用，整个模态可能会在某些时段内缺失，并且由于异步采样和传输失败，额外的随机条目也可能缺失。假设存在一个由少量行为因素生成的低秩潜在结构，因此 $X^\\star$ 可以被两个低维矩阵的乘积很好地近似。\n\n给定一个含噪声的测量矩阵 $M \\in \\mathbb{R}^{n \\times p}$ 和一个二元掩码算子 $P_\\Omega:\\mathbb{R}^{n \\times p}\\rightarrow\\mathbb{R}^{n \\times p}$，该算子保留观测到的条目并将缺失条目置零。观测到的测量值满足\n$$\nM \\;=\\; X^\\star \\;+\\; E,\n$$\n其中 $E$ 是具有独立同分布条目的加性噪声。观测到的索引集合由 $\\Omega \\subseteq \\{1,\\dots,n\\}\\times\\{1,\\dots,p\\}$ 表示，并且 $P_\\Omega$ 定义为\n$$\n\\left[P_\\Omega(X)\\right]_{ij} \\;=\\;\n\\begin{cases}\nX_{ij}, & (i,j)\\in\\Omega,\\\\\n0, & (i,j)\\notin\\Omega.\n\\end{cases}\n$$\n\n假设模态是块缺失的：对于留出的模态块，其对应列中的所有条目都将从 $\\Omega$ 中移除（因此在重建过程中是未观测的），并且仅用于评估。重建问题被构建为一个使用核范数惩罚的凸优化问题（核范数是奇异值的总和）：\n$$\n\\min_{X\\in\\mathbb{R}^{n\\times p}} \\;\\; \\frac{1}{2}\\,\\big\\|P_\\Omega(X - M)\\big\\|_F^2 \\;+\\; \\lambda\\,\\|X\\|_*,\n$$\n其中 $\\|\\cdot\\|_F$ 表示 Frobenius 范数，$\\|\\cdot\\|_*$ 表示核范数，$\\lambda > 0$ 是一个正则化参数。\n\n您的任务是实现一个基于带有奇异值阈值化的近端梯度迭代的求解器，以近似地最小化上述目标函数，然后在留出的传感器（从 $\\Omega$ 中移除的完整列块）上评估重建质量。使用仅限于留出列的归一化均方根误差 (NRMSE)：\n$$\n\\mathrm{NRMSE} \\;=\\; \\frac{\\sqrt{\\sum_{(i,j)\\in\\Theta} \\left(X_{ij}-X^\\star_{ij}\\right)^2}}{\\sqrt{\\sum_{(i,j)\\in\\Theta} \\left(X^\\star_{ij}\\right)^2}},\n$$\n其中 $\\Theta$ 索引了留出列的所有条目。该值为无量纲量，必须以小数形式报告。\n\n在您的推导和实现中需要假设的基本原理：\n- 低秩潜在因子模型 $X^\\star \\approx U V^\\top$，其中 $U\\in\\mathbb{R}^{n\\times r}$ 且 $V\\in\\mathbb{R}^{p\\times r}$，对于一个小的 $r$。\n- $P_\\Omega$ 的正交投影性质，即 $P_\\Omega^2 = P_\\Omega$ 和 $\\|P_\\Omega\\|_2 = 1$。\n- 核范数的近端算子是奇异值软阈值化。\n\n实现一个完整的程序，该程序：\n- 通过从标准正态分布中采样条目来生成 $U$ 和 $V$ 以合成 $X^\\star$，构成 $X^\\star = U V^\\top$，并通过特定于模态的正标量来缩放模态块内的列，以反映异构的传感器振幅。\n- 添加标准差为 $\\sigma$ 的独立高斯噪声以构成 $M$。\n- 通过从指定的留出模态块中移除所有条目，并从剩余列中进一步移除随机比例的条目，来构建观测掩码 $P_\\Omega$。\n- 使用步长为 $\\mu$ 的近端梯度迭代和阈值为 $\\mu\\lambda$ 的奇异值软阈值化来求解核范数正则化的目标函数，如果需要，可使用加速。使用零矩阵或观测数据进行初始化，并迭代直至达到最大迭代次数或关于相对 Frobenius 范数变化的容差。\n- 仅在留出的模态列上计算 NRMSE。\n\n测试套件。您的程序必须运行以下三个测试用例，每个用例由一个参数元组 $(n,p,r,\\sigma,\\lambda,\\mu,\\mathrm{max\\_iters},\\mathrm{tol},\\mathrm{seed},\\mathrm{block\\_sizes},\\mathrm{held\\_out\\_blocks},\\mathrm{missing\\_frac})$ 定义，其中模态块由 $\\mathrm{block\\_sizes}$ 中的连续列大小定义，$\\mathrm{held\\_out\\_blocks}$ 中的索引指向从 $0$ 开始的块位置。\n\n- 用例 1（一般情况，块缺失并伴有中度随机缺失）：\n  - $(n,p,r) = (\\,48,\\,30,\\,3\\,)$,\n  - $\\sigma = 0.05$,\n  - $\\lambda = 0.8$,\n  - $\\mu = 1.0$,\n  - $\\mathrm{max\\_iters} = 500$,\n  - $\\mathrm{tol} = 10^{-6}$,\n  - $\\mathrm{seed} = 42$,\n  - $\\mathrm{block\\_sizes} = [\\,10,\\,10,\\,10\\,]$,\n  - $\\mathrm{held\\_out\\_blocks} = \\{\\,1\\,\\}$,\n  - $\\mathrm{missing\\_frac} = 0.25$（在非留出列上）。\n\n- 用例 2（边界情况，无噪声且训练模态完全观测）：\n  - $(n,p,r) = (\\,48,\\,30,\\,2\\,)$,\n  - $\\sigma = 0.0$,\n  - $\\lambda = 0.1$,\n  - $\\mu = 1.0$,\n  - $\\mathrm{max\\_iters} = 500$,\n  - $\\mathrm{tol} = 10^{-7}$,\n  - $\\mathrm{seed} = 7$,\n  - $\\mathrm{block\\_sizes} = [\\,10,\\,10,\\,10\\,]$,\n  - $\\mathrm{held\\_out\\_blocks} = \\{\\,2\\,\\}$,\n  - $\\mathrm{missing\\_frac} = 0.0$（在非留出列上）。\n\n- 用例 3（边缘情况，严重缺失且有多个留出块）：\n  - $(n,p,r) = (\\,60,\\,36,\\,2\\,)$,\n  - $\\sigma = 0.1$,\n  - $\\lambda = 1.0$,\n  - $\\mu = 1.0$,\n  - $\\mathrm{max\\_iters} = 600$,\n  - $\\mathrm{tol} = 10^{-6}$,\n  - $\\mathrm{seed} = 123$,\n  - $\\mathrm{block\\_sizes} = [\\,12,\\,12,\\,12\\,]$,\n  - $\\mathrm{held\\_out\\_blocks} = \\{\\,0,\\,2\\,\\}$,\n  - $\\mathrm{missing\\_frac} = 0.6$（在非留出列上）。\n\n最终输出格式。您的程序应生成单行输出，其中包含按顺序排列的三个用例的 NRMSE 结果，格式为方括号内以逗号分隔的列表。每个值必须四舍五入到 $4$ 位小数，例如 $\\left[\\,0.1234,0.0000,0.5678\\,\\right]$。不应打印任何额外文本。NRMSE 是无量纲的，必须以上述指定格式的小数表示。",
            "solution": "经过严格的验证过程，用户提供的问题被评估为**有效**。所有提供的数据和条件在科学上都是合理的、一致的且适定的。该问题是机器学习和信号处理领域中一个标准的、尽管复杂的实现任务，特别是低秩矩阵补全，并直接且现实地应用于数字表型数据。\n\n在此提供一个完整的解决方案，详细阐述其理论基础、算法设计和实现策略。\n\n**1. 问题表述与目标函数**\n\n问题的核心是从一个含噪声且不完整的观测矩阵 $M \\in \\mathbb{R}^{n \\times p}$ 中重建一个低秩矩阵 $X^\\star \\in \\mathbb{R}^{n \\times p}$。潜在真实矩阵与观测值之间的关系由 $M = X^\\star + E$ 给出，其中 $E$ 是一个独立同分布（i.i.d.）的噪声矩阵。观测值仅在集合 $\\Omega$ 中的索引 $(i,j)$ 处可用。这被表述为以下凸优化问题：\n$$\n\\min_{X\\in\\mathbb{R}^{n\\times p}} \\;\\; \\frac{1}{2}\\,\\big\\|P_\\Omega(X - M)\\big\\|_F^2 \\;+\\; \\lambda\\,\\|X\\|_*\n$$\n该目标函数是复合的，由两项组成。第一项 $f(X) = \\frac{1}{2}\\,\\big\\|P_\\Omega(X - M)\\big\\|_F^2$ 是一个数据保真项，它惩罚估计值 $X$ 和测量值 $M$ 在观测条目上差异的 Frobenius 范数的平方。该函数是凸且可微的。第二项 $g(X) = \\lambda\\,\\|X\\|_*$ 是一个正则化项。这里，$\\|X\\|_* = \\sum_i \\sigma_i(X)$ 是核范数（$X$ 的奇异值之和），它是矩阵秩的一个凸代理。该项促使解 $X$ 是低秩的。参数 $\\lambda > 0$ 控制数据保真度与低秩结构之间的权衡。\n\n**2. 算法：近端梯度法**\n\n目标函数具有 $\\min_X f(X) + g(X)$ 的结构，其中 $f$ 是平滑的，而 $g$ 是凸但不可微的（由于奇异值中隐含的绝对值函数）。这种结构非常适合使用近端梯度算法。此方法的迭代更新规则是：\n$$\nX_{k+1} = \\mathrm{prox}_{\\mu g}\\left(X_k - \\mu \\nabla f(X_k)\\right)\n$$\n其中 $k$ 是迭代索引，$\\mu > 0$ 是步长，$\\mathrm{prox}_{\\mu g}$ 是函数 $\\mu g$ 的近端算子。\n\n**梯度步**：需要计算平滑项 $f(X)$ 的梯度。利用矩阵微积分以及投影 $P_\\Omega$ 是自伴和幂等（$P_\\Omega = P_\\Omega^\\top$, $P_\\Omega^2=P_\\Omega$）的性质，梯度为：\n$$\n\\nabla f(X) = P_\\Omega\\left(P_\\Omega(X) - P_\\Omega(M)\\right) = P_\\Omega(X - M)\n$$\n梯度下降步骤通过沿负梯度方向移动来更新当前估计 $X_k$：\n$$\nY_k = X_k - \\mu \\nabla f(X_k) = X_k - \\mu P_\\Omega(X_k - M)\n$$\n为保证收敛，步长 $\\mu$ 必须小于或等于 $1/L$，其中 $L$ 是 $\\nabla f$ 的 Lipschitz 常数。对于 $\\nabla f(X) = P_\\Omega(X-M)$，Lipschitz 常数为 $\\|P_\\Omega\\|_2^2=1$。问题指定 $\\mu=1$，满足此条件。\n\n**近端步**：核范数的近端算子 $\\mathrm{prox}_{\\tau\\|\\cdot\\|_*}(Y)$ 是奇异值阈值化 (SVT) 算子，记为 $D_\\tau(Y)$。如果 $Y$ 的奇异值分解 (SVD) 为 $Y = U \\Sigma V^\\top$，其中 $\\Sigma = \\mathrm{diag}(\\sigma_1, \\sigma_2, \\dots)$，则 SVT 算子定义为：\n$$\nD_\\tau(Y) = U \\Sigma_\\tau V^\\top \\quad \\text{with} \\quad [\\Sigma_\\tau]_{ii} = \\max(\\sigma_i - \\tau, 0)\n$$\n在我们的例子中，函数是 $g(X) = \\lambda \\|X\\|_*$，因此应用近端算子时使用的阈值为 $\\tau = \\mu\\lambda$。在第 $k+1$ 次迭代中，对估计值 $X$ 的完整更新变为：\n$$\nX_{k+1} = D_{\\mu\\lambda}(Y_k) = D_{\\mu\\lambda}\\left(X_k - \\mu P_\\Omega(X_k - M)\\right)\n$$\n算法以 $X_0 = 0$ 初始化，并进行迭代，直到达到最大迭代次数，或者 $X$ 的 Frobenius 范数的相对变化量 $\\|X_{k+1}-X_k\\|_F / \\|X_k\\|_F$ 低于指定的容差 $\\mathrm{tol}$。\n\n**3. 数据模拟流程**\n\n为了测试算法，按照规定实现了一个数据生成流程：\n- **潜在矩阵 ($X^\\star$)**：从标准正态分布中采样两个矩阵 $U \\in \\mathbb{R}^{n \\times r}$ 和 $V \\in \\mathbb{R}^{p \\times r}$。潜在低秩矩阵由 $X^\\star = UV^\\top$ 形成。为模拟不同的传感器尺度，将 $X^\\star$ 中对应于不同模态块的列乘以从均匀分布 $\\mathcal{U}(0.5, 1.5)$ 中采样的不同正标量。\n- **测量矩阵 ($M$)**：生成一个均值为零、标准差为 $\\sigma$ 的独立同分布高斯噪声矩阵 $E \\in \\mathbb{R}^{n \\times p}$，并将其加到潜在矩阵上，以产生含噪声的测量矩阵 $M = X^\\star + E$。\n- **观测与评估掩码**：生成两个布尔掩码。评估掩码 $\\Theta$ 标识被指定为 `held_out_blocks` 的列。观测掩码 $\\Omega$ 是其补集，然后通过随机将其 `True` 条目的一部分（比例为 `missing_frac`）设置为 `False` 来进一步下采样。投影算子 $P_\\Omega(A)$ 实现为矩阵 $A$ 与对应于 $\\Omega$ 的二元掩码进行逐元素相乘。\n\n为每个测试用例设置种子的单个随机数生成器确保整个过程是确定性和可复现的。\n\n**4. 性能评估**\n\n重建矩阵 $\\hat{X}$ 的质量使用归一化均方根误差 (NRMSE) 进行评估，该评估在由集合 $\\Theta$ 索引的留出列上进行。NRMSE 定义为：\n$$\n\\mathrm{NRMSE} = \\frac{\\|P_\\Theta(\\hat{X} - X^\\star)\\|_F}{\\|P_\\Theta(X^\\star)\\|_F} = \\frac{\\sqrt{\\sum_{(i,j)\\in\\Theta} \\left(\\hat{X}_{ij}-X^\\star_{ij}\\right)^2}}{\\sqrt{\\sum_{(i,j)\\in\\Theta} \\left(X^\\star_{ij}\\right)^2}}\n$$\n该指标量化了未观测模态中相对于真实信号幅度的重建误差，提供了一个尺度无关的性能度量。\n\n**5. 实现总结**\n\n该解决方案被封装在一个单独的 Python 程序中。一个主函数遍历指定的测试用例。对于每个用例，它初始化一个带种子的随机数生成器，并调用辅助函数来生成数据和掩码。然后，它运行近端梯度求解器以获得重建矩阵。最后，它在留出的列上计算 NRMSE 并存储结果。处理完所有用例后，程序以逗号分隔的列表形式打印 NRMSE 值，并格式化为四位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the matrix completion problem for all test cases.\n    \"\"\"\n\n    def generate_data(n, p, r, sigma, block_sizes, rng):\n        \"\"\"\n        Generates the latent low-rank matrix X_star and its noisy observation M.\n        \"\"\"\n        U = rng.standard_normal(size=(n, r))\n        V = rng.standard_normal(size=(p, r))\n        X_star_unscaled = U @ V.T\n        X_star = np.copy(X_star_unscaled)\n\n        # Scale columns by modality blocks to simulate heterogeneous sensor amplitudes\n        num_blocks = len(block_sizes)\n        scales = rng.uniform(0.5, 1.5, size=num_blocks)\n        \n        col_idx = 0\n        for i in range(num_blocks):\n            block_size = block_sizes[i]\n            X_star[:, col_idx : col_idx + block_size] *= scales[i]\n            col_idx += block_size\n            \n        # Add Gaussian noise\n        noise = rng.normal(0, sigma, size=(n, p))\n        M = X_star + noise\n        \n        return X_star, M\n\n    def create_masks(n, p, block_sizes, held_out_blocks, missing_frac, rng):\n        \"\"\"\n        Creates the observation mask (omega_mask) and evaluation mask (theta_mask).\n        \"\"\"\n        # theta_mask identifies held-out columns for evaluation\n        theta_mask = np.zeros((n, p), dtype=bool)\n        \n        block_col_indices = []\n        col_idx = 0\n        for size in block_sizes:\n            block_col_indices.append(list(range(col_idx, col_idx + size)))\n            col_idx += size\n            \n        held_out_cols = []\n        for block_idx in held_out_blocks:\n            held_out_cols.extend(block_col_indices[block_idx])\n            \n        if held_out_cols:\n            theta_mask[:, held_out_cols] = True\n        \n        # omega_mask identifies observed entries for training\n        omega_mask = np.ones((n, p), dtype=bool)\n        if held_out_cols:\n            omega_mask[:, held_out_cols] = False\n        \n        # Introduce additional random missingness in non-held-out columns\n        if missing_frac > 0.0:\n            training_cols_mask = ~theta_mask[0, :]\n            training_cols_indices = np.where(training_cols_mask)[0]\n            \n            if len(training_cols_indices) > 0:\n                n_training_entries = n * len(training_cols_indices)\n                n_to_remove = int(round(n_training_entries * missing_frac))\n                \n                # Get all (row, col) pairs in training columns\n                row_indices_grid, col_indices_grid = np.meshgrid(\n                    np.arange(n), training_cols_indices, indexing='ij'\n                )\n                flat_row_indices = row_indices_grid.flatten()\n                flat_col_indices = col_indices_grid.flatten()\n                \n                # Randomly choose indices to set to False\n                indices_to_remove = rng.choice(\n                    n_training_entries, size=n_to_remove, replace=False\n                )\n                \n                rows_to_remove = flat_row_indices[indices_to_remove]\n                cols_to_remove = flat_col_indices[indices_to_remove]\n                \n                omega_mask[rows_to_remove, cols_to_remove] = False\n                \n        return omega_mask, theta_mask\n\n    def singular_value_thresholding(Y, threshold):\n        \"\"\"\n        Performs the singular value thresholding operation.\n        \"\"\"\n        U, s, Vt = np.linalg.svd(Y, full_matrices=False)\n        s_thresh = np.maximum(s - threshold, 0)\n        return (U * s_thresh) @ Vt\n\n    def matrix_completion_solver(M, omega_mask, lambda_val, mu, max_iters, tol):\n        \"\"\"\n        Solves the nuclear norm regularized matrix completion problem using\n        proximal gradient descent.\n        \"\"\"\n        n, p = M.shape\n        X = np.zeros((n, p))\n        \n        for _ in range(max_iters):\n            X_prev = np.copy(X)\n            \n            # Gradient descent step\n            grad = (X - M) * omega_mask\n            Y = X - mu * grad\n            \n            # Proximal mapping step (SVT)\n            threshold = mu * lambda_val\n            X = singular_value_thresholding(Y, threshold)\n            \n            # Check for convergence\n            change = np.linalg.norm(X - X_prev, 'fro')\n            norm_prev = np.linalg.norm(X_prev, 'fro')\n            if norm_prev > 0:\n                rel_change = change / norm_prev\n            else: # Handle case X_prev is the zero matrix\n                rel_change = change / (1e-9 + np.linalg.norm(X, 'fro'))\n\n            if rel_change  tol:\n                break\n                \n        return X\n\n    def calculate_nrmse(X_recon, X_star, theta_mask):\n        \"\"\"\n        Calculates the Normalized Root Mean Squared Error on held-out columns.\n        \"\"\"\n        # Use boolean indexing to select elements from held-out columns\n        diff_held_out = (X_recon - X_star)[theta_mask]\n        true_held_out = X_star[theta_mask]\n        \n        numerator = np.linalg.norm(diff_held_out)\n        denominator = np.linalg.norm(true_held_out)\n        \n        if denominator == 0:\n            return 0.0 if numerator == 0.0 else np.inf\n            \n        return numerator / denominator\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (48, 30, 3, 0.05, 0.8, 1.0, 500, 1e-6, 42, [10, 10, 10], {1}, 0.25),\n        # Case 2\n        (48, 30, 2, 0.0, 0.1, 1.0, 500, 1e-7, 7, [10, 10, 10], {2}, 0.0),\n        # Case 3\n        (60, 36, 2, 0.1, 1.0, 1.0, 600, 1e-6, 123, [12, 12, 12], {0, 2}, 0.6)\n    ]\n\n    results = []\n    for params in test_cases:\n        (n, p, r, sigma, lambda_val, mu, max_iters, tol, seed, \n         block_sizes, held_out_blocks, missing_frac) = params\n\n        # Seed a random number generator for reproducibility of the entire case\n        rng = np.random.default_rng(seed)\n\n        # Generate data and masks\n        X_star, M = generate_data(n, p, r, sigma, block_sizes, rng)\n        omega_mask, theta_mask = create_masks(n, p, block_sizes, held_out_blocks, missing_frac, rng)\n        \n        # Solve for the reconstructed matrix\n        X_recon = matrix_completion_solver(M, omega_mask, lambda_val, mu, max_iters, tol)\n        \n        # Calculate NRMSE on the held-out data\n        nrmse = calculate_nrmse(X_recon, X_star, theta_mask)\n        results.append(nrmse)\n\n    # Format and print the final output as specified.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}