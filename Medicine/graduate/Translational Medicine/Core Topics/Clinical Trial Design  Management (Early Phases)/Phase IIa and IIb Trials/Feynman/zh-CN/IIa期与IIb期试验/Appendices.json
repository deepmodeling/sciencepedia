{
    "hands_on_practices": [
        {
            "introduction": "任何精心设计的临床试验都始于严谨的样本量计算，以确保其具有足够的统计功效来检测出具有临床意义的效应。这项基础练习不仅将从第一性原理出发进行推导，还将融入对患者脱落这一关键现实问题的考量，要求您调整招募目标以维持研究的完整性。掌握此技能对于规划高效且符合伦理的试验至关重要。",
            "id": "5044163",
            "problem": "一项转化医学中的IIa期概念验证性随机对照试验（RCT）比较了单一活性剂量与安慰剂对在$12$周时测量的连续性生物标志物的影响。假设两组分配相等，且个体结果独立同分布，共同标准差为 $\\sigma = 1.0$。临床上有意义的均值差异为 $\\Delta = 0.4$，支持活性剂量组。主要分析是在显著性水平 $\\alpha = 0.05$ 下对零假设 $H_{0}: \\Delta = 0$ 进行的双侧大样本$Z$检验。当忽略脱落时，设计目标是在 $H_{1}: \\Delta = 0.4$ 的条件下，检验效能达到 $1 - \\beta = 0.9$。\n\n基于各组样本量 $n$ 相等时均值差异的大样本正态近似，标准化检验统计量在 $H_{1}$ 下具有非零均值。本试验中的脱落预计是非信息性的（完全随机缺失）且与治疗无关，各组的恒定脱落率为 $\\pi = 0.15$，因此如果每组招募 $n$ 名受试者，则各组的预期可分析样本量为 $(1 - \\pi)\\,n$。\n\n从I类错误、II类错误的核心定义以及中心极限定理下均值差异的抽样分布出发，完成以下任务：\n- 当忽略脱落时，推导达到设计效能 $1 - \\beta = 0.9$ 所需的各组样本量 $n$。\n- 当脱落率为 $\\pi = 0.15$ 但招募人数仍保持为上述推导的忽略脱落的 $n$ 时，计算实现的效能。\n- 最后，确定扩增后的各组招募人数 $n'$，通过确保预期的可分析各组样本量等于忽略脱落的 $n$ 来恢复设计效能。\n\n将您的最终答案表示为 $n'$ 的单一数值，四舍五入到四位有效数字。最终答案中不要包含任何单位。所有比率请用小数或分数表示，不要使用百分号。",
            "solution": "该问题被评估为有效，因为它在科学上基于临床试验设计的标准统计理论，问题陈述清晰且提供了所有必要参数，并且表述客观。\n\n设 $n$ 为每组（活性剂量组和安慰剂组）的样本量。两组的样本量相等。设 $\\mu_T$ 和 $\\mu_P$ 分别为治疗人群和安慰剂人群的真实生物标志物均值。均值差异为 $\\Delta = \\mu_T - \\mu_P$。个体结果被假定为独立同分布，且具有共同标准差 $\\sigma = 1.0$。\n\n治疗组和安慰剂组的样本均值分别表示为 $\\bar{X}_T$ 和 $\\bar{X}_P$。均值差异的估计量为 $\\hat{\\Delta} = \\bar{X}_T - \\bar{X}_P$。根据中心极限定理，对于大样本量 $n$，$\\hat{\\Delta}$ 的抽样分布近似于正态分布。\n$\\hat{\\Delta}$ 的期望值为 $E[\\hat{\\Delta}] = \\mu_T - \\mu_P = \\Delta$。\n$\\hat{\\Delta}$ 的方差为 $\\text{Var}(\\hat{\\Delta}) = \\text{Var}(\\bar{X}_T) + \\text{Var}(\\bar{X}_P) = \\frac{\\sigma^2}{n} + \\frac{\\sigma^2}{n} = \\frac{2\\sigma^2}{n}$。\n$\\hat{\\Delta}$ 的标准误为 $SE(\\hat{\\Delta}) = \\sqrt{\\frac{2\\sigma^2}{n}} = \\sigma\\sqrt{\\frac{2}{n}}$。\n\n主要分析采用双侧大样本$Z$检验，检验零假设 $H_0: \\Delta = 0$ 与备择假设 $H_1: \\Delta \\neq 0$。在 $H_0$ 下的检验统计量为：\n$$ Z = \\frac{\\hat{\\Delta} - 0}{SE(\\hat{\\Delta})} = \\frac{\\hat{\\Delta}}{\\sigma\\sqrt{2/n}} $$\n对于显著性水平 $\\alpha = 0.05$，如果 $|Z| > z_{1-\\alpha/2}$，则拒绝零假设 $H_0$，其中 $z_{1-\\alpha/2}$ 是标准正态分布的 $(1-\\alpha/2)$-分位数。当 $\\alpha = 0.05$ 时，我们使用 $z_{1-0.05/2} = z_{0.975}$。\n\n检验的效能 $1-\\beta$ 是在某个特定的备择假设为真时，正确拒绝 $H_0$ 的概率。此处，设计目标是在 $H_1: \\Delta = 0.4$ 的条件下，效能达到 $1-\\beta = 0.9$。\n效能是在 $H_1$ 为真的条件下拒绝 $H_0$ 的概率：\n$$ 1-\\beta = P(\\text{reject } H_0 | \\Delta = 0.4) = P\\left(|Z| > z_{0.975} | \\Delta = 0.4\\right) $$\n由于 $\\Delta = 0.4 > 0$，拒绝主要由分布的右尾驱动。因此，我们可以通过只考虑上侧拒绝域来近似计算效能：\n$$ 1-\\beta \\approx P\\left(\\frac{\\hat{\\Delta}}{\\sigma\\sqrt{2/n}} > z_{0.975} | \\Delta = 0.4\\right) = P\\left(\\hat{\\Delta} > z_{0.975} \\sigma\\sqrt{\\frac{2}{n}} | \\Delta = 0.4\\right) $$\n为了评估这个概率，我们在 $H_1$ 下对 $\\hat{\\Delta}$ 进行标准化，此时其分布为 $N(\\Delta, \\frac{2\\sigma^2}{n})$：\n$$ 1-\\beta = P\\left(\\frac{\\hat{\\Delta} - \\Delta}{\\sigma\\sqrt{2/n}} > \\frac{z_{0.975} \\sigma\\sqrt{2/n} - \\Delta}{\\sigma\\sqrt{2/n}} \\right) = P\\left(Z' > z_{0.975} - \\frac{\\Delta}{\\sigma\\sqrt{2/n}}\\right) $$\n其中 $Z'$ 是一个标准正态随机变量。为使该概率等于 $1-\\beta$，累积分布函数的参数必须是 $z_{1-(1-\\beta)} = z_{\\beta}$。根据正态分布的对称性，有 $z_{\\beta} = -z_{1-\\beta}$。\n$$ -z_{1-\\beta} = z_{0.975} - \\frac{\\Delta \\sqrt{n}}{\\sigma\\sqrt{2}} $$\n整理后求解所需样本量 $n$，得到通用公式：\n$$ \\frac{\\Delta \\sqrt{n}}{\\sigma\\sqrt{2}} = z_{1-\\alpha/2} + z_{1-\\beta} $$\n$$ \\sqrt{n} = \\frac{\\sigma\\sqrt{2} (z_{1-\\alpha/2} + z_{1-\\beta})}{\\Delta} $$\n$$ n = \\frac{2\\sigma^2 (z_{1-\\alpha/2} + z_{1-\\beta})^2}{\\Delta^2} $$\n\n首先，我们推导在忽略脱落的情况下，达到设计效能所需的各组样本量 $n$。\n给定的参数是：\n$\\sigma = 1.0$\n$\\Delta = 0.4$\n$\\alpha = 0.05 \\implies z_{1-\\alpha/2} = z_{0.975} \\approx 1.95996$\n$1-\\beta = 0.9 \\implies \\beta = 0.1 \\implies z_{1-\\beta} = z_{0.9} \\approx 1.28155$\n\n将这些值代入 $n$ 的公式中：\n$$ n = \\frac{2(1.0)^2 (1.95996 + 1.28155)^2}{(0.4)^2} = \\frac{2 (3.24151)^2}{0.16} = \\frac{2(10.5074)}{0.16} \\approx 131.3425 $$\n这是每组所需的可分析受试者数量。\n\n其次，我们计算当每组招募人数保持在 $n \\approx 131.34$，但脱落率为 $\\pi = 0.15$ 时的实现效能。预期的各组可分析样本量变为 $n_{analyzable}$：\n$$ n_{analyzable} = (1 - \\pi)n = (1 - 0.15) \\times 131.3425 = 0.85 \\times 131.3425 \\approx 111.6411 $$\n实现的效能 $1-\\beta_{realized}$，通过求解 $z_{1-\\beta_{realized}}$ 来计算：\n$$ z_{1-\\beta_{realized}} = \\frac{\\Delta \\sqrt{n_{analyzable}}}{\\sigma\\sqrt{2}} - z_{1-\\alpha/2} = \\frac{0.4 \\sqrt{111.6411}}{1.0\\sqrt{2}} - 1.95996 $$\n$$ z_{1-\\beta_{realized}} \\approx \\frac{0.4 \\times 10.5660}{1.4142} - 1.95996 \\approx 2.9884 - 1.95996 \\approx 1.0284 $$\n实现的效能为 $\\Phi(1.0284) \\approx 0.848$，低于 $0.9$ 的目标。\n\n最后，我们确定扩增后的各组招募人数 $n'$，以将设计效能恢复到 $1-\\beta = 0.9$。为实现此目的，预期的可分析受试者数量必须等于最初所需的样本量 $n$。\n设 $n'$ 为扩增后的每组招募人数。预期的可分析样本量为 $(1-\\pi)n'$。我们将其设置为第一步中计算出的所需样本量 $n$：\n$$ (1-\\pi)n' = n $$\n$$ n' = \\frac{n}{1-\\pi} $$\n使用我们计算出的 $n$ 值：\n$$ n' = \\frac{131.3425}{1 - 0.15} = \\frac{131.3425}{0.85} \\approx 154.5206 $$\n问题要求将 $n'$ 的值四舍五入到四位有效数字。\n$$ n' \\approx 154.5 $$\n由于受试者人数必须是整数，在实际操作中，每组会招募 $155$ 名受试者。然而，问题要求的是按规定四舍五入的计算值。",
            "answer": "$$\n\\boxed{154.5}\n$$"
        },
        {
            "introduction": "IIb期试验的一个关键目标是为后续的III期研究确定合适的剂量。这通常通过使用如$E_{\\max}$模型等药效学模型来表征暴露-效应关系来实现。本练习要求您应用该模型，将一个期望的治疗效果反向换算为一个具体的口服剂量，这是模型引导的药物开发中的一项核心技能。",
            "id": "5044142",
            "problem": "在一项口服小分子疗法的IIb期（剂量范围探索）试验中，研究者们使用了一个基于受体占有率原理、并加入了基线效应的可饱和最大效应模型来表征暴露-反应关系。在线性药代动力学（PK）条件下，给药间隔内的全身暴露量与按绝对口服生物利用度缩放后的口服给药剂量成正比。具体来说，假设以下经过充分检验的组成部分：\n- 效应终点被建模为一个加和的基线反应加上一个与最大效应模型一致的可饱和增量效应：如果暴露指数为 $X$，则效应为 $E=E_{0}+E_{\\max}\\,\\frac{X}{ED_{50}+X}$。\n- 暴露指数与全身可用剂量成正比，对于所考虑的给药方案，该比例关系被归一化为 $X=F\\cdot D$，其中 $F$ 是绝对口服生物利用度，$D$ 是口服给药剂量。\n- 半数有效剂量（ED50）参数 $ED_{50}$ 代表了达到最大增量效应一半时的暴露指数。\n\n给定以下从IIa期（概念验证）和IIb期（剂量范围探索）数据模型拟合中得到的估计值：基线效应 $E_{0}=5$（任意效应单位），最大增量效应 $E_{\\max}=30$（相同效应单位），半数有效剂量参数 $ED_{50}=150$（暴露单位，与 $X=F\\cdot D$ 一致），以及绝对口服生物利用度 $F=0.4$。临床团队已指定一个高于基线的目标增量效应 $\\theta^{*}=18$（相同效应单位），即 $E=E_{0}+\\theta^{*}$。\n\n仅使用上述定义，从第一性原理推导出能够达到 $E=E_{0}+\\theta^{*}$ 的口服剂量 $D$ 的显式表达式，然后使用参数值 $E_{0}=5$，$E_{\\max}=30$，$ED_{50}=150$，$F=0.4$ 和 $\\theta^{*}=18$ 计算其数值。以mg为单位表示最终剂量，并将您的答案四舍五入到四位有效数字。",
            "solution": "用户提供了一个来自临床药理学领域的问题，具体涉及药代动力学-药效动力学（PK/PD）建模。问题要求推导并计算达到特定目标治疗效果所需的药物口服剂量。\n\n首先，我将验证问题陈述。\n\n### **问题验证**\n\n**步骤1：提取已知条件**\n\n- **效应模型（$E_{\\max}$模型）**：药物效应 $E$ 与全身暴露指数 $X$ 之间的关系由下式给出：\n  $E = E_{0} + E_{\\max} \\frac{X}{ED_{50} + X}$\n- **暴露模型**：暴露指数 $X$、口服给药剂量 $D$ 和绝对口服生物利用度 $F$ 之间的关系为：\n  $X = F \\cdot D$\n- **模型参数值**：\n  - 基线效应，$E_{0} = 5$ 单位。\n  - 最大增量效应，$E_{\\max} = 30$ 单位。\n  - 半数有效剂量参数，$ED_{50} = 150$ 暴露单位。\n  - 绝对口服生物利用度，$F = 0.4$。\n- **治疗目标**：\n  - 高于基线的目标增量效应为 $\\theta^{*} = 18$ 单位。\n  - 因此，目标总效应为 $E_{\\text{target}} = E_{0} + \\theta^{*}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学依据**：该问题使用了标准的S型$E_{\\max}$模型，这是药理学中描述浓度-效应关系的一个基础且被广泛接受的工具。在治疗范围内，剂量与暴露量之间的线性关系对于许多药物而言是一个有效的近似（线性药代动力学）。该问题在科学上是合理的。\n- **适定性**：该问题提供了一个包含两个代数方程和一个未知变量 $D$ 的方程组。所有必需的参数都已定义和量化。其代数结构允许求解出 $D$ 的唯一解，并且给定的参数值（$E_{\\max} > \\theta^{*} > 0$，$F > 0$，$ED_{50} > 0$）确保了最终得到的剂量将是一个具有物理意义的正值。\n- **客观性**：该问题以精确、定量且无偏见的语言陈述，使用了该领域的标准术语。\n\n**步骤3：结论与行动**\n该问题在科学上合理、适定、客观且内部一致。它被认为是**有效的**。我将从第一性原理开始推导解答。\n\n### **推导与求解**\n\n目标是找到能产生目标效应 $E_{\\text{target}}$ 的口服剂量 $D$。\n\n目标效应被指定为在基线效应 $E_{0}$ 之上增加一个增量效应 $\\theta^{*}$。\n$$E_{\\text{target}} = E_{0} + \\theta^{*}$$\n\n药物产生的效应由 $E_{\\max}$ 模型描述：\n$$E = E_{0} + E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n为达到目标效应，我们令 $E = E_{\\text{target}}$：\n$$E_{0} + \\theta^{*} = E_{0} + E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n从等式两边减去基线效应 $E_{0}$，分离出由药物引起的效应：\n$$\\theta^{*} = E_{\\max}\\,\\frac{X}{ED_{50}+X}$$\n\n现在，我们必须解此方程以求得产生增量效应 $\\theta^{*}$ 所需的暴露指数 $X$。首先，两边同除以 $E_{\\max}$：\n$$\\frac{\\theta^{*}}{E_{\\max}} = \\frac{X}{ED_{50}+X}$$\n\n为了求解 $X$，我们可以对等式两边取倒数：\n$$\\frac{E_{\\max}}{\\theta^{*}} = \\frac{ED_{50}+X}{X} = \\frac{ED_{50}}{X} + 1$$\n\n重新整理方程以分离出含 $X$ 的项：\n$$\\frac{E_{\\max}}{\\theta^{*}} - 1 = \\frac{ED_{50}}{X}$$\n$$\\frac{E_{\\max} - \\theta^{*}}{\\theta^{*}} = \\frac{ED_{50}}{X}$$\n\n求解 $X$：\n$$X = ED_{50} \\left( \\frac{\\theta^{*}}{E_{\\max} - \\theta^{*}} \\right) = \\frac{\\theta^{*} \\cdot ED_{50}}{E_{\\max} - \\theta^{*}}$$\n\n该表达式给出了所需的全身暴露指数 $X$。问题通过绝对生物利用度 $F$ 将此暴露指数与口服给药剂量 $D$ 联系起来：\n$$X = F \\cdot D$$\n\n将此关系代入我们关于 $X$ 的表达式中：\n$$F \\cdot D = \\frac{\\theta^{*} \\cdot ED_{50}}{E_{\\max} - \\theta^{*}}$$\n\n最后，我们通过除以 $F$ 来求解剂量 $D$：\n$$D = \\frac{\\theta^{*} \\cdot ED_{50}}{F (E_{\\max} - \\theta^{*})}$$\n\n这就是达到目标效应所需的口服剂量 $D$ 的显式表达式。\n\n现在，我们将给定的数值代入此表达式：\n- $\\theta^{*} = 18$\n- $ED_{50} = 150$\n- $F = 0.4$\n- $E_{\\max} = 30$\n\n$$D = \\frac{18 \\cdot 150}{0.4 (30 - 18)}$$\n$$D = \\frac{2700}{0.4 (12)}$$\n$$D = \\frac{2700}{4.8}$$\n$$D = 562.5$$\n\n问题指明 $ED_{50}$ 的单位与 $X=F \\cdot D$ 一致。由于 $F$ 是无量纲的，因此 $X$ 的单位，也就是 $ED_{50}$ 的单位，与剂量 $D$ 的单位相同。问题要求最终答案以毫克（mg）表示，因此我们假设在整个计算过程中剂量的隐含单位是mg。\n\n最终的数值结果是 $562.5$。问题要求将答案四舍五入到四位有效数字。数字 $562.5$ 本身已有四位有效数字。因此，无需进一步四舍五入。\n所需的剂量是 $562.5$ mg。",
            "answer": "$$\\boxed{562.5}$$"
        },
        {
            "introduction": "现代临床试验越来越多地采用适应性设计来提高效率和伦理水平。这个动手编程练习将指导您构建一个贝叶斯适应性随机化算法的模拟，其中患者分配会根据累积的数据进行动态调整。通过实施该模型，您将对试验如何“实时学习”以集中于最有希望的治疗方案获得深刻而实际的理解。",
            "id": "5044148",
            "problem": "构建一个程序，该程序使用贝叶斯模型实现一个用于II期临床试验剂量分配的自适应随机化（AR）过程。该模型会增加对那些具有更高后验概率以达到预设目标效应的剂量的分配。背景为转化医学，特别是IIa期（概念验证，PoC）和IIb期（剂量范围探索）试验。该问题必须纯粹以数学和逻辑术语进行阐述，并通过从以下基本依据推导出算法来解决。\n\n基本依据：\n- 贝叶斯定理：对于未知参数 $\\theta$ 和观测数据 $D$，后验分布满足 $p(\\theta \\mid D) \\propto p(D \\mid \\theta) p(\\theta)$。\n- 共轭贝塔-二项分布模型：如果剂量 $k$ 的未知有效性概率 $p_k$ 服从先验分布 $\\mathrm{Beta}(\\alpha_k,\\beta_k)$，并且二元结局服从伯努利分布，那么在观测到 $s_k$ 次成功和 $f_k$ 次失败后，其后验分布为 $\\mathrm{Beta}(\\alpha_k + s_k,\\beta_k + f_k)$。\n- 对于剂量 $k$，达到目标阈值 $\\tau$ 的后验概率为 $q_k = \\Pr(p_k \\ge \\tau \\mid D) = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k + s_k, \\beta_k + f_k)$，其中 $F_{\\mathrm{Beta}}(\\cdot; a,b)$ 是参数为 $(a,b)$ 的贝塔分布的累积分布函数。\n\n待构建的算法：\n- 设有 $K$ 个候选剂量，由 $k \\in \\{1,\\dots,K\\}$ 索引，其未知有效性概率为 $p_k$。用先验分布 $\\mathrm{Beta}(\\alpha_k,\\beta_k)$ 和观测计数 $s_k = 0, f_k = 0$ 初始化每个剂量。\n- 在每个队列步骤 $t \\in \\{1,\\dots,T\\}$（队列大小为 $c$），计算每个剂量的后验分布：$\\mathrm{Beta}(\\alpha_k + s_k,\\beta_k + f_k)$。\n- 计算达到目标效应阈值 $\\tau$ 的后验概率：$q_k = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k + s_k, \\beta_k + f_k)$。\n- 定义分配权重 $\\tilde{w}_k = (q_k + \\delta)^{\\eta}$，其中 $\\eta > 0$ 控制自适应的强度，$\\delta > 0$ 是一个防止权重为零的小常数。\n- 进行归一化以获得随机化概率 $r_k = \\tilde{w}_k / \\sum_{j=1}^{K} \\tilde{w}_j$。\n- 使用概率为 $(r_1,\\dots,r_K)$ 的多项分布抽样，将队列 $t$ 中的 $c$ 名患者进行随机分配。为保证可复现性，应使用伪随机数生成器，并为每个测试用例指定固定的种子。\n- 出于测试目的（非真实试验的一部分），假设真实有效性概率 $p_k^{\\star}$ 已知，并使用概率为 $p_k^{\\star}$ 的伯努利抽样为每个剂量下已分配的患者模拟结局。相应地更新 $s_k$ 和 $f_k$，然后迭代到下一个队列。\n- 在 $T$ 个队列之后，以整数列表 $[n_1,\\dots,n_K]$ 的形式输出每个剂量的最终总分配人数，其中 $n_k$ 是分配给剂量 $k$ 的患者总数。\n\n角度单位不适用。物理单位不适用。所有比例或概率均以小数表示，不使用百分号。\n\n你的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由逗号分隔的列表，并用方括号括起。每个测试用例的结果都表示为其自己的方括号列表，且不含任何空格。例如，总输出的格式必须是 $[[x_1,x_2],[y_1,y_2,y_3],\\dots]$，不含空格。\n\n测试套件：\n对于每个测试用例，指定 $(K, \\alpha, \\beta, \\tau, p^{\\star}, T, c, \\eta, \\delta, \\text{seed})$。\n\n- 测试用例 A（通用“理想路径”）：$K = 3$，$\\alpha = [1, 1, 1]$，$\\beta = [1, 1, 1]$，$\\tau = 0.3$， $p^{\\star} = [0.2, 0.35, 0.5]$，$T = 5$，$c = 8$，$\\eta = 1.0$，$\\delta = 10^{-6}$，$\\text{seed} = 2021$。预期行为：增加对具有更高 $p_k^{\\star}$ 的剂量的分配，特别是第三个剂量。\n- 测试用例 B（平局情况）：$K = 2$，$\\alpha = [10, 10]$，$\\beta = [10, 10]$，$\\tau = 0.5$，$p^{\\star} = [0.5, 0.5]$，$T = 10$，$c = 4$，$\\eta = 2.0$，$\\delta = 10^{-3}$，$\\text{seed} = 2022$。预期行为：由于对称性和相同的性能，分配将近乎相等。\n- 测试用例 C（信息丰富但错误的先验；探索性保障）：$K = 4$，$\\alpha = [20, 1, 1, 1]$，$\\beta = [5, 1, 1, 1]$，$\\tau = 0.6$，$p^{\\star} = [0.3, 0.65, 0.7, 0.8]$，$T = 12$，$c = 6$，$\\eta = 1.5$，$\\delta = 10^{-2}$，$\\text{seed} = 2023$。预期行为：由于先验信息，初始分配可能偏向第一个剂量，但随着数据的积累，算法应将分配转向由真实 $p_k^{\\star}$ 驱动的、具有更高后验 $q_k$ 的剂量。\n- 测试用例 D（高阈值边界情况）：$K = 3$，$\\alpha = [1, 1, 1]$，$\\beta = [1, 1, 1]$，$\\tau = 0.9$，$p^{\\star} = [0.85, 0.88, 0.9]$，$T = 8$，$c = 5$，$\\eta = 1.0$，$\\delta = 10^{-6}$，$\\text{seed} = 2024$。预期行为：初始 $q_k$ 值较低；分配将保持相对平衡，直到积累足够的证据以偏向第三个剂量。\n\n最终输出规范：\n你的程序必须打印单行输出，其中包含所有四个测试用例的结果，形式为由逗号分隔的方括号列表，不含空格，并严格遵循以下格式：$[[n_1^{(A)},n_2^{(A)},n_3^{(A)}],[n_1^{(B)},n_2^{(B)}],[n_1^{(C)},n_2^{(C)},n_3^{(C)},n_4^{(C)}],[n_1^{(D)},n_2^{(D)},n_3^{(D)}]]$，其中 $n_k^{(\\cdot)}$ 是由你的算法计算出的整数。",
            "solution": "该问题要求构建一个 Python 程序，用于模拟II期临床试验的自适应随机化（AR）过程。该过程使用贝叶斯框架，根据累积的有效性数据动态调整患者在不同剂量水平上的分配。此问题在算法上定义明确，在科学上合理，并提供了实现所需的所有必要参数。\n\n该解决方案通过将指定的数学和逻辑步骤转化为计算算法来构建。算法的核心是一个迭代过程，在每个患者队列接受治疗后更新对剂量有效性的信念，并随后将新患者分配到显示出有更高有效可能性的剂量。\n\n**1. 贝叶斯模型基础**\n对于每个剂量 $k \\in \\{1, \\dots, K\\}$ 的未知有效性概率 $p_k$ 的模型是基于贝塔-二项共轭模型的。当结局是二元时（例如，成功/失败，有效/无效），这是一种为概率建模的标准选择。\n\n- **先验信念**：我们从关于有效性 $p_k$ 的先验信念开始，该信念通过贝塔分布 $p_k \\sim \\mathrm{Beta}(\\alpha_k, \\beta_k)$ 建模。参数 $(\\alpha_k, \\beta_k)$ 可用于表示预先存在的知识。一个常见的无信息先验是均匀分布，即 $\\mathrm{Beta}(1, 1)$。\n\n- **似然**：每位患者的结局都是一次伯努利试验。对于剂量 $k$ 的一个包含 $n$ 名患者的队列，如果我们观察到 $s$ 次成功，那么在给定 $p_k$ 的条件下，该数据的似然与 $p_k^s (1-p_k)^{n-s}$ 成正比。\n\n- **后验信念**：根据贝叶斯定理，后验分布与先验和似然的乘积成正比。由于贝塔分布和二项分布的共轭性，如果我们为剂量 $k$ 累积了总共 $s_k$ 次成功和 $f_k$ 次失败，那么 $p_k$ 的后验分布将更新为：\n$$p_k \\mid (s_k, f_k) \\sim \\mathrm{Beta}(\\alpha_k', \\beta_k') = \\mathrm{Beta}(\\alpha_k + s_k, \\beta_k + f_k)$$\n这些更新后的分布包含了我们当前关于每个剂量有效性的所有知识。\n\n**2. 自适应分配机制**\n自适应设计的核心是将更多患者分配给“有前景的”剂量。如果一个剂量的后验分布表明其超过预定义有效性阈值 $\\tau$ 的概率很高，那么该剂量就被认为是有前景的。\n\n- **达到目标的后验概率 ($q_k$)**：对于每个剂量 $k$，我们计算在给定观测数据的情况下，其真实有效性 $p_k$ 至少为 $\\tau$ 的概率。这是根据后验分布计算的：\n$$q_k = \\Pr(p_k \\ge \\tau \\mid s_k, f_k) = \\int_{\\tau}^{1} \\frac{x^{\\alpha_k'-1}(1-x)^{\\beta_k'-1}}{B(\\alpha_k', \\beta_k')} dx = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha_k', \\beta_k')$$\n其中 $F_{\\mathrm{Beta}}(\\cdot; a, b)$ 是参数为 $(a, b)$ 的贝塔分布的累积分布函数（CDF）。这个值 $q_k$ 作为衡量剂量 $k$ “前景”的指标。\n\n- **分配权重和概率**：将 $q_k$ 值转换为分配概率。使用一个幂函数来控制自适应的程度：\n$$\\tilde{w}_k = (q_k + \\delta)^{\\eta}$$\n在这里，$\\eta > 0$ 是一个调整参数；较大的 $\\eta$ 会使分配更加“贪婪”，即严重偏向于具有最高 $q_k$ 值的剂量。较小的 $\\eta$ 会带来更均衡的分配，从而促进探索。常数 $\\delta > 0$ 是一个小的正则化项，用以确保即使 $q_k=0$ 的剂量也有非零（尽管微小）的被选中机会，防止它们被过早排除。然后将权重归一化，形成一个概率分布：\n$$r_k = \\frac{\\tilde{w}_k}{\\sum_{j=1}^{K} \\tilde{w}_j}$$\n这些概率 $(r_1, \\dots, r_K)$ 用于分配下一个患者队列。\n\n**3. 模拟算法**\n模拟以离散步骤进行，每个步骤对应一个患者队列。\n\n- **初始化**：\n    - 对于每个剂量 $k=1, \\dots, K$：初始化成功计数 $s_k=0$ 和失败计数 $f_k=0$。\n    - 分配的患者总数 $n_k$ 也初始化为 $0$。\n    - 为确保可复现性，对伪随机数生成器（RNG）进行种子设定。\n\n- **队列迭代**：对于大小为 $c$ 的每个队列 $t=1, \\dots, T$：\n    1. **计算后验分布**：为所有剂量计算后验贝塔参数 $\\alpha'_k = \\alpha_k + s_k$ 和 $\\beta'_k = \\beta_k + f_k$。\n    2. **计算目标概率**：为所有剂量计算 $q_k = 1 - F_{\\mathrm{Beta}}(\\tau; \\alpha'_k, \\beta'_k)$。此步骤使用 `scipy.stats.beta.cdf` 函数。\n    3. **计算分配概率**：计算权重 $\\tilde{w}_k$ 并进行归一化以得到随机化概率 $r_k$。\n    4. **分配患者**：从具有 $c$ 次试验和概率 $(r_1, \\dots, r_K)$ 的多项分布中，为当前队列抽取患者计数向量 $(c_1, \\dots, c_K)$。此操作使用 `numpy.random.multinomial` 完成。更新总分配数：$n_k \\leftarrow n_k + c_k$。\n    5. **模拟结局**：对于每个剂量 $k$，为 $c_k$ 名新分配的患者模拟结局。成功次数从二项分布 $\\mathrm{Bin}(c_k, p_k^{\\star})$ 中抽取，其中 $p_k^{\\star}$ 是真实有效性。此操作使用 `numpy.random.binomial` 完成。更新累积计数：$s_k \\leftarrow s_k + \\text{成功次数}$ 和 $f_k \\leftarrow f_k + (c_k - \\text{成功次数})$。\n\n- **终止**：处理完 $T$ 个队列后，模拟结束。最终输出是每个剂量的总患者分配列表：$[n_1, n_2, \\dots, n_K]$。\n\n这个综合算法在 Python 中实现，利用 `numpy` 进行高效的基于数组的计算和随机数生成，并利用 `scipy` 获取统计上的贝塔分布函数。整个过程被封装在一个函数中，该函数针对每个提供的测试用例执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta as beta_dist\n\ndef run_simulation(K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed):\n    \"\"\"\n    Implements the Adaptive Randomization (AR) procedure for a single test case.\n\n    Args:\n        K (int): Number of candidate doses.\n        alpha (list): Prior alpha parameters for the Beta distributions.\n        beta_p (list): Prior beta parameters for the Beta distributions.\n        tau (float): Target effect threshold.\n        p_star (list): Ground-truth efficacy probabilities for simulation.\n        T (int): Number of cohorts.\n        c (int): Cohort size.\n        eta (float): Parameter controlling the strength of adaptiveness.\n        delta (float): Small constant to prevent zero weights.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        list: A list of final total patient allocations to each dose.\n    \"\"\"\n    # Initialize the pseudo-random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Convert lists to NumPy arrays for vectorized operations.\n    alpha0 = np.array(alpha, dtype=float)\n    beta0 = np.array(beta_p, dtype=float)\n    p_star = np.array(p_star, dtype=float)\n\n    # Initialize success counts (s), failure counts (f), and total allocations.\n    s = np.zeros(K, dtype=int)\n    f = np.zeros(K, dtype=int)\n    n_total = np.zeros(K, dtype=int)\n\n    # Iterate through each cohort.\n    for _ in range(T):\n        # 1. Compute posterior parameters for each dose.\n        posterior_alpha = alpha0 + s\n        posterior_beta = beta0 + f\n\n        # 2. Compute the posterior probability of meeting the target threshold.\n        # q_k = Pr(p_k >= tau | Data) = 1 - CDF_Beta(tau; a', b')\n        q = 1 - beta_dist.cdf(tau, posterior_alpha, posterior_beta)\n        \n        # 3. Define allocation weights.\n        weights = (q + delta)**eta\n\n        # 4. Normalize weights to obtain randomization probabilities.\n        sum_weights = np.sum(weights)\n        if sum_weights > 0:\n            r = weights / sum_weights\n        else:\n            # Fallback to equal allocation if all weights are zero (highly unlikely with delta > 0).\n            r = np.ones(K) / K\n\n        # 5. Randomly allocate the cohort of patients using a multinomial draw.\n        allocations_this_cohort = rng.multinomial(c, r)\n        n_total += allocations_this_cohort\n        \n        # 6. Simulate outcomes for the allocated patients based on ground-truth probabilities.\n        successes_this_cohort = rng.binomial(allocations_this_cohort, p_star)\n        failures_this_cohort = allocations_this_cohort - successes_this_cohort\n\n        # Update cumulative success and failure counts.\n        s += successes_this_cohort\n        f += failures_this_cohort\n\n    return n_total.tolist()\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (K, alpha, beta, tau, p_star, T, c, eta, delta, seed)\n        (3, [1, 1, 1], [1, 1, 1], 0.3, [0.2, 0.35, 0.5], 5, 8, 1.0, 1e-6, 2021),\n        (2, [10, 10], [10, 10], 0.5, [0.5, 0.5], 10, 4, 2.0, 1e-3, 2022),\n        (4, [20, 1, 1, 1], [5, 1, 1, 1], 0.6, [0.3, 0.65, 0.7, 0.8], 12, 6, 1.5, 1e-2, 2023),\n        (3, [1, 1, 1], [1, 1, 1], 0.9, [0.85, 0.88, 0.9], 8, 5, 1.0, 1e-6, 2024),\n    ]\n\n    results = []\n    for params in test_cases:\n        K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed = params\n        result = run_simulation(K, alpha, beta_p, tau, p_star, T, c, eta, delta, seed)\n        results.append(result)\n\n    # The final print statement must produce a single-line string with no spaces.\n    # Example format: [[n1,n2],[n3,n4,n5]]\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        }
    ]
}