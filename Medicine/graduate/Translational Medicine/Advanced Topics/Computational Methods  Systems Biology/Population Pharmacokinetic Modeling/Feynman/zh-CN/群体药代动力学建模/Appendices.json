{
    "hands_on_practices": [
        {
            "introduction": "在深入研究复杂的群体模型之前，掌握基本的药代动力学原理至关重要。本练习聚焦于药物蓄积，这是设计有效给药方案的关键因素。通过从第一性原理推导蓄积比，您将对药物的半衰期和给药间隔如何相互作用以决定稳态浓度建立起清晰的直觉。",
            "id": "5046120",
            "problem": "一个单室、线性、时不变的群体药代动力学 (PopPK) 模型用于描述一种通过快速静脉推注给药的小分子药物，其给药间隔固定为 $\\,\\tau\\,$。设典型群体清除率为 $\\,\\mathrm{CL}_{\\mathrm{typ}}\\,$，典型群体分布容积为 $\\,V_{\\mathrm{typ}}\\,$。假设为一级消除，速率常数为 $\\,k = \\mathrm{CL}_{\\mathrm{typ}}/V_{\\mathrm{typ}}\\,$，并定义消除半衰期 $\\,t_{1/2}\\,$ 为 $\\,t_{1/2} = \\ln(2)/k\\,$。在稳态下多次给药时，由于先前剂量的残余浓度叠加，给药后瞬时的峰浓度相对于首次给药后的峰浓度会有所升高。\n\n从线性、时不变和一级消除的基本假设出发，利用两次给药之间浓度的指数衰减和叠加原理，推导出蓄积比 $\\,R_{\\mathrm{acc}}\\,$ 的闭式表达式。蓄积比定义为稳态下给药后瞬时的峰浓度与首次给药后瞬时的峰浓度之比，是 $\\,k\\,$ 和 $\\,\\tau\\,$ 的函数。然后，当 $\\,\\mathrm{CL}_{\\mathrm{typ}} = 5.0\\,\\mathrm{L}\\,\\mathrm{h}^{-1}\\,$，$\\,V_{\\mathrm{typ}} = 50.0\\,\\mathrm{L}\\,$ 且 $\\,\\tau = 8.0\\,\\mathrm{h}\\,$ 时，计算 $\\,R_{\\mathrm{acc}}\\,$ 的值。简要地用文字解释 $\\,t_{1/2}\\,$ 与 $\\,\\tau\\,$ 的比值如何决定稳态下的蓄积程度。\n\n将最终的数值答案以无量纲数的形式给出，并四舍五入到四位有效数字。最终答案中不要包含单位。",
            "solution": "该问题提法恰当，有科学依据，且信息自洽。这是经典药代动力学中的一个标准推导。我们可以开始求解。\n\n该问题描述了一个通过静脉 (IV) 推注给药的单室模型。在此模型中，单次静脉推注剂量 $D$ 后，体内药物浓度 $C(t)$ 随时间 $t$ 的变化由以下指数衰减函数给出：\n$$C(t) = C_0 \\exp(-kt)$$\n其中 $k$ 是一级消除速率常数，$C_0$ 是 $t=0$ 时的初始浓度。对于快速静脉推注，假定剂量 $D$ 瞬间分布于整个分布容积 $\\,V_{\\mathrm{typ}}\\,$ 中。因此，初始浓度为 $C_0 = D/V_{\\mathrm{typ}}$。该初始浓度也是首次给药后的峰浓度，记作 $C_{\\mathrm{max, 1}}$。\n$$C_{\\mathrm{max, 1}} = \\frac{D}{V_{\\mathrm{typ}}}$$\n因此，首次给药后任意时间 $t$ 的浓度为 $C_1(t) = (D/V_{\\mathrm{typ}}) \\exp(-kt)$。\n\n药物以固定的给药间隔 $\\tau$ 给药。根据线性时不变 (LTI) 系统的叠加原理，任何时刻的总浓度是每次单独给药产生的浓度之和。\n\n首次给药后瞬时的峰浓度（在 $t=0^+$ 时）是 $C_{\\mathrm{max, 1}}$。\n第二次给药后瞬时的峰浓度（在 $t=\\tau^+$ 时）是新剂量的浓度 ($D/V_{\\mathrm{typ}}$) 与首次给药在时间 $\\tau$ 时剩余的残余浓度之和。\n$$C_{\\mathrm{max, 2}} = \\frac{D}{V_{\\mathrm{typ}}} + C_1(\\tau) = \\frac{D}{V_{\\mathrm{typ}}} + \\frac{D}{V_{\\mathrm{typ}}}\\exp(-k\\tau) = \\frac{D}{V_{\\mathrm{typ}}} (1 + \\exp(-k\\tau))$$\n类似地，第三次给药后瞬时的峰浓度（在 $t=2\\tau^+$ 时）是新剂量的浓度加上前两次给药的残余浓度。第一次给药是在 $t=0$ 时，所以已经过去了 $2\\tau$ 的时间。第二次给药是在 $t=\\tau$ 时，所以已经过去了 $\\tau$ 的时间。\n$$C_{\\mathrm{max, 3}} = \\frac{D}{V_{\\mathrm{typ}}} + \\frac{D}{V_{\\mathrm{typ}}}\\exp(-k(2\\tau)) + \\frac{D}{V_{\\mathrm{typ}}}\\exp(-k\\tau) = \\frac{D}{V_{\\mathrm{typ}}} (1 + \\exp(-k\\tau) + \\exp(-2k\\tau))$$\n\n以此类推，在时间 $t=(n-1)\\tau$ 给予第 $n$ 次剂量后瞬时的峰浓度是所有 $n$ 次剂量贡献的总和：\n$$C_{\\mathrm{max, n}} = \\sum_{i=0}^{n-1} \\left( \\frac{D}{V_{\\mathrm{typ}}} \\exp(-ik\\tau) \\right) = \\frac{D}{V_{\\mathrm{typ}}} \\sum_{i=0}^{n-1} (\\exp(-k\\tau))^i$$\n这是一个首项 $a=1$，公比 $r = \\exp(-k\\tau)$，共 $n$ 项的有限几何级数。该级数的和为 $\\frac{a(1-r^n)}{1-r}$。\n$$C_{\\mathrm{max, n}} = \\frac{D}{V_{\\mathrm{typ}}} \\left( \\frac{1 - (\\exp(-k\\tau))^n}{1 - \\exp(-k\\tau)} \\right) = \\frac{D}{V_{\\mathrm{typ}}} \\left( \\frac{1 - \\exp(-nk\\tau)}{1 - \\exp(-k\\tau)} \\right)$$\n稳态是在给予足够多次剂量后达到的状态，即当 $n \\to \\infty$ 时。稳态峰浓度 $C_{\\mathrm{max, ss}}$ 是 $C_{\\mathrm{max, n}}$ 在 $n \\to \\infty$ 时的极限。\n$$C_{\\mathrm{max, ss}} = \\lim_{n \\to \\infty} C_{\\mathrm{max, n}} = \\lim_{n \\to \\infty} \\left[ \\frac{D}{V_{\\mathrm{typ}}} \\left( \\frac{1 - \\exp(-nk\\tau)}{1 - \\exp(-k\\tau)} \\right) \\right]$$\n由于 $k>0$ 且 $\\tau>0$，项 $\\exp(-k\\tau)$ 是一个小于 $1$ 的正数。因此，当 $n \\to \\infty$ 时，项 $\\exp(-nk\\tau) \\to 0$。\n$$C_{\\mathrm{max, ss}} = \\frac{D}{V_{\\mathrm{typ}}} \\left( \\frac{1 - 0}{1 - \\exp(-k\\tau)} \\right) = \\frac{D}{V_{\\mathrm{typ}}} \\left( \\frac{1}{1 - \\exp(-k\\tau)} \\right)$$\n蓄积比 $R_{\\mathrm{acc}}$ 定义为稳态峰浓度与首次给药后峰浓度之比。\n$$R_{\\mathrm{acc}} = \\frac{C_{\\mathrm{max, ss}}}{C_{\\mathrm{max, 1}}} = \\frac{\\frac{D}{V_{\\mathrm{typ}}} \\frac{1}{1 - \\exp(-k\\tau)}}{\\frac{D}{V_{\\mathrm{typ}}}}$$\n简化后得到蓄积比作为 $k$ 和 $\\tau$ 函数的闭式表达式：\n$$R_{\\mathrm{acc}} = \\frac{1}{1 - \\exp(-k\\tau)}$$\n\n接下来，我们使用给定的参数计算 $R_{\\mathrm{acc}}$：$\\mathrm{CL}_{\\mathrm{typ}} = 5.0\\,\\mathrm{L}\\,\\mathrm{h}^{-1}$，$V_{\\mathrm{typ}} = 50.0\\,\\mathrm{L}$，以及 $\\tau = 8.0\\,\\mathrm{h}$。\n首先，我们计算消除速率常数 $k$：\n$$k = \\frac{\\mathrm{CL}_{\\mathrm{typ}}}{V_{\\mathrm{typ}}} = \\frac{5.0\\,\\mathrm{L}\\,\\mathrm{h}^{-1}}{50.0\\,\\mathrm{L}} = 0.1\\,\\mathrm{h}^{-1}$$\n现在，我们将 $k$ 和 $\\tau$ 的值代入 $R_{\\mathrm{acc}}$ 的表达式中：\n$$R_{\\mathrm{acc}} = \\frac{1}{1 - \\exp(-k\\tau)} = \\frac{1}{1 - \\exp(-(0.1\\,\\mathrm{h}^{-1})(8.0\\,\\mathrm{h}))} = \\frac{1}{1 - \\exp(-0.8)}$$\n数值上，$\\exp(-0.8) \\approx 0.44932896$。\n$$R_{\\mathrm{acc}} = \\frac{1}{1 - 0.44932896} = \\frac{1}{0.55067104} \\approx 1.815933$$\n四舍五入到四位有效数字，我们得到 $R_{\\mathrm{acc}} \\approx 1.816$。\n\n最后，我们解释消除半衰期 $t_{1/2}$、给药间隔 $\\tau$ 和蓄积程度之间的关系。\n半衰期由 $t_{1/2} = \\ln(2)/k$ 定义，可得 $k = \\ln(2)/t_{1/2}$。将此代入 $R_{\\mathrm{acc}}$ 的表达式中：\n$$R_{\\mathrm{acc}} = \\frac{1}{1 - \\exp(-\\frac{\\ln(2)}{t_{1/2}}\\tau)} = \\frac{1}{1 - \\exp(\\ln(2^{-\\tau/t_{1/2}}))} = \\frac{1}{1 - 2^{-\\tau/t_{1/2}}}$$\n此表达式表明 $R_{\\mathrm{acc}}$ 由给药间隔与半衰期的比值 $\\tau/t_{1/2}$ 决定。或者，也可以考虑半衰期与给药间隔的比值 $t_{1/2}/\\tau$。\n如果半衰期远长于给药间隔 ($t_{1/2} \\gg \\tau$)，那么在两次给药之间只有一小部分药物被消除。这意味着比值 $\\tau/t_{1/2}$ 很小，使得 $2^{-\\tau/t_{1/2}}$ 接近 $1$，分母 $1 - 2^{-\\tau/t_{1/2}}$ 接近 $0$，因此 $R_{\\mathrm{acc}}$ 会变得非常大。发生显著的蓄积。\n相反，如果半衰期远短于给药间隔 ($t_{1/2} \\ll \\tau$)，那么在下一次给药前大部分药物已被消除。比值 $\\tau/t_{1/2}$ 很大，使得 $2^{-\\tau/t_{1/2}}$ 接近 $0$，分母接近 $1$，因此 $R_{\\mathrm{acc}}$ 接近 $1$。发生极小的蓄积。\n总之，药物的消除半衰期与给药间隔的比值决定了稳态下的蓄积程度。大的比值 ($t_{1/2}/\\tau \\gg 1$) 意味着显著的蓄积，而小的比值 ($t_{1/2}/\\tau \\ll 1$) 意味着可忽略的蓄积。\n对于我们这个具体案例，$k=0.1\\,\\mathrm{h}^{-1}$，所以 $t_{1/2} = \\ln(2)/0.1 \\approx 6.93\\,\\mathrm{h}$。当 $\\tau = 8.0\\,\\mathrm{h}$ 时，比值 $t_{1/2}/\\tau \\approx 6.93/8.0 \\approx 0.87$，接近 $1$。$R_{\\mathrm{acc}} \\approx 1.816$ 的值表明存在中等程度的蓄积，这与给药间隔略长于半衰期的情况相符。如果给药间隔恰好等于一个半衰期，$R_{\\mathrm{acc}}$ 将恰好为 $2$。",
            "answer": "$$\\boxed{1.816}$$"
        },
        {
            "introduction": "群体药代动力学（PopPK）建模的一个主要目标是通过识别有影响的协变量来解释个体间的变异性。本练习将指导您完成模型构建中的一项标准方法：逐步协变量筛选。您将学习如何在前进法和后退法策略中应用似然比检验，这是开发一个能将患者特征与药物处置联系起来的、统计上稳健且简约的模型的一项核心技能。",
            "id": "5046142",
            "problem": "一个转化医学团队正在使用非线性混合效应 (NLME) 方法构建群体药代动力学 (PopPK) 模型，以表征清除率的个体间变异。个体 $i$ 的结构模型是一个单室模型，其清除率参数化为 $CL_i = \\theta_{CL}\\,\\exp(\\eta_{CL,i})$，其中 $\\eta_{CL,i} \\sim \\mathcal{N}(0,\\omega_{CL}^2)$ 捕捉随机效应。该团队考虑在 $CL_i$ 上添加两种类型的协变量作为固定效应：一个连续协变量（体重，$WT_i$），使用带有一个斜率参数 $\\beta_{WT}$ 的对数线性参数化；以及一个分类协变量（具有三个水平的基因型），使用两个指示系数进行参数化。相对于基础模型，这导致自由参数数量的差异 $d$ 分别为：$WT_i$ 对应 $d=1$，基因型对应 $d=2$。\n\n他们计划采用逐步协变量选择策略，该策略使用似然比检验 (LRT) 来比较嵌套模型。对于向前引入，通过计算目标函数值的变化量 $\\Delta(-2LL) = (-2LL)_{\\text{current}} - (-2LL)_{\\text{candidate}}$，将每个候选协变量模型与当前模型进行比较。对于向后剔除，从一个包含所有在向前选择中被接受的协变量的模型开始，他们通过计算移除某个协变量时的 $\\Delta(-2LL) = (-2LL)_{\\text{reduced}} - (-2LL)_{\\text{full}}$ 来评估该协变量。\n\n假设 LRT 的正则性条件成立，被检验的固定效应参数不在参数空间的边界上，并且 LRT 统计量 $\\Delta(-2LL)$ 近似服从卡方 ($\\chi^2$) 分布，其自由度等于增加或移除的参数数量 $d$。该团队希望对向前引入和向后剔除使用相同的显著性水平 $\\alpha=0.05$。\n\n哪个选项正确描述了此策略，并为 $d=1$ 和 $d=2$ 指定了在 $\\alpha=0.05$ 下正确的 $\\Delta(-2LL)$ 阈值？\n\nA. 在嵌套的 NLME 模型上使用似然比检验 (LRT)。对于向前引入，如果 $\\Delta(-2LL) \\ge x_{\\alpha;d}$（其中 $x_{\\alpha;1} = 3.84$ 且 $x_{\\alpha;2} = 5.99$），则引入协变量。对于向后剔除，从完整模型开始，如果剔除某个协变量导致 $\\Delta(-2LL) \\ge x_{\\alpha;d}$，则保留该协变量；否则将其剔除。\n\nB. 使用赤池信息准则 (AIC) 差异作为代理，对 $d=1$ 的情况，在 $\\Delta(-2LL) \\ge 2.71$ 时引入协变量，对 $d=2$ 的情况，在 $\\Delta(-2LL) \\ge 4.61$ 时引入协变量（对应于 $\\alpha=0.10$）。对于向后剔除，移除任何 $\\Delta(-2LL) \\le 2.71$ 或 $\\le 4.61$ 的协变量。\n\nC. 对估计的固定效应系数使用 Wald 检验，对于 $\\alpha=0.05$ 应用 $|Z| \\ge 1.96$；对于向后剔除，当 $\\Delta(-2LL)  1.96$ 时移除协变量，无论 $d$ 为何值。\n\nD. 使用 LRT，但设置阈值 $x_{\\alpha;1} = 6.63$ 和 $x_{\\alpha;2} = 9.21$；对于向后剔除，如果剔除某个协变量导致 $\\Delta(-2LL) \\ge x_{\\alpha;d}$，则移除该协变量。\n\nE. 计算 $\\Delta(LL)$ 而非 $\\Delta(-2LL)$，如果 $\\Delta(LL) \\ge 3.84$（对于 $d=1$）和 $\\ge 5.99$（对于 $d=2$），则引入协变量；对于向后剔除，如果 $\\Delta(LL) \\ge$ 相同的阈值，则移除协变量。",
            "solution": "问题陈述描述了在非线性混合效应 (NLME) 建模背景下的一种标准逐步协变量选择程序，这是群体药代动力学 (PopPK) 中的常见做法。任务的核心是正确应用似然比检验 (LRT) 来比较嵌套模型。\n\n### 第 1 步：验证问题陈述\n首先验证问题陈述的科学合理性、完整性和清晰度。\n\n-   **提取的已知条件：**\n    -   模型：用于 PopPK 的 NLME。\n    -   关注的参数：清除率，$CL_i = \\theta_{CL}\\,\\exp(\\eta_{CL,i})$，其中 $\\eta_{CL,i} \\sim \\mathcal{N}(0,\\omega_{CL}^2)$。\n    -   协变量：连续型（$WT_i$，增加 $d=1$ 个参数）和分类型（具有 $3$ 个水平的基因型，增加 $d=2$ 个参数）。\n    -   方法：使用 LRT 的逐步协变量选择。\n    -   向前引入 (FI) 的检验统计量：$\\Delta(-2LL) = (-2LL)_{\\text{current}} - (-2LL)_{\\text{candidate}}$。\n    -   向后剔除 (BE) 的检验统计量：$\\Delta(-2LL) = (-2LL)_{\\text{reduced}} - (-2LL)_{\\text{full}}$。\n    -   假设：LRT 的正则性条件成立；参数不在边界上；检验统计量 $\\Delta(-2LL)$ 近似服从自由度为 $d$ 的 $\\chi^2$ 分布。\n    -   显著性水平：FI 和 BE 均为 $\\alpha=0.05$。\n\n-   **验证结论：** 问题是 **有效的**。\n    1.  **科学依据：** 该场景是药学计量学中统计模型构建的教科书式应用。参数化方法、统计检验 (LRT) 和分布假设 ($\\chi^2$) 都是标准且正确的。\n    2.  **良定性：** 问题要求正确描述程序和具体的数值阈值，这些都可以根据所提供的信息唯一确定。\n    3.  **客观清晰：** 语言精确地描述了一种统计方法。所有术语都是该领域的标准术语。$\\Delta(-2LL)$ 的定义是一致的：在向前引入 (FI) 和向后剔除 (BE) 中，它都是简单模型（简化模型）和更复杂模型（完整模型）的 $-2 \\times \\text{对数似然}$ 之差。由于完整模型的似然值总是大于或等于简化模型的似然值，所以 $(-2LL)_{\\text{full}} \\le (-2LL)_{\\text{reduced}}$，因此 $\\Delta(-2LL) \\ge 0$。一个更大的值表示更复杂的模型对拟合的改善程度更大。\n\n### 第 2 步：推导正确的程序和阈值\n\n似然比检验 (LRT) 用于比较两个嵌套模型，一个简单的（简化）模型 $M_r$ 和一个包含 $M_r$ 的更复杂的（完整）模型 $M_f$。原假设 ($H_0$) 是简单模型已经足够，意味着 $M_f$ 中的额外参数等于零。备择假设 ($H_1$) 是更复杂的模型提供了显著更好的拟合。\n\n检验统计量是：\n$$ \\Delta(-2LL) = (-2 \\ln L_r) - (-2 \\ln L_f) = 2(\\ln L_f - \\ln L_r) $$\n其中 $L_r$ 和 $L_f$ 分别是简化模型和完整模型的最大化似然值。\n\n在 $H_0$ 下，并根据问题中的假设，该统计量服从卡方 ($\\chi^2$) 分布，其自由度 $d$ 等于两个模型参数数量之差。\n$$ \\Delta(-2LL) \\sim \\chi^2_d $$\n如果观测到的 $\\Delta(-2LL)$ 大于临界值 $\\chi^2_{d, \\alpha}$（即以概率 $\\alpha$ 被超过的值），我们拒绝 $H_0$。\n\n**计算临界值：**\n给定显著性水平 $\\alpha=0.05$。我们需要 $d=1$ 和 $d=2$ 的临界值。\n-   对于连续协变量（例如 $WT_i$），$d=1$。临界值是 $\\chi^2_{1, 0.05}$。这是标准正态分布的 $0.975$ 分位数的平方，即 $(z_{0.975})^2 = (1.96)^2 \\approx 3.841$。所以，阈值 $x_{\\alpha;1}$ 是 $3.84$。\n-   对于分类协变量（基因型），$d=2$。我们需要从 $\\chi^2$ 表或计算器中查找临界值 $\\chi^2_{2, 0.05}$。这个值约等于 $5.991$。所以，阈值 $x_{\\alpha;2}$ 是 $5.99$。\n\n**决策规则：**\n1.  **向前引入 (FI)：** “当前”模型是简化模型，“候选”模型（带有新协变量的模型）是完整模型。要引入该协变量，我们需要拟合度有统计学上的显著改善。这意味着我们必须拒绝 $H_0$。引入的条件是：\n    $$ \\Delta(-2LL) = (-2LL)_{\\text{current}} - (-2LL)_{\\text{candidate}} \\ge \\chi^2_{d, \\alpha} $$\n2.  **向后剔除 (BE)：** “完整”模型是包含待检验协变量的模型，“简化”模型是移除了该协变量的模型。原假设是简化模型已经足够（即该协变量不显著）。如果移除协变量导致拟合度出现统计学上的显著恶化，即拒绝 $H_0$，我们就*保留*该协变量。*保留*该协变量的条件是：\n    $$ \\Delta(-2LL) = (-2LL)_{\\text{reduced}} - (-2LL)_{\\text{full}} \\ge \\chi^2_{d, \\alpha} $$\n    反之，如果这个值不具有统计显著性，即如果 $\\Delta(-2LL)  \\chi^2_{d, \\alpha}$，我们就*剔除*该协变量。\n\n**正确策略总结：**\n-   无论是向前引入还是向后剔除，检验都涉及将 $\\Delta(-2LL)$ 与 $\\chi^2_{d, 0.05}$ 临界值进行比较。\n-   当 $d=1$ 时，临界值为 $3.84$；当 $d=2$ 时，临界值为 $5.99$。\n-   在向前引入中，显著的结果（$\\Delta(-2LL) \\ge \\text{阈值}$）导致协变量被引入。\n-   在向后剔除中，显著的结果（$\\Delta(-2LL) \\ge \\text{阈值}$）导致协变量被保留。\n\n### 第 3 步：评估选项\n\n**A. 在嵌套的 NLME 模型上使用似然比检验 (LRT)。对于向前引入，如果 $\\Delta(-2LL) \\ge x_{\\alpha;d}$（其中 $x_{\\alpha;1} = 3.84$ 且 $x_{\\alpha;2} = 5.99$），则引入协变量。对于向后剔除，从完整模型开始，如果剔除某个协变量导致 $\\Delta(-2LL) \\ge x_{\\alpha;d}$，则保留该协变量；否则将其剔除。**\n-   此选项正确地将 LRT 确定为使用的方法。\n-   向前引入规则是正确的：如果 $\\Delta(-2LL)$ 超过阈值，则引入。\n-   对于 $\\alpha=0.05$ 和 $d=1, 2$，临界值 $x_{\\alpha;1} = 3.84$ 和 $x_{\\alpha;2} = 5.99$ 是正确的。\n-   向后剔除规则也是正确的：如果移除协变量导致似然值显著下降（即一个大的 $\\Delta(-2LL)$），则保留该协变量，否则将其剔除。\n-   **结论：** 正确。\n\n**B. 使用赤池信息准则 (AIC) 差异作为代理，对 $d=1$ 的情况，在 $\\Delta(-2LL) \\ge 2.71$ 时引入协变量，对 $d=2$ 的情况，在 $\\Delta(-2LL) \\ge 4.61$ 时引入协变量（对应于 $\\alpha=0.10$）。对于向后剔除，移除任何 $\\Delta(-2LL) \\le 2.71$ 或 $\\le 4.61$ 的协变量。**\n-   此选项不正确，因为问题明确规定使用 LRT 且 $\\alpha=0.05$。此选项使用了不同的阈值（$2.71$ 和 $4.61$），这些阈值对应于 $\\alpha=0.10$（$\\chi^2_{1, 0.10} \\approx 2.706$；$\\chi^2_{2, 0.10} \\approx 4.605$）。\n-   **结论：** 不正确。\n\n**C. 对估计的固定效应系数使用 Wald 检验，对于 $\\alpha=0.05$ 应用 $|Z| \\ge 1.96$；对于向后剔除，当 $\\Delta(-2LL)  1.96$ 时移除协变量，无论 $d$ 为何值。**\n-   这不正确。问题规定使用 LRT，而不是 Wald 检验。虽然对于 $d=1$ 的 Wald 检验与 LRT 相关（渐近等价），但问题指定的是 LRT。对于 $d=2$，简单的 Z 检验不适用。\n-   向后剔除规则有缺陷。它将 LRT 统计量 $\\Delta(-2LL)$ 与 Z 检验的临界值（$1.96$）混淆，并错误地声称该阈值与自由度 $d$ 无关。\n-   **结论：** 不正确。\n\n**D. 使用 LRT，但设置阈值 $x_{\\alpha;1} = 6.63$ 和 $x_{\\alpha;2} = 9.21$；对于向后剔除，如果剔除某个协变量导致 $\\Delta(-2LL) \\ge x_{\\alpha;d}$，则移除该协变量。**\n-   阈值 $6.63$ 和 $9.21$ 对应于显著性水平 $\\alpha=0.01$（$\\chi^2_{1, 0.01} \\approx 6.635$；$\\chi^2_{2, 0.01} \\approx 9.210$），而不是 $\\alpha=0.05$。\n-   向后剔除的逻辑是颠倒的。一个大的 $\\Delta(-2LL)$ 表示协变量是显著的，应该被*保留*，而不是被*移除*。\n-   **结论：** 不正确。\n\n**E. 计算 $\\Delta(LL)$ 而非 $\\Delta(-2LL)$，如果 $\\Delta(LL) \\ge 3.84$（对于 $d=1$）和 $\\ge 5.99$（对于 $d=2$），则引入协变量；对于向后剔除，如果 $\\Delta(LL) \\ge$ 相同的阈值，则移除协变量。**\n-   检验统计量是 $\\Delta(-2LL) = 2 \\Delta(LL)$，而不是 $\\Delta(LL)$。此选项将 $\\Delta(LL)$ 与 $\\Delta(-2LL)$ 的临界值进行比较，这在尺度上存在一个因子 2 的错误。\n-   向后剔除的逻辑是颠倒的，与选项 D 相同。一个大的 $\\Delta(LL)$（因此一个大的 $\\Delta(-2LL)$）意味着协变量是显著的，应该被保留。\n-   **结论：** 不正确。\n\n根据分析，选项 A是唯一正确描述统计程序并提供正确数值的选项。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "一个模型的最终价值在于其准确预测未来受试者临床结局的能力。本练习将让您沉浸于通过模拟进行模型外部验证的关键过程中。您将实施一个程序，为关键药代动力学指标（如$C_{\\max}$和$AUC$）生成预测区间，并检验新的“观测”数据是否落在这些区间内。这个练习展示了如何严格评估模型的预测性能，从而确保其在临床应用中的可靠性。",
            "id": "5046163",
            "problem": "一位转化医学科学家正在对一个群体药代动力学（PopPK）模型进行外部验证，方法是将观察到的队列水平的峰值浓度和暴露量分布与基于模型的模拟预测区间进行比较。该模型是一个具有一级吸收和一级消除的单室口服吸收模型。令 $A_{g}(t)$ 表示时间 $t$ 时胃肠道中的药物量，$A_{c}(t)$ 表示时间 $t$ 时中央室中的药物量。结构模型由以下质量平衡常微分方程给出\n$$\n\\frac{dA_{g}(t)}{dt} = -k_{a}A_{g}(t), \\quad \\frac{dA_{c}(t)}{dt} = k_{a}A_{g}(t) - k_{e}A_{c}(t),\n$$\n初始条件为 $A_{g}(0)=F\\cdot D$ 和 $A_{c}(0)=0$，其中 $F$ 是生物利用度，$D$ 是剂量。消除速率常数为 $k_{e} = \\frac{CL}{V}$，其中 $CL$ 是清除率，$V$ 是分布容积。浓度为 $C(t) = \\frac{A_{c}(t)}{V}$。感兴趣的两个标量指标是最大浓度 $C_{\\max} = \\max_{t \\ge 0} C(t)$ 和由浓度-时间曲线下从时间 $0$ 到无穷大的面积 $AUC = \\int_{0}^{\\infty} C(t)\\,dt$ 量化的暴露量。个体间变异在对数尺度上建模。对于体重为 $WT_{i}$（单位为 $\\mathrm{kg}$）的受试者 $i$，其个体参数遵循异速生长标度，并具有对数正态的个体间变异，\n$$\nCL_{i} = \\theta_{CL}\\left(\\frac{WT_{i}}{70}\\right)^{0.75} \\exp(\\eta_{CL,i}), \\quad\nV_{i} = \\theta_{V}\\left(\\frac{WT_{i}}{70}\\right)^{1} \\exp(\\eta_{V,i}), \\quad\nk_{a,i} = \\theta_{k_{a}} \\exp(\\eta_{k_{a},i}),\n$$\n其中 $\\eta_{CL,i} \\sim \\mathcal{N}(0,\\omega_{CL}^{2})$、$\\eta_{V,i} \\sim \\mathcal{N}(0,\\omega_{V}^{2})$ 和 $\\eta_{k_{a},i} \\sim \\mathcal{N}(0,\\omega_{k_{a}}^{2})$ 在参数和受试者之间相互独立。生物利用度 $F$ 假定为已知常数。\n\n您必须通过正向模拟来自拟合的 PopPK 模型的虚拟受试者，并将观察到的 $C_{\\max}$ 和 $AUC$ 的队列水平分布与相应队列分位数的模拟预测区间进行比较，来实施外部验证程序。预测区间是通过在模型下重复抽取具有相同协变量集（相同的体重）的模拟队列，计算队列分位数，然后取这些队列分位数分布的由下 $\\alpha/2$ 和上 $1-\\alpha/2$ 分位数定义的中心区间来构建的。\n\n程序必须实现以下内容，仅从上述模型定义以及标准微积分和概率论出发：\n\n- 根据质量平衡模型推导并计算 $C(t)$，并用它来计算每个受试者的 $C_{\\max}$。如果在模型假设下存在解析最大化器，您可以使用它；否则，在 $[0,T_{\\max}]$ 上一个足够密集的固定时间网格上数值计算最大浓度，其中 $T_{\\max}$ 的选择需足够大以可靠地近似全局最大值。\n- 从第一性原理出发，使用时间积分的定义和结构模型推导并计算 $AUC$。如果可以从模型中推导出解析结果，您可以使用它。\n- 使用指定的个体间变异为给定的队列协变量集（体重）模拟大量虚拟受试者，通过在大型模拟受试者池中精确复制观察到的体重来匹配外部验证的协变量分布。然后通过从该池中有放回地抽样，形成许多重复的虚拟队列，每个重复队列的受试者数量与观察到的相同。对于每个重复队列，计算 $C_{\\max}$ 和 $AUC$ 在概率 $p \\in \\{0.1, 0.5, 0.9\\}$ 处的队列分位数。最后，将每个队列分位数的中心 $90\\%$ 预测区间定义为跨重复队列的 $0.05$ 和 $0.95$ 分位数。\n- 对于每个观察队列，计算观察到的受试者水平 $C_{\\max}$ 和 $AUC$ 在概率 $p \\in \\{0.1, 0.5, 0.9\\}$ 处的经验分位数。\n- 对于每个指标（$C_{\\max}$ 和 $AUC$）和每个概率 $p \\in \\{0.1,0.5,0.9\\}$，返回一个布尔值，指示观察到的队列分位数是否位于相应的模拟 $90\\%$ 预测区间内（包括端点）。\n\n物理和数值规格：\n\n- 剂量 $D$ 使用 $\\mathrm{mg}$，浓度报告为 $\\mathrm{mg/L}$，暴露量报告为 $\\mathrm{mg\\cdot h/L}$。时间使用 $\\mathrm{h}$，速率常数使用 $\\mathrm{h^{-1}}$。最终的布尔输出表示为无单位的无量纲值。\n- 模型参数固定为 $F = 1$、$\\theta_{CL} = 5\\,\\mathrm{L/h}$、$\\theta_{V} = 50\\,\\mathrm{L}$、$\\theta_{k_{a}} = 1.2\\,\\mathrm{h^{-1}}$、$\\omega_{CL} = 0.25$、$\\omega_{V} = 0.25$ 和 $\\omega_{k_{a}} = 0.35$。所有受试者使用剂量 $D = 100\\,\\mathrm{mg}$。\n- 当需要数值最大化 $C(t)$ 时，使用在 $[0,48]\\,\\mathrm{h}$ 上的固定时间网格，分辨率不粗于 $\\Delta t = 0.024\\,\\mathrm{h}$。\n- 对于分位数计算，使用标准定义，即 $p$-分位数是最小值 $q$，使得至少有比例 $p$ 的数据小于或等于 $q$，并根据需要进行线性插值实现。\n\n测试套件和要求的输出格式：\n\n- 共有三个测试队列。对于每个队列，观察数据包括体重（kg）、观察到的 $C_{\\max}$ 值（mg/L）和观察到的 $AUC$ 值（mg·h/L）。\n\n队列 A：\n- 体重 (kg): $[60, 65, 70, 75, 80, 55, 90, 72, 68, 85, 77, 62]$。\n- 观察到的 $C_{\\max}$ (mg/L): $[1.70, 1.62, 1.55, 1.48, 1.42, 1.78, 1.30, 1.52, 1.58, 1.36, 1.46, 1.66]$。\n- 观察到的 $AUC$ (mg·h/L): $[22.44, 21.14, 20.00, 18.99, 18.10, 23.96, 16.57, 19.58, 20.44, 17.29, 18.62, 21.91]$。\n\n队列 B：\n- 体重 (kg): $[60, 65, 70, 75, 80, 55, 90, 72, 68, 85, 77, 62]$。\n- 观察到的 $C_{\\max}$ (mg/L): $[2.38, 2.27, 2.17, 2.07, 1.99, 2.49, 1.82, 2.13, 2.21, 1.90, 2.04, 2.32]$。\n- 观察到的 $AUC$ (mg·h/L): $[31.42, 29.60, 28.00, 26.59, 25.34, 33.54, 23.20, 27.41, 28.62, 24.20, 26.07, 30.67]$。\n\n队列 C：\n- 体重 (kg): $[50, 100, 70, 55, 95, 80]$。\n- 观察到的 $C_{\\max}$ (mg/L): $[1.90, 1.25, 1.55, 1.77, 1.30, 1.41]$。\n- 观察到的 $AUC$ (mg·h/L): $[25.90, 15.10, 20.20, 24.30, 15.70, 18.20]$。\n\n- 您的程序必须：\n    - 通过精确复制每个队列观察到的体重，为每个复制的体重独立抽取 $\\eta$ 值，模拟一个大型虚拟受试者池，以近似 PopPK 预测的受试者水平的 $C_{\\max}$ 和 $AUC$ 分布。\n    - 通过从该池中有放回地抽样，生成许多重复的虚拟队列，每个队列的受试者数量与观察队列相同，以近似概率 $p \\in \\{0.1,0.5,0.9\\}$ 处队列分位数的抽样分布。\n    - 使用跨重复队列的 $0.05$ 和 $0.95$ 分位数，为每个队列分位数构建中心 $90\\%$ 预测区间。\n    - 对每个队列和每个指标（$C_{\\max}$ 和 $AUC$），为每个 $p \\in \\{0.1,0.5,0.9\\}$ 计算一个布尔指示符，如果观察到的队列分位数位于模拟的 $90\\%$ 预测区间内（包括边界），则评估为真，否则为假。\n\n- 最终输出格式：您的程序应生成一行输出，其中包含一个含三个元素的列表，每个元素对应一个队列（A, B, C）。每个元素是一个包含六个布尔值的列表，顺序为 $[C_{\\max}@0.1, C_{\\max}@0.5, C_{\\max}@0.9, AUC@0.1, AUC@0.5, AUC@0.9]$。输出必须打印为单个 Python 风格的列表字面量，例如 $[[\\text{True},\\text{False},\\dots],[\\dots],[\\dots]]$，在单行上，无附加文本。",
            "solution": "该问题要求实施一个给定群体药代动力学（PopPK）模型的外部验证程序。此过程涉及将观察到的临床试验数据与通过随机模拟由模型生成的预测进行比较。任务的核心是确定关键药代动力学（PK）指标的观察分布，特别是最大浓度（$C_{\\max}$）和总暴露量（$AUC$），是否与模型的预测一致。\n\n首先，我们必须通过推导浓度-时间曲线 $C(t)$ 以及感兴趣的指标 $C_{\\max}$ 和 $AUC$ 的解析解来建立坚实的理论基础。结构模型是一个具有一级口服吸收的单室模型，由以下线性常微分方程组描述：\n$$\n\\frac{dA_{g}(t)}{dt} = -k_{a}A_{g}(t)\n$$\n$$\n\\frac{dA_{c}(t)}{dt} = k_{a}A_{g}(t) - k_{e}A_{c}(t)\n$$\n初始条件为 $A_{g}(0)=F \\cdot D$ 和 $A_{c}(0)=0$。这里，$A_{g}(t)$ 是胃肠道中的药物量，$A_{c}(t)$ 是中央室中的药物量，$D$ 是剂量，$F$ 是生物利用度，$k_{a}$ 是吸收速率常数，$k_{e}$ 是消除速率常数。\n\n第一个关于 $A_g(t)$ 的方程的解是 $A_{g}(t) = F D e^{-k_{a}t}$。将其代入第二个方程得到一个关于 $A_c(t)$ 的一阶线性常微分方程，可以使用积分因子求解。假设 $k_{a} \\neq k_{e}$，中央室中药物量的解是众所周知 Bateman 函数：\n$$\nA_{c}(t) = \\frac{k_{a}F D}{k_{a} - k_{e}}(e^{-k_{e}t} - e^{-k_{a}t})\n$$\n血浆浓度为 $C(t) = A_{c}(t)/V$，其中 $V$ 是分布容积：\n$$\nC(t) = \\frac{F D}{V} \\frac{k_{a}}{k_{a} - k_{e}}(e^{-k_{e}t} - e^{-k_{a}t})\n$$\n\n接下来，我们推导 $AUC$ 和 $C_{\\max}$ 的解析表达式。浓度-时间曲线下面积 $AUC$ 是 $C(t)$ 从 $t=0$ 到 $t=\\infty$ 的积分：\n$$\nAUC = \\int_{0}^{\\infty} C(t)\\,dt = \\frac{F D k_{a}}{V(k_{a} - k_{e})} \\int_{0}^{\\infty} (e^{-k_{e}t} - e^{-k_{a}t})\\,dt\n$$\n$$\nAUC = \\frac{F D k_{a}}{V(k_{a} - k_{e})} \\left[ -\\frac{1}{k_{e}}e^{-k_{e}t} + \\frac{1}{k_{a}}e^{-k_{a}t} \\right]_{0}^{\\infty} = \\frac{F D k_{a}}{V(k_{a} - k_{e})} \\left( 0 - \\left(-\\frac{1}{k_{e}} + \\frac{1}{k_{a}}\\right) \\right) = \\frac{F D k_{a}}{V(k_{a} - k_{e})} \\left( \\frac{k_{a}-k_{e}}{k_{a}k_{e}} \\right)\n$$\n这简化为药代动力学中的一个基本关系式，$AUC = \\frac{F D}{V k_{e}}$。由于消除速率常数 $k_e$ 定义为清除率（$CL$）与分布容积（$V$）之比，即 $k_e = CL/V$，$AUC$ 的表达式进一步简化为：\n$$\nAUC = \\frac{F D}{CL}\n$$\n这个结果是稳健的，即使在 $k_a = k_e$ 的特殊情况下也成立。\n\n最大浓度 $C_{\\max}$ 发生在时间 $t_{\\max}$ 处，此时导数 $\\frac{dC(t)}{dt}$ 为零。求解 $\\frac{dC(t)}{dt}=0$ 得到 $t$：\n$$\nt_{\\max} = \\frac{\\ln(k_{a}/k_{e})}{k_{a} - k_{e}}\n$$\n将 $t_{\\max}$ 代回 $C(t)$ 的方程得到 $C_{\\max} = C(t_{\\max})$。可以证明，这可以简化为以下紧凑形式：\n$$\nC_{\\max} = \\frac{F D}{V} \\left( \\frac{k_{a}}{k_{e}} \\right)^{\\frac{k_{e}}{k_{e}-k_{a}}}\n$$\n在 $k_{a} = k_{e}$ 的特定情况下，浓度方程为 $C(t) = \\frac{F D k_{a}}{V} t e^{-k_{a}t}$。对于这种情况，$t_{\\max} = 1/k_a$ 且 $C_{\\max} = \\frac{F D}{V} e^{-1}$。当 $k_e \\to k_a$ 时，$C_{\\max}$ 的通用公式正确地收敛到此极限。使用这些 $AUC$ 和 $C_{\\max}$ 的解析公式比数值积分或优化更准确且计算效率更高。\n\n验证程序执行如下：\n1.  **模拟虚拟群体**：对于每个观察队列，我们创建一个大型虚拟群体。这是通过多次复制观察到的受试者体重（$WT$）向量来完成的。对于每个虚拟受试者条目，我们使用指定的 PopPK 模型结构生成个体 PK 参数（$CL_i, V_i, k_{a,i}$）。这涉及基于体重应用异速生长标度，并通过从其指定的正态分布 $\\mathcal{N}(0, \\omega^2)$ 中抽取随机效应（$\\eta_{CL,i}, \\eta_{V,i}, \\eta_{k_{a,i}}$）来纳入个体间变异。具体而言，对于体重为 $WT_i$ 的受试者 $i$：\n    $$\n    CL_{i} = \\theta_{CL}\\left(\\frac{WT_{i}}{70}\\right)^{0.75} \\exp(\\eta_{CL,i}), \\quad V_{i} = \\theta_{V}\\left(\\frac{WT_{i}}{70}\\right)^{1} \\exp(\\eta_{V,i}), \\quad k_{a,i} = \\theta_{k_{a}} \\exp(\\eta_{k_{a},i})\n    $$\n    使用这些个体参数，我们为每个虚拟受试者计算相应的 $C_{\\max,i}$ 和 $AUC_i$，从而形成一个大型的模型预测结果池。\n\n2.  **模拟重复队列**：我们生成大量的重复虚拟队列。每个重复队列都是通过从上一步创建的大型虚拟群体中有放回地抽样形成的。每个重复队列的大小与原始观察队列中的受试者数量相同。这个过程模拟了多次进行临床研究时固有的统计变异性。\n\n3.  **计算队列分位数的分布**：对于每个模拟的重复队列，我们在指定的概率 $p \\in \\{0.1, 0.5, 0.9\\}$ 下计算 $C_{\\max}$ 和 $AUC$ 的队列水平分位数。这样，对于每个指标和概率水平，我们都得到了一个模拟队列分位数的分布。\n\n4.  **构建预测区间 (PI)**：通过找出其在重复队列中分布的第 $5$ 和第 $95$ 百分位数来构建每个队列分位数的中心 $90\\%$ 预测区间。该区间代表模型预测观察到的队列分位数应以 $90\\%$ 的概率落入的范围。\n\n5.  **执行验证检查**：我们从每个队列的观察 $C_{\\max}$ 和 $AUC$ 数据中计算经验分位数。最后，对于六个指标中的每一个（$C_{\\max}$ 的三个分位数，$AUC$ 的三个分位数），我们检查观察到的分位数是否落在相应的 $90\\%$ 预测区间内（包括端点）。每次检查的结果是一个布尔值（真/假）。\n\n整个程序系统地应用于所提供的三个测试队列中的每一个，并将布尔结果按指定格式收集和格式化。`numpy` 中向量化操作的使用使得对大量模拟受试者和重复进行高效计算成为可能。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the PopPK model validation for all cohorts.\n    \"\"\"\n    \n    # Use a fixed seed for reproducibility of the stochastic simulation.\n    np.random.seed(0)\n\n    # --- Model and Simulation Parameters ---\n    # Populational typical values (thetas)\n    THETA_CL = 5.0   # Clearance (L/h)\n    THETA_V = 50.0    # Volume of distribution (L)\n    THETA_KA = 1.2    # Absorption rate constant (h^-1)\n\n    # Inter-individual variability (omegas, as standard deviations)\n    OMEGA_CL = 0.25\n    OMEGA_V = 0.25\n    OMEGA_KA = 0.35\n\n    # Dosing and bioavailability\n    F = 1.0         # Bioavailability (unitless)\n    D = 100.0       # Dose (mg)\n\n    # Simulation settings\n    N_POOL_MULT = 1000   # Multiplier for the size of the virtual subject pool\n    N_REPLICATES = 1000  # Number of replicate cohorts to simulate\n\n    # Quantiles for analysis\n    QUANTILE_PROBS = [0.1, 0.5, 0.9]\n    PI_PROBS = [0.05, 0.95]\n    \n    # --- Test Cohort Data ---\n    COHORTS = {\n        \"A\": {\n            \"weights\": np.array([60, 65, 70, 75, 80, 55, 90, 72, 68, 85, 77, 62]),\n            \"obs_cmax\": np.array([1.70, 1.62, 1.55, 1.48, 1.42, 1.78, 1.30, 1.52, 1.58, 1.36, 1.46, 1.66]),\n            \"obs_auc\": np.array([22.44, 21.14, 20.00, 18.99, 18.10, 23.96, 16.57, 19.58, 20.44, 17.29, 18.62, 21.91]),\n        },\n        \"B\": {\n            \"weights\": np.array([60, 65, 70, 75, 80, 55, 90, 72, 68, 85, 77, 62]),\n            \"obs_cmax\": np.array([2.38, 2.27, 2.17, 2.07, 1.99, 2.49, 1.82, 2.13, 2.21, 1.90, 2.04, 2.32]),\n            \"obs_auc\": np.array([31.42, 29.60, 28.00, 26.59, 25.34, 33.54, 23.20, 27.41, 28.62, 24.20, 26.07, 30.67]),\n        },\n        \"C\": {\n            \"weights\": np.array([50, 100, 70, 55, 95, 80]),\n            \"obs_cmax\": np.array([1.90, 1.25, 1.55, 1.77, 1.30, 1.41]),\n            \"obs_auc\": np.array([25.90, 15.10, 20.20, 24.30, 15.70, 18.20]),\n        }\n    }\n    \n    def calculate_pk_metrics(cl, v, ka):\n        \"\"\"\n        Calculates Cmax and AUC for sets of individual PK parameters using analytical formulas.\n        This function is vectorized to efficiently handle large arrays of parameters.\n        \"\"\"\n        ke = cl / v\n        \n        # AUC calculation: AUC = F * D / CL\n        auc = (F * D) / cl\n        \n        # Cmax calculation\n        cmax = np.zeros_like(ka)\n        \n        # Handle the case where ka is numerically equal to ke to avoid division by zero.\n        mask_neq = np.abs(ka - ke) > 1e-9\n        \n        # Case 1: ka != ke\n        if np.any(mask_neq):\n            v_neq = v[mask_neq]\n            ka_neq = ka[mask_neq]\n            ke_neq = ke[mask_neq]\n            # Use the formula: Cmax = (F*D/V) * (ka/ke)^(ke/(ke-ka))\n            exponent = ke_neq / (ke_neq - ka_neq)\n            cmax[mask_neq] = (F * D / v_neq) * np.power(ka_neq / ke_neq, exponent)\n\n        # Case 2: ka == ke\n        if np.any(~mask_neq):\n            v_eq = v[~mask_neq]\n            # Use the formula: Cmax = (F*D/V) * exp(-1)\n            cmax[~mask_neq] = (F * D / v_eq) * np.exp(-1.0)\n            \n        return cmax, auc\n    \n\n    def run_validation_for_cohort(cohort_data):\n        \"\"\"\n        Performs the full validation procedure for a single cohort.\n        \"\"\"\n        weights = cohort_data[\"weights\"]\n        obs_cmax = cohort_data[\"obs_cmax\"]\n        obs_auc = cohort_data[\"obs_auc\"]\n        n_subjects_cohort = len(weights)\n        \n        # 1. Create a large virtual subject pool based on the cohort's weight distribution.\n        pool_weights = np.tile(weights, N_POOL_MULT)\n        total_pool_size = len(pool_weights)\n        \n        # Generate random effects for the entire pool.\n        eta_cl = np.random.normal(0, OMEGA_CL, total_pool_size)\n        eta_v = np.random.normal(0, OMEGA_V, total_pool_size)\n        eta_ka = np.random.normal(0, OMEGA_KA, total_pool_size)\n        \n        # Calculate individual parameters for the pool using allometric scaling and random effects.\n        cl_pool = THETA_CL * np.power(pool_weights / 70.0, 0.75) * np.exp(eta_cl)\n        v_pool = THETA_V * np.power(pool_weights / 70.0, 1.0) * np.exp(eta_v)\n        ka_pool = THETA_KA * np.exp(eta_ka)\n        \n        # Calculate Cmax and AUC for the entire pool.\n        pool_cmax, pool_auc = calculate_pk_metrics(cl_pool, v_pool, ka_pool)\n        \n        # 2. Generate replicate cohorts by sampling from the pool.\n        replicate_indices = np.random.choice(total_pool_size, size=(N_REPLICATES, n_subjects_cohort), replace=True)\n        replicate_cmax_cohorts = pool_cmax[replicate_indices]\n        replicate_auc_cohorts = pool_auc[replicate_indices]\n        \n        # 3. Compute the distribution of cohort quantiles.\n        rep_cmax_quantiles = np.quantile(replicate_cmax_cohorts, q=QUANTILE_PROBS, axis=1).T\n        rep_auc_quantiles = np.quantile(replicate_auc_cohorts, q=QUANTILE_PROBS, axis=1).T\n        \n        # 4. Construct the 90% prediction intervals for the cohort quantiles.\n        pi_cmax = np.quantile(rep_cmax_quantiles, q=PI_PROBS, axis=0)\n        pi_auc = np.quantile(rep_auc_quantiles, q=PI_PROBS, axis=0)\n        \n        # 5. Calculate observed cohort quantiles and perform the validation check.\n        obs_cmax_quantiles = np.quantile(obs_cmax, q=QUANTILE_PROBS)\n        obs_auc_quantiles = np.quantile(obs_auc, q=QUANTILE_PROBS)\n        \n        results = []\n        # Check Cmax quantiles against their PIs.\n        for i in range(len(QUANTILE_PROBS)):\n            is_in_interval = (pi_cmax[0, i] = obs_cmax_quantiles[i] = pi_cmax[1, i])\n            results.append(bool(is_in_interval))\n            \n        # Check AUC quantiles against their PIs.\n        for i in range(len(QUANTILE_PROBS)):\n            is_in_interval = (pi_auc[0, i] = obs_auc_quantiles[i] = pi_auc[1, i])\n            results.append(bool(is_in_interval))\n            \n        return results\n\n    all_cohort_results = []\n    for cohort_name in [\"A\", \"B\", \"C\"]:\n        cohort_results = run_validation_for_cohort(COHORTS[cohort_name])\n        all_cohort_results.append(cohort_results)\n\n    # Format the final output string to match the required Python list literal format without spaces.\n    inner_strs = [f\"[{','.join(map(str, res))}]\" for res in all_cohort_results]\n    final_output = f\"[{','.join(inner_strs)}]\"\n    \n    print(final_output)\n\nsolve()\n```"
        }
    ]
}