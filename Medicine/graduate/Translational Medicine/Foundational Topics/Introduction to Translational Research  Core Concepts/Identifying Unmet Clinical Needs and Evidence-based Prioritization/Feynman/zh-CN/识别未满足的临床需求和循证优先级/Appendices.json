{
    "hands_on_practices": [
        {
            "introduction": "我们对健康需求的评估能力，其准确性受限于所用数据的质量，而诊断测试正是这些数据的关键来源之一。本练习深入探讨了诊断工具不完美所带来的实际后果，要求您以 $QALYs$ 损失为单位，量化因假阳性和假阴性造成的健康损害。通过分析这些损害在不同人群中的分布情况 ，您将学会如何识别并量化由诊断性能和公平性问题所引发的未满足临床需求。",
            "id": "5022618",
            "problem": "一个转化医学团队正在评估是否优先开发一种用于存在显著结局差异的慢性病的改进诊断方法。两个亚群被常规筛查：\n\n- 一个高风险的历史上服务不足的人群 (HUP)\n- 普通人群 (GP)\n\n对于当前的诊断测试，假设每个亚群具有以下流行病学参数和测试操作特征：\n\n- HUP中的患病率：$p_{\\mathrm{HUP}} = 0.15$\n- HUP中的灵敏度：$Se_{\\mathrm{HUP}} = 0.86$\n- HUP中的特异度：$Sp_{\\mathrm{HUP}} = 0.91$\n\n- GP中的患病率：$p_{\\mathrm{GP}} = 0.04$\n- GP中的灵敏度：$Se_{\\mathrm{GP}} = 0.93$\n- GP中的特异度：$Sp_{\\mathrm{GP}} = 0.96$\n\n令 $N = 1{,}000$ 表示每个亚群中接受测试的个体数量。假设期望值可以是小数。\n\n为了量化临床影响，使用质量调整生命年 (QALY) 框架。以下每个错误的预期损失是根据历史结局和当前护理路径估算的：\n\n- HUP漏诊（假阴性，FN）的QALY损失：$L_{\\mathrm{FN,HUP}} = 0.9$ QALY\n- HUP假警报（假阳性，FP）的QALY损失：$L_{\\mathrm{FP,HUP}} = 0.08$ QALY\n- GP漏诊（FN）的QALY损失：$L_{\\mathrm{FN,GP}} = 0.6$ QALY\n- GP假警报（FP）的QALY损失：$L_{\\mathrm{FP,GP}} = 0.05$ QALY\n\n定义一个综合了总伤害和公平性差异的未满足需求优先指数为\n$$U \\;=\\; w_{\\mathrm{HUP}}\\,H_{\\mathrm{HUP}} \\;+\\; w_{\\mathrm{GP}}\\,H_{\\mathrm{GP}} \\;+\\; \\lambda\\,\\big| H_{\\mathrm{HUP}} - H_{\\mathrm{GP}} \\big|,$$\n其中 $H_{\\mathrm{HUP}}$ 和 $H_{\\mathrm{GP}}$ 分别是HUP和GP中每$1{,}000$名受试者的预期总QALY损失，政策权重为\n- $w_{\\mathrm{HUP}} = 1.3$\n- $w_{\\mathrm{GP}} = 1.0$\n- $\\lambda = 0.4$\n\n任务：\n1. 使用灵敏度、特异度和患病率的核心定义，计算HUP和GP中每$1{,}000$名受试者的假阳性（FP）和假阴性（FN）的预期数量。\n2. 计算 $H_{\\mathrm{HUP}}$ 和 $H_{\\mathrm{GP}}$。\n3. 计算优先指数 $U$。\n\n将最终指数 $U$ 以每$1{,}000$名受试者的质量调整生命年（QALY）表示。将您的最终答案四舍五入到四位有效数字。除了得出数值结果外，您的推理必须根据计算出的数量明确考虑临床和公平性影响，但最终报告的答案必须是 $U$ 的单一值。",
            "solution": "问题陈述经过严格评估并被认为是有效的。它在科学上基于标准的流行病学和卫生经济学原理，问题提出得当，提供了所有必要数据，并且其表述是客观的。该问题是一个基于明确定义的可形式化计算，不违反任何无效性标准。因此，我们可以进行完整解答。\n\n该问题要求基于诊断测试性能以及在两个不同亚群（高风险的历史上服务不足的人群 (HUP) 和普通人群 (GP)）中的相关质量调整生命年 (QALY) 损失，计算一个未满足需求优先指数 $U$。\n\n**任务1：计算假阳性（FP）和假阴性（FN）的预期数量**\n\n令 $D^+$ 表示个体患有该病的事件，$D^-$ 表示个体未患病的事件。令 $T^+$ 表示测试结果为阳性的事件，$T^-$ 表示测试结果为阴性的事件。关键的流行病学参数是患病率（$p = P(D^+)$）、灵敏度（$Se = P(T^+|D^+)$）和特异度（$Sp = P(T^-|D^-)$）。\n\n每个亚群中接受测试的个体数量为 $N = 1{,}000$。\n\n预期患病个体数量为 $N \\times p$。\n预期未患病个体数量为 $N \\times (1-p)$。\n\n假阴性（FN）发生在患病个体测试结果为阴性时。其概率为 $P(T^-|D^+) = 1 - Se$。\nFN的预期数量 $E[\\text{FN}]$ 由下式给出：\n$$E[\\text{FN}] = N \\times p \\times (1 - Se)$$\n\n假阳性（FP）发生在未患病个体测试结果为阳性时。其概率为 $P(T^+|D^-) = 1 - Sp$。\nFP的预期数量 $E[\\text{FP}]$ 由下式给出：\n$$E[\\text{FP}] = N \\times (1 - p) \\times (1 - Sp)$$\n\n我们将这些公式应用于每个亚群。\n\n**对于HUP亚群：**\n给定参数为 $p_{\\mathrm{HUP}} = 0.15$, $Se_{\\mathrm{HUP}} = 0.86$, 和 $Sp_{\\mathrm{HUP}} = 0.91$。\n预期患病个体数量：$1{,}000 \\times 0.15 = 150$。\n预期未患病个体数量：$1{,}000 \\times (1 - 0.15) = 850$。\n\nHUP中假阴性的预期数量：\n$$E[\\text{FN}_{\\mathrm{HUP}}] = 150 \\times (1 - 0.86) = 150 \\times 0.14 = 21$$\nHUP中假阳性的预期数量：\n$$E[\\text{FP}_{\\mathrm{HUP}}] = 850 \\times (1 - 0.91) = 850 \\times 0.09 = 76.5$$\n\n**对于GP亚群：**\n给定参数为 $p_{\\mathrm{GP}} = 0.04$, $Se_{\\mathrm{GP}} = 0.93$, 和 $Sp_{\\mathrm{GP}} = 0.96$。\n预期患病个体数量：$1{,}000 \\times 0.04 = 40$。\n预期未患病个体数量：$1{,}000 \\times (1 - 0.04) = 960$。\n\nGP中假阴性的预期数量：\n$$E[\\text{FN}_{\\mathrm{GP}}] = 40 \\times (1 - 0.93) = 40 \\times 0.07 = 2.8$$\nGP中假阳性的预期数量：\n$$E[\\text{FP}_{\\mathrm{GP}}] = 960 \\times (1 - 0.96) = 960 \\times 0.04 = 38.4$$\n\n**任务2：计算总QALY损失，$H_{\\mathrm{HUP}}$ 和 $H_{\\mathrm{GP}}$**\n\n一个亚群的总预期QALY损失 $H$ 是FN和FP损失的总和。\n$$H = E[\\text{FN}] \\times L_{\\mathrm{FN}} + E[\\text{FP}] \\times L_{\\mathrm{FP}}$$\n其中 $L_{\\mathrm{FN}}$ 和 $L_{\\mathrm{FP}}$ 是每个错误的QALY损失。\n\n**对于HUP亚群：**\n给定的QALY损失为 $L_{\\mathrm{FN,HUP}} = 0.9$ 和 $L_{\\mathrm{FP,HUP}} = 0.08$。\n$$H_{\\mathrm{HUP}} = E[\\text{FN}_{\\mathrm{HUP}}] \\times L_{\\mathrm{FN,HUP}} + E[\\text{FP}_{\\mathrm{HUP}}] \\times L_{\\mathrm{FP,HUP}}$$\n$$H_{\\mathrm{HUP}} = (21 \\times 0.9) + (76.5 \\times 0.08) = 18.9 + 6.12 = 25.02$$\n因此，HUP中的总预期QALY损失为每$1{,}000$名受试者 $25.02$ QALY。\n\n**对于GP亚群：**\n给定的QALY损失为 $L_{\\mathrm{FN,GP}} = 0.6$ 和 $L_{\\mathrm{FP,GP}} = 0.05$。\n$$H_{\\mathrm{GP}} = E[\\text{FN}_{\\mathrm{GP}}] \\times L_{\\mathrm{FN,GP}} + E[\\text{FP}_{\\mathrm{GP}}] \\times L_{\\mathrm{FP,GP}}$$\n$$H_{\\mathrm{GP}} = (2.8 \\times 0.6) + (38.4 \\times 0.05) = 1.68 + 1.92 = 3.60$$\nGP中的总预期QALY损失为每$1{,}000$名受试者 $3.60$ QALY。\n\n**临床和公平性影响：**\n结局的差异是显著的。HUP中的总伤害（QALY损失）（$H_{\\mathrm{HUP}} = 25.02$）几乎是GP中（$H_{\\mathrm{GP}} = 3.60$）的7倍。这一巨大差异量化了由当前诊断策略驱动的显著健康不平等。在HUP中，伤害主要由漏诊（FNs）造成，贡献了 $18.9$ QALY的损失，这反映了高患病率和显著的单例影响。大量的假警报（FPs）也造成了显著的 $6.12$ QALY损失。相比之下，GP中的总伤害要低得多，并且在FN相关损失（$1.68$ QALY）和FP相关损失（$1.92$ QALY）之间更为平衡。GP中较低的患病率是其总伤害较低的一个主要因素。该分析强调，HUP最迫切需要一种改进的诊断方法，因为目前的测试似乎不适用于该人群，造成了巨大伤害并加剧了健康差异。\n\n**任务3：计算优先指数 $U$**\n\n优先指数 $U$ 定义为：\n$$U = w_{\\mathrm{HUP}} H_{\\mathrm{HUP}} + w_{\\mathrm{GP}} H_{\\mathrm{GP}} + \\lambda | H_{\\mathrm{HUP}} - H_{\\mathrm{GP}} |$$\n政策权重给定为 $w_{\\mathrm{HUP}} = 1.3$, $w_{\\mathrm{GP}} = 1.0$, 和 $\\lambda = 0.4$。\n\n该指数由三部分组成：\n1.  HUP的伤害，由 $w_{\\mathrm{HUP}}$ 加权，以反映优先考虑该群体的政策。\n2.  GP的伤害，标准权重为 $w_{\\mathrm{GP}}=1.0$。\n3.  一个公平性组成部分，即两组之间伤害的绝对差值，由 $\\lambda$ 加权。该项明确惩罚差异性。\n\n代入计算出的值：\n$$H_{\\mathrm{HUP}} = 25.02$$\n$$H_{\\mathrm{GP}} = 3.60$$\n\n$U$ 的三个组成部分是：\n$$w_{\\mathrm{HUP}} H_{\\mathrm{HUP}} = 1.3 \\times 25.02 = 32.526$$\n$$w_{\\mathrm{GP}} H_{\\mathrm{GP}} = 1.0 \\times 3.60 = 3.60$$\n$$\\lambda | H_{\\mathrm{HUP}} - H_{\\mathrm{GP}} | = 0.4 \\times |25.02 - 3.60| = 0.4 \\times 21.42 = 8.568$$\n\n将这些部分相加得到 $U$ 的值：\n$$U = 32.526 + 3.60 + 8.568 = 44.694$$\n\n问题要求将最终答案四舍五入到四位有效数字。\n$U \\approx 44.69$。\n\n这个最终指数 $U$ 综合了临床伤害的总量和一个对该伤害不公平分配的明确惩罚，为优先排序提供了一个单一的量化指标。$U$ 值越高，表示未满足的需求越大。",
            "answer": "$$\\boxed{44.69}$$"
        },
        {
            "introduction": "在量化各项干预措施的潜在健康效益后，优先排序的最终环节是如何在有限的预算内分配资源，以实现最大化的人群健康收益。本练习将这一复杂的决策过程构建为一个可解的优化问题——经典的0-1背包模型。通过编写算法来挑选在预算约束下的最优干预项目组合 ，您将掌握一个把健康经济学证据转化为具体、高效的卫生政策的实用工具。",
            "id": "5022631",
            "problem": "给定一个有限的候选临床干预措施集合，用于解决转化医学中不同的未满足的临床需求。对于每项干预措施 $i \\in \\{0,1,\\dots,n-1\\}$，都提供了三个量：以美元（USD）为单位的货币成本 $c_i$，预期的伤残调整生命年（DALY）规避量 $d_i$，以及反映基于证据的未满足需求严重性优先级的优先级权重 $w_i$。假设遵循以下基本事实和原则：一组独立干预措施的总预期DALY规避量是各单个预期DALY规避量之和；优先级权重与临床效果量相乘以形成加权目标 $b_i = w_i \\cdot d_i$；资源约束由一个硬性预算 $B$ 表示，所选成本的总和不得超过 $B$。目标是选择一个干预措施子集，以在预算约束下最大化加权的总DALY规避量。\n\n您的任务是实现一个 $0$-$1$ 背包优化，对于给定的测试套件，返回最大化的加权总DALY规避量和所选干预措施的索引。该优化问题为：\n最大化 $\\sum_{i \\in S} b_i$，约束条件为 $\\sum_{i \\in S} c_i \\le B$ 且 $S \\subseteq \\{0,1,\\dots,n-1\\}$。\n您必须假设所有成本和预算都以大小为 $\\Delta$（一个正实数）的离散增量给出，并且所有 $c_i$ 和 $B$ 都是 $\\Delta$ 的整数倍。您必须通过将所有成本和预算除以 $\\Delta$ 来以整数容量单位实现优化，并使用基于收益可加性和容量约束的标准 $0$-$1$ 递推关系的动态规划方法。为确保确定性，如果两个子集产生相等的加权总DALY规避量（差异小于 $\\epsilon = 10^{-9}$），则选择总成本较小的子集；如果加权总DALY和总成本在 $\\epsilon$ 范围内均相等，则选择索引列表字典序最小的子集（按索引升序排列）。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，且不含空格。每个结果元素本身必须是一个双元素列表：第一个元素是最大化的加权总DALY规避量，四舍五入到三位小数，第二个元素是按升序排列的所选索引列表。例如，单个结果的格式为 $[x,[i_1,i_2,\\dots]]$，而多个测试用例的完整输出格式为 $[[x_1,[\\dots]],[x_2,[\\dots]],\\dots]$。\n\n请使用以下测试套件，它涵盖了一般情况、边界情况和打破平局的情况。所有成本 $c_i$ 和预算 $B$ 均以美元（USD）为单位，并且都是 $\\Delta = 50$ 美元的倍数。DALY值是无量纲的。优先级权重是无量纲的。\n\n测试用例 1（一般情况，非平凡权衡）：\n- $\\Delta = 50$\n- $c = [300,500,400,200,800,0,350]$\n- $d = [1.2,2.0,1.6,0.7,3.5,0.2,1.4]$\n- $w = [1.0,0.9,1.2,1.5,0.8,1.0,1.1]$\n- $B = 1200$\n\n测试用例 2（零预算边界；包含一个零成本项目）：\n- $\\Delta = 50$\n- $c = [300,500,400,200,800,0,350]$\n- $d = [1.2,2.0,1.6,0.7,3.5,0.2,1.4]$\n- $w = [1.0,0.9,1.2,1.5,0.8,1.0,1.1]$\n- $B = 0$\n\n测试用例 3（预算足以容纳所有项目）：\n- $\\Delta = 50$\n- $c = [300,500,400,200,800,0,350]$\n- $d = [1.2,2.0,1.6,0.7,3.5,0.2,1.4]$\n- $w = [1.0,0.9,1.2,1.5,0.8,1.0,1.1]$\n- $B = 3000$\n\n测试用例 4（按索引的字典序打破平局）：\n- $\\Delta = 50$\n- $c = [400,400,400]$\n- $d = [2.0,2.0,2.0]$\n- $w = [1.0,1.0,1.0]$\n- $B = 800$\n\n测试用例 5（按最小总成本打破平局）：\n- $\\Delta = 50$\n- $c = [500,400]$\n- $d = [1.9,1.9]$\n- $w = [1.0,1.0]$\n- $B = 500$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表，每个测试用例表示为 $[x,[i_1,i_2,\\dots]]$ 且不含空格，其中 $x$ 四舍五入到三位小数。例如：$[[x_1,[i_{1,1},i_{1,2}]], [x_2,[i_{2,1}]], \\dots]$，但整行中不含任何空格。",
            "solution": "首先对问题进行验证，以确保其科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n-   **干预措施**：一个由 $i \\in \\{0, 1, \\dots, n-1\\}$ 索引的有限集合。\n-   **干预措施数据**：对于每项干预措施 $i$，给定其成本 $c_i$（USD）、DALY规避量 $d_i$ 和优先级权重 $w_i$。\n-   **目标函数**：最大化加权总DALY规避量，其中一项干预措施的收益为 $b_i = w_i \\cdot d_i$。所选集合 $S$ 的总收益为 $\\sum_{i \\in S} b_i$。\n-   **约束条件**：所选干预措施的总成本不得超过预算 $B$，即 $\\sum_{i \\in S} c_i \\le B$。\n-   **优化模型**：该问题被定义为一个 $0$-$1$ 背包问题。\n-   **离散化**：成本 $c_i$ 和预算 $B$ 是一个值 $\\Delta > 0$ 的整数倍。优化必须使用通过除以 $\\Delta$ 得出的整数容量单位。\n-   **算法**：使用标准 $0$-$1$ 递推关系的动态规划（DP）。\n-   **打破平局规则**：用于在结果相等的子集之间进行选择的严格层次结构：\n    1.  如果总收益相等（差异小于 $\\epsilon = 10^{-9}$），选择总成本较小的子集。\n    2.  如果收益和成本均在 $\\epsilon$ 范围内相等，选择索引列表字典序最小的子集。\n-   **输出格式**：一个单行的、逗号分隔的结果列表 `[[benefit1,[indices1]],[benefit2,[indices2]],...]`，不含空格，其中收益四舍五入到三位小数。\n-   **测试套件**：提供了五个具体的测试用例及所有必要参数。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据**：问题是有效的。它使用成熟的 $0$-$1$ 背包模型，将卫生经济学和转化医学中常见的资源分配问题形式化。DALY、干预成本和预算约束是该领域的标准概念。\n-   **适定性**：该问题是适定的。它提供了清晰的目标函数、明确的约束条件和所有必要的数据。包含全面、确定性的打破平局程序确保了对于任何给定的输入都存在唯一且稳定的解。\n-   **客观性**：问题陈述客观，使用了精确的数学和领域特定术语，没有歧义或主观成分。\n\n### 步骤 3：结论与行动\n该问题是有效的，因为它具有科学依据、适定性和客观性。将开发一个解决方案。\n\n### 基于原则的设计\n\n这是一个经典的 $0$-$1$ 背包问题，旨在选择物品以在重量限制下最大化总价值。在这里，干预措施是“物品”，其加权DALY规避量 $b_i$ 是它们的“价值”，其成本 $c_i$ 是它们的“重量”。预算 $B$ 是背包的“容量”。\n\n解决 $0$-$1$ 背包问题的一种标准且高效的方法是动态规划。问题规定成本和预算是基本单位 $\\Delta$ 的整数倍。我们可以定义整数成本 $c'_i = c_i / \\Delta$ 和整数预算 $B' = B / \\Delta$。这使得我们可以采用一种DP方法，其复杂度与物品数量 $n$ 和整数预算 $B'$ 相关。\n\n最大化价值的标准DP递推关系是：\n$DP(i, j) = \\max(DP(i-1, j), b_i + DP(i-1, j - c'_i))$\n其中 $DP(i, j)$ 是使用来自 $\\{0, \\dots, i\\}$ 的物品且预算为 $j$ 时的最大收益。\n\n然而，指定的打破平局规则要求跟踪的不仅仅是最大收益。我们的DP状态必须扩展，以包含做出这些决策所需的信息。我们将给定整数预算 $j$ 的DP状态定义为一个元组：$(\\text{收益}, \\text{成本}, \\text{索引})$。目标是最大化收益，然后最小化成本，最后按字典序最小化索引列表。\n\n我们可以使用一个大小为 $B' + 1$ 的一维DP数组 `dp`，其中 `dp[j]` 存储整数预算为 $j$ 时的最优状态元组。该数组被初始化以表示“空集”解：对于所有可能的预算，其值为 $(0.0, 0.0, [])$。\n\n我们从 $0$ 到 $n-1$ 遍历每个干预措施 $i$。对于每个干预措施，我们从整数预算 $B'$ 向下遍历到该项目的整数成本 $c'_i$。对于一维DP数组，向后迭代至关重要，以确保每个项目最多只被考虑一次（即“$0$-$1$”属性）。\n\n在内循环中，对于每个预算 $j$，我们考虑两种可能性：\n1.  **不包含项目 $i$**：预算 $j$ 的最优解仍然是 `dp[j]`，这是由前面的项目决定的。\n2.  **包含项目 $i$**：如果 $j \\ge c'_i$，这是可能的。新的候选解是通过获取剩余预算 `dp[j - c'_i]` 的最优解并添加项目 $i$ 来形成的。候选状态为：\n    -   `new_benefit` = `dp[j - c'_i].benefit + b_i`\n    -   `new_cost` = `dp[j - c'_i].cost + c_i` （使用原始货币成本进行平局打破）\n    -   `new_indices` = `dp[j - c'_i].indices + [i]`\n\n然后，我们使用精确的、分层的打破平局规则将这个新的候选状态与当前状态 `dp[j]` 进行比较：\n-   如果 `new_benefit` 大于 `current_benefit`（超过 $\\epsilon = 10^{-9}$），我们更新 `dp[j]`。\n-   否则，如果 `new_benefit` 和 `current_benefit` 实际上相等，我们比较成本。如果 `new_cost` 小于 `current_cost`（超过 $\\epsilon$），我们更新 `dp[j]`。\n-   否则，如果收益和成本都相等，我们按字典序比较索引列表。如果 `new_indices` 小于 `current_indices`，我们更新 `dp[j]`。\n\n通过按索引 $i$ 的升序（从 $0$ 到 $n-1$）处理项目，任何状态 `dp[...].indices` 中的索引列表都将自然排序。当我们通过将 $i$ 附加到 `dp[j - c'_i].indices` 来形成 `new_indices` 时，由于前一个列表中的所有索引都小于 $i$，因此结果列表保持排序状态。这避免了在算法最内层循环中进行昂贵的排序操作，从而使字典序比较变得高效。\n\n遍历所有项目后，条目 `dp[B']` 将包含对应于完整预算 $B$ 的最优解的元组。然后从该元组中提取最终答案并按要求格式化。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1 (general case)\n        {\n            \"c\": [300, 500, 400, 200, 800, 0, 350],\n            \"d\": [1.2, 2.0, 1.6, 0.7, 3.5, 0.2, 1.4],\n            \"w\": [1.0, 0.9, 1.2, 1.5, 0.8, 1.0, 1.1],\n            \"B\": 1200,\n            \"Delta\": 50\n        },\n        # Test Case 2 (zero budget)\n        {\n            \"c\": [300, 500, 400, 200, 800, 0, 350],\n            \"d\": [1.2, 2.0, 1.6, 0.7, 3.5, 0.2, 1.4],\n            \"w\": [1.0, 0.9, 1.2, 1.5, 0.8, 1.0, 1.1],\n            \"B\": 0,\n            \"Delta\": 50\n        },\n        # Test Case 3 (budget for all)\n        {\n            \"c\": [300, 500, 400, 200, 800, 0, 350],\n            \"d\": [1.2, 2.0, 1.6, 0.7, 3.5, 0.2, 1.4],\n            \"w\": [1.0, 0.9, 1.2, 1.5, 0.8, 1.0, 1.1],\n            \"B\": 3000,\n            \"Delta\": 50\n        },\n        # Test Case 4 (lexicographic tie-break)\n        {\n            \"c\": [400, 400, 400],\n            \"d\": [2.0, 2.0, 2.0],\n            \"w\": [1.0, 1.0, 1.0],\n            \"B\": 800,\n            \"Delta\": 50\n        },\n        # Test Case 5 (cost tie-break)\n        {\n            \"c\": [500, 400],\n            \"d\": [1.9, 1.9],\n            \"w\": [1.0, 1.0],\n            \"B\": 500,\n            \"Delta\": 50\n        }\n    ]\n    epsilon = 1e-9\n\n    def solve_knapsack(c, d, w, B, Delta):\n        \"\"\"\n        Solves the 0-1 knapsack problem with tie-breaking using dynamic programming.\n        \"\"\"\n        n = len(c)\n        # Using numpy for efficient element-wise multiplication\n        benefits = np.array(w) * np.array(d)\n        \n        # Discretize costs and budget\n        int_costs = [int(ci / Delta) for ci in c]\n        int_budget = int(B / Delta)\n\n        # dp[j] stores a tuple: (max_benefit, min_cost, indices_list) for integer budget j\n        dp = [(0.0, 0.0, []) for _ in range(int_budget + 1)]\n\n        for i in range(n):\n            b_i = benefits[i]\n            c_i = c[i]\n            c_int_i = int_costs[i]\n\n            # Iterate backwards to ensure each item is used at most once (0-1 property)\n            for j in range(int_budget, c_int_i - 1, -1):\n                # Candidate solution by including item i\n                prev_benefit, prev_cost, prev_indices = dp[j - c_int_i]\n                \n                new_benefit = prev_benefit + b_i\n                new_cost = prev_cost + c_i\n                \n                # As items are processed in order 0..n-1, prev_indices contains indices  i.\n                # Appending i maintains the sorted order of the list.\n                new_indices = prev_indices + [i]\n\n                # Current best solution for budget j\n                curr_benefit, curr_cost, curr_indices = dp[j]\n\n                # Compare candidate with current best using hierarchical tie-breaking rules\n                update = False\n                if new_benefit > curr_benefit + epsilon:\n                    update = True\n                elif abs(new_benefit - curr_benefit) = epsilon:\n                    if new_cost  curr_cost - epsilon:\n                        update = True\n                    elif abs(new_cost - curr_cost) = epsilon:\n                        if new_indices  curr_indices:\n                            update = True\n                \n                if update:\n                    dp[j] = (new_benefit, new_cost, new_indices)\n\n        # The final optimal tuple is at the full budget\n        final_benefit, _, final_indices = dp[int_budget]\n        return final_benefit, final_indices\n\n    results = []\n    for case in test_cases:\n        benefit, indices = solve_knapsack(case[\"c\"], case[\"d\"], case[\"w\"], case[\"B\"], case[\"Delta\"])\n        \n        # Format the result string according to spec, removing all spaces\n        indices_str = str(indices).replace(' ', '')\n        result_str = f\"[{benefit:.3f},{indices_str}]\"\n        results.append(result_str)\n\n    # Print the final single-line output\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}