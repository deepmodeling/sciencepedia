{"hands_on_practices": [{"introduction": "Understanding linkage disequilibrium (LD) begins with quantifying the non-random association of alleles at different loci. The coefficient of linkage disequilibrium, denoted as $D$, provides a direct measure of the deviation between observed haplotype frequencies and what would be expected under random association. This foundational exercise [@problem_id:1501155] will guide you through the process of calculating $D$ from observed haplotype counts, a critical first step in analyzing the genetic structure of a population.", "problem": "In a population study of a specific species of wildflower, a geneticist examines two gene loci on the same chromosome. The first locus, which we can call locus 'A', determines petal color, with allele 'A' conferring red petals and allele 'a' conferring white petals. The second locus, 'B', influences stem length, with allele 'B' resulting in a tall phenotype and allele 'b' in a dwarf phenotype. After sampling a large number of plants from the population, the geneticist determines the counts of the four possible haplotypes. The observed haplotype counts are as follows: 350 for 'AB', 250 for 'Ab', 150 for 'aB', and 250 for 'ab'.\n\nCalculate the coefficient of linkage disequilibrium, $D$, for these two loci in this population. Provide your answer as an exact decimal value.", "solution": "We are given haplotype counts for two loci: counts for $AB$, $Ab$, $aB$, and $ab$ are $350$, $250$, $150$, and $250$, respectively. Let the total number sampled be\n$$\nN=350+250+150+250=1000.\n$$\nThe haplotype frequencies are the counts divided by $N$:\n$$\nf_{AB}=\\frac{350}{1000}=0.35,\\quad f_{Ab}=\\frac{250}{1000}=0.25,\\quad f_{aB}=\\frac{150}{1000}=0.15,\\quad f_{ab}=\\frac{250}{1000}=0.25.\n$$\nAllele frequencies at locus $A$ and $B$ are obtained by summing appropriate haplotype frequencies:\n$$\np_{A}=f_{AB}+f_{Ab}=0.35+0.25=0.60,\\quad p_{a}=f_{aB}+f_{ab}=0.15+0.25=0.40,\n$$\n$$\np_{B}=f_{AB}+f_{aB}=0.35+0.15=0.50,\\quad p_{b}=f_{Ab}+f_{ab}=0.25+0.25=0.50.\n$$\nThe coefficient of linkage disequilibrium is defined by\n$$\nD=f_{AB}-p_{A}p_{B}.\n$$\nSubstituting the computed frequencies gives\n$$\nD=0.35-(0.60)(0.50)=0.35-0.30=0.05.\n$$\nAs a check, the identity $D=f_{AB}f_{ab}-f_{Ab}f_{aB}$ yields\n$$\nD=(0.35)(0.25)-(0.25)(0.15)=0.0875-0.0375=0.05,\n$$\nwhich is consistent.", "answer": "$$\\boxed{0.05}$$", "id": "1501155"}, {"introduction": "While the $D$ coefficient is fundamental, its value is constrained by the allele frequencies at the loci being studied, making comparisons difficult. To address this, geneticists often use a standardized measure: the squared correlation coefficient, $r^2$. This practice problem [@problem_id:1501170] demonstrates how to calculate $r^2$, providing a robust metric that reflects the statistical correlation between alleles and is widely used in applications like disease gene mapping.", "problem": "A population geneticist is studying a large, randomly mating population of maize. Two genetic loci on the same chromosome are of interest. The first locus controls kernel color, with allele `A` for purple kernels and allele `a` for yellow kernels. The second locus affects plant height, with allele `B` for tall plants and allele `b` for dwarf plants. After sequencing a large sample of gametes from this population, the geneticist determines the frequencies of the four possible haplotypes to be as follows:\n\n-   Frequency of AB haplotype ($f_{AB}$): 0.23\n-   Frequency of Ab haplotype ($f_{Ab}$): 0.37\n-   Frequency of aB haplotype ($f_{aB}$): 0.07\n-   Frequency of ab haplotype ($f_{ab}$): 0.33\n\nUsing this data, calculate the squared correlation coefficient, $r^2$, which is a standardized measure of linkage disequilibrium between the kernel color and plant height loci. Round your final answer to four significant figures.", "solution": "We are given haplotype frequencies for two loci: $f_{AB}=0.23$, $f_{Ab}=0.37$, $f_{aB}=0.07$, $f_{ab}=0.33$, with $f_{AB}+f_{Ab}+f_{aB}+f_{ab}=1$.\n\nFirst compute allele frequencies:\n$$p_{A}=f_{AB}+f_{Ab}=0.23+0.37=0.60,\\quad p_{a}=1-p_{A}=0.40,$$\n$$p_{B}=f_{AB}+f_{aB}=0.23+0.07=0.30,\\quad p_{b}=1-p_{B}=0.70.$$\n\nThe linkage disequilibrium coefficient is\n$$D=f_{AB}-p_{A}p_{B}.$$\nSubstitute values:\n$$D=0.23-(0.60)(0.30)=0.23-0.18=0.05.$$\n\nThe squared correlation coefficient is\n$$r^{2}=\\frac{D^{2}}{p_{A}p_{a}p_{B}p_{b}}.$$\nCompute denominator and numerator:\n$$p_{A}p_{a}p_{B}p_{b}=(0.60)(0.40)(0.30)(0.70)=0.0504,$$\n$$D^{2}=(0.05)^{2}=0.0025.$$\nTherefore,\n$$r^{2}=\\frac{0.0025}{0.0504}=\\frac{25}{504}\\approx 0.049603\\ldots$$\nRounded to four significant figures, this is $0.04960$.", "answer": "$$\\boxed{0.04960}$$", "id": "1501170"}, {"introduction": "Patterns of linkage disequilibrium are not uniform across the genome; they often form 'haplotype blocks'—regions with strong LD separated by hotspots of recombination. Identifying these blocks is a key task in computational genomics. This advanced practice [@problem_id:2401326] challenges you to implement the Four-Gamete Rule, a classic algorithm used to partition a chromosomal segment into haplotype blocks based on evidence of historical recombination, bridging the gap between theoretical population genetics and practical data analysis.", "problem": "Implement a program that, given phased biallelic haplotype data for a contiguous set of loci, partitions the loci into candidate haplotype blocks using the Four-Gamete Rule. The program must be written from first principles and must not rely on pre-built population genetics libraries. The algorithmic basis should start from core definitions of haplotypes, recombination, and the Four-Gamete Rule under the infinite-sites model, without shortcut formulas. The data are represented as a matrix of integers where rows are haplotypes and columns are loci. Each entry is in the set $\\{0,1\\}$ for observed alleles, with optional missing values denoted by $-1$. A block is defined as a maximal contiguous set of loci such that no pair of loci within the same block exhibits all four biallelic combinations across the observed haplotypes, ignoring rows with missing data at either locus. The task is to implement a greedy left-to-right algorithm that yields the coarsest partition into such blocks.\n\nDefinitions and constraints:\n- A haplotype matrix $H$ has shape $n \\times m$ with $n \\ge 1$ haplotypes (rows) and $m \\ge 1$ loci (columns). Entries are in $\\{0,1\\}$ or the missing symbol $-1$.\n- For two loci $i$ and $j$, enumerate observed allele pairs $(H_{r,i}, H_{r,j})$ across rows $r \\in \\{0,\\dots,n-1\\}$, ignoring any row where either value is $-1$. If the set of observed pairs equals $\\{(0,0),(0,1),(1,0),(1,1)\\}$, then loci $i$ and $j$ are said to exhibit four gametes (evidence of historical recombination or recurrent mutation under the infinite-sites model).\n- A valid block is a maximal contiguous index range $[s,e]$ with $0 \\le s \\le e \\le m-1$ such that for every pair $(i,j)$ with $s \\le i < j \\le e$, the observed pairs do not contain all four gametes.\n- The greedy partitioning algorithm must scan loci from left to right, growing the current block by attempting to add the next locus. If adding a locus $j$ would create any pair $(i,j)$ with four gametes for some $i$ already in the block, then the current block ends at $j-1$ and a new block starts at $j$. Continue until all loci are assigned to blocks. The result must be the list of blocks as index intervals $[s,e]$ using $0$-based inclusive indices.\n\nInput to be embedded in the program as a test suite:\n- Use the missing data symbol $-1$ exactly as specified.\n- All indices are $0$-based and inclusive.\n- Test matrices are listed row-wise; each inner list represents a row (haplotype).\n\nTest suite (five cases):\n1. Case T$1$ (no four-gamete evidence, single block):\n   - $H_1$ is $4 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[1,1,1,1]$\n     - Row $2$: $[0,0,0,0]$\n     - Row $3$: $[1,1,1,1]$\n   - Expected to produce a single block spanning indices $[0,3]$.\n\n2. Case T$2$ (one internal boundary due to four gametes when extending):\n   - $H_2$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,1,1]$\n     - Row $2$: $[1,1,1,0,0]$\n     - Row $3$: $[1,1,1,1,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,1,1]$\n   - Adding locus index $3$ introduces all four gametes with earlier loci, creating a boundary between indices $2$ and $3$. The second block spans indices $[3,4]$.\n\n3. Case T$3$ (missing data prevent four-gamete detection, larger block):\n   - $H_3$ is $6 \\times 4$:\n     - Row $0$: $[0,0,0,0]$\n     - Row $1$: $[0,0,0,1]$\n     - Row $2$: $[1,1,1,0]$\n     - Row $3$: $[1,1,1,-1]$\n     - Row $4$: $[0,0,0,0]$\n     - Row $5$: $[1,1,1,-1]$\n   - Due to missing values $-1$ in the last column, not all four gametes are observed for any pair, yielding a single block $[0,3]$.\n\n4. Case T$4$ (every attempted extension triggers a boundary, single-locus blocks):\n   - $H_4$ is $4 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,1,0,1,0]$\n     - Row $2$: $[1,0,1,0,1]$\n     - Row $3$: $[1,1,1,1,1]$\n   - Alternating patterns ensure four gametes between adjacent loci when attempting to extend, producing blocks $[0,0]$, $[1,1]$, $[2,2]$, $[3,3]$, $[4,4]$.\n\n5. Case T$5$ (monomorphic locus within a block):\n   - $H_5$ is $6 \\times 5$:\n     - Row $0$: $[0,0,0,0,0]$\n     - Row $1$: $[0,0,0,0,0]$\n     - Row $2$: $[1,1,1,0,1]$\n     - Row $3$: $[1,1,1,0,1]$\n     - Row $4$: $[0,0,0,0,0]$\n     - Row $5$: $[1,1,1,0,1]$\n   - The fourth column is monomorphic with allele $0$, and all other columns are in perfect concordance, leading to a single block $[0,4]$.\n\nFinal output format:\n- For each test case, output the list of block intervals as a list of two-integer lists $[s,e]$.\n- Aggregate the five case results into a single top-level list in order T$1$, T$2$, T$3$, T$4$, T$5$.\n- Your program should produce a single line of output containing this aggregate as a comma-separated list enclosed in square brackets with no spaces, for example: $[[[0,3]],[[0,2],[3,4]],\\dots]$.\n- Each $s$ and $e$ must be $0$-based indices and inclusive.\n\nThe program must compute these partitions using the specified algorithm and print exactly one line matching the format above. No physical units or angle units are involved. Express any fractions or proportions as decimals if needed (not required here).", "solution": "The problem requires the implementation of a greedy algorithm to partition a set of genetic loci into haplotype blocks. The criterion for this partition is the Four-Gamete Rule, a fundamental concept derived from the infinite-sites model of mutation.\n\nFirst, we must formalize the underlying scientific principle. The infinite-sites model posits that every new mutation occurs at a unique site along a chromosome that has not previously experienced a mutation in the sampled population. Consider two biallelic loci, located at positions $i$ and $j$, with alleles $\\{0,1\\}$. If no recombination has occurred between these two loci in the evolutionary history of the observed haplotypes, then at most three of the four possible two-locus gametes—$(0,0)$, $(0,1)$, $(1,0)$, and $(1,1)$—can exist. The appearance of the fourth gamete can only be explained by a recombination event between the loci or by a recurrent mutation at one of the sites, the latter of which is disallowed by the infinite-sites model. Thus, the presence of all four gametes, denoted as a \"four-gamete pair,\" is strong evidence for at least one historical recombination event between the loci.\n\nThe core of the algorithm is a function to test for this condition. Let the input haplotype data be represented by a matrix $H$ of size $n \\times m$, where $n$ is the number of haplotypes and $m$ is the number of loci. An entry $H_{r,k}$ represents the allele at locus $k$ for haplotype $r$, where $k \\in \\{0, \\dots, m-1\\}$ and $r \\in \\{0, \\dots, n-1\\}$. Alleles are in $\\{0,1\\}$, with $-1$ indicating missing data.\n\nTo determine if two loci, $i$ and $j$, constitute a four-gamete pair, we perform the following check:\n1. Initialize an empty set, $S_{i,j}$, to store unique, valid allele pairs.\n2. Iterate through each haplotype $r$ from $0$ to $n-1$.\n3. For each haplotype $r$, consider the allele pair $(H_{r,i}, H_{r,j})$.\n4. If either $H_{r,i} = -1$ or $H_{r,j} = -1$, this pair contains missing data and must be ignored.\n5. If the pair is valid, add it to the set $S_{i,j}$.\n6. After iterating through all $n$ haplotypes, the test for a four-gamete pair is positive if and only if the set $S_{i,j}$ is equal to $\\{(0,0), (0,1), (1,0), (1,1)\\}$. For biallelic data, this is equivalent to checking if the cardinality of the set, $|S_{i,j}|$, is equal to $4$.\n\nWith this test established, we can construct the greedy block partitioning algorithm as specified. The algorithm proceeds from left to right across the loci, extending a block as far as possible.\n\nLet $m$ be the total number of loci, indexed from $0$ to $m-1$.\n1. Initialize an empty list, $\\mathcal{B}$, to store the resulting block partitions.\n2. Initialize the starting index of the current block, $s$, to $0$.\n3. Iterate with a prospective locus index, $j$, from $1$ to $m-1$. For each $j$, we test if locus $j$ can be included in the current block that starts at index $s$.\n4. To perform this test, we must check for a four-gamete violation between locus $j$ and every locus $i$ already in the current block, where $i$ ranges from $s$ to $j-1$.\n5. A violation occurs if the four-gamete test is positive for any pair of loci $(i,j)$ within this range.\n6. If a violation is found for some locus $i \\in [s, j-1]$:\n   a. The current block is finalized. Its interval is $[s, j-1]$. This interval is added to the list $\\mathcal{B}$.\n   b. A new block must begin at the current locus $j$. The start index $s$ is updated to $j$.\n   c. The inner check for other loci $i$ is terminated, and the algorithm proceeds to the next prospective locus, $j+1$.\n7. If the inner loop over all $i \\in [s, j-1]$ completes without finding any four-gamete violation, locus $j$ is successfully added to the current block. The algorithm then proceeds to evaluate the next locus, $j+1$, without changing the block start $s$.\n8. After the main loop over $j$ completes, the final block, which starts at the current value of $s$ and extends to the last locus $m-1$, must be finalized and added to $\\mathcal{B}$. The interval is $[s, m-1]$.\n\nThis deterministic, greedy procedure produces a unique partition of the loci into contiguous blocks for any given haplotype matrix $H$. Each block is maximal in the sense that it could not be extended further to the right without violating the Four-Gamete Rule.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the block partitioning algorithm.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case T1\n        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]],\n        # Case T2\n        [[0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]],\n        # Case T3\n        [[0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, -1], [0, 0, 0, 0], [1, 1, 1, -1]],\n        # Case T4\n        [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]],\n        # Case T5\n        [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1]],\n    ]\n\n    def check_four_gametes(locus1_col, locus2_col):\n        \"\"\"\n        Checks if two loci exhibit all four gametic types.\n        Missing data (-1) are ignored.\n        \n        Args:\n            locus1_col (np.ndarray): A 1D array representing allele data for the first locus.\n            locus2_col (np.ndarray): A 1D array representing allele data for the second locus.\n        \n        Returns:\n            bool: True if four gametes are observed, False otherwise.\n        \"\"\"\n        observed_pairs = set()\n        for i in range(len(locus1_col)):\n            allele1 = locus1_col[i]\n            allele2 = locus2_col[i]\n            \n            # Ignore haplotypes with missing data at either locus\n            if allele1 != -1 and allele2 != -1:\n                observed_pairs.add((allele1, allele2))\n        \n        # The condition is met if the number of unique pairs is exactly 4\n        return len(observed_pairs) == 4\n\n    def find_blocks(haplotype_matrix):\n        \"\"\"\n        Partitions loci into blocks using the greedy Four-Gamete Rule algorithm.\n        \n        Args:\n            haplotype_matrix (list of lists): The input matrix of haplotypes.\n            \n        Returns:\n            list of lists: A list of [start, end] intervals for each block.\n        \"\"\"\n        H = np.array(haplotype_matrix, dtype=np.int8)\n        _n_haplotypes, n_loci = H.shape\n\n        if n_loci == 0:\n            return []\n        if n_loci == 1:\n            return [[0, 0]]\n\n        blocks = []\n        block_start = 0\n\n        # Iterate through loci to decide where blocks end\n        for j in range(1, n_loci):\n            violation_found = False\n            # Check current locus j against all previous loci in the current block\n            for i in range(block_start, j):\n                if check_four_gametes(H[:, i], H[:, j]):\n                    # Violation found, end the current block here\n                    blocks.append([block_start, j - 1])\n                    # Start a new block at the current locus\n                    block_start = j\n                    violation_found = True\n                    break\n            if violation_found:\n                continue\n        \n        # Add the last block, which extends to the end of the loci\n        blocks.append([block_start, n_loci - 1])\n        \n        return blocks\n\n    results = []\n    for case in test_cases:\n        result = find_blocks(case)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2401326"}]}