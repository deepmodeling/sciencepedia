{"hands_on_practices": [{"introduction": "A gamma camera’s ability to distinguish between scattered and unscattered photons is fundamental to creating high-contrast images. This capability, known as energy resolution ($R_E$), originates in the first stages of signal detection. This exercise guides you through the process of quantifying energy resolution by tracing the path from a single gamma-ray interaction to the generation of photoelectrons, revealing how the physical properties of the scintillator and photomultiplier tube dictate this crucial performance metric [@problem_id:4888105].", "problem": "A gamma camera based on a sodium iodide activated with thallium scintillator (NaI(Tl)) and a photomultiplier tube (PMT) measures the energy of incident gamma rays by converting scintillation light into an electrical signal. Consider a single $140\\ \\mathrm{keV}$ gamma-ray interaction that produces $N_{ph}=5320$ scintillation photons in the crystal. Each photon is transported to the PMT with a collection efficiency of $0.80$ and, if it reaches the photocathode, has a quantum efficiency of $0.25$ for producing a photoelectron. The PMT multiplication process introduces gain fluctuations characterized by an excess noise factor $F=1.2$. \n\nStarting from (i) the definition of quantum efficiency and collection efficiency as probabilities for photon detection, (ii) Poisson statistics for photoelectron counting, and (iii) the definition of energy resolution as the ratio of the full width at half maximum (FWHM) to the mean of a Gaussian response, derive the expected number of detected photoelectrons $N_{pe}$ and the predicted fractional energy resolution $R_E$ for this event. Express $R_E$ as a dimensionless decimal rounded to four significant figures. Provide the final answer as the ordered pair $\\left(N_{pe}, R_E\\right)$.", "solution": "The problem requires the derivation of the expected number of detected photoelectrons, $\\bar{N}_{pe}$, and the fractional energy resolution, $R_E$, for a gamma-ray interaction in a scintillation detector.\n\nFirst, we determine the expected number of photoelectrons, $\\bar{N}_{pe}$.\nThe process begins with a single gamma-ray interaction producing a mean number of scintillation photons, $\\bar{N}_{ph} = 5320$. These photons travel to the photocathode of a photomultiplier tube (PMT). The problem states that the collection efficiency, $\\eta_c = 0.80$, can be interpreted as the probability that a given photon reaches the photocathode. Upon reaching the photocathode, each photon has a probability, given by the quantum efficiency $\\eta_q = 0.25$, of producing a photoelectron.\n\nTherefore, the total probability, $p$, for a single scintillation photon to successfully generate a photoelectron is the product of these independent probabilities:\n$$p = \\eta_c \\times \\eta_q$$\nThe expected number of photoelectrons, $\\bar{N}_{pe}$, generated from the initial $\\bar{N}_{ph}$ photons is given by the product of the number of photons and the probability of conversion for each:\n$$\\bar{N}_{pe} = \\bar{N}_{ph} \\times p = \\bar{N}_{ph} \\eta_c \\eta_q$$\nSubstituting the given values:\n$$\\bar{N}_{pe} = 5320 \\times 0.80 \\times 0.25$$\n$$\\bar{N}_{pe} = 5320 \\times 0.20$$\n$$\\bar{N}_{pe} = 1064$$\nThis is the expected number of photoelectrons produced at the photocathode.\n\nNext, we derive the fractional energy resolution, $R_E$.\nThe energy resolution is defined as the ratio of the full width at half maximum (FWHM) of the detected energy peak to the mean energy, $\\bar{E}$, or equivalently, the mean signal, $\\bar{S}$:\n$$R_E = \\frac{\\text{FWHM}}{\\bar{S}}$$\nThe problem specifies that the detector response is Gaussian. For a Gaussian distribution, the FWHM is related to the standard deviation, $\\sigma_S$, of the distribution by:\n$$\\text{FWHM} = 2\\sqrt{2\\ln 2} \\ \\sigma_S \\approx 2.355 \\sigma_S$$\nSubstituting this into the definition of $R_E$:\n$$R_E = 2\\sqrt{2\\ln 2} \\frac{\\sigma_S}{\\bar{S}}$$\nThe quantity $\\frac{\\sigma_S}{\\bar{S}}$ is the fractional standard deviation of the output signal. Our task is to relate this to the statistical fluctuations in the detector.\n\nThe signal generation involves two main statistical processes: the creation of photoelectrons and their subsequent multiplication in the PMT.\n1.  **Photoelectron Statistics**: As instructed, we model the generation of photoelectrons as a Poisson process. For a mean number of photoelectrons $\\bar{N}_{pe}$, the variance is $\\sigma_{N_{pe}}^2 = \\bar{N}_{pe}$. The squared signal-to-noise ratio for the photoelectrons is $(\\text{S/N})^2_{\\text{in}} = \\frac{\\bar{N}_{pe}^2}{\\sigma_{N_{pe}}^2} = \\frac{\\bar{N}_{pe}^2}{\\bar{N}_{pe}} = \\bar{N}_{pe}$.\n\n2.  **PMT Multiplication**: The multiplication process in the PMT is also statistical and introduces additional noise. The excess noise factor, $F$, quantifies this degradation of the signal-to-noise ratio. It is defined as the ratio of the squared signal-to-noise at the input (photocathode) to the squared signal-to-noise at the output (anode):\n$$F = \\frac{(\\text{S/N})^2_{\\text{in}}}{(\\text{S/N})^2_{\\text{out}}}$$\nThe squared signal-to-noise ratio at the output is $(\\text{S/N})^2_{\\text{out}} = \\frac{\\bar{S}^2}{\\sigma_S^2}$.\n\nBy substituting the expressions for the input and output squared signal-to-noise ratios into the definition of $F$, we can solve for the fractional variance of the output signal:\n$$F = \\frac{\\bar{N}_{pe}}{\\bar{S}^2 / \\sigma_S^2} = \\bar{N}_{pe} \\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2$$\nRearranging this equation gives:\n$$\\left(\\frac{\\sigma_S}{\\bar{S}}\\right)^2 = \\frac{F}{\\bar{N}_{pe}}$$\nThe fractional standard deviation is therefore:\n$$\\frac{\\sigma_S}{\\bar{S}} = \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\nNow, we substitute this result back into our expression for the energy resolution $R_E$:\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{F}{\\bar{N}_{pe}}}$$\nUsing the calculated value $\\bar{N}_{pe} = 1064$ and the given value $F = 1.2$:\n$$R_E = 2\\sqrt{2\\ln 2} \\sqrt{\\frac{1.2}{1064}}$$\n$$R_E \\approx 2.35482 \\sqrt{0.0011278195...}$$\n$$R_E \\approx 2.35482 \\times 0.03358302...$$\n$$R_E \\approx 0.0790803...$$\nThe problem requires the result to be rounded to four significant figures.\n$$R_E \\approx 0.07908$$\n\nThe final answer is the ordered pair $(\\bar{N}_{pe}, R_E)$.\nThe calculated values are $\\bar{N}_{pe} = 1064$ and $R_E = 0.07908$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1064 & 0.07908\n\\end{pmatrix}\n}\n$$", "id": "4888105"}, {"introduction": "Beyond determining a photon's energy, a gamma camera must accurately pinpoint its location on the detector to form an image. The sharpness of this image is governed by the system's spatial resolution, which is limited by multiple blurring factors. In this practice, you will explore how the two primary components of blur—the detector's own intrinsic resolution and the geometric blur from the collimator—are combined to determine the overall system resolution [@problem_id:4888042]. This calculation demonstrates a fundamental principle in imaging physics, where the variances of independent, Gaussian blur sources are additive.", "problem": "A gamma camera equipped with a parallel-hole collimator is used to image a point source located at a source-to-collimator distance of $z=10\\ \\text{cm}$. The camera’s measured intrinsic point spread function (PSF) is well approximated by a Gaussian with standard deviation $\\sigma_{int}=1.5\\ \\text{mm}$. The collimator blur at $z=10\\ \\text{cm}$ is measured to have a full width at half maximum (FWHM) $R_{col}=8\\ \\text{mm}$. Under the assumptions that the system is linear and shift-invariant, and that the intrinsic blur and collimator blur are independent and each Gaussian, derive from first principles the expected system PSF width at $z=10\\ \\text{cm}$ expressed as the full width at half maximum. Express your final answer in millimeters and round to four significant figures.", "solution": "The problem asks for the system's full width at half maximum ($FWHM_{sys}$) given the intrinsic resolution (as a standard deviation, $\\sigma_{int}$) and the collimator resolution (as a FWHM, $R_{col}$).\n\n**Step 1: Relate FWHM and Standard Deviation for a Gaussian PSF**\nFor a Gaussian distribution, the FWHM is related to the standard deviation ($\\sigma$) by the formula:\n$$FWHM = 2\\sqrt{2\\ln 2} \\cdot \\sigma$$\nThis relationship can be squared to relate the FWHM squared to the variance ($\\sigma^2$):\n$$FWHM^2 = (2\\sqrt{2\\ln 2})^2 \\cdot \\sigma^2 = (8\\ln 2) \\cdot \\sigma^2$$\n\n**Step 2: Combine Independent Blurring Components**\nThe problem states that the intrinsic and collimator blur components are independent and that the system is linear and shift-invariant. In such a system, the overall point spread function ($PSF_{sys}$) is the convolution of the component PSFs. A key property of Gaussian functions is that the convolution of two Gaussians is another Gaussian whose variance is the sum of the individual variances.\n$$\\sigma_{sys}^2 = \\sigma_{int}^2 + \\sigma_{col}^2$$\n\n**Step 3: Combine FWHMs in Quadrature**\nUsing the relationship from Step 1, we can express the variance addition in terms of FWHMs:\n$$\\frac{FWHM_{sys}^2}{8\\ln 2} = \\frac{FWHM_{int}^2}{8\\ln 2} + \\frac{FWHM_{col}^2}{8\\ln 2}$$\nMultiplying by $8\\ln 2$ shows that the FWHMs add in quadrature:\n$$FWHM_{sys}^2 = FWHM_{int}^2 + FWHM_{col}^2$$\n\n**Step 4: Calculate the Numerical Result**\nWe are given:\n- Intrinsic standard deviation, $\\sigma_{int} = 1.5\\ \\text{mm}$.\n- Collimator FWHM, $R_{col} = FWHM_{col} = 8\\ \\text{mm}$.\n\nFirst, we must convert the intrinsic standard deviation to its corresponding FWHM:\n$$FWHM_{int} = 2\\sqrt{2\\ln 2} \\cdot \\sigma_{int} = 2\\sqrt{2\\ln 2} \\cdot (1.5\\ \\text{mm})$$\n\nNow, we substitute this into the quadrature sum formula:\n$$FWHM_{sys}^2 = \\left(2\\sqrt{2\\ln 2} \\cdot 1.5\\right)^2 + (8)^2$$\n$$FWHM_{sys}^2 = (4 \\cdot (2\\ln 2) \\cdot 1.5^2) + 64$$\n$$FWHM_{sys}^2 = (8\\ln 2 \\cdot 2.25) + 64$$\n$$FWHM_{sys}^2 = 18\\ln 2 + 64$$\n\nUsing the approximation $\\ln 2 \\approx 0.693147$:\n$$FWHM_{sys}^2 \\approx 18(0.693147) + 64 = 12.476646 + 64 = 76.476646\\ \\text{mm}^2$$\n\nTaking the square root to find the system FWHM:\n$$FWHM_{sys} = \\sqrt{76.476646} \\approx 8.745092\\ \\text{mm}$$\n\nRounding to four significant figures as requested:\n$$FWHM_{sys} \\approx 8.745\\ \\text{mm}$$", "answer": "$$\\boxed{8.745}$$", "id": "4888042"}, {"introduction": "For a gamma camera to produce a diagnostically reliable image, its response must be spatially consistent across its entire field of view; a uniform source of radiation should produce a uniform image. In practice, minor variations in detector sensitivity are inevitable and must be monitored through regular quality control (QC). This hands-on coding exercise simulates a critical QC procedure by having you analyze a flood-field image and compute standard metrics of nonuniformity: integral and differential uniformity [@problem_id:4888122]. By implementing these calculations, you will gain practical insight into how we ensure the fidelity and quality of gamma camera images.", "problem": "A gamma camera flood image can be represented as a two-dimensional array of nonnegative measured counts, denoted by $I(i,j)$ for row index $i$ and column index $j$. The image is acquired under a nearly uniform irradiation so that any spatial variation primarily reflects system nonuniformity. Consider the useful field of view (UFOV), which in this problem is defined as the central subarray obtained by excluding a margin of $m$ pixels from each edge of the original image along both axes. Let the window length be an integer $w \\geq 1$. The task is to compute two dimensionless measures of nonuniformity from first principles: the integral uniformity over the UFOV and the differential uniformity over the UFOV using sliding-window extremal calculations. Then, interpret the significance of these measures for Single Photon Emission Computed Tomography (SPECT).\n\nStarting from the formal definitions that a uniformity metric must be dimensionless, bounded, and constructed from extrema of measured counts to quantify the largest fractional deviation, design and implement an algorithm that:\n\n- Extracts the UFOV by cropping the original image to remove $m$ pixels from each border, producing the subarray $I_{\\mathrm{UFOV}}(i,j)$.\n- Computes the integral uniformity as the worst-case fractional nonuniformity using only the global minimum and maximum within the UFOV.\n- Computes the differential uniformity as the worst-case fractional nonuniformity observed over all contiguous segments of length $w$ in both the horizontal and vertical directions within the UFOV, where each segment's measure is constructed from the minimum and maximum counts within that segment, and the overall result is the maximum value across all such segments.\n\nAll outputs must be expressed as decimal fractions (for example, $0.0175$), rounded to six decimal places. No percentage signs are permitted.\n\nConstruct the following deterministic test suite. For each test case, you are given integers $N$ and $M$ defining the image dimensions $N \\times N$, the margin $m$, and the window length $w$. The image entries are defined by explicit formulas below to ensure reproducible values. In each case, the UFOV is obtained by cropping $m$ pixels from all sides of the image.\n\n- Test Case $1$ (boundary condition: perfectly uniform field): $N=10$, $m=1$, $w=5$, and $I(i,j) = 1000$ for all $0 \\leq i,j < 10$.\n- Test Case $2$ (near-uniform with smooth spatial variation): $N=16$, $m=2$, $w=5$, and\n$$\nI(i,j) = 1000 + 20\\sin\\!\\left(\\frac{2\\pi i}{16}\\right) + 15\\cos\\!\\left(\\frac{2\\pi j}{16}\\right)\n$$\nfor all $0 \\leq i,j < 16$.\n- Test Case $3$ (single hot pixel within UFOV): $N=12$, $m=1$, $w=5$, and\n$$\nI(i,j) =\n\\begin{cases}\n1100, & \\text{if } i=6 \\text{ and } j=6,\\\\\n800, & \\text{otherwise},\n\\end{cases}\n$$\nfor all $0 \\leq i,j < 12$.\n- Test Case $4$ (UFOV exactly equals window size, directional ramp): $N=7$, $m=1$, $w=5$, and\n$$\nI(i,j) = 1000 + 10j\n$$\nfor all $0 \\leq i,j < 7$.\n\nFor each test case, compute two floats: the integral uniformity over the UFOV and the differential uniformity over the UFOV, both as decimal fractions rounded to six decimal places.\n\nYour program should produce a single line of output containing the results as a comma-separated list of pairs for the four test cases, enclosed in square brackets. Specifically, the output format must be\n$$\n\\text{[ [iu\\_1,du\\_1],[iu\\_2,du\\_2],[iu\\_3,du\\_3],[iu\\_4,du\\_4] ]}\n$$\nwhere $iu_k$ and $du_k$ are the integral and differential uniformities for test case $k$, respectively, each rounded to six decimal places and expressed as decimal fractions without any percentage sign.", "solution": "The problem is valid as it is scientifically grounded, well-posed, and objective. It addresses a standard quality control procedure in medical imaging—specifically, the assessment of gamma camera uniformity—using established definitions and a deterministic setup.\n\n**Significance in SPECT**\n\nIn Single Photon Emission Computed Tomography (SPECT), the gamma camera system must exhibit a highly uniform response to a uniform flux of gamma rays. Any nonuniformity in the detector's sensitivity can introduce significant artifacts into the reconstructed tomographic images, such as concentric rings or \"bull's-eye\" patterns. These artifacts can obscure or mimic pathological features, thereby compromising the diagnostic accuracy of the study. The two metrics, integral and differential uniformity, provide a quantitative measure of detector performance, ensuring it meets clinical standards. Integral uniformity assesses large-scale, slowly varying performance, while differential uniformity is sensitive to abrupt, local changes, often indicative of specific component failures (e.g., a malfunctioning photomultiplier tube).\n\n**Mathematical Formulation and Algorithmic Design**\n\nThe problem requires a precise implementation of the definitions for the Useful Field of View (UFOV), integral uniformity, and differential uniformity.\n\n**1. Useful Field of View (UFOV)**\n\nThe raw image is given as an $N \\times N$ matrix of counts, $I$. The UFOV is the central sub-array, $I_{\\mathrm{UFOV}}$, obtained by excluding a margin of $m$ pixels from all four sides. If the indices of $I$ are $(i,j)$ for $0 \\leq i, j < N$, then the indices of $I_{\\mathrm{UFOV}}$ correspond to the range $m \\leq i, j \\leq N-1-m$. The resulting UFOV is an $(N-2m) \\times (N-2m)$ matrix.\n\n**2. Integral Uniformity (IU)**\n\nIntegral uniformity quantifies the global, worst-case deviation of counts across the entire UFOV. It is a dimensionless metric constructed from the global maximum ($I_{\\max}$) and minimum ($I_{\\min}$) counts within the UFOV. The standard formula, which satisfies the problem's formal requirements, is:\n\n$$\nIU = \\frac{I_{\\max} - I_{\\min}}{I_{\\max} + I_{\\min}}\n\\quad \\text{where} \\quad\nI_{\\max} = \\max(I_{\\mathrm{UFOV}}) \\text{ and } I_{\\min} = \\min(I_{\\mathrm{UFOV}})\n$$\n\nIf all counts are zero, the denominator is zero, and the uniformity is defined as $0$. Since the counts are non-negative, this is the only case for a zero denominator.\n\n**3. Differential Uniformity (DU)**\n\nDifferential uniformity measures the worst-case local count variations. It is determined by calculating the uniformity over all contiguous linear segments of a specified length $w$ and taking the maximum of these values. The scan is performed over all rows and all columns of the UFOV.\n\nLet $S$ be any such segment of length $w$ from a row or column of $I_{\\mathrm{UFOV}}$. The uniformity for this segment, $U_S$, is calculated similarly to the integral uniformity:\n\n$$\nU_S = \\frac{\\max(S) - \\min(S)}{\\max(S) + \\min(S)}\n$$\n\nThe differential uniformity, $DU$, is the maximum value of $U_S$ found across all possible horizontal and vertical segments within the UFOV:\n\n$$\nDU = \\max_{S \\in \\{\\text{all segments}\\}} U_S\n$$\n\nThe algorithm proceeds as follows:\n1.  Generate the $N \\times N$ image matrix $I$ based on the specified formula for the given test case.\n2.  Extract the submatrix $I_{\\mathrm{UFOV}}$ by slicing the original matrix $I$. This corresponds to `I[m:N-m, m:N-m]`.\n3.  Calculate $IU$ by finding the global maximum and minimum of $I_{\\mathrm{UFOV}}$ and applying the formula.\n4.  To calculate $DU$:\n    a. Initialize a variable `max_local_uniformity` to $0$.\n    b. Iterate through each row of $I_{\\mathrm{UFOV}}$. For each row, use a sliding window of size $w$ to extract all horizontal segments. For each segment, calculate its uniformity $U_S$ and update `max_local_uniformity = max(max_local_uniformity, U_S)`.\n    c. Iterate through each column of $I_{\\mathrm{UFOV}}$. For each column, use a sliding window of size $w$ to extract all vertical segments. For each segment, calculate its uniformity $U_S$ and update `max_local_uniformity` accordingly.\n5.  The final value of `max_local_uniformity` is the differential uniformity $DU$.\n6.  The results, $IU$ and $DU$, are rounded to six decimal places. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the gamma camera uniformity problem for all test cases.\n    \"\"\"\n\n    def calculate_uniformity_metrics(I, m, w):\n        \"\"\"\n        Calculates integral and differential uniformity for a given image array.\n\n        Args:\n            I (np.ndarray): The N x N image of counts.\n            m (int): The margin in pixels to exclude for the UFOV.\n            w (int): The window length for differential uniformity.\n\n        Returns:\n            tuple: A tuple containing (integral_uniformity, differential_uniformity).\n        \"\"\"\n        N = I.shape[0]\n        ufov_dim = N - 2 * m\n        \n        # If the UFOV has a non-positive dimension, uniformity is undefined or trivial (0).\n        if ufov_dim <= 0:\n            return 0.0, 0.0\n        \n        # 1. Extract the Useful Field of View (UFOV)\n        I_ufov = I[m : N - m, m : N - m]\n        \n        # 2. Compute Integral Uniformity (IU)\n        max_ufov = np.max(I_ufov)\n        min_ufov = np.min(I_ufov)\n        \n        denominator_iu = max_ufov + min_ufov\n        integral_uniformity = (max_ufov - min_ufov) / denominator_iu if denominator_iu > 0 else 0.0\n\n        # 3. Compute Differential Uniformity (DU)\n        max_local_uniformity = 0.0\n        \n        # The window length must not exceed the UFOV dimension.\n        if ufov_dim >= w:\n            # Horizontal sliding windows\n            for i in range(ufov_dim):\n                for j in range(ufov_dim - w + 1):\n                    segment = I_ufov[i, j : j + w]\n                    max_seg, min_seg = np.max(segment), np.min(segment)\n                    denominator_du = max_seg + min_seg\n                    if denominator_du > 0:\n                        local_uniformity = (max_seg - min_seg) / denominator_du\n                        if local_uniformity > max_local_uniformity:\n                            max_local_uniformity = local_uniformity\n\n            # Vertical sliding windows\n            for j in range(ufov_dim):\n                for i in range(ufov_dim - w + 1):\n                    segment = I_ufov[i : i + w, j]\n                    max_seg, min_seg = np.max(segment), np.min(segment)\n                    denominator_du = max_seg + min_seg\n                    if denominator_du > 0:\n                        local_uniformity = (max_seg - min_seg) / denominator_du\n                        if local_uniformity > max_local_uniformity:\n                            max_local_uniformity = local_uniformity\n        \n        differential_uniformity = max_local_uniformity\n        \n        return integral_uniformity, differential_uniformity\n\n    # Define test cases\n    test_cases_defs = [\n        {'N': 10, 'm': 1, 'w': 5},\n        {'N': 16, 'm': 2, 'w': 5},\n        {'N': 12, 'm': 1, 'w': 5},\n        {'N': 7, 'm': 1, 'w': 5}\n    ]\n\n    results = []\n    \n    # Test Case 1\n    case = test_cases_defs[0]\n    N = case['N']\n    image1 = np.full((N, N), 1000.0)\n    iu, du = calculate_uniformity_metrics(image1, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 2\n    case = test_cases_defs[1]\n    N = case['N']\n    i_indices = np.arange(N).reshape(N, 1)\n    j_indices = np.arange(N).reshape(1, N)\n    image2 = 1000 + 20 * np.sin(2 * np.pi * i_indices / N) + 15 * np.cos(2 * np.pi * j_indices / N)\n    iu, du = calculate_uniformity_metrics(image2, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 3\n    case = test_cases_defs[2]\n    N = case['N']\n    image3 = np.full((N, N), 800.0)\n    image3[6, 6] = 1100.0\n    iu, du = calculate_uniformity_metrics(image3, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Test Case 4\n    case = test_cases_defs[3]\n    N = case['N']\n    j_indices = np.arange(N).reshape(1, N)\n    image4 = 1000.0 + 10.0 * j_indices\n    # Broadcast to create a full N x N image where each row is identical.\n    image4 = np.broadcast_to(image4, (N, N))\n    iu, du = calculate_uniformity_metrics(image4, case['m'], case['w'])\n    results.append([round(iu, 6), round(du, 6)])\n\n    # Final print statement in the exact required format.\n    # The standard string representation of a list of lists in Python matches the output format.\n    print(str(results))\n\nsolve()\n```", "id": "4888122"}]}