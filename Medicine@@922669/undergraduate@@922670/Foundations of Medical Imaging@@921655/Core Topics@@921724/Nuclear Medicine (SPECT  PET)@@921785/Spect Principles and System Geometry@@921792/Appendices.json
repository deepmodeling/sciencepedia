{"hands_on_practices": [{"introduction": "Understanding SPECT begins with the fundamental question of signal generation: for a given amount of radioactivity, what is the expected rate of photons detected? This exercise guides you through a first-principles derivation of the SPECT count rate equation [@problem_id:4927588]. By breaking down the process into sequential stages—from nuclear decay to geometric acceptance and final detection—you will construct the core formula that links source activity to the measured signal.", "problem": "A Single-Photon Emission Computed Tomography (SPECT) system consists of a parallel-hole collimator and a scintillation detector that record incident gamma photons from a radiotracer source. Consider a point source located in air at a fixed position relative to the detector, with time-varying activity $A(t)$, defined as the expected number of nuclear decays per unit time. Assume isotropic photon emission, negligible attenuation and scatter between source and detector, and no system dead time or pileup effects. Let $p_{\\gamma}$ denote the probability that a nuclear decay emits a photon in the photopeak of interest (one photon per decay occurs with probability $p_{\\gamma}$), and let the collimator-detector system accept photons within a defined solid angle $\\Omega$ about the detector axis. Define the geometric efficiency $\\eta_{g}$ as the fraction of the isotropically emitted photons that enter the acceptance solid angle and traverse the collimation geometry to reach the active detector area, and define the intrinsic detection efficiency $\\eta_{d}$ as the probability that an accepted photon interacting in the detector produces a count in the photopeak.\n\nStarting from first principles and the definitions above, derive the expected count rate $R(t)$ recorded by the detector as a function of $A(t)$, $p_{\\gamma}$, $\\eta_{g}$, and $\\eta_{d}$. Express your final answer as a single closed-form analytic expression. If you choose to relate $\\eta_{g}$ to the solid angle acceptance, you may assume $\\eta_{g} = \\Omega/(4\\pi)$ for an ideal collimator that admits all photons within $\\Omega$ and rejects all others, but your final expression must be written in terms of $A(t)$, $p_{\\gamma}$, $\\eta_{g}$, and $\\eta_{d}$ only. Do not provide any numerical evaluation.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the principles of nuclear medicine imaging, well-posed with clearly defined terms and a single derivable outcome, and objective in its language. The assumptions provided, such as negligible attenuation and no dead time, are standard idealizations for a first-principles derivation. All necessary variables are provided, and no contradictions are present.\n\nThe objective is to derive the expected count rate, $R(t)$, recorded by the SPECT detector from a point source with time-varying activity $A(t)$. The derivation proceeds by systematically accounting for the sequential probabilistic and geometric factors that reduce the number of initial nuclear decays to the final number of detected counts.\n\n1.  **Source Activity**: The process begins with the radioactive source itself. The activity, $A(t)$, is defined as the expected number of nuclear decays per unit time.\n    $$\n    \\text{Rate of decays} = A(t)\n    $$\n\n2.  **Photon Emission**: Not every nuclear decay results in a photon of the specific energy required for imaging (i.e., a photon in the photopeak). The problem provides the probability, $p_{\\gamma}$, that a single decay will emit such a photon. Assuming each decay is an independent event, the expected rate of emission of photopeak photons is the product of the decay rate and this probability.\n    $$\n    \\text{Rate of photopeak photon emission} = A(t) p_{\\gamma}\n    $$\n\n3.  **Geometric Acceptance**: The source emits photons isotropically, meaning uniformly in all directions over a total solid angle of $4\\pi$ steradians. The collimator-detector system can only \"see\" or accept photons that are emitted within a specific solid angle and trajectory. The geometric efficiency, $\\eta_{g}$, is defined as the fraction of all isotropically emitted photons that successfully pass through the collimator and are incident upon the active area of the detector. Therefore, to find the rate of photons arriving at the detector, we multiply the total emission rate of photopeak photons by this geometric fraction.\n    $$\n    \\text{Rate of photons incident on detector} = (A(t) p_{\\gamma}) \\eta_{g}\n    $$\n    This step effectively filters the emitted photons based on their direction of travel. As noted in the problem, for an idealized system accepting photons within a solid angle $\\Omega$, this efficiency would be $\\eta_{g} = \\frac{\\Omega}{4\\pi}$. However, the final expression is to be in terms of $\\eta_g$.\n\n4.  **Intrinsic Detection**: A photon that is incident on the detector is not guaranteed to be counted. It must interact with the scintillation crystal, and the resulting signal must fall within the pre-set energy window corresponding to the photopeak. The intrinsic detection efficiency, $\\eta_{d}$, is the probability that an incident photon that has passed through the collimator will be successfully detected and registered as a count. The final expected count rate, $R(t)$, is obtained by multiplying the rate of incident photons by this detection probability.\n    $$\n    \\text{Expected count rate} = R(t) = (A(t) p_{\\gamma} \\eta_{g}) \\eta_{d}\n    $$\n\nCombining these steps, we arrive at the final expression for the expected count rate. Each term represents a successive filter on the initial decay rate: $A(t)$ is the initial rate of events; $p_{\\gamma}$ filters for the correct event type (photon emission); $\\eta_{g}$ filters for the correct geometry (direction); and $\\eta_{d}$ filters for successful detection. The assumption of no dead time or pileup is crucial, as it ensures that the response of the system is linear and that the probabilities can be multiplied directly without considering detector saturation effects.\n\nThe final closed-form analytic expression for the expected count rate $R(t)$ as a function of the given parameters is the product of all contributing factors.", "answer": "$$\n\\boxed{R(t) = A(t) p_{\\gamma} \\eta_{g} \\eta_{d}}\n$$", "id": "4927588"}, {"introduction": "The parallel-hole collimator is the heart of SPECT system geometry, defining both spatial resolution and sensitivity. This hands-on problem explores a key aspect of collimator design: the efficiency of how holes are arranged on the detector face [@problem_id:4927633]. By applying basic planar geometry, you will quantify the performance gain achieved by using hexagonal packing over square packing, providing a concrete example of the engineering trade-offs that govern imaging performance.", "problem": "A Single Photon Emission Computed Tomography (SPECT) parallel-hole collimator with circular holes of diameter $d$ and length $L$ is fabricated in two otherwise identical variants. In Variant A, the hole centers lie on a square lattice; in Variant B, the hole centers lie on a triangular (hexagonal) lattice. In both variants, the center-to-center pitch $p$ between adjacent holes is the same, and the septal material and thickness are uniform, so that geometric comparisons are valid. Assume the collimator face is sufficiently large that edge effects are negligible and the arrangement is perfectly periodic.\n\nStart from the following base:\n- The open area fraction $\\phi$ is defined as the ratio of the total open area to the total face area. For a periodic array with one hole per primitive cell, $\\phi$ equals the ratio of the hole area to the primitive cell area.\n- The geometric sensitivity $S$ of a parallel-hole collimator for photons incident near-normal to the face scales linearly with the open area fraction $\\phi$ and with an angular acceptance factor that depends only on $d$ and $L$. Under fixed $d$ and $L$, this angular acceptance factor is identical for both lattices.\n\nUsing only these definitions and elementary planar geometry, derive the primitive cell area for each lattice and then the corresponding open area fractions $\\phi_{\\mathrm{sq}}$ and $\\phi_{\\mathrm{hex}}$. Finally, deduce the sensitivity gain factor\n$$G \\equiv \\frac{S_{\\mathrm{hex}}}{S_{\\mathrm{sq}}},$$\nfor fixed $d$ and $L$ with identical pitch $p$.\n\nExpress the final answer for $G$ as a single exact analytic expression. No rounding is required, and no units should be included in the final answer.", "solution": "The open area fraction $\\phi$ for a periodic array with one hole per primitive cell is\n$$\\phi = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell}}},$$\nwhere $A_{\\mathrm{hole}}$ is the area of one hole and $A_{\\mathrm{cell}}$ is the area of the primitive unit cell associated with one lattice point (one hole). For circular holes of diameter $d$, the hole area is\n$$A_{\\mathrm{hole}} = \\pi \\left(\\frac{d}{2}\\right)^{2} = \\frac{\\pi d^{2}}{4}.$$\n\nWe now determine $A_{\\mathrm{cell}}$ for each lattice.\n\nSquare lattice:\nThe primitive cell is a square of side $p$, so\n$$A_{\\mathrm{cell,\\,sq}} = p^{2}.$$\nTherefore, the open area fraction for the square lattice is\n$$\\phi_{\\mathrm{sq}} = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell,\\,sq}}} = \\frac{\\pi d^{2}/4}{p^{2}} = \\frac{\\pi d^{2}}{4 p^{2}}.$$\n\nTriangular (hexagonal) lattice:\nThe hole centers form a triangular lattice generated by two vectors of length $p$ with an internal angle of $60^{\\circ}$. The area of the primitive cell (a parallelogram spanned by these two vectors) is the magnitude of the cross product of the lattice basis vectors,\n$$A_{\\mathrm{cell,\\,hex}} = p \\cdot p \\cdot \\sin\\!\\left(60^{\\circ}\\right) = p^{2} \\cdot \\frac{\\sqrt{3}}{2} = \\frac{\\sqrt{3}}{2}\\,p^{2}.$$\nTherefore, the open area fraction for the hexagonal packing is\n$$\\phi_{\\mathrm{hex}} = \\frac{A_{\\mathrm{hole}}}{A_{\\mathrm{cell,\\,hex}}} = \\frac{\\pi d^{2}/4}{(\\sqrt{3}/2)\\,p^{2}} = \\frac{\\pi}{2\\sqrt{3}}\\;\\frac{d^{2}}{p^{2}}.$$\n\nPhysical interpretation:\nHexagonal (triangular) packing places hole centers more efficiently, reducing wasted area between holes compared to square packing. This increases the fraction of the face occupied by holes, i.e., the open area fraction.\n\nSensitivity gain for fixed $d$ and $L$:\nThe geometric sensitivity $S$ scales as\n$$S \\propto \\phi \\times f(d,L),$$\nwhere $f(d,L)$ is the angular acceptance factor determined solely by $d$ and $L$. Because $d$ and $L$ are fixed and identical in both variants, $f(d,L)$ is identical and cancels in the ratio. Hence, the sensitivity gain factor is the ratio of open area fractions:\n$$G \\equiv \\frac{S_{\\mathrm{hex}}}{S_{\\mathrm{sq}}} = \\frac{\\phi_{\\mathrm{hex}}}{\\phi_{\\mathrm{sq}}} = \\frac{\\left(\\frac{\\pi}{2\\sqrt{3}}\\frac{d^{2}}{p^{2}}\\right)}{\\left(\\frac{\\pi}{4}\\frac{d^{2}}{p^{2}}\\right)} = \\frac{4}{2\\sqrt{3}} = \\frac{2}{\\sqrt{3}}.$$\n\nThus, hexagonal packing improves the open area fraction and, correspondingly, the sensitivity by a factor of $\\frac{2}{\\sqrt{3}}$ relative to square packing when $d$ and $L$ are fixed and the pitch $p$ is identical.", "answer": "$$\\boxed{\\frac{2}{\\sqrt{3}}}$$", "id": "4927633"}, {"introduction": "Designing a real-world SPECT scan involves more than understanding individual components; it requires synthesizing knowledge to make optimal choices. This final practice challenges you to become a system designer, navigating the fundamental trade-off between image resolution and statistical noise [@problem_id:4927587]. You will develop a computational model to select the best acquisition parameters—from collimator type to rotation settings—to satisfy specific clinical performance targets, simulating the complex decision-making process at the heart of medical imaging.", "problem": "You are to implement a program that formalizes and solves a simplified, first-principles model of the noise–resolution trade-off in Single Photon Emission Computed Tomography (SPECT) as a function of angular sampling, radius of rotation, and detector–collimator properties. The goal is to propose acquisition parameter choices that meet jointly specified resolution and noise targets.\n\nBegin from the following foundational base of widely accepted definitions and physical relationships:\n\n- Geometric resolution of a parallel-hole collimator at source-to-collimator distance $z$ (in $\\mathrm{mm}$) is modeled as a full width at half maximum (FWHM) given by $R_{\\mathrm{coll}}(z) = d \\cdot \\dfrac{L + z}{L}$, where $d$ is the hole diameter (in $\\mathrm{mm}$) and $L$ is the hole length (in $\\mathrm{mm}$).\n- Intrinsic detector resolution (including intrinsic blur and pixel sampling) is modeled by an FWHM $R_{\\mathrm{int}}$ (in $\\mathrm{mm}$).\n- The system-resolution FWHM without angular sampling effects is modeled as the root-sum-of-squares of independent blurs: $R_{\\mathrm{sys,0}}(z) = \\sqrt{R_{\\mathrm{int}}^{2} + R_{\\mathrm{coll}}(z)^{2}}$.\n- Angular sampling introduces an additional effective tangential blur. Using an object-of-interest radius $r$ (in $\\mathrm{mm}$) and $N$ projection angles uniformly covering a full rotation, define the angular step $\\Delta \\theta = \\dfrac{2\\pi}{N}$ (in $\\mathrm{radians}$). Model the angular sampling blur as $R_{\\mathrm{ang}} = r \\, \\Delta \\theta$ (in $\\mathrm{mm}$).\n- Combine independent blurs in quadrature to obtain the effective FWHM: $R_{\\mathrm{eff}} = \\sqrt{R_{\\mathrm{sys,0}}(z)^{2} + R_{\\mathrm{ang}}^{2}}$.\n- Collimator sensitivity is modeled up to a proportionality constant by the product of geometric fill factor and open-area scaling: $S_{\\mathrm{rel}} = \\left(\\dfrac{d}{d + t}\\right)^{2} \\cdot \\dfrac{d^{2}}{L^{2}}$, where $t$ is the septal thickness (in $\\mathrm{mm}$). This is a relative sensitivity in dimensionless units.\n- Total detected counts for a scan of duration $T$ (in $\\mathrm{s}$) with administered activity $A$ (in $\\mathrm{MBq}$) are modeled as $C = k \\, A \\, T \\, S_{\\mathrm{rel}}$, where $k$ is a fixed proportionality constant with units $\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$ set below. The noise metric is taken as the coefficient of variation for a uniform region, $\\eta = \\dfrac{1}{\\sqrt{C}}$ (dimensionless, to be reported as a decimal, not with a percentage sign).\n\nGeometry and distance convention:\n\n- Use radius of rotation (ROR) as the distance from the system’s rotation center to the collimator face. Evaluate $z$ at the mean distance $z = \\mathrm{ROR}$ for the resolution calculation, which is a standard approximation for a point undergoing full angular sampling around the rotation center.\n\nYour program must, for each test case, choose parameters from discrete allowed sets so as to satisfy both an effective resolution target and a noise limit:\n\n- Choose the number of projections $N$ from the allowed set $\\{60, 90, 120, 180\\}$.\n- Choose the radius of rotation $\\mathrm{ROR}$ from the allowed set $\\{140\\,\\mathrm{mm}, 180\\,\\mathrm{mm}\\}$.\n- Choose one of three collimators characterized by $(d, L, t)$ in $\\mathrm{mm}$:\n  1. Low-Energy High-Resolution (LEHR): $(d, L, t) = (1.5, 35, 0.2)$.\n  2. Low-Energy General-Purpose (LEGP): $(d, L, t) = (1.9, 25, 0.2)$.\n  3. High-Sensitivity (HS): $(d, L, t) = (2.4, 20, 0.2)$.\n\nUse the fixed counts proportionality constant $k = 100\\,\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$. Use angles in $\\mathrm{radians}$ for all angular computations.\n\nFeasibility criteria for a candidate triplet $(N, \\mathrm{ROR}, \\text{collimator})$ with given test-case parameters $(A, T, R_{\\mathrm{int}}, r, R_{\\mathrm{target}}, \\eta_{\\max})$:\n\n- Compute $S_{\\mathrm{rel}}$ for the chosen collimator.\n- Compute $C = k \\, A \\, T \\, S_{\\mathrm{rel}}$ and $\\eta = \\dfrac{1}{\\sqrt{C}}$.\n- Compute $R_{\\mathrm{coll}}(\\mathrm{ROR})$, then $R_{\\mathrm{sys,0}}(\\mathrm{ROR})$, then $R_{\\mathrm{ang}}$ using $\\Delta \\theta = \\dfrac{2\\pi}{N}$, and finally $R_{\\mathrm{eff}}$.\n- The candidate is feasible if $R_{\\mathrm{eff}} \\le R_{\\mathrm{target}}$ and $\\eta \\le \\eta_{\\max}$.\n\nSelection rule among feasible candidates for each test case:\n\n- Primary: minimize $\\eta$.\n- Secondary (tie-breaker if $\\eta$ values are equal to within $10^{-12}$): choose the largest $\\mathrm{ROR}$.\n- Tertiary (if still tied): choose the smallest $N$.\n- If no candidate is feasible, the test case is declared infeasible.\n\nUnits and reporting:\n\n- Distances must be in $\\mathrm{mm}$, times in $\\mathrm{s}$, activities in $\\mathrm{MBq}$, and angles in $\\mathrm{radians}$.\n- Your program must compute using the above units and model.\n- For each test case, your program must output either:\n  - Four numbers in the order $(N, \\mathrm{ROR}, d, L)$ if a feasible candidate exists, or\n  - The single integer $-1$ if infeasible.\n- Aggregate all test-case outputs into a single flat list, in test-case order, in one line as a comma-separated list enclosed in square brackets. For example, if there are five test cases and the first yields a feasible quadruple while the second is infeasible, the output begins with something like $[N_{1}, \\mathrm{ROR}_{1}, d_{1}, L_{1}, -1, \\dots]$.\n- Numerical values in the output must be raw numbers without units.\n\nTest suite:\n\nFor all test cases below, use the candidate sets and constant $k$ exactly as stated above.\n\n- Test case $1$ (happy path, resolution-limited):\n  - $A = 150\\,\\mathrm{MBq}$, $T = 600\\,\\mathrm{s}$, $R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$, $r = 100\\,\\mathrm{mm}$,\n  - $R_{\\mathrm{target}} = 10.0\\,\\mathrm{mm}$, $\\eta_{\\max} = 0.02$.\n- Test case $2$ (noise-limited at low activity):\n  - $A = 20\\,\\mathrm{MBq}$, $T = 600\\,\\mathrm{s}$, $R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$, $r = 100\\,\\mathrm{mm}$,\n  - $R_{\\mathrm{target}} = 20.0\\,\\mathrm{mm}$, $\\eta_{\\max} = 0.01$.\n- Test case $3$ (angular-sampling-limited at larger radius):\n  - $A = 80\\,\\mathrm{MBq}$, $T = 300\\,\\mathrm{s}$, $R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$, $r = 150\\,\\mathrm{mm}$,\n  - $R_{\\mathrm{target}} = 12.0\\,\\mathrm{mm}$, $\\eta_{\\max} = 0.02$.\n- Test case $4$ (trade-off favors higher sensitivity while still meeting resolution):\n  - $A = 100\\,\\mathrm{MBq}$, $T = 200\\,\\mathrm{s}$, $R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$, $r = 50\\,\\mathrm{mm}$,\n  - $R_{\\mathrm{target}} = 17.0\\,\\mathrm{mm}$, $\\eta_{\\max} = 0.015$.\n- Test case $5$ (infeasible target resolution):\n  - $A = 500\\,\\mathrm{MBq}$, $T = 600\\,\\mathrm{s}$, $R_{\\mathrm{int}} = 3.5\\,\\mathrm{mm}$, $r = 100\\,\\mathrm{mm}$,\n  - $R_{\\mathrm{target}} = 8.0\\,\\mathrm{mm}$, $\\eta_{\\max} = 0.02$.\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, concatenating each test case’s result in order. For example: $[N_{1}, \\mathrm{ROR}_{1}, d_{1}, L_{1}, N_{2}, \\mathrm{ROR}_{2}, d_{2}, L_{2}, \\dots]$ with any infeasible test contributing a single $-1$ in place of four numbers.", "solution": "The problem is valid. It presents a scientifically grounded, well-posed, and objective task based on established principles of Single Photon Emission Computed Tomography (SPECT). The physical models provided for resolution and sensitivity are standard, albeit simplified, representations used in medical imaging physics. All parameters, constraints, choice sets, and selection criteria are defined unambiguously, ensuring a unique and computable solution exists for each test case.\n\nThe problem requires a constrained optimization over a discrete parameter space to design a SPECT acquisition protocol. The goal is to find a set of acquisition parameters—number of projection angles ($N$), radius of rotation ($\\mathrm{ROR}$), and collimator type—that satisfies specified targets for effective resolution ($R_{\\mathrm{eff}} \\le R_{\\mathrm{target}}$) and statistical noise ($\\eta \\le \\eta_{\\max}$).\n\nThe core scientific principle is the inherent trade-off between system resolution and sensitivity in SPECT. Collimators with higher geometric resolution (e.g., smaller holes, longer bores, like the LEHR) have lower sensitivity, leading to fewer detected photons ($C$) and thus higher statistical noise ($\\eta = 1/\\sqrt{C}$). Conversely, high-sensitivity collimators (e.g., HS) provide lower noise at the cost of poorer spatial resolution. The task is to navigate this trade-off, along with other geometric factors, to find an optimal feasible protocol.\n\nThe algorithmic solution proceeds by systematically evaluating every possible combination of parameters for each test case. The parameter space for each acquisition protocol is the Cartesian product of the allowed sets for $N$, $\\mathrm{ROR}$, and collimator type, resulting in $4 \\times 2 \\times 3 = 24$ candidate protocols to evaluate per test case.\n\nFor each candidate protocol, characterized by a triplet $(N, \\mathrm{ROR}, \\text{collimator})$, and the test case's given conditions ($A, T, R_{\\mathrm{int}}, r, R_{\\mathrm{target}}, \\eta_{\\max}$), the following steps are performed:\n\n1.  **Calculate Noise**: The noise metric $\\eta$ depends on the total detected counts $C$, which is proportional to the collimator's relative sensitivity $S_{\\mathrm{rel}}$. The constant $k = 100\\,\\mathrm{counts \\cdot s^{-1} \\cdot MBq^{-1}}$ is used.\n    $$S_{\\mathrm{rel}} = \\left(\\frac{d}{d + t}\\right)^{2} \\cdot \\frac{d^{2}}{L^{2}}$$\n    $$C = k \\, A \\, T \\, S_{\\mathrm{rel}}$$\n    $$\\eta = \\frac{1}{\\sqrt{C}}$$\n    Here, ($d, L, t$) are the parameters of the chosen collimator. For a given test case (fixed $A, T$), $\\eta$ is determined solely by the choice of collimator.\n\n2.  **Calculate Effective Resolution**: The effective resolution $R_{\\mathrm{eff}}$ is calculated by combining multiple independent blur components in quadrature.\n    - The collimator's geometric resolution $R_{\\mathrm{coll}}$ is evaluated at a distance $z = \\mathrm{ROR}$.\n      $$R_{\\mathrm{coll}}(\\mathrm{ROR}) = d \\cdot \\frac{L + \\mathrm{ROR}}{L}$$\n    - This is combined with the detector's intrinsic resolution $R_{\\mathrm{int}}$.\n      $$R_{\\mathrm{sys,0}}(\\mathrm{ROR}) = \\sqrt{R_{\\mathrm{int}}^{2} + R_{\\mathrm{coll}}(\\mathrm{ROR})^{2}}$$\n    - The blur from angular sampling, $R_{\\mathrm{ang}}$, is calculated based on the number of projections $N$ and the object radius $r$.\n      $$\\Delta \\theta = \\frac{2\\pi}{N}$$\n      $$R_{\\mathrm{ang}} = r \\, \\Delta \\theta$$\n    - The final effective resolution $R_{\\mathrm{eff}}$ combines these components.\n      $$R_{\\mathrm{eff}} = \\sqrt{R_{\\mathrm{sys,0}}(\\mathrm{ROR})^{2} + R_{\\mathrm{ang}}^{2}}$$\n\n3.  **Feasibility Check**: A candidate protocol is deemed feasible if it meets both performance targets:\n    $$R_{\\mathrm{eff}} \\le R_{\\mathrm{target}} \\quad \\text{and} \\quad \\eta \\le \\eta_{\\max}$$\n\n4.  **Optimal Selection**: After identifying all feasible candidates for a test case, the single best protocol is selected based on the specified hierarchical criteria:\n    - **Primary**: Minimize the noise metric $\\eta$.\n    - **Secondary**: For candidates with $\\eta$ values tied (or equal within a tolerance of $10^{-12}$, though here the $\\eta$ values are distinct for each collimator type), choose the one with the largest $\\mathrm{ROR}$.\n    - **Tertiary**: If a tie persists, choose the candidate with the smallest $N$.\n\n    If the set of feasible candidates is empty, the test case is declared infeasible, and the output is the integer $-1$. Otherwise, the output is the quadruplet $(N, \\mathrm{ROR}, d, L)$ for the selected optimal protocol. This entire process is repeated for each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Formalizes and solves a simplified model of the noise-resolution trade-off\n    in SPECT to select optimal acquisition parameters.\n    \"\"\"\n    \n    # Global constants and parameter choices as per the problem statement\n    K_CONST = 100.0  # counts * s^-1 * MBq^-1\n    N_CHOICES = [60, 90, 120, 180]\n    ROR_CHOICES = [140.0, 180.0]  # in mm\n    \n    COLLIMATORS = {\n        'LEHR': {'d': 1.5, 'L': 35.0, 't': 0.2},  # Low-Energy High-Resolution\n        'LEGP': {'d': 1.9, 'L': 25.0, 't': 0.2},  # Low-Energy General-Purpose\n        'HS':   {'d': 2.4, 'L': 20.0, 't': 0.2}   # High-Sensitivity\n    }\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'A': 150, 'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 10.0, 'eta_max': 0.02},\n        {'A': 20,  'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 20.0, 'eta_max': 0.01},\n        {'A': 80,  'T': 300, 'R_int': 3.5, 'r': 150, 'R_target': 12.0, 'eta_max': 0.02},\n        {'A': 100, 'T': 200, 'R_int': 3.5, 'r': 50,  'R_target': 17.0, 'eta_max': 0.015},\n        {'A': 500, 'T': 600, 'R_int': 3.5, 'r': 100, 'R_target': 8.0,  'eta_max': 0.02},\n    ]\n\n    # Pre-calculate relative sensitivity for each collimator\n    s_rels = {}\n    for name, params in COLLIMATORS.items():\n        d, L, t = params['d'], params['L'], params['t']\n        s_rels[name] = (d / (d + t))**2 * (d**2 / L**2)\n\n    final_results = []\n    \n    for case in test_cases:\n        A, T, R_int, r, R_target, eta_max = case.values()\n        \n        # Calculate noise metric eta for each collimator type for the current test case.\n        # Eta depends on A and T, so it is specific to the test case.\n        etas = {}\n        for name, s_rel in s_rels.items():\n            C = K_CONST * A * T * s_rel\n            if C > 0:\n                etas[name] = 1.0 / np.sqrt(C)\n            else:\n                etas[name] = float('inf')\n\n        feasible_candidates = []\n\n        # Iterate through all possible parameter combinations\n        for N in N_CHOICES:\n            for ROR in ROR_CHOICES:\n                for coll_name, coll_params in COLLIMATORS.items():\n                    \n                    # 1. Calculate and check noise\n                    eta = etas[coll_name]\n                    if eta > eta_max:\n                        continue  # This choice is too noisy\n\n                    # 2. Calculate effective resolution\n                    d, L = coll_params['d'], coll_params['L']\n                    \n                    R_coll = d * (L + ROR) / L\n                    R_sys0 = np.sqrt(R_int**2 + R_coll**2)\n                    \n                    delta_theta = 2 * np.pi / N\n                    R_ang = r * delta_theta\n                    \n                    R_eff = np.sqrt(R_sys0**2 + R_ang**2)\n                    \n                    # 3. Check resolution constraint\n                    if R_eff = R_target:\n                        # Candidate is feasible, store its parameters and metrics\n                        candidate_data = {\n                            'N': N, 'ROR': ROR, 'd': d, 'L': L, 'eta': eta\n                        }\n                        feasible_candidates.append(candidate_data)\n        \n        # 4. Select the best candidate or declare infeasible\n        if not feasible_candidates:\n            final_results.append(-1)\n        else:\n            # Sort the feasible candidates based on the hierarchical criteria:\n            # 1. Minimize eta (ascending)\n            # 2. Maximize ROR (descending, hence the negative sign)\n            # 3. Minimize N (ascending)\n            feasible_candidates.sort(key=lambda c: (c['eta'], -c['ROR'], c['N']))\n            \n            best_candidate = feasible_candidates[0]\n            final_results.extend([\n                best_candidate['N'], \n                best_candidate['ROR'], \n                best_candidate['d'], \n                best_candidate['L']\n            ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "4927587"}]}