{"hands_on_practices": [{"introduction": "To truly understand an artifact, we must derive its properties from the underlying reconstruction mathematics. This exercise guides you through a first-principles derivation in a simplified parallel-beam geometry, revealing the direct relationship between a biased detector's position and the radius of the ring it creates. By working through the filtered backprojection formula, you will see how a simple error in the data domain transforms into a distinct circular pattern in the final image [@problem_id:4533126].", "problem": "Consider two-dimensional Computed Tomography (CT) under ideal parallel-beam geometry with center of rotation at the origin and a dense, uniformly sampled set of views over angles $\\theta \\in [0,\\pi)$. Let $f(x,y)$ denote the object being imaged, and let $p(\\theta,s)$ denote its Radon transform, where $s$ is the signed distance of the line of integration from the origin and $\\theta$ is the orientation of the line’s normal. In filtered backprojection reconstruction, the estimate $\\hat{f}(x,y)$ is formed by convolving each projection $p(\\theta,\\cdot)$ along $s$ with a filter $h(s)$ whose Fourier transform with respect to $s$ equals $|\\omega|$, and then backprojecting the filtered projections over $\\theta$. Assume ideal continuous sampling and exact ramp filtering.\n\nNow consider a common acquisition artifact: one detector element located at fixed coordinate $s_0$ has a constant additive bias $\\delta$ across all angles $\\theta$. Model this biased detector element as an infinitesimally narrow bin at $s=s_0$ that adds the term $\\delta$ to the measured projection $p(\\theta,s)$ for all $\\theta$ and only at that $s$. Thus, the measured sinogram is $p_{\\mathrm{m}}(\\theta,s)=p(\\theta,s) + \\delta\\,b(s)$, where $b(s)$ is a function supported at $s=s_0$ capturing the single-bin contribution, and may be idealized in the limit as a Dirac delta distribution at $s_0$.\n\nUsing the definitions above and starting from the inverse Radon transform via filtered backprojection, derive the radius $r^{\\ast}$ (measured from the origin and expressed in the same physical units as $s$) at which the artifact manifests as a ring in the reconstructed image $\\hat{f}(x,y)$. Your derivation should begin from the formal filtered backprojection expression and proceed by analyzing the contribution of the biased detector element to $\\hat{f}(x,y)$, using $x=r\\cos\\varphi$ and $y=r\\sin\\varphi$ to expose radial dependence. Identify $r^{\\ast}$ as the centerline radius of the ring artifact, defined as the value of $r$ at which the artifact’s reconstructed intensity is maximized due to the filter’s singular behavior. State explicitly how (or if) $r^{\\ast}$ depends on $\\delta$.\n\nExpress your final answer as a closed-form analytic expression in terms of $s_0$ and fundamental constants as needed. No numerical evaluation is required.", "solution": "The problem asks for the radius $r^{\\ast}$ of a ring artifact in a Computed Tomography (CT) reconstruction caused by a single detector element with a constant additive bias. The reconstruction is performed using the ideal filtered backprojection (FBP) algorithm.\n\nThe FBP reconstruction $\\hat{f}(x,y)$ of an object $f(x,y)$ from its Radon transform (sinogram) $p(\\theta,s)$ is given by the formula:\n$$ \\hat{f}(x,y) = \\int_{0}^{\\pi} p_f(\\theta, x\\cos\\theta + y\\sin\\theta) \\, d\\theta $$\nwhere $p_f(\\theta, s)$ is the filtered projection. The filtering step is a convolution of the projection $p(\\theta, \\cdot)$ with a filter kernel $h(s)$:\n$$ p_f(\\theta, s) = (p(\\theta, \\cdot) * h)(s) = \\int_{-\\infty}^{\\infty} p(\\theta, s') h(s - s') \\, ds' $$\nThe problem states that the filter $h(s)$ corresponds to the ideal ramp filter, whose Fourier transform with respect to $s$, denoted $\\mathcal{F}\\{h\\}(\\omega)$, is $|\\omega|$. In the spatial domain, this ideal filter is given by the principal value of a singular function. It can be formally written as the inverse Fourier transform of $|\\omega|$:\n$$ h(s) = \\frac{1}{2\\pi} \\int_{-\\infty}^{\\infty} |\\omega| e^{i\\omega s} \\, d\\omega $$\nThis expression is not a regular function but a distribution, whose dominant behavior for $s \\neq 0$ is proportional to $1/s^2$. More formally, $h(s) = -\\frac{1}{2\\pi^2} \\text{p.v.} \\frac{1}{s^2}$. The critical property for this problem is the singularity at $s=0$.\n\nThe measured sinogram $p_{\\mathrm{m}}(\\theta,s)$ contains the true sinogram $p(\\theta,s)$ plus an artifact term. The artifact is due to a single detector bin at coordinate $s=s_0$ having a constant additive bias $\\delta$ for all view angles $\\theta \\in [0, \\pi)$. Idealizing the detector bin as infinitesimally narrow, we can model this artifact contribution as a Dirac delta distribution in the spatial domain $s$:\n$$ p_{\\text{artifact}}(\\theta, s) = \\delta \\cdot \\delta_{\\text{Dirac}}(s - s_0) $$\nThe total measured sinogram is $p_{\\mathrm{m}}(\\theta,s) = p(\\theta,s) + p_{\\text{artifact}}(\\theta,s)$. Due to the linearity of the FBP algorithm, the reconstructed image will be the sum of the true image reconstruction and the artifact's reconstruction:\n$$ \\hat{f}_{\\mathrm{m}}(x,y) = \\hat{f}_{\\text{true}}(x,y) + \\hat{f}_{\\text{artifact}}(x,y) $$\nWe are tasked with finding the radius of the ring artifact, which corresponds to analyzing $\\hat{f}_{\\text{artifact}}(x,y)$.\n\nFirst, we determine the filtered artifact projection, $p_{f, \\text{artifact}}(\\theta,s)$:\n$$ p_{f, \\text{artifact}}(\\theta, s) = (p_{\\text{artifact}}(\\theta, \\cdot) * h)(s) = \\int_{-\\infty}^{\\infty} \\delta \\cdot \\delta_{\\text{Dirac}}(s' - s_0) h(s - s') \\, ds' $$\nUsing the sifting property of the Dirac delta function, this convolution simplifies to:\n$$ p_{f, \\text{artifact}}(\\theta, s) = \\delta \\cdot h(s - s_0) $$\nNote that the filtered artifact projection is independent of the angle $\\theta$.\n\nNext, we perform the backprojection step on $p_{f, \\text{artifact}}$ to obtain the artifact image $\\hat{f}_{\\text{artifact}}(x,y)$:\n$$ \\hat{f}_{\\text{artifact}}(x,y) = \\int_{0}^{\\pi} p_{f, \\text{artifact}}(\\theta, x\\cos\\theta + y\\sin\\theta) \\, d\\theta $$\nSubstituting the expression for $p_{f, \\text{artifact}}$:\n$$ \\hat{f}_{\\text{artifact}}(x,y) = \\int_{0}^{\\pi} \\delta \\cdot h(x\\cos\\theta + y\\sin\\theta - s_0) \\, d\\theta $$\nTo analyze the radial dependence, we convert the image coordinates $(x,y)$ to polar coordinates $(r, \\varphi)$, where $x=r\\cos\\varphi$ and $y=r\\sin\\varphi$. The expression becomes:\n$$ \\hat{f}_{\\text{artifact}}(r,\\varphi) = \\delta \\int_{0}^{\\pi} h(r\\cos\\varphi\\cos\\theta + r\\sin\\varphi\\sin\\theta - s_0) \\, d\\theta $$\n$$ \\hat{f}_{\\text{artifact}}(r,\\varphi) = \\delta \\int_{0}^{\\pi} h(r\\cos(\\theta - \\varphi) - s_0) \\, d\\theta $$\nBy a change of variable $u = \\theta - \\varphi$, the integral becomes $\\int_{-\\varphi}^{\\pi-\\varphi} h(r\\cos(u) - s_0) \\, du$. Since the integration is over an interval of length $\\pi$ and the backprojection of a function of $s$ only is known to be circularly symmetric, the result is independent of $\\varphi$. We can set $\\varphi=0$ without loss of generality to simplify the analysis. The artifact image intensity is a function of radius $r$ only, which we denote $A(r)$:\n$$ A(r) = \\hat{f}_{\\text{artifact}}(r) = \\delta \\int_{0}^{\\pi} h(r\\cos\\theta - s_0) \\, d\\theta $$\n\nThe problem asks for the radius $r^{\\ast}$ where the artifact intensity is maximized due to the filter's singular behavior. The filter $h(u)$ is singular at $u=0$. Therefore, the integral $A(r)$ will be dominated by contributions from angles $\\theta$ where the argument of $h$, which is $g(r, \\theta) = r\\cos\\theta - s_0$, is close to zero. We analyze the behavior of this integral by considering the roots of $g(r, \\theta) = 0$.\n\nCase 1: $r  |s_0|$. In this case, $|r\\cos\\theta| \\le r  |s_0|$, so $r\\cos\\theta - s_0$ is never zero for any $\\theta$. The integrand $h(r\\cos\\theta - s_0)$ is a smooth, well-behaved function over the entire integration interval. The resulting integral $A(r)$ is finite and continuous.\n\nCase 2: $r  |s_0|$. In this case, the equation $r\\cos\\theta = s_0$ has solutions for $\\theta$. Specifically, $\\cos\\theta = s_0/r$ has two solutions in $[0, 2\\pi)$, and generally one or two in $[0, \\pi)$ depending on the sign of $s_0$. Let $\\theta_0$ be a solution. The derivative of the argument with respect to $\\theta$ at this point is $\\frac{d}{d\\theta}(r\\cos\\theta - s_0)|_{\\theta_0} = -r\\sin\\theta_0 = \\mp\\sqrt{r^2 - s_0^2} \\neq 0$. This means $\\theta_0$ is a simple root. Near a simple root, the integrand behaves like $h(c(\\theta-\\theta_0)) \\propto 1/(\\theta-\\theta_0)^2$, where $c$ is a non-zero constant. While singular, this type of integral is manageable in the principal value sense and yields a finite, though large, value.\n\nCase 3: $r = |s_0|$. Let's assume $s_0  0$ without loss of generality, so $r=s_0$. The equation for the root becomes $s_0\\cos\\theta = s_0$, which gives $\\cos\\theta=1$, so $\\theta=0$. At this point, the argument of $h$ is zero. Let's inspect its derivative as well: $\\frac{d}{d\\theta}(s_0\\cos\\theta - s_0)|_{\\theta=0} = -s_0\\sin(0) = 0$. Since both the function and its first derivative are zero, $\\theta=0$ is a double root. Near $\\theta=0$, we use the Taylor expansion for cosine: $\\cos\\theta \\approx 1 - \\theta^2/2$. The argument of $h$ becomes:\n$$ s_0\\cos\\theta - s_0 \\approx s_0(1 - \\frac{\\theta^2}{2}) - s_0 = -\\frac{s_0\\theta^2}{2} $$\nThe integrand near $\\theta=0$ behaves as $h(-\\frac{s_0\\theta^2}{2}) \\propto \\frac{1}{(-\\frac{s_0\\theta^2}{2})^2} \\propto \\frac{1}{\\theta^4}$. The integral $\\int \\frac{d\\theta}{\\theta^4}$ has a much stronger, non-integrable singularity compared to the simple-root case. This \"tangency\" condition, where the backprojection sinusoid $s=r\\cos\\theta$ just touches the artifact line $s=s_0$, creates a mathematical catastrophe in the ideal limit. In a physical system with non-ideal filters and finite detector sizes, this divergence translates to a sharp, finite peak in intensity.\n\nThe maximal intensity of the artifact is thus located at the radius $r$ where this tangency occurs. This condition is $r = |s_0|$. Therefore, the radius of the ring artifact is $r^{\\ast} = |s_0|$.\n\nThe problem also asks about the dependence of $r^{\\ast}$ on the bias value $\\delta$. The value $\\delta$ appears as a linear scaling factor in the expression for the artifact's reconstructed intensity profile $A(r)$. While $\\delta$ determines the magnitude (and sign) of the artifact's intensity (i.e., how bright or dark the ring is), it does not alter the geometric location of its peak. The position $r^{\\ast}$ is determined solely by the geometric parameter $s_0$. Thus, $r^{\\ast}$ is independent of $\\delta$.\n\nThe final answer is the radius $r^{\\ast}$ of the ring artifact.\n$$ r^{\\ast} = |s_0| $$\nThis is expressed in terms of the given coordinate $s_0$, as required.", "answer": "$$ \\boxed{|s_0|} $$", "id": "4533126"}, {"introduction": "Building on the foundational theory, this practice transitions to the more realistic fan-beam geometry used in modern clinical CT scanners. This exercise challenges you to work backward: given a ring artifact of a specific radius in a reconstructed image, you will use geometric principles to identify the exact detector channel responsible for it [@problem_id:4920388]. This is a crucial skill for quality assurance and troubleshooting in a real-world setting.", "problem": "A single persistent detector channel in a fan-beam Computed Tomography (CT) system can produce a circular artifact (“ring”) centered at the isocenter. Consider a third-generation CT geometry with a point X-ray source moving on a circular trajectory of radius $R$ around the isocenter at the origin, and a curved detector arc centered at the source with radius $D_{sd}$ (source-to-detector distance). The detector is equiangular: the $k$-th channel corresponds to an arc-length coordinate $s = (k - i_{c}) \\,\\Delta s$ measured from the central channel index $i_{c}$, where $\\Delta s$ is the arc-length per channel. The fan angle $\\gamma$ associated to an arc-length $s$ on the curved detector satisfies the relation $s = D_{sd}\\,\\gamma$ when $\\gamma$ is measured in radians. Assume the reconstruction algorithm uses standard filtered backprojection of fan-beam data rebinned to parallel-beam geometry.\n\nA constant additive error at a fixed detector channel across all view angles produces a ring artifact whose radius $r$ is determined solely by the underlying fan-beam ray geometry and the rebinning to parallel-beam coordinates. Using only first principles of Euclidean geometry for fan-beam rays and the basic property that, in parallel-beam reconstruction, a stripe at fixed signed perpendicular distance from the isocenter backprojects to a circle of the same radius, derive an explicit closed-form expression for the responsible detector channel index $k_{0}$ as a function of the observed ring radius $r$, the source-to-isocenter radius $R$, the source-to-detector radius $D_{sd}$, the channel pitch $\\Delta s$, and the central channel index $i_{c}$. Take the responsible channel to be on the positive-fan-angle side (i.e., with $s_{0}  0$ and $k_{0}  i_{c}$), and assume $0 \\leq r  R$. Angles are to be treated in radians. Provide the final analytic expression only; no numerical evaluation is required.", "solution": "A ring artifact of radius $r$ in a CT image reconstructed using filtered backprojection is the result of a systematic error that appears as a horizontal stripe in the corresponding sinogram, when the data is represented in parallel-beam coordinates $(\\rho, \\theta)$. Here, $\\theta$ is the projection angle and $\\rho$ is the signed perpendicular distance of a given X-ray from the isocenter (the center of rotation). A constant error for all projection angles at a fixed distance $\\rho_0$ backprojects to a circle of radius $r = |\\rho_0|$.\n\nThe problem states that a single persistent detector channel, $k_0$, is the cause. In a fan-beam system, a fixed channel corresponds to a fixed fan angle, let's call it $\\gamma_0$, relative to the central ray connecting the X-ray source to the isocenter. The reconstruction process involves rebinning the acquired fan-beam data, indexed by gantry angle $\\beta$ and fan angle $\\gamma$, into parallel-beam coordinates $(\\rho, \\theta)$. The crucial insight is that for a fixed fan angle $\\gamma_0$, the corresponding perpendicular distance $\\rho$ is constant for all gantry angles $\\beta$. This constant distance is the radius of the ring artifact, $r$. Our task is to derive this geometric relationship and then use the detector parameterization to solve for the channel index $k_0$.\n\nLet us establish a 2D Cartesian coordinate system with the isocenter at the origin, $O=(0,0)$. The X-ray source moves on a circular path of radius $R$. We can analyze the geometry for a single projection without loss of generality by placing the source at position $\\vec{S} = (0, R)$ on the $y$-axis.\n\nThe central ray of the fan beam travels from the source $\\vec{S}$ through the isocenter $O$. A general ray is characterized by its fan angle $\\gamma$ with respect to this central ray. The problem specifies a channel on the positive-fan-angle side, so we consider $\\gamma  0$.\n\nConsider the right-angled triangle formed by the X-ray source $S$, the isocenter $O$, and the point $Q$ on the ray that is closest to the origin. The line segment $OQ$ is perpendicular to the ray, and its length is the perpendicular distance $\\rho$. The hypotenuse of this triangle is the segment $SO$, whose length is the source-to-isocenter radius, $R$. The angle at the source, $\\angle OSQ$, is equal to the fan angle $\\gamma$.\n\nFrom the trigonometry of the right-angled triangle $\\triangle SOQ$, we have:\n$$\n\\sin(\\gamma) = \\frac{\\text{opposite}}{\\text{hypotenuse}} = \\frac{OQ}{SO} = \\frac{\\rho}{R}\n$$\nThis gives the fundamental relationship between the fan angle $\\gamma$ and the parallel-beam coordinate $\\rho$:\n$$\n\\rho = R \\sin(\\gamma)\n$$\nThis relationship holds irrespective of the source's rotational position $\\beta$. A faulty channel has a fixed fan angle $\\gamma_0$, which is mapped during rebinning to a constant perpendicular distance $\\rho_0 = R \\sin(\\gamma_0)$. This constant value across all views creates the ring artifact. The radius of this artifact is given as $r$, so we must have $r = |\\rho_0|$. Since the problem specifies $k_0  i_c$, this corresponds to a positive arc length $s_0  0$ and a positive fan angle $\\gamma_0  0$. The fan angles in a typical CT scanner are within the range $(-\\pi/2, \\pi/2)$, so $\\sin(\\gamma_0)  0$. Therefore, we can write:\n$$\nr = R \\sin(\\gamma_0)\n$$\nWe need to solve for the fan angle $\\gamma_0$ corresponding to the faulty channel. Given the constraint $0 \\leq r  R$, which ensures the ray intersects the field of view inside the source path, we can invert the sine function:\n$$\n\\sin(\\gamma_0) = \\frac{r}{R}\n$$\n$$\n\\gamma_0 = \\arcsin\\left(\\frac{r}{R}\\right)\n$$\nThe principal value of the arcsin function is taken, which gives a result in $(0, \\pi/2)$ consistent with our assumptions.\n\nNext, we relate the fan angle $\\gamma_0$ to the detector channel index $k_0$. The problem provides two relationships for the equiangular detector array. First, the arc length $s$ on the detector is related to the fan angle $\\gamma$ (in radians) and the source-to-detector distance $D_{sd}$:\n$$\ns = D_{sd} \\gamma\n$$\nFor our specific channel, this is $s_0 = D_{sd} \\gamma_0$.\n\nSecond, the arc length $s$ is related to the channel index $k$ and the central channel index $i_c$ by the channel pitch $\\Delta s$:\n$$\ns = (k - i_c) \\Delta s\n$$\nFor the faulty channel $k_0$, this gives $s_0 = (k_0 - i_c) \\Delta s$.\n\nEquating the two expressions for the arc length $s_0$ of the faulty channel:\n$$\n(k_0 - i_c) \\Delta s = D_{sd} \\gamma_0\n$$\nNow, we substitute the expression we found for $\\gamma_0$:\n$$\n(k_0 - i_c) \\Delta s = D_{sd} \\arcsin\\left(\\frac{r}{R}\\right)\n$$\nFinally, we solve for the desired channel index $k_0$:\n$$\nk_0 - i_c = \\frac{D_{sd}}{\\Delta s} \\arcsin\\left(\\frac{r}{R}\\right)\n$$\n$$\nk_0 = i_c + \\frac{D_{sd}}{\\Delta s} \\arcsin\\left(\\frac{r}{R}\\right)\n$$\nThis expression gives the detector channel index $k_0$ responsible for a ring artifact of radius $r$ as a function of the scanner's geometric and detector parameters.", "answer": "$$\n\\boxed{i_c + \\frac{D_{sd}}{\\Delta s} \\arcsin\\left(\\frac{r}{R}\\right)}\n$$", "id": "4920388"}, {"introduction": "Our final practice moves from manual analysis to the automated methods that are essential for efficient and reliable CT system performance. You will design a complete algorithm using robust statistics to automatically flag miscalibrated detector channels directly from the sinogram data, even in the presence of noise [@problem_id:4920456]. This exercise culminates in deriving the detector's theoretical false positive rate, bridging the gap between algorithm design and performance validation.", "problem": "You are given a simplified mathematical model of ring artifact formation in Computed Tomography (CT) sinograms. Consider a homogeneous cylindrical phantom such that for each rotation angle $\\phi$ (in radians) and detector channel index $j$, the natural logarithm of the measured line integral yields a sinogram sample modeled as\n$$\nS(\\phi,j) = A(\\phi) + B_j + \\varepsilon(\\phi,j),\n$$\nwhere $A(\\phi)$ is a common, angle-dependent term shared across channels due to the homogeneous phantom geometry, $B_j$ is a constant offset for channel $j$ capturing bias or calibration error, and $\\varepsilon(\\phi,j)$ are independent, identically distributed Gaussian noise samples with zero mean and standard deviation $\\sigma$. Under ideal homogeneous phantom scans, the unbiased case has $B_j = 0$ for all $j$.\n\nYour tasks are:\n\n1. Algorithm design: Develop a robust detector of biased channels by applying robust statistics across $\\phi$ to each sinogram column. The algorithm should:\n   - Estimate $A(\\phi)$ robustly using the sample median across channels at each angle $\\phi$, yielding $\\widehat{A}(\\phi)$.\n   - Form residuals $R(\\phi,j) = S(\\phi,j) - \\widehat{A}(\\phi)$.\n   - For each channel $j$, compute the sample median $M_j$ across $\\phi$ of $R(\\phi,j)$ and the Median Absolute Deviation $D_j = \\operatorname{median}_{\\phi}(|R(\\phi,j) - M_j|)$.\n   - Compute a robust score $T_j = |M_j|/D_j$ and declare channel $j$ biased if $T_j \\ge \\tau$ for a given threshold $\\tau$.\n\n2. False positive rate derivation: Under homogeneous phantom scans ($B_j = 0$ for all $j$), assume $R(\\phi,j)$ are independent and identically distributed as $\\mathcal{N}(0,\\sigma^2)$ after removal of the common term $A(\\phi)$ with a large number of channels such that the estimation error in $\\widehat{A}(\\phi)$ is negligible. Using standard asymptotic properties of order statistics for the sample median and the normal-approximation of the Median Absolute Deviation under Gaussian noise, derive the expected false positive rate (FPR) $\\mathrm{FPR}(n_\\phi,\\tau)$ of the detector as a function of the number of angles $n_\\phi$ and threshold $\\tau$. Express your final FPR in terms of the standard normal cumulative distribution function $\\Phi(\\cdot)$, and constants dependent on $\\sigma$ and $n_\\phi$. Your program should implement this derived formula.\n\n3. Simulation and evaluation: For each test case, generate a synthetic sinogram using the model\n$$\nS_k(j) = A(\\phi_k) + B_j + \\varepsilon_{k,j}, \\quad \\phi_k = \\frac{2\\pi k}{n_\\phi}, \\quad k \\in \\{0,1,\\dots,n_\\phi-1\\},\n$$\nwith\n$$\nA(\\phi) = a_1 \\sin(2\\phi) + a_2 \\cos(3\\phi),\n$$\nand known constants $a_1$ and $a_2$. Use the detector to count the total number of biased channels declared for the sinogram with injected biases $B_j$. Additionally, compute the empirical false positive rate by generating a second sinogram with the same parameters but $B_j=0$ for all $j$ and measuring the fraction of channels flagged as biased. Angles $\\phi$ must be in radians. All outputs that represent rates must be expressed as decimals.\n\nTest suite:\n- Case $1$: $n_\\phi = 720$, $m = 512$, $\\sigma = 0.003$, $\\tau = 4.0$, $a_1 = 0.05$, $a_2 = 0.02$, $B_j$ nonzero at $j \\in \\{50,120,300,450\\}$ with $B_j = 0.02$ there and $B_j = 0$ otherwise.\n- Case $2$: $n_\\phi = 32$, $m = 256$, $\\sigma = 0.003$, $\\tau = 3.0$, $a_1 = 0.05$, $a_2 = 0.02$, $B_j$ nonzero at $j \\in \\{10,200\\}$ with $B_j = 0.02$ there and $B_j = 0$ otherwise.\n- Case $3$: $n_\\phi = 180$, $m = 128$, $\\sigma = 0.0$, $\\tau = 2.0$, $a_1 = 0.05$, $a_2 = 0.02$, $B_j$ nonzero at $j \\in \\{5,64,100\\}$ with $B_j = 0.015$ there and $B_j = 0$ otherwise.\n- Case $4$: $n_\\phi = 1000$, $m = 256$, $\\sigma = 0.004$, $\\tau = 10.0$, $a_1 = 0.05$, $a_2 = 0.02$, $B_j = 0$ for all channels.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list of the form $[N_\\text{det}, \\mathrm{FPR}_\\text{theory}, \\mathrm{FPR}_\\text{sim}]$, with $N_\\text{det}$ the integer count of detected biased channels in the biased sinogram, and $\\mathrm{FPR}_\\text{theory}$ and $\\mathrm{FPR}_\\text{sim}$ given as decimal floats. For example, the printed output should look like\n$$\n\\big[ [N_1,F_1,E_1], [N_2,F_2,E_2], [N_3,F_3,E_3], [N_4,F_4,E_4] \\big].\n$$", "solution": "The problem addresses the detection of ring artifacts in Computed Tomography (CT) sinograms. These artifacts manifest as concentric rings in the reconstructed image and typically originate from detector channel miscalibrations or drifts. The provided mathematical model for a sinogram sample, $S(\\phi,j) = A(\\phi) + B_j + \\varepsilon(\\phi,j)$, effectively isolates the source of these artifacts into a channel-dependent bias term $B_j$. A non-zero $B_j$ for a specific channel $j$ will introduce a persistent line-like feature at that channel's position across all projection angles $\\phi$ in the sinogram, which subsequently transforms into a ring during back-projection.\n\nThe task is to develop and analyze a robust statistical detector for identifying channels with non-zero bias $B_j$. The core of the problem involves deriving the theoretical performance of this detector and verifying it through simulation. We will first derive the expression for the false positive rate (FPR), then detail the algorithmic implementation for the simulation.\n\n### False Positive Rate (FPR) Derivation\n\nThe false positive rate is the probability of declaring a channel as biased when it is, in fact, not. This corresponds to the probability of the test statistic $T_j$ exceeding the threshold $\\tau$ under the null hypothesis $H_0$ that the channel is unbiased ($B_j = 0$).\n\n1.  **Null Hypothesis and Residuals**: Under $H_0$, the sinogram model is $S(\\phi,j) = A(\\phi) + \\varepsilon(\\phi,j)$. The algorithm estimates the common term $A(\\phi)$ using the median across channels: $\\widehat{A}(\\phi) = \\operatorname{median}_{j} S(\\phi,j)$. The residuals are then $R(\\phi,j) = S(\\phi,j) - \\widehat{A}(\\phi)$. Assuming a large number of detector channels $m$, the sample median $\\widehat{A}(\\phi)$ is a robust and accurate estimator of $A(\\phi)$, as the median is insensitive to the small fraction of biased channels (outliers). For the unbiased channels under consideration for the FPR, the estimation error $\\widehat{A}(\\phi) - A(\\phi) = \\operatorname{median}_j(\\varepsilon(\\phi, j))$ becomes negligible. Therefore, we can approximate the residuals for a fixed channel $j$ as a set of $n_\\phi$ i.i.d. samples drawn directly from the noise distribution: $R(\\phi_k, j) \\approx \\varepsilon(\\phi_k, j) \\sim \\mathcal{N}(0, \\sigma^2)$.\n\n2.  **Distribution of the Sample Median $M_j$**: The statistic $M_j = \\operatorname{median}_{\\phi}(R(\\phi,j))$ is the sample median of $n_\\phi$ samples from $\\mathcal{N}(0, \\sigma^2)$. For a large number of angles $n_\\phi$, the central limit theorem for order statistics states that the sample median is asymptotically normally distributed. Its expected value is the true median (which is $0$), and its variance is given by $\\sigma_{M_j}^2 \\approx \\frac{1}{4n_\\phi [f(0)]^2}$, where $f(x)$ is the PDF of the underlying distribution. For $\\mathcal{N}(0, \\sigma^2)$, the PDF is $f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\left(\\frac{-x^2}{2\\sigma^2}\\right)$, so $f(0) = \\frac{1}{\\sigma\\sqrt{2\\pi}}$. The variance of $M_j$ is thus:\n    $$ \\sigma_{M_j}^2 \\approx \\frac{1}{4n_\\phi \\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\right)^2} = \\frac{2\\pi\\sigma^2}{4n_\\phi} = \\frac{\\pi\\sigma^2}{2n_\\phi} $$\n    So, $M_j \\sim \\mathcal{N}\\left(0, \\frac{\\pi\\sigma^2}{2n_\\phi}\\right)$.\n\n3.  **Approximation of the Median Absolute Deviation (MAD) $D_j$**: The statistic $D_j = \\operatorname{median}_{\\phi}(|R(\\phi,j) - M_j|)$ is the MAD of the residuals. For large $n_\\phi$, $M_j$ is close to the true median ($0$), so $D_j \\approx \\operatorname{median}_{\\phi}(|R(\\phi,j)|)$. By the law of large numbers, the sample MAD converges in probability to the population MAD. For a normal distribution $\\mathcal{N}(0, \\sigma^2)$, the MAD is proportional to the standard deviation $\\sigma$. The median of the folded normal distribution $|R|$ is $q$ such that $P(|R| \\le q) = 1/2$, which yields $q = \\sigma \\Phi^{-1}(3/4)$, where $\\Phi(\\cdot)$ is the standard normal CDF. We will approximate $D_j$ by this constant asymptotic value, a step justified by Slutsky's theorem when considering the ratio $T_j$.\n    $$ D_j \\approx \\sigma \\Phi^{-1}(3/4) $$\n\n4.  **Distribution of the Test Statistic $T_j$**: The test statistic is $T_j = |M_j|/D_j$. Using the results from steps 2 and 3:\n    $$ T_j \\approx \\frac{|M_j|}{\\sigma \\Phi^{-1}(3/4)} $$\n    Since $M_j \\sim \\mathcal{N}\\left(0, \\frac{\\pi\\sigma^2}{2n_\\phi}\\right)$, the variable $Z_T = \\frac{M_j}{\\sigma \\Phi^{-1}(3/4)}$ follows a normal distribution with mean $0$ and variance:\n    $$ \\operatorname{Var}(Z_T) = \\frac{1}{(\\sigma \\Phi^{-1}(3/4))^2} \\operatorname{Var}(M_j) = \\frac{1}{\\sigma^2 (\\Phi^{-1}(3/4))^2} \\left(\\frac{\\pi\\sigma^2}{2n_\\phi}\\right) = \\frac{\\pi}{2n_\\phi (\\Phi^{-1}(3/4))^2} $$\n    Let $\\sigma_T^2 = \\operatorname{Var}(Z_T)$. Then $T_j \\approx |Z_T|$, where $Z_T \\sim \\mathcal{N}(0, \\sigma_T^2)$.\n\n5.  **False Positive Rate Formula**: The FPR is $P(T_j \\ge \\tau)$.\n    $$ \\mathrm{FPR} = P(|Z_T| \\ge \\tau) = P(Z_T \\ge \\tau) + P(Z_T \\le -\\tau) = 2 P(Z_T \\ge \\tau) $$\n    Let $Z \\sim \\mathcal{N}(0,1)$. Then $Z_T = Z \\cdot \\sigma_T$.\n    $$ \\mathrm{FPR} = 2 P(Z \\cdot \\sigma_T \\ge \\tau) = 2 P(Z \\ge \\tau/\\sigma_T) = 2 \\left(1 - \\Phi\\left(\\frac{\\tau}{\\sigma_T}\\right)\\right) $$\n    Substituting the expression for $\\sigma_T$:\n    $$ \\frac{\\tau}{\\sigma_T} = \\tau \\sqrt{\\frac{2n_\\phi (\\Phi^{-1}(3/4))^2}{\\pi}} = \\tau \\Phi^{-1}(3/4) \\sqrt{\\frac{2n_\\phi}{\\pi}} $$\n    Thus, the final expression for the theoretical FPR is:\n    $$ \\mathrm{FPR}(n_\\phi, \\tau) = 2 \\left(1 - \\Phi\\left(\\tau \\Phi^{-1}(3/4) \\sqrt{\\frac{2n_\\phi}{\\pi}}\\right)\\right) $$\n    This formula is valid for $\\sigma  0$. For the special case $\\sigma=0$, the noise term vanishes. Under the null hypothesis ($B_j=0$), the residuals are identically zero, resulting in $M_j=0$ and $D_j=0$. The test statistic $T_j$ is taken to be $0$, so no false positives occur. Therefore, $\\mathrm{FPR}=0$ when $\\sigma=0$.\n\n### Algorithmic Design and Simulation\n\nThe algorithm specified in the problem statement is implemented to process synthetic sinograms. The simulation framework evaluates this algorithm on the provided test cases.\n\n1.  **Sinogram Generation**: For each test case, two sinograms are generated based on the model $S_k(j) = A(\\phi_k) + B_j + \\varepsilon_{k,j}$.\n    *   A \"biased\" sinogram using the specified non-zero $B_j$ values.\n    *   An \"unbiased\" sinogram for the empirical FPR calculation, where $B_j=0$ for all $j$.\n    The common term is $A(\\phi_k) = a_1 \\sin(2\\phi_k) + a_2 \\cos(3\\phi_k)$, with $\\phi_k = 2\\pi k / n_\\phi$. The noise $\\varepsilon_{k,j}$ is drawn from $\\mathcal{N}(0, \\sigma^2)$.\n\n2.  **Detection Algorithm**: The core detection logic is applied to a given sinogram $S$ and threshold $\\tau$:\n    *   Estimate the common component for each angle: $\\widehat{A}_k = \\operatorname{median}_j S_k(j)$.\n    *   Compute the residual matrix: $R_{k,j} = S_{k,j} - \\widehat{A}_k$.\n    *   For each channel $j$, compute the median of its residuals: $M_j = \\operatorname{median}_k R_{k,j}$.\n    *   For each channel $j$, compute the MAD of its residuals: $D_j = \\operatorname{median}_k |R_{k,j} - M_j|$.\n    *   Calculate the robust score $T_j = |M_j|/D_j$. Special handling is required for $D_j=0$: if $M_j \\neq 0$, $T_j$ is treated as infinite; if $M_j=0$, $T_j=0$.\n    *   Count the number of channels where $T_j \\ge \\tau$.\n\n3.  **Evaluation**:\n    *   $N_\\text{det}$: The number of detected channels from the biased sinogram.\n    *   $\\mathrm{FPR}_\\text{theory}$: The theoretical FPR calculated using the derived formula.\n    *   $\\mathrm{FPR}_\\text{sim}$: The empirical FPR, calculated as the fraction of channels detected as biased in the unbiased sinogram, i.e., $N_{fp}/m$.\n\nThe implementation encapsulates this logic, iterates through the test cases, and formats the results as specified. A fixed random seed is used for reproducibility of the simulations.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def calculate_theoretical_fpr(n_phi, tau, sigma):\n        \"\"\"Calculates the theoretical False Positive Rate using the derived formula.\"\"\"\n        if sigma == 0.0:\n            # In the noiseless case, residuals for unbiased channels are exactly zero.\n            # Thus, M_j = 0, D_j = 0, and T_j = 0, resulting in zero false positives.\n            return 0.0\n        \n        # For any meaningful threshold tau > 0.\n        if tau = 0:\n            return 1.0\n        \n        # Constant c = Phi^-1(0.75)\n        c_factor = norm.ppf(0.75)\n        \n        # Argument for the standard normal CDF\n        arg = tau * c_factor * np.sqrt(2 * n_phi / np.pi)\n        \n        # FPR = 2 * (1 - Phi(arg)) = 2 * SF(arg)\n        fpr = 2 * norm.sf(arg)  # sf is the survival function (1 - cdf)\n        return fpr\n\n    def count_detected_channels(S, tau):\n        \"\"\"\n        Applies the robust detection algorithm to a sinogram S and returns the\n        count of channels declared as biased.\n        \n        Args:\n            S (np.ndarray): The input sinogram of shape (n_phi, m).\n            tau (float): The detection threshold.\n            \n        Returns:\n            int: The number of detected biased channels.\n        \"\"\"\n        # Step 1: Estimate A(phi) robustly using the sample median across channels.\n        A_hat = np.median(S, axis=1, keepdims=True)\n        \n        # Step 2: Form residuals R(phi, j).\n        R = S - A_hat\n        \n        # Step 3: For each channel j, compute the sample median M_j and MAD D_j.\n        M = np.median(R, axis=0)\n        D = np.median(np.abs(R - M), axis=0) # Broadcasting of M is automatic\n        \n        # Step 4: Compute robust score T_j, handling D_j = 0.\n        T = np.zeros_like(M, dtype=float)\n        \n        # Case 1: D_j is not zero. Standard calculation.\n        nonzero_D_mask = D != 0\n        T[nonzero_D_mask] = np.abs(M[nonzero_D_mask]) / D[nonzero_D_mask]\n        \n        # Case 2: D_j is zero, but M_j is not. This is a clear artifact, score is infinite.\n        inf_mask = (D == 0)  (M != 0)\n        T[inf_mask] = np.inf\n        \n        # Case 3: D_j is zero and M_j is zero. Score is zero. (Handled by initialization)\n        \n        # Step 5: Declare channel j biased if T_j >= tau.\n        detected_count = np.sum(T >= tau)\n        \n        return int(detected_count)\n\n    def run_simulation(n_phi, m, sigma, tau, a1, a2, B_spec):\n        \"\"\"\n        Runs a single test case scenario, including simulation and theoretical calculation.\n        \n        Returns:\n            list: A list containing [N_det, FPR_theory, FPR_sim].\n        \"\"\"\n        # 1. Calculate theoretical FPR\n        fpr_theory = calculate_theoretical_fpr(n_phi, tau, sigma)\n        \n        # Common simulation setup\n        phi = (2 * np.pi / n_phi) * np.arange(n_phi)\n        A = a1 * np.sin(2 * phi) + a2 * np.cos(3 * phi)\n        A = A[:, np.newaxis] # Reshape for broadcasting: (n_phi, 1)\n\n        # 2. Simulation with injected biases to find N_det\n        B_biased = np.zeros(m)\n        for j, val in B_spec.items():\n            B_biased[j] = val\n        \n        noise_biased = np.random.normal(0, sigma, (n_phi, m))\n        S_biased = A + B_biased + noise_biased\n        \n        N_det = count_detected_channels(S_biased, tau)\n        \n        # 3. Simulation for empirical FPR (no bias)\n        B_unbiased = np.zeros(m)\n        noise_unbiased = np.random.normal(0, sigma, (n_phi, m))\n        S_unbiased = A + B_unbiased + noise_unbiased\n        \n        N_fp = count_detected_channels(S_unbiased, tau)\n        fpr_sim = N_fp / m\n        \n        return [N_det, fpr_theory, fpr_sim]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n_phi, m, sigma, tau, a1, a2, B_spec\n        (720, 512, 0.003, 4.0, 0.05, 0.02, {50: 0.02, 120: 0.02, 300: 0.02, 450: 0.02}),\n        # Case 2\n        (32, 256, 0.003, 3.0, 0.05, 0.02, {10: 0.02, 200: 0.02}),\n        # Case 3\n        (180, 128, 0.0, 2.0, 0.05, 0.02, {5: 0.015, 64: 0.015, 100: 0.015}),\n        # Case 4\n        (1000, 256, 0.004, 10.0, 0.05, 0.02, {})\n    ]\n\n    # Use a fixed random seed for reproducible results, as is good practice\n    # in scientific simulations.\n    np.random.seed(42)\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(*case)\n        all_results.append(result)\n\n    # Format the final output string to be compact and match the required structure.\n    # e.g., [[N1,F1,E1],[N2,F2,E2],...]\n    string_reps = [f'[{r[0]},{r[1]},{r[2]}]' for r in all_results]\n    final_output = f'[{\",\".join(string_reps)}]'\n\n    print(final_output)\n\nsolve()\n```", "id": "4920456"}]}