{"hands_on_practices": [{"introduction": "The orientation of an image in 3D space is defined by a set of direction vectors that form a local coordinate system. For this system to be rigid and non-distorting, these vectors must be perfectly orthogonal and have unit length. This practice explores this fundamental property of orthonormality and what to do when numerical errors compromise it. You will implement and compare two essential linear algebra techniques, Gram-Schmidt and SVD-based reorthonormalization, to enforce this crucial geometric constraint, a vital skill for ensuring the integrity of any spatial analysis. [@problem_id:4894129]", "problem": "You are given two nearly in-plane direction vectors in three-dimensional Euclidean space that represent the row and column axes of an image slice in patient coordinates. Due to interpolation and rounding, these vectors are not exactly orthonormal. From first principles of Euclidean geometry and linear algebra, construct a method to reorthonormalize these in-plane axes and quantify the deviation introduced by enforcing the constraints of unit norm and mutual orthogonality. Specifically, begin from the definitions of the Euclidean inner product, the norm induced by the inner product, and the definition of an orthonormal set. You may use well-tested facts about the Gram–Schmidt process and the Singular Value Decomposition (SVD) of a matrix. Avoid assuming any shortcut formulas not derived from these foundations.\n\nLet the original in-plane vectors be denoted by $\\mathbf{r}, \\mathbf{c} \\in \\mathbb{R}^3$. The goal is to compute reorthonormalized vectors $\\hat{\\mathbf{r}}, \\hat{\\mathbf{c}} \\in \\mathbb{R}^3$ such that $\\hat{\\mathbf{r}} \\cdot \\hat{\\mathbf{c}} = 0$ and $\\|\\hat{\\mathbf{r}}\\| = \\|\\hat{\\mathbf{c}}\\| = 1$. Implement two reorthonormalization methods:\n\n- Gram–Schmidt: Use the projection of $\\mathbf{c}$ onto the orthogonal complement of the span of $\\mathbf{r}$ to enforce orthogonality, followed by normalization, with $\\hat{\\mathbf{r}}$ taken from the normalization of $\\mathbf{r}$.\n- SVD-based polar decomposition: Construct a full-rank $3 \\times 3$ matrix whose first two columns are derived from unit-normalized versions of $\\mathbf{r}$ and $\\mathbf{c}$, then use the unitary factor of its polar decomposition (obtained from the Singular Value Decomposition) to define an orthonormal matrix closest in Frobenius norm to the constructed matrix. Take the first two columns of this closest orthonormal matrix as $\\hat{\\mathbf{r}}$ and $\\hat{\\mathbf{c}}$.\n\nFor each method, quantify the deviation introduced by reorthonormalization using the following angle changes (in degrees):\n\n- $\\theta_{\\mathbf{r}} = \\arccos\\left( \\dfrac{|\\mathbf{r} \\cdot \\hat{\\mathbf{r}}|}{\\|\\mathbf{r}\\| \\, \\|\\hat{\\mathbf{r}}\\|} \\right)$ in degrees,\n- $\\theta_{\\mathbf{c}} = \\arccos\\left( \\dfrac{|\\mathbf{c} \\cdot \\hat{\\mathbf{c}}|}{\\|\\mathbf{c}\\| \\, \\|\\hat{\\mathbf{c}}\\|} \\right)$ in degrees.\n\nYour program must compute, for each test case, the quadruple of floats $[\\theta_{\\mathbf{r}}^{\\text{GS}}, \\theta_{\\mathbf{c}}^{\\text{GS}}, \\theta_{\\mathbf{r}}^{\\text{SVD}}, \\theta_{\\mathbf{c}}^{\\text{SVD}}]$, where the superscripts indicate the method (Gram–Schmidt or SVD). All angles must be expressed in degrees, rounded to six decimal places. Handle the near-collinear edge case robustly by ensuring the SVD-based method constructs a valid full-rank $3 \\times 3$ matrix (for example, by deterministically choosing a third column orthogonal to the first unit vector when needed). The program must not require any user input.\n\nTest suite (each case specifies $\\mathbf{r}$ and $\\mathbf{c}$ as ordered triples):\n\n- Case $1$ (exactly orthonormal): $\\mathbf{r} = (1, 0, 0)$, $\\mathbf{c} = (0, 1, 0)$.\n- Case $2$ (small in-plane perturbations and slight non-unit norms): $\\mathbf{r} = (0.999, 0.035, 0.002)$, $\\mathbf{c} = (-0.035, 0.999, -0.004)$.\n- Case $3$ (moderate non-orthogonality and non-unit norms): $\\mathbf{r} = (0.7, 0.7, 0)$, $\\mathbf{c} = (0.7, -0.7, 0.05)$.\n- Case $4$ (near-collinear edge case): $\\mathbf{r} = (1, 0, 0)$, $\\mathbf{c} = (0.9999, 0.01, 0)$.\n\nAngle unit requirement: All angles must be reported in degrees.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with no spaces. The results should be concatenated across the test cases in order. For example, the output should be of the form $[\\theta_{\\mathbf{r},1}^{\\text{GS}},\\theta_{\\mathbf{c},1}^{\\text{GS}},\\theta_{\\mathbf{r},1}^{\\text{SVD}},\\theta_{\\mathbf{c},1}^{\\text{SVD}},\\ldots,\\theta_{\\mathbf{r},4}^{\\text{GS}},\\theta_{\\mathbf{c},4}^{\\text{GS}},\\theta_{\\mathbf{r},4}^{\\text{SVD}},\\theta_{\\mathbf{c},4}^{\\text{SVD}}]$, where each numeric entry is a float rounded to six decimal places.", "solution": "This problem is solved by implementing two standard linear algebra techniques to create an orthonormal basis from two nearly-orthogonal input vectors, $\\mathbf{r}$ and $\\mathbf{c}$. The deviation introduced by each method is quantified by the angle between the original and corrected vectors.\n\n**Method 1: Gram–Schmidt Reorthonormalization**\nThe Gram-Schmidt process is an algorithm that constructs an orthonormal set from a set of linearly independent vectors. In this asymmetric application, the direction of the first vector, $\\mathbf{r}$, is preserved.\n1. The first orthonormal vector, $\\hat{\\mathbf{r}}$, is obtained by normalizing $\\mathbf{r}$: $\\hat{\\mathbf{r}} = \\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|}$.\n2. The second vector, $\\mathbf{c}$, is made orthogonal to $\\hat{\\mathbf{r}}$ by subtracting its projection onto $\\hat{\\mathbf{r}}$. This yields an intermediate vector $\\mathbf{c}' = \\mathbf{c} - (\\mathbf{c} \\cdot \\hat{\\mathbf{r}})\\hat{\\mathbf{r}}$.\n3. The second orthonormal vector, $\\hat{\\mathbf{c}}$, is obtained by normalizing $\\mathbf{c}'$: $\\hat{\\mathbf{c}} = \\frac{\\mathbf{c}'}{\\|\\mathbf{c}'\\|}$.\nThe set $\\{\\hat{\\mathbf{r}}, \\hat{\\mathbf{c}}\\}$ is now orthonormal. All correction to enforce orthogonality is applied to $\\mathbf{c}$.\n\n**Method 2: SVD-based Polar Decomposition**\nThis method finds the \"closest\" orthonormal basis to the original vectors in a least-squares sense, treating both vectors symmetrically. It uses the polar decomposition of a matrix, computed via Singular Value Decomposition (SVD).\n1. A $3 \\times 3$ matrix $A$ is constructed. Its first two columns are the normalized input vectors, $\\mathbf{a}_1 = \\mathbf{r}/\\|\\mathbf{r}\\|$ and $\\mathbf{a}_2 = \\mathbf{c}/\\|\\mathbf{c}\\|$. The third column is their cross product, $\\mathbf{a}_3 = \\mathbf{a}_1 \\times \\mathbf{a}_2$, to ensure the matrix is full-rank. $A = [\\mathbf{a}_1 \\ \\mathbf{a}_2 \\ \\mathbf{a}_3]$.\n2. The SVD of $A$ is computed: $A = U \\Sigma V^T$.\n3. The polar decomposition of $A$ is $A = QP$, where $Q = UV^T$ is the unique orthogonal matrix closest to $A$ in the Frobenius norm.\n4. The columns of $Q$ form the desired orthonormal basis. The new vectors are the first two columns of $Q$: $\\hat{\\mathbf{r}} = Q_1$ and $\\hat{\\mathbf{c}} = Q_2$.\n\n**Quantification of Deviation**\nFor each method, the angular change is computed as $\\theta_{\\mathbf{v}} = \\arccos\\left( \\frac{|\\mathbf{v} \\cdot \\hat{\\mathbfv}|}{\\|\\mathbf{v}\\|} \\right)$, converted to degrees.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are needed for this problem.\n\ndef reorthonormalize_gs(r_vec, c_vec):\n    \"\"\"\n    Reorthonormalizes two vectors using the Gram-Schmidt process.\n    The direction of the first vector r_vec is preserved.\n    \"\"\"\n    # Defensive copy to avoid modifying input arrays\n    r = np.copy(r_vec)\n    c = np.copy(c_vec)\n\n    # Normalize the first vector\n    r_norm = np.linalg.norm(r)\n    if r_norm  np.finfo(float).eps:\n        # Handle zero vector case, though not in test suite.\n        # A robust implementation might raise an error or return a default basis.\n        # For this problem, we assume non-zero inputs.\n        r_hat = r\n    else:    \n        r_hat = r / r_norm\n\n    # Project c onto r_hat and subtract to get the orthogonal component\n    c_prime = c - np.dot(c, r_hat) * r_hat\n\n    # Normalize the orthogonal component\n    c_prime_norm = np.linalg.norm(c_prime)\n    if c_prime_norm  np.finfo(float).eps:\n        # This occurs if r and c are collinear.\n        # A robust solution needs a strategy to pick a valid orthogonal vector.\n        # For this problem's test cases, this is not an issue.\n        # A simple fallback: create a vector orthogonal to r_hat.\n        # However, we follow the described algorithm strictly.\n        c_hat = c_prime\n    else:\n        c_hat = c_prime / c_prime_norm\n\n    return r_hat, c_hat\n\ndef reorthonormalize_svd(r_vec, c_vec):\n    \"\"\"\n    Reorthonormalizes two vectors using SVD-based polar decomposition.\n    \"\"\"\n    # Defensive copy\n    r = np.copy(r_vec)\n    c = np.copy(c_vec)\n    \n    # Normalize input vectors to form the first two columns of matrix A\n    r_norm = np.linalg.norm(r)\n    a1 = r / r_norm if r_norm > np.finfo(float).eps else r\n    \n    c_norm = np.linalg.norm(c)\n    a2 = c / c_norm if c_norm > np.finfo(float).eps else c\n\n    # Third column is the cross product to ensure a full-rank 3x3 matrix\n    a3 = np.cross(a1, a2)\n    \n    # Construct the matrix A\n    A = np.column_stack((a1, a2, a3))\n\n    # Compute SVD of A\n    U, s, Vh = np.linalg.svd(A)\n\n    # The orthogonal factor Q of the polar decomposition is U @ Vh\n    Q = U @ Vh\n\n    # The new orthonormal vectors are the first two columns of Q\n    r_hat = Q[:, 0]\n    c_hat = Q[:, 1]\n    \n    return r_hat, c_hat\n\ndef calculate_angle_change(v_orig, v_new):\n    \"\"\"\n    Calculates the angle in degrees between an original vector and its new version.\n    \"\"\"\n    v_orig_norm = np.linalg.norm(v_orig)\n    v_new_norm = np.linalg.norm(v_new)\n\n    # Handle potential zero vectors\n    if v_orig_norm  np.finfo(float).eps or v_new_norm  np.finfo(float).eps:\n        return 0.0\n\n    # Cosine of the angle, clipped for numerical stability of arccos\n    cos_theta = np.clip(np.abs(np.dot(v_orig, v_new)) / (v_orig_norm * v_new_norm), -1.0, 1.0)\n    \n    # Angle in radians\n    angle_rad = np.arccos(cos_theta)\n    \n    # Convert to degrees\n    return np.rad2deg(angle_rad)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (exactly orthonormal)\n        (np.array([1.0, 0.0, 0.0]), np.array([0.0, 1.0, 0.0])),\n        # Case 2 (small perturbations)\n        (np.array([0.999, 0.035, 0.002]), np.array([-0.035, 0.999, -0.004])),\n        # Case 3 (orthogonal, non-unit norm)\n        (np.array([0.7, 0.7, 0.0]), np.array([0.7, -0.7, 0.05])),\n        # Case 4 (near-collinear)\n        (np.array([1.0, 0.0, 0.0]), np.array([0.9999, 0.01, 0.0])),\n    ]\n\n    results = []\n    for r_orig, c_orig in test_cases:\n        # Gram-Schmidt Method\n        r_hat_gs, c_hat_gs = reorthonormalize_gs(r_orig, c_orig)\n        theta_r_gs = calculate_angle_change(r_orig, r_hat_gs)\n        theta_c_gs = calculate_angle_change(c_orig, c_hat_gs)\n        \n        # SVD Method\n        r_hat_svd, c_hat_svd = reorthonormalize_svd(r_orig, c_orig)\n        theta_r_svd = calculate_angle_change(r_orig, r_hat_svd)\n        theta_c_svd = calculate_angle_change(c_orig, c_hat_svd)\n        \n        # Append the quadruple of results\n        results.extend([\n            round(theta_r_gs, 6),\n            round(theta_c_gs, 6),\n            round(theta_r_svd, 6),\n            round(theta_c_svd, 6)\n        ])\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4894129"}, {"introduction": "A 3D medical image volume is often constructed by stacking a series of 2D slices. Ideally, the scanner moves perfectly perpendicular to the image plane between slices, but in practice, mechanical misalignments can cause \"gantry tilt,\" introducing a shear into the reconstructed volume. This exercise demonstrates how to diagnose and quantify this common artifact using the slice position and orientation metadata found in DICOM files. By applying vector projection, you will learn to decompose the inter-slice motion and compute a shear-corrected orientation matrix, a critical step for accurate 3D measurements and visualization. [@problem_id:4894114]", "problem": "You are to implement a complete, runnable program that detects gantry tilt in computed tomography (CT) using Digital Imaging and Communications in Medicine (DICOM) metadata and computes a shear-corrected orientation matrix to ensure reconstructed volumes have orthogonal slices. The program must produce results for a predefined test suite without requiring any external input.\n\nFundamental base and definitions to be used:\n- Digital Imaging and Communications in Medicine (DICOM) provides per-slice metadata including Image Orientation (Patient) and Image Position (Patient).\n- Let the Image Orientation (Patient) be given by two unit vectors: the row direction vector $r \\in \\mathbb{R}^3$ and the column direction vector $c \\in \\mathbb{R}^3$. The slice normal vector is $n = r \\times c$, where $\\times$ denotes the vector cross product.\n- Let the $k$-th slice’s Image Position (Patient) be $p_k \\in \\mathbb{R}^3$, and define the inter-slice translation vector $\\Delta p_k = p_{k+1} - p_k$ for consecutive slices.\n- Pixel Spacing is given by two positive real numbers: $\\Delta_r$ (row spacing, in mm) and $\\Delta_c$ (column spacing, in mm). All geometric quantities are in millimeters (mm).\n- The orthonormality of $r$ and $c$ implies $r \\cdot r = 1$, $c \\cdot c = 1$, and $r \\cdot c = 0$, where $\\cdot$ denotes the dot product.\n\nScientific rationale:\n- In the absence of gantry tilt, the inter-slice translation $\\Delta p_k$ has no in-plane components along $r$ or $c$, and lies purely along $n$, so $\\Delta p_k \\approx s_k n$ for some scalar $s_k \\in \\mathbb{R}$. With gantry tilt, $\\Delta p_k$ acquires in-plane components, i.e., it can be decomposed as $\\Delta p_k = a_k r + b_k c + s_k n$, where $a_k$ and $b_k$ are nonzero.\n- The tilt angle $\\theta$ can be quantified from the ratio of in-plane motion magnitude to through-plane motion magnitude. Define $a_k = \\Delta p_k \\cdot r$, $b_k = \\Delta p_k \\cdot c$, and $s_k = \\Delta p_k \\cdot n$. Robust summary values $a$, $b$, and $s$ are computed as the medians of $\\{a_k\\}$, $\\{b_k\\}$, and $\\{s_k\\}$ across slices. The in-plane magnitude is $m = \\sqrt{a^2 + b^2}$, and the tilt angle is $\\theta = \\arctan2(m, |s|)$.\n- The shear-corrected orientation matrix must preserve in-plane geometry and set the slice axis to the normal direction with spacing equal to the through-plane component magnitude. The $3 \\times 3$ orientation matrix $M$ (columns) is $M = [R \\; C \\; Z]$, where $R = r \\cdot \\Delta_c$, $C = c \\cdot \\Delta_r$, and $Z = n \\cdot |s|$.\n\nTask requirements:\n1. Implement a function that, given $r$, $c$, a list of slice positions $\\{p_k\\}$, and pixel spacings $(\\Delta_r, \\Delta_c)$:\n   - Computes $n = r \\times c$.\n   - Computes $\\Delta p_k = p_{k+1} - p_k$ for all consecutive slices.\n   - Computes $a_k = \\Delta p_k \\cdot r$, $b_k = \\Delta p_k \\cdot c$, and $s_k = \\Delta p_k \\cdot n$.\n   - Uses medians $a$, $b$, and $s$ across slices.\n   - Computes the tilt angle $\\theta = \\arctan2(\\sqrt{a^2 + b^2}, |s|)$ in degrees.\n   - Detects tilt if $\\theta \\ge \\theta_{\\text{thr}}$ with threshold $\\theta_{\\text{thr}} = 0.5$ degrees.\n   - Computes the shear-corrected orientation matrix $M = [r \\cdot \\Delta_c,\\; c \\cdot \\Delta_r,\\; n \\cdot |s|]$.\n2. Angles must be expressed in degrees. Distances must be in millimeters (mm). The tilt angle in the output must be rounded to six decimal places.\n\nTest suite:\nProvide the following test cases directly inside your program. For each case, the program must construct the list of slice positions $\\{p_k\\}$ using the specified $r$, $c$, $n$, an initial position $p_0$, a slice spacing $s$ along $n$, and any in-plane component that simulates tilt. Use $N$ slices indexed $k = 0, 1, \\dots, N-1$ with\n$$\np_k = p_0 + k \\, (s \\, n + t_r \\, r + t_c \\, c),\n$$\nwhere $t_r$ and $t_c$ are the per-slice in-plane shifts (in mm) along $r$ and $c$. If a case has no tilt, then $t_r = 0$ and $t_c = 0$. If a case specifies a tilt angle $\\theta$ about an in-plane axis, set the corresponding in-plane shift to $t = s \\, \\tan(\\theta)$ along that axis.\n\n- Case $1$ (happy path, no tilt):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.8$ mm, $\\Delta_c = 0.8$ mm, $s = 1.5$ mm, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = 0$.\n- Case $2$ (gantry tilt along $c$):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.7$ mm, $\\Delta_c = 0.7$ mm, $s = 1.2$ mm, $\\theta = 15$ degrees, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = s \\, \\tan(\\theta)$.\n- Case $3$ (gantry tilt along $r$):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.5$ mm, $\\Delta_c = 0.5$ mm, $s = 1.0$ mm, $\\theta = 10$ degrees, $p_0 = [0, 0, 0]$, $N = 6$, $t_r = s \\, \\tan(\\theta)$, $t_c = 0$.\n- Case $4$ (very small tilt below detection threshold):\n  - $r = [1, 0, 0]$, $c = [0, 1, 0]$, $\\Delta_r = 0.9$ mm, $\\Delta_c = 0.9$ mm, $s = 2.0$ mm, $\\theta = 0.2$ degrees, $p_0 = [0, 0, 0]$, $N = 5$, $t_r = 0$, $t_c = s \\, \\tan(\\theta)$.\n- Case $5$ (oblique orientation, no gantry tilt):\n  - $r = [1/\\sqrt{2}, 1/\\sqrt{2}, 0]$, $c = [0, 0, 1]$, $\\Delta_r = 1.0$ mm, $\\Delta_c = 1.0$ mm, $s = 1.0$ mm, $p_0 = [10, 20, 30]$, $N = 4$, $t_r = 0$, $t_c = 0$.\n\nOutput specification:\n- For each test case, output a three-element list: $[\\text{tilt\\_detected}, \\theta, \\text{flattened\\_matrix}]$, where $\\text{tilt\\_detected}$ is a boolean, $\\theta$ is the tilt angle in degrees rounded to six decimal places, and $\\text{flattened\\_matrix}$ is the shear-corrected $3 \\times 3$ orientation matrix $M$ flattened in column-major order as a list of $9$ floats rounded to six decimal places.\n- Your program should produce a single line of output containing the results for all test cases as a comma-separated list enclosed in square brackets, for example:\n$[[case1\\_result],[case2\\_result],...]$.\n\nAngle unit requirement:\n- Angles must be computed and printed in degrees.\n\nDistance unit requirement:\n- All lengths and spacings are in millimeters (mm).\n\nDesign constraints:\n- Use only linear algebra definitions (dot product, cross product), normalization, and vector decomposition; do not use any shortcut formulas beyond those defined.\n- Ensure numerical robustness by normalizing $r$ and $c$, re-orthogonalizing $c$ against $r$ if needed, and normalizing $n$.", "solution": "The solution implements an algorithm to detect gantry tilt and compute a shear-corrected orientation matrix from DICOM metadata. This process is founded on principles of vector algebra and coordinate transformations.\n\n**1. Coordinate System Normalization**\nA slice's geometry is defined by its row ($r$) and column ($c$) direction vectors. For robust calculations, these vectors must form an orthonormal basis with the slice normal ($n = r \\times c$). The implementation first enforces this by normalizing $r$, re-orthogonalizing $c$ against $r$ via the Gram-Schmidt process, and finally computing a unit normal vector $n$.\n\n**2. Analysis of Inter-Slice Motion**\nThe vector between consecutive slice positions, $\\Delta p_k = p_{k+1} - p_k$, describes the scanner's motion. In an ideal scan, this motion is purely along the slice normal $n$. With gantry tilt, $\\Delta p_k$ acquires in-plane components along $r$ and $c$. These components are calculated by projecting $\\Delta p_k$ onto the basis vectors:\n$$a_k = \\Delta p_k \\cdot r \\quad (\\text{in-plane, row direction})$$\n$$b_k = \\Delta p_k \\cdot c \\quad (\\text{in-plane, column direction})$$\n$$s_k = \\Delta p_k \\cdot n \\quad (\\text{through-plane})$$\n\n**3. Robust Tilt Quantification**\nTo get a stable measure for the whole series, the median of each component set ($\\{a_k\\}$, $\\{b_k\\}$, $\\{s_k\\}$) is taken, yielding $a$, $b$, and $s$. The magnitude of the average in-plane motion is $m = \\sqrt{a^2 + b^2}$. The tilt angle $\\theta$ is then the angle between the effective motion vector and the slice normal, computed as $\\theta = \\arctan2(m, |s|)$. Tilt is detected if $\\theta$ exceeds a threshold.\n\n**4. Shear-Corrected Orientation Matrix**\nA new orientation matrix $M$ is constructed to represent an orthogonal volume, removing the shear introduced by the tilt. Its columns define the voxel axes in patient coordinates, scaled by the appropriate spacing:\n- First column (X-axis of grid): $R = r \\cdot \\Delta_c$\n- Second column (Y-axis of grid): $C = c \\cdot \\Delta_r$\n- Third column (Z-axis of grid): $Z = n \\cdot |s|$\nThe resulting matrix $M = [R \\; C \\; Z]$ correctly describes the geometry of the unsheared volume.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef analyze_ct_series(r, c, slice_positions, delta_r, delta_c, theta_thr):\n    \"\"\"\n    Analyzes a series of CT slices to detect gantry tilt and compute a\n    shear-corrected orientation matrix.\n\n    Args:\n        r (np.ndarray): The row direction vector (3,).\n        c (np.ndarray): The column direction vector (3,).\n        slice_positions (list[np.ndarray]): A list of slice position vectors.\n        delta_r (float): The row pixel spacing (in-plane, along c).\n        delta_c (float): The column pixel spacing (in-plane, along r).\n        theta_thr (float): The tilt detection threshold in degrees.\n\n    Returns:\n        tuple: A tuple containing:\n            - bool: True if tilt is detected, False otherwise.\n            - float: The computed tilt angle in degrees.\n            - np.ndarray: The 3x3 shear-corrected orientation matrix.\n    \"\"\"\n    # 1. Ensure orthonormal basis {r, c, n} for robustness.\n    # Normalize r\n    r = r / np.linalg.norm(r)\n    # Re-orthogonalize c with respect to r (Gram-Schmidt) and normalize\n    c = c - np.dot(c, r) * r\n    c = c / np.linalg.norm(c)\n    # Compute the normal vector n\n    n = np.cross(r, c)\n    # n should be a unit vector, but normalize for safety\n    n = n / np.linalg.norm(n)\n\n    # 2. Compute inter-slice translation vectors\n    if len(slice_positions)  2:\n        # Not enough slices to compute motion, assume no tilt.\n        s_median = np.sqrt(delta_r**2 + delta_c**2) # A reasonable default\n        return False, 0.0, np.stack([r * delta_c, c * delta_r, n * s_median], axis=-1)\n\n    delta_p_list = [slice_positions[k + 1] - slice_positions[k] for k in range(len(slice_positions) - 1)]\n\n    # 3. Decompose inter-slice vectors into in-plane and through-plane components\n    a_k = [np.dot(dp, r) for dp in delta_p_list]\n    b_k = [np.dot(dp, c) for dp in delta_p_list]\n    s_k = [np.dot(dp, n) for dp in delta_p_list]\n\n    # 4. Use medians for robust estimation\n    a_median = np.median(a_k)\n    b_median = np.median(b_k)\n    s_median = np.median(s_k)\n\n    # 5. Compute tilt angle\n    in_plane_magnitude = np.sqrt(a_median**2 + b_median**2)\n    # arctan2(y, x) where y is in-plane and x is through-plane component\n    tilt_angle_rad = np.arctan2(in_plane_magnitude, np.abs(s_median))\n    tilt_angle_deg = np.rad2deg(tilt_angle_rad)\n\n    # 6. Detect tilt\n    is_tilted = tilt_angle_deg >= theta_thr\n\n    # 7. Compute the shear-corrected orientation matrix M = [R, C, Z]\n    # R = r * delta_c, C = c * delta_r, Z = n * |s_median|\n    R_col = r * delta_c\n    C_col = c * delta_r\n    Z_col = n * np.abs(s_median)\n    M = np.stack([R_col, C_col, Z_col], axis=-1)\n\n    return is_tilted, tilt_angle_deg, M\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Tilt detection threshold\n    theta_thr = 0.5  # degrees\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (happy path, no tilt)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.8, 'delta_c': 0.8, 's': 1.5, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.0, 'tilt_axis': None},\n        # Case 2 (gantry tilt along c)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.7, 'delta_c': 0.7, 's': 1.2, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 15.0, 'tilt_axis': 'c'},\n        # Case 3 (gantry tilt along r)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.5, 'delta_c': 0.5, 's': 1.0, 'p0': [0, 0, 0], 'N': 6, 'tilt_deg': 10.0, 'tilt_axis': 'r'},\n        # Case 4 (very small tilt below detection threshold)\n        {'r': [1, 0, 0], 'c': [0, 1, 0], 'delta_r': 0.9, 'delta_c': 0.9, 's': 2.0, 'p0': [0, 0, 0], 'N': 5, 'tilt_deg': 0.2, 'tilt_axis': 'c'},\n        # Case 5 (oblique orientation, no gantry tilt)\n        {'r': [1/np.sqrt(2), 1/np.sqrt(2), 0], 'c': [0, 0, 1], 'delta_r': 1.0, 'delta_c': 1.0, 's': 1.0, 'p0': [10, 20, 30], 'N': 4, 'tilt_deg': 0.0, 'tilt_axis': None},\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        # Prepare inputs for this test case\n        r_vec = np.array(case['r'], dtype=float)\n        c_vec = np.array(case['c'], dtype=float)\n        p0 = np.array(case['p0'], dtype=float)\n        s_spacing = case['s']\n        N = case['N']\n        delta_r = case['delta_r']\n        delta_c = case['delta_c']\n\n        # Normalize basis vectors for generating slice positions\n        r_norm = r_vec / np.linalg.norm(r_vec)\n        c_ortho = c_vec - np.dot(c_vec, r_norm) * r_norm\n        c_norm = c_ortho / np.linalg.norm(c_ortho)\n        n_norm = np.cross(r_norm, c_norm)\n\n        # Calculate in-plane shifts based on tilt angle\n        t_r, t_c = 0.0, 0.0\n        if case['tilt_axis']:\n            tilt_rad = np.deg2rad(case['tilt_deg'])\n            shift = s_spacing * np.tan(tilt_rad)\n            if case['tilt_axis'] == 'r':\n                t_r = shift\n            elif case['tilt_axis'] == 'c':\n                t_c = shift\n        \n        # Generate the list of slice positions\n        # p_k = p_0 + k * (s * n + t_r * r + t_c * c)\n        inter_slice_vec = s_spacing * n_norm + t_r * r_norm + t_c * c_norm\n        slice_positions = [p0 + k * inter_slice_vec for k in range(N)]\n\n        # Analyze the generated slice data\n        is_tilted, angle_deg, matrix = analyze_ct_series(\n            r_vec, c_vec, slice_positions, delta_r, delta_c, theta_thr\n        )\n        \n        # Format the results for this case\n        is_tilted_str = str(is_tilted).lower()\n        angle_str = f\"{angle_deg:.6f}\"\n        matrix_flat_col_major = matrix.flatten('F')\n        matrix_str = \"[\" + \",\".join(f\"{val:.6f}\" for val in matrix_flat_col_major) + \"]\"\n        case_result_str = f\"[{is_tilted_str},{angle_str},{matrix_str}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "4894114"}, {"introduction": "Aligning a patient's scan to a standard anatomical atlas or to their own previous scans is a cornerstone of modern medical image analysis. This exercise guides you through a classic and powerful method: landmark-based rigid registration. Using the coordinates of a few key anatomical landmarks, you will construct local coordinate frames and derive the unique rigid transformation—a combination of a rotation matrix and a translation vector—that aligns the patient's brain to a canonical atlas space. This practice provides direct experience with the mathematics underlying neuronavigation, change detection, and group-level statistical comparisons. [@problem_id:4894133]", "problem": "A brain Magnetic Resonance Imaging (MRI) volume is to be rigidly aligned to a canonical atlas frame defined by the anterior commissure (AC), posterior commissure (PC), and a superior mid-sagittal point. The atlas frame is constructed so that the AC is the origin, the AC–PC line defines the positive $y$-axis, the superior midline point defines the positive $z$-axis, and the resulting coordinate system is right-handed. In this canonical atlas frame, the landmarks are given by\n$\\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$ mm, $\\mathbf{a}_{\\mathrm{PC}} = (0, 25, 0)$ mm, and $\\mathbf{a}_{\\mathrm{MS}} = (0, 0, 30)$ mm.\nIn the patient MRI, the corresponding landmarks are measured at\n$\\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$ mm, $\\mathbf{p}_{\\mathrm{PC}} = (35, -5, 2)$ mm, and $\\mathbf{p}_{\\mathrm{MS}} = (10, 25, 2)$ mm.\nAssume the atlas and patient landmarks are non-collinear and define their respective local axes by straight-line connections of the landmarks as in standard neuroanatomical orientation: the AC–PC vector defines the $y$-axis, the AC–MS vector defines the $z$-axis, and the $x$-axis is chosen to complete a right-handed orthonormal triad via the vector cross product. Using only these definitions and the rigidity constraints of rotation and translation, derive the unique rigid transform $(\\mathbf{R}, \\mathbf{t})$ that maps the patient landmarks to the atlas landmarks, where $\\mathbf{R}$ is a $3 \\times 3$ rotation matrix and $\\mathbf{t}$ is a $3 \\times 1$ translation vector, and $\\mathbf{R}\\mathbf{p} + \\mathbf{t}$ maps patient coordinates $\\mathbf{p}$ into the atlas frame.\n\nFor quality control, a fourth anatomical point is identified in the atlas at $\\mathbf{a}_{4} = (12, 8, 15)$ mm. The corresponding patient measurement is $\\mathbf{p}_{4} = (18.6, 9.6, 14.3)$ mm. After applying the derived rigid transform to all four patient points, compute the root-mean-square (RMS) residual error across the four landmark correspondences,\n$$E_{\\mathrm{RMS}} = \\left( \\frac{\\sum_{i=1}^{4} \\|\\mathbf{R}\\mathbf{p}_{i} + \\mathbf{t} - \\mathbf{a}_{i}\\|^{2}}{4} \\right)^{1/2},$$\nwhere $\\|\\cdot\\|$ denotes the Euclidean norm, and $(\\mathbf{p}_{i}, \\mathbf{a}_{i})$ denote the patient–atlas landmark pairs for $\\mathrm{AC}$, $\\mathrm{PC}$, $\\mathrm{MS}$, and the fourth point. Round your final numerical answer for $E_{\\mathrm{RMS}}$ to four significant figures and express it in millimeters.", "solution": "The problem is to find a rigid transformation $(\\mathbf{R}, \\mathbf{t})$ that maps points from a patient's coordinate system to an atlas coordinate system. The transformation is defined by aligning three non-collinear landmarks. The solution involves three main steps: 1) constructing an orthonormal coordinate frame for both the patient and the atlas, 2) deriving the rotation matrix $\\mathbf{R}$ and translation vector $\\mathbf{t}$ that map one frame onto the other, and 3) calculating the RMS error to assess the quality of the fit.\n\n**1. Construct Coordinate Frames**\n\nA right-handed orthonormal coordinate frame is defined by an origin and three mutually perpendicular unit basis vectors.\n\n- **Atlas Frame:** The origin is $\\mathbf{O}_A = \\mathbf{a}_{\\mathrm{AC}} = (0, 0, 0)$.\n    - The $y$-axis is defined by the vector $\\mathbf{v}_{yA} = \\mathbf{a}_{\\mathrm{PC}} - \\mathbf{a}_{\\mathrm{AC}} = (0, 25, 0)$. Normalizing gives the unit vector $\\mathbf{u}_{yA} = (0, 1, 0)$.\n    - The $z$-axis is defined by $\\mathbf{v}_{zA} = \\mathbf{a}_{\\mathrm{MS}} - \\mathbf{a}_{\\mathrm{AC}} = (0, 0, 30)$. Normalizing gives the unit vector $\\mathbf{u}_{zA} = (0, 0, 1)$.\n    - The $x$-axis is the cross product: $\\mathbf{u}_{xA} = \\mathbf{u}_{yA} \\times \\mathbf{u}_{zA} = (1, 0, 0)$.\n    The resulting atlas basis matrix $\\mathbf{M}_A = [\\mathbf{u}_{xA} \\ \\mathbf{u}_{yA} \\ \\mathbf{u}_{zA}]$ is the identity matrix $\\mathbf{I}$.\n\n- **Patient Frame:** The origin is $\\mathbf{O}_P = \\mathbf{p}_{\\mathrm{AC}} = (10, -5, 2)$.\n    - The $y$-axis is defined by $\\mathbf{v}_{yP} = \\mathbf{p}_{\\mathrm{PC}} - \\mathbf{p}_{\\mathrm{AC}} = (25, 0, 0)$. The unit vector is $\\mathbf{u}_{yP} = (1, 0, 0)$.\n    - The $z$-axis is defined by $\\mathbf{v}_{zP} = \\mathbf{p}_{\\mathrm{MS}} - \\mathbf{p}_{\\mathrm{AC}} = (0, 30, 0)$. Since $\\mathbf{v}_{yP} \\cdot \\mathbf{v}_{zP} = 0$, the vectors are already orthogonal. The unit vector is $\\mathbf{u}_{zP} = (0, 1, 0)$.\n    - The $x$-axis is the cross product: $\\mathbf{u}_{xP} = \\mathbf{u}_{yP} \\times \\mathbf{u}_{zP} = (0, 0, 1)$.\n    The patient basis matrix is $\\mathbf{M}_P = [\\mathbf{u}_{xP} \\ \\mathbf{u}_{yP} \\ \\mathbf{u}_{zP}] = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}$.\n\n**2. Derive the Rigid Transformation**\n\nThe transformation from patient coordinates $\\mathbf{p}$ to atlas coordinates $\\mathbf{a}$ is $\\mathbf{a} = \\mathbf{R}\\mathbf{p} + \\mathbf{t}$.\n- The rotation matrix $\\mathbf{R}$ rotates the patient basis into the atlas basis: $\\mathbf{R} = \\mathbf{M}_A \\mathbf{M}_P^T$. As $\\mathbf{M}_A = \\mathbf{I}$, this simplifies to $\\mathbf{R} = \\mathbf{M}_P^T$.\n$$ \\mathbf{R} = \\begin{pmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 1  0  0 \\end{pmatrix}^T = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} $$\n- The translation vector $\\mathbf{t}$ aligns the origins after rotation: $\\mathbf{t} = \\mathbf{O}_A - \\mathbf{R}\\mathbf{O}_P$.\n$$ \\mathbf{t} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 10 \\\\ -5 \\\\ 2 \\end{pmatrix} = - \\begin{pmatrix} 2 \\\\ 10 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} $$\n\n**3. Compute RMS Error**\n\nThe RMS error is calculated over all four landmark pairs. Since the transformation was derived from the first three landmarks, their residual error is $0$. We only need to compute the error for the fourth point: $\\mathbf{p}_4 = (18.6, 9.6, 14.3)$ and $\\mathbf{a}_4 = (12, 8, 15)$.\n- Transform $\\mathbf{p}_4$: $\\mathbf{a}'_4 = \\mathbf{R}\\mathbf{p}_4 + \\mathbf{t} = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 18.6 \\\\ 9.6 \\\\ 14.3 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 14.3 \\\\ 18.6 \\\\ 9.6 \\end{pmatrix} + \\begin{pmatrix} -2 \\\\ -10 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} 12.3 \\\\ 8.6 \\\\ 14.6 \\end{pmatrix}$.\n- The squared error is $\\|\\mathbf{a}'_4 - \\mathbf{a}_4\\|^2 = \\|(12.3-12, 8.6-8, 14.6-15)\\|^2 = \\|(0.3, 0.6, -0.4)\\|^2 = (0.3)^2 + (0.6)^2 + (-0.4)^2 = 0.61$.\n- The RMS error is $E_{\\mathrm{RMS}} = \\sqrt{\\frac{0 + 0 + 0 + 0.61}{4}} = \\sqrt{0.1525} \\approx 0.3905$.", "answer": "$$\\boxed{0.3905}$$", "id": "4894133"}]}