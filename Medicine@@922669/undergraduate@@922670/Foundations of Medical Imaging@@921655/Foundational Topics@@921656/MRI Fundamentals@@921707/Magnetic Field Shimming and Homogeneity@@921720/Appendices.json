{"hands_on_practices": [{"introduction": "The cornerstone of MRI is the Larmor equation, which establishes a direct link between a nucleus's resonance frequency and the local magnetic field strength. In an ideal scanner, this field is perfectly uniform, but in reality, imperfections create small spatial variations. This first practice explores the direct consequence of these imperfections, asking you to quantify the relationship between magnetic field inhomogeneity, $\\Delta B$, and the resulting spread of resonance frequencies, $\\Delta f$ [@problem_id:4898475]. Mastering this calculation provides a tangible understanding of why even tiny field variations, often measured in parts per million (ppm), can lead to significant frequency shifts that degrade image quality.", "problem": "In Magnetic Resonance Imaging (MRI), the local resonance frequency of nuclear spins is determined by the Larmor relationship between angular frequency and magnetic field. Consider a scanner with nominal static field $B_0$ and small spatial deviations $\\Delta B(\\mathbf{r})$ around $B_0$ due to imperfect homogeneity. Assume the spins are hydrogen protons, with gyromagnetic ratio $\\gamma$, and recall that the ordinary frequency is related to the angular frequency by division by $2\\pi$. \n\n(a) Starting from the Larmor angular frequency relation, derive an expression for the local resonance frequency offset $\\Delta f(\\mathbf{r})$ in terms of $\\Delta B(\\mathbf{r})$ and fundamental constants.\n\n(b) Magnetic field inhomogeneity is often specified in parts per million (ppm) relative to $B_0$. If the inhomogeneity is bounded by $\\pm p$ ppm, express the maximum magnitude of the frequency offset and the corresponding peak-to-peak frequency spread across the object in terms of $p$, $B_0$, and physical constants.\n\n(c) For a $B_0 = 3 \\ \\mathrm{T}$ scanner with hydrogen nuclei (so that $\\gamma / (2\\pi) \\approx 42.58 \\ \\mathrm{MHz/T}$), and a field inhomogeneity of $\\pm 2$ parts per million (ppm), compute the peak-to-peak frequency spread. Express your final answer in $\\mathrm{Hz}$ and round your final answer to four significant figures.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It is based on the fundamental principles of nuclear magnetic resonance and uses standard terminology and realistic physical parameters. Therefore, the problem is deemed valid and a full solution is warranted.\n\nThe solution is developed in three parts as requested.\n\n(a) Derivation of the local resonance frequency offset $\\Delta f(\\mathbf{r})$\n\nThe Larmor relationship describes the angular frequency of precession, $\\omega$, of a nuclear spin with gyromagnetic ratio $\\gamma$ in a magnetic field of strength $B$. The relationship is:\n$$ \\omega = \\gamma B $$\nIn an MRI scanner, the total magnetic field at a spatial location $\\mathbf{r}$ is the sum of the nominal static field $B_0$ and a small, position-dependent deviation $\\Delta B(\\mathbf{r})$:\n$$ B(\\mathbf{r}) = B_0 + \\Delta B(\\mathbf{r}) $$\nConsequently, the local Larmor angular frequency also becomes position-dependent:\n$$ \\omega(\\mathbf{r}) = \\gamma B(\\mathbf{r}) = \\gamma (B_0 + \\Delta B(\\mathbf{r})) $$\nExpanding this expression gives:\n$$ \\omega(\\mathbf{r}) = \\gamma B_0 + \\gamma \\Delta B(\\mathbf{r}) $$\nWe can identify the nominal angular frequency, $\\omega_0$, corresponding to the static field $B_0$, as $\\omega_0 = \\gamma B_0$. The local angular frequency offset, $\\Delta \\omega(\\mathbf{r})$, is the difference between the local frequency and the nominal frequency:\n$$ \\Delta \\omega(\\mathbf{r}) = \\omega(\\mathbf{r}) - \\omega_0 = (\\gamma B_0 + \\gamma \\Delta B(\\mathbf{r})) - \\gamma B_0 = \\gamma \\Delta B(\\mathbf{r}) $$\nThe problem asks for the offset in ordinary frequency, $f$, which is related to angular frequency by $f = \\omega / (2\\pi)$. The frequency offset in Hertz, $\\Delta f(\\mathbf{r})$, is therefore:\n$$ \\Delta f(\\mathbf{r}) = \\frac{\\Delta \\omega(\\mathbf{r})}{2\\pi} $$\nSubstituting the expression for $\\Delta \\omega(\\mathbf{r})$ yields the desired relationship:\n$$ \\Delta f(\\mathbf{r}) = \\frac{\\gamma}{2\\pi} \\Delta B(\\mathbf{r}) $$\n\n(b) Frequency offset expressions based on inhomogeneity in ppm\n\nMagnetic field inhomogeneity is often specified in parts per million (ppm) relative to the main field $B_0$. An inhomogeneity bounded by $\\pm p$ ppm means that the magnitude of the field deviation, $|\\Delta B(\\mathbf{r})|$, does not exceed $p$ millionths of $B_0$. Mathematically:\n$$ |\\Delta B(\\mathbf{r})| \\leq \\frac{p}{10^6} B_0 = p \\times 10^{-6} B_0 $$\nThe maximum magnitude of the frequency offset, $|\\Delta f(\\mathbf{r})|_{\\max}$, can be found using the result from part (a):\n$$ |\\Delta f(\\mathbf{r})|_{\\max} = \\left| \\frac{\\gamma}{2\\pi} \\Delta B(\\mathbf{r}) \\right|_{\\max} = \\frac{\\gamma}{2\\pi} |\\Delta B(\\mathbf{r})|_{\\max} $$\nSubstituting the maximum field deviation, we get:\n$$ |\\Delta f(\\mathbf{r})|_{\\max} = \\frac{\\gamma}{2\\pi} (p \\times 10^{-6} B_0) $$\nThe peak-to-peak frequency spread, $\\Delta f_{\\text{p-p}}$, is the total range of frequency offsets across the object. Since the field deviation $\\Delta B(\\mathbf{r})$ spans the range from a minimum of $-p \\times 10^{-6} B_0$ to a maximum of $+p \\times 10^{-6} B_0$, the frequency offset $\\Delta f(\\mathbf{r})$ spans a corresponding range.\nThe maximum frequency offset is:\n$$ \\Delta f_{\\max} = \\frac{\\gamma}{2\\pi} (p \\times 10^{-6} B_0) $$\nThe minimum frequency offset is:\n$$ \\Delta f_{\\min} = \\frac{\\gamma}{2\\pi} (-p \\times 10^{-6} B_0) = - \\frac{\\gamma}{2\\pi} (p \\times 10^{-6} B_0) $$\nThe peak-to-peak spread is the difference between these extreme values:\n$$ \\Delta f_{\\text{p-p}} = \\Delta f_{\\max} - \\Delta f_{\\min} = \\left(\\frac{\\gamma}{2\\pi} p \\times 10^{-6} B_0\\right) - \\left(-\\frac{\\gamma}{2\\pi} p \\times 10^{-6} B_0\\right) $$\n$$ \\Delta f_{\\text{p-p}} = 2 \\left( \\frac{\\gamma}{2\\pi} \\right) p \\times 10^{-6} B_0 $$\n\n(c) Numerical calculation of the peak-to-peak frequency spread\n\nWe are given the following values:\n- Main magnetic field: $B_0 = 3 \\ \\mathrm{T}$\n- Modified gyromagnetic ratio for hydrogen: $\\frac{\\gamma}{2\\pi} \\approx 42.58 \\ \\mathrm{MHz/T} = 42.58 \\times 10^6 \\ \\mathrm{Hz/T}$\n- Inhomogeneity bound: $p = 2$ (for $\\pm 2$ ppm)\n\nWe use the expression for the peak-to-peak frequency spread derived in part (b):\n$$ \\Delta f_{\\text{p-p}} = 2 \\left( \\frac{\\gamma}{2\\pi} \\right) p \\times 10^{-6} B_0 $$\nSubstituting the numerical values:\n$$ \\Delta f_{\\text{p-p}} = 2 \\times (42.58 \\times 10^6 \\ \\mathrm{Hz/T}) \\times 2 \\times 10^{-6} \\times (3 \\ \\mathrm{T}) $$\nThe terms involving powers of $10$ cancel each other out ($10^6 \\times 10^{-6} = 10^0 = 1$). The units of Tesla ($\\mathrm{T}$) and per-Tesla ($\\mathrm{T}^{-1}$) also cancel, leaving the result in Hertz ($\\mathrm{Hz}$), as expected.\n$$ \\Delta f_{\\text{p-p}} = (2 \\times 42.58 \\times 2 \\times 3) \\ \\mathrm{Hz} $$\n$$ \\Delta f_{\\text{p-p}} = 12 \\times 42.58 \\ \\mathrm{Hz} $$\n$$ \\Delta f_{\\text{p-p}} = 510.96 \\ \\mathrm{Hz} $$\nThe problem requires the final answer to be rounded to four significant figures. The fifth significant digit is $6$, so we round up the fourth significant digit ($9$).\n$$ \\Delta f_{\\text{p-p}} \\approx 511.0 \\ \\mathrm{Hz} $$", "answer": "$$\n\\boxed{511.0}\n$$", "id": "4898475"}, {"introduction": "Once field inhomogeneity is known, we use active shimming—adjusting currents in specialized coils—to counteract it. Since the fields from different shim coils add up linearly, we can model this correction as a linear algebra problem. This exercise introduces the fundamental mathematical framework for active shimming: the linear least-squares problem, which seeks the combination of coil fields that best cancels the measured inhomogeneity [@problem_id:4898415]. By setting up and solving the normal equations, you will learn how to calculate the optimal shim coil currents to achieve the most homogeneous field possible, and the geometric interpretation of the solution provides deep insight into the nature of this optimization.", "problem": "Magnetic Resonance Imaging (MRI) systems rely on a highly homogeneous static magnetic field to ensure accurate spatial encoding. Residual inhomogeneities are compensated using a set of shim coils whose fields superpose linearly. Consider a calibration in which the shim coil basis fields have been sampled at four spatial locations. Let the $4 \\times 3$ matrix $\\mathbf{A}$ encode the field at each location produced by $1$ ampere in each of the three shim coils, and let $\\mathbf{b}$ denote the desired shim field at those locations (for example, the negative of the measured inhomogeneity). The forward model is linear: the shim field produced by coil currents $\\mathbf{i} \\in \\mathbb{R}^{3}$ is $\\mathbf{A}\\mathbf{i}$.\n\nStarting from the principle of linear superposition and the least-squares criterion, formulate the optimization problem that determines $\\mathbf{i}$ to best match $\\mathbf{b}$ in the sense of minimizing the squared Euclidean norm of the mismatch. Then, derive the necessary optimality condition by setting the gradient of the objective to zero, and interpret the resulting condition physically in terms of orthogonality of the residual to the span of the coil basis fields.\n\nFinally, for the numerically specified calibration below, compute the optimal coil currents. Use the following matrix and vector (entries are in microtesla per ampere for $\\mathbf{A}$ and microtesla for $\\mathbf{b}$):\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n1.0 & 0.0 & 1.0 \\\\\n0.0 & 1.0 & 1.0 \\\\\n1.0 & 0.0 & -1.0 \\\\\n0.0 & 1.0 & -1.0\n\\end{pmatrix},\n\\qquad\n\\mathbf{b} =\n\\begin{pmatrix}\n1.2 \\\\\n-0.8 \\\\\n0.5 \\\\\n1.1\n\\end{pmatrix}.\n$$\nCompute the optimal $\\mathbf{i}$ and report it as a row matrix in the order of coils $1$, $2$, $3$. Express the currents in amperes and round each entry to three significant figures.", "solution": "The problem statement is scientifically grounded, self-contained, and well-posed. It describes a standard linear least-squares problem, which is a fundamental technique used for B0 magnetic field shimming in Magnetic Resonance Imaging. All data and conditions are provided, and they are physically and mathematically consistent. Therefore, the problem is valid and we may proceed with the solution.\n\nThe problem is to find the vector of shim coil currents, $\\mathbf{i} \\in \\mathbb{R}^{3}$, that generates a magnetic field, $\\mathbf{A}\\mathbf{i}$, which best approximates the desired target field, $\\mathbf{b} \\in \\mathbb{R}^{4}$, at four specified spatial locations. The principle of linear superposition states that the total field generated by the coils is a linear combination of the individual coil fields, which is precisely what the matrix-vector product $\\mathbf{A}\\mathbf{i}$ represents. The matrix $\\mathbf{A}$ has columns that are the basis fields for each coil, and $\\mathbf{i}$ contains the weights (currents) for the linear combination.\n\nWe are asked to find the \"best\" approximation in the sense of the least-squares criterion. This means we must minimize the squared Euclidean norm of the residual vector, $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\mathbf{i}$. The objective function to be minimized is $J(\\mathbf{i})$:\n$$\nJ(\\mathbf{i}) = \\|\\mathbf{b} - \\mathbf{A}\\mathbf{i}\\|_2^2\n$$\nThis can be expressed using the dot product, which in matrix notation is a transpose:\n$$\nJ(\\mathbf{i}) = (\\mathbf{b} - \\mathbf{A}\\mathbf{i})^T (\\mathbf{b} - \\mathbf{A}\\mathbf{i})\n$$\nExpanding this expression, we get:\n$$\nJ(\\mathbf{i}) = (\\mathbf{b}^T - (\\mathbf{A}\\mathbf{i})^T)(\\mathbf{b} - \\mathbf{A}\\mathbf{i}) = (\\mathbf{b}^T - \\mathbf{i}^T\\mathbf{A}^T)(\\mathbf{b} - \\mathbf{A}\\mathbf{i})\n$$\n$$\nJ(\\mathbf{i}) = \\mathbf{b}^T\\mathbf{b} - \\mathbf{b}^T\\mathbf{A}\\mathbf{i} - \\mathbf{i}^T\\mathbf{A}^T\\mathbf{b} + \\mathbf{i}^T\\mathbf{A}^T\\mathbf{A}\\mathbf{i}\n$$\nSince $\\mathbf{b}^T\\mathbf{A}\\mathbf{i}$ is a scalar, it is equal to its transpose, $(\\mathbf{b}^T\\mathbf{A}\\mathbf{i})^T = \\mathbf{i}^T\\mathbf{A}^T\\mathbf{b}$. Thus, the two middle terms are identical. The objective function simplifies to:\n$$\nJ(\\mathbf{i}) = \\mathbf{i}^T(\\mathbf{A}^T\\mathbf{A})\\mathbf{i} - 2\\mathbf{b}^T\\mathbf{A}\\mathbf{i} + \\mathbf{b}^T\\mathbf{b}\n$$\nThis is the formal optimization problem. To find the optimal current vector $\\mathbf{i}$ that minimizes $J(\\mathbf{i})$, we must find the point where the gradient of $J(\\mathbf{i})$ with respect to $\\mathbf{i}$ is the zero vector.\n$$\n\\nabla_{\\mathbf{i}} J(\\mathbf{i}) = \\mathbf{0}\n$$\nWe compute the gradient term by term using standard matrix calculus identities. The term $\\mathbf{b}^T\\mathbf{b}$ is constant with respect to $\\mathbf{i}$, so its gradient is zero. For the linear term, $\\nabla_{\\mathbf{i}}(-2\\mathbf{b}^T\\mathbf{A}\\mathbf{i}) = -2(\\mathbf{b}^T\\mathbf{A})^T = -2\\mathbf{A}^T\\mathbf{b}$. For the quadratic term, $\\mathbf{A}^T\\mathbf{A}$ is a symmetric matrix, so $\\nabla_{\\mathbf{i}}(\\mathbf{i}^T(\\mathbf{A}^T\\mathbf{A})\\mathbf{i}) = 2(\\mathbf{A}^T\\mathbf{A})\\mathbf{i}$. Combining these results, the gradient is:\n$$\n\\nabla_{\\mathbf{i}} J(\\mathbf{i}) = 2\\mathbf{A}^T\\mathbf{A}\\mathbf{i} - 2\\mathbf{A}^T\\mathbf{b}\n$$\nSetting the gradient to zero gives the necessary optimality condition:\n$$\n2\\mathbf{A}^T\\mathbf{A}\\mathbf{i} - 2\\mathbf{A}^T\\mathbf{b} = \\mathbf{0} \\implies \\mathbf{A}^T\\mathbf{A}\\mathbf{i} = \\mathbf{A}^T\\mathbf{b}\n$$\nThis system of linear equations is known as the normal equations.\n\nFor the physical interpretation, we can rewrite the normal equations as:\n$$\n\\mathbf{A}^T(\\mathbf{b} - \\mathbf{A}\\mathbf{i}) = \\mathbf{0}\n$$\nThe vector $\\mathbf{A}\\mathbf{i}$ is the best approximation of $\\mathbf{b}$ that lies in the column space of $\\mathbf{A}$, which is the subspace spanned by the coil basis fields. The vector $\\mathbf{r} = \\mathbf{b} - \\mathbf{A}\\mathbf{i}$ is the residual, or error, of this approximation. The matrix $\\mathbf{A}^T$ has rows that are the transposes of the columns of $\\mathbf{A}$ (the coil basis fields). The condition $\\mathbf{A}^T\\mathbf{r} = \\mathbf{0}$ means that the dot product of each column of $\\mathbf{A}$ with the residual vector $\\mathbf{r}$ is zero. In other words, the residual vector $\\mathbf{r}$ is orthogonal to every one of the coil basis fields. This implies that the residual vector is orthogonal to the entire subspace spanned by the coil basis fields, $\\text{Col}(\\mathbf{A})$. Geometrically, a least-squares solution is achieved when the error vector is perpendicular to the subspace onto which we are projecting.\n\nNow, we compute the optimal currents for the given numerical values.\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n1.0 & 0.0 & 1.0 \\\\\n0.0 & 1.0 & 1.0 \\\\\n1.0 & 0.0 & -1.0 \\\\\n0.0 & 1.0 & -1.0\n\\end{pmatrix},\n\\qquad\n\\mathbf{b} =\n\\begin{pmatrix}\n1.2 \\\\\n-0.8 \\\\\n0.5 \\\\\n1.1\n\\end{pmatrix}\n$$\nFirst, we compute $\\mathbf{A}^T\\mathbf{A}$:\n$$\n\\mathbf{A}^T\\mathbf{A} =\n\\begin{pmatrix}\n1.0 & 0.0 & 1.0 & 0.0 \\\\\n0.0 & 1.0 & 0.0 & 1.0 \\\\\n1.0 & 1.0 & -1.0 & -1.0\n\\end{pmatrix}\n\\begin{pmatrix}\n1.0 & 0.0 & 1.0 \\\\\n0.0 & 1.0 & 1.0 \\\\\n1.0 & 0.0 & -1.0 \\\\\n0.0 & 1.0 & -1.0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n2.0 & 0.0 & 0.0 \\\\\n0.0 & 2.0 & 0.0 \\\\\n0.0 & 0.0 & 4.0\n\\end{pmatrix}\n$$\nThe matrix $\\mathbf{A}^T\\mathbf{A}$ is diagonal, which indicates that the columns of $\\mathbf{A}$ are an orthogonal basis. This simplifies the solution significantly.\nNext, we compute $\\mathbf{A}^T\\mathbf{b}$:\n$$\n\\mathbf{A}^T\\mathbf{b} =\n\\begin{pmatrix}\n1.0 & 0.0 & 1.0 & 0.0 \\\\\n0.0 & 1.0 & 0.0 & 1.0 \\\\\n1.0 & 1.0 & -1.0 & -1.0\n\\end{pmatrix}\n\\begin{pmatrix}\n1.2 \\\\\n-0.8 \\\\\n0.5 \\\\\n1.1\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1.0(1.2) + 0.0(-0.8) + 1.0(0.5) + 0.0(1.1) \\\\\n0.0(1.2) + 1.0(-0.8) + 0.0(0.5) + 1.0(1.1) \\\\\n1.0(1.2) + 1.0(-0.8) - 1.0(0.5) - 1.0(1.1)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1.7 \\\\\n0.3 \\\\\n-1.2\n\\end{pmatrix}\n$$\nNow we solve the normal equations $\\mathbf{A}^T\\mathbf{A}\\mathbf{i} = \\mathbf{A}^T\\mathbf{b}$:\n$$\n\\begin{pmatrix}\n2.0 & 0.0 & 0.0 \\\\\n0.0 & 2.0 & 0.0 \\\\\n0.0 & 0.0 & 4.0\n\\end{pmatrix}\n\\begin{pmatrix}\ni_1 \\\\\ni_2 \\\\\ni_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1.7 \\\\\n0.3 \\\\\n-1.2\n\\end{pmatrix}\n$$\nThis yields a system of uncoupled equations:\n$2.0 i_1 = 1.7 \\implies i_1 = \\frac{1.7}{2.0} = 0.85$\n$2.0 i_2 = 0.3 \\implies i_2 = \\frac{0.3}{2.0} = 0.15$\n$4.0 i_3 = -1.2 \\implies i_3 = \\frac{-1.2}{4.0} = -0.3$\nThe optimal current vector is $\\mathbf{i} = [0.85, 0.15, -0.3]^T$ amperes. The problem requires rounding each entry to three significant figures.\n$i_1 = 0.850$ A\n$i_2 = 0.150$ A\n$i_3 = -0.300$ A\nThe final answer is reported as a row matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.850 & 0.150 & -0.300\n\\end{pmatrix}\n}\n$$", "id": "4898415"}, {"introduction": "An ideal least-squares solution might demand impractically large currents or create new, sharp field variations. Real-world engineering requires balancing competing objectives, which we can achieve by extending the least-squares framework with regularization to penalize undesirable outcomes. This advanced coding practice challenges you to implement a regularized shimming algorithm that includes penalties for both power consumption and spatial roughness of the corrected field [@problem_id:4898468]. By adjusting the regularization parameters, you will directly explore the critical trade-offs between achieving perfect homogeneity, managing hardware stress, and ensuring the final field remains smooth, bridging the gap between idealized theory and practical engineering design.", "problem": "You are given a two-dimensional region representing a cross-sectional slice of a uniform static main magnetic field in Magnetic Resonance Imaging (MRI). Magnetic field shimming aims to reduce spatial inhomogeneity by superimposing fields from dedicated shim coils. Assume the following context and definitions are valid:\n\n- Fundamental base:\n  - The magnetic field in magnetostatics satisfies $\\nabla \\cdot \\mathbf{B} = 0$ and superposition of fields from independent sources is valid. The total field produced by multiple shim coils is the linear sum of each coil’s contribution.\n  - The resistive power dissipated in a coil is $P_k = R_k i_k^2$, where $R_k$ is the coil resistance and $i_k$ is the coil current.\n  - Spatial roughness can be characterized by the mean of the squared magnitude of the field gradient, $\\langle \\|\\nabla B\\|^2 \\rangle$, discretized using finite differences.\n\n- Region and discretization:\n  - Consider a square region of side length $0.2$ meters centered at the origin, discretized into a uniform grid of $21 \\times 21$ sample points with spacing $\\Delta x = \\Delta y$ in meters. Coordinates are $(x_i, y_j)$ with $x_i, y_j \\in [-0.1, 0.1]$ meters.\n\n- Baseline field and target:\n  - The baseline main field is $B_{\\mathrm{ref}} = 3.0$ Tesla.\n  - The baseline spatial inhomogeneity is modeled as\n    $$\\Delta B(x, y) = 0.002\\,x - 0.002\\,y + 0.0005\\,(x^2 - y^2),$$\n    producing the baseline field\n    $$B_0(x, y) = B_{\\mathrm{ref}} + \\Delta B(x, y).$$\n  - The desired target field is spatially uniform:\n    $$B_{\\mathrm{t}}(x, y) = B_{\\mathrm{ref}}.$$\n\n- Shim coil basis fields and hardware:\n  - There are four shim coils with basis fields per unit current:\n    1. Uniform adjustment: $b_0(x,y) = 0.01$ Tesla/Ampere.\n    2. Linear $x$-gradient: $b_x(x,y) = 0.02\\,x$ Tesla/(meter·Ampere).\n    3. Linear $y$-gradient: $b_y(x,y) = 0.02\\,y$ Tesla/(meter·Ampere).\n    4. Second-order $(x^2 - y^2)$: $b_q(x,y) = 0.002\\,(x^2 - y^2)$ Tesla/(meter$^2$·Ampere).\n  - Coil resistances are $R_0 = 1.5$ Ohm, $R_x = 2.0$ Ohm, $R_y = 2.0$ Ohm, $R_q = 2.5$ Ohm.\n\n- Model:\n  - Let $\\mathbf{f} = \\mathrm{vec}(B_0)$ be the flattened baseline field over all grid points, $\\mathbf{t} = \\mathrm{vec}(B_{\\mathrm{t}})$ the flattened target field, and $A \\in \\mathbb{R}^{N \\times 4}$ the design matrix whose $k$-th column is $\\mathrm{vec}(b_k)$ sampled at the grid points for $k \\in \\{0, x, y, q\\}$, with $N = 21 \\times 21$.\n  - The synthesized field is $\\mathbf{s}(\\mathbf{i}) = \\mathbf{f} + A \\mathbf{i}$ with $\\mathbf{i} \\in \\mathbb{R}^4$ the vector of coil currents in Ampere.\n  - The homogeneity cost is the squared deviation $\\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2$.\n  - The power penalty is $\\sum_k R_k i_k^2$ in Watts.\n  - The spatial roughness penalty is the sum of squared finite-difference gradients of $\\mathbf{s}(\\mathbf{i})$, using forward differences along $x$ and $y$ divided by $\\Delta x$ and $\\Delta y$, respectively. Let $D_x$ and $D_y$ denote these discrete derivative operators applied to a field over the grid. The roughness metric is proportional to $\\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2$.\n\n- Composite objective and parameters:\n  - Consider the composite objective\n    $$J(\\mathbf{i}) = \\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2 + \\lambda_p \\sum_k R_k i_k^2 + \\lambda_r \\left(\\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2\\right),$$\n    where $\\lambda_p \\ge 0$ is the power regularization weight and $\\lambda_r \\ge 0$ is the roughness regularization weight.\n\nYour tasks:\n\n1. From first principles and the definitions above, derive the normal equations that minimize $J(\\mathbf{i})$ with respect to $\\mathbf{i}$, expressed entirely in terms of $A$, $\\mathbf{f}$, $\\mathbf{t}$, $R = \\mathrm{diag}(R_0, R_x, R_y, R_q)$, and the discrete derivative operators $D_x$ and $D_y$. Do not jump directly to any memorized formula; show the logical steps starting from the definitions.\n2. Implement a program that:\n   - Constructs the grid and all fields.\n   - Forms $A$, $\\mathbf{f}$, and $\\mathbf{t}$ from the provided basis and baseline definitions.\n   - Implements $D_x$ and $D_y$ via forward finite differences with spacing $\\Delta x$ and $\\Delta y$.\n   - Solves for $\\mathbf{i}$ by solving the linear system implied by the normal equations for each provided test case.\n   - Computes and reports the following metrics for the synthesized field $\\mathbf{s}(\\mathbf{i})$:\n     - The root-mean-square (RMS) deviation $\\sqrt{\\frac{1}{N}\\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2}$ in Tesla, rounded to six decimal places.\n     - The total power $\\sum_k R_k i_k^2$ in Watts, rounded to six decimal places.\n     - The mean squared gradient $\\frac{1}{M}\\left(\\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2\\right)$ in Tesla$^2$/meter$^2$, where $M$ is the total number of finite-difference samples (sum of the sizes of $D_x$ and $D_y$ outputs), rounded to six decimal places.\n\n3. Analyze, in comments within the code, how increasing $\\lambda_p$ and $\\lambda_r$ affects the trade-offs among homogeneity, hardware stress (power), and spatial roughness, based on the outputs of the test suite.\n\nTest suite:\n- Use the following four $(\\lambda_p, \\lambda_r)$ pairs:\n  1. $(0.0, 0.0)$\n  2. $(5.0, 0.0)$\n  3. $(0.0, 0.1)$\n  4. $(5.0, 0.2)$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be flattened in the order of test cases, with each test case contributing three floats in the order [RMS deviation in Tesla, total power in Watts, mean squared gradient in Tesla$^2$/meter$^2$]. For example, the output format is\n  $$[\\text{rms}_1, \\text{power}_1, \\text{rough}_1, \\text{rms}_2, \\text{power}_2, \\text{rough}_2, \\ldots],$$\n  with each float rounded to six decimal places as specified.\n\nPhysical units:\n- Express the RMS deviation in Tesla, the total power in Watts, and the mean squared gradient in Tesla$^2$/meter$^2$, all rounded to six decimal places as required.", "solution": "We begin with magnetostatic superposition and quadratic optimization. The field at the grid points due to the baseline and shim coils is modeled as $\\mathbf{s}(\\mathbf{i}) = \\mathbf{f} + A \\mathbf{i}$, where $\\mathbf{f} \\in \\mathbb{R}^N$ is the flattened baseline field, $A \\in \\mathbb{R}^{N \\times 4}$ is the design matrix stacking the basis fields for the four shim coils, and $\\mathbf{i} \\in \\mathbb{R}^4$ is the vector of coil currents. The target field is $\\mathbf{t} \\in \\mathbb{R}^N$.\n\nThe objective combines homogeneity, power, and roughness:\n$$\nJ(\\mathbf{i}) = \\underbrace{\\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2}_{\\text{homogeneity}} + \\underbrace{\\lambda_p \\sum_k R_k i_k^2}_{\\text{power}} + \\underbrace{\\lambda_r \\left(\\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2\\right)}_{\\text{roughness}}.\n$$\nWe treat the discrete derivative operators $D_x$ and $D_y$ as linear maps from $\\mathbb{R}^N$ to $\\mathbb{R}^{M_x}$ and $\\mathbb{R}^{M_y}$, respectively, where $M_x = (n_x - 1) n_y$ and $M_y = n_x (n_y - 1)$ for an $n_x \\times n_y$ grid. They implement forward differences divided by $\\Delta x$ or $\\Delta y$:\n$$\n(D_x \\mathbf{u})_{(i,j)} = \\frac{u_{i+1,j} - u_{i,j}}{\\Delta x}, \\quad (D_y \\mathbf{u})_{(i,j)} = \\frac{u_{i,j+1} - u_{i,j}}{\\Delta y}.\n$$\nWe write $R = \\mathrm{diag}(R_0, R_x, R_y, R_q)$ for the diagonal resistance matrix.\n\nThe objective $J(\\mathbf{i})$ is a convex quadratic in $\\mathbf{i}$, so its minimizer is given by the unique solution of the normal equations obtained by setting the gradient to zero. We expand each term:\n\n1. Homogeneity term:\n$$\n\\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2 = \\|A \\mathbf{i} + \\mathbf{f} - \\mathbf{t}\\|_2^2.\n$$\nIts gradient with respect to $\\mathbf{i}$ is\n$$\n\\nabla_{\\mathbf{i}} \\|A \\mathbf{i} + \\mathbf{f} - \\mathbf{t}\\|_2^2 = 2 A^\\top (A \\mathbf{i} + \\mathbf{f} - \\mathbf{t}).\n$$\n\n2. Power term:\n$$\n\\lambda_p \\sum_k R_k i_k^2 = \\lambda_p \\mathbf{i}^\\top R \\mathbf{i}.\n$$\nIts gradient is\n$$\n\\nabla_{\\mathbf{i}} \\left( \\lambda_p \\mathbf{i}^\\top R \\mathbf{i} \\right) = 2 \\lambda_p R \\mathbf{i}.\n$$\n\n3. Roughness term:\n$$\n\\lambda_r \\left(\\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2\\right) = \\lambda_r \\left(\\|D_x (A \\mathbf{i} + \\mathbf{f})\\|_2^2 + \\|D_y (A \\mathbf{i} + \\mathbf{f})\\|_2^2\\right).\n$$\nUsing linearity, $D_x (A \\mathbf{i} + \\mathbf{f}) = D_x A \\mathbf{i} + D_x \\mathbf{f}$ and similarly for $D_y$. Denote $G_x = D_x$, $G_y = D_y$ and note that\n$$\n\\|G_x (A \\mathbf{i} + \\mathbf{f})\\|_2^2 = \\|G_x A \\mathbf{i} + G_x \\mathbf{f}\\|_2^2 = \\mathbf{i}^\\top (A^\\top G_x^\\top G_x A) \\mathbf{i} + 2 \\mathbf{i}^\\top A^\\top G_x^\\top G_x \\mathbf{f} + \\mathbf{f}^\\top G_x^\\top G_x \\mathbf{f},\n$$\nand analogously for $G_y$. The gradient of the sum with respect to $\\mathbf{i}$ is\n$$\n\\nabla_{\\mathbf{i}} \\left( \\lambda_r \\left[\\|G_x (A \\mathbf{i} + \\mathbf{f})\\|_2^2 + \\|G_y (A \\mathbf{i} + \\mathbf{f})\\|_2^2\\right] \\right)\n= 2 \\lambda_r \\left[ (A^\\top G_x^\\top G_x A + A^\\top G_y^\\top G_y A) \\mathbf{i} + A^\\top (G_x^\\top G_x + G_y^\\top G_y) \\mathbf{f} \\right].\n$$\n\nSetting the total gradient to zero yields:\n$$\n2 A^\\top (A \\mathbf{i} + \\mathbf{f} - \\mathbf{t}) + 2 \\lambda_p R \\mathbf{i} + 2 \\lambda_r \\left[(A^\\top G_x^\\top G_x A + A^\\top G_y^\\top G_y A) \\mathbf{i} + A^\\top (G_x^\\top G_x + G_y^\\top G_y) \\mathbf{f}\\right] = 0.\n$$\nDivide by $2$ and collect terms in $\\mathbf{i}$ to obtain the normal equations:\n$$\n\\left( A^\\top A + \\lambda_p R + \\lambda_r A^\\top (G_x^\\top G_x + G_y^\\top G_y) A \\right) \\mathbf{i}\n= A^\\top (\\mathbf{t} - \\mathbf{f}) - \\lambda_r A^\\top (G_x^\\top G_x + G_y^\\top G_y) \\mathbf{f}.\n$$\nThis is a $4 \\times 4$ linear system. The left-hand matrix is positive definite for $\\lambda_p > 0$ or when $A$ has full column rank and the roughness operator adds positive semidefinite terms, ensuring a unique minimizer $\\mathbf{i}$.\n\nAlgorithmic implementation:\n\n- Construct the grid $(x_i, y_j)$ with $n_x = n_y = 21$, spacing $\\Delta x = \\Delta y = 0.2 / 20$ meters.\n- Evaluate $\\Delta B(x,y)$ at all grid points, set $B_0(x,y) = B_{\\mathrm{ref}} + \\Delta B(x,y)$, and flatten to $\\mathbf{f}$.\n- Set $\\mathbf{t}$ as the constant $B_{\\mathrm{ref}}$, flattened.\n- Build the coil basis fields $b_0$, $b_x$, $b_y$, $b_q$ on the grid and stack columns into $A$.\n- Implement forward differences divided by grid spacing for $D_x$ and $D_y$. For optimization, we need $A^\\top G_x^\\top G_x A$, $A^\\top G_y^\\top G_y A$, and $A^\\top (G_x^\\top G_x + G_y^\\top G_y) \\mathbf{f}$. These can be computed without explicitly forming $G_x$ and $G_y$ by applying differences to each column of $A$ and to $\\mathbf{f}$, then forming inner products:\n  - Let $D_x A$ be the matrix obtained by applying $D_x$ to each column of $A$ reshaped as the grid and flattening; similarly $D_y A$.\n  - Then $A^\\top G_x^\\top G_x A = (D_x A)^\\top (D_x A)$ and $A^\\top G_y^\\top G_y A = (D_y A)^\\top (D_y A)$.\n  - For the linear term, $A^\\top G_x^\\top G_x \\mathbf{f} = (D_x A)^\\top (D_x \\mathbf{f})$ and similarly for $y$.\n- Form the normal equations matrix and right-hand side for each $(\\lambda_p, \\lambda_r)$, solve for $\\mathbf{i}$, compute $\\mathbf{s}(\\mathbf{i}) = \\mathbf{f} + A \\mathbf{i}$.\n- Compute metrics:\n  - RMS deviation: $\\sqrt{\\frac{1}{N} \\|\\mathbf{s}(\\mathbf{i}) - \\mathbf{t}\\|_2^2}$ in Tesla.\n  - Total power: $\\sum_k R_k i_k^2$ in Watts.\n  - Mean squared gradient: $\\frac{1}{M} \\left( \\|D_x \\mathbf{s}(\\mathbf{i})\\|_2^2 + \\|D_y \\mathbf{s}(\\mathbf{i})\\|_2^2 \\right)$ in Tesla$^2$/meter$^2$, where $M = M_x + M_y$.\n\nTrade-off analysis encoded in code comments:\n- Increasing $\\lambda_p$ penalizes large currents, thereby reducing hardware stress (power), but typically increases the RMS deviation because the solution avoids aggressive corrections.\n- Increasing $\\lambda_r$ penalizes spatial gradients, promoting smoother fields; this can reduce the mean squared gradient but may limit the ability to tightly fit the target, increasing RMS deviation and potentially changing current distribution.\n- With both regularizations high, the solution tends to balance small currents and smooth corrections, yielding higher RMS deviation, lower power, and lower roughness relative to the unregularized case.\n\nUnits are preserved by construction: $A$ is in Tesla per Ampere (with appropriate spatial factors for gradients and quadratics), $\\mathbf{f}$ and $\\mathbf{t}$ are in Tesla, $D_x$ and $D_y$ divide by meters, so the gradient outputs are in Tesla/meter, and their squared magnitudes average to Tesla$^2$/meter$^2$. The power is in Watts via $R_k i_k^2$.\n\nThe program implements the full pipeline and prints the flattened list\n$[\\text{rms}_1, \\text{power}_1, \\text{rough}_1, \\ldots, \\text{rms}_4, \\text{power}_4, \\text{rough}_4]$, each rounded to six decimal places, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_grid(n=21, extent=0.1):\n    # Grid from -extent to +extent (meters)\n    x = np.linspace(-extent, extent, n)\n    y = np.linspace(-extent, extent, n)\n    dx = x[1] - x[0]\n    dy = y[1] - y[0]\n    X, Y = np.meshgrid(x, y, indexing='ij')\n    return X, Y, dx, dy\n\ndef baseline_field(X, Y, Bref=3.0):\n    # Baseline inhomogeneity (Tesla)\n    dB = 0.002 * X - 0.002 * Y + 0.0005 * (X**2 - Y**2)\n    return Bref + dB\n\ndef target_field(X, Y, Bref=3.0):\n    return np.full_like(X, Bref)\n\ndef coil_basis_fields(X, Y):\n    # Basis fields per unit current (Tesla/Amp)\n    b0 = 0.01 * np.ones_like(X)                    # uniform\n    bx = 0.02 * X                                  # linear x\n    by = 0.02 * Y                                  # linear y\n    bq = 0.002 * (X**2 - Y**2)                     # quadratic\n    return [b0, bx, by, bq]\n\ndef forward_diff_x(field, dx):\n    # Forward differences along x divided by dx; shape (nx-1, ny)\n    return (field[1:, :] - field[:-1, :]) / dx\n\ndef forward_diff_y(field, dy):\n    # Forward differences along y divided by dy; shape (nx, ny-1)\n    return (field[:, 1:] - field[:, :-1]) / dy\n\ndef assemble_A_and_f(X, Y, dx, dy):\n    # Build design matrix A and vectors f, t\n    f_grid = baseline_field(X, Y)     # Tesla\n    t_grid = target_field(X, Y)       # Tesla\n    basis = coil_basis_fields(X, Y)   # list of 2D arrays\n    n = X.shape[0] * X.shape[1]\n    # Flatten basis into columns of A (N x 4)\n    A = np.column_stack([b.reshape(-1) for b in basis])\n    f = f_grid.reshape(-1)\n    t = t_grid.reshape(-1)\n    return A, f, t, basis, f_grid\n\ndef roughness_matrices(A, basis_fields, f_grid, dx, dy):\n    \"\"\"\n    Compute A^T G^T G A and A^T G^T G f without explicitly constructing G,\n    using forward differences on each column field (basis) and on f.\n    \"\"\"\n    # Apply forward differences to basis fields\n    Dx_cols = []\n    Dy_cols = []\n    for b in basis_fields:\n        Dx_b = forward_diff_x(b, dx).reshape(-1)  # (nx-1)*ny\n        Dy_b = forward_diff_y(b, dy).reshape(-1)  # nx*(ny-1)\n        Dx_cols.append(Dx_b)\n        Dy_cols.append(Dy_b)\n    # Stack columns: shapes (Mx, 4) and (My, 4)\n    DxA = np.column_stack(Dx_cols)\n    DyA = np.column_stack(Dy_cols)\n    # Differences of f\n    Dxf = forward_diff_x(f_grid, dx).reshape(-1)\n    Dyf = forward_diff_y(f_grid, dy).reshape(-1)\n    # Quadratic term contributions (sum over x and y components)\n    Qt = DxA.T @ DxA + DyA.T @ DyA\n    # Linear term contributions\n    qt = DxA.T @ Dxf + DyA.T @ Dyf\n    return Qt, qt, Dxf, Dyf, DxA, DyA\n\ndef solve_case(A, f, t, Rdiag, Qt, qt, lambdap, lambdar):\n    # Normal equations:\n    # (A^T A + lambdap*R + lambdar*Qt) i = A^T (t - f) - lambdar * qt\n    AtA = A.T @ A\n    Atb = A.T @ (t - f)\n    R = np.diag(Rdiag)\n    M = AtA + lambdap * R + lambdar * Qt\n    rhs = Atb - lambdar * qt\n    # Solve linear system\n    i = np.linalg.solve(M, rhs)\n    return i\n\ndef compute_metrics(i, A, f, t, f_grid, dx, dy):\n    # Synthesized field\n    s = f + A @ i\n    # RMS deviation (Tesla)\n    rms = np.sqrt(np.mean((s - t)**2))\n    # Power (Watts)\n    Rdiag = np.array([1.5, 2.0, 2.0, 2.5])\n    power = np.sum(Rdiag * (i**2))\n    # Roughness: mean squared gradient (Tesla^2/m^2)\n    s_grid = s.reshape(f_grid.shape)\n    Dxs = forward_diff_x(s_grid, dx).reshape(-1)\n    Dys = forward_diff_y(s_grid, dy).reshape(-1)\n    Mcount = Dxs.size + Dys.size\n    rough = (np.sum(Dxs**2) + np.sum(Dys**2)) / Mcount\n    return rms, power, rough\n\ndef solve():\n    # Define grid and fields\n    X, Y, dx, dy = build_grid(n=21, extent=0.1)\n    A, f, t, basis_fields, f_grid = assemble_A_and_f(X, Y, dx, dy)\n    # Precompute roughness matrices\n    Qt, qt, Dxf, Dyf, DxA, DyA = roughness_matrices(A, basis_fields, f_grid, dx, dy)\n    # Resistances (Ohm)\n    Rdiag = np.array([1.5, 2.0, 2.0, 2.5])\n    # Test cases: (lambda_p, lambda_r)\n    test_cases = [\n        (0.0, 0.0),   # Unregularized; best homogeneity, highest stress/roughness\n        (5.0, 0.0),   # Power-regularized; reduced currents and power, increased RMS\n        (0.0, 0.1),   # Roughness-regularized; smoother field, potentially higher RMS\n        (5.0, 0.2),   # Both regularizations; balanced trade-off\n    ]\n    results = []\n    for lambdap, lambdar in test_cases:\n        i = solve_case(A, f, t, Rdiag, Qt, qt, lambdap, lambdar)\n        rms, power, rough = compute_metrics(i, A, f, t, f_grid, dx, dy)\n        # Analysis (comments):\n        # - As lambdap increases, the solution penalizes large currents i_k, reducing power.\n        #   This typically increases RMS because the correction field is weaker.\n        # - As lambdar increases, the solution penalizes gradients of the synthesized field,\n        #   promoting smoothness and reducing 'rough', but may also increase RMS and change\n        #   the distribution of currents away from aggressively fitting high-frequency components.\n        results.extend([f\"{rms:.6f}\", f\"{power:.6f}\", f\"{rough:.6f}\"])\n    # Final print statement in the exact required format (flattened list of floats).\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4898468"}]}