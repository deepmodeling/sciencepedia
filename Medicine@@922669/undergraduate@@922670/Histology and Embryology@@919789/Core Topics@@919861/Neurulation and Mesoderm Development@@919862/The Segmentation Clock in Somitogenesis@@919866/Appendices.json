{"hands_on_practices": [{"introduction": "The clock-and-wavefront model provides a powerful quantitative framework for understanding somitogenesis. This practice challenges you to apply the model's core relationship, where somite length ($S$) is the product of the clock's period ($T$) and the wavefront's speed ($u$). By reconciling the predicted live somite size with a fixed histological measurement, you will learn the critical importance of accounting for experimental variables such as tissue growth and processing-induced shrinkage. [@problem_id:4939470]", "problem": "In the clock-and-wavefront framework of somitogenesis, the Presomitic Mesoderm (PSM) exhibits oscillatory gene expression known as the segmentation clock, with period $T$, while an arrest front (the determination wavefront) moves anteriorly at speed $u$ along the embryonic anteroposterior axis. A kymograph built from time-lapse imaging of a live avian embryo provides a measured arrest-front speed $u$ and an oscillation period $T$ for the segmentation clock. From first principles, use core definitions to relate the distance advanced by the arrest front during one oscillation to the nascent somite anteroposterior length $S$. Next, recognize that after segmentation, the somite’s anteroposterior length increases by a fractional growth $\\gamma$ before fixation for histology, and that fixation and processing cause isotropic shrinkage represented by a fractional loss $s$.\n\nYou are given the following experimentally determined values:\n- Measured arrest-front speed from the kymograph $u = 1.6\\ \\text{µm}\\ \\text{min}^{-1}$.\n- Segmentation clock period $T = 90\\ \\text{min}$.\n- Fractional growth along the anteroposterior dimension prior to fixation $\\gamma = 0.05$.\n- Histologically measured somite width after fixation $S_{\\text{hist}} = 130\\ \\text{µm}$.\n\nUsing only core definitions of the segmentation clock and wavefront, first compute the predicted nascent somite length $S$ in micrometers from the live kymograph measurements. Then, derive and compute the shrinkage fraction $s$ that reconciles the predicted live somite length (including the specified growth $\\gamma$ prior to fixation) with the fixed-tissue histological measurement $S_{\\text{hist}}$.\n\nReport your final answer as the shrinkage fraction $s$ written as a decimal number. Round your final answer to three significant figures. Do not include any unit in your final answer.", "solution": "The problem statement is evaluated as valid. It is scientifically grounded in the established clock-and-wavefront model of vertebrate somitogenesis, is well-posed with sufficient and consistent data, and is formulated objectively. The provided parameters, such as the segmentation clock period and wavefront speed, are within physiologically realistic ranges for avian embryos. The problem requires a logical application of core definitions to derive a physically meaningful quantity.\n\nThe solution proceeds in two stages as requested. First, the nascent somite length, $S$, is calculated from the kymograph measurements. Second, this value is used along with the post-segmentation growth and histological measurements to determine the shrinkage fraction, $s$.\n\nThe core principle of the clock-and-wavefront model is that one somite is formed during each period, $T$, of the segmentation clock. The anteroposterior length of this nascent somite, $S$, is determined by the distance the determination wavefront travels along the presomitic mesoderm during this time interval. Given that the wavefront moves at a constant speed, $u$, the length $S$ is given by the product of speed and time:\n$$S = uT$$\nUsing the experimentally determined values $u = 1.6 \\text{ µm min}^{-1}$ and $T = 90 \\text{ min}$:\n$$S = (1.6 \\text{ µm min}^{-1}) \\times (90 \\text{ min}) = 144 \\text{ µm}$$\nThis is the predicted anteroposterior length of a somite immediately upon its formation from the presomitic mesoderm.\n\nNext, we account for the biological and technical processes that alter this length before the final histological measurement. The problem states that the somite undergoes growth, increasing its anteroposterior length by a fractional amount $\\gamma = 0.05$. The length after this growth, which we denote as $S_{\\text{grown}}$, is:\n$$S_{\\text{grown}} = S + \\gamma S = S(1 + \\gamma)$$\nSubstituting the calculated value of $S$:\n$$S_{\\text{grown}} = 144 \\text{ µm} \\times (1 + 0.05) = 144 \\text{ µm} \\times 1.05 = 151.2 \\text{ µm}$$\n\nFollowing this growth, the tissue is fixed and processed for histology, which results in isotropic shrinkage. This shrinkage is represented as a fractional loss, $s$, from the grown length, $S_{\\text{grown}}$. The final measured length on the histological slide, $S_{\\text{hist}}$, is therefore related to $S_{\\text{grown}}$ by:\n$$S_{\\text{hist}} = S_{\\text{grown}} - s S_{\\text{grown}} = S_{\\text{grown}}(1 - s)$$\nWe are asked to find the shrinkage fraction, $s$. We can rearrange this equation to solve for $s$:\n$$1 - s = \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\n$$s = 1 - \\frac{S_{\\text{hist}}}{S_{\\text{grown}}}$$\nNow, we can substitute the expressions for $S_{\\text{grown}}$ and $S$ to obtain a single formula for $s$ in terms of the primary given values:\n$$s = 1 - \\frac{S_{\\text{hist}}}{S(1 + \\gamma)} = 1 - \\frac{S_{\\text{hist}}}{uT(1 + \\gamma)}$$\nUsing the given values $S_{\\text{hist}} = 130 \\text{ µm}$ and the previously calculated value $S_{\\text{grown}} = 151.2 \\text{ µm}$:\n$$s = 1 - \\frac{130 \\text{ µm}}{151.2 \\text{ µm}}$$\n$$s = 1 - 0.859788...$$\n$$s \\approx 0.140211...$$\nThe problem requires the final answer to be rounded to three significant figures.\n$$s \\approx 0.140$$", "answer": "$$\\boxed{0.140}$$", "id": "4939470"}, {"introduction": "The segmentation clock, like many biological rhythms, must function reliably across a range of environmental conditions, including temperature fluctuations. The $Q_{10}$ temperature coefficient is a standard biophysical metric used to quantify the temperature sensitivity of a rate process. This exercise will guide you through calculating $Q_{10}$ from experimental data on clock period, allowing you to assess the degree of temperature compensation in the segmentation clock. [@problem_id:4939459]", "problem": "In vertebrate somitogenesis, the segmentation clock is a tissue-level oscillatory process in the presomitic mesoderm that periodically triggers somite formation. The period of the clock, denoted by $P$, is the time between successive oscillatory peaks, and the corresponding segmentation rate is $k$, where by definition $k = \\frac{1}{P}$. A widely used descriptor of temperature sensitivity in biological rate processes is the temperature coefficient $Q_{10}$, defined such that the rate scales with temperature according to $k(T) = k(T_{0})\\,Q_{10}^{\\frac{T - T_{0}}{10}}$, where $T$ and $T_{0}$ are temperatures in degrees Celsius and $Q_{10}$ is dimensionless.\n\nA pre-somitic mesoderm explant from a chicken embryo is cultured at two controlled temperatures. At $T_{1} = 37.5^{\\circ}\\mathrm{C}$, the mean period of the segmentation clock is measured as $P_{1} = 90\\,\\mathrm{min}$. At $T_{2} = 41.0^{\\circ}\\mathrm{C}$, the mean period is measured as $P_{2} = 84\\,\\mathrm{min}$.\n\nUsing the definitions above, derive an expression for $Q_{10}$ in terms of $k_{1}$, $k_{2}$, $T_{1}$, and $T_{2}$, and then compute the numerical value of $Q_{10}$ for these data. Based on the computed $Q_{10}$, briefly state whether the segmentation clock exhibits temperature compensation over this range (perfect compensation corresponds to $Q_{10}$ very close to $1$).\n\nReport the final $Q_{10}$ value as a dimensionless number rounded to three significant figures.", "solution": "### Solution Derivation\n\nThe analysis begins with the definition of the temperature coefficient $Q_{10}$:\n$$k(T) = k(T_{0})\\,Q_{10}^{\\frac{T - T_{0}}{10}}$$\nThis equation relates the rate of a process, $k$, at a temperature $T$ to its rate at a reference temperature $T_{0}$. We are given two data points, $(T_1, P_1)$ and $(T_2, P_2)$. First, we must convert the periods $P$ into rates $k$ using the given definition $k = \\frac{1}{P}$.\nThe rate at temperature $T_1$ is $k_1 = \\frac{1}{P_1}$.\nThe rate at temperature $T_2$ is $k_2 = \\frac{1}{P_2}$.\n\nWe can use the two data points to establish a relationship. Let us set the reference state to be the first experimental condition, so $T_0 = T_1$ and $k(T_0) = k_1$. Then, for the second condition, we have $T = T_2$ and $k(T) = k_2$. Substituting these into the defining equation gives:\n$$k_2 = k_1\\,Q_{10}^{\\frac{T_2 - T_1}{10}}$$\nOur first goal is to derive an expression for $Q_{10}$ in terms of $k_1$, $k_2$, $T_1$, and $T_2$. To do this, we rearrange the equation to isolate $Q_{10}$.\nFirst, divide by $k_1$:\n$$\\frac{k_2}{k_1} = Q_{10}^{\\frac{T_2 - T_1}{10}}$$\nTo solve for $Q_{10}$, we raise both sides of the equation to the power of the reciprocal of the exponent, which is $\\frac{10}{T_2 - T_1}$:\n$$Q_{10} = \\left(\\frac{k_2}{k_1}\\right)^{\\frac{10}{T_2 - T_1}}$$\nThis is the required expression for $Q_{10}$ in terms of the rates and temperatures.\n\nThe second part of the task is to compute the numerical value of $Q_{10}$. We are given periods $P_1$ and $P_2$, not rates. We can substitute the rate definitions into our expression for $Q_{10}$.\nThe ratio of the rates is:\n$$\\frac{k_2}{k_1} = \\frac{1/P_2}{1/P_1} = \\frac{P_1}{P_2}$$\nSubstituting this into the expression for $Q_{10}$ gives:\n$$Q_{10} = \\left(\\frac{P_1}{P_2}\\right)^{\\frac{10}{T_2 - T_1}}$$\nNow, we can substitute the given numerical values:\n-   $P_1 = 90\\,\\mathrm{min}$\n-   $P_2 = 84\\,\\mathrm{min}$\n-   $T_1 = 37.5^{\\circ}\\mathrm{C}$\n-   $T_2 = 41.0^{\\circ}\\mathrm{C}$\n\nThe temperature difference is $\\Delta T = T_2 - T_1 = 41.0 - 37.5 = 3.5^{\\circ}\\mathrm{C}$.\nThe ratio of the periods is $\\frac{P_1}{P_2} = \\frac{90}{84}$.\n\nSubstituting these values into the equation for $Q_{10}$:\n$$Q_{10} = \\left(\\frac{90}{84}\\right)^{\\frac{10}{3.5}}$$\nNow, we compute the numerical value. The fraction $\\frac{90}{84}$ simplifies to $\\frac{15}{14}$. The exponent is $\\frac{10}{3.5} = \\frac{100}{35} = \\frac{20}{7}$.\n$$Q_{10} = \\left(\\frac{15}{14}\\right)^{\\frac{20}{7}}$$\nCalculating the value:\n$$Q_{10} \\approx (1.07142857)^{\\frac{20}{7}} \\approx (1.07142857)^{2.85714285} \\approx 1.218554$$\nThe problem requires the answer to be rounded to three significant figures. The first three significant figures are $1.21$. The fourth digit is $8$, so we round up the third digit.\n$$Q_{10} \\approx 1.22$$\n\nThe final part of the task is to comment on temperature compensation. Temperature compensation refers to a mechanism that renders a biological process relatively insensitive to temperature changes. Perfect compensation would correspond to a $Q_{10}$ value of exactly $1$, meaning the rate does not change with temperature. The calculated value is $Q_{10} \\approx 1.22$, which indicates that for a $10^{\\circ}\\mathrm{C}$ increase in temperature, the rate of the segmentation clock increases by a factor of approximately $1.22$. Since this value is not close to $1$, the segmentation clock, over this temperature range, does not exhibit strong temperature compensation. It shows a moderate degree of temperature sensitivity, as is common for many biological processes that are not specifically compensated.", "answer": "$$\\boxed{1.22}$$", "id": "4939459"}, {"introduction": "At its heart, the segmentation clock is a manifestation of an underlying genetic oscillator, often based on a delayed negative feedback loop. Modern developmental biology uses computational modeling to understand how these molecular circuits generate rhythmic patterns. This hands-on coding exercise allows you to simulate a delay differential equation (DDE) model of a genetic oscillator, exploring how parameters like feedback delay ($\\tau$) and degradation rate ($\\delta$) control the emergence and period of oscillations. [@problem_id:4939387]", "problem": "You are tasked with designing and implementing a numerical experiment to study how a delayed negative-feedback gene regulatory loop can generate oscillations underlying the segmentation clock in somitogenesis, and how changes in degradation rate or delay time affect the presence and properties of these oscillations. Use a minimal, biologically motivated, delay differential equation model consistent with the Central Dogma of molecular biology (transcription produces messenger ribonucleic acid (mRNA), translation produces protein), and with well-supported observations that hairy and enhancer of split (HES) family genes repress their own transcription via delayed negative feedback.\n\nStarting point and definitions:\n- Let $M(t)$ denote the mRNA level and $P(t)$ denote the protein level.\n- Transcription is repressed by the protein with a delay $t - \\tau$, representing cumulative processes such as transcription, splicing, translation, transport, and post-translational modifications.\n- The delayed negative feedback repression is captured by a Hill function with exponent $n$.\n- Degradation is first-order with rate constants $\\delta_m$ for mRNA and $\\delta$ for protein.\n- Translation from mRNA to protein occurs with rate constant $k$, and maximal mRNA transcription rate is $\\alpha$.\n\nModel equations:\n$$\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t),$$\n$$\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t).$$\n\nRequirements:\n1. Implement a numerical integration scheme that can handle the delay term $P(t - \\tau)$ without using external files or user input. You may approximate the delay with a discrete ring buffer or equivalent. Use a fixed time step $dt$ and ensure numerical stability by choosing sufficiently small $dt$ relative to the fastest rate present.\n2. Devise an oscillation detection method that, given a simulated protein time series over a specified analysis window, returns:\n   - a boolean indicating whether sustained oscillations are present, and\n   - a float giving the mean oscillation period in seconds if oscillations are present, or $0.0$ if not.\n   Sustained oscillations should be determined by detecting multiple peaks after transients and requiring the amplitude (maximum minus minimum) to exceed a small positive threshold. Period should be computed as the mean inter-peak interval in seconds over the analysis window.\n3. Perform a parameter sweep over the delay $\\tau$ to estimate the onset of oscillations (a practical bifurcation point) by identifying the smallest tested $\\tau$ for which sustained oscillations are detected. If none of the tested delays produce oscillations, return $0.0$ for the bifurcation estimate.\n4. Validate the oscillation properties under experimental-like perturbations that modulate the protein degradation rate $\\delta$ or the delay $\\tau$.\n\nPhysical and numerical units:\n- Time must be in seconds. Periods and delays must be reported in seconds as floats.\n- All boolean outputs must be either the literal $True$ or $False$.\n\nNumerical method constraints:\n- Use a fixed time step $dt = 1.0$ seconds for integration.\n- Simulate for a total duration $T_{\\text{total}} = 20000.0$ seconds.\n- Discard the initial $5000.0$ seconds as transient; analyze oscillations in the remaining window.\n- Initialize $M(0)$ and $P(0)$ to small positive values, and use a constant pre-history for $P(t)$ over $t \\in [-\\tau, 0)$.\n\nTest suite:\nUse the following parameter sets, each defined in terms of $\\left(\\alpha, \\delta_m, k, \\delta, n, \\tau\\right)$, with time in seconds and rates in inverse seconds:\n- Test $1$ (baseline oscillatory regime): $\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$, $\\tau = 1200.0$. Output the mean oscillation period in seconds as a float.\n- Test $2$ (boundary, no delay): same as Test $1$ but with $\\tau = 0.0$. Output a boolean indicating whether sustained oscillations are detected.\n- Test $3$ (perturbation, faster degradation): same as Test $1$ but with $\\delta = 2 \\times 0.000577$. Output the mean oscillation period in seconds as a float; if non-oscillatory, output $0.0$.\n- Test $4$ (bifurcation estimate via delay sweep): fix $\\alpha = 0.01$, $\\delta_m = 0.001$, $k = 0.0001$, $\\delta = 0.000577$, $n = 4$, and sweep $\\tau$ over the list $\\left[0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0\\right]$. Output the smallest $\\tau$ in seconds from this list that yields sustained oscillations; if none, output $0.0$.\n- Test $5$ (perturbation, slower degradation): same as Test $1$ but with $\\delta = 0.5 \\times 0.000577$. Output the mean oscillation period in seconds as a float; if non-oscillatory, output $0.0$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Tests $1$ through $5$. The list must contain values of types $\\left[\\text{float}, \\text{boolean}, \\text{float}, \\text{float}, \\text{float}\\right]$ corresponding to the outputs prescribed above. For example, a valid output format is $\\left[1800.0,False,1500.0,900.0,2100.0\\right]$.", "solution": "### The Model: A Delayed Negative Feedback Loop\n\nThe core of the problem is a two-variable model describing the dynamics of messenger RNA (mRNA) concentration, denoted by $M(t)$, and protein concentration, $P(t)$. The model is a system of coupled delay differential equations:\n\n$$\n\\frac{dM}{dt} = \\frac{\\alpha}{1 + \\left[P(t - \\tau)\\right]^n} - \\delta_m M(t)\n$$\n$$\n\\frac{dP}{dt} = k\\,M(t) - \\delta\\,P(t)\n$$\n\nThese equations encapsulate fundamental principles of molecular biology:\n1.  **Transcription**: The first term in the equation for $\\frac{dM}{dt}$ models the production of mRNA. The rate of production is regulated by the protein $P$. The maximal transcription rate is $\\alpha$.\n2.  **Repression**: The protein $P$ represses its own gene's transcription. This negative feedback is described by a Hill function, $\\frac{1}{1 + [P]^n}$, where $n$ is the Hill coefficient that determines the steepness of the repression. A higher $n$ signifies a more switch-like response.\n3.  **Time Delay**: The repression is not instantaneous. The term $P(t - \\tau)$ signifies that the transcription rate at time $t$ is determined by the protein concentration at a past time, $t - \\tau$. This delay, $\\tau$, consolidates the time required for transcription, translation, and molecular transport. It is the crucial element that can induce oscillations.\n4.  **Degradation**: Both mRNA and protein are subject to degradation, modeled as first-order processes with rate constants $\\delta_m$ and $\\delta$, respectively. The terms $-\\delta_m M(t)$ and $-\\delta P(t)$ represent this removal.\n5.  **Translation**: The term $k\\,M(t)$ in the equation for $\\frac{dP}{dt}$ models the synthesis of protein from the mRNA template, occurring at a rate proportional to the mRNA concentration with a rate constant $k$.\n\n### Numerical Solution Strategy\n\nTo solve this system of DDEs, we employ a numerical integration scheme with a fixed time step.\n\n**Discretization and Integration**\nWe use the Forward Euler method, a straightforward and explicit time-stepping scheme. For a small time step $dt$, the state of the system at time $t+dt$ is approximated based on its state at time $t$. Given a time step $dt = 1.0$ second, the discrete update rules are:\n$$\nM(t_i + dt) = M(t_i) + dt \\cdot \\left( \\frac{\\alpha}{1 + \\left[P(t_i - \\tau)\\right]^n} - \\delta_m M(t_i) \\right)\n$$\n$$\nP(t_i + dt) = P(t_i) + dt \\cdot (k\\,M(t_i) - \\delta\\,P(t_i))\n$$\nwhere $t_i = i \\cdot dt$ for $i = 0, 1, 2, \\dots$. The chosen time step $dt=1.0$ is significantly smaller than the characteristic time scales of the system (e.g., $1/\\delta_m = 1000$ s), ensuring numerical stability for the given parameters.\n\n**Handling the Time Delay**\nThe term $P(t_i - \\tau)$ requires accessing the history of the protein concentration. We will store the full time series for $M(t)$ and $P(t)$ in arrays. At each step $i$, corresponding to time $t_i$, the delayed protein concentration is found at the past time $t_i - \\tau$. The corresponding array index is $j = i - \\tau/dt$. Since the provided $\\tau$ values are integer multiples of $dt$, this index $j$ will be an integer. For time points where $t_i - \\tau < 0$, we must consult the pre-history of the system.\n\n**Initial and History Conditions**\nThe system is initialized at $t=0$ with small positive concentrations to prevent division by zero and represent a basal state. We set $M(0) = 1.0$ and $P(0) = 1.0$. For the pre-history, i.e., $t < 0$, the problem specifies a constant value for $P(t)$. We will use a history of $P(t) = P(0) = 1.0$ for all $t \\in [-\\tau, 0)$. This is implemented by using the value $P(0)$ whenever the delay lookup index $j$ is negative.\n\n### Analysis of Oscillations\n\nTo determine if the system exhibits sustained oscillations, we analyze the protein time series $P(t)$ within a specified window, discarding initial transients.\n\n1.  **Analysis Window**: The simulation runs for a total time of $T_{\\text{total}} = 20000.0$ seconds. We discard the first $5000.0$ seconds to allow the system to settle onto its long-term behavior (either a stable steady state or a limit cycle), and perform the analysis on the time interval $[5000.0, 20000.0]$.\n\n2.  **Oscillation Detection Logic**:\n    *   **Amplitude Threshold**: A primary indicator of oscillation is a significant variation in concentration. We calculate the peak-to-trough amplitude, $A = \\max(P_{\\text{window}}) - \\min(P_{\\text{window}})$. To distinguish true oscillations from numerical noise or damped fluctuations, we require this amplitude to exceed a threshold. A threshold of $A > 0.1$ is chosen as a reasonable and small positive value relative to the expected steady-state concentrations.\n    *   **Peak Identification**: We use a peak-finding algorithm, specifically `scipy.signal.find_peaks`, to identify local maxima in the protein time series. A crucial parameter is `prominence`, which measures how much a peak stands out from its surrounding baseline. To filter out minor noisy peaks, we set the required prominence to be at least $10\\%$ of the total amplitude $A$.\n    *   **Sustained Oscillation Criterion**: For an oscillation to be considered \"sustained\", we require the detection of at least $3$ prominent peaks within the analysis window. This ensures that we have at least two full cycles from which to calculate a meaningful mean period.\n\n3.  **Period Calculation**: If the criteria for sustained oscillations are met, the oscillation period is calculated as the average time difference between consecutive detected peaks. If oscillations are not detected, the period is reported as $0.0$.\n\n### Execution of Test Cases\nThe established numerical and analytical framework is applied to each of the five test cases defined in the problem. A main function orchestrates the simulation and analysis for each parameter set, collecting the specific outputs required: mean period, a boolean for oscillation presence, or the bifurcation point from the parameter sweep. The results are then formatted into the specified list structure for the final output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import signal\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation and analysis for all test cases.\n    \"\"\"\n\n    def detect_oscillations(time_series, dt, analysis_start_time):\n        \"\"\"\n        Detects sustained oscillations in a time series and calculates their period.\n\n        Args:\n            time_series (np.ndarray): The data to analyze (e.g., protein concentration).\n            dt (float): The time step of the simulation.\n            analysis_start_time (float): Time to start the analysis from (to discard transients).\n\n        Returns:\n            tuple: A tuple containing:\n                - bool: True if sustained oscillations are detected, False otherwise.\n                - float: The mean oscillation period in seconds, or 0.0 if not oscillating.\n        \"\"\"\n        analysis_start_idx = int(analysis_start_time / dt)\n        analysis_window = time_series[analysis_start_idx:]\n\n        if len(analysis_window) < 3:\n            return False, 0.0\n\n        amplitude = np.max(analysis_window) - np.min(analysis_window)\n        \n        # Amplitude threshold for meaningful oscillation\n        amplitude_threshold = 0.1\n        if amplitude < amplitude_threshold:\n            return False, 0.0\n\n        # Find peaks with a prominence relative to the signal amplitude\n        # A minimal distance helps avoid detecting multiple peaks on a noisy crest.\n        # A distance of 100 steps (100 seconds) is safe.\n        prominence_threshold = 0.1 * amplitude\n        peaks, _ = signal.find_peaks(analysis_window, \n                                     prominence=prominence_threshold,\n                                     distance=int(100/dt))\n\n        # Require at least 3 peaks for a \"sustained\" oscillation and robust period calculation\n        if len(peaks) < 3:\n            return False, 0.0\n\n        # Calculate mean period from inter-peak intervals\n        peak_intervals = np.diff(peaks) * dt\n        mean_period = np.mean(peak_intervals)\n\n        return True, mean_period\n\n    def run_simulation(alpha, delta_m, k, delta, n, tau, T_total, dt, analysis_start_time):\n        \"\"\"\n        Runs a single simulation of the DDE model.\n\n        Args:\n            (alpha, delta_m, k, delta, n, tau): Model parameters.\n            T_total (float): Total simulation time.\n            dt (float): Time step.\n            analysis_start_time (float): Start time for analysis.\n\n        Returns:\n            tuple: (is_oscillatory, mean_period) from detect_oscillations.\n        \"\"\"\n        num_steps = int(T_total / dt)\n        M = np.zeros(num_steps + 1)\n        P = np.zeros(num_steps + 1)\n\n        # Initial conditions: small positive values\n        M[0] = 1.0\n        P[0] = 1.0\n        P_history_val = 1.0 # Constant pre-history\n\n        delay_steps = int(tau / dt)\n\n        # Main integration loop (Forward Euler)\n        for i in range(num_steps):\n            delay_idx = i - delay_steps\n            P_delayed = P[delay_idx] if delay_idx >= 0 else P_history_val\n\n            dM_dt = alpha / (1.0 + P_delayed**n) - delta_m * M[i]\n            dP_dt = k * M[i] - delta * P[i]\n\n            M[i + 1] = M[i] + dt * dM_dt\n            P[i + 1] = P[i] + dt * dP_dt\n\n        is_oscillatory, mean_period = detect_oscillations(P, dt, analysis_start_time)\n        return is_oscillatory, mean_period\n\n    # Numerical settings from the problem\n    DT = 1.0\n    T_TOTAL = 20000.0\n    ANALYSIS_START = 5000.0\n\n    # Baseline parameters\n    base_params = {\n        'alpha': 0.01,\n        'delta_m': 0.001,\n        'k': 0.0001,\n        'delta': 0.000577,\n        'n': 4,\n        'tau': 1200.0\n    }\n\n    results = []\n\n    # --- Test 1: Baseline oscillatory regime ---\n    params1 = base_params.copy()\n    _, period1 = run_simulation(**params1, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period1)\n\n    # --- Test 2: Boundary, no delay ---\n    params2 = base_params.copy()\n    params2['tau'] = 0.0\n    is_oscillatory2, _ = run_simulation(**params2, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(is_oscillatory2)\n    \n    # --- Test 3: Perturbation, faster degradation ---\n    params3 = base_params.copy()\n    params3['delta'] *= 2.0\n    _, period3 = run_simulation(**params3, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period3)\n\n    # --- Test 4: Bifurcation estimate via delay sweep ---\n    params4_base = base_params.copy()\n    tau_sweep = [0.0, 300.0, 600.0, 900.0, 1200.0, 1500.0, 1800.0]\n    bifurcation_tau = 0.0\n    for tau_val in tau_sweep:\n        params4 = params4_base.copy()\n        params4['tau'] = tau_val\n        is_oscillatory, _ = run_simulation(**params4, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n        if is_oscillatory:\n            bifurcation_tau = tau_val\n            break\n    results.append(bifurcation_tau)\n\n    # --- Test 5: Perturbation, slower degradation ---\n    params5 = base_params.copy()\n    params5['delta'] *= 0.5\n    _, period5 = run_simulation(**params5, T_total=T_TOTAL, dt=DT, analysis_start_time=ANALYSIS_START)\n    results.append(period5)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "4939387"}]}