{"hands_on_practices": [{"introduction": "A neuron's firing rate is shaped not only by excitatory inputs but also by a diverse array of inhibitory signals. This practice delves into the fundamental distinction between two primary forms of inhibition: hyperpolarizing inhibition, which actively pulls the membrane potential away from the firing threshold, and shunting inhibition, which increases membrane conductance and short-circuits other inputs. By implementing a leaky integrate-and-fire (LIF) model, you will computationally dissect how these two mechanisms differentially regulate neuronal output, providing a foundational understanding of synaptic integration. [@problem_id:5003160]", "problem": "A single-compartment pacemaker neuron can be modeled with a conductance-based leaky integrate-and-fire (LIF) description grounded in the conservation of charge and Ohm’s law. Consider the membrane equation\n$$\nC\\,\\frac{dV}{dt} \\;=\\; -g_L\\,(V - E_L)\\;-\\;g_{\\text{inh}}\\,(V - E_{\\text{inh}})\\;+\\;I_{\\text{app}},\n$$\nwhere $C$ is the membrane capacitance, $g_L$ is the leak conductance with reversal potential $E_L$, $g_{\\text{inh}}$ is a tonic inhibitory synaptic conductance with reversal potential $E_{\\text{inh}}$, and $I_{\\text{app}}$ is a constant applied current. The neuron spikes whenever $V$ reaches a fixed threshold $V_{\\text{th}}$, at which point $V$ is reset instantaneously to $V_{\\text{reset}}$ and held for an absolute refractory period $t_{\\text{ref}}$ before the dynamics resume. Assume that all parameters are time-constant over each test and that the dynamics between threshold and reset are governed by the linear membrane equation above.\n\nModel shunting inhibition as an increase in the leak conductance $g_L \\mapsto g_L + \\Delta g$ without changing the leak reversal potential $E_L$ and without adding a hyperpolarizing reversal potential. Model hyperpolarizing inhibition as an added inhibitory conductance $g_{\\text{inh}}$ with reversal potential $E_{\\text{inh}}$ strictly below threshold (that is, $E_{\\text{inh}} < V_{\\text{th}}$), leaving $g_L$ unchanged.\n\nYour task is to write a program that, for each test case below, computes three steady-state firing rates (in Hertz): baseline (no inhibition), shunting-inhibited (with $g_L \\mapsto g_L + \\Delta g$ and no $g_{\\text{inh}}$), and hyperpolarizing-inhibited (with $g_{\\text{inh}}$ and $E_{\\text{inh}}$ as given and no change to $g_L$). Assume the subthreshold trajectory is governed by the linear ordinary differential equation above with constant coefficients between spikes, and the spike-generation rule is as specified. If the parameters are such that the trajectory does not reach threshold (for example, the steady-state voltage lies at or below $V_{\\text{th}}$), then the firing rate is zero.\n\nAll physical units must be used consistently as follows: $V$ in millivolts (mV), time $t$ in milliseconds (ms), capacitance $C$ in nanofarads (nF), conductance $g$ in nanosiemens (nS), current $I$ in picoamperes (pA), and the firing rate in Hertz (Hz). Under these units, the effective membrane time constant in milliseconds is given by the ratio of capacitance to total conductance scaled by the appropriate conversion, and your program must ensure dimensional consistency internally. Angles are not involved in this problem. Do not report percentages.\n\nTest suite. For each case $k \\in \\{1,2,3,4,5\\}$, compute and report the triplet of firing rates $[f_{\\text{base}}^{(k)}, f_{\\text{shunt}}^{(k)}, f_{\\text{hyper}}^{(k)}]$ in Hertz (as floats), using the parameters listed. Each line lists $(C,\\; g_L,\\; E_L,\\; V_{\\text{th}},\\; V_{\\text{reset}},\\; I_{\\text{app}},\\; t_{\\text{ref}},\\; \\Delta g,\\; g_{\\text{inh}},\\; E_{\\text{inh}})$ with the units specified above.\n\n- Case $1$: $(0.1,\\; 10,\\; -65,\\; -50,\\; -65,\\; 180,\\; 2,\\; 10,\\; 10,\\; -75)$.\n- Case $2$: $(0.1,\\; 10,\\; -65,\\; -50,\\; -65,\\; 400,\\; 2,\\; 10,\\; 10,\\; -80)$.\n- Case $3$: $(0.1,\\; 10,\\; -65,\\; -50,\\; -65,\\; 600,\\; 2,\\; 10,\\; 10,\\; -75)$.\n- Case $4$: $(0.1,\\; 10,\\; -65,\\; -50,\\; -65,\\; 150,\\; 2,\\; 10,\\; 10,\\; -75)$.\n- Case $5$: $(0.1,\\; 10,\\; -65,\\; -55,\\; -65,\\; 250,\\; 2,\\; 10,\\; 20,\\; -75)$.\n\nDefinition of the three conditions for each case:\n- Baseline: $g_{\\text{inh}} = 0$ and $\\Delta g = 0$.\n- Shunting inhibition: replace $g_L$ by $g_L + \\Delta g$, set $g_{\\text{inh}} = 0$.\n- Hyperpolarizing inhibition: use $g_{\\text{inh}}$ and $E_{\\text{inh}}$ as given, keep $g_L$ unchanged.\n\nRequired final output format: Your program should produce a single line of output containing all results concatenated in order across the five cases, as a comma-separated list enclosed in square brackets. That is, the output must be\n$$\n\\big[\\; f_{\\text{base}}^{(1)},\\, f_{\\text{shunt}}^{(1)},\\, f_{\\text{hyper}}^{(1)},\\, f_{\\text{base}}^{(2)},\\, f_{\\text{shunt}}^{(2)},\\, f_{\\text{hyper}}^{(2)},\\, \\ldots,\\, f_{\\text{base}}^{(5)},\\, f_{\\text{shunt}}^{(5)},\\, f_{\\text{hyper}}^{(5)} \\;\\big].\n$$\nEach entry must be a floating-point number in Hertz. The program must not read any input and must not print anything else.", "solution": "The user wants me to solve a neurobiology problem about a leaky integrate-and-fire (LIF) neuron model.\n\nHere's my plan:\n1.  **Validate the problem:**\n    *   Extract all given information: the differential equation, parameter definitions, units, test cases, and the conditions for baseline, shunting, and hyperpolarizing inhibition.\n    *   Check for scientific soundness, clarity, completeness, and any other potential flaws. The model is a standard LIF neuron, which is a well-established simplified model in computational neuroscience. The units are provided and seem consistent (nF, nS, pA, mV, ms). I need to be careful with the units. The equation is $C \\frac{dV}{dt} = \\sum_i g_i (E_i - V) + I_{app}$. Let's check the given equation: $C\\,\\frac{dV}{dt} \\;=\\; -g_L\\,(V - E_L)\\;-\\;g_{\\text{inh}}\\,(V - E_{\\text{inh}})\\;+\\;I_{\\text{app}}$. This is equivalent to $C\\,\\frac{dV}{dt} \\;=\\; g_L\\,(E_L - V)\\;+\\;g_{\\text{inh}}\\,(E_{\\text{inh}} - V)\\;+\\;I_{\\text{app}}$. This is the standard form. The problem seems scientifically grounded. It is well-posed, providing all necessary parameters and a clear objective. The language is precise. The definitions of the three conditions are clear. The test cases provide all the necessary parameters. The output format is explicitly defined. I don't see any immediate flaws.\n\n2.  **Solve the problem (if valid):**\n    *   The core of the problem is to calculate the firing rate of the LIF neuron under different conditions. The firing rate $f$ is the reciprocal of the inter-spike interval (ISI), i.e., $f = 1 / T_{ISI}$. The ISI is the sum of the time it takes for the voltage to go from $V_{reset}$ to $V_{th}$ and the refractory period $t_{ref}$. So, $T_{ISI} = T_{V_{reset} \\to V_{th}} + t_{ref}$.\n    *   I need to solve the differential equation for $V(t)$ to find $T_{V_{reset} \\to V_{th}}$.\n    *   The general form of the equation is $C \\frac{dV}{dt} = -g_{tot}(V - V_{\\infty})$, where $g_{tot}$ is the total conductance and $V_{\\infty}$ is the steady-state voltage.\n    *   Let's rewrite the given equation:\n        $C\\,\\frac{dV}{dt} \\;=\\; -g_L\\,(V - E_L)\\;-\\;g_{\\text{inh}}\\,(V - E_{\\text{inh}})\\;+\\;I_{\\text{app}}$\n        $C\\,\\frac{dV}{dt} \\;=\\; -g_L V + g_L E_L - g_{\\text{inh}} V + g_{\\text{inh}} E_{\\text{inh}} + I_{\\text{app}}$\n        $C\\,\\frac{dV}{dt} \\;=\\; -(g_L + g_{\\text{inh}})V + (g_L E_L + g_{\\text{inh}} E_{\\text{inh}} + I_{\\text{app}})$\n        Let $g_{tot} = g_L + g_{\\text{inh}}$.\n        Then $C\\,\\frac{dV}{dt} \\;=\\; -g_{tot}V + (g_L E_L + g_{\\text{inh}} E_{\\text{inh}} + I_{\\text{app}})$.\n        We can rewrite this as:\n        $\\frac{C}{g_{tot}}\\,\\frac{dV}{dt} \\;=\\; -V + \\frac{g_L E_L + g_{\\text{inh}} E_{\\text{inh}} + I_{\\text{app}}}{g_{tot}}$.\n        Let $\\tau_m = C / g_{tot}$ and $V_{\\infty} = \\frac{g_L E_L + g_{\\text{inh}} E_{\\text{inh}} + I_{\\text{app}}}{g_{tot}}$.\n        The equation becomes $\\tau_m \\frac{dV}{dt} = V_{\\infty} - V$.\n    *   This is a standard first-order linear ODE. The solution is of the form $V(t) = V_{\\infty} + (V_0 - V_{\\infty}) e^{-t/\\tau_m}$.\n    *   Here, the neuron's voltage starts at $V(0) = V_{reset}$ after a spike. We want to find the time $t = T_{V_{reset} \\to V_{th}}$ it takes to reach $V_{th}$.\n    *   So, $V(t) = V_{th}$ at $t = T_{V_{reset} \\to V_{th}}$.\n        $V_{th} = V_{\\infty} + (V_{reset} - V_{\\infty}) e^{-T_{V_{reset} \\to V_{th}}/\\tau_m}$.\n    *   Solving for $T_{V_{reset} \\to V_{th}}$:\n        $\\frac{V_{th} - V_{\\infty}}{V_{reset} - V_{\\infty}} = e^{-T_{V_{reset} \\to V_{th}}/\\tau_m}$\n        $\\ln\\left(\\frac{V_{th} - V_{\\infty}}{V_{reset} - V_{\\infty}}\\right) = -T_{V_{reset} \\to V_{th}}/\\tau_m$\n        $T_{V_{reset} \\to V_{th}} = -\\tau_m \\ln\\left(\\frac{V_{th} - V_{\\infty}}{V_{reset} - V_{\\infty}}\\right)$\n        $T_{V_{reset} \\to V_{th}} = \\tau_m \\ln\\left(\\frac{V_{reset} - V_{\\infty}}{V_{th} - V_{\\infty}}\\right)$\n    *   This solution is valid only if the neuron actually spikes. This happens if $V_{\\infty} > V_{th}$. If $V_{\\infty} \\le V_{th}$, the neuron's voltage will approach $V_{\\infty}$ and never reach the threshold $V_{th}$. In this case, the firing rate is $0$.\n    *   Also, for the logarithm to be well-defined, the argument must be positive. Since $V_{reset} < V_{th}$ and we assume $V_{\\infty} > V_{th}$, we have $V_{reset} - V_{\\infty} < 0$ and $V_{th} - V_{\\infty} < 0$. Their ratio is positive. So the formula is correct under the condition $V_{\\infty} > V_{th}$. If $V_{reset} \\ge V_{th}$, the setup might be strange, but the given parameters have $V_{reset} < V_{th}$.\n    *   Once we have $T_{V_{reset} \\to V_{th}}$, the total inter-spike interval is $T_{ISI} = T_{V_{reset} \\to V_{th}} + t_{ref}$.\n    *   The firing rate is $f = 1 / T_{ISI}$.\n\n    **Unit consistency check:**\n    -   $V$: mV\n    -   $t$: ms\n    -   $C$: nF\n    -   $g$: nS\n    -   $I$: pA\n    The equation is $C \\frac{dV}{dt} = -g(V-E) + I$. Let's check the units.\n    LHS: nF * mV / ms = $10^{-9}$ F * $10^{-3}$ V / $10^{-3}$ s = $10^{-9}$ F * V/s = $10^{-9}$ A = nA.\n    RHS term 1: nS * mV = $10^{-9}$ S * $10^{-3}$ V = $10^{-12}$ A = pA.\n    RHS term 2: pA = $10^{-12}$ A.\n    There is a discrepancy. The current term $I_{app}$ is in pA, but the conductance term $g(V-E)$ results in pA. The capacitance term $C \\frac{dV}{dt}$ results in nA.\n    Let's re-read the problem carefully. \"your program must ensure dimensional consistency internally.\"\n    The dimensionally consistent form of the ODE, using the specified units for the variables ($V$ in mV, $t$ in ms, etc.), is not the one written, but rather one that reconciles the units of current. The term $C\\frac{dV}{dt}$ has units of $nF \\cdot mV/ms = nA$. The terms on the right-hand side, $g(V-E)$ and $I_{app}$, have units of $nS \\cdot mV = pA$ and $pA$, respectively. Since $1 nA = 1000 pA$, the correct equation is:\n    $C\\frac{dV}{dt} = \\frac{1}{1000} \\left( -g_L(V-E_L) - g_{inh}(V-E_{inh}) + I_{app} \\right)$.\n    This can be rearranged into the standard form $\\tau_m \\frac{dV}{dt} = V_{\\infty} - V$.\n    $C \\frac{dV}{dt} = -\\frac{g_L+g_{inh}}{1000} V + \\frac{g_L E_L + g_{inh} E_{inh} + I_{app}}{1000}$\n    $\\frac{1000 C}{g_L+g_{inh}} \\frac{dV}{dt} = -V + \\frac{g_L E_L + g_{inh} E_{inh} + I_{app}}{g_L+g_{inh}}$\n    From this form, we identify the membrane time constant $\\tau_m$ (which must be in ms, as $t$ is in ms) and the steady-state voltage $V_\\infty$.\n    \n    $V_{\\infty} = \\frac{g_L E_L + g_{inh} E_{inh} + I_{app}}{g_L + g_{inh}}$\n    \n    The fundamental definition is $\\tau_{SI} = C_{SI}/g_{SI}$.\n    $\\tau_{SI} [\\text{s}] = \\frac{C_{val} \\cdot 10^{-9} [F]}{g_{val} \\cdot 10^{-9} [S]} = \\frac{C_{val}}{g_{val}}[\\text{s}]$.\n    To get the time constant in milliseconds, we multiply by $1000$:\n    $\\tau_m [\\text{ms}] = 1000 \\cdot \\frac{C_{val}}{g_{val}}$.\n    This logic appears robust.\n\n    **Final algorithm summary:**\n    1.  For each condition (baseline, shunting, hyperpolarizing), determine the effective leak conductance $g_{L,\n        eff}$ and inhibitory conductance $g_{inh, eff}$.\n        *   Baseline: $g_{L,eff} = g_L$, $g_{inh,eff} = 0$.\n        *   Shunting: $g_{L,eff} = g_L + \\Delta g$, $g_{inh,eff} = 0$.\n        *   Hyperpolarizing: $g_{L,eff} = g_L$, $g_{inh,eff} = g_{inh}$.\n    2.  Calculate the total conductance $g_{tot} = g_{L,eff} + g_{inh,eff}$.\n    3.  Calculate the steady-state membrane potential $V_{\\infty} = \\frac{g_{L,eff}E_L + g_{inh,eff}E_{inh} + I_{app}}{g_{tot}}$.\n    4.  If $V_{\\infty} \\leq V_{th}$, the neuron does not fire, so the rate $f = 0$ Hz.\n    5.  If $V_{\\infty} > V_{th}$, the neuron fires. The firing rate is calculated as follows:\n        a. Calculate the membrane time constant in milliseconds: $\\tau_m = 1000 \\cdot \\frac{C}{g_{tot}}$.\n        b. Calculate the time required for the membrane potential to rise from $V_{reset}$ to $V_{th}$:\n           $T_{charge} = \\tau_m \\ln \\left( \\frac{V_{reset} - V_{\\infty}}{V_{th} - V_{\\infty}} \\right)$.\n        c. The total inter-spike interval (ISI) is the sum of the charging time and the absolute refractory period: $T_{ISI} = T_{charge} + t_{ref}$.\n        d. The firing rate in Hertz is the reciprocal of the ISI in seconds: $f = \\frac{1}{T_{ISI}/1000} = \\frac{1000}{T_{ISI}}$.\n\n    This logic is sound, dimensionally consistent, and correctly interprets the standard LIF model. The subsequent code will implement this algorithm.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the leaky integrate-and-fire neuron problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        # (C, g_L, E_L, V_th, V_reset, I_app, t_ref, delta_g, g_inh_param, E_inh)\n        (0.1, 10, -65, -50, -65, 180, 2, 10, 10, -75),\n        (0.1, 10, -65, -50, -65, 400, 2, 10, 10, -80),\n        (0.1, 10, -65, -50, -65, 600, 2, 10, 10, -75),\n        (0.1, 10, -65, -50, -65, 150, 2, 10, 10, -75),\n        (0.1, 10, -65, -55, -65, 250, 2, 10, 20, -75),\n    ]\n\n    results = []\n    for case in test_cases:\n        C, g_L_base, E_L, V_th, V_reset, I_app, t_ref, delta_g, g_inh_param, E_inh = case\n\n        # --- Baseline Condition ---\n        # g_inh is 0, g_L is as given.\n        f_base = compute_firing_rate(C, g_L_base, E_L, 0, E_inh, V_th, V_reset, I_app, t_ref)\n        results.append(f_base)\n\n        # --- Shunting Inhibition Condition ---\n        # g_L is increased by delta_g, g_inh is 0.\n        g_L_shunt = g_L_base + delta_g\n        f_shunt = compute_firing_rate(C, g_L_shunt, E_L, 0, E_inh, V_th, V_reset, I_app, t_ref)\n        results.append(f_shunt)\n\n        # --- Hyperpolarizing Inhibition Condition ---\n        # g_L is unchanged, g_inh is applied.\n        f_hyper = compute_firing_rate(C, g_L_base, E_L, g_inh_param, E_inh, V_th, V_reset, I_app, t_ref)\n        results.append(f_hyper)\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\ndef compute_firing_rate(C, g_L, E_L, g_inh, E_inh, V_th, V_reset, I_app, t_ref):\n    \"\"\"\n    Computes the steady-state firing rate for a LIF neuron given its parameters.\n\n    Units:\n    - C: nanofarads (nF)\n    - g: nanosiemens (nS)\n    - E: millivolts (mV)\n    - V: millivolts (mV)\n    - I: picoamperes (pA)\n    - t: milliseconds (ms)\n    - f: Hertz (Hz)\n\n    Args:\n        C (float): Membrane capacitance.\n        g_L (float): Leak conductance.\n        E_L (float): Leak reversal potential.\n        g_inh (float): Inhibitory conductance.\n        E_inh (float): Inhibitory reversal potential.\n        V_th (float): Firing threshold potential.\n        V_reset (float): Reset potential.\n        I_app (float): Applied current.\n        t_ref (float): Absolute refractory period.\n\n    Returns:\n        float: The firing rate in Hz. Returns 0 if the neuron does not spike.\n    \"\"\"\n    g_tot = g_L + g_inh\n\n    # Avoid division by zero if total conductance is zero, though not expected here.\n    if g_tot <= 0:\n        # If g_tot is non-positive, behavior depends on I_app.\n        # If I_app > 0, depolarizes without bound (infinite rate). If I_app <= 0, never spikes.\n        # Given problem constraints, g_tot will be positive.\n        return 0.0\n\n    # Calculate the steady-state voltage V_infinity.\n    # The formula is derived from the steady-state condition (dV/dt = 0) of the membrane equation.\n    # The units (nS*mV + pA) / nS result in mV for V_infinity.\n    v_inf_numerator = g_L * E_L + g_inh * E_inh + I_app\n    v_inf = v_inf_numerator / g_tot\n\n    # If V_infinity is at or below threshold, the neuron will never spike.\n    if v_inf <= V_th:\n        return 0.0\n\n    # The argument of the logarithm must be positive.\n    # Since V_reset < V_th < v_inf, (V_reset - v_inf) and (V_th - v_inf) are both negative,\n    # so their ratio is positive.\n    log_arg = (V_reset - v_inf) / (V_th - v_inf)\n    if log_arg <= 0:\n        # This case should not be reached with the given problem parameters.\n        return 0.0\n\n    # Calculate membrane time constant tau_m in milliseconds.\n    # tau_m[s] = C[F]/g[S]. C[nF]/g[nS] = (C_val*1e-9 F)/(g_val*1e-9 S) = C_val/g_val [s].\n    # To convert to ms, we multiply by 1000.\n    tau_m = 1000.0 * C / g_tot\n\n    # Calculate the time to charge from V_reset to V_th.\n    t_charge = tau_m * np.log(log_arg)\n\n    # Total inter-spike interval in milliseconds.\n    t_isi = t_charge + t_ref\n\n    # Firing rate in Hz (1/s). t_isi is in ms, so we convert it to seconds.\n    # f = 1 / (t_isi / 1000) = 1000 / t_isi\n    if t_isi <= 0:\n        # Should not happen if t_ref >= 0\n        return 0.0\n        \n    f_hz = 1000.0 / t_isi\n    \n    return f_hz\n    \nsolve()\n```", "id": "5003160"}, {"introduction": "Beyond responding to synaptic inputs, many neurons possess intrinsic ionic currents that enable them to generate rhythmic activity autonomously, acting as biological pacemakers. This exercise simulates a dynamic clamp experiment, a powerful neurophysiological technique, to explore the role of the hyperpolarization-activated cation current ($I_h$) in rhythmogenesis. Starting with a classic Hodgkin-Huxley model that is normally quiescent, you will computationally add a synthetic $I_h$ current and determine the specific parameter conditions under which it transforms the neuron into a stable pacemaker. [@problem_id:5003163]", "problem": "You are to design and analyze, in purely mathematical and algorithmic terms, a single-compartment conductance-based neuron model that is initially quiescent and becomes a pacemaker when an artificial hyperpolarization-activated cation conductance, often called the hyperpolarization-activated current ($I_h$), is added via dynamic clamp. Dynamic clamp is represented here as the injection of a synthetic current computed in real time from the membrane voltage according to specified kinetics. The target is to determine parameter ranges for the synthetic $I_h$ that induce autonomous pacemaker firing without any external applied current.\n\nStart from the well-tested membrane current balance for a spatially isopotential compartment of capacitance $C$:\n$$\nC \\frac{dV}{dt} = -\\left(I_{\\text{Na}} + I_{\\text{K}} + I_{\\text{L}} + I_h\\right) + I_{\\text{app}},\n$$\nwhere $V$ is the membrane potential, $I_{\\text{Na}}$ is the fast sodium current, $I_{\\text{K}}$ is the delayed rectifier potassium current, $I_{\\text{L}}$ is the leak current, $I_h$ is the synthetic hyperpolarization-activated current injected by dynamic clamp, and $I_{\\text{app}}$ is an applied current. In this experiment you must set $I_{\\text{app}} = 0$ so that autonomous firing (pacemaker dynamics) is the only source of rhythmicity.\n\nUse Hodgkin-Huxley-type dynamics for $I_{\\text{Na}}$ and $I_{\\text{K}}$ with the following well-tested formulas, all in millivolts ($\\text{mV}$) and milliseconds ($\\text{ms}$):\n$$\nI_{\\text{Na}} = g_{\\text{Na}} m^3 h \\left(V - E_{\\text{Na}}\\right), \\quad I_{\\text{K}} = g_{\\text{K}} n^4 \\left(V - E_{\\text{K}}\\right), \\quad I_{\\text{L}} = g_{\\text{L}} \\left(V - E_{\\text{L}}\\right),\n$$\nwith gating variable kinetics\n$$\n\\frac{dm}{dt} = \\alpha_m(V)\\left(1 - m\\right) - \\beta_m(V) m, \\quad \\frac{dh}{dt} = \\alpha_h(V)\\left(1 - h\\right) - \\beta_h(V) h, \\quad \\frac{dn}{dt} = \\alpha_n(V)\\left(1 - n\\right) - \\beta_n(V) n,\n$$\nwhere the rate functions are\n$$\n\\alpha_m(V) = 0.1 \\frac{V + 40}{1 - e^{-(V + 40)/10}}, \\quad \\beta_m(V) = 4 e^{-(V + 65)/18},\n$$\n$$\n\\alpha_h(V) = 0.07 e^{-(V + 65)/20}, \\quad \\beta_h(V) = \\frac{1}{1 + e^{-(V + 35)/10}},\n$$\n$$\n\\alpha_n(V) = 0.01 \\frac{V + 55}{1 - e^{-(V + 55)/10}}, \\quad \\beta_n(V) = 0.125 e^{-(V + 65)/80}.\n$$\nUse the canonical parameter set\n$$\nC = 1.0 \\ \\mu\\text{F}/\\text{cm}^2, \\quad g_{\\text{Na}} = 120.0 \\ \\text{mS}/\\text{cm}^2, \\quad g_{\\text{K}} = 36.0 \\ \\text{mS}/\\text{cm}^2, \\quad g_{\\text{L}} = 0.3 \\ \\text{mS}/\\text{cm}^2,\n$$\n$$\nE_{\\text{Na}} = 50.0 \\ \\text{mV}, \\quad E_{\\text{K}} = -77.0 \\ \\text{mV}, \\quad E_{\\text{L}} = -54.4 \\ \\text{mV}.\n$$\nModel dynamic-clamp $I_h$ as\n$$\nI_h = g_h r \\left(V - E_h\\right),\n$$\nwhere $g_h$ is the maximal conductance, $E_h$ is the reversal potential, and $r$ is an activation variable obeying first-order kinetics\n$$\n\\frac{dr}{dt} = \\frac{r_{\\infty}(V) - r}{\\tau_h},\n$$\nwith steady-state activation\n$$\nr_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(\\frac{V - V_{1/2}}{k}\\right)}.\n$$\nThis choice ensures that $r_{\\infty}(V)$ increases for more hyperpolarized $V$, consistent with hyperpolarization activation. Here $\\tau_h$ is taken constant for simplicity, $V_{1/2}$ is the half-activation voltage, and $k$ is the slope factor.\n\nInitial conditions should be the steady-state values of $m$, $h$, and $n$ at a holding potential $V_{\\text{init}} = -65.0 \\ \\text{mV}$ with $r = r_{\\infty}(V_{\\text{init}})$ and $V(0) = V_{\\text{init}}$.\n\nScientifically realistic parameter ranges for $I_h$ are $E_h$ between $-30.0 \\ \\text{mV}$ and $-20.0 \\ \\text{mV}$, $V_{1/2}$ between $-90.0 \\ \\text{mV}$ and $-70.0 \\ \\text{mV}$, $k$ between $5.0 \\ \\text{mV}$ and $10.0 \\ \\text{mV}$, and $\\tau_h$ between $50.0 \\ \\text{ms}$ and $500.0 \\ \\text{ms}$. In this problem, fix $E_h = -30.0 \\ \\text{mV}$, $k = 7.0 \\ \\text{mV}$, and vary $g_h$, $V_{1/2}$, and $\\tau_h$ as specified below.\n\nSimulation requirements:\n- Integrate the system with a fixed time step $dt = 0.01 \\ \\text{ms}$ for a total duration $T = 3000.0 \\ \\text{ms}$ with $I_{\\text{app}} = 0.0$.\n- Detect spikes as upward crossings of $V$ through $0.0 \\ \\text{mV}$.\n- Define the pacemaker regime as follows: consider spikes occurring after the initial transient of $t \\ge 2000.0 \\ \\text{ms}$. If there are at least $3$ spikes in the last $1000.0 \\ \\text{ms}$, and the coefficient of variation (standard deviation divided by mean) of the interspike intervals in that window is $\\le 0.3$, report the mean firing frequency in $\\text{Hz}$ as $1$ divided by the mean interspike interval expressed in $\\text{s}$. If there are $0$ spikes and the mean membrane potential over the last $1000.0 \\ \\text{ms}$ is $\\ge -45.0 \\ \\text{mV}$, report a sentinel value of $-1.0$ to indicate depolarization block. Otherwise, report $0.0$ to indicate quiescence or irregular/non-pacemaker firing.\n- Express the final firing frequency in $\\text{Hz}$ for each test case as a floating-point number.\n\nTest suite:\nProvide results for the following parameter sets, with all other parameters fixed as stated above:\n- Case $1$ (control, quiescent): $g_h = 0.0 \\ \\text{mS}/\\text{cm}^2$, $V_{1/2} = -80.0 \\ \\text{mV}$, $\\tau_h = 200.0 \\ \\text{ms}$.\n- Case $2$ (expected pacemaker): $g_h = 0.05 \\ \\text{mS}/\\text{cm}^2$, $V_{1/2} = -80.0 \\ \\text{mV}$, $\\tau_h = 200.0 \\ \\text{ms}$.\n- Case $3$ (edge, potential depolarization block): $g_h = 0.20 \\ \\text{mS}/\\text{cm}^2$, $V_{1/2} = -80.0 \\ \\text{mV}$, $\\tau_h = 200.0 \\ \\text{ms}$.\n- Case $4$ (less hyperpolarized activation): $g_h = 0.05 \\ \\text{mS}/\\text{cm}^2$, $V_{1/2} = -70.0 \\ \\text{mV}$, $\\tau_h = 200.0 \\ \\text{ms}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the $\\text{Hz}$ value for the corresponding case, using the sentinel $-1.0$ for depolarization block and $0.0$ for quiescence or non-pacemaker spiking, as defined above.", "solution": "The problem requires the design of a numerical simulation and analysis algorithm to investigate how a synthetic hyperpolarization-activated cation current, $I_h$, can induce pacemaker activity in an otherwise quiescent single-compartment Hodgkin-Huxley-type neuron model. The neuron's dynamics are described by a system of first-order ordinary differential equations (ODEs).\n\nThe core of the model is the membrane potential equation, which balances currents across the neuronal membrane:\n$$\nC \\frac{dV}{dt} = -I_{\\text{ion}} + I_{\\text{app}}\n$$\nwhere $C = 1.0 \\ \\mu\\text{F}/\\text{cm}^2$ is the membrane capacitance, $V$ is the membrane potential in $\\text{mV}$, and $I_{\\text{app}}$ is an external applied current, set to $I_{\\text{app}} = 0.0 \\ \\mu\\text{A}/\\text{cm}^2$ for this problem to study autonomous firing. The total ionic current, $I_{\\text{ion}}$, is the sum of four components:\n$$\nI_{\\text{ion}} = I_{\\text{Na}} + I_{\\text{K}} + I_{\\text{L}} + I_h\n$$\nThe individual currents are defined as follows:\n1.  **Fast Sodium Current ($I_{\\text{Na}}$)**: $I_{\\text{Na}} = g_{\\text{Na}} m^3 h (V - E_{\\text{Na}})$, where $g_{\\text{Na}} = 120.0 \\ \\text{mS}/\\text{cm}^2$ and $E_{\\text{Na}} = 50.0 \\ \\text{mV}$.\n2.  **Delayed Rectifier Potassium Current ($I_{\\text{K}}$)**: $I_{\\text{K}} = g_{\\text{K}} n^4 (V - E_{\\text{K}})$, where $g_{\\text{K}} = 36.0 \\ \\text{mS}/\\text{cm}^2$ and $E_{\\text{K}} = -77.0 \\ \\text{mV}$.\n3.  **Leak Current ($I_{\\text{L}}$)**: $I_{\\text{L}} = g_{\\text{L}} (V - E_{\\text{L}})$, where $g_{\\text{L}} = 0.3 \\ \\text{mS}/\\text{cm}^2$ and $E_{\\text{L}} = -54.4 \\ \\text{mV}$.\n4.  **Hyperpolarization-Activated Cation Current ($I_h$)**: This is a synthetic current modeled as $I_h = g_h r (V - E_h)$, where $E_h = -30.0 \\ \\text{mV}$. The maximal conductance $g_h$ is a varied parameter.\n\nThe dynamics of these currents are governed by gating variables $m$, $h$, $n$, and $r$, each following first-order kinetics. The complete system of ODEs is:\n$$\n\\frac{dV}{dt} = \\frac{1}{C} \\left( -g_{\\text{Na}} m^3 h (V - E_{\\text{Na}}) - g_{\\text{K}} n^4 (V - E_{\\text{K}}) - g_{\\text{L}} (V - E_{\\text{L}}) - g_h r (V - E_h) \\right)\n$$\n$$\n\\frac{dm}{dt} = \\alpha_m(V)(1-m) - \\beta_m(V)m\n$$\n$$\n\\frac{dh}{dt} = \\alpha_h(V)(1-h) - \\beta_h(V)h\n$$\n$$\n\\frac{dn}{dt} = \\alpha_n(V)(1-n) - \\beta_n(V)n\n$$\n$$\n\\frac{dr}{dt} = \\frac{r_{\\infty}(V) - r}{\\tau_h}\n$$\nThe voltage-dependent rate functions $\\alpha_x(V)$ and $\\beta_x(V)$ for $x \\in \\{m, h, n\\}$, and the steady-state activation $r_{\\infty}(V)$ for the $I_h$ current, are given by:\n$$\n\\alpha_m(V) = 0.1 \\frac{V + 40}{1 - e^{-(V + 40)/10}}, \\quad \\beta_m(V) = 4 e^{-(V + 65)/18}\n$$\n$$\n\\alpha_h(V) = 0.07 e^{-(V + 65)/20}, \\quad \\beta_h(V) = \\frac{1}{1 + e^{-(V + 35)/10}}\n$$\n$$\n\\alpha_n(V) = 0.01 \\frac{V + 55}{1 - e^{-(V + 55)/10}}, \\quad \\beta_n(V) = 0.125 e^{-(V + 65)/80}\n$$\n$$\nr_{\\infty}(V) = \\frac{1}{1 + \\exp\\left(\\frac{V - V_{1/2}}{k}\\right)}\n$$\nwhere $k = 7.0 \\ \\text{mV}$, and $V_{1/2}$ and $\\tau_h$ are varied parameters. The rate functions $\\alpha_m(V)$ and $\\alpha_n(V)$ have removable singularities at $V = -40 \\ \\text{mV}$ and $V = -55 \\ \\text{mV}$, respectively. These are handled by applying L'Hôpital's rule, which yields $\\lim_{V \\to -40} \\alpha_m(V) = 1.0$ and $\\lim_{V \\to -55} \\alpha_n(V) = 0.1$.\n\nThe initial state of the system at $t=0$ is determined by a holding potential $V_{\\text{init}} = -65.0 \\ \\text{mV}$. The initial values of the gating variables are their steady-state values at this potential:\n$$\nV(0) = V_{\\text{init}}\n$$\n$$\nm(0) = m_{\\infty}(V_{\\text{init}}) = \\frac{\\alpha_m(V_{\\text{init}})}{\\alpha_m(V_{\\text{init}}) + \\beta_m(V_{\\text{init}})}\n$$\n$$\nh(0) = h_{\\infty}(V_{\\text{init}}) = \\frac{\\alpha_h(V_{\\text{init}})}{\\alpha_h(V_{\\text{init}}) + \\beta_h(V_{\\text{init}})}\n$$\n$$\nn(0) = n_{\\infty}(V_{\\text{init}}) = \\frac{\\alpha_n(V_{\\text{init}})}{\\alpha_n(V_{\\text{init}}) + \\beta_n(V_{\\text{init}})}\n$$\n$$\nr(0) = r_{\\infty}(V_{\\text{init}})\n$$\n\nThe algorithmic design proceeds in two phases: numerical integration and time-series analysis.\n\n**1. Numerical Integration Algorithm**\nThe system of ODEs is solved numerically using the forward Euler method with a fixed time step of $dt = 0.01 \\ \\text{ms}$ for a total duration of $T = 3000.0 \\ \\text{ms}$. Let the state vector at time step $i$ be $\\mathbf{y}_i = [V_i, m_i, h_i, n_i, r_i]^T$. The state at the next time step, $\\mathbf{y}_{i+1}$, is computed as:\n$\\mathbf{y}_{i+1} = \\mathbf{y}_i + dt \\cdot \\frac{d\\mathbf{y}}{dt}\\bigg|_{\\mathbf{y}_i}$.\nSpecifically, for each variable:\n$$\nV_{i+1} = V_i + \\frac{dt}{C} \\left( -I_{\\text{ion}}(V_i, m_i, h_i, n_i, r_i) \\right)\n$$\n$$\nm_{i+1} = m_i + dt \\cdot (\\alpha_m(V_i)(1-m_i) - \\beta_m(V_i)m_i)\n$$\n$$\nh_{i+1} = h_i + dt \\cdot (\\alpha_h(V_i)(1-h_i) - \\beta_h(V_i)h_i)\n$$\n$$\nn_{i+1} = n_i + dt \\cdot (\\alpha_n(V_i)(1-n_i) - \\beta_n(V_i)n_i)\n$$\n$$\nr_{i+1} = r_i + dt \\cdot \\left(\\frac{r_{\\infty}(V_i) - r_i}{\\tau_h}\\right)\n$$\nThe simulation runs for a total of $N = T/dt = 300,000$ steps, and the membrane potential $V(t)$ is stored at each step for subsequent analysis.\n\n**2. Post-Simulation Analysis Algorithm**\nThe analysis is performed on the voltage trace in an analysis window from $t = 2000.0 \\ \\text{ms}$ to $t = 3000.0 \\ \\text{ms}$.\nFirst, action potentials (spikes) are detected. A spike is registered at time $t_j$ if the membrane potential crosses a threshold of $0.0 \\ \\text{mV}$ in the upward direction, i.e., $V(t_j-dt) < 0.0$ and $V(t_j) \\ge 0.0$.\n\nThe resulting list of spike times within the analysis window is processed according to the following logic:\n-   If the number of detected spikes is $\\ge 3$:\n    1.  The interspike intervals (ISIs) are calculated as the time differences between consecutive spikes.\n    2.  The mean ($\\mu_{ISI}$) and standard deviation ($\\sigma_{ISI}$) of the ISIs are computed.\n    3.  The coefficient of variation, $CV = \\sigma_{ISI} / \\mu_{ISI}$, is calculated.\n    4.  If $CV \\le 0.3$, the firing is considered regular (pacemaker regime). The output is the mean firing frequency in Hertz, calculated as $f = 1000 / \\mu_{ISI}$ (since ISI is in ms).\n    5.  If $CV > 0.3$, the firing is irregular, and the output is $0.0$.\n-   If the number of detected spikes is less than $3$:\n    1.  If there are $0$ spikes, the mean membrane potential, $\\mu_V$, is calculated over the analysis window.\n    2.  If $\\mu_V \\ge -45.0 \\ \\text{mV}$, the neuron is in a state of depolarization block, and the output is the sentinel value $-1.0$.\n    3.  Otherwise (i.e., $0$ spikes and $\\mu_V < -45.0 \\ \\text{mV}$, or $1$ or $2$ spikes), the neuron is considered quiescent or exhibiting non-pacemaker firing, and the output is $0.0$.\n\nThis complete algorithm is applied to each of the parameter sets specified in the test suite to determine the dynamical state of the neuron model.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n\n    # Test cases: (g_h, V_1/2, tau_h)\n    test_cases = [\n        (0.0, -80.0, 200.0),   # Case 1: Control, quiescent\n        (0.05, -80.0, 200.0),  # Case 2: Expected pacemaker\n        (0.20, -80.0, 200.0),  # Case 3: Edge, potential depolarization block\n        (0.05, -70.0, 200.0)   # Case 4: Less hyperpolarized activation\n    ]\n\n    results = []\n    for params in test_cases:\n        result = run_simulation(params)\n        results.append(result)\n\n    # Format output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation of the Hodgkin-Huxley model with an Ih current.\n    \"\"\"\n    g_h, V_half, tau_h = params\n\n    # Fixed parameters\n    C = 1.0  # uF/cm^2\n    g_Na = 120.0  # mS/cm^2\n    g_K = 36.0   # mS/cm^2\n    g_L = 0.3    # mS/cm^2\n    E_Na = 50.0  # mV\n    E_K = -77.0  # mV\n    E_L = -54.4  # mV\n    E_h = -30.0  # mV\n    k_h = 7.0    # mV\n\n    # Rate functions for gating variables\n    def alpha_m(V):\n        if abs(V + 40.0) < 1e-6:\n            return 1.0  # L'Hopital's rule\n        return 0.1 * (V + 40.0) / (1.0 - np.exp(-(V + 40.0) / 10.0))\n\n    def beta_m(V):\n        return 4.0 * np.exp(-(V + 65.0) / 18.0)\n\n    def alpha_h(V):\n        return 0.07 * np.exp(-(V + 65.0) / 20.0)\n\n    def beta_h(V):\n        return 1.0 / (1.0 + np.exp(-(V + 35.0) / 10.0))\n\n    def alpha_n(V):\n        if abs(V + 55.0) < 1e-6:\n            return 0.1 # L'Hopital's rule\n        return 0.01 * (V + 55.0) / (1.0 - np.exp(-(V + 55.0) / 10.0))\n\n    def beta_n(V):\n        return 0.125 * np.exp(-(V + 65.0) / 80.0)\n\n    # Steady-state activation for I_h\n    def r_inf(V):\n        return 1.0 / (1.0 + np.exp((V - V_half) / k_h))\n\n    # Simulation setup\n    dt = 0.01  # ms\n    T = 3000.0 # ms\n    num_steps = int(T / dt)\n    \n    V = np.zeros(num_steps + 1)\n    \n    # Initial conditions\n    V_init = -65.0\n    V[0] = V_init\n    \n    m = alpha_m(V_init) / (alpha_m(V_init) + beta_m(V_init))\n    h = alpha_h(V_init) / (alpha_h(V_init) + beta_h(V_init))\n    n = alpha_n(V_init) / (alpha_n(V_init) + beta_n(V_init))\n    r = r_inf(V_init)\n\n    # Simulation loop\n    for i in range(num_steps):\n        # Calculate ionic currents\n        I_Na = g_Na * m**3 * h * (V[i] - E_Na)\n        I_K = g_K * n**4 * (V[i] - E_K)\n        I_L = g_L * (V[i] - E_L)\n        I_h = g_h * r * (V[i] - E_h)\n        I_total = I_Na + I_K + I_L + I_h\n\n        # Update state variables using forward Euler method\n        V[i+1] = V[i] + (dt / C) * (-I_total)\n        m = m + dt * (alpha_m(V[i]) * (1.0 - m) - beta_m(V[i]) * m)\n        h = h + dt * (alpha_h(V[i]) * (1.0 - h) - beta_h(V[i]) * h)\n        n = n + dt * (alpha_n(V[i]) * (1.0 - n) - beta_n(V[i]) * n)\n        r = r + dt * ((r_inf(V[i]) - r) / tau_h)\n\n    # Analysis\n    analysis_start_index = int(2000.0 / dt)\n    V_analysis = V[analysis_start_index:]\n    \n    # Spike detection\n    spike_times = []\n    spike_threshold = 0.0\n    for i in range(1, len(V_analysis)):\n        if V_analysis[i-1] < spike_threshold and V_analysis[i] >= spike_threshold:\n            spike_time = 2000.0 + i * dt\n            spike_times.append(spike_time)\n            \n    num_spikes = len(spike_times)\n\n    if num_spikes >= 3:\n        isis = np.diff(spike_times)\n        mean_isi = np.mean(isis)\n        std_isi = np.std(isis) # Population std dev (ddof=0 is default)\n        \n        cv = std_isi / mean_isi if mean_isi > 0 else float('inf')\n        \n        if cv <= 0.3:\n            # Pacemaker regime\n            frequency = 1000.0 / mean_isi # ISI in ms -> freq in Hz\n            return round(frequency, 4)\n        else:\n            # Irregular firing\n            return 0.0\n    elif num_spikes == 0:\n        mean_V = np.mean(V_analysis)\n        if mean_V >= -45.0:\n            # Depolarization block\n            return -1.0\n        else:\n            # Quiescence\n            return 0.0\n    else: # 1 or 2 spikes\n        # Not pacemaker firing\n        return 0.0\n\nif __name__ == '__main__':\n    solve()\n```", "id": "5003163"}, {"introduction": "Neuronal communication often relies on complex firing patterns that go beyond simple, regular spiking. One of the most important of these is burst firing, characterized by alternating periods of rapid-fire action potentials and quiescence. This final practice guides you through the simulation and analysis of a minimal conductance-based model that endogenously produces bursting. Your task is to numerically integrate the model's dynamics and then quantify the temporal structure of its output by calculating the burst duty cycle, a key metric representing the fraction of time the neuron spends in the active, firing state. [@problem_id:5003133]", "problem": "You are asked to implement and analyze a minimal conductance-based pacemaker model to quantify the burst duty cycle, grounded in the standard passive membrane equation and first-order gating kinetics. Consider the system\n$$\nC \\frac{dV}{dt} = I_{\\mathrm{app}} + F(V,w), \\quad \\frac{dw}{dt} = G(V,w),\n$$\nwhere\n$$\nF(V,w) = -g_{\\mathrm{Na}}\\,m_{\\infty}(V)\\,(V-E_{\\mathrm{Na}}) - g_{\\mathrm{K}}\\,w\\,(V-E_{\\mathrm{K}}) - g_L\\,(V-E_L),\n$$\nand\n$$\nG(V,w) = \\alpha(V)\\,(1-w) - \\beta(V)\\,w.\n$$\nThe steady-state activation function is\n$$\nm_{\\infty}(V) = \\frac{1}{2}\\left(1+\\tanh\\left(\\frac{V - V_m}{V_k}\\right)\\right),\n$$\nand the voltage-dependent activation and deactivation rates are\n$$\n\\alpha(V) = \\phi\\,\\exp\\left(\\frac{V - V_a}{V_b}\\right), \\quad \\beta(V) = \\phi\\,\\exp\\left(-\\frac{V - V_a}{V_b}\\right).\n$$\nThe model parameters are fixed as\n$$\nC = 20.0,\\quad g_{\\mathrm{Na}}=4.4,\\quad g_{\\mathrm{K}}=8.0,\\quad g_L=2.0,\n$$\n$$\nE_{\\mathrm{Na}}=50.0,\\quad E_{\\mathrm{K}}=-84.0,\\quad E_L=-60.0,\n$$\n$$\nV_m=-1.2,\\quad V_k=18.0,\\quad V_a=2.0,\\quad V_b=30.0,\\quad \\phi=0.04.\n$$\nAll voltages are in millivolts and time is in milliseconds; conductances and currents are in consistent arbitrary units chosen such that the equations are dimensionally coherent. Let the initial condition be $V(0)=-60.0$ and $w(0)=0.0$.\n\nYou must integrate the system numerically over a fixed simulation interval using a fixed time step and a fourth-order Runge–Kutta (RK4) method. Use:\n- Simulation duration: $T_{\\mathrm{sim}}=4000.0\\ \\text{ms}$.\n- Time step: $\\Delta t=0.01\\ \\text{ms}$.\n- Transient discard time: $T_{\\mathrm{discard}}=2000.0\\ \\text{ms}$.\n- Active-state detection threshold: $V_{\\mathrm{th}}=-20.0\\ \\text{mV}$.\n\nDefine the active phase as the set of times where $V(t) > V_{\\mathrm{th}}$ and the silent phase as the set of times where $V(t) \\le V_{\\mathrm{th}}$. Over the post-transient window $[T_{\\mathrm{discard}},T_{\\mathrm{sim}}],$ compute the burst duty cycle as the ratio\n$$\n\\mathcal{D} = \\frac{T_{\\mathrm{active}}}{T_{\\mathrm{silent}}},\n$$\nwhere $T_{\\mathrm{active}}$ and $T_{\\mathrm{silent}}$ denote the total time spent in the active and silent phases, respectively, within the post-transient window. If $T_{\\mathrm{silent}}=0,$ define $\\mathcal{D}=+\\infty.$ The duty cycle $\\mathcal{D}$ is dimensionless. Your numerical estimate must be reported rounded to three decimal places, except that the value $+\\infty$ should be represented as the string produced by your programming language for positive infinity.\n\nFundamental base for modeling:\n- Passive membrane current balance: $C \\frac{dV}{dt} = -I_{\\mathrm{ion}} + I_{\\mathrm{app}},$ where $I_{\\mathrm{ion}}$ is the sum of ionic currents.\n- First-order gating kinetics: $\\frac{dw}{dt} = \\alpha(V)\\,(1-w) - \\beta(V)\\,w.$\n- Steady-state activation and rate functions as defined above.\n\nTask:\n- Implement an RK4 solver with the given parameters.\n- Detect active versus silent phases using $V_{\\mathrm{th}}.$\n- Compute $\\mathcal{D}$ over $[T_{\\mathrm{discard}},T_{\\mathrm{sim}}].$\n- Round to three decimals (standard rounding to nearest, with midpoint ties to the nearest even permitted by typical floating-point behavior).\n\nTest suite:\nEvaluate the duty cycle for the following three parameter sets, which vary only $I_{\\mathrm{app}}$ and share all other parameters as listed above:\n1. Case A (oscillatory/pacemaker regime candidate): $I_{\\mathrm{app}}=90.0.$\n2. Case B (quiescent regime candidate): $I_{\\mathrm{app}}=0.0.$\n3. Case C (tonically active regime candidate): $I_{\\mathrm{app}}=200.0.$\n\nFinal output format:\nYour program should produce a single line of output containing the three duty-cycle results, ordered as Case A, Case B, Case C, as a comma-separated list enclosed in square brackets, for example:\n$$\n[\\mathcal{D}_A,\\mathcal{D}_B,\\mathcal{D}_C].\n$$\nEach $\\mathcal{D}$ should be rounded to three decimals as specified. If $\\mathcal{D}=+\\infty,$ the corresponding entry should be the programming language’s infinity literal. No additional text should be printed.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\nThe problem provides a mathematical model of a neuronal pacemaker, defined by a system of two coupled ordinary differential equations (ODEs):\n1.  **Membrane Potential Dynamics**:\n    $$C \\frac{dV}{dt} = I_{\\mathrm{app}} + F(V,w)$$\n2.  **Gating Variable Dynamics**:\n    $$\\frac{dw}{dt} = G(V,w)$$\n\nThe functions $F(V,w)$ and $G(V,w)$ are defined as:\n$$F(V,w) = -g_{\\mathrm{Na}}\\,m_{\\infty}(V)\\,(V-E_{\\mathrm{Na}}) - g_{\\mathrm{K}}\\,w\\,(V-E_{\\mathrm{K}}) - g_L\\,(V-E_L)$$\n$$G(V,w) = \\alpha(V)\\,(1-w) - \\beta(V)\\,w$$\n\nThe auxiliary functions for steady-state activation and voltage-dependent rates are:\n$$m_{\\infty}(V) = \\frac{1}{2}\\left(1+\\tanh\\left(\\frac{V - V_m}{V_k}\\right)\\right)$$\n$$\\alpha(V) = \\phi\\,\\exp\\left(\\frac{V - V_a}{V_b}\\right)$$\n$$\\beta(V) = \\phi\\,\\exp\\left(-\\frac{V - V_a}{V_b}\\right)$$\n\nA fixed set of parameters is provided:\n- Capacitance: $C = 20.0$\n- Conductances: $g_{\\mathrm{Na}}=4.4$, $g_{\\mathrm{K}}=8.0$, $g_L=2.0$\n- Reversal Potentials: $E_{\\mathrm{Na}}=50.0$ mV, $E_{\\mathrm{K}}=-84.0$ mV, $E_L=-60.0$ mV\n- Gating Parameters: $V_m=-1.2$ mV, $V_k=18.0$ mV, $V_a=2.0$ mV, $V_b=30.0$ mV, $\\phi=0.04$\n\nThe initial conditions for the system at time $t=0$ are:\n$$V(0)=-60.0 \\text{ mV}, \\quad w(0)=0.0$$\n\nThe numerical simulation and analysis protocol is specified as:\n- Numerical method: Fourth-order Runge–Kutta (RK4)\n- Simulation duration: $T_{\\mathrm{sim}}=4000.0$ ms\n- Time step: $\\Delta t=0.01$ ms\n- Transient discard time: $T_{\\mathrm{discard}}=2000.0$ ms\n- Active state threshold: $V_{\\mathrm{th}}=-20.0$ mV\n\nThe quantity to be computed is the burst duty cycle $\\mathcal{D}$ over the interval $[T_{\\mathrm{discard}}, T_{\\mathrm{sim}}]$:\n$$\\mathcal{D} = \\frac{T_{\\mathrm{active}}}{T_{\\mathrm{silent}}}$$\nwhere $T_{\\mathrm{active}}$ is the total time with $V(t) > V_{\\mathrm{th}}$ and $T_{\\mathrm{silent}}$ is the total time with $V(t) \\le V_{\\mathrm{th}}$. A special case is defined: if $T_{\\mathrm{silent}}=0$, then $\\mathcal{D}=+\\infty$.\n\nThe task is to evaluate $\\mathcal{D}$ for three test cases, varying only the applied current $I_{\\mathrm{app}}$:\n- Case A: $I_{\\mathrm{app}}=90.0$\n- Case B: $I_{\\mathrm{app}}=0.0$\n- Case C: $I_{\\mathrm{app}}=200.0$\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem is subjected to validation against the specified criteria:\n- **Scientifically Grounded**: The model is a simplified conductance-based model of the Hodgkin–Huxley type, a cornerstone of computational neuroscience. The equations for membrane potential dynamics (passive membrane equation with ionic currents) and first-order gating kinetics are fundamental principles in the field. The functional forms for activation and rate constants (sigmoidal and exponential) are standard and biophysically motivated. The problem is scientifically sound.\n- **Well-Posed**: The problem is an initial value problem (IVP) for a system of two first-order ODEs. The right-hand side functions, $F(V,w)$ and $G(V,w)$, are smooth (infinitely differentiable) in their arguments $V$ and $w$. By the Picard–Lindelöf theorem, a unique solution exists and is continuous. The task requires a numerical approximation over a finite interval, which is a standard and well-defined computational task. The definition of the target metric, $\\mathcal{D}$, is precise, including its behavior in the edge case of $T_{\\mathrm{silent}}=0$.\n- **Objective**: The problem is stated in precise, mathematical language. All quantities are defined, and the task is a purely computational exercise based on these definitions. There are no subjective or ambiguous statements.\n- **Completeness and Consistency**: All parameters, initial conditions, and procedural details required to solve the problem are explicitly provided. There are no missing data points or contradictory constraints. The units are stated to be consistent.\n\n### Step 3: Verdict and Action\n\nThe problem is valid. It is a well-posed, scientifically grounded, and fully specified problem in computational neurobiology. I will proceed with formulating and implementing the solution.\n\n## Solution\n\nThe solution involves numerically integrating the given system of ODEs and then analyzing the resulting voltage trajectory to compute the specified duty cycle, $\\mathcal{D}$. This process is repeated for three different values of the applied current, $I_{\\text{app}}$.\n\n### 1. Mathematical Formulation\nThe system to be solved is a pair of coupled first-order ODEs for the state vector $Y(t) = [V(t), w(t)]^T$:\n$$\n\\frac{dY}{dt} = f(Y; I_{\\text{app}}) = \\begin{bmatrix} \\frac{1}{C} \\left( I_{\\text{app}} -g_{\\mathrm{Na}}\\,m_{\\infty}(V)\\,(V-E_{\\mathrm{Na}}) - g_{\\mathrm{K}}\\,w\\,(V-E_{\\mathrm{K}}) - g_L\\,(V-E_L) \\right) \\\\ \\alpha(V)\\,(1-w) - \\beta(V)\\,w \\end{bmatrix}\n$$\nAll parameters and auxiliary functions are as defined in the problem statement.\n\n### 2. Numerical Integration: Fourth-Order Runge-Kutta (RK4)\nThe system is integrated from the initial condition $Y_0 = [V(0), w(0)]^T = [-60.0, 0.0]^T$ using the RK4 method with a fixed time step $\\Delta t = 0.01$ ms. For each step from time $t_n$ to $t_{n+1} = t_n + \\Delta t$, the state vector $Y_{n+1}$ is calculated from $Y_n$ as follows:\n$$Y_{n+1} = Y_n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\nwhere the intermediate slopes are:\n$$\n\\begin{aligned}\nk_1 &= f(Y_n; I_{\\text{app}}) \\\\\nk_2 &= f(Y_n + \\frac{\\Delta t}{2} k_1; I_{\\text{app}}) \\\\\nk_3 &= f(Y_n + \\frac{\\Delta t}{2} k_2; I_{\\text{app}}) \\\\\nk_4 &= f(Y_n + \\Delta t k_3; I_{\\text{app}})\n\\end{aligned}\n$$\nThis iterative process is repeated for the entire simulation duration $T_{\\text{sim}} = 4000.0$ ms, generating a discrete time series of the membrane potential, $V(t_i)$, where $t_i = i \\Delta t$.\n\n### 3. Duty Cycle Calculation\nThe duty cycle, $\\mathcal{D}$, is calculated over the post-transient analysis window $[T_{\\mathrm{discard}}, T_{\\mathrm{sim}}]$, which spans from $t=2000.0$ ms to $t=4000.0$ ms.\nThe discrete voltage trajectory $V(t_i)$ within this window is analyzed. The analysis window consists of a sequence of time intervals of duration $\\Delta t$. For each such interval beginning at time $t_i$, the state of the system is classified based on the voltage $V(t_i)$:\n-   If $V(t_i) > V_{\\mathrm{th}} = -20.0$ mV, the interval is classified as **active**.\n-   If $V(t_i) \\le V_{\\mathrm{th}} = -20.0$ mV, the interval is classified as **silent**.\n\nThe total time spent in each phase is computed by summing the durations of the corresponding intervals:\n$$T_{\\mathrm{active}} = (\\text{number of active intervals}) \\times \\Delta t$$\n$$T_{\\mathrm{silent}} = (\\text{number of silent intervals}) \\times \\Delta t$$\nThe total duration of the analysis window is $T_{\\mathrm{sim}} - T_{\\mathrm{discard}} = 2000.0$ ms, so $T_{\\mathrm{active}} + T_{\\mathrm{silent}} = 2000.0$ ms.\n\nThe duty cycle is then computed as the ratio:\n$$\\mathcal{D} = \\frac{T_{\\mathrm{active}}}{T_{\\mathrm{silent}}}$$\nIn the case where all intervals in the analysis window are active, $T_{\\mathrm{silent}}$ will be $0$. As specified, the duty cycle is then defined as $\\mathcal{D} = +\\infty$.\n\n### 4. Implementation for Test Cases\nThe entire procedure—from RK4 integration to duty cycle calculation—is encapsulated and executed for each of the three provided test cases for $I_{\\text{app}}$: $90.0$ (Case A), $0.0$ (Case B), and $200.0$ (Case C). The final numerical results are rounded to three decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the full solution to the pacemaker model problem.\n    It simulates the neuron dynamics for three different applied currents\n    and calculates the burst duty cycle for each case.\n    \"\"\"\n    \n    # --- Model Parameters ---\n    # These are shared across all test cases.\n    params = {\n        'C': 20.0, 'g_Na': 4.4, 'g_K': 8.0, 'g_L': 2.0,\n        'E_Na': 50.0, 'E_K': -84.0, 'E_L': -60.0,\n        'V_m': -1.2, 'V_k': 18.0, 'V_a': 2.0, 'V_b': 30.0, 'phi': 0.04\n    }\n\n    # --- Simulation Parameters ---\n    T_sim = 4000.0\n    dt = 0.01\n    T_discard = 2000.0\n    V_th = -20.0\n    V0 = -60.0\n    w0 = 0.0\n\n    # --- Helper Functions for the Model Gating Variables and Currents ---\n    def m_inf(V, p):\n        return 0.5 * (1.0 + np.tanh((V - p['V_m']) / p['V_k']))\n\n    def alpha(V, p):\n        return p['phi'] * np.exp((V - p['V_a']) / p['V_b'])\n\n    def beta(V, p):\n        return p['phi'] * np.exp(-(V - p['V_a']) / p['V_b'])\n\n    # --- ODE System Definition ---\n    # This function calculates the derivatives dV/dt and dw/dt.\n    def derivatives(state, I_app, p):\n        V, w = state\n        \n        # dV/dt component based on ionic currents\n        I_Na = p['g_Na'] * m_inf(V, p) * (V - p['E_Na'])\n        I_K = p['g_K'] * w * (V - p['E_K'])\n        I_L = p['g_L'] * (V - p['E_L'])\n        dVdt = (I_app - I_Na - I_K - I_L) / p['C']\n        \n        # dw/dt component based on gating kinetics\n        a_V = alpha(V, p)\n        b_V = beta(V, p)\n        dwdt = a_V * (1.0 - w) - b_V * w\n        \n        return np.array([dVdt, dwdt])\n\n    # --- Main Solver and Analysis Function ---\n    def run_simulation_and_analyze(I_app, p):\n        \"\"\"\n        Runs a single RK4 simulation and computes the duty cycle.\n        \"\"\"\n        # Initialization\n        num_steps = int(T_sim / dt)\n        V_trace = np.zeros(num_steps + 1)\n        \n        state = np.array([V0, w0])\n        V_trace[0] = state[0]\n        \n        # RK4 Integration Loop\n        for i in range(num_steps):\n            k1 = derivatives(state, I_app, p)\n            k2 = derivatives(state + 0.5 * dt * k1, I_app, p)\n            k3 = derivatives(state + 0.5 * dt * k2, I_app, p)\n            k4 = derivatives(state + dt * k3, I_app, p)\n            \n            state += (dt / 6.0) * (k1 + 2.0*k2 + 2.0*k3 + k4)\n            V_trace[i+1] = state[0]\n            \n        # Post-transient analysis\n        discard_index = int(T_discard / dt)\n        # The analysis window includes time points from T_discard up to (and including) T_sim.\n        analysis_v_values = V_trace[discard_index:]\n        \n        num_active_intervals = np.sum(analysis_v_values > V_th)\n        num_silent_intervals = len(analysis_v_values) - num_active_intervals\n        \n        T_active = num_active_intervals * dt\n        T_silent = num_silent_intervals * dt\n        \n        # Compute Duty Cycle\n        if T_silent == 0.0:\n            duty_cycle = float('inf')\n        else:\n            duty_cycle = T_active / T_silent\n        \n        return duty_cycle\n\n    # --- Run Test Suite ---\n    test_cases = [\n        90.0,   # Case A\n        0.0,    # Case B\n        200.0,  # Case C\n    ]\n    results = []\n\n    for i_app in test_cases:\n        duty_cycle = run_simulation_and_analyze(i_app, params)\n        if duty_cycle == float('inf'):\n            results.append(str(duty_cycle))\n        else:\n            results.append(f\"{duty_cycle:.3f}\")\n            \n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "5003133"}]}