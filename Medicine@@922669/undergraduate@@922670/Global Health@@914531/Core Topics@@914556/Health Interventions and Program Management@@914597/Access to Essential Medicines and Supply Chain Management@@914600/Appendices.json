{"hands_on_practices": [{"introduction": "Effective supply chain management begins with an accurate prediction of future needs. This exercise introduces a fundamental forecasting technique, the moving average, which helps smooth out demand fluctuations to create a stable estimate. By applying this method and calculating its error, you will practice the essential skills of both predicting and evaluating demand forecasts for essential medicines [@problem_id:4967326].", "problem": "A district health supply team is planning inventory for an essential antibiotic to minimize stockouts while avoiding overstock. Monthly consumption data for the last $6$ months are recorded as $[1000, 1100, 900, 1200, 1300, 1100]$ doses, corresponding to months $1$ through $6$. The team uses a $3$-month moving average demand forecasting model to plan the next month. Using this model and the provided data, determine the forecast for month $7$ in doses. Additionally, evaluate the accuracy of this model over months $4$ through $6$ by computing the Mean Absolute Percentage Error (MAPE), defined as the mean of the absolute percentage errors across the evaluation months.\n\nExpress the forecast for month $7$ in doses. Express the Mean Absolute Percentage Error (MAPE) as a decimal fraction, and round the MAPE to $4$ significant figures.", "solution": "In supply chain management for essential medicines, demand forecasting and error evaluation are grounded in arithmetic averages and proportional error measures. Let $D_t$ denote the actual consumption in doses in month $t$, and let $\\hat{D}_t$ denote the forecast for month $t$ produced by the $k$-month moving average model. For a $3$-month moving average, the model uses the arithmetic mean of the most recent $3$ realized values to produce the forecast for the next month. Formally, for $k=3$, the moving average forecast is\n$$\n\\hat{D}_{t} = \\frac{1}{3}\\left(D_{t-1} + D_{t-2} + D_{t-3}\\right),\n$$\napplicable for $t \\geq 4$ when the prior $3$ months are available.\n\nThe data are $D_1 = 1000$, $D_2 = 1100$, $D_3 = 900$, $D_4 = 1200$, $D_5 = 1300$, $D_6 = 1100$.\n\nFirst, compute the forecasts needed to evaluate model accuracy for months $4$ through $6$, and then compute the forecast for month $7$.\n\n- For month $4$:\n$$\n\\hat{D}_4 = \\frac{1}{3}\\left(D_3 + D_2 + D_1\\right) = \\frac{1}{3}\\left(900 + 1100 + 1000\\right) = \\frac{3000}{3} = 1000.\n$$\n\n- For month $5$:\n$$\n\\hat{D}_5 = \\frac{1}{3}\\left(D_4 + D_3 + D_2\\right) = \\frac{1}{3}\\left(1200 + 900 + 1100\\right) = \\frac{3200}{3}.\n$$\n\n- For month $6$:\n$$\n\\hat{D}_6 = \\frac{1}{3}\\left(D_5 + D_4 + D_3\\right) = \\frac{1}{3}\\left(1300 + 1200 + 900\\right) = \\frac{3400}{3}.\n$$\n\n- For month $7$ (the required planning forecast):\n$$\n\\hat{D}_7 = \\frac{1}{3}\\left(D_6 + D_5 + D_4\\right) = \\frac{1}{3}\\left(1100 + 1300 + 1200\\right) = \\frac{3600}{3} = 1200.\n$$\n\nNext, compute the Mean Absolute Percentage Error (MAPE) for months $4$ through $6$. The Mean Absolute Percentage Error (MAPE) over $n$ evaluation periods is defined by\n$$\n\\text{MAPE} = \\frac{1}{n}\\sum_{t}\\left|\\frac{D_t - \\hat{D}_t}{D_t}\\right|,\n$$\nwhere the sum runs over the set of evaluation months. Here, $n = 3$ and $t \\in \\{4, 5, 6\\}$.\n\nCompute each absolute percentage error:\n\n- For month $4$:\n$$\n\\left|\\frac{D_4 - \\hat{D}_4}{D_4}\\right| = \\left|\\frac{1200 - 1000}{1200}\\right| = \\frac{200}{1200} = \\frac{1}{6}.\n$$\n\n- For month $5$:\n$$\n\\left|\\frac{D_5 - \\hat{D}_5}{D_5}\\right| = \\left|\\frac{1300 - \\frac{3200}{3}}{1300}\\right|.\n$$\nRewrite $1300$ as $\\frac{3900}{3}$:\n$$\n\\left|\\frac{\\frac{3900}{3} - \\frac{3200}{3}}{1300}\\right| = \\left|\\frac{\\frac{700}{3}}{1300}\\right| = \\frac{700}{3900} = \\frac{7}{39}.\n$$\n\n- For month $6$:\n$$\n\\left|\\frac{D_6 - \\hat{D}_6}{D_6}\\right| = \\left|\\frac{1100 - \\frac{3400}{3}}{1100}\\right|.\n$$\nRewrite $1100$ as $\\frac{3300}{3}$:\n$$\n\\left|\\frac{\\frac{3300}{3} - \\frac{3400}{3}}{1100}\\right| = \\left|\\frac{\\frac{-100}{3}}{1100}\\right| = \\frac{100}{3300} = \\frac{1}{33}.\n$$\n\nAverage these three values to obtain MAPE:\n$$\n\\text{MAPE} = \\frac{1}{3}\\left(\\frac{1}{6} + \\frac{7}{39} + \\frac{1}{33}\\right).\n$$\nFind a common denominator for the sum inside the parentheses. The least common multiple of $6$, $39$, and $33$ is $858$. Convert each fraction:\n$$\n\\frac{1}{6} = \\frac{143}{858},\\quad \\frac{7}{39} = \\frac{154}{858},\\quad \\frac{1}{33} = \\frac{26}{858}.\n$$\nSum:\n$$\n\\frac{143}{858} + \\frac{154}{858} + \\frac{26}{858} = \\frac{323}{858}.\n$$\nDivide by $3$:\n$$\n\\text{MAPE} = \\frac{1}{3}\\cdot\\frac{323}{858} = \\frac{323}{2574}.\n$$\nThis fraction is already in lowest terms because $323 = 17 \\times 19$ and $2574 = 2 \\times 3 \\times 3 \\times 11 \\times 13$ share no common prime factors. Convert to a decimal and round to $4$ significant figures:\n$$\n\\frac{323}{2574} \\approx 0.1254856\\ \\Rightarrow\\ \\text{MAPE} \\approx 0.1255\\ \\text{(rounded to $4$ significant figures)}.\n$$\n\nTherefore, the $3$-month moving average forecast for month $7$ is $1200$ doses, and the Mean Absolute Percentage Error (MAPE) over months $4$ through $6$ under this model is $0.1255$ as a decimal fraction rounded to $4$ significant figures.", "answer": "$$\\boxed{\\begin{pmatrix}1200 & 0.1255\\end{pmatrix}}$$", "id": "4967326"}, {"introduction": "Once demand is forecasted, a health facility must decide how much inventory to order and when. This problem guides you through the Economic Order Quantity (EOQ) model, a cornerstone of inventory theory that provides a mathematical basis for balancing ordering costs against holding costs. You will determine the optimal order size and the reorder point to create a cost-efficient and responsive inventory policy [@problem_id:4967285].", "problem": "A district health warehouse is responsible for assuring continuous availability of a single essential antibiotic to public clinics. The warehouse follows a continuous-review policy in which an order of fixed size is placed whenever the on-hand inventory position reaches a reorder point. Assume the classical deterministic conditions for the Economic Order Quantity (EOQ): constant demand rate, fixed setup cost per order, constant holding cost per unit per year, no stockouts, and instantaneous receipt of orders upon arrival. The annual demand is $D=120{,}000$ units/year, the fixed ordering cost is $S=50$ United States Dollars (USD)/order, and the annual holding cost is $H=1$ USD/unit/year. The facility operates $300$ days per year, the average daily demand is $400$ units/day, and the lead time is a constant $10$ days.\n\nStarting from the fundamental definitions of annual ordering cost and annual holding cost implied by these assumptions, derive the order quantity that minimizes the annual total cost, then compute:\n- the EOQ in units,\n- the reorder point for the given lead time in units,\n- and the annual number of orders.\n\nRound all numerical results to four significant figures. Express the EOQ and the reorder point in units, and express the annual number of orders in orders per year.", "solution": "The problem is first validated against the required criteria.\n\n### Problem Validation\n\n#### Step 1: Extract Givens\nThe problem provides the following information:\n-   Annual demand: $D=120,000$ units/year\n-   Fixed ordering cost: $S=50$ USD/order\n-   Annual holding cost per unit: $H=1$ USD/unit/year\n-   Operating schedule: $300$ days/year\n-   Average daily demand: $d=400$ units/day\n-   Lead time: $L=10$ days\n-   Model assumptions: Classical deterministic conditions for the Economic Order Quantity (EOQ) model are assumed. This implies a constant demand rate, no stockouts, fixed and known costs, and instantaneous replenishment of inventory upon order arrival (though a non-zero lead time for placing the order is given).\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is subjected to scrutiny based on the established validation criteria.\n-   **Scientifically Grounded**: The problem is based on the Economic Order Quantity (EOQ) model, a foundational and scientifically sound principle in the field of operations research and inventory management. The assumptions listed are the standard idealizations for the basic model.\n-   **Well-Posed**: The problem is well-posed. It requires the minimization of a cost function for which a unique minimum is known to exist. All necessary parameters ($D$, $S$, $H$, $d$, $L$) are provided and are sufficient to determine the required quantities (EOQ, reorder point, and number of orders).\n-   **Objective**: The problem is formulated with clear, objective, and unambiguous quantitative data and instructions.\n-   **Incomplete or Contradictory Setup**: The given data are internally consistent. The annual demand $D=120,000$ units is correctly related to the daily demand $d=400$ units and the number of operating days ($400 \\text{ units/day} \\times 300 \\text{ days/year} = 120,000 \\text{ units/year}$). The problem is self-contained.\n-   **Unrealistic or Infeasible**: While the assumptions of the EOQ model are an idealization of reality, they are explicitly stated for the purpose of applying the classical model. The numerical values are plausible within the given context.\n\n#### Step 3: Verdict and Action\nThe problem is valid as it is scientifically sound, well-posed, objective, and internally consistent. A complete solution will be provided.\n\n### Solution Derivation and Calculation\n\nThe objective is to find the order quantity, denoted by $Q$, that minimizes the total annual cost associated with inventory management. The total annual cost, $TC(Q)$, is the sum of the annual ordering cost and the annual holding cost.\n\n1.  **Derivation of the Economic Order Quantity (EOQ)**\n    The annual ordering cost is the number of orders placed per year multiplied by the fixed cost per order, $S$. The number of orders per year is the total annual demand, $D$, divided by the order quantity, $Q$.\n    $$\n    \\text{Annual Ordering Cost} = S \\times \\frac{D}{Q}\n    $$\n    The annual holding cost is the average inventory level multiplied by the annual cost to hold one unit in inventory, $H$. In the classic EOQ model, inventory depletes linearly from $Q$ to $0$, so the average inventory level is $\\frac{Q}{2}$.\n    $$\n    \\text{Annual Holding Cost} = H \\times \\frac{Q}{2}\n    $$\n    The total annual cost, $TC(Q)$, is the sum of these two costs:\n    $$\n    TC(Q) = \\frac{SD}{Q} + \\frac{HQ}{2}\n    $$\n    To find the order quantity $Q$ that minimizes $TC(Q)$, we must compute the first derivative of $TC(Q)$ with respect to $Q$ and set it to zero.\n    $$\n    \\frac{d(TC)}{dQ} = \\frac{d}{dQ} \\left( \\frac{SD}{Q} + \\frac{HQ}{2} \\right) = -\\frac{SD}{Q^2} + \\frac{H}{2}\n    $$\n    Setting the derivative to zero to find the critical point:\n    $$\n    -\\frac{SD}{Q^2} + \\frac{H}{2} = 0 \\implies \\frac{H}{2} = \\frac{SD}{Q^2}\n    $$\n    Solving for $Q$:\n    $$\n    Q^2 = \\frac{2SD}{H}\n    $$\n    $$\n    Q = \\sqrt{\\frac{2SD}{H}}\n    $$\n    This optimal order quantity is the Economic Order Quantity, or $EOQ$. To confirm that this value of $Q$ corresponds to a minimum, we check the second derivative:\n    $$\n    \\frac{d^2(TC)}{dQ^2} = \\frac{d}{dQ} \\left( -\\frac{SD}{Q^2} + \\frac{H}{2} \\right) = \\frac{2SD}{Q^3}\n    $$\n    Since $S$, $D$, and $Q$ are all positive quantities, $\\frac{d^2(TC)}{dQ^2} > 0$, which confirms that the cost function is convex and the calculated $Q$ is a unique minimum.\n\n2.  **Calculation of the EOQ**\n    Substituting the given values $D=120,000$ units/year, $S=50$ USD/order, and $H=1$ USD/unit/year into the derived formula:\n    $$\n    EOQ = \\sqrt{\\frac{2 \\times 50 \\times 120,000}{1}} = \\sqrt{12,000,000} \\approx 3464.1016 \\text{ units}\n    $$\n    Rounding to four significant figures, the EOQ is $3464$ units.\n\n3.  **Calculation of the Reorder Point (ROP)**\n    The reorder point is the inventory level at which a new order should be placed. Since the lead time $L$ is constant and the demand rate $d$ is constant, the ROP is the demand during the lead time.\n    $$\n    ROP = d \\times L\n    $$\n    Substituting the given values $d=400$ units/day and $L=10$ days:\n    $$\n    ROP = 400 \\frac{\\text{units}}{\\text{day}} \\times 10 \\text{ days} = 4000 \\text{ units}\n    $$\n    This value is exact. To express it with four significant figures as requested, it can be written in scientific notation as $4.000 \\times 10^3$ units.\n\n4.  **Calculation of the Annual Number of Orders**\n    The annual number of orders, $N$, is the total annual demand divided by the order quantity. For an optimal policy, we use the $EOQ$.\n    $$\n    N = \\frac{D}{EOQ}\n    $$\n    Using the unrounded value of the $EOQ$ for higher precision in the calculation:\n    $$\n    N = \\frac{120,000}{\\sqrt{12,000,000}} \\approx 34.641016 \\text{ orders/year}\n    $$\n    Rounding to four significant figures, the annual number of orders is $34.64$ orders/year.\n\nThe required values are:\n-   EOQ: $3464$ units\n-   Reorder point: $4000$ units\n-   Annual number of orders: $34.64$ orders/year", "answer": "$$\n\\boxed{\\begin{pmatrix} 3464 & 4.000 \\times 10^3 & 34.64 \\end{pmatrix}}\n$$", "id": "4967285"}, {"introduction": "The final link in the supply chain—delivering medicines from a central depot to various health clinics—is a complex logistical puzzle. This practice tackles the Vehicle Routing Problem (VRP), challenging you to design efficient delivery routes that minimize travel distance while adhering to vehicle capacity limits. Implementing a widely-used heuristic will provide hands-on experience in solving the kind of \"last-mile\" distribution challenges that are critical to ensuring access to medicines [@problem_id:4967304].", "problem": "A public health logistics team must deliver essential medicine parcels from a single central depot to a set of clinics, subject to vehicle capacity constraints. Formulate and implement a constructive heuristic to produce an approximate capacitated Vehicle Routing Problem (VRP) plan that minimizes total travel distance. The setting is a single-depot scenario in which identical vehicles with limited capacity depart from and return to the depot, serving each clinic exactly once, and cannot exceed capacity when aggregating clinic demands on a route. All distances must be computed in kilometers and the final total distances must be expressed in kilometers, rounded to two decimal places.\n\nUse the following fundamental base without any shortcut formulas:\n- The Euclidean distance between two points with Cartesian coordinates is defined by $d((x_1,y_1),(x_2,y_2)) = \\sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}$.\n- The triangle inequality asserts $d(a,b) \\le d(a,c) + d(c,b)$ for any points $a$, $b$, and $c$.\n- The objective is the minimization of the sum of route lengths expressed as $\\sum_{r} \\left( d(o, v_{r,1}) + \\sum_{k=1}^{m_r - 1} d(v_{r,k}, v_{r,k+1}) + d(v_{r,m_r}, o) \\right)$, where $o$ is the depot, $r$ indexes routes, and $v_{r,1},\\dots,v_{r,m_r}$ are the clinics served in route $r$.\n- A route’s total load is the sum of clinic demands on that route, and must not exceed the vehicle capacity.\n\nDesign and implement a heuristic based on merging initially separate depot-to-clinic routes in a way that leverages the triangle inequality to reduce total distance while respecting capacity constraints. Your algorithm must only merge routes at their endpoints and must never violate capacity constraints. The result is a set of feasible routes whose total distance approximates the minimum.\n\nYour program must compute the total distance of the heuristic plan for each test case below. Distances must be expressed in kilometers and rounded to two decimal places. The test suite covers three scenarios to probe different aspects of the heuristic’s behavior: a clustered urban case, a case with one clinic demanding exactly the full vehicle capacity, and a dispersed rural case.\n\nCommon parameters across all test cases:\n- Vehicle capacity: $1{,}000$ units per vehicle.\n- Distance metric: Euclidean distance as defined above.\n- Each clinic demand is strictly positive and does not exceed the vehicle capacity.\n\nTest Case A (clustered urban clinics):\n- Depot coordinate: $(0.0, 0.0)$ kilometers.\n- Clinic coordinates (kilometers):\n  $[(2.0, 1.0), (3.5, -0.5), (-1.2, 4.0), (0.5, 3.2), (4.0, 3.8), (-2.5, 2.5), (1.5, -2.0), (-3.0, -1.0), (2.2, 2.2), (0.0, -3.5), (3.0, 0.8), (-1.8, 3.5)]$.\n- Clinic demands (units):\n  $[120, 80, 150, 90, 200, 110, 60, 70, 140, 130, 95, 55]$.\n\nTest Case B (one clinic at full capacity):\n- Depot coordinate: $(10.0, -5.0)$ kilometers.\n- Clinic coordinates (kilometers):\n  $[(11.0, -4.0), (12.0, -3.0), (9.0, -6.0), (8.0, -5.5), (10.5, -4.5), (13.0, -2.0), (7.5, -4.0), (12.5, -6.0), (9.5, -7.0), (11.0, -6.0), (10.0, -3.0), (50.0, -20.0)]$.\n- Clinic demands (units):\n  $[60, 45, 55, 50, 40, 35, 65, 70, 45, 60, 25, 1000]$.\n\nTest Case C (dispersed rural clinics):\n- Depot coordinate: $(-20.0, 30.0)$ kilometers.\n- Clinic coordinates (kilometers):\n  $[(-10.0, 25.0), (-25.0, 35.0), (-30.0, 20.0), (-5.0, 40.0), (-15.0, 45.0), (-35.0, 32.0), (-28.0, 12.0), (-12.0, 15.0), (-22.0, 55.0), (-40.0, 10.0), (-7.0, 28.0), (-18.0, 38.0)]$.\n- Clinic demands (units):\n  $[220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220]$.\n\nOutput specification:\n- For each test case, compute the sum of route lengths (in kilometers) produced by your heuristic.\n- Express each sum in kilometers rounded to two decimal places.\n- Your program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example: $[x_A, x_B, x_C]$, where $x_A$, $x_B$, and $x_C$ are the rounded floats for Test Cases A, B, and C respectively.", "solution": "The user's request is to solve a capacitated Vehicle Routing Problem (VRP) using a specified constructive heuristic. The problem is scientifically grounded in the field of operations research, is well-posed, and all necessary data and constraints are provided. The problem is therefore deemed valid. The following solution outlines the methodology and implementation of the specified heuristic.\n\nThe problem is a classic capacitated Vehicle Routing Problem (VRP), where the objective is to design a set of vehicle routes to serve a number of customers (clinics) from a central depot, minimizing the total travel distance, subject to vehicle capacity constraints. The problem asks for the implementation of a specific constructive heuristic, which is a variant of the well-known Clarke and Wright savings algorithm.\n\nThe fundamental principle of this heuristic is to begin with a baseline, trivial solution and iteratively improve it by merging routes in a greedy fashion. The \"saving\" in distance achieved by a merge is used to prioritize which merges to perform.\n\n1.  **Initialization**: The heuristic starts with a feasible but highly suboptimal solution where each clinic $c_i$ is served by a dedicated vehicle. This corresponds to a set of routes, each of the form `depot -> clinic_i -> depot`. The total load on each route is simply the demand of the single clinic, which is guaranteed by the problem statement to not exceed the vehicle capacity. The total distance of this initial plan is the sum of the lengths of all these individual round trips: $D_{initial} = \\sum_{i=1}^{N} (d(o, c_i) + d(c_i, o)) = \\sum_{i=1}^{N} 2 \\cdot d(o, c_i)$, where $o$ is the depot, $c_i$ represents the $i$-th clinic, $N$ is the total number of clinics, and $d(a,b)$ is the Euclidean distance between points $a$ and $b$.\n\n2.  **Savings Calculation**: The core of the algorithm lies in the \"savings\" calculation. The saving $S_{ij}$ represents the reduction in total distance if the separate routes for clinics $c_i$ and $c_j$ are merged. Consider two initial routes, `depot -> c_i -> depot` and `depot -> c_j -> depot`. Their combined distance is $2 \\cdot d(o, c_i) + 2 \\cdot d(o, c_j)$. If they are merged into a single route, `depot -> c_i -> c_j -> depot`, the new distance is $d(o, c_i) + d(c_i, c_j) + d(c_j, o)$. The saving is the difference:\n    $$ S_{ij} = (d(o, c_i) + d(c_i, o)) + (d(o, c_j) + d(c_j, o)) - (d(o, c_i) + d(c_i, c_j) + d(c_j, o)) $$\n    Given that Euclidean distance is symmetric ($d(a,b) = d(b,a)$), this simplifies to:\n    $$ S_{ij} = d(o, c_i) + d(o, c_j) - d(c_i, c_j) $$\n    This formula quantifies the distance saved by linking $c_i$ and $c_j$ directly, eliminating two trips to and from the depot. The triangle inequality, $d(c_i, c_j) \\le d(c_i, o) + d(o, c_j)$, guarantees that $S_{ij} \\ge 0$.\n\n3.  **Algorithmic Procedure**: The heuristic is implemented via the following steps:\n    -   **Step 1: Compute Savings**: Calculate the saving $S_{ij}$ for all distinct pairs of clinics $(c_i, c_j)$.\n    -   **Step 2: Sort Savings**: Create a list of all potential merges, ordered by their saving values in descending order. This greedy approach ensures that the most beneficial merges are considered first.\n    -   **Step 3: Initialize Routes**: As described above, begin with one route for each clinic. We maintain a data structure for each route that tracks its path (an ordered sequence of clinic indices) and its cumulative load.\n    -   **Step 4: Iterative Merging**: The algorithm processes the sorted savings list. For each saving $S_{ij}$, it attempts to merge the routes containing clinics $c_i$ and $c_j$. A merge is executed only if it is feasible, which requires satisfying three conditions:\n        1.  **Distinct Routes**: Clinics $c_i$ and $c_j$ must currently be in different routes.\n        2.  **Capacity Constraint**: The sum of the loads of the two routes must not exceed the vehicle capacity.\n        3.  **Endpoint Constraint**: Both $c_i$ and $c_j$ must be endpoints of their respective routes. This is a critical constraint because the savings formula $S_{ij}$ is derived based on eliminating the depot-to-clinic links, which only occurs for clinics at the ends of a route path.\n    -   **Step 5: Route Fusion**: If a merge is feasible, the two routes are combined. This may involve reversing one or both of the route paths to ensure that clinics $c_i$ and $c_j$ can be linked directly. For instance, a route ending in $c_i$ is joined with a route beginning in $c_j$. The new, longer route's path and load are updated. The algorithm continues this process until all savings have been considered.\n    -   **Step 6: Final Distance Calculation**: After the merging phase is complete, the total distance of the VRP plan is calculated. For each final route, which has a path $v_{r,1}, \\dots, v_{r,m_r}$, the total length is calculated according to the objective function: $d(o, v_{r,1}) + \\sum_{k=1}^{m_r - 1} d(v_{r,k}, v_{r,k+1}) + d(v_{r,m_r}, o)$. The sum of the lengths of all routes gives the final objective value.\n\nThis procedure yields a set of feasible routes that provides a good, though not necessarily optimal, solution to the VRP by systematically constructing routes based on the most promising local improvements.", "answer": "```python\nimport numpy as np\n\ndef euclidean_distance(p1, p2):\n    \"\"\"\n    Calculates the Euclidean distance between two points.\n    \n    Args:\n        p1 (np.ndarray): Coordinates of the first point.\n        p2 (np.ndarray): Coordinates of the second point.\n    \n    Returns:\n        float: The Euclidean distance.\n    \"\"\"\n    return np.linalg.norm(p1 - p2)\n\ndef solve_vrp_heuristic(depot_coord, clinic_coords, clinic_demands, vehicle_capacity):\n    \"\"\"\n    Solves the Capacitated Vehicle Routing Problem using a Clarke and Wright savings heuristic.\n    \n    Args:\n        depot_coord (tuple): (x, y) coordinates of the depot.\n        clinic_coords (list of tuples): List of (x, y) coordinates for each clinic.\n        clinic_demands (list of int): List of demands for each clinic.\n        vehicle_capacity (int): The capacity of each vehicle.\n        \n    Returns:\n        float: The total distance of the resulting routes, rounded to two decimal places.\n    \"\"\"\n    num_clinics = len(clinic_coords)\n    depot_np = np.array(depot_coord)\n    clinics_np = np.array(clinic_coords)\n\n    # Step 1: Pre-calculate distances and savings\n    depot_dists = [euclidean_distance(depot_np, clinics_np[i]) for i in range(num_clinics)]\n    \n    savings = []\n    for i in range(num_clinics):\n        for j in range(i + 1, num_clinics):\n            dist_ij = euclidean_distance(clinics_np[i], clinics_np[j])\n            s_ij = depot_dists[i] + depot_dists[j] - dist_ij\n            if s_ij > 0:\n                savings.append((s_ij, i, j))\n    \n    # Step 2: Sort savings in descending order\n    savings.sort(key=lambda x: x[0], reverse=True)\n\n    # Step 3: Initialize routes (one per clinic)\n    routes = [\n        {'path': [i], 'load': clinic_demands[i]} for i in range(num_clinics)\n    ]\n    clinic_to_route_idx = list(range(num_clinics))\n\n    # Step 4: Iteratively merge routes\n    for _, i, j in savings:\n        route_idx_i = clinic_to_route_idx[i]\n        route_idx_j = clinic_to_route_idx[j]\n\n        # Condition 1: Must be in different routes\n        if route_idx_i == route_idx_j:\n            continue\n\n        route_i = routes[route_idx_i]\n        route_j = routes[route_idx_j]\n\n        # Condition 2: Must not exceed vehicle capacity\n        if route_i['load'] + route_j['load'] > vehicle_capacity:\n            continue\n            \n        path_i = route_i['path']\n        path_j = route_j['path']\n\n        # Condition 3: i and j must be endpoints of their routes\n        i_is_endpoint = (path_i[0] == i or path_i[-1] == i)\n        j_is_endpoint = (path_j[0] == j or path_j[-1] == j)\n\n        if not (i_is_endpoint and j_is_endpoint):\n            continue\n            \n        # Step 5: Perform the merge\n        new_path = None\n        if path_i[-1] == i and path_j[0] == j:\n            new_path = path_i + path_j\n        elif path_i[-1] == i and path_j[-1] == j:\n            new_path = path_i + path_j[::-1]\n        elif path_i[0] == i and path_j[0] == j:\n            new_path = path_i[::-1] + path_j\n        elif path_i[0] == i and path_j[-1] == j:\n            new_path = path_j + path_i\n        else:\n            # Should not happen if i and j are endpoints.\n            # This can occur if a route has a single node, which is both start and end.\n            # The order of checks above handles this gracefully.\n            continue\n        \n        # Update route_i with merged data\n        routes[route_idx_i]['path'] = new_path\n        routes[route_idx_i]['load'] += route_j['load']\n        \n        # Mark route_j as absorbed by clearing its path and load\n        routes[route_idx_j]['path'] = []\n        routes[route_idx_j]['load'] = 0\n        \n        # Update clinic-to-route mapping for all nodes from the absorbed route\n        for clinic_node in path_j:\n            clinic_to_route_idx[clinic_node] = route_idx_i\n\n    # Step 6: Calculate total distance of final routes\n    total_distance = 0.0\n    for route_obj in routes:\n        path = route_obj['path']\n        if not path:\n            continue\n        \n        # Distance from depot to the first clinic in the route\n        route_dist = depot_dists[path[0]]\n        \n        # Sum of distances between consecutive clinics in the route\n        for k in range(len(path) - 1):\n            c1_idx, c2_idx = path[k], path[k+1]\n            route_dist += euclidean_distance(clinics_np[c1_idx], clinics_np[c2_idx])\n            \n        # Distance from the last clinic back to the depot\n        route_dist += depot_dists[path[-1]]\n        \n        total_distance += route_dist\n        \n    return total_distance\n\ndef solve():\n    \"\"\"\n    Defines and runs the test cases, then prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        {\n            \"depot_coord\": (0.0, 0.0),\n            \"clinic_coords\": [(2.0, 1.0), (3.5, -0.5), (-1.2, 4.0), (0.5, 3.2), (4.0, 3.8), (-2.5, 2.5), (1.5, -2.0), (-3.0, -1.0), (2.2, 2.2), (0.0, -3.5), (3.0, 0.8), (-1.8, 3.5)],\n            \"clinic_demands\": [120, 80, 150, 90, 200, 110, 60, 70, 140, 130, 95, 55],\n            \"vehicle_capacity\": 1000\n        },\n        {\n            \"depot_coord\": (10.0, -5.0),\n            \"clinic_coords\": [(11.0, -4.0), (12.0, -3.0), (9.0, -6.0), (8.0, -5.5), (10.5, -4.5), (13.0, -2.0), (7.5, -4.0), (12.5, -6.0), (9.5, -7.0), (11.0, -6.0), (10.0, -3.0), (50.0, -20.0)],\n            \"clinic_demands\": [60, 45, 55, 50, 40, 35, 65, 70, 45, 60, 25, 1000],\n            \"vehicle_capacity\": 1000\n        },\n        {\n            \"depot_coord\": (-20.0, 30.0),\n            \"clinic_coords\": [(-10.0, 25.0), (-25.0, 35.0), (-30.0, 20.0), (-5.0, 40.0), (-15.0, 45.0), (-35.0, 32.0), (-28.0, 12.0), (-12.0, 15.0), (-22.0, 55.0), (-40.0, 10.0), (-7.0, 28.0), (-18.0, 38.0)],\n            \"clinic_demands\": [220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220, 220],\n            \"vehicle_capacity\": 1000\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_vrp_heuristic(\n            case[\"depot_coord\"],\n            case[\"clinic_coords\"],\n            case[\"clinic_demands\"],\n            case[\"vehicle_capacity\"]\n        )\n        results.append(result)\n\n    print(f\"[{','.join([f'{r:.2f}' for r in results])}]\")\n\nsolve()\n```", "id": "4967304"}]}