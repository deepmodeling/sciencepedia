{"hands_on_practices": [{"introduction": "The first challenge in spatial epidemiology is representing our spherical world on a flat map. Every map projection introduces distortions in shape, area, distance, or direction. This exercise explores the critical concept of area distortion by comparing the ubiquitous Web Mercator projection with an equal-area projection, demonstrating why choosing the right projection is essential when mapping disease patterns for resource allocation or risk assessment [@problem_id:4790275].", "problem": "A Geographic Information System (GIS) mapping team is preparing a schistosomiasis intervention map for a coastal district centered at latitude $\\phi = 20^{\\circ}$. The district’s intervention zone has a true surface area of $1000\\,\\text{km}^{2}$, and the epidemiology unit requires accurate area-based resource allocation. Two alternative map projections are under consideration: the Web Mercator projection (also known as Spherical Mercator) commonly used in web maps, and the Albers equal-area conic projection, which is designed to preserve area.\n\nStarting from the standard spherical Earth formulation of the Mercator projection and the definition of local scale distortion, derive the area distortion factor as a function of latitude for the Web Mercator projection. Use the equal-area property of the Albers equal-area projection to justify the comparative baseline. Then, compute the percentage area error for the $1000\\,\\text{km}^{2}$ intervention zone when it is mapped in Web Mercator rather than Albers equal-area at latitude $\\phi = 20^{\\circ}$.\n\nExpress the percentage area error as a decimal (do not use a percent sign) and round your answer to four significant figures.", "solution": "The problem is valid as it is scientifically grounded in the principles of cartography, well-posed with sufficient information for a unique solution, and stated objectively. We will proceed with the solution.\n\nThe problem asks for three main tasks:\n1.  Derive the area distortion factor for the Web Mercator (Spherical Mercator) projection as a function of latitude $\\phi$.\n2.  Justify the use of the Albers equal-area projection as a baseline for area comparison.\n3.  Compute the percentage area error for a zone at latitude $\\phi = 20^{\\circ}$ when mapped using Web Mercator.\n\n**1. Derivation of the Area Distortion Factor for the Mercator Projection**\n\nThe Mercator projection maps a point on a sphere of radius $R$ with longitude $\\lambda$ and latitude $\\phi$ to a point $(x, y)$ on a Cartesian plane. The standard spherical formulation is:\n$$x = R(\\lambda - \\lambda_0)$$\n$$y = R \\ln\\left[\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\right]$$\nwhere $\\lambda_0$ is the longitude of the central meridian.\n\nTo find the distortion, we analyze the local scale factors. The scale factor is the ratio of a differential distance on the map to the corresponding differential distance on the sphere. An infinitesimal arc length on the surface of the sphere, $ds$, is given by the line element:\n$$ds^2 = (R \\, d\\phi)^2 + (R \\cos\\phi \\, d\\lambda)^2$$\nThe first term corresponds to movement along a meridian (North-South) and the second term to movement along a parallel of latitude (East-West).\n\nOn the map, the corresponding infinitesimal arc length, $dl$, is given by:\n$$dl^2 = dx^2 + dy^2$$\nWe find $dx$ and $dy$ by taking the total differentials of the mapping equations:\n$$dx = \\frac{\\partial x}{\\partial \\phi} d\\phi + \\frac{\\partial x}{\\partial \\lambda} d\\lambda$$\n$$dy = \\frac{\\partial y}{\\partial \\phi} d\\phi + \\frac{\\partial y}{\\partial \\lambda} d\\lambda$$\n\nThe required partial derivatives are:\n$\\frac{\\partial x}{\\partial \\phi} = 0$\n$\\frac{\\partial x}{\\partial \\lambda} = R$\n$\\frac{\\partial y}{\\partial \\lambda} = 0$\n\nFor $\\frac{\\partial y}{\\partial \\phi}$, we use the chain rule:\n$$\\frac{\\partial y}{\\partial \\phi} = \\frac{d}{d\\phi} \\left(R \\ln\\left[\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\right]\\right) = R \\cdot \\frac{1}{\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)} \\cdot \\frac{d}{d\\phi}\\left(\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\right)$$\n$$\\frac{\\partial y}{\\partial \\phi} = R \\cdot \\frac{1}{\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)} \\cdot \\sec^2\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right) \\cdot \\frac{1}{2}$$\nSubstituting trigonometric identities $\\tan\\theta = \\frac{\\sin\\theta}{\\cos\\theta}$ and $\\sec\\theta = \\frac{1}{\\cos\\theta}$:\n$$\\frac{\\partial y}{\\partial \\phi} = R \\cdot \\frac{\\cos\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)}{\\sin\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)} \\cdot \\frac{1}{\\cos^2\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)} \\cdot \\frac{1}{2} = R \\cdot \\frac{1}{2\\sin\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\cos\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)}$$\nUsing the double-angle identity $2\\sin\\theta\\cos\\theta = \\sin(2\\theta)$:\n$$\\frac{\\partial y}{\\partial \\phi} = R \\cdot \\frac{1}{\\sin\\left(2\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\right)} = R \\cdot \\frac{1}{\\sin\\left(\\frac{\\pi}{2} + \\phi\\right)}$$\nUsing the co-function identity $\\sin(\\frac{\\pi}{2} + \\phi) = \\cos\\phi$:\n$$\\frac{\\partial y}{\\partial \\phi} = R \\frac{1}{\\cos\\phi} = R \\sec\\phi$$\n\nThe local scale factor along a meridian, $h$, is the ratio of map distance $dy$ (for $d\\lambda=0$) to sphere distance $R \\, d\\phi$:\n$$h = \\frac{dy}{R \\, d\\phi} = \\frac{(\\partial y / \\partial \\phi) \\, d\\phi}{R \\, d\\phi} = \\frac{R \\sec\\phi \\, d\\phi}{R \\, d\\phi} = \\sec\\phi$$\n\nThe local scale factor along a parallel of latitude, $k$, is the ratio of map distance $dx$ (for $d\\phi=0$) to sphere distance $R \\cos\\phi \\, d\\lambda$:\n$$k = \\frac{dx}{R \\cos\\phi \\, d\\lambda} = \\frac{(\\partial x / \\partial \\lambda) \\, d\\lambda}{R \\cos\\phi \\, d\\lambda} = \\frac{R \\, d\\lambda}{R \\cos\\phi \\, d\\lambda} = \\frac{1}{\\cos\\phi} = \\sec\\phi$$\n\nThe area distortion factor, $S$, is the product of the scale factors in two perpendicular directions. For the Mercator projection, $h=k$, which confirms it is a conformal (angle-preserving) projection.\n$$S(\\phi) = h \\cdot k = (\\sec\\phi) \\cdot (\\sec\\phi) = \\sec^2\\phi$$\nThus, the area distortion factor for the Mercator projection is $\\sec^2\\phi$.\n\n**2. Justification of Albers Equal-Area Projection as a Baseline**\n\nThe Albers projection is an equal-area (or equivalent) projection. By definition, such a projection maintains an area distortion factor of $S=1$ everywhere across the map. This means that the area of any feature on the map is equal to its true area on the globe, multiplied by a single constant scale factor for the entire map. When comparing the area of a specific region, a map in an Albers projection provides the true scaled area, making it the correct and ideal baseline against which to measure the area error introduced by non-equal-area projections like the Mercator. The area shown on an Albers map, $A_{albers}$, is therefore taken to be the true area, $A_{true}$.\n\n**3. Computation of Percentage Area Error**\n\nThe true surface area of the intervention zone is given as $A_{true} = 1000\\,\\text{km}^{2}$. The latitude of the district's center is $\\phi = 20^{\\circ}$.\nThe area of the zone as it would appear on a Web Mercator map, $A_{mercator}$, is the true area multiplied by the area distortion factor at that latitude:\n$$A_{mercator} = A_{true} \\cdot S(\\phi) = A_{true} \\sec^2\\phi$$\nThe percentage area error, expressed as a decimal (i.e., the fractional error), is given by the formula:\n$$E = \\frac{A_{mapped} - A_{true}}{A_{true}}$$\nIn our case, $A_{mapped} = A_{mercator}$ and the 'true' reference is $A_{albers} = A_{true}$.\n$$E = \\frac{A_{mercator} - A_{true}}{A_{true}} = \\frac{A_{true} \\sec^2\\phi - A_{true}}{A_{true}} = \\sec^2\\phi - 1$$\nUsing the fundamental trigonometric identity $1 + \\tan^2\\phi = \\sec^2\\phi$, the expression for the error simplifies to:\n$$E = \\tan^2\\phi$$\nNow, we substitute the given latitude $\\phi = 20^{\\circ}$:\n$$E = \\tan^2(20^{\\circ})$$\nWe calculate the value of $\\tan(20^{\\circ})$:\n$$\\tan(20^{\\circ}) \\approx 0.363970234$$\nSquaring this value gives the error:\n$$E \\approx (0.363970234)^2 \\approx 0.13247444$$\nThe problem requires the answer to be rounded to four significant figures.\n$$E \\approx 0.1325$$\nThis means that at a latitude of $20^{\\circ}$, the Web Mercator projection exaggerates the area by approximately $13.25\\%$.", "answer": "$$\\boxed{0.1325}$$", "id": "4790275"}, {"introduction": "Real-world public health projects require integrating spatial data from multiple sources, such as GPS coordinates from field surveys and administrative boundaries from government databases. This process, known as reprojection, is a common source of critical errors if not handled with care. This practice presents a scenario where a seemingly minor mishandling of coordinate units can lead to disease cases being assigned to the wrong health district, highlighting the absolute necessity of rigorous data processing protocols [@problem_id:4790196].", "problem": "A medical parasitology team is using Geographic Information Systems (GIS) to allocate reported schistosomiasis cases to health districts in a metropolitan area with two adjacent administrative units, District West and District East. The administrative boundary is well approximated by a meridian at longitude $\\lambda = 36.8200^\\circ$ and is stored in a projected coordinate reference system (CRS) based on the Web Mercator projection. New case records arrive as Global Positioning System (GPS) coordinates in the World Geodetic System 1984 (WGS84) geographic CRS (latitude $\\phi$, longitude $\\lambda$, units in degrees). A particular case is recorded at $(\\phi,\\lambda) = (-1.3000^\\circ, 36.8196^\\circ)$, which lies just west of the boundary in geographic space. The team projects case points into the boundary’s CRS to perform a point-in-polygon district assignment. Assume a spherical Earth of radius $R = 6{,}378{,}137\\,\\text{m}$ and that, at this scale, projection equations expressed with trigonometric functions require angular inputs in radians.\n\nFrom the foundational definitions of a CRS, a projection function $f\\!:\\!(\\lambda,\\phi)\\mapsto (x,y)$ that maps angular coordinates to planar coordinates with linear units, and the conversion between degrees and radians ($\\text{radians} = \\text{degrees}\\times \\pi/180$), explain why unit mishandling during coordinate reprojection can relocate points across an administrative boundary. Then, select the protocol steps that would prevent misclassification of cases when integrating GPS case points with administrative boundary polygons in routine surveillance.\n\nWhich of the following steps are necessary components of a robust protocol to prevent misclassification in this setting? Select all that apply.\n\nA. Reproject all datasets to a single, region-appropriate projected CRS (for example, Universal Transverse Mercator), use explicit and documented datum transformations, and verify the reprojection with control points before performing spatial joins.\n\nB. Before applying projection equations, convert angles by multiplying degrees by $180/\\pi$ to obtain radians, and then proceed with manual computations for projection.\n\nC. Implement a boundary proximity safeguard: buffer the administrative boundary by the maximum expected positional error (for example, $50$–$100\\,\\text{m}$), and flag any case falling within this buffer for manual verification rather than auto-classifying it.\n\nD. Rely on the GIS software’s on-the-fly reprojection defaults without independently verifying CRS metadata, as visual layer alignment is sufficient to ensure correct classification.\n\nE. Standardize all inputs to WGS84 geographic coordinates and perform point-in-polygon operations in angular units (degrees) to avoid projection distortions.\n\nF. Maintain an auditable transformation log documenting source and target CRSs, transformation parameters, software versions, and date/time, and perform routine spot checks of reprojection accuracy using known landmarks with a positional tolerance less than $10\\,\\text{m}$.", "solution": "The problem statement is valid. It describes a realistic and critical issue in applied Geographic Information Systems (GIS), where incorrect handling of coordinate reference systems (CRS) and units can lead to erroneous spatial analysis, with significant real-world consequences in fields like public health. The problem is scientifically grounded in the principles of geodesy and cartography, is well-posed, and uses precise, objective language.\n\nThe core of the problem lies in the transformation of coordinates from a geographic CRS (like WGS84, with angular units of degrees) to a projected CRS (like Web Mercator, with linear units of meters). This transformation is defined by a set of mathematical equations.\n\n### Explanation of Misclassification due to Unit Mishandling\n\nProjection functions, $f:(\\lambda, \\phi) \\mapsto (x, y)$, map geographic coordinates (longitude $\\lambda$, latitude $\\phi$) to planar coordinates $(x,y)$. These functions often involve trigonometric, logarithmic, or other non-linear operations. A fundamental convention in mathematics and computational science is that arguments to trigonometric functions (e.g., $\\sin, \\cos, \\tan$) must be in radians, not degrees. The conversion is given by $\\theta_{\\text{radians}} = \\theta_{\\text{degrees}} \\times \\frac{\\pi}{180}$.\n\nLet's consider the y-coordinate for the Web Mercator projection mentioned in the problem, which is based on a spherical Earth model with radius $R$:\n$$ y = R \\cdot \\ln\\left[\\tan\\left(\\frac{\\pi}{4} + \\frac{\\phi}{2}\\right)\\right] $$\nHere, the latitude $\\phi$ is an argument to the tangent function (via the sum inside) and must be in radians.\n\nThe case location is given as $\\phi_{deg} = -1.3000^\\circ$.\nThe correct procedure is to first convert $\\phi_{deg}$ to radians:\n$$ \\phi_{rad} = -1.3000^\\circ \\times \\frac{\\pi}{180} \\approx -0.022689 \\text{ radians} $$\nThe argument of the tangent function becomes $\\frac{\\pi}{4} + \\frac{-0.022689}{2} \\approx 0.785398 - 0.011345 = 0.774053$ radians. The tangent of this value is $\\tan(0.774053) \\approx 0.9804$. The resulting $y$ coordinate is $y_{correct} = R \\cdot \\ln(0.9804)$.\n\nNow, consider the \"unit mishandling\" where the degree value is incorrectly fed into the equation as if it were radians:\n$$ y_{error} = R \\cdot \\ln\\left[\\tan\\left(\\frac{\\pi}{4} + \\frac{-1.3000}{2}\\right)\\right] = R \\cdot \\ln\\left[\\tan(0.785398 - 0.65)\\right] = R \\cdot \\ln[\\tan(0.135398)] $$\nThe tangent of this value is $\\tan(0.135398) \\approx 0.1362$. The resulting $y$ coordinate is $y_{error} = R \\cdot \\ln(0.1362)$.\n\nSince $\\ln(0.9804) \\approx -0.0198$ and $\\ln(0.1362) \\approx -1.9936$, the incorrectly calculated $y$-coordinate is approximately $100$ times larger in magnitude than the correct one. This places the point in a completely erroneous location on the map.\n\nWhile the boundary in this specific problem is a meridian (a line of constant longitude, thus a vertical line in the Web Mercator projection), and the miscalculation shown above affects the $y$-coordinate, a similar unit error in a more complex projection involving $\\lambda$ in a non-linear way, or in a manual calculation of the $x$-coordinate, would produce a similarly drastic error in the $x$-direction. For a point located at $\\lambda_p = 36.8196^\\circ$, which is geographically west of the boundary at $\\lambda_b = 36.8200^\\circ$, its correctly projected $x$-coordinate $x_p$ will be less than the boundary's $x$-coordinate $x_b$. However, an incorrectly calculated $x_p'$ value bears no predictable relationship to $x_p$. This new, erroneous coordinate could easily be greater than $x_b$, causing the point to be misclassified as being in District East. This is not a subtle shift; it is a gross error that relocates the point to a essentially arbitrary position.\n\n### Evaluation of Protocol Steps\n\n**A. Reproject all datasets to a single, region-appropriate projected CRS (for example, Universal Transverse Mercator), use explicit and documented datum transformations, and verify the reprojection with control points before performing spatial joins.**\nThis describes the standard best practice in GIS analysis. Standardizing all data into a single, appropriate CRS before analysis eliminates the risks and potential inconsistencies of \"on-the-fly\" reprojection. Using a region-appropriate CRS like UTM minimizes distortion for quantitative analysis compared to a global one like Web Mercator. Explicitly defining and documenting datum transformations ensures accuracy and reproducibility. Verifying with control points is a critical quality assurance step to confirm that the transformation was successful and met accuracy requirements.\n**Correct.**\n\n**B. Before applying projection equations, convert angles by multiplying degrees by $180/\\pi$ to obtain radians, and then proceed with manual computations for projection.**\nThe conversion formula presented is incorrect. To convert from degrees to radians, one must multiply by $\\frac{\\pi}{180}$. Multiplying by $\\frac{180}{\\pi}$ converts from radians to degrees. Implementing this step would systematically introduce, not prevent, massive errors. Furthermore, recommending manual computations is poor practice, as it is highly susceptible to human error and is less reliable and efficient than using professionally developed and validated GIS software libraries.\n**Incorrect.**\n\n**C. Implement a boundary proximity safeguard: buffer the administrative boundary by the maximum expected positional error (for example, $50$–$100\\,\\text{m}$), and flag any case falling within this buffer for manual verification rather than auto-classifying it.**\nThis is a robust quality control and risk mitigation strategy. It acknowledges that all spatial data—GPS points, administrative boundaries, etc.—have inherent positional uncertainty. Creating a buffer zone (a \"zone of indecision\") around boundaries and flagging any feature within it for manual review is a prudent way to handle ambiguous cases that are too close to a boundary to be classified with high confidence by an automated algorithm. This practice prevents misclassifications arising from the sum of all potential errors (GPS error, boundary digitization error, projection error). It is a necessary component of a robust, real-world system.\n**Correct.**\n\n**D. Rely on the GIS software’s on-the-fly reprojection defaults without independently verifying CRS metadata, as visual layer alignment is sufficient to ensure correct classification.**\nThis is a recipe for disaster. Default transformations in GIS software may not be the most accurate ones available for a specific region or pair of datums. Without verifying CRS metadata, one might be misinterpreting the data's true spatial reference. Visual alignment is notoriously unreliable for confirming sub-meter or meter-level accuracy; layers can appear to align perfectly at a medium or large map scale while still having offsets large enough to cause misclassification of points near a boundary. Rigorous analysis requires quantitative verification, not just a visual check.\n**Incorrect.**\n\n**E. Standardize all inputs to WGS84 geographic coordinates and perform point-in-polygon operations in angular units (degrees) to avoid projection distortions.**\nThis is fundamentally flawed. Geometric operations like distance calculation, area measurement, and point-in-polygon tests assume a planar, Cartesian coordinate system where units are consistent in all directions. Geographic coordinates (latitude and longitude) do not form such a system. The linear distance corresponding to one degree of longitude varies dramatically with latitude (from about $111.3$ km at the equator to zero at the poles). Applying standard planar geometric algorithms to angular coordinates will produce meaningless results. The entire purpose of map projections is to create a suitable planar system for such analyses. The solution is not to avoid projections, but to use them correctly.\n**Incorrect.**\n\n**F. Maintain an auditable transformation log documenting source and target CRSs, transformation parameters, software versions, and date/time, and perform routine spot checks of reprojection accuracy using known landmarks with a positional tolerance less than $10\\,\\text{m}$.**\nThis describes essential principles of scientific rigor, reproducibility, and quality management. An auditable log ensures that the entire workflow can be traced, understood, and replicated by others or at a later date. Documenting all parameters is critical for debugging and validation. Routine accuracy checks against known points (control points or landmarks) provide ongoing confidence in the system's reliability and quantify its performance against a defined tolerance. This is a hallmark of a professional and robust operational protocol.\n**Correct.**", "answer": "$$\\boxed{ACF}$$", "id": "4790196"}, {"introduction": "Once data is correctly mapped, we often aggregate it into zones like districts or regions to analyze patterns. However, the conclusions we draw can be surprisingly dependent on the shape and size of these zones—a phenomenon known as the Modifiable Areal Unit Problem (MAUP). This exercise provides a hands-on demonstration of how changing the scale of aggregation can alter key statistics and even reverse the apparent relationship between disease and environmental factors, revealing the related risk of the ecological fallacy [@problem_id:4790223].", "problem": "You are given a scenario in medical parasitology where Geographic Information Systems (GIS) are used to map parasitic diseases at different spatial aggregations. The Modifiable Areal Unit Problem (MAUP) states that estimates and associations can change when data are aggregated to different areal units (for example, villages versus districts). Your task is to implement a program that quantifies how parasite prevalence estimates change when aggregating from village to district level and to assess the risk of ecological fallacy by comparing associations between prevalence and a covariate at different aggregation levels.\n\nFundamental definitions to use:\n- Village-level parasite prevalence is defined as $p_i = I_i / N_i$, where $I_i$ is the number of infected individuals in village $i$ and $N_i$ is the number tested in village $i$. Prevalence must be expressed as a decimal (for example, $0.25$ for $25$ percent).\n- For district $d$, the population-weighted (tested-count-weighted) prevalence is $P_d = \\frac{\\sum_{i \\in d} I_i}{\\sum_{i \\in d} N_i}$.\n- For district $d$, the unweighted mean prevalence of its villages is $\\bar{p}_d = \\frac{1}{k_d} \\sum_{i \\in d} p_i$, where $k_d$ is the number of villages in district $d$.\n- The MAUP difference for district $d$ is $D_d = \\bar{p}_d - P_d$. Summarize the MAUP as the mean absolute difference across districts: $\\mathrm{MAD} = \\frac{1}{D} \\sum_{d=1}^{D} |D_d|$, where $D$ is the number of districts.\n- Let $x_i$ be a village-level covariate representing distance to the nearest perennial freshwater source, measured in kilometers. For district $d$, define the population-weighted covariate $X_d = \\frac{\\sum_{i \\in d} N_i x_i}{\\sum_{i \\in d} N_i}$, measured in kilometers.\n- Compute the Pearson correlation coefficient between village-level prevalence and the covariate, $r_v = \\mathrm{corr}\\left(\\{p_i\\}, \\{x_i\\}\\right)$. Also compute the Pearson correlation coefficient between district-level weighted prevalence and district-level weighted covariate, $r_d = \\mathrm{corr}\\left(\\{P_d\\}, \\{X_d\\}\\right)$.\n- Define an ecological fallacy risk indicator as a boolean $\\mathrm{risk}$ that is $\\mathrm{True}$ if $\\operatorname{sign}(r_v) \\neq \\operatorname{sign}(r_d)$, and $\\mathrm{False}$ otherwise, where $\\operatorname{sign}(\\cdot)$ denotes the sign function mapping positive values to $+1$, negative values to $-1$, and zero to $0$.\n\nAll distances are to be treated in kilometers. All prevalence values are to be treated as decimals.\n\nImplement a single program that, for each test case below, computes:\n- The mean absolute difference $\\mathrm{MAD}$ across districts.\n- The village-level Pearson correlation coefficient $r_v$ between $p_i$ and $x_i$.\n- The district-level Pearson correlation coefficient $r_d$ between $P_d$ and $X_d$.\n- The ecological fallacy risk boolean $\\mathrm{risk}$ as defined above.\n\nTest suite data (each test case consists of $3$ districts; each district consists of $3$ villages; each village is specified by $(N_i, I_i, x_i)$ where $N_i$ is tested count, $I_i$ is infected count, and $x_i$ is distance in kilometers):\n\nTest Case $1$ (general case with varying tested counts):\n- District $A$: villages $\\{(80, 40, 2.0), (120, 36, 5.0), (200, 50, 8.0)\\}$.\n- District $B$: villages $\\{(150, 69, 1.5), (90, 32, 4.0), (60, 12, 9.0)\\}$.\n- District $C$: villages $\\{(50, 5, 10.0), (150, 42, 3.0), (100, 40, 6.0)\\}$.\n\nTest Case $2$ (boundary case with equal tested counts so that $P_d = \\bar{p}_d$ for every district):\n- District $A$: villages $\\{(100, 20, 2.0), (100, 30, 4.0), (100, 40, 6.0)\\}$.\n- District $B$: villages $\\{(100, 10, 1.0), (100, 50, 5.0), (100, 90, 9.0)\\}$.\n- District $C$: villages $\\{(100, 30, 3.0), (100, 70, 7.0), (100, 50, 11.0)\\}$.\n\nTest Case $3$ (constructed to demonstrate potential ecological fallacy via sign flip):\n- District with low covariate values: villages $\\{(100, 60, 1.0), (100, 50, 2.0), (100, 40, 3.0)\\}$.\n- District with mid covariate values: villages $\\{(100, 62, 5.0), (100, 52, 6.0), (100, 42, 7.0)\\}$.\n- District with high covariate values: villages $\\{(100, 64, 9.0), (100, 54, 10.0), (100, 44, 11.0)\\}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case result is a list of the form $[\\mathrm{MAD}, r_v, r_d, \\mathrm{risk}]$. For example, the output should look like $[[\\text{mad}_1, \\text{rv}_1, \\text{rd}_1, \\text{risk}_1],[\\text{mad}_2, \\text{rv}_2, \\text{rd}_2, \\text{risk}_2],[\\text{mad}_3, \\text{rv}_3, \\text{rd}_3, \\text{risk}_3]]$. All numeric values are floats and the boolean is either True or False.", "solution": "The problem requires an analysis of spatial aggregation effects on statistical estimates in medical parasitology, a phenomenon known as the Modifiable Areal Unit Problem (MAUP). The task is to quantify this effect and assess the associated risk of ecological fallacy by comparing data at two spatial scales: the individual village level and the aggregated district level. The solution involves a systematic, step-by-step computation based on the provided definitions and data.\n\nThe procedural design is as follows:\n\nFirst, we process the data at the most granular level, which is the village. For each test case, we compile a comprehensive list of all villages across all districts. For each village $i$, characterized by the number of individuals tested $N_i$, the number of infected individuals $I_i$, and a covariate $x_i$ (distance to a water source), we calculate the parasite prevalence. The village-level prevalence, $p_i$, is defined as the ratio of infected to tested individuals:\n$$p_i = \\frac{I_i}{N_i}$$\nThis step yields two complete datasets for the entire study area: one set for village prevalences, $\\{p_i\\}$, and one for the village covariates, $\\{x_i\\}$.\n\nSecond, we aggregate the village data to the district level. For each district $d$, containing a set of villages, we compute two different measures of district-wide prevalence. The first is the population-weighted prevalence, $P_d$, which represents the true prevalence for the entire district population. It is calculated by summing the infected counts and tested counts across all villages within the district:\n$$P_d = \\frac{\\sum_{i \\in d} I_i}{\\sum_{i \\in d} N_i}$$\nThe second measure is the unweighted mean prevalence, $\\bar{p}_d$. This is the arithmetic average of the individual village prevalence rates, $p_i$, for all $k_d$ villages within the district:\n$$\\bar{p}_d = \\frac{1}{k_d} \\sum_{i \\in d} p_i$$\nSimilarly, we compute an aggregated, population-weighted covariate for each district, $X_d$:\n$$X_d = \\frac{\\sum_{i \\in d} N_i x_i}{\\sum_{i \\in d} N_i}$$\nThis produces two sets of district-level data: one for weighted prevalences, $\\{P_d\\}$, and one for weighted covariates, $\\{X_d\\}$.\n\nThird, we quantify the magnitude of the MAUP. The discrepancy between the two district-level prevalence estimates for a single district $d$ is the MAUP difference, $D_d = \\bar{p}_d - P_d$. This difference arises because $\\bar{p}_d$ gives equal weight to each village's prevalence rate, regardless of its population size, whereas $P_d$ accounts for population size. To summarize this effect across all $D$ districts, we calculate the Mean Absolute Difference ($\\mathrm{MAD}$):\n$$\\mathrm{MAD} = \\frac{1}{D} \\sum_{d=1}^{D} |D_d|$$\n\nFourth, we analyze the relationship between prevalence and the covariate at both spatial scales to assess the risk of ecological fallacy. The ecological fallacy occurs when an association observed for a group is erroneously assumed to hold for individuals within that group. We compute two Pearson correlation coefficients:\n1.  The village-level correlation, $r_v$, between the individual village prevalences $\\{p_i\\}$ and covariates $\\{x_i\\}$:\n    $$r_v = \\mathrm{corr}\\left(\\{p_i\\}, \\{x_i\\}\\right)$$\n2.  The district-level correlation, $r_d$, between the aggregated district prevalences $\\{P_d\\}$ and covariates $\\{X_d\\}$:\n    $$r_d = \\mathrm{corr}\\left(\\{P_d\\}, \\{X_d\\}\\right)$$\nThe risk of ecological fallacy is indicated if the direction of the association changes upon aggregation. We formalize this with a boolean indicator, $\\mathrm{risk}$, which is set to $\\mathrm{True}$ if the signs of the two correlation coefficients differ, and $\\mathrm{False}$ otherwise. The sign function, $\\operatorname{sign}(z)$, is defined as $+1$ for $z > 0$, $-1$ for $z < 0$, and $0$ for $z = 0$.\n$$\\mathrm{risk} = (\\operatorname{sign}(r_v) \\neq \\operatorname{sign}(r_d))$$\n\nThis complete computational sequence is applied to each test case provided. The final result for each case is a list containing the four calculated metrics: $[\\mathrm{MAD}, r_v, r_d, \\mathrm{risk}]$.", "answer": "```python\n# language: Python\n# version: 3.12\n# libraries:\n#   - name: numpy\n#     version: 1.23.5\n\nimport numpy as np\n\ndef calculate_results(districts_data):\n    \"\"\"\n    Computes MAUP metrics and correlation coefficients for a single test case.\n    \n    Args:\n        districts_data (list): A list of districts, where each district is a list\n                             of village data tuples (N_i, I_i, x_i).\n    \n    Returns:\n        list: A list containing [MAD, r_v, r_d, risk].\n    \"\"\"\n    # Lists to store values from all villages for village-level correlation\n    all_p_i = []\n    all_x_i = []\n\n    # Lists to store aggregated district-level values\n    district_maup_abs_diffs = []\n    all_P_d = []\n    all_X_d = []\n    \n    num_districts = len(districts_data)\n\n    # Iterate over each district to calculate its aggregated metrics\n    for district_villages in districts_data:\n        # Per-district accumulators\n        sum_I_d = 0.0\n        sum_N_d = 0.0\n        sum_Nx_d = 0.0\n        \n        # List to store village prevalences within the current district\n        village_prevalences_in_district = []\n        \n        # Iterate over villages in the current district\n        for village_data in district_villages:\n            N_i, I_i, x_i = village_data\n            \n            # Village-level prevalence p_i\n            # The problem context implies N_i > 0 for all cases.\n            p_i = I_i / N_i if N_i > 0 else 0.0\n            \n            # Append to global lists for village-level correlation\n            all_p_i.append(p_i)\n            all_x_i.append(x_i)\n            \n            # Append to district's list for unweighted mean calculation\n            village_prevalences_in_district.append(p_i)\n            \n            # Accumulate sums for weighted district-level metrics\n            sum_I_d += I_i\n            sum_N_d += N_i\n            sum_Nx_d += N_i * x_i\n\n        # Calculate district-level metrics after iterating through its villages\n        # Population-weighted prevalence P_d\n        P_d = sum_I_d / sum_N_d if sum_N_d > 0 else 0.0\n        \n        # Unweighted mean prevalence of villages p_bar_d\n        p_bar_d = np.mean(village_prevalences_in_district)\n        \n        # MAUP difference for the district\n        D_d = p_bar_d - P_d\n        district_maup_abs_diffs.append(np.abs(D_d))\n        \n        # Population-weighted covariate X_d\n        X_d = sum_Nx_d / sum_N_d if sum_N_d > 0 else 0.0\n        \n        # Store aggregated district values for district-level correlation\n        all_P_d.append(P_d)\n        all_X_d.append(X_d)\n\n    # Calculate overall summary metrics\n    # Mean Absolute Difference (MAD) for MAUP\n    mad = np.mean(district_maup_abs_diffs)\n    \n    # Village-level Pearson correlation (r_v)\n    # Handle the case of zero variance to avoid NaN\n    if np.var(all_p_i) == 0 or np.var(all_x_i) == 0:\n        r_v = 0.0\n    else:\n        r_v = np.corrcoef(all_p_i, all_x_i)[0, 1]\n\n    # District-level Pearson correlation (r_d)\n    if np.var(all_P_d) == 0 or np.var(all_X_d) == 0:\n        r_d = 0.0\n    else:\n        r_d = np.corrcoef(all_P_d, all_X_d)[0, 1]\n    \n    # Ecological fallacy risk indicator\n    risk = np.sign(r_v) != np.sign(r_d)\n    \n    return [mad, r_v, r_d, bool(risk)]\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: general case with varying tested counts\n        [\n            [(80, 40, 2.0), (120, 36, 5.0), (200, 50, 8.0)],\n            [(150, 69, 1.5), (90, 32, 4.0), (60, 12, 9.0)],\n            [(50, 5, 10.0), (150, 42, 3.0), (100, 40, 6.0)]\n        ],\n        # Test Case 2: boundary case with equal tested counts\n        [\n            [(100, 20, 2.0), (100, 30, 4.0), (100, 40, 6.0)],\n            [(100, 10, 1.0), (100, 50, 5.0), (100, 90, 9.0)],\n            [(100, 30, 3.0), (100, 70, 7.0), (100, 50, 11.0)]\n        ],\n        # Test Case 3: constructed to demonstrate potential ecological fallacy\n        [\n            [(100, 60, 1.0), (100, 50, 2.0), (100, 40, 3.0)],\n            [(100, 62, 5.0), (100, 52, 6.0), (100, 42, 7.0)],\n            [(100, 64, 9.0), (100, 54, 10.0), (100, 44, 11.0)]\n        ]\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_results(case)\n        results.append(result)\n\n    # Format the final output string as per the requirements\n    # Each sublist must be formatted without spaces after commas\n    final_output_parts = []\n    for res in results:\n        mad, rv, rd, risk = res\n        # Format the boolean as 'True' or 'False'\n        part = f\"[{mad},{rv},{rd},{str(risk)}]\"\n        final_output_parts.append(part)\n\n    print(f\"[{','.join(final_output_parts)}]\")\n\nsolve()\n```", "id": "4790223"}]}