{"hands_on_practices": [{"introduction": "This first exercise grounds your understanding of the Concordance Index (C-index) in its fundamental principles. By working with a small, hypothetical dataset, you will practice the core steps of identifying which patient pairs are valid for comparison (admissible pairs) and determining whether the model's risk predictions align with the observed survival outcomes. This foundational skill is essential for correctly interpreting and calculating the C-index in any survival analysis scenario [@problem_id:5189334].", "problem": "A Deep Neural Survival (DeepSurv) model is trained to estimate individualized risk scores for right-censored survival data in a medical cohort. Let the survival time be a nonnegative random variable $T$, and the censoring time be $C$, with observed time $Y = \\min\\{T, C\\}$ and event indicator $\\Delta = \\mathbf{1}\\{T \\leq C\\}$. The model outputs a scalar risk score $r(\\mathbf{x})$ such that the hazard function $h(t \\mid \\mathbf{x})$ is monotonically increasing in $r(\\mathbf{x})$, consistent with proportional hazards where $h(t \\mid \\mathbf{x}) \\propto \\exp(r(\\mathbf{x}))$. The concordance index (C-index) is defined as the probability that, for a randomly drawn admissible pair of individuals where the shorter observed time corresponds to an event, the individual with the shorter observed event time has a larger predicted risk score.\n\nYou are given three patients with predicted risk scores $\\mathbf{r} = [0.2, 1.1, -0.4]$, observed times $\\mathbf{Y} = [3, 2, 5]$, and event indicators $\\boldsymbol{\\Delta} = [1, 1, 0]$. Using only the foundational definitions above and the admissible-pair logic for right-censored data, compute the C-index for this cohort by explicitly determining which pairs are admissible and whether they are concordant or discordant under the ordering implied by the risk scores. Assume no ties in risk scores or observed times occur; if a tie were to occur in the risk scores within an admissible pair, it would contribute one-half toward concordance.\n\nIn addition, provide a principled interpretation of what discordant pairs imply for model calibration versus discrimination in survival prediction, grounded in the definitions of $T$, $C$, $Y$, $\\Delta$, and risk-based hazard ordering.\n\nExpress the final C-index as a single real number. If your computation yields a rational number, leave it in exact fractional form and do not round.", "solution": "The objective is to compute the concordance index (C-index) from first principles for right-censored survival data under a Deep Neural Survival (DeepSurv) risk model. We begin from core survival analysis definitions and the monotonic relationship between the predicted risk score and the hazard.\n\nLet $T$ be the true survival time and $C$ be the censoring time. The observed time is $Y = \\min\\{T, C\\}$ and the event indicator is $\\Delta = \\mathbf{1}\\{T \\leq C\\}$. A predicted risk score $r(\\mathbf{x})$ is used to produce a hazard ordering where higher $r(\\mathbf{x})$ implies a higher hazard $h(t \\mid \\mathbf{x})$ and thus a tendency toward shorter event times. The concordance index is the probability that the ordering of risk scores agrees with the ordering of observed event times for admissible pairs. An admissible pair $(i, j)$ under right censoring is defined by the following logic: the pair is included if the shorter observed time corresponds to an event, namely if $Y_i  Y_j$ and $\\Delta_i = 1$, or $Y_j  Y_i$ and $\\Delta_j = 1$. Pairs where the minimum observed time is censored are not admissible because the true ordering of event times is unknown in that case.\n\nA pair is concordant if the subject with the shorter observed event time has a larger risk score. A pair is discordant if the subject with the shorter observed event time has a smaller risk score. Ties in risk scores within admissible pairs contribute one-half to concordance, but here no ties occur.\n\nWe are given three subjects:\n- Subject $1$: $r_1 = 0.2$, $Y_1 = 3$, $\\Delta_1 = 1$.\n- Subject $2$: $r_2 = 1.1$, $Y_2 = 2$, $\\Delta_2 = 1$.\n- Subject $3$: $r_3 = -0.4$, $Y_3 = 5$, $\\Delta_3 = 0$.\n\nWe enumerate all unordered pairs $\\{(1,2), (1,3), (2,3)\\}$ and test admissibility and concordance.\n\n1. Pair $(1, 2)$: Compare observed times $Y_1 = 3$ and $Y_2 = 2$. The shorter time is $Y_2 = 2$ with $\\Delta_2 = 1$, so the pair is admissible. Concordance requires that the subject with the shorter event time (subject $2$) has a larger risk score. We check $r_2$ versus $r_1$: $r_2 = 1.1$ and $r_1 = 0.2$, so $r_2 > r_1$. This pair is concordant.\n\n2. Pair $(1, 3)$: Compare $Y_1 = 3$ and $Y_3 = 5$. The shorter time is $Y_1 = 3$ with $\\Delta_1 = 1$, so the pair is admissible. Concordance requires that subject $1$ has a larger risk score than subject $3$. We check $r_1$ versus $r_3$: $r_1 = 0.2$ and $r_3 = -0.4$, so $r_1 > r_3$. This pair is concordant.\n\n3. Pair $(2, 3)$: Compare $Y_2 = 2$ and $Y_3 = 5$. The shorter time is $Y_2 = 2$ with $\\Delta_2 = 1$, so the pair is admissible. Concordance requires that subject $2$ has a larger risk score than subject $3$. We check $r_2$ versus $r_3$: $r_2 = 1.1$ and $r_3 = -0.4$, so $r_2 > r_3$. This pair is concordant.\n\nAll three admissible pairs are concordant. Therefore, the C-index is the fraction of concordant admissible pairs:\n$$\n\\text{C-index} \\;=\\; \\frac{\\text{number of concordant admissible pairs}}{\\text{number of admissible pairs}} \\;=\\; \\frac{3}{3} \\;=\\; 1.\n$$\n\nInterpretation of discordant pairs in relation to calibration and discrimination: A discordant pair arises when the subject with the shorter observed event time has a lower predicted risk score, i.e., the model’s risk ordering disagrees with the observed event-time ordering for an admissible pair. Such discordance directly indicates an error in discrimination, because discrimination measures the model’s ability to correctly rank-order risks consistent with event times (larger $r(\\mathbf{x})$ should correspond to smaller $T$ when $\\Delta = 1$ for the shorter observed time). Calibration, by contrast, concerns the agreement between predicted absolute risks or hazard levels and observed outcome frequencies over time; it requires that the numerical scale of predictions matches observed probabilities or rates. A model can be well calibrated yet exhibit poor discrimination (many discordant pairs), or be poorly calibrated yet maintain good discrimination (few discordant pairs). In this dataset, the absence of discordant pairs implies perfect discrimination for these subjects, but it does not in itself guarantee perfect calibration of the absolute risk scale.\n\nThus, the computed C-index is $1$.", "answer": "$$\\boxed{1}$$", "id": "5189334"}, {"introduction": "Real-world data is rarely as clean as in our first example, and a common challenge is handling tied values. This practice builds upon the basics by introducing ties in both survival times and predicted risk scores. By working through a scenario with these complexities, you will learn the standard conventions for managing ties, which is a crucial step in ensuring your C-index calculations are robust and consistent [@problem_id:4562877].", "problem": "A research team evaluates a radiomics-based survival model that outputs a continuous risk score $r_i$ for each patient $i$, where larger $r_i$ indicates a higher hazard and therefore a tendency toward earlier events. For a cohort of six patients, the observed survival data are given as follows, where $t_i$ is the observed time, $\\delta_i$ is the event indicator ($\\delta_i=1$ for an observed event, $\\delta_i=0$ for right censoring), and $r_i$ is the predicted risk score:\n- Patient A: $t_{\\mathrm{A}}=6$, $\\delta_{\\mathrm{A}}=1$, $r_{\\mathrm{A}}=0.80$\n- Patient B: $t_{\\mathrm{B}}=6$, $\\delta_{\\mathrm{B}}=1$, $r_{\\mathrm{B}}=0.50$\n- Patient C: $t_{\\mathrm{C}}=9$, $\\delta_{\\mathrm{C}}=0$, $r_{\\mathrm{C}}=0.70$\n- Patient D: $t_{\\mathrm{D}}=11$, $\\delta_{\\mathrm{D}}=1$, $r_{\\mathrm{D}}=0.60$\n- Patient E: $t_{\\mathrm{E}}=14$, $\\delta_{\\mathrm{E}}=0$, $r_{\\mathrm{E}}=0.60$\n- Patient F: $t_{\\mathrm{F}}=13$, $\\delta_{\\mathrm{F}}=1$, $r_{\\mathrm{F}}=0.80$\n\nUsing the foundational definition of the Concordance Index (C-index), assess the model’s discrimination by comparing all unordered patient pairs under the following scientifically standard tie-handling protocol:\n- A pair $\\{i,j\\}$ is considered comparable if $\\min\\{t_i,t_j\\}$ is strictly less than the other time and corresponds to an observed event (that is, the earlier of the two observed times is an event time). Pairs with equal observed times are not comparable.\n- For a comparable pair, if the patient with the earlier event time has a larger risk score than the other, count the pair as concordant. If the patient with the earlier event time has a smaller risk score than the other, count it as discordant.\n- For a comparable pair with tied risk scores, award half credit.\n- Pairs in which the earlier observed time is censored are not comparable.\n\nCompute the Concordance Index (C-index) for this dataset under these rules. Express your final answer as a single reduced fraction.", "solution": "The problem requires the calculation of the Concordance Index (C-index) for a given survival dataset. The C-index quantifies the discriminative power of a model by measuring the proportion of comparable patient pairs for which the model correctly predicts the order of survival events. A higher risk score should correspond to an earlier event time.\n\nFirst, we restate the provided data for the six patients, indexed $i \\in \\{\\mathrm{A}, \\mathrm{B}, \\mathrm{C}, \\mathrm{D}, \\mathrm{E}, \\mathrm{F}\\}$. For each patient $i$, we have the observed time $t_i$, the event indicator $\\delta_i$ (where $\\delta_i=1$ denotes an event and $\\delta_i=0$ denotes right censoring), and the predicted risk score $r_i$.\n\n- Patient $\\mathrm{A}$: $t_{\\mathrm{A}}=6$, $\\delta_{\\mathrm{A}}=1$, $r_{\\mathrm{A}}=0.80$\n- Patient $\\mathrm{B}$: $t_{\\mathrm{B}}=6$, $\\delta_{\\mathrm{B}}=1$, $r_{\\mathrm{B}}=0.50$\n- Patient $\\mathrm{C}$: $t_{\\mathrm{C}}=9$, $\\delta_{\\mathrm{C}}=0$, $r_{\\mathrm{C}}=0.70$\n- Patient $\\mathrm{D}$: $t_{\\mathrm{D}}=11$, $\\delta_{\\mathrm{D}}=1$, $r_{\\mathrm{D}}=0.60$\n- Patient $\\mathrm{F}$: $t_{\\mathrm{F}}=13$, $\\delta_{\\mathrm{F}}=1$, $r_{\\mathrm{F}}=0.80$\n- Patient $\\mathrm{E}$: $t_{\\mathrm{E}}=14$, $\\delta_{\\mathrm{E}}=0$, $r_{\\mathrm{E}}=0.60$\nNote that the patients have been reordered by their observed time $t_i$ for procedural clarity.\n\nThe C-index is defined as:\n$$ C = \\frac{ \\text{Number of Concordant Pairs} + (0.5 \\times \\text{Number of Tied Pairs}) }{ \\text{Total Number of Comparable Pairs} } $$\nWe must systematically evaluate all $\\binom{6}{2} = \\frac{6 \\times 5}{2} = 15$ unique, unordered pairs of patients to determine which are comparable, and of those, which are concordant, discordant, or tied.\n\nAccording to the rules provided:\n1.  A pair of patients $\\{i, j\\}$ is **comparable** if their observed times are different and the patient with the earlier time experienced an event. That is, if we assume $t_i  t_j$, the pair is comparable if and only if $\\delta_i = 1$.\n2.  Pairs with equal observed times ($t_i = t_j$) are not comparable.\n3.  For a comparable pair where $t_i  t_j$ and $\\delta_i = 1$:\n    - The pair is **concordant** if the patient with the earlier event has a higher risk score ($r_i > r_j$). This contributes $1$ to the numerator.\n    - The pair is **discordant** if $r_i  r_j$. This contributes $0$ to the numerator.\n    - The pair has a **risk tie** if $r_i = r_j$. This contributes $0.5$ to the numerator.\n\nWe proceed by considering each patient $i$ who experienced an event ($\\delta_i=1$) and comparing them with all patients $j$ who have a later observation time ($t_j > t_i$).\n\n**1. Patient A ($t_{\\mathrm{A}}=6, \\delta_{\\mathrm{A}}=1, r_{\\mathrm{A}}=0.80$):**\nPatient $\\mathrm{A}$ is compared with all patients with $t_j > 6$: $\\mathrm{C}$, $\\mathrm{D}$, $\\mathrm{F}$, $\\mathrm{E}$. (Patient $\\mathrm{B}$ has $t_{\\mathrm{B}}=6$ and is therefore not comparable with $\\mathrm{A}$).\n-   Pair $\\{\\mathrm{A}, \\mathrm{C}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{C}}=9$): Comparable. $r_{\\mathrm{A}}=0.80 > r_{\\mathrm{C}}=0.70$. **Concordant** (score: $1$).\n-   Pair $\\{\\mathrm{A}, \\mathrm{D}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{D}}=11$): Comparable. $r_{\\mathrm{A}}=0.80 > r_{\\mathrm{D}}=0.60$. **Concordant** (score: $1$).\n-   Pair $\\{\\mathrm{A}, \\mathrm{F}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{F}}=13$): Comparable. $r_{\\mathrm{A}}=0.80 = r_{\\mathrm{F}}=0.80$. **Tied** (score: $0.5$).\n-   Pair $\\{\\mathrm{A}, \\mathrm{E}\\}$ ($t_{\\mathrm{A}}=6  t_{\\mathrm{E}}=14$): Comparable. $r_{\\mathrm{A}}=0.80 > r_{\\mathrm{E}}=0.60$. **Concordant** (score: $1$).\nFrom Patient $\\mathrm{A}$, we have $4$ comparable pairs. The score sum is $1 + 1 + 0.5 + 1 = 3.5$.\n\n**2. Patient B ($t_{\\mathrm{B}}=6, \\delta_{\\mathrm{B}}=1, r_{\\mathrm{B}}=0.50$):**\nPatient $\\mathrm{B}$ is compared with all patients with $t_j > 6$: $\\mathrm{C}$, $\\mathrm{D}$, $\\mathrm{F}$, $\\mathrm{E}$.\n-   Pair $\\{\\mathrm{B}, \\mathrm{C}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{C}}=9$): Comparable. $r_{\\mathrm{B}}=0.50  r_{\\mathrm{C}}=0.70$. **Discordant** (score: $0$).\n-   Pair $\\{\\mathrm{B}, \\mathrm{D}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{D}}=11$): Comparable. $r_{\\mathrm{B}}=0.50  r_{\\mathrm{D}}=0.60$. **Discordant** (score: $0$).\n-   Pair $\\{\\mathrm{B}, \\mathrm{F}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{F}}=13$): Comparable. $r_{\\mathrm{B}}=0.50  r_{\\mathrm{F}}=0.80$. **Discordant** (score: $0$).\n-   Pair $\\{\\mathrm{B}, \\mathrm{E}\\}$ ($t_{\\mathrm{B}}=6  t_{\\mathrm{E}}=14$): Comparable. $r_{\\mathrm{B}}=0.50  r_{\\mathrm{E}}=0.60$. **Discordant** (score: $0$).\nFrom Patient $\\mathrm{B}$, we have $4$ comparable pairs. The score sum is $0 + 0 + 0 + 0 = 0$.\n\n**3. Patient C ($t_{\\mathrm{C}}=9, \\delta_{\\mathrm{C}}=0$):**\nPatient $\\mathrm{C}$ was censored, so no comparable pairs are formed with $\\mathrm{C}$ as the patient with the earlier time.\n\n**4. Patient D ($t_{\\mathrm{D}}=11, \\delta_{\\mathrm{D}}=1, r_{\\mathrm{D}}=0.60$):**\nPatient $\\mathrm{D}$ is compared with all patients with $t_j > 11$: $\\mathrm{F}$, $\\mathrm{E}$.\n-   Pair $\\{\\mathrm{D}, \\mathrm{F}\\}$ ($t_{\\mathrm{D}}=11  t_{\\mathrm{F}}=13$): Comparable. $r_{\\mathrm{D}}=0.60  r_{\\mathrm{F}}=0.80$. **Discordant** (score: $0$).\n-   Pair $\\{\\mathrm{D}, \\mathrm{E}\\}$ ($t_{\\mathrm{D}}=11  t_{\\mathrm{E}}=14$): Comparable. $r_{\\mathrm{D}}=0.60 = r_{\\mathrm{E}}=0.60$. **Tied** (score: $0.5$).\nFrom Patient $\\mathrm{D}$, we have $2$ comparable pairs. The score sum is $0 + 0.5 = 0.5$.\n\n**5. Patient F ($t_{\\mathrm{F}}=13, \\delta_{\\mathrm{F}}=1, r_{\\mathrm{F}}=0.80$):**\nPatient $\\mathrm{F}$ is compared with all patients with $t_j > 13$: $\\mathrm{E}$.\n-   Pair $\\{\\mathrm{F}, \\mathrm{E}\\}$ ($t_{\\mathrm{F}}=13  t_{\\mathrm{E}}=14$): Comparable. $r_{\\mathrm{F}}=0.80 > r_{\\mathrm{E}}=0.60$. **Concordant** (score: $1$).\nFrom Patient $\\mathrm{F}$, we have $1$ comparable pair. The score sum is $1$.\n\n**6. Patient E ($t_{\\mathrm{E}}=14, \\delta_{\\mathrm{E}}=0$):**\nPatient $\\mathrm{E}$ was censored, and is the last observation, so no comparable pairs are formed.\n\nNow, we aggregate the results:\n-   Total number of comparable pairs ($N_{comp}$): $4$ (from A) + $4$ (from B) + $2$ (from D) + $1$ (from F) = $11$.\n-   Total score for the numerator: $3.5$ (from A) + $0$ (from B) + $0.5$ (from D) + $1$ (from F) = $5.0$.\n\nFinally, we compute the C-index:\n$$ C = \\frac{\\text{Total Score}}{N_{comp}} = \\frac{5.0}{11} = \\frac{5}{11} $$\nThe result is already a reduced fraction.", "answer": "$$\\boxed{\\frac{5}{11}}$$", "id": "4562877"}, {"introduction": "The true power of the C-index is revealed when it is used to guide model development. This advanced practice moves beyond manual calculation and into a realistic machine learning workflow where you will implement a cross-validation procedure to select the best hyperparameter for a linear survival model. By using the C-index as the optimization metric, you will gain hands-on experience in how this evaluation tool directly contributes to building more effective predictive models in radiomics [@problem_id:4562915].", "problem": "You are given three small radiomics-inspired survival datasets in which each patient has a fixed-length feature vector derived from image-based quantitative descriptors, an observed survival time, and an event indicator. Your task is to implement hyperparameter tuning to optimize the concordance index (C-index) for a simple linear risk scoring model. Survival times are to be interpreted in months; no unit conversion is required, and all outputs must be unitless numbers.\n\nStarting from fundamental definitions, adopt the following modeling and evaluation base:\n- The radiomics feature matrix for $n$ patients is denoted by $X \\in \\mathbb{R}^{n \\times p}$, where each row $x_i \\in \\mathbb{R}^p$ is a standardized descriptor vector. The observed survival times are $T \\in \\mathbb{R}^n$ (strictly positive, measured in months), and the event indicators are $E \\in \\{0,1\\}^n$, where $E_i = 1$ denotes that the event (e.g., death or progression) was observed and $E_i = 0$ denotes right-censoring.\n- A linear risk score for patient $i$ is defined by $s_i = -\\hat{y}_i$, where $\\hat{y}_i = x_i^\\top \\beta$ and $\\beta \\in \\mathbb{R}^p$ is learned by ridge regression on the training fold using only uncensored patients. Specifically, if $U = \\{i \\in \\{1,\\dots,n\\} : E_i = 1\\}$ are the indices of uncensored patients in the training fold, set $y_i = \\log(T_i)$ for $i \\in U$ and learn $\\beta$ by minimizing the squared error with $\\ell_2$ regularization strength $\\lambda > 0$ on the training fold, after feature standardization using the training fold statistics. Use only $i \\in U$ when fitting $\\beta$. If a training fold contains no uncensored patients ($|U| = 0$), define $\\beta = 0 \\in \\mathbb{R}^p$ by convention.\n- The concordance index (C-index) is defined using pairwise ordering among comparable pairs. Two patients $i$ and $j$ form a comparable pair if the shorter observed time corresponds to an uncensored event. Concretely, $i$ and $j$ are comparable if either $E_i = 1$ and $T_i  T_j$, or $E_j = 1$ and $T_j  T_i$. Pairs with $T_i = T_j$ are not comparable. A comparable pair is concordant if the patient with the shorter observed event time has the higher risk score. If the two risk scores are tied on a comparable pair, count the pair as half concordant. The $C$-index is the fraction of concordant pairs among all comparable pairs. If there are no comparable pairs, define the $C$-index as $0.5$.\n\nImplement $K$-fold cross-validation (CV) with contiguous, deterministic splits on patient indices to select the regularization hyperparameter $\\lambda$ from a given grid that maximizes the mean validation-fold $C$-index. Break ties by choosing the smallest $\\lambda$.\n\nFor each dataset below, perform the following steps:\n1. Standardize features using the training fold mean and standard deviation per feature. If a feature has zero standard deviation on the training fold, replace that standard deviation by $1$ for numerical stability.\n2. Fit $\\beta$ on the training fold using only uncensored patients and the given $\\lambda$, with the ridge penalty applied to all coefficients. Use the training fold standardization in this fit.\n3. Compute validation fold risk scores $s_i = -x_i^\\top \\beta$ using the same training standardization and evaluate the validation-fold $C$-index using the definition above.\n4. Average the validation-fold $C$-index across all $K$ folds for each $\\lambda$.\n5. Select the $\\lambda$ that maximizes the mean validation $C$-index, breaking ties by choosing the smallest $\\lambda$.\n6. Report, for each dataset, the selected $\\lambda$ and the corresponding mean cross-validation $C$-index.\n\nDatasets and hyperparameter grids:\n- Test case $1$ (happy path, mixed censoring):\n  - $X \\in \\mathbb{R}^{12 \\times 3}$:\n    $$\n    X = \\begin{bmatrix}\n    0.8  1.2  0.5 \\\\\n    1.0  0.9  0.7 \\\\\n    0.3  1.5  0.2 \\\\\n    1.1  1.1  0.4 \\\\\n    0.7  0.8  0.6 \\\\\n    1.3  1.0  0.5 \\\\\n    0.2  0.4  0.1 \\\\\n    1.0  1.4  0.3 \\\\\n    0.6  0.7  0.8 \\\\\n    1.2  1.0  0.9 \\\\\n    0.5  0.9  0.2 \\\\\n    0.9  1.3  0.4\n    \\end{bmatrix}\n    $$\n  - $T = [12,10,20,9,14,8,30,11,15,7,25,13]$ months\n  - $E = [1,1,0,1,1,1,0,1,0,1,0,1]$\n  - $\\Lambda = [0.01, 0.1, 1.0, 10.0]$, $K = 3$\n- Test case $2$ (boundary case, all censored):\n  - $X \\in \\mathbb{R}^{8 \\times 2}$:\n    $$\n    X = \\begin{bmatrix}\n    0.2  0.1 \\\\\n    0.5  0.4 \\\\\n    0.3  0.2 \\\\\n    0.7  0.6 \\\\\n    0.9  0.8 \\\\\n    0.4  0.3 \\\\\n    0.6  0.5 \\\\\n    0.1  0.2\n    \\end{bmatrix}\n    $$\n  - $T = [10,12,9,11,13,8,14,15]$ months\n  - $E = [0,0,0,0,0,0,0,0]$\n  - $\\Lambda = [0.1, 1.0]$, $K = 4$\n- Test case $3$ (ties in features and times):\n  - $X \\in \\mathbb{R}^{10 \\times 2}$:\n    $$\n    X = \\begin{bmatrix}\n    1.0  1.0 \\\\\n    1.0  1.0 \\\\\n    0.5  0.5 \\\\\n    0.5  0.5 \\\\\n    1.5  1.0 \\\\\n    0.7  0.9 \\\\\n    1.2  0.8 \\\\\n    0.8  1.1 \\\\\n    1.0  0.9 \\\\\n    1.1  1.0\n    \\end{bmatrix}\n    $$\n  - $T = [10,10,20,20,8,15,9,16,12,11]$ months\n  - $E = [1,1,0,1,1,1,1,0,1,1]$\n  - $\\Lambda = [0.001, 0.1, 5.0]$, $K = 5$\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must be a two-element list $[\\lambda^\\ast, \\bar{C}]$ where $\\lambda^\\ast$ is the selected regularization value and $\\bar{C}$ is the mean cross-validation $C$-index for that $\\lambda^\\ast$. For example, an output with three test cases should look like $[[\\lambda_1, c_1],[\\lambda_2, c_2],[\\lambda_3, c_3]]$ with decimal numbers. Round each reported number to $6$ decimal places.", "solution": "The problem statement is assessed to be valid as it is scientifically grounded, well-posed, and objective. It provides a complete and consistent set of definitions, data, and procedures for a standard, albeit simplified, machine learning task in survival analysis. The problem is formalizable and requires the implementation of a deterministic algorithm involving cross-validation, ridge regression, and the concordance index.\n\nThe solution proceeds by implementing the specified $K$-fold cross-validation procedure to select the optimal regularization hyperparameter $\\lambda$ for a linear risk scoring model. For each of the three provided datasets, the process is as follows:\n\nFirst, an outer loop iterates through each value of $\\lambda$ in the provided grid $\\Lambda$. For each $\\lambda$, a $K$-fold cross-validation is performed. The patient indices $\\{0, 1, \\dots, n-1\\}$ are deterministically partitioned into $K$ contiguous, non-overlapping folds. In each of the $K$ iterations, one fold is designated as the validation set, and the remaining $K-1$ folds constitute the training set.\n\nWithin each cross-validation iteration, the following steps are executed:\n1.  **Data Standardization**: The features of the training data, $X_{train}$, are standardized. For each feature column $j \\in \\{1, \\dots, p\\}$, the mean $\\mu_j$ and standard deviation $\\sigma_j$ are computed from the training data. A stability correction is applied: if $\\sigma_j = 0$, it is set to $\\sigma_j = 1$. Both the training features $X_{train}$ and the validation features $X_{val}$ are then standardized using these same statistics: $x'_{i,j} = (x_{i,j} - \\mu_j) / \\sigma_j$.\n\n2.  **Model Fitting**: A linear model is trained using only the uncensored patients in the training set. Let $U_{train}$ be the set of indices of training patients for whom the event was observed (i.e., $E_i = 1$). If this set is empty ($|U_{train}| = 0$), the coefficient vector is defined by convention as the zero vector, $\\beta = 0 \\in \\mathbb{R}^p$. Otherwise, for each patient $i \\in U_{train}$, the regression target is defined as $y_i = \\log(T_i)$. The coefficient vector $\\beta$ is then estimated by solving the ridge regression problem, which minimizes the objective function $L(\\beta) = \\sum_{i \\in U_{train}} (y_i - x'_i{}^\\top \\beta)^2 + \\lambda ||\\beta||_2^2$, where $x'_i$ is the standardized feature vector for patient $i$. The closed-form solution for $\\beta$ is given by:\n    $$\n    \\beta = (X'_{U_{train}}{}^\\top X'_{U_{train}} + \\lambda I)^{-1} X'_{U_{train}}{}^\\top y_{U_{train}}\n    $$\n    where $X'_{U_{train}}$ is the matrix of standardized features for the uncensored training patients, $y_{U_{train}}$ is the vector of their log-transformed survival times, and $I$ is the $p \\times p$ identity matrix.\n\n3.  **Risk Prediction**: The learned coefficient vector $\\beta$ is used to compute a risk score for each patient $i$ in the validation set. The risk score $s_i$ is defined as the negative of the predicted log-survival time:\n    $$\n    s_i = -x'_{i,val}{}^\\top \\beta\n    $$\n    where $x'_{i,val}$ is the standardized feature vector for validation patient $i$.\n\n4.  **Performance Evaluation**: The performance of the model on the validation fold is quantified using the concordance index (C-index). The C-index measures the proportion of comparable patient pairs for which the model correctly predicts the ordering of survival outcomes.\n    - A pair of patients $(i, j)$ from the validation set is **comparable** if the patient with the shorter observed time experienced an event. That is, if $(T_i  T_j \\text{ and } E_i=1)$ or $(T_j  T_i \\text{ and } E_j=1)$. Pairs with tied survival times ($T_i = T_j$) are not considered comparable.\n    - A comparable pair is **concordant** if the patient with the shorter survival time has a higher predicted risk score. For a comparable pair $(i, j)$ where $T_i  T_j$ and $E_i=1$, concordance requires $s_i  s_j$. If the risk scores are tied ($s_i = s_j$), the pair contributes $0.5$ to the count of concordant pairs.\n    - The C-index for the fold is calculated as:\n    $$\n    C = \\frac{\\text{Number of concordant pairs}}{\\text{Number of comparable pairs}}\n    $$\n    If the number of comparable pairs is zero, the C-index is defined as $0.5$.\n\nAfter iterating through all $K$ folds, the mean of the $K$ validation C-indices is computed for the current value of $\\lambda$. This process is repeated for all values in the hyperparameter grid $\\Lambda$.\n\nFinally, the optimal hyperparameter, $\\lambda^\\ast$, is selected as the one that yields the highest mean cross-validation C-index. Any ties are broken by choosing the smallest value of $\\lambda$. The result for each dataset is the pair $[\\lambda^\\ast, \\bar{C}_{\\lambda^\\ast}]$, where $\\bar{C}_{\\lambda^\\ast}$ is the mean C-index corresponding to the selected $\\lambda^\\ast$. This procedure is applied independently to each of the three test cases specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements hyperparameter tuning for a simple radiomics survival model \n    using K-fold cross-validation to optimize the C-index.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([\n                [0.8, 1.2, 0.5], [1.0, 0.9, 0.7], [0.3, 1.5, 0.2],\n                [1.1, 1.1, 0.4], [0.7, 0.8, 0.6], [1.3, 1.0, 0.5],\n                [0.2, 0.4, 0.1], [1.0, 1.4, 0.3], [0.6, 0.7, 0.8],\n                [1.2, 1.0, 0.9], [0.5, 0.9, 0.2], [0.9, 1.3, 0.4]\n            ]),\n            np.array([12, 10, 20, 9, 14, 8, 30, 11, 15, 7, 25, 13]),\n            np.array([1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1]),\n            3,\n            [0.01, 0.1, 1.0, 10.0]\n        ),\n        (\n            np.array([\n                [0.2, 0.1], [0.5, 0.4], [0.3, 0.2], [0.7, 0.6],\n                [0.9, 0.8], [0.4, 0.3], [0.6, 0.5], [0.1, 0.2]\n            ]),\n            np.array([10, 12, 9, 11, 13, 8, 14, 15]),\n            np.array([0, 0, 0, 0, 0, 0, 0, 0]),\n            4,\n            [0.1, 1.0]\n        ),\n        (\n            np.array([\n                [1.0, 1.0], [1.0, 1.0], [0.5, 0.5], [0.5, 0.5],\n                [1.5, 1.0], [0.7, 0.9], [1.2, 0.8], [0.8, 1.1],\n                [1.0, 0.9], [1.1, 1.0]\n            ]),\n            np.array([10, 10, 20, 20, 8, 15, 9, 16, 12, 11]),\n            np.array([1, 1, 0, 1, 1, 1, 1, 0, 1, 1]),\n            5,\n            [0.001, 0.1, 5.0]\n        )\n    ]\n\n    final_results = []\n    \n    for X, T, E, K, Lambda_grid in test_cases:\n        n_patients, n_features = X.shape\n        \n        cv_results = {}\n\n        for lambda_val in Lambda_grid:\n            fold_c_indices = []\n            \n            # Deterministic, contiguous splits for K-fold CV\n            indices = np.arange(n_patients)\n            fold_indices = np.array_split(indices, K)\n\n            for k in range(K):\n                val_idx = fold_indices[k]\n                train_idx = np.concatenate([fold_indices[j] for j in range(K) if j != k])\n\n                X_train, T_train, E_train = X[train_idx], T[train_idx], E[train_idx]\n                X_val, T_val, E_val = X[val_idx], T[val_idx], E[val_idx]\n\n                # 1. Standardize features using training fold statistics\n                train_mean = np.mean(X_train, axis=0)\n                train_std = np.std(X_train, axis=0)\n                train_std[train_std == 0] = 1.0  # Replace zero std with 1\n\n                X_train_std = (X_train - train_mean) / train_std\n                X_val_std = (X_val - train_mean) / train_std\n\n                # 2. Fit beta on uncensored training patients\n                uncensored_mask_train = E_train == 1\n                \n                if np.sum(uncensored_mask_train) == 0:\n                    beta = np.zeros(n_features)\n                else:\n                    X_uncensored = X_train_std[uncensored_mask_train]\n                    T_uncensored = T_train[uncensored_mask_train]\n                    y_uncensored = np.log(T_uncensored)\n                    \n                    # Solve for beta using ridge regression formula\n                    # (X^T X + lambda I) beta = X^T y\n                    A = X_uncensored.T @ X_uncensored + lambda_val * np.identity(n_features)\n                    b = X_uncensored.T @ y_uncensored\n                    beta = np.linalg.solve(A, b)\n\n                # 3. Compute validation fold risk scores\n                risk_scores_val = - (X_val_std @ beta)\n                \n                # 4. Evaluate validation-fold C-index\n                concordant_pairs = 0\n                comparable_pairs = 0\n                \n                for i in range(len(val_idx)):\n                    for j in range(i + 1, len(val_idx)):\n                        # Check for comparability, excluding pairs with tied times\n                        if T_val[i]  T_val[j] and E_val[i] == 1:\n                            comparable_pairs += 1\n                            if risk_scores_val[i]  risk_scores_val[j]:\n                                concordant_pairs += 1\n                            elif risk_scores_val[i] == risk_scores_val[j]:\n                                concordant_pairs += 0.5\n                        elif T_val[j]  T_val[i] and E_val[j] == 1:\n                            comparable_pairs += 1\n                            if risk_scores_val[j]  risk_scores_val[i]:\n                                concordant_pairs += 1\n                            elif risk_scores_val[j] == risk_scores_val[i]:\n                                concordant_pairs += 0.5\n                \n                if comparable_pairs == 0:\n                    c_index = 0.5\n                else:\n                    c_index = concordant_pairs / comparable_pairs\n                \n                fold_c_indices.append(c_index)\n            \n            # 5. Average C-index across folds for the current lambda\n            cv_results[lambda_val] = np.mean(fold_c_indices)\n        \n        # 6. Select the best lambda\n        best_lambda = -1\n        max_c_index = -1.0\n        \n        # Iterate through grid to handle tie-breaking correctly (smallest lambda)\n        for lambda_val in sorted(cv_results.keys()):\n            if cv_results[lambda_val]  max_c_index:\n                max_c_index = cv_results[lambda_val]\n                best_lambda = lambda_val\n\n        final_results.append([round(best_lambda, 6), round(max_c_index, 6)])\n\n    # Format the final output string\n    output_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]}]\" for res in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "4562915"}]}