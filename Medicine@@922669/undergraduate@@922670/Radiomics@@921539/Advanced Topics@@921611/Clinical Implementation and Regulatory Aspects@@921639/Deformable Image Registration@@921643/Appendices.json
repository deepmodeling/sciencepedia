{"hands_on_practices": [{"introduction": "A cornerstone of many deformable registration algorithms is the B-spline Free-Form Deformation (FFD) model, which offers a powerful balance between flexibility and smoothness. The behavior of this model is governed by an underlying grid of control points. This first practice focuses on the crucial initial step of setting up this grid, translating high-level parameters like desired grid spacing and image metadata into the precise number of control points required for the transformation. [@problem_id:4536241]", "problem": "A pair of liver Computed Tomography (CT) volumes is to be registered using a cubic B-spline Free-Form Deformation (FFD). The fixed image contains a liver Region of Interest (ROI) specified by a rectangular bounding box whose dimensions in voxels are $320 \\times 280 \\times 160$. The fixed image voxel spacings are $1.0 \\, \\text{mm}$ in the $x$-direction, $1.0 \\, \\text{mm}$ in the $y$-direction, and $2.5 \\, \\text{mm}$ in the $z$-direction. The control lattice for the FFD is to be constructed with a uniform target grid spacing of $40 \\, \\text{mm}$ in all three directions, covering the ROI.\n\nStarting from first principles of B-spline parameterization, set up the cubic B-spline FFD registration by expressing the deformation field in terms of control points and basis functions, and then derive how to determine the number of control points needed along each dimension for an open uniform knot vector that minimally spans the ROI. Assume a cubic B-spline (degree $p = 3$) with open uniform boundary conditions. The control grid must cover the entire physical extent of the ROI. Use the following foundational bases:\n\n- The physical extent of the ROI along each axis equals the product of the number of voxels in that axis and the corresponding voxel spacing.\n- For a uniform open knot vector of degree $p$, the number of basis functions (and hence control points) equals the number of knot spans plus $p$.\n- The number of knot spans equals the number of uniform intervals needed to cover the physical extent when divided by the target grid spacing, taking the smallest integer not less than the exact ratio.\n\nCompute the expected total number of control points in the three-dimensional control lattice that covers the ROI. Express your final answer as a single integer. No rounding is required beyond exact integer arithmetic. Do not include any units in your final answer.", "solution": "The user wants to determine the total number of control points for a cubic B-spline Free-Form Deformation (FFD) grid. The problem is valid as it is scientifically grounded in the principles of medical image analysis and B-spline theory, is well-posed with all necessary information provided, and is expressed in objective language. We will proceed with a step-by-step calculation based on the provided principles.\n\nA B-spline FFD is defined by a transformation $T$ that deforms an image. This transformation is controlled by a lattice of control points. The total number of control points, $N_{total}$, in a three-dimensional grid is the product of the number of control points along each dimension:\n$$N_{total} = N_{cp,x} \\times N_{cp,y} \\times N_{cp,z}$$\nwhere $N_{cp,x}$, $N_{cp,y}$, and $N_{cp,z}$ are the number of control points along the $x$, $y$, and $z$ axes, respectively. To find $N_{total}$, we must first compute the number of control points for each dimension individually.\n\n**Step 1: Calculate the physical extent of the Region of Interest (ROI)**\n\nThe problem specifies the dimensions of the ROI bounding box in voxels and the physical spacing of each voxel. The physical extent $L$ along an axis is the product of the number of voxels $N$ and the voxel spacing $s$ along that axis.\n\nThe given data are:\n- ROI dimensions in voxels: $N_x = 320$, $N_y = 280$, and $N_z = 160$.\n- Voxel spacings: $s_x = 1.0 \\, \\text{mm}$, $s_y = 1.0 \\, \\text{mm}$, and $s_z = 2.5 \\, \\text{mm}$.\n\nThe physical extent along the $x$-direction is:\n$$L_x = N_x \\times s_x = 320 \\times 1.0 \\, \\text{mm} = 320 \\, \\text{mm}$$\nThe physical extent along the $y$-direction is:\n$$L_y = N_y \\times s_y = 280 \\times 1.0 \\, \\text{mm} = 280 \\, \\text{mm}$$\nThe physical extent along the $z$-direction is:\n$$L_z = N_z \\times s_z = 160 \\times 2.5 \\, \\text{mm} = 400 \\, \\text{mm}$$\n\n**Step 2: Calculate the number of knot spans along each dimension**\n\nThe control grid must cover the physical extent of the ROI with a uniform target grid spacing of $g = 40 \\, \\text{mm}$. The number of knot spans, $N_{spans}$, is defined as the number of intervals needed to cover the physical extent, which is the smallest integer not less than the ratio $\\frac{L}{g}$. This is computed using the ceiling function, $\\lceil \\cdot \\rceil$.\n\nFor the $x$-direction:\n$$N_{spans,x} = \\left\\lceil \\frac{L_x}{g} \\right\\rceil = \\left\\lceil \\frac{320}{40} \\right\\rceil = \\lceil 8 \\rceil = 8$$\nFor the $y$-direction:\n$$N_{spans,y} = \\left\\lceil \\frac{L_y}{g} \\right\\rceil = \\left\\lceil \\frac{280}{40} \\right\\rceil = \\lceil 7 \\rceil = 7$$\nFor the $z$-direction:\n$$N_{spans,z} = \\left\\lceil \\frac{L_z}{g} \\right\\rceil = \\left\\lceil \\frac{400}{40} \\right\\rceil = \\lceil 10 \\rceil = 10$$\n\n**Step 3: Calculate the number of control points along each dimension**\n\nThe problem states that for a B-spline of degree $p$, the number of control points $N_{cp}$ is given by the sum of the number of knot spans $N_{spans}$ and the degree $p$. The FFD uses a cubic B-spline, for which the degree is $p=3$.\n\nThe number of control points along the $x$-direction is:\n$$N_{cp,x} = N_{spans,x} + p = 8 + 3 = 11$$\nThe number of control points along the $y$-direction is:\n$$N_{cp,y} = N_{spans,y} + p = 7 + 3 = 10$$\nThe number of control points along the $z$-direction is:\n$$N_{cp,z} = N_{spans,z} + p = 10 + 3 = 13$$\n\n**Step 4: Calculate the total number of control points**\n\nFinally, we compute the total number of control points in the $3$D lattice by multiplying the number of control points from each dimension.\n$$N_{total} = N_{cp,x} \\times N_{cp,y} \\times N_{cp,z}$$\nSubstituting the calculated values:\n$$N_{total} = 11 \\times 10 \\times 13$$\n$$N_{total} = 110 \\times 13$$\n$$N_{total} = 1430$$\n\nThus, the total number of control points in the three-dimensional control lattice is $1430$.", "answer": "$$\\boxed{1430}$$", "id": "4536241"}, {"introduction": "Once a deformable registration algorithm produces a deformation field, it is essential to evaluate its physical plausibility. A mathematically valid transformation might not be physically meaningful; for instance, it could cause space to fold back on itself. This practice introduces the Jacobian determinant, a fundamental mathematical tool used to quantify local volume changes and detect such non-physical behavior. [@problem_id:4536244] By implementing a numerical method to compute the Jacobian, you will gain hands-on experience with a critical quality assurance step in the DIR pipeline.", "problem": "In deformable image registration for radiomics, a deformation is modeled as a spatial transformation $\\phi:\\mathbb{R}^3 \\to \\mathbb{R}^3$ applied to a regular voxel grid with known spacings. A common representation is the displacement field $u:\\mathbb{R}^3 \\to \\mathbb{R}^3$ such that $\\phi(x)=x+u(x)$. The local volume change induced by $\\phi$ is measured by the Jacobian determinant $J_{\\phi}(x)=\\det(\\nabla \\phi(x))=\\det(I+\\nabla u(x))$, where $I$ is the identity matrix and $\\nabla u(x)$ is the $3 \\times 3$ matrix of first-order partial derivatives $\\partial u_i/\\partial x_j$. Regions where $J_{\\phi}(x)0$ indicate potential folding and non-invertibility of the transformation.\n\nYou are given discrete displacement fields $u$ sampled on a three-dimensional ($d=3$) rectilinear voxel grid of shape $(N_x,N_y,N_z)$ with voxel spacings $(h_x,h_y,h_z)$ along the $x$, $y$, and $z$ axes, respectively. You must compute the voxelwise Jacobian determinant using finite differences and identify voxels with potential folding where $J_{\\phi}0$. Use the following discrete approximations for the partial derivatives, derived from the definition of the derivative as a limit, and implemented by finite differences along each axis with the corresponding spacing:\n\n- For an interior voxel index $i$ along an axis (that is, $1 \\le i \\le N-2$), use the centered difference\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{i} \\approx \\frac{u_{i+1} - u_{i-1}}{2 h}.\n$$\n- For the boundary voxel at index $i=0$, use the forward difference\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{0} \\approx \\frac{u_{1} - u_{0}}{h}.\n$$\n- For the boundary voxel at index $i=N-1$, use the backward difference\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{N-1} \\approx \\frac{u_{N-1} - u_{N-2}}{h}.\n$$\n\nConstruct $I+\\nabla u$ voxelwise and compute its determinant to obtain $J_{\\phi}$ at each voxel. To robustly identify folding in floating-point arithmetic, classify a voxel as folded if $J_{\\phi}  -\\epsilon$ with $\\epsilon=10^{-9}$.\n\nEach test case below defines a grid shape $(N_x,N_y,N_z)$, spacings $(h_x,h_y,h_z)$, and a linear transformation specified by diagonal scale factors $(s_x,s_y,s_z)$ such that $\\phi(x)=S x$ with $S=\\mathrm{diag}(s_x,s_y,s_z)$. The displacement field is then $u(x)=(S-I)x$. For linear maps, the finite-difference gradients should recover the exact constant derivatives. For each test case, compute:\n- the minimum of $J_{\\phi}$ over all voxels,\n- the maximum of $J_{\\phi}$ over all voxels,\n- the integer count of voxels with $J_{\\phi}  -\\epsilon$.\n\nYour program must implement the above method and process the following test suite:\n\n- Test case $\\#1$ (identity mapping, interior and boundary consistency):\n  - Shape $(N_x,N_y,N_z)=(3,3,3)$,\n  - Spacings $(h_x,h_y,h_z)=(1.0,1.0,1.0)$,\n  - Scales $(s_x,s_y,s_z)=(1.0,1.0,1.0)$.\n\n- Test case $\\#2$ (uniform expansion with anisotropic spacings, happy path):\n  - Shape $(N_x,N_y,N_z)=(5,4,3)$,\n  - Spacings $(h_x,h_y,h_z)=(2.0,1.0,0.5)$,\n  - Scales $(s_x,s_y,s_z)=(1.2,1.2,1.2)$.\n\n- Test case $\\#3$ (global reflection about the $y$-$z$ plane, folding everywhere):\n  - Shape $(N_x,N_y,N_z)=(5,4,3)$,\n  - Spacings $(h_x,h_y,h_z)=(1.0,1.0,1.0)$,\n  - Scales $(s_x,s_y,s_z)=(-1.0,1.0,1.0)$.\n\n- Test case $\\#4$ (singular mapping along $y$, zero Jacobian without folding by the strict criterion):\n  - Shape $(N_x,N_y,N_z)=(3,3,2)$,\n  - Spacings $(h_x,h_y,h_z)=(1.5,2.0,0.5)$,\n  - Scales $(s_x,s_y,s_z)=(1.0,0.0,1.0)$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result must itself be a list of the form $[\\mathrm{min}J_{\\phi},\\mathrm{max}J_{\\phi},\\mathrm{count\\_neg}]$, where $\\mathrm{min}J_{\\phi}$ and $\\mathrm{max}J_{\\phi}$ are floating-point values rounded to exactly six digits after the decimal point, and $\\mathrm{count\\_neg}$ is an integer. There must be no spaces anywhere in the output. For example, a valid overall output with two dummy cases would be $[[1.000000,2.000000,0],[0.500000,0.750000,3]]$.", "solution": "The problem requires computing the voxelwise Jacobian determinant of a deformation field and identifying regions of folding. The problem is well-posed, scientifically grounded, and provides all necessary information for a complete algorithmic solution.\n\nThe deformation is given by a transformation $\\phi:\\mathbb{R}^3 \\to \\mathbb{R}^3$, which maps a point $x$ in the original image space to a new point $\\phi(x)$. This is represented by a displacement field $u(x)$ such that $\\phi(x) = x + u(x)$. The local change in volume at a point $x$ due to this deformation is quantified by the Jacobian determinant of the transformation, $J_{\\phi}(x) = \\det(\\nabla \\phi(x))$. Using the relationship $\\phi(x) = x + u(x)$, the gradient of the transformation is $\\nabla \\phi(x) = \\nabla (x + u(x)) = \\nabla x + \\nabla u(x) = I + \\nabla u(x)$, where $I$ is the $3 \\times 3$ identity matrix and $\\nabla u(x)$ is the Jacobian matrix of the displacement field. Thus, the Jacobian determinant is $J_{\\phi}(x) = \\det(I + \\nabla u(x))$. A negative Jacobian determinant, $J_{\\phi}(x)  0$, indicates a local reflection or \"folding\" of space, which is typically physically implausible in deformable registration.\n\nThe displacement field $u$ is provided as a discrete vector field on a three-dimensional rectilinear grid of shape $(N_x, N_y, N_z)$ with voxel spacings $(h_x, h_y, h_z)$. To compute $J_{\\phi}$ at each voxel, we must first approximate the gradient of the displacement field, $\\nabla u$. This is a $3 \\times 3$ matrix at each voxel, consisting of nine partial derivatives:\n$$\n\\nabla u(x) =\n\\begin{pmatrix}\n\\frac{\\partial u_x}{\\partial x}  \\frac{\\partial u_x}{\\partial y}  \\frac{\\partial u_x}{\\partial z} \\\\\n\\frac{\\partial u_y}{\\partial x}  \\frac{\\partial u_y}{\\partial y}  \\frac{\\partial u_y}{\\partial z} \\\\\n\\frac{\\partial u_z}{\\partial x}  \\frac{\\partial u_z}{\\partial y}  \\frac{\\partial u_z}{\\partial z}\n\\end{pmatrix}\n$$\nThe problem specifies the use of finite difference methods to approximate these derivatives. For an interior voxel, a second-order accurate centered difference is used, while at the boundaries, first-order accurate forward or backward differences are used. This scheme ensures that a gradient can be computed at every voxel on the grid. This specific combination of finite difference approximations is conveniently implemented in the `numpy.gradient` function.\n\nThe overall algorithm proceeds as follows for each test case:\n1.  Generate the grid coordinates. An $(N_x, N_y, N_z)$ coordinate grid is constructed using the given shape and spacings. The coordinate of a voxel at index $(i, j, k)$ is $(i \\cdot h_x, j \\cdot h_y, k \\cdot h_z)$.\n2.  Generate the displacement field $u$. For the given test cases, the transformation is a linear map $\\phi(x) = Sx$ with $S = \\mathrm{diag}(s_x, s_y, s_z)$. The displacement field is therefore $u(x) = (S-I)x$. The components are $u_x(x,y,z)=(s_x-1)x$, $u_y(x,y,z)=(s_y-1)y$, and $u_z(x,y,z)=(s_z-1)z$. These are evaluated at each grid point to create a discrete vector field of shape $(N_x, N_y, N_z, 3)$.\n3.  Compute the gradient $\\nabla u$. For each component of the displacement field ($u_x$, $u_y$, and $u_z$), the partial derivatives with respect to $x$, $y$, and $z$ are computed using `numpy.gradient`. The corresponding spacings $(h_x, h_y, h_z)$ are provided to ensure correct scaling. This yields nine scalar fields representing the components of $\\nabla u$.\n4.  Assemble the Jacobian matrix. The nine partial derivative fields are stacked to form a tensor of shape $(N_x, N_y, N_z, 3, 3)$, which represents the matrix $\\nabla u$ at each voxel.\n5.  Compute the Jacobian determinant $J_{\\phi}$. The $3 \\times 3$ identity matrix $I$ is added to $\\nabla u$ at each voxel (via broadcasting) to form $I + \\nabla u$. The determinant of this matrix is then computed for each voxel using `numpy.linalg.det`. This results in a scalar field $J_{\\phi}$ of shape $(N_x, N_y, N_z)$.\n6.  Analyze the results. From the computed $J_{\\phi}$ field, the minimum and maximum values are determined. The number of voxels considered \"folded\" is counted based on the criterion $J_{\\phi}  -\\epsilon$, where $\\epsilon = 10^{-9}$.\n\nFor the specific linear displacement fields in the test cases, the finite difference method exactly recovers the analytical constant gradient, $\\nabla u = S-I$. Therefore, the computed Jacobian determinant $J_{\\phi}$ will be constant across all voxels and equal to the analytical value $\\det(S) = s_x s_y s_z$. This provides a clear theoretical prediction to validate the implementation.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes voxelwise Jacobian determinants for a suite of test cases\n    and reports statistics on folding.\n    \"\"\"\n    test_cases = [\n        {'shape': (3, 3, 3), 'spacings': (1.0, 1.0, 1.0), 'scales': (1.0, 1.0, 1.0)},\n        {'shape': (5, 4, 3), 'spacings': (2.0, 1.0, 0.5), 'scales': (1.2, 1.2, 1.2)},\n        {'shape': (5, 4, 3), 'spacings': (1.0, 1.0, 1.0), 'scales': (-1.0, 1.0, 1.0)},\n        {'shape': (3, 3, 2), 'spacings': (1.5, 2.0, 0.5), 'scales': (1.0, 0.0, 1.0)},\n    ]\n\n    epsilon = 1e-9\n    results = []\n\n    for case in test_cases:\n        shape = case['shape']\n        spacings = case['spacings']\n        scales = case['scales']\n\n        Nx, Ny, Nz = shape\n        hx, hy, hz = spacings\n        sx, sy, sz = scales\n\n        # 1. Create coordinate grid\n        x_coords = np.arange(Nx) * hx\n        y_coords = np.arange(Ny) * hy\n        z_coords = np.arange(Nz) * hz\n        xx, yy, zz = np.meshgrid(x_coords, y_coords, z_coords, indexing='ij')\n\n        # 2. Generate displacement field u(x) = (S-I)x\n        u = np.zeros((Nx, Ny, Nz, 3))\n        u[..., 0] = (sx - 1) * xx\n        u[..., 1] = (sy - 1) * yy\n        u[..., 2] = (sz - 1) * zz\n\n        # 3. Compute the gradient of each component of the displacement field.\n        # np.gradient returns a list of arrays [df/dx, df/dy, df/dz] when\n        # spacings (hx, hy, hz) are provided for a 3D array.\n        # edge_order=1 ensures first-order finite differences at boundaries.\n        grad_ux_list = np.gradient(u[..., 0], hx, hy, hz, edge_order=1)\n        grad_uy_list = np.gradient(u[..., 1], hx, hy, hz, edge_order=1)\n        grad_uz_list = np.gradient(u[..., 2], hx, hy, hz, edge_order=1)\n\n        # 4. Assemble the 3x3 gradient matrix nabla_u at each voxel.\n        # nabla_u will have shape (Nx, Ny, Nz, 3, 3).\n        nabla_u = np.stack([\n            np.stack(grad_ux_list, axis=-1),\n            np.stack(grad_uy_list, axis=-1),\n            np.stack(grad_uz_list, axis=-1)\n        ], axis=-2)\n\n        # 5. Calculate the transformation Jacobian matrix J_matrix = I + nabla_u\n        I = np.identity(3)\n        # Broadcasting adds the (3,3) identity matrix to each voxel's (3,3) gradient matrix.\n        J_matrix = I + nabla_u\n\n        # Compute the determinant at each voxel.\n        J_phi = np.linalg.det(J_matrix) # Output shape: (Nx, Ny, Nz)\n\n        # 6. Compute required statistics\n        min_J = np.min(J_phi)\n        max_J = np.max(J_phi)\n        count_neg = np.sum(J_phi  -epsilon)\n\n        results.append([min_J, max_J, int(count_neg)])\n\n    # Format the final output string as per the requirements.\n    formatted_results = []\n    for res in results:\n        min_j, max_j, count = res\n        formatted_results.append(f\"[{min_j:.6f},{max_j:.6f},{count}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4536244"}, {"introduction": "Deformable registration culminates in the creation of a new, warped image through a process called resampling, which involves interpolation. While necessary, interpolation is not a perfect process and invariably alters the underlying image data, typically causing a subtle blurring effect. This exercise provides a deeper, quantitative understanding of this phenomenon by introducing the Modulation Transfer Function (MTF), a concept from signal processing used to characterize how an operation affects signals of different spatial frequencies. [@problem_id:4536264] By deriving the MTF for linear interpolation, you will learn to precisely quantify the loss of image detail.", "problem": "In deformable image registration, resampling of the moving image onto the fixed image grid introduces blurring and partial volume effects that can be characterized in the frequency domain by the Modulation Transfer Function (MTF). Consider a one-dimensional resampling along a single axis with uniform voxel spacing $\\Delta$ and linear interpolation. Model the resampling as a convolution with the interpolation kernel (the Point Spread Function (PSF))\n$$\nk(x) = \\begin{cases}\n\\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta,\\\\\n0,  |x|  \\Delta,\n\\end{cases}\n$$\nwhich ensures unit area so that constant signals are preserved. Adopt the Fourier transform convention\n$$\n\\mathcal{F}\\{g\\}(f) = \\int_{-\\infty}^{\\infty} g(x)\\,\\exp\\!\\big(-i\\,2\\pi f x\\big)\\,dx,\n$$\nwith spatial frequency $f$ in cycles per millimeter. The Optical Transfer Function (OTF) is the Fourier transform of the PSF, and the Modulation Transfer Function (MTF) is the magnitude of the OTF.\n\nStarting from these definitions and the kernel $k(x)$ above, derive a closed-form analytical expression for the MTF as a function of $f$ and $\\Delta$, and then evaluate it at the spatial frequency $f = 0.25$ cycles per millimeter for a voxel spacing of $\\Delta = 1$ millimeter. Report the numerical value of the MTF at this frequency, rounded to four significant figures. The MTF is dimensionless; express your final numerical answer without units and in decimal form.", "solution": "The user wants me to validate the following problem and, if it is valid, solve it.\n\n### Step 1: Extract Givens\n-   **Point Spread Function (PSF)** for linear interpolation:\n    $$\n    k(x) = \\begin{cases}\n    \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right),  |x| \\le \\Delta,\\\\\n    0,  |x|  \\Delta,\n    \\end{cases}\n    $$\n    where $\\Delta$ is the uniform voxel spacing.\n-   **Fourier Transform Convention**:\n    $$\n    \\mathcal{F}\\{g\\}(f) = \\int_{-\\infty}^{\\infty} g(x)\\,\\exp\\!\\big(-i\\,2\\pi f x\\big)\\,dx\n    $$\n-   **Optical Transfer Function (OTF)**: $\\text{OTF}(f) = \\mathcal{F}\\{k(x)\\}(f)$.\n-   **Modulation Transfer Function (MTF)**: $\\text{MTF}(f) = |\\text{OTF}(f)|$.\n-   **Spatial Frequency for Evaluation**: $f = 0.25$ cycles per millimeter.\n-   **Voxel Spacing for Evaluation**: $\\Delta = 1$ millimeter.\n-   **Required Output**: A closed-form expression for the MTF, and its numerical value at the given parameters, rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientifically Grounded**: The problem is well-grounded in the principles of signal processing as applied to medical imaging. The use of a Point Spread Function ($PSF$), Optical Transfer Function ($OTF$), and Modulation Transfer Function ($MTF$) to characterize the effects of an interpolation kernel is a standard and fundamental technique. The specific $PSF$ provided, a triangle function, is the correct representation of linear interpolation.\n2.  **Well-Posed**: The problem is clearly stated with all necessary information. It provides the function to be transformed, the transform definition, and all parameters required for the final calculation. A unique solution exists and can be derived directly from the givens.\n3.  **Objective**: The problem is stated using precise, objective mathematical and technical language, free from any subjective elements.\n4.  **Completeness and Consistency**: The problem is self-contained. The provided $PSF$, $k(x)$, is a normalized triangle function, and its integral over its support is indeed $1$, as stated. We can verify:\n    $$ \\int_{-\\infty}^{\\infty} k(x) dx = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right) dx = 2 \\int_{0}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{x}{\\Delta}\\right) dx = \\frac{2}{\\Delta} \\left[x - \\frac{x^2}{2\\Delta}\\right]_0^\\Delta = \\frac{2}{\\Delta} \\left(\\Delta - \\frac{\\Delta^2}{2\\Delta}\\right) = \\frac{2}{\\Delta} \\left(\\frac{\\Delta}{2}\\right) = 1 $$\n    This confirms the internal consistency of the problem statement. The physical units (cycles/mm and mm) are consistent.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, and internally consistent. It is a valid problem. I will now proceed with the solution.\n\nThe solution requires two main steps: first, deriving the analytical expression for the $\\text{MTF}$, and second, evaluating this expression for the given numerical parameters.\n\nThe $\\text{OTF}$ is defined as the Fourier transform of the $PSF$, $k(x)$.\n$$ \\text{OTF}(f) = \\mathcal{F}\\{k(x)\\}(f) = \\int_{-\\infty}^{\\infty} k(x) \\exp(-i 2\\pi f x) dx $$\nSubstituting the expression for $k(x)$:\n$$ \\text{OTF}(f) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right) \\exp(-i 2\\pi f x) dx $$\nThe kernel $k(x)$ is a real and even function. The Fourier transform of a real and even function is also a real and even function. This can be shown by expanding the complex exponential using Euler's formula, $\\exp(-i\\theta) = \\cos(\\theta) - i\\sin(\\theta)$.\n$$ \\text{OTF}(f) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right) \\left[\\cos(2\\pi f x) - i\\sin(2\\pi f x)\\right] dx $$\nThe term with $\\sin(2\\pi f x)$ is the integral of an odd function over a symmetric interval $[-\\Delta, \\Delta]$, which evaluates to zero. We are left with the cosine term, whose integrand is an even function.\n$$ \\text{OTF}(f) = \\int_{-\\Delta}^{\\Delta} \\frac{1}{\\Delta}\\left(1 - \\frac{|x|}{\\Delta}\\right) \\cos(2\\pi f x) dx = \\frac{2}{\\Delta} \\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right) \\cos(2\\pi f x) dx $$\nWe solve this integral using integration by parts, $\\int u dv = uv - \\int v du$.\nLet $u = 1 - \\frac{x}{\\Delta}$, which gives $du = -\\frac{1}{\\Delta} dx$.\nLet $dv = \\cos(2\\pi f x) dx$, which gives $v = \\frac{\\sin(2\\pi f x)}{2\\pi f}$.\n\nApplying the integration by parts formula:\n$$ \\int_{0}^{\\Delta} \\left(1 - \\frac{x}{\\Delta}\\right) \\cos(2\\pi f x) dx = \\left[\\left(1 - \\frac{x}{\\Delta}\\right) \\frac{\\sin(2\\pi f x)}{2\\pi f}\\right]_0^\\Delta - \\int_{0}^{\\Delta} \\frac{\\sin(2\\pi f x)}{2\\pi f} \\left(-\\frac{1}{\\Delta}\\right) dx $$\nThe first term evaluates to zero at both limits:\n- At the upper limit $x = \\Delta$, the term $(1 - \\frac{\\Delta}{\\Delta})$ is zero.\n- At the lower limit $x = 0$, the term $\\sin(0)$ is zero.\nThus, we are left with the second term:\n$$ = \\frac{1}{2\\pi f \\Delta} \\int_{0}^{\\Delta} \\sin(2\\pi f x) dx $$\n$$ = \\frac{1}{2\\pi f \\Delta} \\left[ -\\frac{\\cos(2\\pi f x)}{2\\pi f} \\right]_0^\\Delta $$\n$$ = \\frac{1}{4\\pi^2 f^2 \\Delta} \\left( -\\cos(2\\pi f \\Delta) - (-\\cos(0)) \\right) = \\frac{1 - \\cos(2\\pi f \\Delta)}{4\\pi^2 f^2 \\Delta} $$\nNow, we use the trigonometric half-angle identity $1 - \\cos(2\\theta) = 2\\sin^2(\\theta)$. Let $2\\theta = 2\\pi f \\Delta$, so $\\theta = \\pi f \\Delta$.\nThe integral becomes:\n$$ \\frac{2\\sin^2(\\pi f \\Delta)}{4\\pi^2 f^2 \\Delta} = \\frac{\\sin^2(\\pi f \\Delta)}{2\\pi^2 f^2 \\Delta} $$\nSubstituting this back into the expression for the $\\text{OTF}$:\n$$ \\text{OTF}(f) = \\frac{2}{\\Delta} \\left( \\frac{\\sin^2(\\pi f \\Delta)}{2\\pi^2 f^2 \\Delta} \\right) = \\frac{\\sin^2(\\pi f \\Delta)}{\\pi^2 f^2 \\Delta^2} $$\nThis can be written in terms of the unnormalized sinc function, where $\\text{sinc}(z) = \\frac{\\sin(z)}{z}$, or the normalized sinc function, $\\text{sinc}_N(z) = \\frac{\\sin(\\pi z)}{\\pi z}$:\n$$ \\text{OTF}(f) = \\left( \\frac{\\sin(\\pi f \\Delta)}{\\pi f \\Delta} \\right)^2 = \\text{sinc}_N^2(f\\Delta) $$\nThe $\\text{MTF}$ is the magnitude of the $\\text{OTF}$. Since the squared sinc function is always real and non-negative, the magnitude is the function itself.\n$$ \\text{MTF}(f, \\Delta) = |\\text{OTF}(f)| = \\left( \\frac{\\sin(\\pi f \\Delta)}{\\pi f \\Delta} \\right)^2 $$\nThis is the required closed-form analytical expression.\n\nNow, we evaluate this expression at the given values: $f = 0.25$ cycles/mm and $\\Delta = 1$ mm.\n$$ \\text{MTF}(0.25, 1) = \\left( \\frac{\\sin(\\pi \\cdot 0.25 \\cdot 1)}{\\pi \\cdot 0.25 \\cdot 1} \\right)^2 = \\left( \\frac{\\sin(\\pi/4)}{\\pi/4} \\right)^2 $$\nWe know that $\\sin(\\pi/4) = \\frac{\\sqrt{2}}{2}$.\n$$ \\text{MTF}(0.25, 1) = \\left( \\frac{\\frac{\\sqrt{2}}{2}}{\\frac{\\pi}{4}} \\right)^2 = \\left( \\frac{\\sqrt{2}}{2} \\cdot \\frac{4}{\\pi} \\right)^2 = \\left( \\frac{2\\sqrt{2}}{\\pi} \\right)^2 $$\n$$ = \\frac{(2\\sqrt{2})^2}{\\pi^2} = \\frac{4 \\cdot 2}{\\pi^2} = \\frac{8}{\\pi^2} $$\nTo find the numerical value, we use $\\pi \\approx 3.14159265...$.\n$$ \\text{MTF} = \\frac{8}{\\pi^2} \\approx \\frac{8}{9.869604401...} \\approx 0.810569469... $$\nRounding to four significant figures, we get $0.8106$.\n\nThe derived analytical expression for the Modulation Transfer Function is $\\text{MTF}(f, \\Delta) = \\left( \\frac{\\sin(\\pi f \\Delta)}{\\pi f \\Delta} \\right)^2$.\nFor a spatial frequency of $f=0.25$ cycles per millimeter and a voxel spacing of $\\Delta=1$ millimeter, the value of the MTF is $\\frac{8}{\\pi^2}$, which is approximately $0.8106$.", "answer": "$$\\boxed{0.8106}$$", "id": "4536264"}]}