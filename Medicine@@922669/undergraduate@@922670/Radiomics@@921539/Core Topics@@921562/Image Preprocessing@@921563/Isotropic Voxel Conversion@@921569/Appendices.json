{"hands_on_practices": [{"introduction": "This practice serves as the essential starting point for any resampling workflow. It tackles the first fundamental question in isotropic conversion: what are the dimensions of the new, resampled image? We will explore how to calculate the new grid size to ensure the entire physical area, or Field of View (FOV), of the original scan is covered without losing information at the edges. This exercise grounds the abstract concept of resampling in a concrete calculation involving voxel spacing and image dimensions, forming the geometric foundation for the transformations that follow [@problem_id:4548200].", "problem": "A Computed Tomography (CT) volume is modeled as samples of an underlying continuous intensity field $f(\\mathbf{x})$, where $\\mathbf{x} \\in \\mathbb{R}^{3}$ denotes spatial position. The volume is acquired on a rectilinear lattice with axis-aligned spacings $(s_{x}, s_{y}, s_{z}) = (0.7\\,\\mathrm{mm}, 0.7\\,\\mathrm{mm}, 5.0\\,\\mathrm{mm})$ and integer dimensions $N_{x} \\times N_{y} \\times N_{z} = 512 \\times 512 \\times 100$. In radiomics preprocessing, isotropic voxel conversion seeks a lattice with equal spacing in all axes and a grid that covers the same physical field of view (FOV) without loss.\n\nStarting from the fundamental sampling relationship that the physical extent along axis $i \\in \\{x,y,z\\}$ is $L_{i} = N_{i} s_{i}$, and the principle that resampling should avoid aliasing while preserving the FOV, formulate a mathematically precise conversion objective for achieving $1.0\\,\\mathrm{mm}$ isotropic spacing. Your objective must include: (i) an isotropy constraint on the target spacings, (ii) a coverage constraint on the resampled grid extents, and (iii) a fidelity term defined on the continuous domain that quantifies interpolation-induced deviation, using a standard $L^{2}$ criterion.\n\nThen, compute the new integer grid dimensions that satisfy your coverage constraint when resampling to $1.0\\,\\mathrm{mm}$ isotropy, and compute the resulting sampling density (number of voxels per unit volume) of the resampled lattice.\n\nExpress the final sampling density in voxels per cubic millimeter. You must report the three integer dimensions and the sampling density. Do not include units in your final answer box. No rounding to a specified number of significant figures is required in this problem; report exact integers where applicable.", "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, and objective. It presents a standard task in medical image processing (radiomics), providing all necessary data and constraints for a unique and meaningful solution. The problem is free of any invalidating flaws.\n\nThe task is twofold: first, to formulate a mathematical objective for isotropic voxel conversion, and second, to apply this formulation to compute new grid dimensions and the resulting sampling density for a specific CT volume.\n\nFirst, we formulate the conversion objective. Let the original CT volume be represented by a set of discrete samples on a rectilinear lattice. The lattice has axis-aligned spacings $(s_x, s_y, s_z)$ and integer dimensions $(N_x, N_y, N_z)$. These samples are taken from an underlying continuous intensity field, $f(\\mathbf{x})$, where $\\mathbf{x} \\in \\mathbb{R}^3$. The resampling process aims to generate a new set of samples on a target lattice with isotropic spacings $(s'_x, s'_y, s'_z)$ and new integer dimensions $(N'_x, N'_y, N'_z)$. The conversion objective is based on three principles: isotropy, coverage, and fidelity.\n\nLet $s_{iso}$ be the desired isotropic spacing. Let $\\hat{f}(\\mathbf{x})$ be the continuous field reconstructed from the original discrete samples via some interpolation method. The goal is to find the resampled grid parameters and the reconstruction function that minimize the interpolation error while satisfying the geometric constraints. The comprehensive objective is:\n$$\n\\min_{N'_x, N'_y, N'_z, \\hat{f}} \\mathcal{E}\n$$\nsubject to isotropy and coverage constraints, where the components are defined as follows:\n\n(i) Isotropy Constraint: This constraint forces the voxel spacings in the resampled grid to be equal in all dimensions. The target isotropic spacing is given as $s_{iso} = 1.0\\,\\mathrm{mm}$. The constraint is expressed as:\n$$\ns'_{x} = s'_{y} = s'_{z} = s_{iso}\n$$\n\n(ii) Coverage Constraint: This constraint ensures that the physical volume, or Field of View (FOV), of the original scan is fully encompassed by the resampled grid, preventing loss of data at the boundaries. The physical extent (FOV) along an axis $i \\in \\{x, y, z\\}$ is given by the product of the number of voxels and the voxel spacing, $L_i = N_i s_i$. For the resampled grid, the extent is $L'_i = N'_i s'_i$. The coverage constraint requires $L'_i \\ge L_i$ for each axis. Since the new dimensions $N'_i$ must be integers, the tightest form of this constraint for a given target spacing $s'_i$ is to choose the smallest integer $N'_i$ that satisfies the inequality:\n$$\nN'_i \\ge \\frac{N_i s_i}{s'_i} \\implies N'_i = \\left\\lceil \\frac{N_i s_i}{s'_i} \\right\\rceil\n$$\n\n(iii) Fidelity Term: This term quantifies the deviation of the resampled image from the true underlying signal, which arises from the inherent limitations of reconstructing a continuous function from discrete samples. The problem specifies an $L^2$ criterion. The fidelity error, $\\mathcal{E}$, is the integrated squared difference between the true continuous field $f(\\mathbf{x})$ and the reconstructed field $\\hat{f}(\\mathbf{x})$ over the spatial domain of the original image, $\\Omega = [0, L_x] \\times [0, L_y] \\times [0, L_z]$:\n$$\n\\mathcal{E} = \\int_{\\Omega} |f(\\mathbf{x}) - \\hat{f}(\\mathbf{x})|^2 \\, d\\mathbf{x}\n$$\nMinimizing this term corresponds to finding the optimal interpolation function $\\hat{f}$ for a given set of original samples and interpolation strategy (e.g., linear, cubic spline, etc.).\n\nNow, we compute the new integer grid dimensions and the sampling density based on the provided data.\nThe given original parameters are:\n- Spacings: $(s_x, s_y, s_z) = (0.7\\,\\mathrm{mm}, 0.7\\,\\mathrm{mm}, 5.0\\,\\mathrm{mm})$\n- Dimensions: $(N_x, N_y, N_z) = (512, 512, 100)$\nThe target isotropic spacing is $s_{iso} = 1.0\\,\\mathrm{mm}$, so $s'_x = s'_y = s'_z = 1.0\\,\\mathrm{mm}$.\n\nFirst, we calculate the physical Field of View (FOV) for each axis of the original CT volume:\n- $L_x = N_x s_x = 512 \\times 0.7\\,\\mathrm{mm} = 358.4\\,\\mathrm{mm}$\n- $L_y = N_y s_y = 512 \\times 0.7\\,\\mathrm{mm} = 358.4\\,\\mathrm{mm}$\n- $L_z = N_z s_z = 100 \\times 5.0\\,\\mathrm{mm} = 500.0\\,\\mathrm{mm}$\n\nNext, we apply the coverage constraint to determine the new integer dimensions $(N'_x, N'_y, N'_z)$. The new dimensions must be large enough to cover the original FOV with the new spacing of $1.0\\,\\mathrm{mm}$. We use the ceiling function to ensure full coverage.\n- $N'_x = \\left\\lceil \\frac{L_x}{s'_x} \\right\\rceil = \\left\\lceil \\frac{358.4\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 358.4 \\rceil = 359$\n- $N'_y = \\left\\lceil \\frac{L_y}{s'_y} \\right\\rceil = \\left\\lceil \\frac{358.4\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 358.4 \\rceil = 359$\n- $N'_z = \\left\\lceil \\frac{L_z}{s'_z} \\right\\rceil = \\left\\lceil \\frac{500.0\\,\\mathrm{mm}}{1.0\\,\\mathrm{mm}} \\right\\rceil = \\lceil 500.0 \\rceil = 500$\nThe new grid dimensions are thus $359 \\times 359 \\times 500$.\n\nFinally, we compute the sampling density of the resampled lattice. Sampling density, $\\rho'$, is defined as the number of voxels per unit volume. This is the reciprocal of the volume of a single voxel in the resampled grid, $V'_{voxel}$.\nThe volume of a single voxel in the new isotropic grid is:\n$$\nV'_{voxel} = s'_x \\times s'_y \\times s'_z = 1.0\\,\\mathrm{mm} \\times 1.0\\,\\mathrm{mm} \\times 1.0\\,\\mathrm{mm} = 1.0\\,\\mathrm{mm}^3\n$$\nThe resulting sampling density is:\n$$\n\\rho' = \\frac{1}{V'_{voxel}} = \\frac{1}{1.0\\,\\mathrm{mm}^3} = 1.0\\,\\mathrm{voxels}/\\mathrm{mm}^3\n$$\nThe required values are the new dimensions $(359, 359, 500)$ and the sampling density $1.0$.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n359 & 359 & 500 & 1.0\n\\end{pmatrix}\n}\n$$", "id": "4548200"}, {"introduction": "After defining the coordinates of our new isotropic grid, the next critical step is to assign an intensity value to each new voxel. This is achieved through interpolation, a process of estimating values at unknown locations based on known surrounding data. This exercise guides you through a first-principles derivation of trilinear interpolation, a foundational method in medical imaging that treats intensity as varying linearly along each axis [@problem_id:4548165]. Understanding how this weighted average is constructed is key to appreciating how resampling generates new image data from the original discrete samples.", "problem": "A three-dimensional medical image acquired by Computed Tomography (CT) is represented as a scalar intensity field $I(x,y,z)$ sampled on a rectilinear grid of voxels. In radiomics preprocessing for isotropic voxel conversion, a common step is to resample the intensity field onto an isotropic grid by interpolating values at new sample locations. Consider one original voxel cube with eight corner intensities labeled $I_{000}$, $I_{100}$, $I_{010}$, $I_{110}$, $I_{001}$, $I_{101}$, $I_{011}$, and $I_{111}$, where the subscripts indicate the corner at fractional coordinates $(u,v,w)$ with each of $u$, $v$, and $w$ taking values in $\\{0,1\\}$ relative to the voxel’s local axes. Assume the intensity field $I(x,y,z)$ varies linearly along each axis within the voxel and is continuous inside the voxel.\n\nStarting from the fundamental definition that a one-dimensional linear interpolant is the unique linear function that matches the values at two endpoints, and using the physical model that the three-dimensional interpolant inside a voxel is separable across axes (so that variation along each axis is linear independently), derive, from first principles, a closed-form expression for the interpolated intensity $I(u,v,w)$ at an arbitrary point inside the voxel with fractional coordinates $(u,v,w)$, where $u,v,w \\in [0,1]$. Express your final formula solely in terms of $u$, $v$, $w$, and the eight corner intensities $I_{000}$, $I_{100}$, $I_{010}$, $I_{110}$, $I_{001}$, $I_{101}$, $I_{011}$, and $I_{111}$. The final answer must be a single closed-form analytic expression. No numerical evaluation or rounding is required.", "solution": "The problem statement is assessed to be valid. It is scientifically grounded, well-posed, and objective. It presents a standard problem in computational science and medical imaging—the derivation of the trilinear interpolation formula—from first principles. All necessary information and constraints are provided, and there are no ambiguities, contradictions, or factual inaccuracies. The task is to formalize and execute a mathematical derivation based on the provided premises.\n\nThe fundamental principle given is one-dimensional linear interpolation. For a function $f(x)$ with known values $f(0) = y_0$ and $f(1) = y_1$, the unique linear interpolant for a point $u \\in [0,1]$ is given by:\n$$f(u) = y_0(1-u) + y_1 u$$\nThis formula represents a weighted average of the endpoint values, where the weights are linear functions of the fractional distance $u$.\n\nThe problem states that the three-dimensional interpolant $I(u,v,w)$ is separable across the axes. This means we can obtain the final value by applying the one-dimensional linear interpolation sequentially along each of the three axes ($u$, $v$, and $w$). The order of interpolation is irrelevant; for this derivation, we will proceed in the order of $u$, then $v$, then $w$.\n\nLet the eight corner intensities of the voxel be $I_{000}$, $I_{100}$, $I_{010}$, $I_{110}$, $I_{001}$, $I_{101}$, $I_{011}$, and $I_{111}$, where $I_{ijk}$ corresponds to the intensity at the corner with fractional coordinates $(i,j,k)$ where $i,j,k \\in \\{0,1\\}$. We seek the interpolated intensity $I(u,v,w)$ at an arbitrary point $(u,v,w)$ where $u,v,w \\in [0,1]$.\n\n**Step 1: Interpolation along the u-axis**\n\nWe first perform four linear interpolations along the $u$-axis, corresponding to the four edges of the cube that are parallel to the local $x$-axis.\n\n1.  Interpolate between $I_{000}$ and $I_{100}$ (along the edge where $v=0$ and $w=0$):\n    $$I(u,0,0) = I_{000}(1-u) + I_{100}u$$\n2.  Interpolate between $I_{010}$ and $I_{110}$ (along the edge where $v=1$ and $w=0$):\n    $$I(u,1,0) = I_{010}(1-u) + I_{110}u$$\n3.  Interpolate between $I_{001}$ and $I_{101}$ (along the edge where $v=0$ and $w=1$):\n    $$I(u,0,1) = I_{001}(1-u) + I_{101}u$$\n4.  Interpolate between $I_{011}$ and $I_{111}$ (along the edge where $v=1$ and $w=1$):\n    $$I(u,1,1) = I_{011}(1-u) + I_{111}u$$\n\nLet us denote these intermediate values as $I_{u00}$, $I_{u10}$, $I_{u01}$, and $I_{u11}$ for conciseness.\n\n**Step 2: Interpolation along the v-axis**\n\nNext, we interpolate along the $v$-axis using the four values computed in Step 1. These values lie on a plane at the fractional distance $u$. We perform two linear interpolations.\n\n1.  Interpolate between $I(u,0,0)$ and $I(u,1,0)$ (on the plane where $w=0$):\n    $$I(u,v,0) = I(u,0,0)(1-v) + I(u,1,0)v$$\n2.  Interpolate between $I(u,0,1)$ and $I(u,1,1)$ (on the plane where $w=1$):\n    $$I(u,v,1) = I(u,0,1)(1-v) + I(u,1,1)v$$\n\n**Step 3: Interpolation along the w-axis**\n\nFinally, we perform a single interpolation along the $w$-axis using the two values computed in Step 2. These two values lie on a line at fractional coordinates $(u,v)$.\n\n$$I(u,v,w) = I(u,v,0)(1-w) + I(u,v,1)w$$\n\n**Step 4: Derivation of the Closed-Form Expression**\n\nTo obtain the final closed-form expression, we substitute the expressions from the preceding steps into the final equation.\n\nSubstitute the expressions for $I(u,v,0)$ and $I(u,v,1)$ from Step 2 into the equation from Step 3:\n$$I(u,v,w) = [I(u,0,0)(1-v) + I(u,1,0)v](1-w) + [I(u,0,1)(1-v) + I(u,1,1)v]w$$\n\nNow, substitute the expressions for $I(u,0,0)$, $I(u,1,0)$, $I(u,0,1)$, and $I(u,1,1)$ from Step 1:\n\\begin{align*}\nI(u,v,w) = & \\Big[ \\big(I_{000}(1-u) + I_{100}u\\big)(1-v) + \\big(I_{010}(1-u) + I_{110}u\\big)v \\Big](1-w) \\\\\n+ & \\Big[ \\big(I_{001}(1-u) + I_{101}u\\big)(1-v) + \\big(I_{011}(1-u) + I_{111}u\\big)v \\Big]w\n\\end{align*}\nExpanding the terms by distributing $(1-w)$ and $w$:\n\\begin{align*}\nI(u,v,w) = & \\big(I_{000}(1-u) + I_{100}u\\big)(1-v)(1-w) + \\big(I_{010}(1-u) + I_{110}u\\big)v(1-w) \\\\\n+ & \\big(I_{001}(1-u) + I_{101}u\\big)(1-v)w + \\big(I_{011}(1-u) + I_{111}u\\big)vw\n\\end{align*}\nFinally, we expand all products and group the terms by the eight corner intensities $I_{ijk}$:\n\\begin{align*}\nI(u,v,w) = & \\ I_{000}(1-u)(1-v)(1-w) + I_{100}u(1-v)(1-w) \\\\\n+ & \\ I_{010}(1-u)v(1-w) + I_{110}uv(1-w) \\\\\n+ & \\ I_{001}(1-u)(1-v)w + I_{101}u(1-v)w \\\\\n+ & \\ I_{011}(1-u)vw + I_{111}uvw\n\\end{align*}\nThis is the closed-form expression for trilinear interpolation. Each corner intensity $I_{ijk}$ is weighted by a product of three terms. The weight for a given corner is the volume of the rectangular sub-volume diagonally opposite to it, defined by the point $(u,v,w)$ and the three planes passing through it parallel to the faces of the unit cube. The sum of the eight weights is equal to $1$ for any $(u,v,w) \\in [0,1]^3$.\nFor example, the weight for $I_{000}$ is $(1-u)(1-v)(1-w)$, which is equal to $1$ at $(0,0,0)$ and $0$ if any of $u$, $v$, or $w$ are $1$. Conversely, the weight for $I_{111}$ is $uvw$, which is $1$ at $(1,1,1)$ and $0$ if any of $u$, $v$, or $w$ are $0$. This matches the physical and mathematical intuition for interpolation.\nThe requested expression is the sum of these eight weighted terms.", "answer": "$$\n\\boxed{\nI_{000}(1-u)(1-v)(1-w) + I_{100}u(1-v)(1-w) + I_{010}(1-u)v(1-w) + I_{110}uv(1-w) + I_{001}(1-u)(1-v)w + I_{101}u(1-v)w + I_{011}(1-u)vw + I_{111}uvw\n}\n$$", "id": "4548165"}, {"introduction": "Isotropic conversion affects not only the grayscale image but also any associated data, like segmentation masks that delineate tumors or organs. Unlike continuous intensity images, these masks require a different approach—nearest-neighbor interpolation—to preserve their discrete, categorical labels. This hands-on coding practice simulates a complete workflow, from creating a synthetic label mask to performing a round-trip resampling and evaluating the geometric changes using the Dice Similarity Coefficient (DSC) [@problem_id:4548194]. This exercise provides a tangible demonstration of the practical consequences of resampling and introduces a standard metric for quantifying the fidelity of the transformation.", "problem": "You are given a three-dimensional label volume (a segmentation mask) defined on an anisotropic voxel grid. In Radiomics, standardizing images to an isotropic voxel grid is often necessary for reproducible feature extraction. The label resampling must preserve categorical semantics and therefore should use nearest-neighbor interpolation, not continuous intensity interpolation. Your task is to derive, implement, and evaluate a nearest-neighbor isotropic voxel conversion for label volumes and then quantify how much the segmentation changes by computing the Dice Similarity Coefficient (DSC) between the original labels and the labels that have been resampled to isotropic spacing and then mapped back to the original grid.\n\nStart from the following fundamental base:\n- A voxel grid is a regular sampling of a continuous space. If the original grid has spacing $(s_x,s_y,s_z)$ in millimeters, the center of the voxel at integer indices $(i,j,k)$ is at world coordinates $(x,y,z) = \\big((i+\\tfrac{1}{2})s_x,(j+\\tfrac{1}{2})s_y,(k+\\tfrac{1}{2})s_z\\big)$.\n- Nearest-neighbor resampling maps a target voxel center at world coordinate $(x_t,y_t,z_t)$ to the source voxel index $(i_s,j_s,k_s)$ that minimizes the Euclidean distance to the source voxel centers. For separable axes and regular grids, this reduces to $i_s=\\mathrm{round}\\!\\left(\\frac{x_t}{s_x}-\\tfrac{1}{2}\\right)$, $j_s=\\mathrm{round}\\!\\left(\\frac{y_t}{s_y}-\\tfrac{1}{2}\\right)$, and $k_s=\\mathrm{round}\\!\\left(\\frac{z_t}{s_z}-\\tfrac{1}{2}\\right)$ with clipping to valid index ranges.\n- The Dice Similarity Coefficient (DSC) between two label sets $A$ and $B$ is defined as\n$$\n\\mathrm{DSC}(A,B)=\\frac{2\\,|A\\cap B|}{|A|+|B|},\n$$\nwith the convention that if $|A|=|B|=0$ then $\\mathrm{DSC}(A,B)=1$ and if only one is empty then $\\mathrm{DSC}(A,B)=0$.\n\nImplement the following steps:\n1. Generate an original label volume by sampling a continuous axis-aligned ellipsoid defined in world coordinates by\n$$\n\\left(\\frac{x-c_x}{r_x}\\right)^2+\\left(\\frac{y-c_y}{r_y}\\right)^2+\\left(\\frac{z-c_z}{r_z}\\right)^2 \\le 1,\n$$\nwhere $(c_x,c_y,c_z)$ are the ellipsoid center coordinates in millimeters and $(r_x,r_y,r_z)$ are its semi-axes (radii) in millimeters. Use voxel centers to evaluate inclusion.\n2. Compute the isotropic resampling of the original label to a target spacing $(s,s,s)$ in millimeters by nearest-neighbor interpolation, preserving the original field of view. The target grid size along each axis should be determined from the original physical extent $L_\\alpha = N_\\alpha s_\\alpha$ by $N'_\\alpha=\\mathrm{round}\\!\\left(\\frac{L_\\alpha}{s}\\right)$ for $\\alpha\\in\\{x,y,z\\}$, where $N_\\alpha$ is the original number of voxels along axis $\\alpha$.\n3. Map the isotropic label back to the original grid using nearest-neighbor interpolation so that both labels live on the same original grid.\n4. Compute $\\mathrm{DSC}$ between the original and the round-trip resampled label and report the value as a decimal rounded to six digits.\n\nPhysical units: all spacings and geometric parameters are specified in millimeters ($\\mathrm{mm}$). Express all outputs as decimals rounded to six digits.\n\nAngle unit: not applicable.\n\nYour program must evaluate the following test suite and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example `[result_1,result_2,result_3]`.\n\nTest Suite (happy path, identity boundary, thin-structure edge, near-boundary aliasing):\n- Case $1$ (anisotropy to isotropy): original grid size $(N_x,N_y,N_z) = (64,48,16)$, original spacing $(s_x,s_y,s_z) = (1.0\\,\\mathrm{mm}, 1.0\\,\\mathrm{mm}, 3.0\\,\\mathrm{mm})$, isotropic spacing $s=1.0\\,\\mathrm{mm}$, ellipsoid center $(c_x,c_y,c_z)=\\big((32\\cdot 1.0)+2.0, (24\\cdot 1.0)-3.0, (8\\cdot 3.0)+1.5\\big)\\,\\mathrm{mm}$, ellipsoid radii $(r_x,r_y,r_z) = (20.0\\,\\mathrm{mm}, 12.0\\,\\mathrm{mm}, 18.0\\,\\mathrm{mm})$.\n- Case $2$ (identity): original grid size $(40,40,40)$, original spacing $(1.5\\,\\mathrm{mm}, 1.5\\,\\mathrm{mm}, 1.5\\,\\mathrm{mm})$, isotropic spacing $s=1.5\\,\\mathrm{mm}$, ellipsoid center $(c_x,c_y,c_z)=\\big((20\\cdot 1.5), (20\\cdot 1.5), (20\\cdot 1.5)\\big)\\,\\mathrm{mm}$, ellipsoid radii $(18.0\\,\\mathrm{mm}, 9.0\\,\\mathrm{mm}, 10.5\\,\\mathrm{mm})$.\n- Case $3$ (thin structure along $z$): original grid size $(80,80,30)$, original spacing $(0.8\\,\\mathrm{mm}, 0.8\\,\\mathrm{mm}, 2.4\\,\\mathrm{mm})$, isotropic spacing $s=0.8\\,\\mathrm{mm}$, ellipsoid center $(c_x,c_y,c_z)=\\big((40\\cdot 0.8), (40\\cdot 0.8), (15\\cdot 2.4)+1.2\\big)\\,\\mathrm{mm}$, ellipsoid radii $(12.0\\,\\mathrm{mm}, 10.0\\,\\mathrm{mm}, 1.2\\,\\mathrm{mm})$.\n- Case $4$ (near-boundary aliasing): original grid size $(50,30,25)$, original spacing $(1.2\\,\\mathrm{mm}, 2.0\\,\\mathrm{mm}, 2.0\\,\\mathrm{mm})$, isotropic spacing $s=1.0\\,\\mathrm{mm}$, ellipsoid center $(c_x,c_y,c_z) = (5.0\\,\\mathrm{mm}, 10.0\\,\\mathrm{mm}, 15.0\\,\\mathrm{mm})$, ellipsoid radii $(12.0\\,\\mathrm{mm}, 8.0\\,\\mathrm{mm}, 7.0\\,\\mathrm{mm})$.\n\nYour program should produce a single line of output containing the four DSC values for the cases above as a comma-separated list enclosed in square brackets, with each value rounded to six decimal places, for example `[...]`. No other text should be printed.", "solution": "The problem requires the implementation of a nearest-neighbor isotropic resampling process for a 3D label volume, followed by a resampling back to the original grid (a \"round-trip\"). The objective is to quantify the difference between the original and the round-trip resampled label volumes using the Dice Similarity Coefficient (DSC).\n\nThe process will be executed for four distinct test cases, each defined by grid dimensions, voxel spacings, and the parameters of an ellipsoid used to generate the initial label volume.\n\nThe solution is structured as a sequence of four main steps, as outlined in the problem statement.\n\n### Step 1: Generation of the Original Label Volume\n\nFirst, we must create the initial binary label volume, denoted as $A$. This volume is defined on a 3D grid with dimensions $(N_x, N_y, N_z)$ and anisotropic voxel spacing $(s_x, s_y, s_z)$. A voxel at integer grid index $(i, j, k)$ is considered part of the label (value $1$) if its center's world coordinates $(x, y, z)$ satisfy the ellipsoid equation:\n$$\n\\left(\\frac{x-c_x}{r_x}\\right)^2+\\left(\\frac{y-c_y}{r_y}\\right)^2+\\left(\\frac{z-c_z}{r_z}\\right)^2 \\le 1\n$$\nThe world coordinates of a voxel center at index $(i, j, k)$ are given by:\n$$\nx = (i + 0.5)s_x, \\quad y = (j + 0.5)s_y, \\quad z = (k + 0.5)s_z\n$$\nTo implement this efficiently, we can generate three coordinate matrices corresponding to the $x$, $y$, and $z$ world coordinates of every voxel center in the grid. Then, we apply the ellipsoid inequality in a vectorized manner to produce the 3D boolean mask.\n\n### Step 2: Isotropic Resampling (Forward Pass)\n\nThe original label volume $A$ is resampled to a new grid with a uniform, isotropic spacing $s$. The new grid must preserve the original field of view (FOV). The physical extent (FOV) of the original volume along each axis $\\alpha \\in \\{x, y, z\\}$ is $L_\\alpha = N_\\alpha s_\\alpha$. The number of voxels in the new isotropic grid, $N'_\\alpha$, is determined by:\n$$\nN'_\\alpha = \\mathrm{round}\\left(\\frac{L_\\alpha}{s}\\right) = \\mathrm{round}\\left(\\frac{N_\\alpha s_\\alpha}{s}\\right)\n$$\nThe new grid has dimensions $(N'_x, N'_y, N'_z)$ and spacing $(s, s, s)$.\n\nTo populate this new grid, we use nearest-neighbor interpolation. For each voxel in the target isotropic grid at index $(i_t, j_t, k_t)$, we first determine its world coordinates $(x_t, y_t, z_t)$:\n$$\nx_t = (i_t + 0.5)s, \\quad y_t = (j_t + 0.5)s, \\quad z_t = (k_t + 0.5)s\n$$\nThen, we find the index $(i_s, j_s, k_s)$ of the closest voxel in the original (source) grid. The problem provides the formula for this mapping, which is derived from minimizing the Euclidean distance between voxel centers:\n$$\ni_s = \\mathrm{round}\\left(\\frac{x_t}{s_x} - 0.5\\right)\n$$\nwith analogous formulas for $j_s$ and $k_s$. The `round()` function is interpreted as standard rounding (round half up), implementable as $\\lfloor v + 0.5 \\rfloor$. The resulting indices must be clipped to the valid range of the source grid, i.e., $[0, N_\\alpha - 1]$. The value of the target voxel is then set to the value of the source voxel at the computed index. This procedure results in the isotropically resampled label volume, $L_{iso}$.\n\n### Step 3: Mapping Back to Original Grid (Backward Pass)\n\nNext, the isotropic label volume $L_{iso}$ is resampled back to the original grid geometry (dimensions $(N_x, N_y, N_z)$, spacing $(s_x, s_y, s_z)$). This creates the round-trip resampled label volume, $B$. The process is identical to Step 2, but the roles of the grids are reversed:\n-   **Source Grid**: The isotropic grid with dimensions $(N'_x, N'_y, N'_z)$ and spacing $(s, s, s)$.\n-   **Target Grid**: The original grid with dimensions $(N_x, N_y, N_z)$ and spacing $(s_x, s_y, s_z)$.\n\nFor each voxel in the target (original) grid at index $(i_t, j_t, k_t)$, we find its world coordinates $(x_t, y_t, z_t) = ((i_t+0.5)s_x, \\dots)$. We then map these coordinates to the nearest neighbor index $(i_s, j_s, k_s)$ in the source (isotropic) grid using:\n$$\ni_s = \\mathrm{round}\\left(\\frac{x_t}{s} - 0.5\\right)\n$$\nAgain, indices are clipped, and the value from $L_{iso}$ at $(i_s, j_s, k_s)$ is assigned to the voxel in $B$ at $(i_t, j_t, k_t)$.\n\n### Step 4: Dice Similarity Coefficient (DSC) Calculation\n\nFinally, we quantify the change between the original label volume $A$ and the round-trip resampled volume $B$ using the Dice Similarity Coefficient:\n$$\n\\mathrm{DSC}(A,B) = \\frac{2 \\cdot |A \\cap B|}{|A| + |B|}\n$$\nwhere $|A|$ represents the number of voxels in label $A$ (i.e., its volume), and $|A \\cap B|$ is the number of voxels common to both labels. For binary (0/1) arrays, these quantities are computed as:\n-   $|A| = \\sum A_{ijk}$\n-   $|B| = \\sum B_{ijk}$\n-   $|A \\cap B| = \\sum (A_{ijk} \\cdot B_{ijk})$\n\nThe special case where both volumes are empty ($|A| + |B| = 0$) results in a DSC of $1.0$, as per the problem's convention. If the denominator is non-zero, the formula is applied directly. The final DSC value is rounded to six decimal places.\n\nThis entire four-step process is applied to each of the test cases provided.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the isotropic voxel conversion problem for a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (anisotropy to isotropy)\n        {\n            \"N_orig\": (64, 48, 16),\n            \"s_orig\": (1.0, 1.0, 3.0),\n            \"s_iso\": 1.0,\n            \"c\": ((32 * 1.0) + 2.0, (24 * 1.0) - 3.0, (8 * 3.0) + 1.5),\n            \"r\": (20.0, 12.0, 18.0),\n        },\n        # Case 2 (identity)\n        {\n            \"N_orig\": (40, 40, 40),\n            \"s_orig\": (1.5, 1.5, 1.5),\n            \"s_iso\": 1.5,\n            \"c\": ((20 * 1.5), (20 * 1.5), (20 * 1.5)),\n            \"r\": (18.0, 9.0, 10.5),\n        },\n        # Case 3 (thin structure along z)\n        {\n            \"N_orig\": (80, 80, 30),\n            \"s_orig\": (0.8, 0.8, 2.4),\n            \"s_iso\": 0.8,\n            \"c\": ((40 * 0.8), (40 * 0.8), (15 * 2.4) + 1.2),\n            \"r\": (12.0, 10.0, 1.2),\n        },\n        # Case 4 (near-boundary aliasing)\n        {\n            \"N_orig\": (50, 30, 25),\n            \"s_orig\": (1.2, 2.0, 2.0),\n            \"s_iso\": 1.0,\n            \"c\": (5.0, 10.0, 15.0),\n            \"r\": (12.0, 8.0, 7.0),\n        }\n    ]\n\n    results = []\n    \n    # Custom rounding function to implement floor(x + 0.5)\n    def custom_round(x):\n        return np.floor(x + 0.5).astype(int)\n\n    def resample_nearest_neighbor(source_volume, source_spacing, target_shape, target_spacing):\n        \"\"\"\n        Resamples a volume using nearest-neighbor interpolation.\n        \"\"\"\n        # Create grid of indices for the target volume\n        target_indices = np.mgrid[0:target_shape[0], 0:target_shape[1], 0:target_shape[2]]\n        \n        # Convert target indices to world coordinates\n        # (indices + 0.5) * spacing\n        target_coords = (target_indices.astype(float) + 0.5) * np.array(target_spacing).reshape(3, 1, 1, 1)\n\n        # Map target world coordinates to source continuous indices\n        # coord / spacing - 0.5\n        source_continuous_indices = target_coords / np.array(source_spacing).reshape(3, 1, 1, 1) - 0.5\n        \n        # Round to nearest integer indices\n        source_indices = custom_round(source_continuous_indices)\n\n        # Clip indices to be within the bounds of the source volume\n        source_indices[0] = np.clip(source_indices[0], 0, source_volume.shape[0] - 1)\n        source_indices[1] = np.clip(source_indices[1], 0, source_volume.shape[1] - 1)\n        source_indices[2] = np.clip(source_indices[2], 0, source_volume.shape[2] - 1)\n        \n        # Create target volume by indexing source volume\n        target_volume = source_volume[source_indices[0], source_indices[1], source_indices[2]]\n        \n        return target_volume\n\n    def calculate_dsc(label_a, label_b):\n        \"\"\"\n        Calculates the Dice Similarity Coefficient between two label volumes.\n        \"\"\"\n        intersection = np.sum(label_a * label_b)\n        sum_a = np.sum(label_a)\n        sum_b = np.sum(label_b)\n        \n        denominator = sum_a + sum_b\n        \n        if denominator == 0:\n            return 1.0  # Both masks are empty\n        else:\n            return 2.0 * intersection / denominator\n\n    for case in test_cases:\n        N_orig = case[\"N_orig\"]\n        s_orig = case[\"s_orig\"]\n        s_iso = case[\"s_iso\"]\n        center = case[\"c\"]\n        radii = case[\"r\"]\n\n        # Step 1: Generate original label volume\n        orig_indices = np.mgrid[0:N_orig[0], 0:N_orig[1], 0:N_orig[2]]\n        orig_coords = (orig_indices.astype(float) + 0.5) * np.array(s_orig).reshape(3, 1, 1, 1)\n        \n        ellipsoid_term = (\n            ((orig_coords[0] - center[0]) / radii[0])**2 +\n            ((orig_coords[1] - center[1]) / radii[1])**2 +\n            ((orig_coords[2] - center[2]) / radii[2])**2\n        )\n        original_label = (ellipsoid_term <= 1).astype(np.uint8)\n\n        # Step 2: Resample to isotropic grid\n        L_alpha = np.array(N_orig) * np.array(s_orig)\n        N_iso = np.round(L_alpha / s_iso).astype(int)\n        \n        isotropic_label = resample_nearest_neighbor(\n            source_volume=original_label,\n            source_spacing=s_orig,\n            target_shape=N_iso,\n            target_spacing=(s_iso, s_iso, s_iso)\n        )\n\n        # Step 3: Map back to original grid\n        round_trip_label = resample_nearest_neighbor(\n            source_volume=isotropic_label,\n            source_spacing=(s_iso, s_iso, s_iso),\n            target_shape=N_orig,\n            target_spacing=s_orig\n        )\n\n        # Step 4: Compute DSC\n        dsc = calculate_dsc(original_label, round_trip_label)\n        results.append(f\"{dsc:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4548194"}]}