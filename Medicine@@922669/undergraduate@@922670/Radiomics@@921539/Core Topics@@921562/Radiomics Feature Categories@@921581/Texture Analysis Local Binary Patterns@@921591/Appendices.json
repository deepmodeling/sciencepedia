{"hands_on_practices": [{"introduction": "This first practice will ground your understanding in the fundamental mechanics of the Local Binary Pattern operator. By working through the calculation for a single pixel and its immediate neighbors, you will see precisely how a local texture is encoded into a compact binary string and its corresponding decimal value. This exercise [@problem_id:4612936] also introduces the concept of \"uniform\" patterns, an important extension that makes LBP features more robust and concise.", "problem": "In radiomics-driven analysis of Magnetic Resonance Imaging (MRI) textures, Local Binary Patterns (LBP) provide a compact representation of local micro-structures that is robust to monotonic grayscale transformations. Consider a single-channel grayscale $3\\times 3$ patch extracted from a T$_2$-weighted MRI slice. Let the center intensity be $g_c = 10$ and the $8$ neighbors sampled on a circle of radius $R=1$ in clockwise order starting from the neighbor at angle $0$ (the positive $x$-axis, “east”) be the sequence $[12, 9, 11, 8, 10, 13, 7, 10]$. Using the standard Local Binary Patterns (LBP) operator with $P=8$ neighbors and radius $R=1$, define the thresholding indicator for each neighbor intensity $g_p$ as $s(g_p - g_c)$, where $s(t)$ equals $1$ if $t \\ge 0$ and $0$ otherwise. Form the circular binary pattern in the given clockwise order, and interpret this pattern as a base-$2$ integer with the first neighbor (at angle $0$) assigned the least-significant bit and bit weights increasing clockwise. Then, determine the rotation-invariant uniform label by the canonical rule: if the circular binary pattern exhibits at most two transitions between $0$ and $1$, the label equals the number of ones in the pattern; otherwise, the label equals $P+1$. Compute the resulting $LBP_{8,1}$ code and its rotation-invariant uniform label. Report both values without units. The final answer must be a calculation and expressed as a single row matrix. No rounding is required.", "solution": "The problem requires the computation of the Local Binary Patterns ($LBP$) code and the corresponding rotation-invariant uniform label for a given $3\\times3$ image patch.\n\nThe validation of the problem statement is performed first.\n\n**Step 1: Extract Givens**\n- The image patch is a $3 \\times 3$ single-channel grayscale region.\n- The center pixel intensity is $g_c = 10$.\n- The number of neighbors is $P=8$ on a circle of radius $R=1$.\n- The sequence of $P=8$ neighbor intensities, starting from the east ($0$ degrees) and proceeding clockwise, is given as $[12, 9, 11, 8, 10, 13, 7, 10]$. Let's denote this sequence by $\\{g_p\\}_{p=0}^{7}$, so $g_0=12$, $g_1=9$, and so on.\n- The thresholding function is defined as $s(t)$, where $s(t) = 1$ if $t \\ge 0$ and $s(t) = 0$ if $t  0$.\n- The binary pattern is formed from the sequence of thresholded differences $s(g_p - g_c)$ for $p=0, 1, \\dots, 7$.\n- The $LBP$ code is the decimal value of the resulting $8$-bit binary number, where the bit from the first neighbor ($p=0$) is the least-significant bit (LSB), and bit weights increase clockwise.\n- The rotation-invariant uniform label is determined by a rule based on the number of spatial transitions (bit-flips from $0$ to $1$ or $1$ to $0$) in the circular binary pattern. Let this be $U(LBP)$.\n    - If $U(LBP) \\le 2$, the pattern is \"uniform\", and its label is the number of '1's in the pattern.\n    - If $U(LBP)  2$, the pattern is \"non-uniform\", and its label is $P+1$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded as it concerns the standard Local Binary Patterns operator, a fundamental technique in texture analysis and radiomics. It is well-posed, providing all necessary parameters, data, and unambiguous rules for computation. The language is objective and formal. The problem is complete, consistent, and computationally feasible. There are no violations of scientific principles, logical inconsistencies, or ambiguities.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A complete solution will be provided.\n\n**Solution Derivation**\n\nFirst, we compute the binary pattern by comparing each neighbor's intensity $g_p$ with the center intensity $g_c=10$. We apply the thresholding function $s(g_p - g_c)$.\n\nThe neighbor intensities are $g_0=12, g_1=9, g_2=11, g_3=8, g_4=10, g_5=13, g_6=7, g_7=10$.\n\nThe thresholded values, which form the bits of the pattern, are calculated as follows:\n- For $p=0$: $s(g_0 - g_c) = s(12 - 10) = s(2) = 1$.\n- For $p=1$: $s(g_1 - g_c) = s(9 - 10) = s(-1) = 0$.\n- For $p=2$: $s(g_2 - g_c) = s(11 - 10) = s(1) = 1$.\n- For $p=3$: $s(g_3 - g_c) = s(8 - 10) = s(-2) = 0$.\n- For $p=4$: $s(g_4 - g_c) = s(10 - 10) = s(0) = 1$.\n- For $p=5$: $s(g_5 - g_c) = s(13 - 10) = s(3) = 1$.\n- For $p=6$: $s(g_6 - g_c) = s(7 - 10) = s(-3) = 0$.\n- For $p=7$: $s(g_7 - g_c) = s(10 - 10) = s(0) = 1$.\n\nThe sequence of bits, corresponding to neighbors $p=0, \\dots, 7$, is $\\{s_p\\}_{p=0}^7 = \\{1, 0, 1, 0, 1, 1, 0, 1\\}$.\n\nNext, we calculate the $LBP_{8,1}$ code. The problem specifies that the bit from neighbor $p=0$ is the LSB. The formula for the $LBP$ code is:\n$$ LBP_{P,R} = \\sum_{p=0}^{P-1} s(g_p - g_c) \\cdot 2^p $$\nUsing $P=8$ and the bits we calculated:\n$$ LBP_{8,1} = s_0 \\cdot 2^0 + s_1 \\cdot 2^1 + s_2 \\cdot 2^2 + s_3 \\cdot 2^3 + s_4 \\cdot 2^4 + s_5 \\cdot 2^5 + s_6 \\cdot 2^6 + s_7 \\cdot 2^7 $$\nThe binary string, read from $s_7$ to $s_0$, is $10110101_2$.\n$$ LBP_{8,1} = 1 \\cdot 2^0 + 0 \\cdot 2^1 + 1 \\cdot 2^2 + 0 \\cdot 2^3 + 1 \\cdot 2^4 + 1 \\cdot 2^5 + 0 \\cdot 2^6 + 1 \\cdot 2^7 $$\n$$ LBP_{8,1} = 1 \\cdot 1 + 0 \\cdot 2 + 1 \\cdot 4 + 0 \\cdot 8 + 1 \\cdot 16 + 1 \\cdot 32 + 0 \\cdot 64 + 1 \\cdot 128 $$\n$$ LBP_{8,1} = 1 + 4 + 16 + 32 + 128 = 181 $$\nThe first required value, the $LBP_{8,1}$ code, is $181$.\n\nNow, we determine the rotation-invariant uniform label, denoted as $LBP_{P,R}^{riu2}$. We must count the number of transitions $U$ in the circular binary pattern $(s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7)$.\nThe pattern is $(1, 0, 1, 0, 1, 1, 0, 1)$.\nThe number of transitions $U$ is given by:\n$$ U = |s_{P-1} - s_0| + \\sum_{p=1}^{P-1} |s_p - s_{p-1}| $$\nWith $P=8$, the pattern is $(s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7) = (1, 0, 1, 0, 1, 1, 0, 1)$.\nLet's count the transitions sequentially:\n- $s_0 \\to s_1$: $1 \\to 0$, transition. ($1$)\n- $s_1 \\to s_2$: $0 \\to 1$, transition. ($2$)\n- $s_2 \\to s_3$: $1 \\to 0$, transition. ($3$)\n- $s_3 \\to s_4$: $0 \\to 1$, transition. ($4$)\n- $s_4 \\to s_5$: $1 \\to 1$, no transition.\n- $s_5 \\to s_6$: $1 \\to 0$, transition. ($5$)\n- $s_6 \\to s_7$: $0 \\to 1$, transition. ($6$)\n- $s_7 \\to s_0$ (circular part): $1 \\to 1$, no transition.\nThe total number of transitions is $U=6$.\n\nAccording to the rule for uniform patterns, a pattern is uniform if $U \\le 2$. Since $U=6$, which is greater than $2$, the pattern is non-uniform.\nFor non-uniform patterns, the rotation-invariant uniform label is defined as $P+1$.\nGiven $P=8$, the label is $8+1=9$.\n\nThe two computed values are the $LBP_{8,1}$ code, which is $181$, and its rotation-invariant uniform label, which is $9$. The final answer should be presented as a single row matrix.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n181  9\n\\end{pmatrix}\n}\n$$", "id": "4612936"}, {"introduction": "Moving from a single pixel to an entire region of interest, we encounter the practical challenge of handling image boundaries. The choice of how to compute LBP codes for pixels near an edge is not trivial and can significantly influence the final texture histogram. This exercise [@problem_id:4565398] asks you to formalize and apply several common border handling strategies, providing a clear view of how these decisions impact the results and introducing a quantitative method to compare them.", "problem": "In radiomics, Local Binary Patterns (LBP) are used to quantify local texture around each pixel of a region of interest (ROI). Consider the following ROI as a $3 \\times 3$ grayscale image with intensity values\n$$\nI = \\begin{pmatrix}\n10  10  10 \\\\\n10  20  10 \\\\\n10  10  10\n\\end{pmatrix}.\n$$\nThe LBP operator with $P=8$ neighbors at radius $R=1$ is defined as follows: for each pixel at coordinates $(r,c)$ with center intensity $I_{r,c}$, define the neighbor offsets in fixed order\n$$\n(\\Delta r_k, \\Delta c_k) = \\{(-1,-1),\\, (-1,0),\\, (-1,1),\\, (0,1),\\, (1,1),\\, (1,0),\\, (1,-1),\\, (0,-1)\\}, \\quad k = 0,1,\\dots,7,\n$$\nand the corresponding binary tests\n$$\nb_k(r,c) = \\begin{cases}\n1,  \\text{if } I_{r+\\Delta r_k,\\,c+\\Delta c_k} \\ge I_{r,c}, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\nThe LBP code for pixel $(r,c)$ is the integer\n$$\ns(r,c) = \\sum_{k=0}^{7} b_k(r,c)\\,2^{k}.\n$$\nAn LBP histogram is the distribution of codes $s(r,c)$ over the ROI pixels that are deemed valid under a specified border handling strategy, normalized to sum to $1$.\n\nFor pixels near the ROI boundary, four border handling strategies are commonly used:\n- Ignore: exclude any pixel whose $P$ neighbors at radius $R$ do not all lie within the ROI.\n- Mirror: for any neighbor index that would fall outside the ROI, map it back inside by reflecting across the closest ROI boundary.\n- Wrap: for any neighbor index that would fall outside the ROI, map it back inside by applying periodic (toroidal) boundary conditions.\n- Partial sampling: for any neighbor index that would fall outside theROI, assign the corresponding bit $b_k(r,c)$ the value $0$.\n\nStarting only from these fundamental definitions, first formalize each strategy as a precise mathematical rule acting on $(r+\\Delta r_k, c+\\Delta c_k)$, then derive the normalized LBP histogram for the given ROI under each strategy. Finally, quantify the impact of border handling by computing the Jensen–Shannon (JS) divergence between the normalized LBP histograms obtained from the Ignore and Mirror strategies. Use the natural logarithm for all information measures. Round your final numeric answer to four significant figures and express the divergence in nats.", "solution": "The problem is validated as self-contained, scientifically grounded, and well-posed. The solution proceeds in four stages: (1) formalizing the four border handling strategies, (2) calculating the Local Binary Pattern (LBP) codes for every pixel in the given $3 \\times 3$ region of interest (ROI) under each strategy, (3) constructing the normalized LBP histograms, and (4) computing the Jensen-Shannon (JS) divergence between the histograms from the 'Ignore' and 'Mirror' strategies.\n\nThe ROI is given by the intensity matrix $I$, with dimensions $N_r=3$ rows and $N_c=3$ columns. We use $1$-indexed coordinates $(r,c)$, where $r,c \\in \\{1, 2, 3\\}$.\n$$\nI = \\begin{pmatrix}\n10  10  10 \\\\\n10  20  10 \\\\\n10  10  10\n\\end{pmatrix}\n$$\nThe LBP operator is defined with $P=8$ neighbors at radius $R=1$. The neighbor offsets for $k = 0, \\dots, 7$ are $(\\Delta r_k, \\Delta c_k) = \\{(-1,-1), (-1,0), (-1,1), (0,1), (1,1), (1,0), (1,-1), (0,-1)\\}$. The LBP code for a pixel at $(r,c)$ is $s(r,c) = \\sum_{k=0}^{7} b_k(r,c) 2^k$, where $b_k(r,c)=1$ if the neighbor's intensity is greater than or equal to the center pixel's intensity $I_{r,c}$, and $b_k(r,c)=0$ otherwise.\n\n**1. Formalization of Border Handling Strategies**\n\nFor a center pixel at $(r,c)$, let a neighbor's raw coordinate be $(r', c') = (r+\\Delta r_k, c+\\Delta c_k)$. Let $(\\tilde{r}, \\tilde{c})$ be the mapped coordinate used to access intensity values. The ROI domain is $\\mathcal{D} = \\{(i,j) \\mid 1 \\le i \\le N_r, 1 \\le j \\le N_c\\}$.\n\n-   **Ignore**: The set of valid center pixels is restricted to those whose $3 \\times 3$ neighborhood is entirely within $\\mathcal{D}$. For any pixel $(r,c)$ in this set, we have $(\\tilde{r}, \\tilde{c}) = (r',c')$. Any pixel not meeting this condition is excluded from the histogram calculation.\n-   **Mirror**: All pixels in $\\mathcal{D}$ are processed. If a neighbor coordinate $(r',c')$ is outside $\\mathcal{D}$, it is mapped to $(\\tilde{r},\\tilde{c})$ by reflection across the nearest boundary. The mapping is:\n    $$ \\tilde{r} = \\begin{cases} r'  \\text{if } 1 \\le r' \\le N_r \\\\ 2-r'  \\text{if } r'  1 \\\\ 2N_r-r'  \\text{if } r'  N_r \\end{cases} \\quad \\text{and} \\quad \\tilde{c} = \\begin{cases} c'  \\text{if } 1 \\le c' \\le N_c \\\\ 2-c'  \\text{if } c'  1 \\\\ 2N_c-c'  \\text{if } c'  N_c \\end{cases} $$\n    For this problem, $N_r=N_c=3$.\n-   **Wrap**: All pixels in $\\mathcal{D}$ are processed. If $(r',c')$ is outside $\\mathcal{D}$, it is mapped to $(\\tilde{r},\\tilde{c})$ using periodic boundary conditions:\n    $$ \\tilde{r} = (r'-1 \\pmod{N_r}) + 1 \\quad \\text{and} \\quad \\tilde{c} = (c'-1 \\pmod{N_c}) + 1 $$\n    where the modulo operator maps its inputs to $\\{0, 1, \\dots, N-1\\}$.\n-   **Partial sampling**: All pixels in $\\mathcal{D}$ are processed. The bit $b_k(r,c)$ is determined as:\n    $$ b_k(r,c) = \\begin{cases} 1  \\text{if } (r',c') \\in \\mathcal{D} \\text{ and } I_{r',c'} \\ge I_{r,c} \\\\ 0  \\text{if } (r',c') \\notin \\mathcal{D} \\text{ or } I_{r',c'}  I_{r,c} \\end{cases} $$\n\n**2. LBP Code Calculation**\n\nThe central pixel is $(2,2)$ with intensity $I_{2,2}=20$. All its 8 neighbors have intensity $10$. Since $10  20$, all bits $b_k(2,2)$ are $0$. Thus, $s(2,2) = \\sum_{k=0}^{7} 0 \\cdot 2^k = 0$. This code is the same for all strategies as the neighborhood is fully contained in the ROI.\n\nThe other $8$ pixels are on the border and all have an intensity of $10$. For these pixels, any neighbor with intensity $I_{neigh} \\ge 10$ will result in a bit $b_k=1$. In this ROI, all pixels have intensity $10$ or $20$, so any valid neighbor lookup will result in a bit of $1$.\n\n-   **Ignore**: Only the center pixel $(2,2)$ has a neighborhood fully within the $3 \\times 3$ ROI. Thus, only $s(2,2)=0$ is calculated.\n-   **Mirror**: For any of the $8$ border pixels, the center intensity is $10$. Any neighbor, whether inside the ROI or mirrored, will have an intensity of $10$ or $20$. Since all neighbor intensities are $\\ge 10$, all $8$ bits will be $1$.\n    Therefore, for all $8$ border pixels, the code is $s = \\sum_{k=0}^{7} 1 \\cdot 2^k = 2^8 - 1 = 255$.\n-   **Wrap**: Similarly, for any of the $8$ border pixels (center intensity $10$), any wrapped neighbor will have intensity $10$ or $20$. So, all $8$ bits are $1$. The code for all $8$ border pixels is $255$.\n-   **Partial sampling**: For the $8$ border pixels (center intensity $10$), a bit $b_k$ is $1$ if its corresponding neighbor is within the ROI, and $0$ if it is outside.\n    -   Pixel $(1,1)$: In-ROI neighbors are at $k=3,4,5$. $s(1,1)=2^3+2^4+2^5 = 8+16+32 = 56$.\n    -   Pixel $(1,3)$: In-ROI neighbors are at $k=5,6,7$. $s(1,3)=2^5+2^6+2^7 = 32+64+128 = 224$.\n    -   Pixel $(3,1)$: In-ROI neighbors are at $k=1,2,3$. $s(3,1)=2^1+2^2+2^3 = 2+4+8 = 14$.\n    -   Pixel $(3,3)$: In-ROI neighbors are at $k=7,0,1$. $s(3,3)=2^7+2^0+2^1 = 128+1+2 = 131$.\n    -   Pixel $(1,2)$: In-ROI neighbors are at $k=3,4,5,6,7$. $s(1,2)=2^3+2^4+2^5+2^6+2^7 = 8+16+32+64+128 = 248$.\n    -   Pixel $(2,1)$: In-ROI neighbors are at $k=1,2,3,4,5$. $s(2,1)=2^1+2^2+2^3+2^4+2^5 = 2+4+8+16+32 = 62$.\n    -   Pixel $(2,3)$: In-ROI neighbors are at $k=5,6,7,0,1$. $s(2,3)=2^5+2^6+2^7+2^0+2^1 = 32+64+128+1+2 = 227$.\n    -   Pixel $(3,2)$: In-ROI neighbors are at $k=7,0,1,2,3$. $s(3,2)=2^7+2^0+2^1+2^2+2^3 = 128+1+2+4+8 = 143$.\n\n**3. Normalized LBP Histograms**\n\nThe histogram is the normalized distribution of the calculated LBP codes.\n-   $H_{\\text{Ignore}}$: One pixel with code $0$.\n    $H_{\\text{Ignore}}(0) = 1$.\n-   $H_{\\text{Mirror}}$: One pixel with code $0$, eight pixels with code $255$.\n    $H_{\\text{Mirror}}(0) = 1/9$, $H_{\\text{Mirror}}(255) = 8/9$.\n-   $H_{\\text{Wrap}}$: One pixel with code $0$, eight pixels with code $255$.\n    $H_{\\text{Wrap}}(0) = 1/9$, $H_{\\text{Wrap}}(255) = 8/9$.\n-   $H_{\\text{Partial}}$: Nine pixels, each with a unique code.\n    $H_{\\text{Partial}}(s) = 1/9$ for $s \\in \\{0, 14, 56, 62, 131, 143, 224, 227, 248\\}$.\n\n**4. Jensen-Shannon Divergence Calculation**\n\nThe JS divergence between two probability distributions $P$ and $Q$ is $D_{JS}(P || Q) = \\frac{1}{2} D_{KL}(P || M) + \\frac{1}{2} D_{KL}(Q || M)$, where $M = \\frac{1}{2}(P+Q)$ and $D_{KL}(P || M) = \\sum_i P(i) \\ln\\frac{P(i)}{M(i)}$.\n\nLet $P = H_{\\text{Ignore}}$ and $Q = H_{\\text{Mirror}}$. The LBP codes are indexed by $i$.\nThe non-zero probabilities are:\n$P(0) = 1$\n$Q(0) = 1/9$, $Q(255) = 8/9$\n\nThe mixture distribution $M = \\frac{1}{2}(P+Q)$ has non-zero probabilities:\n$M(0) = \\frac{1}{2}(P(0) + Q(0)) = \\frac{1}{2}(1 + 1/9) = \\frac{1}{2}(10/9) = 5/9$.\n$M(255) = \\frac{1}{2}(P(255) + Q(255)) = \\frac{1}{2}(0 + 8/9) = \\frac{1}{2}(8/9) = 4/9$.\n\nFirst KL divergence term, $D_{KL}(P || M)$:\nThe sum is over $i$ where $P(i)  0$, which is only $i=0$.\n$$ D_{KL}(P || M) = P(0) \\ln\\left(\\frac{P(0)}{M(0)}\\right) = 1 \\cdot \\ln\\left(\\frac{1}{5/9}\\right) = \\ln(9/5) $$\n\nSecond KL divergence term, $D_{KL}(Q || M)$:\nThe sum is over $i$ where $Q(i)  0$, which are $i=0$ and $i=255$.\n$$ D_{KL}(Q || M) = Q(0) \\ln\\left(\\frac{Q(0)}{M(0)}\\right) + Q(255) \\ln\\left(\\frac{Q(255)}{M(255)}\\right) $$\n$$ D_{KL}(Q || M) = \\frac{1}{9} \\ln\\left(\\frac{1/9}{5/9}\\right) + \\frac{8}{9} \\ln\\left(\\frac{8/9}{4/9}\\right) = \\frac{1}{9} \\ln\\left(\\frac{1}{5}\\right) + \\frac{8}{9} \\ln(2) = -\\frac{1}{9}\\ln(5) + \\frac{8}{9}\\ln(2) $$\n\nNow, combine them to find the JS divergence:\n$$ D_{JS}(P || Q) = \\frac{1}{2} \\left[ D_{KL}(P || M) + D_{KL}(Q || M) \\right] $$\n$$ D_{JS}(P || Q) = \\frac{1}{2} \\left[ \\ln\\left(\\frac{9}{5}\\right) - \\frac{1}{9}\\ln(5) + \\frac{8}{9}\\ln(2) \\right] $$\n$$ D_{JS}(P || Q) = \\frac{1}{2} \\left[ \\ln(9) - \\ln(5) - \\frac{1}{9}\\ln(5) + \\frac{8}{9}\\ln(2) \\right] $$\n$$ D_{JS}(P || Q) = \\frac{1}{2} \\left[ 2\\ln(3) - \\frac{10}{9}\\ln(5) + \\frac{8}{9}\\ln(2) \\right] $$\n$$ D_{JS}(P || Q) = \\ln(3) - \\frac{5}{9}\\ln(5) + \\frac{4}{9}\\ln(2) $$\n\nTo obtain the numerical value, we use the natural logarithm values:\n$\\ln(2) \\approx 0.693147$\n$\\ln(3) \\approx 1.098612$\n$\\ln(5) \\approx 1.609438$\n$$ D_{JS}(P || Q) \\approx 1.098612 - \\frac{5}{9}(1.609438) + \\frac{4}{9}(0.693147) $$\n$$ D_{JS}(P || Q) \\approx 1.098612 - 0.894132 + 0.308065 $$\n$$ D_{JS}(P || Q) \\approx 0.512545 $$\nRounding to four significant figures, the result is $0.5125$ nats.", "answer": "$$\\boxed{0.5125}$$", "id": "4565398"}, {"introduction": "In modern radiomics, efficiency is paramount, as algorithms are often applied to large, three-dimensional medical scans. This final practice moves beyond the algorithm itself to the critical domain of computational performance. Using a simplified but powerful performance model, you will design and analyze a GPU-accelerated implementation for 3D LBP, estimating the potential speedup over a standard CPU approach [@problem_id:4565442]. This exercise will give you insight into the principles of high-performance computing that are essential for large-scale data analysis.", "problem": "You are asked to reason from first principles to design a Graphics Processing Unit (GPU) kernel for three-dimensional Local Binary Pattern (LBP) computation in radiomics and to estimate the throughput gains of the GPU design relative to a baseline Central Processing Unit (CPU) implementation. The scenario is purely computational and needs to be framed in terms of memory access patterns, arithmetic operations, and algorithmic structure. The final program must implement your derived model and produce numerical estimates for a set of defined test cases.\n\nThe fundamental base you must use comprises the following well-tested definitions and facts:\n- Local Binary Patterns (LBP): For a grayscale volume, the LBP code at a voxel compares the intensity of $P$ spatially distributed neighbors to the center voxel intensity, encoding each comparison result into a binary digit. This extends to three dimensions by considering neighbors in a cubic neighborhood.\n- Roofline model: The execution time can be bounded by the maximum of the memory-bound time and the compute-bound time. If $B$ is memory bandwidth in bytes per second, $C$ is computational throughput in operations per second, $b$ is the number of bytes transferred per voxel, and $o$ is the number of operations per voxel, then the time per voxel is $t = \\max\\left(\\frac{b}{B}, \\frac{o}{C}\\right)$.\n- GPU shared memory tiling: In a GPU kernel using shared memory, a thread block loads a tile of the input volume augmented by a halo of width $r$ (the LBP radius) along each dimension. The halo allows neighbor accesses to be served from shared memory for all voxels in the block. The tiled global load count, and hence the bytes transferred per output voxel, can be derived from block geometry and volume size.\n\nDefinitions and modeling assumptions to use:\n- Three-dimensional LBP neighborhood: For radius $r \\in \\mathbb{N}$, consider the cubic neighborhood of linear size $(2r+1)$; the center voxel is excluded. Therefore, the number of neighbors is $P = (2r + 1)^3 - 1$.\n- Interior-only computation: LBP is computed only for voxels whose full neighborhood fits within the Region of Interest (ROI). If the ROI size is $(X,Y,Z)$, the interior extents are $(X - 2r, Y - 2r, Z - 2r)$. If any of these is non-positive, the interior contains zero voxels, and the result is defined to be $0.0$ for speedup.\n- Voxel storage: Intensities are $16$-bit signed integers, so each intensity uses $b_i = 2$ bytes. The LBP output code is stored as a fixed-width $128$-bit wide unsigned integer (to accommodate up to $125$ bits for $r=2$), so each output uses $b_o = 16$ bytes.\n- GPU kernel design: A three-dimensional thread block of size $(B_x, B_y, B_z)$ processes a tile of $(B_x, B_y, B_z)$ interior voxels. The block loads a shared-memory tile of size $(B_x + 2r) \\times (B_y + 2r) \\times (B_z + 2r)$ intensities from global memory. Interior blocks near the interior boundary may be partially filled; include the exact tile sizes for partially filled blocks in your model.\n- Arithmetic model: Each neighbor contributes one compare and one bit update, for $o = 2P$ integer operations per output voxel. Stores to memory are accounted in $b$ but not counted as arithmetic operations.\n- CPU baseline: The CPU scans the interior voxels naively, reading the center and each neighbor directly from main memory for every voxel. Ignore cache reuse in the CPU model.\n- Roofline constants (plausible fixed numbers): CPU memory bandwidth $B_{\\text{cpu}} = 60 \\times 10^9$ bytes per second; CPU compute throughput $C_{\\text{cpu}} = 240 \\times 10^9$ operations per second. GPU memory bandwidth $B_{\\text{gpu}} = 600 \\times 10^9$ bytes per second; GPU compute throughput $C_{\\text{gpu}} = 6000 \\times 10^9$ operations per second.\n\nDerive from these bases:\n- The exact count of interior voxels $N_{\\text{int}} = \\max(X - 2r, 0) \\cdot \\max(Y - 2r, 0) \\cdot \\max(Z - 2r, 0)$.\n- For the CPU, bytes per output voxel $b_{\\text{cpu}} = (P + 1) \\cdot b_i + b_o$, operations per voxel $o_{\\text{cpu}} = 2P$, and time per voxel $t_{\\text{cpu}} = \\max\\left(\\frac{b_{\\text{cpu}}}{B_{\\text{cpu}}}, \\frac{o_{\\text{cpu}}}{C_{\\text{cpu}}}\\right)$. Total time $T_{\\text{cpu}} = N_{\\text{int}} \\cdot t_{\\text{cpu}}$.\n- For the GPU, compute the exact sum over all thread blocks of the shared-memory tile volume, including halos, to obtain total global-load voxels $L_{\\text{gpu}}$; then bytes per output voxel are $b_{\\text{gpu}} = \\frac{L_{\\text{gpu}} \\cdot b_i}{N_{\\text{int}}} + b_o$, operations per voxel $o_{\\text{gpu}} = 2P$, and time per voxel $t_{\\text{gpu}} = \\max\\left(\\frac{b_{\\text{gpu}}}{B_{\\text{gpu}}}, \\frac{o_{\\text{gpu}}}{C_{\\text{gpu}}}\\right)$. Total time $T_{\\text{gpu}} = N_{\\text{int}} \\cdot t_{\\text{gpu}}$.\n- The throughput gain is defined as the speedup $S = \\frac{T_{\\text{cpu}}}{T_{\\text{gpu}}}$, which is a dimensionless float.\n\nTest suite:\n- Case A: $(X,Y,Z,r,B_x,B_y,B_z) = (128,128,64,1,8,8,8)$.\n- Case B: $(X,Y,Z,r,B_x,B_y,B_z) = (64,64,64,2,8,8,8)$.\n- Case C: $(X,Y,Z,r,B_x,B_y,B_z) = (256,256,64,1,16,8,8)$.\n- Case D: $(X,Y,Z,r,B_x,B_y,B_z) = (32,512,16,1,8,8,4)$.\n- Case E: $(X,Y,Z,r,B_x,B_y,B_z) = (4,4,4,2,8,8,8)$.\n- Case F: $(X,Y,Z,r,B_x,B_y,B_z) = (5,5,5,2,4,4,4)$.\n\nYour program must:\n- Implement the described model.\n- Compute $S$ for each case.\n- For any case with $N_{\\text{int}} = 0$, return $0.0$ for $S$.\n\nFinal output format:\n- Produce a single line of output containing the results as a comma-separated Python list of floats in the order of the test suite, for example, \"[s_A,s_B,s_C,s_D,s_E,s_F]\". Since speedup is dimensionless, no physical unit needs to be printed.\n\nAngles are not involved in this task. Do not use a percentage sign; express all outputs as plain decimal floats.", "solution": "The task is to derive a computational performance model for three-dimensional Local Binary Pattern (3D-LBP) feature extraction on both a Central Processing Unit (CPU) and a Graphics Processing Unit (GPU). Using this model, we will estimate the throughput gain, or speedup, of the GPU implementation over a baseline CPU version for a specific set of parameters. The analysis is grounded in the Roofline model, which characterizes performance based on memory bandwidth and computational throughput.\n\nThe foundation of our model rests on the definitions and constants provided. Let the Region of Interest (ROI) be a 3D volume of size $X \\times Y \\times Z$ voxels. The LBP operator has a radius $r \\in \\mathbb{N}$.\n\nFirst, we define parameters common to both CPU and GPU models.\nThe LBP operator for a central voxel considers its neighbors in a cubic region. The number of neighbors, $P$, for a radius $r$ is the number of voxels in a $(2r+1) \\times (2r+1) \\times (2r+1)$ cube, excluding the center voxel:\n$$ P = (2r + 1)^3 - 1 $$\nThe LBP computation is performed only on *interior* voxels, i.e., voxels for which the full neighborhood is contained within the ROI. The dimensions of this interior volume are:\n$$ X_{\\text{int}} = \\max(0, X - 2r) $$\n$$ Y_{\\text{int}} = \\max(0, Y - 2r) $$\n$$ Z_{\\text{int}} = \\max(0, Z - 2r) $$\nThe total number of interior voxels, which is also the number of LBP codes to be computed, is:\n$$ N_{\\text{int}} = X_{\\text{int}} \\cdot Y_{\\text{int}} \\cdot Z_{\\text{int}} $$\nIf $N_{\\text{int}} = 0$, no computation is performed, and the speedup is defined as $S=0.0$.\n\nThe problem states that each voxel intensity is a $16$-bit signed integer, so each input voxel requires $b_i = 2$ bytes. Each output LBP code is a $128$-bit unsigned integer, requiring $b_o = 16$ bytes. The number of arithmetic operations per output LBP code is given as $o = 2P$, corresponding to one comparison and one bit-wise operation for each of the $P$ neighbors.\n\nThe hardware performance is characterized by the following constants:\n- CPU memory bandwidth, $B_{\\text{cpu}} = 60 \\times 10^9$ bytes/s\n- CPU compute throughput, $C_{\\text{cpu}} = 240 \\times 10^9$ operations/s\n- GPU memory bandwidth, $B_{\\text{gpu}} = 600 \\times 10^9$ bytes/s\n- GPU compute throughput, $C_{\\text{gpu}} = 6000 \\times 10^9$ operations/s\n\nAccording to the Roofline model, the time required to process one voxel is the maximum of the time spent on memory access and the time spent on computation:\n$$ t = \\max\\left(\\frac{b}{B}, \\frac{o}{C}\\right) $$\nwhere $b$ is the number of bytes transferred and $o$ is the number of operations performed, per output voxel.\n\n**CPU Performance Model**\n\nThe baseline CPU implementation is described as a naive scan. For each of the $N_{\\text{int}}$ interior voxels, it reads the center voxel and all its $P$ neighbors directly from main memory. Caching effects are ignored. Therefore, the number of input voxels read per output LBP code is $P+1$. Additionally, the computed LBP code must be written to memory.\nThe total bytes transferred per output voxel, $b_{\\text{cpu}}$, is:\n$$ b_{\\text{cpu}} = (P + 1) \\cdot b_i + b_o $$\nThe number of operations per output voxel is $o_{\\text{cpu}} = 2P$.\nThe time per voxel for the CPU is thus:\n$$ t_{\\text{cpu}} = \\max\\left(\\frac{b_{\\text{cpu}}}{B_{\\text{cpu}}}, \\frac{o_{\\text{cpu}}}{C_{\\text{cpu}}}\\right) $$\nThe total execution time for the CPU is $T_{\\text{cpu}} = N_{\\text{int}} \\cdot t_{\\text{cpu}}$.\n\n**GPU Performance Model**\n\nThe GPU implementation utilizes a tiled approach with shared memory to improve data reuse. The interior volume is partitioned into a grid of thread blocks. A thread block of size $(B_x, B_y, B_z)$ is responsible for computing LBP codes for a corresponding $(B_x, B_y, B_z)$ tile of interior voxels.\n\nTo compute LBP for all voxels in its assigned tile, a thread block must first load a larger region from global memory into its on-chip shared memory. This region includes the voxel tile itself plus a \"halo\" of width $r$ on all sides to provide the necessary neighbors. The key to GPU performance gain is that voxels in the halo region are loaded once per block, but are then used for computations for multiple output voxels within the block, thus reducing total global memory traffic.\n\nLet's derive the total number of voxels, $L_{\\text{gpu}}$, loaded from global memory across all thread blocks. The grid of blocks required to cover the interior volume of size $(X_{\\text{int}}, Y_{\\text{int}}, Z_{\\text{int}})$ has dimensions $(N_{Bx}, N_{By}, N_{Bz})$, where:\n$$ N_{Bx} = \\left\\lceil \\frac{X_{\\text{int}}}{B_x} \\right\\rceil, \\quad N_{By} = \\left\\lceil \\frac{Y_{\\text{int}}}{B_y} \\right\\rceil, \\quad N_{Bz} = \\left\\lceil \\frac{Z_{\\text{int}}}{B_z} \\right\\rceil $$\nA block at grid index $(i,j,k)$ processes a tile of interior voxels of size $(w_i, h_j, d_k)$, where $w_i = \\min(B_x, X_{\\text{int}} - i \\cdot B_x)$, and similarly for $h_j$ and $d_k$. This correctly handles partially-filled blocks at the boundaries. To process this tile, the block must load $(w_i + 2r) \\times (h_j + 2r) \\times (d_k + 2r)$ voxels into shared memory.\n\nThe total global load $L_{\\text{gpu}}$ is the sum of loads over all blocks:\n$$ L_{\\text{gpu}} = \\sum_{k=0}^{N_{Bz}-1} \\sum_{j=0}^{N_{By}-1} \\sum_{i=0}^{N_{Bx}-1} (w_i + 2r) (h_j + 2r) (d_k + 2r) $$\nDue to separability, this can be written as:\n$$ L_{\\text{gpu}} = \\left( \\sum_{i=0}^{N_{Bx}-1} (w_i + 2r) \\right) \\left( \\sum_{j=0}^{N_{By}-1} (h_j + 2r) \\right) \\left( \\sum_{k=0}^{N_{Bz}-1} (d_k + 2r) \\right) $$\nLet's analyze the sum along one dimension, e.g., $x$:\n$$ \\sum_{i=0}^{N_{Bx}-1} (w_i + 2r) = \\left( \\sum_{i=0}^{N_{Bx}-1} w_i \\right) + \\left( \\sum_{i=0}^{N_{Bx}-1} 2r \\right) = X_{\\text{int}} + N_{Bx} \\cdot 2r $$\nThe first term is the sum of the widths of all tiles, which is the total interior dimension $X_{\\text{int}}$. The second term is the sum of halo contributions from each block.\nApplying this to all three dimensions, we get the total number of voxels loaded from global memory:\n$$ L_{\\text{gpu}} = (X_{\\text{int}} + N_{Bx} \\cdot 2r) (Y_{\\text{int}} + N_{By} \\cdot 2r) (Z_{\\text{int}} + N_{Bz} \\cdot 2r) $$\nThis value, $L_{\\text{gpu}}$, represents the total number of input voxel reads. To find the average number of bytes per output voxel, we divide the total input bytes by $N_{\\text{int}}$ and add the cost of writing one output voxel.\n$$ b_{\\text{gpu}} = \\frac{L_{\\text{gpu}} \\cdot b_i}{N_{\\text{int}}} + b_o $$\nThe number of operations per voxel remains the same, $o_{\\text{gpu}} = 2P$.\nThe time per voxel for the GPU is:\n$$ t_{\\text{gpu}} = \\max\\left(\\frac{b_{\\text{gpu}}}{B_{\\text{gpu}}}, \\frac{o_{\\text{gpu}}}{C_{\\text{gpu}}}\\right) $$\nThe total execution time for the GPU is $T_{\\text{gpu}} = N_{\\text{int}} \\cdot t_{\\text{gpu}}$.\n\n**Throughput Gain (Speedup)**\n\nThe throughput gain is the ratio of the total CPU time to the total GPU time.\n$$ S = \\frac{T_{\\text{cpu}}}{T_{\\text{gpu}}} = \\frac{N_{\\text{int}} \\cdot t_{\\text{cpu}}}{N_{\\text{int}} \\cdot t_{\\text{gpu}}} $$\nFor cases where $N_{\\text{int}}  0$, this simplifies to the ratio of a single voxel's processing time:\n$$ S = \\frac{t_{\\text{cpu}}}{t_{\\text{gpu}}} $$\nThis simplification is computationally convenient. For cases where $N_{\\text{int}} = 0$, the speedup is explicitly defined as $S=0.0$.\n\nThe following sequence of calculations will be implemented for each test case.\n1.  Calculate $X_{\\text{int}}$, $Y_{\\text{int}}$, $Z_{\\text{int}}$ and $N_{\\text{int}}$. If $N_{\\text{int}} = 0$, $S=0.0$.\n2.  Calculate $P = (2r+1)^3 - 1$.\n3.  Calculate $t_{\\text{cpu}} = \\max\\left(\\frac{(P+1)b_i + b_o}{B_{\\text{cpu}}}, \\frac{2P}{C_{\\text{cpu}}}\\right)$.\n4.  Calculate grid dimensions $N_{Bx}, N_{By}, N_{Bz}$ using ceiling division.\n5.  Calculate total GPU global loads $L_{\\text{gpu}} = (X_{\\text{int}} + N_{Bx} \\cdot 2r)(Y_{\\text{int}} + N_{By} \\cdot 2r)(Z_{\\text{int}} + N_{Bz} \\cdot 2r)$.\n6.  Calculate $b_{\\text{gpu}} = \\frac{L_{\\text{gpu}} \\cdot b_i}{N_{\\text{int}}} + b_o$.\n7.  Calculate $t_{\\text{gpu}} = \\max\\left(\\frac{b_{\\text{gpu}}}{B_{\\text{gpu}}}, \\frac{2P}{C_{\\text{gpu}}}\\right)$.\n8.  Calculate $S = t_{\\text{cpu}} / t_{\\text{gpu}}$.\n\nThis completes the derivation of the model from first principles as laid out in the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements the derived performance model to calculate GPU speedup for 3D LBP.\n    \"\"\"\n\n    # Define system constants from the problem statement.\n    B_cpu = 60e9  # bytes/s\n    C_cpu = 240e9 # ops/s\n    B_gpu = 600e9  # bytes/s\n    C_gpu = 6000e9 # ops/s\n    b_i = 2       # bytes per input voxel (16-bit)\n    b_o = 16      # bytes per output LBP code (128-bit)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (X, Y, Z, r, B_x, B_y, B_z)\n        (128, 128, 64, 1, 8, 8, 8),   # Case A\n        (64, 64, 64, 2, 8, 8, 8),    # Case B\n        (256, 256, 64, 1, 16, 8, 8),  # Case C\n        (32, 512, 16, 1, 8, 8, 4),    # Case D\n        (4, 4, 4, 2, 8, 8, 8),      # Case E\n        (5, 5, 5, 2, 4, 4, 4),      # Case F\n    ]\n\n    results = []\n\n    for case in test_cases:\n        X, Y, Z, r, B_x, B_y, B_z = case\n\n        # Step 1: Calculate interior volume dimensions\n        X_int = max(0, X - 2 * r)\n        Y_int = max(0, Y - 2 * r)\n        Z_int = max(0, Z - 2 * r)\n\n        # Step 2: Calculate total number of interior voxels\n        N_int = X_int * Y_int * Z_int\n\n        # Step 3: Handle the case of zero interior volume\n        if N_int == 0:\n            results.append(0.0)\n            continue\n\n        # Step 4: Calculate LBP parameters\n        P = (2 * r + 1)**3 - 1\n        \n        # Step 5: CPU Performance Model\n        o_cpu = 2 * P\n        b_cpu = (P + 1) * b_i + b_o\n        t_cpu = max(b_cpu / B_cpu, o_cpu / C_cpu)\n\n        # Step 6: GPU Performance Model\n        # Operations per voxel is the same\n        o_gpu = o_cpu\n\n        # Calculate grid dimensions needed to cover the interior volume\n        N_Bx = int(np.ceil(X_int / B_x)) if X_int  0 else 0\n        N_By = int(np.ceil(Y_int / B_y)) if Y_int  0 else 0\n        N_Bz = int(np.ceil(Z_int / B_z)) if Z_int  0 else 0\n\n        # Calculate total voxels loaded from global memory by all GPU blocks\n        # This sums the volume of each shared memory tile, including halos\n        L_x_dim = X_int + N_Bx * 2 * r\n        L_y_dim = Y_int + N_By * 2 * r\n        L_z_dim = Z_int + N_Bz * 2 * r\n        L_gpu = L_x_dim * L_y_dim * L_z_dim\n\n        # Calculate average bytes transferred per output voxel for the GPU\n        b_gpu = (L_gpu * b_i) / N_int + b_o\n\n        # Calculate time per voxel for the GPU\n        t_gpu = max(b_gpu / B_gpu, o_gpu / C_gpu)\n\n        # Step 7: Calculate throughput gain (speedup)\n        speedup = t_cpu / t_gpu\n        results.append(speedup)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{res:.6f}' for res in results)}]\")\n\nsolve()\n```", "id": "4565442"}]}