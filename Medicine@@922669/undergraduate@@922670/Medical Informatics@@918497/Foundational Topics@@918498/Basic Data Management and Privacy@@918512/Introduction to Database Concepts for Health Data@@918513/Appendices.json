{"hands_on_practices": [{"introduction": "This first practice bridges the gap between the theoretical concepts of relational algebra and their practical application in SQL. By translating a query to find patients with specific lab results, you will explore the fundamental difference between the set-based logic of relational algebra and the default multiset (or \"bag\") behavior of SQL, learning why explicit duplicate removal is often necessary for accurate counting. [@problem_id:4845746]", "problem": "A hospital maintains a laboratory observations relation $\\text{Observation}(\\text{obs\\_id}, \\text{pid}, \\text{loinc\\_code}, \\text{value}, \\text{effective\\_time})$ where $\\text{obs\\_id}$ is the primary key and $\\text{pid}$ is a patient identifier (PID) referencing the patient master. Logical Observation Identifiers Names and Codes (LOINC) use standardized codes for laboratory tests; the LOINC code $\\text{'718-7'}$ represents a hemoglobin test on blood. The data management system is Structured Query Language (SQL) based, which by default uses bag semantics unless duplicate elimination is explicitly requested.\n\nUsing only the core definitions of relational algebra selection and projection, and the notion of set versus bag semantics:\n- Derive the relational algebra expression that returns the set of unique patient identifiers that have at least one hemoglobin observation recorded in $\\text{Observation}$.\n- State an equivalent SQL query that returns the same set of identifiers, and justify their equivalence by reference to the semantics of selection, projection, and duplicate elimination.\n\nFor a specific extract of the $\\text{Observation}$ relation, consider that the rows with $\\text{loinc\\_code} = \\text{'718-7'}$ are distributed across patients as follows:\n- 450 patients have exactly 1 such row.\n- 380 patients have exactly 2 such rows.\n- 250 patients have exactly 3 such rows.\n- 20 patients have exactly 4 such rows.\n- 100 patients have exactly 5 such rows.\n\nAssume there are no other patients with $\\text{loinc\\_code} = \\text{'718-7'}$ beyond those described above, and that any system-level duplication is already reflected in the counts above. Under these conditions, compute the number of distinct patient identifiers returned by your SQL query. Express your final numerical answer as an integer.", "solution": "We begin from the core definitions in the relational model:\n\n- Selection: For a relation $R$ and a predicate $\\theta$, the selection operator $\\sigma_{\\theta}(R)$ returns the subset of tuples of $R$ that satisfy $\\theta$. It preserves all attributes of $R$ while filtering rows.\n- Projection: For a relation $R$ and a list of attributes $A$, the projection operator $\\pi_{A}(R)$ returns the set of tuples restricted to attributes $A$, eliminating duplicate tuples because relational algebra uses set semantics.\n\nIn SQL (Structured Query Language), a query without $\\text{DISTINCT}$ returns a bag (multiset) of rows, possibly with duplicates. Adding $\\text{DISTINCT}$ enforces duplicate elimination, aligning the result with set semantics as in relational algebra projection.\n\nTask 1: Derive the relational algebra expression. We want the set of unique patient identifiers with at least one hemoglobin observation. Let the hemoglobin code be $\\text{'718-7'}$. We first select the hemoglobin rows using selection, then project the patient identifier attribute:\n$$\n\\pi_{\\text{pid}}\\big(\\sigma_{\\text{loinc\\_code}=\\text{'718-7'}}(\\text{Observation})\\big).\n$$\nBy definition, $\\sigma_{\\text{loinc\\_code}=\\text{'718-7'}}(\\text{Observation})$ filters the relation to rows whose LOINC code equals $\\text{'718-7'}$, and $\\pi_{\\text{pid}}(\\cdot)$ then extracts the patient identifiers and removes duplicates, yielding a set of unique PIDs.\n\nTask 2: State an equivalent SQL query and justify equivalence. The corresponding SQL query that mirrors selection (via $\\text{WHERE}$) and projection with duplicate elimination (via $\\text{DISTINCT}$) is:\n$\\text{SELECT DISTINCT pid FROM Observation WHERE loinc\\_code = '718-7';}$\nThis query aligns with the relational algebra expression because:\n- The $\\text{WHERE}$ clause $\\text{loinc\\_code = '718-7'}$ is the SQL realization of the selection $\\sigma_{\\text{loinc\\_code}=\\text{'718-7'}}$.\n- The $\\text{SELECT DISTINCT pid}$ is the SQL realization of the projection $\\pi_{\\text{pid}}$ with duplicate elimination. Without $\\text{DISTINCT}$, SQL would return a bag, potentially repeating $\\text{pid}$ values for patients with multiple hemoglobin observations; with $\\text{DISTINCT}$, duplicates are removed to return a set, matching relational algebra semantics.\n\nTask 3: Compute the number of distinct patient identifiers returned. Let $x_{k}$ denote the number of patients with exactly $k$ rows in $\\text{Observation}$ satisfying $\\text{loinc\\_code}=\\text{'718-7'}$. The number of distinct patients returned by the query is the count of patients with at least one such row, which is the sum of the $x_{k}$:\n$$\n\\text{distinct\\_patients} \\;=\\; \\sum_{k \\ge 1} x_{k}.\n$$\nFrom the problem data:\n- $x_{1} = 450$,\n- $x_{2} = 380$,\n- $x_{3} = 250$,\n- $x_{4} = 20$,\n- $x_{5} = 100$.\n\nTherefore,\n$$\n\\text{distinct\\_patients} \\;=\\; 450 + 380 + 250 + 20 + 100 \\;=\\; 1{,}200.\n$$\nNo rounding is needed because this is an exact integer count under the given assumptions. This value is consistent with the bag semantics of the underlying table (multiple rows per patient) and the set semantics enforced by projection in relational algebra or by $\\text{DISTINCT}$ in SQL: regardless of how many hemoglobin rows each patient has, each qualifying patient contributes exactly one identifier to the result set.", "answer": "$$\\boxed{1200}$$", "id": "4845746"}, {"introduction": "Building on basic queries, this exercise simulates a core task in medical informatics: constructing a patient cohort for a clinical study. You will apply set operations such as intersection ($\\cap$), union ($\\cup$), and set difference ($\\setminus$) to a hypothetical dataset to precisely define a group of patients based on complex inclusion and exclusion criteria involving diagnoses, lab results, and time windows. This practice is essential for developing the skills needed for clinical research and population health analysis. [@problem_id:4845783]", "problem": "A health system maintains two core relational tables that follow set semantics in relational algebra: Diagnosis and Observation. Under set semantics, the operators union, intersection, and set difference remove duplicates and operate on sets of unique tuples. In cohort construction, membership is at the patient level: a patient is included in a set if there exists at least one qualifying row for that patient that satisfies the given predicate. Let International Classification of Diseases, Tenth Revision (ICD-10) codes represent diagnosis concepts, and let Hemoglobin A1c (HbA1c) be a laboratory observation recorded in the Observation table. Assume both tables may contain multiple rows per patient across time, and that patient identifiers are unique and stable. All set operations below are defined over sets of unique patient identifiers.\n\nYou are given the following data extracted from the Diagnosis and Observation tables. Each record lists patient identifier, the concept (ICD-10 code or HbA1c), and a study-day index counted in whole days from a common index. Days are integers.\n\nDiagnosis records:\n- P01: E11.9 at day $30$; E10.9 at day $15$; I10 at day $40$.\n- P02: E11.65 at day $25$; J45.909 at day $60$.\n- P03: E11.9 at day $5$; E11.9 at day $110$; E78.5 at day $45$.\n- P04: E11.9 at day $80$.\n- P05: E10.9 at day $50$.\n- P06: E11.65 at day $95$.\n- P07: I10 at day $70$.\n- P08: E11.9 at day $35$; E11.9 at day $90$.\n- P09: E11.9 at day $150$; E10.9 at day $180$.\n- P10: E11.9 at day $20$.\n- P11: E78.5 at day $55$.\n- P12: E11.9 at day $15$.\n\nObservation records (Hemoglobin A1c values, expressed as decimals):\n- P01: HbA1c $8.2$ at day $50$; HbA1c $7.6$ at day $90$.\n- P02: HbA1c $8.5$ at day $30$.\n- P03: HbA1c $7.4$ at day $50$; HbA1c $7.6$ at day $115$.\n- P04: HbA1c $8.1$ at day $85$; HbA1c $8.0$ at day $130$.\n- P05: HbA1c $9.0$ at day $55$.\n- P06: HbA1c $7.5$ at day $100$; HbA1c $7.8$ at day $140$.\n- P07: HbA1c $8.3$ at day $10$; HbA1c $8.6$ at day $25$.\n- P08: HbA1c $7.2$ at day $40$; HbA1c $7.6$ at day $92$.\n- P09: HbA1c $8.4$ at day $160$; HbA1c $7.7$ at day $100$.\n- P10: HbA1c $7.0$ at day $50$; HbA1c $8.1$ at day $75$.\n- P11: HbA1c $8.2$ at day $60$.\n- P12: HbA1c $7.6$ at day $16$; HbA1c $7.6$ at day $22$.\n\nDefine the following patient-level sets using diagnosis and observation predicates and study-day windows:\n- Set $\\mathcal{A}$: patients with at least one Type $2$ diabetes diagnosis, defined as ICD-10 in $\\{\\text{E11.9}, \\text{E11.65}\\}$, occurring on a day in the inclusive window $[10, 100]$.\n- Set $\\mathcal{B}$: patients with at least one HbA1c value $\\geq 8.0$ recorded on a day in the inclusive window $[20, 120]$.\n- Set $\\mathcal{C}$ (exclusion): patients with any Type $1$ diabetes diagnosis, defined as ICD-10 of the form $\\text{E10.*}$ (e.g., E10.9), occurring on a day in the inclusive window $[0, 200]$.\n- Set $\\mathcal{D}$: patients with at least two HbA1c values $\\geq 7.5$ on two different days in the inclusive window $[20, 150]$.\n\nThe final cohort is defined by the set expression\n$$\n\\mathcal{S} \\;=\\; \\big(\\,(\\mathcal{A} \\cap \\mathcal{B}) \\,\\cup\\, \\mathcal{D}\\,\\big)\\; \\setminus\\; \\mathcal{C},\n$$\nwhere membership in each set is at the patient level (a patient appears at most once in any set), and all operators use set semantics.\n\nCompute the number of unique patients in $\\mathcal{S}$. Express your answer as an integer.", "solution": "The solution is derived by constructing each of the four sets ($\\mathcal{A}, \\mathcal{B}, \\mathcal{C}, \\mathcal{D}$) based on the provided data and definitions, and then applying the specified set operations to find the final cohort $\\mathcal{S}$.\n\n**1. Constructing Set $\\mathcal{A}$**\nSet $\\mathcal{A}$ includes patients with at least one diagnosis code from $\\{\\text{E11.9}, \\text{E11.65}\\}$ on a day within the inclusive interval $[10, 100]$.\n- $P_{01}$: E11.9 at day $30$. Yes ($30 \\in [10, 100]$).\n- $P_{02}$: E11.65 at day $25$. Yes ($25 \\in [10, 100]$).\n- $P_{03}$: E11.9 at day $5$ (too early), day $110$ (too late). No.\n- $P_{04}$: E11.9 at day $80$. Yes ($80 \\in [10, 100]$).\n- $P_{05}$: E10.9 is not a valid code for this set. No.\n- $P_{06}$: E11.65 at day $95$. Yes ($95 \\in [10, 100]$).\n- $P_{07}$: I10 is not a valid code. No.\n- $P_{08}$: E11.9 at day $35$ and day $90$. Yes ($35, 90 \\in [10, 100]$).\n- $P_{09}$: E11.9 at day $150$ (too late). No.\n- $P_{10}$: E11.9 at day $20$. Yes ($20 \\in [10, 100]$).\n- $P_{11}$: E78.5 is not a valid code. No.\n- $P_{12}$: E11.9 at day $15$. Yes ($15 \\in [10, 100]$).\nThus, the set of patients is $\\mathcal{A} = \\{P_{01}, P_{02}, P_{04}, P_{06}, P_{08}, P_{10}, P_{12}\\}$.\n\n**2. Constructing Set $\\mathcal{B}$**\nSet $\\mathcal{B}$ includes patients with at least one HbA1c value $\\geq 8.0$ recorded on a day in $[20, 120]$.\n- $P_{01}$: $8.2$ at day $50$. Yes ($8.2 \\geq 8.0$ and $50 \\in [20, 120]$).\n- $P_{02}$: $8.5$ at day $30$. Yes ($8.5 \\geq 8.0$ and $30 \\in [20, 120]$).\n- $P_{03}$: Values $7.4, 7.6$ are both $< 8.0$. No.\n- $P_{04}$: $8.1$ at day $85$. Yes ($8.1 \\geq 8.0$ and $85 \\in [20, 120]$).\n- $P_{05}$: $9.0$ at day $55$. Yes ($9.0 \\geq 8.0$ and $55 \\in [20, 120]$).\n- $P_{06}$: Values $7.5, 7.8$ are both $< 8.0$. No.\n- $P_{07}$: $8.3$ at day $10$ (too early); $8.6$ at day $25$. Yes ($8.6 \\geq 8.0$ and $25 \\in [20, 120]$).\n- $P_{08}$: Values $7.2, 7.6$ are both $< 8.0$. No.\n- $P_{09}$: $8.4$ at day $160$ (too late); $7.7$ at day $100$ (value too low). No.\n- $P_{10}$: $8.1$ at day $75$. Yes ($8.1 \\geq 8.0$ and $75 \\in [20, 120]$).\n- $P_{11}$: $8.2$ at day $60$. Yes ($8.2 \\geq 8.0$ and $60 \\in [20, 120]$).\n- $P_{12}$: Values are $7.6 < 8.0$. No.\nThus, the set of patients is $\\mathcal{B} = \\{P_{01}, P_{02}, P_{04}, P_{05}, P_{07}, P_{10}, P_{11}\\}$.\n\n**3. Constructing Set $\\mathcal{C}$**\nSet $\\mathcal{C}$ is an exclusion set of patients with any diagnosis code starting with 'E10' on a day in $[0, 200]$.\n- $P_{01}$: E10.9 at day $15$. Yes ($15 \\in [0, 200]$).\n- $P_{05}$: E10.9 at day $50$. Yes ($50 \\in [0, 200]$).\n- $P_{09}$: E10.9 at day $180$. Yes ($180 \\in [0, 200]$).\nAll other patients do not have a diagnosis code matching E10.*.\nThus, the set of patients is $\\mathcal{C} = \\{P_{01}, P_{05}, P_{09}\\}$.\n\n**4. Constructing Set $\\mathcal{D}$**\nSet $\\mathcal{D}$ includes patients with at least two HbA1c values $\\geq 7.5$ on two different days in $[20, 150]$.\n- $P_{01}$: $8.2$ at day $50$ and $7.6$ at day $90$. Yes (two values $\\geq 7.5$ on different days in $[20, 150]$).\n- $P_{02}$: Only one record. No.\n- $P_{03}$: $7.6$ at day $115$. Only one qualifying record ($7.4 < 7.5$). No.\n- $P_{04}$: $8.1$ at day $85$ and $8.0$ at day $130$. Yes (two values $\\geq 7.5$ on different days in $[20, 150]$).\n- $P_{05}$: Only one record. No.\n- $P_{06}$: $7.5$ at day $100$ and $7.8$ at day $140$. Yes (two values $\\geq 7.5$ on different days in $[20, 150]$).\n- $P_{07}$: $8.6$ at day $25$. Only one qualifying record (day $10$ is out of range). No.\n- $P_{08}$: $7.6$ at day $92$. Only one qualifying record ($7.2 < 7.5$). No.\n- $P_{09}$: $7.7$ at day $100$. Only one qualifying record (day $160$ is out of range). No.\n- $P_{10}$: $8.1$ at day $75$. Only one qualifying record ($7.0 < 7.5$). No.\n- $P_{11}$: Only one record. No.\n- $P_{12}$: $7.6$ at day $22$. Only one qualifying record (day $16$ is out of range). No.\nThus, the set of patients is $\\mathcal{D} = \\{P_{01}, P_{04}, P_{06}\\}$.\n\n**5. Computing the Final Set $\\mathcal{S}$**\nThe final cohort $\\mathcal{S}$ is calculated using the expression $\\mathcal{S} = ((\\mathcal{A} \\cap \\mathcal{B}) \\cup \\mathcal{D}) \\setminus \\mathcal{C}$.\nFirst, calculate the intersection $\\mathcal{A} \\cap \\mathcal{B}$:\n$\\mathcal{A} = \\{P_{01}, P_{02}, P_{04}, P_{06}, P_{08}, P_{10}, P_{12}\\}$\n$\\mathcal{B} = \\{P_{01}, P_{02}, P_{04}, P_{05}, P_{07}, P_{10}, P_{11}\\}$\n$\\mathcal{A} \\cap \\mathcal{B} = \\{P_{01}, P_{02}, P_{04}, P_{10}\\}$\n\nNext, calculate the union of the result with $\\mathcal{D}$:\n$(\\mathcal{A} \\cap \\mathcal{B}) \\cup \\mathcal{D} = \\{P_{01}, P_{02}, P_{04}, P_{10}\\} \\cup \\{P_{01}, P_{04}, P_{06}\\}$\n$(\\mathcal{A} \\cap \\mathcal{B}) \\cup \\mathcal{D} = \\{P_{01}, P_{02}, P_{04}, P_{06}, P_{10}\\}$\n\nFinally, calculate the set difference with the exclusion set $\\mathcal{C}$:\n$\\mathcal{S} = ((\\mathcal{A} \\cap \\mathcal{B}) \\cup \\mathcal{D}) \\setminus \\mathcal{C} = \\{P_{01}, P_{02}, P_{04}, P_{06}, P_{10}\\} \\setminus \\{P_{01}, P_{05}, P_{09}\\}$\nPatient $P_{01}$ is present in the set to be subtracted, so it is removed. Patients $P_{05}$ and $P_{09}$ are not in the intermediate set, so their presence in $\\mathcal{C}$ has no effect on the result.\n$\\mathcal{S} = \\{P_{02}, P_{04}, P_{06}, P_{10}\\}$\n\nThe number of unique patients in the final set $\\mathcal{S}$ is the cardinality of the set, $|\\mathcal{S}|$.\n$|\\mathcal{S}| = |\\{P_{02}, P_{04}, P_{06}, P_{10}\\}| = 4$.\nThe final answer is $4$.", "answer": "$$\n\\boxed{4}\n$$", "id": "4845783"}, {"introduction": "Real-world health data is often incomplete, and handling missing values, represented as `NULL` in SQL, is critical for accurate analysis. This practice demonstrates the significant analytical errors that can arise from naively replacing `NULL` values, contrasting it with a logically sound approach that respects SQL's three-valued logic. Mastering this concept is key to writing robust queries that prevent the silent misclassification of patient data. [@problem_id:4845761]", "problem": "A hospital maintains a table of outpatient blood pressure encounters with columns patient_id, encounter_id, systolic_mmHg, and diastolic_mmHg. Values of systolic_mmHg and diastolic_mmHg can be missing, represented as NULL in Structured Query Language (SQL). You are given the following set of rows, each describing a single encounter. For each row, the attributes are shown as an ordered tuple (patient_id, encounter_id, systolic_mmHg, diastolic_mmHg). The numeric values are measured in millimeters of mercury and are either a nonnegative integer or NULL.\n\n- (A01, E001, $142$, $88$)\n- (A01, E002, NULL, $91$)\n- (B07, E003, $138$, NULL)\n- (B07, E004, NULL, NULL)\n- (C12, E005, $129$, $79$)\n- (C12, E006, $170$, NULL)\n- (D22, E007, NULL, $85$)\n- (D22, E008, NULL, $95$)\n- (E31, E009, $200$, $110$)\n- (E31, E010, $139$, $90$)\n- (F45, E011, $100$, NULL)\n- (F45, E012, $140$, $89$)\n\nA clinical rule to identify normotensive encounters in this context is: systolic blood pressure strictly less than $140$ and diastolic blood pressure strictly less than $90$. In SQL, NULL participates in three-valued logic, and a row is selected by a WHERE clause only when the predicate evaluates to true. The function $\\mathrm{COALESCE}$ returns the first non-NULL argument.\n\nAn analyst proposes a naive normotension query that replaces missing numeric values with $0$ using $\\mathrm{COALESCE}$ before applying the clinical thresholds. A second analyst argues that the correct query must implement the clinical rule in a way that respects three-valued logic, does not make up physiologic values for missing data, and avoids misclassification by applying proper filters.\n\nStarting from the core definitions above and reasoning about SQL three-valued logic and the behavior of $\\mathrm{COALESCE}$, derive the logically correct predicate that an SQL WHERE clause should use to identify normotensive encounters in the presence of NULLs, and then determine how many encounters in the dataset would be incorrectly labeled as normotensive by the naive “replace missing with $0$” approach but would not be labeled as normotensive by the correct approach.\n\nReport your final answer as a single integer count. No rounding is required. Do not include any units in your reported answer.", "solution": "The problem requires a rigorous analysis of two distinct Structured Query Language (SQL) predicate formulations for identifying normotensive patient encounters from a dataset containing missing values, represented as `NULL`. The objective is to quantify the number of encounters misclassified by a naive approach compared to a logically correct one.\n\nFirst, we must formally define the clinical rule and the behavior of the two proposed predicates within the framework of SQL's three-valued logic.\n\nThe clinical rule for a normotensive encounter is defined as: systolic blood pressure strictly less than $140$ mmHg and diastolic blood pressure strictly less than $90$ mmHg. Let $S$ represent `systolic_mmHg` and $D$ represent `diastolic_mmHg`. The condition is the logical conjunction:\n$$ (S < 140) \\land (D < 90) $$\n\nIn SQL, any comparison involving a `NULL` value (e.g., `NULL < 140` or `138 < NULL`) evaluates not to `TRUE` or `FALSE`, but to a third logical value, `UNKNOWN`. The logical `AND` operator behaves as follows with `UNKNOWN`:\n- `TRUE AND UNKNOWN` evaluates to `UNKNOWN`.\n- `FALSE AND UNKNOWN` evaluates to `FALSE`.\n- `UNKNOWN AND UNKNOWN` evaluates to `UNKNOWN`.\n\nAn SQL `WHERE` clause filters a result set by including only those rows for which the specified predicate evaluates to `TRUE`. Rows where the predicate evaluates to `FALSE` or `UNKNOWN` are excluded.\n\nNow we analyze the two approaches:\n\n**1. The Correct Predicate**\nA logically sound implementation of the clinical rule must respect the principle that a definitive classification cannot be made with incomplete information. The direct translation of the rule into an SQL predicate achieves this:\n$$ \\text{Predicate}_{\\text{Correct}}: \\quad \\text{systolic\\_mmHg} < 140 \\text{ AND } \\text{diastolic\\_mmHg} < 90 $$\nFor this predicate to evaluate to `TRUE`, both `systolic_mmHg` and `diastolic_mmHg` must be non-`NULL` and must satisfy their respective inequalities. If either value is `NULL`, its corresponding comparison results in `UNKNOWN`. Unless the other comparison is definitively `FALSE` (which would make the entire conjunction `FALSE`), the predicate will evaluate to `UNKNOWN`, and the row will be correctly excluded from the set of normotensive encounters. This approach does not invent data and adheres to the semantics of missing information.\n\n**2. The Naive Predicate**\nThe naive approach first replaces `NULL` values with $0$ using the `COALESCE` function and then applies the comparisons:\n$$ \\text{Predicate}_{\\text{Naive}}: \\quad \\mathrm{COALESCE}(\\text{systolic\\_mmHg}, 0) < 140 \\text{ AND } \\mathrm{COALESCE}(\\text{diastolic\\_mmHg}, 0) < 90 $$\nThis predicate is scientifically unsound because it imputes a non-physiological value ($0$ mmHg) for missing data. Since `COALESCE` always returns a non-`NULL` value (in this case, either the original measurement or $0$), this predicate will always evaluate to either `TRUE` or `FALSE`, never `UNKNOWN`. This forced dichotomization leads to misclassification when data is missing.\n\n**Objective**\nThe task is to find the number of encounters for which `Predicate_Naive` evaluates to `TRUE` but `Predicate_Correct` does not evaluate to `TRUE` (i.e., it evaluates to `FALSE` or `UNKNOWN`).\n\nWe will now systematically evaluate each of the $12$ encounters against both predicates.\n\nLet $P_C$ be the evaluation of the Correct Predicate and $P_N$ be the evaluation of the Naive Predicate.\n\n- **Encounter E001:** ($142$, $88$)\n  - $P_C$: $(142 < 140) \\land (88 < 90) \\rightarrow \\text{FALSE} \\land \\text{TRUE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(142, 0) < 140) \\land (\\mathrm{COALESCE}(88, 0) < 90) \\rightarrow \\text{FALSE} \\land \\text{TRUE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E002:** (NULL, $91$)\n  - $P_C$: $(\\text{NULL} < 140) \\land (91 < 90) \\rightarrow \\text{UNKNOWN} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(\\text{NULL}, 0) < 140) \\land (\\mathrm{COALESCE}(91, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E003:** ($138$, NULL)\n  - $P_C$: $(138 < 140) \\land (\\text{NULL} < 90) \\rightarrow \\text{TRUE} \\land \\text{UNKNOWN} \\rightarrow \\text{UNKNOWN}$\n  - $P_N$: $(\\mathrm{COALESCE}(138, 0) < 140) \\land (\\mathrm{COALESCE}(\\text{NULL}, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - **Misclassification:** The naive approach incorrectly labels this encounter as normotensive.\n\n- **Encounter E004:** (NULL, NULL)\n  - $P_C$: $(\\text{NULL} < 140) \\land (\\text{NULL} < 90) \\rightarrow \\text{UNKNOWN} \\land \\text{UNKNOWN} \\rightarrow \\text{UNKNOWN}$\n  - $P_N$: $(\\mathrm{COALESCE}(\\text{NULL}, 0) < 140) \\land (\\mathrm{COALESCE}(\\text{NULL}, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - **Misclassification:** The naive approach incorrectly labels this encounter as normotensive.\n\n- **Encounter E005:** ($129$, $79$)\n  - $P_C$: $(129 < 140) \\land (79 < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - $P_N$: $(\\mathrm{COALESCE}(129, 0) < 140) \\land (\\mathrm{COALESCE}(79, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - No misclassification.\n\n- **Encounter E006:** ($170$, NULL)\n  - $P_C$: $(170 < 140) \\land (\\text{NULL} < 90) \\rightarrow \\text{FALSE} \\land \\text{UNKNOWN} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(170, 0) < 140) \\land (\\mathrm{COALESCE}(\\text{NULL}, 0) < 90) \\rightarrow \\text{FALSE} \\land \\text{TRUE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E007:** (NULL, $85$)\n  - $P_C$: $(\\text{NULL} < 140) \\land (85 < 90) \\rightarrow \\text{UNKNOWN} \\land \\text{TRUE} \\rightarrow \\text{UNKNOWN}$\n  - $P_N$: $(\\mathrm{COALESCE}(\\text{NULL}, 0) < 140) \\land (\\mathrm{COALESCE}(85, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - **Misclassification:** The naive approach incorrectly labels this encounter as normotensive.\n\n- **Encounter E008:** (NULL, $95$)\n  - $P_C$: $(\\text{NULL} < 140) \\land (95 < 90) \\rightarrow \\text{UNKNOWN} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(\\text{NULL}, 0) < 140) \\land (\\mathrm{COALESCE}(95, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E009:** ($200$, $110$)\n  - $P_C$: $(200 < 140) \\land (110 < 90) \\rightarrow \\text{FALSE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(200, 0) < 140) \\land (\\mathrm{COALESCE}(110, 0) < 90) \\rightarrow \\text{FALSE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E010:** ($139$, $90$)\n  - $P_C$: $(139 < 140) \\land (90 < 90) \\rightarrow \\text{TRUE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(139, 0) < 140) \\land (\\mathrm{COALESCE}(90, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{FALSE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\n- **Encounter E011:** ($100$, NULL)\n  - $P_C$: $(100 < 140) \\land (\\text{NULL} < 90) \\rightarrow \\text{TRUE} \\land \\text{UNKNOWN} \\rightarrow \\text{UNKNOWN}$\n  - $P_N$: $(\\mathrm{COALESCE}(100, 0) < 140) \\land (\\mathrm{COALESCE}(\\text{NULL}, 0) < 90) \\rightarrow \\text{TRUE} \\land \\text{TRUE} \\rightarrow \\text{TRUE}$\n  - **Misclassification:** The naive approach incorrectly labels this encounter as normotensive.\n\n- **Encounter E012:** ($140$, $89$)\n  - $P_C$: $(140 < 140) \\land (89 < 90) \\rightarrow \\text{FALSE} \\land \\text{TRUE} \\rightarrow \\text{FALSE}$\n  - $P_N$: $(\\mathrm{COALESCE}(140, 0) < 140) \\land (\\mathrm{COALESCE}(89, 0) < 90) \\rightarrow \\text{FALSE} \\land \\text{TRUE} \\rightarrow \\text{FALSE}$\n  - No misclassification.\n\nThe misclassifications occur for encounters E003, E004, E007, and E011. In all these cases, the correct predicate evaluates to `UNKNOWN` (and thus the row is not selected), while the naive predicate evaluates to `TRUE` (and the row is incorrectly selected). The total count of such incorrectly labeled encounters is $4$.", "answer": "$$\\boxed{4}$$", "id": "4845761"}]}