{"hands_on_practices": [{"introduction": "True interoperability goes beyond simply moving data; it involves ensuring that data is computationally understandable. This first practice tackles a core challenge in health data analytics: harmonizing laboratory results that arrive from different systems with heterogeneous units. By converting values to a standard unit and normalizing them against reference intervals, you will practice a fundamental skill required for building reliable clinical decision support and population health dashboards [@problem_id:4859949].", "problem": "A hospital Health Information Exchange (HIE) integrates laboratory data from multiple sources coded using Logical Observation Identifiers Names and Codes (LOINC) and reported with heterogeneous units following the Unified Code for Units of Measure (UCUM). To enable interoperable analytics, the pipeline must harmonize units and normalize values relative to standardized reference intervals. Consider three analytes for a fasting adult male, each arriving with the following measured values and target standard units for analytics: plasma glucose reported as $95$ mg/dL (target unit: mmol/L), serum creatinine reported as $1.3$ mg/dL (target unit: $\\mu$mol/L), and alanine aminotransferase (ALT) reported as $58$ U/L (target unit: U/L). The corresponding standardized reference intervals to be used for the normalization step are: glucose $[3.9, 5.5]$ mmol/L, creatinine $[60, 110]$ $\\mu$mol/L, and ALT $[10, 40]$ U/L. For mass-to-amount conversions, use the molar mass of glucose $M_{\\text{glucose}} = 180.15588$ g/mol and the molar mass of creatinine $M_{\\text{creatinine}} = 113.12$ g/mol.\n\nAssume that for each analyte the population distribution is approximately normal and that the provided reference interval represents the central $95\\%$ of the distribution. Normalize each analyte by converting its measured value into the target standard unit and then computing its standardized score relative to the reference interval. Define an analyte as an outlier if the absolute value of its normalized score exceeds $2$.\n\nCompute the fraction of analytes flagged as outliers after unit harmonization and normalization. Express the final fraction as a decimal and round your answer to four significant figures. The fraction is unitless.", "solution": "The user wants me to solve the problem by assuming the role of a meticulous and exacting STEM professor. I must first validate the problem statement.\n\n### Step 1: Extract Givens\n- **Analyte 1 (Plasma Glucose):**\n  - Measured value: $95$ mg/dL\n  - Target unit: mmol/L\n  - Molar mass ($M_{\\text{glucose}}$): $180.15588$ g/mol\n  - Reference interval: $[3.9, 5.5]$ mmol/L\n- **Analyte 2 (Serum Creatinine):**\n  - Measured value: $1.3$ mg/dL\n  - Target unit: $\\mu$mol/L\n  - Molar mass ($M_{\\text{creatinine}}$): $113.12$ g/mol\n  - Reference interval: $[60, 110]$ $\\mu$mol/L\n- **Analyte 3 (Alanine Aminotransferase, ALT):**\n  - Measured value: $58$ U/L\n  - Target unit: U/L\n  - Reference interval: $[10, 40]$ U/L\n- **Normalization Assumption:** The reference interval represents the central $95\\%$ of an approximately normal distribution.\n- **Outlier Definition:** An analyte is an outlier if the absolute value of its normalized score exceeds $2$.\n- **Objective:** Compute the fraction of analytes flagged as outliers, expressed as a decimal rounded to four significant figures.\n\n### Step 2: Validate Using Extracted Givens\n- **Scientifically Grounded:** The problem is based on standard clinical laboratory practices. It uses correct terminologies (LOINC, UCUM, HIE), real-world analytes (glucose, creatinine, ALT), standard units, and correct molar masses. The process of unit harmonization and normalization against reference intervals is a fundamental task in medical informatics and clinical data analysis. The statistical assumption connecting the $95\\%$ reference interval to a normal distribution is a common and valid simplification.\n- **Well-Posed:** All necessary data (measured values, target units, molar masses, reference intervals) and definitions (outlier criterion) are provided. The goal is clearly stated, and the path to a unique solution is well-defined.\n- **Objective:** The problem statement is quantitative and free of subjective or ambiguous language.\n\n### Step 3: Verdict and Action\nThe problem is scientifically sound, well-posed, and internally consistent. It is deemed **valid**. I will proceed with the full solution.\n\nThe task is to compute the fraction of analytes flagged as outliers. The process for each of the $3$ analytes involves two main steps: unit harmonization and value normalization. An analyte is classified as an outlier if its normalized score's absolute value exceeds $2$.\n\nThe normalization is based on the premise that the reference interval, denoted $[L, U]$, corresponds to the central $95\\%$ of a normal distribution with mean $\\mu$ and standard deviation $\\sigma$. For a normal distribution, the interval containing the central $95\\%$ of data is given by $\\mu \\pm 1.96\\sigma$. Therefore, we can set $L = \\mu - 1.96\\sigma$ and $U = \\mu + 1.96\\sigma$. These relationships allow us to estimate the distribution's parameters:\nThe mean $\\mu$ is the midpoint of the interval:\n$$ \\mu = \\frac{L + U}{2} $$\nThe standard deviation $\\sigma$ is derived from the interval's width:\n$$ U - L = (\\mu + 1.96\\sigma) - (\\mu - 1.96\\sigma) = 3.92\\sigma \\implies \\sigma = \\frac{U - L}{3.92} $$\nThe normalized score, or Z-score, for a measured value $X$ (in harmonized units) is then:\n$$ Z = \\frac{X - \\mu}{\\sigma} $$\nThe outlier condition is $|Z| > 2$.\n\nWe apply this procedure to each analyte.\n\n**1. Plasma Glucose**\n- Measured value: $95$ mg/dL.\n- Target unit: mmol/L.\n- Molar mass: $M_{\\text{glucose}} = 180.15588$ g/mol.\n- Reference interval: $[L_1, U_1] = [3.9, 5.5]$ mmol/L.\n\nFirst, we perform the unit conversion. We use the conversion factors $1$ dL = $0.1$ L, $1$ g = $1000$ mg, and $1$ mol = $1000$ mmol.\nThe value in the target unit, $X_1$, is:\n$$ X_1 = 95 \\frac{\\text{mg}}{\\text{dL}} \\times \\frac{1 \\text{ dL}}{0.1 \\text{ L}} \\times \\frac{1 \\text{ g}}{1000 \\text{ mg}} \\times \\frac{1 \\text{ mol}}{180.15588 \\text{ g}} \\times \\frac{1000 \\text{ mmol}}{1 \\text{ mol}} $$\n$$ X_1 = \\frac{950}{180.15588} \\frac{\\text{mmol}}{\\text{L}} \\approx 5.2731 \\frac{\\text{mmol}}{\\text{L}} $$\nNext, we calculate the normalization parameters and the Z-score.\n$$ \\mu_1 = \\frac{3.9 + 5.5}{2} = 4.7 \\text{ mmol/L} $$\n$$ \\sigma_1 = \\frac{5.5 - 3.9}{3.92} = \\frac{1.6}{3.92} \\text{ mmol/L} $$\nThe Z-score for glucose is:\n$$ Z_1 = \\frac{X_1 - \\mu_1}{\\sigma_1} = \\frac{\\frac{950}{180.15588} - 4.7}{\\frac{1.6}{3.92}} \\approx \\frac{5.2731 - 4.7}{0.40816} \\approx 1.4041 $$\nWe check the outlier condition: $|Z_1| \\approx 1.4041$. Since $|Z_1| \\le 2$, glucose is **not an outlier**.\n\n**2. Serum Creatinine**\n- Measured value: $1.3$ mg/dL.\n- Target unit: $\\mu$mol/L.\n- Molar mass: $M_{\\text{creatinine}} = 113.12$ g/mol.\n- Reference interval: $[L_2, U_2] = [60, 110]$ $\\mu$mol/L.\n\nFirst, the unit conversion. We use $1$ dL = $0.1$ L, $1$ g = $1000$ mg, and $1$ mol = $10^6$ $\\mu$mol.\nThe value in the target unit, $X_2$, is:\n$$ X_2 = 1.3 \\frac{\\text{mg}}{\\text{dL}} \\times \\frac{1 \\text{ dL}}{0.1 \\text{ L}} \\times \\frac{1 \\text{ g}}{1000 \\text{ mg}} \\times \\frac{1 \\text{ mol}}{113.12 \\text{ g}} \\times \\frac{10^6 \\mu\\text{mol}}{1 \\text{ mol}} $$\n$$ X_2 = \\frac{13000}{113.12} \\frac{\\mu\\text{mol}}{\\text{L}} \\approx 114.922 \\frac{\\mu\\text{mol}}{\\text{L}} $$\nNext, we calculate the Z-score.\n$$ \\mu_2 = \\frac{60 + 110}{2} = 85 \\text{ }\\mu\\text{mol/L} $$\n$$ \\sigma_2 = \\frac{110 - 60}{3.92} = \\frac{50}{3.92} \\text{ }\\mu\\text{mol/L} $$\nThe Z-score for creatinine is:\n$$ Z_2 = \\frac{X_2 - \\mu_2}{\\sigma_2} = \\frac{\\frac{13000}{113.12} - 85}{\\frac{50}{3.92}} \\approx \\frac{114.922 - 85}{12.7551} \\approx 2.3459 $$\nWe check the outlier condition: $|Z_2| \\approx 2.3459$. Since $|Z_2| > 2$, creatinine is an **outlier**.\n\n**3. Alanine Aminotransferase (ALT)**\n- Measured value: $58$ U/L.\n- Target unit: U/L.\n- Reference interval: $[L_3, U_3] = [10, 40]$ U/L.\n\nThe measured value is already in the target units, so $X_3 = 58$ U/L. No unit conversion is needed.\nWe calculate the normalization parameters and Z-score.\n$$ \\mu_3 = \\frac{10 + 40}{2} = 25 \\text{ U/L} $$\n$$ \\sigma_3 = \\frac{40 - 10}{3.92} = \\frac{30}{3.92} \\text{ U/L} $$\nThe Z-score for ALT is:\n$$ Z_3 = \\frac{X_3 - \\mu_3}{\\sigma_3} = \\frac{58 - 25}{\\frac{30}{3.92}} = \\frac{33 \\times 3.92}{30} = 1.1 \\times 3.92 = 4.312 $$\nWe check the outlier condition: $|Z_3| = 4.312$. Since $|Z_3| > 2$, ALT is an **outlier**.\n\n**Final Calculation**\nOf the $3$ analytes analyzed, $2$ were flagged as outliers (creatinine and ALT). The fraction of analytes that are outliers is:\n$$ \\text{Fraction of outliers} = \\frac{\\text{Number of outliers}}{\\text{Total number of analytes}} = \\frac{2}{3} $$\nThe problem requires the answer as a decimal rounded to four significant figures.\n$$ \\frac{2}{3} \\approx 0.666666... $$\nRounding to four significant figures yields $0.6667$.", "answer": "$$\n\\boxed{0.6667}\n$$", "id": "4859949"}, {"introduction": "Beyond understanding the content of health data, we must also be able to trust its origin and integrity. This exercise guides you through constructing a FHIR Provenance resource, which acts as a digital audit trail, and securing it with a cryptographic signature. Mastering this practice is key to building trustworthy systems where the source and history of every piece of clinical information are verifiable [@problem_id:4859894].", "problem": "You are asked to write a complete, runnable program that models a core interoperability workflow in healthcare by constructing a simplified Fast Healthcare Interoperability Resources (FHIR) Provenance resource that links a clinical Observation to its origin information (device, operator, and software version) and computes digital signature metadata for integrity. The goal is to formalize the construction and validation rules using first principles from data integrity and resource linking to test whether the constructed Provenance meets the specified constraints. Your program must strictly follow the rules below, then apply them to a provided test suite, and finally output the validation results for all test cases in a single line.\n\nFoundational bases to use:\n- Interoperability requires that data from different systems be structured, semantically consistent, and verifiable. In the Health Level Seven (HL7) Fast Healthcare Interoperability Resources (FHIR) model, Provenance records who, what, when, and how a resource was produced. Data integrity can be attained using a keyed hash (Hash-based Message Authentication Code (HMAC)), a well-tested cryptographic primitive.\n- For a message of byte-length $n$, the Hash-based Message Authentication Code (HMAC) using Secure Hash Algorithm 256-bit (SHA-256) produces a $32$-byte digest. Standard Base64 encoding maps $3$ bytes into $4$ characters. Therefore, the Base64 encoded length $L$ of a $32$-byte digest satisfies $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$. This length property is used as a structural integrity check for the signature.\n\nDefinitions and construction rules:\n1. Inputs for each test case are strings: Observation identifier $o$, Device identifier $d$, operator (Practitioner) identifier $p$, software version $v$, occurred time $t_o$ (ISO $8601$ with a trailing $Z$ for Coordinated Universal Time (UTC)), recorded time $t_r$ (ISO $8601$ with a trailing $Z$), signature algorithm $a$, and a secret key $k$ (for computing the Hash-based Message Authentication Code (HMAC)).\n2. You must construct a simplified FHIR Provenance resource (modeled as a nested key-value structure) with at least the following fields:\n   - target: the Observation reference string \"Observation/\" concatenated with $o$.\n   - agent: a list containing exactly two entries:\n     - The operator agent with role \"author\" and reference \"Practitioner/\" concatenated with $p$.\n     - The device agent with role \"assembler\" and reference \"Device/\" concatenated with $d$.\n   - software: the software version string $v$.\n   - occurred: the time $t_o$.\n   - recorded: the time $t_r$.\n   - signature: an object with fields:\n     - type: \"application/fhir+json\".\n     - alg: the algorithm $a$.\n     - who: the string \"Practitioner/\" concatenated with $p$.\n     - when: the time $t_r$.\n     - data: the Base64-encoded Hash-based Message Authentication Code (HMAC) over a canonical string, using key $k$ and algorithm $a$ if and only if $a$ equals the literal \"HMAC-SHA256\"; otherwise, set data to the empty string.\n3. The canonical string to be signed, denoted $\\mathcal{C}$, must be constructed exactly as the following seven lines concatenated with the newline character $\\verb|\n|$:\n   - \"target=Observation/\" followed by $o$\n   - \"device=Device/\" followed by $d$\n   - \"operator=Practitioner/\" followed by $p$\n   - \"software=\" followed by $v$\n   - \"occurred=\" followed by $t_o$\n   - \"recorded=\" followed by $t_r$\n   - \"alg=\" followed by $a$\n   Therefore, if we denote string concatenation by $\\Vert$, the message is\n$$\n\\mathcal{C} = s_1 \\Vert \\verb|\n| \\Vert s_2 \\Vert \\verb|\n| \\Vert s_3 \\Vert \\verb|\n| \\Vert s_4 \\Vert \\verb|\n| \\Vert s_5 \\Vert \\verb|\n| \\Vert s_6 \\Vert \\verb|\n| \\Vert s_7,\n$$\n   where each $s_i$ corresponds to the respective line above.\n4. You must compute the signature data as follows:\n   - If $a$ equals \"HMAC-SHA256\", compute the Hash-based Message Authentication Code (HMAC) of $\\mathcal{C}$ using $k$ as the key and SHA-256 as the hash function, then Base64 encode the resulting $32$-byte digest to produce a $44$-character string (including any padding). Place this string into signature.data.\n   - Otherwise, place the empty string into signature.data.\n\nValidation rules:\nTo determine whether the constructed Provenance resource is valid, all of the following must hold:\n- Identifier format: $o$, $d$, and $p$ must be non-empty and match the regular expression for simple FHIR identifiers: `^[A-Za-z0-9.-]+$`.\n- Version format: $v$ must match semantic versioning with a leading \"v\": the pattern `^v(\\d+)\\.(\\d+)\\.(\\d+)`, meaning a literal \"v\" followed by three dot-separated non-negative integers.\n- Time ordering: parse $t_o$ and $t_r$ as Coordinated Universal Time (UTC) timestamps in ISO $8601$ (with a trailing $Z$), and require $t_r \\ge t_o$.\n- Target and who links: target equals \"Observation/\" concatenated with $o$, and signature.who equals \"Practitioner/\" concatenated with $p$.\n- Agent roles: the agent list contains exactly one operator with role \"author\" referencing \"Practitioner/\" concatenated with $p$, and exactly one device with role \"assembler\" referencing \"Device/\" concatenated with $d$.\n- Signature algorithm and length: $a$ must be exactly the literal \"HMAC-SHA256\". Additionally, signature.data must be a non-empty Base64 string of length exactly $44$, consistent with a Base64-encoded $32$-byte digest. This leverages $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$.\n\nThe program requirements:\n- Implement the construction of the Provenance resource and validation per the rules above.\n- Apply the construction and validation to the following test suite of parameter sets. Each test case is a tuple $(o, d, p, v, t_o, t_r, a, k)$ where all elements are strings.\n\nTest suite:\n- Test case $1$ (happy path): $o=$ \"obs-001\", $d=$ \"dev-Alpha\", $p=$ \"prac-777\", $v=$ \"v1.2.3\", $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:05Z\", $a=$ \"HMAC-SHA256\", $k=$ \"s3cr3t-key-01\".\n- Test case $2$ (invalid operator identifier): $o=$ \"obs-002\", $d=$ \"dev-Alpha\", $p=$ \"prac 777\" (note the space), $v=$ \"v1.2.3\", $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:05Z\", $a=$ \"HMAC-SHA256\", $k=$ \"s3cr3t-key-01\".\n- Test case $3$ (recorded before occurred): $o=$ \"obs-003\", $d=$ \"dev-Beta\", $p=$ \"prac-555\", $v=$ \"v2.0.0\", $t_o=$ \"2024-06-01T12:00:05Z\", $t_r=$ \"2024-06-01T12:00:00Z\", $a=$ \"HMAC-SHA256\", $k=$ \"another-key\".\n- Test case $4$ (invalid algorithm and version format): $o=$ \"obs-004\", $d=$ \"dev-Gamma\", $p=$ \"prac-101\", $v=$ \"v3.1\" (missing patch), $t_o=$ \"2024-06-01T12:00:00Z\", $t_r=$ \"2024-06-01T12:00:10Z\", $a=$ \"HMAC-SHA1\" (unsupported), $k=$ \"k\".\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each result is the boolean validity for the corresponding test case in order. For example, a valid output could look like \"[True,False,True,False]\" depending on your computed validations. Your program must not read any input and must not print anything else beyond this single line.\n\nNotes:\n- All string parsing and comparisons are case-sensitive.\n- All times are in Coordinated Universal Time (UTC); use the standard ISO $8601$ format with a trailing \"Z\".\n- No external files or network access is allowed.", "solution": "The problem requires the construction and validation of a simplified Fast Healthcare Interoperability Resources (FHIR) Provenance resource. The process is governed by a strict set of rules pertaining to data structure, content, and cryptographic integrity. The solution must be implemented as a program that evaluates a series of test cases against these rules.\n\nThe problem is determined to be valid as it is scientifically grounded in established standards (FHIR) and cryptographic methods (HMAC-SHA256), is well-posed with unambiguous rules, and contains all necessary information to produce a unique, verifiable result. The core of the problem lies in the meticulous implementation of a detailed specification, a task central to engineering and informatics.\n\nMy approach is to develop a single validation function that encapsulates all specified rules. This function will take the eight input parameters for a given test case—$o$ (Observation ID), $d$ (Device ID), $p$ (Practitioner ID), $v$ (software version), $t_o$ (occurred time), $t_r$ (recorded time), $a$ (algorithm), and $k$ (secret key)—and return a boolean value indicating validity. The function will proceed by checking each validation rule in a logical sequence, returning `False` upon the first failure. This fail-fast strategy is efficient and logically sound.\n\nThe validation process is structured as follows:\n\n1.  **Input Format Validation**: The initial step is to validate the format of the primary inputs. This is the first gate for a test case to pass.\n    *   **Identifier Format**: The identifiers $o$, $d$, and $p$ must be non-empty strings conforming to the specified regular expression for simple FHIR identifiers. The problem statement provides a formal pattern, `^[A-Za-z0-9.-]+$`, which dictates that identifiers consist of one or more uppercase or lowercase letters, digits, hyphens, or periods.\n    *   **Version Format**: The software version string $v$ must adhere to a simplified semantic versioning scheme, specifically matching the regular expression `^v(\\d+)\\.(\\d+)\\.(\\d+)$`. This corresponds to a literal 'v' followed by three dot-separated integer components.\n    *   **Time Ordering**: The timestamps $t_o$ and $t_r$, provided in ISO $8601$ format with a UTC designator 'Z', must be logically consistent. The `recorded` time $t_r$ must be greater than or equal to the `occurred` time $t_o$, i.e., $t_r \\ge t_o$. This is a fundamental check for temporal plausibility.\n\n2.  **Algorithm and Signature Prerequisite Validation**: The validation rules impose strict constraints on the signature. A critical prerequisite is the choice of algorithm.\n    *   **Algorithm Specification**: The algorithm identifier $a$ must be the exact literal string \"HMAC-SHA256\". As per the validation rules, no other algorithm is permissible. If this condition is not met, the resource is invalid. This check is performed upfront, as it determines whether a signature should be computed at all.\n\n3.  **Canonical String Construction and Signature Generation**: For a test case that passes the initial checks, the signature data is computed. This involves two steps.\n    *   **Canonicalization**: A canonical string, denoted $\\mathcal{C}$, is constructed. This string is a concatenation of seven specific key-value pairs, separated by newline characters (`\n`). The precise, ordered, and formatted nature of $\\mathcal{C}$ is critical for ensuring that the signature is reproducible and unambiguous. The string is formed as:\n        $\\mathcal{C} = (\\text{\"target=Observation/\"} \\Vert o) \\Vert \\text{'\n'} \\Vert (\\text{\"device=Device/\"} \\Vert d) \\Vert \\text{'\n'} \\Vert \\dots \\Vert (\\text{\"alg=\"} \\Vert a)$\n    *   **HMAC Calculation and Encoding**: The signature data is the Base64 encoding of a keyed-hash message authentication code. Specifically, the HMAC is computed using the SHA-256 hash function, with the UTF-8-encoded canonical string $\\mathcal{C}$ as the message and the UTF-8-encoded secret key $k$ as the key. The resulting $32$-byte digest is then encoded using standard Base64.\n\n4.  **Final Signature Validation**: The final validation rule concerns the generated signature data itself.\n    *   **Signature Data Length**: The problem states that a Base64-encoded $32$-byte digest from SHA-256 results in a string of length $L = 4 \\cdot \\lceil 32/3 \\rceil = 44$. A key validation rule is that the `signature.data` field must be a non-empty string of exactly length $44$. This check simultaneously validates the correctness of the cryptographic primitive used (it must produce $32$ bytes) and the encoding process. Since the construction rule specifies that `signature.data` is an empty string if $a$ is not \"HMAC-SHA256\", this length check implicitly enforces the algorithm requirement as well. A case with an invalid algorithm will produce an empty `data` string, which has length $0$, failing the length check of $44$.\n\nA test case is deemed valid if and only if it satisfies every single one of these validation rules. The program will iterate through the provided test suite, apply this comprehensive validation logic to each case, and aggregate the boolean results for the final output. The rules related to the constructed resource's internal structure (e.g., `target` and `agent` fields) are programmatically guaranteed to be correct if the construction logic is implemented faithfully according to the specification; thus, their validation is inherent to a correct implementation.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport re\nfrom datetime import datetime\nimport hmac\nimport hashlib\nimport base64\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1 (happy path)\n        (\"obs-001\", \"dev-Alpha\", \"prac-777\", \"v1.2.3\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:05Z\", \"HMAC-SHA256\", \"s3cr3t-key-01\"),\n        # Test case 2 (invalid operator identifier with a space)\n        (\"obs-002\", \"dev-Alpha\", \"prac 777\", \"v1.2.3\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:05Z\", \"HMAC-SHA256\", \"s3cr3t-key-01\"),\n        # Test case 3 (recorded time before occurred time)\n        (\"obs-003\", \"dev-Beta\", \"prac-555\", \"v2.0.0\", \"2024-06-01T12:00:05Z\", \"2024-06-01T12:00:00Z\", \"HMAC-SHA256\", \"another-key\"),\n        # Test case 4 (invalid algorithm and version format)\n        (\"obs-004\", \"dev-Gamma\", \"prac-101\", \"v3.1\", \"2024-06-01T12:00:00Z\", \"2024-06-01T12:00:10Z\", \"HMAC-SHA1\", \"k\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_valid = validate_provenance(*case)\n        results.append(is_valid)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef validate_provenance(o, d, p, v, t_o, t_r, a, k):\n    \"\"\"\n    Validates a single provenance case based on the problem's rules.\n\n    Args:\n        o (str): Observation identifier.\n        d (str): Device identifier.\n        p (str): Practitioner identifier.\n        v (str): Software version.\n        t_o (str): Occurred time (ISO 8601).\n        t_r (str): Recorded time (ISO 8601).\n        a (str): Signature algorithm.\n        k (str): Secret key for HMAC.\n\n    Returns:\n        bool: True if the case is valid, False otherwise.\n    \"\"\"\n    # Validation Rule 1: Identifier format\n    # The pattern must match from start to end (re.fullmatch).\n    # The '+' in the regex ensures ids are non-empty.\n    id_pattern = r'[A-Za-z0-9.-]+'\n    if not (re.fullmatch(id_pattern, o) and\n            re.fullmatch(id_pattern, d) and\n            re.fullmatch(id_pattern, p)):\n        return False\n\n    # Validation Rule 2: Version format\n    version_pattern = r'v(\\d+)\\.(\\d+)\\.(\\d+)'\n    if not re.fullmatch(version_pattern, v):\n        return False\n\n    # Validation Rule 3: Time ordering\n    try:\n        # Python's fromisoformat handles the trailing 'Z' correctly since 3.11\n        # For compatibility with slightly older pythons, one can replace 'Z' with '+00:00'\n        # As per spec, env is 3.12, so this is fine.\n        dt_o = datetime.fromisoformat(t_o)\n        dt_r = datetime.fromisoformat(t_r)\n        if dt_r  dt_o:\n            return False\n    except ValueError:\n        # If timestamp parsing fails, it's invalid.\n        return False\n\n    # Validation Rule 6 (part 1): Signature algorithm\n    # The algorithm must be exactly \"HMAC-SHA256\".\n    if a != \"HMAC-SHA256\":\n        return False\n\n    # Construction of canonical string for signing\n    canonical_string = \"\\n\".join([\n        f\"target=Observation/{o}\",\n        f\"device=Device/{d}\",\n        f\"operator=Practitioner/{p}\",\n        f\"software={v}\",\n        f\"occurred={t_o}\",\n        f\"recorded={t_r}\",\n        f\"alg={a}\"\n    ])\n\n    # Compute signature data according to construction rule\n    signature_data = \"\"\n    # The check `a == \"HMAC-SHA256\"` is redundant due to the prior check,\n    # but included for clarity of implementation of construction rule.\n    if a == \"HMAC-SHA256\":\n        key_bytes = k.encode('utf-8')\n        msg_bytes = canonical_string.encode('utf-8')\n        digest = hmac.new(key_bytes, msg_bytes, hashlib.sha256).digest()\n        signature_data = base64.b64encode(digest).decode('ascii')\n\n    # Validation Rule 6 (part 2): Signature data length\n    # Must be non-empty and exactly 44 characters long.\n    if len(signature_data) != 44:\n        return False\n        \n    # Validation Rules 4 (Target/who links) and 5 (Agent roles) are implicitly\n    # satisfied by a correct implementation of the construction rules. The logic\n    # here correctly follows those rules, so no explicit self-check is needed.\n\n    # If all checks pass, the provenance is valid.\n    return True\n\nsolve()\n```", "id": "4859894"}, {"introduction": "Clinical workflows rarely involve a single, isolated piece of data; more often, they generate a web of related information that must be kept consistent. This final practice explores how FHIR transaction bundles manage this complexity by ensuring a set of operations succeeds or fails as a single atomic unit. You will model the dependencies between resources as a directed graph and implement an algorithm to find a valid processing order, a core task for any FHIR server handling complex clinical events [@problem_id:4859896].", "problem": "You are to write a complete program that constructs and analyzes Fast Healthcare Interoperability Resources (FHIR) transaction bundles to demonstrate atomic creation of related clinical resources and to determine a deterministic server processing order under a simplified, implementation-agnostic model consistent with the idea of atomic transactions in healthcare interoperability.\n\nFundamental base and assumptions:\n- Atomicity, Consistency, Isolation, Durability (ACID) transactions: An atomic transaction either commits all included operations or none. Under this view, the server must evaluate the entire set of requested operations and either apply them all or roll them back. In this problem, atomicity is modeled as the requirement that an execution order exists that satisfies all inter-resource references within the bundle.\n- Graph dependency resolution: Given a directed graph $G = (V, E)$ with $|V| = n$ entries and $|E| = m$ directed edges, where each edge $(u, v) \\in E$ encodes that entry $u$ must be processed before entry $v$, a valid processing order exists if and only if $G$ is a Directed Acyclic Graph (DAG). A topological ordering can be found in time $\\mathcal{O}(n + m)$.\n\nYour program must:\n- Construct the four FHIR transaction bundles defined in the test suite below as in-memory structures.\n- For each bundle, determine a processing order of entries that respects intra-bundle references by `fullUrl`. Model the order determination as follows:\n  - Build a directed graph $G$ where each entry is a node. For any entry $i$, if it contains a FHIR Reference to some fullUrl that corresponds to entry $j$ in the same bundle, add a directed edge $j \\to i$. This encodes that $j$ must be processed before $i$.\n  - Compute a topological order using Kahn’s algorithm with deterministic tie-breaking: among nodes with indegree $0$, always take the one with the smallest original entry index first. Continue until no nodes remain or no further progress is possible.\n  - If all nodes are ordered, return the resulting list of zero-based indices. If a cycle is detected (that is, some nodes remain with indegree $ 0$), return an empty list to indicate that the transaction cannot be topologically ordered under this model.\n- Reference extraction: Treat any dictionary field named \"reference\" whose value is a string as a candidate FHIR Reference. A reference is considered an intra-bundle dependency only if its string value exactly matches the fullUrl of some entry in the same bundle. Traverse the resource recursively so that references can be found at any depth, including arrays such as derivedFrom.\n- Do not use external input; the bundles must be constructed in the program.\n\nTransaction semantics to model:\n- All requests use Hypertext Transfer Protocol (HTTP) POST to create resources. Conditional create constraints (ifNoneExist) do not change dependency rules in this simplified model; only explicit intra-bundle References by fullUrl influence ordering.\n\nTest suite to cover typical and edge scenarios:\n- Case A (happy path with multiple dependencies and out-of-order entries):\n  - Entries at indices $0, 1, 2, 3$ respectively represent an Encounter referencing a Patient, an Observation referencing both the Encounter and the Patient, the Patient, and another Observation referencing the Patient. The Encounter and Observations appear before the Patient to test that the algorithm correctly reorders them.\n- Case B (boundary: single entry with no references):\n  - A single Observation with no references.\n- Case C (edge: cycle):\n  - Two Observations that reference each other via derivedFrom, forming a directed cycle.\n- Case D (mixed: conditional create, multiple dependencies, and an unrelated Device):\n  - An Observation that references a Patient, an Encounter, and a Device, but is listed before those resources. The Encounter references the Patient. Another Observation references only the Patient. The Device has no references. The Patient uses a conditional create (ifNoneExist) constraint; this does not alter dependency edges in this model.\n\nRequired outputs per test case:\n- For each bundle, produce either:\n  - A list of zero-based indices indicating a valid deterministic processing order that satisfies all intra-bundle references, or\n  - An empty list if no such order exists.\n- Aggregate the outputs for the four test cases into a single line.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[rA,rB,rC,rD]\"). In this problem, each element is either a list of integers or an empty list, representing the result for one test case. The printed line must match exactly this single-line format with no additional text.\n\nThe four bundles are defined as follows. Each has \"type\": \"transaction\" and an \"entry\" array. Indices refer to the zero-based position in the entry array.\n\n- Case A entries (indices $0$ to $3$):\n  - Index $0$: Encounter with fullUrl \"urn:uuid:enc1\" and resource.subject.reference \"urn:uuid:pat1\".\n  - Index $1$: Observation with fullUrl \"urn:uuid:obs1\" and references to \"urn:uuid:pat1\" (subject) and \"urn:uuid:enc1\" (encounter).\n  - Index $2$: Patient with fullUrl \"urn:uuid:pat1\".\n  - Index $3$: Observation with fullUrl \"urn:uuid:obs2\" referencing \"urn:uuid:pat1\" (subject).\n- Case B entries (index $0$):\n  - Index $0$: Observation with fullUrl \"urn:uuid:obsX\" and no references.\n- Case C entries (indices $0$ to $1$):\n  - Index $0$: Observation with fullUrl \"urn:uuid:obsA\" and derivedFrom [{\"reference\": \"urn:uuid:obsB\"}].\n  - Index $1$: Observation with fullUrl \"urn:uuid:obsB\" and derivedFrom [{\"reference\": \"urn:uuid:obsA\"}].\n- Case D entries (indices $0$ to $4$):\n  - Index $0$: Observation with fullUrl \"urn:uuid:obs3\" and references to \"urn:uuid:pat2\" (subject), \"urn:uuid:enc2\" (encounter), and \"urn:uuid:dev1\" (device).\n  - Index $1$: Patient with fullUrl \"urn:uuid:pat2\" and a conditional create request (ifNoneExist present).\n  - Index $2$: Encounter with fullUrl \"urn:uuid:enc2\" and resource.subject.reference \"urn:uuid:pat2\".\n  - Index $3$: Observation with fullUrl \"urn:uuid:obs4\" referencing \"urn:uuid:pat2\" (subject).\n  - Index $4$: Device with fullUrl \"urn:uuid:dev1\" and no references.\n\nYour task is to implement the algorithm described above, apply it to these four bundles, and print the single-line aggregated result as specified.", "solution": "The problem requires the determination of a valid, deterministic processing order for entries within a Fast Healthcare Interoperability Resources (FHIR) transaction bundle. This is accomplished by modeling the inter-resource dependencies as a directed graph and finding a topological sort. The entire process is grounded in the principles of graph theory and algorithms.\n\n### Principle: Dependency Resolution via Topological Sorting\n\nA FHIR transaction bundle represents a set of operations that must be executed atomically. That is, either all operations succeed, or none do. A prerequisite for success is that all intra-bundle references must be resolvable. For a set of `CREATE` operations, this implies that if resource $A$ references resource $B$, resource $B$ must be created before resource $A$. This establishes a dependency relationship.\n\nThis system of dependencies can be formally modeled as a directed graph $G = (V, E)$, where:\n- The set of vertices, $V$, represents the entries in the FHIR bundle. Let $n = |V|$ be the number of entries.\n- The set of directed edges, $E$, represents the dependencies. A directed edge from vertex $j$ to vertex $i$, denoted as $j \\to i$, is added to $E$ if the resource in entry $i$ contains a reference to the resource in entry $j$. This edge signifies that entry $j$ must be processed before entry $i$.\n\nA valid processing order for all entries exists if and only if the dependency graph $G$ is a Directed Acyclic Graph (DAG). If the graph contains a cycle (e.g., entry $A$ depends on $B$, and entry $B$ depends on $A$), no linear ordering can satisfy all dependencies, and the transaction is invalid.\n\nThe task of finding a valid linear ordering is known as topological sorting. A topological sort of a DAG is a linear ordering of its vertices such that for every directed edge from vertex $u$ to vertex $v$, $u$ comes before $v$ in the ordering. If the graph is not a DAG, no topological sort exists.\n\n### Algorithm: Kahn's Algorithm for Topological Sorting\n\nTo find a topological sort, we will employ Kahn's algorithm. This algorithm is particularly well-suited because it can also detect cycles. The algorithm has a time complexity of $\\mathcal{O}(n + m)$, where $n$ is the number of vertices (bundle entries) and $m$ is the number of edges (dependencies), which is efficient.\n\nThe problem specifies a deterministic tie-breaking rule: when multiple entries are ready to be processed (i.e., all their dependencies are met), the one with the smallest original index in the bundle's `entry` array must be chosen first. This ensures a unique output for any given bundle. We can implement this tie-breaking rule by using a min-priority queue (min-heap) to store ready-to-process nodes, ordered by their original index.\n\nThe algorithm proceeds as follows:\n\n1.  **Graph Construction**:\n    - Iterate through each entry $i \\in \\{0, 1, \\dots, n-1\\}$ in the bundle.\n    - Recursively scan the `resource` payload of entry $i$ for any field with the key `\"reference\"`.\n    - For each reference found, if its value corresponds to the `fullUrl` of another entry $j$ in the same bundle, a dependency $j \\to i$ is established.\n    - An adjacency list, `adj`, is created where `adj[j]` stores a list of all entries $i$ that depend on $j$.\n    - An array, `in_degree`, of size $n$ is computed, where `in_degree[i]` stores the count of incoming edges for vertex $i$.\n\n2.  **Initialization**:\n    - Create a min-priority queue, $S$.\n    - For all vertices $i \\in V$, if `in_degree[i]` is $0$, add $i$ to $S$. These are the initial entries with no dependencies.\n    - Initialize an empty list, $L$, which will store the final sorted order of indices.\n\n3.  **Processing Loop**:\n    - While $S$ is not empty:\n        a. Extract the vertex $u$ with the minimum value (smallest original index) from $S$.\n        b. Append $u$ to the list $L$.\n        c. For each neighbor $v$ of $u$ (i.e., for each $v$ in `adj[u]`):\n            i. Decrement `in_degree[v]` by $1$.\n            ii. If `in_degree[v]` becomes $0$, it means all of its dependencies have been met. Add $v$ to the priority queue $S$.\n\n4.  **Cycle Detection and Finalization**:\n    - After the loop terminates, if the number of entries in $L$ is equal to $n$, then $L$ contains a valid topological sort. The algorithm returns $L$.\n    - If the number of entries in $L$ is less than $n$, it implies that there was at least one vertex with an in-degree that never reached zero. This can only happen if a cycle exists in the graph. In this case, a valid processing order is impossible, and the algorithm returns an empty list.\n\n### Application to Test Cases\n\n- **Case A (Happy Path)**: A Patient is referenced by an Encounter and two Observations. The Encounter is also referenced by one of the Observations. The algorithm correctly identifies the Patient (index $2$) as having no dependencies, processes it first, and subsequently resolves the dependencies for the other entries, yielding the order $[2, 0, 1, 3]$.\n- **Case B (Boundary)**: A single Observation with no references has an in-degree of $0$. It is processed immediately, resulting in the order $[0]$.\n- **Case C (Cycle)**: Two Observations reference each other. This creates a cycle $0 \\to 1 \\to 0$. Neither entry has an in-degree of $0$, so the algorithm's priority queue remains empty. It correctly detects the cycle and returns an empty list `[]`.\n- **Case D (Mixed)**: A complex set of dependencies involving a Patient, Encounters, Observations, and a standalone Device. The Patient (index $1$) and Device (index $4$) have no initial dependencies. The tie-breaking rule ensures the Patient (index $1$) is processed first. Following this, the algorithm resolves the remaining dependencies in the deterministic order specified, producing $[1, 2, 3, 4, 0]$. The `ifNoneExist` parameter is correctly ignored for dependency analysis as per the problem statement.", "answer": "```python\nimport heapq\nimport numpy as np  # Included to meet problem specification, but not used.\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the topological sort algorithm,\n    and print the results in the required format.\n    \"\"\"\n    \n    # Test Suite: FHIR-like transaction bundles\n    test_cases = [\n        # Case A: Happy path with multiple dependencies\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:enc1\",\n                    \"resource\": {\"resourceType\": \"Encounter\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs1\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}, \"encounter\": {\"reference\": \"urn:uuid:enc1\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:pat1\",\n                    \"resource\": {\"resourceType\": \"Patient\"},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs2\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat1\"}},\n                },\n            ],\n        },\n        # Case B: Boundary case with a single entry and no references\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obsX\",\n                    \"resource\": {\"resourceType\": \"Observation\"},\n                }\n            ],\n        },\n        # Case C: Edge case with a cycle\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obsA\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"derivedFrom\": [{\"reference\": \"urn:uuid:obsB\"}]},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obsB\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"derivedFrom\": [{\"reference\": \"urn:uuid:obsA\"}]},\n                },\n            ],\n        },\n        # Case D: Mixed case with multiple dependencies and conditional create\n        {\n            \"type\": \"transaction\",\n            \"entry\": [\n                {\n                    \"fullUrl\": \"urn:uuid:obs3\",\n                    \"resource\": {\n                        \"resourceType\": \"Observation\",\n                        \"subject\": {\"reference\": \"urn:uuid:pat2\"},\n                        \"encounter\": {\"reference\": \"urn:uuid:enc2\"},\n                        \"device\": {\"reference\": \"urn:uuid:dev1\"},\n                    },\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:pat2\",\n                    \"resource\": {\"resourceType\": \"Patient\"},\n                    \"request\": {\"method\": \"POST\", \"url\": \"Patient\", \"ifNoneExist\": \"identifier=123\"},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:enc2\",\n                    \"resource\": {\"resourceType\": \"Encounter\", \"subject\": {\"reference\": \"urn:uuid:pat2\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:obs4\",\n                    \"resource\": {\"resourceType\": \"Observation\", \"subject\": {\"reference\": \"urn:uuid:pat2\"}},\n                },\n                {\n                    \"fullUrl\": \"urn:uuid:dev1\",\n                    \"resource\": {\"resourceType\": \"Device\"},\n                },\n            ],\n        },\n    ]\n\n    results = []\n    for bundle in test_cases:\n        order = find_processing_order(bundle)\n        results.append(order)\n\n    # Format the final output string exactly as required.\n    # str(list) in Python produces a string with spaces, which is standard.\n    # Joining these string representations gives the desired format.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\n\ndef find_references_recursive(data):\n    \"\"\"\n    Recursively traverses a nested Python dictionary/list structure and yields\n    all string values associated with the key \"reference\".\n    \"\"\"\n    if isinstance(data, dict):\n        for key, value in data.items():\n            if key == \"reference\" and isinstance(value, str):\n                yield value\n            else:\n                yield from find_references_recursive(value)\n    elif isinstance(data, list):\n        for item in data:\n            yield from find_references_recursive(item)\n\n\ndef find_processing_order(bundle):\n    \"\"\"\n    Determines a valid processing order for a FHIR bundle using Kahn's algorithm\n    with deterministic tie-breaking.\n\n    Args:\n        bundle (dict): A FHIR-like bundle structure.\n\n    Returns:\n        list: A list of indices representing the processing order, or an empty\n              list if a cycle is detected.\n    \"\"\"\n    entries = bundle.get(\"entry\", [])\n    num_nodes = len(entries)\n    if num_nodes == 0:\n        return []\n\n    url_to_index = {entry.get(\"fullUrl\"): i for i, entry in enumerate(entries) if entry.get(\"fullUrl\")}\n    \n    adj = {i: [] for i in range(num_nodes)}\n    in_degree = {i: 0 for i in range(num_nodes)}\n\n    # Build the dependency graph\n    for i, entry in enumerate(entries):\n        resource = entry.get(\"resource\", {})\n        for ref_url in find_references_recursive(resource):\n            if ref_url in url_to_index:\n                # Dependency found: j must be processed before i\n                j = url_to_index[ref_url]\n                if j != i: # Self-references don't affect topological sort order\n                    adj[j].append(i)\n                    in_degree[i] += 1\n\n    # Kahn's algorithm with a min-heap for deterministic tie-breaking\n    # The min-heap will always provide the node with the smallest index\n    priority_queue = [i for i in range(num_nodes) if in_degree[i] == 0]\n    heapq.heapify(priority_queue)\n    \n    sorted_order = []\n    \n    while priority_queue:\n        u = heapq.heappop(priority_queue)\n        sorted_order.append(u)\n        \n        # Sort neighbors for deterministic testing, though not required for correctness\n        # as the heap handles the \"which node to process next\" logic.\n        # The order of decrementing in-degrees doesn't affect the final result.\n        for v in sorted(adj[u]): \n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                heapq.heappush(priority_queue, v)\n\n    if len(sorted_order) == num_nodes:\n        return sorted_order\n    else:\n        # A cycle was detected\n        return []\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4859896"}]}