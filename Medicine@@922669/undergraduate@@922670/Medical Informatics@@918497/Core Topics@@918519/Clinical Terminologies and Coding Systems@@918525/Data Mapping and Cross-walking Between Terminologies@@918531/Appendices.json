{"hands_on_practices": [{"introduction": "The first step in many automated terminology mapping pipelines involves identifying candidate matches based on lexical similarity. This practice provides hands-on experience with the foundational algorithms used for this task. By calculating common string-based metrics such as the Jaccard index, cosine similarity, and normalized edit distance, you will learn how to quantitatively compare clinical terms and evaluate the performance of different methods in ranking potential matches [@problem_id:4832998].", "problem": "A clinical data integration team is validating a string-based cross-walk between Systematized Nomenclature of Medicine — Clinical Terms (SNOMED CT) and Logical Observation Identifiers Names and Codes (LOINC). For each SNOMED CT query term $Q_i$, there are two candidate LOINC terms $C_i^{(1)}$ and $C_i^{(2)}$. The preprocessing pipeline lowercases all terms, removes punctuation and hyphens, and tokenizes on whitespace to produce token sets. The team will evaluate three similarity metrics at the token level to rank candidates for each query: Jaccard index, cosine similarity using binary token incidence, and normalized edit similarity computed from the word-level Levenshtein distance with unit costs (substitution, insertion, deletion) and normalization by the larger token sequence length.\n\nYou are given the following queries and candidates, along with the ground-truth correct candidate for each query:\n\n- Query $Q_1$: “Hemoglobin A1c test”\n  - Candidate $C_1^{(1)}$ (correct): “Hemoglobin A1c level”\n  - Candidate $C_1^{(2)}$: “Hepatic function panel”\n- Query $Q_2$: “Basic metabolic panel”\n  - Candidate $C_2^{(1)}$ (correct): “Basic metabolic panel”\n  - Candidate $C_2^{(2)}$: “Complete blood count”\n- Query $Q_3$: “Urinalysis microscopy”\n  - Candidate $C_3^{(1)}$ (correct): “Urinalysis microscopic”\n  - Candidate $C_3^{(2)}$: “Urine culture”\n\nUsing the tokenization described, compute for each query–candidate pair the Jaccard index, the cosine similarity (binary incidence), and the normalized edit similarity defined as $1$ minus the word-level Levenshtein distance divided by the larger token sequence length. For each metric independently, rank the two candidates for each query in descending order of similarity. Then, for each metric, compute the mean reciprocal rank across the $3$ queries, where the reciprocal rank for a query is $1/k$ if the correct candidate appears at position $k$ in that metric’s ranking for that query.\n\nReport the maximum mean reciprocal rank achieved among the three metrics. Round your final answer to four significant figures.", "solution": "We start from standard, well-tested definitions used in medical informatics for string-based term similarity and ranking.\n\nLet a query term produce a token set $A$ and a candidate produce a token set $B$.\n\n- Jaccard index is defined by\n$$\nJ(A,B) \\;=\\; \\frac{|A \\cap B|}{|A \\cup B|}.\n$$\n\n- Cosine similarity for binary token incidence (presence/absence in each set) is\n$$\n\\cos(A,B) \\;=\\; \\frac{|A \\cap B|}{\\sqrt{|A|\\,|B|}}.\n$$\n\n- Normalized edit similarity at the token level is based on the word-level Levenshtein distance $d(A,B)$ with unit costs for substitution, insertion, and deletion. Let $m=|A|$ and $n=|B|$. The normalized edit similarity is\n$$\nS_{\\text{edit}}(A,B) \\;=\\; 1 - \\frac{d(A,B)}{\\max(m,n)}.\n$$\n\nWe now apply the prescribed preprocessing: lowercase, remove punctuation and hyphens, and tokenize on whitespace.\n\nTokenization:\n\n- $Q_1$: “Hemoglobin A1c test” $\\rightarrow$ $A_1=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}\\}$ so $|A_1|=3$.\n  - $C_1^{(1)}$: “Hemoglobin A1c level” $\\rightarrow$ $B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{level}\\}$ so $|B_1^{(1)}|=3$.\n  - $C_1^{(2)}$: “Hepatic function panel” $\\rightarrow$ $B_1^{(2)}=\\{\\text{hepatic}, \\text{function}, \\text{panel}\\}$ so $|B_1^{(2)}|=3$.\n\n- $Q_2$: “Basic metabolic panel” $\\rightarrow$ $A_2=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ so $|A_2|=3$.\n  - $C_2^{(1)}$: “Basic metabolic panel” $\\rightarrow$ $B_2^{(1)}=\\{\\text{basic}, \\text{metabolic}, \\text{panel}\\}$ so $|B_2^{(1)}|=3$.\n  - $C_2^{(2)}$: “Complete blood count” $\\rightarrow$ $B_2^{(2)}=\\{\\text{complete}, \\text{blood}, \\text{count}\\}$ so $|B_2^{(2)}|=3$.\n\n- $Q_3$: “Urinalysis microscopy” $\\rightarrow$ $A_3=\\{\\text{urinalysis}, \\text{microscopy}\\}$ so $|A_3|=2$.\n  - $C_3^{(1)}$: “Urinalysis microscopic” $\\rightarrow$ $B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopic}\\}$ so $|B_3^{(1)}|=2$.\n  - $C_3^{(2)}$: “Urine culture” $\\rightarrow$ $B_3^{(2)}=\\{\\text{urine}, \\text{culture}\\}$ so $|B_3^{(2)}|=2$.\n\nCompute Jaccard $J$:\n\n- $Q_1$:\n  - $A_1 \\cap B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}\\}$ so $|A_1 \\cap B_1^{(1)}|=2$ and $A_1 \\cup B_1^{(1)}=\\{\\text{hemoglobin}, \\text{a1c}, \\text{test}, \\text{level}\\}$ so $|A_1 \\cup B_1^{(1)}|=4$. Hence\n  $$\n  J(A_1,B_1^{(1)}) = \\frac{2}{4} = \\frac{1}{2}.\n  $$\n  - $A_1 \\cap B_1^{(2)}=\\varnothing$ so $|A_1 \\cap B_1^{(2)}|=0$ and $|A_1 \\cup B_1^{(2)}|=6$. Hence\n  $$\n  J(A_1,B_1^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ so $|A_2 \\cap B_2^{(1)}|=3$, $|A_2 \\cup B_2^{(1)}|=3$, and\n  $$\n  J(A_2,B_2^{(1)}) = \\frac{3}{3} = 1.\n  $$\n  - $A_2 \\cap B_2^{(2)}=\\varnothing$ and $|A_2 \\cup B_2^{(2)}|=6$, thus\n  $$\n  J(A_2,B_2^{(2)}) = \\frac{0}{6} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3 \\cap B_3^{(1)}=\\{\\text{urinalysis}\\}$ so $|A_3 \\cap B_3^{(1)}|=1$, and $A_3 \\cup B_3^{(1)}=\\{\\text{urinalysis}, \\text{microscopy}, \\text{microscopic}\\}$ so $|A_3 \\cup B_3^{(1)}|=3$. Hence\n  $$\n  J(A_3,B_3^{(1)}) = \\frac{1}{3}.\n  $$\n  - $A_3 \\cap B_3^{(2)}=\\varnothing$ and $|A_3 \\cup B_3^{(2)}|=4$, thus\n  $$\n  J(A_3,B_3^{(2)}) = \\frac{0}{4} = 0.\n  $$\n\nCompute cosine similarity $\\cos$ for binary incidence:\n\n- $Q_1$:\n  - $|A_1 \\cap B_1^{(1)}|=2$, $|A_1|=3$, $|B_1^{(1)}|=3$ so\n  $$\n  \\cos(A_1,B_1^{(1)}) = \\frac{2}{\\sqrt{3\\cdot 3}} = \\frac{2}{3}.\n  $$\n  - $|A_1 \\cap B_1^{(2)}|=0$ so\n  $$\n  \\cos(A_1,B_1^{(2)}) = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$ so $|A_2 \\cap B_2^{(1)}|=3$, $|A_2|=3$, $|B_2^{(1)}|=3$ and\n  $$\n  \\cos(A_2,B_2^{(1)}) = \\frac{3}{\\sqrt{3\\cdot 3}} = 1.\n  $$\n  - $|A_2 \\cap B_2^{(2)}|=0$ so\n  $$\n  \\cos(A_2,B_2^{(2)}) = 0.\n  $$\n\n- $Q_3$:\n  - $|A_3 \\cap B_3^{(1)}|=1$, $|A_3|=2$, $|B_3^{(1)}|=2$ so\n  $$\n  \\cos(A_3,B_3^{(1)}) = \\frac{1}{\\sqrt{2\\cdot 2}} = \\frac{1}{2}.\n  $$\n  - $|A_3 \\cap B_3^{(2)}|=0$ so\n  $$\n  \\cos(A_3,B_3^{(2)}) = 0.\n  $$\n\nCompute normalized edit similarity $S_{\\text{edit}}$ at the token level. For word-level Levenshtein distance $d$, we count unit-cost substitutions, insertions, deletions.\n\n- $Q_1$:\n  - $A_1=[\\text{hemoglobin}, \\text{a1c}, \\text{test}]$, $B_1^{(1)}=[\\text{hemoglobin}, \\text{a1c}, \\text{level}]$. Transforming $A_1$ to $B_1^{(1)}$ requires $1$ substitution (“test” $\\rightarrow$ “level”), so $d(A_1,B_1^{(1)})=1$. With $m=|A_1|=3$, $n=|B_1^{(1)}|=3$, we have\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(1)}) = 1 - \\frac{1}{\\max(3,3)} = 1 - \\frac{1}{3} = \\frac{2}{3}.\n  $$\n  - $B_1^{(2)}=[\\text{hepatic}, \\text{function}, \\text{panel}]$. Transforming $A_1$ to $B_1^{(2)}$ requires $3$ substitutions, so $d(A_1,B_1^{(2)})=3$ and\n  $$\n  S_{\\text{edit}}(A_1,B_1^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_2$:\n  - $A_2=B_2^{(1)}$, so $d(A_2,B_2^{(1)})=0$ and\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(1)}) = 1 - \\frac{0}{\\max(3,3)} = 1.\n  $$\n  - $B_2^{(2)}=[\\text{complete}, \\text{blood}, \\text{count}]$. Transforming $A_2$ to $B_2^{(2)}$ requires $3$ substitutions, so $d(A_2,B_2^{(2)})=3$ and\n  $$\n  S_{\\text{edit}}(A_2,B_2^{(2)}) = 1 - \\frac{3}{\\max(3,3)} = 0.\n  $$\n\n- $Q_3$:\n  - $A_3=[\\text{urinalysis}, \\text{microscopy}]$, $B_3^{(1)}=[\\text{urinalysis}, \\text{microscopic}]$. Transforming $A_3$ to $B_3^{(1)}$ requires $1$ substitution (“microscopy” $\\rightarrow$ “microscopic”), so $d(A_3,B_3^{(1)})=1$. With $m=|A_3|=2$, $n=|B_3^{(1)}|=2$, we have\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(1)}) = 1 - \\frac{1}{\\max(2,2)} = 1 - \\frac{1}{2} = \\frac{1}{2}.\n  $$\n  - $B_3^{(2)}=[\\text{urine}, \\text{culture}]$. Transforming $A_3$ to $B_3^{(2)}$ requires $2$ substitutions, so $d(A_3,B_3^{(2)})=2$ and\n  $$\n  S_{\\text{edit}}(A_3,B_3^{(2)}) = 1 - \\frac{2}{\\max(2,2)} = 0.\n  $$\n\nRanking per metric for each query (descending similarity):\n\n- Jaccard:\n  - $Q_1$: $C_1^{(1)}$ has $\\frac{1}{2}$, $C_1^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_1^{(1)}$.\n  - $Q_2$: $C_2^{(1)}$ has $1$, $C_2^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_2^{(1)}$.\n  - $Q_3$: $C_3^{(1)}$ has $\\frac{1}{3}$, $C_3^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_3^{(1)}$.\n\n- Cosine:\n  - $Q_1$: $C_1^{(1)}$ has $\\frac{2}{3}$, $C_1^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_1^{(1)}$.\n  - $Q_2$: $C_2^{(1)}$ has $1$, $C_2^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_2^{(1)}$.\n  - $Q_3$: $C_3^{(1)}$ has $\\frac{1}{2}$, $C_3^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_3^{(1)}$.\n\n- Normalized edit similarity:\n  - $Q_1$: $C_1^{(1)}$ has $\\frac{2}{3}$, $C_1^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_1^{(1)}$.\n  - $Q_2$: $C_2^{(1)}$ has $1$, $C_2^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_2^{(1)}$.\n  - $Q_3$: $C_3^{(1)}$ has $\\frac{1}{2}$, $C_3^{(2)}$ has $0$ $\\Rightarrow$ rank $1$ is $C_3^{(1)}$.\n\nFor each metric, the reciprocal rank for the correct candidate in each query is $1$ (since the correct candidate is at position $1$). The mean reciprocal rank (MRR) across the $3$ queries for each metric is therefore\n$$\n\\text{MRR} \\;=\\; \\frac{1 + 1 + 1}{3} \\;=\\; 1.\n$$\n\nThe maximum mean reciprocal rank achieved among the three metrics is thus $1$. Rounded to four significant figures, this remains $1.000$.", "answer": "$$\\boxed{1.000}$$", "id": "4832998"}, {"introduction": "While lexical similarity can identify candidate mappings, it cannot determine the precise semantic relationship between two concepts. A true mapping requires analyzing the definitional attributes that constrain what each concept represents. This exercise challenges you to apply principled, set-theoretic criteria to classify the relationship between source and target concepts—as exact, narrower, broader, partial-overlap, or no-map—a crucial skill for ensuring the accuracy and safety of a terminology crosswalk [@problem_id:4832986].", "problem": "In medical informatics, concept mapping between clinical terminologies is governed by principled criteria tied to definitional attributes (for example, axis of disorder versus finding, temporality, laterality, severity, and context). Let each concept denote a set of real-world clinical instances that satisfy all of its definitional constraints. For a source concept $S$ and a target concept $T$, define the following source-to-target match types using set-theoretic relations between the denotations $\\mathrm{den}(S)$ and $\\mathrm{den}(T)$: exact if $\\mathrm{den}(S)=\\mathrm{den}(T)$, narrower-than if $\\mathrm{den}(S)\\subset \\mathrm{den}(T)$, broader-than if $\\mathrm{den}(S)\\supset \\mathrm{den}(T)$, partial-overlap if $\\mathrm{den}(S)\\cap \\mathrm{den}(T)\\neq \\emptyset$ yet neither is a subset of the other, and no-map if $\\mathrm{den}(S)\\cap \\mathrm{den}(T)=\\emptyset$ due to incompatible definitional axes. Use these principled criteria to assign match types to the following $4$ source-target pairs, justifying your assignments by analyzing the definitional attributes that constrain each denotation:\n\n- Pair $1$: Source is Systematized Nomenclature of Medicine Clinical Terms (SNOMED CT) concept $44054006$ “Type $2$ diabetes mellitus (disorder)”. Target is International Classification of Diseases, Tenth Revision, Clinical Modification (ICD-$10$-CM) code E$11.9$ “Type $2$ diabetes mellitus without complications”.\n- Pair $2$: Source is a local laboratory test code “Serum potassium” representing measurement on serum only. Target is Logical Observation Identifiers Names and Codes (LOINC) $2823$-$3$ “Potassium [Moles/volume] in Serum or Plasma”.\n- Pair $3$: Source is SNOMED CT “Left otitis media (disorder)” (laterality constrained to the left ear, temporality unspecified). Target is ICD-$10$-CM “Acute otitis media, unspecified ear” (temporality constrained to acute, laterality unspecified).\n- Pair $4$: Source is SNOMED CT “History of myocardial infarction (situation)” (context axis indicates a past event). Target is ICD-$10$-CM I$21.9$ “Acute myocardial infarction, unspecified” (current acute event).\n\nWhich option correctly assigns source-to-target match types for all $4$ pairs?\n\nA. Pair $1$: broader-than; Pair $2$: narrower-than; Pair $3$: partial-overlap; Pair $4$: no-map\n\nB. Pair $1$: exact; Pair $2$: narrower-than; Pair $3$: narrower-than; Pair $4$: partial-overlap\n\nC. Pair $1$: narrower-than; Pair $2$: broader-than; Pair $3$: exact; Pair $4$: no-map\n\nD. Pair $1$: broader-than; Pair $2$: exact; Pair $3$: partial-overlap; Pair $4$: partial-overlap", "solution": "The problem statement is subjected to validation and is found to be valid. It is scientifically grounded in the principles of medical informatics and formal ontology, well-posed with clear definitions and constraints, and objective in its presentation. The problem provides a sound logical framework and sufficient information to derive a unique solution.\n\nThe problem defines five types of source-to-target concept maps based on the set-theoretic relationship between the denotations of a source concept, $S$, and a target concept, $T$. The denotation, $\\mathrm{den}(X)$, is the set of all real-world instances satisfying the definitional constraints of concept $X$. The definitions are as follows:\n- **Exact:** $\\mathrm{den}(S) = \\mathrm{den}(T)$\n- **Narrower-than:** $\\mathrm{den}(S) \\subset \\mathrm{den}(T)$\n- **Broader-than:** $\\mathrm{den}(S) \\supset \\mathrm{den}(T)$\n- **Partial-overlap:** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) \\neq \\emptyset$, $\\mathrm{den}(S) \\not\\subset \\mathrm{den}(T)$, and $\\mathrm{den}(T) \\not\\subset \\mathrm{den}(S)$\n- **No-map:** $\\mathrm{den}(S) \\cap \\mathrm{den}(T) = \\emptyset$\n\nWe will now analyze each of the $4$ source-target pairs.\n\n**Pair $1$ Analysis:**\n- Source ($S_1$): SNOMED CT $44054006$ “Type $2$ diabetes mellitus (disorder)”. This is a general concept for the disorder. Its definition does not specify the absence or presence of complications. Therefore, $\\mathrm{den}(S_1)$ includes all instances of Type $2$ diabetes, both with and without complications.\n- Target ($T_1$): ICD-$10$-CM E$11.9$ “Type $2$ diabetes mellitus without complications”. The definition of this concept is explicitly restricted to instances of Type $2$ diabetes where complications are not present. Therefore, $\\mathrm{den}(T_1)$ is the set of instances of Type $2$ diabetes without complications.\n- Relationship: The set of clinical instances in $\\mathrm{den}(T_1)$ is a proper subset of the instances in $\\mathrm{den}(S_1)$, since $\\mathrm{den}(S_1)$ also contains instances of Type $2$ diabetes *with* complications. Formally, $\\mathrm{den}(T_1) \\subset \\mathrm{den}(S_1)$, which is equivalent to $\\mathrm{den}(S_1) \\supset \\mathrm{den}(T_1)$.\n- Conclusion: The source-to-target match type is **broader-than**.\n\n**Pair $2$ Analysis:**\n- Source ($S_2$): Local laboratory test code “Serum potassium”. The definitional attribute for the specimen type is constrained to \"serum\" only. Thus, $\\mathrm{den}(S_2)$ is the set of all potassium measurements performed on serum.\n- Target ($T_2$): LOINC $2823$-$3$ “Potassium [Moles/volume] in Serum or Plasma”. The definitional attribute for the specimen type allows for either \"serum\" or \"plasma\". Therefore, $\\mathrm{den}(T_2)$ is the set of all potassium measurements performed on either serum or plasma.\n- Relationship: The set of measurements performed on serum, $\\mathrm{den}(S_2)$, is a proper subset of the measurements performed on serum or plasma, $\\mathrm{den}(T_2)$. Every instance in $\\mathrm{den}(S_2)$ is also in $\\mathrm{den}(T_2)$, but $\\mathrm{den}(T_2)$ also contains instances (measurements on plasma) that are not in $\\mathrm{den}(S_2)$. Formally, $\\mathrm{den}(S_2) \\subset \\mathrm{den}(T_2)$.\n- Conclusion: The source-to-target match type is **narrower-than**.\n\n**Pair $3$ Analysis:**\n- Source ($S_3$): SNOMED CT “Left otitis media (disorder)”. The definitional attributes are Laterality='left' and Temporality='unspecified'. $\\mathrm{den}(S_3)$ contains all instances of otitis media in the left ear, regardless of whether it is acute, chronic, recurrent, etc.\n- Target ($T_3$): ICD-$10$-CM “Acute otitis media, unspecified ear”. The definitional attributes are Temporality='acute' and Laterality='unspecified'. $\\mathrm{den}(T_3)$ contains all instances of acute otitis media, regardless of whether it is in the left ear, right ear, or bilateral.\n- Relationship:\n    - We test for subset relations. Is $\\mathrm{den}(S_3) \\subset \\mathrm{den}(T_3)$? No, because an instance of \"chronic left otitis media\" is in $\\mathrm{den}(S_3)$ but not in $\\mathrm{den}(T_3)$ (since $T_3$ is only 'acute').\n    - Is $\\mathrm{den}(T_3) \\subset \\mathrm{den}(S_3)$? No, because an instance of \"acute right otitis media\" is in $\\mathrm{den}(T_3)$ but not in $\\mathrm{den}(S_3)$ (since $S_3$ is only 'left').\n    - We test for intersection. Is $\\mathrm{den}(S_3) \\cap \\mathrm{den}(T_3) = \\emptyset$? No, because an instance of \"acute left otitis media\" satisfies the constraints of both concepts and is therefore in the intersection.\n- Conclusion: Since the sets have a non-empty intersection, but neither is a subset of the other, the source-to-target match type is **partial-overlap**.\n\n**Pair $4$ Analysis:**\n- Source ($S_4$): SNOMED CT “History of myocardial infarction (situation)”. The \"context\" definitional axis specifies this is a past event. The patient is not currently having a myocardial infarction (MI); they have a history of one. $\\mathrm{den}(S_4)$ is the set of clinical states representing a past, resolved MI.\n- Target ($T_4$): ICD-$10$-CM I$21.9$ “Acute myocardial infarction, unspecified”. The \"context\" axis specifies this is a current, acute event. The patient is actively experiencing an MI. $\\mathrm{den}(T_4)$ is the set of clinical events of a current, acute MI.\n- Relationship: The definitional axis of context (past vs. current) is mutually exclusive. A clinical state cannot simultaneously be \"a history of a past MI\" and \"a current acute MI\". The two sets of instances are disjoint. Formally, $\\mathrm{den}(S_4) \\cap \\mathrm{den}(T_4) = \\emptyset$.\n- Conclusion: The source-to-target match type is **no-map**.\n\nSummary of derived matches:\n- Pair $1$: **broader-than**\n- Pair $2$: **narrower-than**\n- Pair $3$: **partial-overlap**\n- Pair $4$: **no-map**\n\nWe now evaluate the given options:\n\n**A. Pair $1$: broader-than; Pair $2$: narrower-than; Pair $3$: partial-overlap; Pair $4$: no-map**\nThis option's assignments match our derived analysis for all $4$ pairs.\n- Pair $1$: broader-than. Correct.\n- Pair $2$: narrower-than. Correct.\n- Pair $3$: partial-overlap. Correct.\n- Pair $4$: no-map. Correct.\nThis option is **Correct**.\n\n**B. Pair $1$: exact; Pair $2$: narrower-than; Pair $3$: narrower-than; Pair $4$: partial-overlap**\n- Pair $1$ is broader-than, not exact. Incorrect.\n- Pair $3$ is partial-overlap, not narrower-than. Incorrect.\n- Pair $4$ is no-map, not partial-overlap. Incorrect.\nThis option is **Incorrect**.\n\n**C. Pair $1$: narrower-than; Pair $2$: broader-than; Pair $3$: exact; Pair $4$: no-map**\n- Pair $1$ is broader-than, not narrower-than. Incorrect.\n- Pair $2$ is narrower-than, not broader-than. Incorrect.\n- Pair $3$ is partial-overlap, not exact. Incorrect.\nThis option is **Incorrect**.\n\n**D. Pair $1$: broader-than; Pair $2$: exact; Pair $3$: partial-overlap; Pair $4$: partial-overlap**\n- Pair $2$ is narrower-than, not exact. Incorrect.\n- Pair $4$ is no-map, not partial-overlap. Incorrect.\nThis option is **Incorrect**.\n\nOnly option A correctly assigns the match types for all four pairs according to the provided principled criteria.", "answer": "$$\\boxed{A}$$", "id": "4832986"}, {"introduction": "To be useful in real-world health IT systems, conceptual maps must be represented in a standardized, machine-readable format. This final practice bridges the gap between theory and implementation by using the HL7 FHIR standard to create a formal, conditional ConceptMap. You will construct a map where the target code depends on an additional attribute (laterality), learning how complex semantic rules are encoded and executed to support sophisticated data integration tasks [@problem_id:4833007].", "problem": "You are asked to write a complete and runnable program that constructs a Health Level Seven Fast Healthcare Interoperability Resources (HL7 FHIR) ConceptMap instance to map a single local problem list concept to International Classification of Diseases, Tenth Revision, Clinical Modification (ICD-10-CM) codes using an equivalence of type \"narrower\" with a dependsOn constraint on laterality, and then evaluates the correctness of the constructed ConceptMap by running a deterministic test suite. Your program must not read any input and must produce a single line of output as specified at the end.\n\nFoundational base and constraints:\n- Use the core definition that a mapping between terminologies is a binary relation $R \\subseteq S \\times T$, where $S$ is the set of source concepts and $T$ is the set of target concepts. A conditional mapping refines this to a ternary relation $R_{c} \\subseteq S \\times T \\times C$ where $C$ is a set of conditions (e.g., laterality). Resolution of a conditional mapping for a given condition value $c \\in C$ selects those $(s,t,c)$ with matching $c$.\n- Use well-tested invariants from resource modeling: an HL7 FHIR ConceptMap groups mappings by source and target code systems, has per-element mappings from a source code to one or more target codes, and can specify equivalence qualifiers and dependsOn conditions. Treat equivalence \"narrower\" as indicating that the target concept is more specific than the source concept in a subsumption sense.\n\nProgram requirements:\n- Construct exactly one ConceptMap instance (as a native data structure in your language) with the following properties:\n  - The source code system is a local system identified by the Uniform Resource Name \"urn:oid:1.2.3.4.5.6.7.8.9\". The single source code to be mapped is the string \"LPL-001\" (representing a general local problem list concept for knee pain).\n  - The target code system is \"http://hl7.org/fhir/sid/icd-10-cm\".\n  - There must be at least two distinct target mappings (two target codes), each with:\n    - Equivalence set to the literal string \"narrower\".\n    - A dependsOn condition using a property URI equal to the literal string \"http://hl7.org/fhir/StructureDefinition/laterality\", with a system equal to the literal string \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\", and a value equal to one of the literals \"left\" or \"right\". This encodes laterality.\n  - Use the ICD-10-CM code \"M25.561\" for right knee pain and \"M25.562\" for left knee pain as the targets.\n\n- Define a resolution function $f$ that takes as input a source concept code $s$ and a laterality token $\\ell$ and returns the list of applicable target codes by evaluating dependsOn as follows:\n  - Only consider mappings for the source code $s = \\text{\"LPL-001\"}$.\n  - If $\\ell$ equals the literal \"left\", return the list containing exactly the single target code whose dependsOn value equals \"left\".\n  - If $\\ell$ equals the literal \"right\", return the list containing exactly the single target code whose dependsOn value equals \"right\".\n  - If $\\ell$ equals the literal \"bilateral\", return both target codes for \"left\" and \"right\" (justify this by set inclusion: \"bilateral\" implies both laterality conditions hold).\n  - For any other $\\ell$, return the empty list.\n\n- Implement a validator $V$ that returns a boolean indicating whether the ConceptMap instance satisfies all of the following structural constraints:\n  - The resourceType equals the literal \"ConceptMap\".\n  - The group.source equals the literal \"urn:oid:1.2.3.4.5.6.7.8.9\" and group.target equals the literal \"http://hl7.org/fhir/sid/icd-10-cm\".\n  - There is exactly one group.element for source code \"LPL-001\".\n  - Every target mapping for that element has equivalence equal to the literal \"narrower\".\n  - Every target mapping for that element has a dependsOn array with at least one object whose property equals the literal \"http://hl7.org/fhir/StructureDefinition/laterality\", whose system equals the literal \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\", and whose value is one of the literals \"left\" or \"right\".\n\nTest suite:\n- Using your constructed ConceptMap and the resolution function $f$, evaluate the following cases and for each case compute a boolean that is the logical conjunction of the structural validator $V$ and the equality of the resolved codes to the expected list:\n  - Case A (happy path): $\\ell = \\text{\"left\"}$, expected codes [\"M25.562\"].\n  - Case B (happy path): $\\ell = \\text{\"right\"}$, expected codes [\"M25.561\"].\n  - Case C (edge case, bilateral): $\\ell = \\text{\"bilateral\"}$, expected codes [\"M25.561\",\"M25.562\"] ordered ascending lexicographically.\n  - Case D (edge case, unknown): $\\ell = \\text{\"unknown\"}$, expected codes [] (empty list).\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D]. For example, a valid output shape is \"[true,false,true,true]\" provided your language’s boolean literals are lower-case; ensure the exact casing and no extra whitespace beyond commas as produced by your language’s default stringification if applicable. No other text may be printed.", "solution": "The problem is valid. It is a well-posed, scientifically grounded, and formally specified task within the domain of medical informatics. It requires the implementation of a data structure and corresponding algorithms to model and evaluate a conditional terminology mapping, adhering to the principles of the HL7 FHIR standard.\n\nThe solution will be developed in four sequential steps:\n1.  Construction of a data structure representing the HL7 FHIR `ConceptMap`.\n2.  Implementation of a validator function, $V$, to verify the structural integrity of the `ConceptMap`.\n3.  Implementation of a resolution function, $f$, to perform the conditional mapping.\n4.  Execution of a deterministic test suite to evaluate the correctness of the entire implementation.\n\n**Conceptual Framework**\n\nThe problem defines a mapping as a binary relation $R \\subseteq S \\times T$, where $S$ is a set of source concepts and $T$ is a set of target concepts. For this problem, the mapping is conditional, modeled as a ternary relation $R_c \\subseteq S \\times T \\times C$, where $C$ represents a set of conditions. The specific sets are:\n- Source concept set: $S = \\{\\text{\"LPL-001\"}\\}$.\n- Target concept set: $T = \\{\\text{\"M25.561\"}, \\text{\"M25.562\"}\\}$.\n- Condition set $C$: The conditions are based on the property of laterality. We can represent a condition as a tuple $(p, v)$ where $p$ is the property and $v$ is the value. The relevant conditions are $(\\text{\"laterality\"}, \\text{\"left\"})$ and $(\\text{\"laterality\"}, \\text{\"right\"})$.\n\nThe `ConceptMap` resource in FHIR is designed to represent such relations. A `group` element defines the source ($S$) and target ($T$) code systems. Within a `group`, `element` structures link a specific source code $s \\in S$ to one or more `target` mappings. Each `target` contains a target code $t \\in T$ and can specify conditions under which the mapping is valid, using the `dependsOn` element, which instantiates the condition set $C$.\n\n**Step 1: `ConceptMap` Data Structure Construction**\n\nA Python dictionary will be used to model the `ConceptMap` resource. This structure will strictly follow the specified constraints. It will have a `resourceType` of `\"ConceptMap\"`. It will contain a single `group` that specifies the `source` system URI as `\"urn:oid:1.2.3.4.5.6.7.8.9\"` and the `target` system URI as `\"http://hl7.org/fhir/sid/icd-10-cm\"`. This `group` will contain a single `element` for the source code `\"LPL-001\"`. This `element` will, in turn, contain two `target` mappings.\n\nEach `target` mapping will have an `equivalence` of `\"narrower\"`, signifying that the target ICD-10-CM code is more specific than the general source code. The conditionality is encoded in the `dependsOn` list.\n- The first target maps to code `\"M25.561\"` (right knee pain) and has a `dependsOn` condition where the `property` is `\"http://hl7.org/fhir/StructureDefinition/laterality\"`, the `system` is `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`, and the `value` is `\"right\"`.\n- The second target maps to code `\"M25.562\"` (left knee pain) with a `dependsOn` condition for a `value` of `\"left\"`.\n\n**Step 2: Validator Function ($V$) Implementation**\n\nThe validator function, $V$, will accept the `ConceptMap` dictionary and return a Boolean value. It will systematically check for the presence and correctness of all required structural elements. The checks are:\n1. The top-level `resourceType` must be `\"ConceptMap\"`.\n2. The structure must contain a `group` list with exactly one element.\n3. This `group` element's `source` property must be `\"urn:oid:1.2.3.4.5.6.7.8.9\"`, and its `target` must be `\"http://hl7.org/fhir/sid/icd-10-cm\"`.\n4. The `group` must contain an `element` list with exactly one element.\n5. This `element`'s `code` must be `\"LPL-001\"`.\n6. This `element` must contain a `target` list with at least two elements.\n7. For every `target` in this list:\n   a. The `equivalence` must be `\"narrower\"`.\n   b. It must have a `dependsOn` list with at least one element.\n   c. At least one element in `dependsOn` must have `property` equal to `\"http://hl7.org/fhir/StructureDefinition/laterality\"`, `system` equal to `\"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"`, and a `value` that is either `\"left\"` or `\"right\"`.\n\nA robust implementation will use safe dictionary access (e.g., the `.get()` method) to prevent errors if keys are missing, returning `False` in such cases.\n\n**Step 3: Resolution Function ($f$) Implementation**\n\nThe resolution function, $f(s, \\ell)$, will take a source code $s$ and a laterality token $\\ell$ as input.\n1. The function will first locate the `element` corresponding to the source code $s = \\text{\"LPL-001\"}$ within the `ConceptMap`. If no such element exists, it returns an empty list.\n2. It then processes the laterality token $\\ell$:\n   - If $\\ell$ is `\"left\"` or `\"right\"`, the function iterates through the `target` mappings. For each `target`, it inspects the `value` of its `dependsOn` element. If the `value` matches $\\ell$, the corresponding `target.code` is added to the result list.\n   - If $\\ell$ is `\"bilateral\"`, this is interpreted as a request for all codes that satisfy either a `\"left\"` or `\"right\"` condition. The function collects the codes for both. This logic aligns with the concept that a bilateral condition subsumes both unilateral conditions.\n   - For any other value of $\\ell$ (e.g., `\"unknown\"`), no conditions match, and the function returns an empty list.\n3. The function returns the list of collected target codes.\n\n**Step 4: Test Suite Execution and Final Output**\n\nThe final part of the program orchestrates the execution of the four specified test cases. For each case (A, B, C, D):\n- The constructed `ConceptMap` is first validated by calling the validator function $V$.\n- The resolution function $f$ is called with the source code `\"LPL-001\"` and the laterality token for that case.\n- For Case C (`\"bilateral\"`), the list of codes returned by $f$ is sorted lexicographically to ensure a deterministic comparison against the expected sorted list `[\"M25.561\", \"M25.562\"]`.\n- The final Boolean result for the case is the logical conjunction of the validator's result and the equality of the function's output with the expected list of codes.\n- The four Boolean results are collected into a list. This list is then converted to the required string format `[true,true,true,true]`, ensuring boolean literals are lowercase, and printed as the sole output.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Constructs, validates, and tests an HL7 FHIR ConceptMap for conditional mapping.\n    \"\"\"\n\n    # Step 1: Construct the ConceptMap data structure as a Python dictionary.\n    concept_map = {\n        \"resourceType\": \"ConceptMap\",\n        \"group\": [\n            {\n                \"source\": \"urn:oid:1.2.3.4.5.6.7.8.9\",\n                \"target\": \"http://hl7.org/fhir/sid/icd-10-cm\",\n                \"element\": [\n                    {\n                        \"code\": \"LPL-001\",\n                        \"target\": [\n                            {\n                                \"code\": \"M25.561\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"right\"\n                                    }\n                                ]\n                            },\n                            {\n                                \"code\": \"M25.562\",\n                                \"equivalence\": \"narrower\",\n                                \"dependsOn\": [\n                                    {\n                                        \"property\": \"http://hl7.org/fhir/StructureDefinition/laterality\",\n                                        \"system\": \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\",\n                                        \"value\": \"left\"\n                                    }\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    }\n\n    def validator(cm):\n        \"\"\"\n        Step 2: Implement the validator function V.\n        Validates the structural integrity of the ConceptMap instance.\n        \"\"\"\n        try:\n            # Check resourceType\n            if cm.get(\"resourceType\") != \"ConceptMap\":\n                return False\n\n            # Check group structure\n            groups = cm.get(\"group\", [])\n            if len(groups) != 1:\n                return False\n            group = groups[0]\n\n            if group.get(\"source\") != \"urn:oid:1.2.3.4.5.6.7.8.9\":\n                return False\n            if group.get(\"target\") != \"http://hl7.org/fhir/sid/icd-10-cm\":\n                return False\n\n            # Check element structure\n            elements = group.get(\"element\", [])\n            if len(elements) != 1:\n                return False\n            element = elements[0]\n\n            if element.get(\"code\") != \"LPL-001\":\n                return False\n            \n            targets = element.get(\"target\", [])\n            if len(targets)  2:  # at least two distinct target mappings\n                return False\n\n            # Check each target mapping\n            for target in targets:\n                if target.get(\"equivalence\") != \"narrower\":\n                    return False\n                \n                depends_on_list = target.get(\"dependsOn\", [])\n                if not depends_on_list:\n                    return False\n\n                valid_dependency_found = False\n                for dep in depends_on_list:\n                    prop = dep.get(\"property\") == \"http://hl7.org/fhir/StructureDefinition/laterality\"\n                    sys = dep.get(\"system\") == \"http://hl7.org/fhir/CodeSystem/bodysite-laterality\"\n                    val = dep.get(\"value\") in [\"left\", \"right\"]\n                    if prop and sys and val:\n                        valid_dependency_found = True\n                        break\n                if not valid_dependency_found:\n                    return False\n\n        except (TypeError, KeyError, IndexError):\n            return False # Malformed structure\n\n        return True\n\n    def resolution_function(cm, source_code, laterality_token):\n        \"\"\"\n        Step 3: Implement the resolution function f.\n        Resolves target codes based on source code and a laterality condition.\n        \"\"\"\n        if source_code != \"LPL-001\":\n            return []\n\n        resolved_codes = []\n        try:\n            element = next((el for el in cm[\"group\"][0][\"element\"] if el[\"code\"] == source_code), None)\n            if not element:\n                return []\n            \n            targets_to_check = []\n            if laterality_token == \"left\":\n                targets_to_check = [\"left\"]\n            elif laterality_token == \"right\":\n                targets_to_check = [\"right\"]\n            elif laterality_token == \"bilateral\":\n                targets_to_check = [\"left\", \"right\"]\n            \n            for target in element[\"target\"]:\n                for dep in target[\"dependsOn\"]:\n                    if dep.get(\"value\") in targets_to_check:\n                        resolved_codes.append(target[\"code\"])\n                        break\n        except (KeyError, IndexError, TypeError):\n            return []\n            \n        return resolved_codes\n\n    # Step 4: Define and run the test suite.\n    test_cases = [\n        # Case A (happy path)\n        {\"laterality\": \"left\", \"expected\": [\"M25.562\"]},\n        # Case B (happy path)\n        {\"laterality\": \"right\", \"expected\": [\"M25.561\"]},\n        # Case C (edge case, bilateral)\n        {\"laterality\": \"bilateral\", \"expected\": [\"M25.561\", \"M25.562\"]},\n        # Case D (edge case, unknown)\n        {\"laterality\": \"unknown\", \"expected\": []},\n    ]\n\n    results = []\n    \n    # Run validator once, as it's static for all cases.\n    is_valid = validator(concept_map)\n\n    for case in test_cases:\n        laterality = case[\"laterality\"]\n        expected = case[\"expected\"]\n\n        # Call resolution function\n        resolved_codes = resolution_function(concept_map, \"LPL-001\", laterality)\n        \n        # Sort results for deterministic comparison, especially for 'bilateral'\n        resolved_codes.sort()\n        expected.sort()\n\n        # Compare results\n        resolution_correct = (resolved_codes == expected)\n        \n        # Final result for the case is the conjunction of validity and correct resolution\n        case_result = is_valid and resolution_correct\n        results.append(str(case_result).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4833007"}]}