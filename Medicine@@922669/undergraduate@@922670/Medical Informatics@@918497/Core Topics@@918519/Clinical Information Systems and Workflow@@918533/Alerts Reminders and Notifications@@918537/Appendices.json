{"hands_on_practices": [{"introduction": "Clinical Decision Support (CDS) alerts are designed to improve patient safety, but they often suffer from a critical flaw: a high rate of false positives. This leads to \"alert fatigue,\" where clinicians, overwhelmed by irrelevant notifications, may start to ignore them. This exercise explores the statistical foundation of this widespread problem [@problem_id:4822027]. By applying Bayes' theorem, you will calculate the Positive Predictive Value ($PPV$) of a hypothetical alert to understand how even a seemingly accurate test can be unreliable in practice, providing a quantitative basis for the challenge of designing effective clinical notifications.", "problem": "A hospital deploys a Clinical Decision Support (CDS) alert within its Electronic Health Record (EHR) to notify clinicians of a potentially actionable condition, denoted $D$. In the screened population, the base rate (prevalence) of $D$ is $P(D)=0.05$. The alert has sensitivity $0.9$ and specificity $0.8$, where sensitivity is defined as the probability that the alert fires given that the patient truly has $D$, and specificity is defined as the probability that the alert does not fire given that the patient does not have $D$. Using fundamental probability definitions and Bayes' theorem, compute the Positive Predictive Value (PPV), defined as the probability that a patient truly has $D$ given that the alert fires. Express the PPV as a decimal rounded to four significant figures. After computing the PPV, explain in words, based on first principles, what this value implies for perceived alert reliability and the potential for alert fatigue in clinical practice. Your final numeric answer must be the PPV only (no units).", "solution": "The problem asks for the calculation of the Positive Predictive Value (PPV) of a Clinical Decision Support (CDS) alert and an explanation of its implications. The problem is well-posed, scientifically grounded in probability theory and medical informatics, and contains all necessary information for a unique solution.\n\nFirst, we must formalize the given information using standard probabilistic notation. Let $D$ be the event that a patient has the condition, and let $A$ be the event that the CDS alert fires. The complementary events are $D^c$ (the patient does not have the condition) and $A^c$ (the alert does not fire).\n\nThe givens are:\n1.  The base rate, or prevalence, of the condition: $P(D) = 0.05$.\n2.  The sensitivity of the alert, which is the probability that the alert fires given the patient has the condition: $P(A|D) = 0.9$.\n3.  The specificity of the alert, which is the probability that the alert does not fire given the patient does not have the condition: $P(A^c|D^c) = 0.8$.\n\nFrom these givens, we can derive two additional probabilities that are necessary for the calculation.\nThe probability of a patient not having the condition is the complement of the prevalence:\n$$P(D^c) = 1 - P(D) = 1 - 0.05 = 0.95$$\nThe probability of the alert firing given that the patient does not have the condition (the false positive rate) is the complement of the specificity:\n$$P(A|D^c) = 1 - P(A^c|D^c) = 1 - 0.8 = 0.2$$\n\nThe problem requires us to compute the Positive Predictive Value (PPV), which is defined as the probability that a patient truly has the condition $D$ given that the alert has fired, $A$. In probabilistic terms, we need to calculate $P(D|A)$.\n\nWe will use Bayes' theorem to find this conditional probability:\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A)}$$\n\nThe denominator, $P(A)$, represents the total probability of the alert firing. It can be calculated using the law of total probability, by summing the probabilities of the alert firing for patients with the condition (true positives) and for patients without the condition (false positives):\n$$P(A) = P(A \\cap D) + P(A \\cap D^c)$$\nUsing the definition of conditional probability, $P(X \\cap Y) = P(X|Y)P(Y)$, we can expand this to:\n$$P(A) = P(A|D)P(D) + P(A|D^c)P(D^c)$$\n\nSubstituting this expansion back into Bayes' theorem gives the full formula for PPV:\n$$P(D|A) = \\frac{P(A|D) P(D)}{P(A|D)P(D) + P(A|D^c)P(D^c)}$$\n\nNow, we can substitute the numerical values into this formula.\nThe numerator is the probability of a true positive event (the patient has the condition AND the alert fires):\n$$\\text{Numerator} = P(A|D)P(D) = (0.9) \\times (0.05) = 0.045$$\nThe first term in the denominator is the same as the numerator:\n$$P(A|D)P(D) = 0.045$$\nThe second term in the denominator is the probability of a false positive event (the patient does not have the condition AND the alert fires):\n$$P(A|D^c)P(D^c) = (0.2) \\times (0.95) = 0.190$$\nThe total probability of the alert firing is the sum of these two terms:\n$$P(A) = 0.045 + 0.190 = 0.235$$\nFinally, we can calculate the PPV:\n$$P(D|A) = \\frac{0.045}{0.235} \\approx 0.19148936...$$\n\nThe problem requires the result to be rounded to four significant figures.\n$$PPV \\approx 0.1915$$\n\nThe computed Positive Predictive Value is $0.1915$. This value implies that when a clinician sees this specific alert, the probability that the patient actually has the condition $D$ is only $19.15\\%$. Conversely, it means that $1 - 0.1915 = 0.8085$, or $80.85\\%$ of the time the alert fires, it is a false alarm (i.e., the patient does not have condition $D$).\n\nThis very low PPV has significant implications for clinical practice.\nFor perceived alert reliability, clinicians are likely to view the alert as highly unreliable. An instrument that is wrong more than $4$ out of $5$ times will not inspire confidence. This erodes the trust clinicians place in the CDS system.\n\nThis poor reliability is a direct cause of alert fatigue. Alert fatigue is the phenomenon where clinicians become desensitized to safety alerts and notifications after being exposed to a high volume of clinically irrelevant or false alarms. Experiencing frequent, low-value interruptions distracts from patient care and leads clinicians to develop a habit of ignoring or reflexively overriding alerts without due consideration. This behavior, while a rational response to an overabundance of \"noise\", is dangerous because it can lead to the dismissal of a rare but critically important true positive alert, thereby undermining the primary safety goal of the CDS. The root cause of the low PPV in this scenario is the combination of a relatively low specificity ($0.8$, leading to a high false positive rate of $0.2$) and a low prevalence of the disease ($0.05$). Even with high sensitivity, a large number of healthy individuals subjected to a test with imperfect specificity will generate a volume of false positives that overwhelms the true positives from the smaller diseased population.", "answer": "$$\n\\boxed{0.1915}\n$$", "id": "4822027"}, {"introduction": "Moving from statistical theory to practical application, building effective alerts requires mastering the technical standards that govern health data exchange. This exercise will guide you through creating a real-time notification using Health Level 7 (HL7) Fast Healthcare Interoperability Resources (FHIR), the leading standard for modern healthcare applications [@problem_id:4821956]. You will specify a FHIR `Subscription` to monitor for clinically significant lab results, translating a medical rule into the precise, machine-readable format required for interoperable systems.", "problem": "You are designing an alerting mechanism in Health Level 7 (HL7) Fast Healthcare Interoperability Resources (FHIR) that notifies a downstream system when a laboratory Observation indicates serum potassium above a clinically significant threshold. Use the following foundational definitions as the base for your derivation and algorithmic specification:\n\n- HL7 FHIR R4 Subscription uses a search criteria string applied to a resource type, following FHIR search semantics. The Observation code is a token search parameter, which matches exactly on the combination of code system and code. The standard LOINC (Logical Observation Identifiers Names and Codes) system is denoted by the Uniform Resource Identifier (URI) \"http://loinc.org\".\n- The FHIR quantity search parameter for value, named \"value-quantity\" on Observation, uses a comparator prefix and a quantity triad \"value|system|code\". The Unified Code for Units of Measure (UCUM) system is denoted by the URI \"http://unitsofmeasure.org\", and the code for millimoles per liter is \"mmol/L\". For the comparator prefix \"gt\", the semantics are strictly greater than. Therefore, \"gt$5.5$\" means \"$>$ $5.5$\".\n- FHIR search matching for quantity using the form \"value-quantity=[comparator][number]|[system]|[code]\" requires exact equality on the unit system and unit code to be considered comparable; do not perform unit conversions. If either the system or the code does not match exactly, the quantity does not match.\n\nTask requirements:\n\n1. Specify precisely the HL7 FHIR R4 Subscription search criteria string that monitors Observation resources for serum or plasma potassium with the LOINC code \"2823-3\" and a value quantity strictly greater than $5.5$ millimoles per liter. Use the above semantics with exact system and code matching. Then, specify a channel configuration that uses a Representational State Transfer (REST) hook with JavaScript Object Notation (JSON) payload delivered via Hypertext Transfer Protocol Secure (HTTPS). You must define the channel type, endpoint, and payload content type.\n2. Implement a program that evaluates whether each of the following pseudo-Observation inputs would trigger delivery under the Subscription derived in part 1. Each input is a tuple of five fields: (code_system, code, value, unit_system, unit_code). A case triggers if and only if all of the following are true:\n   - code_system equals \"http://loinc.org\" and code equals \"2823-3\",\n   - value is a real number strictly greater than $5.5$,\n   - unit_system equals \"http://unitsofmeasure.org\" and unit_code equals \"mmol/L\".\n   If any field is missing or does not meet the condition, the case does not trigger.\n\nUse the following test suite of cases:\n- Case A: (\"http://loinc.org\", \"2823-3\", $6.2$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case B: (\"http://loinc.org\", \"2823-3\", $5.5$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case C: (\"http://loinc.org\", \"2823-3\", $4.7$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case D: (\"http://loinc.org\", \"2951-2\", $6.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case E: (\"http://loinc.org\", \"2823-3\", $6.0$, \"http://unitsofmeasure.org\", \"meq/L\")\n- Case F: (\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\") where null indicates no numeric value is present,\n- Case G: (\"http://example.org/loinc\", \"2823-3\", $7.1$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case H: (\"http://loinc.org\", \"2823-3\", $-1.0$, \"http://unitsofmeasure.org\", \"mmol/L\")\n- Case I: (\"http://loinc.org\", \"2823-3\", $5.5000001$, \"http://unitsofmeasure.org\", \"mmol/L\")\n\nFinal output format:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[true,false,true]\"). The booleans should be printed using the standard Python capitalization \"True\" and \"False\".", "solution": "The problem is valid as it is scientifically grounded in the domain of medical informatics and the HL7 FHIR standard, is well-posed with clear and unambiguous requirements, and is objective in its formulation. All necessary definitions, constants, and conditions are provided to derive a unique and verifiable solution.\n\nThe problem is addressed in two parts as specified.\n\nPart 1: Specification of the HL7 FHIR Subscription\n\nThe objective is to create a subscription that triggers for a specific type of `Observation` resource. This requires defining a set of search criteria that precisely select the target resources. The HL7 FHIR R4 search framework uses a combination of parameter-value pairs, joined by the ampersand character (`&`), appended to the resource type.\n\nThe required subscription must monitor `Observation` resources, so the criteria string will begin with `Observation?`.\n\nCriterion 1: The Observation Code\nThe first condition is for the observation code, which must be the LOINC code for serum or plasma potassium, `\"2823-3\"`. The problem states that the `code` search parameter is of type `token` and matches on both the code system and the code value. The specified syntax for a token search is `[parameter]=[system]|[code]`.\n\n-   Parameter Name: `code`\n-   Code System URI: `http://loinc.org`\n-   Code Value: `2823-3`\n\nCombining these according to the specified format yields the first part of the search string:\n`code=http://loinc.org|2823-3`\n\nCriterion 2: The Observation Value\nThe second condition is for the observation's value, which must be strictly greater than $5.5$ millimoles per liter. This requires the use of the `value-quantity` search parameter. The problem specifies the format for a quantity search as `[parameter]=[comparator][number]|[system]|[code]`. It also mandates that the search is strict, with no unit conversions, requiring an exact match on the unit system and unit code.\n\n-   Parameter Name: `value-quantity`\n-   Comparator for \"strictly greater than\": `gt`\n-   Numeric Value: $5.5$\n-   Unit System URI (UCUM): `http://unitsofmeasure.org`\n-   Unit Code: `mmol/L`\n\nCombining these elements yields the second part of the search string:\n`value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\nFinal Search Criteria String\nThe complete `criteria` string for the `Subscription` resource is formed by concatenating the resource type with the two criteria, joined by an `&`.\n\n`Observation?code=http://loinc.org|2823-3&value-quantity=gt5.5|http://unitsofmeasure.org|mmol/L`\n\nChannel Configuration\nThe problem further requires specifying the delivery channel for the notification. This is configured in the `channel` element of the `Subscription` resource. The requirements are a REST hook, JSON payload, and an HTTPS endpoint.\n\n-   `channel.type`: As specified, for a REST hook, the value is `rest-hook`.\n-   `channel.endpoint`: This must be a secure URL where the notification will be sent. A representative placeholder will be used, such as `https://downstream-system.example.com/fhir/receive`.\n-   `channel.payload`: For a JSON payload representing a FHIR resource, the standard MIME type is `application/fhir+json`.\n\nThese three specifications define the delivery mechanism for the subscription.\n\nPart 2: Algorithmic Evaluation of Pseudo-Observation Inputs\n\nThe task is to create a program that implements the logic defined by the subscription criteria. A pseudo-observation triggers a notification if and only if all specified conditions are met. The input for each case is a tuple: `(code_system, code, value, unit_system, unit_code)`.\n\nThe logic for a trigger is the conjunction of five conditions:\n1.  The `code_system` must be exactly equal to the string `\"http://loinc.org\"`.\n2.  The `code` must be exactly equal to the string `\"2823-3\"`.\n3.  The `value` must be a numeric type and must be strictly greater than $5.5$. A `null` or non-numeric value fails this condition.\n4.  The `unit_system` must be exactly equal to the string `\"http://unitsofmeasure.org\"`.\n5.  The `unit_code` must be exactly equal to the string `\"mmol/L\"`.\n\nThis logic is applied to each test case:\n\n-   Case A: `(\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   All conditions are met. `code_system`, `code`, `unit_system`, and `unit_code` match. The value $6.2$ is numeric and $6.2 > 5.5$.\n    -   Result: `True`.\n\n-   Case B: `(\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The value condition fails. $5.5$ is not strictly greater than $5.5$.\n    -   Result: `False`.\n\n-   Case C: `(\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The value condition fails. $4.7$ is not greater than $5.5$.\n    -   Result: `False`.\n\n-   Case D: `(\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The `code` condition fails. `\"2951-2\"` is not equal to `\"2823-3\"`.\n    -   Result: `False`.\n\n-   Case E: `(\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\")`\n    -   The `unit_code` condition fails. `\"meq/L\"` is not equal to `\"mmol/L\"`.\n    -   Result: `False`.\n\n-   Case F: `(\"http://loinc.org\", \"2823-3\", null, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The value condition fails. A `null` value is not numeric and cannot be compared.\n    -   Result: `False`.\n\n-   Case G: `(\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The `code_system` condition fails. `\"http://example.org/loinc\"` is not equal to `\"http://loinc.org\"`.\n    -   Result: `False`.\n\n-   Case H: `(\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   The value condition fails. While numeric, $-1.0$ is not greater than $5.5$. The physical impossibility of a negative concentration is irrelevant to the logical evaluation.\n    -   Result: `False`.\n\n-   Case I: `(\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\")`\n    -   All conditions are met. The value $5.5000001$ is strictly greater than $5.5$.\n    -   Result: `True`.\n\nThe program below will implement this evaluation logic directly and produce the specified output format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Evaluates a series of pseudo-Observation inputs against HL7 FHIR\n    subscription criteria for hyperkalemia alerts.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (code_system, code, value, unit_system, unit_code)\n    # The 'null' value from the problem is represented as Python's None.\n    test_cases = [\n        (\"http://loinc.org\", \"2823-3\", 6.2, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case A\n        (\"http://loinc.org\", \"2823-3\", 5.5, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case B\n        (\"http://loinc.org\", \"2823-3\", 4.7, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case C\n        (\"http://loinc.org\", \"2951-2\", 6.0, \"http://unitsofmeasure.org\", \"mmol/L\"),  # Case D\n        (\"http://loinc.org\", \"2823-3\", 6.0, \"http://unitsofmeasure.org\", \"meq/L\"),   # Case E\n        (\"http://loinc.org\", \"2823-3\", None, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case F\n        (\"http://example.org/loinc\", \"2823-3\", 7.1, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case G\n        (\"http://loinc.org\", \"2823-3\", -1.0, \"http://unitsofmeasure.org\", \"mmol/L\"), # Case H\n        (\"http://loinc.org\", \"2823-3\", 5.5000001, \"http://unitsofmeasure.org\", \"mmol/L\") # Case I\n    ]\n\n    # Define the target values based on the subscription criteria.\n    TARGET_CODE_SYSTEM = \"http://loinc.org\"\n    TARGET_CODE = \"2823-3\"\n    VALUE_THRESHOLD = 5.5\n    TARGET_UNIT_SYSTEM = \"http://unitsofmeasure.org\"\n    TARGET_UNIT_CODE = \"mmol/L\"\n\n    results = []\n    for case in test_cases:\n        code_system, code, value, unit_system, unit_code = case\n\n        # A case triggers if and only if all conditions are met.\n        # This is a direct implementation of the logical AND of all checks.\n\n        # 1. Check if a numeric value is present and if it's strictly greater than the threshold.\n        #    Python's isinstance handles both int and float.\n        #    A None value will cause the first part of this AND to be false.\n        value_is_valid = isinstance(value, (int, float)) and value > VALUE_THRESHOLD\n\n        # 2. Check for exact matches on code system, code, unit system, and unit code.\n        code_system_matches = (code_system == TARGET_CODE_SYSTEM)\n        code_matches = (code == TARGET_CODE)\n        unit_system_matches = (unit_system == TARGET_UNIT_SYSTEM)\n        unit_code_matches = (unit_code == TARGET_UNIT_CODE)\n\n        # 3. The final result is the logical conjunction of all conditions.\n        trigger = (\n            code_system_matches and\n            code_matches and\n            value_is_valid and\n            unit_system_matches and\n            unit_code_matches\n        )\n        results.append(trigger)\n\n    # Final print statement in the exact required format.\n    # The default string representation of Python's boolean is \"True\" and \"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4821956"}, {"introduction": "Effective clinical alert systems must be robust enough to handle the realities of messy, incomplete data. A simple binary (true/false) evaluation of an alert trigger can fail or produce misleading results when a necessary data point, like a lab value, is missing. This practice introduces a more sophisticated approach using a three-valued logic system to explicitly manage uncertainty [@problem_id:4822035]. By formalizing states for 'positive,' 'negative,' and 'unknown,' you will learn how to build more resilient alert logic that behaves predictably and safely, even when faced with missing information.", "problem": "An Electronic Health Record (EHR) alert must evaluate laboratory triggers in the presence of missing data. The system must distinguish three states: positive, negative, and unknown. Formalize a three-valued logic for a trigger that combines multiple laboratory conditions, and compute how this logic affects alert firing under two policies.\n\nFundamental base to use:\n- Three-valued semantic domain with values: positive, negative, unknown, denoted by $P$, $N$, and $U$, respectively.\n- Deterministic threshold evaluation for a single laboratory value $x$ against a threshold $t$ under relations $\\ge$ or $\\le$, defined as: if $x$ is present, then decide $P$ or $N$ by comparing $x$ to $t$; if $x$ is missing, return $U$.\n- Strong three-valued logic (Kleene semantics) for connectives on $\\{P,N,U\\}$:\n  - Negation: $\\lnot P = N$, $\\lnot N = P$, $\\lnot U = U$.\n  - Conjunction: $P \\land P = P$, $N \\land v = N$ for any $v \\in \\{P,N,U\\}$, $v \\land N = N$, $P \\land U = U$, $U \\land P = U$, $U \\land U = U$.\n  - Disjunction: $P \\lor v = P$ for any $v \\in \\{P,N,U\\}$, $v \\lor P = P$, $N \\lor N = N$, $N \\lor U = U$, $U \\lor N = U$, $U \\lor U = U$.\n\nAlert expression to evaluate:\n- Define three atomic triggers $A$, $B$, and $C$ based on thresholded laboratory values:\n  - $A$ is the three-valued result of testing $x_A$ against threshold $t_A$ under relation $\\ge$.\n  - $B$ is the three-valued result of testing $x_B$ against threshold $t_B$ under relation $\\ge$.\n  - $C$ is the three-valued result of testing $x_C$ against threshold $t_C$ under relation $\\le$.\n- The composite trigger is $E = A \\lor (B \\land C)$ evaluated under the strong three-valued logic.\n\nAlert firing policies:\n- Strict policy $S$: fire if and only if $E = P$.\n- Cautious policy $C$: fire if $E = P$ or $E = U$.\n\nInteger encoding for output:\n- Use the mapping $m(P) = 1$, $m(N) = 0$, $m(U) = -1$.\n\nYour program must:\n1. Implement the three-valued threshold evaluation for $A$, $B$, and $C$, and the strong three-valued logic for $\\lnot$, $\\land$, and $\\lor$.\n2. Compute $E$ for each test case and then compute the strict firing $S$ and cautious firing $C$ decisions.\n3. Produce a single line of output containing a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of the form $[m(E), S, C]$.\n\nThresholds:\n- $t_A = 5.5$, $t_B = 1.5$, $t_C = 60$.\n\nTest suite (each test case provides the tuple $(x_A, x_B, x_C)$ where a missing value is indicated by the word \"None\"):\n- Case $1$: $(5.0, 1.2, 70)$.\n- Case $2$: $(5.6, 1.0, 90)$.\n- Case $3$: $(4.0, 2.0, 40)$.\n- Case $4$: $(4.0, 2.2, 80)$.\n- Case $5$: $(\\text{None}, 2.0, 40)$.\n- Case $6$: $(\\text{None}, \\text{None}, \\text{None})$.\n- Case $7$: $(5.5, 1.5, 60)$.\n- Case $8$: $(4.5, \\text{None}, 50)$.\n\nFinal output format:\n- A single line: a comma-separated list enclosed in square brackets, where each element is a list $[m(E), S, C]$ for the corresponding test case, for example, $[[1,\\mathrm{True},\\mathrm{True}],[0,\\mathrm{False},\\mathrm{False}],\\dots]$.", "solution": "The problem requires the formalization and application of a three-valued logic system to evaluate a medical alert trigger in the presence of missing laboratory data. The solution involves defining the logical framework, evaluating a composite logical expression for several test cases, and determining alert firing decisions based on two distinct policies.\n\nFirst, we establish the mathematical foundations of the system. The semantic domain consists of three logical values: positive ($P$), negative ($N$), and unknown ($U$). These values are manipulated using strong three-valued logic, also known as Kleene's $K_3$ logic. The behavior of the conjunction ($\\land$) and disjunction ($\\lor$) operators is defined by the following truth tables:\n\n**Conjunction ($v_1 \\land v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\land & P & N & U \\\\\n\\hline\nP & P & N & U \\\\\nN & N & N & N \\\\\nU & U & N & U\n\\end{array}\n$$\n\n**Disjunction ($v_1 \\lor v_2$)**\n$$\n\\begin{array}{c|ccc}\n\\lor & P & N & U \\\\\n\\hline\nP & P & P & P \\\\\nN & P & N & U \\\\\nU & P & U & U\n\\end{array}\n$$\n\nAn important property of this logic is the behavior of $N$ in conjunctions and $P$ in disjunctions. A single $N$ operand is sufficient to make a conjunction $N$ ($N$ is \"dominant\" or \"absorbing\" for $\\land$). Similarly, a single $P$ operand is sufficient to make a disjunction $P$ ($P$ is dominant for $\\lor$). The value $U$ arises when the outcome cannot be determined from the available non-unknown values.\n\nThe problem defines three atomic triggers, $A$, $B$, and $C$, based on laboratory values $x_A$, $x_B$, and $x_C$ and their respective thresholds $t_A$, $t_B$, and $t_C$.\n-   $t_A = 5.5$\n-   $t_B = 1.5$\n-   $t_C = 60$\n\nThe evaluation of each atomic trigger is as follows:\n1.  Trigger $A$ evaluates to $P$ if $x_A \\ge 5.5$, $N$ if $x_A < 5.5$, and $U$ if $x_A$ is missing.\n2.  Trigger $B$ evaluates to $P$ if $x_B \\ge 1.5$, $N$ if $x_B < 1.5$, and $U$ if $x_B$ is missing.\n3.  Trigger $C$ evaluates to $P$ if $x_C \\le 60$, $N$ if $x_C > 60$, and $U$ if $x_C$ is missing.\n\nThese atomic triggers are combined into a single composite expression, $E$:\n$$\nE = A \\lor (B \\land C)\n$$\nThe evaluation of this expression follows the order of operations, with the conjunction in parentheses evaluated first.\n\nFinally, two alert firing policies are defined based on the resulting value of $E$:\n-   **Strict Policy ($S$)**: The alert fires if and only if $E = P$.\n-   **Cautious Policy ($C$)**: The alert fires if $E = P$ or $E = U$.\n\nThe final output for each case requires mapping the logical value of $E$ to an integer code: $m(P) = 1$, $m(N) = 0$, $m(U) = -1$. The decisions for the strict ($S$) and cautious ($C$) policies are represented as Boolean values, `True` or `False`.\n\nLet us demonstrate the evaluation process with two representative test cases.\n\n**Case 4: Input $(x_A, x_B, x_C) = (4.0, 2.2, 80)$**\nThis case has no missing data.\n\n1.  **Evaluate atomic triggers**:\n    -   $A$: $x_A = 4.0$. The condition is $4.0 \\ge 5.5$, which is false. Thus, $A = N$.\n    -   $B$: $x_B = 2.2$. The condition is $2.2 \\ge 1.5$, which is true. Thus, $B = P$.\n    -   $C$: $x_C = 80$. The condition is $80 \\le 60$, which is false. Thus, $C = N$.\n\n2.  **Evaluate the sub-expression $(B \\land C)$**:\n    -   We compute $P \\land N$. From the conjunction table, $P \\land N = N$.\n\n3.  **Evaluate the full expression $E = A \\lor (B \\land C)$**:\n    -   We compute $N \\lor N$. From the disjunction table, $N \\lor N = N$. So, $E=N$.\n\n4.  **Determine policies and final output**:\n    -   $m(E) = m(N) = 0$.\n    -   Strict Policy ($S$): Does $E = P$? No ($N \\neq P$). So, $S = \\text{False}$.\n    -   Cautious Policy ($C$): Does $E = P$ or $E = U$? No ($N \\neq P$ and $N \\neq U$). So, $C = \\text{False}$.\n    -   The result vector is $[0, \\text{False}, \\text{False}]$.\n\n**Case 8: Input $(x_A, x_B, x_C) = (4.5, \\text{None}, 50)$**\nThis case includes a missing value, demonstrating the role of the $U$ state.\n\n1.  **Evaluate atomic triggers**:\n    -   $A$: $x_A = 4.5$. The condition is $4.5 \\ge 5.5$, which is false. Thus, $A = N$.\n    -   $B$: $x_B = \\text{None}$. The value is missing. Thus, $B = U$.\n    -   $C$: $x_C = 50$. The condition is $50 \\le 60$, which is true. Thus, $C = P$.\n\n2.  **Evaluate the sub-expression $(B \\land C)$**:\n    -   We compute $U \\land P$. From the conjunction table, $U \\land P = U$.\n\n3.  **Evaluate the full expression $E = A \\lor (B \\land C)$**:\n    -   We compute $N \\lor U$. From the disjunction table, $N \\lor U = U$. So, $E=U$.\n\n4.  **Determine policies and final output**:\n    -   $m(E) = m(U) = -1$.\n    -   Strict Policy ($S$): Does $E = P$? No ($U \\neq P$). So, $S = \\text{False}$.\n    -   Cautious Policy ($C$): Does $E = P$ or $E = U$? Yes ($U = U$). So, $C = \\text{True}$.\n    -   The result vector is $[-1, \\text{False}, \\text{True}]$.\n\nBy applying this procedure to all eight test cases, we obtain the following results:\n-   Case 1: $(5.0, 1.2, 70) \\implies A=N, B=N, C=N \\implies E = N \\lor (N \\land N) = N$. Result: $[0, \\text{False}, \\text{False}]$.\n-   Case 2: $(5.6, 1.0, 90) \\implies A=P, B=N, C=N \\implies E = P \\lor (N \\land N) = P$. Result: $[1, \\text{True}, \\text{True}]$.\n-   Case 3: $(4.0, 2.0, 40) \\implies A=N, B=P, C=P \\implies E = N \\lor (P \\land P) = P$. Result: $[1, \\text{True}, \\text{True}]$.\n-   Case 4: $(4.0, 2.2, 80) \\implies A=N, B=P, C=N \\implies E = N \\lor (P \\land N) = N$. Result: $[0, \\text{False}, \\text{False}]$.\n-   Case 5: $(\\text{None}, 2.0, 40) \\implies A=U, B=P, C=P \\implies E = U \\lor (P \\land P) = P$. Result: $[1, \\text{True}, \\text{True}]$.\n-   Case 6: $(\\text{None}, \\text{None}, \\text{None}) \\implies A=U, B=U, C=U \\implies E = U \\lor (U \\land U) = U$. Result: $[-1, \\text{False}, \\text{True}]$.\n-   Case 7: $(5.5, 1.5, 60) \\implies A=P, B=P, C=P \\implies E = P \\lor (P \\land P) = P$. Result: $[1, \\text{True}, \\text{True}]$.\n-   Case 8: $(4.5, \\text{None}, 50) \\implies A=N, B=U, C=P \\implies E = N \\lor (U \\land P) = U$. Result: $[-1, \\text{False}, \\text{True}]$.\n\nThese results are systematically generated by the implementation in the following section.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport operator\n\n# No other libraries are imported.\n\ndef solve():\n    \"\"\"\n    Solves the three-valued logic problem for medical alerts.\n    \"\"\"\n    \n    # Define the three logic states. Using strings for clarity.\n    P, N, U = \"P\", \"N\", \"U\"\n\n    # Define the integer mapping for the output.\n    MAPPING = {P: 1, N: 0, U: -1}\n\n    def evaluate_atomic_trigger(value, threshold, op):\n        \"\"\"\n        Evaluates a single lab value against a threshold.\n        'op' is a comparison operator from the operator module.\n        \"\"\"\n        if value is None:\n            return U\n        if op(value, threshold):\n            return P\n        else:\n            return N\n\n    def kleene_and(v1, v2):\n        \"\"\"Implements strong Kleene three-valued conjunction (AND).\"\"\"\n        if v1 == N or v2 == N:\n            return N\n        if v1 == P and v2 == P:\n            return P\n        return U\n\n    def kleene_or(v1, v2):\n        \"\"\"Implements strong Kleene three-valued disjunction (OR).\"\"\"\n        if v1 == P or v2 == P:\n            return P\n        if v1 == N and v2 == N:\n            return N\n        return U\n\n    # Thresholds for the atomic triggers A, B, and C.\n    t_A = 5.5\n    t_B = 1.5\n    t_C = 60\n\n    # Test suite: tuples of (x_A, x_B, x_C), with None for missing values.\n    test_cases = [\n        (5.0, 1.2, 70),       # Case 1\n        (5.6, 1.0, 90),       # Case 2\n        (4.0, 2.0, 40),       # Case 3\n        (4.0, 2.2, 80),       # Case 4\n        (None, 2.0, 40),      # Case 5\n        (None, None, None),   # Case 6\n        (5.5, 1.5, 60),       # Case 7\n        (4.5, None, 50),      # Case 8\n    ]\n\n    results = []\n    for case in test_cases:\n        x_A, x_B, x_C = case\n\n        # Step 1: Evaluate atomic triggers A, B, and C.\n        A = evaluate_atomic_trigger(x_A, t_A, operator.ge) # A is x_A >= t_A\n        B = evaluate_atomic_trigger(x_B, t_B, operator.ge) # B is x_B >= t_B\n        C = evaluate_atomic_trigger(x_C, t_C, operator.le) # C is x_C = t_C\n\n        # Step 2: Evaluate the composite expression E = A or (B and C).\n        # The inner conjunction (B and C) is evaluated first.\n        B_and_C = kleene_and(B, C)\n        \n        # Then the outer disjunction.\n        E = kleene_or(A, B_and_C)\n\n        # Step 3: Apply firing policies and map E to its integer representation.\n        m_E = MAPPING[E]\n        \n        # Strict policy (S): fire if and only if E is Positive.\n        S = (E == P)\n        \n        # Cautious policy (C): fire if E is Positive or Unknown.\n        C_policy = (E == P or E == U)\n\n        # Collect the results for this case in the specified format [m(E), S, C].\n        results.append([m_E, S, C_policy])\n\n    # Final print statement must produce a single line in the exact specified format.\n    # The str() function on a list correctly formats it with capitalized Booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4822035"}]}