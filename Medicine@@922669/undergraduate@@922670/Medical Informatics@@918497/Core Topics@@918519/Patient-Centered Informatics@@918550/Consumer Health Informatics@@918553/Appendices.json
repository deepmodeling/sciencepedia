{"hands_on_practices": [{"introduction": "The ultimate goal of many consumer health applications is to foster positive, long-term health behaviors. A key indicator of an app's success in this area is its 'stickiness'—its ability to become an integral part of a user's daily routine. This exercise guides you through calculating and interpreting one of the most common stickiness metrics, the ratio of Daily Active Users ($N_{DAU}$) to Monthly Active Users ($N_{MAU}$), providing a quantitative measure of user habit formation [@problem_id:4831473].", "problem": "A large-scale consumer health application delivering personalized hypertension coaching flows uses standard engagement metrics to evaluate whether users are building daily habits. Over a $30$-day calendar month, the system recorded the count of unique Monthly Active Users (MAU) as $50{,}000$, and on a typical day in that same month, the count of unique Daily Active Users (DAU) was $20{,}000$. Using the core definitions from consumer health informatics, consider a stickiness measure defined as the proportion of the monthly active cohort who are active on a typical day. Starting only from these definitions and the provided counts, derive an expression for this stickiness measure in terms of the quantities provided and compute its value. Interpret the implication for daily habit formation in this consumer health informatics context. Express your final numerical answer as a decimal without a percentage sign, and round to three significant figures.", "solution": "The problem requires the derivation and computation of a user engagement metric, termed \"stickiness,\" for a consumer health application focused on hypertension coaching. The analysis must be based solely on the provided data and definitions.\n\nFirst, we must formalize the given quantities and definitions. Let $N_{MAU}$ represent the count of unique Monthly Active Users and $N_{DAU}$ represent the count of unique Daily Active Users on a typical day within the specified month. The problem provides the following values:\n$$\nN_{MAU} = 50{,}000\n$$\n$$\nN_{DAU} = 20{,}000\n$$\nThe duration of the observation period is a $30$-day calendar month.\n\nThe problem defines the stickiness measure, which we will denote by $S$, as \"the proportion of the monthly active cohort who are active on a typical day.\" This definition provides a direct instruction for formulating the expression. The \"monthly active cohort\" is the set of users whose size is $N_{MAU}$. The number of users from this cohort who are \"active on a typical day\" is given by $N_{DAU}$. Therefore, the proportion is the ratio of these two quantities.\n\nThe mathematical expression for the stickiness measure $S$ is:\n$$\nS = \\frac{N_{DAU}}{N_{MAU}}\n$$\n\nNext, we substitute the provided numerical values into this expression to compute the value of $S$.\n$$\nS = \\frac{20{,}000}{50{,}000}\n$$\nThis fraction simplifies as:\n$$\nS = \\frac{2}{5} = 0.4\n$$\nThe problem requires the final numerical answer to be expressed as a decimal rounded to three significant figures. The value $0.4$ has one significant figure. To express it with three significant figures, we must write it as $0.400$.\n$$\nS = 0.400\n$$\n\nFinally, we must interpret the implication of this result for daily habit formation in the consumer health informatics context. A stickiness measure of $S = 0.400$ means that on a typical day, $40\\%$ of the users who engaged with the application at least once during the month are active.\n\nIn the context of hypertension management, forming daily habits—such as logging blood pressure, taking medication, or engaging with educational content—is often a primary goal for improving health outcomes. A stickiness of $40\\%$ indicates a moderately strong level of daily engagement. It suggests that a substantial core of the user base is successfully integrating the application into their daily routine, which is a positive indicator for habit formation within this group.\n\nHowever, the metric also reveals that on a typical day, the majority of the monthly users ($100\\% - 40\\% = 60\\%$) are not active. This indicates a significant portion of the user base has sporadic or infrequent engagement. For a condition like hypertension where consistent daily monitoring and management can be critical, this level of engagement may be insufficient for a large part of the user base to form the necessary habits for clinical benefit.\n\nIn conclusion, while the application demonstrates success in fostering daily habits for a significant minority of its users, there is a substantial opportunity to improve engagement strategies to convert a larger fraction of the monthly active user base into daily active users, thereby strengthening habit formation and the potential for positive clinical impact across the population served.", "answer": "$$\n\\boxed{0.400}\n$$", "id": "4831473"}, {"introduction": "Effective consumer health informatics is not just about collecting data; it's about communicating it in ways that empower patients to make informed decisions. Statistical concepts like risk, however, can be confusing. This practice delves into the crucial difference between relative risk reduction ($RRR$) and absolute risk reduction ($ARR$), challenging you to translate these clinical statistics into a plain-language explanation that is both accurate and understandable for a patient [@problem_id:4831516].", "problem": "A designer of a Consumer Health Informatics (CHI) portal needs to present treatment benefits to patients in a way that is both mathematically valid and understandable. In this portal, the baseline risk of a specific adverse event for a user group is stated as $2\\%$, and the treatment is described as providing a $50\\%$ relative risk reduction. Using only fundamental definitions, treat “risk” as a probability on $[0,1]$ of the event over a fixed time horizon, interpret “relative risk reduction” as a proportional decrease in the risk relative to the baseline, and interpret “absolute risk reduction” as the change in the probability of the event. \n\nTasks:\n1. Derive, from these definitions, the expression for the post-treatment risk in terms of the baseline risk and the relative risk reduction.\n2. From your derivation, compute the absolute risk reduction (that is, the difference between pre-treatment and post-treatment risk) for the stated baseline risk of $2\\%$ and relative risk reduction of $50\\%$.\n3. Write a single-sentence, plain-language explanation suitable for patients that correctly reflects your quantitative result (for example, by referencing outcomes per $100$ people). \n\nExpress your final numeric answer to Task 2 as a decimal (not using a percentage sign). No rounding instruction is necessary; provide the exact decimal value.", "solution": "We begin from the foundational definitions. Let $p_{0} \\in [0,1]$ denote the baseline probability (risk) of the adverse event over a specified period for a given population, and let $p_{1} \\in [0,1]$ denote the post-treatment probability (risk) under the intervention. By definition, the Absolute Risk Reduction (ARR) is the change in probability:\n$$\n\\text{ARR} = p_{0} - p_{1}.\n$$\nThe Relative Risk Reduction (RRR) is defined as the proportional decrease in risk relative to the baseline:\n$$\n\\text{RRR} = \\frac{p_{0} - p_{1}}{p_{0}}.\n$$\nThis definition rearranges to solve for $p_{1}$ in terms of $p_{0}$ and $\\text{RRR}$:\n$$\n\\text{RRR} = 1 - \\frac{p_{1}}{p_{0}} \\quad \\Longrightarrow \\quad \\frac{p_{1}}{p_{0}} = 1 - \\text{RRR} \\quad \\Longrightarrow \\quad p_{1} = p_{0}\\,(1 - \\text{RRR}).\n$$\nSubstituting this $p_{1}$ into the expression for $\\text{ARR}$ gives:\n$$\n\\text{ARR} = p_{0} - p_{0}(1 - \\text{RRR}) = p_{0}\\,\\text{RRR}.\n$$\nNow evaluate for the given quantities. A baseline risk of $2\\%$ corresponds to $p_{0} = 0.02$ as a probability, and a relative risk reduction of $50\\%$ corresponds to $\\text{RRR} = 0.50$ as a proportion. Compute the post-treatment risk:\n$$\np_{1} = 0.02\\,(1 - 0.50) = 0.02 \\times 0.50 = 0.01.\n$$\nHence, the absolute risk reduction is:\n$$\n\\text{ARR} = p_{0} - p_{1} = 0.02 - 0.01 = 0.01.\n$$\nA plain-language explanation aligned with these values could be: “Without treatment, about $2$ out of $100$ people would be expected to have the event; with treatment, about $1$ out of $100$ would, so the treatment prevents about $1$ event per $100$ people like you.” This statement accurately reflects $p_{0} = 0.02$, $p_{1} = 0.01$, and $\\text{ARR} = 0.01$.\n\nThe requested final numeric answer for the absolute risk reduction, expressed as a decimal, is $0.01$.", "answer": "$$\\boxed{0.01}$$", "id": "4831516"}, {"introduction": "For data from a consumer's health device to be valuable in a clinical setting, it must be structured in a language that electronic health systems can understand. This concept, known as semantic interoperability, is achieved through standards like HL7 FHIR, LOINC, and SNOMED CT. This practical coding exercise tasks you with a core informatics function: converting a raw, consumer-generated blood pressure reading into a standardized FHIR Observation resource, making it ready for integration into a patient's official medical record [@problem_id:4831487].", "problem": "You are designing an algorithm for transforming consumer-generated vital signs into standardized representations suitable for interoperable exchange. Use the following foundational, widely accepted facts and definitions as the base for your derivation and algorithm design, without assuming any domain-specific shortcuts beyond these facts.\n\n1. Health Level Seven (HL7) Fast Healthcare Interoperability Resources (FHIR) defines the \"Observation\" resource for vital signs captured by consumers. Logical Observation Identifiers Names and Codes (LOINC) provides codes for laboratory and clinical observations, including blood pressure components, and Systematized Nomenclature of Medicine—Clinical Terms (SNOMED CT) provides clinical concepts. Unified Code for Units of Measure (UCUM) provides canonical codes and systems for measurement units.\n\n2. For a blood pressure observation, the standard LOINC code for the panel is $85354\\text{-}9$ \"Blood pressure panel with all children optional\". The standard LOINC code for systolic blood pressure is $8480\\text{-}6$, and for diastolic blood pressure is $8462\\text{-}4$. A commonly used SNOMED CT concept for blood pressure is $75367002$ \"Blood pressure (observable entity)\".\n\n3. For units, FHIR recommends using UCUM with system \"http://unitsofmeasure.org\". The canonical UCUM code for millimetres of mercury is \"mm[Hg]\". If input is in kilopascal (kPa), use the well-tested conversion factor $1\\ \\mathrm{kPa} = 7.50061682704\\ \\mathrm{mmHg}$. When converting from kilopascal to millimetres of mercury, round to $1$ decimal place in $\\mathrm{mmHg}$.\n\n4. A minimal, structurally valid FHIR Observation for blood pressure must include: resourceType \"Observation\", status \"final\", category \"vital-signs\" with system \"http://terminology.hl7.org/CodeSystem/observation-category\" and code \"vital-signs\", code containing LOINC $85354\\text{-}9$ and optionally SNOMED CT $75367002$, and component elements for present measures (systolic and/or diastolic), each with its respective LOINC code and a valueQuantity carrying value, unit, system, and code. Missing diastolic is permitted by the panel definition (“all children optional”).\n\nYour task is to write a complete program that, for each provided test case, constructs an internal FHIR Observation JSON representation following the rules above and then computes three validation flags:\n\n- has_required_loinc_codes: true if and only if the Observation.code includes the LOINC panel code $85354\\text{-}9$ and each present component uses the correct LOINC code ($8480\\text{-}6$ for systolic and $8462\\text{-}4$ for diastolic).\n- has_required_snomed_code: true if and only if the Observation.code includes SNOMED CT code $75367002$.\n- uses_ucum_units: true if and only if every present component’s valueQuantity uses the UCUM system \"http://unitsofmeasure.org\" and the UCUM code \"mm[Hg]\".\n\nTransformation rules to implement for each test case:\n- Input numeric blood pressure values may be in either millimetres of mercury (mmHg) or kilopascal (kPa). If input is in kPa, convert to mmHg using $v_{\\mathrm{mmHg}} = v_{\\mathrm{kPa}} \\times 7.50061682704$ and round to $1$ decimal place. Use the rounded value in the JSON.\n- If the input unit text is clearly identifiable as millimetres of mercury (case-insensitive \"mmHg\" or equivalent), set valueQuantity.system to \"http://unitsofmeasure.org\", valueQuantity.code to \"mm[Hg]\", and valueQuantity.unit to \"mmHg\".\n- If the input unit text is clearly identifiable as kilopascal (case-insensitive \"kPa\"), convert as above and set valueQuantity.system to \"http://unitsofmeasure.org\", valueQuantity.code to \"mm[Hg]\", and valueQuantity.unit to \"mmHg\".\n- If the input unit text cannot be recognized as either millimetres of mercury or kilopascal, do not set valueQuantity.system or valueQuantity.code (leave them absent), and copy the raw unit text to valueQuantity.unit. This case should cause uses_ucum_units to be false.\n- If a diastolic value is missing, emit only the systolic component; otherwise, emit both components.\n- The Observation.code must always include the LOINC blood pressure panel code $85354\\text{-}9$; include the SNOMED CT code $75367002$ only when the test case indicates to include SNOMED.\n\nTest suite:\nProvide results for the following five cases. For each case, the input tuple is (systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean):\n\n1. Case A: Systolic $130$, Diastolic $82$, Unit \"mmHg\", Include SNOMED true.\n2. Case B: Systolic $118$, Diastolic null, Unit \"mmHg\", Include SNOMED true.\n3. Case C: Systolic $16.0$, Diastolic $10.7$, Unit \"kPa\", Include SNOMED true. Apply conversion to $\\mathrm{mmHg}$ and round to $1$ decimal place.\n4. Case D: Systolic $140$, Diastolic $95$, Unit \"mmHg\", Include SNOMED false.\n5. Case E: Systolic $125$, Diastolic $79$, Unit \"unknown\", Include SNOMED true. Units are unrecognized and must not receive UCUM system and code.\n\nOutput specification:\n- For each case, compute a list [has_required_loinc_codes, has_required_snomed_code, uses_ucum_units].\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself the list of three booleans for one case, in the order A, B, C, D, E. For example: [[true_case_A_loinc, true_case_A_snomed, true_case_A_ucum],...].\n- All booleans must be printed as Python-style literals True or False.\n- No user input is allowed; hard-code the test cases exactly as specified above.\n\nThere are no angle units involved. The only physical unit conversion is between kilopascal and millimetres of mercury; express internal stored values in the FHIR Observation JSON in millimetres of mercury after conversion, rounded to $1$ decimal place in $\\mathrm{mmHg}$ where applicable.", "solution": "The problem is valid as it is scientifically grounded in established health informatics standards (HL7 FHIR, LOINC, SNOMED CT, UCUM), well-posed with deterministic rules, and objective in its language. It presents a clearly defined data transformation and validation task that is representative of challenges in the field of consumer health informatics.\n\nThe solution requires designing an algorithm that processes consumer-generated blood pressure readings, transforms them into a structured format mimicking a FHIR Observation resource, and then validates this structure against a set of rules. The process for each test case can be broken down into two main phases: construction of the internal data structure and validation of that structure.\n\n**Phase 1: Construction of the FHIR Observation Representation**\n\nFor each input tuple `(systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean)`, we construct an internal dictionary representing the key parts of a FHIR Observation resource.\n\n1.  **Observation-level Coding:**\n    The `Observation.code` element must contain codings that identify the observation panel.\n    -   The LOINC code for the \"Blood pressure panel\", $85354\\text{-}9$, is always included. The coding object will have `system: \"http://loinc.org\"` and `code: \"85354-9\"`.\n    -   If the `include_snomed_boolean` flag is true, the SNOMED CT code for \"Blood pressure (observable entity)\", $75367002$, is also included. The coding object will have `system: \"http://snomed.info/sct\"` and `code: \"75367002\"`.\n\n2.  **Unit and Value Processing:**\n    The input values must be processed based on the provided `unit_label_string`. The goal is to standardize the measurements to millimetres of mercury (mmHg) and represent them using the Unified Code for Units of Measure (UCUM).\n    -   The conversion factor is given as $1\\ \\mathrm{kPa} = 7.50061682704\\ \\mathrm{mmHg}$.\n    -   If the input unit is identified as kilopascal (e.g., case-insensitive \"kPa\"), the numerical values are converted to mmHg using the formula $v_{\\mathrm{mmHg}} = v_{\\mathrm{kPa}} \\times 7.50061682704$. The result is rounded to $1$ decimal place. The `valueQuantity` for the component will then use the UCUM standard representation: `system: \"http://unitsofmeasure.org\"`, `code: \"mm[Hg]\"`, and `unit: \"mmHg\"`.\n    -   If the input unit is identified as millimetres of mercury (e.g., case-insensitive \"mmHg\"), no numerical conversion is necessary. The `valueQuantity` is populated with the same UCUM information as the kPa case.\n    -   If the unit is not recognized, the numerical values are used as is, and the `valueQuantity` is created without the `system` and `code` fields. The original `unit_label_string` is copied to the `unit` field.\n\n3.  **Component Construction:**\n    The blood pressure panel consists of components for systolic and diastolic measurements.\n    -   A component for systolic blood pressure is always created. Its `code` element is populated with the LOINC code $8480\\text{-}6$. Its `valueQuantity` is populated with the processed value and unit information from the previous step.\n    -   If `diastolic_value_or_null` is not null, a component for diastolic blood pressure is also created. Its `code` is set to the LOINC code $8462\\text{-}4$, and its `valueQuantity` is populated similarly. If the diastolic value is null, this component is omitted, consistent with the panel definition \"all children optional\".\n\n**Phase 2: Validation**\n\nAfter constructing the internal representation for a given test case, three boolean flags are computed by inspecting its structure.\n\n1.  **`has_required_loinc_codes`**: This flag is `true` if and only if all of the following conditions are met:\n    -   The `Observation.code` contains the LOINC panel code $85354\\text{-}9$.\n    -   The systolic component's `code` contains the LOINC code $8480\\text{-}6$.\n    -   If the diastolic component is present, its `code` contains the LOINC code $8462\\text{-}4$.\n\n2.  **`has_required_snomed_code`**: This flag is `true` if and only if the `Observation.code` contains the SNOMED CT code $75367002$.\n\n3.  **`uses_ucum_units`**: This flag is `true` if and only if every component present in the Observation has a `valueQuantity` that includes both `system: \"http://unitsofmeasure.org\"` and `code: \"mm[Hg]\"`. If no components were present, this would be vacuously true, but our logic always generates at least a systolic component.\n\nThe algorithm will iterate through each of the five specified test cases, performing these construction and validation steps, and will collect the resulting list of three booleans for each case. The final output will be a formatted string representing a list of these lists.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print results.\n    \"\"\"\n    # Define constants based on the problem statement.\n    KPA_TO_MMHG = 7.50061682704\n    LOINC_SYSTEM = \"http://loinc.org\"\n    SNOMED_SYSTEM = \"http://snomed.info/sct\"\n    UCUM_SYSTEM = \"http://unitsofmeasure.org\"\n    OBS_CATEGORY_SYSTEM = \"http://terminology.hl7.org/CodeSystem/observation-category\"\n\n    LOINC_BP_PANEL = \"85354-9\"\n    LOINC_SYS = \"8480-6\"\n    LOINC_DIA = \"8462-4\"\n    SNOMED_BP = \"75367002\"\n    UCUM_MMHG_CODE = \"mm[Hg]\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (systolic_value, diastolic_value_or_null, unit_label_string, include_snomed_boolean)\n        (130, 82, \"mmHg\", True),    # Case A\n        (118, None, \"mmHg\", True),  # Case B\n        (16.0, 10.7, \"kPa\", True),  # Case C\n        (140, 95, \"mmHg\", False),   # Case D\n        (125, 79, \"unknown\", True), # Case E\n    ]\n\n    def process_case(systolic_val, diastolic_val, unit_str, include_snomed):\n        \"\"\"\n        Constructs a FHIR-like observation and validates it for a single case.\n        \"\"\"\n        \n        # 1. Construct the internal FHIR-like representation\n        observation = {\n            \"resourceType\": \"Observation\",\n            \"status\": \"final\",\n            \"category\": [{\n                \"coding\": [{\n                    \"system\": OBS_CATEGORY_SYSTEM,\n                    \"code\": \"vital-signs\"\n                }]\n            }],\n            \"code\": {\n                \"coding\": [{\n                    \"system\": LOINC_SYSTEM,\n                    \"code\": LOINC_BP_PANEL\n                }]\n            },\n            \"component\": []\n        }\n        \n        # Add SNOMED code if required\n        if include_snomed:\n            observation[\"code\"][\"coding\"].append({\n                \"system\": SNOMED_SYSTEM,\n                \"code\": SNOMED_BP\n            })\n\n        # Process units and values\n        unit_lower = unit_str.lower()\n        value_quantity_system = None\n        value_quantity_code = None\n        value_quantity_unit = unit_str\n\n        processed_sys = systolic_val\n        processed_dia = diastolic_val\n\n        if unit_lower == 'mmhg':\n            value_quantity_system = UCUM_SYSTEM\n            value_quantity_code = UCUM_MMHG_CODE\n            value_quantity_unit = \"mmHg\"\n        elif unit_lower == 'kpa':\n            processed_sys = round(systolic_val * KPA_TO_MMHG, 1)\n            if diastolic_val is not None:\n                processed_dia = round(diastolic_val * KPA_TO_MMHG, 1)\n            value_quantity_system = UCUM_SYSTEM\n            value_quantity_code = UCUM_MMHG_CODE\n            value_quantity_unit = \"mmHg\"\n            \n        # Add systolic component\n        systolic_component = {\n            \"code\": {\"coding\": [{\"system\": LOINC_SYSTEM, \"code\": LOINC_SYS}]},\n            \"valueQuantity\": {\"value\": processed_sys, \"unit\": value_quantity_unit}\n        }\n        if value_quantity_system and value_quantity_code:\n            systolic_component[\"valueQuantity\"][\"system\"] = value_quantity_system\n            systolic_component[\"valueQuantity\"][\"code\"] = value_quantity_code\n        observation[\"component\"].append(systolic_component)\n\n        # Add diastolic component if present\n        if diastolic_val is not None:\n            diastolic_component = {\n                \"code\": {\"coding\": [{\"system\": LOINC_SYSTEM, \"code\": LOINC_DIA}]},\n                \"valueQuantity\": {\"value\": processed_dia, \"unit\": value_quantity_unit}\n            }\n            if value_quantity_system and value_quantity_code:\n                diastolic_component[\"valueQuantity\"][\"system\"] = value_quantity_system\n                diastolic_component[\"valueQuantity\"][\"code\"] = value_quantity_code\n            observation[\"component\"].append(diastolic_component)\n\n        # 2. Perform validation checks\n\n        # Check for required LOINC codes\n        panel_loinc_ok = any(\n            c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_BP_PANEL\n            for c in observation[\"code\"][\"coding\"]\n        )\n        sys_loinc_ok = any(\n            c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_SYS\n            for c in observation[\"component\"][0][\"code\"][\"coding\"]\n        )\n        dia_loinc_ok = True\n        if len(observation[\"component\"]) > 1:\n            dia_loinc_ok = any(\n                c.get(\"system\") == LOINC_SYSTEM and c.get(\"code\") == LOINC_DIA\n                for c in observation[\"component\"][1][\"code\"][\"coding\"]\n            )\n        has_required_loinc_codes = panel_loinc_ok and sys_loinc_ok and dia_loinc_ok\n\n        # Check for required SNOMED code\n        has_required_snomed_code = any(\n            c.get(\"system\") == SNOMED_SYSTEM and c.get(\"code\") == SNOMED_BP\n            for c in observation[\"code\"][\"coding\"]\n        )\n\n        # Check for UCUM units\n        uses_ucum_units = all(\n            comp[\"valueQuantity\"].get(\"system\") == UCUM_SYSTEM and\n            comp[\"valueQuantity\"].get(\"code\") == UCUM_MMHG_CODE\n            for comp in observation[\"component\"]\n        )\n\n        return [has_required_loinc_codes, has_required_snomed_code, uses_ucum_units]\n\n    results = []\n    for case in test_cases:\n        result = process_case(*case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4831487"}]}