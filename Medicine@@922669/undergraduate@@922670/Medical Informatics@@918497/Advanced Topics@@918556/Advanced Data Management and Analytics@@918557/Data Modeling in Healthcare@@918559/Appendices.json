{"hands_on_practices": [{"introduction": "Raw clinical data is often collected in a \"flat\" or denormalized format, which can lead to redundancy and inconsistencies. The process of database normalization provides a systematic way to organize this data into a stable and efficient relational schema. This foundational exercise [@problem_id:4833282] challenges you to apply the principles of normalization to a hypothetical, denormalized Electronic Health Record (EHR) table, building a structured model that prevents data anomalies and ensures referential integrity.", "problem": "A hospital’s Electronic Health Record (EHR) system has a denormalized table with columns: patient_id, patient_name, dob, encounter_id, provider_id, observation_id, loinc_code, value. The code loinc_code refers to Logical Observation Identifiers Names and Codes (LOINC). Assume the following domain and data modeling facts grounded in the relational model and healthcare workflow:\n\n- Each observation is a single clinical measurement or finding recorded during care and belongs to exactly one encounter.\n- Each encounter belongs to exactly one patient.\n- Each observation is attributable to exactly one provider.\n- Each observation is annotated with exactly one LOINC code indicating its clinical meaning.\n- Each patient may have many encounters, each encounter may have many observations, each provider may be responsible for many observations, and each LOINC code may label many observations.\n- Identifiers patient_id, provider_id, encounter_id, observation_id, and loinc_code are unique within their respective domains.\n- In the denormalized table, patient_name and dob are properties of a patient determined by patient_id.\n\nUsing only foundational principles from the relational model, including the definitions of relation, attribute, primary key, foreign key, and functional dependency, derive a fully normalized relational schema appropriate for clinical data in an EHR. Your normalization should remove update anomalies implied by the given dependencies and be consistent with healthcare data semantics as stated.\n\nThen, under the standard definition of referential integrity in Structured Query Language (SQL), compute the minimal number of distinct foreign key constraints necessary to ensure that no record references a non-existent parent across your normalized tables. Count only non-redundant constraints needed to enforce the relationships implied by the domain facts above, and do not introduce optional or derived references that are not required by these facts.\n\nProvide only the integer count of the minimal set of foreign key constraints as your final answer. No rounding is required and no units are necessary. Express the final answer as a single number.", "solution": "The problem requires the derivation of a fully normalized relational schema from a single denormalized table and the subsequent calculation of the minimum number of foreign key constraints required to enforce referential integrity. The process must be grounded in the foundational principles of the relational model.\n\nFirst, we formalize the problem by identifying the set of attributes and the functional dependencies (FDs) implied by the given statements.\n\nThe universal relation, let us call it $R$, contains the following attributes:\n$R(\\mathit{patient\\_id}, \\mathit{patient\\_name}, \\mathit{dob}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{observation\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$\n\nFrom the problem description, we can extract the following functional dependencies:\n1.  \"In the denormalized table, `patient_name` and `dob` are properties of a patient determined by `patient_id`.\" This translates to the FD:\n    $$FD_1: \\{\\mathit{patient\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$$\n2.  \"Each encounter belongs to exactly one patient.\" This implies that the encounter's identifier determines the patient's identifier. This translates to the FD:\n    $$FD_2: \\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$$\n3.  \"Each observation is a single clinical measurement...belongs to exactly one encounter...is attributable to exactly one provider...is annotated with exactly one LOINC code.\" This establishes that the identifier for an observation, $\\mathit{observation\\_id}$, uniquely determines the encounter it belongs to, the provider responsible, the code describing it, and its measured value. This translates to the FD:\n    $$FD_3: \\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value}\\}$$\nThe attribute $\\mathit{observation\\_id}$ serves as the primary key for the granular event of an observation. The initial denormalized table exhibits redundancy and is subject to update anomalies. For instance, a patient's date of birth ($\\mathit{dob}$) might be stored multiple times, once for each observation associated with that patient, leading to potential inconsistencies. These issues arise from transitive dependencies. Specifically, from $FD_3$ and $FD_2$, we have $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{encounter\\_id}\\}$ and $\\{\\mathit{encounter\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$, which implies the transitive dependency $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_id}\\}$. Combining this with $FD_1$, we get another transitive dependency: $\\{\\mathit{observation\\_id}\\} \\rightarrow \\{\\mathit{patient\\_name}, \\mathit{dob}\\}$.\n\nTo create a fully normalized schema (typically achieving at least Third Normal Form, $3$NF, or Boyce-Codd Normal Form, BCNF), we decompose the universal relation $R$ into smaller relations, such that in each resulting relation, every non-key attribute is fully functionally dependent on the primary key.\n\nThe decomposition proceeds as follows:\n1.  **Patients Table:** To resolve the transitive dependency involving patient attributes, we create a relation for patients based on $FD_1$.\n    $$\\text{Patients}(\\underline{\\mathit{patient\\_id}}, \\mathit{patient\\_name}, \\mathit{dob})$$\n    The primary key is $\\mathit{patient\\_id}$.\n\n2.  **Encounters Table:** To resolve the transitive dependency involving the patient link, we create a relation for encounters based on $FD_2$. This table links each encounter to a specific patient.\n    $$\\text{Encounters}(\\underline{\\mathit{encounter\\_id}}, \\mathit{patient\\_id})$$\n    The primary key is $\\mathit{encounter\\_id}$. The attribute $\\mathit{patient\\_id}$ will serve as a foreign key.\n\n3.  **Reference Tables (Dimensions):** The problem states that $\\mathit{provider\\_id}$ and $\\mathit{loinc\\_code}$ are unique identifiers for their respective domains. For referential integrity to be possible, these domains must be represented by relations (tables). Even though no other attributes are specified for providers or LOINC codes, we must define these entities.\n    $$\\text{Providers}(\\underline{\\mathit{provider\\_id}}, \\dots)$$\n    $$\\text{LOINCCodes}(\\underline{\\mathit{loinc\\_code}}, \\dots)$$\n    The primary keys are $\\mathit{provider\\_id}$ and $\\mathit{loinc\\_code}$, respectively.\n\n4.  **Observations Table (Fact Table):** The remaining attributes from $FD_3$ form the central, or fact, table. This relation records the core observational events and links to the other entities.\n    $$\\text{Observations}(\\underline{\\mathit{observation\\_id}}, \\mathit{encounter\\_id}, \\mathit{provider\\_id}, \\mathit{loinc\\_code}, \\mathit{value})$$\n    The primary key is $\\mathit{observation\\_id}$. The attributes $\\mathit{encounter\\_id}$, $\\mathit{provider\\_id}$, and $\\mathit{loinc\\_code}$ will serve as foreign keys.\n\nThe resulting normalized schema consists of $5$ relations: `Patients`, `Providers`, `LOINCCodes`, `Encounters`, and `Observations`. Now, we must identify the minimal set of foreign key (FK) constraints necessary to enforce the relationships defined in the problem. A foreign key constraint ensures that a value (or set of values) in a referencing table has a matching value in the primary key of a referenced table.\n\nLet's enumerate the non-redundant FK constraints for this schema:\n1.  **From `Encounters` to `Patients`:** The relationship \"Each encounter belongs to exactly one patient\" is modeled by the attribute $\\mathit{patient\\_id}$ in the `Encounters` table. To ensure that every encounter is associated with a valid, existing patient, we need a constraint.\n    - FK$1$: `Encounters.patient_id` must reference `Patients.patient_id`.\n\n2.  **From `Observations` to other tables:** The `Observations` table is the hub connecting various entities.\n    - To enforce \"Each observation...belongs to exactly one encounter\":\n        - FK$2$: `Observations.encounter_id` must reference `Encounters.encounter_id`.\n    - To enforce \"Each observation is attributable to exactly one provider\":\n        - FK$3$: `Observations.provider_id` must reference `Providers.provider_id`.\n    - To enforce \"Each observation is annotated with exactly one LOINC code\":\n        - FK$4$: `Observations.loinc_code` must reference `LOINCCodes.loinc_code`.\n\nThese $4$ constraints are minimal and non-redundant. The chain of integrity from an observation to a patient is enforced transitively through two constraints: FK$2$ (Observation $\\rightarrow$ Encounter) and FK$1$ (Encounter $\\rightarrow$ Patient). Adding a direct foreign key from `Observations` to `Patients` would first require adding a `patient_id` column to the `Observations` table. This would violate normalization principles, as `patient_id` would be transitively dependent on the primary key `observation_id` (via `encounter_id`), reintroducing the very redundancy we sought to eliminate. Therefore, such a constraint is not part of the minimal set for a normalized schema.\n\nThe minimal number of distinct foreign key constraints is the sum of the constraints identified:\n- $1$ constraint from the `Encounters` table.\n- $3$ constraints from the `Observations` table.\n\nTotal minimal constraints = $1 + 3 = 4$.", "answer": "$$\\boxed{4}$$", "id": "4833282"}, {"introduction": "A well-designed database schema is only a blueprint; its integrity is maintained by a set of rigorously enforced constraints. This practice [@problem_id:4833285] moves from theoretical design to practical enforcement, simulating how a database management system validates incoming data against rules like primary key uniqueness and foreign key relationships. By predicting the outcome of various data insertion attempts, you will gain a concrete understanding of how a robust data model actively safeguards data quality and consistency.", "problem": "You are given three relations representing core entities in healthcare data modeling: a patient relation, an encounter relation, and an observation relation. Use the classical relational model as the fundamental base to formalize constraints and compute insertion outcomes.\n\nDefine three relations as sets of tuples: the patient relation $P \\subseteq \\mathbb{N}^+$ with attribute $id$, the encounter relation $E \\subseteq \\mathbb{N}^+ \\times \\mathbb{N}^+$ with attributes $(id, patient\\_id)$, and the observation relation $O \\subseteq \\mathbb{N}^+ \\times \\mathbb{N}^+ \\times \\Sigma^\\*$ with attributes $(id, encounter\\_id, code)$, where $\\mathbb{N}^+$ denotes positive integers and $\\Sigma^\\*$ denotes finite strings over an alphabet $\\Sigma$. The objective is to encode and enforce the following constraints derived from the relational model:\n\n- Primary key constraint: For any relation $R$ with primary key attributes $K$, the projection onto $K$ is injective across all tuples in $R$. Concretely, for $P$ the key is $id$, for $E$ the key is $id$, and for $O$ the key is $id$. This requires uniqueness of $id$ values in each relation.\n- Foreign key constraint (referential integrity): For a tuple $(id, patient\\_id)$ in $E$, the value $patient\\_id$ must belong to the set $\\pi_{id}(P)$. For a tuple $(id, encounter\\_id, code)$ in $O$, the value $encounter\\_id$ must belong to the set $\\pi_{id}(E)$.\n- Not-null constraint: No primary key or foreign key attribute, and no observation $code$, may be null. Formally, required attributes must be elements of their domain and not equal to a designated null marker.\n- Domain constraints: All $id$ values must be elements of $\\mathbb{N}^+$, and observation codes must be elements of a controlled vocabulary set $\\mathcal{V} \\subset \\Sigma^\\*$. For this problem, take $\\mathcal{V} = \\{\\text{LOINC:1234-5}, \\text{LOINC:718-7}, \\text{SNOMED:386661006}\\}$.\n\nStarting database state is as follows and must be treated as read-only for each test case (each attempted insertion is independent and does not mutate this state):\n\n- Patients $P$ contain $id$ values $\\{\\,1001, 1002\\,\\}$.\n- Encounters $E$ contain tuples $\\{\\, (2001, 1001), (2002, 1002) \\,\\}$.\n- Observations $O$ currently contain tuples $\\{\\, (3001, 2001, \\text{LOINC:1234-5}) \\,\\}$.\n\nDefine a deterministic evaluation order for enforcing constraints on an attempted insertion $o = (id, encounter\\_id, code)$ into $O$:\n\n1. Not-null check: reject if any of $id$, $encounter\\_id$, or $code$ is null or the empty string.\n2. Domain check for $id$: reject if $id \\notin \\mathbb{N}^+$.\n3. Primary key check: reject if $id$ already exists in $\\pi_{id}(O)$.\n4. Foreign key check: reject if $encounter\\_id \\notin \\pi_{id}(E)$.\n5. Code domain check: reject if $code \\notin \\mathcal{V}$.\n\nMap outcomes to integers as follows: success $\\rightarrow 1$, foreign key violation on $encounter\\_id$ $\\rightarrow 0$, primary key violation $\\rightarrow 2$, not-null violation $\\rightarrow 3$, code domain violation $\\rightarrow 4$, $id$ domain violation $\\rightarrow 5$.\n\nYour task is to implement a program that, given the fixed starting database state above and the deterministic constraint evaluation order, computes the outcome integers for each of the following attempted insertions into $O$:\n\n- Case A (happy path): $(3002, 2002, \\text{SNOMED:386661006})$.\n- Case B (nonexistent encounter): $(3003, 9999, \\text{LOINC:718-7})$.\n- Case C (duplicate observation id): $(3001, 2002, \\text{LOINC:1234-5})$.\n- Case D (not-null $code$): $(3005, 2002, null)$, where $code$ is null.\n- Case E (invalid code): $(3004, 2001, \\text{ICD10:E11})$, which is not in $\\mathcal{V}$.\n- Case F ($id$ domain violation): $(-7, 2001, \\text{LOINC:718-7})$.\n\nAll attempted insertions are independent and do not alter the initial relations. No physical units, angle units, or percentages are involved in this problem. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result\\_A, result\\_B, result\\_C, result\\_D, result\\_E, result\\_F]$), where each $result$ is the integer code defined above, in the order of the cases A through F.", "solution": "The problem statement has been validated and is deemed sound. It is a well-posed problem grounded in the fundamental principles of the relational database model, specifically regarding data integrity constraints. The problem is self-contained, objective, and provides a deterministic evaluation order, permitting a unique and verifiable solution.\n\nThe task is to determine the outcome of six attempted insertion operations into an `Observation` relation, denoted as $O$, given a predefined initial database state and a strict sequence of integrity constraint checks. The initial state of the relevant relations is:\n- Patient IDs, $\\pi_{id}(P) = \\{1001, 1002\\}$.\n- Encounter tuples, $E = \\{(2001, 1001), (2002, 1002)\\}$, from which we derive the set of encounter IDs, $\\pi_{id}(E) = \\{2001, 2002\\}$.\n- Observation tuples, $O = \\{(3001, 2001, \\text{LOINC:1234-5})\\}$, from which we derive the set of existing observation IDs, $\\pi_{id}(O) = \\{3001\\}$.\n- Controlled vocabulary for observation codes, $\\mathcal{V} = \\{\\text{LOINC:1234-5}, \\text{LOINC:718-7}, \\text{SNOMED:386661006}\\}$.\n\nThe deterministic evaluation order for an attempted insertion of a tuple $o = (id, encounter\\_id, code)$ into the observation relation $O$ is as follows:\n1.  **Not-null check:** An attribute is considered null if it is a designated null marker (represented as `None` in implementation) or an empty string. The attributes $id$, $encounter\\_id$, and $code$ must not be null. Violation results in outcome $3$.\n2.  **$id$ domain check:** The $id$ must be a positive integer, i.e., $id \\in \\mathbb{N}^+ = \\{1, 2, 3, \\ldots\\}$. Violation results in outcome $5$.\n3.  **Primary key check:** The $id$ of the new tuple must not already exist in the set of observation IDs, $\\pi_{id}(O)$. That is, $id \\notin \\pi_{id}(O)$. Violation results in outcome $2$.\n4.  **Foreign key check:** The $encounter\\_id$ must refer to an existing encounter. That is, $encounter\\_id \\in \\pi_{id}(E)$. Violation results in outcome $0$.\n5.  **Code domain check:** The $code$ must be a member of the specified controlled vocabulary, $\\mathcal{V}$. That is, $code \\in \\mathcal{V}$. Violation results in outcome $4$.\n6.  **Success:** If all the above checks pass, the insertion is successful, resulting in outcome $1$.\n\nWe will now apply this ordered sequence of checks to each test case.\n\n**Case A: Attempted insertion $o_A = (3002, 2002, \\text{SNOMED:386661006})$**\n1.  **Not-null check:** The attributes $3002$, $2002$, and `'SNOMED:386661006'` are all non-null and not empty strings. Pass.\n2.  **$id$ domain check:** $id=3002$ is a positive integer ($3002 \\in \\mathbb{N}^+$). Pass.\n3.  **Primary key check:** $id=3002$ is not in $\\pi_{id}(O) = \\{3001\\}$. Pass.\n4.  **Foreign key check:** $encounter\\_id=2002$ is in $\\pi_{id}(E) = \\{2001, 2002\\}$. Pass.\n5.  **Code domain check:** $code=\\text{'SNOMED:386661006'}$ is in $\\mathcal{V}$. Pass.\nAll checks pass. The outcome for Case A is $1$.\n\n**Case B: Attempted insertion $o_B = (3003, 9999, \\text{LOINC:718-7})$**\n1.  **Not-null check:** All attributes are non-null. Pass.\n2.  **$id$ domain check:** $id=3003 \\in \\mathbb{N}^+$. Pass.\n3.  **Primary key check:** $id=3003 \\notin \\{3001\\}$. Pass.\n4.  **Foreign key check:** $encounter\\_id=9999$ is not in $\\pi_{id}(E) = \\{2001, 2002\\}$. Fail.\nThe process terminates at the first failure. The outcome for Case B is $0$.\n\n**Case C: Attempted insertion $o_C = (3001, 2002, \\text{LOINC:1234-5})$**\n1.  **Not-null check:** All attributes are non-null. Pass.\n2.  **$id$ domain check:** $id=3001 \\in \\mathbb{N}^+$. Pass.\n3.  **Primary key check:** $id=3001$ is in $\\pi_{id}(O) = \\{3001\\}$. Fail.\nThe process terminates. The outcome for Case C is $2$.\n\n**Case D: Attempted insertion $o_D = (3005, 2002, null)$**\n1.  **Not-null check:** The $code$ attribute is null. Fail.\nThe process terminates. The outcome for Case D is $3$.\n\n**Case E: Attempted insertion $o_E = (3004, 2001, \\text{ICD10:E11})$**\n1.  **Not-null check:** All attributes are non-null. Pass.\n2.  **$id$ domain check:** $id=3004 \\in \\mathbb{N}^+$. Pass.\n3.  **Primary key check:** $id=3004 \\notin \\{3001\\}$. Pass.\n4.  **Foreign key check:** $encounter\\_id=2001 \\in \\{2001, 2002\\}$. Pass.\n5.  **Code domain check:** $code=\\text{'ICD10:E11'}$ is not in $\\mathcal{V}$. Fail.\nThe process terminates. The outcome for Case E is $4$.\n\n**Case F: Attempted insertion $o_F = (-7, 2001, \\text{LOINC:718-7})$**\n1.  **Not-null check:** All attributes are non-null. Pass.\n2.  **$id$ domain check:** $id=-7$ is not a positive integer ($-7 \\notin \\mathbb{N}^+$). Fail.\nThe process terminates. The outcome for Case F is $5$.\n\nSummarizing the results in order from A to F gives the sequence of outcome integers: $[1, 0, 2, 3, 4, 5]$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n# No other libraries outside the Python standard library are permitted.\n\ndef solve():\n    \"\"\"\n    Computes insertion outcomes for healthcare data based on relational model constraints.\n    \"\"\"\n    \n    # 1. Define the read-only initial database state.\n    # Sets are used for efficient membership testing (O(1) average time complexity).\n    patient_ids = {1001, 1002}\n    encounter_ids = {2001, 2002}\n    observation_ids = {3001}\n    vocabulary = {\"LOINC:1234-5\", \"LOINC:718-7\", \"SNOMED:386661006\"}\n\n    # 2. Define the test cases for insertion into the Observation relation.\n    # The format is (id, encounter_id, code).\n    # None is used to represent the null value specified in the problem statement.\n    test_cases = [\n        # Case A (happy path)\n        (3002, 2002, \"SNOMED:386661006\"),\n        # Case B (nonexistent encounter)\n        (3003, 9999, \"LOINC:718-7\"),\n        # Case C (duplicate observation id)\n        (3001, 2002, \"LOINC:1234-5\"),\n        # Case D (not-null code)\n        (3005, 2002, None),\n        # Case E (invalid code)\n        (3004, 2001, \"ICD10:E11\"),\n        # Case F (id domain violation)\n        (-7, 2001, \"LOINC:718-7\"),\n    ]\n\n    results = []\n    \n    # 3. Process each test case according to the specified deterministic evaluation order.\n    for case in test_cases:\n        obs_id, enc_id, code = case\n        \n        # Rule 1: Not-null check\n        if obs_id is None or enc_id is None or code is None or code == \"\":\n            results.append(3)\n            continue\n            \n        # Rule 2: Domain check for id (must be a positive integer)\n        # We also check if it's an integer type to be rigorous.\n        if not isinstance(obs_id, int) or obs_id = 0:\n            results.append(5)\n            continue\n            \n        # Rule 3: Primary key check\n        if obs_id in observation_ids:\n            results.append(2)\n            continue\n            \n        # Rule 4: Foreign key check\n        if enc_id not in encounter_ids:\n            results.append(0)\n            continue\n            \n        # Rule 5: Code domain check\n        if code not in vocabulary:\n            results.append(4)\n            continue\n            \n        # If all checks pass, it's a success\n        results.append(1)\n\n    # 4. Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4833285"}, {"introduction": "In a modern, connected healthcare ecosystem, data must be more than just well-structured; it must be semantically interoperable, meaning it is understood consistently across different systems. This exercise [@problem_id:4833269] introduces you to Fast Healthcare Interoperability Resources (FHIR), the leading standard for achieving this goal. You will implement a core validation rule involving controlled vocabularies, gaining hands-on experience with how standards like FHIR ensure clinical information is exchanged accurately and unambiguously.", "problem": "You are modeling a constraint from Fast Healthcare Interoperability Resources (FHIR) within a programmatic validation framework. In FHIR, Observation.code is a CodeableConcept that can contain multiple codings, each coding being a pair of a system Uniform Resource Identifier (URI) and a code string. You will create an abstract representation of a FHIR profile that restricts Observation.code to a Logical Observation Identifiers Names and Codes (LOINC) value set and implement the validation rule that enforces a “required” binding. The final program must compute the validation outcome for a set of test instances, including cases where an instance uses a code outside the value set expansion.\n\nFundamental base:\n- Set theory and first-order logic: given a set $E$ of allowed codes and a fixed system $S$, a CodeableConcept $C$ with $n$ codings $[(s_1,k_1),\\dots,(s_n,k_n)]$ is valid under a “required” binding if and only if there exists an index $i$ with $1 \\le i \\le n$ such that $s_i = S$ and $k_i \\in E$.\n- FHIR semantics: a “required” binding to a value set asserts that the coded element must draw from the expansion of the value set. For CodeableConcept, validity is satisfied if any coding conforms to the binding; otherwise, the element is invalid.\n\nTask:\n1. Define the LOINC system as the canonical URI string $S = \\text{\"http://loinc.org\"}$.\n2. Define a value set expansion $E$ as the set of allowed LOINC code strings. Use the following expansion: $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$. Treat these as exact string matches.\n3. Define a validation function that, given a CodeableConcept $C$ represented as a list of codings $[(s_1,k_1),\\dots,(s_n,k_n)]$, returns a boolean indicating conformance to the “required” binding. The predicate is:\n$$\\mathrm{valid}(C,E,S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E).$$\nIf $n = 0$, then the predicate is false.\n4. Implement a complete, runnable program that applies this validation to the test suite below and prints a single line containing the list of boolean results in the specified format.\n\nTest suite:\n- Case $1$ (general “happy path”): $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$.\n- Case $2$ (outside expansion): $C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$.\n- Case $3$ (system mismatch): $C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$, where Systematized Nomenclature of Medicine—Clinical Terms (SNOMED CT) is a different system.\n- Case $4$ (multiple codings, one valid): $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$.\n- Case $5$ (boundary, empty coding list): $C = []$.\n- Case $6$ (multiple LOINC codings, one valid and one invalid): $C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$.\n\nOutput specification:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2},\\dots]$).\n- Each result must be a boolean ($\\text{True}$ or $\\text{False}$) corresponding to the validity of the respective test case in the order given above.\n\nAngle units, physical units, and percentage formatting are not applicable to this problem, so none are required.", "solution": "The problem statement has been validated and found to be self-contained, scientifically grounded in set theory and established medical informatics standards (FHIR), and well-posed. All components required for a solution are present and logically consistent.\n\nThe task is to construct a validation function that determines if a Fast Healthcare Interoperability Resources (FHIR) `CodeableConcept` data structure conforms to a \"required\" binding to a specified value set. This problem is an exercise in applying first-order logic to data structure validation.\n\nThe fundamental components of the problem are:\n1. A target coding system, defined as a canonical URI string $S = \\text{\"http://loinc.org\"}$. This represents the Logical Observation Identifiers Names and Codes (LOINC) system.\n2. A value set expansion, which is the set of allowed codes within the target system. This set is given as $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$.\n3. A `CodeableConcept` instance, $C$, which is represented as a list of codings. Each coding is a tuple $(s_i, k_i)$, where $s_i$ is a system URI string and $k_i$ is a code string. Let the number of codings in $C$ be $n$.\n\nThe validation rule is formally defined by the logical predicate:\n$$ \\mathrm{valid}(C, E, S) \\iff \\exists i \\in \\{1,\\dots,n\\}: (s_i = S) \\land (k_i \\in E) $$\nThis predicate asserts that a `CodeableConcept` $C$ is valid if and only if there exists at least one coding $(s_i, k_i)$ in its list such that its system $s_i$ matches the required system $S$ AND its code $k_i$ is a member of the allowed value set expansion $E$. If the list of codings is empty ($n=0$), the existential quantification over an empty set of indices is false, so the `CodeableConcept` is invalid.\n\nTo implement this validation, we will design a function that takes a `CodeableConcept` $C$ as input. Inside this function, we will iterate through each coding $(s_i, k_i)$ from the input list $C$. For each coding, we perform two comparisons:\n1. Is the system string $s_i$ identical to the target system string $S$?\n2. Is the code string $k_i$ present in the value set expansion $E$?\n\nIf both conditions are met for any single coding, the existential condition $\\exists i$ is satisfied. The function can immediately terminate and return `True`. If the function iterates through all the codings in $C$ without finding one that satisfies both conditions, it means no such coding exists. In this case, the function should return `False` after the loop completes. This approach correctly handles the empty list case ($n=0$), as the loop will not execute and the function will proceed to the final return statement, yielding `False`.\n\nFor an efficient implementation, the value set expansion $E$ should be stored in a data structure that provides fast membership testing. A hash set (or `set` in Python) is ideal, offering an average-time complexity of $O(1)$ for lookups.\n\nLet's apply this logic to the provided test suite:\n- **Case 1**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"})]$. Here, $n=1$. The single coding has $s_1 = S$ and $k_1 \\in E$. The predicate is satisfied. Result: `True`.\n- **Case 2**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$. Here, $n=1$. The coding has $s_1 = S$, but $k_1 = \\text{\"99999-9\"} \\notin E$. The predicate is not satisfied. Result: `False`.\n- **Case 3**: $C = [(\\text{\"http://snomed.info/sct\"}, \\text{\"55284-4\"})]$. Here, $n=1$. The coding has $k_1 \\in E$, but $s_1 = \\text{\"http://snomed.info/sct\"} \\neq S$. The predicate is not satisfied. Result: `False`.\n- **Case 4**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"55284-4\"}), (\\text{\"http://snomed.info/sct\"}, \\text{\"123456\"})]$. Here, $n=2$. The first coding $(s_1, k_1)$ has $s_1 = S$ and $k_1 \\in E$. Since we have found one valid coding, the existential condition is met, and we do not need to inspect the rest of the list. Result: `True`.\n- **Case 5**: $C = []$. Here, $n=0$. The set of codings is empty. By definition, the predicate is false. Result: `False`.\n- **Case 6**: $C = [(\\text{\"http://loinc.org\"}, \\text{\"1234-5\"}), (\\text{\"http://loinc.org\"}, \\text{\"99999-9\"})]$. Here, $n=2$. The first coding has $s_1 = S$ and $k_1 = \\text{\"1234-5\"} \\in E$. The condition is satisfied. The fact that the second coding is invalid is irrelevant. Result: `True`.\n\nThe program will implement this logic and apply it to each test case, collecting the boolean outcomes into a list for final formatted printing.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Implements and runs the FHIR CodeableConcept validation logic\n    for a \"required\" binding against a set of test cases.\n    \"\"\"\n    \n    # Task 1: Define the LOINC system as the canonical URI string S.\n    # $S = \\text{\"http://loinc.org\"}$\n    LOINC_SYSTEM = \"http://loinc.org\"\n\n    # Task 2: Define a value set expansion E.\n    # $E = \\{\\text{\"55284-4\"}, \\text{\"1234-5\"}, \\text{\"7890-1\"}\\}$\n    # A set is used for efficient O(1) average time complexity for lookups.\n    VALUE_SET_EXPANSION = {\"55284-4\", \"1234-5\", \"7890-1\"}\n\n    # The test suite as defined in the problem statement.\n    # Each element is a CodeableConcept C represented as a list of codings.\n    # A coding is a tuple of (system, code).\n    test_cases = [\n        # Case 1: General \"happy path\"\n        [(\"http://loinc.org\", \"55284-4\")],\n        # Case 2: Outside expansion\n        [(\"http://loinc.org\", \"99999-9\")],\n        # Case 3: System mismatch\n        [(\"http://snomed.info/sct\", \"55284-4\")],\n        # Case 4: Multiple codings, one valid\n        [(\"http://loinc.org\", \"55284-4\"), (\"http://snomed.info/sct\", \"123456\")],\n        # Case 5: Boundary, empty coding list\n        [],\n        # Case 6: Multiple LOINC codings, one valid and one invalid\n        [(\"http://loinc.org\", \"1234-5\"), (\"http://loinc.org\", \"99999-9\")],\n    ]\n\n    def is_valid_codeable_concept(concept, system, value_set):\n        \"\"\"\n        Validates a CodeableConcept against a required binding to a value set.\n        \n        The predicate is:\n        valid(C, E, S) = exists i in {1,...,n}: (s_i = S) and (k_i in E)\n\n        Args:\n            concept (list): The CodeableConcept, a list of (system, code) tuples.\n            system (str): The required system URI ($S$).\n            value_set (set): The set of allowed codes ($E$).\n\n        Returns:\n            bool: True if the concept is valid, False otherwise.\n        \"\"\"\n        # Iterate through each coding in the CodeableConcept\n        for s_i, k_i in concept:\n            # Check if the coding's system and code match the requirements.\n            # (s_i = S) AND (k_i in E)\n            if s_i == system and k_i in value_set:\n                # If a valid coding is found, the existential condition is met.\n                return True\n        \n        # If the loop completes without finding a valid coding, it fails validation.\n        # This also handles the case of an empty concept list.\n        return False\n\n    results = []\n    for case in test_cases:\n        # Apply the validation function to each test case.\n        result = is_valid_codeable_concept(case, LOINC_SYSTEM, VALUE_SET_EXPANSION)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Example: [True,False,False,True,False,True]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4833269"}]}