{"hands_on_practices": [{"introduction": "The foundation of any medical knowledge graph is the ability to break down complex information into simple, structured statements. The Resource Description Framework (RDF) provides the universal language for this, using 'triples'—a subject, a predicate, and an object—to capture individual facts. This first practice [@problem_id:4849831] guides you through the essential process of translating a common clinical vignette into a set of precise RDF triples, building your foundational skill in knowledge modeling.", "problem": "A hospital knowledge graph is being constructed using the Resource Description Framework (RDF) and Resource Description Framework Schema (RDFS) to represent clinical data. In RDF, a statement is a triple consisting of a subject, a predicate, and an object, where the subject and predicate are Internationalized Resource Identifiers (IRIs), and the object is either an IRI or a literal. In RDFS, class membership is asserted using the predicate rdf:type.\n\nYou are asked to model the following facts for a single patient who has exactly one diagnosis and exactly one laboratory test result:\n- The patient is an instance of the class Patient.\n- The diagnosis is an instance of the class Diagnosis.\n- The laboratory result is an instance of the class LabResult.\n- The patient is connected to the diagnosis by the object property hasDiagnosis.\n- The patient is connected to the laboratory result by the object property hasLabResult.\n- The laboratory result carries three data properties: value (a decimal-typed literal), unit (a string literal), and date (an XML Schema date literal in the lexical form \"YYYY-MM-DD\").\n\nUse the ontology namespace http://med.example.org/ont# for classes and properties (for example, http://med.example.org/ont#Patient, http://med.example.org/ont#hasDiagnosis), and the resource namespace http://med.example.org/res# for individuals (for example, http://med.example.org/res#P001). Represent the lab value as a decimal-typed literal, the unit as a plain string literal such as \"mmol/L\", and the date as an XML Schema date literal in the canonical lexical form \"YYYY-MM-DD\". Do not include any schema axioms beyond class membership assertions (for example, do not include rdfs:domain, rdfs:range, or rdfs:label); use only the minimal set of triples required to encode the above facts under RDF with RDFS typing.\n\nDefine the necessary triples conceptually, then determine the minimal number of distinct RDF triples required to represent all of the above facts for this one patient, one diagnosis, and one laboratory result. Let this count be denoted by $N$. Provide $N$ as your final answer. No rounding is required, and no units are to be included in the final answer.", "solution": "We begin from the core definitions:\n- In the Resource Description Framework (RDF), each fact is encoded as exactly one triple $\\langle s,p,o\\rangle$ consisting of a subject $s$, a predicate $p$, and an object $o$, where $s$ and $p$ are Internationalized Resource Identifiers (IRIs), and $o$ is either an IRI or a literal.\n- In the Resource Description Framework Schema (RDFS), class membership is asserted using the predicate rdf:type; that is, an individual $x$ being an instance of a class $C$ is represented by the triple $\\langle x,\\text{rdf:type},C\\rangle$.\n- Object properties connect two IRIs (for example, an individual patient IRI to an individual diagnosis IRI), and data properties connect an IRI to a literal (for example, a laboratory result individual to a numeric value literal).\n\nUnder the modeling constraints specified, we must assert the following facts:\n1. The individual patient is of class Patient.\n2. The individual diagnosis is of class Diagnosis.\n3. The individual laboratory result is of class LabResult.\n4. The patient is related to the diagnosis via hasDiagnosis.\n5. The patient is related to the laboratory result via hasLabResult.\n6. The laboratory result has a value data property whose object is a decimal-typed literal.\n7. The laboratory result has a unit data property whose object is a string literal.\n8. The laboratory result has a date data property whose object is an XML Schema date-typed literal.\n\nEach of these facts requires one RDF triple by definition; no single triple can encode two independent facts in RDF. Therefore, the minimal representation will contain one triple for each of the above eight facts.\n\nTo make this concrete, using the provided namespaces:\n- Use IRIs such as http://med.example.org/res#P001 for the patient, http://med.example.org/res#DxA for the diagnosis, and http://med.example.org/res#LRB for the lab result.\n- Use ontology IRIs http://med.example.org/ont#Patient, http://med.example.org/ont#Diagnosis, http://med.example.org/ont#LabResult for classes and http://med.example.org/ont#hasDiagnosis, http://med.example.org/ont#hasLabResult, http://med.example.org/ont#value, http://med.example.org/ont#unit, http://med.example.org/ont#date for properties.\n\nA conceptual listing of the triples is:\n- ⟨http://med.example.org/res#P001, rdf:type, http://med.example.org/ont#Patient⟩\n- ⟨http://med.example.org/res#DxA, rdf:type, http://med.example.org/ont#Diagnosis⟩\n- ⟨http://med.example.org/res#LRB, rdf:type, http://med.example.org/ont#LabResult⟩\n- ⟨http://med.example.org/res#P001, http://med.example.org/ont#hasDiagnosis, http://med.example.org/res#DxA⟩\n- ⟨http://med.example.org/res#P001, http://med.example.org/ont#hasLabResult, http://med.example.org/res#LRB⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#value, \"v\"^^xsd:decimal⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#unit, \"mmol/L\"⟩\n- ⟨http://med.example.org/res#LRB, http://med.example.org/ont#date, \"YYYY-MM-DD\"^^xsd:date⟩\n\nCounting these, the total number of distinct triples is $N = 8$.\n\nTo argue minimality, observe:\n- Omitting any rdf:type triple would fail to represent one of the required class membership facts (Patient, Diagnosis, or LabResult).\n- Omitting any object property triple would fail to represent one of the required relationships (hasDiagnosis or hasLabResult).\n- Omitting any data property triple would fail to represent one of the required attributes (value, unit, or date).\n- Combining any two of these facts into one triple is not possible in standard RDF, because each triple has exactly one predicate and cannot simultaneously encode two independent predicates or both class membership and a property assertion.\n\nTherefore, the minimal number of triples required is $8$.", "answer": "$$\\boxed{8}$$", "id": "4849831"}, {"introduction": "Once clinical data is modeled in a knowledge graph, its true value is unlocked by asking complex questions. The SPARQL Protocol and RDF Query Language (SPARQL) is the standard for this, allowing us to retrieve specific patterns from the vast web of interconnected data. This exercise [@problem_id:4849805] places you in the role of a clinical data analyst, tasked with constructing a query to identify patients based on a time-sensitive trend in their lab results, a common and critical task in clinical informatics.", "problem": "You are given a simplified medical laboratory data model inspired by the Resource Description Framework (RDF) and SPARQL Protocol and RDF Query Language (SPARQL). The model represents laboratory observations as triples of the form $\\langle s, p, o \\rangle$, where a subject $s$ is an observation resource, a predicate $p$ is a property such as the patient reference or the measurement time, and an object $o$ is a patient resource, a literal value, or another resource. In SPARQL, Basic Graph Patterns (BGPs) join on shared variables to form bindings; for example, variables $?o_1$, $?o_2$ can be joined on a shared variable $?patient$ to assert they refer to the same patient. You will work with troponin laboratory observations, which in clinical practice represent cardiac biomarkers. We assume that an observation has the following core properties: type, patient subject, code, interpretation, and an effective time measured as decimal hours since admission.\n\nFundamental base:\n- In RDF, an observation is represented by triples of the form $\\langle \\text{obs}, \\text{predicate}, \\text{object} \\rangle$.\n- In SPARQL, a Basic Graph Pattern is the conjunction of triple patterns and joins are performed on shared variables, yielding solution mappings.\n- A time window constraint is expressible as an arithmetic filter over literals, such as requiring $0 < t_2 - t_1 \\le 24$, where $t_1$ and $t_2$ are numeric literals denoting hours.\n\nTask:\n1. Construct a SPARQL SELECT query that returns distinct patients $?patient$ who have two distinct abnormal troponin observations $?o_1$ and $?o_2$ within a $24$ hour window. Observations must satisfy:\n   - Both observation codes $?c_1$ and $?c_2$ are troponin codes.\n   - Both observations have interpretation equal to abnormal.\n   - The two observations are distinct, i.e., $?o_1 \\ne ?o_2$.\n   - Their effective times $t_1$ and $t_2$ are numeric decimal hours and satisfy $0 < t_2 - t_1 \\le 24$.\n   You must rely on standard SPARQL $1.1$ constructs, Basic Graph Patterns, joins on shared variables, and arithmetic FILTER conditions on numeric literals (hours). Do not rely on vendor-specific date functions. The query must use variable bindings for observations $?o_1$, $?o_2$, patient $?patient$, codes $?c_1$, $?c_2$, and effective times $?t_1$, $?t_2$, and must select distinct $?patient$.\n\n2. Implement a program that, without executing SPARQL, computes the same set of patients for provided synthetic test datasets by performing the equivalent logical joins and filters over arrays of observations. Each observation is represented by a record containing: patient identifier (integer), code (string), time in hours (float), value (float), unit (string), and abnormal flag (boolean). The troponin code set consists of two codes, and an observation is considered abnormal if its abnormal flag is true. A patient qualifies if there exists a pair of distinct abnormal troponin observations with times $t_1$ and $t_2$ satisfying $0 < t_2 - t_1 \\le 24$ hours, measured in hours, with $t_2 > t_1$.\n\nUnits and constraints:\n- Time must be treated in hours; all time comparisons and differences are to be computed in hours.\n- The inequality $0 < t_2 - t_1 \\le 24$ must be strictly enforced; equal timestamps ($t_2 - t_1 = 0$) do not qualify.\n- The pairwise condition applies across any troponin codes; the two observations can have different troponin codes.\n\nTest suite:\nProvide a solution for the following four parameter sets, each a list of observations represented as tuples $(\\text{patient\\_id}, \\text{code}, t, v, \\text{unit}, \\text{abnormal})$ where $t$ is the time in hours, $v$ is the measured value, unit is a string (always \"ng/mL\" in these tests), and abnormal is a boolean.\n\n- Case A (general case):\n  - Troponin codes: \"LOINC:89579-7\", \"LOINC:67151-1\".\n  - Observations:\n    - $(1, \\text{\"LOINC:89579-7\"}, 1.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(1, \\text{\"LOINC:89579-7\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(2, \\text{\"LOINC:89579-7\"}, 5.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(2, \\text{\"LOINC:89579-7\"}, 15.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 0.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 12.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n    - $(3, \\text{\"LOINC:67151-1\"}, 36.0, 0.09, \\text{\"ng/mL\"}, \\text{true})$\n    - $(4, \\text{\"LOINC:89579-7\"}, 0.0, 0.10, \\text{\"ng/mL\"}, \\text{true})$\n    - $(4, \\text{\"LOINC:89579-7\"}, 50.0, 0.09, \\text{\"ng/mL\"}, \\text{true})$\n- Case B (boundary and violations):\n  - Observations:\n    - $(5, \\text{\"LOINC:89579-7\"}, 0.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(5, \\text{\"LOINC:89579-7\"}, 24.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(6, \\text{\"LOINC:67151-1\"}, 0.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(6, \\text{\"LOINC:67151-1\"}, 24.1, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(7, \\text{\"LOINC:67151-1\"}, 0.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(7, \\text{\"LOINC:67151-1\"}, 0.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n- Case C (multiple pairs and non-troponin noise):\n  - Observations:\n    - $(8, \\text{\"LOINC:89579-7\"}, 10.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(8, \\text{\"LOINC:89579-7\"}, 12.0, 0.07, \\text{\"ng/mL\"}, \\text{true})$\n    - $(8, \\text{\"LOINC:89579-7\"}, 13.0, 0.08, \\text{\"ng/mL\"}, \\text{true})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 0.0, 0.05, \\text{\"ng/mL\"}, \\text{true})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 10.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(9, \\text{\"LOINC:89579-7\"}, 30.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(10, \\text{\"NON-TROPONIN\"}, 5.0, 2.0, \\text{\"ng/mL\"}, \\text{true})$\n- Case D (different troponin codes mixed):\n  - Observations:\n    - $(11, \\text{\"LOINC:89579-7\"}, 1.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(11, \\text{\"LOINC:67151-1\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(12, \\text{\"LOINC:89579-7\"}, 1.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(12, \\text{\"LOINC:67151-1\"}, 30.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n    - $(13, \\text{\"LOINC:67151-1\"}, 5.0, 0.03, \\text{\"ng/mL\"}, \\text{false})$\n    - $(13, \\text{\"LOINC:67151-1\"}, 20.0, 0.06, \\text{\"ng/mL\"}, \\text{true})$\n\nOutput specification:\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case, and is itself a list of distinct qualifying patient identifiers in ascending order. For example, the output must look like $[[a_1,a_2],[b_1],[],[c_1,c_2]]$ where each $a_i$, $b_i$, $c_i$ is an integer.\n\nDefinitions of acronyms:\n- Resource Description Framework (RDF).\n- SPARQL Protocol and RDF Query Language (SPARQL).\n- Web Ontology Language (OWL).\n\nAnswer type:\n- The program’s output must be a list of lists of integers. No physical units or percentage symbols are to be printed; all internal time computations must be in hours.", "solution": "We first present the SPARQL query and then derive an algorithmic procedure that is equivalent to the query’s Basic Graph Pattern and FILTER semantics.\n\nSPARQL SELECT query:\nLet $\\text{ex}$ be a namespace for example medical entities and $\\text{xsd}$ be the XML Schema Definition namespace. We assume that observation effective times are stored as literals of type $\\text{xsd:decimal}$ in hours. The troponin code set contains two codes represented by Internationalized Resource Identifiers (IRIs). The query binds two observation variables $?o_1$ and $?o_2$, a shared patient variable $?patient$, their codes $?c_1$, $?c_2$, and times $?t_1$, $?t_2$. We use Basic Graph Pattern joins on $?patient$ and arithmetic FILTERs to enforce the time window.\n\nPrefixes:\n- $\\texttt{PREFIX ex: <http://example.org/med/>}$\n- $\\texttt{PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>}$\n\nQuery:\n- $\\texttt{SELECT DISTINCT ?patient WHERE \\{}$\n  - $\\texttt{?o1 a ex:Observation ;}$\n  - $\\quad\\texttt{ex:subject ?patient ;}$\n  - $\\quad\\texttt{ex:code ?c1 ;}$\n  - $\\quad\\texttt{ex:interpretation ex:Abnormal ;}$\n  - $\\quad\\texttt{ex:effectiveTimeHours ?t1 .}$\n  - $\\texttt{?o2 a ex:Observation ;}$\n  - $\\quad\\texttt{ex:subject ?patient ;}$\n  - $\\quad\\texttt{ex:code ?c2 ;}$\n  - $\\quad\\texttt{ex:interpretation ex:Abnormal ;}$\n  - $\\quad\\texttt{ex:effectiveTimeHours ?t2 .}$\n  - $\\texttt{FILTER (?o1 != ?o2)}$\n  - $\\texttt{FILTER (?c1 IN (ex:loinc\\_89579\\_7, ex:loinc\\_67151\\_1) && ?c2 IN (ex:loinc\\_89579\\_7, ex:loinc\\_67151\\_1))}$\n  - $\\texttt{FILTER ((?t2 - ?t1) > 0 && (?t2 - ?t1) <= 24)}$\n- $\\texttt{\\}}$\n\nExplanation of joins and filters:\n- A Basic Graph Pattern (BGP) is a conjunction of triple patterns. Variables $?o_1$, $?o_2$, and $?patient$ are bound by matching triples. The shared variable $?patient$ induces a natural join: only bindings where both $?o_1$ and $?o_2$ share the same $?patient$ are retained.\n- The predicate constraints $\\texttt{ex:interpretation ex:Abnormal}$ filter bindings to abnormal observations.\n- The code constraints via $\\texttt{IN}$ restrict $?c_1$ and $?c_2$ to the troponin code set.\n- The inequality $\\texttt{FILTER ((?t2 - ?t1) > 0 && (?t2 - ?t1) <= 24)}$ enforces $0 < t_2 - t_1 \\le 24$ hours using numeric arithmetic over $\\text{xsd:decimal}$ literals in hours. This excludes equal timestamps ($t_2 - t_1 = 0$) and includes exactly $24$ hours as a valid boundary.\n\nPrinciple-based algorithm for evaluation without SPARQL:\nWe emulate the BGP and FILTER logic procedurally:\n1. Let $O$ be the set of observations as records with fields $\\{\\text{patient\\_id}, \\text{code}, t, v, \\text{unit}, \\text{abnormal}\\}$ where $t$ is time in hours.\n2. Define the troponin code set $T = \\{\\text{\"LOINC:89579-7\"}, \\text{\"LOINC:67151-1\"}\\}$.\n3. For each patient $p$, collect the list $L_p = [t_i]$ of times $t_i$ such that the observation has $\\text{code} \\in T$ and $\\text{abnormal} = \\text{true}$. This step corresponds to matching the BGP triple patterns and restricting bindings by interpretation and code, as in the query’s $\\texttt{IN}$ constraints.\n4. For each patient $p$, sort $L_p$ ascending to obtain $t_{(1)} \\le t_{(2)} \\le \\dots \\le t_{(k)}$.\n5. Determine whether there exists a pair $(t_{(i)}, t_{(j)})$ with $i < j$ such that $0 < t_{(j)} - t_{(i)} \\le 24$. This checks the FILTER constraint with arithmetic on hours. Existence of such a pair corresponds to the combined bindings of $?o_1$ and $?o_2$ satisfying the inequality. The strict inequality excludes identical times, ensuring distinctness beyond the $\\texttt{?o1 != ?o2}$ constraint, while the query’s explicit $\\texttt{?o1 != ?o2}$ also ensures distinct resources even if identical timestamps exist.\n6. If such a pair exists, include $p$ in the output set for that test case.\n7. Return the list of qualifying patients per test case in ascending order.\n\nCorrectness justification from first principles:\n- RDF triples and SPARQL BGPs yield sets of variable bindings. Joining $?o_1$ and $?o_2$ on $?patient$ implements a relational natural join, which guarantees that both observations are for the same patient $p$.\n- Restricting codes to $T$ and interpretations to abnormal implements set membership filters directly analogous to SPARQL’s $\\texttt{IN}$ and triple constraints.\n- Sorting times and checking existence of a pair with $0 < t_2 - t_1 \\le 24$ realizes the numeric FILTER. Because $t$ is in hours, arithmetic is consistent and directly comparable across all observations. The open lower bound enforces that the two observations are temporally distinct, and the closed upper bound enforces the $24$ hour window inclusively.\n- The algorithm ensures distinct patient outputs by accumulating patients in a set and then sorting.\n\nApplying the algorithm to the test suite:\n- Case A: Patient $1$ has times $[1.0, 20.0]$ with difference $19.0$, qualifying. Patient $2$ has only one abnormal troponin, not qualifying. Patient $3$ has times $[0.0, 12.0, 36.0]$ with pairs $(0.0, 12.0)$ difference $12.0$ and $(12.0, 36.0)$ difference $24.0$, qualifying. Patient $4$ has times $[0.0, 50.0]$ with difference $50.0$, not qualifying. Output: $[1, 3]$.\n- Case B: Patient $5$ has times $[0.0, 24.0]$ with difference $24.0$, qualifying. Patient $6$ has $[0.0, 24.1]$ difference $24.1$, not qualifying. Patient $7$ has $[0.0, 0.0]$ difference $0.0$, not qualifying. Output: $[5]$.\n- Case C: Patient $8$ has times $[10.0, 12.0, 13.0]$ with differences $2.0$ and $1.0$, qualifying. Patient $9$ has $[0.0, 30.0]$ with difference $30.0$, not qualifying. Patient $10$ has non-troponin code and is ignored. Output: $[8]$.\n- Case D: Patient $11$ has mixed codes with times $[1.0, 20.0]$ difference $19.0$, qualifying. Patient $12$ has times $[1.0, 30.0]$ difference $29.0$, not qualifying. Patient $13$ has only one abnormal troponin, not qualifying. Output: $[11]$.\n\nThe program aggregates these four lists into a single line in the specified output format, e.g., $[[1,3],[5],[8],[11]]$.", "answer": "```python\n# Python 3.12 compliant solution.\n# Libraries allowed: numpy (1.23.5), scipy (1.11.4) – we only use numpy for potential array handling.\nimport numpy as np\n\ndef qualifying_patients(observations, troponin_codes, window_hours=24.0):\n    \"\"\"\n    Determine patients with at least two distinct abnormal troponin observations\n    within a time window of window_hours, with strict positivity (t2 > t1)\n    and inclusive upper bound (t2 - t1 <= window_hours).\n    observations: list of dicts with keys:\n        patient_id (int), code (str), time_hours (float), value (float),\n        unit (str), abnormal (bool)\n    troponin_codes: set of strings indicating troponin codes to include.\n    Returns sorted list of distinct qualifying patient_ids.\n    \"\"\"\n    # Group relevant (troponin + abnormal) times by patient.\n    by_patient = {}\n    for obs in observations:\n        code = obs[\"code\"]\n        if code in troponin_codes and obs[\"abnormal\"]:\n            pid = obs[\"patient_id\"]\n            t = float(obs[\"time_hours\"])\n            by_patient.setdefault(pid, []).append(t)\n\n    qualifying = set()\n    for pid, times in by_patient.items():\n        if len(times) < 2:\n            continue\n        times_sorted = sorted(times)\n        # Check for any pair within the window with strict positive difference.\n        # Since data is small, use nested loops; for larger data, a two-pointer approach would be efficient.\n        n = len(times_sorted)\n        i = 0\n        j = 1\n        # Two-pointer: advance j while within window; advance i to maintain positivity.\n        # We still need to check all pairs because inclusive upper bound and sparse data.\n        found = False\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                diff = times_sorted[j] - times_sorted[i]\n                if diff <= 0:\n                    continue  # enforce strict positivity\n                if diff <= window_hours:\n                    qualifying.add(pid)\n                    found = True\n                    break\n            if found:\n                break\n\n    return sorted(qualifying)\n\ndef solve():\n    troponin_codes = {\"LOINC:89579-7\", \"LOINC:67151-1\"}\n\n    # Define test cases from the problem statement.\n    case_A = [\n        {\"patient_id\": 1, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 1, \"code\": \"LOINC:89579-7\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 2, \"code\": \"LOINC:89579-7\", \"time_hours\": 5.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 2, \"code\": \"LOINC:89579-7\", \"time_hours\": 15.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 12.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 3, \"code\": \"LOINC:67151-1\", \"time_hours\": 36.0, \"value\": 0.09, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 4, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.10, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 4, \"code\": \"LOINC:89579-7\", \"time_hours\": 50.0, \"value\": 0.09, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_B = [\n        {\"patient_id\": 5, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 5, \"code\": \"LOINC:89579-7\", \"time_hours\": 24.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 6, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 6, \"code\": \"LOINC:67151-1\", \"time_hours\": 24.1, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 7, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 7, \"code\": \"LOINC:67151-1\", \"time_hours\": 0.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_C = [\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 10.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 12.0, \"value\": 0.07, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 8, \"code\": \"LOINC:89579-7\", \"time_hours\": 13.0, \"value\": 0.08, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 0.0, \"value\": 0.05, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 10.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 9, \"code\": \"LOINC:89579-7\", \"time_hours\": 30.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 10, \"code\": \"NON-TROPONIN\", \"time_hours\": 5.0, \"value\": 2.0, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    case_D = [\n        {\"patient_id\": 11, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 11, \"code\": \"LOINC:67151-1\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 12, \"code\": \"LOINC:89579-7\", \"time_hours\": 1.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 12, \"code\": \"LOINC:67151-1\", \"time_hours\": 30.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n        {\"patient_id\": 13, \"code\": \"LOINC:67151-1\", \"time_hours\": 5.0, \"value\": 0.03, \"unit\": \"ng/mL\", \"abnormal\": False},\n        {\"patient_id\": 13, \"code\": \"LOINC:67151-1\", \"time_hours\": 20.0, \"value\": 0.06, \"unit\": \"ng/mL\", \"abnormal\": True},\n    ]\n\n    test_cases = [case_A, case_B, case_C, case_D]\n\n    results = []\n    for obs_list in test_cases:\n        results.append(qualifying_patients(obs_list, troponin_codes, window_hours=24.0))\n\n    # Final print statement in the exact required format: a single line.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4849805"}, {"introduction": "A robust knowledge base must not only store data but also enforce rules to ensure its quality and logical consistency. Two key technologies for this are the Web Ontology Language (OWL) and the Shapes Constraint Language (SHACL), which serve different but complementary purposes. This advanced practice [@problem_id:4849810] presents a scenario with conflicting data to illuminate the fundamental difference between OWL's logic-based inference, which reasons about the data and can declare a model inconsistent, and SHACL's role as a validation tool that checks for and reports non-conformance.", "problem": "A hospital maintains an ontology for patients and their demographic data to support clinical decision support and interoperability. The ontology is modeled in the Web Ontology Language (OWL), and data quality is checked using the Shapes Constraint Language (SHACL). Consider the following modeling intent for a data property that links each patient to their date of birth: an individual of class Patient should have at most one date of birth. In OWL 2 Description Logic notation, one way to encode this intent is the class axiom $$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$$ and equivalently, one can declare the data property hasDateOfBirth to be functional. In SHACL, one might encode this intent in a property shape with a maximum count, for example, a shape that targets Patient nodes and contains the constraint “maxCount $1$” on the path hasDateOfBirth with datatype xsd:date.\n\nA particular data graph for an individual patient p123 contains the following two data property assertions, each with a distinct date value: hasDateOfBirth(p123, \"1980-05-17\"^^xsd:date) and hasDateOfBirth(p123, \"1982-05-17\"^^xsd:date). The individual p123 is also asserted to be of type Patient. Assume standard OWL 2 Direct Semantics for datatypes and the usual Open World Assumption in OWL, and assume standard SHACL validation semantics counting value nodes for maxCount.\n\nWhich option best characterizes, from first principles, the different behaviors of OWL inference versus SHACL validation on this dataset with duplicates, and correctly demonstrates the encodings?\n\nA. In OWL, encoding the intent as $$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$$ (or making hasDateOfBirth functional) forces any two date-of-birth values for a Patient to be equal; since \"1980-05-17\" and \"1982-05-17\" denote distinct $\\text{xsd:date}$ values, the ontology has no model and becomes logically inconsistent. In SHACL, encoding the intent with a property shape using maxCount $1$ on hasDateOfBirth causes the validator to count $2$ value nodes for p123 and report a violation; SHACL does not infer equalities or modify the data graph.\n\nB. In OWL, the Open World Assumption means no violation or inconsistency can be detected when two hasDateOfBirth assertions exist; with the SHACL shape having maxCount $1$, validation passes because both values conform to datatype xsd:date, and datatype conformance suffices for maxCount.\n\nC. In OWL, cardinality constraints on data properties cause the reasoner to merge all data values of the same datatype, so the two dates are inferred equal and no inconsistency occurs; in SHACL, maxCount $1$ triggers an automatic repair by deleting one of the two values to enforce the constraint.\n\nD. In OWL, duplicates are tolerated because the Unique Name Assumption does not apply to literals, so two date-of-birth assertions never cause inconsistency; in SHACL, a violation is reported only if the two values are unequal under datatype semantics, but if the two assertions repeat the same date literal twice, maxCount $1$ passes since SHACL counts distinct values, not occurrences.", "solution": "The user is asking for an analysis of the behavior of OWL reasoners and SHACL validators on a specific dataset containing conflicting information, based on the formal semantics of each language.\n\n### Step 1: Extract Givens\n\n-   **Domain:** An ontology for patients and demographic data.\n-   **Technologies:** Web Ontology Language (OWL) for modeling, Shapes Constraint Language (SHACL) for data quality checks.\n-   **Modeling Intent:** An individual of class `Patient` should have at most one date of birth.\n-   **OWL Encoding of Intent:**\n    1.  Class Axiom: `$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$`\n    2.  Property Characteristic: The data property `hasDateOfBirth` is declared as functional (`FunctionalDataProperty`).\n-   **SHACL Encoding of Intent:** A property shape targeting `Patient` nodes containing the constraint `$\\text{maxCount} \\ 1$` on the path `hasDateOfBirth` with datatype `$\\text{xsd:date}$`.\n-   **Data Graph:**\n    1.  Individual `p123` is of type `Patient`.\n    2.  Assertion 1: `$\\text{hasDateOfBirth}(p123, \\text{\"1980-05-17\"^^xsd:date})$`.\n    3.  Assertion 2: `$\\text{hasDateOfBirth}(p123, \\text{\"1982-05-17\"^^xsd:date})$`.\n-   **Semantic Assumptions:**\n    1.  Standard OWL 2 Direct Semantics for datatypes.\n    2.  The Open World Assumption (OWA) in OWL.\n    3.  Standard SHACL validation semantics counting value nodes for `maxCount`.\n\n### Step 2: Validate Using Extracted Givens\n\nThe problem statement is scientifically grounded, well-posed, and objective.\n-   **Scientifically Grounded:** The problem is based on the formal specifications of OWL 2 and SHACL, which are W3C standards and form the basis of formal knowledge representation and a significant area of computer science. The concepts of logical inconsistency, inference, datatype semantics, and validation are well-defined within these frameworks.\n-   **Well-Posed:** The problem provides a specific set of axioms (the OWL constraint), a specific set of data assertions, and a specific SHACL shape. It asks for the outcome of applying the respective formalisms (OWL reasoning and SHACL validation) to this concrete setup. The outcome is uniquely determined by the semantics of these languages.\n-   **Objective:** The language is formal and precise. Terms like `functional property`, `cardinality restriction`, `logical inconsistency`, and `validation violation` have unambiguous technical meanings.\n\nThe problem does not violate any of the invalidity criteria. It is a well-formed question about the fundamental differences between the model-theoretic, inferential semantics of OWL and the graph-validation semantics of SHACL.\n\n### Step 3: Verdict and Action\n\nThe problem statement is **valid**. I will proceed with deriving the solution and evaluating the options.\n\n### Principle-Based Derivation\n\n#### OWL Behavior Analysis\n\n1.  The problem states that the intent of \"at most one date of birth\" is encoded in OWL either by declaring the data property `hasDateOfBirth` to be functional or by the axiom `$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$`. These two formulations are semantically equivalent for this purpose. A functional property `P` means that for any `x`, if `P(x, y)` and `P(x, z)`, then `y` and `z` must be the same. The qualified cardinality restriction `$\\leq 1 P.T$` on a class `C` means that any instance of `C` can be related via property `P` to at most one instance of class/datatype `T`.\n2.  The data graph asserts that the individual `p123` is of class `Patient`: `$\\text{Patient}(p123)$`.\n3.  The data graph also contains two assertions for `p123`: `$\\text{hasDateOfBirth}(p123, d_1)$` and `$\\text{hasDateOfBirth}(p123, d_2)$`, where `$d_1 = \\text{\"1980-05-17\"^^xsd:date}$` and `$d_2 = \\text{\"1982-05-17\"^^xsd:date}$`.\n4.  Because `p123` is a `Patient`, the OWL axiom `$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$` applies. This forces an OWL reasoner to conclude that `$d_1$` and `$d_2$` must be the same value.\n5.  The problem specifies \"standard OWL 2 Direct Semantics for datatypes\". For the `$\\text{xsd:date}$` datatype, the value space is the set of dates. The literals `$\\text{\"1980-05-17\"}$` and `$\\text{\"1982-05-17\"}$` denote two different points in this value space. Therefore, the built-in semantics of the datatype include the fact that `$d_1 \\neq d_2$`.\n6.  The reasoner is thus forced to hold two contradictory facts: `$d_1 = d_2$` (from the cardinality restriction) and `$d_1 \\neq d_2$` (from the datatype semantics). A logical system that entails a contradiction (e.g., `$A \\land \\neg A$`) is called inconsistent. An inconsistent ontology has no model, meaning there is no possible interpretation of the world that would make all the statements true simultaneously.\n7.  The Open World Assumption (OWA) does not prevent this conclusion. OWA means that the absence of a statement does not make it false. Here, we are not dealing with an absence of information; we are dealing with the presence of explicit statements (the data and the axiom) that logically contradict one another.\n\nTherefore, an OWL reasoner processing this ontology and data will report that the knowledge base is logically inconsistent.\n\n#### SHACL Behavior Analysis\n\n1.  SHACL is a language for *validating* graph data against a set of conditions, called shapes. It is not an inference language in the way OWL is. It checks if the data, as it is, conforms to the rules.\n2.  The SHACL encoding is a property shape targeting `Patient` nodes. The individual `p123` is an instance of `Patient`, so it is a focus node for this shape.\n3.  The shape contains the constraint `$\\text{sh:maxCount} \\ 1$` on the path `hasDateOfBirth`. `$\\text{sh:maxCount}$` is a constraint on the number of value nodes.\n4.  To validate `p123`, the SHACL validator finds all values connected to `p123` via the `hasDateOfBirth` path. These values are `$\\{\\text{\"1980-05-17\"^^xsd:date}, \\text{\"1982-05-17\"^^xsd:date}\\}$`.\n5.  The validator then counts the number of nodes in this set. The count is `$2$`.\n6.  The constraint is `$\\text{sh:maxCount} \\ 1$`. Since `$2 > 1$`, the constraint is violated.\n7.  Upon finding a violation, a standard SHACL validator generates a validation report detailing the violation (which focus node, which path, which constraint, etc.). It does not infer that the two dates are equal, nor does it modify or \"repair\" the data graph. Its function is to report non-conformance.\n\n### Option-by-Option Analysis\n\n**A. In OWL, encoding the intent as `$\\text{Patient} \\sqsubseteq (\\leq 1\\ \\text{hasDateOfBirth}.\\text{xsd:date})$` (or making hasDateOfBirth functional) forces any two date-of-birth values for a Patient to be equal; since \"1980-05-17\" and \"1982-05-17\" denote distinct `$\\text{xsd:date}$` values, the ontology has no model and becomes logically inconsistent. In SHACL, encoding the intent with a property shape using maxCount `$1$` on hasDateOfBirth causes the validator to count `$2$` value nodes for p123 and report a violation; SHACL does not infer equalities or modify the data graph.**\n-   **OWL part:** This is a precise and correct description of the outcome. The cardinality restriction implies equality, which contradicts the datatype semantics for the two different date literals, leading to logical inconsistency.\n-   **SHACL part:** This is also a precise and correct description. The `maxCount` constraint is on the cardinality of the set of value nodes. There are `$2$` such nodes, which exceeds the limit of `$1$`, resulting in a violation report. SHACL's role as a validator, not an reasoner or repair tool, is correctly stated.\n-   **Verdict:** **Correct**\n\n**B. In OWL, the Open World Assumption means no violation or inconsistency can be detected when two hasDateOfBirth assertions exist; with the SHACL shape having maxCount `$1$`, validation passes because both values conform to datatype xsd:date, and datatype conformance suffices for maxCount.**\n-   **OWL part:** This misinterprets the Open World Assumption. OWA concerns missing information, not explicit contradictions. The provided axioms and data create a direct logical contradiction that an OWL reasoner is designed to detect.\n-   **SHACL part:** This misinterprets the `maxCount` constraint. While `$\\text{sh:datatype}$` checks for type conformance, `$\\text{sh:maxCount}$` counts the number of values. The existence of `$2$` values, even if they are valid dates, violates `$\\text 'sh:maxCount} \\ 1$`.\n-   **Verdict:** **Incorrect**\n\n**C. In OWL, cardinality constraints on data properties cause the reasoner to merge all data values of the same datatype, so the two dates are inferred equal and no inconsistency occurs; in SHACL, maxCount `$1$` triggers an automatic repair by deleting one of the two values to enforce the constraint.**\n-   **OWL part:** The reasoner does infer equality, but this is precisely what *causes* the inconsistency. Literals, unlike named individuals (resources), have a fixed identity based on their value. Forcing two distinct literals like `$1$` and `$2$`, or two different dates, to be equal is a contradiction. The claim that \"no inconsistency occurs\" is false.\n-   **SHACL part:** Standard SHACL validation does not perform \"automatic repair\". Its purpose is to report violations. While extensions or related technologies might perform repair, it is not the default behavior of SHACL validation as described.\n-   **Verdict:** **Incorrect**\n\n**D. In OWL, duplicates are tolerated because the Unique Name Assumption does not apply to literals, so two date-of-birth assertions never cause inconsistency; in SHACL, a violation is reported only if the two values are unequal under datatype semantics, but if the two assertions repeat the same date literal twice, maxCount `$1$` passes since SHACL counts distinct values, not occurrences.**\n-   **OWL part:** This statement is confused. The Unique Name Assumption (or lack thereof) applies to names of individuals (URIs), not to literals. The identity of literals is determined by their value space. The inconsistency arises not from naming, but from the cardinality constraint forcing two provably distinct values to be equal.\n-   **SHACL part:** While the second half of this statement is technically correct (SHACL's `maxCount` considers the set of distinct value nodes, so two identical triples would lead to a count of `$1$`), the overall characterization is misleading and the OWL part is fundamentally wrong. The key point in this problem is the behavior with *distinct* values, which this option deflects from.\n-   **Verdict:** **Incorrect**\n\nBased on the analysis, Option A provides the only accurate and comprehensive description of the behaviors of both OWL and SHACL in the given scenario, correctly contrasting OWL's inferential, model-theoretic approach with SHACL's data validation approach.", "answer": "$$\\boxed{A}$$", "id": "4849810"}]}