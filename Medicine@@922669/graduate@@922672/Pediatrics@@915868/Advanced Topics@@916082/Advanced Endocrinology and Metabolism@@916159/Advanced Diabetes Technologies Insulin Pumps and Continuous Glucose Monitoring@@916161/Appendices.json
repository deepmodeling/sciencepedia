{"hands_on_practices": [{"introduction": "The concept of \"Insulin-On-Board\" ($IOB$) is fundamental to the safety and efficacy of insulin pump therapy. Because rapid-acting insulin has a duration of action spanning several hours, administering multiple correction boluses in close succession can lead to an accumulation of effect, or \"insulin stacking,\" significantly increasing the risk of hypoglycemia. This exercise [@problem_id:5099481] provides a hands-on opportunity to calculate $IOB$ from first principles, using a standard pharmacodynamic model to quantify the residual action of prior doses and adjust a new correction bolus accordingly.", "problem": "A pediatric patient with Type 1 diabetes mellitus uses an insulin pump integrated with Continuous Glucose Monitoring (CGM). Let the pharmacodynamic impulse response of a rapid-acting insulin bolus be modeled as a linear time-invariant system with impulse response kernel $w(\\tau)$, where $\\tau$ denotes elapsed time since the bolus. Assume the following widely used and physiologically plausible Erlang-$3$ kernel:\n$$\nw(\\tau) \\;=\\; \\frac{\\lambda^{3}\\,\\tau^{2}\\,\\exp(-\\lambda\\,\\tau)}{2}, \\quad \\tau \\ge 0,\n$$\nwith rate parameter $\\lambda = 1 \\,\\text{h}^{-1}$. The kernel is normalized so that $\\int_{0}^{\\infty} w(\\tau)\\,d\\tau = 1$, and the linear superposition principle applies (i.e., responses to multiple boluses add).\n\nInsulin-on-Board (IOB) at time $T$ contributed by a bolus of magnitude $D$ given at time $t_i$ is defined as the residual fraction of the bolus yet to act, multiplied by $D$. Using the kernel above, the residual fraction $R(\\tau)$ for elapsed time $\\tau = T - t_i$ is\n$$\nR(\\tau) \\;=\\; \\int_{\\tau}^{\\infty} w(s)\\,ds.\n$$\n\nAt the current clock time $T$, the pump history shows two prior boluses:\n- Bolus $1$: $D_{1} = 2.0 \\,\\text{U}$ administered at $T - 2.5 \\,\\text{h}$.\n- Bolus $2$: $D_{2} = 1.0 \\,\\text{U}$ administered at $T - 1.0 \\,\\text{h}$.\n\nThe CGM displays a current glucose $G(T) = 210 \\,\\text{mg/dL}$ and a stable upward trend of $r = 0.5 \\,\\text{mg/dL/min}$. For predictive correction, use a $30 \\,\\text{min}$ horizon, so the predicted glucose at $T + 30 \\,\\text{min}$ is $G_{p} = G(T) + r \\times 30 \\,\\text{min}$. The target glucose is $G^{*} = 110 \\,\\text{mg/dL}$ and the insulin sensitivity factor (ISF) is $45 \\,\\text{mg/dL}$ per unit insulin.\n\nUnder the assumptions above, compute:\n1. The total Insulin-on-Board at time $T$, $\\text{IOB}(T)$, using $R(\\tau)$ and the given $w(\\tau)$.\n2. The correction bolus ignoring IOB, $D_{\\text{corr},0} = \\dfrac{G_{p} - G^{*}}{\\text{ISF}}$.\n3. The IOB-adjusted correction bolus $D_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T)$.\n\nRound your final numerical answer for $D_{\\text{corr}}$ to four significant figures. Express the final dose in $\\text{U}$.", "solution": "The problem is valid as it is scientifically grounded in standard pharmacokinetic/pharmacodynamic modeling, is well-posed with all necessary information provided, and is presented in an objective, formal manner. We proceed with the solution.\n\nThe problem asks for the computation of an IOB-adjusted correction insulin bolus, $D_{\\text{corr}}$. This requires a three-step calculation:\n1.  Compute the total Insulin-on-Board, $\\text{IOB}(T)$.\n2.  Compute the unadjusted correction bolus, $D_{\\text{corr},0}$.\n3.  Compute the final adjusted bolus, $D_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T)$.\n\nFirst, we determine the analytical form of the residual fraction of insulin action, $R(\\tau)$. The impulse response kernel is given as:\n$$\nw(\\tau) = \\frac{\\lambda^{3}\\,\\tau^{2}\\,\\exp(-\\lambda\\,\\tau)}{2}, \\quad \\tau \\ge 0\n$$\nThe residual fraction $R(\\tau)$ is the integral of this kernel from $\\tau$ to infinity:\n$$\nR(\\tau) = \\int_{\\tau}^{\\infty} w(s)\\,ds = \\int_{\\tau}^{\\infty} \\frac{\\lambda^{3}\\,s^{2}\\,\\exp(-\\lambda\\,s)}{2}\\,ds\n$$\nTo evaluate this integral, we find the indefinite integral of $s^{2}\\,\\exp(-\\lambda\\,s)$ using integration by parts twice.\nLet's find $\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds$.\nFirst integration by parts: let $u = s^2$ and $dv = \\exp(-\\lambda\\,s)\\,ds$. Then $du = 2s\\,ds$ and $v = -\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)$.\n$$\n\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) - \\int \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)\\right)(2s\\,ds) = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) + \\frac{2}{\\lambda}\\int s\\,\\exp(-\\lambda\\,s)\\,ds\n$$\nSecond integration by parts for the remaining integral: let $u=s$ and $dv = \\exp(-\\lambda\\,s)\\,ds$. Then $du=ds$ and $v = -\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)$.\n$$\n\\int s\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\int \\left(-\\frac{1}{\\lambda}\\exp(-\\lambda\\,s)\\right)\\,ds = -\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\frac{1}{\\lambda^2}\\exp(-\\lambda\\,s)\n$$\nSubstituting this back, the indefinite integral is:\n$$\n\\int s^{2}\\,\\exp(-\\lambda\\,s)\\,ds = -\\frac{s^2}{\\lambda}\\exp(-\\lambda\\,s) + \\frac{2}{\\lambda}\\left(-\\frac{s}{\\lambda}\\exp(-\\lambda\\,s) - \\frac{1}{\\lambda^2}\\exp(-\\lambda\\,s)\\right) = -\\exp(-\\lambda\\,s)\\left(\\frac{s^2}{\\lambda} + \\frac{2s}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\n$$\nNow we can evaluate the definite integral for $R(\\tau)$:\n$$\nR(\\tau) = \\frac{\\lambda^3}{2} \\left[ -\\exp(-\\lambda\\,s)\\left(\\frac{s^2}{\\lambda} + \\frac{2s}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right) \\right]_{\\tau}^{\\infty}\n$$\nAs $s \\to \\infty$, the term $\\exp(-\\lambda\\,s) \\to 0$ (since $\\lambda > 0$). Thus, the expression evaluated at the upper limit is $0$.\n$$\nR(\\tau) = \\frac{\\lambda^3}{2} \\left( 0 - \\left(-\\exp(-\\lambda\\,\\tau)\\left(\\frac{\\tau^2}{\\lambda} + \\frac{2\\tau}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\\right) \\right) = \\frac{\\lambda^3}{2} \\exp(-\\lambda\\,\\tau) \\left(\\frac{\\tau^2}{\\lambda} + \\frac{2\\tau}{\\lambda^2} + \\frac{2}{\\lambda^3}\\right)\n$$\nSimplifying this expression gives the formula for the residual fraction:\n$$\nR(\\tau) = \\exp(-\\lambda\\,\\tau) \\left( \\frac{(\\lambda\\tau)^2}{2} + \\lambda\\tau + 1 \\right)\n$$\n\n**Step 1: Compute Total Insulin-on-Board, $\\text{IOB}(T)$**\n\nThe problem provides the rate parameter $\\lambda = 1 \\,\\text{h}^{-1}$. Substituting this into the expression for $R(\\tau)$ simplifies it to:\n$$\nR(\\tau) = \\exp(-\\tau) \\left( \\frac{\\tau^2}{2} + \\tau + 1 \\right)\n$$\nwhere $\\tau$ is in hours.\n\nThe patient has two prior boluses:\n- Bolus $1$: $D_1 = 2.0 \\,\\text{U}$ at elapsed time $\\tau_1 = 2.5 \\,\\text{h}$.\n- Bolus $2$: $D_2 = 1.0 \\,\\text{U}$ at elapsed time $\\tau_2 = 1.0 \\,\\text{h}$.\n\nThe IOB from each bolus is $D_i \\times R(\\tau_i)$. The total IOB is the sum of the contributions from each bolus:\n$$\n\\text{IOB}(T) = D_1 R(\\tau_1) + D_2 R(\\tau_2)\n$$\nWe calculate $R(\\tau_1)$ and $R(\\tau_2)$:\n$$\nR(\\tau_1) = R(2.5) = \\exp(-2.5) \\left( \\frac{(2.5)^2}{2} + 2.5 + 1 \\right) = \\exp(-2.5) \\left( \\frac{6.25}{2} + 3.5 \\right) = \\exp(-2.5) (3.125 + 3.5) = 6.625 \\exp(-2.5)\n$$\n$$\nR(\\tau_2) = R(1.0) = \\exp(-1.0) \\left( \\frac{(1.0)^2}{2} + 1.0 + 1 \\right) = \\exp(-1.0) \\left( 0.5 + 2.0 \\right) = 2.5 \\exp(-1.0)\n$$\nNow, we compute the total IOB:\n$$\n\\text{IOB}(T) = (2.0)(6.625 \\exp(-2.5)) + (1.0)(2.5 \\exp(-1.0)) = 13.25 \\exp(-2.5) + 2.5 \\exp(-1.0)\n$$\nNumerically, this is:\n$$\n\\text{IOB}(T) \\approx 13.25 \\times 0.082085 + 2.5 \\times 0.367879 \\approx 1.087626 + 0.919699 \\approx 2.007325 \\,\\text{U}\n$$\n\n**Step 2: Compute the Unadjusted Correction Bolus, $D_{\\text{corr},0}$**\n\nFirst, we calculate the predicted glucose $G_p$ at time $T + 30 \\,\\text{min}$.\nThe current glucose is $G(T) = 210 \\,\\text{mg/dL}$, and the rate of change is $r = 0.5 \\,\\text{mg/dL/min}$.\n$$\nG_p = G(T) + r \\times 30 \\,\\text{min} = 210 \\,\\text{mg/dL} + (0.5 \\,\\text{mg/dL/min}) \\times (30 \\,\\text{min}) = 210 + 15 = 225 \\,\\text{mg/dL}\n$$\nThe unadjusted correction bolus is calculated using the target glucose $G^* = 110 \\,\\text{mg/dL}$ and the insulin sensitivity factor $\\text{ISF} = 45 \\,\\text{mg/dL/U}$.\n$$\nD_{\\text{corr},0} = \\frac{G_p - G^*}{\\text{ISF}} = \\frac{225 - 110}{45} = \\frac{115}{45} \\,\\text{U}\n$$\nNumerically, this is:\n$$\nD_{\\text{corr},0} = \\frac{23}{9} \\approx 2.555556 \\,\\text{U}\n$$\n\n**Step 3: Compute the IOB-Adjusted Correction Bolus, $D_{\\text{corr}}$**\n\nThe final IOB-adjusted correction bolus is the unadjusted dose minus the total IOB.\n$$\nD_{\\text{corr}} = D_{\\text{corr},0} - \\text{IOB}(T) = \\frac{115}{45} - \\left( 13.25 \\exp(-2.5) + 2.5 \\exp(-1.0) \\right)\n$$\nSubstituting the numerical values:\n$$\nD_{\\text{corr}} \\approx 2.555556 - 2.007325 = 0.548231 \\,\\text{U}\n$$\nThe problem requires rounding the final answer to four significant figures.\n$$\nD_{\\text{corr}} \\approx 0.5482 \\,\\text{U}\n$$", "answer": "$$\n\\boxed{0.5482}\n$$", "id": "5099481"}, {"introduction": "Modern automated insulin delivery systems move beyond simple linear calculations to incorporate dynamic risk assessment. To enhance safety, especially in the pediatric population, algorithms must intelligently attenuate insulin delivery when the risk of hypoglycemia is elevated. This practice [@problem_id:5099507] guides you through the design of a sophisticated nonlinear correction factor that integrates real-time glucose levels and trend data from a CGM to modulate dosing, reflecting the advanced safety logic embedded in today's hybrid closed-loop systems.", "problem": "A pediatric insulin pump controller uses continuous glucose monitoring to compute a corrective insulin bolus for hyperglycemia. The conventional corrective bolus formula uses a constant correction factor (also termed insulin sensitivity factor), but this can increase hypoglycemia risk when the current glucose is low. You are tasked with designing and implementing a nonlinear correction factor scheme that attenuates the correction when the glucose concentration is below a specified low threshold to reduce hypoglycemia risk, while preserving unit consistency and scientific realism. All calculations must be derived from first principles and well-tested definitions within pediatric diabetes technology, and all mathematical entities must be written in LaTeX.\n\nStart from the following base concepts and facts:\n- The corrective bolus for hyperglycemia in pump therapy is computed by dividing the glucose deviation by the correction factor. Let the correction factor be denoted by $S$ with units $\\mathrm{mg/dL}$ per $\\mathrm{U}$ (insulin unit), the current glucose be $G$ in $\\mathrm{mg/dL}$, and the target glucose be $G^{\\ast}$ in $\\mathrm{mg/dL}$. The nominal corrective bolus without risk attenuation is $(G - G^{\\ast})/S$ in $\\mathrm{U}$.\n- Insulin on Board (IOB), denoted $I_{\\mathrm{OB}}$ in $\\mathrm{U}$, represents residual active insulin that should decrease any recommended additional bolus. A scalar fraction $\\eta \\in [0,1]$ represents the potency of $I_{\\mathrm{OB}}$ at the current decision time, yielding an effective offset $\\eta I_{\\mathrm{OB}}$ in $\\mathrm{U}$.\n- The Kovatchev glucose risk function is a well-tested mapping for glucose-related risk. Define\n$$F(G) = 1.509\\left((\\ln G)^{1.084} - 5.381\\right),$$\nand the raw risk\n$$R(G) = 10\\,[F(G)]^2.$$\nTo isolate hypoglycemia risk, use\n$$R_{\\mathrm{low}}(G) = 10\\,[\\min(F(G),0)]^2,$$\nwhich is nonzero only when $F(G) \\lt 0$, corresponding to lower glucose values.\n- The continuous glucose monitoring trend (rate of change) $\\dot{G}$ in $\\mathrm{mg/dL/min}$ increases hypoglycemia risk when negative. A simple, well-founded normalization for trend risk is\n$$r_{\\mathrm{slope}}(\\dot{G}) = \\min\\left(1,\\max\\left(0, -\\frac{\\dot{G}}{d_0}\\right)\\right),$$\nfor a reference magnitude $d_0$ in $\\mathrm{mg/dL/min}$.\n\nDesign a nonlinear correction factor scheme as follows, ensuring the attenuation is emphasized when $G \\lt 90\\,\\mathrm{mg/dL}$:\n1. Normalize the hypoglycemia risk to a unit interval using a scale $R_{\\mathrm{scale}}$,\n$$r_{\\mathrm{low}}(G) = \\min\\left(1,\\frac{R_{\\mathrm{low}}(G)}{R_{\\mathrm{scale}}}\\right).$$\n2. Combine low-glucose risk and slope risk into a single dimensionless weight using an exponential survival form,\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-\\alpha\\,r_{\\mathrm{low}}(G) - \\beta\\,r_{\\mathrm{slope}}(\\dot{G})\\right),$$\nwith nonnegative coefficients $\\alpha$ and $\\beta$. This function increases as either $r_{\\mathrm{low}}$ or $r_{\\mathrm{slope}}$ increases and is bounded in $[0,1]$.\n3. Define an effective, nonlinear correction factor\n$$S_{\\mathrm{eff}}(G,\\dot{G}) = S\\left(1 + \\lambda\\,r(G,\\dot{G})\\right),$$\nwith $\\lambda \\ge 0$ controlling the degree of attenuation. When $G \\lt 90\\,\\mathrm{mg/dL}$, $r_{\\mathrm{low}}(G)$ is positive and $S_{\\mathrm{eff}}$ increases, reducing the recommended insulin.\n4. Compute the risk-weighted corrective bolus (in insulin units),\n$$B(G,\\dot{G},S,I_{\\mathrm{OB}}) = \\max\\left(0,\\,\\min\\left(B_{\\max},\\,\\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}\\right)\\right),$$\nwhich clamps negative values to $0\\,\\mathrm{U}$ (no correction when below target) and caps excessively large values at $B_{\\max}\\,\\mathrm{U}$ for pediatric safety.\n\nYour task:\n- Implement the above design as a program that, for each test case, computes $B(G,\\dot{G},S,I_{\\mathrm{OB}})$ in insulin units, rounded to two decimal places.\n- Use the following constants unless otherwise specified within a test case: $G^{\\ast} = 110\\,\\mathrm{mg/dL}$, $\\eta = 0.6$, $R_{\\mathrm{scale}} = 20$, $d_0 = 2\\,\\mathrm{mg/dL/min}$, $\\alpha = 1$, $\\beta = 1$, $B_{\\max} = 5.0\\,\\mathrm{U}$.\n- Angle units do not apply. All outputs are insulin units $\\mathrm{U}$ and must be floats rounded to two decimal places.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,...]\").\n\nTest suite:\nEvaluate eight cases with parameters $(G, \\dot{G}, S, I_{\\mathrm{OB}}, \\lambda)$, all in the units specified:\n1. $G = 250\\,\\mathrm{mg/dL}$, $\\dot{G} = +2\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.5\\,\\mathrm{U}$, $\\lambda = 2.0$.\n2. $G = 90\\,\\mathrm{mg/dL}$, $\\dot{G} = 0\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$.\n3. $G = 120\\,\\mathrm{mg/dL}$, $\\dot{G} = -2\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.2\\,\\mathrm{U}$, $\\lambda = 2.0$.\n4. $G = 85\\,\\mathrm{mg/dL}$, $\\dot{G} = -1\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$.\n5. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = +3\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$.\n6. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = -3\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 1.0\\,\\mathrm{U}$, $\\lambda = 2.0$.\n7. $G = 400\\,\\mathrm{mg/dL}$, $\\dot{G} = +1\\,\\mathrm{mg/dL/min}$, $S = 50\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.0\\,\\mathrm{U}$, $\\lambda = 2.0$.\n8. $G = 180\\,\\mathrm{mg/dL}$, $\\dot{G} = -1\\,\\mathrm{mg/dL/min}$, $S = 60\\,\\mathrm{mg/dL/U}$, $I_{\\mathrm{OB}} = 0.3\\,\\mathrm{U}$, $\\lambda = 3.0$.\n\nYour program must compute and print the list of eight floats corresponding to the recommended corrective bolus $B$ for the above cases, each rounded to two decimal places, in a single-line bracketed comma-separated list.", "solution": "The problem presented is valid. It is scientifically grounded in established principles of diabetes technology, well-posed with a clear and complete set of definitions and constraints, and objective in its formulation. We will, therefore, proceed with a reasoned solution.\n\nThe task is to design and implement a risk-aware algorithm for calculating a corrective insulin bolus. The algorithm attenuates the insulin dose when there is an elevated risk of hypoglycemia, which is indicated by low current glucose levels or a rapidly falling glucose trend. The calculation is structured as a sequence of four main steps, which we will address systematically.\n\nThe fixed parameters for the model are given as:\n- Target Glucose, $G^{\\ast} = 110\\,\\mathrm{mg/dL}$\n- Insulin on Board (IOB) potency fraction, $\\eta = 0.6$\n- Hypoglycemia risk normalization scale, $R_{\\mathrm{scale}} = 20$\n- Glucose trend reference magnitude, $d_0 = 2\\,\\mathrm{mg/dL/min}$\n- Risk combination coefficient (low glucose), $\\alpha = 1$\n- Risk combination coefficient (trend), $\\beta = 1$\n- Maximum allowable bolus, $B_{\\max} = 5.0\\,\\mathrm{U}$\n\nThe final corrective bolus, $B$, is a function of the current glucose $G$, glucose trend $\\dot{G}$, the nominal correction factor $S$, the insulin on board $I_{\\mathrm{OB}}$, and a risk-weighting parameter $\\lambda$.\n\nThe process for computing the bolus $B(G,\\dot{G},S,I_{\\mathrm{OB}})$ is as follows:\n\n**Step 1: Quantify and Normalize Hypoglycemia Risk from Glucose Level**\n\nFirst, we quantify the risk associated with the current glucose level, $G$, using the Kovatchev glucose risk function. This function maps glucose concentrations to a risk score, where negative values indicate hypoglycemic risk.\nThe function is defined as:\n$$F(G) = 1.509\\left((\\ln G)^{1.084} - 5.381\\right)$$\nTo isolate the risk of hypoglycemia, we only consider negative values of $F(G)$. The raw low-glucose risk, $R_{\\mathrm{low}}(G)$, is given by:\n$$R_{\\mathrm{low}}(G) = 10\\,[\\min(F(G),0)]^2$$\nThis value is non-zero only when $G$ is low enough to make $F(G)$ negative. To create a dimensionless risk metric bounded in $[0,1]$, we normalize $R_{\\mathrm{low}}(G)$ using a scaling factor $R_{\\mathrm{scale}}$:\n$$r_{\\mathrm{low}}(G) = \\min\\left(1,\\frac{R_{\\mathrm{low}}(G)}{R_{\\mathrm{scale}}}\\right)$$\nFor the given parameters, $R_{\\mathrm{scale}} = 20$. A value of $r_{\\mathrm{low}}(G) = 1$ indicates maximum scaled risk from the glucose level.\n\n**Step 2: Quantify and Normalize Hypoglycemia Risk from Glucose Trend**\n\nA negative glucose trend, $\\dot{G}$, also contributes to hypoglycemia risk. This risk is quantified by normalizing the rate of change with respect to a reference magnitude, $d_0$. The formula is:\n$$r_{\\mathrm{slope}}(\\dot{G}) = \\min\\left(1,\\max\\left(0, -\\frac{\\dot{G}}{d_0}\\right)\\right)$$\nWith $d_0 = 2\\,\\mathrm{mg/dL/min}$, this function maps falling trends to a risk score between $0$ and $1$. A trend of $\\dot{G} = -2\\,\\mathrm{mg/dL/min}$ yields $r_{\\mathrm{slope}} = 1$, representing maximal trend-based risk. For any stable or rising trend ($\\dot{G} \\ge 0$), $r_{\\mathrm{slope}}(\\dot{G}) = 0$.\n\n**Step 3: Combine Risk Factors and Modulate the Correction Factor**\n\nThe two dimensionless risk components, $r_{\\mathrm{low}}(G)$ and $r_{\\mathrm{slope}}(\\dot{G})$, are combined into a single total risk weight, $r(G,\\dot{G})$. The exponential survival form ensures that the combined risk is greater than or equal to the individual risks and remains bounded in $[0,1]$:\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-\\alpha\\,r_{\\mathrm{low}}(G) - \\beta\\,r_{\\mathrm{slope}}(\\dot{G})\\right)$$\nWith coefficients $\\alpha=1$ and $\\beta=1$, this simplifies to:\n$$r(G,\\dot{G}) = 1 - \\exp\\left(-r_{\\mathrm{low}}(G) - r_{\\mathrm{slope}}(\\dot{G})\\right)$$\nThis combined risk weight is then used to modulate the nominal correction factor, $S$. The effective correction factor, $S_{\\mathrm{eff}}$, is increased proportionally to the risk, which will in turn decrease the calculated insulin dose.\n$$S_{\\mathrm{eff}}(G,\\dot{G}) = S\\left(1 + \\lambda\\,r(G,\\dot{G})\\right)$$\nThe parameter $\\lambda \\ge 0$ controls the strength of this attenuation. A larger $\\lambda$ leads to a more pronounced increase in $S_{\\mathrm{eff}}$ for a given risk level. If the total risk $r(G,\\dot{G})$ is zero, then $S_{\\mathrm{eff}} = S$.\n\n**Step 4: Compute the Final Corrective Bolus**\n\nThe final step is to calculate the risk-weighted corrective bolus, $B$. This is done using the standard bolus formula, but with the effective correction factor $S_{\\mathrm{eff}}$. The calculation also accounts for insulin on board ($I_{\\mathrm{OB}}$) and incorporates safety clamps.\nThe base calculation is:\n$$\\text{Bolus}_{\\text{base}} = \\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}$$\nwhere $G-G^{\\ast}$ is the deviation from target, and $\\eta I_{\\mathrm{OB}}$ is the effective IOB to be subtracted.\n\nTo ensure safety, the final bolus $B$ is constrained: it cannot be negative (no insulin is given if glucose is below target), and it is capped at a maximum value $B_{\\max}$.\n$$B(G,\\dot{G},S,I_{\\mathrm{OB}}) = \\max\\left(0,\\,\\min\\left(B_{\\max},\\,\\frac{G - G^{\\ast}}{S_{\\mathrm{eff}}(G,\\dot{G})} - \\eta I_{\\mathrm{OB}}\\right)\\right)$$\nWith $B_{\\max} = 5.0\\,\\mathrm{U}$, any calculated bolus exceeding this value is reduced to $5.0\\,\\mathrm{U}$. Any negative result (which occurs if $G \\le G^{\\ast}$ or if the IOB offset is large) is set to $0\\,\\mathrm{U}$.\n\nWe will now implement this complete sequence of calculations for each of the eight test cases provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a risk-weighted corrective insulin bolus for a series of test cases.\n    \"\"\"\n\n    # Define the constants for the calculation as specified in the problem.\n    G_star = 110.0  # Target glucose (mg/dL)\n    eta = 0.6       # IOB potency fraction (dimensionless)\n    R_scale = 20.0  # Hypoglycemia risk normalization scale (dimensionless)\n    d0 = 2.0        # Glucose trend reference magnitude (mg/dL/min)\n    alpha = 1.0     # Risk combination coefficient for low glucose (dimensionless)\n    beta = 1.0      # Risk combination coefficient for trend (dimensionless)\n    B_max = 5.0     # Maximum allowable bolus (U)\n\n    def calculate_bolus(G, G_dot, S, I_OB, lam):\n        \"\"\"\n        Calculates the final corrective bolus B for a single set of inputs.\n\n        Args:\n            G (float): Current glucose (mg/dL)\n            G_dot (float): Glucose trend (mg/dL/min)\n            S (float): Correction factor (mg/dL/U)\n            I_OB (float): Insulin on Board (U)\n            lam (float): Attenuation control parameter (lambda)\n\n        Returns:\n            float: The calculated corrective bolus, rounded to two decimal places.\n        \"\"\"\n        # Step 1: Quantify and Normalize Hypoglycemia Risk from Glucose Level\n        if G <= 0:  # Logarithm is undefined for G <= 0, risk is maximal\n            F_G = -np.inf\n        else:\n            F_G = 1.509 * (np.log(G)**1.084 - 5.381)\n        \n        R_low_G = 10.0 * (min(F_G, 0.0))**2\n        r_low_G = min(1.0, R_low_G / R_scale)\n\n        # Step 2: Quantify and Normalize Hypoglycemia Risk from Glucose Trend\n        r_slope_G_dot = min(1.0, max(0.0, -G_dot / d0))\n\n        # Step 3: Combine Risk Factors and Modulate the Correction Factor\n        r_combined = 1.0 - np.exp(-alpha * r_low_G - beta * r_slope_G_dot)\n        S_eff = S * (1.0 + lam * r_combined)\n\n        # Step 4: Compute the Final Corrective Bolus\n        # The bolus is only non-zero if G > G_star\n        if G > G_star:\n            bolus_base = (G - G_star) / S_eff - eta * I_OB\n        else:\n            bolus_base = -1.0  # Ensure result is <= 0 to be clamped by max(0, ...)\n\n        B = max(0.0, min(B_max, bolus_base))\n        \n        return round(B, 2)\n\n    # Define the test cases from the problem statement.\n    # Parameters: (G, G_dot, S, I_OB, lambda)\n    test_cases = [\n        (250.0, 2.0, 50.0, 0.5, 2.0),\n        (90.0, 0.0, 50.0, 0.0, 2.0),\n        (120.0, -2.0, 50.0, 0.2, 2.0),\n        (85.0, -1.0, 50.0, 0.0, 2.0),\n        (180.0, 3.0, 50.0, 0.0, 2.0),\n        (180.0, -3.0, 50.0, 1.0, 2.0),\n        (400.0, 1.0, 50.0, 0.0, 2.0),\n        (180.0, -1.0, 60.0, 0.3, 3.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        G, G_dot, S, I_OB, lam = case\n        result = calculate_bolus(G, G_dot, S, I_OB, lam)\n        results.append(f\"{result:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "5099507"}, {"introduction": "The effectiveness of any insulin dosing algorithm, simple or complex, hinges on the accuracy of its underlying parameters, which are highly individual. This final practice shifts our focus from real-time calculation to long-term personalization, a cornerstone of advanced diabetes management. By analyzing historical Continuous Glucose Monitoring (CGM) and meal data, you will employ statistical methods to derive a patient-specific Insulin-to-Carbohydrate Ratio ($ICR$), demonstrating how data analytics transforms raw patient information into actionable, personalized therapy settings [@problem_id:5099525].", "problem": "A pediatric endocrinology service is evaluating data from Continuous Glucose Monitoring (CGM) and insulin pump meal logs to estimate a data-driven Insulin-to-Carbohydrate Ratio (ICR) for postprandial glucose control. Continuous Glucose Monitoring (CGM) provides interstitial glucose measurements in milligrams per deciliter (mg/dL) at fixed time points after meals. For each meal, carbohydrate amount in grams and bolus insulin amount in international units (IU) are recorded. The aim is to use these records to estimate an ICR that captures how many grams of carbohydrate are neutralized per unit of rapid-acting insulin to prevent a postprandial rise in glucose, and to quantify the model error in milligrams per deciliter (mg/dL).\n\nFundamental base. Begin from a mass-balance perspective: postprandial glucose concentration change is driven by exogenous carbohydrate appearance into blood and insulin-mediated disposal. Over short postprandial windows, treat the net excursion as the observable outcome of these opposing processes. Assume the relationship between the postprandial excursion and the carbohydrate and insulin dosing is well approximated by a linear model over the studied range, and estimate model parameters by Ordinary Least Squares (OLS).\n\nDefinitions to use. For meal index $m$, define the postprandial excursion $E_m$ as the maximum CGM reading in a fixed postprandial window minus the premeal baseline CGM value. The baseline for meal $m$ is the CGM level immediately prior to meal onset. The postprandial window comprises six fixed time points at $30$, $60$, $90$, $120$, $150$, and $180$ minutes after meal onset. The carbohydrate dose $c_m$ is expressed in grams, and the bolus insulin dose $b_m$ is expressed in international units (IU). The linear model relates $E_m$ to $(c_m,b_m)$ via an affine relation. The estimated Insulin-to-Carbohydrate Ratio (ICR) is the grams per unit necessary to render the predicted excursion zero, derived logically from the fitted model coefficients without using any shortcut formula provided in the problem. Model error is quantified by the Root Mean Squared Error (RMSE) between the observed excursions and the model-predicted excursions, expressed in mg/dL.\n\nData and computation instructions. Use the following test suite of three cases. In each case, for each meal $m$, you are given a baseline CGM value (in mg/dL), a carbohydrate dose $c_m$ (in grams), a bolus insulin dose $b_m$ (in IU), and an excursion amplitude parameter $A_m$ (in mg/dL). Construct the CGM postprandial profile for each meal as six values in mg/dL: baseline plus $A_m$ multiplied by the fixed shape fractions vector $S=[0.1,0.5,1.0,0.8,0.6,0.2]$, evaluated at $30$, $60$, $90$, $120$, $150$, and $180$ minutes, respectively. Compute $E_m$ as the difference between the maximum of these six CGM postprandial values and the baseline. Then fit the linear model relating $E_m$ to $c_m$ and $b_m$ via OLS with an intercept, and finally derive the data-driven ICR (grams per unit) implied by the fitted model coefficients such that the predicted excursion is zero. Compute the RMSE between observed $E_m$ and model-predicted excursions, in mg/dL.\n\nUnits. All CGM values are in mg/dL, all carbohydrate doses are in grams, all insulin doses are in international units (IU), and the ICR must be reported in grams per unit. The RMSE must be reported in mg/dL.\n\nTest suite. For each case, use the given meal-level parameters:\n\nCase $1$ (happy path, mixed doses):\n- Shape fractions $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- Meals (baseline in mg/dL, $c_m$ in grams, $b_m$ in IU, $A_m$ in mg/dL):\n  - $(95,60,5,15)$\n  - $(105,45,3,20)$\n  - $(100,75,6,10)$\n  - $(110,30,2,12)$\n  - $(98,90,7,15)$\n  - $(102,50,0,95)$\n\nCase $2$ (boundary coverage, some zero insulin):\n- Shape fractions $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- Meals:\n  - $(100,20,0,42)$\n  - $(97,80,6,38)$\n  - $(103,10,1,5)$\n  - $(108,100,10,8)$\n\nCase $3$ (edge with noise and an outlier):\n- Shape fractions $S=[0.1,0.5,1.0,0.8,0.6,0.2]$\n- Meals:\n  - $(94,60,3,40)$\n  - $(99,90,6,20)$\n  - $(101,30,1,30)$\n  - $(96,120,10,5)$\n  - $(104,45,0,75)$\n\nAlgorithmic requirements. For each case:\n- Build the design matrix with an intercept and columns for $c_m$ and $b_m$, and the response vector of observed $E_m$ computed from the CGM profiles.\n- Estimate model coefficients by OLS via the Moore–Penrose pseudoinverse.\n- Derive the ICR from first principles as the grams per unit that sets the model-predicted excursion to zero for changes along the carbohydrate–insulin dosing axis.\n- Compute the RMSE in mg/dL as the square root of the mean of squared residuals.\n\nAnswer format and rounding. Your program should produce a single line of output containing the six results as a comma-separated list enclosed in square brackets, in the order: $[\\text{ICR}_{1},\\text{RMSE}_{1},\\text{ICR}_{2},\\text{RMSE}_{2},\\text{ICR}_{3},\\text{RMSE}_{3}]$. Round each floating-point result to two decimal places. ICR values must be in grams per unit and RMSE values must be in mg/dL. No other text should be printed.", "solution": "The objective is to estimate a data-driven Insulin-to-Carbohydrate Ratio (ICR) using Continuous Glucose Monitoring (CGM) and insulin pump meal logs. The logic proceeds from a first-principles mass-balance perspective and then constructs an algorithm that is implementable.\n\nFirst-principles foundation. We consider postprandial glucose dynamics as the result of carbohydrate appearance and insulin-mediated glucose disposal. Over the short window following a meal, assume a locally linear relationship between meal carbohydrate $c_m$ and insulin bolus $b_m$ and the observed excursion $E_m$ in the CGM. Specifically, write an affine approximation for meal $m$:\n$$\nE_m \\approx \\beta_0 + \\beta_c \\, c_m + \\beta_b \\, b_m + \\varepsilon_m,\n$$\nwhere $\\beta_0$ captures baseline offsets and other factors, $\\beta_c$ captures the marginal effect of carbohydrate intake on glucose excursion, $\\beta_b$ captures the marginal effect of insulin bolus on excursion, and $\\varepsilon_m$ is random error. This linearization is a standard approximation arising from a first-order Taylor expansion of the underlying nonlinear mass-balance relations over the operating range, under the assumption that variations in $c_m$ and $b_m$ are moderate around a typical operating point.\n\nInsulin-to-Carbohydrate Ratio (ICR) derivation. The Insulin-to-Carbohydrate Ratio (ICR) is defined as the grams of carbohydrate per unit of rapid-acting insulin required to neutralize a meal's glucose-raising effect. Within the affine model, consider small changes $\\Delta c$ and $\\Delta b$ that leave the excursion unchanged, i.e., $\\Delta E = 0$. Taking the differential of the linear model yields\n$$\n0 \\approx \\beta_c \\, \\Delta c + \\beta_b \\, \\Delta b.\n$$\nSolving for the neutralizing dosing ratio gives\n$$\n\\frac{\\Delta c}{\\Delta b} \\approx - \\frac{\\beta_b}{\\beta_c}.\n$$\nThe left-hand side is the Insulin-to-Carbohydrate Ratio (ICR), expressed in grams per unit. Thus, a data-driven estimate for the ICR is obtained directly from the fitted coefficients without invoking any shortcut formula: after estimating $\\beta_c$ and $\\beta_b$ by Ordinary Least Squares (OLS), compute\n$$\n\\widehat{\\text{ICR}} = - \\frac{\\widehat{\\beta}_b}{\\widehat{\\beta}_c}.\n$$\n\nExcursion computation from CGM. For each meal $m$, we define the excursion $E_m$ as the maximum CGM value in a fixed postprandial window minus the premeal baseline. The postprandial window is specified at $30$, $60$, $90$, $120$, $150$, and $180$ minutes after the meal. Given a baseline CGM value (in mg/dL) and an amplitude parameter $A_m$ (in mg/dL), the CGM sequence is constructed at those six time points as\n$$\n\\text{CGM}_{m}(t_k) = \\text{baseline}_m + A_m \\cdot s_k,\n$$\nwhere the shape fractions vector is $S = [s_1, s_2, s_3, s_4, s_5, s_6] = [0.1, 0.5, 1.0, 0.8, 0.6, 0.2]$. The excursion is then\n$$\nE_m = \\max_{k \\in \\{1,\\dots,6\\}} \\text{CGM}_{m}(t_k) - \\text{baseline}_m.\n$$\nBy construction with $s_3 = 1.0$, the maximum occurs at $90$ minutes and equals the amplitude $A_m$; nevertheless, the algorithm must compute it from the CGM data rather than assume a value.\n\nOrdinary Least Squares (OLS). Stack the meals into a design matrix $X$ and response vector $y$:\n$$\nX = \\begin{bmatrix}\n1 & c_1 & b_1 \\\\\n\\vdots & \\vdots & \\vdots \\\\\n1 & c_M & b_M\n\\end{bmatrix}, \\quad\ny = \\begin{bmatrix}\nE_1 \\\\\n\\vdots \\\\\nE_M\n\\end{bmatrix}.\n$$\nThe OLS coefficient vector $\\widehat{\\beta} = [\\widehat{\\beta}_0,\\widehat{\\beta}_c,\\widehat{\\beta}_b]^\\top$ is computed using the Moore–Penrose pseudoinverse:\n$$\n\\widehat{\\beta} = X^{+} y,\n$$\nwhere $X^{+}$ denotes the pseudoinverse of $X$. This is numerically stable even if $X^\\top X$ is ill-conditioned.\n\nModel error. Compute the model-predicted excursions\n$$\n\\widehat{y} = X \\, \\widehat{\\beta},\n$$\nand the residuals $r = y - \\widehat{y}$. The Root Mean Squared Error (RMSE) quantifies error in mg/dL:\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} r_m^2 }.\n$$\n\nAlgorithmic steps for each case.\n1. For each meal, construct the six CGM values using the baseline and amplitude with the fixed shape fractions, compute $E_m$ as the maximum minus baseline.\n2. Build $X$ and $y$ across all meals in the case.\n3. Compute $\\widehat{\\beta}$ via the pseudoinverse, derive $\\widehat{\\text{ICR}} = -\\widehat{\\beta}_b / \\widehat{\\beta}_c$ (grams per unit).\n4. Compute $\\widehat{y}$ and RMSE in mg/dL.\n5. Round $\\widehat{\\text{ICR}}$ and RMSE to two decimal places and prepare the single-line output.\n\nTest suite coverage rationale. Case $1$ offers a balanced set with varied carbohydrate and insulin doses and one zero-insulin meal; Case $2$ includes boundary scenarios with minimal or zero insulin and a wide carbohydrate range; Case $3$ includes noisy excursions and an outlier meal that produces a small peak despite high insulin, testing robustness. These collectively exercise identifiability, stability of the pseudoinverse, and sensitivity to noise.\n\nFinal output specification. The program must print a single line containing $[\\text{ICR}_{1},\\text{RMSE}_{1},\\text{ICR}_{2},\\text{RMSE}_{2},\\text{ICR}_{3},\\text{RMSE}_{3}]$, with each value rounded to two decimals, where ICR values are in grams per unit and RMSE values are in mg/dL.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_cgm_series(baseline, amplitude, shape_fracs):\n    \"\"\"\n    Construct the CGM postprandial series for a meal:\n    baseline + amplitude * shape_fracs at fixed times 30-180 min.\n    Returns the array of CGM values in mg/dL.\n    \"\"\"\n    return baseline + amplitude * np.array(shape_fracs, dtype=float)\n\ndef compute_excursions(meals, shape_fracs):\n    \"\"\"\n    Given a list of meals with fields:\n      - 'baseline' (mg/dL)\n      - 'carb' (grams)\n      - 'bolus' (IU)\n      - 'amplitude' (mg/dL)\n    and a shape fractions vector,\n    construct CGM series and compute excursions E_m as max(post) - baseline.\n    Returns:\n      - c_list: list of carbs per meal (grams)\n      - b_list: list of bolus per meal (IU)\n      - e_list: list of excursions per meal (mg/dL)\n    \"\"\"\n    c_list, b_list, e_list = [], [], []\n    for meal in meals:\n        baseline = float(meal['baseline'])\n        amplitude = float(meal['amplitude'])\n        c = float(meal['carb'])\n        b = float(meal['bolus'])\n        cgm_series = construct_cgm_series(baseline, amplitude, shape_fracs)\n        excursion = float(np.max(cgm_series) - baseline)\n        c_list.append(c)\n        b_list.append(b)\n        e_list.append(excursion)\n    return np.array(c_list), np.array(b_list), np.array(e_list)\n\ndef ols_icr_and_rmse(c, b, e):\n    \"\"\"\n    Perform OLS with intercept to fit e ~ beta0 + beta_c * c + beta_b * b.\n    Derive ICR = -beta_b / beta_c (grams per unit).\n    Compute RMSE between observed e and predicted.\n    Returns (icr, rmse).\n    \"\"\"\n    # Design matrix with intercept\n    X = np.column_stack([np.ones_like(c), c, b])\n    # Moore–Penrose pseudoinverse solution\n    beta = np.linalg.pinv(X) @ e\n    beta0, beta_c, beta_b = beta.tolist()\n    # Derive ICR from first principles: grams per unit that neutralizes excursion\n    # Avoid division by zero: if beta_c ~ 0, set ICR to np.nan\n    icr = -beta_b / beta_c if abs(beta_c) > 1e-12 else np.nan\n    # Predictions and RMSE\n    y_hat = X @ beta\n    rmse = float(np.sqrt(np.mean((e - y_hat) ** 2)))\n    return float(icr), rmse\n\ndef solve():\n    # Fixed shape fractions at 30,60,90,120,150,180 minutes\n    shape_fracs = [0.1, 0.5, 1.0, 0.8, 0.6, 0.2]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path, mixed doses\n        [\n            {'baseline': 95,  'carb': 60, 'bolus': 5,  'amplitude': 15},\n            {'baseline': 105, 'carb': 45, 'bolus': 3,  'amplitude': 20},\n            {'baseline': 100, 'carb': 75, 'bolus': 6,  'amplitude': 10},\n            {'baseline': 110, 'carb': 30, 'bolus': 2,  'amplitude': 12},\n            {'baseline': 98,  'carb': 90, 'bolus': 7,  'amplitude': 15},\n            {'baseline': 102, 'carb': 50, 'bolus': 0,  'amplitude': 95},\n        ],\n        # Case 2: boundary coverage, some zero insulin\n        [\n            {'baseline': 100, 'carb': 20,  'bolus': 0,  'amplitude': 42},\n            {'baseline': 97,  'carb': 80,  'bolus': 6,  'amplitude': 38},\n            {'baseline': 103, 'carb': 10,  'bolus': 1,  'amplitude': 5},\n            {'baseline': 108, 'carb': 100, 'bolus': 10, 'amplitude': 8},\n        ],\n        # Case 3: edge with noise and an outlier\n        [\n            {'baseline': 94,  'carb': 60,  'bolus': 3,  'amplitude': 40},\n            {'baseline': 99,  'carb': 90,  'bolus': 6,  'amplitude': 20},\n            {'baseline': 101, 'carb': 30,  'bolus': 1,  'amplitude': 30},\n            {'baseline': 96,  'carb': 120, 'bolus': 10, 'amplitude': 5},\n            {'baseline': 104, 'carb': 45,  'bolus': 0,  'amplitude': 75},\n        ],\n    ]\n\n    results = []\n    for meals in test_cases:\n        c, b, e = compute_excursions(meals, shape_fracs)\n        icr, rmse = ols_icr_and_rmse(c, b, e)\n        # Round to two decimals for output\n        results.append(f\"{icr:.2f}\")\n        results.append(f\"{rmse:.2f}\")\n\n    # Final print statement in the exact required format: single line, comma-separated in brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "5099525"}]}