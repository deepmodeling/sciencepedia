{"hands_on_practices": [{"introduction": "The core of Gene Set Enrichment Analysis (GSEA) is its running-sum statistic, which quantifies whether genes from a set are concentrated at the extremes of a ranked list. To truly understand GSEA, it is essential to move beyond software outputs and compute this statistic from first principles. This practice guides you through a manual calculation of the weighted Enrichment Score ($ES$), providing a foundational intuition for how the algorithm translates gene ranks and set membership into a single, powerful score [@problem_id:4567424].", "problem": "You are given a pre-ranked list of genes from a transcriptomic differential phenotype analysis, with each gene associated to a ranking metric magnitude interpreted as the absolute value of a correlation with the phenotype. The task is to compute the Gene Set Enrichment Analysis (GSEA) enrichment score at weighting parameter $p=1$ from first principles, using the Kolmogorov–Smirnov-like running-sum definition, and then identify the leading-edge subset. Do not use any pre-memorized shortcut formulas; instead, explicitly construct the running-sum process from the definitions of empirical cumulative distribution functions for hits and misses.\n\nThe total number of genes is $N=10$, the ordered ranked list from most to least associated is:\n1. MYC with score $10$\n2. TP53 with score $9$\n3. EGFR with score $8$\n4. BRCA1 with score $7$\n5. PTEN with score $6$\n6. KRAS with score $5$\n7. AKT1 with score $4$\n8. BRAF with score $3$\n9. MDM2 with score $2$\n10. CDK2 with score $1$\n\nConsider the gene set $S$ of size $|S|=3$ given by $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$. Use weighting parameter $p=1$ so that at a hit the running sum increases by a value proportional to the gene’s score and normalized by the total score of $S$, and at a miss the running sum decreases by a constant so that the total decrement over all misses equals $1$.\n\nStarting from the definitions of the empirical cumulative distribution functions for hits and misses and their difference along the ranked list, compute by hand:\n- the enrichment score (ES) as the maximum deviation of the running sum from zero, and\n- the leading-edge subset corresponding to the location where the enrichment score is attained.\n\nExpress the enrichment score as an exact reduced rational number (no rounding), without units. The final answer should be only the enrichment score.", "solution": "The user-provided problem statement is subjected to a validation process.\n\n### Step 1: Extract Givens\n- Total number of genes in the ranked list: $N=10$.\n- Ranked list of genes with their scores (interpreted as absolute correlation):\n  1. MYC (score $10$)\n  2. TP53 (score $9$)\n  3. EGFR (score $8$)\n  4. BRCA1 (score $7$)\n  5. PTEN (score $6$)\n  6. KRAS (score $5$)\n  7. AKT1 (score $4$)\n  8. BRAF (score $3$)\n  9. MDM2 (score $2$)\n  10. CDK2 (score $1$)\n- Gene set of interest: $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$.\n- Size of the gene set: $N_H = |S|=3$.\n- Weighting parameter: $p=1$.\n- Rule for hit increment: For a gene in $S$, the running sum increases by a value proportional to the gene's score, normalized by the total score of all genes in $S$.\n- Rule for miss decrement: For a gene not in $S$, the running sum decreases by a constant value, such that the sum of all decrements over all misses equals $1$.\n- Definition of Enrichment Score (ES): The maximum deviation of the running sum from zero.\n- Task: Compute the ES and the leading-edge subset from first principles, using the running-sum defined by empirical cumulative distribution functions.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it describes a standard, albeit simplified, procedure for Gene Set Enrichment Analysis (GSEA), a well-established method in bioinformatics. The use of a weighted Kolmogorov-Smirnov-like statistic with $p=1$ is a valid GSEA variant. All necessary data ($N$, the ranked list, the scores, the gene set $S$, and the rules for the running sum) are provided, making the problem well-posed and self-contained. The language is objective and the data are internally consistent. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution\nThe Gene Set Enrichment Analysis (GSEA) enrichment score (ES) is calculated by walking down the ranked list of genes, $L$, and computing a running-sum statistic. The ES is the maximum deviation of this running sum from zero. The running sum at any point $i$ in the ranked list is the difference between a weighted empirical cumulative distribution function for the genes present in the set $S$ (hits) and an empirical cumulative distribution function for genes not in $S$ (misses).\n\nFirst, we identify the hits and misses in the ranked list. The total number of genes is $N=10$. The gene set $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$ has $N_H = |S| = 3$ genes (hits). The number of genes not in $S$ is $N_M = N - N_H = 10 - 3 = 7$ (misses).\n\nThe ranked list with hit/miss status and scores ($r_j$) is as follows:\n1. MYC, $r_1=10$ (Miss)\n2. TP53, $r_2=9$ (Hit)\n3. EGFR, $r_3=8$ (Miss)\n4. BRCA1, $r_4=7$ (Miss)\n5. PTEN, $r_5=6$ (Miss)\n6. KRAS, $r_6=5$ (Hit)\n7. AKT1, $r_7=4$ (Miss)\n8. BRAF, $r_8=3$ (Miss)\n9. MDM2, $r_9=2$ (Hit)\n10. CDK2, $r_{10}=1$ (Miss)\n\nThe running sum at rank $i$, denoted $ES_i$, is defined as $ES_i = P_{hit}(S, i) - P_{miss}(S, i)$.\n\nThe term $P_{hit}(S, i)$ is the weighted empirical cumulative distribution of hits. With the weighting parameter $p=1$, it is calculated as:\n$$P_{hit}(S, i) = \\sum_{g_j \\in S, j \\le i} \\frac{r_j}{N_R}$$\nwhere $N_R$ is the normalization factor, equal to the sum of scores for all genes in $S$:\n$$N_R = \\sum_{g_j \\in S} r_j = r_{\\text{TP53}} + r_{\\text{KRAS}} + r_{\\text{MDM2}} = 9 + 5 + 2 = 16$$\nWhen we encounter a hit $g_j \\in S$ at rank $j$ with score $r_j$, the running sum increases by $\\frac{r_j}{N_R} = \\frac{r_j}{16}$.\n\nThe term $P_{miss}(S, i)$ is the empirical cumulative distribution of misses:\n$$P_{miss}(S, i) = \\sum_{g_j \\notin S, j \\le i} \\frac{1}{N_M}$$\nwhere $N_M = 7$. When we encounter a miss $g_j \\notin S$ at rank $j$, the running sum decreases by $\\frac{1}{N_M} = \\frac{1}{7}$.\n\nWe now compute the running sum $ES_i$ for each gene $g_i$ in the ranked list, starting with $ES_0=0$.\n\n1.  **Gene 1 (MYC, Miss):**\n    $P_{hit}(S, 1) = 0$. $P_{miss}(S, 1) = \\frac{1}{7}$.\n    $ES_1 = 0 - \\frac{1}{7} = -\\frac{1}{7} = -\\frac{16}{112}$.\n\n2.  **Gene 2 (TP53, Hit, score=9):**\n    $P_{hit}(S, 2) = \\frac{9}{16}$. $P_{miss}(S, 2) = \\frac{1}{7}$.\n    $ES_2 = \\frac{9}{16} - \\frac{1}{7} = \\frac{63 - 16}{112} = \\frac{47}{112}$.\n\n3.  **Gene 3 (EGFR, Miss):**\n    $P_{hit}(S, 3) = \\frac{9}{16}$. $P_{miss}(S, 3) = \\frac{2}{7}$.\n    $ES_3 = \\frac{9}{16} - \\frac{2}{7} = \\frac{63 - 32}{112} = \\frac{31}{112}$.\n\n4.  **Gene 4 (BRCA1, Miss):**\n    $P_{hit}(S, 4) = \\frac{9}{16}$. $P_{miss}(S, 4) = \\frac{3}{7}$.\n    $ES_4 = \\frac{9}{16} - \\frac{3}{7} = \\frac{63 - 48}{112} = \\frac{15}{112}$.\n\n5.  **Gene 5 (PTEN, Miss):**\n    $P_{hit}(S, 5) = \\frac{9}{16}$. $P_{miss}(S, 5) = \\frac{4}{7}$.\n    $ES_5 = \\frac{9}{16} - \\frac{4}{7} = \\frac{63 - 64}{112} = -\\frac{1}{112}$.\n\n6.  **Gene 6 (KRAS, Hit, score=5):**\n    $P_{hit}(S, 6) = \\frac{9}{16} + \\frac{5}{16} = \\frac{14}{16}$. $P_{miss}(S, 6) = \\frac{4}{7}$.\n    $ES_6 = \\frac{14}{16} - \\frac{4}{7} = \\frac{7}{8} - \\frac{4}{7} = \\frac{49 - 32}{56} = \\frac{17}{56} = \\frac{34}{112}$.\n\n7.  **Gene 7 (AKT1, Miss):**\n    $P_{hit}(S, 7) = \\frac{14}{16}$. $P_{miss}(S, 7) = \\frac{5}{7}$.\n    $ES_7 = \\frac{14}{16} - \\frac{5}{7} = \\frac{7}{8} - \\frac{5}{7} = \\frac{49 - 40}{56} = \\frac{9}{56} = \\frac{18}{112}$.\n\n8.  **Gene 8 (BRAF, Miss):**\n    $P_{hit}(S, 8) = \\frac{14}{16}$. $P_{miss}(S, 8) = \\frac{6}{7}$.\n    $ES_8 = \\frac{14}{16} - \\frac{6}{7} = \\frac{7}{8} - \\frac{6}{7} = \\frac{49 - 48}{56} = \\frac{1}{56} = \\frac{2}{112}$.\n\n9.  **Gene 9 (MDM2, Hit, score=2):**\n    $P_{hit}(S, 9) = \\frac{14}{16} + \\frac{2}{16} = \\frac{16}{16} = 1$. $P_{miss}(S, 9) = \\frac{6}{7}$.\n    $ES_9 = 1 - \\frac{6}{7} = \\frac{1}{7} = \\frac{16}{112}$.\n\n10. **Gene 10 (CDK2, Miss):**\n    $P_{hit}(S, 10) = 1$. $P_{miss}(S, 10) = \\frac{7}{7} = 1$.\n    $ES_{10} = 1 - 1 = 0$.\n\nThe sequence of running-sum values is: $\\{-\\frac{16}{112}, \\frac{47}{112}, \\frac{31}{112}, \\frac{15}{112}, -\\frac{1}{112}, \\frac{34}{112}, \\frac{18}{112}, \\frac{2}{112}, \\frac{16}{112}, 0\\}$.\n\nThe Enrichment Score (ES) is the maximum deviation of this running sum from zero. This is the maximum of the absolute values of the running sums:\n$$ES = \\max_{i=1,\\ldots,10} |ES_i|$$\nThe maximum value in the set is $ES_2 = \\frac{47}{112}$. The minimum value is $ES_1 = -\\frac{16}{112}$.\nThe maximum deviation from zero is $\\max(\\frac{47}{112}, |-\\frac{16}{112}|) = \\max(\\frac{47}{112}, \\frac{16}{112}) = \\frac{47}{112}$.\nThus, the enrichment score is $\\frac{47}{112}$. The number $47$ is prime and does not divide $112 = 2^4 \\times 7$, so this fraction is in its simplest form.\n\nThe leading-edge subset consists of the genes from the set $S$ that appear in the ranked list up to the position where the maximum enrichment score was found. The maximum score, $ES = \\frac{47}{112}$, occurs at rank $i=2$. The genes in the ranked list up to rank $2$ are $\\{\\text{MYC}, \\text{TP53}\\}$. The intersection of this set with the gene set $S$ is $\\{\\text{TP53}\\}$. Therefore, the leading-edge subset is $\\{\\text{TP53}\\}$.", "answer": "$$\\boxed{\\frac{47}{112}}$$", "id": "4567424"}, {"introduction": "An observed Enrichment Score ($ES$) provides a measure of effect size, but its statistical significance is not immediately clear. To interpret an $ES$ and compare it across different gene sets, it must be normalized against a null distribution generated from phenotype permutations. This exercise demonstrates how to calculate the Normalized Enrichment Score ($NES$) using statistics from this null distribution, a crucial step that transforms the raw $ES$ into a comparable, significance-aware metric [@problem_id:4345921].", "problem": "In Gene Set Enrichment Analysis (GSEA), a gene set’s observed enrichment score $ES$ is obtained from a running-sum statistic over a ranked list of genes, and a null distribution for the magnitude of $ES$ is generated by phenotype-label permutations to estimate the expected magnitude of spurious enrichment. To remove dependence on gene set size and sampling variability, normalization maps an observed $ES$ onto a dimensionless scale using the null distribution of absolute enrichment scores. Consider a gene set with observed $ES$ equal to $0.62$. From $N$ permutations, the empirical null distribution of absolute enrichment scores yields a mean of $0.31$ and a standard deviation of $0.12$. Assume normalization preserves the sign of the observed $ES$ when mapping from the absolute-valued null distribution to the normalized enrichment score $NES$.\n\nUsing the statistical definitions of mean-standardization and $z$-score standardization applied to the absolute null magnitude, compute the two $NES$ values:\n- the mean-standardized $NES$, and\n- the $z$-score standardized $NES$.\n\nPresent your final answer as a row vector in the order $\\left(NES_{\\text{mean}}, NES_{z}\\right)$, and round each value to four significant figures. No units are required.", "solution": "The problem requires the computation of two types of Normalized Enrichment Scores ($NES$) for a given gene set, based on its observed Enrichment Score ($ES$) and the statistical properties of a null distribution.\n\nFirst, the given values are identified:\n- The observed Enrichment Score, $ES_{obs} = 0.62$.\n- The null distribution of absolute enrichment scores, $|ES|_{null}$, generated from permutations, has the following properties:\n  - Mean, $\\mu_{|ES|} = 0.31$.\n  - Standard deviation, $\\sigma_{|ES|} = 0.12$.\n\nThe problem specifies that the normalization process preserves the sign of the observed $ES$. Since $ES_{obs} = 0.62$ is positive, both resulting $NES$ values will be positive. The normalization is performed by standardizing the magnitude of the observed score, $|ES_{obs}|$, against the null distribution of magnitudes.\n\nThe magnitude of the observed enrichment score is $|ES_{obs}| = |0.62| = 0.62$.\n\nThe two required normalization methods are mean-standardization and $z$-score standardization.\n\n1.  **Mean-Standardized $NES$ ($NES_{\\text{mean}}$)**\n    Mean-standardization, in the context of GSEA, involves normalizing the observed score by the mean of the null distribution. The problem directs us to use the null distribution of absolute scores. Therefore, the magnitude of the observed $ES$ is divided by the mean of the absolute scores from the null distribution. The sign of the original $ES_{obs}$ is then applied.\n\n    The formula is:\n    $$NES_{\\text{mean}} = \\text{sign}(ES_{obs}) \\times \\frac{|ES_{obs}|}{\\mu_{|ES|}}$$\n    Given that $ES_{obs}  0$, $\\text{sign}(ES_{obs}) = +1$.\n    Substituting the given values:\n    $$NES_{\\text{mean}} = \\frac{0.62}{0.31} = 2$$\n    Rounding to four significant figures, this is $2.000$.\n\n2.  **$z$-score Standardized $NES$ ($NES_{z}$)**\n    $z$-score standardization rescales a value by expressing it in terms of the number of standard deviations it is from the mean of a distribution. Here, we standardize the magnitude of the observed $ES$, $|ES_{obs}|$, with respect to the mean and standard deviation of the null distribution of absolute scores. The sign of the original $ES_{obs}$ is preserved.\n\n    The formula for a $z$-score is $z = \\frac{(x - \\mu)}{\\sigma}$. Applying this to our context:\n    $$NES_{z} = \\text{sign}(ES_{obs}) \\times \\frac{|ES_{obs}| - \\mu_{|ES|}}{\\sigma_{|ES|}}$$\n    Again, since $ES_{obs}  0$, $\\text{sign}(ES_{obs}) = +1$.\n    Substituting the given values:\n    $$NES_{z} = \\frac{0.62 - 0.31}{0.12} = \\frac{0.31}{0.12}$$\n    $$NES_{z} \\approx 2.58333...$$\n    Rounding this value to four significant figures yields $2.583$.\n\nThe final answer should be presented as a row vector $(NES_{\\text{mean}}, NES_{z})$ with the calculated values rounded to four significant figures.\nThe calculated values are $NES_{\\text{mean}} = 2.000$ and $NES_{z} = 2.583$.", "answer": "$$\\boxed{\\begin{pmatrix} 2.000  2.583 \\end{pmatrix}}$$", "id": "4345921"}, {"introduction": "Previous exercises began with a pre-ranked list of genes, but in practice, generating this list is a critical upstream component of any GSEA workflow. This comprehensive practice simulates a real-world analysis by guiding you through the construction of a pipeline that begins with raw RNA-sequencing count data. By implementing key steps such as normalization, dispersion estimation, and differential expression statistics, you will produce a ranked gene list and perform GSEA, gaining an end-to-end understanding of the entire process from raw data to biological insight [@problem_id:4346070].", "problem": "You are given a directive to construct a pipeline that emulates the per-gene statistical outputs generated by widely used differential expression tools in transcriptomics analysis based on negative binomial modeling assumptions, in order to produce a ranked list suitable for Gene Set Enrichment Analysis (GSEA). The educational context is systems biomedicine, and the topic is gene set enrichment analysis. The pipeline must be grounded in fundamental principles: the negative binomial distribution as a model for RNA-sequencing counts, the concept of compositionality for library size normalization, and the delta method for variance propagation. The task is to implement, for each provided test case, a sequence of steps that justify each preprocessing action in terms of explicit assumptions, compute per-gene statistics suitable for ranking in GSEA, and then compute the classical running-sum enrichment score for a supplied gene set.\n\nFundamental base and assumptions to use:\n- Model RNA-sequencing count data for gene $g$ in sample $i$ as a draw from a negative binomial distribution with mean $\\mu_{g,i}$ and dispersion $\\phi_{g}$, denoted $\\operatorname{NB}(\\mu_{g,i}, \\phi_{g})$, with variance $\\operatorname{Var}(Y_{g,i}) = \\mu_{g,i} + \\phi_{g} \\mu_{g,i}^{2}$. The negative binomial probability mass function is given by\n$$\nP(Y=k \\mid \\mu, \\phi) = \\frac{\\Gamma(k + \\phi^{-1})}{\\Gamma(\\phi^{-1}) \\, k!} \\left(\\frac{\\phi^{-1}}{\\phi^{-1} + \\mu}\\right)^{\\phi^{-1}} \\left(\\frac{\\mu}{\\phi^{-1} + \\mu}\\right)^{k},\n$$\nfor integer $k \\ge 0$, $\\mu  0$, and $\\phi  0$.\n- Assume factorization of the expected counts as $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$ where $s_{i}  0$ is an unknown sample-specific size factor capturing library size and compositional effects, and $\\theta_{g,i}$ is the latent expression level. This compositional assumption implies that only ratios of $\\theta_{g,i}$ are identifiable without absolute calibration.\n- Use a two-group design indicator $X_{i} \\in \\{0,1\\}$ with a log-link generalized linear model $\\log(\\mu_{g,i}) = \\log(s_{i}) + \\beta_{0,g} + \\beta_{1,g} X_{i}$ to model condition effects as multiplicative fold changes on the mean.\n- Use the delta method to approximate the variance of a smooth function of random variables. In particular, for the sample mean under the negative binomial model, the variance of the log of the mean is approximated by dividing the variance of the mean by the square of the mean.\n\nPreprocessing steps and statistical computations to implement for each test case:\n1. Filtering based on detectability: remove genes with insufficient evidence of expression, specifically those with fewer than $2$ samples having strictly positive counts or with a total count less than a chosen minimal value. This is justified by the requirement that the negative binomial dispersion estimation and log-fold-change variance rely on non-degenerate sample means and variances.\n2. Library size normalization: estimate sample-specific size factors $\\{s_{i}\\}$ using a median-of-ratios principle consistent with the factorization $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$. That is, estimate a pseudo-reference per-gene quantity and choose $s_{i}$ so that, for most genes, $Y_{g,i} / s_{i}$ is centered around the reference. When many zeros prevent a stable pseudo-reference, fall back to total-count normalization using $s_{i}$ proportional to the library size, standardized to have mean $1$.\n3. Dispersion estimation: for each gene $g$, estimate a raw dispersion $\\hat{\\phi}_{g}$ using method-of-moments from the normalized counts, $\\hat{\\phi}_{g} = \\max\\{0, (\\hat{v}_{g} - \\hat{m}_{g}) / \\hat{m}_{g}^{2}\\}$, where $\\hat{m}_{g}$ is the across-sample mean of normalized counts and $\\hat{v}_{g}$ is the across-sample variance. Then estimate a trend function $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$ of the form $a + b/\\hat{m}_{g}$ via least squares across genes, and shrink $\\hat{\\phi}_{g}$ toward $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$ to obtain a stabilized dispersion $\\tilde{\\phi}_{g}$ by a convex combination with weight depending on the number of samples.\n4. Per-gene effect and Wald statistic: compute per-gene group means $\\hat{\\mu}_{g,0}$ and $\\hat{\\mu}_{g,1}$ (on normalized scale) for the two conditions. Estimate the log fold change $\\widehat{\\mathrm{LFC}}_{g} = \\log\\left(\\frac{\\hat{\\mu}_{g,1}}{\\hat{\\mu}_{g,0}}\\right)$ using a small positive constant to avoid division by zero where necessary. Using the delta method and the negative binomial variance, approximate the variance of $\\widehat{\\mathrm{LFC}}_{g}$ as\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g}) \\approx \\frac{\\hat{\\mu}_{g,1} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,1}^{2}}{n_{1} \\, \\hat{\\mu}_{g,1}^{2}} + \\frac{\\hat{\\mu}_{g,0} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,0}^{2}}{n_{0} \\, \\hat{\\mu}_{g,0}^{2}},\n$$\nwhere $n_{1}$ and $n_{0}$ are the sample counts in the treatment and control groups, respectively. Define the Wald statistic $Z_{g} = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$, using $Z_{g} = 0$ when the denominator is zero.\n5. Ranking for GSEA: use $Z_{g}$ as the ranking score and compute a weighted running-sum enrichment score for a supplied gene set. For a gene set $S \\subset \\{1,\\dots,G\\}$ and scores $\\{Z_{g}\\}$, sort genes by decreasing $Z_{g}$, use weights $w_{g} = |Z_{g}|^{p}$ with $p = 1$, and compute a running sum that is incremented by $w_{g} / \\sum_{h \\in S} w_{h}$ when $g \\in S$ and decremented by $1 / (G - |S|)$ when $g \\notin S$. The enrichment score is the signed extreme deviation of this running sum from zero.\n\nTest suite:\nFor each test case, you are given a count matrix of dimensions $G \\times S$ (genes by samples), a binary condition vector of length $S$, and one gene set as indices into the gene list. Gene names are implicitly ordered as $G1, G2, \\dots$ corresponding to indices $1, 2, \\dots$.\n\n- Test case $1$ (balanced design, moderate counts):\n  - Counts matrix with $G = 12$ genes and $S = 6$ samples, three controls followed by three treatments. Control samples $A$, $B$, $C$:\n    - $A$: $[40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30]$\n    - $B$: $[42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32]$\n    - $C$: $[39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31]$\n  - Treatment samples $D$, $E$, $F$:\n    - $D$: $[41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33]$\n    - $E$: $[43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34]$\n    - $F$: $[40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]$\n  - Condition vector: $[0,0,0,1,1,1]$.\n  - Gene set: $S_{1} = \\{3,4,5,8,11\\}$.\n  - Required output: the single float enrichment score (running-sum as specified) computed from the pipeline above.\n\n- Test case $2$ (sparse counts, many zeros, balanced design):\n  - Counts matrix with $G = 10$ genes and $S = 4$ samples. Control samples $A$, $B$:\n    - $A$: $[0,0,1,0,2,1,0,0,0,1]$\n    - $B$: $[0,1,0,0,1,0,0,0,1,0]$\n  - Treatment samples $C$, $D$:\n    - $C$: $[0,0,0,0,1,1,0,1,0,0]$\n    - $D$: $[1,0,0,0,0,1,0,0,0,0]$\n  - Condition vector: $[0,0,1,1]$.\n  - Gene set: $S_{2} = \\{2,5,9\\}$.\n  - Required output: the single float enrichment score computed from the pipeline above.\n\n- Test case $3$ (unbalanced design, downregulation in gene set):\n  - Counts matrix with $G = 12$ genes and $S = 6$ samples, four controls followed by two treatments. Control samples $A$, $B$, $C$, $D$:\n    - $A$: $[30,45,60,55,50,40,35,20,25,18,22,28]$\n    - $B$: $[31,44,62,57,49,39,36,21,26,19,23,29]$\n    - $C$: $[32,46,61,56,51,41,34,22,27,17,24,30]$\n    - $D$: $[29,47,63,54,52,42,33,23,28,20,21,27]$\n  - Treatment samples $E$, $F$:\n    - $E$: $[15,45,30,28,26,40,35,20,25,18,22,28]$\n    - $F$: $[16,44,31,29,27,39,36,21,26,19,23,29]$\n  - Condition vector: $[0,0,0,0,1,1]$.\n  - Gene set: $S_{3} = \\{1,3,4,5\\}$.\n  - Required output: the single float enrichment score computed from the pipeline above.\n\nFinal output format:\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., $\"[result1,result2,result3]\"$), where each result is the float enrichment score for the corresponding test case. No additional text should be printed. Angles are not involved, and there are no physical units; express all results as plain decimal floats.", "solution": "The user has directed the construction of a computational pipeline to emulate a standard transcriptomics differential expression analysis followed by Gene Set Enrichment Analysis (GSEA). The problem is scientifically sound, well-posed, and objective, providing a clear sequence of steps based on established principles in systems biomedicine. All necessary components, including the statistical model for RNA-sequencing counts, normalization procedures, effect size estimation, and the enrichment score calculation, are specified. Some minor parameters are left unspecified, which is common in such problems; these have been set to standard, reasonable values as detailed below.\n\nThe solution proceeds by implementing the five specified stages of the analysis pipeline for each test case.\n\n**1. Gene Filtering**\n\nThe first step is to filter out genes with insufficient expression levels, which lack statistical power and can introduce noise. The problem specifies two criteria: remove genes with fewer than $2$ samples having strictly positive counts, or with a total count across all samples less than a chosen minimal value. The rationale is to ensure that per-gene means and variances are computable and non-degenerate. For the sparse data in test case $2$, a high minimal total count would eliminate all genes. Therefore, a small value of $2$ is chosen for this threshold, i.e., `total_count` $\\ge 2$, to retain a minimal set of genes for analysis, which is a common practice for very sparse datasets.\n\n**2. Library Size Normalization**\n\nRNA-sequencing count data is compositional, meaning a gene's count depends on both its expression and the total sequencing depth of its sample. To make counts comparable across samples, we must estimate sample-specific size factors, $s_i$. The model assumes $\\mu_{g,i} = s_i \\theta_{g,i}$, where $\\mu_{g,i}$ is the expected count for gene $g$ in sample $i$, and $\\theta_{g,i}$ is the true expression level. The primary method for estimating $s_i$ is the median-of-ratios method. A pseudo-reference sample is created by taking the geometric mean of counts for each gene across all samples. This is only possible for genes with non-zero counts in every sample. The size factor for each sample $i$ is then the median of the ratios of its counts to the pseudo-reference counts.\n\nIf no gene is expressed in all samples (a common occurrence with sparse data, as in test case $2$), this method fails. The specified fallback is total-count normalization. In this case, the size factor for a sample is its total number of reads. Finally, the set of estimated size factors $\\{s_i\\}$ is scaled to have a mean of $1$ to maintain the count scale. Normalized counts are then computed as $Y_{g,i} / s_i$.\n\n**3. Dispersion Estimation**\n\nThe negative binomial distribution, $\\operatorname{NB}(\\mu, \\phi)$, has a variance that depends on both the mean $\\mu$ and a dispersion parameter $\\phi$ via $\\operatorname{Var}(Y) = \\mu + \\phi \\mu^2$. An accurate estimate of $\\phi$ is critical. This is achieved in three sub-steps:\n- **Raw Dispersion**: For each gene $g$, a raw dispersion $\\hat{\\phi}_g$ is estimated using the method of moments on the normalized counts. The sample mean $\\hat{m}_g$ and variance $\\hat{v}_g$ are computed, and the dispersion is $\\hat{\\phi}_g = \\max\\{0, (\\hat{v}_g - \\hat{m}_g) / \\hat{m}_g^2\\}$.\n- **Trend Fitting**: Individual gene dispersion estimates from small sample sizes are noisy. A more stable estimate is found by modeling the general relationship between dispersion and mean expression. A trend function of the form $\\phi_{\\mathrm{trend}}(\\hat{m}_g) = a + b/\\hat{m}_g$ is fitted to the $(\\hat{m}_g, \\hat{\\phi}_g)$ pairs across all genes using ordinary least squares.\n- **Shrinkage**: The final, stabilized dispersion estimate $\\tilde{\\phi}_g$ for each gene is a weighted average of its raw estimate $\\hat{\\phi}_g$ and the trend value $\\phi_{\\mathrm{trend}}(\\hat{m}_g)$. This \"shrinks\" noisy individual estimates toward the more stable trend. The convex combination is $\\tilde{\\phi}_{g} = \\alpha \\phi_{\\mathrm{trend}}(\\hat{m}_g) + (1-\\alpha) \\hat{\\phi}_{g}$. The weight $\\alpha$ depends on the number of samples $S$, giving more credence to the raw estimate as sample size increases. We use $\\alpha = k/(k+S)$ with a prior strength parameter of $k=4$.\n\n**4. Per-Gene Effect and Wald Statistic**\n\nThe goal is to quantify the expression change between two conditions (e.g., treatment vs. control).\n- **Log-Fold Change (LFC)**: The per-gene means of normalized counts are calculated for the control group ($\\hat{\\mu}_{g,0}$) and the treatment group ($\\hat{\\mu}_{g,1}$). The effect size is the log-fold change, $\\widehat{\\mathrm{LFC}}_{g} = \\log_e(\\hat{\\mu}_{g,1} / \\hat{\\mu}_{g,0})$. To prevent division by zero or taking the logarithm of zero if a group mean is $0$, a small constant $\\epsilon = 10^{-8}$ is added to each mean before calculation.\n- **LFC Variance and Wald Statistic**: The significance of the LFC is assessed using a Wald test. The variance of the LFC estimator is approximated using the delta method and the negative binomial variance function, yielding:\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g}) \\approx \\frac{1/\\hat{\\mu}_{g,1} + \\tilde{\\phi}_{g}}{n_{1}} + \\frac{1/\\hat{\\mu}_{g,0} + \\tilde{\\phi}_{g}}{n_{0}}\n$$\nwhere $n_0$ and $n_1$ are the number of samples in the control and treatment groups, respectively. The Wald statistic is then $Z_g = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$. This statistic serves as the ranking metric for GSEA. If the variance is zero, $Z_g$ is set to $0$.\n\n**5. Gene Set Enrichment Analysis (GSEA)**\n\nGSEA determines whether a predefined set of genes $S$ shows statistically significant, concordant differences between the two conditions.\n- **Ranking**: All filtered genes are ranked in decreasing order based on their Wald statistic $Z_g$.\n- **Running Sum**: A running sum is calculated by walking down the ranked list. The sum is incremented for each gene found that is in the set $S$ and decremented for each gene not in the set. The step sizes are weighted. For a gene $g \\in S$, the increment is proportional to its score, $|Z_g|^p$ with $p=1$, normalized by the total sum of weights for all genes in $S$. For a gene $g \\notin S$, the decrement is a constant $1 / (G_{filt} - |S_{filt}|)$, where $G_{filt}$ is the total number of filtered genes and $|S_{filt}|$ is the size of the filtered gene set.\n- **Enrichment Score (ES)**: The ES is the maximum deviation of the running sum from zero. It is signed, taking the value of the maximum positive deviation or the maximum negative deviation, whichever is larger in magnitude. This score reflects the degree to which the gene set $S$ is overrepresented at the top or bottom of the ranked list of all genes.\n\nThis complete pipeline is applied to each test case to compute the final enrichment score.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis pipeline on the provided test cases.\n    \"\"\"\n\n    def run_pipeline(counts_matrix, condition_vector, gene_set):\n        \"\"\"\n        Executes the full GSEA pipeline for a single test case.\n        \"\"\"\n        # Data setup\n        counts = np.array(counts_matrix).T  # Transpose to get Genes x Samples\n        conditions = np.array(condition_vector)\n        # Convert 1-based gene set to 0-based for Python indexing\n        gene_set_indices = {g - 1 for g in gene_set}\n        \n        # Step 1: Filtering based on detectability\n        min_samples_positive = 2\n        min_total_count = 2  # A reasonable assumption for the provided sparse data\n        \n        positive_samples_per_gene = np.sum(counts  0, axis=1)\n        total_counts_per_gene = np.sum(counts, axis=1)\n        \n        keep_mask = (positive_samples_per_gene = min_samples_positive)  \\\n                    (total_counts_per_gene = min_total_count)\n        \n        filtered_counts = counts[keep_mask]\n        \n        if filtered_counts.shape[0] == 0:\n            return 0.0\n\n        original_indices = np.where(keep_mask)[0]\n        gene_map = {orig_idx: new_idx for new_idx, orig_idx in enumerate(original_indices)}\n        filtered_gene_set = {gene_map[g_idx] for g_idx in gene_set_indices if g_idx in gene_map}\n\n        G_filt, S = filtered_counts.shape\n        \n        # Step 2: Library size normalization\n        genes_all_nonzero_mask = np.all(filtered_counts  0, axis=1)\n        \n        if np.any(genes_all_nonzero_mask):\n            # Median-of-ratios method\n            pseudo_ref_table = filtered_counts[genes_all_nonzero_mask, :]\n            geo_means = np.exp(np.mean(np.log(pseudo_ref_table), axis=1))\n            \n            # Prevent division by zero if a geo_mean is zero\n            geo_means[geo_means == 0] = 1e-9\n\n            # Ratios are S x num_ref_genes\n            ratios = pseudo_ref_table.T / geo_means\n            size_factors_raw = np.median(ratios, axis=1)\n        else:\n            # Fallback to total-count normalization using original pre-filter counts\n            size_factors_raw = np.sum(counts, axis=0)\n            \n        # Standardize size factors to have a mean of 1\n        size_factors = size_factors_raw / np.mean(size_factors_raw)\n        \n        normalized_counts = filtered_counts / size_factors[np.newaxis, :]\n        \n        # Step 3: Dispersion estimation\n        means_g = np.mean(normalized_counts, axis=1)\n        # ddof=1 for unbiased sample variance\n        vars_g = np.var(normalized_counts, axis=1, ddof=1)\n        \n        # Raw dispersion\n        phi_raw = np.zeros_like(means_g)\n        idx_mean_pos = means_g  0\n        phi_raw[idx_mean_pos] = (vars_g[idx_mean_pos] - means_g[idx_mean_pos]) / (means_g[idx_mean_pos]**2)\n        phi_raw[phi_raw  0] = 0\n        \n        # Trend fitting\n        phi_trend = np.zeros_like(means_g)\n        fit_idx = idx_mean_pos  np.isfinite(phi_raw)\n        if np.sum(fit_idx) = 2:\n            means_for_fit = means_g[fit_idx]\n            phi_for_fit = phi_raw[fit_idx]\n            \n            X_fit = np.vstack([np.ones(means_for_fit.shape[0]), 1 / means_for_fit]).T\n            try:\n                coeffs, _, _, _ = np.linalg.lstsq(X_fit, phi_for_fit, rcond=None)\n                a, b = coeffs\n                phi_trend = a + b / means_g\n                phi_trend[phi_trend  0] = 0\n            except np.linalg.LinAlgError:\n                positive_phi_raw = phi_raw[phi_raw  0]\n                median_phi = np.median(positive_phi_raw) if len(positive_phi_raw)  0 else 0.01\n                phi_trend[:] = median_phi\n        else:\n           positive_phi_raw = phi_raw[phi_raw  0]\n           median_phi = np.median(positive_phi_raw) if len(positive_phi_raw)  0 else 0.01\n           phi_trend[:] = median_phi\n\n        # Shrinkage\n        k = 4.0 # Prior strength parameter assumption\n        alpha = k / (k + S)\n        phi_shrunk = alpha * phi_trend + (1 - alpha) * phi_raw\n        phi_shrunk[phi_shrunk  0] = 0\n\n        # Step 4: Per-gene effect and Wald statistic\n        cond0_mask = conditions == 0\n        cond1_mask = conditions == 1\n        n0, n1 = np.sum(cond0_mask), np.sum(cond1_mask)\n        \n        mu_g0 = np.mean(normalized_counts[:, cond0_mask], axis=1)\n        mu_g1 = np.mean(normalized_counts[:, cond1_mask], axis=1)\n        \n        epsilon = 1e-8 # Small constant for numerical stability\n        LFC = np.log((mu_g1 + epsilon) / (mu_g0 + epsilon))\n        \n        var_LFC = ((1 / (mu_g1 + epsilon) + phi_shrunk) / n1) + \\\n                  ((1 / (mu_g0 + epsilon) + phi_shrunk) / n0)\n        \n        Z_scores = np.zeros_like(LFC)\n        valid_var_mask = var_LFC  0\n        Z_scores[valid_var_mask] = LFC[valid_var_mask] / np.sqrt(var_LFC[valid_var_mask])\n\n        # Step 5: Gene Set Enrichment Analysis\n        if len(filtered_gene_set) == 0 or len(filtered_gene_set) == G_filt:\n            return 0.0\n\n        in_set_mask = np.zeros(G_filt, dtype=bool)\n        if filtered_gene_set:\n            in_set_mask[list(filtered_gene_set)] = True\n\n        abs_Z = np.abs(Z_scores)\n        sum_weights_in_set = np.sum(abs_Z[in_set_mask])\n        \n        if sum_weights_in_set == 0:\n            return 0.0\n\n        sorted_indices = np.argsort(Z_scores)[::-1]\n        \n        is_in_set_sorted = in_set_mask[sorted_indices]\n        abs_Z_sorted = abs_Z[sorted_indices]\n        \n        step_hit = abs_Z_sorted / sum_weights_in_set\n        step_miss = 1.0 / (G_filt - len(filtered_gene_set))\n        \n        running_sum = 0.0\n        running_sum_values = [0.0]\n        \n        for i in range(G_filt):\n            if is_in_set_sorted[i]:\n                running_sum += step_hit[i]\n            else:\n                running_sum -= step_miss\n            running_sum_values.append(running_sum)\n            \n        max_rs = np.max(running_sum_values)\n        min_rs = np.min(running_sum_values)\n\n        return max_rs if abs(max_rs)  abs(min_rs) else min_rs\n            \n    test_cases = [\n        {\n            \"counts\": [\n                [40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30],\n                [42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32],\n                [39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31],\n                [41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33],\n                [43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34],\n                [40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]\n            ],\n            \"conditions\": [0, 0, 0, 1, 1, 1],\n            \"gene_set\": {3, 4, 5, 8, 11}\n        },\n        {\n            \"counts\": [\n                [0, 0, 1, 0, 2, 1, 0, 0, 0, 1],\n                [0, 1, 0, 0, 1, 0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1, 1, 0, 1, 0, 0],\n                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n            ],\n            \"conditions\": [0, 0, 1, 1],\n            \"gene_set\": {2, 5, 9}\n        },\n        {\n            \"counts\": [\n                [30, 45, 60, 55, 50, 40, 35, 20, 25, 18, 22, 28],\n                [31, 44, 62, 57, 49, 39, 36, 21, 26, 19, 23, 29],\n                [32, 46, 61, 56, 51, 41, 34, 22, 27, 17, 24, 30],\n                [29, 47, 63, 54, 52, 42, 33, 23, 28, 20, 21, 27],\n                [15, 45, 30, 28, 26, 40, 35, 20, 25, 18, 22, 28],\n                [16, 44, 31, 29, 27, 39, 36, 21, 26, 19, 23, 29]\n            ],\n            \"conditions\": [0, 0, 0, 0, 1, 1],\n            \"gene_set\": {1, 3, 4, 5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_pipeline(case[\"counts\"], case[\"conditions\"], case[\"gene_set\"])\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "4346070"}]}