{"hands_on_practices": [{"introduction": "Before we can perform sophisticated analyses, we must master the fundamentals of representing bipartite networks. This first practice exercise focuses on translating a conceptual graph of transcription factor (TF) and gene interactions into its precise mathematical forms: the biadjacency and full adjacency matrices. By constructing these matrices and calculating vertex degrees, you will gain concrete experience with the foundational data structures used in nearly all bipartite graph algorithms [@problem_id:4321176]. Verifying the handshake lemma provides a critical self-check to ensure your representation is consistent.", "problem": "In a transcription factor–gene regulatory system, consider a bipartite graph with a set of transcription factors (TFs) $U = \\{T_1, T_2, T_3\\}$ and a set of genes $V = \\{G_1, G_2, G_3, G_4\\}$. An edge between $T_i \\in U$ and $G_j \\in V$ represents experimentally supported binding. The initial evidence defines the edge set $E_0$ as\n$$\nE_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}.\n$$\nUse the following foundational definitions: a bipartite graph has no edges within $U$ or within $V$; the biadjacency matrix $B \\in \\{0,1\\}^{|U|\\times|V|}$ has entries $B_{ij} = 1$ if there is an edge between $T_i$ and $G_j$, and $B_{ij} = 0$ otherwise; the full adjacency matrix $A \\in \\{0,1\\}^{(|U|+|V|)\\times(|U|+|V|)}$ under the vertex ordering $(U,V)$ is block-structured as\n$$\nA = \\begin{pmatrix}\n0 & B \\\\\nB^{\\top} & 0\n\\end{pmatrix};\n$$\nthe degree of a vertex is the number of incident edges; the handshake lemma for bipartite graphs states that the sum of degrees over $U$ equals the sum of degrees over $V$ and equals the total number of edges.\n\nTasks:\n- Construct the initial biadjacency matrix $B_0$ and the full adjacency matrix $A_0$ corresponding to $E_0$.\n- Compute the degree vector over $U$, denoted $d_U^{(0)} \\in \\mathbb{N}^{|U|}$, and the degree vector over $V$, denoted $d_V^{(0)} \\in \\mathbb{N}^{|V|}$, for the initial graph. Verify that the handshake lemma holds for $E_0$.\n- New chromatin immunoprecipitation sequencing evidence indicates two additional bindings: $(T_1,G_2)$ and $(T_3,G_4)$. Let $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$. Construct the updated biadjacency matrix $B_1$ and full adjacency matrix $A_1$, and the updated degree vectors $d_U^{(1)}$ and $d_V^{(1)}$. Verify the handshake lemma again for $E_1$.\n\nFinally, define the update matrix $\\Delta A = A_1 - A_0$ and compute the scalar\n$$\nS = \\|\\Delta A\\|_F^2 = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A).\n$$\nReport only the value of $S$ as your final answer. No rounding is required.", "solution": "The problem is well-defined, scientifically grounded, and provides all necessary information to proceed with a solution.\n\nThe set of transcription factors is $U = \\{T_1, T_2, T_3\\}$, so $|U|=3$. The set of genes is $V = \\{G_1, G_2, G_3, G_4\\}$, so $|V|=4$. The total number of vertices in the bipartite graph is $|U|+|V| = 3+4=7$.\n\nFirst, we construct the initial biadjacency matrix $B_0$ corresponding to the edge set $E_0 = \\{(T_1,G_1), (T_1,G_3), (T_2,G_2), (T_2,G_3), (T_2,G_4), (T_3,G_1)\\}$. The matrix $B_0$ is a $3 \\times 4$ matrix where rows correspond to elements of $U$ and columns to elements of $V$. An entry $B_{ij}$ is $1$ if there is an edge between $T_i$ and $G_j$.\n$$\nB_0 = \\begin{pmatrix}\n1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0\n\\end{pmatrix}\n$$\nThe full adjacency matrix $A_0$ is a $7 \\times 7$ block matrix defined as $A_0 = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & B_0 \\\\ B_0^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$.\n$$\nA_0 = \\left(\\begin{array}{ccc|cccc}\n0 & 0 & 0 & 1 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 0 & 1 & 1 & 1 \\\\\n0 & 0 & 0 & 1 & 0 & 0 & 0 \\\\\n\\hline\n1 & 0 & 1 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 1 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 & 0 & 0 & 0\n\\end{array}\\right)\n$$\nNext, we compute the degree vectors. The degree of a vertex in $U$ is the sum of its corresponding row in $B_0$. The degree of a vertex in $V$ is the sum of its corresponding column in $B_0$.\nThe degree vector for $U$ is $d_U^{(0)}$:\n$\\deg(T_1) = 1+0+1+0 = 2$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+0 = 1$\nSo, $d_U^{(0)} = (2, 3, 1)^{\\top}$.\n\nThe degree vector for $V$ is $d_V^{(0)}$:\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 0+1+0 = 1$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+0 = 1$\nSo, $d_V^{(0)} = (2, 1, 2, 1)^{\\top}$.\n\nTo verify the handshake lemma, we sum the degrees in each partition and compare to the number of edges, $|E_0| = 6$.\nSum of degrees in $U$: $\\sum_{i=1}^{3} (d_U^{(0)})_i = 2+3+1 = 6$.\nSum of degrees in $V$: $\\sum_{j=1}^{4} (d_V^{(0)})_j = 2+1+2+1 = 6$.\nSince both sums equal $|E_0|$, the handshake lemma holds for the initial graph.\n\nNow, we consider the updated graph with two new edges, $(T_1,G_2)$ and $(T_3,G_4)$. The new edge set is $E_1 = E_0 \\cup \\{(T_1,G_2),(T_3,G_4)\\}$, with $|E_1| = 6+2 = 8$ edges. The updated biadjacency matrix $B_1$ is obtained by adding these edges to $B_0$, which corresponds to setting the entries for the new edges, $(T_1,G_2)$ and $(T_3,G_4)$, to 1.\n$$\nB_1 = \\begin{pmatrix}\n1 & 1 & 1 & 0 \\\\\n0 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThe updated full adjacency matrix is $A_1 = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & B_1 \\\\ B_1^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$.\n\nThe updated degree vectors $d_U^{(1)}$ and $d_V^{(1)}$ are:\n$d_U^{(1)}$ (row sums of $B_1$):\n$\\deg(T_1) = 1+1+1+0 = 3$\n$\\deg(T_2) = 0+1+1+1 = 3$\n$\\deg(T_3) = 1+0+0+1 = 2$\nSo, $d_U^{(1)} = (3, 3, 2)^{\\top}$.\n\n$d_V^{(1)}$ (column sums of $B_1$):\n$\\deg(G_1) = 1+0+1 = 2$\n$\\deg(G_2) = 1+1+0 = 2$\n$\\deg(G_3) = 1+1+0 = 2$\n$\\deg(G_4) = 0+1+1 = 2$\nSo, $d_V^{(1)} = (2, 2, 2, 2)^{\\top}$.\n\nVerifying the handshake lemma for the updated graph:\nSum of degrees in $U$: $\\sum_{i=1}^{3} (d_U^{(1)})_i = 3+3+2 = 8$.\nSum of degrees in $V$: $\\sum_{j=1}^{4} (d_V^{(1)})_j = 2+2+2+2 = 8$.\nBoth sums equal $|E_1|=8$, so the lemma holds.\n\nFinally, we compute the scalar $S = \\|\\Delta A\\|_F^2$, where $\\Delta A = A_1 - A_0$.\nFirst, we find the difference matrix $\\Delta A$.\n$$\n\\Delta A = A_1 - A_0 = \\begin{pmatrix} \\mathbf{0} & B_1 \\\\ B_1^{\\top} & \\mathbf{0} \\end{pmatrix} - \\begin{pmatrix} \\mathbf{0} & B_0 \\\\ B_0^{\\top} & \\mathbf{0} \\end{pmatrix} = \\begin{pmatrix} \\mathbf{0} & B_1 - B_0 \\\\ B_1^{\\top} - B_0^{\\top} & \\mathbf{0} \\end{pmatrix}\n$$\nLet $\\Delta B = B_1 - B_0$.\n$$\n\\Delta B = \\begin{pmatrix}\n1 & 1 & 1 & 0 \\\\\n0 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 1\n\\end{pmatrix} - \\begin{pmatrix}\n1 & 0 & 1 & 0 \\\\\n0 & 1 & 1 & 1 \\\\\n1 & 0 & 0 & 0\n\\end{pmatrix} = \\begin{pmatrix}\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n$$\nThis matrix $\\Delta B$ has non-zero entries only for the added edges $(T_1, G_2)$ and $(T_3, G_4)$.\nThe full difference matrix is $\\Delta A = \\begin{pmatrix} \\mathbf{0}_{3\\times3} & \\Delta B \\\\ \\Delta B^{\\top} & \\mathbf{0}_{4\\times4} \\end{pmatrix}$.\nExplicitly:\n$$\n\\Delta A = \\left(\\begin{array}{ccc|cccc}\n0 & 0 & 0 & 0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 1 \\\\\n\\hline\n0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 & 0 & 0 & 0\n\\end{array}\\right)\n$$\nThe squared Frobenius norm, $S = \\|\\Delta A\\|_F^2$, is the sum of the squares of all elements in $\\Delta A$.\n$$\nS = \\sum_{i,j} (\\Delta A_{ij})^2\n$$\nThe non-zero entries of $\\Delta A$ are $1$ at positions $(1,5)$, $(3,7)$, $(5,1)$, and $(7,3)$. There are $4$ such entries.\nTherefore, the sum of their squares is:\n$$\nS = 1^2 + 1^2 + 1^2 + 1^2 = 1+1+1+1 = 4\n$$\nThis value can also be found using the trace definition $S = \\operatorname{trace}(\\Delta A^{\\top}\\Delta A)$. As $\\Delta A$ is a real symmetric matrix, $\\Delta A^{\\top} = \\Delta A$, so $S = \\operatorname{trace}(\\Delta A^2)$. The diagonal elements of $\\Delta A^2$ are the dot product of rows of $\\Delta A$ with themselves. This just counts the number of non-zero entries in each row. For example, the first diagonal element of $\\Delta A^2$ is $1$, from row $1$ of $\\Delta A$ which has one non-zero entry. There are $4$ rows with one non-zero entry each. So the trace will be $1+1+1+1 = 4$. Both methods yield the same result.\nA more direct argument based on the block structure is $S = \\|\\Delta A\\|_F^2 = \\|\\Delta B\\|_F^2 + \\|\\Delta B^{\\top}\\|_F^2$.\n$\\|\\Delta B\\|_F^2 = 1^2 + 1^2 = 2$.\nSince the Frobenius norm is invariant under transposition, $\\|\\Delta B^{\\top}\\|_F^2 = 2$.\nThus, $S = 2 + 2 = 4$.", "answer": "$$\\boxed{4}$$", "id": "4321176"}, {"introduction": "With a grasp of the basic matrix representations, we can now use them to uncover meaningful patterns within the network. In systems biology, small, recurring subgraphs called network motifs often correspond to specific biological functions. This exercise explores the 4-cycle, a canonical motif in bipartite graphs that can represent, for example, two enzymes coregulating two metabolites. You will derive and implement an elegant linear algebraic method to count these motifs efficiently, showcasing the power of matrix operations in solving combinatorial problems [@problem_id:4321179].", "problem": "Consider a simple bipartite graph $G=(V,E)$ with disjoint vertex classes $V_{\\mathrm{enz}}$ (enzymes) and $V_{\\mathrm{met}}$ (metabolites), where every edge $e \\in E$ connects one vertex in $V_{\\mathrm{enz}}$ to one vertex in $V_{\\mathrm{met}}$. Let the biadjacency matrix be $B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$, with $B_{ij} = 1$ if enzyme $i$ is connected to metabolite $j$, and $B_{ij} = 0$ otherwise. Assume there are no multi-edges and no self-loops, so $B$ is binary and describes a simple bipartite graph. A $4$-cycle is a simple cycle of length $4$ that alternates between $V_{\\mathrm{enz}}$ and $V_{\\mathrm{met}}$, i.e., a sequence of distinct vertices $(e_a, m_u, e_b, m_v)$ with $e_a, e_b \\in V_{\\mathrm{enz}}$, $m_u, m_v \\in V_{\\mathrm{met}}$, and edges $(e_a,m_u)$, $(m_u,e_b)$, $(e_b,m_v)$, $(m_v,e_a)$ present in $E$.\n\nStarting only from these core definitions, derive a principled algorithm to compute the integer $C_4$, the number of distinct simple $4$-cycles in $G$, by expressing $C_4$ in terms of the matrix products $B B^{\\top}$ and $B^{\\top} B$ and a combinatorial counting argument over shared neighbors. Your derivation must justify why counting unordered pairs of shared neighbors across one partition yields the total number of distinct simple $4$-cycles and why an equivalent symmetric expression exists over the other partition. Based on this derivation, implement a program that computes $C_4$ for each of the test networks below.\n\nRepresent each test network by a binary matrix $B$ whose rows index enzymes and whose columns index metabolites. The matrices are:\n\n- Test $1$ (a minimal $4$-cycle in a complete bipartite subgraph): $B = \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}$.\n- Test $2$ (no $4$-cycles, sparse connections): $B = \\begin{bmatrix} 1 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix}$.\n- Test $3$ (multiple overlapping $4$-cycles): $B = \\begin{bmatrix} 1 & 1 & 1 & 0 \\\\ 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 1 \\end{bmatrix}$.\n- Test $4$ (complete bipartite $K_{3,3}$): $B = \\begin{bmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}$.\n- Test $5$ (boundary case, single enzyme): $B = \\begin{bmatrix} 1 & 1 & 1 & 1 \\end{bmatrix}$.\n\nYour program must, for each $B$ above, compute $C_4$ as an integer using the principled algorithm derived from the core definitions. In addition, for internal validation, you should ensure that the value obtained by counting over enzymes (via $B B^{\\top}$) equals the value obtained by counting over metabolites (via $B^{\\top} B$), and equals a direct enumeration by checking all unordered pairs of enzymes and metabolites. The final output should be a single line containing a list of the computed $C_4$ values, in the order of the tests $1$ through $5$, formatted as a comma-separated list enclosed in square brackets (e.g., $[a,b,c,d,e]$). No physical units or angle units are involved, and no percentages are required; every output entry must be an integer.\n\nYour program should produce exactly one line with the final list, with no additional text.", "solution": "The problem statement is evaluated for validity prior to attempting a solution.\n\n### Step 1: Extract Givens\n- **Graph Type**: A simple bipartite graph $G=(V,E)$ with disjoint vertex classes $V_{\\mathrm{enz}}$ (enzymes) and $V_{\\mathrm{met}}$ (metabolites).\n- **Edge Definition**: Every edge $e \\in E$ connects one vertex in $V_{\\mathrm{enz}}$ to one vertex in $V_{\\mathrm{met}}$.\n- **Biadjacency Matrix**: $B \\in \\{0,1\\}^{n_{\\mathrm{enz}} \\times n_{\\mathrm{met}}}$, where $n_{\\mathrm{enz}} = |V_{\\mathrm{enz}}|$ and $n_{\\mathrm{met}} = |V_{\\mathrm{met}}|$. $B_{ij} = 1$ if enzyme $i$ is connected to metabolite $j$, and $B_{ij} = 0$ otherwise.\n- **Cycle Definition**: A simple $4$-cycle is a sequence of distinct vertices $(e_a, m_u, e_b, m_v)$ where $e_a, e_b \\in V_{\\mathrm{enz}}$, $m_u, m_v \\in V_{\\mathrm{met}}$, and edges $(e_a,m_u)$, $(m_u,e_b)$, $(e_b,m_v)$, $(m_v,e_a)$ are present in $E$.\n- **Objective**: Derive an algorithm to compute $C_4$, the number of distinct simple $4$-cycles, using matrix products $B B^{\\top}$ and $B^{\\top} B$, and implement it.\n- **Test Data**:\n    - Test $1$: $B = \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}$\n    - Test $2$: $B = \\begin{bmatrix} 1 & 0 & 0 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{bmatrix}$\n    - Test $3$: $B = \\begin{bmatrix} 1 & 1 & 1 & 0 \\\\ 1 & 1 & 1 & 0 \\\\ 0 & 1 & 1 & 1 \\end{bmatrix}$\n    - Test $4$: $B = \\begin{bmatrix} 1 & 1 & 1 \\\\ 1 & 1 & 1 \\\\ 1 & 1 & 1 \\end{bmatrix}$\n    - Test $5$: $B = \\begin{bmatrix} 1 & 1 & 1 & 1 \\end{bmatrix}$\n- **Output Format**: A single line with a comma-separated list of integer results, `[c1,c2,c3,c4,c5]`.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is assessed against the required criteria.\n- **Scientifically Grounded**: The problem is based on fundamental and standard concepts from graph theory and linear algebra. The use of biadjacency matrices to represent bipartite graphs and the counting of subgraphs are well-established mathematical topics. Their application to enzyme-metabolite networks is a common abstraction in systems biology.\n- **Well-Posed**: The problem is clearly defined. The input matrices are explicitly given, and the desired output, the number of $4$-cycles, is a uniquely determinable integer for each input.\n- **Objective**: The problem statement uses precise, formal mathematical language, free from ambiguity or subjective claims.\n- **Flaw Analysis**:\n    1.  **Scientific/Factual Unsoundness**: None. The definitions and premises are standard and mathematically sound.\n    2.  **Non-Formalizable/Irrelevant**: None. The problem is explicitly mathematical and relevant to the stated field.\n    3.  **Incomplete/Contradictory**: None. All necessary definitions and data are provided.\n    4.  **Unrealistic/Infeasible**: None. The problem deals with abstract graph structures, and the computations for the given matrices are trivial for a modern computer.\n    5.  **Ill-Posed/Poorly Structured**: None. A unique solution exists and is derivable from the premises.\n    6.  **Pseudo-Profound/Trivial**: None. The problem requires a non-trivial derivation connecting matrix algebra to combinatorial counting, which is a standard but conceptually meaningful exercise.\n    7.  **Outside Scientific Verifiability**: None. The results can be verified by direct enumeration and through the derived formula.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. A principled solution will be derived and implemented.\n\n### Derivation of the Algorithm\n\nA simple $4$-cycle in a bipartite graph with partitions $V_{\\mathrm{enz}}$ and $V_{\\mathrm{met}}$ is defined by a sequence of four distinct vertices $(e_a, m_u, e_b, m_v)$, where $e_a, e_b \\in V_{\\mathrm{enz}}$ and $m_u, m_v \\in V_{\\mathrm{met}}$. The existence of the cycle implies the presence of four edges: $(e_a, m_u)$, $(e_a, m_v)$, $(e_b, m_u)$, and $(e_b, m_v)$. These four vertices and four edges form a complete bipartite subgraph $K_{2,2}$. Therefore, counting the number of distinct simple $4$-cycles, $C_4$, is equivalent to counting the number of distinct $K_{2,2}$ subgraphs in $G$.\n\nA $K_{2,2}$ subgraph is uniquely determined by an unordered pair of distinct enzymes, $\\{e_a, e_b\\}$, and an unordered pair of distinct metabolites, $\\{m_u, m_v\\}$, such that all four corresponding edges exist. We can count these subgraphs by iterating over pairs of vertices in one partition and counting how many pairs from the other partition complete a $K_{2,2}$.\n\n**Method 1: Counting via Enzyme Pairs**\n\nConsider any unordered pair of distinct enzymes, $\\{e_a, e_b\\}$, from $V_{\\mathrm{enz}}$. For these two enzymes to be part of a $4$-cycle, they must share at least two common metabolite neighbors. Let $N(v)$ denote the set of neighbors of a vertex $v$. The set of common metabolite neighbors for $e_a$ and $e_b$ is $N(e_a) \\cap N(e_b)$. Let the size of this set be $k_{ab} = |N(e_a) \\cap N(e_b)|$.\n\nTo form a $4$-cycle with $e_a$ and $e_b$, we must choose two distinct metabolites from their common neighbors. The number of ways to choose an unordered pair of metabolites from this set of $k_{ab}$ common neighbors is given by the binomial coefficient $\\binom{k_{ab}}{2}$. Each such choice forms exactly one unique $K_{2,2}$ subgraph (and thus one $4$-cycle) with the enzyme pair $\\{e_a, e_b\\}$.\n\nTo find the total number of $4$-cycles, $C_4$, we must sum this quantity over all distinct unordered pairs of enzymes:\n$$ C_4 = \\sum_{\\{e_a, e_b\\} \\subseteq V_{\\mathrm{enz}}, |\\{e_a, e_b\\}|=2} \\binom{k_{ab}}{2} = \\sum_{1 \\le a < b \\le n_{\\mathrm{enz}}} \\binom{k_{ab}}{2} $$\nwhere $a$ and $b$ are indices for the enzymes.\n\nWe can express $k_{ab}$ using the biadjacency matrix $B$. The $i$-th row of $B$, denoted $B_{i,:}$, is a vector where the $j$-th component is $1$ if enzyme $e_i$ is connected to metabolite $m_j$. The number of common neighbors, $k_{ab}$, is the number of positions where both $B_{a,:}$ and $B_{b,:}$ are $1$. This is precisely the dot product of these two row vectors:\n$$ k_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} $$\nNow, consider the matrix product $S_{\\mathrm{enz}} = B B^{\\top}$. This is an $n_{\\mathrm{enz}} \\times n_{\\mathrm{enz}}$ symmetric matrix. The element $(S_{\\mathrm{enz}})_{ab}$ is the dot product of the $a$-th row of $B$ and the $b$-th column of $B^{\\top}$. Since the $b$-th column of $B^{\\top}$ is the $b$-th row of $B$, we have:\n$$ (S_{\\mathrm{enz}})_{ab} = \\sum_{j=1}^{n_{\\mathrm{met}}} B_{aj} B_{bj} = k_{ab} $$\nThus, the off-diagonal elements of $S_{\\mathrm{enz}} = B B^{\\top}$ count the number of shared metabolite neighbors between pairs of enzymes. The diagonal elements $(S_{\\mathrm{enz}})_{aa}$ count the degree of enzyme $e_a$, which is not relevant for this calculation.\n\nSubstituting this into our counting formula, we get the algorithm:\n$$ C_4 = \\sum_{1 \\le a < b \\le n_{\\mathrm{enz}}} \\binom{(S_{\\mathrm{enz}})_{ab}}{2} = \\sum_{1 \\le a < b \\le n_{\\mathrm{enz}}} \\frac{(S_{\\mathrm{enz}})_{ab}((S_{\\mathrm{enz}})_{ab} - 1)}{2} $$\nThis expression sums the contributions from the upper (or lower) triangle of the matrix $S_{\\mathrm{enz}}$, excluding the diagonal.\n\n**Method 2: Counting via Metabolite Pairs (Symmetric Argument)**\n\nThe argument is perfectly symmetric. We can start by considering an unordered pair of distinct metabolites, $\\{m_u, m_v\\}$, from $V_{\\mathrm{met}}$. Let $k'_{uv} = |N(m_u) \\cap N(m_v)|$ be the number of common enzyme neighbors for this pair. To form a $4$-cycle, we must choose two distinct enzymes from this set, which can be done in $\\binom{k'_{uv}}{2}$ ways.\n\nSumming over all distinct unordered pairs of metabolites gives the total count:\n$$ C_4 = \\sum_{\\{m_u, m_v\\} \\subseteq V_{\\mathrm{met}}, |\\{m_u, m_v\\}|=2} \\binom{k'_{uv}}{2} = \\sum_{1 \\le u < v \\le n_{\\mathrm{met}}} \\binom{k'_{uv}}{2} $$\nThe number of common neighbors $k'_{uv}$ can be found from the columns of $B$. Let $B_{:,j}$ be the $j$-th column vector. Then:\n$$ k'_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} $$\nThis corresponds to the elements of the matrix product $S_{\\mathrm{met}} = B^{\\top}B$, an $n_{\\mathrm{met}} \\times n_{\\mathrm{met}}$ symmetric matrix, where:\n$$ (S_{\\mathrm{met}})_{uv} = \\sum_{i=1}^{n_{\\mathrm{enz}}} B_{iu} B_{iv} = k'_{uv} $$\nThis leads to the equivalent formula:\n$$ C_4 = \\sum_{1 \\le u < v \\le n_{\\mathrm{met}}} \\binom{(S_{\\mathrm{met}})_{uv}}{2} = \\sum_{1 \\le u < v \\le n_{\\mathrm{met}}} \\frac{(S_{\\mathrm{met}})_{uv}((S_{\\mathrm{met}})_{uv} - 1)}{2} $$\n\n**Equivalence Justification**\nBoth formulas count the same set of objects: the $K_{2,2}$ subgraphs, each corresponding to a unique simple $4$-cycle. The first formula partitions the count based on pairs of enzymes, while the second partitions the count based on pairs of metabolites. Since each $4$-cycle involves exactly one pair of enzymes and one pair of metabolites, both summations must yield the same total, $C_4$. This confirms the combinatorial identity:\n$$ \\sum_{1 \\le a < b \\le n_{\\mathrm{enz}}} \\binom{(BB^{\\top})_{ab}}{2} = \\sum_{1 \\le u < v \\le n_{\\mathrm{met}}} \\binom{(B^{\\top}B)_{uv}}{2} $$\n\nThe derived algorithm is to first compute one of these \"shared neighbor\" matrices ($S_{\\mathrm{enz}}$ or $S_{\\mathrm{met}}$), then iterate through its unique off-diagonal elements $k$, and sum the values of $\\binom{k}{2}$. This is computationally more efficient than enumerating all combinations of four vertices. The implementation will use the enzyme-centric formula.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef count_c4(B: np.ndarray) -> int:\n    \"\"\"\n    Computes the number of simple 4-cycles (C4) in a bipartite graph.\n\n    The algorithm is derived from a combinatorial argument based on shared neighbors.\n    A 4-cycle is formed by two enzymes {e_a, e_b} and two metabolites {m_u, m_v}.\n    This structure requires that both enzymes are connected to both metabolites.\n    \n    1. The number of 4-cycles can be found by summing contributions from every\n       pair of enzymes {e_a, e_b}.\n    2. For a given pair, if they share k_ab common metabolite neighbors, they can\n       form binom(k_ab, 2) distinct 4-cycles by choosing 2 metabolites from\n       the shared set.\n    3. The number of shared neighbors k_ab for enzymes e_a and e_b is given by\n       the matrix product S_enz = B @ B.T, where (S_enz)_ab = k_ab.\n    4. The total count C4 is the sum of binom(k, 2) over all off-diagonal\n       elements k of the S_enz matrix.\n\n    Args:\n        B: The n_enz x n_met biadjacency matrix of the graph, as a numpy array.\n\n    Returns:\n        The total number of simple 4-cycles (C4) as an integer.\n    \"\"\"\n    if B.shape[0] < 2:\n        # A 4-cycle requires at least two enzymes.\n        return 0\n\n    # S_enz is the enzyme-enzyme shared neighbor matrix.\n    # (S_enz)_ab = number of metabolites connected to both enzyme a and enzyme b.\n    S_enz = B @ B.T\n\n    num_enzymes = S_enz.shape[0]\n    c4_count = 0\n\n    # Iterate over the upper triangle of the S_enz matrix (excluding the diagonal).\n    # This corresponds to iterating over all unique pairs of enzymes {a, b}.\n    for i in range(num_enzymes):\n        for j in range(i + 1, num_enzymes):\n            # k is the number of shared neighbors for the enzyme pair {i, j}.\n            k = S_enz[i, j]\n            \n            # If there are k shared neighbors, we can form binom(k, 2) 4-cycles.\n            # binom(k, 2) = k * (k - 1) / 2\n            if k >= 2:\n                c4_count += k * (k - 1) // 2\n                \n    return c4_count\n\ndef solve():\n    \"\"\"\n    Defines the test cases, computes C4 for each, and prints the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: a minimal 4-cycle in a complete bipartite subgraph\n        np.array([[1, 1], \n                  [1, 1]]),\n        # Test 2: no 4-cycles, sparse connections\n        np.array([[1, 0, 0],\n                  [1, 0, 0],\n                  [0, 1, 0]]),\n        # Test 3: multiple overlapping 4-cycles\n        np.array([[1, 1, 1, 0],\n                  [1, 1, 1, 0],\n                  [0, 1, 1, 1]]),\n        # Test 4: complete bipartite K_{3,3}\n        np.array([[1, 1, 1],\n                  [1, 1, 1],\n                  [1, 1, 1]]),\n        # Test 5: boundary case, single enzyme\n        np.array([[1, 1, 1, 1]])\n    ]\n\n    results = []\n    for B in test_cases:\n        result = count_c4(B)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4321179"}, {"introduction": "This final practice moves from local structural analysis to global network optimization, with direct application to identifying metabolic vulnerabilities. The concept of a minimum vertex cover, a set of nodes that \"touches\" every edge in the graph, provides a powerful model for finding metabolic \"choke points\" whose removal would disrupt a wide range of reactions. This advanced problem challenges you to implement an algorithm based on Kőnig's theorem to find such a cover, bridging the gap between a classic graph theory result and a tangible strategy for biological network intervention [@problem_id:4321211].", "problem": "Consider a reaction–metabolite bipartite network modeled as a bipartite graph $G = (R \\cup M, E)$, where $R$ is the set of reaction vertices, $M$ is the set of metabolite vertices, and $E \\subseteq R \\times M$ is the set of edges linking reactions to metabolites if the metabolite participates in the reaction (either as a substrate or product). The graph is simple, unweighted, and without self-loops. All vertices in $R$ are indexed from $0$ to $r - 1$, and all vertices in $M$ are indexed from $0$ to $m - 1$, where $r = |R|$ and $m = |M|$. For a given instance, the bipartite structure is provided by specifying $r$, $m$, and the list of edges as ordered pairs $(i, j)$ with $i \\in \\{0, 1, \\dots, r - 1\\}$ and $j \\in \\{0, 1, \\dots, m - 1\\}$.\n\nFrom first principles in graph theory, a vertex cover of a graph is a set of vertices $C \\subseteq R \\cup M$ such that every edge in $E$ has at least one endpoint in $C$. A minimum vertex cover is a vertex cover of minimum possible cardinality. In the reaction–metabolite bipartite network context, the subset of metabolite vertices included in a minimum vertex cover can be interpreted as potential choke points for pathway disruption, because removing those metabolites from the network eliminates all incident reaction–metabolite edges, thereby blocking associated reaction connectivity through the covered edges.\n\nYour task is to write a complete program that, for each test case, computes one minimum vertex cover of the bipartite graph and outputs the indices of the metabolite vertices (from $M$) that are included in that cover, sorted in nondecreasing order. The result for each test case must be a list of integers.\n\nStart from core definitions and widely accepted graph-theoretic facts. Do not assume or use any ad hoc shortcuts not grounded in these. The algorithm should be correct for any bipartite graph instance described by the given parameters.\n\nNo physical units or angles are involved. All outputs must be purely numerical.\n\nTest suite:\n- Test case $1$: $r = 4$, $m = 4$, edges $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)\\}$.\n- Test case $2$: $r = 3$, $m = 2$, edges $E = \\{(0, 0), (1, 0), (2, 0)\\}$.\n- Test case $3$: $r = 2$, $m = 3$, edges $E = \\{(0, 0), (1, 1)\\}$.\n- Test case $4$: $r = 4$, $m = 4$, edges $E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$.\n- Test case $5$: $r = 2$, $m = 2$, edges $E = \\emptyset$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of metabolite indices in the computed minimum vertex cover, sorted in nondecreasing order. For example, an output with two test cases might look like $[[0,1],[2]]$. Your program must output exactly one such line for the provided test suite.", "solution": "The problem requires us to find the set of metabolite vertices belonging to a minimum vertex cover of a given reaction-metabolite bipartite graph $G = (R \\cup M, E)$. The solution must be derived from fundamental principles of graph theory.\n\nThe paramount principle connecting minimum vertex covers and another key graph structure in bipartite graphs is Kőnig's theorem. This theorem states that in any bipartite graph, the number of edges in a maximum matching is equal to the number of vertices in a minimum vertex cover.\nLet $\\mathcal{M}_{max}$ be a maximum matching (a largest set of edges with no common vertices) and $C_{min}$ be a minimum vertex cover (a smallest set of vertices incident to every edge). Kőnig's theorem states:\n$$|\\mathcal{M}_{max}| = |C_{min}|$$\nThe constructive proof of Kőnig's theorem provides a direct algorithm to find a minimum vertex cover, given a maximum matching. Our strategy will be to follow this constructive algorithm.\n\nThe algorithm proceeds in two main steps:\n1.  Find a maximum matching $\\mathcal{M}$ in the bipartite graph $G$.\n2.  Use the matching $\\mathcal{M}$ to construct a minimum vertex cover $C$.\n\n**Step 1: Finding a Maximum Matching**\n\nA maximum matching can be found by repeatedly finding \"augmenting paths\". An augmenting path is a path in the graph that alternates between edges not in the current matching and edges in the current matching, starting from an unmatched vertex in one partition and ending at an unmatched vertex in the other. By inverting the status of edges along an augmenting path (adding the non-matching edges to the matching and removing the matching ones), the size of the matching increases by one. We continue finding and applying augmenting paths until no more can be found. At that point, the matching is maximum.\n\nThis search for augmenting paths can be implemented efficiently using a Depth-First Search (DFS) or Breadth-First Search (BFS). We will use a DFS-based approach. We iterate through each vertex $u$ in the reaction set $R$. For each $u$, we perform a DFS to find an augmenting path starting from it.\n\nLet the two partitions of the graph be $U=R$ (reactions) and $V=M$ (metabolites). A matching can be represented by an array, `match_M`, of size $m=|M|$, where `match_M[j]` stores the vertex in $R$ matched with metabolite $j \\in M$, or a special value (e.g., $-1$) if $j$ is unmatched.\n\nThe DFS function, `dfs(u, visited, match_M, adj)`, attempts to find an augmenting path starting from reaction vertex $u \\in R$. The `visited` array keeps track of metabolite vertices visited within the current DFS to prevent cycles. The function works as follows: for each neighbor $v \\in M$ of $u$, if $v$ has not been visited, we mark it as visited. If $v$ is unmatched, we have found an augmenting path. We match $u$ with $v$ and return true. If $v$ is already matched with some vertex $u' \\in R$, we recursively call `dfs(u', ...)`. If this recursive call finds an augmenting path starting from $u'$, we can \"shift\" the matching: $u'$ gets a new partner, freeing up $v$, which we can then match with $u$.\n\n**Step 2: Constructing the Minimum Vertex Cover**\n\nOnce a maximum matching $\\mathcal{M}$ is found, we can construct a minimum vertex cover $C$. Let $R_u$ be the set of unmatched vertices in the reaction set $R$. Let $Z$ be the set of all vertices in $G$ that are reachable from any vertex in $R_u$ by an alternating path. An alternating path is a path whose edges alternate between being outside $\\mathcal{M}$ and inside $\\mathcal{M}$. The set $Z$ can be found with a single graph traversal (DFS or BFS) starting from all vertices in $R_u$:\n- From a vertex $u \\in R \\cap Z$, traverse to a vertex $v \\in M$ if the edge $(u,v)$ is **not** in $\\mathcal{M}$.\n- From a vertex $v \\in M \\cap Z$, traverse to a vertex $u \\in R$ if the edge $(u,v)$ **is** in $\\mathcal{M}$.\n\nAfter finding the set $Z$, which can be partitioned into $Z_R = Z \\cap R$ and $Z_M = Z \\cap M$, the minimum vertex cover $C$ is given by the formula from the constructive proof of Kőnig's theorem:\n$$C = (R \\setminus Z_R) \\cup Z_M$$\nThe problem asks for the indices of the metabolite vertices in this cover, which is precisely the set $Z_M$.\n\nLet's illustrate with Test Case 4: $r=4, m=4, E = \\{(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)\\}$.\n- The partitions are $R=\\{0, 1, 2, 3\\}$ and $M=\\{0, 1, 2, 3\\}$.\n- **Step 1:** We find a maximum matching. A possible maximum matching found by the augmenting path algorithm is $\\mathcal{M} = \\{(0,0), (1,1), (2,2)\\}$. The size of this matching is $3$. Vertex $r_3$ is unmatched in $R$, and vertices $m_1$ and $m_3$ are unmatched in $M$.\n- **Step 2:** We construct the vertex cover.\n  - The set of unmatched vertices in $R$ is $R_u = \\{3\\}$.\n  - We find the set $Z$ of vertices reachable from $R_u$ via alternating paths.\n    1. Start a traversal from $r_3$. Add $r_3$ to $Z$.\n    2. From $r_3$, we can traverse the non-matching edge $(3,2)$ to reach $m_2$. Add $m_2$ to $Z$.\n    3. From $m_2$, we must traverse a matching edge. The edge $(2,2)$ is in $\\mathcal{M}$. So, we traverse to $r_2$. Add $r_2$ to $Z$.\n    4. From $r_2$, we can only traverse a non-matching edge, but its only neighbor is $m_2$, which is already in $Z$. The traversal stops.\n  - The set of visited vertices is $Z = \\{r_2, r_3, m_2\\}$.\n  - We partition $Z$ into $Z_R = \\{2, 3\\}$ and $Z_M = \\{2\\}$.\n  - The minimum vertex cover is $C = (R \\setminus Z_R) \\cup Z_M = (\\{0,1,2,3\\} \\setminus \\{2,3\\}) \\cup \\{2\\} = \\{0,1\\} \\cup \\{2\\}$. This refers to vertices $r_0, r_1, m_2$.\n  - The size of $C$ is $3$, which correctly equals the size of the maximum matching.\n- The metabolite vertices in the cover are those in $Z_M$, which is $\\{m_2\\}$. The required output is the list of indices, sorted non-decreasingly: $[2]$.\n\nThe provided code implements this procedure for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    It iterates through test cases, computes the metabolite indices in a minimum\n    vertex cover for each, and prints the results in the specified format.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2), (3, 3)]),\n        # Test case 2\n        (3, 2, [(0, 0), (1, 0), (2, 0)]),\n        # Test case 3\n        (2, 3, [(0, 0), (1, 1)]),\n        # Test case 4\n        (4, 4, [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]),\n        # Test case 5\n        (2, 2, [])\n    ]\n\n    results = []\n    for r, m, edges in test_cases:\n        result = compute_mvc_metabolites(r, m, edges)\n        results.append(result)\n\n    # Format the final output string as per requirements, removing spaces in lists.\n    # e.g., [[0,1],[2]] instead of '[[0, 1], [2]]'\n    formatted_results = [str(res).replace(\" \", \"\") for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_mvc_metabolites(r, m, edges):\n    \"\"\"\n    Computes the metabolite indices in a minimum vertex cover of a bipartite graph.\n\n    The function follows the constructive proof of Kőnig's theorem:\n    1. Find a maximum matching using an augmenting path algorithm (DFS-based).\n    2. Construct the minimum vertex cover from the matching by finding all\n       vertices reachable from unmatched R-vertices via alternating paths.\n    3. Return the metabolite vertices from the constructed cover.\n\n    Args:\n        r (int): Number of vertices in the reaction set R.\n        m (int): Number of vertices in the metabolite set M.\n        edges (list of tuples): The set of edges E, where each edge is (i, j)\n                                with i in R and j in M.\n\n    Returns:\n        list of int: A sorted list of indices of metabolite vertices in one\n                     minimum vertex cover.\n    \"\"\"\n    if not edges:\n        return []\n\n    adj = [[] for _ in range(r)]\n    for u, v in edges:\n        adj[u].append(v)\n\n    # `match_m[j]` stores the R-vertex matched with M-vertex j.\n    match_m = np.full(m, -1, dtype=int)\n\n    def dfs_match(u, visited_m_dfs, current_match_m, adj_list):\n        \"\"\"\n        DFS to find an augmenting path starting from an R-vertex u.\n        \"\"\"\n        for v in adj_list[u]:\n            if not visited_m_dfs[v]:\n                visited_m_dfs[v] = True\n                # If v is unmatched, or its partner can find another match\n                if current_match_m[v] < 0 or dfs_match(current_match_m[v], visited_m_dfs, current_match_m, adj_list):\n                    current_match_m[v] = u\n                    return True\n        return False\n\n    # Step 1: Find a maximum matching\n    for i in range(r):\n        visited_m_in_dfs = np.zeros(m, dtype=bool)\n        dfs_match(i, visited_m_in_dfs, match_m, adj)\n        \n    # Build reverse matching for convenience\n    match_r = np.full(r, -1, dtype=int)\n    for j in range(m):\n        if match_m[j] != -1:\n            match_r[match_m[j]] = j\n\n    # Step 2: Construct the minimum vertex cover\n    unmatched_r = [i for i in range(r) if match_r[i] == -1]\n\n    # Find the set Z of vertices reachable from unmatched_r via alternating paths\n    z_r = set(unmatched_r)\n    z_m = set()\n    queue = list(unmatched_r)\n    head = 0\n\n    while head < len(queue):\n        u = queue[head]\n        head += 1\n        for v in adj[u]:\n            # Traverse non-matching edge from R to M\n            if v not in z_m and match_r[u] != v:\n                z_m.add(v)\n                u_partner = match_m[v]\n                # If endpoint is matched, traverse matching edge from M to R\n                if u_partner != -1 and u_partner not in z_r:\n                    z_r.add(u_partner)\n                    queue.append(u_partner)\n\n    # The metabolite vertices in the minimum vertex cover are exactly z_m.\n    # The cover C = (R \\ z_r) U z_m\n    mvc_metabolites = sorted(list(z_m))\n    \n    return mvc_metabolites\n\nsolve()\n```", "id": "4321211"}]}