{"hands_on_practices": [{"introduction": "To truly understand network modularity, we begin with a foundational calculation. This first exercise walks you through computing the modularity score $Q$ for a simple, unweighted network from first principles. By manually calculating the observed versus expected edge densities, you will gain a concrete intuition for how modularity quantifies community structure relative to a random baseline. [@problem_id:4365529]", "problem": "In systems biomedicine, community structure within molecular interaction networks is often quantified by the modularity score, which compares the observed within-module connectivity to a degree-preserving random null model. Consider an undirected, simple weighted network with node set $\\{1,2,3,4\\}$ and edges $(1,2)$, $(2,3)$, $(3,4)$, each with weight $1$. Let $A_{ij}$ denote the symmetric weighted adjacency matrix entries and let $k_i$ denote the node strength (the sum of weights of edges incident to node $i$). Let $m$ denote the total edge weight, so that $2m=\\sum_{i}k_i$. The degree-preserving null (the Configuration Model (CM)) has expected adjacency $\\mathbb{E}[A_{ij}]$ that depends only on $\\{k_i\\}$ and $m$.\n\nStarting from the fundamental definition that modularity is the normalized difference between the observed fraction of intra-community edge weight and its expectation under the degree-preserving null, derive the expression for the modularity $Q$ of the partition $\\{\\{1,2\\},\\{3,4\\}\\}$ and compute its value for this network. Conclude, based on the sign of $Q$, whether this partition increases $Q$ relative to random. Express your final numerical value as an exact rational number without rounding.", "solution": "The user-provided problem is assessed to be valid. It is scientifically grounded in network theory, well-posed with a unique answer, objective, and contains all necessary information for a solution.\n\nThe problem asks for the derivation and computation of the modularity score, $Q$, for a specific partition of a given weighted network. The fundamental definition of modularity, as stated, is the normalized difference between the observed fraction of intra-community edge weight and its expectation under a degree-preserving null model (the Configuration Model).\n\nFirst, we formalize the network structure and properties based on the givens.\nThe network has a node set $V=\\{1,2,3,4\\}$ and three edges, each with weight $1$: $(1,2)$, $(2,3)$, and $(3,4)$.\nThe weighted adjacency matrix $A$, where $A_{ij}$ is the weight of the edge between nodes $i$ and $j$, is:\n$$\nA = \\begin{pmatrix}\n0 & 1 & 0 & 0 \\\\\n1 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 1 \\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}\n$$\nThe strength of a node $i$, denoted $k_i$, is the sum of the weights of all edges connected to it, $k_i = \\sum_j A_{ij}$. We calculate the strengths for each node:\n- $k_1 = A_{12} = 1$\n- $k_2 = A_{21} + A_{23} = 1 + 1 = 2$\n- $k_3 = A_{32} + A_{34} = 1 + 1 = 2$\n- $k_4 = A_{43} = 1$\n\nThe total edge weight of the network, $m$, is the sum of all edge weights: $m = 1+1+1=3$. This can be verified using the relation $2m = \\sum_i k_i$, which gives $2m = k_1+k_2+k_3+k_4 = 1+2+2+1=6$, thus $m=3$.\n\nThe specified partition divides the nodes into two communities: $C_1 = \\{1,2\\}$ and $C_2 = \\{3,4\\}$.\n\nWe can derive the expression for modularity $Q$ from first principles. Let $L_s$ be the sum of edge weights within a community $s$, and let $K_s$ be the sum of the strengths of all nodes in community $s$. Let $m$ be the total edge weight in the network.\n\nThe fraction of the total edge weight that falls within community $s$ is $e_{ss} = \\frac{L_s}{m}$.\nThe fraction of all edge \"ends\" (or \"stubs\" in the Configuration Model) that are attached to nodes in community $s$ is $a_s = \\frac{K_s}{2m}$. In a random network where edges are formed by connecting stubs uniformly at random, the probability that both ends of a randomly chosen edge fall within community $s$ is $a_s \\times a_s = a_s^2$. This term, $a_s^2$, represents the expected fraction of total edge weight that would be internal to community $s$ under the degree-preserving null model.\n\nModularity, $Q$, is the sum of the differences between the observed and expected fractions over all communities in the partition:\n$$\nQ = \\sum_{s} (e_{ss} - a_s^2) = \\sum_{s} \\left[ \\frac{L_s}{m} - \\left(\\frac{K_s}{2m}\\right)^2 \\right]\n$$\nThis is a standard and direct formulation of modularity for weighted networks. Now, we compute the necessary quantities for the given partition.\n\nFor community $C_1 = \\{1,2\\}$:\n- The intra-community weight, $L_1$, is the weight of the edge $(1,2)$, so $L_1 = 1$.\n- The sum of node strengths, $K_1$, is $k_1 + k_2 = 1 + 2 = 3$.\n\nFor community $C_2 = \\{3,4\\}$:\n- The intra-community weight, $L_2$, is the weight of the edge $(3,4)$, so $L_2 = 1$.\n- The sum of node strengths, $K_2$, is $k_3 + k_4 = 2 + 1 = 3$.\n\nThe total network weight is $m=3$, and $2m=6$.\n\nNow we can calculate the terms for each community's contribution to $Q$.\n\nContribution from $C_1$:\n$$e_{11} - a_1^2 = \\frac{L_1}{m} - \\left(\\frac{K_1}{2m}\\right)^2 = \\frac{1}{3} - \\left(\\frac{3}{6}\\right)^2 = \\frac{1}{3} - \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{3} - \\frac{1}{4}$$\n$$ = \\frac{4}{12} - \\frac{3}{12} = \\frac{1}{12}$$\n\nContribution from $C_2$:\n$$e_{22} - a_2^2 = \\frac{L_2}{m} - \\left(\\frac{K_2}{2m}\\right)^2 = \\frac{1}{3} - \\left(\\frac{3}{6}\\right)^2 = \\frac{1}{3} - \\left(\\frac{1}{2}\\right)^2 = \\frac{1}{3} - \\frac{1}{4}$$\n$$ = \\frac{4}{12} - \\frac{3}{12} = \\frac{1}{12}$$\n\nThe total modularity $Q$ is the sum of these contributions:\n$$Q = (e_{11} - a_1^2) + (e_{22} - a_2^2) = \\frac{1}{12} + \\frac{1}{12} = \\frac{2}{12} = \\frac{1}{6}$$\n\nThe calculated modularity is $Q = \\frac{1}{6}$.\n\nThe sign of the modularity score indicates whether the partition identifies a community structure that is more pronounced than would be expected at random. Since $Q > 0$, the density of intra-community edges (total weight) in the partition $\\{\\{1,2\\},\\{3,4\\}\\}$ is greater than what is expected under the Configuration Model null hypothesis. Therefore, this partition reflects a meaningful community structure in the network, and it increases $Q$ relative to a random baseline.", "answer": "$$\n\\boxed{\\frac{1}{6}}\n$$", "id": "4365529"}, {"introduction": "Biological systems are often characterized by directionality, such as in gene regulatory or metabolic networks where interactions flow from one molecule to another. This practice extends the concept of modularity to directed graphs. You will learn how to adapt the null model by preserving both the in-degree and out-degree of each node, a critical adjustment for accurately identifying communities in networks where influence is not symmetric. [@problem_id:4365539]", "problem": "In systems biomedicine, community detection in directed biomolecular interaction networks such as a Gene Regulatory Network (GRN) is often quantified by a scalar quantity called network modularity, which measures how much a given partition concentrates edges within communities beyond what would be expected under a random null model that preserves the in-degree and out-degree sequences. Consider a directed network with nodes $1$, $2$, and $3$, and directed edges $1 \\to 2$, $2 \\to 3$, and $3 \\to 1$. Let the partition of nodes be $\\{\\{1,2\\},\\{3\\}\\}$, where nodes $1$ and $2$ form one community and node $3$ is alone in the other community. Using the standard configuration-model null ensemble for directed networks that preserves the in-degree and out-degree of each node, compute the modularity $Q$ for this partition. Your computation must proceed by first explicitly calculating the in-degree $k_{i}^{\\text{in}}$ and out-degree $k_{i}^{\\text{out}}$ for each node $i \\in \\{1,2,3\\}$, then evaluating the observed within-community edge count and its expectation under the null model, and finally assembling these into the modularity $Q$ for the specified partition. Express your final answer as an exact rational number, with no rounding.", "solution": "The problem requires the computation of the modularity, $Q$, for a given partition of a specific directed network. The modularity for a directed network measures the extent to which edges are concentrated within communities compared to a random null model. The standard definition of modularity, $Q$, for a partition of a directed network into a set of communities $\\{c\\}$ is given by:\n\n$$ Q = \\frac{1}{M} \\sum_{i,j} \\left[ A_{ij} - P_{ij} \\right] \\delta(c_i, c_j) $$\n\nwhere:\n- $M$ is the total number of edges in the network.\n- $A_{ij}$ is the adjacency matrix element, equal to $1$ if a directed edge exists from node $i$ to node $j$, and $0$ otherwise.\n- $P_{ij}$ is the probability of an edge existing from node $i$ to node $j$ in the configuration null model, given by $P_{ij} = \\frac{k_i^{\\text{out}} k_j^{\\text{in}}}{M}$. Here, $k_i^{\\text{out}}$ is the out-degree of node $i$ and $k_j^{\\text{in}}$ is the in-degree of node $j$.\n- $c_i$ is the community assignment of node $i$.\n- $\\delta(c_i, c_j)$ is the Kronecker delta, which is $1$ if nodes $i$ and $j$ are in the same community ($c_i = c_j$) and $0$ otherwise.\n\nThe calculation will proceed by following the steps outlined in the problem statement.\n\nFirst, we identify the network's properties from the problem description.\nThe network has nodes $V = \\{1, 2, 3\\}$.\nThe directed edges are $1 \\to 2$, $2 \\to 3$, and $3 \\to 1$.\nThe total number of edges is $M=3$.\nThe adjacency matrix $A$ is:\n$$ A = \\begin{pmatrix} 0 & 1 & 0 \\\\ 0 & 0 & 1 \\\\ 1 & 0 & 0 \\end{pmatrix} $$\n\nThe specified partition is $\\{\\{1,2\\},\\{3\\}\\}$. Let's denote community $C_1 = \\{1, 2\\}$ and community $C_2 = \\{3\\}$.\n\n**Step 1: Calculate the in-degree and out-degree for each node.**\n\n- For node $1$: There is one outgoing edge ($1 \\to 2$) and one incoming edge ($3 \\to 1$).\n  $$ k_1^{\\text{out}} = 1, \\quad k_1^{\\text{in}} = 1 $$\n- For node $2$: There is one outgoing edge ($2 \\to 3$) and one incoming edge ($1 \\to 2$).\n  $$ k_2^{\\text{out}} = 1, \\quad k_2^{\\text{in}} = 1 $$\n- For node $3$: There is one outgoing edge ($3 \\to 1$) and one incoming edge ($2 \\to 3$).\n  $$ k_3^{\\text{out}} = 1, \\quad k_3^{\\text{in}} = 1 $$\nThe sum of out-degrees is $\\sum_{i} k_i^{\\text{out}} = 1+1+1=3$, and the sum of in-degrees is $\\sum_{j} k_j^{\\text{in}} = 1+1+1=3$. Both sums are equal to the total number of edges $M$, as expected.\n\n**Step 2: Evaluate the observed within-community edge count.**\n\nThe modularity formula can be expressed as the difference between the fraction of edges that are within communities and the expected fraction of such edges in the null model.\nThe fraction of edges within communities is given by $\\frac{1}{M}\\sum_{i,j} A_{ij} \\delta(c_i, c_j)$.\nWe sum the number of edges that start and end in the same community.\n- For community $C_1 = \\{1, 2\\}$, we check for edges $(i,j)$ where $i,j \\in \\{1,2\\}$. The only such edge is $1 \\to 2$. Thus, the number of internal edges is $L_{C_1} = 1$.\n- For community $C_2 = \\{3\\}$, we check for edges $(i,j)$ where $i,j \\in \\{3\\}$. There are no self-loops on node $3$. Thus, the number of internal edges is $L_{C_2} = 0$.\n\nThe total number of observed within-community edges is $L = L_{C_1} + L_{C_2} = 1 + 0 = 1$.\nThe fraction of observed within-community edges is $\\frac{L}{M} = \\frac{1}{3}$.\n\n**Step 3: Evaluate the expected within-community edge count under the null model.**\n\nThe expected fraction of edges within communities is given by $\\frac{1}{M}\\sum_{i,j} P_{ij} \\delta(c_i, c_j) = \\frac{1}{M^2}\\sum_{i,j} k_i^{\\text{out}} k_j^{\\text{in}} \\delta(c_i, c_j)$.\nThis term can be calculated by summing the contributions from each community. Let $K_c^{\\text{out}} = \\sum_{i \\in c} k_i^{\\text{out}}$ and $K_c^{\\text{in}} = \\sum_{j \\in c} k_j^{\\text{in}}$. The expected fraction is $\\sum_{c} \\frac{K_c^{\\text{out}} K_c^{\\text{in}}}{M^2}$.\n\n- For community $C_1 = \\{1, 2\\}$:\n  The total out-degree is $K_{C_1}^{\\text{out}} = k_1^{\\text{out}} + k_2^{\\text{out}} = 1 + 1 = 2$.\n  The total in-degree is $K_{C_1}^{\\text{in}} = k_1^{\\text{in}} + k_2^{\\text{in}} = 1 + 1 = 2$.\n  The expected fraction of edges within $C_1$ is $\\frac{K_{C_1}^{\\text{out}} K_{C_1}^{\\text{in}}}{M^2} = \\frac{2 \\times 2}{3^2} = \\frac{4}{9}$.\n\n- For community $C_2 = \\{3\\}$:\n  The total out-degree is $K_{C_2}^{\\text{out}} = k_3^{\\text{out}} = 1$.\n  The total in-degree is $K_{C_2}^{\\text{in}} = k_3^{\\text{in}} = 1$.\n  The expected fraction of edges within $C_2$ is $\\frac{K_{C_2}^{\\text{out}} K_{C_2}^{\\text{in}}}{M^2} = \\frac{1 \\times 1}{3^2} = \\frac{1}{9}$.\n\nThe total expected fraction of within-community edges is the sum of these contributions:\n$$ \\frac{4}{9} + \\frac{1}{9} = \\frac{5}{9} $$\n\n**Step 4: Assemble these components to compute the modularity $Q$.**\n\nThe modularity $Q$ is the difference between the observed fraction of within-community edges and the expected fraction:\n$$ Q = (\\text{Observed fraction}) - (\\text{Expected fraction}) $$\n$$ Q = \\frac{1}{3} - \\frac{5}{9} $$\nTo subtract, we find a common denominator, which is $9$:\n$$ Q = \\frac{3}{9} - \\frac{5}{9} = -\\frac{2}{9} $$\n\nThe modularity for the given partition is $-\\frac{2}{9}$. The negative value indicates that the given partition has fewer internal edges than would be expected at random under the specified configuration null model.", "answer": "$$\\boxed{-\\frac{2}{9}}$$", "id": "4365539"}, {"introduction": "Calculating modularity for a given partition is one thing; finding the optimal partition is another. For any non-trivial network, the number of possible partitions is astronomically large, making an exhaustive search computationally infeasible. This exercise shifts our focus to the practical aspects of modularity optimization by analyzing the runtime complexity of the Louvain algorithm, a widely used heuristic. Understanding its efficiency on sparse networks reveals why it has become an essential tool for discovering community structure in large-scale systems biology data. [@problem_id:4365494]", "problem": "Consider an undirected, simple biological interaction network (for example, a proteinâ€“protein interaction graph) represented as a graph with $n$ nodes and $m$ edges. The network is sparse in the sense that the average degree $d$ satisfies $d = \\frac{2m}{n} = \\mathcal{O}(1)$ as $n$ grows, and empirical evidence in systems biomedicine indicates that such graphs have heavy-tailed but finite-variance degree distributions with $k_{\\max}$ growing sublinearly in $n$. The task is to approximate the expected runtime scaling of the Louvain modularity optimization algorithm (Louvain) on this network.\n\nYou may assume the following implementation details, which reflect widely used practice in computational systems biology:\n- The graph is stored in adjacency lists, and community-level statistics (e.g., intra-community edge weights and sum of degrees) are maintained and updated in amortized $\\mathcal{O}(1)$ time per neighbor operation using hash maps keyed by community identifiers.\n- In the local moving phase of Louvain, each node $i$ is visited, and candidate community changes are restricted to the set of communities that appear among neighbors of $i$, so the number of candidate communities is at most the degree $k_i$ of node $i$.\n- The modularity $Q$ of a partition $\\{c_i\\}$ is defined by\n$$\nQ = \\frac{1}{2m} \\sum_{i,j} \\left( A_{ij} - \\frac{k_i k_j}{2m} \\right) \\delta(c_i, c_j),\n$$\nwhere $A_{ij}$ is the adjacency, $k_i$ is the degree of node $i$, and $\\delta$ is the Kronecker delta. The computation of the change in modularity $\\Delta Q$ upon moving node $i$ into any candidate neighboring community can be computed in time proportional to the number of distinct neighboring communities, which is at most $k_i$ when using the stated data structures.\n- The algorithm proceeds by alternating local moving phases, which complete when no positive $\\Delta Q$ moves remain, with aggregation phases that form a coarse-grained network of communities as super-nodes and inter-community edges as super-edges. Empirically in sparse biological networks, the expected number of full local-moving sweeps per level is a constant $s = \\mathcal{O}(1)$, and the expected number of aggregation levels until convergence is a constant $L = \\mathcal{O}(1)$.\n\nStarting only from these definitions and assumptions, derive the expected scaling of the Louvain runtime as a big-$\\mathcal{O}$ expression in terms of $m$. Provide a single big-$\\mathcal{O}$ expression as your final answer, written solely in terms of $m$ (do not include $n$). No numerical evaluation is required, and no units are needed. The final answer must be a single expression.", "solution": "The objective is to determine the expected scaling of the computational runtime of the Louvain algorithm as applied to a sparse biological network, based on the provided definitions and assumptions. The total runtime, denoted by $T$, is the sum of the runtimes for each phase of the algorithm, accumulated across all aggregation levels.\n\nThe algorithm proceeds through a sequence of $L$ levels, where the problem states that $L$ can be treated as a constant, i.e., $L = \\mathcal{O}(1)$. The total runtime $T$ is the sum of the runtimes $T_l$ for each level $l$, from $l=1$ to $l=L$:\n$$ T = \\sum_{l=1}^{L} T_l $$\nLet the graph at level $l$ be denoted by $G_l = (V_l, E_l)$, with $n_l = |V_l|$ nodes and $m_l = |E_l|$ edges. The initial graph given is $G_1$, so we have $n_1=n$ and $m_1=m$.\n\nThe runtime for a single level $l$, $T_l$, is the sum of the costs of two main phases: the local community moving phase, $T_{l, \\text{move}}$, and the network aggregation phase, $T_{l, \\text{agg}}$.\n$$ T_l = T_{l, \\text{move}} + T_{l, \\text{agg}} $$\nWe will analyze the complexity of each phase for an arbitrary level $l$.\n\nFirst, we analyze the local moving phase. This phase consists of a number of \"sweeps\" over all nodes in the graph $G_l$. The problem assumes that the expected number of sweeps per level is a constant, $s = \\mathcal{O}(1)$. Therefore, the complexity of the local moving phase is proportional to the complexity of a single sweep.\n$$ T_{l, \\text{move}} = s \\cdot \\mathcal{O}(\\text{cost of one sweep}) = \\mathcal{O}(\\text{cost of one sweep}) $$\nDuring one sweep, the algorithm visits each node $i \\in V_l$ and evaluates the gain in modularity, $\\Delta Q$, that would result from moving node $i$ into the community of one of its neighbors. The problem specifies that the candidate communities for node $i$ are restricted to those present among its neighbors. The number of such distinct communities is at most the degree of node $i$, which we denote by $k_i$.\n\nThe computational cost to process a single node $i$ is dominated by calculating the $\\Delta Q$ for all candidate moves. According to the problem statement, necessary community-level statistics are maintained in data structures (hash maps) that allow for updates in amortized $\\mathcal{O}(1)$ time. An efficient implementation to find the best move for node $i$ involves a single pass through its $k_i$ neighbors. In this pass, one can build a mapping (e.g., using a hash map) from each neighboring community identifier to the sum of weights of edges connecting node $i$ to that community. This step takes $\\mathcal{O}(k_i)$ time. With this information, the $\\Delta Q$ for moving $i$ into any of these candidate communities can be calculated in $\\mathcal{O}(1)$ time per community. As there are at most $k_i$ candidate communities, the total time to evaluate all moves for node $i$ is $\\mathcal{O}(k_i)$.\n\nThe total cost for one complete sweep over all $n_l$ nodes is the sum of the costs for processing each node:\n$$ \\text{cost of one sweep} = \\sum_{i \\in V_l} \\mathcal{O}(k_i) = \\mathcal{O}\\left(\\sum_{i \\in V_l} k_i\\right) $$\nBy the handshaking lemma for undirected graphs, the sum of the degrees of all nodes is equal to twice the number of edges: $\\sum_{i \\in V_l} k_i = 2m_l$.\nThus, the cost of a single sweep is $\\mathcal{O}(2m_l) = \\mathcal{O}(m_l)$.\nGiven that the number of sweeps $s$ is a constant, the total cost of the local moving phase at level $l$ is $T_{l, \\text{move}} = \\mathcal{O}(m_l)$.\n\nNext, we analyze the aggregation phase. In this phase, a new coarse-grained network $G_{l+1}$ is built. The nodes of $G_{l+1}$ are the communities found in $G_l$. The edges and their weights in $G_{l+1}$ represent the inter-community connections from $G_l$. To construct this new graph, one can iterate through all $m_l$ edges of the graph $G_l$. For each edge $(u,v) \\in E_l$, we find the community memberships $c_u$ and $c_v$ of nodes $u$ and $v$, respectively. Assuming node community assignments are stored in an array, this lookup is an $\\mathcal{O}(1)$ operation. If $c_u \\neq c_v$, the weight of the super-edge between communities $c_u$ and $c_v$ is updated. Using a hash map to store the super-edges of $G_{l+1}$, this update is an amortized $\\mathcal{O}(1)$ operation. The entire aggregation process therefore requires a single pass over the $m_l$ edges, resulting in a runtime of $T_{l, \\text{agg}} = \\mathcal{O}(m_l)$.\n\nCombining the costs for both phases at level $l$, we get:\n$$ T_l = T_{l, \\text{move}} + T_{l, \\text{agg}} = \\mathcal{O}(m_l) + \\mathcal{O}(m_l) = \\mathcal{O}(m_l) $$\nFinally, to find the total runtime $T$ of the algorithm, we sum the runtimes over all $L$ levels:\n$$ T = \\sum_{l=1}^{L} T_l = \\sum_{l=1}^{L} \\mathcal{O}(m_l) $$\nThe number of edges in the coarse-grained graphs is non-increasing with each level, so $m_{l+1} \\leq m_l$ for all $l$. This means that $m_l \\leq m_1$ for all $l \\geq 1$, where $m_1 = m$ is the number of edges in the original graph. We can therefore bound the sum:\n$$ T = \\mathcal{O}(m_1 + m_2 + \\dots + m_L) \\leq \\mathcal{O}(m_1 + m_1 + \\dots + m_1) = \\mathcal{O}(L \\cdot m_1) = \\mathcal{O}(L \\cdot m) $$\nSince the number of levels $L$ is assumed to be a constant, $L = \\mathcal{O}(1)$, the total expected runtime scaling is:\n$$ T = \\mathcal{O}(1 \\cdot m) = \\mathcal{O}(m) $$\nThe problem asks for the scaling solely in terms of $m$. The assumption of sparsity, $d = \\frac{2m}{n} = \\mathcal{O}(1)$, implies a linear relationship between $m$ and $n$, specifically $m = \\Theta(n)$. The derived scaling of $\\mathcal{O}(m)$ is consistent with this property and is the final expression for the runtime complexity.", "answer": "$$ \\boxed{\\mathcal{O}(m)} $$", "id": "4365494"}]}