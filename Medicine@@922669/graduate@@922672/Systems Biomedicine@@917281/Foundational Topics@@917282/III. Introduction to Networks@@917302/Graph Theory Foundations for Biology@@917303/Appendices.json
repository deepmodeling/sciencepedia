{"hands_on_practices": [{"introduction": "Biological networks are rich with recurring interaction patterns, or 'motifs,' that form the building blocks of cellular function. This exercise demonstrates how to move beyond simple visual inspection and use linear algebra to systematically identify one of the most important motifs: the three-node feedback loop. By exploring the connection between the adjacency matrix $A$ and the number of 3-cycles, you will gain hands-on practice in applying a fundamental graph theory result to quantify key regulatory structures in a gene network [@problem_id:4349908].", "problem": "Consider a directed gene regulatory network with six Transcription Factors (TFs), modeled by a simple directed graph (no self-loops and no multi-edges) whose structure is encoded by the $6 \\times 6$ adjacency matrix $A$, where $A_{ij} = 1$ if there is a directed interaction from TF $i$ to TF $j$, and $A_{ij} = 0$ otherwise. The matrix $A$ is\n$$\nA \\;=\\;\n\\begin{pmatrix}\n0  1  0  0  1  0 \\\\\n0  0  1  1  0  1 \\\\\n1  0  0  1  0  0 \\\\\n0  1  0  0  1  0 \\\\\n0  0  1  0  0  1 \\\\\n1  0  0  1  0  0\n\\end{pmatrix}.\n$$\nUsing only core definitions and well-tested facts of graph theory pertaining to adjacency matrices and walks in directed graphs, derive how the quantity $\\mathrm{tr}(A^{3})$ reveals the presence of directed $3$-cycles (three-node feedback loops) in this network. Then evaluate $\\mathrm{tr}(A^{3})$ for the given $A$. Your final answer must be the value of $\\mathrm{tr}(A^{3})$ as a single real number. Additionally, as part of your derivation, briefly justify the biological significance of directed $3$-cycles in systems biomedicine. Do not include any units in the final numerical answer.", "solution": "The problem asks for a derivation of the relationship between the trace of the cube of the adjacency matrix, $\\mathrm{tr}(A^3)$, and the number of directed $3$-cycles in a graph, followed by the calculation of this value for a specific gene regulatory network.\n\nFirst, let us establish the theoretical foundation. A fundamental result in graph theory states that for a simple directed graph with $n$ nodes and an adjacency matrix $A$, the entry $(A^k)_{ij}$ of the matrix power $A^k$ gives the number of distinct walks of length $k$ from node $i$ to node $j$. A walk of length $k$ is a sequence of $k+1$ nodes $v_0, v_1, \\dots, v_k$ such that there is a directed edge from $v_{m-1}$ to $v_m$ for all $m \\in \\{1, \\dots, k\\}$.\n\nFor $k=3$, the element $(A^3)_{ij}$ is the number of distinct walks of length $3$ from node $i$ to node $j$. The matrix $A^3$ is the product of $A^2$ and $A$, where $(A^2)_{ip} = \\sum_{q=1}^{n} A_{iq}A_{qp}$. Thus, the elements of $A^3$ are given by:\n$$ (A^3)_{ij} = \\sum_{p=1}^{n} (A^2)_{ip} A_{pj} = \\sum_{p=1}^{n} \\left( \\sum_{q=1}^{n} A_{iq}A_{qp} \\right) A_{pj} = \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pj} $$\nThis expression counts the number of walks of the form $i \\to q \\to p \\to j$.\n\nThe trace of $A^3$, denoted $\\mathrm{tr}(A^3)$, is the sum of the diagonal elements of $A^3$:\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} (A^3)_{ii} $$\nSubstituting the expression for the diagonal elements, we get:\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{n} \\sum_{p=1}^{n}\\sum_{q=1}^{n} A_{iq}A_{qp}A_{pi} $$\nEach term $A_{iq}A_{qp}A_{pi}$ is equal to $1$ if and only if the sequence of edges $(i, q)$, $(q, p)$, and $(p, i)$ all exist in the graph, forming a closed walk of length $3$: $i \\to q \\to p \\to i$. Otherwise, the term is $0$. Therefore, $\\mathrm{tr}(A^3)$ counts the total number of closed walks of length $3$ in the graph.\n\nLet's analyze the types of closed walks of length $3$:\nA walk $i \\to q \\to p \\to i$ can have repeated nodes.\n1. All nodes are the same: $i=p=q$. The walk is $i \\to i \\to i \\to i$. Its existence requires $A_{ii}=1$. However, the problem states the graph has no self-loops, which is confirmed by the given matrix $A$ having all its diagonal elements equal to $0$. Thus, this type of walk does not exist in our network.\n2. Two nodes are the same (e.g., $i=p$, $p \\neq q$). The walk is $i \\to q \\to i \\to i$. This would require an edge from $i$ to $i$, so $A_{ii}=1$, which is not the case. The same logic applies if $i=q$ or $p=q$ (e.g., $i \\to p \\to p \\to i$ requires $A_{pp}=1$).\n3. All three nodes $i, p, q$ are distinct. The walk $i \\to q \\to p \\to i$ is a directed cycle of length $3$, also known as a $3$-cycle.\n\nSince walks with repeated nodes are ruled out by the absence of self-loops, the quantity $\\mathrm{tr}(A^3)$ counts only the closed walks of length $3$ where all three nodes are distinct. Each such walk corresponds to a unique directed $3$-cycle. A specific $3$-cycle, say involving nodes $\\{v_1, v_2, v_3\\}$ with edges $(v_1, v_2)$, $(v_2, v_3)$, and $(v_3, v_1)$, will be counted three times in the sum for $\\mathrm{tr}(A^3)$:\n- Once as the closed walk $v_1 \\to v_2 \\to v_3 \\to v_1$ (when $i=v_1$).\n- Once as the closed walk $v_2 \\to v_3 \\to v_1 \\to v_2$ (when $i=v_2$).\n- Once as the closed walk $v_3 \\to v_1 \\to v_2 \\to v_3$ (when $i=v_3$).\n\nTherefore, $\\mathrm{tr}(A^3)$ is equal to $3$ times the number of directed $3$-cycles in the graph. If we denote the number of $3$-cycles by $N_3$, we have $\\mathrm{tr}(A^3) = 3 N_3$. This demonstrates how the quantity reveals the presence and abundance of these structures.\n\nIn systems biomedicine, directed cycles are fundamental network motifs known as feedback loops. A $3$-cycle represents a three-component feedback loop (e.g., TF $1$ regulates TF $2$, TF $2$ regulates TF $3$, and TF $3$ in turn regulates TF $1$). Such motifs are of profound biological significance as they are key building blocks for complex dynamic behaviors. For instance, negative feedback loops (those with an odd number of repressive interactions) are critical for promoting stability and homeostasis. Positive feedback loops (with an even number of repressive interactions) can generate bistability, allowing a cell to switch between distinct functional states, a process central to cell differentiation. The interplay of positive and negative feedback can create oscillations, which underpin biological rhythms like the cell cycle and circadian clocks. Thus, identifying and quantifying $3$-cycles is a crucial step in dissecting the functional logic of a gene regulatory network.\n\nNow, we evaluate $\\mathrm{tr}(A^3)$ for the given adjacency matrix $A$:\n$$ A = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} $$\nFirst, we compute $A^2 = A \\times A$:\n$$ A^2 = \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} \\begin{pmatrix} 0  1  0  0  1  0 \\\\ 0  0  1  1  0  1 \\\\ 1  0  0  1  0  0 \\\\ 0  1  0  0  1  0 \\\\ 0  0  1  0  0  1 \\\\ 1  0  0  1  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  2  1  0  2 \\\\ 2  1  0  2  1  0 \\\\ 0  2  0  0  2  0 \\\\ 0  0  2  1  0  2 \\\\ 2  0  0  2  0  0 \\\\ 0  2  0  0  2  0 \\end{pmatrix} $$\nNext, we compute $A^3 = A^2 \\times A$. We only need the diagonal elements for the trace. The $i$-th diagonal element of $A^3$, $(A^3)_{ii}$, is the dot product of the $i$-th row of $A^2$ and the $i$-th column of $A$.\n$(A^3)_{11} = (0)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 4$\n$(A^3)_{22} = (2)(1) + (1)(0) + (0)(0) + (2)(1) + (1)(0) + (0)(0) = 4$\n$(A^3)_{33} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 4$\n$(A^3)_{44} = (0)(0) + (0)(1) + (2)(1) + (1)(0) + (0)(0) + (2)(1) = 4$\n$(A^3)_{55} = (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) + (0)(0) = 4$\n$(A^3)_{66} = (0)(0) + (2)(1) + (0)(0) + (0)(0) + (2)(1) + (0)(0) = 4$\n\nThe diagonal elements of $A^3$ are all equal to $4$. The trace is the sum of these elements:\n$$ \\mathrm{tr}(A^3) = \\sum_{i=1}^{6} (A^3)_{ii} = 4 + 4 + 4 + 4 + 4 + 4 = 6 \\times 4 = 24 $$\nThe value of $\\mathrm{tr}(A^3)$ is $24$. This indicates that there are $N_3 = \\frac{24}{3} = 8$ distinct directed $3$-cycles in this gene regulatory network.", "answer": "$$\\boxed{24}$$", "id": "4349908"}, {"introduction": "In vast biological networks, identifying the most influential genes or proteins is a central challenge. This practice guides you through implementing the renowned PageRank algorithm from first principles to quantify node importance based on network topology. By translating the theory of a random walk with teleportation into functional code, you will develop practical computational skills and learn to rigorously handle common issues like dangling nodes in real-world network models [@problem_id:4349876].", "problem": "Implement a program that computes the Personalized PageRank on small directed transcriptional networks, with rigorous handling of dangling nodes. The goal is to derive and implement the algorithm from first principles of Markov chains and graph stochasticity, not by quoting a pre-existing formula without justification. Concretely, consider a directed graph representing a transcriptional regulatory network, where nodes are genes or transcription factors, and directed edges represent regulation. Let the damping factor be denoted by $\\alpha \\in (0,1)$, and let the personalization vector be denoted by $v \\in \\mathbb{R}^n$ with $v \\ge 0$ and $\\sum_{i=1}^n v_i = 1$. The PageRank vector $p \\in \\mathbb{R}^n$ is defined as the stationary distribution of a random walk with teleportation on this graph.\n\nFundamental base to use:\n- Use the definition of a discrete-time Markov chain with a column-stochastic transition matrix, and the notion that a stationary distribution $p$ satisfies $p = M p$ for a suitable column-stochastic matrix $M$, together with $\\sum_{i=1}^n p_i = 1$ and $p \\ge 0$.\n- Use the well-tested observation that, in the PageRank random walk, with probability $\\alpha$ the walker follows an outgoing edge uniformly at random, and with probability $(1-\\alpha)$ the walker teleports to a node sampled from the personalization vector $v$.\n- Use the fact that a dangling node (a node with zero out-degree) yields a column with zero sum in the raw transition matrix, and must be handled by redistributing its probability mass according to $v$ so that the effective transition is still column-stochastic.\n\nYour program must implement the following from these principles:\n- Construct a column-stochastic transition model from the directed graph, where for each node with at least one outgoing edge, the probability to go to any of its out-neighbors is equal and sums to $1$. For any node with zero out-degree (a dangling node), ensure that its probability mass is redistributed according to $v$.\n- Compute the unique PageRank vector $p$ for given $\\alpha$ and $v$ by power iteration until convergence in the $\\ell_1$ norm, with a tolerance $\\varepsilon = 10^{-12}$ and a hard cap of $10000$ iterations. Initialize the iteration with $p^{(0)} = v$.\n- Return the resulting $p$ rounded to six decimal places for each entry.\n\nGraph representation:\n- Let nodes be indexed from $0$ to $n-1$. The directed edge notation $j \\to i$ means \"from node $j$ to node $i$\", which corresponds to an entry in a column-stochastic adjacency where column $j$ contains the outgoing probabilities from node $j$.\n- A transcriptional network with nodes $\\{A,B,C,D,E\\}$ is mapped to indices $A \\mapsto 0$, $B \\mapsto 1$, $C \\mapsto 2$, $D \\mapsto 3$, $E \\mapsto 4$.\n\nTest suite:\n- Test case $1$: Graph $G_1$ with nodes $\\{0,1,2,3,4\\}$ and edges $0 \\to 1$, $0 \\to 2$, $1 \\to 2$, $1 \\to 3$, $2 \\to 1$, $3 \\to 2$, $3 \\to 4$, and node $4$ is dangling (no outgoing edges). Use $\\alpha = 0.85$ and a uniform personalization vector $v = \\left[\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5},\\frac{1}{5}\\right]$.\n- Test case $2$: Same graph $G_1$ as in test case $1$, with $\\alpha = 0.95$ and the same uniform $v$.\n- Test case $3$: Same graph $G_1$ as in test case $1$, with $\\alpha = 0.85$ and a non-uniform personalization vector $v = [0.05, 0.05, 0.8, 0.05, 0.05]$.\n- Test case $4$: Graph $G_2$ with nodes $\\{0,1,2\\}$ and no edges at all, so all nodes are dangling. Use $\\alpha = 0.85$ and the uniform $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$.\n- Test case $5$: Graph $G_3$ with nodes $\\{0,1,2\\}$ and a single edge $0 \\to 1$, with nodes $1$ and $2$ dangling. Use $\\alpha = 0.85$ and the uniform $v = \\left[\\frac{1}{3},\\frac{1}{3},\\frac{1}{3}\\right]$.\n\nConvergence and numeric specifications:\n- Use $\\varepsilon = 10^{-12}$ for the $\\ell_1$ convergence criterion.\n- Use a maximum of $10000$ iterations.\n- Round each entry of the final PageRank vector to six decimal places before output.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the test cases in order as a comma-separated list of lists, with no spaces. For example, the output format must be exactly\n\"[[p11,p12,...,p1n],[p21,p22,...],[...],...]\"\nwhere $p_{kj}$ are floats rounded to six decimal places for test case $k$.", "solution": "The problem of computing the Personalized PageRank vector is a problem of finding the stationary distribution of a specific discrete-time Markov chain. The solution will be derived from first principles, starting with the construction of the transition matrix for the random walk and culminating in the power iteration algorithm.\n\n### 1. The Underlying Markov Chain\n\nA random walk on a directed graph $G = (V, E)$ with $n = |V|$ nodes can be modeled as a Markov chain. The state of the system at step $k$ is a probability distribution vector $p^{(k)} \\in \\mathbb{R}^n$, where $p_i^{(k)}$ is the probability of a random walker being at node $i$. The state evolves according to $p^{(k+1)} = M p^{(k)}$, where $M$ is a column-stochastic transition matrix. The entry $M_{ij}$ represents the probability of transitioning from node $j$ to node $i$. A stationary distribution $p$ satisfies $p = M p$, along with the constraints $p \\ge 0$ and $\\sum_{i=1}^n p_i = 1$.\n\n### 2. Constructing the PageRank Transition Model\n\nThe PageRank random walker's movement is a weighted combination of two actions:\n1.  With probability $\\alpha$, the walker follows a randomly chosen outgoing edge from its current node.\n2.  With probability $1-\\alpha$, the walker \"teleports\" to a node chosen randomly according to the personalization vector $v$.\n\nWe must construct a column-stochastic matrix $M$ that captures this behavior.\n\n#### 2.1. Handling the Graph-Based Walk (The `S` Matrix)\n\nLet's first model a walk that purely follows the graph structure.\n- For a non-dangling node $j$ (a node with out-degree $d_j  0$), a walker at $j$ moves to any of its neighbors $i$ with uniform probability $1/d_j$.\n- For a dangling node $j$ (a node with out-degree $d_j = 0$), the walker is trapped. The problem specifies that this probability mass must be redistributed according to the personalization vector $v$. This is equivalent to a forced teleport: from a dangling node $j$, the walker jumps to any node $i$ with probability $v_i$.\n\nLet's build a matrix $S$ that represents this graph-based walk, including the dangling node correction.\n- Let $A$ be a matrix representing the transitions for non-dangling nodes.\n$$\nA_{ij} = \\begin{cases} 1/d_j  \\text{if } j \\to i \\text{ is an edge and } d_j  0 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\nThe columns of $A$ corresponding to non-dangling nodes sum to $1$, while columns for dangling nodes are all zero.\n- To handle dangling nodes, we add a correction term. Let $d \\in \\{0,1\\}^n$ be an indicator vector where $d_j=1$ if node $j$ is dangling, and $d_j=0$ otherwise. The transition from a dangling node $j$ is a jump to a node $i$ with probability $v_i$. This can be represented by the outer product $v d^T$.\n- The complete stochastic transition matrix for the graph walk, $S$, is the sum of these two parts:\n$$\nS = A + v d^T\n$$\nLet's verify that $S$ is column-stochastic. The sum of column $j$ is $\\sum_i S_{ij}$.\n- If $j$ is not dangling ($d_j=0$): $\\sum_i S_{ij} = \\sum_i A_{ij} = \\sum_{i \\in \\text{neighbors}(j)} 1/d_j = d_j \\cdot (1/d_j) = 1$.\n- If $j$ is dangling ($d_j=1$): $\\sum_i S_{ij} = \\sum_i (A_{ij} + v_i d_j) = \\sum_i (0 + v_i) = \\sum_i v_i = 1$.\nThus, $S$ is a valid column-stochastic matrix.\n\n#### 2.2. Incorporating Teleportation (The `M` Matrix)\n\nThe full PageRank transition at each step is a combination of the graph walk (governed by $S$) and global teleportation (governed by $v$).\nThe probability of transitioning from any node $j$ to a target node $i$ is:\n$$\nP(j \\to i) = \\alpha \\cdot (\\text{Prob. via graph walk}) + (1-\\alpha) \\cdot (\\text{Prob. via teleportation})\n$$\nThe probability of transitioning from $j$ to $i$ via the graph walk is given by $S_{ij}$. The probability of teleporting to node $i$ is $v_i$, and this is independent of the starting node $j$.\nTherefore, the entry $M_{ij}$ of the final Google matrix $M$ is:\n$$\nM_{ij} = \\alpha S_{ij} + (1-\\alpha)v_i\n$$\nIn matrix notation, this is $M = \\alpha S + (1-\\alpha) v \\mathbf{1}^T$, where $\\mathbf{1}^T$ is a row vector of all ones. This matrix $M$ is column-stochastic, and its unique principal eigenvector (for eigenvalue $1$) is the PageRank vector $p$.\n\n### 3. The Power Iteration Algorithm\n\nThe PageRank vector $p$ is the stationary distribution satisfying $p = M p$. This can be found by the power iteration method: starting with an initial guess $p^{(0)}$, we repeatedly apply the transition matrix: $p^{(k+1)} = M p^{(k)}$. The sequence $p^{(k)}$ converges to $p$.\n\nLet's derive the iterative update rule:\n$$\np^{(k+1)} = M p^{(k)} = (\\alpha S + (1-\\alpha) v \\mathbf{1}^T) p^{(k)}\n$$\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v (\\mathbf{1}^T p^{(k)})\n$$\nSince $p^{(k)}$ is a probability distribution, $\\sum_j p_j^{(k)} = 1$, which means $\\mathbf{1}^T p^{(k)} = 1$.\n$$\np^{(k+1)} = \\alpha S p^{(k)} + (1-\\alpha) v\n$$\nThis gives us a more direct iterative update. For computational efficiency, we can further expand $S$:\n$$\np^{(k+1)} = \\alpha (A + v d^T) p^{(k)} + (1-\\alpha) v\n$$\n$$\np^{(k+1)} = \\alpha A p^{(k)} + \\alpha v (d^T p^{(k)}) + (1-\\alpha) v\n$$\nLet $m_d^{(k)} = d^T p^{(k)} = \\sum_{j \\text{ is dangling}} p_j^{(k)}$ be the total probability mass residing on dangling nodes at step $k$. The equation becomes:\n$$\np^{(k+1)} = \\alpha (A p^{(k)}) + (\\alpha m_d^{(k)} + 1 - \\alpha) v\n$$\nThis is the final, computationally efficient update rule for the power iteration.\n\n**Algorithm:**\n1.  **Initialization**: Set the initial PageRank vector $p^{(0)} = v$, and iteration counter $k=0$.\n2.  **Preprocessing**: From the graph edges, determine the out-degrees $d_j$ and identify the set of dangling nodes $D = \\{j \\mid d_j=0\\}$. Construct the non-dangling transition matrix $A$, or an equivalent representation.\n3.  **Iteration**: Repeat for $k=0, 1, 2, \\dots$ up to a maximum of $10000$ iterations:\n    a.  Store the current vector: $p_{\\text{old}} = p^{(k)}$.\n    b.  Calculate the dangling mass: $m_d = \\sum_{j \\in D} p_j^{\\text{old}}$.\n    c.  Calculate the walk contribution: $p'_{\\text{walk}} = A p_{\\text{old}}$. This is done by summing, for each node $i$, the incoming probability flows: $(p'_{\\text{walk}})_i = \\sum_{j \\to i, j \\notin D} p_j^{\\text{old}} / d_j$.\n    d.  Calculate the new PageRank vector: $p^{(k+1)} = \\alpha p'_{\\text{walk}} + (\\alpha m_d + 1 - \\alpha) v$.\n    e.  **Check for Convergence**: Compute the $\\ell_1$ norm of the difference: $\\Delta = ||p^{(k+1)} - p_{\\text{old}}||_1 = \\sum_i |p_i^{(k+1)} - p_i^{\\text{old}}|$. If $\\Delta  \\varepsilon = 10^{-12}$, terminate the iteration.\n4.  **Result**: The final vector $p^{(k+1)}$ is the computed PageRank vector. Round its entries to six decimal places.", "answer": "```python\nimport numpy as np\n\ndef compute_pagerank(edges, n, alpha, v, epsilon, max_iter):\n    \"\"\"\n    Computes the Personalized PageRank vector from first principles.\n\n    Args:\n        edges (list): A list of tuples (from_node, to_node) representing directed edges.\n        n (int): The total number of nodes in the graph.\n        alpha (float): The damping factor.\n        v (np.ndarray):The personalization vector.\n        epsilon (float): The convergence tolerance for the L1 norm.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        np.ndarray: The computed PageRank vector.\n    \"\"\"\n    # 1. Build adjacency list and find out-degrees.\n    adj = [[] for _ in range(n)]\n    out_degrees = np.zeros(n, dtype=int)\n    for j, i in edges:\n        # j - i means from node j to node i\n        adj[j].append(i)\n        out_degrees[j] += 1\n\n    # 2. Identify dangling nodes.\n    dangling_nodes_mask = (out_degrees == 0)\n\n    # 3. Construct the 'A' matrix for transitions from non-dangling nodes.\n    # For small graphs, a dense matrix is acceptable.\n    A = np.zeros((n, n))\n    non_dangling_indices = np.where(out_degrees  0)[0]\n    for j in non_dangling_indices:\n        for i in adj[j]:\n            A[i, j] = 1.0 / out_degrees[j]\n\n    # 4. Power Iteration.\n    p = v.copy()  # Initialize p^(0) = v\n\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # Calculate the total probability mass on dangling nodes.\n        dangling_mass = np.sum(p_old[dangling_nodes_mask])\n\n        # Calculate the contribution from the random walk on non-dangling nodes.\n        # This is the A*p_old part of the update rule.\n        p_walk_contribution = np.dot(A, p_old)\n\n        # The teleportation component combines the mass from dangling nodes\n        # and the (1-alpha) global teleportation probability.\n        teleport_factor = alpha * dangling_mass + (1.0 - alpha)\n        teleport_contribution = teleport_factor * v\n\n        # Combine walk and teleportation to get the new PageRank vector.\n        p = alpha * p_walk_contribution + teleport_contribution\n\n        # Check for convergence using the L1 norm.\n        l1_norm_diff = np.linalg.norm(p - p_old, ord=1)\n        if l1_norm_diff  epsilon:\n            break\n            \n    return p\n\ndef solve():\n    \"\"\"\n    Sets up and runs the test cases for the Personalized PageRank computation.\n    \"\"\"\n    # Test case definitions\n    # Graph 1\n    n1 = 5\n    edges1 = [(0, 1), (0, 2), (1, 2), (1, 3), (2, 1), (3, 2), (3, 4)]\n    v1_uniform = np.full(n1, 1.0 / n1)\n    v1_nonuniform = np.array([0.05, 0.05, 0.8, 0.05, 0.05])\n\n    # Graph 2\n    n2 = 3\n    edges2 = []\n    v2_uniform = np.full(n2, 1.0 / n2)\n\n    # Graph 3\n    n3 = 3\n    edges3 = [(0, 1)]\n    v3_uniform = np.full(n3, 1.0 / n3)\n\n    test_cases = [\n        # (graph_edges, num_nodes, alpha, personalization_vector)\n        (edges1, n1, 0.85, v1_uniform),\n        (edges1, n1, 0.95, v1_uniform),\n        (edges1, n1, 0.85, v1_nonuniform),\n        (edges2, n2, 0.85, v2_uniform),\n        (edges3, n3, 0.85, v3_uniform),\n    ]\n\n    epsilon = 1e-12\n    max_iter = 10000\n    results = []\n\n    for edges, n, alpha, v in test_cases:\n        p_vector = compute_pagerank(edges, n, alpha, v, epsilon, max_iter)\n        # Round each element to 6 decimal places as required.\n        rounded_p = [round(val, 6) for val in p_vector]\n        results.append(rounded_p)\n\n    # Format the final output string to be a comma-separated list of lists\n    # with no spaces, e.g., \"[[p1,p2],[q1,q2]]\".\n    final_output = str(results).replace(\" \", \"\")\n    print(final_output)\n\nsolve()\n```", "id": "4349876"}, {"introduction": "Identifying functional modules or 'communities' is a key goal in network biology, and modularity is a widely used metric for this purpose. However, no method is perfect, and this exercise challenges you to investigate the well-known 'resolution limit' of modularity, where the algorithm can fail to resolve small, well-defined communities. By analytically deriving the breakdown point for a specific network model, you will learn to think critically about the tools of network science and understand the importance of their theoretical underpinnings [@problem_id:4349895].", "problem": "In systems biomedicine, functional modules such as protein complexes, regulatory subcircuits, or metabolite-processing units are often represented as dense subgraphs (communities) weakly connected to each other. Consider an undirected, unweighted graph modeling a cyclic pathway of such modules as a ring of cliques. There are $N$ cliques arranged on a cycle, with $N$ an even integer, and each clique contains $n$ vertices with all possible intra-clique edges present. Between each pair of consecutive cliques on the ring there is exactly one inter-clique edge, so the ring has exactly $N$ inter-clique edges. Assume each inter-clique edge connects a single vertex in one clique to a single vertex in its neighbor, and that every clique has exactly two inter-clique edges incident to its vertices (one to each neighbor). Let $m$ denote the total number of edges in the graph, and let $Q$ denote the Newman–Girvan modularity (NGM), defined for an undirected graph with adjacency matrix $A$ and vertex degrees $k_i$ as\n$$\nQ \\;=\\; \\frac{1}{2m}\\sum_{i,j}\\left(A_{ij}-\\frac{k_i k_j}{2m}\\right)\\delta(c_i,c_j),\n$$\nwhere $\\delta(c_i,c_j)=1$ if vertices $i$ and $j$ are assigned to the same community and $\\delta(c_i,c_j)=0$ otherwise.\n\nStarting only from this definition and the structural description above, perform the following:\n\n1. Derive the total number of edges $m$ in terms of $N$ and $n$.\n2. Using the community-aggregated form of modularity implied by the definition, compute the modularity $Q_{\\text{single}}$ of the partition in which each clique is a separate community.\n3. Compute the modularity $Q_{\\text{pair}}$ of the partition in which each community consists of two adjacent cliques merged together (so there are $N/2$ communities).\n4. Derive the exact condition on $N$ and $n$ under which merging adjacent cliques increases modularity, that is, when $\\Delta Q = Q_{\\text{pair}} - Q_{\\text{single}}  0$.\n5. Solve this condition for the critical clique size $n_{\\text{crit}}(N)$ at which $\\Delta Q = 0$ as a closed-form expression in $N$. Provide this expression as your final answer.\n\nExpress the final answer as a single simplified symbolic expression. No rounding is required, and no physical units apply.", "solution": "The graph consists of $N$ cliques of size $n$, each fully connected internally and connected to the next by a single edge, forming a cycle. The number of internal edges in one clique of size $n$ is\n$$\nl_c \\;=\\; \\binom{n}{2} \\;=\\; \\frac{n(n-1)}{2}.\n$$\nBecause the ring has $N$ inter-clique edges (one between each consecutive pair), the total number of edges in the graph is\n$$\nm \\;=\\; N\\,l_c \\;+\\; N \\;=\\; N\\left(l_c+1\\right) \\;=\\; N\\left(\\frac{n(n-1)}{2}+1\\right).\n$$\n\nWe now use the community-aggregated form of Newman–Girvan modularity, which follows directly from the definition:\n$$\nQ \\;=\\; \\sum_{C}\\left(\\frac{l_C}{m} \\;-\\; \\left(\\frac{d_C}{2m}\\right)^2\\right),\n$$\nwhere $l_C$ is the number of internal edges in community $C$ and $d_C$ is the sum of degrees of the vertices in community $C$ (each degree counted with respect to the full graph).\n\nFor a single clique community:\n- Internal edges: $l_c=\\frac{n(n-1)}{2}$.\n- Each clique has exactly two inter-clique edges incident to its vertices (one to each neighbor), so the sum of degrees in the clique is the sum of degrees contributed by internal edges plus the two external edge stubs. The sum of degrees in the clique is\n$$\nd_c \\;=\\; 2\\,l_c \\;+\\; 2 \\;=\\; 2\\left(\\frac{n(n-1)}{2}\\right) + 2 \\;=\\; n(n-1) + 2 \\;=\\; 2\\left(l_c+1\\right).\n$$\nTherefore, the modularity of the partition with $N$ single-clique communities is\n$$\nQ_{\\text{single}} \\;=\\; \\sum_{s=1}^{N}\\left(\\frac{l_c}{m} - \\left(\\frac{d_c}{2m}\\right)^2\\right)\n\\;=\\;\nN\\left(\\frac{l_c}{m} - \\frac{d_c^2}{4m^2}\\right).\n$$\n\nFor a merged community consisting of two adjacent cliques:\n- Internal edges become $l_2 = 2\\,l_c + 1$ because the inter-clique edge between the pair becomes internal.\n- The sum of degrees of all vertices in the merged community equals the sum over both cliques, and degrees are measured with respect to the full graph, so\n$$\nd_2 \\;=\\; 2\\,d_c \\;=\\; 4\\left(l_c+1\\right).\n$$\nIn the partition of $N/2$ merged communities, the modularity is\n$$\nQ_{\\text{pair}} \\;=\\; \\sum_{p=1}^{N/2}\\left(\\frac{l_2}{m} - \\left(\\frac{d_2}{2m}\\right)^2\\right)\n\\;=\\;\n\\frac{N}{2}\\left(\\frac{l_2}{m} - \\frac{d_2^2}{4m^2}\\right).\n$$\n\nWe compare the two partitions via the difference\n$$\n\\Delta Q \\;=\\; Q_{\\text{pair}} - Q_{\\text{single}}\n\\;=\\;\n\\frac{N}{2}\\left(\\frac{l_2}{m} - \\frac{d_2^2}{4m^2}\\right)\n\\;-\\;\nN\\left(\\frac{l_c}{m} - \\frac{d_c^2}{4m^2}\\right).\n$$\nSubstituting $l_2 = 2l_c + 1$, $d_c = 2(l_c+1)$, and $d_2 = 4(l_c+1)$:\n\n$$\n\\Delta Q \\;=\\; \\frac{N}{2}\\left(\\frac{2l_c+1}{m} - \\frac{16(l_c+1)^2}{4m^2}\\right) - N\\left(\\frac{l_c}{m} - \\frac{4(l_c+1)^2}{4m^2}\\right).\n$$\n\nSimplifying the squares and factors:\n\n$$\n\\Delta Q \\;=\\; \\frac{N}{2}\\left(\\frac{2l_c+1}{m} - \\frac{4(l_c+1)^2}{m^2}\\right) - N\\left(\\frac{l_c}{m} - \\frac{(l_c+1)^2}{m^2}\\right).\n$$\n\nSeparate the terms linear in $1/m$ and $1/m^2$:\n\n$$\n\\Delta Q \\;=\\; N\\left(\\frac{1}{2m}\\right) \\;+\\; N\\left(-\\frac{2(l_c+1)^2}{m^2}\\right) \\;-\\; N\\left(\\frac{l_c}{m}\\right) \\;+\\; N\\left(\\frac{(l_c+1)^2}{m^2}\\right).\n$$\n\nCombine like terms:\n\n$$\n\\Delta Q \\;=\\; N\\left(\\frac{1}{2m} - \\frac{(l_c+1)^2}{m^2}\\right).\n$$\n\nHence merging increases modularity if and only if\n$$\n\\Delta Q > 0 \\quad\\Longleftrightarrow\\quad \\frac{1}{2m} > \\frac{(l_c+1)^2}{m^2} \\quad\\Longleftrightarrow\\quad m > 2\\,(l_c+1)^2.\n$$\nUsing $m = N(l_c+1)$ derived earlier, with $l_c+1>0$, we obtain the equivalent condition\n$$\nN(l_c+1) > 2(l_c+1)^2 \\quad\\Longleftrightarrow\\quad N > 2(l_c+1).\n$$\nExpressed in terms of $n$,\n$$\nl_c + 1 \\;=\\; \\frac{n(n-1)}{2} + 1,\n$$\nso the boundary $\\Delta Q=0$ occurs at\n$$\nN \\;=\\; 2\\left(\\frac{n(n-1)}{2} + 1\\right) \\;=\\; n(n-1) + 2.\n$$\nSolving for the critical clique size $n_{\\text{crit}}(N)$, we write\n$$\nn^2 - n - (N - 2) \\;=\\; 0,\n$$\nwhose positive root gives\n$$\nn_{\\text{crit}}(N) \\;=\\; \\frac{1 + \\sqrt{1 + 4(N-2)}}{2} \\;=\\; \\frac{1 + \\sqrt{4N - 7}}{2}.\n$$\nFor $n  n_{\\text{crit}}(N)$, the inequality $N  2(l_c+1)$ holds and merging adjacent cliques increases modularity; for $n  n_{\\text{crit}}(N)$, individual cliques remain favored as separate communities. The requested final answer is the closed-form expression for $n_{\\text{crit}}(N)$.", "answer": "$$\\boxed{\\frac{1+\\sqrt{4N-7}}{2}}$$", "id": "4349895"}]}