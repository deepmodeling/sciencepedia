{"hands_on_practices": [{"introduction": "This problem is a foundational exercise in calculating core network metrics. You will compute the eccentricity for each node and the overall network diameter, which represents the \"longest shortest path\" within the system. By performing this analysis for both an unweighted model (where every interaction is equal) and a weighted model (where interactions have different latencies), you will gain direct, hands-on insight into how quantitative information about interactions can fundamentally alter our understanding of a network's topology and which nodes are most peripheral [@problem_id:4372739].", "problem": "In a signaling module of a mammalian cell, consider a directed network of six proteins $v_1,\\ldots,v_6$. An effective latency weight $w_{ij} \\in \\{0,1,2,3,4\\}$ is assigned to each directed interaction $v_i \\to v_j$, where $w_{ij} = 0$ denotes absence of a direct interaction. The weighted adjacency matrix $\\mathbf{W} = (w_{ij})$ is\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}.\n$$\nAssume all edge latencies are strictly positive whenever present, and the network is strongly connected as a directed graph. Define the unweighted model by the binary adjacency $\\mathbf{A} = (a_{ij})$ with $a_{ij} = 1$ if $w_{ij}  0$ and $a_{ij} = 0$ otherwise. In the weighted model, the shortest-path distance from $v_i$ to $v_j$ is the minimal total latency among all directed paths from $v_i$ to $v_j$. In the unweighted model, each present edge has length $1$, and shortest-path distance is the minimal number of edges along a directed path.\n\nFor both models (weighted and unweighted), compute the eccentricity $\\epsilon(v)$ for each node $v \\in \\{v_1,\\ldots,v_6\\}$, defined as the maximum shortest-path distance from $v$ to any other node in the network. Then compute the network diameter $D$, defined as the maximum of the eccentricities over all nodes. Identify which nodes are peripheral in each model, where a node is peripheral if its eccentricity equals the diameter.\n\nExpress your final answer as a single row matrix that concatenates the following in order:\n- $\\epsilon_{\\mathrm{unw}}(v_1),\\ldots,\\epsilon_{\\mathrm{unw}}(v_6)$,\n- $\\epsilon_{\\mathrm{w}}(v_1),\\ldots,\\epsilon_{\\mathrm{w}}(v_6)$,\n- $D_{\\mathrm{unw}}, D_{\\mathrm{w}}$,\n- the peripheral-indicator vector for the unweighted model $\\in \\{0,1\\}^6$ in node order $v_1,\\ldots,v_6$ (with $1$ indicating peripheral),\n- the peripheral-indicator vector for the weighted model $\\in \\{0,1\\}^6$ in node order $v_1,\\ldots,v_6$.\n\nProvide exact integer values; do not round. No units are required.", "solution": "The user wants to analyze a given directed network of six proteins under two different models: an unweighted model and a weighted model. The goal is to compute node eccentricities, the network diameter, and identify peripheral nodes for each model.\n\n**Problem Setup**\nThe network consists of $N=6$ nodes, $\\{v_1, v_2, v_3, v_4, v_5, v_6\\}$. The interactions are defined by a weighted adjacency matrix $\\mathbf{W} = (w_{ij})$:\n$$\n\\mathbf{W} =\n\\begin{pmatrix}\n0  1  0  3  0  0 \\\\\n0  0  1  0  2  0 \\\\\n0  0  0  1  0  2 \\\\\n4  0  0  0  1  0 \\\\\n0  4  0  0  0  1 \\\\\n1  0  4  0  0  0\n\\end{pmatrix}\n$$\nIn this matrix, $w_{ij}$ represents the latency (weight) of the directed edge from $v_i$ to $v_j$. A weight of $0$ signifies the absence of an edge.\n\nThe problem requires a two-part analysis based on two models derived from $\\mathbf{W}$.\n\n**Part 1: Unweighted Model Analysis**\n\nIn the unweighted model, every existing edge is assigned a length of $1$. The connectivity is described by the binary adjacency matrix $\\mathbf{A} = (a_{ij})$, where $a_{ij} = 1$ if $w_{ij}  0$ and $a_{ij} = 0$ otherwise.\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\n0  1  0  1  0  0 \\\\\n0  0  1  0  1  0 \\\\\n0  0  0  1  0  1 \\\\\n1  0  0  0  1  0 \\\\\n0  1  0  0  0  1 \\\\\n1  0  1  0  0  0\n\\end{pmatrix}\n$$\nThe shortest-path distance $d_{\\mathrm{unw}}(v_i, v_j)$ is the minimum number of edges in a directed path from $v_i$ to $v_j$. To find the eccentricities, we must first compute the all-pairs shortest paths matrix, $\\mathbf{D}_{\\mathrm{unw}}$. Since the graph is unweighted, we can run a Breadth-First Search (BFS) starting from each node.\n\n- **From $v_1$**: Distances are $(d(v_1,v_1), \\dots, d(v_1,v_6)) = (0, 1, 2, 1, 2, 3)$.\n- **From $v_2$**: Distances are $(3, 0, 1, 2, 1, 2)$.\n- **From $v_3$**: Distances are $(2, 3, 0, 1, 2, 1)$.\n- **From $v_4$**: Distances are $(1, 2, 3, 0, 1, 2)$.\n- **From $v_5$**: Distances are $(2, 1, 2, 3, 0, 1)$.\n- **From $v_6$**: Distances are $(1, 2, 1, 2, 3, 0)$.\n\nThe all-pairs shortest path matrix for the unweighted model is:\n$$\n\\mathbf{D}_{\\mathrm{unw}} =\n\\begin{pmatrix}\n0  1  2  1  2  3 \\\\\n3  0  1  2  1  2 \\\\\n2  3  0  1  2  1 \\\\\n1  2  3  0  1  2 \\\\\n2  1  2  3  0  1 \\\\\n1  2  1  2  3  0\n\\end{pmatrix}\n$$\nThe eccentricity of a node $v$, $\\epsilon(v)$, is the maximum shortest-path distance from $v$ to any other node in the network. It corresponds to the maximum value in the row for $v$ in the distance matrix.\n\n- $\\epsilon_{\\mathrm{unw}}(v_1) = \\max(0, 1, 2, 1, 2, 3) = 3$.\n- $\\epsilon_{\\mathrm{unw}}(v_2) = \\max(3, 0, 1, 2, 1, 2) = 3$.\n- $\\epsilon_{\\mathrm{unw}}(v_3) = \\max(2, 3, 0, 1, 2, 1) = 3$.\n- $\\epsilon_{\\mathrm{unw}}(v_4) = \\max(1, 2, 3, 0, 1, 2) = 3$.\n- $\\epsilon_{\\mathrm{unw}}(v_5) = \\max(2, 1, 2, 3, 0, 1) = 3$.\n- $\\epsilon_{\\mathrm{unw}}(v_6) = \\max(1, 2, 1, 2, 3, 0) = 3$.\n\nThe vector of unweighted eccentricities is $(\\epsilon_{\\mathrm{unw}}(v_1), \\dots, \\epsilon_{\\mathrm{unw}}(v_6)) = (3, 3, 3, 3, 3, 3)$.\n\nThe network diameter, $D_{\\mathrm{unw}}$, is the maximum eccentricity over all nodes.\n$$D_{\\mathrm{unw}} = \\max_{i} \\{\\epsilon_{\\mathrm{unw}}(v_i)\\} = 3$$\nA node is peripheral if its eccentricity equals the diameter. Since all nodes have an eccentricity of $3$, which equals the diameter, all nodes are peripheral. The peripheral-indicator vector is $(1, 1, 1, 1, 1, 1)$.\n\n**Part 2: Weighted Model Analysis**\n\nIn the weighted model, the length of an edge from $v_i$ to $v_j$ is given by the latency $w_{ij}$. The shortest-path distance $d_{\\mathrm{w}}(v_i, v_j)$ is the minimal sum of weights along a directed path from $v_i$ to $v_j$. We can compute the all-pairs shortest paths matrix, $\\mathbf{D}_{\\mathrm{w}}$, using the Floyd-Warshall algorithm or by running Dijkstra's algorithm from each node. The graph has no negative weight cycles (in fact, no negative weights), so these algorithms are applicable.\n\nLet $\\mathbf{D}_{\\mathrm{w}}^{(k)}$ be the matrix of shortest path distances using only intermediate vertices from $\\{v_1, \\dots, v_k\\}$. We initialize $\\mathbf{D}_{\\mathrm{w}}^{(0)}$ with the given weights for direct edges and $\\infty$ otherwise (with $0$ on the diagonal). After iteratively applying the Floyd-Warshall update rule, $D_{ij} = \\min(D_{ij}, D_{ik} + D_{kj})$, for $k=1, \\dots, 6$, we obtain the final distance matrix $\\mathbf{D}_{\\mathrm{w}} = \\mathbf{D}_{\\mathrm{w}}^{(6)}$.\n\nThe resulting all-pairs shortest path matrix for the weighted model is:\n$$\n\\mathbf{D}_{\\mathrm{w}} =\n\\begin{pmatrix}\n0  1  2  3  3  4 \\\\\n4  0  1  2  2  3 \\\\\n3  4  0  1  2  2 \\\\\n3  4  5  0  1  2 \\\\\n2  3  4  5  0  1 \\\\\n1  2  3  4  4  0\n\\end{pmatrix}\n$$\nNow, we compute the weighted eccentricities by taking the maximum value in each row of $\\mathbf{D}_{\\mathrm{w}}$.\n\n- $\\epsilon_{\\mathrm{w}}(v_1) = \\max(0, 1, 2, 3, 3, 4) = 4$.\n- $\\epsilon_{\\mathrm{w}}(v_2) = \\max(4, 0, 1, 2, 2, 3) = 4$.\n- $\\epsilon_{\\mathrm{w}}(v_3) = \\max(3, 4, 0, 1, 2, 2) = 4$.\n- $\\epsilon_{\\mathrm{w}}(v_4) = \\max(3, 4, 5, 0, 1, 2) = 5$.\n- $\\epsilon_{\\mathrm{w}}(v_5) = \\max(2, 3, 4, 5, 0, 1) = 5$.\n- $\\epsilon_{\\mathrm{w}}(v_6) = \\max(1, 2, 3, 4, 4, 0) = 4$.\n\nThe vector of weighted eccentricities is $(\\epsilon_{\\mathrm{w}}(v_1), \\dots, \\epsilon_{\\mathrm{w}}(v_6)) = (4, 4, 4, 5, 5, 4)$.\n\nThe weighted network diameter, $D_{\\mathrm{w}}$, is the maximum of these eccentricities.\n$$D_{\\mathrm{w}} = \\max_{i} \\{\\epsilon_{\\mathrm{w}}(v_i)\\} = 5$$\nA node is peripheral if its eccentricity equals the diameter ($5$). The nodes with eccentricity $5$ are $v_4$ and $v_5$. Therefore, the peripheral-indicator vector for the weighted model is $(0, 0, 0, 1, 1, 0)$.\n\n**Final Assembly of the Answer**\n\nThe problem asks for a single row matrix concatenating the following results in order:\n1.  Unweighted eccentricities: $(3, 3, 3, 3, 3, 3)$\n2.  Weighted eccentricities: $(4, 4, 4, 5, 5, 4)$\n3.  Diameters (unweighted, weighted): $(3, 5)$\n4.  Unweighted peripheral indicators: $(1, 1, 1, 1, 1, 1)$\n5.  Weighted peripheral indicators: $(0, 0, 0, 1, 1, 0)$\nThis results in a row vector of $6+6+2+6+6 = 26$ elements.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  3  3  3  3  3  4  4  4  5  5  4  3  5  1  1  1  1  1  1  0  0  0  1  1  0\n\\end{pmatrix}\n}\n$$", "id": "4372739"}, {"introduction": "Building on the fundamentals of network metrics, this practice challenges you to connect abstract graph theory concepts to tangible biological meaning. You will compare the unweighted diameter $D_s$, a measure of topological steps, with the weighted diameter $D_w$, which reflects functional costs like signal transduction time. By calculating both for a directed signaling network and articulating the rationale for preferring one, you will develop a deeper appreciation for how different models answer different biological questions, particularly in assessing the reach of a therapeutic intervention [@problem_id:4372644].", "problem": "In systems biomedicine, directed signaling networks model causal influence among molecular entities (for example, receptors, adaptors, kinases, and transcription factors). Consider the directed network with nodes $\\{R, A, B, C, D, E, F\\}$ in which each directed edge $u \\rightarrow v$ has a positive edge cost $c(u,v)$ that represents an effective signal-transduction cost (for example, an average transmission delay, in arbitrary units). The directed edges and their costs are:\n- $R \\rightarrow A$ with $c(R,A)=0.7$\n- $R \\rightarrow C$ with $c(R,C)=3.2$\n- $A \\rightarrow B$ with $c(A,B)=0.6$\n- $A \\rightarrow D$ with $c(A,D)=1.9$\n- $B \\rightarrow C$ with $c(B,C)=0.5$\n- $B \\rightarrow E$ with $c(B,E)=2.8$\n- $C \\rightarrow D$ with $c(C,D)=0.4$\n- $D \\rightarrow E$ with $c(D,E)=0.3$\n- $D \\rightarrow F$ with $c(D,F)=0.2$\n- $E \\rightarrow F$ with $c(E,F)=0.3$\n- $F \\rightarrow C$ with $c(F,C)=0.4$\n\nAdopt the following definitions, which are standard in graph theory and appropriate for directed signaling networks:\n- The unweighted directed shortest-path length $\\ell_{s}(u,v)$ is the minimal number of directed edges on any directed path from $u$ to $v$. If $v$ is not reachable from $u$, then $\\ell_{s}(u,v)$ is undefined for the purpose of maxima below.\n- The weighted directed shortest-path length $\\ell_{w}(u,v)$ is the minimal total cost $\\sum_{e \\in P} c(e)$ over all directed paths $P$ from $u$ to $v$. If $v$ is not reachable from $u$, then $\\ell_{w}(u,v)$ is undefined for the purpose of maxima below.\n- The unweighted directed diameter $D_{s}$ is the maximum of $\\ell_{s}(u,v)$ over all ordered pairs $(u,v)$ with $u \\neq v$ for which $v$ is reachable from $u$.\n- The weighted directed diameter $D_{w}$ is the maximum of $\\ell_{w}(u,v)$ over all ordered pairs $(u,v)$ with $u \\neq v$ for which $v$ is reachable from $u$.\n\nTasks:\n1. Compute $D_{s}$ for this network by determining the minimal directed hop counts $\\ell_{s}(u,v)$ and then taking the maximum over all ordered pairs $(u,v)$ with finite reachability.\n2. Compute $D_{w}$ for this network by determining the minimal directed path costs $\\ell_{w}(u,v)$ and then taking the maximum over all ordered pairs $(u,v)$ with finite reachability.\n3. Starting from the interpretation of path length in signaling cascades and the additivity of independent segment costs, explain the biological rationale for preferring $D_{w}$ or $D_{s}$ when assessing the potential reachability of a pharmacological intervention introduced at a single node.\n\nReport your final numerical result as the ordered pair $(D_{s}, D_{w})$. No rounding is required.", "solution": "The user has provided a problem that requires the computation of unweighted and weighted diameters of a directed graph representing a signaling network, and an explanation of the biological relevance of these two metrics.\n\n### Step 1: Problem Validation\n\n**Extracted Givens:**\n-   **Nodes:** $V = \\{R, A, B, C, D, E, F\\}$\n-   **Directed Edges and Costs:**\n    -   $R \\rightarrow A$, $c(R,A)=0.7$\n    -   $R \\rightarrow C$, $c(R,C)=3.2$\n    -   $A \\rightarrow B$, $c(A,B)=0.6$\n    -   $A \\rightarrow D$, $c(A,D)=1.9$\n    -   $B \\rightarrow C$, $c(B,C)=0.5$\n    -   $B \\rightarrow E$, $c(B,E)=2.8$\n    -   $C \\rightarrow D$, $c(C,D)=0.4$\n    -   $D \\rightarrow E$, $c(D,E)=0.3$\n    -   $D \\rightarrow F$, $c(D,F)=0.2$\n    -   $E \\rightarrow F$, $c(E,F)=0.3$\n    -   $F \\rightarrow C$, $c(F,C)=0.4$\n-   **Definitions:**\n    -   Unweighted shortest-path length $\\ell_{s}(u,v)$: minimal number of edges on a path from $u$ to $v$.\n    -   Weighted shortest-path length $\\ell_{w}(u,v)$: minimal sum of costs on a path from $u$ to $v$.\n    -   Unweighted diameter $D_{s}$: $\\max\\{\\ell_{s}(u,v)\\}$ over all ordered pairs $(u,v)$ with $u \\neq v$ where $v$ is reachable from $u$.\n    -   Weighted diameter $D_{w}$: $\\max\\{\\ell_{w}(u,v)\\}$ over all ordered pairs $(u,v)$ with $u \\neq v$ where $v$ is reachable from $u$.\n\n**Validation Verdict:**\nThe problem is valid.\n-   It is **scientifically grounded**, using standard graph-theoretic concepts ($D_s, D_w$) to analyze a recognized model in systems biomedicine (signaling networks).\n-   It is **well-posed**. The graph is fully specified, edge costs are positive (preventing negative-cost cycles), and the definitions are precise and standard. A unique solution exists for each computational task. The condition to maximize only over reachable pairs handles undefined path lengths correctly.\n-   It is **objective**. The tasks are computational and require logical reasoning based on given interpretations, free of subjective elements.\n-   The problem does not exhibit any of the listed flaws (e.g., incompleteness, contradiction, ambiguity).\n\n### Step 2: Solution Derivation\n\nThe problem requires the calculation of two network properties, the unweighted diameter $D_s$ and the weighted diameter $D_w$, followed by a comparative analysis of their biological utility. This involves computing all-pairs shortest paths for both the unweighted and weighted versions of the given directed graph.\n\n**Task 1: Computation of the Unweighted Diameter $D_s$**\n\nThe unweighted shortest-path length $\\ell_s(u,v)$ between any two nodes $u$ and $v$ is the minimum number of edges (hops) on a path from $u$ to $v$. We can find these lengths by performing a Breadth-First Search (BFS) starting from each node in the network.\n\n-   Let's find the strongly connected components. The set $\\{C, D, F\\}$ forms a strongly connected component since $C \\to D \\to F \\to C$. The cycle has a length of $3$ hops. All nodes are reachable from $R$. Not all nodes can reach $R$.\n-   By executing a BFS from each of the $7$ nodes, we can construct the matrix of unweighted shortest-path lengths $\\ell_s(u,v)$. An entry of $\\infty$ indicates that $v$ is not reachable from $u$.\n\nMatrix of $\\ell_s(u,v)$:\n$$\n\\begin{array}{c|ccccccc}\n\\ell_s(u,v)  R  A  B  C  D  E  F \\\\\n\\hline\nR  0  1  2  1  2  3  3 \\\\\nA  \\infty  0  1  2  1  2  2 \\\\\nB  \\infty  \\infty  0  1  2  1  2 \\\\\nC  \\infty  \\infty  \\infty  0  1  2  2 \\\\\nD  \\infty  \\infty  \\infty  2  0  1  1 \\\\\nE  \\infty  \\infty  \\infty  2  3  0  1 \\\\\nF  \\infty  \\infty  \\infty  1  2  3  0 \\\\\n\\end{array}\n$$\nThe unweighted diameter $D_s$ is the maximum finite value in this matrix, excluding the diagonal entries.\n$$\nD_s = \\max_{u \\neq v, \\ell_s(u,v)  \\infty} \\ell_s(u,v)\n$$\nInspecting the matrix, the maximum value is $3$. This value occurs for several pairs, including:\n-   $\\ell_s(R,E) = 3$ (path: $R \\to A \\to B \\to E$)\n-   $\\ell_s(R,F) = 3$ (path: $R \\to A \\to D \\to F$)\n-   $\\ell_s(E,D) = 3$ (path: $E \\to F \\to C \\to D$)\n-   $\\ell_s(F,E) = 3$ (path: $F \\to C \\to D \\to E$)\n\nTherefore, the unweighted diameter is $D_s = 3$.\n\n**Task 2: Computation of the Weighted Diameter $D_w$**\n\nThe weighted shortest-path length $\\ell_w(u,v)$ is the minimum sum of edge costs along a path from $u$ to $v$. Since all edge costs are positive, we can use Dijkstra's algorithm starting from each node to find the all-pairs shortest paths. Alternatively, for a small graph, the Floyd-Warshall algorithm can be used.\n\nLet's summarize the results of running Dijkstra's algorithm from each node in a matrix of weighted shortest-path lengths $\\ell_w(u,v)$.\n\n-   From source $R$: $\\ell_w(R,E) = \\ell_w(R,D) + c(D,E) = (\\ell_w(R,C) + c(C,D)) + c(D,E) = ((\\ell_w(R,B) + c(B,C)) + c(C,D)) + c(D,E) = (((\\ell_w(R,A) + c(A,B)) + c(B,C)) + c(C,D)) + c(D,E) = (((0.7+0.6)+0.5)+0.4)+0.3 = 2.5$.\n... and so on for all pairs.\n\nThe complete matrix of $\\ell_w(u,v)$ is:\n$$\n\\begin{array}{c|ccccccc}\n\\ell_w(u,v)  R  A  B  C  D  E  F \\\\\n\\hline\nR  0  0.7  1.3  1.8  2.2  2.5  2.4 \\\\\nA  \\infty  0  0.6  1.1  1.5  1.8  1.7 \\\\\nB  \\infty  \\infty  0  0.5  0.9  1.2  1.1 \\\\\nC  \\infty  \\infty  \\infty  0  0.4  0.7  0.6 \\\\\nD  \\infty  \\infty  \\infty  0.6  0  0.3  0.2 \\\\\nE  \\infty  \\infty  \\infty  0.7  1.1  0  0.3 \\\\\nF  \\infty  \\infty  \\infty  0.4  0.8  1.1  0 \\\\\n\\end{array}\n$$\nThe weighted diameter $D_w$ is the maximum value in this matrix, excluding the diagonal.\n$$\nD_w = \\max_{u \\neq v, \\ell_w(u,v)  \\infty} \\ell_w(u,v)\n$$\nBy inspection, the maximum value in the matrix is $2.5$, which is $\\ell_w(R,E)$. The path corresponding to this cost is $R \\to A \\to B \\to C \\to D \\to E$, with a total cost of $0.7 + 0.6 + 0.5 + 0.4 + 0.3 = 2.5$.\n\nTherefore, the weighted diameter is $D_w = 2.5$.\n\n**Task 3: Biological Rationale for Preferring $D_w$ or $D_s$**\n\nThe problem asks for a rationale for preferring $D_w$ or $D_s$ when assessing the reachability of a pharmacological intervention, based on the interpretation of edge costs $c(u,v)$ as signal-transduction costs (e.g., time delays).\n\nA pharmacological intervention at a node $u$ propagates its influence through the network along directed paths. The \"reachability\" of this intervention at a downstream node $v$ is fundamentally related to the time it takes for the signal to travel from $u$ to $v$.\n\nThe unweighted diameter, $D_s$, measures the maximum number of sequential steps required for a signal to traverse between any two reachable nodes. This metric treats every signaling step (every edge) as equivalent. It provides a purely topological measure of the network's maximal \"extent.\"\n\nThe weighted diameter, $D_w$, measures the maximum cumulative cost (e.g., total time delay) for a signal to traverse between any two reachable nodes. This metric explicitly incorporates the heterogeneity of signaling processes, where some steps may be rapid (low cost) and others slow (high cost). The problem states that costs represent an \"effective signal-transduction cost\" such as \"average transmission delay.\"\n\nGiven this interpretation, $D_w$ is the more biologically relevant metric. Biological signaling is a temporal process. The speed and efficiency of signal propagation determine the timescale and magnitude of the cellular response. A path with a few very slow, rate-limiting steps (high cost) can have a much longer total delay than a path with many fast steps (low cost).\n\nFor example, compare the path from $A$ to $D$ directly with the path from $A$ to $C$ via $B$.\n-   Path $A \\to D$: $\\ell_s(A,D) = 1$, but $\\ell_w(A,D) = 1.9$.\n-   Path $A \\to B \\to C$: $\\ell_s(A,C) = 2$, but $\\ell_w(A,C) = 0.6 + 0.5 = 1.1$.\n\nAn intervention at $A$ will affect node $C$ more rapidly (cost $1.1$) than it will affect node $D$ (cost $1.9$), even though $D$ is topologically \"closer\" (1 hop vs. 2 hops). The $D_s$ metric would misleadingly suggest that $D$ is more readily influenced from $A$ than $C$.\n\nTherefore, when assessing the potential reachability of a pharmacological intervention in terms of how far and how fast its effects can propagate, the weighted diameter $D_w$ is superior. It provides a measure of the maximum time delay or cumulative cost for an effect to manifest anywhere in the network, which is a more realistic and functionally meaningful measure of reachability in a dynamic biological system than simply counting the number of intermediate process steps.\n\nThe final required result is the ordered pair $(D_s, D_w)$.\nBased on the calculations, $D_s = 3$ and $D_w = 2.5$.", "answer": "$$ \\boxed{ \\begin{pmatrix} 3  2.5 \\end{pmatrix} } $$", "id": "4372644"}, {"introduction": "This advanced practice moves from calculation and interpretation to computational application and analysis, a key skill in modern systems biomedicine. You will implement an algorithm to assess network robustness by simulating the effect of a loss-of-function mutation, modeled as the removal of a central \"hub\" protein. By computing the network diameter before and after this perturbation across different network architectures, you will explore the critical link between a network's topology, its resilience to damage, and the potential systemic impact of disease-related genetic changes [@problem_id:4372650].", "problem": "You are given a set of undirected biological interaction networks that model macromolecular connectivity (for example, Protein-Protein Interaction (PPI) networks). Each network is represented as a simple graph with a finite set of nodes and undirected edges. Consider the following fundamental definitions from graph theory applied to systems biomedicine: for a simple undirected graph $G = (V, E)$, a path between two nodes is any sequence of distinct nodes connected by edges, its length is the number of edges in that sequence, and the shortest path distance $d(u,v)$ is the minimum such length over all paths between $u$ and $v$ that exist. The diameter $D(G)$ of $G$ is the maximum shortest path distance over all unordered node pairs in a given connected component of interest. In this problem, let the connected component of interest be defined as the largest connected component by cardinality; if more than one component has the same largest size, select among them the one with the largest diameter. If the selected component has fewer than $2$ nodes, define $D(G) = 0$. All path lengths are unitless counts of edges and must be treated as integers.\n\nA disease-associated loss-of-function mutation can be abstracted as the removal of a node (and all incident edges) from the network. A hub is defined as a node having maximum degree in the current graph. Given an integer $k \\ge 1$, perform hub removal by removing $k$ nodes that have the largest degrees, breaking ties by lexicographic order of node identifiers (ascending). After removal, recompute the diameter on the largest connected component using the same rule as above.\n\nYour task is to write a complete program that, for each provided test network, computes the pair of diameters $\\left[D_{\\text{before}}, D_{\\text{after}}\\right]$, where $D_{\\text{before}}$ is the diameter of the largest connected component of the original graph and $D_{\\text{after}}$ is the diameter of the largest connected component after removal of $k$ hubs as specified. Output all results on a single line as a comma-separated list enclosed in square brackets, with each element itself being a two-element list in the same order as the test cases.\n\nUse only the logical and mathematical definitions above, without using any shortcut formulas. Derive the method that computes shortest path distances and diameter from first principles.\n\nTest Suite (edges are given as unordered pairs of strings; all graphs are simple and undirected):\n\n- Test Case $1$ (double-star PPI-like network with two hubs connected by a bridge), removal parameter $k=1$:\n  - Nodes include: TP53, EGFR, BRCA1, AKT1, PTEN, MAPK1, RB1, PIK3CA, CDK2, MDM2, MYC.\n  - Edges:\n    - (\"TP53\",\"EGFR\")\n    - (\"TP53\",\"BRCA1\"), (\"TP53\",\"AKT1\"), (\"TP53\",\"PTEN\"), (\"TP53\",\"MAPK1\"), (\"TP53\",\"RB1\")\n    - (\"EGFR\",\"PIK3CA\"), (\"EGFR\",\"CDK2\"), (\"EGFR\",\"MDM2\"), (\"EGFR\",\"MYC\")\n\n- Test Case $2$ (linear chain of $6$ genes), removal parameter $k=1$:\n  - Nodes: G1, G2, G3, G4, G5, G6.\n  - Edges:\n    - (\"G1\",\"G2\"), (\"G2\",\"G3\"), (\"G3\",\"G4\"), (\"G4\",\"G5\"), (\"G5\",\"G6\")\n\n- Test Case $3$ (complete clique of size $5$), removal parameter $k=1$:\n  - Nodes: A, B, C, D, E.\n  - Edges:\n    - (\"A\",\"B\"), (\"A\",\"C\"), (\"A\",\"D\"), (\"A\",\"E\"),\n    - (\"B\",\"C\"), (\"B\",\"D\"), (\"B\",\"E\"),\n    - (\"C\",\"D\"), (\"C\",\"E\"),\n    - (\"D\",\"E\")\n\nAnswer specification:\n- For each test case, compute $D_{\\text{before}}$ and $D_{\\text{after}}$ as integers.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact format: $\\left[ [D_{\\text{before}}^{(1)}, D_{\\text{after}}^{(1)}], [D_{\\text{before}}^{(2)}, D_{\\text{after}}^{(2)}], [D_{\\text{before}}^{(3)}, D_{\\text{after}}^{(3)}] \\right]$, with no spaces.", "solution": "The problem asks us to compute the diameter of the largest connected component (LCC) of a given biological network, represented as a simple undirected graph, both before and after the removal of a specified number of hub nodes. The solution requires a step-by-step implementation of graph algorithms from first principles.\n\n### Methodological Framework\n\nThe overall process for each test case involves two main stages:\n1.  Analyze the initial graph to determine its LCC's diameter, $D_{\\text{before}}$.\n2.  Identify and remove $k$ hub nodes, then analyze the resulting graph to determine the new LCC's diameter, $D_{\\text{after}}$.\n\nThis requires several fundamental graph-theoretic algorithms, which we will derive and implement.\n\n#### 1. Graph Representation\nA graph $G = (V, E)$ consists of a set of nodes $V$ and a set of edges $E$. We will represent the graph using an adjacency list. This is implemented as a dictionary where each key is a node identifier and its corresponding value is a set of identifiers of its adjacent nodes. This structure is efficient for traversing the graph and for the sparse networks common in biology.\n\n#### 2. Finding Connected Components\nTo identify the LCC, we must first partition the graph into its connected components. A connected component is a subgraph in which any two nodes are connected to each other by a path, and which is connected to no other nodes in the supergraph. We can find all components using a graph traversal algorithm like Breadth-First Search (BFS).\n\nThe algorithm proceeds as follows:\n- Maintain a set of visited nodes, initially empty.\n- Iterate through every node in the graph.\n- If a node has not yet been visited, it belongs to a new, undiscovered component. Start a BFS traversal from this node.\n- The BFS will visit all reachable nodes, which collectively form one connected component. Add all these nodes to the visited set.\n- Store this component (as a set of its nodes) and repeat the process until all nodes have been visited.\n\n#### 3. All-Pairs Shortest Paths (APSP) and Diameter\nThe problem defines the shortest path distance $d(u,v)$ between two nodes $u$ and $v$ as the minimum number of edges in a path connecting them. For an unweighted graph, BFS is the most efficient algorithm to compute single-source shortest paths (SSSP). Starting a BFS from a source node $s$, the distance to any other node $v$ is its level in the BFS tree, i.e., the number of edges on the path from $s$ to $v$.\n\nTo find the diameter of a connected component, we need the shortest path distances between all pairs of nodes within that component. This can be achieved by executing the SSSP (BFS) algorithm from every node in the component.\n\nThe diameter $D(G)$ of a connected component $G$ is the maximum shortest path distance over all pairs of nodes in that component:\n$$\nD(G) = \\max_{u, v \\in V} d(u,v)\n$$\nThis is equivalent to finding the maximum eccentricity of any node, where the eccentricity of a node $u$ is $\\epsilon(u) = \\max_{v \\in V} d(u,v)$.\n\nThe procedure to calculate the diameter of a given component is:\n1.  If the component contains fewer than $2$ nodes, its diameter is $0$.\n2.  Otherwise, initialize a maximum distance variable to $0$.\n3.  For each node $u$ in the component:\n    a. Run BFS starting from $u$ to find the distances to all other nodes $v$ in the component.\n    b. The maximum of these distances is the eccentricity of $u$. Update the overall maximum distance if this eccentricity is greater.\n4.  The final maximum distance is the component's diameter.\n\n#### 4. Selection of the Largest Connected Component (LCC)\nThe problem specifies a precise rule for selecting the component of interest:\n1.  Find all connected components and determine their sizes (number of nodes).\n2.  Identify the maximum size among all components.\n3.  Filter the list of components to include only those with this maximum size.\n4.  If this yields a single component, it is the LCC.\n5.  If there is a tie (multiple components have the same maximal size), calculate the diameter of each of these candidate components. The LCC is the one with the largest diameter among them. The value returned is this largest diameter.\n\n#### 5. Hub Identification and Removal\nA hub is defined as a node with the maximum degree in the graph. The removal process for $k$ hubs is as follows:\n1.  For every node in the graph, calculate its degree (the number of edges connected to it).\n2.  Identify the list of nodes that have the highest degrees.\n3.  If there are ties in degree, these nodes are ordered lexicographically by their string identifiers (in ascending order).\n4.  The top $k$ nodes from this sorted list are designated as the hubs to be removed.\n5.  A new graph is constructed by deleting these $k$ nodes and all edges incident to them.\n\n#### 6. Final Calculation\nThe overall algorithm for each test case is:\n1.  Construct the initial graph from the provided nodes and edges.\n2.  Apply the LCC selection logic and diameter calculation to this graph to find $D_{\\text{before}}$.\n3.  Identify and remove the top $k$ hubs from the initial graph to create a new, perturbed graph.\n4.  Apply the LCC selection and diameter calculation to this new graph to find $D_{\\text{after}}$.\n5.  The result for the test case is the pair $[D_{\\text{before}}, D_{\\text{after}}]$. This procedure is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the network diameter problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: Double-star PPI network\n        {\n            \"nodes\": {\"TP53\", \"EGFR\", \"BRCA1\", \"AKT1\", \"PTEN\", \"MAPK1\", \"RB1\", \"PIK3CA\", \"CDK2\", \"MDM2\", \"MYC\"},\n            \"edges\": [\n                (\"TP53\", \"EGFR\"), (\"TP53\", \"BRCA1\"), (\"TP53\", \"AKT1\"), (\"TP53\", \"PTEN\"),\n                (\"TP53\", \"MAPK1\"), (\"TP53\", \"RB1\"), (\"EGFR\", \"PIK3CA\"), (\"EGFR\", \"CDK2\"),\n                (\"EGFR\", \"MDM2\"), (\"EGFR\", \"MYC\")\n            ],\n            \"k\": 1\n        },\n        # Test Case 2: Linear chain\n        {\n            \"nodes\": {\"G1\", \"G2\", \"G3\", \"G4\", \"G5\", \"G6\"},\n            \"edges\": [(\"G1\", \"G2\"), (\"G2\", \"G3\"), (\"G3\", \"G4\"), (\"G4\", \"G5\"), (\"G5\", \"G6\")],\n            \"k\": 1\n        },\n        # Test Case 3: Complete clique\n        {\n            \"nodes\": {\"A\", \"B\", \"C\", \"D\", \"E\"},\n            \"edges\": [\n                (\"A\", \"B\"), (\"A\", \"C\"), (\"A\", \"D\"), (\"A\", \"E\"),\n                (\"B\", \"C\"), (\"B\", \"D\"), (\"B\", \"E\"),\n                (\"C\", \"D\"), (\"C\", \"E\"),\n                (\"D\", \"E\")\n            ],\n            \"k\": 1\n        }\n    ]\n\n    def build_graph(nodes, edges):\n        \"\"\"Builds an adjacency list representation of the graph.\"\"\"\n        graph = defaultdict(set)\n        for node in nodes:\n            graph[node] # Ensure all nodes are in the graph dict\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n        return graph\n\n    def get_connected_components(graph):\n        \"\"\"Finds all connected components in a graph using BFS.\"\"\"\n        visited = set()\n        components = []\n        for node in graph:\n            if node not in visited:\n                component = set()\n                queue = [node]\n                visited.add(node)\n                component.add(node)\n                head = 0\n                while head  len(queue):\n                    current_node = queue[head]\n                    head += 1\n                    for neighbor in graph[current_node]:\n                        if neighbor not in visited:\n                            visited.add(neighbor)\n                            component.add(neighbor)\n                            queue.append(neighbor)\n                components.append(frozenset(component))\n        return components\n\n    def bfs_shortest_paths(graph, start_node):\n        \"\"\"Calculates shortest paths from a start node in an unweighted graph.\"\"\"\n        if start_node not in graph:\n            return {}\n        distances = {start_node: 0}\n        queue = [(start_node, 0)]\n        head = 0\n        while head  len(queue):\n            current_node, dist = queue[head]\n            head += 1\n            for neighbor in graph.get(current_node, set()):\n                if neighbor not in distances:\n                    distances[neighbor] = dist + 1\n                    queue.append((neighbor, dist + 1))\n        return distances\n\n\n    def calculate_diameter(graph, component_nodes):\n        \"\"\"Calculates the diameter of a given connected component.\"\"\"\n        if len(component_nodes)  2:\n            return 0\n        \n        max_dist = 0\n        # The graph passed to bfs must only contain nodes of the component.\n        subgraph = {node: graph[node] for node in component_nodes}\n\n        for start_node in component_nodes:\n            distances = bfs_shortest_paths(subgraph, start_node)\n            if not distances:\n                continue\n            # If component is disconnected, max would be on reachable nodes.\n            # But get_connected_components ensures this is not an issue.\n            current_max = max(distances.values())\n            if current_max  max_dist:\n                max_dist = current_max\n        return max_dist\n\n    def compute_diameter_of_lcc(graph):\n        \"\"\"Computes the diameter of the largest connected component (LCC).\"\"\"\n        if not graph:\n            return 0\n        \n        components = get_connected_components(graph)\n        if not components:\n            return 0\n\n        max_size = 0\n        for comp in components:\n            if len(comp)  max_size:\n                max_size = len(comp)\n\n        largest_components = [comp for comp in components if len(comp) == max_size]\n        \n        if len(largest_components) == 1:\n            lcc_nodes = largest_components[0]\n            return calculate_diameter(graph, lcc_nodes)\n        else:\n            max_diam = -1\n            for comp_nodes in largest_components:\n                diam = calculate_diameter(graph, comp_nodes)\n                if diam  max_diam:\n                    max_diam = diam\n            return max_diam if max_diam != -1 else 0\n\n    def remove_hubs(graph, k):\n        \"\"\"Identifies and removes the top k hubs from a graph.\"\"\"\n        if not graph:\n            return {}\n\n        nodes_with_degrees = []\n        for node in graph:\n            nodes_with_degrees.append((len(graph[node]), node))\n        \n        # Sort by degree (descending) and then node ID (ascending)\n        nodes_with_degrees.sort(key=lambda x: (-x[0], x[1]))\n\n        nodes_to_remove = {item[1] for item in nodes_with_degrees[:k]}\n        \n        new_graph = defaultdict(set)\n        original_nodes = set(graph.keys())\n        remaining_nodes = original_nodes - nodes_to_remove\n\n        for node in remaining_nodes:\n            new_graph[node] # Ensure node exists in new graph\n            for neighbor in graph[node]:\n                if neighbor in remaining_nodes:\n                    new_graph[node].add(neighbor)\n\n        return new_graph\n\n    results = []\n    for case in test_cases:\n        nodes, edges, k = case[\"nodes\"], case[\"edges\"], case[\"k\"]\n\n        # Before removal\n        graph_before = build_graph(nodes, edges)\n        d_before = compute_diameter_of_lcc(graph_before)\n\n        # After removal\n        graph_after = remove_hubs(graph_before, k)\n        d_after = compute_diameter_of_lcc(graph_after)\n        \n        results.append([d_before, d_after])\n\n    # Format the final output string exactly as specified.\n    str_results = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "4372650"}]}