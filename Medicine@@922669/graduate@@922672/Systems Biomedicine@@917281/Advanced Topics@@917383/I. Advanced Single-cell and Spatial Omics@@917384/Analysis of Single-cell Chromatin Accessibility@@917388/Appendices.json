{"hands_on_practices": [{"introduction": "The journey from raw sequencing data to biological insight in scATAC-seq begins with a critical processing pipeline. This foundational step transforms paired-end sequencing reads into a structured 'fragment file,' which serves as the input for all downstream analyses. This exercise [@problem_id:4314894] demystifies this process by guiding you through the implementation of a pipeline from first principles, including the crucial Tn5 cut-site correction that is unique to transposase-based assays.", "problem": "You are tasked with constructing a self-contained, computational pipeline that transforms raw paired-end reads from single-cell Assay for Transposase-Accessible Chromatin sequencing (scATAC-seq) into a per-cell fragment representation. The pipeline must proceed from first principles using the following foundational facts and definitions:\n\n- Deoxyribonucleic Acid (DNA) can be represented as a finite string over the alphabet $\\{A,C,G,T\\}$.\n- The reverse complement of a DNA string is obtained by reversing the string and substituting each base by its complement under the mapping $A \\leftrightarrow T$ and $C \\leftrightarrow G$.\n- In scATAC-seq, the Tn5 transposase (often referred to as Tn5) makes staggered cuts, and widely accepted empirical correction offsets are applied to the $5'$ ends of aligned reads: shift by $+4$ bases for reads aligned to the forward strand and by $-5$ bases for reads aligned to the reverse strand.\n- Genomic coordinates will be treated under the $0$-based, half-open interval convention on each chromosome, so a fragment on chromosome $X$ is represented by the tuple $(X, s, e)$ where $s$ is the inclusive start and $e$ is the exclusive end, with $0 \\le s \\le e \\le L_X$ and $L_X$ the length of chromosome $X$.\n\nYou must implement the following steps without relying on external files or inputs; all data will be embedded in the program:\n\n1. Alignment by exact matching:\n   - Given a genome string for a chromosome, a read string $r$ of length $L$, and its reverse complement $rc(r)$, scan all positions $p \\in \\{0,1,\\dots,L_{\\text{chr}}-L\\}$.\n   - Record a forward-strand placement whenever the genome substring at $[p,p+L)$ equals $r$ and a reverse-strand placement whenever the genome substring at $[p,p+L)$ equals $rc(r)$.\n   - If there are multiple placements across both strands, select the one with the smallest $p$; if there is a tie on $p$ across strands, prefer the forward strand. If there are no placements on either strand, the read is considered unaligned.\n\n2. Cut site determination for each aligned read:\n   - For a forward-strand placement at position $p$ with read length $L$, define the uncorrected $5'$ cut site as $c = p$.\n   - For a reverse-strand placement at position $p$ with read length $L$, define the uncorrected $5'$ cut site as $c = p + L$.\n\n3. Tn5 cutsite offset correction and clipping:\n   - Apply the empirical offsets: for forward strand use $+4$ and for reverse strand use $-5$.\n   - After offsetting, clip the resulting coordinate to the valid range $[0, L_{\\text{chr}}]$.\n\n4. Fragment construction and deduplication:\n   - For each paired-end read $(r_1, r_2)$ aligned on the same chromosome, compute their two clipped, offset cut sites $o_1$ and $o_2$.\n   - Define the fragment interval as $[s,e)$ where $s = \\min(o_1,o_2)$ and $e = \\max(o_1,o_2)$.\n   - Discard zero-length fragments with $s = e$.\n   - Associate each fragment with its cell barcode $b$ and chromosome name $X$, forming the tuple $(X, s, e, b)$.\n   - Deduplicate fragments per cell by exact identity of $(X, s, e, b)$; duplicates across different cell barcodes are not merged.\n\n5. Aggregation and output:\n   - For each test case, compute the number of unique fragments obtained after deduplication (including the barcode in identity), producing an integer result.\n\nImplement the above in a single program that embeds the test suite defined below, runs the pipeline for each test case, and prints the results in a single line as a comma-separated list within square brackets, for example, $[r_1,r_2,r_3]$.\n\nTest Suite:\n- Case $1$ (happy path with per-cell deduplication):\n  - Genome:\n    - Chromosome name: \"chr1\"\n    - Sequence: \"AAAACCCCGGGGTTTTACGTACGTTTGGCCAAATTTCCCGGG\"\n  - Paired reads with barcodes:\n    - (\"chr1\", $r_1 = \\text{\"ACGTAC\"}$, $r_2 = \\text{\"TTTGGCC\"}$, $b = \\text{\"cellA\"}$)\n    - (\"chr1\", $r_1 = \\text{\"ACGTAC\"}$, $r_2 = \\text{\"TTTGGCC\"}$, $b = \\text{\"cellA\"}$)  [duplicate of the above]\n    - (\"chr1\", $r_1 = \\text{\"GGGGTT\"}$, $r_2 = \\text{\"AAAACC\"}$, $b = \\text{\"cellB\"}$)\n  - Expected behavior: alignment yields two unique fragments overall when including the barcode in identity.\n\n- Case $2$ (boundary at chromosome start causing clipping after $-5$ reverse offset):\n  - Genome:\n    - Chromosome name: \"chr2\"\n    - Sequence: \"AAAAC\"\n  - Paired reads with barcodes:\n    - (\"chr2\", $r_1 = \\text{\"AAAA\"}$, $r_2 = \\text{\"TTT\"}$, $b = \\text{\"cellX\"}$)\n  - Expected behavior: the reverse-strand offset yields a negative coordinate that must be clipped to $0$, producing one unique fragment.\n\n- Case $3$ (boundary at chromosome end causing clipping after $+4$ forward offset):\n  - Genome:\n    - Chromosome name: \"chr3\"\n    - Sequence: \"ACGTAC\"\n  - Paired reads with barcodes:\n    - (\"chr3\", $r_1 = \\text{\"TA\"}$, $r_2 = \\text{\"GT\"}$, $b = \\text{\"cellY\"}$)\n  - Expected behavior: the forward-strand offset exceeds the chromosome length and must be clipped to $L_{\\text{chr}}$, producing one unique fragment.\n\nFinal Output Format:\n- Your program should produce a single line of output containing the results for the three cases as a comma-separated list enclosed in square brackets, for example, $[2,1,1]$. No additional text should be printed.", "solution": "The problem provides a detailed specification for a computational pipeline to process single-cell Assay for Transposase-Accessible Chromatin sequencing (scATAC-seq) data. The process begins with raw paired-end reads and produces a set of unique, per-cell chromatin fragments. The solution requires a faithful implementation of the specified steps, which are grounded in established bioinformatics principles.\n\nFirst, the foundational definitions are established. A DNA sequence is a string over the alphabet $\\{\\text{'A'}, \\text{'C'}, \\text{'G'}, \\text{'T'}\\}$. The reverse complement of a DNA string, denoted $rc(S)$, is obtained by reversing the string $S$ and substituting each base with its Watson-Crick complement ($A \\leftrightarrow T$, $C \\leftrightarrow G$). Genomic locations are represented using a $0$-based, half-open interval convention, where a fragment on chromosome $X$ spanning from a start position $s$ (inclusive) to an end position $e$ (exclusive) is denoted $(X, s, e)$. This interval must conform to the chromosome's boundaries, $0 \\le s \\le e \\le L_X$, where $L_X$ is the length of chromosome $X$.\n\nThe pipeline consists of five sequential steps:\n\n**1. Alignment by Exact Matching**\nThis step maps a sequenced read to its origin on a reference genome. For a given read $r$ of length $L_r$ and a chromosome sequence $G$ of length $L_{\\text{chr}}$, we search for its position and strand. A forward-strand placement occurs at position $p$ if the genomic substring $G[p:p+L_r)$ equals $r$. A reverse-strand placement occurs if $G[p:p+L_r)$ equals $rc(r)$. All possible start positions $p \\in \\{0, 1, \\dots, L_{\\text{chr}} - L_r\\}$ are scanned. Should multiple alignment possibilities exist, a deterministic tie-breaking rule is applied: the alignment with the smallest genomic coordinate $p$ is chosen. If a forward and a reverse alignment share the same minimal $p$, the forward-strand alignment is preferred. A read for which no match is found is considered unaligned and is not processed further.\n\n**2. Cut Site Determination**\nscATAC-seq identifies accessible chromatin regions by leveraging the Tn$5$ transposase, which cuts DNA and inserts sequencing adapters. The start of each sequencing read corresponds to one of these cut sites. The uncorrected coordinate of the cut, which represents the $5'$ end of the read, is defined as follows:\n- For a forward-strand read aligned at position $p$, the uncorrected cut site is $c = p$.\n- For a reverse-strand read aligned at position $p$ with length $L_r$, the corresponding $5'$ end is at the end of the aligned segment on the genome. Thus, the uncorrected cut site is $c = p + L_r$.\n\n**3. Tn5 Cut Site Offset Correction and Clipping**\nThe Tn$5$ enzyme acts as a dimer, and its two active sites create staggered nicks in the DNA. This means the precise center of the transposon binding event is not exactly at the read's $5'$ end. To account for this, an empirical correction is applied:\n- The cut site of a forward-strand read is shifted by $+4$ bases: $c' = c + 4$.\n- The cut site of a reverse-strand read is shifted by $-5$ bases: $c' = c - 5$.\nThe resulting coordinate $c'$ must be a valid position on the chromosome. Any coordinate falling outside the chromosome's boundaries $[0, L_{\\text{chr}}]$ is clipped to the nearest valid value. The final offset coordinate $o$ is given by $o = \\max(0, \\min(c', L_{\\text{chr}}))$.\n\n**4. Fragment Construction and Deduplication**\nIn paired-end sequencing, two reads, $r_1$ and $r_2$, are generated from opposite ends of a single DNA fragment. After determining the final clipped and offset cut sites, $o_1$ and $o_2$, for both reads in a pair, the original fragment is reconstructed. The fragment is represented by the interval $[s, e)$, where $s = \\min(o_1, o_2)$ and $e = \\max(o_1, o_2)$. Any resulting fragments with zero length ($s=e$) are discarded. Each valid fragment is then recorded as a tuple $(X, s, e, b)$, where $X$ is the chromosome name and $b$ is the cell barcode. Due to PCR amplification during library preparation, multiple identical read pairs can originate from a single initial fragment. To correct for this amplification bias, fragments are deduplicated. Uniqueness is determined by the exact identity of the tuple $(X, s, e, b)$, meaning only identical fragments from the same cell are considered duplicates.\n\n**5. Aggregation and Output**\nThe final step is to quantify the result for each test case by counting the number of unique fragments generated after the entire pipeline is executed.\n\n**Execution on Test Cases:**\n\n**Case 1:** Genome `chr1` ($L_{\\text{chr1}} = 46$).\n- Read Pair $1$: $(r_{1a} = \\text{\"ACGTAC\"}, r_{2a} = \\text{\"TTTGGCC\"}, b = \\text{\"cellA\"})$.\n  - $r_{1a}$ aligns to forward strand at $p_1=16$. Corrected cut site: $o_1 = \\text{clip}(16+4, 0, 46) = 20$.\n  - $r_{2a}$ aligns to forward strand at $p_2=25$. Corrected cut site: $o_2 = \\text{clip}(25+4, 0, 46) = 29$.\n  - Fragment: $(\\text{\"chr1\"}, \\min(20,29), \\max(20,29), \\text{\"cellA\"}) = (\\text{\"chr1\"}, 20, 29, \\text{\"cellA\"})$.\n- Read Pair $2$: Identical to Pair $1$, yields the same fragment $(\\text{\"chr1\"}, 20, 29, \\text{\"cellA\"})$.\n- Read Pair $3$: $(r_{1c} = \\text{\"GGGGTT\"}, r_{2c} = \\text{\"AAAACC\"}, b = \\text{\"cellB\"})$.\n  - $r_{1c}$ aligns forward at $p_1=8$. Corrected cut site: $o_1 = \\text{clip}(8+4, 0, 46) = 12$.\n  - $r_{2c}$ aligns forward at $p_2=0$ (which is preferred over a reverse-strand alignment at $p=9$ based on the tie-breaking rule of selecting the smallest position). Corrected cut site: $o_2 = \\text{clip}(0+4, 0, 46) = 4$.\n  - Fragment: $(\\text{\"chr1\"}, \\min(12,4), \\max(12,4), \\text{\"cellB\"}) = (\\text{\"chr1\"}, 4, 12, \\text{\"cellB\"})$.\n- After deduplication, unique fragments are $\\{(\\text{\"chr1\"}, 20, 29, \\text{\"cellA\"}), (\\text{\"chr1\"}, 4, 12, \\text{\"cellB\"})\\}$. Total count is $2$.\n\n**Case 2:** Genome `chr2` ($L_{\\text{chr2}} = 5$).\n- Read Pair: $(r_1 = \\text{\"AAAA\"}, r_2 = \\text{\"TTT\"}, b = \\text{\"cellX\"})$.\n  - $r_1$ aligns forward at $p_1=0$. Corrected cut site: $o_1 = \\text{clip}(0+4, 0, 5) = 4$.\n  - $r_2$ (length $3$) aligns reverse at $p_2=0$. Uncorrected cut site $c_2 = p_2+L_2 = 0+3=3$. Corrected cut site: $o_2 = \\text{clip}(3-5, 0, 5) = \\text{clip}(-2, 0, 5) = 0$.\n  - Fragment: $(\\text{\"chr2\"}, \\min(4,0), \\max(4,0), \\text{\"cellX\"}) = (\\text{\"chr2\"}, 0, 4, \\text{\"cellX\"})$.\n- Total unique fragments: $1$.\n\n**Case 3:** Genome `chr3` ($L_{\\text{chr3}} = 6$).\n- Read Pair: $(r_1 = \\text{\"TA\"}, r_2 = \\text{\"GT\"}, b = \\text{\"cellY\"})$.\n  - $r_1$ aligns forward at $p_1=3$ (preferred over reverse at same $p$). Corrected cut site: $o_1 = \\text{clip}(3+4, 0, 6) = \\text{clip}(7, 0, 6) = 6$.\n  - $r_2$ (length $2$) aligns reverse at $p_2=0$. Uncorrected cut site $c_2 = p_2+L_2 = 0+2=2$. Corrected cut site: $o_2 = \\text{clip}(2-5, 0, 6) = \\text{clip}(-3, 0, 6) = 0$.\n  - Fragment: $(\\text{\"chr3\"}, \\min(6,0), \\max(6,0), \\text{\"cellY\"}) = (\\text{\"chr3\"}, 0, 6, \\text{\"cellY\"})$.\n- Total unique fragments: $1$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a self-contained computational pipeline for processing scATAC-seq data\n    from raw paired-end reads to a per-cell fragment representation.\n    \"\"\"\n\n    def reverse_complement(dna_string):\n        \"\"\"Computes the reverse complement of a DNA string.\"\"\"\n        complement_map = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}\n        return \"\".join(complement_map.get(base, base) for base in reversed(dna_string))\n\n    def align_read(read_seq, genome_seq):\n        \"\"\"\n        Aligns a read to a genome sequence by exact matching, applying specified tie-breaking rules.\n        Returns a tuple (position, strand) or None if unaligned.\n        \"\"\"\n        read_len = len(read_seq)\n        genome_len = len(genome_seq)\n        \n        fwd_matches = []\n        rev_matches = []\n        \n        rc_read_seq = reverse_complement(read_seq)\n        \n        for p in range(genome_len - read_len + 1):\n            substring = genome_seq[p:p + read_len]\n            if substring == read_seq:\n                fwd_matches.append(p)\n            if substring == rc_read_seq:\n                rev_matches.append(p)\n                \n        min_p_fwd = min(fwd_matches) if fwd_matches else float('inf')\n        min_p_rev = min(rev_matches) if rev_matches else float('inf')\n        \n        if min_p_fwd == float('inf') and min_p_rev == float('inf'):\n            return None  # Unaligned\n        \n        # Tie-breaking rule: smallest p, then forward strand preferred\n        if min_p_fwd = min_p_rev:\n            return (min_p_fwd, 'fwd')\n        else:\n            return (min_p_rev, 'rev')\n            \n    def process_case(genome, paired_reads):\n        \"\"\"\n        Runs the full pipeline for a single test case.\n        \"\"\"\n        genome_name = genome['name']\n        genome_seq = genome['seq']\n        genome_len = len(genome_seq)\n        \n        unique_fragments = set()\n        \n        for _, r1_seq, r2_seq, barcode in paired_reads:\n            # Align read 1\n            alignment1 = align_read(r1_seq, genome_seq)\n            if not alignment1:\n                continue\n            \n            # Align read 2\n            alignment2 = align_read(r2_seq, genome_seq)\n            if not alignment2:\n                continue\n\n            p1, strand1 = alignment1\n            p2, strand2 = alignment2\n            \n            # Calculate offset cut site for read 1\n            if strand1 == 'fwd':\n                uncorrected_c1 = p1\n                corrected_c1 = uncorrected_c1 + 4\n            else:  # 'rev'\n                uncorrected_c1 = p1 + len(r1_seq)\n                corrected_c1 = uncorrected_c1 - 5\n            o1 = np.clip(corrected_c1, 0, genome_len)\n            \n            # Calculate offset cut site for read 2\n            if strand2 == 'fwd':\n                uncorrected_c2 = p2\n                corrected_c2 = uncorrected_c2 + 4\n            else:  # 'rev'\n                uncorrected_c2 = p2 + len(r2_seq)\n                corrected_c2 = uncorrected_c2 - 5\n            o2 = np.clip(corrected_c2, 0, genome_len)\n            \n            # Construct fragment interval\n            s = min(o1, o2)\n            e = max(o1, o2)\n            \n            # Discard zero-length fragments\n            if s == e:\n                continue\n            \n            fragment = (genome_name, int(s), int(e), barcode)\n            unique_fragments.add(fragment)\n            \n        return len(unique_fragments)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"genome\": {\"name\": \"chr1\", \"seq\": \"AAAACCCCGGGGTTTTACGTACGTTTGGCCAAATTTCCCGGG\"},\n            \"reads\": [\n                (\"chr1\", \"ACGTAC\", \"TTTGGCC\", \"cellA\"),\n                (\"chr1\", \"ACGTAC\", \"TTTGGCC\", \"cellA\"),\n                (\"chr1\", \"GGGGTT\", \"AAAACC\", \"cellB\"),\n            ]\n        },\n        {\n            \"genome\": {\"name\": \"chr2\", \"seq\": \"AAAAC\"},\n            \"reads\": [\n                (\"chr2\", \"AAAA\", \"TTT\", \"cellX\")\n            ]\n        },\n        {\n            \"genome\": {\"name\": \"chr3\", \"seq\": \"ACGTAC\"},\n            \"reads\": [\n                (\"chr3\", \"TA\", \"GT\", \"cellY\")\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = process_case(case[\"genome\"], case[\"reads\"])\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4314894"}, {"introduction": "Once a fragment file is generated, the next essential task is rigorous quality control (QC) to ensure the data reflects healthy, single cells. A key indicator of cellular stress or damage is an abnormally high fraction of mitochondrial DNA fragments, as mitochondria often remain accessible when the nucleus degrades. This practice [@problem_id:4314890] challenges you to move beyond arbitrary cutoffs by applying fundamental statistical principles to derive a robust threshold for identifying and removing these low-quality cells.", "problem": "In a Single-Cell Assay for Transposase-Accessible Chromatin (scATAC-seq) experiment, each cell yields a total number of uniquely aligned fragments, of which a subset map to the mitochondrial genome. Let the per-cell mitochondrial fraction be defined as $f_{\\text{mt}} = n_{\\text{mt}}/n_{\\text{total}}$, where $n_{\\text{mt}}$ is the number of mitochondrial fragments and $n_{\\text{total}}$ is the total number of fragments for that cell. High values of $f_{\\text{mt}}$ are commonly associated with low-quality or apoptotic cells, because mitochondria remain accessible when nuclear chromatin becomes degraded or the nucleus is ruptured.\n\nYou are given seven cells with fragment counts $(n_{\\text{mt}}, n_{\\text{total}})$:\n- Cell $1$: $(300, 5000)$\n- Cell $2$: $(295, 5000)$\n- Cell $3$: $(305, 5000)$\n- Cell $4$: $(290, 5000)$\n- Cell $5$: $(310, 5000)$\n- Cell $6$: $(280, 5000)$\n- Cell $7$: $(1460, 5100)$\n\nTasks:\n1. Compute $f_{\\text{mt}}$ for each cell.\n2. Using the sample median of $\\{f_{\\text{mt}}\\}$ across the seven cells as an estimate of the baseline healthy-cell mitochondrial fraction $p_{0}$, and modeling fragment identities as independent Bernoulli trials with success probability $p_{0}$, derive an upper threshold $T$ for $f_{\\text{mt}}$ such that a healthy cell with total fragments $n_{\\text{eff}} = 5000$ exceeds $T$ with probability $\\alpha = 0.01$. Justify the thresholding strategy from first principles using the Binomial model and the Central Limit Theorem as the foundational starting point.\n3. Report the single numerical value of $T$ as a decimal, rounded to four significant figures. Do not use a percentage sign.", "solution": "The problem statement has been validated and is deemed valid. It is scientifically grounded in standard single-cell genomics quality control practices, is well-posed with all necessary information provided, and is formulated objectively. The solution proceeds as follows.\n\nThe problem is divided into three tasks:\n1.  Compute the per-cell mitochondrial fraction, $f_{\\text{mt}}$, for each of the seven cells.\n2.  Establish a baseline healthy-cell mitochondrial fraction, $p_{0}$, and derive an upper threshold, $T$, for $f_{\\text{mt}}$ based on a statistical model.\n3.  Report the numerical value of $T$ rounded to four significant figures.\n\n**Task 1: Computation of Mitochondrial Fractions**\n\nThe mitochondrial fraction is defined as $f_{\\text{mt}} = n_{\\text{mt}}/n_{\\text{total}}$, where $n_{\\text{mt}}$ is the number of mitochondrial fragments and $n_{\\text{total}}$ is the total number of fragments. The given data are pairs of $(n_{\\text{mt}}, n_{\\text{total}})$. We compute $f_{\\text{mt}}$ for each cell:\n- Cell $1$: $f_{\\text{mt},1} = \\frac{300}{5000} = 0.060$\n- Cell $2$: $f_{\\text{mt},2} = \\frac{295}{5000} = 0.059$\n- Cell $3$: $f_{\\text{mt},3} = \\frac{305}{5000} = 0.061$\n- Cell $4$: $f_{\\text{mt},4} = \\frac{290}{5000} = 0.058$\n- Cell $5$: $f_{\\text{mt},5} = \\frac{310}{5000} = 0.062$\n- Cell $6$: $f_{\\text{mt},6} = \\frac{280}{5000} = 0.056$\n- Cell $7$: $f_{\\text{mt},7} = \\frac{1460}{5100} \\approx 0.28627$\n\nThe set of mitochondrial fractions is $\\{0.060, 0.059, 0.061, 0.058, 0.062, 0.056, 0.28627...\\}$.\n\n**Task 2: Derivation of the Upper Threshold $T$**\n\nFirst, we estimate the baseline healthy-cell mitochondrial fraction, $p_{0}$, using the sample median of the computed $\\{f_{\\text{mt}}\\}$ values. The use of the median is a robust statistical practice that minimizes the influence of outliers. In this dataset, Cell $7$ has a markedly higher $f_{\\text{mt}}$, suggesting it is a low-quality or apoptotic cell, and its inclusion in a mean calculation would skew the baseline estimate.\n\nTo find the median, we sort the $f_{\\text{mt}}$ values in ascending order:\n$$\n\\{0.056, 0.058, 0.059, 0.060, 0.061, 0.062, 0.28627...\\}\n$$\nFor a set of $7$ observations, the median is the $4$-th value in the sorted list.\nTherefore, our estimate for the baseline healthy mitochondrial fraction is $p_{0} = 0.060$.\n\nNext, we model the number of mitochondrial fragments in a healthy cell. For a cell with a total of $n_{\\text{eff}}$ fragments, we can model the origin of each fragment (mitochondrial or not) as an independent Bernoulli trial. A \"success\" (the fragment is mitochondrial) occurs with probability $p_{0}$. The total number of mitochondrial fragments, denoted by the random variable $X$, thus follows a Binomial distribution:\n$$\nX \\sim \\text{Binomial}(n, p)\n$$\nwhere the number of trials is $n = n_{\\text{eff}} = 5000$ and the success probability is $p = p_{0} = 0.06$.\n\nThe mitochondrial fraction for this cell is the sample proportion $\\hat{p} = X/n_{\\text{eff}}$. We want to find a threshold $T$ such that the probability of this fraction exceeding $T$ is small, specifically $\\alpha = 0.01$. The problem specifies using the Central Limit Theorem (CLT) to derive this threshold.\n\nAccording to the CLT, for a large number of trials $n$, the distribution of the sample proportion $\\hat{p}$ can be approximated by a Normal distribution. The parameters of this Normal distribution are:\n-   Mean: $E[\\hat{p}] = p_{0}$\n-   Variance: $\\text{Var}(\\hat{p}) = \\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}$\n\nThus, we have the approximation:\n$$\n\\hat{p} \\approx \\mathcal{N}\\left(p_{0}, \\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}\\right)\n$$\nWe need to find the threshold $T$ such that $P(\\hat{p}  T) = \\alpha$. To solve this, we standardize the random variable $\\hat{p}$ to a standard normal variable $Z \\sim \\mathcal{N}(0, 1)$:\n$$\nZ = \\frac{\\hat{p} - E[\\hat{p}]}{\\sqrt{\\text{Var}(\\hat{p})}} = \\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}}\n$$\nThe probability statement becomes:\n$$\nP\\left(\\frac{\\hat{p} - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}}  \\frac{T - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}}\\right) = \\alpha\n$$\nThis is equivalent to $P(Z  z_{\\alpha}) = \\alpha$, where $z_{\\alpha}$ is the upper $\\alpha$-quantile of the standard normal distribution, and\n$$\nz_{\\alpha} = \\frac{T - p_{0}}{\\sqrt{\\frac{p_{0}(1-p_0)}{n_{\\text{eff}}}}}\n$$\nSolving for $T$, we get:\n$$\nT = p_{0} + z_{\\alpha} \\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}}\n$$\n\n**Task 3: Numerical Calculation of $T$**\n\nWe now substitute the given and derived values into the expression for $T$:\n-   $p_{0} = 0.06$\n-   $n_{\\text{eff}} = 5000$\n-   $\\alpha = 0.01$\n\nWe need to find the value $z_{0.01}$ such that the area under the standard normal curve to its right is $0.01$. This corresponds to a cumulative probability of $1 - 0.01 = 0.99$. From standard normal distribution tables or a computational function, we find $z_{0.01} \\approx 2.3263$.\n\nNow, we calculate the standard error of the proportion:\n$$\n\\text{SE}_{\\hat{p}} = \\sqrt{\\frac{p_{0}(1-p_{0})}{n_{\\text{eff}}}} = \\sqrt{\\frac{0.06 \\times (1-0.06)}{5000}} = \\sqrt{\\frac{0.06 \\times 0.94}{5000}} = \\sqrt{\\frac{0.0564}{5000}} = \\sqrt{0.00001128}\n$$\n$$\n\\text{SE}_{\\hat{p}} \\approx 0.00335857\n$$\nFinally, we compute $T$:\n$$\nT = 0.06 + (2.3263) \\times (0.00335857) \\approx 0.06 + 0.0078122\n$$\n$$\nT \\approx 0.0678122\n$$\nThe problem requires the answer rounded to four significant figures. The first significant figure is $6$. The first four significant figures are $0.06781$. The fifth significant figure is $2$, so we round down.\n\nThe final numerical value for the threshold is $0.06781$.", "answer": "$$\n\\boxed{0.06781}\n$$", "id": "4314890"}, {"introduction": "With a high-quality, filtered dataset, we can probe for subtle regulatory signals, such as the 'footprints' left by DNA-binding proteins like transcription factors. Detecting these footprints—local regions of depleted accessibility—is complicated by the Tn5 transposase's inherent sequence-specific cutting bias. This advanced exercise [@problem_id:4314918] introduces a model-based approach to simultaneously correct for this enzymatic bias and quantify the strength of a protein footprint, providing a window into transcription factor activity at single-cell resolution.", "problem": "You are tasked with deriving, formalizing, and implementing an algorithm to compute a chromatin accessibility footprint score for a transcription factor motif in single-cell transposase-accessible chromatin sequencing data, expressed entirely in mathematical and logical terms. Begin from foundational probabilistic modeling and biophysical definitions and produce a program that computes the requested scores for specified test cases.\n\nFundamental base and assumptions:\n- Let a genome locus be discretized into base-level positions indexed by $i \\in \\{0,1,\\dots,L-1\\}$ for a sequence of length $L$. At each position $i$, the observable insertion (cut) count is denoted $c_i$.\n- It is empirically established that the transposase insertion process can be modeled as a counting process wherein $c_i$ is well-approximated by a Poisson random variable with parameter $\\lambda_i$, i.e., $c_i \\sim \\mathrm{Poisson}(\\lambda_i)$. This is a widely used approximation in genomics for count data.\n- The parameter $\\lambda_i$ is hypothesized to factorize into a global scaling factor $\\mu$ (e.g., reflecting cell depth or library size), a local accessibility factor $a_i$ (biophysical accessibility of chromatin to the enzyme), and a sequence-dependent transposase bias $b_i$ that captures sequence preference: $$\\lambda_i = \\mu \\, a_i \\, b_i.$$\n- The sequence-dependent bias $b_i$ is modeled using a $k$-mer representation. For an odd integer $k$ and a position $i$, define a $k$-mer centered at $i$ by extracting the substring spanning $i - \\left\\lfloor k/2 \\right\\rfloor$ to $i + \\left\\lfloor k/2 \\right\\rfloor$ inclusive, provided the substring lies within bounds. Associate each possible $k$-mer $u$ with a real-valued weight $w_u$. The unnormalized bias at position $i$ is $$\\tilde{b}_i = \\exp\\!\\big(w_{u(i)}\\big),$$ where $u(i)$ is the $k$-mer centered at $i$ if in-bounds, and $w_{u(i)} = 0$ (hence $\\tilde{b}_i = 1$) when the $k$-mer cannot be extracted due to boundary conditions. To achieve comparability within a region of interest $R$ (defined below), normalize to unit mean within $R$: $$b_i = \\frac{\\tilde{b}_i}{\\frac{1}{|R|}\\sum_{j \\in R} \\tilde{b}_j}.$$\n- Under the Poisson factorization, division of the observed counts by the normalized bias yields a natural estimator proportional to accessibility: $$\\tilde{c}_i = \\frac{c_i}{b_i}.$$ For numerical stability, add a pseudo-count $\\epsilon$ to each corrected count prior to forming means: $$\\tilde{c}_i^{(\\epsilon)} = \\tilde{c}_i + \\epsilon,$$ with $\\epsilon  0$.\n- Define a motif center interval $C = \\{s, s+1, \\dots, e\\}$ using $0$-based indexing with integers $s, e$ satisfying $0 \\leq s \\leq e \\leq L-1$ and define flanking regions of width $m$ bases on each side (bounded within the sequence) by $F_{\\text{left}} = \\{\\max(0, s-m), \\dots, s-1\\}$ and $F_{\\text{right}} = \\{e+1, \\dots, \\min(L-1, e+m)\\}$, with the combined flanks set $F = F_{\\text{left}} \\cup F_{\\text{right}}$. The region of interest for bias normalization is $R = C \\cup F$.\n- The footprint score is defined conceptually as the ratio of the mean corrected insertion counts in flanks versus motif center, reflecting the expected depletion of insertions at a protected motif relative to its accessible surroundings. Compute the score as $$S = \\frac{\\frac{1}{|F|}\\sum_{i \\in F} \\tilde{c}_i^{(\\epsilon)}}{\\frac{1}{|C|}\\sum_{i \\in C} \\tilde{c}_i^{(\\epsilon)}}.$$\n\nProgram requirements:\n- Implement the above model and computation in a single program that takes no input and uses the test suite provided below, computing the footprint score $S$ for each case.\n- Use $0$-based indexing throughout.\n- Treat any missing $k$-mer weight as $0$.\n- Use $k = 3$ for all test cases.\n- Use the same $3$-mer weight dictionary for all test cases. The dictionary associates the following $3$-mers with their respective weights $w_u$ (all unspecified $3$-mers have $w_u = 0$):\n  - $w_{\\text{AAA}} = -0.4$\n  - $w_{\\text{TTT}} = -0.4$\n  - $w_{\\text{GGG}} = 0.6$\n  - $w_{\\text{CCC}} = 0.6$\n  - $w_{\\text{ACG}} = 0.3$\n  - $w_{\\text{CGT}} = 0.3$\n  - $w_{\\text{GCG}} = 0.5$\n  - $w_{\\text{CGC}} = 0.5$\n  - $w_{\\text{CCG}} = 0.4$\n  - $w_{\\text{GCC}} = 0.4$\n  - $w_{\\text{AGG}} = 0.3$\n  - $w_{\\text{GGA}} = 0.3$\n  - $w_{\\text{CAG}} = 0.2$\n  - $w_{\\text{GTT}} = -0.2$\n  - $w_{\\text{CAT}} = -0.2$\n  - $w_{\\text{ATC}} = -0.1$\n  - $w_{\\text{TAC}} = -0.1$\n  - $w_{\\text{CGG}} = 0.5$\n  - $w_{\\text{GGC}} = 0.5$\n- Use the pseudo-count $\\epsilon = 10^{-6}$.\n\nTest suite:\n- Case $1$:\n  - Sequence string: \"ACGTACGTACGGGCCCTTTACGTACGTAC\"\n  - Length $L = 30$\n  - Observed counts $c_i$ for $i = 0,1,\\dots,29$: $[4,5,4,5,3,4,5,8,9,7,10,9,2,1,3,2,1,2,8,7,9,10,8,4,5,4,5,3,4,5]$\n  - Motif center indices: $s = 12$, $e = 17$\n  - Flank width: $m = 5$\n- Case $2$:\n  - Sequence string: \"GGGACGTACGTACGTACGTACGTT\"\n  - Length $L = 24$\n  - Observed counts $c_i$ for $i = 0,1,\\dots,23$: $[7,8,7,1,2,1,1,8,7,9,5,4,6,5,4,5,6,5,4,5,4,6,5,4]$\n  - Motif center indices: $s = 3$, $e = 6$\n  - Flank width: $m = 3$\n- Case $3$:\n  - Sequence string: \"AAAAAGGGCCCACGTACGTAAAAA\"\n  - Length $L = 24$\n  - Observed counts $c_i$ for $i = 0,1,\\dots,23$: $[5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5]$\n  - Motif center indices: $s = 5$, $e = 10$\n  - Flank width: $m = 4$\n- Case $4$:\n  - Sequence string: \"ACGTACGTACGTACGTACGT\"\n  - Length $L = 20$\n  - Observed counts $c_i$ for $i = 0,1,\\dots,19$: $[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]$\n  - Motif center indices: $s = 8$, $e = 11$\n  - Flank width: $m = 3$\n\nOutput specification:\n- Compute the footprint score $S$ for each case in the order $1$ through $4$.\n- The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each score rendered as a decimal number rounded to $6$ places (e.g., $[1.234567,0.987654,2.000000,1.000000]$).", "solution": "The problem statement is assessed to be valid. It is scientifically grounded in the principles of bioinformatics and genomics, specifically in the analysis of chromatin accessibility data. The model presented, while a simplification of state-of-the-art methods, is logically consistent, well-posed, and based on established statistical (Poisson process) and biophysical (transposase bias, transcription factor footprinting) concepts. The problem is formulated with mathematical precision, providing all necessary data, parameters, and boundary conditions to compute a unique solution for each test case. It is free from ambiguity, subjectivity, and factual errors.\n\nThe task is to formalize and implement an algorithm to compute a chromatin accessibility footprint score, $S$, based on the provided model. The derivation proceeds through a sequence of mathematically defined steps.\n\nFirst, the relevant genomic regions are identified. Given a motif start position $s$, an end position $e$, a flank width $m$, and a total sequence length $L$, we define three sets of indices:\n1.  The motif center, $C = \\{i \\in \\mathbb{Z} \\mid s \\leq i \\leq e\\}$. The size of this region is $|C| = e - s + 1$.\n2.  The flanking regions, which consist of a left flank $F_{\\text{left}} = \\{i \\in \\mathbb{Z} \\mid \\max(0, s-m) \\leq i \\leq s-1\\}$ and a right flank $F_{\\text{right}} = \\{i \\in \\mathbb{Z} \\mid e+1 \\leq i \\leq \\min(L-1, e+m)\\}$. The combined flank set is $F = F_{\\text{left}} \\cup F_{\\text{right}}$. Its size is $|F| = |F_{\\text{left}}| + |F_{\\text{right}}|$.\n3.  The overall region of interest for bias normalization, $R = C \\cup F$.\n\nSecond, we calculate the sequence-dependent transposase bias at each position $i \\in R$. This is a two-stage process. We first compute an unnormalized bias, $\\tilde{b}_i$, for each position $i \\in R$. The bias is modeled using $k$-mers, where $k=3$ for this problem. For each position $i$, a $3$-mer, $u(i)$, is extracted from the sequence, centered at $i$. This corresponds to the substring from index $i-1$ to $i+1$. If $i-1  0$ or $i+1 \\ge L$, the $k$-mer is out-of-bounds. The unnormalized bias is given by:\n$$ \\tilde{b}_i = \\exp(w_{u(i)}) $$\nwhere $w_{u(i)}$ is the weight associated with the $k$-mer $u(i)$. If $u(i)$ is not in the provided weight dictionary or is out-of-bounds, its weight is taken to be $w_{u(i)}=0$, which implies $\\tilde{b}_i = \\exp(0) = 1$.\n\nNext, the unnormalized bias values are normalized to have a mean of $1$ across the region of interest $R$. The mean unnormalized bias is $\\bar{\\tilde{b}}_R = \\frac{1}{|R|}\\sum_{j \\in R} \\tilde{b}_j$. The normalized bias for each position $i \\in R$ is then:\n$$ b_i = \\frac{\\tilde{b}_i}{\\bar{\\tilde{b}}_R} $$\n\nThird, we correct the observed insertion counts, $c_i$, for this sequence-dependent bias. The model posits that the expected count is proportional to the product of accessibility and bias, $\\lambda_i \\propto a_i b_i$. By dividing the observed count $c_i$ by the normalized bias $b_i$, we obtain a corrected count, $\\tilde{c}_i = \\frac{c_i}{b_i}$, which serves as an estimator for the local accessibility (up to a scaling factor). For numerical stability, a small pseudo-count, $\\epsilon = 10^{-6}$, is added:\n$$ \\tilde{c}_i^{(\\epsilon)} = \\tilde{c}_i + \\epsilon = \\frac{c_i}{b_i} + \\epsilon $$\nThis calculation is performed for all positions $i \\in R$.\n\nFinally, the footprint score, $S$, is computed. The score is defined as the ratio of the average corrected count in the flanking regions to the average corrected count in the motif center. This ratio quantifies the relative depletion of insertions within the motif, which is the \"footprint\" left by a bound protein. The score is calculated as:\n$$ S = \\frac{\\frac{1}{|F|}\\sum_{i \\in F} \\tilde{c}_i^{(\\epsilon)}}{\\frac{1}{|C|}\\sum_{i \\in C} \\tilde{c}_i^{(\\epsilon)}} $$\nThe pseudo-count $\\epsilon  0$ ensures that the denominator is always positive, preventing division by zero even if all counts in the center region are $0$.\n\nThe implementation will systematically apply these four steps to each test case provided, yielding a numerical score $S$ that will be formatted as requested.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the chromatin accessibility footprint score for given test cases.\n    The implementation follows the mathematical model specified in the problem.\n    \"\"\"\n    # Define constants and parameters globally from the problem statement.\n    weights = {\n        'AAA': -0.4, 'TTT': -0.4, 'GGG': 0.6, 'CCC': 0.6,\n        'ACG': 0.3, 'CGT': 0.3, 'GCG': 0.5, 'CGC': 0.5,\n        'CCG': 0.4, 'GCC': 0.4, 'AGG': 0.3, 'GGA': 0.3,\n        'CAG': 0.2, 'GTT': -0.2, 'CAT': -0.2, 'ATC': -0.1,\n        'TAC': -0.1, 'CGG': 0.5, 'GGC': 0.5\n    }\n    epsilon = 1e-6\n    k = 3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"seq\": \"ACGTACGTACGGGCCCTTTACGTACGTAC\",\n            \"counts\": np.array([4, 5, 4, 5, 3, 4, 5, 8, 9, 7, 10, 9, 2, 1, 3, 2, 1, 2, 8, 7, 9, 10, 8, 4, 5, 4, 5, 3, 4, 5]),\n            \"s\": 12, \"e\": 17, \"m\": 5\n        },\n        {\n            \"seq\": \"GGGACGTACGTACGTACGTACGTT\",\n            \"counts\": np.array([7, 8, 7, 1, 2, 1, 1, 8, 7, 9, 5, 4, 6, 5, 4, 5, 6, 5, 4, 5, 4, 6, 5, 4]),\n            \"s\": 3, \"e\": 6, \"m\": 3\n        },\n        {\n            \"seq\": \"AAAAAGGGCCCACGTACGTAAAAA\",\n            \"counts\": np.array([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]),\n            \"s\": 5, \"e\": 10, \"m\": 4\n        },\n        {\n            \"seq\": \"ACGTACGTACGTACGTACGT\",\n            \"counts\": np.array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),\n            \"s\": 8, \"e\": 11, \"m\": 3\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        seq = case[\"seq\"]\n        counts = case[\"counts\"]\n        s, e, m = case[\"s\"], case[\"e\"], case[\"m\"]\n        L = len(seq)\n        \n        # Step 1: Define Regions\n        C_indices = list(range(s, e + 1))\n        F_left_indices = list(range(max(0, s - m), s))\n        F_right_indices = list(range(e + 1, min(L, e + m + 1)))\n        F_indices = F_left_indices + F_right_indices\n        R_indices = sorted(list(set(C_indices + F_indices)))\n        \n        # Step 2: Calculate Unnormalized Bias\n        b_tilde = {}\n        half_k = k // 2\n        for i in R_indices:\n            start, end = i - half_k, i + half_k + 1\n            if start = 0 and end = L:\n                kmer = seq[start:end]\n                weight = weights.get(kmer, 0.0)\n                b_tilde[i] = np.exp(weight)\n            else:\n                # Boundary condition: if k-mer cannot be extracted, weight is 0.\n                b_tilde[i] = 1.0  # np.exp(0)\n        \n        # Step 3: Normalize Bias\n        b_tilde_R_values = np.array([b_tilde[i] for i in R_indices])\n        if len(b_tilde_R_values) == 0:\n            mean_b_tilde_R = 1.0\n        else:\n            mean_b_tilde_R = np.mean(b_tilde_R_values)\n        \n        # Guard against division by zero, though exp()  0 means mean_b_tilde_R  0\n        if mean_b_tilde_R == 0: mean_b_tilde_R = 1.0\n\n        b = {i: b_tilde[i] / mean_b_tilde_R for i in R_indices}\n        \n        # Step 4-5: Calculate Corrected Counts and Final Score\n        \n        # Calculate mean corrected count for the Center region (C)\n        c_tilde_eps_C_values = []\n        for i in C_indices:\n            c_i = counts[i]\n            b_i = b[i]\n            # The problem definition implies b_i is never zero.\n            c_tilde_eps = (c_i / b_i) + epsilon\n            c_tilde_eps_C_values.append(c_tilde_eps)\n        \n        mean_C = np.mean(c_tilde_eps_C_values) if c_tilde_eps_C_values else epsilon\n        \n        # Calculate mean corrected count for the Flanking region (F)\n        c_tilde_eps_F_values = []\n        for i in F_indices:\n            c_i = counts[i]\n            b_i = b[i]\n            c_tilde_eps = (c_i / b_i) + epsilon\n            c_tilde_eps_F_values.append(c_tilde_eps)\n\n        mean_F = np.mean(c_tilde_eps_F_values) if c_tilde_eps_F_values else epsilon\n\n        # Compute the final footprint score S\n        # Denominator mean_C is guaranteed to be  0 because epsilon  0\n        score = mean_F / mean_C\n        results.append(score)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4314918"}]}