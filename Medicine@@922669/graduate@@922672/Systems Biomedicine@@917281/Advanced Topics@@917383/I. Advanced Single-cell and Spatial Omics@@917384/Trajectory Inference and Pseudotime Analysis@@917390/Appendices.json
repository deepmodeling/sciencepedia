{"hands_on_practices": [{"introduction": "Trajectory inference algorithms often depend on quantifying the dissimilarity between cells in a high-dimensional expression space. However, raw single-cell RNA sequencing counts are confounded by technical variability, such as differences in library size, which can obscure true biological relationships. This practice [@problem_id:4394817] provides a hands-on coding exercise to implement the median-of-ratios normalization method, a robust technique to correct for these technical artifacts, thereby ensuring that downstream distance calculations accurately reflect biological differences.", "problem": "You are given a set of count matrices that represent gene-by-cell single-cell RNA sequencing (scRNA-seq) expression counts. Let $X \\in \\mathbb{N}_0^{G \\times C}$ denote a nonnegative integer matrix with $G$ genes and $C$ cells. The goal is to compute cell-wise size factors using the median-of-ratios principle, normalize the counts by rescaling with these size factors, and quantify the impact of normalization on the pairwise Euclidean distances between cells. The intended application is as a preprocessing step for trajectory inference and pseudotime analysis, where cell-to-cell distances are used downstream.\n\nPrinciples and constraints:\n- The observed counts can be modeled as a multiplicative composition of a cell-specific library size factor and a gene-specific expression level. To remove the multiplicative cell-specific factor, use the median-of-ratios method, which is a robust estimator grounded in scale invariance.\n- For each gene $g \\in \\{1,\\dots,G\\}$, define its geometric mean across cells by taking the exponential of the arithmetic mean of logarithms over strictly positive counts only. If gene $g$ has no strictly positive counts across all cells, its geometric mean is defined to be $0$ and this gene is excluded from all subsequent ratio computations.\n- For each cell $j \\in \\{1,\\dots,C\\}$, compute ratios $r_{g j} = \\frac{X_{g j}}{\\mathrm{GM}_g}$ for all genes $g$ that satisfy $X_{g j} > 0$ and $\\mathrm{GM}_g > 0$, where $\\mathrm{GM}_g$ is the geometric mean of gene $g$. The size factor for cell $j$ is then the median of these ratios across the admissible genes for cell $j$. If a cell has no admissible genes under this rule, its size factor is defined to be $1$.\n- The normalized matrix is defined as $\\widetilde{X}_{g j} = \\frac{X_{g j}}{s_j}$, where $s_j$ is the size factor of cell $j$. Use standard Euclidean distance between columns to quantify pairwise cell-to-cell distances before and after normalization.\n- To provide a scalar summary of the distance change, compute the ratio $R = \\frac{\\lVert D_{\\text{post}} \\rVert_F}{\\lVert D_{\\text{pre}} \\rVert_F}$, where $D_{\\text{pre}}$ and $D_{\\text{post}}$ are the $C \\times C$ Euclidean distance matrices between the columns of $X$ and $\\widetilde{X}$, respectively, and $\\lVert \\cdot \\rVert_F$ is the Frobenius norm. If $\\lVert D_{\\text{pre}} \\rVert_F = 0$, define $R = 0$ if $\\lVert D_{\\text{post}} \\rVert_F = 0$ and $R = +\\infty$ otherwise.\n- To demonstrate the structural impact on neighborhood relations in the cell-to-cell graph, for the first cell (column index $0$), compute whether its nearest neighbor (excluding itself) changes identity after normalization. Use Euclidean distance, and in the case of ties select the smallest column index.\n\nTest suite:\nFor each of the following matrices, implement the above procedure and report the two quantities per case: the Frobenius norm ratio $R$ rounded to six decimal places as a floating-point number, and a boolean indicating whether the nearest neighbor of the first cell changed identity.\n\n- Case A (happy path: pure library size scaling across cells with strictly positive counts):\n$$\nX^{(A)} = \\begin{bmatrix}\n10 & 20 & 30 \\\\\n50 & 100 & 150 \\\\\n100 & 200 & 300\n\\end{bmatrix}.\n$$\n\n- Case B (mixture structure with different compositions and different library sizes, including zeros):\n$$\nX^{(B)} = \\begin{bmatrix}\n10 & 20 & 0 & 0 \\\\\n0 & 0 & 10 & 25 \\\\\n0 & 0 & 10 & 25 \\\\\n10 & 20 & 0 & 0\n\\end{bmatrix}.\n$$\n\n- Case C (edge case with entire-zero genes and proportional scaling among nonzero genes):\n$$\nX^{(C)} = \\begin{bmatrix}\n0 & 0 & 0 \\\\\n10 & 20 & 5 \\\\\n0 & 0 & 0 \\\\\n20 & 40 & 10 \\\\\n30 & 60 & 15\n\\end{bmatrix}.\n$$\n\nAngle units are not applicable. No physical units are involved. All outputs are unitless.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, for each case, first the ratio $R$ (rounded to six decimal places) and then the boolean for the nearest-neighbor identity change for the first cell. Therefore, the output must be of the form\n$[R_A,\\text{changed}_A,R_B,\\text{changed}_B,R_C,\\text{changed}_C]$\nwith the booleans printed as either $True$ or $False$.\n\nThe program must be self-contained and must not read any input or write any files. It must compute results for the three provided matrices exactly as specified and print the final list. All randomization is forbidden.", "solution": "The problem is valid as it is scientifically grounded in established bioinformatics principles, well-posed with a clear algorithmic definition, and objective in its formulation. We will proceed with a step-by-step solution for each test case.\n\nThe core of the problem is to implement the median-of-ratios normalization method and quantify its effects on the cell-to-cell Euclidean distance landscape. The procedure consists of three main parts:\n1.  Calculation of cell-specific size factors ($s_j$).\n2.  Normalization of the count matrix ($X$) to obtain $\\widetilde{X}$.\n3.  Computation of the distance-based metrics: the Frobenius norm ratio ($R$) and the nearest neighbor change for the first cell.\n\nLet $X$ be a $G \\times C$ matrix of gene expression counts, where $G$ is the number of genes and $C$ is the number of cells.\n\n\\textbf{Part 1: Size Factor Calculation}\n\nFirst, for each gene $g$, we compute a reference value, its geometric mean ($\\mathrm{GM}_g$) across all cells where it is expressed. The problem specifies that this is calculated only over strictly positive counts.\n$$\n\\mathrm{GM}_g = \\begin{cases} \\exp\\left(\\frac{1}{|\\{j | X_{gj} > 0\\}|} \\sum_{j: X_{gj} > 0} \\ln(X_{gj})\\right) & \\text{if } \\exists j: X_{gj} > 0 \\\\ 0 & \\text{otherwise} \\end{cases}\n$$\nGenes for which $\\mathrm{GM}_g = 0$ are excluded from the next step.\n\nSecond, for each cell $j$, we compute a set of ratios $r_{gj} = \\frac{X_{gj}}{\\mathrm{GM}_g}$ for all genes $g$ that are expressed in that cell ($X_{gj} > 0$) and have a non-zero geometric mean ($\\mathrm{GM}_g > 0$). The size factor $s_j$ for cell $j$ is the median of these ratios.\n$$\ns_j = \\mathrm{median}\\left( \\left\\{ \\frac{X_{gj}}{\\mathrm{GM}_g} \\mid g \\in \\{1, \\dots, G\\} \\text{ where } X_{gj} > 0 \\text{ and } \\mathrm{GM}_g > 0 \\right\\} \\right)\n$$\nIf for a given cell $j$ no such genes exist, its size factor is defined as $s_j = 1$.\n\n\\textbf{Part 2: Normalization}\n\nThe raw count matrix $X$ is then normalized by dividing each column (cell) by its corresponding size factor. The entry for gene $g$ and cell $j$ in the normalized matrix $\\widetilde{X}$ is:\n$$\n\\widetilde{X}_{gj} = \\frac{X_{gj}}{s_j}\n$$\n\n\\textbf{Part 3: Quantification of Impact}\n\nTo assess the effect of normalization, we first compute the $C \\times C$ matrices of pairwise Euclidean distances between cells (columns) before and after normalization, denoted $D_{\\text{pre}}$ and $D_{\\text{post}}$ respectively. The entry $(i, k)$ in a distance matrix is $d(c_i, c_k) = \\sqrt{\\sum_{g=1}^G (X_{gi} - X_{gk})^2}$.\n\nThe overall change in distances is summarized by the ratio $R$ of the Frobenius norms of the distance matrices:\n$$\nR = \\frac{\\lVert D_{\\text{post}} \\rVert_F}{\\lVert D_{\\text{pre}} \\rVert_F}\n$$\nwhere $\\lVert A \\rVert_F = \\sqrt{\\sum_{i=1}^C \\sum_{k=1}^C A_{ik}^2}$. Special handling for $\\lVert D_{\\text{pre}} \\rVert_F=0$ is defined but not encountered in the test cases.\n\nThe structural change in local neighborhoods is assessed by checking if the identity of the nearest neighbor of the first cell (column index $0$) changes after normalization. For a cell $i$, its nearest neighbor is $\\arg\\min_{k \\neq i} d(c_i, c_k)$, with ties broken by selecting the smallest index $k$.\n\n\\textbf{Case-by-Case Analysis}\n\n\\textbf{Case A:} $X^{(A)} = \\begin{bmatrix} 10 & 20 & 30 \\\\ 50 & 100 & 150 \\\\ 100 & 200 & 300 \\end{bmatrix}$\n\n1.  \\textbf{Geometric Means}: The columns are proportional ($c_2=2c_1, c_3=3c_1$). For any gene $g$ with counts $[k, 2k, 3k]$, its geometric mean is $\\mathrm{GM}_g = (k \\cdot 2k \\cdot 3k)^{1/3} = k \\cdot (6)^{1/3}$.\n    $\\mathrm{GM}_1 = 10 \\cdot 6^{1/3} \\approx 18.171$, $\\mathrm{GM}_2 = 50 \\cdot 6^{1/3} \\approx 90.856$, $\\mathrm{GM}_3 = 100 \\cdot 6^{1/3} \\approx 181.712$.\n2.  \\textbf{Size Factors}: The ratios for cell $j$ and gene $g$ are $r_{gj} = X_{gj} / \\mathrm{GM}_g$.\n    $s_1 = \\mathrm{median}(\\{\\frac{10}{\\mathrm{GM}_1}, \\frac{50}{\\mathrm{GM}_2}, \\frac{100}{\\mathrm{GM}_3}\\}) = \\mathrm{median}(\\{\\frac{1}{6^{1/3}}, \\frac{1}{6^{1/3}}, \\frac{1}{6^{1/3}}\\}) = \\frac{1}{6^{1/3}} \\approx 0.5503$.\n    $s_2 = \\mathrm{median}(\\{\\frac{20}{\\mathrm{GM}_1}, \\frac{100}{\\mathrm{GM}_2}, \\frac{200}{\\mathrm{GM}_3}\\}) = \\frac{2}{6^{1/3}} \\approx 1.1006$.\n    $s_3 = \\mathrm{median}(\\{\\frac{30}{\\mathrm{GM}_1}, \\frac{150}{\\mathrm{GM}_2}, \\frac{300}{\\mathrm{GM}_3}\\}) = \\frac{3}{6^{1/3}} \\approx 1.6509$.\n3.  \\textbf{Normalization}: After dividing each column $j$ by its size factor $s_j$, all columns become identical to the vector of geometric means $[\\mathrm{GM}_1, \\mathrm{GM}_2, \\mathrm{GM}_3]^T$.\n4.  \\textbf{Quantification}:\n    - Since all columns in $\\widetilde{X}^{(A)}$ are identical, all pairwise distances in $D_{\\text{post}}$ are $0$. Thus, $\\lVert D_{\\text{post}} \\rVert_F = 0$.\n    - The columns in $X^{(A)}$ are distinct, so $\\lVert D_{\\text{pre}} \\rVert_F > 0$.\n    - The ratio $R_A = 0 / \\lVert D_{\\text{pre}} \\rVert_F = 0.0$.\n    - \\textbf{Nearest Neighbor}: Before normalization, the distances from cell 1 to cells 2 and 3 are $\\lVert c_1-c_2 \\rVert_2 \\approx 112.25$ and $\\lVert c_1-c_3 \\rVert_2 \\approx 224.5$. The nearest neighbor is cell 2 (index 1). After normalization, the distances are $0$ to both cell 2 and cell 3. By the tie-breaking rule (smallest index), the nearest neighbor is cell 2 (index 1). The nearest neighbor does not change. Hence, $\\text{changed}_A = \\text{False}$.\n\n\\textbf{Case B:} $X^{(B)} = \\begin{bmatrix} 10 & 20 & 0 & 0 \\\\ 0 & 0 & 10 & 25 \\\\ 0 & 0 & 10 & 25 \\\\ 10 & 20 & 0 & 0 \\end{bmatrix}$\n\n1.  \\textbf{Geometric Means}:\n    $\\mathrm{GM}_1 = (10 \\cdot 20)^{1/2} = \\sqrt{200}$. $\\mathrm{GM}_2 = (10 \\cdot 25)^{1/2} = \\sqrt{250}$. $\\mathrm{GM}_3=\\mathrm{GM}_2, \\mathrm{GM}_4=\\mathrm{GM}_1$.\n2.  \\textbf{Size Factors}:\n    $s_1 = \\mathrm{median}(\\{\\frac{10}{\\sqrt{200}}, \\frac{10}{\\sqrt{200}}\\}) = \\frac{10}{\\sqrt{200}} \\approx 0.7071$.\n    $s_2 = \\mathrm{median}(\\{\\frac{20}{\\sqrt{200}}, \\frac{20}{\\sqrt{200}}\\}) = \\frac{20}{\\sqrt{200}} \\approx 1.4142$.\n    $s_3 = \\mathrm{median}(\\{\\frac{10}{\\sqrt{250}}, \\frac{10}{\\sqrt{250}}\\}) = \\frac{10}{\\sqrt{250}} \\approx 0.6325$.\n    $s_4 = \\mathrm{median}(\\{\\frac{25}{\\sqrt{250}}, \\frac{25}{\\sqrt{250}}\\}) = \\frac{25}{\\sqrt{250}} \\approx 1.5811$.\n3.  \\textbf{Normalization}: After normalization, $\\tilde{c}_1 = \\tilde{c}_2 = [\\sqrt{200}, 0, 0, \\sqrt{200}]^T$ and $\\tilde{c}_3 = \\tilde{c}_4 = [0, \\sqrt{250}, \\sqrt{250}, 0]^T$. The normalization reveals two distinct cell types.\n4.  \\textbf{Quantification}:\n    - We calculate $D_{\\text{pre}}$ and $D_{\\text{post}}$ and their Frobenius norms. $\\lVert D_{\\text{pre}} \\rVert_F = \\sqrt{11100}$ and $\\lVert D_{\\text{post}} \\rVert_F = \\sqrt{7200}$.\n    - The ratio $R_B = \\sqrt{7200/11100} \\approx 0.805387$.\n    - \\textbf{Nearest Neighbor}: Before normalization, distances from cell 1 are $d(c_1, c_2)=\\sqrt{200} \\approx 14.14$, $d(c_1, c_3)=20$, $d(c_1, c_4)=\\sqrt{1450} \\approx 38.08$. The nearest neighbor is cell 2 (index 1). After normalization, $d(\\tilde{c}_1, \\tilde{c}_2)=0$, $d(\\tilde{c}_1, \\tilde{c}_3)=30$. The nearest neighbor is cell 2 (index 1). The nearest neighbor does not change. Hence, $\\text{changed}_B = \\text{False}$.\n\n\\textbf{Case C:} $X^{(C)} = \\begin{bmatrix} 0 & 0 & 0 \\\\ 10 & 20 & 5 \\\\ 0 & 0 & 0 \\\\ 20 & 40 & 10 \\\\ 30 & 60 & 15 \\end{bmatrix}$\n\n1.  \\textbf{Geometric Means}: Genes 1 and 3 are all zeros, so $\\mathrm{GM}_1=0, \\mathrm{GM}_3=0$.\n    $\\mathrm{GM}_2 = (10 \\cdot 20 \\cdot 5)^{1/3} = 10$. $\\mathrm{GM}_4 = (20 \\cdot 40 \\cdot 10)^{1/3} = 20$. $\\mathrm{GM}_5 = (30 \\cdot 60 \\cdot 15)^{1/3} = 30$.\n2.  \\textbf{Size Factors}: The non-zero gene vectors are proportional: For gene $g_{nz}$, expression vector is $[k_{g_{nz}}, 2k_{g_{nz}}, 0.5k_{g_{nz}}]$.\n    $s_1 = \\mathrm{median}(\\{\\frac{10}{10}, \\frac{20}{20}, \\frac{30}{30}\\}) = 1$.\n    $s_2 = \\mathrm{median}(\\{\\frac{20}{10}, \\frac{40}{20}, \\frac{60}{30}\\}) = 2$.\n    $s_3 = \\mathrm{median}(\\{\\frac{5}{10}, \\frac{10}{20}, \\frac{15}{30}\\}) = 0.5$.\n3.  \\textbf{Normalization}: The original columns are $c_2 = 2c_1$ and $c_3 = 0.5c_1$. Normalization scales them by $1/s_j$: $\\tilde{c}_1 = c_1/1=c_1$, $\\tilde{c}_2 = c_2/2 = (2c_1)/2 = c_1$, $\\tilde{c}_3 = c_3/0.5 = (0.5c_1)/0.5 = c_1$. All normalized columns become identical.\n4.  \\textbf{Quantification}:\n    - Similar to Case A, all columns in $\\widetilde{X}^{(C)}$ are identical, so $D_{\\text{post}}$ is a zero matrix and $\\lVert D_{\\text{post}} \\rVert_F = 0$.\n    - The original columns are distinct, so $\\lVert D_{\\text{pre}} \\rVert_F > 0$.\n    - The ratio $R_C = 0 / \\lVert D_{\\text{pre}} \\rVert_F = 0.0$.\n    - \\textbf{Nearest Neighbor}: Before normalization, distances from cell 1 are $d(c_1, c_2) = \\lVert c_1 - 2c_1 \\rVert_2 = \\lVert c_1 \\rVert_2 = \\sqrt{1400}$ and $d(c_1, c_3) = \\lVert c_1 - 0.5c_1 \\rVert_2 = 0.5\\lVert c_1 \\rVert_2 = 0.5\\sqrt{1400}$. The nearest neighbor is cell 3 (index 2). After normalization, distances to cells 2 and 3 are both $0$. The tie-breaking rule selects the one with the smallest index, which is cell 2 (index 1). The nearest neighbor changes from cell 3 to cell 2. Hence, $\\text{changed}_C = \\text{True}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_size_factors(X):\n    \"\"\"\n    Computes cell-wise size factors using the median-of-ratios method.\n    \n    Args:\n        X (np.ndarray): A G x C matrix of non-negative integer counts.\n\n    Returns:\n        np.ndarray: A 1D array of size C containing the size factors.\n    \"\"\"\n    G, C = X.shape\n    \n    # Step 1: Compute geometric mean for each gene over positive counts.\n    gm_vec = np.zeros(G)\n    for g in range(G):\n        row = X[g, :]\n        positive_counts = row[row > 0]\n        if positive_counts.size > 0:\n            # Using exp(mean(log(x))) for geometric mean\n            gm_vec[g] = np.exp(np.mean(np.log(positive_counts)))\n        else:\n            # Per problem spec, GM is 0 if no positive counts exist.\n            gm_vec[g] = 0.0\n\n    # Step 2: Compute size factor for each cell.\n    s_vec = np.zeros(C)\n    for j in range(C):\n        ratios = []\n        for g in range(G):\n            # Ratios are computed for genes where count > 0 and GM > 0.\n            if X[g, j] > 0 and gm_vec[g] > 0:\n                ratios.append(X[g, j] / gm_vec[g])\n        \n        # Per problem spec, if no admissible genes, size factor is 1.\n        if len(ratios) == 0:\n            s_vec[j] = 1.0\n        else:\n            s_vec[j] = np.median(ratios)\n            \n    return s_vec\n\ndef calculate_distance_matrix(mat):\n    \"\"\"\n    Computes the pairwise Euclidean distance matrix between columns of a matrix.\n    \n    Args:\n        mat (np.ndarray): A G x C matrix.\n\n    Returns:\n        np.ndarray: A C x C distance matrix.\n    \"\"\"\n    _, C = mat.shape\n    dist_mat = np.zeros((C, C))\n    for i in range(C):\n        for j in range(i, C):\n            # Using numpy's norm function for Euclidean distance.\n            dist = np.linalg.norm(mat[:, i] - mat[:, j])\n            dist_mat[i, j] = dist\n            dist_mat[j, i] = dist\n    return dist_mat\n\ndef find_nearest_neighbor(dist_mat, cell_idx):\n    \"\"\"\n    Finds the nearest neighbor for a given cell, excluding the cell itself.\n    \n    Args:\n        dist_mat (np.ndarray): A C x C distance matrix.\n        cell_idx (int): The index of the cell of interest.\n\n    Returns:\n        int: The index of the nearest neighbor.\n    \"\"\"\n    dists = dist_mat[cell_idx, :].copy()\n    # Exclude self by setting its distance to infinity.\n    dists[cell_idx] = np.inf\n    # np.argmin finds the first occurrence of the minimum value,\n    # which corresponds to the smallest column index, satisfying the tie-breaking rule.\n    return np.argmin(dists)\n\ndef solve_for_matrix(X):\n    \"\"\"\n    Performs the full analysis for a single count matrix.\n    \n    Args:\n        X (np.ndarray): The input count matrix.\n        \n    Returns:\n        tuple: A tuple containing the Frobenius norm ratio (float) and \n               the nearest neighbor change status (bool).\n    \"\"\"\n    # Calculate pre-normalization distances\n    D_pre = calculate_distance_matrix(X)\n    \n    # Compute size factors and normalize\n    size_factors = calculate_size_factors(X)\n    # Broadcasting divides each column of X by the corresponding size factor.\n    X_tilde = X / size_factors\n    \n    # Calculate post-normalization distances\n    D_post = calculate_distance_matrix(X_tilde)\n    \n    # Compute the Frobenius norm ratio R\n    norm_pre = np.linalg.norm(D_pre, 'fro')\n    norm_post = np.linalg.norm(D_post, 'fro')\n    \n    if norm_pre == 0:\n        R = 0.0 if norm_post == 0 else np.inf\n    else:\n        R = norm_post / norm_pre\n        \n    # Determine if the nearest neighbor of the first cell changed\n    nn_pre = find_nearest_neighbor(D_pre, 0)\n    nn_post = find_nearest_neighbor(D_post, 0)\n    changed = (nn_pre != nn_post)\n    \n    return R, changed\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis on all test cases and print the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [10, 20, 30],\n            [50, 100, 150],\n            [100, 200, 300]\n        ], dtype=float),\n        np.array([\n            [10, 20, 0, 0],\n            [0, 0, 10, 25],\n            [0, 0, 10, 25],\n            [10, 20, 0, 0]\n        ], dtype=float),\n        np.array([\n            [0, 0, 0],\n            [10, 20, 5],\n            [0, 0, 0],\n            [20, 40, 10],\n            [30, 60, 15]\n        ], dtype=float)\n    ]\n\n    results = []\n    for X in test_cases:\n        R, changed = solve_for_matrix(X)\n        results.append(f\"{R:.6f}\")\n        results.append(str(changed))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "4394817"}, {"introduction": "Once expression data is properly normalized, the next challenge is to organize the individual cells or cell clusters into a coherent structure that represents the underlying biological process. This is often guided by the principle of parsimony, which posits that differentiation follows the most gradual path of transcriptional changes. In this exercise [@problem_id:4614364], you will apply this principle by constructing a Minimum Spanning Tree (MST) on a graph of cellular states, revealing the most economical, acyclic backbone of the developmental trajectory.", "problem": "A single-cell transcriptomics experiment yields six cluster centroids representing putative cellular states embedded in a two-dimensional principal component analysis (PCA) space. Distances between states are measured as standardized Euclidean distances in PCA space (dimensionless). Consider the undirected, weighted graph whose vertex set is the six states labeled $1,2,3,4,5,6$ and whose edge weights are the pairwise distances given by the symmetric matrix\n$$\nD \\;=\\; \\begin{pmatrix}\n0 & 1 & 2 & 3 & 4 & \\sqrt{5} \\\\\n1 & 0 & 1 & 2 & 3 & \\sqrt{2} \\\\\n2 & 1 & 0 & 1 & 2 & 1 \\\\\n3 & 2 & 1 & 0 & 1 & \\sqrt{2} \\\\\n4 & 3 & 2 & 1 & 0 & \\sqrt{5} \\\\\n\\sqrt{5} & \\sqrt{2} & 1 & \\sqrt{2} & \\sqrt{5} & 0\n\\end{pmatrix}.\n$$\nIn trajectory inference and pseudotime analysis of cellular progression, the Minimum Spanning Tree (MST) of a suitably constructed graph is often used to represent linear or branched developmental trajectories without cycles.\n\nStarting from fundamental definitions of graphs, distances, and spanning trees, determine the total weight (sum of edge weights) of the MST for the graph defined by $D$, and explain, using first principles, why the MST is frequently used to represent linear or branched trajectories without cycles in pseudotime analysis. Express the final total weight as an exact number with no rounding and provide no units.", "solution": "The problem requires the determination of the total weight of the Minimum Spanning Tree (MST) for a graph representing cellular states, and an explanation of the MST's utility in trajectory inference.\n\n### Step 1: Problem Validation\n\n**1.1. Extraction of Givens:**\n- The system consists of six cellular states, labeled as vertices $1, 2, 3, 4, 5, 6$.\n- The graph is undirected and weighted.\n- The weights, representing standardized Euclidean distances, are given by the symmetric matrix $D$:\n$$\nD \\;=\\; \\begin{pmatrix}\n0 & 1 & 2 & 3 & 4 & \\sqrt{5} \\\\\n1 & 0 & 1 & 2 & 3 & \\sqrt{2} \\\\\n2 & 1 & 0 & 1 & 2 & 1 \\\\\n3 & 2 & 1 & 0 & 1 & \\sqrt{2} \\\\\n4 & 3 & 2 & 1 & 0 & \\sqrt{5} \\\\\n\\sqrt{5} & \\sqrt{2} & 1 & \\sqrt{2} & \\sqrt{5} & 0\n\\end{pmatrix}.\n$$\n- The task is to find the total weight of the MST of the graph defined by $D$.\n- An additional explanatory task is to justify, from first principles, the use of the MST in pseudotime analysis for representing cellular trajectories.\n\n**1.2. Validation against Criteria:**\n- **Scientifically Grounded:** The problem is firmly rooted in bioinformatics, specifically the analysis of single-cell transcriptomics data. The use of PCA for dimensionality reduction, Euclidean distance to measure dissimilarity between cell states, and MSTs for trajectory inference are standard and well-established methods (e.g., as implemented in the Monocle algorithm). The setup is a simplified but conceptually accurate representation of a real-world scientific problem.\n- **Well-Posed:** The problem provides a complete, weighted, undirected graph with $V=6$ vertices. Since all off-diagonal entries in the distance matrix $D$ are positive, the graph is connected. For any connected, undirected graph with non-negative edge weights, an MST is guaranteed to exist. While the presence of repeated edge weights (e.g., multiple edges with weight $1$) implies that the MST itself may not be unique, a fundamental theorem of graph theory states that all possible MSTs for a given graph will have the same total weight. Therefore, the question asking for the \"total weight of the MST\" is well-posed and has a unique answer.\n- **Objective:** The problem is stated using precise mathematical and scientific terminology. It is free from subjective or ambiguous language.\n\n**1.3. Verdict:**\nThe problem is valid as it is scientifically grounded, well-posed, and objective.\n\n### Step 2: Solution\n\n#### Part A: Calculation of the MST Total Weight\n\nTo find the Minimum Spanning Tree (MST), we can employ a standard greedy algorithm, such as Kruskal's algorithm or Prim's algorithm. We will use Kruskal's algorithm, which involves iteratively adding the edge with the smallest weight that does not form a cycle with already-selected edges.\n\nThe graph has $V=6$ vertices. Any spanning tree for this graph must contain exactly $V-1 = 5$ edges.\n\n1.  **List all unique edges and their weights in ascending order.** The edges are denoted by pairs of vertices $(i, j)$ with weight $D_{ij}$. We consider the upper triangle of the matrix $D$ to avoid duplicates.\n    -   Weight $1$: Edges $(1, 2)$, $(2, 3)$, $(3, 4)$, $(4, 5)$, $(3, 6)$.\n    -   Weight $\\sqrt{2} \\approx 1.414$: Edges $(2, 6)$, $(4, 6)$.\n    -   Weight $2$: Edges $(1, 3)$, $(2, 4)$, $(3, 5)$.\n    -   Weight $\\sqrt{5} \\approx 2.236$: Edges $(1, 6)$, $(5, 6)$.\n    -   Weight $3$: Edges $(1, 4)$, $(2, 5)$.\n    -   Weight $4$: Edge $(1, 5)$.\n\n2.  **Execute Kruskal's algorithm:** We build the MST by adding edges in increasing order of weight, ensuring no cycles are formed. We start with a forest of $6$ disjoint sets, one for each vertex: $\\{1\\}, \\{2\\}, \\{3\\}, \\{4\\}, \\{5\\}, \\{6\\}$.\n\n    -   **Consider edges of weight $1$**:\n        a.  Select edge $(1, 2)$. It connects two disjoint sets. No cycle.\n            -   MST edges: $\\{(1, 2)\\}$.\n            -   Sets: $\\{\\{1, 2\\}, \\{3\\}, \\{4\\}, \\{5\\}, \\{6\\}\\}$.\n            -   Current total weight: $1$.\n        b.  Select edge $(2, 3)$. It connects vertex $3$ to the set $\\{1, 2\\}$. No cycle.\n            -   MST edges: $\\{(1, 2), (2, 3)\\}$.\n            -   Sets: $\\{\\{1, 2, 3\\}, \\{4\\}, \\{5\\}, \\{6\\}\\}$.\n            -   Current total weight: $1 + 1 = 2$.\n        c.  Select edge $(3, 4)$. It connects vertex $4$ to the set $\\{1, 2, 3\\}$. No cycle.\n            -   MST edges: $\\{(1, 2), (2, 3), (3, 4)\\}$.\n            -   Sets: $\\{\\{1, 2, 3, 4\\}, \\{5\\}, \\{6\\}\\}$.\n            -   Current total weight: $2 + 1 = 3$.\n        d.  Select edge $(4, 5)$. It connects vertex $5$ to the set $\\{1, 2, 3, 4\\}$. No cycle.\n            -   MST edges: $\\{(1, 2), (2, 3), (3, 4), (4, 5)\\}$.\n            -   Sets: $\\{\\{1, 2, 3, 4, 5\\}, \\{6\\}\\}$.\n            -   Current total weight: $3 + 1 = 4$.\n        e.  Select edge $(3, 6)$. It connects vertex $6$ to the set $\\{1, 2, 3, 4, 5\\}$. No cycle.\n            -   MST edges: $\\{(1, 2), (2, 3), (3, 4), (4, 5), (3, 6)\\}$.\n            -   Sets: $\\{\\{1, 2, 3, 4, 5, 6\\}\\}$.\n            -   Current total weight: $4 + 1 = 5$.\n\n3.  **Termination:** We have now selected $5$ edges, and all $6$ vertices are connected in a single component. The algorithm terminates. The resulting structure is a spanning tree. Because we followed the greedy choice property of Kruskal's algorithm, this is an MST.\n\nThe total weight of the MST is the sum of the weights of the selected edges:\n$$ W_{MST} = 1 + 1 + 1 + 1 + 1 = 5 $$\n\n#### Part B: Justification of MST in Trajectory Inference\n\nThe use of an MST to model cellular trajectories is based on a set of logical assumptions that translate biological hypotheses into a graph-theoretic framework.\n\n1.  **Representation of States:** In single-cell analysis, cells are characterized by high-dimensional gene expression vectors. Groups of similar cells are clustered into \"states\" (the vertices of our graph). The distance between two state centroids (e.g., Euclidean distance in PCA space) is a measure of their transcriptomic dissimilarity. A small distance implies high similarity.\n\n2.  **Principle of Parsimony (Occam's Razor):** A biological process, such as cell differentiation, is assumed to proceed through a series of gradual changes. A direct transition between two very dissimilar states is considered less probable than a sequence of transitions through intermediate, more similar states. Mathematically, this translates to finding a path structure that minimizes the total dissimilarity. We seek the \"path of least resistance\" connecting the cellular states.\n\n3.  **Connectivity and Acyclicity of Trajectories:**\n    -   **Connectivity:** The model assumes that all observed cell states are part of a single, coherent biological process. Therefore, the structure connecting them must be a **connected graph**. To connect all $V$ vertices, we need a **spanning subgraph**.\n    -   **Acyclicity:** Simple developmental or differentiation processes are typically not cyclical; a cell progresses forward along a path (e.g., from stem cell to neuron) rather than looping back to a progenitor state. This dictates that the underlying graph structure should be a **tree** (an undirected, connected, acyclic graph), which naturally represents linear or branching progressions.\n\n4.  **Synthesis via the MST:** The Minimum Spanning Tree is the mathematical object that uniquely satisfies these criteria.\n    -   By definition, it is a **spanning** subgraph, so it connects all vertices (satisfying connectivity).\n    -   By definition, it is a **tree**, so it is acyclic (modeling non-cyclical progression).\n    -   Among all possible spanning trees, the MST is the one with the **minimum possible total edge weight**. This directly implements the principle of parsimony, finding the set of connections between states that has the lowest overall dissimilarity.\n\nIn conclusion, the MST provides the most parsimonious (lowest total distance) backbone that connects all cellular states without forming cycles. This structure serves as a robust hypothesis for the underlying topology of the biological process, upon which a \"pseudotime\" can be calculated by ordering cells based on their distance from a designated root state (e.g., a known progenitor cell type) along the tree branches.", "answer": "$$\\boxed{5}$$", "id": "4614364"}, {"introduction": "While graph-based structures like the MST provide a static map of a biological process, they do not inherently specify the direction or dynamics of cell state transitions. The concept of RNA velocity offers a powerful solution by modeling the kinetics of mRNA splicing to infer a cell's future transcriptional state. This exercise [@problem_id:4614291] guides you through the first principles of this model, allowing you to calculate a cell's velocity vector and interpret its instantaneous direction of movement along the trajectory.", "problem": "A common approach to quantify instantaneous transcriptional state changes in single-cell ribonucleic acid sequencing (scRNA-seq) trajectory inference is to model pre-messenger ribonucleic acid (pre-mRNA) splicing and mature messenger ribonucleic acid (mRNA) degradation with first-order mass-action kinetics. Consider a single cell profiled for $2$ genes, where the observed unspliced count vector is $\\mathbf{u}=(5,4)$ and the spliced count vector is $\\mathbf{s}=(10,8)$. Assume a linear two-stage kinetic model in which unspliced molecules are produced at a constant transcription rate and converted to spliced molecules at a first-order splicing rate, while spliced molecules are degraded at a first-order degradation rate. Let the splicing rate be $\\beta=0.2$ and the degradation rate be $\\gamma=0.1$, both assumed constant over the short time window corresponding to the local pseudotime neighborhood of the cell. Using only the mass-action principle for first-order reactions and the definitions of unspliced and spliced species, derive from first principles the expression for the instantaneous rate of change of the spliced counts (the spliced RNA velocity) per gene and then compute the $2$-dimensional velocity vector for this cell. Based on the sign of each component, interpret the instantaneous direction of state change for each gene along pseudotime in the $2$-gene state space. No rounding is required. Express your final velocity vector as a row vector.", "solution": "The problem is valid. It is scientifically grounded in the principles of mass-action kinetics as applied to gene expression, a cornerstone of the RNA velocity model in bioinformatics. It is well-posed, providing all necessary data—unspliced counts $\\mathbf{u}$, spliced counts $\\mathbf{s}$, splicing rate $\\beta$, and degradation rate $\\gamma$—to derive and compute the requested velocity vector. The terminology is precise and objective.\n\nThe central task is to derive the expression for the instantaneous rate of change of spliced messenger ribonucleic acid (mRNA) counts, denoted as $s$, for a single gene. This quantity is also known as the spliced RNA velocity. The derivation is based on a two-stage kinetic model of gene expression governed by first-order mass-action kinetics.\n\nLet $u(t)$ be the number of unspliced pre-mRNA molecules and $s(t)$ be the number of spliced mRNA molecules for a given gene at time $t$. The model involves two key processes affecting the population of spliced mRNA:\n\n1.  **Production of Spliced mRNA**: Unspliced molecules are converted into spliced molecules. This is the splicing process. The problem states this is a first-order reaction with rate constant $\\beta$.\n    The reaction can be schematized as:\n    $$\n    u \\xrightarrow{\\beta} s\n    $$\n    According to the principle of mass-action for a first-order reaction, the rate of this process is directly proportional to the amount of the reactant, which is the unspliced mRNA count $u$. Therefore, the rate of production of $s$ is given by:\n    $$\n    \\text{Rate of Production} = \\beta u\n    $$\n\n2.  **Degradation of Spliced mRNA**: Spliced molecules are degraded and removed from the system. The problem states this is a first-order reaction with rate constant $\\gamma$.\n    The reaction can be schematized as:\n    $$\n    s \\xrightarrow{\\gamma} \\emptyset\n    $$\n    where $\\emptyset$ represents the degraded state. According to the principle of mass-action, the rate of this process is directly proportional to the amount of the reactant, which is the spliced mRNA count $s$. Therefore, the rate of loss of $s$ is given by:\n    $$\n    \\text{Rate of Loss} = \\gamma s\n    $$\n\nThe instantaneous rate of change of the spliced counts, $\\frac{ds}{dt}$, is the net result of these two processes: the rate of production minus the rate of loss. This gives the fundamental RNA velocity equation for spliced mRNA:\n$$\n\\frac{ds}{dt} = \\beta u - \\gamma s\n$$\nThis derivation from first principles provides the expression for the spliced RNA velocity for a single gene.\n\nThe problem requires us to compute the $2$-dimensional velocity vector for a cell with $2$ genes. We can apply the derived formula to each gene independently. Let the unspliced count vector be $\\mathbf{u} = (u_1, u_2)$ and the spliced count vector be $\\mathbf{s} = (s_1, s_2)$. The velocity vector $\\mathbf{v}$ is then given by $\\mathbf{v} = \\frac{d\\mathbf{s}}{dt} = (\\frac{ds_1}{dt}, \\frac{ds_2}{dt})$.\n\nThe given values are:\n- Unspliced count vector: $\\mathbf{u} = (u_1, u_2) = (5, 4)$\n- Spliced count vector: $\\mathbf{s} = (s_1, s_2) = (10, 8)$\n- Splicing rate constant: $\\beta = 0.2$\n- Degradation rate constant: $\\gamma = 0.1$\n\nWe can now compute the two components of the velocity vector:\n\nFor the first gene ($i=1$):\n$$\nv_1 = \\frac{ds_1}{dt} = \\beta u_1 - \\gamma s_1\n$$\nSubstituting the numerical values:\n$$\nv_1 = (0.2)(5) - (0.1)(10) = 1.0 - 1.0 = 0\n$$\n\nFor the second gene ($i=2$):\n$$\nv_2 = \\frac{ds_2}{dt} = \\beta u_2 - \\gamma s_2\n$$\nSubstituting the numerical values:\n$$\nv_2 = (0.2)(4) - (0.1)(8) = 0.8 - 0.8 = 0\n$$\n\nThus, the $2$-dimensional velocity vector for this cell is $\\mathbf{v} = (0, 0)$.\n\nThe final part of the task is to interpret the sign of each component.\n- The velocity component for gene $1$ is $v_1 = 0$. A velocity of zero indicates that the rate of production of spliced mRNA from its precursor ($\\beta u_1 = 1.0$) is exactly balanced by the rate of its degradation ($\\gamma s_1 = 1.0$). This means the gene is at a steady state (or a fixed point) in its expression dynamics. There is no instantaneous change in the amount of spliced mRNA.\n- The velocity component for gene $2$ is $v_2 = 0$. Similarly, this indicates that the production of spliced mRNA for gene $2$ ($\\beta u_2 = 0.8$) is perfectly balanced by its degradation ($\\gamma s_2 = 0.8$). This gene is also at a steady state.\n\nSince both components of the velocity vector are zero, the cell's transcriptional state, as described by the abundances of these two spliced mRNAs, is not changing at this instant in pseudotime. In the context of trajectory inference, this cell is located at a fixed point of the dynamical system, which could represent a stable cell state, an unstable progenitor state, or a transient state at the peak or trough of a dynamic process.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & 0\n\\end{pmatrix}\n}\n$$", "id": "4614291"}]}