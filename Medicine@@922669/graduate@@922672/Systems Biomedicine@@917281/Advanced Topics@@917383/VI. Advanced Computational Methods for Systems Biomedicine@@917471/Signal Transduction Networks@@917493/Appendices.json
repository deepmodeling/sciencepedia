{"hands_on_practices": [{"introduction": "Understanding how cells sense their environment begins with the fundamental interaction between a ligand and its receptor. This first exercise guides you through the derivation of the steady-state fractional occupancy, a cornerstone equation that describes this binding process. By applying the law of mass action, you will build the mathematical foundation for all dose-response relationships and gain a quantitative understanding of the dissociation constant, $K_d$ [@problem_id:4385985].", "problem": "In a signal transduction network characteristic of systems biomedicine, consider a single, well-mixed compartment containing a receptor species $R$ and a soluble ligand species $L$ that reversibly form a complex $RL$ via the reaction $R + L \\rightleftharpoons RL$. Let $k_{\\text{on}}$ denote the bimolecular association rate constant and $k_{\\text{off}}$ denote the unimolecular dissociation rate constant. The system is closed with respect to these three species, and no other reactions occur. All variables are concentrations, denoted $[R](t)$, $[L](t)$, and $[RL](t)$ for time $t$. Define the total receptor concentration $R_T$ and the total ligand concentration $L_T$ by stoichiometric conservation.\n\nStarting only from the fundamental principle of mass-action kinetics and the stoichiometry of the reaction, perform the following:\n\n- Write down the ordinary differential equations (ODEs) for $[R](t)$, $[L](t)$, and $[RL](t)$.\n- State the conservation laws that follow from the reaction stoichiometry in this closed system.\n- Define the fractional occupancy of the receptor by the ligand as $\\theta(t) := \\frac{[RL](t)}{R_T}$. Assuming the system reaches a steady state (all time derivatives equal to zero), and introducing the dissociation constant $K_d := \\frac{k_{\\text{off}}}{k_{\\text{on}}}$, derive a closed-form expression for the steady-state fractional occupancy $\\theta$ exclusively in terms of the free ligand concentration $[L]$ and $K_d$.\n\nYour final answer must be a single analytical expression for the steady-state $\\theta$. No numerical approximation or rounding is required, and no physical units should be included in the final expression.", "solution": "The problem statement is first validated against the required criteria.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Reaction:** $R + L \\rightleftharpoons RL$\n- **Rate Constants:** $k_{\\text{on}}$ (bimolecular association), $k_{\\text{off}}$ (unimolecular dissociation)\n- **System:** Closed with respect to $R$, $L$, and $RL$. No other reactions occur.\n- **Variables:** Concentrations $[R](t)$, $[L](t)$, $[RL](t)$ at time $t$.\n- **Conserved Quantities:** Total receptor concentration $R_T$ and total ligand concentration $L_T$ are defined by stoichiometric conservation.\n- **Definition:** Fractional occupancy of the receptor, $\\theta(t) := \\frac{[RL](t)}{R_T}$.\n- **Condition:** The system reaches a steady state, meaning all time derivatives are equal to zero.\n- **Definition:** Dissociation constant, $K_d := \\frac{k_{\\text{off}}}{k_{\\text{on}}}$.\n- **Objective:** Derive a closed-form expression for the steady-state fractional occupancy $\\theta$ as a function of the free ligand concentration $[L]$ and $K_d$.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem describes a canonical receptor-ligand binding process governed by the law of mass action. This is a fundamental and widely accepted model in biochemistry, pharmacology, and systems biology. It is scientifically sound.\n- **Well-Posed:** The problem provides all necessary definitions, constants, and conditions (steady state) to uniquely determine the requested relationship. The derivation leads to a single, stable, and meaningful analytical expression.\n- **Objective:** The language is formal, precise, and devoid of any subjective or ambiguous terminology.\n\nThe problem does not exhibit any of the listed flaws (e.g., scientific unsoundness, incompleteness, contradiction, or infeasibility). It is a standard, well-posed problem in chemical kinetics and systems biology.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be provided.\n\n### Solution\n\nThe solution proceeds by first establishing the kinetic model, then applying the steady-state condition, and finally rearranging the resulting algebraic equations to find the desired expression for fractional occupancy.\n\n**1. Ordinary Differential Equations (ODEs) from Mass-Action Kinetics**\n\nThe reaction is $R + L \\rightleftharpoons RL$. According to the principle of mass-action kinetics, the rate of the forward reaction (association) is proportional to the product of the concentrations of the reactants, $R$ and $L$. The rate of the reverse reaction (dissociation) is proportional to the concentration of the reactant, $RL$.\n\n- Rate of formation of $RL$: $v_{\\text{forward}} = k_{\\text{on}}[R](t)[L](t)$\n- Rate of breakdown of $RL$: $v_{\\text{reverse}} = k_{\\text{off}}[RL](t)$\n\nThe net rate of change for each species is the sum of the rates of the reactions in which it is produced minus the sum of the rates of the reactions in which it is consumed. This yields the following system of ODEs:\n\n- For the free receptor, $[R](t)$:\n$$ \\frac{d[R]}{dt} = -k_{\\text{on}}[R](t)[L](t) + k_{\\text{off}}[RL](t) $$\n\n- For the free ligand, $[L](t)$:\n$$ \\frac{d[L]}{dt} = -k_{\\text{on}}[R](t)[L](t) + k_{\\text{off}}[RL](t) $$\n\n- For the receptor-ligand complex, $[RL](t)$:\n$$ \\frac{d[RL]}{dt} = k_{\\text{on}}[R](t)[L](t) - k_{\\text{off}}[RL](t) $$\n\n**2. Conservation Laws**\n\nThe problem states that the system is closed with respect to the three species. This means that the total number of receptor molecules (both free and bound) and the total number of ligand molecules (both free and bound) are constant over time. These conservation laws are expressed as:\n\n- **Total Receptor Concentration ($R_T$):** The total concentration of receptors is the sum of the free receptor concentration and the complex concentration.\n$$ R_T = [R](t) + [RL](t) $$\n\n- **Total Ligand Concentration ($L_T$):** The total concentration of ligand is the sum of the free ligand concentration and the complex concentration.\n$$ L_T = [L](t) + [RL](t) $$\n\nThese quantities are constant, i.e., $\\frac{dR_T}{dt} = 0$ and $\\frac{dL_T}{dt} = 0$, which can be verified by summing the corresponding ODEs. For example, $\\frac{dR_T}{dt} = \\frac{d[R]}{dt} + \\frac{d[RL]}{dt} = (-k_{\\text{on}}[R][L] + k_{\\text{off}}[RL]) + (k_{\\text{on}}[R][L] - k_{\\text{off}}[RL]) = 0$.\n\n**3. Steady-State Fractional Occupancy**\n\nAt steady state, the concentrations of all species are constant. Therefore, all time derivatives are equal to zero. We can use any of the three ODEs. Using the equation for $[RL](t)$ is most direct:\n$$ \\frac{d[RL]}{dt} = 0 $$\nAt steady state, we can drop the time dependence notation $(t)$.\n$$ k_{\\text{on}}[R][L] - k_{\\text{off}}[RL] = 0 $$\n$$ k_{\\text{on}}[R][L] = k_{\\text{off}}[RL] $$\n\nThe problem defines the dissociation constant as $K_d = \\frac{k_{\\text{off}}}{k_{\\text{on}}}$. We can rearrange the steady-state equation to feature this constant:\n$$ [R][L] = \\frac{k_{\\text{off}}}{k_{\\text{on}}}[RL] $$\n$$ [R][L] = K_d[RL] $$\n\nThe goal is to find an expression for the fractional occupancy, $\\theta = \\frac{[RL]}{R_T}$, in terms of $[L]$ and $K_d$. To do this, we must eliminate $[R]$ and $R_T$ from the equation.\n\nFrom the conservation law for the receptor, we have $R_T = [R] + [RL]$. This allows us to express the free receptor concentration $[R]$ in terms of $R_T$ and $[RL]$:\n$$ [R] = R_T - [RL] $$\n\nSubstitute this expression for $[R]$ into the steady-state equation, $K_d[RL] = [R][L]$:\n$$ K_d[RL] = (R_T - [RL])[L] $$\n\nNow, we solve this algebraic equation for the ratio $\\frac{[RL]}{R_T}$.\n$$ K_d[RL] = R_T[L] - [RL][L] $$\nGather all terms containing $[RL]$ on one side:\n$$ K_d[RL] + [RL][L] = R_T[L] $$\nFactor out $[RL]$:\n$$ [RL](K_d + [L]) = R_T[L] $$\nFinally, divide both sides by $R_T$ and by $(K_d + [L])$ to isolate the fractional occupancy $\\theta = \\frac{[RL]}{R_T}$:\n$$ \\frac{[RL]}{R_T} = \\frac{[L]}{K_d + [L]} $$\nTherefore, the steady-state fractional occupancy $\\theta$ is given by:\n$$ \\theta = \\frac{[L]}{K_d + [L]} $$\nThis expression gives the fraction of total receptors that are bound to ligand at steady state, as a function of the free ligand concentration $[L]$ and the dissociation constant $K_d$.", "answer": "$$ \\boxed{ \\frac{[L]}{K_d + [L]} } $$", "id": "4385985"}, {"introduction": "Signaling networks must do more than just turn on; they must also regulate their output over time, a process often achieved through feedback. This computational practice explores adaptation, a key dynamic behavior generated by negative feedback loops, using a model of the NF-$\\kappa$B pathway. By numerically simulating the system's response to different stimuli, you will learn how network architecture dictates temporal dynamics and develop essential skills in computational systems biology [@problem_id:4385905].", "problem": "Consider a reduced dynamical model of Nuclear Factor kappa-light-chain-enhancer of activated B cells (NF-$\\kappa$B) signal transduction controlled by Inhibitor of Nuclear Factor kappa B kinase (IKK) activity and feedback via the inhibitor of NF-$\\kappa$B (I$\\kappa$B). The nuclear NF-$\\kappa$B fraction, denoted by $N(t)$, and the normalized I$\\kappa$B level, denoted by $I(t)$, evolve according to ordinary differential equations derived from mass-action kinetics and saturating transport:\n\n$$\n\\frac{dN}{dt} \\;=\\; k_{\\mathrm{in}} \\, \\frac{u(t)}{K_u + u(t)} \\, \\bigl(1 - N\\bigr) \\;-\\; k_{\\mathrm{out}} \\, I \\, N,\n$$\n\n$$\n\\frac{dI}{dt} \\;=\\; k_{s0} \\;+\\; k_{sN} \\, N \\;-\\; \\bigl(k_{d0} \\;+\\; k_{d\\mathrm{IKK}} \\, u(t)\\bigr) \\, I.\n$$\n\nThe input $u(t)$ represents IKK activity in arbitrary units; $k_{\\mathrm{in}}$ and $k_{\\mathrm{out}}$ have units of $\\mathrm{min}^{-1}$; $K_u$ is dimensionless; $k_{s0}$ and $k_{sN}$ have units of $\\mathrm{min}^{-1}$; $k_{d0}$ and $k_{d\\mathrm{IKK}}$ have units of $\\mathrm{min}^{-1}$. Time $t$ is measured in minutes. The initial conditions are $N(0)=0$ and $I(0)=k_{s0}/k_{d0}$.\n\nThe task is to analyze the conditions under which NF-$\\kappa$B exhibits adaptation versus sustained activation by altering IKK input waveforms and parameter values. Adaptation is defined here as the presence of a transient increase in $N(t)$ above baseline followed by a return of $N(t)$ close to its baseline level for long times. Specifically, classify a simulation as adaptive if the following conditions hold simultaneously:\n\n- There exists a time $t_{\\mathrm{peak}}$ such that $N(t_{\\mathrm{peak}}) - N_{\\mathrm{base}} \\ge \\delta_{\\mathrm{peak}}$, with $N_{\\mathrm{base}}$ denoting the baseline nuclear level at $u(t)=0$ and $\\delta_{\\mathrm{peak}}$ a fixed threshold.\n- The long-time average of $N(t)$ over the last window of width $W$ minutes, denoted $\\overline{N}_{\\mathrm{end}}$, satisfies $\\overline{N}_{\\mathrm{end}} - N_{\\mathrm{base}} \\le \\varepsilon_{\\mathrm{end}}$.\n- The standard deviation of $N(t)$ over the same last window, denoted $\\sigma_{\\mathrm{end}}$, satisfies $\\sigma_{\\mathrm{end}} \\le \\varepsilon_{\\mathrm{var}}$.\n\nUse $N_{\\mathrm{base}}=0$ implied by $u(t)=0$, choose $\\delta_{\\mathrm{peak}}=0.15$, $\\varepsilon_{\\mathrm{end}}=0.08$, $\\varepsilon_{\\mathrm{var}}=0.03$, and $W=10$. For sinusoidal inputs, the angle argument is in radians. All simulations should be run for a total duration $T_{\\mathrm{end}}$ specified per test.\n\nImplement a program that numerically integrates the system to produce a boolean classification for each test case indicating whether adaptation occurs (boolean `True`) or not (boolean `False`). Use a robust ordinary differential equation solver and a uniform time grid for evaluation. Ensure scientific realism by adhering to the given model and units.\n\nTest Suite: Simulate the following parameterized cases, each with $k_{\\mathrm{in}}=0.6$, $K_u=0.5$, $k_{s0}=0.02$, $k_{d0}=0.05$, $k_{d\\mathrm{IKK}}=0.6$, and the specified $k_{\\mathrm{out}}$, $k_{sN}$, input waveform $u(t)$, and $T_{\\mathrm{end}}$.\n\n- Case $\\mathbf{1}$ (step input, strong feedback expected to adapt): $u(t)=u_{\\mathrm{amp}}$ for all $t\\ge 0$, with $u_{\\mathrm{amp}}=1.0$, $k_{\\mathrm{out}}=20.0$, $k_{sN}=2.0$, $T_{\\mathrm{end}}=240$.\n- Case $\\mathbf{2}$ (step input, weak feedback sustained): $u(t)=u_{\\mathrm{amp}}$ for all $t\\ge 0$, with $u_{\\mathrm{amp}}=1.0$, $k_{\\mathrm{out}}=0.5$, $k_{sN}=0.0$, $T_{\\mathrm{end}}=240$.\n- Case $\\mathbf{3}$ (finite pulse, returns to baseline): $u(t)=u_{\\mathrm{amp}}$ for $0\\le t < T_p$ and $u(t)=0$ for $t\\ge T_p$, with $u_{\\mathrm{amp}}=1.0$, $T_p=30$, $k_{\\mathrm{out}}=5.0$, $k_{sN}=1.0$, $T_{\\mathrm{end}}=240$.\n- Case $\\mathbf{4}$ (oscillation with nonzero direct current offset, radians): $u(t)=u_{\\mathrm{dc}} + u_{\\mathrm{amp}}\\sin\\bigl(2\\pi f t\\bigr)$ with $u_{\\mathrm{dc}}=0.4$, $u_{\\mathrm{amp}}=0.4$, $f=0.02$ (in $\\mathrm{min}^{-1}$), $k_{\\mathrm{out}}=5.0$, $k_{sN}=1.0$, $T_{\\mathrm{end}}=240$.\n- Case $\\mathbf{5}$ (very small step, sub-threshold response): $u(t)=u_{\\mathrm{amp}}$ for all $t\\ge 0$, with $u_{\\mathrm{amp}}=0.05$, $k_{\\mathrm{out}}=20.0$, $k_{sN}=2.0$, $T_{\\mathrm{end}}=240$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., `[result1,result2,result3,result4,result5]`), where each `result` is the boolean classification for the corresponding case.", "solution": "The problem is valid. It is scientifically grounded, well-posed, and objective. The model is a standard simplified representation of the NF-$\\kappa$B signaling network, based on established principles of biochemical kinetics. The parameters, initial conditions, and evaluation criteria are fully specified, constituting a well-defined initial value problem and a subsequent classification task. There are no contradictions, ambiguities, or factual inaccuracies in the problem statement.\n\nThe dynamical evolution of the system is described by a pair of coupled ordinary differential equations (ODEs) for the nuclear NF-$\\kappa$B fraction, $N(t)$, and the normalized I$\\kappa$B level, $I(t)$:\n$$\n\\frac{dN}{dt} = k_{\\mathrm{in}} \\, \\frac{u(t)}{K_u + u(t)} \\, \\bigl(1 - N\\bigr) - k_{\\mathrm{out}} \\, I \\, N\n$$\n$$\n\\frac{dI}{dt} = k_{s0} + k_{sN} \\, N - \\bigl(k_{d0} + k_{d\\mathrm{IKK}} \\, u(t)\\bigr) \\, I\n$$\nThe state of the system at any time $t$ can be represented by a vector $\\mathbf{y}(t) = [N(t), I(t)]^T$. The initial conditions are given as $N(0)=0$ and $I(0)=k_{s0}/k_{d0}$. The problem requires solving this initial value problem for five distinct parameter sets and input waveforms $u(t)$.\n\nThe solution methodology involves numerically integrating this system of ODEs and then analyzing the trajectory of $N(t)$ to classify the system's response as adaptive or non-adaptive.\n\nFirst, we will implement a function that computes the rate of change of the state vector, $\\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y})$. The components of this function are the right-hand sides of the given ODEs. This function will be the core of our numerical simulation.\n\nFor the numerical integration, we will use a robust, adaptive-step-size ODE solver. The `solve_ivp` function from the `scipy.integrate` library is an appropriate choice, as it provides several high-quality algorithms. We select the `LSODA` method, which is well-suited for problems that may exhibit stiffness, a common characteristic in biochemical networks with processes occurring on different timescales. The simulation for each case will be run over the time interval $[0, T_{\\mathrm{end}}]$ with the solution evaluated on a fine, uniform time grid to ensure accurate analysis. A time step of $\\Delta t = 0.1$ minutes is chosen, yielding a sufficient number of points for calculating statistics.\n\nAfter obtaining the numerical solution for $N(t)$ for each test case, we apply the three specific criteria for adaptation:\n\n1.  **Peak Condition**: The response must exhibit a significant transient increase. The maximum value of the nuclear NF-$\\kappa$B fraction, $N_{\\mathrm{peak}} = \\max_{t} N(t)$, must exceed a threshold $\\delta_{\\mathrm{peak}}$ above the baseline level $N_{\\mathrm{base}}$. The condition is:\n    $$\n    N_{\\mathrm{peak}} - N_{\\mathrm{base}} \\ge \\delta_{\\mathrm{peak}}\n    $$\n    With the given values, this becomes $N_{\\mathrm{peak}} \\ge 0.15$.\n\n2.  **Long-Time Average Condition**: The system must return to a level near its baseline. The time-average of $N(t)$ over the final $W=10$ minutes of the simulation, denoted $\\overline{N}_{\\mathrm{end}}$, must not exceed a tolerance $\\varepsilon_{\\mathrm{end}}$ above the baseline. The condition is:\n    $$\n    \\overline{N}_{\\mathrm{end}} - N_{\\mathrm{base}} \\le \\varepsilon_{\\mathrm{end}}\n    $$\n    With the given values, this becomes $\\overline{N}_{\\mathrm{end}} \\le 0.08$.\n\n3.  **Long-Time Variation Condition**: The system must settle to a steady or near-steady state. The standard deviation of $N(t)$ over the same final $W=10$ minute window, denoted $\\sigma_{\\mathrm{end}}$, must be below a tolerance $\\varepsilon_{\\mathrm{var}}$. This ensures the absence of significant long-term oscillations. The condition is:\n    $$\n    \\sigma_{\\mathrm{end}} \\le \\varepsilon_{\\mathrm{var}}\n    $$\n    With the given values, this becomes $\\sigma_{\\mathrm{end}} \\le 0.03$.\n\nA response is classified as adaptive (boolean `True`) if and only if all three of these conditions are met simultaneously. Otherwise, it is classified as non-adaptive (boolean `False`).\n\nThis procedure will be applied to each of the five test cases defined in the problem. Each case provides a specific set of parameters ($k_{\\mathrm{out}}$, $k_{sN}$), a total simulation time ($T_{\\mathrm{end}}$), and an input function $u(t)$, while sharing common parameter values for $k_{\\mathrm{in}}$, $K_u$, $k_{s0}$, $k_{d0}$, and $k_{d\\mathrm{IKK}}$. The final output will be a list of boolean values corresponding to the classification of each case.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically solves the NF-kappaB ODE model and classifies the response\n    as adaptive or non-adaptive for a suite of test cases.\n    \"\"\"\n\n    # Common model parameters\n    k_in = 0.6  # 1/min\n    K_u = 0.5  # dimensionless\n    k_s0 = 0.02  # 1/min\n    k_d0 = 0.05  # 1/min\n    k_dIKK = 0.6  # 1/min\n\n    # Adaptation classification criteria\n    delta_peak = 0.15  # dimensionless\n    epsilon_end = 0.08  # dimensionless\n    epsilon_var = 0.03  # dimensionless\n    W = 10.0  # min\n    N_base = 0.0  # dimensionless\n\n    # Input functions u(t) for different cases\n    u_funcs = {\n        'step': lambda t, u_amp: u_amp,\n        'pulse': lambda t, u_amp, T_p: u_amp if t < T_p else 0.0,\n        'sine': lambda t, u_dc, u_amp, f: u_dc + u_amp * np.sin(2 * np.pi * f * t)\n    }\n\n    # Test case parameters\n    test_cases = [\n        # Case 1: step input, strong feedback\n        {'k_out': 20.0, 'k_sN': 2.0, 'T_end': 240, 'u_key': 'step', \n         'u_params': {'u_amp': 1.0}},\n        # Case 2: step input, weak feedback\n        {'k_out': 0.5, 'k_sN': 0.0, 'T_end': 240, 'u_key': 'step', \n         'u_params': {'u_amp': 1.0}},\n        # Case 3: finite pulse\n        {'k_out': 5.0, 'k_sN': 1.0, 'T_end': 240, 'u_key': 'pulse', \n         'u_params': {'u_amp': 1.0, 'T_p': 30.0}},\n        # Case 4: oscillation with DC offset\n        {'k_out': 5.0, 'k_sN': 1.0, 'T_end': 240, 'u_key': 'sine', \n         'u_params': {'u_dc': 0.4, 'u_amp': 0.4, 'f': 0.02}},\n        # Case 5: very small step input\n        {'k_out': 20.0, 'k_sN': 2.0, 'T_end': 240, 'u_key': 'step', \n         'u_params': {'u_amp': 0.05}},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Unpack parameters for the current case\n        k_out = case['k_out']\n        k_sN = case['k_sN']\n        T_end = case['T_end']\n        \n        # Create the specific input function u(t) for the case\n        u_func = lambda t: u_funcs[case['u_key']](t, **case['u_params'])\n\n        # Define the system of ODEs\n        def model(t, y, k_out_p, k_sN_p):\n            N, I = y\n            u_val = u_func(t)\n            \n            # Handle u(t) = 0 to avoid division by zero though K_u > 0\n            if u_val <= 0:\n                in_term = 0\n            else:\n                in_term = k_in * (u_val / (K_u + u_val)) * (1 - N)\n                \n            dN_dt = in_term - k_out_p * I * N\n            dI_dt = k_s0 + k_sN_p * N - (k_d0 + k_dIKK * u_val) * I\n            return [dN_dt, dI_dt]\n\n        # Initial conditions\n        N0 = 0.0\n        I0 = k_s0 / k_d0\n        y0 = [N0, I0]\n\n        # Time points for evaluation\n        t_span = [0, T_end]\n        t_eval = np.linspace(0, T_end, int(T_end * 10) + 1)\n\n        # Solve the ODE system\n        sol = solve_ivp(\n            fun=model,\n            t_span=t_span,\n            y0=y0,\n            method='LSODA',\n            t_eval=t_eval,\n            args=(k_out, k_sN)\n        )\n        \n        N_t = sol.y[0]\n\n        # 1. Peak condition\n        peak_val = np.max(N_t)\n        peak_cond = (peak_val - N_base) >= delta_peak\n\n        # 2. Long-time average condition\n        final_window_mask = t_eval >= (T_end - W)\n        N_end_window = N_t[final_window_mask]\n        N_end_avg = np.mean(N_end_window)\n        avg_cond = (N_end_avg - N_base) <= epsilon_end\n\n        # 3. Long-time variation condition\n        N_end_std = np.std(N_end_window)\n        var_cond = N_end_std <= epsilon_var\n\n        # Classify as adaptive if all conditions are met\n        is_adaptive = peak_cond and avg_cond and var_cond\n        results.append(is_adaptive)\n\n    # Print the final list of boolean results\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4385905"}, {"introduction": "In contrast to the homeostatic role of negative feedback, positive feedback can generate decisive, all-or-none cellular responses. This practice delves into bistability, a phenomenon where a system can exist in two distinct stable states, creating a biological switch. Through a computational bifurcation analysis of a MAPK cascade model, you will identify the parameter regimes that permit this switch-like behavior and explore its importance in cellular decision-making [@problem_id:4385929].", "problem": "Consider a reduced, dimensionless two-variable dynamical model of the Rapidly Accelerated Fibrosarcoma kinase (Raf) and Extracellular signal-Regulated Kinase (ERK) activation within a Mitogen-Activated Protein Kinase cascade, where positive feedback from ERK to Raf is included. Let $R(t) \\in [0,1]$ denote the fraction of active Raf and $E(t) \\in [0,1]$ denote the fraction of active ERK. The input stimulus is a dimensionless scalar $S \\ge 0$. The governing ordinary differential equations are derived from mass-action activation and first-order deactivation:\n\n$$\\frac{dR}{dt} = k_R S f(E) (1 - R) - d_R R,$$\n$$\\frac{dE}{dt} = k_E R (1 - E) - d_E E,$$\n\nwhere $k_R > 0$ and $k_E > 0$ are activation rate constants, $d_R > 0$ and $d_E > 0$ are deactivation rate constants, and the positive feedback from ERK to Raf is captured by the Hill-type function\n\n$$f(E) = 1 + \\alpha \\frac{E^n}{K^n + E^n},$$\n\nwith feedback strength $\\alpha \\ge 0$, Hill coefficient $n \\ge 1$, and half-saturation constant $K > 0$. All quantities in this problem are dimensionless.\n\nA fixed point $(R^\\ast, E^\\ast)$ satisfies $\\frac{dR}{dt} = 0$ and $\\frac{dE}{dt} = 0$. By algebraic manipulation, the ERK nullcline implies\n\n$$E^\\ast = \\frac{k_E R^\\ast}{k_E R^\\ast + d_E},$$\n\nand the Raf nullcline implies\n\n$$R^\\ast = \\frac{k_R S f(E^\\ast)}{k_R S f(E^\\ast) + d_R}.$$\n\nA fixed point is locally asymptotically stable if the real parts of the eigenvalues of the Jacobian matrix of the right-hand side evaluated at $(R^\\ast, E^\\ast)$ are strictly negative. Bistability is defined here as the existence, at a fixed value of $S$, of at least two distinct locally asymptotically stable fixed points.\n\nYour task is to write a complete program that, for each parameter set in the test suite below, performs a qualitative bifurcation analysis with respect to the input stimulus $S$ by scanning a range of $S$ values. For each $S$ in a specified grid, your program must:\n- Find all fixed points by solving the scalar implicit equation\n\n$$E = \\frac{k_E}{k_E \\left( \\frac{k_R S f(E)}{k_R S f(E) + d_R} \\right) + d_E} \\cdot \\left( \\frac{k_R S f(E)}{k_R S f(E) + d_R} \\right),$$\n\nwhich is equivalent to $E = g(h(E))$ with $h(E) = \\frac{k_R S f(E)}{k_R S f(E) + d_R}$ and $g(R) = \\frac{k_E R}{k_E R + d_E}$. Implement numerical root finding over $E \\in [0,1]$ to locate all fixed points.\n- Classify the stability of each fixed point by computing the Jacobian\n\n$$J(R,E) = \\begin{pmatrix}\n-k_R S f(E) - d_R & k_R S f'(E) (1 - R) \\\\\nk_E (1 - E) & -k_E R - d_E\n\\end{pmatrix},$$\n\nwhere\n\n$$f'(E) = \\alpha \\cdot \\frac{n K^n E^{n-1}}{(K^n + E^n)^2}.$$\n\n- Determine whether there exist at least two stable fixed points for that $S$.\n\nAggregate over the $S$ scan to report, for each parameter set, whether bistability occurs for any $S$ in the scan. If bistability occurs, also report the minimum and maximum $S$ values (from the scanned grid) at which bistability is observed. If bistability does not occur for any $S$ in the scan, report $0.0$ for both the minimum and maximum $S$.\n\nTest suite:\n- Case $1$ (strong positive feedback, cooperative): $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 30.0$, $n = 4$, scan $S \\in [0.0, 4.0]$ with $161$ evenly spaced points.\n- Case $2$ (no feedback): $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 0.0$, $n = 4$, scan $S \\in [0.0, 4.0]$ with $161$ evenly spaced points.\n- Case $3$ (feedback without cooperativity): $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 30.0$, $n = 1$, scan $S \\in [0.0, 4.0]$ with $161$ evenly spaced points.\n- Case $4$ (high half-saturation threshold): $k_R = 6.0$, $d_R = 1.0$, $k_E = 6.0$, $d_E = 1.0$, $K = 5.0$, $\\alpha = 30.0$, $n = 4$, scan $S \\in [0.0, 5.0]$ with $201$ evenly spaced points.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry corresponds to a test case and is itself a list of the form `[bistable, s_min, s_max]`. Here, `bistable` is a boolean indicating whether bistability was observed for any $S$ in the scan, and `s_min` and `s_max` are floats indicating the minimum and maximum $S$ values in the scan grid at which bistability was detected (or $0.0$ and $0.0$ if none). For example, the output format must be like `[[True, 0.75, 1.25],[False, 0.0, 0.0],...]`.", "solution": "## Problem Validation\n\n### Step 1: Extract Givens\n\nThe problem provides a two-variable ordinary differential equation (ODE) model for a signaling cascade:\n- **State variables**: $R(t)$, the fraction of active Raf, and $E(t)$, the fraction of active ERK. Both are in the range $[0, 1]$.\n- **Input stimulus**: $S \\ge 0$.\n- **Governing ODEs**:\n$$\n\\frac{dR}{dt} = k_R S f(E) (1 - R) - d_R R\n$$\n$$\n\\frac{dE}{dt} = k_E R (1 - E) - d_E E\n$$\n- **Parameters**: Activation rates $k_R > 0$, $k_E > 0$; deactivation rates $d_R > 0$, $d_E > 0$.\n- **Feedback function**: A Hill-type function representing positive feedback from ERK to Raf:\n$$\nf(E) = 1 + \\alpha \\frac{E^n}{K^n + E^n}\n$$\n- **Feedback parameters**: Feedback strength $\\alpha \\ge 0$, Hill coefficient $n \\ge 1$, and half-saturation constant $K > 0$.\n- **Fixed Point Conditions**: At a fixed point $(R^\\ast, E^\\ast)$, $\\frac{dR}{dt} = 0$ and $\\frac{dE}{dt} = 0$. This leads to the nullcline equations:\n$$\nE^\\ast = \\frac{k_E R^\\ast}{k_E R^\\ast + d_E}\n$$\n$$\nR^\\ast = \\frac{k_R S f(E^\\ast)}{k_R S f(E^\\ast) + d_R}\n$$\n- **Scalar Equation for Fixed Points**: Combining the nullclines gives a single implicit equation for $E^\\ast$ (denoted as $E$ for simplicity in the problem):\n$$\nE = \\frac{k_E}{k_E \\left( \\frac{k_R S f(E)}{k_R S f(E) + d_R} \\right) + d_E} \\cdot \\left( \\frac{k_R S f(E)}{k_R S f(E) + d_R} \\right)\n$$\n- **Stability Analysis**: A fixed point is locally asymptotically stable if the real parts of the eigenvalues of the Jacobian matrix are strictly negative.\n- **Jacobian Matrix**:\n$$\nJ(R,E) = \\begin{pmatrix} -k_R S f(E) - d_R & k_R S f'(E) (1 - R) \\\\ k_E (1 - E) & -k_E R - d_E \\end{pmatrix}\n$$\n- **Derivative of the Feedback Function**:\n$$\nf'(E) = \\alpha \\cdot \\frac{n K^n E^{n-1}}{(K^n + E^n)^2}\n$$\n- **Definition of Bistability**: The existence of at least two distinct locally asymptotically stable fixed points for a given value of $S$.\n- **Task**: For several parameter sets, scan $S$ over a specified grid, find all fixed points, analyze their stability, and determine if bistability occurs. If it does, report the minimum and maximum $S$ values in the scanned grid where it is observed.\n- **Test Suite**:\n    - **Case 1**: $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 30.0$, $n = 4$, scan $S \\in [0.0, 4.0]$ with $161$ points.\n    - **Case 2**: $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 0.0$, $n = 4$, scan $S \\in [0.0, 4.0]$ with $161$ points.\n    - **Case 3**: $k_R = 10.0$, $d_R = 1.0$, $k_E = 10.0$, $d_E = 1.0$, $K = 0.2$, $\\alpha = 30.0$, $n = 1$, scan $S \\in [0.0, 4.0]$ with $161$ points.\n    - **Case 4**: $k_R = 6.0$, $d_R = 1.0$, $k_E = 6.0$, $d_E = 1.0$, $K = 5.0$, $\\alpha = 30.0$, $n = 4$, scan $S \\in [0.0, 5.0]$ with $201$ points.\n\n### Step 2: Validate Using Extracted Givens\n\n1.  **Scientifically Grounded**: The problem describes a simplified model of the MAPK signaling cascade, a cornerstone of cell biology. The use of mass-action kinetics and Hill functions for modeling is standard practice in systems biology and biochemical network theory. The model is a well-established motif for studying bistability. The problem is scientifically grounded.\n2.  **Well-Posed**: The problem is well-posed. It provides the complete mathematical model (ODEs), explicit equations for fixed point analysis, a clear definition of stability based on the Jacobian, and a well-defined task (bifurcation analysis) with concrete parameter sets and numerical ranges. The objective is to find a numerical solution, for which a clear path is outlined.\n3.  **Objective**: The language is purely mathematical and descriptive, with no subjective or ambiguous terms.\n4.  **Incomplete or Contradictory Setup**: The setup is complete and consistent. All necessary parameters and functions are defined. The derivations provided for the nullclines, the scalar fixed-point equation, and the Jacobian matrix are arithmetically correct and consistent with the initial ODEs.\n5.  **Unrealistic or Infeasible**: The parameters are dimensionless, and their values are within a range commonly used for theoretical studies of such systems. There are no physical or scientific impossibilities. The problem acknowledges the dimensionless nature of the quantities.\n6.  **Ill-Posed or Poorly Structured**: The task is clearly structured: scan a parameter, and for each value, find roots, then analyze stability. This is a standard procedure in dynamical systems analysis. While finding all roots of a nonlinear equation can be numerically challenging, the problem specifies a bounded interval $E \\in [0,1]$ which makes the search tractable.\n7.  **Pseudo-Profound, Trivial, or Tautological**: The problem is a substantive exercise in computational systems biology. It requires the implementation of a numerical pipeline involving root-finding and eigenvalue analysis to study a non-trivial emergent property (bistability) of a nonlinear dynamical system. It is neither trivial nor tautological.\n\n### Step 3: Verdict and Action\nThe problem is valid. It is a well-defined, scientifically-grounded, and computationally tractable problem in the field of systems biology. The solution can proceed.\n\n## Principle-Based Design\n\nThe core of the problem is to perform a numerical bifurcation analysis of a two-dimensional dynamical system with respect to an input parameter $S$. For each parameter set provided, the program will execute the following sequence of steps:\n\n1.  **Parameter Iteration**: The main loop iterates through each of the four test cases, unpacking the specified parameters ($k_R, d_R, k_E, d_E, K, \\alpha, n$) and the scan range for the stimulus $S$.\n\n2.  **Stimulus Scan**: For each test case, a second loop iterates over a grid of $S$ values, generated using `numpy.linspace` as specified.\n\n3.  **Fixed Point Identification**: For each value of $S$, the program must find all fixed points $(R^\\ast, E^\\ast)$ of the system. The problem formulation insightfully reduces this to finding the roots of a single-variable, nonlinear equation for the active ERK fraction, $E^\\ast \\in [0, 1]$:\n    $$\n    \\text{residual}(E) = E - g(h(E; S)) = 0,\n    $$\n    where $h(E; S) = \\frac{k_R S f(E)}{k_R S f(E) + d_R}$ and $g(R) = \\frac{k_E R}{k_E R + d_E}$. To numerically find all roots in the valid range $E \\in [0, 1]$, a robust strategy is employed:\n    - The interval $[0, 1]$ is finely discretized into a search grid.\n    - The `residual` function is evaluated at each point on this grid.\n    - The program searches for pairs of adjacent grid points where the `residual` function changes sign, as this indicates a root lies between them.\n    - For each such interval, the `scipy.optimize.brentq` routine, a highly reliable bracketing-based root-finder, is used to precisely locate the root.\n    - To avoid missing roots that may touch the x-axis without crossing (e.g., at local extrema), the grid points themselves are checked to see if the residual is close to zero.\n    - A list of unique roots is maintained to avoid duplicates from adjacent search intervals. Once all roots $E^\\ast$ are found, the corresponding Raf activity $R^\\ast$ is calculated using the nullcline equation $R^\\ast = h(E^\\ast; S)$.\n\n4.  **Stability Classification**: For each identified fixed point $(R^\\ast, E^\\ast)$, its local stability must be determined. This is governed by the eigenvalues of the system's Jacobian matrix $J(R^\\ast, E^\\ast)$.\n    - The elements of the $2 \\times 2$ Jacobian matrix are computed using the provided analytical formulas. This involves calculating $f(E^\\ast)$ and its derivative $f'(E^\\ast)$.\n    - The `numpy.linalg.eigvals` function is used to compute the two eigenvalues of the Jacobian.\n    - According to dynamical systems theory, a fixed point is locally asymptotically stable if and only if the real parts of all eigenvalues are strictly negative. The program checks this condition.\n\n5.  **Bistability Detection**: After classifying all fixed points for a given $S$, the number of stable fixed points is counted. If this count is two or greater, the system is bistable at that value of $S$. The value of $S$ is then recorded in a list of bistable stimuli.\n\n6.  **Result Aggregation and Reporting**: After the scan over all $S$ values is complete for a given test case, the program analyzes the list of bistable stimuli.\n    - If the list is empty, no bistability was found. The result is recorded as `[False, 0.0, 0.0]`.\n    - If the list is non-empty, bistability was observed. The result is recorded as `[True, min(S_{bistable}), max(S_{bistable})]`, where `min` and `max` are the minimum and maximum values from the scanned grid at which bistability was detected.\n\nFinally, the results for all test cases are compiled and printed to standard output in the precisely specified string format. This systematic approach ensures a correct and rigorous analysis of the system's behavior as required.", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the MAPK cascade bistability problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (strong positive feedback, cooperative)\n        {'kR': 10.0, 'dR': 1.0, 'kE': 10.0, 'dE': 1.0, 'K': 0.2, 'alpha': 30.0, 'n': 4, 's_range': (0.0, 4.0), 's_points': 161},\n        # Case 2 (no feedback)\n        {'kR': 10.0, 'dR': 1.0, 'kE': 10.0, 'dE': 1.0, 'K': 0.2, 'alpha': 0.0, 'n': 4, 's_range': (0.0, 4.0), 's_points': 161},\n        # Case 3 (feedback without cooperativity)\n        {'kR': 10.0, 'dR': 1.0, 'kE': 10.0, 'dE': 1.0, 'K': 0.2, 'alpha': 30.0, 'n': 1, 's_range': (0.0, 4.0), 's_points': 161},\n        # Case 4 (high half-saturation threshold)\n        {'kR': 6.0, 'dR': 1.0, 'kE': 6.0, 'dE': 1.0, 'K': 5.0, 'alpha': 30.0, 'n': 4, 's_range': (0.0, 5.0), 's_points': 201},\n    ]\n\n    # Helper functions defined based on the problem statement\n    def f(E, alpha, n, K):\n        E_term = E**n\n        return 1.0 + alpha * E_term / (K**n + E_term)\n\n    def f_prime(E, alpha, n, K):\n        if E == 0.0:\n            if n == 1:\n                return alpha * n * K**n / ((K**n)**2)\n            else: # For n > 1\n                return 0.0\n        \n        Kn = K**n\n        En_minus_1 = E**(n - 1)\n        numerator = alpha * n * Kn * En_minus_1\n        denominator = (Kn + E**n)**2\n        return numerator / denominator\n\n    def solve_for_case(params):\n        \"\"\"\n        Performs bifurcation analysis for a single parameter set.\n        \"\"\"\n        kR, dR, kE, dE, K, alpha, n = params['kR'], params['dR'], params['kE'], params['dE'], params['K'], params['alpha'], params['n']\n        s_range, s_points = params['s_range'], params['s_points']\n\n        S_grid = np.linspace(s_range[0], s_range[1], s_points)\n        bistable_S_values = []\n\n        for S in S_grid:\n            def residual(E):\n                if E < 0.0 or E > 1.0:\n                    return 1e9 # Penalize going out of bounds\n                f_E = f(E, alpha, n, K)\n                if kR * S * f_E + dR == 0.0: # Avoid division by zero\n                    R_star = 0.0\n                else:\n                    R_star = (kR * S * f_E) / (kR * S * f_E + dR)\n                \n                if kE * R_star + dE == 0.0:\n                    E_g = 0.0\n                else:\n                    E_g = (kE * R_star) / (kE * R_star + dE)\n                return E - E_g\n\n            # Find all roots of residual(E) = 0 in [0, 1]\n            roots = []\n            e_search_grid = np.linspace(0.0, 1.0, 1001)\n            y_vals = np.array([residual(e) for e in e_search_grid])\n            \n            # Find roots by bracketing where sign changes\n            for i in range(len(e_search_grid) - 1):\n                if np.sign(y_vals[i]) != np.sign(y_vals[i+1]):\n                    try:\n                        root = brentq(residual, e_search_grid[i], e_search_grid[i+1])\n                        if all(not np.isclose(root, r_found) for r_found in roots):\n                            roots.append(root)\n                    except (ValueError, RuntimeError):\n                        pass\n\n            # Check for roots on the grid points themselves\n            for i, y in enumerate(y_vals):\n                if np.isclose(y, 0):\n                    root = e_search_grid[i]\n                    if all(not np.isclose(root, r_found) for r_found in roots):\n                        roots.append(root)\n            \n            stable_fps_count = 0\n            for E_star in roots:\n                if not (0.0 <= E_star <= 1.0):\n                    continue\n\n                f_E_star = f(E_star, alpha, n, K)\n                R_star = (kR * S * f_E_star) / (kR * S * f_E_star + dR)\n                \n                # Check stability via Jacobian eigenvalues\n                fp_prime_E = f_prime(E_star, alpha, n, K)\n                \n                J11 = -kR * S * f_E_star - dR\n                J12 = kR * S * fp_prime_E * (1.0 - R_star)\n                J21 = kE * (1.0 - E_star)\n                J22 = -kE * R_star - dE\n                \n                jacobian = np.array([[J11, J12], [J21, J22]])\n                eigenvalues = np.linalg.eigvals(jacobian)\n                \n                if np.all(np.real(eigenvalues) < 0.0):\n                    stable_fps_count += 1\n            \n            if stable_fps_count >= 2:\n                bistable_S_values.append(S)\n\n        if not bistable_S_values:\n            return [False, 0.0, 0.0]\n        else:\n            return [True, min(bistable_S_values), max(bistable_S_values)]\n\n    # Main execution logic\n    results = []\n    for case_params in test_cases:\n        result = solve_for_case(case_params)\n        results.append(result)\n\n    # Format output string to be exactly as required, e.g., [[True,0.75,1.25],[False,0.0,0.0]]\n    formatted_results = []\n    for res in results:\n        b_val, s_min_val, s_max_val = res\n        # Round floats for consistent output, format without spaces\n        formatted_results.append(f\"[{str(b_val)},{s_min_val:.10g},{s_max_val:.10g}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4385929"}]}