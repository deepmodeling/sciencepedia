{"hands_on_practices": [{"introduction": "This exercise focuses on the very first step of sporulation: the decision to commit. We will use the principles of chemical kinetics to model the accumulation of the master regulator, phosphorylated Spo0A ($Spo0A \\sim P$). By deriving the time it takes to reach a critical threshold, you will gain a quantitative understanding of how a cell translates environmental signals into an irreversible developmental decision. [@problem_id:4629255]", "problem": "Consider a well-mixed population of Bacillus subtilis cells entering nutrient limitation, where sporulation initiation is controlled by the concentration of phosphorylated Spo0A (Spo0A~P). Let $S(t)$ denote the concentration of phosphorylated Spo0A at time $t$, and let $S_{tot}$ denote the total concentration of Spo0A, assumed constant on the time scale of interest due to negligible synthesis and degradation. Phosphorylation converts unphosphorylated Spo0A to Spo0A~P with a pseudo-first-order rate constant $k_{phos}$, and dephosphorylation converts Spo0A~P back to unphosphorylated Spo0A with a first-order rate constant $k_{dephos}$. Assume mass-action kinetics in a closed system and no other sinks or sources.\n\nStarting from a mass balance and core definitions of first-order reaction kinetics, derive the time course $S(t)$ given the initial condition $S(0) = S_0$, with $0 \\leq S_0 \\leq S_{tot}$, and determine the time $t_{\\theta}$ at which $S(t)$ first reaches a commitment threshold $\\theta$ for sporulation initiation. Assume parameters are such that $S(t)$ increases monotonically from $S_0$ and crosses $\\theta$ from below at a finite time, and that $0 < \\theta < S_{tot}$. Express the final time in minutes. Your final answer must be a single closed-form analytic expression for $t_{\\theta}$ in terms of $k_{phos}$, $k_{dephos}$, $S_{tot}$, $S_0$, and $\\theta$.", "solution": "The problem requires the derivation of the time, $t_{\\theta}$, at which the concentration of phosphorylated Spo0A, denoted by $S(t)$, reaches a threshold value $\\theta$. The derivation must begin from a mass balance and the principles of reaction kinetics.\n\nFirst, let's define the species and parameters as per the problem statement.\n- $S(t)$: Concentration of phosphorylated Spo0A (Spo0A~P) at time $t$.\n- $S_u(t)$: Concentration of unphosphorylated Spo0A at time $t$.\n- $S_{tot}$: Total concentration of Spo0A, which is constant. $S_{tot} = S(t) + S_u(t)$.\n- $k_{phos}$: Pseudo-first-order rate constant for the phosphorylation of Spo0A to Spo0A~P.\n- $k_{dephos}$: First-order rate constant for the dephosphorylation of Spo0A~P to Spo0A.\n- $S(0) = S_0$: Initial concentration of Spo0A~P.\n- $\\theta$: Commitment threshold concentration for Spo0A~P.\n\nThe reaction scheme can be written as:\n$$ \\text{Spo0A} \\xrightarrow{k_{phos}} \\text{Spo0A~P} $$\n$$ \\text{Spo0A~P} \\xrightarrow{k_{dephos}} \\text{Spo0A} $$\n\nThe rate of change of the concentration of Spo0A~P, $\\frac{dS}{dt}$, is the difference between its rate of formation and its rate of removal.\n\nThe rate of formation is the phosphorylation of unphosphorylated Spo0A, $S_u(t)$. This is a pseudo-first-order reaction with respect to $S_u(t)$:\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} S_u(t) $$\nUsing the mass balance $S_u(t) = S_{tot} - S(t)$, we can express the formation rate in terms of $S(t)$:\n$$ \\text{Rate}_{\\text{formation}} = k_{phos} (S_{tot} - S(t)) $$\n\nThe rate of removal is the dephosphorylation of Spo0A~P, $S(t)$. This is a first-order reaction:\n$$ \\text{Rate}_{\\text{removal}} = k_{dephos} S(t) $$\n\nCombining these rates, we formulate the differential equation governing the time evolution of $S(t)$:\n$$ \\frac{dS}{dt} = \\text{Rate}_{\\text{formation}} - \\text{Rate}_{\\text{removal}} $$\n$$ \\frac{dS}{dt} = k_{phos} (S_{tot} - S(t)) - k_{dephos} S(t) $$\n\nTo solve this equation, we rearrange it into the standard form of a linear first-order ordinary differential equation.\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - k_{phos} S(t) - k_{dephos} S(t) $$\n$$ \\frac{dS}{dt} = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S(t) $$\n$$ \\frac{dS}{dt} + (k_{phos} + k_{dephos}) S(t) = k_{phos} S_{tot} $$\n\nThis is a non-homogeneous linear ODE of the form $\\frac{dy}{dt} + P(t)y = Q(t)$, where $y=S(t)$, $P(t) = k_{phos} + k_{dephos}$, and $Q(t) = k_{phos} S_{tot}$. $P$ and $Q$ are constants.\n\nThe general solution to this equation is the sum of the homogeneous solution and a particular solution. The steady-state concentration, $S_{ss}$, is achieved when $\\frac{dS}{dt} = 0$.\n$$ 0 = k_{phos} S_{tot} - (k_{phos} + k_{dephos}) S_{ss} $$\n$$ S_{ss} = \\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} $$\nThe general solution for $S(t)$ can be written as an approach to this steady state:\n$$ S(t) = S_{ss} + C \\exp(-(k_{phos} + k_{dephos})t) $$\nwhere $C$ is a constant of integration determined by the initial condition $S(0) = S_0$.\n$$ S(0) = S_0 = S_{ss} + C \\exp(0) = S_{ss} + C $$\n$$ C = S_0 - S_{ss} $$\nSubstituting $C$ back into the general solution gives the explicit time course $S(t)$:\n$$ S(t) = S_{ss} + (S_0 - S_{ss}) \\exp(-(k_{phos} + k_{dephos})t) $$\nThis can be rewritten as:\n$$ S(t) = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t) $$\n\nThe problem specifies that we need to find the time $t_{\\theta}$ at which $S(t_{\\theta}) = \\theta$. We set $S(t) = \\theta$ and $t = t_{\\theta}$ in the derived expression:\n$$ \\theta = S_{ss} - (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) $$\n\nNow, we must algebraically solve for $t_{\\theta}$.\n$$ (S_{ss} - S_0) \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = S_{ss} - \\theta $$\n$$ \\exp(-(k_{phos} + k_{dephos})t_{\\theta}) = \\frac{S_{ss} - \\theta}{S_{ss} - S_0} $$\n\nTaking the natural logarithm ($\\ln$) of both sides:\n$$ -(k_{phos} + k_{dephos})t_{\\theta} = \\ln\\left(\\frac{S_{ss} - \\theta}{S_{ss} - S_0}\\right) $$\n$$ t_{\\theta} = -\\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{S_{ss} - \\theta}{S_{ss} - S_0}\\right) $$\nUsing the property $\\ln(1/x) = -\\ln(x)$, we can invert the argument of the logarithm to remove the leading negative sign:\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{S_{ss} - S_0}{S_{ss} - \\theta}\\right) $$\n\nThe problem statement guarantees that $S(t)$ increases monotonically and crosses $\\theta$ from below, which implies $S_0 < \\theta < S_{ss}$. This ensures that both the numerator ($S_{ss} - S_0$) and the denominator ($S_{ss} - \\theta$) of the fraction inside the logarithm are positive, and since $S_0 < \\theta$, it holds that $S_{ss} - S_0 > S_{ss} - \\theta$, making the argument of the logarithm greater than $1$. Consequently, $t_{\\theta}$ is positive and well-defined, as expected for a physical time.\n\nFinally, we substitute the expression for $S_{ss}$ to obtain the final answer in terms of the given parameters:\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - S_0}{\\frac{k_{phos} S_{tot}}{k_{phos} + k_{dephos}} - \\theta}\\right) $$\nTo simplify the expression within the logarithm, we find a common denominator for the numerator and denominator:\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}{\\frac{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}{k_{phos} + k_{dephos}}}\\right) $$\n$$ t_{\\theta} = \\frac{1}{k_{phos} + k_{dephos}} \\ln\\left(\\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})}\\right) $$\n\nThis is the final closed-form analytic expression for $t_{\\theta}$. If the rate constants $k_{phos}$ and $k_{dephos}$ are given in units of $\\text{min}^{-1}$, then $t_{\\theta}$ will be in minutes, satisfying the problem's descriptive requirement.", "answer": "$$ \\boxed{ \\frac{1}{k_{phos} + k_{dephos}} \\ln \\left( \\frac{k_{phos} S_{tot} - S_0(k_{phos} + k_{dephos})}{k_{phos} S_{tot} - \\theta(k_{phos} + k_{dephos})} \\right) } $$", "id": "4629255"}, {"introduction": "Following commitment, a complex and spatially organized genetic program is executed by a cascade of sigma factors. This practice moves from continuous kinetics to logical modeling, challenging you to build a Boolean network that represents this regulatory circuit. Simulating this network will allow you to explore how the precise timing and dependency of gene expression events give rise to the spore's intricate structure. [@problem_id:4629277]", "problem": "You are tasked with building and validating a minimal synchronous Boolean network that captures the compartmentalized sigma factor cascade of bacterial sporulation beginning from activation of Spo0A in the context of infectious diseases, focusing on bacterial spore biology. The problem must be solved from first principles of regulatory logic using a minimal set of nodes and monotone interactions that reflect well-established facts about sporulation. Your program should construct a concrete network instance, simulate it under wild type and mutant perturbations, and validate whether the dynamics agree with canonical mutant phenotypes.\n\nFoundational base and modeling constraints. Use a Synchronous Boolean Network (SBN) where each node is a Boolean variable that evolves in discrete time steps. For a node $X$, its state at time $t$, denoted $X(t) \\in \\{0,1\\}$, is updated by a deterministic Boolean function using inputs from time $t$. The network must be composed of nodes corresponding to the following biological entities and states: Spo0A (denote as $A$), sigma factor $\\sigma^{\\mathrm{F}}$ (denote as $F$), SpoIIR (denote as $R$), sigma factor $\\sigma^{\\mathrm{E}}$ (denote as $E$), engulfment completion (denote as $G_{\\mathrm{eng}}$), sigma factor $\\sigma^{\\mathrm{G}}$ (denote as $G$), SpoIVB protease (denote as $B$), and sigma factor $\\sigma^{\\mathrm{K}}$ (denote as $K$). The update rules you choose must be monotone with respect to activation (only use logical conjunction and disjunction among activators, with optional self-maintenance that preserves an already active state), and must reflect these well-tested biological facts:\n- Spo0A activation precedes and is necessary for $\\sigma^{\\mathrm{F}}$ activation.\n- $\\sigma^{\\mathrm{F}}$ activity is necessary for SpoIIR production.\n- SpoIIR activity is necessary for the activation of $\\sigma^{\\mathrm{E}}$ in the mother cell.\n- $\\sigma^{\\mathrm{E}}$ activity drives engulfment progression, culminating in an engulfment-complete state.\n- Activation of $\\sigma^{\\mathrm{G}}$ in the forespore requires completion of engulfment and $\\sigma^{\\mathrm{E}}$-dependent factors.\n- SpoIVB production requires $\\sigma^{\\mathrm{G}}$.\n- Activation of $\\sigma^{\\mathrm{K}}$ in the mother cell requires $\\sigma^{\\mathrm{E}}$-dependent processing and the SpoIVB signal from the forespore.\n\nInitial conditions, update semantics, and forcing. Use initial state at time $t=0$ with $A(0)=1$ and all other nodes set to $0$. Use synchronous updates for all nodes. To model mutants, you must allow node forcing: a set of nodes is held at a fixed Boolean value for all $t \\ge 0$, overriding any update logic for those nodes; for example, a deletion mutant of $\\sigma^{\\mathrm{F}}$ is modeled by forcing $F(t)=0$ for all $t \\ge 0$.\n\nTiming objective and validation predicates. Your model must reproduce the ordered cascade under wild type conditions: there must exist strictly increasing activation times $t_F < t_E < t_G < t_K$ at which $F$, then $E$, then $G$, then $K$ first become active (i.e., first attain the value $1$). In mutants, your model must reproduce canonical blocking phenotypes implied by the facts above. You should simulate for a finite horizon of $T$ steps sufficiently large to allow activation to propagate if possible, with $T$ set to $12$.\n\nTest suite. Implement the following test cases, each defined by a set of node-forcing constraints; for each case, simulate the network from $t=0$ to $t=T$ under synchronous updates and evaluate the corresponding predicate as a Boolean result:\n- Case $1$ (wild type): no forcing. Predicate: there exist first-activation times $t_F, t_E, t_G, t_K \\in \\{0,1,\\dots,T\\}$ with $t_F < t_E < t_G < t_K$.\n- Case $2$ (Spo0A deletion): force $A(t)=0$ for all $t \\ge 0$. Predicate: $F$, $E$, $G$, and $K$ never activate within $\\{0,1,\\dots,T\\}$.\n- Case $3$ ($\\sigma^{\\mathrm{F}}$ deletion): force $F(t)=0$ for all $t \\ge 0$. Predicate: $E$, $G$, and $K$ never activate within $\\{0,1,\\dots,T\\}$.\n- Case $4$ (SpoIIR deletion): force $R(t)=0$ for all $t \\ge 0$. Predicate: $E$, $G$, and $K$ never activate within $\\{0,1,\\dots,T\\}$.\n- Case $5$ (engulfment-impaired): force $G_{\\mathrm{eng}}(t)=0$ for all $t \\ge 0$. Predicate: $E$ activates at some $t \\in \\{0,1,\\dots,T\\}$, but $G$ and $K$ never activate.\n- Case $6$ (SpoIVB deletion): force $B(t)=0$ for all $t \\ge 0$. Predicate: $E$ and $G$ both activate at some times in $\\{0,1,\\dots,T\\}$, but $K$ never activates.\n\nOutput format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of Cases $1$ through $6$. Each entry must be a Boolean literal. For example, an output for six cases would be of the form $[b_1,b_2,b_3,b_4,b_5,b_6]$, where each $b_i$ is either True or False. No units are involved in this problem. Angles and percentages are not applicable. Your program must not read any input.", "solution": "The problem requires the construction and validation of a minimal Synchronous Boolean Network (SBN) to model the sigma factor cascade in bacterial sporulation. The model must be built from first principles of regulatory logic, adhering to specified biological constraints and tested against canonical wild-type and mutant phenotypes.\n\nFirst, we formalize the system. The state of the network at any discrete time step $t$ is given by a vector of $8$ Boolean variables:\n$S(t) = (A(t), F(t), R(t), E(t), G_{\\text{eng}}(t), G(t), B(t), K(t))$, where each component is in $\\{0, 1\\}$. The node abbreviations correspond to Spo0A ($A$), $\\sigma^{\\mathrm{F}}$ ($F$), SpoIIR ($R$), $\\sigma^{\\mathrm{E}}$ ($E$), Engulfment completion ($G_{\\text{eng}}$), $\\sigma^{\\mathrm{G}}$ ($G$), SpoIVB ($B$), and $\\sigma^{\\mathrm{K}}$ ($K$). The system evolves according to the synchronous update rule $S(t+1) = \\mathbf{f}(S(t))$, where $\\mathbf{f}$ is a vector of Boolean update functions.\n\nThe construction of the update functions is guided by the provided biological facts and modeling constraints. The constraints mandate monotone logic (using only conjunction and disjunction) and allow for optional self-maintenance, which preserves an active state. A standard way to model this is $X(t+1) = X(t) \\lor \\text{activation_logic}(t)$, ensuring that once a node becomes $1$, it remains $1$. This reflects the irreversible nature of developmental checkpoints in sporulation. The \"necessary for\" biological rules are translated into conjunctions ($\\land$) in the activation logic.\n\nBased on these principles, we define the minimal update rules:\n\n1.  **Spo0A ($A$)**: $A$ is the master regulator, active at the start. It is not regulated by other nodes in this minimal model, so it maintains its state.\n    $$A(t+1) = A(t)$$\n2.  **$\\sigma^{\\mathrm{F}}$ ($F$)**: Activation requires Spo0A ($A$).\n    $$F(t+1) = F(t) \\lor A(t)$$\n3.  **SpoIIR ($R$)**: Production requires $\\sigma^{\\mathrm{F}}$ ($F$).\n    $$R(t+1) = R(t) \\lor F(t)$$\n4.  **$\\sigma^{\\mathrm{E}}$ ($E$)**: Activation requires SpoIIR ($R$).\n    $$E(t+1) = E(t) \\lor R(t)$$\n5.  **Engulfment ($G_{\\text{eng}}$)**: Completion is driven by $\\sigma^{\\mathrm{E}}$ ($E$).\n    $$G_{\\text{eng}}(t+1) = G_{\\text{eng}}(t) \\lor E(t)$$\n6.  **$\\sigma^{\\mathrm{G}}$ ($G$)**: Activation requires both engulfment completion ($G_{\\text{eng}}$) and $\\sigma^{\\mathrm{E}}$-dependent factors ($E$).\n    $$G(t+1) = G(t) \\lor (G_{\\text{eng}}(t) \\land E(t))$$\n7.  **SpoIVB ($B$)**: Production requires $\\sigma^{\\mathrm{G}}$ ($G$).\n    $$B(t+1) = B(t) \\lor G(t)$$\n8.  **$\\sigma^{\\mathrm{K}}$ ($K$)**: Activation requires a signal from the forespore via SpoIVB ($B$) and processing in the mother cell dependent on $\\sigma^{\\mathrm{E}}$ ($E$).\n    $$K(t+1) = K(t) \\lor (E(t) \\land B(t))$$\n\nThe simulation proceeds from an initial state at $t=0$ where $A(0)=1$ and all other nodes are $0$. For mutant analysis, specific nodes are \"forced\" to a fixed value ($0$ or $1$) for all time steps $t \\ge 0$, overriding their update rules. The simulation runs for a time horizon of $T=12$ steps.\n\nTo implement the solution, a program will simulate the network dynamics for each of the six test cases. For each case, it will:\n1.  Initialize a state history array for $t \\in \\{0, 1, \\dots, T\\}$. The initial state $S(0)$ is set to $(1, 0, 0, 0, 0, 0, 0, 0)$.\n2.  Apply any forcing rules for the specific test case, which may modify the initial state and will override updates at every subsequent step.\n3.  Iteratively compute $S(t+1)$ from $S(t)$ for $t = 0, \\dots, T-1$ using the Boolean functions defined above. After computing the new state, the forcing rules are applied.\n4.  After the simulation, the state history is analyzed to evaluate the corresponding Boolean predicate for that test case.\n\nFor example, to evaluate the wild-type predicate (Case $1$), we find the first time step $t_X$ at which each node $X \\in \\{F, E, G, K\\}$ transitions from $0$ to $1$. We then verify if the strict inequality $t_F < t_E < t_G < t_K$ holds. For mutant cases, predicates involve checking if certain nodes activate at any point or remain inactive throughout the simulation. For instance, in the $A$ deletion mutant (Case $2$), we check if the columns for $F, E, G, K$ in the state history contain only zeros. The final output is a list of the Boolean results for each of the six predicates.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, simulates, and validates a Boolean network model of\n    bacterial sporulation sigma factor cascade.\n    \"\"\"\n    \n    # Node mapping to indices in the state vector\n    NODE_MAP = {\n        'A': 0, 'F': 1, 'R': 2, 'E': 3, \n        'G_eng': 4, 'G': 5, 'B': 6, 'K': 7\n    }\n    NUM_NODES = len(NODE_MAP)\n    T = 12  # Simulation horizon\n\n    def get_update_rules(state):\n        \"\"\"\n        Calculates the next state based on the current state.\n        state: np.ndarray of shape (NUM_NODES,)\n        \"\"\"\n        A, F, R, E, G_eng, G, B, K = state\n        \n        next_state = np.zeros_like(state)\n        \n        # Apply the update logic based on the derived Boolean functions\n        next_state[NODE_MAP['A']] = A or A  # Self-maintenance\n        next_state[NODE_MAP['F']] = F or A\n        next_state[NODE_MAP['R']] = R or F\n        next_state[NODE_MAP['E']] = E or R\n        next_state[NODE_MAP['G_eng']] = G_eng or E\n        next_state[NODE_MAP['G']] = G or (G_eng and E)\n        next_state[NODE_MAP['B']] = B or G\n        next_state[NODE_MAP['K']] = K or (E and B)\n        \n        return next_state\n\n    def simulate(forcing_rules: dict):\n        \"\"\"\n        Simulates the Synchronous Boolean Network.\n        forcing_rules: A dictionary mapping node names to their forced values.\n        \"\"\"\n        history = np.zeros((T + 1, NUM_NODES), dtype=bool)\n        \n        # Initial state at t=0\n        history[0, NODE_MAP['A']] = 1\n        \n        # Apply forcing at t=0\n        for node_name, value in forcing_rules.items():\n            history[0, NODE_MAP[node_name]] = value\n            \n        # Synchronous updates for t = 0 to T-1\n        for t in range(T):\n            # Calculate next state based on current state\n            next_state = get_update_rules(history[t])\n            \n            # Apply forcing rules to the new state\n            for node_name, value in forcing_rules.items():\n                next_state[NODE_MAP[node_name]] = value\n            \n            history[t + 1] = next_state\n            \n        return history\n\n    def find_first_activation(history, node_idx):\n        \"\"\"Finds the first time step a node becomes 1.\"\"\"\n        activations = np.where(history[:, node_idx] == 1)[0]\n        return activations[0] if len(activations) > 0 else float('inf')\n\n    # Define test cases with their specific forcing rules\n    test_cases = [\n        {'name': 'Case 1 (wild type)', 'forcing': {}},\n        {'name': 'Case 2 (Spo0A deletion)', 'forcing': {'A': 0}},\n        {'name': 'Case 3 (sigmaF deletion)', 'forcing': {'F': 0}},\n        {'name': 'Case 4 (SpoIIR deletion)', 'forcing': {'R': 0}},\n        {'name': 'Case 5 (engulfment-impaired)', 'forcing': {'G_eng': 0}},\n        {'name': 'Case 6 (SpoIVB deletion)', 'forcing': {'B': 0}},\n    ]\n\n    results = []\n    \n    for i, case in enumerate(test_cases):\n        history = simulate(case['forcing'])\n        \n        if i == 0:  # Case 1 Predicate\n            t_F = find_first_activation(history, NODE_MAP['F'])\n            t_E = find_first_activation(history, NODE_MAP['E'])\n            t_G = find_first_activation(history, NODE_MAP['G'])\n            t_K = find_first_activation(history, NODE_MAP['K'])\n            # Check for activation within horizon and strict ordering\n            predicate_val = (t_F  t_E  t_G  t_K) and (t_K = T)\n            results.append(predicate_val)\n        \n        elif i == 1:  # Case 2 Predicate\n            # Check if F, E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['F'], NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 2:  # Case 3 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n\n        elif i == 3:  # Case 4 Predicate\n            # Check if E, G, K never activate\n            never_active = np.all(history[:, [NODE_MAP['E'], NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(never_active)\n            \n        elif i == 4:  # Case 5 Predicate\n            # E activates, but G and K never activate\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_k_never_active = np.all(history[:, [NODE_MAP['G'], NODE_MAP['K']]] == 0)\n            results.append(e_activates and g_k_never_active)\n            \n        elif i == 5:  # Case 6 Predicate\n            # E and G activate, but K never activates\n            e_activates = np.any(history[:, NODE_MAP['E']] == 1)\n            g_activates = np.any(history[:, NODE_MAP['G']] == 1)\n            k_never_activates = np.all(history[:, NODE_MAP['K']] == 0)\n            results.append(e_activates and g_activates and k_never_activates)\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4629277"}, {"introduction": "The end product of sporulation is an incredibly resilient cell, posing significant challenges for disinfection and food safety. This final practice connects fundamental spore biology to its critical public health applications. You will derive and apply the concepts of the decimal reduction time ($D$-value) and the $z$-value, the foundational parameters used in thermal processing to design effective sterilization protocols against pathogenic spores. [@problem_id:4629224]", "problem": "A canned low-acid food process targets inactivation of thermoresistant bacterial spores relevant to infectious diseases. Assume isothermal exposure where spore inactivation follows first-order kinetics in the viable count. The decimal reduction time (D-value) at temperature $T$, denoted $D(T)$, is defined as the exposure time required to reduce the viable count by a factor of $10$ at temperature $T$. The $z$-value is defined as the temperature increase required to reduce the D-value by a factor of $10$.\n\nUsing only these core definitions and the assumption of first-order inactivation kinetics, derive from first principles an explicit expression for $D(T)$ in terms of a reference D-value $D_{\\mathrm{ref}}$ at reference temperature $T_{\\mathrm{ref}}$, the $z$-value $z$, and the target temperature $T$. Then use your derived relationship to compute $D(T)$ for spores with $D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$ at $T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$ and $z = 8.5\\,^{\\circ}\\mathrm{C}$ when the target temperature is $T = 115\\,^{\\circ}\\mathrm{C}$.\n\nRound your final numeric answer to three significant figures and express the time in minutes. Your final answer must be a single real-valued number.", "solution": "The problem is valid as it is scientifically grounded in the principles of thermal death time kinetics, a standard methodology in food microbiology for ensuring safety from infectious agents like spore-forming bacteria. The problem is well-posed, with all necessary definitions and data provided to derive the requested expression and compute the numerical result.\n\nThe derivation proceeds from the fundamental principles provided.\n\nFirst, we formalize the statement that spore inactivation follows first-order kinetics. Let $N(t)$ be the number of viable spores at time $t$ during an isothermal process at temperature $T$. The rate of inactivation is given by the differential equation:\n$$\n-\\frac{dN(t)}{dt} = k(T) N(t)\n$$\nwhere $k(T)$ is the temperature-dependent first-order rate constant. We can solve this equation by separation of variables, integrating from time $t=0$ with an initial spore count $N(0)=N_0$ to a later time $t$:\n$$\n\\int_{N_0}^{N(t)} \\frac{dN}{N} = -\\int_{0}^{t} k(T) dt'\n$$\nSince the temperature $T$ is constant, $k(T)$ is also constant with respect to time. The integration yields:\n$$\n\\ln\\left(\\frac{N(t)}{N_0}\\right) = -k(T)t\n$$\n\nNext, we use the definition of the decimal reduction time, $D(T)$. This is the time required to reduce the viable count by a factor of $10$. At $t = D(T)$, we have $N(D(T)) = \\frac{N_0}{10}$. Substituting this condition into the integrated rate law:\n$$\n\\ln\\left(\\frac{N_0/10}{N_0}\\right) = -k(T)D(T)\n$$\n$$\n\\ln\\left(\\frac{1}{10}\\right) = -k(T)D(T)\n$$\n$$\n-\\ln(10) = -k(T)D(T)\n$$\nThis gives the relationship between the D-value and the rate constant:\n$$\nD(T) = \\frac{\\ln(10)}{k(T)}\n$$\n\nNow, we use the definition of the $z$-value. The $z$-value is the temperature increase required to reduce the D-value by a factor of $10$. This definition implies a specific relationship between $\\log(D)$ and $T$. In thermal processing, this is modeled as a linear relationship between the base-10 logarithm of the D-value and temperature. That is, a plot of $\\log_{10}(D(T))$ versus $T$ is a straight line.\n\nLet's consider two points on this line: $(T_1, \\log_{10}(D(T_1)))$ and $(T_2, \\log_{10}(D(T_2)))$. The slope of this line is:\n$$\nm = \\frac{\\log_{10}(D(T_2)) - \\log_{10}(D(T_1))}{T_2 - T_1}\n$$\nAccording to the definition of the $z$-value, if we increase the temperature by $z$, so that $T_2 - T_1 = z$, the D-value decreases by a factor of $10$, so $D(T_2) = \\frac{D(T_1)}{10}$. Substituting this into the numerator of the slope equation:\n$$\n\\log_{10}(D(T_2)) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{D(T_1)}{10}\\right) - \\log_{10}(D(T_1)) = \\log_{10}\\left(\\frac{1}{10}\\right) = -1\n$$\nTherefore, the slope of the line is $m = \\frac{-1}{z}$.\n\nUsing the point-slope form of a line with the reference point $(T_{\\mathrm{ref}}, \\log_{10}(D_{\\mathrm{ref}}))$ and a general point $(T, \\log_{10}(D(T)))$, we have:\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = m(T - T_{\\mathrm{ref}})\n$$\nSubstituting $m = -1/z$:\n$$\n\\log_{10}(D(T)) - \\log_{10}(D_{\\mathrm{ref}}) = -\\frac{1}{z}(T - T_{\\mathrm{ref}})\n$$\n$$\n\\log_{10}\\left(\\frac{D(T)}{D_{\\mathrm{ref}}}\\right) = -\\frac{T - T_{\\mathrm{ref}}}{z}\n$$\nTo obtain an explicit expression for $D(T)$, we take the antilogarithm (base $10$) of both sides:\n$$\n\\frac{D(T)}{D_{\\mathrm{ref}}} = 10^{-\\frac{T - T_{\\mathrm{ref}}}{z}}\n$$\nThis can be rearranged to give the desired expression for $D(T)$:\n$$\nD(T) = D_{\\mathrm{ref}} \\cdot 10^{\\frac{T_{\\mathrm{ref}} - T}{z}}\n$$\nThis is the required expression derived from first principles.\n\nNow, we use this relationship to compute the value of $D(T)$ for the given parameters:\n- Reference D-value, $D_{\\mathrm{ref}} = 0.600\\,\\mathrm{min}$\n- Reference temperature, $T_{\\mathrm{ref}} = 121\\,^{\\circ}\\mathrm{C}$\n- z-value, $z = 8.5\\,^{\\circ}\\mathrm{C}$\n- Target temperature, $T = 115\\,^{\\circ}\\mathrm{C}$\n\nSubstituting these values into the derived formula:\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{121 - 115}{8.5}}\n$$\nThe temperature difference in the exponent is $T_{\\mathrm{ref}} - T = 121 - 115 = 6\\,^{\\circ}\\mathrm{C}$.\n$$\nD(115\\,^{\\circ}\\mathrm{C}) = 0.600 \\cdot 10^{\\frac{6}{8.5}}\n$$\nWe now compute the numerical value:\n$$\n\\frac{6}{8.5} \\approx 0.70588235...\n$$\n$$\n10^{6/8.5} \\approx 10^{0.70588235...} \\approx 5.08010...\n$$\n$$\nD(115\\,^{\\circ}\\mathrm{C}) \\approx 0.600 \\times 5.08010... \\approx 3.04806...\n$$\nThe problem requires the final answer to be rounded to three significant figures. The calculated value is $3.04806...\\,\\mathrm{min}$. Rounding to three significant figures gives $3.05$. The unit is minutes.", "answer": "$$\\boxed{3.05}$$", "id": "4629224"}]}