{"hands_on_practices": [{"introduction": "Molecular diagnostics are central to modern infectious disease management. This exercise focuses on quantitative Polymerase Chain Reaction (qPCR), a powerful technique for not only detecting but also quantifying pathogen DNA. By working through this problem [@problem_id:4645947], you will translate a raw instrument output—the quantification cycle ($C_q$)—into a clinically meaningful bacterial load, gaining hands-on practice with the logarithmic calculations and sample processing logic used in real-world laboratories.", "problem": "A clinical microbiology laboratory is quantifying pathogenic Leptospira interrogans in a patient's urine using quantitative Polymerase Chain Reaction (qPCR). The assay targets a conserved pathogenic gene assumed to be single-copy per bacterium. Quantification cycle (Cq) values were calibrated using a standard curve that empirically relates the initial template copy number to the Cq as a linear function under constant amplification efficiency. The calibration yields the relationship $C_q = -3.3\\log_{10}(N) + 40$, where $N$ denotes the initial template copy number present in the reaction volume at the start of amplification and $C_q$ denotes the quantification cycle.\n\nFrom the patient sample, deoxyribonucleic acid (DNA) was extracted from $200~\\mu\\text{L}$ of urine into a final elution volume of $50~\\mu\\text{L}$. The qPCR reaction volume was $20~\\mu\\text{L}$, of which $5~\\mu\\text{L}$ was the DNA template. The patient's sample produced a $C_q$ of $30$. Using the provided calibration relationship and the volumes described, compute the initial template copy number $N$ in the qPCR reaction and then estimate the bacterial load in the original urine in copies per $\\text{mL}$. Round your final bacterial load to three significant figures and express the final result in copies per $\\text{mL}$.", "solution": "The problem is valid as it is scientifically grounded in the principles of quantitative Polymerase Chain Reaction (qPCR), is well-posed with sufficient information for a unique solution, and is expressed in objective, unambiguous language.\n\nThe solution proceeds in two stages. First, we determine the number of initial template copies, $N$, present in the qPCR reaction volume using the provided calibration equation. Second, we use this number along with the specified volumes from the DNA extraction and reaction setup to calculate the concentration of bacteria in the original urine sample.\n\n**Part 1: Calculation of Template Copy Number in the qPCR Reaction**\n\nThe relationship between the quantification cycle, $C_q$, and the initial template copy number, $N$, is given by the linear equation:\n$$C_q = -3.3\\log_{10}(N) + 40$$\nThe patient's sample yielded a $C_q$ value of $30$. We substitute this value into the equation:\n$$30 = -3.3\\log_{10}(N) + 40$$\nOur objective is to solve for $N$. We begin by isolating the logarithmic term:\n$$30 - 40 = -3.3\\log_{10}(N)$$\n$$-10 = -3.3\\log_{10}(N)$$\nNext, we solve for $\\log_{10}(N)$:\n$$\\log_{10}(N) = \\frac{-10}{-3.3} = \\frac{10}{3.3} = \\frac{100}{33}$$\nTo find $N$, we take the antilogarithm (base $10$) of both sides:\n$$N = 10^{\\left(\\frac{100}{33}\\right)}$$\nThis value, $N$, represents the number of DNA template copies present in the volume of the DNA template added to the qPCR reaction, which is specified as $V_{template} = 5~\\mu\\text{L}$.\n\n**Part 2: Calculation of Bacterial Load in the Original Urine Sample**\n\nThe number of copies $N$ calculated above is contained within the $V_{template} = 5~\\mu\\text{L}$ of DNA eluate that was added to the qPCR reaction. First, we determine the concentration of DNA copies in the entire DNA eluate.\nLet $C_{eluate}$ be the concentration of copies per microliter in the DNA eluate.\n$$C_{eluate} = \\frac{N}{V_{template}} = \\frac{10^{\\left(\\frac{100}{33}\\right)}}{5~\\mu\\text{L}}$$\nThe total volume of the DNA eluate is $V_{elution} = 50~\\mu\\text{L}$. The total number of copies in the entire eluate, $N_{eluate}$, is the product of its concentration and total volume:\n$$N_{eluate} = C_{eluate} \\times V_{elution} = \\left(\\frac{10^{\\left(\\frac{100}{33}\\right)}}{5~\\mu\\text{L}}\\right) \\times 50~\\mu\\text{L}$$\n$$N_{eluate} = 10 \\times 10^{\\left(\\frac{100}{33}\\right)} = 10^1 \\times 10^{\\left(\\frac{100}{33}\\right)} = 10^{\\left(1 + \\frac{100}{33}\\right)} = 10^{\\left(\\frac{33+100}{33}\\right)} = 10^{\\left(\\frac{133}{33}\\right)}$$\nThis total number of copies, $N_{eluate}$, was extracted from an initial urine volume of $V_{urine} = 200~\\mu\\text{L}$. Assuming perfect extraction efficiency, this is the number of bacterial gene copies present in $200~\\mu\\text{L}$ of urine.\n\nThe problem asks for the bacterial load in units of copies per milliliter ($\\text{mL}$). Let $L_{urine}$ be this concentration. First, we find the concentration in copies per microliter:\n$$L_{urine, \\mu L} = \\frac{N_{eluate}}{V_{urine}} = \\frac{10^{\\left(\\frac{133}{33}\\right)}}{200}~\\frac{\\text{copies}}{\\mu\\text{L}}$$\nTo convert this concentration to copies per $\\text{mL}$, we use the conversion factor $1~\\text{mL} = 1000~\\mu\\text{L}$:\n$$L_{urine} = L_{urine, \\mu L} \\times \\frac{1000~\\mu\\text{L}}{1~\\text{mL}} = \\frac{10^{\\left(\\frac{133}{33}\\right)}}{200} \\times 1000~\\frac{\\text{copies}}{\\text{mL}}$$\n$$L_{urine} = 5 \\times 10^{\\left(\\frac{133}{33}\\right)}~\\frac{\\text{copies}}{\\text{mL}}$$\nNow, we compute the numerical value. The exponent is approximately $\\frac{133}{33} \\approx 4.030303...$\n$$L_{urine} \\approx 5 \\times 10^{4.030303...}$$\n$$L_{urine} \\approx 5 \\times 10724.11$$\n$$L_{urine} \\approx 53620.55~\\frac{\\text{copies}}{\\text{mL}}$$\nThe problem requires the final answer to be rounded to three significant figures. The first three significant figures are $5$, $3$, and $6$. The fourth digit is $2$, which is less than $5$, so we round down.\n$$L_{urine} \\approx 53600~\\frac{\\text{copies}}{\\text{mL}}$$\nExpressed in standard scientific notation, this is $5.36 \\times 10^4$ copies/mL. Since the problem assumes a single-copy gene per bacterium, this value represents the bacterial load.", "answer": "$$\n\\boxed{5.36 \\times 10^{4}}\n$$", "id": "4645947"}, {"introduction": "A diagnostic test's result is only as useful as our ability to interpret it correctly within a specific population context. This practice explores the crucial epidemiological concepts of Positive and Negative Predictive Values ($PPV$ and $NPV$). You will use Bayes' theorem to see how a test's performance is profoundly influenced by disease prevalence [@problem_id:4645691], a fundamental principle for making sound clinical and public health judgments during an outbreak.", "problem": "A public health team is evaluating an Immunoglobulin M (IgM) Enzyme-Linked Immunosorbent Assay (ELISA) for early diagnosis of leptospirosis caused by Leptospira interrogans in a cohort of febrile patients from a flood-affected region. The assay has been validated against a gold-standard reference panel, yielding sensitivity $Se$ and specificity $Sp$. In the target cohort, the true disease prevalence is $p$. Sensitivity is defined as $Se = P(T^{+} \\mid D^{+})$, specificity as $Sp = P(T^{-} \\mid D^{-})$, and prevalence as $p = P(D^{+})$, where $T^{+}$ denotes a positive test result, $T^{-}$ a negative test result, $D^{+}$ true disease, and $D^{-}$ no disease.\n\nStarting from the law of total probability and Bayes’ theorem, derive the positive predictive value $PPV = P(D^{+} \\mid T^{+})$ and the negative predictive value $NPV = P(D^{-} \\mid T^{-})$ in terms of $Se$, $Sp$, and $p$. Then, for an IgM ELISA with $Se = 0.90$, $Sp = 0.95$, and $p = 0.10$, compute the numerical values of $PPV$ and $NPV$. Round your final numerical answers to four significant figures and express them as decimals.", "solution": "The problem is valid as it is scientifically grounded in the principles of epidemiology and probability theory, well-posed, and provides all necessary information for a unique solution.\n\nThe task is to derive the expressions for the positive predictive value ($PPV$) and the negative predictive value ($NPV$) of a diagnostic test and then compute their numerical values given specific parameters. The provided definitions are:\nSensitivity: $Se = P(T^{+} \\mid D^{+})$\nSpecificity: $Sp = P(T^{-} \\mid D^{-})$\nPrevalence: $p = P(D^{+})$\n\nWe also know the following complementary probabilities:\nProbability of no disease: $P(D^{-}) = 1 - P(D^{+}) = 1 - p$\nFalse positive rate: $P(T^{+} \\mid D^{-}) = 1 - P(T^{-} \\mid D^{-}) = 1 - Sp$\nFalse negative rate: $P(T^{-} \\mid D^{+}) = 1 - P(T^{+} \\mid D^{+}) = 1 - Se$\n\n**1. Derivation of the Positive Predictive Value ($PPV$)**\n\nThe positive predictive value is the probability that a patient has the disease given a positive test result, defined as $PPV = P(D^{+} \\mid T^{+})$.\nUsing the definition of conditional probability (Bayes' theorem):\n$$PPV = P(D^{+} \\mid T^{+}) = \\frac{P(D^{+} \\cap T^{+})}{P(T^{+})}$$\nThe numerator, the joint probability of having the disease and testing positive, can be expressed using the definition of conditional probability:\n$$P(D^{+} \\cap T^{+}) = P(T^{+} \\mid D^{+}) \\cdot P(D^{+}) = Se \\cdot p$$\nThe denominator, the total probability of a positive test result, is found using the law of total probability by summing over the states of having the disease ($D^{+}$) and not having the disease ($D^{-}$):\n$$P(T^{+}) = P(T^{+} \\mid D^{+}) \\cdot P(D^{+}) + P(T^{+} \\mid D^{-}) \\cdot P(D^{-})$$\nSubstituting the known terms:\n$$P(T^{+}) = (Se \\cdot p) + ((1 - Sp) \\cdot (1 - p))$$\nCombining the numerator and denominator gives the final expression for $PPV$:\n$$PPV = \\frac{Se \\cdot p}{(Se \\cdot p) + (1 - Sp)(1 - p)}$$\n\n**2. Derivation of the Negative Predictive Value ($NPV$)**\n\nThe negative predictive value is the probability that a patient does not have the disease given a negative test result, defined as $NPV = P(D^{-} \\mid T^{-})$.\nUsing the definition of conditional probability:\n$$NPV = P(D^{-} \\mid T^{-}) = \\frac{P(D^{-} \\cap T^{-})}{P(T^{-})}$$\nThe numerator, the joint probability of not having the disease and testing negative, is:\n$$P(D^{-} \\cap T^{-}) = P(T^{-} \\mid D^{-}) \\cdot P(D^{-}) = Sp \\cdot (1 - p)$$\nThe denominator, the total probability of a negative test result, is found using the law of total probability:\n$$P(T^{-}) = P(T^{-} \\mid D^{-}) \\cdot P(D^{-}) + P(T^{-} \\mid D^{+}) \\cdot P(D^{+})$$\nSubstituting the known terms:\n$$P(T^{-}) = (Sp \\cdot (1 - p)) + ((1 - Se) \\cdot p)$$\nCombining the numerator and denominator gives the final expression for $NPV$:\n$$NPV = \\frac{Sp \\cdot (1 - p)}{(Sp \\cdot (1 - p)) + (1 - Se)p}$$\n\n**3. Numerical Computation**\n\nThe given values are $Se = 0.90$, $Sp = 0.95$, and $p = 0.10$.\n\nTo compute $PPV$:\n$$PPV = \\frac{0.90 \\cdot 0.10}{(0.90 \\cdot 0.10) + (1 - 0.95)(1 - 0.10)}$$\n$$PPV = \\frac{0.09}{0.09 + (0.05)(0.90)}$$\n$$PPV = \\frac{0.09}{0.09 + 0.045}$$\n$$PPV = \\frac{0.09}{0.135} = \\frac{2}{3} \\approx 0.666666...$$\nRounding to four significant figures, $PPV = 0.6667$.\n\nTo compute $NPV$:\n$$NPV = \\frac{0.95 \\cdot (1 - 0.10)}{(0.95 \\cdot (1 - 0.10)) + (1 - 0.90) \\cdot 0.10}$$\n$$NPV = \\frac{0.95 \\cdot 0.90}{(0.95 \\cdot 0.90) + (0.10 \\cdot 0.10)}$$\n$$NPV = \\frac{0.855}{0.855 + 0.01}$$\n$$NPV = \\frac{0.855}{0.865} \\approx 0.9884393...$$\nRounding to four significant figures, $NPV = 0.9884$.", "answer": "$$\\boxed{\\begin{pmatrix} 0.6667  0.9884 \\end{pmatrix}}$$", "id": "4645691"}, {"introduction": "In an outbreak investigation, a primary goal is to understand the connections between cases. This computational exercise delves into Multilocus Sequence Typing (MLST), a key method in molecular epidemiology for tracing transmission chains. By implementing an algorithm to compare allele profiles, calculate genetic distances, and cluster isolates [@problem_id:4645693], you will simulate the bioinformatic workflow that turns raw sequence data into actionable public health intelligence.", "problem": "You are given allele profiles at $7$ housekeeping gene loci for isolates of Leptospira interrogans in a suspected local outbreak. Using Multilocus Sequence Typing (MLST), each isolate’s allelic profile is a sequence of $7$ nonnegative integers, one per locus. A Sequence Type (ST) is defined by an exact $7$-locus allele profile. Your task is to write a complete, runnable program that, for each provided test case, performs the following computations grounded in fundamental definitions.\n\nFundamental base:\n- Multilocus Sequence Typing (MLST) represents each isolate by an allele profile vector $\\mathbf{a} \\in \\mathbb{N}^L$ with $L=7$, where $\\mathbb{N}$ denotes the nonnegative integers and each coordinate $a_i$ is the allele identifier at locus $i$.\n- A Sequence Type (ST) is a unique identifier assigned to an exact allele profile; an ST database is a finite mapping from known ST identifiers (integers) to $7$-locus allele profiles in $\\mathbb{N}^7$.\n- The allelic distance between two isolates with profiles $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{N}^7$ is the mismatch count across loci, defined by\n$$\nd(\\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{7} \\mathbf{1}\\{a_i \\neq b_i\\},\n$$\nwhere $\\mathbf{1}\\{\\cdot\\}$ is the indicator function.\n- For a fixed mismatch threshold $t \\in \\mathbb{N}$, define an undirected graph $G=(V,E)$ whose vertices $V$ index isolates and whose edges connect isolates $u,v$ if and only if $d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)}) \\le t$. The connected components of $G$ are used as a simple, logic-based proxy for transmission chains under the assumption that closely related profiles (by allelic mismatch) indicate recent shared transmission history.\n\nProgram requirements for each test case:\n1. ST assignment: Given an ST database $\\mathcal{D}$ mapping ST identifiers to allele profiles, assign each isolate’s ST by exact match of its profile to a profile in $\\mathcal{D}$. If no exact match exists, assign the value $-1$.\n2. Pairwise allelic distance matrix: Compute the full $n \\times n$ matrix $D$ where $n$ is the number of isolates, and $D_{uv} = d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)})$ for all pairs $(u,v)$.\n3. Transmission chain inference via threshold graph: Using the specified threshold $t$, construct $G$ and output the connected component label for each isolate. Labels must be integers starting at $1$, assigned in order of first appearance when scanning isolates from index $1$ to index $n$; all isolates in the same connected component share the same label.\n\nFinal output format:\n- For each test case, produce a list of three items: the ST assignments (list of integers in isolate input order), the flattened pairwise distance matrix (list of integers in row-major order including diagonal entries), and the connected component labels (list of integers in isolate input order).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\"). Each \"result\" is the list described above for one test case.\n\nTest suite:\n- Test Case $1$ (general case):\n  - ST database $\\mathcal{D}_1$:\n    - ST $1$: [$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - ST $2$: [$1$,$2$,$4$,$4$,$5$,$6$,$7$]\n    - ST $42$: [$2$,$1$,$3$,$4$,$5$,$6$,$7$]\n    - ST $5$: [$1$,$2$,$3$,$4$,$6$,$6$,$7$]\n  - Outbreak isolate profiles (order defines indices $1$ to $4$):\n    - Isolate $1$: [$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - Isolate $2$: [$1$,$2$,$4$,$4$,$5$,$6$,$7$]\n    - Isolate $3$: [$1$,$2$,$3$,$4$,$5$,$6$,$7$]\n    - Isolate $4$: [$2$,$1$,$3$,$4$,$5$,$6$,$7$]\n  - Threshold $t_1 = 1$.\n- Test Case $2$ (boundary case: identical profiles, strict threshold):\n  - ST database $\\mathcal{D}_2$:\n    - ST $7$: [$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n  - Outbreak isolate profiles (order defines indices $1$ to $3$):\n    - Isolate $1$: [$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n    - Isolate $2$: [$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n    - Isolate $3$: [$3$,$3$,$3$,$3$,$3$,$3$,$3$]\n  - Threshold $t_2 = 0$.\n- Test Case $3$ (edge case: novel profile appears, chain via single-link connections):\n  - ST database $\\mathcal{D}_3$:\n    - ST $10$: [$1$,$1$,$1$,$1$,$1$,$1$,$1$]\n    - ST $11$: [$1$,$1$,$2$,$1$,$1$,$1$,$1$]\n  - Outbreak isolate profiles (order defines indices $1$ to $3$):\n    - Isolate $1$: [$1$,$1$,$1$,$1$,$1$,$1$,$1$]\n    - Isolate $2$: [$1$,$1$,$2$,$1$,$1$,$1$,$1$]\n    - Isolate $3$: [$1$,$2$,$2$,$1$,$1$,$1$,$1$]\n  - Threshold $t_3 = 1$.\n\nAnswer specification:\n- For each test case, the answer must be a list of the form [STs, distances, clusters], where STs is a list of integers, distances is a list of integers, and clusters is a list of integers.\n- The final output must be a single line with the three test case results as a comma-separated list enclosed in square brackets, with no additional whitespace or text.", "solution": "The solution proceeds from fundamental definitions of Multilocus Sequence Typing (MLST) and graph connectivity, translating them into precise computational steps.\n\n1. Representation and ST assignment:\n   - Each isolate is represented by a $7$-dimensional allele vector $\\mathbf{a} = (a_1,a_2,\\dots,a_7) \\in \\mathbb{N}^7$.\n   - The provided ST database $\\mathcal{D}$ is a finite mapping from integer ST identifiers (for example, $1$, $2$, $42$) to exact allele vectors in $\\mathbb{N}^7$. To assign an ST to an isolate, we perform an exact-match lookup: if there exists an ST $s$ such that $\\mathcal{D}(s) = \\mathbf{a}$, return $s$; otherwise, return $-1$ to denote an unknown or novel profile.\n   - Algorithmically, invert $\\mathcal{D}$ into a dictionary from profile tuples to ST identifiers and perform a constant-time lookup per isolate. This respects the definition that STs are defined by exact $7$-locus matches.\n\n2. Allelic distance:\n   - For any two isolates with profiles $\\mathbf{a}$ and $\\mathbf{b}$, the allelic mismatch distance is\n     $$\n     d(\\mathbf{a}, \\mathbf{b}) = \\sum_{i=1}^{7} \\mathbf{1}\\{a_i \\neq b_i\\}.\n     $$\n   - This is the Hamming distance on $\\mathbb{N}^7$ restricted to equality comparisons at each locus. It captures the count of loci where the alleles differ, conforming to well-tested MLST practice in medical microbiology.\n   - Algorithmically, compute $d$ by iterating $i$ from $1$ to $7$ and summing $1$ whenever $a_i \\neq b_i$. For $n$ isolates, form the full $n \\times n$ matrix $D$ with entries $D_{uv} = d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)})$. Complexity is $O(n^2 \\cdot 7)$.\n\n3. Transmission chain inference via threshold graph:\n   - Given a nonnegative integer threshold $t$, define an undirected graph $G=(V,E)$ where $V=\\{1,2,\\dots,n\\}$ indexes isolates and $\\{u,v\\} \\in E$ if and only if $D_{uv} \\le t$.\n   - The connected components of $G$ provide a principled, threshold-based clustering that proxies potential transmission chains: if $d(\\mathbf{a}^{(u)}, \\mathbf{a}^{(v)}) \\le t$, the isolates are \"adjacent\" in allelic space and thus plausibly connected in a recent transmission chain. Single-linkage connectivity integrates transitive relationships: if $u$ is close to $v$ and $v$ is close to $w$, all three belong to the same component even if $u$ and $w$ differ by more than $t$.\n   - Algorithmically, perform a breadth-first search (BFS) or depth-first search (DFS) from each unlabeled vertex to discover its component. Assign component labels beginning at $1$ in the order of first appearance when scanning isolates from index $1$ to $n$.\n\n4. Output construction:\n   - For each test case, output three items:\n     - ST assignments in isolate input order (list of integers).\n     - The distance matrix flattened in row-major order, including diagonal entries (list of integers).\n     - Connected component labels in isolate input order (list of integers starting at $1$).\n   - Aggregate the three test case outputs into a single list and print exactly one line containing this aggregate list, comma-separated and enclosed in square brackets, with no spaces.\n\nReasoning on the test suite:\n- Test Case $1$:\n  - Isolate profiles include exact matches to ST $1$, ST $2$, and ST $42$; one profile [[$1$,$2$,$3$,$4$,$5$,$6$,$7$]] appears twice, assigning ST $1$ to two isolates.\n  - With $t_1=1$, the graph connects isolates that differ at at most one locus. Isolates $1$ and $3$ have $d=0$ and are connected. Isolate $2$ differs by one locus from isolates $1$ and $3$ and connects to them. Isolate $4$ differs by two loci from isolates $1$ and $3$, so it does not connect under $t_1=1$, forming a separate component. The algorithm labels two components, with the first containing isolates $1$, $2$, $3$ and the second containing isolate $4$.\n- Test Case $2$:\n  - All isolates have identical profiles, each matching ST $7$. With $t_2=0$, edges exist only between identical profiles; all isolates are pairwise identical, so the graph is fully connected, resulting in a single component labeled $1$ for all isolates.\n- Test Case $3$:\n  - Two isolates match ST $10$ and ST $11$, respectively. The third isolate has a novel profile and is assigned $-1$. With $t_3=1$, the graph connects isolates differing by one locus. The second isolate acts as a bridge: it differs by one locus from both the first and third isolates, so all three isolates belong to a single connected component by transitivity, and all receive the same component label $1$.\n\nThese steps faithfully implement MLST-based ST assignment, allelic mismatch distance computation, and thresholded connectivity to infer plausible transmission chains, grounded in core definitions and standard practices in medical microbiology for Leptospira interrogans outbreak analysis.", "answer": "```python\n# Python 3.12\n# Libraries: numpy 1.23.5 (imported but not required), standard library only.\nimport numpy as np\nfrom collections import deque\n\ndef assign_sts(profiles, st_db):\n    \"\"\"\n    Assign ST by exact match. Unknown profiles get -1.\n    st_db: dict {ST_id: profile_list_of_7_ints}\n    profiles: list of profile_list_of_7_ints\n    returns: list of ST ids per profile\n    \"\"\"\n    # Invert database: profile tuple - ST id\n    profile_to_st = {tuple(v): k for k, v in st_db.items()}\n    sts = []\n    for p in profiles:\n        sts.append(profile_to_st.get(tuple(p), -1))\n    return sts\n\ndef allelic_distance(a, b):\n    \"\"\"Count mismatches across 7 loci.\"\"\"\n    return sum(1 for ai, bi in zip(a, b) if ai != bi)\n\ndef distance_matrix(profiles):\n    \"\"\"Compute full nxn allelic distance matrix.\"\"\"\n    n = len(profiles)\n    D = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                D[i][j] = 0\n            else:\n                D[i][j] = allelic_distance(profiles[i], profiles[j])\n    return D\n\ndef connected_components(D, t):\n    \"\"\"\n    Compute connected components under threshold t on distance matrix D.\n    Return component labels per vertex in input order, starting at 1.\n    \"\"\"\n    n = len(D)\n    labels = [0]*n\n    current_label = 0\n    for start in range(n):\n        if labels[start] != 0:\n            continue\n        current_label += 1\n        # BFS from start\n        queue = deque([start])\n        labels[start] = current_label\n        while queue:\n            u = queue.popleft()\n            for v in range(n):\n                if labels[v] == 0 and D[u][v] = t:\n                    labels[v] = current_label\n                    queue.append(v)\n    return labels\n\ndef flatten_row_major(matrix):\n    \"\"\"Flatten a matrix (list of lists) in row-major order including diagonal.\"\"\"\n    return [elem for row in matrix for elem in row]\n\ndef format_no_spaces(obj):\n    \"\"\"\n    Recursively format Python lists/ints/floats/bools without spaces,\n    enclosed in brackets for lists, with commas between elements.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_no_spaces(x) for x in obj) + \"]\"\n    elif isinstance(obj, bool):\n        return \"True\" if obj else \"False\"\n    elif isinstance(obj, (int, float)):\n        return str(obj)\n    else:\n        # Fallback for other types (should not occur in this task)\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        {\n            \"st_db\": {\n                1: [1,2,3,4,5,6,7],\n                2: [1,2,4,4,5,6,7],\n                42: [2,1,3,4,5,6,7],\n                5: [1,2,3,4,6,6,7],\n            },\n            \"profiles\": [\n                [1,2,3,4,5,6,7],\n                [1,2,4,4,5,6,7],\n                [1,2,3,4,5,6,7],\n                [2,1,3,4,5,6,7],\n            ],\n            \"t\": 1,\n        },\n        # Test Case 2\n        {\n            \"st_db\": {\n                7: [3,3,3,3,3,3,3],\n            },\n            \"profiles\": [\n                [3,3,3,3,3,3,3],\n                [3,3,3,3,3,3,3],\n                [3,3,3,3,3,3,3],\n            ],\n            \"t\": 0,\n        },\n        # Test Case 3\n        {\n            \"st_db\": {\n                10: [1,1,1,1,1,1,1],\n                11: [1,1,2,1,1,1,1],\n            },\n            \"profiles\": [\n                [1,1,1,1,1,1,1],\n                [1,1,2,1,1,1,1],\n                [1,2,2,1,1,1,1],\n            ],\n            \"t\": 1,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        st_db = case[\"st_db\"]\n        profiles = case[\"profiles\"]\n        t = case[\"t\"]\n\n        # ST assignment\n        sts = assign_sts(profiles, st_db)\n\n        # Distance matrix and flatten\n        D = distance_matrix(profiles)\n        D_flat = flatten_row_major(D)\n\n        # Connected components under threshold t\n        clusters = connected_components(D, t)\n\n        # Append result triple for this test case\n        results.append([sts, D_flat, clusters])\n\n    # Final print statement in the exact required format (no spaces).\n    print(format_no_spaces(results))\n\nsolve()\n```", "id": "4645693"}]}