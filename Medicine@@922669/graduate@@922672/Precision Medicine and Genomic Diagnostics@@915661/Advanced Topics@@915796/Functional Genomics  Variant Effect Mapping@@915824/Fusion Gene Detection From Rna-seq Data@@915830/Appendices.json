{"hands_on_practices": [{"introduction": "The first sign of a potential gene fusion in RNA-seq data is often a cluster of \"soft-clipped\" reads, where one part of a read maps to a known gene and the other part does not. This exercise simulates the foundational bioinformatics task of transforming these fragmented clues into a coherent hypothesis. By implementing a *de novo* assembly and mapping pipeline, you will learn how to reconstruct a novel junction sequence from raw read data and identify its potential partner gene, providing a hands-on look into the engine of modern fusion detection algorithms. [@problem_id:4342701]", "problem": "You are given a cluster of soft-clipped Ribonucleic Acid Sequencing (RNA-Seq) reads arising at a gene boundary. Each soft-clipped read is the unaligned suffix of a read whose prefix aligned to the boundary gene. The goal is to assemble the partner-side fusion junction sequence de novo from these soft-clipped reads and then, without prior knowledge of the partner gene identity, map the assembled sequence to a set of candidate transcript sequences to identify the most likely partner gene and its breakpoint coordinate.\n\nUse the following fundamental base and definitions as the starting point:\n- Central Dogma of Molecular Biology: Deoxyribonucleic Acid (DNA) is transcribed to Ribonucleic Acid (RNA), which is sequenced to produce short reads. Each read is a substring of an expressed transcript, possibly with random base-calling errors.\n- Sequencing error model: For a true nucleotide at a position, an observed base is independently substituted with probability $e \\in [0,1)$ to one of the other bases uniformly at random; with probability $(1-e)$ the observed base is correct.\n- Genome alignment and soft clipping: A soft-clipped suffix indicates that a read’s prefix aligns to a reference locus, while the suffix does not. In a gene fusion event, clustered soft-clipped suffixes at the boundary gene share a common origin in the partner transcript, starting at the fusion breakpoint.\n\nDesign and implement a program that, given clusters of soft-clipped reads and a transcriptome reference, does the following for each cluster:\n1. Assemble a consensus junction sequence by position-wise voting across soft-clipped reads assumed to be co-starting at the fusion breakpoint:\n   - Let $S = \\{s_1, \\ldots, s_n\\}$ be the set of soft-clipped sequences with lengths $\\ell_i$.\n   - For position $j = 0,1,\\ldots$, consider all reads with $\\ell_i > j$. Let $c_{j,b}$ be the count of base $b \\in \\{A,C,G,T\\}$ at position $j$, and let $m_j = \\max_b c_{j,b}$ and $t_j = \\sum_b c_{j,b}$.\n   - Define an inclusion threshold with two parameters: a relative majority $\\alpha \\in (0.5,1]$ and a minimum absolute coverage $C_{\\min} \\in \\mathbb{N}$.\n   - The consensus extends to position $j$ if and only if $m_j \\ge \\alpha \\cdot t_j$ and $t_j \\ge C_{\\min}$. When this fails for the first time, the assembly stops. The assembled consensus has length $L_{\\text{cons}}$ equal to the number of included positions.\n   - Define the support of the assembled consensus as $M_{\\min} = \\min_{0 \\le j < L_{\\text{cons}}} m_j$, or $0$ if $L_{\\text{cons}} = 0$.\n2. Map the assembled consensus to the transcriptome without prior knowledge of the partner gene:\n   - Use a seed-and-vote method. Let the $k$-mer size be $k \\in \\mathbb{N}$.\n   - Build an index from all $k$-mers of each reference transcript $T_r$ of length $L_r$, $r \\in \\{0,1,\\ldots,R-1\\}$, to their positions. For the consensus $x$ of length $L_{\\text{cons}}$, for each position $u \\in \\{0,\\ldots,L_{\\text{cons}}-k\\}$ with $k$-mer $x[u:u+k)$, retrieve occurrences in transcripts and compute offset votes $d = p - u$, where $p$ is the transcript position. For each transcript $r$, select the offset $d_r^\\star$ with the maximum votes.\n   - For each $(r, d_r^\\star)$, compute the edit distance $E_r$ between $x$ and the transcript window $T_r[d_r^\\star: d_r^\\star + L_{\\text{cons}})$, provided $0 \\le d_r^\\star$ and $d_r^\\star + L_{\\text{cons}} \\le L_r$.\n   - Accept the best $(r^\\star, d^\\star)$ if the normalized edit distance satisfies $E_{r^\\star} / L_{\\text{cons}} \\le \\tau$, for a threshold $\\tau \\in (0,1)$. If no candidate satisfies this, mapping fails.\n3. Define success for a cluster as a boolean indicating whether both assembly produced $L_{\\text{cons}} \\ge k$ and mapping succeeded.\n\nYour program must implement the above procedure and run a fixed test suite defined below. There is no external input; all parameters and data generation must be embedded in the program exactly as specified. The final output must be a single line printing the results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is a list in the form:\n- $[ \\text{success}, L_{\\text{cons}}, r^\\star, d^\\star, M_{\\min} ]$\nwhere $\\text{success}$ is a boolean, $L_{\\text{cons}}$ is an integer, $r^\\star$ is the predicted partner transcript integer identifier (or $-1$ if mapping fails), $d^\\star$ is the predicted partner breakpoint offset as an integer (or $-1$ if mapping fails), and $M_{\\min}$ is the integer minimal per-position support within the assembled consensus.\n\nUse the following fixed parameters for all test cases:\n- Majority threshold $\\alpha = 0.6$.\n- Minimum coverage $C_{\\min} = 3$.\n- Seed size $k = 7$.\n- Mapping acceptance threshold $\\tau = 0.15$.\n\nTranscriptome reference generation:\n- Use a pseudorandom generator initialized with seed $s_{\\text{tx}} = 1$ to generate $R = 3$ transcripts of lengths $[400, 420, 380]$ over the alphabet $\\{A,C,G,T\\}$ with uniform base probabilities. Let transcript identifiers be $r \\in \\{0,1,2\\}$ in the order generated.\n\nTest suite (each case provides a soft-clipped read cluster):\n- Case $1$ (happy path):\n  - Use seed $s_1 = 11$ for read simulation.\n  - True partner transcript $r = 1$, start $s = 120$, target segment length $L = 40$.\n  - Number of soft-clipped reads $n = 20$.\n  - Per-base error rate $e = 0.02$.\n  - For read $i$, draw a read length $\\ell_i$ uniformly at random from integers in $[30, 40]$; each read equals the first $\\ell_i$ bases of the true segment with independent substitutions at rate $e$.\n- Case $2$ (boundary condition: minimal cluster):\n  - Use seed $s_2 = 12$.\n  - True partner $r = 0$, start $s = 50$, target length $L = 25$.\n  - $n = 3$, $e = 0.01$, $\\ell_i$ uniformly from $[18, 25]$.\n- Case $3$ (noise robustness: mixture of signal and noise):\n  - Use seed $s_3 = 13$ for signal reads and $s_3' = 131$ for noise reads.\n  - True partner $r = 2$, start $s = 180$, target length $L = 35$.\n  - Signal reads: $n_{\\text{sig}} = 12$, $e = 0.03$, $\\ell_i$ from $[20, 35]$ as above.\n  - Noise reads: $n_{\\text{noise}} = 7$, each a random DNA string with length uniformly drawn from $[18, 35]$, independent of any transcript.\n- Case $4$ (edge case: no true signal):\n  - Use seed $s_4 = 14$.\n  - Pure noise: $n = 10$, each a random DNA string with length uniformly drawn from $[10, 20]$.\n\nAngle units are not involved, and there are no physical units. All integer intervals are inclusive. The edit distance is the standard Levenshtein distance with unit costs for substitutions, insertions, and deletions.\n\nFinal output format:\n- Your program should produce a single line of output containing a list of results, one per test case, where each result is itself a list as specified. For example, a valid format is\n  - $[[\\text{True}, 37, 1, 120, 12],[\\text{False}, 0, -1, -1, 0],\\ldots]$\nwith no spaces required between items.", "solution": "The problem requires the design and implementation of a computational pipeline to identify a partner gene in a fusion transcript event from a collection of soft-clipped RNA-Seq reads. This process is divided into two primary stages: first, the *de novo* assembly of a consensus sequence representing the partner-side of the fusion junction, and second, the alignment of this consensus sequence to a reference transcriptome to identify the partner gene and breakpoint.\n\nThe solution adheres to the principles of molecular biology and standard bioinformatics algorithms. The process begins with simulating the biological and technical artifacts, namely the generation of a reference transcriptome and the production of sequencing reads with errors, based on the provided stochastic models. This ensures a reproducible and well-defined environment for testing the algorithm.\n\n**1. Data Simulation: Transcriptome and Reads**\n\nFirst, a reference transcriptome is generated. This serves as the search space for identifying the fusion partner. A pseudorandom number generator, initialized with a fixed seed $s_{\\text{tx}} = 1$, is used to create $R=3$ transcripts with specified lengths of $[400, 420, 380]$. Each transcript is a sequence of nucleotides from the set $\\{A, C, G, T\\}$, with each base chosen with uniform probability. This mimics a simplified genome where base composition is uniform.\n\nNext, for each test case, a cluster of soft-clipped reads is simulated. This process models two key phenomena:\n- **Fusion Transcript Structure**: A true fusion event produces reads that originate from a specific segment of a partner transcript. Reads are thus generated as substrings of a \"true\" target segment from one of the reference transcripts, starting at a defined breakpoint.\n- **Sequencing Errors**: The process of high-throughput sequencing is imperfect. A simple substitution error model is employed, where each base in a read has a probability $e$ of being incorrectly identified as one of the other three bases (with uniform probability). With probability $1-e$, the base is read correctly.\n\nThe simulation for each test case is controlled by a separate random seed to ensure the entire experiment is deterministic and verifiable. Different cases model various scenarios: a clear signal (Case 1), a minimal signal at the detection threshold (Case 2), a signal mixed with random noise reads (Case 3), and a case with only noise (Case 4).\n\n**2. Step 1: De Novo Consensus Assembly**\n\nGiven a cluster of soft-clipped reads $S = \\{s_1, \\ldots, s_n\\}$, the goal is to reconstruct the most likely sequence of the partner transcript's junction. This is achieved through a position-wise voting mechanism. The underlying principle is that reads originating from the same fusion event will largely agree on the sequence, while sequencing errors or an admix of unrelated \"noise\" reads will appear as a minority signal.\n\nThe algorithm proceeds column by column, from position $j=0$ onwards:\n- For each position $j$, a count $c_{j,b}$ is tallied for each base $b \\in \\{A, C, G, T\\}$ across all reads that are long enough to cover this position.\n- The total number of reads covering position $j$ is the coverage, $t_j = \\sum_b c_{j,b}$.\n- The count of the most frequent base (the majority vote) is $m_j = \\max_b c_{j,b}$.\n- The assembly of the consensus sequence is extended to position $j$ only if two quality control criteria are met:\n    1. **Relative Majority**: The majority vote must represent a significant fraction of the reads, $m_j \\ge \\alpha \\cdot t_j$. The parameter $\\alpha = 0.6$ requires at least a $60\\%$ consensus.\n    2. **Minimum Coverage**: There must be a sufficient number of reads supporting the vote, $t_j \\ge C_{\\min}$. The parameter $C_{\\min} = 3$ guards against making decisions based on very few reads.\n- If both criteria are satisfied, the majority base is appended to the consensus sequence. The process terminates at the first position $j$ where either criterion is not met.\n\nThe length of the resulting sequence is the consensus length, $L_{\\text{cons}}$. The robustness of this assembly is quantified by the minimum support, $M_{\\min} = \\min_{0 \\le j < L_{\\text{cons}}} m_j$, which is the minimum number of agreeing reads at any position within the assembled consensus. If no consensus is formed ($L_{\\text{cons}}=0$), then $M_{\\min}=0$.\n\n**3. Step 2: Partner Transcript Mapping**\n\nOnce a consensus sequence $x$ of length $L_{\\text{cons}}$ is assembled, it must be mapped to the reference transcriptome to identify its origin. A direct brute-force alignment against all possible locations in all transcripts would be computationally expensive. Therefore, a more efficient 'seed-and-vote' heuristic is employed.\n\n- **Seeding**: The consensus sequence and all reference transcripts are decomposed into short, overlapping substrings of a fixed length $k=7$, known as $k$-mers. An index (a hash map) is built that maps every unique $k$-mer found in the transcriptome to a list of all its locations $(r, p)$, where $r$ is the transcript identifier and $p$ is the starting position.\n- **Voting**: The consensus sequence $x$ is scanned for its own $k$-mers, $x[u:u+k)$. For each such $k$-mer, its locations in the transcriptome are retrieved from the index. Each match, where $x[u:u+k)$ is identical to $T_r[p:p+k)$, \"votes\" for a potential alignment offset $d = p - u$. This offset represents the hypothesized start position of the consensus sequence within transcript $r$. All votes are aggregated by transcript and by offset.\n- **Candidate Selection**: For each transcript $r$, the offset $d_r^\\star$ that received the most votes is identified as the most plausible alignment start position. This constitutes a candidate alignment $(r, d_r^\\star)$.\n\n- **Verification**: The 'seed-and-vote' method only provides candidates; it does not guarantee a good full-length alignment. Each candidate $(r, d_r^\\star)$ is validated by computing the Levenshtein edit distance, $E_r$, between the full consensus sequence $x$ and the corresponding window in the transcript, $T_r[d_r^\\star : d_r^\\star + L_{\\text{cons}})$. This is only done for valid windows that do not extend beyond the transcript's boundaries. The Levenshtein distance counts the minimum number of single-character insertions, deletions, or substitutions required to change one string into the other, providing a robust measure of similarity.\n\n- **Acceptance**: To make the comparison fair across different consensus lengths, the edit distance is normalized by the consensus length, $E_r / L_{\\text{cons}}$. The candidate alignment $(r^\\star, d^\\star)$ with the minimum normalized edit distance is chosen as the best hit. This hit is finally accepted as a successful mapping only if its normalized edit distance is below a specified tolerance threshold, $E_{r^\\star} / L_{\\text{cons}} \\le \\tau$, where $\\tau=0.15$. This threshold allows for a small number of discrepancies, accommodating residual errors in the consensus or sequencing. If the best hit does not meet this criterion, or if no valid candidates were found, the mapping process fails.\n\n**4. Final Success Evaluation**\n\nA successful detection of a fusion partner for a given cluster of reads is contingent on passing two checkpoints, reflecting the confidence in both the assembled sequence and its mapping:\n1. The assembled consensus must be sufficiently long to be specific, i.e., $L_{\\text{cons}} \\ge k$. A length shorter than the seed size $k=7$ provides no basis for the seed-and-vote mapping strategy.\n2. The mapping of this consensus to the transcriptome must succeed as per the criteria defined above.\n\nIf both conditions are met, the `success` flag is set to `True`. Otherwise, it is `False`. The final result for each test case is a structured list containing this boolean flag, the consensus length $L_{\\text{cons}}$, the identified partner transcript $r^\\star$ and breakpoint $d^\\star$ (or $-1$ if mapping failed), and the minimum assembly support $M_{\\min}$.", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to run the full pipeline for all test cases.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    ALPHA = 0.6  # Majority threshold for consensus assembly\n    C_MIN = 3    # Minimum coverage for consensus assembly\n    K = 7        # k-mer size for seed-and-vote mapping\n    TAU = 0.15   # Normalized edit distance threshold for mapping acceptance\n    BASES = ['A', 'C', 'G', 'T']\n    \n    # --- Transcriptome Generation ---\n    def generate_transcriptome(seed, lengths, bases):\n        rng = np.random.default_rng(seed)\n        transcripts = []\n        for length in lengths:\n            transcript = \"\".join(rng.choice(bases, size=length))\n            transcripts.append(transcript)\n        return transcripts\n\n    tx_lengths = [400, 420, 380]\n    transcriptome = generate_transcriptome(seed=1, lengths=tx_lengths, bases=BASES)\n\n    # --- Levenshtein Distance Implementation ---\n    def levenshtein_distance(s1, s2):\n        m, n = len(s1), len(s2)\n        if m  n:\n            return levenshtein_distance(s2, s1)\n        if n == 0:\n            return m\n        \n        prev_row = np.arange(n + 1)\n        for i, c1 in enumerate(s1):\n            curr_row = np.zeros(n + 1, dtype=np.int32)\n            curr_row[0] = i + 1\n            for j, c2 in enumerate(s2):\n                insertions = prev_row[j + 1] + 1\n                deletions = curr_row[j] + 1\n                substitutions = prev_row[j] + (c1 != c2)\n                curr_row[j+1] = min(insertions, deletions, substitutions)\n            prev_row = curr_row\n        return int(prev_row[n])\n\n    # --- Read Generation ---\n    def generate_reads_for_case(case_params, transcripts):\n        reads = []\n        bases = BASES\n        \n        # Signal reads\n        if 's_sig' in case_params:\n            rng_sig = np.random.default_rng(case_params['s_sig'])\n            r, s, L, n, e = case_params['partner_info']\n            l_min, l_max = case_params['read_len_range_sig']\n            true_segment = transcripts[r][s : s + L]\n            \n            for _ in range(n):\n                read_len = rng_sig.integers(l_min, l_max, endpoint=True)\n                read = list(true_segment[:read_len])\n                for i in range(len(read)):\n                    if rng_sig.random()  e:\n                        original_base = read[i]\n                        alt_bases = [b for b in bases if b != original_base]\n                        read[i] = rng_sig.choice(alt_bases)\n                reads.append(\"\".join(read))\n\n        # Noise reads\n        if 's_noise' in case_params:\n            rng_noise = np.random.default_rng(case_params['s_noise'])\n            n_noise = case_params['n_noise']\n            l_min, l_max = case_params['read_len_range_noise']\n            for _ in range(n_noise):\n                read_len = rng_noise.integers(l_min, l_max, endpoint=True)\n                noise_read = \"\".join(rng_noise.choice(bases, size=read_len))\n                reads.append(noise_read)\n                \n        return reads\n\n    # --- Consensus Assembly ---\n    def assemble_consensus(reads, alpha, c_min):\n        if not reads:\n            return \"\", 0, 0\n        \n        max_len = max(len(r) for r in reads) if reads else 0\n        consensus_seq = []\n        support_values = []\n        \n        for j in range(max_len):\n            counts = defaultdict(int)\n            for read in reads:\n                if j  len(read):\n                    counts[read[j]] += 1\n            \n            t_j = sum(counts.values())\n            if t_j == 0:\n                break\n                \n            m_j = 0\n            majority_base = ''\n            if counts:\n                m_j = max(counts.values())\n                majority_base = max(counts, key=counts.get)\n            \n            if m_j >= alpha * t_j and t_j >= c_min:\n                consensus_seq.append(majority_base)\n                support_values.append(m_j)\n            else:\n                break\n        \n        consensus = \"\".join(consensus_seq)\n        L_cons = len(consensus)\n        M_min = min(support_values) if support_values else 0\n        \n        return consensus, L_cons, M_min\n\n    # --- Mapping ---\n    def map_consensus(consensus, L_cons, transcripts, k, tau):\n        # 1. Build k-mer index from transcriptome\n        kmer_index = defaultdict(list)\n        for r_idx, transcript in enumerate(transcripts):\n            for p in range(len(transcript) - k + 1):\n                kmer = transcript[p : p + k]\n                kmer_index[kmer].append((r_idx, p))\n\n        # 2. Vote for offsets\n        votes = defaultdict(lambda: defaultdict(int))\n        for u in range(L_cons - k + 1):\n            kmer = consensus[u : u + k]\n            if kmer in kmer_index:\n                for r_idx, p in kmer_index[kmer]:\n                    offset = p - u\n                    votes[r_idx][offset] += 1\n        \n        # 3. Find best candidate offsets and compute edit distance\n        candidates = []\n        for r_idx, offset_counts in votes.items():\n            if not offset_counts:\n                continue\n            \n            d_star = max(offset_counts, key=offset_counts.get)\n            \n            # Check if alignment window is valid\n            if 0 = d_star and d_star + L_cons = len(transcripts[r_idx]):\n                target_window = transcripts[r_idx][d_star : d_star + L_cons]\n                edit_dist = levenshtein_distance(consensus, target_window)\n                norm_dist = edit_dist / L_cons\n                candidates.append((norm_dist, r_idx, d_star))\n        \n        # 4. Find best overall candidate and check threshold\n        if not candidates:\n            return False, -1, -1\n        \n        candidates.sort() # Sort by normalized distance\n        best_norm_dist, best_r, best_d = candidates[0]\n        \n        if best_norm_dist = tau:\n            return True, best_r, best_d\n        else:\n            return False, -1, -1\n\n    # --- Main Processing Logic per Case ---\n    def process_case(case_params, transcripts, alpha, c_min, k, tau):\n        reads = generate_reads_for_case(case_params, transcripts)\n        consensus, L_cons, M_min = assemble_consensus(reads, alpha, c_min)\n        \n        r_star, d_star = -1, -1\n        map_succeeded = False\n        \n        if L_cons >= k:\n            map_succeeded, r_star, d_star = map_consensus(consensus, L_cons, transcripts, k, tau)\n        \n        success = (L_cons >= k) and map_succeeded\n        \n        return [success, L_cons, r_star, d_star, M_min]\n\n    # --- Test Suite Definition ---\n    test_cases = [\n        { # Case 1: Happy path\n            's_sig': 11, 'partner_info': (1, 120, 40, 20, 0.02),\n            'read_len_range_sig': (30, 40)\n        },\n        { # Case 2: Boundary condition: minimal cluster\n            's_sig': 12, 'partner_info': (0, 50, 25, 3, 0.01),\n            'read_len_range_sig': (18, 25)\n        },\n        { # Case 3: Noise robustness\n            's_sig': 13, 'partner_info': (2, 180, 35, 12, 0.03),\n            'read_len_range_sig': (20, 35),\n            's_noise': 131, 'n_noise': 7,\n            'read_len_range_noise': (18, 35)\n        },\n        { # Case 4: No true signal (pure noise)\n            's_noise': 14, 'n_noise': 10,\n            'read_len_range_noise': (10, 20)\n        }\n    ]\n\n    # --- Run Suite and Format Output ---\n    results = []\n    for case in test_cases:\n        result = process_case(case, transcriptome, ALPHA, C_MIN, K, TAU)\n        results.append(result)\n\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, r))}]' for r in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "4342701"}, {"introduction": "Detecting a chimeric transcript is only the first step; validating its authenticity is a critical challenge, as technical artifacts can often mimic true fusions. One of the most common mimics is transcriptional read-through, where RNA polymerase fails to terminate properly and continues transcribing into a downstream gene. This practice moves from discovery to validation by asking you to model this process mathematically, allowing you to develop a quantitative framework for setting distance-based thresholds to distinguish genuine chromosomal rearrangements from transcriptional noise. [@problem_id:4342694]", "problem": "You are tasked with formalizing and computing when intergenic transcriptional read-through can mimic a true chromosomal fusion in Ribonucleic Acid sequencing (RNA-seq), by modeling termination efficiency and polymerase processivity. Base your derivation on the Central Dogma of Molecular Biology and widely validated stochastic process models of transcription.\n\nAssume an upstream gene exhibits imperfect termination at its polyadenylation signal, such that a fraction of RNA polymerase II molecules fail to terminate and continue into downstream loci. Let termination efficiency be denoted by $e \\in [0,1]$, where $e$ is the probability of successful termination at the designated site, and $1-e$ is the probability of read-through initiation. Model the downstream progression of a read-through polymerase as a process with a constant per-base hazard of disengagement $\\lambda$ (in $\\text{bp}^{-1}$), leading to a survival probability across distance $d$ given by $S(d) = \\exp(-\\lambda d)$. Let $\\gamma  0$ denote the expected number of detectable junction-like reads at $d=0$ under the hypothetical absence of termination (i.e., a detection scaling factor aggregating transcript abundance, library sampling, and junction detection propensity). Under imperfect termination, the expected number of detectable read-through junction-like reads as a function of distance $d$ (in base pairs) is\n$$\n\\mu(d) = \\gamma \\,(1-e)\\,\\exp(-\\lambda d).\n$$\n\nA read-through event is considered \"unlikely to mimic a bona fide gene fusion\" if the probability of observing at least $t$ junction-like reads under the read-through model is bounded above by a user-specified false mimicry risk level $\\beta$, that is, if\n$$\n\\mathbb{P}(K \\ge t) \\le \\beta,\n$$\nwhere $K \\sim \\text{Poisson}(\\mu(d))$.\n\nYour objective is to write a complete, runnable program that, for each provided test case $(e, \\lambda, \\gamma, t, \\beta)$, computes the minimal integer distance threshold $d^\\star$ in base pairs such that the inequality $\\mathbb{P}(K \\ge t) \\le \\beta$ is satisfied. If $\\lambda = 0$ (no downstream disengagement), then $\\mu(d)$ is constant in $d$; in this special case, output $0$ if the inequality is already satisfied at $d=0$, and output $-1$ if no finite distance can satisfy the inequality. All outputs must be expressed in base pairs (bp) as integers.\n\nDesign your program to:\n\n- Use the model definitions above and derive an algorithm from first principles without shortcut formulas.\n- Exploit the monotonic dependence of $\\mathbb{P}(K \\ge t)$ on $d$ via $\\mu(d)$ to find $d^\\star$ efficiently.\n- Be robust to edge conditions, including $\\lambda = 0$ and $e = 1$.\n\nTest Suite:\n\nCompute $d^\\star$ for the following parameter sets, where each tuple is $(e, \\lambda, \\gamma, t, \\beta)$:\n\n- Case $1$: $(0.9, 1\\times 10^{-4}, 50, 3, 10^{-3})$\n- Case $2$: $(0.99, 5\\times 10^{-5}, 10, 1, 0.01)$\n- Case $3$: $(0.8, 5\\times 10^{-3}, 100, 5, 10^{-6})$\n- Case $4$: $(0.5, 0, 2, 2, 0.05)$\n\nFinal Output Format:\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the integer $d^\\star$ (in base pairs) for the corresponding test case, or $-1$ if no finite threshold exists under the rules above.", "solution": "The problem is deemed valid as it is scientifically grounded, well-posed, objective, and self-contained. The model uses established principles of molecular biology and stochastic processes, and the objective is a mathematically tractable optimization problem.\n\nThe problem asks for the minimal integer distance $d^\\star$ at which transcriptional read-through is unlikely to be mistaken for a gene fusion. This condition is formally stated as an inequality involving a Poisson-distributed random variable, whose mean is a function of the distance $d$.\n\nOur task is to find the smallest integer $d^\\star \\ge 0$ such that $\\mathbb{P}(K \\ge t) \\le \\beta$, where $K \\sim \\text{Poisson}(\\mu(d))$ and the mean parameter is given by $\\mu(d) = \\gamma (1-e) \\exp(-\\lambda d)$. The parameters are the termination efficiency $e$, the polymerase disengagement hazard $\\lambda$, a detection scaling factor $\\gamma$, a read count threshold $t$, and a risk level $\\beta$.\n\nThe core principle underpinning the solution is the monotonic relationship between the distance $d$ and the probability of interest, $\\mathbb{P}(K \\ge t)$. The Poisson survival function, $\\mathbb{P}(K \\ge t | \\mu)$, is a monotonically increasing function of its mean parameter, $\\mu$. The mean, $\\mu(d)$, is a monotonically decreasing function of distance $d$ for any positive disengagement hazard $\\lambda  0$. Consequently, the composite function $g(d) = \\mathbb{P}(K \\ge t | \\mu(d))$ is a monotonically decreasing function of $d$. This monotonicity guarantees that if the condition $\\mathbb{P}(K \\ge t) \\le \\beta$ is not met at $d=0$, there exists a unique threshold distance $d^\\star$ beyond which the inequality will hold.\n\nOur algorithmic strategy is to first determine the maximum permissible mean, let's call it $\\mu_{max}$, at which the Poisson survival probability does not exceed $\\beta$. We then find the minimum distance $d$ required to reduce the actual mean $\\mu(d)$ to this level.\n\nFirst, we find $\\mu_{max}$ by solving the boundary-condition equation:\n$$\n\\mathbb{P}(K \\ge t | \\mu_{max}) = \\beta\n$$\nThe survival function of a Poisson-distributed variable $K$ with integer threshold $t  0$ is related to the regularized lower incomplete gamma function, $P(a, x) = \\frac{\\gamma(a,x)}{\\Gamma(a)}$, where $\\gamma(a,x) = \\int_0^x u^{a-1}e^{-u}du$. The relation is:\n$$\n\\mathbb{P}(K \\ge t | \\mu) = \\sum_{k=t}^{\\infty} \\frac{e^{-\\mu}\\mu^k}{k!} = P(t, \\mu)\n$$\nTherefore, we must solve $P(t, \\mu_{max}) = \\beta$. This is an inverse problem. The solution is given by the inverse of the regularized lower incomplete gamma function, which is available in computational libraries. We define $\\mu_{max}$ as:\n$$\n\\mu_{max} = P^{-1}(t, \\beta)\n$$\nAny mean $\\mu \\le \\mu_{max}$ will satisfy the probability inequality.\n\nNext, we impose this condition on our distance-dependent mean $\\mu(d)$:\n$$\n\\mu(d) \\le \\mu_{max}\n$$\n$$\n\\gamma (1-e) \\exp(-\\lambda d) \\le \\mu_{max}\n$$\nThe solution for $d$ depends on the parameters, leading to a few distinct cases.\n\nCase 1: Normal Disengagement ($\\lambda  0$)\nLet's first consider the initial state at $d=0$, where the mean is $\\mu_0 = \\mu(0) = \\gamma(1-e)$. If $\\mu_0 \\le \\mu_{max}$, the condition is already satisfied at $d=0$. Since we seek the minimal integer distance, $d^\\star = 0$.\nIf $\\mu_0  \\mu_{max}$, we need to find a distance $d  0$. We solve the inequality for $d$:\n$$\n\\exp(-\\lambda d) \\le \\frac{\\mu_{max}}{\\gamma(1-e)}\n$$\nSince $\\mu_0  \\mu_{max}$, the right-hand side is less than $1$. We can take the natural logarithm of both sides:\n$$\n-\\lambda d \\le \\ln\\left(\\frac{\\mu_{max}}{\\gamma(1-e)}\\right)\n$$\nDividing by $-\\lambda$ (where $\\lambda  0$) reverses the inequality:\n$$\nd \\ge -\\frac{1}{\\lambda} \\ln\\left(\\frac{\\mu_{max}}{\\gamma(1-e)}\\right) = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\gamma(1-e)}{\\mu_{max}}\\right)\n$$\nThe minimal distance satisfying this is $d_{min} = \\frac{1}{\\lambda} \\ln\\left(\\frac{\\mu_0}{\\mu_{max}}\\right)$. Since the problem requires an integer distance, we must take the ceiling of this value:\n$$\nd^\\star = \\left\\lceil \\frac{1}{\\lambda} \\ln\\left(\\frac{\\gamma(1-e)}{\\mu_{max}}\\right) \\right\\rceil\n$$\n\nCase 2: No Disengagement ($\\lambda = 0$)\nIf $\\lambda=0$, the polymerase never disengages. The mean read count is constant for all distances:\n$$\n\\mu(d) = \\gamma(1-e) = \\mu_0\n$$\nThe probability $\\mathbb{P}(K \\ge t)$ is also constant. We evaluate this probability using $\\mu_0$.\n- If $\\mathbb{P}(K \\ge t | \\mu_0) \\le \\beta$, the condition is met for all distances, including $d=0$. The minimal integer distance is $d^\\star=0$.\n- If $\\mathbb{P}(K \\ge t | \\mu_0)  \\beta$, the condition is never met for any finite distance. As per the problem specification, the output must be $d^\\star = -1$.\n\nCase 3: Perfect Termination ($e=1$)\nIf termination is perfect, $1-e=0$. This implies $\\mu(d) = 0$ for all $d$. For any threshold $t \\ge 1$ and risk $\\beta \\ge 0$, $\\mathbb{P}(K \\ge t | \\mu=0) = 0 \\le \\beta$. The condition is met at $d=0$, so $d^\\star = 0$. This is a physically intuitive edge case.\n\nThe final algorithm is as follows:\n1. For a given set of parameters $(e, \\lambda, \\gamma, t, \\beta)$:\n2. If $e=1$, the result is $d^\\star = 0$.\n3. If $\\lambda=0$:\n    a. Calculate the constant mean $\\mu_0 = \\gamma(1-e)$.\n    b. Calculate the probability $P_0 = \\mathbb{P}(K \\ge t)$ for $K \\sim \\text{Poisson}(\\mu_0)$.\n    c. If $P_0 \\le \\beta$, set $d^\\star=0$. Otherwise, set $d^\\star=-1$.\n4. If $\\lambda  0$ and $e  1$:\n    a. Calculate the maximum allowed mean $\\mu_{max}$ by computing the inverse of the regularized incomplete gamma function, $\\mu_{max} = P^{-1}(t, \\beta)$.\n    b. Calculate the initial mean $\\mu_0 = \\gamma(1-e)$.\n    c. If $\\mu_0 \\le \\mu_{max}$, set $d^\\star=0$.\n    d. Otherwise, calculate $d^\\star = \\left\\lceil \\frac{1}{\\lambda} \\ln(\\frac{\\mu_0}{\\mu_{max}}) \\right\\rceil$ and cast to an integer.\nThis provides a complete and robust procedure to solve the problem for all specified conditions.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import special, stats\n\ndef solve():\n    \"\"\"\n    Computes the minimal integer distance threshold d* for transcriptional \n    read-through to be considered an unlikely mimic of a gene fusion.\n    \"\"\"\n    # Test cases are tuples of (e, lambda, gamma, t, beta)\n    test_cases = [\n        # Case 1: (e=0.9, lambda=1e-4, gamma=50, t=3, beta=1e-3)\n        (0.9, 1e-4, 50, 3, 1e-3),\n        # Case 2: (e=0.99, lambda=5e-5, gamma=10, t=1, beta=0.01)\n        (0.99, 5e-5, 10, 1, 0.01),\n        # Case 3: (e=0.8, lambda=5e-3, gamma=100, t=5, beta=1e-6)\n        (0.8, 5e-3, 100, 5, 1e-6),\n        # Case 4: (e=0.5, lambda=0, gamma=2, t=2, beta=0.05)\n        (0.5, 0, 2, 2, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        e, lam, gamma, t, beta = case\n        \n        # Boundary case: perfect termination (e=1)\n        # mu(d) is always 0. For t>=1, P( K>=t | mu=0 ) = 0 = beta.\n        # Thus, the condition is met at d=0.\n        if e == 1.0:\n            results.append(0)\n            continue\n            \n        # Case: No polymerase disengagement (lambda = 0)\n        if lam == 0:\n            mu_0 = gamma * (1 - e)\n            # The probability P(K >= t) is constant for all d.\n            # We check if the condition is met.\n            # scipy.stats.poisson.sf(k, mu) calculates P(K > k) = P(K >= k+1)\n            prob_at_0 = stats.poisson.sf(t - 1, mu_0)\n            \n            if prob_at_0 = beta:\n                # Condition is met at d=0, and for all d. Minimal distance is 0.\n                results.append(0)\n            else:\n                # Condition is never met.\n                results.append(-1)\n            continue\n\n        # Main case: Imperfect termination (e1) and polymerase disengagement (lambda > 0)\n        \n        # Step 1: Find the maximum allowed Poisson mean (mu_max) such that\n        # P(K >= t | mu_max) = beta.\n        # This is equivalent to solving P(t, mu_max) = beta, where P is the\n        # regularized lower incomplete gamma function.\n        # mu_max = gammaincinv(t, beta).\n        # We need to handle potential edge cases for gammaincinv.\n        # If beta is 0, mu_max is 0. If beta is 1, mu_max is inf. Test cases are well-behaved.\n        if t = 0: # t must be a positive integer for a valid threshold\n            # This case is not in the test suite but is a good practice check.\n            # P(K>=0) is 1, P(K>=t) for t0 is 1. If beta  1, impossible.\n            if beta  1.0:\n                results.append(-1) # Cannot be satisfied\n            else:\n                results.append(0) # Satisfied for any mu\n            continue\n\n        mu_max = special.gammaincinv(t, beta)\n\n        # Step 2: Calculate the mean at distance 0 (mu_0).\n        mu_0 = gamma * (1 - e)\n\n        # Step 3: Determine d_star based on mu_0 and mu_max.\n        if mu_0 = mu_max:\n            # The condition is already satisfied at d=0.\n            d_star = 0\n        else:\n            # We need to find the minimal d such that mu(d) = mu_max.\n            # gamma * (1-e) * exp(-lambda * d) = mu_max\n            # exp(-lambda * d) = mu_max / (gamma * (1-e))\n            # -lambda * d = log(mu_max / mu_0)\n            # d >= -1/lambda * log(mu_max / mu_0)\n            # d >= 1/lambda * log(mu_0 / mu_max)\n            d_min = (1 / lam) * np.log(mu_0 / mu_max)\n            d_star = int(np.ceil(d_min))\n            \n        results.append(d_star)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4342694"}, {"introduction": "The clinical significance of a gene fusion hinges on its functional consequences, chief among them being its ability to produce a chimeric protein with novel or unregulated activity. This exercise explores the molecular \"grammar\" that determines a fusion's translational outcome. By deriving and applying the rules of exon phase, you will determine whether a fusion transcript remains \"in-frame\" and, crucially, whether it preserves the essential components of a functional protein domain, such as the active site of a kinase. [@problem_id:4342762]", "problem": "A clinical RNA fusion detected by Ribonucleic Acid sequencing (RNA-seq) links the coding sequence of an upstream partner gene $A$ to the coding sequence of a downstream kinase gene $B$. The central dogma of molecular biology states that deoxyribonucleic acid is transcribed to ribonucleic acid and translated to protein, with translation reading messenger ribonucleic acid in triplet codons of length $3$ nucleotides per amino acid in a fixed reading frame. At exon junctions, the notion of exon phase is used: the phase at an exon boundary is the remainder $p \\in \\{0,1,2\\}$ when the cumulative coding nucleotide count up to that boundary is divided by $3$. A phase of $p=0$ indicates the boundary lies between codons; $p=1$ or $p=2$ indicates that $1$ or $2$ nucleotides of an incomplete codon spill across the junction, respectively.\n\nAn RNA-seq breakpoint connects the end of exon $E^{(A)}_{5}$ of gene $A$ (donor) to the start of exon $E^{(B)}_{7}$ of gene $B$ (acceptor). The donor exon end has phase $p_{\\text{up}}=1$. The acceptor exon start has phase $p_{\\text{down}}=1$. Downstream of exon $E^{(B)}_{7}$, all coding sequence from gene $B$ is retained without further alteration. Exon $E^{(B)}_{7}$ contributes amino acids indexed $[30,120]$ in the canonical protein of gene $B$. The annotated protein kinase domain of gene $B$ spans amino acid indices $[45,310]$, and the catalytic active site features are annotated at the following canonical positions in gene $B$:\n- the conserved lysine $K$ at index $a_{K}=72$,\n- the catalytic loop motif $\\mathrm{HRD}$ at indices $a_{H}=160$, $a_{R}=161$, $a_{D}=162$,\n- the activation segment motif $\\mathrm{DFG}$ at indices $a_{D'}=185$, $a_{F}=186$, $a_{G}=187$.\n\nStarting only from the codon triplet definition and the definition of exon phase above, first derive a criterion for whether the reading frame is preserved across a fusion junction in terms of the donor end phase $p_{\\text{up}}$ and the acceptor start phase $p_{\\text{down}}$. Then, using the given numerical values, determine whether the fusion preserves the kinase active site (meaning that the residues at indices $a_{K}$, $a_{H}$, $a_{R}$, $a_{D}$, $a_{D'}$, $a_{F}$, $a_{G}$ occur in the fused protein exactly as annotated in gene $B$). Express your final answer as a single integer, with $0$ indicating “not preserved” and $1$ indicating “preserved.”", "solution": "The problem asks for two main tasks: first, to derive a general criterion for the preservation of the reading frame across an RNA fusion junction based on exon phases; and second, to apply this criterion to a specific case of a gene fusion to determine if the active site of a kinase is preserved.\n\nFirst, let's establish the criterion for reading frame preservation. The reading frame is determined by the grouping of messenger RNA (mRNA) nucleotides into codons of length $3$. A continuous protein sequence is translated correctly only if these triplet groupings are maintained.\n\nLet the upstream partner gene be $A$ and the downstream partner gene be $B$. The fusion occurs at an exon boundary. Let $N_{\\text{up}}$ be the total number of nucleotides in the coding sequence (CDS) of gene $A$ from its start codon up to the fusion breakpoint (the end of the donor exon). The phase at this donor exon boundary, $p_{\\text{up}}$, is defined as the remainder of $N_{\\text{up}}$ when divided by $3$.\n$$p_{\\text{up}} = N_{\\text{up}} \\pmod{3}$$\nThis means that the upstream sequence from gene $A$ consists of a whole number of codons plus $p_{\\text{up}}$ extra nucleotides.\n\nSimilarly, let $N_{\\text{pre-down}}$ be the total number of nucleotides in the CDS of the canonical gene $B$ from its start codon up to the fusion breakpoint (the start of the acceptor exon). The phase at this acceptor exon boundary, $p_{\\text{down}}$, is defined as the remainder of $N_{\\text{pre-down}}$ when divided by $3$.\n$$p_{\\text{down}} = N_{\\text{pre-down}} \\pmod{3}$$\nThis means that in the context of the canonical gene $B$, the acceptor exon is preceded by a CDS sequence that consists of a whole number of codons plus $p_{\\text{down}}$ extra nucleotides.\n\nFor the reading frame of the downstream gene $B$ to be preserved in the fused transcript, the nucleotide sequence starting from the acceptor exon must be translated in the same frame as it would be in its canonical context.\nIn the canonical transcript of gene $B$, the position of a nucleotide within its codon is determined by its distance from the start codon. A nucleotide at position $j$ (1-indexed) within the acceptor exon has a total position of $N_{\\text{pre-down}} + j$ from the start of the gene $B$ CDS. Its position within a codon (0, 1, or 2) is given by $( (N_{\\text{pre-down}} + j) - 1 ) \\pmod 3$.\n\nIn the fused transcript, the same nucleotide at position $j$ within the acceptor exon is preceded by $N_{\\text{up}}$ nucleotides from gene $A$. Its total position from the start of the fusion CDS is $N_{\\text{up}} + j$. Its position within a codon is therefore $( (N_{\\text{up}} + j) - 1 ) \\pmod 3$.\n\nFor the reading frame to be preserved, these two codon positions must be identical for any nucleotide $j$ within the acceptor exon sequence.\n$$ ( (N_{\\text{pre-down}} + j) - 1 ) \\pmod 3 = ( (N_{\\text{up}} + j) - 1 ) \\pmod 3 $$\nThis simplifies to:\n$$ ( N_{\\text{pre-down}} - 1 ) \\pmod 3 = ( N_{\\text{up}} - 1 ) \\pmod 3 $$\nThis congruence holds if and only if $N_{\\text{pre-down}} \\equiv N_{\\text{up}} \\pmod 3$.\nUsing the definitions of phase, this is equivalent to the condition:\n$$ p_{\\text{down}} = p_{\\text{up}} $$\nThis equation is the criterion for the preservation of the reading frame across a fusion junction. A fusion satisfying this condition is termed \"in-frame\".\n\nNext, we apply this criterion to the specific case provided. The problem states that the donor exon end has phase $p_{\\text{up}}=1$ and the acceptor exon start has phase $p_{\\text{down}}=1$.\nSince $p_{\\text{up}} = 1$ and $p_{\\text{down}} = 1$, the condition $p_{\\text{up}} = p_{\\text{down}}$ is satisfied. Therefore, the fusion is in-frame, and the reading frame is preserved across the junction.\n\nNow, we must determine if the kinase active site is preserved. The preservation of the active site requires two conditions to be met:\n$1$. The reading frame must be preserved, ensuring that the amino acid sequence encoded by the downstream gene's exons is translated correctly. We have already established this is true.\n$2$. The portions of the coding sequence that encode the specific amino acid residues of the active site must be included in the final fused transcript.\n\nThe fusion connects the end of exon $E^{(A)}_{5}$ of gene $A$ to the start of exon $E^{(B)}_{7}$ of gene $B$. The problem states that exon $E^{(B)}_{7}$ contributes amino acids indexed $[30,120]$ in the canonical protein of gene $B$. It also states that downstream of exon $E^{(B)}_{7}$, all coding sequence from gene $B$ is retained. This means that the resulting fusion protein will contain an N-terminal portion from protein $A$, followed by the sequence of protein $B$ starting from amino acid position $30$ and continuing to its C-terminus.\n\nThe canonical positions of the active site residues in protein $B$ are given as:\n- $K$ at index $a_{K}=72$\n- $\\mathrm{HRD}$ motif at indices $a_{H}=160$, $a_{R}=161$, $a_{D}=162$\n- $\\mathrm{DFG}$ motif at indices $a_{D'}=185$, $a_{F}=186$, $a_{G}=187$\n\nWe must check if these amino acid positions are included in the part of protein $B$ that is retained in the fusion, which is the sequence from index $30$ onwards.\n- For Lysine ($K$) at $a_{K}=72$: $72 \\ge 30$. This residue is included.\n- For the $\\mathrm{HRD}$ motif at $a_{H}=160, a_{R}=161, a_{D}=162$: $160 \\ge 30$. This motif is included.\n- For the $\\mathrm{DFG}$ motif at $a_{D'}=185, a_{F}=186, a_{G}=187$: $185 \\ge 30$. This motif is included.\n\nSince the reading frame is preserved and the coding sequences for all specified active site residues are present in the fusion transcript (as their positions are all greater than or equal to the starting amino acid index $30$ from protein $B$), the active site will be correctly translated and is therefore preserved in the fusion protein.\n\nThe problem asks for the answer to be expressed as a single integer, with $1$ for \"preserved\" and $0$ for \"not preserved\". Based on our analysis, the active site is preserved. Thus, the answer is $1$.", "answer": "$$\\boxed{1}$$", "id": "4342762"}]}