{"hands_on_practices": [{"introduction": "A frequent source of error in bioinformatics is the mishandling of genomic coordinates, as different databases and file formats use incompatible systems. This exercise tackles this foundational challenge by having you convert between the 1-based, inclusive coordinates common in NCBI resources and the 0-based, half-open system used in formats like BED files [@problem_id:4318980]. Mastering this conversion is a critical first step toward building reliable data analysis pipelines and ensuring the integrity of your results.", "problem": "A researcher working in precision medicine needs to harmonize genomic interval data across assemblies and file formats for downstream integration with the National Center for Biotechnology Information (NCBI), the European Bioinformatics Institute (EBI), GenBank, the Reference Sequence (RefSeq), and the Single Nucleotide Polymorphism database (dbSNP). Three exon intervals for a clinically relevant gene were retrieved from Reference Sequence (RefSeq) on Genome Reference Consortium Human build 37 (GRCh37) in National Center for Biotechnology Information (NCBI) style, where coordinates are $1$-based and inclusive. The intervals on chromosome $7$ are:\n- Region $1$: start $s_{1} = 55321114$, end $e_{1} = 55321333$.\n- Region $2$: start $s_{2} = 55322001$, end $e_{2} = 55322231$.\n- Region $3$: start $s_{3} = 55323900$, end $e_{3} = 55323985$.\n\nA chain alignment–based assembly conversion for this locus indicates that within the locally colinear block containing all three intervals, the mapping to Genome Reference Consortium Human build 38 (GRCh38) is a linear offset on the positive strand: for any position $x$ in GRCh37, the corresponding position in GRCh38 is $x' = x + \\Delta$ with $\\Delta = 413$, and there are no internal gaps within any of the three intervals.\n\nThe data must be converted for use in the University of California, Santa Cruz genome browser as Browser Extensible Data (BED), which uses a $0$-based, half-open interval convention. Using only the foundational definitions of coordinate systems (that is, the meaning of $1$-based inclusive versus $0$-based half-open coordinates) and the given linear offset, do the following:\n1. Compute the boundary-corrected GRCh38 BED coordinates $(s'_{i}, e'_{i})$ for each region $i \\in \\{1,2,3\\}$.\n2. Compute the total pre-conversion length $$L_{\\mathrm{pre}} = \\sum_{i=1}^{3}\\left(e_{i} - s_{i} + 1\\right).$$\n3. Compute the total post-conversion length in BED convention $$L_{\\mathrm{post}} = \\sum_{i=1}^{3}\\left(e'_{i} - s'_{i}\\right).$$\n4. Verify equality by evaluating $L_{\\mathrm{post}} - L_{\\mathrm{pre}}$ and, assuming equality holds, report the common total length.\n\nExpress the final total length in base pairs (bp). No rounding is required; provide the exact integer value. Your final reported quantity must be a single real number.", "solution": "The problem requires the conversion of genomic interval coordinates from the GRCh37 assembly to the GRCh38 assembly, and simultaneously from NCBI's $1$-based, inclusive coordinate system to the Browser Extensible Data (BED) format's $0$-based, half-open system. We must then calculate the total length of the intervals before and after conversion and verify that the length is conserved.\n\nFirst, we establish the transformation rules. An interval in a $1$-based, inclusive system is denoted by $[s, e]$, representing the set of bases from position $s$ to position $e$, inclusive. The length of such an interval is calculated as $L = e - s + 1$. An interval in a $0$-based, half-open system is denoted by $[s', e')$, representing the set of bases from position $s'$ up to, but not including, position $e'$. The length of this interval is $L' = e' - s'$.\n\nThe conversion consists of two independent transformations:\n1.  An assembly liftover from GRCh37 to GRCh38, which is given as a linear offset $\\Delta = 413$. A position $x$ in GRCh37 corresponds to a position $x' = x + \\Delta$ in GRCh38.\n2.  A coordinate system change from $1$-based inclusive to $0$-based half-open.\n\nLet's derive the formula for the coordinate system change on a single assembly. For a $1$-based inclusive interval $[S, E]$, the first physical base is at position $S$ and the last is at position $E$. In a $0$-based system, the base at position $k$ has index $k-1$. Thus, the bases in the interval correspond to indices $\\{S-1, S, \\dots, E-1\\}$. A $0$-based half-open interval $[S_0, E_0)$ must start at the index of the first base, so $S_0 = S-1$. It must end one position after the index of the last base, so $E_0 = (E-1) + 1 = E$. The conversion rule is $[S, E] \\rightarrow [S-1, E)$.\n\nCombining these two transformations for an initial interval $[s_i, e_i]$ on GRCh37:\nFirst, apply the liftover offset $\\Delta = 413$. The interval in GRCh38 coordinates, but still $1$-based inclusive, is $[s_i + \\Delta, e_i + \\Delta]$.\nSecond, apply the coordinate system change. Let $S = s_i + \\Delta$ and $E = e_i + \\Delta$. The final $0$-based half-open coordinates $(s'_i, e'_i)$ are given by:\n$$s'_i = S - 1 = s_i + \\Delta - 1$$\n$$e'_i = E = e_i + \\Delta$$\n\nNow we perform the specified tasks.\n\n1. Compute the boundary-corrected GRCh38 BED coordinates $(s'_{i}, e'_{i})$ for each region $i \\in \\{1,2,3\\}$.\nThe given offset is $\\Delta = 413$.\n\nFor Region $1$: $s_1 = 55321114$, $e_1 = 55321333$.\n$s'_1 = s_1 + \\Delta - 1 = 55321114 + 413 - 1 = 55321526$.\n$e'_1 = e_1 + \\Delta = 55321333 + 413 = 55321746$.\nThe GRCh38 BED coordinates are $(s'_{1}, e'_{1}) = (55321526, 55321746)$.\n\nFor Region $2$: $s_2 = 55322001$, $e_2 = 55322231$.\n$s'_2 = s_2 + \\Delta - 1 = 55322001 + 413 - 1 = 55322413$.\n$e'_2 = e_2 + \\Delta = 55322231 + 413 = 55322644$.\nThe GRCh38 BED coordinates are $(s'_{2}, e'_{2}) = (55322413, 55322644)$.\n\nFor Region $3$: $s_3 = 55323900$, $e_3 = 55323985$.\n$s'_3 = s_3 + \\Delta - 1 = 55323900 + 413 - 1 = 55324312$.\n$e'_3 = e_3 + \\Delta = 55323985 + 413 = 55324398$.\nThe GRCh38 BED coordinates are $(s'_{3}, e'_{3}) = (55324312, 55324398)$.\n\n2. Compute the total pre-conversion length $L_{\\mathrm{pre}}$.\nThe length of each initial interval is $L_i = e_i - s_i + 1$.\n$L_1 = 55321333 - 55321114 + 1 = 219 + 1 = 220$ bp.\n$L_2 = 55322231 - 55322001 + 1 = 230 + 1 = 231$ bp.\n$L_3 = 55323985 - 55323900 + 1 = 85 + 1 = 86$ bp.\nThe total pre-conversion length is:\n$$L_{\\mathrm{pre}} = \\sum_{i=1}^{3} L_i = 220 + 231 + 86 = 537 \\text{ bp}.$$\n\n3. Compute the total post-conversion length $L_{\\mathrm{post}}$.\nThe length of each converted interval is $L'_i = e'_i - s'_i$.\n$L'_1 = 55321746 - 55321526 = 220$ bp.\n$L'_2 = 55322644 - 55322413 = 231$ bp.\n$L'_3 = 55324398 - 55324312 = 86$ bp.\nThe total post-conversion length is:\n$$L_{\\mathrm{post}} = \\sum_{i=1}^{3} L'_i = 220 + 231 + 86 = 537 \\text{ bp}.$$\n\n4. Verify equality and report the common total length.\nThe difference between the total lengths is $L_{\\mathrm{post}} - L_{\\mathrm{pre}} = 537 - 537 = 0$.\nThe equality holds, as expected. This can be shown analytically: the length of a converted interval is $L'_i = e'_i - s'_i = (e_i + \\Delta) - (s_i + \\Delta - 1) = e_i - s_i + 1 = L_i$. Thus, length is invariant under this specific transformation.\n\nThe common total length of the three exon intervals is $537$ base pairs.", "answer": "$$\n\\boxed{537}\n$$", "id": "4318980"}, {"introduction": "While raw genomic coordinates are fundamental, clinical variants are often described relative to a transcript's coding sequence using HGVS $c.$ notation. This practice challenges you to translate these transcript-centric variants into their absolute positions on the genomic reference, a crucial skill for validation and visualization [@problem_id:4319011]. By working through exon-intron structures, you will gain a practical understanding of how gene models bridge the gap between functional annotation and the linear genome.", "problem": "A clinical sequencing laboratory is validating internal conversion logic that maps Human Genome Variation Society (HGVS) coding DNA ($c.$) variant descriptions to absolute genomic base positions on the Genome Reference Consortium Human Build 38 (GRCh38). The gene of interest has a single curated Reference Sequence (RefSeq) transcript, National Center for Biotechnology Information (NCBI) RefSeq accession $NM\\_999999.1$, and is annotated on the positive strand of chromosome $12$. The European Bioinformatics Institute (EBI) genome browser and GenBank confirm the following exon intervals for this transcript on GRCh38, with coordinates reported as $1$-based, closed intervals inclusive of both ends:\n\n- Exon $1$: start $100{,}000{,}101$, end $100{,}000{,}300$.\n- Exon $2$: start $100{,}010{,}001$, end $100{,}010{,}150$.\n- Exon $3$: start $100{,}020{,}501$, end $100{,}021{,}000$.\n\nThe coding sequence start ($c.1$, first base of the adenine of the start codon) lies in exon $1$ at genomic coordinate $100{,}000{,}110$. The Single Nucleotide Polymorphism database (dbSNP) lists multiple clinically relevant variants for this gene, among which the laboratory wants to compute the absolute genomic positions for the following HGVS $c.$ variants relative to $NM\\_999999.1$:\n\n- $c.50\\text{G}>\\text{A}$,\n- $c.200\\text{C}>\\text{T}$,\n- $c.341+5\\text{G}>\\text{T}$,\n- $c.342-3\\text{A}>\\text{G}$.\n\nUse the foundational definitions of transcript splicing and HGVS $c.$ notation to derive a general mapping from $c.$ coordinates to genomic coordinates for a positive-strand transcript, then apply it to the specific exon structure and coding start provided to compute the absolute GRCh38 base positions for the four variants. You may assume canonical splicing with no alternative exons for $NM\\_999999.1$ and that $c.1$ is the first coding base and lies exactly $10$ bases into exon $1$ as stated. Report the four genomic base positions as integers on GRCh38, sorted in ascending order, and present them as a single row matrix. No rounding is required. Express the final answer solely as the row matrix of coordinates, with no units.", "solution": "The problem requires the mapping of Human Genome Variation Society (HGVS) coding DNA ($c.$) coordinates to absolute genomic positions on the Genome Reference Consortium Human Build 38 ($GRCh38$). This is a standard and fundamental task in genomic diagnostics.\n\nThe general principle for converting a $c.$ coordinate to a genomic coordinate for a gene on the positive ($+$) strand is to sum the lengths of the coding portions of the exons to create a contiguous reference sequence, and then map positions from this constructed sequence back to their corresponding locations on the chromosome.\n\nFirst, we must characterize the coding portions of the transcript $NM\\_999999.1$. We are given the genomic coordinates of three exons on chromosome $12$ and the location of the coding start, $c.1$.\n\nThe given exon coordinates are $1$-based and inclusive:\n- Exon $1$: start $S_1 = 100{,}000{,}101$, end $F_1 = 100{,}000{,}300$\n- Exon $2$: start $S_2 = 100{,}010{,}001$, end $F_2 = 100{,}010{,}150$\n- Exon $3$: start $S_3 = 100{,}020{,}501$, end $F_3 = 100{,}021{,}000$\n\nThe coding sequence start $c.1$ is at genomic position $C_{start} = 100{,}000{,}110$. This lies within Exon $1$, as $100{,}000{,}101 \\le 100{,}000{,}110 \\le 100{,}000{,}300$.\n\nWe can now determine the length and $c.$ coordinate range for the coding sequence within each exon.\n\n1.  **Exon 1 Analysis:**\n    The untranslated region (UTR) at the beginning of Exon $1$ has a length of $100{,}000{,}110 - 100{,}000{,}101 = 9$ bases. The coding sequence in Exon $1$ starts at $100{,}000{,}110$ and ends at the exon's end, $100{,}000{,}300$.\n    The length of the coding portion of Exon $1$ is $L_{c1} = F_1 - C_{start} + 1 = 100{,}000{,}300 - 100{,}000{,}110 + 1 = 191$ bases.\n    Thus, Exon $1$ contains the coding positions from $c.1$ to $c.191$.\n\n2.  **Exon 2 Analysis:**\n    Exon $2$ is fully coding. Its length is $L_{c2} = F_2 - S_2 + 1 = 100{,}010{,}150 - 100{,}010{,}001 + 1 = 150$ bases.\n    The coding sequence in Exon $2$ begins immediately after that of Exon $1$. The first $c.$ position in Exon $2$ is $191 + 1 = 192$.\n    The last $c.$ position in Exon $2$ is $192 + 150 - 1 = 341$.\n    Thus, Exon $2$ contains the coding positions from $c.192$ to $c.341$.\n\n3.  **Exon 3 Analysis:**\n    Exon $3$ is also treated as fully coding for the scope of this problem. Its length is $L_{c3} = F_3 - S_3 + 1 = 100{,}021{,}000 - 100{,}020{,}501 + 1 = 500$ bases.\n    The coding sequence in Exon $3$ begins after Exon $2$. The first $c.$ position is $341 + 1 = 342$.\n    Thus, Exon $3$ contains coding positions starting from $c.342$.\n\nThis establishes the mapping:\n- Exon $1$: $c.1$ to $c.191$ corresponds to genomic positions [$100{,}000{,}110, 100{,}000{,}300$].\n- Exon $2$: $c.192$ to $c.341$ corresponds to genomic positions [$100{,}010{,}001, 100{,}010{,}150$].\n- Exon $3$: $c.342$ to $c.841$ corresponds to genomic positions [$100{,}020{,}501, 100{,}021{,}000$].\n\nNow, we can compute the genomic position for each specified variant.\n\n**Variant 1: $c.50\\text{G}>\\text{A}$**\nThe position $c.50$ falls within the range of Exon $1$ ($1 \\le 50 \\le 191$). The genomic coordinate is found by calculating the offset from the start of the coding sequence.\nGenomic Position = $C_{start} + (\\text{c.position} - 1) = 100{,}000{,}110 + (50 - 1) = 100{,}000{,}110 + 49 = 100{,}000{,}159$.\n\n**Variant 2: $c.200\\text{C}>\\text{T}$**\nThe position $c.200$ falls within the range of Exon $2$ ($192 \\le 200 \\le 341$). The genomic coordinate is found by calculating the offset from the start of Exon $2$. The first $c.$ position in Exon $2$ is $c.192$.\nThe offset from the start of Exon $2$'s coding sequence is $200 - 192 = 8$ bases.\nGenomic Position = $S_2 + \\text{offset} = 100{,}010{,}001 + 8 = 100{,}010{,}009$.\n\n**Variant 3: $c.341+5\\text{G}>\\text{T}$**\nThis variant is intronic. The position $c.341$ is the last coding base of Exon $2$. Its genomic position is the end of Exon $2$, $F_2 = 100{,}010{,}150$. The $+5$ notation indicates a position $5$ bases into the following intron. Since the gene is on the positive strand, we add to the genomic coordinate.\nGenomic Position = $F_2 + 5 = 100{,}010{,}150 + 5 = 100{,}010{,}155$.\n\n**Variant 4: $c.342-3\\text{A}>\\text{G}$**\nThis variant is also intronic. The position $c.342$ is the first coding base of Exon $3$. Its genomic position is the start of Exon $3$, $S_3 = 100{,}020{,}501$. The $-3$ notation indicates a position $3$ bases into the preceding intron. For a positive strand gene, we subtract from the genomic coordinate.\nGenomic Position = $S_3 - 3 = 100{,}020{,}501 - 3 = 100{,}020{,}498$.\n\nThe four computed absolute genomic positions on $GRCh38$ are:\n1. $100{,}000{,}159$\n2. $100{,}010{,}009$\n3. $100{,}010{,}155$\n4. $100{,}020{,}498$\n\nThe problem requires these positions to be sorted in ascending order. The calculated order is already ascending.\nThe final result is the ordered list of these four integer coordinates.", "answer": "$$\\boxed{\\begin{pmatrix} 100000159 & 100010009 & 100010155 & 100020498 \\end{pmatrix}}$$", "id": "4319011"}, {"introduction": "In practice, a single genetic variant can be described by a dizzying array of identifiers from sources like dbSNP, RefSeq, and clinical reports. To make sense of this data, a robust bioinformatic pipeline must first normalize these heterogeneous inputs into a single, canonical format. This capstone exercise guides you through the process of designing such a normalization engine, handling identifiers from rsIDs to HGVS and SPDI notations [@problem_id:4319014]. Successfully completing this task demonstrates your ability to integrate multiple genomic data concepts into a cohesive, automated solution.", "problem": "You are to implement a complete, runnable program that normalizes heterogeneous genomic variant identifiers into a unified canonical reference context suitable for precision medicine curation. The program must not use any external data sources; instead, it must operate on a self-contained, explicitly defined miniature knowledge base and follow formal, deterministic rules grounded in standard genomics representations. The setting reflects how identifiers from National Center for Biotechnology Information (NCBI), European Bioinformatics Institute (EBI), GenBank, Reference Sequence (RefSeq), and the Single Nucleotide Polymorphism database (dbSNP) are harmonized in genomic diagnostics pipelines.\n\nThe canonical reference context is defined as a quadruple $\\langle R, p, d, i \\rangle$:\n- $R$ is an integer code for the genomic reference accession root (version-stripped), uniquely representing the canonical reference sequence.\n- $p$ is the zero-based genomic coordinate where the change is anchored.\n- $d$ is an integer encoding of the deleted sequence.\n- $i$ is an integer encoding of the inserted sequence.\n\nThe program must accept and normalize mixed inputs in the following forms:\n- Reference Single Nucleotide Polymorphism cluster identifier (rsID) from the Single Nucleotide Polymorphism database (dbSNP), e.g., “rs…”.\n- Human Genome Variation Society (HGVS) expressions at the genomic level (“g.”) or coding DNA level (“c.”), e.g., “NC_000019.10:g.1101G>A” or “NM_000001.2:c.201G>A”.\n- Substitution-Position-Deletion-Insertion (SPDI), e.g., “NC_000019.10:1100:G:A”.\n- RefSeq Accession.version alone (no variant), e.g., “NC_000017.11”.\n\nYour task is to implement normalization rules strictly from the following fundamental bases and facts:\n- The Central Dogma of Molecular Biology: Deoxyribonucleic acid (DNA) is transcribed to Ribonucleic acid (RNA) and translated to protein; RefSeq transcripts are oriented according to gene transcription and can be on the positive or negative genomic strand.\n- Coordinate systems: Genomic loci may be represented in one-based coordinates at the genomic HGVS level and zero-based coordinates in SPDI.\n- Versioned accessions (e.g., “NC_000019.10”) share a versionless root (e.g., “NC_000019”), which is used as the canonical reference key. For this exercise, consider all versions of a given root to have identical coordinate systems.\n- Reverse complements for negative strand mapping: If a transcript is on the negative genomic strand, bases from the transcript must be reverse-complemented to derive the corresponding genomic alleles.\n\nCanonical reference context details:\n- Reference accession root to integer code mapping:\n  - $R(\\text{\"NC\\_000019\"}) = 19$\n  - $R(\\text{\"NC\\_000017\"}) = 17$\n- The terminator-based base-$5$ integer encoding $E(s)$ for a Deoxyribonucleic acid (DNA) string $s$ over $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$ is defined as follows. Let the digit map be $\\text{A} \\mapsto 1$, $\\text{C} \\mapsto 2$, $\\text{G} \\mapsto 3$, $\\text{T} \\mapsto 4$, and append a terminator with digit $0$ to the end. Then\n$$\nE(s) = \\sum_{k=0}^{L} d_k \\cdot 5^k,\n$$\nwhere $s$ has length $L$, $d_k$ is the digit of the $k$-th character for $k \\in \\{0,\\dots,L-1\\}$, and $d_L = 0$ is the terminator. By construction, $E(\\text{\"\"}) = 0$, and different sequences yield different integers.\n- Reverse complement is computed basewise via $\\mathrm{rc}(\\text{A})=\\text{T}$, $\\mathrm{rc}(\\text{T})=\\text{A}$, $\\mathrm{rc}(\\text{C})=\\text{G}$, $\\mathrm{rc}(\\text{G})=\\text{C}$; for a string, reverse the string and complement each base.\n\nCurated, self-contained knowledge base:\n- Canonical genomic references are restricted to the accessions with roots “NC_000019” and “NC_000017”. All versions of each root are treated as coordinate-identical for this exercise.\n- rsID to genomic mapping (all coordinates zero-based in this table):\n  - $\\text{rs1000001} \\mapsto (\\text{\"NC\\_000019.10\"}, p=1100, \\text{ref}=\\text{\"G\"}, \\text{alt}=\\text{\"A\"})$\n  - $\\text{rs2000002} \\mapsto (\\text{\"NC\\_000017.11\"}, p=1800, \\text{ref}=\\text{\"A\"}, \\text{alt}=\\text{\"T\"})$\n  - $\\text{rs3000003} \\mapsto (\\text{\"NC\\_000017.11\"}, p=500, \\text{ref}=\\text{\"TA\"}, \\text{alt}=\\text{\"\"})$\n- Transcript to genomic mapping (linear, single-segment models; all ranges inclusive):\n  - $\\text{\"NM\\_000001.2\"}$: genomic reference $\\text{\"NC\\_000019.10\"}$, positive strand, coding range $c \\in [1,10000]$ maps to genomic range $g \\in [901,10900]$ with $g = 900 + c$.\n  - $\\text{\"NM\\_000002.1\"}$: genomic reference $\\text{\"NC\\_000017.11\"}$, negative strand, coding range $c \\in [1,1000]$ maps to genomic range $g \\in [901,1900]$ with $g = 1900 - (c - 1)$.\n\nNormalization rules:\n1. For rsID inputs, obtain $(\\text{acc.version}, p, \\text{ref}, \\text{alt})$ from the curated table; strip the version from the accession to get its root, convert the root to $R$ using the table, and produce $\\langle R, p, E(\\text{ref}), E(\\text{alt}) \\rangle$.\n2. For HGVS genomic inputs “acc.version:g.PREF>ALT”, parse one-based $P$ and alleles $\\text{REF}$ and $\\text{ALT}$, then compute $p=P-1$, strip version to root, get $R$, and produce $\\langle R, p, E(\\text{REF}), E(\\text{ALT}) \\rangle$.\n3. For HGVS coding inputs “tx.version:c.CREF>ALT”, parse one-based $C$, transcript $tx.version$, and alleles on the transcript. Use the transcript’s mapping to compute genomic one-based $G$ as:\n   - Positive strand: $G = g_{\\text{start}} + (C - 1)$.\n   - Negative strand: $G = g_{\\text{end}} - (C - 1)$.\n   Then $p = G - 1$. Let $(\\text{REF}, \\text{ALT})$ be the genomic alleles:\n   - Positive strand: $(\\text{REF}, \\text{ALT}) = (\\text{CREF}, \\text{CALT})$.\n   - Negative strand: $(\\text{REF}, \\text{ALT}) = (\\mathrm{rc}(\\text{CREF}), \\mathrm{rc}(\\text{CALT}))$.\n   Strip the transcript’s associated genomic accession to its root and map to $R$. Output $\\langle R, p, E(\\text{REF}), E(\\text{ALT}) \\rangle$.\n4. For SPDI “acc.version:pos:del:ins”, use $p=\\text{pos}$ as given (zero-based), $(\\text{del},\\text{ins})$ as strings (possibly empty), strip version to root and map to $R$, and output $\\langle R, p, E(\\text{del}), E(\\text{ins}) \\rangle$.\n5. For a bare RefSeq Accession.version with no variant, output $\\langle R, -1, 0, 0 \\rangle$ after mapping to $R$.\n6. For any input with an accession whose root is not one of the defined canonical references, or any input that fails to parse or map, output $\\langle -1, -1, -1, -1 \\rangle$.\n\nAngle units are not applicable. There are no physical units in the outputs. All numeric outputs must be integers as specified.\n\nTest suite:\nYour program must compute results for the following inputs, in this exact order, using the rules above:\n1. “rs1000001”\n2. “NC_000019.10:g.1101G>A”\n3. “NM_000001.2:c.201G>A”\n4. “NC_000019.10:1100:G:A”\n5. “NC_000017.11”\n6. “NC_000019.9:1100:G:A”\n7. “rs3000003”\n8. “NM_000002.1:c.100T>A”\n9. “NC_000017.11:499:TA:”\n10. “NC_000017.11:g.1801A>T”\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list of four integers in the order $[R,p,d,i]$. For example: “[ [r1,p1,d1,i1], [r2,p2,d2,i2], ... ]” but without spaces is also acceptable. The required output for the problem must be generated by your program and must reflect the canonicalization defined above.", "solution": "The problem presented requires the implementation of a deterministic normalization pipeline for heterogeneous genomic variant identifiers. This task is fundamental in precision medicine and genomic diagnostics, where variant data from disparate sources must be collated into a unified and computable format for analysis and interpretation. The solution will be designed based on rigorous adherence to the provided rules and knowledge base, reflecting a microcosm of real-world bioinformatic data harmonization challenges.\n\nThe core of the solution is to transform various input formats—Reference Single Nucleotide Polymorphism cluster identifiers (rsIDs), Human Genome Variation Society (HGVS) notations, and Substitution-Position-Deletion-Insertion (SPDI) formats—into a single canonical reference context. This canonical representation is a quadruple $\\langle R, p, d, i \\rangle$, where $R$ is an integer code for the reference sequence, $p$ is the zero-based genomic coordinate, and $d$ and $i$ are integer encodings of the deleted and inserted sequences, respectively.\n\nFirst, we establish the necessary data structures and helper functions as defined in the problem statement. This includes:\n1.  A mapping from reference accession roots to their integer codes $R$: $R(\\text{\"NC\\_000019\"}) = 19$ and $R(\\text{\"NC\\_000017\"}) = 17$. Any accession is first stripped of its version (e.g., `.10`) to obtain its root for this mapping.\n2.  The curated knowledge base, containing mappings from rsIDs to their genomic context and from transcript accessions to their genomic alignments, including strand and coordinate transformation rules.\n3.  A base-$5$ integer encoding function, $E(s)$, for DNA sequences. For a sequence $s$ of length $L$ over the alphabet $\\{\\text{A, C, G, T}\\}$, with a digit map $\\text{A} \\mapsto 1, \\text{C} \\mapsto 2, \\text{G} \\mapsto 3, \\text{T} \\mapsto 4$, the encoding is defined as $E(s) = \\sum_{k=0}^{L} d_k \\cdot 5^k$. Here, $d_k$ is the digit of the $k$-th character of $s$ for $k < L$, and $d_L=0$ is a terminator digit. This construction ensures a unique integer for every unique sequence, with the empty string encoding to $E(\\text{\"\"})=0$.\n4.  A reverse complement function, $\\mathrm{rc}(s)$, which reverses a DNA string and complements each base according to the pairs $\\text{A} \\leftrightarrow \\text{T}$ and $\\text{C} \\leftrightarrow \\text{G}$. This is crucial for handling variants on the negative genomic strand.\n\nThe main normalization logic will proceed by identifying the format of the input string and applying the corresponding rule. A robust method for this is to use regular expressions to pattern-match each of the specified input formats. The implementation will test for each format in a specific order to ensure unambiguous classification.\n\n1.  **rsID (e.g., “rs1000001”):** For an input matching the rsID format, Rule $1$ is applied. The identifier is used as a key to look up its genomic context $(\\text{accession}, p, \\text{ref}, \\text{alt})$ in the provided table. The reference accession's root is extracted and mapped to the integer code $R$. The position $p$ is already given in the required zero-based format. The reference and alternate alleles, $\\text{ref}$ and $\\text{alt}$, are encoded using the $E(s)$ function to produce $d$ and $i$. The final output is $\\langle R, p, d, i \\rangle$.\n\n2.  **HGVS Genomic (e.g., “NC_000019.10:g.1101G>A”):** For an HGVS `g.` notation, Rule $2$ is applied. The accession and variant details are parsed. The accession's root yields $R$. The one-based coordinate $P$ from the `g.` notation (e.g., $1101$) is converted to the zero-based coordinate $p$ via the formula $p = P - 1$. The reference ($\\text{REF}$) and alternate ($\\text{ALT}$) alleles are extracted and encoded to $d$ and $i$. The output is $\\langle R, p, d, i \\rangle$.\n\n3.  **HGVS Coding (e.g., “NM_000001.2:c.201G>A”):** For an HGVS `c.` notation, Rule $3$ is the most complex. The transcript accession is used to retrieve its genomic mapping information: the genomic reference, the strand, and the coordinate mapping rule.\n    - The genomic one-based coordinate $G$ is calculated from the coding one-based coordinate $C$.\n        - If the transcript is on the **positive strand**, the mapping is linear and increasing: $G = g_{\\text{start}} + (C - 1)$.\n        - If the transcript is on the **negative strand**, the mapping is inverted: $G = g_{\\text{end}} - (C - 1)$.\n    - The zero-based genomic coordinate is then $p = G - 1$.\n    - Allele transformation also depends on the strand.\n        - On the **positive strand**, the genomic alleles are identical to the transcript alleles: $(\\text{REF}, \\text{ALT}) = (\\text{CREF}, \\text{CALT})$.\n        - On the **negative strand**, the genomic alleles are the reverse complement of the transcript alleles: $(\\text{REF}, \\text{ALT}) = (\\mathrm{rc}(\\text{CREF}), \\mathrm{rc}(\\text{CALT}))$.\n    - Finally, the associated genomic accession's root is mapped to $R$, and the derived genomic alleles are encoded to produce $\\langle R, p, E(\\text{REF}), E(\\text{ALT}) \\rangle$.\n\n4.  **SPDI (e.g., “NC_000019.10:1100:G:A”):** For an SPDI string, Rule $4$ is applied. The components `accession`, `pos`, `del`, `ins` are parsed. The accession's root gives $R$. The position `pos` is already zero-based, so $p = \\text{pos}$. The `del` and `ins` sequences are directly encoded to $d$ and $i$. The output is $\\langle R, p, E(\\text{del}), E(\\text{ins}) \\rangle$.\n\n5.  **Bare Accession (e.g., “NC_000017.11”):** For an input that is only a reference accession, Rule $5$ applies. The root is mapped to $R$, and the result is the special quadruple $\\langle R, -1, 0, 0 \\rangle$, indicating a reference context without a specific variant.\n\n6.  **Error Handling:** For any input that does not match the defined formats, or contains an accession root not in our knowledge base, or fails any other parsing step, Rule $6$ dictates the output must be the error quadruple $\\langle -1, -1, -1, -1 \\rangle$.\n\nThis systematic, rule-based approach ensures that every valid input is processed deterministically into the canonical format, providing a solid foundation for downstream computational tasks in a precision medicine workflow.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport re\n# numpy and scipy are not needed for this problem's logic.\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and print output.\n    \"\"\"\n\n    # --- Self-Contained Knowledge Base and Constants ---\n    \n    REF_ACCESSION_ROOT_TO_CODE = {\"NC_000019\": 19, \"NC_000017\": 17}\n    \n    RSID_TO_GENOMIC = {\n        \"rs1000001\": (\"NC_000019.10\", 1100, \"G\", \"A\"),\n        \"rs2000002\": (\"NC_000017.11\", 1800, \"A\", \"T\"),\n        \"rs3000003\": (\"NC_000017.11\", 500, \"TA\", \"\"),\n    }\n\n    TX_TO_GENOMIC_MAP = {\n        \"NM_000001.2\": {\n            \"gen_acc\": \"NC_000019.10\",\n            \"strand\": \"+\",\n            \"g_start\": 901,\n            \"g_end\": 10900,\n        },\n        \"NM_000002.1\": {\n            \"gen_acc\": \"NC_000017.11\",\n            \"strand\": \"-\",\n            \"g_start\": 901,\n            \"g_end\": 1900,\n        },\n    }\n\n    BASE_TO_DIGIT = {\"A\": 1, \"C\": 2, \"G\": 3, \"T\": 4}\n    BASE_COMPLEMENT = {\"A\": \"T\", \"T\": \"A\", \"C\": \"G\", \"G\": \"C\"}\n    ERROR_RESULT = [-1, -1, -1, -1]\n\n    # --- Helper Functions ---\n\n    def get_root_and_R(accession):\n        \"\"\"Strips version from accession and maps root to integer code R.\"\"\"\n        root_match = re.match(r\"([^_]+_\\d+)\", accession)\n        if not root_match:\n            return None\n        root = root_match.group(1)\n        return REF_ACCESSION_ROOT_TO_CODE.get(root)\n\n    def encode_sequence(s):\n        \"\"\"Computes the base-5 integer encoding E(s) for a DNA sequence.\"\"\"\n        encoding = 0\n        for i, base in enumerate(s):\n            encoding += BASE_TO_DIGIT[base] * (5 ** i)\n        return encoding\n\n    def reverse_complement(s):\n        \"\"\"Computes the reverse complement of a DNA sequence.\"\"\"\n        return \"\".join(BASE_COMPLEMENT.get(b, '') for b in reversed(s))\n\n    # --- Main Normalization Logic ---\n\n    def normalize(input_str):\n        \"\"\"\n        Normalizes a genomic variant identifier to the canonical <R, p, d, i> context.\n        \"\"\"\n        # Rule 1: rsID\n        if input_str.startswith(\"rs\"):\n            if input_str in RSID_TO_GENOMIC:\n                acc, p, ref, alt = RSID_TO_GENOMIC[input_str]\n                R = get_root_and_R(acc)\n                if R is None: return ERROR_RESULT\n                d = encode_sequence(ref)\n                i = encode_sequence(alt)\n                return [R, p, d, i]\n            else:\n                return ERROR_RESULT\n        \n        # Using regex for robust parsing of different formats\n        \n        # Rule 4: SPDI (checked before other colon-containing formats for clarity)\n        # Format: acc.version:pos:del:ins\n        spdi_match = re.fullmatch(r\"([^:]+):(\\d+):([ACGT]*):([ACGT]*)\", input_str)\n        if spdi_match:\n            acc, pos_str, del_seq, ins_seq = spdi_match.groups()\n            R = get_root_and_R(acc)\n            if R is None: return ERROR_RESULT\n            p = int(pos_str)\n            d = encode_sequence(del_seq)\n            i = encode_sequence(ins_seq)\n            return [R, p, d, i]\n\n        # Rule 2: HGVS genomic\n        # Format: acc.version:g.PREF>ALT\n        hgvs_g_match = re.fullmatch(r\"([^:]+):g\\.(\\d+)([ACGT]+)>([ACGT]+)\", input_str)\n        if hgvs_g_match:\n            acc, p_str, ref, alt = hgvs_g_match.groups()\n            R = get_root_and_R(acc)\n            if R is None: return ERROR_RESULT\n            P = int(p_str)\n            p = P - 1\n            d = encode_sequence(ref)\n            i = encode_sequence(alt)\n            return [R, p, d, i]\n            \n        # Rule 3: HGVS coding\n        # Format: tx.version:c.CREF>ALT\n        hgvs_c_match = re.fullmatch(r\"([^:]+):c\\.(\\d+)([ACGT]+)>([ACGT]+)\", input_str)\n        if hgvs_c_match:\n            tx_version, c_str, cref, calt = hgvs_c_match.groups()\n            if tx_version not in TX_TO_GENOMIC_MAP: return ERROR_RESULT\n            \n            tx_info = TX_TO_GENOMIC_MAP[tx_version]\n            gen_acc = tx_info[\"gen_acc\"]\n            R = get_root_and_R(gen_acc)\n            if R is None: return ERROR_RESULT\n            \n            C = int(c_str)\n            \n            if tx_info[\"strand\"] == \"+\":\n                G = tx_info[\"g_start\"] + (C - 1)\n                p = G - 1\n                gen_ref, gen_alt = cref, calt\n            else:  # Negative strand\n                G = tx_info[\"g_end\"] - (C - 1)\n                p = G - 1\n                gen_ref = reverse_complement(cref)\n                gen_alt = reverse_complement(calt)\n            \n            d = encode_sequence(gen_ref)\n            i = encode_sequence(gen_alt)\n            return [R, p, d, i]\n\n        # Rule 5: Bare Accession\n        # Format: acc.version\n        bare_acc_match = re.fullmatch(r\"(\\w+\\.\\d+)\", input_str)\n        if bare_acc_match:\n            acc = bare_acc_match.group(1)\n            R = get_root_and_R(acc)\n            if R is None: return ERROR_RESULT\n            return [R, -1, 0, 0]\n\n        # Rule 6: Fallback for any non-matching input\n        return ERROR_RESULT\n\n    # --- Test Suite Execution ---\n    \n    test_cases = [\n        \"rs1000001\",\n        \"NC_000019.10:g.1101G>A\",\n        \"NM_000001.2:c.201G>A\",\n        \"NC_000019.10:1100:G:A\",\n        \"NC_000017.11\",\n        \"NC_000019.9:1100:G:A\",\n        \"rs3000003\",\n        \"NM_000002.1:c.100T>A\",\n        \"NC_000017.11:499:TA:\",\n        \"NC_000017.11:g.1801A>T\",\n    ]\n\n    results = [normalize(case) for case in test_cases]\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes spaces, which is\n    # consistent with the primary example format provided.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "4319014"}]}