{"hands_on_practices": [{"introduction": "To ensure that a genetic variant is understood unambiguously across different clinical systems, it must be described using a standard nomenclature. This exercise provides essential practice in translating a variant from the machine-readable Variant Call Format (VCF) into the clinically-used Human Genome Variation Society (HGVS) nomenclature. Mastering this conversion requires a precise understanding of genomic versus coding coordinates and the critical impact of gene strand direction, forming the bedrock of interoperable genomic data integration [@problem_id:4336669].", "problem": "An Electronic Health Record (EHR) integration pipeline must standardize variant descriptions from a Variant Call Format (VCF) record into Human Genome Variation Society (HGVS) genomic and coding DNA expressions. Consider the following realistic scenario under the Genome Reference Consortium Human Build 38 (GRCh38) with reference sequence accession NC_000007.14 for chromosome $7$.\n\nA single-nucleotide variant is provided in a VCF record with fields: CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, and one sample genotype. The record is:\n\nCHROM=7, POS=101115, ID=., REF=C, ALT=T, QUAL=50, FILTER=PASS, INFO=AC=1;AN=2;DP=30, FORMAT=GT:AD:DP:GQ:PL, SAMPLE=0/1:15,15:30:99:0,99,999.\n\nThe variant lies within a RefSeq transcript NM_999999.1 of a protein-coding gene on the negative (antisense) strand. The transcript structure (all coordinates are genomic, inclusive, and in $5'$ to $3'$ reference genome coordinate orientation) is:\n\n- Exon $1$: $g.[102050, 102200]$\n- Exon $2$: $g.[101000, 101150]$\n- Exon $3$: $g.[100000, 100300]$\n\nThe coding sequence (CDS) of NM_999999.1 begins at the first base of the start codon within exon $2$. The genomic positions of the start codon bases are $g.101120$, $g.101121$, and $g.101122$, and the first coding base (the adenine of the ATG codon) corresponds to $c.1$ and maps to genomic coordinate $g.101122$ because the transcript is on the negative strand (coding proceeds from higher to lower genomic coordinates). Assume all provided coordinates are correct against NC_000007.14, and the variant is within the coding region (not untranslated regions).\n\nUsing only foundational rules that (i) VCF POS is reported on the reference genome plus-strand coordinate system with REF and ALT nucleotides given in plus-strand convention, (ii) HGVS genomic expressions $g.$ use the reference sequence in plus-strand orientation, and (iii) HGVS coding expressions $c.$ use the transcript sequence in the direction of transcription with $c.1$ at the first coding base of the start codon, derive the HGVS genomic and coding DNA expressions for this variant. Then, for EHR field mapping, report the numeric genomic position used in the $g.$ expression and the numeric coding position used in the $c.$ expression as a two-entry row matrix.\n\nExpress the final numerical answer as a row matrix of two integers $\\begin{pmatrix}x & y\\end{pmatrix}$, where $x$ is the genomic coordinate used in the HGVS $g.$ expression and $y$ is the coding DNA coordinate used in the HGVS $c.$ expression. No rounding is required; report exact integers.", "solution": "The user has requested the derivation of genomic and coding DNA coordinates for a genetic variant, presented in a format suitable for Electronic Health Record (EHR) integration. The process begins with a rigorous validation of the problem statement.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n\nThe data and conditions provided in the problem statement are:\n-   **Reference Genome**: Genome Reference Consortium Human Build 38 (GRCh38), with reference sequence NC_000007.14 for chromosome $7$.\n-   **VCF Record**:\n    -   CHROM = $7$\n    -   POS = $101115$\n    -   REF = C\n    -   ALT = T\n-   **Transcript Information**:\n    -   RefSeq ID: NM_999999.1\n    -   Strand: Negative (antisense)\n    -   Exon Structure (genomic, inclusive, $5' \\to 3'$ reference orientation):\n        -   Exon $1$: $g.[102050, 102200]$\n        -   Exon $2$: $g.[101000, 101150]$\n        -   Exon $3$: $g.[100000, 100300]$\n-   **Coding Sequence (CDS) Information**:\n    -   The CDS begins at the start codon in exon $2$.\n    -   Genomic positions of start codon: $g.101120$, $g.101121$, $g.101122$.\n    -   The first coding base, $c.1$, maps to genomic coordinate $g.101122$.\n-   **Assumptions**:\n    -   All coordinates are correct for NC_000007.14.\n    -   The variant is within the coding region.\n-   **Rules for Derivation**:\n    -   (i) VCF POS, REF, and ALT are on the reference genome plus-strand.\n    -   (ii) HGVS $g.$ expressions use the reference sequence in plus-strand orientation.\n    -   (iii) HGVS $c.$ expressions use the transcript sequence in the direction of transcription, with $c.1$ at the first coding base.\n-   **Required Output**: A two-entry row matrix containing the numeric genomic position ($g.$) and the numeric coding position ($c.$).\n\n**Step 2: Validate Using Extracted Givens**\n\nThe problem is evaluated against the validation criteria:\n-   **Scientifically Grounded**: The problem is based on standard, well-established conventions in bioinformatics and clinical genomics, including VCF specification, HGVS nomenclature, and the concept of gene models on reference genomes. The scenario is a realistic and fundamental task in genomic data analysis. This criterion is met.\n-   **Well-Posed**: The problem provides all necessary data (VCF record, transcript structure, strand, CDS start mapping) and a clear set of rules to derive a unique numerical answer. The question is specific and unambiguous. This criterion is met.\n-   **Objective**: The problem uses precise, technical language (e.g., \"GRCh38\", \"VCF\", \"HGVS\", \"negative strand\") and is free from subjective or opinion-based statements. This criterion is met.\n-   **Consistency Check**: The variant is at genomic position $g.101115$. This falls within the boundaries of Exon $2$, which is $g.[101000, 101150]$. The CDS starts at $g.101122$ and proceeds toward lower genomic coordinates because the gene is on the negative strand. As $101115 < 101122$, the variant position is consistent with the statement that it lies within the coding region. The data is self-consistent and not contradictory.\n\n**Step 3: Verdict and Action**\n\nThe problem is scientifically sound, well-posed, objective, and internally consistent. It is therefore deemed **valid**. The solution will now be derived.\n\n### Solution Derivation\n\nThe task is to find the numeric genomic position for the HGVS $g.$ expression and the numeric coding position for the HGVS $c.$ expression.\n\n**1. Derivation of the Genomic Coordinate ($g.$)**\n\nThe HGVS genomic ($g.$) nomenclature describes variants relative to the reference genomic sequence. According to rule (ii), this uses the plus-strand orientation of the reference chromosome. Rule (i) states that the VCF `POS` field is also reported on the reference genome's plus-strand, 1-based coordinate system.\n\nThe VCF record provides:\n-   `CHROM` = $7$\n-   `POS` = $101115$\n-   `REF` = C\n-   `ALT` = T\n\nTherefore, the genomic position is directly given by the `POS` field in the VCF record. The full HGVS genomic expression for this single-nucleotide substitution would be `NC_000007.14:g.101115C>T`.\n\nThe numeric genomic position, $x$, required for the final answer is $101115$.\n\n**2. Derivation of the Coding DNA Coordinate ($c.$)**\n\nThe HGVS coding DNA ($c.$) nomenclature describes variants relative to the transcript's coding sequence. Rule (iii) specifies that the $c.$ coordinates are counted from the first base ($c.1$) of the translation initiation (start) codon, in the direction of transcription.\n\nKey information for this derivation:\n-   The transcript is on the **negative strand**. This means transcription proceeds from higher genomic coordinates to lower genomic coordinates. Consequently, the $c.$ coordinate numbering increases as the $g.$ coordinate numbering decreases.\n-   The reference point mapping is given: $c.1$ corresponds to the genomic position $g.101122$. Let's denote this as $g_{c.1} = 101122$.\n-   The genomic position of the variant is $g_{var} = 101115$.\n\nTo find the coding position of the variant, $c_{var}$, we calculate its distance from the start of the CDS. The distance in bases along the genome is the difference between the genomic coordinates. Since the gene is on the negative strand, a variant at a genomic position $g_{var} < g_{c.1}$ will be \"downstream\" of the start codon in the transcript.\n\nThe position $c_{var}$ can be calculated as follows:\nThe number of bases from $g_{c.1}$ to $g_{var}$ in the direction of transcription is given by the difference in their genomic coordinates.\n$$ \\text{distance} = g_{c.1} - g_{var} $$\n$$ \\text{distance} = 101122 - 101115 = 7 $$\nThe variant is $7$ bases away from the first coding base in the direction of transcription. Therefore, its position in the $c.$ coordinate system is:\n$$ c_{var} = 1 + \\text{distance} $$\n$$ c_{var} = 1 + 7 = 8 $$\nThe numeric coding position, $y$, required for the final answer is $8$.\n\nFor completeness, we can determine the full $c.$ expression. Since the transcript is on the negative strand, the alleles on the transcript are the reverse complements of the alleles on the plus strand of the reference genome.\n-   VCF `REF` (plus strand): `C`. Reverse complement is `G`.\n-   VCF `ALT` (plus strand): `T`. Reverse complement is `A`.\nThus, the variant is a `G` to `A` substitution on the transcript. The full HGVS coding DNA expression would be `NM_999999.1:c.8G>A`.\n\n**3. Final Answer Formulation**\n\nThe problem asks for a two-entry row matrix $\\begin{pmatrix}x & y\\end{pmatrix}$, where $x$ is the numeric genomic position and $y$ is the numeric coding position.\n-   Genomic position, $x = 101115$.\n-   Coding DNA position, $y = 8$.\n\nThe resulting matrix is $\\begin{pmatrix}101115 & 8\\end{pmatrix}$.", "answer": "$$\n\\boxed{\\begin{pmatrix}101115 & 8\\end{pmatrix}}\n$$", "id": "4336669"}, {"introduction": "Real-world EHR integration involves aggregating data from multiple laboratories, each with potential inconsistencies in formatting and representation. This practice moves from a single variant to the challenge of harmonizing large-scale data feeds by defining and applying normalization rules for coordinates and chromosome labels. By calculating the pre- and post-normalization error rates, you will gain a quantitative understanding of data quality improvement, a critical aspect of building a robust and reliable genomic data pipeline [@problem_id:4336609].", "problem": "A hospital-grade Electronic Health Record (EHR) integration pipeline ingests single-nucleotide variant records from three external laboratory feeds and must normalize each record to a canonical representation aligned to Genome Reference Consortium Human Build 38 (GRCh38). The canonical representation uses $1$-based genomic coordinates and chromosome labels $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$. Two sources of canonicalization failures are observed before normalization: mismatched coordinate bases (zero-based versus one-based) and inconsistent chromosome labels. Assume single-nucleotide variants and that all records refer to GRCh38.\n\nUse the frequency interpretation of error rate as a fraction of failures over the total number of records, i.e., if $E$ is the total number of canonicalization failures and $N$ is the total number of ingested records, the error rate is $e = \\frac{E}{N}$.\n\nThe three feeds have the following characteristics and pre-normalization failure counts:\n\n- Feed $A$: $N_A = 6 \\times 10^{5}$ records, reported with zero-based coordinates and labels from $\\{1,\\dots,22,\\text{X},\\text{Y},\\text{MT}\\}$. Diagnostics attribute $C_A = 6.6 \\times 10^{4}$ failures to coordinate base mismatch (assessed on autosomes where label parsing succeeded for this check) and $L_A = 4.2 \\times 10^{4}$ failures to label parsing mismatch (assessed on sex and mitochondrial chromosomes where base-mismatch diagnostics were not run). Treat $C_A$ and $L_A$ as disjoint, so the pre-normalization canonicalization failures for feed $A$ are $E_A^{\\text{pre}} = C_A + L_A$.\n- Feed $B$: $N_B = 8 \\times 10^{5}$ records, reported with one-based coordinates and canonical $\\text{chr}$-prefixed labels. Pre-normalization canonicalization failures for feed $B$ are $E_B^{\\text{pre}} = 0$.\n- Feed $C$: $N_C = 7 \\times 10^{5}$ records, reported with one-based coordinates and labels from $\\{1,\\dots,25\\}$, where $\\{23,24,25\\}$ denote $\\{\\text{X},\\text{Y},\\text{MT}\\}$ respectively. Diagnostics identify $L_C = 3.5 \\times 10^{4}$ label parsing mismatches and $Q_C = 2.8 \\times 10^{3}$ position-field parse failures (non-integer or out-of-range values). Treat $L_C$ and $Q_C$ as disjoint, so $E_C^{\\text{pre}} = L_C + Q_C$.\n\nYou must specify normalization transforms that map any feedâ€™s record to the canonical representation. Formally define:\n\n- A position normalization function $f_{\\text{pos}}(p,b)$, where $p$ is the reported position and $b \\in \\{0,1\\}$ encodes the reported coordinate base, that returns a canonical one-based position on GRCh38.\n- A chromosome label normalization function $f_{\\text{chr}}(\\ell)$ that maps any of the feed-provided labels to one of $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$.\n\nAfter applying these transforms, the residual failures are observed to be:\n\n- For feed $A$: of the $C_A$ coordinate-base failures, $99.5\\%$ are corrected; the residual coordinate-base failures are $R_{A,C} = 3.3 \\times 10^{2}$. All label mismatches $L_A$ are corrected, so $R_{A,L} = 0$.\n- For feed $B$: no canonicalization failures are introduced or corrected, so $R_B = 0$.\n- For feed $C$: of the $L_C$ label mismatches, $98\\%$ are corrected; the residual label failures are $R_{C,L} = 7.0 \\times 10^{2}$. Position-field parse failures $Q_C$ remain uncorrected, so $R_{C,Q} = 2.8 \\times 10^{3}$.\n\nLet $N_{\\text{tot}} = N_A + N_B + N_C$ denote the total number of records across all feeds. Using the fundamental definition of error rate $e = \\frac{E}{N}$ and the specified transforms, compute the post-normalization canonicalization error rate $e^{\\text{post}}$ across all feeds, expressed as a decimal and rounded to four significant figures. Clearly state the normalization transforms you use, then derive $e^{\\text{post}}$ from first principles.", "solution": "The problem statement has been critically validated and is deemed valid. It is scientifically grounded in the domain of bioinformatics and genomic data processing, quantitatively well-posed, internally consistent, and objective. All necessary data are provided, and there are no contradictions. The problem requires the definition of normalization functions and the calculation of a post-normalization error rate, which is a standard procedure in data quality assessment.\n\nThe task is to compute the post-normalization canonicalization error rate, $e^{\\text{post}}$, for genomic data aggregated from three feeds. This requires defining the normalization transforms, calculating the total number of records, calculating the total number of residual errors after normalization, and then computing their ratio.\n\nFirst, we define the a priori normalization transforms as specified.\n\nThe canonical representation requires $1$-based genomic coordinates. A transform is needed for feeds reporting $0$-based coordinates.\nLet $p$ be the reported position and $b \\in \\{0, 1\\}$ be an indicator for the coordinate base, where $b=0$ signifies zero-based and $b=1$ signifies one-based. The position normalization function $f_{\\text{pos}}(p, b)$ maps the input to a canonical $1$-based position. A zero-based coordinate is converted to a one-based coordinate by adding $1$. A one-based coordinate needs no change.\nThus, the function is defined as:\n$$\nf_{\\text{pos}}(p, b) = p + (1 - b)\n$$\nEquivalently, in piecewise form:\n$$\nf_{\\text{pos}}(p, b) = \\begin{cases} p+1 & \\text{if } b=0 \\text{ (zero-based)} \\\\ p & \\text{if } b=1 \\text{ (one-based)} \\end{cases}\n$$\nThis function will be applied to records from Feed $A$, which are zero-based. Feeds $B$ and $C$ are one-based, so for them, the position remains unchanged.\n\nThe canonical representation requires chromosome labels from the set $\\{\\text{chr}1,\\dots,\\text{chr}22,\\text{chrX},\\text{chrY},\\text{chrM}\\}$. A transform is needed for feeds using different label formats.\nLet $\\ell$ be the reported chromosome label. The chromosome label normalization function $f_{\\text{chr}}(\\ell)$ must map labels from all feeds to the canonical set. The feeds provide labels in the following formats:\n- Feed $A$: $\\{1, \\dots, 22, \\text{X}, \\text{Y}, \\text{MT}\\}$\n- Feed $B$: $\\{\\text{chr}1, \\dots, \\text{chr}22, \\text{chrX}, \\text{chrY}, \\text{chrM}\\}$ (already canonical)\n- Feed $C$: $\\{1, \\dots, 25\\}$, with the mapping $\\{23 \\to \\text{X}, 24 \\to \\text{Y}, 25 \\to \\text{MT}\\}$ which must then be mapped to canonical.\n\nA comprehensive function covering all cases is defined as follows, where $\\oplus$ denotes string concatenation:\n$$\nf_{\\text{chr}}(\\ell) = \\begin{cases} \\text{'chr'} \\oplus \\text{string}(\\ell) & \\text{if } \\ell \\in \\{1, 2, \\dots, 22\\} \\\\ \\text{'chrX'} & \\text{if } \\ell \\in \\{\\text{'X'}, 23\\} \\\\ \\text{'chrY'} & \\text{if } \\ell \\in \\{\\text{'Y'}, 24\\} \\\\ \\text{'chrM'} & \\text{if } \\ell \\in \\{\\text{'MT'}, 25\\} \\\\ \\ell & \\text{if } \\ell \\text{ is already in the canonical set} \\end{cases}\n$$\nThis function handles the label formats for all three feeds.\n\nNext, we compute the total number of ingested records, $N_{\\text{tot}}$.\nGiven:\n- Number of records from Feed $A$: $N_A = 6 \\times 10^{5}$\n- Number of records from Feed $B$: $N_B = 8 \\times 10^{5}$\n- Number of records from Feed $C$: $N_C = 7 \\times 10^{5}$\n\nThe total number of records is the sum:\n$$\nN_{\\text{tot}} = N_A + N_B + N_C = (6 \\times 10^{5}) + (8 \\times 10^{5}) + (7 \\times 10^{5}) = (6+8+7) \\times 10^{5} = 21 \\times 10^{5} = 2.1 \\times 10^{6}\n$$\n\nNow, we compute the total number of post-normalization canonicalization failures, $E_{\\text{tot}}^{\\text{post}}$. This is the sum of a posteriori residual failures from each feed after applying the normalization transforms.\n$$\nE_{\\text{tot}}^{\\text{post}} = E_A^{\\text{post}} + E_B^{\\text{post}} + E_C^{\\text{post}}\n$$\n\nFor Feed $A$, the post-normalization failures, $E_A^{\\text{post}}$, are the sum of residual coordinate and label failures.\n- Residual coordinate-base failures: $R_{A,C} = 3.3 \\times 10^{2} = 330$. This is consistent with the initial count $C_A = 6.6 \\times 10^4$ and a $99.5\\%$ correction rate, as $(1 - 0.995) \\times 6.6 \\times 10^4 = 0.005 \\times 66000 = 330$.\n- Residual label failures: $R_{A,L} = 0$, as all initial label mismatches $L_A$ are corrected.\nTherefore, the total post-normalization failures for Feed $A$ are:\n$$\nE_A^{\\text{post}} = R_{A,C} + R_{A,L} = 330 + 0 = 330\n$$\n\nFor Feed $B$, records are already in the canonical format. No normalization is applied, and no failures are introduced or corrected.\n- Residual failures: $R_B = 0$.\nTherefore, the total post-normalization failures for Feed $B$ are:\n$$\nE_B^{\\text{post}} = 0\n$$\n\nFor Feed $C$, the post-normalization failures, $E_C^{\\text{post}}$, are the sum of residual label and position-field parse failures.\n- Residual label failures: $R_{C,L} = 7.0 \\times 10^{2} = 700$. This is consistent with the initial count $L_C = 3.5 \\times 10^4$ and a $98\\%$ correction rate, as $(1 - 0.98) \\times 3.5 \\times 10^4 = 0.02 \\times 35000 = 700$.\n- The position-field parse failures, $Q_C$, are uncorrected. These failures are due to malformed data (non-integer or out-of-range position values) which the defined syntactic normalization function $f_{\\text{pos}}$ cannot handle. Thus, the residual count equals the initial count: $R_{C,Q} = Q_C = 2.8 \\times 10^{3} = 2800$.\nTherefore, the total post-normalization failures for Feed $C$ are:\n$$\nE_C^{\\text{post}} = R_{C,L} + R_{C,Q} = 700 + 2800 = 3500\n$$\n\nThe total number of post-normalization failures across all feeds is:\n$$\nE_{\\text{tot}}^{\\text{post}} = E_A^{\\text{post}} + E_B^{\\text{post}} + E_C^{\\text{post}} = 330 + 0 + 3500 = 3830\n$$\n\nFinally, we compute the post-normalization canonicalization error rate, $e^{\\text{post}}$, using the fundamental definition $e = \\frac{E}{N}$.\n$$\ne^{\\text{post}} = \\frac{E_{\\text{tot}}^{\\text{post}}}{N_{\\text{tot}}} = \\frac{3830}{2.1 \\times 10^{6}}\n$$\nCalculating the decimal value:\n$$\ne^{\\text{post}} = \\frac{3830}{2100000} \\approx 0.0018238095238...\n$$\nThe problem requires the result to be rounded to four significant figures. The first four significant figures are $1$, $8$, $2$, $3$. The fifth significant figure is $8$, which is $\\ge 5$, so we round up the fourth figure.\n$$\ne^{\\text{post}} \\approx 0.001824\n$$\nThis is the final aggregate error rate after applying the normalization pipeline.", "answer": "$$\n\\boxed{0.001824}\n$$", "id": "4336609"}, {"introduction": "The human reference genome is periodically updated, creating different \"versions\" or \"builds\" like GRCh37 and GRCh38, which can make integrating historical and current genomic data a significant challenge. This exercise demystifies the \"liftover\" process, a fundamental bioinformatic task for remapping variant coordinates from an older build to a newer one. By implementing a simplified liftover algorithm, you will develop a practical understanding of how this coordinate transformation works and why some variants may fail to map, leading to data loss or ambiguity in the EHR [@problem_id:4336648].", "problem": "Electronic Health Record (EHR) systems increasingly store clinical variants in a canonical reference genome build to drive interoperable Clinical Decision Support. When clinical variants are generated against Genome Reference Consortium human build 37 (GRCh37) but the EHR operates on Genome Reference Consortium human build 38 (GRCh38), a coordinate transformation (\"liftover\") is required. In a simplified, algorithmically precise model consistent with well-tested genome assembly alignment principles, a liftover is defined by a set of alignment \"chains,\" each composed of one or more perfectly matching blocks between assemblies. The fundamental facts and definitions are:\n- A chain consists of a source chromosome integer $c_s$, a target chromosome integer $c_t$, a strand $\\sigma \\in \\{+1,-1\\}$, and a finite list of alignment blocks $B = \\{(s_i, t_i, \\ell_i)\\}_{i=1}^n$. Each block $(s_i, t_i, \\ell_i)$ maps the half-open interval $[s_i, s_i + \\ell_i)$ on the source to the interval $[t_i, t_i + \\ell_i)$ on the target. All coordinates are $0$-based integers measured in base pairs.\n- A single-nucleotide variant at source coordinate $x$ on chromosome $c$ is said to be covered by a block $(s_i, t_i, \\ell_i)$ if and only if $s_i \\le x < s_i + \\ell_i$ and $c = c_s$.\n- If covered and $\\sigma = +1$, the mapped target coordinate is $y = t_i + (x - s_i)$ on chromosome $c_t$.\n- If covered and $\\sigma = -1$, the mapped target coordinate is $y = t_i + \\left(\\ell_i - 1 - (x - s_i)\\right)$ on chromosome $c_t$.\n- A variant has a unique liftover if and only if exactly one distinct target tuple $(c_t, y)$ arises from all blocks across all chains. If no blocks cover $x$, the mapping is missing. If more than one distinct target tuple arises, the mapping is ambiguous.\n\nYour task is to implement a program that, for each provided test case:\n- Computes the GRCh38 target coordinates $(c_t, y)$ for all GRCh37 variants by applying the definitions above to the provided chain set.\n- Classifies each variant as uniquely lifted, missing, or ambiguous.\n- Returns, for each test case, the fraction (as a decimal) of variants that fail liftover due to ambiguous or missing mappings, defined as $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$, where $N_{\\text{fail}}$ is the count of variants with missing or ambiguous mappings and $N_{\\text{total}}$ is the total number of variants in the test case.\n\nAssumptions and conventions:\n- All chromosomes are represented by positive integers (for example, $1$ for chromosome 1).\n- All coordinates are $0$-based integers counted in base pairs.\n- Input strand $\\sigma$ uses $+1$ for forward and $-1$ for reverse orientation.\n- A variant is a single base at coordinate $x$.\n- The mapping rule uses half-open intervals $[s_i, s_i + \\ell_i)$; a coordinate $x = s_i + \\ell_i$ is not covered by the block.\n\nTest suite to implement inside the program:\n- Test case $1$ (happy path, all unique):\n  - Chains:\n    - One chain with $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$.\n  - Variants as pairs $(c, x)$: $[(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]$.\n  - Expected failure fraction: $0.0$.\n- Test case $2$ (boundary and missing coverage):\n  - Chains:\n    - One chain with $(c_s = 1, c_t = 1, \\sigma = +1, B = [(10, 100, 10)])$.\n  - Variants: $[(1, 9), (1, 10), (1, 19), (1, 20)]$. Coordinates $x = 9$ and $x = 20$ are not covered because the block is $[10, 20)$.\n  - Expected failure fraction: $0.5$.\n- Test case $3$ (ambiguity and reverse strand):\n  - Chains:\n    - Chain A: $(c_s = 2, c_t = 2, \\sigma = +1, B = [(150, 3000, 30)])$.\n    - Chain B: $(c_s = 2, c_t = 2, \\sigma = +1, B = [(160, 4000, 30)])$.\n    - Chain C: $(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$.\n  - Variants: $[(2, 155), (2, 165), (2, 175), (2, 205)]$. Variants at $x = 165$ and $x = 175$ are covered by both Chain A and Chain B with different targets and are therefore ambiguous; $x = 155$ maps uniquely via Chain A; $x = 205$ maps uniquely via Chain C (reverse orientation).\n  - Expected failure fraction: $0.5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order, the failure fractions $f$ for test cases $1$, $2$, and $3$, each formatted to exactly $6$ decimal places (for example, $[0.000000,0.500000,0.500000]$).\n- Express each fraction as a decimal number, not a percentage.\n\nThe problem is fully self-contained; do not read from files or request user input. Implement the chains and variants exactly as specified above and compute the required failure fractions using the definitions provided.", "solution": "The problem statement presents a well-defined computational task based on a simplified but scientifically sound model of genomic coordinate transformation, a process known as \"liftover\" in bioinformatics. The problem is validated as sound, complete, and devoid of ambiguity. It is grounded in established principles of genome assembly alignment, using concepts such as alignment chains, matching blocks, chromosomal coordinates, and strand orientation. The definitions for coordinate coverage and mapping for both forward ($\\sigma = +1$) and reverse ($\\sigma = -1$) strands are precise and algorithmically formalizable. The criteria for classifying a mapping as unique, missing, or ambiguous are mutually exclusive and exhaustive. Therefore, the problem is valid and a definitive solution can be engineered.\n\nThe solution will be implemented by iterating through each variant provided in a given test case. For each variant, we must determine all possible target mappings by evaluating it against every block in every provided alignment chain. A set data structure is ideally suited to collect these mappings, as it automatically stores only the unique target tuples $(c_t, y)$.\n\nThe process for a single variant $(c, x)$ is as follows:\n1. Initialize an empty set, `mappings`, to store the distinct target coordinates found.\n2. Iterate through each chain defined for the test case. A chain is described by a source chromosome $c_s$, a target chromosome $c_t$, a strand orientation $\\sigma$, and a list of alignment blocks $B$.\n3. If the variant's chromosome $c$ does not match the chain's source chromosome $c_s$, this entire chain is irrelevant, and we proceed to the next chain.\n4. If the chromosomes match ($c = c_s$), iterate through each block $(s_i, t_i, \\ell_i)$ in the chain's list $B$.\n5. For each block, check if the variant's source coordinate $x$ is covered. According to the stated half-open interval rule, this condition is $s_i \\le x < s_i + \\ell_i$.\n6. If the coordinate $x$ is covered by the block, a target coordinate $y$ is calculated based on the chain's strand orientation $\\sigma$:\n   - If $\\sigma = +1$ (forward strand), the positional offset is preserved. The target coordinate is $y = t_i + (x - s_i)$.\n   - If $\\sigma = -1$ (reverse strand), the positional offset is inverted within the block. The target coordinate is $y = t_i + (\\ell_i - 1 - (x - s_i))$.\n   The resulting target mapping is the tuple $(c_t, y)$. This tuple is added to the `mappings` set.\n7. After checking all blocks of all chains, the size of the `mappings` set determines the liftover status for the variant $(c, x)$:\n   - If the set is empty (size is $0$), no block covered the variant's coordinate. The mapping is **missing**.\n   - If the set contains exactly one element (size is $1$), the mapping is **unique**.\n   - If the set contains more than one element (size is $> 1$), multiple, conflicting mappings were found. The mapping is **ambiguous**.\n\nA variant is considered to have failed the liftover process if its mapping is either missing or ambiguous. For each test case, we will count the total number of variants, $N_{\\text{total}}$, and the number of failed variants, $N_{\\text{fail}}$. The failure fraction is then computed as $f = \\dfrac{N_{\\text{fail}}}{N_{\\text{total}}}$. This procedure will be applied to all three test cases, and the resulting fractions will be formatted and presented as required.\n\nLet's trace Test Case 3's variant at $x=205$ on chromosome $c=2$ with the reverse strand mapping rule. The relevant chain is Chain C: $(c_s = 2, c_t = 2, \\sigma = -1, B = [(200, 5000, 10)])$. The block is $(s_i, t_i, \\ell_i) = (200, 5000, 10)$.\nThe source coordinate is $x=205$.\nThe variant is on the correct chromosome ($2=c_s$) and its coordinate is within the block's source interval $[200, 200+10) = [200, 210)$, since $200 \\le 205 < 210$.\nThe mapping is on the reverse strand ($\\sigma = -1$). The target coordinate $y$ is calculated as:\n$$ y = t_i + (\\ell_i - 1 - (x - s_i)) $$\n$$ y = 5000 + (10 - 1 - (205 - 200)) $$\n$$ y = 5000 + (9 - 5) $$\n$$ y = 5004 $$\nSince this is the only block covering this coordinate, the unique mapping is to $(c_t, y) = (2, 5004)$. This confirms the logic for reverse strand mapping is correctly applied. The algorithmic design is thereby verified against the problem's specifications.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats # Scipy is specified, importing a submodule for completeness.\n\ndef solve():\n    \"\"\"\n    Solves the liftover problem for the defined test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, all unique)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 10), (1, 12), (1, 15), (1, 18), (1, 19)]\n        },\n        # Test case 2 (boundary and missing coverage)\n        {\n            \"chains\": [\n                {\n                    \"cs\": 1, \"ct\": 1, \"sigma\": 1,\n                    \"blocks\": [(10, 100, 10)]\n                }\n            ],\n            \"variants\": [(1, 9), (1, 10), (1, 19), (1, 20)]\n        },\n        # Test case 3 (ambiguity and reverse strand)\n        {\n            \"chains\": [\n                {  # Chain A\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(150, 3000, 30)]\n                },\n                {  # Chain B\n                    \"cs\": 2, \"ct\": 2, \"sigma\": 1,\n                    \"blocks\": [(160, 4000, 30)]\n                },\n                {  # Chain C\n                    \"cs\": 2, \"ct\": 2, \"sigma\": -1,\n                    \"blocks\": [(200, 5000, 10)]\n                }\n            ],\n            \"variants\": [(2, 155), (2, 165), (2, 175), (2, 205)]\n        }\n    ]\n\n    failure_fractions = []\n\n    for case in test_cases:\n        chains = case[\"chains\"]\n        variants = case[\"variants\"]\n        n_total = len(variants)\n        n_fail = 0\n\n        for c_var, x_var in variants:\n            found_mappings = set()\n\n            for chain in chains:\n                cs = chain[\"cs\"]\n                ct = chain[\"ct\"]\n                sigma = chain[\"sigma\"]\n                \n                # Skip chain if it's for a different source chromosome\n                if c_var != cs:\n                    continue\n\n                for s_i, t_i, l_i in chain[\"blocks\"]:\n                    # Check if the variant is covered by the block's source interval [s_i, s_i + l_i)\n                    if s_i <= x_var < s_i + l_i:\n                        y = 0\n                        # Forward strand mapping\n                        if sigma == 1:\n                            y = t_i + (x_var - s_i)\n                        # Reverse strand mapping\n                        elif sigma == -1:\n                            y = t_i + (l_i - 1 - (x_var - s_i))\n                        \n                        found_mappings.add((ct, y))\n            \n            # Classify the liftover result\n            # A failure is defined as a missing (0 mappings) or ambiguous (>1 mapping) result.\n            if len(found_mappings) != 1:\n                n_fail += 1\n\n        if n_total > 0:\n            fraction = n_fail / n_total\n        else:\n            fraction = 0.0\n        \n        failure_fractions.append(f\"{fraction:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(failure_fractions)}]\")\n\nsolve()\n```", "id": "4336648"}]}