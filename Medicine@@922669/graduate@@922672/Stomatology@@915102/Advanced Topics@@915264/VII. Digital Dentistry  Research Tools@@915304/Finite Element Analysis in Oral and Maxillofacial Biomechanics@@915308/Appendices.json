{"hands_on_practices": [{"introduction": "Finite Element Analysis operates on a discrete mesh of nodes. A crucial first step in any simulation is to accurately translate real-world distributed loads, such as the pressure from an occlusal contact, into a set of equivalent forces applied at these nodes. This practice provides hands-on experience with this fundamental pre-processing task, using shape functions to ensure the nodal forces are statically equivalent to the original pressure, a cornerstone of accurate simulation [@problem_id:4718428].", "problem": "In a bite-force simulation of the mesiobuccal cusp of a mandibular first molar, an occlusal contact patch is represented by a single planar face of a ten-node quadratic tetrahedral element (the face is the standard six-node quadratic triangular face). The outward unit normal of this face points occlusally. During clenching, the antagonist tooth applies a uniform pressure load of magnitude $p_{0} = 8.0 \\times 10^{6} \\, \\text{Pa}$ on this face, directed apically (i.e., opposite to the outward normal). The measured area of this triangular face is $A = 1.20 \\times 10^{-6} \\, \\text{m}^2$.\n\nLet the face nodes be ordered so that nodes $1$, $2$, and $3$ are the vertices of the triangle, and nodes $4$, $5$, and $6$ are the midside nodes on edges $\\overline{12}$, $\\overline{23}$, and $\\overline{31}$, respectively. Assume the face is planar, the pressure is spatially uniform over the face, and the shape functions on the face are the standard quadratic Lagrange shape functions of a six-node triangle in barycentric coordinates.\n\nUsing the finite element method principle that a distributed surface traction $\\boldsymbol{t}$ contributes an equivalent nodal force vector given by the surface integral of the shape functions weighted by $\\boldsymbol{t}$, compute the six scalar normal components of the consistent equivalent nodal force vector associated with this face, that is, compute\n$$\nf_{i}^{n} = \\int_{S} N_{i}\\, \\boldsymbol{t} \\cdot \\boldsymbol{n}\\, \\mathrm{d}S \\quad \\text{for } i = 1,\\dots,6,\n$$\nwhere $S$ is the triangular face, $\\boldsymbol{n}$ is the outward unit normal, and $N_{i}$ are the face shape functions. Use the sign convention that positive force is along the outward unit normal. Express your final answer as a single row vector\n$$\n\\bigl[f_{1}^{n} \\;\\; f_{2}^{n} \\;\\; f_{3}^{n} \\;\\; f_{4}^{n} \\;\\; f_{5}^{n} \\;\\; f_{6}^{n}\\bigr].\n$$\n\nRound your answer to three significant figures. Express the result in Newtons.", "solution": "The problem requires the computation of the consistent nodal forces, $f_{i}^{n}$, for a six-node quadratic triangular face subjected to a uniform pressure. The governing equation is:\n$$f_{i}^{n} = \\int_{S} N_{i}\\, \\boldsymbol{t} \\cdot \\boldsymbol{n}\\, \\mathrm{d}S$$\nHere, $S$ is the triangular face, $N_{i}$ are the shape functions, $\\boldsymbol{n}$ is the outward unit normal, and $\\boldsymbol{t}$ is the surface traction vector.\n\nThe applied load is a uniform pressure of magnitude $p_{0} = 8.0 \\times 10^{6}$ Pa, directed opposite to the outward unit normal $\\boldsymbol{n}$. The surface traction vector is therefore $\\boldsymbol{t} = -p_{0} \\boldsymbol{n}$. Substituting this into the integral and using $\\boldsymbol{n} \\cdot \\boldsymbol{n} = 1$:\n$$f_{i}^{n} = \\int_{S} N_{i} (-p_{0} \\boldsymbol{n}) \\cdot \\boldsymbol{n}\\, \\mathrm{d}S = -p_{0} \\int_{S} N_{i} \\, \\mathrm{d}S$$\nSince the pressure $p_{0}$ is uniform, the task reduces to integrating each shape function $N_{i}$ over the area of the triangle, $A$.\n\nFor a six-node quadratic triangle, the standard Lagrange shape functions have a known property when integrated over the element area $A$:\n*   For vertex nodes ($i \\in \\{1, 2, 3\\}$): $\\int_S N_i \\, \\mathrm{d}S = 0$\n*   For midside nodes ($i \\in \\{4, 5, 6\\}$): $\\int_S N_i \\, \\mathrm{d}S = \\frac{A}{3}$\n\nThis is a classic result: a uniform pressure load on a quadratic element distributes its equivalent forces entirely to the midside nodes, with the vertex nodes receiving zero force. The total integrated load is preserved, as $\\sum_{i=1}^6 \\int_S N_i \\, \\mathrm{d}S = 3 \\times 0 + 3 \\times \\frac{A}{3} = A$.\n\nNow we compute the numerical values for the nodal forces.\nFor vertex nodes ($i = 1, 2, 3$):\n$$f_{1}^{n} = f_{2}^{n} = f_{3}^{n} = -p_{0} \\times 0 = 0 \\, \\text{N}$$\nFor midside nodes ($i = 4, 5, 6$):\n$$f_{4}^{n} = f_{5}^{n} = f_{6}^{n} = -p_{0} \\left(\\frac{A}{3}\\right)$$\nSubstituting the given numerical values, $p_{0} = 8.0 \\times 10^{6}$ N/m$^2$ and $A = 1.20 \\times 10^{-6}$ m$^2$:\n$$f_{4,5,6}^{n} = -\\frac{(8.0 \\times 10^{6}) \\times (1.20 \\times 10^{-6})}{3} = -\\frac{9.6}{3} = -3.2 \\, \\text{N}$$\nThe total normal force on the face is $\\sum f_i^n = 3 \\times (-3.2) = -9.6 \\, \\text{N}$, which correctly equals the total applied force $-p_0 A$.\n\nThe problem requires the answer to be rounded to three significant figures. The force value $-3.2$ N becomes $-3.20$ N. The zero forces are exact and can be written as $0.00$ for consistency.\nThe final nodal force vector is:\n$$ \\bigl[f_{1}^{n} \\;\\; f_{2}^{n} \\;\\; f_{3}^{n} \\;\\; f_{4}^{n} \\;\\; f_{5}^{n} \\;\\; f_{6}^{n}\\bigr] = \\bigl[0.00 \\;\\; 0.00 \\;\\; 0.00 \\;\\; -3.20 \\;\\; -3.20 \\;\\; -3.20\\bigr] $$\nThe units for all components are Newtons (N).", "answer": "$$\\boxed{\\begin{pmatrix} 0.00 & 0.00 & 0.00 & -3.20 & -3.20 & -3.20 \\end{pmatrix}}$$", "id": "4718428"}, {"introduction": "A successful finite element simulation yields a detailed map of the stress state within a biological structure, but these numbers require interpretation to be clinically useful. Failure criteria are the tools that translate a complex stress tensor into a single, understandable measure of fracture risk. This exercise will guide you through applying the pressure-sensitive Drucker-Prager criterion, a model well-suited for materials like bone, to calculate a factor of safety and directly assess the risk of mandibular fracture under load [@problem_id:4718409].", "problem": "A clinician uses Finite Element Analysis (FEA) to assess the mandibular angle of an adult patient under unilateral molar loading. The occlusal force magnitude is $F_{\\mathrm{occ}} = 700$ N applied at the second molar on the working side. The FEA model predicts the Cauchy stress tensor at a cortical bone element centered at the mandibular angle (anatomical axes: mediolateral $x$, superoinferior $y$, anteroposterior $z$) as\n$$\n\\boldsymbol{\\sigma} = \\begin{pmatrix}\n-300 & 60 & 0 \\\\\n60 & -150 & 40 \\\\\n0 & 40 & -120\n\\end{pmatrix} \\, \\mathrm{MPa}.\n$$\nTo estimate failure risk in cortical bone, adopt the pressure-sensitive Drucker–Prager (DP) failure criterion, calibrated so that it reproduces the observed uniaxial tensile and compressive strengths of mandibular cortical bone. Use the following material strengths measured in standardized tests: uniaxial tensile strength $\\sigma_{t} = 120 \\, \\mathrm{MPa}$ and uniaxial compressive strength $\\sigma_{c} = 180 \\, \\mathrm{MPa}$. Define the factor of safety as the ratio between the DP failure surface radius and the current stress state measure under the DP criterion. \n\nStarting from fundamental definitions of the stress invariants and the standard calibration of the Drucker–Prager parameters to uniaxial strengths, compute the factor of safety at the given element. Round your final result to three significant figures, and report it as a dimensionless number. Also, based on the computed factor of safety, briefly interpret the clinical risk under static occlusal loading in your reasoning, but express only the numerical factor of safety in your final answer.", "solution": "The problem requires the computation of the factor of safety (FS) using the Drucker–Prager (DP) failure criterion. The DP criterion is defined as $f(I_1, J_2) = \\sqrt{J_2} + \\alpha I_1 - k = 0$, where $I_1$ is the first stress invariant and $J_2$ is the second invariant of the deviatoric stress.\n\n**Step 1: Calculate Stress Invariants**\nFirst, we calculate the stress invariants for the given stress tensor:\n$$\n\\boldsymbol{\\sigma} = \\begin{pmatrix}\n-300 & 60 & 0 \\\\\n60 & -150 & 40 \\\\\n0 & 40 & -120\n\\end{pmatrix} \\, \\mathrm{MPa}\n$$\nThe first invariant, $I_1$, is the trace of $\\boldsymbol{\\sigma}$:\n$$I_1 = \\mathrm{tr}(\\boldsymbol{\\sigma}) = (-300) + (-150) + (-120) = -570 \\, \\mathrm{MPa}$$\nThe second invariant of the deviatoric stress, $J_2$, is:\n$$J_2 = \\frac{1}{6} \\left[ (\\sigma_{11} - \\sigma_{22})^2 + (\\sigma_{22} - \\sigma_{33})^2 + (\\sigma_{33} - \\sigma_{11})^2 \\right] + \\sigma_{12}^2 + \\sigma_{23}^2 + \\sigma_{31}^2$$\n$$\n\\begin{aligned}\nJ_2 &= \\frac{1}{6} \\left[ (-150)^2 + (-30)^2 + (180)^2 \\right] + (60)^2 + (40)^2 + (0)^2 \\\\\n&= \\frac{1}{6} [ 22500 + 900 + 32400 ] + 3600 + 1600 \\\\\n&= 9300 + 5200 = 14500 \\, \\mathrm{MPa}^2\n\\end{aligned}\n$$\nSo, $\\sqrt{J_2} = \\sqrt{14500} = 10\\sqrt{145} \\, \\mathrm{MPa}$.\n\n**Step 2: Calibrate Drucker-Prager Parameters**\nThe material parameters $\\alpha$ and $k$ are calibrated to the uniaxial tensile strength, $\\sigma_t = 120 \\, \\mathrm{MPa}$, and compressive strength, $\\sigma_c = 180 \\, \\mathrm{MPa}$. The standard formulas for this calibration are:\n$$\\alpha = \\frac{\\sigma_c - \\sigma_t}{\\sqrt{3}(\\sigma_c + \\sigma_t)} \\quad \\text{and} \\quad k = \\frac{2\\sigma_c\\sigma_t}{\\sqrt{3}(\\sigma_c + \\sigma_t)}$$\nSubstituting the material strengths:\n$$\\alpha = \\frac{180 - 120}{\\sqrt{3}(180 + 120)} = \\frac{60}{300\\sqrt{3}} = \\frac{1}{5\\sqrt{3}} = \\frac{\\sqrt{3}}{15}$$\n$$k = \\frac{2(180)(120)}{\\sqrt{3}(180 + 120)} = \\frac{43200}{300\\sqrt{3}} = \\frac{144}{\\sqrt{3}} = 48\\sqrt{3} \\, \\mathrm{MPa}$$\n\n**Step 3: Calculate the Factor of Safety**\nThe factor of safety (FS) is the ratio of the material's failure resistance ($k$) to the current stress state measure ($\\sqrt{J_2} + \\alpha I_1$):\n$$\\mathrm{FS} = \\frac{k}{\\sqrt{J_2} + \\alpha I_1}$$\nSubstituting the calculated values:\n$$\\mathrm{FS} = \\frac{48\\sqrt{3}}{10\\sqrt{145} + (\\frac{\\sqrt{3}}{15})(-570)} = \\frac{48\\sqrt{3}}{10\\sqrt{145} - 38\\sqrt{3}}$$\nUsing numerical values $\\sqrt{3} \\approx 1.73205$ and $\\sqrt{145} \\approx 12.04159$:\n$$\\mathrm{FS} \\approx \\frac{48 \\times 1.73205}{10 \\times 12.04159 - 38 \\times 1.73205} = \\frac{83.1384}{120.4159 - 65.8179} = \\frac{83.1384}{54.5980} \\approx 1.52273$$\nRounding to three significant figures, the factor of safety is $1.52$.\n\nA factor of safety of $1.52$ indicates a low immediate risk of fracture for a single occlusal event of this magnitude. The applied load would need to be approximately $1.52$ times greater to initiate failure at this location.", "answer": "$$\\boxed{1.52}$$", "id": "4718409"}, {"introduction": "Many critical biomechanical interactions, like that between a dental implant and bone, are governed by non-linear phenomena such as contact and friction. Accurately modeling the \"stick-slip\" behavior at these interfaces is key to understanding processes like implant insertion and stability. In this advanced practice, you will implement an active-set algorithm to solve a non-linear contact problem, providing insight into how insertion torque translates into interfacial stresses along the implant threads [@problem_id:4718391].", "problem": "You are to design and implement a small but complete finite element simulation to approximate the interfacial shear stress distribution along the threads of a dental implant embedded in bone under insertion torque. The model is one-dimensional in torsion and enforces local Coulomb friction at each thread-bone contact. Your program must assemble and solve the discrete equilibrium equations, perform an active-set treatment of stick-slip contact at the threads, and post-process the interfacial shear stresses. The final result for each test case shall be the maximum magnitude of interfacial shear stress across all threads, expressed in megapascal (MPa) as a floating-point number rounded to six decimal places.\n\nMathematical and physical modeling assumptions:\n- Represent the implant as a prismatic circular shaft of length $L$ with constant polar second moment of area $J$ and shear modulus $G$, discretized into $n_{\\mathrm{thr}}$ equal torsional beam elements. The shaft twist field is $\\theta(x)$, and its discrete values at nodes are $\\{\\theta_i\\}$ for $i \\in \\{0,1,\\dots,n_{\\mathrm{thr}}\\}$ with node coordinates $x_i = i\\,L/n_{\\mathrm{thr}}$.\n- The torsional beam element stiffness over an element of length $\\ell_e$ is $k_e = GJ/\\ell_e$, and the corresponding element stiffness matrix is $k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$ assembled over adjacent nodes.\n- Each thread is located at node $i \\in \\{1,2,\\dots,n_{\\mathrm{thr}}\\}$ and couples the implant to the surrounding bone through a local tangential contact modeled by a linear spring in stick with stiffness $k_{t,i}$, but with a Coulomb friction cap. The tangential contact torque at node $i$ obeys $t_i = k_{t,i}\\,\\theta_i$ in stick and $|t_i| \\le T^{\\max}_i$ in general, where $T^{\\max}_i = \\mu\\,N_i\\,r_{\\mathrm{thr}}$. Here $\\mu$ is the friction coefficient, $N_i$ is a prescribed normal preload at thread $i$, and $r_{\\mathrm{thr}}$ is the thread contact radius.\n- The tangential spring stiffness at a thread is derived from a local interfacial shear foundation of stiffness per unit area $k_s$ (in $\\mathrm{N}/\\mathrm{mm}^3$). Denoting the thread flank contact area by $A_i = 2\\pi r_{\\mathrm{thr}}\\,b$ where $b$ is the axial engagement width per thread, the torque-based spring stiffness is $k_{t,i} = k_s\\,A_i\\,r_{\\mathrm{thr}}^2$.\n- Static equilibrium in torsion is imposed by the finite element method under an applied insertion torque $T_{\\mathrm{app}}$ at the coronal node $i=0$. To regularize the system and remove the rigid rotation mode, enforce the essential boundary condition $\\theta(L)=0$ at the apical node $i=n_{\\mathrm{thr}}$.\n- Implement contact with Coulomb friction by an active-set iteration: initialize all threads as sticking, solve the linear system, then identify any thread $i$ with $|k_{t,i}\\theta_i| > T^{\\max}_i$; such a thread is reclassified as slipping with its spring stiffness removed and a resisting torque of magnitude $T^{\\max}_i$ applied opposite to the local twist direction. Re-solve and repeat until the stick/slip set stabilizes.\n- The interfacial shear stress at thread $i$ is defined as $\\tau_i = t_i/(r_{\\mathrm{thr}}\\,A_i)$ with units of $\\mathrm{N}/\\mathrm{mm}^2$ (i.e., $\\mathrm{MPa}$). Here $t_i$ is the final contact torque at the thread after convergence (equal to $k_{t,i}\\theta_i$ for stick and $T^{\\max}_i\\,\\mathrm{sign}(\\theta_i)$ for slip). Report the maximum absolute interfacial shear stress $\\max_i |\\tau_i|$ over all threads.\n\nFundamental bases to be used:\n- Torsion of circular shafts under small-strain linear elasticity: $T(x) = GJ\\,\\mathrm{d}\\theta/\\mathrm{d}x$, and the corresponding finite element discretization in terms of nodal twists $\\{\\theta_i\\}$ and element stiffness $k_e = GJ/\\ell_e$.\n- Static equilibrium from Newton’s second law (in the quasi-static limit): internal plus external torques sum to zero at each degree of freedom.\n- Coulomb friction law: $|t_i| \\le \\mu N_i r_{\\mathrm{thr}}$ with stick if $|k_{t,i}\\theta_i| \\le \\mu N_i r_{\\mathrm{thr}}$ and slip otherwise, opposing the local twist direction.\n\nUnits and constants:\n- All lengths must be in $\\mathrm{mm}$, torques in $\\mathrm{N}\\cdot\\mathrm{mm}$, forces in $\\mathrm{N}$, shear modulus in $\\mathrm{N}/\\mathrm{mm}^2$, stress in $\\mathrm{MPa}$, and angles in $\\mathrm{radians}$.\n- Use $J = \\pi r_{\\mathrm{sh}}^4/2$ for a circular shaft of radius $r_{\\mathrm{sh}}$.\n\nTest suite specification:\n- Geometry and material, common to all cases:\n  - Number of threads, $n_{\\mathrm{thr}} = 10$.\n  - Implant engaged length, $L = 8.0\\,\\mathrm{mm}$.\n  - Thread contact radius, $r_{\\mathrm{thr}} = 2.0\\,\\mathrm{mm}$.\n  - Shaft radius, $r_{\\mathrm{sh}} = 1.8\\,\\mathrm{mm}$.\n  - Thread axial engagement width, $b = 0.15\\,\\mathrm{mm}$.\n  - Shear modulus of titanium alloy, $G = 44000\\,\\mathrm{N}/\\mathrm{mm}^2$.\n  - Interfacial shear foundation stiffness per unit area, $k_s = 8000\\,\\mathrm{N}/\\mathrm{mm}^3$.\n- Friction and normal preload distribution, common to all cases:\n  - Friction coefficient, $\\mu = 0.30$.\n  - Normal preload at thread $i$, $N_i = N_0 \\exp(-\\alpha x_i/L)$ with $N_0 = 400\\,\\mathrm{N}$, $\\alpha = 2.0$, and $x_i = i\\,L/n_{\\mathrm{thr}}$.\n- Applied insertion torque per case:\n  - Case A: $T_{\\mathrm{app}} = 500\\,\\mathrm{N}\\cdot\\mathrm{mm}$.\n  - Case B: $T_{\\mathrm{app}} = 50\\,\\mathrm{N}\\cdot\\mathrm{mm}$.\n  - Case C: $T_{\\mathrm{app}} = 1200\\,\\mathrm{N}\\cdot\\mathrm{mm}$.\n\nComputational requirements:\n- Implement the finite element assembly, active-set friction iteration, and stress post-processing precisely as specified above.\n- For each case, output the single scalar $\\max_i |\\tau_i|$ as a float rounded to six decimal places, in $\\mathrm{MPa}$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\").\n\nYour implementation must be a complete, runnable program with no user input.", "solution": "The problem requires the design and implementation of a one-dimensional finite element model to determine the maximum interfacial shear stress on dental implant threads under insertion torque. The model must incorporate Coulomb friction at the thread-bone interface using an active-set iterative algorithm. The problem is scientifically well-posed and contains all necessary physical parameters, material properties, and geometric definitions for a unique solution.\n\nOur approach is to model the implant as a series of $n_{\\mathrm{thr}}$ torsional beam elements connecting $n_{\\mathrm{thr}}+1$ nodes, indexed from $i=0$ (coronal) to $i=n_{\\mathrm{thr}}$ (apical). The governing equation of the discretized system is the static equilibrium equation:\n$$\n\\mathbf{K} \\boldsymbol{\\theta} = \\mathbf{F}\n$$\nwhere $\\boldsymbol{\\theta}$ is the vector of nodal twists, $\\mathbf{K}$ is the global stiffness matrix, and $\\mathbf{F}$ is the global vector of externally applied torques.\n\nThe global stiffness matrix $\\mathbf{K}$ is assembled from two contributions: the torsional stiffness of the implant shaft, $\\mathbf{K}_{\\text{shaft}}$, and the tangential stiffness of the thread-bone interface for threads that are in a 'stick' condition, $\\mathbf{K}_{\\text{contact}}$.\n$$\n\\mathbf{K} = \\mathbf{K}_{\\text{shaft}} + \\mathbf{K}_{\\text{contact}}\n$$\nThe global force vector $\\mathbf{F}$ is composed of the externally applied torque, $\\mathbf{F}_{\\text{app}}$, and the known resisting torques from threads that are in a 'slip' condition, $\\mathbf{F}_{\\text{slip}}$.\n$$\n\\mathbf{F} = \\mathbf{F}_{\\text{app}} + \\mathbf{F}_{\\text{slip}}\n$$\n\n**1. Component Formulation**\n\n**Implant Shaft Stiffness ($\\mathbf{K}_{\\text{shaft}}$):**\nThe implant is discretized into $n_{\\mathrm{thr}}$ elements, each of length $\\ell_e = L/n_{\\mathrm{thr}}$. The torsional stiffness of a single element is given by $k_e = GJ/\\ell_e$, where $G$ is the shear modulus and $J = \\pi r_{\\mathrm{sh}}^4/2$ is the polar second moment of area of the implant shaft. For each element connecting nodes $j$ and $j+1$, the element stiffness matrix is:\n$$\n\\mathbf{k}^{(e)} = k_e \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\nThese element matrices are assembled into the global $(n_{\\mathrm{thr}}+1) \\times (n_{\\mathrm{thr}}+1)$ matrix $\\mathbf{K}_{\\text{shaft}}$ following standard finite element procedures.\n\n**Thread-Bone Interface (Contact Model):**\nThreads are located at nodes $i \\in \\{1, 2, \\dots, n_{\\mathrm{thr}}\\}$. Each thread's contact behavior is determined by an active-set algorithm.\n- **Stick Condition:** If a thread is sticking, it acts as a linear torsional spring connected to a rigid support (the bone). The spring stiffness is derived from the interfacial shear foundation stiffness per unit area, $k_s$. The thread contact area is $A_i = 2\\pi r_{\\mathrm{thr}} b$. The torque-based spring stiffness $k_{t,i}$ is constant for all threads since $A_i$ is constant:\n$$\nk_t = k_s A r_{\\mathrm{thr}}^2 = k_s (2\\pi r_{\\mathrm{thr}} b) r_{\\mathrm{thr}}^2 = 2\\pi k_s b r_{\\mathrm{thr}}^3\n$$\nThis stiffness value is added to the diagonal entry $K_{ii}$ of the global stiffness matrix, representing the contribution of $\\mathbf{K}_{\\text{contact}}$.\n\n- **Slip Condition:** A thread slips if the magnitude of the torque required to maintain the stick condition, $|k_t \\theta_i|$, exceeds a maximum frictional resistance, $T^{\\max}_i$. This limit is defined by the Coulomb friction model:\n$$\nT^{\\max}_i = \\mu N_i r_{\\mathrm{thr}}\n$$\nwhere $\\mu$ is the coefficient of friction and $N_i = N_0 \\exp(-\\alpha x_i/L)$ is the prescribed normal preload at thread $i$, with $x_i = i L/n_{\\mathrm{thr}}$. If a thread is slipping, its stiffness contribution to $\\mathbf{K}$ is zero. Instead, a known resisting torque of magnitude $T^{\\max}_i$ is applied to the implant, opposing its rotation. This is incorporated into the global force vector $\\mathbf{F}$. The equilibrium equation for a slipping node $i$ is part of the system $\\mathbf{K}_{\\text{shaft}} \\boldsymbol{\\theta} = \\mathbf{F}_{\\text{app}} + \\mathbf{F}_{\\text{slip}}$, where the $i$-th component of $\\mathbf{F}_{\\text{slip}}$ is $T^{\\max}_i \\cdot \\mathrm{sign}(\\theta_i)$.\n\n**2. Active-Set Algorithm and System Solution**\n\nThe non-linearity of the friction model necessitates an iterative solution. The active-set algorithm proceeds as follows:\n1.  **Initialization:** Assume all threads $i \\in \\{1, \\dots, n_{\\mathrm{thr}}\\}$ are in the 'stick' state.\n2.  **Iteration:** A loop is initiated and continues until the set of sticking and slipping threads does not change between two consecutive iterations.\n    a.  **Assemble and Solve:** The system $\\mathbf{K} \\boldsymbol{\\theta} = \\mathbf{F}$ is assembled based on the current stick/slip status of each thread. For slipping threads, the term $T^{\\max}_i \\cdot \\mathrm{sign}(\\theta_i^{\\text{prev}})$ is added to the force vector, where $\\theta_i^{\\text{prev}}$ is the twist from the previous iteration. The essential boundary condition $\\theta_{n_{\\mathrm{thr}}} = 0$ is enforced by solving a reduced system for the unknown degrees of freedom ($\\theta_0, \\dots, \\theta_{n_{\\mathrm{thr}}-1}$).\n    b.  **Update State:** The newly computed twists $\\boldsymbol{\\theta}$ are used to check the contact condition at each thread. For each thread $i$, the tentative stick torque $t_{\\text{tent},i} = k_t \\theta_i$ is computed.\n        - If $|t_{\\text{tent},i}| > T^{\\max}_i$, the thread's status is set to 'slip' for the next iteration.\n        - If $|t_{\\text{tent},i}| \\le T^{\\max}_i$, the thread's status is set to 'stick' for the next iteration.\n    c.  **Check Convergence:** If no thread changed its status during the update step, the solution has converged, and the loop terminates.\n\n**3. Post-Processing and Stress Calculation**\n\nUpon convergence, the final nodal twists $\\boldsymbol{\\theta}$ and stick/slip states are known. The final contact torque $t_i$ at each thread $i$ is calculated:\n- If thread $i$ is sticking: $t_i = k_t \\theta_i$.\n- If thread $i$ is slipping: $t_i = T^{\\max}_i \\cdot \\mathrm{sign}(\\theta_i)$.\n\nThe interfacial shear stress $\\tau_i$ is then calculated by normalizing the torque by the effective torque arm $r_{\\mathrm{thr}}$ and the contact area $A_i$:\n$$\n\\tau_i = \\frac{t_i}{r_{\\mathrm{thr}} A_i} = \\frac{t_i}{2\\pi r_{\\mathrm{thr}}^2 b}\n$$\nThe final required output for each test case is the maximum absolute value of this stress across all threads, $\\max_{i=1,\\dots,n_{\\mathrm{thr}}} |\\tau_i|$, reported in units of $\\mathrm{MPa}$ ($\\mathrm{N}/\\mathrm{mm}^2$).\n\nThis rigorous, principle-based computational procedure will be implemented in Python using the NumPy library for numerical computations.", "answer": "```python\nimport numpy as np\n\ndef calculate_max_stress(T_app, n_thr, L, r_thr, r_sh, b, G, k_s, mu, N0, alpha):\n    \"\"\"\n    Calculates the maximum interfacial shear stress for a dental implant model.\n\n    This function implements a 1D torsional finite element model with an\n    active-set algorithm to handle Coulomb friction at the thread-bone interface.\n    \"\"\"\n    # 1. Pre-computation of constants and parameters\n    num_nodes = n_thr + 1\n    ell_e = L / n_thr\n    \n    # Implant shaft properties\n    J = np.pi * r_sh**4 / 2\n    k_e = G * J / ell_e\n    \n    # Thread-bone interface properties (constant for all threads)\n    A = 2 * np.pi * r_thr * b\n    k_t = k_s * A * r_thr**2\n    \n    # Thread-specific properties\n    node_coords = np.linspace(0, L, num_nodes)\n    thread_node_indices = np.arange(1, num_nodes)\n    x_i = node_coords[thread_node_indices]\n    \n    N_i_array = N0 * np.exp(-alpha * x_i / L)\n    T_max_i_array = mu * N_i_array * r_thr\n    \n    # 2. Assemble base stiffness matrix for the implant shaft\n    K_shaft = np.zeros((num_nodes, num_nodes))\n    for i in range(n_thr):\n        K_elem = k_e * np.array([[1, -1], [-1, 1]])\n        K_shaft[i:i+2, i:i+2] += K_elem\n        \n    # 3. Active-set iteration for friction\n    max_iter = 50\n    # True for 'stick', False for 'slip'. Indices 0 to n_thr-1 correspond to threads 1 to n_thr.\n    stick_status = [True] * n_thr\n    theta = np.zeros(num_nodes)  # Initialize nodal twists\n    \n    for _ in range(max_iter):\n        K_iter = K_shaft.copy()\n        F_iter = np.zeros(num_nodes)\n        F_iter[0] = T_app\n\n        # Assemble stiffness and force contributions from threads based on current status\n        for i in range(n_thr):\n            node_idx = i + 1\n            if stick_status[i]:\n                K_iter[node_idx, node_idx] += k_t\n            else:  # Slip\n                # Add slip force based on twist from the PREVIOUS iteration\n                F_iter[node_idx] += T_max_i_array[i] * np.sign(theta[node_idx])\n\n        # Apply boundary condition theta(L) = 0 by solving a reduced system\n        # The last DoF (theta_n_thr) is prescribed, so we solve for the first n_thr DoFs.\n        num_unknowns = num_nodes - 1\n        K_reduced = K_iter[:num_unknowns, :num_unknowns]\n        F_reduced = F_iter[:num_unknowns]\n        \n        try:\n            theta_reduced = np.linalg.solve(K_reduced, F_reduced)\n        except np.linalg.LinAlgError:\n            # This should not happen in this well-posed problem, but is good practice.\n            return np.nan\n\n        # Update the full twist vector with the solution\n        theta_new = np.zeros(num_nodes)\n        theta_new[:num_unknowns] = theta_reduced\n        theta = theta_new\n\n        # Check for changes in stick/slip status to determine convergence\n        new_stick_status = list(stick_status)\n        changed = False\n        for i in range(n_thr):\n            node_idx = i + 1\n            tentative_stick_torque = k_t * theta[node_idx]\n            \n            # Check if the stick condition is violated\n            if abs(tentative_stick_torque) > T_max_i_array[i]:\n                if new_stick_status[i]:  # Was sticking, now slipping\n                    new_stick_status[i] = False\n                    changed = True\n            else: # Check if a slipping joint can now stick\n                if not new_stick_status[i]: # Was slipping, now sticking\n                    new_stick_status[i] = True\n                    changed = True\n        \n        stick_status = new_stick_status\n        \n        if not changed:\n            break\n            \n    # 4. Post-processing: Calculate final torques and stresses\n    final_torques = np.zeros(n_thr)\n    for i in range(n_thr):\n        node_idx = i + 1\n        if stick_status[i]:\n            final_torques[i] = k_t * theta[node_idx]\n        else:\n            final_torques[i] = T_max_i_array[i] * np.sign(theta[node_idx])\n\n    final_stresses = final_torques / (r_thr * A)\n    max_abs_stress = np.max(np.abs(final_stresses))\n    \n    return max_abs_stress\n\ndef solve():\n    \"\"\"\n    Main function to define problem parameters and run the test suite.\n    \"\"\"\n    # Common geometry and material properties\n    n_thr = 10\n    L = 8.0  # mm\n    r_thr = 2.0  # mm\n    r_sh = 1.8  # mm\n    b = 0.15  # mm\n    G = 44000.0  # N/mm^2 (MPa)\n    k_s = 8000.0  # N/mm^3\n\n    # Common friction and preload properties\n    mu = 0.30\n    N0 = 400.0  # N\n    alpha = 2.0\n\n    # Test cases for applied torque\n    test_cases = [\n        500.0,   # Case A\n        50.0,    # Case B\n        1200.0,  # Case C\n    ]\n\n    results = []\n    for T_app in test_cases:\n        max_stress = calculate_max_stress(T_app, n_thr, L, r_thr, r_sh, b, G, k_s, mu, N0, alpha)\n        results.append(max_stress)\n\n    # Format output as specified: comma-separated list in brackets, rounded to 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "4718391"}]}