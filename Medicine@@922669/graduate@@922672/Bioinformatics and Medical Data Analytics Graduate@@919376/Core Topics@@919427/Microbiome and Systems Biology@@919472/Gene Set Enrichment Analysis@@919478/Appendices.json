{"hands_on_practices": [{"introduction": "The running-sum statistic is the engine of Gene Set Enrichment Analysis. To truly understand how GSEA quantifies enrichment, there is no substitute for calculating the enrichment score ($ES$) by hand. This exercise [@problem_id:4567424] guides you through this fundamental process for a small, hypothetical dataset, building a concrete intuition for how the positions of gene set members ('hits') versus other genes ('misses') in a ranked list cause the running sum to rise and fall, ultimately yielding the final score.", "problem": "You are given a pre-ranked list of genes from a transcriptomic differential phenotype analysis, with each gene associated to a ranking metric magnitude interpreted as the absolute value of a correlation with the phenotype. The task is to compute the Gene Set Enrichment Analysis (GSEA) enrichment score at weighting parameter $p=1$ from first principles, using the Kolmogorov–Smirnov-like running-sum definition, and then identify the leading-edge subset. Do not use any pre-memorized shortcut formulas; instead, explicitly construct the running-sum process from the definitions of empirical cumulative distribution functions for hits and misses.\n\nThe total number of genes is $N=10$, the ordered ranked list from most to least associated is:\n1. MYC with score $10$\n2. TP53 with score $9$\n3. EGFR with score $8$\n4. BRCA1 with score $7$\n5. PTEN with score $6$\n6. KRAS with score $5$\n7. AKT1 with score $4$\n8. BRAF with score $3$\n9. MDM2 with score $2$\n10. CDK2 with score $1$\n\nConsider the gene set $S$ of size $|S|=3$ given by $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$. Use weighting parameter $p=1$ so that at a hit the running sum increases by a value proportional to the gene’s score and normalized by the total score of $S$, and at a miss the running sum decreases by a constant so that the total decrement over all misses equals $1$.\n\nStarting from the definitions of the empirical cumulative distribution functions for hits and misses and their difference along the ranked list, compute by hand:\n- the enrichment score (ES) as the maximum deviation of the running sum from zero, and\n- the leading-edge subset corresponding to the location where the enrichment score is attained.\n\nExpress the enrichment score as an exact reduced rational number (no rounding), without units. The final answer should be only the enrichment score.", "solution": "The user-provided problem statement is subjected to a validation process.\n\n### Step 1: Extract Givens\n- Total number of genes in the ranked list: $N=10$.\n- Ranked list of genes with their scores (interpreted as absolute correlation):\n  1. MYC (score $10$)\n  2. TP53 (score $9$)\n  3. EGFR (score $8$)\n  4. BRCA1 (score $7$)\n  5. PTEN (score $6$)\n  6. KRAS (score $5$)\n  7. AKT1 (score $4$)\n  8. BRAF (score $3$)\n  9. MDM2 (score $2$)\n  10. CDK2 (score $1$)\n- Gene set of interest: $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$.\n- Size of the gene set: $N_H = |S|=3$.\n- Weighting parameter: $p=1$.\n- Rule for hit increment: For a gene in $S$, the running sum increases by a value proportional to the gene's score, normalized by the total score of all genes in $S$.\n- Rule for miss decrement: For a gene not in $S$, the running sum decreases by a constant value, such that the sum of all decrements over all misses equals $1$.\n- Definition of Enrichment Score (ES): The maximum deviation of the running sum from zero.\n- Task: Compute the ES and the leading-edge subset from first principles, using the running-sum defined by empirical cumulative distribution functions.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, as it describes a standard, albeit simplified, procedure for Gene Set Enrichment Analysis (GSEA), a well-established method in bioinformatics. The use of a weighted Kolmogorov-Smirnov-like statistic with $p=1$ is a valid GSEA variant. All necessary data ($N$, the ranked list, the scores, the gene set $S$, and the rules for the running sum) are provided, making the problem well-posed and self-contained. The language is objective and the data are internally consistent. The problem does not violate any of the invalidity criteria.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid**. A solution will be provided.\n\n### Solution\nThe Gene Set Enrichment Analysis (GSEA) enrichment score (ES) is calculated by walking down the ranked list of genes, $L$, and computing a running-sum statistic. The ES is the maximum deviation of this running sum from zero. The running sum at any point $i$ in the ranked list is the difference between a weighted empirical cumulative distribution function for the genes present in the set $S$ (hits) and an empirical cumulative distribution function for genes not in $S$ (misses).\n\nFirst, we identify the hits and misses in the ranked list. The total number of genes is $N=10$. The gene set $S=\\{\\text{TP53}, \\text{KRAS}, \\text{MDM2}\\}$ has $N_H = |S| = 3$ genes (hits). The number of genes not in $S$ is $N_M = N - N_H = 10 - 3 = 7$ (misses).\n\nThe ranked list with hit/miss status and scores ($r_j$) is as follows:\n1. MYC, $r_1=10$ (Miss)\n2. TP53, $r_2=9$ (Hit)\n3. EGFR, $r_3=8$ (Miss)\n4. BRCA1, $r_4=7$ (Miss)\n5. PTEN, $r_5=6$ (Miss)\n6. KRAS, $r_6=5$ (Hit)\n7. AKT1, $r_7=4$ (Miss)\n8. BRAF, $r_8=3$ (Miss)\n9. MDM2, $r_9=2$ (Hit)\n10. CDK2, $r_{10}=1$ (Miss)\n\nThe running sum at rank $i$, denoted $ES_i$, is defined as $ES_i = P_{hit}(S, i) - P_{miss}(S, i)$.\n\nThe term $P_{hit}(S, i)$ is the weighted empirical cumulative distribution of hits. With the weighting parameter $p=1$, it is calculated as:\n$$P_{hit}(S, i) = \\sum_{g_j \\in S, j \\le i} \\frac{r_j}{N_R}$$\nwhere $N_R$ is the normalization factor, equal to the sum of scores for all genes in $S$:\n$$N_R = \\sum_{g_j \\in S} r_j = r_{\\text{TP53}} + r_{\\text{KRAS}} + r_{\\text{MDM2}} = 9 + 5 + 2 = 16$$\nWhen we encounter a hit $g_j \\in S$ at rank $j$ with score $r_j$, the running sum increases by $\\frac{r_j}{N_R} = \\frac{r_j}{16}$.\n\nThe term $P_{miss}(S, i)$ is the empirical cumulative distribution of misses:\n$$P_{miss}(S, i) = \\sum_{g_j \\notin S, j \\le i} \\frac{1}{N_M}$$\nwhere $N_M = 7$. When we encounter a miss $g_j \\notin S$ at rank $j$, the running sum decreases by $\\frac{1}{N_M} = \\frac{1}{7}$.\n\nWe now compute the running sum $ES_i$ for each gene $g_i$ in the ranked list, starting with $ES_0=0$.\n\n1.  **Gene 1 (MYC, Miss):**\n    $P_{hit}(S, 1) = 0$. $P_{miss}(S, 1) = \\frac{1}{7}$.\n    $ES_1 = 0 - \\frac{1}{7} = -\\frac{1}{7} = -\\frac{16}{112}$.\n\n2.  **Gene 2 (TP53, Hit, score=9):**\n    $P_{hit}(S, 2) = \\frac{9}{16}$. $P_{miss}(S, 2) = \\frac{1}{7}$.\n    $ES_2 = \\frac{9}{16} - \\frac{1}{7} = \\frac{63 - 16}{112} = \\frac{47}{112}$.\n\n3.  **Gene 3 (EGFR, Miss):**\n    $P_{hit}(S, 3) = \\frac{9}{16}$. $P_{miss}(S, 3) = \\frac{2}{7}$.\n    $ES_3 = \\frac{9}{16} - \\frac{2}{7} = \\frac{63 - 32}{112} = \\frac{31}{112}$.\n\n4.  **Gene 4 (BRCA1, Miss):**\n    $P_{hit}(S, 4) = \\frac{9}{16}$. $P_{miss}(S, 4) = \\frac{3}{7}$.\n    $ES_4 = \\frac{9}{16} - \\frac{3}{7} = \\frac{63 - 48}{112} = \\frac{15}{112}$.\n\n5.  **Gene 5 (PTEN, Miss):**\n    $P_{hit}(S, 5) = \\frac{9}{16}$. $P_{miss}(S, 5) = \\frac{4}{7}$.\n    $ES_5 = \\frac{9}{16} - \\frac{4}{7} = \\frac{63 - 64}{112} = -\\frac{1}{112}$.\n\n6.  **Gene 6 (KRAS, Hit, score=5):**\n    $P_{hit}(S, 6) = \\frac{9}{16} + \\frac{5}{16} = \\frac{14}{16}$. $P_{miss}(S, 6) = \\frac{4}{7}$.\n    $ES_6 = \\frac{14}{16} - \\frac{4}{7} = \\frac{7}{8} - \\frac{4}{7} = \\frac{49 - 32}{56} = \\frac{17}{56} = \\frac{34}{112}$.\n\n7.  **Gene 7 (AKT1, Miss):**\n    $P_{hit}(S, 7) = \\frac{14}{16}$. $P_{miss}(S, 7) = \\frac{5}{7}$.\n    $ES_7 = \\frac{14}{16} - \\frac{5}{7} = \\frac{7}{8} - \\frac{5}{7} = \\frac{49 - 40}{56} = \\frac{9}{56} = \\frac{18}{112}$.\n\n8.  **Gene 8 (BRAF, Miss):**\n    $P_{hit}(S, 8) = \\frac{14}{16}$. $P_{miss}(S, 8) = \\frac{6}{7}$.\n    $ES_8 = \\frac{14}{16} - \\frac{6}{7} = \\frac{7}{8} - \\frac{6}{7} = \\frac{49 - 48}{56} = \\frac{1}{56} = \\frac{2}{112}$.\n\n9.  **Gene 9 (MDM2, Hit, score=2):**\n    $P_{hit}(S, 9) = \\frac{14}{16} + \\frac{2}{16} = \\frac{16}{16} = 1$. $P_{miss}(S, 9) = \\frac{6}{7}$.\n    $ES_9 = 1 - \\frac{6}{7} = \\frac{1}{7} = \\frac{16}{112}$.\n\n10. **Gene 10 (CDK2, Miss):**\n    $P_{hit}(S, 10) = 1$. $P_{miss}(S, 10) = \\frac{7}{7} = 1$.\n    $ES_{10} = 1 - 1 = 0$.\n\nThe sequence of running-sum values is: $\\{-\\frac{16}{112}, \\frac{47}{112}, \\frac{31}{112}, \\frac{15}{112}, -\\frac{1}{112}, \\frac{34}{112}, \\frac{18}{112}, \\frac{2}{112}, \\frac{16}{112}, 0\\}$.\n\nThe Enrichment Score (ES) is the maximum deviation of this running sum from zero. This is the maximum of the absolute values of the running sums:\n$$ES = \\max_{i=1,\\ldots,10} |ES_i|$$\nThe maximum value in the set is $ES_2 = \\frac{47}{112}$. The minimum value is $ES_1 = -\\frac{16}{112}$.\nThe maximum deviation from zero is $\\max(\\frac{47}{112}, |-\\frac{16}{112}|) = \\max(\\frac{47}{112}, \\frac{16}{112}) = \\frac{47}{112}$.\nThus, the enrichment score is $\\frac{47}{112}$. The number $47$ is prime and does not divide $112 = 2^4 \\times 7$, so this fraction is in its simplest form.\n\nThe leading-edge subset consists of the genes from the set $S$ that appear in the ranked list up to the position where the maximum enrichment score was found. The maximum score, $ES = \\frac{47}{112}$, occurs at rank $i=2$. The genes in the ranked list up to rank $2$ are $\\{\\text{MYC}, \\text{TP53}\\}$. The intersection of this set with the gene set $S$ is $\\{\\text{TP53}\\}$. Therefore, the leading-edge subset is $\\{\\text{TP53}\\}$.", "answer": "$$\\boxed{\\frac{47}{112}}$$", "id": "4567424"}, {"introduction": "After computing a specific enrichment score, a deeper understanding comes from exploring the general properties of the GSEA statistic. This exercise [@problem_id:2393962] presents a powerful thought experiment: what happens in the extreme case of a gene set containing only a single gene? By deriving a closed-form expression for the $ES$, you will uncover the fundamental mathematical relationship between a gene's rank and the resulting enrichment score, revealing the core behavior of the algorithm.", "problem": "Consider Gene Set Enrichment Analysis (GSEA) applied to a ranked list of genes. Let there be a ranked list $\\mathcal{L}$ of $N$ distinct genes ordered from rank $1$ (top) to rank $N$ (bottom). Let the gene set $\\mathcal{S}$ contain exactly one gene (so $N_H = |\\mathcal{S}| = 1$), and suppose that this gene appears at rank $k \\in \\{1,2,\\dots,N\\}$ in $\\mathcal{L}$. Use the standard weighted running-sum definition of GSEA with exponent $p \\ge 0$: when scanning down the list from $i=1$ to $i=N$, define the running sum $R(i)$ as follows. If the $i$-th ranked gene is in $\\mathcal{S}$, increase $R(i)$ by $|r_i|^{p} / NR$, where $NR = \\sum_{g \\in \\mathcal{S}} |r_g|^{p}$, and if it is not in $\\mathcal{S}$, decrease $R(i)$ by $1/(N - N_H)$. Define the Enrichment Score $ES$ to be the maximum value of the running sum encountered along the walk, i.e., $ES = \\max_{1 \\le i \\le N} R(i)$. Express $ES$ solely as a closed-form function of $N$ and $k$. No numerical evaluation or rounding is required, and no units are to be reported.", "solution": "The problem as stated is subjected to validation.\n\n**Step 1: Extract Givens**\n- A ranked list $\\mathcal{L}$ of $N$ distinct genes. Ranks are from $1$ to $N$.\n- A gene set $\\mathcal{S}$ with size $N_H = |\\mathcal{S}| = 1$.\n- The single gene in $\\mathcal{S}$ is located at rank $k$, where $k \\in \\{1, 2, \\dots, N\\}$.\n- The GSEA exponent is $p \\ge 0$.\n- The running sum $R(i)$ is computed by scanning from $i=1$ to $i=N$.\n- If the $i$-th gene is in $\\mathcal{S}$ (a \"hit\"), the increment is $|r_i|^p / NR$. The term $r_i$ denotes the correlation or metric value for the gene at rank $i$.\n- $NR$ is defined as $NR = \\sum_{g \\in \\mathcal{S}} |r_g|^p$.\n- If the $i$-th gene is not in $\\mathcal{S}$ (a \"miss\"), the decrement is $1/(N - N_H)$.\n- The Enrichment Score is $ES = \\max_{1 \\le i \\le N} R(i)$.\n- The initial condition is implicitly $R(0)=0$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, as it is based on the well-established Gene Set Enrichment Analysis (GSEA) methodology. The setup with a single-gene set ($N_H=1$) is a simplification that renders the problem analytically tractable, but does not violate any fundamental principles. The problem is well-posed and objective.\n\nA potential ambiguity regarding the correlation values $r_i$ is resolved by careful inspection of the definitions. Since the gene set $\\mathcal{S}$ contains only one gene, which is at rank $k$, let its associated metric value be $r_k$. The normalization factor $NR$ is then $NR = \\sum_{g \\in \\mathcal{S}} |r_g|^p = |r_k|^p$. The increment for a hit, which occurs only at step $i=k$, is calculated as $|r_k|^p / NR = |r_k|^p / |r_k|^p = 1$. This holds for $p > 0$ under the reasonable assumption that the metric value $r_k$ is non-zero. For the case $p=0$, which corresponds to the unweighted GSEA statistic, the increment is $|r_k|^0 / NR = 1 / \\sum_{g \\in \\mathcal{S}} |r_g|^0 = 1 / N_H = 1/1 = 1$. Thus, for any $p \\ge 0$, the increment at a hit is precisely $1$.\n\nThe decrement for a miss is given by $1/(N-N_H)$. With $N_H=1$, this is $1/(N-1)$. This term is undefined if $N=1$. However, if $N=1$, then $N_H=1$ and the set of \"misses\" is empty. The problem implicitly assumes $N > 1$ for the decrement step to be meaningful, which is a standard condition in such analyses. The problem is therefore deemed self-contained and consistent.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be derived.\n\n**Derivation of the Solution**\nWe define the running sum $R(i)$ starting from $R(0)=0$. The change in the running sum at each step $j \\in \\{1, 2, \\dots, N\\}$ is $\\Delta_j$.\nA \"hit\" occurs only at rank $i=k$. The increment is $\\Delta_k = 1$.\nA \"miss\" occurs at any rank $i \\neq k$. The decrement is $-\\frac{1}{N-N_H}$. Since $N_H=1$, the decrement is $-\\frac{1}{N-1}$.\nSo, $\\Delta_j = 1$ if $j=k$, and $\\Delta_j = -\\frac{1}{N-1}$ if $j \\neq k$.\n\nThe running sum at step $i$ is given by $R(i) = \\sum_{j=1}^{i} \\Delta_j$. We analyze $R(i)$ in three cases based on the value of $i$ relative to $k$.\n\nCase 1: $1 \\le i < k$.\nIn this range, every step is a \"miss\".\n$$R(i) = \\sum_{j=1}^{i} \\left(-\\frac{1}{N-1}\\right) = i \\left(-\\frac{1}{N-1}\\right) = -\\frac{i}{N-1}$$\nSince $i \\ge 1$ and $N > 1$, all values of $R(i)$ in this range are negative. The function is strictly decreasing with $i$. The value just before the hit is $R(k-1) = -\\frac{k-1}{N-1}$.\n\nCase 2: $i=k$.\nThe running sum includes $k-1$ misses and one hit at step $k$.\n$$R(k) = R(k-1) + \\Delta_k = -\\frac{k-1}{N-1} + 1 = \\frac{-(k-1) + (N-1)}{N-1} = \\frac{N-k}{N-1}$$\nSince $1 \\le k \\le N$, we have $0 \\le N-k \\le N-1$, so $0 \\le R(k) \\le 1$.\n\nCase 3: $k < i \\le N$.\nThe running sum at step $i$ is the sum at step $k$ plus the decrements for all steps from $k+1$ to $i$. There are $i-k$ such steps, all of which are misses.\n$$R(i) = R(k) + \\sum_{j=k+1}^{i} \\left(-\\frac{1}{N-1}\\right) = R(k) - \\frac{i-k}{N-1}$$\nSubstituting the expression for $R(k)$:\n$$R(i) = \\frac{N-k}{N-1} - \\frac{i-k}{N-1} = \\frac{(N-k) - (i-k)}{N-1} = \\frac{N-i}{N-1}$$\nFor this range $k < i \\le N$, as $i$ increases, $N-i$ decreases, so $R(i)$ is a strictly decreasing function of $i$. The sequence of values starts at $R(k+1) = \\frac{N-(k+1)}{N-1}$ and ends at $R(N) = \\frac{N-N}{N-1}=0$.\n\nTo find the Enrichment Score, $ES = \\max_{1 \\le i \\le N} R(i)$, we must find the maximum value among the expressions for $R(i)$.\n- For $1 \\le i < k$, $R(i) = -i/(N-1) < 0$.\n- For $i \\ge k$, $R(i) = (N-i)/(N-1)$ for $i>k$ and $R(k)=(N-k)/(N-1)$. Since $i>k$, $N-i < N-k$, which implies $R(i) < R(k)$ for all $i > k$ (assuming $N-1>0$).\nThe sequence of values $R(i)$ for $i \\ge k$ is $R(k), R(k+1), \\dots, R(N)$, which is a strictly decreasing sequence.\nThus, the maximum value in the range $i \\ge k$ is $R(k)$.\nSince all values for $i<k$ are negative and $R(k) \\ge 0$, the global maximum over $1 \\le i \\le N$ must be $R(k)$.\n\nTherefore, the Enrichment Score is:\n$$ES = R(k) = \\frac{N-k}{N-1}$$\nThis expression is a closed-form function dependent only on $N$ and $k$, as required.\nFor verification, if the gene is ranked first ($k=1$), $ES = \\frac{N-1}{N-1} = 1$, the maximum possible score. If the gene is ranked last ($k=N$), $ES = \\frac{N-N}{N-1} = 0$. In this case, $R(i) = -i/(N-1)$ for $i < N$, all negative, and $R(N)=0$, so the maximum is indeed $0$. The result is consistent.", "answer": "$$\\boxed{\\frac{N-k}{N-1}}$$", "id": "2393962"}, {"introduction": "In practice, GSEA is rarely performed in isolation; it is the capstone of a broader bioinformatics pipeline. This advanced exercise [@problem_id:4346070] simulates a complete workflow, starting from the raw RNA-sequencing count data that is the basis for many modern genomic studies. You will implement the essential upstream steps—including data filtering, normalization, and statistical modeling—to generate the ranked gene list that GSEA depends on, thereby bridging the gap between abstract theory and the practical application of GSEA in transcriptomics research.", "problem": "You are given a directive to construct a pipeline that emulates the per-gene statistical outputs generated by widely used differential expression tools in transcriptomics analysis based on negative binomial modeling assumptions, in order to produce a ranked list suitable for Gene Set Enrichment Analysis (GSEA). The educational context is systems biomedicine, and the topic is gene set enrichment analysis. The pipeline must be grounded in fundamental principles: the negative binomial distribution as a model for RNA-sequencing counts, the concept of compositionality for library size normalization, and the delta method for variance propagation. The task is to implement, for each provided test case, a sequence of steps that justify each preprocessing action in terms of explicit assumptions, compute per-gene statistics suitable for ranking in GSEA, and then compute the classical running-sum enrichment score for a supplied gene set.\n\nFundamental base and assumptions to use:\n- Model RNA-sequencing count data for gene $g$ in sample $i$ as a draw from a negative binomial distribution with mean $\\mu_{g,i}$ and dispersion $\\phi_{g}$, denoted $\\operatorname{NB}(\\mu_{g,i}, \\phi_{g})$, with variance $\\operatorname{Var}(Y_{g,i}) = \\mu_{g,i} + \\phi_{g} \\mu_{g,i}^{2}$. The negative binomial probability mass function is given by\n$$\nP(Y=k \\mid \\mu, \\phi) = \\frac{\\Gamma(k + \\phi^{-1})}{\\Gamma(\\phi^{-1}) \\, k!} \\left(\\frac{\\phi^{-1}}{\\phi^{-1} + \\mu}\\right)^{\\phi^{-1}} \\left(\\frac{\\mu}{\\phi^{-1} + \\mu}\\right)^{k},\n$$\nfor integer $k \\ge 0$, $\\mu > 0$, and $\\phi > 0$.\n- Assume factorization of the expected counts as $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$ where $s_{i} > 0$ is an unknown sample-specific size factor capturing library size and compositional effects, and $\\theta_{g,i}$ is the latent expression level. This compositional assumption implies that only ratios of $\\theta_{g,i}$ are identifiable without absolute calibration.\n- Use a two-group design indicator $X_{i} \\in \\{0,1\\}$ with a log-link generalized linear model $\\log(\\mu_{g,i}) = \\log(s_{i}) + \\beta_{0,g} + \\beta_{1,g} X_{i}$ to model condition effects as multiplicative fold changes on the mean.\n- Use the delta method to approximate the variance of a smooth function of random variables. In particular, for the sample mean under the negative binomial model, the variance of the log of the mean is approximated by dividing the variance of the mean by the square of the mean.\n\nPreprocessing steps and statistical computations to implement for each test case:\n1. Filtering based on detectability: remove genes with insufficient evidence of expression, specifically those with fewer than $2$ samples having strictly positive counts or with a total count less than a chosen minimal value. This is justified by the requirement that the negative binomial dispersion estimation and log-fold-change variance rely on non-degenerate sample means and variances.\n2. Library size normalization: estimate sample-specific size factors $\\{s_{i}\\}$ using a median-of-ratios principle consistent with the factorization $\\mu_{g,i} = s_{i} \\, \\theta_{g,i}$. That is, estimate a pseudo-reference per-gene quantity and choose $s_{i}$ so that, for most genes, $Y_{g,i} / s_{i}$ is centered around the reference. When many zeros prevent a stable pseudo-reference, fall back to total-count normalization using $s_{i}$ proportional to the library size, standardized to have mean $1$.\n3. Dispersion estimation: for each gene $g$, estimate a raw dispersion $\\hat{\\phi}_{g}$ using method-of-moments from the normalized counts, $\\hat{\\phi}_{g} = \\max\\{0, (\\hat{v}_{g} - \\hat{m}_{g}) / \\hat{m}_{g}^{2}\\}$, where $\\hat{m}_{g}$ is the across-sample mean of normalized counts and $\\hat{v}_{g}$ is the across-sample variance. Then estimate a trend function $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$ of the form $a + b/\\hat{m}_{g}$ via least squares across genes, and shrink $\\hat{\\phi}_{g}$ toward $\\phi_{\\mathrm{trend}}(\\hat{m}_{g})$ to obtain a stabilized dispersion $\\tilde{\\phi}_{g}$ by a convex combination with weight depending on the number of samples.\n4. Per-gene effect and Wald statistic: compute per-gene group means $\\hat{\\mu}_{g,0}$ and $\\hat{\\mu}_{g,1}$ (on normalized scale) for the two conditions. Estimate the log fold change $\\widehat{\\mathrm{LFC}}_{g} = \\log\\left(\\frac{\\hat{\\mu}_{g,1}}{\\hat{\\mu}_{g,0}}\\right)$ using a small positive constant to avoid division by zero where necessary. Using the delta method and the negative binomial variance, approximate the variance of $\\widehat{\\mathrm{LFC}}_{g}$ as\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g}) \\approx \\frac{\\hat{\\mu}_{g,1} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,1}^{2}}{n_{1} \\, \\hat{\\mu}_{g,1}^{2}} + \\frac{\\hat{\\mu}_{g,0} + \\tilde{\\phi}_{g} \\hat{\\mu}_{g,0}^{2}}{n_{0} \\, \\hat{\\mu}_{g,0}^{2}},\n$$\nwhere $n_{1}$ and $n_{0}$ are the sample counts in the treatment and control groups, respectively. Define the Wald statistic $Z_{g} = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$, using $Z_{g} = 0$ when the denominator is zero.\n5. Ranking for GSEA: use $Z_{g}$ as the ranking score and compute a weighted running-sum enrichment score for a supplied gene set. For a gene set $S \\subset \\{1,\\dots,G\\}$ and scores $\\{Z_{g}\\}$, sort genes by decreasing $Z_{g}$, use weights $w_{g} = |Z_{g}|^{p}$ with $p = 1$, and compute a running sum that is incremented by $w_{g} / \\sum_{h \\in S} w_{h}$ when $g \\in S$ and decremented by $1 / (G - |S|)$ when $g \\notin S$. The enrichment score is the signed extreme deviation of this running sum from zero.\n\nTest suite:\nFor each test case, you are given a count matrix of dimensions $G \\times S$ (genes by samples), a binary condition vector of length $S$, and one gene set as indices into the gene list. Gene names are implicitly ordered as $G1, G2, \\dots$ corresponding to indices $1, 2, \\dots$.\n\n- Test case $1$ (balanced design, moderate counts):\n  - Counts matrix with $G = 12$ genes and $S = 6$ samples, three controls followed by three treatments. Control samples $A$, $B$, $C$:\n    - $A$: $[40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30]$\n    - $B$: $[42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32]$\n    - $C$: $[39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31]$\n  - Treatment samples $D$, $E$, $F$:\n    - $D$: $[41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33]$\n    - $E$: $[43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34]$\n    - $F$: $[40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]$\n  - Condition vector: $[0,0,0,1,1,1]$.\n  - Gene set: $S_{1} = \\{3,4,5,8,11\\}$.\n  - Required output: the single float enrichment score (running-sum as specified) computed from the pipeline above.\n\n- Test case $2$ (sparse counts, many zeros, balanced design):\n  - Counts matrix with $G = 10$ genes and $S = 4$ samples. Control samples $A$, $B$:\n    - $A$: $[0,0,1,0,2,1,0,0,0,1]$\n    - $B$: $[0,1,0,0,1,0,0,0,1,0]$\n  - Treatment samples $C$, $D$:\n    - $C$: $[0,0,0,0,1,1,0,1,0,0]$\n    - $D$: $[1,0,0,0,0,1,0,0,0,0]$\n  - Condition vector: $[0,0,1,1]$.\n  - Gene set: $S_{2} = \\{2,5,9\\}$.\n  - Required output: the single float enrichment score computed from the pipeline above.\n\n- Test case $3$ (unbalanced design, downregulation in gene set):\n  - Counts matrix with $G = 12$ genes and $S = 6$ samples, four controls followed by two treatments. Control samples $A$, $B$, $C$, $D$:\n    - $A$: $[30,45,60,55,50,40,35,20,25,18,22,28]$\n    - $B$: $[31,44,62,57,49,39,36,21,26,19,23,29]$\n    - $C$: $[32,46,61,56,51,41,34,22,27,17,24,30]$\n    - $D$: $[29,47,63,54,52,42,33,23,28,20,21,27]$\n  - Treatment samples $E$, $F$:\n    - $E$: $[15,45,30,28,26,40,35,20,25,18,22,28]$\n    - $F$: $[16,44,31,29,27,39,36,21,26,19,23,29]$\n  - Condition vector: $[0,0,0,0,1,1]$.\n  - Gene set: $S_{3} = \\{1,3,4,5\\}$.\n  - Required output: the single float enrichment score computed from the pipeline above.\n\nFinal output format:\nYour program should produce a single line of output containing the three results as a comma-separated list enclosed in square brackets (e.g., $\"[result1,result2,result3]\"$), where each result is the float enrichment score for the corresponding test case. No additional text should be printed. Angles are not involved, and there are no physical units; express all results as plain decimal floats.", "solution": "The user has directed the construction of a computational pipeline to emulate a standard transcriptomics differential expression analysis followed by Gene Set Enrichment Analysis (GSEA). The problem is scientifically sound, well-posed, and objective, providing a clear sequence of steps based on established principles in systems biomedicine. All necessary components, including the statistical model for RNA-sequencing counts, normalization procedures, effect size estimation, and the enrichment score calculation, are specified. Some minor parameters are left unspecified, which is common in such problems; these have been set to standard, reasonable values as detailed below.\n\nThe solution proceeds by implementing the five specified stages of the analysis pipeline for each test case.\n\n**1. Gene Filtering**\n\nThe first step is to filter out genes with insufficient expression levels, which lack statistical power and can introduce noise. The problem specifies two criteria: remove genes with fewer than $2$ samples having strictly positive counts, or with a total count across all samples less than a chosen minimal value. The rationale is to ensure that per-gene means and variances are computable and non-degenerate. For the sparse data in test case $2$, a high minimal total count would eliminate all genes. Therefore, a small value of $2$ is chosen for this threshold, i.e., `total_count` $\\ge 2$, to retain a minimal set of genes for analysis, which is a common practice for very sparse datasets.\n\n**2. Library Size Normalization**\n\nRNA-sequencing count data is compositional, meaning a gene's count depends on both its expression and the total sequencing depth of its sample. To make counts comparable across samples, we must estimate sample-specific size factors, $s_i$. The model assumes $\\mu_{g,i} = s_i \\theta_{g,i}$, where $\\mu_{g,i}$ is the expected count for gene $g$ in sample $i$, and $\\theta_{g,i}$ is the true expression level. The primary method for estimating $s_i$ is the median-of-ratios method. A pseudo-reference sample is created by taking the geometric mean of counts for each gene across all samples. This is only possible for genes with non-zero counts in every sample. The size factor for each sample $i$ is then the median of the ratios of its counts to the pseudo-reference counts.\n\nIf no gene is expressed in all samples (a common occurrence with sparse data, as in test case $2$), this method fails. The specified fallback is total-count normalization. In this case, the size factor for a sample is its total number of reads. Finally, the set of estimated size factors $\\{s_i\\}$ is scaled to have a mean of $1$ to maintain the count scale. Normalized counts are then computed as $Y_{g,i} / s_i$.\n\n**3. Dispersion Estimation**\n\nThe negative binomial distribution, $\\operatorname{NB}(\\mu, \\phi)$, has a variance that depends on both the mean $\\mu$ and a dispersion parameter $\\phi$ via $\\operatorname{Var}(Y) = \\mu + \\phi \\mu^2$. An accurate estimate of $\\phi$ is critical. This is achieved in three sub-steps:\n- **Raw Dispersion**: For each gene $g$, a raw dispersion $\\hat{\\phi}_g$ is estimated using the method of moments on the normalized counts. The sample mean $\\hat{m}_g$ and variance $\\hat{v}_g$ are computed, and the dispersion is $\\hat{\\phi}_g = \\max\\{0, (\\hat{v}_g - \\hat{m}_g) / \\hat{m}_g^2\\}$.\n- **Trend Fitting**: Individual gene dispersion estimates from small sample sizes are noisy. A more stable estimate is found by modeling the general relationship between dispersion and mean expression. A trend function of the form $\\phi_{\\mathrm{trend}}(\\hat{m}_g) = a + b/\\hat{m}_g$ is fitted to the $(\\hat{m}_g, \\hat{\\phi}_g)$ pairs across all genes using ordinary least squares.\n- **Shrinkage**: The final, stabilized dispersion estimate $\\tilde{\\phi}_g$ for each gene is a weighted average of its raw estimate $\\hat{\\phi}_g$ and the trend value $\\phi_{\\mathrm{trend}}(\\hat{m}_g)$. This \"shrinks\" noisy individual estimates toward the more stable trend. The convex combination is $\\tilde{\\phi}_{g} = \\alpha \\phi_{\\mathrm{trend}}(\\hat{m}_g) + (1-\\alpha) \\hat{\\phi}_{g}$. The weight $\\alpha$ depends on the number of samples $S$, giving more credence to the raw estimate as sample size increases. We use $\\alpha = k/(k+S)$ with a prior strength parameter of $k=4$.\n\n**4. Per-Gene Effect and Wald Statistic**\n\nThe goal is to quantify the expression change between two conditions (e.g., treatment vs. control).\n- **Log-Fold Change (LFC)**: The per-gene means of normalized counts are calculated for the control group ($\\hat{\\mu}_{g,0}$) and the treatment group ($\\hat{\\mu}_{g,1}$). The effect size is the log-fold change, $\\widehat{\\mathrm{LFC}}_{g} = \\log_e(\\hat{\\mu}_{g,1} / \\hat{\\mu}_{g,0})$. To prevent division by zero or taking the logarithm of zero if a group mean is $0$, a small constant $\\epsilon = 10^{-8}$ is added to each mean before calculation.\n- **LFC Variance and Wald Statistic**: The significance of the LFC is assessed using a Wald test. The variance of the LFC estimator is approximated using the delta method and the negative binomial variance function, yielding:\n$$\n\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g}) \\approx \\frac{1/\\hat{\\mu}_{g,1} + \\tilde{\\phi}_{g}}{n_{1}} + \\frac{1/\\hat{\\mu}_{g,0} + \\tilde{\\phi}_{g}}{n_{0}}\n$$\nwhere $n_0$ and $n_1$ are the number of samples in the control and treatment groups, respectively. The Wald statistic is then $Z_g = \\widehat{\\mathrm{LFC}}_{g} / \\sqrt{\\widehat{\\operatorname{Var}}(\\widehat{\\mathrm{LFC}}_{g})}$. This statistic serves as the ranking metric for GSEA. If the variance is zero, $Z_g$ is set to $0$.\n\n**5. Gene Set Enrichment Analysis (GSEA)**\n\nGSEA determines whether a predefined set of genes $S$ shows statistically significant, concordant differences between the two conditions.\n- **Ranking**: All filtered genes are ranked in decreasing order based on their Wald statistic $Z_g$.\n- **Running Sum**: A running sum is calculated by walking down the ranked list. The sum is incremented for each gene found that is in the set $S$ and decremented for each gene not in the set. The step sizes are weighted. For a gene $g \\in S$, the increment is proportional to its score, $|Z_g|^p$ with $p=1$, normalized by the total sum of weights for all genes in $S$. For a gene $g \\notin S$, the decrement is a constant $1 / (G_{filt} - |S_{filt}|)$, where $G_{filt}$ is the total number of filtered genes and $|S_{filt}|$ is the size of the filtered gene set.\n- **Enrichment Score (ES)**: The ES is the maximum deviation of the running sum from zero. It is signed, taking the value of the maximum positive deviation or the maximum negative deviation, whichever is larger in magnitude. This score reflects the degree to which the gene set $S$ is overrepresented at the top or bottom of the ranked list of all genes.\n\nThis complete pipeline is applied to each test case to compute the final enrichment score.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the analysis pipeline on the provided test cases.\n    \"\"\"\n\n    def run_pipeline(counts_matrix, condition_vector, gene_set):\n        \"\"\"\n        Executes the full GSEA pipeline for a single test case.\n        \"\"\"\n        # Data setup\n        counts = np.array(counts_matrix).T  # Transpose to get Genes x Samples\n        conditions = np.array(condition_vector)\n        # Convert 1-based gene set to 0-based for Python indexing\n        gene_set_indices = {g - 1 for g in gene_set}\n        \n        # Step 1: Filtering based on detectability\n        min_samples_positive = 2\n        min_total_count = 2  # A reasonable assumption for the provided sparse data\n        \n        positive_samples_per_gene = np.sum(counts > 0, axis=1)\n        total_counts_per_gene = np.sum(counts, axis=1)\n        \n        keep_mask = (positive_samples_per_gene >= min_samples_positive) & \\\n                    (total_counts_per_gene >= min_total_count)\n        \n        filtered_counts = counts[keep_mask]\n        \n        if filtered_counts.shape[0] == 0:\n            return 0.0\n\n        original_indices = np.where(keep_mask)[0]\n        gene_map = {orig_idx: new_idx for new_idx, orig_idx in enumerate(original_indices)}\n        filtered_gene_set = {gene_map[g_idx] for g_idx in gene_set_indices if g_idx in gene_map}\n\n        G_filt, S = filtered_counts.shape\n        \n        # Step 2: Library size normalization\n        genes_all_nonzero_mask = np.all(filtered_counts > 0, axis=1)\n        \n        if np.any(genes_all_nonzero_mask):\n            # Median-of-ratios method\n            pseudo_ref_table = filtered_counts[genes_all_nonzero_mask, :]\n            geo_means = np.exp(np.mean(np.log(pseudo_ref_table), axis=1))\n            \n            # Prevent division by zero if a geo_mean is zero\n            geo_means[geo_means == 0] = 1e-9\n\n            # Ratios are S x num_ref_genes\n            ratios = pseudo_ref_table.T / geo_means\n            size_factors_raw = np.median(ratios, axis=1)\n        else:\n            # Fallback to total-count normalization using original pre-filter counts\n            size_factors_raw = np.sum(counts, axis=0)\n            \n        # Standardize size factors to have a mean of 1\n        size_factors = size_factors_raw / np.mean(size_factors_raw)\n        \n        normalized_counts = filtered_counts / size_factors[np.newaxis, :]\n        \n        # Step 3: Dispersion estimation\n        means_g = np.mean(normalized_counts, axis=1)\n        # ddof=1 for unbiased sample variance\n        vars_g = np.var(normalized_counts, axis=1, ddof=1)\n        \n        # Raw dispersion\n        phi_raw = np.zeros_like(means_g)\n        idx_mean_pos = means_g > 0\n        phi_raw[idx_mean_pos] = (vars_g[idx_mean_pos] - means_g[idx_mean_pos]) / (means_g[idx_mean_pos]**2)\n        phi_raw[phi_raw < 0] = 0\n        \n        # Trend fitting\n        phi_trend = np.zeros_like(means_g)\n        fit_idx = idx_mean_pos & np.isfinite(phi_raw)\n        if np.sum(fit_idx) >= 2:\n            means_for_fit = means_g[fit_idx]\n            phi_for_fit = phi_raw[fit_idx]\n            \n            X_fit = np.vstack([np.ones(means_for_fit.shape[0]), 1 / means_for_fit]).T\n            try:\n                coeffs, _, _, _ = np.linalg.lstsq(X_fit, phi_for_fit, rcond=None)\n                a, b = coeffs\n                phi_trend = a + b / means_g\n                phi_trend[phi_trend < 0] = 0\n            except np.linalg.LinAlgError:\n                positive_phi_raw = phi_raw[phi_raw > 0]\n                median_phi = np.median(positive_phi_raw) if len(positive_phi_raw) > 0 else 0.01\n                phi_trend[:] = median_phi\n        else:\n           positive_phi_raw = phi_raw[phi_raw > 0]\n           median_phi = np.median(positive_phi_raw) if len(positive_phi_raw) > 0 else 0.01\n           phi_trend[:] = median_phi\n\n        # Shrinkage\n        k = 4.0 # Prior strength parameter assumption\n        alpha = k / (k + S)\n        phi_shrunk = alpha * phi_trend + (1 - alpha) * phi_raw\n        phi_shrunk[phi_shrunk < 0] = 0\n\n        # Step 4: Per-gene effect and Wald statistic\n        cond0_mask = conditions == 0\n        cond1_mask = conditions == 1\n        n0, n1 = np.sum(cond0_mask), np.sum(cond1_mask)\n        \n        mu_g0 = np.mean(normalized_counts[:, cond0_mask], axis=1)\n        mu_g1 = np.mean(normalized_counts[:, cond1_mask], axis=1)\n        \n        epsilon = 1e-8 # Small constant for numerical stability\n        LFC = np.log((mu_g1 + epsilon) / (mu_g0 + epsilon))\n        \n        var_LFC = ((1 / (mu_g1 + epsilon) + phi_shrunk) / n1) + \\\n                  ((1 / (mu_g0 + epsilon) + phi_shrunk) / n0)\n        \n        Z_scores = np.zeros_like(LFC)\n        valid_var_mask = var_LFC > 0\n        Z_scores[valid_var_mask] = LFC[valid_var_mask] / np.sqrt(var_LFC[valid_var_mask])\n\n        # Step 5: Gene Set Enrichment Analysis\n        if len(filtered_gene_set) == 0 or len(filtered_gene_set) == G_filt:\n            return 0.0\n\n        in_set_mask = np.zeros(G_filt, dtype=bool)\n        if filtered_gene_set:\n            in_set_mask[list(filtered_gene_set)] = True\n\n        abs_Z = np.abs(Z_scores)\n        sum_weights_in_set = np.sum(abs_Z[in_set_mask])\n        \n        if sum_weights_in_set == 0:\n            return 0.0\n\n        sorted_indices = np.argsort(Z_scores)[::-1]\n        \n        is_in_set_sorted = in_set_mask[sorted_indices]\n        abs_Z_sorted = abs_Z[sorted_indices]\n        \n        step_hit = abs_Z_sorted / sum_weights_in_set\n        step_miss = 1.0 / (G_filt - len(filtered_gene_set))\n        \n        running_sum = 0.0\n        running_sum_values = [0.0]\n        \n        for i in range(G_filt):\n            if is_in_set_sorted[i]:\n                running_sum += step_hit[i]\n            else:\n                running_sum -= step_miss\n            running_sum_values.append(running_sum)\n            \n        max_rs = np.max(running_sum_values)\n        min_rs = np.min(running_sum_values)\n\n        return max_rs if abs(max_rs) > abs(min_rs) else min_rs\n            \n    test_cases = [\n        {\n            \"counts\": [\n                [40, 55, 20, 18, 22, 60, 35, 25, 45, 50, 28, 30],\n                [42, 53, 19, 20, 20, 58, 36, 24, 46, 51, 30, 32],\n                [39, 57, 18, 19, 21, 62, 34, 26, 44, 49, 29, 31],\n                [41, 56, 36, 40, 44, 61, 37, 50, 45, 52, 55, 33],\n                [43, 54, 35, 39, 43, 59, 38, 49, 47, 53, 54, 34],\n                [40, 58, 34, 41, 45, 63, 36, 51, 46, 50, 56, 35]\n            ],\n            \"conditions\": [0, 0, 0, 1, 1, 1],\n            \"gene_set\": {3, 4, 5, 8, 11}\n        },\n        {\n            \"counts\": [\n                [0, 0, 1, 0, 2, 1, 0, 0, 0, 1],\n                [0, 1, 0, 0, 1, 0, 0, 0, 1, 0],\n                [0, 0, 0, 0, 1, 1, 0, 1, 0, 0],\n                [1, 0, 0, 0, 0, 1, 0, 0, 0, 0]\n            ],\n            \"conditions\": [0, 0, 1, 1],\n            \"gene_set\": {2, 5, 9}\n        },\n        {\n            \"counts\": [\n                [30, 45, 60, 55, 50, 40, 35, 20, 25, 18, 22, 28],\n                [31, 44, 62, 57, 49, 39, 36, 21, 26, 19, 23, 29],\n                [32, 46, 61, 56, 51, 41, 34, 22, 27, 17, 24, 30],\n                [29, 47, 63, 54, 52, 42, 33, 23, 28, 20, 21, 27],\n                [15, 45, 30, 28, 26, 40, 35, 20, 25, 18, 22, 28],\n                [16, 44, 31, 29, 27, 39, 36, 21, 26, 19, 23, 29]\n            ],\n            \"conditions\": [0, 0, 0, 0, 1, 1],\n            \"gene_set\": {1, 3, 4, 5}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_pipeline(case[\"counts\"], case[\"conditions\"], case[\"gene_set\"])\n        results.append(result)\n\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "4346070"}]}