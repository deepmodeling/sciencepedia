{"hands_on_practices": [{"introduction": "Substitution matrices are the cornerstone of sequence alignment, yet their scores can seem arbitrary. This exercise demystifies their origin by guiding you through the foundational steps of constructing a BLOSUM-like matrix from a block of aligned sequences [@problem_id:4591431]. By performing sequence clustering, weighting, and calculating log-odds scores from first principles, you will gain a concrete understanding of how these matrices empirically capture the evolutionary patterns of amino acid substitutions.", "problem": "Consider an ungapped conserved block alignment of four protein sequences, each of length $6$ columns. The sequences are:\n- $S_1$: ACDEFG\n- $S_2$: ACDQFG\n- $S_3$: ASDEFG\n- $S_4$: VCNEY G\n\nAssume that Blocks Substitution Matrix (BLOSUM) clustering is performed using a greedy single-linkage scheme at identity threshold $T = 0.7$. In greedy single-linkage clustering, sequences are treated as nodes in a graph, an edge is drawn between two nodes if their pairwise identity (fraction of identical residues across the aligned columns) is at least $T$, and clusters are the connected components induced by these edges. Within each cluster, assign each sequence a weight equal to the reciprocal of the cluster size, and within-cluster aligned residue pairs are excluded from all subsequent counts. Between clusters, every pair of sequences contributes to observed aligned residue-pair counts, weighted by the product of the weights of the two sequences.\n\nUsing the foundational definitions that log-odds substitution scoring quantifies the information content of observing an aligned residue pair relative to the expectation under independent background composition, perform the following steps from first principles:\n- Determine the clusters at threshold $T$ and the resulting per-sequence weights.\n- Across all columns, enumerate all between-cluster sequence pairs and accumulate weighted counts for each unordered residue pair $\\{i,j\\}$, ignoring within-cluster pairs.\n- Normalize these counts to obtain unordered pair probabilities $p^{\\mathrm{unord}}_{ij}$ over all unordered pairs so that $\\sum_{i \\le j} p^{\\mathrm{unord}}_{ij} = 1$.\n- Convert $p^{\\mathrm{unord}}_{ij}$ to ordered pair probabilities $p_{ij}$ by distributing mass equally between $(i,j)$ and $(j,i)$ for $i \\ne j$, and leaving $p_{ii}$ unchanged, so that $\\sum_{i}\\sum_{j} p_{ij} = 1$.\n- Obtain residue background probabilities $q_i$ from the ordered pair probabilities by summing over alignments to $i$, i.e., $q_i = \\sum_{j} p_{ij}$.\n\nFinally, derive the BLOSUM-like base-$2$ log-odds substitution score for the specific off-diagonal pair $D$ aligned to $N$ using these definitions. Express the final score as an exact base-$2$ logarithm without rounding and without units. No gap penalty model is needed because the block is ungapped, but your derivation should clearly state why gaps would be excluded at this stage under typical block-based substitution matrix construction principles.", "solution": "The problem requires the calculation of a BLOSUM-like log-odds score for the amino acid pair (D, N) based on a small, ungapped block alignment of four sequences. The derivation must follow first principles, starting with sequence clustering and weighting, proceeding to pair counting and probability calculations, and concluding with the log-odds score formula.\n\nFirst, we validate the problem statement. The givens are four protein sequences, each purported to be of length $L=6$:\n$S_1$: ACDEFG\n$S_2$: ACDQFG\n$S_3$: ASDEFG\n$S_4$: VCNEY G\n\nThere is a patent inconsistency in the provided data. The problem states the length of each sequence is $6$ columns, but sequence $S_4$ as written, `VCNEY G`, contains a space and has a total character count of $7$. A space is not one of the $20$ standard amino acids. This is a contradiction. A rigorous analysis requires unambiguous data. I will proceed under the explicit and necessary assumption that the space is a typographical error and the intended sequence is $S_4$: `VCNEYG`, which is consistent with the stated length of $L=6$. Without this correction, the problem is ill-defined.\n\nThe derivation proceeds in the following steps.\n\n**Step 1: Sequence Clustering and Weighting**\n\nWe first compute the pairwise identity for all sequence pairs. The identity $I(S_a, S_b)$ is the fraction of identical residues in the alignment. The alignment length is $L=6$. The pairs are evaluated against the identity threshold $T = 0.7$.\n\nThe sequences are:\n$S_1$: ACDEFG\n$S_2$: ACDQFG\n$S_3$: ASDEFG\n$S_4$: VCNEYG\n\nPairwise identities:\n- $I(S_1, S_2)$: Matches at columns $1, 2, 3, 5, 6$. Number of matches = $5$. Identity = $5/6 \\approx 0.833$. Since $0.833 > 0.7$, an edge exists between $S_1$ and $S_2$.\n- $I(S_1, S_3)$: Matches at columns $1, 3, 4, 5, 6$. Number of matches = $5$. Identity = $5/6 \\approx 0.833$. Since $0.833 > 0.7$, an edge exists between $S_1$ and $S_3$.\n- $I(S_1, S_4)$: Matches at columns $2, 4, 6$. Number of matches = $3$. Identity = $3/6 = 0.5$. Since $0.5  0.7$, no edge exists between $S_1$ and $S_4$.\n- $I(S_2, S_3)$: Matches at columns $1, 3, 5, 6$. Number of matches = $4$. Identity = $4/6 \\approx 0.667$. Since $0.667  0.7$, no edge exists between $S_2$ and $S_3$.\n- $I(S_2, S_4)$: Matches at columns $2, 6$. Number of matches = $2$. Identity = $2/6 \\approx 0.333$. Since $0.333  0.7$, no edge exists between $S_2$ and $S_4$.\n- $I(S_3, S_4)$: Matches at columns $4, 6$. Number of matches = $2$. Identity = $2/6 \\approx 0.333$. Since $0.333  0.7$, no edge exists between $S_3$ and $S_4$.\n\nBased on single-linkage clustering, we identify connected components. Since $S_1$ is connected to both $S_2$ and $S_3$, the sequences $\\{S_1, S_2, S_3\\}$ form a single cluster. $S_4$ has no edges connecting to it, so it forms a singleton cluster.\nThe clusters are:\n- Cluster 1: $\\{S_1, S_2, S_3\\}$, size $n_1 = 3$.\n- Cluster 2: $\\{S_4\\}$, size $n_2 = 1$.\n\nThe weight for each sequence in a cluster is the reciprocal of the cluster size.\n- For $S_1, S_2, S_3$ in Cluster 1, the weight is $w_1 = w_2 = w_3 = 1/n_1 = 1/3$.\n- For $S_4$ in Cluster 2, the weight is $w_4 = 1/n_2 = 1/1 = 1$.\n\n**Step 2: Accumulate Weighted Pair Counts**\n\nAccording to the rules, we only count residue pairs from sequences in different clusters. The pairs to consider are $(S_1, S_4)$, $(S_2, S_4)$, and $(S_3, S_4)$. Within-cluster pairs like $(S_1, S_2)$ are excluded. The count for each aligned residue pair is weighted by the product of the sequence weights. For all between-cluster pairs here, the weight is $w_i \\times w_4 = (1/3) \\times 1 = 1/3$.\n\nWe enumerate the unordered residue pairs $\\{i,j\\}$ column by column for the between-cluster sequence pairs, and accumulate their weighted counts, denoted $N_{ij}$.\n\n- Alignment pairs from $(S_1, S_4)$: `ACDEFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {C,C}, {D,N}, {E,E}, {F,Y}, {G,G}. Each contributes $1/3$ to its respective count.\n- Alignment pairs from $(S_2, S_4)$: `ACDQFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {C,C}, {D,N}, {Q,E}, {F,Y}, {G,G}. Each contributes $1/3$ to its respective count.\n- Alignment pairs from $(S_3, S_4)$: `ASDEFG` vs `VCNEYG` $\\rightarrow$ {A,V}, {S,C}, {D,N}, {E,E}, {F,Y}, {G,G}. Each contributes $1/3$ to its respective count.\n\nTotal weighted counts for each unordered pair $\\{i,j\\}$:\n- $N_{AV} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{CC} = 1/3 + 1/3 = 2/3$\n- $N_{DN} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{EE} = 1/3 + 1/3 = 2/3$\n- $N_{FY} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{GG} = 1/3 + 1/3 + 1/3 = 1$\n- $N_{EQ} = 1/3$\n- $N_{CS} = 1/3$\n\nAll other pair counts are $0$. The total number of weighted pairs, $N_{tot}$, is the sum of these counts:\n$N_{tot} = 1 + 2/3 + 1 + 2/3 + 1 + 1 + 1/3 + 1/3 = 4 + 6/3 = 4 + 2 = 6$.\nThis matches the total number of contributing pairs ($3$ sequence pairs $\\times 6$ columns) times their weight ($1/3$), i.e., $3 \\times 6 \\times (1/3) = 6$.\n\n**Step 3: Calculate Pair Probabilities ($p^{\\mathrm{unord}}_{ij}$ and $p_{ij}$)**\n\nThe probability of observing an unordered pair $\\{i,j\\}$, $p^{\\mathrm{unord}}_{ij}$, is its weighted count normalized by the total weighted count.\n$p^{\\mathrm{unord}}_{ij} = N_{ij} / N_{tot}$.\nFor the pair of interest, $\\{D,N\\}$:\n$p^{\\mathrm{unord}}_{DN} = N_{DN} / N_{tot} = 1/6$.\n\nNext, we convert these to ordered pair probabilities, $p_{ij}$. For $i \\neq j$, $p_{ij} = p_{ji} = p^{\\mathrm{unord}}_{ij} / 2$. For $i=j$, $p_{ii} = p^{\\mathrm{unord}}_{ii}$.\nSince $D \\neq N$, the probability for the ordered pair $(D,N)$ is:\n$p_{DN} = p^{\\mathrm{unord}}_{DN} / 2 = (1/6) / 2 = 1/12$.\n\n**Step 4: Calculate Background Residue Probabilities ($q_i$)**\n\nThe background probability of a residue $i$, $q_i$, is its overall frequency, derived from the ordered pair probabilities: $q_i = \\sum_{j} p_{ij}$. We need to find $q_D$ and $q_N$.\n\nTo find $q_D$, we sum over all $p_{Dj}$:\n$q_D = \\sum_{j} p_{Dj} = p_{DA} + p_{DC} + \\dots + p_{DN} + \\dots$\nFrom our counts, the only non-zero term is $p_{DN}$. We must be careful, the definition holds symmetry, so $q_D = \\sum_j p_{jD}$ is also true. The standard calculation uses $q_i = ( \\sum_j p_{ij} + \\sum_j p_{ji} )/2$. Let us compute all ordered probabilities first to be thorough.\n- $p_{AV} = p_{VA} = (1/6)/2 = 1/12$\n- $p_{CC} = 1/9$\n- $p_{DN} = p_{ND} = (1/6)/2 = 1/12$\n- $p_{EE} = 1/9$\n- $p_{FY} = p_{YF} = (1/6)/2 = 1/12$\n- $p_{GG} = 1/6$\n- $p_{EQ} = p_{QE} = ((1/3)/6)/2 = 1/36$\n- $p_{CS} = p_{SC} = ((1/3)/6)/2 = 1/36$\n\nNow, we calculate $q_D$ and $q_N$ using $q_i = \\sum_{j} p_{ij}$:\n$q_D = p_{DA} + p_{DC} + p_{DD} + \\dots + p_{DN} + \\dots = p_{DN} = 1/12$. No other residue was observed to align with D.\n$q_N = p_{NA} + p_{NC} + p_{ND} + \\dots = p_{ND} = 1/12$. No other residue was observed to align with N.\n\nSo, $q_D = 1/12$ and $q_N = 1/12$.\n\n**Step 5: Calculate the Log-Odds Score**\n\nThe log-odds score for a substitution of residue $i$ with residue $j$, $S_{ij}$, compares the observed probability of the alignment, $p_{ij}$, to the expected probability, $e_{ij}$, under a model where residues align randomly according to their background frequencies. The expected probability is $e_{ij} = q_i q_j$. The score is given in base-2 logarithm (bits).\n\n$S_{ij} = \\log_2 \\left( \\frac{p_{ij}}{e_{ij}} \\right) = \\log_2 \\left( \\frac{p_{ij}}{q_i q_j} \\right)$.\n\nWe want to find the score for the pair $(D,N)$, $S_{DN}$:\n- $p_{DN} = 1/12$\n- $q_D = 1/12$\n- $q_N = 1/12$\n\nSubstituting these values:\n$S_{DN} = \\log_2 \\left( \\frac{1/12}{(1/12) \\times (1/12)} \\right) = \\log_2 \\left( \\frac{1}{1/12} \\right) = \\log_2(12)$.\n\nThe final score is requested as an exact base-2 logarithm.\n\n**Exclusion of Gaps**\n\nThe problem specifies an \"ungapped conserved block alignment\", and the procedure for constructing BLOSUM matrices intrinsically excludes gaps from the frequency counts. The rationale is based on the fundamental distinction between substitution and insertion/deletion (indel) events. A substitution matrix like BLOSUM is designed to score the likelihood of one amino acid replacing another over evolutionary time. A gap, represented by a '-', is not an amino acid; it signifies an indel event. The evolutionary processes and probabilities governing substitutions are different from those governing indels. Therefore, scoring alignments involves two separate components: a substitution matrix for matching/mismatching residues and a gap penalty function for indels. To build the substitution matrix, one must isolate pure substitution events. This is achieved by using alignment blocks that are, by definition, free of gaps. Any column containing a gap in the source multiple alignment would be ignored for the purpose of tallying residue-residue pair frequencies.", "answer": "$$\\boxed{\\log_{2}(12)}$$", "id": "4591431"}, {"introduction": "An alignment score is meaningless without a statistical framework to assess its significance. This practice delves into the Karlin-Altschul theory, which provides the statistical foundation for local alignment tools like BLAST, by focusing on the key parameter $\\lambda$ [@problem_id:4591501]. You will investigate how a common practical optimization—rounding scores to integers for computational efficiency—impacts this crucial parameter, offering a clear window into the trade-offs between theoretical precision and practical performance.", "problem": "Consider a nucleotide scoring scheme over the alphabet $\\{A, C, G, T\\}$ with uniform background frequencies $q_{A} = q_{C} = q_{G} = q_{T} = \\frac{1}{4}$. The score matrix $S$ assigns $S_{ii} = s_{\\mathrm{m}}$ for matches and $S_{ij} = s_{\\mathrm{x}}$ for mismatches, with $s_{\\mathrm{m}} = 1.64$ and $s_{\\mathrm{x}} = -1.64$. In the theory of local alignments, the parameter $\\lambda$ is defined as the unique positive solution to the moment generating function equation\n$$\\sum_{i,j} q_{i} q_{j} \\exp\\!\\big(\\lambda\\, S_{ij}\\big) = 1.$$\nIntegerization of substitution matrices is a common step when implementing scoring in dynamic programming. Let the integerized matrix $S'$ be obtained by rounding each entry of $S$ to the nearest integer, so that $S'_{ii} = 2$ and $S'_{ij} = -2$.\n\nStarting from fundamental definitions of background frequencies and log-odds scoring, and using the moment generating function equation above, determine the unique positive $\\lambda$ that solves the equation before integerization (using $S$) and after integerization (using $S'$). Then compute the absolute relative change\n$$\\Delta = \\frac{|\\lambda_{\\mathrm{int}} - \\lambda_{\\mathrm{real}}|}{\\lambda_{\\mathrm{real}}},$$\nwhere $\\lambda_{\\mathrm{real}}$ is the solution using $S$ and $\\lambda_{\\mathrm{int}}$ is the solution using $S'$. Express $\\Delta$ as a pure number (dimensionless). Round your final answer to four significant figures.", "solution": "The problem is evaluated as scientifically grounded, well-posed, and objective. It is based on the established statistical framework of local sequence alignment (Karlin-Altschul statistics), provides all necessary data and definitions, and is free of ambiguity or contradiction. The condition for the existence of a unique positive $\\lambda$, namely that the expected score is negative, is met for both the real and integerized scoring matrices. We may therefore proceed with the solution.\n\nThe problem requires us to find the parameter $\\lambda$ which is the unique positive solution to the equation:\n$$ \\sum_{i,j} q_{i} q_{j} \\exp(\\lambda S_{ij}) = 1 $$\nThe alphabet is $\\{A, C, G, T\\}$, so there are $4 \\times 4 = 16$ pairs of $(i,j)$. The given background frequencies are uniform: $q_{A} = q_{C} = q_{G} = q_{T} = \\frac{1}{4}$. Thus, for any pair $(i,j)$, the product of background frequencies is $q_{i} q_{j} = (\\frac{1}{4})(\\frac{1}{4}) = \\frac{1}{16}$.\n\nThe summation can be partitioned into two parts: one for matches where $i=j$ and one for mismatches where $i \\neq j$. There are $4$ possible matches $((A,A), (C,C), (G,G), (T,T))$ and $16 - 4 = 12$ possible mismatches. The scoring matrix $S$ has a constant score for all matches, $S_{ii} = s_{\\mathrm{m}}$, and a constant score for all mismatches, $S_{ij} = s_{\\mathrm{x}}$ for $i \\neq j$.\n\nThe equation can thus be written as:\n$$ 4 \\cdot \\left(q_i q_j\\right) \\exp(\\lambda s_{\\mathrm{m}}) + 12 \\cdot \\left(q_i q_j\\right) \\exp(\\lambda s_{\\mathrm{x}}) = 1 $$\nSubstituting $q_i q_j = \\frac{1}{16}$:\n$$ 4 \\cdot \\frac{1}{16} \\exp(\\lambda s_{\\mathrm{m}}) + 12 \\cdot \\frac{1}{16} \\exp(\\lambda s_{\\mathrm{x}}) = 1 $$\n$$ \\frac{1}{4} \\exp(\\lambda s_{\\mathrm{m}}) + \\frac{3}{4} \\exp(\\lambda s_{\\mathrm{x}}) = 1 $$\n\nFirst, we calculate $\\lambda_{\\mathrm{real}}$ using the real-valued score matrix $S$, where $s_{\\mathrm{m}} = 1.64$ and $s_{\\mathrm{x}} = -1.64$.\nSubstituting these values into the equation:\n$$ \\frac{1}{4} \\exp(1.64 \\lambda_{\\mathrm{real}}) + \\frac{3}{4} \\exp(-1.64 \\lambda_{\\mathrm{real}}) = 1 $$\nTo solve this transcendental equation, let $y = \\exp(1.64 \\lambda_{\\mathrm{real}})$. The equation becomes:\n$$ \\frac{1}{4} y + \\frac{3}{4} y^{-1} = 1 $$\nMultiplying the entire equation by $4y$ to clear the denominator and the negative exponent gives:\n$$ y^2 + 3 = 4y $$\nRearranging into a standard quadratic form:\n$$ y^2 - 4y + 3 = 0 $$\nThis quadratic equation can be factored as:\n$$ (y - 1)(y - 3) = 0 $$\nThe solutions for $y$ are $y = 1$ and $y = 3$. We substitute back $y = \\exp(1.64 \\lambda_{\\mathrm{real}})$.\nCase 1: $y = 1$.\n$$ \\exp(1.64 \\lambda_{\\mathrm{real}}) = 1 $$\n$$ 1.64 \\lambda_{\\mathrm{real}} = \\ln(1) = 0 $$\n$$ \\lambda_{\\mathrm{real}} = 0 $$\nThis is the trivial solution. The theory of Karlin-Altschul statistics guarantees a unique positive solution for $\\lambda$ when the expected score is negative, so we seek the non-zero solution.\n\nCase 2: $y = 3$.\n$$ \\exp(1.64 \\lambda_{\\mathrm{real}}) = 3 $$\n$$ 1.64 \\lambda_{\\mathrm{real}} = \\ln(3) $$\n$$ \\lambda_{\\mathrm{real}} = \\frac{\\ln(3)}{1.64} $$\nThis is the required unique positive solution.\n\nNext, we calculate $\\lambda_{\\mathrm{int}}$ using the integerized score matrix $S'$, where $s'_{\\mathrm{m}} = 2$ and $s'_{\\mathrm{x}} = -2$. The procedure is identical. The governing equation is:\n$$ \\frac{1}{4} \\exp(\\lambda s'_{\\mathrm{m}}) + \\frac{3}{4} \\exp(\\lambda s'_{\\mathrm{x}}) = 1 $$\n$$ \\frac{1}{4} \\exp(2 \\lambda_{\\mathrm{int}}) + \\frac{3}{4} \\exp(-2 \\lambda_{\\mathrm{int}}) = 1 $$\nLet $z = \\exp(2 \\lambda_{\\mathrm{int}})$. The equation becomes:\n$$ \\frac{1}{4} z + \\frac{3}{4} z^{-1} = 1 $$\n$$ z^2 - 4z + 3 = 0 $$\nThis is the same quadratic equation as before, with solutions $z=1$ and $z=3$. Again, we discard the solution that leads to $\\lambda_{\\mathrm{int}} = 0$. The unique positive solution comes from $z=3$:\n$$ \\exp(2 \\lambda_{\\mathrm{int}}) = 3 $$\n$$ 2 \\lambda_{\\mathrm{int}} = \\ln(3) $$\n$$ \\lambda_{\\mathrm{int}} = \\frac{\\ln(3)}{2} $$\n\nFinally, we compute the absolute relative change $\\Delta$:\n$$ \\Delta = \\frac{|\\lambda_{\\mathrm{int}} - \\lambda_{\\mathrm{real}}|}{\\lambda_{\\mathrm{real}}} $$\nSubstituting the expressions we found for $\\lambda_{\\mathrm{real}}$ and $\\lambda_{\\mathrm{int}}$:\n$$ \\Delta = \\frac{\\left|\\frac{\\ln(3)}{2} - \\frac{\\ln(3)}{1.64}\\right|}{\\frac{\\ln(3)}{1.64}} $$\nSince $\\ln(3)  0$, we can factor it out from the numerator and cancel it with the denominator:\n$$ \\Delta = \\frac{\\ln(3) \\left|\\frac{1}{2} - \\frac{1}{1.64}\\right|}{\\ln(3) \\left(\\frac{1}{1.64}\\right)} = 1.64 \\cdot \\left|\\frac{1}{2} - \\frac{1}{1.64}\\right| $$\nAs $1.64  2$, we have $\\frac{1}{2}  \\frac{1}{1.64}$. Therefore, the term inside the absolute value is positive, so we can remove the absolute value bars after reordering:\n$$ \\Delta = 1.64 \\cdot \\left(\\frac{1}{1.64} - \\frac{1}{2}\\right) $$\nDistributing the $1.64$:\n$$ \\Delta = 1.64 \\cdot \\frac{1}{1.64} - 1.64 \\cdot \\frac{1}{2} = 1 - \\frac{1.64}{2} = 1 - 0.82 $$\n$$ \\Delta = 0.18 $$\nThe problem asks for the answer to be rounded to four significant figures.\n$$ \\Delta = 0.1800 $$", "answer": "$$\n\\boxed{0.1800}\n$$", "id": "4591501"}, {"introduction": "Ultimately, the utility of a substitution matrix and gap penalty model is determined by its performance on real-world tasks. This computational exercise challenges you to build and evaluate an alignment-based classifier, a common task in bioinformatics methods development [@problem_id:4591533]. By implementing a local alignment algorithm and using the Receiver Operating Characteristic (ROC) Area Under the Curve (AUC) to assess different scoring systems, you will learn how to quantitatively measure and compare their ability to distinguish true homologs from unrelated sequences.", "problem": "You are given two labeled datasets of pairwise sequences: one protein dataset and one deoxyribonucleic acid (DNA) dataset. Each pair is labeled as homologous (positive) or decoy (negative). You must implement a classifier based on local pairwise alignment with an affine gap penalty model and log-odds substitution matrices, and then evaluate the Receiver Operating Characteristic Area Under the Curve (ROC AUC). You will compute ROC AUC for a grid of gap penalty parameters for multiple substitution matrices, and then identify robust regions of parameter space where performance remains near-optimal.\n\nUse the following fundamental base. Local alignment with affine gaps maximizes the alignment score over all possible local subsequences based on a substitution score function and a gap penalty schedule. A log-odds substitution matrix encodes the score $S(x,y)$ for aligning residue $x$ with residue $y$ as $S(x,y) = \\log \\frac{p(x,y)}{q(x)q(y)}$, where $p(x,y)$ is the probability of observing $x$ aligned to $y$ in homologs and $q(x)$ and $q(y)$ are background frequencies. An affine gap penalty model assigns a cost $g(k) = g_o + k \\cdot g_e$ to a gap of length $k$, with gap open penalty $g_o$ and gap extension penalty $g_e$. The local alignment score, under an affine model, is the optimal value obtained by dynamic programming. For classification, define the score of a pair as its optimal local alignment score under a specified substitution matrix and gap penalties. The Receiver Operating Characteristic (ROC) curve compares true positive and false positive rates across decision thresholds, and the Area Under the Curve (AUC) is the integral of the ROC curve, equivalently the probability that a randomly chosen positive has a higher score than a randomly chosen negative.\n\nYour program must:\n\n- Implement local alignment with affine gap penalties to compute an alignment score for each pair:\n    - Given two sequences $a_1 a_2 \\dots a_m$ and $b_1 b_2 \\dots b_n$, a substitution function $S(\\cdot,\\cdot)$, and gap penalties $g_o$ and $g_e$, compute the optimal local alignment score over all substrings.\n- For each specified substitution matrix and for a grid of gap penalty parameters $(g_o, g_e)$, compute ROC AUC across the labeled pairs using the alignment scores as classifier scores. Use the rank-based formulation of ROC AUC: for $n_+$ positive scores and $n_-$ negative scores, let $R_+$ be the sum of ranks of the positive scores in the combined list (average ranks for ties). Then the AUC is\n$$ \\text{AUC} = \\frac{R_+ - \\frac{n_+(n_+ + 1)}{2}}{n_+ n_-}. $$\n- Define the robust parameter region for a given substitution matrix as the set of $(g_o, g_e)$ grid points where the AUC is within $\\Delta$ of the maximum AUC achieved by that substitution matrix on the dataset. Use $\\Delta = 0.01$.\n- Report, for each substitution matrix, the maximum AUC over the grid and the count of grid points in its robust region.\n\nDatasets and test suite:\n\n- Protein dataset (amino acid alphabet). Positives (homologous pairs):\n    - (\"MKTLLILALV\",\"MKTLVILALV\")\n    - (\"GAVLKVLTT\",\"GAVLKVLAT\")\n    - (\"HPNFGWQVL\",\"HPDFGWQVL\")\n    - (\"QQHLLSKNF\",\"QQHLLSKHF\")\n    - (\"VVKDNNTLE\",\"VVKDNNTLE\")\n    - (\"NSTEQQLIM\",\"NSTEQQLIM\")\n    - (\"RGLPYTNVV\",\"RGLPYANVV\")\n    - (\"KDELRQKLE\",\"KDELRQKLE\")\n  Negatives (decoys):\n    - (\"MKTLLILALV\",\"GGGGGGGGGG\")\n    - (\"GAVLKVLTT\",\"LLLLLLLLLL\")\n    - (\"HPNFGWQVL\",\"AAAAAAAAA\")\n    - (\"QQHLLSKNF\",\"PPPPPPPPP\")\n    - (\"VVKDNNTLE\",\"SSSSSSSSS\")\n    - (\"NSTEQQLIM\",\"TTTTTTTTT\")\n    - (\"RGLPYTNVV\",\"NNNNNNNNN\")\n    - (\"KDELRQKLE\",\"YYYYYYYYY\")\n- DNA dataset (nucleotide alphabet $\\{A,C,G,T\\}$). Positives:\n    - (\"ATGCGTAC\",\"ATGCGTAC\")\n    - (\"GATTACA\",\"GATTTCA\")\n    - (\"CCGGAATT\",\"CCGGAACT\")\n    - (\"TTGCCAAA\",\"TTGCCAAG\")\n    - (\"AACCGGTT\",\"AACCGGTT\")\n    - (\"GGATCCGA\",\"GGATCCGA\")\n  Negatives:\n    - (\"ATGCGTAC\",\"TGCATGCA\")\n    - (\"GATTACA\",\"CTAGGAT\")\n    - (\"CCGGAATT\",\"TTCCGGAA\")\n    - (\"TTGCCAAA\",\"GGGTTCCC\")\n    - (\"AACCGGTT\",\"TTAACCGG\")\n    - (\"GGATCCGA\",\"AACCTTGG\")\n\nSubstitution matrices to evaluate:\n\n- Amino acids: BLOSUM62 and PAM250. Treat these as log-odds score tables $S(x,y)$ for $x,y$ in the standard $20$ amino acids.\n- DNA matrices:\n    - DNA\\_simple: $S(x,y)=1$ for match, $S(x,y)=-1$ for mismatch.\n    - DNA\\_ttv (transition/transversion-weighted): $S(x,y)=2$ for match; for transitions ($A \\leftrightarrow G$ or $C \\leftrightarrow T$), $S(x,y)=-1$; for transversions, $S(x,y)=-2$.\n\nGap penalty grid:\n\n- Use $g_o \\in \\{8,10,12\\}$ and $g_e \\in \\{1,2,3\\}$, forming a grid of $9$ parameter combinations for each substitution matrix.\n\nRobustness criterion:\n\n- For each substitution matrix and dataset, let $A_{\\max}$ be the maximum AUC over the grid, and take $\\Delta = 0.01$. A grid point is robust if its AUC $A$ satisfies $A \\ge A_{\\max} - \\Delta$.\n\nRequired final output:\n\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain, in order:\n    - For the protein dataset: maximum AUC for BLOSUM62 rounded to $3$ decimal places, robust count for BLOSUM62 as an integer, maximum AUC for PAM250 rounded to $3$ decimal places, robust count for PAM250 as an integer.\n    - For the DNA dataset: maximum AUC for DNA\\_simple rounded to $3$ decimal places, robust count for DNA\\_simple as an integer, maximum AUC for DNA\\_ttv rounded to $3$ decimal places, robust count for DNA\\_ttv as an integer.\n- The final printed line must have no extra text and follow the exact format specification.\n\nDesign for coverage:\n\n- The protein dataset evaluates amino acid substitution matrices; the DNA dataset evaluates nucleotide matrices.\n- The gap penalty grid tests boundary conditions at $g_o \\in \\{8,10,12\\}$ and $g_e \\in \\{1,2,3\\}$, covering both tighter and looser gap models.\n- The robust region identification tests sensitivity to parameter choices via the $\\Delta = 0.01$ tolerance.", "solution": "The problem requires the implementation and evaluation of a bioinformatics classifier. The classifier's score for a pair of sequences (protein or DNA) is determined by the optimal local alignment score, calculated using an affine gap penalty model. This score is then used to distinguish between homologous (positive) and non-homologous decoy (negative) sequence pairs. The performance of this classifier is quantified by the Receiver Operating Characteristic Area Under the Curve ($\\text{AUC}$). This evaluation is performed for several standard substitution matrices across a grid of gap penalty parameters. Finally, for each matrix, we identify a robust parameter region where the performance is near-optimal.\n\nThe solution is structured into three main components:\n$1$. The core algorithm for computing the local alignment score with affine gap penalties.\n$2$. The procedure for calculating the $\\text{AUC}$ from the alignment scores of positive and negative pairs.\n$3$. The systematic evaluation methodology, including the parameter grid search and the identification of the robust region.\n\n### $1$. Local Alignment with Affine Gap Penalties\n\nThe problem specifies local alignment, which seeks the highest-scoring alignment between any possible substrings of the two input sequences, say $a = a_1a_2\\dots a_m$ and $b = b_1b_2\\dots b_n$. The scoring is based on a substitution matrix $S(x,y)$ and an affine gap penalty model. A gap of length $k$ incurs a penalty $g(k) = g_o + k \\cdot g_e$, where $g_o$ is the gap opening penalty and $g_e$ is the gap extension penalty. Since scores are maximized, these penalties are subtracted.\n\nThis problem is solved using a dynamic programming approach, specifically the Smith-Waterman-Gotoh algorithm. Three matrices, $M(i,j)$, $I_x(i,j)$, and $I_y(i,j)$, are used to store the scores of optimal alignments of prefixes $a_1\\dots a_i$ and $b_1\\dots b_j$.\n\n-   $M(i,j)$: The score of an alignment ending with $a_i$ matched to $b_j$.\n-   $I_x(i,j)$: The score of an alignment ending with $a_i$ aligned to a gap ('-').\n-   $I_y(i,j)$: The score of an alignment ending with $b_j$ aligned to a gap ('-').\n\nThe recurrence relations are defined as follows for $i$ from $1$ to $m$ and $j$ from $1$ to $n$:\n\n$1$. The score for an alignment ending in a match or mismatch ($a_i$ vs $b_j$) is given by:\n$$ M(i,j) = S(a_i, b_j) + \\max \\begin{cases} M(i-1, j-1)  \\text{(from a previous match/mismatch)} \\\\ I_x(i-1, j-1)  \\text{(from a gap in sequence } b \\text{)} \\\\ I_y(i-1, j-1)  \\text{(from a gap in sequence } a \\text{)} \\\\ 0  \\text{(start of a new local alignment)} \\end{cases} $$\nThe inclusion of the $0$ term is the \"local\" aspect of the Smith-Waterman algorithm, allowing a new alignment to start at any position $(i,j)$ if all alignments ending at prior positions have negative scores.\n\n$2$. The score for an alignment ending with a gap in sequence $b$ (a deletion with respect to sequence $a$) is:\n$$ I_x(i,j) = \\max \\begin{cases} M(i-1, j) - (g_o + g_e)  \\text{(opening a new gap)} \\\\ I_x(i-1, j) - g_e  \\text{(extending an existing gap)} \\end{cases} $$\n\n$3$. The score for an alignment ending with a gap in sequence $a$ (an insertion with respect to sequence $a$) is:\n$$ I_y(i,j) = \\max \\begin{cases} M(i, j-1) - (g_o + g_e)  \\text{(opening a new gap)} \\\\ I_y(i, j-1) - g_e  \\text{(extending an existing gap)} \\end{cases} $$\n\nThe boundary conditions are $M(0,0)=0$, and all other values in the first row and column of $M$ are $0$, while for $I_x$ and $I_y$ they are initialized to $-\\infty$ to forbid gaps at the start of an alignment. The optimal local alignment score is the maximum value found in the matrix $M$ over all $i,j$. If all possible alignment scores are negative, the optimal score is $0$, which is naturally handled by the recurrence for $M(i,j)$.\n\n### $2$. Classifier Evaluation using ROC AUC\n\nThe alignment score serves as the discriminant value for our classifier. A pair of sequences with a high score is predicted to be homologous, while a pair with a low score is predicted to be a decoy. To evaluate the classifier's ability to separate the two classes (homologs vs. decoys), we use the Receiver Operating Characteristic Area Under the Curve ($\\text{AUC}$).\n\nThe $\\text{AUC}$ represents the probability that a randomly chosen positive example (homologous pair) is ranked higher than a randomly chosen negative example (decoy pair) based on the alignment score. The problem specifies a rank-based formula for its calculation:\n$$ \\text{AUC} = \\frac{R_+ - \\frac{n_+(n_+ + 1)}{2}}{n_+ n_-} $$\nwhere $n_+$ is the number of positive samples, $n_-$ is the number of negative samples, and $R_+$ is the sum of the ranks of the positive scores in a combined, sorted list of all scores. Ties in scores are handled by assigning the average rank to all tied items. An $\\text{AUC}$ of $1.0$ indicates perfect separation, while an $\\text{AUC}$ of $0.5$ suggests performance no better than random chance.\n\n### $3$. Parameter Search and Robustness Analysis\n\nThe performance of the alignment-based classifier is sensitive to the choice of substitution matrix and gap penalties. The problem requires a grid search over a specified set of gap open ($g_o \\in \\{8,10,12\\}$) and gap extension ($g_e \\in \\{1,2,3\\}$) penalties. For each combination of a substitution matrix and a $(g_o, g_e)$ pair, we compute the local alignment scores for all sequence pairs in the dataset and then calculate the resulting $\\text{AUC}$.\n\nAfter computing the $\\text{AUC}$ for all $9$ points in the parameter grid for a given substitution matrix, we identify the maximum $\\text{AUC}$, denoted $A_{\\max}$. The \"robust parameter region\" is then defined as the set of $(g_o, g_e)$ grid points for which the corresponding $\\text{AUC}$ value $A$ satisfies the condition $A \\ge A_{\\max} - \\Delta$, with $\\Delta = 0.01$. The size of this region (the count of such grid points) provides insight into how sensitive the classifier's performance is to small changes in gap penalty parameters. A larger count implies greater robustness.\n\nThe final output aggregates these findings: for each substitution matrix (BLOSUM62, PAM250 for proteins; DNA_simple, DNA_ttv for DNA), we report the maximum $\\text{AUC}$ achieved and the count of points in the robust region. This process is applied independently to the protein and DNA datasets.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import rankdata\n\ndef solve():\n    # --- Data Definition ---\n\n    # Amino acid substitution matrices (BLOSUM62 and PAM250)\n    BLOSUM62_TEXT = \"\"\"\n       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V\n    A  4 -1 -2 -2  0 -1 -1  0 -2 -1 -1 -1 -1 -2 -1  1  0 -3 -2  0\n    R -1  5  0 -2 -3  1  0 -2  0 -3 -2  2 -1 -3 -2 -1 -1 -3 -2 -3\n    N -2  0  6  1 -3  0  0  0  1 -3 -3  0 -2 -3 -2  1  0 -4 -2 -3\n    D -2 -2  1  6 -3  0  2 -1 -1 -3 -4 -1 -3 -3 -1  0 -1 -4 -3 -3\n    C  0 -3 -3 -3  9 -3 -4 -3 -3 -1 -1 -3 -1 -2 -3 -1 -1 -2 -2 -1\n    Q -1  1  0  0 -3  5  2 -2  0 -3 -2  1  0 -3 -1  0 -1 -2 -1 -2\n    E -1  0  0  2 -4  2  5 -2  0 -3 -3  1 -2 -3 -1  0 -1 -3 -2 -2\n    G  0 -2  0 -1 -3 -2 -2  6 -2 -4 -4 -2 -3 -3 -2  0 -2 -2 -3 -3\n    H -2  0  1 -1 -3  0  0 -2  8 -3 -3 -1 -2 -1 -2 -1 -2 -2  2 -3\n    I -1 -3 -3 -3 -1 -3 -3 -4 -3  4  2 -3  1  0 -3 -2 -1 -3 -1  3\n    L -1 -2 -3 -4 -1 -2 -3 -4 -3  2  4 -2  2  0 -3 -2 -1 -2 -1  1\n    K -1  2  0 -1 -3  1  1 -2 -1 -3 -2  5 -1 -3 -1  0 -1 -3 -2 -2\n    M -1 -1 -2 -3 -1  0 -2 -3 -2  1  2 -1  5  0 -2 -1 -1 -1 -1  1\n    F -2 -3 -3 -3 -2 -3 -3 -3 -1  0  0 -3  0  6 -4 -2 -2  1  3 -1\n    P -1 -2 -2 -1 -3 -1 -1 -2 -2 -3 -3 -1 -2 -4  7 -1 -1 -4 -3 -2\n    S  1 -1  1  0 -1  0  0  0 -1 -2 -2  0 -1 -2 -1  4  1 -3 -2 -2\n    T  0 -1  0 -1 -1 -1 -1 -2 -2 -1 -1 -1 -1 -2 -1  1  5 -2 -2  0\n    W -3 -3 -4 -4 -2 -2 -3 -2 -2 -3 -2 -3 -1  1 -4 -3 -2 11  2 -3\n    Y -2 -2 -2 -3 -2 -1 -2 -3  2 -1 -1 -2 -1  3 -3 -2 -2  2  7 -1\n    V  0 -3 -3 -3 -1 -2 -2 -3 -3  3  1 -2  1 -1 -2 -2  0 -3 -1  4\n    \"\"\"\n\n    PAM250_TEXT = \"\"\"\n       A  R  N  D  C  Q  E  G  H  I  L  K  M  F  P  S  T  W  Y  V\n    A  2 -2  0  0 -2  0  0  1 -1 -1 -2 -1 -1 -3  1  1  1 -6 -3  0\n    R -2  6  0 -1 -4  1 -1 -3  2 -2 -3  3  0 -4  0  0 -1  2 -4 -2\n    N  0  0  2  2 -4  1  1  0  2 -2 -3  1 -2 -3  0  1  0 -4 -2 -2\n    D  0 -1  2  4 -5  2  3  1  1 -2 -4  0 -3 -6 -1  0  0 -7 -4 -2\n    C -2 -4 -4 -5 12 -5 -5 -3 -3 -2 -6 -5 -5 -4 -3  0 -2 -8  0 -2\n    Q  0  1  1  2 -5  4  2 -1  3 -2 -2  1 -1 -5  0 -1 -1 -5 -4 -2\n    E  0 -1  1  3 -5  2  4  0  1 -2 -3  0 -2 -5 -1  0  0 -7 -4 -2\n    G  1 -3  0  1 -3 -1  0  5 -2 -3 -4 -2 -3 -5  0  1  0 -7 -5 -1\n    H -1  2  2  1 -3  3  1 -2  6 -2 -2  0 -2 -2  0 -1 -1 -3  0 -2\n    I -1 -2 -2 -2 -2 -2 -2 -3 -2  5  2 -2  2  1 -2 -1  0 -5 -1  4\n    L -2 -3 -3 -4 -6 -2 -3 -4 -2  2  6 -3  4  2 -3 -3 -2 -2 -1  2\n    K -1  3  1  0 -5  1  0 -2  0 -2 -3  5  0 -5 -1  0  0 -3 -4 -2\n    M -1  0 -2 -3 -5 -1 -2 -3 -2  2  4  0  6  0 -2 -2 -1 -4 -2  2\n    F -3 -4 -3 -6 -4 -5 -5 -5 -2  1  2 -5  0  9 -5 -3 -3  0  7 -1\n    P  1  0  0 -1 -3  0 -1  0  0 -2 -3 -1 -2 -5  6  1  0 -6 -5 -1\n    S  1  0  1  0  0 -1  0  1 -1 -1 -3  0 -2 -3  1  2  1 -2 -3  0\n    T  1 -1  0  0 -2 -1  0  0 -1  0 -2  0 -1 -3  0  1  3 -5 -3  0\n    W -6  2 -4 -7 -8 -5 -7 -7 -3 -5 -2 -3 -4  0 -6 -2 -5 17  0 -6\n    Y -3 -4 -2 -4  0 -4 -4 -5  0 -1 -1 -4 -2  7 -5 -3 -3  0 10 -2\n    V  0 -2 -2 -2 -2 -2 -2 -1 -2  4  2 -2  2 -1 -1  0  0 -6 -2  4\n    \"\"\"\n\n    def parse_matrix(text):\n        lines = text.strip().split('\\n')\n        header = lines[0].split()\n        matrix = {aa: {} for aa in header}\n        for line in lines[1:]:\n            parts = line.split()\n            row_aa = parts[0]\n            for col_aa, score in zip(header, parts[1:]):\n                matrix[row_aa][col_aa] = int(score)\n        return matrix\n\n    protein_matrices = {\n        \"BLOSUM62\": parse_matrix(BLOSUM62_TEXT),\n        \"PAM250\": parse_matrix(PAM250_TEXT)\n    }\n\n    # DNA substitution matrices (defined logically)\n    def dna_simple_matrix(c1, c2):\n        return 1 if c1 == c2 else -1\n\n    def dna_ttv_matrix(c1, c2):\n        if c1 == c2:\n            return 2\n        transitions = {('A', 'G'), ('G', 'A'), ('C', 'T'), ('T', 'C')}\n        if (c1, c2) in transitions:\n            return -1\n        else: # Transversions\n            return -2\n\n    # Datasets\n    protein_positives = [(\"MKTLLILALV\",\"MKTLVILALV\"), (\"GAVLKVLTT\",\"GAVLKVLAT\"), (\"HPNFGWQVL\",\"HPDFGWQVL\"), (\"QQHLLSKNF\",\"QQHLLSKHF\"), (\"VVKDNNTLE\",\"VVKDNNTLE\"), (\"NSTEQQLIM\",\"NSTEQQLIM\"), (\"RGLPYTNVV\",\"RGLPYANVV\"), (\"KDELRQKLE\",\"KDELRQKLE\")]\n    protein_negatives = [(\"MKTLLILALV\",\"GGGGGGGGGG\"), (\"GAVLKVLTT\",\"LLLLLLLLLL\"), (\"HPNFGWQVL\",\"AAAAAAAAA\"), (\"QQHLLSKNF\",\"PPPPPPPPP\"), (\"VVKDNNTLE\",\"SSSSSSSSS\"), (\"NSTEQQLIM\",\"TTTTTTTTT\"), (\"RGLPYTNVV\",\"NNNNNNNNN\"), (\"KDELRQKLE\",\"YYYYYYYYY\")]\n    \n    dna_positives = [(\"ATGCGTAC\",\"ATGCGTAC\"), (\"GATTACA\",\"GATTTCA\"), (\"CCGGAATT\",\"CCGGAACT\"), (\"TTGCCAAA\",\"TTGCCAAG\"), (\"AACCGGTT\",\"AACCGGTT\"), (\"GGATCCGA\",\"GGATCCGA\")]\n    dna_negatives = [(\"ATGCGTAC\",\"TGCATGCA\"), (\"GATTACA\",\"CTAGGAT\"), (\"CCGGAATT\",\"TTCCGGAA\"), (\"TTGCCAAA\",\"GGGTTCCC\"), (\"AACCGGTT\",\"TTAACCGG\"), (\"GGATCCGA\",\"AACCTTGG\")]\n\n    gap_penalty_grid = [(g_o, g_e) for g_o in [8, 10, 12] for g_e in [1, 2, 3]]\n    robustness_delta = 0.01\n\n    # --- Core Algorithms ---\n\n    def local_align_affine(seq1, seq2, sub_matrix_func, g_o, g_e):\n        m, n = len(seq1), len(seq2)\n        \n        M = np.zeros((m + 1, n + 1), dtype=np.float64)\n        Ix = np.full((m + 1, n + 1), -np.inf, dtype=np.float64)\n        Iy = np.full((m + 1, n + 1), -np.inf, dtype=np.float64)\n\n        max_score = 0.0\n        gap_open_cost = g_o + g_e\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                match_score = sub_matrix_func(seq1[i-1], seq2[j-1])\n                \n                prev_max = max(M[i-1, j-1], Ix[i-1, j-1], Iy[i-1, j-1], 0)\n                M[i,j] = match_score + prev_max\n                \n                Ix[i,j] = max(M[i-1, j] - gap_open_cost, Ix[i-1, j] - g_e)\n                Iy[i,j] = max(M[i, j-1] - gap_open_cost, Iy[i, j-1] - g_e)\n\n                current_max = max(M[i,j], Ix[i,j], Iy[i,j])\n                if current_max > max_score:\n                    max_score = current_max\n        \n        return max_score\n\n    def calculate_auc(pos_scores, neg_scores):\n        n_pos = len(pos_scores)\n        n_neg = len(neg_scores)\n        if n_pos == 0 or n_neg == 0:\n            return 0.5\n\n        all_scores = np.concatenate((pos_scores, neg_scores))\n        ranks = rankdata(all_scores, method='average')\n        \n        r_plus = np.sum(ranks[:n_pos])\n        \n        auc = (r_plus - n_pos * (n_pos + 1) / 2) / (n_pos * n_neg)\n        return auc\n\n    # --- Main Evaluation Loop ---\n\n    final_results = []\n    \n    # Process Protein Dataset\n    for matrix_name in [\"BLOSUM62\", \"PAM250\"]:\n        matrix = protein_matrices[matrix_name]\n        sub_func = lambda c1, c2: matrix[c1][c2]\n        auc_results = []\n        for g_o, g_e in gap_penalty_grid:\n            pos_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in protein_positives]\n            neg_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in protein_negatives]\n            auc = calculate_auc(pos_scores, neg_scores)\n            auc_results.append(auc)\n        \n        max_auc = max(auc_results)\n        robust_count = sum(1 for auc in auc_results if auc >= max_auc - robustness_delta)\n        \n        final_results.append(round(max_auc, 3))\n        final_results.append(robust_count)\n\n    # Process DNA Dataset\n    dna_matrix_defs = [(\"DNA_simple\", dna_simple_matrix), (\"DNA_ttv\", dna_ttv_matrix)]\n    for matrix_name, sub_func in dna_matrix_defs:\n        auc_results = []\n        for g_o, g_e in gap_penalty_grid:\n            pos_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in dna_positives]\n            neg_scores = [local_align_affine(s1, s2, sub_func, g_o, g_e) for s1, s2 in dna_negatives]\n            auc = calculate_auc(pos_scores, neg_scores)\n            auc_results.append(auc)\n\n        max_auc = max(auc_results) if auc_results else 0\n        robust_count = sum(1 for auc in auc_results if auc >= max_auc - robustness_delta)\n\n        final_results.append(round(max_auc, 3))\n        final_results.append(robust_count)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "4591533"}]}