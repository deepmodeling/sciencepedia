{"hands_on_practices": [{"introduction": "The presence of non-coding introns within eukaryotic genes is a fundamental distinction from the compact, continuous coding sequences of prokaryotes. This exercise provides a concrete, quantitative look at the consequences of this structural difference by tasking you with calculating the sizes of RNA transcripts before and after the crucial process of splicing [@problem_id:2764248]. By comparing these to an equivalent prokaryotic gene, you will solidify your understanding of how genetic information is processed differently in these two domains of life.", "problem": "A synthetic biologist is analyzing a eukaryotic gene to design an equivalent prokaryotic expression construct. The eukaryotic gene occupies a total genomic span of $4\\,\\text{kb}$ and contains $3$ exons of lengths $150\\,\\text{bp}$, $1200\\,\\text{bp}$, and $300\\,\\text{bp}$, separated by $2$ introns of lengths $900\\,\\text{bp}$ and $1450\\,\\text{bp}$. Assume the following: (i) transcription initiates upstream of the first exon and terminates downstream of the last exon such that the primary transcript (precursor messenger ribonucleic acid, pre-mRNA) contains all exons and introns given; (ii) messenger ribonucleic acid (mRNA) maturation in the eukaryote removes introns completely by spliceosomal splicing with no intron retention; (iii) ignore $5^{\\prime}$ capping, $3^{\\prime}$ polyadenylation, and untranslated region (UTR) contributions beyond the given exon lengths; and (iv) in the prokaryotic design, the same coding region is encoded as a single continuous unit with no introns, and transcription yields an mRNA that is colinear with that coding region, with no additional untranslated leaders or trailers.\n\nUsing only foundational principles of the Central Dogma (deoxyribonucleic acid to ribonucleic acid to protein), the definition of exons and introns, and the well-established absence of spliceosomal introns in canonical prokaryotic genes, derive expressions for the lengths of the eukaryotic pre-mRNA, the eukaryotic mature mRNA, and the corresponding prokaryotic mRNA in terms of the exon and intron lengths. Then evaluate these expressions for the provided exon and intron sizes.\n\nProvide your final numerical answers as exact integers in nucleotides (nt). Report the three values in the order: eukaryotic pre-mRNA length, eukaryotic mature mRNA length, prokaryotic mRNA length. Express the final answer as a single row matrix. No rounding is required. Do not include units in the final boxed answer; elsewhere, express lengths in nt.", "solution": "The problem as stated is valid. It is scientifically grounded in the fundamental principles of molecular biology, specifically the Central Dogma and the structural distinctions between eukaryotic and prokaryotic genes. The givens are self-contained, consistent, and sufficient for deriving a unique and meaningful solution. We shall proceed with the derivation.\n\nThe core principle being tested is the process of gene expression. In eukaryotes, the transcription of a gene from its deoxyribonucleic acid (DNA) template results in a precursor messenger ribonucleic acid (pre-mRNA). This pre-mRNA molecule is a direct transcript of the gene's sequence, which includes both coding regions, known as exons, and non-coding intervening sequences, known as introns. Through a process called splicing, introns are excised and exons are joined together to form a mature messenger ribonucleic acid (mRNA). In contrast, canonical prokaryotic genes are not interrupted by spliceosomal introns, and the transcribed mRNA is colinear with the coding DNA sequence. The problem requires us to calculate the lengths of the intermediate and final RNA products based on these principles.\n\nLet $N_E$ be the number of exons and $N_I$ be the number of introns. Let $L_{E_i}$ be the length of the $i$-th exon and $L_{I_j}$ be the length of the $j$-th intron, for $i \\in \\{1, \\dots, N_E\\}$ and $j \\in \\{1, \\dots, N_I\\}$. The lengths are provided in base pairs (bp), which for the purpose of single-stranded RNA length correspond directly to nucleotides (nt).\n\nThe givens are:\n$N_E = 3$\n$L_{E_1} = 150\\,\\text{nt}$\n$L_{E_2} = 1200\\,\\text{nt}$\n$L_{E_3} = 300\\,\\text{nt}$\n$N_I = 2$\n$L_{I_1} = 900\\,\\text{nt}$\n$L_{I_2} = 1450\\,\\text{nt}$\n\nFirst, we derive the general expression for the length of the eukaryotic pre-mRNA, denoted $L_{\\text{pre-mRNA}}$. According to assumption (i), the pre-mRNA is the primary transcript containing all exons and introns. Its length is therefore the sum of the lengths of all individual exons and introns.\n$$L_{\\text{pre-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i} + \\sum_{j=1}^{N_I} L_{I_j}$$\n\nSecond, we derive the expression for the length of the eukaryotic mature mRNA, denoted $L_{\\text{mature-mRNA}}$. According to assumption (ii), the mature mRNA is produced by splicing, which removes all introns. Assumption (iii) instructs us to ignore other features like the $5'$ cap and $3'$ poly(A) tail. Thus, the length of the mature mRNA is simply the sum of the lengths of all exons.\n$$L_{\\text{mature-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i}$$\n\nThird, we derive the expression for the length of the corresponding prokaryotic mRNA, denoted $L_{\\text{prok-mRNA}}$. The problem specifies a synthetic prokaryotic construct designed to express the same protein. This implies that the coding sequence of the prokaryotic gene must be identical to the coding sequence of the spliced eukaryotic mRNA. In prokaryotes, transcription is colinear. Assumption (iv) states that we ignore untranslated leader and trailer sequences. Therefore, the length of the prokaryotic mRNA must be equal to the total length of the exons from the original eukaryotic gene.\n$$L_{\\text{prok-mRNA}} = \\sum_{i=1}^{N_E} L_{E_i} = L_{\\text{mature-mRNA}}$$\n\nNow we perform the calculations using the provided values.\nThe total length of the exons is:\n$$\\sum_{i=1}^{3} L_{E_i} = L_{E_1} + L_{E_2} + L_{E_3} = 150 + 1200 + 300 = 1650\\,\\text{nt}$$\nThe total length of the introns is:\n$$\\sum_{j=1}^{2} L_{I_j} = L_{I_1} + L_{I_2} = 900 + 1450 = 2350\\,\\text{nt}$$\n\nUsing these sums, we evaluate the length of each RNA molecule.\n\nLength of the eukaryotic pre-mRNA:\n$$L_{\\text{pre-mRNA}} = \\left(\\sum_{i=1}^{3} L_{E_i}\\right) + \\left(\\sum_{j=1}^{2} L_{I_j}\\right) = 1650 + 2350 = 4000\\,\\text{nt}$$\nThis result is consistent with the provided total genomic span of $4\\,\\text{kb}$, which is $4000\\,\\text{bp}$.\n\nLength of the eukaryotic mature mRNA:\n$$L_{\\text{mature-mRNA}} = \\sum_{i=1}^{3} L_{E_i} = 1650\\,\\text{nt}$$\n\nLength of the prokaryotic mRNA:\n$$L_{\\text{prok-mRNA}} = \\sum_{i=1}^{3} L_{E_i} = 1650\\,\\text{nt}$$\n\nThe problem requires the final answer to be a single row matrix containing the three calculated lengths in the order: eukaryotic pre-mRNA length, eukaryotic mature mRNA length, and prokaryotic mRNA length. The values are $4000$, $1650$, and $1650$, respectively.", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4000  1650  1650\n\\end{pmatrix}\n}\n$$", "id": "2764248"}, {"introduction": "Beyond static structure, the regulation of gene expression is paramount, and it begins at the promoter. In prokaryotes, the strength of a promoter sequence dictates the frequency of transcription initiation. This practice introduces a core bioinformatics method, the Position Weight Matrix (PWM), to quantitatively model these sequence-based regulatory signals [@problem_id:4599016]. You will apply this model to score potential promoter sequences and predict their relative activities, offering a window into the predictive power of computational genomics.", "problem": "In bacterial transcription initiation, the RNA polymerase holoenzyme recognizes promoter DNA via a sigma factor, and the probability of productive binding depends on sequence-specific interactions at the promoter motifs. The Position Weight Matrix (PWM) encodes a position-specific multinomial model for nucleotides at each motif position. Consider a sigma factor recognizing a $12$ base-pair promoter motif (six base pairs corresponding to the $-35$ element and six base pairs corresponding to the $-10$ element). You are given a Position Weight Matrix (PWM) and a fixed background nucleotide distribution. The PWM specifies, for each position $i \\in \\{1,\\dots,12\\}$, the probabilities for nucleotides $\\{A,C,G,T\\}$ under the motif model. The rows of the PWM correspond to nucleotides in the order $A$, $C$, $G$, $T$, and columns correspond to positions $1$ through $12$:\n$$\n\\text{PWM} =\n\\begin{pmatrix}\n0.05  0.10  0.10  0.60  0.10  0.70  0.10  0.60  0.10  0.60  0.60  0.10 \\\\\n0.10  0.10  0.10  0.10  0.60  0.10  0.10  0.10  0.10  0.10  0.10  0.10 \\\\\n0.15  0.10  0.60  0.20  0.20  0.10  0.10  0.10  0.10  0.10  0.10  0.10 \\\\\n0.70  0.70  0.20  0.10  0.10  0.10  0.70  0.20  0.70  0.20  0.20  0.70\n\\end{pmatrix}.\n$$\nAssume a fixed background distribution $q$ over nucleotides given by $q(A)=0.30$, $q(C)=0.20$, $q(G)=0.20$, and $q(T)=0.30$. Define the log-odds score for a promoter sequence as the natural logarithm of the likelihood ratio under the PWM model versus the background model, using the standard independence assumption across positions. Two promoter sequences of length $12$ are provided:\n- Sequence $1$: $\\mathrm{TTGACATATAAT}$,\n- Sequence $2$: $\\mathrm{CTGGCGTATCAT}$.\nAssuming a thermodynamic occupancy model in which the transcription initiation rate is proportional to the exponential of the natural-log log-odds score, compute the ratio of predicted initiation rates $R_{1}/R_{2}$ for Sequence $1$ relative to Sequence $2$. Use the natural logarithm for all computations, and express the final ratio as a unitless decimal. Round your answer to four significant figures.", "solution": "The problem asks for the ratio of transcription initiation rates, $R_{1}/R_{2}$, for two DNA sequences, $S_1$ and $S_2$, based on a Position Weight Matrix (PWM) model.\n\nFirst, let us formalize the quantities involved. The length of the promoter motif is $L=12$. The PWM, denoted by $W$, is a matrix where $W(b, i)$ gives the probability of observing nucleotide $b \\in \\{\\mathrm{A,C,G,T}\\}$ at position $i \\in \\{1,\\dots,12\\}$ under the motif model. The background nucleotide distribution is given by $q(b)$.\n\nThe problem defines the log-odds score for a sequence $S = s_1s_2\\dots s_{12}$ as the natural logarithm of the likelihood ratio. The likelihood of the sequence under the PWM model is $P(S|W) = \\prod_{i=1}^{12} W(s_i, i)$. The likelihood under the background model is $P(S|q) = \\prod_{i=1}^{12} q(s_i)$. The likelihood ratio, $LR(S)$, is given by:\n$$\nLR(S) = \\frac{P(S|W)}{P(S|q)} = \\frac{\\prod_{i=1}^{12} W(s_i, i)}{\\prod_{i=1}^{12} q(s_i)} = \\prod_{i=1}^{12} \\frac{W(s_i, i)}{q(s_i)}\n$$\nThe log-odds score, which we denote as $\\mathcal{S}(S)$, is the natural logarithm of this ratio:\n$$\n\\mathcal{S}(S) = \\ln(LR(S)) = \\ln\\left(\\prod_{i=1}^{12} \\frac{W(s_i, i)}{q(s_i)}\\right) = \\sum_{i=1}^{12} \\ln\\left(\\frac{W(s_i, i)}{q(s_i)}\\right)\n$$\nThe problem states that the transcription initiation rate, $R$, is proportional to the exponential of the natural-log log-odds score. Let $k$ be the proportionality constant.\n$$\nR(S) = k \\cdot \\exp(\\mathcal{S}(S))\n$$\nSubstituting the expression for $\\mathcal{S}(S)$, we find a direct relationship between the rate and the likelihood ratio:\n$$\nR(S) = k \\cdot \\exp(\\ln(LR(S))) = k \\cdot LR(S)\n$$\nThus, the initiation rate is directly proportional to the likelihood ratio itself. The ratio of the initiation rates for Sequence $1$ ($S_1$) and Sequence $2$ ($S_2$) is:\n$$\n\\frac{R_1}{R_2} = \\frac{R(S_1)}{R(S_2)} = \\frac{k \\cdot LR(S_1)}{k \\cdot LR(S_2)} = \\frac{LR(S_1)}{LR(S_2)}\n$$\nOur task reduces to computing the likelihood ratio for each sequence and then finding the ratio of these two values.\n\nThe given data are:\n- Background distribution: $q(\\mathrm{A})=0.30$, $q(\\mathrm{C})=0.20$, $q(\\mathrm{G})=0.20$, $q(\\mathrm{T})=0.30$.\n- PWM matrix $W$ with rows corresponding to A, C, G, T and columns to positions $1$ to $12$.\n- Sequence $1$: $S_1 = \\mathrm{TTGACATATAAT}$.\n- Sequence $2$: $S_2 = \\mathrm{CTGGCGTATCAT}$.\n\nLet's calculate $LR(S_1)$. For each position $i$ in $S_1$, we find the ratio $\\frac{W(s_{1,i}, i)}{q(s_{1,i})}$.\n- $i=1, s_1=\\mathrm{T}$: $\\frac{W(\\mathrm{T},1)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=2, s_2=\\mathrm{T}$: $\\frac{W(\\mathrm{T},2)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=3, s_3=\\mathrm{G}$: $\\frac{W(\\mathrm{G},3)}{q(\\mathrm{G})} = \\frac{0.60}{0.20} = 3$\n- $i=4, s_4=\\mathrm{A}$: $\\frac{W(\\mathrm{A},4)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=5, s_5=\\mathrm{C}$: $\\frac{W(\\mathrm{C},5)}{q(\\mathrm{C})} = \\frac{0.60}{0.20} = 3$\n- $i=6, s_6=\\mathrm{A}$: $\\frac{W(\\mathrm{A},6)}{q(\\mathrm{A})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=7, s_7=\\mathrm{T}$: $\\frac{W(\\mathrm{T},7)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=8, s_8=\\mathrm{A}$: $\\frac{W(\\mathrm{A},8)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=9, s_9=\\mathrm{T}$: $\\frac{W(\\mathrm{T},9)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=10, s_{10}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},10)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=11, s_{11}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},11)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=12, s_{12}=\\mathrm{T}$: $\\frac{W(\\mathrm{T},12)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\nThe likelihood ratio for $S_1$ is the product of these values:\n$$\nLR(S_1) = \\left(\\frac{7}{3}\\right)^6 \\cdot (3)^2 \\cdot (2)^4 = \\frac{7^6 \\cdot 3^2 \\cdot 2^4}{3^6} = \\frac{7^6 \\cdot 2^4}{3^4}\n$$\n\nNext, we calculate $LR(S_2)$ for $S_2 = \\mathrm{CTGGCGTATCAT}$.\n- $i=1, s_1=\\mathrm{C}$: $\\frac{W(\\mathrm{C},1)}{q(\\mathrm{C})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=2, s_2=\\mathrm{T}$: $\\frac{W(\\mathrm{T},2)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=3, s_3=\\mathrm{G}$: $\\frac{W(\\mathrm{G},3)}{q(\\mathrm{G})} = \\frac{0.60}{0.20} = 3$\n- $i=4, s_4=\\mathrm{G}$: $\\frac{W(\\mathrm{G},4)}{q(\\mathrm{G})} = \\frac{0.20}{0.20} = 1$\n- $i=5, s_5=\\mathrm{C}$: $\\frac{W(\\mathrm{C},5)}{q(\\mathrm{C})} = \\frac{0.60}{0.20} = 3$\n- $i=6, s_6=\\mathrm{G}$: $\\frac{W(\\mathrm{G},6)}{q(\\mathrm{G})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=7, s_7=\\mathrm{T}$: $\\frac{W(\\mathrm{T},7)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=8, s_8=\\mathrm{A}$: $\\frac{W(\\mathrm{A},8)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=9, s_9=\\mathrm{T}$: $\\frac{W(\\mathrm{T},9)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\n- $i=10, s_{10}=\\mathrm{C}$: $\\frac{W(\\mathrm{C},10)}{q(\\mathrm{C})} = \\frac{0.10}{0.20} = \\frac{1}{2}$\n- $i=11, s_{11}=\\mathrm{A}$: $\\frac{W(\\mathrm{A},11)}{q(\\mathrm{A})} = \\frac{0.60}{0.30} = 2$\n- $i=12, s_{12}=\\mathrm{T}$: $\\frac{W(\\mathrm{T},12)}{q(\\mathrm{T})} = \\frac{0.70}{0.30} = \\frac{7}{3}$\nThe likelihood ratio for $S_2$ is the product:\n$$\nLR(S_2) = \\left(\\frac{1}{2}\\right)^3 \\cdot \\left(\\frac{7}{3}\\right)^4 \\cdot (3)^2 \\cdot (1)^1 \\cdot (2)^2 = \\frac{1}{2^3} \\cdot \\frac{7^4}{3^4} \\cdot 3^2 \\cdot 1 \\cdot 2^2 = \\frac{7^4 \\cdot 3^2 \\cdot 2^2}{2^3 \\cdot 3^4} = \\frac{7^4}{2 \\cdot 3^2}\n$$\n\nFinally, we compute the ratio of the initiation rates:\n$$\n\\frac{R_1}{R_2} = \\frac{LR(S_1)}{LR(S_2)} = \\frac{\\frac{7^6 \\cdot 2^4}{3^4}}{\\frac{7^4}{2 \\cdot 3^2}} = \\frac{7^6 \\cdot 2^4}{3^4} \\cdot \\frac{2 \\cdot 3^2}{7^4}\n$$\n$$\n\\frac{R_1}{R_2} = 7^{(6-4)} \\cdot 2^{(4+1)} \\cdot 3^{(2-4)} = 7^2 \\cdot 2^5 \\cdot 3^{-2} = \\frac{7^2 \\cdot 2^5}{3^2} = \\frac{49 \\cdot 32}{9} = \\frac{1568}{9}\n$$\nNow, we convert this fraction to a decimal value:\n$$\n\\frac{1568}{9} \\approx 174.2222...\n$$\nThe problem requires the answer to be rounded to four significant figures. The first four significant figures are $1$, $7$, $4$, and $2$. The fifth digit is $2$, which is less than $5$, so we round down.\nThe final result is $174.2$.", "answer": "$$\n\\boxed{174.2}\n$$", "id": "4599016"}, {"introduction": "Having explored individual features of gene structure and regulation, we now tackle the grand challenge of *de novo* gene prediction. This exercise asks you to implement the Viterbi algorithm for a Hidden Markov Model (HMM), a classic and powerful probabilistic tool used to parse raw DNA sequence into a complete gene model with exons, introns, and regulatory regions [@problem_id:4599035]. This hands-on coding task synthesizes our understanding of eukaryotic gene architecture into a functional predictive engine, mirroring the foundational algorithms of modern genome annotation pipelines.", "problem": "You are to implement a complete, runnable program that performs Viterbi decoding for a splice-aware Hidden Markov Model (HMM) to infer the most likely gene model on given deoxyribonucleic acid sequences. The model reflects a simplified eukaryotic gene architecture with the following states: intergenic, promoter, five-prime untranslated region, exon, intron, and three-prime untranslated region. The decoding must incorporate boundary motif preferences for splice donor and acceptor sites using local sequence context. The solution must be derived from fundamental principles of the Central Dogma of Molecular Biology and the definition of a Hidden Markov Model.\n\nDefinitions and modeling assumptions:\n- The Central Dogma of Molecular Biology states that information flows as deoxyribonucleic acid to ribonucleic acid to protein. In eukaryotes, genes contain exons and introns; introns are removed via splicing, with splice donor and acceptor motifs typically enriched near intron boundaries.\n- A Hidden Markov Model (HMM) consists of a finite set of hidden states, an initial state distribution, a state transition probability matrix, and emission distributions over an observed alphabet. The joint probability of a state sequence and an observation sequence factorizes as a product of initial, transition, and emission factors under the Markov and conditional independence assumptions.\n- Here, the model uses a boundary motif factor that multiplies the transition probability when switching between exon and intron states to reflect donor and acceptor consensus patterns; this factor depends on the adjacent observed symbols surrounding the boundary.\n\nState space and coding:\n- The states are encoded as integers for output: intergenic is $0$, promoter is $1$, five-prime untranslated region is $2$, exon is $3$, intron is $4$, three-prime untranslated region is $5$.\n\nObservations and alphabet:\n- The observation alphabet is the set of nucleotides {A, C, G, T}. Map these to indices as follows: A $\\rightarrow$ $0$, C $\\rightarrow$ $1$, G $\\rightarrow$ $2$, T $\\rightarrow$ $3$.\n\nModel parameters:\n- Let the initial distribution be $\\pi \\in \\mathbb{R}^6$, with nonzero entries $\\pi_0 = 0.98$ and $\\pi_1 = 0.02$, and $\\pi_s = 0$ for all other states $s$. All numbers are probabilities, so they lie in $[0,1]$ and sum to $1$.\n- Let the state transition probability matrix be $A \\in \\mathbb{R}^{6 \\times 6}$ with rows indexed by previous state and columns by next state. Nonzero transitions are:\n  - From intergenic $0$: to $0$ with $0.995$, to $1$ with $0.005$.\n  - From promoter $1$: to $1$ with $0.90$, to $2$ with $0.10$.\n  - From five-prime untranslated region $2$: to $2$ with $0.85$, to $3$ with $0.15$.\n  - From exon $3$: to $3$ with $0.90$, to $4$ with $0.08$, to $5$ with $0.02$.\n  - From intron $4$: to $4$ with $0.92$, to $3$ with $0.08$.\n  - From three-prime untranslated region $5$: to $5$ with $0.90$, to $0$ with $0.10$.\n  - All other transitions have probability $0$.\n- Let the emission probability matrix be $B \\in \\mathbb{R}^{6 \\times 4}$ with rows over states and columns over nucleotides in the order [A, C, G, T]. Emission probabilities by state are:\n  - Intergenic $0$: $[0.30, 0.20, 0.20, 0.30]$.\n  - Promoter $1$: $[0.40, 0.10, 0.10, 0.40]$.\n  - Five-prime untranslated region $2$: $[0.35, 0.15, 0.15, 0.35]$.\n  - Exon $3$: $[0.20, 0.30, 0.30, 0.20]$.\n  - Intron $4$: $[0.35, 0.15, 0.15, 0.35]$.\n  - Three-prime untranslated region $5$: $[0.35, 0.15, 0.15, 0.35]$.\n- Splice-aware boundary motif factors: For a transition from state $s'$ at position $t-1$ to state $s$ at position $t$, define a multiplicative boundary factor $g(s', s, x_{t-1}, x_t)$:\n  - If $(s', s) = (3, 4)$ (exon to intron), then $g = 0.9$ if $(x_{t-1}, x_t) = (\\text{G}, \\text{T})$, else $g = 0.1$.\n  - If $(s', s) = (4, 3)$ (intron to exon), then $g = 0.9$ if $(x_{t-1}, x_t) = (\\text{A}, \\text{G})$, else $g = 0.1$.\n  - For all other $(s', s)$, $g = 1.0$.\n\nDerivation target:\n- Derive from the definition of an HMM and the Markov property a dynamic programming recursion that yields the most probable state sequence $y_{1:T}$ given an observation sequence $x_{1:T}$ under the above factorization. Work in the log domain to avoid numerical underflow, using the natural logarithm. The recursion should maximize the sum of log-initial, log-transition, log-emission, and log-boundary factors and store backpointers to recover the optimal path.\n\nComputational task:\n- Implement the derived Viterbi algorithm that incorporates the boundary motif factors $g(\\cdot)$ as specified above. Your implementation must compute, for each test sequence, the most likely state sequence $y_{1:T}$.\n\nTest suite:\n- Use the following three deoxyribonucleic acid sequences as the test suite:\n  1. CGCGTTTATAAAATATCCGTTTAGCCATATCG\n  2. GGCGTATATAATATGCCGCCATATTT\n  3. ATTATAATACGTAAGAT\n- For each sequence, the program should return the integer-coded state path as a list of integers of length equal to the sequence length.\n\nFinal output format:\n- Your program should produce a single line of output containing the three lists of decoded states, in order of the test suite sequences, as a comma-separated list enclosed in square brackets. The output must be of the form: a list of three lists of integers, for example, something like \"[[a,b,c,...],[...],[...]]\" where each inner list has length equal to the corresponding sequence length. No additional text or whitespace is permitted beyond this single line.", "solution": "We base the derivation on the definition of a Hidden Markov Model (HMM) and the chain rule of probability, combined with the Markov property and conditional independence of emissions given states. Let the observed sequence be $x_{1:T}$ with $T$ positions and the hidden state sequence be $y_{1:T}$ with $y_t \\in \\{0,1,2,3,4,5\\}$. The standard HMM factorization for the joint probability is\n$$\np(y_{1:T}, x_{1:T}) = \\pi_{y_1} \\cdot b_{y_1}(x_1) \\cdot \\prod_{t=2}^{T} a_{y_{t-1}, y_t} \\cdot b_{y_t}(x_t),\n$$\nwhere $\\pi_s$ are initial probabilities, $a_{i,j}$ are transition probabilities, and $b_s(x)$ are emission probabilities.\n\nTo incorporate splice-aware boundary preferences, we introduce a boundary factor $g(y_{t-1}, y_t, x_{t-1}, x_t)$ that multiplies the transition at each step to upweight likely donor and acceptor motifs, giving a generalized factorization:\n$$\np(y_{1:T}, x_{1:T}) = \\pi_{y_1} \\cdot b_{y_1}(x_1) \\cdot \\prod_{t=2}^{T} \\left[ a_{y_{t-1}, y_t} \\cdot g(y_{t-1}, y_t, x_{t-1}, x_t) \\cdot b_{y_t}(x_t) \\right].\n$$\nThe boundary factor $g$ is defined to be $0.9$ for a donor-compatible pair when $(y_{t-1}, y_t) = (3, 4)$ and $(x_{t-1}, x_t) = (\\text{G}, \\text{T})$, or $0.9$ for an acceptor-compatible pair when $(y_{t-1}, y_t) = (4, 3)$ and $(x_{t-1}, x_t) = (\\text{A}, \\text{G})$; otherwise $g$ is $0.1$ for those exon-intron switching transitions, and $1.0$ for all other transitions. This maintains local dependence only on $(x_{t-1}, x_t)$ so that dynamic programming remains valid, since each factor at time $t$ depends solely on $(y_{t-1}, y_t)$ and the adjacent observations.\n\nWe seek the maximizer\n$$\n\\hat{y}_{1:T} = \\arg\\max_{y_{1:T}} \\; p(y_{1:T}, x_{1:T}).\n$$\nBecause products of probabilities can underflow numerically, we work with log-probabilities and convert products to sums. Define\n$$\n\\ell_{\\pi}(s) = \\log \\pi_s,\\quad \\ell_a(i,j) = \\log a_{i,j},\\quad \\ell_b(s,x) = \\log b_s(x),\\quad \\ell_g(i,j,x',x) = \\log g(i,j,x',x).\n$$\nLet the dynamic programming table be\n$$\n\\delta_t(s) = \\max_{y_{1:t-1}} \\log \\left[ \\pi_{y_1} b_{y_1}(x_1) \\prod_{k=2}^{t} a_{y_{k-1}, y_k} \\, g(y_{k-1}, y_k, x_{k-1}, x_k) \\, b_{y_k}(x_k) \\right],\n$$\nwhich is the maximum log-probability of a path ending in state $s$ at time $t$. The initialization at $t=1$ is\n$$\n\\delta_1(s) = \\ell_{\\pi}(s) + \\ell_b(s, x_1),\n$$\nand the recursion for $t \\ge 2$ is\n$$\n\\delta_t(s) = \\max_{s' \\in \\{0,\\dots,5\\}} \\left[ \\delta_{t-1}(s') + \\ell_a(s', s) + \\ell_g(s', s, x_{t-1}, x_t) + \\ell_b(s, x_t) \\right].\n$$\nTo recover the maximizing state path, we store backpointers\n$$\n\\psi_t(s) = \\arg\\max_{s' \\in \\{0,\\dots,5\\}} \\left[ \\delta_{t-1}(s') + \\ell_a(s', s) + \\ell_g(s', s, x_{t-1}, x_t) \\right],\n$$\nand then perform traceback:\n- Let $y_T = \\arg\\max_{s} \\delta_T(s)$.\n- For $t$ from $T$ down to $2$, set $y_{t-1} = \\psi_t(y_t)$.\n\nThe result $\\hat{y}_{1:T}$ is the most likely sequence under the model.\n\nAlgorithmic design details:\n- Disallowed transitions have $a_{i,j} = 0$, which maps to $\\ell_a(i,j) = -\\infty$; these are excluded from the maximization.\n- The observation alphabet is mapped to indices $\\{0,1,2,3\\}$ as A $\\rightarrow$ $0$, C $\\rightarrow$ $1$, G $\\rightarrow$ $2$, T $\\rightarrow$ $3$, so that $\\ell_b(s, x_t)$ can be accessed via array indexing.\n- Computation is in the natural log domain using $-\\infty$ for $\\log 0$; standard floating-point handling allows the $\\max$ operation to ignore $-\\infty$ entries.\n- The boundary factor $\\ell_g$ is computed per candidate transition using $(x_{t-1}, x_t)$, which is available at the time of updating $\\delta_t(s)$, thus preserving the dynamic programming structure.\n\nScientific rationale:\n- The Central Dogma and known eukaryotic gene architecture motivate states for intergenic regions, promoters, untranslated regions, exons, and introns.\n- The HMM formalism captures the stochastic switching among these states and the nucleotide composition biases in each state through emission distributions.\n- Splice donor and acceptor consensus motifs are incorporated by modulating the transition likelihoods at exon-intron boundaries via the boundary factor $g$, preserving locality so that the Viterbi recursion remains valid.\n\nApplying this derivation, the implementation proceeds by:\n- Defining $\\pi$, $A$, $B$, and the boundary factor function $g$ with the specified numerical values.\n- Implementing the log-domain Viterbi algorithm with backpointers for each test sequence.\n- Returning the decoded state sequences using the integer coding $0$ through $5$ in the specified single-line output format.\n\nThe test suite comprises three sequences. For each, the algorithm outputs a list of integers of length equal to the sequence length, representing the most likely state at each position. The final output is a single line containing a list of these three lists, separated by commas and enclosed in square brackets, with no additional text.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# State indices\nIG, PR, U5, EX, IN, U3 = 0, 1, 2, 3, 4, 5\n\n# Alphabet mapping\nalphabet = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\ndef log_safe(x):\n    \"\"\"Return natural log, handling zeros as -inf.\"\"\"\n    with np.errstate(divide='ignore'):\n        return np.log(x)\n\ndef boundary_log_factor(prev_state, curr_state, prev_char, curr_char):\n    \"\"\"\n    Compute log boundary factor given states and adjacent observed symbols.\n    Splice-aware factors:\n      - EX-IN prefers GT across boundary (prev_char='G', curr_char='T').\n      - IN-EX prefers AG across boundary (prev_char='A', curr_char='G').\n    All other transitions have factor 1.0.\n    \"\"\"\n    if prev_state == EX and curr_state == IN:\n        if prev_char == 'G' and curr_char == 'T':\n            return np.log(0.9)\n        else:\n            return np.log(0.1)\n    elif prev_state == IN and curr_state == EX:\n        if prev_char == 'A' and curr_char == 'G':\n            return np.log(0.9)\n        else:\n            return np.log(0.1)\n    else:\n        return 0.0  # log(1.0)\n\ndef viterbi_decode(seq, pi, A, B):\n    \"\"\"\n    Viterbi decoding with boundary motif factors.\n    seq: string of nucleotides\n    pi: (S,) initial probabilities\n    A: (S,S) transition probabilities\n    B: (S,4) emission probabilities for A,C,G,T\n    Returns: list of state indices\n    \"\"\"\n    S = pi.shape[0]\n    T = len(seq)\n    # Map sequence to indices\n    obs = np.array([alphabet[ch] for ch in seq], dtype=int)\n\n    # Precompute logs\n    log_pi = log_safe(pi)\n    log_A = log_safe(A)\n    log_B = log_safe(B)\n\n    # Initialize DP tables\n    delta = np.full((T, S), -np.inf, dtype=float)\n    psi = np.full((T, S), -1, dtype=int)\n\n    # Initialization at t=0\n    for s in range(S):\n        if log_pi[s]  -np.inf and log_B[s, obs[0]]  -np.inf:\n            delta[0, s] = log_pi[s] + log_B[s, obs[0]]\n            psi[0, s] = -1  # start\n        else:\n            delta[0, s] = -np.inf\n            psi[0, s] = -1\n\n    # Recursion\n    for t in range(1, T):\n        curr_char = seq[t]\n        prev_char = seq[t-1]\n        for s in range(S):\n            emit = log_B[s, obs[t]]\n            if emit == -np.inf:\n                # Impossible emission\n                continue\n            best_score = -np.inf\n            best_prev = -1\n            # Consider all previous states\n            for sp in range(S):\n                trans = log_A[sp, s]\n                if trans == -np.inf:\n                    continue\n                bfactor = boundary_log_factor(sp, s, prev_char, curr_char)\n                score = delta[t-1, sp] + trans + bfactor + emit\n                if score  best_score:\n                    best_score = score\n                    best_prev = sp\n            delta[t, s] = best_score\n            psi[t, s] = best_prev\n\n    # Termination\n    last_state = int(np.argmax(delta[T-1, :]))\n    path = [last_state]\n    # Backtrace\n    for t in range(T-1, 0, -1):\n        last_state = psi[t, last_state]\n        if last_state  0:\n            # No valid backpointer; break (should not happen with provided params)\n            last_state = 0\n        path.append(last_state)\n    path.reverse()\n    return path\n\ndef solve():\n    # Define model parameters\n    S = 6\n\n    # Initial distribution\n    pi = np.zeros(S, dtype=float)\n    pi[IG] = 0.98\n    pi[PR] = 0.02\n\n    # Transition matrix\n    A = np.zeros((S, S), dtype=float)\n    # IG - IG, PR\n    A[IG, IG] = 0.995\n    A[IG, PR] = 0.005\n    # PR - PR, U5\n    A[PR, PR] = 0.90\n    A[PR, U5] = 0.10\n    # U5 - U5, EX\n    A[U5, U5] = 0.85\n    A[U5, EX] = 0.15\n    # EX - EX, IN, U3\n    A[EX, EX] = 0.90\n    A[EX, IN] = 0.08\n    A[EX, U3] = 0.02\n    # IN - IN, EX\n    A[IN, IN] = 0.92\n    A[IN, EX] = 0.08\n    # U3 - U3, IG\n    A[U3, U3] = 0.90\n    A[U3, IG] = 0.10\n\n    # Emission matrix B[state, nucleotide_index]\n    B = np.zeros((S, 4), dtype=float)\n    # IG\n    B[IG, :] = [0.30, 0.20, 0.20, 0.30]\n    # PR\n    B[PR, :] = [0.40, 0.10, 0.10, 0.40]\n    # U5\n    B[U5, :] = [0.35, 0.15, 0.15, 0.35]\n    # EX\n    B[EX, :] = [0.20, 0.30, 0.30, 0.20]\n    # IN\n    B[IN, :] = [0.35, 0.15, 0.15, 0.35]\n    # U3\n    B[U3, :] = [0.35, 0.15, 0.15, 0.35]\n\n    # Test suite sequences\n    test_cases = [\n        \"CGCGTTTATAAAATATCCGTTTAGCCATATCG\",\n        \"GGCGTATATAATATGCCGCCATATTT\",\n        \"ATTATAATACGTAAGAT\",\n    ]\n\n    results = []\n    for seq in test_cases:\n        states = viterbi_decode(seq, pi, A, B)\n        results.append(states)\n\n    # Format as a single line: list of lists of integers\n    # Ensure no extra spaces\n    def format_list(lst):\n        return \"[\" + \",\".join(str(int(x)) for x in lst) + \"]\"\n    output = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "4599035"}]}