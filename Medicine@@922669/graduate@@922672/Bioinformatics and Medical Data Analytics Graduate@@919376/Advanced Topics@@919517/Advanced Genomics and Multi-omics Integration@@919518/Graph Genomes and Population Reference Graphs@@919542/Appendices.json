{"hands_on_practices": [{"introduction": "The theoretical concept of a variation graph becomes tangible when built from familiar data formats like the Variant Call Format (VCF). This exercise guides you through the fundamental process of converting simple genetic variants—a single-nucleotide polymorphism (SNP) and a deletion—into the nodes (segments) and edges (links) of a graph. By completing this task [@problem_id:4569876], you will gain a practical understanding of how allelic diversity is encoded as alternative paths or \"bubbles\" in the graph structure.", "problem": "You are given a small set of variant descriptions in the Variant Call Format (VCF; Variant Call Format) and asked to convert them into a simplified, reference-annotated Graphical Fragment Assembly (rGFA; reference-annotated Graphical Fragment Assembly) representation. The core of the task is to formalize the conversion of a bi-allelic single-nucleotide polymorphism (SNP; single-nucleotide polymorphism) and a two base pair (bp; base pairs) deletion into graph components by creating segment sequences, link adjacencies with orientations, and sample paths that traverse chosen alleles. Your program must implement a principled algorithm grounded in accepted foundations of genome representation and variation graphs, and then compute quantifiable metrics from the constructed graph for a given set of test cases.\n\nFundamental base and definitions to use:\n- A linear reference genome string is a finite sequence over the alphabet $\\{A,C,G,T\\}$.\n- The Variant Call Format (VCF) encodes variants relative to the linear reference with position coordinates being $1$-based offsets on the reference.\n- The Graphical Fragment Assembly (GFA) standard represents a genome graph using segments (nodes) carrying sequences and links (edges) connecting segment ends with oriented labels $+$ or $-$.\n- The reference-annotated Graphical Fragment Assembly (rGFA) augments segments and paths with tags that annotate provenance such as reference coordinates and variant identifiers.\n- A bi-allelic single-nucleotide polymorphism is a position $p$ where the reference base is replaced by an alternative base.\n- A deletion of length $L$ starting at position $s$ removes the contiguous reference interval $[s, s+L-1]$ from the alternative haplotype.\n\nYou must construct the following graph elements:\n- Segments: contiguous sequences from the reference that lie between variant breakpoints, plus variant-specific segments for allele choices. For a SNP at position $p$, create one segment for the reference allele (the base at $p$) and one segment for the alternative allele (the provided alternative base). For a deletion starting at position $s$ of length $L$, create a segment for the deleted reference interval (which is traversed only by the reference path), while the deletion alternative path bypasses this segment.\n- Links: edges that connect segments in the order they appear along the reference coordinate axis. Each link must specify orientations. In this exercise, all segments are considered forward-oriented, so every link uses the $+$ orientation on both ends.\n- Sample paths: for each provided sample genotype, construct a path by concatenating the segments corresponding to the selected allele at each variant (reference allele index $0$, alternative allele index $1$) and including the inter-variant reference segments in order.\n\nYou must track provenance conceptually using rGFA-like tags on segments and paths, including but not limited to:\n- Segment-level tags: reference sequence name, reference coordinate span for reference-derived segments, variant identifier, variant type, and allele identity (reference or alternative).\n- Path-level tags: sample name and the ordered list of segment identifiers traversed.\n\nYour program must implement the conversion and then compute the following per test case:\n1. The total number of segments (an integer).\n2. The total number of links (an integer).\n3. The length of the sample path sequence in base pairs (express this integer in bp).\n4. A boolean indicating whether the sample path sequence equals the haplotype sequence obtained by applying the variant edits directly to the reference string in order (true if they match, false otherwise).\n\nTest suite:\nUse the following four parameterized test cases. Each test case provides a reference name, a reference sequence, a list of variants, a sample name, and the sample’s allele selections for the variants in order. Positions are $1$-based.\n\n- Case $1$ (bi-allelic SNP only, happy path):\n  - Reference name: $\\text{chrSNP}$\n  - Reference sequence: $\\text{\"GATTACA\"}$\n  - Variants: one SNP at position $p=4$ with alternative base $\\text{\"G\"}$ and identifier $\\text{\"v1\"}$\n  - Sample name: $\\text{\"SNP\\_ALT\"}$\n  - Allele selections: $[1]$ (choose alternative allele)\n\n- Case $2$ (two base pair deletion only, happy path):\n  - Reference name: $\\text{chrDEL}$\n  - Reference sequence: $\\text{\"AACCGGTT\"}$\n  - Variants: one deletion starting at position $s=3$ with length $L=2$ and identifier $\\text{\"v2\"}$\n  - Sample name: $\\text{\"DEL\\_ALT\"}$\n  - Allele selections: $[1]$ (choose deletion alternative, which bypasses the deleted segment)\n\n- Case $3$ (SNP followed by near-tail two base pair deletion, mixed allele choices):\n  - Reference name: $\\text{chrMIX}$\n  - Reference sequence: $\\text{\"AGCTTAGC\"}$\n  - Variants: a SNP at position $p=3$ with alternative base $\\text{\"G\"}$ and identifier $\\text{\"v3\"}$; and a deletion at $s=6$ with length $L=2$ and identifier $\\text{\"v4\"}$\n  - Sample name: $\\text{\"MIX\\_ALT\\_REF\"}$\n  - Allele selections: $[1,0]$ (choose alternative allele for the SNP and reference allele for the deletion)\n\n- Case $4$ (boundary condition: SNP at first position, no preceding reference segment):\n  - Reference name: $\\text{chrEDGE}$\n  - Reference sequence: $\\text{\"CCG\"}$\n  - Variants: one SNP at position $p=1$ with alternative base $\\text{\"A\"}$ and identifier $\\text{\"v5\"}$\n  - Sample name: $\\text{\"EDGE\\_SNP\\_ALT\"}$\n  - Allele selections: $[1]$ (choose alternative allele)\n\nYour program must produce a single line of output containing the results for the four test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a list in the order described above. For example, the output format must be\n$\\text{[[nSeg\\_1,nLink\\_1,lenBp\\_1,match\\_1],[nSeg\\_2,nLink\\_2,lenBp\\_2,match\\_2],[nSeg\\_3,nLink\\_3,lenBp\\_3,match\\_3],[nSeg\\_4,nLink\\_4,lenBp\\_4,match\\_4]]}$\nwith integers and booleans appearing in their default textual forms. The base-pair length must be expressed as an integer count of base pairs (bp). No additional text may be printed. Your program must not read any input and must be fully self-contained.", "solution": "The provided problem statement is valid. It presents a well-defined task in computational biology, grounded in the established principles of variation graph representation as formalized by standards like GFA. The problem is self-contained, logically consistent, and free of scientific or factual unsoundness. It requires the implementation of a deterministic algorithm to convert variant information relative to a linear reference into a graph structure and then to compute specific, verifiable metrics from that structure.\n\nThe core of the problem is to translate declarative variant calls into a non-linear, graph-based data model. This process is fundamental to modern pangenomics, which aims to represent the genetic diversity of a population rather than being restricted to a single linear reference genome. The solution involves a principled, step-by-step algorithm to construct the graph components—segments and links—and to trace paths corresponding to specific sample haplotypes.\n\nThe algorithm proceeds as follows:\n\nFirst, we must systematically partition the reference genome based on the locations of the given variants. The boundaries of variants act as **breakpoints**. For a reference sequence $R$ of length $N$, a single-nucleotide polymorphism (SNP) at $1$-based position $p$ defines a variant interval of $[p, p]$, creating breakpoints flanking this position. A deletion of length $L$ starting at $1$-based position $s$ defines a variant interval of $[s, s+L-1]$, similarly introducing breakpoints. By collecting all such breakpoints from all variants, along with the reference start ($1$) and end ($N$), we obtain an ordered set of coordinates that partition the reference sequence into a series of contiguous intervals.\n\nSecond, we generate the graph segments. There are two primary categories of segments:\n1.  **Invariant Reference Segments**: These are derived from the intervals of the reference genome that lie between variant sites. For each such interval, a segment is created whose sequence is the corresponding substring of the reference $R$.\n2.  **Allelic Segments**: These are created at each variant site to represent the different allelic choices.\n    *   For a SNP at position $p$, two segments of length $1$ are created: one for the reference allele (the base $R[p]$) and one for the alternative allele.\n    *   For a deletion of the interval $[s, s+L-1]$, one segment is created representing the reference allele, containing the sequence of this deleted interval. The alternative allele (the deletion itself) is not represented by a sequence-bearing segment but rather by a structural bypass in the graph, an edge that \"jumps over\" the reference allele segment.\n\nThird, we establish the graph's topology by creating **links**. The links connect the segments in an order consistent with the reference coordinate system. Following the specified `+/+` orientation for all connections, the logic is as follows: A segment corresponding to a reference interval ending at position $i$ will link to any segment that begins at position $i+1$. This creates a \"bubble\" at each variant site: the invariant segment preceding the variant links to the start of all possible allelic segments for that variant. In turn, the end of all these allelic segments links to the start of the next invariant segment. For a deletion, the alternative path is realized by a link that connects the segment before the deletion site directly to the segment after it, bypassing the deletable-region segment.\n\nFourth, we reconstruct the **sample path and haplotype sequence**. The sample's genotype, given as a vector of allele choices ($0$ for reference, $1$ for alternative), dictates a specific traversal through the graph. The path is constructed by concatenating the identifiers of the segments—both invariant and the chosen allelic ones—in their order of appearance. The resulting path sequence is the concatenation of the nucleotide sequences of the segments in this path. For comparison, the ground-truth haplotype sequence is generated by applying the chosen variant edits directly to the linear reference string. To avoid coordinate-shifting issues, edits are best applied in descending order of position.\n\nFinally, we compute the required metrics from the constructed graph and path:\n1.  **Total number of segments ($N_{seg}$)**: A direct count of all generated segments (invariant and allelic).\n2.  **Total number of links ($N_{link}$)**: A direct count of all created connections between segments.\n3.  **Sample path length ($L_{path}$)**: The sum of the lengths of the nucleotide sequences of all segments in the sample's path.\n4.  **Path-haplotype match ($M_{match}$)**: A boolean comparison (`true` or `false`) of the reconstructed path sequence and the ground-truth haplotype sequence.\n\nThis formal procedure ensures that the variant data is unambiguously translated into a graph representation from which quantitative and qualitative properties can be derived, as required by the problem's test cases.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"ref_name\": \"chrSNP\",\n            \"ref_seq\": \"GATTACA\",\n            \"variants\": [\n                {\"id\": \"v1\", \"pos\": 4, \"ref\": \"T\", \"alt\": \"G\", \"type\": \"SNP\"}\n            ],\n            \"sample_name\": \"SNP_ALT\",\n            \"alleles\": [1]\n        },\n        {\n            \"ref_name\": \"chrDEL\",\n            \"ref_seq\": \"AACCGGTT\",\n            \"variants\": [\n                {\"id\": \"v2\", \"pos\": 3, \"ref\": \"CC\", \"alt\": \"C\", \"type\": \"DEL\", \"len\": 2}\n            ],\n            \"sample_name\": \"DEL_ALT\",\n            \"alleles\": [1]\n        },\n        {\n            \"ref_name\": \"chrMIX\",\n            \"ref_seq\": \"AGCTTAGC\",\n            \"variants\": [\n                {\"id\": \"v3\", \"pos\": 3, \"ref\": \"C\", \"alt\": \"G\", \"type\": \"SNP\"},\n                {\"id\": \"v4\", \"pos\": 6, \"ref\": \"AG\", \"alt\": \"A\", \"type\": \"DEL\", \"len\": 2}\n            ],\n            \"sample_name\": \"MIX_ALT_REF\",\n            \"alleles\": [1, 0]\n        },\n        {\n            \"ref_name\": \"chrEDGE\",\n            \"ref_seq\": \"CCG\",\n            \"variants\": [\n                {\"id\": \"v5\", \"pos\": 1, \"ref\": \"C\", \"alt\": \"A\", \"type\": \"SNP\"}\n            ],\n            \"sample_name\": \"EDGE_SNP_ALT\",\n            \"alleles\": [1]\n        }\n    ]\n\n    results = [process_case(case) for case in test_cases]\n\n    # Format the final output string\n    # e.g., [[4, 4, 7, True], [3, 3, 6, True], ...]\n    output_str = \"[\" + \",\".join([f\"[{','.join(map(str, res))}]\" for res in results]) + \"]\"\n    print(output_str)\n\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case to build the graph and compute metrics.\n    \"\"\"\n    ref_seq = case_data[\"ref_seq\"]\n    variants = case_data[\"variants\"]\n    sample_alleles = case_data[\"alleles\"]\n\n    # --- 1. Graph Construction ---\n    # Sort variants by position to process them linearly\n    variants.sort(key=lambda v: v[\"pos\"])\n\n    segments = []\n    links = set()\n    # Map from variant ID to a dictionary {0: ref_seg_id, 1: alt_seg_id/None}\n    variant_segment_map = {}\n    \n    seg_id_counter = 0\n    current_pos = 0  # 0-based index\n    # List of segment IDs that are \"active\" ends to be linked to the next components\n    dangling_seg_ids = []\n\n    for var in variants:\n        # 1-based variant position to 0-based start index\n        var_start_pos = var[\"pos\"] - 1\n\n        # A. Create invariant reference segment before the variant\n        if var_start_pos > current_pos:\n            seg_seq = ref_seq[current_pos:var_start_pos]\n            seg_id = seg_id_counter\n            segments.append({\"id\": seg_id, \"seq\": seg_seq})\n            seg_id_counter += 1\n            \n            # Link previous dangling ends to this new segment\n            if not dangling_seg_ids: # Handle graph start\n                # This segment is the first one\n                pass\n            else:\n                for last_id in dangling_seg_ids:\n                    links.add((last_id, seg_id))\n            \n            dangling_seg_ids = [seg_id]\n\n        # B. Create variant segments\n        var_dangling_ids = []\n        if var[\"type\"] == \"SNP\":\n            # Ref allele segment\n            ref_allele_seg_id = seg_id_counter\n            segments.append({\"id\": ref_allele_seg_id, \"seq\": ref_seq[var_start_pos]})\n            seg_id_counter += 1\n            # Alt allele segment\n            alt_allele_seg_id = seg_id_counter\n            segments.append({\"id\": alt_allele_seg_id, \"seq\": var[\"alt\"]})\n            seg_id_counter += 1\n            \n            variant_segment_map[var['id']] = {0: ref_allele_seg_id, 1: alt_allele_seg_id}\n\n            if not dangling_seg_ids: # Variant at the start of the reference\n                pass\n            else:\n                for last_id in dangling_seg_ids:\n                    links.add((last_id, ref_allele_seg_id))\n                    links.add((last_id, alt_allele_seg_id))\n            \n            var_dangling_ids = [ref_allele_seg_id, alt_allele_seg_id]\n            current_pos = var_start_pos + 1\n\n        elif var[\"type\"] == \"DEL\":\n            del_len = var[\"len\"]\n            # Ref allele segment (the deleted sequence)\n            ref_allele_seg_id = seg_id_counter\n            deleted_seq = ref_seq[var_start_pos : var_start_pos + del_len]\n            segments.append({\"id\": ref_allele_seg_id, \"seq\": deleted_seq})\n            seg_id_counter += 1\n\n            variant_segment_map[var['id']] = {0: ref_allele_seg_id, 1: None} # None for bypass\n\n            alt_bypass_ids = []\n            if not dangling_seg_ids: # Variant is at start\n                alt_bypass_ids = [-1] # Virtual start node for bypass\n            else:\n                for last_id in dangling_seg_ids:\n                    links.add((last_id, ref_allele_seg_id))\n                alt_bypass_ids = dangling_seg_ids\n            \n            var_dangling_ids = [ref_allele_seg_id] + alt_bypass_ids\n            current_pos = var_start_pos + del_len\n\n        dangling_seg_ids = var_dangling_ids\n\n    # C. Create final invariant reference segment after all variants\n    if current_pos  len(ref_seq):\n        seg_seq = ref_seq[current_pos:]\n        seg_id = seg_id_counter\n        segments.append({\"id\": seg_id, \"seq\": seg_seq})\n        seg_id_counter += 1\n\n        if not dangling_seg_ids: # No variants, just one segment\n            pass\n        else:\n            for last_id in dangling_seg_ids:\n                if last_id != -1: # Don't add links from virtual node\n                    links.add((last_id, seg_id))\n        dangling_seg_ids = [seg_id]\n\n    num_segments = len(segments)\n    num_links = len(links)\n\n    # --- 2. Sample Path and Haplotype Sequence Reconstruction ---\n    # A. Reconstruct path sequence\n    path_segment_indices = []\n    current_pos = 0\n    for i, var in enumerate(variants):\n        var_start_pos = var[\"pos\"] - 1\n        # Add inter-variant segment path\n        if var_start_pos > current_pos:\n            # Find the segment that starts at current_pos\n            for s in segments:\n                if s['seq'] == ref_seq[current_pos:var_start_pos]:\n                    path_segment_indices.append(s['id'])\n                    break\n        \n        # Add chosen variant segment\n        allele_choice = sample_alleles[i]\n        chosen_seg_id = variant_segment_map[var['id']][allele_choice]\n        if chosen_seg_id is not None:\n             path_segment_indices.append(chosen_seg_id)\n        \n        # Update position\n        if var[\"type\"] == \"SNP\":\n            current_pos = var_start_pos + 1\n        elif var[\"type\"] == \"DEL\":\n            current_pos = var_start_pos + var[\"len\"]\n\n    # Add final trailing segment if it exists\n    if current_pos  len(ref_seq):\n        for s in segments:\n            if s['seq'] == ref_seq[current_pos:]:\n                path_segment_indices.append(s['id'])\n                break\n    \n    path_sequence = \"\".join([segments[j][\"seq\"] for j in path_segment_indices])\n    path_length = len(path_sequence)\n\n    # B. Reconstruct haplotype sequence by direct editing\n    hap_seq_list = list(ref_seq)\n    # Apply edits in reverse order to avoid coordinate shifts\n    sorted_edits = sorted(zip(variants, sample_alleles), key=lambda x: x[0][\"pos\"], reverse=True)\n    \n    for var, allele_choice in sorted_edits:\n        if allele_choice == 1:  # Apply alternative allele\n            pos_0based = var[\"pos\"] - 1\n            if var[\"type\"] == \"SNP\":\n                hap_seq_list[pos_0based] = var[\"alt\"]\n            elif var[\"type\"] == \"DEL\":\n                del_len = var[\"len\"]\n                del hap_seq_list[pos_0based : pos_0based + del_len]\n\n    haplotype_sequence = \"\".join(hap_seq_list)\n\n    # --- 3. Compute Metrics ---\n    sequences_match = (path_sequence == haplotype_sequence)\n\n    return [num_segments, num_links, path_length, sequences_match]\n\nsolve()\n```", "id": "4569876"}, {"introduction": "To integrate graph genomes into existing bioinformatics pipelines, it's essential to be able to translate between the linear coordinate system of a reference and the graph's node-based topology. This practice addresses this crucial \"liftover\" challenge by having you develop a function that maps a given linear genomic interval to a precise set of node-and-offset coordinates along a chosen reference path [@problem_id:4569927]. This skill is foundational for annotating features or analyzing read alignments in a graph context.", "problem": "You are given a directed acyclic graph genome model, also known as a Population Reference Graph (PRG), formalized as a directed acyclic graph with nodes representing sequence segments and edges representing allowed adjacencies. Let the graph be denoted by $G=(V,E)$ with a node-length function $\\ell: V \\rightarrow \\mathbb{N}$, where $\\ell(v)$ is the length in bases of the sequence at node $v$. A named reference path is a walk $P=(v_1,v_2,\\dots,v_m)$ such that $(v_i,v_{i+1}) \\in E$ for all $i \\in \\{1,2,\\dots,m-1\\}$. Define a path coordinate system by cumulative prefix sums $S_1=0$ and $S_{i+1}=S_i+\\ell(v_i)$ so that the coordinate interval occupied by node $v_i$ on the path is the half-open interval $[S_i,S_{i+1})$. The total length of the path is $L=S_{m+1}$. A linear genomic interval on the path is specified as a half-open interval $[l,r)$ with $l,r \\in \\mathbb{Z}$ and $0 \\le l \\le r \\le L$.\n\nDefine a mapping function $\\Phi_P([l,r))$ that returns a list of node-offset intervals corresponding to the intersection of $[l,r)$ with the path coordinates of $P$. Each node-offset interval is represented by a triple $(\\text{id}(v_i), a_i, b_i)$, where $\\text{id}(v_i)$ is a unique integer identifier for node $v_i$, and $[a_i,b_i)$ is the half-open interval of offsets within node $v_i$ corresponding to the overlap of $[l,r)$ with $[S_i,S_{i+1})$, that is $a_i = \\max(0,l-S_i)$ and $b_i = \\min(\\ell(v_i),r-S_i)$ for each $i$ such that $[S_i,S_{i+1}) \\cap [l,r) \\neq \\emptyset$. The output of $\\Phi_P([l,r))$ must list these triples in ascending path order $i=1,\\dots,m$, skipping nodes with empty intersection. For the special case $l=r$, $\\Phi_P([l,r))$ should return an empty list.\n\nIn the presence of bubbles (variant sites), where there exist parallel branches between a split node and a subsequent merge node (for example, edges $(x,a)$ and $(x,b)$ with paths from $a$ and $b$ rejoining at a node $y$), the named reference path $P$ selects exactly one branch among alternatives. The mapping function $\\Phi_P$ must operate strictly along the specified named reference path $P$ and must not include intervals from nodes not present on $P$. Therefore, when $[l,r)$ overlaps a bubble region, $\\Phi_P$ must return only the node-offset intervals that lie on the branch actually traversed by $P$; alternative branches are ignored.\n\nImplement a program that constructs $\\Phi_P$ for the following explicit PRG instance and applies it to a set of test intervals.\n\nGraph instance:\n- Nodes $V=\\{1,2,3,4,5,6,7,8\\}$ with lengths $\\ell(1)=5$, $\\ell(2)=3$, $\\ell(3)=4$, $\\ell(4)=2$, $\\ell(5)=6$, $\\ell(6)=1$, $\\ell(7)=5$, $\\ell(8)=4$.\n- Edges $E=\\{(1,2),(1,3),(2,4),(3,4),(4,5),(5,6),(5,7),(6,8),(7,8)\\}$.\n- Named reference path $\\text{REF}= (1,2,4,5,6,8)$, which has total length $L=5+3+2+6+1+4=21$.\n- For clarity, there is an alternative path $\\text{ALT}=(1,3,4,5,7,8)$ that traverses the other branches of the two bubbles, but your mapping must be computed strictly with respect to $\\text{REF}$.\n\nThe function must return a flattened list of integers for each test case, representing the concatenated triples $[\\text{id}(v_{i_1}), a_{i_1}, b_{i_1}, \\text{id}(v_{i_2}), a_{i_2}, b_{i_2}, \\dots]$ in ascending path order. For example, a single interval mapping consisting of two node-offset intervals $(2,0,3)$ and $(4,0,2)$ must be encoded as $[2,0,3,4,0,2]$.\n\nTest suite:\n- Case $1$: $[l,r)=[4,10)$.\n- Case $2$: $[l,r)=[0,5)$.\n- Case $3$: $[l,r)=[5,7)$.\n- Case $4$: $[l,r)=[19,21)$.\n- Case $5$: $[l,r)=[12,12)$.\n- Case $6$: $[l,r)=[0,21)$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results for the six test cases as a comma-separated list enclosed in square brackets, where each element is the flattened list described above for the corresponding test case, in the same order as listed. For example, the output should be of the form $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$. Each $\\text{result}_i$ must be a list of integers following the flattened triple encoding. No additional text should be printed. Angles or physical units are not involved, and all outputs are dimensionless integers.", "solution": "The user-provided problem is assessed as valid. It is a well-posed, scientifically grounded, and objective problem in bioinformatics. All necessary data and definitions for a unique, verifiable solution are provided.\n\n### Solution Derivation\n\nThe problem requires the implementation of a mapping function, denoted $\\Phi_P$, which transforms a linear coordinate interval $[l,r)$ on a named reference path $P$ into a set of node-offset intervals. The mapping must be performed with respect to a specific Population Reference Graph (PRG) instance and a designated path within it.\n\n#### 1. Path Coordinate System Construction\n\nThe foundation of the mapping is a coordinate system defined along the specified named reference path, $\\text{REF} = (1, 2, 4, 5, 6, 8)$. The path is a sequence of nodes $v_i$ from the graph $G=(V,E)$. The coordinate of any point on the path is its distance from the beginning of the path. The coordinate space occupied by each node $v_i$ is a half-open interval $[S_i, S_{i+1})$, where $S_i$ is the cumulative length of all preceding nodes on the path.\n\nThe provided node lengths are: $\\ell(1)=5$, $\\ell(2)=3$, $\\ell(4)=2$, $\\ell(5)=6$, $\\ell(6)=1$, and $\\ell(8)=4$.\n\nThe cumulative prefix sums $S_i$ for the path $\\text{REF}$ are calculated as follows:\n- The path begins at coordinate $S_1=0$.\n- Node $1$: occupies $[S_1, S_1+\\ell(1)) = [0, 5)$. The next node starts at $S_2 = S_1 + \\ell(1) = 0+5=5$.\n- Node $2$: occupies $[S_2, S_2+\\ell(2)) = [5, 8)$. The next node starts at $S_3 = S_2 + \\ell(2) = 5+3=8$.\n- Node $4$: occupies $[S_3, S_3+\\ell(4)) = [8, 10)$. The next node starts at $S_4 = S_3 + \\ell(4) = 8+2=10$.\n- Node $5$: occupies $[S_4, S_4+\\ell(5)) = [10, 16)$. The next node starts at $S_5 = S_4 + \\ell(5) = 10+6=16$.\n- Node $6$: occupies $[S_5, S_5+\\ell(6)) = [16, 17)$. The next node starts at $S_6 = S_5 + \\ell(6) = 16+1=17$.\n- Node $8$: occupies $[S_6, S_6+\\ell(8)) = [17, 21)$. The path ends at $S_7 = S_6 + \\ell(8) = 17+4=21$.\n\nThe total path length is $L = S_7 = 21$. The correspondence between nodes on path $\\text{REF}$ and their path-level coordinate intervals is summarized below:\n\n| Node ID | Length $\\ell(v_i)$ | Start Coordinate $S_i$ | End Coordinate $S_{i+1}$ | Interval $[S_i, S_{i+1})$ |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $5$ | $0$ | $5$ | $[0, 5)$ |\n| $2$ | $3$ | $5$ | $8$ | $[5, 8)$ |\n| $4$ | $2$ | $8$ | $10$ | $[8, 10)$ |\n| $5$ | $6$ | $10$ | $16$ | $[10, 16)$ |\n| $6$ | $1$ | $16$ | $17$ | $[16, 17)$ |\n| $8$ | $4$ | $17$ | $21$ | $[17, 21)$ |\n\n#### 2. Algorithmic Design of the Mapping Function $\\Phi_P$\n\nThe function $\\Phi_P([l,r))$ maps a linear interval $[l,r)$, where $0 \\le l \\le r \\le L$, to a sequence of node-offset intervals.\n\nFirst, we address the special case where the input interval is empty. The problem specifies that for $l=r$, the function should return an empty list. This is consistent with the definition of a half-open interval $[l,l)$ being the empty set.\n\nFor a non-empty query interval $[l,r)$ (i.e., $lr$), the algorithm iterates through each node $v_i$ of the path $\\text{REF}$. For each node, we determine the portion of the query interval that overlaps with the node's coordinate interval $[S_i, S_{i+1})$.\n\nThe intersection of two half-open intervals, $[l,r)$ and $[S_i, S_{i+1})$, is non-empty if and only if $l  S_{i+1}$ and $S_i  r$. If this condition is not met, the node does not contribute to the mapping of $[l,r)$, and we proceed to the next node.\n\nIf an intersection exists, its representation in the global path coordinate system is given by $[\\max(l, S_i), \\min(r, S_{i+1}))$. To find the corresponding local offset interval $[a_i, b_i)$ within the node $v_i$, we transform these global coordinates by subtracting the node's start coordinate, $S_i$:\n- Start offset: $a_i = \\max(l, S_i) - S_i = \\max(l - S_i, S_i - S_i) = \\max(l - S_i, 0)$.\n- End offset: $b_i = \\min(r, S_{i+1}) - S_i = \\min(r - S_i, S_{i+1} - S_i) = \\min(r - S_i, \\ell(v_i))$.\n\nThese are precisely the formulas provided in the problem statement. A triple $(\\text{id}(v_i), a_i, b_i)$ is generated if and only if the resulting local offset interval is non-empty, which means $a_i  b_i$. This single condition, $a_i  b_i$, elegantly combines the check for intersection with the requirement of a non-empty overlap.\n\nThe algorithm is thus as follows:\n1.  Initialize an empty list for the flattened results.\n2.  Handle the base case: if $l \\ge r$, return the empty list.\n3.  For each node $v_i$ in the ordered path $\\text{REF}$, with its identifier $\\text{id}(v_i)$, length $\\ell(v_i)$, and start coordinate $S_i$:\n    a. Calculate the potential start and end offsets: $a_i = \\max(0, l - S_i)$ and $b_i = \\min(\\ell(v_i), r - S_i)$.\n    b. If $a_i  b_i$, append the triple of integers $(\\text{id}(v_i), a_i, b_i)$ to the result list.\n4.  Return the final flattened list.\n\n#### 3. Application to a Sample Case\n\nLet us apply this algorithm to Test Case $1$: $[l,r) = [4,10)$. Here, $l=4$ and $r=10$.\n\n- **Node 1**: $S_1 = 0$, $\\ell(1) = 5$.\n  - $a_1 = \\max(0, 4 - 0) = 4$.\n  - $b_1 = \\min(5, 10 - 0) = 5$.\n  - Since $4  5$, we add $(1, 4, 5)$.\n- **Node 2**: $S_2 = 5$, $\\ell(2) = 3$.\n  - $a_2 = \\max(0, 4 - 5) = 0$.\n  - $b_2 = \\min(3, 10 - 5) = 3$.\n  - Since $0  3$, we add $(2, 0, 3)$.\n- **Node 4**: $S_3 = 8$, $\\ell(4) = 2$.\n  - $a_3 = \\max(0, 4 - 8) = 0$.\n  - $b_3 = \\min(2, 10 - 8) = 2$.\n  - Since $0  2$, we add $(4, 0, 2)$.\n- **Node 5**: $S_4 = 10$, $\\ell(5) = 6$.\n  - $a_4 = \\max(0, 4 - 10) = 0$.\n  - $b_4 = \\min(6, 10 - 10) = 0$.\n  - Since $a_4 \\not b_4$, this node is skipped.\n- Subsequent nodes are also skipped as their start coordinates $S_i$ are greater than or equal to $r=10$.\n\nThe resulting list of triples is $[(1, 4, 5), (2, 0, 3), (4, 0, 2)]$. Flattening this gives the final integer list: $[1, 4, 5, 2, 0, 3, 4, 0, 2]$. This systematic procedure is applied to all test cases to generate the final output. The implementation will pre-calculate and store the path coordinate information for efficient processing of the test suite.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the graph genome coordinate mapping problem.\n    \"\"\"\n    \n    # ------------------ GIVENS FROM THE PROBLEM STATEMENT ------------------\n    \n    # Node lengths as a dictionary: {node_id: length}\n    node_lengths = {\n        1: 5, 2: 3, 3: 4, 4: 2, 5: 6, 6: 1, 7: 5, 8: 4\n    }\n    \n    # The named reference path as a sequence of node IDs.\n    ref_path_nodes = [1, 2, 4, 5, 6, 8]\n    \n    # The test suite of linear genomic intervals [l, r).\n    test_cases = [\n        (4, 10),    # Case 1\n        (0, 5),     # Case 2\n        (5, 7),     # Case 3\n        (19, 21),   # Case 4\n        (12, 12),   # Case 5\n        (0, 21),    # Case 6\n    ]\n\n    # ------------------ PRE-PROCESSING: BUILD PATH COORDINATES ------------------\n    \n    # Store path information as a list of dictionaries for clarity.\n    # Each entry contains the node's ID, length, and start coordinate on the path.\n    path_info = []\n    current_coord = 0\n    for node_id in ref_path_nodes:\n        length = node_lengths[node_id]\n        path_info.append({\n            'id': node_id,\n            'len': length,\n            'start': current_coord\n        })\n        current_coord += length\n\n    # ------------------ MAPPING FUNCTION AND EXECUTION ------------------\n\n    def map_interval_to_path(l, r, path_data):\n        \"\"\"\n        Implements the mapping function Phi_P([l,r)).\n        \n        Args:\n            l (int): The start of the linear interval.\n            r (int): The end of the linear interval.\n            path_data (list): Pre-processed data for the reference path.\n            \n        Returns:\n            list: A flattened list of integers representing the node-offset intervals.\n        \"\"\"\n        # Per problem spec, for l=r, return an empty list.\n        # This condition also robustly handles l > r.\n        if l >= r:\n            return []\n            \n        result_flat = []\n        for node in path_data:\n            node_id = node['id']\n            node_len = node['len']\n            node_start = node['start']\n            \n            # Calculate the local offsets a_i and b_i based on the provided formulas.\n            # a_i = max(0, l - S_i)\n            # b_i = min(ell(v_i), r - S_i)\n            a_i = max(0, l - node_start)\n            b_i = min(node_len, r - node_start)\n            \n            # A non-empty intersection exists if and only if a_i  b_i.\n            # This check correctly identifies nodes that overlap with the query interval.\n            if a_i  b_i:\n                result_flat.extend([node_id, a_i, b_i])\n                \n        return result_flat\n\n    results = []\n    for l_val, r_val in test_cases:\n        mapped_intervals = map_interval_to_path(l_val, r_val, path_info)\n        results.append(mapped_intervals)\n\n    # ------------------ FINAL OUTPUT FORMATTING ------------------\n\n    # Format the list of lists into the required string format:\n    # e.g., [[1,4,5],[2,0,1]] -> \"[[1,4,5],[2,0,1]]\"\n    # The str() representation of a list in Python is used, with spaces removed.\n    formatted_results = [str(res).replace(\" \", \"\") for res in results]\n    \n    # Print the final output in the exact single-line format.\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n\n```", "id": "4569927"}, {"introduction": "One of the key applications of graph genomes is to mitigate reference bias by aligning sequences to a model that includes population-level variation. This exercise delves into the core algorithm for this task: Partial Order Alignment (POA). You will apply the principles of dynamic programming to align a short read to a small directed acyclic graph, calculating the optimal alignment score and identifying the best-matching haplotype path [@problem_id:4569880].", "problem": "Consider a small Population Reference Graph (PRG) modeled as a Directed Acyclic Graph (DAG), where each node is labeled by a single deoxyribonucleic acid (DNA) base from the alphabet $\\{A,C,G,T\\}$. The graph encodes population variation at a locus as alternative paths. Let the node set be $\\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7}\\}$ with labels given by the function $L:\\{v_{i}\\}\\to\\{A,C,G,T\\}$:\n- $L(v_{1})=A$, $L(v_{2})=C$, $L(v_{3})=G$, $L(v_{4})=T$, $L(v_{5})=A$, $L(v_{6})=C$, $L(v_{7})=G$.\nThe directed edge set is\n$$\nE=\\{(v_{1},v_{2}),\\,(v_{2},v_{4}),\\,(v_{4},v_{7}),\\,(v_{1},v_{3}),\\,(v_{3},v_{4}),\\,(v_{1},v_{2}),\\,(v_{2},v_{5}),\\,(v_{5},v_{7}),\\,(v_{3},v_{6}),\\,(v_{6},v_{7})\\},\n$$\nso that all root-to-terminal paths have length $4$ and yield the path strings $P_{1}=\\text{``ACTG''}$ (via $v_{1}\\to v_{2}\\to v_{4}\\to v_{7}$), $P_{2}=\\text{``AGTG''}$ (via $v_{1}\\to v_{3}\\to v_{4}\\to v_{7}$), $P_{3}=\\text{``ACAG''}$ (via $v_{1}\\to v_{2}\\to v_{5}\\to v_{7}$), and $P_{4}=\\text{``AGCG''}$ (via $v_{1}\\to v_{3}\\to v_{6}\\to v_{7}$).\n\nYou are given a patient read $S=\\text{``ATCG''}$ to align globally to the PRG using Partial Order Alignment (POA). Use a linear scoring scheme: match score $+1$, mismatch penalty $-1$, and gap (insertion or deletion) penalty $-1$ per gap character. Assume global alignment to a single root-to-terminal path with no soft clipping, and that gaps (insertions in $S$ or deletions against the graph path) are allowed anywhere as needed.\n\nStarting only from definitions of sequence alignment scoring and dynamic programming on directed acyclic graphs (topological order and predecessor relations), determine the optimal global alignment score of $S$ to the PRG under POA and identify the path in the graph that attains this score. Express the final score as a pure real number with no units. If multiple paths achieve the same score, any one may be reported. No rounding is required. The final numeric answer must be the optimal score only (the aligned path should be reported in your reasoning, not in the final boxed answer).", "solution": "The user wants to find the optimal global alignment score of a sequence to a Population Reference Graph (PRG) using Partial Order Alignment (POA).\n\n### Step 1: Extract Givens\n-   **Graph Model**: A Directed Acyclic Graph (DAG).\n-   **Node Set**: $V = \\{v_{1},v_{2},v_{3},v_{4},v_{5},v_{6},v_{7}\\}$.\n-   **Node Labels**: A function $L: V \\to \\{A,C,G,T\\}$ with the following values:\n    -   $L(v_{1})=A$\n    -   $L(v_{2})=C$\n    -   $L(v_{3})=G$\n    -   $L(v_{4})=T$\n    -   $L(v_{5})=A$\n    -   $L(v_{6})=C$\n    -   $L(v_{7})=G$\n-   **Edge Set**: $E=\\{(v_{1},v_{2}),\\,(v_{2},v_{4}),\\,(v_{4},v_{7}),\\,(v_{1},v_{3}),\\,(v_{3},v_{4}),\\,(v_{2},v_{5}),\\,(v_{5},v_{7}),\\,(v_{3},v_{6}),\\,(v_{6},v_{7})\\}$. Note: the problem lists $(v_1,v_2)$ twice, which is a redundant statement for a set and does not affect the graph structure.\n-   **Given Paths**:\n    -   $P_{1}: v_{1}\\to v_{2}\\to v_{4}\\to v_{7}$ (sequence ``ACTG'')\n    -   $P_{2}: v_{1}\\to v_{3}\\to v_{4}\\to v_{7}$ (sequence ``AGTG'')\n    -   $P_{3}: v_{1}\\to v_{2}\\to v_{5}\\to v_{7}$ (sequence ``ACAG'')\n    -   $P_{4}: v_{1}\\to v_{3}\\to v_{6}\\to v_{7}$ (sequence ``AGCG'')\n-   **Patient Read**: $S=\\text{``ATCG''}$. Let the length of $S$ be $m=4$, so $S = s_1s_2s_3s_4$.\n-   **Scoring Scheme**:\n    -   Match score: $+1$\n    -   Mismatch penalty: $-1$\n    -   Gap penalty (insertion or deletion): $-1$ per character.\n-   **Task**: Find the optimal global alignment score of $S$ to the PRG using POA and identify the corresponding path. Global alignment is specified to be from a single root to a single terminal node.\n\n### Step 2: Validate Using Extracted Givens\n-   **Scientific Grounding**: The problem is well-grounded in bioinformatics. Partial Order Alignment onto a graph representation of population variation (a PRG) is a standard computational problem. The scoring scheme is a common linear gap penalty model.\n-   **Well-Posedness**: The problem is well-posed. The graph is a DAG, ensuring the dynamic programming algorithm will terminate. The scoring function is clearly defined. The objective is to find a maximum score, which is guaranteed to exist.\n-   **Consistency and Completeness**: The problem is self-contained. It provides the graph structure, node labels, the sequence to be aligned, and the full scoring scheme. The stated paths and their corresponding sequences are consistent with the graph definition. The root node is $v_1$ and the terminal node is $v_7$. The statement \"all root-to-terminal paths have length $4$\" refers to the number of nodes in the path, which is consistent with the provided examples. The redundant edge in the edge set definition does not create a contradiction.\n\n### Step 3: Verdict and Action\nThe problem is valid. The solution will be derived using dynamic programming on the given DAG.\n\n### Solution Derivation\nThe problem requires performing a Partial Order Alignment (POA), which generalizes the Needleman-Wunsch algorithm for sequence-to-sequence alignment to sequence-to-graph alignment. We will use a dynamic programming approach. The nodes of the graph must be processed in a topological order. A valid topological sort of the given DAG is $(v_1, v_2, v_3, v_4, v_5, v_6, v_7)$.\n\nLet $M(i, j)$ be the maximum score for aligning the prefix $S[1..i]$ of the sequence $S$ with a path in the PRG that ends at node $v_j$. The sequence is $S=\\text{``ATCG''}$, so $s_1=A, s_2=T, s_3=C, s_4=G$.\n\nThe general recurrence relation for $M(i, j)$ is:\n$$\nM(i, j) = \\max \\begin{cases} M(i-1, j) + g  \\text{(Insertion in graph, gap in path)} \\\\ \\max_{v_k \\in \\text{Pred}(v_j)} \\{ M(i, k) \\} + g  \\text{(Deletion from graph, gap in sequence)} \\\\ \\max_{v_k \\in \\text{Pred}(v_j)} \\{ M(i-1, k) \\} + \\sigma(s_i, L(v_j))  \\text{(Match/Mismatch)} \\end{cases}\n$$\nwhere $g=-1$ is the gap penalty, $\\text{Pred}(v_j)$ is the set of predecessor nodes of $v_j$, and $\\sigma(a, b)$ is the score for aligning characters $a$ and $b$ ($+1$ for match, $-1$ for mismatch). For the root node $v_1$, which has no predecessors in the graph, we consider it to be preceded by a virtual start node, where the score of an alignment of a prefix $S[1..i]$ to an empty path is $i \\times g$.\n\nWe construct a DP table of size $(m+1) \\times |V| = 5 \\times 7$.\n\n**Initialization:**\n-   **Row $i=0$:** Aligning an empty string to paths ending at each node $v_j$. This is equivalent to deleting the path from the root to $v_j$. The score is the negative of the path length.\n    -   $M(0, 1) = -1$ (path \"A\", length $1$)\n    -   $M(0, 2) = -2$ (path \"AC\", length $2$)\n    -   $M(0, 3) = -2$ (path \"AG\", length $2$)\n    -   $M(0, 4) = -3$ (paths \"ACT\" or \"AGT\", length $3$)\n    -   $M(0, 5) = -3$ (path \"ACA\", length $3$)\n    -   $M(0, 6) = -3$ (path \"AGC\", length $3$)\n    -   $M(0, 7) = -4$ (all paths have length $4$)\n-   **Column for virtual start node:** The cost of aligning $S[1..i]$ with an empty path is $i$ insertions. $M(i, \\text{start}) = i \\times g = -i$. This is used for initializing the calculation at root node $v_1$.\n\n**DP Table Calculation:**\nWe fill the table row by row for $i = 1, \\dots, 4$. Within each row, we compute scores for nodes $v_j$ in topological order. Let's denote $M(i,j)$ by `Score[i][j]`.\n\n**For $i=1$ ($s_1 = A$):**\n-   $M(1, 1) = \\max(M(0, 1)-1, M(1, \\text{start})-1, M(0, \\text{start})+\\sigma(A,A)) = \\max(-1-1, -1-1, 0+1) = 1$.\n-   $M(1, 2) = \\max(M(0, 2)-1, M(1, 1)-1, M(0, 1)+\\sigma(A,C)) = \\max(-2-1, 1-1, -1-1) = 0$.\n-   $M(1, 3) = \\max(M(0, 3)-1, M(1, 1)-1, M(0, 1)+\\sigma(A,G)) = \\max(-2-1, 1-1, -1-1) = 0$.\n-   $M(1, 4) = \\max(M(0, 4)-1, \\max(M(1,2),M(1,3))-1, \\max(M(0,2),M(0,3))+\\sigma(A,T)) = \\max(-3-1, \\max(0,0)-1, -2-1) = -1$.\n-   $M(1, 5) = \\max(M(0, 5)-1, M(1, 2)-1, M(0, 2)+\\sigma(A,A)) = \\max(-3-1, 0-1, -2+1) = -1$.\n-   $M(1, 6) = \\max(M(0, 6)-1, M(1, 3)-1, M(0, 3)+\\sigma(A,C)) = \\max(-3-1, 0-1, -2-1) = -1$.\n-   $M(1, 7) = \\max(M(0, 7)-1, \\max(M(1,4),M(1,5),M(1,6))-1, \\max(M(0,4),M(0,5),M(0,6))+\\sigma(A,G)) = \\max(-4-1, -1-1, -3-1) = -2$.\n\n**For $i=2$ ($s_2 = T$):**\n-   $M(2, 1) = \\max(M(1, 1)-1, M(2, \\text{start})-1, M(1, \\text{start})+\\sigma(T,A)) = \\max(1-1, -2-1, -1-1) = 0$.\n-   $M(2, 2) = \\max(M(1, 2)-1, M(2, 1)-1, M(1, 1)+\\sigma(T,C)) = \\max(0-1, 0-1, 1-1) = 0$.\n-   $M(2, 3) = \\max(M(1, 3)-1, M(2, 1)-1, M(1, 1)+\\sigma(T,G)) = \\max(0-1, 0-1, 1-1) = 0$.\n-   $M(2, 4) = \\max(M(1, 4)-1, \\max(M(2,2),M(2,3))-1, \\max(M(1,2),M(1,3))+\\sigma(T,T)) = \\max(-1-1, 0-1, 0+1) = 1$.\n-   $M(2, 5) = \\max(M(1, 5)-1, M(2, 2)-1, M(1, 2)+\\sigma(T,A)) = \\max(-1-1, 0-1, 0-1) = -1$.\n-   $M(2, 6) = \\max(M(1, 6)-1, M(2, 3)-1, M(1, 3)+\\sigma(T,C)) = \\max(-1-1, 0-1, 0-1) = -1$.\n-   $M(2, 7) = \\max(M(1, 7)-1, \\max(M(2,4),M(2,5),M(2,6))-1, \\max(M(1,4),M(1,5),M(1,6))+\\sigma(T,G)) = \\max(-2-1, 1-1, -1-1) = 0$.\n\n**For $i=3$ ($s_3 = C$):**\n-   $M(3, 1) = \\max(M(2, 1)-1, M(3, \\text{start})-1, M(2, \\text{start})+\\sigma(C,A)) = \\max(0-1, -3-1, -2-1) = -1$.\n-   $M(3, 2) = \\max(M(2, 2)-1, M(3, 1)-1, M(2, 1)+\\sigma(C,C)) = \\max(0-1, -1-1, 0+1) = 1$.\n-   $M(3, 3) = \\max(M(2, 3)-1, M(3, 1)-1, M(2, 1)+\\sigma(C,G)) = \\max(0-1, -1-1, 0-1) = -1$.\n-   $M(3, 4) = \\max(M(2, 4)-1, \\max(M(3,2),M(3,3))-1, \\max(M(2,2),M(2,3))+\\sigma(C,T)) = \\max(1-1, 1-1, 0-1) = 0$.\n-   $M(3, 5) = \\max(M(2, 5)-1, M(3, 2)-1, M(2, 2)+\\sigma(C,A)) = \\max(-1-1, 1-1, 0-1) = 0$.\n-   $M(3, 6) = \\max(M(2, 6)-1, M(3, 3)-1, M(2, 3)+\\sigma(C,C)) = \\max(-1-1, -1-1, 0+1) = 1$.\n-   $M(3, 7) = \\max(M(2, 7)-1, \\max(M(3,4),M(3,5),M(3,6))-1, \\max(M(2,4),M(2,5),M(2,6))+\\sigma(C,G)) = \\max(0-1, 1-1, 1-1) = 0$.\n\n**For $i=4$ ($s_4 = G$):**\n-   $M(4, 1) = \\max(M(3, 1)-1, M(4, \\text{start})-1, M(3, \\text{start})+\\sigma(G,A)) = \\max(-1-1, -4-1, -3-1) = -2$.\n-   $M(4, 2) = \\max(M(3, 2)-1, M(4, 1)-1, M(3, 1)+\\sigma(G,C)) = \\max(1-1, -2-1, -1-1) = 0$.\n-   $M(4, 3) = \\max(M(3, 3)-1, M(4, 1)-1, M(3, 1)+\\sigma(G,G)) = \\max(-1-1, -2-1, -1+1) = 0$.\n-   $M(4, 4) = \\max(M(3, 4)-1, \\max(M(4,2),M(4,3))-1, \\max(M(3,2),M(3,3))+\\sigma(G,T)) = \\max(0-1, 0-1, 1-1) = 0$.\n-   $M(4, 5) = \\max(M(3, 5)-1, M(4, 2)-1, M(3, 2)+\\sigma(G,A)) = \\max(0-1, 0-1, 1-1) = 0$.\n-   $M(4, 6) = \\max(M(3, 6)-1, M(4, 3)-1, M(3, 3)+\\sigma(G,C)) = \\max(1-1, 0-1, -1-1) = 0$.\n-   $M(4, 7) = \\max(M(3, 7)-1, \\max(M(4,4),M(4,5),M(4,6))-1, \\max(M(3,4),M(3,5),M(3,6))+\\sigma(G,G)) = \\max(0-1, 0-1, \\max(0,0,1)+1) = \\max(-1, -1, 1+1) = 2$.\n\n**Final DP Table $M(i, j)$:**\n$$\n\\begin{array}{c|ccccccc}\n\\hline\ni \\setminus v_j  v_1(A)  v_2(C)  v_3(G)  v_4(T)  v_5(A)  v_6(C)  v_7(G) \\\\\n\\hline\n0  -1  -2  -2  -3  -3  -3  -4 \\\\\n1 (\\text{A})  1  0  0  -1  -1  -1  -2 \\\\\n2 (\\text{T})  0  0  0  1  -1  -1  0 \\\\\n3 (\\text{C})  -1  1  -1  0  0  1  0 \\\\\n4 (\\text{G})  -2  0  0  0  0  0  2 \\\\\n\\hline\n\\end{array}\n$$\n\n**Result and Traceback:**\nThe optimal global alignment score is the score in the final row ($i=4$) at the terminal node ($v_7$).\nThe score is $M(4, 7) = 2$.\n\nTo find the path, we trace back from the cell $M(4, 7)$.\n-   $M(4, 7) = 2$ was obtained from the match/mismatch case: $\\max(M(3,4), M(3,5), M(3,6)) + \\sigma(s_4, L(v_7)) = \\max(0, 0, 1) + \\sigma(G, G) = 1 + 1 = 2$. The maximum came from $M(3, 6)$. This means the alignment ends with $s_4 = G$ matching $L(v_7) = G$, and the path came from $v_6$. Path: $\\dots \\to v_6 \\to v_7$.\n-   $M(3, 6) = 1$ was obtained from the match/mismatch case: $M(2, 3) + \\sigma(s_3, L(v_6)) = 0 + \\sigma(C, C) = 0 + 1 = 1$. The path came from $v_3$. Path: $\\dots \\to v_3 \\to v_6 \\to v_7$.\n-   $M(2, 3) = 0$ was obtained from the match/mismatch case: $M(1, 1) + \\sigma(s_2, L(v_3)) = 1 + \\sigma(T, G) = 1 - 1 = 0$. The path came from $v_1$. Path: $v_1 \\to v_3 \\to v_6 \\to v_7$.\n-   $M(1, 1) = 1$ was obtained from the match/mismatch case: $M(0, \\text{start}) + \\sigma(s_1, L(v_1)) = 0 + \\sigma(A, A) = 0 + 1 = 1$. This starts the alignment at the root node $v_1$.\n\nThe optimal path is $v_1 \\to v_3 \\to v_6 \\to v_7$. This corresponds to the graph haplotype $P_4 = \\text{``AGCG''}$.\n\nLet's verify the alignment and score:\nSequence $S$: A T C G\nPath $P_4$:   A G C G\n-   $s_1=A$ vs $L(v_1)=A$: Match, score $+1$.\n-   $s_2=T$ vs $L(v_3)=G$: Mismatch, score $-1$.\n-   $s_3=C$ vs $L(v_6)=C$: Match, score $+1$.\n-   $s_4=G$ vs $L(v_7)=G$: Match, score $+1$.\nTotal score $= 1 - 1 + 1 + 1 = 2$.\nThis confirms the result of the dynamic programming calculation. The optimal global alignment score is $2$.", "answer": "$$\\boxed{2}$$", "id": "4569880"}]}