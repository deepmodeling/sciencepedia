{"hands_on_practices": [{"introduction": "The first and most fundamental challenge in analyzing single-cell RNA-seq data is accounting for variations in sequencing depth, or library size, across cells. A cell with more sequenced molecules will naturally show higher gene counts, which can be mistaken for biological differences. This exercise provides a foundational hands-on look at library-size normalization, a simple yet powerful technique to make expression profiles comparable. By working through this problem [@problem_id:4608308], you will see how scaling counts to a common total can reveal that two cells with vastly different raw counts are, in fact, compositionally identical.", "problem": "A single-cell RNA sequencing (scRNA-seq) experiment produces count vectors for genes in individual cells, where the observed counts are proportional to the underlying transcript composition and the cell-specific library size. Under the standard sampling view, observed counts $x = (x_{1}, \\dots, x_{p})$ in a cell arise from sampling $n$ molecules with gene-wise probabilities $(\\pi_{1}, \\dots, \\pi_{p})$, so that the expected counts satisfy $\\mathbb{E}[x_{i}] = n \\pi_{i}$ and the vector $x$ is proportional to the composition vector $\\pi$ with proportionality factor $n$ (the library size). Library-size normalization (also called counts per $s$ or counts-per-$s$ scaling) seeks a normalized vector that represents gene-wise fractions scaled to a fixed total $s$, so the sum of its entries equals $s$, thereby removing the effect of library size while preserving composition.\n\nConsider two cells with four genes and observed count vectors $x^{(1)} = [100, 50, 0, 350]$ and $x^{(2)} = [200, 100, 0, 700]$. Perform library-size normalization for each cell to a common scale $s = 10^{4}$, ensuring that each normalized vector sums to $10^{4}$. Then, compute the Euclidean distance $D$ between the two normalized vectors. Provide $D$ as the final answer. Do not round; report the exact value. Briefly interpret the result in terms of whether differences between the two cells are attributable to library size versus compositional differences, and discuss the implication for batch correction in single-cell RNA-seq analysis within bioinformatics and medical data analytics.", "solution": "First, we calculate the library size (total counts) for each cell.\nFor cell 1, the library size is $n_1 = \\sum x^{(1)}_i = 100 + 50 + 0 + 350 = 500$.\nFor cell 2, the library size is $n_2 = \\sum x^{(2)}_i = 200 + 100 + 0 + 700 = 1000$.\n\nNext, we perform library-size normalization to a common scale $s = 10^4$. The formula for a normalized count vector $\\tilde{x}$ from a raw count vector $x$ with library size $n$ is:\n$$\n\\tilde{x} = \\frac{x}{n} \\times s\n$$\nApplying this to both cells:\nFor cell 1:\n$$\n\\tilde{x}^{(1)} = \\frac{x^{(1)}}{n_1} \\times 10^4 = \\frac{[100, 50, 0, 350]}{500} \\times 10^4 = [0.2, 0.1, 0, 0.7] \\times 10^4 = [2000, 1000, 0, 7000]\n$$\nFor cell 2:\n$$\n\\tilde{x}^{(2)} = \\frac{x^{(2)}}{n_2} \\times 10^4 = \\frac{[200, 100, 0, 700]}{1000} \\times 10^4 = [0.2, 0.1, 0, 0.7] \\times 10^4 = [2000, 1000, 0, 7000]\n$$\nThe normalized count vectors for both cells are identical: $\\tilde{x}^{(1)} = \\tilde{x}^{(2)}$.\n\nFinally, we compute the Euclidean distance $D$ between the two normalized vectors:\n$$\nD = \\sqrt{\\sum_{i=1}^{4} (\\tilde{x}^{(1)}_i - \\tilde{x}^{(2)}_i)^2} = \\sqrt{(2000-2000)^2 + (1000-1000)^2 + (0-0)^2 + (7000-7000)^2} = \\sqrt{0} = 0\n$$\nThe Euclidean distance is exactly $0$.\n\n**Interpretation**: The result $D=0$ indicates that after accounting for the difference in library size, the two cells have an identical gene expression composition. The apparent differences in the raw counts (e.g., cell 2 having twice the counts of cell 1 for every gene) are entirely attributable to cell 2 having been sequenced to twice the depth of cell 1. This demonstrates the critical importance of normalization: it removes technical artifacts like sequencing depth to reveal the true underlying biological similarity or differences between cells. In a larger analysis, failing to normalize would lead to cells clustering by library size rather than by true cell type, a common pitfall that batch correction and normalization are designed to prevent.", "answer": "$$ \\boxed{0} $$", "id": "4608308"}, {"introduction": "After normalizing individual datasets, the next major challenge is integrating them to correct for batch effects. A primary goal of integration is to mix cells from different batches within shared biological populations, yet we need a way to quantify this mixing. The Local Inverse Simpson's Index (LISI) provides a rigorous, neighborhood-based metric to measure the diversity of labels, such as batch IDs. This practice [@problem_id:4608304] will guide you through the calculation of LISI, giving you a concrete tool to assess the degree of batch mixing in an integrated dataset.", "problem": "In single-cell ribonucleic acid sequencing (single-cell RNA-seq) integration, a central goal is to mix batches while preserving cell-type structure. Consider a local neighborhood of $k$ nearest neighbors around a query cell in an integrated embedding. Let $p_{\\ell}$ denote the empirical proportion of label $\\ell$ among these $k$ neighbors. A widely used, well-tested base measure of diversity, the Simpson concentration index, is defined as $D = \\sum_{\\ell} p_{\\ell}^{2}$, which equals the probability that two labels drawn independently from the local label distribution are the same. The Local Inverse Simpson's Index (LISI) is constructed from this base to quantify local label diversity in the embedding. Define the Local Inverse Simpson's Index (LISI) and explain how it yields the integration Local Inverse Simpson's Index (iLISI) when $\\ell$ indexes batch labels and the cell-type Local Inverse Simpson's Index (cLISI) when $\\ell$ indexes biological cell types.\n\nNow consider a toy neighborhood with $k = 20$ nearest neighbors. The batch label counts in this neighborhood are $n_{A} = 9$ for batch $A$, $n_{B} = 6$ for batch $B$, and $n_{C} = 5$ for batch $C$. Using only these batch labels, compute the LISI for this neighborhood. Round your final numerical answer to four significant figures. No units are required.", "solution": "The Local Inverse Simpson's Index (LISI) quantifies the diversity of labels within a local neighborhood of a cell. It is defined as the reciprocal of the Simpson concentration index, $D$. The Simpson index is the sum of the squared proportions of each label in the neighborhood:\n$$\n\\text{LISI} = \\frac{1}{D} = \\frac{1}{\\sum_{\\ell} p_{\\ell}^{2}}\n$$\nwhere $p_{\\ell}$ is the proportion of cells with label $\\ell$ in the local neighborhood. LISI can be interpreted as the effective number of unique labels in the neighborhood. A higher LISI value indicates greater diversity.\n\nThe distinction between integration LISI (iLISI) and cell-type LISI (cLISI) depends on the labels used:\n*   **iLISI (integration LISI)**: The labels $\\ell$ represent the experimental batches. A high iLISI score is desirable, as it indicates a cell's neighborhood is well-mixed with cells from different batches, signifying successful batch correction.\n*   **cLISI (cell-type LISI)**: The labels $\\ell$ represent biological cell types. A low cLISI score is desirable, indicating that a cell's neighborhood is homogeneous with respect to cell type and that biological structure has been preserved.\n\nNow, we compute the LISI for the given neighborhood's batch labels.\nTotal number of neighbors, $k = 20$.\nBatch label counts: $n_{A} = 9$, $n_{B} = 6$, $n_{C} = 5$.\nThe proportions ($p_{\\ell}$) for each batch are:\n$$\np_A = \\frac{9}{20}, \\quad p_B = \\frac{6}{20}, \\quad p_C = \\frac{5}{20}\n$$\nNext, calculate the Simpson concentration index, $D$:\n$$\nD = p_A^2 + p_B^2 + p_C^2 = \\left(\\frac{9}{20}\\right)^2 + \\left(\\frac{6}{20}\\right)^2 + \\left(\\frac{5}{20}\\right)^2 = \\frac{81}{400} + \\frac{36}{400} + \\frac{25}{400} = \\frac{142}{400}\n$$\nFinally, the LISI is the reciprocal of $D$:\n$$\n\\text{LISI} = \\frac{1}{D} = \\frac{400}{142} = \\frac{200}{71} \\approx 2.8169014...\n$$\nRounding to four significant figures, the LISI for this neighborhood is $2.817$.", "answer": "$$\\boxed{2.817}$$", "id": "4608304"}, {"introduction": "Evaluating data integration is a multi-faceted task that goes beyond simply measuring batch mixing. A successful integration must also preserve the underlying biological structure, ensuring that distinct cell types remain separate and that important biological signals are not erased in the process of removing technical noise. This capstone exercise [@problem_id:4608279] challenges you to build a comprehensive benchmarking suite from the ground up, implementing a panel of metrics to simultaneously assess batch mixing, cell-type separation, and the preservation or removal of specific gene-level effects. This practical coding task simulates the rigorous validation required to trust the results of a complex scRNA-seq analysis.", "problem": "You are given a scenario of integrating single-cell ribonucleic acid sequencing (scRNA-seq) data across two platforms. The goal is to benchmark the integration quality such that platform-induced batch effects are minimized while preserving cell-type structure and platform-specific biological signals. Use the following definitions as the fundamental base:\n\n- scRNA-seq produces count or normalized expression measurements per cell and gene. Let there be $n$ cells and $G$ genes, with observed raw expression matrix $X \\in \\mathbb{R}^{n \\times G}$, corrected expression matrix $\\tilde{X} \\in \\mathbb{R}^{n \\times G}$, integrated embedding $Z \\in \\mathbb{R}^{n \\times d}$, batch labels vector $b \\in \\{0,1\\}^n$, and cell-type labels $y \\in \\{0,1,\\dots,C-1\\}^n$.\n\n- Normalization and batch correction aim to reduce technical variability across platforms while preserving biological variability, particularly cell-type separability. A valid integration should mix platforms within matched cell types in $Z$ while keeping cell-type structure distinct.\n\n- Nearest neighbor reasoning is based on Euclidean distances. For a given cell $i$, the set of $k$ nearest neighbors in $Z$ excluding $i$ is denoted $N_k(i)$, defined by sorting distances and taking the smallest $k$.\n\n- The silhouette coefficient for a cell $i$ quantifies cluster separability from first principles of distances. For a given cell $i$ with label $y_i$, let $a_i$ be the mean Euclidean distance from $i$ to all other cells with label $y_i$, and for each other label $\\ell \\neq y_i$, let $d(i,\\ell)$ be the mean distance from $i$ to all cells with label $\\ell$. Define $b_i = \\min_{\\ell \\neq y_i} d(i,\\ell)$. When both sets are non-empty, the silhouette for $i$ is $s_i = \\dfrac{b_i - a_i}{\\max(a_i,b_i)}$, which lies in $[-1,1]$.\n\n- Preservation of platform-specific biological signals can be quantified by comparing pre-correction and post-correction platform differences for a specified set of genes known to have platform-specific biological variability. For a gene $g$, let $\\mu^{\\text{pre}}_{p,g}$ be the mean of $X$ for platform $p \\in \\{0,1\\}$, and $\\mu^{\\text{post}}_{p,g}$ be the mean of $\\tilde{X}$. Define $D^{\\text{pre}}_g = \\left|\\mu^{\\text{pre}}_{0,g} - \\mu^{\\text{pre}}_{1,g}\\right|$ and $D^{\\text{post}}_g = \\left|\\mu^{\\text{post}}_{0,g} - \\mu^{\\text{post}}_{1,g}\\right|$. With a small constant $\\varepsilon > 0$, the retention ratio for gene $g$ is $r_g = \\dfrac{D^{\\text{post}}_g}{D^{\\text{pre}}_g + \\varepsilon}$. Values close to $1$ indicate preserved platform-specific biological signal, and values close to $0$ indicate overcorrection.\n\n- Conversely, for a set of genes known to be technical-only artifacts, we desire removal of platform differences. For a gene $g$ in this set, the removal ratio is $q_g = 1 - \\dfrac{D^{\\text{post}}_g}{D^{\\text{pre}}_g + \\varepsilon}$, with values close to $1$ indicating successful removal.\n\nDesign and implement a program that, given synthetic test cases, computes four benchmark metrics per test case:\n\n1. Batch mixing within cell types:\n$$\nM = \\dfrac{1}{|\\mathcal{I}|} \\sum_{i \\in \\mathcal{I}} \\dfrac{|\\{j \\in N_k(i) \\,:\\, y_j = y_i \\text{ and } b_j \\neq b_i\\}|}{|\\{j \\in N_k(i) \\,:\\, y_j = y_i\\}|}\n$$\nwhere $\\mathcal{I}$ is the set of indices with at least one same-type neighbor in $N_k(i)$.\n\n2. Cell-type silhouette:\n$$\nS = \\dfrac{1}{n} \\sum_{i=1}^{n} s_i\n$$\nwhere $s_i$ is defined as above, and when same-type or other-type sets are empty the contribution is defined as $0$.\n\n3. Platform-specific biological retention:\n$$\nR = \\dfrac{1}{|G_{\\text{bio}}|} \\sum_{g \\in G_{\\text{bio}}} r_g\n$$\n\n4. Technical artifact removal:\n$$\nT = \\dfrac{1}{|G_{\\text{tech}}|} \\sum_{g \\in G_{\\text{tech}}} q_g\n$$\n\nUse $\\varepsilon = 10^{-8}$ and Euclidean distances. Use $k = 3$ neighbors.\n\nYour program must evaluate the following four test cases. Each case provides $(Z, X, \\tilde{X}, b, y, G_{\\text{bio}}, G_{\\text{tech}})$.\n\nTest Case $1$ (happy path, two platforms, two cell types, good mixing, good preservation of platform-specific biology, and removal of technical artifacts):\n\n- $n = 12$, $d = 2$, $G = 5$, $C = 2$.\n- Batches: $b^{(1)} = [\\,0,0,0,0,0,0,1,1,1,1,1,1\\,]$.\n- Cell types: $y^{(1)} = [\\,0,0,0,1,1,1,0,0,0,1,1,1\\,]$.\n- Embedding:\n$$\nZ^{(1)} = \\begin{bmatrix}\n0.00 & 0.00 \\\\\n0.05 & -0.02 \\\\\n-0.03 & 0.04 \\\\\n5.00 & 5.00 \\\\\n4.95 & 4.98 \\\\\n5.02 & 5.04 \\\\\n0.10 & 0.00 \\\\\n0.12 & -0.02 \\\\\n0.08 & 0.03 \\\\\n5.10 & 5.00 \\\\\n5.08 & 4.97 \\\\\n5.12 & 5.05\n\\end{bmatrix}.\n$$\n- Raw expression $X^{(1)}$ per cell and gene: for type $0$ cells (indices $0,1,2,6,7,8$) set gene $0$ to $10$, gene $1$ to $3$, gene $2$ to $4$ if platform $0$ or $9$ if platform $1$, gene $3$ to $2$ if platform $0$ or $8$ if platform $1$, gene $4$ to $1$; for type $1$ cells (indices $3,4,5,9,10,11$) set gene $0$ to $2$, gene $1$ to $12$, gene $2$ by platform as above ($4$ if platform $0$, $9$ if platform $1$), gene $3$ by platform as above ($2$ if platform $0$, $8$ if platform $1$), gene $4$ to $1$.\n- Corrected expression $\\tilde{X}^{(1)}$: identical to $X^{(1)}$ except gene $3$ is set to $5$ for all cells; gene $2$ remains platform-specific ($4$ versus $9$).\n- Platform-specific biology genes: $G_{\\text{bio}}^{(1)} = \\{2\\}$.\n- Technical artifact genes: $G_{\\text{tech}}^{(1)} = \\{3\\}$.\n\nTest Case $2$ (overcorrection of platform-specific biology while removing technical artifacts):\n\n- Use the same $n, d, G, C$, $b^{(2)} = b^{(1)}$, $y^{(2)} = y^{(1)}$, and $Z^{(2)} = Z^{(1)}$, and $X^{(2)} = X^{(1)}$.\n- Corrected expression $\\tilde{X}^{(2)}$: identical to $X^{(1)}$ except genes $2$ and $3$ are set to constants across platforms, with gene $2$ set to $6$ for all cells and gene $3$ set to $5$ for all cells.\n- Platform-specific biology genes: $G_{\\text{bio}}^{(2)} = \\{2\\}$.\n- Technical artifact genes: $G_{\\text{tech}}^{(2)} = \\{3\\}$.\n\nTest Case $3$ (undercorrection, poor mixing across platforms, retention of platform-specific biology, and failure to remove technical artifacts):\n\n- $n = 12$, $d = 2$, $G = 5$, $C = 2$.\n- Batches: $b^{(3)} = [\\,0,0,0,0,0,0,1,1,1,1,1,1\\,]$.\n- Cell types: $y^{(3)} = [\\,0,0,0,1,1,1,0,0,0,1,1,1\\,]$.\n- Embedding:\n$$\nZ^{(3)} = \\begin{bmatrix}\n0.00 & 0.00 \\\\\n0.04 & -0.03 \\\\\n-0.02 & 0.02 \\\\\n5.00 & 5.00 \\\\\n4.94 & 5.03 \\\\\n5.06 & 4.96 \\\\\n2.00 & 0.00 \\\\\n2.10 & -0.05 \\\\\n1.95 & 0.06 \\\\\n7.00 & 5.00 \\\\\n7.05 & 4.95 \\\\\n6.95 & 5.04\n\\end{bmatrix}.\n$$\n- Raw expression $X^{(3)} = X^{(1)}$.\n- Corrected expression $\\tilde{X}^{(3)}$: identical to $X^{(1)}$ (no correction of gene $3$, gene $2$ remains platform-specific).\n- Platform-specific biology genes: $G_{\\text{bio}}^{(3)} = \\{2\\}$.\n- Technical artifact genes: $G_{\\text{tech}}^{(3)} = \\{3\\}$.\n\nTest Case $4$ (boundary case with minimal cells per type and platform):\n\n- $n = 4$, $d = 2$, $G = 5$, $C = 2$.\n- Batches: $b^{(4)} = [\\,0,0,1,1\\,]$.\n- Cell types: $y^{(4)} = [\\,0,1,0,1\\,]$.\n- Embedding:\n$$\nZ^{(4)} = \\begin{bmatrix}\n0.00 & 0.00 \\\\\n5.00 & 5.00 \\\\\n0.09 & -0.01 \\\\\n5.08 & 4.98\n\\end{bmatrix}.\n$$\n- Raw expression $X^{(4)}$: for type $0$ cells (indices $0,2$) set gene $0$ to $10$, gene $1$ to $3$, gene $2$ to $4$ if platform $0$ or $9$ if platform $1$, gene $3$ to $2$ if platform $0$ or $8$ if platform $1$, gene $4$ to $1$; for type $1$ cells (indices $1,3$) set gene $0$ to $2$, gene $1$ to $12$, gene $2$ to $4$ if platform $0$ or $9$ if platform $1$, gene $3$ to $2$ if platform $0$ or $8$ if platform $1$, gene $4$ to $1$.\n- Corrected expression $\\tilde{X}^{(4)}$: identical to $X^{(4)}$ except gene $3$ is set to $5$ for all cells; gene $2$ remains platform-specific.\n- Platform-specific biology genes: $G_{\\text{bio}}^{(4)} = \\{2\\}$.\n- Technical artifact genes: $G_{\\text{tech}}^{(4)} = \\{3\\}$.\n\nAngle units are not involved. There are no physical units. All ratios must be reported as decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a list $[M,S,R,T]$ of four floats in that order; for example, an output for two test cases would look like $[[m_1,s_1,r_1,t_1],[m_2,s_2,r_2,t_2]]$ but your program must include all four specified test cases.", "solution": "The solution requires implementing a Python program that computes four distinct metrics for each of the four test cases provided. The metrics are designed to quantify different aspects of single-cell data integration quality. The overall approach is to create a function that takes the data for a single test case and computes the four metrics: Batch Mixing ($M$), Cell-Type Silhouette ($S$), Biological Retention ($R$), and Technical Removal ($T$). This function is then called for each test case.\n\nThe implementation logic for each metric is as follows:\n1.  **Batch Mixing ($M$)**: For each cell, we first identify its $k=3$ nearest neighbors in the integrated embedding $Z$. Then, we filter these neighbors to find those that share the same cell type. The mixing score for the cell is the fraction of these same-type neighbors that come from a different batch. The final metric $M$ is the average of these scores over all cells that have at least one same-type neighbor.\n2.  **Cell-Type Silhouette ($S$)**: This is a direct implementation of the silhouette score formula for each cell, using cell-type labels. For each cell $i$, we calculate $a_i$ (the mean distance to other cells of the same type) and $b_i$ (the minimum of the mean distances to cells of each other type). The silhouette score $s_i = (b_i - a_i) / \\max(a_i, b_i)$ is computed, with special handling for cases where clusters are empty. The final metric $S$ is the average of these scores over all cells.\n3.  **Biological Retention ($R$)**: This metric is calculated for genes in the set $G_{\\text{bio}}$. For each such gene, we compute the absolute difference in mean expression between the two platforms before correction ($D^{\\text{pre}}_g$) and after correction ($D^{\\text{post}}_g$). The retention ratio for the gene is $r_g = D^{\\text{post}}_g / (D^{\\text{pre}}_g + \\varepsilon)$. The final metric $R$ is the average of these ratios.\n4.  **Technical Removal ($T$)**: This metric is calculated similarly to $R$, but for genes in the set $G_{\\text{tech}}$. The removal ratio for each gene is $q_g = 1 - (D^{\\text{post}}_g / (D^{\\text{pre}}_g + \\varepsilon))$. The final metric $T$ is the average of these ratios.\n\nThe Python code will use the `numpy` library for efficient numerical computations, especially for distance calculations and matrix operations. The final output will be a formatted string containing a list of lists, where each inner list holds the four computed metric values for a test case.", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(Z, X, X_tilde, b, y, G_bio, G_tech, k, epsilon):\n    \"\"\"\n    Calculates the four benchmark metrics for a single test case.\n    \"\"\"\n    n = Z.shape[0]\n\n    # Metric 1: Batch mixing (M)\n    mixing_ratios = []\n    for i in range(n):\n        distances = np.linalg.norm(Z - Z[i], axis=1)\n        # Get indices of k nearest neighbors, excluding self\n        neighbor_indices = np.argsort(distances)[1:k+1]\n\n        same_type_neighbors = [j for j in neighbor_indices if y[j] == y[i]]\n        \n        if not same_type_neighbors:\n            continue\n\n        mixed_batch_neighbors = [j for j in same_type_neighbors if b[j] != b[i]]\n        \n        ratio = len(mixed_batch_neighbors) / len(same_type_neighbors)\n        mixing_ratios.append(ratio)\n        \n    M = np.mean(mixing_ratios) if mixing_ratios else 0.0\n\n    # Metric 2: Cell-type silhouette (S)\n    silhouette_scores = []\n    unique_labels = np.unique(y)\n    for i in range(n):\n        # Intra-cluster distance a_i\n        same_type_indices = np.where((y == y[i])  (np.arange(n) != i))[0]\n        if same_type_indices.size == 0:\n            silhouette_scores.append(0)\n            continue\n        a_i = np.mean(np.linalg.norm(Z[same_type_indices] - Z[i], axis=1))\n\n        # Inter-cluster distance b_i\n        other_labels = [l for l in unique_labels if l != y[i]]\n        if not other_labels:\n            silhouette_scores.append(0)\n            continue\n            \n        mean_other_distances = []\n        for l in other_labels:\n            other_type_indices = np.where(y == l)[0]\n            if other_type_indices.size > 0:\n                dist = np.mean(np.linalg.norm(Z[other_type_indices] - Z[i], axis=1))\n                mean_other_distances.append(dist)\n        \n        if not mean_other_distances:\n            b_i = 0\n        else:\n            b_i = np.min(mean_other_distances)\n\n        denominator = max(a_i, b_i)\n        if denominator == 0:\n            s_i = 0\n        else:\n            s_i = (b_i - a_i) / denominator\n        silhouette_scores.append(s_i)\n\n    S = np.mean(silhouette_scores) if silhouette_scores else 0.0\n\n    # Metrics 3  4 (R and T)\n    p0_mask = (b == 0)\n    p1_mask = (b == 1)\n\n    # Metric 3: Biological Retention (R)\n    retention_ratios = []\n    for g in G_bio:\n        mu_pre_0 = np.mean(X[p0_mask, g])\n        mu_pre_1 = np.mean(X[p1_mask, g])\n        d_pre = np.abs(mu_pre_0 - mu_pre_1)\n        \n        mu_post_0 = np.mean(X_tilde[p0_mask, g])\n        mu_post_1 = np.mean(X_tilde[p1_mask, g])\n        d_post = np.abs(mu_post_0 - mu_post_1)\n        \n        r_g = d_post / (d_pre + epsilon)\n        retention_ratios.append(r_g)\n    \n    R = np.mean(retention_ratios) if retention_ratios else 0.0\n    \n    # Metric 4: Technical Removal (T)\n    removal_ratios = []\n    for g in G_tech:\n        mu_pre_0 = np.mean(X[p0_mask, g])\n        mu_pre_1 = np.mean(X[p1_mask, g])\n        d_pre = np.abs(mu_pre_0 - mu_pre_1)\n        \n        mu_post_0 = np.mean(X_tilde[p0_mask, g])\n        mu_post_1 = np.mean(X_tilde[p1_mask, g])\n        d_post = np.abs(mu_post_0 - mu_post_1)\n\n        q_g = 1 - (d_post / (d_pre + epsilon))\n        removal_ratios.append(q_g)\n        \n    T = np.mean(removal_ratios) if removal_ratios else 0.0\n\n    return [M, S, R, T]\n\ndef build_expression_matrix(n, G, b, y):\n    X = np.zeros((n, G))\n    for i in range(n):\n        is_type0 = (y[i] == 0)\n        is_p0 = (b[i] == 0)\n        if is_type0:\n            X[i, 0], X[i, 1], X[i, 4] = 10, 3, 1\n        else: # type 1\n            X[i, 0], X[i, 1], X[i, 4] = 2, 12, 1\n        \n        X[i, 2] = 4 if is_p0 else 9\n        X[i, 3] = 2 if is_p0 else 8\n    return X\n\n\ndef solve():\n    k = 3\n    epsilon = 1e-8\n\n    # Test Case 1\n    b1 = np.array([0,0,0,0,0,0,1,1,1,1,1,1])\n    y1 = np.array([0,0,0,1,1,1,0,0,0,1,1,1])\n    Z1 = np.array([\n        [0.00, 0.00], [0.05, -0.02], [-0.03, 0.04], [5.00, 5.00], [4.95, 4.98],\n        [5.02, 5.04], [0.10, 0.00], [0.12, -0.02], [0.08, 0.03], [5.10, 5.00],\n        [5.08, 4.97], [5.12, 5.05]\n    ])\n    X1 = build_expression_matrix(12, 5, b1, y1)\n    X_tilde1 = X1.copy()\n    X_tilde1[:, 3] = 5\n    G_bio1 = [2]\n    G_tech1 = [3]\n    \n    # Test Case 2\n    Z2, X2, b2, y2, G_bio2, G_tech2 = Z1, X1, b1, y1, G_bio1, G_tech1\n    X_tilde2 = X2.copy()\n    X_tilde2[:, 2] = 6\n    X_tilde2[:, 3] = 5\n\n    # Test Case 3\n    b3 = np.array([0,0,0,0,0,0,1,1,1,1,1,1])\n    y3 = np.array([0,0,0,1,1,1,0,0,0,1,1,1])\n    Z3 = np.array([\n        [0.00, 0.00], [0.04, -0.03], [-0.02, 0.02], [5.00, 5.00], [4.94, 5.03],\n        [5.06, 4.96], [2.00, 0.00], [2.10, -0.05], [1.95, 0.06], [7.00, 5.00],\n        [7.05, 4.95], [6.95, 5.04]\n    ])\n    X3 = build_expression_matrix(12, 5, b3, y3)\n    X_tilde3 = X3.copy()\n    G_bio3 = [2]\n    G_tech3 = [3]\n\n    # Test Case 4\n    b4 = np.array([0,0,1,1])\n    y4 = np.array([0,1,0,1])\n    Z4 = np.array([[0.00, 0.00], [5.00, 5.00], [0.09, -0.01], [5.08, 4.98]])\n    X4 = build_expression_matrix(4, 5, b4, y4)\n    X_tilde4 = X4.copy()\n    X_tilde4[:, 3] = 5\n    G_bio4 = [2]\n    G_tech4 = [3]\n\n    test_cases = [\n        (Z1, X1, X_tilde1, b1, y1, G_bio1, G_tech1),\n        (Z2, X2, X_tilde2, b2, y2, G_bio2, G_tech2),\n        (Z3, X3, X_tilde3, b3, y3, G_bio3, G_tech3),\n        (Z4, X4, X_tilde4, b4, y4, G_bio4, G_tech4),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_metrics(*case, k=k, epsilon=epsilon)\n        results.append(result)\n\n    # Format output as a string representing a list of lists, without extra spaces\n    results_str = [f\"[{','.join(f'{x:.8f}' for x in r)}]\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "4608279"}]}