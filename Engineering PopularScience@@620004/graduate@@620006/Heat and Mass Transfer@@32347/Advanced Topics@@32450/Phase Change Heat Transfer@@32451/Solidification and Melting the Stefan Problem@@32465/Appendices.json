{"hands_on_practices": [{"introduction": "Many diffusion-controlled phenomena, including solidification in idealized settings, lack a characteristic time or length scale. This property allows for a powerful analytical technique known as the similarity solution, which can reduce the governing partial differential equation to a more manageable ordinary differential equation. This practice [@problem_id:2523101] provides a rigorous exercise in applying the similarity method to determine the complete solidification time for a finite slab, reinforcing the fundamental connection between the heat equation and the Stefan energy balance at the moving interface.", "problem": "A finite planar slab of thickness $L_s$ is initially entirely liquid at its equilibrium melting temperature $T_m$. At time $t=0^{+}$, both faces at $x=0$ and $x=L_s$ are suddenly brought to, and thereafter maintained at, a uniform temperature $T_0$ with $T_0<T_m$. Two solidification fronts form at the two faces and advance inward symmetrically. Assume the following idealizations for the advancing solid phase: one-dimensional heat conduction with constant thermophysical properties (thermal conductivity $k$, density $\\rho$, specific heat $c$, thermal diffusivity $\\alpha=k/(\\rho c)$), negligible volumetric heat sources, and negligible heat conduction and undercooling in the liquid so that the liquid remains isothermal at $T_m$. Let $\\ell$ denote the latent heat of fusion per unit mass. Let $s(t)$ denote the location of each solid–liquid interface measured from its respective cooled surface, so that solid occupies $0\\le x \\le s(t)$ near $x=0$ and $L_s - s(t) \\le x \\le L_s$ near $x=L_s$.\n\nUsing only conservation of energy at the moving interface, the heat equation in the solid, and a similarity ansatz consistent with the imposed boundary conditions, derive an analytical expression for the completion time $t_f$ at which the two interfaces meet at the midplane (i.e., $s(t_f)=L_s/2$). You may introduce a dimensionless Stefan number $\\mathrm{Ste}=c\\,(T_m-T_0)/\\ell$ during your derivation if helpful. Express your final answer as a single symbolic expression in terms of the given symbols and any standard special functions you define along the way. Do not perform any numerical evaluation and do not attach units to your final answer.", "solution": "The problem as stated is a classical one-phase Stefan problem. It is mathematically well-posed and scientifically sound, based on the fundamental principles of heat conduction and phase change. We shall proceed with its solution.\n\nThe solidification process is symmetric about the midplane at $x = L_s/2$. We can therefore analyze the solidification of only one half of the slab, for instance, the region $0 \\le x \\le L_s/2$. A solid layer forms and grows from the surface at $x=0$ into the liquid. The thickness of this layer at time $t$ is given by $s(t)$.\n\nThe temperature distribution $T(x,t)$ within the solid phase, for $0 \\le x \\le s(t)$, is governed by the one-dimensional heat equation, assuming constant thermal diffusivity $\\alpha$:\n$$ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2} \\quad \\text{for} \\quad 0 < x < s(t), t > 0 $$\n\nThe boundary conditions for the temperature field are:\n1.  A fixed temperature $T_0$ is maintained at the outer surface $x=0$:\n    $$ T(0, t) = T_0 \\quad \\text{for} \\quad t > 0 $$\n2.  At the moving solid-liquid interface $x=s(t)$, the temperature is the equilibrium melting temperature $T_m$:\n    $$ T(s(t), t) = T_m \\quad \\text{for} \\quad t > 0 $$\n\nThe movement of the interface is governed by the Stefan condition, which is an energy balance at $x=s(t)$. The heat flux from the solid to the interface provides the latent heat of fusion required for solidification. Since the liquid phase is assumed to be isothermal at $T_m$, there is no heat flux from the liquid to the interface. The Stefan condition is therefore:\n$$ k \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)} = \\rho \\ell \\frac{ds}{dt} $$\nwhere $k$ is the thermal conductivity, $\\rho$ is the density of the solid, and $\\ell$ is the latent heat of fusion per unit mass.\n\nThis problem admits a similarity solution. We introduce a dimensionless similarity variable $\\eta$:\n$$ \\eta = \\frac{x}{2\\sqrt{\\alpha t}} $$\nWe seek a solution where the interface position $s(t)$ is proportional to $\\sqrt{t}$, and the temperature $T(x,t)$ is a function of $\\eta$ alone. Let\n$$ s(t) = 2\\lambda\\sqrt{\\alpha t} $$\n$$ T(x,t) = G(\\eta) $$\nHere, $\\lambda$ is a dimensionless constant that must be determined. The partial derivatives of $T$ transform as follows:\n$$ \\frac{\\partial T}{\\partial t} = G'(\\eta) \\frac{\\partial \\eta}{\\partial t} = G'(\\eta) \\left( -\\frac{x}{4\\sqrt{\\alpha} t^{3/2}} \\right) = -\\frac{\\eta}{2t} G'(\\eta) $$\n$$ \\frac{\\partial T}{\\partial x} = G'(\\eta) \\frac{\\partial \\eta}{\\partial x} = G'(\\eta) \\frac{1}{2\\sqrt{\\alpha t}} $$\n$$ \\frac{\\partial^2 T}{\\partial x^2} = G''(\\eta) \\left( \\frac{\\partial \\eta}{\\partial x} \\right)^2 = G''(\\eta) \\frac{1}{4\\alpha t} $$\nSubstituting these into the heat equation gives an ordinary differential equation for $G(\\eta)$:\n$$ -\\frac{\\eta}{2t} G'(\\eta) = \\alpha \\left( G''(\\eta) \\frac{1}{4\\alpha t} \\right) $$\n$$ G''(\\eta) + 2\\eta G'(\\eta) = 0 $$\nThis is a second-order linear ODE. Its general solution is obtained by two successive integrations:\n$$ G'(\\eta) = C_1 \\exp(-\\eta^2) $$\n$$ G(\\eta) = C_1 \\int_0^\\eta \\exp(-\\xi^2) d\\xi + C_2 = C_1 \\frac{\\sqrt{\\pi}}{2} \\mathrm{erf}(\\eta) + C_2 $$\nwhere $\\mathrm{erf}(\\eta)$ is the error function. We can write the temperature profile as:\n$$ T(x,t) = A \\, \\mathrm{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right) + B $$\nThe constants $A$ and $B$ are determined from the boundary conditions.\nAt $x=0$, $\\eta=0$. The condition $T(0,t)=T_0$ gives:\n$$ T_0 = A \\, \\mathrm{erf}(0) + B \\implies B = T_0 $$\nAt the interface $x=s(t)$, the similarity variable is $\\eta = s(t)/(2\\sqrt{\\alpha t}) = \\lambda$. The condition $T(s(t),t)=T_m$ gives:\n$$ T_m = A \\, \\mathrm{erf}(\\lambda) + T_0 \\implies A = \\frac{T_m - T_0}{\\mathrm{erf}(\\lambda)} $$\nThus, the temperature distribution in the solid is:\n$$ T(x,t) = T_0 + (T_m - T_0) \\frac{\\mathrm{erf}(x / (2\\sqrt{\\alpha t}))}{\\mathrm{erf}(\\lambda)} $$\nNow, we apply the Stefan condition. The derivative of the temperature with respect to $x$ is:\n$$ \\frac{\\partial T}{\\partial x} = (T_m - T_0) \\frac{1}{\\mathrm{erf}(\\lambda)} \\frac{d}{dx} \\left[ \\mathrm{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right) \\right] = (T_m - T_0) \\frac{1}{\\mathrm{erf}(\\lambda)} \\frac{2}{\\sqrt{\\pi}} \\exp\\left(-\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)^2\\right) \\frac{1}{2\\sqrt{\\alpha t}} $$\nEvaluating this at the interface $x=s(t)$, where $\\eta=\\lambda$:\n$$ \\left. \\frac{\\partial T}{\\partial x} \\right|_{x=s(t)} = \\frac{T_m - T_0}{\\sqrt{\\pi \\alpha t} \\, \\mathrm{erf}(\\lambda)} \\exp(-\\lambda^2) $$\nThe rate of interface advance is found by differentiating $s(t)$:\n$$ \\frac{ds}{dt} = \\frac{d}{dt}(2\\lambda\\sqrt{\\alpha t}) = 2\\lambda\\sqrt{\\alpha} \\left(\\frac{1}{2} t^{-1/2}\\right) = \\lambda\\sqrt{\\frac{\\alpha}{t}} $$\nSubstituting these expressions into the Stefan condition $k (\\partial T / \\partial x) = \\rho \\ell (ds/dt)$:\n$$ k \\left( \\frac{T_m - T_0}{\\sqrt{\\pi \\alpha t} \\, \\mathrm{erf}(\\lambda)} \\exp(-\\lambda^2) \\right) = \\rho \\ell \\left( \\lambda \\sqrt{\\frac{\\alpha}{t}} \\right) $$\nThe term $\\sqrt{t}$ cancels. We simplify and use the definition $\\alpha = k/(\\rho c)$:\n$$ k (T_m - T_0) \\exp(-\\lambda^2) = \\rho \\ell \\lambda \\alpha \\sqrt{\\pi} \\, \\mathrm{erf}(\\lambda) $$\n$$ k (T_m - T_0) \\exp(-\\lambda^2) = \\rho \\ell \\lambda \\frac{k}{\\rho c} \\sqrt{\\pi} \\, \\mathrm{erf}(\\lambda) $$\n$$ (T_m - T_0) \\exp(-\\lambda^2) = \\frac{\\ell}{c} \\lambda \\sqrt{\\pi} \\, \\mathrm{erf}(\\lambda) $$\nRearranging gives a transcendental equation for $\\lambda$:\n$$ \\frac{c(T_m - T_0)}{\\ell} = \\sqrt{\\pi} \\lambda \\exp(\\lambda^2) \\mathrm{erf}(\\lambda) $$\nThe left-hand side is the Stefan number, $\\mathrm{Ste} = c(T_m-T_0)/\\ell$. Thus, $\\lambda$ is the positive root of the equation:\n$$ \\mathrm{Ste} = \\sqrt{\\pi} \\lambda \\exp(\\lambda^2) \\mathrm{erf}(\\lambda) $$\nThe solidification is complete at time $t_f$ when the two interfaces, advancing from $x=0$ and $x=L_s$, meet at the midplane. This means $s(t_f) = L_s/2$.\nUsing the expression for $s(t)$:\n$$ 2\\lambda\\sqrt{\\alpha t_f} = \\frac{L_s}{2} $$\nSolving for the completion time $t_f$:\n$$ \\sqrt{t_f} = \\frac{L_s}{4\\lambda\\sqrt{\\alpha}} $$\n$$ t_f = \\frac{L_s^2}{16 \\lambda^2 \\alpha} $$\nThis is the final analytical expression for the completion time. The constant $\\lambda$ is determined by the material properties and temperature conditions via the transcendental equation involving the Stefan number.", "answer": "$$\\boxed{\\frac{L_s^2}{16 \\lambda^2 \\alpha}}$$", "id": "2523101"}, {"introduction": "While analytical solutions provide crucial insights, most practical solidification problems demand numerical methods. The enthalpy method is a powerful and widely-used fixed-grid technique that circumvents the complexity of explicitly tracking the moving boundary by reformulating the problem in terms of enthalpy. This hands-on programming exercise [@problem_id:2523100] guides you through the implementation of an enthalpy-based solver, providing practical skills in discretizing the governing equations and handling the non-linear material properties inherent to phase change.", "problem": "Consider the one-dimensional two-phase Stefan problem on a fixed spatial interval with a fixed-grid enthalpy method. Let $x \\in [0,L]$ denote space and $t \\ge 0$ denote time. The temperature field is $T(x,t)$ and the volumetric enthalpy is $H(x,t)$. The heat conduction obeys energy conservation and Fourier’s law, which together imply the enthalpy balance\n$$\n\\frac{\\partial H}{\\partial t} \\;=\\; \\frac{\\partial}{\\partial x}\\!\\left(k\\,\\frac{\\partial T}{\\partial x}\\right),\n$$\nwhere $k$ is the thermal conductivity, assumed constant and identical in both phases. The enthalpy $H$ is related to the temperature $T$ by a strictly increasing piecewise-linear function that includes latent heat through a narrow mushy interval around the melting temperature. Specifically, fix a melting temperature $T_m$, a mushy half-width $\\Delta T/2 > 0$, a volumetric heat capacity $C$ (assumed constant and identical in both solid and liquid), and a latent heat per unit volume $L_v > 0$. Define the solidus and liquidus temperatures\n$$\nT_s \\;=\\; T_m \\;-\\; \\frac{\\Delta T}{2},\\qquad\nT_l \\;=\\; T_m \\;+\\; \\frac{\\Delta T}{2}.\n$$\nDefine the enthalpy–temperature relation $H(T)$ by\n$$\nH(T) \\;=\\;\n\\begin{cases}\nC\\,T, & T \\le T_s, \\\\[6pt]\nC\\,T \\;+\\; L_v\\,\\dfrac{T - T_s}{\\Delta T}, & T_s < T < T_l, \\\\[10pt]\nC\\,T \\;+\\; L_v, & T \\ge T_l.\n\\end{cases}\n$$\nThis function is invertible; given $H$, recover $T$ by inverting the above piecewise definition. Impose a Dirichlet boundary condition at $x=0$, $T(0,t)=T_{\\text{left}}$, and an adiabatic (zero-normal-heat-flux) Neumann boundary condition at $x=L$, $\\partial T/\\partial x \\big|_{x=L}=0$. The initial temperature is uniform, $T(x,0)=T_{\\text{init}}$.\n\nYour task is to implement a fixed-grid algorithm that advances $H$ explicitly in time and recovers $T$ at each time step by inversion of $H(T)$, on a uniform grid of $N$ nodes. Use a central finite difference for the spatial second derivative and an explicit forward-Euler time integrator on $H$. Enforce the Dirichlet boundary by setting the boundary temperature directly, and enforce the adiabatic boundary by a zero-gradient condition. Track the solid–liquid interface position implicitly as the location where $T(x,t)$ crosses $T_m$ from the left. If there is no crossing within $[0,L]$, define the interface position as $0$ if $T(x,t) \\ge T_m$ for all $x$, and as $L$ if $T(x,t) \\le T_m$ for all $x$. Use linear interpolation between adjacent grid points to estimate the crossing location when it lies between nodes.\n\nStarting from the fundamental laws above, design your algorithm to:\n- Evolve $H$ by the enthalpy balance,\n- Recover $T$ by inverting $H(T)$ pointwise,\n- Enforce the boundary conditions consistently at each time step,\n- Compute the interface position $s(t)$ implicitly from the computed temperature field.\n\nImplement your algorithm as a complete program that runs the following test suite. For each test case, simulate until time $t_{\\text{end}}$, and return the interface position $s(t_{\\text{end}})$ in meters. Use the exact parameter values provided; all quantities are in International System of Units (SI). The grid is uniform with $N$ nodes and spacing $\\Delta x = L/(N-1)$. Take exactly $n_{\\text{steps}} = \\lfloor t_{\\text{end}}/\\Delta t \\rfloor$ steps of size $\\Delta t$, so the simulated final time is $n_{\\text{steps}}\\,\\Delta t$. The test suite covers a typical solidification case, a high-latent-heat case, and a melting case:\n\n- Test case A (solidification, moderate latent heat):\n  - $L = 0.1$,\n  - $N = 201$,\n  - $k = 2.0$,\n  - $C = 2.0 \\times 10^{6}$,\n  - $L_v = 3.34 \\times 10^{8}$,\n  - $T_m = 0.0$,\n  - $\\Delta T = 0.2$,\n  - $T_{\\text{left}} = -10.0$,\n  - $T_{\\text{init}} = 10.0$,\n  - $t_{\\text{end}} = 200.0$,\n  - $\\Delta t = 0.05$.\n\n- Test case B (solidification, very large latent heat):\n  - $L = 0.1$,\n  - $N = 201$,\n  - $k = 2.0$,\n  - $C = 2.0 \\times 10^{6}$,\n  - $L_v = 1.0 \\times 10^{9}$,\n  - $T_m = 0.0$,\n  - $\\Delta T = 0.2$,\n  - $T_{\\text{left}} = -10.0$,\n  - $T_{\\text{init}} = 10.0$,\n  - $t_{\\text{end}} = 200.0$,\n  - $\\Delta t = 0.05$.\n\n- Test case C (melting, moderate latent heat):\n  - $L = 0.05$,\n  - $N = 201$,\n  - $k = 1.5$,\n  - $C = 2.0 \\times 10^{6}$,\n  - $L_v = 3.34 \\times 10^{8}$,\n  - $T_m = 0.0$,\n  - $\\Delta T = 0.2$,\n  - $T_{\\text{left}} = 10.0$,\n  - $T_{\\text{init}} = -5.0$,\n  - $t_{\\text{end}} = 100.0$,\n  - $\\Delta t = 0.02$.\n\nScientific realism requirements:\n- Treat $k$, $C$, and $L_v$ as constants in space and time and identical in both phases.\n- Use the piecewise-linear $H(T)$ defined above and its exact pointwise inverse to recover $T$ from $H$.\n- Ensure the algorithm enforces the boundary conditions at each time step.\n\nAngle units do not apply. All interface positions must be reported in meters. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[resultA,resultB,resultC]\"), where each entry is a floating-point number equal to $s(t_{\\text{end}})$ in meters, rounded to six decimal places.", "solution": "The problem is validated.\n\n**Step 1: Extract Givens**\n- **Governing Equation**: $\\frac{\\partial H}{\\partial t} = \\frac{\\partial}{\\partial x}\\!(k\\,\\frac{\\partial T}{\\partial x})$\n- **Domain**: Spatial $x \\in [0,L]$, time $t \\ge 0$.\n- **Constants**: Thermal conductivity $k$, volumetric heat capacity $C$, latent heat per unit volume $L_v$, melting temperature $T_m$, mushy half-width $\\Delta T/2$.\n- **Phase Transition Temperatures**: $T_s = T_m - \\Delta T/2$, $T_l = T_m + \\Delta T/2$.\n- **Enthalpy-Temperature Relation $H(T)$**:\n$$\nH(T) = \\begin{cases}\nC\\,T, & T \\le T_s, \\\\\nC\\,T + L_v\\,\\frac{T - T_s}{\\Delta T}, & T_s < T < T_l, \\\\\nC\\,T + L_v, & T \\ge T_l.\n\\end{cases}\n$$\n- **Boundary Conditions**: $T(0,t)=T_{\\text{left}}$ (Dirichlet), $\\partial T/\\partial x \\big|_{x=L}=0$ (Neumann).\n- **Initial Condition**: $T(x,0)=T_{\\text{init}}$.\n- **Numerical Scheme**: Uniform grid with $N$ nodes, spacing $\\Delta x = L/(N-1)$. Explicit forward-Euler time integration with step $\\Delta t$, central finite difference for space.\n- **Time Integration**: $n_{\\text{steps}} = \\lfloor t_{\\text{end}}/\\Delta t \\rfloor$ steps of size $\\Delta t$.\n- **Interface Position $s(t)$**: Location where $T(x,t) = T_m$, found by linear interpolation. If $T \\ge T_m$ for all $x$, $s=0$. If $T \\le T_m$ for all $x$, $s=L$.\n- **Test Cases**: Parameters for cases A, B, and C are provided with specific values for all constants and numerical parameters.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, describing the standard one-dimensional Stefan problem using the enthalpy method, a well-established technique in computational heat transfer. All necessary equations, initial conditions, boundary conditions, and material properties are specified, making the problem self-contained and complete. The numerical discretization method (explicit finite differences) is clearly defined. A stability analysis confirms that the chosen time steps for all test cases satisfy the Courant-Friedrichs-Lewy (CFL) condition for the explicit heat equation, ensuring numerical stability. For instance, in Case A, the stability limit is $\\Delta t \\le (\\Delta x)^2 / (2\\alpha) = (5 \\times 10^{-4})^2 / (2 \\times 10^{-6}) = 0.125$ s, and the chosen $\\Delta t = 0.05$ s is safely below this limit. The problem is objective, well-posed, and non-trivial.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be constructed.\n\nThe solution to this problem requires designing a numerical algorithm based on the finite difference method to solve the given partial differential equation for enthalpy. The algorithm proceeds as follows.\n\n**1. Discretization of the Governing Equation**\nThe domain is discretized into a uniform grid with $N$ nodes, indexed $i=0, 1, \\dots, N-1$. The spatial coordinate of node $i$ is $x_i = i \\Delta x$, where $\\Delta x = L/(N-1)$. The temperature and enthalpy at node $i$ and time step $n$ are denoted $T_i^n$ and $H_i^n$, respectively.\n\nThe governing equation is\n$$\n\\frac{\\partial H}{\\partial t} = k \\frac{\\partial^2 T}{\\partial x^2}\n$$\nWe apply a forward-Euler scheme for the time derivative and a central difference scheme for the spatial second derivative. For an interior node $i \\in \\{1, \\dots, N-2\\}$, the discretized equation is:\n$$\n\\frac{H_i^{n+1} - H_i^n}{\\Delta t} = k \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2}\n$$\nRearranging for the explicit update of enthalpy gives:\n$$\nH_i^{n+1} = H_i^n + \\frac{k \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n\n**2. Enthalpy-Temperature Constitutive Relation**\nThe core of the enthalpy method is the relationship between enthalpy $H$ and temperature $T$. To advance the simulation, we first update $H$ and then recover the new temperature $T$ from the updated $H$. This requires the inverse function $T(H)$, which we derive from the given piecewise-linear $H(T)$.\n\nFirst, we define the enthalpy values at the solidus and liquidus temperatures, $T_s = T_m - \\Delta T/2$ and $T_l = T_m + \\Delta T/2$:\n$$\nH_s = H(T_s) = C T_s\n$$\n$$\nH_l = H(T_l) = C T_l + L_v\n$$\nBy inverting each segment of the $H(T)$ function, we obtain $T(H)$:\n$$\nT(H) =\n\\begin{cases}\nH/C & \\text{if } H \\le H_s \\quad \\text{(solid)} \\\\\n\\frac{H \\Delta T + L_v T_s}{L_v + C \\Delta T} & \\text{if } H_s < H < H_l \\quad \\text{(mushy)} \\\\\n(H - L_v)/C & \\text{if } H \\ge H_l \\quad \\text{(liquid)}\n\\end{cases}\n$$\nThis function is applied pointwise to the enthalpy array $H^{n+1}$ to obtain the temperature array $T^{n+1}$ at each time step.\n\n**3. Boundary Conditions**\nThe boundary nodes $i=0$ and $i=N-1$ require special treatment.\n\n- **Dirichlet Condition at $x=0$**: The temperature is fixed, $T(0,t) = T_{\\text{left}}$. At each time step $n+1$, we enforce this by setting $T_0^{n+1} = T_{\\text{left}}$. To maintain consistency between the state variables, the enthalpy at this node must also be updated to correspond to this fixed temperature: $H_0^{n+1} = H(T_{\\text{left}})$, calculated using the given $H(T)$ function.\n\n- **Neumann Condition at $x=L$**: The zero-flux condition $\\partial T/\\partial x = 0$ is implemented using a second-order accurate ghost-point method. We imagine a ghost node at $x_N = x_{N-1} + \\Delta x$ such that the centered difference for the gradient at $x_{N-1}$ is zero: $\\frac{T_N^n - T_{N-2}^n}{2\\Delta x} = 0$, which implies $T_N^n = T_{N-2}^n$. Substituting this into the central difference formula for the second derivative at node $i=N-1$:\n$$\n\\frac{\\partial^2 T}{\\partial x^2}\\bigg|_{i=N-1} \\approx \\frac{T_N^n - 2T_{N-1}^n + T_{N-2}^n}{(\\Delta x)^2} = \\frac{T_{N-2}^n - 2T_{N-1}^n + T_{N-2}^n}{(\\Delta x)^2} = \\frac{2(T_{N-2}^n - T_{N-1}^n)}{(\\Delta x)^2}\n$$\nThe enthalpy update for the rightmost node is therefore:\n$$\nH_{N-1}^{n+1} = H_{N-1}^n + \\frac{2 k \\Delta t}{(\\Delta x)^2} (T_{N-2}^n - T_{N-1}^n)\n$$\n\n**4. Interface Position Tracking**\nThe solid-liquid interface position $s(t)$ is defined as the location where $T(x,t) = T_m$. After computing the temperature profile $T^n$ at a given time, we search for the first grid interval $[x_i, x_{i+1}]$ from the left where the temperature crosses $T_m$. This occurs where $(T_i^n - T_m)(T_{i+1}^n - T_m) \\le 0$. If such an interval is found, the interface position $s$ is estimated via linear interpolation:\n$$\ns = x_i + \\Delta x \\frac{T_m - T_i^n}{T_{i+1}^n - T_i^n}\n$$\nIf no such crossing exists, the problem specifies the position: $s=0$ if all temperatures $T_i^n \\ge T_m$ (fully liquid/mushy), and $s=L$ if all $T_i^n \\le T_m$ (fully solid/mushy).\n\n**5. Algorithmic Summary**\nThe overall algorithm is as follows:\n1.  **Initialization**: Define all physical and numerical parameters. Create the spatial grid $x$. Initialize the temperature array $T$ to $T_{\\text{init}}$, then enforce the boundary condition $T_0 = T_{\\text{left}}$. Compute the initial enthalpy array $H$ from the initial $T$ using the $H(T)$ relation.\n2.  **Time Marching**: Loop for $n_{\\text{steps}}$ iterations.\n    a. Calculate the next enthalpy array $H^{n+1}$ using the explicit update rules for interior nodes and the right boundary node, based on the current temperature profile $T^n$.\n    b. Recover the new temperature array $T^{n+1}$ by applying the inverse function $T(H^{n+1})$ pointwise.\n    c. Enforce the Dirichlet boundary condition: set $T_0^{n+1} = T_{\\text{left}}$ and update $H_0^{n+1} = H(T_{\\text{left}})$.\n    d. The updated arrays $H^{n+1}$ and $T^{n+1}$ become the current arrays for the next iteration.\n3.  **Final Calculation**: After the loop concludes, compute the final interface position $s(t_{\\text{end}})$ from the final temperature profile using the interpolation logic.", "answer": "```python\nimport numpy as np\n\ndef get_H_from_T(T_arr, C, Lv, Tm, DT):\n    \"\"\"\n    Computes volumetric enthalpy H from temperature T.\n    T_arr can be a scalar or a numpy array.\n    \"\"\"\n    # Ensure T_arr is an array for consistent processing\n    T = np.atleast_1d(T_arr)\n    H = np.zeros_like(T, dtype=np.float64)\n\n    Ts = Tm - DT / 2.0\n    Tl = Tm + DT / 2.0\n\n    solid_mask = T <= Ts\n    liquid_mask = T >= Tl\n    mushy_mask = (~solid_mask) & (~liquid_mask)\n\n    H[solid_mask] = C * T[solid_mask]\n    H[liquid_mask] = C * T[liquid_mask] + Lv\n    H[mushy_mask] = C * T[mushy_mask] + Lv * (T[mushy_mask] - Ts) / DT\n\n    return H\n\ndef get_T_from_H(H_arr, C, Lv, Tm, DT):\n    \"\"\"\n    Computes temperature T from volumetric enthalpy H.\n    H_arr can be a scalar or a numpy array.\n    \"\"\"\n    H = np.atleast_1d(H_arr)\n    T = np.zeros_like(H, dtype=np.float64)\n\n    Ts = Tm - DT / 2.0\n    Tl = Tm + DT / 2.0\n    \n    Hs = C * Ts\n    Hl = C * Tl + Lv\n\n    solid_mask = H <= Hs\n    liquid_mask = H >= Hl\n    mushy_mask = (~solid_mask) & (~liquid_mask)\n\n    T[solid_mask] = H[solid_mask] / C\n    T[liquid_mask] = (H[liquid_mask] - Lv) / C\n    T[mushy_mask] = (H[mushy_mask] * DT + Lv * Ts) / (Lv + C * DT)\n\n    return T\n\ndef find_interface_position(x, T, Tm, L):\n    \"\"\"\n    Finds the interface position s where T(s) = Tm.\n    \"\"\"\n    if np.all(T >= Tm):\n        return 0.0\n    if np.all(T <= Tm):\n        return L\n\n    cross_indices = np.where((T[:-1] - Tm) * (T[1:] - Tm) <= 0)[0]\n    \n    if len(cross_indices) == 0:\n        # Fallback, though the np.all checks should handle this.\n        return 0.0 if T[0] > Tm else L\n\n    i = cross_indices[0]\n    T_i, T_i1 = T[i], T[i+1]\n    x_i, x_i1 = x[i], x[i+1]\n    \n    if T_i == T_i1:\n        return x_i\n    \n    # Linear interpolation\n    s = x_i + (x_i1 - x_i) * (Tm - T_i) / (T_i1 - T_i)\n    return s\n\ndef run_simulation(params):\n    \"\"\"\n    Runs a single simulation case for the Stefan problem.\n    \"\"\"\n    L, N, k, C, Lv, Tm, DT, T_left, T_init, t_end, dt = params\n\n    # Discretization parameters\n    dx = L / (N - 1)\n    n_steps = int(t_end / dt)\n    x = np.linspace(0, L, N)\n    \n    # Initial conditions\n    T = np.full(N, T_init, dtype=np.float64)\n    T[0] = T_left  # Boundary condition dominates at t=0, x=0\n    H = get_H_from_T(T, C, Lv, Tm, DT)\n\n    # Pre-calculate constant factor for performance\n    prefactor = k * dt / (dx**2)\n\n    # Time-marching loop\n    for _ in range(n_steps):\n        # Create a copy of H for the update step.\n        H_new = H.copy()\n        \n        # Update enthalpy for interior nodes\n        H_new[1:-1] = H[1:-1] + prefactor * (T[2:] - 2 * T[1:-1] + T[:-2])\n        \n        # Update enthalpy for right boundary (Neumann)\n        H_new[-1] = H[-1] + 2 * prefactor * (T[-2] - T[-1])\n        \n        # Recover new temperature field from new enthalpy field\n        T_new = get_T_from_H(H_new, C, Lv, Tm, DT)\n\n        # Enforce left boundary (Dirichlet)\n        T_new[0] = T_left\n        H_new[0] = get_H_from_T(T_left, C, Lv, Tm, DT)[0]\n        \n        # Update T and H for the next iteration\n        T, H = T_new, H_new\n\n    # Calculate final interface position\n    s_final = find_interface_position(x, T, Tm, L)\n    \n    return s_final\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # Case A (solidification, moderate latent heat)\n        (0.1, 201, 2.0, 2.0e6, 3.34e8, 0.0, 0.2, -10.0, 10.0, 200.0, 0.05),\n        \n        # Case B (solidification, very large latent heat)\n        (0.1, 201, 2.0, 2.0e6, 1.0e9, 0.0, 0.2, -10.0, 10.0, 200.0, 0.05),\n        \n        # Case C (melting, moderate latent heat)\n        (0.05, 201, 1.5, 2.0e6, 3.34e8, 0.0, 0.2, 10.0, -5.0, 100.0, 0.02),\n    ]\n\n    results = []\n    for case in test_cases:\n        s = run_simulation(case)\n        results.append(f\"{s:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2523100"}, {"introduction": "A crucial skill for any scientist or engineer is the ability to connect theoretical models with experimental data. This is the domain of inverse problems, where we use observed outcomes to deduce unknown parameters in our physical model, as opposed to a forward problem that predicts outcomes from known parameters. This advanced practice [@problem_id:2523056] challenges you to solve such a problem by combining the analytical Stefan solution with numerical optimization to estimate the latent heat of fusion from a set of simulated measurements, providing a window into modern data-driven physical modeling.", "problem": "Consider a one-dimensional, one-phase solidification of a semi-infinite medium initially at the melting temperature. Let the spatial coordinate be $x \\ge 0$ and time be $t \\ge 0$. The temperature field in the solidified region $0 \\le x \\le s(t)$ is $T(x,t)$, and the unknown moving interface location is $s(t)$. The medium has constant thermal conductivity $k$, density $\\rho$, and specific heat $c$. The latent heat per unit mass to be estimated is $L$. For $t>0$, the boundary at $x=0$ is suddenly brought to a prescribed temperature $T_s$ that is below the melting temperature $T_m$. The liquid beyond the interface remains at $T_m$. The governing equations and conditions are:\n- Energy conservation in the solid: $\\displaystyle \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$ for $0 < x < s(t)$, $t>0$, where $\\alpha = \\dfrac{k}{\\rho c}$.\n- Boundary condition at the surface: $\\displaystyle T(0,t) = T_s$ for $t>0$.\n- Interface temperature condition: $\\displaystyle T(s(t),t) = T_m$ for $t>0$.\n- Stefan energy balance at the interface: $\\displaystyle \\rho L \\frac{ds}{dt} = k \\left.\\frac{\\partial T}{\\partial x}\\right|_{x = s(t)^-}$ for $t>0$.\n- Initial conditions: $\\displaystyle s(0) = 0$ and $\\displaystyle T(x,0) = T_m$ for $x>0$.\n\nYou are given noisy measurements of the interface position $s(t_i)$ at specified times and noisy measurements of temperatures taken by a thin, surface-embedded thermocouple located at a fixed depth $x_\\star>0$ inside the medium. For each test case below, construct and solve the inverse problem of estimating $L$ by minimizing a weighted least-squares mismatch functional subject to the above Stefan partial differential equation constraints via the analytically consistent similarity solution. The objective is to find\n$$\n\\widehat{L} = \\arg\\min_{L_{\\min} \\le L \\le L_{\\max}} \\left\\{ \\sum_{i=1}^{N_s} \\left(\\frac{s_{\\text{model}}(t_i;L) - s_{\\text{meas},i}}{\\sigma_s}\\right)^2 + \\sum_{j=1}^{N_T} \\left(\\frac{T_{\\text{model}}(x_\\star,t_j;L) - T_{\\text{meas},j}}{\\sigma_T}\\right)^2 \\right\\},\n$$\nwhere $s_{\\text{model}}(\\cdot;L)$ and $T_{\\text{model}}(\\cdot,\\cdot;L)$ are the predictions that exactly satisfy the Stefan problem above for a given $L$, and $\\sigma_s$ and $\\sigma_T$ are given measurement noise scales. The model must be constructed from first principles and must not violate the given Stefan constraints.\n\nUse the following self-consistent test suite. All physical quantities must be used in International System of Units. Report each estimated latent heat $\\widehat{L}$ in joules per kilogram (J/kg), rounded to the nearest integer. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3]\").\n\nIn all test cases, the measured data are defined as the exact forward solution of the Stefan problem with a specified ground-truth latent heat $L_{\\text{true}}$, plus a small, explicitly specified bias. That is, $s_{\\text{meas},i} = s_{\\text{true}}(t_i; L_{\\text{true}}) + \\delta s_i$ and $T_{\\text{meas},j} = T_{\\text{true}}(x_\\star,t_j; L_{\\text{true}}) + \\delta T_j$, where $s_{\\text{true}}$ and $T_{\\text{true}}$ are the model-consistent predictions. Here the bias arrays $\\{\\delta s_i\\}$ and $\\{\\delta T_j\\}$ are provided below. The temperatures must be handled in kelvins and distances in meters, and all times are in seconds. For each case, set the optimization bounds as $L \\in [L_{\\min}, L_{\\max}]$.\n\nTest Case A (happy path, moderate supercooling):\n- Material properties: $k = 2.2$ W/(m·K), $\\rho = 917.0$ kg/m$^3$, $c = 2100.0$ J/(kg·K), $T_m = 273.15$ K, $T_s = 263.15$ K.\n- Sensor depth: $x_\\star = 0.003$ m.\n- Ground truth latent heat: $L_{\\text{true}} = 334000.0$ J/kg.\n- Measurement times: $t_i \\in \\{60.0, 120.0, 300.0, 600.0, 1200.0\\}$ s for both $s$ and $T$.\n- Bias arrays: $\\delta s = [1.0\\times 10^{-4}, -2.0\\times 10^{-4}, 5.0\\times 10^{-5}, -1.0\\times 10^{-4}, 1.5\\times 10^{-4}]$ m; $\\delta T = [0.1, -0.05, 0.0, 0.02, -0.03]$ K.\n- Noise scales: $\\sigma_s = 1.0\\times 10^{-4}$ m; $\\sigma_T = 0.2$ K.\n- Optimization bounds: $L_{\\min} = 200000.0$ J/kg, $L_{\\max} = 600000.0$ J/kg.\n\nTest Case B (edge case, weak supercooling so the interface reaches the sensor later):\n- Material properties: $k = 2.2$ W/(m·K), $\\rho = 917.0$ kg/m$^3$, $c = 2100.0$ J/(kg·K), $T_m = 273.15$ K, $T_s = 271.15$ K.\n- Sensor depth: $x_\\star = 0.004$ m.\n- Ground truth latent heat: $L_{\\text{true}} = 334000.0$ J/kg.\n- Measurement times: $t_i \\in \\{120.0, 240.0, 480.0, 960.0, 1920.0\\}$ s for both $s$ and $T$.\n- Bias arrays: $\\delta s = [5.0\\times 10^{-5}, -1.0\\times 10^{-4}, 7.0\\times 10^{-5}, -5.0\\times 10^{-5}, 1.0\\times 10^{-4}]$ m; $\\delta T = [0.05, -0.04, 0.02, 0.01, -0.02]$ K.\n- Noise scales: $\\sigma_s = 1.0\\times 10^{-4}$ m; $\\sigma_T = 0.2$ K.\n- Optimization bounds: $L_{\\min} = 200000.0$ J/kg, $L_{\\max} = 600000.0$ J/kg.\n\nTest Case C (different material properties and melt temperature):\n- Material properties: $k = 0.25$ W/(m·K), $\\rho = 900.0$ kg/m$^3$, $c = 2100.0$ J/(kg·K), $T_m = 323.15$ K, $T_s = 313.15$ K.\n- Sensor depth: $x_\\star = 0.005$ m.\n- Ground truth latent heat: $L_{\\text{true}} = 180000.0$ J/kg.\n- Measurement times: $t_i \\in \\{300.0, 600.0, 1200.0, 2400.0, 3600.0\\}$ s for both $s$ and $T$.\n- Bias arrays: $\\delta s = [1.0\\times 10^{-4}, 1.5\\times 10^{-4}, -1.0\\times 10^{-4}, 2.0\\times 10^{-4}, -1.5\\times 10^{-4}]$ m; $\\delta T = [0.08, -0.06, 0.02, 0.0, -0.03]$ K.\n- Noise scales: $\\sigma_s = 1.0\\times 10^{-4}$ m; $\\sigma_T = 0.2$ K.\n- Optimization bounds: $L_{\\min} = 100000.0$ J/kg, $L_{\\max} = 300000.0$ J/kg.\n\nModeling directive for the forward map $(L \\mapsto s_{\\text{model}}, T_{\\text{model}})$: enforce the Stefan constraints above exactly by using the classical similarity solution for the one-phase Stefan problem on a semi-infinite domain with a Dirichlet boundary at $x=0$. In particular, the interface takes the form $s(t) = 2 \\lambda \\sqrt{\\alpha t}$ with a similarity parameter $\\lambda>0$ consistent with the Stefan condition, and $T(x,t)$ is a similarity profile in the solid region $0 \\le x \\le s(t)$ that satisfies the stated boundary and interface conditions. The parameter $\\lambda$ is implicitly determined by the balance implied by the Stefan condition in terms of the latent heat and material properties. For temperatures at the sensor depth $x_\\star$, if $x_\\star \\le s(t)$, use the solid-region similarity temperature; if $x_\\star > s(t)$, the sensor is in liquid at $T_m$.\n\nFinal output format requirement: Your program must produce a single line containing a Python-style list with the three estimated values $[\\widehat{L}_A,\\widehat{L}_B,\\widehat{L}_C]$ in J/kg, each rounded to the nearest integer, with no additional text. All computations must use the units as stated above.", "solution": "The problem presented is a classical inverse heat transfer problem: to estimate a physical parameter, the latent heat of solidification $L$, from noisy experimental data. This is a valid, well-posed, and scientifically grounded problem that can be solved using established methods of parameter estimation theory constrained by partial differential equations. We will proceed by first constructing the forward model, which maps the parameter $L$ to the observable quantities (interface position $s(t)$ and temperature $T(x_\\star,t)$), and then setting up and solving the optimization problem to find the value of $L$ that best fits the provided data.\n\nThe forward model is given by the solution to the one-phase Stefan problem on a semi-infinite domain. The governing equations are:\n1.  Heat equation in the solid phase: $\\displaystyle \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$ for $0 < x < s(t)$, where $\\alpha = \\frac{k}{\\rho c}$ is the thermal diffusivity.\n2.  Dirichlet boundary condition at the surface: $\\displaystyle T(0,t) = T_s$.\n3.  Temperature at the moving interface: $\\displaystyle T(s(t),t) = T_m$.\n4.  Stefan condition at the interface: $\\displaystyle \\rho L \\frac{ds}{dt} = k \\left.\\frac{\\partial T}{\\partial x}\\right|_{x = s(t)^-}$.\n\nThis system admits a similarity solution. We introduce the similarity variable $\\eta = \\frac{x}{2\\sqrt{\\alpha t}}$. The temperature field is assumed to have the form $T(x,t) = f(\\eta)$. Substituting this into the heat equation yields the ordinary differential equation $f''(\\eta) + 2\\eta f'(\\eta) = 0$. The general solution to this equation is $f(\\eta) = A \\cdot \\text{erf}(\\eta) + B$, where $\\text{erf}$ is the error function and $A$ and $B$ are constants of integration.\n\nThe moving interface $s(t)$ is also sought in a form compatible with the similarity transformation, $s(t) = 2\\lambda\\sqrt{\\alpha t}$, where $\\lambda$ is a dimensionless constant to be determined. In the similarity coordinate, the interface is at the fixed position $\\eta = \\lambda$. The solid phase exists in the region $0 \\le \\eta \\le \\lambda$.\n\nWe apply the boundary conditions to determine the constants $A$ and $B$:\n- At $x=0$, we have $\\eta=0$. The condition $T(0,t) = T_s$ gives $f(0) = A \\cdot \\text{erf}(0) + B = B$, so $B = T_s$.\n- At $x=s(t)$, we have $\\eta=\\lambda$. The condition $T(s(t),t) = T_m$ gives $f(\\lambda) = A \\cdot \\text{erf}(\\lambda) + T_s = T_m$, which implies $A = \\frac{T_m - T_s}{\\text{erf}(\\lambda)}$.\n\nThus, the temperature profile in the solidified region is:\n$$ T(x,t) = T_s + (T_m - T_s) \\frac{\\text{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)}{\\text{erf}(\\lambda)} \\quad \\text{for } 0 \\le x \\le s(t) $$\n\nThe constant $\\lambda$ is determined by the Stefan condition. First, we find the derivatives:\n- $\\frac{ds}{dt} = \\frac{d}{dt}(2\\lambda\\sqrt{\\alpha t}) = \\lambda\\sqrt{\\frac{\\alpha}{t}}$.\n- $\\frac{\\partial T}{\\partial x} = (T_m-T_s) \\frac{1}{\\text{erf}(\\lambda)} \\frac{d}{dx}\\left[\\text{erf}\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)\\right] = \\frac{T_m-T_s}{\\text{erf}(\\lambda)} \\frac{2}{\\sqrt{\\pi}} e^{-\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right)^2} \\frac{1}{2\\sqrt{\\alpha t}}$.\n\nEvaluating the temperature gradient at the interface $x = s(t)$, we get:\n$$ \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=s(t)} = \\frac{T_m - T_s}{\\text{erf}(\\lambda)} \\frac{1}{\\sqrt{\\pi\\alpha t}} e^{-\\lambda^2} $$\n\nSubstituting these into the Stefan condition $\\rho L \\frac{ds}{dt} = k \\left.\\frac{\\partial T}{\\partial x}\\right|_{x=s(t)}$:\n$$ \\rho L \\lambda\\sqrt{\\frac{\\alpha}{t}} = k \\frac{T_m - T_s}{\\text{erf}(\\lambda)} \\frac{e^{-\\lambda^2}}{\\sqrt{\\pi\\alpha t}} $$\nUsing $\\alpha = k/(\\rho c)$ and simplifying, we arrive at the following transcendental equation for $\\lambda$:\n$$ \\lambda e^{\\lambda^2} \\text{erf}(\\lambda) = \\frac{c(T_m - T_s)}{L\\sqrt{\\pi}} $$\nThe term $Ste = \\frac{c(T_m - T_s)}{L}$ is known as the Stefan number. For a given set of material properties and boundary conditions, and a candidate value for the latent heat $L$, this equation has a unique positive solution for $\\lambda$ because the left-hand side is a monotonically increasing function of $\\lambda$ for $\\lambda > 0$. This equation must be solved numerically.\n\nThe forward model, which maps a candidate $L$ to predictions, is thus:\n1.  For a given $L$, numerically solve the transcendental equation for $\\lambda$.\n2.  The interface position is then given by $s_{\\text{model}}(t; L) = 2\\lambda\\sqrt{\\alpha t}$.\n3.  The temperature at the sensor location $x_\\star$ is conditional. The interface reaches the sensor at time $t_{pass} = \\frac{x_\\star^2}{4\\lambda^2\\alpha}$.\n    - For $t < t_{pass}$ (i.e., $x_\\star > s_{\\text{model}}(t; L)$), the sensor is in the liquid, so $T_{\\text{model}}(x_\\star,t; L) = T_m$.\n    - For $t \\ge t_{pass}$ (i.e., $x_\\star \\le s_{\\text{model}}(t; L)$), the sensor is in the solid, and its temperature is $T_{\\text{model}}(x_\\star,t; L) = T_s + (T_m-T_s) \\frac{\\text{erf}(x_\\star / (2\\sqrt{\\alpha t}))}{\\text{erf}(\\lambda)}$.\n\nThe inverse problem is to find the estimate $\\widehat{L}$ by minimizing the weighted least-squares objective function $J(L)$:\n$$\n\\widehat{L} = \\arg\\min_{L_{\\min} \\le L \\le L_{\\max}} J(L) = \\arg\\min_{L_{\\min} \\le L \\le L_{\\max}} \\left\\{ \\sum_{i=1}^{N_s} \\left(\\frac{s_{\\text{model}}(t_i; L) - s_{\\text{meas},i}}{\\sigma_s}\\right)^2 + \\sum_{j=1}^{N_T} \\left(\\frac{T_{\\text{model}}(x_\\star,t_j; L) - T_{\\text{meas},j}}{\\sigma_T}\\right)^2 \\right\\}\n$$\nThe \"measured\" data $s_{\\text{meas},i}$ and $T_{\\text{meas},j}$ for each test case are synthesized by evaluating the forward model with the ground-truth value $L_{\\text{true}}$ and adding the specified bias values.\n\nThe computational procedure is as follows:\n1.  For each test case, the given physical parameters, measurement times, and data biases are used to generate the measurement datasets $s_{\\text{meas}}$ and $T_{\\text{meas}}$.\n2.  An objective function $J(L)$ is defined that, for any input $L$, executes the forward model as described above and computes the weighted sum of squared residuals.\n3.  A one-dimensional numerical optimization routine (`scipy.optimize.minimize_scalar`) is employed to find the value of $L$ within the specified bounds $[L_{\\min}, L_{\\max}]$ that minimizes $J(L)$.\n4.  The resulting optimal value $\\widehat{L}$ is rounded to the nearest integer as required. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\nfrom scipy.optimize import brentq, minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves the inverse Stefan problem for multiple test cases to estimate latent heat L.\n    \"\"\"\n\n    test_cases = [\n        # Test Case A\n        {\n            \"k\": 2.2, \"rho\": 917.0, \"c\": 2100.0, \"Tm\": 273.15, \"Ts\": 263.15,\n            \"x_star\": 0.003, \"L_true\": 334000.0,\n            \"times\": np.array([60.0, 120.0, 300.0, 600.0, 1200.0]),\n            \"delta_s\": np.array([1.0e-4, -2.0e-4, 5.0e-5, -1.0e-4, 1.5e-4]),\n            \"delta_T\": np.array([0.1, -0.05, 0.0, 0.02, -0.03]),\n            \"sigma_s\": 1.0e-4, \"sigma_T\": 0.2,\n            \"L_min\": 200000.0, \"L_max\": 600000.0,\n        },\n        # Test Case B\n        {\n            \"k\": 2.2, \"rho\": 917.0, \"c\": 2100.0, \"Tm\": 273.15, \"Ts\": 271.15,\n            \"x_star\": 0.004, \"L_true\": 334000.0,\n            \"times\": np.array([120.0, 240.0, 480.0, 960.0, 1920.0]),\n            \"delta_s\": np.array([5.0e-5, -1.0e-4, 7.0e-5, -5.0e-5, 1.0e-4]),\n            \"delta_T\": np.array([0.05, -0.04, 0.02, 0.01, -0.02]),\n            \"sigma_s\": 1.0e-4, \"sigma_T\": 0.2,\n            \"L_min\": 200000.0, \"L_max\": 600000.0,\n        },\n        # Test Case C\n        {\n            \"k\": 0.25, \"rho\": 900.0, \"c\": 2100.0, \"Tm\": 323.15, \"Ts\": 313.15,\n            \"x_star\": 0.005, \"L_true\": 180000.0,\n            \"times\": np.array([300.0, 600.0, 1200.0, 2400.0, 3600.0]),\n            \"delta_s\": np.array([1.0e-4, 1.5e-4, -1.0e-4, 2.0e-4, -1.5e-4]),\n            \"delta_T\": np.array([0.08, -0.06, 0.02, 0.0, -0.03]),\n            \"sigma_s\": 1.0e-4, \"sigma_T\": 0.2,\n            \"L_min\": 100000.0, \"L_max\": 300000.0,\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        # Extract parameters for clarity\n        k, rho, c = case[\"k\"], case[\"rho\"], case[\"c\"]\n        Tm, Ts = case[\"Tm\"], case[\"Ts\"]\n        x_star = case[\"x_star\"]\n        times = case[\"times\"]\n        L_true = case[\"L_true\"]\n        delta_s, delta_T = case[\"delta_s\"], case[\"delta_T\"]\n        sigma_s, sigma_T = case[\"sigma_s\"], case[\"sigma_T\"]\n        L_min, L_max = case[\"L_min\"], case[\"L_max\"]\n\n        alpha = k / (rho * c)\n\n        def get_lambda(L_val):\n            \"\"\"Solves the transcendental equation for lambda for a given L.\"\"\"\n            if L_val <= 0:\n                return 0\n            # Constant C in the equation: lambda*exp(lambda^2)*erf(lambda) = C\n            C_const = (c * (Tm - Ts)) / (L_val * np.sqrt(np.pi))\n            \n            # This function is zero when lambda is the correct root\n            func_to_solve = lambda lam: lam * np.exp(lam**2) * erf(lam) - C_const\n            \n            try:\n                # The function is monotonic, brentq is efficient\n                lam_sol = brentq(func_to_solve, 1e-9, 20)\n            except ValueError:\n                # If root is not bracketed (unlikely for physical L), return a value\n                # that will lead to a large error in the objective function.\n                return 1e9 \n            return lam_sol\n        \n        def forward_model(L_val):\n            \"\"\"Computes model predictions for s(t) and T(x_star, t) for a given L.\"\"\"\n            lam = get_lambda(L_val)\n            \n            s_model = 2 * lam * np.sqrt(alpha * times)\n            \n            T_model = np.zeros_like(times)\n            erf_lam = erf(lam)\n\n            if erf_lam == 0:\n                # Avoid division by zero if lambda is effectively zero\n                T_model.fill(Tm)\n                return s_model, T_model\n\n            for i, t in enumerate(times):\n                if x_star > s_model[i]:\n                    T_model[i] = Tm\n                else:\n                    eta_star = x_star / (2 * np.sqrt(alpha * t))\n                    T_model[i] = Ts + (Tm - Ts) * erf(eta_star) / erf_lam\n            \n            return s_model, T_model\n\n        # 1. Generate \"measured\" data using the ground truth L\n        s_true, T_true = forward_model(L_true)\n        s_meas = s_true + delta_s\n        T_meas = T_true + delta_T\n\n        # 2. Define the objective function for the optimization\n        def objective_function(L_val):\n            \"\"\"The weighted least-squares objective function J(L).\"\"\"\n            s_model, T_model = forward_model(L_val)\n            \n            # Sum of squared residuals for interface position\n            res_s = np.sum(((s_model - s_meas) / sigma_s)**2)\n            \n            # Sum of squared residuals for temperature\n            res_T = np.sum(((T_model - T_meas) / sigma_T)**2)\n            \n            return res_s + res_T\n\n        # 3. Perform the optimization to find L_hat\n        opt_result = minimize_scalar(\n            objective_function,\n            bounds=(L_min, L_max),\n            method='bounded'\n        )\n        \n        L_hat = opt_result.x\n        results.append(int(round(L_hat)))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2523056"}]}