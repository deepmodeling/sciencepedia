{"hands_on_practices": [{"introduction": "Mastering structural modeling begins with understanding how to assemble complex components from simpler ones. This practice challenges you to build a 1-bit Arithmetic Logic Unit (ALU) slice, a cornerstone of computer processors, by structurally connecting a pre-defined full-adder with primitive logic gates [@problem_id:1964327]. The exercise sharpens your ability to implement control logic and data path selection, which are essential skills for designing versatile digital circuits.", "problem": "You are tasked with creating a 1-bit processing slice module in Verilog named `ALU_slice`. This module should be implemented using structural modeling by instantiating gate-level primitives and a provided `full_adder` module.\n\n**Module specification:**\n\nThe `ALU_slice` module has the following ports:\n- Inputs: `a` (1-bit), `b` (1-bit), `cin` (1-bit carry-in), `op` (1-bit operation select).\n- Outputs: `result` (1-bit), `cout` (1-bit carry-out).\n\n**Functional behavior:**\n\nThe module must perform one of two operations based on the `op` signal:\n1.  If `op` is `0`, the module performs a logical XOR operation.\n    - `result` should be `a XOR b`.\n    - `cout` should be `0`.\n2.  If `op` is `1`, the module performs an arithmetic ADD operation.\n    - `result` should be the sum of `a`, `b`, and `cin`.\n    - `cout` should be the carry-out from the addition.\n\n**Structural constraints:**\n\nYour design must structurally instantiate and connect the following components:\n- One `full_adder` module (Verilog code provided below).\n- One primitive `xor` gate for the logical operation.\n- One primitive `and` gate to correctly generate the final `cout` signal.\n- The logic equivalent of a 2-to-1 multiplexer, built from primitive `and`, `or`, `not` gates, to select the final `result`.\n\n**Provided `full_adder` module:**\n\nYou must use the following `full_adder` module without modification.\n\n```verilog\n// full_adder module\n// Outputs: sum, cout\n// Inputs: x, y, z\nmodule full_adder(sum, cout, x, y, z);\n  output sum, cout;\n  input  x, y, z;\n  wire   w1, w2, w3;\n\n  xor(w1, x, y);\n  xor(sum, w1, z);\n  and(w2, x, y);\n  and(w3, w1, z);\n  or(cout, w2, w3);\nendmodule\n```\n\n**Question:**\n\nWhich of the following Verilog code blocks correctly implements the `ALU_slice` module according to all specifications?\n\n**A.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, fa_sum, s_not); // MUX path for op=0 connected to fa_sum\n  and A2(w1, xor_out, op);   // MUX path for op=1 connected to xor_out\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**B.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  assign cout = fa_cout; // Incorrect cout logic\nendmodule\n```\n\n**C.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  full_adder FA(fa_sum, fa_cout, a, b, cin);\n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not); // MUX path for op=0\n  and A2(w1, fa_sum, op);     // MUX path for op=1\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```\n\n**D.**\n```verilog\nmodule ALU_slice(result, cout, a, b, cin, op);\n  output result, cout;\n  input a, b, cin, op;\n  wire fa_sum, fa_cout, xor_out;\n  wire s_not, w0, w1;\n\n  // Incorrect port mapping for full_adder\n  full_adder FA(fa_sum, fa_cout, a, b, op); \n  xor G1(xor_out, a, b);\n\n  not N1(s_not, op);\n  and A1(w0, xor_out, s_not);\n  and A2(w1, fa_sum, op);\n  or O1(result, w0, w1);\n\n  and A3(cout, fa_cout, op);\nendmodule\n```", "solution": "We need a 1-bit ALU slice that, under control of $op$, selects between:\n- Logical XOR when $op=0$: $result = a \\oplus b$, $cout=0$.\n- Arithmetic ADD when $op=1$: $result = sum(a,b,cin)$, $cout = carry\\_out(a,b,cin)$.\n\nLet the full adder outputs be $fa\\_sum$ and $fa\\_cout$ for inputs $(a,b,cin)$, so:\n- $fa\\_sum$ is the sum bit of $a+b+cin$,\n- $fa\\_cout$ is the carry-out bit.\n\nWe also instantiate one primitive XOR gate producing $xor\\_out = a \\oplus b$.\n\nThe final $result$ must be selected by a $2$-to-$1$ multiplexer built from primitive gates to satisfy:\n$$\nresult = (\\overline{op} \\cdot (a \\oplus b)) + (op \\cdot fa\\_sum)\n$$\nThis is realized structurally with one NOT gate to form $s\\_not = \\overline{op}$, and two AND gates:\n$$\nw0 = (a \\oplus b) \\cdot \\overline{op}, \\quad w1 = fa\\_sum \\cdot op\n$$\nand one OR gate:\n$$\nresult = w0 + w1\n$$\nThe required $cout$ behavior is:\n$$\ncout =\n\\begin{cases}\n0, & op=0, \\\\\nfa\\_cout, & op=1,\n\\end{cases}\n$$\nwhich is exactly the gated expression\n$$\ncout = op \\cdot fa\\_cout\n$$\nand uses a single primitive AND gate for the final $cout$ as required.\n\nNow check each option against these equations and structural constraints:\n\n- Option A connects the MUX paths as $w0 = fa\\_sum \\cdot \\overline{op}$ and $w1 = (a \\oplus b) \\cdot op$, giving\n$$\nresult = (\\overline{op}\\cdot fa\\_sum) + (op \\cdot (a \\oplus b))\n$$\nwhich inverts the required selection. Thus it fails the functional behavior.\n\n- Option B implements the correct MUX:\n$$\nresult = (\\overline{op})\\cdot (a \\oplus b) + (op \\cdot fa\\_sum)\n$$\nbut sets $cout = fa\\_cout$ unconditionally, violating $cout=0$ when $op=0$ and the requirement to use a primitive AND for the final $cout$.\n\n- Option C matches exactly:\n  - Full adder on $(a,b,cin)$,\n  - $xor\\_out = a \\oplus b$,\n  - MUX as $result = (\\overline{op})\\cdot (a \\oplus b) + (op \\cdot fa\\_sum)$ using NOT/AND/OR,\n  - $cout = op \\cdot fa\\_cout$ using one AND.\n  It satisfies both functional behavior and structural constraints.\n\n- Option D incorrectly feeds $op$ as the third input to the full adder instead of $cin$, so the addition ignores $cin$ and is functionally incorrect.\n\nTherefore, the only correct implementation is Option C.", "answer": "$$\\boxed{C}$$", "id": "1964327"}, {"introduction": "Beyond simple data processing, digital systems must often follow a specific sequence of operations, a task that requires memory. In this exercise, you will step into the realm of sequential logic by constructing a 4-bit \"twisted-ring\" counter, also known as a Johnson counter [@problem_id:1964346]. By structurally connecting a series of D-flip-flops, you will gain hands-on experience in creating state machines and understanding how feedback loops can generate predictable and useful patterns.", "problem": "In digital systems, specific sequences of states are often required for control logic. You are tasked with designing a 4-bit sequential circuit, which we will refer to as a \"twisted-ring counter\". This circuit's behavior and structure are defined as follows.\n\nThe circuit has a clock input `clk`, an active-low asynchronous reset `rst_n`, and a 4-bit output bus `Q[3:0]`. When the circuit is reset (`rst_n` is asserted low), the output `Q` must be `4'b0000`.\n\nWhen not in reset, the state transitions on every rising edge of the `clk`. The data path follows a specific shift-and-feedback pattern: the value of `Q[3]` moves to `Q[2]`, the value of `Q[2]` moves to `Q[1]`, and the value of `Q[1]` moves to `Q[0]`. The \"twist\" in this counter comes from the feedback loop: the new value for the most significant bit, `Q[3]`, is determined by the *inverted* current value of the least significant bit, `Q[0]`.\n\nYour implementation must be purely structural. You are required to use a pre-defined D-type flip-flop module named `d_ff`, which has an active-low asynchronous reset. The Verilog definition for this building block is provided here:\n\n```verilog\nmodule d_ff (\n    output reg q,\n    input d,\n    input clk,\n    input rst_n\n);\n    // On the rising edge of the clock or falling edge of reset\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            q <= 1'b0; // Asynchronous reset to 0\n        else\n            q <= d;    // Synchronous data load\n    end\nendmodule\n```\n\nYou are to complete the body of the `twisted_ring_counter` module below by structurally instantiating and connecting four instances of the `d_ff` module.\n\n```verilog\nmodule twisted_ring_counter (\n    output [3:0] Q,\n    input clk,\n    input rst_n\n);\n\n    // -- SELECT THE CORRECT CODE BLOCK FOR THIS SECTION --\n\nendmodule\n```\n\nWhich of the following Verilog code snippets correctly implements the body of the `twisted_ring_counter` module according to the specification?\n\nA.\n```verilog\nwire not_Q0;\nassign not_Q0 = ~Q[0];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q0), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nB.\n```verilog\nd_ff ff3 (.q(Q[3]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```\n\nC.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[0]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\n```\n\nD.\n```verilog\nwire not_Q3;\nassign not_Q3 = ~Q[3];\n\nd_ff ff3 (.q(Q[3]), .d(not_Q3), .clk(clk), .rst_n(rst_n));\nd_ff ff2 (.q(Q[2]), .d(Q[3]),   .clk(clk), .rst_n(rst_n));\nd_ff ff1 (.q(Q[1]), .d(Q[2]),   .clk(clk), .rst_n(rst_n));\nd_ff ff0 (.q(Q[0]), .d(Q[1]),   .clk(clk), .rst_n(rst_n));\n```", "solution": "We interpret the specification by writing next-state equations in terms of the current outputs. Let $Q_{i}^{+}$ denote the value of $Q[i]$ after the next rising edge of `clk` (assuming $rst\\_n=1$). The required transitions are:\n$$Q_{2}^{+}=Q_{3},\\quad Q_{1}^{+}=Q_{2},\\quad Q_{0}^{+}=Q_{1},\\quad Q_{3}^{+}=\\overline{Q_{0}}$$\nBecause the provided `d_ff` module loads its input `d` into its output `q` on the rising edge of `clk` (unless asynchronously reset), implementing these equations structurally requires wiring each flip-flopâ€™s `d` input to the corresponding right-hand side of the equation:\n- For $Q[3]$: `d` must be connected to $\\overline{Q[0]}$.\n- For $Q[2]$: `d` must be connected to $Q[3]$.\n- For $Q[1]$: `d` must be connected to $Q[2]$.\n- For $Q[0]$: `d` must be connected to $Q[1]$.\n\nWe check each option against these wiring requirements:\n- Option A computes a wire for $\\overline{Q[0]}$ and connects the `d` inputs as: `Q[3]` from $\\overline{Q[0]}$, `Q[2]` from `Q[3]`, `Q[1]` from `Q[2]`, and `Q[0]` from `Q[1]`. This exactly matches the required next-state equations.\n- Option B uses `Q[3]` from `Q[0]` (missing the required inversion), so it does not satisfy $Q_{3}^{+}=\\overline{Q_{0}}$.\n- Option C implements $Q[3]\\leftarrow Q[2]$, $Q[2]\\leftarrow Q[1]$, $Q[1]\\leftarrow Q[0]$, $Q[0]\\leftarrow\\overline{Q[3]}$, which shifts in the opposite direction and inverts the wrong bit for the feedback.\n- Option D uses $Q[3]\\leftarrow\\overline{Q[3]}$, which would make `Q[3]` toggle on every clock cycle regardless of `Q[0]`, violating the specified feedback loop.\n\nSince all options instantiate the same `d_ff` module which has an active-low asynchronous reset, the required reset behavior (output `Q` becomes `4'b0000` when `rst_n` is low) is correctly implemented in all four cases. The distinguishing factor is the correct wiring of the `d` inputs for the synchronous behavior. Therefore, only option A correctly implements the specified twisted-ring counter.", "answer": "$$\\boxed{A}$$", "id": "1964346"}, {"introduction": "This final practice synthesizes your skills by building a complete, efficient computing system that operates over time. You will design a bit-serial adder, which ingeniously performs multi-bit addition using only a single full adder, a flip-flop to store the carry, and a counter for control [@problem_id:1964345]. This exercise demonstrates the power of structural modeling to implement complex algorithms in hardware, highlighting the trade-offs between processing speed and circuit area.", "problem": "You are tasked with designing a 4-bit bit-serial adder in Verilog. A bit-serial adder processes multi-bit numbers one bit at a time on each clock cycle, starting from the least significant bit (LSB). This design must be purely structural, using a pre-defined `full_adder` module and flip-flops for state-holding.\n\nThe `serial_adder` module you are designing has the following interface:\n- **Inputs**:\n    - `clk`: A 1-bit clock signal.\n    - `reset`: A 1-bit active-high asynchronous reset signal. When asserted, the adder should be initialized for a new 4-bit addition.\n    - `a`, `b`: 1-bit inputs representing the current bits of the two numbers being added.\n- **Outputs**:\n    - `s`: A 1-bit output for the current sum bit.\n    - `done`: A 1-bit signal that should be asserted high for exactly one clock cycle, coinciding with the cycle when the most significant bit (MSB) sum is produced.\n\nYou are provided with a `full_adder` module with the following interface:\n`module full_adder(input a, b, cin, output s, cout);`\n\nYour `serial_adder` must be implemented according to these rules:\n1.  It must instantiate exactly one `full_adder`.\n2.  The carry-out from one bit addition must be stored and used as the carry-in for the next bit addition on the subsequent clock cycle. The initial carry-in for the LSB must be 0. This state-holding must be implemented using a register.\n3.  A 2-bit counter must be used to keep track of the bit position being processed (from bit 0 to bit 3). This counter must also be reset by the `reset` signal.\n\nBelow are four potential implementations for the body of the `serial_adder` module. Select the single option that correctly implements the specified 4-bit bit-serial adder.\n\n**Module Header:**\n`module serial_adder(input clk, reset, a, b, output s, done);`\n\n**Code Fragments:**\n\n**A.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else if (count == 2'b11)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**B.**\n```verilog\nwire carry;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry), .s(s), .cout(carry));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**C.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(carry_out));\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b1; // Reset carry to 1\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b11);\n```\n\n**D.**\n```verilog\nwire carry_out;\nreg carry_reg;\nreg [1:0] count;\n\nfull_adder fa_inst (.a(a), .b(b), .cin(carry_reg), .s(s), .cout(s)); // Incorrect connection\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        carry_reg <= 1'b0;\n    else\n        carry_reg <= carry_out;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 2'b00;\n    else\n        count <= count + 1;\nend\n\nassign done = (count == 2'b10); // Incorrect done logic\n```", "solution": "We first restate the required behavior of the 4-bit bit-serial adder:\n\n- Exactly one `full_adder` must be instantiated. The carry-out from the current bit's addition must be stored in a register and used as the carry-in for the next bit's addition on the subsequent clock cycle. The initial carry-in for the least significant bit (LSB) must be 0, which is enforced by the `reset` signal. Therefore, the carry register must have an asynchronous reset to zero.\n- A 2-bit counter must track the bit index, processing bits 0, 1, 2, and 3. This counter must also be asynchronously reset. The `done` signal must be asserted high for exactly one clock cycle, coinciding with the cycle when the sum for the most significant bit (MSB) is produced. Since the counter tracks the bit index from 0 to 3, this occurs when the counter's value is 3.\n\nWe evaluate each option against these rules.\n\n**Option A:**\n- It instantiates exactly one `full_adder`. The carry-in `cin` is driven by a register `carry_reg`, and the carry-out `cout` is captured into this register on the next clock cycle via the wire `carry_out`.\n- The `carry_reg` has an active-high asynchronous reset to `0`, satisfying the initial carry-in requirement for the LSB. On each clock edge, it correctly latches the `carry_out` from the previous cycle's addition, correctly pipelining the carry between bit times.\n- It uses a 2-bit counter `count` with an asynchronous reset to zero. The logic `if (count == 2'b11) count = 2'b00; else count = count + 1;` correctly implements a 0-1-2-3-0 counting sequence for the four bits.\n- The `done` signal is assigned combinationally as `(count == 2'b11)`. This asserts `done` when the counter value is 3 (i.e., during the MSB processing cycle). Since the counter resets to 0 on the next cycle, `done` is high for exactly one clock cycle as required. This option satisfies all constraints.\n\n**Option B:**\n- The carry signal is a wire fed from `cout` directly back into `cin`, creating a combinational feedback loop. There is no register to hold the carry between clock cycles and no mechanism to reset the carry to zero, violating both the state-holding and initial carry-in requirements.\n\n**Option C:**\n- The `carry_reg` is asynchronously reset to `1`, which violates the requirement that the initial carry-in for the LSB must be zero.\n\n**Option D:**\n- The `full_adder` instantiation is incorrect: its `cout` port is wired to `s` instead of a wire leading to the carry register.\n- The `done` logic asserts `done` when `count` is 2 (`2'b10`), not 3, so it does not coincide with the MSB sum generation.\n\nFrom this analysis, only Option A correctly implements all specifications for the 4-bit bit-serial adder.", "answer": "$$\\boxed{A}$$", "id": "1964345"}]}