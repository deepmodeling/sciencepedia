{"hands_on_practices": [{"introduction": "要将经典的PID控制理论应用于数字系统，第一步是理解其离散时间形式。本练习将指导您手动计算数字PID控制器的输出，通过对一个给定的误差信号进行逐步计算，您可以深入理解比例（P）、积分（I）和微分（D）三个部分在每个采样时刻如何共同作用，从而为控制器输出做出贡献。这个基础计算练习是掌握数字PID控制器行为的基石[@problem_id:1571856]。", "problem": "设计了一个数字控制器来调节一个小型实验炉的温度。在离散时间步 $k$ 时，控制器的输出 $u(k)$ 是施加到加热元件上的电压。该控制器实现了一种比例-积分-微分 (PID) 算法。控制电压 $u(k)$ 是根据误差信号 $e(k)$ 计算的，误差信号是期望设定点温度与实测炉温之间的差值。\n\n离散时间 PID 控制律由以下方程给出：\n$$u(k) = K_p e(k) + K_i T_s \\sum_{i=0}^{k} e(i) + \\frac{K_d}{T_s} (e(k) - e(k-1))$$\n其中：\n- $K_p$ 是比例增益。\n- $K_i$ 是积分增益。\n- $K_d$ 是微分增益。\n- $T_s$ 是采样时间。\n\n控制器具有以下参数：\n- 比例增益，$K_p = 2.0$ V/°C\n- 积分增益，$K_i = 0.8$ V/(°C·s)\n- 微分增益，$K_d = 0.5$ V·s/°C\n- 采样时间，$T_s = 0.5$ s\n\n系统在时间 $t=0$ (对应于样本 $k=0$) 时启动。在初始运行期间，观测到误差信号遵循关系式 $e(k) = A \\cdot k$，其中 $k \\in \\{0, 1, 2, ...\\}$ 是离散时间索引，$A = 0.25$ °C。\n\n假设系统在 $k=0$ 之前的所有时间都处于静止状态。这意味着求和项的初始值为零，并且上一个时间步的误差 $e(-1)$ 可以取为 $0$。\n\n计算控制器输出电压的前四个值：$u(0)$、$u(1)$、$u(2)$ 和 $u(3)$。以伏特 (Volts) 为单位表示您的答案。将这四个值 $u(0), u(1), u(2), u(3)$ 表示为一个行矩阵，每个值四舍五入到三位有效数字。", "solution": "离散时间 PID 律为\n$$u(k) = K_{p} e(k) + K_{i} T_{s} \\sum_{i=0}^{k} e(i) + \\frac{K_{d}}{T_{s}} \\left(e(k) - e(k-1)\\right).$$\n给定对于 $k \\geq 0$ 有 $e(k)=A k$，其中 $A=0.25$ 且 $e(-1)=0$，我们计算求和项和差分项：\n$$\\sum_{i=0}^{k} e(i) = \\sum_{i=0}^{k} A i = A \\sum_{i=0}^{k} i = A \\frac{k(k+1)}{2},$$\n$$e(k)-e(k-1) = \\begin{cases}\n0,  k=0,\\\\\nA,  k \\geq 1.\n\\end{cases}$$\n代入控制器参数 $K_{p}=2.0$，$K_{i}=0.8$，$K_{d}=0.5$，$T_{s}=0.5$：\n$$K_{i}T_{s}=0.8 \\cdot 0.5=0.4,\\qquad \\frac{K_{d}}{T_{s}}=\\frac{0.5}{0.5}=1.$$\n因此，\n$$u(k)=2.0\\,e(k)+0.4 \\sum_{i=0}^{k} e(i)+1\\cdot\\left(e(k)-e(k-1)\\right).$$\n当 $e(k)=0.25 k$ 且 $\\sum_{i=0}^{k} e(i)=0.25 \\cdot \\frac{k(k+1)}{2}=0.125\\,k(k+1)$ 时，我们有\n$$u(k)=2.0\\cdot(0.25 k)+0.4\\cdot(0.125\\,k(k+1))+\\left(e(k)-e(k-1)\\right).$$\n由于当 $k=0$ 时 $e(k)-e(k-1)=0$，当 $k \\geq 1$ 时等于 $0.25$，我们对每个 $k$ 进行求值：\n\n对于 $k=0$：\n$$e(0)=0,\\quad \\sum_{i=0}^{0} e(i)=0,\\quad e(0)-e(-1)=0,$$\n$$u(0)=2.0\\cdot 0+0.4\\cdot 0+1\\cdot 0=0.$$\n\n对于 $k=1$：\n$$e(1)=0.25,\\quad \\sum_{i=0}^{1} e(i)=0.125\\cdot 1\\cdot 2=0.25,\\quad e(1)-e(0)=0.25,$$\n$$u(1)=2.0\\cdot 0.25+0.4\\cdot 0.25+1\\cdot 0.25=0.5+0.1+0.25=0.85.$$\n\n对于 $k=2$：\n$$e(2)=0.5,\\quad \\sum_{i=0}^{2} e(i)=0.125\\cdot 2\\cdot 3=0.75,\\quad e(2)-e(1)=0.25,$$\n$$u(2)=2.0\\cdot 0.5+0.4\\cdot 0.75+1\\cdot 0.25=1.0+0.3+0.25=1.55.$$\n\n对于 $k=3$：\n$$e(3)=0.75,\\quad \\sum_{i=0}^{3} e(i)=0.125\\cdot 3\\cdot 4=1.5,\\quad e(3)-e(2)=0.25,$$\n$$u(3)=2.0\\cdot 0.75+0.4\\cdot 1.5+1\\cdot 0.25=1.5+0.6+0.25=2.35.$$\n\n四舍五入到三位有效数字，这些值为 $u(0)=0.000$，$u(1)=0.850$，$u(2)=1.55$，$u(3)=2.35$。", "answer": "$$\\boxed{\\begin{pmatrix} 0.000  0.850  1.55  2.35 \\end{pmatrix}}$$", "id": "1571856"}, {"introduction": "理论方程到实际代码的转换是控制工程师的一项核心技能。本练习探讨了如何将一种常见的PID变体——I-PD控制器的差分方程，转化为结构化的伪代码[@problem_id:1571851]。通过选择正确的代码实现，您将学习如何管理控制器的内部状态（如积分累加值和上一次的测量值），并理解为何将比例和微分作用于测量值而非误差，这有助于避免在设定点突变时产生“微分冲击”现象。", "problem": "在数字控制系统中，比例-积分-微分 (PID) 控制器常被修改以改善其对设定点变化的响应。其中一种修改是 I-PD 控制器，它的积分作用施加于误差信号，而比例和微分作用则直接施加于过程测量值。这种配置有助于避免“微分冲击”，即当设定点突然改变时控制器输出中出现的不希望出现的大尖峰。\n\n考虑一个数字 I-PD 控制器，其在离散时间步 $k$ 的输出 $u[k]$ 由以下差分方程组确定：\n\n$u[k] = u_I[k] - u_P[k] - u_D[k]$\n\n其中，各分项定义如下：\n1.  **积分作用 ($u_I$):** 该项随时间累积误差。\n    $u_I[k] = u_I[k-1] + K_i T_s e[k]$\n2.  **比例作用 ($u_P$):** 该项与当前测量值成比例。\n    $u_P[k] = K_p y[k]$\n3.  **微分作用 ($u_D$):** 该项与测量值的变化率成比例，通过后向差分近似。\n    $u_D[k] = \\frac{K_d}{T_s}(y[k] - y[k-1])$\n\n误差 $e[k]$ 定义为参考设定点 $r[k]$ 与过程测量值 $y[k]$ 之间的差值：\n$e[k] = r[k] - y[k]$\n\n参数如下：\n- $u[k]$: 时间步 $k$ 时的控制器输出。\n- $y[k]$: 时间步 $k$ 时的过程测量值。\n- $r[k]$: 时间步 $k$ 时的参考设定点。\n- $T_s$: 恒定的采样周期。\n- $K_p$, $K_i$, $K_d$: 分别为比例、积分和微分增益（均为正常数）。\n\n你的任务是用类C伪代码实现这个控制器。函数 `compute_control_signal` 每个采样周期 $T_s$ 调用一次。它必须正确计算输出 $u[k]$ 并为下一次调用维护必要的状态变量。该函数接收当前的 `reference` ($r[k]$) 和 `measurement` ($y[k]$)，并应返回计算出的 `output` ($u[k]$)。增益 `Kp`、`Ki`、`Kd` 和采样时间 `Ts` 作为全局常量可用。\n\n选择正确实现上述方程所定义的 I-PD 控制器的代码块。\n\nA.\n```c\nfloat compute_control_signal(float reference, float measurement) {\n    static float integral_term = 0.0;\n    static float prev_measurement = 0.0;\n\n    float error = reference - measurement;\n    integral_term = integral_term + Ki * Ts * error;\n    float p_term = Kp * measurement;\n    float d_term = (Kd / Ts) * (measurement - prev_measurement);\n    float output = integral_term - p_term - d_term;\n\n    prev_measurement = measurement;\n    return output;\n}\n```\n\nB.\n```c\nfloat compute_control_signal(float reference, float measurement) {\n    static float integral_term = 0.0;\n    static float prev_error = 0.0;\n\n    float error = reference - measurement;\n    integral_term = integral_term + Ki * Ts * error;\n    float p_term = Kp * error;\n    float d_term = (Kd / Ts) * (error - prev_error);\n    float output = p_term + integral_term + d_term;\n\n    prev_error = error;\n    return output;\n}\n```\n\nC.\n```c\nfloat compute_control_signal(float reference, float measurement) {\n    static float integral_term = 0.0;\n    static float prev_measurement = 0.0;\n\n    float error = reference - measurement;\n    integral_term = integral_term + Ki * Ts * error;\n    float p_term = Kp * measurement;\n    float d_term = (Kd / Ts) * (measurement - prev_measurement);\n    float output = p_term + integral_term + d_term;\n\n    prev_measurement = measurement;\n    return output;\n}\n```\n\nD.\n```c\nfloat compute_control_signal(float reference, float measurement) {\n    static float integral_term = 0.0;\n    static float prev_measurement = 0.0;\n\n    float error = reference - measurement;\n    integral_term = Ki * Ts * error;\n    float p_term = Kp * measurement;\n    float d_term = (Kd / Ts) * (measurement - prev_measurement);\n    float output = integral_term - p_term - d_term;\n\n    prev_measurement = measurement;\n    return output;\n}\n```", "solution": "我们已知 I-PD 控制器由以下离散时间方程定义：\n$$u[k] = u_{I}[k] - u_{P}[k] - u_{D}[k],$$\n其中\n$$u_{I}[k] = u_{I}[k-1] + K_{i} T_{s} e[k], \\quad u_{P}[k] = K_{p} y[k], \\quad u_{D}[k] = \\frac{K_{d}}{T_{s}}\\left(y[k] - y[k-1]\\right),$$\n且\n$$e[k] = r[k] - y[k].$$\n为了在代码中实现这一点，我们需要持久化的状态变量：一个用于存储 $u_{I}[k-1]$（积分累加器），另一个用于存储 $y[k-1]$（前一次的测量值）。在每次调用时：\n- 计算误差 $e[k] = r[k] - y[k]$。\n- 更新积分累加器为 $u_{I}[k] = u_{I}[k-1] + K_{i} T_{s} e[k]$。\n- 使用测量值计算比例项：$u_{P}[k] = K_{p} y[k]$。\n- 使用测量值的后向差分计算微分项：$u_{D}[k] = \\frac{K_{d}}{T_{s}}(y[k] - y[k-1])$。\n- 根据指定的符号构成输出：$u[k] = u_{I}[k] - u_{P}[k] - u_{D}[k]$。\n- 更新存储的前一次测量值：$y[k-1] \\leftarrow y[k]$。\n\n现在根据这些要求评估每个选项：\n\n选项 A：\n- 使用一个静态的积分累加器和前一次的测量值。\n- 计算 $e[k] = r[k] - y[k]$。\n- 将积分更新为 $u_{I}[k] = u_{I}[k-1] + K_{i} T_{s} e[k]$。\n- 计算 $u_{P}[k] = K_{p} y[k]$ 和 $u_{D}[k] = \\frac{K_{d}}{T_{s}}(y[k] - y[k-1])$。\n- 构成 $u[k] = u_{I}[k] - u_{P}[k] - u_{D}[k]$ 并更新 $y[k-1]$。\n这完全符合给定的方程。\n\n选项 B：\n- 对误差使用比例项和微分项，即 $u_{P}[k] = K_{p} e[k]$ 和 $u_{D}[k] = \\frac{K_{d}}{T_{s}}(e[k] - e[k-1])$。\n- 将 $u_{P} + u_{I} + u_{D}$ 相加。\n这是一个标准的基于误差的 PID，而不是 I-PD；因此不正确。\n\n选项 C：\n- 正确地对测量值使用了 $u_{P}[k] = K_{p} y[k]$ 和 $u_{D}[k] = \\frac{K_{d}}{T_{s}}(y[k] - y[k-1])$，并且正确地更新了积分项。\n- 但是，它构成了 $u[k] = u_{P}[k] + u_{I}[k] + u_{D}[k]$，其符号错误；正确的形式要求减去比例项和微分项。\n因此不正确。\n\n选项 D：\n- 对测量值使用了比例项和微分项并进行相减，符合符号约定。\n- 但是，它将积分项设置为 $K_{i} T_{s} e[k]$ 而没有累加，即省略了 $u_{I}[k-1]$。\n这未能实现积分累加，因此不正确。\n\n因此，只有选项 A 实现了所定义的 I-PD 控制器。", "answer": "$$\\boxed{A}$$", "id": "1571851"}, {"introduction": "在工程实践中，您会发现不同制造商的控制器可能采用不同的PID算法结构，最常见的有“理想”的并联形式和“交互”的串联形式。当您设计的控制器参数需要在一个采用不同结构形式的平台上实现时，参数转换就变得至关重要。本练习将引导您完成从并联型PID到串联型PID的参数转换，这不仅能锻炼您的代数推导能力，也揭示了不同PID实现方式之间的数学联系[@problem_id:1571892]。", "problem": "在控制系统领域，比例-积分-微分（PID）控制器是一种普遍存在的反馈机制。根据硬件或软件实现方式的不同，PID控制器可以有不同的结构形式。\n\n连续时间PID控制器的“理想”或“并行”形式其传递函数为：\n$$C(s) = K_p \\left( 1 + \\frac{1}{T_i s} + T_d s \\right)$$\n其中$K_p$是比例增益，$T_i$是积分时间，$T_d$是微分时间。\n\n另一种常见的实现是“串行”或“交互”形式，其传递函数为：\n$$C'(s) = K'_p \\left( 1 + \\frac{1}{T'_i s} \\right) (1 + T'_d s)$$\n其中$K'_p$、$T'_i$和$T'_d$是这种形式的相应参数。\n\n一位控制工程师使用优化算法确定了一个热过程的理想PID参数，得到了$K_p = 4.0$、$T_i = 10.0$秒和$T_d = 1.0$秒。然而，现有的可编程逻辑控制器（PLC）使用一个内置函数块，该函数块实现的是串行PID形式。为了正确地对PLC进行编程，工程师必须找到等效的串行参数。\n\n假设两个控制器是等效的，求出串行控制器参数的数值：比例增益$K'_p$、积分时间$T'_i$和微分时间$T'_d$。以一组三个数字的形式报告你的最终答案，按顺序分别对应$K'_p$、$T'_i$和$T'_d$。将$T'_i$和$T'_d$以秒为单位表示。将所有最终值四舍五入到三位有效数字。", "solution": "我们已知理想（并行）PID控制器为\n$$C(s) = K_{p}\\left(1 + \\frac{1}{T_{i} s} + T_{d} s\\right),$$\n以及串行（交互）形式\n$$C'(s) = K'_{p}\\left(1 + \\frac{1}{T'_{i} s}\\right)\\left(1 + T'_{d} s\\right).$$\n为了使它们等效，展开串行形式：\n$$(1 + \\frac{1}{T'_{i} s})(1 + T'_{d} s) = 1 + \\frac{1}{T'_{i} s} + T'_{d} s + \\frac{T'_{d}}{T'_{i}}.$$\n因此，\n$$C'(s) = K'_{p}\\left(1 + \\frac{1}{T'_{i} s} + T'_{d} s + \\frac{T'_{d}}{T'_{i}}\\right).$$\n通过匹配$1$、$s^{-1}$和$s$的系数，令$C'(s)$等于$C(s)$，可得\n$$K'_{p}\\left(1 + \\frac{T'_{d}}{T'_{i}}\\right) = K_{p}, \\quad \\frac{K'_{p}}{T'_{i}} = \\frac{K_{p}}{T_{i}}, \\quad K'_{p} T'_{d} = K_{p} T_{d}.$$\n联立求解这些方程。由第二个和第三个方程可得，\n$$T'_{i} = \\frac{K'_{p}}{K_{p}} T_{i}, \\qquad T'_{d} = \\frac{K_{p}}{K'_{p}} T_{d}.$$\n代入第一个方程：\n$$K'_{p}\\left[1 + \\frac{\\left(\\frac{K_{p}}{K'_{p}} T_{d}\\right)}{\\left(\\frac{K'_{p}}{K_{p}} T_{i}\\right)}\\right] = K_{p} \\;\\;\\Rightarrow\\;\\; K'_{p}\\left[1 + \\frac{K_{p}^{2}}{K_{p}'^{2}}\\frac{T_{d}}{T_{i}}\\right] = K_{p}.$$\n令$x = K'_{p}$。两边同乘以$x$得到二次方程\n$$x^{2} - K_{p} x + K_{p}^{2}\\frac{T_{d}}{T_{i}} = 0,$$\n其解为\n$$K'_{p} = \\frac{K_{p}}{2}\\left(1 \\pm \\sqrt{1 - \\frac{4 T_{d}}{T_{i}}}\\right), \\qquad T'_{i} = \\frac{T_{i}}{K_{p}} K'_{p}, \\qquad T'_{d} = \\frac{K_{p} T_{d}}{K'_{p}}.$$\n对于给定的值$K_{p} = 4.0$、$T_{i} = 10.0$和$T_{d} = 1.0$，\n$$K'_{p} = 2\\left(1 \\pm \\sqrt{1 - \\frac{4}{10}}\\right) = 2\\left(1 \\pm \\sqrt{0.6}\\right).$$\n这会产生两个正解。常规选择是在$T_{i} > T_{d}$时保留$T'_{i} > T'_{d}$的顺序，这对应于取正号的根：\n$$K'_{p} = 2\\left(1 + \\sqrt{0.6}\\right) \\approx 3.549193338,$$\n$$T'_{i} = \\frac{10}{4} K'_{p} \\approx 8.872983346 \\text{ s}, \\qquad T'_{d} = \\frac{4 \\cdot 1}{K'_{p}} \\approx 1.127016653 \\text{ s}.$$\n将每个值四舍五入到三位有效数字，得到\n$$K'_{p} \\approx 3.55, \\quad T'_{i} \\approx 8.87 \\text{ s}, \\quad T'_{d} \\approx 1.13 \\text{ s}.$$", "answer": "$$\\boxed{\\begin{pmatrix}3.55  8.87  1.13\\end{pmatrix}}$$", "id": "1571892"}]}