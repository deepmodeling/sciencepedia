## 引言
[模型预测控制](@entry_id:146965)（MPC）最强大的特性之一是其能够系统地处理复杂系统固有的物理、安全和性能约束。与许多在违反约束后才做出反应的传统控制方法不同，MPC在其核心的优化过程中就预见并规划如何遵守这些限制，使其成为现代控制工程中的关键技术。然而，这种前瞻性的约束处理能力也带来了独特的挑战，例如，当控制器无法找到任何满足所有约束的解时会发生什么？我们如何将从执行器变化率到[生态系统健康](@entry_id:202023)度的各种限制，都转化为优化器可以理解的统一语言？

本文旨在深入剖析在MPC中处理[状态和](@entry_id:193625)输入约束的理论与实践。我们将系统地解答上述问题，为读者提供一个全面的理解框架。文章分为三个核心章节：

首先，在 **“原理与机制”** 中，我们将奠定基础，详细介绍如何将不同类型的约束（如幅值、变化率）转化为标准的数学形式。我们还将探讨硬约束带来的核心挑战——可行性问题，并介绍软约束和[终端约束](@entry_id:176488)等保证控制器稳定运行的高级策略。

接着，在 **“应用与跨学科连接”** 中，我们将展示这些原理在现实世界中的强大威力。通过探索MPC在化学工程、机器人学、航空航天乃至生物医学和生态学等多个领域的应用，读者将看到约束处理如何解决从电池管理到人工胰腺等各种前沿问题。

最后，在 **“动手实践”** 部分，您将有机会通过一系列精心设计的问题，将所学知识付诸实践，亲手构建约束、分析可行性，并实现软约束策略，从而巩固对核心概念的理解。

让我们从约束处理的基础——它们的数学表达和内在机制——开始我们的探索之旅。

## 原理与机制

[模型预测控制](@entry_id:146965)（MPC）的一个核心优势在于其能够前瞻性地处理系统在物理、安全或性能方面的各种约束。与那些只能被动响应约束违规的传统控制器不同，MPC在其优化过程中直接将约束考虑在内，从而生成既满足当前要求又为未来操作留有余地的控制动作。本章将深入探讨在MPC框架中处理[状态和](@entry_id:193625)输入约束的原理与机制，从基本约束的数学表达到确保控制器长期稳定运行的高级策略。

### 约束的数学表达

为了让[数值优化](@entry_id:138060)器能够处理物理限制，我们必须首先将它们转化为标准的数学形式。在大多数MPC应用中，特别是对于[线性系统](@entry_id:147850)，约束被表达为一组[线性不等式](@entry_id:174297)，其通用形式为 $G\mathbf{z} \le \mathbf{h}$，其中 $\mathbf{z}$ 是优化变量（通常包括未来的控制输入序列和状态序列），$G$ 是一个矩阵，$\mathbf{h}$ 是一个向量。

#### 基本输入与状态约束

最常见的约束类型是变量的上限和下限，也称为“盒式约束”。

考虑一个直流电机，其控制输入 $u_k$ 是施加的电压。由于电源的物理限制，电压必须在最小值 $V_{min}$ 和最大值 $V_{max}$ 之间，即 $V_{min} \le u_k \le V_{max}$。在MPC中，控制器需要规划一个未来 $N_p$ 步的控制序列 $\mathbf{U} = [u_{k|k}, u_{k+1|k}, \dots, u_{k+N_p-1|k}]^T$。为了将每个 $u_{k+i|k}$ 的边界约束转化为标准[线性不等式](@entry_id:174297)形式 $M\mathbf{U} \le \mathbf{p}$，我们将每个双边不等式分解为两个单边不等式：
1.  $u_{k+i|k} \le V_{max}$
2.  $-u_{k+i|k} \le -V_{min}$

例如，对于一个[预测时域](@entry_id:261473) $N_p=2$ 的情况，控制向量为 $\mathbf{U} = [u_{k|k}, u_{k+1|k}]^T$。对 $u_{k|k}$ 和 $u_{k+1|k}$ 分别应用这两个不等式，并将它们堆叠起来，就可以得到完整的约束矩阵 $M$ 和向量 $\mathbf{p}$ [@problem_id:1579666]。具体来说，这四个不等式可以写作：
$$
\begin{pmatrix}
1  & 0 \\
-1 & 0 \\
0  & 1 \\
0  & -1
\end{pmatrix}
\begin{pmatrix} u_{k|k} \\ u_{k+1|k} \end{pmatrix}
\le
\begin{pmatrix} V_{max} \\ -V_{min} \\ V_{max} \\ -V_{min} \end{pmatrix}
$$
这种系统性的转换方法可以推广到任意长度的[预测时域](@entry_id:261473)和任意数量的输入。

同样的方法也适用于状态约束。假设一颗卫星的姿态控制系统必须确保其天线指向地球，其指向误差角 $\theta(k)$ 的[绝对值](@entry_id:147688)不能超过最大允许偏差 $\theta_{max}$，即 $|\theta(k)| \le \theta_{max}$ [@problem_id:1579658]。如果系统[状态向量](@entry_id:154607)为 $x(k) = [\theta(k), \omega(k)]^T$，其中 $\omega(k)$ 是角速度，这个[绝对值](@entry_id:147688)约束等价于两个[线性不等式](@entry_id:174297)：
1.  $\theta(k) \le \theta_{max}$
2.  $-\theta(k) \le \theta_{max}$

用矩阵形式表达，这可以写作 $M x(k) \le d$：
$$
\begin{pmatrix} 1  & 0 \\ -1 & 0 \end{pmatrix}
\begin{pmatrix} \theta(k) \\ \omega(k) \end{pmatrix}
\le
\begin{pmatrix} \theta_{max} \\ \theta_{max} \end{pmatrix}
$$
请注意，矩阵 $M$ 的设计起到了“选择器”的作用，它从状态向量中提取出我们关心的分量（在这里是 $\theta(k)$）并对其施加约束，而忽略了其他分量（如 $\omega(k)$）。

#### 处理变化率约束

除了幅值约束，执行器通常还有变化速率的限制。例如，一个大型的力矩电机可能无法瞬间改变其输出力矩。这种约束通常表现为 $|u_k - u_{k-1}| \le \Delta u_{max}$。这种约束涉及不同时间步的输入，不能直接表示为对控制序列 $\mathbf{U}$ 的简单[线性约束](@entry_id:636966)。

处理这类动态约束的一个强大技巧是**[状态增广](@entry_id:140869) (state augmentation)**。其核心思想是通过重新定义[状态和](@entry_id:193625)输入，将动态约束转化为对新变量的静态约束。考虑一个摩天大楼中的主动质量阻尼器系统，其执行器施加的力 $u_k$ 不仅有幅值限制 $|u_k| \le F_{max}$，还有变化率限制 $|u_k - u_{k-1}| \le \dot{F}_{max} \Delta t$ [@problem_id:1579628]。

为了处理这个变化率约束，我们定义一个新的增广状态向量 $\mathbf{z}_k$，它包含原始状态 $\mathbf{x}_k$ 和前一时刻的输入 $u_{k-1}$：
$$
\mathbf{z}_k = \begin{pmatrix} \mathbf{x}_k \\ u_{k-1} \end{pmatrix}
$$
同时，我们将优化变量从输入本身 $u_k$ 改为其变化量 $v_k = u_k - u_{k-1}$。现在，$v_k$ 成为了新的控制输入。基于这些新定义，原始系统的动态方程 $\mathbf{x}_{k+1} = A_d \mathbf{x}_k + B_d u_k$ 可以被重写为关于 $\mathbf{z}_k$ 和 $v_k$ 的增广系统：
$$
\mathbf{z}_{k+1} = \begin{pmatrix} \mathbf{x}_{k+1} \\ u_k \end{pmatrix} = \begin{pmatrix} A_d  & B_d \\ \mathbf{0}^T  & 1 \end{pmatrix} \mathbf{z}_k + \begin{pmatrix} B_d \\ 1 \end{pmatrix} v_k
$$
这个转换的精妙之处在于它如何改变了约束的表达形式：
*   **变化率约束**: 原始的变化率约束 $|u_k - u_{k-1}| \le \dot{F}_{max} \Delta t$ 直接变成了对新输入 $v_k$ 的简单幅值约束 $|v_k| \le \dot{F}_{max} \Delta t$。
*   **幅值约束**: 原始的幅值约束 $|u_k| \le F_{max}$ 转换为了一个耦合的约束，因为它涉及到新的[状态和](@entry_id:193625)输入：$|u_{k-1} + v_k| \le F_{max}$。由于 $u_{k-1}$ 是增广状态 $\mathbf{z}_k$ 的一部分，这变成了一个形如 $|c^T\mathbf{z}_k + v_k| \le F_{max}$ 的约束。

通过[状态增广](@entry_id:140869)，所有约束都变成了关于当前（增广）[状态和](@entry_id:193625)当前（新）输入的静态约束，这使得它们可以被标准MPC优化器处理。

### 硬约束的挑战：可行性问题

将约束整合到MPC中是其强大功能的核心，但“硬约束”（即必须在任何时候都严格满足的约束）也带来了独特的挑战，其中最主要的就是**可行性 (feasibility)** 问题。如果MPC优化器在任何一个时间步无法找到任何一个满足所有约束的控制序列，该问题就被称为**不可行 (infeasible)**，控制器将无法产生控制动作。

#### 初始状态导致的问题

最直接的[不可行性](@entry_id:164663)来源是当系统的初始状态已经违反了硬约束。考虑一个[生物反应器](@entry_id:188949)，其温度 $T(k)$ 必须始终低于 $T_{max}$ [@problem_id:1579679]。如果由于某种故障，控制器在启动时测量的初始温度 $T(0)$ 就已经高于 $T_{max}$，那么MPC问题在第一步就是不可行的。

其根本原因在于，MPC的优化是在当前状态 $x(k)$ 的基础上规划未来。约束 $T(j|k) \le T_{max}$ 在[预测时域](@entry_id:261473)内的所有点（包括 $j=0$）都必须满足。当 $j=0$ 时，预测状态 $T(0|k)$ 就是当前测量的状态 $T(k)$。如果 $T(k) > T_{max}$，那么第一个约束就已经被违反，而这个约束的满足与否与控制器将要计算的任何未来控制输入无关。因此，[优化问题](@entry_id:266749)的可行集从一开始就是空的，导致优化失败。

#### 有限[预测时域](@entry_id:261473)的“短视”效应

一个更微妙但同样严重的[不可行性](@entry_id:164663)问题源于MPC的有限[预测时域](@entry_id:261473)。控制器是“短视的”，它只关心在未来 $N$ 步内是否能满足约束。这种短视可能导致控制器做出看似合理但最终将系统引入“死胡同”的决策。

一个经典的例子是自动驾驶汽车的紧急制动场景 [@problem_id:1579651]。汽车的MPC控制器被要求确保其位置 $p_k$ 始终小于障碍物的位置 $p_{obs}$。假设汽车的[预测时域](@entry_id:261473) $N$ 较短。当汽车距离障碍物还很远时，控制器可能认为没有必要立即制动，因为在未来的 $N$ 步内，即使以当前速度行驶也不会撞上障碍物。因此，它会继续保持速度。

然而，随着汽车越来越接近障碍物，它最终会进入一个“无法挽回”的状态区域：即在该状态下（由其当前位置和速度共同决定），即使立即采取最大制动，也无法在未来 $N$ 步的预测窗口内避免预测位置超过 $p_{obs}$。一旦进入这个状态，MPC优化器将无法找到任何一个满足 $p_k \le p_{obs}$ 的有效制动序列，从而宣告问题不可行。

这个问题说明，可行性不仅取决于当前状态是否在约束边界内，还取决于系统是否处于一个能够在有限的未来内持续满足约束的状态集合中。较短的[预测时域](@entry_id:261473)会使控制器对远期的危险视而不见，从而更容易将系统带入不可行的区域。

### 恢复与保证可行性的策略

面对硬约束带来的可行性挑战，研究人员和工程师开发了多种策略来增强MPC的鲁棒性。

#### 软约束：一种实用的解决方案

处理偶发或不可避免的约束违规的最常用方法是**软约束 (soft constraints)**。其核心思想是允许约束在一定程度上被违反，但对违规行为施加惩罚。这样，优化器会尽量避免违规，但当违规不可避免时（例如为了防止整个问题变得不可行），它会选择一个“最小化违规”的解。

实现软约束的标准方法是引入非负的**[松弛变量](@entry_id:268374) (slack variables)**。考虑一个机器人手臂，其关节角度 $\theta_k$ 有一个理想的工作范围 $|\theta_k| \le \theta_{lim}$ [@problem_id:1579644]。为了将其软化，我们将约束修改为：
$$
|\theta_k| \le \theta_{lim} + \epsilon_k, \quad \text{其中 } \epsilon_k \ge 0
$$
$\epsilon_k$ 就是一个[松弛变量](@entry_id:268374)。如果 $\epsilon_k = 0$，则原始约束被满足。如果 $\epsilon_k > 0$，则表示约束被违反了 $\epsilon_k$ 的量。

为了让优化器尽可能保持 $\epsilon_k$ 为零，我们在目标函数中加入一个对它的惩罚项。例如，可以将阶段成本函数 $L(x_k, u_k)$ 修改为：
$$
L_{soft}(x_k, u_k, \epsilon_k) = x_k^T Q x_k + u_k^T R u_k + \rho_s \epsilon_k^2
$$
其中 $\rho_s$ 是一个很大的权重因子，用于惩罚约束违规。通过调整 $\rho_s$ 的大小，我们可以控制约束的“软硬程度”。

当面临像前述生物反应器中初始状态违规的问题时，软约束提供了一个优雅的解决方案 [@problem_id:1579625]。通过将硬约束 $x_k \le 2.0$ 替换为软约束 $x_k \le 2.0 + \epsilon_k$，并向总目标函数中添加惩罚项 $\sum_{k=1}^{N} M \epsilon_k^2$，即使初始状态 $x_0 = 2.5$ 违反了原始约束，[优化问题](@entry_id:266749)依然是可行的。优化器会选择一个足够大的 $\epsilon_1$ 来满足第一个预测步的约束，尽管这会带来一定的成本。这种方法极大地提高了MPC控制器在现实世界中的鲁棒性。

最终的目标函数将变为：
$$
J_{soft} = P x_N^2 + \sum_{k=0}^{N-1} (Q x_k^2 + R u_k^2) + \sum_{k=1}^{N} M \epsilon_k^2
$$

#### [递归可行性](@entry_id:167169)与[终端约束](@entry_id:176488)

软约束解决了燃眉之急，但对于安全关键系统，我们可能需要更强的保证，即确保控制器在任何时候都不会失效。这就引出了**[递归可行性](@entry_id:167169) (recursive feasibility)** 的概念：如果MPC问题在当前时刻 $k$ 是可行的，我们能否保证它在下一时刻 $k+1$ 也必定是可行的？

对于标准的有限时域MPC，答案通常是否定的。原因在于，在时刻 $k$ 计算出的[最优控制](@entry_id:138479)序列 $\{u^*(0|k), \dots, u^*(N-1|k)\}$ 是“贪婪”的，它只为当前的 $N$ 步时域寻找最优解。当控制器应用第一个动作 $u^*(0|k)$ 后，系统转移到新状态 $x_{k+1}$。这个新状态 $x_{k+1}$ 并不保证它是一个“好的”起点，也就是说，从 $x_{k+1}$ 出发，不一定存在一个满足未来 $N$ 步约束的控制序列 [@problem_id:1579662]。

为了从理论上保证[递归可行性](@entry_id:167169)，一种经典的方法是引入**[终端约束](@entry_id:176488) (terminal constraint)** 和**控制[不变集](@entry_id:275226) (control invariant set)** [@problem_id:1579678]。

一个集合 $\mathcal{X}_f$ 被称为控制[不变集](@entry_id:275226)，如果对于该集合中的任何状态 $\tilde{x} \in \mathcal{X}_f$，都存在一个容许的控制输入 $\tilde{u} \in \mathcal{U}$，使得系统的下一个状态 $A\tilde{x} + B\tilde{u}$ 仍然位于 $\mathcal{X}_f$ 内。

通过在MPC[优化问题](@entry_id:266749)中增加一个[终端约束](@entry_id:176488)，即要求[预测时域](@entry_id:261473)的最后一个状态必须位于一个预先计算好的控制[不变集](@entry_id:275226)内 ($x(N|t) \in \mathcal{X}_f$)，我们就可以保证[递归可行性](@entry_id:167169)。其证明思路如下：
1.  假设在时刻 $t$，[优化问题](@entry_id:266749)是可行的，并找到了一个最优控制序列 $U_t^*$，它将系统状态从 $x_t$ 驱动到 $x^*(N|t) \in \mathcal{X}_f$。
2.  控制器应用第一个动作 $u^*(0|t)$，系统在时刻 $t+1$ 到达状态 $x_{t+1} = x^*(1|t)$。
3.  在时刻 $t+1$，我们需要证明至少存在一个可行的控制序列。我们可以构造这样一个序列：
    *   **平移 (Shift)**: 将时刻 $t$ 的最优序列向前提一格，使用 $\{u^*(1|t), \dots, u^*(N-1|t)\}$ 作为新序列的前 $N-1$ 个动作。根据时刻 $t$ 的最优解，这个序列是可行的，它会将状态从 $x_{t+1}$ 驱动到 $x^*(N|t)$。
    *   **追加 (Append)**: 当状态到达 $x^*(N|t)$ 时，由于 $x^*(N|t)$ 位于控制[不变集](@entry_id:275226) $\mathcal{X}_f$ 中，根据定义，我们知道必然存在一个控制输入 $\tilde{u}$，它能使下一个状态仍然保持在 $\mathcal{X}_f$ 内。我们将这个 $\tilde{u}$ 作为新序列的最后一个动作。

这个“平移并追加”的构造过程证明了在时刻 $t+1$ 总是存在一个可行的（尽管不一定是最优的）控制序列。这就保证了MPC问题永远不会变得不可行，从而为系统的长期稳定运行提供了理论基础。

### 扩展：处理不确定性的鲁棒约束

到目前为止，我们都假设系统模型是完美的。在现实中，系统总是会受到未知扰动和[模型不确定性](@entry_id:265539)的影响。[鲁棒MPC](@entry_id:174393)旨在即使在存在不确定性的情况下也能严格满足约束。

#### 约束收紧

处理有界扰动的一个基本方法是**约束收紧 (constraint tightening)**。考虑一个受到有界加性扰动 $w(k)$ 影响的系统 $x(k+1) = A x(k) + b u(k) + d w(k)$，其中 $|w(k)| \le w_{max}$ [@problem_id:1579690]。

我们的目标是确保**真实**的系统状态 $x_{true}(k)$ 始终满足某个约束，例如 $h^T x_{true}(k) \le g$。然而，MPC是基于**标称**模型（即假设 $w(k)=0$）进行规划的，它只能对标称状态 $x_{nom}(k)$ 施加约束。

由于扰动的存在，真实状态会偏离标称状态。这个偏差 $e(k) = x_{true}(k) - x_{nom}(k)$ 会随着时间累积。为了保证真实状态不违规，我们必须对标称状态施加一个更严格的、“收紧”了的约束：
$$
h^T x_{nom}(k) \le g_{tight}
$$
收紧的量必须足以覆盖在任何可能的扰动序列下，真实状态相对于标称状态可能产生的最大偏差。对于一个[预测时域](@entry_id:261473) $N$，在第 $i$ 步的预测偏差可以表示为扰动历史的线性组合。在[预测时域](@entry_id:261473)末端，总偏差在 $h$ 方向上的最坏情况是：
$$
\Delta = \max_{|w_j| \le w_{max}} h^T e_N = w_{max} \sum_{j=0}^{N-1} |h^T A^{N-1-j} d|
$$
因此，收紧后的约束界限为 $g_{tight} = g - \Delta$。通过在标称轨迹周围留出足够的“安全裕度”，我们可以保证即使在最坏的扰动情况下，真实的系统状态轨迹仍然会保持在原始的约束边界之内。这种约束收紧技术是构建[鲁棒MPC](@entry_id:174393)控制器的基石。