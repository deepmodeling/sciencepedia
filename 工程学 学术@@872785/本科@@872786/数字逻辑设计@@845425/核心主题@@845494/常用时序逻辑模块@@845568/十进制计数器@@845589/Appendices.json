{"hands_on_practices": [{"introduction": "十进制计数器不仅用于计数，它们在定时和频率划分电路中也扮演着核心角色。这项练习将引导你分析一个基本十进制计数器输出信号的特性，特别是其频率和占空比。通过这个练习，你将深入理解计数器的状态序列如何决定其作为信号发生器的基本属性[@problem_id:1927040]。", "problem": "一个标准的同步十进制计数器，也称为二-十进制（BCD）计数器，其设计为循环经历代表十进制数字0到9（二进制 `0000` 到 `1001`）的状态，然后在下一个时钟脉冲时复位到 `0000`。计数器的状态由其四个触发器的输出表示：$Q_D$、$Q_C$、$Q_B$ 和 $Q_A$，其中 $Q_D$ 是最高有效位（MSB），$Q_A$ 是最低有效位（LSB）。\n\n该计数器由一个频率为 $f_{in} = 1.00 \\text{ MHz}$ 的连续且稳定的输入时钟信号驱动。\n\n您的任务是分析最高有效位 $Q_D$ 处的输出信号。确定该信号的两个属性：\n1. 其频率，$f_{out}$。\n2. 其占空比，定义为信号在一个周期内处于高逻辑电平的时间所占的比例。\n\n将频率 $f_{out}$ 以 kHz 为单位表示。将占空比表示为小数值。在您的答案中提供这两个值，频率在前，占空比在后。", "solution": "一个同步十进制（BCD）计数器会循环经历10个不同的状态，从十进制0到9，每个输入时钟周期对应一个状态。设输入时钟周期为 $T_{in} = \\frac{1}{f_{in}}$。\n\n在一个包含10个计数的完整周期内，输出模式会重复，因此任何与状态相关的输出的输出周期为\n$$\nT_{out} = 10\\,T_{in} = \\frac{10}{f_{in}}, \\quad \\text{hence} \\quad f_{out} = \\frac{1}{T_{out}} = \\frac{f_{in}}{10}.\n$$\n已知 $f_{in} = 1.00 \\times 10^{6}\\ \\text{Hz} = 1000\\ \\text{kHz}$，可得出\n$$\nf_{out} = \\frac{1000\\ \\text{kHz}}{10} = 100\\ \\text{kHz}.\n$$\n\n对于最高有效位 $Q_{D}$，该位仅在计数为$8$或$9$时为高电平，即在10个状态中恰好有2个状态。因此，在一个输出周期 $T_{out}$ 内，高电平时间为\n$$\nt_{H} = 2\\,T_{in},\n$$\n占空比为\n$$\nD = \\frac{t_{H}}{T_{out}} = \\frac{2\\,T_{in}}{10\\,T_{in}} = \\frac{2}{10} = 0.2.\n$$\n\n因此，以 kHz 为单位的频率和占空比（以小数表示）分别为 $100$ 和 $0.2$。", "answer": "$$\\boxed{\\begin{pmatrix}100  0.2\\end{pmatrix}}$$", "id": "1927040"}, {"introduction": "在理解了计数器的基本序列后，下一步是学习如何定制它。这项练习将挑战你解决一个常见的设计问题：如何强制一个标准计数器跳过某个特定状态。你将学习如何设计组合逻辑来控制计数器的同步加载功能，从而展示了如何利用现成的组件创建自定义的计数序列[@problem_id:1927096]。", "problem": "一个商用同步4位二进制编码的十进制（BCD）递增计数器集成电路被用于一个显示驱动系统中。该计数器有四个数据输出，$Q_D, Q_C, Q_B, Q_A$，其中$Q_D$是最高有效位（MSB）。此计数器的正常工作模式是按顺序从BCD状态0（0000）循环到9（1001），在每个时钟上升沿递增。\n\n该计数器还具有一个高电平有效的同步`LOAD`输入。如果`LOAD`输入保持在逻辑高电平，计数器状态将在下一个时钟上升沿被其并行数据输入（$P_D, P_C, P_B, P_A$）上的4位数值所取代。如果`LOAD`输入保持在逻辑低电平，计数器正常递增。\n\n一个特定的应用需要修改计数器的序列以跳过数值状态5。所期望的序列是0, 1, 2, 3, 4, 6, 7, 8, 9，然后回滚到0。为了实现这一点，并行数据输入（$P_D, P_C, P_B, P_A$）将被永久连接到数字6的BCD表示。您的任务是设计必要的外部组合逻辑来生成`LOAD`信号。该逻辑将以计数器的输出（$Q_D, Q_C, Q_B, Q_A$）作为其输入。\n\n确定以计数器输出表示的`LOAD`信号的最小积之和（SOP）布尔表达式。在您的表达式中，使用上划线（例如，$\\overline{A}$）来表示逻辑非运算。", "solution": "我们需要一个同步机制，以确保在时钟上升沿之后永远不会进入状态5。由于有一个高电平有效的同步LOAD，它会在下一个上升沿加载并行输入上的值，并且并行输入被硬连接到数字6的BCD码，正确的策略是仅当当前计数器状态等于4时才使LOAD有效。然后，当从状态4到达时钟沿时，计数器将加载6而不是递增到5，从而产生所需的转换 $4 \\to 6$，并因此在时钟沿采样的序列中完全跳过5。\n\n设输出为$Q_D$（MSB）、$Q_C$、$Q_B$、$Q_A$（LSB）。十进制4的BCD码是$0100$，对应于$Q_D=0$，$Q_C=1$，$Q_B=0$，$Q_A=0$。因此，在正常的BCD操作期间，`LOAD`信号必须仅在这种输入组合下为$1$，在其他情况下为$0$。\n\n用于检测状态4的相应最小项（乘积项）是\n$$\n\\overline{Q_{D}}\\,Q_{C}\\,\\overline{Q_{B}}\\,\\overline{Q_{A}}.\n$$\n没有其他状态被指定为无关项，并且只有一个状态必须使LOAD有效，所以最小积之和恰好是这个单一的乘积项。\n\n因此，`LOAD`信号的最小SOP布尔表达式是\n$$\n\\overline{Q_{D}}\\,Q_{C}\\,\\overline{Q_{B}}\\,\\overline{Q_{A}}.\n$$", "answer": "$$\\boxed{\\overline{Q_{D}}\\,Q_{C}\\,\\overline{Q_{B}}\\,\\overline{Q_{A}}}$$", "id": "1927096"}, {"introduction": "从分立逻辑设计过渡到现代数字系统实现，最后的这项实践将重点放在使用硬件描述语言（HDL）来描述一个十进制计数器。你的任务是识别出正确的Verilog代码，该代码实现了一个具有同步使能和异步复位等特定功能的计数器。这项练习对于理解抽象的逻辑概念如何转化为用于FPGA或ASIC的可综合代码至关重要[@problem_id:1927087]。", "problem": "您的任务是为一个数字频率合成器设计一个核心组件。该组件是一个 4 位同步十进制计数器，具有以下规范：\n\n- **输入**:\n    - `clk`: 时钟信号。所有同步操作都在 `clk` 的上升沿发生。\n    - `reset_n`: 一个异步、低电平有效的复位信号。当 `reset_n` 为逻辑 0 时，计数器的输出 `q` 必须立即且无条件地设置为 0。\n    - `count_en`: 一个同步、高电平有效的计数使能信号。当 `count_en` 为逻辑 1 时，计数器在下一个时钟上升沿递增。如果 `count_en` 为逻辑 0，计数器保持其当前值。\n\n- **输出**:\n    - `q`: 一个 4 位寄存器，用于保持当前计数值。\n\n- **行为**:\n    - 计数器必须按十进制序列 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 循环计数。\n    - 当计数达到 9 时，如果计数器被使能，下一个时钟上升沿的状态必须是 0。\n\n以下哪个 Verilog 代码片段正确地提供了该十进制计数器的行为描述？\n\nA.\n```verilog\nmodule decade_counter (output reg [3:0] q, input clk, input count_en, input reset_n);\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            q = 4'd0;\n        else if (count_en) begin\n            if (q == 4'd9)\n                q = 4'd0;\n            else\n                q = q + 1;\n        end\n    end\nendmodule\n```\n\nB.\n```verilog\nmodule decade_counter (output reg [3:0] q, input clk, input count_en, input reset_n);\n    always @(posedge clk) begin\n        if (!reset_n)\n            q = 4'd0;\n        else if (count_en) begin\n            if (q == 4'd9)\n                q = 4'd0;\n            else\n                q = q + 1;\n        end\n    end\nendmodule\n```\n\nC.\n```verilog\nmodule decade_counter (output reg [3:0] q, input clk, input count_en, input reset_n);\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            q = 4'd0;\n        else if (count_en) begin\n            if (q == 4'd10)\n                q = 4'd0;\n            else\n                q = q + 1;\n        end\n    end\nendmodule\n```\n\nD.\n```verilog\nmodule decade_counter (output reg [3:0] q, input clk, input count_en, input reset_n);\n    always @(posedge clk or negedge reset_n) begin\n        if (!reset_n)\n            q = 4'd0;\n        else if (count_en) begin\n            if (q == 4'd9)\n                q = 4'd0;\n            else\n                q = q + 1;\n        end\n    end\nendmodule\n```\n\nE.\n```verilog\nmodule decade_counter (output reg [3:0] q, input clk, input count_en, input reset_n);\n    always @(posedge clk or negedge reset_n or posedge count_en) begin\n        if (!reset_n)\n            q = 4'd0;\n        else if (count_en) begin\n            if (q == 4'd9)\n                q = 4'd0;\n            else\n                q = q + 1;\n        end\n    end\nendmodule\n```", "solution": "我们根据指定的要求逐一分析每个选项：异步、低电平有效的复位；在时钟上升沿进行同步操作；同步、高电平有效的计数使能；十进制序列 0 到 9，并在使能时从 9 翻转到 0；以及正确的时序编码风格。\n\n- 要求含义：\n  1) 异步、低电平有效的复位意味着 always 块的敏感列表中必须包含复位信号的下降沿 (negedge)，并且复位分支必须无条件地将 $q$ 设置为 $4'd0$。\n  2) 同步行为意味着敏感列表中唯一的时钟是 $clk$ 的上升沿；敏感列表中不应出现其他控制信号。\n  3) 使能是同步且高电平有效的，因此只有当 $count\\_en$ 为 $1$ 时，才会在时钟块内部发生递增。\n  4) 十进制翻转要求在使能时测试 $q==4'd9$ 并将 $q$ 设置为 $4'd0$，否则加一。\n  5) Verilog 中的时序逻辑应在时钟驱动的 always 块中使用非阻塞赋值 (`=`) 来正确地模拟寄存器行为。\n\n- 选项 A:\n  敏感列表包含 $posedge\\ clk$ 和 $negedge\\ reset\\_n$，满足异步复位要求。功能上，该逻辑测试 $q==4'd9$ 并翻转，并且仅在 $count\\_en$ 为 $1$ 时递增，这是正确的。然而，它在时序 always 块中使用了阻塞赋值 (`=`)，这不是正确的时序编码风格，可能导致仿真与综合不匹配。因此，根据最佳实践，这不是正确的行为描述。\n\n- 选项 B:\n  always 块仅对 $posedge\\ clk$ 敏感。复位在块内部检查，因此复位是同步的，违反了异步复位要求。因此，不正确。\n\n- 选项 C:\n  具有异步复位并使用了非阻塞赋值，但翻转条件是 $q==4'd10$。这会导致序列在复位前经过 $10$：当 $q=9$ 且 $count\\_en=1$ 时，它会递增到 $10$（因为在该时钟沿 $q==10$ 为假），然后在下一个使能的时钟沿才复位到 $0$。这违反了十进制序列的要求。因此，不正确。\n\n- 选项 D:\n  敏感列表包含 $posedge\\ clk$ 和 $negedge\\ reset\\_n$（异步、低电平有效的复位），使用了非阻塞赋值，仅在 $count\\_en$ 为 $1$ 时递增，并且在 $q==4'd9$ 时精确地翻转到 $4'd0$。当 $count\\_en=0$ 时，没有赋值操作，寄存器自然保持其值。这符合所有要求。因此，正确。\n\n- 选项 E:\n  敏感列表除了时钟和复位外，还包含了 $posedge\\ count\\_en$，这使得该块也会在使能信号的边沿触发，违反了所有同步操作仅在 $clk$ 的上升沿发生的要求。因此，不正确。\n\n因此，只有选项 D 满足所有指定的行为要求和正确的时序编码实践。", "answer": "$$\\boxed{D}$$", "id": "1927087"}]}