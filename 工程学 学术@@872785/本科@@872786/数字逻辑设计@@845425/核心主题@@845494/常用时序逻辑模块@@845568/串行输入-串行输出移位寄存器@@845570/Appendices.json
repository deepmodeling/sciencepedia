{"hands_on_practices": [{"introduction": "这个练习旨在巩固串入串出（SISO）移位寄存器的基本工作原理。通过逐个时钟周期地追踪寄存器内部状态的变化，你将能够直观地理解数据是如何在寄存器中移动和被新数据替代的。这是掌握更复杂移位寄存器应用的基础。[@problem_id:1959756]", "problem": "一个4位临时数据缓冲器是使用一个串行输入、串行输出（SISO）移位寄存器实现的。寄存器的位标记为 $Q_3, Q_2, Q_1, Q_0$，其中 $Q_3$ 是最高有效位（MSB），$Q_0$ 是最低有效位（LSB）。在每个时钟脉冲的上升沿，数据向右移动一个位置：串行数据输入 $D_{in}$ 的值被加载到 $Q_3$ 中；$Q_3$ 的前一个值移动到 $Q_2$；$Q_2$ 移动到 $Q_1$；$Q_1$ 移动到 $Q_0$。原本在 $Q_0$ 中的值被移出。\n\n最初，寄存器中存储的二进制值为 `1011`。在接下来的连续四个时钟脉冲中，串行数据输入线 $D_{in}$ 保持恒定的逻辑'0'。在第四个时钟脉冲之后，寄存器中存储的、表示为 $Q_3Q_2Q_1Q_0$ 的二进制值是什么？\n\nA. 0000\n\nB. 0001\n\nC. 0101\n\nD. 1101\n\nE. 1011", "solution": "问题要求一个4位串行输入、串行输出（SISO）移位寄存器在四个时钟脉冲之后的内容。设寄存器的状态由二进制字符串 $Q_3Q_2Q_1Q_0$ 表示。该寄存器在每个时钟脉冲上将其内容向右移一位。这意味着新状态 $(Q_3', Q_2', Q_1', Q_0')$ 由旧状态 $(Q_3, Q_2, Q_1, Q_0)$ 和串行输入 $D_{in}$ 决定，如下所示：\n$Q_3' = D_{in}$\n$Q_2' = Q_3$\n$Q_1' = Q_2$\n$Q_0' = Q_1$\n\n我们已知初始状态和输入条件。\n初始状态（任何脉冲之前）：$Q_3Q_2Q_1Q_0 = 1011$\n串行输入：$D_{in} = 0$（在所有四个脉冲中保持不变）\n\n我们可以追踪每个时钟脉冲后寄存器的状态。\n\n**在第1个时钟脉冲后：**\n$Q_3$ 的新值将是输入，$D_{in} = 0$。\n$Q_2$ 的新值将是 $Q_3$ 的旧值，即 1。\n$Q_1$ 的新值将是 $Q_2$ 的旧值，即 0。\n$Q_0$ 的新值将是 $Q_1$ 的旧值，即 1。\n所以，寄存器的状态变为 $0101$。\n\n**在第2个时钟脉冲后：**\n输入仍为 $D_{in} = 0$。寄存器上一步的状态是 $0101$。\n$Q_3$ 的新值将是 $D_{in} = 0$。\n$Q_2$ 的新值将是 $Q_3$ 的旧值，即 0。\n$Q_1$ 的新值将是 $Q_2$ 的旧值，即 1。\n$Q_0$ 的新值将是 $Q_1$ 的旧值，即 0。\n所以，寄存器的状态变为 $0010$。\n\n**在第3个时钟脉冲后：**\n输入仍为 $D_{in} = 0$。寄存器上一步的状态是 $0010$。\n$Q_3$ 的新值将是 $D_{in} = 0$。\n$Q_2$ 的新值将是 $Q_3$ 的旧值，即 0。\n$Q_1$ 的新值将是 $Q_2$ 的旧值，即 0。\n$Q_0$ 的新值将是 $Q_1$ 的旧值，即 1。\n所以，寄存器的状态变为 $0001$。\n\n**在第4个时钟脉冲后：**\n输入仍为 $D_{in} = 0$。寄存器上一步的状态是 $0001$。\n$Q_3$ 的新值将是 $D_{in} = 0$。\n$Q_2$ 的新值将是 $Q_3$ 的旧值，即 0。\n$Q_1$ 的新值将是 $Q_2$ 的旧值，即 0。\n$Q_0$ 的新值将是 $Q_1$ 的旧值，即 0。\n所以，寄存器的状态变为 $0000$。\n\n因此，在第四个时钟脉冲后，寄存器中存储的最终二进制值是 `0000`。这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1959756"}, {"introduction": "这个练习将挑战你的分析和逆向推理能力。在一个数字系统中，我们常常需要根据观察到的输出和已知的输入来推断系统的初始状态，这在调试过程中至关重要。通过解决这个问题，你将学会如何“倒推”移位寄存器的操作，从而加深对其确定性行为的理解。[@problem_id:1959752]", "problem": "一位数字工程师正在调试一个使用4位串行输入、串行输出 (SISO) 移位寄存器的通信协议。该寄存器在每个时钟信号的上升沿将数据向右移位。设寄存器的状态由二进制字符串 $Q_3Q_2Q_1Q_0$ 表示，其中 $Q_3$ 是最高有效位 (MSB)，$Q_0$ 是最低有效位 (LSB)。在每个时钟周期，串行输入位被移入最高有效位 (MSB) 位置 ($Q_3$)，$Q_i$ 的内容被移动到 $Q_{i-1}$ (对于 $i=3, 2, 1$)，而 $Q_0$ 的内容作为串行输出被移出。\n\n该工程师在三个连续的时钟周期内应用了串行输入序列 `011`（应用的第一个比特是 `0`）。在第三个时钟周期后，测得寄存器的状态为 `1101`。在此过程中，观察到串行移出的比特序列为 `101`（移出的第一个比特是 `1`）。\n\n确定第一个时钟周期之前寄存器的初始4位状态。请用一个4位二进制字符串 $Q_3Q_2Q_1Q_0$ 来表示你的答案。", "solution": "设初始状态为 $S_{0}=(Q_{3},Q_{2},Q_{1},Q_{0})=(a,b,c,d)$。对于一个右移的4位SISO寄存器，串行输入 $x$ 进入 $Q_{3}$，每个时钟周期的更新规则是\n$$\nQ_{3}^{+}=x,\\quad Q_{2}^{+}=Q_{3},\\quad Q_{1}^{+}=Q_{2},\\quad Q_{0}^{+}=Q_{1},\n$$\n且该时钟周期的串行输出是移位前的 $Q_{0}$。\n\n时钟周期1：输入 $x_{1}=0$，输出 $y_{1}=d$。已知 $y_{1}=1$，可得 $d=1$。移位后的状态为 $S_{1}=(0,a,b,c)$。\n\n时钟周期2：输入 $x_{2}=1$，输出 $y_{2}$ 为 $S_{1}$ 中的 $Q_{0}$，所以 $y_{2}=c$。已知 $y_{2}=0$，可得 $c=0$。移位后的状态为 $S_{2}=(1,0,a,b)$。\n\n时钟周期3：输入 $x_{3}=1$，输出 $y_{3}$ 为 $S_{2}$ 中的 $Q_{0}$，所以 $y_{3}=b$。已知 $y_{3}=1$，可得 $b=1$。移位后的状态为 $S_{3}=(1,1,0,a)$。\n\n第三个时钟周期后测得的状态是 $S_{3}=(1,1,0,1)$，因此 $a=1$。所以，初始状态为 $(a,b,c,d)=(1,1,0,1)$，即 $Q_{3}Q_{2}Q_{1}Q_{0}=1101$。", "answer": "$$\\boxed{1101}$$", "id": "1959752"}, {"introduction": "理想的电路模型是学习的起点，但现实世界的硬件可能会出现故障。本练习引入了一个常见的“卡住”故障模型，要求你分析一个非理想移位寄存器的行为。通过这种方式，你不仅能巩固对标准移位操作的理解，还能培养在实际工程中诊断和预测故障影响的能力。[@problem_id:1959731]", "problem": "考虑一个由D型触发器构成的6位同步串行输入、串行输出（SISO）移位寄存器。该寄存器被设计为在每个时钟上升沿向右移位数据。触发器编号为 $FF_1, FF_2, \\dots, FF_6$。串行数据输入 $S_{in}$ 连接到 $FF_1$ 的数据输入端，串行数据输出 $S_{out}$ 从 $FF_6$ 的输出端获取。\n\n最初，在时间 $t=0$ 时，所有触发器都处于 ‘0’ 状态。从第一个时钟周期开始，一个输入序列被施加到 $S_{in}$。在前10个时钟周期，输入序列为 $1101011001$。\n\n已知该寄存器存在一个特定故障：第四个触发器 $FF_4$ 的数据输入端永久性地“固定为1”（stuck-at-1）。这意味着在每个有效时钟沿，一个逻辑‘1’会被载入到 $FF_4$ 中，而不管第三个触发器 $FF_3$ 的输出值是多少。\n\n确定在这10个时钟周期内，在 $S_{out}$ 处观察到的10位串行输出序列。答案的第一位应对应于第一个时钟脉冲后的输出，第二位对应第二个脉冲后的输出，以此类推。请以单个不含空格的二进制字符串形式给出答案（例如，1010101010）。", "solution": "设 $Q_{i}(k)$ 表示在第 $k$ 个时钟上升沿之后 $FF_{i}$ 的状态，其中对于所有 $i\\in\\{1,2,3,4,5,6\\}$，有 $Q_{i}(0)=0$。设输入位为 $b_{1},\\dots,b_{10}$，且 $b_{1}b_{2}\\dots b_{10}=1101011001$。因为寄存器向右移位，且第四个触发器的输入固定为1，所以对于 $k\\geq 1$，同步更新方程为：\n$$\nQ_{1}(k)=b_{k},\\quad Q_{2}(k)=Q_{1}(k-1),\\quad Q_{3}(k)=Q_{2}(k-1),\\quad Q_{4}(k)=1,\\quad Q_{5}(k)=Q_{4}(k-1),\\quad Q_{6}(k)=Q_{5}(k-1).\n$$\n在第 $k$ 个时钟周期的串行输出为 $S_{out}(k)=Q_{6}(k)$。使用初始条件和输入序列 $b_{1}=1$, $b_{2}=1$, $b_{3}=0$, $b_{4}=1$, $b_{5}=0$, $b_{6}=1$, $b_{7}=1$, $b_{8}=0$, $b_{9}=0$, $b_{10}=1$，我们依次计算：\n\n对于 $k=1$:\n$$\nQ_{1}(1)=1,\\ Q_{2}(1)=0,\\ Q_{3}(1)=0,\\ Q_{4}(1)=1,\\ Q_{5}(1)=0,\\ Q_{6}(1)=0 \\Rightarrow S_{out}(1)=0.\n$$\n\n对于 $k=2$:\n$$\nQ_{1}(2)=1,\\ Q_{2}(2)=1,\\ Q_{3}(2)=0,\\ Q_{4}(2)=1,\\ Q_{5}(2)=1,\\ Q_{6}(2)=0 \\Rightarrow S_{out}(2)=0.\n$$\n\n对于 $k=3$:\n$$\nQ_{1}(3)=0,\\ Q_{2}(3)=1,\\ Q_{3}(3)=1,\\ Q_{4}(3)=1,\\ Q_{5}(3)=1,\\ Q_{6}(3)=1 \\Rightarrow S_{out}(3)=1.\n$$\n\n对于 $k=4$:\n$$\nQ_{1}(4)=1,\\ Q_{2}(4)=0,\\ Q_{3}(4)=1,\\ Q_{4}(4)=1,\\ Q_{5}(4)=1,\\ Q_{6}(4)=1 \\Rightarrow S_{out}(4)=1.\n$$\n\n对于 $k=5$:\n$$\nQ_{1}(5)=0,\\ Q_{2}(5)=1,\\ Q_{3}(5)=0,\\ Q_{4}(5)=1,\\ Q_{5}(5)=1,\\ Q_{6}(5)=1 \\Rightarrow S_{out}(5)=1.\n$$\n\n对于 $k=6$:\n$$\nQ_{1}(6)=1,\\ Q_{2}(6)=0,\\ Q_{3}(6)=1,\\ Q_{4}(6)=1,\\ Q_{5}(6)=1,\\ Q_{6}(6)=1 \\Rightarrow S_{out}(6)=1.\n$$\n\n对于 $k=7$:\n$$\nQ_{1}(7)=1,\\ Q_{2}(7)=1,\\ Q_{3}(7)=0,\\ Q_{4}(7)=1,\\ Q_{5}(7)=1,\\ Q_{6}(7)=1 \\Rightarrow S_{out}(7)=1.\n$$\n\n对于 $k=8$:\n$$\nQ_{1}(8)=0,\\ Q_{2}(8)=1,\\ Q_{3}(8)=1,\\ Q_{4}(8)=1,\\ Q_{5}(8)=1,\\ Q_{6}(8)=1 \\Rightarrow S_{out}(8)=1.\n$$\n\n对于 $k=9$:\n$$\nQ_{1}(9)=0,\\ Q_{2}(9)=0,\\ Q_{3}(9)=1,\\ Q_{4}(9)=1,\\ Q_{5}(9)=1,\\ Q_{6}(9)=1 \\Rightarrow S_{out}(9)=1.\n$$\n\n对于 $k=10$:\n$$\nQ_{1}(10)=1,\\ Q_{2}(10)=0,\\ Q_{3}(10)=0,\\ Q_{4}(10)=1,\\ Q_{5}(10)=1,\\ Q_{6}(10)=1 \\Rightarrow S_{out}(10)=1.\n$$\n\n因此，10位串行输出序列为 $0011111111$。", "answer": "$$\\boxed{0011111111}$$", "id": "1959731"}]}