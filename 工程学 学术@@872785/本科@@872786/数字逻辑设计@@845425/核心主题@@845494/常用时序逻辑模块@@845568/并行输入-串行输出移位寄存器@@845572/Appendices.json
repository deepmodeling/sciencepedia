{"hands_on_practices": [{"introduction": "要理解一个完整的并行输入、串行输出 (PISO) 移位寄存器，我们必须首先理解其基本构建单元。这项练习 ([@problem_id:1950675]) 挑战你从第一性原理出发，仅使用基本逻辑门来设计单个位片（bit-slice）的输入逻辑。通过为触发器的输入 $D_i$ 推导出一个由并行输入 $P_i$、串行输入 $S_i$ 和模式控制信号 $M$ 决定的布尔表达式，你将深刻体会到所有移位寄存器背后那简洁而巧妙的多路复用器逻辑。", "problem": "考虑一个通用并行输入、串行输出（PISO）移位寄存器的单个位片，即第 $i$ 级。这一级围绕一个 D 型触发器及其相关的输入逻辑构建。这一级的行为由单个模式控制信号 $M$ 控制。\n\n功能定义如下：\n- 当 $M=0$ 时，寄存器处于“加载”模式。在下一个有效时钟沿，触发器应捕获来自并行数据输入线 $P_i$ 的值。\n- 当 $M=1$ 时，寄存器处于“移位”模式。在下一个有效时钟沿，触发器应捕获来自串行数据输入线 $S_i$ 的值。串行输入 $S_i$ 连接到前一级触发器的输出端。\n\n你的任务是设计一个组合逻辑电路，为第 $i$ 级的 D 型触发器提供正确的输入信号 $D_i$。该逻辑必须从基本原理出发进行设计，仅使用基本的与门、或门和非门。明确禁止使用任何预封装的逻辑元件，如多路复用器（MUX）或解码器。\n\n确定触发器输入 $D_i$ 的布尔表达式，该表达式应由输入 $P_i$、$S_i$ 和 $M$ 表示。在最终的表达式中，你可以使用标准的布尔代数表示法，其中乘法（例如，$A \\cdot B$）表示“与”，加法（例如，$A+B$）表示“或”，上划线（例如，$\\overline{A}$）表示“非”。", "solution": "我们需要一个布尔函数 $D_{i}(M,P_{i},S_{i})$，使得：\n- 如果 $M=0$（加载模式），则 $D_{i}=P_{i}$。\n- 如果 $M=1$（移位模式），则 $D_{i}=S_{i}$。\n\n对 $M$ 使用布尔条件化（香农展开），任何函数 $F(M,\\dots)$ 都可以写成 $F=M\\cdot F|_{M=1}+\\overline{M}\\cdot F|_{M=0}$。将此应用于 $D_{i}$，其中 $D_{i}|_{M=1}=S_{i}$ 且 $D_{i}|_{M=0}=P_{i}$，可得\n$$\nD_{i}=M\\cdot S_{i}+\\overline{M}\\cdot P_{i}.\n$$\n此表达式仅使用基本门电路：一个非门用于生成 $\\overline{M}$，两个与门用于形成 $M\\cdot S_{i}$ 和 $\\overline{M}\\cdot P_{i}$，以及一个或门将它们求和。\n\n验证：\n- 当 $M=1$ 时：$D_{i}=1\\cdot S_{i}+0\\cdot P_{i}=S_{i}$。\n- 当 $M=0$ 时：$D_{i}=0\\cdot S_{i}+1\\cdot P_{i}=P_{i}$。\n\n因此，所需的组合逻辑是\n$$\nD_{i}=(M\\cdot S_{i})+(\\overline{M}\\cdot P_{i}).\n$$", "answer": "$$\\boxed{(M\\cdot S_{i})+(\\overline{M}\\cdot P_{i})}$$", "id": "1950675"}, {"introduction": "在建立了单个位片的内部逻辑之后，现在让我们来观察整个寄存器的动态行为。这个练习 ([@problem_id:1950743]) 模拟了PISO寄存器的核心功能：将一个并行数据字转换为一个串行数据流。通过手动追踪数据从并行加载到每一次时钟驱动下的移位过程，你将巩固对寄存器操作时序和数据路径的理解，并能准确预测其串行输出。", "problem": "一个简单的数据串行化电路使用了一个8位并行输入、串行输出 (PISO) 移位寄存器。该寄存器由八个D型触发器组成，从最高有效位 (MSB) 的Q7到最低有效位 (LSB) 的Q0进行标记。\n\n操作分两个阶段进行。首先，在“加载”阶段，8位十六进制数据字 `$B4` 被并行加载到寄存器中。这意味着数据字的MSB存储在Q7中，下一位存储在Q6中，依此类推，直到LSB存储在Q0中。\n\n其次，寄存器的模式切换到“移位”。在每个后续时钟脉冲的上升沿，寄存器中的所有位都向右移动一个位置（即，Q_n 的值移动到 Q_{n-1}）。在整个移位阶段，送入Q7的串行数据输入保持在逻辑0。电路的串行输出从Q0引脚获取。\n\n确定在移位阶段出现在串行输出的前8个位的序列，从第一个时钟脉冲产生的输出开始。\n\n下列哪个选项表示正确的8位串行输出序列？\n\nA. `00101101`\n\nB. `10110100`\n\nC. `01001011`\n\nD. `11010010`\n\nE. `01000011`", "solution": "将十六进制字 $B4$ 解释为一个8位二进制字，其中最高有效位 (MSB) 位于 $Q_{7}$，最低有效位 (LSB) 位于 $Q_{0}$。由于 $B=1011$ 且 $4=0100$，加载阶段后的初始内容为：\n$$\n[Q_{7},Q_{6},Q_{5},Q_{4},Q_{3},Q_{2},Q_{1},Q_{0}] = [1,0,1,1,0,1,0,0].\n$$\n在移位阶段，在每个时钟上升沿，寄存器右移，串行输入为零：\n$$\nQ_{n-1}^{+} = Q_{n}, \\quad Q_{7}^{+} = 0,\n$$\n其中上标 $+$ 表示时钟沿刚过后的值。\n\n串行输出取自 $Q_{0}$。由给定时钟脉冲“产生”的位是在该边沿移出的位，即移位前 $Q_{0}$ 的内容。因此，前8个输出位正是最初加载的位，从LSB到MSB：\n$$\nb_{k} = Q_{k-1}^{(0)} \\quad \\text{for } k=1,2,\\dots,8,\n$$\n其中 $Q^{(0)}$ 表示加载阶段刚结束时的值。\n\n使用初始状态 $[1,0,1,1,0,1,0,0]$，我们得到：\n$$\n[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6},b_{7},b_{8}] = [Q_{0},Q_{1},Q_{2},Q_{3},Q_{4},Q_{5},Q_{6},Q_{7}] = [0,0,1,0,1,1,0,1].\n$$\n因此，8位串行输出序列为 $00101101$，对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1950743"}, {"introduction": "现实世界中的电路并非总是完美无瑕。这项练习 ([@problem_id:1950684]) 将超越理想化的操作，让你扮演一位负责诊断故障的测试工程师。通过分析一个非预期的串行输出序列与期望值之间的差异，你将学习如何逆向推理以精确定位内部的“卡死”故障点，这对于培养实际的硬件调试能力至关重要。", "problem": "一个8位并行输入、串行输出（PISO）移位寄存器由八个D型触发器构成，从左到右依次标记为 $DFF_7$ 到 $DFF_0$。串行输出 $S_{out}$ 取自最右边触发器的输出 $Q_0$。\n\n对于每个触发器 $DFF_i$（其中 $i$ 的范围为0到7），其D输入 $D_i$ 连接到一个2对1多路复用器的输出。该多路复用器根据单根控制线 `SHIFT/`$\\overline{\\text{LOAD}}$` 在两个信号源之间进行选择：\n- 当 `SHIFT/`$\\overline{\\text{LOAD}}$` = 0（并行加载模式）时，多路复用器选择并行数据输入位 $P_i$。\n- 当 `SHIFT/`$\\overline{\\text{LOAD}}$` = 1（移位模式）时，多路复用器选择其左侧相邻触发器的输出 $Q_{i+1}$。对于最左边的触发器 $DFF_7$，其移入输入永久接地（逻辑0）。\n\n该寄存器设计用于执行以下操作：\n1. 将 `SHIFT/`$\\overline{\\text{LOAD}}$` 信号设置为0。将并行数据字 $P = (P_7, P_6, P_5, P_4, P_3, P_2, P_1, P_0) = (1, 1, 1, 1, 1, 1, 1, 1)$ 应用于输入。施加一个时钟脉冲以加载此数据。\n2. 将 `SHIFT/`$\\overline{\\text{LOAD}}$` 信号设置为1。然后施加一串八个时钟脉冲以串行移出数据。在每个时钟脉冲后，从 $S_{out}$ 读取串行输出流。\n\n执行此操作后，观测到的8位串行输出流（从第一个输出位到最后一个）为 `11110111`。已知电路中存在一个单一的固定为0故障。根据这一观察，以下哪项是最可能的故障？\n\nA. 触发器 $DFF_3$ 的D输入（$D_3$）固定为0。\n\nB. 触发器 $DFF_4$ 的输出（$Q_4$）固定为0。\n\nC. 触发器 $DFF_4$ 的并行数据输入引脚（$P_4$）固定为0。\n\nD. 主 `SHIFT/`$\\overline{\\text{LOAD}}$` 控制线固定为0。\n\nE. 触发器 $DFF_3$ 的输出（$Q_3$）固定为0。", "solution": "假设寄存器为右移寄存器，在移位模式下 $Q_{i}$ 的输出馈送到 $Q_{i-1}$，串行输出取自 $S_{out}=Q_{0}$。在使用 $P=(P_{7},\\dots,P_{0})$ 进行并行加载后，寄存器的内容为 $Q_{i}(0)=P_{i}$。\n\n在移位模式下进行时钟操作并观察每个时钟周期移出的位（标准的PISO时序）时，第 $k$ 个观测到的串行位等于并行加载后立即存在于 $Q_{k-1}$ 中的内容。因此，对于一个理想的、无故障的寄存器，\n$$\nb_{k}=P_{k-1}\\quad\\text{for }k=1,2,\\dots,8.\n$$\n由于所有 $i$ 的 $P_{i}=1$，一个正常的寄存器将产生 $b_{1}\\dots b_{8}=11111111$。\n\n观测到的流是 $11110111$，这意味着 $b_{1}=P_{0}=1$, $b_{2}=P_{1}=1$, $b_{3}=P_{2}=1$, $b_{4}=P_{3}=1$, $b_{5}=P_{4}=0$, $b_{6}=P_{5}=1$, $b_{7}=P_{6}=1$, $b_{8}=P_{7}=1$。因此，加载操作导致了 $Q_{4}(0)=P_{4}=0$，而所有其他加载的位都是1。\n\n现在，根据这个观察结果来测试每个单一的固定为0故障：\n\n1) 主控制线固定为0（选项D）：设备将保持在加载模式；每个时钟脉冲都会重新加载 $P$，因此每次读取时 $Q_{0}$ 都将保持为1，从而产生 $11111111$，与观察结果矛盾。\n\n2) $D_{3}$ 固定为0（选项A）：在加载期间，$Q_{3}(0)=0$，因此流中的第四位将是0（即 $1110\\ldots$），而不是第五位。此外，在移位期间，0会进一步向右传播，引入额外的0，这与 $11110111$ 不一致。\n\n3) $Q_{3}$ 固定为0（选项E）：这会强制 $Q_{3}(0)=0$，并且在移位模式下，会不断向右注入0，因此会出现一个较早的0和额外的尾随0，而不是观察到的在第五个位置的单个0。\n\n4) $Q_{4}$ 固定为0（选项B）：尽管这会使 $Q_{4}(0)=0$，从而第五位为0，但 $Q_{4}$ 的固定输出也破坏了向右的移位路径；具体来说，在移位模式下，$Q_{3}$ 在每个时钟周期都接收到 $Q_{4}=0$，因此对应于 $P_{5},P_{6},P_{7}$ 的位无法传播到 $Q_{0}$。逐步仿真显示输出变为 $1,1,1,1,0,0,0,0$，因此第6、7、8位将是0，这与观察到的 $1,1,1$ 矛盾。\n\n5) $P_{4}$ 固定为0（选项C）：在并行加载期间，仅此故障就会使 $Q_{4}(0)=0$，而所有其他的 $Q_{i}(0)=1$。移位路径保持完好，因此串行流等于从 $Q_{0}$ 到 $Q_{7}$ 加载的数据字：\n$$\nb_{1}\\dots b_{8}=(Q_{0}(0),Q_{1}(0),Q_{2}(0),Q_{3}(0),Q_{4}(0),Q_{5}(0),Q_{6}(0),Q_{7}(0))=11110111,\n$$\n这与观察结果完全匹配。\n\n因此，唯一与观察结果一致的单一固定为0故障是并行输入 $P_{4}$ 固定为0。", "answer": "$$\\boxed{C}$$", "id": "1950684"}]}