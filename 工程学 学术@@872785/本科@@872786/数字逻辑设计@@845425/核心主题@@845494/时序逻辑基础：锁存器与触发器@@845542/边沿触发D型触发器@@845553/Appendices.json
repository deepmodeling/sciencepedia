{"hands_on_practices": [{"introduction": "理解边沿触发D触发器的第一步是掌握其基本的状态转换行为。这个练习将帮助你通过逐个时钟周期地追踪一个简单序贯电路的输出来巩固这一核心技能。在这个场景中 [@problem_id:1931277]，触发器的输入取决于一个外部信号和它自身的当前输出，这突出了触发器作为一位存储单元的关键作用。", "problem": "一个时序逻辑电路由一个上升沿触发的D型触发器和一个异或门 (XOR) 构成。该电路有一个外部串行数据输入（记为 $S$）和一个时钟信号。触发器的数据输入 $D$ 由异或门的输出驱动。该异或门的两个输入分别是外部串行数据线 $S$ 和触发器自身的输出 $Q$。\n\n初始状态下，在施加任何时钟脉冲之前，触发器的输出 $Q$ 处于逻辑低电平状态 (0)。\n\n外部串行数据输入 $S$ 被输入5比特序列 '10110'。$S$ 的比特位与时钟同步，这意味着在连续五个时钟上升沿的每一个，序列中的一个新比特在 $S$ 输入端保持稳定。第一个比特 ('1') 在第一个时钟上升沿出现，第二个比特 ('0') 在第二个时钟上升沿出现，依此类推。\n\n在连续五个时钟上升沿之后，输出 $Q$ 处最终得到的5比特状态序列是什么？该序列应从第一个时钟沿之后的状态读到第五个时钟沿之后的状态。\n\nA. 10110\n\nB. 11011\n\nC. 01011\n\nD. 01110\n\nE. 11100", "solution": "一个上升沿触发的D型触发器在每个上升沿根据 $Q^{+}=D$ 更新其状态。此处 $D=S \\oplus Q$，其中 $\\oplus$ 表示异或。在初始条件 $Q_{0}=0$ 和输入比特 $S_{1}=1$、$S_{2}=0$、$S_{3}=1$、$S_{4}=1$、$S_{5}=0$ 的情况下，状态更新由以下公式递归地给出：\n$$\nQ_{i}=S_{i} \\oplus Q_{i-1}, \\quad i=1,\\dots,5.\n$$\n按步骤计算：\n$$\nQ_{1}=1 \\oplus 0=1,\\quad\nQ_{2}=0 \\oplus 1=1,\\quad\nQ_{3}=1 \\oplus 1=0,\\quad\nQ_{4}=1 \\oplus 0=1,\\quad\nQ_{5}=0 \\oplus 1=1.\n$$\n因此，每个上升沿之后的输出序列是 $11011$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1931277"}, {"introduction": "理想化的模型很有用，但现实世界的数字电路存在延迟。本练习将理论与现实联系起来，引入了传播延迟 ($t_{pd}$) 的概念，即输出在时钟有效沿之后响应输入变化所需的时间。通过分析一个具体的时序图 [@problem_id:1931297]，你将学会如何计算和解释这些延迟对电路输出波形的影响，这是高速数字系统设计中的一项基本功。", "problem": "一个上升沿触发的 D 触发器用于一个数字电路中。该触发器的传播延迟，记为 $t_{pd}$，为 $10 \\text{ ns}$，这是从触发时钟沿到输出 Q 变化的时间。在时间 $t=0$ 时，输出 Q 处于低逻辑电平。\n\n该触发器接收一个周期性的时钟信号 CLK，周期为 $T_{clk} = 80 \\text{ ns}$，占空比为 50%。在 $t=0$ 时，时钟信号为低电平，其第一个上升沿出现在 $t = T_{clk}/2$。\n\n数据输入 D 也随时间变化。它初始为低电平。在 $t=25 \\text{ ns}$ 时，D 变为高电平。在 $t=170 \\text{ ns}$ 时，D 变为低电平。在 $t=210 \\text{ ns}$ 时，D 再次变为高电平，并在观察期间的剩余时间内保持不变。\n\n计算在时间间隔从 $t=0$ 到 $t=300 \\text{ ns}$ 内，输出 Q 处于高逻辑电平的总时长，单位为纳秒。请以单个数值作为你的答案。", "solution": "一个上升沿触发的 D 触发器在 CLK 的每个上升沿采样 $D$，并在传播延迟 $t_{pd}$ 后更新 $Q$。因此，如果一个上升沿出现在时间 $t_{r}$，那么 $Q$ 会在时间 $t_{r}+t_{pd}$ 变为采样到的 $D(t_{r})$。\n\n已知 $T_{clk}=80\\ \\text{ns}$，占空比为 $50$%，且时钟在 $t=0$ 时为低电平，第一个上升沿在 $t=T_{clk}/2$，则上升沿出现在\n$$\nt_{r}(n)=\\frac{T_{clk}}{2}+nT_{clk},\\quad n=0,1,2,3,\n$$\n在 $[0,300\\ \\text{ns}]$ 范围内，这产生\n$$\nt_{r}(0)=40,\\quad t_{r}(1)=120,\\quad t_{r}(2)=200,\\quad t_{r}(3)=280\\ \\text{ns}.\n$$\n当 $t_{pd}=10\\ \\text{ns}$ 时，对应的 $Q$ 更新时间为\n$$\nt_{q}(n)=t_{r}(n)+t_{pd}:\\quad 50,\\ 130,\\ 210,\\ 290\\ \\text{ns}.\n$$\n\n$D$ 的波形为：\n- 对于 $0\\le t25$，$D=0$，\n- 对于 $25\\le t170$，$D=1$，\n- 对于 $170\\le t210$，$D=0$，\n- 对于 $t\\ge 210$，$D=1$。\n\n在每个 $t_{r}(n)$ 时刻采样 $D$：\n- 在 $t_{r}(0)=40$ 时，$D=1$，因此 $Q$ 在 $t=50$ 时变为 $1$。\n- 在 $t_{r}(1)=120$ 时，$D=1$，因此 $Q$ 在 $t=130$ 时保持为 $1$。\n- 在 $t_{r}(2)=200$ 时，$D=0$，因此 $Q$ 在 $t=210$ 时变为 $0$。\n- 在 $t_{r}(3)=280$ 时，$D=1$，因此 $Q$ 在 $t=290$ 时变为 $1$。\n\n已知 $Q(0)=0$，得到的 $Q$ 区间为：\n- 在 $[0,50)$ 上，$Q=0$，\n- 在 $[50,210)$ 上，$Q=1$，\n- 在 $[210,290)$ 上，$Q=0$，\n- 在 $[290,300]$ 上，$Q=1$。\n\n在 $[0,300]$ 内的总高电平持续时间为\n$$\n(210-50)+(300-290)=160+10=170\\ \\text{ns}.\n$$", "answer": "$$\\boxed{170}$$", "id": "1931297"}, {"introduction": "从分析现有电路到设计新电路是数字逻辑学习的关键一步。本练习 [@problem_id:1931239] 要求你使用硬件描述语言 (HDL) Verilog 来为一个带有附加功能的D触发器进行行为建模，例如异步复位和同步使能。这项实践不仅能检验你对触发器工作原理的深刻理解，还能让你熟悉在现代数字设计流程中如何将抽象的逻辑功能转化为可综合的代码。", "problem": "您需要使用 Verilog 硬件描述语言 (HDL) 为一个特殊的 D 型触发器设计一个行为模型。该触发器具有以下输入和输出端口：一个时钟 `clk`、一个数据输入 `d`、一个高电平有效同步使能 `en`、一个低电平有效异步清零 `clr_n` 以及一个输出 `q`。输出 `q` 应声明为 `reg` 或 `logic` 类型。\n\n该触发器要求的行为如下：\n1.  **异步清零**：无论何时 `clr_n` 输入为低电平（逻辑 0），输出 `q` 必须立即且无条件地被强制为 0。此操作必须具有最高优先级，并且无论 `clk` 或 `en` 的状态如何都必须发生。\n2.  **同步操作**：当 `clr_n` 为高电平（逻辑 1）时，触发器的行为与 `clk` 输入的上升沿同步。\n3.  **时钟使能**：在 `clk` 的上升沿（且 `clr_n` 为高电平），如果 `en` 输入为高电平（逻辑 1），输出 `q` 应更新为数据输入 `d` 的值。\n4.  **保持状态**：在 `clk` 的上升沿（且 `clr_n` 为高电平），如果 `en` 输入为低电平（逻辑 0），输出 `q` 必须保持其先前的值。\n\n下列哪个 Verilog `always` 块正确地实现了所描述的触发器？\n\nA.\n```verilog\nalways @(posedge clk) begin\n    if (!clr_n) begin\n        q = 1'b0;\n    end else if (en) begin\n        q = d;\n    end\nend\n```\n\nB.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q = 1'b0;\n    end else if (en) begin\n        q = d;\n    end\nend\n```\n\nC.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (!clr_n) begin\n        q = 1'b0;\n    end else if (en) begin\n        q = d;\n    end\nend\n```\n\nD.\n```verilog\nalways @(posedge clk, negedge clr_n) begin\n    if (en) begin\n        if (!clr_n) begin\n            q = 1'b0;\n        end else begin\n            q = d;\n        end\n    end\nend\n```\n\nE.\n```verilog\nalways @(posedge clk or negedge clr_n) begin\n    if (clr_n == 1'b0)\n        q = 1'b0;\n    else if (clk == 1'b1  en == 1'b1)\n        q = d;\nend\n```", "solution": "我们来解读一下规格要求：\n\n- 具有最高优先级的低电平有效异步清零，要求 always 块对清零信号的下降沿敏感，并立即将 $q$ 强制为 $0$，而无需考虑 $clk$ 或 $en$。这意味着事件控制应为 @(posedge clk or negedge clr_n)（或等效的逗号形式），并且需要一个测试 !clr_n 的 if 分支，使用非阻塞赋值将 $q$ 赋值为0。\n\n- 当 $clr_n$ 为高电平时，在 $clk$ 上升沿的同步行为意味着对 $q$ 的更新仅发生在 `posedge clk` 且 $clr_n=1$ 时；否则，异步分支处理 $clr_n=0$ 的情况。\n\n- 时钟使能意味着在 `posedge clk` 且 $clr_n=1$ 时，如果 $en=1$，则 $q$ 应采样 $d$；如果 $en=0$，则 $q$ 应保持。在时序 always 块中，省略 $en=0$ 情况下的赋值会正确地推断出保持状态。\n\n评估每个选项：\n\n- A 使用 `always @(posedge clk)`，因此无法执行相对于 $clr_n$ 立即生效的异步清零。因此，它违反了异步清零的要求。\n\n- B 使用 `always @(posedge clk, negedge clr_n)` 且优先级正确，但在时序逻辑块中使用了阻塞赋值 \"=\"。虽然一些工具可能会对其进行仿真甚至综合，但正确的触发器建模需要使用非阻塞赋值 \"=\" 来避免竞争条件和意外行为；因此，这不是正确的实现。\n\n- C 使用 `always @(posedge clk, negedge clr_n)`，使用了非阻塞赋值，并且优先级正确：如果 `!clr_n`，则异步地 $q$ 被赋值为0；否则，如果 `en`，则在 `posedge clk` 时 $q$ 被赋值为 $d$；再否则保持。这符合所有指定的行为。\n\n- D 将清零操作嵌套在使能条件下。在 `negedge clr_n` 且 `en` 为低电平时，清零将不会执行，这违反了清零具有最高优先级且必须独立于 `en` 工作的要求。\n\n- E 在时钟驱动的 always 块内部包含了对 `clk` 的显式测试。尽管在 `posedge clk` 时功能上是冗余的，但在条件中引用 `clk` 是非标准的，可能无法按预期综合；此外，正确的模板既不要求也不推荐在 if 语句内部检查 `clk`。与 C 相比，这不是规范的或可可靠综合的形式。\n\n因此，明确且可移植地实现指定触发器的正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1931239"}]}