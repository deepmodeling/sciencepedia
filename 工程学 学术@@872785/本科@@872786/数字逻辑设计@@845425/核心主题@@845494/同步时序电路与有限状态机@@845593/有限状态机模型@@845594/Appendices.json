{"hands_on_practices": [{"introduction": "有限状态机设计的核心在于如何将问题需求抽象为一组有限的状态。这个练习将通过一个经典计数问题，引导你设计一个摩尔（Moore）型有限状态机。通过这个实践，你将学会如何用状态来表示一个累积属性（输入流中‘1’的数量模3的余数），而不是仅仅记录最近的输入历史 [@problem_id:1935256]。", "problem": "一个数字系统正在被设计用于监控一个串行二进制数据流。该系统的核心是一个摩尔型有限状态机（FSM）。该 FSM 有一个二进制输入，记为 $x$，和一个二进制输出，记为 $z$。\n\n该 FSM 需要执行一个特定的功能：其输出 $z$ 必须为 '1'，当且仅当自机器上次复位以来，在输入 $x$ 上接收到的 '1' 的累积数量是三的非负整数倍（即 0, 3, 6, 9,...）。对于所有其他 '1' 的计数，输出 $z$ 必须为 '0'。\n\n机器的状态是根据累积的 '1' 的数量除以三的余数来定义的。设状态为 $S_0$、$S_1$ 和 $S_2$，分别对应余数 0、1 和 2。机器从复位状态 $S_0$ 开始。\n\n状态表通过列出当前状态、每个可能输入的下一个状态以及与当前状态相关联的输出来描述 FSM 的行为。以下哪个状态表正确地表示了这个摩尔机？\n\nA.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_0$        |      0       |\n\nB.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      0       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_0$        |      1       |\n\nC.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_1$        |       $S_0$        |      1       |\n|     $S_1$     |       $S_2$        |       $S_1$        |      0       |\n|     $S_2$     |       $S_0$        |       $S_2$        |      0       |\n\nD.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_0$        |      0       |\n|     $S_2$     |       $S_2$        |       $S_1$        |      0       |\n\nE.\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n|     $S_0$     |       $S_0$        |       $S_1$        |      1       |\n|     $S_1$     |       $S_1$        |       $S_2$        |      0       |\n|     $S_2$     |       $S_0$        |       $S_2$        |      0       |", "solution": "根据累积的输入'1'的数量模三的余数来定义摩尔 FSM 的状态：$S_{0}$ 代表余数 $0$，$S_{1}$ 代表余数 $1$，$S_{2}$ 代表余数 $2$。复位状态为 $S_{0}$。\n\n因为这是一个摩尔机，所以输出仅取决于当前状态。要求是当且仅当到目前为止看到的'1'的数量是三的倍数时，$z=1$。因此，仅在状态 $S_{0}$ 时 $z=1$，而在状态 $S_{1}$ 和 $S_{2}$ 时 $z=0$。\n\n设当前状态的余数为 $r \\in \\{0,1,2\\}$。当接收到输入 $x \\in \\{0,1\\}$ 时，累积的'1'的数量增加 $x$，因此下一状态的余数由下式给出\n$r^{+} = (r + x) \\pmod 3$。\n\n这意味着状态转移结构如下：\n- 对于 $x=0$，余数不变，所以 $S_{0} \\to S_{0}$，$S_{1} \\to S_{1}$，$S_{2} \\to S_{2}$。\n- 对于 $x=1$，余数模三加一，所以 $S_{0} \\to S_{1}$，$S_{1} \\to S_{2}$，$S_{2} \\to S_{0}$。\n\n结合状态转移和输出，正确的状态表必须具有：\n- 当 $x=0$ 时的下一状态：每个状态自循环。\n- 当 $x=1$ 时的下一状态：$S_{0} \\to S_{1}$，$S_{1} \\to S_{2}$，$S_{2} \\to S_{0}$。\n- 输出 $z$：在 $S_{0}$ 时为 $1$，在 $S_{1}$ 和 $S_{2}$ 时为 $0$。\n\n与选项比较，只有选项A符合这些状态转移和输出。", "answer": "$$\\boxed{A}$$", "id": "1935256"}, {"introduction": "与摩尔机不同，米利（Mealy）型有限状态机的输出取决于当前状态和当前输入，这使其在某些应用中更为高效。本练习将探讨一个非常实用的场景：设计一个串行二進制补码器。你需要构建一个米利机，它能逐位处理输入的二进制数，并实时输出其二的补码，这充分展示了米利机在实现串行算法方面的强大能力 [@problem_id:1935273]。", "problem": "一个数字系统被设计用于计算一个二进制数的二进制补码。该二进制数以串行方式、一次一位地输入到该系统中。该系统被实现为一个米利型有限状态机（FSM）。\n\n该 FSM 的输入是一个单位比特 $x$，代表正在处理的数的当前位。输入比特流从最低有效位（LSB）开始，向最高有效位（MSB）进行。输出是一个单位比特 $y$，代表二进制补码数的相应位。\n\n该 FSM 有两个状态：\n- `S_wait`：初始状态，在此状态下，机器等待在输入流中遇到第一个 '1'。\n- `S_invert`：在处理完第一个 '1' 后进入的状态。对于所有后续的比特，机器都保持在此状态。\n\n你的任务是确定这个米利型机器的正确状态转换表。该表描述了对于当前状态和输入 $x$ 的每种组合，其下一状态和输出 $y$。\n\n以下哪个表格正确地表示了该串行二进制补码器的行为？\n\n**A.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_invert` | 1          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**B.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 1          |\n| `S_wait`      | 1         | `S_wait`   | 0          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**C.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_invert` | 0          |\n| `S_invert`    | 0         | `S_invert` | 1          |\n| `S_invert`    | 1         | `S_invert` | 0          |\n\n**D.**\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $y$ |\n|:-------------:|:---------:|:----------:|:----------:|\n| `S_wait`      | 0         | `S_wait`   | 0          |\n| `S_wait`      | 1         | `S_wait`   | 1          |\n| `S_invert`    | 0         | `S_invert` | 0          |\n| `S_invert`    | 1         | `S_invert` | 1          |", "solution": "一个二进制数的二进制补码可以定义为按位取反再加一。当从最低有效位（LSB）处理到最高有效位（MSB）时，与此定义等效的串行算法是：\n- 从 LSB 端开始，复制所有比特，直到并包括第一个出现的 $1$。\n- 反转所有后续的比特。\n\n为了用一个米利型 FSM 实现这个算法，定义两个状态：\n- $S_{\\text{wait}}$：尚未见到 $1$；我们正在等待第一个 $1$。\n- $S_{\\text{invert}}$：第一个 $1$ 已经被处理；从现在开始，反转所有输入的比特。\n\n设输入比特为 $x \\in \\{0,1\\}$，输出为 $y \\in \\{0,1\\}$。每个状态和输入的行为推导如下：\n\n1. 在状态 $S_{\\text{wait}}$：\n   - 如果 $x=0$，表示尚未遇到 $1$，根据算法我们复制该比特。因此 $y=0$ 并且保持在状态 $S_{\\text{wait}}$。\n   - 如果 $x=1$，这是第一个 $1$；我们必须复制它，然后开始反转后续的比特。因此 $y=1$ 并转换到状态 $S_{\\text{invert}}$。\n\n2. 在状态 $S_{\\text{invert}}$：\n   - 对于所有后续的比特，我们输出其反码。因此对于任何 $x$，$y=\\overline{x}$ 并且保持在状态 $S_{\\text{invert}}$。具体来说：\n     - 如果 $x=0$，那么 $y=1$ 并停留在状态 $S_{\\text{invert}}$。\n     - 如果 $x=1$，那么 $y=0$ 并停留在状态 $S_{\\text{invert}}$。\n\n总结起来，状态/输出关系如下：\n- $S_{\\text{wait}}, x=0 \\rightarrow$ 下一状态 $S_{\\text{wait}}$，输出 $y=0$。\n- $S_{\\text{wait}}, x=1 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=1$。\n- $S_{\\text{invert}}, x=0 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=1$。\n- $S_{\\text{invert}}, x=1 \\rightarrow$ 下一状态 $S_{\\text{invert}}$，输出 $y=0$。\n\n这与选项 A 相符。", "answer": "$$\\boxed{A}$$", "id": "1935273"}, {"introduction": "序列检测是数字通信和数据处理中的一项基本任务，也是有限状态机的一个关键应用领域。在这个练习中，你的任务是设计一个米利型有限状态机，用于在一个连续的比特流中识别特定的4位密码序列‘1001’。这个挑战將帮助你掌握构建序列检测器的标准方法，并理解如何处理重叠序列的识别问题 [@problem_id:1935239]。", "problem": "正在设计一个用于保险库的数字安全系统。该系统接受串行二进制输入流，每个时钟周期一位。当且仅当接收到的最后四位是序列“1001”时，保险库的门会解锁一个时钟周期。该系统必须能够识别目标序列的重叠出现。例如，如果输入流是 `...01001001...`，系统应在接收到第八位时产生一个解锁信号，并在接收到第十二位时再次产生解锁信号。\n\n您的任务是使用 Mealy 型有限状态机 (FSM) 来设计该系统。Mealy FSM 是一种状态机，其输出取决于当前状态和当前输入。对于此系统，FSM 应具有单个输出 `Z`，当接收到有效序列 `1001` 的最后一位时，`Z` 在该时钟周期内为 `1`（解锁），否则为 `0`。\n\n实现此 FSM 所需的最小状态数是多少？\n\nA. 3\n\nB. 4\n\nC. 5\n\nD. 6\n\nE. 8", "solution": "我们寻求一个 Mealy FSM，它在最后四个输入位恰好是 $1001$ 时输出 $Z=1$，并允许重叠。在 Mealy 机中，输出与状态转移相关联，而通常的最优构造方法是让状态表示目标模式的最长前缀的长度，该前缀同时也是目前为止所见比特流的后缀。\n\n将目标模式定义为长度为 $4$ 的 $P=1001$。标准构造方法为每个可能匹配的前缀长度 $k \\in \\{0,1,2,3\\}$ 维持一个状态，其中 $k$ 表示最后 $k$ 个输入位等于 $P[1..k]$。设状态为：\n- $S_{0}$：匹配长度 $0$（无非空前缀匹配），\n- $S_{1}$：匹配长度 $1$（后缀 $1$），\n- $S_{2}$：匹配长度 $2$（后缀 $10$），\n- $S_{3}$：匹配长度 $3$（后缀 $100$）。\n\n我们现在推导转移和输出行为：对于每个状态和下一个输入 $b \\in \\{0,1\\}$，我们计算新的匹配长度。该长度是 $P$ 的最长前缀的长度，且该前缀是“当前后缀”与 $b$ 拼接后形成的新字符串的后缀。Mealy 输出 $Z$ 仅在完成该模式的转移上为 $1$，即从 $S_{3}$ 接收到输入 $1$ 时的转移。\n\n转移和输出：\n1. 从 $S_{0}$：\n   - 输入 $1$ 时：新的后缀是 $1$，匹配前缀长度 $1$，所以转移到 $S_{1}$，此时 $Z=0$。\n   - 输入 $0$ 时：没有非空前缀匹配，所以停留在 $S_{0}$，此时 $Z=0$。\n2. 从 $S_{1}$（后缀 $1$）：\n   - 输入 $0$ 时：新的后缀是 $10$，匹配前缀长度 $2$，所以转移到 $S_{2}$，此时 $Z=0$。\n   - 输入 $1$ 时：新的后缀是 $11$，其最长匹配前缀是 $1$，所以停留在 $S_{1}$，此时 $Z=0$。\n3. 从 $S_{2}$（后缀 $10$）：\n   - 输入 $0$ 时：新的后缀是 $100$，匹配前缀长度 $3$，所以转移到 $S_{3}$，此时 $Z=0$。\n   - 输入 $1$ 时：新的后缀是 $101$，其最长匹配前缀是 $1$，所以转移到 $S_{1}$，此时 $Z=0$。\n4. 从 $S_{3}$（后缀 $100$）：\n   - 输入 $1$ 时：新的后缀是 $1001$，完成了模式；在此转移上输出 $Z=1$，并且新状态的匹配长度为 1（因为后缀 `1`），所以转移到 $S_{1}$。\n   - 输入 $0$ 时：新的后缀是 $1000$，没有非空匹配前缀，所以转移到 $S_{0}$，此时 $Z=0$。\n\n这个 FSM 可以检测重叠，因为在 $S_{3} \\xrightarrow{1} S_1$ 产生 $Z=1$ 后，它转移到 $S_{1}$，保留了可以开始一个新的 $1001$ 匹配的结尾的 $1$。\n\n最小性论证：我们通过证明这四个上下文（匹配长度 $0,1,2,3$）就其对未来输入所产生的输出流而言是两两可区分的，从而表明至少需要 $4$ 个状态。\n- $S_{3}$ 与 $S_{2}$：输入 $1$ 会立即从 $S_{3}$ 得到 $Z=1$，而从 $S_{2}$ 得到 $Z=0$，所以它们是可区分的。\n- $S_{2}$ 与 $S_{1}$：输入 $01$ 会使 $S_{2}$ 在第二个比特上产生 $Z=1$，而 $S_{1}$ 在两个比特上都产生 $Z=0$，因此是可区分的。\n- $S_{1}$ 与 $S_{0}$：输入 $001$ 会使 $S_{1}$ 在第三个比特上产生 $Z=1$，而 $S_{0}$ 在整个过程中都输出 $Z=0$，因此是可区分的。\n\n因此，这四个上下文中的任何两个都不能合并，所以至少需要 $4$ 个状态。由于上述构造用恰好 $4$ 个状态实现了该规范，因此 Mealy FSM 的最小状态数是 $4$。\n\n在提供的选项中，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1935239"}]}