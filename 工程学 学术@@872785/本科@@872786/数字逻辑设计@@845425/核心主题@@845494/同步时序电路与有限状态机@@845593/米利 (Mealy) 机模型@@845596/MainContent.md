## 引言
在数字逻辑和计算机系统的设计中，[有限状态机](@entry_id:174162)（FSM）是描述和实现时序行为的核心工具。在众多 FSM 模型中，[米利机](@entry_id:177066)（Mealy Machine）以其独特的输出机制而著称，它为设计需要对外部输入做出快速、即时响应的系统提供了一个强大而高效的框架。然而，传统的顺序[逻辑设计](@entry_id:751449)常常面临一个挑战：如何精确地构建一个不仅其未来状态、而且其当前输出也直接取决于实时输入的系统？[米利机](@entry_id:177066)模型正是为了解决这一问题而生，但其输出的异步特性也带来了独特的设计考量。

本文将全面深入地探讨[米利机](@entry_id:177066)模型。在第一章“原理与机制”中，我们将详细阐述其形式化定义、表示方法（[状态图](@entry_id:176069)与[状态表](@entry_id:178995)），并将其与[摩尔机](@entry_id:170836)进行对比，同时介绍状态分析、设计与化简的关键技术。随后，在第二章“应用和跨学科联系”中，我们将展示[米利机](@entry_id:177066)如何在序列检测、系统控制、通信协议乃至计算生物学等领域发挥作用，揭示其广泛的适用性。最后，通过第三章“动手实践”中的一系列练习，您将有机会亲手应用所学知识，将理论转化为解决实际问题的能力。

## 原理与机制

继前一章对[有限状态机](@entry_id:174162)（FSM）基本概念的介绍之后，本章将深入探讨一种重要的 FSM 模型——**Mealy 机**（Mealy Machine）。我们将详细阐述其核心工作原理、表示方法、分析与设计技术，并将其与另一种关键模型——Moore 机进行对比。通过理解 Mealy 机，我们将能够设计出响应更迅速、逻辑更高效的[时序电路](@entry_id:174704)。

### Mealy 机的定义

在[同步时序电路](@entry_id:175242)中，系统的行为由其当前**状态**（State）和外部**输入**（Input）共同决定。状态存储在寄存器（如 D 型[触发器](@entry_id:174305)）中，并在[时钟信号](@entry_id:174447)的驱动下发生变化。Mealy 机和 Moore 机是描述这种行为的两种主要形式化模型。

一个 Mealy 机可以通过一个六元组 $(S, \Sigma, \Gamma, \delta, \lambda, s_0)$ 来形式化定义，其中：
- $S$ 是一个有限的状态集合。
- $\Sigma$ 是一个有限的输入符号集合（输入字母表）。
- $\Gamma$ 是一个有限的输出符号集合（输出字母表）。
- $\delta: S \times \Sigma \to S$ 是**状态[转移函数](@entry_id:273897)**，它根据当前[状态和](@entry_id:193625)当前输入来决定下一个状态。
- $\lambda: S \times \Sigma \to \Gamma$ 是**输出函数**，它根据当前[状态和](@entry_id:193625)当前输入来决定当前的输出。
- $s_0 \in S$ 是初始状态。

Mealy 机的**核心特征**在于其输出函数 $\lambda$。输出不仅取决于电路所处的当前状态，还直接取决于当前的输入值。若用 $s(t)$ 表示[时钟周期](@entry_id:165839) $t$ 的当前状态，$x(t)$ 表示当前输入，$z(t)$ 表示当前输出，则 Mealy 机的行为可以表示为：

$$
s(t+1) = \delta(s(t), x(t))
$$
$$
z(t) = \lambda(s(t), x(t))
$$

这与 Moore 机形成了鲜明对比。在 Moore 机中，输出仅由当前状态决定，即 $z(t) = \lambda(s(t))$。这意味着 Moore 机的输出在整个时钟周期内是稳定的，仅在[时钟沿](@entry_id:171051)到来、状态发生改变后才会更新。而 Mealy 机的输出是组合逻辑的直接产物，它会随着当前输入信号的变化而即时变化，即使在同一个[时钟周期](@entry_id:165839)内也是如此 [@problem_id:1969121]。这个根本性的差异导致了两种模型在响应速度、硬件实现和输出特性上的显著不同。

### Mealy 机的表示方法

为了清晰地描述和分析 Mealy 机，我们通常使用两种标准表示方法：[状态图](@entry_id:176069)和[状态表](@entry_id:178995)。

#### [状态图](@entry_id:176069) (State Diagram)

**[状态图](@entry_id:176069)**是一种直观的图形化表示。在 Mealy 机的[状态图](@entry_id:176069)中：
- 每个**状态**用一个圆圈表示，圆圈内写有状态的名称（如 $S_0, S_1$）。
- **状态之间的转移**用带箭头的弧线表示。
- 每条弧线上都有一个标签，格式为 `输入 / 输出`。例如，一条从状态 $S_0$ 指向 $S_1$ 且标签为 `1 / 0` 的弧线表示：当机器处于状态 $S_0$ 且接收到输入 `1` 时，它将产生输出 `0`，并在下一个[时钟沿](@entry_id:171051)到来时转移到状态 $S_1$。

#### [状态表](@entry_id:178995) (State Table)

**[状态表](@entry_id:178995)**为 FSM 提供了更规整、更适合于[逻辑综合](@entry_id:274398)的描述方式。表格的每一行对应一个当前状态。表格的列则根据输入进行划分，每一列显示在该[状态和](@entry_id:193625)相应输入下的**下一状态**和**输出**。

例如，考虑一个用于数据包过滤的四状态 Mealy 机 [@problem_id:1968936]。其[状态表](@entry_id:178995)如下所示：

| 当前状态 | 输入 `x` | 下一状态 | 输出 `z` |
|:---:|:---:|:---:|:---:|
| S0 | 0 | S1 | 0 |
| S0 | 1 | S2 | 0 |
| S1 | 0 | S1 | 1 |
| S1 | 1 | S3 | 0 |
| S2 | 0 | S0 | 0 |
| S2 | 1 | S3 | 1 |
| S3 | 0 | S2 | 1 |
| S3 | 1 | S0 | 0 |

这张表清晰地定义了机器的全部行为。例如，当机器处于状态 `S2` 且输入为 `1` 时，它会立即产生输出 `1`，并在下一个时钟上升沿转换到状态 `S3`。

### Mealy 机的分析与实现

理解了 Mealy 机的定义和表示方法后，我们可以对其进行分析以理解其功能，并学习如何将其从抽象模型转化为具体的[数字逻辑电路](@entry_id:748425)。

#### 行为追踪与[功能分析](@entry_id:164849)

分析 Mealy 机最直接的方法是**行为追踪**。给定一个初始[状态和](@entry_id:193625)一串输入序列，我们可以一步步地跟踪状态的变迁和相应输出的产生。让我们使用上文中的四状态机，并假设其初始状态为 `S0`，输入序列为 `x = 1011001` [@problem_id:1968936]。

1.  初始状态为 `S0`，第一个输入为 `1`。查表可知，输出 `z` 为 `0`，下一状态为 `S2`。
2.  当前状态为 `S2`，第二个输入为 `0`。输出 `z` 为 `0`，下一状态为 `S0`。
3.  当前状态为 `S0`，第三个输入为 `1`。输出 `z` 为 `0`，下一状态为 `S2`。
4.  当前状态为 `S2`，第四个输入为 `1`。输出 `z` 为 `1`，下一状态为 `S3`。
5.  当前状态为 `S3`，第五个输入为 `0`。输出 `z` 为 `1`，下一状态为 `S2`。
6.  当前状态为 `S2`，第六个输入为 `0`。输出 `z` 为 `0`，下一状态为 `S0`。
7.  当前状态为 `S0`，第七个输入为 `1`。输出 `z` 为 `0`，下一状态为 `S2`。

因此，完整的输出序列为 `z = 0001100`。若将其解释为一个无符号二[进制](@entry_id:634389)数，其值为 $1 \cdot 2^3 + 1 \cdot 2^2 = 12$。

除了机械地追踪，更深层次的分析是理解 FSM 的**整体功能**。考虑一个简单的双状态 Mealy 机 [@problem_id:1968897]，其状态 `S0` (初始) 和 `S1`。其行为可以概括为：状态代表了“上一个输入是 `1` (S1) 还是 `0` (S0)”。其输出逻辑被设计为 `当前输入` 与 `上一输入` (即状态所代表的信息) 的[异或](@entry_id:172120)。这样的设计使其功能等同于一个**边缘检测器**：当且仅当当前输入位与前一个输入位不同时，输出为 `1`。

#### 从逻辑电路到状态行为

Mealy 机在物理上由[状态寄存器](@entry_id:755408)（如 D 型[触发器](@entry_id:174305)）和组合逻辑电路构成。[状态寄存器](@entry_id:755408)存储当前状态，而组合逻辑则实现状态[转移函数](@entry_id:273897) $\delta$ 和输出函数 $\lambda$。

假设一个 Mealy 机由两个 D 型[触发器](@entry_id:174305) ($Q_1, Q_0$) 存储状态，有一个输入 $X$ 和一个输出 $Z$。其硬件逻辑由以下方程定义 [@problem_id:1968919]：
- 下一状态逻辑：
  $D_1 = X(Q_1' + Q_0)$
  $D_0 = (X \oplus Q_1) + Q_0'$
- 输出逻辑：
  $Z = X'Q_1Q_0 + XQ_0'$

其中 $D_1$ 和 $D_0$ 是[触发器](@entry_id:174305)的输入，它们的值将在下一个[时钟沿](@entry_id:171051)被锁存为新的状态 $(Q_{1, \text{next}}, Q_{0, \text{next}})$。我们可以通过代入特定的当前[状态和](@entry_id:193625)输入值来分析电路的行为。例如，当电路处于状态 $(Q_1, Q_0) = (1, 1)$ 且输入 $X=0$ 时：

- $D_1 = 0 \cdot (0 + 1) = 0 \implies Q_{1, \text{next}} = 0$
- $D_0 = (0 \oplus 1) + 0 = 1 + 0 = 1 \implies Q_{0, \text{next}} = 1$
- $Z = 1 \cdot 1 \cdot 1 + 0 \cdot 0 = 1$

因此，在此条件下，当前输出为 `1`，下一状态为 `(0, 1)`。通过对所有可能的[状态和](@entry_id:193625)输入组合进行这样的计算，我们就可以完整地推导出该电路的[状态表](@entry_id:178995)。类似地，通过分析[时序图](@entry_id:171669)中的状态、输入和输出变化，我们也可以反向工程出其[状态表](@entry_id:178995) [@problem_id:1968902]。

#### 从[状态表](@entry_id:178995)到逻辑电路

设计过程则与上述分析相反。我们从一个描述所需功能的[状态表](@entry_id:178995)出发，推导出实现该功能的逻辑表达式。这通常包括以下步骤：
1.  **[状态分配](@entry_id:172668)**：为每个符号化的状态（如 $S_0, S_1$）分配一个唯一的二进制编码（如 `00`, `01`）。
2.  **构建[激励表](@entry_id:164712)和输出表**：根据[状态表](@entry_id:178995)，列出每个当前[状态和](@entry_id:193625)输入组合所对应的下一状态（即 D [触发器](@entry_id:174305)的输入 $D_i$）和输出 $Z$。
3.  **[逻辑化简](@entry_id:178919)**：使用[卡诺图](@entry_id:264061)（Karnaugh Map）或布尔代数等工具，为每个 $D_i$ 和 $Z$ 导出最简的逻辑表达式。

例如，对于一个输出行为由下表定义的部分 Mealy 机 [@problem_id:1968912]：

| $Q_1Q_0$ | $X$ | $Z$ |
|:---:|:---:|:---:|
| 10 | 1 | 1 |
| 11 | 1 | 1 |
| (其他) | ... | 0 |

输出 $Z$ 为 `1` 的情况是 $(Q_1, Q_0, X) = (1, 0, 1)$ 和 $(1, 1, 1)$。其对应的[最小项](@entry_id:178262)之和为 $Z = Q_1Q_0'X + Q_1Q_0X$。通过[布尔代数化简](@entry_id:260581)：

$$
Z = Q_1X(Q_0' + Q_0) = Q_1X(1) = Q_1X
$$

这个结果 $Z = XQ_1$ 就是实现该输出行为的最简组合逻辑。

### Mealy 机输出的异步特性

Mealy 机的一个至关重要的实践特性是其输出的**异步性**。由于输出 $z(t)$ 是当前状态 $s(t)$ 和当前输入 $x(t)$ 的组合逻辑函数，如果输入 $x(t)$ 在两个[时钟沿](@entry_id:171051)之间发生变化，输出 $z(t)$ 也会**立即**做出反应，而无需等待下一个[时钟沿](@entry_id:171051)。

这种行为可能导致不期望的**毛刺**（Glitches）。考虑一个 Mealy 机，在状态 $S_1$ 时，输入 $X=1$ 产生输出 $Z=0$，而输入 $X=0$ 产生输出 $Z=1$ [@problem_id:1968918]。假设机器当前处于状态 $S_1$，输入 $X$ 稳定在 `1`，因此输出 $Z$ 为 `0`。如果在[时钟周期](@entry_id:165839)的中间，输入 $X$ 从 `1` 变为 `0`，输出 $Z$ 会几乎立刻从 `0` 变为 `1`。这个输出的变化与系统时钟是不同步的。直到下一个[时钟沿](@entry_id:171051)到来，机器状态根据输入 `0` 转移到新状态（比如 $S_0$）后，输出才会再次更新（比如变为 $\lambda(S_0, 0)=0$）。

这种特性是一把双刃剑：
- **优点**：Mealy 机可以对输入变化做出快速响应，在某些应用中，这种零延迟的反应是必要的。
- **缺点**：产生的异步输出或毛刺可能会被下游的[同步电路](@entry_id:172403)错误地采样，引发系统错误。如果需要严格同步的输出，Moore 机是更安全的选择，或者需要在 Mealy 机的输出端额外添加一个寄存器来使其同步化。

### 与 Moore 机的转换

任何 Mealy 机都可以转换为一个功能等价的 Moore 机，反之亦然。这种转换在设计中非常有用，例如，当我们想保留 Mealy 机的状态逻辑但需要一个无毛刺的同步输出时。

将 Mealy 机转换为 Moore 机的核心思想是**将输出与状态绑定**。由于 Moore 机的输出仅依赖于状态，我们需要将 Mealy 机中与转移相关的输出信息“吸收”到 Moore 机的状态定义中。

转换算法如下：
1.  分析 Mealy 机中每个状态的所有传出转移。如果一个状态（如 $S_i$）的所有传出转移产生的输出都相同，则可以直接创建一个与之对应的 Moore 状态，并将该输出值作为此 Moore 状态的固定输出。
2.  如果一个 Mealy 状态（如 $S_j$）是多个转移的目的地，而这些转移的输出值不同，那么在 Moore 机中必须为每种不同的输出值创建一个 $S_j$ 的“副本”。例如，如果存在转移 $S_a \xrightarrow{x_1/z_1} S_j$ 和 $S_b \xrightarrow{x_2/z_2} S_j$ 且 $z_1 \neq z_2$，则需要创建两个 Moore 状态，例如 $S_{j1}$（输出为 $z_1$）和 $S_{j2}$（输出为 $z_2$）。
3.  重新连接转移弧线。原 Mealy 机中指向 $S_j$ 且输出为 $z_k$ 的转移，在新 Moore 图中应指向对应的副本 $S_{jk}$。

让我们以一个检测 `01` 序列的 Mealy 机为例 [@problem_id:1968913]。该 Mealy 机有状态 $S_0$ 和 $S_1$。关键转移是当处于 $S_1$（表示“上一个输入是0”）且输入为 `1` 时，输出 `1` 并回到 $S_0$。所有其他转移的输出均为 `0`。

在转换中，我们发现状态 $S_0$ 是两条转移弧的目的地：一条来自 $S_0$（输入`1`），输出为 `0`；另一条来自 $S_1$（输入`1`），输出为 `1`。由于到达 $S_0$ 的路径产生了不同的输出，我们需要为 $S_0$ 创建两个 Moore 状态：一个状态 `A`，其输出为 `0`；另一个状态 `C`，其输出为 `1`。对于状态 $S_1$，所有指向它的转移输出都为 `0`，因此只需一个 Moore 状态 `B`，其输出为 `0`。

最终得到的等价 Moore 机有三个状态：
- **状态 A** (对应 $S_0$，初始状态)：输出为 0。输入 `0` 时，转移到 B (记录了“刚看到0”)；输入 `1` 时，回到 A。
- **状态 B** (对应 $S_1$)：输出为 0。输入 `0` 时，留在 B；输入 `1` 时，检测到 `01` 序列，转移到 C 以便在下一个周期输出 `1`。
- **状态 C** (对应 $S_0$，但在检测到 `01` 之后)：输出为 1。这是产生所需输出的状态。之后，无论输入是 `0` 还是 `1`，机器都会根据 $S_0$ 的原始行为转移到相应的下一个状态（输入`0`去B，输入`1`去A）。

这个例子表明，Mealy 机到 Moore 机的转换可能会导致状态数量的增加，这是为实现输出同步化而付出的代价。

### Mealy 机的状态化简

在 FSM 设计中，一个常见的目标是用最少的状态来实现所需的功能，这可以减少硬件成本和逻辑复杂性。状态化简的过程就是找到并合并功能上**等价**的状态。

#### [状态等价](@entry_id:261329)性的概念

在 Mealy 机中，两个状态 $S_i$ 和 $S_j$ 被认为是等价的，当且仅当对于**任何**可能的输入序列，从 $S_i$ 开始和从 $S_j$ 开始所产生的输出序列完全相同。

这个定义引出一个可操作的递归判断准则：两个状态是等价的，必须满足以下两个条件：
1.  对于所有可能的单个输入，它们的**输出必须相同**。
2.  对于所有可能的单个输入，它们的**下一状态必须是等价的**。

我们可以直接应用此准则来检查状态对。例如，在一个六[状态机](@entry_id:171352)中，要判断状态 `B` 和 `E` 是否等价 [@problem_id:1968877]，我们检查它们的行：

| 状态 | 输入 `x=0` (下一状态/输出) | 输入 `x=1` (下一状态/输出) |
|:---:|:---:|:---:|
| B | C / 1 | D / 0 |
| E | C / 1 | D / 0 |

- 当输入为 `0` 时，两者输出都为 `1`，下一状态都是 `C`。
- 当输入为 `1` 时，两者输出都为 `0`，下一状态都是 `D`。

由于对于所有输入，它们的输出相同，且下一状态也完全相同（因此下一状态必然等价），我们可以断定状态 `B` 和 `E` 是等价的。

#### [划分算法](@entry_id:637954)

对于更复杂的状态机，逐对比较效率低下。**[划分算法](@entry_id:637954)**（Partitioning Algorithm）提供了一种系统性的方法来找出所有的等价状态集。

该算法是一个迭代过程，从未一个粗略的划分开始，逐步将其细化，直到无法再划分为止。

1.  **初始划分 ($P_0$)**：将所有状态按照其输出行为分组。对于 Mealy 机，如果两个状态对于所有输入的输出都完全相同，则将它们放入同一个初始分组（或称为块）。

2.  **迭代细化 ($P_k \to P_{k+1}$)**：检查 $P_k$ 中的每一个块。对于块中的任意两个状态 $S_i$ 和 $S_j$，以及每一个输入 $x$，检查它们的下一状态 $\delta(S_i, x)$ 和 $\delta(S_j, x)$ 是否属于 $P_k$ 中的**同一个块**。如果对于所有输入，它们的下一状态都落在相同的块中，则 $S_i$ 和 $S_j$ 在这一轮中保持在同一组。如果存在某个输入使它们的下一状态分属不同的块，则必须将 $S_i$ 和 $S_j$ 分开，形成新的、更小的块。

3.  **终止**：重复步骤 2，直到某一次迭代后划分 $P_{k+1}$ 与 $P_k$ 完全相同。此时，[算法终止](@entry_id:143996)，最终的划分就代表了最小化状态机的状态集。每个块中的所有状态都是等价的，可以合并成一个新状态。

让我们应用此算法于一个六状态机 [@problem_id:1968874]。

**初始划分 ($P_0$)**：根据输出对 $(z(x=0), z(x=1))$ 进行分组。
- $S_0$: $(a, a)$
- $S_1$: $(b, a)$
- $S_2$: $(a, b)$
- $S_3$: $(b, a)$
- $S_4$: $(a, b)$
- $S_5$: $(a, b)$
由此得到初始划分 $P_0 = \{ \{S_0\}, \{S_1, S_3\}, \{S_2, S_4, S_5\} \}$。我们将其标记为块 A, B, C：$A=\{S_0\}, B=\{S_1, S_3\}, C=\{S_2, S_4, S_5\}$。

**第一次细化 ($P_1$)**：检查块 B 和 C 内部的一致性。
- 对于块 $B=\{S_1, S_3\}$：
  - $S_1$: 输入 `0` $\to S_4 \in C$；输入 `1` $\to S_5 \in C$。下一状态模式：(C, C)。
  - $S_3$: 输入 `0` $\to S_4 \in C$；输入 `1` $\to S_5 \in C$。下一状态模式：(C, C)。
  - $S_1$ 和 $S_3$ 行为一致，块 B 保持不变。

- 对于块 $C=\{S_2, S_4, S_5\}$：
  - $S_2$: 输入 `0` $\to S_0 \in A$；输入 `1` $\to S_3 \in B$。下一状态模式：(A, B)。
  - $S_4$: 输入 `0` $\to S_0 \in A$；输入 `1` $\to S_0 \in A$。下一状态模式：(A, A)。
  - $S_5$: 输入 `0` $\to S_0 \in A$；输入 `1` $\to S_1 \in B$。下一状态模式：(A, B)。
  - $S_2$ 和 $S_5$ 的模式 (A, B) 相同，但与 $S_4$ 的模式 (A, A) 不同。因此块 C 被分裂。

第一次细化后的划分为 $P_1 = \{ \{S_0\}, \{S_1, S_3\}, \{S_2, S_5\}, \{S_4\} \}$。

**第二次细化 ($P_2$)**：我们检查新的划分 $P_1$ 是否稳定。
- 块 $\{S_1, S_3\}$：它们的下一状态模式现在需要根据 $P_1$ 中的新块来判断，但由于它们的下一状态 ($S_4, S_5$) 仍然在不同的块里，所以它们的下一状态模式仍是一致的。
- 块 $\{S_2, S_5\}$：它们的下一状态模式 $(A, B)$ 也是一致的。

由于没有新的分裂发生，$P_2 = P_1$。[算法终止](@entry_id:143996)。

最终的划分为 $\{S_0\}, \{S_1, S_3\}, \{S_2, S_5\}, \{S_4\}$，共 4 个[等价类](@entry_id:156032)。这意味着原有的 6 状态 Mealy 机可以被一个功能完[全等](@entry_id:273198)价的 4 [状态机](@entry_id:171352)所替代，从而实现了状态化简。