{"hands_on_practices": [{"introduction": "我们将从摩尔机最基础的应用之一开始：在输入流中检测特定的序列。这个练习旨在帮助你掌握核心概念，即如何根据输入历史定义状态，并将输出与这些状态关联起来。我们将以一个经典的非重叠序列检测器作为起点，来构建你的第一个摩尔机状态表 [@problem_id:1969113]。", "problem": "您的任务是设计一个数字电路，用于监控一个串行输入比特流 `x`。该电路必须在检测到特定的三比特序列 `101` 后，立即产生一个持续一个时钟周期的输出 `z` 为 $1$。一个关键约束是检测到的序列必须是不重叠的。这意味着一旦识别出一个完整的 `101` 序列，组成该序列的比特不能被重复用作另一个潜在序列的一部分。检测过程必须重置并重新开始。\n\n您需要使用摩尔型有限状态机（FSM）来对此行为进行建模。该状态机使用四个状态来跟踪序列检测的进度：\n- `$S_0$`：初始或复位状态，尚未检测到目标序列的前缀。\n- `$S_1$`：表示最近接收到的比特是 '1'，它可能是序列的开始。\n- `$S_2$`：表示最后接收到的两个比特是 '10'。\n- `$S_3$`：表示最后接收到的三个比特是 '101'，这是检测状态。\n\n根据这些状态定义，从下面的选项中选择正确实现所指定摩尔机的状态表。“当前状态”列表示下一个输入比特到达之前的状态，“下一状态”表示处理输入比特之后的状态，“输出 (z)”是与当前状态相关联的输出。\n\nA.\n\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| $S_0$ | $S_0$ | $S_1$ | 0     |\n| $S_1$ | $S_2$ | $S_1$ | 0     |\n| $S_2$ | $S_0$ | $S_3$ | 0     |\n| $S_3$ | $S_0$ | $S_1$ | 1     |\n\nB.\n\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| $S_0$ | $S_0$ | $S_1$ | 0     |\n| $S_1$ | $S_2$ | $S_1$ | 0     |\n| $S_2$ | $S_0$ | $S_3$ | 0     |\n| $S_3$ | $S_2$ | $S_1$ | 1     |\n\nC.\n\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| $S_0$ | $S_0$ | $S_1$ | 0     |\n| $S_1$ | $S_2$ | $S_1$ | 0     |\n| $S_2$ | $S_0$ | $S_3$ | 1     |\n| $S_3$ | $S_0$ | $S_1$ | 0     |\n\nD.\n\n| 当前状态 | 下一状态 (输入=0) | 下一状态 (输入=1) | 输出 (z) |\n| :---: | :---: | :---: | :---: |\n| $S_0$ | $S_1$ | $S_0$ | 0     |\n| $S_1$ | $S_2$ | $S_1$ | 0     |\n| $S_2$ | $S_0$ | $S_3$ | 0     |\n| $S_3$ | $S_0$ | $S_1$ | 1     |", "solution": "我们设计一个摩尔型有限状态机，用于检测不重叠的序列 `101`，并在检测后立即产生一个持续一个时钟周期的输出 $z=1$。在摩尔机中，$z$ 仅取决于当前状态，因此检测状态必须是唯一一个 $z=1$ 的状态。\n\n根据给定的状态含义：\n- $S_0$：没有有用的前缀；下一状态必须仅取决于当前的输入比特。\n- $S_1$：最后一个比特是 $1$；输入为 $0$ 时，我们前进到前缀 `10` 的状态；输入为 $1$ 时，我们得到的序列（例如`...11`）中，能与模式 `101` 前缀匹配的最长真后缀仍然是 $1$，因此我们保持在 $S_1$ 状态。\n- $S_2$：最后两个比特是 `10`；输入为 $1$ 时，我们完成 `101` 并进入检测状态；输入为 $0$ 时，没有匹配的后缀，所以我们复位到 $S_0$。\n- $S_3$：最后三个比特是 `101`；由于检测必须是不重叠的，在将 $z=1$ 置位一个时钟周期后，我们必须重新开始搜索，而不重用已检测序列中的任何比特。因此，从 $S_3$ 开始的转换逻辑必须与从 $S_0$ 重新开始的逻辑相同：输入为 $0$ 时，转到 $S_0$；输入为 $1$ 时，转到 $S_1$。\n\n现在确定正确的转换和输出：\n\n1) 从 $S_0$ 出发：\n- 输入 $0$：仍然没有前缀，所以 $S_0 \\to S_0$。\n- 输入 $1$：一个潜在匹配的开始，所以 $S_0 \\to S_1$。\n\n2) 从 $S_1$ 出发：\n- 输入 $0$：我们得到 `10`，所以 $S_1 \\to S_2$。\n- 输入 $1$：我们得到的序列结尾是`...11`，其能匹配`101`前缀的最长后缀仍是'1'，所以状态保持为 $S_1 \\to S_1$。\n\n3) 从 $S_2$ 出发：\n- 输入 $0$：序列变为 `100`，其与 `101` 前缀匹配的最长后缀为空，所以 $S_2 \\to S_0$。\n- 输入 $1$：我们完成了 `101`，所以 $S_2 \\to S_3$。\n\n4) 从 $S_3$ 出发（不重叠重启）：\n- 输入 $0$：以 $0$ 重启，所以 $S_3 \\to S_0$。\n- 输入 $1$：以 $1$ 重启，所以 $S_3 \\to S_1$。\n\n对于摩尔机的输出分配：\n- $z=1$ 仅在 $S_3$（检测状态）中，而在 $S_0$、$S_1$ 和 $S_2$ 中 $z=0$。\n\n与选项进行比较：\n- 选项 A 匹配上述所有转换，并且只有在 $S_3$ 状态时 $z=1$。\n- 选项 B 在输入为 $0$ 时使用 $S_3 \\to S_2$ 的转换，这重用了已检测序列的后缀信息（重叠），违反了不重叠的要求。\n- 选项 C 在 $S_2$ 中分配 $z=1$，在 $S_3$ 中分配 $z=0$，这与摩尔机检测的定义相矛盾。\n- 选项 D 从 $S_0$ 开始的转换不正确（它交换了对输入 $0$ 和 $1$ 的响应），这是无效的。\n\n因此，正确的状态表是选项 A。", "answer": "$$\\boxed{A}$$", "id": "1969113"}, {"introduction": "从抽象的状态图转向具体的硬件实现，下一个练习将探讨如何分析由逻辑方程定义的摩尔机。我们将追踪状态机在进入一个意外的初始状态后的运行轨迹，这是验证数字电路设计鲁棒性的一项关键技能 [@problem_id:1969124]。这个过程能让你更深入地理解状态转换在电路层面的本质。", "problem": "一个摩尔型时序电路使用三个D型触发器设计。该电路的状态由二进制元组 $(Q_2, Q_1, Q_0)$ 表示，其中 $Q_2$ 是最高有效位。该电路有一个单一的二进制输入 $x$。触发器输入 $(D_2, D_1, D_0)$ 和电路输出 $Z$ 的逻辑由以下布尔方程定义。请注意，并置表示逻辑与运算，`+` 符号表示逻辑或运算，上划线（例如 $\\overline{Q}$）表示逻辑非运算。\n\n$D_2 = \\overline{Q_2} Q_1 + Q_1 \\overline{Q_0}$\n$D_1 = \\overline{Q_1} Q_0 + x \\overline{Q_2}$\n$D_0 = Q_2 \\overline{Q_0} + \\overline{x} Q_1$\n$Z = Q_2 Q_0$\n\n由于启动异常，电路进入状态 $(Q_2, Q_1, Q_0) = (1, 1, 1)$。从此时起，输入 $x$ 恒定保持为值 $0$。\n\n确定该电路将经历的状态序列。该序列应以初始异常状态开始，并列出接下来三个时钟脉冲后的后续状态。\n\n下列哪个选项表示此状态序列？\n\nA. $(1,1,1) \\rightarrow (0,0,1) \\rightarrow (0,1,0) \\rightarrow (1,0,1)$\n\nB. $(1,1,1) \\rightarrow (0,0,1) \\rightarrow (1,1,0) \\rightarrow (0,0,0)$\n\nC. $(1,1,1) \\rightarrow (1,0,1) \\rightarrow (0,1,1) \\rightarrow (1,0,0)$\n\nD. $(1,1,1) \\rightarrow (0,0,0) \\rightarrow (0,0,0) \\rightarrow (0,0,0)$\n\nE. $(1,1,1) \\rightarrow (0,1,0) \\rightarrow (1,1,1) \\rightarrow (0,0,1)$", "solution": "对于D型触发器，下一个状态等于在有效时钟沿施加的 $D$ 输入，因此 $Q_{i}^{+}=D_{i}$。这里，从异常初始状态开始，$x$ 保持为 $0$。\n\n给定\n$D_2 = \\overline{Q_2} Q_1 + Q_1 \\overline{Q_0}$, $D_1 = \\overline{Q_1} Q_0 + x \\overline{Q_2}$, $D_0 = Q_2 \\overline{Q_0} + \\overline{x} Q_1$,\n当 $x=0$ 时，这些方程简化为\n$D_1 = \\overline{Q_1} Q_0$, $D_0 = Q_2 \\overline{Q_0} + Q_1$。\n\n从 $(Q_{2},Q_{1},Q_{0})=(1,1,1)$ 开始。\n计算下一个状态 $(Q_{2}^{+},Q_{1}^{+},Q_{0}^{+})=(D_{2},D_{1},D_{0})$：\n\n1) 从 $(1,1,1)$ 开始，使用 $\\overline{Q_{2}}=0$, $\\overline{Q_{1}}=0$, $\\overline{Q_{0}}=0$ 和 $\\overline{x}=1$：\n$D_{2}=0\\cdot 1+1\\cdot 0=0$, $D_{1}=0\\cdot 1+0\\cdot 0=0$, $D_{0}=1\\cdot 0+1\\cdot 1=1$,\n所以下一个状态是 $(0,0,1)$。\n\n2) 从 $(0,0,1)$ 开始，使用 $\\overline{Q_{2}}=1$, $\\overline{Q_{1}}=1$, $\\overline{Q_{0}}=0$：\n$D_{2}=1\\cdot 0+0\\cdot 0=0$, $D_{1}=1\\cdot 1+0\\cdot 1=1$, $D_{0}=0\\cdot 0+1\\cdot 0=0$,\n所以下一个状态是 $(0,1,0)$。\n\n3) 从 $(0,1,0)$ 开始，使用 $\\overline{Q_{2}}=1$, $\\overline{Q_{1}}=0$, $\\overline{Q_{0}}=1$：\n$D_{2}=1\\cdot 1+1\\cdot 1=1$, $D_{1}=0\\cdot 0+0\\cdot 1=0$, $D_{0}=0\\cdot 1+1\\cdot 1=1$,\n所以下一个状态是 $(1,0,1)$。\n\n因此，从 $(1,1,1)$ 开始，并列出接下来三个时钟脉冲后的状态，序列是\n$$(1,1,1)\\rightarrow(0,0,1)\\rightarrow(0,1,0)\\rightarrow(1,0,1),$$\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1969124"}, {"introduction": "真实世界的设计必须兼顾功能与效率。最后的练习将挑战一个更复杂的重叠序列检测问题，并引入状态最小化的正式方法。通过学习识别和合并等价状态，你将能够为一个给定的任务创建出最紧凑、最高效的状态机 [@problem_id:1969119]。", "problem": "在设计一个自定义的高速串行通信协议中，一个核心组件是实时数据完整性校验器。该校验器必须持续监控一个输入的二进制数据流，并识别特定的4位同步标记。您的任务是使用有限状态机为该校验器设计逻辑。\n\n该校验器将被实现为一个摩尔（Moore）机。它有一个单一的二进制输入 `x`，每个时钟周期从数据流中接收一个比特，以及一个单一的二进制输出 `z`。当且仅当输入 `x` 上最近接收到的四个比特序列为 `1010` 或 `0101` 时，输出 `z` 必须为 $1$。该状态机必须能够检测这些序列的重叠实例。例如，如果输入流是 `...01010...`，则在最后一个'1'（`0101`）到达时输出应为'1'，然后在最后一个'0'（`1010`）到达时再次输出'1'。\n\n假设在接收任何比特之前，机器处于一个复位状态。首先，为正确实现此行为的摩尔机构建一个状态表。然后，应用一个形式化的状态最小化算法（例如划分法）来找到等效的最小状态机。这个最小摩尔机中的状态总数是多少？", "solution": "为了解决这个问题，我们将首先构建一个能够正确识别目标序列的状态机，然后应用一个形式化的最小化过程来找出等效最小状态机中的状态数。\n\n**步骤1：构建非最小状态机**\n\n为序列检测构建摩尔机的一种系统方法是，定义状态来表示输入流中同时也是目标序列（`1010` 或 `0101`）之一的前缀的最长后缀。如果一个状态表示一个完整的目标序列，其输出为1，否则为0。\n\n让我们识别所有这些必要的前缀：\n1.  `\"\"` (空字符串，我们的复位状态)\n2.  `1` (`1010` 的前缀)\n3.  `0` (`0101` 的前缀)\n4.  `10` (`1010` 的前缀)\n5.  `01` (`0101` 的前缀)\n6.  `101` (`1010` 的前缀)\n7.  `010` (`0101` 的前缀)\n8.  `1010` (第一个目标序列)\n9.  `0101` (第二个目标序列)\n\n这样我们就得到了总共9个状态。我们按如下方式标记它们：\n-   $S_0$：后缀为 `\"\"` (复位状态)，输出 $z=0$。\n-   $S_1$：后缀为 `1`，输出 $z=0$。\n-   $S_2$：后缀为 `0`，输出 $z=0$。\n-   $S_3$：后缀为 `10`，输出 $z=0$。\n-   $S_4$：后缀为 `01`，输出 $z=0$。\n-   $S_5$：后缀为 `101`，输出 $z=0$。\n-   $S_6$：后缀为 `010`，输出 $z=0$。\n-   $S_7$：后缀为 `1010`，输出 $z=1$。\n-   $S_8$：后缀为 `0101`，输出 $z=1$。\n\n现在，我们确定状态转移。对于每个状态，我们将输入比特（`0` 或 `1`）附加到该状态所代表的字符串后，并找出新字符串中属于我们所定义前缀之一的最长后缀。\n\n-   从 $S_0$ (`\"\"`)：输入 $0$ 得到 `0` ($S_2$)；输入 $1$ 得到 `1` ($S_1$)。\n-   从 $S_1$ (`1`)：输入 $0$ 得到 `10` ($S_3$)；输入 $1$ 得到 `11` (最长前缀后缀为 `1`，所以是 $S_1$)。\n-   从 $S_2$ (`0`)：输入 $0$ 得到 `00` (最长前缀后缀为 `0`，所以是 $S_2$)；输入 $1$ 得到 `01` ($S_4$)。\n-   从 $S_3$ (`10`)：输入 $0$ 得到 `100` (最长前缀后缀为 `0`，所以是 $S_2$)；输入 $1$ 得到 `101` ($S_5$)。\n-   从 $S_4$ (`01`)：输入 $0$ 得到 `010` ($S_6$)；输入 $1$ 得到 `011` (最长前缀后缀为 `1`，所以是 $S_1$)。\n-   从 $S_5$ (`101`)：输入 $0$ 得到 `1010` ($S_7$)；输入 $1$ 得到 `1011` (最长前缀后缀为 `1`，所以是 $S_1$)。\n-   从 $S_6$ (`010`)：输入 $0$ 得到 `0100` (最长前缀后缀为 `0`，所以是 $S_2$)；输入 $1$ 得到 `0101` ($S_8$)。\n-   从 $S_7$ (`1010`, $z=1$)：输入 $0$ 得到 `10100` (最长前缀后缀为 `0`，所以是 $S_2$)；输入 $1$ 得到 `10101` (最长前缀后缀为 `101`，所以是 $S_5$)。\n-   从 $S_8$ (`0101`, $z=1$)：输入 $0$ 得到 `01010` (最长前缀后缀为 `10`，所以是 $S_3$)；输入 $1$ 得到 `01011` (最长前缀后缀为 `1`，所以是 $S_1$)。\n\n这导出了以下状态表：\n\n| 当前状态 | 下一状态 ($x=0$) | 下一状态 ($x=1$) | 输出 ($z$) |\n|:-------------:|:------------------:|:------------------:|:------------:|\n| $S_0$         | $S_2$              | $S_1$              | 0            |\n| $S_1$         | $S_3$              | $S_1$              | 0            |\n| $S_2$         | $S_2$              | $S_4$              | 0            |\n| $S_3$         | $S_2$              | $S_5$              | 0            |\n| $S_4$         | $S_6$              | $S_1$              | 0            |\n| $S_5$         | $S_7$              | $S_1$              | 0            |\n| $S_6$         | $S_2$              | $S_8$              | 0            |\n| $S_7$         | $S_2$              | $S_5$              | 1            |\n| $S_8$         | $S_3$              | $S_1$              | 1            |\n\n**步骤2：通过划分法进行状态最小化**\n\n我们使用划分法来寻找等效状态。如果两个状态具有相同的输出，并且对于每个可能的输入，它们的下一状态都属于同一个等效类，则这两个状态是等效的。\n\n**划分 $P_0$**：根据输出 $z$ 对状态进行划分。\n-   第1组 ($z=0$)：$\\{S_0, S_1, S_2, S_3, S_4, S_5, S_6\\}$\n-   第2组 ($z=1$)：$\\{S_7, S_8\\}$\n$P_0 = \\{ (S_0, S_1, S_2, S_3, S_4, S_5, S_6), (S_7, S_8) \\}$\n\n**划分 $P_1$**：我们检查 $P_0$ 中每个组内状态的转移。下一状态根据它们所属的 $P_0$ 组进行分类。\n对于第1组：\n-   $S_0$：当 $x=0 \\to S_2(\\text{组1})$；当 $x=1 \\to S_1(\\text{组1})$。转移：(组1, 组1)。\n-   $S_1$：当 $x=0 \\to S_3(\\text{组1})$；当 $x=1 \\to S_1(\\text{组1})$。转移：(组1, 组1)。\n-   $S_2$：当 $x=0 \\to S_2(\\text{组1})$；当 $x=1 \\to S_4(\\text{组1})$。转移：(组1, 组1)。\n-   $S_3$：当 $x=0 \\to S_2(\\text{组1})$；当 $x=1 \\to S_5(\\text{组1})$。转移：(组1, 组1)。\n-   $S_4$：当 $x=0 \\to S_6(\\text{组1})$；当 $x=1 \\to S_1(\\text{组1})$。转移：(组1, 组1)。\n-   $S_5$：当 $x=0 \\to S_7(\\text{组2})$；当 $x=1 \\to S_1(\\text{组1})$。转移：(组2, 组1)。\n-   $S_6$：当 $x=0 \\to S_2(\\text{组1})$；当 $x=1 \\to S_8(\\text{组2})$。转移：(组1, 组2)。\n\n第1组必须被划分。$\\{S_0, S_1, S_2, S_3, S_4\\}$ 的转移剖面为 (组1,组1)。$S_5$ 的剖面为 (组2,组1)。$S_6$ 的剖面为 (组1,组2)。这产生了三个新的组。\n\n对于第2组：\n-   $S_7$：当 $x=0 \\to S_2(\\text{组1})$；当 $x=1 \\to S_5(\\text{组1})$。转移：(组1, 组1)。\n-   $S_8$：当 $x=0 \\to S_3(\\text{组1})$；当 $x=1 \\to S_1(\\text{组1})$。转移：(组1, 组1)。\n第2组中的两个状态相对于 $P_0$ 具有相同的转移剖面。它们保留在同一个组中。\n\n因此，$P_1 = \\{ (S_0, S_1, S_2, S_3, S_4), (S_5), (S_6), (S_7, S_8) \\}$。我们称这些组为 Ga, Gb, Gc, Gd。\n\n**划分 $P_2$**：细化 $P_1$。\n对于 Ga 组：\n-   $S_0$：$x=0 \\to S_2(\\text{Ga})$；$x=1 \\to S_1(\\text{Ga})$。转移：(Ga, Ga)。\n-   $S_1$：$x=0 \\to S_3(\\text{Ga})$；$x=1 \\to S_1(\\text{Ga})$。转移：(Ga, Ga)。\n-   $S_2$：$x=0 \\to S_2(\\text{Ga})$；$x=1 \\to S_4(\\text{Ga})$。转移：(Ga, Ga)。\n-   $S_3$：$x=0 \\to S_2(\\text{Ga})$；$x=1 \\to S_5(\\text{Gb})$。转移：(Ga, Gb)。\n-   $S_4$：$x=0 \\to S_6(\\text{Gc})$；$x=1 \\to S_1(\\text{Ga})$。转移：(Gc, Ga)。\nGa 组分裂。$\\{S_0, S_1, S_2\\}$ 的剖面为 (Ga,Ga)。$S_3$ 的剖面为 (Ga,Gb)。$S_4$ 的剖面为 (Gc,Ga)。\n\nGb 和 Gc 组是单元素集，不能再分裂。\n\n对于 Gd 组：\n-   $S_7$：$x=0 \\to S_2(\\text{Ga})$；$x=1 \\to S_5(\\text{Gb})$。转移：(Ga, Gb)。\n-   $S_8$：$x=0 \\to S_3(\\text{Ga})$；$x=1 \\to S_1(\\text{Ga})$。转移：(Ga, Ga)。\n转移剖面不同。$S_7$ 和 $S_8$ 不等效。Gd 组分裂。\n\n因此，$P_2 = \\{ (S_0, S_1, S_2), (S_3), (S_4), (S_5), (S_6), (S_7), (S_8) \\}$。\n\n**划分 $P_3$**：细化 $P_2$。\n设 $P_2$ 的组为：G'a = $\\{S_0, S_1, S_2\\}$，G'b=\\{S3\\}，G'c=\\{S4\\}，G'd=\\{S5\\}，G'e=\\{S6\\}，G'f=\\{S7\\}，G'g=\\{S8\\}。\n对于 G'a 组：\n-   $S_0$：$x=0 \\to S_2(\\text{G'a})$；$x=1 \\to S_1(\\text{G'a})$。转移：(G'a, G'a)。\n-   $S_1$：$x=0 \\to S_3(\\text{G'b})$；$x=1 \\to S_1(\\text{G'a})$。转移：(G'b, G'a)。\n-   $S_2$：$x=0 \\to S_2(\\text{G'a})$；$x=1 \\to S_4(\\text{G'c})$。转移：(G'a, G'c)。\n$S_0, S_1, S_2$ 相对于 $P_2$ 的划分的转移剖面都不同。因此，G'a 分裂成三个单元素组。\n\n因此，$P_3 = \\{ (S_0), (S_1), (S_2), (S_3), (S_4), (S_5), (S_6), (S_7), (S_8) \\}$。\n\n由于无法进一步划分（所有组都是单元素集），我们已经达到了最小形式。该过程表明，我们初始设计中没有两个状态是等效的。这意味着初始的9状态机已经是最小的了。\n\n最小状态机中的状态数为9。", "answer": "$$\\boxed{9}$$", "id": "1969119"}]}