{"hands_on_practices": [{"introduction": "要真正掌握状态图，最好的方法莫过于亲身实践。我们将从一个基础的序列检测器开始，通过分析其状态转换逻辑来热身。这个练习的目标是通过验证一个预先定义的状态表，来理解米利（Mealy）机中状态转换背后的逻辑，这有助于巩固状态机如何跟踪输入流的核心机制。[@problem_id:1962078]", "problem": "一个数字系统包含一个“突发信号触发器”，设计用于监控一个单比特串行数据流。该触发器有一个输入 $x$ 和一个输出 $z$。该系统与一个时钟同步运行。该触发器的功能是，当且仅当当前输入比特为 '1' 且紧邻的前两个输入比特也为 '1' 时，将其输出 $z$ 置为高逻辑电平 ('1')。此功能必须考虑重叠序列；例如，输入流 '...011110...' 应产生输出流 '...000110...'。在所有其他时间，输出 $z$ 必须处于低逻辑电平 ('0')。\n\n这种行为可以用一个有限状态机来描述。假设该系统被设计为一个具有最少状态数的米利型状态机（Mealy machine），以下哪个状态转换表正确地表示了其行为？状态定义如下：\n- $S_0$：初始或复位状态。所需的 '1' 序列已被中断。\n- $S_1$：最近一个输入比特是 '1'。\n- $S_2$：最近两个输入比特是 '11'。\n\n表格以 (当前状态, 输入 $x$, 下一状态, 输出 $z$) 的格式呈现。\n\nA)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)\n\nB)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S0, 1)\n\nC)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S1, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)\n\nD)\n(S0, 0, S0, 0)\n(S0, 1, S1, 0)\n(S1, 0, S0, 0)\n(S1, 1, S2, 0)\n(S2, 0, S0, 0)\n(S2, 1, S1, 1)\n\nE)\n(S0, 0, S0, 0)\n(S0, 1, S1, 1)\n(S1, 0, S0, 0)\n(S1, 1, S2, 1)\n(S2, 0, S0, 0)\n(S2, 1, S2, 1)", "solution": "问题要求我们设计一个米利型有限状态机，用于检测串行比特流中的 '111' 序列，包括重叠出现的情况。米利型状态机的输出是其当前状态和当前输入的函数。我们需要确定状态转换和相应的输出。\n\n状态是根据检测 '111' 序列的进展来定义的：\n- $S_0$：复位状态。尚未检测到目标序列的前缀。这是在接收到 '0' 或启动后的状态。\n- $S_1$：最后一个输入是 '1'。这表示已经看到了前缀 '1'。\n- $S_2$：最后两个输入是 '11'。这表示已经看到了前缀 '11'。\n\n让我们根据输入 $x \\in \\{0, 1\\}$ 来分析每个状态的转换。\n\n**状态 $S_0$ (复位状态) 的分析：**\n- 如果当前输入为 $x=0$：状态机没有看到可以开始序列的 '1'。系统保持在复位状态 $S_0$。输出 $z$ 必须为 0。\n  - 转换：(当前状态: $S_0$, 输入: 0) $\\rightarrow$ (下一状态: $S_0$, 输出: 0)。\n- 如果当前输入为 $x=1$：这是潜在序列的第一个 '1'。状态机转换到状态 $S_1$ 以记住它已经看到了一个 '1'。完整序列尚未被检测到，所以输出 $z$ 为 0。\n  - 转换：(当前状态: $S_0$, 输入: 1) $\\rightarrow$ (下一状态: $S_1$, 输出: 0)。\n\n**状态 $S_1$ (看到一个 '1') 的分析：**\n- 如果当前输入为 $x=0$：由于接收到了 '0'，序列被中断。状态机必须返回到复位状态 $S_0$。输出 $z$ 为 0。\n  - 转换：(当前状态: $S_1$, 输入: 0) $\\rightarrow$ (下一状态: $S_0$, 输出: 0)。\n- 如果当前输入为 $x=1$：状态机处于状态 $S_1$（意味着前一个输入是 '1'），现在又接收到一个 '1'。序列现在以 '11' 结尾。状态机转换到状态 $S_2$。完整的 '111' 序列尚未完成，所以输出 $z$ 为 0。\n  - 转换：(当前状态: $S_1$, 输入: 1) $\\rightarrow$ (下一状态: $S_2$, 输出: 0)。\n\n**状态 $S_2$ (看到 '11') 的分析：**\n- 如果当前输入为 $x=0$：序列被中断。状态机必须返回到复位状态 $S_0$。输出 $z$ 为 0。\n  - 转换：(当前状态: $S_2$, 输入: 0) $\\rightarrow$ (下一状态: $S_0$, 输出: 0)。\n- 如果当前输入为 $x=1$：状态机处于状态 $S_2$（前两个输入是 '11'），现在接收到一个 '1'。这完成了 '111' 序列。因此，输出 $z$ 必须为 1。问题规定检测器必须处理重叠序列。考虑输入 '1111'。第一个 '111' 应产生输出 1。此时，接收到的最后两个输入是 '11'。这正是处于状态 $S_2$ 的条件。因此，为了检测下一个 '111' 序列（由第一个序列的最后两个 '1' 和新的 '1' 组成），状态机必须转换回状态 $S_2$。\n  - 转换：(当前状态: $S_2$, 输入: 1) $\\rightarrow$ (下一状态: $S_2$, 输出: 1)。\n\n**汇总状态表：**\n通过组合上述所有推导出的转换，我们可以构建完整的状态转换表：\n\n| 当前状态 | 输入 $x$ | 下一状态 | 输出 $z$ |\n|---------------|-----------|------------|------------|\n| $S_0$         | 0         | $S_0$      | 0          |\n| $S_0$         | 1         | $S_1$      | 0          |\n| $S_1$         | 0         | $S_0$      | 0          |\n| $S_1$         | 1         | $S_2$      | 0          |\n| $S_2$         | 0         | $S_0$      | 0          |\n| $S_2$         | 1         | $S_2$      | 1          |\n\n这个表与选项 A 中提供的一模一样。让我们分析其他选项以确认它们是错误的。\n- 选项 B 是一个非重叠检测器，因为在 (S2, 1) 时，它转换到 S0，重置了序列。\n- 选项 C 是不正确的，因为转换 (S1, 0, S1, 0) 是错误的；接收到 '0' 必须中断序列并复位到 S0。\n- 选项 D 在输入 '1' 时错误地从 S2 转换到 S1。这将无法正确检测像 '1111' 这样的重叠序列。它会检测到 '111'，然后转换到一个“看到一个1”的状态，而没有认识到最后两个输入是 '11'。\n- 选项 E 错误地将转换 (S0, 1) 和 (S1, 1) 的输出设置为 1，这不符合问题规定。只有在完整的 '111' 序列完成时，输出才应为 1。\n\n因此，选项 A 是指定突发信号触发器的唯一正确表示。", "answer": "$$\\boxed{A}$$", "id": "1962078"}, {"introduction": "在验证了状态转换表之后，我们现在从验证转向设计。这个问题挑战你确定一个用于比特填充的米利（Mealy）机所需的最小状态数。[@problem_id:1962063] 这里的关键技能是构思机器在每一步需要“记住”什么信息，这正是定义状态的精髓所在。", "problem": "一种数字通信协议使用比特填充（bit stuffing）来防止出现长串的'1'，因为这可能被误认为是特殊的控制标志。该填充电路的一个关键组件是一个预处理器，它能精确地识别何时需要插入一个比特。\n\n您的任务是确定该预处理器的复杂性，该预处理器被建模为一个米利型有限状态机（Mealy-type Finite State Machine, FSM）。该FSM有一个单比特串行二进制输入 $X$ 和一个单比特二进制输出 $Z$。该机器逐比特地持续监控输入流。当且仅当当前输入比特 $X$ 是一个恰好包含四个连续'1'的序列中的第四个'1'时，输出 $Z$ 必须为'1'。在所有其他情况下，输出 $Z$ 必须为'0'。\n\n为清晰起见，请看以下示例：\n- 如果输入序列 `X` 是 `011110`，则对应的输出序列 `Z` 应为 `000010`。\n- 如果输入序列 `X` 是 `111111`，则对应的输出序列 `Z` 应为 `000100`。请注意，输出仅在第四个'1'时为'1'，而不是在第五个或第六个'1'时。\n\n实现这个米利型FSM所需的最少状态数是多少？", "solution": "我们将需求形式化如下。设输入流为 $\\{x[n]\\}$，其中 $x[n]\\in\\{0,1\\}$。我们用状态变量 $r[n-1]$ 定义在时间 $n$ 之前紧邻的连续'1'的游程长度（run-length），其中\n$$\nr[n]=\\begin{cases}\n0,   x[n]=0 \\\\\nr[n-1]+1,  x[n]=1\n\\end{cases}\n$$\n要求输出 $z[n]=1$ 当且仅当当前比特 $x[n]$ 是当前游程中的第四个'1'，这等价于\n$$\nz[n]=\\begin{cases}\n1,  x[n]=1 \\text{ 且 } r[n-1]=3 \\\\\n0,  \\text{其他情况}\n\\end{cases}\n$$\n这与给出的示例相符：对于 `011110`，第四个 `1` 产生 `z` 中唯一的 `1`；对于 `111111`，只有第四个 `1` 产生 `z=1`，而第五个和第六个 `1` 产生 `z=0`。\n\n为了将其实现为一个米利型FSM，机器必须记住关于当前'1'游程的足够信息。只需跟踪游程长度直到一个阈值，超过该阈值后，长度的进一步增加不会改变未来的输出机会。具体来说，定义五个抽象状态，分别对应于\n$$\nS_{0}: r=0,\\quad S_{1}: r=1,\\quad S_{2}: r=2,\\quad S_{3}: r=3,\\quad S_{4}: r\\geq 4.\n$$\n其转移和输出规则如下：\n- 当输入为 $0$ 时：从任何状态都转移到 $S_{0}$ 并输出 $0$（因为输入 `0` 永远不可能是第四个 `1`）。\n- 当输入为 $1$ 时：从 $k\\in\\{0,1,2\\}$ 的状态 $S_{k}$ 转移到 $S_{k+1}$ 并输出 $0$；从 $S_{3}$ 转移到 $S_{4}$ 并输出 $1$；从 $S_{4}$ 保持在 $S_{4}$ 并输出 $0$。\n\n这样就用 $5$ 个状态实现了该规范。\n\n为了证明其最小性，我们证明上述五个状态中任意两个都不是米利等价的（Mealy-equivalent）；因此至少需要 $5$ 个状态。\n- 区分 $a,b\\in\\{0,1,2,3\\}$ 且 $a\\neq b$ 的状态 $S_{a}$ 和 $S_{b}$：考虑一个由 $m$ 个重复的 `1` 组成的输入字符串。从状态 $S_{c}$ 开始，机器第一次在输入为 `1` 时可以输出 `1` 的情况发生在第 $(4-c)$ 个 `1` 处。因此，从状态 $S_{a}$ 开始，输出 `1` 将发生在该字符串的第 $(4-a)$ 个符号处，而从状态 $S_{b}$ 开始，则发生在第 $(4-b)$ 个符号处。因为 $a\\neq b$，这些位置不同，所以输出序列也不同；因此 $S_{a}$ 和 $S_{b}$ 不能合并。\n- 区分 $S_{4}$ 和任意 $k\\in\\{0,1,2,3\\}$ 的状态 $S_{k}$：输入一个由 $(4-k)$ 个重复的 `1` 组成的字符串。从状态 $S_{k}$ 开始，该字符串中的最后一个 `1` 会产生输出 `1`（根据 $k$ 的定义）。然而，从状态 $S_{4}$ 开始，对于任意数量的 `1` 输入，所有输出都保持为 `0`。因此，$S_{4}$ 与任何 $S_{k}$ 都不是等价的。\n\n因此，至少需要 $5$ 个状态。由于我们已经构造出了一个 $5$ 状态的米利型FSM，所以最少状态数是 $5$。", "answer": "$$\\boxed{5}$$", "id": "1962063"}, {"introduction": "我们最后的练习将焦点从响应输入的米利（Mealy）机，转移到一个自主生成输出序列的摩尔（Moore）机。你需要确定生成一个特定重复模式所需的最小状态数。[@problem_id:1962064] 这个练习突出了摩尔机的一个关键特性，并揭示了序列周期与生成该序列所需状态数之间的根本关系。", "problem": "一个同步有限状态机被设计用作一个专用处理器的控制路径的序列发生器。该机器没有外部数据输入，在时钟的驱动下循环经过一系列状态。该机器有两条输出线，当将其解释为一个2位无符号整数时，必须连续产生重复序列：0, 1, 1, 3, 2, 2, 0, 1, 1, ... 该机器被设计成其输出仅是其当前状态的函数。实现这个状态机所需的最少状态数是多少？", "solution": "令 $y[t]$ 表示在时钟时间 $t \\in \\mathbb{Z}_{\\geq 0}$ 的 $2$ 位输出。所要求的无限序列为\n$$\ny[0],y[1],y[2],y[3],y[4],y[5],y[6],\\dots=(0,1,1,3,2,2,0,1,1,\\dots).\n$$\n首先，确定该序列的最小周期 $L$。通过观察，该序列重复数据块 $(0,1,1,3,2,2)$，因此它是周期性的，周期 $L=6$。我们必须验证不存在更小的周期。一个周期 $L$ 满足对所有 $t \\geq 0$ 都有 $y[t+L]=y[t]$。检查所有 $1 \\leq L  6$ 的 $L$：\n- 对于 $L=1$，需要 $y[0]=y[1]$，但 $0 \\neq 1$。\n- 对于 $L=2$，需要 $y[0]=y[2]$，但 $0 \\neq 1$。\n- 对于 $L=3$，需要 $y[0]=y[3]$，但 $0 \\neq 3$。\n- 对于 $L=4$，需要 $y[0]=y[4]$，但 $0 \\neq 2$。\n- 对于 $L=5$，需要 $y[0]=y[5]$，但 $0 \\neq 2$。\n因此最小周期为\n$$\nL=6.\n$$\n\n因为该机器是一个没有外部输入的摩尔机，每个状态都决定了一个唯一的右无限未来输出序列。如果两个不同的时间索引 $i \\neq j$ 对应于相同的状态，那么它们的未来输出必须是相同的：\n$$\n\\forall k \\geq 0: y[i+k]=y[j+k].\n$$\n这意味着该无限序列在 $|i-j|$ 的移位下是不变的，即它会有一个能整除 $|i-j|$ 的周期。由于最小周期为 $L=6$，没有两个不同的模 $6$ 的偏移量可以产生相同的右无限尾序列。因此，状态数必须满足\n$$\nN_{\\min} \\geq L = 6.\n$$\n\n反之，6个状态就足够了：构建一个6状态的环形结构 $S_{0} \\to S_{1} \\to \\dots \\to S_{5} \\to S_{0}$，并分配输出\n$$\nS_{0}\\!:\\,0,\\quad S_{1}\\!:\\,1,\\quad S_{2}\\!:\\,1,\\quad S_{3}\\!:\\,3,\\quad S_{4}\\!:\\,2,\\quad S_{5}\\!:\\,2,\n$$\n这恰好产生周期序列 $(0,1,1,3,2,2)$。\n\n因此，所需的最少状态数为 $6$。", "answer": "$$\\boxed{6}$$", "id": "1962064"}]}