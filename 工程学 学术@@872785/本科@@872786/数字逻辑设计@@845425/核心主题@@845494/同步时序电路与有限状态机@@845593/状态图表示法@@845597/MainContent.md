## 引言
在数字系统的世界里，许多设备的功能远超简单的输入输出响应，它们必须能够“记忆”过去发生的事件并据此作出决策。从控制交通灯的变换到执行复杂的通信协议，这种依赖于历史序列的行为无处不在。简单的[组合逻辑](@entry_id:265083)电路无法满足这类需求，因此，我们需要一种更强大的建模工具来描述和设计这些具有“记忆”功能的时序系统。这个工具就是[有限状态机](@entry_id:174162)（Finite State Machine, FSM），而[状态图](@entry_id:176069)（State Diagram）正是其直观、通用的图形化语言。

本文旨在系统性地介绍[状态图](@entry_id:176069)表示法，解决从抽象的需求描述到具体、严谨的[时序逻辑](@entry_id:181558)模型构建这一核心问题。通过学习本文，您将能够掌握[有限状态机](@entry_id:174162)的基本工作原理，并能清晰地辨别和应用两种主要的FSM模型。

在接下来的内容中，第一章“原理与机制”将深入探讨[有限状态机](@entry_id:174162)（FSM）的理论基础，详细对比摩尔（Moore）机和米利（Mealy）机，并阐述如何从问题描述中提炼出关键的状态。第二章“应用与跨学科联系”将通过控制系统、[数字通信](@entry_id:271926)和[计算机体系结构](@entry_id:747647)等领域的实例，展示[状态图](@entry_id:176069)在解决真实世界问题中的强大威力。最后，在“动手实践”部分，您将有机会通过一系列精心设计的问题，巩固和应用所学知识。让我们一同开启探索[时序逻辑设计](@entry_id:170390)核心的旅程。

## 原理与机制

在数字逻辑领域，我们处理两种基本的电路类型：组合逻辑电路和[时序逻辑电路](@entry_id:167016)。组合逻辑电路的输出仅由其当前输入的函数确定，它没有记忆功能。然而，现实世界中的许多系统——从简单的交通灯控制器到复杂的微处理器——都必须根据过去的事件序列来做出决策。这些系统具有“记忆”功能，其行为由一系列事件所驱动。为了对这类系统进行建模和设计，我们需要一种更强大的工具。这种工具就是**[有限状态机](@entry_id:174162) (Finite State Machine, FSM)**，而**[状态图](@entry_id:176069) (State Diagram)** 则是其通用且直观的图形化语言。

本章将深入探讨[有限状态机](@entry_id:174162)的核心原理和机制。我们将学习如何使用[状态图](@entry_id:176069)来描述、分析和设计时序系统。我们将区分两种主要的 FSM 模型——**摩尔 (Moore)** 机和**米利 (Mealy)** 机，并理解它们各自的优势和局限性。最重要的是，我们将掌握从自然语言描述的需求中提炼出状态，并构建完整、精确的[状态图](@entry_id:176069)的系统性方法。

### [有限状态机](@entry_id:174162)：时序行为的模型

[有限状态机](@entry_id:174162)是一种数学计算模型，它由一组有限数量的**状态 (States)**、一组**输入 (Inputs)**、一组**输出 (Outputs)**、一个**状态[转移函数](@entry_id:273897) (Transition Function)** 和一个**输出函数 (Output Function)** 构成。从本质上讲，FSM 捕捉了一个系统的动态行为：在任何给定时刻，系统处于其有限个状态中的一个；它接收一个输入，然后根据其当前[状态和](@entry_id:193625)该输入，转移到一个新的状态（可能就是当前状态本身）并产生一个输出。

[状态图](@entry_id:176069)是 FSM 的可视化表示，它使得复杂的[时序逻辑](@entry_id:181558)变得清晰易懂：
- **状态 (States)** 通常用圆圈表示，内部标有状态的名称或编码。
- **状态转移 (Transitions)** 由从一个状态指向另一个状态的带箭头弧线表示。
- **输入/输出关系** 标记在状态或转移弧线上，具体取决于 FSM 的类型。

让我们通过一个简单的例子来理解 FSM 的基本运作方式。考虑一个数字宠物的情感模型，它可以在“开心 (H)”、“悲伤 (S)”和“困倦 (Z)”三种状态之间转换。系统的行为由当前[状态和](@entry_id:193625)两位输入 $FP$ 决定，其中 $F=1$ 代表“喂食”，$P=1$ 代表“玩耍”。初始状态为“开心 (H)”。其规则定义了状态[转移函数](@entry_id:273897)。例如，当宠物开心时（处于状态 H），如果没有喂食也没有玩耍（输入为 $00$），它会感到无聊并转移到悲伤状态 S。如果给定一个输入序列，我们就可以精确地追踪宠物的状态变化轨迹。

假设输入序列为 $10, 01, 00, 11, 01, 00$。我们可以一步步推演：
1.  初始状态: $s_0 = H$。输入 $u_1 = 10$ (仅喂食)。规则规定，在开心状态下，喂食或玩耍都会保持开心。状态变为 $s_1 = H$。
2.  当前状态: $H$。输入 $u_2 = 01$ (仅玩耍)。同样，宠物保持开心。状态变为 $s_2 = H$。
3.  当前状态: $H$。输入 $u_3 = 00$ (无活动)。宠物感到无聊，转移到悲伤状态。状态变为 $s_3 = S$。
4.  当前状态: $S$。输入 $u_4 = 11$ (喂食且玩耍)。规则规定，在悲伤状态下，这种输入不会改变其状态。状态保持为 $s_4 = S$。
5.  当前状态: $S$。输入 $u_5 = 01$ (仅玩耍)。宠物振作起来，转移到开心状态。状态变为 $s_5 = H$。
6.  当前状态: $H$。输入 $u_6 = 00$ (无活动)。宠物再次感到无聊，转移到悲伤状态。最终状态为 $s_6 = S$。

这个例子 [@problem_id:1962041] 展示了 FSM 的核心：系统通过一系列离散的状态变迁来响应外部输入，其“记忆”就体现在当前所处的状态之中。

### 两种基本模型：[摩尔机](@entry_id:170836)与[米利机](@entry_id:177066)

虽然所有 FSM 都共享状态、输入和转移的基本概念，但它们在如何生成输出方面存在一个关键的区别，这导致了两种主要模型：[摩尔机](@entry_id:170836)和[米利机](@entry_id:177066)。

#### [摩尔机](@entry_id:170836)：输出由状态决定

在**[摩尔机](@entry_id:170836) (Moore Machine)** 中，输出完全由当前状态确定。输出函数 $Y$ 只是当前状态 $S$ 的函数，写作 $Y = g(S)$。无论系统如何进入一个状态，也不论当前输入是什么，只要它处于该状态，其输出就是固定不变的。

在[状态图](@entry_id:176069)中，[摩尔机](@entry_id:170836)的输出通常写在表示状态的圆圈内部，格式为 `状态名/输出`。

[摩尔机](@entry_id:170836)的一个显著特点是其输出的稳定性。在一个[时钟周期](@entry_id:165839)内，只要状态不改变，输出就保持稳定。这在某些设计中可以避免由输入信号变化直接引起的输出信号毛刺（glitches），从而使系统更加稳健。

**示例：时钟[分频器](@entry_id:177929)**
考虑一个将时钟频率四[分频](@entry_id:162771)的电路 [@problem_id:1962048]。该电路由一个使能输入 $X$ 控制。当 $X=1$ 时，电路在每个时钟周期依次遍历四个状态（$S_0, S_1, S_2, S_3$）；当 $X=0$ 时，电路保持当前状态。要求是，仅当电路处于第四个状态 $S_3$ 时，输出 $Y$ 才为 $1$，在所有其他状态下 $Y$ 均为 $0$。

这是一个典型的[摩尔机](@entry_id:170836)应用。输出 $Y$ 的值是“处于特定状态”的结果，而不是状态转移的产物。其[状态图](@entry_id:176069)将包含四个状态，$S_0, S_1, S_2$ 的输出均为 $0$，而 $S_3$ 的输出为 $1$。从任意状态 $S_i$ 出发，当输入 $X=1$ 时，有一条指向 $S_{(i+1) \pmod 4}$ 的转移；当输入 $X=0$ 时，有一条指向其自身的环路。

**示例：[序列检测器](@entry_id:261086)（计数型）**
另一个经典的[摩尔机](@entry_id:170836)例子是检测输入序列中某种模式的出现次数。例如，设计一个电路，其输出为 $1$ 当且仅当自初始化以来接收到的二[进制](@entry_id:634389)输入流中 $0$ 的总数是 $3$ 的倍数（包括零个 $0$） [@problem_id:1962069]。

这里的关键是，输出[信号表示](@entry_id:266189)的是一个累积的属性（到目前为止 $0$ 的数量模 $3$ 的余数）。这个属性正是系统需要“记忆”的信息。因此，我们可以定义三个状态来分别代表余数为 $0$、 $1$ 和 $2$ 的情况：
- $S_0$: 已接收的 $0$ 的数量是 $3$ 的倍数 ($count \pmod 3 = 0$)。
- $S_1$: 已接收的 $0$ 的数量模 $3$ 余 $1$ ($count \pmod 3 = 1$)。
- $S_2$: 已接收的 $0$ 的数量模 $3$ 余 $2$ ($count \pmod 3 = 2$)。

因为输出仅依赖于这个余数（余数为 $0$ 时输出 $1$，否则输出 $0$），这是一个[摩尔机](@entry_id:170836)。状态 $S_0$ 的输出为 $1$，而 $S_1$ 和 $S_2$ 的输出为 $0$。当输入为 $1$ 时， $0$ 的数量不变，状态保持不变。当输入为 $0$ 时， $0$ 的数量加一，状态从 $S_i$ 转移到 $S_{(i+1) \pmod 3}$。这个 FSM 共有 $3$ 个状态，每个状态有 $2$ 个出边（对应输入 $0$ 和 $1$），因此总共有 $3 \times 2 = 6$ 条转移。

#### [米利机](@entry_id:177066)：输出由转移决定

与[摩尔机](@entry_id:170836)不同，在**[米利机](@entry_id:177066) (Mealy Machine)** 中，输出不仅取决于当前状态，还取决于当前的输入。输出函数 $Y$ 是当前状态 $S$ 和当前输入 $X$ 的函数，写作 $Y = g(S, X)$。

在[状态图](@entry_id:176069)中，[米利机](@entry_id:177066)的输出标记在转移弧线上，格式为 `输入/输出`。这意味着输出是与特定的“状态-输入”组合相关联的事件。

[米利机](@entry_id:177066)的主要优势在于它对输入的响应速度。输出可以在导致它的输入出现的同个[时钟周期](@entry_id:165839)内就发生变化，而无需等待下一个时钟边沿使状态发生改变。这有时也使得[米利机](@entry_id:177066)可以用比等效[摩尔机](@entry_id:170836)更少的状态来实现相同的功能。

**示例：'10' [序列检测器](@entry_id:261086)**
设计一个检测器，当输入序列中出现 '10' 模式时，输出 $Z$ 在一个[时钟周期](@entry_id:165839)内变为 $1$ [@problem_id:1962046]。该检测器需要处理重叠的序列，例如输入 $10101$ 应产生输出 $01010$。

这个任务非常适合用[米利机](@entry_id:177066)实现。输出 $Z=1$ 并不是一个持久的状态，而是一个在特定条件下发生的瞬时事件：即当前输入为 $0$ *并且* 前一个输入为 $1$。因此，我们只需要“记忆”一件事：“上一个输入是不是 $1$？” 这自然地导向了两个状态：
- $S_0$: 空闲状态，或上一个输入不是 $1$。
- $S_1$: 刚刚接收到一个 $1$。

状态转移和输出如下定义：
- 在 $S_0$: 若输入为 $0$，我们没有看到 '10'，输出 $0$，并保持在 $S_0$。若输入为 $1$，我们看到了一个潜在的前缀，输出 $0$，转移到 $S_1$。 ($S_0 \xrightarrow{0/0} S_0$, $S_0 \xrightarrow{1/0} S_1$)
- 在 $S_1$: 若输入为 $0$，我们成功检测到 '10' 模式，输出 $1$，并返回到 $S_0$ 准备下一次检测。若输入为 $1$，我们看到了 '11'，这虽然没有完成 '10' 检测，但最后一个 '1' 仍然可以作为新模式的前缀，所以输出 $0$，并保持在 $S_1$。 ($S_1 \xrightarrow{0/1} S_0$, $S_1 \xrightarrow{1/0} S_1$)

这个设计使用了最少的 $2$ 个[状态和](@entry_id:193625) $2 \times 2 = 4$ 条转移，完美地完成了任务。

**示例：触发控制器**
另一个例子是设计一个特殊的触发控制器 [@problem_id:1962072]。它有一个输入 $X$ 和一个输出 $Z$。规则是：当 $X=1$ 时，输出 $Z$ 翻转（与上一次因 $X=1$ 而产生的输出相反）；当 $X=0$ 时，输出 $Z$ 恒为 $0$。初始时，第一个 $X=1$ 将产生 $Z=1$。
这里的输出行为也依赖于当前输入和内部“记忆”。我们需要两个状态来记忆下一次 $X=1$ 应该产生什么输出：
- 状态 A: 下一个 $X=1$ 应输出 $1$。
- 状态 B: 下一个 $X=1$ 应输出 $0$。

初始状态为 A。
- 从 A: 输入 $X=0$，输出 $0$，状态不变 ($A \xrightarrow{0/0} A$)。输入 $X=1$，按定义输出 $1$，并翻转记忆，转移到 B ($A \xrightarrow{1/1} B$)。
- 从 B: 输入 $X=0$，输出 $0$，状态不变 ($B \xrightarrow{0/0} B$)。输入 $X=1$，按定义输出 $0$，并翻转记忆，转移到 A ($B \xrightarrow{1/0} A$)。

### 选择正确的模型：一个关于表达能力的案例研究

[摩尔机](@entry_id:170836)和[米利机](@entry_id:177066)之间的选择并非任意，它取决于问题的具体要求，特别是关于输出的时序。一个经典案例深刻地揭示了两者在[表达能力](@entry_id:149863)上的差异：串行二[补码](@entry_id:756269)转换器 [@problem_id:1962067]。

任务是设计一个电路，从最低有效位 (LSB) 开始逐位接收一个二进制数，并立即输出其二补码的对应位。二[补码](@entry_id:756269)的计算规则是：“从 LSB 开始，保持所有位不变，直到并包括第一个 $1$，然后反转之后的所有位。”
例如，输入 `...00110` (数字6)，输出应为 `...11010` (-6)。

让我们分析这个规则：
- 在遇到第一个 $1$ 之前，输出位等于输入位 ($y_i = x_i$)。
- 在遇到第一个 $1$ 之后（包括那个 $1$），输出位是输入位的[反码](@entry_id:172386) ($y_i = \overline{x_i}$)。

这个行为可以用一个简单的[米利机](@entry_id:177066)实现。我们需要两个状态来记忆“是否已经遇到了第一个 $1$”：
- 状态 $C$ (Copy): 尚未遇到第一个 $1$。
- 状态 $N$ (Negate): 已经遇到了第一个 $1$。

状态转移如下：
- 在状态 $C$ 中：
    - 如果输入 $x_i = 0$，输出 $y_i = 0$ (复制)，并保持在状态 $C$。 ($C \xrightarrow{0/0} C$)
    - 如果输入 $x_i = 1$，输出 $y_i = 1$ (复制)，这是第一个 $1$，所以转移到状态 $N$。 ($C \xrightarrow{1/1} N$)
- 在状态 $N$ 中：
    - 如果输入 $x_i = 0$，输出 $y_i = 1$ (反转)，并保持在状态 $N$。 ($N \xrightarrow{0/1} N$)
    - 如果输入 $x_i = 1$，输出 $y_i = 0$ (反转)，并保持在状态 $N$。 ($N \xrightarrow{1/0} N$)

这个两状态的[米利机](@entry_id:177066)完美地实现了所需功能。现在，关键问题来了：能否用[摩尔机](@entry_id:170836)实现？

答案是不能。根据规范，输出 $y_i$ 必须在接收到输入 $x_i$ 的同个周期内产生。在状态 $C$ 中（尚未遇到第一个 $1$），规范要求输出 $y_i = x_i$。这意味着如果 $x_i=0$，输出必须是 $0$；如果 $x_i=1$，输出必须是 $1$。然而，[摩尔机](@entry_id:170836)的输出只依赖于状态。当机器处于状态 $C$ 时，它的输出是固定的，不能根据当前输入 $x_i$ 的变化而变化。它无法在同一个状态 $C$ 中既能输出 $0$ 又能输出 $1$。因此，任何[摩尔机](@entry_id:170836)都无法满足“在同一个[时钟周期](@entry_id:165839)内输出等于当前输入”这个要求。

这个案例有力地证明了，当输出需要对当前输入做出即时反应时，[米利机](@entry_id:177066)是必要且更强大的工具。

### 状态定义的艺术：从规范到状态

FSM 设计中最具挑战性也最具创造性的部分是**定义状态**。一个好的状态定义是设计成功的关键。其核心指导原则是：

> **一个状态必须封装所有关于过去历史的信息，这些信息对于决定未来的行为是必要的。**

换句话说，状态是系统对过去的“记忆摘要”。

#### 步骤 1：形式化行为描述

设计的第一步总是从清晰、无[歧义](@entry_id:276744)地理解需求开始。通常需要将自然语言描述的规则转化为精确的状态转移逻辑。例如，在设计一个简单的音乐播放器控制器时 [@problem_id:1962042]，我们需要为“播放中”和“暂停”两个状态，精确定义 `播放/暂停`、`下一首`、`上一首` 这三个命令如何影响状态的转移。例如，在“暂停”状态下，任何一个命令都会使其进入“播放中”状态。

#### 步骤 2：识别必要的记忆

要确定需要多少个状态以及每个状态代表什么，我们应该问：“系统必须记住哪些关于过去输入的信息，才能正确地处理未来的输入？”

- **简单记忆**：在'10'[序列检测器](@entry_id:261086)中 [@problem_id:1962046]，唯一需要记住的历史信息是“上一个输入是不是 $1$？”。这直接导致了两个状态的划分。

- **复杂控制器**：对于一个 2 槽位的先进先出 (FIFO) 缓冲区的控制器 [@problem_id:1962066]，其行为取决于缓冲区是空的、半满还是全满。因此，需要记住的关键信息就是缓冲区中的项目数量。这自然地产生了三个状态：$S_0$ (0个项目), $S_1$ (1个项目), 和 $S_2$ (2个项目)。然后，对于每个状态，我们必须分析所有可能的输入组合（如读写请求 `(WR, RD)`) 的影响。例如，在状态 $S_1$（半满）时，如果同时收到读和写请求 `(1, 1)`，一个项目被读出一个项目被写入，净变化为零，因此状态保持在 $S_1$。

- **复合信息记忆**：在更复杂的系统中，状态可能需要编码多种信息。考虑为一个以 3 比特为数据包的串行协议设计一个偶校验位生成器 [@problem_id:1962070]。电路必须在第三个比特到达的同个周期输出整个包的偶校验位。为了在第三位 $d_3$ 到达时计算出总校验位 $P = d_1 \oplus d_2 \oplus d_3$，电路在接收 $d_3$ 之前，其状态必须已经“记住”了前两个比特的[异或](@entry_id:172120)和 $d_1 \oplus d_2$。但这还不够，电路还必须知道当前是在接收第几个比特，以便在处理完第三个比特后重置。因此，状态必须编码**位置**和**累积值**两个信息：
    - 初始状态（第0位之前）：1个状态。
    - 第1位之后：需要区分累积奇偶性（$d_1$ 是0还是1），需要2个状态。
    - 第2位之后：需要区分累积奇偶性（$d_1 \oplus d_2$ 是0还是1），需要2个状态。
    因此，总共需要 $1 + 2 + 2 = 5$ 个状态来完整地描述这个过程。

#### 步骤 3：[状态最小化](@entry_id:273227)与等价性

设计时，我们总是力求使用最少的状态来实现功能，因为更少的状态通常意味着更简单的电路。[状态最小化](@entry_id:273227)的基本思想是合并**等价 (Equivalent)** 的状态。两个状态被认为是等价的，如果对于任何可能的未来输入序列，它们产生的输出序列都完全相同。

一个简单的检查方法是：如果两个状态（在[摩尔机](@entry_id:170836)中）具有相同的输出，并且对于每一个可能的输入，它们都转移到同一个或等价的下一状态，那么它们是等价的，可以合并。

然而，仅仅输出相同并不足以保证[状态等价](@entry_id:261329)。一个深刻的例子是通信[握手协议](@entry_id:174594)的设计 [@problem_id:1962053]。在这个[摩尔机](@entry_id:170836)中，发送方有四个操作阶段，需要四个状态来实现：
1.  **空闲 (Idle)**: 输出 (RTS=0, DATA_VALID=0)。
2.  **请求等待 (Requesting)**: 输出 (RTS=1, DATA_VALID=0)。
3.  **传输 (Transmitting)**: 输出 (RTS=1, DATA_VALID=1)。
4.  **清理 (Cleanup)**: 输出 (RTS=0, DATA_VALID=0)。

注意到“空闲”和“清理”状态具有完全相同的摩尔输出 $(0,0)$。我们能将它们合并成一个状态吗？答案是不能。原因在于它们的**未来行为**不同，即它们的状态[转移函数](@entry_id:273897)不同。
- 在“空闲”状态，如果接收到“开始传输”命令 ($START\_TX=1$)，机器必须立即转移到“请求等待”状态。
- 在“清理”状态，机器刚完成一次传输，正在等待接收方确认。此时，即使收到新的 $START\_TX=1$ 命令，它也必须忽略，并保持在“清理”状态，直到接收方的“清除发送”信号 ($CTS$) 变为 $0$。

由于对于相同的输入（例如，$START\_TX=1$），这两个状态要求转移到不同的下一状态，因此它们是不可等价的，必须作为两个独立的状态存在。这个例子强调了一个核心原则：**状态不仅由其即时输出定义，更由其未来的全部转移行为定义。**

### 构建完整的[状态图](@entry_id:176069)

总结来说，从一个问题规范到最终的[状态图](@entry_id:176069)，我们通常遵循以下系统性步骤：
1.  **分析规范**：仔细阅读并完全理解系统的行为需求，包括所有输入、输出及其相互关系和时序。
2.  **选择模型并定义状态**：根据输出的时序要求选择[摩尔机](@entry_id:170836)或[米利机](@entry_id:177066)。然后，通过识别系统需要“记忆”哪些历史信息来定义一组最小的必要状态。
3.  **绘制转移**：对于每一个状态，系统地考虑所有可能的输入（或输入组合），并画出对应的状态转移弧线到正确的下一状态。
4.  **分配输出**：根据所选模型，将输出值标记在状态圈内（[摩尔机](@entry_id:170836)）或转移弧线上（[米利机](@entry_id:177066)）。
5.  **验证和审查**：用一些典型的输入序列来“演练”你的[状态图](@entry_id:176069)，确保其行为与规范完全一致。检查是否有可以合并的等价状态以实现最小化。

[状态图](@entry_id:176069)是连接抽象行为描述与具体硬件实现之间的桥梁。一旦一个正确、最小化的[状态图](@entry_id:176069)被确定下来，将其转化为[逻辑门](@entry_id:142135)和[触发器](@entry_id:174305)（例如[D触发器](@entry_id:171740)）的实现过程就变得直接而系统化。因此，掌握[状态图](@entry_id:176069)的原理与机制是每一位数字[系统工程](@entry_id:180583)师的基本功。