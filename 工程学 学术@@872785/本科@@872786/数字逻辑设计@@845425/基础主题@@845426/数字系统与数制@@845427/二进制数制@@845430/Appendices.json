{"hands_on_practices": [{"introduction": "数字系统在内部统一使用二进制进行计算，但其输入和输出常常采用十六进制或八进制等更紧凑的表示法。这个练习旨在巩固在不同数制之间转换以及在固定位宽的处理器内执行基本算术运算的核心技能。通过解决这个问题[@problem_id:1914540]，你将模拟一个微处理器如何处理来自不同格式源的数据，并执行减法操作。", "problem": "一个假设的16位微处理器中的算术逻辑单元（ALU）被赋予执行一条减法指令的任务。该微处理器的内部架构使用16位二进制补码系统来表示所有有符号整数。\n\n要执行的操作是 `R = A - B`。操作数 `A` 从一个内存位置加载，它在该位置以十六进制值 $D4B_{16}$ 存储。操作数 `B` 从另一个内存位置加载，它在该位置以八进制值 $3157_8$ 存储。\n\n你的任务是确定结果 `R` 存储在16位寄存器中的最终值。将你的最终答案表示为 `R` 的16位二进制形式。", "solution": "在16位二进制补码系统中，最高有效位为 $0$ 的值直接表示非负整数，而减法 $R=A-B$ 是在模 $2^{16}$ 的意义下，使用常规的二进制算术来执行的。\n\n将操作数解释为一致的16位形式。十六进制操作数是 $A=(D4B)_{16}=(0D4B)_{16}$。按半字节（nibble）转换为二进制，得到\n$$(0D4B)_{16} \\to (0000\\ 1101\\ 0100\\ 1011)_{2}=(0000110101001011)_{2}。$$\n对于八进制操作数 $B=(3157)_{8}$，通过 $3\\mapsto 011$、$1\\mapsto 001$、$5\\mapsto 101$、$7\\mapsto 111$ 将其转换为二进制，得到\n$$(3157)_{8}=(011001101111)_{2}。$$\n补齐至16位，如果需要，可以重新组合为十六进制：\n$$(011001101111)_{2}=(0000\\ 0110\\ 0110\\ 1111)_{2}=(066F)_{16}。$$\n\n用十六进制计算减法：\n$$R=A-B=(0D4B)_{16}-(066F)_{16}=(06DC)_{16}，$$\n这可以通过带借位的按位相减来验证。\n\n按半字节（nibble）将结果转换为16位二进制：\n$$(06DC)_{16} \\to (0000\\ 0110\\ 1101\\ 1100)_{2}=(0000011011011100)_{2}。$$\n\n作为十进制的一致性检查，$A=13\\cdot 16^{2}+4\\cdot 16+11=3403$，$B=3\\cdot 8^{3}+1\\cdot 8^{2}+5\\cdot 8+7=1647$，所以 $R=3403-1647=1756$，而 $1756=(06DC)_{16}$ 确实成立。其绝对值小于 $2^{15}$，因此没有发生溢出，其二进制补码表示就是上面给出的16位二进制数。", "answer": "$$\\boxed{0000011011011100}$$", "id": "1914540"}, {"introduction": "在理想的数学世界里，数字可以无限大，但在现实的数字电路中，我们总要面对有限位数的限制。当计算结果超出了系统所能表示的范围时，就会发生“溢出”，这是一个必须理解和处理的关键问题。这个练习[@problem_id:1914561]通过一个简单的4位系统，清晰地揭示了在有符号数加法中溢出是如何发生的，以及溢出后系统会如何错误地解释结果。", "problem": "一个低功耗环境传感器的原型机使用一个专门的4位处理器来执行初始数据过滤。该处理器使用4位二进制补码系统来表示有符号整数。在一次测试运行中，该处理器需要将两个传感器读数相加，这两个读数由二进制值 $X = 0110_2$ 和 $Y = 0100_2$ 表示。和存储在一个4位的寄存器中。下列哪个陈述准确地描述了这次加法运算的结果？\n\nA. 加法运算得到正确的十进制值+10，且没有发生溢出。\nB. 加法运算导致溢出，且存储的4位二进制值表示十进制值-6。\nC. 加法运算导致溢出，且存储的4位二进制值表示十进制值+2。\nD. 加法运算没有导致溢出，且存储的4位二进制值为 $0000_2$。\nE. 加法运算导致溢出，且存储的4位二进制值与该系统中可表示的最大负数的表示形式相同。", "solution": "在一个4位二进制补码系统中，可表示的范围由 $[-2^{n-1},\\,2^{n-1}-1]$ 给出，其中 $n=4$，因此范围是 $[-8,\\,7]$。给定的操作数是 $X=0110_{2}$ 和 $Y=0100_{2}$，它们的最高有效位都是 $0$，因此都是非负数。转换为十进制，$0110_{2}=+6$ 且 $0100_{2}=+4$，所以真实的数学和是 $+10$，这超出了可表示的范围，表明预期会发生溢出。\n\n执行4位加法运算：\n- 位 $0$：$0+0=0$，进位 $0$。\n- 位 $1$：$1+0=1$，进位 $0$。\n- 位 $2$：$1+1=0$，带进位 $1$。\n- 位 $3$ (MSB)：$0+0+\\text{carry }1=1$，带出位 $0$。\n\n因此，存储的4位结果是\n$$0110_{2}+0100_{2}=1010_{2}。$$\n二进制补码中的溢出检测可以通过任一规则来检查：两个符号相同的操作数相加得到一个符号相反的结果，或者进入最高有效位(MSB)的进位与从最高有效位(MSB)产生的进位不同。在这里，两个操作数的符号位都是 $0$，而结果的符号位是 $1$，所以发生了溢出。等效地，进入最高有效位的进位是 $1$，而产生的进位是 $0$，所以发生了溢出。\n\n以二进制补码解释存储的4位值 $1010_{2}$：由于最高有效位是 $1$，它是一个负数。其绝对值通过取二进制补码得到：\n$$\\text{invert}(1010_{2})=0101_{2},\\quad 0101_{2}+0001_{2}=0110_{2}，$$\n所以 $1010_{2}$ 表示十进制中的 $-6$。\n\n因此，加法运算导致溢出，且存储的4位二进制值表示十进制值 $-6$，与选项B相符。", "answer": "$$\\boxed{B}$$", "id": "1914561"}, {"introduction": "除了基本的加减法，数字系统还使用巧妙的位操作来实现更复杂的数学功能，以提高效率。这个练习[@problem_id:1914545]将带你探索算术右移操作，它是在硬件层面实现有符号整数除以二的高效快捷方式。通过这个实例，你将理解这种位移操作与传统除法的关系，特别是它在处理负数时的独特取整行为。", "problem": "一个为低温实验定制的数字控制器使用一个8位算术逻辑单元 (ALU) 来处理温度数据。温度以8位二进制补码有符号整数表示，单位为摄氏度。该控制器的固件被设计用于计算两个连续温度读数的平均值。\n\n该过程包括两个步骤：\n1.  控制器接收两个读数，$R_1 = -21$ 和 $R_2 = -44$。ALU首先计算它们的和 $S = R_1 + R_2$，并将结果存储在一个8位寄存器中。\n2.  为了求平均值，控制器接着对8位的和 $S$ 执行一次算术右移。此移位操作的结果是存储在平均寄存器中的最终值。\n\n确定在算术右移操作后，平均寄存器中的8位二进制数所表示的最终十进制整数值。", "solution": "温度以8位二进制补码有符号整数存储。其范围是从 $-128$ 到 $127$。读数为 $R_{1}=-21$ 和 $R_{2}=-44$，所以它们的和是\n$$\nS=R_{1}+R_{2}=-21+(-44)=-65,\n$$\n该值在可表示的范围内，因此没有发生溢出。\n\n在8位二进制补码中，$-21$ 是通过将 $00010101$ 取反并加 $1$ 得到的，结果为 $11101011$；而 $-44$ 是通过将 $00101100$ 取反并加 $1$ 得到的，结果为 $11010100$。在8位上相加，\n$$\n11101011+11010100=10111111 \\quad (\\text{discarding the carry out}),\n$$\n其结果表示 $-65$，符合预期。\n\n为了计算平均值，控制器对 $S$ 执行一次算术右移。对一个二进制补码整数进行算术右移，等效于带符号的除以2运算，并向负无穷大舍入，即，\n$$\n\\operatorname{ASR}_{1}(S)=\\left\\lfloor \\frac{S}{2} \\right\\rfloor.\n$$\n因此，\n$$\n\\operatorname{ASR}_{1}(-65)=\\left\\lfloor \\frac{-65}{2} \\right\\rfloor=\\left\\lfloor -32.5 \\right\\rfloor=-33.\n$$\n等价地，将二进制数 $10111111$ 算术右移一位（复制符号位）得到 $11011111$，这是 $-33$ 的二进制补码。\n\n因此，平均寄存器中最终的十进制整数值为 $-33$。", "answer": "$$\\boxed{-33}$$", "id": "1914545"}]}