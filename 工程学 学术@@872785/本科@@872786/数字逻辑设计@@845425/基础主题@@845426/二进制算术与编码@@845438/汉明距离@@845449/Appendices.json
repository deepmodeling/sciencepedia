{"hands_on_practices": [{"introduction": "汉明距离不仅用于比较静态的数据块，它在分析如计数器等时序逻辑电路的状态转换中也同样重要。这个练习将帮助你通过计算一个二进制计数器在几个时钟周期前后的状态差异，来具体感受汉明距离如何量化数字系统状态随时间的变化 [@problem_id:1941035]。这种分析对于理解状态机的行为和功耗至关重要。", "problem": "一个简单的嵌入式系统使用一个4位寄存器作为状态计数器，以循环切换不同的工作模式。该寄存器实现为一个同步二进制加法计数器，在每个时钟脉冲到来时其值加一。系统初始化时，状态计数器中的值为十进制数3的二进制表示。初始化后，系统接收到两个时钟脉冲。\n\n计算第一个时钟脉冲*之前*计数器的二进制状态与第二个时钟脉冲*之后*其二进制状态之间的汉明距离。", "solution": "同步二进制加法计数器在每个时钟脉冲到来时会将其存储的值加一。对于一个4位寄存器，算术运算是模$2^{4}$的，且任何时刻的二进制状态是所存储整数的4位二进制表示。\n\n设4位状态写成行向量 $(b_{3},b_{2},b_{1},b_{0})$，其中 $b_{3}$ 是最高有效位。系统初始化为十进制数 $3$，其4位二进制表示为\n$$\nS_{0}=(0,0,1,1).\n$$\n第一个时钟脉冲后，计数器加一：\n$$\nS_{1}=S_{0}+1 \\pmod{2^{4}}=(0,1,0,0),\n$$\n因为十进制数 $4$ 的4位二进制表示为 $(0,10,0)$。第二个时钟脉冲后，它再次加一：\n$$\nS_{2}=S_{1}+1 \\pmod{2^{4}}=(0,1,0,1),\n$$\n因为十进制数 $5$ 是 $(0,1,0,1)$。\n\n两个二进制向量之间的汉明距离等于它们比特位不同的位置数量，也就是它们按位异或结果的汉明权重。将按位异或记为 $\\oplus$，汉明权重记为 $\\mathrm{wt}(\\cdot)$，我们计算\n$$\nd_{H}(S_{0},S_{2})=\\mathrm{wt}\\big(S_{0}\\oplus S_{2}\\big)=\\mathrm{wt}\\big((0,0,1,1)\\oplus(0,1,0,1)\\big)=\\mathrm{wt}(0,1,1,0)=2.\n$$\n因此，汉明距离是 $2$。", "answer": "$$\\boxed{2}$$", "id": "1941035"}, {"introduction": "将抽象的数学概念转化为具体的逻辑电路是数字设计工程师的核心技能。这个练习挑战你设计一个组合逻辑电路，该电路能计算两个输入字之间的汉明距离，从而将汉明距离的理论定义与硬件实现直接联系起来 [@problem_id:1941078]。通过推导布尔表达式并考虑其最小化，你将深入理解如何用逻辑门构建复杂的数据处理功能。", "problem": "在数字通信系统中，确保数据完整性至关重要。用于错误检测的一个基本度量是汉明距离，它量化了两个等长二进制字在多少个比特位上有所不同。\n\n考虑一个监控电路，其设计用于比较一个发送的3位二进制字 $A = A_2A_1A_0$ 和一个接收的3位二进制字 $B = B_2B_1B_0$。该电路的输出 $Z$ 是一个2位二进制数 $Z=Z_1Z_0$（其中 $Z_1$ 是最高有效位），表示汉明距离 $d_H(A, B)$。汉明距离与输出 $Z$ 之间的关系定义如下：\n- 如果 $d_H(A, B) = 0$，则 $Z_1Z_0 = 00$。\n- 如果 $d_H(A, B) = 1$，则 $Z_1Z_0 = 01$。\n- 如果 $d_H(A, B) = 2$，则 $Z_1Z_0 = 10$。\n- 如果 $d_H(A, B) = 3$，则 $Z_1Z_0 = 11$。\n\n您的任务是确定每个输出位 $Z_1$ 和 $Z_0$ 的最小乘积和 (SOP) 布尔表达式中乘积项的数量。这些表达式应被视为六个输入变量 $A_2, A_1, A_0, B_2, B_1, B_0$ 的函数。\n\n请以一个包含两个整数的行矩阵形式提供您的答案，其中第一个整数是 $Z_1$ 的乘积项数量，第二个整数是 $Z_0$ 的乘积项数量。", "solution": "令 $D_{i} \\equiv A_{i} \\oplus B_{i}$，其中 $i \\in \\{2,1,0\\}$。根据3位字 $A$ 和 $B$ 之间汉明距离的定义，不同比特位的数量是整数和\n$$\nd_{H}(A,B)=D_{2}+D_{1}+D_{0}.\n$$\n输出 $Z=Z_{1}Z_{0}$ 是这个和的标准二进制编码：\n- $Z_{0}$ 是 $D_{2}+D_{1}+D_{0}$ 的最低有效位，因此\n$$\nZ_{0}=D_{2}\\oplus D_{1}\\oplus D_{0}.\n$$\n- $Z_{1}$ 是最高有效位，对于三个输入，它是一个阈值函数“至少有两个1”，等价于\n$$\nZ_{1}=D_{2}D_{1}+D_{2}D_{0}+D_{1}D_{0}.\n$$\n\n我们现在确定在六个输入变量 $A_{2},A_{1},A_{0},B_{2},B_{1},B_{0}$ 上最小SOP的大小。\n\n首先，对每对变量使用异或（XOR）和同或（XNOR）的SOP形式：\n$$\nD_{i}=A_{i}\\oplus B_{i}=\\overline{A_{i}}B_{i}+A_{i}\\overline{B_{i}},\\qquad\n\\overline{D_{i}}=A_{i}\\odot B_{i}=A_{i}B_{i}+\\overline{A_{i}}\\overline{B_{i}}.\n$$\n\n对于 $Z_{0}$，根据 $\\oplus$ 的结合律和交换律，\n$$\nZ_{0}=(A_{2}\\oplus B_{2})\\oplus(A_{1}\\oplus B_{1})\\oplus(A_{0}\\oplus B_{0})\n= A_{2}\\oplus B_{2}\\oplus A_{1}\\oplus B_{1}\\oplus A_{0}\\oplus B_{0}.\n$$\n因此 $Z_{0}$ 是六变量奇校验函数。翻转六个输入中的任何一个都会使 $Z_{0}$ 的值反转，因此在六变量空间中，任何两个汉明距离为一的输入组合都不会同时在“1”集合（on-set）中。因此，从卡诺图或立方体图的角度来看，没有比单个最小项更大的蕴含项；最小SOP恰好由每个“1”集合的最小项对应一个乘积项组成。由于 $2^{6}$ 个输入组合中恰好有一半产生奇校验，所以“1”集合的大小是 $2^{6-1}=32$。因此 $Z_{0}$ 的最小SOP有 $32$ 个乘积项。\n\n对于 $Z_{1}$，使用\n$$\nZ_{1}=D_{2}D_{1}+D_{2}D_{0}+D_{1}D_{0}.\n$$\n每个乘积 $D_{i}D_{j}$ 展开（使用 $D_k$ 的SOP形式）为\n$$\nD_{i}D_{j}=(\\overline{A_{i}}B_{i}+A_{i}\\overline{B_{i}})(\\overline{A_{j}}B_{j}+A_{j}\\overline{B_{j}})\n$$\n$$\n=\\;\\overline{A_{i}}B_{i}\\,\\overline{A_{j}}B_{j}\\;+\\;\\overline{A_{i}}B_{i}\\,A_{j}\\overline{B_{j}}\\;+\\;A_{i}\\overline{B_{i}}\\,\\overline{A_{j}}B_{j}\\;+\\;A_{i}\\overline{B_{i}}\\,A_{j}\\overline{B_{j}}.\n$$\n这是四个不同的4文字乘积项，不涉及第三对变量 $(A_{k},B_{k})$。在这四项的集合中，没有任意两项仅在一个文字上不同（它们在一对变量内相差两个文字），因此它们不能合并成更大的蕴含项。在不同的变量对组合之间（例如，$D_{2}D_{1}$ 和 $D_{2}D_{0}$ 之间），这些项涉及不同的变量对，同样不能合并成更少或更大的乘积项。因此，三个两两相乘的乘积中的每一个都恰好贡献了 $4$ 个不可化简的乘积项，使得 $Z_1$ 的最小SOP总共有 $3\\times 4=12$ 个乘积项。\n\n因此，最小SOP中的乘积项数量对于 $Z_1$ 是 $12$ 个，对于 $Z_0$ 是 $32$ 个。", "answer": "$$\\boxed{\\begin{pmatrix}12  32\\end{pmatrix}}$$", "id": "1941078"}, {"introduction": "汉明距离最重要的应用在于构建可靠的通信和存储系统，其核心是纠错码的设计。本练习通过一个模拟的工程场景，引导你探索纠错码的能力边界 [@problem_id:1941082]。通过分析一个解码失败的案例，你将学会如何推断一个编码系统的关键参数——最小汉明距离 $d_{\\min}$，并进一步探讨满足汉明界的“完美码”的理论极限。", "problem": "一个用于高精度机械臂的控制器使用7位二进制字来发送运动指令。为了保护这些指令免受工厂环境中的电噪声干扰，该系统使用了一种纠错码，该纠错码将128个可能的7位字符串中的一个特定子集指定为有效的“码字”。所有其他字符串都被视为无效。\n\n在一次质量保证测试中，工程师们发现了一个关键漏洞。当控制器尝试发送有效码字 $C_A = 1010101$ 时，由于噪声引起的单比特翻转可能导致损坏的字 $R = 1011101$。系统的纠错逻辑检测到错误，但无法执行纠正，因为它判定接收到的字 $R$ 与两个不同的有效码字等距：原始的 $C_A$ 和另一个有效码字 $C_B$。\n\n这种模糊性揭示了当前使用的编码的真实最小汉明距离 ($d_{\\min}$) 。您的任务是分析这种情况，然后评估一个提议的替代方案。该替代方案将是一种假设的、*不同*的编码方案，也使用7位字，并被设计成一个“完美码”。这个完美码被要求具有新的最小距离 $d'_{\\min} = d_{\\min} + 1$。对于这样一个完美码，它可能包含的唯一有效码字的最大数量 $M$ 是多少？\n\n注意：一个能够在 $n$ 位字中纠正 $t$ 个错误的完美码满足汉明界的等式：$M \\cdot \\sum_{i=0}^{t} \\binom{n}{i} = 2^n$。", "solution": "问题要求计算一个假设的7位完美码中码字的数量 $M$。要使用给定的公式求出 $M$，我们首先需要确定这个假设编码的参数 $n$ 和 $t$。\n\n字长给定为 $n=7$。纠错能力 $t$ 取决于编码的最小汉明距离 $d'_{\\min}$。问题指出，对于假设的编码，其最小汉明距离为 $d'_{\\min} = d_{\\min} + 1$，其中 $d_{\\min}$ 是情景中描述的*原始*编码的最小汉明距离。因此，我们的第一步是根据所提供的信息确定 $d_{\\min}$。\n\n该情景描述了接收到的字 $R=1011101$ 与两个有效码字 $C_A=1010101$ 和 $C_B$ 等距的情况。问题指出 $R$ 是由 $C_A$ 发生单比特翻转得到的结果。汉明距离计算的是不同比特的数量，$C_A$ 和 $R$ 之间的汉明距离确实是1：\n$d_H(C_A, R) = d_H(1010101, 1011101) = 1$ （它们仅在从左数第4位上不同）。\n\n由于 $R$ 与 $C_A$ 和 $C_B$ 等距，因此 $R$ 和 $C_B$ 之间的汉明距离也必须是1：\n$d_H(R, C_B) = 1$。\n\n现在我们可以使用汉明距离的三角不等式性质来关联两个有效码字 $C_A$ 和 $C_B$ 之间的距离：\n$d_H(C_A, C_B) \\le d_H(C_A, R) + d_H(R, C_B)$\n代入已知的距离：\n$d_H(C_A, C_B) \\le 1 + 1 = 2$\n\n由于 $C_A$ 和 $C_B$ 是不同的有效码字，它们的汉明距离必须是一个正整数。因此，$d_H(C_A, C_B)$ 只能是1或2。如果 $d_H(C_A, C_B) = 1$，这将意味着 $C_B$ 可以通过翻转 $C_A$ 的一个比特位来形成。然而，情景中指出，翻转 $C_A$ 的一个比特位会得到损坏的字 $R$，并且系统无法在 $C_A$ 和 $C_B$ 之间做出决定，这意味着 $R$ 本身不是一个有效的码字。这种纠错的模糊性意味着 $R$ 必须与 $C_A$ 和 $C_B$ 都不同。如果 $d_H(C_A, C_B) = 1$，这将是不可能的。因此，$d_H(C_A, C_B)$ 必须是2。\n\n一个编码的最小汉明距离 $d_{\\min}$ 是任意一对不同有效码字之间的最小汉明距离。由于我们找到了一对距离为2的有效码字 $(C_A, C_B)$，整个编码的最小汉明距离不能大于2，即 $d_{\\min} \\le 2$。由于任何单比特错误检测都要求 $d_{\\min}$ 至少为2，我们可以得出结论，原始编码的最小汉明距离恰好是 $d_{\\min}=2$。\n\n现在我们可以描述这个假设的完美码了。它的最小汉明距离是：\n$d'_{\\min} = d_{\\min} + 1 = 2 + 1 = 3$。\n\n一个最小距离为 $d'_{\\min}$ 的编码可以纠正的错误数量 $t$ 由公式 $t = \\lfloor \\frac{d'_{\\min} - 1}{2} \\rfloor$ 给出。\n代入 $d'_{\\min} = 3$：\n$t = \\lfloor \\frac{3 - 1}{2} \\rfloor = \\lfloor \\frac{2}{2} \\rfloor = 1$。\n因此，这个假设的完美码是一个单比特纠错码。\n\n我们现在可以使用问题陈述中为完美码提供的汉明界公式了：\n$M \\cdot \\sum_{i=0}^{t} \\binom{n}{i} = 2^n$。\n\n代入已知值 $n=7$ 和 $t=1$：\n$M \\cdot \\left( \\binom{7}{0} + \\binom{7}{1} \\right) = 2^7$。\n\n我们计算二项式系数：\n$\\binom{7}{0} = \\frac{7!}{0!(7-0)!} = 1$\n$\\binom{7}{1} = \\frac{7!}{1!(7-1)!} = \\frac{7}{1} = 7$\n\n将这些值代回方程中：\n$M \\cdot (1 + 7) = 128$\n$8M = 128$\n\n求解 $M$：\n$M = \\frac{128}{8} = 16$。\n\n在这个假设的完美码中，唯一有效码字的最大数量是16。", "answer": "$$\\boxed{16}$$", "id": "1941082"}]}