{"hands_on_practices": [{"introduction": "在数字系统中，当不同位宽的二进制数进行算术运算时，必须先将较小位宽的数扩展到与较大位宽的数相同的位数，同时保持其数值不变。这个过程对于有符号数来说，就是符号扩展。本练习提供了一个基础而关键的场景：在将一个4位补码数与一个8位补码数相加之前，如何正确地执行符号扩展([@problem_id:1913334])。通过这个计算，你将巩固符号扩展和补码加法的核心操作。", "problem": "一个简化的中央处理器 (CPU) 包含一个8位加法器，该加法器设计用于处理补码表示的整数。CPU需要计算两个数 $X$ 和 $Y$ 的和。数 $X$ 存储在一个4位寄存器中，其值为 $1010_2$。数 $Y$ 存储在一个8位寄存器中，其值为 $00010110_2$。\n\n为了执行该运算，4位数 $X$ 必须首先被转换为等效的8位补码表示形式，然后才能发送给加法器。然后，加法器计算和 $S = X + Y$。\n\n得到的和 $S$ 的8位补码二进制值是什么？\n\nA. $00010000_2$\n\nB. $00100000_2$\n\nC. $11110000_2$\n\nD. $11001000_2$\n\nE. $00000000_2$", "solution": "我们使用补码算术进行计算。\n\n1) 将4位数 $X=1010_{2}$ 解释为补码。对于一个位为 $b_{n-1}\\dots b_{0}$ 的 $n$ 位补码数，其值为\n$$\nv=-b_{n-1}2^{n-1}+\\sum_{k=0}^{n-2} b_{k}2^{k}.\n$$\n对于 $n=4$ 的 $X=1010_{2}$，我们有 $b_{3}=1$、$b_{1}=1$ 以及 $b_{2}=b_{0}=0$，因此\n$$\nX=-1\\cdot 2^{3}+1\\cdot 2^{1}=-8+2=-6.\n$$\n\n2) 将 $X$ 从4位符号扩展到8位。在补码中，符号扩展会复制最高有效位。由于 $X$ 的符号位是 $1$，其8位表示为\n$$\nX_{(8\\text{-bit})}=11111010_{2}.\n$$\n\n3) 将 $Y=00010110_{2}$ 解释为一个8位补码数。其符号位是 $0$，因此它是一个非负数：\n$$\nY=2^{4}+2^{2}+2^{1}=16+4+2=22.\n$$\n\n4) 计算和 $S=X+Y$：\n$$\nS=-6+22=16.\n$$\n在8位补码中，$16$ 表示为\n$$\nS=00010000_{2}.\n$$\n等价地，直接进行二进制加法也证实了这一点：\n$$\n11111010_{2}+00010110_{2}=00010000_{2},\n$$\n产生的进位在定长补码加法中被忽略；因为两个加数的符号相反，所以不会发生溢出。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1913334"}, {"introduction": "掌握符号扩展的正确方法固然重要，但理解错误实现所带来的后果同样关键。在电路设计中，一个微小的缺陷就可能导致灾难性的计算错误。此练习模拟了一种常见的硬件设计缺陷，即使用固定的比特值而非符号位来填充高位([@problem_id:1960202])。你的任务是推导出一个解析表达式来量化这种错误实现所造成的数值偏差，从而深刻体会到为何必须严格遵循符号扩展的规则。", "problem": "在专用数字信号处理器的设计中，一个核心组件是总线扩展模块。此模块的功能是将一个 $M$ 位数据字转换为一个 $N$ 位数据字，其中 $N > M$。输入和输出字都使用二补码表示法来表示有符号整数。\n\n设输入为一个 $M$ 位字，由位向量 $A = (a_{M-1}, a_{M-2}, \\dots, a_0)$ 表示，其中 $a_{M-1}$ 是最高有效位（符号位）。任意一个 $X$ 位二补码字 $W = (w_{X-1}, \\dots, w_0)$ 的数值定义为 $V(W) = -w_{X-1} 2^{X-1} + \\sum_{i=0}^{X-2} w_i 2^i$。\n\n在总线扩展逻辑中发现了一个设计缺陷。电路没有执行标准的符号扩展，而是根据以下规则从输入字 $A$ 构建 $N$ 位输出字 $B = (b_{N-1}, b_{N-2}, \\dots, b_0)$：\n1. 输出字 $B$ 的低 $M$ 位是输入字 $A$ 的位的直接副本。即，对于所有满足 $0 \\leq i \\leq M-1$ 的整数 $i$，$b_i = a_i$。\n2. 输出字 $B$ 的高 $N-M$ 位，即“扩展位”，全部设置为一个固定的常数位值 $k$，其中 $k \\in \\{0, 1\\}$。即，对于所有满足 $M \\leq i \\leq N-1$ 的整数 $i$，$b_i = k$。\n\n设 $V_A$ 为输入字 $A$ 所代表的数值，$V_B$ 为输出字 $B$ 所代表的数值。你的任务是推导此错误逻辑引入的误差的闭式解析表达式，该误差定义为差值 $\\Delta V = V_B - V_A$。你的最终表达式应使用输入符号位 $a_{M-1}$、固定填充位 $k$ 和输入位宽 $M$ 来表示。", "solution": "根据给定的二补码定义，对于任意 $X$ 位字 $W=(w_{X-1},\\dots,w_{0})$，\n$$\nV(W)=-w_{X-1}2^{X-1}+\\sum_{i=0}^{X-2}w_{i}2^{i}.\n$$\n对于 $M$ 位输入 $A=(a_{M-1},\\dots,a_{0})$，\n$$\nV_{A}=-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}.\n$$\n对于 $N$ 位输出 $B=(b_{N-1},\\dots,b_{0})$，其中当 $0\\leq i\\leq M-1$ 时 $b_{i}=a_{i}$，当 $M\\leq i\\leq N-1$ 时 $b_{i}=k$，\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\sum_{i=M}^{N-2}2^{i}.\n$$\n使用等比数列求和公式 $\\sum_{i=p}^{q}2^{i}=2^{q+1}-2^p$，我们得到 $\\sum_{i=M}^{N-2}2^{i}=2^{N-1}-2^{M}$。\n因此\n$$\nV_{B}=-k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\left(2^{N-1}-2^{M}\\right)\n= -k\\,2^{N-1}+\\sum_{i=0}^{M-1}a_{i}2^{i}+k\\,2^{N-1}-k\\,2^{M}.\n$$\n项 $\\pm k\\,2^{N-1}$相互抵消，得到\n$$\nV_{B}=\\sum_{i=0}^{M-1}a_{i}2^{i}-k\\,2^{M}.\n$$\n因此，误差为\n$$\n\\Delta V=V_{B}-V_{A}=\\left(\\sum_{i=0}^{M-1}a_{i}2^{i}\\right)-k\\,2^{M}-\\left(-a_{M-1}2^{M-1}+\\sum_{i=0}^{M-2}a_{i}2^{i}\\right).\n$$\n简化求和项，\n$$\n\\Delta V=\\left(\\sum_{i=0}^{M-2}a_{i}2^{i}+a_{M-1}2^{M-1}\\right)-k\\,2^{M}+a_{M-1}2^{M-1}-\\sum_{i=0}^{M-2}a_{i}2^{i}\n=2\\,a_{M-1}2^{M-1}-k\\,2^{M}.\n$$\n于是，\n$$\n\\Delta V=a_{M-1}2^{M}-k\\,2^{M} = 2^{M}(a_{M-1}-k).\n$$\n此表达式仅取决于 $a_{M-1}$、$k$ 和 $M$，并且与 $N$ 无关。", "answer": "$$\\boxed{2^{M}(a_{M-1}-k)}$$", "id": "1960202"}, {"introduction": "从理论走向实践，一个关键环节是设计能够验证功能正确性的硬件。在处理器和接口设计中，确保数据在不同位宽的模块间正确传递至关重要。本练习让你扮演一名硬件设计工程师，任务是设计一个验证模块的布尔逻辑([@problem_id:1960208])。该模块需要判断一个32位的数是否为一个12位数正确符号扩展的结果，这个练习将理论定义转化为实际的逻辑门级实现，是连接概念与工程应用的桥梁。", "problem": "在一个现代计算系统中，一个32位的中央处理器（CPU）需要与一个以12位格式提供数据的旧式外围设备接口。CPU和外设都使用二进制补码表示有符号整数。一个接口协处理器负责从外设读取12位值，并将其加载到32位的CPU寄存器中。这个过程需要符号扩展。\n\n设来自外设的12位值为$A$，其比特位表示为$a_{11}a_{10}...a_0$，其中$a_{11}$是符号位。$A$的值由公式 $-a_{11} \\cdot 2^{11} + \\sum_{i=0}^{10} a_i \\cdot 2^i$ 给出。\n\n设CPU寄存器中的32位值为$B$，其比特位表示为$b_{31}b_{30}...b_0$，其中$b_{31}$是符号位。\n\n将12位数$A$正确地符号扩展为32位数$B$需要满足两个条件：\n1. $B$的低12位必须与$A$的位相等。\n2. $B$的高20位（从第12位到第31位）必须全部与$A$的符号位$a_{11}$相等。\n\n你的任务是设计一个硬件验证模块。该模块接收所有44个比特（$A$的12个比特和$B$的32个比特）作为输入，并产生一个单一的输出信号$V$。如果$B$是$A$的正确符号扩展，则信号$V$必须为逻辑'1'，否则为'0'。\n\n推导输出信号$V$的简化布尔表达式。该表达式应以单个比特$a_i$和$b_j$的形式表示。对于逻辑等价（XNOR），你可以使用双条件符号$\\Leftrightarrow$。对于合取（AND），你可以使用符号$\\land$或乘积表示法。", "solution": "我们要验证一个32位值$B$是否为一个12位二进制补码值$A$的正确符号扩展。根据符号扩展的定义：\n1. 低12位必须被直接复制：对于所有$i \\in \\{0,1,\\dots,11\\}$，我们需要$b_{i} = a_{i}$。\n2. 所有高20位必须复制符号位$a_{11}$：对于所有$j \\in \\{12,13,\\dots,31\\}$，我们需要$b_{j} = a_{11}$。\n\n在硬件中检查精确的比特相等性，一个自然的原语是逻辑等价（XNOR），写作双条件。对于任意一对比特$x,y \\in \\{0,1\\}$，“$x$等于$y$”的条件可以通过$x \\Leftrightarrow y$来捕捉，这在逻辑上等价于$(x \\land y) \\lor (\\lnot x \\land \\lnot y)$。\n\n因此，验证信号$V$必须是所有要求的逐比特相等性的合取：\n- 对于低12位：$\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)$。\n- 对于高20位：$\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)$。\n\n将这两个独立的条件用合取连接起来，得到最终的布尔表达式：\n$$\nV = \\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right).\n$$\n这个表达式已经根据允许的原语进行了简化，并直接反映了正确符号扩展所需的条件。", "answer": "$$\\boxed{\\left(\\prod_{i=0}^{11} \\left(b_{i} \\Leftrightarrow a_{i}\\right)\\right) \\land \\left(\\prod_{j=12}^{31} \\left(b_{j} \\Leftrightarrow a_{11}\\right)\\right)}$$", "id": "1960208"}]}