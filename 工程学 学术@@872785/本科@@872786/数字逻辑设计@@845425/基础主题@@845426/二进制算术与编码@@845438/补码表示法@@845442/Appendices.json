{"hands_on_practices": [{"introduction": "补码表示法的核心优势在于它统一了加法和减法运算，使得计算机处理器可以使用相同的电路来处理这两种操作。这个练习将带你实践如何将正负十进制数转换为二进制补码形式，并执行二进制加法 [@problem_id:1973785]。这是理解算术逻辑单元（ALU）工作原理的一项基本技能。", "problem": "一个用于专门的低温系统的微控制器使用6位架构来处理传感器数据。它使用二进制补码表示法来表示围绕一个稳定设定点的温度波动的有符号整数值。该系统初始状态下，记录的温度波动为十进制值$+12$。在一次实验过程中，施加了一个冷却脉冲，系统将其记录为同单位下$-25$的变化量。微控制器通过将初始值与记录的变化量相加来计算新的温度波动值。\n\n表示存储在微控制器寄存器中的新温度波动的最终6位二进制值是什么？\n\nA. `110011`\nB. `001101`\nC. `110010`\nD. `011011`\nE. `100111`", "solution": "一个6位二进制补码系统可以表示从$-2^{5}$到$2^{5}-1$范围内的整数，即从$-32$到$31$。初始值为$+12$，变化量为$-25$。更新后的值通过加法计算：\n$$12+(-25)=-13.$$\n由于$-13$在可表示的范围内，我们将$-13$转换为6位二进制补码。首先，使用6位二进制表示$13$。因为$13=8+4+1$，其二进制形式为\n$$13 \\rightarrow 001101.$$\n为了得到$-13$的二进制补码，先将所有位取反，然后加$1$：\n$$\\text{invert}(001101)=110010,$$\n$$110010+1=110011.$$\n我们可以通过计算二进制补码的加权和来验证该值：对于$110011$，其值为\n$$-2^{5}+2^{4}+2^{1}+2^{0}=-32+16+2+1=-13,$$\n这与计算结果相符。因此，最终的6位寄存器值为$110011$，对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1973785"}, {"introduction": "数字系统在有限的资源下运行，其中最典型的限制就是寄存器的固定位宽。这个练习将探讨当算术运算的结果超出了可表示范围时会发生什么——这种现象被称为“溢出” [@problem_id:1973830]。通过在一个小型的4位系统中进行计算，你将看到溢出所带来的令人意外且违反直觉的后果。", "problem": "一位计算机工程专业的学生正在设计一个带有最小算术逻辑单元 (MALU) 的简单自定义处理器。这个 MALU 被设计用于操作固定大小的寄存器。MALU 中的每个寄存器都是 4 位宽，并且所有有符号整数都使用补码表示法进行存储。\n\n该学生希望通过执行运算 $A + B$ 来测试加法器电路，其中操作数 A 的十进制值为 5，操作数 B 的十进制值也为 5。加法以二进制形式执行，其 4 位结果被存储在目标寄存器中。由于寄存器大小有限，最终存储的位模式可能不代表真实的数学和。\n\n此操作后，存储在目标寄存器中的 4 位模式所表示的十进制整数值是多少？", "solution": "一个 4 位补码寄存器可以表示范围为 $[-2^{3}, 2^{3}-1] = [-8, 7]$ 的有符号整数。一个 4 位字 $b_{3}b_{2}b_{1}b_{0}$ 的值为\n$$\nV(b_{3}b_{2}b_{1}b_{0}) = -b_{3}2^{3} + b_{2}2^{2} + b_{1}2^{1} + b_{0}2^{0}.\n$$\n十进制值 $5$ 在此范围内，其 4 位补码表示为 $0101_{2}$。使用一个 4 位加法器将 $A=B=5$ 相加，得到模 $2^{4}$ 的和：\n$$\n(5 + 5) \\bmod 2^{4} = 10 \\bmod 16 = 10,\n$$\n其 4 位二进制模式为 $1010_{2}$。将这个存储的模式解释为一个补码数，得到\n$$\nV(1010) = -1 \\cdot 2^{3} + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 0 \\cdot 2^{0} = -8 + 2 = -6.\n$$\n这反映了有符号溢出（真实的和 $10$ 超出了 $[-8, 7]$ 的范围），但目标寄存器中保存的模式是 $1010_{2}$，它所表示的十进制值为 $-6$。", "answer": "$$\\boxed{-6}$$", "id": "1973830"}, {"introduction": "这个练习将带你从硬件表示跨越到软件层面，审视一个常见的编译器优化技巧：用更快的移位和加法操作来替代乘法。你的任务是分析这种优化在何种条件下有效，又在何种条件下会因溢出而失效 [@problem_id:1973825]。这揭示了高级语言代码和底层算术约束之间至关重要的相互作用。", "problem": "考虑一个8位补码整数，记为 $x$。在此系统中，整数的范围可以从-128到127。一种常见的编译器优化方法，用于乘以一个小的常数，是使用移位和加法操作。例如，乘以3可以表示为 $3x = 2x + x$。在位运算层面，这可能被实现为计算 `(x  1) + x`。\n\n让我们在恒等式 $3x = (x \\ll 1) + x$ 下分析此优化的有效性。这里，$x$ 是一个8位补码整数变量。操作 `x  1` 表示将 $x$ 的位模式**逻辑**左移一位。`+` 操作表示标准的8位补码加法。恒等式的左侧，$3x$，表示真实的数学乘积，其结果可能超出8位可表示的范围。右侧表示由8位处理器执行的计算结果。\n\n确定在8位补码范围内，有多少个不同的整数值 $x$ 会使此恒等式不成立，即计算结果 `(x  1) + x` 不等于 $3x$ 的数学值。", "solution": "设 $x$ 是一个8位补码整数，因此 $x \\in \\{-128,-127,\\dots,127\\}$。在一个8位处理器上：\n- 逻辑左移一位，$x \\ll 1$，对应于乘以 $2$ 再模 $256$；即，\n$$\nx \\ll 1 \\equiv 2x \\pmod{256}.\n$$\n- 8位补码加法对应于模 $256$ 的加法。\n\n因此，计算出的表达式满足\n$$\n(x \\ll 1) + x \\equiv (2x) + x \\equiv 3x \\pmod{256}.\n$$\n将8位结果解释为有符号整数，意味着它等于 $\\{-128,\\dots,127\\}$ 中与 $3x \\pmod{256}$ 同余的唯一整数。因此，当且仅当 $3x$ 本身位于可表示范围 $[-128,127]$ 内时，计算结果才等于真实的数学值 $3x$。因此，该恒等式仅对满足以下条件的 $x$ 成立\n$$\n-128 \\leq 3x \\leq 127.\n$$\n两边同除以 $3$（因为 $30$，不等式方向不变）得到\n$$\n-\\frac{128}{3} \\leq x \\leq \\frac{127}{3}.\n$$\n由于 $x$ 为整数，这等价于\n$$\nx \\in \\left[\\left\\lceil -\\frac{128}{3} \\right\\rceil,\\ \\left\\lfloor \\frac{127}{3} \\right\\rfloor\\right] = [-42,\\,42].\n$$\n这样的 $x$ 的数量为\n$$\n42 - (-42) + 1 = 85.\n$$\n因为总共有 $256$ 个8位补码值，所以恒等式不成立的 $x$ 的数量为\n$$\n256 - 85 = 171.\n$$", "answer": "$$\\boxed{171}$$", "id": "1973825"}]}