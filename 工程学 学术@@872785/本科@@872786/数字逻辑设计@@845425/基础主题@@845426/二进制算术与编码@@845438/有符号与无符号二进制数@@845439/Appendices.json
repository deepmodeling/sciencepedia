{"hands_on_practices": [{"introduction": "掌握数字逻辑始于理解计算机如何处理负数。第一个练习将提供补码表示法的基础实践，要求你将有符号二进制数转换为其等效的十进制数并执行一次基本的加法运算。这是任何数字系统设计师都需掌握的核心技能。[@problem_id:1960895]", "problem": "在一个为物理实验定制设计的微控制器中，数据值使用6位寄存器进行处理。该系统中的有符号整数使用二进制补码表示法进行编码。\n\n两个寄存器 `R1` 和 `R2` 分别存储二进制值 `011011` 和 `101010`。算术逻辑单元 (ALU) 被指令计算存储在这两个寄存器中的有符号整数之和。\n\n计算 `R1 + R2` 运算的结果。请将您的最终答案表示为单个有符号十进制整数。", "solution": "在一个6位二进制补码系统中，可表示的范围是从 $-2^{5}$ 到 $2^{5}-1$，即 $[-32, 31]$。对于一个6位字 $b_{5}b_{4}b_{3}b_{2}b_{1}b_{0}$，如果 $b_{5}=0$，其值是通常的无符号和；如果 $b_{5}=1$，其值为负，等于其二进制补码绝对值的负数。\n\n寄存器 $R1$ 的值为 $011011_{2}$，其最高有效位为 $0$，因此它是一个非负数，其值通过按权相加计算得出：\n$$\n\\operatorname{val}(R1)=0\\cdot 2^{5}+1\\cdot 2^{4}+1\\cdot 2^{3}+0\\cdot 2^{2}+1\\cdot 2^{1}+1\\cdot 2^{0}=16+8+2+1=27.\n$$\n\n寄存器 $R2$ 的值为 $101010_{2}$，其最高有效位为 $1$，因此它是一个负数。其二进制补码绝对值通过按位取反再加 $1$ 得到：\n$$\n101010_{2}\\ \\xrightarrow{\\text{invert}}\\ 010101_{2}\\ \\xrightarrow{+1}\\ 010110_{2}.\n$$\n因此其绝对值为\n$$\n|R2|=0\\cdot 2^{5}+1\\cdot 2^{4}+0\\cdot 2^{3}+1\\cdot 2^{2}+1\\cdot 2^{1}+0\\cdot 2^{0}=16+4+2=22,\n$$\n所以\n$$\n\\operatorname{val}(R2)=-22.\n$$\n\nALU 计算这两个有符号整数的和：\n$$\n\\operatorname{val}(R1)+\\operatorname{val}(R2)=27+(-22)=5.\n$$\n由于 $5\\in[-32,31]$，没有发生溢出，结果为有符号十进制整数 $5$。", "answer": "$$\\boxed{5}$$", "id": "1960895"}, {"introduction": "数字处理器在固定位数下运行，这限制了它们可以表示的数值范围。本练习将探讨算术溢出这一关键概念，即计算结果超出了这些限制。你将执行一次加法，不仅要确定结果，还要判断是否发生了有符号溢出，从而突显处理器标记此类错误的必要性。[@problem_id:1960891]", "problem": "一个为嵌入式系统定制设计的8位微处理器使用2的补码格式表示有符号整数。该处理器内部的算术逻辑单元 (ALU) 负责将来自不同系统状态寄存器的两个值相加。这两个值以十六进制数 `B4` 和 `9A` 的形式给出。您的任务是像ALU一样执行此加法运算。加法运算后，这个8位二进制结果将用于两个独立的目的：作为无符号整数用于校验和计算，以及用于有符号运算的溢出检查。\n\n确定：\n1. 将8位和解释为*无符号*整数时的值，以十进制表示。\n2. 一个二进制位，指示*有符号*加法的算术溢出标志的状态（如果发生溢出则为1，否则为0）。\n\n按指定顺序，以数对的形式提供这两个值。", "solution": "我们将ALU的运算建模为模 $2^{8}$ 的8位加法。设给定的两个8位操作数为十六进制数 B4 和 9A。为便于计算，将它们转换为十进制：\n$$\n\\text{B4}_{16} = 11 \\cdot 16 + 4 = 180, \\quad \\text{9A}_{16} = 9 \\cdot 16 + 10 = 154.\n$$\n在无限整数范围内的算术和为\n$$\n180 + 154 = 334.\n$$\n由于ALU是8位的，存储的结果是和对 $2^{8}$ 取模：\n$$\ns \\equiv 334 \\pmod{2^{8}} \\quad \\Rightarrow \\quad s = 334 - 256 = 78.\n$$\n等效地，在十六进制中，$\\text{B4} + \\text{9A} = \\text{14E}$，8位结果是低位字节 $\\text{4E}$，其十进制值为 $4 \\cdot 16 + 14 = 78$。因此，当解释为无符号8位整数时，和为 $78$。\n\n对于2的补码中的有符号溢出标志，当且仅当两个加数符号相同而结果符号相反时，才会发生溢出。在8位2的补码中，符号位是最高有效位。它们的二进制形式是\n$$\n\\text{B4}_{16} = 10110100_{2}, \\quad \\text{9A}_{16} = 10011010_{2}, \\quad \\text{result} = 01001110_{2}.\n$$\n两个输入的符号位都是 $1$（它们是负数），而8位结果的符号位是 $0$（它看起来是非负数）。因此，发生了溢出，溢出标志为 $1$。这与将输入解释为有符号值 $-76$ 和 $-102$ 的情况相符，它们的真实和是 $-178$，超出了8位2的补码可表示的范围 $[-128, 127]$。\n\n所要求的数对是无符号8位和的十进制值以及溢出标志位，按此顺序排列。", "answer": "$$\\boxed{\\begin{pmatrix}78  1\\end{pmatrix}}$$", "id": "1960891"}, {"introduction": "在处理器算术中，两个重要的状态标志是最高有效位的进位输出（$C_{out}$）和溢出标志（$V$），二者经常被混淆。本练习旨在通过寻找一个产生进位输出但未发生算术溢出的具体案例，来挑战你区分它们的能力。这将巩固你对它们在评估加法结果时各自独特作用的理解。[@problem_id:1960941]", "problem": "在数字系统中，有符号整数通常使用二进制补码格式表示。考虑一个对这类数字执行算术运算的8位处理器。一个8位二进制补码数的有效范围是从-128到+127。当两个数相加时，通常会考虑两个重要的标志位：来自最高有效位（MSB）的进位输出标志（$C_{out}$），以及溢出标志（$V$），后者指示结果是否因超出可表示范围而导致算术错误。\n\n给定四对8位二进制补码数。您的任务是找出哪一对数相加后，会产生来自最高有效位（MSB）的进位输出（$C_{out} = 1$），但**不会**导致算术溢出（$V = 0$）。\n\n以下哪一对8位二进制补码数满足这些标准？\n\nA. `11111111` 和 `11111110`\n\nB. `10011100` 和 `10011100`\n\nC. `01100100` 和 `01100100`\n\nD. `00010100` 和 `00011110`", "solution": "题目要求我们找出一对8位二进制补码数，它们相加后会从最高有效位（MSB）产生一个进位输出，但不会引起算术溢出。\n\n首先，我们来确定8位二进制补码算术的规则。\n可表示的数字范围是 $[-2^{8-1}, 2^{8-1}-1]$，即 $[-128, 127]$。\n如果一个数的最高有效位（第7位）是1，则该数为负数；如果最高有效位是0，则为正数或零。\n\n算术溢出在以下两种情况下发生：\n1.  两个正数之和得到一个负数结果（和的MSB为1）。\n2.  两个负数之和得到一个正数结果（和的MSB为0）。\n一个正数和一个负数相加永远不会导致溢出。\n\n进位输出（$C_{out}$）是在最高有效位（第7位）位置的加法所产生的进位。\n\n一种常见的检测溢出的方法是比较进入最高有效位的进位（$C_{in,7}$）和从最高有效位产生的进位输出（$C_{out}$）。当且仅当 $C_{in,7} \\neq C_{out}$ 时，发生溢出。题目要求没有溢出，这意味着我们在寻找一个 $C_{in,7} = C_{out}$ 的情况。由于题目还要求 $C_{out}=1$，我们特别要寻找一个 $C_{in,7}=1$ 且 $C_{out}=1$ 的情况。\n\n我们来分析每个选项。\n\n**A. `11111111` 和 `11111110`**\n- **十进制值：**\n  - `11111111` 是 -1 的二进制补码表示。\n  - `11111110` 是 -2 的二进制补码表示。\n- **期望和：** $(-1) + (-2) = -3$。该值在 [-128, 127] 的范围内，因此不应发生溢出。\n- **二进制加法：**\n  ```\n     11111111   (carries)\n     11111111   (-1)\n   + 11111110   (-2)\n   -----------\n   1 11111101\n  ```\n- **分析：**\n  - 8位结果是 `11111101`，这是-3的二进制补码。结果在算术上是正确的，因此**没有溢出**。\n  - 从最高有效位位置产生了一个为1的进位。因此，**$C_{out} = 1$**。\n- 这对数满足两个条件：$C_{out} = 1$ 且没有溢出。\n\n**B. `10011100` 和 `10011100`**\n- **十进制值：**\n  - `10011100` 是 `01100100` (100) 的二进制补码。所以，`10011100` 代表 -100。\n- **期望和：** $(-100) + (-100) = -200$。该值超出了 [-128, 127] 的范围。必须发生溢出。\n- **二进制加法：**\n  ```\n      11  111     (carries)\n     10011100   (-100)\n   + 10011100   (-100)\n   -----------\n   1 01011000\n  ```\n- **分析：**\n  - 8位结果是 `01011000`，代表 +88。由于我们相加了两个负数却得到了一个正数结果，因此**发生了溢出**。\n  - 从最高有效位位置产生了一个为1的进位。因此，**$C_{out} = 1$**。\n- 这对数不满足“没有溢出”的条件。\n\n**C. `01100100` 和 `01100100`**\n- **十进制值：**\n  - `01100100` 代表 +100。\n- **期望和：** $100 + 100 = 200$。该值超出了 [-128, 127] 的范围。必须发生溢出。\n- **二进制加法：**\n  ```\n     1  1        (carries)\n     01100100   (+100)\n   + 01100100   (+100)\n   -----------\n   0 11001000\n  ```\n- **分析：**\n  - 8位结果是 `11001000`，代表 -56。由于我们相加了两个正数却得到了一个负数结果，因此**发生了溢出**。\n  - 从最高有效位位置没有产生进位。因此，**$C_{out} = 0$**。\n- 这对数两个条件都不满足。\n\n**D. `00010100` 和 `00011110`**\n- **十进制值：**\n  - `00010100` 代表 +20。\n  - `00011110` 代表 +30。\n- **期望和：** $20 + 30 = 50$。该值在 [-128, 127] 的范围内，因此不应发生溢出。\n- **二进制加法：**\n  ```\n       111       (carries)\n     00010100   (+20)\n   + 00011110   (+30)\n   -----------\n   0 00110010\n  ```\n- **分析：**\n  - 8位结果是 `00110010`，代表 +50。结果在算术上是正确的，因此**没有溢出**。\n  - 从最高有效位位置没有产生进位。因此，**$C_{out} = 0$**。\n- 这对数不满足“$C_{out}=1$”的条件。\n\n**结论：**\n只有选项A中的 `11111111` 和 `11111110` 这对数，其相加结果会从最高有效位产生1的进位输出，同时得到正确的和（没有溢出）。", "answer": "$$\\boxed{A}$$", "id": "1960941"}]}