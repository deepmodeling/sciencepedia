{"hands_on_practices": [{"introduction": "在硬件描述语言 (HDL) 中，正确区分逻辑运算符和按位运算符至关重要，因为它们会产生根本不同的硬件电路。逻辑与 (``) 将其操作数视为单一的布尔值（真或假），而按位与 (``) 则对操作数的每一位独立进行并行运算。这个练习 [@problem_id:1943465] 将通过一个具体的例子来巩固这一区别，要求你找到一个场景，使得这两种运算符的输出结果截然不同。", "problem": "在像Verilog这样的硬件描述语言（HDL）的数字逻辑设计中，区分逻辑运算符和按位运算符至关重要，因为即使它们由相似的符号表示，也可能产生截然不同的结果。考虑两个4位寄存器 `A` 和 `B`。您的任务是分析Verilog的逻辑与（``）和按位与（``）运算符的行为。\n\n确定下列哪一项对寄存器 `A` 和 `B` 的赋值同时满足以下两个条件：\n1. 表达式 `(A  B)` 的求值结果为单比特值 `1'b1`。\n2. 表达式 `(A  B)` 的求值结果为4比特值 `4'b0000`。\n\nA. `A = 4'b1010`, `B = 4'b0101`\nB. `A = 4'b1100`, `B = 4'b1010`\nC. `A = 4'b1111`, `B = 4'b0000`\nD. `A = 4'b0110`, `B = 4'b0110`", "solution": "在 Verilog 中，逻辑与运算符 `` 将每个操作数视为单个布尔值：当且仅当 `A` 和 `B` 都不为零时（即 $A \\neq 4'b0000$ 且 $B \\neq 4'b0000$），`(A  B)` 的结果为 `1'b1`。按位与运算符 `` 生成一个向量，其中每一位是相应位的与运算结果：当 `A` 和 `B` 在任何位上都不同时为 `1` 时，`(A  B)` 的结果为 `4'b0000`。\n\n因此，两个要求的条件是：\n1) `(A  B)` 的结果为 `1'b1` $\\iff A \\neq 4'b0000$ 且 $B \\neq 4'b0000$。\n2) `(A  B)` 的结果为 `4'b0000` $\\iff$ `A` 和 `B` 的支持集不相交（即没有一个位在两个数中都为1）。\n\n检查每个选项：\n\nA. $A = 4'b1010$, $B = 4'b0101$。\n计算按位与：\n$4'b1010 \\ \\ \\ 4'b0101 = 4'b0000$。\n所以条件2成立。此外，$A \\neq 4'b0000$ 且 $B \\neq 4'b0000$，因此 `(A  B)` 的结果为 `1'b1`。\n所以条件1成立。\n\nB. $A = 4'b1100$, $B = 4'b1010$。\n计算按位与：\n$4'b1100 \\ \\ \\ 4'b1010 = 4'b1000 \\neq 4'b0000$。\n所以条件2不成立（尽管两者都非零，所以条件1会成立）。\n\nC. $A = 4'b1111$, $B = 4'b0000$。\n这里 $B = 4'b0000$，因此 `(A  B)` 的结果为 `1'b0`。\n所以条件1不成立（尽管 `$A \\ \\ \\ B = 4'b0000$` 会满足条件2）。\n\nD. $A = 4'b0110$, $B = 4'b0110$。\n计算按位与：\n$4'b0110 \\ \\ \\ 4'b0110 = 4'b0110 \\neq 4'b0000$。\n所以条件2不成立（两者都非零，所以条件1会成立）。\n\n因此，只有选项A同时满足两个条件。", "answer": "$$\\boxed{A}$$", "id": "1943465"}, {"introduction": "掌握了基本运算符后，下一步是使用它们来构建完整的组合逻辑电路。优先级编码器是数字系统中的一个常见构件，它能从多个输入中找出优先级最高的有效信号。这个练习 [@problem_id:1943463] 旨在教会你如何使用 Verilog 中简洁而强大的嵌套条件（三元）运算符来高效地描述这种具有优先级的逻辑行为。", "problem": "在数字逻辑设计中，优先编码器是一种组合电路，它将多个二进制输入转换为数量较少的输出。其输出表示处于活动状态的最高优先级输入的二进制编码索引。\n\n考虑一个要用硬件描述语言（HDL）如 Verilog 实现的 4-2 优先编码器模块。该模块具有以下接口：\n- 一个 4 位输入向量 `d`，其中 `d[3]` 具有最高优先级，`d[0]` 具有最低优先级。\n- 一个 2 位输出向量 `y`，它应表示最高优先级有效（逻辑 '1'）输入的二进制索引。\n- 一个 1 位输出 `v`（表示“有效”），如果 `d` 中有任何输入有效，则其应为 '1'，否则为 '0'。\n\n如果没有输入有效（即 `d` 为 `4'b0000`），则 `v` 输出必须为 '0'，而 `y` 的输出值可被视为“无关项”（通常设为 '0'）。\n\n您的任务是识别出那个使用嵌套条件（三元）运算符（`? :`）的单一连续赋值语句，该语句通过为拼接向量 `{v, y}` 赋上合适的值来正确实现此 4-2 优先编码器的逻辑。\n\n以下哪个 Verilog 语句正确地建模了指定的优先编码器？\n\nA. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\nB. `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`\nC. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`\nD. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`\nE. `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`", "solution": "题目要求用户找到一个使用单一 `assign` 语句和嵌套条件运算符的 4-2 优先编码器的正确 Verilog 实现。赋值的输出是 3 位拼接向量 `{v, y}`。\n\n首先，我们根据问题描述建立优先编码器的真值表。输入为 `d[3:0]`，输出为 `v` 和 `y[1:0]`。优先级为 `d[3]  d[2]  d[1]  d[0]`。我们还确定了拼接向量 `{v, y}` 所需的 3 位值。真值表中的 'x' 代表“无关”条件。\n\n| `d[3]` | `d[2]` | `d[1]` | `d[0]` |  `v`  | `y[1:0]` | `{v, y}` (3位值) |\n|:------:|:------:|:------:|:------:|:-----:|:--------:|:----------------------:|\n|   1    |   x    |   x    |   x    |   1   |  `2'b11` |        `3'b111`        |\n|   0    |   1    |   x    |   x    |   1   |  `2'b10` |        `3'b110`        |\n|   0    |   0    |   1    |   x    |   1   |  `2'b01` |        `3'b101`        |\n|   0    |   0    |   0    |   1    |   1   |  `2'b00` |        `3'b100`        |\n|   0    |   0    |   0    |   0    |   0   |  `2'b00` |        `3'b000`        |\n*（注意：在没有输入有效的情况下，`y` 是一个无关项，通常设置为 `2'b00`）*\n\nVerilog 中的嵌套条件（三元）运算符 `condition ? value_if_true : value_if_false` 创建了一个等效于 `if-else if-else` 链的优先级结构。该语句将按条件出现的顺序进行检查。\n\n让我们根据真值表和优先级规则构建正确的语句：\n\n1.  **检查最高优先级的输入 `d[3]`：** 如果 `d[3]` 为 '1'，输出 `{v, y}` 必须是 `3'b111`。\n    语句以 `d[3] ? 3'b111 : ...` 开始。\n\n2.  **检查次高优先级的输入 `d[2]`：** 如果 `d[3]` 为 '0'，我们检查 `d[2]`。如果 `d[2]` 为 '1'，输出 `{v, y}` 必须是 `3'b110`。\n    这就形成了第一个嵌套：`d[3] ? 3'b111 : (d[2] ? 3'b110 : ...)`\n\n3.  **检查 `d[1]`：** 如果 `d[3]` 和 `d[2]` 都为 '0'，我们检查 `d[1]`。如果 `d[1]` 为 '1'，输出 `{v, y}` 必须是 `3'b101`。\n    嵌套继续：`... : (d[2] ? 3'b110 : (d[1] ? 3'b101 : ...))`\n\n4.  **检查最低优先级的输入 `d[0]`：** 如果 `d[3]`、`d[2]` 和 `d[1]` 都为 '0'，我们检查 `d[0]`。如果 `d[0]` 为 '1'，输出 `{v, y}` 必须是 `3'b100`。\n    嵌套变为：`... : (d[1] ? 3'b101 : (d[0] ? 3'b100 : ...))`\n\n5.  **默认情况：** 如果所有输入都为 '0'，则所有条件都不满足。这是最后的 `else` 情况。输出 `{v, y}` 必须是 `3'b000`。\n    完整的语句是：`assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`\n\n现在，我们来评估给出的选项：\n\n*   **A: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b000;`**\n    该语句与我们推导出的逻辑完全匹配。它正确地实现了从 `d[3]` 到 `d[0]` 的优先级，并为每种情况（包括默认情况）生成了正确的 `{v, y}` 值。这是正确答案。\n\n*   **B: `assign {v, y} = d[0] ? 3'b100 : d[1] ? 3'b101 : d[2] ? 3'b110 : d[3] ? 3'b111 : 3'b000;`**\n    该语句颠倒了优先级顺序，首先检查 `d[0]`。它实现了一个 `d[0]` 具有最高优先级的优先编码器，这与问题规范相矛盾。\n\n*   **C: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b110 : d[0] ? 3'b100 : 3'b000;`**\n    该语句在 `d[1]` 情况的输出中有错误。当 `d[1]` 有效（且 `d[3]`、`d[2]` 无效）时，它输出 `3'b110`，这对应于 `{v=1, y=2'b10}`。正确的输出应该是 `{v=1, y=2'b01}` 或 `3'b101`。\n\n*   **D: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b110 : d[1] ? 3'b101 : d[0] ? 3'b100 : 3'b100;`**\n    该语句在最后的 `else`（默认）情况下有错误。如果没有输入有效（`d == 4'b0000`），它将 `3'b100` 赋给 `{v, y}`。这意味着 `v` 变为 '1'，这是不正确的，因为当没有输入有效时，有效位应为 '0'。\n\n*   **E: `assign {v, y} = d[3] ? 3'b111 : d[2] ? 3'b101 : d[1] ? 3'b011 : d[0] ? 3'b001 : 3'b000;`**\n    该语句似乎是为赋值给 `{y, v}` 而不是 `{v, y}` 构建的。我们来分析 `d[2]` 的情况：`{v, y}` 的正确输出是 `3'b110`。该语句提供了 `3'b101`，这意味着 `v=1, y=2'b01`。这对应于索引 1，而不是 2。然而，如果目标是 `{y, v}`，其值将是 `{2'b10, 1'b1}`，即 `3'b101`。此选项表明对问题中指定的拼接顺序存在误解。\n\n因此，选项 A 是唯一一个正确建模了指定的 4-2 优先编码器逻辑的选项。", "answer": "$$\\boxed{A}$$", "id": "1943463"}, {"introduction": "随着设计复杂度的增加，模块化和代码复用成为关键的设计原则。将特定的逻辑功能封装在可重用的函数中，可以使设计更加清晰、易于调试和扩展。本练习 [@problem_id:1943464] 的任务是创建一个用于计算奇偶校验位的可综合函数，这是数据通信中一种基础的错误检测机制，从而帮助你实践结构化的 HDL 设计方法。", "problem": "您的任务是使用硬件描述语言（HDL）为一个简单通信协议的组件建模。该组件名为 `DataPacketProcessor`，它接收一个 16 位的数据字，并准备一个 17 位的输出数据包。输出数据包由原始的 16 位数据字和一个计算出的单位比特组成。\n\n`DataPacketProcessor` 模块有一个名为 `data_in` 的 16 位输入端口和一个名为 `packet_out` 的 17 位输出端口。`packet_out` 的 16 个最高有效位（即 `packet_out[16:1]`）必须是输入 `data_in` 的直接副本。最低有效位 `packet_out[0]` 是一个由 `data_in` 的内容决定的计算值。如果 `data_in` 中设置为 `1` 的比特总数为奇数，则 `packet_out[0]` 的值必须为 `1`；如果为偶数，则为 `0`。在此设计中，用于计算该比特的逻辑必须封装在一个可重用的、纯组合逻辑的例程中，该例程接收一个输入向量并返回一个单位比特值。\n\n假设模块的输入为 `data_in = 16'hA5C3`，请确定最终 17 位输出 `packet_out` 的十进制表示。", "solution": "所需的计算比特是 16 个输入比特的奇校验函数，可以定义为一个纯组合逻辑的异或归约（reduction XOR）操作。设输入比特为 $b_{15},\\dots,b_{0}$，并令\n$$\np=\\bigoplus_{i=0}^{15} b_{i}=\\left(\\sum_{i=0}^{15} b_{i}\\right)\\bmod 2.\n$$\n给定 $\\,\\text{data\\_in}=16'\\text{hA5C3}\\,$，其二进制形式为 $(1010\\,0101\\,1100\\,0011)_{2}$。按半字节（nibble）计算 1 的数量可得\n$$\nN_{1}=(1010)\\to 2,\\quad(0101)\\to 2,\\quad(1100)\\to 2,\\quad(0011)\\to 2,\n$$\n所以 $N_{1}=2+2+2+2=8$，为偶数，因此\n$$\np=8\\bmod 2=0.\n$$\n设 $V$ 为 $\\text{data\\_in}$ 的整数值。从十六进制转换为十进制，\n$$\nV=10\\cdot 16^{3}+5\\cdot 16^{2}+12\\cdot 16^{1}+3=10\\cdot 4096+5\\cdot 256+12\\cdot 16+3=40960+1280+192+3=42435.\n$$\n根据比特映射要求，$\\text{packet\\_out}[16:1]$ 复制输入，且 $\\text{packet\\_out}[0]=p$，所以 17 位输出的整数值为\n$$\nP=2V+p=2\\cdot 42435+0=84870.\n$$\n因此，最终 $17$ 位输出的十进制表示为 $84870$。", "answer": "$$\\boxed{84870}$$", "id": "1943464"}]}