{"hands_on_practices": [{"introduction": "VHDL允许通过不同的建模风格来描述硬件行为。其中最直接的是数据流建模，它通过描述数据如何在信号之间流动来定义逻辑。本练习将侧重于将一个布尔表达式直接转换为VHDL并行信号赋值语句，这是在数据流架构中实现组合逻辑的基础技能。[@problem_id:1976420]", "problem": "在使用诸如VHSIC HDL (VHDL)之类的硬件描述语言（HDL）进行数字系统设计时，数据流建模用于描述数据如何在系统中流动。这通常通过在架构体中使用并发信号赋值来实现。\n\n考虑一个简单的监控系统，它有三个单位比特输入 `A`、`B` 和 `C`，以及一个单位比特输出 `Z`。所有信号都是标准类型 `STD_LOGIC`。该系统的行为由以下规则定义：如果控制输入 `C` 被置位（变为 '1'），或者传感器输入 `A` 和 `B` 不会同时被置位，则输出 `Z` 被置位。\n\n以下哪条单一的VHDL并发信号赋值语句正确地实现了输出 `Z` 的这个逻辑？\n\nA. `Z = (A nand B) or C;`\nB. `Z = not (A and B or C);`\nC. `Z = not A and not B or C;`\nD. `Z = (A or B) and C;`\nE. `Z = (A and B)' or C;`", "solution": "题目描述的逻辑是“如果控制输入 `C` 被置位（为'1'），或者传感器输入 `A` 和 `B` 不会同时被置位，则输出 `Z` 被置位”。这可以被翻译成布尔表达式：\n$$Z = C \\lor \\lnot(A \\land B)$$\n根据布尔代数，$\\lnot(A \\land B)$ 等价于 $A \\ \\text{NAND} \\ B$。因此，表达式变为：\n$$Z = C \\lor (A \\ \\text{NAND} \\ B)$$\n在 VHDL 中，并发信号赋值语句使用 ` = ` 运算符。因此，实现这一逻辑的正确 VHDL 代码是 `Z = (A nand B) or C;`。\n\n现在评估各个选项：\n*   **选项 A**: `Z = (A nand B) or C;` 这完全符合我们推导出的逻辑和正确的 VHDL 语法。\n*   **选项 B**: `Z = not (A and B or C);` 对应于 $Z = \\lnot((A \\land B) \\lor C)$，根据德摩根定律，这等于 $\\lnot(A \\land B) \\land \\lnot C$，逻辑不正确。\n*   **选项 C**: `Z = not A and not B or C;` 根据 VHDL 运算符优先级，这等于 $((\\lnot A) \\land (\\lnot B)) \\lor C$，即 $\\lnot(A \\lor B) \\lor C$，逻辑不正确。\n*   **选项 D**: `Z = (A or B) and C;` 对应于 $Z = (A \\lor B) \\land C$，逻辑不正确。\n*   **选项 E**: `Z = (A and B)' or C;` 在 VHDL 中是无效语法。撇号 (`'`) 用于表示信号属性，而不是 `not` 运算符。\n\n因此，只有选项 A 是正确的。", "answer": "$$\\boxed{A}$$", "id": "1976420"}, {"introduction": "现实世界中的数字电路很少能用单个逻辑方程简单描述。为了管理复杂性，设计者会将逻辑分解为更小的、相互连接的部分。在VHDL中，内部信号扮演着这些连接的角色，如同架构内部的导线，将不同的逻辑阶段连接起来。本练习要求你构建一个两位比较器，并特别要求使用一个内部信号来计算中间结果，从而展示如何创建结构更清晰、可读性更强的硬件描述。[@problem_id:1976435]", "problem": "在超高速集成电路硬件描述语言 (VHDL) 中，数字系统通过 `ENTITY` 和 `ARCHITECTURE` 进行描述。`ENTITY` 定义了 I/O 端口，而 `ARCHITECTURE` 描述了内部行为。\n\n考虑一个 2 位数字比较器的设计。该比较器接收两个 2 位输入 `A` 和 `B`，并产生一个单比特输出 `A_gt_B`。如果 `A` 的无符号整数值严格大于 `B`，则 `A_gt_B` 为 '1'，否则为 '0'。输入 `A` 和 `B` 的类型为 `STD_LOGIC_VECTOR(1 DOWNTO 0)`，其中索引 1 代表最高有效位 (MSB)。\n\n该比较器的 `ENTITY` 定义如下：\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\n\nENTITY comparator_2bit IS\n    PORT (\n        A      : IN  STD_LOGIC_VECTOR(1 DOWNTO 0);\n        B      : IN  STD_LOGIC_VECTOR(1 DOWNTO 0);\n        A_gt_B : OUT STD_LOGIC\n    );\nEND ENTITY comparator_2bit;\n```\n\n你的任务是为此实体编写一个名为 `Behavioral` 的数据流 `ARCHITECTURE`。该实现必须遵循一个特定的结构要求：必须使用一个名为 `intermediate_check` 的 `STD_LOGIC` 类型的内部信号。此信号必须实现检查 `A` 的 MSB 是否为 1 且 `B` 的 MSB 是否为 0 的逻辑。最终输出 `A_gt_B` 必须使用此 `intermediate_check` 信号以及处理最低有效位的逻辑来计算。\n\n根据这些规范，以下哪个 VHDL 代码块正确地实现了 `Behavioral` 架构？\n\nA.\n```vhdl\nARCHITECTURE Behavioral OF comparator_2bit IS\n    SIGNAL intermediate_check : STD_LOGIC;\nBEGIN\n    intermediate_check = A(1) AND (NOT B(1));\n    A_gt_B = intermediate_check OR ((A(1) XNOR B(1)) AND (A(0) AND (NOT B(0))));\nEND ARCHITECTURE Behavioral;\n```\n\nB.\n```vhdl\nARCHITECTURE Behavioral OF comparator_2bit IS\n    SIGNAL intermediate_check : STD_LOGIC;\nBEGIN\n    intermediate_check = A(1) AND (NOT B(1));\n    A_gt_B = intermediate_check AND ((A(1) XNOR B(1)) AND (A(0) AND (NOT B(0))));\nEND ARCHITECTURE Behavioral;\n```\n\nC.\n```vhdl\nARCHITECTURE Behavioral OF comparator_2bit IS\nBEGIN\n    SIGNAL intermediate_check : STD_LOGIC;\n    intermediate_check = A(1) AND (NOT B(1));\n    A_gt_B = intermediate_check OR ((A(1) XNOR B(1)) AND (A(0) AND (NOT B(0))));\nEND ARCHITECTURE Behavioral;\n```\n\nD.\n```vhdl\nARCHITECTURE Behavioral OF comparator_2bit IS\n    SIGNAL intermediate_check : STD_LOGIC;\nBEGIN\n    intermediate_check = A(1) AND (NOT B(1));\n    A_gt_B = (A(1) AND (NOT B(1))) OR ((A(1) XNOR B(1)) AND (A(0) AND (NOT B(0))));\nEND ARCHITECTURE Behavioral;\n```", "solution": "设 $A$ 和 $B$ 是两个两位的无符号输入，其最高有效位分别为 $A_{1}$ 和 $B_{1}$，最低有效位分别为 $A_{0}$ 和 $B_{0}$。对于一个 2 位比较器，当且仅当满足以下任一条件时，$AB$：\n1) 仅通过比较 MSB 就能确定 $AB$，即 $A_{1}=1$ 且 $B_{1}=0$，或者\n2) MSB 相等，而通过比较 LSB 来确定 $AB$，即 $A_{1}=B_{1}$ 且 $A_{0}=1$ 且 $B_{0}=0$。\n\n使用 VHDL 中可用的操作符，其布尔形式为：\n$$\nA\\_gt\\_B = \\left(A_{1} \\cdot \\overline{B_{1}}\\right) \\;\\lor\\; \\left(\\left(A_{1} \\text{ XNOR } B_{1}\\right) \\cdot \\left(A_{0} \\cdot \\overline{B_{0}}\\right)\\right)\n$$\n定义所需的内部信号\n$$\n\\text{intermediate\\_check} = A_{1} \\cdot \\overline{B_{1}}\n$$\n然后计算输出为\n$$\nA\\_gt\\_B = \\text{intermediate\\_check} \\;\\lor\\; \\left(\\left(A_{1} \\text{ XNOR } B_{1}\\right) \\cdot \\left(A_{0} \\cdot \\overline{B_{0}}\\right)\\right)\n$$\nVHDL 架构必须在声明区域声明该信号，为其赋值以实现 MSB 的比较，并在最终的输出表达式中将其与 LSB 项一起使用。\n\n评估各个选项：\n- 选项 A 在声明区域声明了信号，赋值 $\\text{intermediate\\_check} \\leftarrow A(1) \\text{ AND } \\text{NOT } B(1)$，并将 $A\\_gt\\_B$ 计算为 $\\text{intermediate\\_check} \\text{ OR } ((A(1) \\text{ XNOR } B(1)) \\text{ AND } (A(0) \\text{ AND } \\text{NOT } B(0)))$。这与推导出的布尔表达式以及使用内部信号的结构要求相匹配。\n- 选项 B 错误地使用了 AND 而不是 OR 来组合两种情况，这无法正确实现 $AB$。\n- 选项 C 试图在架构的并发区域（BEGIN 之后）声明信号，这在 VHDL 中是非法的；信号必须在声明区域中声明。\n- 选项 D 的逻辑是正确的，但它违反了结构要求，因为在计算 $A\\_gt\\_B$ 时没有使用 $\\text{intermediate\\_check}$ 信号。\n\n因此，只有选项 A 是正确的，并且同时符合功能和结构规范。", "answer": "$$\\boxed{A}$$", "id": "1976435"}, {"introduction": "除了简单的数据流，VHDL还提供了`process`块，允许使用`if-then-else`等顺序语句来描述复杂的行为。虽然这种行为级风格功能强大，但它要求设计者深刻理解综合工具如何将代码解释为硬件。一个常见的陷阱是在描述纯组合逻辑时无意中创建了存储元件（锁存器）。本练习要求你分析一个有缺陷的优先级编码器设计，找出其失败的原因，从而教会你在`process`中编写可综合组合逻辑的关键规则，以及如何避免不期望的锁存器。[@problem_id:1976482]", "problem": "一位工程师正在使用甚高速集成电路(VHSIC)硬件描述语言(VHDL)设计一个3位优先编码器。该编码器有一个3位输入向量`R`，一个2位输出`Y`（表示最高优先级有效输入的二进制索引），一个单比特“有效”输出`V`（当至少有一个输入有效时为高电平有效），以及一个低电平有效的使能输入`EN_L`。其优先级顺序为`R(2)`具有最高优先级，`R(0)`具有最低优先级。\n\n工程师为该编码器编写了以下行为VHDL代码：\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity priority_encoder is\n    port (\n        EN_L : in  std_logic;\n        R    : in  std_logic_vector(2 downto 0);\n        Y    : out std_logic_vector(1 downto 0);\n        V    : out std_logic\n    );\nend entity priority_encoder;\n\narchitecture behavioral of priority_encoder is\nbegin\n    encoder_proc: process (R) is\n    begin\n        if EN_L = '0' then\n            if R(2) = '1' then\n                Y = \"10\";\n                V = '1';\n            elsif R(1) = '1' then\n                Y = \"01\";\n                V = '1';\n            elsif R(0) = '1' then\n                Y = \"00\";\n                V = '1';\n            end if;\n        end if;\n    end process encoder_proc;\nend architecture behavioral;\n```\n\n当这段代码被综合时，对生成的数字电路最准确的描述是什么？\n\nA. 一个纯组合逻辑的3位优先编码器，其功能如规格所述正常。\nB. 一个因赋值路径不完整而在输出`Y`和`V`上产生意外锁存器的电路。\nC. 一个包含边沿触发触发器的时序电路。\nD. 一个会因进程块中的VHDL语法错误而导致综合失败的电路。\nE. 一个纯组合逻辑电路，但完全忽略了`EN_L`输入信号。", "solution": "要确定综合后电路的性质，我们必须根据逻辑综合的规则来分析VHDL的`process`块。要使一个进程描述纯组合逻辑，必须满足两个主要条件：\n1. 进程的敏感列表必须包含进程内所有被读取的信号。\n2. 在进程中赋值的每个信号（即每个输出），在所有可能的执行路径中都必须被赋予一个确定的值。\n\n让我们根据这两个条件来分析提供的代码。\n\n首先，我们检查敏感列表。进程被定义为`process (R)`。这意味着只有当信号`R`中的某一位发生变化时，进程内的代码块才会执行。然而，在进程内部，逻辑还依赖于输入信号`EN_L`，因为它被用在`if EN_L = '0' then`条件中。由于`EN_L`在进程内部被读取但并未出现在敏感列表中，因此违反了纯组合逻辑的第一个条件。`EN_L`的变化不会触发进程重新求值，这可能导致不正确的行为。\n\n其次，我们检查输出信号`Y`和`V`的赋值路径。代码使用了嵌套的`if`语句。\n- 外部的`if`语句检查`EN_L = '0'`。没有对应的`else`子句来处理`EN_L = '1'`的情况。这意味着如果`EN_L`为`'1'`，代码没有指定`Y`和`V`应该取什么值。\n- 内部嵌套的`if-elsif-elsif`结构检查`R`的各位。没有最后的`else`子句。这意味着如果`EN_L`是`'0'`但`R`是`\"000\"`，那么`R(2)='1'`、`R(1)='1'`或`R(0)='1'`这些条件都不会满足。在这种情况下，代码同样没有指定`Y`和`V`应该取什么值。\n\n当综合工具在进程中遇到某个执行路径，其中输出信号没有被显式赋值时，它必须推断出一种方法来保持该信号的前一个状态。实现这种“保持前值”行为的数字电路元件是锁存器。因为设计者的意图很可能是创建一个组合电路，所以这些被推断出的锁存器被认为是“意外的”。\n\n因此，由于不完整的`if`语句（缺少`else`子句），综合器将为输出`Y`和`V`推断出锁存器。这违背了创建纯组合电路的目标。不完整的敏感列表也是一个重大的设计缺陷，它使问题变得更加复杂，意味着被推断出的锁存器将无法作为相对于`EN_L`的透明锁存器正常工作。\n\n现在我们来评估给出的选项：\n- A 是不正确的，因为推断出的锁存器使得电路成为时序电路（它具有存储功能），而不是纯组合电路。\n- B 是正确的。因为在进程的所有可能执行路径中，`Y`和`V`并未都被赋值，所以会在`Y`和`V`上推断出锁存器。这通常被称为“不完整的赋值路径”。\n- C 是不正确的。推断出的存储元件是电平敏感的锁存器，而不是边沿触发的触发器。触发器通常是从指定时钟边沿的VHDL结构中推断出来的，例如`if rising_edge(clk) then ...`。\n- D 是不正确的。这段代码在VHDL中语法是有效的，尽管它描述了一个具有不期望行为的电路。它能够被综合，但不会综合成预期的逻辑。\n- E 是一个不完整的描述。虽然不完整的敏感列表意味着电路不能正确响应`EN_L`的变化，但不完整的赋值路径更根本的结果是产生了存储元件（锁存器）。选项B是对综合出的硬件更精确、更准确的描述。", "answer": "$$\\boxed{B}$$", "id": "1976482"}]}