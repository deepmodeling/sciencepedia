{"hands_on_practices": [{"introduction": "寄存器传输级 (RTL) 设计的基础是精确描述寄存器如何随时间变化。本练习 [@problem_id:1957805] 聚焦于一项关键且常见的现实世界设计选择：实现异步复位。理解同步与异步控制信号之间的区别，对于创建稳健且可预测的数字系统至关重要。", "problem": "一个数字系统需要一个16位上计数器。该计数器实现为一个名为 `C` 的寄存器。该系统具有以下信号：\n\n*   `clk`：一个系统时钟输入。\n*   `reset`：一个高电平有效、异步复位输入。\n*   `en`：一个高电平有效、同步使能输入。\n\n计数器的行为定义如下：\n1.  在任何时候，如果 `reset` 信号被置位（逻辑高电平），计数器 `C` 必须立即无条件地清零。\n2.  如果 `reset` 信号未被置位，则在 `clk` 信号的每个上升沿，计数器的行为由 `en` 信号决定。\n3.  如果在时钟上升沿 `en` 被置位（逻辑高电平），计数器 `C` 加1。\n4.  如果在时钟上升沿 `en` 未被置位（逻辑低电平），计数器 `C` 保持其当前值。\n\n要求您选择能够准确模拟此行为的寄存器传输级（RTL）伪代码描述。该伪代码使用类似于Verilog硬件描述语言（HDL）的语法，其中进程由敏感列表触发，`=` 表示寄存器的非阻塞赋值。\n\n以下哪个RTL描述正确实现了指定的16位计数器？\n\nA.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```\n\nB.\n```\nalways @ (posedge clk)\nbegin\n  if (reset)\n    C = 0;\n  else if (en)\n    C = C + 1;\nend\n```\n\nC.\n```\nalways @ (posedge clk)\nbegin\n  if (en)\n    C = C + 1;\n  else if (reset)\n    C = 0;\nend\n```\n\nD.\n```\nalways @ (posedge clk or posedge reset)\nbegin\n  if (en)\n    C = C + 1;\n  else if (reset)\n    C = 0;\nend\n```", "solution": "问题要求为具有特定复位、时钟和使能信号行为的16位计数器提供正确的寄存器传输级（RTL）描述。要解决这个问题，我们必须正确解释异步和同步事件之间的区别以及标准的RTL编码实践。\n\n1.  **分析异步复位要求：** 问题指出 `reset` 是“异步的”和“高电平有效的”。\n    *   **异步：** 这意味着复位操作（将计数器 `C` 清零）必须在 `reset` 信号为高电平时发生，而与 `clk` 信号的状态无关。在像Verilog的 `always` 块这样的RTL进程中，这通过将复位信号包含在敏感列表中来建模。由于复位是高电平有效的，该块应该对复位信号的上升沿（或正电平变化）敏感。因此，敏感列表必须是 `always @ (posedge clk or posedge reset)`。\n    *   **无条件优先级：** 复位也是“无条件的”。这意味着它具有最高优先级。在 `if-else if-else` 结构中，必须首先检查最高优先级的条件。因此，`if (reset)` 检查必须出现在 `always` 块内的任何其他逻辑之前。\n\n2.  **分析同步行为：** 递增和保持操作是“同步的”。\n    *   **时钟触发：** 这些操作仅在时钟的上升沿发生。此逻辑必须以时钟事件为条件。`always @ (posedge clk ...)` 敏感列表处理了这一点。\n    *   **以复位为条件：** 同步逻辑只应在系统*不*处于复位状态时执行。这意味着所有同步逻辑都必须放在主 `if (reset)` 语句的 `else` 部分。\n    *   **使能逻辑：** 在同步部分内，仅当 `en` 为高电平时，计数器才会递增（`C = C + 1`）。如果 `en` 为低电平，`C` 将保持其值。在RTL中，如果在给定条件下没有为寄存器分配新值，它将保持其值。因此，我们只需要为递增指定逻辑：`if (en) C = C + 1;`。这将放在与 `if (reset)` 对应的 `else` 块内。\n\n3.  **理解赋值运算符：** 对于建模时序逻辑（寄存器、触发器、计数器），非阻塞赋值是标准约定。问题明确指出，伪代码中的 `=` 代表非阻塞赋值，它安排值更新在当前仿真时间步结束时发生，这准确地模仿了同步系统中所有触发器在时钟沿同时捕获其新值的行为。\n\n根据这些原则，我们来评估各个选项：\n\n*   **A：** 敏感列表是 `(posedge clk or posedge reset)`，它正确地建模了由时钟或复位事件触发的异步复位。逻辑 `if (reset)` 首先被检查，赋予其最高优先级。同步逻辑 `else if (en) C = C + 1;` 被正确放置，并且只在复位无效的时钟沿执行。此选项正确实现了所有要求。\n\n*   **B：** 敏感列表是 `(posedge clk)`。该块仅对时钟沿敏感。因此，`reset` 信号只会在时钟上升沿被检查，这使其成为**同步**复位。这违反了“异步”的要求。\n\n*   **C：** 这也是一个同步复位，因为敏感列表是 `(posedge clk)`。此外，其内部逻辑有缺陷：它在检查 `if (reset)` 之前检查 `if (en)`，使得使能信号的优先级高于复位信号，这是不正确的。\n\n*   **D：** 敏感列表 `(posedge clk or posedge reset)` 对于异步复位是正确的。然而，其内部逻辑错误地在 `if (reset)` 之前检查 `if (en)`。如果 `en` 和 `reset` 都为高电平，这将导致计数器递增，这违反了复位是无条件的这一要求。\n\n基于此分析，选项A是唯一正确建模了指定计数器所有方面的选项。", "answer": "$$\\boxed{A}$$", "id": "1957805"}, {"introduction": "在理解了如何控制寄存器后，下一步是设计决定其“下一个状态”的逻辑。这项实践 [@problem_id:1957755] 要求你为一个格雷码计数器推导组合逻辑，格雷码计数器因其可靠性而备受青睐。将期望的状态序列转化为布尔方程是设计任何时序电路的核心技能。", "problem": "在数字系统中，计数器是基本的构建模块。格雷码计数器是一种特殊类型的计数器，其通过一个二进制数序列进行计数，任意两个连续状态之间只有一个比特位发生变化。在状态转换可能是异步或有噪声的系统中，这一特性非常有价值，因为它可以防止转换过程中的险象和误读。\n\n您的任务是为一个同步3位格雷码计数器进行寄存器传输级（RTL）设计分析。该计数器由以下规范定义：\n- 它使用一个3位状态寄存器 `G_state`，由D型触发器组成。状态位表示为 $G_2, G_1, G_0$，其中 $G_2$ 是最高有效位。\n- 该计数器有三个输入：一个时钟（`clk`）、一个高电平有效同步复位（`reset`）和一个高电平有效计数使能（`enable`）。\n- 状态寄存器 `G_state` 仅在 `clk` 的上升沿更新。\n- 如果 `reset` 为高电平，则在下一个时钟上升沿，无论 `enable` 信号如何，状态都变为 `000`。\n- 如果 `reset` 为低电平且 `enable` 为高电平，计数器将转换到格雷码序列中的下一个状态。\n- 如果 `reset` 为低电平且 `enable` 为低电平，计数器将保持其当前状态。\n- 3位反射二进制格雷码序列为：000、001、011、010、110、111、101、100，然后循环回到 000。\n\nRTL设计的核心是指定用于计算寄存器下一状态的组合逻辑。设D型触发器的输入为 $D_2, D_1, D_0$。请确定这些输入的最小化积之和（SOP）布尔逻辑方程组，这些方程是当前状态位（$G_2, G_1, G_0$）和 `enable` 信号的函数。假设 `reset` 信号为低电平。\n\n从以下选项中选择正确的方程组。在表达式中，并置表示逻辑与运算，`+` 符号表示逻辑或运算，$\\overline{A}$ 表示 A 的逻辑非运算。\n\nA.\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} G_1 \\overline{G_0} + \\text{enable} G_2 G_0$\n$D_1 = \\overline{\\text{enable}} G_1 + G_1 \\overline{G_0} + \\text{enable} \\overline{G_2} G_0$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} \\overline{G_1} \\overline{G_2} + \\text{enable} G_1 G_2$\n\nB.\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} (G_2 \\oplus (G_1 G_0))$\n$D_1 = \\overline{\\text{enable}} G_1 + \\text{enable} (G_1 \\oplus G_0)$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} (\\overline{G_0})$\n\nC.\n$D_2 = G_1 \\overline{G_0} + G_2 G_0$\n$D_1 = \\overline{G_2} G_0 + G_1 \\overline{G_0}$\n$D_0 = \\overline{G_1} \\overline{G_2} + G_1 G_2$", "solution": "我们需要为一个同步3位反射格雷码计数器推导下一状态逻辑，其状态位为 $G_{2},G_{1},G_{0}$，并带有一个高电平有效的使能信号 $\\text{enable}$。在同步复位假定为低电平的情况下，每个下一状态输入 $D_i$ (D型触发器的输入) 的逻辑由当前状态 $G_i$ 和使能信号决定。\n- 如果 $\\text{enable}=0$，计数器保持状态，因此 $D_i = G_i$。\n- 如果 $\\text{enable}=1$，计数器转换到下一状态，因此 $D_i = N_i$，其中 $N_i$ 是下一格雷码状态的第 $i$ 位。\n\n综合这两种情况，标准形式为：\n$$\nD_{i}=\\overline{\\text{enable}} \\cdot G_{i}+\\text{enable} \\cdot N_{i}\n$$\n\n首先，我们根据给定的格雷码序列，为 $\\text{enable}=1$ 的情况推导出下一状态逻辑 $N_i$。\n状态转换映射： $000\\to 001 \\to 011 \\to 010 \\to 110 \\to 111 \\to 101 \\to 100 \\to 000$。\n\n我们可以为每个下一状态位 $N_2, N_1, N_0$ 构建一个真值表或卡诺图，其输入为当前状态位 $G_2, G_1, G_0$。\n| 当前状态 ($G_2G_1G_0$) | 下一状态 ($N_2N_1N_0$) |\n|---|---|\n| 000 | 001 |\n| 001 | 011 |\n| 011 | 010 |\n| 010 | 110 |\n| 100 | 000 |\n| 101 | 100 |\n| 110 | 111 |\n| 111 | 101 |\n\n从真值表中推导 $N_i$ 的最小化SOP（积之和）形式：\n1.  **推导 $N_2$**: 当且仅当当前状态为 $010, 101, 110, 111$ 时，$N_2=1$。最小化SOP为 $N_2 = G_1 \\overline{G_0} + G_2 G_0$。\n2.  **推导 $N_1$**: 当且仅当当前状态为 $001, 011, 010, 110$ 时，$N_1=1$。最小化SOP为 $N_1 = \\overline{G_2} G_0 + G_1 \\overline{G_0}$。\n3.  **推导 $N_0$**: 当且仅当当前状态为 $000, 001, 110, 111$ 时，$N_0=1$。这是一个标准的异或非（XNOR）模式，最小化SOP为 $N_0 = \\overline{G_2} \\overline{G_1} + G_2 G_1$。\n\n现在，我们将这些代入使能逻辑的完整表达式中：\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} (G_1 \\overline{G_0} + G_2 G_0)$\n$D_1 = \\overline{\\text{enable}} G_1 + \\text{enable} (\\overline{G_2} G_0 + G_1 \\overline{G_0})$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} (\\overline{G_2} \\overline{G_1} + G_2 G_1)$\n\n将 $\\text{enable}$ 分配进去，得到：\n$D_2 = \\overline{\\text{enable}} G_2 + \\text{enable} G_1 \\overline{G_0} + \\text{enable} G_2 G_0$\n$D_1 = \\overline{\\text{enable}} G_1 + \\text{enable} \\overline{G_2} G_0 + \\text{enable} G_1 \\overline{G_0}$\n$D_0 = \\overline{\\text{enable}} G_0 + \\text{enable} \\overline{G_2} \\overline{G_1} + \\text{enable} G_2 G_1$\n\n现在与提供的选项进行比较：\n*   **选项A** 的方程组与我们上面推导出的展开形式完全匹配，除了 $D_1$ 的项顺序不同。\n    $D_1$ 表达式为 $D_1 = \\overline{\\text{enable}} G_1 + G_1 \\overline{G_0} + \\text{enable} \\overline{G_2} G_0$。\n    这是一个经过优化的形式。我们可以通过分情况讨论来验证其正确性：\n    - 如果 $\\text{enable}=0$，表达式变为 $D_1 = G_1 + G_1 \\overline{G_0} = G_1$（根据吸收律），这正确地实现了保持状态的功能。\n    - 如果 $\\text{enable}=1$，表达式变为 $D_1 = G_1 \\overline{G_0} + \\overline{G_2} G_0$，这正是我们推导出的下一状态逻辑 $N_1$。\n    因此，选项A中的所有方程都是正确的。\n\n*   **选项B** 使用了异或（XOR），其逻辑与我们推导的SOP形式不符。例如，$N_1$ 依赖于 $G_2, G_1, G_0$，而选项B的 $D_1$ 仅依赖于 $G_1, G_0$。\n*   **选项C** 完全忽略了 `enable` 信号，它只描述了计数器始终计数的情况，不满足保持状态的要求。\n\n因此，选项A是唯一正确的答案。", "answer": "$$\\boxed{A}$$", "id": "1957755"}, {"introduction": "现实世界的数字系统很少在单个时钟周期内完成任务；相反，它们通过多个步骤执行算法。这最后一个练习 [@problem_id:1957789] 将所有知识点融会贯通，通过为一个数据路径和一个控制器协同工作的完整系统建模，以实现浮点数的规格化。追踪这个多周期过程，为了解 RTL 如何不仅描述组件，还描述整个计算过程提供了顶石般的体验。", "problem": "一个专门的数字电路被设计用来对一个8位非规格化浮点数进行规格化。该电路的数据路径由两个8位寄存器组成：一个指数寄存器 `E` 和一个尾数寄存器 `M`。该系统由一个同步有限状态机（FSM）控制，它负责协调整个规格化过程。\n\n数据路径包含以下组件和控制信号：\n- `E`, `M`：8位寄存器。\n- `E_{in}`, `M_{in}`：8位输入总线。\n- `start`：一个1位的输入信号，用于开始操作。\n- `done`：一个1位的输出信号，当规格化完成时置为高电平（`1`）。\n- `E_{load}`：一个控制信号，当置位时，在下一个时钟上升沿将 `E_{in}` 的值加载到 `E` 中。\n- `M_{load}`：一个控制信号，当置位时，在下一个时钟上升沿将 `M_{in}` 的值加载到 `M` 中。\n- `E_{dec}`：一个控制信号，当置位时，在下一个时钟上升沿将 `E` 的值减一（`E \\leftarrow E - 1`）。\n- `M_{shiftL}`：一个控制信号，当置位时，在下一个时钟上升沿对 `M` 执行逻辑左移操作（`M \\leftarrow M \\ll 1`，移入一个 `0`）。\n\nFSM 遵循以下操作顺序，所有状态转换和寄存器更新都在一个共同时钟的上升沿发生：\n\n1.  **IDLE 状态**：FSM 最初处于 IDLE 状态。只要 `start` 信号为低电平（`0`），它就保持在该状态。在此期间，`done` 为低电平。\n2.  **LOAD 状态**：在时钟上升沿检测到 `start = 1` 后，FSM 转换到 LOAD 状态，并持续一个时钟周期。在此状态下，它置位 `E_{load}` 和 `M_{load}` 以捕获输入值。\n3.  **NORMALIZE 状态**：在 LOAD 状态之后，FSM 进入 NORMALIZE 状态。在此状态的每个时钟周期内，它会检查尾数的最高有效位 `M[7]`。\n    - 如果 `M[7] = 1` 或者整个尾数为零（`M = 00000000_2`），则认为该数已规格化。FSM 转换到 DONE 状态。\n    - 如果 `M[7] = 0` 且 `M` 不为零，FSM 会置位 `E_{dec}` 和 `M_{shiftL}` 信号，并在下一个周期保持在 NORMALIZE 状态。\n4.  **DONE 状态**：在此状态下，FSM 将 `done` 信号置为 `1`，并保持 `E` 和 `M` 中的最终值。\n\n假设系统已上电并处于 IDLE 状态。在时钟周期 1 的上升沿，输入被设置为 `E_{in} = 10110110_2` 和 `M_{in} = 00001101_2`，并且 `start` 信号被置为高电平。`start` 信号仅在该单个时钟周期内保持高电平。\n\n当 `done` 信号首次被置为高电平时，在该时钟周期结束时，分别存储在寄存器 `E` 和 `M` 中的最终8位二进制值是什么？请将您的答案表示为一个包含 E 和 M 的两个8位二进制字符串的行矩阵。", "solution": "为了确定最终的寄存器值，我们必须精确地追踪FSM状态和寄存器内容在每个时钟周期上升沿的变化。\n\n初始状态：系统处于 IDLE 状态。`E` 和 `M` 的内容未知。`done=0`。\n\n**时钟周期 1 (上升沿)**：\n- FSM处于IDLE状态。\n- 检测到 `start = 1`。\n- **动作**：FSM决定在下一个时钟沿转换到LOAD状态。\n\n**时钟周期 2 (上升沿)**：\n- FSM进入LOAD状态。\n- **动作**：FSM置位 `E_{load}` 和 `M_{load}` 控制信号。FSM决定在下一个时钟沿转换到NORMALIZE状态。\n\n**时钟周期 3 (上升沿)**：\n- 在LOAD状态下置位的控制信号生效。\n- **寄存器更新**：`E ← E_{in} = 10110110`, `M ← M_{in} = 00001101`。\n- FSM进入NORMALIZE状态。\n- **FSM检查**：`M[7]` ( `00001101` 的最高位) 为 `0`，且 `M` 不为零。\n- **动作**：FSM置位 `E_{dec}` 和 `M_{shiftL}`。FSM决定保持在NORMALIZE状态。\n\n**时钟周期 4 (上升沿)**：\n- 在NORMALIZE状态下置位的控制信号生效。\n- **寄存器更新**：`E ← 10110110 - 1 = 10110101`，`M ← 00001101  1 = 00011010`。\n- FSM保持在NORMALIZE状态。\n- **FSM检查**：`M[7]` (`00011010` 的最高位) 仍然为 `0`。\n- **动作**：FSM再次置位 `E_{dec}` 和 `M_{shiftL}`，并决定保持在NORMALIZE状态。\n\n**时钟周期 5 (上升沿)**：\n- 控制信号生效。\n- **寄存器更新**：`E ← 10110101 - 1 = 10110100`，`M ← 00011010  1 = 00110100`。\n- FSM保持在NORMALIZE状态。\n- **FSM检查**：`M[7]` (`00110100` 的最高位) 仍然为 `0`。\n- **动作**：FSM再次置位 `E_{dec}` 和 `M_{shiftL}`，并决定保持在NORMALIZE状态。\n\n**时钟周期 6 (上升沿)**：\n- 控制信号生效。\n- **寄存器更新**：`E ← 10110100 - 1 = 10110011`，`M ← 00110100  1 = 01101000`。\n- FSM保持在NORMALIZE状态。\n- **FSM检查**：`M[7]` (`01101000` 的最高位) 仍然为 `0`。\n- **动作**：FSM再次置位 `E_{dec}` 和 `M_{shiftL}`，并决定保持在NORMALIZE状态。\n\n**时钟周期 7 (上升沿)**：\n- 控制信号生效。\n- **寄存器更新**：`E ← 10110011 - 1 = 10110010`，`M ← 01101000  1 = 11010000`。\n- FSM保持在NORMALIZE状态。\n- **FSM检查**：`M[7]` (`11010000` 的最高位) 现在为 `1`。规格化完成。\n- **动作**：FSM不置位任何数据路径控制信号。FSM决定在下一个时钟沿转换到DONE状态。\n\n**时钟周期 8 (上升沿)**：\n- FSM进入DONE状态。\n- **动作**：FSM置位 `done` 信号为 `1`。\n- 此时，`done` 信号首次变为高电平。寄存器中的值是在上一个周期（周期7）结束时确定的值。\n\n因此，当 `done` 首次被置为高电平时，寄存器中的最终值为：\n- **E**: `10110010`\n- **M**: `11010000`\n\n这个过程可以通过计算初始尾数 `M_in = 00001101` 的前导零数量来快速验证。它有4个前导零。因此，需要进行4次左移和4次指数递减。\n- 最终 `M`: `M_in  4 = 00001101  4 = 11010000`。\n- 最终 `E`: `E_in - 4 = 10110110_2 - 4 = 182_{10} - 4 = 178_{10} = 10110010_2`。\n计算结果与时序追踪一致。", "answer": "$$\\boxed{\\begin{pmatrix}10110010  11010000\\end{pmatrix}}$$", "id": "1957789"}]}