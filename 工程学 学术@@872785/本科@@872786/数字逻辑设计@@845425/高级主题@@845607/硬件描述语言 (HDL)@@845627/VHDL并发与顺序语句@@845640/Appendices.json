{"hands_on_practices": [{"introduction": "时序电路构成了数字系统的“记忆”核心，而计数器是时序逻辑的经典范例。本练习将指导你构建一个带有异步复位的递减计数器，这是一种至关重要的设计模式，可确保电路能立即、无视时钟信号地恢复到预知状态。通过这个练习[@problem_id:1976164]，你将掌握在VHDL中实现异步行为的标准方法。", "problem": "您的任务是使用超高速集成电路硬件描述语言（VHDL）为一个数字系统设计一个组件。该组件是一个 3 位二进制递减计数器，具有以下规范：\n- 它有一个时钟输入 `clk`。\n- 它有一个低电平有效（active-low）的异步复位输入 `rst_n`。\n- 它有一个 3 位输出 `q_out`。\n\n计数器的行为必须如下：\n1.  当复位信号 `rst_n` 被断言（即 `rst_n` 为逻辑 '0'）时，输出 `q_out` 必须立即异步地设置为 `111`。\n2.  当复位未被断言时，在时钟 `clk` 的每个上升沿，计数器的值必须减一。\n3.  计数器应该回卷。也就是说，当它从 `000` 递减时，下一个状态应该是 `111`。\n\n假设提供了以下 VHDL 上下文：\n```vhdl\nLIBRARY ieee;\nUSE ieee.std_logic_1164.ALL;\nUSE ieee.numeric_std.ALL;\n\nENTITY down_counter IS\n  PORT (\n    clk   : IN  std_logic;\n    rst_n : IN  std_logic;\n    q_out : OUT std_logic_vector(2 DOWNTO 0)\n  );\nEND ENTITY down_counter;\n\nARCHITECTURE behavioral OF down_counter IS\n  SIGNAL q_reg : unsigned(2 DOWNTO 0);\nBEGIN\n\n  -- A VHDL process block goes here --\n  \n  q_out = std_logic_vector(q_reg);\n\nEND ARCHITECTURE behavioral;\n```\n\n当插入到上述架构中时，以下哪个 VHDL `PROCESS` 块正确地实现了指定的 3 位递减计数器？\n\nA.\n```vhdl\ncounter_proc : PROCESS (clk)\nBEGIN\n  IF rising_edge(clk) THEN\n    IF rst_n = '0' THEN\n      q_reg = \"111\";\n    ELSE\n      q_reg = q_reg - 1;\n    END IF;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nB.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '1' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nC.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg + 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nD.\n```vhdl\ncounter_proc : PROCESS (clk, rst_n)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```\n\nE.\n```vhdl\ncounter_proc : PROCESS (clk, q_reg)\nBEGIN\n  IF rst_n = '0' THEN\n    q_reg = \"111\";\n  ELSIF rising_edge(clk) THEN\n    q_reg = q_reg - 1;\n  END IF;\nEND PROCESS counter_proc;\n```", "solution": "我们识别出所需的行为，并将它们映射到 VHDL 进程结构和敏感性列表的要求：\n\n1) 异步、低电平有效复位：\n- 异步复位意味着进程必须对复位信号敏感，并在满足复位条件时立即赋予防问值，而与时钟沿无关。因此，进程的敏感性列表必须同时包含时钟和复位信号，即必须包含 `clk` 和 `rst_n`。\n- 低电平有效意味着复位操作必须在 `rst_n = '0'` 时发生。\n- 异步复位的标准 VHDL 模板将复位条件置于时钟沿检测之前的第一个分支：`IF rst_n = '0' THEN ... ELSIF rising_edge(clk) THEN ... END IF;`。\n\n2) 在时钟上升沿递减：\n- 当复位未被断言时，计数器必须在 `clk` 的每个上升沿减一：这要求 `ELSIF rising_edge(clk)` 分支执行 `q_reg = q_reg - 1;`。\n\n3) 从 `000` 回卷到 `111`：\n- 使用 ieee.numeric_std 和 unsigned 类型，对一个固定宽度的 unsigned 向量执行 `q_reg - 1` 操作会以 $2^{3}$ 为模进行回卷。因此，`\"000\" - 1` 会自动变为 `\"111\"`，无需额外逻辑即可满足回卷要求。\n\n现在根据这些要求评估每个选项：\n\n- 选项 A：进程敏感性列表只包含 `clk`，并且复位检查位于上升沿分支内部。这实现的是同步复位，而不是异步复位。因此，它不满足异步复位要求。\n\n- 选项 B：敏感性列表包含 `clk` 和 `rst_n`，但它在 `rst_n = '1'` 时复位。这实现的是高电平有效（active-high）复位，与低电平有效（active-low）的要求相矛盾。\n\n- 选项 C：敏感性列表和低电平有效异步复位位置正确，但时钟触发的操作是递增，`q_reg = q_reg + 1`，而不是递减。这违反了指定的行为。\n\n- 选项 D：敏感性列表包含 `clk` 和 `rst_n`。第一个分支在 `rst_n = '0'` 时复位（低电平有效，异步），而 `ELSIF rising_edge(clk)` 分支执行 `q_reg = q_reg - 1`，它以正确的模 $2^{3}$ 回卷方式递减。这符合所有要求。\n\n- 选项 E：敏感性列表错误地使用了 `(clk, q_reg)` 并省略了 `rst_n`，因此 `rst_n` 上的变化不会触发该进程，这违反了异步复位要求。\n\n因此，唯一正确实现指定 3 位递减计数器的选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1976164"}, {"introduction": "VHDL代码不仅仅是程序，更是硬件的蓝图。代码的结构，特别是 `if-elsif` 语句中的优先级，直接决定了最终综合出的逻辑门电路。本练习[@problem_id:1976143]将探讨当复位信号被赋予较低优先级时会发生什么，它展示了看似微小的代码调整如何导致不同且效率较低的硬件实现，从而加深你对代码与硬件映射关系的理解。", "problem": "一位数字系统工程师正在使用VHSIC硬件描述语言（VHDL）设计一个组件。该组件是一个8位寄存器，具有同步高电平有效复位（`sync_reset`）和高电平有效加载使能（`load_en`）。该寄存器由 `clk` 提供时钟信号。该工程师在一个架构块内编写了以下VHDL代码。\n\n```vhdl\n-- Signal Declarations\nsignal clk         : std_logic;\nsignal sync_reset  : std_logic;\nsignal load_en     : std_logic;\nsignal data_in     : std_logic_vector(7 downto 0);\nsignal q           : std_logic_vector(7 downto 0);\n\n-- ...\n\n-- Process for the register\nREG_PROC: process(clk)\nbegin\n  if rising_edge(clk) then\n    if load_en = '1' then\n      q = data_in;\n    elsif sync_reset = '1' then\n      q = (others = '0');\n    else\n      q = q; -- Hold current value\n    end if;\n  end if;\nend process REG_PROC;\n```\n\n当此VHDL代码由综合工具处理以生成硬件时，嵌套 `if-elsif` 结构中编写的控制信号（`load_en` 和 `sync_reset`）的优先级直接影响最终生成的逻辑电路。假设一个标准综合工具会逐字翻译代码，以下哪个陈述最准确地描述了为寄存器 `q` 及其输入逻辑综合出的硬件？\n\nA. 代码综合成一个单独的8位寄存器。该寄存器的数据输入由一个2选1多路复用器提供，其选择线是 `load_en`。该多路复用器的 '1' 输入是 `data_in`。其 '0' 输入由第二个2选1多路复用器的输出提供，该多路复用器使用 `sync_reset` 作为其选择线，在恒定零向量和当前寄存器输出 `q` 之间进行选择。\n\nB. 综合工具将识别其功能意图并优化代码。它将生成一个带有专用同步清除端口的8位寄存器，该端口连接到 `sync_reset`。寄存器的数据输入将由一个由 `load_en` 控制的2选1多路复用器提供，该多路复用器在 `data_in` 和当前寄存器输出 `q` 之间进行选择。\n\nC. 代码综合成一个8位寄存器，其输入由一个3选1多路复用器提供。该多路复用器的选择线由一个组合逻辑块形成，该逻辑块以 `load_en` 和 `sync_reset` 作为输入。多路复用器的数据输入是 `data_in`、一个恒定零向量和当前寄存器输出 `q`。\n\nD. 代码将无法综合，因为它描述了一个具有模糊优先级结构的硬件元件。在一个时钟进程中，同步复位必须始终是最高优先级的条件，才能被综合成标准触发器。\n\nE. 代码综合成一个包含一个8位锁存器后跟一个8位寄存器的结构。锁存器的产生是因为 `sync_reset` 条件没有在 `load_en` 信号状态的每个可能分支上都被检查。", "solution": "目标是确定综合工具将根据给定的VHDL进程创建的硬件结构。综合工具将时钟进程内的过程式代码映射为寄存器以及驱动其输入的组合逻辑。\n\n1.  **识别时序元件**：VHDL进程仅对时钟 `clk` 敏感，并且所有对 `q` 的信号赋值都发生在 `if rising_edge(clk) then ... end if;` 块内。这种结构可靠地推断出一组边沿触发的触发器，信号 `q` 的每一位对应一个。由于 `q` 是一个8位向量（`std_logic_vector(7 downto 0)`），这将是一个8位寄存器。\n\n2.  **分析组合逻辑**：决定 `q` 的*下一个*状态（它成为触发器的D输入）的逻辑由嵌套的 `if-elsif-else` 语句描述。综合工具会将这种优先级编码的结构转换为一连串的多路复用器或等效的逻辑门。我们需要追踪这个优先级。\n\n3.  **最高优先级条件**：在时钟块内检查的第一个条件是 `if load_en = '1' then`。这使得 `load_en` 具有最高优先级。\n    - 如果 `load_en` 为 '1'，`q` 的下一个值将是 `data_in`。\n    - 如果 `load_en` 为 '0'，逻辑将进入 `elsif` 部分。\n\n4.  **第二优先级条件**：下一个条件是 `elsif sync_reset = '1' then`。这仅在 `load_en = '0'` 时才会被评估。\n    - 如果 `load_en` 为 '0' 并且 `sync_reset` 为 '1'，`q` 的下一个值将是零向量 `(others = '0')`。\n    - 如果 `load_en` 为 '0' 并且 `sync_reset` 为 '0'，逻辑将进入 `else` 部分。\n\n5.  **最低优先级条件（默认）**：`else` 子句 `q = q;` 是默认操作。当 `load_en` 和 `sync_reset` 都为 '0' 时执行。这个 `q = q` 语句意味着寄存器应保持其当前值。\n\n6.  **综合为硬件模型**：我们现在可以构建为8位寄存器的D输入提供信号的组合逻辑电路，我们将此输入称为 `d_next`。我们从最高优先级到最低优先级进行分析。\n\n    - 一个2选1多路复用器（我们称之为MUX1）被用来实现基于 `load_en` 的最高优先级决策。选择线是 `load_en`。\n    - 当 `load_en = '1'` 时，MUX1必须选择 `data_in`。因此，`data_in` 连接到MUX1的 '1' 输入端。\n    - 当 `load_en = '0'` 时，MUX1必须选择较低优先级逻辑的结果。这个较低优先级逻辑的输出将连接到MUX1的 '0' 输入端。\n\n    - 现在，我们来设计为MUX1的 '0' 输入端提供信号的较低优先级逻辑。该逻辑必须决定当 `load_en` 为 '0' 时做什么。该决策基于 `sync_reset`。\n    - 这需要另一个2选1多路复用器（我们称之为MUX2）。它的选择线是 `sync_reset`。\n    - 当 `sync_reset = '1'` 时，MUX2必须选择复位值，即8位零向量 `(others = '0')`。因此，常数 `0` 连接到MUX2的 '1' 输入端。\n    - 当 `sync_reset = '0'` 时，MUX2必须选择来自 `else` 子句的值，即寄存器的当前值 `q`。因此，寄存器 `q` 的输出被反馈到MUX2的 '0' 输入端。\n\n7.  **组合各部分**：MUX2的输出馈入MUX1的 '0' 输入。MUX1的输出馈入8位寄存器 `q` 的D输入。这种结构是一个级联的多路复用器链。与高优先级复位可以使用触发器上的专用清除输入的理想情况相比，这种效率较低，但它是对所提供VHDL代码的直接且正确的翻译。\n\n8.  **评估选项**：\n    *   **A**：“代码综合成一个单独的8位寄存器。该寄存器的数据输入由一个2选1多路复用器提供，其选择线是 `load_en`。该多路复用器的 '1' 输入是 `data_in`。其 '0' 输入由第二个2选1多路复用器的输出提供，该多路复用器使用 `sync_reset` 作为其选择线，在恒定零向量和当前寄存器输出 `q` 之间进行选择。” 此描述与步骤6和7中推导出的硬件完全匹配。\n    *   **B**：这是不正确的。虽然这是*期望的*且更优化的结构，但综合工具会遵循代码中指定的优先级。代码明确地将 `load_en` 置于比 `sync_reset` 更高的优先级，这阻止了工具在這種直接翻译中使用专用的复位引脚。\n    *   **C**：3选1多路复用器是实现此逻辑的一种可能性，但级联的2选1多路复用器结构是对嵌套 `if-elsif-else` 优先级结构更直接、更字面的表示。选项A是对这种优先级编码更精确的描述。\n    *   **D**：这是不正确的。该代码对于综合来说是完全有效的VHDL。它可能导致次优的硬件（额外的逻辑导致更长的传播延迟），但它并不模糊，并且会正确综合。\n    *   **E**：这是不正确的。当一个信号在组合进程的所有可能分支中都没有被赋值时，会推断出锁存器。在这个时钟进程中，`else q = q;` 子句确保了 `q` 在每个时钟上升沿总是被赋值，从而防止了锁存器的推断。\n\n因此，选项A是对综合硬件最准确的描述。", "answer": "$$\\boxed{A}$$", "id": "1976143"}, {"introduction": "对于设计者而言，一个危险的陷阱是代码在仿真中的行为与在实际硬件中的行为不一致。本练习[@problem_id:1976132]揭示了一个经典的“仿真-综合不匹配”问题：组合逻辑环路。你将看到这个编码错误如何在仿真器中导致无限循环，却在最终的芯片上产生一个不希望出现的物理振荡器，这是学习稳健设计的重要一课。", "problem": "一位工程师正在使用VHSIC硬件描述语言（VHDL）为一个系统设计一个简单的故障检测模块。该模块有一个输入 `system_ok`，在正常操作期间其值为'1'，当检测到故障时其值为'0'。该模块有一个输出 `alarm_active`。设计意图是，当发生故障时（`system_ok` = '0'），`alarm_active` 信号应开始翻转，大概是为了闪烁一个状态发光二极管（LED）。如果系统恢复正常（`system_ok` = '1'），警报应被重置为'0'。\n\n该工程师编写了以下VHDL代码。请分析 `p_alarm_logic` 进程，特别是当输入 `system_ok` 保持为恒定值‘0’时发生的行为。\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity fault_detector is\n    port (\n        system_ok    : in  std_logic;\n        alarm_active : out std_logic\n    );\nend entity fault_detector;\n\narchitecture behavioral of fault_detector is\n    signal internal_alarm : std_logic := '0';\nbegin\n\n    -- Process to control the alarm state\n    p_alarm_logic : process(system_ok, internal_alarm)\n    begin\n        if system_ok = '1' then\n            internal_alarm = '0';\n        else\n            -- When system is not okay, toggle the alarm\n            internal_alarm = not internal_alarm;\n        end if;\n    end process p_alarm_logic;\n\n    -- Assign internal state to the output port\n    alarm_active = internal_alarm;\n\nend architecture behavioral;\n```\n\n当 `system_ok` 保持为'0'时，以下哪个选项最准确地描述了此代码在标准事件驱动VHDL仿真器中的行为与典型RTL综合工具生成的物理电路行为之间的差异？\n\nA. **仿真：** 信号 `internal_alarm` 将被稳定地锁存为值'1'。**综合：** 会创建一个透明锁存器，只要 `system_ok` 为'0'，它就保持值'1'。\nB. **仿真：** 仿真器报告 `internal_alarm` 在从其前一个值进行单次逻辑反相后进入稳定状态。**综合：** 会创建一个简单的反相器，其输入接地，其输出驱动 `alarm_active`。\nC. **仿真：** 仿真器很可能会因为在零延迟无限循环中超过迭代限制而停止并报告错误。**综合：** 会创建一个自由运行的异步振荡器。\nD. **仿真：** 信号 `internal_alarm` 在每个预定义的仿真时间步长（例如1 ns）内精确地翻转其值一次。**综合：** 会错误地推断出一个T型触发器，然后由于缺少时钟信号而被标记为错误。\nE. **仿真：** 代码仿真无误，显示 `internal_alarm` 以一个非常高的、依赖于仿真器的频率进行翻转。**综合：** 代码被认为是根本不可综合的，并将被综合工具以致命错误拒绝。", "solution": "我们在输入保持恒定值 $system\\_ok = '0'$ 的条件下，分别分析该进程的语义和综合后的硬件。\n\n首先，我们象征性地表达进程的行为。令 $s$ 表示 `system_ok`，$i$ 表示 `internal_alarm` 的当前值，$i^{+}$ 表示由进程调度的 `internal_alarm` 的值（当前delta周期后的下一个值）。该进程实现了布尔映射\n$$\ni^{+} =\n\\begin{cases}\n0,   \\text{if } s = \\text{'1'} \\\\\n\\lnot i,  \\text{if } s = \\text{'0'}\n\\end{cases}\n$$\n并且该进程对 $s$ 和 $i$ 都敏感。\n\n对于 $s = '0'$ 的事件驱动仿真行为：\n1. 当 $s = '0'$ 保持恒定时，进程映射简化为 $i^{+} = \\lnot i$。\n2. 在VHDL中，带有敏感列表的进程内的信号赋值被调度在进程挂起后生效，即在同一仿真时间的下一个delta周期生效。因此，在进程计算出 $i^{+} = \\lnot i$ 后，仿真器会在不推进仿真时间的情况下，在下一个delta周期更新 $i \\leftarrow i^{+}$。\n3. 因为进程的敏感列表包含了 `internal_alarm`，所以对 $i$ 的这次更新是一个事件，它会在同一仿真时间立即重新触发该进程。条件 $s = '0'$ 仍然成立，因此进程会再次计算 $i^{+} = \\lnot i$。\n4. 结果是在同一仿真时间点上出现无限的delta周期序列，其中 $i$ 在每个delta周期都进行翻转：$i \\mapsto \\lnot i \\mapsto \\lnot(\\lnot i) \\mapsto \\cdots$，这在零延迟内永远不会收敛。标准的事件驱动仿真器会将其检测为零延迟不收敛振荡，并因超出迭代限制或在给定时间不收敛等错误而终止。\n\n对于 $s = '0'$ 的综合和物理电路行为：\n1. RTL综合将该进程映射为组合逻辑。该逻辑等效于一个2选1多路选择器，其选择输入是 $s$，输出是 $i^{+}$，数据输入是常量 $0$ 和 $\\lnot i$，其中 $i$ 被反馈回来形成 $\\lnot i$ 输入：\n   - 如果 $s = '1'$：多路选择器选择常量 $0$，因此 $i$ 被驱动为 $0$。\n   - 如果 $s = '0'$：多路选择器选择 $\\lnot i$，形成一个组合逻辑环路，通过逻辑的传播延迟强制实现 $i = \\lnot i$。\n2. 在实际硬件中，这种带有奇数个反相的组合逻辑反馈构成了一个环形振荡器。由于真实的、非零的门延迟和布线延迟，节点 $i$ 将以由物理延迟决定的频率进行异步振荡。综合工具通常会对此组合逻辑环路发出警告，但仍会生成实现此反馈的网表；它不是锁存器或时钟元件，并且不会仅仅因为缺少时钟而被拒绝。\n\n因此，当 `system_ok` 保持为 '0' 时：\n- 在仿真中，模型会进入一个零延迟的无限delta周期振荡，仿真器很可能会因不收敛或超出迭代限制错误而停止。\n- 在综合后的硬件中，通过反相器的反馈创建了一个自由运行的异步振荡器。\n\n与选项进行比较，这与选项C完全匹配，并与其他选项相矛盾（没有稳定的'1'值锁存，没有单时间步翻转，没有推断出T型触发器，并且通常不会因不可综合而被拒绝）。", "answer": "$$\\boxed{C}$$", "id": "1976132"}]}