{"hands_on_practices": [{"introduction": "在数字设计中，算术运算是核心任务之一。然而，VHDL 是一种强类型语言，这意味着你不能直接对不同数据类型的对象进行运算。本练习将引导你掌握在 VHDL 中执行有符号数乘法的标准方法，这需要使用业界标准的 `ieee.numeric_std` 库进行显式类型转换，这是现代 VHDL 设计的一项基本技能 [@problem_id:1976696]。", "problem": "您正在使用超高速集成电路硬件描述语言 (VHDL) 设计一个简单的数字信号处理 (DSP) 内核。该内核需要计算瞬时功率，其定义为电压和电流的乘积。这两个量由外部的模数转换器以8位有符号数的形式提供，在您的 VHDL 设计中用 `std_logic_vector` 类型表示。\n\n请看下面这个功率计算模块的 VHDL 实体声明：\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\nentity power_calculator is\n  port (\n    clk      : in  std_logic;\n    voltage  : in  std_logic_vector(7 downto 0);\n    current  : in  std_logic_vector(7 downto 0);\n    power    : out std_logic_vector(15 downto 0)\n  );\nend entity power_calculator;\n```\n两个N位有符号数的乘积结果是一个2N位的有符号数。因此，`voltage` 和 `current` 输入是8位向量，而 `power` 输出是16位向量。您的任务是在该实体的一个架构中实现其功能。乘法必须是寄存的，这意味着输出 `power` 仅在时钟信号 `clk` 的上升沿更新。\n\n以下哪个 VHDL 代码片段正确地为 `power_calculator` 实体实现了名为 `rtl` 的架构？\n\nA.\n```vhdl\narchitecture rtl of power_calculator is\n  use ieee.std_logic_arith.all;\n  use ieee.std_logic_unsigned.all;\nbegin\n  process(clk)\n  begin\n    if rising_edge(clk) then\n      power = std_logic_vector(signed(voltage) * signed(current));\n    end if;\n  end process;\nend architecture rtl;\n```\n\nB.\n```vhdl\narchitecture rtl of power_calculator is\n  use ieee.numeric_std.all;\nbegin\n  process(clk)\n  begin\n    if rising_edge(clk) then\n      power = std_logic_vector(unsigned(voltage) * unsigned(current));\n    end if;\n  end process;\nend architecture rtl;\n```\n\nC.\n```vhdl\narchitecture rtl of power_calculator is\n  use ieee.numeric_std.all;\nbegin\n  process(clk)\n  begin\n    if rising_edge(clk) then\n      power = std_logic_vector(signed(voltage) * signed(current));\n    end if;\n  end process;\nend architecture rtl;\n```\n\nD.\n```vhdl\narchitecture rtl of power_calculator is\nbegin\n  process(clk)\n  begin\n    if rising_edge(clk) then\n      power = voltage * current;\n    end if;\n  end process;\nend architecture rtl;\n```\n\nE.\n```vhdl\narchitecture rtl of power_calculator is\n  use ieee.numeric_std.all;\nbegin\n  process(clk)\n  begin\n    if rising_edge(clk) then\n      power = signed(voltage) * signed(current);\n    end if;\n  end process;\nend architecture rtl;\n```", "solution": "我们必须实现两个8位有符号值的寄存乘法，这两个值以 std_logic_vector 类型提供，结果是一个16位有符号值，也以 std_logic_vector 类型提供。这些要求意味着：\n\n1) 算术运算必须在有符号数上进行，因此输入必须被解释为 signed 类型，而不是 unsigned 类型。\n2) 乘法必须是同步的，即仅在时钟的上升沿进行赋值，因此操作必须位于 if rising_edge(clk) then 语句内部。\n3) 操作符“*”并未为 std_logic_vector 定义；它在 IEEE 标准库 ieee.numeric_std 中为 signed 和 unsigned 定义。因此，我们必须包含 use ieee.numeric_std.all; 并将 std_logic_vector 输入强制转换为 signed 类型。\n4) 两个 $N$ 位有符号数的乘积产生一个 $2N$ 位的有符号结果。当 $N=8$ 时，结果是 $16$ 位。在 ieee.numeric_std 中，两个 signed(7 downto 0) 值的乘积是一个 signed(15 downto 0) 值，与输出端口的宽度相匹配。\n5) 由于输出端口 power 的类型是 std_logic_vector(15 downto 0)，因此有符号乘积必须转换回 std_logic_vector 类型才能进行赋值。\n\n评估各个选项：\n\n- 选项 A 使用了非标准的 Synopsys 程序包（ieee.std_logic_arith 和 ieee.std_logic_unsigned）。混合使用这些是不标准的，并且不被推荐；标准方法要求使用 ieee.numeric_std。因此，选项 A 不是符合标准的正确实现。\n\n- 选项 B 使用了 ieee.numeric_std，但将两个操作数都视为 unsigned，这是不正确的，因为输入代表有符号值。这对于负值会产生错误的结果。\n\n- 选项 C 使用了 ieee.numeric_std，将两个输入都强制转换为 signed，将它们相乘，然后将有符号乘积转换为 std_logic_vector 以用于输出，所有这些都在一个 rising_edge(clk) 同步进程内完成。这满足了所有要求，并正确使用了标准程序包。\n\n- 选项 D 试图直接对 std_logic_vector 进行乘法运算，而没有进行类型转换，也没有导入用于 signed/unsigned 的算术库；“*” 对 std_logic_vector 未定义，因此它是无效的。\n\n- 选项 E 执行了有符号乘法，但试图将一个 signed 结果直接赋给一个 std_logic_vector 输出，而没有进行转换，这会导致类型不匹配。\n\n因此，只有选项 C 是正确的。", "answer": "$$\\boxed{C}$$", "id": "1976696"}, {"introduction": "理解信号 (signal) 和变量 (variable) 之间的区别对于掌握 VHDL至关重要。本练习通过一个思想实验，揭示了当多个并发进程试图修改一个`共享变量` (shared variable) 时产生的非确定性行为，即“竞争条件” (race condition) [@problem_id:1976697]。通过分析这种行为，你将深刻理解为何在可综合的多进程通信中，信号是比共享变量更安全、更受推荐的选择。", "problem": "一位工程师正在设计一个数字系统，用于对两个独立的同步传感器检测到的事件进行计数。为了仿真该事件计数器的行为，创建了一个 VHDL 模型。该设计使用了两个并发进程，每个进程对应一个传感器，旨在在公共时钟信号 `clk` 的每个上升沿上增加一个共享计数器的值。仿真的过程由第三个进程控制，该进程在初始 `reset` 后，使计数在固定的时钟周期数 `N_CYCLES` 内有效。\n\n请看下面 `race_condition_eval` 实体的 VHDL 代码片段。\n\n```vhdl\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\n\nentity race_condition_eval is\n    port (\n        clk   : in  std_logic;\n        reset : in  std_logic;\n        final_count : out integer\n    );\nend entity race_condition_eval;\n\narchitecture behavioral of race_condition_eval is\n    signal stop_sim : boolean := false;\n    shared variable event_counter : integer := 0;\n    \n    constant N_CYCLES : integer := 80;\n\nbegin\n\n    process_A: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_A;\n\n    process_B: process(clk)\n    begin\n        if rising_edge(clk) then\n            if not stop_sim then\n                event_counter := event_counter + 1;\n            end if;\n        end if;\n    end process process_B;\n\n    control_proc: process\n    begin\n        -- Wait for reset to be applied and then de-asserted\n        wait until reset = '1';\n        wait until reset = '0';\n        \n        event_counter := 0;\n        stop_sim = false;\n        \n        for i in 1 to N_CYCLES loop\n            wait until rising_edge(clk);\n        end loop;\n        \n        stop_sim = true;\n        \n        -- Allow one final delta cycle for processes to stop\n        wait for 0 ns; \n        \n        final_count = event_counter;\n        \n        wait; -- Halt the control process\n    end process control_proc;\n\nend architecture behavioral;\n```\n\n假设一个 VHDL 仿真器执行此代码。由于并发进程中共享变量的特性，`final_count` 输出端口上报告的 `event_counter` 的最终值是非确定性的。\n\n请确定仿真完成后 `final_count` 的最小可能值和最大可能值。计算此最小可能值和最大可能值的和。", "solution": "我们分析在公共时钟的每个上升沿上的执行情况。process_A 和 process_B 都对 $rising\\_edge(clk)$ 敏感，并且当 $stop\\_sim$ 为 false 时，每个进程都会对共享变量执行一次读-修改-写操作：\n$$\nevent\\_counter := event\\_counter + 1.\n$$\n在 VHDL 中，共享变量的更新是立即的，但并发进程在同一个 delta 周期内以不确定的顺序恢复执行。因此，在任意一个给定的上升沿上：\n- 如果两个进程在任一方写入之前都读取了相同的旧值 $x$，那么它们各自计算 $x+1$ 然后写入 $x+1$，最终导致净增量为 1。\n- 如果一个进程在另一个进程读取之前完成了其增量操作，那么第二个进程将读取 $x+1$ 并写入 $x+2$，最终导致净增量为 2。\n\n因此，对于每个有效的上升沿 $k$，净增量 $m_{k}$ 满足 $m_{k} \\in \\{1,2\\}$，并且没有其他可能的结果。\n\n控制进程执行以下操作：\n1) 它等待 $reset$ 置为有效然后变为无效，接着执行 $event\\_counter := 0$ 和 $stop\\_sim \\le false$。对 $event\\_counter$ 的赋值确保了之前的活动被清除；随后的循环精确地对接下来 $N\\_CYCLES$ 个上升沿进行计数。\n2) 然后它精确地等待 $N\\_CYCLES$ 个上升沿：\n$$\n\\text{for } i=1 \\text{ to } N\\_CYCLES: \\quad \\text{wait until } rising\\_edge(clk).\n$$\n在这 $N\\_CYCLES$ 个时钟沿期间，$stop\\_sim$ 保持为 false，因为赋值语句 $stop\\_sim \\le true$ 只在循环之后发生，并在下一个 delta 周期生效，所以在这每一个时钟沿上两个进程都是使能的。\n3) 循环结束后，它执行 $stop\\_sim \\le true$，然后执行 $wait \\; for \\; 0 \\; ns$ 以允许一个 delta 周期，让时钟进程观察到 $stop\\_sim = true$ 并停止进一步的增量，之后再执行 $final\\_count \\le event\\_counter$ 赋值。\n\n设 $N := N\\_CYCLES$。从计数窗口开始时的 $event\\_counter = 0$ 算起，经过 $N$ 个有效的上升沿后，共享变量的最终值为\n$$\nevent\\_counter = \\sum_{k=1}^{N} m_{k}, \\quad \\text{with } m_{k} \\in \\{1,2\\}.\n$$\n因此，当每个周期都丢失一次增量时，达到最小可能值：\n$$\nevent\\_counter_{\\min} = \\sum_{k=1}^{N} 1 = N,\n$$\n而当每个周期两次增量都被保留时，达到最大可能值：\n$$\nevent\\_counter_{\\max} = \\sum_{k=1}^{N} 2 = 2N.\n$$\n所要求的和是\n$$\nevent\\_counter_{\\min} + event\\_counter_{\\max} = N + 2N = 3N.\n$$\n当 $N\\_CYCLES = 80$ 时，我们得到\n$$\n3N = 3 \\times 80 = 240.\n$$", "answer": "$$\\boxed{240}$$", "id": "1976697"}, {"introduction": "VHDL 的强大之处不仅在于其内置的数据类型，更在于它允许我们定义具有特定硬件行为的自定义类型。本练习将带你探索一个高级特性：解析类型 (resolved type) [@problem_id:1976728]。我们将学习如何通过自定义一个解析函数，将复杂的逻辑（如基于优先级的总线仲裁）直接嵌入到数据类型本身，从而为共享资源的设计提供一种更优雅的建模方式。", "problem": "在数字系统设计中，共享总线允许多个组件（主设备）通过一组公共导线进行通信。管理对该总线的访问以防止冲突至关重要，这通常由仲裁器电路来处理。本问题探讨了一种新颖的总线架构，它通过使用甚高速集成电路硬件描述语言（VHDL）的特性，将仲裁逻辑直接嵌入到总线信号的数据类型中，从而无需显式的仲裁器。\n\n考虑一个名为 `priority_logic` 的自定义VHDL逻辑类型，它被定义为一个枚举类型，具有以下可能的值：`'U'`（未初始化）、`'X'`（未知/冲突）、`'1'`（逻辑高）、`'0'`（逻辑低）和 `'Z'`（高阻态）。\n\n当多个主设备同时驱动此类型的单个信号时，一个特殊的解析函数会确定该信号的最终值。此函数基于严格的优先级方案运行，其中所有驱动值中优先级最高的值“获胜”。优先级顺序定义为：\n`'U'  'X'  '1'  '0'  'Z'`\n\n例如，如果三个驱动器试图在线路上放置 `'0'`、`'Z'` 和 `'1'`，则解析后的值将是 `'1'`，因为它是三者中优先级最高的。如果驱动器提供 `'1'` 和 `'X'`，则解析后的值将是 `'X'`。如果所有驱动器都是 `'Z'`，则线路保持在高阻态 `'Z'`。\n\n现在，考虑一个4位共享总线 `DATA_BUS`，其中每一位都是已解析的 `priority_logic` 类型的独立信号。这意味着四位中的每一位都根据上述优先级规则独立解析。三个主设备 `M1`、`M2` 和 `M3` 连接到此总线。系统根据以下事件序列运行：\n\n1.  在所有时间 `t  10 ns`，主设备们使用以下恒定的4位值（从第3位到第0位）驱动 `DATA_BUS`：\n    *   `M1` 驱动 `\"0Z1Z\"`\n    *   `M2` 驱动 `\"ZZ01\"`\n    *   `M3` 驱动 `\"ZZZZ\"`\n\n2.  在 `t = 10 ns` 时，主设备 `M3` 改变其输出并开始驱动值 `\"X10X\"`。\n\n3.  在 `t = 20 ns` 时，主设备 `M1` 改变其输出并开始驱动值 `\"Z110\"`。\n\n假设所有信号变化都是瞬时的，确定在时间 `t = 25 ns` 时 `DATA_BUS` 的4位状态。将您的答案表示为一个4字符的字符串，代表从第3位到第0位的总线值。", "solution": "总线使用一种解析类型，其解析函数根据严格顺序 $\\text{'U'}\\text{'X'}\\text{'1'}\\text{'0'}\\text{'Z'}$，为每一位独立地选择优先级最高的驱动值。信号变化是瞬时的，因此在 $t=25\\,\\text{ns}$ 时，有效的驱动值是在 $t=20\\,\\text{ns}$ 时最后一个事件之后生效的值。因此，主设备驱动如下：\n- $M1$：\"Z110\" （在 $t=20\\,\\text{ns}$ 时改变），\n- $M2$：\"ZZ01\" （全程未变），\n- $M3$：\"X10X\" （在 $t=10\\,\\text{ns}$ 时改变）。\n\n从最高有效位（第3位）到最低有效位（第0位）解析每一位：\n- 第3位：$M1=\\text{'Z'}$，$M2=\\text{'Z'}$，$M3=\\text{'X'}$；存在的最高优先级是 $\\text{'X'}$，所以第3位 = $\\text{'X'}$。\n- 第2位：$M1=\\text{'1'}$，$M2=\\text{'Z'}$，$M3=\\text{'1'}$；存在的最高优先级是 $\\text{'1'}$，所以第2位 = $\\text{'1'}$。\n- 第1位：$M1=\\text{'1'}$，$M2=\\text{'0'}$，$M3=\\text{'0'}$；存在的最高优先级是 $\\text{'1'}$，所以第1位 = $\\text{'1'}$。\n- 第0位：$M1=\\text{'0'}$，$M2=\\text{'1'}$，$M3=\\text{'X'}$；存在的最高优先级是 $\\text{'X'}$，所以第0位 = $\\text{'X'}$。\n\n因此，在 $t=25\\,\\text{ns}$ 时，从第3位到第0位的4位总线解析值为 \"X11X\"。", "answer": "$$\\boxed{X11X}$$", "id": "1976728"}]}