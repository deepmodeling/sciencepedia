{"hands_on_practices": [{"introduction": "控制数据通路不仅在于激活正确的操作，同样关键的在于禁止不必要的操作。“无操作”（`NOP`）指令就是这一原则的终极体现，它对流水线控制和程序调试至关重要。通过这个练习，你将通过设置一组最基础的控制信号，来确保处理器除了正常递增程序计数器外，不改变任何寄存器或内存的状态[@problem_id:1926298]。", "problem": "考虑一个简化的单周期处理器架构。处理器的控制单元生成若干信号来指导数据通路的操作。处理器的状态由其寄存器和数据存储器的内容定义。对于流水线和指令调度，一个关键要求是能够执行一条对处理器状态没有影响的指令，这被称为空操作（NOP）指令。执行NOP指令期间唯一发生的变化是程序计数器（PC）递增，以指向序列中的下一条指令。\n\n对于此处理器，我们关注主控制单元生成的四个主要控制信号：\n\n*   `RegWrite`：当置位（设为1）时，此信号允许将一个值写入寄存器文件中的目标寄存器。当复位（设为0）时，寄存器文件不被修改。\n*   `MemRead`：当置位（设为1）时，此信号允许从数据存储器进行读操作。\n*   `MemWrite`：当置位（设为1）时，此信号允许向数据存储器进行写操作。\n*   `Branch`：当置位（设为1）时，此信号表示如果满足其他条件（如算术逻辑单元比较的结果），PC可能会被更新为一个新的目标地址，从而导致潜在的控制流改变。当复位（设为0）时，PC总是更新为PC+4（假设为4字节指令），继续执行下一条顺序指令。\n\n下列哪组控制信号（`RegWrite`, `MemRead`, `MemWrite`, `Branch`）的值正确地实现了一条NOP指令？\n\nA. (0, 0, 0, 0)\n\nB. (1, 0, 0, 0)\n\nC. (0, 1, 0, 0)\n\nD. (0, 0, 1, 0)\n\nE. (0, 0, 0, 1)", "solution": "NOP指令不得改变体系结构状态（此处定义为寄存器文件和数据存储器的内容），并且必须只将程序计数器推进到下一条顺序指令。这意味着：\n- 不写入寄存器：设置 $RegWrite = 0$，以便不修改任何目标寄存器。\n- 不写入内存：设置 $MemWrite = 0$，以防止对数据存储器进行任何更改。\n- 仅顺序更新PC：为无条件保证 $PC \\leftarrow PC + 4$，必须将分支控制信号置为无效，因此 $Branch = 0$。如果 $Branch = 1$，则根据条件信号，PC可能会变为分支目标地址，这违反了在所有可能的状态下，指令除了顺序递增外没有其他效果的要求。\n- 不读取内存：设置 $MemRead = 0$。尽管在 $RegWrite = 0$ 的情况下，单纯的内存读取本身不会改变已定义的体系结构状态（寄存器和数据存储器），但置位 $MemRead$ 可能会导致意外的副作用（例如，异常或内存映射I/O），这将违反唯一的变化是 $PC \\leftarrow PC + 4$ 的要求。因此，要严格实现一个除了PC递增外没有任何效果的NOP， $MemRead$ 必须为 $0$。\n\n评估各个选项：\n- A. $(0, 0, 0, 0)$ 满足以上所有条件：不写入寄存器，不访问内存，不分支，因此只有 $PC \\leftarrow PC + 4$ 发生。\n- B. $(1, 0, 0, 0)$ 写入一个寄存器，改变了状态；不是NOP。\n- C. $(0, 1, 0, 0)$ 读取内存；为严格确保在所有状态下除了PC递增外没有其他效果，此选项被拒绝。\n- D. $(0, 0, 1, 0)$ 写入内存；不是NOP。\n- E. $(0, 0, 0, 1)$ 可能会根据条件改变控制流；不能保证是NOP。\n\n因此，实现NOP的正确控制信号设置是选项A。", "answer": "$$\\boxed{A}$$", "id": "1926298"}, {"introduction": "掌握了如何禁止操作后，下一步是学习如何编排一系列动作来执行一条完整的指令。本练习要求你将一条内存存储指令的高级描述，转化为数据通路中所有主要控制信号的精确二进制设置[@problem_id:1926288]。这是一个核心实践，它将指令集的语义与底层的硬件控制紧密联系起来。", "problem": "考虑一个为执行一组指令而设计的简化单周期处理器数据通路。该数据通路包括一个具有两个读端口和一个写端口的寄存器文件、一个主存储器单元和一个算术逻辑单元 (ALU)。数据流由几个控制信号和多路复用器管理。\n\n主要的控制信号及其功能定义如下：\n- `RegWrite` (1位): 当设置为1时，允许将结果写入寄存器文件。\n- `MemtoReg` (1位): 选择寄存器文件写端口的数据源。如果为0，源是ALU结果；如果为1，源是从内存读取的数据。\n- `MemRead` (1位): 当设置为1时，对主存储器执行读操作。\n- `MemWrite` (1位): 当设置为1时，对主存储器执行写操作。\n- `ALUSrc` (1位): 选择ALU的第二个操作数。如果为0，操作数来自寄存器文件的第二个读端口；如果为1，操作数是来自指令的符号扩展的16位立即数。\n- `Branch` (1位): 当设置为1时，为条件分支指令启用逻辑。\n- `ALUOp` (2位): 一个2位信号，`ALUOp_1` `ALUOp_0`，用于指定ALU的操作。编码为：`00` 表示按位与，`01` 表示按位或，`10` 表示加法，`11` 表示减法。\n\n指令集中增加了一条新指令 `STOR_OFFSET Rsrc, immediate(Rbase)`。该指令执行以下操作：它从寄存器 `Rsrc` 中检索值，并将其存储到内存中，地址由寄存器 `Rbase` 中的值与符号扩展的 `immediate` 值相加计算得出。该操作可描述为：`Memory[Register[Rbase] + sign_extend(immediate)] ← Register[Rsrc]`。\n\n您的任务是确定处理器正确执行 `STOR_OFFSET` 指令所需的主要控制信号的状态。请按以下特定顺序提供信号的二进制值：(`RegWrite`, `ALUSrc`, `MemtoReg`, `MemRead`, `MemWrite`, `Branch`, `ALUOp_1`, `ALUOp_0`)。", "solution": "该指令的语义由下式给出：\n$$\n\\text{Memory}\\big[\\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate})\\big] \\leftarrow \\text{Register}[R_{\\text{src}}].\n$$\n为了在单周期数据通路上实现此操作，一个周期内必须发生以下动作：\n1) 读取两个寄存器：$\\text{Register}[R_{\\text{base}}]$（用于地址计算）和 $\\text{Register}[R_{\\text{src}}]$（要存储的数据）。\n2) 使用ALU计算有效地址：\n$$\n\\text{ALU\\_result} = \\text{Register}[R_{\\text{base}}] + \\text{sign\\_extend}(\\text{immediate}).\n$$\n这需要选择符号扩展的立即数作为ALU的第二个操作数，并选择ALU操作为加法。\n3) 在计算出的地址处执行内存写入操作，写入的数据等于 $\\text{Register}[R_{\\text{src}}]$。\n4) 不将任何值写回寄存器文件，因为存储指令不产生寄存器结果。\n\n将这些要求映射到控制信号：\n- RegWrite：存储指令不执行寄存器写回操作，因此设置为 $0$。\n- ALUSrc：对于基址加偏移量寻址，ALU的第二个操作数必须是符号扩展的立即数，因此设置为 $1$。\n- MemtoReg：由于 RegWrite 为 $0$，寄存器写回数据源无关紧要；这是一个无关项。可以将其设置为 $0$ 而不影响正确性。\n- MemRead：存储指令不从内存中读取，因此设置为 $0$。\n- MemWrite：存储指令向内存中写入，因此设置为 $1$。\n- Branch：此指令不是分支指令，因此设置为 $0$。\n- ALUOp：ALU必须执行加法以计算有效地址。根据编码，加法对应于 $\\text{ALUOp} = 10$，即 $\\text{ALUOp\\_1} = 1$ 且 $\\text{ALUOp\\_0} = 0$。\n\n因此，按照指定的顺序 $(\\text{RegWrite}, \\text{ALUSrc}, \\text{MemtoReg}, \\text{MemRead}, \\text{MemWrite}, \\text{Branch}, \\text{ALUOp\\_1}, \\text{ALUOp\\_0})$，所需的控制值为：\n$$\n(0, 1, 0, 0, 1, 0, 1, 0).\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0  1  0  0  1  0  1  0\\end{pmatrix}}$$", "id": "1926288"}, {"introduction": "真实的处理器设计不仅要执行指令，还必须强制执行架构规则。本练习聚焦于一个常见的设计特性：一个只读的零寄存器（`$zero`）。你将设计一个简单但至关重要的组合逻辑电路，以防止任何写操作修改这个特殊寄存器，从而理解如何通过增加额外的控制逻辑来保护系统的完整性[@problem_id:1926285]。", "problem": "在一个简单处理器的数据通路设计中，使用了一个包含32个寄存器的寄存器堆。这些寄存器通过一个5位的地址总线进行寻址。设目标寄存器地址的五个比特位表示为 $A_4, A_3, A_2, A_1, A_0$，其中 $A_4$ 是最高有效位。寄存器0，对应于所有五个地址位均为0的地址，是一个特殊的硬件常数，其输出值恒为零且不可修改。\n\n处理器的主控制单元产生一个信号 $W_{in}$，当指令需要在寄存器堆中写入一个值时，该信号被置位（逻辑1），否则被复位（逻辑0）。然而，这个信号没有考虑到寄存器0的特殊性质。\n\n你必须设计一个组合逻辑电路，该电路以 $W_{in}$ 和地址位 $A_4, A_3, A_2, A_1, A_0$ 作为输入，并产生一个最终的写使能信号 $W_{out}$。这个 $W_{out}$ 信号将直接连接到寄存器堆的写使能输入端。该逻辑必须确保只有在原始写信号 $W_{in}$ 被置位且目标寄存器不是寄存器0时，写操作才被使能。\n\n请提供用 $W_{in}, A_4, A_3, A_2, A_1,$ 和 $A_0$ 表示的 $W_{out}$ 的布尔逻辑表达式。使用 `+` 符号表示逻辑或运算，使用并列形式表示逻辑与（例如，用 $XY$ 表示 $X$ 与 $Y$）。", "solution": "我们要求只有在传入的写控制信号被置位且目标寄存器不是寄存器0时，才进行写操作。用布尔术语来说，“目标寄存器不是寄存器0”这一条件等价于“至少有一个地址位为1”。对于地址位 $A_{4},A_{3},A_{2},A_{1},A_{0} \\in \\{0,1\\}$，“至少有一个位为1”这一谓词可以通过逻辑或 $A_{4}+A_{3}+A_{2}+A_{1}+A_{0}$ 来表示，如果地址向量不全为零，该表达式的值为 $1$，如果全为零，则值为 $0$。\n\n因此，最终的写使能信号必须在且仅在 $W_{in}=1$ 且 $(A_{4}+A_{3}+A_{2}+A_{1}+A_{0})=1$ 时被置位。使用并列表示与运算，`+` 表示或运算，所求的表达式为\n$$\nW_{out}=W_{in}\\left(A_{4}+A_{3}+A_{2}+A_{1}+A_{0}\\right).\n$$\n这确保了当目标地址为 $00000$（寄存器0）时，$W_{out}=0$，而在其他情况下 $W_{out}=W_{in}$。", "answer": "$$\\boxed{W_{in}\\left(A_{4}+A_{3}+A_{2}+A_{1}+A_{0}\\right)}$$", "id": "1926285"}]}