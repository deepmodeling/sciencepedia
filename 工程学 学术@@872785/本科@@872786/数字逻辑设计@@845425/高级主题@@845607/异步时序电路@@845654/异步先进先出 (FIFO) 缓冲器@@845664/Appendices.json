{"hands_on_practices": [{"introduction": "在异步FIFO设计中，一个核心挑战是如何安全地将写指针或读指针从一个时钟域传递到另一个时钟域。如果直接使用标准的二进制指针，多位同时翻转可能导致接收端采到灾难性的错误值。为了解决这个问题，我们使用格雷码，其特性是相邻数值之间仅有一位发生变化。本练习将帮助你掌握将二进制指针转换为格雷码的基础，这是确保跨时钟域指针同步安全的第一步。[@problem_id:1910272]", "problem": "在数字系统中，异步先进先出（FIFO）缓冲器是一个关键组件，用于在两个使用不同且无关时钟（这种情况称为跨时钟域）工作的模块之间可靠地传输数据。为了跟踪数据的写入位置和读取位置，FIFO使用称为写指针和读指针的内部计数器，这些指针用于索引缓冲器内的存储单元。\n\n异步FIFO的一个主要设计挑战是，为了同步和生成状态标志（例如，满或空信号），如何安全地将指针值从一个时钟域传递到另一个时钟域。如果指针使用标准的二进制计数器，当计数器递增时，多个位可能会同时发生变化（例如，从二进制`011`变为`100`）。如果接收时钟在这个多位转换期间对指针进行采样，可能会捕获到一个无意义的中间值，从而导致灾难性的系统故障。\n\n为防止此问题，异步FIFO中的指针几乎总是使用格雷码（Gray code）实现。格雷码是一种二进制数字系统，其中任意两个连续的数值仅有一位不同。这种单比特变化的特性确保了即使在转换期间对指针进行采样，接收到的值也将是旧值或新值，而这两者都是有效的状态。\n\n考虑一个深度为8字的异步FIFO，它需要一个3位指针来寻址其存储单元。在某一时刻，写指针的二进制值为`101`。为了将此指针值安全地传输到读时钟域，必须首先将其转换为等效的格雷码。\n\n以下哪个选项代表了二进制指针值`101`的正确3位格雷码？\n\nA. 111\n\nB. 101\n\nC. 110\n\nD. 010", "solution": "要将二进制值转换为格雷码，可使用二进制位 $b_{2}, b_{1}, b_{0}$（其中 $b_{2}$ 是最高有效位）与格雷码位 $g_{2}, g_{1}, g_{0}$ 之间的位运算关系：\n$$\ng_{2} = b_{2}, \\quad g_{1} = b_{2} \\oplus b_{1}, \\quad g_{0} = b_{1} \\oplus b_{0},\n$$\n其中 $\\oplus$ 表示异或（XOR）运算。\n\n给定二进制指针 $b_{2}b_{1}b_{0} = 101$，我们有 $b_{2} = 1$, $b_{1} = 0$, $b_{0} = 1$。计算每一位格雷码：\n$$\ng_{2} = 1, \\quad g_{1} = 1 \\oplus 0 = 1, \\quad g_{0} = 0 \\oplus 1 = 1.\n$$\n因此，3位格雷码是`111`，对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1910272"}, {"introduction": "理解了格雷码为何是异步FIFO的关键之后，下一步便是在硬件中实现它。理论必须转化为实际的电路才能发挥作用。这个练习将带你从概念走向实践，要求你设计出实现二进制到格雷码转换所需的组合逻辑电路。你会发现，只需使用几个简单的逻辑门，就能构建出保障指针传递可靠性的关键模块。[@problem_id:1910274]", "problem": "在数字系统中，异步先进先出（FIFO）缓冲器通常用于在运行于不同、非同步时钟的电路之间安全地传输数据。为了管理读写操作，FIFO使用指向其内存阵列地址的指针。当这些指针从一个时钟域传递到另一个时钟域以检查满或空条件时，如果指针值的多个位同时发生变化，就可能发生同步错误。\n\n为了缓解这个问题，指针通常使用格雷码来实现，这是一种二进制数字系统，其中两个连续值仅相差一个比特。在典型设计中，一个易于实现的标准二进制计数器会生成地址序列。然后，需要一个组合逻辑电路，在指针值用于跨域比较之前，将二进制计数器的输出转换为格雷码。\n\n考虑一个需要2位地址指针的小型异步FIFO。计数器的二进制输出表示为 $B_1 B_0$，其中 $B_1$ 是最高有效位。所需的相应2位格雷码输出表示为 $G_1 G_0$，其中 $G_1$ 是最高有效位。\n\n下列哪项表示了格雷码输出 $G_1$ 和 $G_0$ 关于二进制输入 $B_1$ 和 $B_0$ 的正确布尔表达式集合？在下面的选项中，符号 $\\oplus$ 代表异或（XOR）运算，而 $+$ 代表逻辑或（OR）运算。\n\nA) $G_1 = B_1$; $G_0 = B_1 \\oplus B_0$\n\nB) $G_1 = B_1 \\oplus B_0$; $G_0 = B_0$\n\nC) $G_1 = B_1$; $G_0 = B_1 + B_0$\n\nD) $G_1 = B_1$; $G_0 = (B_1 \\oplus B_0)'$\n\nE) $G_1 = B_1 \\oplus B_0$; $G_0 = B_1$", "solution": "我们需要寻找将2位二进制计数 $B_{1}B_{0}$ 映射到相应2位格雷码 $G_{1}G_{0}$ 的布尔表达式，其中连续的格雷码值仅相差一个比特。对于一个 $n$ 位的字 $B_{n-1}\\ldots B_{1}B_{0}$，标准的二进制到格雷码转换公式为：\n$$\nG_{n-1} = B_{n-1}, \\quad G_{i} = B_{i+1} \\oplus B_{i} \\text{ for } i = 0,1,\\ldots,n-2.\n$$\n对于2位的情况（$n=2$），代入 $i=0$ 可得：\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0}.\n$$\n为了验证此映射在二进制计数序列 $00 \\to 01 \\to 10 \\to 11$ 上能产生格雷码（单比特跳变）：\n- 对于 $B_{1}B_{0} = 00$：$G_{1} = 0$， $G_{0} = 0 \\oplus 0 = 0$，因此 $G = 00$。\n- 对于 $B_{1}B_{0} = 01$：$G_{1} = 0$， $G_{0} = 0 \\oplus 1 = 1$，因此 $G = 01$。\n- 对于 $B_{1}B_{0} = 10$：$G_{1} = 1$， $G_{0} = 1 \\oplus 0 = 1$，因此 $G = 11$。\n- 对于 $B_{1}B_{0} = 11$：$G_{1} = 1$， $G_{0} = 1 \\oplus 1 = 0$，因此 $G = 10$。\n序列 $00 \\to 01 \\to 11 \\to 10$ 在每一步仅改变一个比特，从而证实了其正确性。\n\n与选项比较，这对应于：\n$$\nG_{1} = B_{1}, \\quad G_{0} = B_{1} \\oplus B_{0},\n$$\n即选项 A。", "answer": "$$\\boxed{A}$$", "id": "1910274"}, {"introduction": "掌握了指针的编码和同步方法后，最后一步是利用这些同步后的指针来精确地控制FIFO的读写操作，以判断“满”或“空”状态。本练习模拟了一个真实的FIFO设计场景，你需要根据一种先进的指针方案来生成“满”状态标志和内部写使能信号。完成这项任务，意味着你已具备防止数据溢出和保证FIFO正常工作的综合设计能力。[@problem_id:1910302]", "problem": "您是一名初级数字逻辑设计师，任务是为异步先进先出（FIFO）缓冲器创建一部分控制逻辑。该 FIFO 的存储深度为 $D=2^N$ 个数据字。\n\n为了在不同时钟域之间正确管理缓冲区的状态并防止上溢或下溢，该 FIFO 使用 $(N+1)$ 位的二进制指针：一个写指针 `wr_ptr` 和一个读指针 `rd_ptr`。这些指针的范围从 $0$ 到 $2^{N+1}-1$。\n\n在写时钟域内，您可以使用以下信号：\n- `wr_req`：一个高电平有效信号。当 `wr_req` 为逻辑“1”时，表示有一个向 FIFO 写入数据的外部请求。\n- `wr_ptr[(N):0]`：当前的 $(N+1)$ 位写指针。\n- `rd_ptr_sync[(N):0]`：$(N+1)$ 位读指针，它已从读时钟域安全同步到写时钟域。\n\nFIFO 的状态通过比较 `wr_ptr` 和 `rd_ptr_sync` 根据以下规则来确定：\n- **满条件**：当指针的最高有效位（MSB），即第 $N$ 位，不同，而所有较低的 $N$ 位（从第 $N-1$ 位到第 $0$ 位）都相同时，FIFO 被认为是满的。\n- **空条件**：当写指针和同步后的读指针相同时（`wr_ptr == rd_ptr_sync`），FIFO 被认为是空的。\n\n您的任务是推导出内部写使能信号 `wr_en` 的逻辑。`wr_en` 应被置位（逻辑“1”）当且仅当有外部写请求（`wr_req` 为“1”）并且 FIFO 未满。\n\n请用 `wr_req` 以及指针 `wr_ptr` 和 `rd_ptr_sync` 的各个位来推导 `wr_en` 的简化布尔表达式。", "solution": "设 $\\mathrm{wr\\_ptr}_{i}$ 和 $\\mathrm{rd\\_ptr\\_sync}_{i}$ 分别表示写指针和同步后读指针的第 $i$ 位，其中 $i \\in \\{0,1,\\ldots,N\\}$ 且 $i=N$ 是最高有效位。根据所述规则：\n- 满条件：\n$$\n\\text{FULL}=\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\land \\bigwedge_{i=0}^{N-1}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n- 空条件：\n$$\n\\text{EMPTY}=\\bigwedge_{i=0}^{N}\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n内部写使能必须在有外部写请求且 FIFO 未满时置位，因此\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land \\lnot(\\text{FULL}).\n$$\n对 $\\lnot(\\text{FULL})$ 应用德摩根定律得到\n$$\n\\lnot(\\text{FULL})=\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right).\n$$\n因此，\n$$\n\\mathrm{wr\\_en}=\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right).\n$$\n该表达式表明，当有写请求，并且最高有效位（MSB）相等，或者至少有一个较低的 $N$ 位不同时，写操作被使能，这正是满条件的否定。", "answer": "$$\\boxed{\\mathrm{wr\\_req}\\land\\left(\\lnot\\!\\left(\\mathrm{wr\\_ptr}_{N} \\oplus \\mathrm{rd\\_ptr\\_sync}_{N}\\right)\\lor \\bigvee_{i=0}^{N-1}\\left(\\mathrm{wr\\_ptr}_{i} \\oplus \\mathrm{rd\\_ptr\\_sync}_{i}\\right)\\right)}$$", "id": "1910302"}]}