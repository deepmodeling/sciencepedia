{"hands_on_practices": [{"introduction": "任何数字协议的行为都可以被形式化地描述为一个有限状态机（FSM）。本练习提供了一个动手实践的机会，将一个四相握手协议的规则从描述性的状态图转换为精确的状态表，这是数字电路设计中的一个基本步骤。掌握这种转换是实现和验证异步逻辑的关键。[@problem_id:1910555]", "problem": "在一个异步数据传输系统中，接收单元必须使用握手协议与发送方进行协调。考虑一个实现四相（也称为返回零或 RTZ）握手协议的简单接收器。接收器的行为由来自发送方的单个输入信号 `Req`（请求）控制，并向发送方产生单个输出信号 `Ack`（确认）。\n\n这个接收器时序电路的行为可以用一个包含两个状态的状态图来描述：`S0`（空闲）和 `S1`（数据锁存）。系统的初始状态是 `S0`。状态转换和输出定义如下：\n\n1.  在状态 `S0` 中，`Ack` 信号保持低电平（逻辑 0）。只要 `Req` 是低电平（逻辑 0），接收器就保持在 `S0` 状态。\n2.  当 `Req` 信号变为高电平（逻辑 1）时，接收器从状态 `S0` 转换到状态 `S1`。\n3.  进入状态 `S1` 后，`Ack` 信号被驱动为高电平（逻辑 1）。只要 `Req` 是高电平，接收器就保持在 `S1` 状态。\n4.  当 `Req` 信号返回低电平（逻辑 0）时，接收器从状态 `S1` 转换回状态 `S0`，完成握手周期。\n\n你的任务是为这个 Moore 型有限状态机创建相应的状态表。状态表系统地列出了当前状态和输入的每种可能组合的下一个状态和输出。\n\n下列哪个选项正确表示了所述四相握手接收器的状态表？\n\n**A.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      1       |\n|      `S0`     |      1      |    `S1`    |      1       |\n|      `S1`     |      0      |    `S0`    |      0       |\n|      `S1`     |      1      |    `S1`    |      0       |\n\n**B.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S1`    |      0       |\n|      `S1`     |      0      |    `S0`    |      1       |\n|      `S1`     |      1      |    `S1`    |      1       |\n\n**C.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S1`    |      0       |\n|      `S0`     |      1      |    `S0`    |      0       |\n|      `S1`     |      0      |    `S1`    |      1       |\n|      `S1`     |      1      |    `S0`    |      1       |\n\n**D.**\n| 当前状态 | 输入 `Req` | 下一状态 | 输出 `Ack` |\n|:-------------:|:-----------:|:----------:|:------------:|\n|      `S0`     |      0      |    `S0`    |      0       |\n|      `S0`     |      1      |    `S0`    |      1       |\n|      `S1`     |      0      |    `S1`    |      0       |\n|      `S1`     |      1      |    `S1`    |      1       |", "solution": "Moore 型有限状态机的输出仅由当前状态决定。根据描述：在状态 $S0$ 中，输出 $Ack$ 保持低电平；在状态 $S1$ 中，输出 $Ack$ 保持高电平。因此，\n$$Ack(S0)=0,\\quad Ack(S1)=1.$$\n状态转换由输入 $Req$ 控制，如下所示：当 $Req=0$ 时保持在 $S0$ 状态，当 $Req=1$ 时转换到 $S1$ 状态；当 $Req=1$ 时保持在 $S1$ 状态，当 $Req=0$ 时转换到 $S0$ 状态。因此，下一状态函数满足\n$$\\text{Next}(S0,Req=0)=S0,\\quad \\text{Next}(S0,Req=1)=S1,$$\n$$\\text{Next}(S1,Req=1)=S1,\\quad \\text{Next}(S1,Req=0)=S0.$$\n将这些与 Moore 型输出结合起来，得到所需的四行：\n- 当前状态 $S0$，输入 $Req=0$：下一状态 $S0$，输出 $Ack=0$。\n- 当前状态 $S0$，输入 $Req=1$：下一状态 $S1$，输出 $Ack=0$。\n- 当前状态 $S1$，输入 $Req=0$：下一状态 $S0$，输出 $Ack=1$。\n- 当前状态 $S1$，输入 $Req=1$：下一状态 $S1$，输出 $Ack=1$。\n与提供的选项进行比较，只有选项 B 完全匹配这些下一状态和输出关系。", "answer": "$$\\boxed{B}$$", "id": "1910555"}, {"introduction": "除了逻辑事件序列，异步握手协议的性能还取决于现实世界中的物理延迟。本问题让您通过计算逻辑延迟和传播延迟，来计算四相协议完成一次完整传输所需的总时间。这种分析对于理解片上系统（SoC）中异步接口的吞吐量限制至关重要。[@problem_id:1910561]", "problem": "在一个现代片上系统 (SoC) 的设计中，一个中央处理器 (CPU) 与一个专门的神经处理单元 (NPU) 通信，以分担机器学习的计算任务。它们之间的通信链路使用一种异步四相握手协议，由两个信号控制：`VALID`，由 CPU（发送方）置位，表示数据可用；以及 `READY`，由 NPU（接收方）置位，以确认数据已被读取。\n\n一个完整的事务周期由四个不同的信号转换组成：\n1. CPU 将 `VALID` 置为高电平。\n2. NPU 响应，将 `READY` 置为高电平。\n3. CPU 看到 `READY` 为高电平，便将 `VALID` 复位为低电平。\n4. NPU 看到 `VALID` 为低电平，便将 `READY` 复位为低电平，使系统返回初始状态。\n\n该链路的时序特性由以下延迟决定：\n- 发送方逻辑延迟 (`t_sl`)：CPU 逻辑处理输入变化并置位或复位 `VALID` 信号所需的时间为 120 ps。\n- 接收方逻辑延迟 (`t_rl`)：NPU 逻辑处理输入变化并置位或复位 `READY` 信号所需的时间为 150 ps。\n- 互连传播延迟 (`t_wire`)：`VALID` 或 `READY` 线路上的信号变化沿导线从 CPU 传播到 NPU（或反之）所需的时间为 80 ps。\n\n计算完成一个完整数据事务所需要的最小总时间。该时间从 CPU 发起传输（开始置位 `VALID` 信号的过程）的时刻开始测量，直到系统完全复位到初始状态并准备好开始下一个事务为止。以纳秒 (ns) 为单位表示你的最终答案，并四舍五入到两位有效数字。", "solution": "我们将四相握手协议建模为一系列因果相关的事件，每个事件都会在驱动端产生逻辑延迟，并通过互连进行传播。设 $t_{sl}$ 为发送方 (CPU) 的逻辑延迟，$t_{rl}$ 为接收方 (NPU) 的逻辑延迟，$t_{\\text{wire}}$ 为互连传播延迟。总事务时间从 CPU 开始置位 $VALID$ 时算起，直到 CPU 观察到 $READY$ 被复位且两个信号都回到低电平为止。\n\n分步时序分析：\n1) CPU 置位 $VALID$：CPU 逻辑延迟 $t_{sl}$，然后 $VALID$ 信号边沿在 $t_{\\text{wire}}$ 时间内传播到 NPU。\n步骤1后的累计时间：$t_{sl} + t_{\\text{wire}}$。\n\n2) NPU 置位 $READY$：NPU 逻辑延迟 $t_{rl}$，然后 $READY$ 信号边沿在 $t_{\\text{wire}}$ 时间内传播到 CPU。\n步骤2的额外时间：$t_{rl} + t_{\\text{wire}}$。\n步骤2后的累计时间：$t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}}$。\n\n3) CPU 复位 $VALID$：在 CPU 端看到 $READY$ 变为高电平后，CPU 经过逻辑延迟 $t_{sl}$ 将 $VALID$ 驱动为低电平，然后 $VALID$ 低电平信号在 $t_{\\text{wire}}$ 时间内传播到 NPU。\n步骤3的额外时间：$t_{sl} + t_{\\text{wire}}$。\n步骤3后的累计时间：$t_{sl} + t_{\\text{wire}} + t_{rl} + t_{\\text{wire}} + t_{sl} + t_{\\text{wire}}$。\n\n4) NPU 复位 $READY$：在 NPU 端看到 $VALID$ 变为低电平后，NPU 经过逻辑延迟 $t_{rl}$ 将 $READY$ 驱动为低电平，然后 $READY$ 低电平信号在 $t_{\\text{wire}}$ 时间内传播到 CPU（确保发起方看到握手完成，系统已准备好进行下一个事务）。\n步骤4的额外时间：$t_{rl} + t_{\\text{wire}}$。\n\n因此，最小总时间为\n$$\nT_{\\text{min}} \\;=\\; 2\\,t_{sl} \\;+\\; 2\\,t_{rl} \\;+\\; 4\\,t_{\\text{wire}}.\n$$\n\n代入给定值（单位为皮秒），然后转换为纳秒：\n$$\nT_{\\text{min}} \\;=\\; 2\\cdot 120 \\;+\\; 2\\cdot 150 \\;+\\; 4\\cdot 80 \\;=\\; 240 \\;+\\; 300 \\;+\\; 320 \\;=\\; 860 \\text{ ps} \\;=\\; 0.86 \\text{ ns}.\n$$\n四舍五入到两位有效数字，结果是 $0.86$ ns。", "answer": "$$\\boxed{0.86}$$", "id": "1910561"}, {"introduction": "一个稳健的协议必须能够处理意外情况，例如硬件故障。本实践提出了一个思想实验，其中一个控制信号被卡住，要求您追踪协议在故障条件下的行为。分析此类情景对于设计可靠的系统和理解死锁等故障模式至关重要。[@problem_id:1910529]", "problem": "一个异步数据传输系统使用四相握手协议来协调发送方和接收方之间的通信。该协议通过来自发送方的请求（`Req`）信号和来自接收方的确认（`Ack`）信号进行操作。初始状态下，`Req` 和 `Ack` 均为逻辑低电平（0）。\n\n一次数据传输的标准操作序列如下：\n1. 发送方将数据放置在数据总线上，然后通过将 `Req` 设置为逻辑高电平（1）来断言 `Req`。\n2. 接收方检测到 `Req` 为高电平，从总线读取数据，然后通过将 `Ack` 设置为逻辑高电平（1）来断言 `Ack`。\n3. 发送方检测到 `Ack` 为高电平，并通过将 `Req` 设置为逻辑低电平（0）来撤销 `Req`。\n4. 接收方检测到 `Req` 为低电平，并通过将 `Ack` 设置为逻辑低电平（0）来撤销 `Ack`，使系统返回初始状态，为下一次传输做好准备。\n\n现在，考虑一个故障场景。系统从 `Req` = 0 和 `Ack` = 0 的初始状态开始。发送方通过正确执行步骤1来启动一次传输。然而，在 `Req` 信号变为高电平后，立即发生了一个“固定为1”（stuck-at-1）的故障，这使得 `Req` 信号永久地保持在逻辑高电平，无论发送方如何尝试改变它。\n\n假设接收方功能正常，并根据协议规则进行响应，那么 `Req` 和 `Ack` 信号的最终稳定逻辑电平将是什么？\n\nA. `Req` = 0, `Ack` = 0\nB. `Req` = 0, `Ack` = 1\nC. `Req` = 1, `Ack` = 0\nD. `Req` = 1, `Ack` = 1\nE. 信号将振荡，永远不会达到稳定状态。", "solution": "我们将根据四相握手协议的规则并考虑指定的故障，一步一步地追踪 `Req` 和 `Ack` 信号的状态。系统的状态可以用序对 (`Req`, `Ack`) 来表示。\n\n**初始状态：**\n系统从没有传输进行的静默状态开始。根据问题描述，`Req` = 0 且 `Ack` = 0。\n状态：(`Req`, `Ack`) = (0, 0)。\n\n**协议步骤1：**\n发送方启动一次传输。它将数据放置在总线上并断言其请求信号。`Req` 从 0 变为 1。\n状态变为：(`Req`, `Ack`) = (1, 0)。\n就在此时，`Req` 线上发生了“固定为1”的故障。这意味着在接下来的过程中，`Req` 信号将永久固定在逻辑高电平（1）。\n\n**协议步骤2：**\n功能正常的接收方检测到 `Req` 为高电平（1）。根据协议，它通过读取数据然后断言其确认信号来响应。`Ack` 从 0 变为 1。\n状态变为：(`Req`, `Ack`) = (1, 1)。\n\n**协议步骤3：**\n发送方的内部逻辑工作正常，它检测到 `Ack` 为高电平（1）。根据协议，它现在应该撤销其请求信号。发送方的逻辑试图将 `Req` 线驱动至逻辑低电平（0）。然而，由于线路上存在固定为1的故障，该信号保持高电平。\n状态保持为：(`Req`, `Ack`) = (1, 1)。\n\n**协议步骤4：**\n接收方现在等待协议规定的下一个事件。协议的步骤4规定：“接收方检测到 `Req` 为低电平并撤销 `Ack`”。由于 `Req` 信号固定在 1，接收方撤销 `Ack` 的条件（即 `Req` = 0）永远不会被满足。因此，接收方将继续将 `Ack` 保持在逻辑高电平（1），无限期地等待 `Req` 变为低电平。\n\n**结论：**\n发送方在开始新周期前等待 `Ack` 变为低电平（尽管它已经卡在步骤3），而接收方在降低 `Ack` 前等待 `Req` 变为低电平。两个条件都无法满足。系统陷入了死锁状态。信号停止变化，并保持在两者都被断言的状态。\n\n因此，最终的稳定逻辑电平是 `Req` = 1 和 `Ack` = 1。这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1910529"}]}