{"hands_on_practices": [{"introduction": "数字乘法的基础是“移位与相加”法，其硬件实现的核心在于生成部分积。这个练习将带你量化实现一个基本无符号乘法器所需的最基础的逻辑资源，帮助你理解乘法操作在门级电路上的成本。通过计算构建部分积生成阶段所需的与门数量 [@problem_id:1914114]，你将对硬件乘法器的规模有一个直观的认识。", "problem": "一个数字逻辑设计团队正在为实时数字信号处理（DSP）应用创建一个专用协处理器。该协处理器的一个关键组件是专用的硬件乘法器，设计用于执行两个无符号二进制数的乘法运算。该架构规定第一个操作数（被乘数）是一个7位数，第二个操作数（乘数）是一个5位数。\n\n乘法过程采用标准的阵列乘法器方法实现。在此过程的第一阶段，会生成一组部分积。每个部分积由乘数的一位与被乘数的所有位进行逻辑与运算形成。然后，这些部分积在后续阶段被送入一个加法器阵列。\n\n假设用于生成这些部分积的硬件完全由双输入与门构成，计算此部分积生成阶段所需的双输入与门的总数。", "solution": "设被乘数有 $m$ 位，乘数有 $n$ 位。对于一个标准的阵列乘法器，部分积位是通过将被乘数的每一位与乘数的每一位进行与运算来生成的。如果 $a_{i}$ 表示被乘数的第 $i$ 位（其中 $i \\in \\{0,\\dots,m-1\\}$），$b_{j}$ 表示乘数的第 $j$ 位（其中 $j \\in \\{0,\\dots,n-1\\}$），那么每个部分积位是\n$$\np_{i,j} = a_{i} \\land b_{j},\n$$\n这由一个双输入与门实现。\n\n因此，所需的双输入与门的总数等于此类 $(i,j)$ 对的总数，也就是 $m$ 个被乘数位和 $n$ 个乘数位的笛卡尔积的大小：\n$$\n\\sum_{j=0}^{n-1}\\sum_{i=0}^{m-1} 1 = m \\times n.\n$$\n代入 $m=7$ 和 $n=5$ 得\n$$\n7 \\times 5 = 35.\n$$\n因此，部分积生成阶段需要 $35$ 个双输入与门。", "answer": "$$\\boxed{35}$$", "id": "1914114"}, {"introduction": "为了提高乘法效率，特别是对于有符号数，工程师们设计了布斯算法（Booth's algorithm）。该算法通过巧妙地处理乘数中的连续比特来减少所需的加法和减法操作次数。本练习 [@problem_id:1914183] 挑战你找到一个能让布斯算法操作次数最少的乘数值，这会促使你深入思考该算法高效背后的核心原理。", "problem": "在数字系统中，布斯（Booth）算法是一种乘法算法，用于将两个以二进制补码表示的有符号二进制数相乘。其效率源于它能够处理乘数中连续的“1”，与标准的“加法和移位”方法相比，通常能减少所需的加法和减法操作次数。该算法从右到左、一次一对地检查乘数位。\n\n考虑两个有符号4位整数的乘法 $P = M \\times R$，其中 $M$ 是被乘数，$R$ 是乘数。Booth算法执行的加法和减法操作次数完全由乘数 $R$ 的位模式决定。\n\n您的任务是为乘数 $R$ 找到一个非零的4位二进制值，使得加法和减法操作的总次数最少。如果存在多个这样的4位 $R$ 值，请选择表示的有符号十进制整数的绝对值最小（即最接近零）的那个。请提供这个4位二进制值作为您的答案。", "solution": "设4位二进制补码乘数为 $R = Q_{3}Q_{2}Q_{1}Q_{0}$，并根据Booth算法在其右侧附加一个额外的位 $Q_{-1}=0$。在每一步 $i \\in \\{0,1,2,3\\}$ 中，算法检查位对 $(Q_{i},Q_{i-1})$ 并：\n- 如果 $(Q_{i},Q_{i-1})=(0,1)$，则执行一次加法，\n- 如果 $(Q_{i},Q_{i-1})=(1,0)$，则执行一次减法，\n- 如果 $(Q_{i},Q_{i-1})=(0,0)$ 或 $(1,1)$，则不执行任何操作。\n\n因此，加法和减法的总次数恰好是扩展序列 $Q_{-1},Q_{0},Q_{1},Q_{2},Q_{3}$ 中相邻位之间发生变化的次数。等价地，\n$$\nN_{\\text{ops}}=\\sum_{i=0}^{3} \\mathbf{1}\\{Q_{i}\\neq Q_{i-1}\\},\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n\n对于一个非零的 $R$，$N_{\\text{ops}}$ 的最小可能值为 $1$。确实如此：\n- 如果 $R=0000$，则 $N_{\\text{ops}}=0$，但这被非零约束所排除。\n- 如果 $R\\neq 0000$，令 $k$ 为使 $Q_{k}=1$ 的最小索引。由于根据 $k$ 的最小性，有 $Q_{-1}=0$ 和 $Q_{0},\\ldots,Q_{k-1}=0$，因此位对 $(Q_{k},Q_{k-1})=(1,0)$ 至少贡献了一次操作，所以 $N_{\\text{ops}} \\geq 1$。\n- 为了实现 $N_{\\text{ops}}=1$，必须没有更多的变化，这要求对于所有 $j \\geq k$ 都有 $Q_{j}=1$。因此，$R$ 必须具有从零（最低有效位侧）到一（最高有效位侧）的单次变化的形式。\n\n对于4位，能使 $N_{\\text{ops}}=1$ 的确切 $R$ 值为\n$$\nR \\in \\{1000,\\,1100,\\,1110,\\,1111\\}。\n$$\n在4位二进制补码中，它们分别表示：\n$$\n1000=-8,\\quad 1100=-4,\\quad 1110=-2,\\quad 1111=-1。\n$$\n在这些值中，最小的绝对值是 $|-1|=1$，对应于 $R=1111$。\n\n因此，使加/减法次数最少，并且在并列情况下绝对值最小的非零4位乘数是 $1111$。", "answer": "$$\\boxed{1111}$$", "id": "1914183"}, {"introduction": "理论上完美的逻辑电路在物理世界中可能会出现故障，“卡-0”（stuck-at-0）或“卡-1”（stuck-at-1）是常见的故障模型。这个练习将理论与实践相结合，要求你分析在一个硬件与门发生“卡-0”故障的特定场景下，哪些输入组合仍然能得到正确结果。通过这个过程 [@problem_id:1914169]，你将更深刻地理解每个部分积在最终结果计算中的具体作用。", "problem": "一个标准的 $2 \\times 2$ 无符号二进制阵列乘法器被设计用来计算乘积 $P = A \\times B$。输入是两个2位无符号数，$A$ 由位 $a_1a_0$ 表示（其值为 $2a_1 + a_0$），$B$ 由位 $b_1b_0$ 表示（其值为 $2b_1 + b_0$）。乘积是一个4位数 $P = p_3p_2p_1p_0$。这个乘法的逻辑可以表示为部分积的加权和：$A \\times B = (a_1b_1) \\cdot 2^2 + (a_1b_0 + a_0b_1) \\cdot 2^1 + (a_0b_0) \\cdot 2^0$。在物理电路中，每一项 $a_i b_j$ 都由一个与门生成。\n\n在制造后测试期间，发现其中一个与门存在“固定为0”的故障。具体来说，本应计算部分积项 $a_0b_1$ 的那个门，无论其输入 $a_0$ 和 $b_1$ 的实际值如何，总是输出0。\n\n从下面的输入对 $(A, B)$ 列表中，找出所有使得这个有故障的乘法器仍然能产生正确的最终乘积的数对。请注意，所有输入均以十进制表示法给出，并且您只应考虑 $A$ 和 $B$ 均不为零的数对。\n\nA. $A=2, B=3$\nB. $A=3, B=2$\nC. $A=1, B=2$\nD. $A=3, B=1$\nE. $A=3, B=3$", "solution": "设 $A=2a_{1}+a_{0}$ 且 $B=2b_{1}+b_{0}$，其中 $a_{i},b_{j}\\in\\{0,1\\}$。正确的乘积为\n$$\nP_{\\text{true}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+a_{0}b_{1})\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\n当计算 $a_{0}b_{1}$ 的与门存在固定为0的故障时，实际实现的乘积为\n$$\nP_{\\text{faulty}}=(a_{1}b_{1})\\cdot 2^{2}+(a_{1}b_{0}+0)\\cdot 2^{1}+(a_{0}b_{0})\\cdot 2^{0}.\n$$\n因此误差为\n$$\nP_{\\text{true}}-P_{\\text{faulty}}=(a_{0}b_{1})\\cdot 2^{1}.\n$$\n因此，有故障的乘法器能产生正确乘积的充要条件是 $a_{0}b_{1}=0$。\n\n将每个十进制输入编码为位：\n- $1\\equiv 01$ 所以 $(a_{1},a_{0})=(0,1)$ 或 $(b_{1},b_{0})=(0,1)$。\n- $2\\equiv 10$ 所以 $(a_{1},a_{0})=(1,0)$ 或 $(b_{1},b_{0})=(1,0)$。\n- $3\\equiv 11$ 所以 $(a_{1},a_{0})=(1,1)$ 或 $(b_{1},b_{0})=(1,1)$。\n\n通过计算 $a_{0}b_{1}$ 来检查每个选项：\n- A: $A=2\\Rightarrow a_{0}=0$, $B=3\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=0$；正确。\n- B: $A=3\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；错误。\n- C: $A=1\\Rightarrow a_{0}=1$, $B=2\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；错误。\n- D: $A=3\\Rightarrow a_{0}=1$, $B=1\\Rightarrow b_{1}=0$，所以 $a_{0}b_{1}=0$；正确。\n- E: $A=3\\Rightarrow a_{0}=1$, $B=3\\Rightarrow b_{1}=1$，所以 $a_{0}b_{1}=1$；错误。\n\n因此，正确的选项是A和D。", "answer": "$$\\boxed{AD}$$", "id": "1914169"}]}