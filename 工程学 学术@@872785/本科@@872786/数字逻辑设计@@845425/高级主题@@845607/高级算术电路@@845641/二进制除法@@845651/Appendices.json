{"hands_on_practices": [{"introduction": "理论知识是基础，但真正掌握二进制除法算法需要在实践中加深理解。恢复余数法（Restoring Division Algorithm）是一种直观的硬件除法实现，其逻辑类似于我们手动进行长除法。此练习将引导你完整地追踪一个简单的除法过程，通过逐步记录累加器（$A$）和商寄存器（$Q$）在每个周期的变化，你将亲身体验“移位-减法-恢复”这一核心操作，从而牢固掌握该算法的运作机制 [@problem_id:1913872]。", "problem": "一个数字电路被设计用于使用恢复除法算法执行无符号二进制除法。该电路使用一个累加器寄存器 (A)、一个商寄存器 (Q) 和一个除数寄存器 (M)。被除数（也就是 Q 寄存器）的位数为 $n=4$。A 和 M 寄存器的大小为 $n+1=5$ 位，以容纳符号位并防止中间计算过程中的溢出。\n\n该电路的任务是用除数 $11_2$ 去除被除数 $1001_2$。初始时，A 寄存器被清零为 $00000_2$，Q 寄存器存放被除数 $1001_2$，M 寄存器存放除数，填充至5位为 $00011_2$。\n\n除法过程进行 $n=4$ 个周期。每个周期包括以下步骤：\n1. 连接的寄存器对 `AQ` 左移一位。从 Q 的最高有效位 (MSB) 移出的位移入 A 的最低有效位 (LSB)。\n2. 从 A 中减去 M 的值 ($A \\leftarrow A - M$)。所有算术运算都使用二进制补码表示法进行。\n3. 检查 A 的 MSB。\n    - 如果 A 的 MSB 为 1（表示结果为负），则 Q 的 LSB 设置为 0，并通过将 M 加回到 A 来恢复 A 的值 ($A \\leftarrow A + M$)。\n    - 如果 A 的 MSB 为 0（表示结果为正或零），则 Q 的 LSB 设置为 1，且 A 的值不改变。\n\n以下哪个选项正确列出了从周期1到周期4，每个周期结束时累加器 (A) 寄存器中保存的5位二进制值序列？\n\nA. $00001_2, 00010_2, 00001_2, 00000_2$\n\nB. $11110_2, 11111_2, 00001_2, 00000_2$\n\nC. $00001_2, 00010_2, 00010_2, 00001_2$\n\nD. $00001_2, 00001_2, 00010_2, 00000_2$", "solution": "我们使用恢复除法算法，寄存器包括：$A$（5位）、$Q$（4位）和 $M$（5位）。初始化 $A=00000_{2}$，$Q=1001_{2}$，$M=00011_{2}$。每个周期执行：连接的 $AQ$ 左移，然后使用5位二进制补码运算执行 $A \\leftarrow A - M$，如果 $A$ 为负（MSB $=1$），则将 $Q$ 的 LSB 设置为 $0$ 并恢复 $A \\leftarrow A+M$；否则将 $Q$ 的 LSB 设置为 $1$ 并保持 $A$ 不变。\n\n周期1：左移 $AQ$。$Q$ 的 MSB 是 $1$，所以移位后 $A=00001_{2}$，$Q=0010_{2}$。减去 $M$：计算 $M=00011_{2}$ 的5位二进制补码为 $11101_{2}$，因此\n$$\nA \\leftarrow 00001_{2} + 11101_{2} = 11110_{2}.\n$$\nMSB为 $1$（负数），所以将 $Q$ 的 LSB 设置为 $0$ 并恢复\n$$\nA \\leftarrow 11110_{2} + 00011_{2} = 00001_{2}.\n$$\n周期1结束：$A=00001_{2}$。\n\n周期2：左移 $AQ$。$Q$ 的 MSB 是 $0$，所以 $A=00010_{2}$，$Q=0100_{2}$。减去 $M$：\n$$\nA \\leftarrow 00010_{2} + 11101_{2} = 11111_{2}.\n$$\n结果为负，所以将 $Q$ 的 LSB 设置为 $0$ 并恢复\n$$\nA \\leftarrow 11111_{2} + 00011_{2} = 00010_{2}.\n$$\n周期2结束：$A=00010_{2}$。\n\n周期3：左移 $AQ$。$Q$ 的 MSB 是 $0$，所以 $A=00100_{2}$，$Q=1000_{2}$。减去 $M$：\n$$\nA \\leftarrow 00100_{2} + 11101_{2} = 00001_{2}.\n$$\n结果非负，所以将 $Q$ 的 LSB 设置为 $1$ 并保持 $A$ 不变。周期3结束：$A=00001_{2}$。\n\n周期4：左移 $AQ$。$Q$ 的 MSB 是 $1$，所以 $A=00011_{2}$，$Q=0010_{2}$。减去 $M$：\n$$\nA \\leftarrow 00011_{2} - 00011_{2} = 00000_{2}.\n$$\n结果非负，所以将 $Q$ 的 LSB 设置为 $1$ 并保持 $A$ 不变。周期4结束：$A=00000_{2}$。\n\n因此，在周期1到周期4结束时，累加器 $A$ 的值分别为 $00001_{2}, 00010_{2}, 00001_{2}, 00000_{2}$，这对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1913872"}, {"introduction": "在掌握了恢复余数法之后，让我们来探索一种更高效的实现：不恢复余数法（Non-Restoring Division Algorithm）。该算法通过省去“恢复”这一步来提升运算速度，当减法结果为负时，它并不加回除数，而是在下一个周期通过补偿性的加法来修正结果。通过完成这个练习 [@problem_id:1913819]，你将追踪不恢复余数法的完整流程，并将其与恢复余数法进行对比，从而理解两种算法在逻辑和效率上的关键差异。", "problem": "考虑将4位无符号二进制数 $D = 1011_2$（被除数）除以无符号二进制数 $V = 11_2$（除数）。此除法将使用不恢复余数除法算法来执行。\n\n硬件设置包括一个累加器寄存器 'A'、一个商寄存器 'Q' 和一个除数寄存器 'M'。在此操作中，累加器 A 和除数 M 使用5位表示。被除数 D 最初被加载到4位寄存器 Q 中。累加器 A 初始化为全零。\n\n该算法执行的周期数等于被除数的位数。使用标准的无符号整数不恢复余数算法，该算法涉及根据累加器的符号进行条件加法或减法，然后设置新的商位。\n\n确定在四个周期中的最后一个周期完成后，5位累加器寄存器 A 中包含的最终二进制值。请注意，这是在对余数执行任何可能的最终校正步骤 *之前* 的值。请以5位二进制字符串的形式提供您的答案。", "solution": "我们使用标准的不恢复余数除法算法，在5位累加器 $A$ 和5位除数寄存器 $M$ 中使用二进制补码运算。初始化 $A=00000$，$Q=1011$，$M=00011$。对于 $4$ 个周期中的每一个，执行以下操作：\n1) 将连接的 $(A,Q)$ 左移一位。\n2) 如果 $A \\ge 0$，则执行 $A \\leftarrow A - M$；如果 $A  0$，则执行 $A \\leftarrow A + M$（所有运算均在5位二进制补码下进行）。\n3) 如果 $A \\ge 0$，则将新的商位 $Q_{0}$ 设置为 $1$，否则设置为 $0$。\n\n周期 1:\n- 移位：$(A,Q): 00000\\,1011 \\to 00001\\,0110$，所以 $A=00001$，$Q=0110$。\n- 由于 $A \\ge 0$，计算 $A \\leftarrow A - M = 00001 - 00011 = 00001 + 11101 = 11110$。\n- 由于 $A0$，设置 $Q_{0}=0$，所以 $Q=0110$。\n\n周期 2:\n- 移位：$(A,Q): 11110\\,0110 \\to 11100\\,1100$，所以 $A=11100$，$Q=1100$。\n- 由于 $A  0$，计算 $A \\leftarrow A + M = 11100 + 00011 = 11111$。\n- 由于 $A0$，设置 $Q_{0}=0$，所以 $Q=1100$。\n\n周期 3:\n- 移位：$(A,Q): 11111\\,1100 \\to 11111\\,1000$，所以 $A=11111$，$Q=1000$。\n- 由于 $A  0$，计算 $A \\leftarrow A + M = 11111 + 00011 = 00010$（丢弃进位）。\n- 由于 $A \\ge 0$，设置 $Q_{0}=1$，所以 $Q=1001$。\n\n周期 4:\n- 移位：$(A,Q): 00010\\,1001 \\to 00101\\,0010$，所以 $A=00101$，$Q=0010$。\n- 由于 $A \\ge 0$，计算 $A \\leftarrow A - M = 00101 - 00011 = 00010$。\n- 由于 $A \\ge 0$，设置 $Q_{0}=1$，所以 $Q=0011$。\n\n在第四个周期后（且在任何最终校正之前），累加器为 $A=00010$。", "answer": "$$\\boxed{00010}$$", "id": "1913819"}, {"introduction": "在实际的数字电路设计或调试中，我们不仅关心最终的计算结果，更常常需要检查算法执行过程中特定时间点的寄存器状态，以确保逻辑的正确性。这个练习模拟了这样一个场景，要求你运用恢复余数法处理一组更复杂的数值，并精确确定算法在执行到第三个周期结束时的中间状态。这不仅能巩固你对算法步骤的掌握，还能培养你在复杂计算中保持条理和精确性的能力 [@problem_id:1913836]。", "problem": "一名硬件设计师正在测试一个定制微处理器中的除法单元。该单元使用恢复余数除法算法（restoring division algorithm）执行无符号二进制除法。该处理器有一个累加器寄存器 `A`、一个商寄存器 `Q` 和一个除数寄存器 `M`。对于一个 `n` 位除法，`Q` 寄存器的宽度为 `n` 位，而 `A` 和 `M` 寄存器的宽度为 `n+1` 位，以便在中间减法过程中处理符号。\n\n该算法分 `n` 个周期进行。在第一个周期之前，`A` 被初始化为全零，`Q` 装载 `n` 位的被除数，`M` 装载 `n+1` 位的除数（用前导零填充）。每个周期包括以下步骤：\n1.  级联寄存器对 `AQ` 左移一位。从 `Q` 的最高有效位移出的位进入 `A` 的最低有效位。\n2.  从 `A` 中减去 `M` 的值。此操作通过二进制补码加法完成。\n3.  检查 `A` 的最高有效位（符号位）。\n    - 如果符号位为 1（表示负结果），则 `Q` 的最低有效位被置为 0，并且通过将 `M` 加回到 `A` 来恢复 `A` 的值。\n    - 如果符号位为 0（表示非负结果），则 `Q` 的最低有效位被置为 1，`A` 的值保持不变。\n\n考虑被除数 $D = 197_{10}$ 除以除数 $d = 13_{10}$ 的无符号除法。确定在算法的*第三个*周期完成时，累加器寄存器 `A` 和商寄存器 `Q` 的二进制内容。\n\n从以下选项中选择正确的 `(A, Q)` 值对。\n\nA. `A = 000000110`, `Q = 00101000`\n\nB. `A = 000000011`, `Q = 00010100`\n\nC. `A = 111111001`, `Q = 00101000`\n\nD. `A = 000010011`, `Q = 00101001`\n\nE. `A = 000001100`, `Q = 01010000`", "solution": "我们执行无符号恢复余数除法，其中 `Q` 为 $n=8$ 位，`A` 和 `M` 为 $(n+1)=9$ 位。转换操作数：\n- 被除数：$D=197_{10}=11000101_{2}$，所以初始时 $Q=11000101$（8位）。\n- 除数：$d=13_{10}=1101_{2}$。对于 `M` 进行9位填充后：$M=000001101$。\n- 初始化 $A=000000000$（9位）。\n\n每个周期：将级联的 `AQ` 左移一位（即 $A \\leftarrow (A \\ll 1)$，`Q` 先前的最高有效位进入 `A` 的最低有效位，且 $Q \\leftarrow (Q \\ll 1)$），然后使用二进制补码计算 $A \\leftarrow A - M$。如果结果为负（`A` 的最高有效位为 `1`），则置 $Q_{0}=0$ 并恢复 $A \\leftarrow A + M$。如果为非负，则置 $Q_{0}=1$ 并保持 `A` 不变。\n\n预先计算 `M` 的二进制补码（9位）为 $-M = \\overline{M} + 1 = 111110011$。\n\n周期 1：\n- `AQ` 左移：\n  $A: 000000000 \\to 000000001$（将 `Q` 先前的最高有效位 `1` 插入 `A` 的最低有效位），\n  $Q: 11000101 \\to 10001010$。\n- 减法：$A \\leftarrow A - M = 000000001 + 111110011 = 111110100$（负数）。\n- 结果为负，所以 $Q_{0}=0$（已经是 `0`）并恢复 `A`：$A \\leftarrow 111110100 + 000001101 = 000000001$。\n- 周期 1 结束：$A=000000001$, $Q=10001010$。\n\n周期 2：\n- `AQ` 左移：\n  $A: 000000001 \\to 000000011$（插入 `Q` 先前的最高有效位 `1`），\n  $Q: 10001010 \\to 00010100$。\n- 减法：$A \\leftarrow A - M = 000000011 + 111110011 = 111110110$（负数）。\n- 结果为负，所以 $Q_{0}=0$ 并恢复 `A`：$A \\leftarrow 111110110 + 000001101 = 000000011$。\n- 周期 2 结束：$A=000000011$, $Q=00010100$。\n\n周期 3：\n- `AQ` 左移：\n  $A: 000000011 \\to 000000110$（插入 `Q` 先前的最高有效位 `0`），\n  $Q: 00010100 \\to 00101000$。\n- 减法：$A \\leftarrow A - M = 000000110 + 111110011 = 111111001$（负数）。\n- 结果为负，所以 $Q_{0}=0$ 并恢复 `A`：$A \\leftarrow 111111001 + 000001101 = 000000110$。\n- 周期 3 结束：$A=000000110$, $Q=00101000$。\n\n因此，在第三个周期完成时，寄存器的值为 $(A,Q) = (000000110,\\ 00101000)$，与选项 A 匹配。", "answer": "$$\\boxed{A}$$", "id": "1913836"}]}