{"hands_on_practices": [{"introduction": "理解浮点数的第一步是掌握如何将其二进制表示解码为我们熟悉的十进制数值。这个练习[@problem_id:1937520]将指导你分解一个给定的10位浮点数，通过解析其符号、指数和尾数部分，并应用指定的偏置量，来精确计算出它所代表的数值。通过这个过程，你将对浮点数的内部结构建立起直观的认识。", "problem": "一位工程师正在为环境传感器设计一款低功耗微控制器。为了节省内存，该微控制器使用自定义的10位浮点数格式来表示传感器读数。该格式定义如下：\n\n- **符号 (S)**：1位（0代表正数，1代表负数）\n- **指数 (E)**：5位，使用15的指数偏移量。\n- **小数部分 (F)**：4位\n\n位从高到低按S、E、F的顺序排列。规格化数的值由公式 $V = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E-15)}$ 给出，其中 $(1.F)_{2}$ 是带有隐含前导1的尾数。指数全为零（非规格化数/零）或全为一（无穷大/NaN）的特殊情况不适用于此问题。\n\n假设微控制器的内存中包含10位二进制值 `1100101100`。确定此浮点数表示的十进制值。将您的答案表示为十进制数，必要时四舍五入到四位有效数字。", "solution": "10位的字是 1100101100，按 $S|E|F$ 排列，其中S是第一位，E是接下来的五位，F是最后的四位。因此，$S=1$，$E=10010_{2}$，且 $F=1100_{2}$。由于E既不全为零也不全为一，该数为规格化数，我们使用公式\n$$\nV = (-1)^{S}\\,(1.F)_{2}\\,2^{(E-15)}.\n$$\n\n转换指数：\n$$\nE = 1\\cdot 2^{4} + 0\\cdot 2^{3} + 0\\cdot 2^{2} + 1\\cdot 2^{1} + 0\\cdot 2^{0} = 16 + 2 = 18,\n$$\n所以无偏指数为\n$$\nE - 15 = 18 - 15 = 3.\n$$\n\n计算尾数：\n$$\n(1.F)_{2} = 1 + 1\\cdot 2^{-1} + 1\\cdot 2^{-2} + 0\\cdot 2^{-3} + 0\\cdot 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} = \\frac{7}{4}.\n$$\n\n当 $S=1$ 时，符号因子为 $(-1)^{1}=-1$。因此，\n$$\nV = -\\frac{7}{4}\\,2^{3} = -\\frac{7}{4}\\cdot 8 = -14.\n$$\n\n这是一个精确的十进制值，不需要四舍五入。", "answer": "$$\\boxed{-14}$$", "id": "1937520"}, {"introduction": "将一个十进制数编码为浮点表示是解码的逆过程，但它也揭示了有限精度表示的一个核心挑战：近似误差。在这个练习中[@problem_id:1937508]，你不仅需要将一个十进制数转换为自定义的8位浮点格式，还必须量化这个过程中因截断而产生的表示误差。这个实践旨在强调在数字系统中，精度和存储空间之间存在的根本性权衡。", "problem": "一个专门的嵌入式系统使用一个自定义的8位浮点数表示法来存储传感器数据。该格式定义如下：\n- 1位用于符号 (S)：0代表正数，1代表负数。\n- 4位用于指数 (E)：指数以7为偏置量存储。\n- 3位用于小数部分 (F)：数字被规格化为 $1.F...$ 的形式，且首位的1是隐藏的。\n\n比特位按 S, E, F 的顺序排列。如果一个数的二进制表示的小数位数超过了可存储的位数，系统会截断多余的比特位（而不是四舍五入）。\n\n计算当系统尝试存储十进制值 $9.2$ 时产生的绝对表示误差。答案以十进制数形式给出，并四舍五入到三位有效数字。", "solution": "在此格式中，一个规格化的浮点值为\n$$V=(-1)^{S}\\left(1+\\sum_{i=1}^{3}f_{i}2^{-i}\\right)2^{E-\\mathrm{bias}},$$\n其中 $\\mathrm{bias}=7$，$S$ 是符号位，$E$ 是4位指数，$f_{i}$ 是三位小数位。截断意味着在规格化后，我们只保留前三位小数，并舍弃其余部分。\n\n对于 $9.2>0$，$S=0$。将 $9.2$ 转换为二进制并进行规格化。因为 $9.2=1001.0011001100\\ldots_{2}$，规格化后得到\n$$9.2=1.0010011001100\\ldots_{2}\\times 2^{3},$$\n所以无偏指数为 $e=3$，存储的指数为 $E=e+\\mathrm{bias}=3+7=10$。\n\n规格化尾数的小数部分为 $0010011\\ldots$；截断为三位小数后得到 $F=001$，所以存储的尾数是\n$$M_{\\text{stored}}=1.001_{2}=1+2^{-3}.$$\n因此，存储的值为\n$$V_{\\text{stored}}=(1+2^{-3})2^{3}=2^{3}+1=9.$$\n\n绝对表示误差是\n$$\\left|9.2-9\\right|=0.2.$$\n四舍五入到三位有效数字，结果是 $0.200$。", "answer": "$$\\boxed{0.200}$$", "id": "1937508"}, {"introduction": "浮点数系统的一个关键特性是其表示的数值并非均匀分布；随着数值的增大，可表示数之间的间隔也会变大。这个练习[@problem_id:2173582]将引导你超越单个数值的转换，去探索整个IEEE 754单精度浮点数系统的表示能力边界。你的任务是找出第一个无法被精确表示的正整数，从而深刻理解浮点表示的非均匀性及其固有的局限性。", "problem": "在现代计算中，实数通常使用浮点表示法来近似。一个被广泛采用的标准是电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) 754 标准。该标准下的单精度格式使用 32 位来表示一个数。\n\n这 32 位分配如下：\n- 1 位用于符号 ($s$)。\n- 8 位用于偏置指数 ($E$)。\n- 23 位用于小数部分 ($f$)。\n\n对于一个正的规格化数（其中符号位 $s=0$），其值 $V$ 由以下公式确定：\n$$V = 2^{E-127} \\times (1.f)_2$$\n这里，$127$ 是指数偏置量。项 $(1.f)_2$ 表示二进制的有效数，其中 '1.' 是一个不被存储的隐含前导位，$f$ 是存储在小数部分的 23 位二进制小数。对于规格化数，偏置指数 $E$ 的范围可以从 1 到 254。\n\n虽然这种格式可以表示非常大范围的数，但其有限的精度意味着并非所有数都能被精确表示。在考虑整数时，这个限制尤其有趣。例如，整数 5 可以写成 $1.25 \\times 4 = (1.01)_2 \\times 2^2$。这对应于小数部分 $f=0100...0$ 和一个产生 2 的幂的指数部分，因此 5 是可以被精确表示的。\n\n你的任务是找出在 IEEE 754 单精度浮点格式中无法被精确表示的最小正整数。", "solution": "一个规格化的单精度值具有以下形式\n$$V=2^{e}\\,(1.f)_{2},\\quad e=E-127,$$\n其中有效数有一个隐含的前导位加上 23 个存储的小数位，从而得到 $p=24$ 位的有效精度。将小数部分 $f$ 增加一个单位会使 $(1.f)_{2}$ 改变 $2^{-23}$，因此对于一个固定的指数 $e$，连续可表示数之间的间距（最后一位的单位，unit in the last place）是\n$$\\mathrm{ulp}(e)=2^{e}\\cdot 2^{-23}=2^{e-23}.$$\n\n为了精确表示某个区间内的每一个整数，该区间的间距必须最多为 $1$。因此我们要求\n$$\\mathrm{ulp}(e)\\leq 1 \\quad \\Longleftrightarrow \\quad 2^{e-23}\\leq 1 \\quad \\Longleftrightarrow \\quad e\\leq 23.$$\n在范围 $[2^{23},\\,2^{24})$ 内的数有 $e=23$，因此 $\\mathrm{ulp}=1$，所以该范围内的每个整数都是可表示的。值 $2^{24}$ 本身作为一个 2 的幂，其有效数为 $(1.0)_{2}$ 且 $e=24$，是可以被精确表示的。\n\n对于下一个范围 $[2^{24},\\,2^{25})$，我们有 $e=24$，因此\n$$\\mathrm{ulp}(24)=2^{24-23}=2,$$\n所以在该范围内只有 $2$ 的倍数是可表示的。因此，在这个范围内不能被精确表示的最小整数是最小的奇数，\n$$2^{24}+1.$$\n\n由于所有小于或等于 $2^{24}$ 的正整数都可以被精确表示，而 $2^{24}+1$ 不能，因此在 IEEE 754 单精度格式中无法被精确表示的最小正整数是 $2^{24}+1$。", "answer": "$$\\boxed{16777217}$$", "id": "2173582"}]}