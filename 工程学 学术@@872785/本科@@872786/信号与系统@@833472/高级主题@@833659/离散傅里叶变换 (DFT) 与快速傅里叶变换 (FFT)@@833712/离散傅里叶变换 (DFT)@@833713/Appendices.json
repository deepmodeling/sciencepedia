{"hands_on_practices": [{"introduction": "要真正掌握离散傅里叶变换 (DFT)，最好的起点是观察它如何处理其最基本的构成元素。DFT 将信号分解为一系列复指数信号，而这个练习正是要求你计算其中一个基函数的 DFT。通过这项基础练习 [@problem_id:1759639]，你将亲手验证一个核心概念：一个纯粹的复指数信号的频谱是一个尖锐的脉冲，从而深刻理解 DFT 作为频谱分析工具的本质。", "problem": "在数字信号处理中，离散傅里叶变换（DFT）是分析有限长度信号频率成分的基本工具。考虑一个采样后纯音信号的简化模型。该信号表示为 $x[n]$，由单个复指数表示。\n\n该信号是一个长度为 $N$ 的序列，定义如下：\n$$x[n] = \\exp\\left(j \\frac{2\\pi k_0 n}{N}\\right)$$\n时间索引为 $n = 0, 1, \\ldots, N-1$。此处，$k_0$ 是一个整数常数，代表该音调的归一化频率，且满足 $0 \\le k_0  N$。\n\n你的任务是计算该信号的 $N$ 点DFT。DFT表示为 $X[k]$，由以下分析方程定义：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right)$$\n其中 $k$ 是频率索引，取整数值 $k = 0, 1, \\ldots, N-1$。\n\n请找出 $X[k]$ 关于 $N$、$k$ 和 $k_0$ 的单一闭式解析表达式。", "solution": "我们从DFT分析方程开始，并代入给定的信号。根据定义，\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi kn}{N}\\right).\n$$\n当 $x[n] = \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)$ 时，该式变为\n$$\nX[k] = \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi k_{0} n}{N}\\right)\\exp\\left(-j \\frac{2\\pi k n}{N}\\right) \n= \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_{0}-k) n}{N}\\right).\n$$\n定义比率\n$$\nr \\triangleq \\exp\\left(j \\frac{2\\pi (k_{0}-k)}{N}\\right).\n$$\n则\n$$\nX[k] = \\sum_{n=0}^{N-1} r^{n}.\n$$\n这是一个有限几何级数。使用几何级数求和公式，\n$$\n\\sum_{n=0}^{N-1} r^{n} = \n\\begin{cases}\n\\frac{1 - r^{N}}{1 - r},  r \\neq 1, \\\\\nN,  r = 1,\n\\end{cases}\n$$\n并注意到\n$$\nr^{N} = \\exp\\left(j \\frac{2\\pi (k_{0}-k) N}{N}\\right) = \\exp\\left(j 2\\pi (k_{0}-k)\\right) = 1,\n$$\n我们有：\n- 如果 $r \\neq 1$ （对于 $k,k_{0}\\in\\{0,\\ldots,N-1\\}$，等价于 $k \\neq k_{0}$），那么 $1 - r^{N} = 0$ 而 $1 - r \\neq 0$，所以 $X[k] = 0$。\n- 如果 $r = 1$ （等价于 $k = k_{0}$），那么求和的每一项都等于 $1$，所以 $X[k] = N$。\n\n综合这两种情况，得到闭式表达式\n$$\nX[k] = N\\,\\delta_{k,k_{0}},\n$$\n其中 $\\delta_{k,k_{0}}$ 是克罗内克δ函数，当 $k=k_{0}$ 时等于 $1$，否则等于 $0$。", "answer": "$$\\boxed{N\\,\\delta_{k,k_{0}}}$$", "id": "1759639"}, {"introduction": "理解了 DFT 如何分析频率成分后，我们可以将其应用于一项核心的信号处理任务：滤波。在频域中，复杂的时域卷积运算可以被简化为简单的逐点相乘，这体现了 DFT 的强大威力。这个练习 [@problem_id:1759601] 将引导你完成一个理想低通滤波的具体案例，通过计算一个位于原始信号范围之外的输出样本，你将直接观察到“振铃”效应——这是数字滤波器设计中的一个关键现象，它揭示了频域操作对时域信号产生的非局部影响。", "problem": "考虑一个长度为 $N=16$ 的离散时间信号 $x[n]$。该信号定义为一个矩形脉冲：当 $0 \\le n \\le 4$ 时，$x[n]=1$；当 $5 \\le n \\le 15$ 时，$x[n]=0$。该信号在频域中通过一个理想低通滤波器进行处理。信号的N点离散傅里叶变换 (DFT)，记为 $X[k]$，与滤波器频率响应 $H[k]$ 相乘以产生输出频谱 $Y[k] = X[k]H[k]$。滤波器的定义为：当 $k \\in \\{0, 1, 2, 14, 15\\}$ 时，$H[k]=1$；对于范围 $0 \\le k \\le 15$ 内的所有其他 $k$ 值，$H[k]=0$。时域中的输出信号 $y[n]$ 是通过对 $Y[k]$ 进行N点离散傅里叶逆变换 (IDFT) 得到的。计算输出信号样本 $y[7]$ 的值。将您的最终答案四舍五入到四位有效数字。", "solution": "令 $N=16$，定义 $N$ 点 DFT 和 IDFT 如下：\n$$\nX[k]=\\sum_{n=0}^{15} x[n]\\exp(-\\mathrm{j}2\\pi kn/16),\\quad\ny[n]=\\frac{1}{16}\\sum_{k=0}^{15} Y[k]\\exp(\\mathrm{j}2\\pi kn/16),\n$$\n其中 $Y[k]=X[k]H[k]$。由于当 $0\\leq n\\leq 4$ 时 $x[n]=1$ 否则 $x[n]=0$，我们有对于 $k\\in\\{0,1,\\dots,15\\}$：\n$$\nX[k]=\\sum_{n=0}^{4}\\exp(-\\mathrm{j}2\\pi kn/16).\n$$\n对于 $k=0$，$X[0]=5$。对于 $k\\neq 0$，使用 $M=5$ 和 $\\theta=2\\pi k/16$ 的狄利克雷形式的等比数列求和公式：\n$$\nX[k]=\\exp\\!\\big(-\\mathrm{j}\\theta(M-1)/2\\big)\\,\\frac{\\sin(M\\theta/2)}{\\sin(\\theta/2)}\n=\\exp\\!\\big(-\\mathrm{j}\\theta\\cdot 2\\big)\\,\\frac{\\sin(5\\theta/2)}{\\sin(\\theta/2)}.\n$$\n滤波器只保留 $k\\in\\{0,1,2,14,15\\}$ 的分量，所以\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+X[1]\\exp(\\mathrm{j}\\omega n)+X[2]\\exp(\\mathrm{j}2\\omega n)+X[14]\\exp(\\mathrm{j}14\\omega n)+X[15]\\exp(\\mathrm{j}15\\omega n)\\Big),\n$$\n其中 $\\omega=2\\pi/16$。利用 $X[16-k]=X[k]^{*}$ 以及 $\\exp(\\mathrm{j}14\\omega n)=\\exp(-\\mathrm{j}2\\omega n)$，$\\exp(\\mathrm{j}15\\omega n)=\\exp(-\\mathrm{j}\\omega n)$，上式变为\n$$\ny[n]=\\frac{1}{16}\\Big(X[0]+2\\Re\\{X[1]\\exp(\\mathrm{j}\\omega n)\\}+2\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega n)\\}\\Big).\n$$\n现在我们令 $n=7$。显式计算 $X[1]$ 和 $X[2]$：\n- 对于 $k=1$，$\\theta=\\pi/8$，所以\n$$\nX[1]=\\exp(-\\mathrm{j}\\pi/4)\\,\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}.\n$$\n因此\n$$\n\\Re\\{X[1]\\exp(\\mathrm{j}\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(7\\frac{\\pi}{8}-\\frac{\\pi}{4}\\Big)=\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big).\n$$\n- 对于 $k=2$，$\\theta=\\pi/4$，所以\n$$\nX[2]=\\exp(-\\mathrm{j}\\pi/2)\\,\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}.\n$$\n因此\n$$\n\\Re\\{X[2]\\exp(\\mathrm{j}2\\omega\\cdot 7)\\}=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(7\\frac{\\pi}{4}-\\frac{\\pi}{2}\\Big)=\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big).\n$$\n因此\n$$\ny[7]=\\frac{1}{16}\\left(5+2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)+2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)\\right).\n$$\n在可能的情况下使用精确的三角函数值：\n$$\n\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)=-\\cos\\!\\Big(\\frac{3\\pi}{8}\\Big),\\quad \\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-\\frac{\\sqrt{2}}{2},\\quad \\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}=\\frac{\\sin(3\\pi/8)}{\\sin(\\pi/8)}=1+\\sqrt{2}.\n$$\n数值上，\n$$\n\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\approx 4.2619726274,\\quad \\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -0.3826834324,\\quad 1+\\sqrt{2}\\approx 2.4142135624,\n$$\n所以\n$$\n2\\frac{\\sin(5\\pi/16)}{\\sin(\\pi/16)}\\cos\\!\\Big(\\frac{5\\pi}{8}\\Big)\\approx -3.2619726274,\\quad\n2\\frac{\\sin(5\\pi/8)}{\\sin(\\pi/8)}\\cos\\!\\Big(\\frac{5\\pi}{4}\\Big)=-(\\sqrt{2}+2)\\approx -3.4142135624.\n$$\n因此\n$$\ny[7]\\approx \\frac{1}{16}\\Big(5-3.2619726274-3.4142135624\\Big)\\approx -0.1047616369,\n$$\n四舍五入到四位有效数字是 $-0.1048$。", "answer": "$$\\boxed{-0.1048}$$", "id": "1759601"}, {"introduction": "虽然 DFT 在理论上极为强大，但其 $\\mathcal{O}(N^2)$ 的直接计算复杂度使其在处理大规模数据时显得不切实际，这引出了一个关键问题：DFT 在实践中是如何高效实现的？答案是快速傅里叶变换 (FFT) 算法，它将计算复杂度显著降低至 $\\mathcal{O}(N \\log N)$。这项终极实践 [@problem_id:2387187] 将带你从理论走向实践，你将亲手实现经典的 Cooley-Tukey FFT 算法，通过编写代码并用它来验证卷积定理和帕塞瓦尔恒等式等基本属性，你将对 DFT 的计算原理及其在现代科技中的基石地位获得最深刻的理解。", "problem": "设 $N$ 是一个正整数，其形式为 $N = 2^m$，其中 $m$ 是某个非负整数。对于一个长度为 $N$ 的复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$，其离散傅里叶变换 (DFT) $X = \\{X_k\\}_{k=0}^{N-1}$ 定义为\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1,\n$$\n且逆离散傅里叶变换 (IDFT) 定义为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N} \\quad \\text{for } n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。\n\n编写一个完整的程序，在不调用任何库傅里叶变换例程的情况下，为长度为 $N = 2^m$ 的序列计算 DFT 和 IDFT。您的程序还必须仅使用这些定义，通过明确的测试用例来验证以下基本性质：\n\n- 循环卷积定理：对于长度为 $N$ 的序列 $a$ 和 $b$，其长度为 $N$ 的循环卷积 $c$ 定义为 $c_n = \\sum_{m=0}^{N-1} a_m \\, b_{(n-m) \\bmod N}$，满足 $C_k = A_k B_k$，其中 $A$、$B$ 和 $C$ 分别是 $a$、$b$ 和 $c$ 的 DFT。\n- 帕塞瓦尔恒等式（使用上述归一化）：$\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2$。\n\n您的程序必须实现自己的快速算法来计算 $N = 2^m$ 的 DFT 和 IDFT，并且必须包含一个直接的 $\\mathcal{O}(N^2)$ DFT 用于验证。在需要布尔验证的地方，使用数值容差 $\\varepsilon = 10^{-9}$。所有角度都必须解释为弧度。\n\n使用以下测试套件，并按下面给出的顺序生成输出：\n\n- 测试 1 (DFT 正确性与直接 DFT 对比，正常路径)：设 $N = 8$ 且 $x = [0,1,2,3,4,3,2,1]$。使用您的快速实现计算 $X$，并使用直接 DFT 计算 $\\tilde{X}$。如果 $\\max_k |X_k - \\tilde{X}_k| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 2 (逆变换恢复)：使用与测试 1 相同的 $N$ 和 $x$，通过将您的 IDFT 应用于您快速实现得到的 $X$ 来计算 $x'$。如果 $\\max_n |x'_n - x_n| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 3 (通过频域实现循环卷积)：设 $N = 8$，$a = [1,2,3,0,0,0,0,0]$ 且 $b = [0,1,0,0,0,0,0,0]$。直接根据其定义计算长度为 $N$ 的循环卷积 $c$。另外，通过计算 $a$ 和 $b$ 的 DFT，逐点相乘，然后应用 IDFT 来计算 $\\hat{c}$。输出标量 $\\max_n |c_n - \\hat{c}_n|$ 作为浮点数。\n- 测试 4 (帕塞瓦尔恒等式)：设 $N = 16$ 且 $x_n = \\sin\\!\\left( \\frac{2\\pi \\cdot 3 \\, n}{N} \\right) + \\frac{1}{2} \\cos\\!\\left( \\frac{2\\pi \\cdot 5 \\, n}{N} \\right)$，$n = 0,1,\\dots,15$。通过您的快速实现计算 $X$。输出标量 $\\left| \\sum_{n=0}^{N-1} |x_n|^2 - \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2 \\right|$ 作为浮点数。\n- 测试 5 (边界情况 $N=1$)：设 $N = 1$ 且 $x = [3 + 4i]$。计算 $X$，然后通过 IDFT 计算 $x'$。如果 $|x'_0 - x_0| \\le \\varepsilon$ 则输出布尔值 $\\text{True}$，否则输出 $\\text{False}$。\n- 测试 6 (最小非平凡大小 $N=2$)：设 $N = 2$ 且 $x = [1,-1]$。通过您的快速实现计算 $X$。在给定约定下，确切的 DFT 是 $[0,2]$。输出标量 $\\max_k |X_k - [0,2]_k|$ 作为浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含六个结果，按顺序排列，以逗号分隔并用方括号括起来，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$。所有布尔条目必须是 $\\text{True}$ 或 $\\text{False}$，所有实值条目必须以标准十进制或科学记数法打印。不应打印其他任何文本。", "solution": "所提出的问题是计算物理领域中一个适定且科学上合理的问题，具体来说属于信号处理领域。它要求实现和验证离散傅里叶变换 (DFT)、其逆变换 (IDFT) 以及相关的基本定理。该问题是完整、客观的，并且其解是可验证的。我们将继续进行求解。\n\n问题的核心是为给定的长度为 $N$ 的离散复值序列 $x = \\{x_n\\}_{n=0}^{N-1}$ 计算其 DFT $X$。其定义如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, k n / N} \\quad \\text{for } k = 0,1,\\dots,N-1.\n$$\n这个公式的直接实现涉及两个嵌套循环，一个循环遍历索引 $k$ (从 $0$ 到 $N-1$)，另一个循环遍历索引 $n$ (从 $0$ 到 $N-1$) 。这导致了 $\\mathcal{O}(N^2)$ 的计算复杂度，对于大的 $N$ 而言效率低下。为了验证目的，我们将实现这样一种直接方法。\n\n问题指定 $N$ 是 2 的幂，即 $N = 2^m$，其中 $m$ 是某个非负整数。这种结构是采用快速傅里叶变换 (FFT) 算法的关键，特别是 Cooley-Tukey 时域抽取算法。该算法将复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N \\log N)$。其原理是分治法。长度为 $N$ 的 DFT被递归地分解为两个长度为 $(N/2)$ 的 DFT。\n\n将序列 $x_n$ 分解为其偶数索引元素（构成序列 $x'_m = x_{2m}$）和奇数索引元素（构成序列 $x''_m = x_{2m+1}$），每个序列的长度均为 $N/2$。DFT 的求和可以重写为：\n$$\nX_k = \\sum_{m=0}^{N/2-1} x_{2m} e^{-2\\pi i k (2m) / N} + \\sum_{m=0}^{N/2-1} x_{2m+1} e^{-2\\pi i k (2m+1) / N}\n$$\n$$\nX_k = \\sum_{m=0}^{N/2-1} x'_m e^{-2\\pi i k m / (N/2)} + e^{-2\\pi i k/N} \\sum_{m=0}^{N/2-1} x''_m e^{-2\\pi i k m / (N/2)}\n$$\n设 $X'_k$ 和 $X''_k$ 分别是 $x'_m$ 和 $x''_m$ 的长度为 $(N/2)$ 的 DFT。则上述表达式变为：\n$$\nX_k = X'_{k \\bmod (N/2)} + W_N^k X''_{k \\bmod (N/2)}\n$$\n其中 $W_N^k = e^{-2\\pi i k/N}$ 是“旋转因子”。对于索引的前半部分 $0 \\le k  N/2$，我们有：\n$$\nX_k = X'_k + W_N^k X''_k\n$$\n对于后半部分，其中索引为 $k+N/2$ ($0 \\le k  N/2$) ，我们使用性质 $X'_{k+N/2} = X'_k$、$X''_{k+N/2} = X''_k$ 和 $W_N^{k+N/2} = -W_N^k$。这得出：\n$$\nX_{k+N/2} = X'_k - W_N^k X''_k\n$$\n这个递归定义允许构建完整的 DFT。递归在基本情况 $N=1$ 时终止，此时序列 $\\{x_0\\}$ 的 DFT 就是 $\\{X_0\\} = \\{x_0\\}$。我们的实现将遵循这种递归结构。\n\n逆离散傅里叶变换 (IDFT) 定义为：\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{+2\\pi i \\, k n / N}\n$$\n没有必要单独实现。我们可以将 IDFT 与正向 DFT 联系起来。观察以下推导：\n$$\nN \\cdot \\overline{x_n} = \\overline{\\sum_{k=0}^{N-1} X_k e^{+2\\pi i k n / N}} = \\sum_{k=0}^{N-1} \\overline{X_k} e^{-2\\pi i k n / N}\n$$\n右边是复共轭序列 $\\{\\overline{X_k}\\}_{k=0}^{N-1}$ 的 DFT。因此，我们可以通过计算 $\\overline{X}$ 的 DFT，取结果的复共轭，再乘以 $1/N$ 来求得 $x_n$。即 $x = \\frac{1}{N} \\overline{\\text{DFT}(\\overline{X})}$。这也允许我们使用我们高效的 FFT 实现来计算逆变换 (IFFT)。\n\n该问题进一步要求验证两个基本定理。\n\n首先是循环卷积定理。两个长度为 $N$ 的序列 $a$ 和 $b$ 的循环卷积 $c$ 由 $c_n = \\sum_{m=0}^{N-1} a_m b_{(n-m) \\bmod N}$ 给出。该定理指出，卷积的 DFT 是各个 DFT 的逐点乘积：$C_k = A_k B_k$。因此，可以通过频域计算 $c$：$c = \\text{IDFT}(\\text{DFT}(a) \\odot \\text{DFT}(b))$，其中 $\\odot$ 表示逐元素乘法。我们将通过直接计算 $c$ 和通过频域路径计算 $c$ 并比较结果来测试这一点。\n\n其次是帕塞瓦尔恒等式。对于给定的 DFT 归一化，该恒等式为：\n$$\n\\sum_{n=0}^{N-1} |x_n|^2 = \\frac{1}{N} \\sum_{k=0}^{N-1} |X_k|^2\n$$\n该定理将信号在时域中的总能量与其在频域中的能量联系起来。我们将对一个特定的测试信号验证这一点。\n\n程序将首先定义必要的函数：一个直接的 $\\mathcal{O}(N^2)$ DFT、一个递归的 $\\mathcal{O}(N \\log N)$ FFT、一个基于 FFT 的 IFFT，以及一个直接的循环卷积函数。然后，它将使用这些函数和 $\\varepsilon = 10^{-9}$ 的数值容差来执行 $6$ 个指定的测试用例进行比较。结果将被收集并以要求的格式打印。", "answer": "```python\nimport numpy as np\n\ndef direct_dft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the direct O(N^2) method.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n    n = np.arange(N)\n    k = n.reshape((N, 1))\n    W = np.exp(-2j * np.pi * k * n / N)\n    X = np.dot(W, x)\n    return X\n\ndef fft(x):\n    \"\"\"\n    Computes the Discrete Fourier Transform of a sequence x using the recursive\n    Cooley-Tukey FFT algorithm. Assumes N is a power of 2.\n    \"\"\"\n    x = np.asarray(x, dtype=complex)\n    N = x.shape[0]\n\n    if N == 1:\n        return x\n\n    # Decimate: split into even and odd subsequences\n    x_even = fft(x[0::2])\n    x_odd = fft(x[1::2])\n\n    # Combine\n    k = np.arange(N // 2)\n    twiddle_factors = np.exp(-2j * np.pi * k / N)\n    \n    X = np.concatenate([x_even + twiddle_factors * x_odd,\n                          x_even - twiddle_factors * x_odd])\n    return X\n\ndef ifft(X):\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform using the forward FFT algorithm.\n    \"\"\"\n    X = np.asarray(X, dtype=complex)\n    N = X.shape[0]\n    \n    # Use the property: IDFT(X) = (1/N) * conj(DFT(conj(X)))\n    x = np.conjugate(fft(np.conjugate(X))) / N\n    return x\n\ndef circular_conv(a, b):\n    \"\"\"\n    Computes the circular convolution of two sequences a and b directly.\n    \"\"\"\n    a = np.asarray(a, dtype=complex)\n    b = np.asarray(b, dtype=complex)\n    N = len(a)\n    c = np.zeros(N, dtype=complex)\n    for n in range(N):\n        for m in range(N):\n            c[n] += a[m] * b[(n - m) % N]\n    return c\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the formatted results.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: DFT correctness versus direct DFT\n    N1 = 8\n    x1 = np.array([0, 1, 2, 3, 4, 3, 2, 1], dtype=float)\n    X_fast = fft(x1)\n    X_direct = direct_dft(x1)\n    err1 = np.max(np.abs(X_fast - X_direct))\n    results.append(err1 = epsilon)\n\n    # Test 2: Inverse transform recovery\n    x_prime = ifft(X_fast)\n    err2 = np.max(np.abs(x_prime - x1))\n    results.append(err2 = epsilon)\n\n    # Test 3: Circular convolution via frequency domain\n    N3 = 8\n    a3 = np.array([1, 2, 3, 0, 0, 0, 0, 0], dtype=float)\n    b3 = np.array([0, 1, 0, 0, 0, 0, 0, 0], dtype=float)\n    c_direct = circular_conv(a3, b3)\n    A3 = fft(a3)\n    B3 = fft(b3)\n    C_freq = A3 * B3\n    c_hat = ifft(C_freq)\n    err3 = np.max(np.abs(c_direct - c_hat))\n    results.append(err3)\n\n    # Test 4: Parseval identity\n    N4 = 16\n    n4 = np.arange(N4)\n    x4 = np.sin(2 * np.pi * 3 * n4 / N4) + 0.5 * np.cos(2 * np.pi * 5 * n4 / N4)\n    X4 = fft(x4)\n    sum_sq_x = np.sum(np.abs(x4)**2)\n    sum_sq_X_scaled = np.sum(np.abs(X4)**2) / N4\n    err4 = np.abs(sum_sq_x - sum_sq_X_scaled)\n    results.append(err4)\n\n    # Test 5: Edge case N=1\n    x5 = np.array([3 + 4j])\n    X5 = fft(x5)\n    x5_prime = ifft(X5)\n    err5 = np.abs(x5_prime[0] - x5[0])\n    results.append(err5 = epsilon)\n\n    # Test 6: Smallest nontrivial size N=2\n    x6 = np.array([1, -1], dtype=float)\n    X6 = fft(x6)\n    X_exact = np.array([0, 2], dtype=complex)\n    err6 = np.max(np.abs(X6 - X_exact))\n    results.append(err6)\n\n    # Format and print final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2387187"}]}