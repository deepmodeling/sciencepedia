{"hands_on_practices": [{"introduction": "为了有效地使用语谱图，我们必须首先理解其基本的物理含义。本练习将引导你对短时傅里叶变换（STFT）和语谱图的定义进行量纲分析。通过确定其单位，你将巩固对语谱图作为时变功率谱密度的理解，这是在处理更高级概念之前至关重要的第一步。[@problem_id:2914026]", "problem": "一个实值电压信号 $x(t)$ 以伏特为单位测量，时间 $t$ 以秒为单位。考虑其带有分析窗 $g(t)$ 的短时傅里叶变换（STFT），其定义使用赫兹为单位的频率变量 $f$ 如下：\n$$\nX_g(t,f) \\equiv \\int_{-\\infty}^{\\infty} x(\\tau)\\, g^{\\ast}(\\tau - t)\\, \\exp(-j 2\\pi f \\tau)\\, d\\tau,\n$$\n以及相应的谱图\n$$\nS_x(t,f) \\equiv \\frac{|X_g(t,f)|^2}{E_g}, \\quad \\text{其中} \\quad E_g \\equiv \\int_{-\\infty}^{\\infty} |g(\\tau)|^2\\, d\\tau.\n$$\n假设 $g(t)$ 是无量纲的，并仅使用给定的定义和量纲一致性，以及标准的双边变换约定 $\\exp(-j 2\\pi f t)$。\n\n任务：\n- 从这些定义出发，推导 $S_x(t,f)$ 的物理单位（用伏特和秒表示）。通过将频率积分 $\\int S_x(t,f)\\, df$ 与瞬时信号能量的加窗平均值相关联来解释你的结果。\n- 然后，采用一个参考谱密度 $S_{\\mathrm{ref}}$，其值等于常数 $1$，单位与 $S_x(t,f)$ 相同（也就是说，当 $S_x$ 的数值以 $\\mathrm{V}^2/\\mathrm{Hz}$ 表示时，$S_{\\mathrm{ref}} = 1$）。使用类功率量的常规分贝（dB）映射，提供一个单一的闭式解析表达式，将 $S_x(t,f)$ 映射到以 $S_{\\mathrm{ref}}$ 为参考的分贝值谱图 $L_{\\mathrm{dB}}(t,f)$。\n\n你的最终答案必须只是这个用 $S_x(t,f)$ 和 $S_{\\mathrm{ref}}$ 表示的 $L_{\\mathrm{dB}}(t,f)$ 的单一表达式，且最终的方框表达式内不含单位。不要进行四舍五入或近似计算。", "solution": "所述问题具有科学依据、提法恰当且客观。它基于信号处理的标准定义，并要求应用量纲分析和傅里叶理论的基本原理。所有必要信息均已提供，任务明确。我们可以开始求解。\n\n根据要求，分析分为两个部分：首先，推导谱图的物理单位及其物理解释；其次，构建分贝值谱图的公式。\n\n首先，我们确定谱图 $S_x(t,f)$ 的单位。这需要对其组成部分进行量纲分析，从短时傅里叶变换（STFT）$X_g(t,f)$ 开始。其定义为：\n$$\nX_g(t,f) \\equiv \\int_{-\\infty}^{\\infty} x(\\tau)\\, g^{\\ast}(\\tau - t)\\, \\exp(-j 2\\pi f \\tau)\\, d\\tau\n$$\n我们分析积分内各项的单位。令 $[Q]$ 表示量 $Q$ 的单位。\n- 信号 $x(t)$ 是电压，所以 $[x(\\tau)] = \\mathrm{V}$ (伏特)。\n- 分析窗 $g(t)$ 被明确说明是无量纲的，所以 $[g^{\\ast}(\\tau - t)] = 1$。\n- 复指数项 $\\exp(-j 2\\pi f \\tau)$ 总是无量纲的，因为其宗量必须是无量纲的。确实，$[f][\\tau] = \\mathrm{Hz} \\cdot \\mathrm{s} = (\\mathrm{s}^{-1}) \\cdot \\mathrm{s} = 1$。\n- 微分元是关于时间的，所以 $[d\\tau] = \\mathrm{s}$ (秒)。\n\n因此，被积函数的单位是 $[x(\\tau) g^{\\ast}(\\tau-t) \\exp(-j 2\\pi f \\tau)] = \\mathrm{V} \\cdot 1 \\cdot 1 = \\mathrm{V}$。关于 $\\tau$ 的积分将这些单位乘以 $d\\tau$ 的单位。\n因此，STFT 的单位是：\n$$\n[X_g(t,f)] = \\mathrm{V} \\cdot \\mathrm{s}\n$$\n接下来，我们求窗能量 $E_g$ 的单位：\n$$\nE_g \\equiv \\int_{-\\infty}^{\\infty} |g(\\tau)|^2\\, d\\tau\n$$\n由于 $[g(\\tau)] = 1$，我们有 $[|g(\\tau)|^2] = 1^2 = 1$。关于 $\\tau$ 的积分给出：\n$$\n[E_g] = 1 \\cdot \\mathrm{s} = \\mathrm{s}\n$$\n现在我们可以确定谱图 $S_x(t,f)$ 的单位：\n$$\nS_x(t,f) \\equiv \\frac{|X_g(t,f)|^2}{E_g}\n$$\n单位是：\n$$\n[S_x(t,f)] = \\frac{[X_g(t,f)]^2}{[E_g]} = \\frac{(\\mathrm{V} \\cdot \\mathrm{s})^2}{\\mathrm{s}} = \\frac{\\mathrm{V}^2 \\cdot \\mathrm{s}^2}{\\mathrm{s}} = \\mathrm{V}^2 \\cdot \\mathrm{s}\n$$\n因为频率单位赫兹（$\\mathrm{Hz}$）是时间单位秒（$\\mathrm{s} = 1/\\mathrm{Hz}$）的倒数，我们可以将这些单位表示为：\n$$\n[S_x(t,f)] = \\mathrm{V}^2 / \\mathrm{Hz}\n$$\n这是功率谱密度的单位，这是对谱图的正确物理解释。\n\n其次，我们解释谱图的频率积分 $\\int_{-\\infty}^{\\infty} S_x(t,f)\\, df$ 的物理意义。我们从代入 $S_x(t,f)$ 的定义开始：\n$$\n\\int_{-\\infty}^{\\infty} S_x(t,f)\\, df = \\int_{-\\infty}^{\\infty} \\frac{|X_g(t,f)|^2}{E_g}\\, df = \\frac{1}{E_g} \\int_{-\\infty}^{\\infty} |X_g(t,f)|^2\\, df\n$$\nSTFT $X_g(t,f)$ 是加窗信号段 $y_t(\\tau) = x(\\tau) g^*(\\tau-t)$ 关于 $\\tau$ 的傅里叶变换。也就是说，$X_g(t,f) = \\mathcal{F}_{\\tau \\to f}\\{y_t(\\tau)\\}$。我们应用傅里叶变换的 Parseval 定理，该定理指出对于给定的变换约定，有 $\\int_{-\\infty}^{\\infty} |Y(f)|^2\\, df = \\int_{-\\infty}^{\\infty} |y(\\tau)|^2\\, d\\tau$。将此应用于我们的情况：\n$$\n\\int_{-\\infty}^{\\infty} |X_g(t,f)|^2\\, df = \\int_{-\\infty}^{\\infty} |x(\\tau) g^*(\\tau-t)|^2\\, d\\tau = \\int_{-\\infty}^{\\infty} |x(\\tau)|^2 |g(\\tau-t)|^2\\, d\\tau\n$$\n由于问题陈述 $x(t)$ 是实值的，所以 $|x(\\tau)|^2 = x^2(\\tau)$。因此，谱图的频率积分变为：\n$$\n\\int_{-\\infty}^{\\infty} S_x(t,f)\\, df = \\frac{1}{E_g} \\int_{-\\infty}^{\\infty} x^2(\\tau) |g(\\tau-t)|^2\\, d\\tau = \\frac{\\int_{-\\infty}^{\\infty} x^2(\\tau) |g(\\tau-t)|^2\\, d\\tau}{\\int_{-\\infty}^{\\infty} |g(\\tau')|^2\\, d\\tau'}\n$$\n量 $x^2(\\tau)$ 表示信号在时间 $\\tau$ 的瞬时功率（归一化到 $1$ 欧姆电阻，单位为 $\\mathrm{V}^2$）。该表达式是此瞬时功率的加权平均值，其中权重函数 $|g(\\tau-t)|^2$ 是一个以时间 $t$ 为中心的窗。分母 $E_g$ 是此平均值的归一化因子。因此，该积分表示信号在时间 $t$ 附近的短时平均功率。单位与此解释相符：$[\\int S_x(t,f) df] = (\\mathrm{V}^2/\\mathrm{Hz}) \\cdot \\mathrm{Hz} = \\mathrm{V}^2$，这是平均功率的单位（每欧姆）。\n\n最后，我们推导分贝值谱图 $L_{\\mathrm{dB}}(t,f)$ 的表达式。对于一个类功率量 $P$，相对于参考值 $P_{\\mathrm{ref}}$ 的分贝（dB）标度由公式 $10 \\log_{10}(P/P_{\\mathrm{ref}})$ 给出。\n谱图 $S_x(t,f)$ 代表功率谱密度，它是一个类功率量。我们给定了一个参考谱密度 $S_{\\mathrm{ref}}$。因此，到分贝的映射为：\n$$\nL_{\\mathrm{dB}}(t,f) = 10 \\log_{10} \\left( \\frac{S_x(t,f)}{S_{\\mathrm{ref}}} \\right)\n$$\n问题指定 $S_{\\mathrm{ref}}$ 在数值上等于 $1$，其单位与 $S_x(t,f)$ 相同。虽然我们可以在表达式中代入 $S_{\\mathrm{ref}}=1$，但最完整和最正式的表示法保留了符号参考，因为它使比率更加明确。问题要求一个用 $S_x(t,f)$ 和 $S_{\\mathrm{ref}}$ 表示的单一闭式表达式。此表达式即为最终答案。", "answer": "$$\n\\boxed{10 \\log_{10}\\left(\\frac{S_x(t,f)}{S_{\\mathrm{ref}}}\\right)}\n$$", "id": "2914026"}, {"introduction": "语谱图分析的核心在于处理时间-频率分辨率的权衡问题。本练习提供了一个实际场景，旨在挑战一个常见的误区：将快速傅里叶变换（FFT）的计算网格与真实的物理分辨率混淆。通过分析分辨两个紧邻音调的能力，你将学会区分窗函数长度（$L$）和FFT点数（$N$）各自的作用，这是正确解读任何语谱图的关键技能。[@problem_id:2914032]", "problem": "一个离散时间信号以采样率 $F_{s} = 48000$ Hz 进行采样。一个基于短时傅里叶变换 (STFT) 的频谱图是这样计算的：使用长度为 $L = 1024$ 个样本的汉宁窗（Hann window），每帧进行 $N = 8192$ 点的快速傅里叶变换 (FFT)（即用 $N - L$ 个零进行补零），以及足够大的重叠，使得加窗操作主导了时间分辨率。考虑一个帧，其中包含两个等幅纯音，频率分别为 $f_{1} = 10000$ Hz 和 $f_{2} = 10050$ Hz。\n\n仅使用关于离散傅里叶变换 (DFT) 频率采样网格和有限窗长对谱集中的影响的基本定义，回答以下问题：\n\n1) 计算每个 STFT 帧中使用的 $N$ 点 DFT 的离散频率仓（bin）间距。\n\n2) 评估以下关于频率分辨率和时频权衡的陈述。选择所有正确的陈述。\n\nA. 离散频率仓间距等于 $F_{s}/N$，此处的数值计算结果为 $5.859375$ Hz。\n\nB. 因为频率仓间距小于音调的 $50$ Hz 间隔，所以这两个音调在经过补零的汉宁窗频谱图中将被清晰地分辨出来。\n\nC. 对于长度为 $L$ 的汉宁窗，其主瓣的第一个谱零点大约出现在距离音调频率 $\\pm 2 F_{s}/L$ 的位置，因此对于等幅音调，实际可分辨的最小间隔约为 $2 F_{s}/L$。当 $L = 1024$ 且 $F_{s} = 48000$ 时，这个值约为 $93.75$ Hz，这意味着尽管进行了补零，这两个相隔 $50$ Hz 的音调也无法被分辨。\n\nD. 在保持 $L$ 固定的情况下增加 $N$ 会减小窗谱的主瓣宽度，从而提高真实的谱分辨率。\n\nE. 增加 $L$（在窗类型固定的情况下）会提高频率分辨率，但会降低时间分辨率，因为有效的时间支撑区 $T = L/F_{s}$ 增加了。\n\nF. 对于任何 $L$ 和任何窗类型，离散频率仓间距都等于窗的等效噪声带宽 (ENBW)。\n\nG. 如果使用相同长度 $L$ 的矩形窗代替汉宁窗，瑞利分离（第一零点准则）约为 $F_{s}/L \\approx 46.875$ Hz，因此相隔 $50$ Hz 的两个等幅音调接近瑞利极限，在无噪声条件下可能勉强可以分辨。", "solution": "问题陈述在科学上是合理的、定义明确的，并包含了进行严谨分析所需的所有信息。我们将首先解决频率仓间距的计算问题，然后逐一评估每个陈述。\n\n分析基于以下给定条件：\n- 采样率：$F_{s} = 48000$ Hz\n- 汉宁窗长度：$L = 1024$ 个样本\n- FFT 点数：$N = 8192$ 点\n- 音调频率：$f_{1} = 10000$ Hz 和 $f_{2} = 10050$ Hz，间隔为 $\\Delta f = f_{2} - f_{1} = 50$ Hz。\n\n**第1部分：离散频率仓间距的计算**\n\n长度为 $N$ 的离散傅里叶变换 (DFT) 提供了从 $0$ 到（但不包括）采样频率 $F_{s}$ 范围内的频谱样本。频率轴被划分为 $N$ 个等间距的点，称为频率仓（frequency bins）。这个 DFT 网格的间距或分辨率，我们记作 $\\Delta f_{bin}$，由以下基本公式给出：\n$$ \\Delta f_{bin} = \\frac{F_{s}}{N} $$\n代入给定值：\n$$ \\Delta f_{bin} = \\frac{48000 \\text{ Hz}}{8192} = 5.859375 \\text{ Hz} $$\n这个值表示由快速傅里叶变换 (FFT) 计算出的相邻频率样本之间的距离。\n\n**第2部分：陈述评估**\n\n我们现在将根据数字信号处理的原理评估每个陈述。\n\n**A. 离散频率仓间距等于 $F_{s}/N$，此处的数值计算结果为 $5.859375$ Hz。**\n该陈述是 DFT 频率网格定义的直接应用。如上所计算，公式 $\\Delta f_{bin} = F_{s}/N$ 是正确的，数值计算 $\\frac{48000}{8192} = 5.859375 \\text{ Hz}$ 也是正确的。\n**结论：正确。**\n\n**B. 因为频率仓间距小于音调的 $50$ Hz 间隔，所以这两个音调在经过补零的汉宁窗频谱图中将被清晰地分辨出来。**\n该陈述揭示了一个常见但关键的误解。分辨两个紧密频率的能力取决于**窗函数频谱的主瓣宽度**，而主瓣宽度又由窗的类型及其长度 $L$ 决定。DFT 频率仓间距 $\\Delta f_{bin}$ 仅决定了所得频谱的采样密度。使用大的 $N$（补零）可以提供一个由窗函数决定的频谱的精细插值视图，但它本质上并不能提高“真实”的分辨率。条件 $\\Delta f > \\Delta f_{bin}$ 是分辨率的必要条件，但远非充分条件。\n**结论：错误。**\n\n**C. 对于长度为 $L$ 的汉宁窗，其主瓣的第一个谱零点大约出现在距离音调频率 $\\pm 2 F_{s}/L$ 的位置，因此对于等幅音调，实际可分辨的最小间隔约为 $2 F_{s}/L$。当 $L = 1024$ 且 $F_{s} = 48000$ 时，这个值约为 $93.75$ Hz，这意味着尽管进行了补零，这两个相隔 $50$ Hz 的音调也无法被分辨。**\n分辨率极限由窗的特性决定。对于长度为 $L$ 的汉宁窗，其主瓣比矩形窗的主瓣宽。其频谱响应的第一个零点位于距离中心频率 $\\pm 2/L$ 周/样本的频率偏移处。换算成赫兹，这对应于频率 $\\Delta f_{res} = \\frac{2 F_{s}}{L}$。这个值代表了汉宁窗的瑞利分辨率准则。\n我们来计算这个值：\n$$ \\Delta f_{res} = \\frac{2 \\times 48000 \\text{ Hz}}{1024} = \\frac{96000}{1024} \\text{ Hz} = 93.75 \\text{ Hz} $$\n两个音调的频率间隔是 $\\Delta f = 50$ Hz。由于 $\\Delta f  \\Delta f_{res}$（$50 \\text{ Hz}  93.75 \\text{ Hz}$），两个音调的主瓣将重叠到一定程度，以至于它们合并成一个更宽的单峰。它们不会被分辨为两个不同的峰。该陈述正确地得出了这个结论，并正确地指出补零不会改变这一事实。\n**结论：正确。**\n\n**D. 在保持 $L$ 固定的情况下增加 $N$ 会减小窗谱的主瓣宽度，从而提高真实的谱分辨率。**\n这在事实上是错误的。包括主瓣宽度在内的频谱特性是由窗函数 $w[n]$ 及其长度 $L$ 决定的。将 FFT 点数 $N$ 增加到超过 $L$ 的操作称为补零。补零等效于对加窗信号段的底层离散时间傅里叶变换 (DTFT) 的现有采样点之间进行插值。它不会改变该 DTFT 谱瓣的形状或宽度。因此，增加 $N$ 并不能提高真实的谱分辨率。\n**结论：错误。**\n\n**E. 增加 $L$（在窗类型固定的情况下）会提高频率分辨率，但会降低时间分辨率，因为有效的时间支撑区 $T = L/F_{s}$ 增加了。**\n该陈述正确地描述了应用于 STFT 的基本时频不确定性原理。\n- **频率分辨率**：窗主瓣的宽度与其长度 $L$ 成反比。例如，对于汉宁窗，分辨率约为 $2F_s/L$。增加 $L$ 会使这个值变小，意味着可以分辨更精细的频率细节。\n- **时间分辨率**：STFT 分析有效地将频谱估计定位在持续时间为 $T = L/F_{s}$ 的时间间隔内。更大的 $L$ 意味着更长的时间间隔，从而将时间事件在更宽的持续时间内平滑掉，降低了精确定位频率事件发生时间的能力。\n该陈述是对这种权衡的精确阐述。\n**结论：正确。**\n\n**F. 对于任何 $L$ 和任何窗类型，离散频率仓间距都等于窗的等效噪声带宽 (ENBW)。**\n这是错误的。离散频率仓间距为 $\\Delta f_{bin} = F_{s}/N$。等效噪声带宽 (ENBW) 以赫兹为单位表示时，是衡量窗滤波器响应有效宽度的指标，它取决于窗的形状和长度 $L$，但与 FFT 点数 $N$ 无关。以赫兹为单位的 ENBW 由 ENBW$_{\\text{Hz}} = \\text{ENBW}_{\\text{bins}} \\times \\frac{F_s}{L}$ 给出，其中 ENBW$_{\\text{bins}}$ 与窗类型有关，而与L无关。例如，对于汉宁窗，ENBW$_{\\text{bins}} \\approx 1.5$。因此，以赫兹为单位的 ENBW 约为 $1.5 \\times F_{s}/L$。这显然不等于频率仓间距 $F_s/N$。只有在特殊情况下（矩形窗且 N=L），ENBW 才等于频率仓间距。声称这对“任何”窗类型和任何 L, N 都成立是错误的。\n**结论：错误。**\n\n**G. 如果使用相同长度 $L$ 的矩形窗代替汉宁窗，瑞利分离（第一零点准则）约为 $F_{s}/L \\approx 46.875$ Hz，因此相隔 $50$ Hz 的两个等幅音调接近瑞利极限，在无噪声条件下可能勉强可以分辨。**\n对于长度为 $L$ 的矩形窗，其主瓣比汉宁窗的窄。其频谱（狄利克雷核）的第一个零点位于频率偏移为 $1/L$ 周/样本处，对应于频率 $\\Delta f_{res} = F_{s}/L$ 赫兹。这是矩形窗的瑞利准则。\n我们来计算这个值：\n$$ \\Delta f_{res} = \\frac{48000 \\text{ Hz}}{1024} = 46.875 \\text{ Hz} $$\n音调的间隔为 $\\Delta f = 50$ Hz。由于 $\\Delta f > \\Delta f_{res}$（$50 \\text{ Hz} > 46.875 \\text{ Hz}$），一个音调的频谱响应峰值正好落在另一个音调的第一个零点之外。这个条件使得这两个音调可以被区分为两个独立的峰，并且它们之间有一个可见的凹陷，因此它们是“勉强可分辨的”。该陈述的计算和结论都是准确的。\n**结论：正确。**", "answer": "$$\\boxed{ACEG}$$", "id": "2914032"}, {"introduction": "固定的分析窗口强加了一种“一刀切”的折衷方案，这对于具有多变特征的真实世界信号而言通常并非最佳选择。这个动手编程练习将挑战你构建一个能够动态管理分辨率权衡的自适应语谱图。你将设计并实现一个算法，该算法通过检验信号的局部平稳性，智能地在用于瞬态事件的短窗口和用于稳定音调的长窗口之间切换，这代表了从理论理解到实际算法设计的重大飞跃。[@problem_id:2914058]", "problem": "您的任务是指定并实现一种自适应谱图算法，该算法基于局部平稳性检验在短窗口和长窗口之间切换。您的设计必须从短时傅里叶变换（STFT）和谱图的定义、样本方差的定义以及时频分辨率受时宽-带宽不确定性关系约束的原理出发。您必须使用帧内谱方差与跨帧谱方差的比率来定义一个无量纲的检验统计量，制定一个决策规则，然后对几个具有已知基准真相的合成信号凭经验估计其检测误差。\n\n用作基础的定义：\n- 离散时间信号 $x[n]$ 使用窗口 $w[n]$ 和跳跃步长 $H$ 的短时傅里叶变换（STFT）是在帧 $x[n] w[n-mH]$ 上计算的复数谱序列 $X[m,k]$，其谱图为 $S[m,k] = \\lvert X[m,k] \\rvert^{2}$。\n- 对于任何有限的实数列表 $\\{ u_{j} \\}_{j=1}^{J}$，样本均值为 $\\bar{u} = \\frac{1}{J} \\sum_{j=1}^{J} u_{j}$，无偏样本方差为 $\\widehat{\\mathrm{var}}(u) = \\frac{1}{J-1} \\sum_{j=1}^{J} (u_{j} - \\bar{u})^{2}$。\n- 时频分辨率权衡：对于有效持续时间为 $\\Delta t$ 和有效带宽为 $\\Delta f$ 的窗口，存在一个不确定性约束，形式为 $\\Delta t \\, \\Delta f \\gtrsim \\frac{1}{4 \\pi}$，这表明较长的窗口产生更精细的频率分辨率但更粗糙的时间分辨率，反之亦然。\n\n需要实现的算法规范：\n- 设短窗口长度为 $N_{s}$，长窗口长度为 $N_{\\ell}$，两者均以样本数计量。所有周期图计算均使用汉宁窗。\n- 将信号划分为多个不重叠的分析上下文，每个上下文包含 $K$ 个短帧，因此一个上下文恰好包含 $K$ 个长度为 $N_{s}$ 样本、跳跃步长为 $N_{s}$ 的帧（在上下文中无重叠）。对于上下文索引 $i$，令 $P_{i}[f,t]$ 表示在上下文中，对于短帧 $t$ 在频率仓 $f$ 处的周期图幅值平方，该值由长度等于 $N_{s}$ 的离散傅里叶变换计算得出。仅使用由实数输入离散傅里叶变换产生的非负频率仓（从仓 $f = 0$ 到仓 $f = N_{s}/2$（含））。\n- 将上下文 $i$ 中帧 $t$ 的帧内谱方差（频率上的方差）定义为\n$$\nV_{\\mathrm{within}}(i,t) \\triangleq \\widehat{\\mathrm{var}}_{f} \\!\\left( P_{i}[f,t] \\right).\n$$\n将上下文 $i$ 中频率仓 $f$ 的跨帧谱方差（帧间的方差）定义为\n$$\nV_{\\mathrm{across}}(i,f) \\triangleq \\widehat{\\mathrm{var}}_{t} \\!\\left( P_{i}[f,t] \\right).\n$$\n将这些聚合为\n$$\nW(i) \\triangleq \\frac{1}{K} \\sum_{t=1}^{K} V_{\\mathrm{within}}(i,t), \\quad\nA(i) \\triangleq \\frac{1}{F} \\sum_{f=1}^{F} V_{\\mathrm{across}}(i,f),\n$$\n其中 $F \\triangleq \\frac{N_{s}}{2} + 1$ 是非负频率仓的数量。\n- 定义局部平稳性比率\n$$\nR(i) \\triangleq \\frac{W(i)}{A(i) + \\varepsilon},\n$$\n其中有一个小的正则化常数 $\\varepsilon > 0$ 以避免除以零。使用 $\\varepsilon = 10^{-12}$。\n- 上下文 $i$ 处窗口切换的决策规则：如果对于阈值 $\\tau > 0$，有 $R(i) \\ge \\tau$，则声明上下文 $i$ 为局部平稳，并为该上下文选择长窗口长度 $N_{\\ell}$；否则声明其为局部非平稳，并选择短窗口长度 $N_{s}$。\n\n检测误差分析：\n- 对于一组具有已知基准真相平稳性标签的上下文，按如下方式计算经验假阳性率（FPR）和经验假阴性率（FNR）。令 $\\mathcal{I}_{\\mathrm{stat}}$ 为根据基准真相确实为平稳的上下文的索引集，令 $\\mathcal{I}_{\\mathrm{nonstat}}$ 为确实为非平稳的上下文的索引集。令 $\\widehat{y}(i) \\in \\{ 0, 1 \\}$ 为上下文 $i$ 的检测标签，其中 $\\widehat{y}(i) = 1$ 表示平稳，$\\widehat{y}(i) = 0$ 表示非平稳。经验假阳性率为\n$$\n\\mathrm{FPR} \\triangleq \\frac{1}{\\lvert \\mathcal{I}_{\\mathrm{stat}} \\rvert} \\sum_{i \\in \\mathcal{I}_{\\mathrm{stat}}} \\mathbb{1}\\{ \\widehat{y}(i) = 0 \\},\n$$\n经验假阴性率为\n$$\n\\mathrm{FNR} \\triangleq \\frac{1}{\\lvert \\mathcal{I}_{\\mathrm{nonstat}} \\rvert} \\sum_{i \\in \\mathcal{I}_{\\mathrm{nonstat}}} \\mathbb{1}\\{ \\widehat{y}(i) = 1 \\}.\n$$\n如果分母为零（即没有该类型的上下文），则将相应的误差定义为 $0$。\n\n信号模型和基准真相：\n- 平稳上下文：两个固定频率的正弦波与加性高斯白噪声之和，其在上下文内具有时不变的二阶结构。出于此测试的目的，这被视为局部平稳。\n- 非平稳上下文：一个线性调频信号，其瞬时频率在上下文持续时间内扫过整个频带，外加加性高斯白噪声；这具有时变的二阶结构，被视为局部非平稳。\n- 为了控制加性噪声，将以分贝为单位的信噪比（SNR）定义为 $\\mathrm{SNR_{dB}} = 10 \\log_{10}(P_{\\mathrm{sig}} / P_{\\mathrm{noise}})$，并缩放噪声以在每个上下文中相对于确定性分量功率达到所要求的信噪比。所有误差率输出必须表示为小数（而非百分比）。\n\n测试套件：\n实现您的程序，以在以下四个参数集上评估该算法。在每种情况下，使用赫兹为单位的采样频率 $f_{s}$，并生成恰好 $C = 24$ 个上下文，每个上下文长为 $K$ 个短帧，帧长为 $N_{s}$，跳跃步长为 $N_{s}$。对于混合情况，从上下文索引 $i = 0$ 处的平稳上下文开始，交替出现平稳和非平稳上下文。\n- 情况 1：$f_{s} = 8000$， $N_{s} = 256$， $N_{\\ell} = 2048$， $K = 8$， $\\tau = 1.0$， $\\mathrm{SNR_{dB}} = 10$， 模式 = 混合（交替平稳和非平稳上下文）。\n- 情况 2：$f_{s} = 8000$， $N_{s} = 128$， $N_{\\ell} = 1024$， $K = 6$， $\\tau = 0.9$， $\\mathrm{SNR_{dB}} = 0$， 模式 = 混合。\n- 情况 3：$f_{s} = 8000$， $N_{s} = 256$， $N_{\\ell} = 2048$， $K = 8$， $\\tau = 1.05$， $\\mathrm{SNR_{dB}} = 10$， 模式 = 仅平稳。\n- 情况 4：$f_{s} = 8000$， $N_{s} = 256$， $N_{\\ell} = 2048$, $K = 8$, $\\tau = 0.9$, $\\mathrm{SNR_{dB}} = 10$, 模式 = 仅非平稳。\n\n需要遵守的实现细节：\n- 所有周期图计算均使用汉宁窗。\n- 使用实数输入离散傅里叶变换以仅获取非负频率仓。\n- 为保证可复现性，在程序开始时固定一个您选择的随机种子。\n- 对于每个测试用例，通过连接 $C$ 个上下文来构建信号，并使用比率检验为每个上下文计算一个决策。然后，将经验 $\\mathrm{FPR}$ 和 $\\mathrm{FNR}$ 计算为小数。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个双元素列表 $[\\mathrm{FPR}, \\mathrm{FNR}]$。因此，最后一行必须看起来像\n$[ [r_{1}, s_{1}], [r_{2}, s_{2}], [r_{3}, s_{3}], [r_{4}, s_{4}] ]$\n其中每个 $r_{j}$ 和 $s_{j}$ 都是一个小数。", "solution": "问题陈述经评估为**有效**。它提出了一个在数字信号处理领域内自成体系、有科学依据且定义明确的问题。所有必要的定义、参数和程序均已提供，从而可以进行唯一且可验证的实现。使用谱方差比率来检验局部平稳性的核心思想，是一个植根于平稳和非平稳过程基本属性的合理启发式方法。\n\n虽然问题是有效的，但值得注意的是，用于误差度量的术语，特别是“假阳性率”（$\\mathrm{FPR}$）和“假阴性率”（$\\mathrm{FNR}$），用法并不常规。通常，如果“阳性”类别是检测到一个事件（例如，非平稳性），那么假阳性是指错误地将阴性案例（平稳性）声明为阳性。问题的 $\\mathrm{FNR}$ 公式实际上计算的是这个量值。反之，问题的 $\\mathrm{FPR}$ 公式计算的则是通常意义上的假阴性率（或漏检率）。然而，由于问题为 $\\mathrm{FPR}$ 和 $\\mathrm{FNR}$ 提供了明确无误的数学定义，我们将严格遵守这些定义。实现将基于所提供的公式，而不是常规的术语解释。\n\n该算法旨在解决信号分析中根本性的时频分辨率权衡问题，这是不确定性原理（$\\Delta t \\, \\Delta f \\gtrsim \\frac{1}{4 \\pi}$）的一个结果。对于一个统计特性并非恒定的信号，单一的分析窗口长度选择是次优的。长窗口提供良好的频率分辨率但时间分辨率差，会将瞬态事件在其持续时间内模糊掉。短窗口提供良好的时间分辨率但频率分辨率差。自适应谱图试图通过选择适合信号局部特征的窗口长度来缓解这一问题。\n\n所提出的方法依赖于一个局部平稳性检验。如果一个信号的谱内容在给定的分析上下文中大致恒定，则该信号是局部平稳的。\n量 $P_{i}[f,t]$，即上下文 $i$ 中帧 $t$ 的周期图，表示信号功率在频率仓 $f$ 上的分布。\n\n平稳性检验的核心是比率 $R(i) \\triangleq \\frac{W(i)}{A(i) + \\varepsilon}$。其基本原理如下：\n1. 项 $W(i)$ 是帧内谱方差的平均值，$V_{\\mathrm{within}}(i,t) = \\widehat{\\mathrm{var}}_{f} ( P_{i}[f,t] )$。该量度量了单帧内频谱的结构复杂性或“峰度”。由少数强正弦波组成的信号将具有高能量峰和低能量谷的频谱，导致在频率仓 $f$ 上的方差很大。\n2. 项 $A(i)$ 是跨帧谱方差的平均值，$V_{\\mathrm{across}}(i,f) = \\widehat{\\mathrm{var}}_{t} ( P_{i}[f,t] )$。该量度量了在上下文内的帧 $t$ 上，每个频率仓 $f$ 处的功率变化程度。对于一个真正的平稳信号，频谱是时不变的，因此该方差应该很低，理想情况下仅由加性噪声引起。对于一个非平稳信号，如主导频率扫过频带的线性调频信号，任何给定频率仓的能量会随时间显著变化，导致较大的跨帧方差。\n\n因此，对于一个平稳信号上下文（例如，噪声中的正弦波），我们预期 $W(i)$ 较大而 $A(i)$ 较小，从而导致比率 $R(i)$ 较大。\n对于一个非平稳信号上下文（例如，线性调频信号），我们预期 $A(i)$ 较大，这将使得比率 $R(i)$ 较小。\n决策规则，“若 $R(i) \\ge \\tau$，则声明为平稳”，直接形式化了这一原则。检验统计量 $R(i)$ 的较大值提供了平稳性的证据。\n\n基于此决策，算法为该上下文选择窗口长度。平稳上下文用长窗口 $N_{\\ell}$ 进行分析以获得精细的频率分辨率，这是允许的，因为信号的属性在此较长持续时间内是稳定的。非平稳上下文用短窗口 $N_{s}$ 进行分析以保持时间局部性，同时接受较粗糙的频率分辨率。\n\n实现过程首先根据指定的模式（`mixed`、`stationary-only`或`nonstationary-only`）和基准真相标签，通过连接 $C=24$ 个上下文来为每个测试用例合成信号。然后逐个上下文地处理该信号。对于每个上下文，计算一个周期图矩阵 $P_i$，并由此确定 $W(i)$ 和 $A(i)$。将比率 $R(i)$ 与阈值 $\\tau$ 进行比较，得出决策 $\\widehat{y}(i)$。最后，将预测标签 $\\widehat{y}(i)$ 与基准真相标签进行比较，以精确地根据给定的公式计算经验误差率 $\\mathrm{FPR}$ 和 $\\mathrm{FNR}$。固定的随机种子确保了信号中噪声分量的可复现性，从而也保证了最终结果的可复现性。\n\n无偏样本方差的计算，$\\widehat{\\mathrm{var}}(u) = \\frac{1}{J-1} \\sum_{j=1}^{J} (u_{j} - \\bar{u})^{2}$，需要一个自由度为 $1$ 的校正，这通过在方差计算中设置 `ddof=1` 来处理。跨帧方差的聚合，$A(i) \\triangleq \\frac{1}{F} \\sum_{f=1}^{F} V_{\\mathrm{across}}(i,f)$，是通过对所有非负频率仓的方差求和，然后除以非负频率仓的总数 $F$ 来实现的，如规定所示。", "answer": "```python\nimport numpy as np\nfrom scipy.signal import chirp\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the signal generation, analysis,\n    and error calculation for the specified test cases.\n    \"\"\"\n    np.random.seed(42)  # For reproducibility\n\n    test_cases = [\n        {'fs': 8000, 'Ns': 256, 'Nl': 2048, 'K': 8, 'tau': 1.0, 'snr_db': 10, 'mode': 'mixed'},\n        {'fs': 8000, 'Ns': 128, 'Nl': 1024, 'K': 6, 'tau': 0.9, 'snr_db': 0, 'mode': 'mixed'},\n        {'fs': 8000, 'Ns': 256, 'Nl': 2048, 'K': 8, 'tau': 1.05, 'snr_db': 10, 'mode': 'stationary-only'},\n        {'fs': 8000, 'Ns': 256, 'Nl': 2048, 'K': 8, 'tau': 0.9, 'snr_db': 10, 'mode': 'nonstationary-only'},\n    ]\n\n    total_contexts = 24\n    epsilon = 1e-12\n\n    def generate_context_signal(length_samples, fs, snr_db, is_stationary):\n        \"\"\"Generates a single signal context (stationary or nonstationary).\"\"\"\n        t = np.arange(length_samples) / fs\n        \n        if is_stationary:\n            # Sum of two sinusoids\n            f1, f2 = 500.0, 1500.0\n            signal_det = np.sin(2 * np.pi * f1 * t) + np.sin(2 * np.pi * f2 * t)\n        else:\n            # Linear chirp\n            f_start, f_end = 200.0, fs / 2 - 200.0\n            signal_det = chirp(t, f0=f_start, f1=f_end, t1=t[-1], method='linear')\n\n        # Calculate signal power and add noise\n        power_sig = np.mean(signal_det**2)\n        if power_sig == 0:\n            power_sig = 1e-10\n\n        snr_linear = 10**(snr_db / 10.0)\n        power_noise = power_sig / snr_linear\n        noise_std = np.sqrt(power_noise)\n        noise = np.random.normal(0, noise_std, length_samples)\n        \n        return signal_det + noise\n\n    def analyze_signal(full_signal, Ns, K, fs, tau):\n        \"\"\"Analyzes the full signal context by context to make stationarity decisions.\"\"\"\n        context_len_samples = Ns * K\n        num_contexts = len(full_signal) // context_len_samples\n        y_pred = []\n        \n        window = np.hanning(Ns)\n        F = Ns // 2 + 1\n\n        for i in range(num_contexts):\n            context_signal = full_signal[i * context_len_samples : (i + 1) * context_len_samples]\n            \n            periodograms = np.zeros((K, F))\n            \n            for t_idx in range(K):\n                frame = context_signal[t_idx * Ns : (t_idx + 1) * Ns]\n                frame_windowed = frame * window\n                spectrum = np.fft.rfft(frame_windowed)\n                periodograms[t_idx, :] = np.abs(spectrum)**2\n            \n            # Calculate W(i)\n            V_within_per_frame = np.var(periodograms, axis=1, ddof=1)\n            W = np.mean(V_within_per_frame)\n            \n            # Calculate A(i)\n            V_across_per_freq = np.var(periodograms, axis=0, ddof=1)\n            # As per problem, sum over all F bins then divide by F\n            A = np.sum(V_across_per_freq[1:]) / F\n            \n            # Calculate ratio and make decision\n            R = W / (A + epsilon)\n            \n            # stationary if R >= tau. y_hat = 1 for stationary, 0 for nonstationary.\n            decision = 1 if R >= tau else 0\n            y_pred.append(decision)\n            \n        return np.array(y_pred)\n\n    def calculate_errors(y_true, y_pred):\n        \"\"\"Calculates FPR and FNR based on the problem's explicit definitions.\"\"\"\n        y_true = np.array(y_true)\n        y_pred = np.array(y_pred)\n        \n        # Indices of true stationary and nonstationary contexts\n        I_stat = np.where(y_true == 1)[0]\n        I_nonstat = np.where(y_true == 0)[0]\n        \n        # Calculate FPR as defined: fraction of true stationaries misclassified as nonstationary\n        if len(I_stat) == 0:\n            FPR = 0.0\n        else:\n            misclassified_stat = np.sum(y_pred[I_stat] == 0)\n            FPR = misclassified_stat / len(I_stat)\n            \n        # Calculate FNR as defined: fraction of true nonstationaries misclassified as stationary\n        if len(I_nonstat) == 0:\n            FNR = 0.0\n        else:\n            misclassified_nonstat = np.sum(y_pred[I_nonstat] == 1)\n            FNR = misclassified_nonstat / len(I_nonstat)\n            \n        return [FPR, FNR]\n\n    final_results = []\n    for params in test_cases:\n        Ns, K, fs, mode = params['Ns'], params['K'], params['fs'], params['mode']\n        \n        context_len = Ns * K\n        full_signal = np.array([])\n        y_true = []\n\n        for i in range(total_contexts):\n            if mode == 'mixed':\n                is_stationary = (i % 2 == 0)\n            elif mode == 'stationary-only':\n                is_stationary = True\n            else: # nonstationary-only\n                is_stationary = False\n            \n            # y=1 for stationary, y=0 for nonstationary\n            y_true.append(1 if is_stationary else 0)\n            \n            context_sig = generate_context_signal(context_len, fs, params['snr_db'], is_stationary)\n            full_signal = np.concatenate((full_signal, context_sig))\n            \n        y_pred = analyze_signal(full_signal, Ns, K, fs, params['tau'])\n        \n        errors = calculate_errors(y_true, y_pred)\n        final_results.append(errors)\n\n    # Format the final output string exactly as required.\n    print(f\"[{','.join(str(e) for e in final_results)}]\")\n\nsolve()\n```", "id": "2914058"}]}