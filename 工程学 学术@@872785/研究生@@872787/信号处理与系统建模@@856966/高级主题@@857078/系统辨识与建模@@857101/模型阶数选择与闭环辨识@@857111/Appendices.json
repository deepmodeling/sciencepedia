{"hands_on_practices": [{"introduction": "在选择模型阶数之前，我们必须对“阶数”的真正含义有牢固的把握。本练习旨在通过将麦克米伦阶数（McMillan degree）这一抽象概念与系统传递函数及其状态空间实现等具体结构联系起来，从而巩固我们的理解。通过完成此推导练习 [@problem_id:2883933]，您将加深对系统内部复杂性与其输入输出描述之间基本关系的认识。", "problem": "一个在单位反馈中运行的单输入单输出 (SISO) 离散时间线性时不变 (LTI) 对象，在移位算子域中由一个形如 $G(q)$ 的传递函数建模\n$$\nG(q) \\;=\\; \\frac{b_0 + b_1 q^{-1} + b_2 q^{-2}}{1 + a_1 q^{-1} + a_2 q^{-2} + a_3 q^{-3}},\n$$\n其中 $q$ 是前向移位算子，而 $a_1$、$a_2$、$a_3$、$b_0$、$b_1$、$b_2$ 是实系数。假设分子和分母多项式互质（$G(q)$ 中没有极点-零点对消），并且该对象与一个严格真分控制器在闭环中运行\n$$\nC(q) \\;=\\; \\frac{\\alpha_0 + \\alpha_1 q^{-1}}{1 + \\beta_1 q^{-1}},\n$$\n在单位反馈中。闭环系统是内部稳定的，并且在环路中 $G(q)$ 和 $C(q)$ 之间没有极点-零点对消。\n\n从有理传递函数的定义、麦克米伦阶 (McMillan degree) 的概念以及基本框图代数出发，完成以下任务：\n\n- 仅使用基本定义，在给定的互质假设下，确定与 $G(q)$ 兼容的对象模型的最小动态阶数 $n$（麦克米伦阶）。\n- 推导 $G(q)$ 的一个能控标准型状态空间实现 $(A,B,C,D)$，其矩阵用 $a_1$、$a_2$、$a_3$、$b_0$、$b_1$、$b_2$ 符号化表示。您的推导必须从与 $z$ 变换相关的复变量 $z$ 的定义 $G(z)=C\\,(zI-A)^{-1}B+D$ 以及与 $G(q)$ 分母相关的特征多项式出发。\n- 仅使用标准框图代数，推导从参考信号 $r$ 到输出 $y$ 的闭环传递函数（用 $G(q)$ 和 $C(q)$ 表示），并简要说明在什么样的关于互质性和持续激励的结构条件下，闭环数据允许在没有降阶偏差的情况下辨识出正确的对象阶数 $n$。\n\n最终答案仅给出最小动态阶数 $n$ 的值。无需四舍五入，不涉及单位。请以整数形式表示您的答案。", "solution": "所述问题需要经过验证。\n\n**第一步：提取已知条件**\n- 对象传递函数：$G(q) = \\frac{b_0 + b_1 q^{-1} + b_2 q^{-2}}{1 + a_1 q^{-1} + a_2 q^{-2} + a_3 q^{-3}}$，其中 $q$ 是前向移位算子，系数为实数。\n- 对象属性：$G(q)$ 的分子和分母多项式互质。\n- 控制器传递函数：$C(q) = \\frac{\\alpha_0 + \\alpha_1 q^{-1}}{1 + \\beta_1 q^{-1}}$。\n- 控制器属性：$C(q)$ 是严格真分的。\n- 系统配置：单位反馈闭环。\n- 系统属性：闭环系统是内部稳定的。$G(q)$ 和 $C(q)$ 之间没有极点-零点对消。\n\n**第二步：验证**\n该问题在线性系统理论和系统辨识领域内是良定义的。传递函数、状态空间实现、麦克米伦阶和闭环辨识等概念都是标准的。控制器 $C(q)$ 是“严格真分”的这一陈述对其系数施加了一个约束。如果 $\\lim_{z \\to \\infty} H(z) = 0$，则传递函数 $H(z)$ 是严格真分的。对于 $C(q)$，在 $z$ 变换变量下为 $C(z) = \\frac{\\alpha_0 + \\alpha_1 z^{-1}}{1 + \\beta_1 z^{-1}}$，该极限为 $\\alpha_0$。因此，严格真分的条件意味着 $\\alpha_0=0$。这不是一个矛盾，而是一个必须使用的规范。所有其他条件都是一致且自洽的。该问题具有科学依据，是客观且适定的。\n\n**第三步：结论**\n问题有效。将提供解答。\n\n问题包括三个部分，将按顺序进行解答。\n\n**第一部分：对象的最小动态阶数**\n\n由有理传递函数描述的系统的最小动态阶数是其麦克米伦阶。麦克米伦阶被定义为系统最小状态空间实现的维数。对于单输入单输出 (SISO) 系统，麦克米伦阶等于在分子和分母多项式之间所有公因式都被对消后，传递函数分母的阶数。\n\n给定的对象传递函数为：\n$$\nG(q) = \\frac{N(q^{-1})}{D(q^{-1})} = \\frac{b_0 + b_1 q^{-1} + b_2 q^{-2}}{1 + a_1 q^{-1} + a_2 q^{-2} + a_3 q^{-3}}\n$$\n这里，多项式用不定元 $q^{-1}$ 表示。分母多项式为 $D(q^{-1}) = 1 + a_1 q^{-1} + a_2 q^{-2} + a_3 q^{-3}$。假设 $a_3 \\neq 0$，该多项式的阶数为 $3$。如果 $a_3=0$，阶数会更低，但给出的形式意味着三阶分母是需要考虑的一般情况。表示这个分母所需的最小阶数是 $3$。\n\n问题陈述分子和分母多项式是互质的。这是一个关键条件，因为它意味着没有公共根，因此不会发生极点-零点对消来降低系统的阶数。\n\n因此，麦克米伦阶（记为 $n$）等于分母多项式 $D(q^{-1})$ 的阶数。所以，对象模型的最小动态阶数是 $n=3$。\n\n**第二部分：能控标准型状态空间实现**\n\n我们的任务是为 $G(q)$ 找到一个能控标准型状态空间实现 $(A,B,C,D)$。我们首先按照要求，将传递函数从移位算子 $q$ 转换为 $z$ 变换表示法中使用的复变量 $z$。\n$$\nG(z) = \\frac{b_0 + b_1 z^{-1} + b_2 z^{-2}}{1 + a_1 z^{-1} + a_2 z^{-2} + a_3 z^{-3}}\n$$\n为了使用标准的状态空间形式，我们通过将分子和分母乘以 $z^3$ 来用 $z$ 的正幂次表示 $G(z)$：\n$$\nG(z) = \\frac{z^3(b_0 + b_1 z^{-1} + b_2 z^{-2})}{z^3(1 + a_1 z^{-1} + a_2 z^{-2} + a_3 z^{-3})} = \\frac{b_0 z^3 + b_1 z^2 + b_2 z}{z^3 + a_1 z^2 + a_2 z + a_3}\n$$\n如果 $b_0 \\neq 0$，这个传递函数是真分的但不是严格真分的。我们可以通过多项式长除法将其分离为一个严格真分部分和一个直接馈通项 $D$：\n$$\nG(z) = b_0 + \\frac{(b_1 - b_0 a_1)z^2 + (b_2 - b_0 a_2)z - b_0 a_3}{z^3 + a_1 z^2 + a_2 z + a_3}\n$$\n根据这个分解，直接馈通矩阵（在本例中为标量）是 $D = b_0$。剩余的严格真分部分是：\n$$\nG_{sp}(z) = \\frac{\\beta_1 z^2 + \\beta_2 z + \\beta_3}{z^3 + \\alpha_1 z^2 + \\alpha_2 z + \\alpha_3}\n$$\n其中对于 $k=1,2,3$，$\\alpha_k = a_k$，并且分子系数为 $\\beta_1 = b_1 - b_0 a_1$，$\\beta_2 = b_2 - b_0 a_2$，以及 $\\beta_3 = -b_0 a_3$。\n\n对于分母为 $z^3 + a_1 z^2 + a_2 z + a_3$、分子为 $\\beta_1 z^2 + \\beta_2 z + \\beta_3$ 的一般三阶严格真分系统，其能控标准型由以下矩阵给出：\n$$\nA = \\begin{pmatrix} -a_1 & -a_2 & -a_3 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}, \\quad C = \\begin{pmatrix} \\beta_1 & \\beta_2 & \\beta_3 \\end{pmatrix}\n$$\n代入 $\\beta_1$、$\\beta_2$ 和 $\\beta_3$ 的表达式，我们得到完整系统 $G(z) = C(zI-A)^{-1}B+D$ 的状态空间矩阵：\n$$\nA = \\begin{pmatrix} -a_1 & -a_2 & -a_3 \\\\ 1 & 0 & 0 \\\\ 0 & 1 & 0 \\end{pmatrix}\n$$\n$$\nB = \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n$$\nC = \\begin{pmatrix} b_1 - b_0 a_1 & b_2 - b_0 a_2 & -b_0 a_3 \\end{pmatrix}\n$$\n$$\nD = b_0\n$$\n这组矩阵 $(A,B,C,D)$ 构成了给定传递函数 $G(q)$ 的一个能控标准型实现。该矩阵 $A$ 的特征多项式是 $\\det(zI-A) = z^3 + a_1 z^2 + a_2 z + a_3$，这与 $G(z)$ 的分母相匹配，从而证实了从第一性原理推导的正确性。\n\n**第三部分：闭环辨识条件**\n\n系统在单位反馈配置下运行。设 $r(t)$ 是参考输入，$y(t)$ 是对象输出，$u(t)$ 是控制信号。误差为 $e(t) = r(t) - y(t)$。控制器和对象的方程分别为 $u(q) = C(q)e(q)$ 和 $y(q) = G(q)u(q)$。\n代入这些关系，我们推导出从 $r$ 到 $y$ 的闭环传递函数 $T(q)$：\n$$\ny(q) = G(q) C(q) (r(q) - y(q))\n$$\n$$\ny(q) (1 + G(q)C(q)) = G(q)C(q) r(q)\n$$\n$$\nT(q) = \\frac{y(q)}{r(q)} = \\frac{G(q)C(q)}{1 + G(q)C(q)}\n$$\n要从闭环数据（例如 $u(t)$ 和 $y(t)$ 的记录）中无偏地辨识出对象阶数 $n=3$，数据必须具有足够的信息量以激励对象的所有动态模态。必须满足两个主要条件：\n\n1.  **结构条件（互质性）：** 对象 $G(q)$ 和控制器 $C(q)$ 之间不得有极点-零点对消。例如，如果 $G(q)$ 的一个极点同时也是 $C(q)$ 的一个零点，则控制器将不会生成能够激励该特定对象模态的输入信号 $u(t)$。该模态将因此从输入输出数据中“隐藏”或不可观测，导致辨识过程产生一个降阶模型。问题陈述已明确此条件得到满足。设 $G(q) = N_G/D_G$ 和 $C(q) = N_C/D_C$。闭环特征多项式为 $D_{CL} = D_G D_C + N_G N_C$。如果 $D_G$ 和 $N_C$ 有公因式（极点-零点对消），或者 $N_G$ 和 $D_C$ 有公因式，则 $D_{CL}$ 的阶数可能会低于对象和控制器分母阶数之和，但这与输入输出数据的信息含量是不同的问题。关键在于输入 $u(t)$ 必须激励 $G(q)$ 的所有模态。从 $r$ 到 $u$ 的传递函数是 $S_u(q) = \\frac{C(q)}{1+G(q)C(q)}$。如果 $C(q)$ 有一个零点与 $G(q)$ 的一个极点匹配，则该极点将不会出现在 $S_u(q)$ 中，因此不会被 $r$ 激励。\n\n2.  **激励条件（持续激励）：** 外部参考信号 $r(t)$ 必须是足够高阶的“持续激励”信号。如果一个信号的统计特性足够丰富，能够区分多达 $M$ 个线性依赖关系，则称其为 $M$ 阶持续激励。在带有线性时不变控制器的闭环中，外部信号 $r(t)$ 的频谱特性会通过环路动态进行滤波，从而生成对象输入 $u(t)$。如果 $r(t)$ 不够丰富（例如，一个简单的正弦波），$u(t)$ 也会缺乏丰富性，即使互质条件成立，也无法激励对象的所有模态。为了一致地估计模型参数，输入信号的持续激励阶数必须与参数数量相关。对于一个阶数为 $n=3$ 的 ARX 模型，这要求 $u(t)$ 至少是 $3$ 阶持续激励。为保证这一点，外部信号 $r(t)$ 的持续激励阶数必须至少等于闭环系统的预期复杂度，即 $n + \\text{ord}(C) = 3 + 1 = 4$。\n\n总而言之，结构条件是对象和控制器传递函数的互质性，这可以防止控制器选择性地忽略某些对象动态。这一条件与持续激励的外部参考信号相结合，确保了收集到的数据对于辨识正确的对象阶数 $n$ 具有足够的信息量。", "answer": "$$\\boxed{3}$$", "id": "2883933"}, {"introduction": "许多强大的系统辨识技术都属于预测误差方法（Prediction Error Methods, PEM）的范畴，而PEM的核心在于一步向前预测器。本实践 [@problem_id:2883861] 要求您从第一性原理出发，为广泛使用的ARMAX模型结构推导其预测器，从而揭示模型参数如何与最小化预测误差内在地联系在一起。理解这一推导过程是掌握如何将数据转化为动态模型的关键。", "problem": "考虑一个在闭环中运行的离散时间、线性时不变、单输入单输出系统，其中测量的输入输出数据 $\\{u(t), y(t)\\}$ 由通用阶数 $(n_a, n_b, n_c, n_k)$ 的带外生输入的自回归移动平均 (ARMAX) 结构建模：\n$$\nA(q) y(t) \\;=\\; B(q) q^{-n_k} u(t) \\;+\\; C(q) e(t),\n$$\n其中 $A(q) \\,=\\, 1 + a_{1} q^{-1} + \\cdots + a_{n_a} q^{-n_a}$，$B(q) \\,=\\, b_{1} q^{-1} + \\cdots + b_{n_b} q^{-n_b}$，$C(q) \\,=\\, 1 + c_{1} q^{-1} + \\cdots + c_{n_c} q^{-n_c}$，且 $q^{-1}$ 是单位延迟（后移）算子。假设 $A(q)$ 和 $C(q)$ 是稳定的，且 $C(q)$ 是最小相位的（因此是可逆的），并且 $e(t)$ 是一个零均值、独立同分布的白噪声序列，具有有限方差，且独立于 $u(t)$。数据是在带有稳定线性控制器的闭环中采集的，但此任务不需要控制器的动态特性；仅使用测量的序列 $\\{u(t), y(t)\\}$。\n\n从条件期望和最小方差预测的正交性原理的定义出发，并且不使用任何快捷公式，推导上述ARMAX模型的一步超前预测误差 $\\varepsilon(t;\\theta)$ 和相应的一步超前预测器 $\\hat{y}(t \\mid t-1)$，并用 $A(q)$、$B(q)$、$C(q)$、$q^{-1}$ 和 $n_k$ 表示。您的推导应明确利用 $C(q)$ 的可逆性和 $e(t)$ 的新息特性，并应阐明为什么当最优预测器表示为 $\\{u(t), y(t)\\}$ 中的因果算子时，闭环操作不会改变其代数形式。\n\n请提供最终的预测器，形式为一个将 $\\{y(t), u(t)\\}$ 映射到 $\\hat{y}(t \\mid t-1)$ 的单一闭式算子表达式，仅使用 $A(q)$、$B(q)$、$C(q)$、$q^{-1}$ 和 $n_k$。最终答案必须是单一的解析表达式，不带单位，其中不嵌入任何不等式或方程。不需要进行数值舍入。", "solution": "所提出的问题是系统辨识理论中的一个标准练习，问题是适定的、有科学依据的，并包含了严谨推导所需的所有必要信息。因此，该问题被认为是 **有效的**。\n\n目标是推导ARMAX模型的一步超前预测器 $\\hat{y}(t \\mid t-1)$ 和相应的预测误差 $\\varepsilon(t;\\theta)$。预测器定义为给定截至时间 $t-1$ 的所有可用信息下，输出 $y(t)$ 的条件期望。这个信息集用 $\\mathcal{I}_{t-1}$ 表示，包含截至时间 $t-1$ 的所有过去和当前的输入以及截至时间 $t-1$ 的所有过去的输出，即 $\\mathcal{I}_{t-1} = \\{u(t-1), u(t-2), \\dots, y(t-1), y(t-2), \\dots\\}$。对于最小方差估计，预测器由下式给出：\n$$\n\\hat{y}(t \\mid t-1) = E[y(t) \\mid \\mathcal{I}_{t-1}]\n$$\n相应的预测误差定义为 $\\varepsilon(t) = y(t) - \\hat{y}(t \\mid t-1)$。根据正交性原理，该误差必须与 $\\mathcal{I}_{t-1}$ 中数据的任何函数都不相关。在给定的问题中，项 $e(t)$ 被定义为一个零均值、独立同分布的白噪声序列，独立于过去的数据。这使得 $e(t)$ 成为新息过程，它是过程在时间 $t$ 的基本不可预测分量。因此，我们的目标是证明预测误差恰好是这个新息项，即 $\\varepsilon(t) = e(t)$。\n\n我们从ARMAX模型方程开始：\n$$\nA(q) y(t) = B(q) q^{-n_k} u(t) + C(q) e(t)\n$$\n其中 $\\theta$ 代表多项式 $A(q)$、$B(q)$ 和 $C(q)$ 中所有系数的集合。推导的核心是重排这个方程，将 $y(t)$ 表示为一个可从 $\\mathcal{I}_{t-1}$ 预测的项与另一个不可预测的项之和。这个不可预测的项必须是 $e(t)$。\n\n我们可以如下重排ARMAX方程来分离 $y(t)$：\n$$\ny(t) + \\sum_{i=1}^{n_a} a_i y(t-i) = \\sum_{i=1}^{n_b} b_i u(t-n_k-i) + e(t) + \\sum_{i=1}^{n_c} c_i e(t-i)\n$$\n这可以用移位算子多项式写成：\n$$\ny(t) = (1 - A(q)) y(t) + B(q) q^{-n_k} u(t) + (C(q) - 1) e(t) + e(t)\n$$\n现在，我们将条件期望算子 $E[\\cdot \\mid \\mathcal{I}_{t-1}]$ 应用于 $y(t)$ 的这个表达式：\n$$\n\\hat{y}(t \\mid t-1) = E \\left[ (1 - A(q)) y(t) + B(q) q^{-n_k} u(t) + (C(q) - 1) e(t) + e(t) \\mid \\mathcal{I}_{t-1} \\right]\n$$\n根据期望的线性性质，我们可以分别考虑每一项：\n1. 项 $(1-A(q))y(t) = -a_1 y(t-1) - \\dots - a_{n_a} y(t-n_a)$ 是过去输出的函数，这些输出包含在 $\\mathcal{I}_{t-1}$ 中。因此，它在时间 $t-1$ 是已知的，其条件期望就是它本身。\n2. 项 $B(q)q^{-n_k}u(t) = b_1 u(t-n_k-1) + \\dots + b_{n_b} u(t-n_k-n_b)$ 是过去输入的函数（按标准假设 $n_k \\ge 1$），这些输入在 $\\mathcal{I}_{t-1}$ 中。因此，它在时间 $t-1$ 也是已知的。\n3. 项 $(C(q) - 1)e(t) = c_1 e(t-1) + \\dots + c_{n_c} e(t-n_c)$ 是过去新息的函数。关键的假设是 $C(q)$ 是可逆的（稳定的且最小相位）。这允许我们通过关系式 $e(\\tau) = C^{-1}(q) [A(q)y(\\tau) - B(q)q^{-n_k}u(\\tau)]$，将 $\\tau < t$ 的过去新息 $e(\\tau)$ 用测量数据 $\\{y(s), u(s)\\}_{s \\le \\tau}$ 表示。因此，序列 $\\{e(t-1), e(t-2), \\dots\\}$ 相对于由 $\\mathcal{I}_{t-1}$ 生成的sigma代数是可测的，并被认为是已知的。\n4. 项 $e(t)$ 根据定义是时间 $t$ 的新息。它是一个零均值过程，且独立于所有过去的信息。因此，$E[e(t) \\mid \\mathcal{I}_{t-1}] = E[e(t)] = 0$。\n\n综合这些结果，我们得到预测器：\n$$\n\\hat{y}(t \\mid t-1) = (1 - A(q)) y(t) + B(q) q^{-n_k} u(t) + (C(q) - 1) e(t)\n$$\n由此，预测误差 $\\varepsilon(t)$ 为：\n$$\n\\varepsilon(t) = y(t) - \\hat{y}(t \\mid t-1) = y(t) - \\left[ (1 - A(q)) y(t) + B(q) q^{-n_k} u(t) + (C(q) - 1) e(t) \\right]\n$$\n代入ARMAX模型关系式 $y(t) - (1-A(q))y(t) = A(q)y(t)$，我们得到：\n$$\n\\varepsilon(t) = A(q) y(t) - B(q) q^{-n_k} u(t) - (C(q) - 1) e(t)\n$$\n根据ARMAX的定义，$A(q) y(t) - B(q) q^{-n_k} u(t) = C(q) e(t)$。代入此式：\n$$\n\\varepsilon(t) = C(q) e(t) - (C(q) - 1) e(t) = C(q) e(t) - C(q) e(t) + e(t) = e(t)\n$$\n这证实了ARMAX模型的一步超前预测误差恰好是新息序列 $e(t)$，即 $\\varepsilon(t;\\theta) = e(t)$。\n\n为了获得以测量信号 $\\{y(t), u(t)\\}$ 表示的预测器 $\\hat{y}(t \\mid t-1)$ 的最终表达式，我们使用关系式 $\\hat{y}(t \\mid t-1) = y(t) - \\varepsilon(t) = y(t) - e(t)$。新息 $e(t)$ 必须表示为测量数据的函数。从ARMAX模型，我们有 $C(q)e(t) = A(q)y(t) - B(q)q^{-n_k}u(t)$。由于 $C(q)$ 是可逆的，我们可以写出：\n$$\ne(t) = C^{-1}(q) \\left[ A(q) y(t) - B(q) q^{-n_k} u(t) \\right]\n$$\n将此代入预测器的表达式中：\n$$\n\\hat{y}(t \\mid t-1) = y(t) - C^{-1}(q) \\left[ A(q) y(t) - B(q) q^{-n_k} u(t) \\right]\n$$\n对含 $y(t)$ 和 $u(t)$ 的项进行因式分解，得到一步超前预测器的最终形式：\n$$\n\\hat{y}(t \\mid t-1) = \\left[ 1 - C^{-1}(q) A(q) \\right] y(t) + C^{-1}(q) B(q) q^{-n_k} u(t)\n$$\n这个结果也可以写成 $\\hat{y}(t \\mid t-1) = C^{-1}(q) \\left[ (C(q)-A(q))y(t) + B(q)q^{-n_k}u(t) \\right]$。\n\n最后，关于闭环操作：上面所示的预测器代数形式的推导仅依赖于所假设的ARMAX模型结构和新息序列 $e(t)$ 的统计特性。像 $u(t) = -K(q) y(t) + r(t)$ 这样的反馈律的存在，对 $u(t)$ 和 $y(t)$ 序列施加了一个约束，但并未改变由ARMAX方程所描述的系统的数学定义。预测器的构造是针对给定的模型结构达到最优，而不管输入信号 $u(t)$ 是如何生成的。因此，表示为测量数据序列 $\\{u(t), y(t)\\}$ 上的因果算子的最优预测器的代数形式，对于开环和闭loop实验都是相同的。闭环辨识的挑战在于确保模型参数的可辨识性（这取决于控制器和外部激励），而不在于预测器本身的形式。", "answer": "$$\n\\boxed{\\left[ 1 - C^{-1}(q) A(q) \\right] y(t) + C^{-1}(q) B(q) q^{-n_k} u(t)}\n$$", "id": "2883861"}, {"introduction": "子空间辨识方法为从数据中寻找状态空间模型提供了一种强大的非迭代途径，这在闭环场景中是一项常见任务。该过程中的一个关键步骤是通过检查由数据构建的汉克尔矩阵（Hankel matrix）的奇异值来确定系统阶数。这个动手编程练习 [@problem_id:2883912] 要求您实现一个“奇异值间隙启发式算法”（gap heuristic），这是一种能自动完成该决策的实用算法，它将低秩近似的理论与一个可工作的辨识工具连接起来。", "problem": "给定一个严格正值的、按降序排列的奇异值序列，它们是在线性时不变（LTI）系统的闭环子空间辨识中产生的块汉克尔（block Hankel）矩阵或信息矩阵的估计奇异值。此外，还提供了一个外部估计的噪声基底。您的任务是设计并实现一个程序，使用间隙启发法（gap heuristic）来选择系统阶数，其原理基于低秩近似的基本原则以及在闭环辨识下奇异值的预期结构。\n\n假设与理论基础：\n1. 实数矩阵的奇异值分解（SVD）和 Eckart–Young–Mirsky 定理：对于一个奇异值为 $\\{s_1,s_2,\\dots,s_n\\}$（按非增序排列）的矩阵，其在弗罗贝尼乌斯范数（Frobenius norm）下的最佳秩-$r$近似保留了前 $r$ 个奇异值。\n2. 在使用充分的工具变量处理的闭环数据子空间辨识中，与确定性动态相对应的奇异值在达到真实系统阶数之前占主导地位，此后的其余奇异值则趋于平坦，接近噪声基底。因此，对于一个真实阶数 $r^\\star$，我们预期 $s_1 \\ge \\cdots \\ge s_{r^\\star} \\gg s_{r^\\star+1} \\approx \\cdots \\approx s_n \\approx \\tau$，其中 $\\tau$ 表示一个有效噪声基底水平。\n\n推导目标：\n- 基于上述基础，推导一个数学上不变的准则，通过识别主导奇异值和噪声基底奇异值之间的“拐点”（knee）来选择一个阶数 $r$。该准则对于整体数据缩放应具有尺度不变性，并且应该捕捉连续奇异值之间最大的相对下降，同时在存在跨越噪声基底的拐点时，有原则地偏好选择该拐点。\n\n需实现的算法规范：\n- 输入：奇异值列表 $\\mathbf{s} = (s_1,\\dots,s_n)$，其中 $s_i > 0$ 且 $s_1 \\ge \\cdots \\ge s_n$，以及一个正标量噪声基底 $\\tau > 0$。\n- 输出：一个整数模型阶数 $r \\in \\{0,1,\\dots,n-1\\}$，该阶数通过一种稳定的间隙启发法选出，该方法：\n  1. 使用一种对 $\\mathbf{s}$ 的公共缩放不变的相对下降度量。\n  2. 偏好选择跨越噪声基底的拐点，即当存在索引 $i$ 使得 $s_i > \\tau$ 且 $s_{i+1} \\le \\tau$ 时，优先选择这样的索引。\n  3. 确定性地处理平局情况。\n\n需要处理的边界情况：\n- 如果对所有 $i$ 都有 $s_i \\le \\tau$，则返回 $r = 0$。\n- 如果没有索引满足 $s_{i+1} \\le \\tau$，则在高于噪声基底的区域内选择一个索引。\n- 准则值的平局必须确定性地解决。\n\n您的程序必须为以下测试套件实现此选择。每个测试用例包含一个奇异值向量 $\\mathbf{s}^{(k)}$ 和一个噪声基底 $\\tau^{(k)}$。\n\n测试套件：\n- 用例 1：$\\mathbf{s}^{(1)} = (10.0,\\, 5.1,\\, 2.6,\\, 0.51,\\, 0.49,\\, 0.48,\\, 0.47)$，$\\tau^{(1)} = 0.5$。\n- 用例 2：$\\mathbf{s}^{(2)} = (20.0,\\, 10.0,\\, 1.0,\\, 0.9,\\, 0.88,\\, 0.87)$，$\\tau^{(2)} = 0.85$。\n- 用例 3：$\\mathbf{s}^{(3)} = (5.0,\\, 4.0,\\, 3.2,\\, 2.7,\\, 2.4,\\, 2.1)$，$\\tau^{(3)} = 0.5$。\n- 用例 4：$\\mathbf{s}^{(4)} = (0.49,\\, 0.48,\\, 0.47,\\, 0.46)$，$\\tau^{(4)} = 0.5$。\n- 用例 5：$\\mathbf{s}^{(5)} = (8.0,\\, 4.0,\\, 2.0,\\, 1.0,\\, 0.5,\\, 0.5,\\, 0.5)$，$\\tau^{(5)} = 0.5$。\n- 用例 6：$\\mathbf{s}^{(6)} = (3.0,\\, 0.4)$，$\\tau^{(6)} = 0.5$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用例 1 到 6 的选定阶数，格式为一个由方括号括起来的逗号分隔列表，例如 $\\text{\"[}r_1,r_2,r_3,r_4,r_5,r_6\\text{]\"}$。\n- 所有输出必须是整数。本问题不要求任何物理单位或角度单位。", "solution": "所提出的问题已经过验证，并被认定是有效的。它在科学上基于线性代数和系统辨识的原理，特别是通过奇异值分解（SVD）进行的低秩近似以及子空间辨识方法中汉克尔矩阵的结构。该问题是适定的、客观的，并包含足够的信息来推导和实现一个唯一的、确定性的算法。不存在矛盾、事实错误或伪科学论断。\n\n任务是设计一种有原则的启发式方法，用于从一个估计的奇异值序列 $\\mathbf{s} = (s_1, s_2, \\dots, s_n)$（其中 $s_1 \\ge s_2 \\ge \\dots \\ge s_n > 0$）中选择线性时不变系统的模型阶数 $r$。选择过程由一个外部估计的噪声基底 $\\tau > 0$ 辅助。所选的阶数 $r$ 应对应于奇异值图中的“拐点”，该拐点将与系统动态相关的主导奇异值与和噪声相关的较小奇异值分离开来。\n\n一个有效的模型阶数 $r$ 意味着该系统最好由一个秩-$r$模型来近似。根据 Eckart-Young-Mirsky 定理，这会保留前 $r$ 个奇异值。因此，信号与噪声之间的分界预期出现在 $s_r$ 和 $s_{r+1}$ 之间。我们的目标是识别出这个索引 $r \\in \\{1, \\dots, n-1\\}$。\n\n首先，必须建立一个度量标准来量化连续奇异值之间的“下降”或“间隙”。让我们考虑在索引 $i$ 处的间隙，即从 $s_i$到 $s_{i+1}$ 的下降。一个简单的差值 $s_i - s_{i+1}$ 并不适用，因为它不是尺度不变的；将整个数据矩阵乘以一个因子 $c$ 将使所有奇异值及其差值都乘以 $c$，从而改变所选的阶数。需要一个尺度不变的度量标准，因为信号的整体能量不应影响推导出的模型阶数。比率 $g_i = s_i / s_{i+1}$ 对此类缩放是不变的：$(c s_i) / (c s_{i+1}) = s_i / s_{i+1}$。一个大的比率 $g_i$ 意味着一个大的相对下降，指示可能存在拐点。因此，任务简化为找到使该准则最大化的索引 $i$：$r = \\arg\\max_{i} g_i$。\n\n接下来，我们必须整合噪声基底 $\\tau$。基本假设是，对于一个真实阶数为 $r^\\star$ 的系统，奇异值会划分为一个“信号子空间”和一个“噪声子空间”，使得 $s_1 \\ge \\dots \\ge s_{r^\\star} \\gg s_{r^\\star+1} \\approx \\dots \\approx s_n \\approx \\tau$。这意味着最显著的下降，即真正的拐点，理想情况下应该发生在奇异值穿过噪声基地的索引 $i$ 处。我们通过定义一个“跨越”索引 $i$ 来形式化这一点，它满足 $s_i > \\tau$ 且 $s_{i+1} \\le \\tau$。\n\n问题陈述了对此类跨越拐点的“偏好”。为了以一种有原则的、非任意的方式实现这种偏好，我们采用一种字典序或两阶段搜索策略。这避免了引入任意的加权参数。\n\n由此产生的稳定间隙启发法如下：\n\n1.  **初始验证**：检查是否存在任何高于噪声基底的信号。如果最大的奇异值 $s_1 \\le \\tau$，那么所有后续的奇异值也处于或低于噪声基底。无法从噪声中辨别出任何系统动态。在这种情况下，模型阶数必须为 $r = 0$。\n\n2.  **主搜索（跨越间隙）**：如果 $s_1 > \\tau$，我们继续。我们首先识别所有跨越索引的集合，$I_{straddle} = \\{ i \\in \\{1, \\dots, n-1\\} \\mid s_i > \\tau \\text{ and } s_{i+1} \\le \\tau \\}$。如果这个集合非空，意味着奇异值穿过噪声基底的位置有一个或多个。我们对最优阶数的搜索则完全限制在该集合内，因为这些是物理上最合理的拐点位置。所选的阶数是对应于该子集内最大间隙比的那个：\n    $$ r = \\arg\\max_{i \\in I_{straddle}} \\left(\\frac{s_i}{s_{i+1}}\\right) $$\n\n3.  **备用搜索（所有间隙）**：如果集合 $I_{straddle}$ 为空，而 $s_1 > \\tau$，这意味着所有奇异值 $\\{s_1, \\dots, s_n\\}$ 都严格大于噪声基底 $\\tau$。在这种情况下，噪声基底估计无助于划分奇异值。根据问题规范，我们必须从“高于基底的区域”中选择一个阶数。该过程恢复为在所有可能的索引中寻找最大的相对下降：\n    $$ r = \\arg\\max_{i \\in \\{1, \\dots, n-1\\}} \\left(\\frac{s_i}{s_{i+1}}\\right) $$\n\n4.  **平局处理**：在任一搜索阶段，如果 $\\arg\\max$ 操作产生多个具有相同最大间隙比的索引，则需要一个确定性的平局处理规则。根据简约原则（奥卡姆剃刀），我们选择最小的索引。这对应于选择能够同等好地解释数据的最简单模型（最低阶）。\n\n该算法提供了一个完整、鲁棒且确定性的模型阶数选择方法，该方法遵循所有指定的要求。它是尺度不变的，在可用时优先考虑具有物理意义的特征，并处理了所有指定的边界情况。", "answer": "```python\nimport numpy as np\n\ndef select_order(s_values, tau):\n    \"\"\"\n    Selects the system order using a stabilized gap heuristic.\n\n    Args:\n        s_values (list or np.ndarray): A list of strictly positive singular values\n                                      in descending order.\n        tau (float): A positive scalar representing the noise floor.\n\n    Returns:\n        int: The selected model order r.\n    \"\"\"\n    s = np.array(s_values, dtype=float)\n    n = len(s)\n\n    # Edge Case 1: All singular values are at or below the noise floor.\n    # If the largest singular value is not above tau, no signal is detectable.\n    if s[0] <= tau:\n        return 0\n\n    # There is at least one singular value above the noise floor.\n    # Possible orders are 1, ..., n-1. If n=1, no gaps exist, return 0.\n    if n <= 1:\n        return 0\n\n    # Calculate gap ratios for all possible orders i = 1, ..., n-1.\n    # The gap for order i corresponds to the ratio s_i / s_{i+1}.\n    # In 0-based indexing, this is s[i-1] / s[i] for order i.\n    gaps = s[:-1] / s[1:]\n    \n    # Identify indices i (1-based) that straddle the noise floor.\n    # An index i straddles if s_i > tau and s_{i+1} = tau.\n    # In 0-based indexing, this corresponds to indices k = 0..n-2\n    # where s[k] > tau and s[k+1] = tau.\n    possible_orders = np.arange(1, n)\n    is_straddling_mask = (s[:-1] > tau)  (s[1:] = tau)\n    \n    straddling_orders = possible_orders[is_straddling_mask]\n\n    # Primary Criterion: Search among straddling orders if they exist.\n    if len(straddling_orders) > 0:\n        # Get the gap ratios corresponding to the straddling orders.\n        straddling_gaps = gaps[is_straddling_mask]\n        \n        # Find the index of the maximum gap within the straddling subset.\n        # np.argmax provides deterministic tie-breaking by choosing the first max.\n        best_local_idx = np.argmax(straddling_gaps)\n        \n        # Return the corresponding order.\n        return straddling_orders[best_local_idx]\n    \n    # Fallback Criterion: If no index straddles the noise floor,\n    # it implies all singular values are above it.\n    # Find the largest gap among all possible orders.\n    else:\n        # np.argmax returns the 0-based index of the first maximum value.\n        # The corresponding order is index + 1.\n        best_overall_idx = np.argmax(gaps)\n        return best_overall_idx + 1\n\ndef solve():\n    \"\"\"\n    Runs the model order selection algorithm on the test suite and prints the result.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        (np.array([10.0, 5.1, 2.6, 0.51, 0.49, 0.48, 0.47]), 0.5),\n        # Case 2\n        (np.array([20.0, 10.0, 1.0, 0.9, 0.88, 0.87]), 0.85),\n        # Case 3\n        (np.array([5.0, 4.0, 3.2, 2.7, 2.4, 2.1]), 0.5),\n        # Case 4\n        (np.array([0.49, 0.48, 0.47, 0.46]), 0.5),\n        # Case 5\n        (np.array([8.0, 4.0, 2.0, 1.0, 0.5, 0.5, 0.5]), 0.5),\n        # Case 6\n        (np.array([3.0, 0.4]), 0.5),\n    ]\n\n    results = []\n    for s_values, tau in test_cases:\n        order = select_order(s_values, tau)\n        results.append(order)\n\n    # Print results in the required format \"[r1,r2,r3,r4,r5,r6]\"\n    # Expected: [4, 2, 1, 0, 4, 1]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# solve() # The function call is commented out as per execution environment standards.\n```", "id": "2883912"}]}