{"hands_on_practices": [{"introduction": "本节的第一个练习将我们的理解建立在连续时间系统的基础上。我们将探讨如何通过简单的比例缩放来设计系统的稳态行为，然后通过部分分式展开，将系统极点与其脉冲响应的各个分量联系起来，从而剖析其动态响应。这个练习[@problem_id:2877039]强化了 $s$ 域特征与时域性能之间的直接联系。", "problem": "一个单输入单输出线性时不变（LTI）系统由严格真、渐近稳定的传递函数建模\n$$H_{0}(s)=\\frac{4(s+1)}{s^{2}+6s+8}.$$\n假设初始条件为零。仅使用LTI系统输入和输出的拉普拉斯变换核心定义以及对有界输入的稳态响应概念，确定一个常数标量 $\\alpha0$，使得系统对单位阶跃输入的输出响应的稳态值等于$1$。然后考虑归一化传递函数 $H(s)=\\alpha H_{0}(s)$，并将其分解为与其在 $s=-2$ 和 $s=-4$ 处的实极点相对应的简单部分分式。令相应的留数分别为 $R_{1}$ 和 $R_{2}$，使得\n$$H(s)=\\frac{R_{1}}{s+2}+\\frac{R_{2}}{s+4}.$$\n计算 $R_{1}$ 和 $R_{2}$，并按照与极点 $s=-2$ 和 $s=-4$ 相关联的顺序报告它们。将您的最终答案表示为有序对 $\\big(R_{1},R_{2}\\big)$ 的行矩阵。不要转换为小数；报告精确整数。", "solution": "对所述问题进行验证。\n\n逐字提取给定条件：\n1.  一个单输入单输出线性时不变（LTI）系统。\n2.  初始传递函数：$H_{0}(s)=\\frac{4(s+1)}{s^{2}+6s+8}$。\n3.  该系统是严格真且渐近稳定的。\n4.  初始条件为零。\n5.  必须确定一个常数标量 $\\alpha0$，使得对单位阶跃输入的输出响应的稳态值等于$1$。\n6.  归一化传递函数为 $H(s)=\\alpha H_{0}(s)$。\n7.  $H(s)$ 将被分解为部分分式：$H(s)=\\frac{R_{1}}{s+2}+\\frac{R_{2}}{s+4}$。\n8.  留数 $R_{1}$ 和 $R_{2}$ 分别对应于实极点 $s=-2$ 和 $s=-4$。\n9.  最终答案必须是有序对 $(R_{1}, R_{2})$ 的行矩阵形式。\n\n验证评估：\n该问题具有科学依据，植根于线性系统和控制的标准理论。问题提法明确，为求得唯一解提供了充分的信息。语言客观、精确。渐近稳定性的前提是可验证的：$H_{0}(s)$ 的极点是分母 $s^{2}+6s+8=0$ 的根，可因式分解为 $(s+2)(s+4)=0$。极点位于 $s=-2$ 和 $s=-4$。由于两个极点都位于复平面的开左半平面，该系统确实是渐近稳定的。该问题没有矛盾、歧义或伪科学主张。\n\n结论：该问题有效。将构建解答。\n\n第一个目标是确定常数 $\\alpha$。系统的输入是单位阶跃函数，记为 $u(t)$，其拉普拉斯变换为 $U(s) = \\frac{1}{s}$。缩放后系统的传递函数为 $H(s) = \\alpha H_{0}(s)$。该系统的输出 $Y(s)$ 是传递函数与输入变换的乘积：\n$$Y(s) = H(s)U(s) = \\alpha H_{0}(s) \\frac{1}{s} = \\alpha \\frac{4(s+1)}{s(s^2+6s+8)}$$\n输出的稳态值 $y_{ss} = \\lim_{t \\to \\infty} y(t)$，可以使用拉普拉斯变换的终值定理（FVT）来确定。终值定理指出，如果 $sY(s)$ 的所有极点都在复平面的严格左半平面，那么 $\\lim_{t \\to \\infty} y(t) = \\lim_{s \\to 0} sY(s)$。\n函数 $sY(s)$ 由下式给出：\n$$sY(s) = \\alpha \\frac{4(s+1)}{s^2+6s+8}$$\n$sY(s)$ 的极点是 $s^2+6s+8=0$ 的根，即 $s=-2$ 和 $s=-4$。两个极点都在左半平面，因此终值定理适用。\n应用该定理：\n$$y_{ss} = \\lim_{s \\to 0} sY(s) = \\lim_{s \\to 0} \\alpha \\frac{4(s+1)}{s^2+6s+8}$$\n将 $s=0$ 代入表达式中：\n$$y_{ss} = \\alpha \\frac{4(0+1)}{0^2+6(0)+8} = \\alpha \\frac{4}{8} = \\frac{\\alpha}{2}$$\n问题要求这个稳态值等于 $1$。\n$$y_{ss} = 1 \\implies \\frac{\\alpha}{2} = 1$$\n解出 $\\alpha$ 得 $\\alpha=2$。该值满足条件 $\\alpha0$。\n\n第二个目标是求出归一化传递函数 $H(s)$ 的部分分式展开中的留数 $R_{1}$ 和 $R_{2}$。当 $\\alpha=2$ 时，传递函数为：\n$$H(s) = 2 H_{0}(s) = 2 \\cdot \\frac{4(s+1)}{s^2+6s+8} = \\frac{8(s+1)}{s^2+6s+8}$$\n对分母进行因式分解，我们得到：\n$$H(s) = \\frac{8s+8}{(s+2)(s+4)}$$\n问题陈述分解的形式为：\n$$H(s)=\\frac{R_{1}}{s+2}+\\frac{R_{2}}{s+4}$$\n对于单实极点，其留数可以使用 Heaviside 遮盖法计算。对应于极点 $s=-2$ 的留数 $R_{1}$ 是：\n$$R_{1} = \\lim_{s \\to -2} (s+2)H(s) = \\lim_{s \\to -2} (s+2)\\frac{8s+8}{(s+2)(s+4)}$$\n$$R_{1} = \\lim_{s \\to -2} \\frac{8s+8}{s+4} = \\frac{8(-2)+8}{-2+4} = \\frac{-16+8}{2} = \\frac{-8}{2} = -4$$\n所以，$R_{1}=-4$。\n\n对应于极点 $s=-4$ 的留数 $R_{2}$ 是：\n$$R_{2} = \\lim_{s \\to -4} (s+4)H(s) = \\lim_{s \\to -4} (s+4)\\frac{8s+8}{(s+2)(s+4)}$$\n$$R_{2} = \\lim_{s \\to -4} \\frac{8s+8}{s+2} = \\frac{8(-4)+8}{-4+2} = \\frac{-32+8}{-2} = \\frac{-24}{-2} = 12$$\n所以，$R_{2}=12$。\n\n计算出的留数为 $R_{1}=-4$ 和 $R_{2}=12$。问题要求有序对 $(R_{1}, R_{2})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-4  12\n\\end{pmatrix}\n}\n$$", "id": "2877039"}, {"introduction": "转向离散时间域，这个练习探讨了系统行为中一个更微妙的方面：系统零点对瞬态响应的影响。我们将构建两个具有相同幅频响应但相位特性不同的系统，并比较它们的阶跃响应。这个实践[@problem_id:2877044]揭示了为什么相位信息至关重要，以及非最小相位零点如何引入不希望出现的效应，例如初始下冲。", "problem": "考虑传递函数为 $H(z)$ 且相应频率响应为 $H(\\exp(j\\omega))$（其中实角频率 $\\omega$ 的单位为弧度）的离散时间线性时不变（LTI）系统。如果一个系统的所有零点都严格位于复 $z$ 平面的单位圆内部，则该系统称为最小相位系统；否则，称为非最小相位系统。单位阶跃响应是在零初始条件下，输入为单位阶跃 $u[n]$ 时的输出序列。幅度响应是函数 $\\omega \\mapsto |H(\\exp(j\\omega))|$。\n\n构建以下一对由实常数 $c$（$0c1$）参数化的因果、稳定离散时间 LTI 系统：\n1.  一个最小相位系统 $H_{\\min}(z)$。\n2.  一个非最小相位系统 $H_{\\text{nm}}(z)$。\n\n要求这两个系统对于所有频率 $\\omega$ 都具有相同的幅度响应，即 $|H_{\\min}(\\exp(j\\omega))| = |H_{\\text{nm}}(\\exp(j\\omega))|$。\n\n接下来，推导这两个系统 $y_{\\min}[n]$ 和 $y_{\\text{nm}}[n]$ 的单位阶跃响应。最后，计算下冲幅度 $\\Delta(c)$，定义为非最小相位响应与最小相位响应的最终稳态值 $y_{\\min}[\\infty] \\triangleq \\lim_{n \\to \\infty} y_{\\min}[n]$ 之间的最大绝对偏差：\n$$\n\\Delta(c) = \\max_{n \\ge 0} \\big( y_{\\min}[\\infty] - y_{\\text{nm}}[n] \\big).\n$$\n你的最终答案应该是只包含 $c$ 的一个简单代数表达式。", "solution": "所述问题是适定的，科学上合理的，并包含唯一解所需的所有必要信息。我们按要求进行推导。\n\n两个因果、稳定的离散时间LTI系统由其传递函数定义：\n$H_{\\min}(z) = 1$\n$H_{\\text{nm}}(z) = \\dfrac{z^{-1} - c}{1 - c z^{-1}}$，其中实常数 $c$ 满足 $0  c  1$。\n\n首先，我们根据任务1分析这两个系统的性质。\n\n如果一个系统的所有极点和零点都在 $z$ 平面的单位圆内，则该系统为最小相位系统。位于原点 $z=0$ 的极点和零点不影响此分类。\n对于 $H_{\\min}(z) = 1$，除了可能在原点或无穷远处的极点或零点（取决于如何解释）外，没有其他极点或零点。对于这样的因果有限脉冲响应（FIR）滤波器，稳定性得到保证，并且由于其在单位圆外没有零点，通常被认为是最小相位系统。\n\n对于 $H_{\\text{nm}}(z)$，极点由分母多项式的根决定，$1 - c z^{-1} = 0$，解得 $z=c$。由于 $0  c  1$，极点严格位于单位圆内部，即 $|c|  1$，这证实了该因果系统的稳定性。零点由分子多项式的根决定，$z^{-1} - c = 0$，解得 $z = 1/c$。由于 $0  c  1$，零点严格位于单位圆外部，即 $|1/c|  1$。单位圆外存在零点使得 $H_{\\text{nm}}(z)$ 成为一个非最小相位系统。\n\n接下来，我们证明幅度响应是相同的。频率响应通过在单位圆上（即 $z = \\exp(j\\omega)$）评估传递函数得到。\n对于最小相位系统：\n$$|H_{\\min}(\\exp(j\\omega))| = |1| = 1$$\n对于非最小相位系统：\n$$H_{\\text{nm}}(\\exp(j\\omega)) = \\frac{\\exp(-j\\omega) - c}{1 - c \\exp(-j\\omega)}$$\n为了求幅度，我们计算 $|H_{\\text{nm}}(\\exp(j\\omega))|$。一个直接的方法是认识到分母与分子的复共轭有关。令 $w = \\exp(-j\\omega) - c$。由于 $c$ 是实数，其复共轭为 $\\bar{c}=c$，而 $\\exp(-j\\omega)$ 的共轭是 $\\exp(j\\omega)$。分母为 $1 - c \\exp(-j\\omega) = \\exp(-j\\omega)(\\exp(j\\omega) - c) = \\exp(-j\\omega)\\bar{w}$。\n因此，\n$$|H_{\\text{nm}}(\\exp(j\\omega))| = \\left| \\frac{w}{\\exp(-j\\omega)\\bar{w}} \\right| = \\frac{|w|}{|\\exp(-j\\omega)| |\\bar{w}|}$$\n由于 $|\\exp(-j\\omega)| = 1$ 且 $|w|=|\\bar{w}|$，我们有：\n$$|H_{\\text{nm}}(\\exp(j\\omega))| = 1$$\n这证实了两个系统对于所有实频率 $\\omega$ 都具有相同的、单位为1的幅度响应。具有此性质的系统被称为全通滤波器。\n\n第二，我们通过推导差分方程和单位阶跃响应来完成任务2。\n对于最小相位系统，$z$ 域中的输入输出关系是 $Y_{\\min}(z) = H_{\\min}(z) X(z) = 1 \\cdot X(z) = X(z)$。应用 $z$ 反变换得到差分方程：\n$$y_{\\min}[n] = x[n]$$\n输入是单位阶跃序列 $x[n] = u[n]$，定义为 $u[n]=1$ for $n \\ge 0$ 且 $u[n]=0$ for $n  0$。相应的阶跃响应为：\n$$y_{\\min}[n] = u[n]$$\n当 $n \\to \\infty$ 时的稳态值为 $y_{\\min}[\\infty] = \\lim_{n \\to \\infty} u[n] = 1$。\n\n对于非最小相位系统，输入输出关系为 $Y_{\\text{nm}}(z) = H_{\\text{nm}}(z) X(z)$。\n$$Y_{\\text{nm}}(z) = \\left( \\frac{z^{-1} - c}{1 - c z^{-1}} \\right) X(z)$$\n交叉相乘得到 $Y_{\\text{nm}}(z)(1 - c z^{-1}) = X(z)(z^{-1} - c)$，展开为 $Y_{\\text{nm}}(z) - c z^{-1}Y_{\\text{nm}}(z) = z^{-1}X(z) - cX(z)$。应用 $z$ 反变换并使用时移性质 $\\mathcal{Z}^{-1}\\{z^{-k}F(z)\\} = f[n-k]$，我们得到因果差分方程：\n$$y_{\\text{nm}}[n] - c y_{\\text{nm}}[n-1] = x[n-1] - c x[n]$$\n$$y_{\\text{nm}}[n] = c y_{\\text{nm}}[n-1] + x[n-1] - c x[n]$$\n为了求单位阶跃响应，我们令 $x[n] = u[n]$。输入的 $z$ 变换为 $X(z) = \\mathcal{Z}\\{u[n]\\} = \\frac{1}{1-z^{-1}}$。输出的变换为：\n$$Y_{\\text{nm}}(z) = \\left( \\frac{z^{-1} - c}{1 - c z^{-1}} \\right) \\left( \\frac{1}{1 - z^{-1}} \\right)$$\n我们使用部分分式展开来求反变换。设\n$$Y_{\\text{nm}}(z) = \\frac{A}{1 - c z^{-1}} + \\frac{B}{1 - z^{-1}}$$\n系数 $A$ 的计算如下：\n$$A = \\left. (1 - c z^{-1}) Y_{\\text{nm}}(z) \\right|_{z^{-1}=1/c} = \\left. \\frac{z^{-1} - c}{1 - z^{-1}} \\right|_{z^{-1}=1/c} = \\frac{1/c - c}{1 - 1/c} = \\frac{(1-c^2)/c}{(c-1)/c} = \\frac{-(c-1)(c+1)}{c-1} = -(1+c)$$\n系数 $B$ 的计算如下：\n$$B = \\left. (1 - z^{-1}) Y_{\\text{nm}}(z) \\right|_{z^{-1}=1} = \\left. \\frac{z^{-1} - c}{1 - c z^{-1}} \\right|_{z^{-1}=1} = \\frac{1 - c}{1 - c} = 1$$\n所以，输出的变换为：\n$$Y_{\\text{nm}}(z) = -\\frac{1+c}{1 - c z^{-1}} + \\frac{1}{1 - z^{-1}}$$\n逐项进行 $z$ 反变换，使用变换对 $\\mathcal{Z}^{-1}\\{\\frac{1}{1-az^{-1}}\\} = a^n u[n]$，我们得到对于 $n \\ge 0$ 的阶跃响应：\n$$y_{\\text{nm}}[n] = -(1+c)c^n u[n] + 1^n u[n] = (1 - (1+c)c^n) u[n]$$\n对于 $n \\ge 0$，即 $y_{\\text{nm}}[n] = 1 - (1+c)c^n$。\n\n第三，我们执行任务3，对阶跃响应进行定量比较。下冲幅度 $\\Delta(c)$ 定义为：\n$$\\Delta(c) = \\max_{n \\ge 0} \\big( y_{\\min}[\\infty] - y_{\\text{nm}}[n] \\big)$$\n我们已经求得 $y_{\\min}[\\infty] = 1$。代入 $n \\ge 0$ 时的 $y_{\\min}[\\infty]$ 和 $y_{\\text{nm}}[n]$ 的表达式：\n$$y_{\\min}[\\infty] - y_{\\text{nm}}[n] = 1 - \\left(1 - (1+c)c^n\\right) = (1+c)c^n$$\n我们必须求序列 $D[n] = (1+c)c^n$ 在整数 $n \\ge 0$ 上的最大值。\n参数 $c$ 位于区间 $0  c  1$。因此，因子 $(1+c)$ 是一个大于1的正定常数。项 $c^n$ 是一个几何序列。由于 $0  c  1$，该序列在 $n \\ge 0$ 上是正的且严格单调递减的。\n具体来说，$c^0=1$, $c^1=c$, $c^2  c$，以此类推。$c^n$ 在 $n \\ge 0$ 上的最大值出现在 $n$ 的最小值处，即 $n=0$。\n因此，序列 $D[n]$ 的最大值也出现在 $n=0$ 处：\n$$\\Delta(c) = \\max_{n \\ge 0} \\left((1+c)c^n\\right) = (1+c)c^0 = 1+c$$\n这个结果表示非最小相位响应与最终稳态值的最大偏差，它发生在时间 $n=0$ 处，此时响应为 $y_{\\text{nm}}[0] = 1 - (1+c) = -c$。这种初始值远低于最终值的现象是非最小相位系统的典型特征。", "answer": "$$\\boxed{1+c}$$", "id": "2877044"}, {"introduction": "最后一个练习则弥合了抽象理论与实际应用之间的鸿沟。我们将推导系统脉冲响应与阶跃响应之间的简单递归关系，然后研究在计算机上实现该关系时遇到的数值挑战。通过将一个朴素的实现与一个数值稳健的算法进行比较，这个练习[@problem_id:2877073]展示了在数字信号处理中，尤其是在处理具有长记忆特性的系统时，考虑有限精度效应的至关重要性。", "problem": "考虑一个离散时间、因果、线性时不变 (LTI) 系统，其冲激响应表示为 $h[n]$。单位阶跃响应 $s[n]$ 定义为单位阶跃输入 $u[n]$ 所对应的输出，等效于冲激响应截至时间 $n$ 的部分和。根据离散时间卷积的基本定义和系统的因果性，$s[n]$ 必须能仅从 $h[n]$ 推导得出，而无需获取未来的样本。仅从线性时不变系统和离散时间卷积的核心定义出发，推导一个在线递归关系，用于在每个新样本 $h[n]$ 到达时更新 $s[n]$。在构建递归式时，请明确地从 $s[n]$ 作为 $h[n]$ 与 $u[n]$ 的运行时离散卷积的定义出发进行推理。\n\n接下来，实现并分析两种数值上实现你所推导的递归的在线算法：\n- 一种使用标准双精度（IEEE $754$ binary64）的朴素直接更新方法。\n- 一种使用 Kahan 求和来减少有限精度下舍入误差的补偿更新方法。\n\n你的实现必须是通用的，并能处理逐个到达的 $h[n]$ 样本流。为评估长记录下的数值稳定性，请在稳定的、具有靠近单位圆的单个实极点参数 $p$ 的一阶系统上测试这两种实现，其传递函数为\n$$\nH(z)=\\frac{1}{1-p z^{-1}},\n$$\n因此其（因果）冲激响应满足由离散时间单位冲激驱动的一阶齐次递推关系。每次测试必须在一个有限的 $N$ 个样本的时间范围内进行。\n\n使用以下测试集，其中每个案例由 $(p,N)$ 指定，且 $p \\in \\mathbb{R}$，$|p|1$：\n- 案例 1：$(p,N)=\\left(0.9,\\, 50000\\right)$。\n- 案例 2：$(p,N)=\\left(0.999999,\\, 200000\\right)$。\n- 案例 3：$(p,N)=\\left(-0.9999,\\, 200000\\right)$。\n\n对于每个案例，按以下步骤操作：\n- 在线生成冲激响应流：$h[0]=1$ 且对于 $n \\ge 1$ 有 $h[n]=p \\, h[n-1]$（这等同于用单位冲激激励该系统）。\n- 仅使用传入的 $h[n]$ 样本和你推导的递归关系，更新阶跃响应的两个运行估计值 $\\widehat{s}_{\\text{naive}}[n]$ 和 $\\widehat{s}_{\\text{Kahan}}[n]$。\n- 同时，通过使用至少 $80$ 位十进制精度的任意精度算术对同一样本流求和，计算一个高精度的参考阶跃响应 $s_{\\text{ref}}[n]$。\n\n对于每个 $n \\in \\{0,1,\\dots,N-1\\}$，定义瞬时相对误差\n$$\n\\varepsilon_{\\text{naive}}[n] \\triangleq \n\\begin{cases}\n\\left|\\dfrac{\\widehat{s}_{\\text{naive}}[n]-s_{\\text{ref}}[n]}{s_{\\text{ref}}[n]}\\right|,  s_{\\text{ref}}[n] \\ne 0,\\\\\n0,  s_{\\text{ref}}[n]=0,\n\\end{cases}\n\\quad\n\\varepsilon_{\\text{Kahan}}[n] \\triangleq \n\\begin{cases}\n\\left|\\dfrac{\\widehat{s}_{\\text{Kahan}}[n]-s_{\\text{ref}}[n]}{s_{\\text{ref}}[n]}\\right|,  s_{\\text{ref}}[n] \\ne 0,\\\\\n0,  s_{\\text{ref}}[n]=0.\n\\end{cases}\n$$\n对于每个案例，报告在整个时间范围内的最大相对误差：\n$$\nE_{\\text{naive}}=\\max_{0 \\le n  N} \\varepsilon_{\\text{naive}}[n], \n\\qquad\nE_{\\text{Kahan}}=\\max_{0 \\le n  N} \\varepsilon_{\\text{Kahan}}[n].\n$$\n\n你的程序必须：\n- 推导并实现仅使用传入的 $h[n]$ 来更新 $s[n]$ 的两种在线算法。\n- 对 $\\widehat{s}_{\\text{naive}}[n]$ 和 $\\widehat{s}_{\\text{Kahan}}[n]$ 使用标准双精度。\n- 对 $s_{\\text{ref}}[n]$ 使用至少 $80$ 位十进制精度。\n- 处理上述三个测试案例，并为每个案例计算两个标量 $E_{\\text{naive}}$ 和 $E_{\\text{Kahan}}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n\\big[E_{\\text{naive}}^{(1)},\\, E_{\\text{Kahan}}^{(1)},\\, E_{\\text{naive}}^{(2)},\\, E_{\\text{Kahan}}^{(2)},\\, E_{\\text{naive}}^{(3)},\\, E_{\\text{Kahan}}^{(3)}\\big],\n$$\n其中上标表示测试案例索引 $1,2,3$。\n- 每个条目必须是实数（浮点数）。不涉及单位。\n\n关于科学真实性和范围的说明：\n- 所有指定的系统都满足 $|p|1$，以确保有界输入有界输出稳定性。\n- 所选的 $p$ 值旨在探测正常衰减（$p=0.9$）、具有长记忆的极慢衰减（$p=0.999999$）以及交替的慢衰减（$p=-0.9999$），从而揭示在单位圆附近的数值敏感性。", "solution": "该问题是有效的。它在科学上基于线性时不变 (LTI) 系统理论和数值分析的原理，问题阐述清晰，目标明确，信息完整，并且表述客观。我现在将着手解决。\n\n问题的核心是推导并数值分析一个离散时间 LTI 系统的冲激响应 $h[n]$ 与其单位阶跃响应 $s[n]$ 之间的递归关系。\n\n**1. 在线递归的推导**\n\nLTI 系统的单位阶跃响应 $s[n]$ 定义为当输入为单位阶跃序列 $u[n]$ 时的系统输出，其中当 $n \\ge 0$ 时 $u[n] = 1$，当 $n  0$ 时 $u[n] = 0$。LTI 系统的输出由其冲激响应 $h[n]$ 与输入信号的离散时间卷积给出。\n\n对于一个因果系统，其中当 $k  0$ 时 $h[k] = 0$，卷积和为：\n$$\ns[n] = (h * u)[n] = \\sum_{k=0}^{\\infty} h[k] u[n-k]\n$$\n根据单位阶跃函数 $u[m]$ 的定义，当 $n-k \\ge 0$（即 $k \\le n$）时，项 $u[n-k]$ 等于 $1$；当 $n-k  0$（即 $k  n$）时，项 $u[n-k]$ 等于 $0$。这使我们可以将求和的上限从 $\\infty$ 改为 $n$：\n$$\ns[n] = \\sum_{k=0}^{n} h[k] \\cdot 1 = \\sum_{k=0}^{n} h[k]\n$$\n此方程表明，阶跃响应 $s[n]$ 是冲激响应 $h[k]$ 从 $k=0$ 到当前时间索引 $n$ 的累积和。\n\n为了推导在线递归关系，我们将 $s[n]$ 用其前一个值 $s[n-1]$ 来表示。我们可以将 $s[n]$ 的求和式分解如下：\n$$\ns[n] = \\left( \\sum_{k=0}^{n-1} h[k] \\right) + h[n]\n$$\n括号中的项根据定义是时间 $n-1$ 处的阶跃响应，即 $s[n-1] = \\sum_{k=0}^{n-1} h[k]$。\n将其代回，我们得到所需的一阶递归关系：\n$$\ns[n] = s[n-1] + h[n]\n$$\n此关系对 $n \\ge 1$ 成立。初始条件可通过计算 $n=0$ 时的值得到：\n$$\ns[0] = \\sum_{k=0}^{0} h[k] = h[0]\n$$\n等价地，可以定义 $s[-1] = 0$，这样该递归关系对所有 $n \\ge 0$ 均成立。这个简单的更新规则——一个累加器——非常适合在线处理，因为新的阶跃响应值 $s[n]$ 仅使用前一个值 $s[n-1]$ 和新到达的冲激响应样本 $h[n]$ 即可计算。\n\n**2. 数值实现与分析**\n\n推导出的递归关系 $s[n] = s[n-1] + h[n]$ 本质上是一个求和过程。当使用有限精度浮点算术实现时，此过程会受到累积舍入误差的影响。我们将实现并比较两种算法。\n\n**朴素直接更新**：\n最直接的实现是使用标准双精度浮点数（IEEE $754$ binary64，对应于 Python 的 `float` 或 `numpy.float64`）并直接应用递归关系：\n$$\n\\widehat{s}_{\\text{naive}}[n] = \\widehat{s}_{\\text{naive}}[n-1] + h[n]\n$$\n当运行总和 $\\widehat{s}_{\\text{naive}}[n-1]$ 的量级远大于待加项 $h[n]$ 时，这种方法就会出现问题。在浮点加法中，较小数的尾数会被移位以对齐指数，这可能导致其低位比特丢失。经过多次迭代，这些小误差的累积可能导致结果与真实数学和之间产生显著偏差。这对于具有长记忆的系统（极点靠近单位圆），即 $h[n]$ 衰减缓慢的系统，尤其成问题。\n\n**补偿 Kahan 求和**：\nKahan 求和是一种旨在减轻这种精度损失的算法。它引入一个补偿变量 $c$，该变量累积每一步加法产生的误差，并在下一步中进行修正。对于每个传入的样本 $h[n]$，更新过程分四步进行：\n1.  用前一个误差修正新项：$y = h[n] - c$\n2.  将修正后的项加到总和中：$t = s + y$\n3.  计算新误差：$c = (t - s) - y$\n4.  更新总和：$s = t$\n\n在这里，$s$ 代表运行总和 $\\widehat{s}_{\\text{Kahan}}[n]$。变量 $c$ 跟踪在求和 $s+y$ 过程中“丢失”的 $y$ 的那一部分。通过从*下一个*项中减去这个丢失的部分，该算法有效地将精度向前传递，与朴素方法相比，极大地减少了总体累积误差。\n\n**高精度参考**：\n为了客观地测量两种浮点方法的误差，需要一个基准真相或参考值 $s_{\\text{ref}}[n]$。该参考值通过使用任意精度算术执行相同的累加来计算。为此，我们使用 Python 的 `decimal` 模块，并设置 $100$ 位十进制数字的精度，这超过了要求的 $80$ 位，并确保其自身的舍入误差在此上下文中可以忽略不计。\n\n**测试流程**：\n对于每个测试案例 $(p, N)$，我们对 $n$ 从 $0$到 $N-1$ 执行以下步骤：\n1.  在线生成冲激响应流 $h[n]$：$h[0]=1$ 且对于 $n \\ge 1$ 有 $h[n] = p \\cdot h[n-1]$。这一步对高精度 (`Decimal`) 和双精度 (`numpy.float64`) 数据类型并行进行。\n2.  更新三个运行总和：$s_{\\text{ref}}[n]$（高精度）、$\\widehat{s}_{\\text{naive}}[n]$（朴素双精度）和 $\\widehat{s}_{\\text{Kahan}}[n]$（Kahan 双精度），使用它们各自新生成的 $h[n]$ 样本。\n3.  在每一步 $n$，计算相对于 $s_{\\text{ref}}[n]$ 的瞬时相对误差 $\\varepsilon_{\\text{naive}}[n]$ 和 $\\varepsilon_{\\text{Kahan}}[n]$。\n4.  最终的度量指标 $E_{\\text{naive}}$ 和 $E_{\\text{Kahan}}$ 是在整个 $N$ 个样本的时间范围内观察到的这些瞬时相对误差的最大值。\n\n所选的极点 $p$ 靠近单位圆 ($|p| \\approx 1$) 的测试案例旨在创建数值上具有挑战性的场景，其中 $h[n]$ 衰减非常缓慢，从而最大化了累积舍入误差的可能性，因此能清晰地展示朴素求和算法与补偿求和算法之间的性能差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Derives, implements, and analyzes two online algorithms for calculating \n    the step response from the impulse response of an LTI system.\n    \"\"\"\n\n    test_cases = [\n        (0.9, 50000),\n        (0.999999, 200000),\n        (-0.9999, 200000),\n    ]\n\n    results = []\n    for p, N in test_cases:\n        e_naive, e_kahan = run_simulation(p, N)\n        results.append(e_naive)\n        results.append(e_kahan)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(p, N):\n    \"\"\"\n    Runs the simulation for a given first-order system and calculates the max relative errors.\n\n    Args:\n        p (float): The pole of the first-order system.\n        N (int): The number of samples (horizon).\n\n    Returns:\n        tuple[float, float]: A tuple containing E_naive and E_Kahan.\n    \"\"\"\n    # Set precision for the high-precision reference calculation.\n    # 80 is required, 100 provides a safe margin.\n    getcontext().prec = 100\n\n    # Convert parameter p to the required numerical types.\n    # str(p) is used to avoid floating point representation issues during conversion to Decimal.\n    p_str = str(p)\n    p_dec = Decimal(p_str)\n    p_float = np.float64(p)\n\n    # --- State variables initialization ---\n\n    # High-precision reference states\n    h_ref = Decimal(1)  # h[n] for the reference calculation\n    s_ref = Decimal(0)  # s_ref[n], the running sum\n\n    # Naive double-precision states\n    h_naive = np.float64(1.0)  # h[n] for double-precision calculations\n    s_naive = np.float64(0.0)    # s_naive[n], the running sum\n\n    # Kahan summation double-precision states\n    s_kahan = np.float64(0.0)    # s_kahan[n], the running sum\n    c_kahan = np.float64(0.0)    # The compensation variable\n\n    # --- Error tracking initialization ---\n    max_rel_err_naive = 0.0\n    max_rel_err_kahan = 0.0\n\n    # --- Main simulation loop ---\n    for _ in range(N):\n        # At the start of this loop, h_ref and h_naive hold the value of h[n].\n\n        # 1. Update the step responses using h[n]\n        \n        # High-precision reference update\n        s_ref += h_ref\n        \n        # Naive double-precision update\n        s_naive += h_naive\n        \n        # Kahan summation update\n        y = h_naive - c_kahan\n        t = s_kahan + y\n        c_kahan = (t - s_kahan) - y\n        s_kahan = t\n\n        # 2. Calculate instantaneous relative errors and update maximums\n        if s_ref != 0:\n            # Naive error\n            rel_err_naive = abs((Decimal(s_naive) - s_ref) / s_ref)\n            if float(rel_err_naive)  max_rel_err_naive:\n                max_rel_err_naive = float(rel_err_naive)\n            \n            # Kahan error\n            rel_err_kahan = abs((Decimal(s_kahan) - s_ref) / s_ref)\n            if float(rel_err_kahan)  max_rel_err_kahan:\n                max_rel_err_kahan = float(rel_err_kahan)\n        \n        # 3. Generate the next impulse response sample, h[n+1], for the next iteration.\n        h_ref *= p_dec\n        h_naive *= p_float\n\n    return max_rel_err_naive, max_rel_err_kahan\n\nsolve()\n```", "id": "2877073"}]}