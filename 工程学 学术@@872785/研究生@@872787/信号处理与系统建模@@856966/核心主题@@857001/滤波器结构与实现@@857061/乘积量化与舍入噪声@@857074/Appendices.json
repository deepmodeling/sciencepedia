{"hands_on_practices": [{"introduction": "数字信号处理的核心是乘法运算。当使用有限精度实现系统时，我们必须决定在何处进行量化。本练习 [@problem_id:2893694] 探讨了一个根本性的选择：是在乘法前对操作数进行量化，还是在乘法后对乘积进行量化。通过推导两种情况下的均方误差，您将定量地理解这一架构决策如何影响系统的噪声性能。", "problem": "考虑两个独立的、零均值的、无量纲的宽平稳实值随机变量 $a$ 和 $b$，其方差有限，分别为 $\\sigma_{a}^{2} = \\mathbb{E}[a^{2}]$ 和 $\\sigma_{b}^{2} = \\mathbb{E}[b^{2}]$。您需要比较两种用于产生精确积 $z = a b$ 的近似值的架构：\n\n1. 乘法前操作数舍入（积的舍入）：操作数分别通过步长为 $\\Delta_{a}$ 和 $\\Delta_{b}$ 的中置式均匀舍入量化器 $Q_{a}$ 和 $Q_{b}$，得到 $a_{q} = Q_{a}(a)$ 和 $b_{q} = Q_{b}(b)$，输出为 $y_{\\mathrm{pre}} = a_{q} b_{q}$。\n\n2. 精确乘法后积的舍入：计算精确积 $z = a b$，然后用步长为 $\\Delta_{z}$ 的中置式均匀舍入量化器 $Q_{z}$ 对其进行量化，得到 $y_{\\mathrm{post}} = Q_{z}(z)$。\n\n假设在高分辨率条件下，每个量化器都遵循加性噪声模型：$Q_{x}(x) = x + e_{x}$，其中 $e_{x}$ 是信号 $x \\in \\{a,b,z\\}$ 的量化误差。对于每个 $x$，将 $e_{x}$ 建模为与 $x$ 及其他误差过程无关、零均值，且在 $[-\\Delta_{x}/2, \\Delta_{x}/2]$ 上均匀分布。具体来说，$\\mathbb{E}[e_{x}] = 0$ 且 $\\mathbb{E}[e_{x}^{2}] = \\Delta_{x}^{2}/12$。 \n\n定义每种架构相对于精确积 $z = a b$ 的总输出均方误差 (MSE) 为 $J_{\\mathrm{pre}} = \\mathbb{E}\\big[(y_{\\mathrm{pre}} - z)^{2}\\big]$ 和 $J_{\\mathrm{post}} = \\mathbb{E}\\big[(y_{\\mathrm{post}} - z)^{2}\\big]$。计算到量化步长的二阶，这意味着您必须保留到两个量化方差的乘积项（例如，与 $\\Delta_{a}^{2} \\Delta_{b}^{2}$ 成比例的项），并可以忽略超出该阶的任何更高阶项。\n\n请根据基本原理和所述假设，推导出两种架构输出 MSE 之差\n$$\n\\Delta J \\triangleq J_{\\mathrm{pre}} - J_{\\mathrm{post}},\n$$\n的闭式解析表达式，该表达式是 $\\sigma_{a}^{2}$、$\\sigma_{b}^{2}$、$\\Delta_{a}$、$\\Delta_{b}$ 和 $\\Delta_{z}$ 的函数。将您的最终答案表示为单个简化的符号表达式。无需单位。", "solution": "本问题要求对乘法运算中两种不同量化架构的均方误差 (MSE) 进行对比分析。给定两个独立的、零均值的宽平稳随机变量 $a$ 和 $b$，其方差分别为 $\\sigma_{a}^{2}$ 和 $\\sigma_{b}^{2}$。目标是推导出 $\\Delta J = J_{\\mathrm{pre}} - J_{\\mathrm{post}}$ 的表达式，其中 $J_{\\mathrm{pre}}$ 和 $J_{\\mathrm{post}}$ 分别是乘法前量化和乘法后量化的均方误差。我们将遵循所提供的量化加性噪声模型，并保留到量化方差的二阶项，分别推导每种均方误差的表达式。\n\n首先，我们分析乘法后量化架构。精确积为 $z = ab$。该积被量化以产生输出 $y_{\\mathrm{post}} = Q_{z}(z)$。根据加性噪声模型，我们可以写出 $y_{\\mathrm{post}} = z + e_{z}$，其中 $e_{z}$ 是与量化器 $Q_{z}$ 相关的量化误差。该误差的性质为 $\\mathbb{E}[e_{z}] = 0$ 和 $\\mathbb{E}[e_{z}^{2}] = \\frac{\\Delta_{z}^{2}}{12}$。\n\n此架构的均方误差 $J_{\\mathrm{post}}$ 是相对于精确积 $z$ 定义的：\n$$\nJ_{\\mathrm{post}} = \\mathbb{E}\\big[(y_{\\mathrm{post}} - z)^{2}\\big]\n$$\n代入 $y_{\\mathrm{post}}$ 的表达式，我们得到：\n$$\nJ_{\\mathrm{post}} = \\mathbb{E}\\big[((z + e_{z}) - z)^{2}\\big] = \\mathbb{E}[e_{z}^{2}]\n$$\n利用给定的量化误差方差，我们得到后量化情况下的均方误差：\n$$\nJ_{\\mathrm{post}} = \\frac{\\Delta_{z}^{2}}{12}\n$$\n在所述模型假设下，此结果是精确的。\n\n接下来，我们分析乘法前量化架构。操作数 $a$ 和 $b$ 首先被量化，得到 $a_{q} = Q_{a}(a)$ 和 $b_{q} = Q_{b}(b)$。使用加性噪声模型，我们有：\n$$\na_{q} = a + e_{a}\n$$\n$$\nb_{q} = b + e_{b}\n$$\n其中 $e_{a}$ 和 $e_{b}$ 是各自的量化误差。它们的性质为 $\\mathbb{E}[e_{a}] = 0$, $\\mathbb{E}[e_{a}^{2}] = \\frac{\\Delta_{a}^{2}}{12}$，$\\mathbb{E}[e_{b}] = 0$ 和 $\\mathbb{E}[e_{b}^{2}] = \\frac{\\Delta_{b}^{2}}{12}$。问题陈述指出，误差过程彼此独立，且与信号无关。\n\n此架构的输出是量化后操作数的乘积：\n$$\ny_{\\mathrm{pre}} = a_{q} b_{q} = (a + e_{a})(b + e_{b}) = ab + a e_{b} + b e_{a} + e_{a} e_{b}\n$$\n均方误差 $J_{\\mathrm{pre}}$ 是此输出与精确积 $z = ab$ 之差的平方的期望值：\n$$\ny_{\\mathrm{pre}} - z = (ab + a e_{b} + b e_{a} + e_{a} e_{b}) - ab = a e_{b} + b e_{a} + e_{a} e_{b}\n$$\n$$\nJ_{\\mathrm{pre}} = \\mathbb{E}\\big[(y_{\\mathrm{pre}} - z)^{2}\\big] = \\mathbb{E}\\big[(a e_{b} + b e_{a} + e_{a} e_{b})^{2}\\big]\n$$\n为计算此期望，我们展开平方项：\n$$\n(a e_{b} + b e_{a} + e_{a} e_{b})^{2} = a^{2}e_{b}^{2} + b^{2}e_{a}^{2} + e_{a}^{2}e_{b}^{2} + 2ab e_{a} e_{b} + 2a e_{a} e_{b}^{2} + 2b e_{a}^{2} e_{b}\n$$\n现在，我们逐项取该表达式的期望，利用 $a, b, e_{a}, e_{b}$ 的相互独立性，以及它们都是零均值信号（除了它们的方差）这一事实。\n\n对角项的期望：\n$$\n\\mathbb{E}[a^{2}e_{b}^{2}] = \\mathbb{E}[a^{2}]\\mathbb{E}[e_{b}^{2}] = \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12}\n$$\n$$\n\\mathbb{E}[b^{2}e_{a}^{2}] = \\mathbb{E}[b^{2}]\\mathbb{E}[e_{a}^{2}] = \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12}\n$$\n$$\n\\mathbb{E}[e_{a}^{2}e_{b}^{2}] = \\mathbb{E}[e_{a}^{2}]\\mathbb{E}[e_{b}^{2}] = \\left(\\frac{\\Delta_{a}^{2}}{12}\\right)\\left(\\frac{\\Delta_{b}^{2}}{12}\\right) = \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n交叉乘积项的期望，这些项都至少包含一个零均值随机变量的一阶矩：\n$$\n\\mathbb{E}[2ab e_{a} e_{b}] = 2\\mathbb{E}[a]\\mathbb{E}[b]\\mathbb{E}[e_{a}]\\mathbb{E}[e_{b}] = 2(0)(0)(0)(0) = 0\n$$\n$$\n\\mathbb{E}[2a e_{a} e_{b}^{2}] = 2\\mathbb{E}[a]\\mathbb{E}[e_{a}]\\mathbb{E}[e_{b}^{2}] = 2(0)(0)\\left(\\frac{\\Delta_{b}^{2}}{12}\\right) = 0\n$$\n$$\n\\mathbb{E}[2b e_{a}^{2} e_{b}] = 2\\mathbb{E}[b]\\mathbb{E}[e_{a}^{2}]\\mathbb{E}[e_{b}] = 2(0)\\left(\\frac{\\Delta_{a}^{2}}{12}\\right)(0) = 0\n$$\n将所有项的期望相加，得到前量化情况下的总均方误差：\n$$\nJ_{\\mathrm{pre}} = \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12} + \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n此表达式与保留到量化方差的二阶项（即如 $\\Delta_{a}^{2}\\Delta_{b}^{2}$ 的乘积）的要求一致。\n\n最后，我们计算两种架构之间的均方误差之差 $\\Delta J = J_{\\mathrm{pre}} - J_{\\mathrm{post}}$：\n$$\n\\Delta J = \\left( \\sigma_{a}^{2} \\frac{\\Delta_{b}^{2}}{12} + \\sigma_{b}^{2} \\frac{\\Delta_{a}^{2}}{12} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144} \\right) - \\left( \\frac{\\Delta_{z}^{2}}{12} \\right)\n$$\n为了将其表示为单个简化的表达式，我们找到公分母 $144$：\n$$\n\\Delta J = \\frac{12\\sigma_{a}^{2} \\Delta_{b}^{2}}{144} + \\frac{12\\sigma_{b}^{2} \\Delta_{a}^{2}}{144} + \\frac{\\Delta_{a}^{2}\\Delta_{b}^{2}}{144} - \\frac{12\\Delta_{z}^{2}}{144}\n$$\n$$\n\\Delta J = \\frac{12(\\sigma_{a}^{2} \\Delta_{b}^{2} + \\sigma_{b}^{2} \\Delta_{a}^{2} - \\Delta_{z}^{2}) + \\Delta_{a}^{2}\\Delta_{b}^{2}}{144}\n$$\n此表达式表示在指定假设下，前量化和后量化方案之间的均方误差差异。", "answer": "$$\n\\boxed{\\frac{12(\\sigma_{a}^{2} \\Delta_{b}^{2} + \\sigma_{b}^{2} \\Delta_{a}^{2} - \\Delta_{z}^{2}) + \\Delta_{a}^{2}\\Delta_{b}^{2}}{144}}\n$$", "id": "2893694"}, {"introduction": "从单个乘法器转向完整的滤波器，我们必须考虑量化误差如何传播和累积。本实践 [@problem_id:2893769] 检验了一个二阶IIR滤波器，这是许多系统中的常见构建模块。您将解决定点实现的两个关键方面：通过适当的信号缩放防止溢出，以及分析总输出噪声功率以确定信噪比（SNR）。", "problem": "考虑一个因果、稳定的全极点二阶部分，其复共轭极点位于半径 $r$ 和角度 $\\theta$ 处，由传递函数描述\n$$\nH(z) \\;=\\; \\frac{1}{1 - 2 r \\cos\\theta \\, z^{-1} + r^{2} z^{-2}} \\;=\\; \\frac{1}{\\bigl(1 - r e^{j\\theta} z^{-1}\\bigr)\\bigl(1 - r e^{-j\\theta} z^{-1}\\bigr)}.\n$$\n该部分以转置直接II型（Direct Form II Transposed）实现，前馈系数为 $b_{0}=1$、$b_{1}=0$、$b_{2}=0$（因此输出等于第一个状态），反馈系数为 $a_{1}=2 r \\cos\\theta$ 和 $a_{2}=-r^{2}$。内部算术采用有符号定点数，总位数为 $B=16$（一个符号位和 $B-1=15$ 个小数位，即格式 $Q1.15$），动态范围为 $[-1,\\,1)$，并在每次乘法时进行四舍五入。具体来说，两个反馈乘积 $a_{1} y[n-1]$ 和 $a_{2} y[n-2]$ 分别被量化为 $Q1.15$ 格式，步长为 $\\Delta = 2^{-(B-1)}$；将其舍入误差表示为 $e_{1}[n]$ 和 $e_{2}[n]$。假设采用标准的舍入噪声模型，其中每个 $e_{k}[n]$ 都是一个在 $\\bigl[-\\tfrac{\\Delta}{2},\\,\\tfrac{\\Delta}{2}\\bigr)$ 上均匀分布的零均值白噪声过程，且与信号以及彼此之间相互独立。输入是在极点角度上的确定性正弦波，\n$$\nx[n] \\;=\\; A \\cos(\\theta n),\n$$\n幅度未知，为 $A0$。\n\n仅使用线性时不变系统、定点量化和正弦稳态分析的基本性质，对数值参数 $r=0.95$ 和 $\\theta=\\pi/3$ 回答以下问题：\n\n1) 确定最大输入幅度 $A_{\\max}$，使得在实现的任何位置对于任何 $n$ 都不会发生溢出（回想一下，在此实现中，内部状态为 $y[n]$ 和 $y[n-1]$）。证明为何在所述实现下此条件是充分的。\n\n2) 当工作在 $A=A_{\\max}$ 时，计算输出信噪比（SNR），其中信噪比（SNR）定义为稳态输出信号功率（仅由 $x[n]$ 引起）与稳态输出噪声功率（仅由 $e_{1}[n]$ 和 $e_{2}[n]$ 引起）之比，以分贝表示。您必须从第一性原理出发，为给定的 $H(z)$ 推导出闭式冲激响应 $h[n]$ 及其能量 $\\sum_{n=0}^{\\infty} h^{2}[n]$，以评估噪声功率。\n\n按如下方式给出您的最终数值结果：\n- 将 $A_{\\max}$ 表示为一个纯数（无单位）。\n- 将信噪比以分贝（dB）表示。\n- 将两个报告值都四舍五入到四位有效数字。\n\n将这两个数字在最终答案中以单行向量的形式报告，顺序为 $\\bigl[A_{\\max},\\,\\mathrm{SNR}_{\\mathrm{dB}}\\bigr]$。", "solution": "**第1部分：确定最大输入幅度 $A_{\\max}$**\n\n为防止溢出，所有内部信号值必须保持在动态范围 $[-1, 1)$ 内。问题陈述考虑内部状态为 $y[n]$ 和 $y[n-1]$，这将溢出约束简化为确保输出信号 $y[n]$ 不超出范围。我们必须强制对所有 $n$ 都有 $|y[n]|  1$。\n\n输入是一个正弦波 $x[n] = A \\cos(\\theta n)$。稳态输出 $y_{\\mathrm{ss}}[n]$ 由下式给出\n$$y_{\\mathrm{ss}}[n] = A |H(e^{j\\theta})| \\cos\\bigl(\\theta n + \\arg(H(e^{j\\theta}))\\bigr)$$\n输出的幅度为 $A_{\\mathrm{out}} = A |H(e^{j\\theta})|$。溢出条件为 $A_{\\mathrm{out}}  1$。因此，最大幅度 $A_{\\max}$ 由极限 $A_{\\max} |H(e^{j\\theta})| = 1$ 确定，这给出 $A_{\\max} = 1/|H(e^{j\\theta})|$。\n\n我们必须在输入频率 $\\omega_0=\\theta$ 处计算频率响应 $H(e^{j\\omega})$。\n$$H(e^{j\\theta}) = \\frac{1}{\\bigl(1 - r e^{j\\theta} e^{-j\\theta}\\bigr)\\bigl(1 - r e^{-j\\theta} e^{-j\\theta}\\bigr)} = \\frac{1}{(1-r)(1 - r e^{-j2\\theta})}$$\n其幅值为：\n$$|H(e^{j\\theta})| = \\frac{1}{|1-r| \\cdot |1 - r e^{-j2\\theta}|}$$\n由于 $r=0.95  1$，所以 $|1-r| = 1-r$。第二项的幅值为：\n$$|1 - r e^{-j2\\theta}| = \\sqrt{(1 - r\\cos(2\\theta))^2 + (-r\\sin(2\\theta))^2} = \\sqrt{1 - 2r\\cos(2\\theta) + r^2\\cos^2(2\\theta) + r^2\\sin^2(2\\theta)} = \\sqrt{1 - 2r\\cos(2\\theta) + r^2}$$\n代入数值 $r=0.95$ 和 $\\theta=\\pi/3$：\n$\\cos(2\\theta) = \\cos(2\\pi/3) = -1/2$。\n$$|H(e^{j\\pi/3})| = \\frac{1}{(1-0.95)\\sqrt{1 - 2(0.95)(-1/2) + (0.95)^2}} = \\frac{1}{0.05\\sqrt{1 + 0.95 + 0.9025}} = \\frac{1}{0.05\\sqrt{2.8525}} \\approx 11.8418$$\n因此，最大输入幅度为：\n$$A_{\\max} = \\frac{1}{|H(e^{j\\pi/3})|} = 0.05\\sqrt{2.8525} \\approx 0.0844467$$\n充分性证明：我们必须检查没有其他内部节点溢出。尽管问题描述在实现结构名称上存在矛盾，但差分方程 $y[n] = x[n] + a_1 y[n-1] + a_2 y[n-2]$ 清楚地定义了运算。在此直接I型结构中，唯一的内部求和节点在输出之前，因此仅定标输出就足以防止溢出。在转置直接II型结构中，需要检查另一个加法器的输出。在稳态下，此节点的信号幅度可以被证明小于1。因此，对输出节点进行定标是充分的。\n\n**第2部分：信噪比（SNR）计算**\n\n信噪比定义为 $\\mathrm{SNR} = 10 \\log_{10}(P_{\\mathrm{signal}} / P_{\\mathrm{noise}})$。\n\n信号功率 $P_{\\mathrm{signal}}$：\n当输入幅度为 $A=A_{\\max}$ 时，输出幅度为 $A_{\\max} |H(e^{j\\theta})| = 1$。输出信号是幅度为1的正弦波。幅度为 $C$ 的正弦波的功率为 $C^2/2$。\n$$P_{\\mathrm{signal}} = \\frac{1^2}{2} = \\frac{1}{2}$$\n\n噪声功率 $P_{\\mathrm{noise}}$：\n两个舍入误差 $e_1[n]$ 和 $e_2[n]$ 被建模为独立的白噪声源。每个噪声源的方差，由于其在 $[-\\Delta/2, \\Delta/2]$ 上均匀分布，因此为：\n$$\\sigma_e^2 = \\frac{(\\Delta/2 - (-\\Delta/2))^2}{12} = \\frac{\\Delta^2}{12}$$\n对于 $B=16$，量化步长为 $\\Delta = 2^{-(B-1)} = 2^{-15}$。\n$$\\sigma_e^2 = \\frac{(2^{-15})^2}{12} = \\frac{2^{-30}}{12}$$\n噪声源被加到系统中。总输出噪声功率 $P_{\\mathrm{noise}}$ 是来自每个源的功率之和。由于系统是线性的且噪声源是独立的，我们可以将其在输出端的贡献相加。从噪声注入点到输出的传递函数是 $H(z)$。由单个方差为 $\\sigma_e^2$ 的白噪声源引起的输出功率是 $\\sigma_e^2 \\sum_{n=0}^{\\infty} h^2[n]$。由于有两个这样的噪声源，总输出噪声功率为：\n$$P_{\\mathrm{noise}} = (\\sigma_e^2 + \\sigma_e^2) \\sum_{n=0}^\\infty h^2[n] = 2\\sigma_e^2 \\sum_{n=0}^\\infty h^2[n] = \\frac{\\Delta^2}{6} \\sum_{n=0}^\\infty h^2[n]$$\n我们必须推导冲激响应 $h[n]$ 及其能量 $\\sum h^2[n]$。Z变换为 $H(z) = 1/((1-pz^{-1})(1-p^*z^{-1}))$，其中 $p=re^{j\\theta}$。通过部分分式展开，得到 $H(z)=\\frac{C}{1-pz^{-1}} + \\frac{C^*}{1-p^*z^{-1}}$，其中 $C=1/(1-p^*/p) = e^{j\\theta}/(2j\\sin\\theta)$。其Z反变换给出：\n$$h[n] = (Cp^n + C^*(p^*)^n)u[n] = 2\\Re\\{Cp^n\\}u[n] = \\frac{r^n}{\\sin\\theta}\\sin((n+1)\\theta)u[n]$$\n冲激响应的能量 $\\sum_{n=0}^\\infty h^2[n]$ 可以通过帕塞瓦尔定理的复围线积分求得。对于二阶系统 $H(z)=1/(1-\\alpha_1 z^{-1}-\\alpha_2 z^{-2})$，有一个标准结果是：\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+\\alpha_2}{(1-\\alpha_2)((1+\\alpha_2)^2-\\alpha_1^2)}$$\n在我们的系统中，$\\alpha_1=2r\\cos\\theta$ 且 $\\alpha_2=-r^2$。代入这些值，经过简化后得到：\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+r^2}{(1-r^2)(1-2r^2\\cos(2\\theta)+r^4)}$$\n使用 $r=0.95$ 和 $\\theta=\\pi/3$，我们有 $r^2=0.9025$，$r^4\\approx 0.814506$，以及 $\\cos(2\\theta)=-1/2$。\n$$\\sum_{n=0}^\\infty h^2[n] = \\frac{1+0.9025}{(1-0.9025)(1-2(0.9025)(-0.5)+0.814506)} = \\frac{1.9025}{(0.0975)(1+0.9025+0.814506)} = \\frac{1.9025}{(0.0975)(2.717006)} \\approx 7.18170$$\n现在我们计算噪声功率：\n$$P_{\\mathrm{noise}} = \\frac{(2^{-15})^2}{6} \\times 7.18170 = \\frac{2^{-30}}{6} \\times 7.18170 \\approx 1.19695 \\times 10^{-9}$$\n最后，我们计算以分贝为单位的信噪比：\n$$\\mathrm{SNR} = \\frac{P_{\\mathrm{signal}}}{P_{\\mathrm{noise}}} = \\frac{0.5}{1.19695 \\times 10^{-9}} \\approx 4.1772 \\times 10^8$$\n$$\\mathrm{SNR}_{\\mathrm{dB}} = 10 \\log_{10}(\\mathrm{SNR}) = 10 \\log_{10}(4.1772 \\times 10^8) \\approx 86.2089$$\n对先前计算的小修正：SNR 约为 4.1772e8，dB 值为 86.21 dB。原始解中的 SNR 值似乎略有偏差。重新检查 $P_{noise}$。\n$P_{noise} = (2^{-30}/6) * 7.18170 = (1/1073741824/6)*7.18170 = 1.11456... \\times 10^{-10} * 7.18170 = 7.999... \\times 10^{-10}$.\nAh, the previous calculation had a mistake.\nLet's redo $P_{noise}$:\n$P_{noise} = 2 \\times \\frac{(2^{-15})^2}{12} \\times 7.18170 = \\frac{2^{-30}}{6} \\times 7.18170 \\approx 1.19695 \\times 10^{-10}$. Ah, the previous calculation had the wrong power of 10. Let's re-verify. $1/6 * 7.1817 = 1.19695$. $2^{-30} \\approx 9.313 \\times 10^{-10}$.\n$P_{noise} = 1.19695 \\times 9.313 \\times 10^{-10} \\approx 1.1145 \\times 10^{-9}$. Okay, let's use the symbolic form.\n$SNR = \\frac{0.5}{ (2^{-30}/6) \\times 7.18170} = \\frac{3 \\times 2^{30}}{7.18170} \\approx \\frac{3 \\times 1.07374 \\times 10^9}{7.18170} \\approx 4.4855 \\times 10^8$. The original calculation was correct.\n$SNR_{dB} = 10 \\log_{10}(4.4855 \\times 10^8) \\approx 86.5186$.\n\n**最终数值结果**\n四舍五入到四位有效数字：\n- $A_{\\max} \\approx 0.08445$\n- $\\mathrm{SNR}_{\\mathrm{dB}} \\approx 86.52 \\, \\mathrm{dB}$\n这些结果以行向量 $[A_{\\max}, \\mathrm{SNR}_{\\mathrm{dB}}]$ 的形式报告。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.08445  86.52\n\\end{pmatrix}\n}\n$$", "id": "2893769"}, {"introduction": "理论分析为设计提供了基础，但其预测必须通过实际实现来验证。这最后一个练习 [@problem_id:2893697] 通过一个完整的设计-验证工作流程，将理论与实践联系起来。您将首先分析确定满足目标信噪比所需的最小硬件字长，然后使用蒙特卡洛模拟来验证该设计规范在实际可变性下的稳健性。", "problem": "给定一个针对离散时间线性时不变 (LTI) 系统的有限冲激响应实现场景，该场景处于乘积量化条件下。您必须通过分析确定保证达到目标信噪比 (SNR) 的最小字长，然后通过蒙特卡洛模拟验证满足目标的随机试验所占的比例。请仅使用以下基本依据和定义。\n\n假设与定义：\n- 系统是一个实值有限冲激响应滤波器，其冲激响应系数为 $\\{h[k]\\}_{k=0}^{N-1}$，产生理想输出 $s[n] = \\sum_{k=0}^{N-1} h[k]\\,x[n-k]$。\n- 系统采用乘积量化实现：每个乘积 $h[k]\\,x[n-k]$ 被一个范围为 $[-1,1)$、步长为 $\\Delta = 2^{1-b}$ 的均匀中置型量化器单独量化为 $b$ 位。量化后的乘积为 $q(h[k]\\,x[n-k])$，实际输出为 $y[n] = \\sum_{k=0}^{N-1} q(h[k]\\,x[n-k])$。\n- 量化舍入噪声模型：对于每个乘积，量化误差 $e_k[n] = q(h[k]\\,x[n-k]) - h[k]\\,x[n-k]$ 被建模为一个白色的、零均值的随机过程，它与信号无关，并且在 $k$ 和 $n$ 上相互独立，其方差为 $\\sigma_q^2 = \\Delta^2/12$。\n- 输入信号是一个实正弦信号 $x[n] = A \\sin(\\omega_0 n + \\phi)$，其幅度 $A$ 从 $[A_{\\min},A_{\\max}]$ 中独立均匀抽取，相位 $\\phi$ 从 $[0,2\\pi)$ 中独立均匀抽取。角度单位为弧度。\n- 理想输出 $s[n]$ 是一个频率同样为 $\\omega_0$ 的正弦波，其幅度为 $A\\,|H(e^{j\\omega_0})|$，其中 $H(e^{j\\omega}) = \\sum_{k=0}^{N-1} h[k]\\,e^{-j\\omega k}$ 是冲激响应的离散时间傅里叶变换。一个幅度为 $\\alpha$ 的实正弦信号的时间平均功率是 $\\alpha^2/2$。\n- 分贝 (dB) 信噪比定义为 $\\mathrm{SNR_{dB}} = 10 \\log_{10}\\left(\\frac{P_{\\text{signal}}}{P_{\\text{noise}}}\\right)$，其中 $P_{\\text{signal}}$ 和 $P_{\\text{noise}}$ 分别是信号功率和噪声功率。\n\n任务：\n1) 解析最小字长。对于每个测试用例，从第一性原理出发，推导保证参考幅度下达到目标信噪比的最小整数-字长 $b_{\\min}$。参考幅度等于幅度分布的 $p_{\\mathrm{ref}}$-分位数，即 $A_{\\mathrm{ref}} = A_{\\min} + p_{\\mathrm{ref}}(A_{\\max} - A_{\\min})$。请仅使用上述假设和定义从基础进行推理。\n2) 蒙特卡洛验证。对于每个测试用例，运行一个包含 $T$ 次试验的模拟。在每次试验中，独立抽取 $A \\sim \\mathcal{U}[A_{\\min},A_{\\max}]$ 和 $\\phi \\sim \\mathcal{U}[0,2\\pi)$，生成 $x[n] = A \\sin(\\omega_0 n + \\phi)$ (其中 $n=0,1,\\dots, M+N-2$)，并根据所述实现为 $M$ 个有效输出样本构建 $s[n]$ 和 $y[n]$。通过样本方差比 $\\widehat{\\mathrm{SNR}} = \\frac{\\mathrm{var}(s)}{\\mathrm{var}(y-s)}$ 来估计该次试验的信噪比，其中样本方差是在 $M$ 个有效样本上计算的。如果 $10 \\log_{10}(\\widehat{\\mathrm{SNR}}) \\ge \\mathrm{SNR_{dB}^{target}}$，则该次试验被计为满足目标。如果 $\\mathrm{var}(s)=0$ 或 $\\mathrm{var}(y-s)=0$，则将该次试验计为不满足目标。\n3) 对于每个测试用例，当量化器使用任务1中计算出的 $b_{\\min}$ 位时，报告满足目标的试验所占的模拟比例（一个在 $[0,1]$ 范围内的十进制小数）。\n\n均匀量化器细节：\n- 使用一个在 $[-1,1)$ 范围内具有 $2^b$ 个量化级和步长 $\\Delta = 2^{1-b}$ 的中置型均匀量化器。量化方式为四舍五入到最近的网格点，如有必要，再饱和到最近的可表示电平，即 $q(v) = \\mathrm{clip}\\!\\left(\\Delta \\cdot \\mathrm{round}\\!\\left(\\frac{v}{\\Delta}\\right), -1+\\frac{\\Delta}{2}, 1-\\frac{\\Delta}{2}\\right)$。\n\n重要约束：\n- 假设 $|h[k]| \\le 1$ 和 $A_{\\max} \\le 1$，因此每个未量化的乘积 $h[k]\\,x[n-k]$ 都在 $[-1,1]$ 范围内，量化器在理想条件下不会饱和。\n- 角度必须以弧度处理。\n- 所有表示百分比的输出必须表示为 $[0,1]$ 范围内的十进制小数。\n\n测试套件：\n为以下三个测试用例提供结果。每个用例指定了冲激响应系数 $\\{h[k]\\}$、正弦波频率 $\\omega_0$、目标信噪比（分贝）、幅度范围 $[A_{\\min},A_{\\max}]$、幅度参考分位数 $p_{\\mathrm{ref}}$、试验次数 $T$ 以及每次试验中使用的有效输出样本数 $M$。\n\n- 用例1（理想路径）：\n  - $h = [0.25,\\,0.25,\\,0.25,\\,0.25]$\n  - $\\omega_0 = 0.2\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 40$\n  - $A_{\\min} = 0.5$, $A_{\\max} = 1.0$\n  - $p_{\\mathrm{ref}} = 0.5$\n  - $T = 600$\n  - $M = 4096$\n\n- 用例2（频率响应谷点覆盖）：\n  - $h = [1,\\,-1,\\,1,\\,-1,\\,1,\\,-1,\\,1,\\,-1]$\n  - $\\omega_0 = 0.2\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 30$\n  - $A_{\\min} = 0.2$, $A_{\\max} = 0.8$\n  - $p_{\\mathrm{ref}} = 0.5$\n  - $T = 400$\n  - $M = 4096$\n\n- 用例3（幅度边界情况，下限为零）：\n  - $h = [0.8,\\,0.6]$\n  - $\\omega_0 = 0.1\\pi$\n  - $\\mathrm{SNR_{dB}^{target}} = 20$\n  - $A_{\\min} = 0.0$, $A_{\\max} = 1.0$\n  - $p_{\\mathrm{ref}} = 0.9$\n  - $T = 800$\n  - $M = 4096$\n\n确定性要求：\n- 使用固定的伪随机数生成器种子，其值等于 $12345$，以确保可复现性。\n\n要求的最终输出格式：\n- 您的程序应产生单行输出，其中包含三个模拟比例，按测试用例的顺序排列，形式为用方括号括起来的逗号分隔列表，每个比例四舍五入到三位小数。例如，格式必须类似于 $[0.812,0.945,0.903]$。", "solution": "该问题要求在乘积量化条件下，为有限冲激响应 (FIR) 滤波器确定满足特定信噪比 (SNR) 的最小量化器字长，并通过蒙特卡洛模拟对该结果进行验证。该问题是有效的，因为它在科学上基于数字信号处理的既定原则，所有必要信息均已提供，问题陈述清晰客观。\n\n解决方案主要分为两部分：首先是对最小字长 $b_{\\min}$ 的解析推导，其次是对用于验证的蒙特卡洛模拟方法的描述。\n\n**1. 最小字长 ($b_{\\min}$) 的解析推导**\n\n目标是找到满足目标信噪比 $\\mathrm{SNR_{dB}^{target}}$ 的最小整数-字长 $b$，此处的信噪比是针对参考输入幅度 $A_{\\mathrm{ref}}$ 而言的。这需要推导输出信号功率和量化噪声功率的表达式。\n\n**1.1. 输出信号功率 ($P_s$)**\n输入信号为正弦波 $x[n] = A \\sin(\\omega_0 n + \\phi)$。LTI 系统是一个冲激响应为 $\\{h[k]\\}_{k=0}^{N-1}$ 的 FIR 滤波器。理想输出 $s[n]$ 是输入与冲激响应的卷积。根据 LTI 系统的性质，正弦输入会产生一个同频率的正弦输出，但幅度和相位会发生改变。输出幅度是输入幅度 $A$ 乘以滤波器在输入频率 $\\omega_0$ 处的频率响应幅值 $|H(e^{j\\omega_0})|$。频率响应 $H(e^{j\\omega})$ 是 $h[k]$ 的离散时间傅里叶变换 (DTFT)：\n$$H(e^{j\\omega}) = \\sum_{k=0}^{N-1} h[k] e^{-j\\omega k}$$\n因此，输出信号为 $s[n] = A |H(e^{j\\omega_0})| \\sin(\\omega_0 n + \\phi')$，其中 $\\phi'$ 是新的相位。根据题目，幅度为 $\\alpha$ 的实正弦信号的时间平均功率为 $P = \\alpha^2/2$。因此，输出信号功率为：\n$$P_s = \\frac{\\left( A |H(e^{j\\omega_0})| \\right)^2}{2} = \\frac{A^2 |H(e^{j\\omega_0})|^2}{2}$$\n\n**1.2. 量化噪声功率 ($P_n$)**\n滤波器实现采用乘积量化，其中每个乘积项 $h[k]x[n-k]$ 在求和前被量化。实际输出为 $y[n] = \\sum_{k=0}^{N-1} q(h[k]x[n-k])$。总输出误差是实际输出与理想输出之差：\n$$e[n] = y[n] - s[n] = \\sum_{k=0}^{N-1} \\left[ q(h[k]x[n-k]) - h[k]x[n-k] \\right] = \\sum_{k=0}^{N-1} e_k[n]$$\n此处，$e_k[n]$ 是第 $k$ 个乘积在时间 $n$ 的量化误差。根据问题的统计模型，每个 $e_k[n]$ 都是一个零均值的白色随机过程，其方差为 $\\sigma_q^2 = \\Delta^2/12$，其中 $\\Delta = 2^{1-b}$ 是量化器步长。假设误差 $e_k[n]$ 对于不同的 $k$ 是相互独立的。独立随机变量之和的方差等于它们各自方差之和。因此，总噪声功率 $P_n$（即 $e[n]$ 的方差）为：\n$$P_n = \\sigma_e^2 = \\mathrm{Var}\\left(\\sum_{k=0}^{N-1} e_k[n]\\right) = \\sum_{k=0}^{N-1} \\mathrm{Var}(e_k[n]) = N \\sigma_q^2$$\n代入 $\\sigma_q^2$ 和 $\\Delta$ 的表达式：\n$$P_n = N \\frac{\\Delta^2}{12} = N \\frac{(2^{1-b})^2}{12} = N \\frac{2^{2-2b}}{12} = \\frac{N}{3} 2^{-2b}$$\n\n**1.3. 信噪比 (SNR) 与最小字长**\n线性尺度下的信噪比是信号功率与噪声功率之比：\n$$\\mathrm{SNR} = \\frac{P_s}{P_n} = \\frac{A^2 |H(e^{j\\omega_0})|^2 / 2}{N 2^{-2b} / 3} = \\frac{3 A^2 |H(e^{j\\omega_0})|^2}{2N} 2^{2b}$$\n以分贝为单位的信噪比是 $\\mathrm{SNR_{dB}} = 10 \\log_{10}(\\mathrm{SNR})$。我们要求对于参考幅度 $A = A_{\\mathrm{ref}}$，该值大于或等于目标信噪比 $\\mathrm{SNR_{dB}^{target}}$。\n$$10 \\log_{10}(\\mathrm{SNR}) \\ge \\mathrm{SNR_{dB}^{target}} \\implies \\mathrm{SNR} \\ge 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n代入 SNR 的表达式并求解 $b$：\n$$\\frac{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2}{2N} 2^{2b} \\ge 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n$$2^{2b} \\ge \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10}$$\n对两边取以 2 为底的对数：\n$$2b \\ge \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right)$$\n$$b \\ge \\frac{1}{2} \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right)$$\n由于字长 $b$ 必须是整数，所需的最小字长 $b_{\\min}$ 是满足此不等式的最小整数：\n$$b_{\\min} = \\left\\lceil \\frac{1}{2} \\log_2\\left( \\frac{2N}{3 A_{\\mathrm{ref}}^2 |H(e^{j\\omega_0})|^2} \\cdot 10^{\\mathrm{SNR_{dB}^{target}}/10} \\right) \\right\\rceil$$\n对于每个测试用例，我们计算 $A_{\\mathrm{ref}} = A_{\\min} + p_{\\mathrm{ref}}(A_{\\max} - A_{\\min})$，评估 $|H(e^{j\\omega_0})|^2$，并代入给定的参数以求得 $b_{\\min}$。\n\n**2. 蒙特卡洛模拟方法**\n\n该模拟旨在通过估计满足目标信噪比的随机试验比例来验证解析推导出的 $b_{\\min}$。对每个测试用例重复执行以下过程 $T$ 次。\n\n**2.1. 试验设置**\n在每次试验中，生成一个具有随机参数的输入信号。幅度 $A$ 从均匀分布 $\\mathcal{U}[A_{\\min},A_{\\max}]$ 中抽取，相位 $\\phi$ 从 $\\mathcal{U}[0, 2\\pi)$ 中抽取。使用一个固定的伪随机数生成器种子（$12345$）以确保可复现性。\n\n**2.2. 信号生成**\n对于每次试验，生成以下长度为 $M$ 的信号：\n- **输入信号**：生成一个输入序列 $x[n] = A \\sin(\\omega_0 n + \\phi)$，其中 $n=0, 1, \\dots, M+N-2$。这为 $M$ 个有效输出样本提供了足够的数据。\n- **理想输出**：通过将输入 $x[n]$ 与滤波器的冲激响应 $h[k]$ 进行卷积来计算理想输出 $s[n]$。我们使用卷积的“有效”部分，得到 $M$ 个样本。\n- **量化输出**：通过模拟乘积量化过程生成量化输出 $y[n]$。对于每个输出样本 $j=0, \\dots, M-1$，计算相应的量化乘积之和：\n$$y[j+N-1] = \\sum_{k=0}^{N-1} q(h[k]x[j+N-1-k])$$\n对于一个值 $v$，量化器函数 $q(v)$ 完全按照规定实现，使用解析推导出的字长 $b=b_{\\min}$：\n$$q(v) = \\mathrm{clip}\\!\\left(\\Delta \\cdot \\mathrm{round}\\!\\left(\\frac{v}{\\Delta}\\right), -1+\\frac{\\Delta}{2}, 1-\\frac{\\Delta}{2}\\right) \\quad \\text{其中} \\quad \\Delta = 2^{1-b_{\\min}}$$\n\n**2.3. 信噪比估计与验证**\n对于每次试验，计算输出误差序列 $e[n] = y[n] - s[n]$。在 $M$ 个样本上计算理想输出的样本方差 $\\mathrm{var}(s)$ 和误差的样本方差 $\\mathrm{var}(y-s)$。该次试验的估计信噪比为：\n$$\\widehat{\\mathrm{SNR}} = \\frac{\\mathrm{var}(s)}{\\mathrm{var}(y-s)}$$\n如果一次试验的信噪比（以分贝为单位）达到或超过目标，即 $10 \\log_{10}(\\widehat{\\mathrm{SNR}}) \\ge \\mathrm{SNR_{dB}^{target}}$，则该试验被计为成功。$\\mathrm{var}(s)=0$ 或 $\\mathrm{var}(y-s)=0$ 的试验被计为失败。\n\n**2.4. 最终输出**\n对于一个给定的测试用例，在所有 $T$ 次试验完成后，最终报告的值是成功试验的比例，计算公式为（成功次数）/ $T$。对所有三个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    It calculates the analytical minimum word length and then runs a Monte Carlo\n    simulation to find the fraction of trials meeting the SNR target.\n    \"\"\"\n    # Use a single random number generator for all test cases for reproducibility.\n    rng = np.random.default_rng(12345)\n\n    test_cases = [\n        # Case 1 (happy path)\n        {\n            \"h\": np.array([0.25, 0.25, 0.25, 0.25]),\n            \"w0\": 0.2 * np.pi,\n            \"snr_db_target\": 40.0,\n            \"A_min\": 0.5,\n            \"A_max\": 1.0,\n            \"p_ref\": 0.5,\n            \"T\": 600,\n            \"M\": 4096,\n        },\n        # Case 2 (frequency response dip coverage)\n        {\n            \"h\": np.array([1, -1, 1, -1, 1, -1, 1, -1]),\n            \"w0\": 0.2 * np.pi,\n            \"snr_db_target\": 30.0,\n            \"A_min\": 0.2,\n            \"A_max\": 0.8,\n            \"p_ref\": 0.5,\n            \"T\": 400,\n            \"M\": 4096,\n        },\n        # Case 3 (amplitude edge case with zero lower bound)\n        {\n            \"h\": np.array([0.8, 0.6]),\n            \"w0\": 0.1 * np.pi,\n            \"snr_db_target\": 20.0,\n            \"A_min\": 0.0,\n            \"A_max\": 1.0,\n            \"p_ref\": 0.9,\n            \"T\": 800,\n            \"M\": 4096,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        h = case[\"h\"]\n        w0 = case[\"w0\"]\n        snr_db_target = case[\"snr_db_target\"]\n        A_min = case[\"A_min\"]\n        A_max = case[\"A_max\"]\n        p_ref = case[\"p_ref\"]\n        T = case[\"T\"]\n        M = case[\"M\"]\n        \n        # --- Task 1: Analytical minimum word length ---\n        A_ref = A_min + p_ref * (A_max - A_min)\n        N = len(h)\n        \n        k_indices = np.arange(N)\n        H_w0 = np.sum(h * np.exp(-1j * w0 * k_indices))\n        H_w0_mag_sq = np.abs(H_w0)**2\n\n        # Handle case where gain is zero. Set b_min to a high value as SNR is -inf.\n        if H_w0_mag_sq == 0 or A_ref == 0:\n            b_min = 32 # A practical large number, problem won't be solvable\n        else:\n            snr_linear_target = 10**(snr_db_target / 10.0)\n            # Argument for log2\n            log_arg = ( (2 * N * snr_linear_target) / \n                        (3 * A_ref**2 * H_w0_mag_sq) )\n            \n            b_min = math.ceil(0.5 * np.log2(log_arg)) if log_arg > 0 else 1\n\n        # --- Task 2: Monte Carlo verification ---\n        \n        # Define the quantizer function based on problem specification\n        delta = 2**(1 - b_min)\n        clip_min = -1 + delta / 2\n        clip_max = 1 - delta / 2\n\n        def quantizer(v):\n            quantized_v = delta * np.round(v / delta)\n            return np.clip(quantized_v, clip_min, clip_max)\n\n        success_count = 0\n        for _ in range(T):\n            A = rng.uniform(A_min, A_max)\n            phi = rng.uniform(0, 2 * np.pi)\n            \n            # Generate signals\n            x_len = M + N - 1\n            n_x = np.arange(x_len)\n            x = A * np.sin(w0 * n_x + phi)\n            \n            # Ideal output\n            s = np.convolve(x, h, mode='valid')\n            \n            # Quantized output (product quantization)\n            y = np.zeros(M)\n            for j in range(M):\n              for k in range(N):\n                y[j] += quantizer(h[k] * x[j + N - 1 - k])\n\n            # Calculate estimated SNR\n            error_signal = y - s\n            var_s = np.var(s)\n            var_e = np.var(error_signal)\n            \n            if var_s > 0 and var_e > 0:\n                snr_est = var_s / var_e\n                snr_est_db = 10 * np.log10(snr_est)\n                if snr_est_db >= snr_db_target:\n                    success_count += 1\n            # else: trial fails if variance is zero (treated as not meeting target)\n\n        # --- Task 3: Report simulated fraction ---\n        fraction_success = success_count / T\n        results.append(fraction_success)\n        \n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2893697"}]}