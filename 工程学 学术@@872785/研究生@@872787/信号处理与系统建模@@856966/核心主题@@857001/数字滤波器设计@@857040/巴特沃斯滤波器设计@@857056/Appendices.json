{"hands_on_practices": [{"introduction": "滤波器设计的第一个也是最关键的步骤，是将抽象的性能要求（例如通带纹波和阻带衰减）转换为一个具体的设计参数。本练习 ([@problem_id:2856532]) 演示了如何根据给定的通带和阻带衰减指标，计算出满足要求的最低滤波器阶数 $N$。掌握这一计算对于在滤波器性能与实现复杂性之间取得平衡至关重要，因为更高的阶数意味着更有效的滤波，但同时也带来了更复杂的结构。", "problem": "一个连续时间巴特沃斯低通滤波器将用于一个测量前端。其通带边界指定在角频率 $\\Omega_{p} = 1$ krad/s 处，最大允许通带衰减为 $A_{p} = 1$ 分贝 (dB)，阻带规范要求在角频率 $\\Omega_{s} = 3$ krad/s 处至少有 $A_{s} = 40$ dB 的衰减。利用一个截止频率为 $\\Omega_{c}$ 的 $N$ 阶巴特沃斯低通滤波器的幅频响应平方由 $|H(j\\Omega)|^2 = \\frac{1}{1 + \\left(\\frac{\\Omega}{\\Omega_c}\\right)^{2N}}$ 给出的定义特性，以及衰减 $A(\\Omega)$（以分贝计）的定义为 $A(\\Omega) = -20 \\log_{10}|H(j\\Omega)|$，确定最小的整数阶数 $N$，使得存在某个 $\\Omega_{c}$ 能同时满足通带和阻带的规范。将您的最终答案表示为一个不带单位的整数。", "solution": "首先对问题进行严格的验证过程。\n\n从问题陈述中逐字提取的已知条件如下：\n- 通带边界角频率：$\\Omega_{p} = 1$ krad/s\n- 最大允许通带衰减：$A_{p} = 1$ dB\n- 阻带边界角频率：$\\Omega_{s} = 3$ krad/s\n- 最小要求阻带衰减：$A_{s} = 40$ dB\n- $N$ 阶巴特沃斯滤波器的幅频响应平方：$|H(j\\Omega)|^2 = \\frac{1}{1 + \\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2N}}$\n- 以分贝为单位的衰减定义：$A(\\Omega) = -20 \\log_{10}|H(j\\Omega)|$\n\n该问题具有科学依据，提法明确且客观。这是一个模拟滤波器设计中的标准问题，基于已建立的公式和原理。所有必要的数据都已提供，约束条件一致，术语精确。因此，该问题被认为是有效的，并将推导求解。\n\n目标是找到最小的整数滤波器阶数 $N$，使得存在一个截止频率 $\\Omega_c$ 满足给定的通带和阻带规范。\n\n首先，我们用幅频响应平方直接表示衰减 $A(\\Omega)$：\n$A(\\Omega) = -20 \\log_{10}|H(j\\Omega)| = -10 \\log_{10}(|H(j\\Omega)|^2)$。\n代入巴特沃斯滤波器的幅频响应平方的给定表达式：\n$A(\\Omega) = -10 \\log_{10}\\left(\\dfrac{1}{1 + \\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2N}}\\right) = 10 \\log_{10}\\left(1 + \\left(\\frac{\\Omega}{\\Omega_{c}}\\right)^{2N}\\right)$。\n\n现在，我们将两个规范转化为不等式。\n\n通带规范为 $A(\\Omega_p) \\leq A_p$：\n$$10 \\log_{10}\\left(1 + \\left(\\frac{\\Omega_p}{\\Omega_c}\\right)^{2N}\\right) \\leq A_p$$\n$$\\log_{10}\\left(1 + \\left(\\frac{\\Omega_p}{\\Omega_c}\\right)^{2N}\\right) \\leq \\frac{A_p}{10}$$\n$$1 + \\left(\\frac{\\Omega_p}{\\Omega_c}\\right)^{2N} \\leq 10^{A_p/10}$$\n$$\\left(\\frac{\\Omega_p}{\\Omega_c}\\right)^{2N} \\leq 10^{A_p/10} - 1 \\quad (1)$$\n\n阻带规范为 $A(\\Omega_s) \\geq A_s$：\n$$10 \\log_{10}\\left(1 + \\left(\\frac{\\Omega_s}{\\Omega_c}\\right)^{2N}\\right) \\geq A_s$$\n$$\\log_{10}\\left(1 + \\left(\\frac{\\Omega_s}{\\Omega_c}\\right)^{2N}\\right) \\geq \\frac{A_s}{10}$$\n$$1 + \\left(\\frac{\\Omega_s}{\\Omega_c}\\right)^{2N} \\geq 10^{A_s/10}$$\n$$\\left(\\frac{\\Omega_s}{\\Omega_c}\\right)^{2N} \\geq 10^{A_s/10} - 1 \\quad (2)$$\n\n为了使解存在，必须有一个 $\\Omega_c$ 的值能同时满足不等式 $(1)$ 和 $(2)$。我们可以从两个不等式中分离出包含 $\\Omega_c$ 的项。\n从 $(1)$ 得：\n$$\\frac{1}{\\Omega_c^{2N}} \\leq \\frac{10^{A_p/10} - 1}{\\Omega_p^{2N}}$$\n从 $(2)$ 得：\n$$\\frac{1}{\\Omega_c^{2N}} \\geq \\frac{10^{A_s/10} - 1}{\\Omega_s^{2N}}$$\n\n结合 $\\frac{1}{\\Omega_c^{2N}}$ 的这两个界限，得到条件：\n$$\\frac{10^{A_s/10} - 1}{\\Omega_s^{2N}} \\leq \\frac{1}{\\Omega_c^{2N}} \\leq \\frac{10^{A_p/10} - 1}{\\Omega_p^{2N}}$$\n这意味着下界必须小于或等于上界：\n$$\\frac{10^{A_s/10} - 1}{\\Omega_s^{2N}} \\leq \\frac{10^{A_p/10} - 1}{\\Omega_p^{2N}}$$\n我们可以重新整理这个不等式来求解 $N$：\n$$\\frac{10^{A_s/10} - 1}{10^{A_p/10} - 1} \\leq \\left(\\frac{\\Omega_s}{\\Omega_p}\\right)^{2N}$$\n为了分离出 $N$，我们对两边取以 $10$ 为底的对数。由于 $\\frac{\\Omega_s}{\\Omega_p}  1$，对数值为正，不等号方向保持不变。\n$$\\log_{10}\\left(\\frac{10^{A_s/10} - 1}{10^{A_p/10} - 1}\\right) \\leq \\log_{10}\\left(\\left(\\frac{\\Omega_s}{\\Omega_p}\\right)^{2N}\\right)$$\n$$\\log_{10}\\left(\\frac{10^{A_s/10} - 1}{10^{A_p/10} - 1}\\right) \\leq 2N \\log_{10}\\left(\\frac{\\Omega_s}{\\Omega_p}\\right)$$\n最后，我们得到滤波器阶数 $N$ 的不等式：\n$$N \\geq \\frac{\\log_{10}\\left(\\frac{10^{A_s/10} - 1}{10^{A_p/10} - 1}\\right)}{2 \\log_{10}\\left(\\frac{\\Omega_s}{\\Omega_p}\\right)}$$\n现在我们代入给定的数值：$A_p = 1$ dB, $A_s = 40$ dB, $\\Omega_p = 1$ krad/s, 以及 $\\Omega_s = 3$ krad/s。\n$$N \\geq \\frac{\\log_{10}\\left(\\frac{10^{40/10} - 1}{10^{1/10} - 1}\\right)}{2 \\log_{10}\\left(\\frac{3}{1}\\right)}$$\n$$N \\geq \\frac{\\log_{10}\\left(\\frac{10^4 - 1}{10^{0.1} - 1}\\right)}{2 \\log_{10}(3)}$$\n我们来计算这些项。对数内部表达式的分数，分子是 $10^4 - 1 = 9999$。分母是 $10^{0.1} - 1$。\n$$N \\geq \\frac{\\log_{10}\\left(\\frac{9999}{10^{0.1} - 1}\\right)}{2 \\log_{10}(3)}$$\n数值上，$10^{0.1} \\approx 1.258925$，所以 $10^{0.1} - 1 \\approx 0.258925$。\n对数内部的分数值约为 $\\frac{9999}{0.258925} \\approx 38618.3$。\n这个值的对数是 $\\log_{10}(38618.3) \\approx 4.58678$。\n主表达式的分母是 $2 \\log_{10}(3) \\approx 2 \\times 0.47712 = 0.95424$。\n$$N \\geq \\frac{4.58678}{0.95424} \\approx 4.8066$$\n由于滤波器阶数 $N$ 必须是整数，我们必须选择大于或等于 $4.8066$ 的最小整数。\n因此，所需的最小整数阶数为 $N = 5$。", "answer": "$$\\boxed{5}$$", "id": "2856532"}, {"introduction": "实际的滤波器设计很少从零开始；它通常利用标准化的、归一化的“原型”滤波器。本练习 ([@problem_id:2856497]) 聚焦于频率变换这一基本技术，展示了如何将一个截止频率为 $\\Omega_c=1$ 的原型滤波器，转换为一个满足特定截止频率要求的新滤波器。这个过程突显了系统设计中一种强大的抽象能力，它允许我们将滤波器的特征“形状”与其频率“尺度”分离开来。", "problem": "一个阶数为 $n \\ge 1$ 的模拟低通巴特沃斯原型滤波器，其传递函数为 $H_{p}(s)$，并经过归一化，使其 $-3$ dB 截止角频率为 $\\Omega_{c} = 1$ (单位：弧度/秒)。该巴特沃斯原型是最小相位、稳定且正常的。要求您通过从 $H_{p}(s)$ 构建传递函数 $H(s)$ 来实现一个物理滤波器，其期望的 $-3$ dB 截止角频率为 $\\Omega_{c}^{\\star} = 2\\pi \\cdot 2 \\times 10^{3}$。此过程仅能使用连续时间线性时不变系统的尺度变换原理和拉普拉斯变换，不得依赖任何现成的设计公式。\n\n任务：\n- 从巴特沃斯幅度响应的定义出发（即一个单调低通响应，其幅度的平方在通带内为常数，在零频率处等于1，在截止频率处等于1/2），根据第一性原理推导出一个连续时间尺度变换，该变换将截止频率为 $\\Omega_{c} = 1$ 的归一化原型 $H_{p}(s)$ 映射到截止频率为 $\\Omega_{c}^{\\star}$ 的目标滤波器 $H(s)$。用 $H_{p}(s)$ 和 $\\Omega_{c}^{\\star}$ 构建精确的 $H(s)$，并证明所得到的滤波器仍然是正常的、稳定的和最小相位的。\n- 使用您构建的 $H(s)$，直接验证对于任意阶数 $n \\ge 1$，都有 $|H(j\\,\\Omega_{c}^{\\star})| = 1/\\sqrt{2}$，并明确利用归一化原型在 $\\Omega = 1$ 处的性质。\n\n答案规格：\n- 最终答案只报告所需的频率尺度因子 $a$ (单位：弧度/秒)，该因子必须应用于从 $H_{p}(s)$ 到 $H(s)$ 的映射中的复频率变量 $s$。将此值表示为精确表达式，不要四舍五入。以 rad/s 为单位陈述您的答案，但不要在最终的方框答案中包含单位。", "solution": "所述问题具有科学依据，提法得当且客观。这是一个基于线性时不变系统既定原理的模拟滤波器设计中的标准问题。所有必要信息均已提供，且前提条件符合事实。因此，该问题有效，将提供解答。\n\n主要任务是推导一个频率尺度变换，将一个归一化的低通巴特沃斯原型滤波器映射到一个具有期望截止频率的滤波器。\n\n设归一化原型滤波器的传递函数为 $H_p(s)$。这是一个 $n$ 阶滤波器，其中 $n \\ge 1$。巴特沃斯滤波器的幅方响应在通带内是最大平坦的，并且单调递减。其一般形式由下式给出：\n$$ |H(j\\Omega)|^2 = \\frac{A_0^2}{1 + \\epsilon^2 \\left(\\frac{\\Omega}{\\Omega_c}\\right)^{2n}} $$\n其中 $A_0$ 是直流增益，$\\Omega_c$ 是截止频率，$\\epsilon$ 决定了通带波纹。对于一个在 $\\Omega_c$ 处有 $-3$ dB 截止的巴特沃斯滤波器，我们必须有 $\\epsilon=1$。\n问题指出，原型被归一化为在 $\\Omega_c = 1$ rad/s 处有 $-3$ dB 截止，并且在直流处有单位增益（$|H_p(0)| = 1$，这意味着 $A_0 = 1$）。因此，原型的幅方响应为：\n$$ |H_p(j\\Omega)|^2 = \\frac{1}{1 + \\Omega^{2n}} $$\n在截止频率 $\\Omega=1$ 处，我们有 $|H_p(j1)|^2 = \\frac{1}{1+1^{2n}} = \\frac{1}{2}$，这对应于幅度 $|H_p(j1)| = \\frac{1}{\\sqrt{2}}$，从而证实了 $-3$ dB 的规格。\n\n我们寻求构建一个新的滤波器，其传递函数为 $H(s)$，它具有相同的巴特沃斯特性，但截止频率不同，为 $\\Omega_c^\\star = 2\\pi \\cdot 2 \\times 10^3$ rad/s。这可以通过频率尺度变换来实现。我们提出对复频率变量 $s$ 进行变换。设新的传递函数与原型的关系如下：\n$$ H(s) = H_p\\left(\\frac{s}{a}\\right) $$\n其中 $a$ 是一个实数、正的尺度因子。我们假设没有应用额外的增益因子，从而保持了单位直流增益，因为 $H(0) = H_p(0/a) = H_p(0) = 1$。\n\n新滤波器的频率响应可以通过代入 $s=j\\Omega$ 得到：\n$$ H(j\\Omega) = H_p\\left(\\frac{j\\Omega}{a}\\right) $$\n因此，$H(s)$ 的幅方响应是：\n$$ |H(j\\Omega)|^2 = \\left|H_p\\left(\\frac{j\\Omega}{a}\\right)\\right|^2 $$\n使用 $|H_p(j\\Omega)|^2$ 的表达式，并将其频率变量 $\\Omega$ 替换为新的有效频率 $\\Omega/a$，我们得到：\n$$ |H(j\\Omega)|^2 = \\frac{1}{1 + \\left(\\frac{\\Omega}{a}\\right)^{2n}} $$\n这个新滤波器的期望截止频率是 $\\Omega_c^\\star$。在此频率下，幅方响应必须为 $\\frac{1}{2}$。\n$$ |H(j\\Omega_c^\\star)|^2 = \\frac{1}{1 + \\left(\\frac{\\Omega_c^\\star}{a}\\right)^{2n}} = \\frac{1}{2} $$\n求解 $a$，我们发现：\n$$ 1 + \\left(\\frac{\\Omega_c^\\star}{a}\\right)^{2n} = 2 $$\n$$ \\left(\\frac{\\Omega_c^\\star}{a}\\right)^{2n} = 1 $$\n由于 $\\Omega_c^\\star  0$ 并且我们要求 $a  0$，我们可以对两边取正实的 $2n$ 次方根：\n$$ \\frac{\\Omega_c^\\star}{a} = 1 \\implies a = \\Omega_c^\\star $$\n所以，所需的尺度因子就是期望的截止频率本身。变换是：\n$$ H(s) = H_p\\left(\\frac{s}{\\Omega_c^\\star}\\right) $$\n尺度因子为 $a = \\Omega_c^\\star = 2\\pi \\cdot 2 \\times 10^3 = 4000\\pi$ rad/s。\n\n接下来，我们必须证明，在给定 $H_p(s)$ 具有这些性质的情况下，$H(s)$ 仍然是正常的、稳定的和最小相位的。\n设 $\\{p_k\\}$ 是 $H_p(s)$ 的极点，$\\{z_m\\}$ 是 $H_p(s)$ 的零点。\n- **正常性**：原型 $H_p(s)$ 是正常的，意味着其分子多项式的阶数不大于分母多项式的阶数。变换 $s \\to s/\\Omega_c^\\star$ 对变量进行尺度缩放，但不会改变分子和分母多项式的阶数。因此，如果 $H_p(s)$ 是正常的，那么 $H(s)=H_p(s/\\Omega_c^\\star)$ 也是正常的。\n- **稳定性**：原型 $H_p(s)$ 是稳定的，因此其所有极点 $\\{p_k\\}$ 都位于复平面的左半平面，即 $\\text{Re}\\{p_k\\}  0$。$H(s)$ 的极点，记为 $\\{s_k\\}$，满足 $s_k/\\Omega_c^\\star = p_k$，这意味着 $s_k = p_k \\Omega_c^\\star$。由于 $\\Omega_c^\\star$ 是一个正实数，$\\text{Re}\\{s_k\\} = \\text{Re}\\{p_k \\Omega_c^\\star\\} = \\Omega_c^\\star \\text{Re}\\{p_k\\}  0$。$H(s)$ 的所有极点也都在左半平面，所以 $H(s)$ 是稳定的。\n- **最小相位**：原型 $H_p(s)$ 是最小相位的，因此其所有零点 $\\{z_m\\}$ 都位于复平面的左半平面，即 $\\text{Re}\\{z_m\\} \\le 0$。$H(s)$ 的零点，记为 $\\{s'_m\\}$，满足 $s'_m/\\Omega_c^\\star = z_m$，这意味着 $s'_m = z_m \\Omega_c^\\star$。其实部为 $\\text{Re}\\{s'_m\\} = \\Omega_c^\\star \\text{Re}\\{z_m\\} \\le 0$。$H(s)$ 的所有零点也都在左半平面。一个标准的巴特沃斯原型是一个全极点滤波器，没有有限零点，这是一个最小相位条件。变换后的滤波器 $H(s)$ 也没有有限零点，因此它仍然是最小相位的。\n\n最后，我们执行验证任务。我们必须验证 $|H(j\\Omega_c^\\star)| = 1/\\sqrt{2}$。\n使用我们构建的滤波器 $H(s) = H_p(s/\\Omega_c^\\star)$，我们评估其在 $s=j\\Omega_c^\\star$ 处的频率响应：\n$$ H(j\\Omega_c^\\star) = H_p\\left(\\frac{j\\Omega_c^\\star}{\\Omega_c^\\star}\\right) = H_p(j1) $$\n取其幅度：\n$$ |H(j\\Omega_c^\\star)| = |H_p(j1)| $$\n根据问题陈述，原型 $H_p(s)$ 的 $-3$ dB 截止频率在 $\\Omega_c=1$ 处。根据定义，这意味着在该频率下的幅度是直流增益的 $1/\\sqrt{2}$ 倍。给定单位直流增益，我们有：\n$$ |H_p(j1)| = \\frac{1}{\\sqrt{2}} $$\n因此：\n$$ |H(j\\Omega_c^\\star)| = \\frac{1}{\\sqrt{2}} $$\n这就完成了验证，表明所构建的滤波器 $H(s)$ 在其新的截止频率 $\\Omega_c^\\star$ 处具有期望的性质。\n\n问题要求的是必须应用于复频率变量 $s$ 的尺度因子 $a$。我们已经发现这个值是 $a = \\Omega_c^\\star$。其数值为：\n$$ a = 2\\pi \\cdot 2 \\times 10^3 = 4000\\pi $$", "answer": "$$\\boxed{4000\\pi}$$", "id": "2856497"}, {"introduction": "尽管巴特沃斯滤波器的理论根植于连续时间的模拟域，但大多数现代实现都是数字化的。这项高级练习 ([@problem_id:2856543]) 通过指导您实现双线性变换来弥合这一差距，这是一种将模拟滤波器转换为数字无限冲激响应 (IIR) 滤波器的经典方法。通过要求使用精确的符号计算，此问题强调了在设计过程中数值精度的重要性，并最终推导出一套可用于软件实现的具体系数。", "problem": "设计一个程序，该程序针对低通无限脉冲响应 (IIR) 巴特沃斯滤波器，以符号化的、精确的方式实现频率预畸变和双线性变换，从而在进行任何数值计算之前，将数字传递函数的系数推导为有理表达式。您的程序必须完全从第一性原理出发，从以下基本事实和定义开始。\n\n一个 $N$ 阶连续时间巴特沃斯低通原型滤波器的模拟传递函数形式为\n$$\nH_{a}(s) \\;=\\; \\frac{K}{B_{N}(s)},\n$$\n其中 $B_{N}(s)$ 是一个实系数、首一（monic）、稳定的多项式，其根是位于左半平面的巴特沃斯极点。对于归一化截止频率 $|\\Omega|=1$，当 $N \\in \\{1,3\\}$ 时，其分母为\n$$\nB_{1}(s) = s + 1, \\quad B_{3}(s) = s^{3} + 2 s^{2} + 2 s + 1.\n$$\n对于一个期望的模拟截止频率 $\\Omega_{c}$，经过频率缩放的模拟分母为\n$$\nD(s) \\;=\\; \\sum_{k=0}^{N} b_{k}\\,\\Omega_{c}^{\\,N-k}\\,s^{k}, \\quad \\text{其中} \\quad B_{N}(s)=\\sum_{k=0}^{N} b_{k}\\,s^{k}.\n$$\n双线性变换通过以下方式将拉普拉斯变量 $s$ 映射到 $z$ 域\n$$\ns \\;=\\; \\frac{2}{T}\\,\\frac{1 - z^{-1}}{1 + z^{-1}},\n$$\n其中 $T$ 是采样周期，单位为秒。为确保指定的数字截止频率 $\\omega_{c}$（单位：弧度/样本）在双线性变换之前能精确映射到模拟截止频率 $\\Omega_{c}$，需使用频率预畸变：\n$$\n\\Omega_{c} \\;=\\; \\frac{2}{T}\\,\\tan\\!\\left(\\frac{\\omega_{c}}{2}\\right).\n$$\n为在推导过程中避免任何数值近似，您必须使用精确有理数算术实现以下步骤：\n- 将有理数值 $\\tan\\!\\left(\\frac{\\omega_{c}}{2}\\right)$ 表示为整数 $p$ 和 $q$ 的既约分数 $\\frac{p}{q}$。\n- 将 $\\Omega_{c} = \\frac{2}{T}\\,\\frac{p}{q}$ 精确地计算为一个有理数。\n- 在精确有理数算术中，以 $c_{k} = b_{k}\\,\\Omega_{c}^{\\,N-k}$ 构成 $D(s) = \\sum_{k=0}^{N} c_{k}\\,s^{k}$。\n- 代入双线性映射 $s = \\frac{2}{T}\\,\\frac{1 - r}{1 + r}$（其中 $r = z^{-1}$），并使用二项式定理进行符号展开。定义 $A=\\frac{2}{T}$ 并注意\n$$\n\\left(\\frac{2}{T}\\,\\frac{1 - r}{1 + r}\\right)^{k} \\;=\\; A^{k}\\,(1 - r)^{k}\\,(1 + r)^{-k}.\n$$\n- 将各项合并到公分母 $(1 + r)^{N}$ 上，以获得数字分母多项式\n$$\nS(r) \\;=\\; \\sum_{k=0}^{N} c_{k}\\,A^{k}\\,(1 - r)^{k}\\,(1 + r)^{N-k},\n$$\n因此\n$$\nH_{d}(r) \\;=\\; H_{a}\\!\\left(\\tfrac{2}{T}\\,\\tfrac{1 - r}{1 + r}\\right) \\;=\\; \\frac{K\\,(1 + r)^{N}}{S(r)}.\n$$\n- 选择增益 $K$，使得数字滤波器在零频率处具有单位增益，即 $H_{d}(r=1)=1$。证明这意味着 $K=c_{0}=\\Omega_{c}^{N}$。\n- 对数字分母多项式进行归一化，使其 $r^{0}$ 项的系数等于 $1$，从而得到分母首项系数为 $1$ 的标准 IIR 差分方程形式。\n\n您的程序必须：\n- 在最终转换为数值之前，对所有符号化步骤、展开和系数推导使用精确有理数算术。在最终的四舍五入步骤之前，不要使用浮点算术。\n- 对于 $N \\in \\{1,3\\}$，使用归一化的巴特沃斯分母 $B_{1}(s)=s+1$ 和 $B_{3}(s)=s^{3}+2 s^{2}+2 s+1$ 作为唯一允许的基础案例。\n- 在推导出数字分子和分母系数向量的精确有理表达式后，将它们转换为浮点数，并将每个系数四舍五入到 $12$ 位小数。\n\n角度单位是弧度。输出中不出现其他物理单位。\n\n测试套件：\n对于每个测试用例，您将获得一个三元组 $(N, T, p/q)$，其中 $N$ 是巴特沃斯阶数，$T$ 是采样周期（单位：秒），$p/q$ 是 $\\tan(\\omega_{c}/2)$ 的既约有理数。\n\n- 案例 A（理想路径，非平凡 IIR）：$(N, T, p/q) = (3, 1, 1/2)$。\n- 案例 B（边界情况，极点的双线性映射对齐，导致归一化后产生类似 FIR 的分母）：$(N, T, p/q) = (1, 1, 1/1)$。\n- 案例 C（缩放采样周期与小截止频率）：$(N, T, p/q) = (3, 3, 1/3)$。\n\n对于每个案例，您的程序必须输出一个扁平列表，首先包含分子系数，然后是分母系数，两者都按 $z^{-1}$ 的非递增次幂排序（即从 $r^{0}$ 到 $r^{N}$）。分母必须进行归一化，使其 $r^{0}$ 项的系数等于 $1$。具体来说，对于阶数 $N$，您的列表必须是\n$$\n[b_{0}, b_{1}, \\dots, b_{N}, a_{0}, a_{1}, \\dots, a_{N}],\n$$\n其中 $a_{0}=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个案例的结果，形式为由逗号分隔的扁平列表，并用一对总的方括号括起来。例如，\n\"[[b0,b1,...,a0,a1,...],[...],[...]]\"\n但使用实际的数值（四舍五入到 $12$ 位小数）。请确保最外层的列表中正好有 $3$ 个案例结果，与上面列出的三个指定案例一一对应，且顺序相同。", "solution": "所述问题需根据既有的科学和工程原理进行验证。\n\n**步骤 1：提取已知条件**\n-   **模拟巴特沃斯原型：** $H_{a}(s) = K / B_{N}(s)$，其中 $B_{N}(s)$ 是一个首一、稳定的巴特沃斯多项式。\n-   **特定原型：** 对于归一化截止频率 $|\\Omega|=1$，当 $N=1$ 和 $N=3$ 时，其分母分别为 $B_{1}(s) = s + 1$ 和 $B_{3}(s) = s^{3} + 2 s^{2} + 2 s + 1$。\n-   **频率缩放：** 对于一个期望的模拟截止频率 $\\Omega_{c}$，分母与 $D(s) = \\sum_{k=0}^{N} b_{k}\\,\\Omega_{c}^{\\,N-k}\\,s^{k}$ 相关，其中 $B_{N}(s)=\\sum_{k=0}^{N} b_{k}\\,s^{k}$。\n-   **双线性变换：** 从 $s$ 平面到 $z$ 平面的映射为 $s = \\frac{2}{T}\\,\\frac{1 - z^{-1}}{1 + z^{-1}}$，其中 $T$ 为采样周期。\n-   **频率预畸变：** 必须将模拟截止频率 $\\Omega_c$ 设置为 $\\Omega_{c} = \\frac{2}{T}\\,\\tan(\\frac{\\omega_{c}}{2})$，以正确映射数字截止频率 $\\omega_c$。\n-   **符号化过程：** 所有中间计算必须使用精确有理数算术。这包括将 $\\tan(\\frac{\\omega_{c}}{2})$ 表示为分数 $p/q$，计算 $\\Omega_c$，构建模拟系数，以及展开变换后的多项式。\n-   **数字传递函数结构：** 数字传递函数推导为 $H_{d}(r) = \\frac{K\\,(1 + r)^{N}}{S(r)}$，其中 $r = z^{-1}$ 且 $S(r) = \\sum_{k=0}^{N} c_{k}\\,A^{k}\\,(1 - r)^{k}\\,(1 + r)^{N-k}$，其中 $A=2/T$ 且 $c_k = b_k \\Omega_c^{N-k}$。\n-   **归一化条件：**\n    1.  直流增益必须为 1：$H_{d}(r=1)=1$，这意味着增益因子为 $K=\\Omega_c^N$。\n    2.  最终的数字分母多项式必须进行归一化，使其常数项（$r^0$ 的系数）为 $1$。\n-   **测试数据：** 提供了三个案例：$(N, T, p/q) = (3, 1, 1/2)$、$(1, 1, 1/1)$ 和 $(3, 3, 1/3)$。\n-   **输出格式：** 每个案例对应一个扁平列表，包含四舍五入后的浮点系数 $[b_0, ..., b_N, a_0, ..., a_N]$，其中 $a_0 = 1$。\n\n**步骤 2：使用提取的已知条件进行验证**\n对问题的有效性进行评估：\n-   **科学依据：** 该问题描述了使用双线性变换从模拟原型设计 IIR 数字滤波器的标准流程。所有方程和概念——巴特沃斯多项式、频率缩放、预畸变以及变换本身——都是数字信号处理的基本且正确的原理。该问题牢固地建立在公认的理论基础之上。\n-   **适定性：** 该问题以数学精度进行了规定。它提供了所有必要的输入，定义了精确的变换序列，并指定了所需的输出格式。其约束条件，包括使用精确有理数算术，是明确的，并为每个测试用例导向唯一的解。\n-   **客观性：** 其语言是形式化和数学化的，没有任何主观或基于观点的陈述。\n\n该问题没有表现出任何诸如科学上不健全、不完整、矛盾或模糊之类的缺陷。这是系统工程中一个严谨且定义明确的练习。\n\n**步骤 3：结论与行动**\n该问题是 **有效的**。将提供一个解决方案。\n\n**数字传递函数的推导**\n\n目标是从一个连续时间低通巴特沃斯原型 $H_a(s)$ 推导出数字滤波器 $H_d(z)$ 的系数。该推导必须使用精确有理数算术以符号方式进行。\n\n设 $N$ 阶归一化模拟原型传递函数为\n$$\nH_{a,norm}(s') = \\frac{1}{B_N(s')} \\quad , \\quad B_N(s') = \\sum_{k=0}^{N} b_k (s')^k\n$$\n其中 $s'$ 是频率归一化的拉普拉斯变量且 $b_N=1$。给出了 $N=1$ 和 $N=3$ 时的系数 $b_k$。对于指定的案例，$b_0=1$。\n\n**1. 频率预畸变与缩放**\n为了达到期望的数字截止频率 $\\omega_c$，我们应用频率预畸变。模拟截止频率 $\\Omega_c$ 由\n$$\n\\Omega_c = \\frac{2}{T} \\tan\\left(\\frac{\\omega_c}{2}\\right)\n$$\n确定，其中 $T$ 是采样周期。问题将 $\\tan(\\frac{\\omega_c}{2})$ 提供为一个精确的有理数 $p/q$。因此，$\\Omega_c = \\frac{2}{T}\\frac{p}{q}$ 可以被精确计算。\n\n通过代换 $s' = s/\\Omega_c$ 可得到频率缩放后的模拟传递函数：\n$$\nH_a(s) = H_{a,norm}(s/\\Omega_c) = \\frac{1}{B_N(s/\\Omega_c)} = \\frac{1}{\\sum_{k=0}^{N} b_k (s/\\Omega_c)^k} = \\frac{\\Omega_c^N}{\\sum_{k=0}^{N} b_k \\Omega_c^{N-k} s^k}\n$$\n我们将缩放后的模拟分母多项式定义为 $D(s) = \\sum_{k=0}^{N} c_k s^k$，其中系数为 $c_k = b_k \\Omega_c^{N-k}$。传递函数为 $H_a(s) = \\frac{\\Omega_c^N}{D(s)}$，这里我们已将初始增益 $K$ 吸收到缩放因子中，其值稍后确定。\n\n**2. 双线性变换**\n双线性变换将 $s$ 平面映射到 $z$ 平面。使用代换 $r = z^{-1}$ 并定义常数 $A = 2/T$，该变换可写作：\n$$\ns = A \\frac{1-r}{1+r}\n$$\n将此变换应用于 $H_a(s)$ 得到数字传递函数 $H_d(r)$：\n$$\nH_d(r) = H_a\\left(A \\frac{1-r}{1+r}\\right) = \\frac{\\Omega_c^N}{D\\left(A \\frac{1-r}{1+r}\\right)} = \\frac{\\Omega_c^N}{\\sum_{k=0}^{N} c_k \\left(A \\frac{1-r}{1+r}\\right)^k}\n$$\n为消除复分式，我们将分子和分母同乘以 $(1+r)^N$：\n$$\nH_d(r) = \\frac{\\Omega_c^N (1+r)^N}{\\sum_{k=0}^{N} c_k A^k (1-r)^k (1+r)^{N-k}}\n$$\n设分子多项式为 $N_{poly}(r) = K_{num} (1+r)^N$，分母多项式为 $S(r) = \\sum_{k=0}^{N} c_k A^k (1-r)^k (1+r)^{N-k}$。问题陈述指定应选择增益以确保直流（DC）增益为 1。直流对应于 $z=1$，即 $r=1$。\n$$\nH_d(r=1) = \\frac{K_{num} (1+1)^N}{S(1)} = 1\n$$\n当 $r=1$ 且 $k0$ 时，$S(r)$ 中的项 $(1-r)^k$ 的值为零。因此，求和中只有 $k=0$ 的项保留下来：\n$$\nS(1) = c_0 A^0 (1-1)^0 (1+1)^{N-0} = c_0 \\cdot 1 \\cdot 1 \\cdot 2^N = c_0 2^N\n$$\n增益条件变为：\n$$\n\\frac{K_{num} 2^N}{c_0 2^N} = \\frac{K_{num}}{c_0} = 1 \\implies K_{num} = c_0\n$$\n根据 $c_k$ 的定义，我们有 $c_0 = b_0 \\Omega_c^{N-0}$。对于给定的巴特沃斯多项式，$b_0=1$，所以 $c_0 = \\Omega_c^N$。这证实了问题陈述中的发现。\n因此，未归一化的数字传递函数为：\n$$\nH_d(r) = \\frac{\\Omega_c^N (1+r)^N}{S(r)}\n$$\n分子多项式为 $N(r) = \\Omega_c^N (1+r)^N = \\Omega_c^N \\sum_{j=0}^{N} \\binom{N}{j} r^j$。\n分母多项式为 $S(r) = \\sum_{k=0}^{N} c_k A^k (1-r)^k (1+r)^{N-k}$。\n\n**3. 归一化**\nIIR 滤波器的标准形式要求分母多项式的常数项（$z^0$ 或 $r^0$ 的系数）为 $1$。设 $S(r) = \\sum_{j=0}^N S_j r^j$。$r^0$ 的系数是 $S_0$。为求得 $S_0$，我们可以在 $r=0$ 处计算 $S(r)$ 的值：\n$$\nS_0 = S(0) = \\sum_{k=0}^{N} c_k A^k (1-0)^k (1+0)^{N-k} = \\sum_{k=0}^{N} c_k A^k\n$$\n这个值 $S_0$ 就是归一化因子。我们将分子和分母多项式都除以 $S_0$。\n最终的归一化传递函数是 $H_d(r) = \\frac{B(r)}{A(r)}$，其中：\n-   $B(r) = \\frac{N(r)}{S_0} = \\sum_{j=0}^N \\beta_j r^j$\n-   $A(r) = \\frac{S(r)}{S_0} = \\sum_{j=0}^N \\alpha_j r^j$\n\n需要为输出计算的系数是：\n-   分子：$\\beta_j = \\frac{\\Omega_c^N \\binom{N}{j}}{S_0}$，其中 $j=0, \\dots, N$。\n-   分母：$\\alpha_j = \\frac{S_j}{S_0}$，其中 $j=0, \\dots, N$。\n\n根据构造，$\\alpha_0 = S_0/S_0 = 1$。\n\n**4. 算法步骤**\n一个使用精确有理数算术实现此推导的算法流程如下：\n1.  使用 Python 的 `fractions.Fraction` 将所有数值初始化为精确分数。\n2.  对于给定的测试用例 $(N, T, p/q)$：\n    a.  为原型多项式 $B_N(s')$ 选择系数 $b_k$。\n    b.  计算 $\\Omega_c = \\frac{2}{T} \\frac{p}{q}$ 和 $A = \\frac{2}{T}$。\n    c.  计算缩放后的模拟系数 $c_k = b_k \\Omega_c^{N-k}$，其中 $k=0, \\dots, N$。\n    d.  计算分母归一化因子 $S_0 = \\sum_{k=0}^N c_k A^k$。\n    e.  计算归一化的分子系数 $\\beta_j = \\frac{\\Omega_c^N \\binom{N}{j}}{S_0}$，其中 $j=0, \\dots, N$。\n    f.  为求得分母系数 $\\alpha_j$，首先计算未归一化的多项式 $S(r)$。这需要多项式代数。将多项式表示为其有理系数的列表。实现多项式加法和乘法的辅助函数。\n        -   将 $S(r)$ 初始化为 $N$ 次零多项式。\n        -   对于每个 $k \\in [0, N]$，通过多项式乘法计算项 $P_k(r) = c_k A^k (1-r)^k (1+r)^{N-k}$。\n        -   将 $P_k(r)$ 加到总和 $S(r)$ 中。\n    g.  所得多项式 $S(r)$ 的系数即为 $S_j$。\n    h.  计算归一化的分母系数 $\\alpha_j = S_j/S_0$。\n3.  将系数合并为一个扁平列表 $[\\beta_0, \\dots, \\beta_N, \\alpha_0, \\dots, \\alpha_N]$。\n4.  将精确的有理系数转换为浮点数，并四舍五入到 $12$ 位小数。\n5.  对所有测试用例重复以上步骤，并按规定格式化最终输出。\n\n此流程严格遵守了问题在进行数值计算前进行纯符号推导的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nimport math\n\ndef solve():\n    \"\"\"\n    Derives digital IIR Butterworth filter coefficients using exact rational arithmetic.\n    \"\"\"\n\n    def poly_add(p1, p2):\n        \"\"\"Adds two polynomials represented as lists of coefficients.\"\"\"\n        n1, n2 = len(p1), len(p2)\n        n_max = max(n1, n2)\n        res = [Fraction(0)] * n_max\n        for i in range(n_max):\n            c1 = p1[i] if i  n1 else Fraction(0)\n            c2 = p2[i] if i  n2 else Fraction(0)\n            res[i] = c1 + c2\n        return res\n\n    def poly_mul(p1, p2):\n        \"\"\"Multiplies two polynomials represented as lists of coefficients.\"\"\"\n        n1, n2 = len(p1), len(p2)\n        if n1 == 0 or n2 == 0:\n            return []\n        res = [Fraction(0)] * (n1 + n2 - 1)\n        for i in range(n1):\n            for j in range(n2):\n                res[i + j] += p1[i] * p2[j]\n        return res\n\n    def poly_power(p, n):\n        \"\"\"Computes p^n for a polynomial p.\"\"\"\n        if n == 0:\n            return [Fraction(1)]\n        res = p\n        for _ in range(n - 1):\n            res = poly_mul(res, p)\n        return res\n\n    def binom_coeff(n, k):\n        \"\"\"Computes binomial coefficient C(n, k) as an integer.\"\"\"\n        if k  0 or k  n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        if k  n // 2:\n            k = n - k\n        \n        res = 1\n        for i in range(k):\n            res = res * (n - i) // (i + 1)\n        return res\n\n    def compute_filter_coeffs(N, T, p_q_str):\n        \"\"\"\n        Computes the filter coefficients for a single case.\n        N: filter order\n        T: sampling period\n        p_q_str: tan(omega_c/2) as a string \"p/q\"\n        \"\"\"\n        p, q = map(int, p_q_str.split('/'))\n        T_frac = Fraction(T)\n        tan_w_c_half = Fraction(p, q)\n\n        # 1. Select Butterworth prototype coefficients b_k (for B_N(s))\n        # coeffs are b_k for s^k, ordered from k=0 to N\n        if N == 1:\n            # B1(s) = s + 1 - b = [1, 1] for s^0, s^1\n            b = [Fraction(1), Fraction(1)]\n        elif N == 3:\n            # B3(s) = s^3 + 2s^2 + 2s + 1 - b = [1, 2, 2, 1] for s^0...s^3\n            b = [Fraction(1), Fraction(2), Fraction(2), Fraction(1)]\n        else:\n            raise ValueError(\"Unsupported order N\")\n\n        # 2. Compute prewarped analog cutoff Omega_c and bilinear constant A\n        Omega_c = (Fraction(2) / T_frac) * tan_w_c_half\n        A = Fraction(2) / T_frac\n\n        # 3. Compute scaled analog coefficients c_k = b_k * Omega_c^(N-k)\n        c = [b[k] * (Omega_c ** (N - k)) for k in range(N + 1)]\n\n        # 4. Compute denominator normalization factor S_0 = sum(c_k * A^k)\n        S0 = sum(c[k] * (A ** k) for k in range(N + 1))\n\n        # 5. Compute normalized numerator coefficients (beta_j)\n        # Numerator is Omega_c^N * (1+r)^N\n        num_gain = Omega_c ** N\n        beta = []\n        for j in range(N + 1):\n            # Binomial coefficient for (1+r)^N\n            binom_nj = binom_coeff(N, j)\n            # Full coefficient is num_gain * binom_nj, normalized by S0\n            beta.append(num_gain * binom_nj / S0)\n        \n        # 6. Compute unnormalized denominator polynomial S(r)\n        # S(r) = sum_k c_k * A^k * (1-r)^k * (1+r)^(N-k)\n        S_poly = [Fraction(0)] * (N + 1)\n        poly_1_minus_r = [Fraction(1), Fraction(-1)]\n        poly_1_plus_r = [Fraction(1), Fraction(1)]\n\n        for k in range(N + 1):\n            # Constant term\n            const_term = c[k] * (A ** k)\n            \n            # (1-r)^k\n            term1 = poly_power(poly_1_minus_r, k)\n            \n            # (1+r)^(N-k)\n            term2 = poly_power(poly_1_plus_r, N-k)\n            \n            # P_k(r) = const * term1 * term2\n            poly_k = poly_mul(term1, term2)\n            poly_k_scaled = [const_term * coeff for coeff in poly_k]\n            \n            # Add to the sum polynomial S(r)\n            S_poly = poly_add(S_poly, poly_k_scaled)\n        \n        # 7. Compute normalized denominator coefficients (alpha_j)\n        Sj = S_poly\n        alpha = [sj / S0 for sj in Sj]\n\n        # 8. Combine, convert to float, and round\n        combined_coeffs = beta + alpha\n        rounded_coeffs = [round(float(coeff), 12) for coeff in combined_coeffs]\n        \n        return rounded_coeffs\n\n    test_cases = [\n        # (N, T, p/q)\n        (3, 1, \"1/2\"),  # Case A\n        (1, 1, \"1/1\"),  # Case B\n        (3, 3, \"1/3\"),  # Case C\n    ]\n\n    all_results = []\n    for N, T, pq_str in test_cases:\n        result = compute_filter_coeffs(N, T, pq_str)\n        all_results.append(result)\n\n    # Format the final output as a string representation of a list of lists\n    # e.g., [[1,2],[3,4]]\n    result_str_list = []\n    for res in all_results:\n        result_str_list.append(f\"[{','.join(map(str, res))}]\")\n    \n    final_output = f\"[{','.join(result_str_list)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2856543"}]}