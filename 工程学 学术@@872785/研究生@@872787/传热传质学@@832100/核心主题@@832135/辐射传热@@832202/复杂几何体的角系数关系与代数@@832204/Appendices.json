{"hands_on_practices": [{"introduction": "许多看似复杂的辐射换热问题，可以通过应用基本原理而非尝试暴力积分来极大地简化。本练习 [@problem_id:2537099] 挑战您的创造性思维，要求您运用叠加法则和对称性。通过构建一个虚拟表面以形成一个完整的封闭腔，您将发现如何求解一个原本需要困难积分计算的角系数，这体现了角系数代数方法的精妙之处。", "problem": "一个半径为 $R$、长度为 $L$ 的直圆柱体，其轴线平行于一个单一的、无限延伸的、漫灰色的、等温的平面，且中心线到平面的距离为 $h$。除此以外，周围环境为空（没有其他表面）。所有表面均为漫灰色、不透明，且介质为非参与性介质。圆柱体的圆形边缘薄得可以忽略不计，只考虑圆柱侧表面。请仅使用漫射角（视）系数的基本定义、封闭体求和法则、相互关系以及不依赖于列表公式的对称性论证，来确定从整个圆柱体侧面到该无限平面的角系数 $F_{c \\to p}$。您的推导必须从角系数的第一性原理出发，并对所使用的任何封闭体增补或对称操作进行论证。将最终答案表示为单个实数。无需四舍五入。角系数是无量纲的，请勿报告任何单位。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- **几何体1**：一个直圆柱体，记为表面“c”，半径为 $R$，长度为 $L$。只考虑其侧表面积 $A_c = 2\\pi R L$。\n- **几何体2**：一个单一的、无限延伸的平面，记为表面“p”。\n- **配置**：圆柱体的轴线平行于平面“p”。圆柱体轴线与平面之间的距离为 $h$。\n- **表面性质**：所有表面都是漫灰色和不透明的。介质是非参与性的。\n- **周围环境**：空间在其他方面是空的，这意味着未投射到“p”上的辐射会逃逸到一个零温度的散热器。\n- **目标**：确定从圆柱体侧面到无限平面的角系数 $F_{c \\to p}$。\n- **方法论约束**：推导过程必须仅使用角系数的基本定义、封闭体求和法则、相互关系和对称性论证。禁止使用表格化的公式。任何几何增补或对称操作都必须加以论证。\n- **答案格式**：最终答案必须是一个单一的实数。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，涉及辐射传热的标准原理。这是一个适定问题，因为其几何形状和目标都已明确定义。尽管存在符号参数（$R, L, h$），但要求提供单一数值答案表明，解将独立于这些具体尺寸，这在涉及无限表面和对称性的问题中是常见的结果。对推导方法的约束是明确的，并将求解策略引向概念性证明，而非直接积分。该问题没有矛盾、歧义和事实错误。\n\n**结论与行动**\n该问题被判定为**有效**。将按照规定的方法提供解答。\n\n**角系数 $F_{c \\to p}$ 的推导**\n\n角系数，或称视系数，$F_{i \\to j}$ 定义为离开漫射表面 $A_i$ 的辐射中直接到达表面 $A_j$ 的那部分。我们需要求的是 $F_{c \\to p}$。\n\n给定的系统由圆柱体“c”和无限平面“p”组成，并不构成一个封闭体。离开圆柱体但未投射到平面上的辐射会逃逸到空旷的周围环境中。为了使用角系数代数的强大工具（特别是求和法则）来解决这个问题，我们必须首先构建一个合适的封闭体。\n\n这可以通过**封闭体增补**的方法来完成。我们引入一个虚拟表面来完成围绕圆柱体“c”的封闭体。\n设无限平面“p”为表面 $A_1$。我们建立一个坐标系，其中平面 $A_1$ 是 $z=0$ 平面。圆柱体“c”的轴线平行于 $xy$ 平面，位于恒定高度 $z=h$ 处。\n\n现在我们引入第二个虚拟的无限平面，记为表面 $A_2$，位于 $z=2h$ 处。该平面平行于 $A_1$。这个构造创建了一个由两个无限平行平面 $A_1$ 和 $A_2$ 形成的封闭体，圆柱体“c”恰好位于中间。任何离开圆柱体“c”表面的辐射现在必须被平面 $A_1$ 或平面 $A_2$ 拦截，因为没有其他逃逸路径。\n\n对于封闭体内的任何表面“c”，角系数的**求和法则**规定，从“c”到封闭体所有表面（包括其自身）的角系数之和必须等于1。将此应用于我们的增补系统：\n$$F_{c \\to 1} + F_{c \\to 2} + F_{c \\to c} = 1$$\n其中 $F_{c \\to 1}$ 是从圆柱体到平面 $A_1$ 的角系数（即我们所求的量 $F_{c \\to p}$），而 $F_{c \\to 2}$ 是从圆柱体到虚拟平面 $A_2$ 的角系数。\n\n圆柱体的侧面是一个**凸面**。凸面无法“看到”自身的任何部分。因此，从圆柱体到其自身的角系数为零：\n$$F_{c \\to c} = 0$$\n将此代入求和法则，方程简化为：\n$$F_{c \\to 1} + F_{c \\to 2} = 1$$\n\n接下来，我们应用问题陈述所允许的**对称性论证**。该封闭体由两个相同的无限平面 $A_1$ 和 $A_2$ 组成。圆柱体“c”的轴线恰好位于它们之间的中点。圆柱体轴线到平面 $A_1$ 的距离是 $h$，同样，其轴线到平面 $A_2$ 的距离是 $|2h - h| = h$。由于这种几何对称性，圆柱体对平面 $A_1$ 的“视”与对平面 $A_2$ 的“视”是相同的。对于圆柱体表面上的任何面积微元，其相对于平面 $A_1$ 的位置和方向与相对于平面 $A_2$ 的位置和方向是镜像对称的。因此，从整个圆柱体表面“c”辐射的能量中，到达平面 $A_1$ 的部分必须等于到达平面 $A_2$ 的部分。因此我们可以说：\n$$F_{c \\to 1} = F_{c \\to 2}$$\n只要圆柱体是对称放置的，这个结论就与圆柱体的具体尺寸（$R, L$）及其与平面的距离（$h$）无关。\n\n现在我们将对称性论证的结果代回到简化的求和法则中：\n$$F_{c \\to 1} + F_{c \\to 1} = 1$$\n$$2 F_{c \\to 1} = 1$$\n解出 $F_{c \\to 1}$ 得：\n$$F_{c \\to 1} = \\frac{1}{2}$$\n\n因为 $F_{c \\to 1}$ 是从圆柱体到原始无限平面“p”的角系数，我们已经求得了所需的量：\n$$F_{c \\to p} = \\frac{1}{2}$$\n这个结果是一个常数，与圆柱体的半径、长度和与平面的距离无关，这与问题要求提供单一数值答案是一致的。该推导完全依赖于求和法则以及应用于增补封闭体的、经过论证的对称性论证，因此遵守了所有方法论上的约束。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "2537099"}, {"introduction": "对于那些可以近似为无限长（二维）的几何结构，一种称为霍特尔(Hottel)交叉线法的强大图形技术，可以用简单的几何运算代替复杂的积分。本练习 [@problem_id:2537083] 将为您提供使用此方法的实践机会，展示其巧妙之处。此外，它还强调了作为角系数代数基石的可加性原理，该原理允许您通过将复杂形状分解为更简单的部分来计算其角系数。", "problem": "二维辐射角系数可以通过利用以下事实进行分析：在非参与介质中，无限长、漫射、灰体表面将角系数的三维双重面积分定义简化为每单位长度的二维线积分问题。考虑三个无限长、平行、漫射、灰体表面（其长轴沿$z$方向），它们嵌入在非参与介质中，其在$x$–$y$平面上的投影是位于两个不同$y$高度上的线段：\n\n- 发射体$A$沿$y = 0$从$x = 0$到$x = 2$，因此其宽度为$w_A = 2$。\n- 接收体$B$沿$y = H$从$x = 0.5$到$x = 2.5$。\n- 接收体$C$沿$y = H$从$x = -1$到$x = 0.5$。\n\n这两个高度层之间的间隙为$H = 1.2\\,\\mathrm{m}$。所有表面均为黑体-漫射体，因此仅需纯几何角系数（视界因子）即可，且介质不发射、不吸收、也不散射。表面$B$和表面$C$相邻且不重叠，因此它们的并集$U = B \\cup C$沿$y=H$从$x = -1$延伸至$x = 2.5$。\n\n从辐射传热中角系数的基本定义出发，并利用无限长平行表面的二维类比，推导出一个适用于计算从有限发射体段到跨越均匀间距的有限接收体段的角系数的交叉弦关系式。然后，利用角系数对不交并集的可加性，通过计算$F_{A \\to U}$和$F_{A \\to C}$并求出适当的差值，来计算直接角系数$F_{A \\to B}$。\n\n将$F_{A \\to B}$的最终数值答案表示为一个无量纲数，并四舍五入到五位有效数字。", "solution": "问题陈述已经过验证。\n\n**步骤1：提取已知条件**\n- **系统几何形状：**三个无限长、平行、漫射、灰体表面，其轴线平行于$z$方向。\n- **介质：**非参与介质。\n- **表面定义（在$x$-$y$平面上的投影）：**\n  - 发射体$A$：沿$y = 0$从$x = 0$到$x = 2$的线段。\n  - 接收体$B$：沿$y = H$从$x = 0.5$到$x = 2.5$的线段。\n  - 接收体$C$：沿$y = H$从$x = -1$到$x = 0.5$的线段。\n- **尺寸：**\n  - 发射体$A$的宽度：$w_A = 2$。\n  - 平面间距：$H = 1.2\\,\\mathrm{m}$。\n- **表面属性：**所有表面均为黑体-漫射体。\n- **复合表面：**$U = B \\cup C$，沿$y = H$从$x = -1$延伸至$x = 2.5$。\n- **任务：**\n  1. 推导此几何形状的交叉弦关系。\n  2. 使用可加性原理计算角系数$F_{A \\to B}$，即通过计算$F_{A \\to U}$和$F_{A \\to C}$并求出它们的差值。\n  3. 提供$F_{A \\to B}$的数值答案，四舍五入到五位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：**该问题基于辐射传热的既定原理，特别是二维构型的角系数概念。所要求的方法，即Hottel的交叉弦法，是解决此类问题的标准有效技术。\n- **适定性：**几何形状已明确定义，并给出了所有必要的尺寸。提供了表面和介质的属性。目标明确，存在唯一解。\n- **客观性：**问题以精确、定量的语言陈述，没有歧义或主观论断。\n- **一致性：**定义内部一致。表面$B$和$C$相邻，在$x=0.5$处相交，它们的并集$U$的描述是正确的。\n\n**步骤3：结论与行动**\n该问题科学上合理，适定且内部一致。这是一个有效的辐射传热问题。将制定一个解决方案。\n\n对于二维几何形状（代表无限长平行表面），角系数$F_{1 \\to 2}$可以使用Hottel的交叉弦法来确定。对于两个分别表示为表面1和表面2、宽度分别为$w_1$和$w_2$的表面，从表面1到表面2的角系数由下式给出：\n$$F_{1 \\to 2} = \\frac{(\\text{Sum of lengths of crossed strings}) - (\\text{Sum of lengths of uncrossed strings})}{2 \\times (\\text{Width of surface 1})}$$\n“弦”是在二维平面中连接两个表面端点的假想线。\n\n设发射体表面$A$为表面1，接收体表面$J$（其中$J$可以是$B$、$C$或$U$）为表面2。表面$A$由端点$P_{A1} = (0, 0)$和$P_{A2} = (2, 0)$定义。其宽度为$w_A = 2 - 0 = 2$。所有接收体表面都位于直线$y=H=1.2$上。\n位于直线$y=H$上的一个通用接收体表面$J$从$x=x_{Ja}$延伸到$x=x_{Jb}$。其端点为$P_{Ja} = (x_{Ja}, H)$和$P_{Jb} = (x_{Jb}, H)$。\n点$(x_i, y_i)$和点$(x_j, y_j)$之间的弦长为$L = \\sqrt{(x_j - x_i)^2 + (y_j - y_i)^2}$。\n$F_{A \\to J}$的交叉弦公式为：\n$$F_{A \\to J} = \\frac{1}{2w_A} \\left[ \\left( L(P_{A1}, P_{Jb}) + L(P_{A2}, P_{Ja}) \\right) - \\left( L(P_{A1}, P_{Ja}) + L(P_{A2}, P_{Jb}) \\right) \\right]$$\n其中$L(P_1, P_2)$是点$P_1$和$P_2$之间的距离。\n\n该问题要求使用角系数可加性原理进行求解。由于表面$B$和$C$不相交（仅共享一条线边界）且它们的并集是$U$，角系数的求和法则适用：\n$$F_{A \\to U} = F_{A \\to (B \\cup C)} = F_{A \\to B} + F_{A \\to C}$$\n因此，所求的角系数$F_{A \\to B}$可以计算为：\n$$F_{A \\to B} = F_{A \\to U} - F_{A \\to C}$$\n\n首先，我们计算$F_{A \\to U}$。\n表面$A$的端点为$P_{A1}=(0,0)$和$P_{A2}=(2,0)$。其宽度为$w_A=2$。\n表面$U$在$y=H=1.2$处从$x = -1$延伸至$x = 2.5$。其端点为$P_{Ua}=(-1, 1.2)$和$P_{Ub}=(2.5, 1.2)$。\n弦的长度为：\n- 交叉弦1（$P_{A1}$到$P_{Ub}$）：$L_{c1,U} = \\sqrt{(2.5 - 0)^2 + (1.2 - 0)^2} = \\sqrt{2.5^2 + 1.2^2} = \\sqrt{6.25 + 1.44} = \\sqrt{7.69}$。\n- 交叉弦2（$P_{A2}$到$P_{Ua}$）：$L_{c2,U} = \\sqrt{(-1 - 2)^2 + (1.2 - 0)^2} = \\sqrt{(-3)^2 + 1.2^2} = \\sqrt{9 + 1.44} = \\sqrt{10.44}$。\n- 非交叉弦1（$P_{A1}$到$P_{Ua}$）：$L_{u1,U} = \\sqrt{(-1 - 0)^2 + (1.2 - 0)^2} = \\sqrt{(-1)^2 + 1.2^2} = \\sqrt{1 + 1.44} = \\sqrt{2.44}$。\n- 非交叉弦2（$P_{A2}$到$P_{Ub}$）：$L_{u2,U} = \\sqrt{(2.5 - 2)^2 + (1.2 - 0)^2} = \\sqrt{0.5^2 + 1.2^2} = \\sqrt{0.25 + 1.44} = \\sqrt{1.69} = 1.3$。\n角系数$F_{A \\to U}$为：\n$$F_{A \\to U} = \\frac{1}{2w_A} \\left[ (L_{c1,U} + L_{c2,U}) - (L_{u1,U} + L_{u2,U}) \\right] = \\frac{1}{2(2)} \\left[ (\\sqrt{7.69} + \\sqrt{10.44}) - (\\sqrt{2.44} + 1.3) \\right]$$\n\n接下来，我们计算$F_{A \\to C}$。\n表面$C$在$y=H=1.2$处从$x = -1$延伸至$x = 0.5$。其端点为$P_{Ca}=(-1, 1.2)$和$P_{Cb}=(0.5, 1.2)$。\n注意$P_{Ca} = P_{Ua}$。\n弦的长度为：\n- 交叉弦1（$P_{A1}$到$P_{Cb}$）：$L_{c1,C} = \\sqrt{(0.5 - 0)^2 + (1.2 - 0)^2} = \\sqrt{0.5^2 + 1.2^2} = \\sqrt{0.25 + 1.44} = \\sqrt{1.69} = 1.3$。\n- 交叉弦2（$P_{A2}$到$P_{Ca}$）：$L_{c2,C} = \\sqrt{(-1 - 2)^2 + (1.2 - 0)^2} = \\sqrt{(-3)^2 + 1.2^2} = \\sqrt{9 + 1.44} = \\sqrt{10.44}$。这与$L_{c2,U}$相同。\n- 非交叉弦1（$P_{A1}$到$P_{Ca}$）：$L_{u1,C} = \\sqrt{(-1 - 0)^2 + (1.2 - 0)^2} = \\sqrt{(-1)^2 + 1.2^2} = \\sqrt{1 + 1.44} = \\sqrt{2.44}$。这与$L_{u1,U}$相同。\n- 非交叉弦2（$P_{A2}$到$P_{Cb}$）：$L_{u2,C} = \\sqrt{(0.5 - 2)^2 + (1.2 - 0)^2} = \\sqrt{(-1.5)^2 + 1.2^2} = \\sqrt{2.25 + 1.44} = \\sqrt{3.69}$。\n角系数$F_{A \\to C}$为：\n$$F_{A \\to C} = \\frac{1}{2w_A} \\left[ (L_{c1,C} + L_{c2,C}) - (L_{u1,C} + L_{u2,C}) \\right] = \\frac{1}{4} \\left[ (1.3 + \\sqrt{10.44}) - (\\sqrt{2.44} + \\sqrt{3.69}) \\right]$$\n\n现在，我们通过减法计算$F_{A \\to B}$：\n$$F_{A \\to B} = F_{A \\to U} - F_{A \\to C}$$\n$$F_{A \\to B} = \\frac{1}{4} \\left[ (\\sqrt{7.69} + \\sqrt{10.44}) - (\\sqrt{2.44} + 1.3) \\right] - \\frac{1}{4} \\left[ (1.3 + \\sqrt{10.44}) - (\\sqrt{2.44} + \\sqrt{3.69}) \\right]$$\n我们可以对各项进行分组：\n$$F_{A \\to B} = \\frac{1}{4} \\left[ (\\sqrt{7.69} + \\sqrt{10.44} - \\sqrt{2.44} - 1.3) - (1.3 + \\sqrt{10.44} - \\sqrt{2.44} - \\sqrt{3.69}) \\right]$$\n$$F_{A \\to B} = \\frac{1}{4} \\left[ \\sqrt{7.69} + \\sqrt{10.44} - \\sqrt{2.44} - 1.3 - 1.3 - \\sqrt{10.44} + \\sqrt{2.44} + \\sqrt{3.69} \\right]$$\n项$\\sqrt{10.44}$和$\\sqrt{2.44}$相互抵消，得到一个简化的表达式：\n$$F_{A \\to B} = \\frac{1}{4} \\left[ \\sqrt{7.69} + \\sqrt{3.69} - 1.3 - 1.3 \\right]$$\n$$F_{A \\to B} = \\frac{1}{4} \\left( \\sqrt{7.69} + \\sqrt{3.69} - 2.6 \\right)$$\n这个简化的结果正是直接对表面$A$和$B$应用交叉弦法所得到的表达式，这证实了角系数代数的一致性。\n\n现在，我们代入数值。\n$$F_{A \\to B} = \\frac{1}{4} \\left( \\sqrt{7.69} + \\sqrt{3.69} - 2.6 \\right)$$\n$$F_{A \\to B} \\approx \\frac{1}{4} \\left( 2.7730849 + 1.9209373 - 2.6 \\right)$$\n$$F_{A \\to B} \\approx \\frac{1}{4} \\left( 4.6940222 - 2.6 \\right)$$\n$$F_{A \\to B} \\approx \\frac{1}{4} \\left( 2.0940222 \\right)$$\n$$F_{A \\to B} \\approx 0.52350555$$\n将结果四舍五入到五位有效数字，得到$0.52351$。", "answer": "$$\\boxed{0.52351}$$", "id": "2537083"}, {"introduction": "虽然解析方法很巧妙，但大多数现实世界中的工程问题都涉及过于复杂的几何形状，无法使用解析法求解。本练习 [@problem_id:2537093] 将指导您从第一性原理出发，构建一个数值工具来计算任意平面之间的角系数。通过实现该算法并根据互易性和可加性等基本定律进行测试，您将深刻理解角系数的连续积分定义是如何转化为一种实用而强大的计算方法的。", "problem": "您需要设计并实现一个数值算法，用于计算三维空间中平面平行四边形之间的漫射几何角系数，并使用高斯求积法验证代数关系和收敛性。该问题必须从角系数的积分定义和基本几何关系等第一性原理出发进行求解。您必须为固定的测试套件输出具体的数值结果。\n\n基本原理：\n- 两个无遮挡视线的漫射灰体表面 $A_1$ 和 $A_2$ 之间的角系数 $F_{1 \\to 2}$ 定义为\n$$\nF_{1 \\to 2} = \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos\\theta_1 \\, \\cos\\theta_2}{\\pi \\, R^2} \\, \\mathrm{d}A_2 \\, \\mathrm{d}A_1,\n$$\n其中 $\\theta_1$ 是 $A_1$ 上一点的外法向单位向量与到 $A_2$ 上一点的视线之间的夹角，$\\theta_2$ 是 $A_2$ 上一点的外法向单位向量与到 $A_1$ 上一点的视线之间的夹角，而 $R$ 是这两点之间的距离。该积分使用的可见性因子等于 $1$（无遮挡），以及基本的辐射角系数被积函数 $\\left(\\cos\\theta_1 \\cos\\theta_2\\right)/\\left(\\pi R^2\\right)$。\n\n- 互易性：$A_1 F_{1 \\to 2} = A_2 F_{2 \\to 1}$。\n\n- 可加性（分割）：如果 $A_1$ 被分割成不相交的子区域 $A_{1k}$，则 $F_{1 \\to 2} = \\sum_k \\left(\\frac{A_{1k}}{A_1}\\right) F_{1k \\to 2}$。\n\n平面几何模型：\n- 一个平面平行四边形表面 $S$ 由一个原点 $\\mathbf{o} \\in \\mathbb{R}^3$ 和两个张成向量 $\\mathbf{a}, \\mathbf{b} \\in \\mathbb{R}^3$（单位为米）表示，其参数化形式为\n$$\n\\mathbf{r}(u,v) = \\mathbf{o} + u \\, \\mathbf{a} + v \\, \\mathbf{b}, \\quad u \\in [0,1], \\; v \\in [0,1].\n$$\n- 面积为 $A = \\|\\mathbf{a} \\times \\mathbf{b}\\|$。外法向单位向量为 $\\mathbf{n} = s \\, \\frac{\\mathbf{a} \\times \\mathbf{b}}{\\|\\mathbf{a} \\times \\mathbf{b}\\|}$，其中 $s \\in \\{+1,-1\\}$ 用于选择表面的发射面（外法向符号）。所有长度单位均为米。角系数是无量纲的。\n\n数值求积要求：\n- 使用 $n$ 阶张量积 Gauss–Legendre 求积法对 $[0,1]$ 上的每个参数来近似计算双重积分。如果 $\\{x_i, w_i\\}_{i=1}^n$ 是 $[-1,1]$ 上的标准 Gauss–Legendre 节点和权重，则通过 $u_i = \\frac{x_i+1}{2}$ 映射到 $[0,1]$，权重为 $\\tilde{w}_i = \\frac{w_i}{2}$。在每个曲面上对 $(u,v)$ 使用张量积，然后在两个曲面之间使用张量积，以近似计算\n$$\n\\iint_{A_1} \\iint_{A_2} \\cdot \\; \\mathrm{d}A_2 \\, \\mathrm{d}A_1 \\approx \\sum_{i,j=1}^n \\sum_{p,q=1}^n \\left(\\tilde{w}_i \\tilde{w}_j A_1\\right) \\left(\\tilde{w}_p \\tilde{w}_q A_2\\right) \\, \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2}.\n$$\n- 对于任何满足 $\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$ 的求积点对，其贡献必须视为 $0$（背面之间没有相互交换）。\n\n需要实现的算法任务：\n1. 实现一个例程，根据 $(\\mathbf{o}, \\mathbf{a}, \\mathbf{b}, s)$ 构建一个表面，并计算其面积 $A$ 和外法向单位向量 $\\mathbf{n}$。\n2. 实现一个例程，使用 $n$ 阶 Gauss–Legendre 节点在 $[0,1]$ 上生成求积点，并在给定表面上组合张量积点和权重。\n3. 实现一个函数，使用上述求积公式计算 $F_{1 \\to 2}$。\n4. 实现沿 $\\mathbf{a}$ 方向将一个表面分割成两个等面积的子表面，并用数值方法验证可加性关系。\n\n测试套件：\n按顺序计算以下四个结果，并按规定格式输出。所有坐标单位均为米。使用可见性因子等于 $1$。\n\n- 测试 $1$（互易性，平行偏移矩形）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-1.0,-0.5,0.0)$, $\\mathbf{a}_1 = (2.0,0.0,0.0)$, $\\mathbf{b}_1 = (0.0,1.0,0.0)$, $s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (-0.8,-0.6,0.5)$, $\\mathbf{a}_2 = (2.0,0.0,0.0)$, $\\mathbf{b}_2 = (0.0,1.0,0.0)$, $s_2=-1$。\n  - 使用求积阶数 $n=8$ 计算 $F_{1 \\to 2}$ 和 $F_{2 \\to 1}$。以浮点数形式输出绝对互易性残差 $\\left|A_1 F_{1 \\to 2} - A_2 F_{2 \\to 1}\\right|$。\n\n- 测试 $2$（收敛性，垂直矩形）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-0.5,-0.5,0.0)$, $\\mathbf{a}_1 = (1.0,0.0,0.0)$, $\\mathbf{b}_1 = (0.0,1.0,0.0)$, $s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (1.0,-0.5,0.0)$, $\\mathbf{a}_2 = (0.0,1.0,0.0)$, $\\mathbf{b}_2 = (0.0,0.0,2.0)$, $s_2=-1$。\n  - 使用 $n \\in \\{2,4,6,8\\}$ 计算 $F_{1 \\to 2}$。令 $\\Delta_{8,6} = |F_{1 \\to 2}^{(n=8)} - F_{1 \\to 2}^{(n=6)}|$ 且 $\\Delta_{6,4} = |F_{1 \\to 2}^{(n=6)} - F_{1 \\to 2}^{(n=4)}|$。输出 $\\left(\\Delta_{8,6} < 5\\times 10^{-4}\\right)$ AND $\\left(\\Delta_{6,4} < 2\\times 10^{-3}\\right)$ 的布尔值。\n\n- 测试 $3$（可加性/分割，与测试 $1$ 中 $S_2$ 和分割后的 $S_1$ 几何形状相同）：\n  - 将测试 $1$ 的 $S_1$ 沿 $\\mathbf{a}_1$ 方向分割成两个等面积的子表面。使用 $n=8$ 计算整个 $S_1$ 的 $F_{1 \\to 2}$，并使用 $n=8$ 计算两个子表面的面积加权和 $\\left(\\frac{A_{1a}}{A_1}\\right) F_{1a \\to 2} + \\left(\\frac{A_{1b}}{A_1}\\right) F_{1b \\to 2}$。以浮点数形式输出绝对差。\n\n- 测试 $4$（小角系数边缘情况，远场平行小方块）：\n  - 表面 $S_1$：$\\mathbf{o}_1 = (-0.1,-0.1,0.0)$, $\\mathbf{a}_1 = (0.2,0.0,0.0)$, $\\mathbf{b}_1 = (0.0,0.2,0.0)$, $s_1=+1$。\n  - 表面 $S_2$：$\\mathbf{o}_2 = (-0.1,-0.1,5.0)$, $\\mathbf{a}_2 = (0.2,0.0,0.0)$, $\\mathbf{b}_2 = (0.0,0.2,0.0)$, $s_2=-1$。\n  - 使用 $n=8$ 计算 $F_{1 \\to 2}$。输出此浮点数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 $1$–$4$ 的结果，按上述顺序以逗号分隔的列表形式包含在方括号内，不含空格。例如，输出必须为 $[r_1,b_2,r_3,f_4]$ 的形式，其中 $r_1$ 和 $r_3$ 是浮点数，$b_2$ 是布尔值，$f_4$ 是浮点数。不应打印任何额外文本。", "solution": "所述问题已经过验证。\n\n**步骤 1：提取的已知条件**\n- 角系数积分：$F_{1 \\to 2} = \\frac{1}{A_1} \\int_{A_1} \\int_{A_2} \\frac{\\cos\\theta_1 \\, \\cos\\theta_2}{\\pi \\, R^2} \\, \\mathrm{d}A_2 \\, \\mathrm{d}A_1$。\n- 角系数代数：互易性 $A_1 F_{1 \\to 2} = A_2 F_{2 \\to 1}$ 和可加性 $F_{1 \\to 2} = \\sum_k \\left(\\frac{A_{1k}}{A_1}\\right) F_{1k \\to 2}$。\n- 表面表示：一个平面平行四边形，由一个原点 $\\mathbf{o}$ 和两个张成向量 $\\mathbf{a}, \\mathbf{b}$ 参数化为 $\\mathbf{r}(u,v) = \\mathbf{o} + u \\, \\mathbf{a} + v \\, \\mathbf{b}$，其中 $u, v \\in [0,1]$。外法向单位向量为 $\\mathbf{n} = s \\, (\\mathbf{a} \\times \\mathbf{b}) / \\|\\mathbf{a} \\times \\mathbf{b}\\|$，其中 $s \\in \\{+1, -1\\}$。面积为 $A = \\|\\mathbf{a} \\times \\mathbf{b}\\|$。\n- 数值方法：$n$ 阶张量积 Gauss-Legendre 求积。将节点 $\\{x_i\\}$ 从 $[-1,1]$ 通过 $u_i = (x_i+1)/2$ 映射到 $[0,1]$，并将权重 $\\{w_i\\}$ 通过 $\\tilde{w}_i = w_i/2$ 映射。\n- 求积条件：如果 $\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$，则微分贡献为零。\n- 测试套件：提供了四个特定的测试用例，以验证互易性、收敛性、可加性和一个小角系数配置。\n\n**步骤 2：验证**\n- **科学依据**：该问题在根本上是合理的。它基于辐射传热的既定原理，并使用标准的数学和数值技术。角系数的定义、其性质、几何表示以及 Gauss-Legendre 求积的选择都是教科书中的标准内容。\n- **适定性**：该问题是适定的。每个测试的输入都已明确定义，所需的输出也毫不含糊。对于每个指定的求积阶数，都存在唯一的数值解。\n- **客观性**：该问题以精确、客观的数学和物理语言陈述，没有任何主观性或模糊性。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个定义明确的计算物理任务，要求从第一性原理实现一个数值算法。将提供一个解决方案。\n\n**基于原理的解决方案设计**\n\n任务是计算角系数 $F_{1 \\to 2}$，这是一个无量纲量，表示离开表面 $A_1$ 的辐射中直接到达表面 $A_2$ 的部分。控制方程是两个表面上的一个四维积分。\n\n首先，我们必须用参数坐标来表示这个积分。表面 $S_1$ 上的一个点 $\\mathbf{r}_1$ 由 $\\mathbf{r}_1(u_1, v_1) = \\mathbf{o}_1 + u_1 \\mathbf{a}_1 + v_1 \\mathbf{b}_1$ 给出，表面 $S_2$ 上的点 $\\mathbf{r}_2(u_2, v_2)$ 类似。微分面积元为 $\\mathrm{d}A_1 = \\|\\mathbf{a}_1 \\times \\mathbf{b}_1\\| \\, \\mathrm{d}u_1 \\, \\mathrm{d}v_1 = A_1 \\, \\mathrm{d}u_1 \\, \\mathrm{d}v_1$ 和 $\\mathrm{d}A_2 = A_2 \\, \\mathrm{d}u_2 \\, \\mathrm{d}v_2$。将这些代入 $F_{1 \\to 2}$ 的定义中得到：\n$$\nF_{1 \\to 2} = \\frac{1}{A_1} \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2} (A_2 \\, \\mathrm{d}u_2 \\mathrm{d}v_2) (A_1 \\, \\mathrm{d}u_1 \\mathrm{d}v_1)\n$$\n这可以简化为一个在超立方体 $[0,1]^4$ 上的纯参数积分：\n$$\nF_{1 \\to 2} = A_2 \\int_0^1 \\int_0^1 \\int_0^1 \\int_0^1 \\frac{\\cos\\theta_1 \\cos\\theta_2}{\\pi R^2} \\, \\mathrm{d}u_1 \\mathrm{d}v_1 \\mathrm{d}u_2 \\mathrm{d}v_2\n$$\n在这里，对于每个四元组 $(u_1, v_1, u_2, v_2)$，我们有：\n- $S_1$ 上的点：$\\mathbf{r}_1 = \\mathbf{o}_1 + u_1\\mathbf{a}_1 + v_1\\mathbf{b}_1$\n- $S_2$ 上的点：$\\mathbf{r}_2 = \\mathbf{o}_2 + u_2\\mathbf{a}_2 + v_2\\mathbf{b}_2$\n- 点间向量：$\\mathbf{R} = \\mathbf{r}_2 - \\mathbf{r}_1$\n- 距离：$R = \\|\\mathbf{R}\\|$\n- 角度余弦：$\\cos\\theta_1 = \\mathbf{n}_1 \\cdot \\frac{\\mathbf{R}}{R}$ 和 $\\cos\\theta_2 = \\mathbf{n}_2 \\cdot \\frac{-\\mathbf{R}}{R}$\n\n为了数值计算这个积分，我们采用一个 $n$ 阶 Gauss-Legendre 求积法，在四个维度 $(u_1, v_1, u_2, v_2)$ 上形成张量积。设 $\\{u_k, \\tilde{w}_k\\}_{k=1}^n$ 分别是从标准区间 $[-1,1]$ 映射到 $[0,1]$ 的求积节点和权重。该积分由以下求和近似：\n$$\nF_{1 \\to 2} \\approx A_2 \\sum_{i=1}^n \\sum_{j=1}^n \\sum_{p=1}^n \\sum_{q=1}^n (\\tilde{w}_i \\tilde{w}_j \\tilde{w}_p \\tilde{w}_q) \\left[ \\frac{\\cos\\theta_{1,ijpq} \\cos\\theta_{2,ijpq}}{\\pi R_{ijpq}^2} \\right]\n$$\n其中方括号中的项是在对应于节点 $(u_i, u_j, u_p, u_q)$ 的点上计算的被积函数，如果可见性失效（$\\cos\\theta_1 \\le 0$ 或 $\\cos\\theta_2 \\le 0$），则该项设为 $0$。\n\n实现将按以下结构进行：\n1.  定义一个 `Surface` 类来封装平行四边形的几何属性：其原点 $\\mathbf{o}$、张成向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，以及法向符号参数 $s$。该类将计算并存储其面积 $A$ 和外法向单位向量 $\\mathbf{n}$。\n2.  一个辅助函数将使用 `scipy.special.roots_legendre` 生成 $[0,1]$ 上所需的 Gauss-Legendre 节点和权重，并带有缓存以防止对相同阶数 $n$ 进行重复计算。\n3.  核心计算函数 `compute_view_factor` 实现数值积分。为实现高性能，该函数使用 `numpy` 进行向量化。它为每个表面生成完整的 $n^2$ 个求积点和权重集。然后，使用矩阵和张量运算一次性计算所有 $n^4$ 个成对相互作用、距离、角度余弦和最终的加权和，避免了缓慢的显式 Python 循环。这是进行严肃数值工作的唯一可接受的方法。\n4.  四个测试用例按顺序执行。测试 $1$ 和测试 $3$ 验证了互易性和可加性的关键代数性质，证明了公式的自洽性。测试 $2$ 确认了数值求积的收敛性，这是可靠数值方法的必要条件。测试 $4$ 评估了算法在角系数很小的远场情况下的性能。\n\n最终的 Python 代码实现了这一设计，以计算测试套件所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the view factor calculations and tests.\n    \"\"\"\n    \n    # Use a cache for Gauss-Legendre quadrature data to avoid recomputation\n    gl_cache = {}\n\n    class Surface:\n        \"\"\"\n        Represents a planar parallelogram surface in 3D space.\n        \"\"\"\n        def __init__(self, o, a, b, s):\n            self.o = np.array(o, dtype=float)\n            self.a = np.array(a, dtype=float)\n            self.b = np.array(b, dtype=float)\n            self.s = s\n            \n            cross_prod = np.cross(self.a, self.b)\n            self.area = np.linalg.norm(cross_prod)\n            \n            if self.area > 1e-12:\n                self.normal = self.s * cross_prod / self.area\n            else:\n                # Handle degenerate parallelograms\n                self.normal = np.array([0.0, 0.0, 0.0])\n\n    def get_gauss_legendre(n, cache):\n        \"\"\"\n        Generates Gauss-Legendre nodes and weights for the interval [0, 1].\n        Results are cached to improve performance.\n        \"\"\"\n        if n not in cache:\n            nodes_m11, weights_m11 = roots_legendre(n)\n            nodes_01 = (nodes_m11 + 1.0) / 2.0\n            weights_01 = weights_m11 / 2.0\n            cache[n] = (nodes_01, weights_01)\n        return cache[n]\n\n    def compute_view_factor(s1, s2, n, cache):\n        \"\"\"\n        Computes the view factor F_{1->2} using n-order Gauss-Legendre quadrature.\n        \"\"\"\n        nodes, weights = get_gauss_legendre(n, cache)\n\n        # Generate n x n grid of parametric coordinates and weights for each surface\n        u_grid, v_grid = np.meshgrid(nodes, nodes)\n        wu_grid, wv_grid = np.meshgrid(weights, weights)\n\n        # Flatten grids to get 1D arrays of n^2 points/weights\n        u_flat = u_grid.flatten()\n        v_flat = v_grid.flatten()\n        w_flat = (wu_grid * wv_grid).flatten()\n\n        # Generate n^2 quadrature points in R^3 for each surface\n        # pts1 and pts2 will have shape (n^2, 3)\n        pts1 = s1.o + u_flat[:, np.newaxis] * s1.a + v_flat[:, np.newaxis] * s1.b\n        pts2 = s2.o + u_flat[:, np.newaxis] * s2.a + v_flat[:, np.newaxis] * s2.b\n        \n        # Vectorized calculation over all n^2 x n^2 point pairs\n        # R_vec has shape (n^2, n^2, 3) where R_vec[i, j, :] = pts2[j] - pts1[i]\n        R_vec = pts2[np.newaxis, :, :] - pts1[:, np.newaxis, :]\n        \n        # R_norm has shape (n^2, n^2)\n        R_norm = np.linalg.norm(R_vec, axis=2)\n        \n        # Avoid division by zero for coincident points (theoretically non-occurring here)\n        R_norm_safe = np.where(R_norm  1e-12, 1.0, R_norm)\n\n        # cos(theta) calculations in a vectorized way\n        # Shape of both is (n^2, n^2)\n        cos_theta1 = np.dot(R_vec, s1.normal) / R_norm_safe\n        cos_theta2 = np.dot(-R_vec, s2.normal) / R_norm_safe\n        \n        # Apply visibility condition: contribution is zero if not mutually visible\n        valid_mask = (cos_theta1 > 0)  (cos_theta2 > 0)\n        \n        # Integrand kernel\n        kernel = (cos_theta1 * cos_theta2) / (np.pi * R_norm_safe**2)\n        \n        # Combine weights for 4D integration\n        # w_combined[i, j] = w_flat[i] * w_flat[j]\n        w_combined = w_flat[:, np.newaxis] * w_flat[np.newaxis, :]\n        \n        # Perform summation\n        integral_sum = np.sum(w_combined * kernel * valid_mask)\n        \n        # Final view factor\n        F12 = s2.area * integral_sum\n        return F12\n\n    # --- Test Suite Execution ---\n    results = []\n\n    # Test 1: Reciprocity\n    s1_t1 = Surface(o=[-1.0, -0.5, 0.0], a=[2.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=1)\n    s2_t1 = Surface(o=[-0.8, -0.6, 0.5], a=[2.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=-1)\n    n_t1 = 8\n    F12_t1 = compute_view_factor(s1_t1, s2_t1, n_t1, gl_cache)\n    F21_t1 = compute_view_factor(s2_t1, s1_t1, n_t1, gl_cache)\n    reciprocity_residual = abs(s1_t1.area * F12_t1 - s2_t1.area * F21_t1)\n    results.append(reciprocity_residual)\n\n    # Test 2: Convergence\n    s1_t2 = Surface(o=[-0.5, -0.5, 0.0], a=[1.0, 0.0, 0.0], b=[0.0, 1.0, 0.0], s=1)\n    s2_t2 = Surface(o=[1.0, -0.5, 0.0], a=[0.0, 1.0, 0.0], b=[0.0, 0.0, 2.0], s=-1)\n    orders = [2, 4, 6, 8]\n    f_vals = {n: compute_view_factor(s1_t2, s2_t2, n, gl_cache) for n in orders}\n    delta_86 = abs(f_vals[8] - f_vals[6])\n    delta_64 = abs(f_vals[6] - f_vals[4])\n    convergence_check = (delta_86  5e-4) and (delta_64  2e-3)\n    results.append(convergence_check)\n\n    # Test 3: Additivity\n    n_t3 = 8\n    # Partition surface s1_t1 from Test 1\n    a1_half = s1_t1.a / 2.0\n    s1a_t3 = Surface(s1_t1.o, a1_half, s1_t1.b, s1_t1.s)\n    s1b_t3 = Surface(s1_t1.o + a1_half, a1_half, s1_t1.b, s1_t1.s)\n    \n    F_1_2_t3 = compute_view_factor(s1_t1, s2_t1, n_t3, gl_cache)\n    F_1a_2_t3 = compute_view_factor(s1a_t3, s2_t1, n_t3, gl_cache)\n    F_1b_2_t3 = compute_view_factor(s1b_t3, s2_t1, n_t3, gl_cache)\n\n    # Since areas of sub-surfaces are equal (A_1a = A_1b = A_1/2)\n    F_sum_t3 = 0.5 * F_1a_2_t3 + 0.5 * F_1b_2_t3\n    additivity_residual = abs(F_1_2_t3 - F_sum_t3)\n    results.append(additivity_residual)\n\n    # Test 4: Small-factor edge case\n    s1_t4 = Surface(o=[-0.1, -0.1, 0.0], a=[0.2, 0.0, 0.0], b=[0.0, 0.2, 0.0], s=1)\n    s2_t4 = Surface(o=[-0.1, -0.1, 5.0], a=[0.2, 0.0, 0.0], b=[0.0, 0.2, 0.0], s=-1)\n    n_t4 = 8\n    F12_t4 = compute_view_factor(s1_t4, s2_t4, n_t4, gl_cache)\n    results.append(F12_t4)\n    \n    # Final output format\n    # Convert boolean to lowercase 'true'/'false' for output consistency.\n    results[1] = str(results[1]).lower()\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2537093"}]}