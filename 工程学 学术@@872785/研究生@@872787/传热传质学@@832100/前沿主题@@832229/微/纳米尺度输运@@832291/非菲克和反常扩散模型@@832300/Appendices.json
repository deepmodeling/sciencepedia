{"hands_on_practices": [{"introduction": "均方位移 (MSD) 是表征扩散过程的基本指标。本练习将引导您从第一性原理出发，为经典的时间分数阶扩散方程 (TFDE) 推导其 MSD [@problem_id:2512376]。掌握这种分析技术至关重要，它能帮助您理解分数阶导数阶数 $\\alpha$ 如何直接决定亚扩散标度律 $\\langle x^2(t) \\rangle \\propto t^\\alpha$。", "problem": "考虑一个带阶数为 $0  \\alpha  1$ 的 Caputo 时间导数的一维时间分数阶扩散方程 (TFDE)，\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} C(x,t) = D\\,\\frac{\\partial^{2} C(x,t)}{\\partial x^{2}}, \\quad x\\in\\mathbb{R},\\; t0,\n$$\n其服从点源初始条件 $C(x,0^{+})=\\delta(x)$ 和归一化约束 $\\int_{-\\infty}^{\\infty} C(x,t)\\,dx = 1$ (对于所有 $t0$）。广义扩散系数 $D0$ 的单位是 $\\text{m}^{2}\\,\\text{s}^{-\\alpha}$。对于一个足够光滑的函数 $f$，Caputo 导数定义为\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} f(t) = \\frac{1}{\\Gamma(1-\\alpha)} \\int_{0}^{t} \\frac{f'(\\tau)}{(t-\\tau)^{\\alpha}}\\,d\\tau.\n$$\n令均方位移定义为\n$$\n\\langle x^{2}(t)\\rangle = \\int_{-\\infty}^{\\infty} x^{2}\\,C(x,t)\\,dx.\n$$\n仅从控制方程、初始条件和归一化约束出发，推导出一个关于 $D$、$\\alpha$ 和 $t$ 的 $\\langle x^{2}(t)\\rangle$ 的闭式解析表达式。你可以使用傅里叶变换和拉普拉斯变换的标准性质，包括 Caputo 导数的拉普拉斯变换。将最终结果以单个闭式表达式的形式报告。假设如果 $D$ 的单位是 $\\text{m}^{2}\\,\\text{s}^{-\\alpha}$ 且 $t$ 的单位是 $\\text{s}$，则 $\\langle x^{2}(t)\\rangle$ 的单位是 $\\text{m}^{2}$；不要在最终的方框表达式中包含单位。无需进行数值四舍五入；提供一个精确的符号表达式。", "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它描述了数学物理学中一个标准的反常次扩散模型。我们的任务是求出均方位移 (MSD)，其定义为：\n$$\n\\langle x^{2}(t)\\rangle = \\int_{-\\infty}^{\\infty} x^{2}\\,C(x,t)\\,dx\n$$\n我们将直接从控制方程——时间分数阶扩散方程 (TFDE) 出发，推导一个关于 $\\langle x^{2}(t)\\rangle$ 的微分方程。控制方程为：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} C(x,t) = D\\,\\frac{\\partial^{2} C(x,t)}{\\partial x^{2}}\n$$\n我们首先将 Caputo 时间导数算子 ${}^{\\mathrm{C}}D_{t}^{\\alpha}$ 应用于 $\\langle x^{2}(t)\\rangle$ 的定义。\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = {}^{\\mathrm{C}}D_{t}^{\\alpha} \\left[ \\int_{-\\infty}^{\\infty} x^{2}\\,C(x,t)\\,dx \\right]\n$$\n在浓度分布 $C(x,t)$ 及其导数在 $|x| \\to \\infty$ 时足够快地衰减的假设下，我们可以交换微分和积分算子。对于在一个无限域中从点源扩散的守恒量来说，这一假设是物理上必需的。\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = \\int_{-\\infty}^{\\infty} x^{2}\\,\\left({}^{\\mathrm{C}}D_{t}^{\\alpha} C(x,t)\\right)\\,dx\n$$\n现在，我们将 TFDE 的右侧代入被积函数中：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = \\int_{-\\infty}^{\\infty} x^{2}\\,\\left(D\\,\\frac{\\partial^{2} C(x,t)}{\\partial x^{2}}\\right)\\,dx = D \\int_{-\\infty}^{\\infty} x^{2}\\,\\frac{\\partial^{2} C(x,t)}{\\partial x^{2}}\\,dx\n$$\n我们使用分部积分法来计算右侧的积分。令 $u = x^{2}$ 和 $dv = \\frac{\\partial^{2} C}{\\partial x^{2}}\\,dx$。则 $du = 2x\\,dx$ 且 $v = \\frac{\\partial C}{\\partial x}$。\n$$\n\\int_{-\\infty}^{\\infty} x^{2}\\,\\frac{\\partial^{2} C}{\\partial x^{2}}\\,dx = \\left[ x^{2}\\,\\frac{\\partial C}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} 2x\\,\\frac{\\partial C}{\\partial x}\\,dx\n$$\n边界项 $\\left[ x^{2}\\,\\frac{\\partial C}{\\partial x} \\right]_{-\\infty}^{\\infty}$ 为零，因为对于一个有物理意义的解，浓度及其梯度在无穷远处必须趋于零。因此，我们剩下：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = -2D \\int_{-\\infty}^{\\infty} x\\,\\frac{\\partial C}{\\partial x}\\,dx\n$$\n我们对余下的积分再次使用分部积分法。令 $u = x$ 和 $dv = \\frac{\\partial C}{\\partial x}\\,dx$。则 $du = dx$ 且 $v = C(x,t)$。\n$$\n\\int_{-\\infty}^{\\infty} x\\,\\frac{\\partial C}{\\partial x}\\,dx = \\left[ x\\,C(x,t) \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} C(x,t)\\,dx\n$$\n同样，边界项 $\\left[ x\\,C(x,t) \\right]_{-\\infty}^{\\infty}$ 为零。剩下：\n$$\n\\int_{-\\infty}^{\\infty} x\\,\\frac{\\partial C}{\\partial x}\\,dx = - \\int_{-\\infty}^{\\infty} C(x,t)\\,dx\n$$\n将此结果代回，我们得到：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = -2D \\left( - \\int_{-\\infty}^{\\infty} C(x,t)\\,dx \\right) = 2D \\int_{-\\infty}^{\\infty} C(x,t)\\,dx\n$$\n问题给出了归一化约束 $\\int_{-\\infty}^{\\infty} C(x,t)\\,dx = 1$ (对于所有 $t>0$）。应用此约束可得到一个关于 $\\langle x^{2}(t)\\rangle$ 的简单分数阶常微分方程：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} \\langle x^{2}(t)\\rangle = 2D\n$$\n为了解这个方程，我们需要 $\\langle x^{2}(t)\\rangle$ 的一个初始条件。我们可以从浓度的初始条件 $C(x,0^{+})=\\delta(x)$ 中找到它。\n$$\n\\langle x^{2}(0^{+})\\rangle = \\int_{-\\infty}^{\\infty} x^{2}\\,C(x,0^{+})\\,dx = \\int_{-\\infty}^{\\infty} x^{2}\\,\\delta(x)\\,dx = 0\n$$\n所以我们必须求解以下初值问题：\n$$\n{}^{\\mathrm{C}}D_{t}^{\\alpha} y(t) = 2D, \\quad y(0) = 0\n$$\n其中 $y(t) = \\langle x^{2}(t)\\rangle$。方程 ${}^{\\mathrm{C}}D_{t}^{\\alpha} y(t) = f(t)$ 在初始条件 $y(0) = 0$ 下的解，可以通过将 Riemann-Liouville 分数阶积分算子 $J^{\\alpha}$ 应用于 $f(t)$ 得到。\n$$\ny(t) = J^{\\alpha}[f(t)] = \\frac{1}{\\Gamma(\\alpha)} \\int_{0}^{t} (t-\\tau)^{\\alpha-1} f(\\tau)\\,d\\tau\n$$\n在我们的例子中，$f(t)$是常数 $2D$。\n$$\n\\langle x^{2}(t)\\rangle = \\frac{1}{\\Gamma(\\alpha)} \\int_{0}^{t} (t-\\tau)^{\\alpha-1} (2D)\\,d\\tau = \\frac{2D}{\\Gamma(\\alpha)} \\int_{0}^{t} (t-\\tau)^{\\alpha-1}\\,d\\tau\n$$\n为了计算该积分，我们进行换元，$u = t - \\tau$，这意味着 $du = -d\\tau$。积分上下限从 $\\tau=0$ 变为 $u=t$，从 $\\tau=t$ 变为 $u=0$。\n$$\n\\int_{0}^{t} (t-\\tau)^{\\alpha-1}\\,d\\tau = \\int_{t}^{0} u^{\\alpha-1} (-du) = \\int_{0}^{t} u^{\\alpha-1}\\,du = \\left[ \\frac{u^{\\alpha}}{\\alpha} \\right]_{0}^{t} = \\frac{t^{\\alpha}}{\\alpha}\n$$\n将此结果代回，得到 MSD 的表达式：\n$$\n\\langle x^{2}(t)\\rangle = \\frac{2D}{\\Gamma(\\alpha)} \\left( \\frac{t^{\\alpha}}{\\alpha} \\right) = \\frac{2D t^{\\alpha}}{\\alpha \\Gamma(\\alpha)}\n$$\n最后，利用 Gamma 函数的性质 $\\Gamma(z+1)=z\\Gamma(z)$，我们有 $\\alpha\\Gamma(\\alpha) = \\Gamma(\\alpha+1)$。这将表达式简化为：\n$$\n\\langle x^{2}(t)\\rangle = \\frac{2D t^{\\alpha}}{\\Gamma(\\alpha+1)}\n$$\n这个表达式描述了次扩散过程，其中均方位移随时间以指数 $\\alpha$（小于1）的幂律形式增长。对于 $\\alpha=1$ 的正常扩散情况，我们恢复了经典结果 $\\langle x^{2}(t)\\rangle = \\frac{2D t}{\\Gamma(2)} = 2Dt$。", "answer": "$$\n\\boxed{\\frac{2D t^{\\alpha}}{\\Gamma(\\alpha+1)}}\n$$", "id": "2512376"}, {"introduction": "宏观的非Fick扩散模型往往源于不同的微观随机行走图像。本练习要求您扮演一名实验科学家，利用测得的 MSD 数据以及等待时间和跳跃长度的统计特性，来推断最有可能的潜在物理机制 [@problem_id:2512419]。这项练习将锻炼您将连续时间随机行走 (CTRW) 等抽象数学框架与具体物理观测联系起来的能力。", "problem": "一项实验在温度 $T$下追踪示踪粒子在交联水凝胶中的扩散，得到了均方位移（MSD）的形式为 $\\langle x^{2}(t)\\rangle = A t^{0.7}$，该关系在三个时间数量级上成立，其中 $A$ 是一个具有适当单位的已知正常数。从相同的轨迹中还测量了两个互补的单粒子统计量：\n\n1. 连续跳跃之间的经验等待时间概率密度 $\\psi(\\tau)$ 呈现出一个重尾，在中间渐近范围 $\\tau\\in[\\tau_{0},\\tau_{c}]$ 内与 $\\psi(\\tau)\\sim C \\tau^{-(1+\\mu)}$ 一致，指数估计值为 $\\mu=0.68\\pm 0.03$，且归一化常数 $C$ 有限。\n2. 经验跳跃长度概率密度 $\\lambda(\\ell)$ 呈现出代数尾 $\\lambda(\\ell)\\sim D |\\ell|^{-(1+\\beta)}$，适用于 $|\\ell|\\ge \\ell_{0}$，其中 $\\beta=1.8\\pm 0.1$，且归一化常数 $D$ 有限。\n\n假设示踪粒子的动力学可以由具有独立同分布的等待时间和跳跃的随机游走模型来建模，并考虑以下两种可能的粗粒化描述：(i) 具有重尾等待时间的连续时间随机游走（CTRW）（时间非局域性），以及 (ii) 具有重尾跳跃长度的模型，例如Lévy飞行或Lévy行走（空间非局域性）。您可以假设在实验时间尺度上，位移的所有测量二阶矩都是有限的，并且MSD标度关系 $\\langle x^{2}(t)\\rangle\\propto t^{\\alpha}$ 定义了反常扩散指数 $\\alpha$。\n\n仅使用这些模型的基本定义和广为接受的性质，完成以下任务：\n\n(a) 根据MSD的观测结果，计算反常扩散指数 $\\alpha$。\n\n(b) 基于报告的重尾统计数据，从第一性原理出发，推断是时间非局域性机制还是空间非局域性机制与观测到的MSD标度关系及有限二阶矩更为一致。\n\n最终答案只报告反常指数 $\\alpha$ 的数值。将 $\\alpha$ 表示为一个纯数（无单位），并四舍五入到三位有效数字。", "solution": "我们从一维示踪粒子位置 $x(t)$ 的均方位移（MSD）的定义开始，\n$$\n\\langle x^{2}(t)\\rangle \\equiv \\int_{-\\infty}^{\\infty} x^{2}\\, p(x,t)\\, dx,\n$$\n其中 $p(x,t)$ 是在时间 $t$ 时的位移概率密度，尖括号表示系综平均。在经典的菲克扩散中，概率守恒、菲克定律和高斯中心极限定理行为意味着 $\\langle x^{2}(t)\\rangle \\propto t$。反常扩散由标度律定义\n$$\n\\langle x^{2}(t)\\rangle \\propto t^{\\alpha},\n$$\n其中 $0\\alpha1$ 表示亚扩散，$1\\alpha2$ 表示超扩散。\n\n(a) 部分：实验报告称\n$$\n\\langle x^{2}(t)\\rangle = A t^{0.7},\n$$\n其中 $A0$ 为常数。与定义 $\\langle x^{2}(t)\\rangle \\propto t^{\\alpha}$ 相比，我们直接确定反常扩散指数为\n$$\n\\alpha = 0.7.\n$$\n\n(b) 部分：我们现在使用具有重尾统计的随机游走的第一性原理来评估各种机制。\n\n考虑一个具有独立同分布等待时间和跳跃的连续时间随机游走（CTRW）。设 $\\psi(\\tau)$ 为等待时间概率密度，$\\lambda(\\ell)$ 为跳跃长度概率密度。Montroll–Weiss 形式主义通过以下公式将 $p(x,t)$ 的傅里叶-拉普拉斯变换与 $\\psi$ 和 $\\lambda$ 联系起来\n$$\n\\tilde{p}(k,s) = \\frac{1-\\tilde{\\psi}(s)}{s}\\, \\frac{1}{1-\\tilde{\\psi}(s)\\,\\hat{\\lambda}(k)},\n$$\n其中 $\\tilde{\\psi}(s)$ 是 $\\psi(\\tau)$ 的拉普拉斯变换，$\\hat{\\lambda}(k)$ 是 $\\lambda(\\ell)$ 的傅里叶变换。对于重尾等待时间\n$$\n\\psi(\\tau)\\sim C \\tau^{-(1+\\mu)}, \\quad 0\\mu1,\n$$\n当 $s\\to 0$ 时，渐近地有 $\\tilde{\\psi}(s)\\approx 1 - (s \\tau_{\\mu})^{\\mu}$，其中 $\\tau_{\\mu}$ 是一个依赖于微观细节的特征时间尺度。在假设 $\\lambda(\\ell)$ 具有有限二阶矩（例如，高斯跳跃或足够窄尾的跳跃）的情况下，小 $k$ 展开给出，当 $k\\to 0$ 时，$\\hat{\\lambda}(k)\\approx 1 - \\frac{\\sigma^{2}}{2}k^{2}$，其中跳跃方差为 $\\sigma^{2}$。将这些代入 Montroll–Weiss 表达式，并对小 $s$ 和 $k$ 进行展开，可以得到长时、大尺度的渐近行为\n$$\n\\tilde{p}(k,s) \\approx \\frac{s^{\\mu-1}}{s^{\\mu} + K_{\\mu} k^{2}},\n$$\n其中广义扩散系数为 $K_{\\mu}=\\sigma^{2}/(2 \\tau_{\\mu}^{\\mu})$。对拉普拉斯变换进行逆变换，得到一个带有 $\\mu$ 阶 Caputo 导数的时间分数阶扩散方程，并且MSD的标度关系为\n$\n\\langle x^{2}(t)\\rangle \\sim \\frac{2 K_{\\mu}}{\\Gamma(1+\\mu)}\\, t^{\\mu}.\n$\n因此，对于具有重尾等待时间的CTRW，反常指数等于等待时间的尾部指数：\n$$\n\\alpha = \\mu \\in (0,1),\n$$\n且运动是亚扩散的，对于所有 $t$ 都有有限的MSD。\n\n现在考虑另一种机制：具有\n$$\n\\lambda(\\ell)\\sim D |\\ell|^{-(1+\\beta)}, \\quad 0\\beta2,\n$$\n的重尾跳跃长度，以及有限均值或轻尾的等待时间。对于Lévy飞行，当 $\\beta2$ 时，$\\lambda(\\ell)$ 的二阶矩发散，空间传播子 $p(x,t)$ 表现出具有无限方差的稳定律尾。因此，MSD要么发散，要么无定义，这与实验中有限的MSD不相容。对于Lévy行走，物理速度耦合使运动正则化，因此MSD可以是有限的；然而，对于 $1\\beta2$ 的情况，渐近标度关系是超扩散的，\n$$\n\\langle x^{2}(t)\\rangle \\propto t^{\\alpha}, \\quad \\alpha = 3 - \\beta \\in (1,2),\n$$\n反映了持续的弹道运动段。这与观测到的亚扩散指数 $\\alpha=0.71$ 不相容。\n\n将测量结果与这些第一性原理的推论进行比较：\n- 测得的MSD指数 $\\alpha=0.7$ 表明是具有有限二阶矩的亚扩散。\n- 观测到的等待时间尾部指数 $\\mu=0.68\\pm 0.03$ 接近0.7，在CTRW模型中，直接预测 $\\alpha\\approx \\mu$，这与MSD一致。\n- 观测到的跳跃长度尾部指数 $\\beta=1.8\\pm 0.1$ 意味着要么是无限MSD（Lévy飞行），要么是 $\\alpha=3-\\beta\\approx 1.2$ 的超扩散（Lévy行走），两者都与实验的MSD不一致。\n\n因此，由重尾等待时间（时间记忆）引起的时间非局域性动力学是解释所观测到的亚扩散现象的更合理的机制，而基于重尾跳跃长度的空间非局域性机制与有限的亚扩散MSD不一致。\n\n最后，根据(a)部分和报告要求，反常指数为 $\\alpha=0.7$。四舍五入到三位有效数字得到 $0.700$。", "answer": "$$\\boxed{0.700}$$", "id": "2512419"}, {"introduction": "模拟分数阶扩散模型的一个关键挑战是其非局域记忆核所带来的巨大计算成本。这个动手编程练习介绍了一种强大的数值方法，通过将幂律核近似为指数和来克服这一障碍 [@problem_id:2512393]。通过实现该算法，您将获得为分数阶微分方程开发高效数值格式的实用技能，从而填补理论与计算之间的鸿沟。", "problem": "时间分数阶非菲克扩散模型用一个遗传核取代了经典的菲克型无记忆通量。阶数为 $\\alpha\\in(0,1)$ 的 Caputo 时间分数阶导数使用记忆核 $K(t)=\\frac{t^{-\\alpha}}{\\Gamma(1-\\alpha)}$，该核出现在卷积 $\\int_{0}^{t}K(t-\\tau)g(\\tau)d\\tau$ 中。使用这种幂律核 $K(t)$ 的直接时间步进方法内存开销很大，因为它需要在每一步存储并重用整个历史数据。一种广泛使用的加速策略是将 $K(t)$ 近似为指数和，这样卷积就可以通过每步恒定成本的递归方式进行更新。\n\n您的任务是推导并实现一个对幂律核的快速指数和近似，该近似在有限时间窗口 $[t_{\\min},t_{\\max}]$ 上是一致精确的，并通过直接采样来估计其在该窗口上的近似误差。\n\n仅从以下基本事实出发。\n\n- 阶数 $\\alpha\\in(0,1)$ 的 Caputo 记忆核为 $K(t)=\\frac{t^{-\\alpha}}{\\Gamma(1-\\alpha)}$（对于 $t>0$），其中 $\\Gamma(\\cdot)$ 是伽马函数。\n- 对于 $\\alpha\\in(0,1)$ 成立的拉普拉斯变换恒等式为\n$$\n\\int_{0}^{\\infty} s^{\\alpha-1}\\,e^{-s t}\\,ds \\;=\\; \\Gamma(\\alpha)\\,t^{-\\alpha},\\quad t0.\n$$\n\nA 部分（推导）。\n\n- 使用上述恒等式，推导积分表示\n$$\nK(t)\\;=\\;\\frac{1}{\\Gamma(1-\\alpha)\\,\\Gamma(\\alpha)}\\int_{0}^{\\infty} s^{\\alpha-1}e^{-s t}\\,ds,\\quad t0.\n$$\n- 进行变量替换 $s=e^{x}$ 以证明\n$$\nK(t)\\;=\\;c_{\\alpha}\\int_{-\\infty}^{\\infty} e^{\\alpha x}\\,e^{-t e^{x}}\\,dx,\\quad\\text{其中}\\quad c_{\\alpha}=\\frac{1}{\\Gamma(1-\\alpha)\\,\\Gamma(\\alpha)}.\n$$\n- 在均匀网格 $x_{k}=x_{\\min}+k h$（$k=0,1,\\dots,N-1$，间距 $h>0$）上，使用梯形法则将 $x\\in\\mathbb{R}$ 上的积分近似，并截断到有限区间 $[x_{\\min},x_{\\max}]$。证明这将在 $[t_{\\min},t_{\\max}]$ 上产生一个形式如下的指数和近似\n$$\nK(t)\\;\\approx\\;\\sum_{k=0}^{N-1} w_{k}\\,e^{-\\lambda_{k}\\,t},\\quad\n\\lambda_{k}=e^{x_{k}},\\quad\nw_{k}=c_{\\alpha}\\,h\\,e^{\\alpha x_{k}}.\n$$\n- 提出一个确定性规则，根据 $\\alpha$, $t_{\\min}$, $t_{\\max}$ 和一个无量纲安全裕度 $M>0$ 来选择 $x_{\\min}$ 和 $x_{\\max}$，其动机是基于被积函数在 $s\\sim \\alpha/t$ 处的峰值。一个可接受的选择是\n$$\ns_{\\min}=\\frac{\\alpha}{t_{\\max}}\\,e^{-M},\\quad\ns_{\\max}=\\frac{\\alpha}{t_{\\min}}\\,e^{+M},\\quad\nx_{\\min}=\\log s_{\\min},\\quad\nx_{\\max}=\\log s_{\\max},\\quad\nN=1+\\left\\lceil\\frac{x_{\\max}-x_{\\min}}{h}\\right\\rceil.\n$$\n- 解释为什么对于所有 $t\\in[t_{\\min},t_{\\max}]$，这个选择都能一致地捕捉到积分的主要贡献部分。\n\nB 部分（算法与误差估计）。\n\n- 实现一个函数，给定 $\\alpha\\in(0,1)$, $t_{\\min}>0$, $t_{\\max}>t_{\\min}$, 网格间距 $h>0$ 和裕度 $M>0$，返回按上述方法构建的指数和参数 $\\{(\\lambda_{k},w_{k})\\}_{k=0}^{N-1}$。\n- 实现一个函数，用于在 $[t_{\\min},t_{\\max}]$ 内 $J$ 个点的对数间隔网格 $\\{t_{j}\\}$ 上评估近似的最大相对误差：\n$$\n\\varepsilon_{\\max}\\;=\\;\\max_{1\\le j\\le J}\\frac{\\left|\\sum_{k=0}^{N-1}w_{k}e^{-\\lambda_{k} t_{j}}-K(t_{j})\\right|}{K(t_{j})}.\n$$\n量 $\\varepsilon_{\\max}$ 是无量纲的，不需要单位。\n- 对于下面的每个测试用例，您的程序必须报告数对 $[N,\\varepsilon_{\\max}]$，其中 $N$ 是指数项的数量，$\\varepsilon_{\\max}$ 是在 $J$ 个对数间隔点上计算出的最大相对误差。\n\n测试套件。\n\n- 对所有用例均使用 $J=1000$ 个评估点。\n- 用例 $1$：$\\alpha=0.5$, $t_{\\min}=10^{-3}$, $t_{\\max}=10^{0}$, $h=0.5$, $M=6$。\n- 用例 $2$：$\\alpha=0.1$, $t_{\\min}=10^{-4}$, $t_{\\max}=10^{1}$, $h=0.4$, $M=8$。\n- 用例 $3$：$\\alpha=0.9$, $t_{\\min}=10^{-3}$, $t_{\\max}=10^{0}$, $h=0.4$, $M=8$。\n\n最终输出格式。\n\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个条目本身必须是如上所述的双元素列表 $[N,\\varepsilon_{\\max}]$，并与测试套件的顺序相同。例如，打印的行应类似于 $[\\,[N_{1},\\varepsilon_{\\max,1}],[N_{2},\\varepsilon_{\\max,2}],[N_{3},\\varepsilon_{\\max,3}]\\,]$。", "solution": "问题陈述已经过严格验证，被认为是科学上合理的、适定的和客观的。它提出了一个在分数阶微分方程数值分析领域中标准且重要的问题。其前提在事实上是正确的，定义是明确的，所描述的任务可以形式化为一个可解问题。它既不是微不足道的，也不是不适定的。因此，我将按要求进行完整的推导和算法说明。\n\nCaputo 核 $K(t)$ 的指数和近似的推导过程如前所述，分四个步骤进行。\n\n首先，我们建立核的积分表示。问题给出了阶数为 $\\alpha \\in (0,1)$ 的时间分数阶导数的核的定义为\n$$\nK(t) = \\frac{t^{-\\alpha}}{\\Gamma(1-\\alpha)}, \\quad t>0,\n$$\n其中 $\\Gamma(\\cdot)$ 是欧拉伽马函数。我们还得到了拉普拉斯变换恒等式\n$$\n\\Gamma(\\alpha) t^{-\\alpha} = \\int_{0}^{\\infty} s^{\\alpha-1} e^{-st} ds, \\quad t>0.\n$$\n根据这个恒等式，我们可以将 $t^{-\\alpha}$ 表示为 $t^{-\\alpha} = \\frac{1}{\\Gamma(\\alpha)} \\int_{0}^{\\infty} s^{\\alpha-1} e^{-st} ds$。将此式代入 $K(t)$ 的定义，直接得到所需的积分表示：\n$$\nK(t) = \\frac{1}{\\Gamma(1-\\alpha)} \\left( \\frac{1}{\\Gamma(\\alpha)} \\int_{0}^{\\infty} s^{\\alpha-1} e^{-st} ds \\right) = \\frac{1}{\\Gamma(1-\\alpha)\\Gamma(\\alpha)} \\int_{0}^{\\infty} s^{\\alpha-1} e^{-st} ds.\n$$\n\n其次，我们进行变量替换，将积分转换为更适合数值求积的形式。我们通过替换 $s = e^x$ 将积分变量从 $s$ 更改为 $x$。这意味着 $ds = e^x dx$。当 $s$ 的范围从 $0$ 到 $\\infty$ 时，新变量 $x$ 的范围从 $-\\infty$ 到 $\\infty$。项 $s^{\\alpha-1}$ 变为 $(e^x)^{\\alpha-1} = e^{(\\alpha-1)x}$。积分变换如下：\n$$\n\\int_{0}^{\\infty} s^{\\alpha-1} e^{-st} ds = \\int_{-\\infty}^{\\infty} e^{(\\alpha-1)x} e^{-t e^x} (e^x dx) = \\int_{-\\infty}^{\\infty} e^{\\alpha x - x} e^{-t e^x} e^x dx = \\int_{-\\infty}^{\\infty} e^{\\alpha x} e^{-t e^x} dx.\n$$\n因此，核 $K(t)$ 表示为在整个实直线上的积分：\n$$\nK(t) = c_{\\alpha} \\int_{-\\infty}^{\\infty} e^{\\alpha x} e^{-t e^x} dx,\n$$\n其中常数 $c_{\\alpha}$ 定义为 $c_{\\alpha} = \\frac{1}{\\Gamma(1-\\alpha)\\Gamma(\\alpha)}$。\n\n第三，我们使用数值求积法则来近似这个无穷积分。问题指定了在均匀网格上使用梯形法则，当被积函数在 $\\pm\\infty$ 处足够快地衰减到零时，这是一种对 $\\mathbb{R}$ 上的积分非常有效的方法。积分被截断到有限区间 $[x_{\\min}, x_{\\max}]$，并以均匀步长 $h$ 进行离散化。设网格点为 $x_k = x_{\\min} + kh$，其中 $k=0, 1, \\dots, N-1$，$N$ 是点的数量。梯形法则（对于在 $\\mathbb{R}$ 上的指数衰减被积函数，它简化为权重等于步长 $h$ 的矩形法则）将积分近似为：\n$$\n\\int_{x_{\\min}}^{x_{\\max}} f(x) dx \\approx h \\sum_{k=0}^{N-1} f(x_k).\n$$\n将此应用于我们的被积函数 $f(x, t) = e^{\\alpha x} e^{-t e^x}$，我们得到 $K(t)$ 的近似值：\n$$\nK(t) \\approx c_{\\alpha} h \\sum_{k=0}^{N-1} e^{\\alpha x_k} e^{-t e^{x_k}}.\n$$\n这个表达式正是一个关于变量 $t$ 的指数和。通过定义求积节点 $\\lambda_k = e^{x_k}$ 和相应的权重 $w_k = c_{\\alpha} h e^{\\alpha x_k}$，我们得到所需的形式：\n$$\nK(t) \\approx \\sum_{k=0}^{N-1} w_k e^{-\\lambda_k t}.\n$$\n\n第四，我们必须证明所选择的截断积分域 $[x_{\\min}, x_{\\max}]$ 的合理性。对于给定窗口 $[t_{\\min}, t_{\\max}]$ 内的所有 $t$，该近似必须是一致精确的。对于任何固定的 $t>0$，被积函数 $f(x, t) = e^{\\alpha x} e^{-t e^x}$ 关于 $x$ 只有一个峰值。为了找到这个峰值的位置，我们将其关于 $x$ 的偏导数设为零：\n$$\n\\frac{\\partial f}{\\partial x} = \\alpha e^{\\alpha x} e^{-t e^x} - t e^x e^{\\alpha x} e^{-t e^x} = f(x,t) (\\alpha - t e^x) = 0.\n$$\n这给出了峰值位置 $e^x = \\alpha/t$，或 $x_{\\text{peak}}(t) = \\log(\\alpha/t)$。当 $t$ 从 $t_{\\min}$ 变化到 $t_{\\max}$ 时，被积函数的峰值在区间 $[\\log(\\alpha/t_{\\max}), \\log(\\alpha/t_{\\min})]$ 上移动。为了使求积精确，积分域 $[x_{\\min}, x_{\\max}]$ 必须包含峰值位置的整个范围。被积函数在其峰值之外迅速衰减。所提出的规则，\n$$\nx_{\\min} = \\log(\\alpha/t_{\\max}) - M, \\quad x_{\\max} = \\log(\\alpha/t_{\\min}) + M,\n$$\n构建了一个包含峰值位置范围的区间，并通过一个无量纲安全裕度 $M$ 对其进行对称扩展。这确保了对于任何 $t \\in [t_{\\min}, t_{\\max}]$，被积函数的峰值都很好地位于求积域内，并且只要 $M$ 足够大，$[x_{\\min}, x_{\\max}]$ 之外的尾部贡献可以忽略不计。选择求积点数 $N$ 以指定的间距 $h$ 覆盖该域：$N = 1 + \\lceil(x_{\\max}-x_{\\min})/h\\rceil$。\n\n对于实现，我们基于此推导定义一个算法。首先，一个函数计算指数和参数。给定 $\\alpha, t_{\\min}, t_{\\max}, h, M$，它计算 $c_{\\alpha}, x_{\\min}, x_{\\max}$ 和 $N$。然后它生成网格 $x_k$ 并根据推导出的公式计算集合 $\\{\\lambda_k\\}$ 和 $\\{w_k\\}$。其次，一个误差估计函数接收这些参数并评估近似的质量。它在 $[t_{\\min}, t_{\\max}]$ 上构建一个由 $J$ 个点组成的精细对数间隔网格 $\\{t_j\\}$。在每个点 $t_j$ 处，它使用伽马函数计算精确的核值 $K(t_j)$，并通过对指数级数求和来计算近似值。然后确定该网格上的最大相对误差 $\\varepsilon_{\\max}$。这个过程为在目标时间窗口内近似的准确性提供了一个可靠的估计。所需的特殊函数 $\\Gamma(\\cdot)$ 在 `scipy.special` 库中可用。为了效率，所有数组操作都使用 `numpy` 进行了向量化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gamma\n\ndef solve():\n    \"\"\"\n    Derives and implements a sum-of-exponentials approximation for the\n    Caputo fractional derivative kernel and evaluates its accuracy.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, t_min, t_max, h, M)\n        (0.5, 1e-3, 1.0, 0.5, 6),\n        (0.1, 1e-4, 10.0, 0.4, 8),\n        (0.9, 1e-3, 1.0, 0.4, 8),\n    ]\n\n    # Number of evaluation points for error estimation.\n    J = 1000\n\n    results = []\n    for case in test_cases:\n        alpha, t_min, t_max, h, M = case\n\n        # Part A: Derive sum-of-exponentials parameters {lambda_k, w_k}\n        \n        # Calculate the integration bounds in the s-domain and x-domain\n        s_min = (alpha / t_max) * np.exp(-M)\n        s_max = (alpha / t_min) * np.exp(M)\n        x_min = np.log(s_min)\n        x_max = np.log(s_max)\n        \n        # Determine the number of quadrature points, N, to cover the interval [x_min, x_max]\n        # The number of points is the number of intervals plus one.\n        num_intervals = int(np.ceil((x_max - x_min) / h))\n        N = num_intervals + 1\n        \n        # Construct the uniform grid for the trapezoidal rule\n        k = np.arange(N)\n        x_k = x_min + k * h\n        \n        # Calculate the constant c_alpha\n        c_alpha = 1.0 / (gamma(alpha) * gamma(1.0 - alpha))\n        \n        # Calculate the exponents (lambda_k) and weights (w_k)\n        lambdas = np.exp(x_k)\n        weights = c_alpha * h * np.exp(alpha * x_k)\n        \n        # Part B: Estimate the maximal relative error\n\n        # Create a logarithmically spaced grid of J points for t\n        t_grid = np.logspace(np.log10(t_min), np.log10(t_max), J)\n        \n        # Calculate the exact kernel values, K(t)\n        K_exact = (t_grid**(-alpha)) / gamma(1.0 - alpha)\n        \n        # Calculate the approximate kernel values using the sum-of-exponentials\n        # This is vectorized for efficiency: weights are (N,1), exp term is (N,J)\n        K_approx = np.sum(weights[:, np.newaxis] * np.exp(-lambdas[:, np.newaxis] * t_grid[np.newaxis, :]), axis=0)\n        \n        # Compute the relative error at each point in t_grid\n        relative_errors = np.abs(K_approx - K_exact) / K_exact\n        \n        # Find the maximum relative error over the interval\n        max_relative_error = np.max(relative_errors)\n        \n        results.append([N, max_relative_error])\n\n    # Final print statement in the exact required format.\n    # The format [[N1,eps1],[N2,eps2],...] without extra spaces is achieved\n    # by constructing the string representation for each pair manually.\n    formatted_results = [f\"[{N},{eps}]\" for N, eps in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2512393"}]}