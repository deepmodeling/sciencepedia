{"hands_on_practices": [{"introduction": "本练习是任何格子玻尔兹曼方法（LBM）模拟中至关重要的第一步：将一个物理问题转化为一个可在计算上处理的基于格子的模型。通过确保雷诺数（$Re$）和佩克莱特数（$Pe$）等关键无量纲数的不变性，我们在真实世界和我们的模拟之间建立了联系，这是获得有物理意义结果的一项基本技能。本练习将指导您如何根据给定的物理属性，计算出必要的格子参数，如时间步长 $\\Delta t$ 和弛豫时间 $\\tau$。[@problem_id:2500937]", "problem": "一个长度为$L$、高度为$H$的二维加热通道中，一种被动标量在特征速度为$U$的稳定流场中平流输运。流体的运动黏度为$\\nu$，热扩散率为$\\alpha$。你将使用单弛豫时间Bhatnagar–Gross–Krook (BGK)模型和二维九速(D2Q9)格子，为动量和标量输运建立一个格子玻尔兹曼方法(LBM)模拟。格子离散声速满足$c_{s}^{2} = 1/3$。雷诺数(Re)和佩克莱数(Pe)定义为 $Re = UL/\\nu$ 和 $Pe = UL/\\alpha$。\n\n给定以下物理属性和几何形状：\n- $L = 0.100\\,\\mathrm{m}$，$H = 0.010\\,\\mathrm{m}$，\n- $U = 0.50\\,\\mathrm{m/s}$，\n- $\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$，\n- $\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$，\n\n设计一个在长度$L$上均匀分布$N_{x} = 1000$个节点的格子（使用方形格子，使得两个方向上的格子间距均为 $\\Delta x = L/N_{x}$）。为保持可压缩性误差较小，选择特征格子速度 $U_{\\ell b} = 0.050$（以格子单位计）。利用格子单位下计算的雷诺数和佩克莱数与其实际物理值相等的相似性要求，确定与此选择一致的时间步长$\\Delta t$，然后计算表示给定$\\nu$和$\\alpha$所需的动量和温度的BGK弛豫时间$\\tau_{\\nu}$和$\\tau_{T}$。\n\n将最终答案表示为一个无单位的行矩阵 $\\left(\\tau_{\\nu},\\ \\tau_{T}\\right)$。将你的答案四舍五入到五位有效数字。", "solution": "所述问题具有科学依据，提法恰当，客观，并包含足够的信息以获得唯一解。这是应用格子玻尔兹曼方法(LBM)标度关系的一个标准练习。因此，我将进行推导。\n\nLBM模拟的核心原理是无量纲数（如雷诺数($Re$)和佩克莱数($Pe$)）在物理系统与其格子表示之间保持不变。这要求将物理量（长度、时间、质量）与其在格子单位中的对应量进行一致的标度变换。\n\n首先，我们定义格子参数。通道的物理长度为$L = 0.100\\,\\mathrm{m}$，被离散为$N_{x} = 1000$个节点。这定义了格子间距$\\Delta x$，即相邻格子节点之间的物理距离。\n$$\n\\Delta x = \\frac{L}{N_{x}} = \\frac{0.100\\,\\mathrm{m}}{1000} = 1.0 \\times 10^{-4}\\,\\mathrm{m}\n$$\n问题指定了方形格子，因此两个维度上的间距相同。\n\n接下来，我们必须确定模拟的时间步长$\\Delta t$。这可以通过将物理特征速度$U = 0.50\\,\\mathrm{m/s}$与指定的格子单位特征速度$U_{\\ell b} = 0.050$关联起来找到。物理速度($v_{p}$)和格子速度($v_{\\ell b}$)之间的转换关系为 $v_{p} = v_{\\ell b} \\frac{\\Delta x}{\\Delta t}$。将此应用于特征速度：\n$$\nU = U_{\\ell b} \\frac{\\Delta x}{\\Delta t}\n$$\n求解时间步长$\\Delta t$：\n$$\n\\Delta t = \\frac{U_{\\ell b} \\Delta x}{U} = \\frac{0.050 \\times (1.0 \\times 10^{-4}\\,\\mathrm{m})}{0.50\\,\\mathrm{m/s}} = 1.0 \\times 10^{-5}\\,\\mathrm{s}\n$$\n\n确定了标度因子$\\Delta x$和$\\Delta t$后，我们可以将物理输运系数——运动黏度$\\nu$和热扩散率$\\alpha$——转换为它们在格子单位中的等效值$\\nu_{\\ell b}$和$\\alpha_{\\ell b}$。对于这些单位为长度$^2$/时间的量，转换公式为：\n$$\n\\nu_{\\ell b} = \\frac{\\nu \\Delta t}{\\Delta x^{2}} \\quad \\text{和} \\quad \\alpha_{\\ell b} = \\frac{\\alpha \\Delta t}{\\Delta x^{2}}\n$$\n代入给定的物理值和计算出的标度因子：\n$\\nu = 1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$\\alpha = 2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}$\n$$\n\\nu_{\\ell b} = \\frac{(1.5 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{1.5 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.015\n$$\n$$\n\\alpha_{\\ell b} = \\frac{(2.2 \\times 10^{-5}\\,\\mathrm{m^{2}/s}) \\times (1.0 \\times 10^{-5}\\,\\mathrm{s})}{(1.0 \\times 10^{-4}\\,\\mathrm{m})^{2}} = \\frac{2.2 \\times 10^{-10}}{1.0 \\times 10^{-8}} = 0.022\n$$\n这些是在格子模拟中黏度和扩散率的无量纲值。\n\n最后，我们使用D2Q9格子的单弛豫时间Bhatnagar–Gross–Krook (BGK)模型中的关系式来找到所需的弛豫时间$\\tau_{\\nu}$和$\\tau_{T}$。对于该模型，格子单位中的输运系数通过以下方式与其各自的弛豫时间相关：\n$$\n\\nu_{\\ell b} = c_{s}^{2} (\\tau_{\\nu} - 0.5)\n$$\n$$\n\\alpha_{\\ell b} = c_{s}^{2} (\\tau_{T} - 0.5)\n$$\n问题指定格子声速的平方为$c_{s}^{2} = 1/3$。我们现在可以求解弛豫时间。\n\n对于动量弛豫时间$\\tau_{\\nu}$：\n$$\n\\tau_{\\nu} = \\frac{\\nu_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.015}{1/3} + 0.5 = 3 \\times 0.015 + 0.5 = 0.045 + 0.5 = 0.545\n$$\n对于温度（被动标量）弛豫时间$\\tau_{T}$：\n$$\n\\tau_{T} = \\frac{\\alpha_{\\ell b}}{c_{s}^{2}} + 0.5 = \\frac{0.022}{1/3} + 0.5 = 3 \\times 0.022 + 0.5 = 0.066 + 0.5 = 0.566\n$$\n问题要求将答案四舍五入到五位有效数字。\n$\\tau_{\\nu} = 0.54500$\n$\\tau_{T} = 0.56600$\n\n最终答案以行矩阵形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 0.54500  0.56600 \\end{pmatrix}}\n$$", "id": "2500937"}, {"introduction": "在设定好模拟参数之后，下一个关键步骤是实现核心的LBM算法并验证其正确性。本练习涉及为一个热扩散问题编写一个简单的D1Q3代码，并进行网格加密研究以测量该方法的精度阶数。这种通过与解析解进行对比的验证过程是科学计算的基石，它确保了您的代码能够如理论预测般运行。[@problem_id:2500947]", "problem": "一维扩散热脉冲在周期性域上根据热方程演化。考虑一个长度为 $L$ 的周期性区间上的标量温度场 $T(x,t)$，该温度场由方程 $\\partial_t T = \\alpha \\,\\partial_{xx} T$ 控制，其中 $\\alpha$ 是恒定的热扩散系数。将使用单弛豫时间 Bhatnagar–Gross–Krook (BGK) 模型的一维三速（D1Q3）格子玻尔兹曼方法（LBM）来近似此标量场的演化。D1Q3 模型采用物理单位下的离散粒子速度 $e_i \\in \\{-c, 0, +c\\}$，求积权重 $w_0 = 2/3$ 和 $w_{\\pm 1} = 1/6$，以及标量的线性平衡分布 $f_i^{\\mathrm{eq}} = w_i \\, T$。格子声速满足 $c_s^2 = c^2/3$。在与宏观热方程一致的扩散标度下，热扩散系数通过 $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$ 与格子参数相关联，其中 $\\tau$ 是无量纲弛豫时间，$\\Delta t$ 是物理时间步长。对于具有 $N_x$ 个节点和网格间距 $\\Delta x = L/N_x$ 的均匀网格，当 $c = \\Delta x/\\Delta t$ 时，D1Q3 中的迁移是精确的，这意味着在网格加密时，为了保持 $\\alpha$ 不变，存在耦合关系 $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$。\n\n初始条件和精确解。设初始温度为一个周期性高斯脉冲，其振幅为 $A$，宽度参数为 $\\sigma_0$，中心位于 $x_0 = L/2$。$2J+1$ 镜像周期近似为\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\n根据线性叠加原理和热方程的基本解，时刻 $t$ 对应的周期性精确解为\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\n所有量都是无量纲的，因此所有最终数值都应作为无单位数报告。\n\n离散化和误差范数。在周期性网格上实现带有 BGK 碰撞和精确迁移的标量 D1Q3 LBM。宏观温度是零阶矩 $T = \\sum_i f_i$。通过 $f_i(x,0) = w_i \\, T(x,0)$ 初始化粒子布居数。演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步，以近似 $t^\\ast = N_t \\,\\Delta t$ 时刻的解。使用离散 $L^2$ 范数比较数值解 $T_{\\mathrm{num}}(x,t^\\ast)$ 与精确解 $T_{\\mathrm{exact}}(x,t^\\ast)$\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\n观测到的精度阶。进行网格加密研究，使用 $N_x \\in \\{64,128,256,512\\}$，同时通过上述扩散标度关系保持 $\\alpha$ 不变。对于每次加密，计算误差 $E$、网格间距 $\\Delta x$ 和时间步长 $\\Delta t$。估计：\n- 观测到的空间阶 $p_x$，即 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率；\n- 观测到的时间阶 $p_t$，即 $\\log E$ 对 $\\log \\Delta t$ 的最小二乘线性拟合的斜率。\n由于在扩散标度下 $\\Delta t \\propto \\Delta x^2$，因此必须对同一组加密数据进行两种拟合，以分别表征误差如何随 $\\Delta x$ 和 $\\Delta t$ 变化。\n\n测试套件。使用以下三组参数集，每组的域长度 $L=1$，中心 $x_0=L/2$，镜像数 $J=6$：\n- 情况 A (基准): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- 情况 B (较低扩散系数): $\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n- 情况 C (更尖锐的脉冲): $\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$.\n\n程序要求。编写一个完整的程序，该程序：\n- 为每种情况和 $N_x \\in \\{64,128,256,512\\}$ 实现上述的 D1Q3 标量 LBM。\n- 对于每种情况，计算不同加密程度下的数组 $\\{E\\}$, $\\{\\Delta x\\}$, 和 $\\{\\Delta t\\}$，然后使用最小二乘拟合返回 $(p_x, p_t)$。\n- 其唯一输出为一行，包含六个浮点数值 $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$，按此顺序排列，每个值四舍五入到三位小数，格式为用方括号括起来的逗号分隔列表。\n\n角度单位和物理单位。没有角度量，所有变量都是无量纲的。不应报告任何物理单位；所有输出都是纯数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果 (例如, \"[result1,result2,result3,result4,result5,result6]\")。", "solution": "问题陈述经过验证，被认为是科学上合理的、适定的和自洽的。它提出了一个标准的数值分析任务，涉及将格子玻尔兹曼方法（LBM）应用于一维热方程。所有参数、方程和程序都已足够清晰和正确地指定，从而可以得到唯一解。因此，我们着手推导和实现解决方案。\n\n该问题要求数值求解标量热扩散方程，\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\n在一个长度为 $L$ 的一维周期性域上。指定的方法是带有 Bhatnagar-Gross-Krook (BGK) 碰撞算子的 D1Q3 格子玻尔兹曼模型。\n\nD1Q3 模型将速度空间离散化为三个方向，$i \\in \\{0, 1, 2\\}$，对应于微观粒子速度 $e_0 = 0$、$e_1 = +c$ 和 $e_2 = -c$。粒子分布函数 $f_i(x,t)$ 的演化由格子玻尔兹曼方程控制：\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\n其中 $\\tau$ 是无量纲弛豫时间，$f_i^{\\mathrm{eq}}$ 是局部平衡分布。左侧表示粒子向相邻格子节点的迁移，而右侧表示由于碰撞而向平衡态的弛豫。\n\n对于标量扩散过程，平衡分布是宏观标量场（在此情况下为温度 $T$）的线性函数。它由 $f_i^{\\mathrm{eq}} = w_i T$ 给出，其中 $w_i$ 是求积权重。对于 D1Q3 模型，这些权重是 $w_0 = 2/3$ 和 $w_{1,2} = 1/6$。宏观温度通过分布函数的零阶矩恢复：\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\n可以验证 $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$，这确保了标量 $T$ 在碰撞过程中的局部守恒。\n\n数值算法在每个时间增量中分两步进行：碰撞和迁移。\n1.  **碰撞步**：在每个网格节点 $x_k$ 计算碰撞后的分布函数 $f_i^{\\ast}$：\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    首先，根据当前的布居数计算宏观温度 $T(x_k,t) = \\sum_i f_i(x_k,t)$。然后，确定平衡布居数 $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$，最后应用碰撞更新。\n\n2.  **迁移步**：碰撞后的布居数根据其速度传播到相邻节点。当格子速度设置为 $c = \\Delta x/\\Delta t$（其中 $\\Delta x$ 是网格间距，$\\Delta t$ 是时间步长）时，粒子在一个时间步内精确地从一个节点移动到其邻居节点。对于周期性域，这实现为循环移位：\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    索引 $k-1$ 和 $k+1$ 通过周期性环绕处理。\n\n模拟在时间 $t=0$ 初始化。初始温度场 $T(x,0)$ 由高斯函数的周期性总和给出。初始粒子分布被设置为与该场处于局部平衡：$f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$。然后模拟演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步。最终的数值温度分布 $T_{\\mathrm{num}}(x_k, t^{\\ast})$ 在实际的最终时间 $t^{\\ast} = N_t \\Delta t$ 计算。\n\n问题指定了一个扩散标度关系，以在网格加密过程中保持物理热扩散系数 $\\alpha$ 不变。该关系为：\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\n其中 $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ 是格子声速的平方。将 $c_s^2$ 代入 $\\alpha$ 的表达式并求解 $\\Delta t$，得到时间步长和网格间距之间的显式耦合关系：\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\n该关系意味着 $\\Delta t \\propto \\Delta x^2$。\n\n使用网格大小 $N_x \\in \\{64, 128, 256, 512\\}$ 进行网格加密研究。对于每个 $N_x$，网格间距为 $\\Delta x=L/N_x$，并计算相应的 $\\Delta t$。运行模拟，并使用离散 $L^2$ 范数，对照在 $t^{\\ast}$ 处求值的给定精确解计算误差 $E$：\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\n精度阶由误差定标律的假设 $E \\approx C (\\Delta x)^{p_x}$ 确定，其中 $C$ 为某个常数，$p_x$ 为空间阶。取对数可得 $\\log E \\approx \\log C + p_x \\log \\Delta x$。因此，空间阶 $p_x$ 是 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率。类似地，由于 $\\Delta t \\propto \\Delta x^2$，我们有 $\\log E \\approx \\log C' + p_t \\log \\Delta t$，其中 $p_t = p_x/2$。时间阶 $p_t$ 是 $\\log E$ 对 $\\log \\Delta t$ 拟合的斜率。將为指定的三个测试案例中的每一個计算这两个斜率。用于扩散的 LBM-BGK 格式在空间上预期是二阶精度的，因此我们预计 $p_x \\approx 2.0$，从而 $p_t \\approx 1.0$。\n\n实现过程首先是定义初始条件和精确解析解的函数。一个主模拟函数封装了针对给定物理和数值参数集的 LBM 算法。该函数在每个加密级别被调用。收集由此产生的误差和网格参数。最后，对经对数转换的数据进行线性回归，以提取观测到的精度阶，然后报告这些精度阶。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2500947"}, {"introduction": "现实世界的问题很少有简单的、与网格对齐的边界，而精确处理曲线边界是LBM中的一个重大挑战。这个高级练习探讨了曲率对边界条件精度的影响，特别是对于计算热通量。您将通过解析推导出一个修正方案，以恢复一个常用边界格式的二阶精度，然后使用一个“人造解”（manufactured solution）来数值验证其有效性。[@problem_id:2500986]", "problem": "考虑一个由无平流的能量平衡所支配的被动标量的热传导过程，其中温度场 $T(\\mathbf{x},t)$ 满足 $\\partial T/\\partial t = \\alpha \\nabla^2 T + S$，$\\alpha$ 为热扩散率，$S$ 为源项。关注光滑、弯曲的等温边界（Dirichlet 条件）附近的局部稳态行为，壁面温度为 $T_{\\mathrm{w}}$。引入局部正交的 Frenet 标架 $(s,n)$，其中 $n$ 是从壁面出发的外法向坐标，$s$ 是沿壁面的切向坐标。对于一个局部切向均匀的场（即 $\\partial/\\partial s = 0$），拉普拉斯算子简化为 $\\nabla^2 T = \\partial^2 T/\\partial n^2 + \\kappa\\, \\partial T/\\partial n$，其中 $\\kappa$ 是边界在目标点的带符号曲率（从流体侧看，对于局部凸边界为正）。\n\n在用于标量输运的格子玻尔兹曼方法（LBM）中，一种广泛用于弯曲壁面的边界处理方法是插值反弹格式（IBB）。考虑一个穿过壁面的格子链接，其中流体节点距离壁面的法向距离为 $q\\,\\Delta x$，其中 $q\\in(0,1)$，$\\Delta x$ 为空间步长。对于温度为 $T_{\\mathrm{w}}$ 的等温壁面和一个温度为 $T_{\\mathrm{f}}$ 的邻近流体节点，一个常见的、几何一致的壁面法向温度梯度（计算热通量所需）估计量是以下有限差分商\n$$\nG_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}.\n$$\n相应的壁面法向热通量为 $q_n = -k\\, G$，其中 $k$ 是热导率。在 IBB 的背景下，$G_{\\mathrm{naive}}$ 通过 $q$ 捕捉了离格交叉点的影响，但忽略了曲率引起的耦合。\n\n您的任务是：\n\n- 从局部坐标系中的稳态法向扩散方程 $\\partial^2 T/\\partial n^2 + \\kappa\\, \\partial T/\\partial n = 0$ 和关于壁面位置 $n=0$ 的泰勒展开出发，推导 $G_{\\mathrm{naive}}$ 关于 $\\Delta x$ 幂次的领头阶截断误差。然后，提出一个考虑曲率的修正估计量 $G_{\\mathrm{corr}}(\\Delta x; \\kappa, q)$，它能将壁面法向梯度的精度恢复到 $\\Delta x$ 的二阶。该修正必须通过系统地消除泰勒展开中由曲率引起的领头偏差项来获得。\n- 为在不模拟完整格子玻尔兹曼方法的情况下生成具体、可测试的数值，考虑由以下边值问题定义的构造局部精确解\n$$\n\\frac{\\partial^2 T}{\\partial n^2} + \\kappa\\, \\frac{\\partial T}{\\partial n} = 0,\\quad T(0) = T_{\\mathrm{w}},\\quad \\left.\\frac{\\partial T}{\\partial n}\\right|_{n=0} = G_{\\ast},\n$$\n其中 $\\kappa \\neq 0$ 为常数，壁面法向梯度 $G_{\\ast}$ 为给定的常数。其精确解为\n$$\nT(n) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{-\\kappa n} - 1\\right).\n$$\n特别地，在位于 $n = -q\\,\\Delta x$（流体内部）的流体节点处，精确温度为\n$$\nT_{\\mathrm{f}} = T(-q\\,\\Delta x) = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right).\n$$\n使用此精确的 $T_{\\mathrm{f}}$ 来评估壁面法向梯度的数值估计量，而无需演化任何瞬态格式。\n\n- 定义绝对误差\n$$\nE_{\\mathrm{naive}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{naive}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|,\\qquad\nE_{\\mathrm{corr}}(\\Delta x; \\kappa, q) \\equiv \\left| G_{\\mathrm{corr}}(\\Delta x; \\kappa, q) - G_{\\ast} \\right|.\n$$\n对于每个估计量，通过对加密序列上的 $\\log E$ 与 $\\log \\Delta x$ 进行最小二乘线性回归，计算观测到的收敛阶 $p$。\n\n- 使用以下曲率、交叉点参数和网格加密的测试套件：\n    - 曲率和交叉点对 $(\\kappa, q)$：\n        $$\n        (\\kappa, q) \\in \\left\\{ (1.0, 0.3),\\ (0.5, 0.8),\\ (-1.0, 0.4),\\ (2.0, 0.1) \\right\\}.\n        $$\n    - 网格间距的加密序列：\n        $$\n        \\Delta x \\in \\left\\{ 1/10,\\ 1/20,\\ 1/40,\\ 1/80 \\right\\}.\n        $$\n    - 使用 $T_{\\mathrm{w}} = 0$ 和 $G_{\\ast} = 1$（无量纲单位），以及 $k=1$，从而使热通量的大小等于梯度的大小。仅报告梯度的收敛阶；$p$ 是无量纲的，不需要单位。\n\n- 程序要求：\n    - 实现朴素估计量和您推导的曲率修正估计量。\n    - 对于测试套件中的每个 $(\\kappa,q)$，在指定的加密序列上计算观测到的收敛阶 $p_{\\mathrm{naive}}$ 和 $p_{\\mathrm{corr}}$。\n    - 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n      $[p_{\\mathrm{naive},1}, p_{\\mathrm{corr},1}, p_{\\mathrm{naive},2}, p_{\\mathrm{corr},2}, p_{\\mathrm{naive},3}, p_{\\mathrm{corr},3}, p_{\\mathrm{naive},4}, p_{\\mathrm{corr},4}]$,\n      其中下标索引按上面给出的顺序遍历四个 $(\\kappa,q)$ 案例。\n\n所有计算都以无量纲形式进行。明确地将最终输出表示为上述方括号列表的单个 Python `print` 语句。", "solution": "经过严格审查，问题陈述被认为是有效的。它在科学上基于热传递和数值分析的原理，问题定义清晰，目标明确，并提供了一套自洽、一致的数据和定义。使用构造解是验证数值格式精度阶数的标准且严谨的技术。因此，我们可以进行正式的求解。\n\n本任务旨在推导一个用于壁面法向温度梯度的曲率修正估计量，并与一个更简单的朴素估计量进行比较，以验证其数值收敛特性。\n\n让我们从局部 Frenet 标架 $(s,n)$ 中的稳态、切向均匀的能量平衡方程开始，其中 $n$ 是法向坐标：\n$$\n\\frac{d^2 T}{d n^2} + \\kappa \\frac{d T}{d n} = 0\n$$\n此处，$T(n)$ 是沿法向的温度分布，$\\kappa$ 是局部壁面曲率。边界位于 $n=0$ 处且为等温，因此 $T(0) = T_{\\mathrm{w}}$。真实的壁面法向梯度记为 $G_{\\ast} = \\left.\\frac{dT}{dn}\\right|_{n=0}$。\n\n根据在壁面 $n=0$ 处求值的控制方程，我们可以将二阶导数与一阶导数联系起来：\n$$\n\\left.\\frac{d^2 T}{d n^2}\\right|_{n=0} = -\\kappa \\left.\\frac{d T}{d n}\\right|_{n=0} = -\\kappa G_{\\ast}\n$$\n我们可以通过对控制方程关于 $n$ 求导来找到更高阶的导数：\n$$\n\\frac{d^3 T}{d n^3} = -\\kappa \\frac{d^2 T}{d n^2} = (-\\kappa)(-\\kappa G(n)) = \\kappa^2 \\frac{d T}{d n}\n$$\n其中 $G(n) = \\frac{dT}{dn}$。在壁面处，$\\left.\\frac{d^3 T}{d n^3}\\right|_{n=0} = \\kappa^2 G_{\\ast}$。\n\n现在我们构建温度 $T(n)$ 在壁面位置 $n=0$ 附近的泰勒级数展开：\n$$\nT(n) = T(0) + n \\left.\\frac{dT}{dn}\\right|_{n=0} + \\frac{n^2}{2!} \\left.\\frac{d^2T}{dn^2}\\right|_{n=0} + \\frac{n^3}{3!} \\left.\\frac{d^3T}{dn^3}\\right|_{n=0} + \\mathcal{O}(n^4)\n$$\n代入已知值和推导出的导数关系：\n$$\nT(n) = T_{\\mathrm{w}} + n G_{\\ast} - \\frac{n^2}{2} \\kappa G_{\\ast} + \\frac{n^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(n^4)\n$$\n所考虑的流体节点距离壁面的法向距离为 $q\\,\\Delta x$。由于 $n$ 是外法线，域内的流体节点位于 $n = -q\\,\\Delta x$。在该流体节点处计算温度 $T_{\\mathrm{f}} = T(-q\\,\\Delta x)$：\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} + (-q\\,\\Delta x) G_{\\ast} - \\frac{(-q\\,\\Delta x)^2}{2} \\kappa G_{\\ast} + \\frac{(-q\\,\\Delta x)^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n$$\nT_{\\mathrm{f}} = T_{\\mathrm{w}} - q\\,\\Delta x\\, G_{\\ast} - \\frac{q^2 \\Delta x^2}{2} \\kappa G_{\\ast} - \\frac{q^3 \\Delta x^3}{6} \\kappa^2 G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n对温差 $T_{\\mathrm{w}} - T_{\\mathrm{f}}$ 进行整理：\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} + \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4)\n$$\n朴素梯度估计量定义为 $G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$。代入展开式：\n$$\nG_{\\mathrm{naive}} = \\frac{1}{q\\,\\Delta x} \\left( q\\,\\Delta x\\, G_{\\ast} + \\frac{\\kappa q^2 \\Delta x^2}{2} G_{\\ast} + \\frac{\\kappa^2 q^3 \\Delta x^3}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^4) \\right)\n$$\n$$\nG_{\\mathrm{naive}} = G_{\\ast} + \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\n该估计量的截断误差为 $G_{\\mathrm{naive}} - G_{\\ast} = \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)$。此误差为 $\\Delta x$ 的一阶，因此我们预期收敛阶为 $p=1$。这是由曲率引起的领头偏差。\n\n为恢复二阶精度，我们必须消除这个领头误差项。从 $G_{\\mathrm{naive}}$ 的表达式中，我们可以写出：\n$$\nG_{\\ast} = G_{\\mathrm{naive}} - \\frac{\\kappa q \\Delta x}{2} G_{\\ast} + \\mathcal{O}(\\Delta x^2)\n$$\n为消除右侧的未知量 $G_{\\ast}$，我们可以代入其最低阶近似 $G_{\\ast} \\approx G_{\\mathrm{naive}}$，这是允许的，因为它只会引入更高阶的误差。然而，一个更系统的方法是重新整理表达式 $T_{\\mathrm{w}} - T_{\\mathrm{f}}$：\n$$\nT_{\\mathrm{w}} - T_{\\mathrm{f}} = q\\,\\Delta x\\, G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3) \\right)\n$$\n求解 $G_{\\ast}$：\n$$\nG_{\\ast} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2) \\right)} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2} + \\mathcal{O}(\\Delta x^2)}\n$$\n这启发我们定义一个二阶精度的、考虑曲率的修正估计量 $G_{\\mathrm{corr}}$：\n$$\nG_{\\mathrm{corr}}(\\Delta x; \\kappa, q) = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\n让我们验证这个新估计量的精度。我们代入 $G_{\\mathrm{naive}}$ 的完整展开式：\n$$\nG_{\\mathrm{corr}} = \\frac{G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\mathcal{O}(\\Delta x^3)\\right)}{1 + \\frac{\\kappa q \\Delta x}{2}}\n$$\n使用几何级数展开 $\\frac{1}{1+z} = 1 - z + z^2 - \\dots$，其中 $z = \\frac{\\kappa q \\Delta x}{2}$：\n$$\nG_{\\mathrm{corr}} = G_{\\ast} \\left(1 + \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} + \\dots\\right) \\left(1 - \\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\dots\\right)\n$$\n按 $\\Delta x$ 的幂次展开并收集各项：\n- $\\Delta x^0$ 阶项：$G_{\\ast} \\cdot 1 \\cdot 1 = G_{\\ast}$。\n- $\\Delta x^1$ 阶项：$G_{\\ast} \\left( -\\frac{\\kappa q \\Delta x}{2} + \\frac{\\kappa q \\Delta x}{2} \\right) = 0$。一阶误差项被成功消除。\n- $\\Delta x^2$ 阶项：$G_{\\ast} \\left( \\frac{\\kappa^2 q^2 \\Delta x^2}{4} - \\frac{\\kappa^2 q^2 \\Delta x^2}{4} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} \\right) = G_{\\ast} \\frac{\\kappa^2 q^2 \\Delta x^2}{6}$。\n\n因此，修正估计量的展开式为：\n$$\nG_{\\mathrm{corr}} = G_{\\ast} + \\frac{\\kappa^2 q^2 \\Delta x^2}{6} G_{\\ast} + \\mathcal{O}(\\Delta x^3)\n$$\n截断误差为 $G_{\\mathrm{corr}} - G_{\\ast} = \\mathcal{O}(\\Delta x^2)$，这证实了该估计量是二阶精度的。我们预期数值收敛阶为 $p=2$。\n\n对于问题的数值部分，我们将实现以下公式：\n1.  位于 $n=-q\\Delta x$ 的精确流体温度 $T_{\\mathrm{f}}$ 由构造解给出：\n    $$T_{\\mathrm{f}} = T_{\\mathrm{w}} + \\frac{G_{\\ast}}{-\\kappa}\\,\\left(e^{\\kappa\\, q\\, \\Delta x} - 1\\right)$$\n2.  朴素估计量计算如下：\n    $$G_{\\mathrm{naive}} = \\frac{T_{\\mathrm{w}} - T_{\\mathrm{f}}}{q\\,\\Delta x}$$\n3.  曲率修正估计量为：\n    $$G_{\\mathrm{corr}} = \\frac{G_{\\mathrm{naive}}}{1 + \\frac{1}{2}\\kappa q \\Delta x}$$\n4.  绝对误差为 $E_{\\mathrm{naive}} = |G_{\\mathrm{naive}} - G_{\\ast}|$ 和 $E_{\\mathrm{corr}} = |G_{\\mathrm{corr}} - G_{\\ast}|$。\n5.  收敛阶 $p$ 是 $\\log E$ 对 $\\log \\Delta x$ 进行线性最小二乘拟合的斜率。\n\n所有计算将使用指定的参数 $T_{\\mathrm{w}}=0$，$G_{\\ast}=1$，以及提供的 $(\\kappa, q)$ 和 $\\Delta x$ 集合进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the convergence orders for naive and curvature-corrected\n    wall-normal gradient estimators.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.3),  # (kappa, q) pair 1\n        (0.5, 0.8),  # (kappa, q) pair 2\n        (-1.0, 0.4), # (kappa, q) pair 3\n        (2.0, 0.1),  # (kappa, q) pair 4\n    ]\n\n    # Refinement sequence for the grid spacing.\n    dx_values = np.array([1/10, 1/20, 1/40, 1/80])\n    \n    # Constants for the manufactured solution.\n    Tw = 0.0\n    G_star = 1.0\n\n    results = []\n\n    for kappa, q in test_cases:\n        errors_naive = []\n        errors_corr = []\n\n        for dx in dx_values:\n            # 1. Calculate the exact fluid temperature Tf at the fluid node n = -q*dx\n            # using the provided manufactured solution.\n            # T_f = T_w + (G_star / -kappa) * (e^(kappa*q*dx) - 1)\n            # Since kappa is guaranteed to be non-zero, no division-by-zero check is needed.\n            Tf = Tw + (G_star / -kappa) * (np.exp(kappa * q * dx) - 1.0)\n            \n            # 2. Calculate the naive gradient estimator G_naive.\n            # G_naive = (T_w - T_f) / (q*dx)\n            G_naive = (Tw - Tf) / (q * dx)\n            \n            # 3. Calculate the curvature-corrected gradient estimator G_corr.\n            # G_corr = G_naive / (1 + 0.5 * kappa * q * dx)\n            G_corr = G_naive / (1.0 + 0.5 * kappa * q * dx)\n            \n            # 4. Calculate the absolute errors for both estimators.\n            E_naive = np.abs(G_naive - G_star)\n            E_corr = np.abs(G_corr - G_star)\n            \n            errors_naive.append(E_naive)\n            errors_corr.append(E_corr)\n\n        # 5. Compute the convergence orders p_naive and p_corr.\n        # This is done by a linear least-squares regression of log(E) vs log(dx).\n        # The slope of this regression is the convergence order p.\n        log_dx = np.log(dx_values)\n        \n        # For the naive estimator\n        log_E_naive = np.log(np.array(errors_naive))\n        # np.polyfit with degree 1 returns [slope, intercept]\n        p_naive = np.polyfit(log_dx, log_E_naive, 1)[0]\n        \n        # For the corrected estimator\n        log_E_corr = np.log(np.array(errors_corr))\n        p_corr = np.polyfit(log_dx, log_E_corr, 1)[0]\n        \n        results.extend([p_naive, p_corr])\n\n    # Final print statement in the exact required format.\n    # The output format is a single line: [p_naive1,p_corr1,p_naive2,p_corr2,...]\n    # Rounding is not explicitly requested for the final list elements, but good practice.\n    # The problem description for problem 2 specified rounding, but problem 3 does not. I will output as is.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2500986"}]}