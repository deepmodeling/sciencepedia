{"hands_on_practices": [{"introduction": "理论学习的最终目的是解决实际问题。本节的第一个实践将引导你从零开始构建一个完整的蒙特卡罗模拟程序。通过追踪大量光子在均匀介质板中的完整生命周期，我们将估算一个宏观物理量——能量透射率，从而掌握蒙特卡罗方法的核心流程，包括路径采样、相互作用决策和结果统计。[@problem_id:2508047]", "problem": "您需要设计并实现一个无偏蒙特卡洛估计器，用于计算均匀平板中，入射辐射能分别经过恰好一次体散射事件和两次或以上体散射事件后，到达背向探测器的期望分数。\n\n该介质是均匀、不发射的，具有各向同性散射，且其折射率与外部匹配，因此界面无反射。输运在三维空间中建模，但几何结构在空间上是一维的。\n\n使用以下基本建模假设作为唯一允许的出发点：\n- 线性输运与指数衰减：光子在不发生相互作用的情况下行进自由程长度 $s$ 的概率密度为 $p(s) = \\sigma_t \\exp(-\\sigma_t s)$，其中 $\\sigma_t \\, [\\mathrm{m^{-1}}]$ 是消光系数。单次散射反照率为 $\\omega = \\sigma_s / \\sigma_t \\in [0,1]$，其中 $\\sigma_s \\, [\\mathrm{m^{-1}}]$ 是散射系数。\n- 在一次相互作用中，光子以概率 $\\omega$ 发生弹性散射；以概率 $1-\\omega$ 被吸收并终止。对于三维空间中的各向同性散射，相对于平板法线的新传播方向余弦在 $[-1,1]$ 上均匀分布。\n- 边界条件：平板占据 $x \\in [0,H]$ 的空间，厚度为 $H \\, [\\mathrm{m}]$。入射平面位于 $x=0$，出射平面（探测器平面）位于 $x=H$。界面是透射的，无折射或反射。入射辐射能是单位能量、垂直入射、均匀覆盖入射平面的准直光束。当使用 $N$ 个历史时，每个蒙特卡洛粒子历史代表入射单位能量的 $1/N$ 分数。\n\n定义待求量如下。令 $K$ 为一个随机变量，等于一个历史在出射或被吸收之前所经历的体散射事件次数。令 $E_{\\text{back},1}$ 表示单位入射能量在经历恰好 $K=1$ 次散射事件后，到达并穿过位于 $x=H$ 的背向面的期望分数。令 $E_{\\text{back},\\ge 2}$ 表示在经历 $K \\ge 2$ 次散射事件后，到达并穿过位于 $x=H$ 的背向面的期望分数。$K=0$ 的未散射透射不属于这些待求量的一部分。\n\n您的任务是：\n- 从上述基本陈述中推导出一个路径指示函数估计器，其数学期望分别等于 $E_{\\text{back},1}$ 和 $E_{\\text{back},\\ge 2}$。\n- 实现一个模拟蒙特卡洛算法，该算法在 $x=0$ 处以方向余弦 $+\\!1$ 发射历史，使用参数 $\\sigma_t$ 抽样自由程，利用 $\\omega$ 执行相互作用，并处理各向同性散射。角度单位使用弧度。跟踪每个历史的 $K$ 值，如果历史在 $x=H$ 处以 $K=1$ 的状态出射，则记录对 $E_{\\text{back},1}$ 的贡献为 $1/N$；类似地，如果它在 $x=H$ 处以 $K \\ge 2$ 的状态出射，则对 $E_{\\text{back},\\ge 2}$ 贡献 $1/N$。如果一个历史在 $x=0$ 处出射或被吸收，则它不贡献任何值。\n- 使用固定的随机数种子以确保可复现性。\n\n物理单位和角度单位：\n- $H$ 的单位为 $\\mathrm{m}$，$\\sigma_t$ 的单位为 $\\mathrm{m^{-1}}$。得到的能量分数 $E_{\\text{back},1}$ 和 $E_{\\text{back},\\ge 2}$ 是无量纲的。\n- 使用的任何角度都必须以弧度为单位。\n\n测试套件：\n对以下参数集运行您的程序，每个参数集使用 $N=80000$ 个历史和随机数种子 $12345$。\n- 情况 A（正常路径）：$\\sigma_t = 1.0 \\,\\mathrm{m^{-1}}$，$H = 1.0 \\,\\mathrm{m}$，$\\omega = 0.5$。\n- 情况 B（光学厚、高反照率）：$\\sigma_t = 2.0 \\,\\mathrm{m^{-1}}$，$H = 3.0 \\,\\mathrm{m}$，$\\omega = 0.9$。\n- 情况 C（边界情况、纯吸收）：$\\sigma_t = 1.0 \\,\\mathrm{m^{-1}}$，$H = 1.0 \\,\\mathrm{m}$，$\\omega = 0.0$。\n\n要求的最终输出格式：\n- 您的程序必须产生单行输出，其中包含一个结果列表，每个测试用例对应一个条目，每个条目本身是一个包含两个小数 $[E_{\\text{back},1},E_{\\text{back},\\ge 2}]$ 的列表，保留 $6$ 位小数。外层列表必须按 A、B、C 的顺序排列。例如：`[[0.123456,0.234567],[0.010203,0.040506],[0.000000,0.000000]]`。\n\n角度单位要求：\n- 所有角度都必须以弧度为单位。\n\n不允许有其他输出或格式。", "solution": "所提出的问题是计算物理学中一个定义明确且具有科学依据的练习，具体涉及蒙特卡洛方法在解决辐射输运问题中的应用。问题陈述经验证是完整、一致和客观的。因此，我们将着手推导所需的估计器并设计相应的模拟算法。\n\n物理系统是一个厚度为 $H$ 的均匀、不发射、各向同性散射的平板。辐射垂直入射到 $x=0$ 处的表面。我们的任务是估计经过恰好一次（$E_{\\text{back},1}$）或两次及以上（$E_{\\text{back},\\ge 2}$）散射事件后，从 $x=H$ 处的背向面出射的入射能量的分数。\n\n蒙特卡洛方法模拟大量单个能量包（或称“光子”）的概率行为。在一维平板几何结构中，光子的状态由其位置 $x \\in [0, H]$ 和方向余弦 $\\mu \\in [-1, 1]$ 定义，其中 $\\mu$ 是光子传播矢量与正 $x$ 轴之间夹角的余弦。每个历史都从入射平面 $x_0 = 0$ 开始，方向垂直于表面，即 $\\mu_0 = 1$。光子经历的散射事件次数 $K$ 初始化为 $K=0$。\n\n模拟的核心是追踪单个光子生命周期的循环：\n\n1.  **路径长度抽样**：光子在下一次相互作用前行进一个随机距离 $s$。此自由程长度的概率密度函数由指数衰减定律给出，$p(s) = \\sigma_t \\exp(-\\sigma_t s)$，其中 $\\sigma_t$ 是消光系数。使用逆变换法对此分布进行抽样。给定一个均匀随机数 $R_s \\in (0,1)$，路径长度计算如下：\n    $$\n    s = -\\frac{\\ln(R_s)}{\\sigma_t}\n    $$\n    然后根据光子当前的位置 $x$ 和方向 $\\mu$ 计算其新的潜在位置 $x'$：\n    $$\n    x' = x + s \\cdot \\mu\n    $$\n\n2.  **边界穿越**：我们必须检查光子的路径是否穿过平板的边界。\n    - 如果 $x' \\ge H$，光子从背向面（探测器）出射。历史终止。我们根据 $K$ 的值对事件进行计分。\n    - 如果 $x' \\le 0$，光子从前向面（反向散射）出射。历史终止，对所求量无任何贡献。\n    - 如果 $0  x'  H$，则在平板内部发生相互作用。光子的位置更新为 $x \\leftarrow x'$。\n\n3.  **相互作用事件**：在相互作用点，光子要么散射，要么被吸收。这由单次散射反照率 $\\omega = \\sigma_s / \\sigma_t$ 决定。抽样一个均匀随机数 $R_\\omega \\in [0,1)$。\n    - 如果 $R_\\omega  \\omega$，光子发生散射。我们将散射计数器加一，$K \\leftarrow K+1$。对于各向同性散射，新的方向余弦 $\\mu'$ 从 $[-1, 1]$ 上的均匀分布中抽样。这通过抽样另一个随机数 $R_\\mu \\in [0,1)$ 并设置 $\\mu' = 2R_\\mu - 1$ 来实现。光子的状态用这个新方向更新，$\\mu \\leftarrow \\mu'$，然后模拟从步骤 1 继续。\n    - 如果 $R_\\omega \\ge \\omega$，光子被吸收。历史终止。\n\n4.  **估计器公式化**：问题要求一个无偏的指示函数估计器。对于总共 $N$ 个模拟历史，这等同于一个模拟蒙特卡洛方案。期望值 $E_{\\text{back},1}$ 通过在 $x=H$ 处以恰好一次散射出射的历史所占的比例来估计。令 $I_{1,i}$ 为第 $i$ 个历史的指示变量：\n    $$\n    I_{1,i} = \\begin{cases} 1,  \\text{if history } i \\text{ exits at } x=H \\text{ with } K=1 \\\\ 0,  \\text{otherwise} \\end{cases}\n    $$\n    $E_{\\text{back},1}$ 的估计器是 $N$ 个历史的样本均值：\n    $$\n    \\hat{E}_{\\text{back},1} = \\frac{1}{N} \\sum_{i=1}^{N} I_{1,i} = \\frac{N_{K=1}}{N}\n    $$\n    其中 $N_{K=1}$ 是满足该条件的历史总数。\n\n    类似地，对于经过两次或更多次散射后透射的能量分数，其估计器为：\n    $$\n    \\hat{E}_{\\text{back},\\ge 2} = \\frac{1}{N} \\sum_{i=1}^{N} I_{\\ge 2,i} = \\frac{N_{K\\ge 2}}{N}\n    $$\n    其中 $I_{\\ge 2,i}$ 是一个历史在 $x=H$ 处以 $K \\ge 2$ 出射的指示符，而 $N_{K\\ge 2}$ 是相应的计数。\n\n提供的 Python 代码实现了该算法。它遍历每个指定的测试用例，使用固定的随机数种子运行 $N=80000$ 个历史以保证可复现性，并计算这两个估计器。对于纯吸收情况（$\\omega = 0$），不可能发生散射（任何透射光子的 $K$ 值将始终为 $0$），因此我们正确地预期并验证了 $\\hat{E}_{\\text{back},1} = 0$ 和 $\\hat{E}_{\\text{back},\\ge 2} = 0$。最终结果按要求格式化为六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(slab_thickness, extinction_coeff, albedo, num_histories, rng):\n    \"\"\"\n    Performs an analog Monte Carlo simulation for radiative transport in a 1D slab.\n\n    Args:\n        slab_thickness (float): The thickness H of the slab [m].\n        extinction_coeff (float): The extinction coefficient sigma_t [m^-1].\n        albedo (float): The single-scattering albedo omega.\n        num_histories (int): The number of photon histories to simulate.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        list: A list containing two floats [E_back_1, E_back_ge2].\n    \"\"\"\n    transmitted_k1 = 0\n    transmitted_k_ge2 = 0\n\n    for _ in range(num_histories):\n        # Initialize photon state for a new history\n        x = 0.0      # Position, starting at the entrance plane\n        mu = 1.0     # Direction cosine, normal incidence\n        k = 0        # Number of scattering events\n        is_alive = True\n\n        while is_alive:\n            # Sample the free path length s using inverse transform sampling\n            # rng.random() samples from [0.0, 1.0). If it returns 0.0, log(0) is -inf,\n            # leading to an infinite path length s, which is physically correct.\n            s = -np.log(rng.random()) / extinction_coeff\n            \n            # Calculate the potential new position\n            x_new = x + s * mu\n            \n            # Check for boundary crossing or interaction\n            if x_new = slab_thickness:  # Photon transmitted through the back face\n                if k == 1:\n                    transmitted_k1 += 1\n                elif k = 2:\n                    transmitted_k_ge2 += 1\n                is_alive = False  # Terminate history\n            elif x_new = 0:  # Photon back-scattered through the front face\n                is_alive = False  # Terminate history\n            else:  # Interaction occurs inside the slab\n                x = x_new\n                \n                # Determine if the photon scatters or is absorbed\n                if rng.random()  albedo:  # Scattering event\n                    k += 1\n                    # Sample new direction for isotropic scattering\n                    # The new direction cosine is uniformly distributed in [-1, 1]\n                    mu = 2.0 * rng.random() - 1.0\n                else:  # Absorption event\n                    is_alive = False  # Terminate history\n                    \n    # Calculate the estimated fractions of transmitted energy\n    e_back_1 = transmitted_k1 / num_histories\n    e_back_ge2 = transmitted_k_ge2 / num_histories\n    \n    return [e_back_1, e_back_ge2]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results in the required format.\n    \"\"\"\n    # Define the simulation parameters from the problem statement\n    num_histories = 80000\n    random_seed = 12345\n    \n    # Define the test cases from the problem statement.\n    # Format: (H [m], sigma_t [m^-1], omega)\n    test_cases = [\n        # Case A: Happy path\n        (1.0, 1.0, 0.5),\n        # Case B: Optically thick, high albedo\n        (3.0, 2.0, 0.9),\n        # Case C: Boundary case, pure absorption\n        (1.0, 1.0, 0.0)\n    ]\n\n    # Initialize the random number generator for reproducibility\n    rng = np.random.default_rng(random_seed)\n\n    all_results = []\n    for H, sigma_t, omega in test_cases:\n        result_pair = run_simulation(H, sigma_t, omega, num_histories, rng)\n        all_results.append(result_pair)\n\n    # Format the final output string precisely as required\n    case_strings = []\n    for e1, e2 in all_results:\n        s1 = f\"{e1:.6f}\"\n        s2 = f\"{e2:.6f}\"\n        case_strings.append(f\"[{s1},{s2}]\")\n    \n    final_output_string = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2508047"}, {"introduction": "真实世界的辐射传输问题往往涉及性质不均匀的复杂介质。这个实践将我们的模拟能力从简单的均匀平板扩展到更普遍的情况。我们将学习并实现一种关键的“逐元追踪”算法，它能精确地在具有不同光学性质的网格单元中追踪光子路径并累积光学厚度，这是开发通用蒙特卡罗模拟程序的必备技能。[@problem_id:2508013]", "problem": "给定一个三维、轴对齐的矩形域，该域被离散化为具有分段常数消光系数的均匀笛卡尔单元网格。从域内一点以给定方向发射单条笔直、无散射的蒙特卡洛射线。射线的自由程以光学厚度为单位进行采样。您的任务是从第一性原理出发，推导并实现一个物理上忠实的逐单元遍历算法，该算法沿射线逐个单元累积光学厚度，直到光学厚度预算耗尽（发生碰撞事件）或射线离开域（无碰撞）。\n\n使用以下基本原理进行推导：\n- 沿特征线的仅含消光辐射传输方程 (RTE)：在消光系数为 $\\kappa_e(\\mathbf{x})$ 的介质中，对于一个小的路径长度段 $ds$，辐射强度的衰减遵循 $dI/ds = -\\kappa_e I$，这意味着比尔-朗伯衰减。在常数 $\\kappa_e$ 的均匀介质中，行进距离 $s$ 后的存活概率为 $\\exp(-\\kappa_e s)$。\n- 自由程的光学厚度逆变换采样：光学自由程 $\\tau$ 服从概率密度函数为 $p(\\tau) = \\exp(-\\tau)$（其中 $\\tau \\ge 0$）的指数分布。给定一个均匀随机变量 $\\xi \\in (0,1)$，通过 $\\tau = -\\ln(1 - \\xi)$ 对 $\\tau$ 进行采样。\n- 分段常数消光：在每个网格单元 $C$ 中，消光系数 $\\kappa_e$ 是恒定的，在 $C$ 内长度为 $s_C$ 的几何路径段上累积的光学厚度为 $\\tau_C = \\kappa_e s_C$。\n\n您的算法目标是：\n- 给定域内的一个起始位置 $\\mathbf{x}_0$、一个单位长度（无量纲）的方向向量 $\\hat{\\boldsymbol{\\omega}}$，以及一个采样的光学厚度预算 $\\tau^\\star$，沿射线遍历单元并累积光学厚度，直到事件发生。\n- 在每个单元内，计算沿射线到下一个相交单元面的几何路径长度，并使用该单元局部的、单元内恒定的 $\\kappa_e$ 计算相应的光学厚度贡献。\n- 判断碰撞是发生在当前单元内，还是射线穿入下一个单元，并迭代此过程，直到发生碰撞或射线离开域。\n\n几何和物理规格：\n- 域是轴对齐的立方体 $[0,L_x) \\times [0,L_y) \\times [0,L_z)$，其中 $L_x = L_y = L_z = $ $1.0$（单位：米）。\n- 网格是均匀的，每个轴向有 $N_x = N_y = N_z = $ $2$ 个单元，因此每个单元的尺寸为 $\\Delta x = \\Delta y = \\Delta z = $ $0.5$（单位：米）。\n- 以逆米为单位的消光系数 $\\kappa_e$ 在每个单元内是分段常数，单元索引为 $(i_x,i_y,i_z) \\in \\{0,1\\}^3$，其值为：\n  - $\\kappa_e(0,0,0) = $ $2.0$，\n  - $\\kappa_e(1,0,0) = $ $1.0$，\n  - $\\kappa_e(0,1,0) = $ $0.2$，\n  - $\\kappa_e(1,1,0) = $ $0.4$，\n  - $\\kappa_e(0,0,1) = $ $0.5$，\n  - $\\kappa_e(1,0,1) = $ $3.0$，\n  - $\\kappa_e(0,1,1) = $ $0.1$，\n  - $\\kappa_e(1,1,1) = $ $0.2$。\n\n碰撞判定规则：\n- 设处理当前单元前的剩余光学厚度预算为 $\\tau_{\\mathrm{rem}}$。设当前单元内沿射线到下一个单元面的几何距离为 $s_{\\mathrm{face}}$（单位：米）。该单元到达该面的光学厚度贡献为 $\\tau_{\\mathrm{face}} = \\kappa_e s_{\\mathrm{face}}$。\n- 如果 $\\tau_{\\mathrm{rem}} \\le \\tau_{\\mathrm{face}}$，则判定在当前单元内发生碰撞，碰撞位置距当前位置的距离为 $s_\\mathrm{col} = \\tau_{\\mathrm{rem}}/\\kappa_e$，然后停止。\n- 如果 $\\tau_{\\mathrm{rem}}  \\tau_{\\mathrm{face}}$，则将 $\\tau_{\\mathrm{rem}}$ 更新为 $\\tau_{\\mathrm{rem}} \\leftarrow \\tau_{\\mathrm{rem}} - \\tau_{\\mathrm{face}}$，将射线推进到单元面，沿相交轴移入相邻单元，然后继续。\n- 如果下一步将使射线离开域，则以无碰撞终止。\n\n单位与归一化：\n- 所有方向必须是单位向量，以确保沿射线的几何距离以米为单位。距离必须以米为单位报告。光学厚度是无量纲的。\n\n角度单位：\n- 不适用；方向以单位向量的分量形式提供。\n\n测试套件：\n实现您的算法，并将其应用于以下五个测试用例。在每个案例中，光学厚度预算均通过给定的 $\\xi$ 使用 $\\tau^\\star = -\\ln(1 - \\xi)$ 进行采样。\n\n- 案例 1（穿过一个单元面后碰撞）：\n  - $\\mathbf{x}_0 = [$ $0.1$, $0.1$, $0.1$ $]$ (米),\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $1.0$, $0.0$, $0.0$ $]$ (无单位),\n  - $\\xi = $ $0.6321205588285577$ (因此 $\\tau^\\star = $ $1.0$ 整).\n- 案例 2（恰好在单元面发生碰撞；边界相等情况）：\n  - $\\mathbf{x}_0 = [$ $0.1$, $0.1$, $0.1$ $]$ (米),\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $1.0$, $0.0$, $0.0$ $]$ (无单位),\n  - $\\xi = $ $0.5506710358827784$ (因此 $\\tau^\\star = $ $0.8$ 整).\n- 案例 3（无碰撞；在预算耗尽前离开域）：\n  - $\\mathbf{x}_0 = [$ $0.25$, $0.75$, $0.75$ $]$ (米),\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $0.0$, $-1.0$, $0.0$ $]$ (无单位),\n  - $\\xi = $ $0.6321205588285577$ (因此 $\\tau^\\star = $ $1.0$ 整).\n- 案例 4（轴对齐且有一个零分量；在当前单元内碰撞）：\n  - $\\mathbf{x}_0 = [$ $0.3$, $0.3$, $0.3$ $]$ (米),\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $0.0$, $1.0$, $0.0$ $]$ (无单位),\n  - $\\xi = $ $0.048770575499285984$ (因此 $\\tau^\\star = $ $0.05$ 整).\n- 案例 5（负分量和带零分量的斜向遍历）：\n  - $\\mathbf{x}_0 = [$ $0.8$, $0.9$, $0.1$ $]$ (米),\n  - $\\hat{\\boldsymbol{\\omega}} = [$ $-1.0$, $-1.0$, $0.0$ $]$ (无单位；需归一化为单位长度),\n  - $\\xi = $ $0.09516258196404048$ (因此 $\\tau^\\star = $ $0.1$ 整).\n\n每个测试用例所需的输出：\n- 一个包含四个条目的列表，顺序如下：\n  - 一个布尔值，指示是否在域内发生碰撞。\n  - 沿射线直到事件（碰撞或离开）发生所行进的总几何距离，以米为单位，作为浮点数。\n  - 事件发生时累积的光学厚度，作为浮点数（如果发生碰撞，则等于采样的预算；否则等于直到离开时累积的光学厚度，严格小于采样的预算）。\n  - 事件发生所在单元的整数索引三元组 $[i_x,i_y,i_z]$。如果事件是离开（无碰撞），则报告射线离开前的最后一个域内单元索引。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有五个测试用例结果的列表，每个用例的结果本身也是一个按上述顺序排列的列表。最外层必须是单个Python风格的列表字面量，例如：\n  \"[[case1_result_list],[case2_result_list],...,[case5_result_list]]\".", "solution": "我们从仅含消光介质中沿特征线的辐射传输方程 (RTE) 开始。设 $I(s)$ 表示沿由几何路径长度 $s$ 参数化的射线在消光系数为 $\\kappa_e(\\mathbf{x}) \\ge 0$ 的介质中的辐射亮度。在一个无穷小段 $ds$ 上，RTE简化为 $dI/ds = -\\kappa_e I$，对于均匀段，该方程积分得到比尔-朗伯定律：$I(s) = I(0)\\exp(-\\kappa_e s)$。行进到 $s$ 处的存活概率为 $\\exp(-\\kappa_e s)$，这意味着定义为 $\\tau(s) = \\int_0^s \\kappa_e(\\mathbf{x}(u))\\,du$ 的光学厚度是可加的且无量纲的。对于一个具有恒定 $\\kappa_e$ 且在其中行进了几何距离 $s_C$ 的均匀单元 $C$，光学厚度增量为 $\\tau_C = \\kappa_e s_C$。\n\n在蒙特卡洛自由程采样中，到碰撞点的光学厚度是一个单位速率的指数随机变量。如果 $\\xi \\sim \\mathcal{U}(0,1)$，则采样的光学预算为 $\\tau^\\star = -\\ln(1 - \\xi)$。给定 $\\xi$，这个选择是确定性的。碰撞事件发生在路径积分 $\\tau(s)$ 达到 $\\tau^\\star$ 的最小 $s \\ge 0$ 处，即 $\\tau(s) = \\tau^\\star$，前提是射线仍在域内；否则，当射线到达域边界且 $\\tau(s_{\\mathrm{exit}})  \\tau^\\star$ 时，射线无碰撞地离开。\n\n由于 $\\kappa_e(\\mathbf{x})$ 在轴对齐的单元网格上是分段常数，我们可以将沿射线的 $\\tau$ 积分分解为对连续单元的求和。设域为 $[0,L_x) \\times [0,L_y) \\times [0,L_z)$，其中 $L_x=L_y=L_z=$ $1.0$，在每个维度上均匀离散为 $N_x=N_y=N_z=$ $2$ 个单元，得到单元尺寸 $\\Delta x=\\Delta y=\\Delta z=$ $0.5$。对于单元索引 $(i_x,i_y,i_z)\\in \\{0,1\\}^3$，消光系数值 $\\kappa_e$ 已指定。射线由域内的一个初始点 $\\mathbf{x}_0$ 和一个单位长度的方向 $\\hat{\\boldsymbol{\\omega}}$ 定义。射线方程为 $\\mathbf{x}(s) = \\mathbf{x}_0 + s\\hat{\\boldsymbol{\\omega}}$。\n\n我们需要一个鲁棒的算法来遍历单元并累积光学厚度。用于轴对齐网格的标准数字微分分析器 (DDA) 提供了一种高效的方法，可以从单元内的位置和方向计算沿射线到下一个单元面的几何距离。设 $\\hat{\\boldsymbol{\\omega}}=(\\omega_x,\\omega_y,\\omega_z)$，并假设射线当前位于单元 $(i_x,i_y,i_z)$ 中。定义步进符号 $s_x=\\operatorname{sign}(\\omega_x)$，约定 $s_x\\in\\{-1,0,1\\}$，对 $s_y$ 和 $s_z$ 也类似。对每个轴定义：\n- 如果 $\\omega_x0$，下一个垂直于 $\\hat{\\mathbf{e}}_x$ 的平面在 $x = (i_x+1)\\Delta x$ 处，到该平面的几何距离为\n$$\nt^{\\max}_x = \\frac{(i_x+1)\\Delta x - x_0}{\\omega_x},\n$$\n其中 $x_0$ 是当前的 $x$ 坐标。如果 $\\omega_x0$，下一个平面在 $x = i_x\\Delta x$ 处，距离为\n$$\nt^{\\max}_x = \\frac{x_0 - i_x\\Delta x}{|\\omega_x|}.\n$$\n如果 $\\omega_x=0$，则设 $t^{\\max}_x=+\\infty$。此后，连续的与 $x$ 轴对齐的平面之间的增量距离为\n$$\nt^{\\Delta}_x = \\begin{cases}\n\\frac{\\Delta x}{|\\omega_x|},  \\omega_x\\neq 0,\\\\\n+\\infty,  \\omega_x=0.\n\\end{cases}\n$$\n类似地定义 $t^{\\max}_y,t^{\\Delta}_y$ 和 $t^{\\max}_z,t^{\\Delta}_z$。\n\n设 $s_{\\mathrm{tot}}$ 表示从 $\\mathbf{x}_0$ 已经行进的几何距离，$\\tau_{\\mathrm{rem}}$ 表示碰撞前待消耗的剩余光学预算，初始值为 $\\tau_{\\mathrm{rem}}=\\tau^\\star$。在当前单元的每次迭代中：\n1.  计算从 $\\mathbf{x}_0$ 沿射线到下一个单元面的绝对距离为 $t_{\\mathrm{face}} = \\min\\{t^{\\max}_x,t^{\\max}_y,t^{\\max}_z\\}$。当前单元内的增量几何距离为 $s_{\\mathrm{cell}} = t_{\\mathrm{face}} - s_{\\mathrm{tot}}$。\n2.  该单元到达该面的光学贡献为 $\\tau_{\\mathrm{face}} = \\kappa_e(i_x,i_y,i_z)\\, s_{\\mathrm{cell}}$。\n3.  如果 $\\tau_{\\mathrm{rem}} \\le \\tau_{\\mathrm{face}}$，则在当前单元内发生碰撞，几何增量为\n$$\ns_{\\mathrm{col}} = \\frac{\\tau_{\\mathrm{rem}}}{\\kappa_e(i_x,i_y,i_z)},\n$$\n因此总行进距离变为 $s_{\\mathrm{tot}} \\leftarrow s_{\\mathrm{tot}} + s_{\\mathrm{col}}$，然后带碰撞停止。\n4.  否则，将 $\\tau_{\\mathrm{rem}}$ 更新为 $\\tau_{\\mathrm{rem}} \\leftarrow \\tau_{\\mathrm{rem}} - \\tau_{\\mathrm{face}}$，将 $s_{\\mathrm{tot}}$ 推进到 $s_{\\mathrm{tot}} \\leftarrow t_{\\mathrm{face}}$，并确定哪个轴在 $t_{\\mathrm{face}}$ 中实现了最小值。如果多个轴完全相等，任何能防止重复计数的相容性决胜规则都是可接受的；为了数值稳定性，我们考虑严格最小值。如果沿该轴前进会离开网格（即，当 $x$ 轴是最小化轴时，$i_x + s_x$ 超出 $\\{0,1\\}$），则射线在距离 $s_{\\mathrm{tot}}$ 处无碰撞地离开域。否则，将相应的索引加上步进符号，例如，对 $x$ 轴为 $i_x \\leftarrow i_x + s_x$，并为所选轴更新 DDA 累加器 $t^{\\max}_x \\leftarrow t^{\\max}_x + t^{\\Delta}_x$。从步骤 1 重复。\n5.  方向是单位向量，因此所有 $t$ 和 $s$ 的单位都是米。光学厚度保持无量纲。\n\n该算法直接在单元上分段线性地积分路径积分 $\\tau(s)$，遵循了光学厚度的可加性和 $\\tau^\\star$ 的指数采样。在等式 $\\tau_{\\mathrm{rem}} = \\tau_{\\mathrm{face}}$ 处的判定规则会在当前单元的单元面上产生一次碰撞，这在物理上是一致的，因为碰撞事件是沿路径连续采样的。\n\n我们现在解释每个测试用例：\n\n- 案例 1：$\\mathbf{x}_0=[$ $0.1$, $0.1$, $0.1$ $]$, $\\hat{\\boldsymbol{\\omega}}=[$ $1$, $0$, $0$ $]$, $\\tau^\\star=$ $1$。当前单元 $(0,0,0)$，$\\kappa_e=$ $2.0$。到 $x=$ $0.5$ 的距离是 $s=$ $0.4$，到该面的光学厚度是 $\\tau_{\\mathrm{face}}=$ $0.8$。由于 $\\tau^\\star  \\tau_{\\mathrm{face}}$，移动到 $(1,0,0)$，剩余预算为 $1.0-0.8=$ $0.2$。在 $(1,0,0)$ 中，$\\kappa_e=$ $1.0$，因此碰撞发生在 $s_{\\mathrm{col}}=0.2/1.0=$ $0.2$ 处。总距离为 $0.4+0.2=$ $0.6$，在单元 $(1,0,0)$ 中发生碰撞。\n\n- 案例 2：几何结构相同，但 $\\tau^\\star=$ $0.8$。在 $(0,0,0)$ 中，到面的光学厚度恰好为 $\\tau_{\\mathrm{face}}=$ $0.8$。根据相等规则，在当前单元内的面上发生碰撞，距离为 $s=$ $0.4$；报告单元 $(0,0,0)$。\n\n- 案例 3：$\\mathbf{x}_0=[$ $0.25$, $0.75$, $0.75$ $]$, $\\hat{\\boldsymbol{\\omega}}=[$ $0$, $-1$, $0$ $]$, $\\tau^\\star=$ $1$。从 $(0,1,1)$ 开始，$\\kappa_e=$ $0.1$；到 $y=$ $0.5$ 的距离是 $s=$ $0.25$，光学厚度 $\\tau_{\\mathrm{face}}=$ $0.025$。步进到 $(0,0,1)$（因为沿 $-y$ 方向移动），剩余预算为 $0.975$。在 $(0,0,1)$ 中，$\\kappa_e=$ $0.5$；到 $y=$ $0$ 处域出口的距离是 $s=$ $0.5$，光学厚度 $\\tau_{\\mathrm{face}}=$ $0.25$。射线无碰撞地离开，因为 $0.025+0.25=$ $0.275  1.0$。总距离为 $0.25+0.5=$ $0.75$，最后一个域内单元是 $(0,0,1)$，离开时累积的光学厚度为 $0.275$。\n\n- 案例 4：$\\mathbf{x}_0=[$ $0.3$, $0.3$, $0.3$ $]$, $\\hat{\\boldsymbol{\\omega}}=[$ $0$, $1$, $0$ $]$, $\\tau^\\star=$ $0.05$。在 $(0,0,0)$ 中，$\\kappa_e=$ $2.0$，到 $y=$ $0.5$ 的距离是 $s=$ $0.2$，因此 $\\tau_{\\mathrm{face}}=$ $0.4$。由于 $\\tau^\\star  \\tau_{\\mathrm{face}}$，碰撞发生在当前单元内，距离为 $s_{\\mathrm{col}}=0.05/2.0=$ $0.025$。总距离 $0.025$，在 $(0,0,0)$ 中发生碰撞。\n\n- 案例 5：$\\mathbf{x}_0=[$ $0.8$, $0.9$, $0.1$ $]$, $\\hat{\\boldsymbol{\\omega}}$ 与 $[$ $-1$, $-1$, $0$ $]$ 成比例，归一化为单位长度；$\\tau^\\star=$ $0.1$。在 $(1,1,0)$ 中，$\\kappa_e=$ $0.4$，到下一个面的距离是 $s_x=$ $(0.8-0.5)/|\\omega_x|=$ $0.3\\sqrt{2}$ 和 $s_y=$ $(0.9-0.5)/|\\omega_y|=$ $0.4\\sqrt{2}$，因此第一个面穿越是沿 $x$ 轴，距离为 $s\\approx 0.424264$。到该面对应的光学厚度为 $\\tau_{\\mathrm{face}}\\approx 0.4\\times 0.424264\\approx 0.1697056$。由于 $\\tau^\\star\\tau_{\\mathrm{face}}$，碰撞发生在 $(1,1,0)$ 内部，距离为 $s_{\\mathrm{col}}=0.1/0.4=$ $0.25$。总距离 $0.25$，在 $(1,1,0)$ 中发生碰撞。\n\n实现细节：\n- 将每个输入方向归一化为单位长度，以确保几何和光学计算使用一致的单位。\n- 使用半开域区间以避免上边界的模糊性，并将当前单元初始化为 $i_\\alpha = \\min(\\max(\\lfloor x_{0,\\alpha}/\\Delta \\alpha \\rfloor,0),N_\\alpha-1)$，其中 $\\alpha\\in\\{x,y,z\\}$。\n- 如上实现 DDA 累加器 $t^{\\max}_\\alpha$ 和 $t^{\\Delta}_\\alpha$。跟踪 $s_{\\mathrm{tot}}$、$\\tau_{\\mathrm{rem}}$，并在一步将导致单元索引沿最小化轴移出 $\\{0,1\\}$ 时确定离开。\n- 所需的输出直接来自终止时的状态：碰撞标志、$s_{\\mathrm{tot}}$、累积的光学厚度（对于碰撞等于 $\\tau^\\star$，对于离开等于 $\\tau^\\star - \\tau_{\\mathrm{rem}}$）以及当前单元索引三元组。\n\n根据此推导构建的程序将生成所要求的每个案例的输出，并将它们聚合到指定的单行列表格式中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sample_tau_from_xi(xi: float) - float:\n    # Optical thickness sample via inverse transform: tau = -ln(1 - xi)\n    # Assumes 0  xi  1\n    return -np.log(1.0 - xi)\n\ndef normalize(v: np.ndarray) - np.ndarray:\n    n = np.linalg.norm(v)\n    if n == 0.0:\n        raise ValueError(\"Direction vector must be non-zero.\")\n    return v / n\n\ndef in_bounds(ix, iy, iz, nx, ny, nz):\n    return (0 = ix  nx) and (0 = iy  ny) and (0 = iz  nz)\n\ndef ray_traverse_to_event(x0, w, xi, kappa_grid, L, N):\n    \"\"\"\n    Perform cell-by-cell traversal accumulating optical thickness until collision or exit.\n\n    Parameters:\n        x0: np.array shape (3,), starting position in meters.\n        w: np.array shape (3,), ray direction (will be normalized).\n        xi: float, uniform in (0,1) used to sample optical thickness tau* = -ln(1 - xi).\n        kappa_grid: np.ndarray shape (Nx,Ny,Nz), extinction coefficients in 1/m.\n        L: tuple (Lx,Ly,Lz) domain lengths in meters.\n        N: tuple (Nx,Ny,Nz) number of cells per axis.\n\n    Returns:\n        (collision: bool, distance: float, tau_accum: float, cell_index: [ix,iy,iz])\n    \"\"\"\n    # Normalize direction to ensure distances are in meters.\n    w = normalize(w.astype(float))\n    Lx, Ly, Lz = L\n    Nx, Ny, Nz = N\n    dx = np.array([Lx / Nx, Ly / Ny, Lz / Nz], dtype=float)\n\n    # Initial cell indices (clamp to valid range)\n    ix = int(np.clip(np.floor(x0[0] / dx[0]), 0, Nx - 1))\n    iy = int(np.clip(np.floor(x0[1] / dx[1]), 0, Ny - 1))\n    iz = int(np.clip(np.floor(x0[2] / dx[2]), 0, Nz - 1))\n\n    # Sanity: start must be in bounds\n    if not in_bounds(ix, iy, iz, Nx-1, Ny-1, Nz-1):\n        raise ValueError(\"Start position is not inside the domain.\")\n\n    # Step directions\n    step_x = 0 if w[0] == 0.0 else (1 if w[0]  0.0 else -1)\n    step_y = 0 if w[1] == 0.0 else (1 if w[1]  0.0 else -1)\n    step_z = 0 if w[2] == 0.0 else (1 if w[2]  0.0 else -1)\n\n    # Initialize tMax and tDelta for DDA\n    # Compute distance from current position to next plane along each axis.\n    def initial_tmax(pos, dir_comp, i, d):\n        if dir_comp  0.0:\n            next_plane = (i + 1) * d\n            return (next_plane - pos) / dir_comp\n        elif dir_comp  0.0:\n            next_plane = i * d\n            return (pos - next_plane) / (-dir_comp)\n        else:\n            return np.inf\n\n    def delta_t(dir_comp, d):\n        return (d / abs(dir_comp)) if dir_comp != 0.0 else np.inf\n\n    tMax_x = initial_tmax(x0[0], w[0], ix, dx[0])\n    tMax_y = initial_tmax(x0[1], w[1], iy, dx[1])\n    tMax_z = initial_tmax(x0[2], w[2], iz, dx[2])\n\n    tDelta_x = delta_t(w[0], dx[0])\n    tDelta_y = delta_t(w[1], dx[1])\n    tDelta_z = delta_t(w[2], dx[2])\n\n    # Optical-thickness budget\n    tau_star = sample_tau_from_xi(xi)\n    tau_rem = tau_star\n\n    # Accumulated geometric distance\n    s_tot = 0.0\n\n    eps = 1e-15  # numerical tolerance\n\n    while True:\n        # Current cell extinction\n        kappa = float(kappa_grid[ix, iy, iz])\n\n        # Compute distance to next face from the ray origin and incremental distance in current cell\n        tface_abs = min(tMax_x, tMax_y, tMax_z)\n        s_cell = tface_abs - s_tot\n        if s_cell  -1e-14:\n            # Should not happen; numerical guard\n            s_cell = 0.0\n\n        # Optical thickness to that face\n        tau_face = kappa * s_cell\n\n        # Collision decision\n        if tau_rem = tau_face + eps:\n            # Collision occurs within this cell at distance s_col from current location\n            # Clamp at zero kappa (degenerate) would be problematic; but all kappas are  0 here.\n            if kappa = 0.0:\n                # Degenerate case: no extinction; treat as infinite path in this cell - exit\n                # But not applicable for given test suite.\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            s_col = tau_rem / kappa\n            s_tot += s_col\n            # Accumulated optical thickness equals tau_star at collision\n            return (True, s_tot, tau_star, [ix, iy, iz])\n\n        # Otherwise, advance to the face, decrement remaining tau, and step to the next cell\n        tau_rem -= tau_face\n        s_tot = tface_abs\n\n        # Determine which axis to step along\n        # Use strict comparisons to avoid double-stepping; ties will step the first matching axis.\n        if tMax_x = tMax_y and tMax_x = tMax_z:\n            # Stepping across x-face\n            next_ix = ix + step_x\n            # Check domain exit\n            if next_ix  0 or next_ix = Nx:\n                # Exiting domain from current cell\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            ix = next_ix\n            tMax_x += tDelta_x\n        elif tMax_y = tMax_x and tMax_y = tMax_z:\n            # Stepping across y-face\n            next_iy = iy + step_y\n            if next_iy  0 or next_iy = Ny:\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            iy = next_iy\n            tMax_y += tDelta_y\n        else:\n            # Stepping across z-face\n            next_iz = iz + step_z\n            if next_iz  0 or next_iz = Nz:\n                return (False, s_tot, tau_star - tau_rem, [ix, iy, iz])\n            iz = next_iz\n            tMax_z += tDelta_z\n\n\ndef solve():\n    # Domain and grid specification\n    L = (1.0, 1.0, 1.0)   # meters\n    N = (2, 2, 2)         # cells per axis\n    # Extinction coefficients per cell (Nx,Ny,Nz) in 1/m\n    kappa = np.zeros(N, dtype=float)\n    # Assign values as specified\n    kappa[0,0,0] = 2.0\n    kappa[1,0,0] = 1.0\n    kappa[0,1,0] = 0.2\n    kappa[1,1,0] = 0.4\n    kappa[0,0,1] = 0.5\n    kappa[1,0,1] = 3.0\n    kappa[0,1,1] = 0.1\n    kappa[1,1,1] = 0.2\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Each case: (x0, w, xi)\n        (np.array([0.1, 0.1, 0.1], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float), 0.6321205588285577),\n        (np.array([0.1, 0.1, 0.1], dtype=float), np.array([1.0, 0.0, 0.0], dtype=float), 0.5506710358827784),\n        (np.array([0.25, 0.75, 0.75], dtype=float), np.array([0.0, -1.0, 0.0], dtype=float), 0.6321205588285577),\n        (np.array([0.3, 0.3, 0.3], dtype=float), np.array([0.0, 1.0, 0.0], dtype=float), 0.048770575499285984),\n        (np.array([0.8, 0.9, 0.1], dtype=float), np.array([-1.0, -1.0, 0.0], dtype=float), 0.09516258196404048),\n    ]\n\n    results = []\n    for x0, w, xi in test_cases:\n        collision, dist, tau_accum, cell_idx = ray_traverse_to_event(x0, w, xi, kappa, L, N)\n        # Build per-case result list as specified\n        results.append([bool(collision), float(dist), float(tau_accum), [int(cell_idx[0]), int(cell_idx[1]), int(cell_idx[2])]])\n\n    # Final print statement in the exact required format.\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2508013"}, {"introduction": "蒙特卡罗模拟的效率并非一成不变，理解其性能瓶颈与建立模型同样重要。这个练习通过一个思想实验和理论推导，揭示了介质的一个关键物理参数——单次散射反照率（$ \\omega $）——如何极大地影响“模拟”或“类比”蒙特卡罗方法的计算成本。理解这种关系对于判断何时需要采用高级的方差缩减技术至关重要。[@problem_id:2508048]", "problem": "考虑在一个无限、均匀、各向同性散射介质中进行的稳态、单能辐射输运的模拟蒙特卡罗（MC）模拟。该介质的单次散射反照率为 $\\omega$，其中 $0\\omega1$。在模拟MC方案中，粒子在碰撞之间以由总消光系数决定的指数分布自由程进行传播。在每次碰撞时，粒子要么以 $1-\\omega$ 的概率被吸收，要么以 $\\omega$ 的概率被散射（不终止）。粒子历史在第一次吸收事件时终止。\n\n定义 $N$ 为粒子在终止前经历的碰撞次数，其中 $N$ 只计算散射碰撞，不计算最终的吸收碰撞。从单次散射反照率的定义和连续碰撞结果的独立性出发，通过第一性原理推导期望值 $E[N]$ 作为 $\\omega$ 函数的闭式表达式，不得使用任何专门的快捷公式。然后，根据与 $\\omega$ 的标度关系，简要解释该期望值如何影响在该介质中进行模拟MC时每个粒子历史的计算成本。\n\n请以单一闭式解析表达式的形式给出 $E[N]$ 的最终结果。不需要进行数值取整。由于 $E[N]$ 是无量纲的，因此不需要单位。", "solution": "所述问题是有效的。它在科学上是合理的，是自洽的，并且在辐射输运理论和概率方法的框架内是适定的。我们将从第一性原理出发进行严格推导。\n\n设 $N$ 为一个离散随机变量，表示一个粒子在其历史被吸收终止之前所经历的散射碰撞次数。问题指明，在每次碰撞中，粒子以恒定概率 $\\omega$ 发生散射，并以概率 $1-\\omega$ 被吸收。连续碰撞的结果是统计独立的。\n\n一个粒子要恰好经历 $n$ 次散射碰撞（其中 $n$ 是一个非负整数，$n \\in \\{0, 1, 2, \\dots\\}$），它必须经历一个由 $n$ 次散射事件组成的序列，然后在第 $(n+1)$ 次碰撞时发生一次吸收事件。鉴于这些事件的独立性，这个特定序列的概率是各个事件概率的乘积。\n\n连续 $n$ 次散射事件的概率是 $\\omega^n$。终止吸收事件的概率是 $1-\\omega$。因此，随机变量 $N$ 的概率质量函数（PMF）由下式给出：\n$$ P(N=n) = \\omega^n (1-\\omega) \\quad \\text{对于 } n = 0, 1, 2, \\dots $$\n这是几何分布的定义，它描述了在第一次“成功”（在此情况下为吸收事件）之前“失败”（在此情况下为散射事件）的次数。\n\n$N$ 的期望值，记为 $E[N]$，是通过将每个可能值 $n$ 与其对应概率 $P(N=n)$ 的乘积对所有可能的 $n$ 值求和来计算的：\n$$ E[N] = \\sum_{n=0}^{\\infty} n \\cdot P(N=n) = \\sum_{n=0}^{\\infty} n \\cdot \\omega^n (1-\\omega) $$\n项 $(1-\\omega)$ 相对于求和索引 $n$ 是一个常数，可以被提出来：\n$$ E[N] = (1-\\omega) \\sum_{n=0}^{\\infty} n \\omega^n $$\n当 $n=0$ 时，求和的第一项为 $0 \\cdot \\omega^0 = 0$。因此，求和可以等效地从 $n=1$ 开始：\n$$ E[N] = (1-\\omega) \\sum_{n=1}^{\\infty} n \\omega^n $$\n为计算此无穷级数，我们回顾几何级数的标准公式，该级数在 $|\\omega|  1$ 时收敛。此条件已满足，因为问题陈述中 $0  \\omega  1$。\n$$ \\sum_{n=0}^{\\infty} \\omega^n = \\frac{1}{1-\\omega} $$\n对该方程两边关于 $\\omega$ 求导，可以在求和内部引入前置因子 $n$：\n$$ \\frac{d}{d\\omega} \\left( \\sum_{n=0}^{\\infty} \\omega^n \\right) = \\frac{d}{d\\omega} \\left( \\frac{1}{1-\\omega} \\right) $$\n通过对级数进行逐项微分，我们得到：\n$$ \\sum_{n=0}^{\\infty} \\frac{d}{d\\omega} (\\omega^n) = \\sum_{n=1}^{\\infty} n \\omega^{n-1} $$\n右侧的导数是：\n$$ \\frac{d}{d\\omega} (1-\\omega)^{-1} = -1 \\cdot (1-\\omega)^{-2} \\cdot (-1) = \\frac{1}{(1-\\omega)^2} $$\n将结果相等，得到：\n$$ \\sum_{n=1}^{\\infty} n \\omega^{n-1} = \\frac{1}{(1-\\omega)^2} $$\n为了得到求和形式 $\\sum n\\omega^n$，我们将两边乘以 $\\omega$：\n$$ \\omega \\sum_{n=1}^{\\infty} n \\omega^{n-1} = \\frac{\\omega}{(1-\\omega)^2} $$\n$$ \\sum_{n=1}^{\\infty} n \\omega^n = \\frac{\\omega}{(1-\\omega)^2} $$\n现在我们将此结果代回到 $E[N]$ 的表达式中：\n$$ E[N] = (1-\\omega) \\left( \\frac{\\omega}{(1-\\omega)^2} \\right) $$\n消去分子和分母中的公因子 $(1-\\omega)$，得到散射碰撞次数期望值的最终表达式：\n$$ E[N] = \\frac{\\omega}{1-\\omega} $$\n关于对计算成本的影响，在模拟蒙特卡罗方案中模拟一个粒子历史所需的工作量与该历史所模拟的总事件数成正比。一个历史包含 $N$ 次散射碰撞和一次最终的吸收碰撞，总共 $N+1$ 次碰撞。总碰撞次数的期望值为 $E[N+1] = E[N] + 1$。\n$$ E[N+1] = \\frac{\\omega}{1-\\omega} + 1 = \\frac{\\omega + (1-\\omega)}{1-\\omega} = \\frac{1}{1-\\omega} $$\n因此，每个粒子历史的计算成本与 $(1-\\omega)^{-1}$ 成标度关系。当单次散射反照率 $\\omega$ 趋近于 $1$（即近乎无吸收或“保守”散射介质）时，分母 $(1-\\omega)$ 趋近于 $0$。因此，$E[N]$ 和总碰撞次数期望值 $E[N+1]$ 都发散至无穷大。这表明粒子历史变得极长，需要模拟大量的步骤。计算成本的这种快速增长使得模拟蒙特卡罗方法对于以高反照率介质为特征的问题变得效率极低。", "answer": "$$\\boxed{\\frac{\\omega}{1-\\omega}}$$", "id": "2508048"}]}