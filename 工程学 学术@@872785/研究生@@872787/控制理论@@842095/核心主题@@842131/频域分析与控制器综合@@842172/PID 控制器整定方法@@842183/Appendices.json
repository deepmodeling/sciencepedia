{"hands_on_practices": [{"introduction": "PID控制器的整定效果在很大程度上依赖于过程模型的准确性。本练习将引导你运用一阶灵敏度分析，从解析层面探究模型辨识误差如何传递到控制器参数上。通过这个练习，你将深入理解Ziegler-Nichols整定法则对模型参数变化的敏感性，这是评估任何基于模型的整定方法鲁棒性的基础。", "problem": "一个热过程可以很好地用一阶加纯滞后 (FOPDT) 模型来近似，其传递函数为 $G_{p}(s)=\\dfrac{K \\exp(-L s)}{T s+1}$，其中 $K$ 是稳态增益，$L$ 是表观输入-输出纯滞后时间，$T$ 是主导时间常数。控制器设计为比例-积分-微分 (PID) 控制器，采用基于 FOPDT 参数的经典 Ziegler–Nichols (Z-N) 反应曲线整定法则。假设 $K$ 从稳态数据中精确已知，但由于测量和拟合误差，辨识出的动态参数 $(L,T)$ 受到小的偏差 $(\\Delta L,\\Delta T)$ 的影响。使用一阶灵敏度分析（即全微分和线性化），推导在 PID 控制的 Z-N 反应曲线方法下，由 $(\\Delta L,\\Delta T)$ 引起的整定参数 $(K_{p},T_{i},T_{d})$ 的相对误差的一阶近似。将你的最终结果表示为一个包含 $\\Delta K_{p}/K_{p}$、$\\Delta T_{i}/T_{i}$ 和 $\\Delta T_{d}/T_{d}$ 的单行向量，用 $L$、$T$、$\\Delta L$ 和 $\\Delta T$ 来表示。不需要进行数值计算或四舍五入，最终表达式中不应包含任何单位。", "solution": "一阶加纯滞后 (FOPDT) 模型为 $G_{p}(s)=\\dfrac{K \\exp(-L s)}{T s+1}$，其中过程增益为 $K$，纯滞后时间为 $L$，时间常数为 $T$。在用于比例-积分-微分 (PID) 控制的经典 Ziegler–Nichols (Z-N) 反应曲线整定法则下，整定后的控制器参数是已辨识 FOPDT 参数的确定性函数。我们基于一个基本事实，即这些法则将 $(K_{p},T_{i},T_{d})$ 表示为 $(K,L,T)$ 的平滑函数，并且我们假设过程增益 $K$ 是精确已知的（因此 $\\Delta K=0$）。目标是使用一阶灵敏度分析（即全微分），将小的辨识误差 $(\\Delta L,\\Delta T)$ 传播到对应的微小变化 $(\\Delta K_{p},\\Delta T_{i},\\Delta T_{d})$ 中。\n\n对于一个平滑依赖于 $L$ 和 $T$ 的标量函数 $f(L,T)$，由微小变化 $(\\Delta L,\\Delta T)$ 引起的一阶变动由全微分给出\n$$\n\\Delta f \\approx \\frac{\\partial f}{\\partial L}\\,\\Delta L+\\frac{\\partial f}{\\partial T}\\,\\Delta T,\n$$\n对应的相对变动为\n$$\n\\frac{\\Delta f}{f}\\approx \\frac{1}{f}\\frac{\\partial f}{\\partial L}\\,\\Delta L+\\frac{1}{f}\\frac{\\partial f}{\\partial T}\\,\\Delta T.\n$$\n\n应用于 FOPDT 过程的 PID 控制器的经典 Ziegler–Nichols 反应曲线法则可以写为\n$$\nK_{p}=\\alpha\\,\\frac{T}{K\\,L},\\qquad T_{i}=\\beta\\,L,\\qquad T_{d}=\\gamma\\,L,\n$$\n其中 $\\alpha$、$\\beta$ 和 $\\gamma$ 是正常数。对于传统的 Ziegler–Nichols PID 设置，这些常数是\n$$\n\\alpha=1.2,\\qquad \\beta=2,\\qquad \\gamma=0.5.\n$$\n我们进行符号推导；在相对灵敏度中，除了参数仅依赖于单个变量的情况外，这些常数将被消去。\n\n考虑 $K_{p}(L,T)=\\alpha\\,\\dfrac{T}{K\\,L}$。其偏导数为\n$$\n\\frac{\\partial K_{p}}{\\partial T}=\\frac{\\alpha}{K\\,L}=\\frac{K_{p}}{T},\\qquad\n\\frac{\\partial K_{p}}{\\partial L}=-\\alpha\\,\\frac{T}{K\\,L^{2}}=-\\frac{K_{p}}{L}.\n$$\n因此一阶变化是\n$$\n\\Delta K_{p}\\approx \\frac{K_{p}}{T}\\,\\Delta T-\\frac{K_{p}}{L}\\,\\Delta L,\n$$\n相对变化为\n$$\n\\frac{\\Delta K_{p}}{K_{p}}\\approx \\frac{\\Delta T}{T}-\\frac{\\Delta L}{L}.\n$$\n\n接下来，$T_{i}(L)=\\beta\\,L$ 仅依赖于 $L$，所以\n$$\n\\frac{\\partial T_{i}}{\\partial L}=\\beta=\\frac{T_{i}}{L},\n$$\n因此\n$$\n\\Delta T_{i}\\approx \\frac{T_{i}}{L}\\,\\Delta L\\quad\\Rightarrow\\quad \\frac{\\Delta T_{i}}{T_{i}}\\approx \\frac{\\Delta L}{L}.\n$$\n\n类似地，$T_{d}(L)=\\gamma\\,L$ 得出\n$$\n\\frac{\\partial T_{d}}{\\partial L}=\\gamma=\\frac{T_{d}}{L},\n$$\n所以\n$$\n\\Delta T_{d}\\approx \\frac{T_{d}}{L}\\,\\Delta L\\quad\\Rightarrow\\quad \\frac{\\Delta T_{d}}{T_{d}}\\approx \\frac{\\Delta L}{L}.\n$$\n\n综合这些结果，一阶相对误差向量为\n$$\n\\begin{pmatrix}\n\\dfrac{\\Delta K_{p}}{K_{p}} \\dfrac{\\Delta T_{i}}{T_{i}} \\dfrac{\\Delta T_{d}}{T_{d}}\n\\end{pmatrix}\n\\approx\n\\begin{pmatrix}\n\\dfrac{\\Delta T}{T}-\\dfrac{\\Delta L}{L} \\dfrac{\\Delta L}{L} \\dfrac{\\Delta L}{L}\n\\end{pmatrix}.\n$$\n只要函数依赖关系 $K_{p}\\propto T/L$、$T_{i}\\propto L$ 和 $T_{d}\\propto L$ 成立，该表达式就与 $\\alpha$、$\\beta$ 和 $\\gamma$ 的具体数值无关，而经典的 Ziegler–Nichols 反应曲线 PID 法则确实满足这些关系。假设 $\\Delta K=0$ 对于消除由 $K$ 的不确定性带来的任何额外影响至关重要；如果 $\\Delta K\\neq 0$，则应在 $\\Delta K_{p}/K_{p}$ 中加上 $-(\\Delta K/K)$ 这一项。", "answer": "$$\\boxed{\\begin{pmatrix}\\dfrac{\\Delta K_{p}}{K_{p}}  \\dfrac{\\Delta T_{i}}{T_{i}}  \\dfrac{\\Delta T_{d}}{T_{d}}\\end{pmatrix}=\\begin{pmatrix}\\dfrac{\\Delta T}{T}-\\dfrac{\\Delta L}{L}  \\dfrac{\\Delta L}{L}  \\dfrac{\\Delta L}{L}\\end{pmatrix}}$$", "id": "2731985"}, {"introduction": "在控制器参数整定完成后，评估系统对过程特性变化的鲁棒性至关重要。本练习设定了一个实际场景：过程增益在控制器投运后发生了变化，你需要计算闭环系统新的增益裕度。这个实践将强化你运用频率响应法进行鲁棒性分析的能力，并将模型不确定性与闭环稳定性直接联系起来[@problem_id:2731985]。", "problem": "一个单输入单输出过程可由一阶加死区时间 (FOPDT) 模型很好地近似，其传递函数为 $P(s) = \\dfrac{K \\exp(-L s)}{T s + 1}$。标称反应曲线辨识给出 $K = K_{0}$、$L = 1$ 和 $T = 4$，其中 $K_{0} = 2$。一个比例-积分 (PI) 控制器使用基于标称模型的 Ziegler–Nichols (ZN) 开环阶跃响应法进行整定。控制器实施后，过程增益增加了 $20\\%$（即 $K$ 变为 $1.2 K_{0}$），而 $L$ 和 $T$ 保持不变。\n\n从环路传递函数、频率响应和增益裕度（定义为开环相位等于 $-\\pi$ 时的相位交越频率处的开环幅值的倒数）的定义出发，确定在增益增加的过程上使用固定的 PI 控制器时，闭环系统最终的增益裕度。假设角频率以弧度/秒为单位。将最终数值答案四舍五入到四位有效数字。最终答案表示为一个无单位的纯数字。", "solution": "步骤 1：确定 PI 控制器参数。\n控制器使用基于*标称*FOPDT模型参数（$K_0=2$、$L=1$ 和 $T=4$）的 Ziegler-Nichols 开环法进行整定。\n对于 PI 控制器，ZN 整定规则为：\n比例增益：$K_p = \\dfrac{0.9 T}{K_0 L}$\n积分时间：$T_i = \\dfrac{L}{0.3} = \\dfrac{10}{3} L$\n\n代入标称值：\n$K_p = \\dfrac{0.9 \\times 4}{2 \\times 1} = \\dfrac{3.6}{2} = 1.8$\n$T_i = \\dfrac{10}{3} \\times 1 = \\dfrac{10}{3}$\n\nPI 控制器的传递函数为 $C(s) = K_p \\left(1 + \\dfrac{1}{T_i s}\\right)$。\n$C(s) = 1.8 \\left(1 + \\dfrac{1}{(10/3) s}\\right) = 1.8 \\left(1 + \\dfrac{0.3}{s}\\right) = 1.8 \\dfrac{s + 0.3}{s}$\n\n步骤 2：定义新的开环传递函数。\n控制器实施后，过程增益增加了 $20\\%$。新的增益为 $K' = 1.2 K_0 = 1.2 \\times 2 = 2.4$。参数 $L=1$ 和 $T=4$ 保持不变。\n新的过程传递函数为 $P'(s) = \\dfrac{K' \\exp(-L s)}{T s + 1} = \\dfrac{2.4 \\exp(-s)}{4s + 1}$。\n\n带有固定控制器和修改后过程的系统的开环传递函数为 $G_{OL}(s) = C(s) P'(s)$。\n$G_{OL}(s) = \\left(1.8 \\dfrac{s + 0.3}{s}\\right) \\left(\\dfrac{2.4 \\exp(-s)}{4s + 1}\\right) = \\dfrac{4.32 (s + 0.3) \\exp(-s)}{s(4s + 1)}$\n\n步骤 3：求解相位交越频率 $\\omega_{pc}$。\n相位交越频率 $\\omega_{pc}$ 是开环频率响应的相位等于 $-\\pi$ 弧度时的频率。\n通过令 $s = j\\omega$ 得到频率响应：\n$G_{OL}(j\\omega) = \\dfrac{4.32 (j\\omega + 0.3) \\exp(-j\\omega)}{j\\omega(4j\\omega + 1)}$\n\n$G_{OL}(j\\omega)$ 的相角是各项相位的总和：\n$\\angle G_{OL}(j\\omega) = \\angle(4.32) + \\angle(j\\omega + 0.3) + \\angle(\\exp(-j\\omega)) - \\angle(j\\omega) - \\angle(4j\\omega + 1)$\n$\\angle G_{OL}(j\\omega) = 0 + \\arctan\\left(\\dfrac{\\omega}{0.3}\\right) - \\omega - \\dfrac{\\pi}{2} - \\arctan(4\\omega)$\n\n我们将此表达式设为 $-\\pi$ 以求解 $\\omega = \\omega_{pc}$：\n$\\arctan\\left(\\dfrac{\\omega_{pc}}{0.3}\\right) - \\omega_{pc} - \\dfrac{\\pi}{2} - \\arctan(4\\omega_{pc}) = -\\pi$\n整理各项得到关于 $\\omega_{pc}$ 的超越方程：\n$\\dfrac{\\pi}{2} = \\omega_{pc} + \\arctan(4\\omega_{pc}) - \\arctan\\left(\\dfrac{\\omega_{pc}}{0.3}\\right)$\n该方程必须通过数值方法求解。令 $f(\\omega) = \\omega + \\arctan(4\\omega) - \\arctan(\\frac{10}{3}\\omega) - \\frac{\\pi}{2}$。我们求解 $f(\\omega) = 0$ 的根。\n该方程的数值解为 $\\omega_{pc} \\approx 1.5387$ rad/s。\n\n步骤 4：计算相位交越频率处的幅值。\n开环频率响应的幅值为：\n$|G_{OL}(j\\omega)| = \\dfrac{|4.32| |j\\omega + 0.3| |\\exp(-j\\omega)|}{|j\\omega| |4j\\omega + 1|} = \\dfrac{4.32 \\sqrt{\\omega^2 + 0.3^2}}{\\omega \\sqrt{(4\\omega)^2 + 1^2}}$\n$|G_{OL}(j\\omega)| = \\dfrac{4.32 \\sqrt{\\omega^2 + 0.09}}{\\omega \\sqrt{16\\omega^2 + 1}}$\n\n代入 $\\omega = \\omega_{pc} = 1.5387$：\n$|G_{OL}(j\\omega_{pc})| = \\dfrac{4.32 \\sqrt{(1.5387)^2 + 0.09}}{1.5387 \\sqrt{16(1.5387)^2 + 1}}$\n$|G_{OL}(j\\omega_{pc})| = \\dfrac{4.32 \\sqrt{2.3676 + 0.09}}{1.5387 \\sqrt{16(2.3676) + 1}} = \\dfrac{4.32 \\sqrt{2.4576}}{1.5387 \\sqrt{37.8816 + 1}}$\n$|G_{OL}(j\\omega_{pc})| = \\dfrac{4.32 \\times 1.5676}{1.5387 \\times \\sqrt{38.8816}} = \\dfrac{6.7721}{1.5387 \\times 6.2355} \\approx \\dfrac{6.7721}{9.5934}$\n$|G_{OL}(j\\omega_{pc})| \\approx 0.70591$\n\n步骤 5：计算增益裕度。\n增益裕度定义为该幅值的倒数：\n$GM = \\dfrac{1}{|G_{OL}(j\\omega_{pc})|} = \\dfrac{1}{0.70591} \\approx 1.41662$\n\n最后，根据问题陈述的要求，将结果四舍五入到四位有效数字，得到 $1.417$。", "answer": "$$\\boxed{1.417}$$", "id": "2731986"}, {"introduction": "最终，控制系统的性能需要在时域响应中得到验证。本练习将视角从频率域转向时域，并关注工业中常见的积分加延迟（IPDT）过程。你将首先为这类特定对象推导Ziegler-Nichols整定参数，然后通过编程仿真来评估闭环系统在阶跃响应下的积分平方误差（ISE）和超调量，从而直观地感受整定参数对系统动态性能的影响。", "problem": "给定一个单位反馈下的积分加纯滞后 (IPDT) 过程，其对象传递函数为 $G_{p}(s) = \\dfrac{K \\, e^{-L s}}{s}$，其中 $K  0$ 为稳态增益，$L  0$ 为纯滞后时间（单位：秒）。控制器为比例-积分 (PI) 控制器 $C(s) = K_{p} \\left(1 + \\dfrac{1}{T_{i} s}\\right)$。控制器参数将采用闭环 Ziegler–Nichols (ZN) 方法，根据极限增益 $K_{\\mathrm{u}}$ 和极限周期 $P_{\\mathrm{u}}$ 进行选择。\n\n从回路稳定性的基本频域定义以及临界不稳定状态下的相位/幅值条件（Nyquist 观点）出发，推导该 IPDT 对象的极限频率 $\\omega_{\\mathrm{u}}$ 和 Ziegler–Nichols 参数的表达式。在推导中，请使用以下经过充分检验的事实作为基础：\n- 积分器的频率响应在 $s = j \\omega$ 处贡献 $-\\dfrac{\\pi}{2}$ 的相位和 $\\dfrac{1}{\\omega}$ 的幅值。\n- 时间延迟贡献 $-\\omega L$ 弧度的相位和 $1$ 的幅值。\n- 闭环 Ziegler–Nichols 方法通过将一个纯比例控制回路驱动至持续振荡来定义 $K_{\\mathrm{u}}$ 和 $P_{\\mathrm{u}}$，此时开环频率响应满足 $-\\pi$ 弧度的相角和 $1$ 的幅值。\n- 根据 $K_{\\mathrm{u}}$ 和 $P_{\\mathrm{u}}$ 计算的 Ziegler–Nichols PI 参数设置为 $K_{p} = 0.45 \\, K_{\\mathrm{u}}$ 和 $T_{i} = \\dfrac{P_{\\mathrm{u}}}{1.2}$。\n\n在推导出用 $K$ 和 $L$ 表示的 $K_{p}$ 和 $T_{i}$ 后，对单位反馈闭环系统在 $t \\ge 0$ 时输入单位阶跃指令 $r(t) = 1$ 的情况进行仿真（初始条件为零），并评估误差平方积分 (ISE)，\n$$\n\\mathrm{ISE} = \\int_{0}^{T_{\\text{end}}} e(t)^{2} \\, dt, \\quad e(t) = r(t) - y(t),\n$$\n其中 $y(t)$ 是过程输出。使用一种数值上稳健的时域仿真方法，该方法能精确处理纯滞后时间 $L$ 或使用精确近似。如果使用近似，请在解题方案中说明其合理性，并确保其与采样间隔一致。时间单位使用秒。将 ISE 报告为四舍五入到小数点后5位的浮点数值。\n\n此外，使用一个简单的、可解释的数值标准来量化进取性与鲁棒性。将超调分数定义为\n$$\nM_{p} = \\max\\{0, \\max_{t \\in [0, T_{\\text{end}}]} y(t) - 1\\}。\n$$\n如果 $M_{p}  0.2$，则将闭环系统分类为进取型，否则为鲁棒型。将此分类报告为一个整数标志 $A$，进取型为 $A=1$，鲁棒型为 $A=0$。\n\n测试套件：\n对于下方的每对参数 $(K, L)$，计算并返回单位阶跃输入下的 $[\\mathrm{ISE}, A]$ 对。\n- 案例 1：$K = 1.0$， $L = 1.0$。\n- 案例 2：$K = 1.0$， $L = 2.0$。\n- 案例 3：$K = 0.5$， $L = 1.0$。\n- 案例 4：$K = 2.0$， $L = 1.0$。\n\n仿真要求：\n- 使用固定的时间步长 $\\Delta t$ 来解析纯滞后时间 $L$；一个实际的选择是 $\\Delta t \\le \\dfrac{L}{400}$，并设置上限如 $\\Delta t \\le 10^{-3}$ 秒。\n- 使用 $T_{\\text{end}} = 30 L$ 秒来捕捉瞬态响应和趋于稳态的过程。\n- 通过数值上一致的方法实现纯滞后，例如使用带有线性插值的先进先出缓冲器来处理子采样延迟。\n- 对对象积分器和控制器积分器使用 Euler 积分法，或在所选 $\\Delta t$ 下具有同等清晰度和稳定性的其他方法。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个结果本身都是一个双元素列表 $[\\mathrm{ISE}, A]$，顺序与测试套件中的案例顺序相同。例如：$[[x_{1},a_{1}],[x_{2},a_{2}],[x_{3},a_{3}],[x_{4},a_{4}]]$，其中每个 $x_{i}$ 是四舍五入到小数点后5位的 ISE 值，每个 $a_{i}$ 是 $0$ 或 $1$。", "solution": "该问题要求使用 Ziegler-Nichols (ZN) 闭环整定方法，为积分加纯滞后 (IPDT) 过程推导比例-积分 (PI) 控制器参数，然后通过时域仿真来评估所得控制系统的性能。经检验，该问题陈述具有科学依据、提法得当且客观。我们着手求解。\n\n首先，我们推导控制器参数的解析表达式。该过程由传递函数 $G_{p}(s) = \\dfrac{K e^{-L s}}{s}$ 描述，其中增益 $K  0$，纯滞后时间 $L  0$。ZN 闭环方法要求找到极限增益 $K_{\\mathrm{u}}$ 和极限周期 $P_{\\mathrm{u}}$。这需要将过程置于纯比例控制 $C(s) = K_{c}$ 下，并找到能引起持续振荡的增益 $K_{c} = K_{\\mathrm{u}}$。\n\n该测试的开环传递函数为 $G_{OL}(s) = C(s)G_{p}(s) = K_{c} \\dfrac{K e^{-L s}}{s}$。\n为了找到临界稳定点，我们通过代入 $s = j \\omega$ 来分析频率响应，其中 $\\omega$ 是角频率。\n$$\nG_{OL}(j\\omega) = K_{c} \\dfrac{K e^{-j\\omega L}}{j\\omega}\n$$\n频率响应的幅值和相角分别为：\n$$\n|G_{OL}(j\\omega)| = \\left| K_{c} \\dfrac{K}{j\\omega} e^{-j\\omega L} \\right| = K_{c} \\dfrac{K}{\\omega} |e^{-j\\omega L}| = \\dfrac{K_{c} K}{\\omega}\n$$\n$$\n\\angle G_{OL}(j\\omega) = \\angle K_{c} + \\angle K + \\angle e^{-j\\omega L} - \\angle j\\omega\n$$\n由于 $K_{c}  0$ 和 $K  0$，它们的相角为 $0$。积分器 $1/j\\omega$ 的相角为 $-\\pi/2$ 弧度，时间延迟 $e^{-j\\omega L}$ 的相角为 $-\\omega L$ 弧度。\n$$\n\\angle G_{OL}(j\\omega) = 0 + 0 - \\omega L - \\dfrac{\\pi}{2} = -\\left(\\omega L + \\dfrac{\\pi}{2}\\right)\n$$\n根据 Nyquist 稳定性判据，当频率响应轨迹穿过临界点 $(-1, 0j)$ 时，系统出现持续振荡，这对应于幅值为 $1$ 和相角为 $-\\pi$ 弧度。设发生这种情况时的频率为极限频率 $\\omega_{\\mathrm{u}}$。\n\n相位条件是：\n$$\n\\angle G_{OL}(j\\omega_{\\mathrm{u}}) = -\\pi \\implies -\\left(\\omega_{\\mathrm{u}} L + \\dfrac{\\pi}{2}\\right) = -\\pi\n$$\n求解 $\\omega_{\\mathrm{u}}$ 得：\n$$\n\\omega_{\\mathrm{u}} L = \\dfrac{\\pi}{2} \\implies \\omega_{\\mathrm{u}} = \\dfrac{\\pi}{2L}\n$$\n极限周期 $P_{\\mathrm{u}}$ 与 $\\omega_{\\mathrm{u}}$ 的关系为 $P_{\\mathrm{u}} = 2\\pi / \\omega_{\\mathrm{u}}$。\n$$\nP_{\\mathrm{u}} = \\dfrac{2\\pi}{\\pi / (2L)} = 4L\n$$\n幅值条件，当 $K_{c} = K_{\\mathrm{u}}$ 时，是：\n$$\n|G_{OL}(j\\omega_{\\mathrm{u}})| = 1 \\implies \\dfrac{K_{\\mathrm{u}} K}{\\omega_{\\mathrm{u}}} = 1\n$$\n求解极限增益 $K_{\\mathrm{u}}$ 得：\n$$\nK_{\\mathrm{u}} = \\dfrac{\\omega_{\\mathrm{u}}}{K} = \\dfrac{\\pi / (2L)}{K} = \\dfrac{\\pi}{2KL}\n$$\n在确定了 $K_{\\mathrm{u}}$ 和 $P_{\\mathrm{u}}$ 之后，使用指定的 ZN 整定规则计算 PI 控制器参数 $K_{p}$ 和 $T_{i}$：\n$$\nK_{p} = 0.45 K_{\\mathrm{u}} = 0.45 \\left( \\dfrac{\\pi}{2KL} \\right) = \\dfrac{0.45\\pi}{2KL}\n$$\n$$\nT_{i} = \\dfrac{P_{\\mathrm{u}}}{1.2} = \\dfrac{4L}{1.2} = \\dfrac{10}{3}L\n$$\n$K_{p}$ 和 $T_{i}$ 的这些表达式仅是对象参数 $K$ 和 $L$ 的函数。\n\n接下来，我们定义用于仿真闭环系统对单位阶跃输入 $r(t)=1$ 响应的数值方法。系统处于单位反馈下，因此误差信号为 $e(t) = r(t) - y(t)$，其中 $y(t)$ 是对象输出。\nPI 控制器输出 $u(t)$ 由下式给出：\n$$\nu(t) = K_{p}e(t) + \\dfrac{K_{p}}{T_{i}}\\int_{0}^{t} e(\\tau)d\\tau\n$$\n对象行为由带时间延迟的微分方程描述：\n$$\n\\dfrac{dy(t)}{dt} = K u(t-L)\n$$\n我们使用带有固定时间步长 $\\Delta t$ 的显式 Euler 方法将这些方程离散化以进行数值仿真。设 $y_k$、$e_k$ 和 $u_k$ 表示在时间 $t_k = k\\Delta t$ 时变量的值。控制器中的积分项由一个状态变量 $x_{I}$ 表示，该变量在每个步骤中更新。\n\n离散时间仿真算法如下：\n初始化状态：$y_0 = 0$, $x_{I,0} = 0$。\n对于每个时间步 $k = 0, 1, 2, \\dots$：\n1. 计算误差：$e_k = 1 - y_k$。\n2. 计算控制器输出：$u_k = K_p e_k + \\dfrac{K_p}{T_i} x_{I,k}$。将 $u_k$ 存储在历史缓冲器中。\n3. 更新下一步的控制器积分器状态：$x_{I,k+1} = x_{I,k} + \\Delta t \\cdot e_k$。\n4. 确定延迟的控制输入 $u(t_k - L)$。以样本数表示的延迟为 $d = L/\\Delta t$。如果 $d$ 不是整数，则需要在过去的 $u$ 样本之间进行线性插值。值 $u(t_k-L) = u((k-d)\\Delta t)$ 使用存储的值 $u_{k-d_{\\text{int}}-1}$ 和 $u_{k-d_{\\text{int}}}$ 进行插值，其中 $d_{\\text{int}} = \\lfloor d \\rfloor$ 且 $d_{\\text{frac}} = d - d_{\\text{int}}$。插值后的值为 $u_{\\text{delayed}, k} = (1 - d_{\\text{frac}})u_{k-d_{\\text{int}}} + d_{\\text{frac}}u_{k-d_{\\text{int}}-1}$。对于 $t_k  L$，有 $u_{\\text{delayed},k} = 0$。\n5. 更新下一步的对象输出：$y_{k+1} = y_k + \\Delta t \\cdot K \\cdot u_{\\text{delayed},k}$。\n\n仿真参数根据问题陈述设置：$\\Delta t = \\min(L/400, 10^{-3})$ 和 $T_{\\text{end}} = 30L$。\n\n最后，从仿真结果中计算性能指标。\n误差平方积分 (ISE) 通过求和来近似：\n$$\n\\mathrm{ISE} = \\int_{0}^{T_{\\text{end}}} e(t)^{2} \\, dt \\approx \\sum_{k=0}^{N-1} e_k^2 \\Delta t, \\quad \\text{where } N = \\frac{T_{\\text{end}}}{\\Delta t}\n$$\n超调分数 $M_p$ 计算如下：\n$$\nM_{p} = \\max\\{0, \\max_{k} y_k - 1\\}\n$$\n如果 $M_p  0.2$，则系统响应被分类为进取型 ($A=1$)，否则为鲁棒型 ($A=0$)。\n\n实施此完整过程以评估指定的测试案例。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the control theory problem by deriving ZN parameters,\n    simulating the closed-loop system, and evaluating performance metrics.\n    \"\"\"\n\n    def simulate(K, L):\n        \"\"\"\n        Simulates the closed-loop response of the IPDT process with a PI controller.\n\n        Args:\n            K (float): The process gain.\n            L (float): The process dead time.\n\n        Returns:\n            list: A list containing [ISE, A], where ISE is the Integral of\n                  Squared Error and A is the aggressiveness flag (0 or 1).\n        \"\"\"\n        # 1. Derive controller parameters based on the ZN method\n        Ku = math.pi / (2 * K * L)\n        Pu = 4 * L\n        Kp = 0.45 * Ku\n        Ti = Pu / 1.2\n\n        # 2. Setup simulation parameters\n        dt = min(L / 400.0, 0.001)\n        Tend = 30 * L\n        num_steps = int(Tend / dt)\n\n        # 3. Initialize arrays for simulation variables\n        t = np.linspace(0, Tend, num_steps + 1)\n        y = np.zeros(num_steps + 1)  # Plant output\n        u = np.zeros(num_steps + 1)  # Controller output\n        e = np.zeros(num_steps + 1)  # Error signal\n        xi = np.zeros(num_steps + 1) # Controller integrator state\n\n        y[0] = 0.0\n        xi[0] = 0.0\n        \n        # Dead time parameters\n        # In all test cases, L/dt is an integer, so d_frac is 0.\n        # The logic is kept general for correctness.\n        d = L / dt\n        d_int = int(np.floor(d))\n        d_frac = d - d_int\n\n        # 4. Run the simulation loop\n        for k in range(num_steps):\n            # Calculate error\n            e[k] = 1.0 - y[k]\n\n            # Calculate controller output\n            u[k] = Kp * e[k] + (Kp / Ti) * xi[k]\n\n            # Update controller integrator state for next step\n            xi[k+1] = xi[k] + dt * e[k]\n\n            # Determine delayed control input with linear interpolation\n            u_delayed = 0.0\n            # Indices for interpolation are based on two points in the past\n            idx1 = k - d_int\n            idx2 = k - d_int - 1\n\n            if idx2 >= 0:\n                # Standard case: interpolate between two past points\n                u_delayed = (1 - d_frac) * u[idx1] + d_frac * u[idx2]\n            elif idx1 >= 0:\n                # Edge case at the start of the simulation after first delay period\n                # Assumes u=0 for t0\n                u_delayed = (1 - d_frac) * u[idx1]\n\n            # Update plant output for next step\n            y[k+1] = y[k] + dt * K * u_delayed\n\n        # Fill the last error value for completeness\n        e[num_steps] = 1.0 - y[num_steps]\n\n        # 5. Calculate performance metrics\n        # ISE is calculated over the interval [0, Tend), corresponding to e[0]...e[num_steps-1]\n        ise = dt * np.sum(e[:num_steps]**2)\n        \n        # Overshoot fraction\n        max_y = np.max(y)\n        Mp = max(0.0, max_y - 1.0)\n\n        # Aggressiveness flag\n        A = 1 if Mp > 0.2 else 0\n\n        return [round(ise, 5), A]\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        (1.0, 1.0),  # Case 1\n        (1.0, 2.0),  # Case 2\n        (0.5, 1.0),  # Case 3\n        (2.0, 1.0),  # Case 4\n    ]\n\n    results = []\n    for K, L in test_cases:\n        result = simulate(K, L)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2731954"}]}