{"hands_on_practices": [{"introduction": "这个练习将引导你直接应用阿克曼公式。通过一个简单的二阶系统，你将巩固对核心计算步骤的理解，包括构建可控性矩阵、确定期望特征多项式，以及最终计算出增益矩阵 $K$。这次实践[@problem_id:1599742]是解决更复杂极点配置问题的基础。", "problem": "一个线性时不变系统由状态空间模型 $\\dot{\\mathbf{x}}(t) = A \\mathbf{x}(t) + B u(t)$ 描述，其中 $\\mathbf{x}(t)$ 是状态向量，$u(t)$ 是标量输入。系统矩阵由下式给出：\n$$\nA = \\begin{pmatrix} 0  1 \\\\ 4  1 \\end{pmatrix}, \\quad B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n需要设计一个状态反馈控制器，其控制律为 $u(t) = -K \\mathbf{x}(t)$，其中 $K = \\begin{pmatrix} k_1  k_2 \\end{pmatrix}$ 是状态反馈增益矩阵。目标是将闭环系统的极点配置在 $s = -5$ 和 $s = -6$。\n\n增益矩阵 $K$ 可以使用阿克曼 (Ackermann) 公式确定，对于单输入、$n$ 阶系统，该公式为：\n$$\nK = \\begin{pmatrix} 0  \\dots  0  1 \\end{pmatrix} \\mathcal{C}^{-1} \\phi(A)\n$$\n其中 $\\mathcal{C}$ 是系统的能控性矩阵，$\\phi(s)$ 是期望的闭环特征多项式。\n\n确定状态反馈增益矩阵 $K$。将您的答案表示为行矩阵。", "solution": "给定 LTI 系统 $\\dot{\\mathbf{x}}(t) = A \\mathbf{x}(t) + B u(t)$，其中 $A = \\begin{pmatrix} 0  1 \\\\ 4  1 \\end{pmatrix}$ 且 $B = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$，以及状态反馈律 $u(t) = -K \\mathbf{x}(t)$，其中 $K = \\begin{pmatrix} k_{1}  k_{2} \\end{pmatrix}$。在状态反馈下，闭环系统矩阵为 $A_{\\text{cl}} = A - B K$。极点配置的目标是将闭环特征值分配到 $s = -5$ 和 $s = -6$，因此期望的特征多项式为 $\\phi(s) = (s + 5)(s + 6) = s^{2} + 11 s + 30$。\n\n首先，验证阿克曼公式所要求的能控性。能控性矩阵为\n$$\n\\mathcal{C} = \\begin{pmatrix} B  A B \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 1  1 \\end{pmatrix},\n$$\n其行列式为 $\\det(\\mathcal{C}) = -1 \\neq 0$，因此系统是能控的。\n\n使用 $A_{\\text{cl}}$ 的特征多项式直接匹配法，计算 $A_{\\text{cl}} = A - B K$：\n$$\nB K = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\begin{pmatrix} k_{1}  k_{2} \\end{pmatrix} = \\begin{pmatrix} 0  0 \\\\ k_{1}  k_{2} \\end{pmatrix},\n$$\n$$\nA_{\\text{cl}} = \\begin{pmatrix} 0  1 \\\\ 4  1 \\end{pmatrix} - \\begin{pmatrix} 0  0 \\\\ k_{1}  k_{2} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 4 - k_{1}  1 - k_{2} \\end{pmatrix}.\n$$\n$A_{\\text{cl}}$ 的特征多项式为\n$$\n\\det\\!\\left(s I - A_{\\text{cl}}\\right) = \\det\\!\\begin{pmatrix} s  -1 \\\\ k_{1} - 4  s - 1 + k_{2} \\end{pmatrix} = s\\left(s - 1 + k_{2}\\right) + \\left(k_{1} - 4\\right),\n$$\n展开为\n$$\ns^{2} + (k_{2} - 1) s + (k_{1} - 4).\n$$\n与期望的多项式 $s^{2} + 11 s + 30$ 进行匹配，得到方程组\n$$\nk_{2} - 1 = 11, \\quad k_{1} - 4 = 30,\n$$\n因此\n$$\nk_{2} = 12, \\quad k_{1} = 34.\n$$\n\n等效地，应用阿克曼公式 $K = \\begin{pmatrix} 0  1 \\end{pmatrix} \\mathcal{C}^{-1} \\phi(A)$ 可以进行一致性检查。计算\n$$\n\\mathcal{C}^{-1} = \\frac{1}{-1} \\begin{pmatrix} 1  -1 \\\\ -1  0 \\end{pmatrix} = \\begin{pmatrix} -1  1 \\\\ 1  0 \\end{pmatrix},\n$$\n$$\nA^{2} = \\begin{pmatrix} 0  1 \\\\ 4  1 \\end{pmatrix}^{2} = \\begin{pmatrix} 4  1 \\\\ 4  5 \\end{pmatrix},\n$$\n$$\n\\phi(A) = A^{2} + 11 A + 30 I = \\begin{pmatrix} 4  1 \\\\ 4  5 \\end{pmatrix} + \\begin{pmatrix} 0  11 \\\\ 44  11 \\end{pmatrix} + \\begin{pmatrix} 30  0 \\\\ 0  30 \\end{pmatrix} = \\begin{pmatrix} 34  12 \\\\ 48  46 \\end{pmatrix}.\n$$\n然后\n$$\n\\begin{pmatrix} 0  1 \\end{pmatrix} \\mathcal{C}^{-1} = \\begin{pmatrix} 1  0 \\end{pmatrix}, \\quad K = \\begin{pmatrix} 1  0 \\end{pmatrix} \\phi(A) = \\begin{pmatrix} 34  12 \\end{pmatrix}.\n$$\n\n因此，所需的状态反馈增益矩阵为行矩阵 $\\begin{pmatrix} 34  12 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix}34  12\\end{pmatrix}}$$", "id": "1599742"}, {"introduction": "在掌握了基本计算之后，下一个问题将通过一个思想实验来加深你的理论理解。通过考虑期望极点与系统开环极点相同的特殊情况，你将探索阿克曼公式与凯莱-哈密顿定理之间的深刻联系[@problem_id:1556685]。这个练习揭示了一个直观的结论：当系统极点已经处于期望位置时，不需要任何控制作用。", "problem": "考虑一个由状态空间表示 $\\dot{x}(t) = Ax(t) + Bu(t)$ 描述的通用 $n$ 阶、可控、线性时不变 (LTI)、单输入单输出 (SISO) 系统，其中 $x \\in \\mathbb{R}^{n}$ 是状态向量，$u \\in \\mathbb{R}$ 是控制输入，$A$ 是 $n \\times n$ 的状态矩阵，$B$ 是 $n \\times 1$ 的输入矩阵。该系统的开环极点是矩阵 $A$ 的特征值，即开环特征多项式 $\\alpha(s) = \\det(sI-A)$ 的根。\n\n应用形式为 $u(t) = -Kx(t)$ 的状态反馈控制律，其中 $K$ 是一个 $1 \\times n$ 的反馈增益行向量。该控制律的目标是将闭环系统（其极点由矩阵 $(A - BK)$ 的特征值给出）的极点配置到期望的位置。期望的极点位置由期望特征多项式 $\\alpha_d(s)$ 的根指定。\n\n阿克曼公式提供了一种计算实现期望极点配置的增益矩阵 $K$ 的方法。该公式为：\n$$K = [0 \\ 0 \\ \\dots \\ 1] \\mathcal{C}^{-1} \\alpha_d(A)$$\n其中 $\\mathcal{C}$ 是系统对 $(A, B)$ 的 $n \\times n$ 可控性矩阵，而 $\\alpha_d(A)$ 是将期望特征多项式 $\\alpha_d(s)$ 中的标量变量 $s$ 替换为矩阵 $A$ 所得到的矩阵多项式。\n\n假设一位控制设计者为了分析目的，决定选择期望的闭环极点与系统原始的开环极点完全相同。在这种特定情况下，阿克曼公式计算出的状态反馈增益矩阵 $K$ 是什么？请用一个对任何此类 $n$ 阶系统都有效的通用矩阵表达式来表示你的答案。", "solution": "给定一个 $n$ 阶可控 LTI SISO 系统 $\\dot{x}(t) = Ax(t) + Bu(t)$ 和状态反馈律 $u(t) = -Kx(t)$，以及阿克曼公式\n$$\nK = \\begin{pmatrix}0  0  \\dots  1\\end{pmatrix} \\mathcal{C}^{-1} \\alpha_{d}(A),\n$$\n其中 $\\mathcal{C}$ 是 $(A,B)$ 的可控性矩阵，$\\alpha_{d}(s)$ 是期望的特征多项式。\n\n令期望的闭环多项式等于开环特征多项式：\n$$\n\\alpha_{d}(s) = \\alpha(s) = \\det(sI - A).\n$$\n根据凯莱-哈密顿定理，矩阵 $A$ 满足其自身的特征多项式：\n$$\n\\alpha(A) = 0_{n \\times n}.\n$$\n因此，将 $\\alpha_{d}(A) = \\alpha(A)$ 代入阿克曼公式可得\n$$\nK = \\begin{pmatrix}0  0  \\dots  1\\end{pmatrix} \\mathcal{C}^{-1} \\alpha(A) = \\begin{pmatrix}0  0  \\dots  1\\end{pmatrix} \\mathcal{C}^{-1} 0_{n \\times n} = 0_{1 \\times n}.\n$$\n因此，在这种情况下，阿克曼公式返回的增益是零行向量，这使得闭环矩阵 $A - BK$ 等于 $A$，从而将极点配置在所指定的原始开环位置。", "answer": "$$\\boxed{0_{1 \\times n}}$$", "id": "1556685"}, {"introduction": "这项高级实践旨在连接理论与实际应用，聚焦于数值稳定性这一关键问题。直接应用阿克曼公式，特别是涉及显式矩阵求逆时，对于高阶或病态系统可能并不可靠。在本练习[@problem_id:2689308]中，你将使用 QR 分解或 SVD 等现代数值技术，开发并实现一种数值稳健的方法，以确保在实际场景中精确计算反馈增益。", "problem": "给定一个由矩阵对 $(A,B)$ 描述的 $n$ 阶完全可控、单输入线性时不变状态空间模型，其中 $A \\in \\mathbb{R}^{n \\times n}$ 且 $B \\in \\mathbb{R}^{n \\times 1}$。目标是通过静态状态反馈律 $u = -K x$ 将闭环特征值配置到一组预设的实数位置，同时通过一种不显式构造任何矩阵逆的数值稳定方法计算状态反馈增益 $K \\in \\mathbb{R}^{1 \\times n}$。\n\n从以下基本定义和事实出发：\n- 可控性矩阵为 $C = \\big[ B \\;\\; A B \\;\\; \\cdots \\;\\; A^{n-1} B \\big] \\in \\mathbb{R}^{n \\times n}$。\n- 期望的实数特征值 $\\{\\lambda_1,\\dots,\\lambda_n\\}$ 定义了一个首一多项式 $p_d(s) = \\prod_{i=1}^n (s - \\lambda_i) = s^n + a_{n-1} s^{n-1} + \\cdots + a_1 s + a_0$，其系数 $\\{a_0,\\dots,a_{n-1}\\}$ 为实数。\n- 对于矩阵自变量，相关的矩阵多项式为 $p_d(A) = A^n + a_{n-1} A^{n-1} + \\cdots + a_1 A + a_0 I$，其中 $I$ 是大小为 $n$ 的单位矩阵。\n- Cayley–Hamilton 定理指出，每个方阵都满足其自身的特征多项式。\n- 对于一个可控系统，存在一个静态反馈增益 $K$，可以将闭环特征值配置到期望的集合。\n\n你的任务是：\n- 基于这些基础，并且不调用任何现成的公式，推导出一个使用可控性矩阵 $C$ 和矩阵多项式 $p_d(A)$ 将闭环特征值配置到期望位置的可计算状态反馈增益的表达式。你的推导应说明如何计算形如 $C^{-1} p_d(A)$ 的中间量，以及如何通过一个规范选择向量从中恢复出增益行向量。你不能显式地构造 $C^{-1}$。\n- 提出并实现一个数值稳定的计算过程，使用 $C$ 的正交三角 (QR) 分解或奇异值分解 (SVD) 来计算 $C^{-1} p_d(A)$。你的实现必须：\n  - 使用数值稳定的矩阵多项式求值方案（例如 Horner 法）来计算 $p_d(A)$，以避免显式构造高次矩阵幂。\n  - 使用基于 QR 的三角求解或基于 SVD 且对小奇异值有合理容差的伪逆来求解线性矩阵方程 $C X = p_d(A)$ 以得到 $X$，从而在不显式对 $C$ 求逆的情况下计算 $X = C^{-1} p_d(A)$。\n  - 使用适当的规范选择向量从 $X$ 中提取一个有效的状态反馈行向量。\n- 通过构造闭环矩阵 $A_{cl} = A - B K$ 并将其特征多项式的系数与 $p_d(s)$ 的系数进行比较来验证结果。使用对应系数之间的最大绝对差作为标量误差度量。值越小表示特征值配置效果越好。\n\n重要的实现约束：\n- 不要使用任何直接的矩阵求逆。使用 QR 分解或奇异值分解来求解 $X$ 的线性系统。\n- 全程使用双精度浮点运算。\n- 此问题不涉及角度，因此不需要角度单位。此问题不出现物理单位。\n\n测试套件和要求输出：\n为以下三个测试用例实现你的方法。在所有情况下，$A \\in \\mathbb{R}^{n \\times n}$ 且 $B \\in \\mathbb{R}^{n \\times 1}$。\n\n- 测试用例 1 (理想情况):\n  - 维度 $n = 3$。\n  - 使用可控积分器链 $A = \\begin{bmatrix} 0  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{bmatrix}$ 和 $B = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$。\n  - 期望特征值 $\\{\\lambda_1,\\lambda_2,\\lambda_3\\} = \\{-1,-2,-3\\}$。\n- 测试用例 2 (重复的期望特征值):\n  - 维度 $n = 4$。\n  - 使用可控积分器链 $A = \\begin{bmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  1 \\\\ 0  0  0  0 \\end{bmatrix}$ 和 $B = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$。\n  - 期望特征值 $\\{\\lambda_1,\\lambda_2,\\lambda_3,\\lambda_4\\} = \\{-1,-1,-2,-2\\}$。\n- 测试用例 3 (通过相似变换导致的病态可控性):\n  - 维度 $n = 5$。\n  - 令 $J \\in \\mathbb{R}^{5 \\times 5}$ 表示积分器链 $J = \\begin{bmatrix} 0  1  0  0  0 \\\\ 0  0  1  0  0 \\\\ 0  0  0  1  0 \\\\ 0  0  0  0  1 \\\\ 0  0  0  0  0 \\end{bmatrix}$ 且 $e_5 = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}$。\n  - 定义一个缩放不良的相似变换 $T = \\operatorname{diag}(1,10^2,10^4,10^6,10^8) \\in \\mathbb{R}^{5 \\times 5}$。\n  - 设置 $A = T J T^{-1}$ 和 $B = T e_5$。\n  - 期望特征值 $\\{\\lambda_1,\\lambda_2,\\lambda_3,\\lambda_4,\\lambda_5\\} = \\{-1,-2,-3,-4,-5\\}$。\n\n对于每个测试用例，计算两个版本的反馈增益：\n- 一个使用基于 QR 的求解方法解 $C X = p_d(A)$。\n- 一个使用基于 SVD 的求解方法（对小奇异值使用数值上合理的截断值）解 $C X = p_d(A)$。\n\n对于每个计算出的增益 $K$，构造 $A_{cl} = A - B K$ 并计算 $A_{cl}$ 的首一特征多项式系数，记为 $\\{1,\\hat{a}_{n-1},\\dots,\\hat{a}_0\\}$。令标量误差为 $\\max_{k \\in \\{0,\\dots,n-1\\}} |a_k - \\hat{a}_k|$。最后，为每个测试用例报告以下三个浮点数组成的三元组：\n- 基于 QR 方法的误差。\n- 基于 SVD 方法的误差。\n- 两种增益之差的欧几里得范数，$\\|K_{\\text{QR}} - K_{\\text{SVD}}\\|_2$。\n\n最终输出格式要求：\n- 你的程序应生成单行输出，其中包含一个以逗号分隔的列表，并用方括号括起来。每个测试用例对应一个子列表，其中包含按上述顺序排列的三个浮点数。例如，三个测试用例的输出必须类似于 $[[\\text{err\\_QR}_1,\\text{err\\_SVD}_1,\\text{dK}_1],[\\text{err\\_QR}_2,\\text{err\\_SVD}_2,\\text{dK}_2],[\\text{err\\_QR}_3,\\text{err\\_SVD}_3,\\text{dK}_3]]$，不含任何额外文本。", "solution": "所提出的问题是线性控制理论中一个标准的、关于通过状态反馈进行特征值配置的适定问题，通常称为极点配置。所有提供的信息在科学上是合理的、内部一致的，并且足以进行推导和计算。因此，该问题是有效的。我们将进行推导和求解。\n\n目标是为可控单输入线性时不变系统 $\\dot{x} = Ax + Bu$ 找到一个状态反馈增益矩阵 $K \\in \\mathbb{R}^{1 \\times n}$，使得在控制律 $u = -Kx$ 下，闭环系统的特征值位于一组预设的实数位置 $\\{\\lambda_1, \\dots, \\lambda_n\\}$。闭环系统由 $\\dot{x} = (A - BK)x = A_{cl}x$ 描述。\n\n期望的特征值是首一多项式 $p_d(s) = \\prod_{i=1}^n (s - \\lambda_i) = s^n + a_{n-1}s^{n-1} + \\dots + a_0$ 的根。要使 $A_{cl}$ 的特征值为 $\\{\\lambda_1, \\dots, \\lambda_n\\}$，其特征多项式 $\\det(sI-A_{cl})$ 必须等于 $p_d(s)$。根据 Cayley-Hamilton 定理，矩阵 $A_{cl}$ 必须满足其自身的特征方程，这意味着 $p_d(A_{cl}) = 0$。\n\n推导将通过假设增益 $K$ 的形式（即所谓的 Ackermann 公式）来进行，然后证明该形式可以实现期望的特征值配置。该公式为：\n$$ K = e_n^T C^{-1} p_d(A) $$\n其中 $e_n^T = [0, \\dots, 0, 1] \\in \\mathbb{R}^{1 \\times n}$ 是一个规范行向量，$C$ 是系统的可控性矩阵，$p_d(A)$ 是与期望特征多项式相关的矩阵多项式。\n\n让我们定义一个行向量 $q^T = e_n^T C^{-1}$。根据定义，$q^T$ 是可控性矩阵 $C = [B \\;\\; AB \\;\\; \\dots \\;\\; A^{n-1}B]$ 的逆矩阵的最后一行。这意味着 $q^T C = e_n^T$。展开这个矩阵方程可以得到 $q^T$ 的一组独特性质：\n$$ q^T A^i B = 0 \\quad \\text{for } i = 0, 1, \\dots, n-2 $$\n$$ q^T A^{n-1} B = 1 $$\n\n当 $K = q^T p_d(A)$ 时，我们现在必须证明 $A_{cl} = A - BK$ 的特征值是 $p_d(s)$ 的根。$A_{cl}$ 的特征值 $\\lambda$ 是 $\\det(\\lambda I - A_{cl}) = 0$ 的解。使用矩阵行列式引理 $\\det(M+uv^T) = \\det(M)(1+v^T M^{-1}u)$，我们可以写出：\n$$ \\det(\\lambda I - A_{cl}) = \\det(\\lambda I - (A - BK)) = \\det((\\lambda I - A) + BK) $$\n$$ = \\det(\\lambda I - A) \\left(1 + K(\\lambda I - A)^{-1}B\\right) $$\n由于对于单输入系统，$K(\\lambda I - A)^{-1}B$ 是一个标量，闭环系统特征值 $\\lambda$（其中 $\\lambda$ 不是 $A$ 的特征值）的特征方程变为：\n$$ 1 + K(\\lambda I - A)^{-1}B = 0 $$\n代入我们的表达式 $K = q^T p_d(A)$：\n$$ 1 + q^T p_d(A) (\\lambda I - A)^{-1} B = 0 $$\n我们可以使用多项式除法将 $p_d(s)$ 写为 $p_d(s) = p_d(\\lambda) + (s-\\lambda)\\hat{p}(s,\\lambda)$，其中 $\\hat{p}(s,\\lambda)$ 是一个关于 $s$ 的 $n-1$ 次多项式。$\\hat{p}(s,\\lambda)$ 的首项系数为 1。将矩阵 $A$ 代入该式得到：\n$$ p_d(A) = p_d(\\lambda)I + (A-\\lambda I)\\hat{p}(A,\\lambda) $$\n假设 $\\lambda I - A$ 是可逆的，我们可以写出：\n$$ p_d(A)(\\lambda I-A)^{-1} = -p_d(A)(A-\\lambda I)^{-1} = -p_d(\\lambda)(A-\\lambda I)^{-1} - \\hat{p}(A,\\lambda) $$\n将此代入特征方程：\n$$ 1 - q^T \\left( p_d(\\lambda)(A-\\lambda I)^{-1} + \\hat{p}(A,\\lambda) \\right) B = 0 $$\n$$ 1 - p_d(\\lambda) q^T(A-\\lambda I)^{-1}B - q^T\\hat{p}(A,\\lambda)B = 0 $$\n现在，我们来考察 $q^T\\hat{p}(A,\\lambda)B$ 这一项。由于 $\\hat{p}(s,\\lambda)$ 是一个 $n-1$ 次多项式，我们可以写出 $\\hat{p}(A,\\lambda) = \\sum_{i=0}^{n-1} c_i A^i$，其中 $c_{n-1}=1$。\n$$ q^T\\hat{p}(A,\\lambda)B = q^T \\left(\\sum_{i=0}^{n-1} c_i A^i \\right) B = \\sum_{i=0}^{n-1} c_i (q^T A^i B) $$\n利用 $q^T$ 的性质，这个和式坍缩为一项：\n$$ (c_0 \\cdot 0) + \\dots + (c_{n-2} \\cdot 0) + (c_{n-1} \\cdot 1) = c_{n-1} = 1 $$\n因此，特征方程简化为：\n$$ 1 - p_d(\\lambda) q^T(A-\\lambda I)^{-1}B - 1 = 0 $$\n$$ -p_d(\\lambda) \\left(q^T(A-\\lambda I)^{-1}B\\right) = 0 $$\n如果 $p_d(\\lambda) = 0$，则该方程成立。这证明了期望多项式 $p_d(s)$ 的任何根都是闭环矩阵 $A_{cl}$ 的一个特征值。由于有 $n$ 个这样的根，它们构成了 $A_{cl}$ 的完整特征值集合。\n\n计算过程避免了显式的矩阵求逆。增益为 $K = e_n^T C^{-1} p_d(A)$。令 $X = C^{-1} p_d(A)$。那么 $K$ 就是矩阵 $X$ 的最后一行。我们可以通过求解线性矩阵方程 $CX = p_d(A)$ 来找到 $X$。\n算法如下：\n1.  根据期望的特征值 $\\{\\lambda_1, \\dots, \\lambda_n\\}$，计算目标特征多项式 $p_d(s) = s^n + a_{n-1}s^{n-1} + \\dots + a_0$ 的系数 $\\{a_0, \\dots, a_{n-1}\\}$。\n2.  使用像 Horner 法这样的数值稳定方案来计算矩阵多项式 $p_d(A)$，以避免构造和存储 $A$ 的高次幂：\n    $p_d(A) = (\\dots((I\\cdot A + a_{n-1}I)A + a_{n-2}I)A + \\dots + a_0I)$。\n3.  构造可控性矩阵 $C = [B \\;\\; AB \\;\\; \\dots \\;\\; A^{n-1}B]$。\n4.  求解线性矩阵方程 $CX = p_d(A)$ 以得到 $X$，而不构造 $C^{-1}$。\n    -   **使用 QR 分解**：计算 $C=QR$。方程变为 $RX = Q^T p_d(A)$。由于 $R$ 是上三角矩阵，可以通过回代法高效地求出 $X$。\n    -   **使用 SVD**：计算 $C=U\\Sigma V^T$。解为 $X = V \\Sigma^{\\dagger} U^T p_d(A)$，其中 $\\Sigma^{\\dagger}$ 是对角矩阵 $\\Sigma$ 的伪逆。对于大于某个容差的奇异值 $\\sigma_i$，$\\Sigma^{\\dagger}$ 的对应元素为 $1/\\sigma_i$，否则为 $0$。一个有依据的容差是 $\\tau = \\max(n,n) \\cdot \\epsilon \\cdot \\sigma_{\\max}$，其中 $\\epsilon$ 是机器精度，$\\sigma_{\\max}$ 是最大的奇异值。\n5.  从计算出的矩阵 $X$ 的最后一行提取增益向量 $K$：`K = X[n-1, :]`。\n6.  为了验证，构造 $A_{cl}=A-BK$ 并计算其特征多项式的系数。误差是这些系数与目标系数 $\\{a_i\\}$ 之间的最大绝对差。\n\n这个过程为计算状态反馈增益提供了一种数值鲁棒的方法。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Solves for the state feedback gain K using QR and SVD based methods for three test cases,\n    and reports the accuracy of eigenvalue placement.\n    \"\"\"\n\n    def compute_ackermann_gain(A, B, desired_eigs, method):\n        \"\"\"\n        Computes the state feedback gain K using Ackermann's formula via QR or SVD.\n        \n        Args:\n            A (np.ndarray): State matrix (n x n).\n            B (np.ndarray): Input matrix (n x 1).\n            desired_eigs (list or np.ndarray): List of desired closed-loop eigenvalues.\n            method (str): 'qr' or 'svd'.\n\n        Returns:\n            np.ndarray: State feedback gain K (1 x n).\n        \"\"\"\n        n = A.shape[0]\n\n        # 1. Compute coefficients of the desired characteristic polynomial p_d(s)\n        # np.poly gives [1, a_{n-1}, ..., a_0]\n        p_coeffs = np.poly(desired_eigs)\n\n        # 2. Evaluate the matrix polynomial p_d(A) using Horner's method\n        # p_d(A) = A^n + a_{n-1}A^{n-1} + ... + a_0*I\n        PdA = np.eye(n)\n        for i in range(1, n + 1):\n            PdA = A @ PdA + p_coeffs[i] * np.eye(n)\n\n        # 3. Construct the controllability matrix C\n        C = np.zeros((n, n), dtype=np.float64)\n        C[:, 0] = B.flatten()\n        for i in range(1, n):\n            C[:, i] = A @ C[:, i - 1]\n        \n        # 4. Solve the linear system CX = p_d(A) for X\n        if method == 'qr':\n            Q, R = np.linalg.qr(C)\n            # Solve R @ X = Q.T @ PdA\n            X = scipy.linalg.solve_triangular(R, Q.T @ PdA)\n        elif method == 'svd':\n            U, s, Vh = np.linalg.svd(C)\n            # Set tolerance for pseudoinverse calculation\n            tol = max(C.shape) * np.finfo(s.dtype).eps * s[0]\n            s_inv = np.where(s > tol, 1 / s, 0)\n            # Compute X = V @ S_pinv @ U.T @ PdA\n            C_pinv = Vh.T @ np.diag(s_inv) @ U.T\n            X = C_pinv @ PdA\n        else:\n            raise ValueError(\"Method must be 'qr' or 'svd'\")\n\n        # 5. Extract gain K from the last row of X\n        K = X[-1, :]\n        return K.reshape(1, n)\n\n    test_cases = [\n        {\n            \"n\": 3,\n            \"A\": np.array([[0, 1, 0], [0, 0, 1], [0, 0, 0]], dtype=np.float64),\n            \"B\": np.array([[0], [0], [1]], dtype=np.float64),\n            \"eigs\": [-1, -2, -3]\n        },\n        {\n            \"n\": 4,\n            \"A\": np.array([[0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1], [0, 0, 0, 0]], dtype=np.float64),\n            \"B\": np.array([[0], [0], [0], [1]], dtype=np.float64),\n            \"eigs\": [-1, -1, -2, -2]\n        },\n        {\n            \"n\": 5,\n            \"setup\": {\n                \"J\": np.diag(np.ones(4), 1),\n                \"e5\": np.array([[0],[0],[0],[0],[1]], dtype=np.float64),\n                \"T\": np.diag([10**(2*i) for i in range(5)])\n            },\n            \"eigs\": [-1, -2, -3, -4, -5]\n        }\n    ]\n    # Prepare test case 3\n    tc3 = test_cases[2]\n    J = tc3['setup']['J']\n    T = tc3['setup']['T']\n    e5 = tc3['setup']['e5']\n    T_inv = np.linalg.inv(T)\n    tc3['A'] = T @ J @ T_inv\n    tc3['B'] = T @ e5\n\n    results = []\n    \n    for case in test_cases:\n        A, B, eigs = case['A'], case['B'], case['eigs']\n        n = case['n']\n\n        # Desired characteristic polynomial coefficients\n        p_coeffs_desired = np.poly(eigs)\n\n        # QR method\n        K_qr = compute_ackermann_gain(A, B, eigs, 'qr')\n        A_cl_qr = A - B @ K_qr\n        p_coeffs_qr = np.poly(A_cl_qr)\n        err_qr = np.max(np.abs(p_coeffs_desired[1:] - p_coeffs_qr[1:]))\n\n        # SVD method\n        K_svd = compute_ackermann_gain(A, B, eigs, 'svd')\n        A_cl_svd = A - B @ K_svd\n        p_coeffs_svd = np.poly(A_cl_svd)\n        err_svd = np.max(np.abs(p_coeffs_desired[1:] - p_coeffs_svd[1:]))\n\n        # Difference between gains\n        dK = np.linalg.norm(K_qr - K_svd)\n\n        results.append([err_qr, err_svd, dK])\n\n    # Format the output as specified\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2689308"}]}