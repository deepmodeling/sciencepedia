{"hands_on_practices": [{"introduction": "理论学习的最佳方式是付诸实践。本章节将通过一系列精心设计的练习，引导您从基本概念走向高级应用。我们的第一个练习将从最核心的概念入手：通过调整一个标量增益 $L$ 来设定降阶观测器误差动态的极点。这个练习 [@problem_id:1604257] 将帮助您牢固掌握增益、系统矩阵和误差动态稳定性的基本代数关系，为后续更复杂的设计奠定基础。", "problem": "考虑一个线性时不变系统，其内部状态由向量 $\\mathbf{x}(t) = [x_a(t), x_b(t)]^T$ 描述。系统动态由以下耦合常微分方程组控制：\n$$\n\\dot{x}_a(t) = -2x_a(t) + 3x_b(t)\n$$\n$$\n\\dot{x}_b(t) = x_a(t) - 5x_b(t) + 0.5u(t)\n$$\n其中 $u(t)$ 是一个控制输入。\n\n在该系统中，只有状态变量 $x_a(t)$ 是可直接测量的，并被定义为系统输出，因此 $y(t) = x_a(t)$。为了估计未测量的状态 $x_b(t)$，设计了一个降阶观测器。该观测器的结构包含一个标量增益 $L$。该设计的一个关键特征是，估计误差 $e(t) = x_b(t) - \\hat{x}_b(t)$（其中 $\\hat{x}_b(t)$ 是 $x_b(t)$ 的估计值）的动态由以下自治一阶微分方程描述：\n$$\n\\dot{e}(t) = (A_{bb} - L A_{ab}) e(t)\n$$\n项 $A_{ab}$ 和 $A_{bb}$ 是系统状态矩阵 $A$ 的元素，该矩阵根据测量状态 ($x_a$) 和未测量状态 ($x_b$) 分块如下：\n$$\nA = \\begin{pmatrix} A_{aa} & A_{ab} \\\\ A_{ba} & A_{bb} \\end{pmatrix}\n$$\n您的任务是确定增益 $L$ 的数值，该增益将误差动态的单个极点置于 $s = -12$。增益 $L$ 是一个无量纲的量。将您的最终答案四舍五入到三位有效数字。", "solution": "给定的状态空间方程为\n$$\n\\dot{x}_{a}(t) = -2 x_{a}(t) + 3 x_{b}(t), \\quad \\dot{x}_{b}(t) = x_{a}(t) - 5 x_{b}(t) + 0.5\\,u(t).\n$$\n因此状态矩阵为\n$$\nA = \\begin{pmatrix} -2 & 3 \\\\ 1 & -5 \\end{pmatrix}.\n$$\n根据测量状态 $x_{a}$ 和未测量状态 $x_{b}$ 进行分块，得到标量块\n$$\nA_{aa} = -2, \\quad A_{ab} = 3, \\quad A_{ba} = 1, \\quad A_{bb} = -5.\n$$\n降阶观测器的误差动态由下式给出\n$$\n\\dot{e}(t) = \\left(A_{bb} - L A_{ab}\\right) e(t),\n$$\n因此（单个）误差动态极点为\n$$\ns = A_{bb} - L A_{ab}.\n$$\n为了将该极点置于 $s = -12$，我们施加条件\n$$\nA_{bb} - L A_{ab} = -12.\n$$\n求解 $L$：\n$$\n- L A_{ab} = -12 - A_{bb} \\;\\Rightarrow\\; L A_{ab} = 12 + A_{bb} \\;\\Rightarrow\\; L = \\frac{12 + A_{bb}}{A_{ab}}.\n$$\n代入 $A_{bb} = -5$ 和 $A_{ab} = 3$：\n$$\nL = \\frac{12 - 5}{3} = \\frac{7}{3}.\n$$\n四舍五入到三位有效数字，结果为 $2.33$。", "answer": "$$\\boxed{2.33}$$", "id": "1604257"}, {"introduction": "在掌握了基本的一阶误差系统设计后，我们将挑战一个更普遍的场景：为未测量状态为多维的系统设计观测器。在这个练习 [@problem_id:2737294] 中，您需要计算一个向量增益 $L$ 来同时配置多个误差动态极点。此外，本练习还要求您构建完整的观测器实现矩阵 $(F, G, H)$，从而将抽象的极点配置理论与具体的观测器状态空间方程联系起来。", "problem": "考虑一个连续时间线性时不变（LTI）系统，该系统经过变换，使得测量输出等于状态的一个子集。状态被划分为 $x = \\begin{bmatrix} x_{a} \\\\ x_{b} \\end{bmatrix}$，其中 $x_{a} \\in \\mathbb{R}$ 是可测量的，而 $x_{b} \\in \\mathbb{R}^{2}$ 是不可测量的。在这些坐标系下，动力学和输入输出方程为\n$$\n\\begin{bmatrix}\n\\dot{x}_{a} \\\\\n\\dot{x}_{b}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nA_{aa} & A_{ab} \\\\\nA_{ba} & A_{bb}\n\\end{bmatrix}\n\\begin{bmatrix}\nx_{a} \\\\\nx_{b}\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nB_{a} \\\\\nB_{b}\n\\end{bmatrix}\nu,\n\\qquad\ny = x_{a}.\n$$\n在这个具体的数值例子中，各矩阵分块为\n$$\nA_{aa} = 0,\\quad\nA_{ab} = \\begin{bmatrix} 0 & 1 \\end{bmatrix},\\quad\nA_{ba} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix},\\quad\nA_{bb} = \\begin{bmatrix} 0 & 1 \\\\ -1 & -1 \\end{bmatrix},\\quad\nB_{a} = 0,\\quad\nB_{b} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}.\n$$\n设计一个2阶的降阶观测器，从测量输出 $y$ 和已知输入 $u$ 来估计 $x_{b}$。从第一性原理出发：使用状态分块模型、观测器和估计误差的定义，推导出一个由 $y$ 和 $u$ 驱动的观测器结构，其估计误差动力学在误差上是线性和自治的。然后，施加一个极点配置要求，使误差动力学的特征值位于 $-4$ 和 $-5$，并构建观测器实现中出现的相应观测器矩阵 $(F, G, H)$\n$$\n\\dot{z} = F z + G y + H u, \\qquad \\hat{x}_{b} = z + L y, \\qquad \\hat{x}_{a} = y,\n$$\n其中 $z \\in \\mathbb{R}^{2}$ 是观测器状态，$L \\in \\mathbb{R}^{2 \\times 1}$ 是一个观测器增益，你必须在设计过程中确定它。最后，在构建 $(F,G,H)$ 之后，报告特征多项式 $p(s) = \\det(s I - F)$，它是一个关于 $s$ 的多项式。请以精确的解析形式（无四舍五入）给出 $p(s)$ 的最终答案。", "solution": "所给问题是控制理论中的一个标准练习，涉及为线性时不变（LTI）系统设计一个降阶观测器。该问题具有科学依据，提法明确，并为得到唯一解提供了所有必要信息。任意配置观测器误差动力学极点所需的可观测性条件是满足的。我们将按照指示，从第一性原理开始推导。\n\n系统动力学以分块形式给出：\n$$\n\\dot{x}_{a} = A_{aa} x_{a} + A_{ab} x_{b} + B_{a} u\n$$\n$$\n\\dot{x}_{b} = A_{ba} x_{a} + A_{bb} x_{b} + B_{b} u\n$$\n输出为 $y = x_{a}$，其中 $x_{a}$ 是状态的可测量部分，$x_{b}$ 是我们希望估计的不可测量部分。用 $y$ 替换 $x_{a}$，系统方程变为：\n$$\n\\dot{y} = A_{aa} y + A_{ab} x_{b} + B_{a} u\n$$\n$$\n\\dot{x}_{b} = A_{ba} y + A_{bb} x_{b} + B_{b} u\n$$\n问题指定了用于估计 $x_{b}$ 的降阶观测器结构，记为 $\\hat{x}_{b}$，其形式如下：\n$$\n\\hat{x}_{b} = z + L y\n$$\n其中 $z$ 是观测器的状态，$L$ 是一个待定的增益矩阵。观测器状态 $z$ 的动力学由下式给出：\n$$\n\\dot{z} = F z + G y + H u\n$$\n估计误差定义为 $e = x_{b} - \\hat{x}_{b}$。我们旨在推导该误差的动力学。\n$$\ne = x_{b} - (z + L y) = x_{b} - z - L y\n$$\n对时间求导，我们得到：\n$$\n\\dot{e} = \\dot{x}_{b} - \\dot{z} - L \\dot{y}\n$$\n现在，代入 $\\dot{x}_{b}$、$\\dot{z}$ 和 $\\dot{y}$ 的表达式：\n$$\n\\dot{e} = (A_{ba} y + A_{bb} x_{b} + B_{b} u) - (F z + G y + H u) - L (A_{aa} y + A_{ab} x_{b} + B_{a} u)\n$$\n为了使误差动力学仅依赖于误差 $e$，我们必须消除包含 $x_{b}$、$y$ 和 $u$ 的项。首先，我们使用误差的定义来替换 $z$：$z = x_{b} - e - Ly$。\n$$\n\\dot{e} = (A_{ba} y + A_{bb} x_{b} + B_{b} u) - F(x_{b} - e - Ly) - (G y + H u) - L(A_{aa} y + A_{ab} x_{b} + B_{a} u)\n$$\n按 $e$、$x_{b}$、$y$ 和 $u$ 对各项进行分组：\n$$\n\\dot{e} = Fe + (A_{bb} - F - LA_{ab})x_{b} + (A_{ba} + FL - G - LA_{aa})y + (B_{b} - H - LB_{a})u\n$$\n为了使误差动力学是线性和自治的，形式为 $\\dot{e} = Fe$，则 $x_{b}$、$y$ 和 $u$ 项的系数必须为零。这就得到了观测器矩阵 $F$、$G$ 和 $H$ 的设计方程：\n1. $A_{bb} - F - LA_{ab} = 0 \\implies F = A_{bb} - LA_{ab}$\n2. $A_{ba} + FL - G - LA_{aa} = 0 \\implies G = A_{ba} - LA_{aa} + FL$\n3. $B_{b} - H - LB_{a} = 0 \\implies H = B_{b} - LB_{a}$\n\n误差动力学由 $\\dot{e} = (A_{bb} - LA_{ab})e$ 决定。观测器的稳定性和性能由矩阵 $F = A_{bb} - LA_{ab}$ 的特征值决定。我们可以选择增益 $L$ 来将这些特征值配置在期望的位置。问题要求误差动力学的特征值位于 $-4$ 和 $-5$。相应的期望特征多项式为：\n$$\np_{\\text{desired}}(s) = (s - (-4))(s - (-5)) = (s+4)(s+5) = s^2 + 9s + 20\n$$\n现在我们使用所给定的具体数值：\n$$\nA_{aa} = 0, \\quad A_{ab} = \\begin{bmatrix} 0 & 1 \\end{bmatrix}, \\quad A_{ba} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad A_{bb} = \\begin{bmatrix} 0 & 1 \\\\ -1 & -1 \\end{bmatrix}, \\quad B_{a} = 0, \\quad B_{b} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n$$\n增益矩阵 $L$ 的维度为 $2 \\times 1$。令 $L = \\begin{bmatrix} L_1 \\\\ L_2 \\end{bmatrix}$。我们构建矩阵 $F$：\n$$\nF = A_{bb} - LA_{ab} = \\begin{bmatrix} 0 & 1 \\\\ -1 & -1 \\end{bmatrix} - \\begin{bmatrix} L_1 \\\\ L_2 \\end{bmatrix} \\begin{bmatrix} 0 & 1 \\end{bmatrix} = \\begin{bmatrix} 0 & 1 \\\\ -1 & -1 \\end{bmatrix} - \\begin{bmatrix} 0 & L_1 \\\\ 0 & L_2 \\end{bmatrix} = \\begin{bmatrix} 0 & 1 - L_1 \\\\ -1 & -1 - L_2 \\end{bmatrix}\n$$\n$F$ 的特征多项式为 $p(s) = \\det(sI - F)$：\n$$\nsI - F = \\begin{bmatrix} s & 0 \\\\ 0 & s \\end{bmatrix} - \\begin{bmatrix} 0 & 1 - L_1 \\\\ -1 & -1 - L_2 \\end{bmatrix} = \\begin{bmatrix} s & -(1-L_1) \\\\ 1 & s - (-1-L_2) \\end{bmatrix} = \\begin{bmatrix} s & L_1-1 \\\\ 1 & s+1+L_2 \\end{bmatrix}\n$$\n$$\np(s) = \\det(sI - F) = s(s+1+L_2) - (L_1-1)(1) = s^2 + (1+L_2)s + (1-L_1)\n$$\n我们将该多项式的系数与期望多项式 $s^2 + 9s + 20$ 的系数进行匹配：\n- 对于 $s$ 的系数：$1+L_2 = 9 \\implies L_2 = 8$。\n- 对于常数项：$1-L_1 = 20 \\implies L_1 = -19$。\n因此，所需的增益矩阵为 $L = \\begin{bmatrix} -19 \\\\ 8 \\end{bmatrix}$。\n\n使用这个增益，观测器矩阵 $F$ 为：\n$$\nF = \\begin{bmatrix} 0 & 1 - (-19) \\\\ -1 & -1 - 8 \\end{bmatrix} = \\begin{bmatrix} 0 & 20 \\\\ -1 & -9 \\end{bmatrix}\n$$\n问题要求的是这个矩阵 $F$ 的特征多项式。我们已经将这个多项式设计为 $s^2 + 9s + 20$。作为一个正式的检验：\n$$\np(s) = \\det(sI - F) = \\det\\left(\\begin{bmatrix} s & -20 \\\\ 1 & s+9 \\end{bmatrix}\\right) = s(s+9) - (1)(-20) = s^2 + 9s + 20\n$$\n计算是正确的。\n为了完整性，我们也可以求出矩阵 $G$ 和 $H$。\n$G = A_{ba} - LA_{aa} + FL$。因为 $A_{aa}=0$，所以 $G = A_{ba} + FL$。\n$$\nFL = \\begin{bmatrix} 0 & 20 \\\\ -1 & -9 \\end{bmatrix} \\begin{bmatrix} -19 \\\\ 8 \\end{bmatrix} = \\begin{bmatrix} 0(-19) + 20(8) \\\\ -1(-19) + (-9)(8) \\end{bmatrix} = \\begin{bmatrix} 160 \\\\ 19 - 72 \\end{bmatrix} = \\begin{bmatrix} 160 \\\\ -53 \\end{bmatrix}\n$$\n$$\nG = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} + \\begin{bmatrix} 160 \\\\ -53 \\end{bmatrix} = \\begin{bmatrix} 160 \\\\ -52 \\end{bmatrix}\n$$\n$H = B_b - LB_a$。因为 $B_a=0$，所以 $H = B_b$。\n$$\nH = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}\n$$\n完整的观测器已经构建，但最终要求的输出只是 $F$ 的特征多项式。", "answer": "$$\n\\boxed{s^2 + 9s + 20}\n$$", "id": "2737294"}, {"introduction": "最后一个练习将引导您进入降阶观测器设计的前沿领域，展示一种强大而系统化的设计方法。本练习 [@problem_id:2737300] 的核心是利用控制理论中深刻的对偶原理 (duality principle)，将观测器增益设计问题转化为一个等效的状态反馈控制器设计问题。您将通过应用线性二次调节器 (LQR) 理论来系统地计算观测器增益，并通过编写代码和进行仿真来验证您的设计，真正实现从理论推导到实践验证的闭环学习。", "problem": "考虑一个由方程 $ \\dot{x}(t) = A x(t) + B u(t) $ 和 $ y(t) = C x(t) $ 定义的连续时间线性时不变状态空间系统，其中 $ A \\in \\mathbb{R}^{n \\times n} $，$ B \\in \\mathbb{R}^{n \\times m} $，以及 $ C \\in \\mathbb{R}^{p \\times n} $ 且 $ \\operatorname{rank}(C) = p $。假设 $ p \\le n $ 且 $ C $ 具有满行秩。目标是利用观测器设计与控制器综合之间的对偶性，设计一个阶数为 $ n - p $ 的降阶观测器。您的任务是推导、实现并验证一个算法，该算法仅基于公认的原理来构建降阶观测器：线性时不变状态空间公式、可控性与可观测性之间的对偶性，以及用于稳定线性系统的连续时间线性二次調節器 (LQR) 综合。\n\n推导要求：\n- 从线性时不变状态空间模型和测量方程的定义出发。\n- 引入一个状态变换，该变换使用 $ C $ 的一个右逆和 $ \\operatorname{Null}(C) $ 的一组基，来分离已测和未测子空间。除了 $ \\operatorname{rank}(C) = p $ 外，避免对 $ A $ 或 $ C $ 作任何特殊结构的假设。\n- 以分块变换矩阵的形式，推导未测部分的降阶估计误差动态，展示误差动态如何依赖于一个乘以已知信号的观测器增益，该已知信号可能包含 $ \\dot{y}(t) $。\n- 利用状态反馈控制器设计与观测器设计之间的对偶性，将应用于对偶对的控制器综合程序转换为降阶观测器增益。将控制器综合建立在连续时间线性二次調節器 (LQR) 的基础上，当对是可镇定的且权重为正（半）定时，LQR 使用连续时间代数黎卡提方程 (ARE) 来产生一个稳定的状态反馈增益。\n\n算法要求：\n- 使用 $ X = C^{\\top} (C C^{\\top})^{-1} $ 构建 $ C $ 的一个右逆 $ X \\in \\mathbb{R}^{n \\times p} $，使得 $ C X = I_p $。\n- 构建一个矩阵 $ N \\in \\mathbb{R}^{n \\times (n-p)} $，其列构成 $ \\operatorname{Null}(C) $ 的一组基。\n- 形成可逆变换 $ T^{-1} = [\\, X \\; N \\,] \\in \\mathbb{R}^{n \\times n} $ 及其逆 $ T \\in \\mathbb{R}^{n \\times n} $。定义变换后的坐标 $ \\bar{x} = T x $，其中 $ \\bar{x} = \\begin{bmatrix} x_a \\\\ x_b \\end{bmatrix} $，$ x_a \\in \\mathbb{R}^{p} $ 等于已测输出 $ y $，$ x_b \\in \\mathbb{R}^{n-p} $ 表示未测部分。\n- 计算分块变换矩阵 $ \\bar{A} = T A T^{-1} $ 和 $ \\bar{B} = T B $，形式为 $ \\bar{A} = \\begin{bmatrix} A_{aa} & A_{ab} \\\\ A_{ba} & A_{bb} \\end{bmatrix} $ 和 $ \\bar{B} = \\begin{bmatrix} B_a \\\\ B_b \\end{bmatrix} $。\n- 仅使用上述原理，推导出利用可测量信号 $ y(t) $、$ u(t) $ 和 $ \\dot{y}(t) $（可由模型计算得出 $ \\dot{y}(t) = C \\dot{x}(t) = C (A x(t) + B u(t)) $）的降阶观测器，可以得到未测部分的估计误差动态形式为 $ \\dot{e}_b(t) = \\left( A_{bb} - L A_{ab} \\right) e_b(t) $，其中 $ L \\in \\mathbb{R}^{(n-p) \\times p} $ 是待设计的降阶观测器增益。\n- 利用对偶性，为对偶对指定一个控制器综合方法，通过从连续时间 LQR 获得的状态反馈控制器增益映射得到 $ L $。除了使用 $ X $ 和 $ N $ 的既定构造外，您不得假设任何特殊的规范型，并且必须严格证明为什么所选的控制器综合方法在通过对偶性映射回传后能确保估计误差动态的渐近稳定性。\n\n验证要求：\n- 实现一个程序，该程序：\n  1. 构造 $ X $、$ N $、$ T^{-1} $、$ T $，并对 $ \\bar{A} $ 和 $ \\bar{B} $ 进行分块。\n  2. 使用应用于适当定义的对偶对的连续时间 LQR 设计降阶观测器增益。\n  3. 使用固定步长数值积分器在连续时间内仿真被控对象和降阶观测器，以确认收敛性。\n  4. 验证 $ A_{bb} - L A_{ab} $ 的特征值均具有严格为负的实部，并且终端估计误差范数低于指定的容差。\n- 连续时间 LQR 应通过连续时间代数黎卡提方程实现，其中状态权重 $ Q_d $ 为对称半正定，输入权重 $ R_d $ 为对称正定。您必须明确地从代数黎卡提方程的解中计算 LQR 增益。\n\n测试套件：\n提供以下三个测试用例。所有量均为无量纲。仿真时长为 $ T = 5.0 $，固定时间步长为 $ \\Delta t = 0.002 $。终端估计误差范数计算为 $ \\lVert x(T) - \\hat{x}(T) \\rVert_2 $，成功的容差为 $ 10^{-3} $。对于每个测试，与未测部分对应的初始观测器内部状态为零，完整状态估计重构为 $ \\hat{x}(t) = T^{-1} \\begin{bmatrix} y(t) \\\\ \\hat{x}_b(t) \\end{bmatrix} $。\n\n- 测试用例 1（理想情况，$ n = 3 $，$ p = 1 $，$ m = 1 $）：\n  - $ A = \\begin{bmatrix} 0.2 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\\\ 1.0 & 2.0 & 0.5 \\end{bmatrix} $，$ B = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 1.0 \\end{bmatrix} $，$ C = \\begin{bmatrix} 1.0 & 0.0 & 0.0 \\end{bmatrix} $。\n  - LQR 对偶权重：$ Q_d = I_2 $，$ R_d = \\begin{bmatrix} 1.0 \\end{bmatrix} $。\n  - 初始条件：$ x(0) = \\begin{bmatrix} 0.5 \\\\ -1.0 \\\\ 1.0 \\end{bmatrix} $。\n  - 输入：$ u(t) = 0.2 $ for all $ t \\in [0, T] $。\n\n- 测试用例 2（多输出，非平凡的对偶输入维度，$ n = 4 $，$ p = 2 $，$ m = 1 $）：\n  - $ A = \\begin{bmatrix}\n      0.0 & 1.0 & 1.0 & 0.0 \\\\\n      -1.0 & 0.0 & 0.0 & 1.0 \\\\\n      0.0 & 0.0 & 0.0 & 1.0 \\\\\n      1.0 & 0.0 & 3.0 & 0.2\n    \\end{bmatrix} $，$ B = \\begin{bmatrix} 0.0 \\\\ 0.0 \\\\ 0.0 \\\\ 1.0 \\end{bmatrix} $，$ C = \\begin{bmatrix} 1.0 & 0.0 & 0.0 & 0.0 \\\\ 0.0 & 1.0 & 0.0 & 0.0 \\end{bmatrix} $。\n  - LQR 对偶权重：$ Q_d = I_2 $，$ R_d = I_2 $。\n  - 初始条件：$ x(0) = \\begin{bmatrix} 0.2 \\\\ -0.5 \\\\ 0.3 \\\\ 1.0 \\end{bmatrix} $。\n  - 输入：$ u(t) = 0.1 \\sin(2 t) $ for all $ t \\in [0, T] $。\n\n- 测试用例 3（边界情况，全状态测量，$ n = 3 $，$ p = 3 $，$ m = 1 $）：\n  - $ A = \\begin{bmatrix} 0.0 & 1.0 & 0.0 \\\\ 0.0 & 0.0 & 1.0 \\\\ -1.0 & -1.0 & -1.0 \\end{bmatrix} $，$ B = \\begin{bmatrix} 0.0 \\\\ 1.0 \\\\ 0.0 \\end{bmatrix} $，$ C = I_3 $。\n  - LQR 对偶权重（由于没有未测子空间而未使用）：$ Q_d = I_0 $（空），$ R_d = I_0 $（空）。\n  - 初始条件：$ x(0) = \\begin{bmatrix} -0.3 \\\\ 0.4 \\\\ -0.2 \\end{bmatrix} $。\n  - 输入：$ u(t) = 0.0 $ for all $ t \\in [0, T] $。\n\n程序输出规范：\n- 对于每个测试用例，计算一个布尔值，当且仅当以下两个条件同时成立时，该值为 $ \\text{True} $：\n  1. $ A_{bb} - L A_{ab} $ 的所有特征值都具有严格为负的实部（如果 $ n - p = 0 $，则视此条件为满足）。\n  2. 终端估计误差范数满足 $ \\lVert x(T) - \\hat{x}(T) \\rVert_2 \\le 10^{-3} $。\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$ [\\text{True},\\text{False},\\text{True}] $）。", "solution": "所提出的问题是控制理论领域一个有效、定义明确的问题。它在科学上基于线性时不变 (LTI) 系统、状态观测器以及控制与估计之间的对偶性等原理。该问题是客观、完整的，并为降阶观测器的推导和数值验证提供了所有必要的数据。我们现在开始进行形式化的推导和求解。\n\n所考虑的系统是一个连续时间 LTI 系统，由以下状态空间方程描述：\n$$ \\dot{x}(t) = A x(t) + B u(t) $$\n$$ y(t) = C x(t) $$\n其中 $x(t) \\in \\mathbb{R}^n$ 是状态向量，$u(t) \\in \\mathbb{R}^m$ 是输入向量，$y(t) \\in \\mathbb{R}^p$ 是测量向量。矩阵 $A$、$B$ 和 $C$ 具有相容的维度。我们已知 $C$ 具有满行秩，即 $\\operatorname{rank}(C) = p$。\n\n我们的目标是设计一个阶数为 $n-p$ 的降阶观测器来估计状态 $x(t)$。该设计将基于一个状态变换，该变换将状态向量分离为已测和未测分量。\n\n首先，我们构造一个状态变换 $T$。我们定义一个矩阵 $T^{-1} = [\\, X \\quad N \\,]$，其中 $X \\in \\mathbb{R}^{n \\times p}$ 是 $C$ 的一个右逆，而 $N \\in \\mathbb{R}^{n \\times (n-p)}$ 是一个矩阵，其列构成了 $C$ 的零空间 $\\operatorname{Null}(C)$ 的一组基。\n一个合适的右逆 $X$ 可以构造为 $X = C^{\\top} (C C^{\\top})^{-1}$。由于 $\\operatorname{rank}(C) = p$，矩阵 $C C^{\\top} \\in \\mathbb{R}^{p \\times p}$ 是正定的，因此是可逆的。这样选择的 $X$ 满足 $C X = C C^{\\top} (C C^{\\top})^{-1} = I_p$。\n矩阵 $N$ 的构造使其列线性无关且张成 $\\operatorname{Null}(C)$，这意味着 $C N = 0$。\n矩阵 $T^{-1}$ 是可逆的，因为 $X$ 的列空间和 $N$ 的列空间（即 $\\operatorname{Null}(C)$）的交集是平凡的。要证明这一点，设 $v$ 同时属于这两个空间。则存在某个 $a \\in \\mathbb{R}^p$ 使得 $v = Xa$ 且 $Cv = 0$。应用 $C$ 得 $C(Xa) = (CX)a = I_p a = a$。因此，$a=0$，这意味着 $v=0$。由于 $X$ 和 $N$ 的列空间的维度分别为 $p$ 和 $n-p$，它们共同张成 $\\mathbb{R}^n$，使得 $T^{-1}$ 可逆。\n\n我们定义一个新的状态向量 $\\bar{x}(t) = T x(t)$。我们将 $\\bar{x}(t)$ 分块为 $\\bar{x}(t) = \\begin{bmatrix} x_a(t) \\\\ x_b(t) \\end{bmatrix}$，其中 $x_a \\in \\mathbb{R}^p$ 且 $x_b \\in \\mathbb{R}^{n-p}$。\n$y(t)$ 与变换后状态之间的关系可通过以下方式找到：\n$$ y(t) = C x(t) = C T^{-1} \\bar{x}(t) = C [\\, X \\quad N \\,] \\begin{bmatrix} x_a(t) \\\\ x_b(t) \\end{bmatrix} = [\\, CX \\quad CN \\,] \\begin{bmatrix} x_a(t) \\\\ x_b(t) \\end{bmatrix} = [\\, I_p \\quad 0 \\,] \\begin{bmatrix} x_a(t) \\\\ x_b(t) \\end{bmatrix} = x_a(t) $$\n这证实了变换后状态的前 $p$ 个分量恰好是已测输出。剩下的 $n-p$ 个分量 $x_b(t)$ 是我们必须估计的状态的未测部分。\n\n变换后状态的动态由下式给出：\n$$ \\dot{\\bar{x}}(t) = T \\dot{x}(t) = T (A x(t) + B u(t)) = T A T^{-1} \\bar{x}(t) + T B u(t) $$\n我们定义变换后的系统矩阵 $\\bar{A} = T A T^{-1}$ 和 $\\bar{B} = T B$。我们根据 $\\bar{x}$ 的分块对它们进行分块：\n$$ \\bar{A} = \\begin{bmatrix} A_{aa} & A_{ab} \\\\ A_{ba} & A_{bb} \\end{bmatrix}, \\quad \\bar{B} = \\begin{bmatrix} B_a \\\\ B_b \\end{bmatrix} $$\n其中 $A_{aa} \\in \\mathbb{R}^{p \\times p}$，$A_{ab} \\in \\mathbb{R}^{p \\times (n-p)}$，$A_{ba} \\in \\mathbb{R}^{(n-p) \\times p}$，$A_{bb} \\in \\mathbb{R}^{(n-p) \\times (n-p)}$，$B_a \\in \\mathbb{R}^{p \\times m}$，$B_b \\in \\mathbb{R}^{(n-p) \\times m}$。\n新坐标系下的状态动态为：\n$$ \\dot{x}_a(t) = A_{aa} x_a(t) + A_{ab} x_b(t) + B_a u(t) $$\n$$ \\dot{x}_b(t) = A_{ba} x_a(t) + A_{bb} x_b(t) + B_b u(t) $$\n用已知测量值 $y(t)$ 替换 $x_a(t)$，我们得到：\n$$ \\dot{y}(t) = A_{aa} y(t) + A_{ab} x_b(t) + B_a u(t) $$\n$$ \\dot{x}_b(t) = A_{ba} y(t) + A_{bb} x_b(t) + B_b u(t) $$\n第一个方程通过关系 $A_{ab} x_b(t) = \\dot{y}(t) - A_{aa} y(t) - B_a u(t)$ 提供了对未测状态 $x_b(t)$ 的一种“测量”。这表明对偶 $(A_{bb}, A_{ab})$ 对于 $x_b$ 的动态表现得像一个系统-输出对。\n\n我们现在为 $x_b(t)$ 设计一个 Luenberger 型观测器。设 $\\hat{x}_b(t)$ 是 $x_b(t)$ 的估计。观测器动态的构造模仿了 $x_b(t)$ 的动态，并带有一个与输出估计误差成比例的修正项：\n$$ \\dot{\\hat{x}}_b(t) = A_{bb} \\hat{x}_b(t) + A_{ba} y(t) + B_b u(t) + L \\left( (\\dot{y} - A_{aa} y - B_a u) - A_{ab} \\hat{x}_b \\right) $$\n其中 $L \\in \\mathbb{R}^{(n-p) \\times p}$ 是观测器增益矩阵。项 $(\\dot{y} - A_{aa} y - B_a u)$ 是 $A_{ab} x_b$ 的“测量”值，而 $A_{ab} \\hat{x}_b$ 是其估计值。\n\n估计误差为 $e_b(t) = x_b(t) - \\hat{x}_b(t)$。其动态为：\n$$ \\dot{e}_b(t) = \\dot{x}_b(t) - \\dot{\\hat{x}}_b(t) $$\n$$ \\dot{e}_b(t) = (A_{ba} y + A_{bb} x_b + B_b u) - \\left( A_{bb} \\hat{x}_b + A_{ba} y + B_b u + L ((\\dot{y} - A_{aa} y - B_a u) - A_{ab} \\hat{x}_b) \\right) $$\n代入 $A_{ab} x_b = \\dot{y} - A_{aa} y - B_a u$：\n$$ \\dot{e}_b(t) = A_{bb} (x_b - \\hat{x}_b) - L (A_{ab} x_b - A_{ab} \\hat{x}_b) $$\n$$ \\dot{e}_b(t) = (A_{bb} - L A_{ab}) e_b(t) $$\n为使估计误差收敛到零，矩阵 $(A_{bb} - L A_{ab})$ 必须是赫尔维茨的（所有特征值的实部都必须严格为负）。现在的问题是选择一个增益 $L$ 来实现这一点。\n\n我们采用对偶性原理。对于系统矩阵为 $A$、输出矩阵为 $C$ 的观测器，其极点配置问题与系统矩阵为 $A^{\\top}$、输入矩阵为 $C^{\\top}$ 的控制器极点配置问题是对偶的。在我们的例子中，系统是 $(A_{bb}, A_{ab})$。因此，我们考虑具有状态空间对 $(\\mathcal{A}_d, \\mathcal{B}_d) = (A_{bb}^{\\top}, A_{ab}^{\\top})$ 的对偶控制系统。\n我们为这个对偶系统寻找一个状态反馈增益 $K_d$，即 $v = -K_d z$，使得闭环矩阵 $\\mathcal{A}_d - \\mathcal{B}_d K_d = A_{bb}^{\\top} - A_{ab}^{\\top} K_d$ 是赫尔维茨的。一个矩阵的特征值与其转置的特征值相同。因此，如果 $A_{bb}^{\\top} - A_{ab}^{\\top} K_d$ 是赫尔维茨的，那么它的转置 $(A_{bb}^{\\top} - A_{ab}^{\\top} K_d)^{\\top} = A_{bb} - K_d^{\\top} A_{ab}$ 也是赫尔维茨的。\n通过将其与误差动态矩阵 $(A_{bb} - L A_{ab})$ 进行比较，我们确定观测器增益为 $L = K_d^{\\top}$。\n\n问题指定使用连续时间 LQR 控制器来找到 $K_d$。对于对偶系统 $\\dot{z} = \\mathcal{A}_d z + \\mathcal{B}_d v$，以及 LQR 代价函数 $J = \\int_0^\\infty (z^{\\top} Q_d z + v^{\\top} R_d v) dt$，最优反馈增益为 $K_d = R_d^{-1} \\mathcal{B}_d^{\\top} P_d$，其中 $P_d$ 是连续时间代数黎卡提方程 (CARE) 的唯一对称半正定解：\n$$ \\mathcal{A}_d^{\\top} P_d + P_d \\mathcal{A}_d - P_d \\mathcal{B}_d R_d^{-1} \\mathcal{B}_d^{\\top} P_d + Q_d = 0 $$\n代入 $\\mathcal{A}_d = A_{bb}^{\\top}$ 和 $\\mathcal{B}_d = A_{ab}^{\\top}$：\n$$ (A_{bb}^{\\top})^{\\top} P_d + P_d A_{bb}^{\\top} - P_d A_{ab}^{\\top} R_d^{-1} (A_{ab}^{\\top})^{\\top} P_d + Q_d = 0 $$\n$$ A_{bb} P_d + P_d A_{bb}^{\\top} - P_d A_{ab}^{\\top} R_d^{-1} A_{ab} P_d + Q_d = 0 $$\n如果对 $(A_{bb}^{\\top}, A_{ab}^{\\top})$ 是可镇定的（这等价于对 $(A_{bb}, A_{ab})$ 是可检测的），并且 $Q_d$ 和 $R_d$ 分别是对称半正定和正定的，则 LQR 控制器保证闭环系统是稳定的。\n控制器增益为 $K_d = R_d^{-1} (A_{ab}^{\\top})^{\\top} P_d = R_d^{-1} A_{ab} P_d$。\n观测器增益则为 $L = K_d^{\\top} = (R_d^{-1} A_{ab} P_d)^{\\top} = P_d^{\\top} A_{ab}^{\\top} (R_d^{-1})^{\\top}$。由于 $P_d$ 和 $R_d$ 是对称的，这简化为 $L = P_d A_{ab}^{\\top} R_d^{-1}$。\n\n观测器动态包含 $\\dot{y}$ 项，这在实践中通常会带来问题。我们可以通过定义一个新的观测器状态 $z(t) = \\hat{x}_b(t) - L y(t)$ 来消除它。$z(t)$ 的动态为：\n$$ \\dot{z}(t) = \\dot{\\hat{x}}_b(t) - L \\dot{y}(t) $$\n使用 $\\dot{\\hat{x}}_b(t)$ 的表达式并化简，我们得到：\n$$ \\dot{z}(t) = (A_{bb} - L A_{ab}) \\hat{x}_b(t) + (A_{ba} - L A_{aa}) y(t) + (B_b - L B_a) u(t) $$\n代入 $\\hat{x}_b(t) = z(t) + L y(t)$：\n$$ \\dot{z}(t) = (A_{bb} - L A_{ab}) z(t) + [(A_{bb} - L A_{ab})L + A_{ba} - L A_{aa}] y(t) + [B_b - L B_a] u(t) $$\n这是观测器内部状态 $z(t)$ 的微分方程，它可以很容易地实现，因为它只依赖于已知信号 $y(t)$ 和 $u(t)$。\n\n为了仿真和验证，我们实现观测器的内部动态，初始条件为 $\\hat{x}_b(0)=0$，这意味着 $z(0) = -L y(0) = -L C x(0)$。在任何时刻 $t$，可以从测量输出 $y(t)$ 和观测器状态估计 $\\hat{x}_b(t)$ 使用逆变换重构完整的状态估计 $\\hat{x}(t)$：\n$$ \\hat{x}(t) = T^{-1} \\begin{bmatrix} y(t) \\\\ \\hat{x}_b(t) \\end{bmatrix} = [\\, X \\quad N \\,] \\begin{bmatrix} y(t) \\\\ \\hat{x}_b(t) \\end{bmatrix} = X y(t) + N \\hat{x}_b(t) = X y(t) + N(z(t) + L y(t)) $$\n至此完成了算法的推导。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_continuous_are, null_space\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates a reduced-order observer for LTI systems\n    using the duality with LQR control.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"A\": np.array([[0.2, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 2.0, 0.5]]),\n            \"B\": np.array([[0.0], [0.0], [1.0]]),\n            \"C\": np.array([[1.0, 0.0, 0.0]]),\n            \"Qd\": np.identity(2),\n            \"Rd\": np.array([[1.0]]),\n            \"x0\": np.array([0.5, -1.0, 1.0]),\n            \"u_func\": lambda t: 0.2,\n        },\n        {\n            \"A\": np.array([[0.0, 1.0, 1.0, 0.0], [-1.0, 0.0, 0.0, 1.0], [0.0, 0.0, 0.0, 1.0], [1.0, 0.0, 3.0, 0.2]]),\n            \"B\": np.array([[0.0], [0.0], [0.0], [1.0]]),\n            \"C\": np.array([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]]),\n            \"Qd\": np.identity(2),\n            \"Rd\": np.identity(2),\n            \"x0\": np.array([0.2, -0.5, 0.3, 1.0]),\n            \"u_func\": lambda t: 0.1 * np.sin(2 * t),\n        },\n        {\n            \"A\": np.array([[0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [-1.0, -1.0, -1.0]]),\n            \"B\": np.array([[0.0], [1.0], [0.0]]),\n            \"C\": np.identity(3),\n            \"Qd\": np.empty((0, 0)), \n            \"Rd\": np.empty((0, 0)),\n            \"x0\": np.array([-0.3, 0.4, -0.2]),\n            \"u_func\": lambda t: 0.0,\n        },\n    ]\n\n    T_sim = 5.0\n    dt = 0.002\n    error_tolerance = 1e-3\n    results = []\n\n    for case in test_cases:\n        A, B, C, Qd, Rd, x0, u_func = case.values()\n        n, m = B.shape\n        p = C.shape[0]\n\n        eigenvalue_check_passed = False\n        terminal_error_check_passed = False\n\n        if p == n:\n            # Full state measurement case\n            # No unmeasured dynamics, so no observer is needed.\n            # Eigenvalue condition on A_bb - L A_ab is vacuously true.\n            eigenvalue_check_passed = True\n            \n            # The state is fully known: y(t) = C x(t) = I x(t) = x(t).\n            # The estimate is perfect: hat(x)(t) = y(t).\n            # The error is identically zero.\n            terminal_error_norm = 0.0\n            terminal_error_check_passed = terminal_error_norm = error_tolerance\n\n            results.append(eigenvalue_check_passed and terminal_error_check_passed)\n            continue\n        \n        # 1. Construct State Transformation\n        # Right-inverse of C: X = C' * inv(C*C')\n        X = C.T @ np.linalg.inv(C @ C.T)\n        \n        # Basis for Null(C)\n        N = null_space(C)\n        \n        # Transformation matrices\n        T_inv = np.hstack([X, N])\n        T = np.linalg.inv(T_inv)\n\n        # 2. Transform System Matrices\n        A_bar = T @ A @ T_inv\n        B_bar = T @ B\n\n        # Partition transformed matrices\n        A_aa = A_bar[:p, :p]\n        A_ab = A_bar[:p, p:]\n        A_ba = A_bar[p:, :p]\n        A_bb = A_bar[p:, p:]\n        \n        B_a = B_bar[:p, :]\n        B_b = B_bar[p:, :]\n\n        # 3. Design Observer Gain L using LQR Duality\n        # Dual system matrices for controller design\n        A_dual = A_bb.T\n        B_dual = A_ab.T\n        \n        # Solve the Continuous-time Algebraic Riccati Equation (CARE) for the dual system\n        # scipy.linalg.solve_continuous_are(A, B, Q, R) solves A'X + XA - XBR^-1B'X + Q = 0\n        try:\n            Pd = solve_continuous_are(A_dual, B_dual, Qd, Rd)\n        except np.linalg.LinAlgError:\n            # Handle cases where ARE might not have a solution (e.g., not stabilizable)\n            results.append(False)\n            continue\n\n        # Observer gain L = Pd * A_ab' * inv(Rd)\n        L = Pd @ A_ab.T @ np.linalg.inv(Rd)\n        \n        # 4. Verify Observer Stability\n        A_obs_err = A_bb - L @ A_ab\n        eigvals = np.linalg.eigvals(A_obs_err)\n        eigenvalue_check_passed = np.all(np.real(eigvals)  0)\n\n        # 5. Set up and run simulation\n        # Observer state-space matrices (form that avoids dy/dt)\n        F = A_obs_err\n        G = F @ L + A_ba - L @ A_aa\n        H = B_b - L @ B_a\n        \n        # Initial conditions\n        x = x0.copy()\n        y0 = C @ x0\n        z = -L @ y0  # z(0) = hat_x_b(0) - L*y(0), with hat_x_b(0) = 0\n        \n        time_steps = np.arange(0, T_sim, dt)\n        \n        # Euler integration\n        for t in time_steps:\n            u = u_func(t)\n            \n            # System dynamics\n            x_dot = A @ x + B @ np.atleast_1d(u)\n            \n            # Observer dynamics\n            y = C @ x\n            z_dot = F @ z + G @ y + H @ np.atleast_1d(u)\n            \n            # Update states\n            x += x_dot * dt\n            z += z_dot * dt\n            \n        # 6. Compute Terminal Error\n        # Reconstruct full state estimate at t=T\n        y_T = C @ x\n        hat_x_b_T = z + L @ y_T\n        hat_x_T = X @ y_T + N @ hat_x_b_T\n        \n        terminal_error_norm = np.linalg.norm(x - hat_x_T)\n        terminal_error_check_passed = terminal_error_norm = error_tolerance\n        \n        results.append(eigenvalue_check_passed and terminal_error_check_passed)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2737300"}]}