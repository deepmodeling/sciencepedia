{"hands_on_practices": [{"introduction": "求解线性时不变(LTI)系统的关键在于理解其固有模态。通过对系统矩阵进行特征分解，我们可以将复杂的耦合动态解耦为一组简单的一阶系统，每个系统都沿着一个特征向量演化，其速率由相应的特征值决定。这个练习 [@problem_id:1611524] 将带你实践这一核心方法，通过计算一个具体系统的解析解，加深你对模态、稳定性和系统响应之间关系的理解。", "problem": "一个线性时不变（LTI）系统由齐次状态空间方程 $\\dot{x}(t) = Ax(t)$ 描述，其中 $x(t) = \\begin{pmatrix} x_1(t) \\\\ x_2(t) \\end{pmatrix}$ 是状态向量。系统矩阵 $A$ 由下式给出：\n$$\nA = \\begin{pmatrix} -2  1 \\\\ 2  -3 \\end{pmatrix}\n$$\n给定系统在 $t=0$ 时的初始状态为 $x(0) = \\begin{pmatrix} 2 \\\\ 5 \\end{pmatrix}$，求对于所有 $t \\ge 0$ 的状态向量 $x(t)$。将你的答案表示为一个列向量，其分量是 $t$ 的函数。", "solution": "对于常数矩阵 $A$ 的齐次LTI系统 $\\dot{x}(t)=Ax(t)$，其状态轨迹为 $x(t)=\\exp(At)x(0)$。为了计算 $\\exp(At)$，我们通过其特征值和特征向量来对角化 $A$。\n\n计算特征多项式：\n$$\n\\det(A-\\lambda I)=\\det\\begin{pmatrix}-2-\\lambda  1 \\\\ 2  -3-\\lambda\\end{pmatrix}=(\\lambda+2)(\\lambda+3)-2=\\lambda^{2}+5\\lambda+4.\n$$\n求解 $\\lambda^{2}+5\\lambda+4=0$ 得到特征值 $\\lambda_{1}=-1$ 和 $\\lambda_{2}=-4$。\n\n寻找对应的特征向量。对于 $\\lambda_{1}=-1$，求解 $(A+I)v=0$：\n$$\n\\begin{pmatrix}-1  1 \\\\ 2  -2\\end{pmatrix}\\begin{pmatrix}v_{1}\\\\v_{2}\\end{pmatrix}=0 \\implies v_{2}=v_{1},\n$$\n因此选择 $v_{1}=\\begin{pmatrix}1\\\\1\\end{pmatrix}$。对于 $\\lambda_{2}=-4$，求解 $(A+4I)v=0$：\n$$\n\\begin{pmatrix}2  1 \\\\ 2  1\\end{pmatrix}\\begin{pmatrix}v_{1}\\\\v_{2}\\end{pmatrix}=0 \\implies v_{2}=-2v_{1},\n$$\n因此选择 $v_{2}=\\begin{pmatrix}1\\\\-2\\end{pmatrix}$。\n\n通解是沿特征向量的线性组合：\n$$\nx(t)=c_{1}\\exp(-t)\\begin{pmatrix}1\\\\1\\end{pmatrix}+c_{2}\\exp(-4t)\\begin{pmatrix}1\\\\-2\\end{pmatrix}.\n$$\n根据初始条件 $x(0)=\\begin{pmatrix}2\\\\5\\end{pmatrix}$ 来确定 $c_{1},c_{2}$：\n$$\n\\begin{pmatrix}2\\\\5\\end{pmatrix}=c_{1}\\begin{pmatrix}1\\\\1\\end{pmatrix}+c_{2}\\begin{pmatrix}1\\\\-2\\end{pmatrix}=\\begin{pmatrix}c_{1}+c_{2}\\\\c_{1}-2c_{2}\\end{pmatrix}.\n$$\n这给出了线性方程组 $c_{1}+c_{2}=2$ 和 $c_{1}-2c_{2}=5$。两式相减得到 $3c_{2}=-3$，所以 $c_{2}=-1$，进而 $c_{1}=3$。\n\n因此，\n$$\nx(t)=3\\exp(-t)\\begin{pmatrix}1\\\\1\\end{pmatrix}-\\exp(-4t)\\begin{pmatrix}1\\\\-2\\end{pmatrix}=\\begin{pmatrix}3\\exp(-t)-\\exp(-4t)\\\\3\\exp(-t)+2\\exp(-4t)\\end{pmatrix}.\n$$\n这同时满足微分方程和初始条件。", "answer": "$$\\boxed{\\begin{pmatrix}3\\exp(-t)-\\exp(-4t)\\\\3\\exp(-t)+2\\exp(-4t)\\end{pmatrix}}$$", "id": "1611524"}, {"introduction": "虽然解析解为我们提供了深刻的洞见，但在实践中，我们常常需要依赖数值方法来仿真复杂系统的行为。然而，数值方法的稳定性并非理所当然，选择不当的时间步长可能导致结果发散。这个练习 [@problem_id:1611510] 挑战你从理论层面分析数值稳定性，利用Gershgorin圆盘定理为一个对角占优系统推导保证显式欧拉法稳定性的时间步长上限。", "problem": "一位控制系统工程师正在分析一个线性时不变(LTI)系统的仿真数值稳定性。该系统由齐次状态方程 $\\frac{d\\mathbf{x}}{dt} = A\\mathbf{x}$ 描述，其中 $\\mathbf{x}(t)$ 是 $\\mathbb{R}^n$ 中的状态向量，$A$ 是一个 $n \\times n$ 的常数矩阵。该仿真使用显式(前向)欧拉法在离散时间步长上近似状态，由 $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\Delta t \\, A \\mathbf{x}_k$ 给出，其中 $\\Delta t$ 是时间步长。\n\n矩阵 $A$ 的确切值未知，但通过系统辨识实验，已确定 $A$ 满足以下性质：\n1.  所有对角元 $a_{ii}$ 均为实数且为负。\n2.  该矩阵是严格对角占优的，即对于每一行 $i$，对角元的绝对值大于该行所有其他元素的绝对值之和：$|a_{ii}|  \\sum_{j \\neq i} |a_{ij}|$。这个性质保证了连续时间系统是稳定的。\n\n两个量化该矩阵性质的关键参数已被测得：\n-   $S = \\max_{i} |a_{ii}|$, 任意对角元绝对值的最大值。\n-   $d = \\max_{i} \\sum_{j \\neq i} |a_{ij}|$, 非对角元绝对值的最大行和。\n\n为确保仿真不会因数值不稳定性而发散，必须选择一个合适的时间步长 $\\Delta t$。请根据参数 $S$ 和 $d$，推导出一个 $\\Delta t$ 的上界，该上界能保证对于*任何*满足给定条件的矩阵 $A$，显式欧拉仿真的数值稳定性。请用解析表达式表示您的答案。", "solution": "LTI系统的显式欧拉更新为 $\\mathbf{x}_{k+1} = (I + \\Delta t\\,A)\\mathbf{x}_{k}$。数值稳定性（不发散）得到保证，当且仅当谱半径满足 $\\rho(I + \\Delta t\\,A)  1$。\n\n一个充分且可计算的条件是应用盖尔圆定理于矩阵 $I + \\Delta t\\,A$。对于第 $i$ 行，记 $a_{ii} = -s_{i}$，其中 $s_{i} = |a_{ii}|  0$，并设 $r_{i} = \\sum_{j \\neq i} |a_{ij}|$。严格对角占优给出对所有 $i$ 都有 $r_{i}  s_{i}$。定义 $S = \\max_{i} s_{i}$ 和 $d = \\max_{i} r_{i}$。那么从对 $r_{i}  s_{i}$ 取最大值可得 $d  S$。\n\n矩阵 $I + \\Delta t\\,A$ 第 $i$ 行的盖尔圆盘中心为 $c_{i} = 1 + \\Delta t\\,a_{ii} = 1 - \\Delta t\\,s_{i}$，半径为 $R_{i} = \\Delta t\\,r_{i}$。如果对于每个 $i$，整个圆盘 $B(c_{i}, R_{i})$ 都严格位于单位圆盘 $\\{z: |z|  1\\}$ 内部，那么 $I + \\Delta t\\,A$ 的所有特征值都位于 $\\{z: |z|  1\\}$ 内，因此 $\\rho(I + \\Delta t\\,A)  1$。包含关系 $B(c_{i}, R_{i}) \\subset \\{z: |z|  1\\}$ 可由以下条件保证：\n$$\n|c_{i}| + R_{i} = |1 - \\Delta t\\,s_{i}| + \\Delta t\\,r_{i}  1 \\quad \\text{对所有 } i.\n$$\n我们现在推导一个（用 $S$ 和 $d$ 表示的）统一的 $\\Delta t$ 界限，使得上述不等式对任何允许的 $(s_{i}, r_{i})$ 都成立。\n\n对每一行 $i$ 考虑两种情况：\n\n1) 如果 $\\Delta t\\,s_{i} \\leq 1$，则 $|1 - \\Delta t\\,s_{i}| = 1 - \\Delta t\\,s_{i}$ 且\n$$\n|1 - \\Delta t\\,s_{i}| + \\Delta t\\,r_{i} = 1 - \\Delta t\\,(s_{i} - r_{i})  1,\n$$\n因为根据严格对角占优有 $s_{i} - r_{i} > 0$。因此，满足 $\\Delta t\\,s_{i} \\leq 1$ 的行不会施加进一步的限制。\n\n2) 如果 $\\Delta t\\,s_{i} > 1$，则 $|1 - \\Delta t\\,s_{i}| = \\Delta t\\,s_{i} - 1$。我们要求：\n$$\n(\\Delta t\\,s_{i} - 1) + \\Delta t\\,r_{i}  1 \\implies \\Delta t\\,(s_i + r_i)  2\n$$\n为了确保这个条件对所有可能的 $s_i$ 和 $r_i$ 都成立，我们必须考虑最坏的情况。由于 $s_i \\le S$ 且 $r_i \\le d$，我们有：\n$$\n\\Delta t\\,(s_i + r_i) \\le \\Delta t\\,(S + d)\n$$\n因此，一个统一的充分条件是\n$$\n\\Delta t\\,(S + d)  2 \\implies \\Delta t  \\frac{2}{S + d}.\n$$\n因为 $d  S$，所以这个界是正的。它保证了对于所有行 $i$ 和任何满足所述性质的矩阵 $A$，都有 $|1 - \\Delta t\\,s_{i}| + \\Delta t\\,r_{i}  1$。因此，$\\rho(I + \\Delta t\\,A)  1$，显式欧拉仿真是数值稳定的。一个能保证对任何此类 $A$ 都稳定的上界是 $\\frac{2}{S + d}$。", "answer": "$$\\boxed{\\frac{2}{S + d}}$$", "id": "1611510"}, {"introduction": "现实世界中的许多系统，从轨道力学到电力电子，其动态特性都随时间周期性变化，构成了线性时变(LTV)系统。Floquet理论为分析这类系统提供了强大的框架，它揭示了周期系统的长期行为可以通过一个等效的常数“生成元”矩阵来理解。这个高级编程练习 [@problem_id:2745820] 要求你通过数值积分实现Floquet分析的核心步骤，计算周期系统的 monodromy 矩阵和生成元矩阵，从而将抽象的理论转化为可执行的算法。", "problem": "考虑一个连续时间线性时变 (LTV) 系统的齐次状态方程，该方程由常微分方程 (ODE) $\\dot{x}(t)=A(t)\\,x(t)$ 定义，其中 $A(t)$ 是一个 $2\\times 2$ 的 $T$-周期矩阵，即对所有 $t$ 都有 $A(t+T)=A(t)$。状态转移矩阵 $\\Phi(t,t_{0})$ 是满足 $\\frac{d}{dt}\\Phi(t,t_{0})=A(t)\\,\\Phi(t,t_{0})$ 和 $\\Phi(t_{0},t_{0})=I$ 的唯一矩阵函数，其中 $I$ 是单位矩阵。一个周期内的单值矩阵为 $M=\\Phi(T,0)$，它编码了从单位矩阵开始，经过一个周期后的净演化。一个常数生成元矩阵 $R$ 可以在 $M$ 的特征值均不位于非正实轴上的条件下，通过矩阵对数与 $M$ 关联，从而使得主矩阵对数存在。您的程序必须通过对矩阵 ODE 进行时间有序积分来数值计算 $M$，然后使用主矩阵对数从 $M$ 计算出 $R$。\n\n算法要求：\n- 通过直接对矩阵 ODE $\\dot{\\Phi}(t,0)=A(t)\\,\\Phi(t,0)$（初始条件为 $\\Phi(0,0)=I$）进行积分来计算 $\\Phi(t,0)$。这通过随时间向前演化，数值上实现了时间有序指数。\n- 在最终时间 $T$ 处，设置 $M=\\Phi(T,0)$。\n- 通过将主矩阵对数应用于 $M$ 并按 $1/T$ 缩放，从 $M$ 计算 $R$ 作为由周期缩放的主矩阵对数，即计算一个满足 $\\exp(R\\,T)=M$ 的矩阵 $R$。\n\n角度单位说明：当出现三角函数时，其参数应解释为弧度。\n\n测试套件：\n为以下四种情况实现算法。对于每种情况，计算下面指定的标量误差。所有数值常数都是无量纲的，所有角度都以弧度为单位。\n\n- 情况 $\\mathbf{1}$（恒定、可交换基准）：\n  - 周期：$T=3$。\n  - 矩阵：$A(t)=\\begin{bmatrix}-0.2  0\\\\ 0  -0.5\\end{bmatrix}$ 对所有 $t$。\n  - 期望生成元：$R_{\\text{exp}}=\\begin{bmatrix}-0.2  0\\\\ 0  -0.5\\end{bmatrix}$。\n  - 此情况所需的标量输出：$e_{1}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{2}$（对角周期、零均值，边界条件为 $M=I$）：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\operatorname{diag}\\left(\\sin(t),-\\sin(t)\\right)$。\n  - 期望生成元：$R_{\\text{exp}}=\\begin{bmatrix}0  0\\\\ 0  0\\end{bmatrix}$。\n  - 所需的标量输出：$e_{2}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{3}$（对角周期、非零均值，可交换但时变）：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\operatorname{diag}\\left(-0.1+0.05\\sin(2t),\\,-0.3+0.02\\cos(3t)\\right)$。\n  - 期望生成元：$R_{\\text{exp}}=\\operatorname{diag}\\left(-0.1,\\,-0.3\\right)$。\n  - 所需的标量输出：$e_{3}=\\max_{i,j}\\left|R_{ij}-(R_{\\text{exp}})_{ij}\\right|$。\n\n- 情况 $\\mathbf{4}$（不可交换周期，重构检查）：\n  - 周期：$T=2\\pi$。\n  - 矩阵：$A(t)=\\begin{bmatrix}0  1+0.2\\sin(2t)\\\\ -\\left(1.0+0.1\\cos(t)\\right)  0\\end{bmatrix}$。\n  - 未提供闭式解的期望生成元。\n  - 所需的标量输出：$e_{4}=\\left\\|\\exp(R\\,T)-M\\right\\|_{F}$，其中 $\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含列表 $\\left[e_{1},e_{2},e_{3},e_{4}\\right]$，格式为逗号分隔的 Python 风格列表。\n- 每个浮点数必须以科学记数法打印，小数点后精确到六位数字（例如，$1.234567\\text{e-}04$）。\n- 不应打印任何其他文本。\n\n您的实现必须是完全自包含的，不得要求任何用户输入，并且必须对 $\\Phi(t,0)$ 使用矩阵 ODE 的时间有序数值积分，然后对 $M$ 使用主矩阵对数以获得 $R$。", "solution": "解决此问题的核心是遵循弗洛凯理论的算法步骤，对给定的周期性LTV系统进行数值分析。主要包括三个步骤：数值积分计算单值矩阵 $M$，使用矩阵对数计算生成元矩阵 $R$，以及根据每个测试用例的要求计算误差。\n\n**步骤 1：计算单值矩阵 $M$**\n\n单值矩阵 $M = \\Phi(T, 0)$ 是状态转移矩阵在一个周期 $T$ 后的值。$\\Phi(t, 0)$ 本身是矩阵微分方程 $\\frac{d}{dt}\\Phi(t, 0) = A(t)\\Phi(t, 0)$ 的解，其初始条件为 $\\Phi(0, 0) = I$（单位矩阵）。\n\n由于 $A(t)$ 不一定是常数矩阵，我们不能直接使用标准的矩阵指数。相反，我们必须对这个矩阵ODE进行数值积分。我们将 $2 \\times 2$ 的矩阵 $\\Phi$ 展平为一个 $4 \\times 1$ 的向量 $y$，以便使用标准的ODE求解器（如Python中SciPy库的 `solve_ivp`）。\n\n- **状态向量**: $y(t) = \\text{flatten}(\\Phi(t, 0))$\n- **微分方程**: $\\dot{y}(t) = \\text{flatten}(A(t) \\cdot \\text{reshape}(y(t)))$\n- **初始条件**: $y(0) = \\text{flatten}(I)$\n\n我们从 $t=0$ 积分到 $t=T$。积分结束时得到的向量 $y(T)$ 被重塑回 $2 \\times 2$ 矩阵，即为单值矩阵 $M$。\n\n**步骤 2：计算生成元矩阵 $R$**\n\n根据弗洛凯理论，单值矩阵 $M$ 和生成元矩阵 $R$ 之间存在关系 $M = \\exp(RT)$。为了求得 $R$，我们取矩阵对数：\n$$\nR = \\frac{1}{T}\\log(M)\n$$\n这里使用主矩阵对数（`scipy.linalg.logm`），它在 $M$ 的特征值均不位于非正实轴上的条件下是唯一确定的。\n\n**步骤 3：分析特定情况并计算误差**\n\n- **情况 1, 2, 3 (可交换系统)**: 在这三种情况下，$A(t)$ 在所有时刻都是对角的或常数的，因此对于任意 $t_1, t_2$ 都有 $[A(t_1), A(t_2)] = 0$。对于这类可交换系统，状态转移矩阵可以简化为 $\\Phi(T, 0) = \\exp\\left(\\int_0^T A(\\tau) d\\tau\\right)$。因此，生成元就是 $A(t)$ 在一个周期内的平均值 $R = \\frac{1}{T}\\int_0^T A(\\tau) d\\tau$。这为我们提供了与数值结果进行比较的精确期望值 $R_{\\text{exp}}$。\n    - 情况1: $R = \\frac{1}{3}\\int_0^3 A d\\tau = A = R_{\\text{exp}}$。\n    - 情况2: $\\int_0^{2\\pi} \\sin(t) dt = 0$，所以 $R = \\bar{A} = 0 = R_{\\text{exp}}$。\n    - 情况3: 周期性项 $\\sin(2t)$ 和 $\\cos(3t)$ 在周期 $2\\pi$ 上的积分为零，只留下常数项。因此 $R = \\text{diag}(-0.1, -0.3) = R_{\\text{exp}}$。\n\n- **情况 4 (不可交换系统)**: $A(t)$ 的非对角项导致 $[A(t_1), A(t_2)] \\neq 0$。因此，必须进行完整的数值积分。由于没有解析解，我们通过重构单值矩阵来验证计算的自洽性。误差 $e_4$ 通过计算 $\\|\\exp(RT) - M\\|_F$ 来衡量，其中 $\\|\\cdot\\|_F$ 是弗罗贝尼乌斯范数。这个误差应该接近于数值计算的精度。\n\n通过在数值上执行这些步骤，我们可以得到每个测试用例的生成元矩阵 $R$，并计算出相应的误差 $e_1, e_2, e_3, e_4$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import logm, expm\n\ndef solve():\n    \"\"\"\n    Computes the generator matrix R for four LTV systems and calculates\n    the specified error metrics.\n    \"\"\"\n\n    def compute_R_and_M(A_func, T):\n        \"\"\"\n        Computes the monodromy matrix M and the generator R for a given\n        system A(t) and period T.\n        \"\"\"\n        # Define the ODE system for the flattened state-transition matrix Phi.\n        # The state vector y has 4 elements, representing the 2x2 matrix Phi.\n        def ode_system(t, y):\n            Phi = y.reshape((2, 2))\n            A = A_func(t)\n            dPhi_dt = A @ Phi\n            return dPhi_dt.flatten()\n\n        # Initial condition Phi(0, 0) = I, flattened to a vector.\n        y0 = np.identity(2, dtype=float).flatten()\n        \n        # Numerically integrate the ODE from t=0 to t=T.\n        # We use a high-precision solver configuration to ensure accuracy.\n        # We only need the solution at the final time T.\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=[0, T],\n            y0=y0,\n            method='RK45',\n            t_eval=[T],\n            rtol=1e-13,\n            atol=1e-13\n        )\n        \n        # The monodromy matrix M is the state-transition matrix at t=T.\n        M = sol.y[:, -1].reshape((2, 2))\n        \n        # Compute the generator matrix R using the principal matrix logarithm.\n        R = logm(M) / T\n        \n        return R, M\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"case_id\": 1,\n            \"A_func\": lambda t: np.array([[-0.2, 0.0], [0.0, -0.5]]),\n            \"T\": 3.0,\n            \"R_exp\": np.array([[-0.2, 0.0], [0.0, -0.5]]),\n        },\n        {\n            \"case_id\": 2,\n            \"A_func\": lambda t: np.diag([np.sin(t), -np.sin(t)]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": np.zeros((2, 2)),\n        },\n        {\n            \"case_id\": 3,\n            \"A_func\": lambda t: np.diag([-0.1 + 0.05 * np.sin(2*t), -0.3 + 0.02 * np.cos(3*t)]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": np.diag([-0.1, -0.3]),\n        },\n        {\n            \"case_id\": 4,\n            \"A_func\": lambda t: np.array([[0.0, 1.0 + 0.2 * np.sin(2*t)], [-(1.0 + 0.1 * np.cos(t)), 0.0]]),\n            \"T\": 2 * np.pi,\n            \"R_exp\": None, # No analytical R_exp is provided\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        A_func = case[\"A_func\"]\n        T = case[\"T\"]\n        R_exp = case[\"R_exp\"]\n        \n        R, M = compute_R_and_M(A_func, T)\n        \n        if case[\"case_id\"] in [1, 2, 3]:\n            # For cases 1-3, the error is the maximum absolute difference\n            # between the computed R and the expected R_exp.\n            error = np.max(np.abs(R - R_exp))\n        else: # case_id == 4\n            # For case 4, the error is a self-consistency check: the Frobenius norm\n            # of the difference between the reconstructed M and the original M.\n            M_reconstructed = expm(R * T)\n            error = np.linalg.norm(M_reconstructed - M, 'fro')\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    # e.g., [1.234567e-08,_..._]\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "2745820"}]}