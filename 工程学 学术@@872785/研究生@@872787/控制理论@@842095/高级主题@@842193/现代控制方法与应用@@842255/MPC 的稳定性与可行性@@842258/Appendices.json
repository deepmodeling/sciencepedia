{"hands_on_practices": [{"introduction": "在模型预测控制（MPC）中，保证闭环稳定性的一个关键技术是使用终端代价函数作为李雅普诺夫函数。这个练习将带你亲手实践这一核心思想，通过求解离散时间李雅普诺夫方程，计算出二次终端代价函数 $V(x) = x^{\\top} P x$ 中的关键矩阵 $P$。这不仅能加深你对李雅普诺夫稳定性理论的理解，也揭示了其在MPC控制器设计中的具体应用。", "problem": "考虑在模型预测控制（MPC）稳定性分析中使用的离散时间线性时不变系统，\n$$x_{k+1} = A x_k + B u_k,$$\n其状态反馈控制律为\n$$u_k = K x_k,$$\n二次阶段成本为\n$$\\ell(x_k,u_k) = x_k^{\\top} Q x_k + u_k^{\\top} R u_k.$$\n假设闭环矩阵 $A_{K} \\coloneqq A + B K$ 是舒尔稳定的（所有特征值都严格位于单位圆盘内）。MPC 的一个标准终端成本候选是二次李雅普诺夫函数\n$$V(x) = x^{\\top} P x,$$\n其中 $P \\succ 0$ 是以下离散时间李雅普诺夫方程的解\n$$P = A_{K}^{\\top} P A_{K} + \\left(Q + K^{\\top} R K\\right).$$\n此选择通过确保李雅普诺夫下降条件来保证递归可行性和闭环稳定性。\n\n对于以下具体数据\n$$A=\\begin{bmatrix}1  1\\\\ 0  1\\end{bmatrix},\\quad B=\\begin{bmatrix}0\\\\ 1\\end{bmatrix},\\quad K=\\begin{bmatrix}-1  -2\\end{bmatrix},\\quad Q=I,\\quad R=I,$$\n执行以下操作：\n1) 计算求解上述离散时间李雅普诺夫方程的唯一对称正定矩阵 $P$。\n2) 使用您计算出的 $P$，验证对所有 $x$ 成立的李雅普诺夫下降不等式，\n$$V(x^{+})-V(x) \\leq -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right),$$\n其中 $x^{+} = A_{K} x$。\n\n请以精确的 $2 \\times 2$ 矩阵 $P$（各项为有理数，无四舍五入）的形式提供您的最终答案。最终答案中不要包含任何不等式。", "solution": "该问题是关于反馈控制下线性离散时间系统稳定性分析的一个标准练习，特别涉及二次李雅普诺夫函数的构造。该问题提法恰当且科学上合理。我将继续进行求解。\n\n任务是从离散时间代数李雅普诺夫方程中求解对称正定矩阵 $P$：\n$$P = A_{K}^{\\top} P A_{K} + \\left(Q + K^{\\top} R K\\right)$$\n并随后验证李雅普诺夫下降条件。\n\n首先，我们必须计算闭环系统矩阵 $A_K = A + BK$。给定的矩阵是：\n$$A = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix}, \\quad B = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}, \\quad K = \\begin{bmatrix} -1  -2 \\end{bmatrix}$$\n乘积 $BK$ 是：\n$$BK = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\begin{bmatrix} -1  -2 \\end{bmatrix} = \\begin{bmatrix} 0 \\times (-1)  0 \\times (-2) \\\\ 1 \\times (-1)  1 \\times (-2) \\end{bmatrix} = \\begin{bmatrix} 0  0 \\\\ -1  -2 \\end{bmatrix}$$\n因此，闭环矩阵 $A_K$ 是：\n$$A_K = A + BK = \\begin{bmatrix} 1  1 \\\\ 0  1 \\end{bmatrix} + \\begin{bmatrix} 0  0 \\\\ -1  -2 \\end{bmatrix} = \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n问题指出 $A_K$ 是舒尔稳定的。我们来确认这一点。特征方程为 $\\det(A_K - \\lambda I) = 0$。\n$$\\det \\left( \\begin{bmatrix} 1-\\lambda  1 \\\\ -1  -1-\\lambda \\end{bmatrix} \\right) = (1-\\lambda)(-1-\\lambda) - (1)(-1) = -1 - \\lambda + \\lambda + \\lambda^2 + 1 = \\lambda^2 = 0$$\n特征值为 $\\lambda_{1,2} = 0$。由于所有特征值的模 $|\\lambda| = 0  1$，矩阵 $A_K$ 确实是舒尔稳定的，这保证了对于任何正定权重矩阵 $Q + K^{\\top} R K$，李雅普诺夫方程都存在唯一的正定解 $P$。\n\n接下来，我们计算阶段成本的总权重矩阵，记为 $Q_{cl} = Q + K^{\\top} R K$。给定 $Q = I$ 和 $R = I$。由于控制输入 $u_k = Kx_k$ 是一个标量，所以 $R$ 是标量 $1$。\n$$K^{\\top} R K = \\begin{bmatrix} -1 \\\\ -2 \\end{bmatrix} (1) \\begin{bmatrix} -1  -2 \\end{bmatrix} = \\begin{bmatrix} (-1)(-1)  (-1)(-2) \\\\ (-2)(-1)  (-2)(-2) \\end{bmatrix} = \\begin{bmatrix} 1  2 \\\\ 2  4 \\end{bmatrix}$$\n因此，$Q_{cl}$ 是：\n$$Q_{cl} = Q + K^{\\top} R K = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} + \\begin{bmatrix} 1  2 \\\\ 2  4 \\end{bmatrix} = \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix}$$\n李雅普诺夫方程为 $P = A_K^{\\top} P A_K + Q_{cl}$。设 $P$ 为对称矩阵 $P = \\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix}$。我们必须求解其元素。\n首先，我们计算 $A_K^{\\top} P A_K$ 项：\n$$A_K^{\\top} P A_K = \\begin{bmatrix} 1  -1 \\\\ 1  -1 \\end{bmatrix} \\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n$$= \\begin{bmatrix} p_{11}-p_{12}  p_{12}-p_{22} \\\\ p_{11}-p_{12}  p_{12}-p_{22} \\end{bmatrix} \\begin{bmatrix} 1  1 \\\\ -1  -1 \\end{bmatrix}$$\n$$= \\begin{bmatrix} (p_{11}-p_{12}) - (p_{12}-p_{22})  (p_{11}-p_{12}) - (p_{12}-p_{22}) \\\\ (p_{11}-p_{12}) - (p_{12}-p_{22})  (p_{11}-p_{12}) - (p_{12}-p_{22}) \\end{bmatrix}$$\n$$= \\begin{bmatrix} p_{11}-2p_{12}+p_{22}  p_{11}-2p_{12}+p_{22} \\\\ p_{11}-2p_{12}+p_{22}  p_{11}-2p_{12}+p_{22} \\end{bmatrix}$$\n设标量值 $c = p_{11}-2p_{12}+p_{22}$。则 $A_K^{\\top} P A_K = c \\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$。\n将此代入李雅普诺夫方程：\n$$\\begin{bmatrix} p_{11}  p_{12} \\\\ p_{12}  p_{22} \\end{bmatrix} = \\begin{bmatrix} c  c \\\\ c  c \\end{bmatrix} + \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix} = \\begin{bmatrix} c+2  c+2 \\\\ c+2  c+5 \\end{bmatrix}$$\n通过比较元素，我们得到一个方程组：\n1) $p_{11} = c+2$\n2) $p_{12} = c+2$\n3) $p_{22} = c+5$\n由方程 1) 和 2)，我们得到 $p_{11} = p_{12}$。\n现在我们将这些代入 $c$ 的定义中：\n$$c = p_{11} - 2p_{12} + p_{22} = (c+2) - 2(c+2) + (c+5)$$\n$$c = c+2 - 2c-4 + c+5 = (c-2c+c) + (2-4+5) = 0 \\cdot c + 3$$\n$$c = 3$$\n使用这个值，我们求出 $P$ 的元素：\n$$p_{11} = c+2 = 3+2 = 5$$\n$$p_{12} = c+2 = 3+2 = 5$$\n$$p_{22} = c+5 = 3+5 = 8$$\n因此，解是矩阵：\n$$P = \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix}$$\n该矩阵是对称的。我们使用西尔维斯特准则（Sylvester's criterion）检查其正定性。主子式为 $5  0$ 和 $\\det(P) = 5 \\times 8 - 5 \\times 5 = 40 - 25 = 15  0$。两者都为正，因此 $P$ 是正定的。这完成了问题的第一部分。\n\n对于第二部分，我们必须验证李雅普诺夫下降不等式：\n$$V(x^{+}) - V(x) \\leq -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right)$$\n其中 $V(x) = x^{\\top} P x$ 且 $x^{+} = A_K x$。\n左边（LHS）是：\n$$V(x^{+}) - V(x) = (A_K x)^{\\top} P (A_K x) - x^{\\top} P x = x^{\\top} (A_K^{\\top} P A_K - P) x$$\n右边（RHS）是：\n$$-\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right) = -x^{\\top} (Q + K^{\\top} R K) x$$\n该不等式等价于证明 $x^{\\top} (A_K^{\\top} P A_K - P) x \\leq -x^{\\top} (Q + K^{\\top} R K) x$。\n根据李雅普诺夫方程 $P = A_K^{\\top} P A_K + Q + K^{\\top} R K$ 对 $P$ 的定义，我们可以将其重新排列为：\n$$A_K^{\\top} P A_K - P = -(Q + K^{\\top} R K)$$\n这意味着定义不等式两边二次型的矩阵不仅仅是由一个不等式关联，它们实际上是相等的。将这个等式代入不等式的左边，得到：\n$$x^{\\top} (-(Q + K^{\\top} R K)) x = -x^{\\top} (Q + K^{\\top} R K) x$$\n这恰好是右边。因此，对于求解李雅普诺夫方程的矩阵 $P$，该关系以等式形式成立：\n$$V(x^{+}) - V(x) = -\\left(x^{\\top} Q x + x^{\\top} K^{\\top} R K x\\right)$$\n由于等式意味着“小于或等于”条件成立，因此通过 $P$ 的构造，该不等式被不证自明地验证了。为求详尽，我们可以重新代入我们计算出的值，以证明矩阵等式 $A_K^{\\top} P A_K - P = -(Q + K^{\\top} R K)$ 成立。\n我们计算得出 $A_K^{\\top} P A_K = \\begin{bmatrix} 3  3 \\\\ 3  3 \\end{bmatrix}$ 和 $P = \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix}$。\n$$A_K^{\\top} P A_K - P = \\begin{bmatrix} 3  3 \\\\ 3  3 \\end{bmatrix} - \\begin{bmatrix} 5  5 \\\\ 5  8 \\end{bmatrix} = \\begin{bmatrix} -2  -2 \\\\ -2  -5 \\end{bmatrix}$$\n并且我们计算得出 $Q_{cl} = Q + K^{\\top} R K = \\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix}$。\n$$-(Q + K^{\\top} R K) = -\\begin{bmatrix} 2  2 \\\\ 2  5 \\end{bmatrix} = \\begin{bmatrix} -2  -2 \\\\ -2  -5 \\end{bmatrix}$$\n两个矩阵完全相同，这证实了我们对 $P$ 的解是正确的，并验证了该条件。", "answer": "$$\\boxed{\\begin{pmatrix} 5  5 \\\\ 5  8 \\end{pmatrix}}$$", "id": "2746597"}, {"introduction": "在实际应用中，系统常受到未知但有界的干扰，这给满足状态和输入约束带来了挑战。为了在这种不确定性下保证安全性与可行性，我们需要对约束进行“紧缩”处理。这个练习将指导你计算最小鲁棒正不变（RPI）集，它描述了干扰可能导致的状态偏差的累积效应，并量化了为保证鲁棒可行性所必需的约束边界收缩量 [@problem_id:2746575]。", "problem": "考虑一个在模型预测控制 (MPC) 下的离散时间线性时不变 (LTI) 闭环误差系统，其动态方程为 $e_{k+1} = A_{K} e_{k} + w_{k}$，并带有加性有界扰动，其中 $A_{K} \\in \\mathbb{R}^{n \\times n}$ 且对于所有 $k \\in \\mathbb{N}$ 都有 $w_{k} \\in W$。如果一个集合 $\\mathcal{E} \\subset \\mathbb{R}^{n}$ 满足 $A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$，则称其为该系统的鲁棒正不变 (RPI) 集，其中 $\\oplus$ 表示闵可夫斯基和。在鲁棒MPC中，标称状态约束通常通过RPI集进行收紧，以使标称状态在存在扰动的情况下仍保持可行；具体来说，对于一个对称凸约束集 $X$，一个常见的收紧是 $X_{\\text{tight}} = X \\ominus \\mathcal{E}$，其中 $\\ominus$ 表示庞特里亚金差。\n\n假设 $A_{K} = 0.5 I$，扰动集是轴对齐超立方体 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。标称状态约束集为 $X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。仅使用RPI集、闵可夫斯基和以及集值级数极限的基本定义，推导最小RPI集 $\\mathcal{E}$，该集是由 $W$ 通过闭环动态反复传播生成的闵可夫斯基和级数的极限。然后，从第一性原理出发，量化导出的无穷范数约束收紧量，该收紧量定义为必须从 $X$ 的每个边界减去的标量 $\\tau$，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n提供收紧幅度 $\\tau$ 的精确值作为您的最终答案。不需要四舍五入。最终答案必须是单个实数。", "solution": "问题陈述需经过验证。\n\n逐字提取的已知条件如下：\n- 闭环误差动态方程：$e_{k+1} = A_{K} e_{k} + w_{k}$。\n- 系统矩阵：$A_{K} \\in \\mathbb{R}^{n \\times n}$。\n- 扰动：对于所有 $k \\in \\mathbb{N}$，$w_{k} \\in W$。\n- 鲁棒正不变 (RPI) 集 $\\mathcal{E}$：$A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$。\n- 闵可夫斯基和算子：$\\oplus$。\n- 庞特里亚金差算子：$\\ominus$。\n- 约束收紧：$X_{\\text{tight}} = X \\ominus \\mathcal{E}$。\n- 具体系统矩阵：$A_{K} = 0.5 I$。\n- 具体扰动集：$W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。\n- 具体标称状态约束集：$X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。\n- 任务1：推导作为闵可夫斯基和级数极限的最小RPI集 $\\mathcal{E}$。\n- 任务2：量化收紧量 $\\tau$ 使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n该问题在科学上基于鲁棒控制理论和模型预测控制 (MPC) 的既定原则。该问题是适定的，因为对于有界扰动的稳定LTI系统，最小RPI集的概念是标准的，并能导出一个唯一解。问题陈述是客观、完整且无矛盾的。所有术语都有数学定义，并与该领域的文献一致。因此，该问题被视为有效，并将提供解答。\n\n第一步是为给定系统推导最小鲁棒正不变 (RPI) 集 $\\mathcal{E}$。最小RPI集是在所有可能的扰动序列作用下，从原点 ($e_0 = 0$) 可达的所有状态的集合。它被构造为由系统动态传播的扰动集的无穷闵可夫斯基和。\n从 $e_0 = 0$ 开始，在时间步 $k$ 的状态由下式给出：\n$$ e_k = \\sum_{i=0}^{k-1} A_K^i w_{k-1-i} $$\n任何时刻所有可能状态的集合是所有可达集的并集。最小RPI集 $\\mathcal{E}$ 是当 $k \\to \\infty$ 时这些可达集的极限：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} A_K^i W $$\n该级数收敛，因为系统矩阵 $A_K$ 是舒尔稳定的。$A_K = 0.5 I$ 的所有特征值都是 $0.5$，其模小于 $1$。\n代入给定的 $A_K = 0.5 I$：\n$$ A_K^i = (0.5 I)^i = (0.5)^i I $$\n因此，最小RPI集是：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} (0.5)^i I W = \\bigoplus_{i=0}^{\\infty} (0.5)^i W $$\n扰动集 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$ 是一个凸中心对称集（一个以原点为中心的超立方体）。对于这类集合，缩放和闵可夫斯基加法具有性质 $\\alpha S \\oplus \\beta S = (\\alpha+\\beta)S$，其中 $\\alpha, \\beta$ 为非负标量。将此推广到无穷和，我们可以写出：\n$$ \\mathcal{E} = \\left( \\sum_{i=0}^{\\infty} (0.5)^i \\right) W $$\n该和是公比为 $r = 0.5$ 的几何级数：\n$$ \\sum_{i=0}^{\\infty} (0.5)^i = \\frac{1}{1 - 0.5} = \\frac{1}{0.5} = 2 $$\n因此，最小RPI集是：\n$$ \\mathcal{E} = 2 W = 2 \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\} $$\n为了描述这个集合，令 $e \\in \\mathcal{E}$。那么对于某个 $w \\in W$，有 $e = 2w$。$e$ 的范数为 $\\|e\\|_{\\infty} = \\|2w\\|_{\\infty} = 2\\|w\\|_{\\infty}$。由于 $\\|w\\|_{\\infty} \\le 0.1$，可得 $\\|e\\|_{\\infty} \\le 2 \\times 0.1 = 0.2$。\n所以，最小RPI集是超立方体：\n$$ \\mathcal{E} = \\{ e \\in \\mathbb{R}^{n} : \\|e\\|_{\\infty} \\le 0.2 \\} $$\n\n第二步是确定收紧幅度 $\\tau$。收紧后的约束集为 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$。该集合必须满足条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。此条件确保如果标称状态在 $X_{\\text{tight}}$ 内，真实状态（标称状态加误差）将保持在原始约束集 $X$ 内。\n\n让我们分析闵可夫斯基和 $X_{\\text{tight}} \\oplus \\mathcal{E}$。$X_{\\text{tight}}$ 和 $\\mathcal{E}$ 都是以原点为中心的超立方体，由无穷范数界定。\n- $X_{\\text{tight}}$ 是一个无穷范数半径为 $1 - \\tau$ 的超立方体。\n- $\\mathcal{E}$ 是一个无穷范数半径为 $0.2$ 的超立方体。\n两个以原点为中心的超立方体的闵可夫斯基和是另一个以原点为中心的超立方体，其半径是它们半径之和。\n令 $z \\in X_{\\text{tight}} \\oplus \\mathcal{E}$。那么对于某个 $x \\in X_{\\text{tight}}$ 和 $e \\in \\mathcal{E}$，有 $z = x + e$。$z$ 的无穷范数受限于：\n$$ \\|z\\|_{\\infty} = \\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty} $$\n可以达到最大可能值，因此所得集合的特征由下式给出：\n$$ \\sup_{z \\in X_{\\text{tight}} \\oplus \\mathcal{E}} \\|z\\|_{\\infty} = \\sup_{x \\in X_{\\text{tight}}} \\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}} \\|e\\|_{\\infty} = (1 - \\tau) + 0.2 = 1.2 - \\tau $$\n所以，$X_{\\text{tight}} \\oplus \\mathcal{E} = \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\}$。条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$ 变为：\n$$ \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\} \\subseteq \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\} $$\n为使此集合包含关系成立，内部集合的半径必须小于或等于外部集合的半径：\n$$ 1.2 - \\tau \\le 1 $$\n这意味着 $0.2 \\le \\tau$。为了在确保可行性的同时保持最小的保守性，我们必须为收紧量 $\\tau$ 选择最小的可能值。满足条件的最小收紧量是 $\\tau = 0.2$。\n\n这等同于计算庞特里亚金差 $X \\ominus \\mathcal{E}$。根据定义，$X \\ominus \\mathcal{E} = \\{ x \\in \\mathbb{R}^n \\mid x \\oplus \\mathcal{E} \\subseteq X \\}$。\n要使一个元素 $x$ 属于这个集合，对于所有 $e \\in \\mathcal{E}$，必须有 $x+e \\in X$。这意味着对于所有 $\\|e\\|_{\\infty} \\le 0.2$，都有 $\\|x+e\\|_{\\infty} \\le 1$。\n对于一个固定的 $x$，$\\|x+e\\|_{\\infty}$ 的最大值是 $\\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}}\\|e\\|_{\\infty}$。\n所以，条件是 $\\|x\\|_{\\infty} + 0.2 \\le 1$，简化为 $\\|x\\|_{\\infty} \\le 0.8$。\n这定义了最大的收紧集：$X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 0.8 \\}$。\n将此与给定形式 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 进行比较，我们令其边界相等：\n$$ 1 - \\tau = 0.8 $$\n解出 $\\tau$ 可得 $\\tau = 1 - 0.8 = 0.2$。\n收紧幅度为 $\\tau = 0.2$。", "answer": "$$\n\\boxed{0.2}\n$$", "id": "2746575"}, {"introduction": "理论上的可行集在实践中往往难以精确计算，因为它们可能是复杂的非凸几何体。这个编程练习旨在连接理论与实际，要求你通过对状态和输入空间进行网格化，来构造N步可行集的一个内近似。通过编写代码，你将直观地理解可行集的概念，并学习如何用数值方法验证对保证MPC长期运行至关重要的递推可行性属性 [@problem_id:2746631]。", "problem": "考虑在模型预测控制 (MPC) 中使用的离散时间线性时不变系统，其状态更新方程定义为 $x_{k+1} = A x_k + B u_k$，其中 $x_k \\in \\mathbb{R}^2$ 且 $u_k \\in \\mathbb{R}$。设 $A = \\begin{bmatrix}1  1 \\\\ 0  1\\end{bmatrix}$ 且 $B = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$。状态约束集为 $X = \\{ x \\in \\mathbb{R}^2 : \\|x\\|_{\\infty} \\le 1 \\}$，输入约束集为 $U = \\{ u \\in \\mathbb{R} : |u| \\le u_{\\max} \\}$。$N$步可行集 $X_N$ 由基本容许前驱算子递归定义如下：对于任意集合 $S \\subseteq \\mathbb{R}^2$，定义 $\\mathrm{Pre}(S) = \\{ x \\in X : \\exists u \\in U \\text{ such that } A x + B u \\in S \\}$。则 $X_0 = X$ 且对于 $k \\ge 0$，有 $X_{k+1} = \\mathrm{Pre}(X_k)$。集合 $X_N$ 包含所有满足以下条件的初始状态 $x_0$：存在一个输入序列 $(u_0,\\dots,u_{N-1})$，其中每个 $u_i \\in U$，使得预测的状态在 $N$ 步内都保持在 $X$ 中。\n\n您的任务是：\n\n1) 仅使用上述基本定义，不调用任何预计算公式，通过对 $X$ 进行网格化和对 $U$ 进行离散化，构建 $X_3$ 的一个非空内近似。具体来说：\n- 在 $X$ 上使用均匀的矩形网格，每个坐标的间距为 $\\Delta$。对于每个网格点 $x_0$，通过检查是否存在一个从有限离散集 $U_{\\mathrm{disc}} \\subset U$ 中抽取的序列 $(u_0,\\dots,u_{N-1})$，使得在 $x_{k+1} = A x_k + B u_k$ 下的 $N$ 步前向仿真中，每个预测步的状态都保持在 $X$ 内部，从而判断其是否属于内近似集 $\\widehat{X}_N$。因为 $U_{\\mathrm{disc}} \\subset U$ 且 $X$ 上的网格是有限的，所以得到的集合是 $X_N$ 的一个可计算的内近似。\n\n2) 通过标准的 MPC 候选序列论证来验证单步递归可行性：对于每个 $x_0 \\in \\widehat{X}_N$，取任何一个证明其成员资格的可行输入序列 $(u_0,\\dots,u_{N-1})$。通过移位并追加的方式，即 $(u_1,\\dots,u_{N-1}, u_N)$，形成下一时刻的候选序列。通过找到某个 $u_N \\in U_{\\mathrm{disc}}$ 使得额外的预测状态 $x_{N+1} \\in X$，来证明下一时刻的可行性。结论是，对于从 $x_1$ 开始、约束集相同的时域为 $N$ 的问题，该移位序列是一个可行的候选解。您的程序应输出一个布尔值，表示对于每个 $x_0 \\in \\widehat{X}_N$，此单步递归可行性检查是否成功。\n\n您必须使用 $X$ 上的有限网格和 $U$ 的有限离散化来实现上述操作。使用以下测试套件（每个案例指定 $u_{\\max}$、时域 $N$ 和网格间距 $\\Delta$；所有案例使用相同的 $A$、$B$ 和 $X$）：\n- 测试 1 (正常路径): $u_{\\max} = 0.5$, $N = 3$, $\\Delta = 0.5$。\n- 测试 2 (更紧的输入边界): $u_{\\max} = 0.25$, $N = 3$, $\\Delta = 0.5$。\n- 测试 3 (边界时域): $u_{\\max} = 0.5$, $N = 1$, $\\Delta = 0.5$。\n- 测试 4 (更长时域): $u_{\\max} = 0.5$, $N = 4$, $\\Delta = 0.5$。\n\n对于所有案例，使用离散输入集 $U_{\\mathrm{disc}} = \\{-u_{\\max}, 0, u_{\\max}\\}$ 和由 $\\{ x \\in \\mathbb{R}^2 : x_i \\in \\{-1, -1+\\Delta, \\dots, 1-\\Delta, 1\\}, i=1,2 \\}$ 定义的状态网格。\n\n您的程序必须：\n- 对于每个测试案例，计算内近似 $\\widehat{X}_N \\subseteq X$ 的基数（即，存在至少一个来自 $U_{\\mathrm{disc}}$ 的可行 $N$ 步序列，能使预测状态保持在 $X$ 内的网格点 $x_0$ 的数量）。\n- 对于每个测试案例，输出一个布尔值，当且仅当 $\\widehat{X}_N$ 非空，并且通过移位候选序列的单步递归可行性检查对于 $\\widehat{X}_N$ 中的每个 $x_0$ 都成功时，该值为真。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个类似 Python 列表的列表形式的结果。每个内部列表对应一个测试案例，并恰好包含两个元素：第一个是 $\\widehat{X}_N$ 的整数基数，第二个是布尔值，表示候选序列递归可行性检查是否对该案例中 $\\widehat{X}_N$ 内的所有点都通过。除了这单行文本外，不要打印任何额外内容。", "solution": "该问题要求对一个离散时间线性时不变系统的有限时域可行集进行数值研究，这是模型预测控制（MPC）分析与实现中的一项基本任务。该系统由状态更新方程 $x_{k+1} = A x_k + B u_k$ 描述，给定矩阵 $A = \\begin{bmatrix}1  1 \\\\ 0  1\\end{bmatrix}$ 和 $B = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix}$。状态 $x_k$ 和输入 $u_k$ 分别被约束在多胞形集 $X = \\{ x \\in \\mathbb{R}^2 : \\|x\\|_{\\infty} \\le 1 \\}$ 和 $U = \\{ u \\in \\mathbb{R} : |u| \\le u_{\\max} \\}$ 内。\n\n解决方案按规定分两个阶段进行。首先，我们构建真实 $N$ 步可行集 $X_N$ 的一个可计算内近似，记为 $\\widehat{X}_N$。其次，我们验证与此计算集内所有点的递归可行性相关的一个关键属性。\n\n我们数值方法的基础是对连续的状态和输入空间进行离散化。状态约束集 $X$ 是一个正方形 $[-1, 1] \\times [-1, 1]$，它被一个有限的点网格所替代。对于给定的间距 $\\Delta$，该网格由所有点 $(x_1, x_2)$ 组成，其中 $x_1, x_2 \\in \\{-1, -1+\\Delta, \\dots, 1-\\Delta, 1\\}$。输入约束集 $U$ 被离散化为一个有限集 $U_{\\mathrm{disc}} = \\{-u_{\\max}, 0, u_{\\max}\\}$。这些有限的表示将问题从一个无限搜索问题转化为一个组合（尽管可能规模很大）的评估问题。\n\n**第 1 部分：内近似 $\\widehat{X}_N$ 的构建**\n\n$N$ 步可行集 $X_N$ 是所有初始状态 $x_0 \\in X$ 的集合，对于其中每个状态，都存在一个容许的输入序列 $(u_0, \\dots, u_{N-1})$，该序列能在 $N$ 步内将整个状态轨迹保持在 $X$ 内。我们的内近似 $\\widehat{X}_N$ 是通过将初始状态集和可用输入集都限制为其离散对应物来构建的。\n\n算法如下：\n1.  遍历 $X$ 上已定义网格中的每个初始状态 $x_0$。\n2.  对于每个 $x_0$，系统地测试所有可能的输入序列 $(u_0, \\dots, u_{N-1})$，其中每个 $u_k$ 均从 $U_{\\mathrm{disc}}$ 中抽取。此类序列的总数为 $|U_{\\mathrm{disc}}|^N=3^N$。\n3.  对于每个候选序列，使用动力学方程 $x_{k+1} = A x_k + B u_k$ 对系统进行 $N$ 步前向仿真。\n4.  在每一步 $k \\in \\{1, \\dots, N\\}$，检查所得状态 $x_k$ 是否满足状态约束，即 $\\|x_k\\|_{\\infty} \\le 1$。\n5.  如果整个状态轨迹 $(x_1, \\dots, x_N)$ 都保持在 $X$ 内，则该输入序列被认为是初始状态 $x_0$ 的“证明性”或可行序列。\n6.  如果至少找到一个这样的证明性序列，则初始状态 $x_0$ 被包含在集合 $\\widehat{X}_N$ 中。\n7.  必须存储每个 $x_0 \\in \\widehat{X}_N$ 的所有证明性序列，以供分析的第二部分使用。\n8.  $\\widehat{X}_N$ 的基数是满足此标准的网格点总数。\n\n这种前向仿真或“暴力”方法保证了 $\\widehat{X}_N$ 是一个内近似，即 $\\widehat{X}_N \\subseteq X_N$，因为它是使用更严格的初始状态集（有限网格）和输入集（$U_{\\mathrm{disc}} \\subset U$）构建的。\n\n**第 2 部分：单步递归可行性的验证**\n\n递归可行性是 MPC 稳定性证明的基石。它确保如果当前时刻控制问题存在可行解，那么在下一时刻也同样存在可行解。保证这一点的一个常用方法是证明一个根据前一最优解构造的候选解总是可用且可行的。该问题要求我们验证一个能使该论证成立的条件。\n\n在时刻 $k+1$ 的候选输入序列通常是通过取前一最优序列的一部分 $(u_1^*, \\dots, u_{N-1}^*)$，将其移位，并追加某个新输入 $u_N$ 来形成的。为使此策略有效，我们必须确保总能找到一个这样的 $u_N$ 来维持可行性。\n\n验证算法如下：\n1.  只有当 $\\widehat{X}_N$ 非空时，整体检查才能通过。如果 $\\widehat{X}_N$ 为空，检查失败。\n2.  如果 $\\widehat{X}_N$ 非空，我们必须遍历 $\\widehat{X}_N$ 中的每一个点 $x_0$。\n3.  对于每个这样的 $x_0$，我们接着必须遍历其在第 1 部分中找到的*每一个*证明性序列 $(u_0^*, \\dots, u_{N-1}^*)$。该条件必须普遍成立。\n4.  对于给定的 $x_0$ 和一个证明性序列，计算相应轨迹的终端状态：$x_N = A x_{N-1} + B u_{N-1}^*$。\n5.  检查是否存在至少一个输入 $u_N \\in U_{\\mathrm{disc}}$，使得下一步的状态 $x_{N+1} = A x_N + B u_N$ 满足状态约束 $\\|x_{N+1}\\|_{\\infty} \\le 1$。这通过测试 $U_{\\mathrm{disc}}$ 中的三个值来完成。\n6.  如果对于 $\\widehat{X}_N$ 中的任何 $x_0$ 及其任何证明性序列，都找不到这样的 $u_N$，则递归可行性属性不成立。该测试案例的总体结果为 `False`，并且可以终止该过程。\n7.  如果该条件对 $\\widehat{X}_N$ 中的所有点及其各自所有的证明性序列都成立，则该测试案例的总体结果为 `True`。\n\n这个穷举检查确认了所选的离散化是否支持移位并追加的候选解策略，这是真实连续空间可行集属性的一个离散模拟。所提供的 Python 代码为每个指定的测试案例实现了这一完整的验证和确认过程。", "answer": "```python\nimport numpy as np\nfrom itertools import product\nimport sys\n\ndef solve():\n    \"\"\"\n    Solves the MPC feasibility problem for the given test cases.\n    \"\"\"\n    # The problem statement requests output to be Python-like, which may be interpreted\n    # as having spaces. To be safe and unambiguous, printing with an f-string is robust.\n    # The default boolean representation ('True', 'False') is standard.\n    # Disabling the default formatter's behavior for strictness.\n    # pylint: disable=f-string-without-interpolation, consider-using-f-string\n    \n    # Define matrix A and B from the problem statement\n    A = np.array([[1.0, 1.0], [0.0, 1.0]])\n    B = np.array([[0.0], [1.0]])\n\n    # Define the test cases\n    test_cases = [\n        (0.5, 3, 0.5),   # Test 1 (happy path)\n        (0.25, 3, 0.5),  # Test 2 (tighter input bound)\n        (0.5, 1, 0.5),   # Test 3 (boundary horizon)\n        (0.5, 4, 0.5),   # Test 4 (longer horizon)\n    ]\n\n    all_results = []\n\n    for u_max, N, delta in test_cases:\n        # Discretize input space U\n        U_disc = np.array([-u_max, 0.0, u_max])\n\n        # Generate grid for state space X\n        grid_coords = np.arange(-1.0, 1.0 + delta / 2.0, delta)\n        x0_grid_tuples = list(product(grid_coords, grid_coords))\n\n        # Generate all possible input sequences of length N\n        input_sequences = list(product(U_disc, repeat=N))\n\n        # Dictionary to store initial states in hat_X_N and their certifying sequences\n        hat_X_N_data = {}\n\n        # --- Part 1: Construct inner approximation hat_X_N ---\n        for x0_tuple in x0_grid_tuples:\n            x0 = np.array(x0_tuple).reshape(2, 1)\n            certifying_sequences = []\n\n            for u_seq in input_sequences:\n                is_traj_feasible = True\n                x_k = x0\n                \n                # Simulate system for N steps\n                for k in range(N):\n                    u_k = u_seq[k]\n                    # State update: x_{k+1} = A*x_k + B*u_k\n                    x_k_plus_1 = A @ x_k + B * u_k\n                    # Check state constraints: ||x_{k+1}||_inf = 1\n                    # A small tolerance is used for robust floating point comparison.\n                    if np.any(np.abs(x_k_plus_1) > 1.0 + 1e-9):\n                        is_traj_feasible = False\n                        break\n                    x_k = x_k_plus_1\n                \n                if is_traj_feasible:\n                    certifying_sequences.append(u_seq)\n            \n            if certifying_sequences:\n                hat_X_N_data[x0_tuple] = certifying_sequences\n\n        cardinality = len(hat_X_N_data)\n\n        # --- Part 2: Verify one-step recursive feasibility ---\n        recursive_feasibility_ok = True\n        if cardinality == 0:\n            # If hat_X_N is empty, the condition is not met.\n            recursive_feasibility_ok = False\n        else:\n            # Check must hold for every x0 in hat_X_N and every one of its certifying sequences\n            for x0_tuple, c_seqs in hat_X_N_data.items():\n                x0 = np.array(x0_tuple).reshape(2, 1)\n                \n                for u_seq in c_seqs:\n                    # Find the terminal state x_N for this trajectory\n                    x_N = x0\n                    for u_k in u_seq:\n                        x_N = A @ x_N + B * u_k\n                        \n                    # Check if there exists a u_N in U_disc s.t. A*x_N + B*u_N is in X\n                    terminal_condition_met = False\n                    for u_N in U_disc:\n                        x_N_plus_1 = A @ x_N + B * u_N\n                        if np.all(np.abs(x_N_plus_1) = 1.0 + 1e-9):\n                            terminal_condition_met = True\n                            break\n                            \n                    if not terminal_condition_met:\n                        # If check fails for even one sequence, the overall check fails\n                        recursive_feasibility_ok = False\n                        break  # Break from c_seqs loop\n                \n                if not recursive_feasibility_ok:\n                    break  # Break from hat_X_N_data loop\n\n        all_results.append([cardinality, recursive_feasibility_ok])\n\n    # Print results in the required format\n    # Example: [[5, True], [2, False]]\n    print(str(all_results))\n\n# Execute the main function\nsolve()\n```", "id": "2746631"}]}