{"hands_on_practices": [{"introduction": "数据驱动控制的基石在于所用数据的信息量是否“足够丰富”。“持续激励”（Persistency of Excitation, PE）是量化这一概念的核心工具。本练习 [@problem_id:2698781] 引导你从第一性原理出发，亲手设计一个满足特定阶数持续激励条件的输入序列，从而将抽象的汉克尔矩阵秩条件转化为具体可感的信号构造过程。", "problem": "考虑一个具有标量输入（即输入维度 $m = 1$）的离散时间线性时不变（LTI）系统。在数据驱动控制中，如果从输入序列 $\\{u_k\\}_{k=0}^{T-1}$ 构建的深度为 $L$ 的块汉克尔矩阵具有满行秩，则该序列称为 $L$ 阶持续激励。与标量序列 $\\{u_k\\}_{k=0}^{T-1}$ 相关的深度为 $L$ 的块汉克尔矩阵是一个 $L \\times (T-L+1)$ 矩阵\n$$\nH_L(u) \\;=\\;\n\\begin{bmatrix}\nu_0 & u_1 & \\cdots & u_{T-L} \\\\\nu_1 & u_2 & \\cdots & u_{T-L+1} \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\nu_{L-1} & u_{L} & \\cdots & u_{T-1}\n\\end{bmatrix}.\n$$\n仅使用上述核心定义和基本原理，完成以下任务：\n- 设 $L=4$ 且 $T=19$。设计一个显式的二元输入序列 $\\{u_k\\}_{k=0}^{18}$，其中 $u_k \\in \\{0,1\\}$，且该序列是 $L$ 阶持续激励的。\n- 从基本原理出发，证明您的设计为何能保证满足定义所蕴含的秩条件。您的证明必须通过识别 $H_L(u)$ 的一个结构上充分的线性无关列集合，并解释为什么对于您的设计，这些列存在。\n- 计算您所构造序列的 $H_4(u)$ 的秩，并将此秩作为您的最终答案报告。\n\n您的最终答案必须是一个实数。无需四舍五入，也不涉及单位。", "solution": "问题要求设计一个二元输入序列 $\\{u_k\\}_{k=0}^{18}$，其中 $u_k \\in \\{0, 1\\}$，且该序列是 $L=4$ 阶持续激励的。序列总长度为 $T=19$。\n\n首先，我们根据给定参数确定汉克尔矩阵的属性。深度为 $L=4$，序列长度为 $T=19$。块汉克尔矩阵 $H_L(u)$（我们将其记为 $H_4(u)$）是一个 $L \\times (T-L+1)$ 矩阵。\n$$\n\\text{行数} = L = 4\n$$\n$$\n\\text{列数} = T - L + 1 = 19 - 4 + 1 = 16\n$$\n因此，$H_4(u)$ 是一个 $4 \\times 16$ 的矩阵，其形式如下：\n$$\nH_4(u) =\n\\begin{bmatrix}\nu_0 & u_1 & u_2 & \\cdots & u_{15} \\\\\nu_1 & u_2 & u_3 & \\cdots & u_{16} \\\\\nu_2 & u_3 & u_4 & \\cdots & u_{17} \\\\\nu_3 & u_4 & u_5 & \\cdots & u_{18}\n\\end{bmatrix}\n$$\n$L$ 阶持续激励的定义指出，矩阵 $H_L(u)$ 必须具有满行秩。对于 $H_4(u)$，这意味着其秩必须为 $4$。\n\n我们的任务是构造一个序列 $\\{u_k\\}_{k=0}^{18}$，以保证 $\\text{rank}(H_4(u)) = 4$。我们将从基本原理出发，通过构造法来完成。矩阵的秩是其列空间的维度，等价于最大线性无关列的数量。为了证明秩为 $4$，我们只需在 $H_4(u)$ 中找出 $4$ 个线性无关的列即可。\n\n设 $H_4(u)$ 的列用 $c_j$ 表示，其中 $j \\in \\{0, 1, \\dots, 15\\}$，且\n$$\nc_j = \\begin{pmatrix} u_j \\\\ u_{j+1} \\\\ u_{j+2} \\\\ u_{j+3} \\end{pmatrix}\n$$\n我们将设计序列 $\\{u_k\\}$，使得特定的四列构成一个可逆的 $4 \\times 4$ 矩阵。最简单的选择是单位矩阵 $I_4$。我们选择列 $c_0, c_4, c_8, c_{12}$，并使它们分别成为标准基向量 $e_1, e_2, e_3, e_4$，其中 $e_1 = [1,0,0,0]^T$, $e_2 = [0,1,0,0]^T$，依此类推。\n\n这对序列 $\\{u_k\\}$ 施加了以下条件：\n1. $c_0 = e_1 \\implies [u_0, u_1, u_2, u_3]^T = [1, 0, 0, 0]^T$。这设定了 $u_0=1, u_1=0, u_2=0, u_3=0$。\n2. $c_4 = e_2 \\implies [u_4, u_5, u_6, u_7]^T = [0, 1, 0, 0]^T$。这设定了 $u_4=0, u_5=1, u_6=0, u_7=0$。\n3. $c_8 = e_3 \\implies [u_8, u_9, u_{10}, u_{11}]^T = [0, 0, 1, 0]^T$。这设定了 $u_8=0, u_9=0, u_{10}=1, u_{11}=0$。\n4. $c_{12} = e_4 \\implies [u_{12}, u_{13}, u_{14}, u_{15}]^T = [0, 0, 0, 1]^T$。这设定了 $u_{12}=0, u_{13}=0, u_{14}=0, u_{15}=1$。\n\n这些条件定义了 $k \\in \\{0, 1, \\dots, 15\\}$ 的序列元素 $\\{u_k\\}$。这些定义的索引区间 $[0,3], [4,7], [8,11]$ 和 $[12,15]$ 是不相交的，因此这些定义是一致的，不会产生矛盾。\n\n综合这些值，我们得到输入序列的前 $16$ 个元素：\n$$\n\\{u_k\\}_{k=0}^{15} = \\{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1\\}\n$$\n问题要求序列长度为 $T=19$，即 $\\{u_k\\}_{k=0}^{18}$。元素 $u_{16}, u_{17}, u_{18}$ 不受我们构造的约束。为简单起见，我们将它们设为 $0$：\n$$\nu_{16} = 0, \\quad u_{17} = 0, \\quad u_{18} = 0\n$$\n因此，显式的二元输入序列为：\n$$\n\\{u_k\\}_{k=0}^{18} = \\{1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0\\}\n$$\n现在，我们必须证明该序列满足秩条件。根据我们的设计，由列 $c_0, c_4, c_8, c_{12}$ 构成的 $H_4(u)$ 的子矩阵是：\n$$\n[c_0, c_4, c_8, c_{12}] =\n\\begin{bmatrix}\nu_0 & u_4 & u_8 & u_{12} \\\\\nu_1 & u_5 & u_9 & u_{13} \\\\\nu_2 & u_6 & u_{10} & u_{14} \\\\\nu_3 & u_7 & u_{11} & u_{15}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n= I_4\n$$\n这个 $4 \\times 4$ 子矩阵的行列式为 $\\det(I_4) = 1$，非零。因此，列 $c_0, c_4, c_8, c_{12}$ 是线性无关的。\n\n由于 $H_4(u)$ 包含一个由 $4$ 个线性无关列组成的集合，其列空间的维度，也就是它的秩，必须至少为 $4$。\n$$\n\\text{rank}(H_4(u)) \\ge 4\n$$\n此外，任何矩阵的秩都不能超过其行数或列数。矩阵 $H_4(u)$ 有 $4$ 行。\n$$\n\\text{rank}(H_4(u)) \\le \\min(\\text{rows}, \\text{columns}) = \\min(4, 16) = 4\n$$\n结合这两个不等式，我们得到 $4 \\le \\text{rank}(H_4(u)) \\le 4$。这迫使秩恰好为 $4$。\n$$\n\\text{rank}(H_4(u)) = 4\n$$\n由于秩等于行数 $L=4$，矩阵 $H_4(u)$ 具有满行秩，因此根据定义，所构造的序列是 $4$ 阶持续激励的。计算出的秩为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "2698781"}, {"introduction": "掌握了持续激励的构造方法后，下一个关键问题是：它在实践中如何确保我们能够实现控制目标？本练习 [@problem_id:2698788] 将持续激励的概念与 Willems 基本引理相结合，探讨一个具体的控制问题：为了能纯粹基于数据设计一个“无差拍控制器”（deadbeat controller），我们至少需要多长的实验数据和多高阶的激励信号？这个练习将理论与一个明确的控制应用联系起来。", "problem": "考虑一个未知的离散时间单输入单输出 (SISO) 线性时不变系统，该系统由一个 $n$ 阶的最小状态空间实现所描述，并且是能控和能观的。您进行了一次长度为 $T$ 的开环实验，并收集了输入输出数据。您希望使用这些数据，通过一种基于行为方法的纯数据驱动方法，来保证合成无差拍控制器所需的信息充分性。\n\n采用以下基本依据：\n- 一个有限长度的输入序列 $u_{0},\\dots,u_{T-1}$ 被称为是 $s$ 阶持续激励的，如果其深度为 $s$ 的块汉克尔矩阵行满秩。对于 SISO 输入，该汉克尔矩阵的大小为 $s \\times (T-s+1)$，因此行满秩要求 $T - s + 1 \\ge s$。\n- J. C. Willems 的基本引理（行为系统理论）指出，对于一个未知的 $n$ 阶最小系统，如果输入是 $L+n$ 阶持续激励的，那么由单次长度为 $T$ 的轨迹构建的数据矩阵可以张成该未知系统的所有长度为 $L$ 的容许轨迹。特别地，任何与系统动力学兼容的、长度为 $L$ 的容许闭环行为都可以从测量数据中构建出来。\n- 对于一个能控的离散时间系统，其无差拍闭环的所有闭环特征值都位于原点，因此闭环状态转移矩阵是幂零的。根据能控性和 Cayley–Hamilton 定理，存在一个无差拍控制器，它能在最多 $L=n$ 步内将状态驱动到原点。\n\n在此背景下，如果单次长度为 $T$ 的实验及其对应的输入 $u_{0},\\dots,u_{T-1}$ 能够在不显式辨识参数模型的情况下，保证数据足以合成为未知系统在最多 $L$ 步内产生无差拍行为的控制器，则称该数据对于无差拍控制是“信息充分的”。\n\n仅使用上述三个基本要点，确定：\n1) 最小实验长度 $T_{\\min}$，以及\n2) 输入的最小持续激励阶数 $s_{\\min}$，\n\n它们共同保证了对于一个 $n$ 阶能控 SISO 系统实现无差拍控制的信息充分性。将您的最终答案表示为一个关于 $n$ 的双元素行向量 $\\bigl[T_{\\min},\\,s_{\\min}\\bigr]$。不需要数值近似；给出闭式符号表达式。不需要单位。", "solution": "该问题要求确定最小实验长度 $T_{\\min}$ 和最小持续激励阶数 $s_{\\min}$，这两个值需足以保证能为一个未知的、$n$ 阶的能控单输入单输出 (SISO) 线性时不变 (LTI) 系统合成一个无差拍控制器。整个推导过程必须仅基于所提供的三个基本要点。\n\n解题的步骤是将无差拍控制的要求与基本引理的条件逻辑地联系起来，再将其与持续激励的定义联系起来。\n\n首先，我们分析目标：合成一个无差拍控制器。根据第三个基本要点，对于一个 $n$ 阶能控系统，无差拍控制器是指能在最多 $L=n$ 步内将系统状态驱动到原点的控制器。这意味着我们希望能够从实验数据中构建出的期望闭环行为是一个长度为 $L=n$ 的轨迹。\n\n其次，我们确定合成给定长度的任意行为所需的数据要求。第二个基本要点，即 Willems 的基本引理，提供了这个条件。它指出，为了能够从数据中构建任何长度为 $L$ 的容许系统轨迹，实验中使用的输入信号必须是 $s = L+n$ 阶持续激励的。为了保证我们能合成特征长度为 $L=n$ 的特定无差拍行为，输入必须至少是 $s = n+n = 2n$ 阶持续激励的。这就确定了所需的最小持续激励阶数：\n$$s_{\\min} = 2n$$\n\n第三，我们将持续激励阶数与实验长度联系起来。第一个基本要点定义了 SISO 输入的 $s$ 阶持续激励。它要求输入的块汉克尔矩阵（对于长度为 $T$ 的输入序列，其维度为 $s \\times (T-s+1)$）必须行满秩。任何矩阵行满秩的一个必要条件是其列数必须大于或等于其行数。将此条件应用于汉克尔矩阵的维度，得到不等式：\n$$T - s + 1 \\ge s$$\n这个不等式可以重新整理，从而为给定持续激励阶数 $s$ 时所需的实验长度 $T$ 建立一个下界：\n$$T \\ge 2s - 1$$\n\n最后，我们结合这些结果来找到最小条件。我们已经确定，为保证能够合成无差拍控制器，输入必须至少是 $s_{\\min} = 2n$ 阶持续激励的。为了找到能够支持这种输入的最小实验长度 $T_{\\min}$，我们将所需的最小持续激励阶数 $s_{\\min}$ 代入关于 $T$ 的不等式中：\n$$T \\ge 2(s_{\\min}) - 1$$\n$$T \\ge 2(2n) - 1$$\n$$T \\ge 4n - 1$$\n因此，保证无差拍控制信息充分性所需的最小实验长度为 $T_{\\min} = 4n - 1$。\n\n综上所述，所需的最小持续激励阶数为 $s_{\\min} = 2n$，相应的最小实验长度为 $T_{\\min} = 4n - 1$。问题要求将这两个值表示为一个双元素行向量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4n - 1 & 2n\n\\end{pmatrix}\n}\n$$", "id": "2698788"}, {"introduction": "理论分析通常假设数据是无噪声的，但实际应用必须处理测量误差。集合成员辨识（Set-Membership Identification）方法通过定义与有界噪声相容的“可行参数集”（Feasible Parameter Set, FPS）来应对这一挑战。这个编程练习 [@problem_id:2698754] 将带你走完一个完整的从数据到鲁棒控制分析的流程：你将编写代码来构建可行参数集，计算其切比雪夫中心作为标称模型，设计一个控制器，并最终评估其在整个不确定性集上的最坏情况性能。", "problem": "考虑一个单输入单输出（SISO）自回归外源输入（ARX）单步预测模型，其回归形式写作 $y_k = \\varphi_k^\\top \\theta + e_k$，其中 $y_k \\in \\mathbb{R}$ 是在时间索引 $k$ 的测量输出，$\\varphi_k \\in \\mathbb{R}^p$ 是已知回归量向量，$\\theta \\in \\mathbb{R}^p$ 是未知参数向量，$e_k \\in \\mathbb{R}$ 是满足 $|e_k| \\le \\varepsilon$ 的有界扰动。在已知一致边界 $\\varepsilon \\ge 0$ 的假设下，可行参数集（FPS）是多胞体\n$$\n\\Theta = \\left\\{ \\theta \\in \\mathbb{R}^p \\,\\middle|\\, -\\varepsilon \\le y_k - \\varphi_k^\\top \\theta \\le \\varepsilon \\text{ for all available indices } k \\right\\}.\n$$\n等价地，令 $A \\in \\mathbb{R}^{m \\times p}$ 和 $b \\in \\mathbb{R}^m$ 收集从数据中导出的线性不等式，即\n$$\n\\begin{aligned}\n\\varphi_k^\\top \\theta \\le y_k + \\varepsilon,\\\\\n(-\\varphi_k)^\\top \\theta \\le -y_k + \\varepsilon,\n\\end{aligned}\n$$\n对于每个索引 $k$，我们将 $\\Theta$ 写为 $\\Theta = \\{ \\theta \\in \\mathbb{R}^p \\mid A \\theta \\le b \\}$。\n\n$\\Theta$ 的 Chebyshev 中心定义为点 $\\theta_c \\in \\mathbb{R}^p$，该点能最大化包含在 $\\Theta$ 中的最大欧几里得球 $\\mathbb{B}_2(\\theta_c, r) = \\{\\theta \\in \\mathbb{R}^p \\mid \\|\\theta - \\theta_c\\|_2 \\le r\\}$ 的半径 $r \\ge 0$。对于由 $A \\theta \\le b$ 给出的多胞体，其 Chebyshev 中心可以通过求解以下线性规划（LP）问题来计算\n$$\n\\begin{aligned}\n\\max_{\\theta \\in \\mathbb{R}^p,\\, r \\in \\mathbb{R}}~ r\\\\\n\\text{s.t.}~ A_i^\\top \\theta + \\|A_i\\|_2 \\, r \\le b_i,\\quad i = 1,\\dots,m,\\\\\n r \\ge 0,\n\\end{aligned}\n$$\n其中 $A_i^\\top$ 是 $A$ 的第 $i$ 行，$b_i$ 是 $b$ 的对应元素。\n\n对于一个静态状态反馈控制律 $u_{k-1} = k_{\\text{nom}} y_{k-1}$，该控制律使用来自 Chebyshev 中心的标称参数估计 $\\hat{\\theta} = \\theta_c$ 进行设计，一阶 SISO ARX 受控对象模型 $y_k = a\\, y_{k-1} + b\\, u_{k-1} + e_k$ 的标称闭环极点等于 $a + b\\,k_{\\text{nom}}$。如果指定一个期望的标称闭环极点 $\\alpha_{\\text{des}} \\in \\mathbb{R}$，确定性等价设计选择\n$$\nk_{\\text{nom}} = \n\\begin{cases}\n\\dfrac{\\alpha_{\\text{des}} - \\hat{a}}{\\hat{b}}, & \\text{if } |\\hat{b}| \\ge \\delta, \\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\n其中小的阈值 $\\delta > 0$ 用于避免除以非常小的数。由此产生的在可行参数集上的最坏情况闭环极点模为\n$$\n\\rho_{\\max} = \\max_{\\theta \\in \\Theta} \\left| a + b\\,k_{\\text{nom}} \\right|,\n$$\n这量化了因在整个可行集上使用单一标称增益而引起的基本保守性。这个量可以通过两个 LP 计算，因为它是一个分段线性函数的最大值：\n$$\n\\begin{aligned}\nz_{\\max} = \\max_{\\theta \\in \\Theta}~ c^\\top \\theta,\\\\\nz_{\\min} = \\min_{\\theta \\in \\Theta}~ c^\\top \\theta,\\\\\n\\rho_{\\max} = \\max\\{\\, z_{\\max},\\, -z_{\\min}\\,\\},\n\\end{aligned}\n$$\n其中 $c = \\begin{bmatrix} 1 & k_{\\text{nom}} \\end{bmatrix}^\\top$ 且 $\\theta = \\begin{bmatrix} a & b \\end{bmatrix}^\\top$。\n\n你的任务是编写一个程序，该程序：\n- 根据给定的回归量-输出对 $(\\varphi_k, y_k)$ 和噪声边界 $\\varepsilon$ 构建 FPS $\\Theta$。\n- 使用上述 LP 计算 Chebyshev 中心 $(\\theta_c, r)$。\n- 使用 $\\hat{\\theta} = \\theta_c$ 为指定的期望极点 $\\alpha_{\\text{des}}$ 和一个小的安全阈值 $\\delta = 10^{-8}$ 来合成 $k_{\\text{nom}}$。\n- 通过两个 LP 计算最坏情况下的闭环极点模 $\\rho_{\\max}$ 和保守性比率\n$$\n\\Gamma = \\frac{\\rho_{\\max}}{\\max\\{|\\alpha_{\\text{des}}|, 10^{-12}\\}},\n$$\n这是一个非负无量纲指标：大于 $1$ 的值反映了相对于设计目标的潜在保守性甚至不稳定性，而接近 $1$ 的值表示低保守性。\n\n使用以下测试套件。在所有情况下，取 $\\alpha_{\\text{des}} = 0.2$ 和 $\\delta = 10^{-8}$。对于每种情况，提供真实参数向量 $\\theta^\\star$ 以计算辨识误差范数 $\\|\\theta_c - \\theta^\\star\\|_2$。\n\n- 情况 1（充分激励数据，小不确定性）：\n    - 维度：$p = 2$，其中 $\\theta = [a, b]^\\top$。\n    - 数据：\n        - $\\varphi_1 = [0.0,~1.0]^\\top$, $y_1 = 1.0$。\n        - $\\varphi_2 = [1.0,~0.0]^\\top$, $y_2 = 0.5$。\n        - $\\varphi_3 = [0.5,~1.0]^\\top$, $y_3 = 1.25$。\n        - $\\varphi_4 = [1.25,~-1.0]^\\top$, $y_4 = -0.375$。\n        - $\\varphi_5 = [-0.375,~0.5]^\\top$, $y_5 = 0.3125$。\n        - $\\varphi_6 = [0.3125,~-0.5]^\\top$, $y_6 = -0.34375$。\n    - 噪声边界：$\\varepsilon = 0.05$。\n    - 真实参数：$\\theta^\\star = [0.5,~1.0]^\\top$。\n\n- 情况 2（弱信息但有界，中等不确定性）：\n    - 维度：$p = 2$，其中 $\\theta = [a, b]^\\top$。\n    - 数据：\n        - $\\varphi_1 = [1.0,~1.0]^\\top$, $y_1 = 1.0$。\n        - $\\varphi_2 = [2.0,~2.01]^\\top$, $y_2 = 2.006$。\n        - $\\varphi_3 = [3.0,~3.02]^\\top$, $y_3 = 3.012$。\n        - $\\varphi_4 = [1.5,~1.49]^\\top$, $y_4 = 1.494$。\n    - 噪声边界：$\\varepsilon = 0.05$。\n    - 真实参数：$\\theta^\\star = [0.4,~0.6]^\\top$。\n\n- 情况 3（良态，非常小的不确定性）：\n    - 维度：$p = 2$，其中 $\\theta = [a, b]^\\top$。\n    - 数据：\n        - $\\varphi_1 = [1.0,~-1.0]^\\top$, $y_1 = 1.1$。\n        - $\\varphi_2 = [0.5,~2.0]^\\top$, $y_2 = -1.7$。\n        - $\\varphi_3 = [-1.5,~0.5]^\\top$, $y_3 = -0.75$。\n        - $\\varphi_4 = [2.0,~-0.5]^\\top$, $y_4 = 0.85$。\n        - $\\varphi_5 = [-0.5,~-1.5]^\\top$, $y_5 = 1.25$。\n    - 噪声边界：$\\varepsilon = 0.001$。\n    - 真实参数：$\\theta^\\star = [0.2,~-0.9]^\\top$。\n\n程序输出规范：\n- 对于每个测试案例，计算并返回一个列表，其中按顺序包含：\n    1) Chebyshev 半径 $r$，\n    2) 辨识误差范数 $\\|\\theta_c - \\theta^\\star\\|_2$，\n    3) 最坏情况下的闭环极点模 $\\rho_{\\max}$，以及\n    4) 保守性比率 $\\Gamma$。\n- 将所有四个量表示为实数，四舍五入到六位小数。\n- 你的程序应生成单行输出，包含所有案例的结果，形式为逗号分隔的列表的列表，并用方括号括起来，例如：\n\"[ [r1,err1,rho1,gamma1], [r2,err2,rho2,gamma2], [r3,err3,rho3,gamma3] ]\"。", "solution": "所呈现的问题是数据驱动控制领域一个有效且适定的练习，具体涉及一个简单线性系统的集员辨识和鲁棒控制分析。其理论背景可靠，数据完整且一致，目标通过线性规划在计算上是可行的。我们将进行系统性的求解。\n\n问题的核心在于刻画自回归外源输入（ARX）模型参数的不确定性，并分析其对一个简单反馈控制器的影响。ARX 模型由下式给出\n$$y_k = \\varphi_k^\\top \\theta + e_k$$\n其中 $\\theta = [a, b]^\\top \\in \\mathbb{R}^2$ 是未知参数向量，$\\varphi_k \\in \\mathbb{R}^2$ 是回归量向量，$y_k \\in \\mathbb{R}$ 是输出，$e_k$ 是一个有界扰动，满足 $|e_k| \\le \\varepsilon$。这个有界误差假设使我们能够定义一个可行参数集（FPS），记作 $\\Theta$，它是与观测数据 $(\\varphi_k, y_k)$ 和噪声边界 $\\varepsilon$ 相一致的所有参数向量 $\\theta$ 的集合。\n\nFPS 是一个由一组线性不等式定义的多胞体：\n$$\\Theta = \\left\\{ \\theta \\in \\mathbb{R}^2 \\,\\middle|\\, |y_k - \\varphi_k^\\top \\theta| \\le \\varepsilon \\text{ for all } k \\right\\}$$\n这等价于线性不等式系统 $A \\theta \\le b$，其中对于每个数据点 $k$，我们有两个约束条件：\n$$\n\\begin{aligned}\n\\varphi_k^\\top \\theta \\le y_k + \\varepsilon \\\\\n-\\varphi_k^\\top \\theta \\le -y_k + \\varepsilon\n\\end{aligned}\n$$\n矩阵 $A$ 和向量 $b$ 是通过堆叠所有可用数据点的这些约束而构建的。\n\n第一步是计算 $\\Theta$ 的 Chebyshev 中心。这提供了一个标称参数估计 $\\theta_c$，在几何意义上，它与不确定性集的边界距离最远。最大内切超球面的中心 $\\theta_c$ 和半径 $r$ 可通过求解以下线性规划（LP）问题找到：\n$$\n\\begin{aligned}\n\\max_{\\theta \\in \\mathbb{R}^2,\\, r \\in \\mathbb{R}}~ r\\\\\n\\text{s.t.}~ A_i^\\top \\theta + \\|A_i\\|_2 \\, r \\le b_i,\\quad i = 1,\\dots,m \\\\\n r \\ge 0\n\\end{aligned}\n$$\n这里，$A_i^\\top$ 是矩阵 $A$ 的第 $i$ 行（即 $\\varphi_k^\\top$ 或 $-\\varphi_k^\\top$），$m$ 是不等式的总数。此 LP 的决策变量是中心 $\\theta$ 的分量和半径 $r$。\n\n一旦找到 Chebyshev 中心 $\\theta_c = [\\hat{a}, \\hat{b}]^\\top$，我们用它作为标称参数估计 $\\hat{\\theta}$ 来设计一个状态反馈控制器 $u_{k-1} = k_{\\text{nom}} y_{k-1}$。增益 $k_{\\text{nom}}$ 是使用确定性等价的极点配置策略来选择的，目的是将标称闭环极点 $a+bk_{\\text{nom}}$ 放置在期望的位置 $\\alpha_{\\text{des}}$。增益的公式为：\n$$\nk_{\\text{nom}} = \n\\begin{cases}\n\\dfrac{\\alpha_{\\text{des}} - \\hat{a}}{\\hat{b}}, & \\text{if } |\\hat{b}| \\ge \\delta \\\\\n0, & \\text{otherwise}\n\\end{cases}\n$$\n其中 $\\delta = 10^{-8}$ 是一个小的正数常量，用以防止除以接近零的输入增益估计值 $\\hat{b}$。\n\n在控制器增益 $k_{\\text{nom}}$ 固定的情况下，我们必须在整个可行参数集 $\\Theta$ 上评估其最坏情况下的性能。性能指标是闭环极点的模 $|a + b k_{\\text{nom}}|$。我们旨在计算其最大值：\n$$\\rho_{\\max} = \\max_{\\theta \\in \\Theta} |a + b k_{\\text{nom}}|$$\n这是一个线性函数在一个多胞体上的最大值问题。令 $c = [1, k_{\\text{nom}}]^\\top$。那么绝对值内的表达式是 $c^\\top \\theta$。该问题等价于在 $\\Theta$ 上找到 $c^\\top \\theta$ 的最大值和最小值：\n$$\n\\begin{aligned}\nz_{\\max} = \\max_{\\theta \\in \\Theta}~ c^\\top \\theta \\\\\nz_{\\min} = \\min_{\\theta \\in \\Theta}~ c^\\top \\theta\n\\end{aligned}\n$$\n这两个值可以通过求解另外两个 LP 来找到。最终的最坏情况极点模为 $\\rho_{\\max} = \\max\\{z_{\\max}, -z_{\\min}\\}$。\n\n最后，我们计算两个总结性指标：辨识误差 $\\|\\theta_c - \\theta^\\star\\|_2$，其中 $\\theta^\\star$ 是真实参数向量；以及保守性比率 $\\Gamma = \\frac{\\rho_{\\max}}{\\max\\{|\\alpha_{\\text{des}}|, 10^{-12}\\}}$。该比率将最坏情况下实现的极点模与设计目标进行比较，提供了因参数不确定性导致的性能退化的一个度量。\n\n我们现在将对每个提供的测试案例执行此过程。LP 将使用 `scipy.optimize.linprog` 来求解。\n\n对于每个有 $N$ 个数据点 $(\\varphi_k, y_k)$ 的测试案例，我们构建一个矩阵 $A \\in \\mathbb{R}^{2N \\times 2}$ 和一个向量 $b \\in \\mathbb{R}^{2N}$。\n\n1.  **用于 Chebyshev 中心的 LP**：我们求解 $x = [\\theta_1, \\theta_2, r]^\\top = [a, b, r]^\\top$。目标是最小化 $c^\\top x$，其中 $c = [0, 0, -1]^\\top$。约束 $A_{ub} x \\le b_{ub}$ 被构建，其中 $A_{ub}$ 的每一行是 $[(A_i)_1, (A_i)_2, \\|A_i\\|_2]$，$b_{ub}$ 是原始的 $b$ 向量。边界设置使 $r \\ge 0$。\n\n2.  **用于最坏情况极点的 LP**：我们求解 $x = \\theta = [a, b]^\\top$。约束是 $A \\theta \\le b$。\n    -   为了找到 $z_{\\max}$，我们最小化 $(-c)^\\top \\theta$ 并对结果取负。\n    -   为了找到 $z_{\\min}$，我们最小化 $c^\\top \\theta$。\n\n这种线性规划的系统性应用提供了所有要求的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"name\": \"Case 1\",\n            \"p\": 2,\n            \"data\": [\n                (np.array([0.0, 1.0]), 1.0),\n                (np.array([1.0, 0.0]), 0.5),\n                (np.array([0.5, 1.0]), 1.25),\n                (np.array([1.25, -1.0]), -0.375),\n                (np.array([-0.375, 0.5]), 0.3125),\n                (np.array([0.3125, -0.5]), -0.34375),\n            ],\n            \"epsilon\": 0.05,\n            \"theta_star\": np.array([0.5, 1.0]),\n        },\n        {\n            \"name\": \"Case 2\",\n            \"p\": 2,\n            \"data\": [\n                (np.array([1.0, 1.0]), 1.0),\n                (np.array([2.0, 2.01]), 2.006),\n                (np.array([3.0, 3.02]), 3.012),\n                (np.array([1.5, 1.49]), 1.494),\n            ],\n            \"epsilon\": 0.05,\n            \"theta_star\": np.array([0.4, 0.6]),\n        },\n        {\n            \"name\": \"Case 3\",\n            \"p\": 2,\n            \"data\": [\n                (np.array([1.0, -1.0]), 1.1),\n                (np.array([0.5, 2.0]), -1.7),\n                (np.array([-1.5, 0.5]), -0.75),\n                (np.array([2.0, -0.5]), 0.85),\n                (np.array([-0.5, -1.5]), 1.25),\n            ],\n            \"epsilon\": 0.001,\n            \"theta_star\": np.array([0.2, -0.9]),\n        },\n    ]\n\n    alpha_des = 0.2\n    delta = 1e-8\n\n    all_results = []\n    \n    for case in test_cases:\n        p = case[\"p\"]\n        data = case[\"data\"]\n        epsilon = case[\"epsilon\"]\n        theta_star = case[\"theta_star\"]\n        \n        # 1. Construct the FPS polyhedron A_poly * theta = b_poly\n        num_data_points = len(data)\n        A_poly = np.zeros((2 * num_data_points, p))\n        b_poly = np.zeros(2 * num_data_points)\n        \n        for i, (phi_k, y_k) in enumerate(data):\n            A_poly[2 * i, :] = phi_k\n            b_poly[2 * i] = y_k + epsilon\n            A_poly[2 * i + 1, :] = -phi_k\n            b_poly[2 * i + 1] = -y_k + epsilon\n\n        # 2. Compute the Chebyshev center (theta_c, r)\n        # LP variables: [theta_1, ..., theta_p, r]\n        c_chebyshev = np.zeros(p + 1)\n        c_chebyshev[-1] = -1  # Maximize r by minimizing -r\n\n        A_chebyshev = np.zeros((2 * num_data_points, p + 1))\n        for i in range(2 * num_data_points):\n            A_chebyshev[i, :p] = A_poly[i, :]\n            A_chebyshev[i, p] = np.linalg.norm(A_poly[i, :])\n        \n        b_chebyshev = b_poly\n        \n        bounds_chebyshev = [(None, None)] * p + [(0, None)]\n        \n        res_chebyshev = linprog(c_chebyshev, A_ub=A_chebyshev, b_ub=b_chebyshev, bounds=bounds_chebyshev, method='highs')\n\n        if not res_chebyshev.success:\n            raise RuntimeError(f\"Chebyshev center LP failed for {case['name']}\")\n            \n        theta_c = res_chebyshev.x[:p]\n        r = res_chebyshev.x[p]\n        \n        # 3. Synthesize controller gain k_nom\n        a_hat, b_hat = theta_c\n        if abs(b_hat) >= delta:\n            k_nom = (alpha_des - a_hat) / b_hat\n        else:\n            k_nom = 0.0\n            \n        # 4. Compute worst-case pole magnitude rho_max\n        c_pole = np.array([1.0, k_nom])\n        bounds_pole = [(None, None)] * p\n\n        # Find z_max = max c_pole^T * theta\n        res_z_max = linprog(-c_pole, A_ub=A_poly, b_ub=b_poly, bounds=bounds_pole, method='highs')\n        if not res_z_max.success:\n            raise RuntimeError(f\"z_max LP failed for {case['name']}\")\n        z_max = -res_z_max.fun\n\n        # Find z_min = min c_pole^T * theta\n        res_z_min = linprog(c_pole, A_ub=A_poly, b_ub=b_poly, bounds=bounds_pole, method='highs')\n        if not res_z_min.success:\n            raise RuntimeError(f\"z_min LP failed for {case['name']}\")\n        z_min = res_z_min.fun\n\n        rho_max = max(z_max, -z_min)\n\n        # 5. Compute additional metrics\n        id_error_norm = np.linalg.norm(theta_c - theta_star)\n        conservatism_ratio = rho_max / max(abs(alpha_des), 1e-12)\n\n        # 6. Format results\n        case_results = [\n            round(r, 6),\n            round(id_error_norm, 6),\n            round(rho_max, 6),\n            round(conservatism_ratio, 6)\n        ]\n        all_results.append(case_results)\n\n    # Final print statement\n    results_str = \", \".join([str(res) for res in all_results])\n    print(f\"[{results_str}]\".replace(\" \", \"\"))\n\nsolve()\n```", "id": "2698754"}]}