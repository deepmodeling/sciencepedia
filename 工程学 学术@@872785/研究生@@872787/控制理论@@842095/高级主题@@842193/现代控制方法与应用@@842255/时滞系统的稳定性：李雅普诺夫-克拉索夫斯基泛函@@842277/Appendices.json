{"hands_on_practices": [{"introduction": "在时滞系统的稳定性分析中，我们常常面临一个权衡：是使用简单但可能过于保守的“时滞无关”判据，还是采用更复杂但更精确的“时滞相关”判据。这个练习将通过一个具体的例子来展示这种权衡。你将实现两种测试方法，并发现一个简单的时滞无关测试失败了，而一个更精细的、基于Wirtinger不等式的时滞相关测试却成功证明了系统的稳定性，从而直观地理解高级分析方法的价值 [@problem_id:2747657]。", "problem": "考虑由以下迟滞型泛函微分方程描述的线性时滞系统\n$$\n\\dot{x}(t) = a\\,x(t) + b\\,x(t-h),\n$$\n其中时滞 $$h \\ge 0$$ 为常数，$$a,b \\in \\mathbb{R}$$ 为实标量。要求您实现两个基于李雅普诺夫的稳定性认证测试，并展示一个案例，在该案例中，一个与时滞无关的测试未能检测到稳定性，而一个基于Wirtinger增强的Lyapunov-Krasovskii泛函（LKF）的时滞相关测试成功了。\n\n您的程序必须实现以下两个充分条件：\n\n1) 仅使用状态和积分能量的时滞无关Lyapunov-Krasovskii泛函（LKF）测试：\n- 考虑泛函\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds,\n$$\n其中 $$p  0$$ 且 $$q  0$$。它沿解的时间导数为\n$$\n\\dot{V}(t) = 2 p\\,x(t)\\,\\dot{x}(t) + q\\,x(t)^2 - q\\,x(t-h)^2.\n$$\n代入 $$\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)$$ 得到一个关于 $$[\\,x(t),\\,x(t-h)\\,]^T$$ 的二次型：\n$$\n\\dot{V}(t) = \n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}^\\top\n\\underbrace{\\begin{bmatrix}\n2 p a + q  p b \\\\\np b  -q\n\\end{bmatrix}}_{M(p,q)}\n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}.\n$$\n如果存在 $$p0,q0$$ 使得 $$M(p,q) \\prec 0$$（负定），则原点对所有 $$h \\ge 0$$ 都是渐近稳定的。这是一个时滞无关的测试。\n\n2) 经Wirtinger增强的时滞相关LKF测试：\n- 考虑增强的泛函\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds + \\int_{t-h}^{t}\\int_{\\xi}^{t} r\\,\\dot{x}(\\tau)^2\\,d\\tau\\,d\\xi,\n$$\n其中 $$p0, q0, r0$$。其时间导数满足\n$$\n\\dot{V}(t) = 2 p\\,x(t)\\,\\dot{x}(t) + q\\big(x(t)^2 - x(t-h)^2\\big) + r\\,h\\,\\dot{x}(t)^2 - r\\int_{t-h}^{t} \\dot{x}(s)^2\\,ds.\n$$\n使用不等式\n$$\n\\int_{t-h}^{t} \\dot{x}(s)^2 ds \\ge \\frac{1}{h}\\big(x(t) - x(t-h)\\big)^2,\n$$\n并代入 $$\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)$$，可以获得一个上界\n$$\n\\dot{V}(t) \\le \n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}^\\top\n\\underbrace{\\begin{bmatrix}\n2 p a + q + r h a^2 - \\frac{r}{h}  p b + r h a b + \\frac{r}{h} \\\\\np b + r h a b + \\frac{r}{h}  -q + r h b^2 - \\frac{r}{h}\n\\end{bmatrix}}_{N(p,q,r;h)}\n\\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix}.\n$$\n如果存在 $$p0, q0, r0$$ 使得 $$N(p,q,r;h) \\prec 0$$，则对于该特定时滞 $$h$$，原点是渐近稳定的。这是一个通过导数项和积分不等式（一个Wirtinger型界）加强的时滞相关测试。\n\n您的任务是：\n- 将两种测试实现为计算过程，通过搜索决策变量来检测可行的证书。\n- 对于每个测试，您必须通过检查相关的对称 $$2\\times 2$$ 矩阵是否为负定来判断可行性，即所有特征值都严格为负。使用一个小的数值容差，仅当矩阵的最大特征值低于 $$-10^{-9}$$ 时，才将其视为负定。\n\n测试套件：\n- 使用以下参数集 $$\\{(a,b,h)\\}$$：\n    1) $$a=-0.3,\\, b=-0.8,\\, h=0.5$$\n    2) $$a=-0.3,\\, b=-0.8,\\, h=1.6$$\n    3) $$a=-0.3,\\, b=-0.8,\\, h=3.0$$\n    4) $$a=-2.0,\\, b=0.5,\\, h=3.0$$\n- 对于每种情况，返回一个包含两个整数的列表 $$[d_1,d_2]$$，其中：\n    - $$d_1 \\in \\{0,1\\}$$ 表示时滞无关的LKF测试是否找到了证书（1代表成功，0代表失败）。\n    - $$d_2 \\in \\{0,1\\}$$ 表示经Wirtinger增强的时滞相关LKF测试是否为给定的 $$h$$ 找到了证书（1代表成功，0代表失败）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个结果，格式为由逗号分隔的四个双整数列表，无空格，并用方括号括起来。例如：\n$$\n[[0,1],[0,1],[0,0],[1,1]]\n$$\n不涉及物理单位。不使用角度。不使用百分比。", "solution": "该问题已经过严格验证，并被确认为有效。它在科学上基于控制理论的既定原则，特别是使用Lyapunov-Krasovskii泛函进行时滞系统的稳定性分析。泛函的时间导数及其产生的矩阵不等式的数学公式是正确的。该问题是适定的，为开发和验证计算解提供了一套清晰、客观和完整的规范。其中没有科学上的不准确、含糊不清或矛盾之处。我们将开始解答。\n\n该问题要求为以下方程描述的线性时滞系统实现两种不同的稳定性测试：\n$$\n\\dot{x}(t) = a\\,x(t) + b\\,x(t-h)\n$$\n其中 $$a, b \\in \\mathbb{R}$$ 是常数系数，$$h \\ge 0$$ 是时滞。目标是针对几个参数集 $$\\{a, b, h\\}$$ 确定每个稳定性测试是否能证明系统原点的渐近稳定性。如果存在一组正的决策变量使得特定的测试矩阵为负定，则找到了一个证书。当且仅当一个对称矩阵的最大特征值严格为负时，该矩阵被认为是负定的。出于计算目的，我们将使用指定的阈值，即最大特征值必须小于 $$-10^{-9}$$。\n\n第一个测试是一个时滞无关条件，意味着如果它被满足，系统对于所有非负时滞 $$h \\ge 0$$ 都是稳定的。第二个测试是时滞相关的，即使在第一个测试失败的情况下，也可能为特定的 $$h$$ 值证明稳定性。这展示了稳定性判据的普适性与其保守性之间的权衡。\n\n### 测试 1：时滞无关的Lyapunov-Krasovskii泛函\n\n该测试利用以下泛函：\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds\n$$\n稳定性条件要求找到正标量 $$p  0$$ 和 $$q  0$$，使得矩阵 $$M(p,q)$$ 是负定的（$$M(p,q) \\prec 0$$），其中：\n$$\nM(p,q) = \\begin{bmatrix}\n2 p a + q  p b \\\\\np b  -q\n\\end{bmatrix}\n$$\n该条件对于决策变量是齐次的；如果（$$p, q$$）是一个可行解，那么对于任何 $$\\alpha  0$$，（$$\\alpha p, \\alpha q$$）也是一个可行解。这允许我们固定一个变量，例如 $$p=1$$，并将搜索简化为寻找可行 $$q  0$$ 的一维问题。计算过程将涉及对 $$q$$ 的一系列正值进行数值搜索。对于每个 $$q$$，构造矩阵 $$M(1, q)$$，并计算其特征值。如果发现两个特征值都小于所需的容差 $$-10^{-9}$$，则找到了证书，测试成功。\n\n### 测试 2：经Wirtinger增强的时滞相关LKF\n\n该测试采用一个更复杂的泛函，其中包含一个涉及状态导数的积分项，并通过Wirtinger不等式增强以获得更紧的界：\n$$\nV(t) = p\\,x(t)^2 + \\int_{t-h}^{t} q\\,x(s)^2\\,ds + \\int_{t-h}^{t}\\int_{\\xi}^{t} r\\,\\dot{x}(\\tau)^2\\,d\\tau\\,d\\xi\n$$\n这里的稳定性条件是，对于*特定*的时滞 $$h$$，找到正标量 $$p  0, q  0, r  0$$，使得矩阵 $$N(p,q,r;h) \\prec 0$$，其中：\n$$\nN(p,q,r;h) = \\begin{bmatrix}\n2 p a + q + r h a^2 - \\frac{r}{h}  p b + r h a b + \\frac{r}{h} \\\\\np b + r h a b + \\frac{r}{h}  -q + r h b^2 - \\frac{r}{h}\n\\end{bmatrix}\n$$\n与第一个测试类似，这是一个在 $$p, q, r$$ 上齐次的可行性问题。我们可以固定 $$p=1$$ 并搜索一对正标量（$$q, r$$）。实现上将对 $$q$$ 和 $$r$$ 在预定义的正值范围内执行二维网格搜索。对于每一对（$$q, r$$），构造矩阵 $$N(1,q,r;h)$$，计算其特征值，并检查负定性条件。如果找到一个可行的对，则对于给定的 $$h$$ 值，测试成功。\n\n### 计算搜索策略\n\n对于两种测试，决策变量的搜索实现如下：\n- **测试 1：** 在固定 $$p=1$$ 的情况下，对 $$q$$ 进行一维线性搜索。$$q$$ 的搜索空间是一个足够大区间内（例如 `[1e-6, 100]`）的点网格。\n- **测试 2：** 在固定 $$p=1$$ 的情况下，对（$$q, r$$）进行二维网格搜索。搜索空间是 $$q$$ 和 $$r$$ 的两个线性网格的笛卡尔积，例如 `[1e-4, 50] x [1e-4, 50]`。\n\n对于搜索空间中的每个点，构造相应的矩阵（$$M$$ 或 $$N$$），并使用针对对称矩阵的鲁棒数值方法计算其特征值。如果最大特征值低于容差 $$-10^{-9}$$，则搜索成功终止。如果在耗尽整个搜索空间后仍未找到证书，则认为测试失败。这种计算方法直接解决了由稳定性条件提出的可行性问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_neg_def(matrix: np.ndarray) - bool:\n    \"\"\"\n    Checks if a symmetric 2x2 matrix is negative definite.\n    A matrix is negative definite if all its eigenvalues are strictly negative.\n    The check is performed against a specified numerical tolerance.\n    \"\"\"\n    # eigvalsh is efficient for symmetric matrices\n    eigenvalues = np.linalg.eigvalsh(matrix)\n    return np.max(eigenvalues)  -1e-9\n\ndef run_test_1(a: float, b: float) - int:\n    \"\"\"\n    Implements the delay-independent LKF test by searching for a feasible certificate.\n    It fixes p=1 and performs a 1D search for q  0.\n\n    Args:\n        a (float): System parameter 'a'.\n        b (float): System parameter 'b'.\n\n    Returns:\n        int: 1 if stable (certificate found), 0 otherwise.\n    \"\"\"\n    p = 1.0  # Fix p=1 due to homogeneity\n    \n    # Search for a feasible q  0 on a linear grid\n    q_vals = np.linspace(1e-6, 100.0, 2000)\n    \n    for q in q_vals:\n        M = np.array([\n            [2 * p * a + q, p * b],\n            [p * b, -q]\n        ])\n        \n        if check_neg_def(M):\n            return 1\n            \n    return 0\n\ndef run_test_2(a: float, b: float, h: float) - int:\n    \"\"\"\n    Implements the Wirtinger-enhanced delay-dependent LKF test for a given h.\n    It fixes p=1 and performs a 2D grid search for q  0 and r  0.\n\n    Args:\n        a (float): System parameter 'a'.\n        b (float): System parameter 'b'.\n        h (float): System delay 'h'.\n\n    Returns:\n        int: 1 if stable (certificate found), 0 otherwise.\n    \"\"\"\n    # h must be positive for this test\n    if h == 0:\n        return 0\n\n    p = 1.0  # Fix p=1\n    \n    # Define a 2D grid for the search\n    q_vals = np.linspace(1e-4, 50.0, 150)\n    r_vals = np.linspace(1e-4, 50.0, 150)\n    \n    # Pre-calculate h-dependent terms for efficiency\n    ha2 = h * a**2\n    hb2 = h * b**2\n    hab = h * a * b\n    r_over_h = 1.0 / h\n\n    for q in q_vals:\n        for r in r_vals:\n            # Construct the N(p,q,r;h) matrix with p=1\n            r_term_11 = r * (ha2 - r_over_h)\n            r_term_12 = r * (hab + r_over_h)\n            r_term_22 = r * (hb2 - r_over_h)\n            \n            N11 = 2 * a + q + r_term_11\n            N12 = b + r_term_12\n            N22 = -q + r_term_22\n            \n            N = np.array([\n                [N11, N12],\n                [N12, N22]\n            ])\n            \n            if check_neg_def(N):\n                return 1\n                \n    return 0\n\ndef solve():\n    \"\"\"\n    Main function to run the stability tests on the provided test suite\n    and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (-0.3, -0.8, 0.5),\n        (-0.3, -0.8, 1.6),\n        (-0.3, -0.8, 3.0),\n        (-2.0, 0.5, 3.0)\n    ]\n\n    results = []\n    for a, b, h in test_cases:\n        d1 = run_test_1(a, b)\n        d2 = run_test_2(a, b, h)\n        results.append(f\"[{d1},{d2}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2747657"}, {"introduction": "时滞相关方法的有效性，很大程度上取决于我们如何精确地处理Lyapunov-Krasovskii泛函 (LKF) 导数中的积分项。这个练习让你亲手比较几种关键积分不等式的性能。通过数值计算Jensen、Wirtinger以及Bessel-Legendre不等式给出的边界的“紧致度”，你将对它们的保守性有更深刻的量化认识，并理解为何现代控制理论倾向于使用更复杂的不等式来获得更优的结果 [@problem_id:2747627]。", "problem": "考虑一个出现在时滯系统 Lyapunov–Krasovskii 泛函中的标量时滞泛函项：由一个正常数 $Q  0$ (代表简化为标量情况的对称正定矩阵) 缩放的二次积分 $\\int_{0}^{h} x(s)^{2} \\, ds$。对于区间 $[0,h]$ 上的给定光滑标量函数 $x(s)$，定义其精确值\n$$\nI(Q,h;x) \\;=\\; Q \\int_{0}^{h} x(s)^{2} \\, ds.\n$$\n在稳定性分析中，一个常见的任务是使用积分不等式来找到 $I(Q,h;x)$ 的下界。这类界有三族：\n- Jensen 不等式界，它仅使用 $x(s)$ 在 $[0,h]$ 上的平均值。\n- 一个基于 Wirtinger 的界，它通过一阶移位 Legendre 模态来丰富平均值。\n- 一个 Bessel–Legendre 界，它将 $x(s)$ 在移位 Legendre 多项式基上的正交展开截断到指定阶数。\n\n您的任务是，对下面指定的每个测试用例，计算以下三个下界，并报告它们相对于 $I(Q,h;x)$ 的紧致度：\n1. 基于 $x(s)$ 平均值的 Jensen 界 $L_{J}$。\n2. 基于前两个移位 Legendre 模态（0 阶和 1 阶）的 Wirtinger 界 $L_{W}$。\n3. 基于前三个移位 Legendre 模态（0 阶、1 阶和 2 阶）的 Bessel–Legendre 界 $L_{BL}$。\n\n任何三角函数中的所有角度均以弧度为单位。\n\n使用的基本原理：\n- 积分的 Cauchy–Schwarz 不等式和 Jensen 不等式。\n- $[0,1]$ 上移位 Legendre 多项式的正交性，即如果 $P_{k}(\\tau)$ 是 $[-1,1]$ 上的 k 阶 Legendre 多项式，那么 $[0,1]$ 上的 $P_{k}^{\\text{sh}}(\\tau) = P_{k}(2\\tau - 1)$ 满足\n$$\n\\int_{0}^{1} P_{k}^{\\text{sh}}(\\tau)\\, P_{\\ell}^{\\text{sh}}(\\tau)\\, d\\tau \\;=\\; \\begin{cases}\n\\frac{1}{2k+1},  k = \\ell,\\\\\n0,  k \\ne \\ell.\n\\end{cases}\n$$\n- 标准正交展开的 Bessel 不等式。\n\n待实现的定义：\n- 定义 $\\tau = s/h$，这样 $s \\in [0,h]$ 映射到 $\\tau \\in [0,1]$ 并且 $ds = h\\, d\\tau$。\n- 令 $P_{k}^{\\text{sh}}(\\tau)$ 为 $[0,1]$ 上的 k 阶移位 Legendre 多项式。使用标准正交族 $\\varphi_{k}(\\tau) = \\sqrt{2k+1}\\, P_{k}^{\\text{sh}}(\\tau)$ on $[0,1]$，定义系数\n$$\nc_{k} \\;=\\; \\int_{0}^{1} x(h \\tau)\\, \\varphi_{k}(\\tau)\\, d\\tau \\;=\\; \\frac{\\sqrt{2k+1}}{h}\\, \\int_{0}^{h} P_{k}^{\\text{sh}}\\!\\left(\\frac{s}{h}\\right) x(s)\\, ds.\n$$\n- $N$ 阶 Bessel–Legendre 下界为\n$$\nL_{N}(Q,h;x) \\;=\\; Q h \\sum_{k=0}^{N} c_{k}^{2} \\;=\\; \\frac{Q}{h} \\sum_{k=0}^{N} (2k+1)\\, \\left(\\int_{0}^{h} P_{k}^{\\text{sh}}\\!\\left(\\frac{s}{h}\\right) x(s)\\, ds\\right)^{2}.\n$$\n- Jensen 界对应于 $N = 0$，即 $L_{J} = L_{0}(Q,h;x)$。\n- 此处的 Wirtinger 界对应于 $N = 1$，即 $L_{W} = L_{1}(Q,h;x)$。\n- 要使用的 Bessel–Legendre 界是二阶截断 $N = 2$，即 $L_{BL} = L_{2}(Q,h;x)$。\n\n对于每个测试用例，高精度数值计算精确积分 $I(Q,h;x)$，通过上述公式计算三个下界 $L_{J}$、$L_{W}$ 和 $L_{BL}$，并报告紧致度比率\n$$\n\\rho_{J} \\;=\\; \\frac{L_{J}}{I(Q,h;x)}, \\qquad\n\\rho_{W} \\;=\\; \\frac{L_{W}}{I(Q,h;x)}, \\qquad\n\\rho_{BL} \\;=\\; \\frac{L_{BL}}{I(Q,h;x)}.\n$$\n\n测试套件：\n- 情况 1（单位区间上的一般三角-仿射函数）：$Q = 2.0$，$h = 1.0$，以及对于 $s \\in [0,1]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 情况 2（小区间行为）：$Q = 5.0$，$h = 0.05$，以及对于 $s \\in [0,0.05]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 情况 3（较长区间）：$Q = 1.5$，$h = 2.0$，以及对于 $s \\in [0,2]$，$x(s) = \\sin(2\\pi s) + 0.3\\, s - 0.1$。\n- 情况 4（在移位 Legendre 基下展开的最高二次多项式；界在 $N=2$ 时变为精确值）：$Q = 1.0$，$h = 3.0$，以及\n$$\nx(s) \\;=\\; a \\;+\\; b\\,\\Big(2\\frac{s}{h} - 1\\Big) \\;+\\; c\\,\\Big(6\\Big(\\frac{s}{h}\\Big)^{2} - 6\\frac{s}{h} + 1\\Big),\n$$\n其中 $a = 0.7$，$b = -1.2$，$c = 0.9$，对于 $s \\in [0,3]$。\n- 情况 5（高振荡性）：$Q = 0.7$，$h = 1.0$，以及对于 $s \\in [0,1]$，$x(s) = \\sin(10\\pi s) + 0.2\\, \\cos(3\\pi s) - 0.05$。\n\n要求的最终输出格式：\n- 对于每种情况，计算三元组 $(\\rho_{J}, \\rho_{W}, \\rho_{BL})$ 并将每个条目四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的三元组列表，且无空格。例如，包含两种情况的有效输出如下所示：\"[[0.123456,0.234567,0.345678],[0.987654,0.876543,0.765432]]\"。", "solution": "问题陈述经评估是有效的。它在控制理论和应用数学领域具有科学依据，特别是关于使用 Lyapunov-Krasovskii 泛函对时滞系统进行稳定性分析。该问题是适定的、客观的，并包含得出唯一解所需的所有必要信息和定义。所提供的任务在计算上是可行的，并且基于已建立的数学原理，如积分不等式和正交多项式展开。\n\n问题的核心是将积分项 $I(Q,h;x) = Q \\int_{0}^{h} x(s)^{2} \\, ds$ 的精确值与从函数 $x(s)$ 的谱展开导出的几个下界进行比较。分析在平方可积函数的 Hilbert 空间中进行，这些界是 Bessel 不等式的直接推论。\n\n我们首先执行变量替换，将积分区间从 $[0,h]$ 映射到 $[0,1]$。令 $\\tau = s/h$，这意味着 $s = h\\tau$ 且 $ds = h\\, d\\tau$。积分 $I(Q,h;x)$ 可以重写为：\n$$\nI(Q,h;x) \\;=\\; Q \\int_{0}^{1} x(h\\tau)^{2} \\, (h\\, d\\tau) \\;=\\; Qh \\int_{0}^{1} [x(h\\tau)]^{2} \\, d\\tau.\n$$\n令 $y(\\tau) = x(h\\tau)$。积分为 $I = Qh \\int_{0}^{1} y(\\tau)^2 d\\tau = Qh \\|y\\|_{L^2[0,1]}^2$，其中 $\\| \\cdot \\|_{L^2[0,1]}$ 是区间 $[0,1]$ 上平方可积函数空间的标准范数。\n\n该问题利用了在 $[0,1]$ 上正交的移位 Legendre 多项式基 $P_{k}^{\\text{sh}}(\\tau)$。它们的正交关系由下式给出：\n$$\n\\int_{0}^{1} P_{k}^{\\text{sh}}(\\tau)\\, P_{\\ell}^{\\text{sh}}(\\tau)\\, d\\tau \\;=\\; \\frac{\\delta_{k\\ell}}{2k+1},\n$$\n其中 $\\delta_{k\\ell}$ 是 Kronecker delta 符号。由此，我们可以为 $L^2[0,1]$ 构建一个标准正交基 $\\{\\varphi_k(\\tau)\\}_{k=0}^{\\infty}$：\n$$\n\\varphi_{k}(\\tau) \\;=\\; \\sqrt{2k+1}\\, P_{k}^{\\text{sh}}(\\tau).\n$$\n任何函数 $y(\\tau) \\in L^2[0,1]$都可以在此基上展开为 $y(\\tau) = \\sum_{k=0}^{\\infty} c_k \\varphi_k(\\tau)$，其中系数 $c_k$ 是 $y$ 在基函数上的投影：\n$$\nc_{k} \\;=\\; \\langle y, \\varphi_k \\rangle \\;=\\; \\int_{0}^{1} y(\\tau)\\, \\varphi_{k}(\\tau)\\, d\\tau.\n$$\n根据 Parseval 等式，函数的范数平方是其 Fourier-Legendre 系数平方的总和：$\\|y\\|^2 = \\sum_{k=0}^{\\infty} c_k^2$。因此，精确积分为：\n$$\nI(Q,h;x) \\;=\\; Qh \\sum_{k=0}^{\\infty} c_k^2.\n$$\nBessel 不等式指出，对于任何有限截断阶数 $N$，系数平方的部分和为总范数平方提供了一个下界：\n$$\n\\sum_{k=0}^{N} c_k^2 \\;\\le\\; \\|y\\|^2.\n$$\n乘以 $Qh$，我们得到积分 $I$ 的下界：\n$$\nL_N(Q,h;x) \\;=\\; Qh \\sum_{k=0}^{N} c_k^2 \\;\\le\\; I(Q,h;x).\n$$\n这正是问题陈述中给出的 Bessel-Legendre 下界的公式。任务是计算截断阶数 $N=0$、$N=1$ 和 $N=2$ 时的这个界。\n\n为了实现计算，我们将系数 $c_k$ 表示为在原始区间 $[0,h]$ 上的积分：\n$$\nc_k = \\int_{0}^{1} x(h\\tau) \\sqrt{2k+1} P_k^{\\text{sh}}(\\tau) d\\tau = \\frac{\\sqrt{2k+1}}{h} \\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds.\n$$\n将此代入 $L_N$ 的公式，我们得到：\n$$\nL_N(Q,h;x) = Qh \\sum_{k=0}^{N} \\left(\\frac{2k+1}{h^2}\\right) \\left(\\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds\\right)^2 = \\frac{Q}{h} \\sum_{k=0}^{N} (2k+1) \\left(\\int_{0}^{h} x(s) P_k^{\\text{sh}}(s/h) ds\\right)^2,\n$$\n这与提供的定义相符。\n\n我们需要前三个移位 Legendre 多项式，其中 $\\tau = s/h$：\n\\begin{itemize}\n    \\item $P_{0}^{\\text{sh}}(\\tau) = 1$\n    \\item $P_{1}^{\\text{sh}}(\\tau) = 2\\tau - 1 = 2\\frac{s}{h} - 1$\n    \\item $P_{2}^{\\text{sh}}(\\tau) = 6\\tau^2 - 6\\tau + 1 = 6\\left(\\frac{s}{h}\\right)^2 - 6\\frac{s}{h} + 1$\n\\end{itemize}\n\n我们定义矩 $m_k = \\int_{0}^{h} x(s) P_{k}^{\\text{sh}}(s/h) ds$。这些界可以写成：\n\\begin{enumerate}\n    \\item Jensen 界 $L_J = L_0$：\n    $$L_{J} = \\frac{Q}{h} (2(0)+1) m_0^2 = \\frac{Q}{h} \\left(\\int_0^h x(s) ds\\right)^2.$$\n    \\item 基于 Wirtinger 的界 $L_W = L_1$：\n    $$L_{W} = \\frac{Q}{h} \\left(m_0^2 + 3m_1^2\\right) = L_J + \\frac{3Q}{h} \\left(\\int_0^h \\left(2\\frac{s}{h}-1\\right)x(s) ds\\right)^2.$$\n    \\item Bessel-Legendre 界 $L_{BL} = L_2$：\n    $$L_{BL} = \\frac{Q}{h} \\left(m_0^2 + 3m_1^2 + 5m_2^2\\right) = L_W + \\frac{5Q}{h} \\left(\\int_0^h \\left(6\\left(\\frac{s}{h}\\right)^2 - 6\\frac{s}{h} + 1\\right)x(s) ds\\right)^2.$$\n\\end{enumerate}\n从这些表达式可以清楚地看出 $L_J \\le L_W \\le L_{BL} \\le I$。这些界的紧致度，由比率 $\\rho = L/I$ 表示，预计会随着阶数 $N$ 的增加而提高。\n\n对于每个测试用例，我们将使用高精度求积法（特别是 `scipy.integrate.quad` 函数）来数值计算所需的定积分。然后，我们使用这些值来组装 $I$、$L_J$、$L_W$ 和 $L_{BL}$，并最终计算紧致度比率 $\\rho_J, \\rho_W, \\rho_{BL}$。对于特殊情况 4，其中 $x(s)$ 是前三个基多项式的线性组合，我们预期界 $L_{BL}$ 是精确的，即 $\\rho_{BL}=1.0$，因为其展开式不包含更高阶的项。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\n\ndef solve():\n    \"\"\"\n    Computes Jensen, Wirtinger-based, and Bessel-Legendre lower bounds for\n    a quadratic integral term and reports their tightness.\n    \"\"\"\n\n    # Define test cases: (Q, h, function x(s), extra params for x(s))\n    test_cases = [\n        # Case 1\n        (2.0, 1.0, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 2\n        (5.0, 0.05, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 3\n        (1.5, 2.0, \n         lambda s, h, params: np.sin(2 * np.pi * s) + 0.3 * s - 0.1, \n         None),\n        # Case 4\n        (1.0, 3.0, \n         lambda s, h, params: params['a'] + params['b'] * (2 * s / h - 1) + \n                              params['c'] * (6 * (s / h)**2 - 6 * s / h + 1), \n         {'a': 0.7, 'b': -1.2, 'c': 0.9}),\n        # Case 5\n        (0.7, 1.0, \n         lambda s, h, params: np.sin(10 * np.pi * s) + 0.2 * np.cos(3 * np.pi * s) - 0.05, \n         None),\n    ]\n\n    # Shifted Legendre Polynomials as functions of tau = s/h\n    P0_sh = lambda tau: 1.0\n    P1_sh = lambda tau: 2.0 * tau - 1.0\n    P2_sh = lambda tau: 6.0 * tau**2 - 6.0 * tau + 1.0\n\n    results = []\n    \n    for case in test_cases:\n        Q, h, x_func, params = case\n\n        # Integrand for the exact value I\n        integrand_I = lambda s: (x_func(s, h, params))**2\n        \n        # Integrands for the moments m_k\n        integrand_m0 = lambda s: P0_sh(s / h) * x_func(s, h, params)\n        integrand_m1 = lambda s: P1_sh(s / h) * x_func(s, h, params)\n        integrand_m2 = lambda s: P2_sh(s / h) * x_func(s, h, params)\n\n        # Numerical integration using scipy.integrate.quad for high accuracy\n        I_val = Q * integrate.quad(integrand_I, 0, h)[0]\n        m0 = integrate.quad(integrand_m0, 0, h)[0]\n        m1 = integrate.quad(integrand_m1, 0, h)[0]\n        m2 = integrate.quad(integrand_m2, 0, h)[0]\n\n        # Calculate the lower bounds\n        L_J = (Q / h) * (m0**2)\n        L_W = L_J + (Q / h) * 3 * (m1**2)\n        L_BL = L_W + (Q / h) * 5 * (m2**2)\n        \n        # Protective check for I_val being close to zero\n        if np.isclose(I_val, 0):\n            # If I=0, then x(s)=0 almost everywhere. All bounds must be 0.\n            # In this scenario, define tightness as 1.0.\n            rho_J, rho_W, rho_BL = 1.0, 1.0, 1.0\n        else:\n            # Calculate the tightness ratios\n            rho_J = L_J / I_val\n            rho_W = L_W / I_val\n            rho_BL = L_BL / I_val\n\n        results.append((rho_J, rho_W, rho_BL))\n\n    # Format the output string as specified\n    formatted_results = []\n    for r_tuple in results:\n        # Round to 6 decimal places and format\n        formatted_tuple = f\"[{r_tuple[0]:.6f},{r_tuple[1]:.6f},{r_tuple[2]:.6f}]\"\n        formatted_results.append(formatted_tuple)\n\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2747627"}, {"introduction": "这个最终练习将前面所学的概念融会贯通，构成一个完整的分析任务。你将从一个给定的Lyapunov-Krasovskii泛函出发，推导出一个时滞相关的线性矩阵不等式 (LMI) 稳定性条件，并最终编写一个数值算法来估算系统能够保持稳定的最大时滞 $h_{\\max}$。这个练习完美地连接了理论推导与计算实践，是现代控制工程师必备的一项核心技能 [@problem_id:2747632]。", "problem": "考虑由迟滞型泛函微分方程 $ \\dot{x}(t) = A x(t) + A_d x(t - h) $ 定义的线性时滞系统，其中 $ A \\in \\mathbb{R}^{n \\times n} $，$ A_d \\in \\mathbb{R}^{n \\times n} $，且 $ h \\ge 0 $ 是一个常数时滞。从Lyapunov-Krasovskii泛函（LKF）的基本定义和基础微积分出发，使用形式为 $ V(x_t) = x(t)^{\\top} P x(t) + \\int_{t-h}^{t} x(s)^{\\top} Q x(s) \\, ds + \\int_{t-h}^{t} \\int_{s}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau \\, ds $ 的二次Lyapunov-Krasovskii泛函，其中 $ P \\in \\mathbb{S}_{++}^{n} $，$ Q \\in \\mathbb{S}_{+}^{n} $ 和 $ R \\in \\mathbb{S}_{+}^{n} $ 是决策变量。通过结合乘法法则、微积分基本定理以及应用于 $ \\int_{t-h}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau $ 的Jensen不等式，推导出一个关于 $ P $，$ Q $，$ R $ 和 $ h $ 的时滞相关线性矩阵不等式（LMI）条件，该条件保证对于某个 $ \\epsilon  0 $，有 $ \\dot{V}(x_t) \\le - \\epsilon \\| x(t) \\|^2 $ 成立，从而保证零解的渐近稳定性。\n\n然后，你必须实现一个数值程序，使用以下约束来估计确保稳定性的最大容许常数时滞 $ h_{\\max} $：\n- 限制于特殊情况 $ n = 2 $，其中 $ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $，$ A_d $ 由测试套件指定。\n- 将决策矩阵限制为单位矩阵的标量倍数：$ P = p I_2 $，$ Q = q I_2 $，$ R = r I_2 $，其中 $ p  0 $，$ q \\ge 0 $，$ r  0 $。\n- 对于固定的 $ h $，必须通过检验相关的对称分块矩阵是否为负定来检查关于变量 $ p $，$ q $，$ r $ 的LMI。如果在有限搜索集中存在使该条件成立的 $ p $，$ q $，$ r $，则证明可行。\n- 对于给定的有限 $ H_{\\text{search}} $，通过在 $ h \\in [0, H_{\\text{search}}] $ 上进行二分法来估计 $ h_{\\max} $，并使用上述可行性检验作为判据。如果系统对于所有 $ h \\in [0, H_{\\text{search}}] $ 都是可行的，则在该测试用例中报告 $ h_{\\max} = H_{\\text{search}} $。\n\n你必须按如下方式实现数值搜索：\n- 对于给定 $ h $ 的每次可行性检验，在有限网格 $ \\mathcal{G}_p \\times \\mathcal{G}_q \\times \\mathcal{G}_r $ 上进行搜索，其中 $ \\mathcal{G}_p = \\{ 0.1, 0.5, 1, 2, 5, 10 \\} $，$ \\mathcal{G}_q = \\{ 0, 0.5, 1, 2, 5, 10 \\} $，$ \\mathcal{G}_r = \\{ 0.1, 0.5, 1, 2, 5, 10 \\} $。如果此网格中的任何三元组 $ (p, q, r) $ 产生的LMI矩阵是负定的，则声明可行。\n- 使用至少 $ 25 $ 次迭代的二分法来估计 $ h_{\\max} $，起始于一个小的严格正数下界和一个有限上界 $ H_{\\text{search}} = 5 $。如果在 $ h = H_{\\text{search}} $ 处可行性检验成功，则返回 $ h_{\\max} = H_{\\text{search}} $。如果即使在极小的正 $ h $ 值处可行性也失败，则返回 $ h_{\\max} = 0 $。\n\n测试套件：\n- 情况1（基准）：$ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $，$ A_d = \\begin{bmatrix} 0  0 \\\\ 0  -1 \\end{bmatrix} $。\n- 情况2（无时滞效应）：$ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $，$ A_d = \\begin{bmatrix} 0  0 \\\\ 0  0 \\end{bmatrix} $。\n- 情况3（中等时滞效应）：$ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $，$ A_d = 2 \\cdot \\begin{bmatrix} 0  0 \\\\ 0  -1 \\end{bmatrix} $。\n- 情况4（强时滞效应）：$ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $，$ A_d = 4 \\cdot \\begin{bmatrix} 0  0 \\\\ 0  -1 \\end{bmatrix} $。\n\n输出要求：\n- 报告每个测试用例估计的 $ h_{\\max} $（单位：秒），并四舍五入到小数点后四位。\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[h1,h2,h3,h4]”），其中每个 $ h_i $ 对应于上面列出的一个测试用例。", "solution": "我们考虑具有常数时滞 $ h \\ge 0 $ 的线性时滞系统 $ \\dot{x}(t) = A x(t) + A_d x(t - h) $。我们使用Lyapunov-Krasovskii泛函（LKF）来寻求一个时滞相关的稳定性条件。我们从核心原理开始：导数的定义、乘法法则、微积分基本定理和Jensen不等式。\n\n定义二次LKF\n$$\nV(x_t) = V_1 + V_2 + V_3,\n$$\n其中\n$$\nV_1 = x(t)^{\\top} P x(t), \\quad V_2 = \\int_{t-h}^{t} x(s)^{\\top} Q x(s) \\, ds, \\quad V_3 = \\int_{t-h}^{t} \\int_{s}^{t} \\dot{x}(\\tau)^{\\top} R \\dot{x}(\\tau) \\, d\\tau \\, ds,\n$$\n其中 $ P \\in \\mathbb{S}_{++}^{n} $，$ Q \\in \\mathbb{S}_{+}^{n} $ 和 $ R \\in \\mathbb{S}_{+}^{n} $。我们使用微积分基本定理和标准微分法则逐项计算导数。\n\n1) 对于 $ V_1 $，使用乘法法则和 $ P $ 的对称性，\n$$\n\\dot{V}_1 = \\dot{x}(t)^{\\top} P x(t) + x(t)^{\\top} P \\dot{x}(t) = 2 x(t)^{\\top} P \\dot{x}(t) = x(t)^{\\top} (A^{\\top} P + P A) x(t) + 2 x(t)^{\\top} P A_d x(t - h).\n$$\n\n2) 对于 $ V_2 $，根据微积分基本定理，\n$$\n\\dot{V}_2 = x(t)^{\\top} Q x(t) - x(t - h)^{\\top} Q x(t - h).\n$$\n\n3) 对于 $ V_3 $，其导数为\n$$\n\\dot{V}_3 = h \\, \\dot{x}(t)^{\\top} R \\dot{x}(t) - \\int_{t-h}^{t} \\dot{x}(s)^{\\top} R \\dot{x}(s) \\, ds.\n$$\n将Jensen不等式应用于长度为 $ h $ 的区间上关于 $ \\dot{x} $ 的凸二次型，得到\n$$\n\\int_{t-h}^{t} \\dot{x}(s)^{\\top} R \\dot{x}(s) \\, ds \\ge \\frac{1}{h} \\left( \\int_{t-h}^{t} \\dot{x}(s) \\, ds \\right)^{\\top} R \\left( \\int_{t-h}^{t} \\dot{x}(s) \\, ds \\right).\n$$\n注意到 $ \\int_{t-h}^{t} \\dot{x}(s) \\, ds = x(t) - x(t - h) $，我们得到界\n$$\n\\dot{V}_3 \\le h \\, \\dot{x}(t)^{\\top} R \\dot{x}(t) - \\frac{1}{h} \\left( x(t) - x(t - h) \\right)^{\\top} R \\left( x(t) - x(t - h) \\right).\n$$\n\n结合 $ \\dot{V}_1 $、$ \\dot{V}_2 $ 和 $ \\dot{V}_3 $ 的界，并代入 $ \\dot{x}(t) = A x(t) + A_d x(t-h) $，我们可以将总导数的上界表示为关于堆叠向量 $ \\xi = \\begin{bmatrix} x(t) \\\\ x(t-h) \\end{bmatrix} $ 的二次型：\n$$\n\\dot{V}(x_t) \\le \\xi^{\\top} \\mathcal{M}(h) \\, \\xi,\n$$\n其分块矩阵为\n$$\n\\mathcal{M}(h) = \\begin{bmatrix}\nM_{11}  M_{12} \\\\\nM_{12}^{\\top}  M_{22}\n\\end{bmatrix},\n$$\n其中\n$$\n\\begin{aligned}\nM_{11} = A^{\\top} P + P A + Q + h \\, A^{\\top} R A - \\frac{1}{h} R, \\\\\nM_{12} = P A_d + h \\, A^{\\top} R A_d + \\frac{1}{h} R, \\\\\nM_{22} = - Q + h \\, A_d^{\\top} R A_d - \\frac{1}{h} R.\n\\end{aligned}\n$$\n渐近稳定性的一个充分条件是，对于某个 $ P \\in \\mathbb{S}_{++}^{n} $、$ Q \\in \\mathbb{S}_{+}^{n} $ 和 $ R \\in \\mathbb{S}_{+}^{n} $，有 $ \\mathcal{M}(h) \\prec 0 $。因为根据S-procedure和标准的紧性论证，这蕴含了对于某个 $ \\epsilon  0 $，有 $ \\dot{V}(x_t) \\le -\\epsilon \\| x(t) \\|^2 $。对于固定的 $ h $，条件 $ \\mathcal{M}(h) \\prec 0 $ 是一个关于决策矩阵 $ P $、$ Q $ 和 $ R $ 的线性矩阵不等式（LMI）。\n\n为了使可行性检验在计算上简单，并且无需专用的半定规划求解器即可完全实现，我们在 $ n = 2 $ 的情况下限制为单位矩阵的标量倍数，即 $ P = p I_2 $，$ Q = q I_2 $，$ R = r I_2 $，其中 $ p  0 $，$ q \\ge 0 $，$ r  0 $。在此限制下，$ M_{11} $，$ M_{12} $ 和 $ M_{22} $ 成为 $ p $，$ q $，$ r $ 和 $ h $ 的显式函数，而检验 $ \\mathcal{M}(h) \\prec 0 $ 则简化为验证 $ 4 \\times 4 $ 对称矩阵 $ \\mathcal{M}(h) $ 的所有特征值均为严格负数。\n\n算法设计：\n- 对于每个固定的 $ h $，在有限网格 $ \\mathcal{G}_p \\times \\mathcal{G}_q \\times \\mathcal{G}_r $ 上进行网格搜索，其中 $ \\mathcal{G}_p = \\{ 0.1, 0.5, 1, 2, 5, 10 \\} $，$ \\mathcal{G}_q = \\{ 0, 0.5, 1, 2, 5, 10 \\} $，$ \\mathcal{G}_r = \\{ 0.1, 0.5, 1, 2, 5, 10 \\} $。对于每个三元组，组装 $ \\mathcal{M}(h) $ 并通过其特征值测试负定性。如果任何三元组产生负定矩阵，则声明在该 $ h $ 处可行。\n- 在 $ h \\in [h_{\\text{low}}, H_{\\text{search}}] $ 上使用二分法，其中 $ h_{\\text{low}} $ 是一个小的严格正数（例如 $ 10^{-6} $），以找到可行时滞的上确界。首先通过在 $ h = H_{\\text{search}} = 5 $ 处检查可行性来初始化。如果可行，则报告 $ h_{\\max} = H_{\\text{search}} $。否则，确保在小的 $ h_{\\text{low}} $ 处可行；如果即使在那里也不可行，则报告 $ h_{\\max} = 0 $。如果在 $ h_{\\text{low}} $ 处可行而在 $ H_{\\text{search}} $ 处不可行，则执行至少 $ 25 $ 次二分法迭代，以遇到的最大可行 $ h $ 来从下方逼近 $ h_{\\max} $。\n- 测试套件包含四个案例，它们具有相同的 $ A = \\begin{bmatrix} 0  1 \\\\ -2  -3 \\end{bmatrix} $ 和如上所列的不同 $ A_d $。这些案例涵盖了一个基准情况、一个无时滞耦合的边界场景，以及逐渐增强的时滞反馈强度。\n\n数值输出：\n- 对于每个测试用例，返回估计的 $ h_{\\max} $（单位：秒），并四舍五入到小数点后四位。\n- 以“[h1,h2,h3,h4]”的格式单行输出结果。\n\n由于对 $ P $、$ Q $ 和 $ R $ 施加了对角标量限制，以及Jensen不等式的松弛，这种方法是保守的；因此，估计的 $ h_{\\max} $ 是真实最大容许时滞的一个下界。尽管如此，该方法是系统可计算的，并且基于推导出的LMI条件，满足了使用Lyapunov-Krasovskii泛函和第一性原理的要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_M(A, Ad, h, p, q, r):\n    \"\"\"\n    Assemble the 4x4 symmetric LMI matrix M(h) using:\n    P = p * I, Q = q * I, R = r * I for 2x2 A, Ad.\n    \"\"\"\n    I = np.eye(2)\n    P = p * I\n    Q = q * I\n    R = r * I\n\n    AT = A.T\n    AdT = Ad.T\n\n    # Blocks according to the derived expressions\n    M11 = AT @ P + P @ A + Q + h * (AT @ R @ A) - (1.0 / h) * R\n    M12 = P @ Ad + h * (AT @ R @ Ad) + (1.0 / h) * R\n    M21 = M12.T\n    M22 = -Q + h * (AdT @ R @ Ad) - (1.0 / h) * R\n\n    # Form the full 4x4 block matrix\n    upper = np.hstack((M11, M12))\n    lower = np.hstack((M21, M22))\n    M = np.vstack((upper, lower))\n    # Ensure symmetry numerically\n    M = 0.5 * (M + M.T)\n    return M\n\ndef is_negative_definite(M, tol=-1e-9):\n    \"\"\"\n    Check if M is strictly negative definite by verifying eigenvalues  tol.\n    \"\"\"\n    # Use symmetric eigenvalue solver\n    evals = np.linalg.eigvalsh(M)\n    return np.max(evals)  tol\n\ndef feasible_for_h(A, Ad, h, grid_p, grid_q, grid_r):\n    \"\"\"\n    Feasibility oracle: returns True if there exist p, q, r in the provided grids\n    such that the LMI matrix M(h) is negative definite.\n    \"\"\"\n    for p in grid_p:\n        for q in grid_q:\n            for r in grid_r:\n                # p  0, q = 0, r  0 ensured by grids\n                M = assemble_M(A, Ad, h, p, q, r)\n                if is_negative_definite(M):\n                    return True\n    return False\n\ndef estimate_hmax(A, Ad, H_search=5.0, max_bisect_iter=30):\n    \"\"\"\n    Estimate h_max by bisection using the feasibility oracle.\n    If feasible at H_search, return H_search.\n    If infeasible even at tiny h, return 0.0.\n    Else perform bisection to approximate the boundary from below.\n    \"\"\"\n    grid_p = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0]\n    grid_q = [0.0, 0.5, 1.0, 2.0, 5.0, 10.0]\n    grid_r = [0.1, 0.5, 1.0, 2.0, 5.0, 10.0]\n\n    # Check at the upper bound\n    if feasible_for_h(A, Ad, H_search, grid_p, grid_q, grid_r):\n        return H_search\n\n    # Find a small feasible lower bound\n    small_h_candidates = [1e-3, 1e-4, 1e-5, 1e-6]\n    h_low = None\n    for h0 in small_h_candidates:\n        if feasible_for_h(A, Ad, h0, grid_p, grid_q, grid_r):\n            h_low = h0\n            break\n    if h_low is None:\n        return 0.0\n\n    h_high = H_search\n    # Bisection\n    for _ in range(max_bisect_iter):\n        h_mid = 0.5 * (h_low + h_high)\n        if feasible_for_h(A, Ad, h_mid, grid_p, grid_q, grid_r):\n            h_low = h_mid\n        else:\n            h_high = h_mid\n    return h_low\n\ndef solve():\n    # Define the test cases from the problem statement.\n    A = np.array([[0.0, 1.0],\n                  [-2.0, -3.0]])\n\n    Ad_base = np.array([[0.0, 0.0],\n                        [0.0, -1.0]])\n\n    test_cases = [\n        (A, Ad_base.copy()),                      # Case 1\n        (A, np.zeros_like(Ad_base)),             # Case 2\n        (A, 2.0 * Ad_base.copy()),               # Case 3\n        (A, 4.0 * Ad_base.copy()),               # Case 4\n    ]\n\n    H_search = 5.0\n    results = []\n    for A_case, Ad_case in test_cases:\n        h_est = estimate_hmax(A_case, Ad_case, H_search=H_search, max_bisect_iter=30)\n        # Round to four decimals\n        h_est_rounded = round(h_est + 0.0, 4)\n        results.append(h_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2747632"}]}