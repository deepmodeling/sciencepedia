{"hands_on_practices": [{"introduction": "在控制一个网络化系统之前，我们必须能够估计其状态。本练习探讨了*集体能观性* (collective observability) 这一基本概念，它决定了来自所有智能体的组合测量是否足以重构整个系统的状态。你将应用线性系统理论的基石——Popov-Belevitch-Hautus (PBH) 测试——来诊断能观性，并确定为保证能观性所需的最小传感器增补数量。[@problem_id:2701991]", "problem": "考虑一个状态维度为 $n = 4$ 的线性时不变网络系统，其控制方程为 $\\dot{x}(t) = A x(t)$，其中\n$$\nA = \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  2  0\\\\\n0  0  0  3\n\\end{pmatrix}.\n$$\n存在 $3$ 个传感智能体（节点），索引为 $i \\in \\{1,2,3\\}$，每个智能体都有一个局部测量值 $y_i(t) = C_i x(t)$。局部传感矩阵为\n$$\nC_1 = \\begin{pmatrix}1  0  0  0\\end{pmatrix},\\quad\nC_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix},\\quad\nC_3 = \\begin{pmatrix}0  0  0  1\\end{pmatrix}.\n$$\n这 $3$ 个智能体之间的有向通信图是强连通的，其边集为 $\\{(1,2),(2,3),(3,1)\\}$。智能体可以通过此图交换信息。\n\n仅使用线性系统和网络化估计的基本定义，判断该系统在所有可用传感器的联合作用下（即使用堆叠测量矩阵 $C = \\begin{pmatrix} C_1^{\\vphantom{\\top}} \\\\ C_2^{\\vphantom{\\top}} \\\\ C_3^{\\vphantom{\\top}} \\end{pmatrix}$）是否是集体可观测的。如果不可观测，计算需要添加的形如 $y_{\\text{add}}(t) = e_j^{\\top} x(t)$ 的标量传感器的最小数量 $m$，其中 $e_j$ 是 $\\mathbb{R}^{4}$ 中的标准基向量且 $j \\in \\{1,2,3,4\\}$，这些传感器可以放置在任何节点上，以使得联合传感使系统对 $(A,C_{\\text{aug}})$ 可观测。请将您的最终答案以整数 $m$ 的形式给出。如果系统已经是可观测的，则给出 $m=0$。最终答案必须是单个整数；无需进行四舍五入。", "solution": "问题要求分析一个给定的线性时不变系统的集体可观测性，并确定在系统本身不可观测的情况下，为实现可观测性所需添加的最小标准传感器数量。\n\n首先，我们必须按规定将“集体可观测性”这一概念形式化。问题指出，这是在“所有可用传感器的联合作用下”的可观测性。对于线性系统 $\\dot{x}(t) = Ax(t)$，这等同于检查系统对 $(A, C)$ 的可观测性，其中 $A$ 是状态矩阵，$C$ 是所有单个传感器矩阵 $C_i$ 堆叠而成的矩阵。有关通信图拓扑的信息与*分布式*可观测性相关，在分布式可观测性中，每个智能体必须使用局部测量值及其邻居的信息来估计状态。然而，对于集体可观测性，我们考虑的是一个集中式场景，其中所有测量值都是立即可用的。\n\n状态矩阵为：\n$$\nA = \\begin{pmatrix}\n1  0  0  0\\\\\n0  1  0  0\\\\\n0  0  2  0\\\\\n0  0  0  3\n\\end{pmatrix}\n$$\n各个传感器矩阵为：\n$$\nC_1 = \\begin{pmatrix}1  0  0  0\\end{pmatrix},\\quad\nC_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix},\\quad\nC_3 = \\begin{pmatrix}0  0  0  1\\end{pmatrix}\n$$\n集体测量矩阵 $C$ 是通过堆叠这些单个矩阵形成的：\n$$\nC = \\begin{pmatrix} C_1 \\\\ C_2 \\\\ C_3 \\end{pmatrix} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n$$\n状态维度为 $n=4$。为了判断系统对 $(A, C)$ 是否可观测，我们将使用 Popov-Belevitch-Hautus (PBH) 准则。PBH 准则指出，系统对 $(A, C)$ 可观测的充分必要条件是对于 $A$ 的每一个特征值 $\\lambda$，矩阵\n$$\n\\begin{pmatrix} A - \\lambda I \\\\ C \\end{pmatrix}\n$$\n具有满列秩，即秩为 $n=4$。\n\n由于 $A$ 是一个对角矩阵，其特征值就是其对角线上的元素。$A$ 的特征值集合，记为 $\\sigma(A)$，是 $\\{1, 1, 2, 3\\}$。我们必须对每个不同的特征值检查 PBH 秩条件：$\\lambda=1$，$\\lambda=2$ 和 $\\lambda=3$。\n\n情况 1：$\\lambda = 2$\n与此特征值对应的特征向量是 $v_2 = e_3 = (0, 0, 1, 0)^{\\top}$。一个模式是可观测的，当且仅当对于与该模式相关的任何特征向量 $v$，都有 $Cv \\neq 0$。\n$$\nC v_2 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\end{pmatrix} \\neq 0\n$$\n由于 $C v_2 \\neq 0$，与 $\\lambda=2$ 相关的模式是可观测的。\n\n情况 2：$\\lambda = 3$\n与此特征值对应的特征向量是 $v_3 = e_4 = (0, 0, 0, 1)^{\\top}$。我们检查：\n$$\nC v_3 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 1 \\end{pmatrix} \\neq 0\n$$\n由于 $C v_3 \\neq 0$，与 $\\lambda=3$ 相关的模式是可观测的。\n\n情况 3：$\\lambda = 1$\n这个特征值的代数重数为 $2$。矩阵 $A$ 是对角矩阵，所以几何重数也为 $2$。与 $\\lambda=1$ 相关的特征空间由特征向量 $v_{1a} = e_1 = (1, 0, 0, 0)^{\\top}$ 和 $v_{1b} = e_2 = (0, 1, 0, 0)^{\\top}$ 张成。\n如果存在一个 $A$ 的非零特征向量 $v$ 位于 $C$ 的核空间中，即 $Cv=0$，则系统对 $(A,C)$ 是不可观测的。我们对 $\\lambda=1$ 的特征空间的基向量进行检查。\n对于 $v_{1a} = e_1$：\n$$\nC e_1 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\neq 0\n$$\n对于 $v_{1b} = e_2$：\n$$\nC e_2 = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\n\\end{pmatrix}\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix} = 0\n$$\n我们找到了一个非零特征向量 $v_{1b} = e_2$，使得 $C v_{1b} = 0$。这意味着与此特征向量相关的模式是不可观测的。不可观测子空间是此特征向量的张成空间，即 $\\text{span}\\{e_2\\}$。因此，该系统不是集体可观测的。\n\n现在的问题是找到使系统可观测所需添加的形如 $y_{\\text{add}}(t) = e_j^{\\top} x(t)$（其中 $j \\in \\{1,2,3,4\\}$）的传感器的最小数量 $m$。添加这样一个传感器对应于将行向量 $e_j^{\\top}$ 附加到测量矩阵 $C$ 上。设增广矩阵为 $C_{\\text{aug}}$。\n为了使与 $e_2$ 对应的不可观测模式变为可观测，增广测量矩阵 $C_{\\text{aug}}$ 必须满足 $C_{\\text{aug}}e_2 \\neq 0$。这要求至少有一个添加的行向量 $e_j^{\\top}$ 满足 $e_j^{\\top} e_2 \\neq 0$。\n我们对每个可能的 $j$ 计算乘积 $e_j^{\\top} e_2$：\n\\begin{itemize}\n    \\item $j=1$：$e_1^{\\top} e_2 = \\begin{pmatrix}1  0  0  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n    \\item $j=2$：$e_2^{\\top} e_2 = \\begin{pmatrix}0  1  0  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 1 \\neq 0$。\n    \\item $j=3$：$e_3^{\\top} e_2 = \\begin{pmatrix}0  0  1  0\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n    \\item $j=4$：$e_4^{\\top} e_2 = \\begin{pmatrix}0  0  0  1\\end{pmatrix} \\begin{pmatrix}0 \\\\ 1 \\\\ 0 \\\\ 0\\end{pmatrix} = 0$。\n\\end{itemize}\n唯一能够观测状态分量 $x_2$（从而观测到不可观测模式）的传感器选择是对应于 $j=2$ 的传感器，即 $y_{\\text{add}}(t) = e_2^{\\top}x(t) = x_2(t)$。\n添加这单个传感器就足够了。让我们用这个附加的传感器构建新的增广矩阵 $C_{\\text{aug}}$：\n$$\nC_{\\text{aug}} = \\begin{pmatrix} C \\\\ e_2^{\\top} \\end{pmatrix} = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\\\\\n0  1  0  0\n\\end{pmatrix}\n$$\n这个矩阵是一个置换矩阵，因此具有满秩 $4$。现在我们必须检查系统对 $(A, C_{\\text{aug}})$ 的可观测性。由于添加传感器不会消除可观测性，所以 $\\lambda=2$ 和 $\\lambda=3$ 的模式仍然是可观测的。我们只需要重新检查 $\\lambda=1$ 的特征空间。\n该特征空间中的任何向量 $v$ 的形式都为 $v = \\alpha e_1 + \\beta e_2 = (\\alpha, \\beta, 0, 0)^{\\top}$。如果对于某个非零向量 $v$（即 $\\alpha$ 或 $\\beta$ 不为零），有 $C_{\\text{aug}}v=0$，则该模式是不可观测的。\n$$\nC_{\\text{aug}}v = \\begin{pmatrix}\n1  0  0  0\\\\\n0  0  1  0\\\\\n0  0  0  1\\\\\n0  1  0  0\n\\end{pmatrix}\n\\begin{pmatrix} \\alpha \\\\ \\beta \\\\ 0 \\\\ 0 \\end{pmatrix} =\n\\begin{pmatrix} \\alpha \\\\ 0 \\\\ 0 \\\\ \\beta \\end{pmatrix}\n$$\n要使 $C_{\\text{aug}}v = 0$，我们要求 $\\alpha=0$ 和 $\\beta=0$，这意味着 $v=0$。因此，在该特征空间中没有非零的不可观测特征向量。系统 $(A, C_{\\text{aug}})$ 现在是完全可观测的。\n由于原始系统是不可观测的，所以必须至少添加一个传感器。我们已经证明，添加一个特定的传感器就足够了。因此，所需添加的传感器的最小数量是 $m=1$。\n最终答案必须是单个整数，即 $1$。", "answer": "$$\n\\boxed{1}\n$$", "id": "2701991"}, {"introduction": "通信延迟是网络化系统中不可避免的现实，它可能导致原本行为良好的算法变得不稳定。本问题挑战你分析一个在单步延迟下运行的共识协议，这种情况会将系统转化为一个二阶动态系统。你的目标是推导出能最大化收敛速率的最优步长，这是一个经典问题，需要平衡网络中最快和最慢模式的动态特性。[@problem_id:2702001]", "problem": "考虑一个由$n$个智能体组成的网络，这些智能体通过一个无向、连通的加权图互连，其图拉普拉斯矩阵为$L \\in \\mathbb{R}^{n \\times n}$。设智能体运行一个具有已知单步通信延迟的离散时间线性一致性迭代，因此对于时间索引$k \\in \\mathbb{Z}_{\\ge 0}$，全局状态$x(k) \\in \\mathbb{R}^{n}$根据以下公式演化：\n$$\nx(k+1) \\;=\\; x(k) \\;-\\; \\alpha \\, L \\, x(k-1),\n$$\n其中$\\alpha > 0$是一个恒定步长，$x(-1), x(0)$是任意初始条件。假设图是连通的，因此$L$的特征值满足$0 = \\lambda_{1}  \\lambda_{2} \\le \\cdots \\le \\lambda_{n}$。与$\\lambda_{1} = 0$相关联的保平均模式被允许是临界稳定的，但所有其他模式必须是渐近Schur稳定的。一致性动力学的收敛速率由所有$\\lambda \\in [\\lambda_{2}, \\lambda_{n}]$中衰减最慢的非一致性模式决定，并且稳定性约束要求对于所有非零拉普拉斯特征值，都有$\\alpha \\lambda  1$。\n\n仅从图拉普拉斯矩阵和线性时不变动力学的定义出发，并仅使用标准的线性系统理论，推导在所述稳定性约束条件下，能够最小化所有非一致性模式中最坏情况渐近收敛因子的唯一步长$\\alpha^{\\star}$的闭式表达式。用$\\lambda_{2}$和$\\lambda_{n}$表示$\\alpha^{\\star}$。你的最终答案必须是一个无单位的单一闭式表达式。", "solution": "所述问题具有科学依据、适定、客观且自洽。它是网络上线性一致性动力学分析中的一个标准问题。不存在使其无效的缺陷。我们开始进行推导。\n\n系统的动力学由关于状态$x(k) \\in \\mathbb{R}^{n}$的二阶线性差分方程给出：\n$$\nx(k+1) = x(k) - \\alpha L x(k-1)\n$$\n其中$k \\in \\mathbb{Z}_{\\ge 0}$，$\\alpha > 0$是步长，$L \\in \\mathbb{R}^{n \\times n}$是图拉普拉斯矩阵。为了分析稳定性和收敛性，我们首先将此系统表示为一阶状态空间形式。令增广状态向量为$z(k) = \\begin{pmatrix} x(k) \\\\ x(k-1) \\end{pmatrix} \\in \\mathbb{R}^{2n}$。状态更新方程变为：\n$$\nz(k+1) = \\begin{pmatrix} x(k+1) \\\\ x(k) \\end{pmatrix} = \\begin{pmatrix} I  -\\alpha L \\\\ I  0 \\end{pmatrix} \\begin{pmatrix} x(k) \\\\ x(k-1) \\end{pmatrix} = A z(k)\n$$\n其中$A = \\begin{pmatrix} I  -\\alpha L \\\\ I  0 \\end{pmatrix}$是系统矩阵。\n\n通过使用拉普拉斯矩阵$L$的特征分解来解耦动力学，可以简化分析。由于对于无向图，$L$是一个实对称矩阵，因此它可以通过一个正交矩阵$U$对角化。设$L = U \\Lambda U^T$，其中$U$是一个正交矩阵（$U^T U = I$），其列是$L$的特征向量，$\\Lambda = \\text{diag}(\\lambda_1, \\lambda_2, \\dots, \\lambda_n)$是相应特征值组成的对角矩阵。已知$0 = \\lambda_1  \\lambda_2 \\le \\dots \\le \\lambda_n$。\n\n定义变换后的状态向量$\\hat{x}(k) = U^T x(k)$。在这个新基下的动力学为：\n$$\nU \\hat{x}(k+1) = U \\hat{x}(k) - \\alpha L U \\hat{x}(k-1)\n$$\n从左侧乘以$U^T$得到：\n$$\n\\hat{x}(k+1) = \\hat{x}(k) - \\alpha (U^T L U) \\hat{x}(k-1) = \\hat{x}(k) - \\alpha \\Lambda \\hat{x}(k-1)\n$$\n该方程解耦为$n$个独立的标量二阶差分方程，每个方程对应于$\\hat{x}(k)$的一个分量$\\hat{x}_i(k)$：\n$$\n\\hat{x}_i(k+1) = \\hat{x}_i(k) - \\alpha \\lambda_i \\hat{x}_i(k-1), \\quad \\text{for } i \\in \\{1, \\dots, n\\}\n$$\n对于每个模式$i$，我们可以写出一个$2 \\times 2$的状态空间模型：\n$$\n\\begin{pmatrix} \\hat{x}_i(k+1) \\\\ \\hat{x}_i(k) \\end{pmatrix} = \\begin{pmatrix} 1  -\\alpha \\lambda_i \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} \\hat{x}_i(k) \\\\ \\hat{x}_i(k-1) \\end{pmatrix}\n$$\n每个模式的稳定性和收敛性由相应的$2 \\times 2$模态矩阵$M_i = \\begin{pmatrix} 1  -\\alpha \\lambda_i \\\\ 1  0 \\end{pmatrix}$的特征值决定。其特征方程为$\\det(\\mu I - M_i) = 0$，即：\n$$\n\\mu(\\mu - 1) - (1)(-\\alpha \\lambda_i) = 0 \\implies \\mu^2 - \\mu + \\alpha \\lambda_i = 0\n$$\n这个二次方程的根，也就是$M_i$的特征值，由下式给出：\n$$\n\\mu = \\frac{1 \\pm \\sqrt{1 - 4 \\alpha \\lambda_i}}{2}\n$$\n对于一致性模式（$i=1$），$\\lambda_1 = 0$。特征方程变为$\\mu^2 - \\mu = 0$，解得根为$\\mu = 1$和$\\mu = 0$。特征值$\\mu=1$表示状态的平均值被保留，这是一个临界稳定模式，正如问题陈述所允许的。\n\n对于非一致性模式（$i \\ge 2$），我们有$\\lambda_i > 0$。这些模式必须是渐近Schur稳定的，这意味着谱半径$\\rho(M_i) = \\max\\{|\\mu|\\}$必须小于1。模式$i$的收敛速率由$\\rho(M_i)$决定。我们基于判别式$1 - 4 \\alpha \\lambda_i$来分析$\\rho(M_i)$。令$\\beta = \\alpha \\lambda_i$。\n\n情况1：实根。当$1 - 4\\beta \\ge 0$时发生，即$0  \\beta \\le \\frac{1}{4}$。根为$\\mu_{1,2} = \\frac{1 \\pm \\sqrt{1 - 4\\beta}}{2}$。两个根都是实数且为正。模最大的根是$\\mu_1 = \\frac{1 + \\sqrt{1 - 4\\beta}}{2}$。因此，谱半径为$\\rho(M_i) = \\frac{1 + \\sqrt{1 - 4 \\alpha \\lambda_i}}{2}$。\n\n情况2：共轭复根。当$1 - 4\\beta  0$时发生，即$\\beta > \\frac{1}{4}$。根为$\\mu_{1,2} = \\frac{1 \\pm i\\sqrt{4\\beta - 1}}{2}$。它们的模为$|\\mu| = \\sqrt{(\\frac{1}{2})^2 + (\\frac{\\sqrt{4\\beta - 1}}{2})^2} = \\sqrt{\\frac{1}{4} + \\frac{4\\beta - 1}{4}} = \\sqrt{\\beta}$。谱半径为$\\rho(M_i) = \\sqrt{\\alpha \\lambda_i}$。为了保证稳定性，我们要求$\\sqrt{\\alpha \\lambda_i}  1$，这等价于$\\alpha \\lambda_i  1$。这证实了问题陈述中给出的稳定性约束。\n\n对于给定的$\\lambda_i > 0$，其渐近收敛因子可以表示为乘积$\\beta = \\alpha \\lambda_i$的函数：\n$$\nf(\\beta) = \\begin{cases} \\frac{1 + \\sqrt{1 - 4\\beta}}{2}  \\text{if } 0  \\beta \\le \\frac{1}{4} \\\\ \\sqrt{\\beta}  \\text{if } \\frac{1}{4}  \\beta  1 \\end{cases}\n$$\n问题在于找到步长$\\alpha^{\\star}$，它能够最小化所有非一致性模式（即所有$\\lambda_i \\in [\\lambda_2, \\lambda_n]$）中最坏情况（最慢）的收敛因子。\n优化问题是：\n$$\n\\min_{\\alpha > 0} \\max_{\\lambda \\in [\\lambda_2, \\lambda_n]} f(\\alpha \\lambda)\n$$\n满足稳定性约束$\\alpha \\lambda_n  1$。\n\n让我们分析函数$f(\\beta)$。\n对于$0  \\beta \\le \\frac{1}{4}$，其导数为$f'(\\beta) = \\frac{-1}{\\sqrt{1-4\\beta}}  0$，因此$f(\\beta)$是严格递减的。\n对于$\\frac{1}{4}  \\beta  1$，其导数为$f'(\\beta) = \\frac{1}{2\\sqrt{\\beta}} > 0$，因此$f(\\beta)$是严格递增的。\n函数$f(\\beta)$在$\\beta = \\frac{1}{4}$处有全局最小值，其值为$f(\\frac{1}{4}) = \\frac{1}{2}$。\n\n对于一个固定的$\\alpha$，自变量$\\beta = \\alpha \\lambda$在区间$[\\alpha \\lambda_2, \\alpha \\lambda_n]$上变化。由于$f(\\beta)$在$\\beta = \\frac{1}{4}$之前是递减的，之后是递增的，因此$f(\\alpha \\lambda)$在区间$\\lambda \\in [\\lambda_2, \\lambda_n]$上的最大值必定在两个端点之一处取得。也就是说：\n$$\n\\max_{\\lambda \\in [\\lambda_2, \\lambda_n]} f(\\alpha \\lambda) = \\max\\{ f(\\alpha \\lambda_2), f(\\alpha \\lambda_n) \\}\n$$\n优化问题简化为一个极小化极大问题：\n$$\n\\min_{\\alpha > 0} \\max\\{ f(\\alpha \\lambda_2), f(\\alpha \\lambda_n) \\}\n$$\n两个函数最大值的最小值在两个函数值相等时取得。因此，最优的$\\alpha^{\\star}$必须满足$f(\\alpha^{\\star} \\lambda_2) = f(\\alpha^{\\star} \\lambda_n)$。\n由于$\\lambda_2 \\le \\lambda_n$，我们有$\\alpha^{\\star}\\lambda_2 \\le \\alpha^{\\star}\\lambda_n$。要使它们的函数值相等，一个自变量必须位于$f$的递减部分，另一个必须位于递增部分。这意味着我们必须有$\\alpha^{\\star} \\lambda_2 \\le \\frac{1}{4}$且$\\alpha^{\\star} \\lambda_n \\ge \\frac{1}{4}$。\n等式条件变为：\n$$\n\\frac{1 + \\sqrt{1 - 4\\alpha^{\\star}\\lambda_2}}{2} = \\sqrt{\\alpha^{\\star}\\lambda_n}\n$$\n我们现在对该方程求解$\\alpha^{\\star}$。\n$$\n1 + \\sqrt{1 - 4\\alpha^{\\star}\\lambda_2} = 2\\sqrt{\\alpha^{\\star}\\lambda_n}\n$$\n$$\n\\sqrt{1 - 4\\alpha^{\\star}\\lambda_2} = 2\\sqrt{\\alpha^{\\star}\\lambda_n} - 1\n$$\n为使该方程有效，右侧必须为非负，即$2\\sqrt{\\alpha^{\\star}\\lambda_n} - 1 \\ge 0$，这意味着$\\alpha^{\\star}\\lambda_n \\ge \\frac{1}{4}$。这与我们的推理一致。将两边平方得到：\n$$\n1 - 4\\alpha^{\\star}\\lambda_2 = (2\\sqrt{\\alpha^{\\star}\\lambda_n} - 1)^2 = 4\\alpha^{\\star}\\lambda_n - 4\\sqrt{\\alpha^{\\star}\\lambda_n} + 1\n$$\n$$\n-4\\alpha^{\\star}\\lambda_2 = 4\\alpha^{\\star}\\lambda_n - 4\\sqrt{\\alpha^{\\star}\\lambda_n}\n$$\n由于$\\alpha^{\\star} > 0$，我们可以除以$4\\sqrt{\\alpha^{\\star}}$：\n$$\n-\\sqrt{\\alpha^{\\star}}\\lambda_2 = \\sqrt{\\alpha^{\\star}}\\lambda_n - \\sqrt{\\lambda_n}\n$$\n$$\n\\sqrt{\\lambda_n} = \\sqrt{\\alpha^{\\star}}\\lambda_n + \\sqrt{\\alpha^{\\star}}\\lambda_2 = \\sqrt{\\alpha^{\\star}}(\\lambda_n + \\lambda_2)\n$$\n$$\n\\sqrt{\\alpha^{\\star}} = \\frac{\\sqrt{\\lambda_n}}{\\lambda_2 + \\lambda_n}\n$$\n将两边平方，得到唯一的最佳步长$\\alpha^{\\star}$：\n$$\n\\alpha^{\\star} = \\left( \\frac{\\sqrt{\\lambda_n}}{\\lambda_2 + \\lambda_n} \\right)^2 = \\frac{\\lambda_n}{(\\lambda_2 + \\lambda_n)^2}\n$$\n该表达式仅取决于$\\lambda_2$和$\\lambda_n$，符合要求。推导完成。", "answer": "$$\\boxed{\\frac{\\lambda_{n}}{(\\lambda_{2} + \\lambda_{n})^{2}}}$$", "id": "2702001"}, {"introduction": "由于巨大的通信和计算需求，集中式最优控制对于大规模网络通常是不切实际的。本练习深入探讨了一种*局部化*控制器 (localized controller) 的实用设计，其中每个智能体的控制动作仅基于其直接邻居的信息。你将合成一个集中式LQR控制器和一个结构化的局部控制器，然后定量比较它们的性能，以理解最优性与去中心化之间的根本权衡。[@problem_id:2702021]", "problem": "考虑一个由 $n$ 个节点组成的一维链构成的离散时间线性时不变网络化系统，节点之间存在最近邻耦合。状态向量为 $x_{t} \\in \\mathbb{R}^{n}$，控制输入为 $u_{t} \\in \\mathbb{R}^{n}$，动力学由 $x_{t+1} = A x_{t} + B u_{t}$ 给出，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，主对角线元素为 $a$，第一亚对角线和第一超对角线元素为 $c$，且 $B = I_{n}$。性能由无穷时域二次型代价 $J = \\sum_{t=0}^{\\infty} \\left( x_{t}^{\\top} Q x_{t} + u_{t}^{\\top} R u_{t} \\right)$ 衡量，其中 $Q = q I_{n}$ 和 $R = r I_{n}$，$q > 0$ 且 $r > 0$。\n\n将集中式线性二次调节器 (LQR) 定义为最优静态状态反馈 $u_{t} = -K_{\\mathrm{cen}} x_{t}$，它在所有静态增益中使 $J$ 最小化。将局部半径为 $1$ 的局部化线性二次调节器 (LLQR) 定义为任意静态反馈 $u_{t} = -K_{\\mathrm{loc}} x_{t}$，其中增益矩阵 $K_{\\mathrm{loc}} \\in \\mathbb{R}^{n \\times n}$ 是半带宽为 $1$ 的带状矩阵，即当 $\\lvert i - j \\rvert > 1$ 时，$\\left(K_{\\mathrm{loc}}\\right)_{ij} = 0$。\n\n你必须使用以下保持局部性的合成规则来计算 $K_{\\mathrm{cen}}$ 和构造 $K_{\\mathrm{loc}}$：\n- 对于每个节点索引 $i \\in \\{1,2,\\dots,n\\}$，构建局部索引集 $S_{i} = \\{j \\in \\{1,2,\\dots,n\\} : \\lvert j - i \\rvert \\le 1\\}$。\n- 通过将 $A$ 和 $B$ 限制到由 $S_{i}$ 索引的行和列，提取局部子系统矩阵 $A_{S_{i}} \\in \\mathbb{R}^{\\lvert S_{i} \\rvert \\times \\lvert S_{i} \\rvert}$ 和 $B_{S_{i}} = I_{\\lvert S_{i} \\rvert}$。\n- 在此局部子系统上，针对局部代价 $Q_{S_{i}} = q I_{\\lvert S_{i} \\rvert}$ 和 $R_{S_{i}} = r I_{\\lvert S_{i} \\rvert}$ 合成集中式 LQR 增益，从而获得一个局部增益矩阵 $K_{S_{i}} \\in \\mathbb{R}^{\\lvert S_{i} \\rvert \\times \\lvert S_{i} \\rvert}$。\n- 令 $p$ 为索引 $i$ 在有序集 $S_{i}$ 中的位置，通过将 $K_{S_{i}}$ 的第 $p$ 行置于由 $S_{i}$ 索引的列中来设置 $K_{\\mathrm{loc}}$ 的第 $i$ 行，该行所有其他项均为 $0$。\n\n为了定量比较这两个控制器，请使用标准的无穷时域代价矩阵。对于集中式 LQR，令 $P_{\\mathrm{cen}} \\in \\mathbb{R}^{n \\times n}$ 表示与初始状态 $x_{0}$ 的最小代价 $J = x_{0}^{\\top} P_{\\mathrm{cen}} x_{0}$ 相关联的最优代价矩阵。对于局部化控制器 $K_{\\mathrm{loc}}$，定义闭环矩阵 $A_{\\mathrm{cl,loc}} = A - B K_{\\mathrm{loc}}$ 以及相应的代价矩阵 $P_{\\mathrm{loc}}$，该矩阵是离散时间李雅普诺夫方程 $P_{\\mathrm{loc}} = A_{\\mathrm{cl,loc}}^{\\top} P_{\\mathrm{loc}} A_{\\mathrm{cl,loc}} + \\left(Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}\\right)$ 的唯一解，前提是 $A_{\\mathrm{cl,loc}}$ 是舒尔稳定的（所有特征值都严格位于单位圆内）。如果 $A_{\\mathrm{cl,loc}}$ 不是舒尔稳定的，则将代价视为无界的。\n\n你的程序必须为每个测试用例计算标量比 $\\rho = \\operatorname{trace}\\left(P_{\\mathrm{loc}}\\right) \\big/ \\operatorname{trace}\\left(P_{\\mathrm{cen}}\\right)$，该比值等于当初始状态 $x_{0}$ 服从零均值和单位协方差分布时，期望无穷时域代价之比。如果 $A_{\\mathrm{cl,loc}}$ 不是舒尔稳定的，则该测试用例输出 $+\\infty$。\n\n使用以下参数集测试套件，其中每个用例指定 $(n, a, c, q, r)$：\n- 用例 1：$n = 5$，$a = 0.6$，$c = 0.15$，$q = 1.0$，$r = 0.1$。\n- 用例 2：$n = 8$，$a = 0.7$，$c = 0.10$，$q = 1.0$，$r = 0.5$。\n- 用例 3：$n = 3$，$a = 0.95$，$c = 0.02$，$q = 1.0$，$r = 0.01$。\n\n实现要求：\n- 将 $A$ 构造为三对角矩阵，其元素为：对于所有 $i$，$A_{ii} = a$；对于所有 $i \\in \\{1,2,\\dots,n-1\\}$，$A_{i,i+1} = c$；对于所有 $i \\in \\{1,2,\\dots,n-1\\}$，$A_{i+1,i} = c$。并设置 $B = I_{n}$。\n- 使用针对离散时间系统的标准集中式 LQR 方法计算 $K_{\\mathrm{cen}}$，并从同一解中一致地获得 $P_{\\mathrm{cen}}$。\n- 使用上面给出的保持局部性的合成规则构建 $K_{\\mathrm{loc}}$，然后在 $A_{\\mathrm{cl,loc}}$ 是舒尔稳定的情况下，通过离散时间李雅普诺夫方程评估 $P_{\\mathrm{loc}}$。\n- 对于每个用例，将比率 $\\rho$ 作为浮点数输出。\n\n最终输出规范：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试用例顺序排列的结果。例如，输出应类似于 $[\\rho_{1},\\rho_{2},\\rho_{3}]$。\n- 不涉及物理单位。\n- 不会出现角度。\n- 将每个 $\\rho$ 表示为浮点小数。", "solution": "所提出的问题是现代控制理论中一个适定的标准练习，具体涉及网络化系统控制器设计中最优性与去中心化之间的权衡。我们将进行严谨的分析。目标是计算性能比 $\\rho$，该比率量化了结构化的局部控制器相对于全局最优的集中式控制器的次优性。\n\n系统动力学由以下离散时间线性时不变方程给出：\n$$x_{t+1} = A x_{t} + B u_{t}$$\n其中 $x_{t} \\in \\mathbb{R}^{n}$ 是状态，$u_{t} \\in \\mathbb{R}^{n}$ 是控制输入。系统矩阵为 $A \\in \\mathbb{R}^{n \\times n}$，一个主对角线元素为 $a$、第一副对角线元素为 $c$ 的三对角矩阵，以及 $B = I_{n}$，$n \\times n$ 的单位矩阵。性能目标是最小化无穷时域二次型代价：\n$$J = \\sum_{t=0}^{\\infty} \\left( x_{t}^{\\top} Q x_{t} + u_{t}^{\\top} R u_{t} \\right)$$\n其中权重矩阵为 $Q = q I_{n}$（$q > 0$）和 $R = r I_{n}$（$r > 0$）。\n\n首先，我们分析集中式线性二次调节器 (LQR)。最优控制律是静态状态反馈 $u_{t} = -K_{\\mathrm{cen}} x_{t}$。最优增益 $K_{\\mathrm{cen}}$ 和相关的待去代价矩阵 $P_{\\mathrm{cen}}$ 通过求解离散代数黎卡提方程 (DARE) 找到。对于一个通用系统 $(A, B)$ 和代价 $(Q, R)$，DARE 为：\n$$P = A^{\\top} P A - (A^{\\top} P B)(R + B^{\\top} P B)^{-1}(B^{\\top} P A) + Q$$\n此方程的解 $P$ 是最优代价矩阵，因此 $P_{\\mathrm{cen}} = P$。这意味着从初始状态 $x_{0}$ 开始的最小代价为 $J^{*} = x_{0}^{\\top} P_{\\mathrm{cen}} x_{0}$。由于 $B=I_{n}$，系统对 $(A, B)$ 是可控的；由于 $Q=qI_{n}$ 且 $q>0$，系统对 $(A, Q^{1/2})$ 是可观的。这些条件保证了存在一个唯一的正定解 $P_{\\mathrm{cen}}$，该解能产生一个镇定反馈增益。\n\n最优集中式反馈增益由下式给出：\n$$K_{\\mathrm{cen}} = (R + B^{\\top} P_{\\mathrm{cen}} B)^{-1}(B^{\\top} P_{\\mathrm{cen}} A)$$\n代入 $B = I_{n}$ 和 $R = r I_{n}$，上式简化为：\n$$K_{\\mathrm{cen}} = (r I_{n} + P_{\\mathrm{cen}})^{-1}(P_{\\mathrm{cen}} A)$$\n我们将数值求解 DARE 以找到 $P_{\\mathrm{cen}}$，然后计算 $K_{\\mathrm{cen}}$。\n\n接下来，我们遵循预定的合成规则构造局部化控制器 $K_{\\mathrm{loc}}$。这是一个自下而上的设计过程，它从局部最优解构建全局控制器。对于每个节点 $i \\in \\{1, 2, \\dots, n\\}$，我们定义一个局部邻域 $S_{i} = \\{j \\in \\{1, \\dots, n\\} : |j - i| \\le 1\\}$。该集合的大小 $|S_{i}|$ 对于边界节点（$i=1$ 和 $i=n$）为 $2$，对于内部节点（$1  i  n$，假设 $n > 2$）为 $3$。\n\n对于每个 $i$，我们提取局部子系统矩阵。$A_{S_{i}}$ 是通过选择索引在 $S_{i}$ 中的行和列而从 $A$ 中形成的子矩阵。局部输入和代价矩阵为 $B_{S_{i}} = I_{|S_{i}|}$、$Q_{S_{i}} = q I_{|S_{i}|}$ 和 $R_{S_{i}} = r I_{|S_{i}|}$。然后我们为这个更小的局部 LQR 问题求解 DARE：\n$$P_{S_{i}} = A_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}} - (A_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})(R_{S_{i}} + B_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})^{-1}(B_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}}) + Q_{S_{i}}$$\n相应的局部最优增益为 $K_{S_{i}} = (R_{S_{i}} + B_{S_{i}}^{\\top} P_{S_{i}} B_{S_{i}})^{-1}(B_{S_{i}}^{\\top} P_{S_{i}} A_{S_{i}})$。\n\n全局局部化增益矩阵 $K_{\\mathrm{loc}}$ 是逐行组装的。对于每个节点 $i$，令 $p$ 为索引 $i$ 在有序集 $S_{i}$ 中的位置。$K_{\\mathrm{loc}}$ 的第 $i$ 行是通过取局部增益矩阵 $K_{S_{i}}$ 的第 $p$ 行，并将其元素放置到 $K_{\\mathrm{loc}}$ 第 $i$ 行中与 $S_{i}$ 中索引相对应的列中来构造的。$K_{\\mathrm{loc}}$ 第 $i$ 行中的所有其他项均为零。这种构造确保了如果 $|i-j| > 1$，则 $(K_{\\mathrm{loc}})_{ij} = 0$，从而强制执行了所需的局部性结构。\n\n对于局部化控制器 $u_{t} = -K_{\\mathrm{loc}} x_{t}$，闭环系统动力学变为：\n$$x_{t+1} = (A - B K_{\\mathrm{loc}}) x_{t} = (A - K_{\\mathrm{loc}}) x_{t}$$\n令 $A_{\\mathrm{cl,loc}} = A - K_{\\mathrm{loc}}$。此控制器的性能由代价矩阵 $P_{\\mathrm{loc}}$ 决定，该矩阵是离散时间李雅普诺夫方程的解，前提是 $A_{\\mathrm{cl,loc}}$ 是舒尔稳定的（其所有特征值都严格位于复平面的单位圆盘内）。该李雅普诺夫方程为：\n$$P_{\\mathrm{loc}} = A_{\\mathrm{cl,loc}}^{\\top} P_{\\mathrm{loc}} A_{\\mathrm{cl,loc}} + Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}$$\n如果 $A_{\\mathrm{cl,loc}}$ 不是舒尔稳定的，则定义代价 $J$ 的求和会发散，代价被认为是无穷大。如果它是稳定的，则存在一个唯一的正定解 $P_{\\mathrm{loc}}$。我们将数值求解这个线性矩阵方程。一种标准方法是对该方程进行向量化：令 $p_{\\mathrm{loc}} = \\operatorname{vec}(P_{\\mathrm{loc}})$ 和 $M = Q + K_{\\mathrm{loc}}^{\\top} R K_{\\mathrm{loc}}$。方程变为 $(I_{n^2} - A_{\\mathrm{cl,loc}}^{\\top} \\otimes A_{\\mathrm{cl,loc}}^{\\top}) p_{\\mathrm{loc}} = \\operatorname{vec}(M)$，这是一个标准的线性系统。\n\n最后，我们计算所需的比率 $\\rho$。该比率比较了两种控制方案下的期望代价，其中期望是针对从零均值和单位协方差分布（$\\mathbb{E}[x_{0}x_{0}^{\\top}] = I_{n}$）中抽取的初始状态 $x_{0}$ 计算的。期望代价为 $\\mathbb{E}[x_{0}^{\\top} P x_{0}] = \\operatorname{trace}(P \\mathbb{E}[x_{0}x_{0}^{\\top}]) = \\operatorname{trace}(P)$。因此，性能比为：\n$$\\rho = \\frac{\\operatorname{trace}(P_{\\mathrm{loc}})}{\\operatorname{trace}(P_{\\mathrm{cen}})}$$\n如果 $P_{\\mathrm{loc}}$ 是无界的，我们设 $\\rho = +\\infty$。现在我们将对每个指定的测试用例进行计算。\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_discrete_are, solve_discrete_lyapunov, LinAlgError\n\ndef solve_for_problem3():\n    \"\"\"\n    Solves the control theory problem for centralized and localized LQR controllers.\n    \"\"\"\n    test_cases = [\n        # (n, a, c, q, r)\n        (5, 0.6, 0.15, 1.0, 0.1),\n        (8, 0.7, 0.10, 1.0, 0.5),\n        (3, 0.95, 0.02, 1.0, 0.01),\n    ]\n\n    results = []\n    for n, a, c, q, r in test_cases:\n        # Construct system matrices A, B, Q, R\n        A = np.diag(np.full(n, a)) + np.diag(np.full(n - 1, c), k=1) + np.diag(np.full(n - 1, c), k=-1)\n        B = np.eye(n)\n        Q = q * np.eye(n)\n        R = r * np.eye(n)\n\n        # 1. Centralized LQR\n        try:\n            P_cen = solve_discrete_are(A, B, Q, R)\n        except LinAlgError:\n            results.append(np.inf)\n            continue\n        \n        # 2. Localized LQR (LLQR) Synthesis\n        K_loc = np.zeros((n, n))\n        for i in range(n):\n            # Define local index set Si (using 0-based indexing)\n            s_i_indices = []\n            if i > 0:\n                s_i_indices.append(i - 1)\n            s_i_indices.append(i)\n            if i  n - 1:\n                s_i_indices.append(i + 1)\n            \n            s_i_size = len(s_i_indices)\n            \n            # Extract local subsystem matrices\n            A_si = A[np.ix_(s_i_indices, s_i_indices)]\n            B_si = np.eye(s_i_size)\n            Q_si = q * np.eye(s_i_size)\n            R_si = r * np.eye(s_i_size)\n            \n            P_si = solve_discrete_are(A_si, B_si, Q_si, R_si)\n\n            # Compute local gain K_si\n            K_si = np.linalg.inv(R_si + B_si.T @ P_si @ B_si) @ (B_si.T @ P_si @ A_si)\n            \n            p = s_i_indices.index(i)\n            K_loc[i, s_i_indices] = K_si[p, :]\n\n        # 3. Evaluate LLQR performance\n        A_cl_loc = A - B @ K_loc\n        \n        eigvals = np.linalg.eigvals(A_cl_loc)\n        if np.any(np.abs(eigvals) >= 1.0):\n            results.append(np.inf)\n            continue\n\n        M = Q + K_loc.T @ R @ K_loc\n        \n        try:\n            # Solve discrete-time Lyapunov equation A.T X A - X = -Q\n            P_loc = solve_discrete_lyapunov(A_cl_loc.T, M)\n        except LinAlgError:\n            results.append(np.inf)\n            continue\n            \n        # 4. Compute the ratio rho\n        trace_P_cen = np.trace(P_cen)\n        trace_P_loc = np.trace(P_loc)\n        \n        if trace_P_cen == 0:\n            rho = np.inf if trace_P_loc > 0 else 1.0\n        else:\n            rho = trace_P_loc / trace_P_cen\n        \n        results.append(rho)\n\n    # Format output as requested\n    formatted_results = [f\"{r:.7f}\" for r in results]\n    return f\"[{','.join(formatted_results)}]\"\n\n# The following call is for generating the answer string.\n# print(solve_for_problem3())\n```", "answer": "[1.0264024,1.0028248,1.0000000]", "id": "2702021"}]}