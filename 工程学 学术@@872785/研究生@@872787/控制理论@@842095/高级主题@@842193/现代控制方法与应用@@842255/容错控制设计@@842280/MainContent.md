## 引言
在航空航天、自动驾驶、工业过程等安全关键系统中，组件故障并非罕见事件，而是必须预见并加以处理的现实。设计能够在发生故障时依然保持稳定运行并完[成核](@entry_id:140577)心任务的控制系统，是现代[控制工程](@entry_id:149859)面临的一项核心挑战。[容错控制](@entry_id:173831)（Fault-Tolerant Control, FTC）正是为应对这一挑战而生的一套理论与技术体系，其重要性不言而喻。传统的控制设计往往假设系统组件完美工作，然而这种理想化的假设在现实中不堪一击。本文旨在系统性地填补这一空白，为读者提供一套从理论到实践的完整[容错控制](@entry_id:173831)设计知识框架。

为了实现这一目标，本文将引导您逐步深入[容错控制](@entry_id:173831)的世界。在**“原理与机制”**一章中，我们将奠定理论基础，深入探讨故障建模、诊断的基本性质以及被动与主动[容错](@entry_id:142190)策略的内在权衡。接着，在**“应用与跨学科联系”**一章，我们将拓宽视野，探索FTC如何在先进控制策略中得到深化，并观察其核心思想如何在计算机科学乃至系统生物学等不同领域中得到体现。最后，**“动手实践”**部分将通过一系列精选问题，将理论知识转化为可操作的分析与设计技能。通过这一结构化的学习路径，您将全面掌握[容错控制](@entry_id:173831)的核心思想与设计方法。现在，让我们从构建这一切的基石——[容错控制](@entry_id:173831)的核心原理与机制——开始我们的探索之旅。

## 原理与机制

在“引言”章节对[容错控制](@entry_id:173831)的基本概念和重要性进行概述之后，本章将深入探讨其核心技术原理与关键机制。我们将系统性地研究如何对故障进行[数学建模](@entry_id:262517)，分析系统固有的故障[可检测性](@entry_id:265305)与可隔离性，阐述用于故障诊断的[残差生成](@entry_id:162977)与评估方法，并最终对比分析两种主要的[容错控制](@entry_id:173831)设计哲学——被动[容错控制](@entry_id:173831)与主动[容错控制](@entry_id:173831)——及其内在的性能权衡。

### 故障建模与系统表示

在设计能够响应并适应故障的控制系统之前，我们必须首先建立故障的数学描述。精确的[故障模型](@entry_id:172256)是后续所有分析与设计的基础。

#### 故障类型与标准表示

故障可以多种形式影响系统，但大体上可以归为两类：**加性故障**和**乘性故障**。加性故障表现为向系统中注入了非预期的信号，例如执行器卡死在某个非零位置或传感器出现恒定偏差。[乘性](@entry_id:187940)故障则改变了系统已有信号的传递效能，例如执行器部分失效导致其输出扭矩只有指令值的80%，或者[传感器灵敏度](@entry_id:275091)下降。

尽管故障类型多样，但为了发展系统性的设计方法，将它们统一到一种[标准形式](@entry_id:153058)下至关重要。一个广泛采用的标准形式是加性[故障模型](@entry_id:172256)。考虑一个[线性时不变](@entry_id:276287)（LTI）系统：
$$
\dot{x}(t) = Ax(t) + Bu(t)
$$
一个通过特定通道 $E$ 注入的加性故障 $w(t)$ 会将系统动态改变为：
$$
\dot{x}(t) = Ax(t) + Bu(t) + Ew(t)
$$
这个模型的强大之处在于，许多其他类型的故障也可以通过数学变换等效为此形式。例如，考虑一个常见的执行器乘性[故障模型](@entry_id:172256)，其中第 $i$ 个执行器的实际输出 $u_{f,i}(t)$ 是指令输入 $u_i(t)$ 的一个[折扣](@entry_id:139170)版本：$u_{f,i}(t) = (1-\delta_i(t))u_i(t)$。其中 $\delta_i(t)$ 代表未知的失效因子（$\delta_i=0$ 表示无故障，$\delta_i=1$ 表示完全失效）。对于一个多输入系统，这可以写成矩阵形式 $u_f(t) = (I - \Delta(t))u(t)$，其中 $\Delta(t) = \mathrm{diag}(\delta_1(t), \dots, \delta_m(t))$。

将此[故障模型](@entry_id:172256)代入状态方程，我们得到：
$$
\dot{x}(t) = Ax(t) + B(I - \Delta(t))u(t) = Ax(t) + Bu(t) - B\Delta(t)u(t)
$$
这里的故障项 $-B\Delta(t)u(t)$ 形式复杂，因为它同时与未知的故障 $\Delta(t)$ 和已知的控制输入 $u(t)$ 相乘。然而，我们可以通过一个简单的代数技巧将其重构为标准的加性故障形式 [@problem_id:2707726]。注意到 $\Delta(t)u(t)$ 是一个向量，其第 $i$ 个元素为 $\delta_i(t)u_i(t)$。这个向量可以等效地写成一个[对角矩阵](@entry_id:637782) $\mathrm{diag}(u_1(t), \dots, u_m(t))$ 与故障向量 $w(t) = [\delta_1(t), \dots, \delta_m(t)]^T$ 的乘积。因此，[状态方程](@entry_id:274378)可以重写为：
$$
\dot{x}(t) = Ax(t) + Bu(t) + E(t)w(t)
$$
其中，新的**故障[分布](@entry_id:182848)矩阵** $E(t) = -B \cdot \mathrm{diag}(u_1(t), \dots, u_m(t))$ 是已知的（因为它只依赖于已知的 $B$ 矩阵和控制信号 $u(t)$），而未知的部分则被完全归入新的**等效故障向量** $w(t)$。通过这种方式，乘性故障被转化为了一个具有时变[分布](@entry_id:182848)矩阵的加性故障，使得为加性故障设计的诸多分析工具和诊断算法得以应用。

#### [状态增广](@entry_id:140869)与故障估计

另一种强大的建模思路是将故障本身视为系统状态的一部分。如果我们能够为故障的动态行为建立一个模型，就可以将这个模型与原系统模型结合，构成一个**增广状态模型**（augmented state model）。然后，就可以利用[状态估计](@entry_id:169668)（观测器）技术来同时估计原始系统[状态和](@entry_id:193625)故障状态。

考虑一个简单的例子：一个传感器受到线性漂移故障 $g(t)$ 的影响，其测量输出为 $y(t) = x(t) + g(t)$。该漂移以一个未知的恒定速率 $\alpha$ 累积，即 $\dot{g}(t) = \alpha$。由于 $\alpha$ 是常数，其动态可以描述为 $\dot{\alpha}(t) = 0$ [@problem_id:2707678]。

为了能够估计出漂移 $g(t)$ 和漂移率 $\alpha$，我们可以定义一个增广状态向量 $z = [x, g, \alpha]^T$。结合原始系统动态 $\dot{x} = ax$，我们可以构建如下的增广[LTI系统](@entry_id:271946)：
$$
\dot{z}(t) = \begin{pmatrix} \dot{x} \\ \dot{g} \\ \dot{\alpha} \end{pmatrix} = \begin{pmatrix} a  0  0 \\ 0  0  1 \\ 0  0  0 \end{pmatrix} \begin{pmatrix} x \\ g \\ \alpha \end{pmatrix} = A_{\mathrm{aug}} z(t)
$$
相应的输出方程为：
$$
y(t) = \begin{pmatrix} 1  1  0 \end{pmatrix} z(t) = C_{\mathrm{aug}} z(t)
$$
通过这种方式，故障估计问题被转化为了一个对增广系统 $(A_{\mathrm{aug}}, C_{\mathrm{aug}})$ 的[标准状态](@entry_id:145000)观测问题。这种方法的前提是增广系统必须是**可观测的**，我们将在下一节深入探讨这个概念。

### 基本性质：[可检测性](@entry_id:265305)与可隔离性

在尝试设计故障诊断系统之前，我们必须回答两个根本性问题：(1) 在给定传感器的条件下，一个特定的故障是否可能被检测到？(2) 当多个故障可能发生时，我们能否区分它们？这两个问题分别对应于**故障[可检测性](@entry_id:265305)**（fault detectability）和**故障可隔离性**（fault isolability）的概念。它们是系统的内在属性，由系统动态、[故障注入](@entry_id:176348)方式和测量方式共同决定。

#### 故障[可检测性](@entry_id:265305)

一个故障是**可检测的**，如果任何非零的、有界的故障信号必然会在系统输出端产生非零的响应。换言之，故障不能“隐藏”在系统中而不被传感器察觉。

令人惊讶的是，这个看似简单的性质与系统理论中一个深刻的概念——**不变零点**（invariant zeros）——紧密相连 [@problem_id:2707659]。考虑一个由故障驱动的系统 $\dot{x} = Ax + Ef, y = Cx$。如果存在一个复数 $s_0$ 以及非零向量 $x_0, f_0$，使得如下方程成立：
$$
\begin{pmatrix} A - s_0 I  E \\ C  0 \end{pmatrix} \begin{pmatrix} x_0 \\ f_0 \end{pmatrix} = \begin{pmatrix} 0 \\ 0 \end{pmatrix}
$$
那么 $s_0$ 就被称为系统三元组 $(A, E, C)$ 的一个不变零点。这个代数条件背后有着深刻的物理意义。它表明，存在一个指数形式的故障输入 $f(t) = f_0 e^{s_0 t}$，它能驱动系统产生一个内部状态响应 $x(t) = x_0 e^{s_0 t}$，但这个响应在输出端却恰好为零 ($Cx_0 = 0$)。这种状态响应被称为“零输出状态方向”。

如果一个不变零点 $s_0$ 位于闭合左半复平面（即 $\mathrm{Re}(s_0) \le 0$），那么对应的故障信号 $f(t) = f_0 e^{s_0 t}$ 将是一个有界信号。这意味着，存在一个有界的、非零的故障输入，它所产生的输出恒等于零。根据定义，这样的故障是不可检测的。

因此，故障[可检测性](@entry_id:265305)的**充分必要条件**是：系统三元组 $(A, E, C)$ 的所有不变零点都必须位于开放右半复平面（$\mathrm{Re}(s) > 0$）。对于输出数量等于故障输入数量的“方系统”，不变零点恰好是如下系统[矩阵[行列](@entry_id:194066)式](@entry_id:142978)[多项式的根](@entry_id:154615)：
$$
\det\begin{pmatrix} A-sI  E \\ C  0 \end{pmatrix} = 0
$$
检查这些根的位置，就能从根本上判断一个故障是否可能被检测到。

回到前述的[状态增广](@entry_id:140869)模型 [@problem_id:2707678]，通过计算其[可观测性矩阵](@entry_id:165052)的[行列式](@entry_id:142978)，我们发现其值为 $a^2$。可观测性等价于该[行列式](@entry_id:142978)非零，即 $a \neq 0$。这个结果与漂移率 $\alpha$ 无关，揭示了一个重要事实：当系统自身动态 $a=0$ 时（即 $x$ 是一个常数），我们无法从输出 $y(t) = x(0) + g(0) + \alpha t$ 中唯一地分离出初始状态 $x(0)$ 和初始漂移 $g(0)$，因为它们只以和的形式出现。这种情况下，故障状态是不可观测（不可检测）的，无论故障本身如何演化。

#### 故障可隔离性

当系统可能受到多种不同故障影响时，仅仅检测到异常的存在是不够的，我们还需要确定是哪一种故障发生了。这就是**故障可隔离性**。

我们可以用一种直观的几何方法来理解可隔离性 [@problem_id:2707711]。对于每一种故障 $f_i$（通过通道 $E_i$ 进入系统），我们可以定义一个**输出故障[子空间](@entry_id:150286)** $\mathcal{Y}_i$。这个[子空间](@entry_id:150286)是 $\mathbb{R}^p$（输出空间）的一部分，它由所有可能由故障 $f_i$ 瞬时产生的输出向量方向张成。数学上，它定义为：
$$
\mathcal{Y}_i \triangleq \mathrm{span}\{ C A^{k} E_i \,:\, k = 0,1,\dots,n-1 \}
$$
$\mathcal{Y}_i$ 刻画了故障 $f_i$ 在输出端的“足迹”或“签名”。

现在，考虑隔离故障 $f_1$ 和 $f_2$。为了将 $f_1$ 从 $f_2$ 中隔离出来，我们需要设计一个“滤波器”（即一个[残差生成](@entry_id:162977)器），它对 $f_1$ 的影响敏感，但对 $f_2$ 的影响完全不敏感（解耦）。这意味着该滤波器必须能够“无视”所有来自 $\mathcal{Y}_2$ 的输出。要同时对 $f_1$ 敏感，就要求 $f_1$ 的[影响范围](@entry_id:166501) $\mathcal{Y}_1$ 不能完全被这个滤波器“无视”。

这只有在 $\mathcal{Y}_1$ 不完全包含于 $\mathcal{Y}_2$ 的情况下才可能实现。如果 $\mathcal{Y}_1 \subseteq \mathcal{Y}_2$，那么 $f_1$ 能产生的所有输出方向 $f_2$ 都能产生。在这种情况下，$f_1$ 的任何“足迹”都可以被解释为是由 $f_2$ 造成的，因此我们无法将它们明确分开。反之，如果 $\mathcal{Y}_1 \not\subseteq \mathcal{Y}_2$，则总存在一个仅属于 $\mathcal{Y}_1$ 而不属于 $\mathcal{Y}_2$ 的方向，我们可以设计一个残差专门对这个方向敏感。

因此，故障 $f_1$ 可从 $f_2$ 隔离的**充分必要条件**是：
$$
\mathcal{Y}_1 \not\subseteq \mathcal{Y}_2
$$
同理， $f_2$ 可从 $f_1$ 隔离的条件是 $\mathcal{Y}_2 \not\subseteq \mathcal{Y}_1$。如果两个条件同时满足，则称这两个故障是**相互可隔离的**。这并不要求它们的输出[子空间](@entry_id:150286)完全不相交。它们的交集 $\mathcal{Y}_1 \cap \mathcal{Y}_2$ 代表了“模糊”的输出方向，这些方向可以由任一故障产生，但只要每个故障都拥有自己独特的、不属于交集的方向，隔离就是可能的。

### 故障诊断引擎：[残差生成](@entry_id:162977)与评估

故障诊断系统（FDI）的核心是一个诊断引擎，它通常包含两个阶段：**[残差生成](@entry_id:162977)**和**残差评估**。

#### [残差生成](@entry_id:162977)

**残差**（residual）是一个经过特殊设计的信号，在理想的无故障情况下，它应该为零（或接近于零），而在故障发生时，它应显著偏离零。最常用的[残差生成](@entry_id:162977)方法之一是基于观测器的。

一个**龙贝格观测器**（Luenberger observer）是一个系统的动态模型副本，它利用实际的测量输出来修正其内部[状态估计](@entry_id:169668) [@problem_id:2707723]。其形式如下：
$$
\dot{\hat{x}}(t) = A\hat{x}(t) + Bu(t) + L(y(t) - C\hat{x}(t))
$$
其中 $\hat{x}(t)$ 是状态估计，而 $L$ 是[观测器增益](@entry_id:267562)矩阵，需要设计以确保[估计误差](@entry_id:263890)收敛。

残差 $r(t)$ 被自然地定义为实际测量输出 $y(t)$ 与观测器预测输出 $\hat{y}(t) = C\hat{x}(t)$ 之间的差异：
$$
r(t) = y(t) - C\hat{x}(t)
$$
通过定义[状态估计](@entry_id:169668)误差 $e(t) = x(t) - \hat{x}(t)$，我们可以推导出残差的表达式。考虑存在传感器噪声 $v(t)$ 的情况，即 $y(t) = Cx(t) + v(t)$，残差方程变为：
$$
r(t) = (Cx(t) + v(t)) - C\hat{x}(t) = C(x(t) - \hat{x}(t)) + v(t) = Ce(t) + v(t)
$$
同时，估计误差的动态演化由下式决定：
$$
\dot{e}(t) = (A - LC)e(t) - Lv(t)
$$
如果选择增益 $L$ 使得矩阵 $A-LC$ 是Hurwitz的（所有[特征值](@entry_id:154894)都有负实部），那么在没有故障和噪声的情况下，[估计误差](@entry_id:263890) $e(t)$ 将[指数收敛](@entry_id:142080)到零，从而残差 $r(t)$ 也将收敛到零。当故障发生时，它会改变原始系统的动态（例如，变为 $\dot{x}=Ax+Bu+Ef$），而观测器模型仍然是无故障的。这种模型与现实之间的不匹配会驱动估计误差 $e(t)$ 和残差 $r(t)$ 偏离零，从而指示故障的发生。

这个分析也揭示了设计的核心挑战：残差不仅对故障敏感，也对噪声（如 $v(t)$）敏感。一个好的FDI设计必须在最大化对故障的敏感度的同时，最小化对噪声和不确定性的敏感度。

#### 残差评估

[残差生成](@entry_id:162977)后，我们需要一个决策逻辑来判断其非零行为是否确实由故障引起，而非仅仅是随机噪声的正常波动。这个过程被称为**残差评估**，本质上是一个统计**[假设检验](@entry_id:142556)**问题。

- **$\mathcal{H}_0$ (零假设)**: 系统无故障。残差的非零值是由噪声引起的。
- **$\mathcal{H}_1$ (备择假设)**: 系统存在故障。

最直接的方法是设定一个**阈值** $\gamma$。如果残差的某种度量超过了此阈值，就触发故障警报。然而，阈值设得太低，会导致频繁的**虚警**（false alarms），即无故障时误报故障；设得太高，则可能错过真正的故障（漏检）。

**1. [卡方检验](@entry_id:174175) (Chi-Squared Test)**

一种系统性的阈值设定方法是基于统计学原理。假设在无故障情况下，经过处理的离散时间残差向量 $r_k \in \mathbb{R}^m$ 服从零均值的多元高斯分布 $r_k \sim \mathcal{N}(0, \Sigma)$，其中 $\Sigma$ 是已知的[协方差矩阵](@entry_id:139155) [@problem_id:2707656]。我们可以构造一个二次型[检验统计量](@entry_id:167372)：
$$
J_k = r_k^T \Sigma^{-1} r_k
$$
这个统计量在几何上相当于对残差进行“白化”（通过 $\Sigma^{-1/2}$ 变换，使其协[方差](@entry_id:200758)变为单位矩阵），然后计算其欧几里得范数的平方。一个关键的统计学结论是：如果 $r_k \sim \mathcal{N}(0, \Sigma)$，那么 $J_k$ 服从自由度为 $m$ 的**[卡方分布](@entry_id:165213)**（chi-squared distribution），记为 $\chi^2_m$。

现在，我们可以精确地控制**虚警率**（False Alarm Probability, FAP），即 $\mathbb{P}(J_k > \gamma | \mathcal{H}_0) = \alpha$。为了达到指定的虚警率 $\alpha$（例如0.01），我们只需将阈值 $\gamma$ 选为 $\chi^2_m$ [分布](@entry_id:182848)的 $(1-\alpha)$ [分位数](@entry_id:178417)。这可以通过查询标准统计表或使用数值计算得到：
$$
\gamma = F_{\chi^2_m}^{-1}(1-\alpha)
$$
其中 $F_{\chi^2_m}^{-1}$ 是卡方分布[累积分布函数](@entry_id:143135)的逆函数（[分位数函数](@entry_id:271351)）。

**2. 广义[似然比检验](@entry_id:268070) (Generalized Likelihood Ratio Test)**

当[故障模型](@entry_id:172256)中包含未知参数时（例如，故障的幅度未知），一种更强大的方法是**广义[似然比](@entry_id:170863)（GLR）检验**。GLR检验比较了两种假设下观测到当前数据的“可能性”。

考虑一个简单的例子：在 $\mathcal{H}_1$ 下，残差中出现一个未知大小的恒定偏置 $b$，即在一个长度为 $L$ 的窗口内，$r_i \sim \mathcal{N}(b, \sigma^2)$ [@problem_id:2707708]。GLR检验的核心思想是，首先在 $\mathcal{H}_1$ 假设下，找到使观测数据出现概率最大的那个参数值（即参数的**最大似然估计**，MLE）。对于偏置 $b$，其MLE恰好是窗口内残差的样本均值 $\hat{b}_{ML} = \bar{r}_k = \frac{1}{L}\sum r_i$。

然后，将这个“最优”的[备择假设](@entry_id:167270)与[零假设](@entry_id:265441)进行[似然比检验](@entry_id:268070)。经过推导，最终的对数广义似然比统计量为：
$$
\ln \Lambda_k = \frac{L \bar{r}_k^2}{2\sigma^2}
$$
这个结果非常直观：[检验统计量](@entry_id:167372)与样本均值的平方成正比。样本均值越大，我们就越有理由相信存在一个非零的偏置，从而拒绝零假设。GLR检验为针对特定故障模式设计最优检测器提供了理论框架。

### FTC设计哲学与权衡

有了故障诊断的能力，我们就可以设计能够容忍故障的控制系统。主要有两种设计哲学：被动[容错控制](@entry_id:173831)（PFTC）和主动[容错控制](@entry_id:173831)（AFTC）。

#### 被动[容错控制](@entry_id:173831) (PFTC)

**被动[容错控制](@entry_id:173831)**采用一种“一劳永逸”的策略。它设计一个单一的、固定的**鲁棒控制器**，该控制器从一开始就被设计为对一组预定义的故障不敏感。系统结构在故障发生后不会改变 [@problem_id:2707692]。

其核心机制是通过[控制器设计](@entry_id:274982)来塑造[闭环系统](@entry_id:270770)的**[灵敏度函数](@entry_id:271212)** $S(s) = (1+P(s)K(s))^{-1}$，其中 $P(s)$ 是被控对象， $K(s)$ 是控制器。对于一个通过通道 $P_f(s)$ 注入的加性故障 $f(s)$，它对输出 $y(s)$ 的影响由下式给出：
$$
Y(s) = S(s) P_f(s) F(s)
$$
为了抑制故障影响，需要在故障能量集中的频段使 $|S(j\omega)|$ 尽可能小。通常，这意味着需要一个高增益的控制器。然而，高增益控制器虽然能很好地抑制扰动和故障，但往往对[模型不确定性](@entry_id:265539)（尤其是高频[未建模动态](@entry_id:264781)）非常敏感，容易导致系统不稳定。为了保证系统在面对各种不确定性和故障时的稳定性，鲁棒[控制器设计](@entry_id:274982)通常必须采取保守策略，例如限制闭[环带](@entry_id:163678)宽。

这就导致了PFTC的**内在权衡**：为了获得对故障的鲁棒性，通常需要牺牲系统的标称性能（即无故障时的性能）。一个被动[容错控制](@entry_id:173831)器可能比一个为标-称[性能优化](@entry_id:753341)的控制器响应更慢、精度更低，即使在没有故障发生时也是如此。

#### 主动[容错控制](@entry_id:173831) (AFTC)

**主动[容错控制](@entry_id:173831)**则采取一种“智能”的、自适应的策略。它包含一个在线的FDI模块，该模块持续监控系统，并在检测和识别出特定故障后，主动地**重新配置**（reconfigure）或调整控制器，以补偿故障的影响 [@problem_id:2707692]。

AFTC的主要优势在于它避免了PFTC的性能折衷。在无故障时，系统可以运行一个为最优性能设计的高性能控制器。只有当故障被确认发生后，控制律才被切换到一个专门为应对该故障而设计的新控制器。原则上，这使得系统在绝大多数时间（无故障时）都能保持最佳性能。

#### 更深层次的比较：稳定性、瞬态与性能

AFTC的优势并非没有代价。其实现过程中的两个关键挑战是**检测延迟**和**切换瞬态**，这使得PFTC和AFTC之间的选择成为一个复杂的权衡问题。

**1. 检测延迟的风险**

从故障发生到被FDI模块成功检测和隔离，总会存在一个时间延迟 $\tau_d$。在此期间，系统在故障状态下运行，但控制器尚未被重新配置。这段时间的系统稳定性至关重要，尤其是对于那些随时间恶化的**渐发故障**（incipient faults） [@problem_id:2707721]。

考虑一个执行器效能随时间[线性衰减](@entry_id:198935)的例子，$\delta(t) = \delta_0 + \rho t$。这使得[闭环系统](@entry_id:270770)变为[时变系统](@entry_id:175653) $\dot{x}(t) = A_{cl}(t)x(t)$。如果 $A_{cl}(t)$ 随着时间增长从负值变为正值，系统将从稳定变为不稳定。系统保持稳定的最长时间，即**最大允许检测延迟** $\tau_{d,\max}$，可以通过求解 $A_{cl}(\tau_d) = 0$ 来确定。如果实际的检测延迟超过了这个极限，系统将在控制器切换之前就已发散。

**2. 切换瞬态的影响**

控制器切换本身也并非一个平滑的过程。它可能会引入**切换瞬态**，例如由于新旧控制器状态不匹配导致的控制信号突变，这可能激发系统未建模的动态，甚至导致短暂的性能恶化或不稳定。

我们可以用李雅普诺夫函数来量化这种影响 [@problem_id:2707669]。假设在切换时刻 $\tau_d$，系统的[李雅普诺夫函数](@entry_id:273986)值发生了一次“跳变”，其[上界](@entry_id:274738)为 $V_a(\tau_d^+) \le \rho V_p(\tau_d^-)$，其中 $\rho \ge 1$ 是一个量化切换瞬态严重程度的因子。

**3. 定量权衡分析**

那么，在什么情况下，AFTC的复杂性是值得的？我们可以通过比较两种策略下的某个性能指标来回答这个问题。例如，考虑一个衡量系统状态偏离原点总量的积分[代价函数](@entry_id:138681) $J = \int_0^\infty V(t) dt$。

- 对于PFTC，系统在故障后以一个较慢的衰减率 $\alpha_p$ 收敛，其总代价为 $J_{PFTC} \approx \frac{V_p(0)}{2\alpha_p}$。
- 对于AFTC，系统先以衰减率 $\alpha_p$ 运行 $\tau_d$ 时间，然后在切换瞬态（代价放大 $\rho$ 倍）后，以一个可能更优的衰减率 $\alpha_a$ 收敛。

通过对这两种情况下的总代价进行计算和比较，可以得出一个非常简洁和深刻的结论：当考虑这个积分性能指标时，AFTC优于PFTC的条件是：
$$
\alpha_a > \rho \alpha_p
$$
这个不等式精辟地概括了AFTC的核心权衡：重新配置后的控制器所带来的更好性能（更大的衰减率 $\alpha_a$），必须足以补偿切换瞬态所造成的性能损失（由因子 $\rho$ 体现）以及被动策略本身固有的性能水平（由 $\alpha_p$ 体现）。这个条件为工程师在面对具体问题时，选择被动还是主动策略提供了强有力的理论指导。