{"hands_on_practices": [{"introduction": "在鲁棒模型预测控制（RMPC）中，我们必须确保即使在存在扰动的情况下，状态约束也能被严格满足。一种常见的技术是“收紧”施加在标称（无扰动）状态上的约束。本练习介绍庞特里亚金差集（Pontryagin difference）$X \\ominus E$，这是计算所需约束收紧量的基本数学工具。通过完成这个练习 [@problem_id:2746569]，你将亲身体验如何应用集合论运算，从而为一个简单但具有代表性的案例保证鲁棒的约束满足。", "problem": "考虑一个离散时间系统的鲁棒模型预测控制（MPC）设置，该系统在状态更新中存在加性扰动，在本任务中，仅涉及状态约束集和扰动集。在每个预测步长上，真实状态的约束集是由 $X=\\{x\\in\\mathbb{R}^{n}:\\|x\\|_{\\infty}\\le 1\\}$ 给出的轴对齐超立方体，加性扰动属于不确定性集 $E=\\{e\\in\\mathbb{R}^{n}:\\|e\\|_{\\infty}\\le 0.2\\}$。在鲁棒MPC中，为确保单步鲁棒可行性，一种常用的技术是向标称状态施加收紧约束 $x\\in X\\ominus E$，其中 $\\ominus$ 表示庞特里亚金集差。\n\n请仅从范数和集合运算的核心定义与性质出发，计算庞特里亚金集差 $X\\ominus E$ 的闭式集合表达式，并验证此收紧约束所产生的坐标方向上的裕度。然后，（从基本原理出发）论证为何你所求得的收紧集能够确保，当 $x\\in X\\ominus E$ 时，对于所有的 $e\\in E$，都有 $x+e\\in X$。\n\n请以 $X\\ominus E$ 的单一闭式表达式形式给出最终答案。无需进行数值舍入。最终答案应纯粹以含 $\\|\\cdot\\|_{\\infty}$ 的集合形式表达，不加任何额外说明。", "solution": "该问题要求计算并论证在鲁棒模型预测控制中使用的一个收紧约束集。我们已知状态约束集 $X$ 和扰动集 $E$，必须求出庞特里亚金集差 $X \\ominus E$。\n\n首先，我们陈述问题中给出的定义。\n状态约束集为 $X = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 1\\}$。\n加性扰动集为 $E = \\{e \\in \\mathbb{R}^n : \\|e\\|_{\\infty} \\le 0.2\\}$。\n\n庞特里亚金集差 $A \\ominus B$ 定义为所有点 $c$ 的集合，使得 $\\{c\\}$ 和 $B$ 的闵可夫斯基和是 $A$ 的一个子集。其形式化定义为：\n$$A \\ominus B = \\{c \\in \\mathbb{R}^n \\mid \\{c\\} + B \\subseteq A\\}$$\n这等价于：对于任意 $c \\in A \\ominus B$ 和任意 $b \\in B$，它们的和 $c+b$ 必须属于 $A$。\n\n将此定义应用于我们的特定集合 $X$ 和 $E$，一个向量 $x$ 属于 $X \\ominus E$ 当且仅当对于所有扰动 $e \\in E$，结果状态 $x+e$ 属于 $X$。一个向量属于 $X$ 的条件是其无穷范数小于或等于 $1$。因此，我们必须找到所有 $x \\in \\mathbb{R}^n$ 的集合，使得：\n$$\\|x+e\\|_{\\infty} \\le 1 \\quad \\forall e \\in E \\text{ where } \\|e\\|_{\\infty} \\le 0.2$$\n这等价于找到所有 $x$，使得 $\\|x+e\\|_{\\infty}$ 在所有有效 $e$ 上的最大可能值不超过 $1$：\n$$\\sup_{e \\in E} \\|x+e\\|_{\\infty} \\le 1$$\n\n我们现在将证明所得集合为 $X \\ominus E = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$。证明包含两个部分的包含关系。\n\n第一部分：我们证明 $\\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\} \\subseteq X \\ominus E$。\n令 $x$ 为任意向量，满足 $\\|x\\|_{\\infty} \\le 0.8$。令 $e$ 为来自集合 $E$ 的任意扰动，因此 $\\|e\\|_{\\infty} \\le 0.2$。我们必须证明 $x+e \\in X$。\n我们使用无穷范数的三角不等式，即对于任意 $u, v \\in \\mathbb{R}^n$，有 $\\|u+v\\|_{\\infty} \\le \\|u\\|_{\\infty} + \\|v\\|_{\\infty}$。\n应用此不等式，可得：\n$$\\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty}$$\n代入 $x$ 和 $e$ 的范数界限：\n$$\\|x+e\\|_{\\infty} \\le 0.8 + 0.2 = 1.0$$\n这证实了 $\\|x+e\\|_{\\infty} \\le 1$，意味着 $x+e \\in X$。由于这对任意 $e \\in E$ 都成立，我们证明了如果 $\\|x\\|_{\\infty} \\le 0.8$，则 $x \\in X \\ominus E$。\n\n第二部分：我们证明 $X \\ominus E \\subseteq \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$。\n我们采用反证法。假设存在一个 $x \\in X \\ominus E$，使得 $\\|x\\|_{\\infty} > 0.8$。\n根据无穷范数的定义，$\\|x\\|_{\\infty} = \\max_{i \\in \\{1,\\dots,n\\}} |x_i|$。设 $j$ 是达到此最大值的索引，因此 $|x_j| = \\|x\\|_{\\infty} > 0.8$。\n我们现在构造一个特定的扰动向量 $e^* \\in E$，旨在最大化地增加 $x$ 的第 $j$ 个分量。设 $e^*$ 的分量定义为：\n$$e^*_i = \\begin{cases} 0.2 \\cdot \\text{sgn}(x_j)  \\text{if } i=j \\\\ 0  \\text{if } i \\neq j \\end{cases}$$\n该向量的无穷范数为 $\\|e^*\\|_{\\infty} = \\max_i |e^*_i| = |0.2 \\cdot \\text{sgn}(x_j)| = 0.2$。因此，这个特定的向量 $e^*$ 是扰动集 $E$ 的一个元素。\n现在，考虑和 $x+e^*$。该向量的第 $j$ 个分量是 $(x+e^*)_j = x_j + e^*_j = x_j + 0.2 \\cdot \\text{sgn}(x_j)$。由于 $x_j$ 和 $0.2 \\cdot \\text{sgn}(x_j)$ 符号相同（或者如果 $x_j=0$ 则其中一个为零，但此处情况并非如此），它们和的绝对值等于它们绝对值的和：\n$$|(x+e^*)_j| = |x_j| + |0.2 \\cdot \\text{sgn}(x_j)| = |x_j| + 0.2$$\n回想 $|x_j| = \\|x\\|_{\\infty}$，我们有 $|(x+e^*)_j| = \\|x\\|_{\\infty} + 0.2$。\n由于我们假设了 $\\|x\\|_{\\infty} > 0.8$，因此可得：\n$$|(x+e^*)_j| > 0.8 + 0.2 = 1.0$$\n任何向量的无穷范数至少与它的任何分量的绝对值一样大。因此：\n$$\\|x+e^*\\|_{\\infty} \\ge |(x+e^*)_j| > 1.0$$\n这个结果 $\\|x+e^*\\|_{\\infty} > 1$ 意味着对于这个特定的 $e^* \\in E$，状态 $x+e^*$ 不在 $X$ 中。这与我们最初的假设 $x \\in X \\ominus E$ 相矛盾，该假设要求对于*所有* $e \\in E$ 都有 $x+e \\in X$。这个矛盾意味着我们的前提 $\\|x\\|_{\\infty} > 0.8$ 必定是错误的。因此，任何 $x \\in X \\ominus E$ 都必须满足 $\\|x\\|_{\\infty} \\le 0.8$。\n\n结合证明的两个部分，我们严格地确定了庞特里亚金集差为：\n$$X \\ominus E = \\{x \\in \\mathbb{R}^n : \\|x\\|_{\\infty} \\le 0.8\\}$$\n\n坐标方向上的裕度是指每个状态变量分量的约束被收紧的量。原始约束为 $|x_i| \\le 1$。收紧后的约束为 $|x_i| \\le 0.8$。裕度是界限之间的差值，即 $1 - 0.8 = 0.2$。这个裕度恰好等于任意单个坐标上扰动的最大可能幅值，即 $\\sup_{e \\in E}|e_i| = 0.2$。\n\n最后，我们从基本原理出发，论证为何这个收紧集能确保鲁棒可行性。根据定义，如果我们将标称状态 $x$ 约束在集合 $X \\ominus E$ 中，我们就是选择了一个满足 $\\|x\\|_{\\infty} \\le 0.8$ 的 $x$。对于扰动 $e \\in E$ 的任何可能实现，我们知道 $\\|e\\|_{\\infty} \\le 0.2$。真实状态是 $x+e$。要检查真实状态是否满足原始状态约束，我们必须验证 $\\|x+e\\|_{\\infty} \\le 1$ 是否成立。根据范数的三角不等式，$\\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty}$。代入标称状态和扰动的既定界限，我们得到上界 $\\|x+e\\|_{\\infty} \\le 0.8 + 0.2 = 1$。这保证了对于 $X \\ominus E$ 中的任意标称状态 $x$ 和 $E$ 中的任意扰动 $e$，真实状态将始终被包含在原始约束集 $X$ 内。这就是通过约束收紧实现鲁棒约束满足的原理。", "answer": "$$\\boxed{\\{x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 0.8\\}}$$", "id": "2746569"}, {"introduction": "虽然单步约束收紧很有用，但要确保在整个预测时域内的安全性，则需要一种更全面的方法。我们必须考虑扰动通过系统动力学传播时产生的累积效应。本练习 [@problem_id:2746575] 将指导你推导最小鲁棒正不变（RPI）集，它代表了包含所有可能误差轨迹的“管道”（tube）。理解如何计算该集合对于设计能够保证递归可行性和长期安全的基于管道的 RMPC 控制器至关重要。", "problem": "考虑一个在模型预测控制(MPC)下的离散时间线性时不变(LTI)闭环误差系统，其受加性有界扰动影响，动态方程由 $e_{k+1} = A_{K} e_{k} + w_{k}$ 给出，其中 $A_{K} \\in \\mathbb{R}^{n \\times n}$ 且对于所有 $k \\in \\mathbb{N}$ 都有 $w_{k} \\in W$。如果集合 $\\mathcal{E} \\subset \\mathbb{R}^{n}$ 满足 $A_{K} \\mathcal{E} \\oplus W \\subseteq \\mathcal{E}$，则称其为该系统的一个鲁棒正不变(RPI)集，其中 $\\oplus$ 表示闵可夫斯基和。在鲁棒MPC中，标称状态约束通常通过RPI集进行收紧，以确保标称状态在存在扰动的情况下仍保持可行；具体来说，对于一个对称凸约束集 $X$，一种常见的收紧是 $X_{\\text{tight}} = X \\ominus \\mathcal{E}$，其中 $\\ominus$ 表示庞特里亚金差。\n\n假设 $A_{K} = 0.5 I$ 且扰动集为轴对齐超立方体 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$。标称状态约束集为 $X = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\}$。仅使用RPI集、闵可夫斯基和以及集值级数极限的基本定义，推导最小RPI集 $\\mathcal{E}$，其作为扰动集 $W$ 通过闭环动态方程重复传播所生成的闵可夫斯基和级数的极限。然后，从第一性原理出发，量化所导出的无穷范数约束收紧量，该收紧量定义为必须从 $X$ 的每个边界上减去的标量 $\\tau$，使得 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 满足 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。\n\n提供收紧幅度 $\\tau$ 的精确值作为最终答案。无需四舍五入。最终答案必须是单个实数。", "solution": "第一步是推导给定系统的最小鲁棒正不变(RPI)集 $\\mathcal{E}$。最小RPI集是在所有可能的扰动序列作用下，从原点($e_0=0$)可达的所有状态的集合。它被构造为通过系统动态方程传播的扰动集的无穷闵可夫斯基和。\n从 $e_0 = 0$ 开始，在时间步 $k$ 的状态由下式给出：\n$$ e_k = \\sum_{i=0}^{k-1} A_K^i w_{k-1-i} $$\n任何时刻所有可能状态的集合是所有可达集的并集。最小RPI集 $\\mathcal{E}$ 是当 $k \\to \\infty$ 时这些可达集的极限：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} A_K^i W $$\n这个级数收敛，因为系统矩阵 $A_K$ 是舒尔稳定的。$A_K = 0.5 I$ 的特征值均为 $0.5$，其模小于 $1$。\n代入给定的 $A_K = 0.5 I$：\n$$ A_K^i = (0.5 I)^i = (0.5)^i I $$\n因此，最小RPI集为：\n$$ \\mathcal{E} = \\bigoplus_{i=0}^{\\infty} (0.5)^i I W = \\bigoplus_{i=0}^{\\infty} (0.5)^i W $$\n扰动集 $W = \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\}$ 是一个凸的、中心对称的集合（一个以原点为中心的超立方体）。对于这类集合，缩放和闵可夫斯基加法具有性质 $\\alpha S \\oplus \\beta S = (\\alpha+\\beta)S$，其中 $\\alpha, \\beta$ 为非负标量。将此推广到无穷和，我们可以写出：\n$$ \\mathcal{E} = \\left( \\sum_{i=0}^{\\infty} (0.5)^i \\right) W $$\n该和是公比 $r = 0.5$ 的几何级数：\n$$ \\sum_{i=0}^{\\infty} (0.5)^i = \\frac{1}{1 - 0.5} = \\frac{1}{0.5} = 2 $$\n因此，最小RPI集是：\n$$ \\mathcal{E} = 2 W = 2 \\{ w \\in \\mathbb{R}^{n} : \\|w\\|_{\\infty} \\le 0.1 \\} $$\n为了刻画这个集合，令 $e \\in \\mathcal{E}$。那么对于某个 $w \\in W$ 有 $e = 2w$。$e$ 的范数为 $\\|e\\|_{\\infty} = \\|2w\\|_{\\infty} = 2\\|w\\|_{\\infty}$。因为 $\\|w\\|_{\\infty} \\le 0.1$，所以可得 $\\|e\\|_{\\infty} \\le 2 \\times 0.1 = 0.2$。\n所以，最小RPI集是超立方体：\n$$ \\mathcal{E} = \\{ e \\in \\mathbb{R}^{n} : \\|e\\|_{\\infty} \\le 0.2 \\} $$\n\n第二步是确定收紧幅度 $\\tau$。收紧后的约束集由 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 给出。该集合必须满足条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$。此条件确保如果标称状态在 $X_{\\text{tight}}$ 内，那么真实状态（标称状态加误差）将保持在原始约束集 $X$ 内。\n\n让我们分析闵可夫斯基和 $X_{\\text{tight}} \\oplus \\mathcal{E}$。$X_{\\text{tight}}$ 和 $\\mathcal{E}$ 都是由无穷范数界定的以原点为中心的超立方体。\n- $X_{\\text{tight}}$ 是一个无穷范数半径为 $1 - \\tau$ 的超立方体。\n- $\\mathcal{E}$ 是一个无穷范数半径为 $0.2$ 的超立方体。\n两个以原点为中心的超立方体的闵可夫斯基和是另一个以原点为中心的超立方体，其半径是它们半径之和。\n令 $z \\in X_{\\text{tight}} \\oplus \\mathcal{E}$。那么对于某个 $x \\in X_{\\text{tight}}$ 和 $e \\in \\mathcal{E}$，有 $z = x + e$。$z$ 的无穷范数有界，如下：\n$$ \\|z\\|_{\\infty} = \\|x+e\\|_{\\infty} \\le \\|x\\|_{\\infty} + \\|e\\|_{\\infty} $$\n最大可能值是可以达到的，因此结果集可由下式刻画：\n$$ \\sup_{z \\in X_{\\text{tight}} \\oplus \\mathcal{E}} \\|z\\|_{\\infty} = \\sup_{x \\in X_{\\text{tight}}} \\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}} \\|e\\|_{\\infty} = (1 - \\tau) + 0.2 = 1.2 - \\tau $$\n所以，$X_{\\text{tight}} \\oplus \\mathcal{E} = \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\}$。\n条件 $X_{\\text{tight}} \\oplus \\mathcal{E} \\subseteq X$ 变为：\n$$ \\{ z \\in \\mathbb{R}^{n} : \\|z\\|_{\\infty} \\le 1.2 - \\tau \\} \\subseteq \\{ x \\in \\mathbb{R}^{n} : \\|x\\|_{\\infty} \\le 1 \\} $$\n为使此集合包含关系成立，内部集合的半径必须小于或等于外部集合的半径：\n$$ 1.2 - \\tau \\le 1 $$\n这意味着 $0.2 \\le \\tau$。为确保可行性同时做到最小保守，我们必须为收紧量 $\\tau$ 选择可能的最小值。满足条件的最小收紧量是 $\\tau = 0.2$。\n\n这等同于计算庞特里亚金差 $X \\ominus \\mathcal{E}$。根据定义，$X \\ominus \\mathcal{E} = \\{ x \\in \\mathbb{R}^n \\mid x \\oplus \\mathcal{E} \\subseteq X \\}$。\n对于一个元素 $x$ 要属于这个集合，必须对所有 $e \\in \\mathcal{E}$ 都有 $x+e \\in X$。这意味着对所有 $\\|e\\|_{\\infty} \\le 0.2$ 都有 $\\|x+e\\|_{\\infty} \\le 1$。\n对于一个固定的 $x$，$\\|x+e\\|_{\\infty}$ 的最大值为 $\\|x\\|_{\\infty} + \\sup_{e \\in \\mathcal{E}}\\|e\\|_{\\infty}$。\n所以，条件是 $\\|x\\|_{\\infty} + 0.2 \\le 1$，可简化为 $\\|x\\|_{\\infty} \\le 0.8$。\n这定义了最大的收紧集：$X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 0.8 \\}$。\n将其与给定形式 $X_{\\text{tight}} = \\{ x \\in \\mathbb{R}^n \\mid \\|x\\|_{\\infty} \\le 1 - \\tau \\}$ 进行比较，我们令边界相等：\n$$ 1 - \\tau = 0.8 $$\n解出 $\\tau$ 可得 $\\tau = 1 - 0.8 = 0.2$。\n收紧幅度为 $\\tau = 0.2$。", "answer": "$$\\boxed{0.2}$$", "id": "2746575"}, {"introduction": "鲁棒正不变（RPI）集的理论推导通常涉及无穷级数或抽象定义。为了在实践中应用，我们需要一个具体的算法来计算这些集合。本练习 [@problem_id:2741157] 将理论付诸实践，要求你使用线性规划实现一个不动点迭代算法，以计算状态约束内的最大 RPI 集。这个编程练习将展示如何将前驱集和集合交集等抽象概念转化为一个强大的鲁棒控制器综合计算工具。", "problem": "考虑一个带有加性扰动的离散时间线性时不变系统，由 $x^{+} = A x + B u + w$ 给出，其中 $x \\in \\mathbb{R}^{n}$ 是状态， $u \\in \\mathbb{R}^{m}$ 是控制输入， $w \\in \\mathbb{R}^{n}$ 是一个外部扰动。应用静态状态反馈 $u = K x$，得到闭环系统 $x^{+} = A_{\\mathrm{cl}} x + w$，其中 $A_{\\mathrm{cl}} := A + B K$。状态被约束在一个紧凸集 $X := \\{ x \\in \\mathbb{R}^{n} \\mid H x \\le h \\}$ 内，扰动在一个紧凸集 $W$ 内有界。如果对于所有 $x \\in S$ 和所有 $w \\in W$，后继状态 $A_{\\mathrm{cl}} x + w$ 仍在 $S$ 内，则集合 $S \\subseteq X$ 称为该闭环系统的一个鲁棒正不变 (RPI) 集。在鲁棒模型预测控制 (RMPC) 的背景下，计算包含在 $X$ 中的最大 RPI 集可以保证鲁棒可行性和约束满足。\n\n您的任务是推导并实现一个不动点迭代，使用基于鲁棒一步前驱算子的多胞体不动点迭代来计算包含在 $X$ 中的最大 RPI 集。该计算必须是完全自动化的，并且当满足收敛准则或结果集变为空集时必须在数值上终止。\n\n基本原理：\n- 鲁棒正不变性的定义：对于系统 $x^{+} = A_{\\mathrm{cl}} x + w$，集合 $S$ 是 RPI 的当且仅当对于所有 $x \\in S$ 和所有 $w \\in W$，都有 $A_{\\mathrm{cl}} x + w \\in S$。\n- 集合 $S$ 的鲁棒一步前驱集是 $\\mathrm{Pre}(S) := \\{ x \\in \\mathbb{R}^{n} \\mid A_{\\mathrm{cl}} x + w \\in S \\ \\text{for all} \\ w \\in W \\}$。\n- 对于多胞体 $S = \\{ x \\mid H x \\le c \\}$ 和紧凸集 $W$，包含关系 $A_{\\mathrm{cl}} x + w \\in S$ 对所有 $w \\in W$ 成立，等价于 $H A_{\\mathrm{cl}} x \\le c - s$，其中 $s \\in \\mathbb{R}^{q}$ 的分量为 $s_{i} = \\max_{w \\in W} (H_{i} w)$，即 $W$ 的支撑函数在刻面法向量 $H_{i}$ 上的取值。\n- $X$ 的最大 RPI 子集的集合迭代为 $S_{0} := X$ 和 $S_{k+1} := X \\cap \\mathrm{Pre}(S_{k})$，这是一个单调非增序列，在温和条件下收敛到 $X$ 的最大 RPI 子集或空集。\n\n为了使计算在有限时间内算法上可行且易于测试，请使用固定的刻面法向量模板 $H$，并计算一系列形如 $S_{k} = \\{ x \\mid H x \\le c_{k} \\}$ 的集合，其中向量 $c_k$ 变化而 $H$ 固定。您必须：\n- 使用轴对齐的盒式模板 $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$，其中 $I$ 是 $n \\times n$ 的单位矩阵。当相对刻面的上界相等时，此模板表示关于原点对称的超矩形。状态约束集为 $X := \\{ x \\mid H x \\le h_{X} \\}$，其中 $h_{X} = \\begin{bmatrix} \\bar{x} \\\\ \\bar{x} \\end{bmatrix}$，$\\bar{x} \\in \\mathbb{R}^{n}_{\\ge 0}$ 是状态界限向量。\n- 令扰动集为盒子 $W := \\{ w \\in \\mathbb{R}^{n} \\mid |w_{j}| \\le \\bar{w}_{j} \\}$，因此其在行向量 $H_{i}$ 上的支撑函数为 $s_{i} = \\sum_{j=1}^{n} |H_{i j}| \\bar{w}_{j}$。对于所选的 $H$，这简化为 $s = \\begin{bmatrix} \\bar{w} \\\\ \\bar{w} \\end{bmatrix}$。\n\n按如下方式推导将 $c_{k}$ 映射到 $c_{k+1}$ 的不动点更新：\n- 从 $c_{0} = h_{X}$ 开始。\n- 给定 $c_k$，计算鲁棒前驱约束 $H A_{\\mathrm{cl}} x \\le c_{k} - s$。\n- 通过对每一行 $i$ 求解线性规划来计算 $c_{k+1}$ 作为同一模板中的最紧向量，该线性规划返回在满足 $H A_{\\mathrm{cl}} x \\le c_{k} - s$ 和 $H x \\le h_{X}$ 的 $x$ 上 $H_i x$ 的最大值，从而满足 $S_{k+1} = \\{ x \\mid H x \\le c_{k+1} \\} \\supseteq X \\cap \\mathrm{Pre}(S_{k})$。将 $c_{k+1,i}$ 设为此最大值。如果交集为空，则声明 $S_{k+1} = \\varnothing$ 并终止。\n- 当 $\\| c_{k+1} - c_{k} \\|_{\\infty} \\le \\varepsilon$（其中 $\\varepsilon$ 是收敛容差）或检测到空集时停止。\n\n为了报告结果，将最终集的每轴半宽定义为 $r_{j} := \\min\\{ c_{\\infty, j}, \\ c_{\\infty, j+n} \\}$，其中 $j \\in \\{1,\\dots,n\\}$，$c_{\\infty}$ 是收敛后的向量。如果集合为空，则对所有 $j$ 定义 $r_{j} := 0$。将二维情况下的面积定义为 $A := 4 \\, r_{1} r_{2}$。所有数值结果必须四舍五入到六位小数。\n\n使用线性规划求解逐刻面最大化问题来实现上述过程，并使用以下测试套件。在每个测试中，计算 $A_{\\mathrm{cl}} = A + B K$，迭代至收敛或空集，并输出半宽和面积。\n\n测试套件（所有数字均为实数标量；所有矩阵和向量均明确给出）：\n- 测试 1（正常情况，开环稳定）：\n  - $n = 2$，\n  - $A = \\begin{bmatrix} 0.9  0.1 \\\\ 0.0  0.8 \\end{bmatrix}$，\n  - $B = I_{2}$，\n  - $K = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$，\n  - $\\bar{x} = \\begin{bmatrix} 2.0 \\\\ 2.0 \\end{bmatrix}$，\n  - $\\bar{w} = \\begin{bmatrix} 0.05 \\\\ 0.05 \\end{bmatrix}$。\n- 测试 2（通过反馈镇定，非平凡耦合）：\n  - $n = 2$，\n  - $A = \\begin{bmatrix} 1.2  0.1 \\\\ 0.2  1.1 \\end{bmatrix}$，\n  - $B = I_{2}$，\n  - $K = \\begin{bmatrix} -0.8  0.0 \\\\ 0.0  -0.7 \\end{bmatrix}$，\n  - $\\bar{x} = \\begin{bmatrix} 1.0 \\\\ 0.8 \\end{bmatrix}$，\n  - $\\bar{w} = \\begin{bmatrix} 0.02 \\\\ 0.01 \\end{bmatrix}$。\n- 测试 3（边界情况，因扰动过大而不可行）：\n  - $n = 2$，\n  - $A = 0.95 \\, I_{2}$，\n  - $B = I_{2}$，\n  - $K = \\begin{bmatrix} 0.0  0.0 \\\\ 0.0  0.0 \\end{bmatrix}$，\n  - $\\bar{x} = \\begin{bmatrix} 0.1 \\\\ 0.1 \\end{bmatrix}$，\n  - $\\bar{w} = \\begin{bmatrix} 0.12 \\\\ 0.12 \\end{bmatrix}$。\n\n数值规格：\n- 在 $\\ell_{\\infty}$-范数下使用收敛容差 $\\varepsilon = 10^{-8}$，最大迭代次数为 200 次。\n- 如果任何迭代产生不可行的交集 $X \\cap \\mathrm{Pre}(S_{k})$，则视该集合为空集。\n\n要求的最终输出格式：\n- 您的程序必须打印一行，其中包含每个测试结果的列表，每个测试结果是一个列表 $[r_{1}, r_{2}, A]$，所有条目都四舍五入到六位小数。对于上述三个测试，要求的格式是：\n- $[[r_{1}^{(1)}, r_{2}^{(1)}, A^{(1)}],[r_{1}^{(2)}, r_{2}^{(2)}, A^{(2)}],[r_{1}^{(3)}, r_{2}^{(3)}, A^{(3)}]]$。\n\n此问题中没有物理单位，也未使用角度。所有实数值输出必须是小数点后恰好有六位的小数。", "solution": "该问题要求推导并实现一个不动点迭代算法，用于计算在状态和扰动约束下离散时间线性系统的最大鲁棒正不变 (RPI) 集。该解决方案将基于多胞体集合运算，并通过线性规划在算法上实现。\n\n系统动力学由 $x^{+} = A x + B u + w$ 给出，采用状态反馈控制律 $u=Kx$ 后，闭环系统为 $x^{+} = A_{\\mathrm{cl}} x + w$，其中 $A_{\\mathrm{cl}} = A + B K$。状态 $x \\in \\mathbb{R}^n$ 被约束在一个集合 $X$ 内，扰动 $w \\in \\mathbb{R}^n$ 在一个集合 $W$ 内有界。\n\n如果对于任意状态 $x \\in S$ 和任意扰动 $w \\in W$，下一状态 $x^{+} = A_{\\mathrm{cl}}x + w$ 仍然在 $S$ 中，则集合 $S$ 是一个鲁棒正不变 (RPI) 集。目标是找到包含在状态约束集 $X$ 内的最大的此类集合，记为 $S_{\\infty} \\subseteq X$。\n\n该计算通过对一系列集合 $\\{S_k\\}_{k \\ge 0}$ 进行不动点迭代来完成，定义如下：\n$$ S_0 = X $$\n$$ S_{k+1} = X \\cap \\mathrm{Pre}(S_k) $$\n其中 $\\mathrm{Pre}(S_k)$ 是 $S_k$ 的鲁棒一步前驱集。它包含所有状态 $x$，使得无论扰动 $w \\in W$ 如何，所有可能的下一状态 $A_{\\mathrm{cl}}x + w$ 都在 $S_k$ 中。形式上，\n$$ \\mathrm{Pre}(S_k) = \\{ x \\in \\mathbb{R}^n \\mid A_{\\mathrm{cl}}x + w \\in S_k, \\ \\forall w \\in W \\} $$\n这个集合序列是单调非增的，$S_{k+1} \\subseteq S_k$，并收敛到最大 RPI 集 $S_{\\infty}$。\n\n为了使该算法在计算上可行，我们将集合表示为具有固定刻面法向量模板的多胞体。模板由 $H = \\begin{bmatrix} I \\\\ -I \\end{bmatrix}$ 给出，其中 $I$ 是 $n \\times n$ 的单位矩阵。因此，这些集合是形如 $S_k = \\{ x \\mid H x \\le c_k \\}$ 的超矩形。\n\n状态约束集为 $X = \\{ x \\mid H x \\le h_X \\}$，其中对于给定的正界限向量 $\\bar{x}$，$h_X = [\\bar{x}^T, \\bar{x}^T]^T$。这对应于每个分量 $j$ 都有 $|x_j| \\le \\bar{x}_j$。\n扰动集为 $W = \\{ w \\mid |w_j| \\le \\bar{w}_j \\}$。\n\n让我们推导前驱集 $\\mathrm{Pre}(S_k)$ 的约束。给定 $S_k = \\{ x \\mid H x \\le c_k \\}$，条件 $A_{\\mathrm{cl}}x + w \\in S_k$ 变为 $H(A_{\\mathrm{cl}}x + w) \\le c_k$。这必须对所有 $w \\in W$ 成立。这等价于：\n$$ H A_{\\mathrm{cl}} x + H w \\le c_k, \\quad \\forall w \\in W $$\n$$ H A_{\\mathrm{cl}} x \\le c_k - H w, \\quad \\forall w \\in W $$\n为了对所有 $w$ 满足此条件，我们必须对使 $Hw$ 最大化的最坏情况 $w$ 满足它。这导致不等式：\n$$ H A_{\\mathrm{cl}} x \\le c_k - s $$\n其中 $s$ 是一个向量，其第 $i$ 个分量是 $W$ 在法向量 $H_i$ 上的支撑函数值，即 $s_i = \\max_{w \\in W} (H_i w)$。对于所选的模板 $H$ 和扰动集 $W$，$H$ 的行是 $H_{j} = e_j$ 和 $H_{n+j} = -e_j$，其中 $j=1, \\dots, n$。\n对于行 $H_j = e_j$，$s_j = \\max_{w \\in W} w_j = \\bar{w}_j$。\n对于行 $H_{n+j} = -e_j$，$s_{n+j} = \\max_{w \\in W} (-w_j) = \\bar{w}_j$。\n因此，支撑向量是常数 $s = [\\bar{w}^T, \\bar{w}^T]^T$。\n前驱集是多胞体 $\\mathrm{Pre}(S_k) = \\{ x \\mid H A_{\\mathrm{cl}} x \\le c_k - s \\}$。\n\n下一个迭代项 $S_{k+1}$ 由两个多胞体的交集定义：$S_{k+1, \\text{exact}} = X \\cap \\mathrm{Pre}(S_k) = \\{ x \\mid H x \\le h_X \\text{ and } H A_{\\mathrm{cl}} x \\le c_k - s \\}$。\n为了使用固定模板 $H$ 继续迭代，我们必须找到包含该交集的最紧的超矩形 $\\{x \\mid H x \\le c_{k+1}\\}$。新向量 $c_{k+1}$ 的分量 $c_{k+1,i}$ 是通过在该交集上最大化相应的线性函数 $H_i x$ 来找到的。这是通过为 $2n$ 个刻面中的每一个求解一个线性规划（LP）来实现的：\n$$ c_{k+1, i} = \\max_{x \\in \\mathbb{R}^n} \\quad H_i x $$\n$$ \\text{subject to:} \\quad \\begin{bmatrix} H \\\\ H A_{\\mathrm{cl}} \\end{bmatrix} x \\le \\begin{bmatrix} h_X \\\\ c_k - s \\end{bmatrix} $$\n如果这些 LP 中有任何一个是不可行的，则交集为空，意味着在 $X$ 内不存在 RPI 集，迭代终止。\n\n总体算法如下：\n1.  初始化 $k=0$，令 $c_0 = h_X$。\n2.  在每次迭代 $k$ 中，构造 LP 约束的右侧，即 $b_{LP} = [h_X^T, (c_k - s)^T]^T$。约束矩阵 $A_{LP} = [H^T, (H A_{\\mathrm{cl}})^T]^T$ 是常数。\n3.  对于每个刻面 $i=1, \\ldots, 2n$，求解相应的 LP 以找到 $c_{k+1,i}$。如果任何 LP 是不可行的，则最大 RPI 集为空。终止并报告一个空集。\n4.  通过将新向量 $c_{k+1}$ 与前一个向量 $c_k$ 进行比较来检查收敛性。如果对于一个小的容差 $\\varepsilon$，有 $\\|c_{k+1} - c_k\\|_{\\infty} \\le \\varepsilon$，则迭代已收敛到 $c_{\\infty}$。\n5.  如果未收敛，则设置 $c_k = c_{k+1}$ 并从步骤 2 开始重复，直到达到最大迭代次数。\n6.  一旦收敛到 $c_{\\infty}$，最终集合为 $S_{\\infty} = \\{x \\mid Hx \\le c_{\\infty}\\}$。半宽计算为 $r_j = \\min\\{ c_{\\infty, j}, c_{\\infty, j+n} \\}$，其中 $j=1, \\dots, n$。如果集合为空，则所有 $r_j=0$。对于 $n=2$，面积为 $A = 4 r_1 r_2$。\n此过程被实现以解决给定的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef compute_mRPI(A, B, K, x_bar, w_bar, tol=1e-8, max_iter=200):\n    \"\"\"\n    Computes the maximal Robust Positively Invariant (RPI) set.\n    \n    The function implements a fixed-point iteration using linear programming\n    to find the maximal RPI set S_inf contained in the state constraint set X\n    for the system x^+ = A_cl*x + w.\n    \"\"\"\n    n = A.shape[0]\n\n    # --- Setup System and Set Definitions ---\n    A_cl = A + B @ K\n    I_n = np.identity(n)\n    H = np.vstack([I_n, -I_n])  # Shape (2n, n)\n\n    h_X = np.hstack([x_bar, x_bar])  # Shape (2n,)\n    s = np.hstack([w_bar, w_bar])    # Shape (2n,)\n\n    # --- LP Formulation ---\n    # The constraint matrix is constant throughout the iterations.\n    A_lp = np.vstack([H, H @ A_cl])  # Shape (4n, n)\n\n    # --- Iteration ---\n    c_k = h_X\n    is_empty = False\n    \n    for k in range(max_iter):\n        c_k_plus_1 = np.zeros(2 * n)\n        \n        # The right-hand side of the LP constraints depends on c_k.\n        b_lp = np.hstack([h_X, c_k - s])  # Shape (4n,)\n\n        for i in range(2 * n):\n            # Objective: max H[i,:] @ x  => min -H[i,:] @ x\n            c_obj = -H[i, :]\n\n            # Solve the LP. The 'highs' method is robust and the default in recent SciPy.\n            res = linprog(c=c_obj, A_ub=A_lp, b_ub=b_lp, bounds=(None, None), method='highs')\n            \n            # Check for infeasibility.\n            if not res.success:\n                is_empty = True\n                break\n            \n            # The LP minimizes, so the maximum value is -res.fun\n            c_k_plus_1[i] = -res.fun\n        \n        if is_empty:\n            break\n\n        # Check for emptiness based on derived bounds.\n        # If max(x_j)  min(x_j), the set is empty.\n        # max(x_j) = c_k_plus_1[j], min(x_j) = -c_k_plus_1[n+j].\n        # So, if c_k_plus_1[j]  -c_k_plus_1[n+j] for any j, it's empty.\n        if np.any(c_k_plus_1[:n]  -c_k_plus_1[n:]):\n            is_empty = True\n            break\n        \n        # Check for convergence in the infinity norm.\n        if np.max(np.abs(c_k_plus_1 - c_k)) = tol:\n            c_k = c_k_plus_1 # Final converged value\n            break\n        \n        c_k = c_k_plus_1\n\n    # --- Post-processing and Result Calculation ---\n    if is_empty:\n        r = np.zeros(n)\n        area = 0.0\n    else:\n        # If loop finished due to max_iter, use the last computed c_k.\n        c_inf = c_k\n        # Calculate half-widths as per problem definition\n        r = np.minimum(c_inf[:n], c_inf[n:])\n        \n        # If any half-width is negative, the set is considered empty.\n        if np.any(r  0):\n            r.fill(0.0)\n            area = 0.0\n        else:\n            if n == 2:\n                # Area = (2*r1) * (2*r2)\n                area = 4 * r[0] * r[1]\n            else:\n                area = np.nan # Not defined for n!=2 in this problem\n    return r, area\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Stable open-loop system\n        {\n            \"A\": np.array([[0.9, 0.1], [0.0, 0.8]]),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([2.0, 2.0]),\n            \"w_bar\": np.array([0.05, 0.05]),\n        },\n        # Test 2: Unstable system stabilized by feedback\n        {\n            \"A\": np.array([[1.2, 0.1], [0.2, 1.1]]),\n            \"B\": np.identity(2),\n            \"K\": np.array([[-0.8, 0.0], [0.0, -0.7]]),\n            \"x_bar\": np.array([1.0, 0.8]),\n            \"w_bar\": np.array([0.02, 0.01]),\n        },\n        # Test 3: Infeasible due to large disturbance\n        {\n            \"A\": 0.95 * np.identity(2),\n            \"B\": np.identity(2),\n            \"K\": np.zeros((2, 2)),\n            \"x_bar\": np.array([0.1, 0.1]),\n            \"w_bar\": np.array([0.12, 0.12]),\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        r, area = compute_mRPI(\n            A=case[\"A\"], \n            B=case[\"B\"], \n            K=case[\"K\"], \n            x_bar=case[\"x_bar\"], \n            w_bar=case[\"w_bar\"]\n        )\n        \n        # Store results for final printing\n        if r.shape[0] == 2:\n            results.append([r[0], r[1], area])\n\n    # Final print statement in the exact required format.\n    # Format: [[r1_1,r2_1,A_1],[r1_2,r2_2,A_2],[r1_3,r2_3,A_3]]\n    # with 6 decimal places and no spaces within the inner lists.\n    formatted_results = []\n    for res in results:\n        # res is a list [r1, r2, Area]\n        formatted_results.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2741157"}]}