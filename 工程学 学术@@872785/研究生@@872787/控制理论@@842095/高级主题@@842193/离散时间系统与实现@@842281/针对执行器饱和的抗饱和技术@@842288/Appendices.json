{"hands_on_practices": [{"introduction": "反馈补偿（back-calculation）是一种经典的抗饱和策略，但其效果在很大程度上取决于抗饱和增益 $k_{\\mathrm{aw}}$ 的选择。此练习提供了一种系统性的方法，将饱和恢复过程视为一个动态系统，通过调节其带宽来整定此增益。通过这个练习，你将掌握一种将性能指标（即恢复速度）直接转化为控制器参数的 principled tuning 方法。[@problem_id:2690044]", "problem": "给定一个单输入单输出闭环系统，该系统由一个线性时不变对象、一个比例积分控制器、一个饱和执行器和一个反计算（back-calculation）抗饱和机制组成。对象由传递函数 $P(s) = \\dfrac{1}{s + 1}$ 描述，控制器由传递函数 $K(s) = k_p + \\dfrac{k_i}{s}$ 描述。执行器将控制器输出 $u(t)$ 饱和为信号 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$，其对称限制为 $\\pm u_{\\max}$。反计算抗饱和通过将信号 $v(t) - u(t)$ 乘以一个标量增益 $k_{\\mathrm{aw}}$ 来修正控制器的内部积分器状态，即控制器积分器的动态特性为\n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right),$$\n其中 $u(t) = k_p e(t) + k_i z(t)$ 且 $e(t) = r(t) - y(t)$，$y(t)$ 是对象输出，$r(t)$ 是参考信号。\n\n从线性时不变系统、Laplace 变换和闭环互联的核心定义出发，仅利用比例积分控制器和饱和执行器的特性，通过对外源信号 $w(t) = u(t) - v(t)$ 到 $v(t)$ 的环路传递进行整形，推导一种基于原理的抗饱和增益 $k_{\\mathrm{aw}}$ 整定方法，使得有效的去饱和动态在一个期望的角带宽 $\\omega_{\\mathrm{aw}}$（单位为弧度/秒）处呈现一个单实极点。你的推导必须从闭环系统的状态空间或传递函数表示开始，其中外源输入 $w(t)$ 在执行器处注入，必须与上面给出的对象和控制器内部一致，并论证 $k_{\\mathrm{aw}}$ 的选择如何决定去饱和带宽。\n\n在推导出整定规则后，将其在一个数值实验中实现，以演示在一个大的阶跃指令后，抗饱和带宽如何影响执行器从饱和状态的暂态恢复过程。数值实验中使用以下固定参数：\n- 对象 $P(s) = \\dfrac{1}{s + 1}$。\n- 控制器增益 $k_p = 4$ 和 $k_i = 4$。\n- 饱和极限 $u_{\\max} = 0.5$。\n- 对于所有 $t \\ge 0$，阶跃参考 $r(t) = r_0$，其中 $r_0 = 2$。\n- 初始条件：对象状态 $x_p(0) = 0$，控制器积分器状态 $z(0) = 0$。\n\n将未饱和闭环带宽 $\\omega_{\\mathrm{cl}}$ 定义为由 $P(s)$ 和 $K(s)$ 组成、没有执行器饱和和抗饱和反馈（即使用标准比例积分控制器）的线性闭环系统的最慢极点（最靠近虚轴的极点）实部的绝对值。使用你推导的整定方法，选择 $k_{\\mathrm{aw}}$ 以实现由 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ 给出的三种不同的抗饱和带宽，其中因子 $f$ 在下面的测试套件中指定。\n\n仿真得到的带有饱和器和抗饱和反馈的非线性闭环系统，并计算去饱和恢复时间 $t_{\\mathrm{rec}}$，其定义为饱和偏差 $|w(t)| = |u(t) - v(t)|$ 超过一个很小的阈值 $\\varepsilon$ 的最后时刻。使用 $\\varepsilon = 1\\times 10^{-3}$，并仿真到一个足以捕捉恢复过程的有限时间范围 $T_{\\max}$；你必须使用 $T_{\\max} = 15$ 秒。将 $t_{\\mathrm{rec}}$ 以秒为单位表示，并四舍五入到三位小数。\n\n你的程序必须实现以下包含三个抗饱和带宽因子的测试套件：\n- 情况 1：$f = 0.5$。\n- 情况 2：$f = 2$。\n- 情况 3：$f = 10$。\n\n对于每种情况，计算 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$，根据你推导的环路整形规则整定 $k_{\\mathrm{aw}}$，运行仿真，并返回相应的 $t_{\\mathrm{rec}}$。你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[1.234,5.678,9.000]\"），其中每个条目是对应测试用例的 $t_{\\mathrm{rec}}$（单位为秒），四舍五入到三位小数。不应打印任何其他文本。", "solution": "我们从一个标准的互联系统开始，该系统包含一个单输入单输出线性对象、一个比例积分控制器和一个饱和执行器。对象为 $P(s) = \\dfrac{1}{s + 1}$。控制器为 $K(s) = k_p + \\dfrac{k_i}{s}$，通过内部积分器状态 $z(t)$ 实现，在没有抗饱和的情况下，其方程为 $u(t) = k_p e(t) + k_i z(t)$ 和 $\\dot{z}(t) = e(t)$。饱和器将预饱和输入 $u(t)$ 映射为 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$，对象的状态空间实现为 $\\dot{x}_p(t) = - x_p(t) + v(t)$，输出为 $y(t) = x_p(t)$。闭环误差为 $e(t) = r(t) - y(t)$。\n\n为了分析执行器饱和，我们引入外源偏差信号 $w(t) = u(t) - v(t)$，因此 $v(t) = u(t) - w(t)$。反计算抗饱和将积分器动态修正为\n$$\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right) = e(t) - k_{\\mathrm{aw}} w(t)。$$\n这种结构使控制器内部状态跟踪饱和的执行器输出，从而抵消积分饱和效应。\n\n我们通过研究控制去饱和动态的映射关系来推导一种环路整形规则，这种动态由预饱和控制器信号 $u(t)$ 对饱和执行器输出 $v(t)$ 的跟踪过程所捕捉。考虑一种隔离跟踪环路的情形，即设置 $e(t) = 0$，这代表当误差反馈与反计算项相比可以忽略不计时，饱和对控制器的局部影响。在 $e(t) = 0$ 的条件下，我们有 $u(t) = k_i z(t)$ 和\n$$\\dot{z}(t) = - k_{\\mathrm{aw}} w(t) = k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right)。$$\n由此可得\n$$\\dot{u}(t) = k_i \\dot{z}(t) = k_i k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right)。$$\n在零初始条件下取 Laplace 变换，得到\n$$s U(s) = k_i k_{\\mathrm{aw}} \\left(V(s) - U(s)\\right)，$$\n因此从 $V(s)$ 到 $U(s)$ 的传递函数是\n$$\\frac{U(s)}{V(s)} = \\frac{k_i k_{\\mathrm{aw}}}{s + k_i k_{\\mathrm{aw}}}。$$\n因此，$u(t)$ 对 $v(t)$ 的跟踪动态是一个稳定的一阶系统，其单极点位于 $s = - k_i k_{\\mathrm{aw}}$，带宽等于角频率 $\\omega = k_i k_{\\mathrm{aw}}$。由于 $w(t) = u(t) - v(t)$，偏差 $w(t)$ 以相同的时间常数衰减。在去饱和期间 $e(t)$ 相对于反计算作用较小的极限情况下，这种基本关系与对象的具体细节无关。\n\n这提出了一个环路整形规则：选择 $k_{\\mathrm{aw}}$ 以实现期望的去饱和带宽 $\\omega_{\\mathrm{aw}}$，通过设置\n$$k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i}。$$\n该规则确保与去饱和相关的闭环映射在 $s = - \\omega_{\\mathrm{aw}}$ 处有一个单实极点，从而通过以指定的带宽跟踪 $v(t)$ 来间接地形塑从 $w(t)$ 到 $v(t)$ 的传递函数。对包括 $P(s)$ 和 $K(s)$ 在内的完整闭环系统的影响是，在饱和期间，控制器内部状态被拉向跟踪饱和的执行器输出，其时间常数为 $1 / \\omega_{\\mathrm{aw}}$，从而减少积分饱和，并在执行器离开饱和状态后改善恢复性能。\n\n接下来，我们必须定义在没有饱和和抗饱和的情况下的基准闭环带宽 $\\omega_{\\mathrm{cl}}$。对于 $P(s) = \\dfrac{1}{s + 1}$ 和 $K(s) = k_p + \\dfrac{k_i}{s}$，线性闭环系统在单位反馈下的特征多项式由 $1 + K(s) P(s) = 0$ 得到，即\n$$1 + \\left(k_p + \\frac{k_i}{s}\\right) \\frac{1}{s + 1} = 0。$$\n两边乘以 $s (s + 1)$ 得\n$$s (s + 1) + k_p s + k_i = 0，$$\n化简为\n$$s^2 + (1 + k_p) s + k_i = 0。$$\n闭环极点是这个二次方程的根。最慢的极点（即最靠近虚轴的极点）决定了主导衰减率，我们将未饱和闭环带宽定义为\n$$\\omega_{\\mathrm{cl}} = \\left| \\operatorname{Re}\\left(s_{\\mathrm{dom}}\\right) \\right|，$$\n其中 $s_{\\mathrm{dom}}$ 是在本例中两个不同实极点中实部最大（最接近零）的极点。对于数值参数 $k_p = 4$ 和 $k_i = 4$，特征多项式为 $s^2 + 5 s + 4$，其根为 $s = -1$ 和 $s = -4$，因此主导极点是 $s_{\\mathrm{dom}} = -1$ 且 $\\omega_{\\mathrm{cl}} = 1$。\n\n有了这个基准带宽，我们通过设置以下方式实现环路整形规则\n$$\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}, \\quad k_{\\mathrm{aw}} = \\frac{\\omega_{\\mathrm{aw}}}{k_i} = \\frac{f \\, \\omega_{\\mathrm{cl}}}{k_i}。$$\n这提供了一个从期望的去饱和带宽因子 $f$ 到抗饱和增益 $k_{\\mathrm{aw}}$ 的系统性映射。\n\n为了演示抗饱和带宽对暂态恢复的影响，我们仿真带有饱和器和反计算抗饱和的非线性闭环系统，使用对象状态空间 $\\dot{x}_p(t) = - x_p(t) + v(t)$ 和 $y(t) = x_p(t)$，控制器 $u(t) = k_p e(t) + k_i z(t)$ 及 $\\dot{z}(t) = e(t) + k_{\\mathrm{aw}} \\left(v(t) - u(t)\\right)$，误差 $e(t) = r(t) - y(t)$，阶跃参考 $r(t) = r_0$ 且 $r_0 = 2$，以及饱和 $v(t) = \\mathrm{sat}_{u_{\\max}}(u(t))$ 且 $u_{\\max} = 0.5$。初始条件为 $x_p(0) = 0$ 和 $z(0) = 0$。\n\n我们将去饱和恢复时间 $t_{\\mathrm{rec}}$ 定义为饱和偏差 $|w(t)| = |u(t) - v(t)|$ 超过阈值 $\\varepsilon = 10^{-3}$ 的最后时刻。也就是说，$t_{\\mathrm{rec}}$ 是在仿真时间范围 $[0, T_{\\max}]$ 内使得 $|w(t)| > \\varepsilon$ 的时间 $t$ 的上确界。我们仿真到 $T_{\\max} = 15$ 秒，这对于给定的 $k_{\\mathrm{aw}}$ 范围足以捕捉恢复过程。\n\n测试套件使用三个因子 $f$：\n- 情况 1：$f = 0.5$，所以 $\\omega_{\\mathrm{aw}} = 0.5 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{0.5 \\, \\omega_{\\mathrm{cl}}}{k_i}$，\n- 情况 2：$f = 2$，所以 $\\omega_{\\mathrm{aw}} = 2 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{2 \\, \\omega_{\\mathrm{cl}}}{k_i}$，\n- 情况 3：$f = 10$，所以 $\\omega_{\\mathrm{aw}} = 10 \\, \\omega_{\\mathrm{cl}}$ 且 $k_{\\mathrm{aw}} = \\dfrac{10 \\, \\omega_{\\mathrm{cl}}}{k_i}$。\n\n我们预期更大的 $\\omega_{\\mathrm{aw}}$（即更大的 $k_{\\mathrm{aw}}$）将产生更快的去饱和，因此 $t_{\\mathrm{rec}}$ 更小，但过大的 $k_{\\mathrm{aw}}$ 可能会增加暂态峰值或在饱和极限附近引起抖振。该数值实验通过 $t_{\\mathrm{rec}}$ 来量化恢复过程。\n\n程序的算法步骤：\n- 通过求解 $s^2 + (1 + k_p) s + k_i = 0$ 计算未饱和闭环极点，并将 $\\omega_{\\mathrm{cl}}$ 设置为主导极点实部的绝对值。\n- 对于测试套件中的每个因子 $f$，设置 $\\omega_{\\mathrm{aw}} = f \\, \\omega_{\\mathrm{cl}}$ 和 $k_{\\mathrm{aw}} = \\omega_{\\mathrm{aw}} / k_i$。\n- 在 $[0, T_{\\max}]$ 上仿真带有饱和和反计算抗饱和的闭环微分方程，并计算 $w(t) = u(t) - v(t)$。\n- 将 $t_{\\mathrm{rec}}$ 设置为 $|w(t)| > \\varepsilon$ 的最后时刻（如果从未发生饱和则为零），并四舍五入到三位小数。\n- 将列表 $[t_{\\mathrm{rec}}^{(1)}, t_{\\mathrm{rec}}^{(2)}, t_{\\mathrm{rec}}^{(3)}]$ 作为单行打印，其中上标对应于三种情况。\n\n该过程基于比例积分控制器和饱和执行器的基本动态特性，并利用去饱和跟踪动态的环路整形来选择抗饱和增益。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.polynomial.polynomial import Polynomial\n\ndef closed_loop_dominant_bandwidth(kp: float, ki: float) - float:\n    \"\"\"\n    Compute the unsaturated closed-loop dominant bandwidth as the absolute value\n    of the real part of the slowest pole of s^2 + (1+kp)s + ki = 0.\n    For kp=4, ki=4, poles are -1 and -4, so bandwidth is 1 rad/s.\n    \"\"\"\n    # Characteristic polynomial coefficients: s^2 + (1+kp)s + ki\n    a2 = 1.0\n    a1 = 1.0 + kp\n    a0 = ki\n    roots = np.roots([a2, a1, a0])\n    # Dominant pole: real part closest to zero (largest real part)\n    # For real coefficients, roots should be real here given values.\n    real_parts = np.real(roots)\n    dominant = real_parts[np.argmax(real_parts)]\n    return abs(dominant)\n\ndef simulate_aw_response(kp: float, ki: float, umax: float, r0: float,\n                         k_aw: float, t_final: float = 15.0,\n                         eps: float = 1e-3) - float:\n    \"\"\"\n    Simulate the nonlinear closed loop with saturation and back-calculation AW.\n    Plant: xdot = -x + v, y = x.\n    Controller: u = kp*e + ki*z, zdot = e + k_aw*(v - u), e = r - y.\n    Saturation: v = sat(u, umax).\n    Return desaturation recovery time t_rec = last time where |u - v|  eps,\n    or 0.0 if saturation discrepancy never exceeds eps.\n    \"\"\"\n    def dynamics(t, state):\n        x, z = state\n        y = x\n        e = r0 - y\n        u = kp * e + ki * z\n        v = np.clip(u, -umax, umax)\n        zdot = e + k_aw * (v - u)\n        xdot = -x + v\n        return [xdot, zdot]\n\n    # Time grid for evaluation\n    t_eval = np.linspace(0.0, t_final, 6001)  # 2.5 ms step approx\n    sol = solve_ivp(dynamics, (0.0, t_final), [0.0, 0.0], t_eval=t_eval, rtol=1e-8, atol=1e-10, method='RK45')\n    x = sol.y[0, :]\n    z = sol.y[1, :]\n    y = x\n    e = r0 - y\n    u = kp * e + ki * z\n    v = np.clip(u, -umax, umax)\n    w = u - v\n    mask = np.abs(w)  eps\n    if not np.any(mask):\n        return 0.0\n    # Last time index where saturation discrepancy is above eps\n    last_idx = np.where(mask)[0][-1]\n    t_rec = sol.t[last_idx]\n    return float(t_rec)\n\ndef solve():\n    # Fixed parameters\n    kp = 4.0\n    ki = 4.0\n    umax = 0.5\n    r0 = 2.0\n    t_final = 15.0\n    eps = 1e-3\n\n    # Compute unsaturated closed-loop dominant bandwidth\n    omega_cl = closed_loop_dominant_bandwidth(kp, ki)\n\n    # Test cases: factors f for omega_aw = f * omega_cl\n    test_cases = [0.5, 2.0, 10.0]\n\n    results = []\n    for f in test_cases:\n        omega_aw = f * omega_cl\n        k_aw = omega_aw / ki  # loop-shaping rule derived from u_dot = ki*k_aw (v - u)\n        t_rec = simulate_aw_response(kp, ki, umax, r0, k_aw, t_final=t_final, eps=eps)\n        results.append(round(t_rec, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2690044"}, {"introduction": "在学会如何整定抗饱和补偿器后，一个自然的问题是：它究竟带来了多大的好处？此练习通过一个非常直观的性能指标——系统的吸引域（Region of Attraction, RoA）——来量化抗饱和策略的效果。你将通过数值计算来对比有无抗饱和措施时系统吸引域的大小，从而 firsthand 体验并证明有效的抗饱和设计能如何显著提升非线性系统的稳定性。[@problem_id:2690066]", "problem": "考虑一个带饱和执行器的双积分器对象，以及一个对位置状态增加了积分作用的线性状态反馈控制器。该对象遵循以下状态空间方程\n$$\n\\dot{x}_1 = x_2,\\quad \\dot{x}_2 = u,\n$$\n其中 $x_1 \\in \\mathbb{R}$ 是位置，$x_2 \\in \\mathbb{R}$ 是速度，$u \\in \\mathbb{R}$ 是控制输入。指令控制 $v \\in \\mathbb{R}$ 由一个带积分作用的线性状态反馈生成，\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z,\n$$\n其中 $z \\in \\mathbb{R}$ 是对 $x_1$ 进行积分的控制器积分器状态。执行器根据以下公式对指令控制进行饱和处理\n$$\nu = \\mathrm{sat}(v; u_{\\max}) \\triangleq \\max\\!\\big(-u_{\\max},\\, \\min(v,\\, u_{\\max})\\big),\n$$\n饱和极限为 $u_{\\max} \\gt 0$。不带抗饱和的积分器动态为\n$$\n\\dot{z} = x_1,\n$$\n而带标准线性反算抗饱和增强的积分器动态为\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v),\n$$\n其中 $k_{\\mathrm{aw}} \\ge 0$ 是抗饱和增益。所有量均为无量纲。\n\n对于给定的参数集 $(k_1, k_2, k_I, u_{\\max}, k_{\\mathrm{aw}})$ 以及固定的初始积分器状态 $z(0) = 0$，将 $(x_1, x_2)$ 平面中原点的吸引域 (RoA) 定义为使得闭环轨迹收敛于原点的初始条件 $(x_1(0), x_2(0))$ 的集合。在本问题中，您将计算吸引域的一个已认证内估计，即包含在吸引域中、以原点为中心的最大欧几里得球，该球由其半径 $r^\\star \\ge 0$ 量化：\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}.\n$$\n\n由于对此非线性饱和系统精确解析计算 $r^\\star$ 是困难的，您必须通过仿真闭环系统并对 $r$ 进行二分搜索来数值地估计它。请使用以下基于原则的规范：\n\n1. 使用上述给出的带饱和的完整非线性闭环动态。\n2. 对于一个候选半径 $r \\ge 0$，在 $N$ 个等间隔角度 $\\theta_j = 2\\pi j/N$（其中 $j \\in \\{0,1,\\ldots,N-1\\}$，$x_1(0) = r\\cos(\\theta_j)$，$x_2(0) = r\\sin(\\theta_j)$ 且 $z(0)=0$）处，测试圆 $\\{(x_1(0), x_2(0)) \\; | \\; \\|(x_1(0), x_2(0))\\|_2 = r\\}$ 上的所有初始条件。\n3. 对于每个初始条件，将系统仿真到一个有限时间范围 $T$，如果轨迹进入了以原点为中心、半径为 $\\varepsilon$ 的球内，即存在 $t \\in [0, T]$ 使得 $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$，则宣布收敛。如果圆上的任何初始条件未能在该时间范围内收敛，则候选半径 $r$ 未被认证。\n4. 使用由失败/成功的半径界定的二分搜索，以计算具有所需数值容差的 $r^\\star$ 估计值。您可以按几何级数增加上界，直到检测到失败或达到预设的上限。\n5. 对每个参数集重复计算两次：一次不使用抗饱和（即使用 $\\dot{z} = x_1$），一次使用抗饱和（即使用 $\\dot{z} = x_1 + k_{\\mathrm{aw}}(u-v)$）。将估计的半径分别表示为 $r^\\star_{\\mathrm{no\\_aw}}$ 和 $r^\\star_{\\mathrm{aw}}$，并通过比率 $\\rho$ 来量化因增强而产生的扩张：\n$$\n\\rho \\triangleq \\frac{r^\\star_{\\mathrm{aw}}}{\\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)},\n$$\n其中 $\\delta \\gt 0$ 是一个微小的正则化项，以避免在退化情况下出现除以零的错误。\n\n使用固定步长显式四阶龙格-库塔 (RK4) 数值积分方法，时间步长为 $\\Delta t$，以确保确定性。对所有测试使用以下数值参数：\n- 角度数量 $N = 24$。\n- 时间范围 $T = 12$。\n- 时间步长 $\\Delta t = 0.01$。\n- 收敛半径 $\\varepsilon = 0.02$。\n- 发散警戒：如果 $\\sqrt{x_1(t)^2 + x_2(t)^2}$ 在任何时候超过 $R_{\\mathrm{div}} = 100$，则宣布该初始条件失败。\n- 二分迭代次数 $N_{\\mathrm{bis}} = 12$。\n- 初始上界 $r_{\\mathrm{init}} = 0.1$，如果测试继续成功，则以 2 为因子增长，直至上限 $r_{\\mathrm{cap}} = 5.0$。\n\n测试套件。您的程序必须按给定顺序为以下四个参数集中的每一个计算 $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$：\n- 情况 1：$k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 5.0$。\n- 情况 2：$k_1 = 2.0$, $k_2 = 2.0$, $k_I = 3.0$, $u_{\\max} = 0.2$, $k_{\\mathrm{aw}} = 5.0$。\n- 情况 3：$k_1 = 4.0$, $k_2 = 3.0$, $k_I = 2.0$, $u_{\\max} = 0.5$, $k_{\\mathrm{aw}} = 10.0$。\n- 情况 4：$k_1 = 3.0$, $k_2 = 2.5$, $k_I = 2.0$, $u_{\\max} = 0.3$, $k_{\\mathrm{aw}} = 8.0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每种情况，按顺序 $(r^\\star_{\\mathrm{no\\_aw}}, r^\\star_{\\mathrm{aw}}, \\rho)$ 附加三个浮点数，从而产生一个长度为 12 的扁平列表。例如，输出必须具有以下形式：\n$$\n[\\; r^\\star_{\\mathrm{no\\_aw},1},\\ r^\\star_{\\mathrm{aw},1},\\ \\rho_1,\\ r^\\star_{\\mathrm{no\\_aw},2},\\ r^\\star_{\\mathrm{aw},2},\\ \\rho_2,\\ r^\\star_{\\mathrm{no\\_aw},3},\\ r^\\star_{\\mathrm{aw},3},\\ \\rho_3,\\ r^\\star_{\\mathrm{no\\_aw},4},\\ r^\\star_{\\mathrm{aw},4},\\ \\rho_4 \\;].\n$$\n将每个打印的浮点数四舍五入到 $6$ 位小数。", "solution": "该问题要求对一个带积分作用的饱和状态反馈控制下的双积分器对象，其吸引域进行数值估计。我们将针对两种情况进行此分析：有和没有反算抗饱和方案。目标是量化抗饱和增强所带来的性能提升。\n\n闭环系统动态由一组三个一阶非线性常微分方程描述。设状态向量为 $\\mathbf{y}(t) = [x_1(t), x_2(t), z(t)]^T$，其中 $x_1$ 是位置，$x_2$ 是速度，$z$ 是积分器状态。其状态空间表示为 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$。向量场 $f$ 的分量由以下公式给出：\n$$\n\\dot{x}_1 = x_2\n$$\n$$\n\\dot{x}_2 = u\n$$\n$$\n\\dot{z} = x_1 + k_{\\mathrm{aw}}(u - v)\n$$\n指令控制信号 $v$ 是状态的线性函数：\n$$\nv = -k_1 x_1 - k_2 x_2 - k_I z\n$$\n输入到对象的实际控制信号 $u$ 是指令信号 $v$ 经过执行器饱和处理后的结果，饱和极限为 $u_{\\max}$：\n$$\nu = \\mathrm{sat}(v; u_{\\max}) = \\max(-u_{\\max}, \\min(v, u_{\\max}))\n$$\n不带抗饱和的系统是这些动态的一个特例，其中抗饱和增益 $k_{\\mathrm{aw}}$ 设置为 $0$。\n\n对于这样一个非线性饱和系统，其吸引域（RoA）的解析确定通常是难以处理的。因此，我们采用一种结构化的数值程序来计算吸引域的一个已认证内估计。该指定估计是在 $(x_1, x_2)$ 平面中以原点为中心的最大欧几里得球，从该球出发的所有轨迹都收敛到原点。我们用 $r^\\star$ 表示这个球的半径。其形式化定义是：\n$$\nr^\\star \\triangleq \\sup\\{ r \\ge 0 \\; | \\; \\text{for all } \\theta \\in [0, 2\\pi),\\ \\|(x_1(0), x_2(0))\\|_2=r,\\ z(0)=0 \\Rightarrow \\lim_{t\\to\\infty} \\|(x_1(t), x_2(t))\\|_2 = 0 \\}\n$$\n初始积分器状态固定为 $z(0) = 0$。\n\n估计 $r^\\star$ 的计算方法遵循一个系统的两阶段过程：先划定区间，然后进行二分搜索。\n\n首先，我们定义一个测试程序 `check_radius(r)`，它确定一个给定的候选半径 $r$ 是否被认证。这是通过将 $(x_1, x_2)$ 平面中半径为 $r$ 的圆离散化为 $N=24$ 个初始点 $(x_1(0), x_2(0)) = (r\\cos(\\theta_j), r\\sin(\\theta_j))$（其中 $\\theta_j = 2\\pi j/N$, $j \\in \\{0, \\dots, N-1\\}$）来实现的。对于每个初始条件，系统的轨迹被仿真一个时间范围 $T=12$。仿真是使用显式四阶龙格-库塔 (RK4) 方法以 $\\Delta t=0.01$ 的固定时间步长进行的，以确保确定性结果。如果一条轨迹在 $(x_1, x_2)$ 平面上的投影进入了以原点为中心、半径为 $\\varepsilon=0.02$ 的球内，即对于某个 $t \\in [0, T]$ 有 $\\sqrt{x_1(t)^2 + x_2(t)^2} \\le \\varepsilon$，则该轨迹被宣布为收敛。如果一条轨迹的范数超过了发散警戒值 $R_{\\mathrm{div}}=100$，则它被宣布为不收敛。仅当从其圆周出发的所有 $N$ 条轨迹都收敛时，半径 $r$ 才被认证。\n\n其次，我们采用一种搜索算法来找到上确界 $r^\\star$。\n1.  **区间划定**：我们寻找一个区间 $[r_{\\text{low}}, r_{\\text{high}}]$，使得 `check_radius`($r_{\\text{low}}$) 成功而 `check_radius`($r_{\\text{high}}$) 失败。我们从 $r_{\\text{high}} = r_{\\text{init}} = 0.1$ 开始，并已知在 $r=0$ 时是成功的。如果 $r_{\\text{high}}$ 成功，我们更新 $r_{\\text{low}}$ 为这个新值，并按 2 的因子几何级数增加 $r_{\\text{high}}$，重复此过程直到检测到失败或达到 $r_{\\text{cap}}=5.0$ 的上限。如果测试在 $r_{\\text{cap}}$ 处仍然成功，我们取 $r^\\star = r_{\\text{cap}}$。\n2.  **二分法**：一旦找到一个有效的区间 $[r_{\\text{low}}, r_{\\text{high}}]$，我们执行 $N_{\\mathrm{bis}}=12$ 次二分法迭代来精化 $r^\\star$ 的估计值。在每次迭代中，我们测试中点 $r_{\\text{mid}} = (r_{\\text{low}} + r_{\\text{high}})/2$。如果 $r_{\\text{mid}}$ 被认证，我们更新 $r_{\\text{low}} = r_{\\text{mid}}$；否则，我们更新 $r_{\\text{high}} = r_{\\text{mid}}$。最终结果是 $r_{\\text{low}}$ 的终值。\n\n对每个参数集执行这整个过程，一次在 $k_{\\mathrm{aw}}=0$ 时找到 $r^\\star_{\\mathrm{no\\_aw}}$，另一次在给定的 $k_{\\mathrm{aw}}0$ 时找到 $r^\\star_{\\mathrm{aw}}$。相对改进由比率 $\\rho = r^\\star_{\\mathrm{aw}} / \\max(r^\\star_{\\mathrm{no\\_aw}}, \\delta)$ 衡量，其中 $\\delta=10^{-9}$ 是一个小的正则化项。实现严格遵守所有指定的数值参数。", "answer": "```python\nimport numpy as np\nimport math\n\n# Global numerical parameters\nN_ANGLES = 24\nTIME_HORIZON = 12.0\nDT = 0.01\nCONVERGENCE_RADIUS = 0.02\nDIVERGENCE_GUARD = 100.0\nN_BISECTION = 12\nR_INIT = 0.1\nR_CAP = 5.0\nDELTA_REG = 1e-9\n\ndef system_dynamics(state, params, use_aw):\n    \"\"\"\n    Computes the time derivative of the state vector.\n    state: [x1, x2, z]\n    params: dictionary of controller and plant parameters\n    use_aw: boolean to enable/disable anti-windup\n    \"\"\"\n    x1, x2, z = state\n    k1, k2, kI, u_max, k_aw = params['k1'], params['k2'], params['kI'], params['u_max'], params['k_aw']\n\n    # Commanded control\n    v = -k1 * x1 - k2 * x2 - kI * z\n\n    # Saturated control\n    u = np.clip(v, -u_max, u_max)\n\n    # State derivatives\n    dx1_dt = x2\n    dx2_dt = u\n    \n    if use_aw:\n        dz_dt = x1 + k_aw * (u - v)\n    else:\n        dz_dt = x1\n        \n    return np.array([dx1_dt, dx2_dt, dz_dt])\n\ndef rk4_step(func, state, t, dt, params, use_aw):\n    \"\"\"Performs a single RK4 step.\"\"\"\n    k1 = func(state, params, use_aw)\n    k2 = func(state + dt / 2.0 * k1, params, use_aw)\n    k3 = func(state + dt / 2.0 * k2, params, use_aw)\n    k4 = func(state + dt * k3, params, use_aw)\n    return state + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\ndef simulate_trajectory(x1_0, x2_0, params, use_aw):\n    \"\"\"\n    Simulates a single trajectory to check for convergence.\n    Returns True if converges, False otherwise.\n    \"\"\"\n    state = np.array([x1_0, x2_0, 0.0])\n    num_steps = int(TIME_HORIZON / DT)\n\n    for i in range(num_steps):\n        t = i * DT\n        state = rk4_step(system_dynamics, state, t, DT, params, use_aw)\n        \n        # Check for convergence\n        if math.sqrt(state[0]**2 + state[1]**2) = CONVERGENCE_RADIUS:\n            return True\n            \n        # Check for divergence\n        if math.sqrt(state[0]**2 + state[1]**2)  DIVERGENCE_GUARD:\n            return False\n\n    return False\n\ndef check_radius(r, params, use_aw):\n    \"\"\"\n    Tests if all initial conditions on a circle of radius r converge.\n    Returns True if all converge, False otherwise.\n    \"\"\"\n    if r == 0.0:\n        return True\n    \n    angles = np.linspace(0, 2 * np.pi, N_ANGLES, endpoint=False)\n    for theta in angles:\n        x1_0 = r * math.cos(theta)\n        x2_0 = r * math.sin(theta)\n        \n        if not simulate_trajectory(x1_0, x2_0, params, use_aw):\n            return False\n            \n    return True\n\ndef find_r_star(params, use_aw):\n    \"\"\"\n    Finds the estimated radius of the region of attraction r_star.\n    \"\"\"\n    # Phase 1: Bracket finding\n    r_low = 0.0\n    r_high = R_INIT\n    \n    while True:\n        is_success = check_radius(r_high, params, use_aw)\n        if is_success:\n            r_low = r_high\n            if r_high == R_CAP:\n                return R_CAP  # Succeeded up to the cap\n            r_high = min(r_high * 2, R_CAP)\n        else:\n            break  # Found bracket [r_low, r_high] where low succeeds and high fails\n            \n    # Phase 2: Bisection search\n    for _ in range(N_BISECTION):\n        r_mid = (r_low + r_high) / 2.0\n        if check_radius(r_mid, params, use_aw):\n            r_low = r_mid\n        else:\n            r_high = r_mid\n            \n    return r_low\n\ndef solve():\n    test_cases = [\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.5, 'k_aw': 5.0},\n        {'k1': 2.0, 'k2': 2.0, 'kI': 3.0, 'u_max': 0.2, 'k_aw': 5.0},\n        {'k1': 4.0, 'k2': 3.0, 'kI': 2.0, 'u_max': 0.5, 'k_aw': 10.0},\n        {'k1': 3.0, 'k2': 2.5, 'kI': 2.0, 'u_max': 0.3, 'k_aw': 8.0},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        r_star_no_aw = find_r_star(params, use_aw=False)\n        r_star_aw = find_r_star(params, use_aw=True)\n        \n        rho = r_star_aw / max(r_star_no_aw, DELTA_REG)\n        \n        all_results.extend([r_star_no_aw, r_star_aw, rho])\n\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2690066"}, {"introduction": "饱和问题不仅限于反馈回路，在前馈控制中，尤其是在处理非最小相位（non-minimum phase）系统时，它会引发更隐蔽且严重的“积分饱和”现象。这是因为对非最小相位系统的精确逆模型本身就是不稳定的。此练习将引导你分析这种由不稳定零点反演导致的灾难性失效模式，并设计一种先进的抗饱和策略，该策略能在执行器未饱和时实现完美跟踪，而在饱和发生时切换到稳定的近似逆模型以确保系统内部信号的有界性。[@problem_id:2690016]", "problem": "考虑一个单输入单输出 (SISO) 线性时不变 (LTI) 对象，其传递函数为 $P(s) = \\dfrac{s - z}{s + p}$，其中 $z  0$ 且 $p  0$。执行器存在硬饱和，建模为 $u(t) = \\operatorname{sat}(v(t))$，其中 $\\operatorname{sat}(\\cdot)$ 是对称饱和函数，其界限为 $\\pm u_{\\max}$，即 $\\operatorname{sat}(v) = \\max\\{\\min\\{v, u_{\\max}\\}, -u_{\\max}\\}$。为了改善跟踪性能，引入了一个前馈预滤波器 $F(s)$。标称设计对对象进行求逆，即 $F(s) = P(s)^{-1} = \\dfrac{s + p}{s - z}$，这样在没有饱和的情况下，标称串联系统 $P(s) F(s) = 1$ 可以实现精确跟踪。\n\n第一部分。仅使用传递函数的定义、一阶系统的阶跃响应以及 $P(s)$ 的右半平面零点会成为 $F(s)$ 的右半平面极点这一基本事实，证明即使输出 $y(t)$ 因对象动态和饱和而有界，由不稳定逆 $F(s)$ 生成的内部信号 $v(t)$ 在饱和发生后也可能变得无界。具体来说，设 $r(t) = r_{0} \\mathbf{1}_{\\{t \\ge 0\\}}$ 是一个阶跃参考信号，其中 $r_{0} \\ne 0$，并将 $F(s)$ 实现为以下分解形式\n$$\nF(s) \\;=\\; 1 \\;+\\; \\frac{p + z}{s - z}.\n$$\n假设逆的内部状态初始条件为 $x_{F}(0)=0$，并回想 $\\dfrac{1}{s - z}$ 对单位阶跃的响应包含一个与 $e^{z t}$ 成比例的项。显式推导 $v(t)$，并使用饱和模型论证：\n- 当 $r_{0}$ 与 $(p+z)$ 同号且 $u_{\\max}$ 有限时，存在一个有限时间 $t^{\\star}$，使得 $\\operatorname{sat}(v(t)) \\ne v(t)$，\n- 一旦饱和在某个区间 $[t^{\\star}, \\infty)$ 上激活，$F(s)$ 生成的内部信号 $v(t)$ 会表现出一个 $e^{z t}$分量，该分量不会被对象的输入-输出映射所抵消，因此会无界增长，尽管由有界输入驱动的稳定对象所产生的 $y(t)$ 仍然是有界的。\n\n解释为什么这种现象是由不稳定零点动态求逆驱动的“积分饱和”(windup) 的一个实例，以及为什么它不能通过任何围绕 $P(s)$ 的稳定反馈来消除，只要该反馈不修改承载不稳定逆的路径。\n\n第二部分。考虑以下用于前馈路径的抗饱和设计备选方案。目标有两个：($i$) 当饱和发生时，保证对于任何有界参考信号，内部信号都有界，以及 ($ii$) 每当执行器未饱和时，保持精确求逆 $P(s) F(s) = 1$。选择满足这两个目标的选项，并基于第一性原理证明你的选择。\n\nA. 在前馈路径中，在精确逆和带有无扰切换及滞后的稳定近似逆之间切换：定义\n$$\nF_{\\text{exact}}(s) = \\frac{s + p}{s - z}, \\qquad F_{\\text{stab}}(s) = \\frac{s + p}{s + z} = 1 + \\frac{p - z}{s + z}.\n$$\n使用以下逻辑\n$$\nF_{\\sigma}(s) \\;=\\; \\begin{cases}\nF_{\\text{exact}}(s),  \\text{if } |v(t)| \\le u_{\\max} - \\delta, \\\\\nF_{\\text{stab}}(s),  \\text{if } |v(t)| \\ge u_{\\max},\n\\end{cases}\n$$\n其中滞后带宽为 $\\delta \\in (0, u_{\\max})$，并在切换时刻 $t_{s}$ 重置状态，以使 $v(t)$ 连续，即，设置新启用的实现的状态以匹配当前输出 $v(t_{s}^{-})$。论证在饱和模式下，内部极点位于 $-z  0$，确保内部信号有界；在非饱和模式下，恢复了精确求逆。\n\nB. 保持 $F(s) = \\dfrac{s + p}{s - z}$ 不变，但用一个高增益静态反馈稳定器 $u(t) = \\operatorname{sat}(v(t)) - k\\,y(t)$（其中 $k \\gg 1$）来包裹对象 $P(s)$。声称高增益将主导饱和非线性，并防止 $F(s)$ 内部状态的积分饱和。\n\nC. 通过一个饱和预滤波器 $r_{\\text{sat}}(t) = \\operatorname{sat}_{r}(r(t))$ 对参考信号进行预缩放，使得 $|r_{\\text{sat}}(t)| \\le r_{\\max}$，其中 $r_{\\max}$ 的选择是为了避免在稳态下执行器饱和，并保持 $F(s) = \\dfrac{s + p}{s - z}$ 不变。论证限制参考信号足以防止前馈逆中的积分饱和。\n\nD. 在 $F(s)$ 之后放置一个严格真分低通滤波器 $L(s) = \\dfrac{\\omega_{c}}{s + \\omega_{c}}$，以限制 $v(t)$ 的高频成分，即，使用由 $L(s) F(s) r(t)$ 生成的 $v(t)$，而不修改 $F(s)$ 在 $s=z$ 处的不稳定极点。声称带宽限制足以在存在饱和的情况下防止积分饱和。\n\n选择满足目标 ($i$) 和 ($ii$) 的唯一最佳选项。", "solution": "问题陈述已经过验证，被认为是合理的。这是一个控制理论中定义良好的问题，它解决了由于执行器饱和导致的非最小相位系统中的积分饱和问题。\n\n**第一部分：积分饱和的演示**\n\n该系统包含一个带有右半平面 (RHP) 零点的稳定对象，$P(s) = \\dfrac{s - z}{s + p}$，其中 $z  0$ 且 $p  0$。为了实现完美跟踪，设计了一个前馈预滤波器 $F(s)$ 作为对象的逆，$F(s) = P(s)^{-1} = \\dfrac{s + p}{s - z}$。由于在 $s = z$ 处有一个极点，该预滤波器是不稳定的。\n\n我们被要求分析对于阶跃参考输入 $r(t) = r_{0} \\mathbf{1}_{\\{t \\ge 0\\}}$（其中 $r_{0} \\ne 0$），预滤波器输出 $v(t)$ 的行为。参考信号的拉普拉斯变换是 $R(s) = \\dfrac{r_{0}}{s}$。在考虑任何饱和之前，预滤波器的输出由 $V(s) = F(s)R(s)$ 给出。\n\n使用所提供的分解 $F(s) = 1 + \\dfrac{p + z}{s - z}$，我们有：\n$$V(s) = \\left(1 + \\frac{p + z}{s - z}\\right) \\frac{r_{0}}{s} = \\frac{r_{0}}{s} + \\frac{r_{0}(p + z)}{s(s - z)}$$\n我们对第二项进行部分分式展开：\n$$\\frac{1}{s(s - z)} = \\frac{A}{s} + \\frac{B}{s - z}$$\n其中 $A = \\left.\\frac{1}{s - z}\\right|_{s=0} = -\\frac{1}{z}$ 且 $B = \\left.\\frac{1}{s}\\right|_{s=z} = \\frac{1}{z}$。\n因此，\n$$V(s) = \\frac{r_{0}}{s} + r_{0}(p + z) \\left(-\\frac{1}{zs} + \\frac{1}{z(s - z)}\\right) = \\left(r_{0} - \\frac{r_{0}(p + z)}{z}\\right)\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z}$$\n$$V(s) = r_{0}\\left(\\frac{z - p - z}{z}\\right)\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z} = -\\frac{r_{0}p}{z}\\frac{1}{s} + \\frac{r_{0}(p + z)}{z}\\frac{1}{s - z}$$\n进行拉普拉斯反变换，我们得到 $t \\ge 0$ 时的时域信号 $v(t)$，假设系统从静止状态启动 ($x_{F}(0)=0$):\n$$v(t) = -\\frac{r_{0}p}{z} + \\frac{r_{0}(p + z)}{z} e^{zt} = \\frac{r_{0}}{z} \\left( (p+z)e^{zt} - p \\right)$$\n\n1.  **存在饱和时间 $t^{\\star}$**：给定 $p  0$ 和 $z  0$，这意味着 $p+z  0$。我们假设 $r_{0}$ 与 $p+z$ 同号，所以我们取 $r_{0}  0$。$v(t)$ 的表达式显示了一个指数增长项 $e^{zt}$，因为 $z  0$。在 $t=0$ 时，$v(0) = \\frac{r_{0}}{z}(p+z-p) = r_{0}$。由于 $v(t)$ 单调无界增长，对于任何有限的饱和限制 $u_{\\max}  0$，$v(t)$ 最终将超过 $u_{\\max}$。如果 $r_{0} \\ge u_{\\max}$，饱和在 $t^{\\star}=0$ 时立即发生。如果 $r_{0}  u_{\\max}$，饱和时间 $t^{\\star}$ 通过求解 $v(t^{\\star}) = u_{\\max}$ 得到：\n    $$\\frac{r_{0}}{z} \\left( (p+z)e^{zt^{\\star}} - p \\right) = u_{\\max} \\implies e^{zt^{\\star}} = \\frac{1}{p+z}\\left(\\frac{zu_{\\max}}{r_{0}} + p\\right)$$\n    由于 $u_{\\max} > r_{0}$（或至少大于0），对数的参数大于 0，从而为 $t^{\\star}$ 产生一个有限的正解。因此，可以保证在有限时间 $t^{\\star}$ 发生饱和。\n\n2.  **$v(t)$ 在饱和后的无界性**：对于 $t \\ge t^{\\star}$，执行器饱和。假设 $r_{0}  0$，对象输入变为常数：$u(t) = u_{\\max}$。对象传递函数 $P(s)$ 是稳定的（极点在 $s=-p  0$）。一个由有界输入（此处为常数 $u_{\\max}$）驱动的稳定 LTI 系统会产生有界输出。输出 $y(t)$ 将收敛到稳态值 $y_{ss} = P(0)u_{\\max} = -\\frac{z}{p}u_{\\max}$。因此，$y(t)$ 保持有界。\n\n    然而，信号 $v(t)$ 是由作用于 $r(t)$ 的预滤波器 $F(s)$ 生成的。这个过程独立于对象的饱和和输出。表达式 $v(t) = \\frac{r_{0}}{z} \\left( (p+z)e^{zt} - p \\right)$ 对所有 $t \\ge 0$ 均有效。由于 $z0$ 的 $e^{zt}$ 项，$v(t) \\to \\infty$ 当 $t \\to \\infty$。\n\n    这种现象被称为“积分饱和”(windup)。控制器（此处为预滤波器 $F(s)$）的内部状态无界增长，因为一旦信号路径因饱和而中断，其不稳定动态就不再被对象的零点所“掩盖”。指令信号 $v(t)$ 和实际对象输入 $u(t)$ 之间的差异不断增长，表明失去了控制。\n\n3.  **标准反馈的不足**：任何标准的反馈回路，例如产生一个指令 $v_{cmd} = v_{ff} + v_{fb} = F(s)r - C(s)y$ 的回路，本身并不能解决这个问题。只要前馈分量 $v_{ff} = F(s)r$ 是由不稳定的逆产生的，并且是被饱和信号的一部分，那么当饱和发生时，它的内部状态就会发生积分饱和。反馈可以稳定对象，但它无法“触及”独立的开环前馈模块 $F(s)$ 的“内部”来稳定其内部状态。为了防止这种积分饱和，抗饱和方案必须明确地修改 $F(s)$ 的动态特性或为其状态提供一个校正信号，这正是“抗饱和”技术的设计目的。\n\n**第二部分：抗饱和备选方案评估**\n\n目标是 ($i$) 饱和期间内部信号有界，以及 ($ii$) 未饱和时精确求逆。\n\n**A. 在精确逆和稳定近似逆之间切换：**\n该策略建议当 $|v(t)|$ 安全地低于 $u_{\\max}$ 时使用 $F_{\\text{exact}}(s) = \\frac{s+p}{s-z}$，当饱和激活或即将发生时切换到稳定的近似 $F_{\\text{stab}}(s) = \\frac{s+p}{s+z}$。\n-   **目标 (ii) - 非饱和模式：** 当 $|v(t)| \\le u_{\\max} - \\delta$ 时，滤波器为 $F_{\\text{exact}}(s)$。与对象的级联为 $P(s)F_{\\text{exact}}(s) = \\frac{s-z}{s+p}\\frac{s+p}{s-z} = 1$。这提供了精确求逆。目标 (ii) 得以满足。\n-   **目标 (i) - 饱和模式：** 当 $|v(t)| \\ge u_{\\max}$ 时，滤波器切换到 $F_{\\text{stab}}(s) = \\frac{s+p}{s+z}$。该传递函数在 $s=-z$ 处有极点（因为 $z0$，这是一个稳定极点），因此是稳定的。对于任何有界参考信号 $r(t)$，这个稳定滤波器的输出及其所有内部状态都将保持有界。无扰切换机制确保了平滑的过渡。因此，可以保证内部信号有界。目标 (i) 得以满足。\n该备选方案满足两个目标。\n**结论：正确。**\n\n**B. 围绕对象的高增益反馈：**\n此选项建议增加反馈 $u(t) = \\operatorname{sat}(v(t)) - k y(t)$，同时保持预滤波器 $F(s) = \\frac{s+p}{s-z}$ 不变，其中 $v(t)$ 由 $F(s)$ 从 $r(t)$ 生成。\n信号 $v(t)$ 的合成独立于反馈回路。如第一部分所示，$v(t)$ 包含一个 $e^{zt}$ 项并无界增长。所提出的反馈作用于对象输入 $u(t)$，位于 $v(t)$ 的生成和饱和模块的下游。它没有任何机制可以影响滤波器 $F(s)$ 的内部状态。因此，$F(s)$ 的内部状态无论反馈作用如何都会发生积分饱和。声称这能防止 $F(s)$ 内部状态的积分饱和是错误的。\n-   **目标 (i) - 有界性：** 失败，因为 $F(s)$ 的状态未被稳定。\n-   **目标 (ii) - 精确求逆：** 在非饱和情况下，$u(t) = v(t) - k y(t)$。从 $v$ 到 $y$ 的闭环响应是 $Y(s) = \\frac{P(s)}{1+kP(s)}V(s)$。从 $r$ 到 $y$ 的总响应为 $Y(s) = \\frac{P(s)F(s)}{1+kP(s)}R(s) = \\frac{1}{1+kP(s)}R(s)$，这不等于 $R(s)$。未实现精确求逆。\n该备选方案两个目标都未达成。\n**结论：不正确。**\n\n**C. 对参考信号进行预缩放：**\n该选项建议基于稳态分析限制参考信号 $r_{\\text{sat}}(t)$ 的幅度。对于阶跃输入 $\\hat{r}_0$，$v(t)$ 的稳态值为 $v_{ss} = F(0)\\hat{r}_0 = \\frac{p}{-z}\\hat{r}_0$。限制 $r(t)$ 可以使 $|v_{ss}|  u_{\\max}$。然而，这忽略了暂态行为。$v(t)$ 的暂态响应是 $v(t) = \\frac{\\hat{r}_0}{z} \\left( (p+z)e^{zt} - p \\right)$。由于在 $s=z$ 处的不稳定极点，该信号仍然呈指数增长。在暂态阶段，它将不可避免地超过任何有限的饱和极限 $u_{\\max}$，从而引发饱和和积分饱和。限制参考信号的幅度不足以防止由不稳定动态引起的积分饱和。\n-   **目标 (i) - 有界性：** 失败，因为暂态将是无界的。\n**结论：不正确。**\n\n**D. 对预滤波器输出进行低通滤波：**\n这提出了一个新的预滤波器 $F_{new}(s) = L(s)F(s) = \\frac{\\omega_c}{s+\\omega_c}\\frac{s+p}{s-z}$。这个新滤波器仍然具有来自 $F(s)$ 的位于 $s=z$ 的不稳定极点。一个稳定滤波器和一个不稳定滤波器的串联是不稳定的。对于有界输入 $r(t)$，该滤波器的输出 $v(t)$ 将由于 $e^{zt}$ 模式而仍然无界。仅靠带宽限制并不能消除不稳定性。\n-   **目标 (i) - 有界性：** 失败，因为滤波器仍然不稳定。\n此外，非饱和状态下的串联响应为 $P(s)F_{new}(s) = P(s)L(s)F(s) = 1 \\cdot L(s) = \\frac{\\omega_c}{s+\\omega_c} \\ne 1$。\n-   **目标 (ii) - 精确求逆：** 失败，因为失去了完美跟踪。\n该备选方案两个目标都未达成。\n**结论：不正确。**\n\n基于以上分析，只有选项 A 提供了一个正确且完整的解决方案，满足了所有指定的目标。它正确地诊断了问题的根源——逆的不稳定极点——并通过在饱和期间切换到一个稳定的滤波器来纠正它，同时在线性区域保留了期望的性能。", "answer": "$$\\boxed{A}$$", "id": "2690016"}]}