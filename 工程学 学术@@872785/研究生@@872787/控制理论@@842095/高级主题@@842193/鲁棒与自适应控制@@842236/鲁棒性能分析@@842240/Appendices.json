{"hands_on_practices": [{"introduction": "鲁棒控制的理论基石之一是小增益定理，它是保证系统在存在不确定性时维持稳定的强大工具。本练习旨在引导您回归基本原理，从 $H_{\\infty}$ 范数的定义出发，推导鲁棒性能的频域测试条件。通过完成这个基础性问题，您将巩固对抽象的范数如何转化为具体、实用的稳定性检验标准的理解。", "problem": "一个线性时不变 (LTI) 反馈回路用一个非结构化、范数有界的不确定性进行建模，该不确定性由一个频率相关的加权函数进行缩放。设不确定性加权函数为稳定的真传递函数 $W_{\\Delta}(s)$，并且不确定性所见的闭环互补输入输出映射为稳定的传递函数 $M(s)$。在小增益范式下，鲁棒性能要求是乘积 $W_{\\Delta} M$ 的哈代空间无穷范数（H-infinity (H$\\infty$) 范数）满足 $\\|W_{\\Delta} M\\|_{\\infty} \\le 1$。\n\n仅从稳定 LTI 系统的 H$\\infty$ 范数的诱导 $\\mathcal{L}_{2}$-到-$\\mathcal{L}_{2}$ 范数定义出发，\n$$\n\\|G\\|_{\\infty} \\triangleq \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big),\n$$\n其中 $\\bar{\\sigma}(\\cdot)$ 表示最大奇异值，推导一个关于 $\\omega$ 的逐频率不等式，该不等式是 $\\|W_{\\Delta} M\\|_{\\infty} \\le 1$ 的充分必要条件。将您的推导具体化到单输入单输出 (SISO) 情况。\n\n然后，对于具有以下特定传递函数的 SISO 情况：\n$$\nW_{\\Delta}(s) = \\frac{s + 1}{s + 2}, \\qquad M(s) = \\frac{0.8}{s + 1},\n$$\n精确计算 $\\|W_{\\Delta} M\\|_{\\infty}$ 的值。您的最终答案必须是一个以精确形式写出的实数。不要包含单位。不要四舍五入；给出精确值。", "solution": "所述问题提法恰当，科学上基于鲁棒控制理论的既定原则，并包含足够的信息以得到唯一且有意义的解。因此，该问题被认为是有效的。\n\n任务是首先推导鲁棒性能的频域条件，然后将其应用于一个具体案例。鲁棒性能准则由 $\\|W_{\\Delta} M\\|_{\\infty} \\le 1$ 给出，其中对于一个稳定的线性时不变 (LTI) 系统 $G(s)$，$\\mathcal{H}_{\\infty}$ 范数由其诱导 $\\mathcal{L}_{2}$-到-$\\mathcal{L}_{2}$ 增益定义为\n$$\n\\|G\\|_{\\infty} \\triangleq \\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big)\n$$\n这里，$\\bar{\\sigma}(\\cdot)$ 表示矩阵的最大奇异值，而 $G(\\mathrm{j}\\omega)$ 是系统 $G(s)$ 在 $s = \\mathrm{j}\\omega$ 处的频率响应。\n\n令 $G(s) = W_{\\Delta}(s) M(s)$。条件是 $\\|G\\|_{\\infty} \\le 1$。代入范数的定义，我们得到：\n$$\n\\sup_{\\omega \\in \\mathbb{R}} \\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) \\le 1\n$$\n一组非负实数（在本例中为 $\\{\\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) \\mid \\omega \\in \\mathbb{R}\\}$）的上确界小于或等于 $1$ 的充分必要条件是该集合中的每个元素都小于或等于 $1$。这为一般多输入多输出 (MIMO) 情况提供了充分必要的逐频率条件：\n$$\n\\bar{\\sigma}\\big(W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)\\big) \\le 1 \\quad \\text{for all } \\omega \\in \\mathbb{R}\n$$\n\n接下来，我们将此结果具体化到单输入单输出 (SISO) 情况。对于 SISO 系统，传递函数是标量函数。在特定频率 $s = \\mathrm{j}\\omega$ 处进行求值时，频率响应 $G(\\mathrm{j}\\omega)$ 是一个复数。一个复数可以看作一个 $1 \\times 1$ 的矩阵。一个 $1 \\times 1$ 矩阵 $[c]$ 的最大奇异值就是复数 $c$ 的模。即 $\\bar{\\sigma}([c]) = |c|$。\n因此，对于 SISO 系统 $G(s)$，其频率响应的最大奇异值就是频率响应的模：\n$$\n\\bar{\\sigma}\\big(G(\\mathrm{j}\\omega)\\big) = |G(\\mathrm{j}\\omega)|\n$$\n对于一个稳定的 SISO 系统，$\\mathcal{H}_{\\infty}$ 范数简化为其频率响应的峰值模：\n$$\n\\|G\\|_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(\\mathrm{j}\\omega)|\n$$\n将此应用于鲁棒性能条件 $\\|W_{\\Delta} M\\|_{\\infty} \\le 1$，我们得到：\n$$\n\\sup_{\\omega \\in \\mathbb{R}} |W_{\\Delta}(\\mathrm{j}\\omega) M(\\mathrm{j}\\omega)| \\le 1\n$$\n利用复数模的性质 $|z_1 z_2| = |z_1| |z_2|$，这等价于：\n$$\n\\sup_{\\omega \\in \\mathbb{R}} \\left( |W_{\\Delta}(\\mathrm{j}\\omega)| \\cdot |M(\\mathrm{j}\\omega)| \\right) \\le 1\n$$\nSISO 情况下对应的充分必要的逐频率不等式是：\n$$\n|W_{\\Delta}(\\mathrm{j}\\omega)| \\cdot |M(\\mathrm{j}\\omega)| \\le 1 \\quad \\text{for all } \\omega \\in \\mathbb{R}\n$$\n这完成了问题的推导部分。\n\n最后，我们必须为特定的 SISO 传递函数计算 $\\|W_{\\Delta} M\\|_{\\infty}$ 的精确值：\n$$\nW_{\\Delta}(s) = \\frac{s + 1}{s + 2}, \\qquad M(s) = \\frac{0.8}{s + 1}\n$$\n首先，我们构成乘积传递函数 $G(s) = W_{\\Delta}(s) M(s)$：\n$$\nG(s) = \\left(\\frac{s + 1}{s + 2}\\right) \\left(\\frac{0.8}{s + 1}\\right)\n$$\n在 $s = -1$ 处发生零极点对消。由于两个原始传递函数都是稳定的，这种对消是允许的，并且得到的传递函数准确地描述了整个系统的输入输出频率响应。\n$$\nG(s) = \\frac{0.8}{s + 2}\n$$\n该系统是稳定的，因为其唯一的极点位于复平面的左半平面 $s = -2$ 处。我们现在计算其 $\\mathcal{H}_{\\infty}$ 范数：\n$$\n\\|G\\|_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(\\mathrm{j}\\omega)|\n$$\n我们计算频率响应 $G(\\mathrm{j}\\omega)$：\n$$\nG(\\mathrm{j}\\omega) = \\frac{0.8}{\\mathrm{j}\\omega + 2}\n$$\n频率响应的模是 $\\omega$ 的函数：\n$$\n|G(\\mathrm{j}\\omega)| = \\left|\\frac{0.8}{2 + \\mathrm{j}\\omega}\\right| = \\frac{|0.8|}{|2 + \\mathrm{j}\\omega|} = \\frac{0.8}{\\sqrt{2^2 + \\omega^2}} = \\frac{0.8}{\\sqrt{4 + \\omega^2}}\n$$\n为了找到该表达式在 $\\omega \\in \\mathbb{R}$ 上的上确界，我们必须找到其最大值。分子是一个正常数 $0.8$。当分母 $\\sqrt{4 + \\omega^2}$ 最小时，函数值最大。项 $\\omega^2$ 始终为非负，即 $\\omega^2 \\ge 0$。$4 + \\omega^2$ 的最小值在 $\\omega^2$ 取其最小值 $0$ 时出现。这发生在频率 $\\omega = 0$ 处。\n因此，分母的最小值为 $\\sqrt{4 + 0^2} = \\sqrt{4} = 2$。\n因此，模的最大值，即 $\\mathcal{H}_{\\infty}$ 范数，为：\n$$\n\\|W_{\\Delta} M\\|_{\\infty} = |G(\\mathrm{j}0)| = \\frac{0.8}{\\sqrt{4 + 0^2}} = \\frac{0.8}{2} = 0.4\n$$\n这就是范数的精确值。", "answer": "$$\n\\boxed{0.4}\n$$", "id": "2741697"}, {"introduction": "尽管标准的小增益定理非常有用，但当不确定性具有已知结构（例如不同通道中的独立扰动）时，其结论可能过于保守。这正是结构奇异值（$\\mu$）发挥关键作用的场合。本练习要求您通过编程计算，对比非结构化小增益测试与更精确的 $\\mu$ 测试，从而生动地展示利用不确定性结构如何获得更不保守、更准确的鲁棒性分析结果。", "problem": "考虑一个双输入、双输出线性时不变（LTI）互联系统的定频鲁棒性能/稳定性检验，该系统由一个复矩阵 $M \\in \\mathbb{C}^{2 \\times 2}$ 和一个不确定性模块 $\\Delta = \\mathrm{diag}(\\delta_1,\\delta_2)$ 描述，其中每个 $\\delta_i \\in \\mathbb{C}$ 是满足 $\\lvert \\delta_i \\rvert \\le 1$ 的标量。两个经典的分析测试如下。\n\n1. 非结构化小增益测试：该测试用一个具有谱范数界限的单一满块代替结构化不确定性，并在诱导2-范数（最大奇异值）满足 $\\lVert M \\rVert_2  1$ 时证明鲁棒性。\n2. 结构化奇异值（Structured Singular Value (SSV)，也称为 $\\mu$）测试：对于具有标量复数块的对角结构 $\\Delta = \\mathrm{diag}(\\delta_1,\\delta_2)$，在 $M$ 处的结构化奇异值定义为\n$$\n\\mu_{\\Delta}(M) \\triangleq \\frac{1}{\\min \\left\\{ \\lVert \\Delta \\rVert_2 \\; \\middle| \\; \\Delta=\\mathrm{diag}(\\delta_1,\\delta_2),\\ \\lvert \\delta_i \\rvert \\le \\lVert \\Delta \\rVert_2,\\ \\det(I - M \\Delta)=0 \\right\\}}.\n$$\n如果 $\\mu_{\\Delta}(M)  1$，则证明了鲁棒性能/稳定性。\n\n仅从上述定义出发（即，不假设任何现成的 $\\mu$ 公式），您需要设计一个程序，对于给定的一组矩阵 $M$，计算：\n- 非结构化小增益决策：判断 $\\lVert M \\rVert_2  1$ 是否成立。\n- 结构化决策：判断对于对角标量不确定性，$\\mu_{\\Delta}(M)  1$ 是否成立。\n\n您的程序必须遵循第一性原理和逻辑，且能够在有限精度算术中实现。特别地，对于结构化决策，需从奇异性条件 $\\det(I - M \\Delta)=0$ 和 $\\delta_i$ 的标量幅值界限进行推导。您可以使用任何从这些定义中导出的等效计算表征，前提是它能清楚地从奇异性条件和结构 $\\Delta=\\mathrm{diag}(\\delta_1,\\delta_2)$ 中得到。\n\n测试套件：\n使用以下四个定频测试矩阵，每个大小均为 $2 \\times 2$：\n- 测试 1 (理想情况): $M_1 = \\begin{bmatrix} 0  0.5 \\\\ 0.5  0 \\end{bmatrix}$。\n- 测试 2 (保守性演示): $M_2 = \\begin{bmatrix} 0  1.2 \\\\ 0.8  0 \\end{bmatrix}$。\n- 测试 3 (边界情况): $M_3 = \\begin{bmatrix} 0  1.25 \\\\ 0.8  0 \\end{bmatrix}$。\n- 测试 4 (强失效情况): $M_4 = \\begin{bmatrix} 0  1.5 \\\\ 1.2  0 \\end{bmatrix}$。\n\n要求：\n- 对于每个测试矩阵 $M_k$，按 $[\\text{small\\_gain\\_passes}, \\text{structured\\_}\\mu\\text{\\_passes}]$ 的顺序返回一对编码为整数 $\\{0,1\\}$ 的布尔值。当且仅当相应的严格不等式成立时，测试才算“通过”，即小增益测试的 $\\lVert M \\rVert_2  1$ 和结构化测试的 $\\mu_{\\Delta}(M)  1$。\n- 角度单位（如适用）必须是弧度。\n- 最终输出必须是单行，包含按顺序排列的四个布尔对，聚合为单一 Python 风格的列表之列表，例如： \"[[a,b],[c,d],[e,f],[g,h]]\"。\n\n您的程序必须是完整且可按如下规定运行的，并且必须以所述格式准确地生成一行输出。", "solution": "所述问题是有效的。它在科学上基于鲁棒控制理论的原理，特别是小增益和结构化奇异值（$\\mu$）分析。该问题是适定的，提供了所有必要的定义、数据和约束，以得出一个唯一的、可验证的解。其语言客观且数学上精确。\n\n任务是针对一组给定的矩阵 $M \\in \\mathbb{C}^{2 \\times 2}$ 和一个结构化不确定性模块 $ \\Delta = \\mathrm{diag}(\\delta_1, \\delta_2) $ 执行两种不同的鲁棒性检验。这两种检验是非结构化小增益测试和结构化奇异值（$\\mu$）测试。\n\n首先，我们分析非结构化小增益测试。该测试为鲁棒稳定性提供了一个充分条件。条件是矩阵 $M$ 的诱导 $2$-范数，即其最大奇异值 $\\sigma_{\\max}(M)$，必须严格小于 $1$。\n$$\n\\lVert M \\rVert_2 = \\sigma_{\\max}(M)  1\n$$\n对于每个测试矩阵 $M_k$，我们将计算其奇异值。 $M_k$ 的奇异值是半正定矩阵 $M_k^* M_k$ （由于给定矩阵是实数，也可写作 $M_k^T M_k$）的特征值的平方根。如果最大奇异值小于 $1$，则测试通过，我们赋值为 $1$。否则，测试失败，我们赋值为 $0$。\n\n其次，我们分析结构化奇异值（$\\mu$）测试。对于给定的不确定性结构，这为鲁棒稳定性提供了一个充要条件。条件是 $\\mu_{\\Delta}(M)  1$。我们必须按要求从第一性原理推导出一个计算过程。条件 $\\mu_{\\Delta}(M)  1$ 等价于：对于所有满足 $\\lVert \\Delta \\rVert_2 \\le 1$ 的扰动 $\\Delta = \\mathrm{diag}(\\delta_1, \\delta_2)$，矩阵 $I - M\\Delta$ 都是非奇异的。由于对于这种对角结构，$\\lVert \\Delta \\rVert_2 = \\max (|\\delta_1|, |\\delta_2|)$，这意味着对于所有满足 $|\\delta_1| \\le 1$ 和 $|\\delta_2| \\le 1$ 的 $\\delta_1, \\delta_2 \\in \\mathbb{C}$，我们必须有 $\\det(I - M\\Delta) \\neq 0$。\n\n我们分析奇异性条件 $\\det(I - M\\Delta) = 0$。设 $M = \\begin{bmatrix} m_{11}  m_{12} \\\\ m_{21}  m_{22} \\end{bmatrix}$。\n$$\n\\det(I - M\\Delta) = \\det \\left( \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - \\begin{bmatrix} m_{11}  m_{12} \\\\ m_{21}  m_{22} \\end{bmatrix} \\begin{bmatrix} \\delta_1  0 \\\\ 0  \\delta_2 \\end{bmatrix} \\right) = \\det \\begin{bmatrix} 1 - m_{11}\\delta_1  -m_{12}\\delta_2 \\\\ -m_{21}\\delta_1  1 - m_{22}\\delta_2 \\end{bmatrix}\n$$\n行列式为 $(1 - m_{11}\\delta_1)(1 - m_{22}\\delta_2) - m_{12}m_{21}\\delta_1\\delta_2 = 0$。展开后得到：\n$$\n1 - m_{11}\\delta_1 - m_{22}\\delta_2 + (m_{11}m_{22} - m_{12}m_{21})\\delta_1\\delta_2 = 0\n$$\n$$\n1 - m_{11}\\delta_1 - m_{22}\\delta_2 + \\det(M) \\delta_1\\delta_2 = 0\n$$\n所有提供的测试矩阵都具有形式 $M_k = \\begin{bmatrix} 0  m_{12}^{(k)} \\\\ m_{21}^{(k)}  0 \\end{bmatrix}$。对于这种结构，有 $m_{11} = 0$，$m_{22} = 0$，以及 $\\det(M) = -m_{12}m_{21}$。特征方程显著简化为：\n$$\n1 - m_{12}m_{21}\\delta_1\\delta_2 = 0 \\quad \\implies \\quad \\delta_1\\delta_2 = \\frac{1}{m_{12}m_{21}}\n$$\n$\\mu_{\\Delta}(M)$ 的值由其定义给出：\n$$\n\\mu_{\\Delta}(M) = \\frac{1}{\\min \\left\\{ \\lVert \\Delta \\rVert_2 \\; \\middle| \\; \\det(I - M \\Delta)=0 \\right\\}}\n$$\n利用我们简化的条件和 $\\lVert \\Delta \\rVert_2 = \\max(|\\delta_1|, |\\delta_2|)$，我们需要在约束条件 $\\delta_1\\delta_2 = 1/(m_{12}m_{21})$ 下，找到 $\\max(|\\delta_1|, |\\delta_2|)$ 的最小值。设 $r_1 = |\\delta_1|$ 和 $r_2 = |\\delta_2|$。对幅值的约束变为 $r_1 r_2 = |1/(m_{12}m_{21})|$。我们想要在 $r_1 r_2 = C$（其中 $C$ 是一个正常数）的约束下最小化 $\\max(r_1, r_2)$。当 $r_1 = r_2 = \\sqrt{C}$ 时，该最小值出现。\n因此，$\\max(|\\delta_1|, |\\delta_2|)$ 的最小值为 $\\sqrt{|1/(m_{12}m_{21})|} = 1/\\sqrt{|m_{12}m_{21}|}$。这就是 $\\mu_{\\Delta}(M)^{-1}$ 的值。\n$$\n\\mu_{\\Delta}(M)^{-1} = \\frac{1}{\\sqrt{|m_{12}m_{21}|}} \\quad \\implies \\quad \\mu_{\\Delta}(M) = \\sqrt{|m_{12}m_{21}|}\n$$\n因此，结构化测试条件 $\\mu_{\\Delta}(M)  1$ 等价于 $\\sqrt{|m_{12}m_{21}|}  1$，或简写为 $|m_{12}m_{21}|  1$。当且仅当此严格不等式成立时，测试通过。\n\n我们现在将这两个测试应用于每个矩阵。\n\n测试 1：$M_1 = \\begin{bmatrix} 0  0.5 \\\\ 0.5  0 \\end{bmatrix}$。\n- 非结构化测试：$M_1$ 的奇异值为 $0.5$ 和 $0.5$。最大值为 $\\lVert M_1 \\rVert_2 = 0.5$。因为 $0.5  1$，测试通过（结果：$1$）。\n- 结构化测试：我们计算 $|m_{12}m_{21}| = |0.5 \\times 0.5| = 0.25$。因为 $0.25  1$，测试通过（结果：$1$）。\n- 结果对：$(1, 1)$。\n\n测试 2：$M_2 = \\begin{bmatrix} 0  1.2 \\\\ 0.8  0 \\end{bmatrix}$。\n- 非结构化测试：$M_2$ 的奇异值为 $1.2$ 和 $0.8$。最大值为 $\\lVert M_2 \\rVert_2 = 1.2$。因为 $1.2 \\not 1$，测试失败（结果：$0$）。\n- 结构化测试：我们计算 $|m_{12}m_{21}| = |1.2 \\times 0.8| = 0.96$。因为 $0.96  1$，测试通过（结果：$1$）。\n- 结果对：$(0, 1)$。这证明了非结构化小增益测试的保守性。\n\n测试 3：$M_3 = \\begin{bmatrix} 0  1.25 \\\\ 0.8  0 \\end{bmatrix}$。\n- 非结构化测试：$M_3$ 的奇异值为 $1.25$ 和 $0.8$。最大值为 $\\lVert M_3 \\rVert_2 = 1.25$。因为 $1.25 \\not 1$，测试失败（结果：$0$）。\n- 结构化测试：我们计算 $|m_{12}m_{21}| = |1.25 \\times 0.8| = 1.0$。因为 $1.0 \\not 1$，测试失败（结果：$0$）。\n- 结果对：$(0, 0)$。这是结构化测试的一个边界情况。\n\n测试 4：$M_4 = \\begin{bmatrix} 0  1.5 \\\\ 1.2  0 \\end{bmatrix}$。\n- 非结构化测试：$M_4$ 的奇异值为 $1.5$ 和 $1.2$。最大值为 $\\lVert M_4 \\rVert_2 = 1.5$。因为 $1.5 \\not 1$，测试失败（结果：$0$）。\n- 结构化测试：我们计算 $|m_{12}m_{21}| = |1.5 \\times 1.2| = 1.8$。因为 $1.8 \\not 1$，测试失败（结果：$0$）。\n- 结果对：$(0, 0)$。两个测试都明确失败。\n\n最终程序将计算这些结果对，并将它们聚合成所需的字符串格式：`[[1,1],[0,1],[0,0],[0,0]]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes robust stability checks for a set of 2x2 matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0, 0.5], [0.5, 0]], dtype=float),\n        np.array([[0, 1.2], [0.8, 0]], dtype=float),\n        np.array([[0, 1.25], [0.8, 0]], dtype=float),\n        np.array([[0, 1.5], [1.2, 0]], dtype=float)\n    ]\n\n    results = []\n    for M in test_cases:\n        # 1. Unstructured small-gain test: norm(M, 2)  1\n        # The induced 2-norm is the largest singular value of M.\n        # It can be computed directly using numpy.linalg.norm with ord=2.\n        norm_M_2 = np.linalg.norm(M, ord=2)\n        small_gain_passes = 1 if norm_M_2  1.0 else 0\n\n        # 2. Structured singular value (mu) test: mu(M)  1\n        # For the given M structure (zero diagonal elements), mu(M)  1\n        # is equivalent to |m_12 * m_21|  1, as derived from first\n        # principles.\n        m12 = M[0, 1]\n        m21 = M[1, 0]\n        mu_criterion = np.abs(m12 * m21)\n        structured_mu_passes = 1 if mu_criterion  1.0 else 0\n        \n        results.append([small_gain_passes, structured_mu_passes])\n\n    # Final print statement in the exact required format.\n    # The required format is a string representation of a Python list of lists,\n    # with no whitespace, e.g., \"[[a,b],[c,d]]\".\n    # We construct this string manually to ensure exactness.\n    outer_parts = []\n    for pair in results:\n        outer_parts.append(f\"[{pair[0]},{pair[1]}]\")\n    final_output_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2741714"}, {"introduction": "在多变量系统中，独立分析每个控制回路可能产生误导甚至危险的结论，因为回路间的强耦合可能严重削弱系统的整体稳定性。本练习旨在阐明这一关键概念，您将构建一个从单回路角度看似乎是鲁棒的，但在扰动同时作用时却变得脆弱的系统。通过比较单回路和多回路的稳定裕度，您将对分散式分析的陷阱以及MIMO鲁棒性能分析工具的必要性获得至关重要的直觉。", "problem": "给定一个线性时不变 (LTI) 的多输入多输出 (MIMO) 连续时间负反馈系统，其控制器为对角静态控制器。令 $G(s)$ 表示 $2 \\times 2$ 的对象传递矩阵，令 $K = \\mathrm{diag}(k_1,k_2)$ 表示控制器。回路传递矩阵为 $L(s) = G(s)K$，互补灵敏度矩阵为 $T(s) = L(s)(I + L(s))^{-1}$，其中 $I$ 是 $2 \\times 2$ 的单位矩阵。考虑在回路开环处的复数乘性不确定性。对于单个回路 $i$ 受到扰动 $L_{ii}(s) \\mapsto (1 + \\Delta_i)L_{ii}(s)$，其中 $|\\Delta_i| \\le \\rho_i$（复标量），小增益定理根据该回路的互补灵敏度的大小提供了一个鲁棒稳定性的条件。对于两个回路同时存在的独立复数乘性不确定性，建模为块对角不确定性 $\\Delta = \\mathrm{diag}(\\Delta_1,\\Delta_2)$，其中 $|\\Delta_i| \\le \\rho$（复标量），小增益定理根据互补灵敏度矩阵的诱导范数提供了一个鲁棒稳定性的充分条件。你的任务是：\n- 从小增益定理和互补灵敏度的定义出发，推导计算以下表达式：\n  1. 对每个独立分析的回路 $i \\in \\{1,2\\}$（另一个回路断开），计算能保证对所有复标量乘性扰动 $|\\Delta_i| \\le \\rho_i$ 保持鲁棒稳定性的最大复增益裕度 $\\rho_i$。\n  2. 计算最大同时复增益（圆盘）裕度的一个保守界 $\\rho_{\\mathrm{sim}}$，该裕度保证系统在两个回路同时施加所有块对角复标量乘性扰动 $|\\Delta_i| \\le \\rho$ 时保持鲁棒稳定。\n- 然后使用频域分析对你的推导进行数值实现。\n\n使用以下建模和数值说明：\n- $G(s)$ 的每个标量传递函数项的形式为 $G_{ij}(s) = \\dfrac{a_{ij}}{s + p_{ij}}$，其中 $a_{ij}$ 为实数，$p_{ij}$ 为严格正数。\n- 控制器为 $K = \\mathrm{diag}(k_1,k_2)$，其中 $k_1,k_2$ 为正实数增益。\n- 对于回路 $i$ 的单回路分析，断开另一个回路。将单回路互补灵敏度建模为由 SISO 回路传递 $L_{ii}(s)$ 构建的 $T_i(s)$。\n- 通过在对数网格 $\\omega \\in [10^{-3}, 10^{3}]$（单位：弧度/秒）上采样频率轴来近似频率上的本质上确界，使用至少 $N = 3000$ 个对数间隔的采样点。\n\n测试套件：\n为三个指定的对象和控制器计算以下量值。对于每种情况，报告三个值：\n- 最小的单回路复增益裕度 $\\min(\\rho_1,\\rho_2)$。\n- 从互补灵敏度矩阵获得的保守同时圆盘裕度界 $\\rho_{\\mathrm{sim}}$。\n- 比率 $\\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)$。\n\n情况 1（对角对象，基准一致性检查）：\n- $G_{11}(s) = \\dfrac{2.0}{s + 1.0}$， $G_{12}(s) = \\dfrac{0.0}{s + 1.0}$，\n- $G_{21}(s) = \\dfrac{0.0}{s + 1.0}$， $G_{22}(s) = \\dfrac{3.0}{s + 0.5}$，\n- $K = \\mathrm{diag}(0.6, 0.4)$。\n\n情况 2（中等交叉耦合）：\n- $G_{11}(s) = \\dfrac{2.0}{s + 1.0}$， $G_{12}(s) = \\dfrac{0.5}{s + 0.7}$，\n- $G_{21}(s) = \\dfrac{-0.4}{s + 0.9}$， $G_{22}(s) = \\dfrac{3.0}{s + 0.5}$，\n- $K = \\mathrm{diag}(0.6, 0.4)$。\n\n情况 3（导致脆弱性的强交叉耦合）：\n- $G_{11}(s) = \\dfrac{0.2}{s + 1.0}$， $G_{12}(s) = \\dfrac{5.0}{s + 0.3}$，\n- $G_{21}(s) = \\dfrac{-5.0}{s + 0.3}$， $G_{22}(s) = \\dfrac{0.2}{s + 1.0}$，\n- $K = \\mathrm{diag}(1.0, 1.0)$。\n\n要求的输出和格式：\n- 对于每种情况，计算：\n  - 根据单回路分析计算 $\\rho_1$ 和 $\\rho_2$，然后计算 $\\min(\\rho_1,\\rho_2)$，\n  - 根据多回路分析计算保守的同时圆盘裕度界 $\\rho_{\\mathrm{sim}}$，\n  - 比率 $\\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)$。\n- 将每种情况报告为一个列表 $[\\min(\\rho_1,\\rho_2), \\rho_{\\mathrm{sim}}, \\rho_{\\mathrm{sim}} / \\min(\\rho_1,\\rho_2)]$，每个值四舍五入到恰好三位小数。\n- 你的程序应生成单行输出，其中包含三个情况的结果，格式为方括号内包含的逗号分隔列表，例如 $[[r_{1,1}, r_{1,2}, r_{1,3}],[r_{2,1}, r_{2,2}, r_{2,3}],[r_{3,1}, r_{3,2}, r_{3,3}]]$.\n\n角度单位：\n- 所有频率单位均为弧度/秒。无需进行角度转换。\n\n输出中没有物理单位；所有输出都是无量纲的实数。请通过遵守指定的频率网格并在可能的情况下避免病态矩阵求逆来确保数值稳定性和准确性。你的程序必须是自包含的，不需要用户输入，并严格遵循指定的输出格式。", "solution": "所提出的问题是关于线性时不变 (LTI) 多输入多输出 (MIMO) 系统鲁棒控制分析的一个适定练习。它在科学上基于成熟的控制理论，提供了所有必要的数据和定义，并要求计算标准的鲁棒性度量。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n问题的核心是使用小增益定理来确定受复数乘性不确定性影响的反馈系统的鲁棒稳定裕度。我们将首先推导必要的理论表达式，然后概述数值实现。\n\n设系统由对象 $G(s)$ 和控制器 $K$ 的负反馈互联描述。回路传递矩阵为 $L(s) = G(s)K$，并假设标称闭环系统是稳定的。输出互补灵敏度矩阵定义为 $T(s) = L(s)(I + L(s))^{-1}$。\n\n**1. 单回路鲁棒性分析**\n\n对于单个回路 $i \\in \\{1,2\\}$ 的分析，问题陈述了另一个回路被断开，并且一个乘性扰动被施加到回路传递函数 $L_{ii}(s)$ 上。受扰动的标量回路传递函数为 $L'_{ii}(s) = (1 + \\Delta_i(s))L_{ii}(s)$，其中 $\\Delta_i(s)$ 是一个稳定的复传递函数，代表不确定性，其界为对所有频率 $\\omega$，有 $|\\Delta_i(j\\omega)| \\leq \\rho_i$。\n\n回路 $i$ 的标称特征方程为 $1 + L_{ii}(s) = 0$。受扰动的特征方程为 $1 + L'_{ii}(s) = 0$。代入 $L'_{ii}(s)$ 的表达式：\n$$ 1 + (1 + \\Delta_i(s))L_{ii}(s) = 0 $$\n$$ (1 + L_{ii}(s)) + \\Delta_i(s)L_{ii}(s) = 0 $$\n对于标称稳定的闭环系统，$1 + L_{ii}(s)$ 在虚轴上非零。我们可以重新排列方程以分离不确定性：\n$$ 1 + \\Delta_i(s) \\frac{L_{ii}(s)}{1 + L_{ii}(s)} = 0 $$\n我们将回路 $i$ 的标量互补灵敏度函数定义为 $T_i(s) = \\frac{L_{ii}(s)}{1 + L_{ii}(s)}$。稳定性条件变为对于右半平面中所有的 $s$，都有 $1 + \\Delta_i(s)T_i(s) \\neq 0$。这可以看作是 $\\Delta_i(s)$ 和 $T_i(s)$ 之间的一个反馈回路。根据小增益定理，对于所有满足 $\\|\\Delta_i\\|_{\\infty}  1/\\|T_i\\|_{\\infty}$ 的稳定 $\\Delta_i(s)$，此回路是稳定的。\n\n给定不确定性界 $|\\Delta_i(j\\omega)| \\le \\rho_i$，我们有 $\\|\\Delta_i\\|_{\\infty} \\le \\rho_i$。因此，鲁棒稳定性的条件是 $\\rho_i  1/\\|T_i\\|_{\\infty}$。对于所有容许的扰动，保证稳定性的最大复增益裕度 $\\rho_i$ 为：\n$$ \\rho_i = \\frac{1}{\\|T_i\\|_{\\infty}} = \\frac{1}{\\sup_{\\omega} |T_i(j\\omega)|} $$\n其中 $L_{ii}(s) = G_{ii}(s)k_i$。\n\n**2. 同时 MIMO 鲁棒性分析**\n\n对于两个回路上同时存在的扰动，我们将不确定性建模为一个对角矩阵 $\\Delta(s) = \\mathrm{diag}(\\Delta_1(s), \\Delta_2(s))$，其中对所有 $\\omega$，有 $|\\Delta_i(j\\omega)| \\le \\rho$。我们假设采用标准的输出乘性不确定性模型，其中受扰动的对象为 $G_p(s) = G(s)(I + \\Delta(s))$。这是互补灵敏度矩阵 $T(s)$ 作为相关分析传递函数的标准模型之一。\n\n为了应用小增益定理，我们在 M-$\\Delta$ 框架中构建系统。令 $z(s)$ 为不确定性模块 $\\Delta(s)$ 的输入，$w(s)$ 为其输出，使得 $w(s) = \\Delta(s)z(s)$。目标是找到标称系统中从 $w(s)$ 到 $z(s)$ 的传递矩阵 $M(s)$。\n\n反馈系统方程为：\n- 对象输出: $y(s) = G(s)u(s)$\n- 控制器输出: $u(s) = K(r(s) - y_f(s))$\n- 反馈信号（受扰动）: $y_f(s) = y(s) + w(s)$\n- 不确定性输入: $z(s) = y(s)$\n\n为进行内部稳定性分析，我们设置外部参考 $r(s) = 0$。\n$$ u(s) = -K(y(s) + w(s)) = -K(z(s) + w(s)) $$\n$$ y(s) = G(s)u(s) = -G(s)K(z(s) + w(s)) = -L(s)(z(s) + w(s)) $$\n因为 $z(s) = y(s)$，我们有：\n$$ z(s) = -L(s)(z(s) + w(s)) $$\n$$ (I + L(s))z(s) = -L(s)w(s) $$\n$$ z(s) = -(I + L(s))^{-1}L(s)w(s) $$\n通过颠倒最后一个表达式中矩阵的顺序，$z(s) = -L(s)(I + L(s))^{-1}w(s) = -T(s)w(s)$。从 $w$ 到 $z$ 的传递矩阵是 $M(s) = -T(s)$。\n\n小增益定理指出，如果 $\\|\\Delta M\\|_{\\infty}  1$，则互联系统是稳定的。一个充分（且保守）的条件是 $\\|\\Delta\\|_{\\infty} \\|M\\|_{\\infty}  1$。\n块对角不确定性 $\\Delta(s)$ 的 $H_{\\infty}$-范数为：\n$$ \\|\\Delta\\|_{\\infty} = \\sup_{\\omega} \\sigma_{\\max}(\\Delta(j\\omega)) = \\sup_{\\omega} \\max_{i} |\\Delta_i(j\\omega)| \\le \\rho $$\n$M(s)$ 的范数是 $\\|M\\|_{\\infty} = \\|-T\\|_{\\infty} = \\|T\\|_{\\infty}$。稳定性条件变为 $\\rho \\|T\\|_{\\infty}  1$。因此，最大同时圆盘裕度 $\\rho_{\\mathrm{sim}}$ 由下式给出：\n$$ \\rho_{\\mathrm{sim}} = \\frac{1}{\\|T\\|_{\\infty}} = \\frac{1}{\\sup_{\\omega} \\sigma_{\\max}(T(j\\omega))} $$\n其中 $\\sigma_{\\max}(\\cdot)$ 表示最大奇异值。这个界是保守的，因为它没有利用 $\\Delta(s)$ 的对角结构。\n\n**3. 数值实现**\n\n$H_{\\infty}$-范数通过在密集的频率网格上取最大值来数值计算。对于标量函数 $T_i(s)$，$\\|T_i\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} |T_i(j\\omega)|$。对于矩阵函数 $T(s)$，$\\|T\\|_{\\infty} \\approx \\max_{\\omega \\in \\Omega} \\sigma_{\\max}(T(j\\omega))$。频率网格 $\\Omega$ 被指定为 $10^{-3}$ 和 $10^3$ rad/s 之间的 $N=3000$ 个对数间隔点。计算过程是在网格中的每个频率点上评估相关的传递函数，并找到相应范数的最大值。对于 MIMO 情况，这涉及在每个频率点进行矩阵求逆和奇异值分解。\n\n比率 $\\rho_{\\mathrm{sim}} / \\min(\\rho_1, \\rho_2)$ 量化了多变量耦合对鲁棒性的影响。对于解耦系统（对角对象），该比率预期为 $1$。对于耦合系统，相互作用通常会降低鲁棒性，导致比率小于 $1$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import svd\n\ndef g_ij(s, a, p):\n    \"\"\"\n    Computes the value of a single transfer function G_ij(s) = a / (s + p).\n    \"\"\"\n    return a / (s + p)\n\ndef solve_case(G_params, K_diag):\n    \"\"\"\n    Solves for robustness margins for a single test case.\n\n    Args:\n        G_params (list of lists of tuples): 2x2 matrix of (a_ij, p_ij) parameters for the plant G(s).\n        K_diag (list): Diagonal elements [k1, k2] of the controller K.\n\n    Returns:\n        list: A list containing [min(rho_1, rho_2), rho_sim, ratio], rounded to 3 decimal places.\n    \"\"\"\n    # Define frequency grid\n    w_grid = np.logspace(-3, 3, 3000)\n    s_grid = 1j * w_grid\n\n    k1, k2 = K_diag\n    K = np.diag(K_diag)\n\n    # --- Single-loop analysis (SISO) ---\n\n    # Loop 1\n    a11, p11 = G_params[0][0]\n    L11_s_vals = g_ij(s_grid, a11, p11) * k1\n    T1_s_vals = L11_s_vals / (1.0 + L11_s_vals)\n    norm_T1_inf = np.max(np.abs(T1_s_vals))\n    rho1 = 1.0 / norm_T1_inf if norm_T1_inf > 0 else float('inf')\n\n    # Loop 2\n    a22, p22 = G_params[1][1]\n    L22_s_vals = g_ij(s_grid, a22, p22) * k2\n    T2_s_vals = L22_s_vals / (1.0 + L22_s_vals)\n    norm_T2_inf = np.max(np.abs(T2_s_vals))\n    rho2 = 1.0 / norm_T2_inf if norm_T2_inf > 0 else float('inf')\n\n    min_rho_i = min(rho1, rho2)\n\n    # --- Simultaneous analysis (MIMO) ---\n    max_sigma_T_list = []\n\n    for s in s_grid:\n        # Construct G(s) matrix\n        G_s = np.array([\n            [g_ij(s, G_params[0][0][0], G_params[0][0][1]), g_ij(s, G_params[0][1][0], G_params[0][1][1])],\n            [g_ij(s, G_params[1][0][0], G_params[1][0][1]), g_ij(s, G_params[1][1][0], G_params[1][1][1])]\n        ], dtype=complex)\n\n        # Loop transfer matrix L(s) = G(s)K\n        L_s = G_s @ K\n\n        # Complementary sensitivity T(s) = L(s) * inv(I + L(s))\n        # Numerically better: T(s) = I - S(s) where S(s) = inv(I + L(s))\n        I = np.eye(2)\n        try:\n            S_s = np.linalg.inv(I + L_s)\n            T_s = I - S_s\n        except np.linalg.LinAlgError:\n            # If I+L is singular, ||T|| -> inf, rho -> 0.\n            # This indicates instability, but for this problem, we can assume it's stable.\n            # A large norm will be captured at other frequencies.\n            # We can skip this point, or assign a large value.\n            # Using svd on L might give a large singular value, leading to a large norm for T.\n            # For simplicity, we skip if inversion fails.\n            continue\n            \n        # Maximum singular value of T(s)\n        # scipy.linalg.svd is faster for just singular values\n        singular_values = svd(T_s, compute_uv=False)\n        max_sigma_T_list.append(singular_values[0])\n\n    norm_T_inf = np.max(max_sigma_T_list)\n    rho_sim = 1.0 / norm_T_inf if norm_T_inf > 0 else float('inf')\n\n    ratio = rho_sim / min_rho_i if min_rho_i != 0 else float('inf')\n\n    return [round(min_rho_i, 3), round(rho_sim, 3), round(ratio, 3)]\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"G_params\": [[(2.0, 1.0), (0.0, 1.0)], [(0.0, 1.0), (3.0, 0.5)]],\n            \"K_diag\": [0.6, 0.4]\n        },\n        {\n            \"G_params\": [[(2.0, 1.0), (0.5, 0.7)], [(-0.4, 0.9), (3.0, 0.5)]],\n            \"K_diag\": [0.6, 0.4]\n        },\n        {\n            \"G_params\": [[(0.2, 1.0), (5.0, 0.3)], [(-5.0, 0.3), (0.2, 1.0)]],\n            \"K_diag\": [1.0, 1.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case[\"G_params\"], case[\"K_diag\"])\n        results.append(result)\n\n    # Format the output string exactly as required\n    formatted_results = [f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2741663"}]}