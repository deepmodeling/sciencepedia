{"hands_on_practices": [{"introduction": "在控制理论中，内部稳定性和有界输入有界输出 (BIBO) 稳定性之间的区别是一个至关重要但又很微妙的概念。一个系统从某个输入到某个输出的传递函数可能表现出稳定性，但其内部却可能隐藏着不稳定的动态。本练习 [@problem_id:2708249] 探讨了极点-零点对消，尤其是在涉及不稳定模式时，是如何误导只关注单一传递函数的设计者的。通过分析这个看似简单的配置，您将更深刻地理解为何确保内部稳定性是任何可靠反馈系统设计的必要前提。", "problem": "考虑一个拉普拉斯域中的单输入单输出线性时不变单位负反馈互联系统，其前向通路控制器和对象分别为 $K(s)=k$ 和 $P(s)=\\frac{1}{s(s-1)}$。外部参考输入为 $r(t)$，控制信号为 $u(t)$，测量输出为 $y(t)$。假设所有信号都是可拉普拉斯变换的，并且对于所有实数 $k$，该反馈互联都是适定的。请使用反馈互联的基本原理以及下述定义来推导您的结论：\n\n- 有界输入有界输出 (BIBO) 稳定性被定义为：任何有界的外部输入都产生有界的测量输出的性质，等价于从外源输入到测量输出的每个闭环传递函数都是真分数的，并且其所有极点都严格位于开放左半平面。\n- 内部稳定性（也称为闭环实现的渐近稳定性）被定义为：互联实现的所有内部模式都具有严格为负的实部的性质，包括那些从所选的输入输出通道来看可能不可观或不可控的模式。\n\n任务：\n1. 从求和点和框图关系出发，推导从 $r$ 到 $y$ 的闭环传递函数，不要使用任何预先记忆的灵敏度公式。\n2. 使用您得到的多项式，通过基本原理分析闭环极点，刻画对于实数 $k$，从 $r$ 到 $y$ 的映射的 BIBO 稳定性。\n3. 确定所有实数 $k$ 的集合，使得该互联系统是 BIBO 稳定但非内部稳定的。您的论证必须明确说明在此配置中，任何不稳定的内部模式是否会因闭环输入输出映射中的代数极点-零点对消而被隐藏（不可观和/或不可控），并从原理上解释这种隐藏的不稳定模式的作用。\n\n请使用标准数学符号将您的最终答案表示为一个集合。无需四舍五入，也无物理单位。", "solution": "我们将通过验证问题的前提，然后使用线性控制理论的基本原理来完成指定的任务。\n\n首先，我们推导从参考输入 $r$ 到测量输出 $y$ 的闭环传递函数。设 $R(s)$、$U(s)$ 和 $Y(s)$ 分别是 $r(t)$、$u(t)$ 和 $y(t)$ 的拉普拉斯变换。对于单位负反馈配置，求和点的误差信号由下式给出：\n$$E(s) = R(s) - Y(s)$$\n控制信号 $U(s)$ 由控制器 $K(s)$ 作用于误差 $E(s)$ 产生：\n$$U(s) = K(s) E(s) = k(R(s) - Y(s))$$\n对象输出 $Y(s)$ 是对象 $P(s)$ 作用于控制信号 $U(s)$ 的结果：\n$$Y(s) = P(s) U(s) = \\frac{1}{s(s-1)} U(s)$$\n将 $U(s)$ 的表达式代入 $Y(s)$ 的方程中，得到：\n$$Y(s) = \\frac{k}{s(s-1)} (R(s) - Y(s))$$\n我们重新整理各项以求解比值 $\\frac{Y(s)}{R(s)}$：\n$$Y(s) \\left(1 + \\frac{k}{s(s-1)}\\right) = \\frac{k}{s(s-1)} R(s)$$\n$$Y(s) \\left(\\frac{s(s-1) + k}{s(s-1)}\\right) = \\frac{k}{s(s-1)} R(s)$$\n这给出了从 $r$ 到 $y$ 的闭环传递函数，完成了任务1：\n$$T_{yr}(s) = \\frac{Y(s)}{R(s)} = \\frac{k}{s(s-1) + k} = \\frac{k}{s^2 - s + k}$$\n\n对于任务2，我们刻画从 $r$ 到 $y$ 的映射的有界输入有界输出 (BIBO) 稳定性。这要求传递函数 $T_{yr}(s)$ 的所有极点都严格位于开放左半平面。我们通过寻找特征多项式 $\\Delta(s) = s^2 - s + k = 0$ 的根来考察极点。\n根据 $k$ 的值，有两种情况。\n情况1：$k \\neq 0$。$T_{yr}(s)$ 的极点是 $s^2 - s + k = 0$ 的根。设根为 $p_1$ 和 $p_2$。根据韦达定理，根之和为 $p_1 + p_2 = -(-1)/1 = 1$。根的实部之和为 $\\text{Re}(p_1 + p_2) = \\text{Re}(p_1) + \\text{Re}(p_2) = 1$。为了使两个极点都在开放左半平面，必须有 $\\text{Re}(p_1) < 0$ 和 $\\text{Re}(p_2) < 0$。这将意味着 $\\text{Re}(p_1) + \\text{Re}(p_2) < 0$，这与实部之和为 $1$ 的事实相矛盾。因此，对于任何 $k \\neq 0$，至少有一个极点不位于开放左半平面，从 $r$ 到 $y$ 的映射不是 BIBO 稳定的。\n情况2：$k=0$。传递函数变为 $T_{yr}(s) = \\frac{0}{s^2-s} = 0$。一个恒为零的传递函数没有极点。具有零传递函数的系统是 BIBO 稳定的，因为任何有界输入产生的输出始终为零，而零是有界的。\n综合这两种情况，从 $r$ 到 $y$ 的映射是 BIBO 稳定的当且仅当 $k=0$。\n\n对于任务3，我们必须找到所有实数 $k$ 的集合，使得该互联系统是 BIBO 稳定但非内部稳定的。\n首先，我们分析内部稳定性。闭环系统的内部模式是特征方程 $1 + P(s)K(s) = 0$ 的根，前提是环路传递函数 $L(s) = P(s)K(s)$ 中没有极点-零点对消。这里，$L(s) = \\frac{k}{s(s-1)}$，没有发生此类对消。特征方程为 $1 + \\frac{k}{s(s-1)} = 0$，化简为 $s^2 - s + k = 0$。为了使系统内部稳定，其所有内部模式（该多项式的根）的实部都必须严格为负。如任务2的分析所确立的，这些根的实部之和总是 $1$。这个稳定性条件对于任何实数 $k$ 都永远无法满足。因此，对于任何 $k \\in \\mathbb{R}$，该互联系统都不是内部稳定的。\n\n接下来，我们分析互联系统的 BIBO 稳定性。根据问题给出的严格定义，这要求*每个*从外源输入到测量输出的闭环传递函数的所有极点都位于开放左半平面。让我们考虑一个加在对象输入端的外源扰动输入 $d(t)$。对象输出则为 $Y(s) = P(s)(U(s)+D(s))$。从该扰动 $d$ 到输出 $y$ 的传递函数由 $T_{yd}(s) = \\frac{P(s)}{1+P(s)K(s)}$ 给出。代入给定的 $P(s)$ 和 $K(s)$ 表达式：\n$$T_{yd}(s) = \\frac{\\frac{1}{s(s-1)}}{1+\\frac{k}{s(s-1)}} = \\frac{1}{s(s-1)+k} = \\frac{1}{s^2-s+k}$$\n为了使互联系统是 BIBO 稳定的，$T_{yd}(s)$ 的极点（即 $s^2-s+k=0$ 的根）必须全部位于开放左半平面。如前所示，对于任何实数 $k$，这都永远不成立。因为至少存在一个输入输出映射对于任何 $k$ 都不稳定，所以该互联系统永远不是 BIBO 稳定的。\n\n问题要求的是使得互联系统 BIBO 稳定且非内部稳定的 $k$ 的集合。\n- “互联系统是 BIBO 稳定的”这一条件对于任何实数值 $k$ 都不成立。满足此条件的 $k$ 的集合是空集 $\\emptyset$。\n- “互联系统不是内部稳定的”这一条件对于所有实数值 $k$ 都成立。满足此条件的 $k$ 的集合是 $\\mathbb{R}$。\n这两个集合的交集是 $\\emptyset \\cap \\mathbb{R} = \\emptyset$。\n\n问题要求明确讨论隐藏模式。对于 $k=0$ 的情况，系统不是内部稳定的，其模式位于 $s=0$ 和 $s=1$。然而，传递函数 $T_{yr}(s)$ 为零，因此是稳定的。这是在状态空间实现背景下的极点-零点对消：不稳定的内部模式与参考输入 $r$ 无关。它们是“隐藏的”，因为它们从 $r$ 来看是不可控的。然而，这些模式并非对所有通道都是隐藏的。它们表现为扰动传递函数 $T_{yd}(s) = \\frac{1}{s(s-1)}$ 中的极点。根据所给定义，该映射的不稳定性使得整个互联系统不是 BIBO 稳定的。对于任何 $k \\neq 0$，没有发生此类对消，不稳定的内部模式会作为不稳定极点出现在所有传递函数中，包括 $T_{yr}(s)$ 和 $T_{yd}(s)$。", "answer": "$$\\boxed{\\emptyset}$$", "id": "2708249"}, {"introduction": "反馈的一个主要作用是处理不确定性，但它也可能放大我们不希望看到的信号，例如测量噪声，尤其是在高频段。量化这种放大效应是进行控制器实际整定的关键步骤。本练习 [@problem_id:2708282] 应用 $\\mathcal{H}_2$ 范数作为由白噪声输入引起的输出方差的精确度量，将一个理论工具与一个具体的性能指标直接联系起来。通过实施解决方案，您将在平衡控制器增益以获得性能与满足可接受的噪声放大约束方面，获得宝贵的实践经验。", "problem": "考虑一个连续时间、单输入单输出的线性时不变 (LTI) 单位负反馈回路，其中受控对象为 $P(s)=\\dfrac{5}{(s+1)(s+5)}$，控制器为 $K(s)=k\\dfrac{s+1}{s/10+1}$，标量增益 $k \\ge 0$。测量信号受到加性测量噪声 $n(t)$ 的干扰，该噪声具有单位（单边）功率谱密度，理想化为单位强度的连续时间白噪声。假设参考输入恒为零，因此唯一的激励是在传感器处以加性方式注入到对象输出的测量噪声。闭环输出 $y(t)$ 被测量并反馈，形成一个标准的负反馈互联。\n\n需要在程序中实现的任务：\n\n1) 根据反馈互联的基本原理，推导从测量噪声 $n(t)$ 到对象输出 $y(t)$ 的闭环传递函数 $T(s)$。\n\n2) 利用严格真分、内部稳定的 LTI 系统的 $\\mathcal{H}_2$ 范数定义，以及单位强度白噪声激励下输出方差与 $\\mathcal{H}_2$ 范数平方之间的等价关系，用 $T(s)$ 的参数和控制器增益 $k$ 来表示由 $n(t)$ 引起的输出方差 $\\sigma_y^2$。\n\n3) 对于给定的非负 $k$ 和指定的方差限制 $V_{\\max} \\ge 0$，计算：\n   - 给定 $k$ 时的噪声放大系数 $\\lVert T \\rVert_2$（即 $\\mathcal{H}_2$ 范数）。\n   - 一个调整后的增益 $k_{\\text{adj}} \\in [0,k]$，该增益在保证方差约束 $\\sigma_y^2 \\le V_{\\max}$ 的前提下尽可能大。\n   - 在 $k_{\\text{adj}}$ 下的最终输出方差。\n\n所有计算都必须在闭环系统内部稳定的假设下进行。如果 $V_{\\max}=0$，则取 $k_{\\text{adj}}=0$。\n\n您必须使用的基础理论：\n- 标准单位负反馈回路中灵敏度函数和互补灵敏度函数的定义，这些定义由基本的求和点和串联互联规则构建。\n- 对于传递函数为 $G(s)$ 的严格真分、渐近稳定的 LTI 系统，其 $\\mathcal{H}_2$ 范数的定义为：$\\lVert G \\rVert_2^2 = \\dfrac{1}{2\\pi}\\displaystyle\\int_{-\\infty}^{\\infty} \\lvert G(\\mathrm{j}\\omega) \\rvert^2 \\,\\mathrm{d}\\omega$，等价地，$\\lVert G \\rVert_2^2 = \\operatorname{trace}(CWC^\\top)$，其中 $W$ 是能控格拉姆矩阵，是 $G(s)$ 的一个最小实现 $(A,B,C,0)$ 所对应的连续时间李雅普诺夫方程 $AW + WA^\\top + BB^\\top = 0$ 的解。\n- 对于单位强度的白噪声输入，一个严格真分、稳定的 LTI 系统的输出稳态方差等于其 $\\mathcal{H}_2$ 范数的平方，即 $\\lVert G \\rVert_2^2$。\n\n您的程序必须实现上述步骤，并为以下参数值测试套件生成结果。每个测试用例是一个参数对 $(k, V_{\\max})$：\n\n- 用例 1 (一般情况): $(0.5, 10.0)$。\n- 用例 2 (约束激活): $(2.0, 1.0)$。\n- 用例 3 (位于边界): $(0.75, 0.5357142857142857)$。\n- 用例 4 (严格限制): $(1.0, 0.0001)$。\n- 用例 5 (零限制): $(3.0, 0.0)$。\n\n对每个用例，计算三个量：\n- 给定 $k$ 时的初始噪声放大系数 $\\lVert T \\rVert_2$。\n- 为满足 $\\sigma_y^2 \\le V_{\\max}$ 同时最大化 $k_{\\text{adj}} \\le k$ 而选择的调整后增益 $k_{\\text{adj}}$。\n- 在 $k_{\\text{adj}}$ 下的最终输出方差 $\\sigma_y^2$。\n\n数值和输出要求：\n- 将所有最终数值输出表示为无量纲实数，并四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表被方括号包围。每个测试用例对应一个子列表，顺序与上文指定的一致。每个子列表的形式必须为 $[\\lVert T \\rVert_2, k_{\\text{adj}}, \\sigma_y^2]$，并遵循上述四舍五入规则。例如，包含两个用例的一行输出应如下所示：$[[0.123456,0.100000,0.015000],[0.234567,0.200000,0.030000]]$。", "solution": "所给问题是分析受随机扰动影响的线性时不变 (LTI) 反馈系统的一个标准练习。该问题具有科学依据，提法明确且客观。问题陈述经过验证，包含了所有必要信息，内部一致，并依赖于成熟的控制理论原理。我们将进行一个形式化的、分步的推导和求解。\n\n主要目标是分析测量噪声对对象输出的影响，并设计一个控制器增益以满足对输出方差的约束。该系统是一个单位反馈回路，其对象为 $P(s) = \\dfrac{5}{(s+1)(s+5)}$，控制器为 $K(s) = k\\dfrac{s+1}{s/10+1}$。参考输入 $r(t)$ 为零，系统由单位强度的加性白测量噪声 $n(t)$ 激励。\n\n**步骤 1：推导噪声到输出的传递函数**\n\n闭环系统的动态特性由拉普拉斯域中的以下信号关系描述：\n1. 对象输出: $Y(s) = P(s)U(s)$\n2. 控制器输入: $E(s) = R(s) - (Y(s) + N(s))$\n3. 控制器输出: $U(s) = K(s)E(s)$\n\n给定参考 $R(s) = 0$，控制器输入简化为 $E(s) = -(Y(s) + N(s))$。\n将此代入控制器输出方程，得到对象输入：\n$U(s) = -K(s)(Y(s) + N(s))$\n\n则对象输出为：\n$Y(s) = P(s)U(s) = -P(s)K(s)(Y(s) + N(s)) = -P(s)K(s)Y(s) - P(s)K(s)N(s)$\n\n为了找到从噪声输入 $N(s)$ 到对象输出 $Y(s)$ 的传递函数，我们重新整理方程以求解 $Y(s)$：\n$Y(s) + P(s)K(s)Y(s) = -P(s)K(s)N(s)$\n$Y(s)(1 + P(s)K(s)) = -P(s)K(s)N(s)$\n\n因此，所求的传递函数（记为 $T(s)$）为：\n$T(s) = \\dfrac{Y(s)}{N(s)} = -\\dfrac{P(s)K(s)}{1 + P(s)K(s)}$\n\n这是互补灵敏度函数的相反数。首先计算环路传递函数 $L(s) = P(s)K(s)$：\n$L(s) = \\left(\\dfrac{5}{(s+1)(s+5)}\\right) \\left(k\\dfrac{s+1}{0.1s+1}\\right) = \\dfrac{5k}{(s+5)(0.1s+1)}$\n注意到在 $s=-1$ 处存在零极点对消。由于被对消的极点是稳定的，只要简化后的闭环系统是稳定的，内部稳定性就能得到保持。\n\n将 $L(s)$ 代入 $T(s)$ 的表达式中：\n$T(s) = -\\dfrac{\\frac{5k}{(s+5)(0.1s+1)}}{1 + \\frac{5k}{(s+5)(0.1s+1)}} = -\\dfrac{5k}{(s+5)(0.1s+1) + 5k}$\n展开分母多项式：\n$(s+5)(0.1s+1) + 5k = 0.1s^2 + s + 0.5s + 5 + 5k = 0.1s^2 + 1.5s + 5(1+k)$\n\n为使分母的首项系数归一化为 1，我们将分子和分母同乘以 10：\n$T(s) = -\\dfrac{50k}{s^2 + 15s + 50(1+k)}$\n\n**步骤 2：稳定性与输出方差**\n\n闭环系统的稳定性由其特征多项式（即 $T(s)$ 的分母）的根决定：$s^2 + 15s + 50(1+k) = 0$。对于一个二阶多项式，如果所有系数均为正，则系统是稳定的（所有根都在左半平面）。给定 $k \\ge 0$，系数 $1$、$15$ 和 $50(1+k)$ 均为正。因此，对于所有非负增益 $k$，该闭环系统都是内部稳定的。\n\n问题陈述指出，对于一个由单位强度白噪声激励的严格真分、稳定的 LTI 系统，其传递函数为 $G(s)$，输出的稳态方差等于系统 $\\mathcal{H}_2$ 范数的平方，即 $\\sigma^2 = \\lVert G \\rVert_2^2$。传递函数 $T(s)$ 是严格真分且稳定的。\n\n对于一个通用的二阶系统 $G(s) = \\dfrac{b_0}{s^2 + a_1s + a_0}$，其 $\\mathcal{H}_2$ 范数的平方由公式 $\\lVert G \\rVert_2^2 = \\dfrac{b_0^2}{2a_1a_0}$ 给出。\n对于我们的传递函数 $T(s)$，参数为：\n$b_0 = -50k$\n$a_1 = 15$\n$a_0 = 50(1+k)$\n\n输出方差 $\\sigma_y^2$ 作为增益 $k$ 的函数为：\n$\\sigma_y^2(k) = \\lVert T \\rVert_2^2 = \\dfrac{(-50k)^2}{2(15)(50(1+k))} = \\dfrac{2500k^2}{1500(1+k)} = \\dfrac{5k^2}{3(1+k)}$\n\n噪声放大系数即 $\\mathcal{H}_2$ 范数本身：对于 $k \\ge 0$，$\\lVert T \\rVert_2(k) = \\sqrt{\\sigma_y^2(k)} = k\\sqrt{\\dfrac{5}{3(1+k)}}$。\n\n**步骤 3：增益调整算法**\n\n我们必须找到最大的增益 $k_{\\text{adj}} \\in [0, k]$，以确保方差约束 $\\sigma_y^2(k_{\\text{adj}}) \\le V_{\\max}$ 得到满足。为此，我们分析 $\\sigma_y^2$ 和 $k$ 之间的关系。方差对 $k$ 的导数为：\n$\\dfrac{d\\sigma_y^2}{dk} = \\dfrac{5}{3}\\dfrac{d}{dk}\\left(\\dfrac{k^2}{1+k}\\right) = \\dfrac{5}{3}\\dfrac{2k(1+k) - k^2}{(1+k)^2} = \\dfrac{5}{3}\\dfrac{k^2+2k}{(1+k)^2}$\n当 $k > 0$ 时，该导数严格为正。因此，对于 $k \\ge 0$，$\\sigma_y^2(k)$ 是 $k$ 的一个单调递增函数。\n\n这种单调性决定了对于给定的输入对 $(k, V_{\\max})$，应遵循以下逻辑：\n1.  计算在给定增益 $k$ 下的方差：$\\sigma_y^2(k) = \\dfrac{5k^2}{3(1+k)}$。\n2.  将此方差与最大允许方差 $V_{\\max}$ 进行比较。\n    - 如果 $\\sigma_y^2(k) \\le V_{\\max}$，则约束已满足。在允许范围 $[0, k]$ 内可能的最大增益就是 $k$ 本身。因此，$k_{\\text{adj}} = k$。最终的方差为 $\\sigma_y^2(k)$。\n    - 如果 $\\sigma_y^2(k) > V_{\\max}$，则增益 $k$ 过高。由于单调性，满足约束的最大增益是一个值 $k_{\\text{adj}} < k$，使得方差恰好等于限制值，即 $\\sigma_y^2(k_{\\text{adj}}) = V_{\\max}$。我们必须解此方程以求得 $k_{\\text{adj}}$。\n\n需要求解的方程是：\n$\\dfrac{5k_{\\text{adj}}^2}{3(1+k_{\\text{adj}})} = V_{\\max}$\n$5k_{\\text{adj}}^2 = 3V_{\\max}(1+k_{\\text{adj}})$\n$5k_{\\text{adj}}^2 - (3V_{\\max})k_{\\text{adj}} - 3V_{\\max} = 0$\n\n这是一个关于 $k_{\\text{adj}}$ 的二次方程。应用二次公式并选择非负根（因为 $k_{\\text{adj}} \\ge 0$ 且 $V_{\\max} \\ge 0$）：\n$k_{\\text{adj}} = \\dfrac{3V_{\\max} + \\sqrt{(3V_{\\max})^2 - 4(5)(-3V_{\\max})}}{2(5)} = \\dfrac{3V_{\\max} + \\sqrt{9V_{\\max}^2 + 60V_{\\max}}}{10}$\n在这种情况下，根据构造，最终的方差为 $\\sigma_y^2(k_{\\text{adj}}) = V_{\\max}$。\n\n特殊情况 $V_{\\max}=0$ 意味着，从方差公式来看，$k=0$ 是唯一的非负解。问题陈述明确指示，如果 $V_{\\max}=0$，我们必须设置 $k_{\\text{adj}}=0$。\n\n对每个测试用例，程序实现将遵循此逻辑。\n对于每对 $(k, V_{\\max})$，程序将计算：\n1. 给定 $k$ 的初始噪声放大系数：$\\lVert T \\rVert_2(k) = \\sqrt{\\frac{5k^2}{3(1+k)}}$。\n2. 使用上述逻辑计算的调整后增益 $k_{\\text{adj}}$。\n3. 在调整后增益下的最终输出方差：$\\sigma_y^2(k_{\\text{adj}})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the control theory problem for a suite of test cases.\n\n    The solution involves:\n    1. Calculating the initial noise amplification (H2 norm) for a given gain k.\n    2. Determining the maximum adjusted gain k_adj = k that satisfies a variance constraint.\n    3. Computing the output variance at k_adj.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (k_initial, V_max).\n    test_cases = [\n        (0.5, 10.0),\n        (2.0, 1.0),\n        (0.75, 0.5357142857142857),\n        (1.0, 0.0001),\n        (3.0, 0.0),\n    ]\n\n    results = []\n    \n    # Process each test case\n    for k_in, v_max in test_cases:\n        # Step 1: Compute initial noise amplification factor\n        # The output variance is sigma_y^2 = (5 * k^2) / (3 * (1 + k))\n        # The noise amplification factor is the H2 norm, which is sqrt(sigma_y^2)\n        if k_in == 0:\n            initial_variance = 0.0\n        else:\n            initial_variance = (5.0 * k_in**2) / (3.0 * (1.0 + k_in))\n        \n        h2_norm = np.sqrt(initial_variance)\n\n        # Step 2  3: Compute adjusted gain k_adj and final variance\n        \n        # Handle special case as per problem statement\n        if v_max == 0.0:\n            k_adj = 0.0\n            final_variance = 0.0\n        # If initial variance is within the limit, no adjustment is needed\n        elif initial_variance = v_max:\n            k_adj = k_in\n            final_variance = initial_variance\n        # If initial variance exceeds the limit, we must reduce the gain\n        else:\n            # We solve the quadratic equation 5*k^2 - (3*V_max)*k - 3*V_max = 0 for k.\n            # k_adj is the positive root of this equation.\n            a = 5.0\n            b = -3.0 * v_max\n            c = -3.0 * v_max\n            \n            discriminant = np.sqrt(b**2 - 4.0 * a * c)\n            k_adj = (-b + discriminant) / (2.0 * a)\n            \n            # The resulting variance is V_max by construction\n            final_variance = v_max\n            \n        results.append([h2_norm, k_adj, final_variance])\n\n    # Format the final output string exactly as required\n    formatted_cases = []\n    for case_result in results:\n        # case_result is a list [h2_norm, k_adj, final_variance]\n        # Format each number to six decimal places\n        formatted_numbers = [f\"{num:.6f}\" for num in case_result]\n        formatted_cases.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    final_output_string = f\"[{','.join(formatted_cases)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_string)\n\nsolve()\n```", "id": "2708252"}, {"introduction": "现代控制设计通常需要对闭环系统的频率响应进行整形，以满足多个、且常常是相互冲突的目标。混合灵敏度 $\\mathcal{H}_{\\infty}$ 框架为处理这些权衡提供了一种系统化的方法。本高级练习 [@problem_id:2708282] 将挑战您综合设计一个控制器，以最小化一个基于加权灵敏度函数 ($S$) 和加权互补灵敏度函数 ($T$) 的性能指标。通过这个数值综合任务，您将学习如何将性能规格（如扰动抑制和噪声衰减）转化为频域中的加权函数，并找到一个能最佳平衡这些需求的控制器。", "problem": "要求您实现一个完整的、可运行的程序，该程序基于反馈原理综合一个连续时间反馈控制器，并在Hardy空间无穷范数（$\\mathcal{H}_{\\infty}$）的意义下评估加权闭环性能。被控对象是线性时不变（LTI）的，性能目标通过加权灵敏度函数和加权互补灵敏度函数来定义。\n\n给定LTI单输入单输出被控对象\n$$\nP(s)=\\frac{1}{s(s+1)},\n$$\n和加权函数\n$$\nW_{1}(s)=\\frac{s/0.1+1}{s/10+1},\\qquad W_{3}(s)=\\frac{s/100+1}{s/1000+1},\n$$\n您必须从严格真的超前-滞后控制器族\n$$\nK(s)=k\\frac{s+z}{s+p},\n$$\n（其中$k0$，$z0$，$p0$）中选择并综合一个稳定控制器，以最小化性能指标\n$$\n\\gamma=\\max\\left(\\lVert W_{1}S\\rVert_{\\infty},\\,\\lVert W_{3}T\\rVert_{\\infty}\\right),\n$$\n其中灵敏度函数$S$和互补灵敏度函数$T$由以下闭环关系定义\n$$\nS(s)=\\frac{1}{1+L(s)},\\qquad T(s)=\\frac{L(s)}{1+L(s)},\\qquad L(s)=P(s)K(s).\n$$\n对于给定的频率$\\omega$（单位为弧度/秒），记$j\\omega$为虚轴上的取值。对于有理函数$G(s)$，使用$G(j\\omega)$计算其幅频响应。一个稳定的真传递函数$G$的$\\mathcal{H}_{\\infty}$范数是\n$$\n\\lVert G\\rVert_{\\infty}=\\sup_{\\omega\\in\\mathbb{R}}\\sigma_{\\max}\\bigl(G(j\\omega)\\bigr),\n$$\n对于单输入单输出系统，这简化为幅值$\\lvert G(j\\omega)\\rvert$在所有$\\omega$上的上确界。\n\n您的程序必须：\n1. 搜索$k$、$z$、$p$以找到一个能最小化上述定义的$\\gamma$的稳定控制器$K(s)$。此过程基于在一个足够密集的对数频率网格（$\\omega$的单位为弧度/秒）上对$\\mathcal{H}_{\\infty}$范数进行扫频近似。您必须通过检查闭环特征多项式的所有极点是否都具有严格为负的实部来显式地验证闭环稳定性。\n2. 一旦找到最佳控制器参数$(k^{\\star},z^{\\star},p^{\\star})$，使用相同的频率网格计算并报告所达到的$\\gamma$值，以及两个分量范数$\\lVert W_{1}S\\rVert_{\\infty}$和$\\lVert W_{3}T\\rVert_{\\infty}$。\n\n您必须使用的基本原理：\n- 反馈互联定义：$S(s)=\\frac{1}{1+L(s)}$，$T(s)=\\frac{L(s)}{1+L(s)}$，$L(s)=P(s)K(s)$。\n- $\\mathcal{H}_{\\infty}$范数的定义，即单输入单输出系统在所有频率上幅值的上确界。\n- 通过特征多项式的根严格位于开左半平面来检验闭环稳定性。\n\n您的搜索必须是完全数值化的，不得使用符号代数或任何用于综合的控制专用库函数。频率单位应为弧度/秒。\n\n测试套件与所需输出：\n- 使用上文指定的固定被控对象$P(s)$和加权$W_{1}(s)$、$W_{3}(s)$。\n- 评估三个性能界限目标值$\\gamma_{\\text{target}}$：$[1.5,\\,1.2,\\,1.05]$（所有值均无单位）。\n- 对于测试套件中的每个$\\gamma_{\\text{target}}$，程序必须确定最佳综合控制器是否满足$\\gamma\\gamma_{\\text{target}}$，并按顺序报告一个元组，其中包含布尔可行性、达到的$\\gamma$值、达到的$\\lVert W_{1}S\\rVert_{\\infty}$值以及达到的$\\lVert W_{3}T\\rVert_{\\infty}$值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果。结果是一个以逗号分隔的列表，并用方括号括起来，其中每个元素本身都是一个形式为$[\\text{feasible},\\gamma,\\lVert W_{1}S\\rVert_{\\infty},\\lVert W_{3}T\\rVert_{\\infty}]$的列表。\n- 例如，包含三个用例的输出应如下所示：`[[\\text{True},1.23,1.10,1.08],[\\text{True},1.18,1.05,1.12],[\\text{False},1.34,1.30,1.20]]`。\n- 所有频率计算都必须以弧度/秒为单位进行，最终输出无需包含任何物理单位。\n\n您的最终答案必须是一个单一、完整、可运行的Python程序，通过数值搜索执行综合，并仅按上述确切格式打印所需的单行输出。不允许用户输入或外部文件。答案必须是自包含且可复现的。", "solution": "所述问题是控制系统工程中一个有效练习。它具有科学依据，其形式适合数值求解，并且所有术语和目标都经过了精确的数学定义。任务是执行一个固定结构控制器的数值综合，以满足混合灵敏度$\\mathcal{H}_{\\infty}$性能目标。我们将着手解决。\n\n问题的核心是为一个超前-滞后控制器\n$$\nK(s) = k\\frac{s+z}{s+p}\n$$\n找到参数$(k, z, p)$（其中$k0$，$z0$，$p0$），以最小化性能指标$\\gamma$。该指标定义为两个加权$\\mathcal{H}_{\\infty}$范数的最大值：\n$$\n\\gamma = \\max\\left(\\lVert W_{1}S\\rVert_{\\infty}, \\lVert W_{3}T\\rVert_{\\infty}\\right)\n$$\n该系统包含一个单输入单输出被控对象$P(s)$，其灵敏度函数$S(s)$和互补灵敏度函数$T(s)$由标准反馈关系给出：\n$$\nS(s) = \\frac{1}{1+L(s)}, \\quad T(s) = \\frac{L(s)}{1+L(s)}\n$$\n其中$L(s) = P(s)K(s)$是开环传递函数。被控对象和加权函数指定如下：\n$$\nP(s) = \\frac{1}{s(s+1)}, \\quad W_{1}(s)=\\frac{s/0.1+1}{s/10+1}, \\quad W_{3}(s)=\\frac{s/100+1}{s/1000+1}\n$$\n\n任何解的一个强制性先决条件是闭环系统的稳定性。闭环系统的特征多项式是$1+L(s)$的分子。我们推导出此多项式为：\n$$\n1+L(s) = 1 + \\frac{k(s+z)}{s(s+1)(s+p)} = \\frac{s(s+1)(s+p) + k(s+z)}{s(s+1)(s+p)}\n$$\n因此，特征多项式为$\\Delta(s) = s^3 + (p+1)s^2 + (p+k)s + kz$。对于一个三阶多项式$a_3s^3+a_2s^2+a_1s+a_0=0$，劳斯-赫尔维茨稳定性判据要求所有系数均为正，并且$a_2 a_1  a_3 a_0$。考虑到约束$k0$、$z0$、$p0$，所有系数$a_3=1$、$a_2=p+1$、$a_1=p+k$和$a_0=kz$都严格为正。因此，稳定性条件简化为单个不等式：\n$$\n(p+1)(p+k)  kz\n$$\n任何违反此条件的参数集$(k, z, p)$都会导致控制器不稳定，并应立即被舍弃。\n\n该问题通过数值优化来解决。对于单输入单输出系统，一个稳定传递函数$G(s)$的$\\mathcal{H}_{\\infty}$范数是其在虚轴上幅值的上确界：\n$$\n\\lVert G \\rVert_{\\infty} = \\sup_{\\omega \\in \\mathbb{R}} |G(j\\omega)|\n$$\n此上确界通过在一个密集的对数间隔频率网格$\\omega$上评估$|G(j\\omega)|$并找到最大值来进行数值近似。\n\n综合任务被表述为以下优化问题：\n$$\n\\min_{k,z,p} \\gamma(k,z,p) \\quad \\text{约束条件为} \\quad k0, z0, p0 \\quad \\text{且} \\quad (p+1)(p+k)  kz\n$$\n为了处理正性约束，采用了对数变量替换：$k=10^{x_1}$，$z=10^{x_2}$，$p=10^{x_3}$。然后对无约束实变量$(x_1, x_2, x_3)$执行优化。构建一个目标函数，该函数接收这些对数参数，计算出相应的$(k, z, p)$，检查稳定性，如果系统稳定，则计算并返回$\\gamma$。如果系统不稳定，函数返回一个无穷大惩罚，以引导优化器避开这些区域。\n\n使用一种无导数优化算法，特别是`scipy.optimize.minimize`提供的Nelder-Mead方法，来寻找最优参数。为增加找到全局最优解并避免陷入不良局部最小值的概率，实施了多起点策略。优化程序从参数空间中的几个不同初始点执行，并将获得的最佳结果作为最终解。\n\n一旦确定了最优参数$(k^{\\star}, z^{\\star}, p^{\\star})$和最小性能指标$\\gamma^{\\star}$，最后一步是将此结果与三个指定的目标值$\\gamma_{\\text{target}} \\in \\{1.5, 1.2, 1.05\\}$进行评估。对于每个目标，我们确定所达到的性能是否更好（即$\\gamma^{\\star}  \\gamma_{\\text{target}}$），并报告布尔可行性以及达到的$\\gamma^{\\star}$和分量范数$\\lVert W_{1}S\\rVert_{\\infty}$和$\\lVert W_{3}T\\rVert_{\\infty}$。最终输出被构造成这些评估元组的列表，严格遵循指定的格式。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport sys\n\n# Suppress runtime warnings that can occur with complex numbers (e.g., divide by zero in L).\n# The optimization logic handles these cases by returning np.inf.\nnp.seterr(all='ignore')\n\ndef solve():\n    \"\"\"\n    Synthesizes a feedback controller by minimizing a mixed-sensitivity H-infinity\n    performance index and evaluates the result against specified targets.\n    \"\"\"\n    # Define the target performance levels for evaluation from the problem statement.\n    gamma_targets = [1.5, 1.2, 1.05]\n\n    # --- System and Optimization Setup ---\n\n    # Define a dense logarithmic frequency grid for H-infinity norm approximation.\n    # The range covers all relevant dynamics of the plant and weights.\n    omega = np.logspace(-3, 4, 5000)\n    s = 1j * omega\n\n    # Pre-calculate frequency responses of fixed system components.\n    # Plant: P(s) = 1 / (s * (s + 1))\n    P_s = 1 / (s * (s + 1))\n    # Weight 1: W1(s) = (s/0.1 + 1) / (s/10 + 1)\n    W1_s = (s / 0.1 + 1) / (s / 10 + 1)\n    # Weight 3: W3(s) = (s/100 + 1) / (s/1000 + 1)\n    W3_s = (s / 100 + 1) / (s / 1000 + 1)\n\n    # Cache for the optimization to avoid re-computation for the same parameters.\n    cost_cache = {}\n\n    def cost_function(log_params):\n        \"\"\"\n        Calculates the performance index gamma for a given set of controller parameters.\n        Parameters are provided in log10 scale to enforce positivity and handle wide ranges.\n        \"\"\"\n        params_tuple = tuple(log_params)\n        if params_tuple in cost_cache:\n            return cost_cache[params_tuple]\n\n        log_k, log_z, log_p = log_params\n        k = 10**log_k\n        z = 10**log_z\n        p = 10**log_p\n\n        # --- Stability Check ---\n        # Using the Routh-Hurwitz criterion for the 3rd-order characteristic polynomial:\n        # delta(s) = s^3 + (p+1)s^2 + (p+k)s + kz\n        # Condition for stability: (p+1)*(p+k) > k*z\n        if (p + 1) * (p + k) = k * z:\n            return np.inf  # Return infinity for unstable controllers\n\n        # --- Performance Calculation ---\n        # Controller: K(s) = k * (s + z) / (s + p)\n        K_s = k * (s + z) / (s + p)\n        \n        L_s = P_s * K_s\n        # Add a small epsilon to prevent division by zero if 1+L=0 at some frequency\n        S_s = 1 / (1 + L_s + 1e-12)\n        T_s = L_s / (1 + L_s + 1e-12)\n\n        # Approximate H-infinity norms by finding the maximum magnitude over the frequency grid.\n        norm_w1s = np.max(np.abs(W1_s * S_s))\n        norm_w3t = np.max(np.abs(W3_s * T_s))\n        \n        gamma = np.max([norm_w1s, norm_w3t])\n        \n        cost_cache[params_tuple] = gamma\n        return gamma\n\n    # --- Optimization using a Multi-Start Strategy ---\n    # This mitigates the risk of converging to a poor local minimum.\n    # Initial guesses for [log10(k), log10(z), log10(p)]\n    initial_guesses = [\n        [1.0, 0.0, 1.0],    # k=10, z=1, p=10 (Lead)\n        [0.0, -1.0, 1.0],   # k=1, z=0.1, p=10 (Lead)\n        [1.0, 1.0, 0.0],    # k=10, z=10, p=1 (Lag)\n        [2.0, 0.5, 2.5],    # k=100, z=~3.16, p=~316 (Lead)\n        [1.5, -0.5, 2.0],   # k=~31.6, z=~0.316, p=100 (Lead)\n    ]\n    \n    best_result = None\n    min_gamma = np.inf\n\n    for x0 in initial_guesses:\n        res = minimize(\n            cost_function,\n            x0,\n            method='Nelder-Mead',\n            options={'maxiter': 1500, 'adaptive': True}\n        )\n        if res.success and res.fun  min_gamma:\n            min_gamma = res.fun\n            best_result = res\n\n    # --- Final Evaluation ---\n    # Once the best controller is found, evaluate its performance metrics.\n    if best_result is None or not np.isfinite(min_gamma):\n        # Fallback if no stable solution is found\n        achieved_gamma = np.inf\n        achieved_norm_w1s = np.inf\n        achieved_norm_w3t = np.inf\n    else:\n        log_k_opt, log_z_opt, log_p_opt = best_result.x\n        k_opt, z_opt, p_opt = 10**log_k_opt, 10**log_z_opt, 10**log_p_opt\n\n        K_s_opt = k_opt * (s + z_opt) / (s + p_opt)\n        L_s_opt = P_s * K_s_opt\n        S_s_opt = 1 / (1 + L_s_opt + 1e-12)\n        T_s_opt = L_s_opt / (1 + L_s_opt + 1e-12)\n\n        achieved_norm_w1s = np.max(np.abs(W1_s * S_s_opt))\n        achieved_norm_w3t = np.max(np.abs(W3_s * T_s_opt))\n        achieved_gamma = np.max([achieved_norm_w1s, achieved_norm_w3t])\n\n    # --- Format Output ---\n    # Assemble the results for each target gamma.\n    results_list = []\n    for target in gamma_targets:\n        feasible = bool(achieved_gamma  target)\n        results_list.append([\n            feasible, \n            achieved_gamma, \n            achieved_norm_w1s, \n            achieved_norm_w3t\n        ])\n    \n    # Construct the output string manually to match the required format exactly\n    # (no spaces between list elements, True/False capitalized).\n    case_strings = []\n    for case in results_list:\n        case_str = f\"[{case[0]},{case[1]},{case[2]},{case[3]}]\"\n        case_strings.append(case_str)\n    \n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2708282"}]}