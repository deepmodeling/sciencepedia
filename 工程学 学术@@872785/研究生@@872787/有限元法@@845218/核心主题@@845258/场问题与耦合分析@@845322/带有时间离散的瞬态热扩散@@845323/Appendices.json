{"hands_on_practices": [{"introduction": "在信任任何复杂的模拟结果之前，通过与已知的解析解进行比较来验证代码是至关重要的一步。本练习将指导您推导一个简单一维热问题的连续解和离散解，从而可以直接比较数值格式如何衰减不同频率的模式。通过这个过程，您不仅可以建立对代码正确性的信心，还能更深入地理解离散化误差的本质。[@problem_id:2607785]", "problem": "考虑一根长度为 $L>0$、热扩散率为 $\\alpha>0$ 的均匀杆中的一维瞬态热传导。温度场 $u(x,t)$ 满足齐次狄利克雷(Dirichlet)边界条件 $u(0,t)=0$ 和 $u(L,t)=0$ (对于所有 $t\\ge 0$)。初始条件为单一正弦模态 $u(x,0)=\\sin\\!\\left(\\frac{m\\pi x}{L}\\right)$，其中模态指数 $m\\in\\mathbb{N}$。\n\n从局部能量守恒原理和傅里叶(Fourier)定律出发，推导 $u(x,t)$ 的控制偏微分方程(PDE)，并证明在这些边界条件下，连续特征函数是空间正弦模态。通过分离变量法和正交性，推导给定初始条件下模态振幅的解析时间演化。\n\n接下来，使用 $N\\in\\mathbb{N}$ 个大小为 $h=L/N$ 的单元对空间域进行均匀离散化，并采用标准分段线性有限元法(FEM)和一致质量矩阵来近似 $u(x,t)$。令 $M$ 和 $K$ 分别表示所得的质量矩阵和刚度矩阵。证明在内部节点索引 $j=1,2,\\dots,N-1$ 处分量为 $\\sin\\!\\left(\\frac{jm\\pi}{N}\\right)$ 的内部网格正弦向量是矩阵束 $(K,M)$ 的广义特征向量，并以 $N$、$L$ 和 $m$ 的函数形式推导出相应的广义特征值的闭式解。\n\n使用时间步长为 $\\Delta t>0$ 的后向欧拉(BE)法对半离散系统 $M \\dot{\\boldsymbol{U}}(t)+\\alpha K \\boldsymbol{U}(t)=\\boldsymbol{0}$ 进行时间离散化，并将所得的单步更新专门应用于单个离散特征模态。定义此离散模态的每步放大因子，并将其与从相同模态在长度为 $\\Delta t$ 的时间间隔内的连续解析解中得到的精确每步放大因子进行比较。\n\n最后，取连续问题中的 $m$ 与离散模态指数相匹配，并假设 $1\\le m \\le N-1$，推导离散单步放大因子与精确单步放大因子之比 $\\mathcal{R}$ 的单一闭式解析表达式，该表达式用 $\\alpha$、$L$、$N$、$m$ 和 $\\Delta t$ 表示。将您的最终结果表述为单一闭式表达式。$\\mathcal{R}$ 无需单位，也无需四舍五入。", "solution": "所述问题具有科学依据、良定、客观且自洽。它是在偏微分方程数值方法分析领域中一个标准的、尽管是多部分的练习。所有参数都已明确定义，任务要求基于数学物理和数值分析的既定原理进行严格推导。因此，该问题是有效的，并将提供解答。\n\n首先，我们推导一维热传导的控制偏微分方程(PDE)。我们考虑杆上从 $x$ 到 $x+\\Delta x$ 的一个无穷小段。局部能量守恒原理指出，该体积内内能的时间变化率等于穿过其边界的净热通量。设 $A$ 为横截面积，$\\rho$ 为密度，$c$ 为比热容。内能为 $\\int_x^{x+\\Delta x} c \\rho A u(x',t) dx'$。热通量由傅里叶(Fourier)定律给出，$q(x,t) = -k \\frac{\\partial u}{\\partial x}$，其中 $k$ 是热导率。能量平衡方程为：\n$$ \\frac{d}{dt} \\int_x^{x+\\Delta x} c \\rho A u(x',t) dx' = A q(x,t) - A q(x+\\Delta x, t) $$\n假设 $c, \\rho, A$ 是常数，我们有：\n$$ \\int_x^{x+\\Delta x} c \\rho A \\frac{\\partial u}{\\partial t} dx' = A \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_x - \\left( -k \\frac{\\partial u}{\\partial x} \\bigg|_{x+\\Delta x} \\right) \\right) $$\n两边除以 $A \\Delta x$ 并取 $\\Delta x \\to 0$ 的极限，我们在左边使用微积分基本定理，在右边使用导数的定义：\n$$ c \\rho \\frac{\\partial u}{\\partial t} = \\frac{\\partial}{\\partial x} \\left( k \\frac{\\partial u}{\\partial x} \\right) $$\n对于均匀杆，$k$ 是常数。定义热扩散率 $\\alpha = k/(c\\rho)$，我们得到热方程：\n$$ \\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2} $$\n为求解析解，我们使用分离变量法，假设解的形式为 $u(x,t) = X(x)T(t)$。代入PDE得到 $X(x)T'(t) = \\alpha X''(x)T(t)$。分离变量得：\n$$ \\frac{T'(t)}{\\alpha T(t)} = \\frac{X''(x)}{X(x)} = -\\lambda^2 $$\n为满足齐次狄利克雷(Dirichlet)边界条件 $u(0,t)=u(L,t)=0$ 并得到非平凡解，分离常数必须为负。空间问题是算子 $-\\frac{d^2}{dx^2}$ 的一个特征值问题：\n$$ X''(x) + \\lambda^2 X(x) = 0, \\quad X(0)=0, \\quad X(L)=0 $$\n通解为 $X(x) = C_1 \\cos(\\lambda x) + C_2 \\sin(\\lambda x)$。条件 $X(0)=0$ 意味着 $C_1=0$。条件 $X(L)=0$ 意味着 $C_2 \\sin(\\lambda L) = 0$。为得到非平凡解($C_2 \\neq 0$)，必须有 $\\sin(\\lambda L)=0$，这要求 $\\lambda L = m\\pi$，其中整数 $m \\in \\mathbb{N}$。特征值为 $\\lambda_m^2 = \\left(\\frac{m\\pi}{L}\\right)^2$，相应的特征函数为 $X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$。这些就是空间正弦模态。\n\n时间问题是 $T'(t) + \\alpha \\lambda_m^2 T(t) = 0$，其解为 $T_m(t) = T_m(0) \\exp(-\\alpha \\lambda_m^2 t)$。完整解是这些模态的叠加。给定初始条件 $u(x,0) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$，我们看到只存在一个模态。解析解为：\n$$ u(x,t) = \\sin\\left(\\frac{m\\pi x}{L}\\right) \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 t\\right) $$\n在时间间隔 $\\Delta t$ 内的精确每步放大因子是振幅衰减的因子，即：\n$$ G_{\\text{exact}} = \\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right) $$\n现在我们进行有限元离散化。该PDE的弱形式是找到 $u \\in H^1_0([0,L])$，使得对于所有测试函数 $v \\in H^1_0([0,L])$：\n$$ \\int_0^L \\frac{\\partial u}{\\partial t} v \\,dx + \\alpha \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial v}{\\partial x} \\,dx = 0 $$\n在单元大小为 $h=L/N$ 的均匀网格上，使用分段线性有限元基 $\\{\\phi_j(x)\\}_{j=1}^{N-1}$，我们将 $u(x,t)$ 近似为 $u_h(x,t) = \\sum_{j=1}^{N-1} U_j(t) \\phi_j(x)$。这导出了半离散系统 $M \\dot{\\boldsymbol{U}}(t)+\\alpha K \\boldsymbol{U}(t)=\\boldsymbol{0}$，其中一致质量矩阵 $M$ 和刚度矩阵 $K$ 的元素为：\n$$ M_{ij} = \\int_0^L \\phi_i \\phi_j \\,dx, \\quad K_{ij} = \\int_0^L \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx} \\,dx $$\n对于一维均匀网格上的帽函数，这些矩阵是三对角的，其元素为：$M_{ii} = \\frac{2h}{3}$，$M_{i,i\\pm 1} = \\frac{h}{6}$，$K_{ii} = \\frac{2}{h}$，以及 $K_{i,i\\pm 1} = -\\frac{1}{h}$。\n\n我们必须证明，分量为 $(v_m)_j = \\sin\\left(\\frac{jm\\pi}{N}\\right)$ (其中 $j=1, \\dots, N-1$) 的离散正弦向量 $\\boldsymbol{v}_m$ 是 $(K,M)$ 的广义特征向量，并求出满足 $K\\boldsymbol{v}_m = \\Lambda_m M\\boldsymbol{v}_m$ 的特征值 $\\Lambda_m$。我们计算 $K$ 和 $M$ 对 $\\boldsymbol{v}_m$ 的作用。对于第 $j$ 个分量：\n$$ (K\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[-\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 2\\sin\\left(\\frac{jm\\pi}{N}\\right) - \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\n使用恒等式 $\\sin(A-B)+\\sin(A+B) = 2\\sin(A)\\cos(B)$，可简化为：\n$$ (K\\boldsymbol{v}_m)_j = \\frac{1}{h}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right) - 2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right)\\right] = \\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\n对于质量矩阵：\n$$ (M\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[\\sin\\left(\\frac{(j-1)m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right) + \\sin\\left(\\frac{(j+1)m\\pi}{N}\\right)\\right] $$\n$$ (M\\boldsymbol{v}_m)_j = \\frac{h}{6}\\left[2\\sin\\left(\\frac{jm\\pi}{N}\\right)\\cos\\left(\\frac{m\\pi}{N}\\right) + 4\\sin\\left(\\frac{jm\\pi}{N}\\right)\\right] = \\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)(v_m)_j $$\n正弦向量确实是这两个矩阵的特征向量。广义特征值 $\\Lambda_m$ 是它们各自特征值的比值：\n$$ \\Lambda_m = \\frac{\\frac{2}{h}\\left(1 - \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)}{\\frac{h}{3}\\left(2 + \\cos\\left(\\frac{m\\pi}{N}\\right)\\right)} = \\frac{6}{h^2}\\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\n代入 $h=L/N$，广义特征值为：\n$$ \\Lambda_m = \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)} $$\n接下来，我们使用后向欧拉(backward Euler)法对半离散系统进行时间离散化。对于单个特征模态，系统简化为关于模态振幅 $c(t)$ 的标量常微分方程 $c'(t) + \\alpha \\Lambda_m c(t) = 0$。将步长为 $\\Delta t$ 的后向欧拉法应用于形如 $\\dot{y}=-\\lambda y$ 的方程，得到 $y^{n+1} = y^n - \\lambda \\Delta t y^{n+1}$，这给出更新式 $y^{n+1} = (1+\\lambda\\Delta t)^{-1} y^n$。此处，$\\lambda = \\alpha \\Lambda_m$。离散单步放大因子是：\n$$ G_{\\text{discrete}} = \\frac{1}{1 + \\alpha \\Lambda_m \\Delta t} = \\frac{1}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\n最后，我们计算离散放大因子与精确放大因子之比 $\\mathcal{R}$。\n$$ \\mathcal{R} = \\frac{G_{\\text{discrete}}}{G_{\\text{exact}}} = \\frac{\\left(1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}\\right)^{-1}}{\\exp\\left(-\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)} $$\n这可以简化为最终表达式：\n$$ \\mathcal{R} = \\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos(m\\pi/N)}{2 + \\cos(m\\pi/N)}} $$\n这就是所要求的比率 $\\mathcal{R}$ 的闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{\\exp\\left(\\alpha \\left(\\frac{m\\pi}{L}\\right)^2 \\Delta t\\right)}{1 + \\alpha \\Delta t \\frac{6N^2}{L^2} \\frac{1 - \\cos\\left(\\frac{m\\pi}{N}\\right)}{2 + \\cos\\left(\\frac{m\\pi}{N}\\right)}}}\n$$", "id": "2607785"}, {"introduction": "在数值求解过程中，维持解的物理特性（例如温度的非负性）是一个重要的挑战。本实践要求您构建一个二维瞬态热扩散求解器，并设计一个具有强梯度的测试案例，以探究广泛使用的Crank-Nicolson格式的局限性，揭示其产生非物理振荡的可能。这对于理解数值方法的实际应用和选择合适的算法至关重要。[@problem_id:2607746]", "problem": "您需要使用有限元法，在锐角三角剖分上采用连续分片线性基函数，实现一个瞬态热扩散求解器。目标是设计一个具有强梯度的测试用例，评估 Crank-Nicolson 时间离散格式在锐角三角剖分上是否保持有限元解的正性，并解释任何观察到的振荡。您的程序必须从第一性原理出发组装空间算子，并直接对解进行时间步进。\n\n从以下基本物理和数学基础开始：\n- 连续介质中的能量守恒：对于温度场 $u(\\boldsymbol{x},t)$、热导率 $\\kappa$、密度 $\\rho$ 和热容 $c$，无源情况下的能量平衡方程为 $\\rho c\\, \\partial_t u - \\nabla \\cdot (\\kappa \\nabla u) = 0$。\n- 傅里叶热传导定律：热通量为 $\\boldsymbol{q} = -\\kappa \\nabla u$。\n- 假设经过无量纲化后，$\\rho c = 1$ 和 $\\kappa = 1$，因此控制方程简化为在区域 $\\Omega$ 内的 $\\partial_t u - \\Delta u = 0$，边界 $\\partial \\Omega$ 上具有齐次狄利克雷边界条件 $u=0$。\n\n您必须：\n- 在一个顶点为 $(0,0)$、$(1,0)$ 和 $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$ 的等边三角形区域 $\\Omega$ 上，推导该初边值问题的弱形式。在一个通过将该等边三角形细分为 $N \\times N$ 个均匀子三角形（所有内角严格小于 $90^\\circ$）而获得的协调、形状规则的锐角三角剖分上，使用连续分片线性试探函数和检验函数。使用一致质量矩阵。\n- 使用 Crank-Nicolson 方法，以时间步长 $\\Delta t$ 和零源项对时间进行离散，即对半离散系统应用梯形法则。通过消除边界自由度，在每个时间步强加狄利克雷边界条件。\n- 使用初始条件 $u(\\boldsymbol{x},0) = \\exp\\!\\big(-\\|\\boldsymbol{x}-\\boldsymbol{x}_c\\|^2/(2\\sigma^2)\\big)$，其中 $\\boldsymbol{x}_c$ 是顶部的顶点 $(\\tfrac{1}{2},\\tfrac{\\sqrt{3}}{2})$，并在边界节点处设置 $u=0$ 以与边界条件保持一致。对于较小的 $\\sigma$，此选择会产生强的空间梯度。\n- 通过追踪所有时间步中节点值的最小值和最大值来评估数值解随时间的正性，并计算一个布尔值，指示解是否在容差 $\\varepsilon = 10^{-12}$ 内保持非负。同时，使用仿真过程中遇到的全局最小值和最大值计算一个下冲比 $r = \\max(0,-\\min u)/\\max u$，其中最大值是在所有节点和所有时间步上取到的。如果 $\\max u$ 在容差范围内为零，则定义 $r=0$ 以避免除以零。\n\n您的程序必须从第一性原理出发实现以下内容：\n- 在 $\\Omega$ 上经过分部积分后，且在 $\\partial \\Omega$ 上 $u=0$ 的热方程的弱形式。\n- 使用三角形上的线性形函数组装全局一致质量矩阵和刚度矩阵。\n- 半离散系统的 Crank-Nicolson 更新。\n- 使用网格的格点描述来识别等边三角剖分的边界节点。\n\n您必须在以下参数值 $(N,\\Delta t, n_{\\text{steps}}, \\sigma)$ 的测试套件上运行求解器：\n- 情况 1：$(12, 5\\times 10^{-4}, 40, 0.04)$。\n- 情况 2：$(12, 5\\times 10^{-3}, 4, 0.02)$。\n- 情况 3：$(8, 1\\times 10^{-2}, 3, 0.015)$。\n- 情况 4：$(20, 1\\times 10^{-3}, 20, 0.04)$。\n\n对于每种情况，您必须：\n- 按上述描述，用每边 $N$ 个细分来组装网格。\n- 从高斯函数初始化 $u^0$ 并在边界节点处强制 $u=0$。\n- 使用 Crank-Nicolson 方法和时间步长 $\\Delta t$ 推进 $n_{\\text{steps}}$ 步。\n- 记录所有节点和所有时间步上的全局最小值 $m$ 和最大值 $M$，计算布尔值 $\\text{nonneg} = (m \\ge -\\varepsilon)$（其中 $\\varepsilon = 10^{-12}$），并按上述定义计算下冲比 $r$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，按此顺序输出一个形如 $[m, M, \\text{nonneg}, r]$ 的列表，其中 $m$ 和 $M$ 是浮点数，$\\text{nonneg}$ 是布尔值， $r$ 是浮点数。总输出必须是这些单用例列表的列表，例如：\n\"[ [m1,M1,nonneg1,r1], [m2,M2,nonneg2,r2], [m3,M3,nonneg3,r3], [m4,M4,nonneg4,r4] ]\"\n所有数字都是无量纲的；不需要物理单位。\n\n您的实现必须是一个完整的、可运行的程序。不允许用户输入；所有参数均按上述规定。您的代码必须仅依赖于允许的库，并且必须符合本任务其他地方说明的执行环境。", "solution": "所提出的问题是一个良定的、具有科学依据的偏微分方程数值解练习。它要求在特定的区域几何上实现一个用于瞬态热方程的有限元方法（FEM）求解器。所有必要的物理定律、数学公式和数值参数都已提供。该问题要求分析一个关键的数值性质，即 Crank-Nicolson 时间步进格式在锐角三角剖分上的正性保持，这是一个数值分析中的经典课题。其前提——网格的锐角性质以及时间步相对于网格间距的大小对此性质至关重要——是正确的。此问题是有效的，我将着手提供一个完整的解决方案。\n\n推导和实现将遵循以下步骤：\n1.  **弱形式**：控制方程是无量纲化的热方程，$\\partial_t u - \\Delta u = 0$ 在区域 $\\Omega$ 内，边界 $\\partial\\Omega$ 上具有齐次狄利克雷边界条件 $u=0$。为了推导弱形式，我们将其乘以一个来自 Sobolev 空间 $H_0^1(\\Omega)$（一阶导数平方可积且在边界 $\\partial\\Omega$ 上为零的函数空间）的检验函数 $v$，并在 $\\Omega$ 上积分：\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} - \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = 0 $$\n    对第二项应用格林第一恒等式（分部积分）得到：\n    $$ \\int_{\\Omega} (\\Delta u) v \\, d\\boldsymbol{x} = - \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} + \\int_{\\partial\\Omega} (\\nabla u \\cdot \\boldsymbol{n}) v \\, dS $$\n    由于检验函数 $v \\in H_0^1(\\Omega)$，因此在边界 $\\partial\\Omega$ 上 $v=0$，这使得边界积分为零。于是弱形式为：求 $u(\\cdot, t) \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$：\n    $$ \\int_{\\Omega} (\\partial_t u) v \\, d\\boldsymbol{x} + \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, d\\boldsymbol{x} = 0 $$\n\n2.  **空间离散化 (FEM)**：我们在有限维子空间 $V_h \\subset H_0^1(\\Omega)$ 中寻求一个近似解 $u_h(\\boldsymbol{x}, t)$。我们将 $u_h$ 定义为与网格内部节点相关的基函数 $\\phi_j(\\boldsymbol{x})$ 的线性组合：\n    $$ u_h(\\boldsymbol{x}, t) = \\sum_{j \\in \\mathcal{I}} U_j(t) \\phi_j(\\boldsymbol{x}) $$\n    其中 $\\mathcal{I}$ 是内部节点的索引集，$U_j(t)$ 是表示这些节点上温度的未知时间相关系数。通过选择检验函数 $v$ 为基函数 $\\phi_i$（其中 $i \\in \\mathcal{I}$，即伽辽金法），我们得到一个常微分方程（ODEs）组：\n    $$ \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}\\right) \\frac{dU_j}{dt} + \\sum_{j \\in \\mathcal{I}} \\left(\\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x}\\right) U_j(t) = 0, \\quad \\forall i \\in \\mathcal{I} $$\n    这是半离散系统，写成矩阵形式为：\n    $$ M \\frac{d\\boldsymbol{U}}{dt} + K \\boldsymbol{U} = \\boldsymbol{0} $$\n    其中 $\\boldsymbol{U}(t)$ 是节点值 $\\{U_j(t)\\}_{j \\in \\mathcal{I}}$ 的向量。矩阵 $M$ 和 $K$ 分别是一致质量矩阵和刚度矩阵，它们被限制在内部自由度上。它们的元素为：\n    $$ M_{ij} = \\int_{\\Omega} \\phi_i \\phi_j \\, d\\boldsymbol{x}, \\quad K_{ij} = \\int_{\\Omega} \\nabla\\phi_i \\cdot \\nabla\\phi_j \\, d\\boldsymbol{x} $$\n\n3.  **时间离散化 (Crank–Nicolson)**：我们使用梯形法则（Crank–Nicolson 格式）和时间步长 $\\Delta t$ 对时间导数进行离散，其中 $\\boldsymbol{U}^n \\approx \\boldsymbol{U}(n\\Delta t)$：\n    $$ M \\frac{\\boldsymbol{U}^{n+1} - \\boldsymbol{U}^n}{\\Delta t} + K \\frac{\\boldsymbol{U}^{n+1} + \\boldsymbol{U}^n}{2} = \\boldsymbol{0} $$\n    重新整理各项以求解下一时间步的未知状态 $\\boldsymbol{U}^{n+1}$，得到线性系统：\n    $$ \\left(M + \\frac{\\Delta t}{2} K\\right) \\boldsymbol{U}^{n+1} = \\left(M - \\frac{\\Delta t}{2} K\\right) \\boldsymbol{U}^n $$\n    该系统必须在每个时间步求解。左侧的矩阵是恒定的，因此可以预先计算其分解以提高效率。\n\n4.  **单元矩阵**：全局矩阵 $M$ 和 $K$ 是通过对局部单元矩阵 $M^e$ 和 $K^e$ 的贡献求和来组装的。对于使用边长为 $h = 1/N$ 的等边三角形的均匀剖分，所有单元矩阵都是相同的。每个单元的面积是 $A = \\frac{\\sqrt{3}}{4}h^2$。对于分片线性（$\\mathbb{P}_1$）基函数，单元刚度矩阵和质量矩阵为：\n    $$ K^e = \\frac{1}{2\\sqrt{3}} \\begin{pmatrix} 2  -1  -1 \\\\ -1  2  -1 \\\\ -1  -1  2 \\end{pmatrix}, \\quad M^e = \\frac{A}{12} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} = \\frac{\\sqrt{3}h^2}{48} \\begin{pmatrix} 2  1  1 \\\\ 1  2  1 \\\\ 1  1  2 \\end{pmatrix} $$\n    单元刚度矩阵 $K^e$ 具有非正的非对角线元素，其组装结果是，对于锐角三角剖分，全局刚度矩阵 $K$ 是一个M-矩阵。这个性质对于离散极值原理至关重要。然而，Crank-Nicolson 更新矩阵 $(M + \\frac{\\Delta t}{2} K)^{-1} (M - \\frac{\\Delta t}{2} K)$ 并不保证正性，除非满足一个关于 $\\Delta t$ 的条件。具体来说，如果矩阵 $M - \\frac{\\Delta t}{2} K$ 是非负的，则正性得以维持，这施加了一个形式为 $\\Delta t \\le C h^2$ 的类CFL条件。问题中的用例旨在探测这个条件：具有较大 $\\Delta t$ 的用例预计会违反它并产生伪振荡（下冲），导致出现负的温度值，即使初始条件处处非负。\n\n5.  **实现策略**：\n    - **网格**：一个顶点为 $(0,0)$、$(1,0)$ 和 $(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ 的等边三角形区域被剖分成 $N^2$ 个较小的等边三角形。节点使用重心坐标系生成。一个节点 $\\boldsymbol{x}_{ijk}$ 由 $\\boldsymbol{x}_{ijk} = \\frac{i}{N}(0,0) + \\frac{j}{N}(1,0) + \\frac{k}{N}(\\frac{1}{2},\\frac{\\sqrt{3}}{2})$ 定义，其中 $i,j,k$ 是非负整数且 $i+j+k=N$。我们可以使用 $(j,k)$ 作为独立索引（$j,k \\ge 0$, $j+k \\le N$）。\n    - **组装**：通过迭代所有单元并将局部单元矩阵的贡献加到相应的全局索引上，来组装全局 $M$ 和 $K$ 矩阵。\n    - **边界条件**：通过识别所有边界节点（在重心坐标索引中 $i=0$ 或 $j=0$ 或 $k=0$）并将线性系统限制在仅内部节点上，来强制施加狄利克雷边界条件（$u=0$）。\n    - **时间推进**：通过在所有内部节点坐标处评估高斯函数并设置边界节点为 $0$ 来构造初始条件向量 $\\boldsymbol{U}^0$。然后，通过重复求解 Crank-Nicolson 线性系统，模拟进行 $n_{\\text{steps}}$ 步。\n    - **分析**：在模拟过程中，从 $t=0$ 到 $t_{final}$ 的每个时间步，追踪所有节点（内部和边界）的最小和最大节点值。这些值用于计算最终所需的指标：全局最小值 $m$、全局最大值 $M$、表示正性的布尔值 `nonneg` 以及下冲比 $r$。\n\n以下程序从第一性原理出发实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Main function to run the FEM solver for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (N, dt, n_steps, sigma)\n        (12, 5e-4, 40, 0.04),\n        (12, 5e-3, 4, 0.02),\n        (8, 1e-2, 3, 0.015),\n        (20, 1e-3, 20, 0.04),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        N, dt, n_steps, sigma = params\n        result = run_simulation(N, dt, n_steps, sigma)\n        all_results.append(result)\n\n    # Format the final output string\n    # E.g., [[-2.3e-05, 0.9, False, 2.5e-05], ...]\n    # using f-strings for demonstration of format. The exact values will be computed.\n    result_str = \"[\" + \", \".join([\n        f\"[{m:.8e}, {M:.8e}, {str(nonneg).lower()}, {r:.8e}]\"\n        for m, M, nonneg, r in all_results\n    ]) + \"]\"\n    print(result_str)\n\ndef run_simulation(N, dt, n_steps, sigma):\n    \"\"\"\n    Runs a single simulation for the transient heat equation using FEM.\n    \n    Args:\n        N (int): Number of subdivisions along each edge of the domain.\n        dt (float): Time step size.\n        n_steps (int): Number of time steps to perform.\n        sigma (float): Standard deviation of the initial Gaussian pulse.\n\n    Returns:\n        tuple: A tuple containing (m, M, nonneg, r) for the simulation.\n    \"\"\"\n    TOL = 1.0e-12\n\n    # 1. Mesh Generation\n    # Vertices of the main equilateral triangle\n    v1 = np.array([0.0, 0.0])\n    v2 = np.array([1.0, 0.0])\n    v3 = np.array([0.5, np.sqrt(3.0) / 2.0])\n\n    # Generate nodes using barycentric coordinates\n    nodes = []\n    node_map = {}  # maps (j, k) -> node_idx\n    idx_counter = 0\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            coord = (j / N) * v2 + (k / N) * v3  # v1 is origin\n            nodes.append(coord)\n            node_map[(j, k)] = idx_counter\n            idx_counter += 1\n    nodes = np.array(nodes)\n    num_nodes = len(nodes)\n\n    # Generate elements (triangles)\n    elements = []\n    # \"Up\" pointing triangles\n    for k in range(N):\n        for j in range(N - k):\n            v_idx1 = node_map[(j, k)]\n            v_idx2 = node_map[(j + 1, k)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    # \"Down\" pointing triangles\n    for k in range(N - 1):\n        for j in range(N - k - 1):\n            v_idx1 = node_map[(j + 1, k)]\n            v_idx2 = node_map[(j + 1, k + 1)]\n            v_idx3 = node_map[(j, k + 1)]\n            elements.append([v_idx1, v_idx2, v_idx3])\n    \n    # Identify interior and boundary nodes\n    interior_nodes_indices = []\n    boundary_nodes_indices = []\n    for k in range(N + 1):\n        for j in range(N - k + 1):\n            i = N - j - k\n            idx = node_map[(j, k)]\n            if i > 0 and j > 0 and k > 0:\n                interior_nodes_indices.append(idx)\n            else:\n                boundary_nodes_indices.append(idx)\n\n    # 2. Assemble Matrices\n    h = 1.0 / N\n    area = np.sqrt(3.0) / 4.0 * h**2\n    \n    # Element stiffness matrix for equilateral triangle\n    K_e = (1.0 / (2.0 * np.sqrt(3.0))) * np.array([[2, -1, -1], [-1, 2, -1], [-1, -1, 2]])\n    # Element mass matrix\n    M_e = (area / 12.0) * np.array([[2, 1, 1], [1, 2, 1], [1, 1, 2]])\n\n    M = np.zeros((num_nodes, num_nodes))\n    K = np.zeros((num_nodes, num_nodes))\n\n    for el in elements:\n        for i in range(3):\n            for j in range(3):\n                gi, gj = el[i], el[j]\n                M[gi, gj] += M_e[i, j]\n                K[gi, gj] += K_e[i, j]\n    \n    # Extract submatrices for interior nodes\n    ix = np.ix_(interior_nodes_indices, interior_nodes_indices)\n    M_int = M[ix]\n    K_int = K[ix]\n    \n    # 3. Initial Condition\n    u0 = np.zeros(num_nodes)\n    xc = v3\n    for i in range(num_nodes):\n        if i in interior_nodes_indices:\n            dist_sq = np.sum((nodes[i] - xc)**2)\n            u0[i] = np.exp(-dist_sq / (2.0 * sigma**2))\n    \n    global_min = np.min(u0)\n    global_max = np.max(u0)\n\n    u_int = u0[interior_nodes_indices]\n\n    # 4. Time Stepping\n    A = M_int + (dt / 2.0) * K_int\n    B = M_int - (dt / 2.0) * K_int\n    \n    # Pre-factorize A\n    lu, piv = lu_factor(A)\n    \n    u_current_full = np.copy(u0)\n\n    for step in range(n_steps):\n        rhs = B @ u_int\n        u_int = lu_solve((lu, piv), rhs)\n        \n        # Update full solution vector and track min/max\n        u_current_full[interior_nodes_indices] = u_int\n        step_min = np.min(u_current_full)\n        step_max = np.max(u_current_full)\n        \n        if step_min  global_min:\n            global_min = step_min\n        if step_max > global_max:\n            global_max = step_max\n\n    # 5. Compute final metrics\n    m = global_min\n    M = global_max\n    \n    nonneg = m >= -TOL\n    \n    if M  TOL:\n        r = 0.0\n    else:\n        r = max(0.0, -m) / M\n        \n    return m, M, nonneg, r\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2607746"}, {"introduction": "对于具有动态行为（如移动热源）的问题，模拟效率至关重要。本实践超越了固定的时间步长，要求您实现一个自适应求解器，该求解器能自动调整步长以在需要时集中计算资源，从而在保证精度的前提下提高效率。这个练习展示了如何构建更智能、更实用的科学计算软件，是从基础求解器迈向稳健高效工具的关键一步。[@problem_id:2607783]", "problem": "考虑一个固定空间域上带有局部移动热源的一维瞬态热扩散问题。其控制偏微分方程为热方程\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T],\n$$\n边界条件为齐次 Dirichlet 边界条件\n$$\nu(0,t) = 0, \\quad u(L,t) = 0, \\quad t \\in (0,T],\n$$\n初始条件为\n$$\nu(x,0) = 0, \\quad x \\in [0,L].\n$$\n源项是一个移动的高斯函数，形式如下\n$$\ns(x,t) = A \\exp\\!\\left(-\\frac{\\left(x - x_c(t)\\right)^2}{2\\sigma^2}\\right),\n$$\n其中高斯函数的中心位置按以下规律移动\n$$\nx_c(t) = x_0 + v t,\n$$\n速度参数 $v$ 为常数。假设 $k = 1$, $L = 1$, $T = 0.5$, $A = 10$, $\\sigma = 0.05$ 且 $x_0 = 0.2$。在整个问题中，将空间网格取为 $[0,L]$ 上的一个均匀划分，包含 $N_e = 100$ 个线性有限元（即 $N_n = 101$ 个节点），并使用标准的 Galerkin 方法，基函数为连续分段线性函数；使用一致质量矩阵。\n\n任务：\n1. 从偏微分方程的强形式和上述边界/初始条件出发，推导出弱形式以及关于时间变化的有限元系数的半离散常微分方程组。不要使用任何快捷公式；从加权残差的定义开始，通过分部积分进行推导，并仔细论证在给定边界条件下边界项的处理方法。\n2. 从半离散系统出发，推导一种基于步长加倍进行局部误差控制的可变步长 Crank–Nicolson 时间离散格式。其接受准则必须由以下误差估计定义：给定一个大小为 $\\Delta t$ 的完整步长和两个大小为 $\\Delta t/2$ 的半步长，计算这两个步末解的差值，并将标量误差定义为该差值的质量矩阵加权欧几里得范数除以未知数数量的平方根。以此作为局部截断误差的代理。设计一个时间步长控制器，当误差最多为给定容差时接受该步长，并使用适合于局部误差以 $\\mathcal{O}(\\Delta t^3)$ 尺度变化的方法的幂律法则来更新下一步长 $\\Delta t_{\\text{new}}$。你的控制器还必须强制执行最小和最大时间步长，以及有界的增长/收缩因子，以避免极端变化。\n3. 将在一个被接受的时间层级上的“锋面位置”定义为分段常数有限元梯度（由相邻节点值计算）的模达到最大的网格单元的中点。对于一个由 $i = 1, 2, \\dots, M$ 索引的已接受步长序列，其接受的时间步长为 $\\Delta t_i$，相应的前后锋面位置为 $x^{\\text{front}}_{i-1}$ 和 $x^{\\text{front}}_{i}$，将瞬时锋面速度大小定义为\n$$\n\\lvert v^{\\text{front}}_i \\rvert = \\frac{\\left|x^{\\text{front}}_{i} - x^{\\text{front}}_{i-1}\\right|}{\\Delta t_i}.\n$$\n为量化步长控制如何跟随锋面速度，定义追踪度量时间序列为\n$$\ny_i = \\frac{1}{\\varepsilon + \\lvert v^{\\text{front}}_i \\rvert},\n$$\n其中正则化参数 $\\varepsilon = 10^{-8}$ 用于避免除以零。计算在区间 $(0,T]$ 内所有已接受步长的两个序列 $\\{\\Delta t_i\\}$ 和 $\\{y_i\\}$ 之间的 Pearson 相关系数。如果任一序列的方差为零，则定义相关系数为 $0$。\n4. 实现完整的有限元求解器，包括可变步长 Crank–Nicolson 格式和步长加倍控制器。使用以下控制器和数值参数：初始时间步长 $\\Delta t_0 = 10^{-3}$，最小步长 $\\Delta t_{\\min} = 10^{-4}$，最大步长 $\\Delta t_{\\max} = 2\\times 10^{-2}$，容差 $\\text{tol} = 10^{-4}$，安全因子 $\\eta = 0.9$，最大增长因子 $g_{\\max} = 2.0$，最小收缩因子 $g_{\\min} = 0.5$。当一个步长被接受时，使用两个半步长计算得到的更精确的解来推进。通过在必要时缩短最后一步，确保最终时间 $T$ 被精确匹配。\n5. 测试组。对以下三种速度运行求解器\n$$\nv \\in \\{0.0, \\; 0.4, \\; 0.8\\},\n$$\n所有其他参数保持如上所述固定不变，并按上述方法计算每种情况下的相关系数。输出是无量纲的实数。\n6. 要求的最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试组中的速度顺序一致，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3].\n$$\n不应打印任何额外文本。\n\n注释：\n- 此问题不涉及角度，因此不需要角度单位。\n- 输出是无物理单位的纯数。\n- 通过执行所述的接受/拒绝逻辑并限制时间步长来确保科学真实性；不要依赖任何未说明的公式。", "solution": "所提出的问题是偏微分方程数值解的一个标准练习，具体涉及瞬态热方程。它要求应用有限元方法（FEM）进行空间离散化，并采用自适应隐式时间步进格式进行时间演化。该问题定义明确、科学上合理，并包含唯一数值解所需的所有参数。我们着手进行推导和实现。\n\n**1. 弱形式与空间离散化**\n\n该问题由一维热方程的强形式控制：\n$$\n\\frac{\\partial u}{\\partial t} = k \\frac{\\partial^2 u}{\\partial x^2} + s(x,t), \\quad x \\in (0,L), \\; t \\in (0,T]\n$$\n边界条件为齐次 Dirichlet 边界条件，$u(0,t) = u(L,t) = 0$，初始条件为零，$u(x,0) = 0$。\n\n为了推导弱形式，我们将偏微分方程乘以一个来自合适函数空间的任意检验函数 $w(x)$，并在空间域 $\\Omega = (0,L)$ 上积分。检验函数选自 Sobolev 空间 $H_0^1(0,L)$，该空间由平方可积、一阶导数平方可积且在边界 $x=0$ 和 $x=L$ 处为零的函数组成。这得到了加权残差陈述：\n$$\n\\int_0^L \\left( \\frac{\\partial u}{\\partial t} - k \\frac{\\partial^2 u}{\\partial x^2} - s(x,t) \\right) w(x) \\, dx = 0 \\quad \\forall w \\in H_0^1(0,L)\n$$\n我们对扩散项应用分部积分，以降低空间导数的阶数，并将一个导数从解 $u$ 转移到检验函数 $w$ 上：\n$$\n- \\int_0^L \\frac{\\partial^2 u}{\\partial x^2} w(x) \\, dx = \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx - \\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L\n$$\n边界项 $\\left[ \\frac{\\partial u}{\\partial x} w(x) \\right]_0^L = \\frac{\\partial u}{\\partial x}(L,t)w(L) - \\frac{\\partial u}{\\partial x}(0,t)w(0)$ 恒为零，因为根据检验空间 $H_0^1(0,L)$ 的定义，有 $w(0)=0$ 和 $w(L)=0$。这导出了问题的弱形式：寻找 $u(t) \\in H^1(0,L)$，满足 $u(0,t)=u(L,t)=0$，使得对于所有 $w \\in H_0^1(0,L)$：\n$$\n\\int_0^L \\frac{\\partial u}{\\partial t} w \\, dx + k \\int_0^L \\frac{\\partial u}{\\partial x} \\frac{\\partial w}{\\partial x} \\, dx = \\int_0^L s(x,t) w \\, dx\n$$\n对于有限元方法，我们在由分段线性基函数 $N_j(x)$ 张成的有限维子空间 $V_h \\subset H^1(0,L)$ 中逼近解 $u(x,t)$：\n$$\nu(x,t) \\approx u_h(x,t) = \\sum_{j=1}^{N_n} U_j(t) N_j(x)\n$$\n其中 $U_j(t)$ 是随时间变化的节点值。边界条件 $u(0,t)=0$ 和 $u(L,t)=0$ 强制 $U_1(t)=0$ 和 $U_{N_n}(t)=0$，剩下 $N_{dof} = N_n-2$ 个内部节点值作为未知数。Galerkin 方法对检验空间采用相同的基函数，即对于每个内部节点 $i \\in \\{2, \\ldots, N_n-1\\}$，有 $w(x) = N_i(x)$。将近似解代入弱形式，得到一个常微分方程（ODE）组：\n$$\n\\sum_{j=2}^{N_n-1} \\left( \\int_0^L N_i N_j \\, dx \\right) \\frac{dU_j}{dt} + k \\sum_{j=2}^{N_n-1} \\left( \\int_0^L \\frac{dN_i}{dx} \\frac{dN_j}{dx} \\, dx \\right) U_j = \\int_0^L s(x,t) N_i \\, dx\n$$\n这就是半离散系统，可以表示为矩阵形式：\n$$\nM \\frac{d\\mathbf{U}}{dt} + k K \\mathbf{U} = \\mathbf{F}(t)\n$$\n其中 $\\mathbf{U}(t)$ 是 $N_{dof}$ 个未知内部节点值的向量。系统矩阵为：\n- **一致质量矩阵**: $M_{ij} = \\int_0^L N_i(x) N_j(x) \\, dx$\n- **刚度矩阵**: $K_{ij} = \\int_0^L \\frac{dN_i}{dx}\\frac{dN_j}{dx} \\, dx$\n- **载荷向量**: $F_i(t) = \\int_0^L s(x,t) N_i(x) \\, dx$\n\n**2. 时间离散化与自适应步长控制**\n\n该半离散 ODE 系统使用 Crank–Nicolson 方法求解，这是一种二阶精度的隐式格式。在时间上从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 进行离散，其格式为：\n$$\nM \\frac{\\mathbf{U}_{n+1} - \\mathbf{U}_n}{\\Delta t} = \\frac{1}{2}\\left[ (\\mathbf{F}_n - kK\\mathbf{U}_n) + (\\mathbf{F}_{n+1} - kK\\mathbf{U}_{n+1}) \\right]\n$$\n重新整理以分离未知向量 $\\mathbf{U}_{n+1}$，得到在每个时间步需要求解的线性系统：\n$$\n\\left( M + \\frac{k\\Delta t}{2}K \\right) \\mathbf{U}_{n+1} = \\left( M - \\frac{k\\Delta t}{2}K \\right) \\mathbf{U}_n + \\frac{\\Delta t}{2}(\\mathbf{F}_n + \\mathbf{F}_{n+1})\n$$\n自适应时间步长通过步长加倍实现。Crank-Nicolson 方法的局部截断误差（LTE）为 $\\mathcal{O}(\\Delta t^3)$。我们在 $t_{n+1}$ 处计算两个解：$\\mathbf{U}_{n+1}^{(1)}$ 使用一个大小为 $\\Delta t$ 的步长得到，而 $\\mathbf{U}_{n+1}^{(2)}$ 使用两个大小为 $\\Delta t/2$ 的步长得到。差分向量 $\\mathbf{d} = \\mathbf{U}_{n+1}^{(2)} - \\mathbf{U}_{n+1}^{(1)}$ 作为 LTE 的估计。一个标量误差度量被定义为该差值的质量矩阵加权范数：\n$$\n\\text{err} = \\frac{\\sqrt{\\mathbf{d}^T M \\mathbf{d}}}{\\sqrt{N_{dof}}}\n$$\n如果 $\\text{err} \\le \\text{tol}$，则接受该步长，并使用更精确的结果推进求解：$\\mathbf{U}_{n+1} = \\mathbf{U}_{n+1}^{(2)}$。如果不满足，则拒绝该步长，并用一个更小的 $\\Delta t$ 重复计算。新的步长根据误差缩放特性计算：\n$$\n\\Delta t_{\\text{new}} = \\eta \\, \\Delta t \\left( \\frac{\\text{tol}}{\\text{err}} \\right)^{1/3}\n$$\n其中 $\\eta$ 是一个安全因子。步长还受到指定的最小/最大值以及增长/收缩因子的限制，以确保控制器的稳定性。\n\n**3. 实现与最终分析**\n\n该算法用 Python 实现。矩阵 $M$ 和 $K$ 是为内部自由度组装的。载荷向量 $\\mathbf{F}(t)$ 需要将源项与每个基函数进行数值积分，`scipy.integrate.quad` 适用于此任务。时间步进循环执行自适应 Crank–Nicolson 格式，直到达到最终时间 $T$。在每个被接受的步长，锋面位置被确定为具有最大梯度模的单元的中点。最后，计算已接受时间步长序列 $\\{\\Delta t_i\\}$ 与定义为锋面速度倒数的追踪度量 $\\{y_i\\}$ 之间的 Pearson 相关系数。对每个指定的源速度 $v$ 执行此分析。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve_for_v(v_val, params):\n    \"\"\"\n    Solves the 1D transient heat equation for a given source speed v.\n    \"\"\"\n    # --- Problem Parameters ---\n    k, L, T_final, A, sigma, x0 = params['phys']\n    v = v_val\n\n    # --- Numerical Parameters ---\n    Ne, TOL, DT_INIT, DT_MIN, DT_MAX, ETA, G_MAX, G_MIN, EPS_REG = params['num']\n    Nn = Ne + 1\n    Ndof = Nn - 2\n    h = L / Ne\n\n    # --- Spatial Grid ---\n    nodes = np.linspace(0, L, Nn)\n\n    # --- Assemble Mass and Stiffness Matrices (for interior nodes) ---\n    M = np.zeros((Ndof, Ndof))\n    K = np.zeros((Ndof, Ndof))\n\n    diag_M = 2 * h / 3\n    offdiag_M = h / 6\n    diag_K = 2 / h\n    offdiag_K = -1 / h\n\n    for i in range(Ndof):\n        M[i, i] = diag_M\n        K[i, i] = diag_K\n        if i > 0:\n            M[i, i-1] = offdiag_M\n            K[i, i-1] = offdiag_K\n        if i  Ndof - 1:\n            M[i, i+1] = offdiag_M\n            K[i, i+1] = offdiag_K\n\n    # --- Source Term Functions ---\n    def source_center(t):\n        return x0 + v * t\n\n    def source_func(x, t):\n        xc = source_center(t)\n        return A * np.exp(-(x - xc)**2 / (2 * sigma**2))\n\n    # --- Force Vector Calculation ---\n    memo_F = {}\n    def get_force_vector(t):\n        if t in memo_F:\n            return memo_F[t]\n\n        F = np.zeros(Ndof)\n        for i_dof in range(Ndof):\n            i_glob = i_dof + 1\n            x_prev, x_curr, x_next = nodes[i_glob-1], nodes[i_glob], nodes[i_glob+1]\n            \n            def N_left(x): return (x - x_prev) / h\n            def N_right(x): return (x_next - x) / h\n            \n            integral_left, _ = quad(lambda x: source_func(x, t) * N_left(x), x_prev, x_curr, epsabs=1e-9)\n            integral_right, _ = quad(lambda x: source_func(x, t) * N_right(x), x_curr, x_next, epsabs=1e-9)\n            \n            F[i_dof] = integral_left + integral_right\n        \n        memo_F[t] = F\n        return F\n\n    # --- Front Location Calculation ---\n    def get_front_location(U_full):\n        grads = np.abs(np.diff(U_full)) / h\n        max_grad_elem_idx = np.argmax(grads)\n        return (nodes[max_grad_elem_idx] + nodes[max_grad_elem_idx + 1]) / 2\n\n    # --- Time Marching Loop ---\n    t = 0.0\n    dt = DT_INIT\n    U = np.zeros(Ndof)\n\n    initial_elem_idx = int(np.floor(x0 / h))\n    x_front_0 = (nodes[initial_elem_idx] + nodes[initial_elem_idx+1]) / 2.0\n    \n    accepted_steps = []\n    front_locations = [x_front_0]\n\n    while t  T_final:\n        final_step = False\n        if t + dt >= T_final:\n            dt = T_final - t\n            final_step = True\n        \n        if dt  1e-12: break\n\n        # --- Step Doubling ---\n        dt_full = dt\n        A1 = M + (k * dt_full / 2) * K\n        F_n = get_force_vector(t)\n        F_n1 = get_force_vector(t + dt_full)\n        b1 = (M - (k * dt_full / 2) * K) @ U + (dt_full / 2) * (F_n + F_n1)\n        U_n1_1 = np.linalg.solve(A1, b1)\n\n        dt_half = dt / 2\n        A2 = M + (k * dt_half / 2) * K\n        F_n_half = get_force_vector(t + dt_half)\n        \n        b2_1 = (M - (k * dt_half / 2) * K) @ U + (dt_half / 2) * (F_n + F_n_half)\n        U_n_half = np.linalg.solve(A2, b2_1)\n        \n        b2_2 = (M - (k * dt_half / 2) * K) @ U_n_half + (dt_half / 2) * (F_n_half + F_n1)\n        U_n1_2 = np.linalg.solve(A2, b2_2)\n\n        # --- Error Estimation ---\n        d = U_n1_2 - U_n1_1\n        err = np.sqrt(np.dot(d, M @ d) / Ndof)\n        \n        # --- Step Control ---\n        if err = TOL or final_step:\n            t += dt\n            U = U_n1_2\n            \n            accepted_steps.append(dt)\n            U_full = np.concatenate(([0], U, [0]))\n            front_loc = get_front_location(U_full)\n            front_locations.append(front_loc)\n\n            if final_step: break\n                \n            if err  1e-12:\n                dt_new = G_MAX * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            \n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n        else:\n            if err  1e-12:\n                dt_new = G_MIN * dt\n            else:\n                dt_new = ETA * dt * (TOL / err)**(1/3.0)\n            dt = np.clip(dt_new, G_MIN * dt, G_MAX * dt)\n            dt = np.clip(dt, DT_MIN, DT_MAX)\n\n    # --- Post-processing: Correlation Calculation ---\n    delta_t_seq = np.array(accepted_steps)\n    front_loc_seq = np.array(front_locations)\n    \n    if len(delta_t_seq)  2: return 0.0\n\n    front_speeds = np.abs(np.diff(front_loc_seq)) / delta_t_seq\n    y_seq = 1.0 / (EPS_REG + front_speeds)\n\n    if np.var(delta_t_seq) == 0 or np.var(y_seq) == 0:\n        return 0.0\n    else:\n        return np.corrcoef(delta_t_seq, y_seq)[0, 1]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    params = {\n        'phys': (1.0, 1.0, 0.5, 10.0, 0.05, 0.2), # k, L, T, A, sigma, x0\n        'num': (100, 1.0e-4, 1.0e-3, 1.0e-4, 2.0e-2, 0.9, 2.0, 0.5, 1.0e-8) # Ne, TOL, ...\n    }\n    \n    test_cases_v = [0.0, 0.4, 0.8]\n    results = [solve_for_v(v, params) for v in test_cases_v]\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2607783"}]}