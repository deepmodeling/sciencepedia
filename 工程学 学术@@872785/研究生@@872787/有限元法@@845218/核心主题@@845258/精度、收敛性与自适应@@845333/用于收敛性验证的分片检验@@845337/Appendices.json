{"hands_on_practices": [{"introduction": "一个单元能否通过特定阶次的分片检验，其根本在于其近似空间能否精确表示检验所用的多项式场。本练习将让你通过一个具体例子，识别一个不完备的多项式基中缺失的关键项，从而直观理解多项式完备性对于确保收敛性的核心作用。[@problem_id:2605451]", "problem": "考虑一个二维小应变线性弹性问题，该问题在一个由直边三角形单元组成的单元片上，通过基于位移的 $C^0$ 连续有限元法进行离散。每个单元从参考三角形到物理坐标的映射都是仿射的，因此物理坐标 $(x,y)$ 线性地依赖于参考坐标。\n\n您计划对每个位移分量 $u(x,y)$ 和 $v(x,y)$ 使用相同的标量多项式逼近，即一个由 $(x,y)$ 的单项式构成的基。具体来说，您当前为每个分量选择的基是\n$$\n\\mathcal{B}=\\{1,\\, x,\\, y,\\, x^{2},\\, y^{2}\\}.\n$$\n\n为了通过分片检验进行收敛性验证，您要求单元通过二次分片检验，这意味着当单元在一个无体力、且边界牵引力与某个二次位移场一致的单元片上组合时，每个单元必须能够精确地重现该二次位移场。在所述条件下（仿射映射和基于位移的格式），这个要求等价于每个分量的标量逼近空间包含 $(x,y)$ 中总次数最高为 $2$ 的完备二元多项式空间。\n\n请确定必须添加到基 $\\mathcal{B}$ 中的那个具有最小总次数的唯一单项式，以使得最终的标量逼近空间包含 $(x,y)$ 中的所有二次多项式，从而使单元能够通过二次分片检验。请用 $x$ 和 $y$ 表示该单项式作为您的答案。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且客观的。它提出了一个有限元方法理论中的标准问题。我现在开始解答。\n\n问题要求确定必须添加到给定基中的具体单项式，以确保单元格式能通过二次分片检验。问题明确指出，在给定条件下（基于位移的 $C^0$ 格式，具有仿射映射的直边三角形单元），通过二次分片检验等价于每个位移分量的标量逼近空间包含总次数最高为 $2$ 的完备二元多项式空间。设此空间为 $\\mathcal{P}_2(x,y)$。\n\n如果一个多项式空间包含了所有总次数小于或等于 $k$ 的单项式，那么它就被称为“k次完备的”。单项式 $x^a y^b$ 的总次数定义为其指数之和 $a+b$。\n\n空间 $\\mathcal{P}_2(x,y)$ 是所有满足以下条件的多项式 $p(x,y)$ 的集合：\n$$\np(x,y) = \\sum_{i+j \\le 2} c_{ij} x^i y^j\n$$\n其中 $c_{ij}$ 是常系数。为了构成该空间的基，我们必须包含所有满足非负整数 $i$ 和 $j$ 条件 $i+j \\le 2$ 的单项式 $x^i y^j$。让我们系统地列举这些单项式：\n\n1.  总次数 $0$：$i+j=0$。唯一可能是 $i=0, j=0$，对应于单项式 $x^0 y^0 = 1$。\n2.  总次数 $1$：$i+j=1$。可能情况是 $(i,j) = (1,0)$ 和 $(i,j) = (0,1)$，对应于单项式 $x^1 y^0 = x$ 和 $x^0 y^1 = y$。\n3.  总次数 $2$：$i+j=2$。可能情况是 $(i,j) = (2,0)$、$(i,j) = (1,1)$ 和 $(i,j) = (0,2)$，对应于单项式 $x^2 y^0 = x^2$、$x^1 y^1 = xy$ 和 $x^0 y^2 = y^2$。\n\n综合以上，空间 $\\mathcal{P}_2(x,y)$ 的一个完备单项式基由以下集合给出：\n$$\n\\mathcal{B}_{\\text{complete}} = \\{1, x, y, x^2, y^2, xy\\}\n$$\n这个空间的维数为 $6$。\n\n问题提供了当前用于单元格式的不完备基：\n$$\n\\mathcal{B} = \\{1, x, y, x^2, y^2\\}\n$$\n由 $\\mathcal{B}$ 张成的空间是 $\\mathcal{P}_2(x,y)$ 的一个子空间，但它不是完备空间。为了满足分片检验的条件，必须对该基进行扩充，使其能够张成整个 $\\mathcal{P}_2(x,y)$ 空间。\n\n将集合 $\\mathcal{B}_{\\text{complete}}$ 与给定的基 $\\mathcal{B}$ 直接比较，可以发现缺失的项。存在于 $\\mathcal{B}_{\\text{complete}}$ 中但不在 $\\mathcal{B}$ 中的单项式正是混合项或耦合项 $xy$。\n\n问题要求找出必须添加的具有最小总次数的唯一单项式。需要添加的单项式是 $xy$。其总次数为 $1+1=2$。所有更低总次数的单项式（$1, x, y$）都已存在于 $\\mathcal{B}$ 中。总次数为 $2$ 的其他单项式仅有 $x^2$ 和 $y^2$，它们也已存在。因此，$xy$ 是总次数为 $2$ 或更低次中唯一缺失的单项式。因此，它是为达到二次完备性而必须添加的唯一单项式。添加它是完备化该基的充分必要条件。\n\n通过将单项式 $xy$ 添加到基 $\\mathcal{B}$ 中，我们得到新的基 $\\mathcal{B}' = \\{1, x, y, x^2, y^2, xy\\}$，它与 $\\mathcal{B}_{\\text{complete}}$ 完全相同。$\\mathcal{B}'$ 的张成空间是 $\\mathcal{P}_2(x,y)$，从而满足了通过二次分片检验的要求。由原基选择所代表的单元属于Serendipity族单元，该族单元是已知不完备的；而具有完备基的单元则是Lagrangian单元。不完备性是未能通过分片检验的根本原因。", "answer": "$$\\boxed{xy}$$", "id": "2605451"}, {"introduction": "将理论知识转化为可靠的计算工具是计算工程的关键一步。本练习要求你亲手构建一个自动化的分片检验框架，以系统性地验证单元的正确性。你将实现一个能够处理多种单元和检验工况的程序，并通过检验那些理论上应该通过或失败的案例，来确保你的验证工具是稳健和可靠的。[@problem_id:2605421]", "problem": "设计并实现一个用于有限元法 (FEM) 中二维小应变线性弹性的自动化分片检验框架。该框架必须在使用双线性四边形单元和线性三角形单元的矩形分片上，验证用于收敛性验证的线性分片检验。其目标是评估给定的网格和单元公式是否能在规定的多项式位移场位于离散试验空间内时精确再现该位移场，并为每个测试用例报告一个布尔结果。\n\n从以下基本基础开始：\n\n- 控制模型是矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上的小应变线性弹性，位移场为 $\\mathbf{u} = (u_x,u_y)$。\n- 小应变张量为 $\\boldsymbol{\\varepsilon}(\\mathbf{u}) = \\frac{1}{2}\\left(\\nabla \\mathbf{u} + (\\nabla \\mathbf{u})^{T}\\right)$。\n- 平面应力下各向同性材料的本构关系为 $\\boldsymbol{\\sigma} = \\mathbf{D} \\, \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{D}$ 取决于杨氏模量 $E$ 和泊松比 $\\nu$，并且当 $E > 0$ 和 $-1  \\nu  0.5$ 时是正定的。\n- 在边界 $\\partial \\Omega$ 上具有本质（狄利克雷）边界条件 $\\mathbf{u} = \\mathbf{g}$ 且体力为零的弱形式为：求 $\\mathbf{u} \\in \\mathcal{V}$ 且满足 $\\mathbf{u}|_{\\partial \\Omega} = \\mathbf{g}$，使得\n$$\n\\int_{\\Omega} \\boldsymbol{\\varepsilon}(\\mathbf{v})^{T} \\mathbf{D} \\, \\boldsymbol{\\varepsilon}(\\mathbf{u}) \\, \\mathrm{d}\\Omega = 0 \\quad \\text{for all } \\mathbf{v} \\in \\mathcal{V}_0.\n$$\n\n你的自动化分片检验必须实现以下流程：\n\n- 在 $\\Omega$ 上生成网格，可使用以下任一方式：\n  - 在一个 $n_x \\times n_y$ 的均匀矩形网格上使用双线性四边形单元（记为 $Q4$），或\n  - 通过将每个矩形分割成两个三角形得到的线性三角形单元（记为 $T3$）。\n- 采用协调有限元离散化，对 $Q4$ 使用标准等参插值，对 $T3$ 使用仿射插值。\n- 在 $\\partial \\Omega$ 上的完全狄利克雷边界条件由一个给定的位移场 $\\mathbf{u}^{\\star}(x,y)$ 定义，该场在 $x$ 和 $y$ 上是线性的或二次的。体力为零。\n- 组装全局刚度矩阵，并通过消元法施加狄利克雷边界条件。\n- 求解所得的线性系统，以获得未知的位移自由度。\n- 在内部采样点评估离散解 $\\mathbf{u}_h$：\n  - 对于 $Q4$ 单元：使用参考正方形中的标准 $2 \\times 2$ 高斯点，并映射到每个物理单元。\n  - 对于 $T3$ 单元：使用每个三角形的形心。\n- 计算所有采样点上的最大绝对误差，\n$$\ne_{\\max} = \\max_{\\text{samples}} \\max\\left( \\left| u_{x,h} - u^{\\star}_x \\right|, \\left| u_{y,h} - u^{\\star}_y \\right| \\right).\n$$\n- 如果 $e_{\\max} \\le \\tau$，则声明测试用例通过，其中 $\\tau$ 是一个指定的容差。\n\n你的程序必须根据上述定义和每种单元类型的标准精确数值积分法则来实现单元级矩阵：\n- 对于 $Q4$，使用带有 $2 \\times 2$ 个点的张量积高斯积分。\n- 对于 $T3$，利用应变-位移矩阵在仿射三角形上为常数的特性，在面积上进行精确积分。\n\n使用以下测试套件。每个测试提供 $(\\text{单元类型}, n_x, n_y, L_x, L_y, E, \\nu, \\text{场类型}, \\text{系数或 None}, \\tau)$，其中：\n- 对于线性场，$\\mathbf{u}^{\\star}(x,y)$ 由下式给出\n$$\nu_x(x,y) = a_0 + a_1 x + a_2 y, \\quad u_y(x,y) = b_0 + b_1 x + b_2 y,\n$$\n系数 $(a_0,a_1,a_2,b_0,b_1,b_2)$ 在测试用例中提供。\n- 对于二次场情况，使用\n$$\nu_x(x,y) = x^2 + y, \\quad u_y(x,y) = x + y^2.\n$$\n- 材料参数为 $E$ 和 $\\nu$，容差为 $\\tau$，域为 $\\Omega = [0,L_x]\\times[0,L_y]$。\n\n待实现的测试套件：\n\n- 用例 $1$ (正常路径, $Q4$, 线性场):\n  - $(\\text{单元类型} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{场类型} = \\text{线性}, \\text{系数} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- 用例 $2$ (覆盖 $T3$, 线性场):\n  - $(\\text{单元类型} = T3, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{场类型} = \\text{线性}, \\text{系数} = (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), \\tau = 10^{-10})$.\n- 用例 $3$ (确保区分性的反例, $Q4$, 二次场):\n  - $(\\text{单元类型} = Q4, n_x = 2, n_y = 2, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{场类型} = \\text{二次}, \\text{系数} = \\text{None}, \\tau = 10^{-10})$.\n- 用例 $4$ (边界情况: 单单元分片, $Q4$, 线性场):\n  - $(\\text{单元类型} = Q4, n_x = 1, n_y = 1, L_x = 1.0, L_y = 1.0, E = 1.0, \\nu = 0.25, \\text{场类型} = \\text{线性}, \\text{系数} = (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), \\tau = 10^{-10})$.\n\n科学真实性要求：\n\n- 假设所有计算都是无量纲的；不需要物理单位。\n- 角度不出现在输入或输出中，也无需指定。\n\n你的程序必须输出一行，其中包含上述四个用例的通过/失败布尔结果，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 为 $\\text{True}$ 或 $\\text{False}$。不允许有其他输出。", "solution": "该问题要求设计并实现一个用于二维线性弹性的分片检验框架。分片检验是有限元公式收敛的一个基本必要条件。它用于确定单元是否能够精确表示一个恒定应变状态，该状态对应于一个线性位移场。通过线性分片检验的协调单元，在网格细化时保证收敛到正确解。\n\n控制方程是线性弹性静力学方程。位移场表示为 $\\mathbf{u} = (u_x, u_y)^T$。应变-位移关系由对称梯度算子给出，产生小应变张量 $\\boldsymbol{\\varepsilon}$：\n$$ \\boldsymbol{\\varepsilon} = \\begin{pmatrix} \\varepsilon_{xx} \\\\ \\varepsilon_{yy} \\\\ \\gamma_{xy} \\end{pmatrix} = \\begin{pmatrix} \\partial u_x / \\partial x \\\\ \\partial u_y / \\partial y \\\\ \\partial u_x / \\partial y + \\partial u_y / \\partial x \\end{pmatrix} $$\n对于平面应力条件下的线性各向同性材料，应力张量 $\\boldsymbol{\\sigma}$ 通过本构矩阵 $\\mathbf{D}$ 与应变张量相关联：\n$$ \\boldsymbol{\\sigma} = \\mathbf{D} \\boldsymbol{\\varepsilon} $$\n其中，平面应力的矩阵 $\\mathbf{D}$ 根据杨氏模量 $E$ 和泊松比 $\\nu$ 定义如下：\n$$ \\mathbf{D} = \\frac{E}{1 - \\nu^2} \\begin{pmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  \\frac{1 - \\nu}{2} \\end{pmatrix} $$\n\n有限元法为问题的弱形式提供了一个近似解。域 $\\Omega$ 被离散化为单元。在每个单元 $e$ 内，位移场 $\\mathbf{u}_h$ 使用形函数 $\\mathbf{N}$ 从节点位移 $\\mathbf{d}_e$ 插值得到：\n$$ \\mathbf{u}_h(x, y) = \\mathbf{N}(x, y) \\mathbf{d}_e $$\n然后通过对形函数求导获得应变场：\n$$ \\boldsymbol{\\varepsilon}_h(x, y) = \\mathbf{B}(x, y) \\mathbf{d}_e $$\n矩阵 $\\mathbf{B}$ 是应变-位移矩阵，它将节点位移与单元应变联系起来。\n\n单元刚度矩阵 $\\mathbf{k}_e$ 将单元的节点位移与节点力联系起来，并通过在单元域 $\\Omega_e$ 上积分计算得出：\n$$ \\mathbf{k}_e = \\int_{\\Omega_e} \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\, \\mathrm{d}\\Omega $$\n这些单元矩阵被组装成一个全局刚度矩阵 $\\mathbf{K}$。得到的线性方程组为 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$。对于分片检验，边界条件由一个精确的多项式位移场 $\\mathbf{u}^\\star$ 指定。求解该系统以得到未知的内部节点位移。\n\n如果计算出的数值解 $\\mathbf{u}_h$ 在域内与精确解 $\\mathbf{u}^\\star$ 在机器精度范围内相同，则测试通过。我们通过在特定的内部采样点比较解来验证这一点。最大误差计算如下：\n$$ e_{\\max} = \\max_{\\text{samples}} \\| \\mathbf{u}_h(\\mathbf{x}_{\\text{sample}}) - \\mathbf{u}^\\star(\\mathbf{x}_{\\text{sample}}) \\|_{\\infty} $$\n如果 $e_{\\max} \\le \\tau$，则测试通过，其中 $\\tau$ 是一个很小的容差。\n\n考虑两种单元类型：\n1.  双线性四边形 ($Q4$)：在参考单元坐标系 $(\\xi, \\eta)$ 中，形函数是双线性的，形式为 $N_i(\\xi, \\eta) = c_0 + c_1 \\xi + c_2 \\eta + c_3 \\xi \\eta$。这个基包含了所有线性多项式。$\\mathbf{k}_e$ 的积分使用 $2 \\times 2$ 高斯求积法计算，该方法对 $\\xi$ 和 $\\eta$ 中最高为 3 次的多项式是精确的。对于矩形单元和线性位移场，被积函数是二次的，因此该法则足够。检查在每个单元内部相同的高斯求积点上进行。\n\n2.  线性三角形 ($T3$)：形函数是线性的，形式为 $N_i(x, y) = c_0 + c_1 x + c_2 y$。这个基也包含所有线性多项式。对于这种单元，应变-位移矩阵 $\\mathbf{B}$ 是常数。$\\mathbf{k}_e$ 的积分变得很简单：$\\mathbf{k}_e = \\mathbf{B}^T \\mathbf{D} \\mathbf{B} \\cdot A_e$，其中 $A_e$ 是单元面积。检查在单元的形心处进行。\n\n分片检验用例的逻辑如下：\n- 线性位移场对应于恒定应变状态。$Q4$ 和 $T3$ 单元都必须能够精确地再现此状态。用例 1、2 和 4 测试这一基本属性。\n- 一般来说，二次位移场不能由 $Q4$ 单元基表示。双线性形函数无法精确捕捉像 $x^2$ 或 $y^2$ 这样的项。因此，预计 $Q4$ 单元对于一般的二次场将无法通过分片检验。用例 3 测试了这种区分能力，这对于一个有效的测试框架至关重要。\n\n实现流程如下：\n1.  网格生成器为给定的 $n_x \\times n_y$ 网格创建节点坐标和单元连接性。对于 $T3$ 单元，每个矩形被一致地划分为两个三角形。\n2.  通过遍历所有单元并将其各自的 $\\mathbf{k}_e$ 添加到相应的全局自由度 (DOF) 中，来组装全局刚度矩阵 $\\mathbf{K}$。\n3.  为边界 $\\partial\\Omega$ 上的所有节点确定狄利克雷边界条件。已知的位移根据解析场 $\\mathbf{u}^\\star$ 计算得出。\n4.  将线性系统划分为自由自由度和固定自由度，并通过消元法求解：$\\mathbf{K}_{ff} \\mathbf{U}_f = -\\mathbf{K}_{fd} \\mathbf{U}_d$。\n5.  在求解出未知位移 $\\mathbf{U}_f$ 后，重构完整的解向量 $\\mathbf{U}$。\n6.  通过遍历所有单元及其指定的采样点，比较插值得到的有限元解 $\\mathbf{u}_h$ 和精确解 $\\mathbf{u}^\\star$，来计算最大误差 $e_{\\max}$。\n7.  最后，如果 $e_{\\max} \\le \\tau$，则报告结果为 `True`，否则为 `False`。这种结构化的方法确保了分片检验的严格和可验证的实现。", "answer": "```python\nimport numpy as np\n\ndef perform_test(element_type, nx, ny, Lx, Ly, E, nu, field_type, coeffs, tau):\n    \"\"\"Performs a single patch test case.\"\"\"\n\n    # 1. Mesh Generation\n    dx = Lx / nx\n    dy = Ly / ny\n    num_nodes = (nx + 1) * (ny + 1)\n    nodes = np.zeros((num_nodes, 2))\n    for i in range(nx + 1):\n        for j in range(ny + 1):\n            node_idx = i * (ny + 1) + j\n            nodes[node_idx] = [i * dx, j * dy]\n\n    elements = []\n    if element_type == 'Q4':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                elements.append([n1, n2, n3, n4])\n    elif element_type == 'T3':\n        for i in range(nx):\n            for j in range(ny):\n                n1 = i * (ny + 1) + j\n                n2 = (i + 1) * (ny + 1) + j\n                n3 = (i + 1) * (ny + 1) + (j + 1)\n                n4 = i * (ny + 1) + (j + 1)\n                # Consistent split: n1-n3 diagonal\n                elements.append([n1, n2, n3])\n                elements.append([n1, n3, n4])\n    \n    # 2. Define Exact Solution\n    if field_type == 'linear':\n        a0, a1, a2, b0, b1, b2 = coeffs\n        u_star = lambda x, y: np.array([a0 + a1 * x + a2 * y, b0 + b1 * x + b2 * y])\n    elif field_type == 'quadratic':\n        u_star = lambda x, y: np.array([x**2 + y, x + y**2])\n    else:\n        raise ValueError(\"Unknown field type\")\n\n    # 3. FEM Assembly\n    # Constitutive matrix for Plane Stress\n    D = (E / (1 - nu**2)) * np.array([[1, nu, 0],\n                                     [nu, 1, 0],\n                                     [0, 0, (1 - nu) / 2]])\n    \n    K = np.zeros((2 * num_nodes, 2 * num_nodes))\n\n    if element_type == 'Q4':\n        gauss_points = 1 / np.sqrt(3) * np.array([[-1, -1], [1, -1], [-1, 1], [1, 1]])\n        gauss_weights = [1, 1, 1, 1]\n\n        for el_nodes_idx in elements:\n            k_e = np.zeros((8, 8))\n            el_nodes_coords = nodes[el_nodes_idx]\n            \n            for gp, w in zip(gauss_points, gauss_weights):\n                xi, eta = gp\n                # Derivatives of shape functions w.r.t. ref coords\n                dN_dxi_eta = 0.25 * np.array([\n                    [-(1-eta),  (1-eta), (1+eta), -(1+eta)],\n                    [-(1-xi), -(1+xi),  (1+xi),  (1-xi)]\n                ])\n                \n                # Jacobian matrix\n                J = dN_dxi_eta @ el_nodes_coords\n                detJ = np.linalg.det(J)\n                invJ = np.linalg.inv(J)\n                \n                # Derivatives of shape functions w.r.t. physical coords\n                dN_dxy = invJ @ dN_dxi_eta\n                \n                # B matrix\n                B = np.zeros((3, 8))\n                for i in range(4):\n                    B[0, 2*i] = dN_dxy[0, i]\n                    B[1, 2*i+1] = dN_dxy[1, i]\n                    B[2, 2*i] = dN_dxy[1, i]\n                    B[2, 2*i+1] = dN_dxy[0, i]\n                \n                k_e += B.T @ D @ B * detJ * w\n                \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            x1, y1 = el_nodes_coords[0]\n            x2, y2 = el_nodes_coords[1]\n            x3, y3 = el_nodes_coords[2]\n\n            area = 0.5 * np.abs(x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))\n            \n            # B matrix (constant for T3)\n            B = (1 / (2 * area)) * np.array([\n                [y2-y3, 0,     y3-y1, 0,     y1-y2, 0    ],\n                [0,     x3-x2, 0,     x1-x3, 0,     x2-x1],\n                [x3-x2, y2-y3, x1-x3, y3-y1, x2-x1, y1-y2]\n            ])\n            \n            k_e = B.T @ D @ B * area\n            \n            # Assembly\n            dof_map = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            K[np.ix_(dof_map, dof_map)] += k_e\n\n    # 4. Apply Boundary Conditions by Elimination\n    is_boundary_node = np.array([\n        np.isclose(n[0], 0.0) or np.isclose(n[0], Lx) or\n        np.isclose(n[1], 0.0) or np.isclose(n[1], Ly)\n        for n in nodes\n    ])\n    \n    fixed_dofs = np.where(np.repeat(is_boundary_node, 2))[0]\n    free_dofs = np.where(~np.repeat(is_boundary_node, 2))[0]\n    \n    U = np.zeros(2 * num_nodes)\n    for node_idx in np.where(is_boundary_node)[0]:\n        x, y = nodes[node_idx]\n        U[2*node_idx : 2*node_idx+2] = u_star(x, y)\n        \n    U_d = U[fixed_dofs]\n    K_ff = K[np.ix_(free_dofs, free_dofs)]\n    K_fd = K[np.ix_(free_dofs, fixed_dofs)]\n    \n    F_eff = -K_fd @ U_d\n    \n    if free_dofs.size > 0:\n        U_f = np.linalg.solve(K_ff, F_eff)\n        U[free_dofs] = U_f\n\n    # 5. Error Evaluation\n    max_error = 0.0\n    if element_type == 'Q4':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n\n            for gp in gauss_points:\n                xi, eta = gp\n                # Shape functions at GP\n                N = 0.25 * np.array([\n                    (1-xi)*(1-eta), (1+xi)*(1-eta), \n                    (1+xi)*(1+eta), (1-xi)*(1+eta)\n                ])\n                # Physical coordinates of GP\n                xy_gp = N @ el_nodes_coords\n                # FEM solution at GP\n                u_h = np.array([N @ el_U[0::2], N @ el_U[1::2]])\n                # Exact solution at GP\n                u_exact = u_star(xy_gp[0], xy_gp[1])\n                \n                max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    elif element_type == 'T3':\n        for el_nodes_idx in elements:\n            el_nodes_coords = nodes[el_nodes_idx]\n            el_dofs = np.array([[2*i, 2*i+1] for i in el_nodes_idx]).flatten()\n            el_U = U[el_dofs]\n            \n            # Centroid coordinates\n            xy_c = np.mean(el_nodes_coords, axis=0)\n            \n            # For linear triangle, interpolated value at centroid is average of nodal values\n            u_h = np.mean(el_U.reshape(-1, 2), axis=0)\n            u_exact = u_star(xy_c[0], xy_c[1])\n            \n            max_error = max(max_error, np.max(np.abs(u_h - u_exact)))\n\n    return max_error = tau\n\ndef solve():\n    \"\"\"\n    Main function to run the suite of patch tests.\n    \"\"\"\n    test_suite = [\n        # Case 1: Q4, linear field (should pass)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 2: T3, linear field (should pass)\n        ('T3', 2, 2, 1.0, 1.0, 1.0, 0.25, 'linear', (0.1, 0.2, -0.3, -0.05, 0.4, 0.25), 1e-10),\n        # Case 3: Q4, quadratic field (should fail)\n        ('Q4', 2, 2, 1.0, 1.0, 1.0, 0.25, 'quadratic', None, 1e-10),\n        # Case 4: Single element Q4, linear field (should pass)\n        ('Q4', 1, 1, 1.0, 1.0, 1.0, 0.25, 'linear', (0.0, 1.0, 0.0, 0.2, -0.1, 0.0), 1e-10),\n    ]\n\n    results = []\n    for params in test_suite:\n        result = perform_test(*params)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2605421"}, {"introduction": "理论分析通常假设使用精确算术，但实际计算总是在有限精度的浮点数上进行。本项高级练习旨在揭示理论与现实之间的鸿沟，探讨一个理论上完美的单元实现为何可能因为网格的病态条件或有限的浮点数精度而在分片检验中失败。理解这些数值陷阱对于编写稳健、可靠的有限元程序至关重要。[@problem_id:2605438]", "problem": "要求您从第一性原理出发，使用有限元方法（FEM）和常应变三角形（CST）单元，为二维线性化弹性力学实现一个计算分片检验，并明确研究网格条件和数值精度如何影响验证结果。当施加适当的狄利克雷边界条件且体力为零时，分片检验会检查离散化是否能精确地再现任何线性位移场。您的实现必须包含一个受控舍入模型，该模型通过模拟具有指定二进制尾数位的算术来评估对数值精度的敏感性。\n\n从以下基本基础开始：\n- 无体力的小应变、平面应力线性弹性力学的弱形式：在容许空间中找到位移场 $u : \\Omega \\to \\mathbb{R}^2$，使得对于所有容许的虚位移 $w$，都有\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0,\n$$\n其中 $D$ 是各向同性平面应力弹性力学的本构矩阵，$\\varepsilon(\\cdot)$ 是线性化应变算子。\n- 一个常应变三角形（CST）单元，其节点坐标为 $(x_i,y_i)$，$i \\in \\{1,2,3\\}$，具有一个恒定的应变-位移矩阵 $B$ 和单元刚度\n$$\nK_e = t \\, A \\, B^{\\mathsf{T}} D B,\n$$\n其中 $t$ 是单元厚度，$A$ 是三角形面积，$D$ 是平面应力本构张量\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}.\n$$\n- 一阶完备性的分片检验规定了来自线性场的位移\n$$\nu(x,y) =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix},\n$$\n施加于边界上。对于CST单元网格和精确算术，内部节点解必须与精确的线性场完全匹配。\n\n几何与网格：\n- 考虑正方形 $\\Omega = [0,1]\\times[0,1]$，通过在坐标 $x \\in \\{0, 0.5, 1\\}$ 和 $y \\in \\{0, 0.5, 1\\}$ 处的 $3\\times 3$ 节点网格进行离散化，通过沿相同对角线分割4个正方形中的每一个，将其三角剖分为8个CST单元。为了控制条件数，通过一个因子 $s0$ 对 $y$ 坐标进行各向异性压缩，即使用节点坐标 $(x, s y)$，同时保持 $x$ 不变。用 $s$ 表示压缩因子。\n- 使用几何中心的内部节点作为唯一的自由节点，并在所有边界节点上应用由线性场给出的狄利克雷边界条件。\n\n材料与载荷：\n- 使用平面应力，杨氏模量 $E = 1$，泊松比 $\\nu = 0.3$，厚度 $t = 1$。没有体力，没有牵引力。\n- 使用线性位移场系数 $a_0 = 0.3$, $a_1 = 1.7$, $a_2 = -0.9$, $b_0 = -0.2$, $b_1 = 0.4$, $b_2 = 1.1$。\n\n数值精度模型：\n- 通过将每个基本算术结果舍入到 $p$ 个二进制尾数位来模拟具有指定二进制尾数位数 $p$ 的算术。通过标准分解将实数表示为 $m 2^e$ 且 $m \\in [0.5,1)$ 后，对尾数进行“舍入到最近”处理。将此舍入一致地应用于单元刚度计算和全局刚度组装中使用的标量加法、减法、乘法和除法，以及用于形成简化右侧项的矩阵-向量乘积。使用标准的双精度求解器求解最终的简化线性系统。\n- 求解后，在误差评估之前，将恢复的内部节点位移量化到 $p$ 位尾数，以反映有限的输出精度。\n\n误差度量：\n- 令 $u_h$ 为在内部（自由）节点计算出的位移，$u_{\\star}$ 为该节点处的精确线性场位移。定义相对误差\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}.\n$$\n\n任务：\n- 为以下 $(s,p)$ 对的测试套件实现上述过程：\n  1. $s = 1$, $p = 53$ (良态几何，双精度尾数)。\n  2. $s = 10^{-3}$, $p = 24$ (中度病态几何，类单精度尾数)。\n  3. $s = 10^{-6}$, $p = 53$ (高度病态几何，双精度尾数)。\n  4. $s = 10^{-6}$, $p = 10$ (高度病态几何，极低精度尾数)。\n- 对于每种情况，计算如上定义的 $\\mathrm{err}$。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含四个相对误差，以逗号分隔的列表形式封装在方括号中，顺序与上面列出的（四种 $(s,p)$ 情况）一致。这些数字是无量纲的。例如，一个符合要求的输出格式是\n$$\n[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3,\\mathrm{err}_4],\n$$\n其中每个 $\\mathrm{err}_i$ 是一个标准十进制表示的浮点数。", "solution": "问题陈述经过严格审查，被认定为有效。这是一个适定且具有科学依据的计算力学问题，要求在受控的数值精度下实现有限元分片检验。其参数、方程和目标都足够清晰和严谨，可以得出一个唯一且有意义的解。\n\n任务是验证常应变三角形（CST）单元在二维平面应力弹性力学中的一阶完备性。这通过分片检验来实现，该测试断言，对于一片单元，当施加相应的狄利克雷边界条件时，有限元解必须能精确地再现线性位移场。该问题引入了两个关键的复杂性：各向异性的网格扭曲以引发病态条件，以及一个模拟有限精度算术的模型来研究其与数值误差的相互作用。\n\n在没有体力的情况下，静态平衡的控制弱形式为：\n$$\n\\int_{\\Omega} \\varepsilon(w)^{\\mathsf{T}} D \\, \\varepsilon(u)\\, \\mathrm{d}\\Omega = 0 \\quad \\forall w \\in V_0\n$$\n其中 $u$ 是容许函数空间 $V$ 中的位移场，$w$ 是空间 $V_0$ （在狄利克雷边界上为零）中的虚位移，$\\varepsilon(\\cdot)$ 是产生应变分量的对称梯度算子，$D$ 是材料本构矩阵。对于各向同性平面应力， $D$ 由下式给出：\n$$\nD = \\frac{E}{1-\\nu^2}\n\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\frac{1-\\nu}{2}\n\\end{bmatrix}\n$$\n其中杨氏模量 $E=1$，泊松比 $\\nu=0.3$。\n\n域 $\\Omega = [0,1]\\times[0,1]$ 使用一个包含8个CST单元的网格进行离散化，该网格基于一个 $3 \\times 3$ 的节点阵列。节点坐标为 $(x, sy)$，其中 $x, y \\in \\{0, 0.5, 1\\}$，$s$ 是网格压缩因子。节点自由度（DOF）是水平和垂直位移 $(u_x, u_y)$。离散化后得到代数系统 $KU=F$。\n\n对于单个CST单元，其节点 $i, j, k$ 的坐标为 $(x_i, y_i), (x_j, y_j), (x_k, y_k)$，单元刚度矩阵 $K_e$ 是一个 $6 \\times 6$ 的矩阵，计算公式为：\n$$\nK_e = t A B^{\\mathsf{T}} D B\n$$\n这里，$t=1$ 是厚度，$A$ 是单元面积，$B$ 是常应变-位移矩阵：\n$$\nB = \\frac{1}{2A} \\begin{bmatrix}\ny_j-y_k  0  y_k-y_i  0  y_i-y_j  0 \\\\\n0  x_k-x_j  0  x_i-x_k  0  x_j-x_i \\\\\ny_j-y_k  x_k-x_j  y_k-y_i  x_i-x_k  y_i-y_j  x_j-x_i\n\\end{bmatrix}\n$$\n面积 $A$ 由 $A = \\frac{1}{2} |x_i(y_j - y_k) + x_j(y_k - y_i) + x_k(y_i - y_j)|$ 给出。\n\n该问题的关键部分是模拟有限精度算术。在计算单元刚度矩阵、将其组装成全局矩阵以及形成右侧向量的整个过程中，每个基本运算（加、减、乘、除）都必须舍入到 $p$ 个二进制位的尾数。这是通过一个自定义的舍入函数实现的，该函数对一个数 $x$ 进行操作，首先将其分解为尾数和指数，$x=m \\cdot 2^e$，其中 $m \\in [-1, -0.5) \\cup \\{0\\} \\cup [0.5, 1)$，然后将尾数 $m$ 舍入到最接近的可用 $p$ 位表示的值，最后重构该数。\n\n规定的位移场是线性的：\n$$\nu(x,y) = \\begin{bmatrix} u_x(x,y) \\\\ u_y(x,y) \\end{bmatrix} =\n\\begin{bmatrix}\na_0 + a_1 x + a_2 y\\\\\nb_0 + b_1 x + b_2 y\n\\end{bmatrix}\n$$\n系数为 $a_0 = 0.3, a_1 = 1.7, a_2 = -0.9, b_0 = -0.2, b_1 = 0.4, b_2 = 1.1$。在8个边界节点的坐标处计算该场，以定义狄利克雷边界条件。位于 $(0.5, 0.5s)$ 的单个内部节点保持自由。\n\n全局系统 $KU=F$ 被划分为自由（f）和指定（p）自由度：\n$$\n\\begin{bmatrix} K_{ff}  K_{fp} \\\\ K_{pf}  K_{pp} \\end{bmatrix} \\begin{Bmatrix} U_f \\\\ U_p \\end{Bmatrix} = \\begin{Bmatrix} F_f \\\\ F_p \\end{Bmatrix}\n$$\n由于自由节点上没有外力，因此 $F_f = 0$。未知位移 $U_f$ 的简化系统为：\n$$\nK_{ff} U_f = -K_{fp} U_p\n$$\n矩阵 $K_{ff}$ 和 $K_{fp}$ 是全局刚度矩阵 $K$ 的子矩阵，该矩阵是使用有限精度算术逐个单元组装而成的。右侧向量 $RHS = -K_{fp} U_p$ 也使用精度感知的矩阵-向量乘法计算。根据问题规范，这个最终的 $2 \\times 2$ 系统使用标准的双精度线性求解器求解。\n\n获得自由节点的计算位移 $u_h$ 后，其分量被量化到 $p$ 位精度。然后与该节点的精确位移 $u_{\\star} = u(0.5, 0.5s)$ 进行比较，计算相对误差：\n$$\n\\mathrm{err} = \\frac{\\|u_h - u_{\\star}\\|_2}{\\|u_{\\star}\\|_2}\n$$\n对测试套件中提供的每对参数 $(s, p)$ 重复此过程。该实现将系统地在指定的精度约束下构建所有矩阵和向量，以评估条件数和舍入误差对分片检验结果的影响。", "answer": "```python\nimport numpy as np\nimport math\n\nclass PFloatOps:\n    \"\"\"\n    A class to handle arithmetic operations with controlled precision.\n    All elementary operations are rounded to a mantissa of p binary bits.\n    \"\"\"\n    def __init__(self, p):\n        if not (1 = p = 53):\n            raise ValueError(\"Precision bits p must be between 1 and 53.\")\n        self.p = p\n\n    def round(self, val: float) - float:\n        \"\"\"Rounds a float to p mantissa bits.\"\"\"\n        if val == 0.0 or not np.isfinite(val):\n            return val\n        \n        m, e = math.frexp(val)\n        # m is in [-1, -0.5) or [0.5, 1)\n        # Scale mantissa, round to nearest integer, and scale back.\n        scale = 2**self.p\n        rounded_m = round(m * scale) / scale\n        return math.ldexp(rounded_m, e)\n\n    def add(self, a: float, b: float) - float:\n        return self.round(a + b)\n\n    def sub(self, a: float, b: float) - float:\n        return self.round(a - b)\n\n    def mul(self, a: float, b: float) - float:\n        return self.round(a * b)\n\n    def div(self, a: float, b: float) - float:\n        return self.round(a / b)\n\n    def matmul(self, A: np.ndarray, B: np.ndarray) - np.ndarray:\n        \"\"\"Performs matrix multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        n_B, p_ = B.shape\n        if n != n_B:\n            raise ValueError(\"Matrix dimensions are incompatible for multiplication.\")\n        \n        C = np.zeros((m, p_))\n        for i in range(m):\n            for j in range(p_):\n                sum_val = 0.0\n                for k in range(n):\n                    prod = self.mul(A[i, k], B[k, j])\n                    sum_val = self.add(sum_val, prod)\n                C[i, j] = sum_val\n        return C\n    \n    def matvecmul(self, A: np.ndarray, v: np.ndarray) - np.ndarray:\n        \"\"\"Performs matrix-vector multiplication with controlled precision.\"\"\"\n        m, n = A.shape\n        if n != v.shape[0]:\n            raise ValueError(\"Matrix and vector dimensions are incompatible.\")\n\n        res = np.zeros(m)\n        for i in range(m):\n            sum_val = 0.0\n            for j in range(n):\n                prod = self.mul(A[i, j], v[j])\n                sum_val = self.add(sum_val, prod)\n            res[i] = sum_val\n        return res\n\ndef get_cst_stiffness(nodes_coords: np.ndarray, D: np.ndarray, t: float, ops: PFloatOps) - np.ndarray:\n    \"\"\"\n    Computes the stiffness matrix for a single Constant Strain Triangle (CST) element\n    using the provided precision operations.\n    \"\"\"\n    (x1, y1), (x2, y2), (x3, y3) = nodes_coords\n    \n    # Calculate area with precision\n    term1 = ops.mul(x1, ops.sub(y2, y3))\n    term2 = ops.mul(x2, ops.sub(y3, y1))\n    term3 = ops.mul(x3, ops.sub(y1, y2))\n    sum_terms = ops.add(ops.add(term1, term2), term3)\n    area = ops.div(sum_terms, 2.0)\n    \n    if area = 0:\n        raise ValueError(\"Element has zero or negative area.\")\n\n    # Components of B matrix\n    beta1, beta2, beta3 = ops.sub(y2, y3), ops.sub(y3, y1), ops.sub(y1, y2)\n    gamma1, gamma2, gamma3 = ops.sub(x3, x2), ops.sub(x1, x3), ops.sub(x2, x1)\n\n    inv_2A = ops.div(1.0, ops.mul(2.0, area))\n\n    B = np.zeros((3, 6))\n    betas = [beta1, beta2, beta3]\n    gammas = [gamma1, gamma2, gamma3]\n\n    for i in range(3):\n        B[0, 2*i] = ops.mul(betas[i], inv_2A)\n        B[1, 2*i+1] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i] = ops.mul(gammas[i], inv_2A)\n        B[2, 2*i+1] = ops.mul(betas[i], inv_2A)\n\n    # Ke = t * A * B.T @ D @ B with controlled precision\n    Bt = B.T\n    DB = ops.matmul(D, B)\n    BtDB = ops.matmul(Bt, DB)\n    \n    Ke = np.zeros((6, 6))\n    scalar = ops.mul(t, area)\n    for i in range(6):\n        for j in range(6):\n            Ke[i, j] = ops.mul(scalar, BtDB[i, j])\n\n    return Ke\n\ndef solve_case(s: float, p: int) - float:\n    \"\"\"\n    Runs the patch test for a given geometry scaling `s` and precision `p`.\n    \"\"\"\n    ops = PFloatOps(p)\n\n    # Material properties\n    E = 1.0\n    nu = 0.3\n    t = 1.0\n    \n    # Constitutive matrix D for plane stress, calculated with precision\n    nu_sq = ops.mul(nu, nu)\n    one_minus_nu_sq = ops.sub(1.0, nu_sq)\n    factor = ops.div(E, one_minus_nu_sq)\n    \n    D = np.zeros((3, 3))\n    D[0, 0] = factor\n    D[0, 1] = ops.mul(factor, nu)\n    D[1, 0] = D[0, 1]\n    D[1, 1] = factor\n    D[2, 2] = ops.mul(factor, ops.div(ops.sub(1.0, nu), 2.0))\n\n    # Mesh definition\n    x_coords = [0.0, 0.5, 1.0]\n    y_coords = [0.0, 0.5, 1.0]\n    nodes = np.array([[x, ops.mul(s, y)] for y in y_coords for x in x_coords])\n    \n    # Node indices are 0-8, row-by-row from bottom-left\n    # Elements are numbered to create a consistent triangulation\n    elements = [\n        (0, 1, 4), (0, 4, 3), (1, 2, 5), (1, 5, 4),\n        (3, 4, 7), (3, 7, 6), (4, 5, 8), (4, 8, 7)\n    ]\n    \n    # Assembly\n    num_nodes = 9\n    K_global = np.zeros((2 * num_nodes, 2 * num_nodes))\n    \n    for el_nodes in elements:\n        node1_idx, node2_idx, node3_idx = el_nodes\n        el_coords = nodes[[node1_idx, node2_idx, node3_idx]]\n        \n        Ke = get_cst_stiffness(el_coords, D, t, ops)\n        \n        dof_indices = [2*node1_idx, 2*node1_idx+1, 2*node2_idx, 2*node2_idx+1, 2*node3_idx, 2*node3_idx+1]\n        \n        for i in range(6):\n            for j in range(6):\n                global_i, global_j = dof_indices[i], dof_indices[j]\n                K_global[global_i, global_j] = ops.add(K_global[global_i, global_j], Ke[i, j])\n\n    # Boundary conditions and partitioning\n    free_dofs = [8, 9]  # DOFs for the central node (node 4)\n    prescribed_dofs = [i for i in range(2 * num_nodes) if i not in free_dofs]\n    \n    K_ff = K_global[np.ix_(free_dofs, free_dofs)]\n    K_fp = K_global[np.ix_(free_dofs, prescribed_dofs)]\n    \n    # Prescribed displacement field coefficients\n    a0, a1, a2 = 0.3, 1.7, -0.9\n    b0, b1, b2 = -0.2, 0.4, 1.1\n\n    def u_exact(x, y):\n        ux = a0 + a1*x + a2*y\n        uy = b0 + b1*x + b2*y\n        return np.array([ux, uy])\n\n    U_p = np.zeros(len(prescribed_dofs))\n    for i, dof in enumerate(prescribed_dofs):\n        node_idx = dof // 2\n        dof_type = dof % 2\n        node_coord = nodes[node_idx]\n        u_val = u_exact(node_coord[0], node_coord[1])[dof_type]\n        U_p[i] = u_val\n        \n    # Solve system: K_ff * U_f = -K_fp * U_p\n    RHS = ops.matvecmul(K_fp, U_p)\n    RHS = -RHS\n    \n    # Solve using standard double precision solver\n    try:\n        Uh_f = np.linalg.solve(K_ff, RHS)\n    except np.linalg.LinAlgError:\n        return np.inf\n\n    # Quantize solution\n    Uh_f_quantized = np.array([ops.round(Uh_f[0]), ops.round(Uh_f[1])])\n    \n    # Error calculation\n    center_node_coord = nodes[4]\n    U_star = u_exact(center_node_coord[0], center_node_coord[1])\n    \n    diff_vec = Uh_f_quantized - U_star\n    err_norm = np.linalg.norm(diff_vec)\n    ustar_norm = np.linalg.norm(U_star)\n    \n    if ustar_norm == 0:\n        return 0.0 if err_norm == 0.0 else np.inf\n    \n    return err_norm / ustar_norm\n\ndef solve():\n    test_cases = [\n        (1.0, 53),\n        (1e-3, 24),\n        (1e-6, 53),\n        (1e-6, 10),\n    ]\n\n    results = []\n    for s, p in test_cases:\n        rel_err = solve_case(s, p)\n        results.append(rel_err)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2605438"}]}