{"hands_on_practices": [{"introduction": "本练习为自适应策略提供了一个具体的切入点。通过分析一个简单的一维边界层问题，您将定量地比较 $r$-自适应（节点重定位）和 $h$-自适应（单元插入）的差异。这项实践将帮助您建立关于网格密度如何与解的特征及所需精度相关联的直观理解。[@problem_id:2540459]", "problem": "考虑单位区间 $[0,1]$ 上的光滑函数 $u(x) = 1 - \\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$给出的一维边界层原型，其中 $\\varepsilon \\in (0,1]$ 控制了 $x=1$ 附近边界层的厚度。我们通过两种策略来分析分片线性有限元的自适应网格加密：$r$-自适应（节点移动，单元数量固定）和 $h$-自适应（单元插入，即增加单元数量），同时保持多项式次数不变。假设通常的有限元插值误差理论适用于本性上确界范数 $L^\\infty$ 中的 $C^2$ 函数。\n\n从以下公认的基础出发：\n- 长度为 $h$ 的单元上的分片线性插值误差满足不等式 $\\|u - I_h u\\|_{L^\\infty(\\text{element})} \\le C_I \\,\\max_{x \\text{ in element}} |u''(x)|\\, h^2$，其中常数 $C_I = \\dfrac{1}{8}$，$I_h u$ 表示局部线性插值。\n- 标量监控函数的 $r$-自适应等分布原则指出，为了在固定的单元预算下最小化所有单元上的最大插值误差，应选择一个与二阶导数绝对值的平方根成反比的网格密度，即单元尺寸 $h(x)$ 满足 $|u''(x)|\\, h(x)^2 \\approx \\text{constant}$。\n- 边界层函数满足 $u''(x) = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，该函数为正，并从 $x=1$ 处开始指数衰减。\n\n你的任务是：\n1. 从插值误差界和等分布原则出发，推导在最优自适应网格下，为确保全局 $L^\\infty$ 插值误差不超过目标容差 $\\tau > 0$ 所需的最小单元数 $n_\\star$ 的估计。用 $\\varepsilon$、$\\tau$ 和 $C_I$ 表示 $n_\\star$。\n2. 对于具有固定单元预算 $n_0 \\in \\mathbb{N}$ 的 $r$-自适应，确定仅通过节点移动（不改变连接性或单元数量）是否能满足容差 $\\tau$。这当且仅当 $n_0 \\ge n_\\star$ 时成立。\n3. 通过计算对于指定的正参数 $\\Lambda$，应位于末端子区间 $[1 - \\Lambda \\varepsilon, 1]$ 内的单元分数 $f_{\\Lambda}$，来量化最优等分布在边界层附近所要求的单元集中程度。将其解释为在 $[1 - \\Lambda \\varepsilon, 1]$ 上的最优网格密度积分与在 $[0,1]$ 上的积分之比。\n\n你必须实现一个程序，该程序：\n- 使用你推导的表达式计算 $n_\\star$（向上取整到最近的整数）。\n- 如果 $n_0 \\ge n_\\star$，则确定 $r$-自适应成功的布尔指示符为 $1$，否则为 $0$。\n- 计算 $f_{\\Lambda}$ 并将其四舍五入到 $6$ 位小数。\n\n你的实现应专门针对给定的 $u(x)$，并且只使用下面指定的数据。对于这个 $u(x)$，基于等分布的最优单元密度与 $\\sqrt{|u''(x)|}$ 成正比，你的程序应利用这一事实来精确计算 $f_{\\Lambda}$。答案必须是无单位的。\n\n测试套件：\n- 情况 1：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.05, 10^{-2}, 40, 4)$。\n- 情况 2：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.005, 10^{-4}, 50, 5)$。\n- 情况 3：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.5, 10^{-2}, 5, 1)$。\n- 情况 4：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.001, 5\\times 10^{-3}, 8, 3)$。\n- 情况 5：$(\\varepsilon, \\tau, n_0, \\Lambda) = (0.02, 2\\times 10^{-3}, 30, 4)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，顺序与上面相同。\n- 每个条目必须是 $[n_\\star, s, f_{\\Lambda}]$ 形式的列表，其中 $n_\\star$ 是一个整数，$s \\in \\{0,1\\}$ 指示仅 $r$-自适应是否成功，$f_{\\Lambda}$ 是一个四舍五入到 $6$ 位小数的浮点数。\n- 输出必须打印为单行，不带任何额外文本，条目必须在方括号内用逗号分隔。例如，一个有效的形状是 $[[n_\\star^{(1)},s^{(1)},f_{\\Lambda}^{(1)}],[n_\\star^{(2)},s^{(2)},f_{\\Lambda}^{(2)}],\\dots]$。", "solution": "我们处理在 $[0,1]$ 上的特定边界层剖面 $u(x) = 1 - \\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，其中 $\\varepsilon \\in (0,1]$。其导数为\n$$\nu'(x) = \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right),\\quad\nu''(x) = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right).\n$$\n在长度为 $h_K$ 的单元 $K$ 上的分片线性插值误差界为\n$$\n\\|u - I_h u\\|_{L^\\infty(K)} \\le C_I \\big(\\max_{x\\in K} |u''(x)|\\big)\\, h_K^2,\n$$\n其中 $C_I = \\dfrac{1}{8}$，这是一个可从线性插值的 Peano 核推导出的经典结果。$r$-自适应的最优性原则（等分布）旨在选择单元尺寸 $\\{h_K\\}$，以使单元对误差的贡献均等化。在一维情况下，对于定义域上的连续网格尺寸函数 $h(x)$，这对应于强制\n$$\nC_I\\, |u''(x)|\\, h(x)^2 \\approx \\tau_e,\n$$\n其中 $\\tau_e$ 是目标均等化单元误差，使得全局 $L^\\infty$ 误差不超过预定容差 $\\tau > 0$。当所有单元共享相同的不等式界 $C_I |u''| h^2 = \\tau_e$ 时，网格上的全局最大值不超过 $\\tau_e$，因此为了保守设计，我们可以设置 $\\tau_e = \\tau$。解出 $h(x)$ 得\n$$\nh(x) = \\sqrt{\\dfrac{\\tau}{C_I}}\\, |u''(x)|^{-1/2}.\n$$\n与此连续网格尺寸关联的总单元数 $n$ 是域的路径长度除以局部尺寸：\n$$\nn \\approx \\int_{0}^{1} \\dfrac{dx}{h(x)} = \\sqrt{\\dfrac{C_I}{\\tau}} \\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx.\n$$\n因此，能够达到容差的最小单元数的估计为\n$$\nn_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx \\right\\rceil.\n$$\n对于我们的 $u(x)$，我们有 $|u''(x)| = \\dfrac{1}{\\varepsilon^2}\\exp\\!\\left(-\\dfrac{1-x}{\\varepsilon}\\right)$，因此\n$$\n\\sqrt{|u''(x)|} = \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{2\\varepsilon}\\right).\n$$\n该积分可以精确计算：\n$$\n\\int_{0}^{1} \\sqrt{|u''(x)|}\\, dx = \\int_{0}^{1} \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{1-x}{2\\varepsilon}\\right) dx.\n$$\n通过换元 $y = 1-x$，$dy = -dx$，积分变为\n$$\n\\int_{y=1}^{0} \\dfrac{1}{\\varepsilon} \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) (-dy) = \\int_{0}^{1} \\dfrac{1}{\\varepsilon} \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) dy = \\left[-2 \\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right)\\right]_{0}^{1} = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right).\n$$\n因此，\n$$\nn_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\cdot 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right) \\right\\rceil,\n$$\n其中 $C_I = \\dfrac{1}{8}$。这个 $n_\\star$ 是在最优重分布下 $h$-自适应和 $r$-自适应的基准：$h$-自适应可以通过增加单元数直到至少 $n_\\star$ 来满足容差，而 $r$-自适应当且仅当可用单元数 $n_0$ 满足 $n_0 \\ge n_\\star$ 时，才能在不改变单元数的情况下满足容差。\n\n为量化边界层附近的网格集中程度，注意最优单元密度与 $\\sqrt{|u''(x)|}$ 成正比。令 $\\rho(x) = \\sqrt{|u''(x)|}$ 并定义\n$$\nI_{\\text{tot}}(\\varepsilon) = \\int_{0}^{1} \\rho(x)\\, dx = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right).\n$$\n在末端子区间 $[1 - \\Lambda \\varepsilon, 1]$ 中预期的单元分数为\n$$\nf_{\\Lambda} = \\dfrac{\\int_{1-\\Lambda \\varepsilon}^{1} \\rho(x)\\, dx}{\\int_{0}^{1} \\rho(x)\\, dx}.\n$$\n使用相同的换元 $y=1-x$ 并注意该子区间对应于 $y \\in [0, \\min(1,\\Lambda \\varepsilon)]$，我们发现\n$$\n\\int_{1-\\Lambda \\varepsilon}^{1} \\rho(x)\\, dx = \\int_{0}^{\\min(1,\\Lambda \\varepsilon)} \\dfrac{1}{\\varepsilon}\\exp\\!\\left(-\\dfrac{y}{2\\varepsilon}\\right) dy = 2\\left(1 - \\exp\\!\\left(-\\min\\!\\left(\\dfrac{1}{2\\varepsilon}, \\dfrac{\\Lambda}{2}\\right)\\right)\\right).\n$$\n因此，\n$$\nf_{\\Lambda}(\\varepsilon,\\Lambda) = \\dfrac{1 - \\exp\\!\\left(-\\min\\!\\left(\\dfrac{1}{2\\varepsilon}, \\dfrac{\\Lambda}{2}\\right)\\right)}{1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)}.\n$$\n这给出了一个完全等分布的网格会分配给边界层邻域的精确、无单位的分数。\n\n对每个测试用例 $(\\varepsilon, \\tau, n_0, \\Lambda)$ 的算法步骤：\n1. 计算 $I_{\\text{tot}}(\\varepsilon) = 2\\left(1 - \\exp\\!\\left(-\\dfrac{1}{2\\varepsilon}\\right)\\right)$。\n2. 计算 $n_\\star = \\left\\lceil \\sqrt{\\dfrac{C_I}{\\tau}} \\cdot I_{\\text{tot}}(\\varepsilon) \\right\\rceil$，$C_I=\\dfrac{1}{8}$。\n3. 如果 $n_0 \\ge n_\\star$，则设置 $s = 1$，否则 $s = 0$。\n4. 使用上述精确公式计算 $f_{\\Lambda}$ 并四舍五入到 $6$ 位小数。\n\n将此应用于指定的测试套件会产生确定的整数和浮点数输出。程序必须打印一个包含 $5$ 个条目的单行列表，每个条目形式为 $[n_\\star, s, f_{\\Lambda}]$，$f_{\\Lambda}$ 四舍五入到 $6$ 位小数，并且没有附加文本。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef n_star(eps: float, tol: float, C_I: float = 1.0/8.0) -> int:\n    # I_tot = integral of sqrt(|u''|) over [0,1] for u'' = exp(-(1-x)/eps)/eps^2\n    # sqrt(|u''|) = exp(-(1-x)/(2 eps))/eps\n    # Integral = 2 * (1 - exp(-1/(2 eps)))\n    I_tot = 2.0 * (1.0 - np.exp(-1.0 / (2.0 * eps)))\n    val = np.sqrt(C_I / tol) * I_tot\n    return int(np.ceil(val))\n\ndef fraction_in_layer(eps: float, Lam: float) -> float:\n    # f_Lambda = (1 - exp(-min(1/(2 eps), Lam/2))) / (1 - exp(-1/(2 eps)))\n    denom = 1.0 - np.exp(-1.0 / (2.0 * eps))\n    m = min(1.0 / (2.0 * eps), Lam / 2.0)\n    numer = 1.0 - np.exp(-m)\n    # Handle potential numerical issues if denom is extremely small (shouldn't happen in given tests)\n    if denom == 0.0:\n        return 1.0  # degenerate smooth limit: all density uniform\n    f = numer / denom\n    # Clamp to [0,1] due to rounding\n    return max(0.0, min(1.0, f))\n\ndef solve():\n    # Define the test cases from the problem statement: (eps, tau, n0, Lambda)\n    test_cases = [\n        (0.05, 1e-2, 40, 4.0),\n        (0.005, 1e-4, 50, 5.0),\n        (0.5, 1e-2, 5, 1.0),\n        (0.001, 5e-3, 8, 3.0),\n        (0.02, 2e-3, 30, 4.0),\n    ]\n\n    results = []\n    for eps, tau, n0, Lam in test_cases:\n        n_req = n_star(eps, tau, C_I=1.0/8.0)\n        r_success = 1 if n0 >= n_req else 0\n        frac = fraction_in_layer(eps, Lam)\n        frac_rounded = round(frac, 6)\n        results.append([n_req, r_success, float(f\"{frac_rounded:.6f}\")])\n\n    # Format as a single-line list of lists with no spaces for exactness\n    def format_entry(entry):\n        # entry is [int, int, float]\n        return f\"[{entry[0]},{entry[1]},{entry[2]}]\"\n    print(f\"[{','.join(format_entry(e) for e in results)}]\")\n\nsolve()\n```", "id": "2540459"}, {"introduction": "有效的自适应加密依赖于对误差的准确估计。本练习深入探讨了自适应的“引擎”，要求您为一个一维问题实现两种后验误差估计子。通过比较一个标准的残差估计子和一个基于局部诺伊曼问题（Neumann problems）的估计子，您将获得关于误差估计计算力学的第一手经验。[@problem_id:2540490]", "problem": "考虑一维空间中的标量泊松问题：求解 $u \\in H_0^1(0,1)$，使得在 $(0,1)$ 上有 $-u'' = f$，并满足齐次狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。能量范数定义为 $\\lVert v \\rVert_E := \\left(\\int_0^1 \\lvert v'(x)\\rvert^2\\,dx\\right)^{1/2}$。令 $V_h$ 表示在 $[0,1]$ 上一个包含 $N$ 个单元的均匀网格上的连续分片线性函数空间，其节点为 $x_i = i h$，$i=0,\\dots,N$，$h=1/N$。有限元方法旨在求解 $u_h\\in V_h\\cap H_0^1(0,1)$，使得对于所有 $v\\in V_h\\cap H_0^1(0,1)$，均有 $\\int_0^1 u_h'(x)v'(x)\\,dx=\\int_0^1 f(x)v(x)\\,dx$。\n\n您的任务是：\n\n1) 使用数值积分法，实现能量误差 $\\lVert u' - u_h'\\rVert_{L^2(0,1)}$ 的计算，其中 $u$ 是对应于下面给出的选定右端项 $f$ 的精确解。\n\n2) 实现一维情况下分片线性有限元的标准残差型后验误差估计子。对于每个长度为 $h_K$ 的单元 $K=[x_{i},x_{i+1}]$，将内部残差贡献定义为 $h_K^2 \\int_K f(x)^2\\,dx$；在每个内部节点 $x_i$（$i=1,\\dots,N-1$）处，定义离散通量的跳跃项为 $\\llbracket u_h'\\rrbracket_i := u_h'(x_i^-)-u_h'(x_i^+)$。将在节点 $x_i$ 处的跳跃项贡献定义为 $\\frac{h_{i-1}+h_{i}}{2}\\,\\llbracket u_h'\\rrbracket_i^2$，其中 $h_{i-1}=x_i-x_{i-1}$，$h_{i}=x_{i+1}-x_i$。总的标准估计子为\n$$\n\\eta_{\\mathrm{std}}^2 := \\sum_{K} h_K^2 \\int_K f(x)^2\\,dx \\;+\\;\\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2.\n$$\n\n3) 实现一个可计算的替代界，该界通过顶点片（vertex patches）上局部诺伊曼（Neumann）问题的解来替换散度残差项。对于每个内部节点 $x_i$（$i=1,\\dots,N-1$），考虑片 $\\omega_i := (x_{i-1},x_{i+1})$ 和离散局部诺伊曼问题：求解 $w_i \\in V_h(\\omega_i)$，使得\n$$\n\\int_{\\omega_i} w_i'(x) v'(x)\\,dx = \\int_{\\omega_i} f(x) v(x)\\,dx \\quad \\text{for all } v \\in V_h(\\omega_i),\n$$\n并附加约束 $\\int_{\\omega_i} w_i(x)\\,dx = 0$ 以确定诺伊曼零空间，其中 $V_h(\\omega_i)$ 表示全局分片线性空间在 $\\omega_i$ 上的限制。将局域片能量定义为\n$$\n\\eta_{i,\\mathrm{div}}^2 := \\int_{\\omega_i} \\lvert w_i'(x)\\rvert^2\\,dx,\n$$\n并将诺伊曼片估计子定义为\n$$\n\\eta_{\\mathrm{neu}}^2 := \\sum_{i=1}^{N-1} \\eta_{i,\\mathrm{div}}^2 \\;+\\;\\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2.\n$$\n通过组装节点 $\\{x_{i-1},x_i,x_{i+1}\\}$ 上的 $3\\times 3$ 片刚度矩阵、相应的片载荷向量，并通过单个拉格朗日乘子施加附加约束，在离散片空间中计算 $w_i$。\n\n4) 对每个测试用例，计算可靠性常数 $C_{\\mathrm{std}} := \\eta_{\\mathrm{std}} / \\lVert u' - u_h'\\rVert_{L^2(0,1)}$ 和 $C_{\\mathrm{neu}} := \\eta_{\\mathrm{neu}} / \\lVert u' - u_h'\\rVert_{L^2(0,1)}$，结果为浮点数。\n\n使用以下右端项 $f$ 和精确解 $u$：\n- $f_1(x) := \\pi^2 \\sin(\\pi x)$，其 $u_1(x) := \\sin(\\pi x)$，因此 $u_1'(x) := \\pi \\cos(\\pi x)$。\n- $f_2(x) := 1$，其 $u_2(x) := \\tfrac{1}{2}x(1-x)$，因此 $u_2'(x) := \\tfrac{1}{2}(1-2x)$。\n- $f_3(x) := \\begin{cases} 1, & x < 1/2, \\\\ 2, & x \\ge 1/2,\\end{cases}$，其对应的精确解满足 $-u_3''=f_3$ 以及 $u_3(0)=0, u_3(1)=0$，可得\n$$\nu_3(x) := \\begin{cases}\n-\\tfrac{1}{2}x^2 + \\tfrac{5}{8}x, & 0 \\le x \\le 1/2,\\\\\n-x^2 + \\tfrac{9}{8}x - \\tfrac{1}{8}, & 1/2 < x \\le 1,\n\\end{cases}\n\\quad\nu_3'(x) := \\begin{cases}\n-x + \\tfrac{5}{8}, & 0 \\le x \\le 1/2,\\\\\n-2x + \\tfrac{9}{8}, & 1/2 < x \\le 1.\n\\end{cases}\n$$\n\n测试套件：\n- 用例 A：$N=4$，使用 $f_1$。\n- 用例 B：$N=16$，使用 $f_1$。\n- 用例 C：$N=3$，使用 $f_2$。\n- 用例 D：$N=20$，使用 $f_3$。\n- 用例 E：$N=2$，使用 $f_3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按 A 到 E 的顺序，先输出 $C_{\\mathrm{std}}$，再输出 $C_{\\mathrm{neu}}$。例如，输出必须采用以下格式：$[C_{\\mathrm{std},A},C_{\\mathrm{neu},A},C_{\\mathrm{std},B},C_{\\mathrm{neu},B},C_{\\mathrm{std},C},C_{\\mathrm{neu},C},C_{\\mathrm{std},D},C_{\\mathrm{neu},D},C_{\\mathrm{std},E},C_{\\mathrm{neu},E}]$。", "solution": "所给问题是一维泊松方程有限元方法后验误差分析中一个明确定义的练习。它在科学上是合理的，在数学上是一致的，并且所有必需的组件都已明确指定。因此，该问题被认为是有效的。我将着手解决它。\n\n问题的核心是计算和比较 $-u'' = f$ 在 $(0,1)$ 上（其中 $u(0)=u(1)=0$）的有限元解的两种后验误差估计子。\n\n**1. 有限元解**\n\n我们使用一个均匀网格，该网格有 $N$ 个单元，大小为 $h = 1/N$，节点为 $x_i = i h$，$i=0, \\dots, N$。有限元解 $u_h$ 在连续分片线性函数空间 $V_h$ 中求解，该空间中的函数在 $x=0$ 和 $x=1$ 处为零。我们可以用标准的“帽子”基函数 $\\phi_i(x)$ 来表示 $u_h$，即 $u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)$，其中 $U_j = u_h(x_j)$ 是未知的节点值。\n\nGalerkin 公式导出一个线性方程组 $A \\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = (U_1, \\dots, U_{N-1})^T$。刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的项为：\n$$\nA_{ij} = \\int_0^1 \\phi_j'(x) \\phi_i'(x) \\,dx \\quad \\text{和} \\quad b_i = \\int_0^1 f(x) \\phi_i(x) \\,dx\n$$\n对于一维均匀网格，刚度矩阵是一个 $(N-1) \\times (N-1)$ 的对称三对角矩阵：\n$$\nA = \\frac{1}{h}\n\\begin{pmatrix}\n2 & -1 & 0 & \\dots & 0 \\\\\n-1 & 2 & -1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & 0 \\\\\n\\dots & -1 & 2 & -1 \\\\\n0 & \\dots & 0 & -1 & 2\n\\end{pmatrix}\n$$\n载荷向量 $b_i$ 的各项必须通过数值积分计算，特别是对于非多项式 $f(x)$。一旦求解系统 $A \\mathbf{U} = \\mathbf{b}$ 得到 $\\mathbf{U}$，近似解 $u_h$ 就完全确定了。其导数 $u_h'$ 在每个单元 $K_i = [x_i, x_{i+1}]$ 上是分片常数：\n$$\nu_h'(x) = \\frac{U_{i+1} - U_i}{h} \\quad \\text{对于 } x \\in (x_i, x_{i+1}),\n$$\n其中我们定义 $U_0 = U_N = 0$。\n\n**2. 能量误差**\n\n精确能量误差由 $\\lVert u' - u_h' \\rVert_{L^2(0,1)}$ 给出。其平方通过对每个单元的贡献求和来计算：\n$$\n\\lVert u' - u_h' \\rVert_{L^2(0,1)}^2 = \\int_0^1 (u'(x) - u_h'(x))^2 \\,dx = \\sum_{i=0}^{N-1} \\int_{x_i}^{x_{i+1}} \\left(u'(x) - \\frac{U_{i+1}-U_i}{h}\\right)^2 \\,dx\n$$\n为了保证精度，该积分使用高阶数值积分计算。\n\n**3. 标准残差估计子 ($\\eta_{\\mathrm{std}}$)**\n\n该估计子定义为 $\\eta_{\\mathrm{std}}^2 = \\eta_{\\mathrm{res}}^2 + \\eta_{\\mathrm{jump}}^2$。\n第一项是单元残差贡献：\n$$\n\\eta_{\\mathrm{res}}^2 = \\sum_{K} h_K^2 \\int_K f(x)^2\\,dx = \\sum_{i=0}^{N-1} h^2 \\int_{x_i}^{x_{i+1}} f(x)^2\\,dx\n$$\n$f^2$ 的积分使用数值积分逐个单元地计算。\n\n第二项涉及离散解在内部节点处导数的跳跃：\n$$\n\\eta_{\\mathrm{jump}}^2 = \\sum_{i=1}^{N-1} \\frac{h_{i-1}+h_i}{2}\\,\\llbracket u_h'\\rrbracket_i^2 = \\sum_{i=1}^{N-1} h\\,\\llbracket u_h'\\rrbracket_i^2\n$$\n其中 $\\llbracket u_h'\\rrbracket_i = u_h'(x_i^-) - u_h'(x_i^+)$。Galerkin 方法的一个基本结果是，此跳跃项等于载荷向量中相应的项。对于每个内部基函数 $\\phi_i$，弱形式给出：\n$$\n\\int_0^1 u_h'(x)\\phi_i'(x)\\,dx = \\int_0^1 f(x)\\phi_i(x)\\,dx = b_i\n$$\n在 $\\phi_i$ 的支集中的每个单元上对左侧进行分部积分，得到：\n$$\n\\int_0^1 u_h'(x)\\phi_i'(x)\\,dx = u_h'(x_i^-) - u_h'(x_i^+) = \\llbracket u_h'\\rrbracket_i\n$$\n因此，$\\llbracket u_h'\\rrbracket_i = b_i$。这极大地简化了跳跃项的计算：\n$$\n\\eta_{\\mathrm{jump}}^2 = \\sum_{i=1}^{N-1} h\\, b_i^2\n$$\n\n**4. 诺伊曼片估计子 ($\\eta_{\\mathrm{neu}}$)**\n\n此估计子将单元残差项替换为局部诺伊曼问题解的能量之和。其形式为：\n$$\n\\eta_{\\mathrm{neu}}^2 = \\sum_{i=1}^{N-1} \\eta_{i,\\mathrm{div}}^2 + \\eta_{\\mathrm{jump}}^2\n$$\n跳跃项 $\\eta_{\\mathrm{jump}}^2$ 与标准估计子中的相同。我们专注于计算每个内部节点 $x_i$（$i \\in \\{1, \\dots, N-1\\}$）的片散度项 $\\eta_{i,\\mathrm{div}}^2$。\n\n对于每个片 $\\omega_i = (x_{i-1}, x_{i+1})$，我们在由限制在 $\\omega_i$ 上的 $\\{\\phi_{i-1}, \\phi_{i}, \\phi_{i+1}\\}$ 张成的局部三节点有限元空间中求解 $w_i(x)$ 的局部诺伊曼问题。设 $\\mathbf{w} = (w_{i-1}, w_i, w_{i+1})^T$ 为局部解 $w_i$ 的节点值。局部问题由刚度矩阵 $A_p$ 和载荷向量 $\\mathbf{b}_p$ 定义：\n$$\nA_p \\mathbf{w} = \\mathbf{b}_p \\quad \\text{其中} \\quad A_p = \\frac{1}{h}\\begin{pmatrix} 1 & -1 & 0 \\\\ -1 & 2 & -1 \\\\ 0 & -1 & 1 \\end{pmatrix}, \\quad (\\mathbf{b}_p)_j = \\int_{\\omega_i} f(x)\\phi_j(x)\\,dx\n$$\n对于 $j \\in \\{i-1, i, i+1\\}$。矩阵 $A_p$是奇异的，反映了诺伊曼问题中常数函数的零空间。唯一解由约束 $\\int_{\\omega_i} w_i(x)\\,dx=0$ 确定，该约束转化为节点值上的一个线性约束：\n$$\n\\int_{x_{i-1}}^{x_{i+1}} \\sum_{j=i-1}^{i+1} w_j \\phi_j(x)\\,dx = w_{i-1}\\frac{h}{2} + w_i h + w_{i+1}\\frac{h}{2} = 0 \\implies \\mathbf{C}^T \\mathbf{w} = 0\n$$\n其中 $\\mathbf{C} = (h/2, h, h/2)^T$。我们使用一个拉格朗日乘子 $\\lambda$ 求解此约束系统，这导出了增广的 $4 \\times 4$ 系统：\n$$\n\\begin{pmatrix} A_p & \\mathbf{C} \\\\ \\mathbf{C}^T & 0 \\end{pmatrix} \\begin{pmatrix} \\mathbf{w} \\\\ \\lambda \\end{pmatrix} = \\begin{pmatrix} \\mathbf{b}_p \\\\ 0 \\end{pmatrix}\n$$\n求解得到 $\\mathbf{w}$ 后，局部能量贡献为 $\\eta_{i,\\mathrm{div}}^2 = \\int_{\\omega_i} \\lvert w_i'(x)\\rvert^2\\,dx$。从局部问题的弱形式出发，通过将测试函数设为 $w_i$ 本身，我们发现：\n$$\n\\eta_{i,\\mathrm{div}}^2 = \\int_{\\omega_i} w_i'(x)w_i'(x)\\,dx = \\int_{\\omega_i} f(x) w_i(x)\\,dx = \\sum_{j=i-1}^{i+1} w_j \\int_{\\omega_i} f(x)\\phi_j(x)\\,dx = \\mathbf{w}^T \\mathbf{b}_p\n$$\n这为计算片能量提供了一种高效的方法。\n\n**5. 可靠性常数**\n\n最后，对于每个测试用例，我们计算估计误差与真实误差的比值，这被称为可靠性常数（或有效性指数）：\n$$\nC_{\\mathrm{std}} = \\frac{\\eta_{\\mathrm{std}}}{\\lVert u' - u_h'\\rVert_{L^2(0,1)}}, \\quad C_{\\mathrm{neu}} = \\frac{\\eta_{\\mathrm{neu}}}{\\lVert u' - u_h'\\rVert_{L^2(0,1)}}\n$$\n这些常数是针对每个指定的 $N$ 和 $f(x)$ 配置计算的。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson problem using FEM and computes error estimators for specified test cases.\n    \"\"\"\n\n    class TestCase:\n        def __init__(self, N, f_func, u_prime_func, f_discontinuity=None):\n            self.N = N\n            self.f = f_func\n            self.u_prime = u_prime_func\n            self.f_discontinuity = f_discontinuity\n\n    # Define test functions\n    f1 = lambda x: np.pi**2 * np.sin(np.pi * x)\n    u1_prime = lambda x: np.pi * np.cos(np.pi * x)\n\n    f2 = lambda x: 1.0\n    u2_prime = lambda x: 0.5 * (1.0 - 2.0 * x)\n    \n    def f3(x):\n        if hasattr(x, '__iter__'):\n            return np.piecewise(x, [x  0.5], [1.0, 2.0])\n        return 1.0 if x  0.5 else 2.0\n\n    def u3_prime(x):\n        if hasattr(x, '__iter__'):\n            return np.piecewise(x, [x  0.5],\n                                [lambda v: -v + 5/8, lambda v: -2*v + 9/8])\n        return -x + 5/8 if x  0.5 else -2*x + 9/8\n\n    test_cases = [\n        TestCase(N=4, f_func=f1, u_prime_func=u1_prime),\n        TestCase(N=16, f_func=f1, u_prime_func=u1_prime),\n        TestCase(N=3, f_func=f2, u_prime_func=u2_prime),\n        TestCase(N=20, f_func=f3, u_prime_func=u3_prime, f_discontinuity=0.5),\n        TestCase(N=2, f_func=f3, u_prime_func=u3_prime, f_discontinuity=0.5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N = case.N\n        h = 1.0 / N\n        nodes = np.linspace(0, 1, N + 1)\n        \n        # --- 1. Global FEM solution ---\n        if N > 1:\n            A = np.zeros((N - 1, N - 1))\n            main_diag = 2.0 / h * np.ones(N - 1)\n            off_diag = -1.0 / h * np.ones(N - 2)\n            A += np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n            b = np.zeros(N - 1)\n            for i in range(1, N):\n                # Hat function phi_i\n                phi_i = lambda x, i_node=i: np.maximum(0, 1 - np.abs(x - nodes[i_node]) / h)\n                integrand = lambda x: case.f(x) * phi_i(x)\n                \n                points = [case.f_discontinuity] if case.f_discontinuity and nodes[i-1]  case.f_discontinuity  nodes[i+1] else None\n                b[i - 1] = quad(integrand, nodes[i - 1], nodes[i + 1], points=points)[0]\n\n            U_internal = np.linalg.solve(A, b)\n            U = np.concatenate(([0], U_internal, [0]))\n        else: # N=1 case, only boundary nodes\n            U = np.zeros(2)\n            b = np.array([])\n\n        # --- 2. Energy Error ---\n        error_sq = 0.0\n        for i in range(N):\n            u_h_prime_val = (U[i + 1] - U[i]) / h\n            integrand = lambda x: (case.u_prime(x) - u_h_prime_val)**2\n            \n            points = [case.f_discontinuity] if case.f_discontinuity and nodes[i]  case.f_discontinuity  nodes[i+1] else None\n            error_sq += quad(integrand, nodes[i], nodes[i+1], points=points)[0]\n\n        energy_error = np.sqrt(error_sq)\n\n        # --- 3. Standard Estimator ---\n        # Residual term\n        eta_res_sq = 0.0\n        for i in range(N):\n            integrand = lambda x: case.f(x)**2\n            points = [case.f_discontinuity] if case.f_discontinuity and nodes[i]  case.f_discontinuity  nodes[i+1] else None\n            integral_f_sq = quad(integrand, nodes[i], nodes[i+1], points=points)[0]\n            eta_res_sq += h**2 * integral_f_sq\n        \n        # Jump term\n        eta_jump_sq = h * np.sum(b**2)\n        eta_std = np.sqrt(eta_res_sq + eta_jump_sq)\n\n        # --- 4. Neumann-Patch Estimator ---\n        eta_div_sq_sum = 0.0\n        if N > 1:\n            for i in range(1, N): # Loop over interior nodes\n                # Local patch stiffness matrix\n                A_p = (1.0 / h) * np.array([[1, -1, 0], [-1, 2, -1], [0, -1, 1]])\n                C = np.array([h/2, h, h/2])\n                \n                # Augmented system matrix\n                M = np.zeros((4,4))\n                M[:3,:3] = A_p\n                M[:3, 3] = C\n                M[3, :3] = C.T\n\n                # Local load vector b_p\n                b_p = np.zeros(3)\n                patch_nodes_idx = [i - 1, i, i + 1]\n                for j_local, j_global in enumerate(patch_nodes_idx):\n                    phi_j = lambda x, j_node=j_global: np.maximum(0, 1 - np.abs(x - nodes[j_node]) / h)\n                    integrand = lambda x: case.f(x) * phi_j(x)\n                    \n                    points = [case.f_discontinuity] if case.f_discontinuity and nodes[i-1]  case.f_discontinuity  nodes[i+1] else None\n                    b_p[j_local] = quad(integrand, nodes[i - 1], nodes[i + 1], points=points)[0]\n\n                # RHS for augmented system\n                F_aug = np.concatenate((b_p, [0]))\n\n                # Solve for (w, lambda)\n                sol_aug = np.linalg.solve(M, F_aug)\n                w = sol_aug[:3]\n\n                # Compute local patch energy\n                eta_i_div_sq = np.dot(w, b_p)\n                eta_div_sq_sum += eta_i_div_sq\n\n        eta_neu = np.sqrt(eta_div_sq_sum + eta_jump_sq)\n\n        # --- 5. Reliability Constants ---\n        C_std = eta_std / energy_error if energy_error > 1e-15 else 0.0\n        C_neu = eta_neu / energy_error if energy_error > 1e-15 else 0.0\n        results.extend([C_std, C_neu])\n\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2540490"}, {"introduction": "对于多维问题，计算效率是关键。本练习将探索一种强大的 $h$-加密技术：各向异性自适应。通过为一个具有拉伸特征的解比较各向同性与各向异性加密，您将亲眼见证如何通过使单元形状与解的行为相匹配，来显著减少达到目标精度所需的自由度数量。[@problem_id:2540498]", "problem": "考虑方形域 $\\Omega = [0,1]^2$ 和目标场 $u_{\\sigma_x,\\sigma_y}:\\Omega\\to\\mathbb{R}$，其定义为\n$$\nu_{\\sigma_x,\\sigma_y}(x,y) = \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma_x^2} - \\frac{(y-\\tfrac{1}{2})^2}{2\\sigma_y^2}\\right),\n$$\n其中 $\\sigma_x \\in (0,1)$ 和 $\\sigma_y \\in (0,1)$ 控制拉伸高斯特征的轴向宽度。考虑在轴对齐的矩形网格上，对连续双线性（也称为 $\\mathbb{Q}_1$）有限元进行自适应 $h$-加密。您将比较各向同性与各向异性单元标记和加密策略，并以自由度数量的代理指标为基准。\n\n使用以下基本依据和定义。\n\n- 双线性插值余项取决于目标场的二阶导数。受此启发并根据标准的各向异性网格自适应实践，在矩形单元 $K = [x_0,x_1]\\times[y_0,y_1]$ 上定义一个局部逐单元误差指标，其中 $h_x = x_1-x_0$，$h_y = y_1-y_0$，面积 $|K|=h_x h_y$，中心点为 $c_K=(\\tfrac{x_0+x_1}{2},\\tfrac{y_0+y_1}{2})$，定义如下\n$$\n\\eta_K = |K|\\left(|u_{xx}(c_K)|\\,h_x^2 + |u_{yy}(c_K)|\\,h_y^2 + 2\\,|u_{xy}(c_K)|\\,h_x h_y\\right),\n$$\n其中 $u_{xx}$、$u_{yy}$ 和 $u_{xy}$ 是 $u_{\\sigma_x,\\sigma_y}$ 的二阶偏导数。\n\n- 全局误差指标为 $\\eta = \\sum_{K\\in\\mathcal{T}} \\eta_K$，其中 $\\mathcal{T}$ 是一个网格。\n\n- 使用Dörfler标记：给定一个体积参数 $\\theta\\in(0,1)$，选择一个基数最小的子集 $\\mathcal{M}\\subset\\mathcal{T}$，使得 $\\sum_{K\\in\\mathcal{M}} \\eta_K \\ge \\theta\\,\\eta$。在实践中，这通过将 $\\{\\eta_K\\}$ 按非增序排序并累加直到满足阈值来实现。\n\n- 在相同的初始网格 $\\mathcal{T}_0$ 上比较两种加密策略：\n  1. 各向同性加密：每个被标记的单元 $K\\in\\mathcal{M}$ 通过在两个方向上对半分割而被加密成 4 个子单元，即在 $x=\\tfrac{x_0+x_1}{2}$ 和 $y=\\tfrac{y_0+y_1}{2}$ 处进行二等分。\n  2. 各向异性加密（方向性）：对于每个被标记的单元 $K\\in\\mathcal{M}$，根据主曲率对 $\\eta_K$ 的相对贡献选择一个单一的分割方向。具体来说，如果 $|u_{yy}(c_K)|\\,h_y \\ge |u_{xx}(c_K)|\\,h_x$，则仅在 $y$ 方向上对半分割，将 $K$ 分成 2 个子单元；否则，仅在 $x$ 方向上对半分割。\n\n- 停止准则：迭代标记和加密过程，直到 $\\eta \\le \\mathrm{TOL}$，或者达到总单元数上限 $N_{\\max}$，或者达到加密迭代次数上限 $I_{\\max}$。硬性上限确保即使在极端参数体系下也能终止。\n\n- 自由度代理指标：对于带有局部悬挂节点约束的 $\\mathbb{Q}_1$ 网格，全局自由度的数量与叶单元的数量成正比，比例系数是一个依赖于网格的常数。为了获得一个稳健且与实现无关的度量，使用叶单元的数量 $N_\\mathrm{elem}$ 作为自由度的代理指标。为每种策略报告此代理指标。\n\n实现一个程序，该程序：\n- 构建一个均匀的 $N_0\\times N_0$ 矩形剖分作为 $\\Omega$ 的初始网格 $\\mathcal{T}_0$。\n- 使用单元中心 $c_K$ 计算 $\\eta_K$。\n- 使用给定的 $\\theta$ 应用Dörfler标记。\n- 根据指定的各向同性或各向异性规则进行加密。\n- 重复以上步骤直至满足停止准则。\n- 对每个测试用例，返回一个三元组 $[N_\\mathrm{iso}, N_\\mathrm{ani}, S]$，其中 $N_\\mathrm{iso}$ 是各向同性加密的最终单元数，$N_\\mathrm{ani}$ 是各向异性加密的最终单元数，$S = N_\\mathrm{iso}/N_\\mathrm{ani}$ 是通过各向异性加密实现的自由度节省率（$S>1$ 的值表示有所节省）。\n\n必须使用 $u_{\\sigma_x,\\sigma_y}$ 的二阶导数的解析表达式：\n$$\nu_{xx}(x,y) = \\left(\\frac{(x-\\tfrac{1}{2})^2}{\\sigma_x^4} - \\frac{1}{\\sigma_x^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\\quad\nu_{yy}(x,y) = \\left(\\frac{(y-\\tfrac{1}{2})^2}{\\sigma_y^4} - \\frac{1}{\\sigma_y^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\n$$\n$$\nu_{xy}(x,y) = \\frac{(x-\\tfrac{1}{2})(y-\\tfrac{1}{2})}{\\sigma_x^2 \\sigma_y^2}\\,u_{\\sigma_x,\\sigma_y}(x,y).\n$$\n\n使用以下测试套件，它涵盖了典型、近各向同性和高度各向异性的特征。常数 $N_{\\max}$ 和 $I_{\\max}$ 是所有测试通用的安全限制。\n\n- 测试 1： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.05,\\,0.6,\\,0.02,\\,8)$。\n- 测试 2： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.025,\\,0.6,\\,0.02,\\,8)$。\n- 测试 3： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.15,\\,0.15,\\,0.6,\\,0.02,\\,8)$。\n- 测试 4： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.30,\\,0.02,\\,0.6,\\,0.02,\\,8)$。\n\n使用 $N_{\\max}=40000$ 和 $I_{\\max}=200$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目本身是对应一个测试的方括号三元组，顺序与上文相同。例如，输出必须具有以下形式\n$[[N_\\mathrm{iso,1},N_\\mathrm{ani,1},S_1],[N_\\mathrm{iso,2},N_\\mathrm{ani,2},S_2],[N_\\mathrm{iso,3},N_\\mathrm{ani,3},S_3],[N_\\mathrm{iso,4},N_\\mathrm{ani,4},S_4]]$，\n所有数字均以十进制表示法书写。本问题不涉及物理单位或角度，任何可能以百分比表示的量都必须表示为 $[0,1]$ 区间内的小数。", "solution": "我们从一个基本属性出发：对于轴对齐矩形上的连续双线性单元，其插值误差与目标场的二阶导数有关。具体来说，每个坐标方向上的泰勒展开余项意味着，单元插值误差的尺度与 $|u_{xx}|h_x^2$、$|u_{yy}|h_y^2$ 以及一个包含 $|u_{xy}|h_x h_y$ 的混合项的线性组合成比例，比例系数与单元面积 $|K|$ 相关。这启发我们定义了能够感知各向异性的指标\n$$\n\\eta_K = |K|\\left(|u_{xx}(c_K)|\\,h_x^2 + |u_{yy}(c_K)|\\,h_y^2 + 2\\,|u_{xy}(c_K)|\\,h_x h_y\\right).\n$$\n该指标不是未知真实误差的简便计算公式，而是一个可计算的代理，它与插值误差的二阶导数结构保持一致。将所有单元的 $\\eta_K$ 相加，得到全局指标 $\\eta$。\n\n我们规定使用参数为 $\\theta\\in(0,1)$ 的 Dörfler 标记（也称体积追踪或 bulk chasing），这是一个经过充分检验的机制，用于定位误差估计中的最大贡献部分。具体而言，如果将局部指标按非增序排列为 $\\eta_{K_1}\\ge\\eta_{K_2}\\ge\\cdots$，则满足 $\\sum_{i=1}^m \\eta_{K_i}\\ge \\theta \\sum_{K}\\eta_K$ 的最小索引 $m$ 决定了被标记的集合 $\\mathcal{M}=\\{K_1,\\dots,K_m\\}$。这确保了在每次迭代中都处理了全局指标的一个固定比例，从而在合理的估计器属性下导向收敛。\n\n比较了两种加密规则：\n\n- 各向同性加密：每个被标记的矩形在两个坐标轴方向上都被对半分割，产生 4 个子单元，其 $(h_x,h_y)$ 各减半。此策略不利用方向信息。\n\n- 各向异性加密：对于一个被标记的单元 $K$，我们评估在 $|u_{yy}(c_K)|\\,h_y$ 与 $|u_{xx}(c_K)|\\,h_x$ 的意义上，哪一项对 $\\eta_K$ 的贡献更强。如果 $|u_{yy}(c_K)|\\,h_y \\ge |u_{xx}(c_K)|\\,h_x$，我们仅沿 $y$ 方向进行分割，将 $h_y$ 减半并产生 2 个子单元。否则，我们仅沿 $x$ 方向进行分割，将 $h_x$ 减半并产生 2 个子单元。该规则旨在最有效地减少主导曲率的贡献。\n\n目标场是一个可分离的高斯脊：\n$$\nu_{\\sigma_x,\\sigma_y}(x,y) = \\exp\\!\\left(-\\frac{(x-\\tfrac{1}{2})^2}{2\\sigma_x^2} - \\frac{(y-\\tfrac{1}{2})^2}{2\\sigma_y^2}\\right),\n$$\n其 Hessian 矩阵具有解析表达式：\n$$\nu_{xx}(x,y) = \\left(\\frac{(x-\\tfrac{1}{2})^2}{\\sigma_x^4} - \\frac{1}{\\sigma_x^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\\quad\nu_{yy}(x,y) = \\left(\\frac{(y-\\tfrac{1}{2})^2}{\\sigma_y^4} - \\frac{1}{\\sigma_y^2}\\right) u_{\\sigma_x,\\sigma_y}(x,y),\n$$\n$$\nu_{xy}(x,y) = \\frac{(x-\\tfrac{1}{2})(y-\\tfrac{1}{2})}{\\sigma_x^2 \\sigma_y^2}\\,u_{\\sigma_x,\\sigma_y}(x,y).\n$$\n值得注意的是，在中心附近，主曲率的量级分别与 $|u_{xx}|\\sim \\sigma_x^{-2}$ 和 $|u_{yy}|\\sim \\sigma_y^{-2}$ 成比例，这意味着当 $\\sigma_y\\ll\\sigma_x$ 时，可能存在很大的各向异性。\n\n算法设计：\n\n- 在 $\\Omega$ 上初始化一个均匀的 $N_0\\times N_0$ 网格。每个单元 $K$ 由其边界 $[x_0,x_1]\\times[y_0,y_1]$ 表示。\n\n- 在每次迭代中：\n  1. 对于每个单元 $K$，计算 $h_x$、$h_y$、中心 $c_K$，评估 $u_{xx}(c_K)$、$u_{yy}(c_K)$ 和 $u_{xy}(c_K)$，然后计算 $\\eta_K$。\n  2. 求和得到 $\\eta$。如果 $\\eta \\le \\mathrm{TOL}$，则停止。否则，将 $\\{\\eta_K\\}$ 按非增序排序，并使用参数 $\\theta$ 进行 Dörfler 标记。\n  3. 根据所选策略加密被标记的单元。对于各向同性加密，用 4 个子单元替换每个被标记的单元。对于各向异性加密，使用方向性规则，为每个被标记的单元生成 2 个子单元。\n  4. 重复以上步骤，直到 $\\eta \\le \\mathrm{TOL}$ 或达到单元数上限 $N_{\\max}$ 或迭代次数上限 $I_{\\max}$。\n\n- 自由度的代理指标是 $N_\\mathrm{elem}$，即叶单元的数量，在终止时报告。\n\n为什么各向异性加密在处理拉伸特征时能节省自由度：\n\n- 考虑在 $y$ 方向解析一个宽度为 $\\sigma_y$、在 $x$ 方向解析一个宽度为 $\\sigma_x$ 的层。各向同性加密会同时减小 $h_x$ 和 $h_y$。为了将主导项 $|u_{yy}|\\,h_y^2$ 减小到目标容差，各向同性加密也不必要地减小了 $h_x$，导致额外的单元数量，其因子与特征的宽高比相当。相比之下，当 $|u_{yy}|\\,h_y$ 占主导时，各向异性规则会选择性地减小 $h_y$，当 $\\sigma_y\\ll\\sigma_x$ 时，这会带来一个量级约为 $\\sigma_x/\\sigma_y$ 的渐近节省因子。\n\n- Dörfler 标记确保算法将加密集中在特征附近和最关键的方向上，对于各向异性场景中的各向异性策略，这导致每个新增单元能更快地降低全局指标。\n\n计算考虑和边界情况：\n\n- 该指标使用单元中心；这是一种计算上高效的采样方法，与平滑的 Hessian 矩阵相符。\n\n- 安全上限 $N_{\\max}$ 和 $I_{\\max}$ 可防止在极端参数体系下出现失控的加密。如果在 $\\eta\\le \\mathrm{TOL}$ 之前达到上限，算法将返回当前的 $N_\\mathrm{elem}$，这对于比较策略仍然具有信息价值。\n\n- 在近各向同性的情况下（例如 $\\sigma_x\\approx\\sigma_y$），两种策略应产生相似的 $N_\\mathrm{elem}$，且比率 $S$ 接近 1。在高度各向异性的情况下（例如 $\\sigma_y\\ll\\sigma_x$），我们期望 $S>1$，表明各向异性策略节省了自由度。\n\n该程序实现了上述算法，并将其应用于指定的测试套件：\n- 测试 1： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.05,\\,0.6,\\,0.02,\\,8)$。\n- 测试 2： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.25,\\,0.025,\\,0.6,\\,0.02,\\,8)$。\n- 测试 3： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.15,\\,0.15,\\,0.6,\\,0.02,\\,8)$。\n- 测试 4： $(\\sigma_x,\\sigma_y,\\theta,\\mathrm{TOL},N_0) = (0.30,\\,0.02,\\,0.6,\\,0.02,\\,8)$。\n\n它输出一行，包含一个由四个三元组 $[N_\\mathrm{iso},N_\\mathrm{ani},S]$ 组成的列表，每个测试一个。结果量化了由各向异性标记带来的自由度节省。虽然该算法专注于 h-加密，但与 p- 和 r-策略的概念性比较如下：p-加密会在解光滑的区域增加多项式次数（高斯函数就是光滑的），可能在不改变网格的情况下减少自由度，但当误差主要由需要固定次数下方向性解析的几何拉伸主导时，其效果不如各向异性。r-加密（节点重定位）可以在不改变连接性的情况下使单元形状适应 Hessian 度量；然而，在强各向异性的情况下，如果宽高比必须超过稳定性界限，仅靠 r-移动可能不足，因此 h-各向异性仍然至关重要。所实现的指标和加密规则通过 h-分裂将曲率驱动的方向性直接编码到网格中，从而反映了这些原则。", "answer": "```python\nimport numpy as np\n\n# Adaptive h-refinement comparison: isotropic vs anisotropic marking on a stretched Gaussian feature.\n# Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4 (not used). No external input/output.\n\ndef u_and_hessian(x, y, sigx, sigy):\n    # Gaussian value and second derivatives at (x,y)\n    cx = 0.5\n    cy = 0.5\n    dx = x - cx\n    dy = y - cy\n    invsx2 = 1.0 / (sigx * sigx)\n    invsy2 = 1.0 / (sigy * sigy)\n    # Value\n    u = np.exp(-0.5 * (dx * dx * invsx2 + dy * dy * invsy2))\n    # Second derivatives\n    u_xx = ((dx * dx) * (invsx2 ** 2) - invsx2) * u\n    u_yy = ((dy * dy) * (invsy2 ** 2) - invsy2) * u\n    u_xy = (dx * dy) * (invsx2 * invsy2) * u\n    return u, u_xx, u_yy, u_xy\n\ndef element_indicator(rect, sigx, sigy):\n    x0, x1, y0, y1 = rect\n    hx = x1 - x0\n    hy = y1 - y0\n    xc = 0.5 * (x0 + x1)\n    yc = 0.5 * (y0 + y1)\n    _, u_xx, u_yy, u_xy = u_and_hessian(xc, yc, sigx, sigy)\n    area = hx * hy\n    eta = area * (abs(u_xx) * (hx ** 2) + abs(u_yy) * (hy ** 2) + 2.0 * abs(u_xy) * hx * hy)\n    return eta, abs(u_xx), abs(u_yy)\n\ndef dorfler_mark(indices, etas, theta):\n    # indices: list of element indices, etas: list of corresponding indicators\n    # return a list of indices to mark according to Dörfler with parameter theta\n    order = sorted(indices, key=lambda i: etas[i], reverse=True)\n    total = sum(etas)\n    if total == 0.0:\n        return []\n    target = theta * total\n    acc = 0.0\n    marked = []\n    for i in order:\n        marked.append(i)\n        acc += etas[i]\n        if acc >= target:\n            break\n    return marked\n\ndef refine_mesh(mesh, marked_set, strategy, sigx, sigy):\n    # strategy: 'iso' or 'ani'\n    new_mesh = []\n    for idx, rect in enumerate(mesh):\n        if idx not in marked_set:\n            new_mesh.append(rect)\n        else:\n            x0, x1, y0, y1 = rect\n            xm = 0.5 * (x0 + x1)\n            ym = 0.5 * (y0 + y1)\n            if strategy == 'iso':\n                # split into 4 children\n                new_mesh.append((x0, xm, y0, ym))\n                new_mesh.append((xm, x1, y0, ym))\n                new_mesh.append((x0, xm, ym, y1))\n                new_mesh.append((xm, x1, ym, y1))\n            else:\n                # anisotropic: decide direction based on |u_yy|*hy vs |u_xx|*hx at center\n                hx = x1 - x0\n                hy = y1 - y0\n                xc = 0.5 * (x0 + x1)\n                yc = 0.5 * (y0 + y1)\n                _, u_xx, u_yy, _ = u_and_hessian(xc, yc, sigx, sigy)\n                if abs(u_yy) * hy >= abs(u_xx) * hx:\n                    # split along y only\n                    new_mesh.append((x0, x1, y0, ym))\n                    new_mesh.append((x0, x1, ym, y1))\n                else:\n                    # split along x only\n                    new_mesh.append((x0, xm, y0, y1))\n                    new_mesh.append((xm, x1, y0, y1))\n    return new_mesh\n\ndef adaptive_refine(sigx, sigy, theta, TOL, N0, strategy, Nmax=40000, Imax=200):\n    # Build initial uniform mesh\n    xs = np.linspace(0.0, 1.0, N0 + 1)\n    ys = np.linspace(0.0, 1.0, N0 + 1)\n    mesh = []\n    for i in range(N0):\n        for j in range(N0):\n            mesh.append((xs[i], xs[i+1], ys[j], ys[j+1]))\n    # Adaptive loop\n    for it in range(Imax):\n        n = len(mesh)\n        etas = [0.0] * n\n        # Compute indicators\n        total_eta = 0.0\n        for i, rect in enumerate(mesh):\n            eta, _, _ = element_indicator(rect, sigx, sigy)\n            etas[i] = eta\n            total_eta += eta\n        if total_eta = TOL:\n            break\n        # Mark with Dörfler\n        indices = list(range(n))\n        marked = dorfler_mark(indices, etas, theta)\n        marked_set = set(marked)\n        # Refine\n        mesh = refine_mesh(mesh, marked_set, strategy, sigx, sigy)\n        if len(mesh) > Nmax:\n            break\n    return len(mesh)\n\ndef run_case(sigx, sigy, theta, TOL, N0):\n    N_iso = adaptive_refine(sigx, sigy, theta, TOL, N0, 'iso')\n    N_ani = adaptive_refine(sigx, sigy, theta, TOL, N0, 'ani')\n    ratio = float(N_iso) / float(N_ani) if N_ani > 0 else float('inf')\n    # Format: integers for counts, ratio as float with reasonable precision\n    return [int(N_iso), int(N_ani), float(f\"{ratio:.6f}\")]\n\ndef solve():\n    # Test suite as specified in the problem statement\n    test_cases = [\n        (0.25, 0.05, 0.6, 0.02, 8),\n        (0.25, 0.025, 0.6, 0.02, 8),\n        (0.15, 0.15, 0.6, 0.02, 8),\n        (0.30, 0.02, 0.6, 0.02, 8),\n    ]\n    results = []\n    for sigx, sigy, theta, TOL, N0 in test_cases:\n        res = run_case(sigx, sigy, theta, TOL, N0)\n        results.append(res)\n    # Print single-line output exactly as required: a list of lists, comma-separated, no extra text\n    # Ensure no spaces for strict formatting\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(lst)\n    print(list_to_str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2540498"}]}