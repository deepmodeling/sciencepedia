{"hands_on_practices": [{"introduction": "第一个练习旨在将理论讨论与具体计算相结合。通过分析一个简单的双自由度系统，我们将直接比较使用标准欧几里得内积和质量加权（$M$-加权）内积时模态振型的相似性。这个实践将阐明为何在结构动力学中，$M$-内积是评估模态特性的自然且物理上正确的框架。 [@problem_id:2578481]", "problem": "考虑来自有限元法 (FEM) 的一个二自由度系统的无阻尼自由振动广义特征值问题，\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi}=\\lambda\\,\\mathbf{M}\\,\\boldsymbol{\\phi},\n$$\n其质量矩阵和刚度矩阵为对称正定矩阵\n$$\n\\mathbf{M}=\\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix},\\qquad\n\\mathbf{K}=\\begin{pmatrix}3  -1 \\\\ -1  1\\end{pmatrix}.\n$$\n从以下基本定义出发：(i) 自由振动满足上述广义特征值问题，(ii) 不同特征值对应的模态关于 $\\mathbf{M}$ 加权内积正交，以及 (iii) 对于 $\\mathbb{R}^n$ 上的任意内积 $\\langle\\cdot,\\cdot\\rangle$，向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间夹角的余弦平方由下式给出\n$$\n\\frac{|\\langle \\mathbf{a},\\mathbf{b}\\rangle|^2}{\\langle \\mathbf{a},\\mathbf{a}\\rangle\\,\\langle \\mathbf{b},\\mathbf{b}\\rangle},\n$$\n一旦选定了内积，这就定义了模态置信准则 (Modal Assurance Criterion, MAC)。\n\n1) 求解广义特征值问题，得到解析特征对 $(\\lambda_1,\\boldsymbol{\\phi}_1)$ 和 $(\\lambda_2,\\boldsymbol{\\phi}_2)$，并通过计算 $\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\,\\boldsymbol{\\phi}_2$ 验证两种模态的 $\\mathbf{M}$ 正交性，以及通过 $\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\boldsymbol{\\phi}_2$ 验证其欧几里得非正交性。\n\n2) 假设一个粗糙的离散化产生了一个近似的第一阶模态振型\n$$\n\\tilde{\\boldsymbol{\\phi}}_1=\\begin{pmatrix}1 \\\\ \\tfrac{9}{5}\\end{pmatrix}.\n$$\n计算精确模态 $\\boldsymbol{\\phi}_1$ 与近似模态 $\\tilde{\\boldsymbol{\\phi}}_1$ 之间的模态置信准则 (MAC)，分别关于：\n- 欧几里得内积 $\\langle \\mathbf{a},\\mathbf{b}\\rangle_{\\mathrm{E}}=\\mathbf{a}^{\\mathsf{T}}\\mathbf{b}$，\n- $\\mathbf{M}$ 加权内积 $\\langle \\mathbf{a},\\mathbf{b}\\rangle_{\\mathbf{M}}=\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b}$。\n\n3) 结合模态正交性和归一化原理，简要解释为什么在这个例子中两个 MAC 值不同。\n\n请提供一个等于下式的单一精确数值作为最终交付结果\n$$\n\\Delta=\\mathrm{MAC}_{\\mathbf{M}}(\\boldsymbol{\\phi}_1,\\tilde{\\boldsymbol{\\phi}}_1)-\\mathrm{MAC}_{\\mathrm{E}}(\\boldsymbol{\\phi}_1,\\tilde{\\boldsymbol{\\phi}}_1),\n$$\n表示为一个最简分数。不包含单位。不要四舍五入；给出精确值。", "solution": "首先对问题陈述进行验证。\n\n逐字提取给定条件：\n1.  控制方程为广义特征值问题 $\\mathbf{K}\\,\\boldsymbol{\\phi}=\\lambda\\,\\mathbf{M}\\,\\boldsymbol{\\phi}$。\n2.  质量矩阵为 $\\mathbf{M}=\\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix}$。\n3.  刚度矩阵为 $\\mathbf{K}=\\begin{pmatrix}3  -1 \\\\ -1  1\\end{pmatrix}$。\n4.  $\\mathbf{M}$ 和 $\\mathbf{K}$ 被说明为对称正定矩阵。\n5.  不同特征值对应的模态关于 $\\mathbf{M}$ 加权内积正交。\n6.  对于一个内积 $\\langle\\cdot,\\cdot\\rangle$，向量 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间夹角的余弦平方由 $\\frac{|\\langle \\mathbf{a},\\mathbf{b}\\rangle|^2}{\\langle \\mathbf{a},\\mathbf{a}\\rangle\\,\\langle \\mathbf{b},\\mathbf{b}\\rangle}$ 给出，这定义了模态置信准则 (MAC)。\n7.  一个近似的第一阶模态振型为 $\\tilde{\\boldsymbol{\\phi}}_1=\\begin{pmatrix}1 \\\\ \\tfrac{9}{5}\\end{pmatrix}$。\n8.  定义了两种内积：欧几里得内积 $\\langle \\mathbf{a},\\mathbf{b}\\rangle_{\\mathrm{E}}=\\mathbf{a}^{\\mathsf{T}}\\mathbf{b}$ 和 $\\mathbf{M}$ 加权内积 $\\langle \\mathbf{a},\\mathbf{b}\\rangle_{\\mathbf{M}}=\\mathbf{a}^{\\mathsf{T}}\\mathbf{M}\\mathbf{b}$。\n9.  最终交付结果为 $\\Delta=\\mathrm{MAC}_{\\mathbf{M}}(\\boldsymbol{\\phi}_1,\\tilde{\\boldsymbol{\\phi}}_1)-\\mathrm{MAC}_{\\mathrm{E}}(\\boldsymbol{\\phi}_1,\\tilde{\\boldsymbol{\\phi}}_1)$。\n\n问题验证如下：\n- **科学依据：**该问题涉及线性时不变机械系统的标准模态分析，这是工程和物理学的核心课题。矩阵具有物理合理性。我们验证其正定性。对于 $\\mathbf{M}$，特征值为 $2$ 和 $1$，均为正数。对于 $\\mathbf{K}$，其主子式为 $\\det(3)=3>0$ 和 $\\det(\\mathbf{K})=3(1)-(-1)(-1)=2>0$。两个矩阵确实都是对称正定矩阵。\n- **良态问题：**该问题是一个标准的广义特征值问题，其矩阵为对称正定矩阵，这保证了特征值为实数、正数，并存在一组 $\\mathbf{M}$ 正交的特征向量。任务具体，并会导出一个唯一的数值答案。\n- **客观性：**问题使用精确的数学语言陈述，没有主观性。\n\n结论是该问题有效。我们继续进行求解。\n\n解答过程遵循问题描述的三个部分进行。\n\n第 1 部分：求解广义特征值问题并验证正交性。\n特征值问题为 $(\\mathbf{K} - \\lambda\\mathbf{M})\\boldsymbol{\\phi} = \\mathbf{0}$。为使解非平凡，特征矩阵的行列式必须为零：\n$$\n\\det(\\mathbf{K} - \\lambda\\mathbf{M}) = \\det\\left(\\begin{pmatrix}3  -1 \\\\ -1  1\\end{pmatrix} - \\lambda \\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix}\\right) = \\det\\begin{pmatrix}3 - 2\\lambda  -1 \\\\ -1  1 - \\lambda\\end{pmatrix} = 0\n$$\n这给出了特征方程：\n$$\n(3 - 2\\lambda)(1 - \\lambda) - (-1)^2 = 0\n$$\n$$\n3 - 3\\lambda - 2\\lambda + 2\\lambda^2 - 1 = 0\n$$\n$$\n2\\lambda^2 - 5\\lambda + 2 = 0\n$$\n求解这个关于 $\\lambda$ 的二次方程：\n$$\n\\lambda = \\frac{-(-5) \\pm \\sqrt{(-5)^2 - 4(2)(2)}}{2(2)} = \\frac{5 \\pm \\sqrt{25-16}}{4} = \\frac{5 \\pm 3}{4}\n$$\n特征值为 $\\lambda_1 = \\frac{5-3}{4} = \\frac{1}{2}$ 和 $\\lambda_2 = \\frac{5+3}{4} = 2$。\n\n对每个特征值，我们求出对应的特征向量（模态振型）。\n对于 $\\lambda_1 = \\frac{1}{2}$：\n$$\n(\\mathbf{K} - \\lambda_1\\mathbf{M})\\boldsymbol{\\phi}_1 = \\begin{pmatrix}3 - 2(\\frac{1}{2})  -1 \\\\ -1  1 - \\frac{1}{2}\\end{pmatrix} \\boldsymbol{\\phi}_1 = \\begin{pmatrix}2  -1 \\\\ -1  \\frac{1}{2}\\end{pmatrix} \\begin{pmatrix}\\phi_{11} \\\\ \\phi_{12}\\end{pmatrix} = \\begin{pmatrix}0 \\\\ 0\\end{pmatrix}\n$$\n这得到方程 $2\\phi_{11} - \\phi_{12} = 0$，即 $\\phi_{12} = 2\\phi_{11}$。选择 $\\phi_{11} = 1$ 得到 $\\boldsymbol{\\phi}_1 = \\begin{pmatrix}1 \\\\ 2\\end{pmatrix}$。\n\n对于 $\\lambda_2 = 2$：\n$$\n(\\mathbf{K} - \\lambda_2\\mathbf{M})\\boldsymbol{\\phi}_2 = \\begin{pmatrix}3 - 2(2)  -1 \\\\ -1  1 - 2\\end{pmatrix} \\boldsymbol{\\phi}_2 = \\begin{pmatrix}-1  -1 \\\\ -1  -1\\end{pmatrix} \\begin{pmatrix}\\phi_{21} \\\\ \\phi_{22}\\end{pmatrix} = \\begin{pmatrix}0 \\\\ 0\\end{pmatrix}\n$$\n这得到方程 $-\\phi_{21} - \\phi_{22} = 0$，即 $\\phi_{22} = -\\phi_{21}$。选择 $\\phi_{21} = 1$ 得到 $\\boldsymbol{\\phi}_2 = \\begin{pmatrix}1 \\\\ -1\\end{pmatrix}$。\n\n特征对为 $(\\lambda_1, \\boldsymbol{\\phi}_1) = (\\frac{1}{2}, \\begin{pmatrix}1 \\\\ 2\\end{pmatrix})$ 和 $(\\lambda_2, \\boldsymbol{\\phi}_2) = (2, \\begin{pmatrix}1 \\\\ -1\\end{pmatrix})$。\n\n我们验证正交性：\n$\\mathbf{M}$-正交性：\n$$\n\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\boldsymbol{\\phi}_2 = \\begin{pmatrix}1  2\\end{pmatrix} \\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix} \\begin{pmatrix}1 \\\\ -1\\end{pmatrix} = \\begin{pmatrix}1  2\\end{pmatrix} \\begin{pmatrix}2 \\\\ -1\\end{pmatrix} = 1(2) + 2(-1) = 0\n$$\n根据理论，模态是 $\\mathbf{M}$-正交的。\n欧几里得非正交性：\n$$\n\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\boldsymbol{\\phi}_2 = \\begin{pmatrix}1  2\\end{pmatrix} \\begin{pmatrix}1 \\\\ -1\\end{pmatrix} = 1(1) + 2(-1) = -1\n$$\n模态在欧几里得意义下不是正交的。\n\n第 2 部分：计算 MAC 值。\n我们比较精确的第一阶模态 $\\boldsymbol{\\phi}_1 = \\begin{pmatrix}1 \\\\ 2\\end{pmatrix}$ 和近似模态 $\\tilde{\\boldsymbol{\\phi}}_1 = \\begin{pmatrix}1 \\\\ \\frac{9}{5}\\end{pmatrix}$。\n\n关于欧几里得内积的 MAC 为：\n$$\n\\mathrm{MAC}_{\\mathrm{E}}(\\boldsymbol{\\phi}_1, \\tilde{\\boldsymbol{\\phi}}_1) = \\frac{|\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\tilde{\\boldsymbol{\\phi}}_1|^2}{(\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\boldsymbol{\\phi}_1)(\\tilde{\\boldsymbol{\\phi}}_1^{\\mathsf{T}}\\tilde{\\boldsymbol{\\phi}}_1)}\n$$\n各项为：\n$\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\tilde{\\boldsymbol{\\phi}}_1 = 1(1) + 2(\\frac{9}{5}) = 1 + \\frac{18}{5} = \\frac{23}{5}$。\n$\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\boldsymbol{\\phi}_1 = 1^2 + 2^2 = 5$。\n$\\tilde{\\boldsymbol{\\phi}}_1^{\\mathsf{T}}\\tilde{\\boldsymbol{\\phi}}_1 = 1^2 + (\\frac{9}{5})^2 = 1 + \\frac{81}{25} = \\frac{25+81}{25} = \\frac{106}{25}$。\n$$\n\\mathrm{MAC}_{\\mathrm{E}} = \\frac{(\\frac{23}{5})^2}{5 \\cdot \\frac{106}{25}} = \\frac{\\frac{529}{25}}{\\frac{530}{25}} = \\frac{529}{530}\n$$\n\n关于 $\\mathbf{M}$ 加权内积的 MAC 为：\n$$\n\\mathrm{MAC}_{\\mathbf{M}}(\\boldsymbol{\\phi}_1, \\tilde{\\boldsymbol{\\phi}}_1) = \\frac{|\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\tilde{\\boldsymbol{\\phi}}_1|^2}{(\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\boldsymbol{\\phi}_1)(\\tilde{\\boldsymbol{\\phi}}_1^{\\mathsf{T}}\\mathbf{M}\\tilde{\\boldsymbol{\\phi}}_1)}\n$$\n各项为：\n$\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\tilde{\\boldsymbol{\\phi}}_1 = \\begin{pmatrix}1  2\\end{pmatrix}\\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix}\\begin{pmatrix}1 \\\\ \\frac{9}{5}\\end{pmatrix} = \\begin{pmatrix}2  2\\end{pmatrix}\\begin{pmatrix}1 \\\\ \\frac{9}{5}\\end{pmatrix} = 2(1) + 2(\\frac{9}{5}) = 2 + \\frac{18}{5} = \\frac{28}{5}$。\n$\\boldsymbol{\\phi}_1^{\\mathsf{T}}\\mathbf{M}\\boldsymbol{\\phi}_1 = \\begin{pmatrix}1  2\\end{pmatrix}\\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix}\\begin{pmatrix}1 \\\\ 2\\end{pmatrix} = 1(2)(1) + 2(1)(2) = 2+4 = 6$。\n$\\tilde{\\boldsymbol{\\phi}}_1^{\\mathsf{T}}\\mathbf{M}\\tilde{\\boldsymbol{\\phi}}_1 = \\begin{pmatrix}1  \\frac{9}{5}\\end{pmatrix}\\begin{pmatrix}2  0 \\\\ 0  1\\end{pmatrix}\\begin{pmatrix}1 \\\\ \\frac{9}{5}\\end{pmatrix} = 1(2)(1) + \\frac{9}{5}(1)(\\frac{9}{5}) = 2 + \\frac{81}{25} = \\frac{50+81}{25} = \\frac{131}{25}$。\n$$\n\\mathrm{MAC}_{\\mathbf{M}} = \\frac{(\\frac{28}{5})^2}{6 \\cdot \\frac{131}{25}} = \\frac{\\frac{784}{25}}{\\frac{786}{25}} = \\frac{784}{786} = \\frac{392}{393}\n$$\n\n第 3 部分：解释。\n模态置信准则 (MAC) 是一个共线性的度量，可解释为两个向量之间夹角的余弦平方。这个“夹角”由所选择的内积定义。\n欧几里得内积 $\\langle\\cdot,\\cdot\\rangle_{\\mathrm{E}}$ 定义了一个标准的几何夹角。\n$\\mathbf{M}$ 加权内积 $\\langle\\cdot,\\cdot\\rangle_{\\mathbf{M}}$ 在一个坐标根据物理系统质量分布进行缩放的空间中定义了一个夹角。这是结构动力学中的自然内积，因为它与动能有关，并且系统的模态正是关于这个内积正交的。\n两个 MAC 值不同，是因为用于测量共线性的底层几何结构不同。除非质量矩阵 $\\mathbf{M}$ 是单位矩阵的标量倍数，否则欧几里得内积和 $\\mathbf{M}$ 加权内积将定义不同的几何结构，从而对同一对向量产生不同的 MAC 值。\n\n最终交付结果的计算：\n我们需要计算 $\\Delta = \\mathrm{MAC}_{\\mathbf{M}} - \\mathrm{MAC}_{\\mathrm{E}}$。\n$$\n\\Delta = \\frac{392}{393} - \\frac{529}{530}\n$$\n为了相减，我们找到公分母，即 $393 \\times 530$。\n$$\n\\Delta = \\frac{392 \\times 530 - 529 \\times 393}{393 \\times 530}\n$$\n分子为：\n$392 \\times 530 = 207760$。\n$529 \\times 393 = 207897$。\n分子 $= 207760 - 207897 = -137$。\n分母为：\n$393 \\times 530 = 208290$。\n因此，差值为：\n$$\n\\Delta = -\\frac{137}{208290}\n$$\n数字 $137$ 是素数，而 $208290$ 不能被 $137$ 整除。因此，这个分数已是最简形式。", "answer": "$$\n\\boxed{-\\frac{137}{208290}}\n$$", "id": "2578481"}, {"introduction": "从解析计算转向数值实现，本练习将解决计算力学中的一个核心挑战：如何在存在浮点运算误差的情况下验证理论属性。您将设计一个稳健的数值程序，以检查一组计算得到的特征向量是否在给定容差内满足$M$-正交性。此练习强调了创建尺度不变且数值稳定的验证工具的重要性，这是开发或使用有限元软件的一项关键技能。 [@problem_id:2578532]", "problem": "考虑在有限元方法背景下的广义对称定正特征值问题：给定矩阵 $K \\in \\mathbb{R}^{n \\times n}$ 和 $M \\in \\mathbb{R}^{n \\times n}$，其中 $K = K^T$ 且 $M = M^T \\succ 0$，一个特征对 $(\\lambda, \\phi)$ 满足 $K \\phi = \\lambda M \\phi$。在精确算术中，与不同特征值相关联的特征向量关于 $M$-内积是正交的。对于一组计算得到的列向量 $\\{\\hat{\\phi}_i\\}_{i=1}^m$（组合为矩阵 $\\hat{\\Phi} \\in \\mathbb{R}^{n \\times m}$），$M$-正交性的数值验证需要仔细处理缩放和舍入误差。\n\n任务：设计并实现一个程序，在给定 $K$、$M$、一个列为计算出的特征向量的矩阵 $\\hat{\\Phi}$ 以及一个公差 $\\epsilon > 0$ 的情况下，返回一个布尔值，指示向量集 $\\{\\hat{\\phi}_i\\}$ 是否在公差 $\\epsilon$ 内是 $M$-正交的。此验证必须仅基于基本定义：$M$-内积 $\\langle x, y \\rangle_M := x^T M y$ 和正交性定义 $\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M = 0$（对于 $i \\neq j$）。您的程序必须对 $\\hat{\\Phi}$ 的列进行非零重缩放保持不变，并且必须能稳健地检测无效输入，例如零列（其违反了正定性所蕴含的对于非零 $\\hat{\\phi}_i$ 有 $\\hat{\\phi}_i^T M \\hat{\\phi}_i > 0$ 的性质）。\n\n验证程序的规范：\n- 输入：$K \\in \\mathbb{R}^{n \\times n}$ 且 $K = K^T$，$M \\in \\mathbb{R}^{n \\times n}$ 且 $M = M^T \\succ 0$，$\\hat{\\Phi} \\in \\mathbb{R}^{n \\times m}$，以及 $\\epsilon \\in \\mathbb{R}$ 且 $\\epsilon > 0$。\n- 计算格拉姆矩阵 (Gram matrix) $G := \\hat{\\Phi}^T M \\hat{\\Phi} \\in \\mathbb{R}^{m \\times m}$，其元素为 $g_{ij} = \\hat{\\phi}_i^T M \\hat{\\phi}_j$。\n- 令 $d_i := g_{ii}$，其中 $i \\in \\{1,\\dots,m\\}$。如果任何 $d_i \\le 0$，则声明该向量集非 $M$-正交（返回 false）。\n- 为 $i \\ne j$ 定义归一化相关系数 $c_{ij} := \\dfrac{g_{ij}}{\\sqrt{d_i d_j}}$。这种归一化消除了对列缩放的敏感性。\n- 令 $\\eta := \\max_{i \\ne j} |c_{ij}|$。对于 $m = 1$ 的情况，定义 $\\eta := 0$。\n- 当且仅当 $\\eta \\le \\epsilon$ 时返回 true；否则返回 false。\n\n您的程序必须将此验证实现为一个纯函数，并将其应用于以下确定性测试套件。在每个测试用例中，使用提供的 $M$、$\\hat{\\Phi}$ 和 $\\epsilon$。您可以将 $K$ 设置为任何兼容尺寸的对称矩阵；验证过程不会使用它，但包含它是为了保持问题的背景。\n\n测试套件：\n- 测试 1（尺度不变性，精确 $M$-正交性）：\n  - $M_1 = \\operatorname{diag}(4,3,2,5)$。\n  - $\\hat{\\Phi}_1 = [7 e_1, -2 e_2, 0.5 e_3]$，其中 $e_i$ 表示 $\\mathbb{R}^4$ 中的第 $i$ 个标准基向量。\n  - $\\epsilon_1 = 10^{-12}$。\n  - 预期布尔值：true。\n- 测试 2（微小违规，严格公差）：\n  - $M_1$ 如上。\n  - $\\hat{\\Phi}_2 = [e_1 + 10^{-3} e_2, e_2, e_3]$ 于 $\\mathbb{R}^4$ 中。\n  - $\\epsilon_2 = 10^{-6}$。\n  - 预期布尔值：false。\n- 测试 3（相同违规，较宽松公差）：\n  - $M_1$ 如上。\n  - $\\hat{\\Phi}_3 = [e_1 + 10^{-3} e_2, e_2, e_3]$ 于 $\\mathbb{R}^4$ 中。\n  - $\\epsilon_3 = 10^{-2}$。\n  - 预期布尔值：true。\n- 测试 4（单个向量，空洞正交性）：\n  - $M_2 = \\begin{bmatrix}2  0  0 \\\\ 0  5  1 \\\\ 0  1  3\\end{bmatrix}$。\n  - $\\hat{\\Phi}_4 = [[1,2,3]^T]$（$\\mathbb{R}^3$ 中的单个列向量）。\n  - $\\epsilon_4 = 10^{-12}$。\n  - 预期布尔值：true。\n- 测试 5（在 $M$ 下的非正交对，退化子空间示例）：\n  - $M_3 = \\operatorname{diag}(2,2)$。\n  - $\\hat{\\Phi}_5 = [[1,0]^T, [1,1]^T]$ 于 $\\mathbb{R}^2$ 中。\n  - $\\epsilon_5 = 0.5$。\n  - 预期布尔值：false。\n- 测试 6（包含零列的无效输入）：\n  - $M_4 = \\operatorname{diag}(1,1)$。\n  - $\\hat{\\Phi}_6 = [[1,0]^T, [0,0]^T]$ 于 $\\mathbb{R}^2$ 中。\n  - $\\epsilon_6 = 10^{-12}$。\n  - 预期布尔值：false。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按测试 1 到 6 顺序排列的结果，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是所用编程语言的规范布尔文字格式的布尔值。", "solution": "该问题要求设计并实现一个程序来验证一组向量的数值 $M$-正交性。此任务在有限元方法的背景下至关重要，尤其是在模态分析中，广义特征值问题 $K \\phi = \\lambda M \\phi$ 的特征向量必须相对于质量矩阵 $M$ 正交。我们将首先验证问题陈述，然后基于严谨的数学原理构建解决方案。\n\n该问题是有效的。它在科学上基于数值线性代数的既定原则，问题表述清晰，具有明确和确定性的规则，并使用客观、无歧义的语言表达。它提出了一个标准的、非平凡的验证任务，需要仔细实现。所有测试用例的必要数据都已提供。因此，我们可以着手解决该问题。\n\n问题的核心在于由对称正定矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 导出的内积的定义。对于任意两个向量 $x, y \\in \\mathbb{R}^n$，其 $M$-内积定义为：\n$$\n\\langle x, y \\rangle_M := x^T M y\n$$\n$M$ 的正定性 ($M \\succ 0$) 确保了此定义满足内积的所有公理。具体而言，对于所有非零向量 $x$，有 $\\langle x, x \\rangle_M = x^T M x > 0$。向量的 $M$-范数则为 $\\|x\\|_M = \\sqrt{\\langle x, x \\rangle_M}$。\n\n如果对于所有 $i \\neq j$ 都有 $\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M = 0$，则称向量集 $\\{\\hat{\\phi}_i\\}_{i=1}^m$ 是 $M$-正交的。在数值计算中，结果会受到舍入误差的影响，因此我们必须在指定的公差 $\\epsilon$ 内验证此条件。\n\n指定的验证程序正确地将此任务形式化。让我们分析每个步骤。\n\n1.  **计算格拉姆矩阵 $G$**：\n    该过程首先计算格拉姆矩阵 $G \\in \\mathbb{R}^{m \\times m}$，其元素是 $\\hat{\\Phi} = [\\hat{\\phi}_1, \\dots, \\hat{\\phi}_m]$ 各列的成对 $M$-内积。元素 $g_{ij}$ 由下式给出：\n    $$\n    g_{ij} = \\hat{\\phi}_i^T M \\hat{\\phi}_j = \\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M\n    $$\n    这可以用矩阵符号紧凑地表示为 $G = \\hat{\\Phi}^T M \\hat{\\Phi}$。对角线元素为 $g_{ii} = \\hat{\\phi}_i^T M \\hat{\\phi}_i = \\|\\hat{\\phi}_i\\|_M^2$，即向量的 $M$-范数的平方。非对角线元素 $g_{ij}$ ($i \\neq j$) 是对于一个 $M$-正交集应为零的量。\n\n2.  **验证向量范数**：\n    下一步是检查对角线元素 $d_i := g_{ii}$。条件是如果任何 $d_i \\le 0$，则返回 `false`。这是一个关键的有效性检查。由于 $M$ 是正定的，$\\hat{\\phi}_i^T M \\hat{\\phi}_i$ 仅当 $\\hat{\\phi}_i$ 是零向量时才可能为零，并且不能为负。在一个旨在表示特征向量的集合中出现零向量是一种异常情况；这样的向量不能成为正交基的一部分。因此，任何满足 $\\|\\hat{\\phi}_i\\|_M^2 \\le 0$ 的 $\\hat{\\phi}_i$ 都会立即使该集合对于正交性验证无效。此检查还防止了在后续归一化步骤中出现除以零的情况。\n\n3.  **归一化以实现尺度不变性**：\n    特征向量的定义仅在非零缩放因子下是唯一的。一个稳健的验证程序必须对此类缩放保持不变。如果我们将 $\\hat{\\phi}_i$ 替换为 $\\alpha_i \\hat{\\phi}_i$ 并将 $\\hat{\\phi}_j$ 替换为 $\\alpha_j \\hat{\\phi}_j$（其中 $\\alpha_i, \\alpha_j \\neq 0$），内积变为 $g_{ij}' = \\alpha_i \\alpha_j g_{ij}$。因此，$g_{ij}$ 的原始值不是一个可靠的正交性度量。\n    该程序规定计算归一化相关系数：\n    $$\n    c_{ij} := \\frac{g_{ij}}{\\sqrt{d_i d_j}} = \\frac{\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M}{\\sqrt{\\|\\hat{\\phi}_i\\|_M^2 \\|\\hat{\\phi}_j\\|_M^2}} = \\frac{\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M}{\\|\\hat{\\phi}_i\\|_M \\|\\hat{\\phi}_j\\|_M}\n    $$\n    这个量 $c_{ij}$ 是在赋予了 $M$-内积的希尔伯特空间 (Hilbert space) 中向量 $\\hat{\\phi}_i$ 和 $\\hat{\\phi}_j$ 之间夹角的余弦。根据此内积的柯西-施瓦茨不等式 (Cauchy-Schwarz inequality)，我们有 $|\\langle \\hat{\\phi}_i, \\hat{\\phi}_j \\rangle_M| \\le \\|\\hat{\\phi}_i\\|_M \\|\\hat{\\phi}_j\\|_M$，这意味着 $|c_{ij}| \\le 1$。$c_{ij}$ 的值与 $\\hat{\\phi}_i$ 和 $\\hat{\\phi}_j$ 的缩放无关，因此满足了尺度不变性的要求。对于完美的正交性，$c_{ij}=0$。\n\n4.  **量化整体正交性偏差**：\n    为了评估整个集合，我们必须找到所有不同向量对之间与正交性的最大偏差。这由度量 $\\eta$ 捕获：\n    $$\n    \\eta := \\max_{i \\neq j} |c_{ij}|\n    $$\n    该度量代表了集合中最坏情况下的“正交性误差”。对于单个向量的特殊情况（$m \\le 1$），不存在不同的向量对，因此正交性条件是空洞地满足的。该程序在这种情况下正确地定义了 $\\eta := 0$。\n\n5.  **最终裁决**：\n    最后一步是将最坏情况偏差 $\\eta$ 与指定的公差 $\\epsilon > 0$ 进行比较。如果 $\\eta \\le \\epsilon$，则认为集合 $\\{\\hat{\\phi}_i\\}$ 是数值上 $M$-正交的。这为验证提供了一个清晰、量化且稳健的标准。\n\n该程序是针对所述任务的一个完整且数学上合理的算法。我们现在将用代码实现它，并将其应用于所提供的测试套件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_m_orthogonal(M: np.ndarray, Phi: np.ndarray, epsilon: float) -> bool:\n    \"\"\"\n    Verifies if the columns of Phi are M-orthogonal within a given tolerance.\n\n    Args:\n        M (np.ndarray): A symmetric positive definite matrix (n x n).\n        Phi (np.ndarray): A matrix whose columns are the vectors to be checked (n x m).\n        epsilon (float): A positive tolerance for orthogonality.\n\n    Returns:\n        bool: True if the columns of Phi are M-orthogonal within tolerance, False otherwise.\n    \"\"\"\n    if not isinstance(M, np.ndarray) or not isinstance(Phi, np.ndarray):\n        raise TypeError(\"Inputs M and Phi must be numpy arrays.\")\n    \n    if M.ndim != 2 or Phi.ndim != 2:\n        raise ValueError(\"Inputs M and Phi must be 2D arrays.\")\n\n    n_m, n_m_check = M.shape\n    n_phi, m = Phi.shape\n\n    if n_m != n_m_check or n_m != n_phi:\n        raise ValueError(\"Matrix dimensions are not compatible for multiplication.\")\n\n    if epsilon = 0:\n        raise ValueError(\"Tolerance epsilon must be positive.\")\n\n    # Per the specification, for m=1, eta is 0 if the vector is valid.\n    if m = 1:\n        if m == 0:\n            return True # An empty set of vectors is vacuously orthogonal.\n        \n        # Case m = 1\n        phi_1 = Phi[:, 0]\n        d1 = phi_1.T @ M @ phi_1\n        \n        # If d1 = 0, the vector is a zero vector (since M is positive definite),\n        # which is invalid.\n        if d1 = 0:\n            return False\n        \n        # For a single valid vector, orthogonality is vacuously true (eta=0).\n        # Since epsilon > 0, eta = epsilon is always true.\n        return True\n\n    # Compute the Gram matrix: G = Phi^T * M * Phi\n    G = Phi.T @ M @ Phi\n\n    # Extract the diagonal entries d_i = g_ii\n    d = np.diagonal(G)\n\n    # Check for invalid vectors: d_i must be > 0.\n    # If any d_i = 0, it implies a zero vector or M is not SPD.\n    if np.any(d = 0):\n        return False\n\n    # Compute the normalized correlation coefficients c_ij = g_ij / sqrt(d_i * d_j)\n    # We do not need to compute the full matrix C. We only need the max of off-diagonals.\n    \n    # An efficient way to compute sqrt(d_i * d_j) matrix is via an outer product.\n    d_sqrt = np.sqrt(d)\n    denom_matrix = np.outer(d_sqrt, d_sqrt)\n    \n    # Avoid division by zero, though the check d = 0 should already prevent this.\n    # Add a small machine epsilon for safety in floating point arithmetic.\n    denom_matrix[denom_matrix == 0] = np.finfo(float).eps\n    \n    C = np.abs(G / denom_matrix)\n    \n    # Set diagonal elements to 0 to only consider off-diagonal pairs (i != j)\n    np.fill_diagonal(C, 0)\n    \n    # Find the maximum absolute off-diagonal value\n    eta = np.max(C)\n    \n    return eta = epsilon\n\ndef solve():\n    \"\"\"\n    Runs the deterministic test suite for the M-orthogonality verification procedure.\n    \"\"\"\n    # Define standard basis vectors for convenience\n    e1_4d = np.array([1., 0., 0., 0.])\n    e2_4d = np.array([0., 1., 0., 0.])\n    e3_4d = np.array([0., 0., 1., 0.])\n\n    # Test Case 1: Scale invariance, exact M-orthogonality\n    M1 = np.diag([4., 3., 2., 5.])\n    Phi1 = np.array([7. * e1_4d, -2. * e2_4d, 0.5 * e3_4d]).T\n    epsilon1 = 1e-12\n\n    # Test Case 2: Small violation, strict tolerance\n    Phi2 = np.array([e1_4d + 1e-3 * e2_4d, e2_4d, e3_4d]).T\n    epsilon2 = 1e-6\n\n    # Test Case 3: Same violation, looser tolerance\n    Phi3 = np.copy(Phi2)\n    epsilon3 = 1e-2\n\n    # Test Case 4: Single vector, vacuous orthogonality\n    M2 = np.array([[2., 0., 0.], [0., 5., 1.], [0., 1., 3.]])\n    Phi4 = np.array([[1., 2., 3.]]).T\n    epsilon4 = 1e-12\n\n    # Test Case 5: Non-orthogonal pair under M\n    M3 = np.diag([2., 2.])\n    Phi5 = np.array([[1., 0.], [1., 1.]]).T\n    epsilon5 = 0.5\n\n    # Test Case 6: Invalid input with a zero column\n    M4 = np.diag([1., 1.])\n    Phi6 = np.array([[1., 0.], [0., 0.]]).T\n    epsilon6 = 1e-12\n\n    test_cases = [\n        (M1, Phi1, epsilon1),\n        (M1, Phi2, epsilon2),\n        (M1, Phi3, epsilon3),\n        (M2, Phi4, epsilon4),\n        (M3, Phi5, epsilon5),\n        (M4, Phi6, epsilon6),\n    ]\n\n    results = []\n    for M, Phi, epsilon in test_cases:\n        # K is not needed for the verification procedure\n        result = is_m_orthogonal(M, Phi, epsilon)\n        results.append(result)\n        \n    # Format the output as a comma-separated list of lowercase boolean literals.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "2578532"}, {"introduction": "最后一个练习处理一个更高级也更精细的情景：重根特征值问题，此时系统存在退化的特征子空间而非唯一的特征向量。您将开发一个验证算法，以确定一组计算得到的向量是否为正确的不变子空间构成了一个有效的$M$-标准正交基。这个问题将我们从单个向量的正交性验证，提升到子空间验证的层面，这是处理物理系统中对称性或近似对称性时的关键概念。 [@problem_id:2578529]", "problem": "给定一个由一对实矩阵 $\\mathbf{K} \\in \\mathbb{R}^{n \\times n}$ 和 $\\mathbf{M} \\in \\mathbb{R}^{n \\times n}$ 描述的对称矩阵束，其中 $\\mathbf{K}$ 是对称的，$\\mathbf{M}$ 是对称正定的。考虑广义特征值问题 $\\mathbf{K}\\mathbf{x} = \\lambda \\mathbf{M}\\mathbf{x}$。假设存在一个二重特征值 $\\lambda_0$，其特征空间的维数为 $2$，并且在该矩阵束下是不变的。一个由一对列向量组装成的矩阵 $\\mathbf{U} \\in \\mathbb{R}^{n \\times 2}$ 被声称是该特征空间的基。在有限元法中，模态正交性和归一化是相对于 $\\mathbf{M}$-内积来表示的。目标是利用基本原理来验证所提供的 $\\mathbf{U}$ 是否既能张成与 $\\lambda_0$ 相关的正确不变子空间，又是关于 $\\mathbf{M}$-内积标准正交的。\n\n从基本定义出发：\n- 与 $\\lambda_0$ 相关的不变子空间是满足 $(\\mathbf{K} - \\lambda_0 \\mathbf{M})\\mathbf{x} = \\mathbf{0}$ 的向量 $\\mathbf{x}$ 的集合。对于一个基矩阵 $\\mathbf{U} \\in \\mathbb{R}^{n \\times 2}$，若要张成该子空间，其每个列向量在理想情况下都必须满足相同的关系。在数值上，一个在适当相对范数下的小残差是可以接受的。\n- $\\mathbf{U}$ 的列向量的 $\\mathbf{M}$-标准正交性意味着 $\\mathbf{U}^{\\top}\\mathbf{M}\\mathbf{U} = \\mathbf{I}_2$，其中 $\\mathbf{I}_2$ 是大小为 $2$ 的单位矩阵。\n\n您的任务是编写一个程序，对每个提供的测试用例，返回一个布尔值，该值指示以下两个数值检验是否都通过：\n1. $\\mathbf{M}$-标准正交性：$\\mathbf{U}^{\\top}\\mathbf{M}\\mathbf{U} - \\mathbf{I}_2$ 的 Frobenius 范数小于或等于一个给定的容差 $\\tau_{\\mathrm{orth}}$。\n2. $\\lambda_0$ 处的不变子空间：相对 Frobenius 范数残差\n$$\n\\rho = \\frac{\\lVert (\\mathbf{K} - \\lambda_0 \\mathbf{M}) \\mathbf{U} \\rVert_F}{\\left(\\lVert \\mathbf{K} \\rVert_F + |\\lambda_0| \\lVert \\mathbf{M} \\rVert_F\\right)\\lVert \\mathbf{U} \\rVert_F}\n$$\n小于或等于一个给定的容差 $\\tau_{\\mathrm{inv}}$。\n\n对所有测试用例使用以下数值容差：$\\tau_{\\mathrm{orth}} = 10^{-10}$ 和 $\\tau_{\\mathrm{inv}} = 10^{-8}$。\n\n测试套件包含五个用例，这些用例由一个具有 $n = 5$ 和一个精确二重特征值的公共矩阵束构建而成。该矩阵束的构造如下：\n- 定义 $\\mathbf{M} = \\mathrm{diag}(m_1, m_2, m_3, m_4, m_5)$，其中 $m_1 = 1.5$，$m_2 = 2.5$，$m_3 = 3.25$，$m_4 = 4.0$，$m_5 = 6.0$。\n- 设 $\\mathbf{Q} \\in \\mathbb{R}^{5 \\times 5}$ 是一个正交矩阵，并设置精确特征值 $\\boldsymbol{\\Lambda} = \\mathrm{diag}(\\lambda_1, \\ldots, \\lambda_5)$，其中 $\\lambda_1 = \\lambda_2 = 2.0$，$\\lambda_3 = 5.0$，$\\lambda_4 = 7.0$，$\\lambda_5 = 11.0$。令 $\\mathbf{M}^{1/2} = \\mathrm{diag}(\\sqrt{m_1}, \\ldots, \\sqrt{m_5})$ 并定义 $\\mathbf{K} = \\mathbf{M}^{1/2}\\mathbf{Q}\\boldsymbol{\\Lambda}\\mathbf{Q}^{\\top}\\mathbf{M}^{1/2}$。那么 $(\\mathbf{K},\\mathbf{M})$ 就是一个具有所需谱的对称矩阵束。\n- 精确的 $\\mathbf{M}$-标准正交特征向量矩阵为 $\\mathbf{X} = \\mathbf{M}^{-1/2}\\mathbf{Q}$，满足 $\\mathbf{X}^{\\top}\\mathbf{M}\\mathbf{X} = \\mathbf{I}_5$ 和 $\\mathbf{K}\\mathbf{X} = \\mathbf{M}\\mathbf{X}\\boldsymbol{\\Lambda}$。该二重特征值的特征空间由 $\\mathbf{X}$ 的前两列张成。\n\n对于所有五个测试，取 $\\lambda_0 = 2.0$。按如下方式构造五个候选基 $\\mathbf{U}$：\n- 测试 1（理想情况）：$\\mathbf{U} = \\mathbf{U}_\\star \\mathbf{R}$，其中 $\\mathbf{U}_\\star = \\mathbf{X}[:,0:2]$ 且 $\\mathbf{R}$ 是一个旋转角为 $\\theta = 0.4$ 弧度的 $2 \\times 2$ 旋转矩阵，即 $\\mathbf{R} = \\begin{bmatrix}\\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta\\end{bmatrix}$。这应该是 $\\mathbf{M}$-标准正交且不变的。\n- 测试 2（正确的子空间，但非标准正交）：$\\mathbf{U} = \\mathbf{U}_\\star \\mathbf{C}$，其中 $\\mathbf{C} = \\begin{bmatrix}1.5  0.3 \\\\ 0  0.6\\end{bmatrix}$。它张成了正确的子空间，但违反了 $\\mathbf{M}$-标准正交性。\n- 测试 3（$\\mathbf{M}$-标准正交但子空间错误）：$\\mathbf{U} = [\\mathbf{X}[:,0], \\mathbf{X}[:,2]]$，即一个来自二重特征空间的向量和另一个来自不同特征值的向量。这是 $\\mathbf{M}$-标准正交的，但在 $\\lambda_0$ 处不是不变的。\n- 测试 4（应该仍然能通过的邻近扰动）：$\\mathbf{U}$ 是通过扰动 $\\mathbf{U}_\\star$ 得到的，即 $\\mathbf{U}_{\\mathrm{tmp}} = \\mathbf{U}_\\star + \\varepsilon \\mathbf{X}[:,2:4]$，其中 $\\varepsilon = 10^{-11}$，然后对 $\\mathbf{U}_{\\mathrm{tmp}}$ 的两列进行精确的 $\\mathbf{M}$-标准正交化，这通过对 $\\mathbf{U}_{\\mathrm{tmp}}^{\\top}\\mathbf{M}\\mathbf{U}_{\\mathrm{tmp}}$ 进行 Cholesky 分解实现；得到的 $\\mathbf{U}$ 应该在容差范围内于 $\\lambda_0$ 处是不变的，并且是 $\\mathbf{M}$-标准正交的。\n- 测试 5（秩亏）：$\\mathbf{U} = [\\mathbf{X}[:,0], \\mathbf{X}[:,0] + 10^{-14}\\mathbf{X}[:,1]]$。这未通过 $\\mathbf{M}$-标准正交性检验。\n\n您的程序必须：\n- 按规定构建 $\\mathbf{M}$、$\\mathbf{Q}$、$\\boldsymbol{\\Lambda}$、$\\mathbf{K}$ 和 $\\mathbf{X}$。\n- 为五个测试构造每个 $\\mathbf{U}$。\n- 对于每个 $\\mathbf{U}$，使用 $\\tau_{\\mathrm{orth}} = 10^{-10}$ 和 $\\tau_{\\mathrm{inv}} = 10^{-8}$ 评估上述两个检验，生成一个布尔结果，当且仅当两个检验都通过时为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5]”），其中每个结果都是一个布尔字面量。不应打印任何额外文本。", "solution": "问题陈述已被解析和验证。我们发现它在科学上是合理的、良态的，并且是数值线性代数中一个明确的练习，特别是关于验证广义特征值问题的特征空间。该问题是有效的，将提供一个解决方案。\n\n问题的核心是验证一个给定的矩阵 $\\mathbf{U} \\in \\mathbb{R}^{n \\times 2}$ 是否为对称矩阵束 $(\\mathbf{K}, \\mathbf{M})$ 的一个二重特征值 $\\lambda_0$ 所对应的二维不变子空间的一个 $\\mathbf{M}$-标准正交基。其控制方程是广义特征值问题 $\\mathbf{K}\\mathbf{x} = \\lambda\\mathbf{M}\\mathbf{x}$，其中 $\\mathbf{K}$ 是对称矩阵，$\\mathbf{M}$ 是对称正定矩阵。\n\n该问题的解的性质是基础性的。特征值 $\\lambda_i$ 是实数，并且对应的特征向量 $\\mathbf{x}_i$ 可以被选择为 $\\mathbf{M}$-正交的，即当 $\\lambda_i \\neq \\lambda_j$ 时，$\\mathbf{x}_i^{\\top}\\mathbf{M}\\mathbf{x}_j = 0$。如果一个特征向量 $\\mathbf{x}_i$ 被归一化以至于 $\\mathbf{x}_i^{\\top}\\mathbf{M}\\mathbf{x}_i = 1$，那么所有这些特征向量的集合就构成一个 $\\mathbf{M}$-标准正交基。\n\n对于一个候选基 $\\mathbf{U}$，必须满足两个条件：它必须张成正确的不变子空间，并且必须相对于 $\\mathbf{M}$-内积是标准正交的。这两个条件被转化为数值检验。\n\n首先，$\\mathbf{U}$ 的列的 $\\mathbf{M}$-标准正交性条件表示为：\n$$\n\\mathbf{U}^{\\top}\\mathbf{M}\\mathbf{U} = \\mathbf{I}_2\n$$\n其中 $\\mathbf{I}_2$ 是 $2 \\times 2$ 的单位矩阵。在数值计算中，我们不期望完全相等。我们通过检查与单位矩阵的偏差的范数是否在指定的容差 $\\tau_{\\mathrm{orth}}$ 内来验证此条件。Frobenius 范数是该矩阵范数的一个合适选择。检验条件是：\n$$\n\\lVert \\mathbf{U}^{\\top}\\mathbf{M}\\mathbf{U} - \\mathbf{I}_2 \\rVert_F \\le \\tau_{\\mathrm{orth}}\n$$\n\n其次，要使 $\\mathbf{U}$ 成为对应于特征值 $\\lambda_0$ 的不变子空间（特征空间）的基，$\\mathbf{U}$ 的列空间中的每个向量都必须是 $\\lambda_0$ 的特征向量。这等同于要求 $\\mathbf{U}$ 的每一列都满足特征值方程，可以紧凑地写成：\n$$\n(\\mathbf{K} - \\lambda_0 \\mathbf{M})\\mathbf{U} = \\mathbf{0}\n$$\n矩阵 $(\\mathbf{K} - \\lambda_0 \\mathbf{M})\\mathbf{U}$ 是残差矩阵。同样，由于有限精度算术和 $\\mathbf{U}$ 中潜在的微小扰动，该残差不会完全为零。我们使用相对残差来衡量其大小，以避免与问题矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$ 的整体缩放相关的问题。相对 Frobenius 范数残差 $\\rho$ 定义为：\n$$\n\\rho = \\frac{\\lVert (\\mathbf{K} - \\lambda_0 \\mathbf{M}) \\mathbf{U} \\rVert_F}{\\left(\\lVert \\mathbf{K} \\rVert_F + |\\lambda_0| \\lVert \\mathbf{M} \\rVert_F\\right)\\lVert \\mathbf{U} \\rVert_F}\n$$\n这个相对残差必须小于或等于给定的容差 $\\tau_{\\mathrm{inv}}$。分母为问题提供了一个自然的尺度。一个候选基 $\\mathbf{U}$ 仅当两个数值检验都通过时才被认为是有效的。\n\n为了进行测试，我们首先构造指定的矩阵束。质量矩阵 $\\mathbf{M}$ 是一个大小为 n=5 的对角矩阵：\n$$\n\\mathbf{M} = \\mathrm{diag}(1.5, 2.5, 3.25, 4.0, 6.0)\n$$\n特征值被指定为 $\\boldsymbol{\\Lambda} = \\mathrm{diag}(2.0, 2.0, 5.0, 7.0, 11.0)$。需要一个固定的正交矩阵 $\\mathbf{Q} \\in \\mathbb{R}^{5 \\times 5}$。为了可复现性，我们通过对一个固定的随机矩阵执行 QR 分解来生成 $\\mathbf{Q}$。利用 $\\mathbf{M}^{1/2} = \\mathrm{diag}(\\sqrt{m_i})$，刚度矩阵 $\\mathbf{K}$ 被构造为 $\\mathbf{K} = \\mathbf{M}^{1/2}\\mathbf{Q}\\boldsymbol{\\Lambda}\\mathbf{Q}^{\\top}\\mathbf{M}^{1/2}$。这种构造保证了 $(\\mathbf{K}, \\mathbf{M})$ 是一个具有指定特征值 $\\boldsymbol{\\Lambda}$ 的对称矩阵束。相应地，精确的 $\\mathbf{M}$-标准正交特征向量矩阵由 $\\mathbf{X} = \\mathbf{M}^{-1/2}\\mathbf{Q}$ 给出。二重特征值 $\\lambda_0 = 2.0$ 的特征空间由 $\\mathbf{X}$ 的前两列张成，我们将其表示为 $\\mathbf{U}_\\star = \\mathbf{X}[:,0:2]$。\n\n五个测试用例的构造如下：\n1.  **测试 1**：对真实基应用旋转：$\\mathbf{U}_1 = \\mathbf{U}_\\star \\mathbf{R}$，其中 $\\mathbf{R}$ 是一个 $2 \\times 2$ 旋转矩阵。由于旋转矩阵是正交的，$\\mathbf{U}_1$ 保持 $\\mathbf{M}$-标准正交性：$\\mathbf{U}_1^{\\top}\\mathbf{M}\\mathbf{U}_1 = \\mathbf{R}^{\\top}\\mathbf{U}_\\star^{\\top}\\mathbf{M}\\mathbf{U}_\\star \\mathbf{R} = \\mathbf{R}^{\\top}\\mathbf{I}_2\\mathbf{R} = \\mathbf{I}_2$。子空间保持不变。两个检验都应该通过。\n2.  **测试 2**：真实基向量的非正交线性组合：$\\mathbf{U}_2 = \\mathbf{U}_\\star \\mathbf{C}$。这个 $\\mathbf{U}_2$ 仍然张成正确的子空间，所以不变子空间检验应该会通过。然而，$\\mathbf{U}_2^{\\top}\\mathbf{M}\\mathbf{U}_2 = \\mathbf{C}^{\\top}\\mathbf{C} \\neq \\mathbf{I}_2$，所以标准正交性检验应该会失败。\n3.  **测试 3**：一个由不同特征值的特征向量构造的基：$\\mathbf{U}_3 = [\\mathbf{x}_1, \\mathbf{x}_3]$。根据构造，这个基是 $\\mathbf{M}$-标准正交的。然而，向量 $\\mathbf{x}_3$ 不在 $\\lambda_0 = 2.0$ 的特征空间中，而是在 $\\lambda_3 = 5.0$ 的特征空间中。因此，$(\\mathbf{K} - \\lambda_0\\mathbf{M})\\mathbf{x}_3 = (\\lambda_3 - \\lambda_0)\\mathbf{M}\\mathbf{x}_3 \\neq \\mathbf{0}$。不变子空间检验将失败。\n4.  **测试 4**：一个被轻微扰动然后重新标准正交化的基。初始扰动 $\\mathbf{U}_{\\mathrm{tmp}} = \\mathbf{U}_\\star + \\varepsilon \\mathbf{X}[:,2:4]$ 用来自其他特征空间的向量污染了基。随后的 $\\mathbf{M}$-标准正交化，通过对 $\\mathbf{U}_{\\mathrm{tmp}}^{\\top}\\mathbf{M}\\mathbf{U}_{\\mathrm{tmp}}$ 进行 Cholesky 分解实现，产生了一个根据构造是完全 $\\mathbf{M}$-标准正交的基 $\\mathbf{U}_4$。因为初始扰动 $\\varepsilon = 10^{-11}$ 非常小，所以得到的子空间与真实子空间极其接近，相对残差应该远在容差 $\\tau_{\\mathrm{inv}} = 10^{-8}$ 范围内。两个检验都应该通过。\n5.  **测试 5**：一个近乎秩亏的基，$\\mathbf{U}_5 = [\\mathbf{x}_1, \\mathbf{x}_1 + 10^{-14}\\mathbf{x}_2]$。这两列几乎是平行的。格拉姆矩阵 $\\mathbf{U}_5^{\\top}\\mathbf{M}\\mathbf{U}_5$ 将接近于 $\\begin{bmatrix} 1  1 \\\\ 1  1 \\end{bmatrix}$，这与单位矩阵相去甚远。预计标准正交性检验会失败。\n\n该算法首先设置矩阵 $\\mathbf{K}$ 和 $\\mathbf{M}$。然后，为五个测试用例中的每一个构造候选矩阵 $\\mathbf{U}$。最后，使用给定的容差 $\\tau_{\\mathrm{orth}} = 10^{-10}$ 和 $\\tau_{\\mathrm{inv}} = 10^{-8}$ 执行两个验证检验。为每个案例记录一个布尔结果，当且仅当两个检验都满足时，该结果为 `True`。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Validates candidate bases for a generalized eigenvalue problem.\n    \"\"\"\n    # Tolerances and constants from the problem statement\n    tau_orth = 1e-10\n    tau_inv = 1e-8\n    lam0 = 2.0\n    n = 5\n\n    # --- Step 1: Construct the matrix pencil (K, M) and exact solution X ---\n\n    # Mass matrix M\n    m_diag = np.array([1.5, 2.5, 3.25, 4.0, 6.0])\n    M = np.diag(m_diag)\n\n    # Eigenvalue matrix Lambda\n    lambda_diag = np.array([2.0, 2.0, 5.0, 7.0, 11.0])\n    Lambda = np.diag(lambda_diag)\n\n    # Create a reproducible orthogonal matrix Q\n    np.random.seed(0)\n    A = np.random.rand(n, n)\n    Q, _ = np.linalg.qr(A)\n\n    # Construct K and the exact eigenvector matrix X\n    M_sqrt = np.diag(np.sqrt(m_diag))\n    M_inv_sqrt = np.diag(1.0 / np.sqrt(m_diag))\n    K = M_sqrt @ Q @ Lambda @ Q.T @ M_sqrt\n    X = M_inv_sqrt @ Q\n\n    # True basis for the eigenspace of lambda_0 = 2.0\n    U_star = X[:, 0:2]\n\n    def check_validity(U, K, M, lam0, tau_orth, tau_inv):\n        \"\"\"\n        Performs the two checks: M-orthonormality and invariant subspace.\n        \"\"\"\n        # 1. M-orthonormality check\n        I2 = np.eye(2)\n        orth_err = np.linalg.norm(U.T @ M @ U - I2, 'fro')\n        orth_pass = orth_err = tau_orth\n\n        # 2. Invariant subspace check\n        residual_matrix = (K - lam0 * M) @ U\n        # Denominator can be zero only if K, M, and U are all zero, which is not the case here\n        denominator = (np.linalg.norm(K, 'fro') + np.abs(lam0) * np.linalg.norm(M, 'fro')) * np.linalg.norm(U, 'fro')\n        \n        # Handle potential division by zero, although highly unlikely\n        if denominator == 0:\n            inv_err = np.linalg.norm(residual_matrix, 'fro')\n        else:\n            inv_err = np.linalg.norm(residual_matrix, 'fro') / denominator\n\n        inv_pass = inv_err = tau_inv\n\n        return orth_pass and inv_pass\n\n    # --- Step 2: Define and process the five test cases ---\n\n    test_cases = []\n\n    # Test 1: Happy path (rotated true basis)\n    theta = 0.4\n    R = np.array([[np.cos(theta), -np.sin(theta)],\n                  [np.sin(theta), np.cos(theta)]])\n    U1 = U_star @ R\n    test_cases.append(U1)\n\n    # Test 2: Correct subspace, not orthonormal\n    C = np.array([[1.5, 0.3], [0, 0.6]])\n    U2 = U_star @ C\n    test_cases.append(U2)\n    \n    # Test 3: M-orthonormal but wrong subspace\n    U3 = np.hstack((X[:, 0:1], X[:, 2:3]))\n    test_cases.append(U3)\n\n    # Test 4: Contaminated and re-orthonormalized\n    epsilon = 1e-11\n    U_tmp = U_star + epsilon * X[:, 2:4]\n    # M-orthonormalization using Cholesky factorization of the Gram matrix\n    G = U_tmp.T @ M @ U_tmp\n    L = np.linalg.cholesky(G)\n    # U = U_tmp @ inv(L.T)\n    L_inv_T = np.linalg.inv(L).T\n    U4 = U_tmp @ L_inv_T\n    test_cases.append(U4)\n\n    # Test 5: Rank deficiency (nearly linearly dependent columns)\n    U5 = np.hstack((X[:, 0:1], (X[:, 0] + 1e-14 * X[:, 1]).reshape(-1, 1)))\n    test_cases.append(U5)\n\n    # --- Step 3: Run checks and collect results ---\n\n    results = []\n    for U in test_cases:\n        is_valid = check_validity(U, K, M, lam0, tau_orth, tau_inv)\n        results.append(is_valid)\n\n    # --- Step 4: Print final output in the required format ---\n    result_str = ','.join(map(lambda b: str(b).lower(), results))\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2578529"}]}