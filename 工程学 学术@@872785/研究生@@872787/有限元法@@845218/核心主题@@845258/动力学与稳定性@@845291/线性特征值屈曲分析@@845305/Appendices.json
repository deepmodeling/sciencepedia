{"hands_on_practices": [{"introduction": "为了真正掌握线性特征值屈曲分析，我们从一个基础问题开始：简支梁的屈曲。这个练习将引导您完成有限元法的基本步骤，从基于势能原理推导单元刚度矩阵，到求解最终的特征值问题。通过完成这个典型的例子 [@problem_id:2574102] 并将您的有限元解与经典的欧拉临界载荷进行比较，您将对该方法如何近似求解结构失稳问题建立起直观和解析层面的理解。", "problem": "一根长度为 $L$、均匀抗弯刚度为 $EI$、剪切变形可忽略的直棱柱细长梁，两端简支（铰接）。梁的两端承受均匀的轴向预压缩载荷 $P$。使用有限元法（FEM），将梁离散为两个等长的 Euler–Bernoulli 梁单元，并使用三次 Hermite 插值来描述横向挠度场。将该问题视为一个线性特征值屈曲分析，该分析由总势能的一致线性化得到。\n\n仅从以下基本出发点开始：\n- Euler–Bernoulli 运动学关系 $w(x)$，其曲率为 $\\kappa(x)=w''(x)$，弯曲应变能为 $\\dfrac{1}{2}\\int_{0}^{L}EI\\,[w''(x)]^{2}\\,\\mathrm{d}x$。\n- 由轴向力功的二阶变分产生的几何刚度贡献，其二次型与 $\\dfrac{P}{2}\\int_{0}^{L}[w'(x)]^{2}\\,\\mathrm{d}x$ 成正比。\n- 标准的 Galerkin 程序，其中一致单元矩阵是利用 $w$ 的三次 Hermite 形函数从上述能量推导出来的，\n\n执行以下任务：\n1. 推导长度为 $L_{e}$ 的单元的一致 $4\\times 4$ 单元弹性刚度矩阵 $K_{e}$ 和单位轴向力下的一致 $4\\times 4$ 单元几何刚度矩阵 $K_{g}^{(0)}$。\n2. 对于节点位于 $x=0$、$x=L/2$ 和 $x=L$ 的双单元网格，组集全局弹性刚度矩阵 $K$ 和单位载荷下的全局几何刚度矩阵 $K_{g}^{(0)}$。通过消除两端的横向位移来施加铰接边界条件，同时保持端点转角自由。\n3. 建立广义特征值问题 $K\\,\\boldsymbol{\\phi}=\\lambda\\,K_{g}^{(0)}\\,\\boldsymbol{\\phi}$ 并计算最小特征值 $\\lambda_{\\min}$，该值代表临界载荷的有限元估计值 $P_{\\text{cr,FE}}$。\n4. 通过构建无量纲比率 $\\alpha=P_{\\text{cr,FE}}/P_{\\text{cr}}$，将 $P_{\\text{cr,FE}}$ 与经典的 Euler 临界载荷 $P_{\\text{cr}}=\\pi^{2}EI/L^{2}$ 进行比较。\n\n以单一的、封闭形式的解析表达式给出比率 $\\alpha$ 作为最终答案。不需要进行数值取整，最终答案中不应包含单位。", "solution": "所述问题具有科学依据、提法恰当、客观且自洽。它是计算结构力学领域的典型问题。因此，该问题被认为是有效的，并将推导其解答。\n\n按要求，分析分四部分进行：单元矩阵的推导，组集与边界条件的应用，特征值问题的求解，以及与精确解的比较。\n\n**1. 单元刚度矩阵与几何刚度矩阵**\n\n一个长度为 $L_e$ 的 Euler-Bernoulli 梁单元由两个节点 $i$ 和 $j$ 定义。每个节点有两个自由度（DOF）：横向位移 $w$ 和转角 $\\theta = w'(x)$。单元节点位移向量为 $\\boldsymbol{d}_e = \\begin{pmatrix} w_i  \\theta_i  w_j  \\theta_j \\end{pmatrix}^T$。横向位移场 $w(x)$ 使用三次 Hermite 形函数 $\\boldsymbol{N}(\\xi)$ 进行插值，其中 $\\xi = x/L_e$ 是从 $0$ 变化到 $1$ 的自然坐标。\n$$ w(x) = \\boldsymbol{N}(\\xi(x)) \\boldsymbol{d}_e $$\n形函数为：\n$N_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3$\n$N_2(\\xi) = L_e(\\xi - 2\\xi^2 + \\xi^3)$\n$N_3(\\xi) = 3\\xi^2 - 2\\xi^3$\n$N_4(\\xi) = L_e(-\\xi^2 + \\xi^3)$\n\n单元弹性刚度矩阵 $K_e$ 从弯曲应变能 $U_e = \\frac{1}{2} \\int_{0}^{L_e} EI [w''(x)]^2 \\mathrm{d}x$ 推导得出。用节点自由度表示该能量，得到 $U_e = \\frac{1}{2}\\boldsymbol{d}_e^T K_e \\boldsymbol{d}_e$。矩阵 $K_e$ 由下式给出：\n$$ K_e = \\int_{0}^{L_e} EI \\left(\\frac{d^2\\boldsymbol{N}}{dx^2}\\right)^T \\left(\\frac{d^2\\boldsymbol{N}}{dx^2}\\right) \\mathrm{d}x = \\frac{EI}{L_e^3} \\int_{0}^{1} (\\boldsymbol{N}''(\\xi))^T \\boldsymbol{N}''(\\xi) \\mathrm{d}\\xi $$\n执行积分得到标准的单元弹性刚度矩阵：\n$$ K_e = \\frac{EI}{L_e^3} \\begin{pmatrix} 12  6L_e  -12  6L_e \\\\ 6L_e  4L_e^2  -6L_e  2L_e^2 \\\\ -12  -6L_e  12  -6L_e \\\\ 6L_e  2L_e^2  -6L_e  4L_e^2 \\end{pmatrix} $$\n单元几何刚度矩阵 $K_g$ 由轴向力 $P$ 所做的功推导得出，其表达式为 $W_P = -\\frac{P}{2} \\int_{0}^{L_e} [w'(x)]^2 \\mathrm{d}x$。我们定义单位轴向力下的几何刚度矩阵 $K_g^{(0)}$，使得 $K_g = P K_g^{(0)}$。其离散形式为 $W_P = -\\frac{1}{2}\\boldsymbol{d}_e^T (P K_g^{(0)}) \\boldsymbol{d}_e$，其中：\n$$ K_g^{(0)} = \\int_{0}^{L_e} \\left(\\frac{d\\boldsymbol{N}}{dx}\\right)^T \\left(\\frac{d\\boldsymbol{N}}{dx}\\right) \\mathrm{d}x = \\frac{1}{L_e} \\int_{0}^{1} (\\boldsymbol{N}'(\\xi))^T \\boldsymbol{N}'(\\xi) \\mathrm{d}\\xi $$\n积分得到标准的单位载荷下单元几何刚度矩阵：\n$$ K_g^{(0)} = \\frac{1}{30L_e} \\begin{pmatrix} 36  3L_e  -36  3L_e \\\\ 3L_e  4L_e^2  -3L_e  -L_e^2 \\\\ -36  -3L_e  36  -3L_e \\\\ 3L_e  -L_e^2  -3L_e  4L_e^2 \\end{pmatrix} $$\n\n**2. 组集与边界条件**\n\n梁被离散为两个等长单元，$L_e = L/2$。节点分别位于 $x=0$（节点1）、$x=L/2$（节点2）和 $x=L$（节点3）。全局自由度向量为 $\\boldsymbol{D} = \\begin{pmatrix} w_1  \\theta_1  w_2  \\theta_2  w_3  \\theta_3 \\end{pmatrix}^T$。组集两个单元的贡献，得到 $6 \\times 6$ 的全局矩阵 $K$ 和 $K_g^{(0)}$。\n\n简支（铰接）边界条件要求两端横向位移为零：$w(0)=0$ 和 $w(L)=0$。这等价于 $w_1=0$ 和 $w_3=0$。我们从全局矩阵中消除相应的行和列（第1行和第5行）。剩余的有效自由度为 $\\boldsymbol{d}_{active} = \\begin{pmatrix} \\theta_1  w_2  \\theta_2  \\theta_3 \\end{pmatrix}^T$，系统简化为一个 $4 \\times 4$ 的问题。\n\n缩减后的弹性刚度矩阵 $K_{red}$ 为：\n$$ K_{red} = \\frac{EI}{L_e^3} \\begin{pmatrix} 4L_e^2  -6L_e  2L_e^2  0 \\\\ -6L_e  24  0  6L_e \\\\ 2L_e^2  0  8L_e^2  2L_e^2 \\\\ 0  6L_e  2L_e^2  4L_e^2 \\end{pmatrix} $$\n缩减后的单位载荷下几何刚度矩阵 $K_{g,red}^{(0)}$ 为：\n$$ K_{g,red}^{(0)} = \\frac{1}{30L_e} \\begin{pmatrix} 4L_e^2  -3L_e  -L_e^2  0 \\\\ -3L_e  72  0  3L_e \\\\ -L_e^2  0  8L_e^2  -L_e^2 \\\\ 0  3L_e  -L_e^2  4L_e^2 \\end{pmatrix} $$\n其中 $L_e = L/2$。\n\n**3. 特征值问题求解**\n\n简支梁的基本屈曲模态关于中点（$x=L/2$）对称。这一物理洞察对自由度施加了进一步的约束：中点转角为零（$\\theta_2=0$），两端转角大小相等、方向相反（$\\theta_3 = -\\theta_1$）。有效自由度向量可以用两个广义坐标 $\\boldsymbol{q} = \\begin{pmatrix} \\theta_1  w_2 \\end{pmatrix}^T$ 和转换矩阵 $\\boldsymbol{T}$ 表示：\n$$ \\boldsymbol{d}_{active} = \\begin{pmatrix} \\theta_1 \\\\ w_2 \\\\ \\theta_2 \\\\ \\theta_3 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\\\ 0  0 \\\\ -1  0 \\end{pmatrix} \\begin{pmatrix} \\theta_1 \\\\ w_2 \\end{pmatrix} = \\boldsymbol{T}\\boldsymbol{q} $$\n$4 \\times 4$ 的特征值问题 $K_{red}\\boldsymbol{\\phi} = \\lambda K_{g,red}^{(0)}\\boldsymbol{\\phi}$ 被简化为一个 $2 \\times 2$ 的问题 $( \\boldsymbol{T}^T K_{red} \\boldsymbol{T} ) \\boldsymbol{q} = \\lambda ( \\boldsymbol{T}^T K_{g,red}^{(0)} \\boldsymbol{T} ) \\boldsymbol{q}$，或 $K_s \\boldsymbol{q} = \\lambda K_{g,s} \\boldsymbol{q}$。\n用 $L_e=L/2$ 计算转换后的矩阵：\n$K_s = \\boldsymbol{T}^T K_{red} \\boldsymbol{T} = \\frac{16EI}{L^3} \\begin{pmatrix} L^2  -3L \\\\ -3L  12 \\end{pmatrix}$\n$K_{g,s} = \\boldsymbol{T}^T K_{g,red}^{(0)} \\boldsymbol{T} = \\frac{1}{15L} \\begin{pmatrix} 2L^2  -3L \\\\ -3L  72 \\end{pmatrix}$\n\n特征值问题需要求解 $\\det(K_s - \\lambda K_{g,s}) = 0$。这可以通过定义 $\\mu = \\frac{\\lambda L^2}{240 EI}$ 并求解 $\\det(A - \\mu B)=0$ 来简化，其中 $A = \\frac{L^3}{16EI} K_s$ 且 $B = 15L \\cdot K_{g,s}$。\n$A = \\begin{pmatrix} L^2  -3L \\\\ -3L  12 \\end{pmatrix}$，$B = \\begin{pmatrix} 2L^2  -3L \\\\ -3L  72 \\end{pmatrix}$。\n特征方程为：\n$$ \\det \\begin{pmatrix} L^2(1 - 2\\mu)  -3L(1 - \\mu) \\\\ -3L(1 - \\mu)  12(1 - 6\\mu) \\end{pmatrix} = 0 $$\n$$ 12L^2(1 - 2\\mu)(1 - 6\\mu) - 9L^2(1 - \\mu)^2 = 0 $$\n两边同除以 $3L^2$ 并展开，得到一个关于 $\\mu$ 的二次方程：\n$$ 4(1 - 8\\mu + 12\\mu^2) - 3(1 - 2\\mu + \\mu^2) = 0 $$\n$$ 45\\mu^2 - 26\\mu + 1 = 0 $$\n方程的根为 $\\mu = \\frac{26 \\pm \\sqrt{26^2 - 4(45)(1)}}{90} = \\frac{26 \\pm \\sqrt{496}}{90} = \\frac{13 \\pm 2\\sqrt{31}}{45}$。\n最小特征值 $\\lambda_{\\min}$ 对应于最小根 $\\mu_{\\min}$，代表最低的屈曲载荷。\n$$ \\mu_{\\min} = \\frac{13 - 2\\sqrt{31}}{45} $$\n有限元分析得到的临界载荷为 $P_{\\text{cr,FE}} = \\lambda_{\\min}$。\n$$ P_{\\text{cr,FE}} = \\mu_{\\min} \\frac{240 EI}{L^2} = \\frac{13 - 2\\sqrt{31}}{45} \\frac{240 EI}{L^2} = \\frac{16(13 - 2\\sqrt{31})}{3} \\frac{EI}{L^2} $$\n\n**4. 与 Euler 临界载荷的比较**\n\n最后一步是计算有限元结果与经典 Euler 临界载荷 $P_{\\text{cr}} = \\frac{\\pi^2 EI}{L^2}$ 的比率 $\\alpha$。\n$$ \\alpha = \\frac{P_{\\text{cr,FE}}}{P_{\\text{cr}}} = \\frac{\\frac{16(13 - 2\\sqrt{31})}{3} \\frac{EI}{L^2}}{\\frac{\\pi^2 EI}{L^2}} $$\n$$ \\alpha = \\frac{16(13 - 2\\sqrt{31})}{3\\pi^2} $$\n这就是所要求比率的最终解析表达式。", "answer": "$$\\boxed{\\frac{16(13-2\\sqrt{31})}{3\\pi^{2}}}$$", "id": "2574102"}, {"introduction": "在完成一次计算之后，理解结果的物理意义至关重要。这个练习将我们的关注点从计算转移到概念，要求您基于能量原理来解释线性屈曲分析中得到的特征值的物理含义。通过分析正、零、负特征值的意义 [@problem_id:2574144]，您将巩固自己的理论基础，并学会批判性地评估有限元结构稳定性模拟的输出结果。", "problem": "考虑一个弹性结构在小应变和小屈曲前位移情况下的有限元法（FEM）线性化分岔分析。设材料（弹性）刚度矩阵表示为 $K \\in \\mathbb{R}^{n \\times n}$，几何（初始应力）刚度矩阵表示为 $K_g \\in \\mathbb{R}^{n \\times n}$，两者均在通常的对称性假设下由标准单元公式装配而成。线性特征值屈曲问题写作\n$$(K - \\lambda K_g)\\,\\phi = 0,$$\n其中有非平凡特征向量 $\\phi \\neq 0$ 和特征值 $\\lambda \\in \\mathbb{R}$。假设对于没有预应力的恰当约束结构，$K$ 是对称正定的。在所采用的符号约定下，压缩参考应力场产生的几何刚度 $K_g$ 在能量意义上是半正定的。总势能泛函 $\\Pi$ 在预应力状态下的二次变分为\n$$\\delta^2 \\Pi[\\delta u] = \\tfrac{1}{2}\\,\\delta u^T\\,(K - \\lambda K_g)\\,\\delta u.$$\n屈曲是通过切线算子 $K - \\lambda K_g$ 的正定性丧失来检测的。\n\n从基于稳定性能力准则和对称矩阵性质的第一性原理角度来看，$(K - \\lambda K_g)$ 的负特征值或零特征值的正确物理诠释是什么？为什么在实践中，只有与压缩 $K_g$ 相关的正 $\\lambda$ 值在这种情况下才表示经典屈曲？\n\n选择最准确、最完整地解释这种情况的选项。\n\nA. 如果 $K$ 是正定的，且压缩几何刚度 $K_g$ 是半正定的，那么只要 $u^T K_g u > 0$，Rayleigh 商 $\\lambda(u) = \\dfrac{u^T K u}{u^T K_g u}$ 就是非负的。零特征值 $\\lambda = 0$ 只有在 $K$ 奇异（例如，存在机构或未约束的刚体模态）时才会发生，这并非屈曲现象。负特征值要求 $u^T K_g u  0$，即 $K_g$是不定的或受拉主导的，这不对应于压缩屈曲。因此，只有正的 $\\lambda$ 会将压缩参考应力缩放到使 $K - \\lambda K_g$ 丧失正定性的点，从而指示屈曲。\n\nB. 零特征值 $\\lambda = 0$ 表示结构在零载荷下屈曲，因为压缩总是导致失稳，而负特征值是屈曲后软化的标志；因此零和负的 $\\lambda$ 都是有效的压缩屈曲指标。\n\nC. 正的 $\\lambda$ 对应于拉伸屈曲载荷，因为它们增加了刚度，而负的 $\\lambda$ 对应于压缩屈曲载荷，因为它们减小了刚度；因此负的 $\\lambda$ 是压缩屈曲的相关指标。\n\nD. 在良态模型中，负特征值或零特征值总是数值舍入误差的产物，应该忽略它们；所有具有物理意义的屈曲载荷都具有严格为正的 $\\lambda$，而不管 $K_g$ 的性质和参考应力状态如何。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n### 步骤1：提取已知条件\n-   分析是有限元法（FEM）中的线性化分岔分析。\n-   结构是弹性的，具有小应变和小屈曲前位移。\n-   弹性刚度矩阵为 $K \\in \\mathbb{R}^{n \\times n}$。\n-   几何（初始应力）刚度矩阵为 $K_g \\in \\mathbb{R}^{n \\times n}$。\n-   $K$ 和 $K_g$ 都是对称的。\n-   线性特征值屈曲问题是 $(K - \\lambda K_g)\\,\\phi = 0$，对于非平凡特征向量 $\\phi \\neq 0$ 和特征值 $\\lambda \\in \\mathbb{R}$。\n-   对于没有预应力的恰当约束结构，假设 $K$ 是对称正定的。\n-   压缩参考应力场产生的几何刚度 $K_g$ 在能量意义上是半正定的。\n-   总势能的二次变分为 $\\delta^2 \\Pi[\\delta u] = \\tfrac{1}{2}\\,\\delta u^T\\,(K - \\lambda K_g)\\,\\delta u$。\n-   屈曲被定义为切线算子 $K - \\lambda K_g$ 正定性的丧失。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题陈述进行分析。\n\n-   **科学依据**：问题描述了线性特征值屈曲分析的标准公式，这是有限元法框架内结构稳定性理论的基石。所有概念——刚度矩阵（$K$，$K_g$）、特征值（$\\lambda$）、特征向量（$\\phi$）以及稳定性能力准则——在连续介质力学和计算力学中都是标准的并被严格定义。\n-   **良态的**：问题是良态的。它要求基于一个完整和标准的数学模型对特征值进行物理解释。\n-   **客观性**：语言精确、技术性强，没有主观或模糊的术语。\n-   **不完整或矛盾的设置**：设置是完整且自洽的。矩阵的性质（$K$ 为正定，$K_g$ 对于压缩应力为半正定）被清晰定义，为分析构成了一致的基础。\n-   **琐碎或同义反复**：问题需要对稳定性理论和矩阵性质有细致的理解，并非琐碎。它要求从数学公式中推导出物理意义。\n\n### 步骤3：结论与行动\n问题陈述是**有效的**。这是一个计算结构力学中的标准、定义明确的问题。可以继续求解过程。\n\n### 求解推导\n平衡状态的稳定性由总势能的二次变分 $\\delta^2 \\Pi$ 决定。如果对于所有容许的虚位移 $\\delta u$，都有 $\\delta^2 \\Pi > 0$，则系统是稳定的。表达式为：\n$$ \\delta^2 \\Pi[\\delta u] = \\tfrac{1}{2}\\,\\delta u^T\\,(K - \\lambda K_g)\\,\\delta u $$\n稳定性要求切线刚度矩阵 $K_T = K - \\lambda K_g$ 是正定的。失稳或屈曲的临界点发生在最低的载荷水平 $\\lambda$ 上，在该水平上 $K_T$ 不再是正定的，即它通过获得一个零特征值而变为半正定。这正是特征值问题所描述的条件：\n$$ (K - \\lambda K_g)\\phi = 0 $$\n对于某个非平凡的模态振型 $\\phi \\neq 0$。\n\n这是一个广义特征值问题。由于 $K$ 和 $K_g$ 是对称矩阵，我们可以通过 Rayleigh 商来分析特征值 $\\lambda$，这是通过将方程左乘 $\\phi^T$ 得到的：\n$$ \\phi^T(K - \\lambda K_g)\\phi = 0 $$\n$$ \\phi^T K \\phi - \\lambda \\phi^T K_g \\phi = 0 $$\n假设 $\\phi^T K_g \\phi \\neq 0$，我们可以解出 $\\lambda$：\n$$ \\lambda = \\frac{\\phi^T K \\phi}{\\phi^T K_g \\phi} $$\n现在我们根据分子和分母的性质来分析 $\\lambda$ 的符号。\n\n1.  **分子 $\\phi^T K \\phi$**：此项表示在位移模式 $\\phi$ 下结构中存储的弹性应变能的两倍。问题陈述，对于恰当约束的结构，$K$ 是正定的。这意味着对于任何非零向量 $\\phi$，$\\phi^T K \\phi > 0$。\n\n2.  **分母 $\\phi^T K_g \\phi$**：此项表示在扰动 $\\phi$ 期间参考应力场所做的功。问题陈述，对于参考*压缩*应力状态，所用的符号约定使得 $K_g$ 是半正定的。这意味着 $\\phi^T K_g \\phi \\ge 0$。\n\n结合这些事实，我们分析 $\\lambda$ 的可能值。\n\n-   **情况1：正特征值 ($\\lambda > 0$)**\n    要使 $\\lambda$ 为正，Rayleigh 商的分子和分母必须同号。由于 $\\phi^T K \\phi > 0$，我们必须有 $\\phi^T K_g \\phi > 0$。这对应于一个屈曲模态 $\\phi$，在该模态下压缩参考应力做功，从而产生失稳效应。随着载荷乘子 $\\lambda$ 从0开始增加，矩阵 $K - \\lambda K_g$ 的“刚度”逐漸减小，直到在临界值 $\\lambda_{cr}$ 时变为奇异。这就是经典压缩屈曲的物理意义。\n\n-   **情况2：零特征值 ($\\lambda = 0$)**\n    对于 $\\lambda = 0$，Rayleigh 商意味着分子必须为零：$\\phi^T K \\phi = 0$。由于 $K$ 是正定的，这只在 $\\phi = 0$ 时才可能。但我们寻求的是非平凡特征向量。只有当 $K$ 是奇异的（非正定）时，才可能存在 $\\lambda=0$ 的非平凡解（即 $K\\phi = 0$）。奇异的 $K$ 意味着结构存在预先的不稳定性，例如刚体模态（不恰当的约束）或机构。这是一个初始不稳定性的建模问题，而不是由载荷引起的屈曲现象。\n\n-   **情况3：负特征值 ($\\lambda  0$)**\n    要使 $\\lambda$ 为负，分子和分母必须异号。由于 $\\phi^T K \\phi > 0$，这要求 $\\phi^T K_g \\phi  0$。这与给定条件“压缩参考应力产生半正定的 $K_g$”相矛盾。$\\phi^T K_g \\phi$ 的负值意味着 $K_g$ 是不定或负定的，根据给定的符号约定，这对应于*拉伸*参考应力。负的 $\\lambda$ 则意味着这个拉伸参考载荷必须反向（即变为压缩，因为屈曲载荷是 $\\lambda \\times (\\text{参考载荷})$）才能引起失稳。因此，对于一个设定了压缩参考载荷的问题，负特征值不代表沿所施加载荷方向的压缩屈曲。\n\n总之，对于一个恰当约束结构在压缩参考载荷作用下的良态问题，只有正的载荷乘子 $\\lambda$ 才具有直接的物理意义，即作为将参考载荷放大至临界屈曲载荷的比例因子。\n\n### 逐项分析选项\n\n**A. 如果 $K$ 是正定的，且压缩几何刚度 $K_g$ 是半正定的，那么只要 $u^T K_g u > 0$，Rayleigh 商 $\\lambda(u) = \\dfrac{u^T K u}{u^T K_g u}$ 就是非负的。零特征值 $\\lambda = 0$ 只有在 $K$ 奇异（例如，存在机构或未约束的刚体模态）时才会发生，这并非屈曲现象。负特征值要求 $u^T K_g u  0$，即 $K_g$是不定的或受拉主导的，这不对应于压缩屈曲。因此，只有正的 $\\lambda$ 会将压缩参考应力缩放到使 $K - \\lambda K_g$ 丧失正定性的点，从而指示屈曲。**\n\n此选项提供了完整且正确的解释。它正确地使用Rayleigh商确定了正、零和负特征值的数学条件，并在问题指定的上下文中准确地将它们映射到其物理解释。正确地区分了预先存在的机构（$\\lambda=0$）和由载荷引起的屈曲（$\\lambda>0$）。负特征值无关的原因（根据给定的约定，它们对应于拉伸而非压缩参考应力）也得到了正确解释。\n\n**结论：正确**\n\n**B. 零特征值 $\\lambda = 0$ 表示结构在零载荷下屈曲，因为压缩总是导致失稳，而负特征值是屈曲后软化的标志；因此零和负的 $\\lambda$ 都是有效的压缩屈曲指标。**\n\n此选项在多方面都是错误的。首先，$\\lambda = 0$ 的特征值表示 $K$ 的初始奇异性，而不是“在零载荷下屈曲”。其次，负特征值不是屈曲后行为的标志。线性特征值分析不提供关于屈曲后路径（软化或硬化）的信息，这需要非线性分析。负特征值与载荷反向或拉伸参考应力有关。\n\n**结论：错误**\n\n**C. 正的 $\\lambda$ 对应于拉伸屈曲载荷，因为它们增加了刚度，而负的 $\\lambda$ 对应于压缩屈曲载荷，因为它们减小了刚度；因此负的 $\\lambda$ 是压缩屈曲的相关指标。**\n\n此选项描述的与物理现实完全相反。对于压缩参考载荷（$K_g$ 半正定），切线刚度是 $K - \\lambda K_g$。一个正的 $\\lambda$ 会从弹性刚度 $K$ 中*减去*一项，从而*减小*系统的整体刚度，导致压缩屈曲。一个负的 $\\lambda = -\\mu$（其中 $\\mu>0$）将得到 $K + \\mu K_g$，这会*增加*刚度。整个前提从根本上就是错误的。\n\n**结论：错误**\n\n**D. 在良态模型中，负特征值或零特征值总是数值舍入误差的产物，应该忽略它们；所有具有物理意义的屈曲载荷都具有严格为正的 $\\lambda$，而不管 $K_g$ 的性质和参考应力状态如何。**\n\n此选项是一个不正确的概括。零特征值具有明确的物理意义（机构或刚体模态），它们不是误差产物。负特征值也具有物理意义（载荷反向下的屈曲或来自拉伸参考状态的屈曲），通常也不是误差产物。具有物理意义的 $\\lambda$ 的符号完全取决于参考应力的性质（压缩与拉伸）以及用于 $K_g$ 的符号约定。声称它们必须*不顾*这种背景而严格为正，是错误的。\n\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "2574144"}, {"introduction": "在掌握了基本原理之后，我们现在进入一个更全面的计算问题，涉及板的屈曲分析。这项动手编程任务要求您实现一个考虑了剪切变形效应的Mindlin-Reissner板单元，并求解一个二维结构的屈曲问题。此外，通过进行网格细化研究 [@problem_id:2574106]，您将实践计算力学中的一项关键技能：验证您的数值结果并量化模拟的收敛速度。", "problem": "考虑一个平坦、均质、各向同性的矩形板，其线性特征值屈曲分析采用 Mindlin-Reissner 理论建模。设板的中面占据 $x$–$y$ 平面上的矩形区域 $[0,a] \\times [0,b]$，其厚度 $t$、杨氏模量 $E$ 和泊松比 $\\nu$ 均为常数。运动学变量为横向位移 $w(x,y)$ 以及法线分别绕 $y$ 轴和 $x$ 轴的转角 $\\theta_x(x,y)$ 和 $\\theta_y(x,y)$。假设应变和转角均为小量，且存在一个均匀、受压的平面内应力合力场 $N_{xx} = N_0$（常数）、$N_{yy} = 0$、$N_{xy} = 0$，作用于 $x$ 方向。所有板的边界均为固支，即在 $\\partial \\Omega$ 上有 $w=0$、$\\theta_x=0$ 和 $\\theta_y=0$。\n\n分析的起点是板的虚功原理：在初始屈曲时，弯曲和横向剪切的虚应变能等于预应力在二阶虚位移上所做的虚功。在 Mindlin-Reissner 板理论中，弯曲曲率为 $\\kappa_x = \\partial \\theta_x / \\partial x$、$\\kappa_y = \\partial \\theta_y / \\partial y$ 和 $\\kappa_{xy} = \\partial \\theta_x / \\partial y + \\partial \\theta_y / \\partial x$，横向剪切应变为 $\\gamma_{xz} = \\theta_x + \\partial w / \\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w / \\partial y$。弯曲本构矩阵为 $D_b = D \\begin{bmatrix} 1  \\nu  0 \\\\ \\nu  1  0 \\\\ 0  0  (1-\\nu)/2 \\end{bmatrix}$，其中 $D = E t^3 / \\left(12(1-\\nu^2)\\right)$，剪切本构矩阵为 $D_s = \\kappa_s G t \\, I$，其中 $G = E /(2(1+\\nu))$ 且 $\\kappa_s = 5/6$ 是一个标准的剪切修正系数。\n\n使用四节点等参双线性四边形单元对板进行离散化。每个节点有三个自由度：$w$、$\\theta_x$ 和 $\\theta_y$。使用以下变分构造块作为符合上下文的基本依据：\n- 弯曲能量密度：$(\\kappa_x,\\kappa_y,\\kappa_{xy})^T D_b (\\kappa_x,\\kappa_y,\\kappa_{xy})$ 在板面积上的积分。\n- 剪切能量密度：$(\\gamma_{xz},\\gamma_{yz})^T D_s (\\gamma_{xz},\\gamma_{yz})$ 在板面积上的积分。\n- 与预应力相关的几何（应力）势：$N_{xx} \\left(\\partial w/\\partial x\\right)^2 + 2 N_{xy} \\left(\\partial w/\\partial x\\right)\\left(\\partial w/\\partial y\\right) + N_{yy} \\left(\\partial w/\\partial y\\right)^2$ 在板面积上的积分。\n\n基于以上各项，组装全局弹性刚度矩阵 $K$（来自弯曲和剪切）和几何刚度矩阵 $K_g$（来自预应力和面外位移梯度）。通过约束所有边界节点上的 $w$、$\\theta_x$ 和 $\\theta_y$ 来强加固支边界条件。然后，建立如下形式的线性屈曲广义特征值问题：\n$$\nK_g \\, \\phi = \\mu \\, K \\, \\phi,\n$$\n其中 $\\mu$ 是与假设的单位预应力大小相关的广义特征值。相应的临界屈曲因子为 $\\lambda = 1/\\mu$，它乘以基础平面内应力合力得到临界载荷合力。我们关心的是最小的正 $\\lambda$，即基本屈曲因子。所有计算都可以在一个无量纲系统中进行，其中 $E$ 和 $N_0$ 设置为单位1；所要求的输出是无量纲数。\n\n您的任务是编写一个完整的程序，该程序能够：\n1. 实现所述的四节点双线性 Mindlin 板单元，并满足：\n   - 弯曲项使用完整的 $2 \\times 2$ 高斯积分，\n   - 剪切项使用减缩的 $1 \\times 1$ 高斯积分，\n   - 几何刚度项使用完整的 $2 \\times 2$ 高斯积分。\n2. 在结构化网格上组装全局矩阵 $K$ 和 $K_g$，并施加所有边界均为固支的边界条件。\n3. 求解广义特征值问题，以获得 $(K_g, K)$ 的最大代数特征值 $\\mu_{\\max}$，并返回 $\\lambda = 1/\\mu_{\\max}$ 作为最小屈曲因子。\n4. 对于下面的每个测试用例，使用三种依次细化的网格（单元尺寸为 $h_1$、$h_2 = h_1/2$ 和 $h_3 = h_2/2$）进行网格细化研究，计算出三个近似值 $\\lambda(h_1)$、$\\lambda(h_2)$ 和 $\\lambda(h_3)$，并通过差商估算最小特征值的观测渐近收敛率 $p$：\n$$\np \\approx \\frac{\\log\\left( \\left|\\lambda(h_2) - \\lambda(h_1)\\right| \\, / \\, \\left|\\lambda(h_3) - \\lambda(h_2)\\right|\\right)}{\\log(2)}.\n$$\n如果任何差值在数值上为零，使用一个小的正则化项以避免除以零，但保留估算的逻辑。\n\n使用以下测试套件。在所有情况下，设置 $E = 1$ 和 $N_0 = 1$，泊松比 $\\nu = 0.3$，剪切修正系数 $\\kappa_s = 5/6$。板的四边均为固支。对于每个用例，选择的网格三元组使得单元尺寸从一个级别到下一个级别减半，使用 $h = \\max\\{a/n_x, b/n_y\\}$，其中 $n_x$ 和 $n_y$ 分别是沿 $x$ 和 $y$ 方向的单元数量。\n\n- 测试用例 1（方形，中等厚度）：\n  - 几何形状：$a = 1$，$b = 1$，厚度 $t = 0.10$。\n  - 平面内应力合力：$N_{xx} = 1$，$N_{yy} = 0$，$N_{xy} = 0$。\n  - 网格：$(n_x,n_y) \\in \\{(4,4),(8,8),(16,16)\\}$。\n\n- 测试用例 2（方形，薄板）：\n  - 几何形状：$a = 1$，$b = 1$，厚度 $t = 0.01$。\n  - 平面内应力合力：$N_{xx} = 1$，$N_{yy} = 0$，$N_{xy} = 0$。\n  - 网格：$(n_x,n_y) \\in \\{(4,4),(8,8),(16,16)\\}$。\n\n- 测试用例 3（矩形，中等厚度）：\n  - 几何形状：$a = 2$，$b = 1$，厚度 $t = 0.05$。\n  - 平面内应力合力：$N_{xx} = 1$，$N_{yy} = 0$，$N_{xy} = 0$。\n  - 网格：$(n_x,n_y) \\in \\{(6,3),(12,6),(24,12)\\}$。\n\n您的程序必须计算三个测试用例的估计收敛率 $p$，并按下面指定的最终格式输出结果。\n\n角度单位（如有）均以弧度为单位。输出均为无量纲数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[p1,p2,p3]”），其中每个 $p_i$ 是一个浮点数，对应于上述顺序中测试用例 $i$ 的估计速率。", "solution": "该问题要求实现一个有限元方法（FEM）程序，根据 Mindlin-Reissner 理论对固支矩形板进行线性特征值屈曲分析。最终目标是计算三个不同测试用例中基本屈曲载荷因子的收敛率。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。它描述了计算结构力学中的一个标准问题，并提供了清晰的实现和分析说明。所有必要的物理参数、数学公式和数值程序都已给出。广义特征值问题 $K_g \\, \\phi = \\mu \\, K \\, \\phi$ 的公式，结合屈曲因子 $\\lambda = 1/\\mu_{\\max}$ 的关系，是求解最小屈曲载荷的一种标准且数值稳定的方法。\n\n解决方案按以下步骤进行：\n\n1.  **单元公式化**：构建一个四节点四边形 Mindlin-Reissner 板单元。每个节点拥有三个自由度（DOF）：一个横向位移 $w$ 和两个转角 $\\theta_x$、$\\theta_y$。每个单元的总自由度为12个。使用等参双线性形函数 $N_i(\\xi, \\eta)$ 从节点值插值计算单元内的位移场。\n\n2.  **应变-位移关系**：运动学关系基于 Mindlin-Reissner 理论。\n    -   弯曲曲率被收集在一个向量 $\\boldsymbol{\\kappa} = [\\kappa_x, \\kappa_y, \\kappa_{xy}]^T$ 中，其中 $\\kappa_x = \\partial \\theta_x / \\partial x$、$\\kappa_y = \\partial \\theta_y / \\partial y$ 和 $\\kappa_{xy} = \\partial \\theta_x / \\partial y + \\partial \\theta_y / \\partial x$。这些曲率通过应变-位移矩阵 $\\mathbf{B}_b$ 与节点自由度相关联，即 $\\boldsymbol{\\kappa} = \\mathbf{B}_b \\mathbf{d}$，其中 $\\mathbf{d}$ 是单元的节点自由度向量。\n    -   横向剪切应变为 $\\boldsymbol{\\gamma} = [\\gamma_{xz}, \\gamma_{yz}]^T$，其中 $\\gamma_{xz} = \\theta_x + \\partial w / \\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w / \\partial y$。这些应变通过矩阵 $\\mathbf{B}_s$ 与节点自由度相关联，因此 $\\boldsymbol{\\gamma} = \\mathbf{B}_s \\mathbf{d}$。\n    -   横向位移的梯度 $\\nabla w = [\\partial w / \\partial x, \\partial w / \\partial y]^T$ 用于计算几何刚度矩阵。它通过矩阵 $\\mathbf{B}_g$ 与节点自由度相关联，因此 $\\nabla w = \\mathbf{B}_g \\mathbf{d}$。\n\n3.  **单元矩阵计算**：通过在单元面积上使用高斯积分对相应的能量密度进行积分来计算单元矩阵。\n    -   单元弹性刚度矩阵 $\\mathbf{K}_e$ 是弯曲刚度 $\\mathbf{K}_{e,b}$ 和剪切刚度 $\\mathbf{K}_{e,s}$ 的和。\n        $$\n        \\mathbf{K}_{e,b} = \\int_{\\Omega_e} \\mathbf{B}_b^T \\mathbf{D}_b \\mathbf{B}_b \\, dA \\quad \\text{和} \\quad \\mathbf{K}_{e,s} = \\int_{\\Omega_e} \\mathbf{B}_s^T \\mathbf{D}_s \\mathbf{B}_s \\, dA\n        $$\n        其中，$\\mathbf{D}_b$ 和 $\\mathbf{D}_s$ 分别是弯曲和剪切的材料本构矩阵。为防止剪切自锁，特别是在薄板中，采用了选择性减缩积分方案：弯曲项使用 $2 \\times 2$ 高斯积分，剪切项使用 $1 \\times 1$ 高斯积分。\n    -   单元几何刚度矩阵 $\\mathbf{K}_{g,e}$ 源于平面内预应力 $N_{xx} = N_0$ 在屈曲过程中所做的功。\n        $$\n        \\mathbf{K}_{g,e} = \\int_{\\Omega_e} \\mathbf{B}_g^T \\begin{pmatrix} N_0  0 \\\\ 0  0 \\end{pmatrix} \\mathbf{B}_g \\, dA\n        $$\n        该积分使用完整的 $2 \\times 2$ 高斯积分进行计算。\n\n4.  **全局组装和边界条件**：生成结构化单元网格。计算每个单元的单元矩阵（$\\mathbf{K}_e$ 和 $\\mathbf{K}_{g,e}$），并将其组装成全局弹性刚度矩阵 $\\mathbf{K}$ 和几何刚度矩阵 $\\mathbf{K}_g$。通过从全局矩阵中移除与受约束自由度对应的行和列来施加固支边界条件（所有边界上 $w=0, \\theta_x=0, \\theta_y=0$），从而得到缩减后的矩阵 $\\mathbf{K}_{\\text{free}}$ 和 $\\mathbf{K}_{g, \\text{free}}$。\n\n5.  **特征值问题求解**：线性屈曲分析引出广义特征值问题 $( \\mathbf{K} - \\lambda \\mathbf{K}_g ) \\boldsymbol{\\phi} = 0$。根据问题要求，将其重排为 $\\mathbf{K}_g \\boldsymbol{\\phi} = \\mu \\mathbf{K} \\boldsymbol{\\phi}$，其中 $\\mu = 1/\\lambda$。最小的正屈曲因子 $\\lambda_{\\text{crit}}$ 对应于最大的特征值 $\\mu_{\\max}$。使用 `scipy.linalg.eigh` 求解缩减后的系统 $\\mathbf{K}_{g, \\text{free}} \\boldsymbol{\\phi}_{\\text{free}} = \\mu \\mathbf{K}_{\\text{free}} \\boldsymbol{\\phi}_{\\text{free}}$，该求解器适用于对称广义特征值问题。返回的最大特征值即为 $\\mu_{\\max}$，临界屈曲因子则为 $\\lambda = 1/\\mu_{\\max}$。\n\n6.  **收敛率估计**：对每个测试用例，在三个连续细化的网格（$h_1, h_2=h_1/2, h_3=h_2/2$）上重复分析。使用得到的屈曲因子 $\\lambda(h_1)$、$\\lambda(h_2)$ 和 $\\lambda(h_3)$，通过以下公式估计渐近收敛率 $p$：\n    $$\n    p \\approx \\frac{\\log\\left( \\left|\\lambda(h_2) - \\lambda(h_1)\\right| \\, / \\, \\left|\\lambda(h_3) - \\lambda(h_2)\\right|\\right)}{\\log(2)}\n    $$\n    如果分母中的差值在数值上为零，则使用一个小的正则化项来防止除以零。\n\n提供的 Python 代码实现了这整个过程。它被构造成多个函数，分别用于单元矩阵计算、给定网格的全局分析，以及一个主驱动函数来处理所有测试用例并计算最终的收敛率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef get_shape_functions(xi, eta):\n    \"\"\"\n    Computes the bilinear shape functions for a 4-node quad element.\n    \"\"\"\n    N = np.zeros(4)\n    N[0] = 0.25 * (1.0 - xi) * (1.0 - eta)\n    N[1] = 0.25 * (1.0 + xi) * (1.0 - eta)\n    N[2] = 0.25 * (1.0 + xi) * (1.0 + eta)\n    N[3] = 0.25 * (1.0 - xi) * (1.0 + eta)\n    return N\n\ndef get_shape_function_derivatives(coords, xi, eta):\n    \"\"\"\n    Computes derivatives of shape functions w.r.t. real coordinates (x, y).\n    \"\"\"\n    dNdxi = 0.25 * np.array([-(1.0 - eta), (1.0 - eta), (1.0 + eta), -(1.0 + eta)])\n    dNdeta = 0.25 * np.array([-(1.0 - xi), -(1.0 + xi), (1.0 + xi), (1.0 - xi)])\n    N_deriv_iso = np.vstack([dNdxi, dNdeta])\n\n    J = N_deriv_iso @ coords\n    detJ = np.linalg.det(J)\n    invJ = np.linalg.inv(J)\n    \n    N_deriv_real = invJ @ N_deriv_iso\n    return N_deriv_real, detJ\n\ndef get_element_matrices(coords, Db, Ds, N0):\n    \"\"\"\n    Computes the element stiffness (Ke) and geometric stiffness (Kge) matrices.\n    \"\"\"\n    Ke = np.zeros((12, 12))\n    Kge = np.zeros((12, 12))\n\n    # Gauss points and weights for 2x2 quadrature\n    gp_loc = 1.0 / np.sqrt(3.0)\n    gauss_points_2x2 = [(-gp_loc, -gp_loc), (gp_loc, -gp_loc),\n                        (gp_loc, gp_loc), (-gp_loc, gp_loc)]\n    gauss_weights_2x2 = [1.0, 1.0, 1.0, 1.0]\n\n    # Gauss point and weight for 1x1 quadrature\n    gauss_points_1x1 = [(0.0, 0.0)]\n    gauss_weights_1x1 = [4.0]\n\n    N_mat = np.array([[N0, 0.0], [0.0, 0.0]])\n\n    # Bending stiffness (Kb) using 2x2 quadrature\n    K_b = np.zeros((12, 12))\n    for gp, w_gp in zip(gauss_points_2x2, gauss_weights_2x2):\n        xi, eta = gp\n        N_deriv_real, detJ = get_shape_function_derivatives(coords, xi, eta)\n        \n        Bb = np.zeros((3, 12))\n        for i in range(4):\n            dNi_dx, dNi_dy = N_deriv_real[0, i], N_deriv_real[1, i]\n            # [w_i, th_xi, th_yi]\n            Bb[0, 3 * i + 1] = dNi_dx\n            Bb[1, 3 * i + 2] = dNi_dy\n            Bb[2, 3 * i + 1] = dNi_dy\n            Bb[2, 3 * i + 2] = dNi_dx\n        \n        K_b += Bb.T @ Db @ Bb * detJ * w_gp\n\n    # Shear stiffness (Ks) using 1x1 quadrature (Reduced Integration)\n    K_s = np.zeros((12, 12))\n    for gp, w_gp in zip(gauss_points_1x1, gauss_weights_1x1):\n        xi, eta = gp\n        N = get_shape_functions(xi, eta)\n        N_deriv_real, detJ = get_shape_function_derivatives(coords, xi, eta)\n        \n        Bs = np.zeros((2, 12))\n        for i in range(4):\n            Ni = N[i]\n            dNi_dx, dNi_dy = N_deriv_real[0, i], N_deriv_real[1, i]\n            Bs[0, 3 * i] = dNi_dx\n            Bs[0, 3 * i + 1] = Ni\n            Bs[1, 3 * i] = dNi_dy\n            Bs[1, 3 * i + 2] = Ni\n        \n        K_s += Bs.T @ Ds @ Bs * detJ * w_gp\n\n    Ke = K_b + K_s\n\n    # Geometric stiffness (Kge) using 2x2 quadrature\n    for gp, w_gp in zip(gauss_points_2x2, gauss_weights_2x2):\n        xi, eta = gp\n        N_deriv_real, detJ = get_shape_function_derivatives(coords, xi, eta)\n        \n        Bg = np.zeros((2, 12))\n        for i in range(4):\n            dNi_dx, dNi_dy = N_deriv_real[0, i], N_deriv_real[1, i]\n            Bg[0, 3*i] = dNi_dx\n            Bg[1, 3*i] = dNi_dy\n            \n        Kge += Bg.T @ N_mat @ Bg * detJ * w_gp\n\n    return Ke, Kge\n\ndef analyze_plate(a, b, t, nx, ny, E, nu, N0):\n    \"\"\"\n    Performs the full buckling analysis for a given plate and mesh.\n    \"\"\"\n    # Material properties\n    D = E * t**3 / (12.0 * (1.0 - nu**2))\n    G = E / (2.0 * (1.0 + nu))\n    kappa_s = 5.0 / 6.0\n    \n    Db = D * np.array([[1.0, nu, 0.0], [nu, 1.0, 0.0], [0.0, 0.0, (1.0 - nu) / 2.0]])\n    Ds = kappa_s * G * t * np.identity(2)\n\n    # Mesh generation\n    num_nodes = (nx + 1) * (ny + 1)\n    num_dofs = 3 * num_nodes\n    K = np.zeros((num_dofs, num_dofs))\n    Kg = np.zeros((num_dofs, num_dofs))\n    \n    nodes_coords = np.array([[i * a / nx, j * b / ny] for j in range(ny + 1) for i in range(nx + 1)])\n\n    # Assemble global matrices\n    for j in range(ny):\n        for i in range(nx):\n            n1 = i + j * (nx + 1)\n            n2 = (i + 1) + j * (nx + 1)\n            n3 = (i + 1) + (j + 1) * (nx + 1)\n            n4 = i + (j + 1) * (nx + 1)\n            \n            elem_nodes = [n1, n2, n3, n4]\n            elem_coords = nodes_coords[elem_nodes]\n            \n            Ke, Kge = get_element_matrices(elem_coords, Db, Ds, N0)\n            \n            dof_map = np.array([[3 * n, 3 * n + 1, 3 * n + 2] for n in elem_nodes]).flatten()\n            K[np.ix_(dof_map, dof_map)] += Ke\n            Kg[np.ix_(dof_map, dof_map)] += Kge\n\n    # Apply clamped boundary conditions\n    constrained_dofs = []\n    for node_idx in range(num_nodes):\n        x, y = nodes_coords[node_idx]\n        if np.isclose(x, 0.0) or np.isclose(x, a) or np.isclose(y, 0.0) or np.isclose(y, b):\n            constrained_dofs.extend([3 * node_idx, 3 * node_idx + 1, 3 * node_idx + 2])\n    \n    all_dofs = np.arange(num_dofs)\n    free_dofs = np.setdiff1d(all_dofs, constrained_dofs)\n\n    K_free = K[np.ix_(free_dofs, free_dofs)]\n    Kg_free = Kg[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve generalized eigenvalue problem: Kg * v = mu * K * v\n    try:\n        eigvals = linalg.eigh(Kg_free, K_free, eigvals_only=True)\n    except linalg.LinAlgError:\n        # Fallback to a more general solver if K_free is not positive definite\n        eigvals, _ = linalg.eig(Kg_free, K_free)\n        eigvals = np.real(eigvals)\n\n    mu_max = np.max(eigvals)\n    \n    if mu_max == 0 or np.isinf(mu_max) or np.isnan(mu_max):\n        return np.nan\n\n    lambda_crit = 1.0 / mu_max\n    return lambda_crit\n\ndef solve():\n    \"\"\"\n    Main driver function to run test cases and compute convergence rates.\n    \"\"\"\n    test_cases = [\n        {'a': 1.0, 'b': 1.0, 't': 0.10, 'meshes': [(4, 4), (8, 8), (16, 16)]},\n        {'a': 1.0, 'b': 1.0, 't': 0.01, 'meshes': [(4, 4), (8, 8), (16, 16)]},\n        {'a': 2.0, 'b': 1.0, 't': 0.05, 'meshes': [(6, 3), (12, 6), (24, 12)]},\n    ]\n    \n    E = 1.0\n    nu = 0.3\n    N0 = 1.0\n    \n    results = []\n    for case in test_cases:\n        lambdas = []\n        for nx, ny in case['meshes']:\n            lambda_val = analyze_plate(case['a'], case['b'], case['t'], nx, ny, E, nu, N0)\n            lambdas.append(lambda_val)\n\n        diff1 = abs(lambdas[1] - lambdas[0])\n        diff2 = abs(lambdas[2] - lambdas[1])\n        \n        # Regularization to avoid division by zero\n        if diff2  1e-16:\n            p = np.nan # Undefined convergence\n        else:\n            p = np.log(diff1 / diff2) / np.log(2.0)\n        \n        results.append(p)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2574106"}]}