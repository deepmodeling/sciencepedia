{"hands_on_practices": [{"introduction": "这项实践是理解一致性切线的基石。我们将从虚功原理出发，为一个简单的超弹性杆单元推导其一致性切线刚度矩阵。此练习还将引导你掌握一项至关重要的工程技能：使用有限差分法（一种常被称为“切线检查”的技术）来验证你的解析实现，确保代码的正确性 [@problem_id:2547569]。", "problem": "考虑有限元法 (FEM) 中总拉格朗日列式下的单个双节点杆单元。设参考坐标为 $X \\in [0,L_0]$，参考构型中的节点位移为 $u_1$ 和 $u_2$。假设单元上采用线性形函数，因此位移场为 $u(X) = N_1(X) u_1 + N_2(X) u_2$，其对参考坐标的导数是常数。变形梯度为 $F = 1 + \\frac{\\partial u}{\\partial X}$。横截面积为 $A$，对于此问题，所有量均可视为无量纲。\n\n该杆由可压缩超弹性材料制成，其单位参考体积的应变能密度由下式给出：\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2,\n$$\n其中 $F > 0$，$\\lambda$ 和 $\\mu$ 是拉梅参数。第一皮奥拉-基尔霍夫应力定义为 $P(F) = \\frac{\\partial \\Psi}{\\partial F}$。在该单元的总拉格朗日设置中，平衡的弱形式导出了内力向量，并通过线性化得到了一致算法切向刚度矩阵，该矩阵必须在牛顿-拉夫逊 (NR) 迭代中使用，以在非线性分析中实现二次收敛。\n\n您的任务是：\n1. 从虚功原理和第一皮奥拉-基尔霍夫应力的定义出发，推导出该单元的 $2 \\times 1$ 内力向量 $f_{\\text{int}}(u_1,u_2)$，用 $A$、$L_0$ 和 $P(F)$ 表示。\n2. 使用链式法则和定义 $F = 1 + \\frac{u_2 - u_1}{L_0}$，推导出 $2 \\times 2$ 一致切向刚度矩阵 $K_{\\text{cons}}(u_1,u_2)$，作为精确雅可比矩阵 $\\frac{\\partial f_{\\text{int}}}{\\partial [u_1,u_2]}$，用 $A$、$L_0$ 和在当前 $F$ 下求得的 $\\frac{dP}{dF}$ 表示。\n3. 实现一个数值微分程序，以计算内力的有限差分雅可比矩阵 $K_{\\text{num}}$。对每个节点位移分量使用带有小扰动的对称中心差分。使用一个与 $L_0$ 成比例的扰动步长，以在不同单元尺寸下保持数值稳定性。\n4. 对于下面指定的每个测试用例，计算一致切向刚度矩阵和数值雅可比矩阵之间的相对弗罗贝尼乌斯范数误差，\n$$\ne = \\frac{\\| K_{\\text{cons}} - K_{\\text{num}} \\|_F}{\\max\\left(1, \\| K_{\\text{num}} \\|_F \\right)}.\n$$\n将此误差报告为浮点数。\n\n您必须实现一个完整的程序，对于下面测试套件中的每组参数，计算误差 $e$ 并将误差列表作为单行输出。不涉及角度。不需要物理单位；将所有量视为无量纲。您的程序必须生成一行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个误差必须以科学记数法打印，并保留小数点后八位数字。\n\n测试套件（每个用例为 $(A, L_0, \\lambda, \\mu, u_1, u_2)$）：\n- 用例 1（中等伸长）：$(2.0,\\; 1.0,\\; 120.0,\\; 80.0,\\; 0.0,\\; 0.2)$。\n- 用例 2（零平均应变）：$(1.0,\\; 3.0,\\; 200.0,\\; 50.0,\\; 0.01,\\; 0.01)$。\n- 用例 3（显著压缩但 F 可接受）：$(1.5,\\; 2.0,\\; 500.0,\\; 30.0,\\; 0.2,\\; -0.5)$。\n- 用例 4（压缩下的近不可压缩响应）：$(0.8,\\; 1.0,\\; 1000.0,\\; 10.0,\\; 0.0,\\; -0.3)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含四个用例的误差，以逗号分隔的列表形式，并用方括号括起来，采用科学记数法，小数点后保留八位数字。例如：\"[1.23456789e-06,9.87654321e-07, ...]\"。", "solution": "所呈现的问题是非线性计算固体力学领域一个标准且定义明确的练习，具体涉及超弹性材料的有限元法 (FEM)。它具有科学依据，并包含了获得唯一解所需的所有信息。因此，我们可以进行推导和实现。\n\n分析基于总拉格朗日框架下的单个双节点杆单元。单元的参考长度为 $L_0$，其恒定的横截面积为 $A$，其节点位移由向量 $\\mathbf{u} = [u_1, u_2]^T$ 表示。\n\n首先，我们建立运动学关系。位移场 $u(X)$ 通过线性形函数 $N_1(X) = 1 - X/L_0$ 和 $N_2(X) = X/L_0$ 从节点位移插值得到。位移梯度则为：\n$$\n\\frac{\\partial u}{\\partial X} = \\frac{\\partial}{\\partial X} (N_1(X) u_1 + N_2(X) u_2) = \\frac{\\partial N_1}{\\partial X} u_1 + \\frac{\\partial N_2}{\\partial X} u_2 = -\\frac{1}{L_0} u_1 + \\frac{1}{L_0} u_2 = \\frac{u_2 - u_1}{L_0}\n$$\n这个量在整个单元内是恒定的。变形梯度 $F$ 定义为 $F = 1 + \\partial u / \\partial X$，这给出：\n$$\nF = 1 + \\frac{u_2 - u_1}{L_0}\n$$\n由于位移梯度是恒定的，所以在单元域 $X \\in [0, L_0]$ 上 $F$ 也是恒定的。\n\n材料行为由给定的应变能密度函数 $\\Psi(F)$ 描述：\n$$\n\\Psi(F) = \\frac{\\mu}{2} \\left( F^2 - 1 - 2 \\ln F \\right) + \\frac{\\lambda}{2} \\left( \\ln F \\right)^2\n$$\n第一皮奥拉-基尔霍夫 (PK$1$) 应力 $P$ 是 $\\Psi$ 相对于 $F$ 的导数：\n$$\nP(F) = \\frac{\\partial \\Psi}{\\partial F} = \\frac{\\mu}{2} \\left( 2F - \\frac{2}{F} \\right) + \\frac{\\lambda}{2} \\left( 2 (\\ln F) \\cdot \\frac{1}{F} \\right) = \\mu \\left( F - \\frac{1}{F} \\right) + \\frac{\\lambda \\ln F}{F}\n$$\n\n**任务 1：内力向量的推导**\n\n内力向量 $\\mathbf{f}_{\\text{int}}$ 由虚功原理推导而来。内虚功 $\\delta W_{\\text{int}}$ 由 PK$1$ 应力与变形梯度变分在参考体积 $V_0$ 上的积分给出。对于一维杆，这简化为：\n$$\n\\delta W_{\\text{int}} = \\int_{V_0} P \\, \\delta F \\, dV_0 = \\int_0^{L_0} P \\, \\delta F \\, A \\, dX\n$$\n变形梯度的变分 $\\delta F$ 为：\n$$\n\\delta F = \\delta \\left( 1 + \\frac{u_2 - u_1}{L_0} \\right) = \\frac{\\delta u_2 - \\delta u_1}{L_0}\n$$\n由于 $P$、$A$ 和 $\\delta F$ 在单元上都是恒定的，积分变得很简单：\n$$\n\\delta W_{\\text{int}} = A P \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) \\int_0^{L_0} dX = A P L_0 \\left( \\frac{\\delta u_2 - \\delta u_1}{L_0} \\right) = A P (\\delta u_2 - \\delta u_1)\n$$\n我们可以将其写成矩阵形式：\n$$\n\\delta W_{\\text{int}} = [-\\delta u_1, \\delta u_2] \\begin{bmatrix} A P \\\\ A P \\end{bmatrix} \\text{ (这不正确，让我们更精确些)} \\quad \\delta W_{\\text{int}} = (-A P) \\delta u_1 + (A P) \\delta u_2 = [\\delta u_1, \\delta u_2] \\begin{bmatrix} -A P \\\\ A P \\end{bmatrix}\n$$\n根据定义，$\\delta W_{\\text{int}} = \\delta \\mathbf{u}^T \\mathbf{f}_{\\text{int}}$。比较这两个表达式，我们确定内力向量为：\n$$\n\\mathbf{f}_{\\text{int}}(u_1, u_2) = \\begin{bmatrix} f_{\\text{int},1} \\\\ f_{\\text{int},2} \\end{bmatrix} = \\begin{bmatrix} -A P(F) \\\\ A P(F) \\end{bmatrix} = A P(F) \\begin{bmatrix} -1 \\\\ 1 \\end{bmatrix}\n$$\n这个结果与力学平衡一致，即在均匀拉伸或压缩下，杆两节点的内力必须大小相等、方向相反。\n\n**任务 2：一致切向刚度矩阵的推导**\n\n一致切向刚度矩阵 $\\mathbf{K}_{\\text{cons}}$ 是内力向量关于节点位移向量 $\\mathbf{u} = [u_1, u_2]^T$ 的精确雅可比矩阵。\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{\\partial \\mathbf{f}_{\\text{int}}}{\\partial \\mathbf{u}} = \\begin{bmatrix} \\frac{\\partial f_{\\text{int},1}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},1}}{\\partial u_2} \\\\ \\frac{\\partial f_{\\text{int},2}}{\\partial u_1} & \\frac{\\partial f_{\\text{int},2}}{\\partial u_2} \\end{bmatrix}\n$$\n我们应用链式法则，因为 $\\mathbf{f}_{\\text{int}}$ 通过 $F$ 依赖于 $\\mathbf{u}$。所需的 $F$ 的偏导数为：\n$$\n\\frac{\\partial F}{\\partial u_1} = -\\frac{1}{L_0}, \\quad \\frac{\\partial F}{\\partial u_2} = \\frac{1}{L_0}\n$$\n现在我们计算 $\\mathbf{K}_{\\text{cons}}$ 的分量：\n$$\nK_{11} = \\frac{\\partial (-A P(F))}{\\partial u_1} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = -A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{12} = \\frac{\\partial (-A P(F))}{\\partial u_2} = -A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = -A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{21} = \\frac{\\partial (A P(F))}{\\partial u_1} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_1} = A \\frac{dP}{dF} \\left(-\\frac{1}{L_0}\\right) = -\\frac{A}{L_0} \\frac{dP}{dF}\n$$\n$$\nK_{22} = \\frac{\\partial (A P(F))}{\\partial u_2} = A \\frac{dP}{dF} \\frac{\\partial F}{\\partial u_2} = A \\frac{dP}{dF} \\left(\\frac{1}{L_0}\\right) = \\frac{A}{L_0} \\frac{dP}{dF}\n$$\n将这些分量组装成矩阵：\n$$\n\\mathbf{K}_{\\text{cons}} = \\frac{A}{L_0} \\frac{dP}{dF} \\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}\n$$\n项 $c = dP/dF$ 是算法切向模量。我们必须计算其显式形式：\n$$\n\\frac{dP}{dF} = \\frac{d}{dF} \\left( \\mu F - \\mu F^{-1} + \\lambda F^{-1} \\ln F \\right) \\\\\n= \\mu - \\mu(-1)F^{-2} + \\lambda \\left[ (-1)F^{-2} \\ln F + F^{-1} (F^{-1}) \\right] \\\\\n= \\mu + \\frac{\\mu}{F^2} - \\frac{\\lambda \\ln F}{F^2} + \\frac{\\lambda}{F^2} \\\\\n= \\mu \\left( 1 + \\frac{1}{F^2} \\right) + \\frac{\\lambda}{F^2} (1 - \\ln F)\n$$\n至此，解析推导完成。一致切向刚度矩阵作为精确雅可比矩阵，对于在非线性模拟中实现牛顿-拉夫逊方法的二次收敛速度至关重要。\n\n**任务 3 和 4：数值实现与误差计算**\n\n我们将实现 $\\mathbf{f}_{\\text{int}}$ 和 $\\mathbf{K}_{\\text{cons}}$ 的解析表达式。数值雅可比矩阵 $\\mathbf{K}_{\\text{num}}$ 将使用对称中心有限差分格式计算。$\\mathbf{K}_{\\text{num}}$ 的第 $j$ 列近似为：\n$$\n(\\mathbf{K}_{\\text{num}})_{:,j} \\approx \\frac{\\mathbf{f}_{\\text{int}}(\\mathbf{u} + h \\mathbf{e}_j) - \\mathbf{f}_{\\text{int}}(\\mathbf{u} - h \\mathbf{e}_j)}{2h}\n$$\n其中 $\\mathbf{e}_j$ 是第 $j$ 个标准基向量，$h$ 是一个小的扰动。按照要求，$h$ 将与单元长度 $L_0$ 成比例，使用 $h = 10^{-7} L_0$ 的值来平衡截断误差和舍入误差。\n\n最后，使用弗罗贝尼乌斯范数计算解析雅可比矩阵和数值雅可比矩阵之间的相对误差：\n$$\ne = \\frac{\\|\\mathbf{K}_{\\text{cons}} - \\mathbf{K}_{\\text{num}}\\|_F}{\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)}\n$$\n归一化因子 $\\max(1, \\|\\mathbf{K}_{\\text{num}}\\|_F)$ 确保了数值稳定性，特别是在刚度矩阵范数可能很小的情况下。下面的程序为给定的测试套件执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the relative error between the consistent tangent stiffness matrix and a\n    numerically computed Jacobian for a hyperelastic bar element.\n    \"\"\"\n    # Test suite: (A, L0, lambda, mu, u1, u2)\n    test_cases = [\n        # Case 1 (moderate extension)\n        (2.0, 1.0, 120.0, 80.0, 0.0, 0.2),\n        # Case 2 (zero average strain)\n        (1.0, 3.0, 200.0, 50.0, 0.01, 0.01),\n        # Case 3 (significant compression but admissible F)\n        (1.5, 2.0, 500.0, 30.0, 0.2, -0.5),\n        # Case 4 (nearly incompressible response with compression)\n        (0.8, 1.0, 1000.0, 10.0, 0.0, -0.3),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, L0, lam, mu, u1_val, u2_val = case\n        u = np.array([u1_val, u2_val])\n\n        # Define kinematic and constitutive functions\n        def get_F(disp_vector):\n            \"\"\"Computes the deformation gradient F from a displacement vector.\"\"\"\n            return 1.0 + (disp_vector[1] - disp_vector[0]) / L0\n\n        def get_P(F_val):\n            \"\"\"Computes the First Piola-Kirchhoff stress P from F.\"\"\"\n            if F_val = 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # P(F) = mu * (F - 1/F) + lambda * ln(F) / F\n            return mu * (F_val - 1.0 / F_val) + lam * np.log(F_val) / F_val\n\n        def get_dP_dF(F_val):\n            \"\"\"Computes the tangent modulus dP/dF from F.\"\"\"\n            if F_val = 0:\n                raise ValueError(\"Deformation gradient F must be positive.\")\n            # dP/dF = mu * (1 + 1/F^2) + lambda * (1 - ln(F)) / F^2\n            F_sq = F_val**2\n            return mu * (1.0 + 1.0 / F_sq) + lam * (1.0 - np.log(F_val)) / F_sq\n\n        def get_f_int(disp_vector):\n            \"\"\"Computes the internal force vector for a given displacement vector.\"\"\"\n            F_val = get_F(disp_vector)\n            P_val = get_P(F_val)\n            # f_int = A * P * [-1, 1]^T\n            return A * P_val * np.array([-1.0, 1.0])\n\n        # Task 2: Compute the consistent tangent stiffness matrix K_cons\n        F_current = get_F(u)\n        dP_dF_current = get_dP_dF(F_current)\n        # K_cons = (A/L0) * dP/dF * [[1, -1], [-1, 1]]\n        K_cons = (A / L0) * dP_dF_current * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Task 3: Compute the numerical Jacobian K_num using central differences\n        h = L0 * 1e-7  # Perturbation step size, scaled with element length\n        K_num = np.zeros((2, 2))\n        \n        # Column 1: Perturb u1\n        u_p1 = u + np.array([h, 0.0])\n        u_m1 = u - np.array([h, 0.0])\n        f_p1 = get_f_int(u_p1)\n        f_m1 = get_f_int(u_m1)\n        col1 = (f_p1 - f_m1) / (2.0 * h)\n        \n        # Column 2: Perturb u2\n        u_p2 = u + np.array([0.0, h])\n        u_m2 = u - np.array([0.0, h])\n        f_p2 = get_f_int(u_p2)\n        f_m2 = get_f_int(u_m2)\n        col2 = (f_p2 - f_m2) / (2.0 * h)\n        \n        K_num[:, 0] = col1\n        K_num[:, 1] = col2\n        \n        # Task 4: Compute the relative Frobenius norm error\n        diff_norm = np.linalg.norm(K_cons - K_num, 'fro')\n        K_num_norm = np.linalg.norm(K_num, 'fro')\n        \n        error = diff_norm / max(1.0, K_num_norm)\n        results.append(error)\n\n    # Format and print the final output as a single line\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547569"}, {"introduction": "在超弹性模型的基础上，这项实践将带你探索与历史相关的材料。我们将为一个一维弹塑性模型推导其一致性切线，这需要对离散的算法更新方程（返回映射算法）进行线性化 [@problem_id:2547573]。此过程揭示了一致性切线 $\\mathbb{C}_{\\text{alg}}$ 是数值算法的精确线性化，而不仅仅是物理本构的微分，这是计算非弹性力学中的一个核心思想。", "problem": "考虑一个一维小应变率无关弹塑性材料，其具有线性各向同性硬化特性，用作有限元法（FEM）中两节点杆单元的本构模型。其弹性定律由胡克定律给出：$\\,\\sigma = E(\\varepsilon - \\varepsilon^{p})\\,$，其中 $\\,\\sigma\\,$ 是柯西应力，$\\,\\varepsilon\\,$ 是总应变，$\\,\\varepsilon^{p}\\,$ 是塑性应变，$\\,E\\,$ 是杨氏模量。屈服函数采用 von Mises 形式的一维特例：$\\,f(\\sigma,\\kappa) = |\\sigma| - \\big(\\sigma_{y0} + H\\,\\kappa\\big)\\le 0\\,$，其中 $\\,\\sigma_{y0}\\,$ 是初始屈服应力，$\\,H\\,$ 是（常数）各向同性硬化模量，$\\,\\kappa\\,$ 是累积塑性应变。流动法則是相关的，硬化法则为 $\\,\\dot{\\kappa} = \\dot{\\gamma}\\,$，并带有塑性乘子 $\\,\\dot{\\gamma}\\,$ 的标准 Kuhn–Tucker 条件。\n\n在从步骤 $\\,n\\,$ 到 $\\,n+1\\,$ 的增量上使用后向欧拉时间离散化，其中状态 $\\,(\\varepsilon^{p}_{n},\\kappa_{n})\\,$ 已知，总应变 $\\,\\varepsilon_{n+1}\\,$ 已给定。假设在该增量上为单调拉伸加载，因此 $\\,\\sigma_{n+all}  0\\,$、$\\,\\Delta\\gamma  0\\,$ 且 $\\,f_{n+1}=0\\,$（一个塑性步）。\n\n严格地从上述本构定义和后向欧拉离散化出发（不得假设任何其他专用公式），推导用于 Newton 方法的算法一致切线模量，即量\n$$\n\\mathbb{C}_{\\text{alg}} := \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} \\, ,\n$$\n对于此塑性步。最终答案仅用 $\\,E\\,$ 和 $\\,H\\,$ 表示。提供最终表达式（无需分情况讨论）。在最终的方框答案中不要包含单位。", "solution": "所提出的问题是有效的，因为它是计算塑性力学领域一个标准且定义明确的练习。该问题有科学依据、内部一致，并要求为非线性固体力学问题的数值解推导一个关键量。我们开始进行求解。\n\n目标是为一个经历塑性加载步、具有线性各向同性硬化的一维弹塑性模型推导算法一致切线模量，其定义为 $\\mathbb{C}_{\\text{alg}} := \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$。推导必须从使用后向欧拉法离散化的基本本构方程开始。\n\n时间增量结束时（步骤 $n+1$）的状态由总应变 $\\varepsilon_{n+1}$ 和增量开始时的已知状态 $(\\varepsilon^{p}_{n}, \\kappa_{n})$ 确定。问题假设在拉伸加载下发生塑性步，这意味着塑性乘子增量 $\\Delta\\gamma  0$ 且屈服条件得到满足 $f_{n+1}=0$。使用后向欧拉格式在时间步上积分的控制方程，构成一个非线性代数方程组：\n\n1. 弹性应力-应变关系：\n$$\n\\sigma_{n+1} = E (\\varepsilon_{n+1} - \\varepsilon^{p}_{n+1})\n$$\n\n2. 塑性应变演化（积分形式的流动法则）：流动法则是 $\\dot{\\varepsilon}^{p} = \\dot{\\gamma} \\frac{\\partial f}{\\partial \\sigma}$。对于给定的屈服函数 $f(\\sigma, \\kappa) = |\\sigma| - (\\sigma_{y0} + H\\kappa)$，其梯度为 $\\frac{\\partial f}{\\partial \\sigma} = \\text{sgn}(\\sigma)$。鉴于拉伸加载的假设，$\\sigma_{n+1}  0$，因此 $\\text{sgn}(\\sigma_{n+1}) = 1$。积分形式的流动法则变为：\n$$\n\\varepsilon^{p}_{n+1} = \\varepsilon^{p}_{n} + \\Delta\\gamma \\, \\text{sgn}(\\sigma_{n+1}) = \\varepsilon^{p}_{n} + \\Delta\\gamma\n$$\n\n3. 硬化法则演化：法则是 $\\dot{\\kappa} = \\dot{\\gamma}$。其积分形式为：\n$$\n\\kappa_{n+1} = \\kappa_{n} + \\Delta\\gamma\n$$\n\n4. 屈服（一致性）条件：$f_{n+1}=0$。当 $\\sigma_{n+1}0$ 时，此条件为：\n$$\n|\\sigma_{n+1}| - (\\sigma_{y0} + H \\kappa_{n+1}) = \\sigma_{n+1} - (\\sigma_{y0} + H \\kappa_{n+1}) = 0\n$$\n\n这四个方程组成的方程组隐式地将最终状态变量 $(\\sigma_{n+1}, \\varepsilon^{p}_{n+1}, \\kappa_{n+1}, \\Delta\\gamma)$ 定义为驱动变量 $\\varepsilon_{n+1}$ 的函数。一致切线模量可以通过对这些方程关于 $\\varepsilon_{n+1}$ 求全导数来找到，同时认识到步骤 $n$ 的变量在此上下文中是常数。\n\n让我们对该方程组关于 $\\varepsilon_{n+1}$ 进行微分：\n\n1'. 根据弹性定律：\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( \\frac{\\partial \\varepsilon_{n+1}}{\\partial \\varepsilon_{n+1}} - \\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} \\right) = E \\left( 1 - \\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} \\right)\n$$\n\n2'. 根据塑性应变演化：\n$$\n\\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial}{\\partial \\varepsilon_{n+1}}(\\varepsilon^{p}_{n} + \\Delta\\gamma) = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}\n$$\n\n3'. 根据硬化法则（此步骤对于最终结果并非严格必需，但它完成了系统的线性化）：\n$$\n\\frac{\\partial \\kappa_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial}{\\partial \\varepsilon_{n+1}}(\\kappa_{n} + \\Delta\\gamma) = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}\n$$\n\n4'. 根据屈服条件：\n$$\n\\frac{\\partial}{\\partial \\varepsilon_{n+1}} \\left( \\sigma_{n+1} - \\sigma_{y0} - H \\kappa_{n+1} \\right) = 0\n$$\n代入 $\\kappa_{n+1}$ 的表达式：\n$$\n\\frac{\\partial}{\\partial \\varepsilon_{n+1}} \\left( \\sigma_{n+1} - \\sigma_{y0} - H (\\kappa_{n} + \\Delta\\gamma) \\right) = 0\n$$\n进行微分：\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} - H \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} = 0\n$$\n这最后一个方程提供了应力导数与塑性乘子增量导数之间的直接关系。我们可以写出：\n$$\n\\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} = \\frac{1}{H} \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}\n$$\n现在，我们为 $\\mathbb{C}_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$ 构建一个可解的方程组。\n根据方程 $(2')$，我们有 $\\frac{\\partial \\varepsilon^{p}_{n+1}}{\\partial \\varepsilon_{n+1}} = \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}$。将此代入方程 $(1')$ 得到：\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( 1 - \\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}} \\right)\n$$\n接下来，将微分后的屈服条件中 $\\frac{\\partial (\\Delta\\gamma)}{\\partial \\varepsilon_{n+1}}$ 的表达式代入此方程：\n$$\n\\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} = E \\left( 1 - \\frac{1}{H} \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}} \\right)\n$$\n我们现在得到了一个关于未知切线模量 $\\mathbb{C}_{\\text{alg}} = \\frac{\\partial \\sigma_{n+1}}{\\partial \\varepsilon_{n+1}}$ 的单个方程。让我们来求解它。\n$$\n\\mathbb{C}_{\\text{alg}} = E - \\frac{E}{H} \\mathbb{C}_{\\text{alg}}\n$$\n$$\n\\mathbb{C}_{\\text{alg}} + \\frac{E}{H} \\mathbb{C}_{\\text{alg}} = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} \\left( 1 + \\frac{E}{H} \\right) = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} \\left( \\frac{H+E}{H} \\right) = E\n$$\n$$\n\\mathbb{C}_{\\text{alg}} = E \\left( \\frac{H}{E+H} \\right)\n$$\n因此，塑性步的一致切线模量为：\n$$\n\\mathbb{C}_{\\text{alg}} = \\frac{E H}{E+H}\n$$\n这个结果在此一维情况下也被称为弹塑性切线模量。它正确地反映了材料屈服后刚度的降低，因为它是弹性模量 $E$ 和硬化模量 $H$ 的调和平均值。对于理想塑性（$H=0$），$\\mathbb{C}_{\\text{alg}}=0$；对于纯弹性行为（$H \\to \\infty$ 或不发生屈服），$\\mathbb{C}_{\\text{alg}} \\to E$。", "answer": "$$\n\\boxed{\\frac{E H}{E+H}}\n$$", "id": "2547573"}, {"introduction": "在学习了如何推导和实现一致性切线之后，这最后一个练习将展示其为何如此重要。通过比较真正的牛顿-拉弗森法（使用一致性切线 $k_{\\text{tan}}(u)$）和一种准牛顿法（不使用一致性切线）的性能，你将定量地看到收敛速度的显著提升 [@problem_id:2547604]。这项实践为我们追求一致性线性化所需的理论严谨性提供了清晰而有力的证明。", "problem": "考虑一根未变形长度为 $L$、横截面积为 $A$ 的一维杆，其左端固定，右端承受集中轴向力 $P$。假设为小应变运动学，因此轴向应变为 $\\varepsilon = u/L$，其中 $u$ 是加载端的轴向位移。该材料的非线性应力-应变关系由 $\\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3}$ 给出，其中 $E$ 是杨氏模量，$\\beta \\ge 0$ 是一个材料非线性参数。内部轴向力为 $f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u))$。静力平衡要求 $f_{\\text{int}}(u) - P = 0$。\n\n您的任务是比较求解标量非线性平衡方程 $r(u) = f_{\\text{int}}(u) - P = 0$ 的两种迭代求解策略的收敛行为：\n- 方法 $\\mathsf{CT}$（“使用一致切线”）：标准的 Newton–Raphson 方法，使用一致切线刚度，其定义为残差相对于位移的精确导数，$k_{\\text{tan}}(u) = \\dfrac{d r(u)}{d u}$。\n- 方法 $\\mathsf{SEC}$（“不使用一致切线”）：一种割线刚度拟牛顿法，在迭代 $n \\ge 1$ 时，使用斜率 $s_{n} = \\dfrac{r(u_{n}) - r(u_{n-1})}{u_{n} - u_{n-1}}$ 代替一致切线。对于从初始猜测值 $u_{0}$ 开始的第一次更新，使用初始线性刚度 $K_{0} = \\left.\\dfrac{d r}{d u}\\right|_{u=0}$ 进行单步预测 $u_{1} = u_{0} - r(u_{0})/K_{0}$。\n\n从基本平衡陈述（内力等于外力）、给定的本构关系和微分的链式法则开始您的推导。除这些基础知识外，不要假定任何专门的公式。请推导：\n- 用 $A$、$E$、$\\beta$、$L$、$u$ 和 $P$ 表示的残差 $r(u)$。\n- 一致切线刚度 $k_{\\text{tan}}(u)$，即精确导数 $\\dfrac{d r}{d u}$。\n\n对两种方法采用以下算法定义：\n- 初始化：使用 $u_{0} = 0$。\n- 收敛检验：当残差绝对值满足 $\\lvert r(u_{n}) \\rvert \\le \\mathrm{tol}$ 时，宣布收敛，其中 $\\mathrm{tol} = 10^{-12}$。\n- 每种方法的最大迭代次数：$N_{\\max} = 50$。如果方法在 $N_{\\max}$ 次更新内未收敛，则报告未收敛。\n- 迭代次数：报告直到收敛（或达到 $N_{\\max}$）实际执行的更新次数。如果初始猜测值已满足残差容差，则迭代次数为 $0$。\n\n本问题中没有物理单位；将所有量视为无量纲量。\n\n实现一个完整的程序，对每个测试用例计算并返回：\n- 方法 $\\mathsf{CT}$ 的迭代次数（一个整数）。\n- 方法 $\\mathsf{SEC}$ 的迭代次数（一个整数）。\n- 方法 $\\mathsf{CT}$ 的布尔标志，指示其是否在 $N_{\\max}$ 内收敛。\n- 方法 $\\mathsf{SEC}$ 的布尔标志，指示其是否在 $N_{\\max}$ 内收敛。\n\n您的程序必须处理以下参数集 $(E, \\beta, A, L, P)$ 的测试套件：\n- 测试 $1$：$(E, \\beta, A, L, P) = (1000, 0, 1, 1, 100)$。\n- 测试 $2$：$(E, \\beta, A, L, P) = (1000, 10^{5}, 1, 1, 100)$。\n- 测试 $3$：$(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 100)$。\n- 测试 $4$：$(E, \\beta, A, L, P) = (1000, 10^{6}, 1, 1, 0)$。\n\n您的程序应生成单行输出，其中包含所有测试的汇总结果，格式为方括号括起来的逗号分隔列表。结果必须按测试用例排序，并且在每个测试用例内按以下顺序排列：$[\\text{iters}_{\\mathsf{CT}}, \\text{iters}_{\\mathsf{SEC}}, \\text{converged}_{\\mathsf{CT}}, \\text{converged}_{\\mathsf{SEC}}]$。因此，最终输出应为一个扁平列表：\n$[\\text{iters}_{\\mathsf{CT}}^{(1)}, \\text{iters}_{\\mathsf{SEC}}^{(1)}, \\text{converged}_{\\mathsf{CT}}^{(1)}, \\text{converged}_{\\mathsf{SEC}}^{(1)}, \\dots, \\text{iters}_{\\mathsf{CT}}^{(4)}, \\text{iters}_{\\mathsf{SEC}}^{(4)}, \\text{converged}_{\\mathsf{CT}}^{(4)}, \\text{converged}_{\\mathsf{SEC}}^{(4)}]$。\n\n您的输出必须与此单行格式完全匹配，不得有任何多余的空格或文本。", "solution": "该问题是有效的。这是一个在计算力学领域中定义明确的练习，旨在比较标准 Newton-Raphson 方法与拟牛顿（割线）方法在一维非线性问题中的收敛性。所有必要的参数、方程和算法定义均已提供，并且问题在科学上是合理的。\n\n首先，我们根据问题陈述推导所需的数学表达式。\n\n轴向应变 $\\varepsilon$ 与杆端位移 $u$ 和杆长 $L$ 的关系如下：\n$$ \\varepsilon(u) = \\frac{u}{L} $$\n材料的应力-应变关系如下：\n$$ \\sigma(\\varepsilon) = E\\,\\varepsilon + \\beta\\,\\varepsilon^{3} $$\n其中 $E$ 是杨氏模量，$\\beta \\ge 0$ 是一个非线性参数。\n\n内力 $f_{\\text{int}}$ 是应力乘以横截面积 $A$：\n$$ f_{\\text{int}}(u) = A\\,\\sigma(\\varepsilon(u)) $$\n通过代入应变和应力的表达式，我们可以将内力表示为位移 $u$ 的函数：\n$$ f_{\\text{int}}(u) = A \\left[ E\\left(\\frac{u}{L}\\right) + \\beta\\left(\\frac{u}{L}\\right)^{3} \\right] = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 $$\n\n残差函数 $r(u)$ 表示内力与外施加力 $P$ 之间的不平衡。静力平衡要求 $r(u) = 0$。\n$$ r(u) = f_{\\text{int}}(u) - P $$\n代入 $f_{\\text{int}}(u)$ 的表达式，我们得到残差的完整表达式：\n$$ r(u) = \\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P $$\n\n接下来，我们推导一致切线刚度 $k_{\\text{tan}}(u)$，它是残差函数相对于位移 $u$ 的精确导数。这是标准 Newton-Raphson 方法（方法 $\\mathsf{CT}$）所必需的。\n$$ k_{\\text{tan}}(u) = \\frac{d r(u)}{d u} = \\frac{d}{du}\\left(\\frac{AE}{L}u + \\frac{A\\beta}{L^3}u^3 - P\\right) $$\n应用微分法则，我们得到：\n$$ k_{\\text{tan}}(u) = \\frac{AE}{L} \\cdot \\frac{d(u)}{du} + \\frac{A\\beta}{L^3} \\cdot \\frac{d(u^3)}{du} - \\frac{d(P)}{du} $$\n由于 $P$ 是一个恒定的施加载荷，其导数为零。\n$$ k_{\\text{tan}}(u) = \\frac{AE}{L} + \\frac{A\\beta}{L^3}(3u^2) = \\frac{AE}{L} + \\frac{3A\\beta}{L^3}u^2 $$\n鉴于 $A  0$、$E  0$、$L  0$ 和 $\\beta \\ge 0$，切线刚度 $k_{\\text{tan}}(u)$ 总是正的。\n\n现在，我们概述迭代算法。两种方法都从初始猜测值 $u_0 = 0$ 开始，并进行迭代，直到残差的绝对值小于或等于容差 $\\lvert r(u_n) \\rvert \\le \\mathrm{tol} = 10^{-12}$，或者直到达到最大迭代次数 $N_{\\max} = 50$。\n\n**方法 $\\mathsf{CT}$ (Newton-Raphson)：**\n在第 $n$ 次迭代中，位移的更新规则是：\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{k_{\\text{tan}}(u_n)} $$\n1. 初始化 $u_0 = 0$。\n2. 检查是否 $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $0$）。\n3. 对于 $n = 0, 1, \\dots, N_{\\max}-1$：\n   a. 计算更新量 $\\Delta u_n = -r(u_n)/k_{\\text{tan}}(u_n)$。\n   b. 更新位移：$u_{n+1} = u_n + \\Delta u_n$。\n   c. 检查是否 $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$。如果是，则停止。迭代次数为 $n+1$。\n4. 如果循环完成但未收敛，则该方法失败。\n\n**方法 $\\mathsf{SEC}$ (割线拟牛顿法)：**\n更新规则使用割线刚度 $s_n$。\n$$ u_{n+1} = u_n - \\frac{r(u_n)}{s_n} $$\n其中对于 $n \\ge 1$：\n$$ s_n = \\frac{r(u_n) - r(u_{n-1})}{u_n - u_{n-1}} $$\n1. 初始化 $u_0 = 0$。\n2. 检查是否 $\\lvert r(u_0) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $0$）。\n3. **第一步 (n=1):** 问题指定使用初始线性刚度进行第一次预测。即 $K_0 = k_{\\text{tan}}(u_0) = k_{\\text{tan}}(0) = AE/L$。\n   $$ u_1 = u_0 - \\frac{r(u_0)}{K_0} $$\n   检查是否 $\\lvert r(u_1) \\rvert \\le \\mathrm{tol}$。如果是，则停止（迭代次数 = $1$）。\n4. **后续步骤 (n  1):** 对于 $n = 1, 2, \\dots, N_{\\max}-2$：\n   a. 计算割线刚度 $s_n$。\n   b. 计算更新量 $\\Delta u_n = -r(u_n)/s_n$。\n   c. 更新位移：$u_{n+1} = u_n + \\Delta u_n$。\n   d. 检查是否 $\\lvert r(u_{n+1}) \\rvert \\le \\mathrm{tol}$。如果是，则停止。迭代次数为 $n+1$。\n5. 如果循环完成，则该方法失败。\n\n需要注意的一个特殊情况是测试 4，其中施加的力 $P=0$。平衡方程为 $r(u) = (AE/L)u + (A\\beta/L^3)u^3 = 0$。初始猜测值为 $u_0 = 0$。在初始猜测值处计算残差得到 $r(0) = 0$。由于 $\\lvert r(0) \\rvert \\le \\mathrm{tol}$，两种算法都应立即终止，迭代次数为 0，并报告收敛。\n\n实现将遵循这些推导和算法步骤，为每个测试用例计算所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as defined in the problem\nTOL = 1e-12\nN_MAX = 50\n\ndef solve_ct(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using the standard Newton-Raphson \n    method with the consistent tangent stiffness (Method CT).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n    \n    # Pre-calculate constants for efficiency\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    a3b_l3 = 3.0 * A * beta / (L**3)\n\n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    def tangent_stiffness(u):\n        return ae_l + a3b_l3 * u**2\n\n    u = 0.0\n    res = residual(u)\n    \n    # Check if initial guess is already a solution\n    if abs(res) = TOL:\n        return 0, True\n\n    for n in range(1, N_MAX + 1):\n        k_tan = tangent_stiffness(u)\n        \n        # k_tan is guaranteed to be positive for the given problem constraints\n        u = u - res / k_tan\n        res = residual(u)\n        \n        if abs(res) = TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve_sec(params):\n    \"\"\"\n    Solves the nonlinear equilibrium equation using a secant-stiffness\n    quasi-Newton method (Method SEC).\n\n    Args:\n        params (tuple): A tuple of floats (E, beta, A, L, P).\n\n    Returns:\n        tuple: A tuple containing the number of iterations (int) and a\n               convergence flag (bool).\n    \"\"\"\n    E, beta, A, L, P = params\n\n    # Pre-calculate constants\n    ae_l = A * E / L\n    ab_l3 = A * beta / (L**3)\n    \n    def residual(u):\n        return ae_l * u + ab_l3 * u**3 - P\n\n    u_prev = 0.0\n    res_prev = residual(u_prev)\n\n    # Check if initial guess is already a solution\n    if abs(res_prev) = TOL:\n        return 0, True\n\n    # First step (n=1) uses the initial linear stiffness K0\n    k0 = ae_l\n    if abs(k0)  1e-15: # Protection against division by zero (not expected here)\n        return N_MAX, False\n        \n    u_curr = u_prev - res_prev / k0\n    res_curr = residual(u_curr)\n    \n    if abs(res_curr) = TOL:\n        return 1, True\n\n    for n in range(2, N_MAX + 1):\n        du = u_curr - u_prev\n        \n        # Check for stagnation or division by zero\n        if abs(du)  1e-15:\n            return n - 1, False # Stalled\n\n        s = (res_curr - res_prev) / du\n\n        if abs(s)  1e-15:\n            return n - 1, False # Divergence or stall likely\n\n        u_next = u_curr - res_curr / s\n\n        # Update values for next iteration\n        u_prev, res_prev = u_curr, res_curr\n        u_curr = u_next\n        res_curr = residual(u_curr)\n\n        if abs(res_curr) = TOL:\n            return n, True\n            \n    return N_MAX, False\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (E, beta, A, L, P)\n    test_cases = [\n        (1000.0, 0.0, 1.0, 1.0, 100.0),\n        (1000.0, 1e5, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 100.0),\n        (1000.0, 1e6, 1.0, 1.0, 0.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        iters_ct, conv_ct = solve_ct(case)\n        iters_sec, conv_sec = solve_sec(case)\n        \n        # Append results in the specified order\n        results.extend([iters_ct, iters_sec, conv_ct, conv_sec])\n\n    # Convert boolean to string 'True'/'False' as required for output\n    formatted_results = [str(r) for r in results]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2547604"}]}