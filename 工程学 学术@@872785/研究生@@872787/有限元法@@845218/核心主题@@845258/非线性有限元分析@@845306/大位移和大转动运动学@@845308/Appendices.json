{"hands_on_practices": [{"introduction": "分析任何变形问题的第一步都是计算最基本的运动学量。本练习将通过一个给定的变形映射，指导你计算变形梯度 ($F$)、柯西-格林变形张量 ($C$ 和 $B$) 以及体积变化率 ($J$)，为你打下坚实的基础。通过这个练习，你将加深对构成有限变形理论核心的各项定义的理解。[@problem_id:2573025]", "problem": "考虑一个在有限元法中使用的大变形运动学框架内分析的三维连续体。设运动由从参考构型坐标 $X=\\left(X_{1},X_{2},X_{3}\\right)$ 到当前构型坐标 $x=\\varphi(X)$ 的映射定义，该映射由下式给出\n$$\nx=\\varphi(X)=(1+\\epsilon)X_{1}\\,e_{1}+(1-\\epsilon)X_{2}\\,e_{2}+X_{3}\\,e_{3},\n$$\n其中 $\\epsilon$ 是一个满足 $|\\epsilon|  1$ 的有限常数，以确保变形是可逆且保向的，并且 $\\{e_{1},e_{2},e_{3}\\}$ 是固定的空间基。仅使用核心运动学定义，精确推导（不对 $\\epsilon$ 进行任何线性化）变形梯度 $F$、右柯西-格林变形张量 $C$、左柯西-格林变形张量 $B$ 以及雅可比行列式 $J$ 作为 $\\epsilon$ 的函数。\n\n使用以下基本定义：变形梯度 $F$ 是运动相对于参考坐标的梯度，右柯西-格林张量是 $C=F^{\\mathsf{T}}F$，左柯西-格林张量是 $B=F F^{\\mathsf{T}}$，雅可比行列式是 $J=\\det F$。\n\n答案规格：\n- 提供以 $\\epsilon$ 表示的精确表达式。不要假设 $\\epsilon$ 是小量。\n- 无需四舍五入。\n- 无需单位。\n- 通过按行主序（即对每个张量，顺序为 $11$, $12$, $13$, $21$, $22$, $23$, $31$, $32$, $33$）列出 $F$、$C$ 和 $B$ 的分量，后跟 $J$，并将它们全部连接成一个单行矩阵来表示你的最终答案。", "solution": "我们从大变形的标准运动学定义出发。运动的分量形式由下式给出\n$$\nx_{1}=(1+\\epsilon)X_{1},\\quad x_{2}=(1-\\epsilon)X_{2},\\quad x_{3}=X_{3}.\n$$\n根据定义，变形梯度 $F$ 是 $x$ 相对于 $X$ 的梯度，\n$$\nF=\\frac{\\partial x}{\\partial X}=\\begin{bmatrix}\n\\frac{\\partial x_{1}}{\\partial X_{1}}   \\frac{\\partial x_{1}}{\\partial X_{2}}   \\frac{\\partial x_{1}}{\\partial X_{3}} \\\\\n\\frac{\\partial x_{2}}{\\partial X_{1}}   \\frac{\\partial x_{2}}{\\partial X_{2}}   \\frac{\\partial x_{2}}{\\partial X_{3}} \\\\\n\\frac{\\partial x_{3}}{\\partial X_{1}}   \\frac{\\partial x_{3}}{\\partial X_{2}}   \\frac{\\partial x_{3}}{\\partial X_{3}}\n\\end{bmatrix}.\n$$\n从分量表达式中，我们得到\n$$\n\\frac{\\partial x_{1}}{\\partial X_{1}}=1+\\epsilon,\\quad \\frac{\\partial x_{1}}{\\partial X_{2}}=0,\\quad \\frac{\\partial x_{1}}{\\partial X_{3}}=0,\\\\\n\\frac{\\partial x_{2}}{\\partial X_{1}}=0,\\quad \\frac{\\partial x_{2}}{\\partial X_{2}}=1-\\epsilon,\\quad \\frac{\\partial x_{2}}{\\partial X_{3}}=0,\\\\\n\\frac{\\partial x_{3}}{\\partial X_{1}}=0,\\quad \\frac{\\partial x_{3}}{\\partial X_{2}}=0,\\quad \\frac{\\partial x_{3}}{\\partial X_{3}}=1.\n$$\n因此，\n$$\nF=\\begin{bmatrix}\n1+\\epsilon   0   0\\\\\n0   1-\\epsilon   0\\\\\n0   0   1\n\\end{bmatrix}.\n$$\n右柯西-格林变形张量定义为 $C=F^{\\mathsf{T}}F$。由于 $F$ 是对角矩阵，所以 $F^{\\mathsf{T}}=F$，$C$ 就是一个对角矩阵，其对角线元素是 $F$ 对应元素的平方：\n$$\nC=F^{\\mathsf{T}}F=\\begin{bmatrix}\n(1+\\epsilon)^{2}   0   0\\\\\n0   (1-\\epsilon)^{2}   0\\\\\n0   0   1\n\\end{bmatrix}.\n$$\n类似地，左柯西-格林变形张量为 $B=F F^{\\mathsf{T}}$，对于对角矩阵 $F$，$B$ 与 $C$ 相同：\n$$\nB=F F^{\\mathsf{T}}=\\begin{bmatrix}\n(1+\\epsilon)^{2}   0   0\\\\\n0   (1-\\epsilon)^{2}   0\\\\\n0   0   1\n\\end{bmatrix}.\n$$\n最后，雅可比行列式定义为 $J=\\det F$。对于对角矩阵 $F$，\n$$\nJ=\\det F=(1+\\epsilon)(1-\\epsilon)\\cdot 1=1-\\epsilon^{2}.\n$$\n为了遵循所要求的输出格式，我们现在按行主序列出 $F$、$C$ 和 $B$ 的分量，后跟 $J$。行主序意味着对每个张量按 $(11,12,13,21,22,23,31,32,33)$ 的顺序列出分量。因此，\n- 对于 $F$：$(1+\\epsilon,\\,0,\\,0,\\,0,\\,(1-\\epsilon),\\,0,\\,0,\\,0,\\,1)$。\n- 对于 $C$：$((1+\\epsilon)^{2},\\,0,\\,0,\\,0,\\,(1-\\epsilon)^{2},\\,0,\\,0,\\,0,\\,1)$。\n- 对于 $B$：$((1+\\epsilon)^{2},\\,0,\\,0,\\,0,\\,(1-\\epsilon)^{2},\\,0,\\,0,\\,0,\\,1)$。\n- 然后是 $J=1-\\epsilon^{2}$。\n将这些连接起来就得到了所要求的单行矩阵。", "answer": "$$\\boxed{\\begin{pmatrix}\n1+\\epsilon   0   0   0   1-\\epsilon   0   0   0   1   (1+\\epsilon)^{2}   0   0   0   (1-\\epsilon)^{2}   0   0   0   1   (1+\\epsilon)^{2}   0   0   0   (1-\\epsilon)^{2}   0   0   0   1   1-\\epsilon^{2}\n\\end{pmatrix}}$$", "id": "2573025"}, {"introduction": "变形梯度 $F$ 本身混合了拉伸和旋转的信息。为了深入理解变形的物理本质，我们必须通过极分解 ($F=RU$) 将这两种效应分离开来。本练习将探讨经典的纯剪切情形，它揭示了一个与直觉相悖但至关重要的概念：有限变形中的剪切必然伴随着刚体旋转。这一深刻见解是有限应变理论区别于无限小应变理论的关键所在。[@problem_id:2573030]", "problem": "考虑一个连续体的平面单剪切变形，其运动 $\\boldsymbol{\\varphi}:\\mathbb{R}^{2}\\to\\mathbb{R}^{2}$ 在笛卡尔坐标系下由下式给出：\n$$\nx_{1} = X_{1} + \\gamma X_{2}, \\quad x_{2} = X_{2},\n$$\n其中 $\\gamma \\in \\mathbb{R}$ 是一个给定的剪切参数，$\\mathbf{X} = (X_{1},X_{2})$ 是参考坐标，$\\mathbf{x} = (x_{1},x_{2})$ 是当前坐标。令 $\\mathbf{F} = \\nabla_{\\! \\mathbf{X}} \\boldsymbol{\\varphi}$ 为变形梯度。使用右极分解将 $\\mathbf{F}$ 写成 $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$ 的形式，其中 $\\mathbf{R}$ 是一个真正交旋转张量，$\\mathbf{U}$ 是一个对称正定右拉伸张量。仅从运动学定义 $\\mathbf{F} = \\partial \\boldsymbol{\\varphi}/\\partial \\mathbf{X}$ 和 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F} = \\mathbf{U}^{2}$ 出发，推导 $\\mathbf{R}$ 和 $\\mathbf{U}$ 关于 $\\gamma$ 的显式闭式表达式，并确定与 $\\mathbf{R}$ 相关联的剪切引起的刚体转角 $\\phi$。假设在具有物理意义的分支上，$\\phi(\\gamma)$ 是连续的且满足 $\\phi(0) = 0$。请以 $\\gamma$ 的函数形式给出转角 $\\phi(\\gamma)$（以弧度为单位）作为最终答案。最终方框内的答案不要包含单位。", "solution": "所述问题具有科学依据、是适定的、客观的，并且包含得出唯一解所需的全部信息。这是有限变形运动学中的一个标准问题。因此，我将开始推导。\n\n运动由映射 $\\boldsymbol{\\varphi}(\\mathbf{X}) = \\mathbf{x}$ 给出，其分量为：\n$$\nx_{1} = X_{1} + \\gamma X_{2}\n$$\n$$\nx_{2} = X_{2}\n$$\n变形梯度张量 $\\mathbf{F}$ 定义为 $\\mathbf{F} = \\frac{\\partial \\mathbf{x}}{\\partial \\mathbf{X}}$，其分量为 $F_{ij} = \\frac{\\partial x_{i}}{\\partial X_{j}}$。我们计算 $\\mathbf{F}$ 的分量：\n$$\nF_{11} = \\frac{\\partial x_{1}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{1} + \\gamma X_{2}) = 1\n$$\n$$\nF_{12} = \\frac{\\partial x_{1}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{1} + \\gamma X_{2}) = \\gamma\n$$\n$$\nF_{21} = \\frac{\\partial x_{2}}{\\partial X_{1}} = \\frac{\\partial}{\\partial X_{1}}(X_{2}) = 0\n$$\n$$\nF_{22} = \\frac{\\partial x_{2}}{\\partial X_{2}} = \\frac{\\partial}{\\partial X_{2}}(X_{2}) = 1\n$$\n变形梯度的矩阵形式为：\n$$\n\\mathbf{F} = \\begin{pmatrix} 1   \\gamma \\\\ 0   1 \\end{pmatrix}\n$$\n右柯西-格林变形张量 $\\mathbf{C}$ 定义为 $\\mathbf{C} = \\mathbf{F}^{\\mathsf{T}}\\mathbf{F}$。我们计算 $\\mathbf{C}$：\n$$\n\\mathbf{C} = \\begin{pmatrix} 1   0 \\\\ \\gamma   1 \\end{pmatrix} \\begin{pmatrix} 1   \\gamma \\\\ 0   1 \\end{pmatrix} = \\begin{pmatrix} (1)(1)+(0)(0)   (1)(\\gamma)+(0)(1) \\\\ (\\gamma)(1)+(1)(0)   (\\gamma)(\\gamma)+(1)(1) \\end{pmatrix} = \\begin{pmatrix} 1   \\gamma \\\\ \\gamma   1+\\gamma^{2} \\end{pmatrix}\n$$\n右极分解为 $\\mathbf{F} = \\mathbf{R}\\mathbf{U}$，其中 $\\mathbf{U}$ 是右拉伸张量，由 $\\mathbf{C}$ 的唯一正定平方根给出，即 $\\mathbf{U} = \\sqrt{\\mathbf{C}}$。对于一个 $2 \\times 2$ 的对称正定矩阵 $\\mathbf{A}$，其平方根由以下公式给出：\n$$\n\\sqrt{\\mathbf{A}} = \\frac{1}{\\sqrt{\\operatorname{tr}(\\mathbf{A}) + 2\\sqrt{\\det(\\mathbf{A})}}} (\\mathbf{A} + \\sqrt{\\det(\\mathbf{A})}\\mathbf{I})\n$$\n对于我们的张量 $\\mathbf{C}$，我们有 $\\operatorname{tr}(\\mathbf{C}) = 1 + (1+\\gamma^{2}) = 2+\\gamma^{2}$ 和 $\\det(\\mathbf{C}) = (1)(1+\\gamma^{2}) - (\\gamma)(\\gamma) = 1$。\n将这些值代入 $\\mathbf{U} = \\sqrt{\\mathbf{C}}$ 的公式中：\n$$\n\\mathbf{U} = \\frac{1}{\\sqrt{(2+\\gamma^{2}) + 2\\sqrt{1}}} \\left( \\mathbf{C} + \\sqrt{1}\\mathbf{I} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} (\\mathbf{C} + \\mathbf{I})\n$$\n$$\n\\mathbf{U} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\left( \\begin{pmatrix} 1   \\gamma \\\\ \\gamma   1+\\gamma^{2} \\end{pmatrix} + \\begin{pmatrix} 1   0 \\\\ 0   1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2   \\gamma \\\\ \\gamma   2+\\gamma^{2} \\end{pmatrix}\n$$\n这就是右拉伸张量 $\\mathbf{U}$ 的显式表达式。\n\n接下来，我们从关系式 $\\mathbf{R} = \\mathbf{F}\\mathbf{U}^{-1}$ 中求出旋转张量 $\\mathbf{R}$。首先，我们计算 $\\mathbf{U}$ 的逆矩阵。由于 $\\det(\\mathbf{U}) = \\det(\\sqrt{\\mathbf{C}}) = \\sqrt{\\det(\\mathbf{C})} = 1$，我们可以使用行列式为1的 $2 \\times 2$ 矩阵的逆矩阵公式：\n$$\n\\mathbf{U}^{-1} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}   -\\gamma \\\\ -\\gamma   2 \\end{pmatrix}\n$$\n现在我们计算 $\\mathbf{R}$：\n$$\n\\mathbf{R} = \\mathbf{F}\\mathbf{U}^{-1} = \\begin{pmatrix} 1   \\gamma \\\\ 0   1 \\end{pmatrix} \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}   -\\gamma \\\\ -\\gamma   2 \\end{pmatrix}\n$$\n$$\n\\mathbf{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} (1)(2+\\gamma^{2})+(\\gamma)(-\\gamma)   (1)(-\\gamma)+(\\gamma)(2) \\\\ (0)(2+\\gamma^{2})+(1)(-\\gamma)   (0)(-\\gamma)+(1)(2) \\end{pmatrix}\n$$\n$$\n\\mathbf{R} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2+\\gamma^{2}-\\gamma^{2}   -\\gamma+2\\gamma \\\\ -\\gamma   2 \\end{pmatrix} = \\frac{1}{\\sqrt{4+\\gamma^{2}}} \\begin{pmatrix} 2   \\gamma \\\\ -\\gamma   2 \\end{pmatrix}\n$$\n这就是真正交旋转张量 $\\mathbf{R}$ 的显式表达式。\n一个绕原点逆时针旋转角度 $\\phi$ 的通用二维旋转由以下矩阵表示：\n$$\n\\mathbf{R}(\\phi) = \\begin{pmatrix} \\cos\\phi   -\\sin\\phi \\\\ \\sin\\phi   \\cos\\phi \\end{pmatrix}\n$$\n通过将我们计算出的 $\\mathbf{R}$ 的分量与此标准形式进行比较，我们可以确定 $\\phi$：\n$$\n\\cos\\phi = \\frac{2}{\\sqrt{4+\\gamma^{2}}}\n$$\n$$\n\\sin\\phi = \\frac{-\\gamma}{\\sqrt{4+\\gamma^{2}}}\n$$\n为了求出 $\\phi$，我们可以计算其正切值：\n$$\n\\tan\\phi = \\frac{\\sin\\phi}{\\cos\\phi} = \\frac{-\\gamma/\\sqrt{4+\\gamma^{2}}}{2/\\sqrt{4+\\gamma^{2}}} = -\\frac{\\gamma}{2}\n$$\n这就给出了作为剪切参数 $\\gamma$ 函数的转角 $\\phi$：\n$$\n\\phi(\\gamma) = \\arctan\\left(-\\frac{\\gamma}{2}\\right)\n$$\n利用性质 $\\arctan(-x) = -\\arctan(x)$，我们可以将其写为：\n$$\n\\phi(\\gamma) = -\\arctan\\left(\\frac{\\gamma}{2}\\right)\n$$\n我们必须根据给定的物理约束条件来验证此解，即 $\\phi(\\gamma)$ 是连续的且满足 $\\phi(0) = 0$。函数 $\\phi(\\gamma) = -\\arctan(\\gamma/2)$ 对所有 $\\gamma \\in \\mathbb{R}$ 都是连续的。在 $\\gamma=0$ 时，我们有 $\\phi(0) = -\\arctan(0) = 0$。该条件得到满足。因此，该表达式代表了具有物理意义的转角。负号表示对于一个正的剪切 $\\gamma  0$，所引起的刚体旋转是顺时针的。", "answer": "$$\\boxed{-\\arctan\\left(\\frac{\\gamma}{2}\\right)}$$", "id": "2573030"}, {"introduction": "从静态分析到动态仿真是理论走向应用的关键一步。在计算力学中，旋转通常是在大量时间步上进行增量更新的。这个编程练习将要求你实现并比较两种常用的旋转累积方法：一种基于旋转矩阵，另一种基于四元数。通过这个实践，你将直接体会到数值稳定性的重要性，并理解为何带有归一化步骤的四元数方法在稳健的仿真中更受青睐。[@problem_id:2573012]", "problem": "实现一个程序，比较三维大位移大转动运动学中的两种旋转更新方案。这两种方案是：(i) 采用每步重归一化的单位四元数复合更新，以及 (ii) 使用每步旋转矢量的矩阵指数进行旋转矩阵更新，在累积过程中不进行任何重正交化。目的是评估这两种方案在多次增量更新后的数值稳定性和精度。\n\n您必须从以下基本依据出发：\n- 刚性旋转运动学由一个正常正交矩阵 $R \\in \\mathrm{SO}(3)$ 表示，满足 $R^{\\mathsf{T}} R = I$ 和 $\\det(R) = 1$。\n- 一个小的增量旋转可以用一个旋转矢量 $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ 表示，其范数是旋转角度（以弧度为单位），其方向是旋转轴。\n- 斜对称矩阵 $[\\boldsymbol{\\varphi}]_{\\times}$ 的矩阵指数将旋转矢量 $\\boldsymbol{\\varphi}$ 映射到 $R = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)$。\n- 一个单位范数的单位四元数 $q \\in \\mathbb{R}^4$ 表示 $\\mathrm{SO}(3)$ 中的一个旋转，四元数乘法用于复合旋转；对 $q$ 进行归一化可维持其单位长度。\n\n任务要求：\n1. 实现一个函数，给定一个以弧度为单位的每步旋转矢量 $\\boldsymbol{\\varphi}_k$，构造相关的单位四元数增量，并将其与当前四元数复合。每次复合后，对四元数进行重归一化。使用单位四元数进行初始化。最后，将四元数转换为旋转矩阵 $R_{\\mathrm{quat}}$。\n2. 实现一个函数，给定相同的每步旋转矢量 $\\boldsymbol{\\varphi}_k$，使用矩阵指数 $\\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$ 构造相应的增量旋转矩阵（对小角度使用数值稳定的公式），并将其左乘到当前旋转矩阵上，不进行任何重正交化。使用单位矩阵进行初始化。最后，将累积的矩阵表示为 $R_{\\mathrm{mat}}$。\n3. 对于下面指定的每个测试用例，计算以下定量诊断指标：\n   - 每种方法的正交性误差：$e_{\\mathrm{orth}}(R) = \\left\\|R^{\\mathsf{T}} R - I\\right\\|_F$。\n   - 每种方法的行列式偏差：$e_{\\det}(R) = \\left|\\det(R) - 1\\right|$。\n   - 相对于参考旋转矩阵 $R_{\\mathrm{ref}}$ 的旋转角误差：$e_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\dfrac{\\mathrm{tr}\\left(R^{\\mathsf{T}} R_{\\mathrm{ref}}\\right) - 1}{2}, -1, 1\\right)\\right)$，以弧度表示。\n4. 参考旋转 $R_{\\mathrm{ref}}$：\n   - 对于每步旋转矢量为常数的测试用例，精确的参考值为 $R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$，因为当增量旋转矢量为常数时，指数函数是可交换的。这里，$N$ 是步数。\n   - 对于每步旋转矢量随步数变化的测试用例，将 $R_{\\mathrm{ref}}$ 定义为精确乘积 $\\prod_{k=1}^{N} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$（在有限精度下计算）通过极分解（使用奇异值分解）到 $\\mathrm{SO}(3)$ 上的正交投影。这定义了一个没有步内重正交化的稳定参考。\n\n角度单位要求：\n- 所有角度和旋转矢量必须以弧度处理。所有报告的角度误差必须以弧度表示。\n\n测试套件：\n使用以下四个测试用例。对于每个用例，每步旋转矢量以弧度给出，$N$ 是步数。\n- 测试 $1$（恒定增量，多轴）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.001,\\,-0.002,\\,0.0015\\,]$, $N = 10000$。\n  - 参考：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n- 测试 $2$（恒定增量，单轴，中等步长）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,0.01,\\,0.0,\\,0.0\\,]$, $N = 3000$。\n  - 参考：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n- 测试 $3$（时变增量，非对易累积）：\n  - 对于 $k = 0,1,\\dots,N-1$，$N=8000$，定义 $\\boldsymbol{\\varphi}_k = s \\,[\\,\\cos(\\alpha k),\\, \\sin(\\alpha k),\\, 0.5\\,]$，其中 $s = 0.002$ 且 $\\alpha = 0.005$。\n  - 参考：令 $\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right)$，并将 $R_{\\mathrm{ref}}$ 定义为 $\\widehat{R}$ 经极分解得到的最接近的旋转。\n- 测试 $4$（近零增量，极端小角度鲁棒性）：\n  - $\\boldsymbol{\\varphi}_{\\text{step}} = [\\,10^{-12},\\, -2\\times 10^{-12},\\, 3\\times 10^{-12}\\,]$, $N = 1000$。\n  - 参考：$R_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right)$。\n\n您的程序必须：\n- 为四元数增量和矩阵指数实现数值稳定的小角度公式，以避免当 $\\|\\boldsymbol{\\varphi}\\| \\to 0$ 时出现除以零的情况。\n- 为每个测试用例按以下顺序生成六个浮点数诊断结果：\n  1. $e_{\\mathrm{orth}}(R_{\\mathrm{quat}})$\n  2. $e_{\\mathrm{orth}}(R_{\\mathrm{mat}})$\n  3. $e_{\\det}(R_{\\mathrm{quat}})$\n  4. $e_{\\det}(R_{\\mathrm{mat}})$\n  5. $e_{\\angle}(R_{\\mathrm{quat}}, R_{\\mathrm{ref}})$（以弧度为单位）\n  6. $e_{\\angle}(R_{\\mathrm{mat}}, R_{\\mathrm{ref}})$（以弧度为单位）\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含所有四个测试用例的串联结果，形式为用方括号括起来的逗号分隔列表。该列表必须按每个测试用例指定的顺序以及测试 $1$ 到 $4$ 的顺序包含 $24$ 个浮点数（例如，$[r_1,r_2,\\dots,r_{24}]$）。不得打印任何额外文本。", "solution": "我们基于刚体旋转运动学以及斜对称矩阵李代数与旋转矩阵李群之间的指数映射来构建。一个旋转矩阵 $R \\in \\mathrm{SO}(3)$ 满足 $R^{\\mathsf{T}}R = I$ 和 $\\det(R) = 1$。一个旋转矢量 $\\boldsymbol{\\varphi} \\in \\mathbb{R}^3$ 编码了一个绕单位轴 $\\mathbf{u} = \\boldsymbol{\\varphi}/\\theta$ 旋转角度为 $\\theta = \\|\\boldsymbol{\\varphi}\\|$ 的旋转（当 $\\theta \\neq 0$ 时）。相关的斜对称矩阵是 $[\\boldsymbol{\\varphi}]_{\\times}$，对于 $\\boldsymbol{\\varphi} = [\\varphi_1,\\varphi_2,\\varphi_3]^{\\mathsf{T}}$ 定义为\n$$\n[\\boldsymbol{\\varphi}]_{\\times} =\n\\begin{bmatrix}\n0   -\\varphi_3   \\varphi_2\\\\\n\\varphi_3   0   -\\varphi_1\\\\\n-\\varphi_2   \\varphi_1   0\n\\end{bmatrix}.\n$$\n矩阵指数通过以下方式为每步旋转矢量 $\\boldsymbol{\\varphi}$ 提供更新：\n$$\nR_{\\mathrm{inc}} = \\exp\\left([\\boldsymbol{\\varphi}]_{\\times}\\right)\n= I + \\frac{\\sin \\theta}{\\theta}[\\boldsymbol{\\varphi}]_{\\times}\n+ \\frac{1 - \\cos \\theta}{\\theta^2}[\\boldsymbol{\\varphi}]_{\\times}^2,\n$$\n其中 $I$ 是单位矩阵，$\\theta = \\|\\boldsymbol{\\varphi}\\|$。此表示源于 Rodrigues 旋转公式。对于小 $\\theta$，我们使用级数展开以避免除以零：\n$$\n\\frac{\\sin \\theta}{\\theta} = 1 - \\frac{\\theta^2}{6} + \\frac{\\theta^4}{120} + \\mathcal{O}(\\theta^6), \\quad\n\\frac{1 - \\cos \\theta}{\\theta^2} = \\frac{1}{2} - \\frac{\\theta^2}{24} + \\frac{\\theta^4}{720} + \\mathcal{O}(\\theta^6).\n$$\n不进行重正交化的基于矩阵的累积为\n$$\nR_{k+1}^{\\mathrm{mat}} = R_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\, R_k^{\\mathrm{mat}}, \\quad R_0^{\\mathrm{mat}} = I.\n$$\n由于浮点误差，重复乘法可能导致偏离 $\\mathrm{SO}(3)$，造成 $R^{\\mathsf{T}}R \\neq I$ 和 $\\det(R) \\neq 1$。\n\n或者，一个单位四元数 $q = [q_0,q_1,q_2,q_3]^{\\mathsf{T}}$ 表示相同的旋转，并带有约束 $\\|q\\|=1$，通过一个光滑同态映射到一个旋转矩阵。与旋转矢量 $\\boldsymbol{\\varphi}$ 相关的四元数增量是\n$$\nq_{\\mathrm{inc}} = \\begin{bmatrix}\n\\cos(\\theta/2)\\\\\n\\mathbf{u} \\, \\sin(\\theta/2)\n\\end{bmatrix}, \\quad \\theta = \\|\\boldsymbol{\\varphi}\\|, \\ \\mathbf{u} = \n\\begin{cases}\n\\boldsymbol{\\varphi}/\\theta,   \\theta \\neq 0,\\\\\n[0,0,0]^{\\mathsf{T}},   \\theta = 0,\n\\end{cases}\n$$\n并进行小角度稳定化处理\n$$\n\\frac{\\sin(\\theta/2)}{\\theta} = \\frac{1}{2} - \\frac{\\theta^2}{48} + \\frac{\\theta^4}{3840} + \\mathcal{O}(\\theta^6).\n$$\n旋转的四元数复合对应于四元数乘法 $\\otimes$。累积过程如下\n$$\nq_{k+1} = q_{\\mathrm{inc}}(\\boldsymbol{\\varphi}_k) \\otimes q_k, \\quad q_0 = [1,0,0,0]^{\\mathsf{T}},\n$$\n并进行显式归一化\n$$\nq_{k+1} \\leftarrow \\frac{q_{k+1}}{\\|q_{k+1}\\|},\n$$\n以减轻浮点漂移。最终的旋转矩阵是 $R_{\\mathrm{quat}} = \\mathcal{R}(q_N)$，其中 $\\mathcal{R}(\\cdot)$ 是四元数到旋转矩阵的映射，当 $q$ 是单位长度时，该映射保持正交性。\n\n为了验证和稳定性评估，我们为任何 $3\\times 3$ 矩阵 $R$ 定义以下诊断指标：\n- 正交性误差 $e_{\\mathrm{orth}}(R) = \\|R^{\\mathsf{T}}R - I\\|_F$（弗罗贝尼乌斯范数）。\n- 行列式偏差 $e_{\\det}(R) = |\\det(R) - 1|$。\n- 相对于参考 $R_{\\mathrm{ref}}$ 的旋转角误差：\n$$\ne_{\\angle}(R, R_{\\mathrm{ref}}) = \\arccos\\!\\left(\\mathrm{clip}\\left(\\frac{\\operatorname{tr}(R^{\\mathsf{T}} R_{\\mathrm{ref}}) - 1}{2}, \\,-1,\\, 1\\right)\\right),\n$$\n这给出了相对旋转 $\\Delta R = R^{\\mathsf{T}} R_{\\mathrm{ref}}$ 的主角（以弧度为单位）。裁剪操作确保了对舍入误差的数值鲁棒性，以防其违反反余弦函数的定义域。\n\n对于恒定的每步增量 $\\boldsymbol{\\varphi}_{\\text{step}}$，精确的参考值为\n$$\nR_{\\mathrm{ref}} = \\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times} \\, N\\right),\n$$\n因为 $[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}$ 与自身可交换，因此 $\\left(\\exp\\left([\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)\\right)^N = \\exp\\left(N \\,[\\boldsymbol{\\varphi}_{\\text{step}}]_{\\times}\\right)$。对于时变增量 $\\boldsymbol{\\varphi}_k$，非对易性使得无法得到闭式解。因此，我们计算乘积\n$$\n\\widehat{R} = \\prod_{k=0}^{N-1} \\exp\\left([\\boldsymbol{\\varphi}_k]_{\\times}\\right),\n$$\n并通过极分解将其投影到 $\\mathrm{SO}(3)$ 上。设 $\\widehat{R} = U \\Sigma V^{\\mathsf{T}}$ 为奇异值分解，则最接近的旋转（在弗罗贝尼乌斯范数意义下）是\n$$\nR_{\\mathrm{ref}} = U \\, \\operatorname{diag}(1,1,\\operatorname{sign}(\\det(UV^{\\mathsf{T}}))) \\, V^{\\mathsf{T}}.\n$$\n\n算法设计：\n1. 实现一个鲁棒的函数，使用 $\\sin\\theta/\\theta$ 和 $(1-\\cos\\theta)/\\theta^2$ 对小 $\\theta$ 的级数展开，将 $\\boldsymbol{\\varphi}$ 映射到 $R_{\\mathrm{inc}}$。\n2. 实现四元数增量映射，对小 $\\theta$ 使用 $\\sin(\\theta/2)/\\theta$ 的鲁棒评估，并通过四元数乘法进行复合，每步之后进行归一化。\n3. 对每个测试用例模拟两种累积方法，以获得 $R_{\\mathrm{quat}}$ 和 $R_{\\mathrm{mat}}$。\n4. 构建参考 $R_{\\mathrm{ref}}$：\n   - 对于恒定情况：作为在 $N \\boldsymbol{\\varphi}_{\\text{step}}$ 处的单个指数。\n   - 对于变化情况：作为指数直接乘积的极因子。\n5. 为 $R_{\\mathrm{quat}}$ 和 $R_{\\mathrm{mat}}$ 计算诊断指标 $e_{\\mathrm{orth}}$、$e_{\\det}$ 和 $e_{\\angle}$。\n6. 按指定顺序输出 $24$ 个浮点数结果：\n   - 对于每个测试 $i \\in \\{1,2,3,4\\}$，输出\n     $[\\,e_{\\mathrm{orth}}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\mathrm{orth}}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{quat}}^{(i)}),\\ e_{\\det}(R_{\\mathrm{mat}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{quat}}^{(i)}, R_{\\mathrm{ref}}^{(i)}),\\ e_{\\angle}(R_{\\mathrm{mat}}^{(i)}, R_{\\mathrm{ref}}^{(i)})\\,]$。\n   将四个子列表连接成一个单一列表，并作为单行打印。\n\n预期定性结果：\n- 带有每步归一化的四元数方法应在所有测试中保持 $e_{\\mathrm{orth}}$ 和 $e_{\\det}$ 接近机器精度，展示出高数值稳定性。\n- 不进行重正交化的矩阵指数累积预计会随着步数的增加而显示出增大的 $e_{\\mathrm{orth}}$ 和 $e_{\\det}$，表明其偏离了 $\\mathrm{SO}(3)$。\n- 四元数方法的角度误差 $e_{\\angle}$ 在所有测试中通常应小于或可比于矩阵方法；当步数很多或接近奇异配置（如长序列或极小角度，此时稳定的级数展开至关重要）时，差异会变得更加明显。\n\n所有角度必须以弧度表示。除角度单位外，不涉及任何物理单位。程序必须精确打印一行：一个包含指定格式的 $24$ 个浮点数的单一列表，无额外文本。", "answer": "```python\nimport numpy as np\n\ndef skew(v):\n    \"\"\"Return the 3x3 skew-symmetric matrix of a 3-vector v.\"\"\"\n    vx, vy, vz = v\n    return np.array([[0.0, -vz,  vy],\n                     [vz,  0.0, -vx],\n                     [-vy, vx,  0.0]], dtype=float)\n\ndef safe_sinc(x):\n    \"\"\"Return sin(x)/x with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax  1e-8:\n        x2 = x*x\n        # 1 - x^2/6 + x^4/120\n        return 1.0 - x2/6.0 + x2*x2/120.0\n    return np.sin(x)/x\n\ndef safe_one_minus_cos_over_x2(x):\n    \"\"\"Return (1-cos(x))/x^2 with a stable series near x=0.\"\"\"\n    ax = abs(x)\n    if ax  1e-8:\n        x2 = x*x\n        # 1/2 - x^2/24 + x^4/720\n        return 0.5 - x2/24.0 + x2*x2/720.0\n    return (1.0 - np.cos(x))/(x*x)\n\ndef exp_rotvec(phi):\n    \"\"\"\n    Compute rotation matrix R = exp([phi]_x) using Rodrigues' formula with\n    stable small-angle handling.\n    \"\"\"\n    theta = np.linalg.norm(phi)\n    A = skew(phi)\n    if theta  1e-16:\n        # Very small, R ~ I + A\n        return np.eye(3) + A\n    a = safe_sinc(theta)\n    b = safe_one_minus_cos_over_x2(theta)\n    return np.eye(3) + a * A + b * (A @ A)\n\ndef quat_mul(p, q):\n    \"\"\"Hamilton product p ⊗ q for quaternions p=[w,x,y,z], q=[w,x,y,z].\"\"\"\n    pw, px, py, pz = p\n    qw, qx, qy, qz = q\n    w = pw*qw - px*qx - py*qy - pz*qz\n    x = pw*qx + px*qw + py*qz - pz*qy\n    y = pw*qy - px*qz + py*qw + pz*qx\n    z = pw*qz + px*qy - py*qx + pz*qw\n    return np.array([w, x, y, z], dtype=float)\n\ndef quat_normalize(q):\n    n = np.linalg.norm(q)\n    if n == 0.0:\n        return np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    return q / n\n\ndef rotvec_to_quat(phi):\n    \"\"\"Map rotation vector phi to unit quaternion q = [w, x, y, z].\"\"\"\n    theta = np.linalg.norm(phi)\n    if theta  1e-16:\n        # q ≈ [1, 0.5*phi]\n        return quat_normalize(np.array([1.0, 0.5*phi[0], 0.5*phi[1], 0.5*phi[2]], dtype=float))\n    half = 0.5 * theta\n    # sin(half)/theta stabilized\n    s = np.sin(half)\n    c = np.cos(half)\n    scale = s / theta\n    q = np.array([c, scale*phi[0], scale*phi[1], scale*phi[2]], dtype=float)\n    return quat_normalize(q)\n\ndef quat_to_R(q):\n    \"\"\"Convert unit quaternion q=[w,x,y,z] to rotation matrix.\"\"\"\n    w, x, y, z = q\n    # Normalize to avoid drift\n    n = w*w + x*x + y*y + z*z\n    if n == 0.0:\n        w, x, y, z = 1.0, 0.0, 0.0, 0.0\n        n = 1.0\n    s = 2.0 / n\n    wx, wy, wz = s*w*x, s*w*y, s*w*z\n    xx, xy, xz = s*x*x, s*x*y, s*x*z\n    yy, yz, zz = s*y*y, s*y*z, s*z*z\n    R = np.array([\n        [1.0 - (yy + zz), xy - wz,       xz + wy      ],\n        [xy + wz,         1.0 - (xx + zz), yz - wx     ],\n        [xz - wy,         yz + wx,       1.0 - (xx + yy)]\n    ], dtype=float)\n    return R\n\ndef orthogonality_error(R):\n    E = R.T @ R - np.eye(3)\n    return float(np.linalg.norm(E, ord='fro'))\n\ndef det_deviation(R):\n    return float(abs(np.linalg.det(R) - 1.0))\n\ndef angle_error(R, Rref):\n    RtR = R.T @ Rref\n    tr = (np.trace(RtR) - 1.0) / 2.0\n    tr = max(-1.0, min(1.0, tr))\n    return float(np.arccos(tr))\n\ndef project_to_SO3(R):\n    \"\"\"Project a matrix to the nearest rotation matrix via SVD-based polar decomposition.\"\"\"\n    U, S, Vt = np.linalg.svd(R)\n    M = U @ Vt\n    if np.linalg.det(M)  0.0:\n        # Fix reflection\n        D = np.diag([1.0, 1.0, -1.0])\n        M = U @ D @ Vt\n    return M\n\ndef accumulate_quaternion(increments):\n    q = np.array([1.0, 0.0, 0.0, 0.0], dtype=float)\n    for phi in increments:\n        q_inc = rotvec_to_quat(phi)\n        q = quat_mul(q_inc, q)\n        q = quat_normalize(q)\n    return quat_to_R(q)\n\ndef accumulate_matrix(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return R\n\ndef reference_constant(phi_step, N):\n    phi_tot = phi_step * N\n    return exp_rotvec(phi_tot)\n\ndef reference_varying(increments):\n    R = np.eye(3)\n    for phi in increments:\n        R = exp_rotvec(phi) @ R\n    return project_to_SO3(R)\n\ndef build_test_cases():\n    tests = []\n\n    # Test 1: constant increments, multi-axis\n    phi_step1 = np.array([0.001, -0.002, 0.0015], dtype=float)\n    N1 = 10000\n    inc1 = [phi_step1 for _ in range(N1)]\n    Rref1 = reference_constant(phi_step1, N1)\n    tests.append((inc1, Rref1))\n\n    # Test 2: constant increments, single-axis\n    phi_step2 = np.array([0.01, 0.0, 0.0], dtype=float)\n    N2 = 3000\n    inc2 = [phi_step2 for _ in range(N2)]\n    Rref2 = reference_constant(phi_step2, N2)\n    tests.append((inc2, Rref2))\n\n    # Test 3: varying increments\n    N3 = 8000\n    s = 0.002\n    alpha = 0.005\n    inc3 = []\n    for k in range(N3):\n        vk = np.array([np.cos(alpha * k), np.sin(alpha * k), 0.5], dtype=float)\n        inc3.append(s * vk)\n    Rref3 = reference_varying(inc3)\n    tests.append((inc3, Rref3))\n\n    # Test 4: near-zero increments\n    phi_step4 = np.array([1e-12, -2e-12, 3e-12], dtype=float)\n    N4 = 1000\n    inc4 = [phi_step4 for _ in range(N4)]\n    Rref4 = reference_constant(phi_step4, N4)\n    tests.append((inc4, Rref4))\n\n    return tests\n\ndef solve():\n    tests = build_test_cases()\n    results = []\n    for increments, Rref in tests:\n        Rq = accumulate_quaternion(increments)\n        Rm = accumulate_matrix(increments)\n\n        e_orth_q = orthogonality_error(Rq)\n        e_orth_m = orthogonality_error(Rm)\n        e_det_q = det_deviation(Rq)\n        e_det_m = det_deviation(Rm)\n        e_ang_q = angle_error(Rq, Rref)\n        e_ang_m = angle_error(Rm, Rref)\n\n        results.extend([e_orth_q, e_orth_m, e_det_q, e_det_m, e_ang_q, e_ang_m])\n\n    # Print as a single line list, comma-separated, no spaces\n    # Format floats with scientific notation for consistency\n    formatted = \",\".join(f\"{x:.12e}\" for x in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2573012"}]}