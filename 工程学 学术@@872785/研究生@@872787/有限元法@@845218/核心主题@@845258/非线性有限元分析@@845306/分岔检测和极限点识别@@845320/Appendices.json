{"hands_on_practices": [{"introduction": "为了掌握分岔分析的核心数学原理，我们首先从一个简单的双自由度离散系统入手。这个练习旨在揭示一个基本事实：系统的平衡路径在切线刚度矩阵 $K_T$ 奇异时发生分岔。通过从一个给定的势能函数出发，您将亲手推导出残差向量和切线刚度矩阵，并确定导致系统失稳的临界载荷参数 [@problem_id:2542980]。", "problem": "考虑一个无量纲的两自由度有限元 (FE) 离散化，其节点位移向量为 $u = \\begin{pmatrix} u_{1}  u_{2} \\end{pmatrix}^{\\mathsf{T}}$，标量载荷参数为 $\\lambda$。设该系统由总势能定义\n$$\n\\Pi(u,\\lambda) \\;=\\; \\frac{1}{2}\\,k\\,(u_{1}^{2}+u_{2}^{2}) \\;+\\; \\frac{c}{2}\\,(u_{1}-u_{2})^{2} \\;+\\; \\frac{\\gamma}{4}\\,(u_{1}^{4}+u_{2}^{4}) \\;-\\; \\frac{\\lambda}{2}\\,g\\,(u_{1}^{2}+u_{2}^{2}),\n$$\n其中 $k>0$、$c>0$、$g>0$ 和 $\\gamma \\ge 0$ 是常数。该能量模型模拟了一对具有线性耦合和载荷相关几何软化项的对称非线性弹簧。\n\n利用平衡状态下的总势能驻值条件，构建作为 $\\Pi(u,\\lambda)$ 关于 $u$ 的梯度的有限元残差向量 $R(u,\\lambda)$，并计算作为 Jacobian 矩阵 $\\partial R/\\partial u$ 的一致切线刚度矩阵 $K_{T}(u,\\lambda)$。然后将 $K_{T}(u,\\lambda)$ 特殊化到平凡平衡路径 $u=\\begin{pmatrix} 0  0 \\end{pmatrix}^{\\mathsf{T}}$ 上，并确定使 $\\det K_{T}(0,\\lambda)=0$ 成立的所有参数值 $\\lambda$。\n\n答案规格：\n- 将最终答案以包含两个临界参数值 $\\lambda$ 的单行矩阵形式给出。\n- 无需进行数值取整；请给出精确表达式。\n- 所有量均为无量纲，因此不需要单位。", "solution": "该问题经验证在科学上是成立的、适定的、客观且完整的。这是关于分岔点检测的非线性有限元分析中的一个标准练习。我们开始求解。\n\n系统的总势能由下式给出：\n$$\n\\Pi(u,\\lambda) = \\frac{1}{2} k (u_{1}^{2}+u_{2}^{2}) + \\frac{c}{2} (u_{1}-u_{2})^{2} + \\frac{\\gamma}{4} (u_{1}^{4}+u_{2}^{4}) - \\frac{\\lambda}{2} g (u_{1}^{2}+u_{2}^{2})\n$$\n其中 $u = \\begin{pmatrix} u_{1}  u_{2} \\end{pmatrix}^{\\mathsf{T}}$ 是节点位移向量，$\\lambda$ 是载荷参数，$k, c, g, \\gamma$ 是常数，且满足 $k>0$、$c>0$、$g>0$ 和 $\\gamma \\ge 0$。\n\n平衡条件是势能的驻值条件，即 $\\delta \\Pi = 0$。这要求 $\\Pi$ 相对于位移向量 $u$ 的梯度为零。该梯度即为残差向量 $R(u, \\lambda)$。\n$$\nR(u, \\lambda) = \\nabla_{u} \\Pi(u, \\lambda) = \\begin{pmatrix} \\frac{\\partial \\Pi}{\\partial u_{1}} \\\\ \\frac{\\partial \\Pi}{\\partial u_{2}} \\end{pmatrix}\n$$\n我们计算偏导数：\n$$\n\\frac{\\partial \\Pi}{\\partial u_{1}} = k u_{1} + c(u_{1}-u_{2}) + \\gamma u_{1}^{3} - \\lambda g u_{1} = (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3}\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial u_{2}} = k u_{2} + c(u_{1}-u_{2})(-1) + \\gamma u_{2}^{3} - \\lambda g u_{2} = -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3}\n$$\n因此，残差向量为：\n$$\nR(u, \\lambda) = \\begin{pmatrix} (k+c-\\lambda g)u_{1} - c u_{2} + \\gamma u_{1}^{3} \\\\ -c u_{1} + (k+c-\\lambda g)u_{2} + \\gamma u_{2}^{3} \\end{pmatrix}\n$$\n接下来，我们计算一致切线刚度矩阵 $K_{T}(u, \\lambda)$，它是残差向量 $R$ 关于位移向量 $u$ 的 Jacobian 矩阵。\n$$\nK_{T}(u, \\lambda) = \\frac{\\partial R}{\\partial u} = \\begin{pmatrix} \\frac{\\partial R_{1}}{\\partial u_{1}}  \\frac{\\partial R_{1}}{\\partial u_{2}} \\\\ \\frac{\\partial R_{2}}{\\partial u_{1}}  \\frac{\\partial R_{2}}{\\partial u_{2}} \\end{pmatrix}\n$$\n切线刚度矩阵的分量为：\n$$\n\\frac{\\partial R_{1}}{\\partial u_{1}} = k+c-\\lambda g + 3\\gamma u_{1}^{2}\n$$\n$$\n\\frac{\\partial R_{1}}{\\partial u_{2}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{1}} = -c\n$$\n$$\n\\frac{\\partial R_{2}}{\\partial u_{2}} = k+c-\\lambda g + 3\\gamma u_{2}^{2}\n$$\n这给出了切线刚度矩阵：\n$$\nK_{T}(u, \\lambda) = \\begin{pmatrix} k+c-\\lambda g + 3\\gamma u_{1}^{2}  -c \\\\ -c  k+c-\\lambda g + 3\\gamma u_{2}^{2} \\end{pmatrix}\n$$\n问题要求我们分析平凡平衡路径上的稳定性，该路径由 $u = \\begin{pmatrix} 0  0 \\end{pmatrix}^{\\mathsf{T}}$ 定义。我们将 $u_{1}=0$ 和 $u_{2}=0$ 代入残差向量，得到 $R(0, \\lambda) = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，这对任意 $\\lambda$ 都成立，从而验证这确实是一条平衡路径。\n\n现在我们将切线刚度矩阵 $K_{T}$ 特殊化到这条平凡路径上，即令 $u_{1}=0$ 和 $u_{2}=0$：\n$$\nK_{T}(0, \\lambda) = \\begin{pmatrix} k+c-\\lambda g  -c \\\\ -c  k+c-\\lambda g \\end{pmatrix}\n$$\n平凡路径上的分岔点（临界点）发生在切线刚度矩阵变为奇异时。该条件在数学上表示为 $\\det K_{T}(0, \\lambda)=0$。\n我们计算其行列式：\n$$\n\\det K_{T}(0, \\lambda) = (k+c-\\lambda g)(k+c-\\lambda g) - (-c)(-c) = (k+c-\\lambda g)^{2} - c^{2}\n$$\n令行列式为零，得到关于 $\\lambda$ 临界值的方程：\n$$\n(k+c-\\lambda g)^{2} - c^{2} = 0\n$$\n这是一个平方差，可因式分解为：\n$$\n\\left[ (k+c-\\lambda g) - c \\right] \\left[ (k+c-\\lambda g) + c \\right] = 0\n$$\n如果任一因子为零，则该方程成立。\n\n情况1：\n$$\n(k+c-\\lambda g) - c = 0 \\implies k - \\lambda g = 0 \\implies \\lambda g = k\n$$\n这给出了第一个临界值：\n$$\n\\lambda_{1} = \\frac{k}{g}\n$$\n情况2：\n$$\n(k+c-\\lambda g) + c = 0 \\implies k+2c - \\lambda g = 0 \\implies \\lambda g = k+2c\n$$\n这给出了第二个临界值：\n$$\n\\lambda_{2} = \\frac{k+2c}{g}\n$$\n由于题目说明 $k>0$，$c>0$ 和 $g>0$，两个临界值 $\\lambda_{1}$ 和 $\\lambda_{2}$ 均为正且不相等。这些就是平凡平衡路径失去稳定性时的参数值。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{k}{g}  \\frac{k+2c}{g} \\end{pmatrix}}\n$$", "id": "2542980"}, {"introduction": "有限元分析中使用的刚度矩阵并非凭空而来。本练习将引导您从第一性原理出发，为经典的欧拉-伯努利梁单元推导其弹性刚度矩阵和几何刚度矩阵。通过求解仅含一个单元的简化模型的特征值问题，您将能够计算出其屈曲荷载，并将其与精确解进行比较，从而深刻理解有限元方法中离散化误差的来源 [@problem_id:2543000]。", "problem": "一根长度为 $L$、抗弯刚度为 $EI$ 的均匀、等截面欧拉-伯努利梁，在其形心轴上受到恒定端部力 $N$ 的轴向压缩。假设小应变和小转动，并忽略剪切变形。梁两端简支，模型为 $w(0)=0$，$w(L)=0$，且端部转动自由。将屈曲的检测视为平衡态的分岔，其特征是总势能二阶变分的正定性丧失，等效于切线刚度的最小特征值消失。\n\n使用有限元法（FEM），采用单个两节点欧拉-伯努利梁单元，对横向位移 $w(x)$ 进行 Hermite 三次插值，节点自由度（DOFs）在 $x=0$ 处为 $w_{1}$、$\\theta_{1}$，在 $x=L$ 处为 $w_{2}$、$\\theta_{2}$，从第一性原理出发，按以下步骤进行：\n- 从虚功原理和由 $N$ 引起的几何非线性问题的线性化出发，根据 Hermite 形函数推导协调单元的弯曲刚度和几何（初始应力）刚度。\n- 组装单元切线刚度，通过约束 $w_{1}=0$ 和 $w_{2}=0$ 同时保持 $\\theta_{1}$ 和 $\\theta_{2}$ 自由来施加简支边界条件，并写出所得的针对转动自由度的降阶广义特征值问题。\n- 求解此降阶问题，以获得预测分岔的最低临界载荷 $N_{\\mathrm{cr}}^{\\mathrm{FE}}$。\n\n设简支梁的解析欧拉屈曲载荷为 $N_{\\mathrm{cr}}^{\\mathrm{exact}}=\\pi^{2} EI / L^{2}$。作为最终答案，请报告单一的无量纲比值\n$$\nr \\;=\\; \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}}.\n$$\n请用精确的闭式解析表达式表示您的最终结果。不要四舍五入或近似计算。", "solution": "该问题陈述具有科学依据，提法恰当且客观。它提出了一个计算结构力学中的标准问题，特别是弹性屈曲的有限元分析。所有需要的数据和条件都已提供，没有矛盾或谬误。该问题是有效的。我们按照要求从第一性原理开始求解。\n\n分析基于承受轴向压力 $N$ 的欧拉-伯努利梁的线性化虚功原理。切线刚度矩阵 $\\mathbf{K}_T$ 是标准弹性（弯曲）刚度矩阵 $\\mathbf{K}_E$ 和几何（初始应力）刚度矩阵 $\\mathbf{K}_G$ 的和。当 $\\mathbf{K}_T$ 不再是正定时，发生屈曲分岔，这等效于找到使特征值问题 $(\\mathbf{K}_E - \\mathbf{K}_G(N)) \\mathbf{d} = \\mathbf{0}$ 具有非平凡解 $\\mathbf{d} \\neq \\mathbf{0}$ 的最低载荷 $N$。由于 $\\mathbf{K}_G$ 线性依赖于 $N$，我们写作 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$，问题变成一个标准的线性特征值问题 $(\\mathbf{K}_E - N_{\\mathrm{cr}} \\mathbf{K}_{G0}) \\mathbf{d} = \\mathbf{0}$，其中 $N_{\\mathrm{cr}}$ 是临界载荷。\n\n使用一个长度为 $L$ 的两节点梁单元。横向位移场 $w(x)$ 使用 Hermite 三次形函数进行插值。节点自由度（DOFs）为 $\\mathbf{d} = [w_1, \\theta_1, w_2, \\theta_2]^T$，其中 $w_1 = w(0)$，$\\theta_1 = w'(0)$，$w_2 = w(L)$ 和 $\\theta_2 = w'(L)$。位移由 $w(x) = \\mathbf{N}(x) \\mathbf{d}$ 给出，其中 $\\mathbf{N}(x) = [H_1(x), H_2(x), H_3(x), H_4(x)]$ 是形函数向量。用无量纲坐标 $\\xi = x/L$ 表示，它们是：\n$$ H_1(\\xi) = 1 - 3\\xi^2 + 2\\xi^3 $$\n$$ H_2(\\xi) = L(\\xi - 2\\xi^2 + \\xi^3) $$\n$$ H_3(\\xi) = 3\\xi^2 - 2\\xi^3 $$\n$$ H_4(\\xi) = L(-\\xi^2 + \\xi^3) $$\n\n考虑弯曲和轴向力效应的梁柱的内虚功由其线性化形式给出：\n$$ \\delta W_{\\mathrm{int}} = \\int_0^L \\delta\\epsilon_{xx} \\sigma_{xx} dA dx = \\int_0^L EI \\delta w'' w'' dx + \\int_0^L N \\delta w' w' dx $$\n其中 $w''$ 是曲率，$w'$ 是斜率。第一项产生弹性刚度矩阵 $\\mathbf{K}_E$，第二项产生几何刚度矩阵 $\\mathbf{K}_G$。\n\n弹性刚度矩阵 $\\mathbf{K}_E$ 的分量由弯曲应变能导出：\n$$ K_{E,ij} = EI \\int_0^L H_i''(x) H_j''(x) dx = EI \\int_0^1 H_i''(\\xi L) H_j''(\\xi L) L d\\xi $$\n在单元域 $[0, L]$ 上计算这些标准积分，得到矩阵：\n$$ \\mathbf{K}_E = \\frac{EI}{L^3} \\begin{pmatrix} 12  6L  -12  6L \\\\ 6L  4L^2  -6L  2L^2 \\\\ -12  -6L  12  -6L \\\\ 6L  2L^2  -6L  4L^2 \\end{pmatrix} $$\n\n几何刚度矩阵 $\\mathbf{K}_G = N \\mathbf{K}_{G0}$ 的分量由轴向力 $N$ 因构件转动所做的功导出：\n$$ K_{G,ij} = \\int_0^L N H_i'(x) H_j'(x) dx = N \\int_0^1 H_i'(\\xi L) H_j'(\\xi L) L d\\xi $$\n因此，矩阵 $\\mathbf{K}_{G0}$ 为：\n$$ K_{G0,ij} = \\int_0^L H_i'(x) H_j'(x) dx $$\n计算这些积分得到：\n$$ \\mathbf{K}_G = \\frac{N}{30L} \\begin{pmatrix} 36  3L  -36  3L \\\\ 3L  4L^2  -3L  -L^2 \\\\ -36  -3L  36  -3L \\\\ 3L  -L^2  -3L  4L^2 \\end{pmatrix} $$\n\n问题指定了简支边界条件，即 $w(0)=w_1=0$ 和 $w(L)=w_2=0$。这些约束消除了第一和第三个自由度。特征值问题被降阶到自由转动自由度 $\\theta_1$ 和 $\\theta_2$ 的子空间。我们提取 $\\mathbf{K}_E$ 和 $\\mathbf{K}_G$ 中对应于第二行、第四行和第二列、第四列的子矩阵。\n降阶后的弹性刚度矩阵 $\\mathbf{K}_{E, red}$ 是：\n$$ \\mathbf{K}_{E, red} = \\frac{EI}{L^3} \\begin{pmatrix} 4L^2  2L^2 \\\\ 2L^2  4L^2 \\end{pmatrix} = \\frac{EI}{L} \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} $$\n降阶后的几何刚度矩阵 $\\mathbf{K}_{G, red}$ 是：\n$$ \\mathbf{K}_{G, red} = \\frac{N}{30L} \\begin{pmatrix} 4L^2  -L^2 \\\\ -L^2  4L^2 \\end{pmatrix} = \\frac{NL}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} $$\n\n临界载荷 $N = N_{\\mathrm{cr}}^{\\mathrm{FE}}$ 的降阶特征值问题是：\n$$ (\\mathbf{K}_{E, red} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\mathbf{K}_{G0, red}) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n代入矩阵得到：\n$$ \\left( \\frac{EI}{L} \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} - N_{\\mathrm{cr}}^{\\mathrm{FE}} \\frac{L}{30} \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} \\right) \\begin{pmatrix} \\theta_1 \\\\ \\theta_2 \\end{pmatrix} = \\mathbf{0} $$\n为了得到非平凡解，矩阵的行列式必须为零。我们定义一个无量纲特征值 $\\lambda = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}} L^2}{30EI}$。特征方程变为：\n$$ \\det \\left( \\begin{pmatrix} 4  2 \\\\ 2  4 \\end{pmatrix} - \\lambda \\begin{pmatrix} 4  -1 \\\\ -1  4 \\end{pmatrix} \\right) = 0 $$\n$$ \\det \\begin{pmatrix} 4 - 4\\lambda  2 + \\lambda \\\\ 2 + \\lambda  4 - 4\\lambda \\end{pmatrix} = 0 $$\n$$ (4 - 4\\lambda)^2 - (2 + \\lambda)^2 = 0 $$\n这个方程可以因式分解为平方差形式：\n$$ [4(1-\\lambda) - (2+\\lambda)] [4(1-\\lambda) + (2+\\lambda)] = 0 $$\n这导致了 $\\lambda$ 的两个可能解：\n1. $4 - 4\\lambda - 2 - \\lambda = 0 \\implies 2 - 5\\lambda = 0 \\implies \\lambda_1 = \\frac{2}{5}$\n2. $4 - 4\\lambda + 2 + \\lambda = 0 \\implies 6 - 3\\lambda = 0 \\implies \\lambda_2 = 2$\n\n最低临界载荷对应于最小的特征值 $\\lambda_1$。\n$$ N_{\\mathrm{cr}}^{\\mathrm{FE}} = \\frac{30EI}{L^2} \\lambda_1 = \\frac{30EI}{L^2} \\left(\\frac{2}{5}\\right) = \\frac{12EI}{L^2} $$\n简支梁的解析欧拉屈曲载荷已知为 $N_{\\mathrm{cr}}^{\\mathrm{exact}} = \\frac{\\pi^2 EI}{L^2}$。\n\n所要求的比值 $r$ 是：\n$$ r = \\frac{N_{\\mathrm{cr}}^{\\mathrm{FE}}}{N_{\\mathrm{cr}}^{\\mathrm{exact}}} = \\frac{12EI/L^2}{\\pi^2EI/L^2} = \\frac{12}{\\pi^2} $$\n这个结果表明，由于其多项式形函数，单个有限元模型过于刚硬，高估了真实的屈曲载荷。误差约为 $21.6\\%$。需要更多的单元才能收敛到精确解。", "answer": "$$\n\\boxed{\\frac{12}{\\pi^2}}\n$$", "id": "2543000"}, {"introduction": "这项综合性练习将前面学习的概念融入一个完整的计算程序中。您将为一个对称拱形结构实现一个完整的线性化屈曲分析流程，包括从单元矩阵出发组装总体系统、求解广义特征值问题，以及运用群论的对称性原理对屈曲模态进行分类。这个实践不仅巩固了您的编程实现能力，也展示了在计算结构稳定性分析中的一个完整工作流程 [@problem_id:2542913]。", "problem": "给定一个使用欧拉-伯努利梁框架有限元法建模的对称平面圆弧。您的任务是实现一个完整、可运行的程序，该程序能够组装弹性刚度矩阵和初始应力几何刚度矩阵，计算给定压缩轴力模式下的两个最低分岔（线性屈曲）荷载因子及其振型，并通过投影到群不变子空间上，将每个振型按其相对于圆弧中跨反射的对称性分类为对称或反对称。\n\n从以下基础开始：\n\n- 线性屈曲问题源于总势能的二阶变分。在节点位移向量为 $\\mathbf{u}$ 的有限元离散化中，预应力状态下的稳定性算子是弹性刚度 $\\mathbf{K}$ 和初始应力几何刚度 $\\mathbf{K}_\\sigma$ 的和。对于一个压缩荷载大小 $P$（假设其缩放一个固定的轴力分布），离散化的线性屈曲条件是\n$$\n\\left( \\mathbf{K} - P\\,\\mathbf{K}_\\sigma \\right)\\boldsymbol{\\phi} = \\mathbf{0},\n$$\n这等价于广义特征值问题\n$$\n\\mathbf{K}\\,\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\,\\boldsymbol{\\phi}, \\quad \\lambda = P.\n$$\n- 对于一个长度为 $L$、杨氏模量为 $E$、横截面积为 $A$、截面二次矩为 $I$ 的二维欧拉-伯努利梁单元，其局部弹性刚度矩阵 $\\mathbf{k}_e^{\\text{loc}}$ 由以下经过充分检验的表达式组装而成\n$$\n\\mathbf{k}_e^{\\text{loc}} =\n\\begin{bmatrix}\n\\frac{EA}{L}  0  0  -\\frac{EA}{L}  0  0 \\\\\n0  \\frac{12EI}{L^3}  \\frac{6EI}{L^2}  0  -\\frac{12EI}{L^3}  \\frac{6EI}{L^2} \\\\\n0  \\frac{6EI}{L^2}  \\frac{4EI}{L}  0  -\\frac{6EI}{L^2}  \\frac{2EI}{L} \\\\\n-\\frac{EA}{L}  0  0  \\frac{EA}{L}  0  0 \\\\\n0  -\\frac{12EI}{L^3}  -\\frac{6EI}{L^2}  0  \\frac{12EI}{L^3}  -\\frac{6EI}{L^2} \\\\\n0  \\frac{6EI}{L^2}  \\frac{2EI}{L}  0  -\\frac{6EI}{L^2}  \\frac{4EI}{L}\n\\end{bmatrix}.\n$$\n- 对于一个沿单元承受恒定压缩轴力 $P>0$ 的欧拉-伯努利梁单元，其一致初始应力几何刚度矩阵为\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}}(P) = \\frac{P}{30L}\\begin{bmatrix}\n0  0  0  0  0  0 \\\\\n0  36  3L  0  -36  3L \\\\\n0  3L  4L^2  0  -3L  -L^2 \\\\\n0  0  0  0  0  0 \\\\\n0  -36  -3L  0  36  -3L \\\\\n0  3L  -L^2  0  -3L  4L^2\n\\end{bmatrix}.\n$$\n对于广义特征值问题，使用单位压缩力下的几何刚度\n$$\n\\mathbf{k}_\\sigma^{\\text{loc}} := \\mathbf{k}_\\sigma^{\\text{loc}}(P=1),\n$$\n这样，在方程 $\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\,\\mathbf{K}_\\sigma\\boldsymbol{\\phi}$ 中，临界荷载因子即为 $\\lambda$。\n- 使用从单元弦杆得到的标准正交方向余弦将局部单元矩阵转换到全局坐标系，组装全局矩阵，并施加边界条件以模拟铰接支座：两端节点的平动均被固定，转动自由。\n\n对称性分类要求：\n\n- 该圆弧关于其中跨垂直轴线呈反射对称。令 $\\mathcal{G}$ 表示由反射算子 $\\mathbf{R}$ 生成的2阶对称群。按如下方式构造作用于全局节点位移向量的 $\\mathbf{R}$。对于一个切向单位向量为 $\\hat{\\mathbf{t}}$、法向单位向量为 $\\hat{\\mathbf{n}}$（平面内）的节点，通过将全局分量 $(u_x,u_y,\\theta)$ 投影到 $(\\hat{\\mathbf{t}},\\hat{\\mathbf{n}},\\theta)$ 上，定义局部（当地）位移分量 $(u_t,u_n,\\theta)$。在中跨轴的反射作用下，局部（当地）分量变换为\n$$\n(u_t,u_n,\\theta) \\mapsto (-u_t,\\,u_n,\\,-\\theta),\n$$\n然后被映射回镜像节点的全局分量。对称和反对称投影算子为\n$$\n\\mathbf{P}_{\\text{sym}} = \\tfrac{1}{2}(\\mathbf{I}+\\mathbf{R}), \\quad\n\\mathbf{P}_{\\text{anti}} = \\tfrac{1}{2}(\\mathbf{I}-\\mathbf{R}).\n$$\n给定一个振型向量 $\\boldsymbol{\\phi}$，如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$，则将其分类为对称，否则为反对称。\n\n几何与离散化：\n\n- 圆弧位于半径为 $R$、总中心角为 $\\Phi$ 的圆上，节点角度在区间 $\\alpha \\in [-\\Phi/2,\\Phi/2]$ 内均匀分布，坐标为\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha).\n$$\n节点角度 $\\alpha$ 处的切向和法向单位向量为\n$$\n\\hat{\\mathbf{t}}(\\alpha) = (\\cos\\alpha,\\,-\\sin\\alpha), \\quad \\hat{\\mathbf{n}}(\\alpha) = (\\sin\\alpha,\\,\\cos\\alpha).\n$$\n使用 $n_e$ 个直线框架单元连接连续的节点。\n\n数值步骤与约束：\n\n- 在全局坐标系中，根据单元贡献组装 $\\mathbf{K}$ 和 $\\mathbf{K}_\\sigma$。\n- 通过消除两端节点的平动自由度 $u_x$ 和 $u_y$ 来施加铰接边界条件；端节点的转动保持自由。\n- 通过在简化的自由度上使用 $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$ 将广义特征值问题转换为标准形式，从而稳健地求解该问题。如果 $\\mu$ 是 $\\mathbf{K}^{-1}\\mathbf{K}_\\sigma$ 的一个特征值，则屈曲荷载因子为 $\\lambda = 1/\\mu$。选择两个最小的正 $\\lambda$（等价于两个最大的正 $\\mu$）及其对应的特征向量。\n\n角度单位与物理单位：\n\n- 所有角度必须使用弧度制。\n- 使用一个一致的无量纲单位制，其中 $E, A, I, R$ 和 $\\Phi$ 如下文所给。报告的荷载因子 $\\lambda$ 应为纯数（无量纲）。\n\n测试套件：\n\n- 使用以下三种情况。对每种情况，计算两个最低的分岔荷载因子 $\\lambda_1 \\le \\lambda_2$，并使用上述投影算子准则将其振型分类为对称（$1$）或反对称（$0$）。每种情况指定了 $(R,\\Phi,E,A,I,n_e)$：\n\n    - 情况1（理想路径）：$R=1.0$, $\\Phi=1.6$, $E=1.0$, $A=1.0$, $I=10^{-3}$, $n_e=40$。\n    - 情况2（弯曲刚度更小）：$R=1.0$, $\\Phi=1.2$, $E=1.0$, $A=1.0$, $I=5\\times 10^{-4}$, $n_e=40$。\n    - 情况3（跨度更大）：$R=1.0$, $\\Phi=2.0$, $E=1.0$, $A=1.0$, $I=2\\times 10^{-3}$, $n_e=60$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，以逗号分隔列表的形式呈现。每个测试用例的结果是一个包含四个条目的列表，顺序为 $[\\lambda_1, s_1, \\lambda_2, s_2]$，其中 $\\lambda_i$ 四舍五入到六位小数，$s_i$ 对于对称情况等于 $1$，对于反对称情况等于 $0$。格式示例：[[0.123456,1,0.234567,0],[...],[...]]。", "solution": "该问题要求确定一个用有限元法离散化的对称圆弧的两个最低线性屈曲荷载及相应的振型。振型需要根据其对称性进行分类。对问题陈述的验证表明，它是科学上合理的、适定的，并且包含了获得唯一解所需的所有必要信息。我们接下来将遵循基本原理推导求解方法。\n\n线性屈曲方程的离散形式是一个广义特征值问题：\n$$\n\\mathbf{K}\\boldsymbol{\\phi} = \\lambda\\mathbf{K}_\\sigma\\boldsymbol{\\phi}\n$$\n其中 $\\mathbf{K}$ 是弹性刚度矩阵，$\\mathbf{K}_\\sigma$ 是对应于单位荷载的几何刚度矩阵，$\\lambda$ 是临界屈曲荷载因子，$\\boldsymbol{\\phi}$ 是相应的屈曲振型（特征向量）。\n\n**1. 离散化与几何**\n\n圆弧的几何形状由其半径 $R$ 和总张角 $\\Phi$ 定义。圆弧的中心线由角度 $\\alpha \\in [-\\Phi/2, \\Phi/2]$ 参数化，其笛卡尔坐标由下式给出：\n$$\nx(\\alpha) = R\\sin(\\alpha), \\quad y(\\alpha) = R\\cos(\\alpha)\n$$\n结构被离散为 $n_e$ 个直线欧拉-伯努利梁单元，连接 $n_n = n_e + 1$ 个节点。节点在角度上均匀分布。节点 $i$（对于 $i \\in \\{0, 1, \\dots, n_e\\}$）的角度位置是：\n$$\n\\alpha_i = -\\frac{\\Phi}{2} + i \\frac{\\Phi}{n_e}\n$$\n每个节点的坐标 $(x_i, y_i)$ 使用上述几何方程计算。每个节点在平面内拥有三个自由度（DOF）：两个平动（$u_x, u_y$）和一个转动（$\\theta$）。系统的总自由度数为 $3n_n$。\n\n**2. 单元刚度矩阵与坐标变换**\n\n对于每个连接节点 $i$ 和 $i+1$ 的单元，我们首先在其局部坐标系 $(x', y')$ 中计算其属性，其中 $x'$ 轴与单元的弦杆对齐。\n单元长度 $L$ 是其两节点之间的欧几里得距离：\n$$\nL = \\sqrt{(x_{i+1}-x_i)^2 + (y_{i+1}-y_i)^2}\n$$\n单元局部 $x'$ 轴相对于全局 $x$ 轴的方向由角度 $\\theta_e$ 给出：\n$$\n\\theta_e = \\text{atan2}(y_{i+1}-y_i, x_{i+1}-x_i)\n$$\n局部弹性刚度矩阵 $\\mathbf{k}_e^{\\text{loc}}$ 和局部几何刚度矩阵 $\\mathbf{k}_\\sigma^{\\text{loc}}$ 在问题陈述中已提供。它们是 $6 \\times 6$ 的矩阵，对应于单元两个节点在其局部坐标系中的自由度 $(u'_1, v'_1, \\theta'_1, u'_2, v'_2, \\theta'_2)$。\n\n为了组装全局系统矩阵，这些局部矩阵必须转换到全局坐标系。这通过一个转换矩阵 $\\mathbf{T}$ 来实现，该矩阵关联了局部和全局节点位移。对于一个二维梁单元，$\\mathbf{T}$ 是一个 $6 \\times 6$ 的块对角矩阵：\n$$\n\\mathbf{T} = \\begin{bmatrix} \\mathbf{\\Lambda}  \\mathbf{0} \\\\ \\mathbf{0}  \\mathbf{\\Lambda} \\end{bmatrix}, \\quad \\text{where} \\quad \\mathbf{\\Lambda} = \\begin{bmatrix} \\cos\\theta_e  -\\sin\\theta_e  0 \\\\ \\sin\\theta_e  \\cos\\theta_e  0 \\\\ 0  0  1 \\end{bmatrix}\n$$\n然后，通过合同变换计算全局坐标系中的单元刚度矩阵 $\\mathbf{k}_e^{\\text{glob}}$ 和 $\\mathbf{k}_\\sigma^{\\text{glob}}$：\n$$\n\\mathbf{k}_e^{\\text{glob}} = \\mathbf{T}^T \\mathbf{k}_e^{\\text{loc}} \\mathbf{T}\n$$\n$$\n\\mathbf{k}_\\sigma^{\\text{glob}} = \\mathbf{T}^T \\mathbf{k}_\\sigma^{\\text{loc}} \\mathbf{T}\n$$\n\n**3. 全局系统组装与边界条件**\n\n大小为 $3n_n \\times 3n_n$ 的全局刚度矩阵 $\\mathbf{K}$ 和 $\\mathbf{K}_\\sigma$ 是通过对所有单元全局矩阵的贡献求和来构建的。这是一个标准的直接刚度法组装程序，其中 $\\mathbf{k}^{\\text{glob}}$ 的条目根据单元的节点连接性被添加到全局矩阵的相应位置。\n\n圆弧两端（节点 $0$ 和 $n_e$）由铰链支撑，这意味着平动位移被约束，而转动是自由的。边界条件是：\n$$\nu_x=0, u_y=0 \\quad \\text{at node } 0\n$$\n$$\nu_x=0, u_y=0 \\quad \\text{at node } n_e\n$$\n通过从全局矩阵中移除与这四个固定自由度相对应的行和列来施加这些条件，得到简化后的矩阵 $\\mathbf{K}_{\\text{free}}$ 和 $\\mathbf{K}_{\\sigma, \\text{free}}$。最终的系统仅涉及自由度。\n\n**4. 特征值问题求解**\n\n问题陈述指定通过将广义特征值问题转换为标准特征值问题来求解。自由度的屈曲方程为：\n$$\n\\mathbf{K}_{\\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\lambda\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}}\n$$\n由于结构被恰当约束，$\\mathbf{K}_{\\text{free}}$ 是正定的，因此是可逆的。因此我们可以写出：\n$$\n\\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}\\boldsymbol{\\phi}_{\\text{free}} = \\frac{1}{\\lambda}\\boldsymbol{\\phi}_{\\text{free}}\n$$\n令 $\\mu = 1/\\lambda$，我们求解标准特征值问题 $\\mathbf{A}\\mathbf{x} = \\mu\\mathbf{x}$，其中 $\\mathbf{A} = \\mathbf{K}_{\\text{free}}^{-1}\\mathbf{K}_{\\sigma, \\text{free}}$ 且 $\\mathbf{x} = \\boldsymbol{\\phi}_{\\text{free}}$。计算特征值 $\\mu$。临界屈曲荷载因子 $\\lambda$ 是这些特征值的倒数。我们寻找两个最小的正 $\\lambda$ 值，这对应于两个最大的正 $\\mu$ 值。相应的特征向量 $\\boldsymbol{\\phi}_{\\text{free}}$ 是限制在自由度上的振型。通过在固定自由度的位置重新插入零，可以重构完整的振型向量 $\\boldsymbol{\\phi}$。\n\n**5. 对称性分类**\n\n圆弧关于 $y$ 轴反射对称。这种对称性由一个作用在全局自由度向量 $\\boldsymbol{\\phi}$ 上的算子 $\\mathbf{R}$ 表示。对于一个按节点分块的自由度向量 $\\boldsymbol{\\phi} = [\\boldsymbol{\\phi}_0^T, \\boldsymbol{\\phi}_1^T, \\dots, \\boldsymbol{\\phi}_{n_e}^T]^T$，反射算子将节点 $i$ 的自由度映射到反射节点 $j=n_e-i$ 的变换后的自由度。\n\n问题基于局部切向和法向坐标定义了反射变换。遵循指定的程序，我们可以推导出将节点 $i$ 的位移自由度 $(u_x, u_y)_i$ 映射到节点 $j=n_e-i$ 的 $(u'_x, u'_y)_j$ 的变换块。发现此变换是一个简单的反射：$(u'_x, u'_y)_j = (-u_x, u_y)_i$。转动自由度的变换为 $\\theta_j = -\\theta_i$。因此，将自由度从节点 $i$ 映射到节点 $j$ 的 $\\mathbf{R}$ 的 $3 \\times 3$ 子块是 $\\text{diag}(-1, 1, -1)$。完整的矩阵 $\\mathbf{R}$ 是一个由这些块在其反主对角线上组成的块置换矩阵。\n\n构造出算子 $\\mathbf{R}$ 后，我们定义对称和反对称投影算子：\n$$\n\\mathbf{P}_{\\text{sym}} = \\frac{1}{2}(\\mathbf{I} + \\mathbf{R}), \\quad \\mathbf{P}_{\\text{anti}} = \\frac{1}{2}(\\mathbf{I} - \\mathbf{R})\n$$\n一个任意的振型 $\\boldsymbol{\\phi}$ 可以分解为其对称和反对称分量：$\\boldsymbol{\\phi} = \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi} + \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}$。如果其对称部分的范数大于或等于其反对称部分的范数，则该振型被分类为对称，否则为反对称：\n\\begin{itemize}\n    \\item 对称 ($s=1$)：如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2 \\ge \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n    \\item 反对称 ($s=0$)：如果 $\\lVert \\mathbf{P}_{\\text{sym}}\\boldsymbol{\\phi}\\rVert_2  \\lVert \\mathbf{P}_{\\text{anti}}\\boldsymbol{\\phi}\\rVert_2$\n\\end{itemize}\n将此程序应用于计算出的两个屈曲振型 $\\boldsymbol{\\phi}_1$ 和 $\\boldsymbol{\\phi}_2$，以确定它们的对称性分类 $s_1$ 和 $s_2$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases specified\n    in the problem statement.\n    \"\"\"\n\n    def analyze_arch(R, Phi, E, A, I, n_e):\n        \"\"\"\n        Performs FEM buckling analysis for a single circular arch case.\n\n        Args:\n            R (float): Arch radius.\n            Phi (float): Total arch angle in radians.\n            E (float): Young's modulus.\n            A (float): Cross-sectional area.\n            I (float): Second moment of area.\n            n_e (int): Number of elements.\n\n        Returns:\n            list: A list containing [lambda_1, s_1, lambda_2, s_2],\n                  where lambda_i are the buckling loads and s_i are the\n                  symmetry classifications (1 for symmetric, 0 for antisymmetric).\n        \"\"\"\n        n_n = n_e + 1\n        dofs_per_node = 3\n        total_dofs = n_n * dofs_per_node\n\n        # 1. Discretization and Nodal Coordinates\n        alphas = np.linspace(-Phi / 2.0, Phi / 2.0, n_n)\n        coords = np.zeros((n_n, 2))\n        coords[:, 0] = R * np.sin(alphas)\n        coords[:, 1] = R * np.cos(alphas)\n\n        # Initialize global stiffness matrices\n        K_global = np.zeros((total_dofs, total_dofs))\n        K_sigma_global = np.zeros((total_dofs, total_dofs))\n\n        # 2. Element-by-Element Assembly\n        for i in range(n_e):\n            node1_idx, node2_idx = i, i + 1\n            node1_coords, node2_coords = coords[node1_idx], coords[node2_idx]\n            \n            dx = node2_coords[0] - node1_coords[0]\n            dy = node2_coords[1] - node1_coords[1]\n            L = math.sqrt(dx**2 + dy**2)\n            \n            # Element orientation\n            angle = math.atan2(dy, dx)\n            c, s = math.cos(angle), math.sin(angle)\n            \n            # Local elastic stiffness matrix\n            ke_loc = np.zeros((6, 6))\n            EA_L = E * A / L\n            EI_L = E * I / L\n            EI_L2 = E * I / L**2\n            EI_L3 = E * I / L**3\n\n            ke_loc[0, 0] = EA_L\n            ke_loc[0, 3] = -EA_L\n            ke_loc[3, 0] = -EA_L\n            ke_loc[3, 3] = EA_L\n\n            ke_loc[1, 1] = 12 * EI_L3\n            ke_loc[1, 2] = 6 * EI_L2\n            ke_loc[1, 4] = -12 * EI_L3\n            ke_loc[1, 5] = 6 * EI_L2\n            ke_loc[2, 1] = 6 * EI_L2\n            ke_loc[2, 2] = 4 * EI_L\n            ke_loc[2, 4] = -6 * EI_L2\n            ke_loc[2, 5] = 2 * EI_L\n            ke_loc[4, 1] = -12 * EI_L3\n            ke_loc[4, 2] = -6 * EI_L2\n            ke_loc[4, 4] = 12 * EI_L3\n            ke_loc[4, 5] = -6 * EI_L2\n            ke_loc[5, 1] = 6 * EI_L2\n            ke_loc[5, 2] = 2 * EI_L\n            ke_loc[5, 4] = -6 * EI_L2\n            ke_loc[5, 5] = 4 * EI_L\n\n            # Local geometric stiffness matrix (for P=1)\n            ksigma_loc = np.zeros((6, 6))\n            _30L = 30 * L\n            ksigma_loc[1, 1] = 36 / _30L\n            ksigma_loc[1, 2] = 3 * L / _30L\n            ksigma_loc[1, 4] = -36 / _30L\n            ksigma_loc[1, 5] = 3 * L / _30L\n            ksigma_loc[2, 1] = 3 * L / _30L\n            ksigma_loc[2, 2] = 4 * L**2 / _30L\n            ksigma_loc[2, 4] = -3 * L / _30L\n            ksigma_loc[2, 5] = -L**2 / _30L\n            ksigma_loc[4, 1] = -36 / _30L\n            ksigma_loc[4, 2] = -3 * L / _30L\n            ksigma_loc[4, 4] = 36 / _30L\n            ksigma_loc[4, 5] = -3 * L / _30L\n            ksigma_loc[5, 1] = 3 * L / _30L\n            ksigma_loc[5, 2] = -L**2 / _30L\n            ksigma_loc[5, 4] = -3 * L / _30L\n            ksigma_loc[5, 5] = 4 * L**2 / _30L\n\n            # Transformation matrix\n            Lambda = np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])\n            T = np.zeros((6, 6))\n            T[0:3, 0:3] = Lambda\n            T[3:6, 3:6] = Lambda\n            \n            # Transform and assemble\n            ke_glob = T.T @ ke_loc @ T\n            ksigma_glob = T.T @ ksigma_loc @ T\n            \n            dof_indices = np.array([\n                dofs_per_node * node1_idx, dofs_per_node * node1_idx + 1, dofs_per_node * node1_idx + 2,\n                dofs_per_node * node2_idx, dofs_per_node * node2_idx + 1, dofs_per_node * node2_idx + 2\n            ])\n            \n            K_global[np.ix_(dof_indices, dof_indices)] += ke_glob\n            K_sigma_global[np.ix_(dof_indices, dof_indices)] += ksigma_glob\n\n        # 3. Boundary Conditions\n        fixed_dofs = [0, 1, dofs_per_node * n_e, dofs_per_node * n_e + 1]\n        all_dofs = np.arange(total_dofs)\n        free_dofs = np.setdiff1d(all_dofs, fixed_dofs)\n        \n        K_free = K_global[np.ix_(free_dofs, free_dofs)]\n        K_sigma_free = K_sigma_global[np.ix_(free_dofs, free_dofs)]\n        \n        # 4. Eigenvalue Problem\n        # Following problem statement: convert to standard eigenproblem\n        # A more robust method would be scipy.linalg.eigh(K_free, K_sigma_free)\n        try:\n            K_free_inv = np.linalg.inv(K_free)\n        except np.linalg.LinAlgError:\n            return [np.nan, -1, np.nan, -1] # Indicates failure\n            \n        A = K_free_inv @ K_sigma_free\n        \n        mu_vals, eig_vecs_free = np.linalg.eig(A)\n\n        # Filter for positive real eigenvalues mu=1/lambda\n        # and sort to find largest mu (smallest lambda)\n        valid_eigs = []\n        for j, mu in enumerate(mu_vals):\n            if np.isreal(mu) and mu.real  1e-9: # Filter out non-positive and trivial\n                valid_eigs.append((mu.real, eig_vecs_free[:, j]))\n        \n        # Sort by mu in descending order to get smallest lambda first\n        valid_eigs.sort(key=lambda x: x[0], reverse=True)\n        \n        if len(valid_eigs)  2:\n             return [np.nan, -1, np.nan, -1]\n\n        # 5. Extract results and reconstruct full eigenvectors\n        lambda_vals = [1.0 / eig[0] for eig in valid_eigs[:2]]\n        \n        # Ensure lambda1 = lambda2\n        buckling_results = []\n        if lambda_vals[0]  lambda_vals[1]:\n            lambda_vals = [lambda_vals[1], lambda_vals[0]]\n            eig_vecs_to_process = [valid_eigs[1][1], valid_eigs[0][1]]\n        else:\n            eig_vecs_to_process = [valid_eigs[0][1], valid_eigs[1][1]]\n\n        # 6. Symmetry Classification\n        R_matrix = np.zeros((total_dofs, total_dofs))\n        R_block = np.diag([-1.0, 1.0, -1.0])\n        \n        for i in range(n_n):\n            j = n_e - i # Reflected node index\n            i_start, j_start = i * dofs_per_node, j * dofs_per_node\n            R_matrix[j_start:j_start+3, i_start:i_start+3] = R_block\n\n        I_matrix = np.identity(total_dofs)\n        P_sym = 0.5 * (I_matrix + R_matrix)\n        P_anti = 0.5 * (I_matrix - R_matrix)\n\n        for k in range(2):\n            lambda_val = lambda_vals[k]\n            eig_vec_free = eig_vecs_to_process[k]\n            \n            phi_full = np.zeros(total_dofs, dtype=float)\n            phi_full[free_dofs] = eig_vec_free.real\n            phi_full /= np.linalg.norm(phi_full)\n            \n            phi_sym = P_sym @ phi_full\n            phi_anti = P_anti @ phi_full\n            \n            norm_sym = np.linalg.norm(phi_sym)\n            norm_anti = np.linalg.norm(phi_anti)\n            \n            symmetry_class = 1 if norm_sym = norm_anti else 0\n            buckling_results.extend([round(lambda_val, 6), symmetry_class])\n\n        return buckling_results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.6, 1.0, 1.0, 1e-3, 40),\n        (1.0, 1.2, 1.0, 1.0, 5e-4, 40),\n        (1.0, 2.0, 1.0, 1.0, 2e-3, 60),\n    ]\n\n    results = []\n    for case in test_cases:\n        R, Phi, E, A, I, n_e = case\n        result = analyze_arch(R, Phi, E, A, I, n_e)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert each inner list to a string representation\n    result_strings = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2542913"}]}