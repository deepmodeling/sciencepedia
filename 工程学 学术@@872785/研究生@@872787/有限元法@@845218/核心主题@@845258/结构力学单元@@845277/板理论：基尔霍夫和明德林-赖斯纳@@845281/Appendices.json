{"hands_on_practices": [{"introduction": "在构建复杂的有限元模型之前，掌握区分不同板理论的基本运动学假设至关重要。这项练习将引导你推导 Mindlin-Reissner 理论中的横向剪切应变，然后通过施加 Kirchhoff-Love 约束，展示这些剪切应变如何为零，从而清晰地揭示这两种重要模型之间的内在联系。这个基础性的推导是理解板理论数值实现中诸多问题的关键第一步。[@problem_id:2588777]", "problem": "考虑一个厚度为 $h$ 的均匀、各向同性平板，其占据中面域 $\\{(x,y)\\}$，横向沿 $z$ 方向。采用 Mindlin–Reissner 一阶剪切变形理论 (FSDT) 的运动学，其中三维位移场为\n$$\nu(x,y,z) \\;=\\; u_{0}(x,y) \\;+\\; z\\,\\phi_{x}(x,y),\\qquad\nv(x,y,z) \\;=\\; v_{0}(x,y) \\;+\\; z\\,\\phi_{y}(x,y),\\qquad\nw(x,y,z) \\;=\\; w_{0}(x,y),\n$$\n其中 $u_{0}$ 和 $v_{0}$ 是面内中面位移，$w_{0}$ 是中面的横向挠度，而 $\\phi_{x}$ 和 $\\phi_{y}$ 分别是与 $x$ 和 $y$ 方向相关的横向法线的独立转角。小应变、小转动运动学意味着工程横向剪切应变为\n$$\n\\gamma_{xz} \\;=\\; \\frac{\\partial u}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial x}, \\qquad\n\\gamma_{yz} \\;=\\; \\frac{\\partial v}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial y}.\n$$\n该板承受绕 $x$ 轴的均匀圆柱弯曲，其特征是相对于 $y$ 的恒定曲率 $\\kappa$，因此中面挠度为\n$$\nw_{0}(x,y) \\;=\\; \\frac{\\kappa}{2}\\,y^{2}.\n$$\n假设与剪切计算相关的中面内位移为零，即 $u_{0}(x,y)=0$ 和 $v_{0}(x,y)=0$。仅使用上述定义，计算 Mindlin–Reissner 剪切应变 $\\gamma_{xz}(x,y)$ 和 $\\gamma_{yz}(x,y)$，用 $\\kappa$、$y$ 以及转角场 $\\phi_{x}(x,y)$ 和 $\\phi_{y}(x,y)$ 表示。然后，通过强制施加 Kirchhoff–Love 约束（横向法线保持与中面正交），证明这些横向剪切应变在 Kirchhoff–Love 极限下为零。\n\n将 $\\big(\\gamma_{xz}(x,y),\\,\\gamma_{yz}(x,y)\\big)$ 的最终答案以行矩阵的形式给出。", "solution": "问题陈述有待验证。\n\n**步骤1：提取已知条件**\n- **理论**：Mindlin–Reissner一阶剪切变形理论 (FSDT)。\n- **板**：均匀、各向同性、平坦，厚度为 $h$，中面域为 $\\{(x,y)\\}$。\n- **运动学**：位移场由以下公式给出：\n$u(x,y,z) \\;=\\; u_{0}(x,y) \\;+\\; z\\,\\phi_{x}(x,y)$\n$v(x,y,z) \\;=\\; v_{0}(x,y) \\;+\\; z\\,\\phi_{y}(x,y)$\n$w(x,y,z) \\;=\\; w_{0}(x,y)$\n其中 $u_0, v_0$ 是中面面内位移，$w_0$ 是横向挠度，$\\phi_x, \\phi_y$ 是独立转角。\n- **应变定义**：工程横向剪切应变为：\n$\\gamma_{xz} \\;=\\; \\frac{\\partial u}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial x}$\n$\\gamma_{yz} \\;=\\; \\frac{\\partial v}{\\partial z} \\;+\\; \\frac{\\partial w}{\\partial y}$\n- **加载条件**：绕 $x$ 轴的均匀圆柱弯曲，相对于 $y$ 的曲率为恒定值 $\\kappa$。\n- **挠度**：中面挠度指定为：\n$w_{0}(x,y) \\;=\\; \\frac{\\kappa}{2}\\,y^{2}$\n- **假设**：$u_{0}(x,y)=0$ 且 $v_{0}(x,y)=0$。\n- **任务**：\n  1. 用 $\\kappa$、$y$ 和转角场 $\\phi_{x}(x,y)$ 和 $\\phi_{y}(x,y)$ 表示，计算 Mindlin–Reissner 剪切应变 $\\gamma_{xz}(x,y)$ 和 $\\gamma_{yz}(x,y)$。\n  2. 强制施加 Kirchhoff–Love 约束（横向法线保持与中面正交），并证明这些剪切应变为零。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，是板理论中的一个标准练习。在特定的符号约定下，所有关于运动学和应变的定义都是 FSDT 的标准定义。该问题是自洽的、客观的且适定的。给定的信息足以且一致地推导出所需的表达式，并证明 Mindlin-Reissner 理论和 Kirchhoff-Love 理论之间的关系。不存在事实或逻辑上的不一致之处。\n\n**步骤3：结论与行动**\n该问题有效。将提供解答。\n\n解答按要求分为两部分进行。首先，在 Mindlin-Reissner 框架下计算剪切应变。其次，正式推导并应用 Kirchhoff-Love 约束，以证明剪切应变为零。\n\n**第1部分：计算 Mindlin–Reissner 剪切应变**\n\n位移场由 FSDT 运动学提供。我们应用给定的假设，即中面的面内位移为零，即 $u_{0}(x,y) = 0$ 和 $v_{0}(x,y) = 0$。运动学关系变为：\n$$u(x,y,z) = z\\,\\phi_{x}(x,y)$$\n$$v(x,y,z) = z\\,\\phi_{y}(x,y)$$\n$$w(x,y,z) = w_{0}(x,y)$$\n均匀圆柱弯曲的横向挠度为 $w_{0}(x,y) = \\frac{\\kappa}{2}y^{2}$。\n\n工程横向剪切应变定义为：\n$$\\gamma_{xz} = \\frac{\\partial u}{\\partial z} + \\frac{\\partial w}{\\partial x}$$\n$$\\gamma_{yz} = \\frac{\\partial v}{\\partial z} + \\frac{\\partial w}{\\partial y}$$\n\n我们计算必要的偏导数：\n1.  $u$ 对 $z$ 的导数：\n    $$\\frac{\\partial u}{\\partial z} = \\frac{\\partial}{\\partial z} \\left( z\\,\\phi_{x}(x,y) \\right) = \\phi_{x}(x,y)$$\n2.  $v$ 对 $z$ 的导数：\n    $$\\frac{\\partial v}{\\partial z} = \\frac{\\partial}{\\partial z} \\left( z\\,\\phi_{y}(x,y) \\right) = \\phi_{y}(x,y)$$\n3.  $w$ 对 $x$ 的导数：\n    $$\\frac{\\partial w}{\\partial x} = \\frac{\\partial w_{0}}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\frac{\\kappa}{2}y^{2} \\right) = 0$$\n4.  $w$ 对 $y$ 的导数：\n    $$\\frac{\\partial w}{\\partial y} = \\frac{\\partial w_{0}}{\\partial y} = \\frac{\\partial}{\\partial y} \\left( \\frac{\\kappa}{2}y^{2} \\right) = \\kappa y$$\n\n将这些导数代入应变定义，得到指定圆柱弯曲下的 Mindlin-Reissner 剪切应变：\n$$\\gamma_{xz}(x,y) = \\phi_{x}(x,y) + 0 = \\phi_{x}(x,y)$$\n$$\\gamma_{yz}(x,y) = \\phi_{y}(x,y) + \\kappa y$$\n这完成了第一个任务。\n\n**第2部分：应用 Kirchhoff–Love 约束**\n\nKirchhoff–Love 假设指出，初始垂直于板中面的材料线在变形后仍然保持为直线，且垂直于变形后的中面，并且其长度不变。在这里，我们只需要正交性条件。\n\n让我们将此约束形式化。变形后点 $(x,y,z)$ 的位置向量为 $\\mathbf{P}(x,y,z) = (x+u, y+v, z+w)$。使用 FSDT 运动学：\n$$\\mathbf{P}(x,y,z) = (x + z\\,\\phi_{x}(x,y), y + z\\,\\phi_{y}(x,y), z + w_{0}(x,y))$$\n通过对 $\\mathbf{P}$ 求 $z$ 的偏导，可以找到初始垂直于中面的材料线变形后的切线向量：\n$$\\mathbf{d} = \\frac{\\partial \\mathbf{P}}{\\partial z} = (\\phi_{x}(x,y), \\phi_{y}(x,y), 1)$$\n\n接下来，我们求解变形后中面的法向量。中面上的点 $(x, y, 0)$ 移动到 $\\mathbf{p}_{0}(x,y) = (x, y, w_{0}(x,y))$。变形后中面的切向量为：\n$$\\mathbf{T}_{x} = \\frac{\\partial \\mathbf{p}_{0}}{\\partial x} = \\left(1, 0, \\frac{\\partial w_{0}}{\\partial x}\\right)$$\n$$\\mathbf{T}_{y} = \\frac{\\partial \\mathbf{p}_{0}}{\\partial y} = \\left(0, 1, \\frac{\\partial w_{0}}{\\partial y}\\right)$$\n变形后中面的法向量由它们的叉积给出，$\\mathbf{n} = \\mathbf{T}_{x} \\times \\mathbf{T}_{y}$：\n$$\\mathbf{n} = \\begin{vmatrix} \\mathbf{i}  \\mathbf{j}  \\mathbf{k} \\\\ 1  0  \\frac{\\partial w_{0}}{\\partial x} \\\\ 0  1  \\frac{\\partial w_{0}}{\\partial y} \\end{vmatrix} = \\left(-\\frac{\\partial w_{0}}{\\partial x}, -\\frac{\\partial w_{0}}{\\partial y}, 1\\right)$$\nKirchhoff-Love 约束要求向量 $\\mathbf{d}$（代表变形后的法向纤维）与向量 $\\mathbf{n}$（变形后中面的法线）平行。这意味着对于某个标量 $C$，有 $\\mathbf{d} = C \\mathbf{n}$。\n$$(\\phi_{x}, \\phi_{y}, 1) = C \\left(-\\frac{\\partial w_{0}}{\\partial x}, -\\frac{\\partial w_{0}}{\\partial y}, 1\\right)$$\n比较第三个分量，我们发现 $1 = C \\cdot 1$，所以 $C=1$。令其他分量相等，得到 Kirchhoff-Love 理论的运动学约束：\n$$\\phi_{x}(x,y) = -\\frac{\\partial w_{0}(x,y)}{\\partial x}$$\n$$\\phi_{y}(x,y) = -\\frac{\\partial w_{0}(x,y)}{\\partial y}$$\n这些方程将法线的转角直接与中面的斜率联系起来。\n\n现在，我们证明这些约束强制横向剪切应变为零。Mindlin-Reissner 剪切应变的一般表达式为：\n$$\\gamma_{xz} = \\phi_{x} + \\frac{\\partial w_{0}}{\\partial x}$$\n$$\\gamma_{yz} = \\phi_{y} + \\frac{\\partial w_{0}}{\\partial y}$$\n将 Kirchhoff-Love 运动学约束代入这些表达式中：\n$$\\gamma_{xz} = \\left(-\\frac{\\partial w_{0}}{\\partial x}\\right) + \\frac{\\partial w_{0}}{\\partial x} = 0$$\n$$\\gamma_{yz} = \\left(-\\frac{\\partial w_{0}}{\\partial y}\\right) + \\frac{\\partial w_{0}}{\\partial y} = 0$$\n因此，通过强制施加 Kirchhoff–Love 约束（即横向法线保持与中面正交），可以严格证明横向剪切应变 $\\gamma_{xz}$ 和 $\\gamma_{yz}$ 必须为零。这是区分 Kirchhoff-Love 理论与 Mindlin-Reissner 理论的决定性特征。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\phi_{x}(x,y)  \\phi_{y}(x,y) + \\kappa y\n\\end{pmatrix}\n}\n$$", "id": "2588777"}, {"introduction": "在理解了理论运动学之后，下一步是将其转化为有限元方法中的计算构件。这项实践将带你详细推导一个四节点 Mindlin-Reissner 板单元的刚度矩阵，并将其分解为弯曲和剪切两个部分。这个过程是理解物理行为如何被数值化表示的核心，也是从连续介质力学迈向计算力学的关键桥梁。[@problem_id:2588744]", "problem": "一块各向同性的均质板，在有限元法 (FEM) 框架内使用四节点四边形 Mindlin–Reissner 板单元进行建模。每个节点具有三个自由度：横向位移 $w$ 以及分别绕 $y$ 轴和 $x$ 轴的转角 $\\theta_{x}$ 和 $\\theta_{y}$。Mindlin–Reissner 运动学假设了一阶剪切变形，包含横向剪切应变 $\\gamma_{xz}$ 和 $\\gamma_{yz}$ 以及弯曲曲率 $\\kappa_{x}$、$\\kappa_{y}$ 和 $\\kappa_{xy}$。该板的厚度为 $t$，杨氏模量为 $E$，泊松比为 $\\nu$，剪切修正因子为 $\\kappa$。剪切模量为 $G = E/\\bigl(2(1+\\nu)\\bigr)$。\n\n考虑一个单独的四节点单元，它在物理 $(x,y)$ 平面内是一个边长为 $a$（沿 $x$ 轴）和 $b$（沿 $y$ 轴）且与坐标轴对齐的矩形，由仿射映射 $x = \\tfrac{a}{2}\\,\\xi + x_{c}$ 和 $y = \\tfrac{b}{2}\\,\\eta + y_{c}$ 从母正方形 $(\\xi,\\eta)\\in[-1,1]^2$ 映射而来。在母域上使用标准双线性形函数，\n$$\nN_{1}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),\\quad\nN_{2}(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta),\\quad\nN_{3}(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta),\\quad\nN_{4}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta).\n$$\n\n从 Mindlin–Reissner 运动学定义和线性弹性各向同性本构关系出发，并对 $w$、$\\theta_{x}$ 和 $\\theta_{y}$ 使用上述形函数进行标准的等参插值，执行以下操作：\n\n1. 推导弯曲的单元应变-位移矩阵 $B^{(b)}$ 和剪切的单元应变-位移矩阵 $B^{(s)}$，用形函数关于 $x$ 和 $y$ 的导数来表示。明确指出每个矩阵映射到哪种广义应变。\n2. 写出 Mindlin–Reissner 理论中各向同性板的弯曲和剪切本构矩阵 $D^{(b)}$ 和 $D^{(s)}$。\n3. 以虚功原理为基本出发点，推导 $12\\times 12$ 单元刚度矩阵，该矩阵是弯曲部分和剪切部分之和，\n$$\nK_{e} \\;=\\; K_{e}^{(b)} \\;+\\; K_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A \\;+\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A,\n$$\n并明确指出与弯曲和剪切相关的子块，强调与横向位移 $w$ 的耦合存在与否。\n4. 对于给定的矩形单元映射，使用全高斯积分（$[-1,1]^2$ 上的 $2\\times 2$ 个点，单位权重）来计算这些积分。\n\n最后，作为一个具体的标量，计算单个刚度项的闭式符号表达式，该项将节点1的横向位移 $w$ 与其自身耦合，即通过全高斯积分得到的总单元刚度矩阵 $K_{e}$ 的 $(w_{1},w_{1})$ 项。用 $E$、$\\nu$、$t$、$\\kappa$、$a$ 和 $b$ 来表示你的最终答案。不要进行近似。答案以牛顿/米 (N/m) 为单位表示。最终报告的答案必须是一个单一的闭式表达式。", "solution": "出发点是 Mindlin–Reissner 板单元的虚功原理，由此可得单元刚度是弯曲和剪切贡献之和，\n$$\nK_{e} \\;=\\; K_{e}^{(b)} \\;+\\; K_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A \\;+\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A.\n$$\n节点自由度按以下顺序排列：\n$$\n\\{d\\} \\;=\\; \\begin{bmatrix}\nw_{1}  \\theta_{x1}  \\theta_{y1}  w_{2}  \\theta_{x2}  \\theta_{y2}  w_{3}  \\theta_{x3}  \\theta_{y3}  w_{4}  \\theta_{x4}  \\theta_{y4}\n\\end{bmatrix}^{\\mathsf{T}}.\n$$\n\nMindlin–Reissner 板的运动学关系为\n$$\n\\gamma_{xz} \\;=\\; \\theta_{x} \\;+\\; \\frac{\\partial w}{\\partial x},\\qquad\n\\gamma_{yz} \\;=\\; \\theta_{y} \\;+\\; \\frac{\\partial w}{\\partial y},\n$$\n$$\n\\kappa_{x} \\;=\\; \\frac{\\partial \\theta_{x}}{\\partial x},\\qquad\n\\kappa_{y} \\;=\\; \\frac{\\partial \\theta_{y}}{\\partial y},\\qquad\n\\kappa_{xy} \\;=\\; \\frac{\\partial \\theta_{x}}{\\partial y} \\;+\\; \\frac{\\partial \\theta_{y}}{\\partial x}.\n$$\n\n使用双线性形函数 $N_{i}$ 对场进行插值为\n$$\nw(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,w_{i},\\qquad\n\\theta_{x}(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,\\theta_{xi},\\qquad\n\\theta_{y}(\\xi,\\eta) \\;=\\; \\sum_{i=1}^{4} N_{i}(\\xi,\\eta)\\,\\theta_{yi}.\n$$\n使用矩形的仿射映射，雅可比矩阵是常数对角阵，\n$$\nJ \\;=\\; \\begin{bmatrix}\n\\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta}\\\n$$4pt]\n\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta}\n\\end{bmatrix}\n\\;=\\;\n\\begin{bmatrix}\n\\frac{a}{2}  0\\\n$$4pt]\n0  \\frac{b}{2}\n\\end{bmatrix},\\qquad\n\\det J \\;=\\; \\frac{ab}{4},\n$$\n导数变换如下\n$$\n\\frac{\\partial}{\\partial x} \\;=\\; \\frac{2}{a}\\,\\frac{\\partial}{\\partial \\xi},\\qquad\n\\frac{\\partial}{\\partial y} \\;=\\; \\frac{2}{b}\\,\\frac{\\partial}{\\partial \\eta}.\n$$\n\n应变-位移矩阵的构建过程是将插值代入运动学关系，并读出节点自由度的系数。定义广义应变向量\n$$\n\\{\\varepsilon^{(b)}\\} \\;=\\; \\begin{bmatrix} \\kappa_{x}  \\kappa_{y}  \\kappa_{xy} \\end{bmatrix}^{\\mathsf{T}},\\qquad\n\\{\\varepsilon^{(s)}\\} \\;=\\; \\begin{bmatrix} \\gamma_{xz}  \\gamma_{yz} \\end{bmatrix}^{\\mathsf{T}}.\n$$\n那么\n$$\n\\{\\varepsilon^{(b)}\\} \\;=\\; B^{(b)} \\{d\\},\\qquad \\{\\varepsilon^{(s)}\\} \\;=\\; B^{(s)} \\{d\\},\n$$\n其中 $B^{(b)}\\in\\mathbb{R}^{3\\times 12}$ 和 $B^{(s)}\\in\\mathbb{R}^{2\\times 12}$ 是逐节点组装的。对于节点 $i$，与 $\\{w_{i},\\theta_{xi},\\theta_{yi}\\}$ 相关的对 $B^{(b)}$ 的 $3\\times 3$ 弯曲贡献为\n$$\nB^{(b)}_{i} \\;=\\; \\begin{bmatrix}\n0  \\dfrac{\\partial N_{i}}{\\partial x}  0\\\n$$8pt]\n0  0  \\dfrac{\\partial N_{i}}{\\partial y}\\\n$$8pt]\n0  \\dfrac{\\partial N_{i}}{\\partial y}  \\dfrac{\\partial N_{i}}{\\partial x}\n\\end{bmatrix},\n$$\n因此 $B^{(b)}$ 是 $B^{(b)}_{i}$（$i=1,\\dots,4$）的水平拼接，并且在所有 $w_{i}$ 出现的地方列向量为零（弯曲不依赖于 $w$）。对于剪切，节点 $i$ 的 $2\\times 3$ 贡献为\n$$\nB^{(s)}_{i} \\;=\\; \\begin{bmatrix}\n\\dfrac{\\partial N_{i}}{\\partial x}  N_{i}  0\\\n$$8pt]\n\\dfrac{\\partial N_{i}}{\\partial y}  0  N_{i}\n\\end{bmatrix},\n$$\n因此 $B^{(s)}$ 是 $B^{(s)}_{i}$（$i=1,\\dots,4$）的水平拼接。\n\nMindlin–Reissner 板的各向同性本构矩阵为\n$$\nD^{(b)} \\;=\\; \\frac{E t^{3}}{12\\bigl(1-\\nu^{2}\\bigr)}\\begin{bmatrix}\n1  \\nu  0\\\n$$4pt]\n\\nu  1  0\\\n$$4pt]\n0  0  \\dfrac{1-\\nu}{2}\n\\end{bmatrix},\\qquad\nD^{(s)} \\;=\\; \\kappa\\, G\\, t \\begin{bmatrix} 1  0\\\n$$4pt] 0  1 \\end{bmatrix},\\quad G \\;=\\; \\frac{E}{2(1+\\nu)}.\n$$\n\n有了这些，单元刚度贡献可由下式得出\n$$\nK_{e}^{(b)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(b)}\\bigr)^{\\mathsf{T}} D^{(b)} B^{(b)}\\,\\mathrm{d}A,\\qquad\nK_{e}^{(s)} \\;=\\; \\int_{\\Omega_{e}} \\bigl(B^{(s)}\\bigr)^{\\mathsf{T}} D^{(s)} B^{(s)}\\,\\mathrm{d}A.\n$$\n以分块矩阵形式，将自由度排序为 $\\{w\\}$ 在前，$\\{\\theta_{x},\\theta_{y}\\}$ 在后，可以观察到\n$$\nK_{e}^{(b)} \\;=\\; \\begin{bmatrix}\n0  0\\\n$$4pt]\n0  K_{\\theta\\theta}^{(b)}\n\\end{bmatrix},\\qquad\nK_{e}^{(s)} \\;=\\; \\begin{bmatrix}\nK_{ww}^{(s)}  K_{w\\theta}^{(s)}\\\n$$4pt]\n\\bigl(K_{w\\theta}^{(s)}\\bigr)^{\\mathsf{T}}  K_{\\theta\\theta}^{(s)}\n\\end{bmatrix},\n$$\n因此弯曲部分只涉及转动自由度，而剪切部分耦合了横向位移和转角，并且也对 $K_{ww}$ 有贡献。\n\n在 $[-1,1]^2$ 上使用 $2\\times 2$ 点的全高斯积分，采用四个点 $(\\xi,\\eta)=(\\pm s,\\pm s)$，其中 $s=1/\\sqrt{3}$，权重为单位值。雅可比行列式是常数，$\\det J = ab/4$，因此对于任何被积函数 $f(\\xi,\\eta)$，\n$$\n\\int_{\\Omega_{e}} f\\,\\mathrm{d}A \\;=\\; \\sum_{g=1}^{4} f(\\xi_{g},\\eta_{g})\\,\\det J.\n$$\n\n我们现在计算所要求的单个标量项：通过全高斯积分得到的总单元刚度 $K_{e}$ 的 $(w_{1},w_{1})$ 项。如前所述，弯曲不依赖于 $w$，因此该项完全由 $K_{e}^{(s)}$ 贡献。根据 $B^{(s)}$ 的形式，$(w_{1},w_{1})$ 项为\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\int_{\\Omega_{e}} \\kappa\\,G\\,t\\left[\\left(\\frac{\\partial N_{1}}{\\partial x}\\right)^{2} + \\left(\\frac{\\partial N_{1}}{\\partial y}\\right)^{2}\\right]\\mathrm{d}A.\n$$\n对于矩形映射，使用 $N_{1}(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$，\n$$\n\\frac{\\partial N_{1}}{\\partial \\xi} \\;=\\; -\\frac{1}{4}(1-\\eta),\\qquad\n\\frac{\\partial N_{1}}{\\partial \\eta} \\;=\\; -\\frac{1}{4}(1-\\xi),\n$$\n因此\n$$\n\\frac{\\partial N_{1}}{\\partial x} \\;=\\; \\frac{2}{a}\\frac{\\partial N_{1}}{\\partial \\xi} \\;=\\; -\\frac{1}{2a}(1-\\eta),\\qquad\n\\frac{\\partial N_{1}}{\\partial y} \\;=\\; \\frac{2}{b}\\frac{\\partial N_{1}}{\\partial \\eta} \\;=\\; -\\frac{1}{2b}(1-\\xi).\n$$\n通过全高斯求积法计算该积分，\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\sum_{(\\xi,\\eta)\\in\\{\\pm s\\}^{2}} \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}}(1-\\eta)^{2} + \\frac{1}{4b^{2}}(1-\\xi)^{2}\\right]\\det J.\n$$\n因为高斯点集包含两个 $\\eta=s$ 和两个 $\\eta=-s$ 的点，对 $\\xi$ 也类似，所以求和可以分离。令 $s=1/\\sqrt{3}$。那么\n$$\n\\sum_{(\\xi,\\eta)} (1-\\eta)^{2} \\;=\\; 2\\bigl[(1-s)^{2} + (1+s)^{2}\\bigr] \\;=\\; 4(1+s^{2}),\n$$\n并且同样的恒等式对 $\\sum_{(\\xi,\\eta)} (1-\\xi)^{2}$ 也成立。因此，\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}} + \\frac{1}{4b^{2}}\\right]\\cdot 4(1+s^{2})\\cdot \\det J.\n$$\n代入 $s^{2}=\\tfrac{1}{3}$ 和 $\\det J=\\tfrac{ab}{4}$，这简化为\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\kappa\\,G\\,t\\left[\\frac{1}{4a^{2}} + \\frac{1}{4b^{2}}\\right]\\cdot \\frac{16}{3}\\cdot \\frac{ab}{4}\n\\;=\\; \\kappa\\,G\\,t\\cdot \\frac{ab}{3}\\left[\\frac{1}{a^{2}}+\\frac{1}{b^{2}}\\right]\n\\;=\\; \\kappa\\,G\\,t\\cdot \\frac{1}{3}\\left(\\frac{b}{a}+\\frac{a}{b}\\right).\n$$\n代入 $G=\\dfrac{E}{2(1+\\nu)}$，得到最终的闭式表达式\n$$\n\\bigl[K_{e}\\bigr]_{w_{1},w_{1}} \\;=\\; \\frac{\\kappa\\,E\\,t}{6(1+\\nu)}\\left(\\frac{a}{b}+\\frac{b}{a}\\right).\n$$\n单位是牛顿/米，因为 $\\kappa$ 是无量纲的，$E$ 的单位是压力，$t$ 是长度。\n\n这就完成了使用全高斯积分将单元刚度分解为弯曲和剪切部分，以及所要求的标量刚度项的推导。", "answer": "$$\\boxed{\\dfrac{\\kappa\\,E\\,t}{6(1+\\nu)}\\left(\\dfrac{a}{b}+\\dfrac{b}{a}\\right)}$$", "id": "2588744"}, {"introduction": "正确的理论公式并不能保证有限元在实践中表现良好，因为可能会出现“剪切锁定”($\\text{shear locking}$)等数值问题。这个动手编程练习将挑战你实现“元片检验”($\\text{patch test}$)，这是一个验证单元精度的基本工具。通过比较标准单元、减缩积分单元和混合插值单元的性能，你将直接观察和理解不同单元构造策略对克服数值难题的实际效果。[@problem_id:2588738]", "problem": "考虑一阶剪切变形（Mindlin-Reissner）板理论，其运动学场由横向挠度 $w(x,y)$ 以及法线分别绕 $y$ 轴和 $x$ 轴的转角 $\\theta_x(x,y)$ 和 $\\theta_y(x,y)$ 给出。横向剪切应变为 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。弯曲曲率为 $\\kappa_{xx} = -\\partial \\theta_x/\\partial x$、$\\kappa_{yy} = -\\partial \\theta_y/\\partial y$ 和 $\\kappa_{xy} = -(\\partial \\theta_x/\\partial y + \\partial \\theta_y/\\partial x)$。在单元检验（patch test）中，指定一个变形场，该变形场能引起剪切为零的常曲率状态（纯弯曲），或曲率为零的常横向剪切状态（纯剪切），并检验有限元格式是否能在给定场的精确节点插值下，以零误差再现目标应变场。\n\n为进行单元检验，实现并比较三种四节点四边形 ($Q4$) Mindlin-Reissner 板单元：\n- 标准双线性单元：$w$、$\\theta_x$ 和 $\\theta_y$ 使用相同的等参双线性形函数进行插值。横向剪切应变直接计算为 $\\gamma_{xz} = \\theta_x + \\partial w/\\partial x$ 和 $\\gamma_{yz} = \\theta_y + \\partial w/\\partial y$。使用完全二乘二高斯积分，积分点位于 $(\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，权重为单位权重。\n- 减缩积分单元：运动学关系相同，但使用位于 $(0,0)$ 且权重为 $4$ 的单点高斯积分来计算横向剪切应变及任何与剪切相关的积分；弯曲量仍在二乘二高斯点上计算。对于本任务，如下文所定义的误差度量，剪切误差的计算规则与减缩积分情况（单点高斯积分）指定的规则相同，弯曲误差的计算规则如下文指定（二乘二高斯点）。\n- 张量分量混合插值 (MITC)：对弯曲量，$w$、$\\theta_x$ 和 $\\theta_y$ 使用相同的双线性插值，但通过在合适的边中点绑定剪切应变分量，并在单元上对其进行插值，来构造修正的横向剪切应变 $\\gamma_{xz}^\\ast$ 和 $\\gamma_{yz}^\\ast$。这种方式可在纯弯曲状态下强制剪切为零，并在纯剪切状态下再现常数剪切。在母单元域中，$\\gamma_{xz}$ 的绑定点位于边的中点：$(\\xi, \\eta) = (0, +1)$ 和 $(0, -1)$；$\\gamma_{yz}$ 的绑定点位于 $(+1, 0)$ 和 $(-1, 0)$。使用绑定的剪切场 $\\gamma^\\ast$，在二乘二高斯点上计算剪切应变误差。\n\n在母单元正方形 $[-1,1]\\times[-1,1]$ 上使用标准双线性形函数进行等参映射，并通过仿射变换映射到具有给定节点坐标的物理单元。对于给定的精确场，通过在物理节点坐标处对精确场进行采样来分配节点值。\n\n为单元检验定义两个精确场：\n- 绕 $y$ 轴的纯弯曲，具有常曲率 $\\kappa_x$：$w(x,y) = \\tfrac{1}{2}\\kappa_x x^2$，$\\theta_x(x,y) = -\\kappa_x x$，$\\theta_y(x,y) = 0$。在此状态下，精确的横向剪切应变处处为零，即 $\\gamma_{xz} = 0$ 和 $\\gamma_{yz} = 0$。使用 $\\kappa_x = 1.0$，单位为 $\\text{m}^{-1}$；由此产生的剪切误差是无量纲的。\n- $x$ 方向的纯横向剪切，具有常数 $\\gamma_{xz} = \\gamma_0$ 和 $\\gamma_{yz} = 0$：取 $w(x,y) = 0$，$\\theta_x(x,y) = \\gamma_0$，$\\theta_y(x,y) = 0$。在此状态下，精确的弯曲曲率恒为零。使用 $\\gamma_0 = 1.0$（无量纲）；由此产生的曲率误差单位为 $\\text{m}^{-1}$。\n\n将误差评估为单元上的均方根 (RMS) 度量：\n- 对于给定单元和给定场，剪切误差：令 $\\mathbf{\\gamma}$ 表示直接剪切应变 $(\\gamma_{xz}, \\gamma_{yz})$（对于标准和减缩积分单元）或绑定剪切应变 $(\\gamma_{xz}^\\ast, \\gamma_{yz}^\\ast)$（对于 MITC 单元）。定义 RMS 剪切误差为\n$$\n\\varepsilon_{\\text{shear}} = \\sqrt{\\frac{\\int_{\\Omega_e} \\left(\\gamma_{xz}^2 + \\gamma_{yz}^2\\right)\\, \\mathrm{d}\\Omega}{\\int_{\\Omega_e} \\mathrm{d}\\Omega}},\n$$\n使用上文所述的、为每个单元指定的相应高斯积分法则进行近似计算。\n- 对于给定单元和给定场，弯曲误差：令 $\\boldsymbol{\\kappa} = (\\kappa_{xx}, \\kappa_{yy}, \\kappa_{xy})$ 从插值的转角直接计算。定义 RMS 弯曲误差为\n$$\n\\varepsilon_{\\text{bend}} = \\sqrt{\\frac{\\int_{\\Omega_e} \\left(\\kappa_{xx}^2 + \\kappa_{yy}^2 + \\kappa_{xy}^2\\right)\\, \\mathrm{d}\\Omega}{\\int_{\\Omega_e} \\mathrm{d}\\Omega}},\n$$\n使用二乘二高斯积分法则进行近似计算。\n\n构建一个包含两种单元几何形状的测试套件（节点按逆时针顺序排列）：\n- 几何形状 A（正方形）：节点位于 $(-0.5,-0.5)$、$(0.5,-0.5)$、$(0.5,0.5)$、$(-0.5,0.5)$，坐标单位为 $\\text{m}$。\n- 几何形状 B（高纵横比矩形）：节点位于 $(-2.0,-0.25)$、$(2.0,-0.25)$、$(2.0,0.25)$、$(-2.0,0.25)$，坐标单位为 $\\text{m}$。\n\n对于每种几何形状，计算：\n- 对于纯弯曲场：计算三种单元（标准、减缩积分、MITC）中每一种的 RMS 剪切误差 $\\varepsilon_{\\text{shear}}$。\n- 对于纯剪切场：计算三种单元（标准、减缩积分、MITC）中每一种的 RMS 弯曲误差 $\\varepsilon_{\\text{bend}}$。\n\n您的程序应生成单行输出，其中包含一个由逗号分隔的列表，用方括号括起，按以下顺序包含 $12$ 个浮点数值：\n- 对于几何形状 A：$[\\varepsilon_{\\text{shear}}^{\\text{STD}}, \\varepsilon_{\\text{shear}}^{\\text{RI}}, \\varepsilon_{\\text{shear}}^{\\text{MITC}}, \\varepsilon_{\\text{bend}}^{\\text{STD}}, \\varepsilon_{\\text{bend}}^{\\text{RI}}, \\varepsilon_{\\text{bend}}^{\\text{MITC}}]$。\n- 对于几何形状 B：$[\\varepsilon_{\\text{shear}}^{\\text{STD}}, \\varepsilon_{\\text{shear}}^{\\text{RI}}, \\varepsilon_{\\text{shear}}^{\\text{MITC}}, \\varepsilon_{\\text{bend}}^{\\text{STD}}, \\varepsilon_{\\text{bend}}^{\\text{RI}}, \\varepsilon_{\\text{bend}}^{\\text{MITC}}]$。\n\n所有应变均为无量纲，所有曲率单位均为 $\\text{m}^{-1}$。按指定顺序以十进制浮点数报告数值。最终输出必须是 $[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_{12}]$ 形式的单行文本。", "solution": "所提出的问题是计算力学领域一个定义明确的练习，具体涉及使用 Mindlin-Reissner 理论对板进行有限元分析。它要求通过标准的单元检验（patch test）来实现和验证三种不同的四节点四边形单元格式。该问题具有科学依据，形式规范，且内部逻辑一致。它提供了所有必要的数据，包括运动学关系、单元插值方案、积分规则、用于测试的指定变形场以及精确的误差度量。因此，该问题被认为是有效的，下面给出一个正式的解答。\n\n该解答首先建立等参四节点 Mindlin-Reissner 板单元的理论基础。随后，详细介绍标准（STD）、减缩积分（RI）和张量分量混合插值（MITC）单元的具体格式。最后，实施单元检验程序和误差计算，以生成所需的数值结果。\n\n### 1. Mindlin-Reissner 板理论与运动学\n\nMindlin-Reissner 理论是一种一阶剪切变形板理论。板中面（位于 $x-y$ 平面）的运动状态由三个独立的场描述：横向挠度 $w(x,y)$ 和横截面的两个转角，即绕 $y$ 轴的转角 $\\theta_x(x,y)$ 和绕 $x$ 轴的转角 $\\theta_y(x,y)$。\n\n弯曲曲率（用向量 $\\boldsymbol{\\kappa}$ 表示）和横向剪切应变（用向量 $\\boldsymbol{\\gamma}$ 表示）定义如下：\n$$\n\\boldsymbol{\\kappa} =\n\\begin{Bmatrix} \\kappa_{xx} \\\\ \\kappa_{yy} \\\\ \\kappa_{xy} \\end{Bmatrix} =\n\\begin{Bmatrix} -\\frac{\\partial \\theta_x}{\\partial x} \\\\ -\\frac{\\partial \\theta_y}{\\partial y} \\\\ -(\\frac{\\partial \\theta_x}{\\partial y} + \\frac{\\partial \\theta_y}{\\partial x}) \\end{Bmatrix}\n\\quad , \\quad\n\\boldsymbol{\\gamma} =\n\\begin{Bmatrix} \\gamma_{xz} \\\\ \\gamma_{yz} \\end{Bmatrix} =\n\\begin{Bmatrix} \\theta_x + \\frac{\\partial w}{\\partial x} \\\\ \\theta_y + \\frac{\\partial w}{\\partial y} \\end{Bmatrix}\n$$\n\n### 2. 等参四节点四边形 ($Q4$) 单元\n\n单元几何形状和运动学场是使用定义在母单元正方形域 $[-1,1] \\times [-1,1]$ 上的等参双线性形函数 $N_i(\\xi, \\eta)$ 从节点值插值得到的。四个形函数为：\n$$\nN_1 = \\frac{1}{4}(1-\\xi)(1-\\eta) \\quad, \\quad N_2 = \\frac{1}{4}(1+\\xi)(1-\\eta) \\quad, \\quad N_3 = \\frac{1}{4}(1+\\xi)(1+\\eta) \\quad, \\quad N_4 = \\frac{1}{4}(1-\\xi)(1+\\eta)\n$$\n单元内的物理坐标 $(x,y)$ 和运动学场 $(w, \\theta_x, \\theta_y)$ 由各自的节点值插值得到：\n$$\nx(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) x_i \\quad, \\quad y(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) y_i\n$$\n$$\nw^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) w_i \\quad, \\quad \\theta_x^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{xi} \\quad, \\quad \\theta_y^h(\\xi, \\eta) = \\sum_{i=1}^4 N_i(\\xi, \\eta) \\theta_{yi}\n$$\n上标 $h$ 表示有限元近似。对物理坐标的导数通过链式法则获得，这涉及到雅可比矩阵 $\\boldsymbol{J}$：\n$$\n\\begin{Bmatrix} \\frac{\\partial}{\\partial x} \\\\ \\frac{\\partial}{\\partial y} \\end{Bmatrix} = \\boldsymbol{J}^{-1} \\begin{Bmatrix} \\frac{\\partial}{\\partial \\xi} \\\\ \\frac{\\partial}{\\partial \\eta} \\end{Bmatrix} \\quad \\text{where} \\quad \\boldsymbol{J} = \\begin{bmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\xi} \\\\ \\frac{\\partial x}{\\partial \\eta}  \\frac{\\partial y}{\\partial \\eta} \\end{bmatrix} = \\begin{bmatrix} \\sum \\frac{\\partial N_i}{\\partial \\xi} x_i  \\sum \\frac{\\partial N_i}{\\partial \\xi} y_i \\\\ \\sum \\frac{\\partial N_i}{\\partial \\eta} x_i  \\sum \\frac{\\partial N_i}{\\partial \\eta} y_i \\end{bmatrix}\n$$\n面积微元变换为 $d\\Omega = \\det(\\boldsymbol{J}) d\\xi d\\eta$。对于指定的矩形几何形状，雅可比矩阵 $\\boldsymbol{J}$ 是一个常数对角矩阵。\n\n### 3. 单元格式与应变计算\n\n这三种单元格式在计算横向剪切应变和处理相关的数值积分方面有所不同，这是避免剪切自锁的关键环节。\n\n**标准（STD）单元：** 所有场均采用双线性插值。通过将运动学定义直接应用于插值场来计算应变。任何积分（例如，刚度矩阵或误差范数）中的弯曲项和剪切项都使用完全的 $2 \\times 2$ 高斯求积法则进行计算，积分点位于 $(\\xi, \\eta) = (\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3})$，权重为 $w_g=1$。众所周知，这种格式会遭受严重的剪切自锁，特别是在薄板或扭曲网格的情况下。\n\n**减缩积分（RI）单元：** 此格式与标准单元相同，区别在于涉及横向剪切应变的积分使用位于单元中心 $(\\xi, \\eta) = (0,0)$、权重为 $w_g=4$ 的单点高斯积分进行计算。对于本问题，剪切误差 $\\varepsilon_{\\text{shear}}$ 使用此 $1 \\times 1$ 积分法则计算。与弯曲相关的积分继续使用 $2 \\times 2$ 积分法则。该技术通常能缓解剪切自锁，但有时会引入其他问题，如伪零能模式。\n\n**张量分量混合插值（MITC）单元：** 这是一种更复杂的对抗剪切自锁的方法。虽然弯曲曲率是直接从双线性插值的转角计算得出，但横向剪切应变则源自一个独立的、“绑定的”插值。\n过程如下：\n1.  “原始”横向剪切应变 $(\\gamma_{xz}, \\gamma_{yz})$ 在母单元域中单元边上的特定绑定点处进行计算。对于 $\\gamma_{xz}$，绑定点为 $A: (\\xi=0, \\eta=-1)$ 和 $B: (\\xi=0, \\eta=1)$。对于 $\\gamma_{yz}$，绑定点为 $C: (\\xi=-1, \\eta=0)$ 和 $D: (\\xi=1, \\eta=0)$。\n2.  在这些点上，应变根据标准运动学定义计算，例如 $\\gamma_{xz, A} = \\theta_x^h(A) + \\frac{\\partial w^h}{\\partial x}(A)$。\n3.  然后，使用这些绑定的值在整个单元上插值出一个修正的剪切应变场 $(\\gamma_{xz}^\\ast, \\gamma_{yz}^\\ast)$：\n    $$\n    \\gamma_{xz}^\\ast(\\xi, \\eta) = \\frac{1}{2}(1-\\eta) \\gamma_{xz,A} + \\frac{1}{2}(1+\\eta) \\gamma_{xz,B}\n    $$\n    $$\n    \\gamma_{yz}^\\ast(\\xi, \\eta) = \\frac{1}{2}(1-\\xi) \\gamma_{yz,C} + \\frac{1}{2}(1+\\xi) \\gamma_{yz,D}\n    $$\n4.  剪切误差 $\\varepsilon_{\\text{shear}}$ 是通过使用 $2 \\times 2$ 高斯积分法则对这些修正的应变 $\\gamma^\\ast$ 在单元上进行积分来计算的。\n\n### 4. 单元检验与误差评估\n\n单元检验验证了单元精确再现常数应变状态的能力。这里测试了两种状态：\n- **纯弯曲：** 指定一个具有常曲率 $\\kappa_{xx} = \\kappa_x = 1.0$ 且横向剪切应变为零（$\\gamma_{xz} = \\gamma_{yz}=0$）的场：$w(x,y) = \\frac{1}{2}\\kappa_x x^2$，$\\theta_x(x,y) = -\\kappa_x x$，$\\theta_y(x,y) = 0$。计算数值剪切误差 $\\varepsilon_{\\text{shear}}$。一个理想的单元应得出 $\\varepsilon_{\\text{shear}} = 0$。\n- **纯剪切：** 指定一个具有常剪切应变 $\\gamma_{xz} = \\gamma_0 = 1.0$ 且曲率为零（$\\kappa_{xx} = \\kappa_{yy} = \\kappa_{xy} = 0$）的场：$w(x,y)=0$，$\\theta_x(x,y)=\\gamma_0$，$\\theta_y(x,y)=0$。计算数值弯曲误差 $\\varepsilon_{\\text{bend}}$。一个理想的单元应得出 $\\varepsilon_{\\text{bend}} = 0$。\n\n对于每个测试，节点值 $(w_i, \\theta_{xi}, \\theta_{yi})$ 是通过在单元的物理节点坐标处评估指定的解析场来获得的。\n\n误差通过均方根（RMS）度量进行量化，并通过数值积分计算：\n$$\n\\varepsilon_{\\text{shear}} = \\sqrt{\\frac{\\sum_{g} (\\gamma_{xz}^2 + \\gamma_{yz}^2)_g w_g \\det(\\boldsymbol{J}_g)}{\\sum_{g} w_g \\det(\\boldsymbol{J}_g)}} \\quad , \\quad \\varepsilon_{\\text{bend}} = \\sqrt{\\frac{\\sum_{g} (\\kappa_{xx}^2 + \\kappa_{yy}^2 + \\kappa_{xy}^2)_g w_g \\det(\\boldsymbol{J}_g)}{\\sum_{g} w_g \\det(\\boldsymbol{J}_g)}}\n$$\n求和是针对为每种单元类型和应变分量指定的高斯点 $g$ 进行的。项 $\\gamma$ 对于 STD 和 RI 单元指的是直接计算的剪切应变，对于 MITC 单元则指的是绑定的应变 $\\gamma^\\ast$。\n\n### 5. 算法实现\n\nPython 代码实现了这些过程。一个主循环遍历两种指定的几何形状。对于每种几何形状，它执行两个单元检验。\n1.  **纯弯曲测试：**\n    - 节点自由度由纯弯曲场方程计算得出。\n    - 使用各自的应变计算和积分规则，为 STD、RI 和 MITC 单元计算剪切误差 $\\varepsilon_{\\text{shear}}$。\n2.  **纯剪切测试：**\n    - 节点自由度由纯剪切场方程计算得出。\n    - 使用 $2 \\times 2$ 高斯积分法则为所有三个单元计算弯曲误差 $\\varepsilon_{\\text{bend}}$。\n\n对于给定的简单矩形几何形状，纯剪切场的有限元近似是精确的，导致所有单元类型的弯曲误差均为零。对于纯弯曲场，双线性单元无法精确表示二次挠度 $w=\\frac{1}{2}\\kappa_x x^2$，这会导致寄生剪切应变。标准单元表现出非零的剪切误差，显示出剪切自锁。减缩积分和 MITC 格式旨在纠正这一缺陷，并且对于矩形单元，预期它们能以零误差通过此测试。代码的结果与这些理论预期一致。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares three Q4 Mindlin-Reissner plate elements\n    (Standard, Reduced Integration, MITC) in a patch test.\n    \"\"\"\n    \n    # --- Constants and Test Case Definitions ---\n    KAPPA_X = 1.0  # m^-1\n    GAMMA_0 = 1.0  # dimensionless\n\n    # Gauss points and weights for 2x2 integration\n    gp_val = 1.0 / np.sqrt(3.0)\n    GAUSS_2x2 = {\n        'points': [\n            (-gp_val, -gp_val), (gp_val, -gp_val),\n            (gp_val, gp_val), (-gp_val, gp_val)\n        ],\n        'weights': [1.0, 1.0, 1.0, 1.0]\n    }\n    \n    # Gauss point and weight for 1x1 integration\n    GAUSS_1x1 = {\n        'points': [(0.0, 0.0)],\n        'weights': [4.0]\n    }\n\n    geometries = {\n        'A': np.array([\n            [-0.5, -0.5], [0.5, -0.5], [0.5, 0.5], [-0.5, 0.5]\n        ]),\n        'B': np.array([\n            [-2.0, -0.25], [2.0, -0.25], [2.0, 0.25], [-2.0, 0.25]\n        ])\n    }\n\n    # --- Core FEM Helper Functions ---\n\n    def get_shape_functions(xi, eta):\n        \"\"\"Returns bilinear shape functions and their derivatives in parent coords.\"\"\"\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        dNdxi = 0.25 * np.array([\n            -(1 - eta), (1 - eta), (1 + eta), -(1 + eta)\n        ])\n        dNdeta = 0.25 * np.array([\n            -(1 - xi), -(1 + xi), (1 + xi), (1 - xi)\n        ])\n        return N, dNdxi, dNdeta\n\n    def get_jacobian_and_physical_grads(xi, eta, nodes):\n        \"\"\"Computes Jacobian, its determinant, and shape function grads in physical coords.\"\"\"\n        _, dNdxi, dNdeta = get_shape_functions(xi, eta)\n        \n        # Jacobian matrix J = [[dx/dxi, dy/dxi], [dx/deta, dy/deta]]\n        J = np.zeros((2, 2))\n        J[0, 0] = np.dot(dNdxi, nodes[:, 0])\n        J[0, 1] = np.dot(dNdxi, nodes[:, 1])\n        J[1, 0] = np.dot(dNdeta, nodes[:, 0])\n        J[1, 1] = np.dot(dNdeta, nodes[:, 1])\n        \n        detJ = np.linalg.det(J)\n        if detJ = 0:\n            raise ValueError(\"Jacobian determinant is non-positive.\")\n        \n        J_inv = np.linalg.inv(J)\n        \n        # Gradients of shape functions w.r.t physical coordinates (x, y)\n        dG = np.vstack((dNdxi, dNdeta)) # shape (2, 4)\n        dN_dxy = J_inv @ dG # shape (2, 4)\n        dNdx = dN_dxy[0, :]\n        dNdy = dN_dxy[1, :]\n        \n        return detJ, dNdx, dNdy\n\n    # --- Element-Specific Calculation Functions ---\n\n    def calculate_errors(nodes, nodal_dofs):\n        \"\"\"\n        Calculates shear and bending errors for all three element formulations.\n        \"\"\"\n        w_nodal = nodal_dofs[:, 0]\n        th_x_nodal = nodal_dofs[:, 1]\n        th_y_nodal = nodal_dofs[:, 2]\n\n        # --- Quantities for STD and RI elements ---\n        num_shear_std, den_shear_std = 0.0, 0.0\n        num_shear_ri, den_shear_ri = 0.0, 0.0\n        num_bend_std_ri, den_bend_std_ri = 0.0, 0.0\n        \n        # Bending error (and shear for STD) uses 2x2 Gauss rule\n        for i, (xi, eta) in enumerate(GAUSS_2x2['points']):\n            w_gp = GAUSS_2x2['weights'][i]\n            N, _, _ = get_shape_functions(xi, eta)\n            detJ, dNdx, dNdy = get_jacobian_and_physical_grads(xi, eta, nodes)\n            \n            # Interpolated rotations\n            th_x = np.dot(N, th_x_nodal)\n            th_y = np.dot(N, th_y_nodal)\n            \n            # Bending curvatures\n            k_xx = -np.dot(dNdx, th_x_nodal)\n            k_yy = -np.dot(dNdy, th_y_nodal)\n            k_xy = -(np.dot(dNdy, th_x_nodal) + np.dot(dNdx, th_y_nodal))\n            \n            # Direct shear strains\n            gam_xz = th_x + np.dot(dNdx, w_nodal)\n            gam_yz = th_y + np.dot(dNdy, w_nodal)\n            \n            num_bend_std_ri += (k_xx**2 + k_yy**2 + k_xy**2) * w_gp * detJ\n            den_bend_std_ri += w_gp * detJ\n            \n            num_shear_std += (gam_xz**2 + gam_yz**2) * w_gp * detJ\n            den_shear_std += w_gp * detJ\n\n        # Shear error for RI uses 1x1 Gauss rule\n        xi_ri, eta_ri = GAUSS_1x1['points'][0]\n        w_gp_ri = GAUSS_1x1['weights'][0]\n        N_ri, _, _ = get_shape_functions(xi_ri, eta_ri)\n        detJ_ri, dNdx_ri, dNdy_ri = get_jacobian_and_physical_grads(xi_ri, eta_ri, nodes)\n        \n        th_x_ri = np.dot(N_ri, th_x_nodal)\n        gam_xz_ri = th_x_ri + np.dot(dNdx_ri, w_nodal)\n        th_y_ri = np.dot(N_ri, th_y_nodal)\n        gam_yz_ri = th_y_ri + np.dot(dNdy_ri, w_nodal)\n        \n        num_shear_ri = (gam_xz_ri**2 + gam_yz_ri**2) * w_gp_ri * detJ_ri\n        den_shear_ri = w_gp_ri * detJ_ri\n\n        eps_shear_std = np.sqrt(num_shear_std / den_shear_std)\n        eps_shear_ri = np.sqrt(num_shear_ri / den_shear_ri)\n        eps_bend_std = np.sqrt(num_bend_std_ri / den_bend_std_ri)\n        eps_bend_ri = eps_bend_std # Same bending formulation\n\n        # --- Quantities for MITC element ---\n        tying_points = {\n            'A': (0.0, -1.0), 'B': (0.0, 1.0), # for gamma_xz\n            'C': (-1.0, 0.0), 'D': (1.0, 0.0)  # for gamma_yz\n        }\n        \n        tied_strains = {}\n        for name, (xi, eta) in tying_points.items():\n            N, _, _ = get_shape_functions(xi, eta)\n            _, dNdx, dNdy = get_jacobian_and_physical_grads(xi, eta, nodes)\n            th_x = np.dot(N, th_x_nodal)\n            th_y = np.dot(N, th_y_nodal)\n            gam_xz = th_x + np.dot(dNdx, w_nodal)\n            gam_yz = th_y + np.dot(dNdy, w_nodal)\n            tied_strains[name] = (gam_xz, gam_yz)\n        \n        gam_xz_A = tied_strains['A'][0]\n        gam_xz_B = tied_strains['B'][0]\n        gam_yz_C = tied_strains['C'][1]\n        gam_yz_D = tied_strains['D'][1]\n\n        num_shear_mitc, den_shear_mitc = 0.0, 0.0\n        for i, (xi, eta) in enumerate(GAUSS_2x2['points']):\n            w_gp = GAUSS_2x2['weights'][i]\n            detJ, _, _ = get_jacobian_and_physical_grads(xi, eta, nodes)\n            \n            # Interpolated tied shear strains\n            gam_xz_star = 0.5 * (1 - eta) * gam_xz_A + 0.5 * (1 + eta) * gam_xz_B\n            gam_yz_star = 0.5 * (1 - xi) * gam_yz_C + 0.5 * (1 + xi) * gam_yz_D\n            \n            num_shear_mitc += (gam_xz_star**2 + gam_yz_star**2) * w_gp * detJ\n            den_shear_mitc += w_gp * detJ\n        \n        eps_shear_mitc = np.sqrt(num_shear_mitc / den_shear_mitc)\n        eps_bend_mitc = eps_bend_std # Same bending formulation\n        \n        return {\n            'shear_std': eps_shear_std, 'shear_ri': eps_shear_ri, 'shear_mitc': eps_shear_mitc,\n            'bend_std': eps_bend_std, 'bend_ri': eps_bend_ri, 'bend_mitc': eps_bend_mitc\n        }\n\n    # --- Main Calculation Loop ---\n    all_results = []\n    \n    for geom_name in sorted(geometries.keys()):\n        nodes = geometries[geom_name]\n        \n        # 1. Pure Bending Patch Test (compute shear error)\n        dofs_bending_test = np.zeros((4, 3))\n        dofs_bending_test[:, 0] = 0.5 * KAPPA_X * nodes[:, 0]**2  # w\n        dofs_bending_test[:, 1] = -KAPPA_X * nodes[:, 0]        # theta_x\n        dofs_bending_test[:, 2] = 0.0                           # theta_y\n        \n        errors_bending_test = calculate_errors(nodes, dofs_bending_test)\n        all_results.append(errors_bending_test['shear_std'])\n        all_results.append(errors_bending_test['shear_ri'])\n        all_results.append(errors_bending_test['shear_mitc'])\n        \n        # 2. Pure Shear Patch Test (compute bending error)\n        dofs_shear_test = np.zeros((4, 3))\n        dofs_shear_test[:, 0] = 0.0                             # w\n        dofs_shear_test[:, 1] = GAMMA_0                         # theta_x\n        dofs_shear_test[:, 2] = 0.0                             # theta_y\n        \n        errors_shear_test = calculate_errors(nodes, dofs_shear_test)\n        all_results.append(errors_shear_test['bend_std'])\n        all_results.append(errors_shear_test['bend_ri'])\n        all_results.append(errors_shear_test['bend_mitc'])\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.15g}' for r in all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2588738"}]}