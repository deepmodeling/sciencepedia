{"hands_on_practices": [{"introduction": "剪切锁定是梁和板壳单元中的一个经典数值问题，当结构变薄时，低阶单元会表现出过于刚硬的行为。这个实践练习将通过一个具体的数值实验来揭示这一现象。你将亲手实现一个线性Timoshenko梁单元，并观察其在不同长厚比下的收敛行为，从而直观地理解剪切锁定的成因及其对计算结果的影响 [@problem_id:2595579]。", "problem": "考虑一个长度为 $L$ 的棱柱形矩形截面悬臂梁的 Timoshenko 梁模型，其自由端承受横向点载荷 $P$。截面单位宽度 $b=1$，厚度为 $t$。材料的杨氏模量为 $E$，剪切模量为 $G$。Timoshenko 运动学采用横向位移场 $w(x)$ 和截面转角 $\\varphi(x)$。弯曲曲率为 $\\kappa_b(x)=\\dfrac{d\\varphi}{dx}$，剪切应变为 $\\gamma(x)=\\dfrac{dw}{dx}-\\varphi(x)$。一个区间上的应变能是弯曲和剪切贡献之和。抗弯刚度为 $E I$，其中 $I=\\dfrac{b t^3}{12}$，抗剪刚度为 $\\kappa_s G A$，其中 $A=b\\,t$，对于矩形截面，剪切修正因子 $\\kappa_s=\\dfrac{5}{6}$。在端部载荷 $P$ 作用下，悬臂梁的精确 Timoshenko 尖端挠度由弯曲部分和剪切部分之和给出。本问题中所有量均为无量纲，因此答案中无需物理单位。\n\n您将在均匀网格上使用线性的二节点 Timoshenko 梁单元实现一个有限元模型。每个节点有两个自由度：横向位移 $w$ 和截面转角 $\\varphi$。使用最小势能原理和标准的有限元组集过程。对于长度为 $\\ell_e$ 的单个单元，用线性形函数 $N_1(x)=1-\\dfrac{x}{\\ell_e}$ 和 $N_2(x)=\\dfrac{x}{\\ell_e}$ 来近似 $w(x)$ 和 $\\varphi(x)$，即\n$$\nw(x)=N_1(x)\\,w_1+N_2(x)\\,w_2,\\quad \\varphi(x)=N_1(x)\\,\\varphi_1+N_2(x)\\,\\varphi_2.\n$$\n从定义 $\\kappa_b(x)=\\dfrac{d\\varphi}{dx}$ 和 $\\gamma(x)=\\dfrac{dw}{dx}-\\varphi(x)$ 出发，通过在单元上对应变能密度的二次型进行积分，推导出单元刚度矩阵。为悬臂梁组集全局刚度矩阵，其固支端在 $x=0$ 处（施加 $w(0)=0$ 和 $\\varphi(0)=0$），在 $x=L$ 处仅在横向施加尖端载荷 $P$。求解该线性系统以获得节点未知数，并提取尖端位移的有限元近似值 $w_{\\mathrm{FE}}$（在 $x=L$ 处）。\n\n设计一个数值实验来量化尖端位移的收敛性并诊断剪切自锁。使用以下参数：\n- $L=10$，$E=1$，$G=1$，$\\kappa_s=\\dfrac{5}{6}$，$b=1$，$P=1$，以及 $t\\in\\{1,0.1,0.01\\}$。\n- 对于每个厚度 $t$，在单元数量为 $n_e\\in\\{1,2,4,8,16,32\\}$ 的均匀网格上计算 $w_{\\mathrm{FE}}$。\n- 对于每种情况，也计算精确的 Timoshenko 尖端挠度\n$$\nw_{\\mathrm{exact}}=\\frac{P\\,L^3}{3\\,E\\,I}+\\frac{P\\,L}{\\kappa_s\\,G\\,A}.\n$$\n通过比率 $r(n_e,t)=\\dfrac{w_{\\mathrm{FE}}(n_e,t)}{w_{\\mathrm{exact}}(t)}$ 来量化每组 $n_e$ 和 $t$ 的收敛性。您的程序必须为所有网格和所有三种厚度输出这些比率。\n\n测试套件和要求的最终输出格式：\n- 测试套件是 $t\\in\\{1,0.1,0.01\\}$ 和 $n_e\\in\\{1,2,4,8,16,32\\}$ 的笛卡尔积。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其中外层列表包含三个内层列表，每个内层列表对应一个厚度值，顺序为 $t=1$，$t=0.1$，$t=0.01$。每个内层列表必须按 $n_e=1,2,4,8,16,32$ 的顺序包含六个浮点数比率 $r(n_e,t)$。例如，使用占位符值的输出将如下所示：\n$$\n[[r_{1,1},r_{2,1},r_{4,1},r_{8,1},r_{16,1},r_{32,1}],[r_{1,0.1},r_{2,0.1},r_{4,0.1},r_{8,0.1},r_{16,0.1},r_{32,0.1}],[r_{1,0.01},r_{2,0.01},r_{4,0.01},r_{8,0.01},r_{16,0.01},r_{32,0.01}]].\n$$\n不要打印任何其他文本。这些值必须通过如上所述组集和求解有限元系统来计算。\n\n您的任务：\n- 根据基本运动学定义和能量表达式，实现线性 Timoshenko 单元的有限元组集。\n- 为指定的测试套件计算 $w_{\\mathrm{FE}}$ 和 $r(n_e,t)$。\n- 以指定的精确格式生成最终输出，仅包含比率的嵌套列表。\n- 运行程序后，解释 $r(n_e,t)$ 随 $n_e$ 和 $t$ 变化的趋势，作为剪切自锁的证据：持续的低估，即 $r(n_e,t) \\ll 1$，并且随着 $t$ 减小，网格细化带来的改善缓慢，这是剪切自锁的特征。您无需打印此解释；下面的解析解撰写部分需要它。", "solution": "所提出的问题是计算力学中的一个标准练习，用于演示在 Timoshenko 梁的有限元分析中被称为剪切自锁的数值伪影。它是科学上合理、适定且完整的。我将继续进行推导和求解。\n\n有限元方法的基础是最小势能原理。梁的总势能 $\\Pi$ 是内应变能 $U$ 减去外力所做的功 $W_e$ 的总和。对于我们的问题，\n$$ \\Pi = U - W_e = \\frac{1}{2} \\int_0^L \\left( EI (\\kappa_b(x))^2 + \\kappa_s G A (\\gamma(x))^2 \\right) dx - P w(L) $$\n其中 $L$ 是梁长，$E$ 是杨氏模量，$I$ 是截面二次矩，$G$ 是剪切模量，$A$ 是截面积，$\\kappa_s$ 是剪切修正因子，$P$ 是在自由端 $x=L$ 处的点载荷。运动学变量是横向位移 $w(x)$ 和截面转角 $\\varphi(x)$。弯曲曲率为 $\\kappa_b(x) = \\frac{d\\varphi}{dx}$，剪切应变为 $\\gamma(x) = \\frac{dw}{dx} - \\varphi(x)$。\n\n我们将梁离散化为 $n_e$ 个有限单元。对于一个长度为 $\\ell_e$，局部坐标为 $\\bar{x} \\in [0, \\ell_e]$ 的二节点单元，场量 $w(\\bar{x})$ 和 $\\varphi(\\bar{x})$ 由节点自由度插值得到。单元的节点位移向量为 $\\mathbf{d}_e = [w_1, \\varphi_1, w_2, \\varphi_2]^T$。我们使用指定的线性形函数 $N_1(\\bar{x}) = 1 - \\frac{\\bar{x}}{\\ell_e}$ 和 $N_2(\\bar{x}) = \\frac{\\bar{x}}{\\ell_e}$。\n$$ w(\\bar{x}) = N_1(\\bar{x}) w_1 + N_2(\\bar{x}) w_2 $$\n$$ \\varphi(\\bar{x}) = N_1(\\bar{x}) \\varphi_1 + N_2(\\bar{x}) \\varphi_2 $$\n关于 $\\bar{x}$ 的导数为：\n$$ \\frac{dw}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} w_1 + \\frac{d N_2}{d\\bar{x}} w_2 = -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 $$\n$$ \\frac{d\\varphi}{d\\bar{x}} = \\frac{d N_1}{d\\bar{x}} \\varphi_1 + \\frac{d N_2}{d\\bar{x}} \\varphi_2 = -\\frac{1}{\\ell_e} \\varphi_1 + \\frac{1}{\\ell_e} \\varphi_2 $$\n弯曲曲率 $\\kappa_b$ 在单元内是常数：\n$$ \\kappa_b(\\bar{x}) = \\frac{d\\varphi}{d\\bar{x}} = \\frac{1}{\\ell_e} (-\\varphi_1 + \\varphi_2) = \\begin{bmatrix} 0  -\\frac{1}{\\ell_e}  0  \\frac{1}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_b \\mathbf{d}_e $$\n剪切应变 $\\gamma$ 在单元内是线性的：\n$$ \\gamma(\\bar{x}) = \\frac{dw}{d\\bar{x}} - \\varphi(\\bar{x}) = \\left( -\\frac{1}{\\ell_e} w_1 + \\frac{1}{\\ell_e} w_2 \\right) - \\left( (1-\\frac{\\bar{x}}{\\ell_e}) \\varphi_1 + \\frac{\\bar{x}}{\\ell_e} \\varphi_2 \\right) $$\n$$ \\gamma(\\bar{x}) = \\begin{bmatrix} -\\frac{1}{\\ell_e}  -(1-\\frac{\\bar{x}}{\\ell_e})  \\frac{1}{\\ell_e}  -\\frac{\\bar{x}}{\\ell_e} \\end{bmatrix} \\mathbf{d}_e = \\mathbf{B}_s(\\bar{x}) \\mathbf{d}_e $$\n单元应变能 $U_e$ 由 $U_e = \\frac{1}{2} \\mathbf{d}_e^T \\mathbf{K}_e \\mathbf{d}_e$ 给出，其中单元刚度矩阵 $\\mathbf{K}_e$ 是抗弯刚度 $\\mathbf{K}_b$ 和抗剪刚度 $\\mathbf{K}_s$ 的和：\n$$ \\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s = \\int_0^{\\ell_e} \\mathbf{B}_b^T E I \\mathbf{B}_b d\\bar{x} + \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\kappa_s G A \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\n抗弯刚度矩阵计算如下：\n$$ \\mathbf{K}_b = E I \\int_0^{\\ell_e} \\frac{1}{\\ell_e^2} \\begin{bmatrix} 0  0  0  0 \\\\ 0  1  0  -1 \\\\ 0  0  0  0 \\\\ 0  -1  0  1 \\end{bmatrix} d\\bar{x} = \\frac{EI}{\\ell_e} \\begin{bmatrix} 0  0  0  0 \\\\ 0  1  0  -1 \\\\ 0  0  0  0 \\\\ 0  -1  0  1 \\end{bmatrix} $$\n抗剪刚度矩阵需要对 $\\mathbf{B}_s(\\bar{x})$ 的二次型进行积分：\n$$ \\mathbf{K}_s = \\kappa_s G A \\int_0^{\\ell_e} \\mathbf{B}_s(\\bar{x})^T \\mathbf{B}_s(\\bar{x}) d\\bar{x} $$\n逐项积分后得到：\n$$ \\mathbf{K}_s = \\kappa_s G A \\begin{bmatrix} 1/\\ell_e  1/2  -1/\\ell_e  1/2 \\\\ 1/2  \\ell_e/3  -1/2  \\ell_e/6 \\\\ -1/\\ell_e  -1/2  1/\\ell_e  -1/2 \\\\ 1/2  \\ell_e/6  -1/2  \\ell_e/3 \\end{bmatrix} $$\n然后将总单元刚度矩阵 $\\mathbf{K}_e = \\mathbf{K}_b + \\mathbf{K}_s$ 组集到整个梁的全局刚度矩阵 $\\mathbf{K}$ 中，该梁包含 $n_e$ 个单元和 $n_e+1$ 个节点。全局方程组为 $\\mathbf{K}\\mathbf{D} = \\mathbf{F}$，其中 $\\mathbf{D}$ 是所有节点位移和转角的向量，$\\mathbf{F}$ 是全局力向量。\n\n对于在 $x=0$ 处固支的悬臂梁，边界条件是 $w(0)=0$ 和 $\\varphi(0)=0$。这些对应于全局系统中的前两个自由度 $D_0$ 和 $D_1$。我们通过修改系统矩阵和向量来施加这些约束，通常是将相应的行和列设置为零（对角线上的元素设为1），并将相应的力分量设置为零。在自由端 $x=L$ 处施加横向点载荷 $P$。这对应于最后一个节点 $n_e$。将力 $P$ 加到与该节点横向位移相关的 $\\mathbf{F}$ 分量上。\n\n求解修改后的线性系统得到 $\\mathbf{D}$ 后，我们提取尖端位移的有限元近似值 $w_{\\mathrm{FE}}$，它是 $\\mathbf{D}$ 中对应于节点 $n_e$ 处横向位移的分量。\n\n将此解与精确的 Timoshenko 解进行比较：\n$$ w_{\\mathrm{exact}}=\\frac{P L^3}{3 E I}+\\frac{P L}{\\kappa_s G A} $$\n比率 $r(n_e, t) = w_{\\mathrm{FE}}(n_e, t) / w_{\\mathrm{exact}}(t)$ 用于量化收敛性。参数 $t$ 是梁的厚度，它通过 $A=bt$ 和 $I=bt^3/12$ 进入计算。对于本问题，$b=1$，因此 $A=t$ 且 $I=t^3/12$。\n\n当梁变薄时（即长厚比 $L/t$ 很大时），会出现剪切自锁现象。在薄梁极限下，真实的剪切应变 $\\gamma = dw/dx - \\varphi$ 应趋近于零。然而，我们对 $w$ 和 $\\varphi$ 都使用线性插值的有限元公式迫使 $\\gamma$ 成为 $\\bar{x}$ 的线性函数，而弯曲主导的状态要求 $\\varphi$ 线性变化，因此 $dw/dx$ 应二次变化。线性单元无法正确表示这一点。为了最小化巨大的剪切能项（与 $\\kappa_s G A \\sim t$ 成正比），单元的自由度受到伪约束，迫使 $\\gamma(\\bar{x})$ 在各处都趋于零。这迫使 $\\varphi$ 在单元内几乎保持恒定，从而“锁定”了它，阻止其正常弯曲。这导致了人为的过刚响应和计算出的位移 $w_{\\mathrm{FE}}$ 被严重低估。\n\n数值结果将证明这一点。对于厚梁（$t=1$），收敛会很快（$r \\to 1$ 迅速）。对于薄梁（$t=0.1$，尤其是 $t=0.01$），对于粗网格（$n_e$ 小），比率 $r$ 将非常小，并且只有在网格细化时才会缓慢接近 $1$。这种对薄结构的不良收敛性是剪切自锁的标志。下面的实现将精确地量化此行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Timoshenko beam problem using FEM and analyzes shear locking.\n    \"\"\"\n    # Problem Constants\n    L = 10.0\n    E = 1.0\n    G = 1.0\n    ks = 5.0 / 6.0\n    b = 1.0\n    P = 1.0\n\n    # Test Suite Parameters\n    thicknesses = [1.0, 0.1, 0.01]\n    n_elements_list = [1, 2, 4, 8, 16, 32]\n\n    results = []\n\n    for t in thicknesses:\n        # Geometric and Material Properties for the current thickness\n        A = b * t\n        I = b * t**3 / 12.0\n        \n        # Calculate the exact Timoshenko tip deflection\n        # Bending part + Shear part\n        w_exact = (P * L**3) / (3.0 * E * I) + (P * L) / (ks * G * A)\n\n        ratios_for_t = []\n        for ne in n_elements_list:\n            le = L / ne\n            num_nodes = ne + 1\n            num_dofs = 2 * num_nodes\n\n            # Calculate element stiffness matrix Ke = Kb + Ks\n            # Bending stiffness matrix Kb\n            Kb = (E * I / le) * np.array([\n                [0, 0, 0, 0],\n                [0, 1, 0, -1],\n                [0, 0, 0, 0],\n                [0, -1, 0, 1]\n            ])\n\n            # Shear stiffness matrix Ks\n            Ks_factor = ks * G * A\n            Ks_geom = np.array([\n                [1.0/le, 0.5, -1.0/le, 0.5],\n                [0.5, le/3.0, -0.5, le/6.0],\n                [-1.0/le, -0.5, 1.0/le, -0.5],\n                [0.5, le/6.0, -0.5, le/3.0]\n            ])\n            Ks = Ks_factor * Ks_geom\n            \n            Ke = Kb + Ks\n\n            # Assemble global stiffness matrix K and force vector F\n            K_global = np.zeros((num_dofs, num_dofs))\n            F_global = np.zeros(num_dofs)\n\n            for i in range(ne):\n                # Global DOFs for element i (nodes i and i+1)\n                dof_map = [2*i, 2*i + 1, 2*(i+1), 2*(i+1) + 1]\n                for row_loc in range(4):\n                    for col_loc in range(4):\n                        row_glob = dof_map[row_loc]\n                        col_glob = dof_map[col_loc]\n                        K_global[row_glob, col_glob] += Ke[row_loc, col_loc]\n\n            # Apply point load P at the free end (node ne)\n            # The DOF is for transverse displacement 'w' at the last node.\n            F_global[2*ne] = P\n\n            # Apply boundary conditions (clamped at x=0, node 0)\n            # w(0) = 0 and phi(0) = 0\n            # This corresponds to DOFs 0 and 1.\n            K_global[0, :] = 0.0\n            K_global[:, 0] = 0.0\n            K_global[0, 0] = 1.0\n            F_global[0] = 0.0\n\n            K_global[1, :] = 0.0\n            K_global[:, 1] = 0.0\n            K_global[1, 1] = 1.0\n            F_global[1] = 0.0\n            \n            # Solve the linear system KU=F\n            D = np.linalg.solve(K_global, F_global)\n\n            # Extract tip displacement w_FE at x=L (node ne)\n            w_fe = D[2*ne]\n\n            # Calculate the ratio\n            ratio = w_fe / w_exact\n            ratios_for_t.append(ratio)\n        \n        results.append(ratios_for_t)\n\n    # Format the output string as specified\n    output_str = \"[\"\n    for i, t_results in enumerate(results):\n        output_str += f\"[{','.join(map(str, t_results))}]\"\n        if i  len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```", "id": "2595579"}, {"introduction": "在观察到剪切锁定现象后，一个关键问题是如何系统性地检验一个单元的性能，以确保其在薄结构分析中的可靠性。“分片检验”（Patch Test）正是为此目的而设计的黄金标准。在这个练习中，你将学习如何为Reissner-Mindlin板单元构建一个剪切分片检验，通过定义特定的运动场来创造一个纯剪切状态，从而检验单元是否能准确地再现这一基本变形模式 [@problem_id:2595605]。", "problem": "考虑一个在有限元法 (FEM) 中使用的、具有 4 个节点的单 isoparametric 四边形 Reissner–Mindlin (RM) 板单元（通常称为双线性 QUAD 单元）。该单元采用选择性减缩积分 (SRI)：弯曲项和薄膜项采用 $2\\times 2$ 高斯求积进行积分，而横向剪切项则在单元中心采用 $1\\times 1$ 高斯求积进行积分。在小变形情况下，RM 板的运动学由横向位移 $w(x,y)$ 以及法线分别绕 y 轴和 x 轴的转角 $\\theta_x(x,y)$ 和 $\\theta_y(x,y)$ 来表征。将横向剪切应变和弯曲曲率定义为\n$$\n\\gamma_{xz} = \\theta_x - \\frac{\\partial w}{\\partial x}, \\quad \\gamma_{yz} = \\theta_y - \\frac{\\partial w}{\\partial y},\n$$\n$$\n\\kappa_x = \\frac{\\partial \\theta_x}{\\partial x}, \\quad \\kappa_y = \\frac{\\partial \\theta_y}{\\partial y}, \\quad \\kappa_{xy} = \\frac{\\partial \\theta_x}{\\partial y} + \\frac{\\partial \\theta_y}{\\partial x}.\n$$\n剪切斑块检验旨在验证单元是否能够精确再现一个具有恒定、预设横向剪切应变和零弯曲曲率的状态。设目标剪切状态为\n$$\n\\gamma_{xz} = \\gamma_{xz}^0, \\quad \\gamma_{yz} = \\gamma_{yz}^0,\n$$\n其中 $\\gamma_{xz}^0, \\gamma_{yz}^0$ 为常数，并设目标弯曲状态为\n$$\n\\kappa_x = 0, \\quad \\kappa_y = 0, \\quad \\kappa_{xy} = 0.\n$$\n在以下哪种方案中，正确地用运动学场 $w(x,y)$、$\\theta_x(x,y)$、$\\theta_y(x,y)$ 构造了这样一个剪切斑块检验，并正确地指出了在该所述的 SRI 方案下，单元必须在哪些采样点上精确再现剪切应变才能通过该检验？\n\nA. 选择 $w(x,y) = a\\,x + b\\,y + c$，$\\theta_x(x,y) = \\theta_x^0$，$\\theta_y(x,y) = \\theta_y^0$，并选择常数 $a,b,c,\\theta_x^0,\\theta_y^0$ 使得 $\\theta_x^0 - a = \\gamma_{xz}^0$ 且 $\\theta_y^0 - b = \\gamma_{yz}^0$，这会得到 $\\kappa_x=\\kappa_y=\\kappa_{xy}=0$ 和恒定的 $\\gamma_{xz},\\gamma_{yz}$；要求在剪切求积点 $(\\xi,\\eta)=(0,0)$ 处精确再现 $\\gamma_{xz},\\gamma_{yz}$。\n\nB. 选择 $w(x,y) = \\tfrac{1}{2}a\\,x^2 + \\tfrac{1}{2}b\\,y^2$，$\\theta_x(x,y)=0$，$\\theta_y(x,y)=0$，这确保了 $\\kappa_x=\\kappa_y=\\kappa_{xy}=0$ 和恒定的 $\\gamma_{xz},\\gamma_{yz}$；要求在所有单元节点上精确再现 $\\gamma_{xz},\\gamma_{yz}$。\n\nC. 选择 $w(x,y) = 0$，$\\theta_x(x,y) = \\alpha\\,x$，$\\theta_y(x,y) = \\beta\\,y$，并选择常数 $\\alpha,\\beta$ 使得 $\\gamma_{xz}=\\gamma_{xz}^0$ 且 $\\gamma_{yz}=\\gamma_{yz}^0$；要求在 $2\\times 2$ 高斯点 $(\\xi,\\eta)=\\left(\\pm \\frac{1}{\\sqrt{3}},\\pm \\frac{1}{\\sqrt{3}}\\right)$ 处精确再现 $\\gamma_{xz},\\gamma_{yz}$。\n\nD. 选择 $w(x,y) = a\\,x + b\\,y + c$，$\\theta_x(x,y) = a$，$\\theta_y(x,y) = b$，这使得 $\\gamma_{xz},\\gamma_{yz}$ 恒定且等于 $\\gamma_{xz}^0,\\gamma_{yz}^0$；要求在弯曲求积点 $(\\xi,\\eta)=\\left(\\pm \\frac{1}{\\sqrt{3}},\\pm \\frac{1}{\\sqrt{3}}\\right)$ 处精确再现。", "solution": "用户要求对问题陈述进行验证并提供后续解答。\n\n**问题陈述验证**\n\n首先，我将根据指定的程序验证问题陈述。\n\n**步骤 1：提取已知条件**\n- **单元：**一个 4 节点等参四边形 Reissner-Mindlin (RM) 板单元（双线性 QUAD）。\n- **积分：**采用选择性减缩积分 (SRI)。\n  - 弯曲/薄膜项：$2 \\times 2$ 高斯求积。\n  - 横向剪切项：在单元中心进行 $1 \\times 1$ 高斯求积。\n- **运动学：** 场为横向位移 $w(x,y)$ 和转角 $\\theta_x(x,y)$, $\\theta_y(x,y)$。\n- **应变定义：**\n  - 剪切应变：$\\gamma_{xz} = \\theta_x - \\frac{\\partial w}{\\partial x}$，$\\gamma_{yz} = \\theta_y - \\frac{\\partial w}{\\partial y}$。\n  - 曲率：$\\kappa_x = \\frac{\\partial \\theta_x}{\\partial x}$，$\\kappa_y = \\frac{\\partial \\theta_y}{\\partial y}$，$\\kappa_{xy} = \\frac{\\partial \\theta_x}{\\partial y} + \\frac{\\partial \\theta_y}{\\partial x}$。\n- **斑块检验目标：**单元必须精确再现一个具有恒定预设横向剪切应变和零弯曲曲率的状态。\n- **目标状态：**\n  - $\\gamma_{xz} = \\gamma_{xz}^0$，$\\gamma_{yz} = \\gamma_{yz}^0$（常数）。\n  - $\\kappa_x = 0$，$\\kappa_y = 0$，$\\kappa_{xy} = 0$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据。Reissner-Mindlin 板理论、4 节点四边形单元的使用、选择性减缩积分以及斑块检验的概念都是计算固体力学和有限元法 (FEM) 领域的标准和基础课题。所提供的应变和曲率定义是正确的。问题提法得当，为确定所述斑块检验的正确设置提供了所有必要信息。语言精确客观。没有矛盾、缺失数据或不科学的前提。\n\n**步骤 3：结论与行动**\n问题陈述是**有效的**。我将继续进行解答。\n\n**解答推导**\n\n目标是找到运动学场 $w(x,y)$、$\\theta_x(x,y)$ 和 $\\theta_y(x,y)$，它们满足零弯曲和恒定剪切的目标状态，并确定单元必须在哪些点上再现这些应变才能通过斑块检验。\n\n**1. 连续介质场的分析**\n首先，我们确定产生目标状态的场的解析形式。\n- **零弯曲曲率**：\n条件 $\\kappa_x = \\frac{\\partial \\theta_x}{\\partial x} = 0$ 意味着 $\\theta_x$ 仅是 y 的函数，即 $\\theta_x = f(y)$。\n条件 $\\kappa_y = \\frac{\\partial \\theta_y}{\\partial y} = 0$ 意味着 $\\theta_y$ 仅是 x 的函数，即 $\\theta_y = g(x)$。\n条件 $\\kappa_{xy} = \\frac{\\partial \\theta_x}{\\partial y} + \\frac{\\partial \\theta_y}{\\partial x} = 0$ 于是变为 $f'(y) + g'(x) = 0$。这个方程要对所有 x, y 成立，当且仅当两个导数都等于一个常数，即 $f'(y) = C$ 且 $g'(x) = -C$。\n积分得到 $\\theta_x(x,y) = C y + D_1$ 和 $\\theta_y(x,y) = -C x + D_2$。\n斑块检验应验证最简单的非平凡状态。满足零弯曲的最简单情况是 C=0，这会产生恒定的转角：\n$$ \\theta_x(x,y) = \\theta_x^0 \\quad \\text{和} \\quad \\theta_y(x,y) = \\theta_y^0 $$\n其中 $\\theta_x^0$ 和 $\\theta_y^0$ 是常数。\n\n- **恒定剪切应变**：\n使用恒定的转角，剪切应变的定义变为：\n$$ \\gamma_{xz} = \\theta_x^0 - \\frac{\\partial w}{\\partial x} = \\gamma_{xz}^0 $$\n$$ \\gamma_{yz} = \\theta_y^0 - \\frac{\\partial w}{\\partial y} = \\gamma_{yz}^0 $$\n这些方程要求 w 的偏导数为常数：\n$$ \\frac{\\partial w}{\\partial x} = \\theta_x^0 - \\gamma_{xz}^0 = \\text{常数} $$\n$$ \\frac{\\partial w}{\\partial y} = \\theta_y^0 - \\gamma_{yz}^0 = \\text{常数} $$\n偏导数均为常数的唯一函数 $w(x,y)$ 是 x 和 y 的线性函数。令 $a = \\theta_x^0 - \\gamma_{xz}^0$ 和 $b = \\theta_y^0 - \\gamma_{yz}^0$。那么，位移场必须具有以下形式：\n$$ w(x,y) = a x + b y + c $$\n其中 c 为某个常数。\n\n总之，目标状态是由线性横向位移场和恒定转角场产生的。\n\n**2. 有限元近似分析**\n问题指定了一个 4 节点等参四边形单元。对于此类单元，几何和运动学变量是使用双线性形函数 $N_i(\\xi, \\eta)$ 从节点值插值得到的。该单元的一个基本特性是它能够精确表示空间坐标 $(x,y)$ 的任何线性函数。\n由于所需的位移 $w(x,y)$ 是线性的，而转角 $\\theta_x(x,y), \\theta_y(x,y)$ 是恒定的（线性函数的一个子集），因此只要节点值根据这些函数来设置（例如，$w_i = a x_i + b y_i + c$），该 4 节点单元就能精确表示这些场。\n因此，插值场的导数也将是精确的。该单元将计算出 $\\frac{\\partial w^h}{\\partial x} = a$，$\\frac{\\partial w^h}{\\partial y} = b$，并且 $\\theta_x^h, \\theta_y^h$ 的所有导数都将为零。这意味着该单元能够在其域内的任何地方精确表示零弯曲和恒定剪切状态。\n\n**3. 选择性减缩积分 (SRI) 的作用**\n单元的刚度矩阵和内力向量是通过数值积分计算的。问题指出，剪切项使用 $1 \\times 1$ 高斯求积法则进行积分。这意味着与剪切相关的量仅在父单元的中心，即 $(\\xi, \\eta) = (0,0)$ 处进行评估。\n为了使单元通过剪切斑块检验，它必须在恒定剪切状态下产生正确的剪切应变能。对于 $1 \\times 1$ 积分法则，这当且仅当单元在这个单一积分点 $(\\xi, \\eta) = (0,0)$ 处计算出精确的剪切应变时才能实现。\n由于该单元可以在任何地方精确表示恒定剪切场，因此它在中心点自然也是精确的。因此，检验标准是在剪切求积点精确再现剪切应变。\n\n**逐项分析**\n\n现在我根据此分析评估每个选项。\n\n**A. 选择 $w(x,y) = a\\,x + b\\,y + c$，$\\theta_x(x,y) = \\theta_x^0$，$\\theta_y(x,y) = \\theta_y^0$，并选择常数 $a,b,c,\\theta_x^0,\\theta_y^0$ 使得 $\\theta_x^0 - a = \\gamma_{xz}^0$ 且 $\\theta_y^0 - b = \\gamma_{yz}^0$，这会得到 $\\kappa_x=\\kappa_y=\\kappa_{xy}=0$ 和恒定的 $\\gamma_{xz},\\gamma_{yz}$；要求在剪切求积点 $(\\xi,\\eta)=(0,0)$ 处精确再现 $\\gamma_{xz},\\gamma_{yz}$。**\n- $w$、$\\theta_x$ 和 $\\theta_y$ 的选择与我们对恒定剪切和零弯曲状态的推导相符。\n- 常数与目标剪切应变之间的关系是正确的。\n- 用于验证的所需采样点 $(\\xi,\\eta)=(0,0)$，正确对应于为剪切项指定的 $1 \\times 1$ 积分法则。\n- 此选项正确描述了剪切斑块检验的所有方面。\n**结论：正确**\n\n**B. 选择 $w(x,y) = \\tfrac{1}{2}a\\,x^2 + \\tfrac{1}{2}b\\,y^2$，$\\theta_x(x,y)=0$，$\\theta_y(x,y)=0$，这确保了 $\\kappa_x=\\kappa_y=\\kappa_{xy}=0$ 和恒定的 $\\gamma_{xz},\\gamma_{yz}$；要求在所有单元节点上精确再现 $\\gamma_{xz},\\gamma_{yz}$。**\n- 我们来检查此选项的应变。转角 $\\theta_x, \\theta_y$ 是恒定的（零），因此所有曲率 $\\kappa$ 都为零。这部分是正确的。\n- 然而，剪切应变为 $\\gamma_{xz} = 0 - \\frac{\\partial w}{\\partial x} = -ax$ 和 $\\gamma_{yz} = 0 - \\frac{\\partial w}{\\partial y} = -by$。\n- 这些剪切应变不是恒定的，这与斑块检验的目标相矛盾。该选项中声称剪切应变为恒定的说法是错误的。\n**结论：不正确**\n\n**C. 选择 $w(x,y) = 0$，$\\theta_x(x,y) = \\alpha\\,x$，$\\theta_y(x,y) = \\beta\\,y$，并选择常数 $\\alpha,\\beta$ 使得 $\\gamma_{xz}=\\gamma_{xz}^0$ 且 $\\gamma_{yz}=\\gamma_{yz}^0$；要求在 $2\\times 2$ 高斯点 $(\\xi,\\eta)=\\left(\\pm \\frac{1}{\\sqrt{3}},\\pm \\frac{1}{\\sqrt{3}}\\right)$ 处精确再现 $\\gamma_{xz},\\gamma_{yz}$。**\n- 我们来检查应变。位移 w=0。\n- 剪切应变为 $\\gamma_{xz} = \\alpha x - 0 = \\alpha x$ 和 $\\gamma_{yz} = \\beta y - 0 = \\beta y$。这些不是恒定的。\n- 弯曲曲率为 $\\kappa_x = \\frac{\\partial \\theta_x}{\\partial x} = \\alpha$ 和 $\\kappa_y = \\frac{\\partial \\theta_y}{\\partial y} = \\beta$。这些不为零（除非 $\\alpha=\\beta=0$，即平凡情况）。这违反了斑块检验的“零弯曲”条件。\n- 指定的再现点 ($\\pm \\frac{1}{\\sqrt{3}}, \\pm \\frac{1}{\\sqrt{3}}$) 是弯曲积分点，而不是剪切积分点。\n**结论：不正确**\n\n**D. 选择 $w(x,y) = a\\,x + b\\,y + c$，$\\theta_x(x,y) = a$，$\\theta_y(x,y) = b$，这使得 $\\gamma_{xz},\\gamma_{yz}$ 恒定且等于 $\\gamma_{xz}^0,\\gamma_{yz}^0$；要求在弯曲求积点 $(\\xi,\\eta)=\\left(\\pm \\frac{1}{\\sqrt{3}},\\pm \\frac{1}{\\sqrt{3}}\\right)$ 处精确再现。**\n- 所选的运动学场是正确形式的一个特例。我们来检查应变。\n- 由于转角是恒定的，因此曲率为零。这是正确的。\n- 剪切应变为 $\\gamma_{xz} = \\theta_x - \\frac{\\partial w}{\\partial x} = a - a = 0$ 和 $\\gamma_{yz} = \\theta_y - \\frac{\\partial w}{\\partial y} = b - b = 0$。\n- 这个选择只能表示*零*剪切应变的状态。斑块检验必须对任意恒定剪切状态通过，即对任何 $\\gamma_{xz}^0, \\gamma_{yz}^0$。此选项描述了一个平凡且不完整的检验。\n- 此外，它要求在弯曲求积点进行再现，这对于 SRI 下的剪切检验是不正确的。\n**结论：不正确**\n\n基于这一全面分析，只有选项 A 正确地为给定的单元和积分方案表述了剪切斑块检验。", "answer": "$$\\boxed{A}$$", "id": "2595605"}, {"introduction": "除了剪切锁定，体积锁定是另一个在模拟近不可压缩材料（如橡胶或某些流体）时出现的严重数值问题。本练习将通过“制造解方法”（Method of Manufactured Solutions）来精确量化体积锁定，并展示如何通过混合配方来克服它。你将实现并对比标准位移单元和混合位移-压力单元的性能，从而深刻理解体积锁定的诊断方法及其有效的缓解策略 [@problem_id:2595504]。", "problem": "考虑一个在单位正方形域 $\\Omega=[0,1]\\times[0,1]$ 上的二维线性弹性边界值问题，该问题处于平面应变状态，并采用一个光滑的制造位移解。设位移定义为 $u_x(x,y)=\\sin(\\pi x)\\sin(\\pi y)$ 和 $u_y(x,y)=\\cos(\\pi x)\\sin(\\pi y)$。设材料为近不可压缩材料，其杨氏模量 $E=1$，泊松比 $\\nu=0.4999$。Lamé 参数记为 $\\lambda=\\dfrac{E\\nu}{(1+\\nu)(1-2\\nu)}$ 和 $\\mu=\\dfrac{E}{2(1+\\nu)}$。将精确压力定义为 $p_{\\text{exact}}(x,y)=-\\lambda\\,\\nabla\\cdot u(x,y)$。设体力为 $f(x,y)=-\\nabla\\cdot\\sigma(x,y)$，其中 Cauchy 应力为 $\\sigma=2\\mu\\,\\varepsilon(u)+\\lambda\\,\\text{tr}(\\varepsilon(u))I=2\\mu\\,\\varepsilon(u)-p_{\\text{exact}} I$，$\\varepsilon(u)$ 是小应变张量。通过在整个边界 $\\partial\\Omega$ 上施加精确位移来施加 Dirichlet 边界条件。\n\n您的任务是通过比较以下两种方法的位移和压力的 $L^2$ 误差来量化体积锁定现象：\n- 一种标准的基于位移的双线性四边形单元 (Q4) 离散化，使用完整的线性弹性刚度（易受体积锁定影响），\n- 一种基于 Herrmann 公式的混合位移-压力公式，其中位移为 Q4，每个单元上的压力为分段常数 (Q4/Q0)。在该公式中，偏应力部分由 $2\\mu\\,\\varepsilon(u):\\varepsilon(v)$ 处理，压力 $p$ 是一个独立的未知量，在弱形式意义上满足 $p+\\lambda\\,\\nabla\\cdot u=0$。\n\n从以下基本原则出发：\n- 平面应变下线性弹性的弱形式、Lamé 参数的定义、小应变张量的定义以及线性弹性中的 Cauchy 应力概念。\n- 用于近不可压缩弹性的 Herrmann 混合公式，其中压力 $p$ 为独立未知量。\n- 等参双线性四边形单元的数值积分（使用张量积 Gauss 法则）。\n- $\\Omega$ 上的 $L^2$ 范数的定义。\n\n按以下步骤进行，仅使用这些基础，不使用超出这些原则的任何快捷公式：\n- 从制造位移 $u$ 和精确压力 $p_{\\text{exact}}$ 推导出体力 $f$。\n- 对于纯位移 Q4 方法，利用双线性形式 $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega$（其中 $D$ 为平面应变本构张量）和线性泛函 $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$ 组装全局系统。使用精确边界位移来强施加 Dirichlet 条件。\n- 对于混合 Q4/Q0 方法 (Herrmann)，从以下双线性形式组装 $(u,p)$ 的分块系统\n  - $a(u,v)=\\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega$,\n  - $b(v,p)=-\\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega$ 和 $b(u,q)=-\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega$,\n  - $c(p,q)=-\\int_{\\Omega}\\dfrac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega$,\n  和线性泛函 $\\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$。每个单元使用一个压力自由度（单元内为常数）。如上所述，对 $u$ 强施加 Dirichlet 条件。\n- 对于纯位移 Q4 方法，将计算出的压力场定义为 $p_h=-\\lambda\\,\\nabla\\cdot u_h$，并在积分点上进行求值。\n- 使用适当的高斯积分计算位移的 $L^2$ 误差 $e_u=\\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$ 和压力的 $L^2$ 误差 $e_p=\\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2}$。对于混合 Q4/Q0 方法，$p_h$ 是分段常数，因此在每个单元内通过积分计算其误差。\n\n在 $\\Omega$ 上使用一个由 $N\\times N$ 个节点间距均匀的双线性四边形单元组成的结构化网格。实现等参映射，并对所有单元积分使用 $2\\times 2$ Gaussian 积分法则。通过制造解精确施加所有边界条件。\n\n测试套件：\n- 使用三种网格，其中 $N\\in\\{2,4,8\\}$。\n- 对于每个 $N$，计算四个浮点数：Q4 方法的位移 $L^2$ 误差、Q4 方法的压力 $L^2$ 误差（其中 $p_h=-\\lambda\\,\\nabla\\cdot u_h$）、混合 Q4/Q0 方法的位移 $L^2$ 误差以及混合 Q4/Q0 方法的压力 $L^2$ 误差。\n\n最终输出规范：\n- 您的程序应生成单行输出，包含一个以逗号分隔的列表的列表，其中每个内部列表对应于一个网格（按 $N=2, N=4, N=8$ 的顺序），并按上述顺序包含四个浮点数。所有浮点数均以科学记数法表示，小数点后保留六位数字。例如，格式必须与以下完全相同：\n  $[ [a_{11},a_{12},a_{13},a_{14}], [a_{21},a_{22},a_{23},a_{24}], [a_{31},a_{32},a_{33},a_{34}] ]$\n此问题不涉及物理单位。", "solution": "所述问题是计算力学中一个适定的练习，具体来说是关于近不可压缩线性弹性的有限元分析。该问题具有科学依据，内容自洽，没有矛盾之处。其目的是展示低阶位移单元中的体积锁定现象以及如何使用混合公式来修正它。所有必要的组成部分——域、边界条件、控制方程、材料属性和分析方法——均已提供。因此，该问题是有效的。我们着手进行求解。\n\n分析基于平面应变线性弹性的原理。控制平衡方程为 $\\nabla \\cdot \\sigma + f = 0$，其中 $\\sigma$ 是 Cauchy 应力张量，$f$ 是单位体积的体力。\n\n首先，我们建立制造解及其导数的表达式，这对于定义问题和评估数值解的准确性至关重要。\n\n位移场由下式给出：\n$$ u_x(x,y) = \\sin(\\pi x)\\sin(\\pi y) $$\n$$ u_y(x,y) = \\cos(\\pi x)\\sin(\\pi y) $$\n小应变张量 $\\varepsilon(u) = \\frac{1}{2}(\\nabla u + (\\nabla u)^T)$ 的分量为：\n$$ \\varepsilon_{xx} = \\frac{\\partial u_x}{\\partial x} = \\pi \\cos(\\pi x)\\sin(\\pi y) $$\n$$ \\varepsilon_{yy} = \\frac{\\partial u_y}{\\partial y} = \\pi \\cos(\\pi x)\\cos(\\pi y) $$\n$$ \\varepsilon_{xy} = \\frac{1}{2}\\left(\\frac{\\partial u_x}{\\partial y} + \\frac{\\partial u_y}{\\partial x}\\right) = \\frac{1}{2}\\left(\\pi \\sin(\\pi x)\\cos(\\pi y) - \\pi \\sin(\\pi x)\\sin(\\pi y)\\right) = \\frac{\\pi}{2} \\sin(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) $$\n对于平面应变，$\\varepsilon_{zz} = 0$。\n\n位移场的散度是应变张量的迹：\n$$ \\nabla \\cdot u = \\varepsilon_{xx} + \\varepsilon_{yy} = \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\n精确压力定义为 $p_{\\text{exact}} = -\\lambda \\, \\text{tr}(\\varepsilon(u)) = -\\lambda (\\nabla \\cdot u)$：\n$$ p_{\\text{exact}}(x,y) = -\\lambda \\pi \\cos(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) $$\n\n体力 $f$ 的推导是为了确保制造位移场是该边界值问题的精确解。根据弹性的 Navier-Cauchy 方程，$f$ 由下式给出：\n$$ f = - \\nabla \\cdot \\sigma = - \\nabla \\cdot (2\\mu\\varepsilon + \\lambda(\\nabla \\cdot u)I) = -\\mu \\nabla^2 u - (\\mu+\\lambda)\\nabla(\\nabla \\cdot u) $$\n我们计算必要的项：\n$$ \\nabla^2 u_x = \\frac{\\partial^2 u_x}{\\partial x^2} + \\frac{\\partial^2 u_x}{\\partial y^2} = -2\\pi^2 \\sin(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_x $$\n$$ \\nabla^2 u_y = \\frac{\\partial^2 u_y}{\\partial x^2} + \\frac{\\partial^2 u_y}{\\partial y^2} = -2\\pi^2 \\cos(\\pi x)\\sin(\\pi y) = -2\\pi^2 u_y $$\n$$ \\nabla(\\nabla \\cdot u) = \\begin{pmatrix} \\frac{\\partial}{\\partial x}(\\nabla \\cdot u) \\\\ \\frac{\\partial}{\\partial y}(\\nabla \\cdot u) \\end{pmatrix} = \\begin{pmatrix} -\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) \\\\ \\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) \\end{pmatrix} $$\n将这些代入 $f$ 的表达式中，得到体力的分量：\n$$ f_x(x,y) = 2\\mu\\pi^2 u_x + (\\mu+\\lambda)\\pi^2 \\sin(\\pi x)(\\sin(\\pi y) + \\cos(\\pi y)) = \\pi^2 \\sin(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) + (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n$$ f_y(x,y) = 2\\mu\\pi^2 u_y - (\\mu+\\lambda)\\pi^2 \\cos(\\pi x)(\\cos(\\pi y) - \\sin(\\pi y)) = \\pi^2 \\cos(\\pi x) \\left( (3\\mu+\\lambda)\\sin(\\pi y) - (\\mu+\\lambda)\\cos(\\pi y) \\right) $$\n\n该问题使用 $N \\times N$ 个双线性四边形单元 (Q4) 的结构化网格进行离散化。对于定义在父域 $[-1,1]\\times[-1,1]$ 上的单元，等参映射和位移插值由下式给出：\n$$ x(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) x_a, \\quad u_h(\\xi, \\eta) = \\sum_{a=1}^4 N_a(\\xi, \\eta) d_a $$\n其中 $N_a(\\xi, \\eta) = \\frac{1}{4}(1+\\xi_a\\xi)(1+\\eta_a\\eta)$ 是形函数，$x_a$ 是节点坐标，$d_a$ 是节点位移向量。应变-位移矩阵 $B$ 将应变向量 $\\varepsilon_V = (\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy})^T$ 与节点位移向量 $d$ 相关联：$\\varepsilon_V = B d$。\n\n**方法1：标准的基于位移的 Q4 公式**\n\n弱形式为 $\\int_{\\Omega} \\varepsilon(v)^T D\\,\\varepsilon(u)\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega$。这导出一个线性系统 $K d = F$。单元刚度矩阵 $K^e$ 和力向量 $F^e$ 分别为：\n$$ K^e = \\int_{\\Omega_e} B^T D B \\, \\mathrm{d}\\Omega, \\quad F^e = \\int_{\\Omega_e} N^T f \\, \\mathrm{d}\\Omega $$\n平面应变本构矩阵 $D$ 为：\n$$ D = \\frac{E}{(1+\\nu)(1-2\\nu)} \\begin{pmatrix} 1-\\nu  \\nu  0 \\\\ \\nu  1-\\nu  0 \\\\ 0  0  (1-2\\nu)/2 \\end{pmatrix} = \\begin{pmatrix} \\lambda+2\\mu  \\lambda  0 \\\\ \\lambda  \\lambda+2\\mu  0 \\\\ 0  0  \\mu \\end{pmatrix} $$\n积分使用 $2 \\times 2$ Gauss 积分法则计算。组装完全局系统后，通过对系统进行分区并求解未知的内部自由度来强施加 Dirichlet 边界条件。数值压力场根据计算出的位移场 $u_h$ 进行后处理，即 $p_h = -\\lambda (\\nabla \\cdot u_h)$。此计算在积分点上执行。\n\n**方法2：混合位移-压力 Q4/Q0 公式 (Herrmann)**\n\n此公式将压力 $p$ 视为一个独立变量（在每个单元上为常数），以克服锁定。弱形式是一个鞍点系统：\n$$ \\int_{\\Omega} 2\\mu\\,\\varepsilon(u):\\varepsilon(v)\\,\\mathrm{d}\\Omega - \\int_{\\Omega} p\\,\\nabla\\cdot v\\,\\mathrm{d}\\Omega = \\int_{\\Omega} v\\cdot f\\,\\mathrm{d}\\Omega $$\n$$ -\\int_{\\Omega} q\\,\\nabla\\cdot u\\,\\mathrm{d}\\Omega - \\int_{\\Omega}\\dfrac{1}{\\lambda}\\,pq\\,\\mathrm{d}\\Omega = 0 $$\n这导出一个分块矩阵系统：\n$$ \\begin{pmatrix} A  B^T \\\\ B  C \\end{pmatrix} \\begin{pmatrix} d \\\\ p \\end{pmatrix} = \\begin{pmatrix} F \\\\ 0 \\end{pmatrix} $$\n单元级矩阵为：\n - $A^e = \\int_{\\Omega_e} B^T D_{dev} B \\, \\mathrm{d}\\Omega$，其中 $D_{dev} = \\text{diag}(2\\mu, 2\\mu, \\mu)$。这代表了刚度的偏量部分。\n - $B^e$ 是一个 $1 \\times 8$ 的矩阵，它将单元的单个压力自由度与其8个位移自由度耦合起来：$B^e = -\\int_{\\Omega_e} [1, 1, 0]B \\, \\mathrm{d}\\Omega$。\n - $C^e$ 是一个用于压力项的 $1 \\times 1$ 矩阵：$C^e = -\\int_{\\Omega_e} \\frac{1}{\\lambda} \\, \\mathrm{d}\\Omega = -\\frac{\\text{Area}(e)}{\\lambda}$。\n - $F^e$ 与 Q4 方法中的体力向量相同。\n全局系统由这些单元矩阵组装而成。矩阵 $C$ 是对角的。边界条件以与 Q4 方法相同的方式应用于位移自由度。该系统的解同时产生位移场 $u_h$ 和分段常数压力场 $p_h$。\n\n**误差计算**\n\n对于这两种方法，都计算了位移和压力的 $L^2$ 误差以量化准确性。误差定义为：\n$$ e_u = \\left(\\int_{\\Omega}\\|u_h-u_{\\text{exact}}\\|^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\n$$ e_p = \\left(\\int_{\\Omega}\\left(p_h-p_{\\text{exact}}\\right)^2\\,\\mathrm{d}\\Omega\\right)^{1/2} $$\n这些积分使用相同的 $2 \\times 2$ Gauss 积分法则在每个单元上进行数值计算，并将各单元的贡献相加以获得总误差。对于 Q4/Q0 方法，$p_h$ 是为每个单元计算的分段常数值；而对于 Q4 方法，$p_h$ 是根据每个积分点上的位移导数计算得出的。\n\n以下 Python 实现针对指定的网格尺寸执行这些步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear elasticity problem with a manufactured solution\n    to demonstrate volumetric locking and its mitigation with a mixed method.\n    \"\"\"\n\n    # Material properties and constants\n    E = 1.0\n    nu = 0.4999\n    \n    # Lamé parameters\n    lmbda = (E * nu) / ((1.0 + nu) * (1.0 - 2.0 * nu))\n    mu = E / (2.0 * (1.0 + nu))\n    \n    # Constitutive matrix for plane strain (Q4 method)\n    D = np.array([\n        [lmbda + 2 * mu, lmbda, 0],\n        [lmbda, lmbda + 2 * mu, 0],\n        [0, 0, mu]\n    ])\n    \n    # Deviatoric part for Q4/Q0 method\n    D_dev = np.diag([2 * mu, 2 * mu, mu])\n    \n    # Manufactured solution and its derivatives\n    pi = np.pi\n    u_exact_fn = lambda x, y: (np.sin(pi * x) * np.sin(pi * y), np.cos(pi * x) * np.sin(pi * y))\n    p_exact_fn = lambda x, y: -lmbda * pi * np.cos(pi * x) * (np.sin(pi * y) + np.cos(pi * y))\n\n    # Body force from manufactured solution\n    # f_x = pi**2 * sin(pi*x) * ((3*mu+lmbda)*sin(pi*y) + (mu+lmbda)*cos(pi*y))\n    # f_y = pi**2 * cos(pi*x) * ((3*mu+lmbda)*sin(pi*y) - (mu+lmbda)*cos(pi*y))\n    c1 = 3 * mu + lmbda\n    c2 = mu + lmbda\n    f_fn = lambda x, y: (\n        pi**2 * np.sin(pi * x) * (c1 * np.sin(pi * y) + c2 * np.cos(pi * y)),\n        pi**2 * np.cos(pi * x) * (c1 * np.sin(pi * y) - c2 * np.cos(pi * y))\n    )\n\n    # Gaussian quadrature points and weights for 2x2 rule\n    gauss_pts = [-1.0 / np.sqrt(3.0), 1.0 / np.sqrt(3.0)]\n    gauss_w = [1.0, 1.0]\n\n    def get_shape_functions_and_derivs(xi, eta):\n        # Shape functions N(xi, eta)\n        N = 0.25 * np.array([\n            (1 - xi) * (1 - eta),\n            (1 + xi) * (1 - eta),\n            (1 + xi) * (1 + eta),\n            (1 - xi) * (1 + eta)\n        ])\n        \n        # Derivatives of N w.r.t. xi, eta\n        dN_dxi = 0.25 * np.array([-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)])\n        dN_deta = 0.25 * np.array([-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)])\n        \n        return N, dN_dxi, dN_deta\n\n    def solve_fem(N, method):\n        # Mesh parameters\n        h = 1.0 / N\n        num_nodes = (N + 1)**2\n        num_elems = N**2\n        num_disp_dofs = 2 * num_nodes\n        \n        nodes = np.array([[i * h, j * h] for j in range(N + 1) for i in range(N + 1)])\n        elements = np.array([\n            [j * (N + 1) + i, j * (N + 1) + i + 1, (j + 1) * (N + 1) + i + 1, (j + 1) * (N + 1) + i]\n            for j in range(N) for i in range(N)\n        ])\n        elem_map = {(j, i): j * N + i for j in range(N) for i in range(N)}\n        \n        if method == 'Q4':\n            K = np.zeros((num_disp_dofs, num_disp_dofs))\n            F = np.zeros(num_disp_dofs)\n        elif method == 'Q4Q0':\n            num_pressure_dofs = num_elems\n            dof_total = num_disp_dofs + num_pressure_dofs\n            K_saddle = np.zeros((dof_total, dof_total))\n            F_saddle = np.zeros(dof_total)\n            A_mat = K_saddle[:num_disp_dofs, :num_disp_dofs]\n            B_mat = K_saddle[num_disp_dofs:, :num_disp_dofs] # B\n            C_mat = K_saddle[num_disp_dofs:, num_disp_dofs:]\n            F_disp = F_saddle[:num_disp_dofs]\n            \n            # Pressure matrix is diagonal\n            np.fill_diagonal(C_mat, -h**2 / lmbda)\n\n        # Assemble matrices\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n\n                # Element matrices\n                Ke = np.zeros((8, 8))\n                Fe = np.zeros(8)\n                if method == 'Q4Q0':\n                    Be_row = np.zeros(8)\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        \n                        # Jacobian is constant for structured grid\n                        dN_dx = dN_dxi * (2.0 / h)\n                        dN_dy = dN_deta * (2.0 / h)\n                        \n                        B = np.zeros((3, 8))\n                        for k in range(4):\n                            B[0, 2*k] = dN_dx[k]\n                            B[1, 2*k+1] = dN_dy[k]\n                            B[2, 2*k] = dN_dy[k]\n                            B[2, 2*k+1] = dN_dx[k]\n\n                        D_eff = D if method == 'Q4' else D_dev\n                        Ke += B.T @ D_eff @ B * detJ\n                        \n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        f_vec = f_fn(x_gp, y_gp)\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        Fe += N_matrix.T @ np.array(f_vec) * detJ\n                        \n                        if method == 'Q4Q0':\n                            G_transpose = np.array([1, 1, 0]) @ B\n                            Be_row -= G_transpose * detJ\n\n                # Assemble into global system\n                dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                if method == 'Q4':\n                    K[np.ix_(dofs, dofs)] += Ke\n                    F[dofs] += Fe\n                elif method == 'Q4Q0':\n                    A_mat[np.ix_(dofs, dofs)] += Ke\n                    F_disp[dofs] += Fe\n                    B_mat[elem_idx, dofs] += Be_row\n\n        if method == 'Q4Q0':\n            # Transpose B to get B.T\n            K_saddle[:num_disp_dofs, num_disp_dofs:] = B_mat.T\n        \n        # Apply boundary conditions\n        boundary_nodes = set()\n        for i in range(N + 1):\n            boundary_nodes.add(i)  # bottom\n            boundary_nodes.add(N * (N + 1) + i) # top\n            boundary_nodes.add(i * (N + 1)) # left\n            boundary_nodes.add(i * (N + 1) + N) # right\n        \n        boundary_dofs = []\n        for n in sorted(list(boundary_nodes)):\n            boundary_dofs.extend([2 * n, 2 * n + 1])\n        \n        all_dofs = np.arange(num_disp_dofs)\n        internal_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n        \n        u_h_full = np.zeros(num_disp_dofs)\n        boundary_coords = nodes[sorted(list(boundary_nodes))]\n        u_exact_b = np.array([u_exact_fn(c[0], c[1]) for c in boundary_coords]).ravel()\n        u_h_full[boundary_dofs] = u_exact_b\n        \n        if method == 'Q4':\n            K_II = K[np.ix_(internal_dofs, internal_dofs)]\n            K_IB = K[np.ix_(internal_dofs, boundary_dofs)]\n            F_I = F[internal_dofs]\n            F_eff = F_I - K_IB @ u_exact_b\n            u_I = np.linalg.solve(K_II, F_eff)\n            u_h_full[internal_dofs] = u_I\n            u_h = u_h_full\n            p_h = None\n        \n        elif method == 'Q4Q0':\n            dof_total = num_disp_dofs + num_pressure_dofs\n            all_saddle_dofs = np.arange(dof_total)\n            pressure_dofs_global = np.arange(num_disp_dofs, dof_total)\n            internal_saddle_dofs = np.concatenate([internal_dofs, pressure_dofs_global])\n            \n            K_saddle_II = K_saddle[np.ix_(internal_saddle_dofs, internal_saddle_dofs)]\n            K_saddle_IB = K_saddle[np.ix_(internal_saddle_dofs, boundary_dofs)]\n            F_saddle_I = F_saddle[internal_saddle_dofs]\n            F_saddle_eff = F_saddle_I - K_saddle_IB @ u_exact_b\n            \n            sol_I = np.linalg.solve(K_saddle_II, F_saddle_eff)\n            u_h_full[internal_dofs] = sol_I[:len(internal_dofs)]\n            u_h = u_h_full\n            p_h = sol_I[len(internal_dofs):]\n\n        # Error computation\n        u_err_sq, p_err_sq = 0.0, 0.0\n        for j in range(N):\n            for i in range(N):\n                elem_idx = elem_map[(j, i)]\n                elem_nodes = elements[elem_idx]\n                elem_coords = nodes[elem_nodes]\n                \n                detJ = (h / 2.0)**2\n                \n                for gp_eta in gauss_pts:\n                    for gp_xi in gauss_pts:\n                        N_vals, dN_dxi, dN_deta = get_shape_functions_and_derivs(gp_xi, gp_eta)\n                        x_gp, y_gp = elem_coords.T @ N_vals\n                        \n                        u_exact_gp = np.array(u_exact_fn(x_gp, y_gp))\n                        p_exact_gp = p_exact_fn(x_gp, y_gp)\n                        \n                        dofs = np.ravel([[2 * n, 2 * n + 1] for n in elem_nodes])\n                        u_nodal = u_h[dofs]\n                        \n                        N_matrix = np.zeros((2, 8))\n                        N_matrix[0, 0::2] = N_vals\n                        N_matrix[1, 1::2] = N_vals\n                        \n                        u_h_gp = N_matrix @ u_nodal\n                        u_err_sq += np.sum((u_h_gp - u_exact_gp)**2) * detJ\n\n                        if method == 'Q4':\n                            dN_dx = dN_dxi * (2.0 / h)\n                            dN_dy = dN_deta * (2.0 / h)\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = dN_dx[k]\n                                B[1, 2*k+1] = dN_dy[k]\n                            div_u_h = (B[0, :] + B[1, :]) @ u_nodal\n                            p_h_gp = -lmbda * div_u_h\n                        elif method == 'Q4Q0':\n                            p_h_gp = p_h[elem_idx]\n\n                        p_err_sq += (p_h_gp - p_exact_gp)**2 * detJ\n                        \n        return np.sqrt(u_err_sq), np.sqrt(p_err_sq)\n\n\n    test_cases = [2, 4, 8]\n    results = []\n    \n    for n in test_cases:\n        case_results = []\n        \n        # Q4 analysis\n        err_u_q4, err_p_q4 = solve_fem(n, 'Q4')\n        case_results.extend([err_u_q4, err_p_q4])\n        \n        # Q4/Q0 analysis\n        err_u_q4q0, err_p_q4q0 = solve_fem(n, 'Q4Q0')\n        case_results.extend([err_u_q4q0, err_p_q4q0])\n        \n        results.append(case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = [\n        \"[\" + \", \".join(f\"{val:.6e}\" for val in case) + \"]\"\n        for case in results\n    ]\n    print(f\"[{', '.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2595504"}]}