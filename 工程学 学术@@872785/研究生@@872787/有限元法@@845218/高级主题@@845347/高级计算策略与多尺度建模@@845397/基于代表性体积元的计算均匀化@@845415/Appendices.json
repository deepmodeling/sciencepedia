{"hands_on_practices": [{"introduction": "计算均匀化理论的核心在于从微观细节中提取宏观等效属性。这一过程的基石是体积平均法，它将微观尺度上复杂变化的场（如应力或应变）转化为单一的宏观张量。此练习将指导您推导在有限元分析中计算体积平均应力的标准公式 [@problem_id:2546266]。这个推导不仅仅是一个数学步骤，它揭示了如何确保计算结果对于网格划分具有不变性，这是任何数值平均方案必须满足的基本一致性要求，即“补丁测试”（patch test）。", "problem": "考虑计算均匀化中的一个代表性体积单元 (RVE)，记为有界域 $\\Omega_{\\mu} \\subset \\mathbb{R}^{d}$，其体积为 $|\\Omega_{\\mu}|$。微观柯西应力场为 $\\boldsymbol{\\sigma}(\\boldsymbol{x})$，假设其足够光滑，并通过有限元计算得到。有限元网格将 $\\Omega_{\\mu}$ 剖分为由 $e \\in \\mathcal{E}$ 索引的单元。在每个单元 $e$ 上，使用一个从参考单元 $\\widehat{\\Omega}$ 到物理单元 $\\Omega_{e}$ 的等参映射 $\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$，其雅可比行列式为 $J_{e}(\\boldsymbol{\\xi}) = \\det\\left(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi}\\right)$。在每个单元上使用具有点 $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ 和正权重 $\\{w_{q}\\}_{q=1}^{Q_{e}}$ 的标准高斯积分来组装各个量，而在高斯点处计算的应力记为 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$。\n\n从宏观（体积）平均应力的基本定义出发，\n$$\\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V,$$\n推导一个仅用高斯点应力 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$、雅可比行列式 $J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$ 和参考单元权重 $w_{q}$ 表示的、基于积分的有限元表达式 $\\langle \\boldsymbol{\\sigma} \\rangle$。\n\n然后，使用第一性原理，证明如何选择离散公式中的归一化方法，以使得最终的平均值在以下精确意义上对于网格剖分是不变的：对于任意两个使用相同单元类型和相同积分法则的 $\\Omega_{\\mu}$ 网格，对于任何单元上为常数的应力场，计算出的平均值都应一致。你的推理应仅依赖于高斯积分和等参映射的基本性质，而非任何特定代码的特殊功能。\n\n你的最终答案必须是一个单一的闭式解析表达式，仅包含对单元和高斯点的求和、$\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})$、$J_{e}(\\boldsymbol{\\xi}^{(e)}_{q})$ 和 $w_{q}$。不要包含任何其他符号。不需要进行数值计算，也不需要单位。只将最终公式作为你的答案。", "solution": "问题陈述具有科学依据、适定、客观且自洽。它提出了计算均匀化框架下有限元解后处理中的一个标准任务。我们将进行严格的推导。\n\n目标是推导宏观平均应力的离散、基于积分的表达式，其定义为：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle = \\frac{1}{|\\Omega_{\\mu}|} \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\n推导过程分三个逻辑步骤进行：积分的空间离散化、使用高斯积分的数值近似，以及一致的归一化。\n\n首先，对整个代表性体积单元 (RVE) 域 $\\Omega_{\\mu}$ 的积分被分解为对构成网格 $\\mathcal{E}$ 的不重叠有限单元 $\\Omega_e$ 的积分之和。域是其单元的并集，$\\Omega_{\\mu} = \\bigcup_{e \\in \\mathcal{E}} \\Omega_e$。因此，积分变为：\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V $$\n\n第二，通过使用给定的等参映射 $\\boldsymbol{x} = \\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})$，每个物理单元 $\\Omega_e$ 上的积分被变换为标准参考单元 $\\widehat{\\Omega}$ 上的积分。微分体积元根据 $\\mathrm{d}V = J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V}$ 进行变换，其中 $J_{e}(\\boldsymbol{\\xi}) = \\det(\\partial \\boldsymbol{x}^{(e)}/\\partial \\boldsymbol{\\xi})$ 是映射的雅可比行列式。于是单元 $e$ 上的积分为：\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V = \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} $$\n\n然后，使用指定的高斯积分法则对参考单元上的这个积分进行数值近似。该积分法则由参考单元中的一组 $Q_e$ 个积分点 $\\{\\boldsymbol{\\xi}^{(e)}_{q}\\}_{q=1}^{Q_{e}}$ 和相应的正权重 $\\{w_{q}\\}_{q=1}^{Q_{e}}$ 定义。对于给定的单元类型，积分法则（点和权重）通常是固定的，因此 $Q_e$ 和 $\\boldsymbol{\\xi}^{(e)}_q$ 上的下标和上标可以省略，但为保持严谨，我们将保留问题中的记法。该近似为：\n$$ \\int_{\\widehat{\\Omega}} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi})) J_{e}(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q})) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n使用所提供的简写符号 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) \\equiv \\boldsymbol{\\sigma}(\\boldsymbol{x}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}))$，我们可以将单元 $e$ 上的积分的离散近似写为：\n$$ \\int_{\\Omega_e} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n对网格中的所有单元求和，得到总应力积分的数值近似：\n$$ \\int_{\\Omega_{\\mu}} \\boldsymbol{\\sigma}(\\boldsymbol{x}) \\, \\mathrm{d}V \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n\n第三，我们处理归一化因子 $|\\Omega_{\\mu}|$。一种朴素的方法可能是使用一个精确的或解析已知的体积。然而，为了使离散公式保持一致性，归一化因子必须使用与分子完全相同的数值方案来计算。体积 $|\\Omega_{\\mu}|$ 是函数 $f(\\boldsymbol{x})=1$ 在域上的积分：\n$$ |\\Omega_{\\mu}| = \\int_{\\Omega_{\\mu}} 1 \\, \\mathrm{d}V $$\n对此积分应用相同的离散化和积分过程，得到数值计算的体积：\n$$ |\\Omega_{\\mu}| \\approx \\sum_{e \\in \\mathcal{E}} \\int_{\\Omega_e} 1 \\, \\mathrm{d}V = \\sum_{e \\in \\mathcal{E}} \\int_{\\widehat{\\Omega}} J_e(\\boldsymbol{\\xi}) \\, \\mathrm{d}\\widehat{V} \\approx \\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_e(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q} $$\n因此，平均应力的一致归一化表达式是这两个数值计算量的比值：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\n\n现在我们必须根据所要求的不变性属性来证明这种归一化选择的合理性。问题要求计算出的平均值对于“任何单元上为常数的应力场”在网格剖分下保持不变。我们在任何平均方案的基本一致性要求（即零阶分片检验）的背景下解释这一点：该方案必须能精确地再现常数。\n考虑一个全局常数应力场 $\\boldsymbol{\\sigma}(\\boldsymbol{x}) = \\boldsymbol{\\sigma}_0$。其真实平均值显然是 $\\langle\\boldsymbol{\\sigma}\\rangle = \\boldsymbol{\\sigma}_0$。我们的数值公式必须得到这个结果，无论使用何种网格。对于这样的场，每个高斯点处的应力也是 $\\boldsymbol{\\sigma}_0$，即对所有的 $e$ 和 $q$ 都有 $\\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) = \\boldsymbol{\\sigma}_0$。\n将此代入我们推导出的公式：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}_0 J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} $$\n由于 $\\boldsymbol{\\sigma}_0$ 是一个常数张量，它可以从分子的求和中提取出来：\n$$ \\langle \\boldsymbol{\\sigma} \\rangle \\approx \\boldsymbol{\\sigma}_0 \\left( \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} \\right) = \\boldsymbol{\\sigma}_0 $$\n该表达式精确地简化为 $\\boldsymbol{\\sigma}_0$，因为除了因子 $\\boldsymbol{\\sigma}_0$ 外，分子和分母变得完全相同。这个结果与网格 $\\mathcal{E}$ 无关，从而满足了常数场这一关键情况下的指定不变性条件。这表明，使用与应力积分相同的积分法则来计算体积（归一化因子），不仅仅是一种选择，而是数值平均值基本一致性的一项要求。\n因此，最终的公式由这些原则唯一确定。", "answer": "$$ \\boxed{ \\frac{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} \\boldsymbol{\\sigma}^{(e)}(\\boldsymbol{\\xi}^{(e)}_{q}) J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}}{\\sum_{e \\in \\mathcal{E}} \\sum_{q=1}^{Q_e} J_{e}(\\boldsymbol{\\xi}^{(e)}_{q}) w_{q}} } $$", "id": "2546266"}, {"introduction": "掌握了平均化方法后，我们便可以着手进行一次完整的计算均匀化分析。本实践提供了一个端到端的流程，用于计算具有正交增强夹杂物的二维复合材料的有效泊松比 [@problem_id:2546256]。您将通过施加运动学一致边界条件（Kinematically Uniform Boundary Conditions, KUBC）来模拟宏观应变，求解代表性体积单元（RVE）内的微观应力场，并最终通过平均化和矩阵运算提取出材料的宏观等效弹性常数。这个练习是应用均匀化理论解决实际工程问题的典型范例。", "problem": "考虑一个平面应力状态下的线性弹性非均质介质的二维（$2$D）代表性体积单元（RVE），将通过有限元法（FEM）进行分析。该 RVE 是一个单位正方形，坐标为 $(x,y)\\in[0,1]\\times[0,1]$。其微观结构由一个柔性基体和包含在其中的两族正交的刚性夹杂物组成，这些夹杂物被建模为与坐标轴对齐的周期性条带。如果一个点 $(x,y)$ 满足 $(x \\bmod p_x) > t_x$ 或 $(y \\bmod p_y) > t_y$，则该点位于刚性相中，其中 $p_x>0$ 和 $p_y>0$ 是条带间距，$t_x\\in[0,p_x]$ 和 $t_y\\in[0,p_y]$ 是条带厚度。否则，该点位于基体相中。所有材料参数均为无量纲。\n\n使用以下基本理论基础：\n- 平面应力下的小应变线性弹性：应变张量为 $\\boldsymbol{\\varepsilon}=\\tfrac{1}{2}(\\nabla\\mathbf{u}+\\nabla\\mathbf{u}^{\\mathsf{T}})$，柯西应力为 $\\boldsymbol{\\sigma}=\\mathbb{C}(\\mathbf{x}):\\boldsymbol{\\varepsilon}$，且静力平衡（无体力）满足 $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$。\n- 各向同性相在平面应力下的本构律，其杨氏模量为 $E$，泊松比为 $\\nu$，使用 Voigt 记法 $(\\varepsilon_{xx},\\varepsilon_{yy},\\gamma_{xy})$ 表示为：\n$$\n\\mathbf{D}(E,\\nu)\\;=\\;\\frac{E}{1-\\nu^2}\\begin{bmatrix}\n1  \\nu  0\\\\\n\\nu  1  0\\\\\n0  0  \\tfrac{1-\\nu}{2}\n\\end{bmatrix},\n$$\n其中 $\\boldsymbol{\\sigma}=\\mathbf{D}\\,\\boldsymbol{\\varepsilon}$，$\\gamma_{xy}=2\\varepsilon_{xy}$ 是工程剪切应变。\n- Hill–Mandel 宏观均匀性条件和体积平均：宏观平均应力 $\\overline{\\boldsymbol{\\sigma}}$ 和宏观应变 $\\overline{\\boldsymbol{\\varepsilon}}$ 定义为\n$$\n\\overline{\\boldsymbol{\\sigma}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\\quad\n\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\varepsilon}(\\mathbf{x})\\,\\mathrm{d}\\Omega,\n$$\n并且它们在能量上是共轭的，即 $\\overline{\\boldsymbol{\\sigma}}:\\overline{\\boldsymbol{\\varepsilon}}=\\frac{1}{|\\Omega|}\\int_{\\Omega}\\boldsymbol{\\sigma}:\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega$。\n- 在运动学一致边界条件（KUBC）下，在边界 $\\partial\\Omega$ 上施加仿射位移 $\\mathbf{u}(\\mathbf{x})=\\overline{\\boldsymbol{\\varepsilon}}\\,\\mathbf{x}$ 可确保 $\\overline{\\boldsymbol{\\varepsilon}}$ 等于施加的宏观应变，并允许通过体积平均计算 $\\overline{\\boldsymbol{\\sigma}}$。\n\n任务。从这些原理出发，在一个结构化双线性四边形网格上实施一个平面应力计算均匀化过程，通过以下步骤计算非均质介质的等效泊松比：\n- 通过 KUBC 施加两个独立的宏观应变状态，\n- 对每个载荷工况，通过 FEM 求解非均质 RVE 中的平衡问题，\n- 平均得到的微观应力场，以获得等效刚度矩阵 $\\mathbf{C}^{\\mathrm{H}}$ 的前两列，\n- 反转法向子块以获得等效柔度子块 $\\mathbf{S}^{\\mathrm{H}}$，\n- 提取宏观泊松比。\n\n以 Voigt 形式指定两个独立的宏观应变状态：\n- 载荷工况 $\\mathcal{A}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}}=[\\varepsilon_{0},\\,0,\\,0]^{\\mathsf{T}}$，\n- 载荷工况 $\\mathcal{B}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{B}}=[0,\\,\\varepsilon_{0},\\,0]^{\\mathsf{T}}$，\n其中给定一个小的应变幅值 $\\varepsilon_{0}>0$。通过为每个载荷工况在 $\\partial\\Omega$ 上指定边界位移来施加 KUBC\n$$\nu_x(x,y)=\\overline{\\varepsilon}_{xx}\\,x+\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,y,\\quad\nu_y(x,y)=\\tfrac{1}{2}\\,\\overline{\\gamma}_{xy}\\,x+\\overline{\\varepsilon}_{yy}\\,y\n$$\n。\n\n令 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}}$ 和 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}}$ 表示由相应 FEM 解计算出的微观应力场的体积平均值。构建等效面内法向刚度子矩阵\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn}=\n\\begin{bmatrix}\nC^{\\mathrm{H}}_{11}  C^{\\mathrm{H}}_{12}\\\\\nC^{\\mathrm{H}}_{21}  C^{\\mathrm{H}}_{22}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\overline{\\sigma}^{\\mathcal{A}}_{xx}/\\varepsilon_{0}  \\overline{\\sigma}^{\\mathcal{B}}_{xx}/\\varepsilon_{0}\\\\\n\\overline{\\sigma}^{\\mathcal{A}}_{yy}/\\varepsilon_{0}  \\overline{\\sigma}^{\\mathcal{B}}_{yy}/\\varepsilon_{0}\n\\end{bmatrix},\n$$\n然后将其反转以获得等效面内柔度\n$$\n\\mathbf{S}^{\\mathrm{H}}_{nn}=(\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}=\n\\begin{bmatrix}\nS^{\\mathrm{H}}_{11}  S^{\\mathrm{H}}_{12}\\\\\nS^{\\mathrm{H}}_{21}  S^{\\mathrm{H}}_{22}\n\\end{bmatrix}.\n$$\n定义等效泊松比（在平面应力下）为\n$$\n\\nu^{\\mathrm{H}}_{xy}=-\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}},\\qquad\n\\nu^{\\mathrm{H}}_{yx}=-\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}.\n$$\n\n数值离散化要求：\n- 网格：一个覆盖 $[0,1]\\times[0,1]$ 的 $n_x\\times n_y$ 结构化张量积网格，包含双线性四边形单元。使用标准的 $2\\times 2$ 高斯积分。\n- 材料：基体相具有 $(E_m,\\nu_m)$，夹杂物相具有 $(E_s,\\nu_s)$，通过上述条带判据在积分点处指定。\n- 边界条件：如前述的 KUBC，无体力也无面力。\n- 未知量：每个节点的两个位移分量。\n- 后处理：通过高斯积分计算体积平均应力，并形成 $\\mathbf{C}^{\\mathrm{H}}_{nn}$ 和 $\\mathbf{S}^{\\mathrm{H}}_{nn}$。\n\n测试套件。你的程序必须运行以下四种情况，并报告每种情况的 $[\\nu^{\\mathrm{H}}_{xy},\\nu^{\\mathrm{H}}_{yx}]$ 对，四舍五入到 $6$ 位小数：\n- 情况 #1（理想情况，中等对比度）：$(n_x,n_y)=(12,12)$，$(E_m,\\nu_m)=(1.0,0.30)$，$(E_s,\\nu_s)=(100.0,0.30)$，$(p_x,p_y)=(0.25,0.25)$，$(t_x,t_y)=(0.05,0.05)$，$\\varepsilon_0=0.01$。\n- 情况 #2（仅基体，边界情况）：$(n_x,n_y)=(10,10)$，$(E_m,\\nu_m)=(1.0,0.30)$，$(E_s,\\nu_s)=(100.0,0.30)$，$(p_x,p_y)=(0.25,0.25)$，$(t_x,t_y)=(0.0,0.0)$，$\\varepsilon_0=0.01$。\n- 情况 #3（高对比度，薄条带）：$(n_x,n_y)=(16,16)$，$(E_m,\\nu_m)=(1.0,0.30)$，$(E_s,\\nu_s)=(10000.0,0.30)$，$(p_x,p_y)=(0.2,0.2)$，$(t_x,t_y)=(0.02,0.02)$，$\\varepsilon_0=0.005$。\n- 情况 #4（各向异性条带厚度）：$(n_x,n_y)=(14,10)$，$(E_m,\\nu_m)=(1.0,0.30)$，$(E_s,\\nu_s)=(1000.0,0.30)$，$(p_x,p_y)=(0.25,0.25)$，$(t_x,t_y)=(0.02,0.12)$，$\\varepsilon_0=0.01$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个逗号分隔的列表的列表，其中不含空格，按测试套件的顺序排列结果，例如\n$$\n[[\\nu^{\\mathrm{H}}_{xy,\\#1},\\nu^{\\mathrm{H}}_{yx,\\#1}],[\\nu^{\\mathrm{H}}_{xy,\\#2},\\nu^{\\mathrm{H}}_{yx,\\#2}],[\\nu^{\\mathrm{H}}_{xy,\\#3},\\nu^{\\mathrm{H}}_{yx,\\#3}],[\\nu^{\\mathrm{H}}_{xy,\\#4},\\nu^{\\mathrm{H}}_{yx,\\#4}]],\n$$\n每个浮点数四舍五入到 $6$ 位小数，且无额外文本。例如，一个有效的输出骨架是\n$$\n[[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456],[0.123456,0.123456]].\n$$", "solution": "所提出的问题是针对线性弹性复合材料的计算均匀化中的一个定义明确的练习。其目标是使用有限元法（FEM）在代表性体积单元（RVE）上计算非均质介质的等效面内泊松比。该过程在科学上是合理的，并遵循计算固体力学的标准实践。\n\n此静力线性弹性问题的有限元法基础是虚功原理，它是平衡方程 $\\nabla\\cdot\\boldsymbol{\\sigma}=\\mathbf{0}$ 的弱形式。对于一个无体力的物体 $\\Omega$，其边界为 $\\partial\\Omega$，该原理指出，对于任何在指定位移的边界部分上为零的运动学容许的虚位移场 $\\delta\\mathbf{u}$，内虚功等于外虚功：\n$$\n\\int_{\\Omega} \\boldsymbol{\\sigma}:\\delta\\boldsymbol{\\varepsilon}\\,\\mathrm{d}\\Omega = \\int_{\\partial\\Omega_t} \\mathbf{t}\\cdot\\delta\\mathbf{u}\\,\\mathrm{d}S\n$$\n其中 $\\boldsymbol{\\varepsilon}$ 是对应于位移场 $\\mathbf{u}$ 的应变张量，$\\delta\\boldsymbol{\\varepsilon}$ 是虚应变张量，$\\boldsymbol{\\sigma}$ 是柯西应力张量，$\\mathbf{t}$ 是在边界部分 $\\partial\\Omega_t$ 上施加的面力。在此问题中，位移在整个边界 $\\partial\\Omega$ 上都被指定，因此 $\\partial\\Omega_t=\\emptyset$，右侧为零。\n\n求解域，即单位正方形 RVE $\\Omega = [0,1]\\times[0,1]$，被离散化为一个由 $n_x \\times n_y$ 个双线性四边形单元组成的结构化网格。在每个单元 $\\Omega_e$ 内，位移场 $\\mathbf{u}(\\mathbf{x})$ 通过使用形函数 $N_i$ 对节点位移 $\\mathbf{U}^e$ 进行插值来近似：\n$$\n\\mathbf{u}(\\mathbf{x}) = \\sum_{i=1}^{4} N_i(\\mathbf{x}) \\mathbf{u}_i^e\n$$\n其中 $\\mathbf{u}_i^e$ 是单元第 $i$ 个节点的位移向量。单元内的应变场通过应变-位移矩阵 $\\mathbf{B}(\\mathbf{x})$ 与节点位移相关联：\n$$\n\\boldsymbol{\\varepsilon}(\\mathbf{x}) = \\sum_{i=1}^{4} \\mathbf{B}_i(\\mathbf{x}) \\mathbf{u}_i^e = \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e\n$$\n在这里，对于平面应力的 Voigt 记法，$\\boldsymbol{\\varepsilon} = [\\varepsilon_{xx}, \\varepsilon_{yy}, \\gamma_{xy}]^{\\mathsf{T}}$，节点 $i$ 的矩阵 $\\mathbf{B}_i$ 为：\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\partial N_i / \\partial x  0 \\\\ 0  \\partial N_i / \\partial y \\\\ \\partial N_i / \\partial y  \\partial N_i / \\partial x \\end{bmatrix}\n$$\n线性本构关系 $\\boldsymbol{\\sigma} = \\mathbf{D}(\\mathbf{x})\\boldsymbol{\\varepsilon}$ 将应变与应力联系起来，其中 $\\mathbf{D}(\\mathbf{x})$ 是材料刚度矩阵，由于微观结构的存在，它是位置相关的。\n\n将有限元近似代入弱形式，得到一个线性代数方程组 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$，其中 $\\mathbf{U}$ 是全局节点位移向量，$\\mathbf{K}$ 是全局刚度矩阵，$\\mathbf{F}$ 是全局力向量。全局刚度矩阵由单元刚度矩阵 $\\mathbf{k}^e$ 组装而成：\n$$\n\\mathbf{k}^e = \\int_{\\Omega_e} \\mathbf{B}^{\\mathsf{T}}(\\mathbf{x}) \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\,\\mathrm{d}\\Omega\n$$\n这个积分使用 $2 \\times 2$ 高斯求积进行数值计算。在每个高斯点，计算坐标 $(x,y)$ 以确定该点是位于刚性相还是基体相，依据的规则是 $(x \\bmod p_x) > t_x$ 或 $(y \\bmod p_y) > t_y$。然后使用相应的材料属性 $(E_s, \\nu_s)$ 或 $(E_m, \\nu_m)$ 来构建该点的 $\\mathbf{D}$ 矩阵。\n\n运动学一致边界条件（KUBC）是通过根据仿射变换 $\\mathbf{u}(\\mathbf{x}) = \\overline{\\boldsymbol{\\varepsilon}}\\cdot\\mathbf{x}$ 来指定边界 $\\partial\\Omega$ 上所有节点的位移来施加的，其中 $\\overline{\\boldsymbol{\\varepsilon}}$ 是指定的宏观应变张量。这需要对全局方程组进行分块。全局位移向量 $\\mathbf{U}$ 被分为内部节点的未知位移 $\\mathbf{U}_I$ 和边界节点的已知位移 $\\mathbf{U}_B$。系统 $\\mathbf{K}\\mathbf{U}=\\mathbf{F}$ 被分块为：\n$$\n\\begin{bmatrix} \\mathbf{K}_{II}  \\mathbf{K}_{IB} \\\\ \\mathbf{K}_{BI}  \\mathbf{K}_{BB} \\end{bmatrix} \\begin{Bmatrix} \\mathbf{U}_I \\\\ \\mathbf{U}_B \\end{Bmatrix} = \\begin{Bmatrix} \\mathbf{F}_I \\\\ \\mathbf{F}_B \\end{Bmatrix}\n$$\n由于没有体力，内部节点上的力 $\\mathbf{F}_I$ 为零。通过求解简化系统来找到未知的内部位移：\n$$\n\\mathbf{K}_{II} \\mathbf{U}_I = -\\mathbf{K}_{IB} \\mathbf{U}_B\n$$\n一旦计算出 $\\mathbf{U}_I$，整个位移场就已知了。\n\n下一步是计算体积平均应力张量 $\\overline{\\boldsymbol{\\sigma}}$。因为 RVE 的面积为单位面积（$|\\Omega|=1$），所以这只是微观应力在域上的积分：\n$$\n\\overline{\\boldsymbol{\\sigma}} = \\int_{\\Omega} \\boldsymbol{\\sigma}(\\mathbf{x}) \\,\\mathrm{d}\\Omega = \\sum_{e} \\int_{\\Omega_e} \\mathbf{D}(\\mathbf{x}) \\mathbf{B}(\\mathbf{x}) \\mathbf{U}^e \\,\\mathrm{d}\\Omega\n$$\n这也通过在所有单元上进行高斯求积来数值评估。\n\n这整个过程对两种独立的宏观应变状态执行两次：\n1.  载荷工况 $\\mathcal{A}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{A}} = [\\varepsilon_0, 0, 0]^{\\mathsf{T}}$（$x$方向的单轴应变）。有限元解产生平均应力向量 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{A}} = [\\overline{\\sigma}^{\\mathcal{A}}_{xx}, \\overline{\\sigma}^{\\mathcal{A}}_{yy}, \\overline{\\sigma}^{\\mathcal{A}}_{xy}]^{\\mathsf{T}}$。\n2.  载荷工况 $\\mathcal{B}$：$\\overline{\\boldsymbol{\\varepsilon}}^{\\mathcal{B}} = [0, \\varepsilon_0, 0]^{\\mathsf{T}}$（$y$方向的单轴应变）。有限元解产生 $\\overline{\\boldsymbol{\\sigma}}^{\\mathcal{B}} = [\\overline{\\sigma}^{\\mathcal{B}}_{xx}, \\overline{\\sigma}^{\\mathcal{B}}_{yy}, \\overline{\\sigma}^{\\mathcal{B}}_{xy}]^{\\mathsf{T}}$。\n\n根据关系式 $\\overline{\\boldsymbol{\\sigma}} = \\mathbf{C}^{\\mathrm{H}}\\overline{\\boldsymbol{\\varepsilon}}$，确定等效刚度矩阵 $\\mathbf{C}^{\\mathrm{H}}$ 的前两列。按指定方式构建面内法向子矩阵：\n$$\n\\mathbf{C}^{\\mathrm{H}}_{nn} = \\begin{bmatrix} C^{\\mathrm{H}}_{11}  C^{\\mathrm{H}}_{12}\\\\ C^{\\mathrm{H}}_{21}  C^{\\mathrm{H}}_{22} \\end{bmatrix} = \\frac{1}{\\varepsilon_0} \\begin{bmatrix} \\overline{\\sigma}^{\\mathcal{A}}_{xx}  \\overline{\\sigma}^{\\mathcal{B}}_{xx}\\\\ \\overline{\\sigma}^{\\mathcal{A}}_{yy}  \\overline{\\sigma}^{\\mathcal{B}}_{yy} \\end{bmatrix}\n$$\n相应的等效柔度子矩阵 $\\mathbf{S}^{\\mathrm{H}}_{nn}$ 通过求逆得到：$\\mathbf{S}^{\\mathrm{H}}_{nn} = (\\mathbf{C}^{\\mathrm{H}}_{nn})^{-1}$。\n\n最后，从柔度矩阵中提取等效泊松比。根据定义，在单轴应力 $\\sigma_{ii}$ 下，$\\nu_{ij} = -\\varepsilon_{jj}/\\varepsilon_{ii}$。用柔度分量表示，这转换为：\n$$\n\\nu^{\\mathrm{H}}_{xy} = -\\frac{S^{\\mathrm{H}}_{21}}{S^{\\mathrm{H}}_{11}}, \\qquad \\nu^{\\mathrm{H}}_{yx} = -\\frac{S^{\\mathrm{H}}_{12}}{S^{\\mathrm{H}}_{22}}\n$$\n这样就完成了计算均匀化过程。所实现的代码将对提供的每个测试用例遵循这些步骤。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to run the computational homogenization for all test cases.\n    \"\"\"\n    test_cases = [\n        {'nx': 12, 'ny': 12, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.05, 0.05), 'eps0': 0.01},\n        {'nx': 10, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (100.0, 0.30), 'geo': (0.25, 0.25, 0.0, 0.0), 'eps0': 0.01},\n        {'nx': 16, 'ny': 16, 'mat_m': (1.0, 0.30), 'mat_s': (10000.0, 0.30), 'geo': (0.2, 0.2, 0.02, 0.02), 'eps0': 0.005},\n        {'nx': 14, 'ny': 10, 'mat_m': (1.0, 0.30), 'mat_s': (1000.0, 0.30), 'geo': (0.25, 0.25, 0.02, 0.12), 'eps0': 0.01}\n    ]\n\n    all_results = []\n\n    # Gauss quadrature points and weights for a 2x2 scheme\n    gauss_points = np.array([-1/np.sqrt(3), 1/np.sqrt(3)])\n    gauss_weights = np.array([1.0, 1.0])\n\n    for case in test_cases:\n        nx, ny = case['nx'], case['ny']\n        (E_m, nu_m) = case['mat_m']\n        (E_s, nu_s) = case['mat_s']\n        (px, py, tx, ty) = case['geo']\n        eps0 = case['eps0']\n\n        def get_D_matrix(E, nu):\n            factor = E / (1 - nu**2)\n            return factor * np.array([[1, nu, 0], [nu, 1, 0], [0, 0, (1 - nu)/2]])\n\n        D_m = get_D_matrix(E_m, nu_m)\n        D_s = get_D_matrix(E_s, nu_s)\n\n        def is_stiff(x, y):\n            if tx > 0 and (np.fmod(x, px) > tx):\n                return True\n            if ty > 0 and (np.fmod(y, py) > ty):\n                return True\n            return False\n\n        def get_fem_solution(macro_strain_voigt):\n            macro_eps_xx, macro_eps_yy, macro_gamma_xy = macro_strain_voigt\n            \n            hx, hy = 1.0/nx, 1.0/ny\n            num_nodes = (nx + 1) * (ny + 1)\n            num_dofs = 2 * num_nodes\n            \n            K = lil_matrix((num_dofs, num_dofs))\n            \n            node_coords = np.zeros(((nx + 1) * (ny + 1), 2))\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    node_idx = i * (ny + 1) + j\n                    node_coords[node_idx] = [i * hx, j * hy]\n\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [\n                        el_i * (ny + 1) + el_j,          # bottom-left\n                        (el_i + 1) * (ny + 1) + el_j,    # bottom-right\n                        (el_i + 1) * (ny + 1) + (el_j + 1),# top-right\n                        el_i * (ny + 1) + (el_j + 1)       # top-left\n                    ]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n                    \n                    el_coords = node_coords[node_indices]\n                    ke = np.zeros((8, 8))\n\n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            # Shape functions and their derivatives in master coords\n                            N_deriv_master = 0.25 * np.array([\n                                [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)],\n                                [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)]\n                            ])\n                            \n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            \n                            N_deriv_physical = invJ @ N_deriv_master\n                            \n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]\n                                B[1, 2*k+1] = N_deriv_physical[1, k]\n                                B[2, 2*k] = N_deriv_physical[1, k]\n                                B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            # Material properties at Gauss point\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            ke += B.T @ D @ B * detJ * gauss_weights[i] * gauss_weights[j]\n\n                    for r in range(8):\n                        for c in range(8):\n                            K[dof_indices[r], dof_indices[c]] += ke[r, c]\n            \n            K = K.tocsc()\n            \n            boundary_dofs = []\n            for i in range(nx + 1):\n                for j in range(ny + 1):\n                    if i == 0 or i == nx or j == 0 or j == ny:\n                        node_idx = i * (ny + 1) + j\n                        boundary_dofs.extend([2 * node_idx, 2 * node_idx + 1])\n            \n            all_dofs = np.arange(num_dofs)\n            interior_dofs = np.setdiff1d(all_dofs, boundary_dofs)\n            \n            U_b = np.zeros(len(boundary_dofs))\n            for i, dof in enumerate(boundary_dofs):\n                node_idx = dof // 2\n                coord = node_coords[node_idx]\n                if dof % 2 == 0: # x-displacement\n                    U_b[i] = macro_eps_xx * coord[0] + 0.5 * macro_gamma_xy * coord[1]\n                else: # y-displacement\n                    U_b[i] = 0.5 * macro_gamma_xy * coord[0] + macro_eps_yy * coord[1]\n\n            K_II = K[interior_dofs, :][:, interior_dofs]\n            K_IB = K[interior_dofs, :][:, boundary_dofs]\n            \n            F_eff = -K_IB @ U_b\n            \n            U_I = spsolve(K_II, F_eff)\n            \n            U = np.zeros(num_dofs)\n            U[interior_dofs] = U_I\n            U[boundary_dofs] = U_b\n\n            # Post-processing: stress averaging\n            avg_stress = np.zeros(3)\n            for el_i in range(nx):\n                for el_j in range(ny):\n                    node_indices = [el_i*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j, (el_i+1)*(ny+1)+el_j+1, el_i*(ny+1)+el_j+1]\n                    dof_indices = []\n                    for idx in node_indices:\n                        dof_indices.extend([2 * idx, 2 * idx + 1])\n\n                    el_coords = node_coords[node_indices]\n                    el_U = U[dof_indices]\n                    \n                    for i, xi in enumerate(gauss_points):\n                        for j, eta in enumerate(gauss_points):\n                            N_deriv_master = 0.25 * np.array([ [-(1 - eta), (1 - eta), (1 + eta), -(1 + eta)], [-(1 - xi), -(1 + xi), (1 + xi), (1 - xi)] ])\n                            J = N_deriv_master @ el_coords\n                            detJ = np.linalg.det(J)\n                            invJ = np.linalg.inv(J)\n                            N_deriv_physical = invJ @ N_deriv_master\n                            B = np.zeros((3, 8))\n                            for k in range(4):\n                                B[0, 2*k] = N_deriv_physical[0, k]; B[1, 2*k+1] = N_deriv_physical[1, k]; B[2, 2*k] = N_deriv_physical[1, k]; B[2, 2*k+1] = N_deriv_physical[0, k]\n\n                            N_shape = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                            gp_coord = N_shape @ el_coords\n                            D = D_s if is_stiff(gp_coord[0], gp_coord[1]) else D_m\n\n                            strain = B @ el_U\n                            stress = D @ strain\n                            avg_stress += stress * detJ * gauss_weights[i] * gauss_weights[j]\n            return avg_stress\n\n        # Load Case A: Uniaxial strain in x\n        avg_stress_A = get_fem_solution([eps0, 0.0, 0.0])\n        # Load Case B: Uniaxial strain in y\n        avg_stress_B = get_fem_solution([0.0, eps0, 0.0])\n\n        C_H_11 = avg_stress_A[0] / eps0\n        C_H_21 = avg_stress_A[1] / eps0\n        C_H_12 = avg_stress_B[0] / eps0\n        C_H_22 = avg_stress_B[1] / eps0\n\n        C_H_nn = np.array([[C_H_11, C_H_12], [C_H_21, C_H_22]])\n        S_H_nn = np.linalg.inv(C_H_nn)\n\n        nu_H_xy = -S_H_nn[1, 0] / S_H_nn[0, 0]\n        nu_H_yx = -S_H_nn[0, 1] / S_H_nn[1, 1]\n        \n        all_results.append(f\"[{nu_H_xy:.6f},{nu_H_yx:.6f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2546256"}, {"introduction": "计算均匀化方法的一个核心前提是，我们选择的计算模型——代表性体积单元（RVE）——必须足够大，以“代表”整个材料的统计特性。然而，“足够大”究竟是多大？本实践旨在解决这个至关重要的问题 [@problem_id:2546329]。您将实现一个基于希尔（Hill）统计准则的算法，通过分析不同尺寸窗口下表观模量集合的统计数据，来确定满足精度要求的最小 RVE 尺寸。这项练习将您的技能从执行单次 RVE 模拟提升到对均匀化模型本身进行统计验证的更高层次。", "problem": "给定多个从尺寸递增的立方体材料窗口的介观有限元模拟中获得的表观弹性模量集成。在使用代表性体积单元（RVE）的计算均匀化中，人们使用 Hill 的宏观均匀性论证来证明一个足够大的统计窗口应表现出稳定的表观模量：当运动学容许场的微观应力功率的体积平均值等于宏观应力功率时，即实现了宏观功共轭，并且在统计上，表观模量随窗口尺寸的增加而稳定。在实践中，RVE 尺寸是通过统计方法确定的，要求相对于大窗口参考的系统偏差小，并且跨实现的抽样不确定性也小。\n\n你的任务是实现一个算法，该算法在给定一组离散的窗口尺寸以及每个尺寸对应的表观模量值集成的情况下，根据统计 Hill 准则确定符合 RVE 资格的最小窗口尺寸。\n\n从以下基本定义和原则开始：\n- Hill–Mandel 宏观均匀性条件：在没有体积力的情况下，对于运动学容许场，宏观应力功率等于微观应力功率的体积平均值。\n- 对统计均匀微结构的各态历经假设：在大窗口极限下，集成平均代表体积平均。\n- 基于 Student 分布的方差未知样本均值的置信区间。\n\n将统计 Hill 准则定义如下。令 $L_1 < L_2 < \\dots < L_K$ 为递增的窗口尺寸，对于每个 $L_i$，令 $\\{E_{i,j}\\}_{j=1}^{N_i}$ 为表观模量值的集成（在固定宏观加载路径下的标量有效模量）。将在尺寸 $L_i$ 下的集成均值记为 $\\bar{E}(L_i)$，其无偏样本标准差记为 $s(L_i)$。令最大尺寸 $L_K$ 作为参考，其参考均值为 $\\bar{E}_{\\mathrm{ref}} = \\bar{E}(L_K)$。对于指定的双侧置信水平 $1-\\alpha$（使用 $1-\\alpha = 0.95$）和公差 $\\tau_\\mu$ 及 $\\tau_{\\mathrm{hw}}$（以小数形式提供），定义：\n- 尺寸 $L_i$ 下的相对偏差为 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。\n- $\\bar{E}(L_i)$ 的双侧置信区间的半宽度为 $h(L_i) = t_{1-\\alpha/2,\\;N_i-1}\\, \\dfrac{s(L_i)}{\\sqrt{N_i}}$，其中 $t_{1-\\alpha/2,\\;N_i-1}$ 是具有 $N_i - 1$ 个自由度的 Student 分布的分位数。\n- 相对半宽度为 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。\n\n如果 $b(L_i) \\le \\tau_\\mu$ 和 $r(L_i) \\le \\tau_{\\mathrm{hw}}$ 同时成立，则尺寸 $L_i$ 是可接受的。RVE 尺寸是满足以下条件的最小 $L_i$：对于所有 $j \\ge i$ 的更大尺寸 $L_j$ 都是可接受的。如果不存在这样的 $L_i$，则报告无 RVE。\n\n物理和数值单位：\n- 窗口尺寸 $L_i$ 以微米为单位，你必须以整数形式报告所选的 RVE 尺寸（单位：微米）。\n- 表观模量 $E_{i,j}$ 以吉帕斯卡为单位。\n- 置信水平为 $1-\\alpha = 0.95$。\n- 公差 $\\tau_\\mu$ 和 $\\tau_{\\mathrm{hw}}$ 以小数形式给出（例如，$0.02$ 表示百分之二）。\n\n边界情况：\n- 如果 $N_i < 2$，将抽样不确定性视为不确定（将 $r(L_i)$ 设为 $+\\infty$）。\n- 如果 $|\\bar{E}_{\\mathrm{ref}}| = 0$，将问题视为不适定问题，并报告无 RVE。\n\n实现一个程序，为以下四个测试数据集中的每一个计算 RVE 尺寸。如果某个数据集不存在 RVE 尺寸，则返回 $-1$。\n\n测试套件（每个数据集提供尺寸、每个尺寸的模量集成以及公差 $(\\tau_\\mu,\\tau_{\\mathrm{hw}})$）：\n\n1) 数据集 A:\n- 尺寸 (微米): $[20, 40, 80, 160]$.\n- 集成 (吉帕斯卡):\n  - $L=20$: $[44.0, 47.5, 43.5, 46.2, 44.8, 45.1]$.\n  - $L=40$: $[48.2, 49.5, 50.1, 49.0, 48.7, 49.3]$.\n  - $L=80$: $[49.6, 50.2, 49.8, 49.9, 50.1, 49.7]$.\n  - $L=160$: $[50.0, 49.9, 50.2, 49.8, 50.1, 49.9]$.\n- 公差: $(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.02, 0.03)$.\n\n2) 数据集 B:\n- 尺寸 (微米): $[10, 20, 40]$.\n- 集成 (吉帕斯卡):\n  - $L=10$: $[26.0, 34.0, 30.0, 29.0]$.\n  - $L=20$: $[28.0, 32.0, 29.0, 31.0]$.\n  - $L=40$: $[28.9, 30.5, 31.1, 29.5]$.\n- 公差: $(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.01, 0.01)$.\n\n3) 数据集 C:\n- 尺寸 (微米): $[30, 60, 90]$.\n- 集成 (吉帕斯卡):\n  - $L=30$: $[99.8, 100.5, 100.1, 99.9, 100.2, 99.7]$.\n  - $L=60$: $[100.3, 100.0, 99.7, 100.2, 99.9, 100.1]$.\n  - $L=90$: $[100.2, 99.6, 100.4, 99.8, 100.1, 100.0]$.\n- 公差: $(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.02, 0.02)$.\n\n4) 数据集 D:\n- 尺寸 (微米): $[15, 30, 60, 120]$.\n- 集成 (吉帕斯卡):\n  - $L=15$: $[190.0, 205.0, 198.0, 202.0, 196.0, 201.0]$.\n  - $L=30$: $[199.7, 200.3, 200.2, 199.9, 200.1, 200.0]$.\n  - $L=60$: $[196.8, 196.9, 196.7, 196.8, 196.9, 196.7]$.\n  - $L=120$: $[199.8, 200.1, 200.3, 199.7, 200.2, 200.0]$.\n- 公差: $(\\tau_\\mu, \\tau_{\\mathrm{hw}}) = (0.015, 0.02)$.\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个 RVE 的确定结果，每个数据集一个，形式为用方括号括起来的逗号分隔列表（例如，$[40,-1,30,120]$）。每个条目必须是微米为单位的整数窗口尺寸，如果根据规定准则未找到 RVE，则为 $-1$。", "solution": "该算法基于 Hill–Mandel 宏观均匀性条件和集成属性的统计估计。Hill–Mandel 条件指出，对于运动学容许的微观场和可忽略的体积力，宏观应力功率等于微观应力功率的体积平均值。在计算均匀化中，随着采样窗口的增大，在容许边界条件下计算出的表观模量会趋于稳定。假设统计均匀性和各态历经性，在给定窗口尺寸下对各实现的集成平均可近似体积平均，大数定律保证了样本均值会逼近真实均值，且不确定性随样本数量的增加而减小。\n\n为实施 Hill 的统计 RVE 准则，我们监测每个窗口尺寸 $L_i$ 的两个量：\n\n1) 相对于大窗口参考 $\\bar{E}_{\\mathrm{ref}}$ 的相对偏差 $b(L_i)$，定义为 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。这概括了相对于所考虑的最大窗口的系统性尺寸效应。\n\n2) 尺寸 $L_i$ 下平均模量的 $(1-\\alpha)$ 双侧置信区间的相对半宽度 $r(L_i)$。对于方差未知的集成 $\\{E_{i,j}\\}_{j=1}^{N_i}$，无偏样本标准差为 $s(L_i)$，双侧置信区间的半宽度为 $h(L_i) = t_{1-\\alpha/2,\\,N_i-1}\\,\\dfrac{s(L_i)}{\\sqrt{N_i}}$，其中 $t_{1-\\alpha/2,\\,\\nu}$ 是具有 $\\nu$ 个自由度的 Student 分布的 $(1-\\alpha/2)$ 分位数。相对半宽度为 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。如果 $N_i < 2$，则无法估计不确定性，我们设 $r(L_i) = +\\infty$。\n\n统计 Hill 准则要求在 $L_i$ 处接受的条件是同时满足 $b(L_i) \\le \\tau_\\mu$（小偏差）和 $r(L_i) \\le \\tau_{\\mathrm{hw}}$（小不确定性）。为了体现随窗口尺寸增加的稳定性，我们将 RVE 尺寸定义为满足以下条件的最小 $L_i$：对于所有 $j \\ge i$，两个不等式都成立。如果连最大尺寸 $L_K$ 都未能通过不确定性阈值（例如，由于变异性非常高或样本太少），那么没有候选尺寸能满足稳定性条件，结果为 $-1$。\n\n每个数据集的算法步骤：\n- 输入：递增尺寸 $\\{L_i\\}_{i=1}^K$、集成 $\\{E_{i,j}\\}_{j=1}^{N_i}$、公差 $(\\tau_\\mu,\\tau_{\\mathrm{hw}})$、置信水平 $1-\\alpha = 0.95$。\n- 计算 $\\bar{E}_{\\mathrm{ref}} = \\bar{E}(L_K)$ 作为参考均值。如果 $|\\bar{E}_{\\mathrm{ref}}| = 0$，返回 $-1$。\n- 对每个 $i \\in \\{1,\\dots,K\\}$：\n  - 计算 $\\bar{E}(L_i)$ 和 $s(L_i)$（使用 Bessel 校正）。\n  - 如果 $N_i \\ge 2$，计算 $h(L_i) = t_{0.975,\\,N_i-1}\\,\\dfrac{s(L_i)}{\\sqrt{N_i}}$ 和 $r(L_i) = \\dfrac{h(L_i)}{|\\bar{E}_{\\mathrm{ref}}|}$。如果 $N_i < 2$，设 $r(L_i) = +\\infty$。\n  - 计算 $b(L_i) = \\dfrac{|\\bar{E}(L_i) - \\bar{E}_{\\mathrm{ref}}|}{|\\bar{E}_{\\mathrm{ref}}|}$。\n  - 如果 $b(L_i) \\le \\tau_\\mu$ 且 $r(L_i) \\le \\tau_{\\mathrm{hw}}$，则将 $L_i$ 标记为可接受。\n- 按升序扫描尺寸，并选择满足以下条件的最小 $L_i$：所有 $j \\ge i$ 的 $L_j$ 均可接受。如果没有，则返回 $-1$。\n\n关于测试数据集的推理：\n\n- 数据集 A：最大尺寸 $L=160$ 的集成紧密围绕在约 $50$ 吉帕斯卡，因此 $\\bar{E}_{\\mathrm{ref}}$ 接近 $50$ 且 $r(160)$ 很小。对于 $L=20$，相对于参考值的偏差很大，因此不可接受。对于 $L=40$ 和 $L=80$，$b(L_i)$ 和 $r(L_i)$ 都足够小，满足条件。因此，最小的稳定尺寸是 $L=40$，因为从它开始往后所有尺寸都可接受。\n\n- 数据集 B：最大尺寸 $L=40$ 在 $95\\%$ 置信水平下，其半宽度相对于其均值仍然较大，超过了 $\\tau_{\\mathrm{hw}} = 0.01$。因此，即使是最大尺寸也不可接受；稳定性条件无法被任何前缀满足，得出 $-1$。\n\n- 数据集 C：所有尺寸都紧密聚集在约 $100$ 吉帕斯卡周围，并且相对于最大尺寸的参考值，都满足两个阈值。稳定性从最小尺寸开始就成立，所以最小尺寸是 $L=30$。\n\n- 数据集 D：尽管 $L=30$ 的偏差和不确定性本身是可接受的，但中间尺寸 $L=60$ 的均值接近 $196.8$ 吉帕斯卡，相对于接近 $200$ 吉帕斯卡的最大尺寸参考值，其引入的相对偏差略高于 $\\tau_\\mu = 0.015$。因此，$L=30$ 不满足稳定性要求（即其后的所有尺寸都必须可接受）。在其之后所有更大尺寸都可接受的最小尺寸是 $L=120$。\n\n该程序实现了上述过程，使用 $\\nu = N_i - 1$ 的 Student 分位数 $t_{0.975,\\nu}$，并按要求将四个确定结果返回在一个列表中。输出是以微米为单位的整数，或在适用情况下为 $-1$。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import t\n\ndef compute_rve_size(sizes, ensembles, tol_mean, tol_hw, conf_level=0.95):\n    \"\"\"\n    Determine minimal RVE size based on statistical Hill criterion with stability.\n\n    Parameters:\n        sizes (list of int): Increasing window sizes (micrometers).\n        ensembles (list of list of float): For each size, the list of apparent moduli (GPa).\n        tol_mean (float): Relative bias tolerance (decimal).\n        tol_hw (float): Relative half-width tolerance (decimal).\n        conf_level (float): Two-sided confidence level (default 0.95).\n\n    Returns:\n        int: Minimal RVE size (micrometers), or -1 if none exists.\n    \"\"\"\n    # Convert to numpy arrays for convenience\n    K = len(sizes)\n    # Reference mean at largest size\n    ref_vals = np.array(ensembles[-1], dtype=float)\n    if ref_vals.size == 0:\n        return -1\n    E_ref = np.mean(ref_vals)\n    if abs(E_ref) == 0.0:\n        return -1\n\n    # Precompute acceptability for each size\n    acceptable = []\n    alpha = 1.0 - conf_level\n    for i in range(K):\n        vals = np.array(ensembles[i], dtype=float)\n        Ni = vals.size\n        if Ni == 0:\n            acceptable.append(False)\n            continue\n        mean_i = float(np.mean(vals))\n        # Sample standard deviation with Bessel's correction if possible\n        if Ni >= 2:\n            s_i = float(np.std(vals, ddof=1))\n            # Student-t critical value for two-sided CI\n            tcrit = float(t.ppf(1.0 - alpha / 2.0, df=Ni - 1))\n            hw = tcrit * s_i / np.sqrt(Ni)\n            rel_hw = hw / abs(E_ref)\n        else:\n            # Indeterminate uncertainty with single sample\n            rel_hw = float('inf')\n\n        rel_bias = abs(mean_i - E_ref) / abs(E_ref)\n        acceptable.append((rel_bias <= tol_mean) and (rel_hw <= tol_hw))\n\n    # Enforce stability: find minimal i such that all j >= i are acceptable\n    for i in range(K):\n        if all(acceptable[i:]):\n            return int(sizes[i])\n\n    return -1\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Dataset A\n    sizes_A = [20, 40, 80, 160]\n    ensembles_A = [\n        [44.0, 47.5, 43.5, 46.2, 44.8, 45.1],\n        [48.2, 49.5, 50.1, 49.0, 48.7, 49.3],\n        [49.6, 50.2, 49.8, 49.9, 50.1, 49.7],\n        [50.0, 49.9, 50.2, 49.8, 50.1, 49.9],\n    ]\n    tol_mean_A, tol_hw_A = 0.02, 0.03\n\n    # Dataset B\n    sizes_B = [10, 20, 40]\n    ensembles_B = [\n        [26.0, 34.0, 30.0, 29.0],\n        [28.0, 32.0, 29.0, 31.0],\n        [28.9, 30.5, 31.1, 29.5],\n    ]\n    tol_mean_B, tol_hw_B = 0.01, 0.01\n\n    # Dataset C\n    sizes_C = [30, 60, 90]\n    ensembles_C = [\n        [99.8, 100.5, 100.1, 99.9, 100.2, 99.7],\n        [100.3, 100.0, 99.7, 100.2, 99.9, 100.1],\n        [100.2, 99.6, 100.4, 99.8, 100.1, 100.0],\n    ]\n    tol_mean_C, tol_hw_C = 0.02, 0.02\n\n    # Dataset D\n    sizes_D = [15, 30, 60, 120]\n    ensembles_D = [\n        [190.0, 205.0, 198.0, 202.0, 196.0, 201.0],\n        [199.7, 200.3, 200.2, 199.9, 200.1, 200.0],\n        [196.8, 196.9, 196.7, 196.8, 196.9, 196.7],\n        [199.8, 200.1, 200.3, 199.7, 200.2, 200.0],\n    ]\n    tol_mean_D, tol_hw_D = 0.015, 0.02\n\n    test_cases = [\n        (sizes_A, ensembles_A, tol_mean_A, tol_hw_A),\n        (sizes_B, ensembles_B, tol_mean_B, tol_hw_B),\n        (sizes_C, ensembles_C, tol_mean_C, tol_hw_C),\n        (sizes_D, ensembles_D, tol_mean_D, tol_hw_D),\n    ]\n\n    results = []\n    for sizes, ensembles, tol_m, tol_hw in test_cases:\n        rve_size = compute_rve_size(sizes, ensembles, tol_m, tol_hw, conf_level=0.95)\n        results.append(rve_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2546329"}]}