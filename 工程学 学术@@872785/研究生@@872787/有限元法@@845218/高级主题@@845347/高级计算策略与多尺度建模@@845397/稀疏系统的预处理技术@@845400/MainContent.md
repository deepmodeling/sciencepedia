## 引言
在现代科学与工程计算中，有限元等数值方法被广泛用于模拟复杂的物理现象，这通常会产生包含数百万甚至数十亿未知数的[大型稀疏线性系统](@entry_id:137968)。直接求解这些系统是不可行的，而标准的[迭代求解器](@entry_id:136910)在面对这些系统固有的“病态”特性时，其[收敛速度](@entry_id:636873)往往随着问题规模的增大而急剧下降。这构成了大规模仿真中的核心计算瓶颈。[预处理](@entry_id:141204)技术正是为攻克这一难题而生，它通过巧妙的代数变换，将原始的困难问题转化为一个等价且易于求解的问题，从而极大地加速了迭代过程。

本文旨在为读者提供一个关于[稀疏系统](@entry_id:168473)预处理技术的全面而深入的指南。我们将从基本原理出发，逐步探索高级方法及其在前沿科学中的应用。
- 在“**原理与机制**”一章中，我们将阐明预处理的根本必要性，深入探讨条件数、[误差放大](@entry_id:749086)等核心概念，并解释预处理器如何从机制上改善系统的代数性质，为对称与非对称系统建立起坚实的理论基础。
- 接着，在“**应用与交叉学科联系**”一章中，我们将展示这些理论的实际威力，考察从通用的不完全分解到专为[可扩展性](@entry_id:636611)设计的多重网格和[区域分解](@entry_id:165934)方法，并探讨它们如何在[计算力学](@entry_id:174464)、电磁学等领域中解决具体的工程挑战。
- 最后，“**动手实践**”部分将提供一系列精心设计的问题，帮助读者通过实践加深对误差平滑、性能权衡等关键概念的理解。

通过本次学习，您将掌握设计、选择和评估预处理器的核心知识，为解决[大规模科学计算](@entry_id:155172)问题打下坚实的基础。

## 原理与机制

在本章中，我们将深入探讨预处理技术的核心科学原理与关键机制。在上一章的介绍之后，我们已经理解了在有限元等数值方法产生的[大型稀疏线性系统](@entry_id:137968)中，[迭代求解器](@entry_id:136910)的性能至关重要。本章的目标是系统地阐明为何需要预处理，预处理旨在实现什么，以及它如何通过改变代数系统的性质来加速收敛。我们将从[对称正定](@entry_id:145886)（SPD）系统开始，建立关于条件数和[误差放大](@entry_id:749086)的基本概念，然后扩展到更普适的非对称系统，并最终探讨在[高性能计算](@entry_id:169980)环境中衡量[预处理器](@entry_id:753679)质量的准则。

### [预处理](@entry_id:141204)的必要性：病态问题

在数值求解中，一个核心挑战是线性系统 $A x = b$ 的**病态（ill-conditioning）**问题。系统的“健康状况”可以通过其**条件数（condition number）**来量化。对于一个可逆矩阵 $A$，其谱[条件数](@entry_id:145150)（[2-范数](@entry_id:636114)[条件数](@entry_id:145150)）定义为 $\kappa_2(A) = \| A \|_2 \| A^{-1} \|_2$。对于在有限元分析中至关重要的[对称正定](@entry_id:145886)（SPD）矩阵 $A$，该定义可以简化。由于SPD矩阵的[2-范数](@entry_id:636114)等于其最大[特征值](@entry_id:154894) $\lambda_{\max}(A)$，其[逆矩阵](@entry_id:140380) $A^{-1}$ 的[2-范数](@entry_id:636114)等于 $1/\lambda_{\min}(A)$，其中 $\lambda_{\min}(A)$ 是 $A$ 的最小特征值。因此，对于[SPD矩阵](@entry_id:136714)，[条件数](@entry_id:145150)有一个直观的[光谱](@entry_id:185632)解释：

$$
\kappa_2(A) = \frac{\lambda_{\max}(A)}{\lambda_{\min}(A)}
$$

[条件数](@entry_id:145150)始终大于或等于1。当 $\kappa_2(A)$ 接近1时，我们称系统是**良态的（well-conditioned）**；当 $\kappa_2(A)$ 远大于1时，系统是**病态的（ill-conditioned）**。

病态的后果是灾难性的，因为它直接关系到解对扰动的敏感性。考虑两种常见情况：
1.  **右端项扰动**：如果右端项 $b$ 有一个小的扰动 $\delta b$，它会引起解的扰动 $\delta x = A^{-1}\delta b$。解的相对误差由以下不等式界定：
    $$
    \frac{\| \delta x \|_{2}}{\| x \|_{2}} \le \kappa_2(A) \frac{\| \delta b \|_{2}}{\| b \|_{2}}
    $$
    这意味着右端项的相对误差被条件数放大了。一个巨大的 $\kappa_2(A)$ 意味着即使是微小的输入误差（例如由[浮点](@entry_id:749453)算术引起的误差）也可能导致解的巨大变化。

2.  **近似解的残差**：假设我们通过某个迭代过程得到了一个近似解 $\hat{x}$。其质量通常通过**残差（residual）** $r = b - A \hat{x}$ 来衡量。然而，我们真正关心的是**[前向误差](@entry_id:168661)（forward error）** $x - \hat{x}$。这两者之间的关系同样由[条件数](@entry_id:145150)支配：
    $$
    \frac{\| x - \hat{x} \|_{2}}{\| x \|_{2}} \le \kappa_2(A) \frac{\| r \|_{2}}{\| b \|_{2}}
    $$
    这个不等式揭示了一个令人不安的事实：即使残差非常小，如果系统是病态的，[前向误差](@entry_id:168661)也可能非常大。因此，仅凭小残差就判断解的准确性是不可靠的。

不幸的是，[病态问题](@entry_id:137067)在有限元分析中并非特例，而是常态。考虑一个典型的例子：在二维有界区域上求解泊松方程 $-\Delta u = f$，并采用分片线性有限元进行离散化。假设我们在一系列拟一致（quasi-uniform）的网格上进行计算，网格尺寸为 $h$。由此产生的刚度矩阵 $A_h$ 是SPD的。通过基于[瑞利商](@entry_id:137794)（Rayleigh quotient）的分析，并结合有限元函数空间中的标准[范数等价](@entry_id:137561)性、[逆不等式](@entry_id:750800)和[庞加莱不等式](@entry_id:142086)，可以严格证明该刚度[矩阵的[条件](@entry_id:150947)数](@entry_id:145150)与网格尺寸 $h$ 存在如下渐近关系：

$$
\kappa_2(A_h) = \mathcal{O}(h^{-2})
$$

这个结果是有限元数值分析的基石之一。它表明，随着我们为了提高解的精度而细化网格（即 $h \to 0$），[线性系统](@entry_id:147850)的条件数会急剧恶化。例如，将网格尺寸减半会导致条件数增大四倍。这种代数难度的迅速增长使得直接使用[迭代法](@entry_id:194857)（如[共轭梯度法](@entry_id:143436)）求解变得不切实际，因为[收敛速度](@entry_id:636873)会随着[网格细化](@entry_id:168565)而变得越来越慢。这正是预处理技术发挥作用的根本原因。

### [预处理](@entry_id:141204)的目标与核心思想

既然原始系统 $A x = b$ 可能病态，我们的目标就是将其转化为一个等价且更“健康”的系统。这就是**[预处理](@entry_id:141204)（preconditioning）**的核心思想。

一个**[预处理器](@entry_id:753679)（preconditioner）**是一个可逆矩阵 $M$，它在某种意义上是原矩阵 $A$ 的一个“廉价”近似。这里的“廉价”有两层含义：
1.  $M$ 应该能捕捉 $A$ 的主要性质，使得 $M^{-1}A$ 或 $AM^{-1}$ 的性质比 $A$ 本身更好。理想情况下，$M \approx A$，那么 $M^{-1}A \approx I$（单位矩阵）。
2.  求解形如 $Mz = r$ 的[线性系统](@entry_id:147850)（即应用 $M^{-1}$）必须非常高效，其计算成本远低于求解原系统 $Ax=b$。

这是一个根本性的权衡：$M$ 越接近 $A$，预处理效果越好，但应用 $M^{-1}$ 的成本通常也越高。最完美的[预处理器](@entry_id:753679)是 $M=A$，此时 $M^{-1}A=I$，条件数为1，任何合适的[迭代法](@entry_id:194857)都能一步收敛。但这显然是无用的，因为应用 $M^{-1}$ 等价于求解原问题。因此，预处理器的设计总是在“近似质量”和“应用成本”之间寻求平衡。

通过引入[预处理器](@entry_id:753679) $M$，我们可以构造一个代数上等价的系统。以**[左预处理](@entry_id:165660)（left preconditioning）**为例，我们将原方程两边同时左乘 $M^{-1}$：
$$
M^{-1} A x = M^{-1} b
$$
这个新系统的解与原系统完全相同，但其[系数矩阵](@entry_id:151473)变成了 $M^{-1}A$。[预处理](@entry_id:141204)的**形式化目标**是使这个**[预处理](@entry_id:141204)后算子（preconditioned operator）** $M^{-1}A$ 的[谱分布](@entry_id:158779)尽可能理想。对于SPD系统，这意味着其条件数 $\kappa_2(M^{-1}A)$ 远小于 $\kappa_2(A)$。理想情况下，我们希望 $\kappa_2(M^{-1}A)$ 接近1，这意味着其[特征值](@entry_id:154894)应该紧密地**聚集（cluster）**在1附近。

对于依赖于[条件数](@entry_id:145150)的迭代方法（如共轭梯度法），[预处理](@entry_id:141204)的效果是显著的。例如，对于SPD系统，达到给定精度所需的PCG（[预处理](@entry_id:141204)[共轭梯度](@entry_id:145712)）迭代次数 $k$ 近似满足：
$$
k \propto \sqrt{\kappa(M^{-1}A)}
$$
如果一个好的预处理器能使 $\kappa(M^{-1}A)$ 保持为一个适中的常数，那么迭代次数将不再随问题规模的增长而增长。

### 预处理的形式及其对迭代过程的影响

根据预处理器 $M$ 的应用方式，主要有三种形式。理解它们的区别对于正确实施和解释迭代过程至关重要。设第 $k$ 次迭代的近似解为 $x_k$，真实残差为 $r_k = b - A x_k$。

#### [左预处理](@entry_id:165660) (Left Preconditioning)
系统形式为 $M^{-1} A x = M^{-1} b$。
Krylov[子空间方法](@entry_id:200957)（如GMRES）被应用于这个修改后的系统。因此，该方法旨在最小化**[预处理](@entry_id:141204)后残差（preconditioned residual）**的范数，即 $\|M^{-1}r_k\|_2$。在算法内部，无需额外计算即可监控的[残差范数](@entry_id:754273)正是 $\|M^{-1}r_k\|_2$。

#### [右预处理](@entry_id:173546) (Right Preconditioning)
通过变量代换 $x = M^{-1}y$ 实现，求解系统 $A M^{-1} y = b$。得到解 $y_k$ 后，通过 $x_k = M^{-1}y_k$ 恢复原问题的解。
此时，Krylov方法作用于算子 $AM^{-1}$。其残差为 $b - (AM^{-1})y_k = b - Ax_k = r_k$。这意味着[右预处理](@entry_id:173546)的Krylov方法直接最小化**真实残差（true residual）**的范数 $\|r_k\|_2$。算法内部监控的残差就是真实残差。

#### [分裂预处理](@entry_id:755247) (Split Preconditioning)
这是左[右预处理](@entry_id:173546)的结合，通常基于预处理器的因子分解 $M=M_L M_R$。系统变为 $M_L^{-1} A M_R^{-1} y = M_L^{-1} b$，其中 $x = M_R^{-1} y$。
Krylov方法作用于算子 $M_L^{-1} A M_R^{-1}$。其残差为 $M_L^{-1} b - (M_L^{-1} A M_R^{-1}) y_k = M_L^{-1}(b - Ax_k) = M_L^{-1}r_k$。因此，[分裂预处理](@entry_id:755247)最小化的是一个[左预处理](@entry_id:165660)形式的[残差范数](@entry_id:754273) $\|M_L^{-1}r_k\|_2$。

这些差异在设置迭代[终止准则](@entry_id:136282)时具有重大的实际意义。通常，我们希望当真实残差的范数 $\|r_k\|_2$ 小于某个容差 $\varepsilon$ 时停止迭代。
- 对于**[右预处理](@entry_id:173546)**，这很简单，因为算法自然地计算和最小化 $\|r_k\|_2$。
- 对于**[左预处理](@entry_id:165660)**，情况则比较复杂。算法监控的是 $\|M^{-1}r_k\|_2$。真实[残差范数](@entry_id:754273)和预处理后[残差范数](@entry_id:754273)之间存在如下关系：
  $$
  \|r_k\|_2 = \|M(M^{-1}r_k)\|_2 \le \|M\|_2 \|M^{-1}r_k\|_2
  $$
  以及
  $$
  \|M^{-1}r_k\|_2 \le \|M^{-1}\|_2 \|r_k\|_2
  $$
  这意味着，即使我们确保了 $\|M^{-1}r_k\|_2 \le \tau$，真实[残差范数](@entry_id:754273)也可能高达 $\|M\|_2 \tau$。如果[预处理器](@entry_id:753679)本身是病态的（即 $\|M\|_2$ 和 $\|M^{-1}\|_2$ 很大，导致 $\kappa_2(M)$ 很大），那么一个很小的[预处理](@entry_id:141204)后[残差范数](@entry_id:754273)并不能保证一个很小的真实[残差范数](@entry_id:754273)。因此，在使用[左预处理](@entry_id:165660)时，如果需要严格控制真实残差，可能需要额外计算 $r_k = M(M^{-1}r_k)$ 并检查其范数，这会增加每次迭代的成本。

### 预处理对称与非对称系统

Krylov[子空间方法](@entry_id:200957)对系数矩阵的代数性质非常敏感。特别是，处理对称和非对称系统的方法有本质区别。

#### [对称正定系统](@entry_id:172662)与[共轭梯度法](@entry_id:143436) (PCG)

标准的**[共轭梯度法](@entry_id:143436)（Conjugate Gradient, CG）**是求解SPD系统 $Ax=b$ 的首选迭代方法。其高效性（特别是短递归关系）从根本上依赖于算子 $A$ 的对称性和[正定性](@entry_id:149643)。这可以从变分角度理解：CG可以被看作是在Krylov[子空间](@entry_id:150286)上逐步最小化二次能量泛函 $J(x) = \frac{1}{2}x^\top A x - b^\top x$ 的过程。要使这个泛函有唯一的最小值，其Hessian矩阵（即 $A$）必须是SPD的。

当我们引入一个SPD[预处理器](@entry_id:753679) $M$ 时，必须确保[预处理](@entry_id:141204)后的系统算子仍然是SPD的（至少在某个适当的[内积](@entry_id:158127)下）。
- 直接使用[左预处理](@entry_id:165660)会遇到问题：算子 $M^{-1}A$ 通常是**非对称的**，因为矩阵 $M$ 和 $A$ 一般不可交换（即 $AM \neq MA$）。因此，标准CG不能直接应用于系统 $M^{-1}Ax = M^{-1}b$。

为解决此问题，有两种标准方法：

1.  **[分裂预处理](@entry_id:755247)**：这是理论上最清晰的方法。由于 $M$ 是SPD，它可以进行[Cholesky分解](@entry_id:147066)或类似的分解 $M = CC^\top$（其中 $C$ 可逆）。通过[分裂预处理](@entry_id:755247)，我们得到系统 $\tilde{A} y = \tilde{b}$，其中 $\tilde{A} = C^{-1}AC^{-\top}$，$\tilde{b} = C^{-1}b$，且 $x = C^{-\top}y$。容易验证，由于 $A$ 是对称的，新的算子 $\tilde{A}$ 也是对称的。更进一步，由于 $A$ 是正定的，$\tilde{A}$ 也是正定的。因此，我们可以放心地对这个变换后的系统应用标准CG方法。

2.  **$M$-[内积](@entry_id:158127)下的解释**：这是实践中[PCG算法](@entry_id:753273)的另一种等价观点。虽然 $M^{-1}A$ 在标准欧几里得[内积](@entry_id:158127)下非对称，但它在由预处理器定义的**$M$-[内积](@entry_id:158127)** $\langle u, v \rangle_M = u^\top M v$ 下是**自伴的（self-adjoint）**（即对称的）。可以验证 $\langle M^{-1}Au, v \rangle_M = \langle u, M^{-1}Av \rangle_M$。同时，它在该[内积](@entry_id:158127)下也是正定的。因此，[PCG算法](@entry_id:753273)可以被严谨地解释为在[赋范向量空间](@entry_id:274725) $( \mathbb{R}^n, \langle \cdot, \cdot \rangle_M )$ 中应用广义CG方法。这为我们提供了无需显式构造分裂形式即可实现PCG的理论基础。

#### 非对称系统与广义极小残差法 (GMRES)

当[有限元离散化](@entry_id:193156)（例如，包含[对流](@entry_id:141806)项或使用特定稳定化方法）产生[非对称矩阵](@entry_id:153254) $A$ 时，CG不再适用，我们必须转向如**广义极小残差法（Generalized Minimal Residual, GMRES）**等方法。

对于非对称系统，仅靠[特征值分布](@entry_id:194746)不足以预测GMRES的收敛行为。一个关键的新概念是**[非正规性](@entry_id:752585)（nonnormality）**。一个矩阵 $B$ 被称为**正规的（normal）**，如果它与其共轭转置可交换（$B^*B = BB^*$）。[对称矩阵](@entry_id:143130)和酉矩阵都是[正规矩阵](@entry_id:185943)。对于[正规矩阵](@entry_id:185943)，其多项式函数 $p(B)$ 的范数由其在谱上的最大值决定：$\|p(B)\|_2 = \max_{\lambda \in \Lambda(B)} |p(\lambda)|$。此时，如果[预处理器](@entry_id:753679)能使 $M^{-1}A$ 的[特征值](@entry_id:154894)紧密聚集在1附近且远离0，GMRES就会快速收敛。

然而，许多非[对称算子](@entry_id:272489)是**非正规的**。对于[非正规矩阵](@entry_id:752668)，$p(B)$ 的范数可能远大于其在谱上的最大值。这意味着，即使所有[特征值](@entry_id:154894)都良好地聚集，GMRES也可能收敛得很慢，甚至在初期出现停滞。这种现象的极端例子是具有非平凡若尔当块（[Jordan block](@entry_id:148136)）的矩阵。例如，一个矩阵的谱仅为 $\{1\}$，但如果它具有一个尺寸大于1的[若尔当块](@entry_id:155003)，它就是非正规（且亏损的）。应用于此类矩阵的GMRES收敛曲线通常会先经历一个平台期，然后才开始收敛。

因此，对于非对称[预处理](@entry_id:141204)，我们需要比[特征值](@entry_id:154894)更强大的分析工具：
- **值域（Field of Values）**：$\mathcal{F}(B) = \{x^*Bx : \|x\|_2=1\}$。这是一个包含所有[特征值](@entry_id:154894)的复平面上的[凸集](@entry_id:155617)。如果 $\mathcal{F}(M^{-1}A)$ 远离原点，那么可以保证GMRES[线性收敛](@entry_id:163614)，其[收敛速度](@entry_id:636873)与[非正规性](@entry_id:752585)程度无关。
- **[伪谱](@entry_id:138878)（Pseudospectrum）**：$\Lambda_\varepsilon(B)$ 是复平面上的一个区域，其中算子 $zI-B$ 的逆的范数很大。[非正规矩阵](@entry_id:752668)的[伪谱](@entry_id:138878)即使在 $\varepsilon$ 很小时也可能远远超出其谱的范围。GMRES的收敛行为更像是被伪谱而非谱本身所控制。

总之，一个好的非对称预处理器不仅要使[特征值](@entry_id:154894)聚集，还应尽量降低[预处理](@entry_id:141204)后算子的[非正规性](@entry_id:752585)。

### 预处理器质量的衡量标准：最优性与鲁棒性

我们如何量化一个预处理器是“好”的？在[求解偏微分方程](@entry_id:138485)的背景下，有两个关键的衡量标准：最优性和鲁棒性。

#### 最优性 (Optimality)

考虑一个由 $h$ [参数化](@entry_id:272587)的有限元离散问题族。一个[预处理器](@entry_id:753679)序列 $M_h$ 被认为是**（算法）最优的（optimal）**，如果存在一个与网格尺寸 $h$ 无关的常数 $C$，使得对所有足够小的 $h$，预处理后系统的条件数都有界：
$$
\kappa(M_h^{-1} A_h) \le C
$$
这个性质之所以被称为“最优”，是因为它直接关系到求解的总计算复杂度。由于PCG的迭代次数正比于 $\sqrt{\kappa}$，一个有界的条件数意味着求解到给定精度所需的**迭代次数与[网格细化](@entry_id:168565)程度无关**。假设每次迭代的成本（主要由[稀疏矩阵](@entry_id:138197)-向量乘积和[预处理器](@entry_id:753679)求解构成）与未知数数量 $N_h$ 成正比（这在FEM中很典型），那么总计算功就与 $N_h$ 呈线性关系，即 $\mathcal{O}(N_h)$。对于一个具有 $N_h$ 个未知数的系统，这是可以期待的最佳求解复杂度，因此被称为**[线性复杂度](@entry_id:144405)**或**最优复杂度**。像[多重网格法](@entry_id:146386)（multigrid）这类先进的[预处理器](@entry_id:753679)正是以实现这种最优性为目标的。

#### 鲁棒性 (Robustness)

在许多物理问题中，系数矩阵不仅依赖于网格尺寸 $h$，还依赖于问题的物理参数。例如，在[扩散](@entry_id:141445)问题 $-\nabla \cdot (\alpha(x) \nabla u) = f$ 中，[扩散](@entry_id:141445)系数 $\alpha(x)$ 可能在区域内剧烈变化。我们定义**系数对比度（coefficient contrast）**为 $\beta = \alpha_{\max} / \alpha_{\min}$。标准预处理器（如不完全分解）的性能通常会随着 $\beta$ 的增大而严重退化。

一个[预处理器](@entry_id:753679)被称为**鲁棒的（robust）**，如果其性能不仅对网格参数 $h$ 是最优的，而且对问题中的一个或多个物理参数（如 $\beta$）也是不敏感的。形式上，这意味着预处理后系统的[条件数](@entry_id:145150)由一个与 $h$ 和 $\beta$ 都无关的常数界定：
$$
\kappa(M^{-1}A) \le C \quad (\text{其中 } C \text{ 独立于 } h \text{ 和 } \beta)
$$

在代数层面，最优性和鲁棒性通常通过**谱等价性（spectral equivalence）**来表述。如果存在与相关参数（如 $h, \beta$）无关的正常数 $c_1, c_2$，使得对于所有非[零向量](@entry_id:156189) $v$ 都成立：
$$
c_1 v^\top M v \le v^\top A v \le c_2 v^\top M v
$$
那么我们称矩阵 $A$ 和 $M$ 是谱等价的。这个条件直接等价于 $\kappa(M^{-1}A) \le c_2/c_1$，即[条件数](@entry_id:145150)有界。因此，设计一个最优且鲁棒的预处理器，本质上是寻找一个计算上廉价且与原[刚度矩阵](@entry_id:178659)谱等价的算子 $M$。

### 高级主题：[高性能计算](@entry_id:169980)中的可扩展性

在现代科学计算中，求解大型系统通常依赖于[大规模并行计算](@entry_id:268183)机。在这种背景下，预处理器的性能不仅取决于其代数性质（如条件数），还取决于其在并行环境中的**可扩展性（scalability）**。

我们区分两种可扩展性：
- **[算法可扩展性](@entry_id:141500)（Algorithmic Scalability）**：这与我们之前定义的最优性相同，即求解所需的迭代次数不随问题规模 $N$ 增长。
- **[并行可扩展性](@entry_id:753141)（Parallel Scalability）**：这描述了当处理器数量 $p$ 增加时，求解时间的表现。
    - **[强扩展性](@entry_id:172096)（Strong Scaling）**：固定总问题规模 $N$，增加处理器 $p$。理想情况下，求解时间 $T(p)$ 应与 $1/p$ 成正比。
    - **[弱扩展性](@entry_id:167061)（Weak Scaling）**：保持每个处理器上的问题规模 $N/p$ 不变，同时增加 $N$ 和 $p$。理想情况下，求解时间应保持大致恒定。

许多最强大的[预处理器](@entry_id:753679)，如多重网格法和[区域分解法](@entry_id:165176)，都具有分层结构，包含一个在“粗”尺度上进行的计算，即**粗网格求解（coarse-grid solve）**。尽管精确的粗网格求解对于保证[算法可扩展性](@entry_id:141500)至关重要（尽管适当的非精确求解也可以接受），但它在并行环境中往往成为一个严重的**瓶颈**。

考虑一个典型的基于区域分解的二级预处理器。[并行化](@entry_id:753104)通常通过将[网格划分](@entry_id:269463)为 $p$ 个子区域（每个处理器一个）来实现。粗网格问题的自由度数量 $n_0$ 通常与子区域的数量成正比，即 $n_0 = \Theta(p)$。在每次迭代中，都需要求解一个 $n_0 \times n_0$ 的粗系统。
- 在**[强扩展性](@entry_id:172096)**测试中，随着 $p$ 的增加，细网格上的并行工作量减少了，但粗网格问题变得越来越大。求解这个日益增大的粗问题所需的时间 $T_0(p)$ 不仅不会减少，反而会增加（例如，使用并行[直接求解器](@entry_id:152789)时可能为 $\mathcal{O}(p^2)$）。当 $p$ 足够大时，$T_0(p)$ 将主导总迭[代时](@entry_id:173412)间，从而限制了加速比的上限。
- 在**[弱扩展性](@entry_id:167061)**测试中，虽然每个处理器上的细网格工作量保持不变，但粗问题的大小仍然随 $p$ 增长。求解时间中 $T_0(p)$ 这一项的增长（同样可能为 $\mathcal{O}(p^2)$）破坏了总迭[代时](@entry_id:173412)间保持恒定的目标。

这个“粗网格瓶颈”是现代预[处理器设计](@entry_id:753772)和实现中的一个核心挑战。在追求代数最优性的同时，必须仔细考虑算法的各个组件如何映射到并行硬件上，以实现真正的端到端性能。