{"hands_on_practices": [{"introduction": "内聚力模型的预测能力在很大程度上取决于其材料参数的准确性。本练习将指导您完成一个标准流程，即如何从双悬臂梁（DCB）试验的载荷-位移数据中提取I型断裂的关键参数，如临界能量释放率 $G_{Ic}$ 和峰值牵引力 $\\sigma_{c}$ [@problem_id:2544709]。这个过程连接了理论模型与实验断裂力学，是实际应用内聚力模型的第一步。", "problem": "在一个沿弱界面含有预制裂纹的对称层合板上进行双悬臂梁（DCB）试验，以表征分层的 I 型内聚区法则。其目标是为内聚区模型（CZM）确定法向张开下的三角形牵引-分离法则的参数：临界能量释放率 $G_{I c}$、峰值法向牵引力 $\\sigma_{c}$、最终分离位移 $\\delta_{f}$ 以及初始罚刚度 $K$（法向模式）。假设为线性弹性、小应变，且剪切变形和根部转动可忽略。使用 Euler–Bernoulli 梁理论和 Irwin–Kies 能量释放率关系式。两个厚度为 $h$、宽度为 $b$ 的相同悬臂由杨氏模量为 $E$ 的各向同性线性弹性固体材料制成。施加载荷 $P$ 是作用于每个悬臂的力，测得的张开位移 $\\delta$ 是两个加载点之间的相对张开位移。\n\n已知数据：\n- 几何与材料：$E = 70 \\times 10^{9}$，$b = 0.020$，$h = 0.003$。\n- 裂纹开始扩展时的裂纹长度：$a = 0.050$。\n- 裂纹开始扩展时测得的载荷和张开位移：$P_{\\text{on}} = 60$，$\\delta_{\\text{on}} = 0.0018$。\n- 相同裂纹长度下测得的初始（损伤前）线性响应：$P_{\\ell} = 30$，$\\delta_{\\ell} = 0.00090$。\n- 通过数字图像相关法测得的完全脱粘时的最终分离位移：$\\delta_{f} = 20 \\times 10^{-6}$。\n- 为了通过匹配初始斜率来确定罚刚度 $K$，将界面贡献近似为一个长度为 $L_{\\text{eff}} = 0.010$ 的等效线性弹簧，该弹簧与未开裂悬臂的弯曲柔度串联。\n\n任务：\n1) 使用 I 型的 Irwin–Kies 关系式 $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$，并结合两个相同悬臂的 Euler–Bernoulli 梁理论，推导出用 $P$、$\\delta$、$b$ 和 $a$ 表示的 $G_{I}$ 的闭式表达式，并计算起始条件下的 $G_{I c}$。\n2) 对于 I 型的三角形牵引-分离法则，使用面积条件 $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$ 来计算 $\\sigma_{c}$。\n3) 通过匹配初始斜率来确定罚刚度 $K$：将完整结构建模为裂纹长度为 $a$ 的 DCB 悬臂的弯曲柔度与一个刚度为 $k_{c} = b K L_{\\text{eff}}$ 的等效内聚弹簧的串联组合。使用测得的初始柔度 $C_{\\exp} = \\delta_{\\ell}/P_{\\ell}$ 来求解 $K$。\n\n报告有序三元组 $\\left(G_{I c},\\,\\sigma_{c},\\,K\\right)$，结果四舍五入到三位有效数字，$G_{I c}$ 的单位为 $\\text{J}\\,\\text{m}^{-2}$，$\\sigma_{c}$ 的单位为 $\\text{MPa}$，$K$ 的单位为 $\\text{N}\\,\\text{mm}^{-3}$。最终方框内的答案中不要包含单位；条目的顺序必须遵循此处指定的顺序。", "solution": "首先对问题陈述进行严格验证。\n\n步骤 1：提取已知条件。\n- 材料属性：杨氏模量 $E = 70 \\times 10^{9}$。\n- 几何属性：梁宽 $b = 0.020$，梁厚（单臂）$h = 0.003$。\n- 裂纹扩展开始时的裂纹长度：$a = 0.050$。\n- 裂纹扩展开始时测得的数据：载荷 $P_{\\text{on}} = 60$，张开位移 $\\delta_{\\text{on}} = 0.0018$。\n- 相同裂纹长度下在线性弹性区域测得的数据：载荷 $P_{\\ell} = 30$，张开位移 $\\delta_{\\ell} = 0.00090$。\n- 完全破坏时的最终分离位移：$\\delta_{f} = 20 \\times 10^{-6}$。\n- 用于计算罚刚度的等效长度：$L_{\\text{eff}} = 0.010$。\n- 控制关系式：Irwin–Kies 关系式 $G = \\dfrac{P^{2}}{2 b}\\dfrac{dC}{da}$，Euler–Bernoulli 梁理论，三角形内聚法则面积 $G_{I c} = \\dfrac{1}{2}\\sigma_{c}\\,\\delta_{f}$，以及用于初始刚度的串联柔度模型 $C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$，其中 $k_{c} = \\frac{1}{C_{\\text{coh}}} = b K L_{\\text{eff}}$。\n- 假设：线性弹性、小应变、剪切变形可忽略、根部转动可忽略。除非另有说明，所有数值均假定使用 SI 基本单位（米、牛顿、帕斯卡）。\n\n步骤 2：验证。\n该问题具有科学依据，采用线性弹性断裂力学和梁理论的标准原理来分析双悬臂梁（DCB）试验，这是一种常见的实验方法。所提供的数据是自洽的；例如，根据线性响应点计算的柔度 $C_{\\ell} = \\delta_{\\ell} / P_{\\ell} = 0.00090 / 30 = 3 \\times 10^{-5}$，与起始点处的柔度 $C_{\\text{on}} = \\delta_{\\text{on}} / P_{\\text{on}} = 0.0018 / 60 = 3 \\times 10^{-5}$ 相同，这在物理上是正确的，因为裂纹开始扩展标志着线性区域的结束。该问题是适定的、客观的，并包含足够的信息以获得唯一解。它没有违反任何指定的无效标准。\n\n步骤 3：结论。\n该问题是有效的。将提供解答。\n\n解答过程按顺序处理三个指定的任务。\n\n任务 1：$G_{I}$ 的推导和 $G_{I c}$ 的计算。\n根据 Euler-Bernoulli 梁理论，长度为 $a$ 的单个悬臂梁在载荷 $P$ 作用下，其末端的挠度 $w$ 由下式给出：\n$$w = \\frac{Pa^{3}}{3EI}$$\n其中 $E$ 是杨氏模量，$I$ 是梁横截面的面积二次矩。对于宽度为 $b$、厚度为 $h$ 的矩形横截面，$I = \\frac{bh^{3}}{12}$。DCB 试样由两个这样的梁组成，因此加载点处的总张开位移 $\\delta$ 是单个悬臂挠度的两倍：\n$$\\delta = 2w = \\frac{2Pa^{3}}{3EI} = \\frac{2Pa^{3}}{3E \\left( \\frac{bh^{3}}{12} \\right)} = \\frac{8Pa^{3}}{Ebh^{3}}$$\n试样的柔度 $C$ 定义为张开位移与载荷之比，$C = \\delta/P$。\n$$C(a) = \\frac{8a^{3}}{Ebh^{3}}$$\n问题指定使用 Irwin–Kies 关系式计算 I 型能量释放率 $G_{I}$：\n$$G_{I} = \\frac{P^{2}}{2b} \\frac{dC}{da}$$\n我们计算柔度对裂纹长度 $a$ 的导数：\n$$\\frac{dC}{da} = \\frac{d}{da} \\left( \\frac{8a^{3}}{Ebh^{3}} \\right) = \\frac{24a^{2}}{Ebh^{3}}$$\n将此导数代入 Irwin–Kies 关系式，得到 $G_{I}$ 的表达式：\n$$G_{I} = \\frac{P^{2}}{2b} \\left( \\frac{24a^{2}}{Ebh^{3}} \\right) = \\frac{12P^{2}a^{2}}{b^{2}Eh^{3}}$$\n为按要求用 $P$、$\\delta$、$b$ 和 $a$ 表示 $G_{I}$，我们使用柔度关系式 $C = \\delta/P$ 并注意到 $\\frac{dC}{da} = 3 \\frac{C}{a}$。因此：\n$$G_{I} = \\frac{P^{2}}{2b} \\left( 3 \\frac{C}{a} \\right) = \\frac{3P^{2}}{2ab} \\left( \\frac{\\delta}{P} \\right) = \\frac{3P\\delta}{2ab}$$\n这就是所要求的闭式表达式。临界能量释放率 $G_{I c}$ 是在裂纹扩展开始时使用所提供的数据计算的：$P_{\\text{on}} = 60\\,\\text{N}$，$\\delta_{\\text{on}} = 0.0018\\,\\text{m}$，$a = 0.050\\,\\text{m}$，$b = 0.020\\,\\text{m}$。\n$$G_{I c} = \\frac{3 P_{\\text{on}} \\delta_{\\text{on}}}{2ab} = \\frac{3 \\times 60 \\times 0.0018}{2 \\times 0.050 \\times 0.020} = \\frac{0.324}{0.002} = 162\\,\\text{J}\\,\\text{m}^{-2}$$\n\n任务 2：峰值法向牵引力 $\\sigma_{c}$ 的计算。\n对于三角形牵引-分离法则，断裂能 $G_{I c}$ 是由峰值牵引力 $\\sigma_{c}$ 和最终分离位移 $\\delta_{f}$ 定义的三角形面积：\n$$G_{I c} = \\frac{1}{2} \\sigma_{c} \\delta_{f}$$\n求解 $\\sigma_{c}$：\n$$\\sigma_{c} = \\frac{2G_{I c}}{\\delta_{f}}$$\n使用计算值 $G_{I c} = 162\\,\\text{J}\\,\\text{m}^{-2}$ 和给定的最终分离位移 $\\delta_{f} = 20 \\times 10^{-6}\\,\\text{m}$：\n$$\\sigma_{c} = \\frac{2 \\times 162}{20 \\times 10^{-6}} = \\frac{324}{20 \\times 10^{-6}} = 16.2 \\times 10^{6}\\,\\text{Pa}$$\n由于 $1\\,\\text{MPa} = 10^{6}\\,\\text{Pa}$，峰值牵引力为 $\\sigma_{c} = 16.2\\,\\text{MPa}$。\n\n任务 3：罚刚度 $K$ 的确定。\n试样的初始响应被建模为梁弯曲柔度 $C_{\\text{beam}}$ 和等效内聚柔度 $C_{\\text{coh}}$ 的串联组合。总测量柔度 $C_{\\exp}$ 是这两者之和：\n$$C_{\\exp} = C_{\\text{beam}} + C_{\\text{coh}}$$\n实验柔度由线性响应数据确定：\n$$C_{\\exp} = \\frac{\\delta_{\\ell}}{P_{\\ell}} = \\frac{0.00090}{30} = 3.0 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n梁弯曲柔度由先前推导的理论表达式给出：\n$$C_{\\text{beam}} = \\frac{8a^{3}}{Ebh^{3}} = \\frac{8 \\times (0.050)^{3}}{(70 \\times 10^{9}) \\times 0.020 \\times (0.003)^{3}} = \\frac{1 \\times 10^{-3}}{37.8} \\approx 2.6455 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n内聚柔度通过相减得到：\n$$C_{\\text{coh}} = C_{\\exp} - C_{\\text{beam}} = (3.0 \\times 10^{-5}) - (2.6455 \\times 10^{-5}) = 0.3545 \\times 10^{-5}\\,\\text{m}\\,\\text{N}^{-1}$$\n内聚柔度通过等效弹簧刚度 $k_c = 1/C_{\\text{coh}}$ 与罚刚度 $K$ 相关。该弹簧代表了罚刚度在等效面积 $A_{\\text{eff}} = b L_{\\text{eff}}$ 上的积分效应。内聚区的刚度给出为 $k_{c} = b K L_{\\text{eff}}$。因此：\n$$C_{\\text{coh}} = \\frac{1}{b K L_{\\text{eff}}}$$\n求解 $K$：\n$$K = \\frac{1}{b L_{\\text{eff}} C_{\\text{coh}}} = \\frac{1}{0.020 \\times 0.010 \\times (0.3545 \\times 10^{-5})} = \\frac{1}{7.09 \\times 10^{-10}} \\approx 1.4104 \\times 10^{9}\\,\\text{N}\\,\\text{m}^{-3}$$\n结果必须转换为 $\\text{N}\\,\\text{mm}^{-3}$。转换因子为 $1\\,\\text{N}\\,\\text{m}^{-3} = 1\\,\\text{N}\\,(1000\\,\\text{mm})^{-3} = 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3}$。\n$$K = (1.4104 \\times 10^{9}) \\times 10^{-9}\\,\\text{N}\\,\\text{mm}^{-3} \\approx 1.4104\\,\\text{N}\\,\\text{mm}^{-3}$$\n四舍五入到三位有效数字，$K = 1.41\\,\\text{N}\\,\\text{mm}^{-3}$。\n\n最终的有序三元组 $(G_{I c}, \\sigma_{c}, K)$，其值四舍五入到三位有效数字，为 $(162\\,\\text{J}\\,\\text{m}^{-2}, 16.2\\,\\text{MPa}, 1.41\\,\\text{N}\\,\\text{mm}^{-3})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 162 & 16.2 & 1.41 \\end{pmatrix}\n}\n$$", "id": "2544709"}, {"introduction": "一个完整的内聚力模型不仅要描述分离过程，还必须能够处理受压状态以防止材料的相互侵入。本练习将探讨罚函数法，这是一种实现接触约束的常用数值技术 [@problem_id:2544699]。您将通过编程实践，分析罚刚度 $k_p$ 的选择对计算结果（如侵入深度和系统矩阵条件数）的影响，从而理解在确保计算精度的同时维持数值稳定性的重要权衡。", "problem": "考虑一个一维小应变线性弹性杆，它被切割成两个子域，并通过一个单边法向-粘性界面耦合。该界面仅通过罚函数牵引力惩罚压缩。目标是实现压缩罚函数牵引力，并研究罚刚度对互穿以及由有限元法（FEM; Finite Element Method）组装的线性化系统矩阵条件数的影响。\n\n从以下基本基础出发：\n- 准静态下的线性动量守恒简化为总势能的驻定性，对于线性杆，这简化为平衡的弱形式：内虚功等于外虚功。\n- 对于杨氏模量为 $E$、横截面积为 $A$ 的一维线性弹性杆，其轴向位移场为 $u(x)$，内虚功表示为 $\\int_0^L E A \\, \\varepsilon \\, \\delta \\varepsilon \\, dx$，其中 $\\varepsilon = du/dx$。\n- 使用线性单元通过有限元法进行离散化，得到标准单元刚度矩阵，即 $k_e = E A / \\ell_e$ 乘以规范的 $2 \\times 2$ 矩阵 $\\begin{bmatrix} 1 & -1 \\\\ -1 & 1 \\end{bmatrix}$，其中 $\\ell_e$ 是单元长度。\n- 一个法向间隙为 $\\delta_n$ 的粘性界面，通过牵引力 $t_n = k_p \\, \\delta_n^-$（其中 $\\delta_n^- = \\max(0,-\\delta_n)$ 且罚刚度 $k_p \\ge 0$）来惩罚压缩。如果 $\\delta_n  0$（压缩），法向切向刚度等于 $k_p$；如果 $\\delta_n \\ge 0$（张开），则为 $0$。在拉伸（张开）状态下，取 $t_n = 0$。\n\n建立以下边值问题：\n- 几何：总长度为 $L$ 的杆被分成相等的两半，每半长度为 $L/2$。左半部分占据 $x \\in [0,L/2]$，右半部分占据 $x \\in [L/2,L]$。\n- 材料：两半部分具有相同的杨氏模量 $E$ 和横截面积 $A$。\n- 离散化：每半部分由 $N_e$ 个长度为 $\\ell_e = (L/2)/N_e$ 的均匀线性单元离散化。将两半部分视为具有独立的节点集；它们之间的界面由一对重合节点表示，一个来自左半部分，一个来自右半部分，仅通过法向的粘性罚函数法则耦合。\n- 运动学：设 $u_L$ 为左半部分界面节点的位移，$u_R$ 为右半部分界面节点的位移。定义标量法向间隙为 $\\delta_n = u_R - u_L$。\n- 边界条件：在左端施加 $u(0) = 0$，在右端施加 $u(L) = -u_0$，其中规定 $u_0 > 0$，从而使界面受压。\n- 压缩状态下的粘性界面法则：$t_n = k_p \\, \\delta_n^-$，其中 $\\delta_n^- = \\max(0,-\\delta_n)$。在界面自由度上，对全局刚度矩阵的一致性切向贡献为：如果 $\\delta_n  0$，则 $k_{\\text{int}} = k_p$；否则 $k_{\\text{int}}=0$。该贡献在界面节点对上组装为 $2\\times 2$ 的块矩阵 $k_{\\text{int}} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。\n\n任务：\n1. 从总势能和上述离散化出发，推导给定激活集（压缩是否激活）的线性系统，并解释如何通过叠加单元贡献和由 $\\delta_n$ 符号确定的界面切向贡献来组装全局刚度矩阵。\n2. 由于接触法则是单边的，设计一个简单的不动点激活集迭代法：假设一个初始界面状态（压缩激活），组装并求解；然后通过检查 $\\delta_n$ 的符号来更新激活集；如果激活集发生变化，则重新组装并求解。迭代直至激活集一致。方程组的右手边仅包含由狄利克雷边界条件引起的贡献，没有外力。\n3. 对每个测试案例，计算：\n   - 穿透深度 $P = \\delta_n^- = \\max(0,-\\delta_n)$，以米为单位表示，并四舍五入到六位有效数字。\n   - 约简切向刚度矩阵（施加狄利克雷边界条件后）的条件数 $\\kappa$，在谱2-范数下测量，并四舍五入到三位有效数字。\n\n使用以下测试套件参数（物理单位已明确指出，必须一致使用）：\n- 材料与几何：$E = 70 \\times 10^9$ Pa, $A = 10^{-4}$ m$^2$, $L = 1$ m, $N_e = 10$, $u_0 = 10^{-4}$ m。\n- 用于不同运行的罚刚度值：\n  - 案例 $1$（无罚函数）：$k_p = 0$ N/m。\n  - 案例 $2$（弱罚函数）：$k_p = 10^6$ N/m。\n  - 案例 $3$（中等罚函数）：$k_p = 10^8$ N/m。\n  - 案例 $4$（强罚函数）：$k_p = 10^{10}$ N/m。\n\n要求输出：\n- 对每个案例，返回一个包含两个浮点数的列表 $[P,\\kappa]$，$P$ 的单位为米，$\\kappa$ 无单位，按规定进行四舍五入。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[[P1,kappa1],[P2,kappa2],...]”）。\n\n陈述中的所有数值常数均应在国际单位制下解释，如果出现任何角度，都将以弧度为单位。不得使用百分比；如果相关，请用小数表示分数量。", "solution": "此问题需经过验证。\n\n### 步骤1：提取给定信息\n- **模型**：一维、小应变、准静态下的线性弹性杆。\n- **控制方程**：总势能的驻定性，等价于平衡的弱形式（内虚功 = 外虚功）。\n- **内虚功（弹性）**：$\\int_0^L E A \\, \\varepsilon \\, \\delta \\varepsilon \\, dx$，其中 $\\varepsilon = du/dx$。\n- **有限元离散化**：线性单元。单元刚度矩阵为 $k_e = E A / \\ell_e$ 乘以 $\\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。\n- **几何**：长度为 $L$ 的杆，在 $x=L/2$ 处分裂成两个长度为 $L/2$ 的子域。\n- **材料**：杨氏模量 $E$ 和横截面积 $A$ 均匀。\n- **离散化细节**：每半部分用 $N_e$ 个均匀线性单元进行网格划分。$\\ell_e = (L/2)/N_e$。在 $x=L/2$ 处的界面由一对重合节点表示，一个用于左子域（$u_L$），一个用于右子域（$u_R$）。\n- **界面运动学**：法向间隙 $\\delta_n = u_R - u_L$。\n- **界面本构法则**：压缩罚函数牵引力（力）$t_n = k_p \\, \\delta_n^-$，其中 $\\delta_n^- = \\max(0,-\\delta_n)$ 且 $k_p \\ge 0$。在拉伸状态下（$t_n=0$）。\n- **界面切向刚度**：对全局刚度矩阵的贡献是一个 $2 \\times 2$ 的块矩阵 $k_{\\text{int}} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$，耦合界面自由度，其中如果 $\\delta_n  0$，则 $k_{\\text{int}} = k_p$，否则 $k_{\\text{int}}=0$。\n- **边界条件**：$u(0) = 0$ 和 $u(L) = -u_0$，其中 $u_0 > 0$。\n- **任务**：\n    1. 推导线性系统并解释全局刚度矩阵的组装。\n    2. 设计一个不动点激活集迭代法来处理单边接触。\n    3. 计算穿透深度 $P = \\max(0,-\\delta_n)$ 和约简切向刚度矩阵的条件数 $\\kappa$。\n- **测试参数**：\n    - 材料/几何：$E = 70 \\times 10^9$ Pa, $A = 10^{-4}$ m$^2$, $L = 1$ m, $N_e = 10$, $u_0 = 10^{-4}$ m。\n    - 罚刚度 $k_p$：案例1：$0$ N/m；案例2：$10^6$ N/m；案例3：$10^8$ N/m；案例4：$10^{10}$ N/m。\n- **要求输出**：对每个案例，$[P, \\kappa]$ 分别四舍五入到六位和三位有效数字。\n\n### 步骤2：使用提取的信息进行验证\n检查问题陈述的有效性。\n- **科学基础**：该问题在连续介质力学、有限元法和接触罚函数的既定框架内进行表述。所有原理都是计算固体力学中的标准原理。它在科学上是合理的。\n- **适定性**：该问题是一个定义明确的边值问题。对于任何 $k_p \\ge 0$，控制方程与边界条件相结合会得到一个可解的系统。$k_p=0$ 的情况代表一个退化但物理上有意义的极限，即两个子域在力学上是断开的。所提出的激活集算法是解决此类非线性问题的标准程序。预计位移有唯一解。\n- **客观性**：问题使用精确的数学和物理术语陈述，没有歧义或主观内容。\n- **缺陷清单**：\n    1.  **科学/事实不健全**：无。\n    2.  **非形式化/不相关**：该问题是指定领域内一个标准、可形式化的问题。\n    3.  **不完整/矛盾的设置**：所有必要参数均已提供。没有矛盾之处。\n    4.  **不现实/不可行**：物理参数对于像铝这样的常见工程材料是现实的。该设置是一个标准的学术基准问题。\n    5.  **不适定/结构不良**：问题结构良好。对于 $k_p > 0$，约束系统的刚度矩阵是正定的，保证了唯一解。对于 $k_p=0$，施加边界条件后系统矩阵非奇异，同样产生唯一解。\n    6.  **伪深刻/琐碎**：该问题需要正确的有限元实现和对数值分析概念（条件数）的理解，因此并非琐碎。\n    7.  **超出科学可验证性**：结果可通过计算进行验证。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n---\n\n该问题要求对带单边粘性界面的一维杆进行有限元实现和分析。解决方案按照指定的任务进行。\n\n### 任务1：线性系统的推导与组装\n\n控制原理是总势能 $\\Pi$ 的驻定性。对于离散化系统，这等价于节点内力向量与节点外力向量平衡。总势能是弹性应变能 $U_{\\text{elastic}}$ 和储存在粘性界面中的能量 $\\Phi_{\\text{int}}$ 的和。\n\n$\\Pi(\\mathbf{d}) = U_{\\text{elastic}}(\\mathbf{d}) + \\Phi_{\\text{int}}(\\mathbf{d})$\n\n整个杆的弹性应变能是所有单元能量的总和：\n$U_{\\text{elastic}}(\\mathbf{d}) = \\frac{1}{2} \\mathbf{d}^T \\mathbf{K}_{\\text{elastic}} \\mathbf{d}$，其中 $\\mathbf{d}$ 是全局节点位移向量，$\\mathbf{K}_{\\text{elastic}}$ 是由单元贡献组装而成的全局弹性刚度矩阵。对于长度为 $\\ell_e$ 的线性杆单元，单元刚度矩阵为 $\\mathbf{k}_e = \\frac{EA}{\\ell_e} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。\n\n压缩罚函数界面的势能由下式给出：\n$\\Phi_{\\text{int}}(\\delta_n) = \\frac{1}{2} k_p (\\delta_n^-)^2 = \\frac{1}{2} k_p (\\max(0, -\\delta_n))^2$。\n定义间隙为 $\\delta_n = u_R - u_L$，并考虑压缩情况，其中 $\\delta_n  0$（即 $u_L > u_R$），我们有 $\\delta_n^- = -\\delta_n = u_L - u_R$。势能变为：\n$\\Phi_{\\text{int}}(u_L, u_R) = \\frac{1}{2} k_p (u_L - u_R)^2$。\n\n驻定性条件 $\\nabla_{\\mathbf{d}} \\Pi(\\mathbf{d}) = \\mathbf{0}$ 产生非线性方程组 $\\mathbf{R}(\\mathbf{d}) = \\mathbf{F}_{\\text{int}}(\\mathbf{d}) - \\mathbf{F}_{\\text{ext}} = \\mathbf{0}$，其中内力向量 $\\mathbf{F}_{\\text{int}}$ 是势能的梯度。在我们的问题中，有指定位移而无外力，因此 $\\mathbf{F}_{\\text{ext}} = \\mathbf{0}$，系统求解的是未知位移。\n\n内力向量 $\\mathbf{F}_{\\text{int}}(\\mathbf{d})$ 有来自弹性杆和界面的贡献。\n$\\mathbf{F}_{\\text{int}}(\\mathbf{d}) = \\mathbf{K}_{\\text{elastic}} \\mathbf{d} + \\mathbf{f}_{\\text{int}}(\\mathbf{d})$，其中 $\\mathbf{f}_{\\text{int}}$ 是来自界面的内力向量。它计算为 $\\Phi_{\\text{int}}$ 对相关自由度 $u_L$ 和 $u_R$ 的梯度：\n$f_{\\text{int}, L} = \\frac{\\partial \\Phi_{\\text{int}}}{\\partial u_L} = k_p(u_L - u_R)$\n$f_{\\text{int}, R} = \\frac{\\partial \\Phi_{\\text{int}}}{\\partial u_R} = -k_p(u_L - u_R)$\n以矩阵形式表示，界面自由度上的力贡献为：\n$\\mathbf{f}_{\\text{int}} \\big|_{\\{u_L, u_R\\}} = \\begin{pmatrix} f_{\\text{int}, L} \\\\ f_{\\text{int}, R} \\end{pmatrix} = k_p \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix} \\begin{pmatrix} u_L \\\\ u_R \\end{pmatrix}$\n\n激活集方法是针对此类问题的牛顿-拉夫逊法的一种特殊形式，它通过迭代地线性化系统来求解：$\\mathbf{K}_T \\Delta\\mathbf{d} = -\\mathbf{R}(\\mathbf{d})$。切向刚度矩阵 $\\mathbf{K}_T$ 是残差 $\\mathbf{R}(\\mathbf{d})$ 的雅可比矩阵：\n$\\mathbf{K}_T = \\frac{\\partial \\mathbf{R}}{\\partial \\mathbf{d}} = \\frac{\\partial \\mathbf{F}_{\\text{int}}}{\\partial \\mathbf{d}} = \\mathbf{K}_{\\text{elastic}} + \\mathbf{K}_{\\text{int}}$\n界面对切向刚度的贡献 $\\mathbf{K}_{\\text{int}}$ 是 $\\mathbf{f}_{\\text{int}}$ 的雅可比矩阵：\n$\\mathbf{K}_{\\text{int}} = \\frac{\\partial \\mathbf{f}_{\\text{int}}}{\\partial \\{u_L, u_R\\}} = k_p \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ (对于 $\\delta_n  0$)\n此结果与问题陈述中给出的矩阵形式相符。如果界面未处于压缩状态（$\\delta_n \\ge 0$），则 $\\Phi_{\\text{int}} = 0$，因此 $\\mathbf{K}_{\\text{int}} = \\mathbf{0}$。\n\n全局刚度矩阵 $\\mathbf{K}$ 的组装遵循标准的有限元组装程序：\n1. 初始化一个大小为 $N_{\\text{dof}} \\times N_{\\text{dof}}$ 的全局矩阵 $\\mathbf{K}$ 为零矩阵，其中 $N_{\\text{dof}} = 2(N_e+1)$ 是总的节点自由度数。\n2. 对 $2N_e$ 个杆单元中的每一个，计算单元刚度矩阵 $\\mathbf{k}_e$，并将其条目加到 $\\mathbf{K}$ 中的相应位置。\n3. 根据当前界面状态（压缩是否激活），将界面切向矩阵 $\\mathbf{K}_{\\text{int}}$ 添加到全局矩阵 $\\mathbf{K}$ 中对应于界面自由度 $u_L$ 和 $u_R$ 的行和列。\n\n### 任务2：激活集迭代\n\n接触法则的单边性需要一种迭代求解策略。不动点激活集算法是合适的。\n1. **初始化**：假设界面的初始状态。鉴于边界条件 $u(0)=0$ 和 $u(L)=-u_0  0$，杆处于全局压缩状态。因此，假设界面处于压缩状态是合乎逻辑的。设置一个状态标志，`compression_active = True`。\n2. **迭代循环**：\n   a. **组装与求解**：根据当前的 `compression_active` 标志构建切向刚度矩阵 $\\mathbf{K}_T$。这包括组装弹性刚度，并在 `compression_active` 为真时添加界面贡献 $\\mathbf{K}_{\\text{int}} = k_p \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$。应用狄利克雷边界条件 $u_0 = 0$ 和 $u_{2N_e+1} = -u_0$ 形成一个约化系统 $\\mathbf{K}_{uu} \\mathbf{d}_u = \\mathbf{b}$，其中 $\\mathbf{d}_u$ 是未知位移，$\\mathbf{b}$ 是由规定位移产生的力向量。求解此线性系统以得到 $\\mathbf{d}_u$。\n   b. **更新状态**：重构完整的位移向量 $\\mathbf{d}$。计算界面间隙 $\\delta_n = u_R - u_L$。确定新状态：`new_compression_active = (delta_n  0)`。\n   c. **检查收敛**：将新状态与前一状态进行比较。如果 `new_compression_active == compression_active`，则假设的状态与解一致。算法已收敛。终止循环。\n   d. **更新与再迭代**：如果状态发生变化，更新 `compression_active = new_compression_active` 并从步骤2a重复。\n\n对于这个特定问题，压缩的初始假设将被第一个解所证实，算法预计在一次迭代中收敛。\n\n### 任务3：穿透深度与条件数的计算\n\n在激活集算法收敛后，最终的位移场 $\\mathbf{d}$ 就已知了。\n- **穿透深度 ($P$)**：界面处的互穿深度计算为 $P = \\delta_n^- = \\max(0, -\\delta_n) = \\max(0, -(u_R - u_L))$。该值以米为单位报告，四舍五入到六位有效数字。\n- **条件数 ($\\kappa$)**：线性系统的条件性由所求解的**约化**切向刚度矩阵 $\\mathbf{K}_{uu}$ 的谱条件数来衡量。谱（2-范数）条件数定义为 $\\kappa(\\mathbf{K}_{uu}) = ||\\mathbf{K}_{uu}||_2 ||\\mathbf{K}_{uu}^{-1}||_2$。对于对称正定矩阵，这是最大特征值与最小特征值之比，$\\kappa = \\lambda_{\\max} / \\lambda_{\\min}$。该值无单位，将使用库函数计算并四舍五入到三位有效数字。随着 $k_p$ 的增加，罚弹簧和杆单元之间的刚度差异预计会增大，导致更高的条件数和数值上更刚性的系统。\n\n现在为给定的测试案例实施该程序。", "answer": "```python\nimport numpy as np\n\ndef round_to_significant_figures(value, sf):\n    \"\"\"\n    Rounds a number to a specified number of significant figures.\n    \"\"\"\n    if value == 0:\n        return 0.0\n    # The format specifier 'g' handles scientific notation and significant figures.\n    return float(f\"{value:.{sf}g}\")\n\ndef solve():\n    \"\"\"\n    Solves the 1D bar problem with a compressive penalty interface\n    for different penalty stiffness values.\n    \"\"\"\n    # Test suite parameters\n    E = 70e9  # Pa\n    A = 1e-4  # m^2\n    L = 1.0   # m\n    Ne_half = 10  # Number of elements per half-bar\n    u0 = 1e-4 # m\n\n    test_cases_kp = [\n        0.0,      # Case 1: No penalty\n        1e6,      # Case 2: Weak penalty\n        1e8,      # Case 3: Moderate penalty\n        1e10,     # Case 4: Strong penalty\n    ]\n\n    results = []\n\n    # Derived parameters\n    le = (L / 2.0) / Ne_half\n    kel = E * A / le\n    k_elem_mat = kel * np.array([[1, -1], [-1, 1]])\n    \n    # Node and DOF details\n    # Left bar: nodes 0 to Ne_half. Right bar: nodes Ne_half+1 to 2*Ne_half+1\n    # Total nodes = 2 * (Ne_half + 1). Total DOFs are the same.\n    num_dofs = 2 * (Ne_half + 1)\n    \n    # Interface nodes are Ne_half (left) and Ne_half+1 (right)\n    interface_node_L = Ne_half\n    interface_node_R = Ne_half + 1\n    \n    # Boundary conditions\n    bc_dofs = [0, num_dofs - 1]\n    bc_values = [0, -u0]\n    unknown_dofs = [i for i in range(num_dofs) if i not in bc_dofs]\n    num_unknowns = len(unknown_dofs)\n\n    for kp in test_cases_kp:\n        compression_active = None\n        d = np.zeros(num_dofs)\n        \n        # --- Active-set iteration ---\n        # For this problem, starting with compression_active=True will converge in one step.\n        for _ in range(5): # Max 5 iterations as a safeguard\n            \n            new_compression_active_guess = True if compression_active is None else (d[interface_node_R]  d[interface_node_L])\n            \n            if new_compression_active_guess == compression_active:\n                break # Active set has converged\n            \n            compression_active = new_compression_active_guess\n\n            # --- Assembly of the global tangent stiffness matrix K ---\n            K = np.zeros((num_dofs, num_dofs))\n\n            # Assemble elastic stiffness for the left bar (elements 0 to Ne_half-1)\n            for i in range(Ne_half):\n                nodes = [i, i + 1]\n                K[np.ix_(nodes, nodes)] += k_elem_mat\n\n            # Assemble elastic stiffness for the right bar (elements Ne_half to 2*Ne_half-1)\n            # The nodes are from Ne_half+1 to 2*Ne_half+1\n            for i in range(Ne_half):\n                nodes = [interface_node_R + i, interface_node_R + i + 1]\n                K[np.ix_(nodes, nodes)] += k_elem_mat\n\n            # Assemble interface stiffness\n            if compression_active:\n                k_int_mat = kp * np.array([[1, -1], [-1, 1]])\n                interface_dofs = [interface_node_L, interface_node_R]\n                K[np.ix_(interface_dofs, interface_dofs)] += k_int_mat\n\n            # --- Partitioning and Solving ---\n            K_uu = K[np.ix_(unknown_dofs, unknown_dofs)]\n            K_uk = K[np.ix_(unknown_dofs, bc_dofs)]\n            \n            d_k = np.array(bc_values)\n            \n            # The RHS comes from the prescribed displacements\n            b = -K_uk @ d_k\n            \n            # Solve the reduced system K_uu * d_u = b\n            try:\n                d_u = np.linalg.solve(K_uu, b)\n                # Reconstruct full displacement vector\n                d[unknown_dofs] = d_u\n                d[bc_dofs] = d_k\n            except np.linalg.LinAlgError:\n                # This should not happen for this problem as K_uu is non-singular.\n                # It is a good practice to handle it for more general cases.\n                d.fill(np.nan) # Mark solution as failed\n                break\n\n        # --- Post-processing ---\n        if not np.any(np.isnan(d)):\n            # Calculate penetration P\n            delta_n = d[interface_node_R] - d[interface_node_L]\n            penetration = max(0, -delta_n)\n            \n            # Calculate condition number kappa of the reduced matrix\n            # For the kp=0 case, K_uu is non-singular after applying BCs.\n            condition_number = np.linalg.cond(K_uu, p=2)\n        else:\n            # Fallback if solver fails\n            penetration = np.nan\n            condition_number = np.nan\n\n        # Round results to specified significant figures\n        P_rounded = round_to_significant_figures(penetration, 6)\n        kappa_rounded = round_to_significant_figures(condition_number, 3)\n\n        results.append([P_rounded, kappa_rounded])\n\n    # Format the final output as a string\n    output_str = \"[\" + \",\".join([f\"[{p},{k}]\" for p, k in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2544699"}, {"introduction": "为了捕捉更复杂的材料响应，如界面的永久变形和能量耗散，我们需要引入塑性本构关系。这个高级练习将引导您推导并实现一个针对率无关塑性内聚力模型的返回映射算法（return-mapping algorithm）[@problem_id:2544669]。这是计算非弹性力学中的一个核心算法，对于精确模拟延性断裂行为至关重要，它要求您处理弹塑性状态的判断、塑性流动法则以及一致性切线刚度的推导。", "problem": "您的任务是在内聚区模型的背景下，为一个具有率无关伴随塑性的界面开发并实现一个稳健的返回映射算法。界面牵引力 $\\mathbf{t} \\in \\mathbb{R}^2$（其分量对应于法向和剪切方向）通过一个线性弹性关系与位移跳跃 $\\boldsymbol{\\delta} \\in \\mathbb{R}^2$ 和塑性位移跳跃 $\\boldsymbol{\\delta}^{\\mathrm{p}} \\in \\mathbb{R}^2$ 相关联。屈服条件和伴随流动法则作用于跳跃空间。您的程序必须为几个测试用例计算更新后的牵引力和算法一致切线。\n\n从以下率无关伴随塑性和线性弹性的基本定律和定义开始：\n- 界面的弹性本构关系为 $\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$，其中 $\\mathbf{K} \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定的界面刚度。\n- 屈服函数是凸的，并由下式给出\n$$\nf(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0,\n$$\n其中 $\\mathbf{A} \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定的，且 $t_c  0$。\n- 塑性容许性的 Kuhn–Tucker 条件是\n$$\nf(\\mathbf{t}) \\le 0,\\quad \\Delta\\gamma \\ge 0,\\quad \\Delta\\gamma\\,f(\\mathbf{t}) = 0,\n$$\n其中 $\\Delta\\gamma \\ge 0$ 是塑性乘子增量。\n- 跳跃空间中的伴随流动法则是\n$$\n\\Delta \\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma\\,\\frac{\\partial f}{\\partial \\mathbf{t}}(\\mathbf{t}).\n$$\n\n您必须推导一个返回映射算法，给定上述的弹性预测器和屈服函数，该算法计算更新后的牵引力 $\\mathbf{t}_{n+1}$ 和一致算法切线 $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$，以确保全局层面 Newton 法的二次收敛性。只能使用上述基本陈述作为起点，不要假定任何专门的简化公式。\n\n具体步骤如下：\n1. 给定 $\\boldsymbol{\\delta}_{n+1}$ 和 $\\boldsymbol{\\delta}^{\\mathrm{p}}_{n}$，构建弹性预测器（试探状态）\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big)\n$$\n并通过 $f(\\mathbf{t}^{\\mathrm{tr}})$ 测试屈服容许性。\n2. 如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$，该步是弹性的：设置 $\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}$ 和 $\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{K}$。\n3. 如果 $f(\\mathbf{t}^{\\mathrm{tr}})  0$，通过使用与约束 $f(\\mathbf{t}_{n+1}) = 0$ 和增量势的驻定性相关联的拉格朗日乘子 $\\lambda \\ge 0$ 返回到屈服面来强制执行一致性。证明驻定性条件导致非线性系统\n$$\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - \\big(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\\big) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0},\\quad f(\\mathbf{t}_{n+1}) = 0,\n$$\n您必须解此方程组以求得 $\\mathbf{t}_{n+1}$ 和 $\\lambda$。证明这可以简化为一个关于 $\\lambda$ 的一维求根问题。\n4. 通过对上述系统关于 $\\boldsymbol{\\delta}_{n+1}$ 进行线性化，推导精确的一致算法切线 $\\mathbf{C}_{\\mathrm{alg}} = \\dfrac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$，假设为理想塑性（无硬化）。您的最终表达式必须通过从线性化方程中消去 $\\mathrm{d}\\lambda$ 得到，使得 $\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{C}_{\\mathrm{alg}}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$。\n\n所有量都是无量纲的；不需要物理单位。\n\n您的程序必须实现此返回映射算法，并为以下测试套件生成所要求的输出。每个测试用例提供 $\\mathbf{K}$、$\\mathbf{A}$、$t_c$、$\\boldsymbol{\\delta}_{n+1}$ 和 $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$。对于每个测试，计算：\n- 更新后的牵引力分量 $\\mathbf{t}_{n+1} = [t_n,\\, t_s]^\\mathsf{T}$。\n- 一致切线矩阵 $\\mathbf{C}_{\\mathrm{alg}} \\in \\mathbb{R}^{2\\times 2}$，报告其条目 $C_{11}, C_{12}, C_{21}, C_{22}$。\n\n测试套件：\n- 测试 1（弹性，对角 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.002 \\\\ 0.002 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 2（塑性，对角 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 3（在屈服面上，如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$ 则视为弹性）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} \\frac{3}{1000\\sqrt{2}} \\\\ \\frac{2}{500\\sqrt{2}} \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 4（塑性，耦合 $\\mathbf{K}$）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1200  200 \\\\ 200  800 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.004 \\\\ 0.004 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$。\n- 测试 5（具有非零初始塑性跳跃的弹性）：\n  - $\\mathbf{K} = \\begin{bmatrix} 1000  0 \\\\ 0  500 \\end{bmatrix}$，$\\mathbf{A} = \\begin{bmatrix} \\frac{1}{9}  0 \\\\ 0  \\frac{1}{4} \\end{bmatrix}$，$t_c = 1$，\n  - $\\boldsymbol{\\delta}_{n+1} = \\begin{bmatrix} 0.006 \\\\ 0.0 \\end{bmatrix}$，$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n} = \\begin{bmatrix} 0.004 \\\\ 0.0 \\end{bmatrix}$。\n\n程序输出规范：\n- 对于每个测试，输出列表 $[t_n, t_s, C_{11}, C_{12}, C_{21}, C_{22}]$，其中所有条目均四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含所有测试的结果，格式为一个由这些列表组成的逗号分隔列表，并用方括号括起来，例如：\n$[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\dots]$。", "solution": "该问题要求为一个内聚界面的率无关伴随塑性推导并实现一个返回映射算法。我们必须为给定的一组材料参数和规定的最终位移跳跃 $\\boldsymbol{\\delta}_{n+1}$ 计算更新后的牵引力向量 $\\mathbf{t}_{n+1}$ 和一致算法切线矩阵 $\\mathbf{C}_{\\mathrm{alg}}$。推导必须从第一性原理出发。\n\n让我们首先将问题形式化。时间增量开始时的状态是已知的，由塑性位移跳跃 $\\boldsymbol{\\delta}^{\\mathrm{p}}_n$ 表征。增量结束时的总位移跳跃 $\\boldsymbol{\\delta}_{n+1}$ 是给定的。\n\n控制方程是：\n1.  弹性定律：$\\mathbf{t} = \\mathbf{K}\\,(\\boldsymbol{\\delta} - \\boldsymbol{\\delta}^{\\mathrm{p}})$\n2.  屈服函数：$f(\\mathbf{t}) = \\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}} - t_c \\le 0$\n3.  流动法则（后向欧拉离散化）：$\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} + \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}$，其中 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\Delta\\gamma \\left. \\frac{\\partial f}{\\partial \\mathbf{t}} \\right|_{\\mathbf{t}_{n+1}}$\n4.  Kuhn-Tucker 加载/卸载条件：$\\Delta\\gamma \\ge 0$，$f(\\mathbf{t}_{n+1}) \\le 0$，$\\Delta\\gamma\\,f(\\mathbf{t}_{n+1}) = 0$\n\n屈服函数的梯度是：\n$$\n\\frac{\\partial f}{\\partial \\mathbf{t}} = \\frac{\\mathbf{A}\\,\\mathbf{t}}{\\sqrt{\\mathbf{t}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}}}\n$$\n在塑性加载期间，我们有 $f(\\mathbf{t}_{n+1}) = 0$，这意味着 $\\sqrt{\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}} = t_c$。因此，流动法则简化为：\n$$\n\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\frac{\\Delta\\gamma}{t_c} \\mathbf{A}\\,\\mathbf{t}_{n+1} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\n这里我们定义了缩放的（且非负的）塑性乘子 $\\lambda = \\Delta\\gamma/t_c \\ge 0$。\n\n返回映射算法分两个主要步骤进行：一个弹性试探步，如果需要，则跟随一个塑性修正步。\n\n**步骤 1：弹性预测器（试探状态）**\n首先，我们假设整个步骤是弹性的，即 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\mathbf{0}$。试探牵引力 $\\mathbf{t}^{\\mathrm{tr}}$ 使用弹性定律计算：\n$$\n\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n})\n$$\n然后，我们通过在此试探状态下评估屈服函数来检查塑性屈服：\n$$\nf(\\mathbf{t}^{\\mathrm{tr}}) = \\sqrt{(\\mathbf{t}^{\\mathrm{tr}})^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}^{\\mathrm{tr}}} - t_c\n$$\n如果 $f(\\mathbf{t}^{\\mathrm{tr}}) \\le 0$，则弹性的假设是正确的。状态更新为：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n$$\n\\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1} = \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\n响应是纯弹性的，所以一致切线就是弹性刚度矩阵：\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}} = \\frac{\\partial}{\\partial \\boldsymbol{\\delta}_{n+1}} \\left[ \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) \\right] = \\mathbf{K}\n$$\n\n**步骤 2：塑性修正（返回映射）**\n如果 $f(\\mathbf{t}^{\\mathrm{tr}})  0$，试探状态位于弹性域之外，需要进行塑性修正。最终状态 $(\\mathbf{t}_{n+1}, \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1})$ 必须满足本构方程和一致性条件 $f(\\mathbf{t}_{n+1}) = 0$。\n\n更新后的牵引力与试探状态相关：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n+1}) = \\mathbf{K}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n} - \\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}) = \\mathbf{t}^{\\mathrm{tr}} - \\mathbf{K}\\,\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}}\n$$\n代入流动法则 $\\Delta\\boldsymbol{\\delta}^{\\mathrm{p}} = \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}$：\n$$\n\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}} - \\lambda\\,\\mathbf{K}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\n$$\n为 $\\mathbf{t}_{n+1}$ 重新整理可得：\n$$\n(\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{t}^{\\mathrm{tr}}\n$$\n左乘 $\\mathbf{K}^{-1}$，我们得到：\n$$\n(\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})\\,\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathbf{t}^{\\mathrm{tr}} = \\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}\n$$\n这导致了 $\\mathbf{t}_{n+1}$ 作为未知乘子 $\\lambda$ 的函数表达式：\n$$\n\\mathbf{t}_{n+1}(\\lambda) = (\\mathbf{K}^{-1} + \\lambda\\,\\mathbf{A})^{-1}\\,(\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) = (\\mathbf{I} + \\lambda\\,\\mathbf{K}\\,\\mathbf{A})^{-1}\\,\\mathbf{t}^{\\mathrm{tr}}\n$$\n如问题中所给，求解塑性步的方程组由这个关系和一致性条件组成：\n$$\n\\begin{cases}\n\\mathbf{K}^{-1}\\,\\mathbf{t}_{n+1} - (\\boldsymbol{\\delta}_{n+1} - \\boldsymbol{\\delta}^{\\mathrm{p}}_{n}) + \\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} = \\mathbf{0} \\\\\nf(\\mathbf{t}_{n+1}) = 0\n\\end{cases}\n$$\n为了解这个系统，我们将 $\\mathbf{t}_{n+1}(\\lambda)$ 的表达式代入一致性条件 $f(\\mathbf{t}_{n+1})=0$，这等价于 $\\mathbf{t}_{n+1}^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} - t_c^2 = 0$。这产生了一个关于 $\\lambda$ 的标量非线性残差方程：\n$$\nR(\\lambda) = \\sqrt{\\mathbf{t}_{n+1}(\\lambda)^\\mathsf{T}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}(\\lambda)} - t_c = 0\n$$\n这个关于 $\\lambda  0$ 的一维求根问题可以使用诸如 Newton-Raphson 之类的数值方法高效求解。一旦确定了 $\\lambda$，就可以计算更新后的牵引力 $\\mathbf{t}_{n+1}$。\n\n**步骤 3：一致算法切线的推导**\n在有限元背景下，全局 Newton-Raphson 求解器的二次收敛需要一致切线算子 $\\mathbf{C}_{\\mathrm{alg}} = \\frac{\\partial \\mathbf{t}_{n+1}}{\\partial \\boldsymbol{\\delta}_{n+1}}$。它是通过对塑性状态的控制方程组取全微分来推导的。我们将系统线性化：\n1.  $(\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\mathbf{t}^{\\mathrm{tr}}$\n2.  $f(\\mathbf{t}_{n+1}) = 0$\n\n回想一下 $\\mathbf{t}^{\\mathrm{tr}}$ 通过 $\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$ 依赖于 $\\boldsymbol{\\delta}_{n+1}$，我们对第一个方程求微分：\n$$\n\\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1} + (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})\\,\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{K}^{-1}\\,\\mathrm{d}\\mathbf{t}^{\\mathrm{tr}} = \\mathbf{K}^{-1}\\,(\\mathbf{K}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}) = \\mathrm{d}\\boldsymbol{\\delta}_{n+1}\n$$\n让我们定义 $\\mathbf{H}_{\\lambda}^{-1} = \\mathbf{K}^{-1} + \\lambda\\mathbf{A}$。解出 $\\mathrm{d}\\mathbf{t}_{n+1}$：\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1})\n$$\n接下来，我们对一致性条件 $f(\\mathbf{t}_{n+1})=0$ 求微分，这意味着任何变分都必须位于屈服面的切平面内：\n$$\n\\mathrm{d}f = \\left(\\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}}\\right)^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0\n$$\n设 $\\mathbf{m} = \\frac{\\partial f}{\\partial \\mathbf{t}_{n+1}} = \\frac{\\mathbf{A}\\,\\mathbf{t}_{n+1}}{t_c}$。条件是 $\\mathbf{m}^\\mathsf{T}\\,\\mathrm{d}\\mathbf{t}_{n+1} = 0$。\n代入 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的表达式：\n$$\n\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,(\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathrm{d}\\lambda\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) = 0\n$$\n我们解此方程以求得乘子的微分 $\\mathrm{d}\\lambda$：\n$$\n\\mathrm{d}\\lambda = \\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\n这个表达式将塑性乘子的增量与总位移跳跃的增量联系起来。最后，我们将 $\\mathrm{d}\\lambda$ 代回到 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的表达式中，以消除对 $\\mathrm{d}\\lambda$ 的依赖：\n$$\n\\mathrm{d}\\mathbf{t}_{n+1} = \\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1} - \\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}\\,\\left(\\frac{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathrm{d}\\boldsymbol{\\delta}_{n+1}}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\\right)\n$$\n使用外积表示法 $(\\mathbf{u} \\otimes \\mathbf{v}) \\mathbf{w} = \\mathbf{u} (\\mathbf{v}^\\mathsf{T} \\mathbf{w})$，我们可以确定从 $\\mathrm{d}\\boldsymbol{\\delta}_{n+1}$ 到 $\\mathrm{d}\\mathbf{t}_{n+1}$ 的映射算子：\n$$\n\\mathbf{C}_{\\mathrm{alg}} = \\mathbf{H}_{\\lambda} - \\frac{(\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}) \\otimes (\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda})}{\\mathbf{m}^\\mathsf{T}\\,\\mathbf{H}_{\\lambda}\\,\\mathbf{A}\\,\\mathbf{t}_{n+1}}\n$$\n其中 $\\mathbf{H}_{\\lambda} = (\\mathbf{K}^{-1} + \\lambda\\mathbf{A})^{-1}$ 且 $\\mathbf{m} = \\mathbf{A}\\,\\mathbf{t}_{n+1} / t_c$。这就是塑性步的精确一致算法切线。\n\n现在的实现将遵循此推导的算法来处理所提供的测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the cohesive zone plasticity problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test 1 (elastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.002, 0.002]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 2 (plastic, diagonal K)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 3 (on the yield surface)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([3.0 / (1000.0 * np.sqrt(2.0)), 2.0 / (500.0 * np.sqrt(2.0))]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 4 (plastic, coupled K)\n        {\n            'K': np.array([[1200.0, 200.0], [200.0, 800.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.004, 0.004]),\n            'delta_p_n': np.array([0.0, 0.0])\n        },\n        # Test 5 (elastic with prior plastic jump)\n        {\n            'K': np.array([[1000.0, 0.0], [0.0, 500.0]]),\n            'A': np.array([[1.0/9.0, 0.0], [0.0, 1.0/4.0]]),\n            'tc': 1.0,\n            'delta': np.array([0.006, 0.0]),\n            'delta_p_n': np.array([0.004, 0.0])\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        K = case['K']\n        A = case['A']\n        tc = case['tc']\n        delta_n1 = case['delta']\n        delta_p_n = case['delta_p_n']\n\n        # Step 1: Elastic Predictor\n        delta_e_tr = delta_n1 - delta_p_n\n        t_tr = K @ delta_e_tr\n        \n        # Check yield condition\n        f_tr_val_sq = t_tr.T @ A @ t_tr\n        f_tr = np.sqrt(f_tr_val_sq) - tc\n\n        if f_tr = 1e-12:  # Using tolerance for floating point comparison\n            # Elastic step\n            t_n1 = t_tr\n            C_alg = K\n        else:\n            # Plastic step: return mapping\n            \n            # Formulate the residual function for lambda\n            K_inv = np.linalg.inv(K)\n            \n            def residual(lam):\n                # Using the expression t_n1 = (I + lambda*K*A)^-1 * t_tr\n                # Inversion is expensive, so it's better to solve the linear system\n                # (I + lam*K@A) @ t_n1 = t_tr\n                M = np.eye(2) + lam * K @ A\n                t_n1_lam = np.linalg.solve(M, t_tr)\n                yield_val_sq = t_n1_lam.T @ A @ t_n1_lam\n                return np.sqrt(yield_val_sq) - tc\n\n            # Solve for lambda using a root-finding algorithm\n            sol = root_scalar(residual, bracket=[0, 1e-2], method='brentq')\n            lam = sol.root\n            \n            # Update traction vector\n            M_final = np.eye(2) + lam * K @ A\n            t_n1 = np.linalg.solve(M_final, t_tr)\n            \n            # Calculate consistent tangent\n            H_lam = np.linalg.inv(K_inv + lam * A)\n            m = (A @ t_n1) / tc\n            \n            numerator_vec1 = H_lam @ A @ t_n1\n            numerator_vec2_T = m.T @ H_lam\n            \n            denominator = m.T @ H_lam @ A @ t_n1\n            \n            C_alg = H_lam - np.outer(numerator_vec1, numerator_vec2_T) / denominator\n\n        # Format output\n        tn, ts = t_n1[0], t_n1[1]\n        C11, C12 = C_alg[0, 0], C_alg[0, 1]\n        C21, C22 = C_alg[1, 0], C_alg[1, 1]\n        \n        results.append(\n            f\"[{tn:.6f},{ts:.6f},{C11:.6f},{C12:.6f},{C21:.6f},{C22:.6f}]\"\n        )\n    \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2544669"}]}