{"hands_on_practices": [{"introduction": "任何稳健的数值模型都必须是可验证的。对于一个库仑摩擦模型，一个基础的验证测试是检查其在无摩擦极限下的行为。当摩擦系数 $\\mu$ 被设为零时，该模型必须退化为一个纯粹的单边接触问题，无论切向滑移如何，都不应产生切向力。这项实践 [@problem_id:2550832] 将指导您实现并测试这一关键特性，确保您的算法在处理更复杂的摩擦情景之前，其基础是正确的。", "problem": "设计并实现一个针对有限元方法中库仑摩擦接触算法的验证测试，该算法在摩擦系数为零时应简化为无摩擦单边接触。目标是确认当摩擦系数设为零时，该方法不产生切向曳力，并且仅施加单边法向接触响应。您必须从第一性原理推导控制接触响应，并将其实现为一个完整的、可运行的程序，用于评估指定的测试套件。\n\n从以下基本原理出发：\n- 离散节点与刚性平面接触的虚功原理，该原理给出了接触曳力与外力作用之间的平衡关系。\n- 法向的单边（Signorini）接触条件：法向间隙 $g_n$ 满足 $g_n \\ge 0$，法向接触反力 $r_n$ 满足 $r_n \\ge 0$，以及互补条件 $r_n g_n = 0$。\n- 切向平面内的库仑摩擦模型，摩擦系数为 $\\mu \\ge 0$。在滑移过程中，切向曳力的大小受限于 $\\mu r_n$，且其方向与切向相对运动方向相反。\n- 法向接触的罚函数正则化，当试探状态违反 $g_n \\ge 0$（即 $g_n  0$）时，该方法对侵入进行惩罚。\n\n离散化模型：\n- 考虑一个表面节点与一个刚性平面相互作用，该平面在接触点处具有单位外法线 $\\mathbf{n}$ 和一个标准正交切向标架 $\\{\\mathbf{t}_1,\\mathbf{t}_2\\}$。\n- 设带符号的法向间隙为 $g_n \\in \\mathbb{R}$，定义为分离时为正，侵入时为负。设切向间隙矢量为 $\\mathbf{g}_t \\in \\mathbb{R}^2$，在局部切向基中表示。接触反力分解为 $\\mathbf{r} = r_n \\mathbf{n} + \\mathbf{r}_t$，其中 $r_n \\in \\mathbb{R}$ 且 $\\mathbf{r}_t \\in \\mathbb{R}^2$。\n- 使用法向罚刚度 $k_n  0$ 和切向罚刚度 $k_t  0$ 来定义进行摩擦投影之前的试探弹性曳力。\n\n根据虚功原理和罚函数正则化，法向反力由关于侵入的二次罚势能的导数得到，\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\n其中 $\\langle x \\rangle_+ = \\max(0,x)$。因此，法向反力为\n$$\nr_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\cdot (-1) = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\n在切向平面内，定义试探弹性曳力\n$$\n\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t.\n$$\n为施加摩擦系数为 $\\mu \\ge 0$ 的库仑摩擦，当接触处于激活状态时，将 $\\mathbf{t}^{\\text{trial}}$ 投影到容许集\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}\n$$\n上。若 $r_n = 0$（无接触），则设 $\\mathbf{r}_t = \\mathbf{0}$。若 $r_n  0$，则：\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$，则为粘滞状态，此时 $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$。\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\|  \\mu r_n$，则为滑移状态，此时\n$$\n\\mathbf{r}_t = \\mu r_n \\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}}\\|}.\n$$\n当摩擦系数为零，即 $\\mu = 0$ 时，容许集简化为 $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$，因此该方法的一致性简化是在所有状态下均为 $\\mathbf{r}_t = \\mathbf{0}$，法向反力 $r_n$ 如上所述。对于任何 $k_t$ 和 $\\mathbf{g}_t$ 的选择，此条件都必须成立，且不产生虚假的切向曳力。\n\n编程任务：\n- 为单个节点与刚性平面的情况实现上述接触定律，使用基于罚函数的法向反力以及切向平面内的库仑投影。\n- 使用国际单位制（SI）：长度单位为米（$\\mathrm{m}$），力单位为牛顿（$\\mathrm{N}$）。在内部，所有输入都将以 SI 单位提供。程序的最终输出是表示每个测试通过或失败的无量纲布尔值，因此不应打印任何单位。\n\n测试套件：\n对于每个测试用例，将摩擦系数设为 $\\mu = 0$，计算 $(r_n, \\mathbf{r}_t)$，并使用固定的绝对容差 $\\varepsilon = 10^{-10}$ 验证以下条件：\n- 无虚假切向曳力：$\\|\\mathbf{r}_t\\| \\le \\varepsilon$。\n- 正确的法向反力：$|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$。\n- 若 $g_n \\ge 0$（分离或接触），则额外验证 $r_n \\le \\varepsilon$。\n\n使用以下五个测试用例（每个元组为 $(g_n, \\mathbf{g}_t, k_n, k_t)$）：\n- 用例 A（激活接触状态下大切向滑移的理想路径）：$(-10^{-3}\\ \\mathrm{m},\\ [3\\times 10^{-2},\\ -4\\times 10^{-2}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例 B（分离）：$(2\\times 10^{-4}\\ \\mathrm{m},\\ [1,\\ -1]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例 C（接触边界）：$(0\\ \\mathrm{m},\\ [10^{-1},\\ 10^{-1}]\\ \\mathrm{m},\\ 10^{7}\\ \\mathrm{N/m},\\ 2\\times 10^{7}\\ \\mathrm{N/m})$。\n- 用例 D（微小侵入且切向罚刚度极大）：$(-5\\times 10^{-5}\\ \\mathrm{m},\\ [5\\times 10^{-1},\\ -5\\times 10^{-1}]\\ \\mathrm{m},\\ 3\\times 10^{8}\\ \\mathrm{N/m},\\ 10^{9}\\ \\mathrm{N/m})$。\n- 用例 E（侵入但切向间隙为零）：$(-2\\times 10^{-4}\\ \\mathrm{m},\\ [0,\\ 0]\\ \\mathrm{m},\\ 4\\times 10^{7}\\ \\mathrm{N/m},\\ 5\\times 10^{6}\\ \\mathrm{N/m})$。\n\n预期程序行为：\n- 对每个用例，使用上述算法（$\\mu = 0$ 和 $\\varepsilon = 10^{-10}$）计算 $(r_n, \\mathbf{r}_t)$，然后将三个检查评估为每个用例的单个通过/失败布尔值：如果所有适用的检查都满足，则该用例通过。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔结果列表（例如，“[true1,true2,true3,true4,true5]”）。使用 Python 布尔字面量（“True”或“False”）。", "solution": "我们推导了单个节点与刚性平面接触时的一致性离散接触响应，其中法向采用罚函数正则化，切向采用库仑摩擦的返回映射投影。推导从虚功原理开始，该原理指出内力和接触力的虚功与外力的虚功相平衡。对于单个与刚性平面相互作用的节点，接触力是界面上唯一的内力贡献，并且与间隙是功共轭的。\n\n法向接触。单边约束由 Signorini 条件描述：$g_n \\ge 0$，$r_n \\ge 0$，$r_n g_n = 0$。为对此约束进行正则化，我们引入一个仅作用于侵入的凸罚势能，\n$$\n\\Pi_n(g_n) = \\tfrac{1}{2} k_n \\,\\langle -g_n \\rangle_+^2,\n$$\n其中 $k_n  0$ 且 $\\langle x \\rangle_+ = \\max(0,x)$。法向接触反力由增广能量关于间隙虚变分（在链式法则意义下）的平稳性得出，\n$$\n\\delta \\Pi_n = \\dfrac{\\partial \\Pi_n}{\\partial g_n} \\,\\delta g_n, \\quad \\text{和} \\quad \\delta W_n = r_n \\,\\delta g_n,\n$$\n因此辨识可得 $r_n = \\partial \\Pi_n/\\partial g_n \\cdot (-1)$（出现负号是因为当 $g_n$ 减小时，一个正的压缩反力做负功）。求导可得\n$$\nr_n = k_n \\,\\langle -g_n \\rangle_+ = k_n \\max(0,-g_n).\n$$\n此响应在分离或接触（$g_n \\ge 0$）时强制 $r_n = 0$，在侵入（$g_n  0$）时强制 $r_n = k_n (-g_n)$，这在极限 $k_n \\to \\infty$情况下与单边约束是一致的。\n\n带库仑摩擦的切向接触。在切向平面内，通过二次罚储存能定义弹性试探曳力，\n$$\n\\Pi_t(\\mathbf{g}_t) = \\tfrac{1}{2} k_t \\,\\|\\mathbf{g}_t\\|^2, \\quad \\mathbf{t}^{\\text{trial}} = \\dfrac{\\partial \\Pi_t}{\\partial \\mathbf{g}_t} = k_t \\,\\mathbf{g}_t,\n$$\n其中 $k_t  0$。当接触激活时，库仑摩擦将容许的切向曳力 $\\mathbf{r}_t$ 限制在切向平面内一个半径为 $\\mu r_n$ 的圆盘内。这是一个闭凸集\n$$\n\\mathcal{C}(r_n) = \\left\\{ \\mathbf{t} \\in \\mathbb{R}^2 \\,:\\, \\|\\mathbf{t}\\| \\le \\mu r_n \\right\\}.\n$$\n当 $r_n = 0$（无激活接触）时，不存在容许的切向曳力，一致性要求 $\\mathbf{r}_t = \\mathbf{0}$。当 $r_n  0$ 时，一致性算法是将试探曳力在欧几里得范数意义下正交投影到 $\\mathcal{C}(r_n)$ 上：\n- 若 $\\|\\mathbf{t}^{\\text{trial}}\\| \\le \\mu r_n$（粘滞），则 $\\mathbf{r}_t = \\mathbf{t}^{\\text{trial}}$。\n- 否则（滑移），在 $\\mathbf{t}^{\\text{trial}}$ 方向上投影到半径为 $\\mu r_n$ 的圆上，得到\n$$\n\\mathbf{r}_t = \\mu r_n \\,\\dfrac{\\mathbf{t}^{\\text{trial}}}{\\|\\mathbf{t}^{\\text{trial}}\\|}.\n$$\n该投影是在约束 $\\mathbf{t} \\in \\mathcal{C}(r_n)$ 下 $\\|\\mathbf{t} - \\mathbf{t}^{\\text{trial}}\\|$ 的唯一最小化子，并且是有限元实现中使用的标准返回映射算法的离散对应物。\n\n零摩擦极限。当 $\\mu = 0$ 时，对于任何 $r_n \\ge 0$，容许集都简化为 $\\mathcal{C}(r_n) = \\{\\mathbf{0}\\}$。因此，当 $r_n  0$ 时，粘滞条件和滑移投影都退化为唯一的容许值\n$$\n\\mathbf{r}_t = \\mathbf{0}.\n$$\n当 $r_n = 0$ 时，根据分离（或接触）的一致性，我们同样有 $\\mathbf{r}_t = \\mathbf{0}$。因此，无论切向间隙 $\\mathbf{g}_t$ 或切向罚函数 $k_t$ 如何，$\\mu = 0$ 的库仑模型都严格简化为无摩擦单边接触：即纯法向反力，无虚假切向曳力。\n\n验证检查。为了验证这一简化，我们检验：\n- 无虚假切向曳力：在微小容差 $\\varepsilon$ 内，$\\|\\mathbf{r}_t\\| \\le \\varepsilon$。\n- 正确的法向反力：$|r_n - k_n \\max(0,-g_n)| \\le \\varepsilon$。\n- 分离状态下的一致性：若 $g_n \\ge 0$，则 $r_n \\le \\varepsilon$。\n\n每个测试用例的算法步骤：\n1. 输入 $(g_n, \\mathbf{g}_t, k_n, k_t)$ 并设置 $\\mu = 0$ 及容差 $\\varepsilon$。\n2. 计算 $r_n = k_n \\max(0,-g_n)$。\n3. 若 $r_n = 0$，则设 $\\mathbf{r}_t = \\mathbf{0}$。否则，计算 $\\mathbf{t}^{\\text{trial}} = k_t \\,\\mathbf{g}_t$ 并将其投影到 $\\mu = 0$ 的 $\\mathcal{C}(r_n)$ 上，得到 $\\mathbf{r}_t = \\mathbf{0}$。\n4. 评估这三个检查，并为该用例记录一个布尔型的通过/失败结果。\n\n提供的程序实现了此算法并执行了五个指定的用例：\n- 用例 A（大切向滑移的侵入）测试了激活接触状态，并确保即使在大的 $\\|\\mathbf{g}_t\\|$ 和 $k_t$ 下，$\\mathbf{r}_t = \\mathbf{0}$。\n- 用例 B（分离）测试了互补性：$r_n$ 和 $\\|\\mathbf{r}_t\\|$ 都必须在容差范围内为零。\n- 用例 C（接触边界）进一步测试了单边约束的边界情况。\n- 用例 D（微小侵入，切向罚函数非常大）在极端试探切向曳力下对投影进行压力测试，并确认其返回值仍为 $\\mathbf{0}$。\n- 用例 E（切向间隙为零的侵入）测试了切向试探曳力恰好为零的极限情况。\n\n输出是包含五个布爾值的单个列表，每个用例对应一个。如果实现能够在 $\\mu=0$ 时正确地简化为无摩擦接触且无虚假切向曳力，则所有值都必须为 True。", "answer": "```python\nimport numpy as np\n\ndef contact_response(g_n, g_t_vec, k_n, k_t, mu, tol=1e-14):\n    \"\"\"\n    Compute contact reaction for a single node against a rigid plane.\n\n    Parameters:\n        g_n (float): normal gap (m), positive in separation, negative in penetration.\n        g_t_vec (array-like): tangential gap vector (m) in 2D tangential frame.\n        k_n (float): normal penalty stiffness (N/m).\n        k_t (float): tangential penalty stiffness (N/m).\n        mu (float): Coulomb friction coefficient (dimensionless).\n        tol (float): small tolerance for numerical decisions.\n\n    Returns:\n        r_n (float): normal reaction (N), non-negative.\n        r_t (np.ndarray): tangential reaction vector (N) in 2D.\n    \"\"\"\n    g_t = np.array(g_t_vec, dtype=float).reshape(2)\n    # Normal reaction via penalty on interpenetration\n    r_n = k_n * max(0.0, -g_n)\n\n    # If no contact is active, no tangential traction\n    if r_n = tol:\n        return r_n, np.zeros(2)\n\n    # Trial tangential elastic traction\n    t_trial = k_t * g_t\n    norm_t_trial = np.linalg.norm(t_trial)\n    bound = mu * r_n\n\n    if norm_t_trial = bound + tol:\n        # Stick\n        r_t = t_trial\n    else:\n        # Slip: project onto friction disk\n        if norm_t_trial = tol or bound = tol:\n            r_t = np.zeros(2)\n        else:\n            r_t = (bound / norm_t_trial) * t_trial\n\n    return r_n, r_t\n\n\ndef run_tests():\n    # Frictionless limit\n    mu = 0.0\n    # Tolerances for verification\n    tol_force = 1e-10\n\n    test_cases = [\n        # (g_n, g_t, k_n, k_t)\n        (-1e-3,  [3e-2, -4e-2], 1e7, 2e7),      # Case A: penetration, large tangential slip\n        ( 2e-4,  [1.0,  -1.0],  1e7, 2e7),      # Case B: separation\n        ( 0.0,   [1e-1,  1e-1], 1e7, 2e7),      # Case C: touching boundary\n        (-5e-5,  [5e-1, -5e-1], 3e8, 1e9),      # Case D: small penetration, very stiff kt\n        (-2e-4,  [0.0,   0.0],  4e7, 5e6),      # Case E: penetration, zero tangential gap\n    ]\n\n    results = []\n    for g_n, g_t, k_n, k_t in test_cases:\n        r_n, r_t = contact_response(g_n, g_t, k_n, k_t, mu)\n        # Checks\n        # 1) No spurious tangential traction\n        no_spurious_tan = np.linalg.norm(r_t) = tol_force\n        # 2) Correct normal reaction\n        r_n_expected = k_n * max(0.0, -g_n)\n        correct_normal = abs(r_n - r_n_expected) = tol_force\n        # 3) If separation or touching, r_n must be zero\n        sep_touch_ok = True\n        if g_n >= 0.0:\n            sep_touch_ok = r_n = tol_force\n\n        results.append(bool(no_spurious_tan and correct_normal and sep_touch_ok))\n    return results\n\n\ndef solve():\n    results = run_tests()\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2550832"}, {"introduction": "在有限元分析中，解的准确性取决于网格分辨率。对于像摩擦这样的非线性问题，接触状态（粘着或滑移）可能发生突变，因此理解这种依赖性至关重要。网格加密研究系统地评估了当单元尺寸减小时，数值解如何收敛于真实解。通过这项实践 [@problem_id:2550840]，您将为一个一维摩擦界面实施一个收敛性研究，学习量化牵引力分布和预测的粘滑区域中的离散化误差。", "problem": "针对一个二维平面滑块的库仑摩擦接触问题，设计并实现一个自洽的一维界面有限元离散网格加密研究。其目标是评估随着界面网格的加密，计算出的切向反作用力场和粘滞-滑移界面划分的收敛性。所有量均为无量纲；所有输出均以无量纲浮点数形式报告。\n\n基本和建模假设：\n- 接触界面为长度为 $L0$ 的线段 $\\left[0,L\\right]$。\n- 沿界面，法向接触压力是均匀的，等于 $p_n0$。\n- 切向摩擦系数为 $\\mu0$。\n- 切向罚刚度为 $k_t0$。\n- 在满载情况下，给定的相对切向滑移场为 $g_t(x)=U_0\\left(\\dfrac{x}{L}\\right)^{\\alpha}$，对于 $x\\in[0,L]$，其中 $U_0\\ge 0$ 和 $\\alpha\\ge 1$ 是给定值。\n- 带有罚函数正则化的库仑摩擦定律逐点执行如下。定义试探切向牵引力 $t_{\\mathrm{tr}}(x)=k_t\\,g_t(x)$。则容许的切向牵引力为\n$$\nt(x)=\\begin{cases}\nt_{\\mathrm{tr}}(x),  \\text{若 } \\left|t_{\\mathrm{tr}}(x)\\right|\\le \\mu\\,p_n \\quad \\text{(粘滞)},\\\\\n\\mu\\,p_n\\,\\mathrm{sign}\\!\\left(t_{\\mathrm{tr}}(x)\\right),  \\text{若 } \\left|t_{\\mathrm{tr}}(x)\\right|\\mu\\,p_n \\quad \\text{(滑移)}.\n\\end{cases}\n$$\n此局部返回映射以给定的罚刚度强制施加库仑边界。\n- 界面的有限元 (FE) 近似在 $[0,L]$ 上使用 $N$ 个均匀分布的节点。相对滑移的离散节点值取为在节点处采样的精确 $g_t(x)$ 值。$g_t$ 在界面上的有限元插值是标准的分段线性插值。近似切向牵引力场 $t_h(x)$ 是通过在每个 $x$ 处对插值后的滑移值应用上述局部返回映射得到的。\n\n参考解和误差范数的定义：\n- 高分辨率参考场是通过在 $[0,L]$ 上 $n_{\\mathrm{ref}}$ 个均匀分布的采样点上，使用精确的 $g_t(x)$ 来评估 $t(x)$ 定义的。将这些采样位置表示为 $\\{x_i\\}_{i=0}^{n_{\\mathrm{ref}}-1}$，间距为 $\\Delta x = \\dfrac{L}{n_{\\mathrm{ref}}-1}$。令 $t_{\\mathrm{ref},i}=t(x_i)$。\n- 对于给定的具有 $N$ 个节点的有限元网格，通过在网格上计算 $g_t$ 的分段线性插值，并在每个 $x_i$ 处应用相同的返回映射，定义 $t_{h,i}=t_h(x_i)$。\n- 切向牵引力的相对 $L^2$ 误差为\n$$\n\\mathcal{E}_{L^2}=\\frac{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{h,i}-t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}}{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}},\n$$\n其中梯形权重为 $w_0=w_{n_{\\mathrm{ref}}-1}=\\dfrac{\\Delta x}{2}$ 和 $w_i=\\Delta x$ 对于 $i=1,\\dots,n_{\\mathrm{ref}}-2$。如果分母为零，则定义 $\\mathcal{E}_{L^2}=0$。\n- 粘滞-滑移划分误差的定义如下：对于参考场，若 $\\left|t_{\\mathrm{tr}}(x_i)\\right|\\le \\mu\\,p_n$，则将每个采样点 $x_i$ 分类为粘滞，否则为滑移；对于近似场，类似地使用有限元插值后的滑移进行分类。令 $s_{\\mathrm{ref},i}\\in\\{0,1\\}$，粘滞为 $1$，滑移为 $0$；令 $s_{h,i}$ 为在 $x_i$ 处相应的基于有限元的分类。划分误差是对称差分数\n$$\n\\mathcal{E}_{\\mathrm{part}}=\\frac{1}{n_{\\mathrm{ref}}}\\sum_{i=0}^{n_{\\mathrm{ref}}-1}\\left|s_{h,i}-s_{\\mathrm{ref},i}\\right|.\n$$\n\n算法要求：\n- 为多个参数集实现上述模型和误差计算。对参考解使用精确的 $g_t(x)$，对离散近似使用有限元插值的 $g_t(x)$。\n- 使用 $n_{\\mathrm{ref}}=4001$ 作为参考网格，以数值方式近似积分和划分度量。\n- 所有计算都是无量纲的。将 $\\mathcal{E}_{L^2}$ 和 $\\mathcal{E}_{\\mathrm{part}}$ 报告为无量纲浮点数。\n\n测试套件：\n除非特别说明，所有测试使用以下固定参数：$L=1$，$\\mu=0.3$，$p_n=1$，$k_t=50$。定义六个测试用例，涵盖正常路径、加密过程和边界情况：\n- 用例 1：$N=4$，$U_0=0.02$，$\\alpha=1$。\n- 用例 2：$N=8$，$U_0=0.02$，$\\alpha=1$。\n- 用例 3：$N=16$，$U_0=0.02$，$\\alpha=1$。\n- 用例 4：$N=8$，$U_0=0.001$，$\\alpha=1$。\n- 用例 5：$N=8$，$U_0=0.5$，$\\alpha=1$。\n- 用例 6：$N=8$，$U_0=0.02$，$\\alpha=3$。\n\n程序必须做什么：\n- 对于每个用例，计算如上定义的 $\\mathcal{E}_{L^2}$ 和 $\\mathcal{E}_{\\mathrm{part}}$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个结果必须是一个形如 $[\\mathcal{E}_{L^2},\\mathcal{E}_{\\mathrm{part}}]$ 的双元素列表，因此最终输出的格式为\n“[ [e11,e12],[e21,e22],...[e61,e62] ]”，其中每个 $e$ 是一个浮点数。", "solution": "该问题要求进行一个定义明确的计算力学数值方法练习，即为一个一维摩擦接触问题执行网格加密研究。这涉及到将有限元 (FE) 近似与高分辨率参考解进行比较。问题的核心在于正确实现用于 FE 近似的分段线性插值和决定摩擦响应的非线性返回映射算法。\n\n首先，我们建立分析和数值框架。物理域是区间 $[0,L]$。问题是无量纲的，对于所有情况，我们给定 $L=1$。给定的相对滑移是 $g_t(x) = U_0 x^\\alpha$。由于参数 $U_0$ 和 $\\alpha$ 是非负的，对于 $x \\in [0,L]$，有 $g_t(x) \\ge 0$。\n\n试探切向牵引力计算为 $t_{\\mathrm{tr}}(x) = k_t g_t(x)$。由于 $k_t  0$ 且 $g_t(x) \\ge 0$，我们有 $t_{\\mathrm{tr}}(x) \\ge 0$。摩擦响应由库仑条件控制。最大容许牵引力，即摩擦极限，是 $\\tau_{\\mathrm{crit}} = \\mu p_n$。如果试探牵引力不超过此极限，即 $|t_{\\mathrm{tr}}(x)| \\le \\tau_{\\mathrm{crit}}$，则接触处于粘滞状态，否则处于滑移状态。\n\n鉴于 $t_{\\mathrm{tr}}(x)$ 是非负的，返回映射算法显著简化：\n$$\nt(x) = \\begin{cases}\nt_{\\mathrm{tr}}(x),  \\text{如果 } t_{\\mathrm{tr}}(x) \\le \\tau_{\\mathrm{crit}} \\\\\n\\tau_{\\mathrm{crit}},  \\text{如果 } t_{\\mathrm{tr}}(x)  \\tau_{\\mathrm{crit}}\n\\end{cases}\n$$\n这可以简洁地表示为 $t(x) = \\min(t_{\\mathrm{tr}}(x), \\tau_{\\mathrm{crit}})$。粘滞-滑移状态由 $t_{\\mathrm{tr}}(x) \\le \\tau_{\\mathrm{crit}}$（粘滞）还是 $t_{\\mathrm{tr}}(x)  \\tau_{\\mathrm{crit}}$（滑移）决定。\n\n在 $[0,L]$ 上定义一个由 $n_{\\mathrm{ref}}=4001$ 个点组成的高分辨率参考网格 $\\{x_i\\}_{i=0}^{n_{\\mathrm{ref}}-1}$。参考解在这些点上计算。对于每个 $x_i$，我们计算：\n1.  精确滑移：$g_{\\mathrm{ref},i} = g_t(x_i) = U_0 (x_i/L)^\\alpha$。\n2.  试探牵引力：$t_{\\mathrm{tr,ref},i} = k_t g_{\\mathrm{ref},i}$。\n3.  实际牵引力：$t_{\\mathrm{ref},i} = \\min(t_{\\mathrm{tr,ref},i}, \\mu p_n)$。\n4.  粘滞-滑移状态：如果 $t_{\\mathrm{tr,ref},i} \\le \\mu p_n$，则 $s_{\\mathrm{ref},i} = 1$，否则 $s_{\\mathrm{ref},i} = 0$。\n\n接下来，我们为给定的节点数 $N$ 构建 FE 近似。FE 网格由 $[0,L]$ 上的 $N$ 个均匀分布的节点 $\\{z_j\\}_{j=0}^{N-1}$ 组成。\n1.  计算精确的节点滑移：$g_{j}^{\\mathrm{node}} = g_t(z_j)$，对于 $j=0, \\dots, N-1$。\n2.  FE 近似的滑移场 $g_h(x)$ 是这些节点值的分段线性插值。对于 $[0,L]$ 中的任何点 $x$，其值 $g_h(x)$ 通过在包含 $x$ 的单元的节点值之间进行线性插值找到。\n\n然后，在相同的高分辨率参考网格 $\\{x_i\\}$ 上评估近似解。对于每个点 $x_i$：\n1.  找到相应的插值滑移值 $g_{h,i} = g_h(x_i)$。这可以通过使用标准库函数进行分段线性插值来高效完成。\n2.  计算试探牵引力：$t_{\\mathrm{tr},h,i} = k_t g_{h,i}$。\n3.  应用返回映射：$t_{h,i} = \\min(t_{\\mathrm{tr},h,i}, \\mu p_n)$。\n4.  确定状态：如果 $t_{\\mathrm{tr},h,i} \\le \\mu p_n$，则 $s_{h,i} = 1$，否则 $s_{h,i} = 0$。\n\n最后，我们量化误差。\n相对 $L^2$ 误差 $\\mathcal{E}_{L^2}$ 通过使用梯形法则进行数值积分来计算。积分权重为 $w_0=w_{n_{\\mathrm{ref}}-1}=\\Delta x/2$ 和 $w_k=\\Delta x$ 用于中间点，其中 $\\Delta x = L/(n_{\\mathrm{ref}}-1)$。公式是：\n$$\n\\mathcal{E}_{L^2}=\\frac{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{h,i}-t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}}{\\left(\\sum_{i=0}^{n_{\\mathrm{ref}}-1} w_i \\left(t_{\\mathrm{ref},i}\\right)^2\\right)^{1/2}}\n$$\n必须实现对零范数参考解的检查，以避免除以零。\n\n划分误差 $\\mathcal{E}_{\\mathrm{part}}$ 是错误分类点的比例：\n$$\n\\mathcal{E}_{\\mathrm{part}} = \\frac{1}{n_{\\mathrm{ref}}} \\sum_{i=0}^{n_{\\mathrm{ref}}-1} \\mathbb{I}(s_{h,i} \\neq s_{\\mathrm{ref},i}) = \\frac{1}{n_{\\mathrm{ref}}} \\sum_{i=0}^{n_{\\mathrm{ref}}-1} |s_{h,i} - s_{\\mathrm{ref},i}|\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。这等同于状态指示符之间绝对差的平均值。\n\n算法通过遍历每个测试用例，应用这些步骤，计算两个误差度量，并收集结果以供最终输出。从用例1到用例3（$N=4, 8, 16$）的演进预计将显示收敛性，即随着FE网格的加密，两个误差范数都会减小。其他用例则探讨了对滑移幅度（$U_0$）及其空间分布（$\\alpha$）的敏感性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D frictional contact problem for a suite of test cases.\n    \"\"\"\n\n    # Define the 6 test cases from the problem statement.\n    # Format: (N, U0, alpha)\n    test_cases = [\n        (4, 0.02, 1),\n        (8, 0.02, 1),\n        (16, 0.02, 1),\n        (8, 0.001, 1),\n        (8, 0.5, 1),\n        (8, 0.02, 3),\n    ]\n\n    # Fixed parameters for all tests\n    L = 1.0\n    mu = 0.3\n    p_n = 1.0\n    k_t = 50.0\n    n_ref = 4001\n\n    results = []\n\n    for case in test_cases:\n        N, U0, alpha = case\n\n        # Friction limit (critical traction)\n        tau_crit = mu * p_n\n\n        # --- High-resolution reference solution ---\n\n        # Define the fine reference grid\n        x_ref = np.linspace(0, L, n_ref)\n\n        # Exact prescribed relative slip field g_t(x)\n        g_t = lambda x: U0 * (x / L)**alpha if L > 0 else (U0 if x == 0 else 0)\n        \n        # Evaluate exact slip on the reference grid\n        g_ref = g_t(x_ref)\n\n        # Calculate reference trial traction\n        t_tr_ref = k_t * g_ref\n\n        # Apply return-mapping to get reference traction field t(x)\n        # Since t_tr is non-negative, this is a simple min operation\n        t_ref = np.minimum(t_tr_ref, tau_crit)\n\n        # Determine reference stick-slip partition\n        # s=1 for stick, s=0 for slip\n        s_ref = (t_tr_ref = tau_crit).astype(int)\n\n        # --- Finite Element (FE) approximation ---\n\n        # Define the coarse FE nodal grid\n        x_nodes = np.linspace(0, L, N)\n\n        # Evaluate exact slip at the FE nodes\n        g_nodal = g_t(x_nodes)\n\n        # Compute the piecewise linear interpolation of slip on the reference grid\n        g_h = np.interp(x_ref, x_nodes, g_nodal)\n\n        # Calculate approximate trial traction from interpolated slip\n        t_tr_h = k_t * g_h\n\n        # Apply return-mapping to get approximate traction field t_h(x)\n        t_h = np.minimum(t_tr_h, tau_crit)\n\n        # Determine approximate stick-slip partition\n        s_h = (t_tr_h = tau_crit).astype(int)\n\n        # --- Error computation ---\n\n        # 1. Relative L2 error in tangential traction\n        delta_x = L / (n_ref - 1)\n        weights = np.full(n_ref, delta_x)\n        weights[0] = delta_x / 2.0\n        weights[-1] = delta_x / 2.0\n\n        l2_err_numerator = np.sqrt(np.sum(weights * (t_h - t_ref)**2))\n        l2_norm_ref = np.sqrt(np.sum(weights * t_ref**2))\n        \n        if l2_norm_ref > 1e-15:\n            e_l2 = l2_err_numerator / l2_norm_ref\n        else:\n            e_l2 = 0.0 # As per problem statement\n\n        # 2. Stick-slip partition error\n        e_part = np.mean(np.abs(s_h - s_ref))\n\n        results.append([e_l2, e_part])\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) correctly handles the list-of-lists format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2550840"}, {"introduction": "摩擦功代表能量耗散，是一个路径依赖的量。在模拟涉及旋转的场景时，功的数值计算必须独立于观察者的参考系——这一原则被称为客观性。非客观的数值格式会因未能正确追踪旋转局部坐标系中的运动历史而产生物理上不正确的结果，从而低估或错误计算能量耗散。本练习 [@problem_id:2550801] 通过将一个正确的、增量式的功计算方法与一个在固定坐标系中累积滑移向量的非客观方法进行比较，展示了客观性的重要性，并突出了计算力学中的一个常见陷阱。", "problem": "考虑一个半径为 $r$、宽度为 $b$ 的薄圆环，在均匀接触压力 $p$ (单位为 $\\mathrm{Pa} = \\mathrm{N}/\\mathrm{m}^2$) 的作用下被压在一个刚性平面上。该圆环位于 $z=0$ 平面内，平面的外单位法向量与全局 $z$ 轴对齐。该圆环承受一个规定的平面内相对切向运动：在圆环上的每个材料点处，平面内的瞬时相对切向速度矢量的大小恒为 $v_s$ (单位为 $\\mathrm{m}/\\mathrm{s}$)，其方向以角速度 $\\omega$ (单位为 $\\mathrm{rad}/\\mathrm{s}$) 绕平面法线旋转。这模拟了“刚性平面上的旋转环”问题，其中滑动方向随时间旋转。假设库仑摩擦系数 $\\mu$ 为恒定值（无量纲）。总法向力为 $F_N = p \\cdot (2\\pi r b)$ (单位为 $\\mathrm{N}$)。您将通过对比两种在时间范围 $T$ (单位为 $\\mathrm{s}$) 内计算切向功的离散算法，来研究有限元法（FEM）背景下摩擦功计算的客观性。\n\n您的模型应基于以下基本定律和核心定义：\n- 库仑摩擦定律：当发生滑动时，摩擦力的大小为 $F_T = \\mu F_N$。\n- 机械功：增量切向功为 $\\mathrm{d}W = \\boldsymbol{F}_T \\cdot \\mathrm{d}\\boldsymbol{u}_t$，其中 $\\mathrm{d}\\boldsymbol{u}_t$ 是平面内的增量切向滑动矢量。\n- 客观性（标架无关性）：在叠加的刚体运动（包括空间参考系的旋转）下，物理上可测量的量（如耗散功）必须保持不变。\n\n将瞬时相对切向速度定义为一个平面矢量 $\\boldsymbol{v}_{\\mathrm{rel}}(t)$，其大小恒为 $v_s$，方向以角速度 $\\omega$ 绕平面法线旋转，即对于所有 $t \\in [0,T]$，$\\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| = v_s$，其在平面内的方向为 $\\boldsymbol{e}_t(t) = [\\cos(\\omega t), \\sin(\\omega t)]$。法向没有耦合；接触保持闭合，法向力 $F_N$ 恒定。\n\n实现并比较以下两种离散算法，用于计算在 $t \\in [0,T]$ 上累积的总切向功 $W$：\n\n- 客观增量功累积（带客观参考系更新）：\n  - 将区间 $[0,T]$ 划分为 $M$ 个大小为 $\\Delta t = T/M$ 的均匀子步。\n  - 在每个子步 $k$，使用当前方向 $\\boldsymbol{e}_t(t_k)$ 计算增量切向滑动 $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$，并累积功增量为 $\\Delta W_{\\mathrm{obj}}^{(k)} = \\mu F_N \\|\\Delta \\boldsymbol{u}_t^{(k)}\\|$。\n  - 总客观功为 $W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\Delta W_{\\mathrm{obj}}^{(k)}$。\n  - 该算法通过在每一步使用瞬时方向 $\\boldsymbol{e}_t(t_k)$ 来更新切向参考系，从而保持了客观性。\n\n- 非客观累积（无客观参考系更新）：\n  - 将区间 $[0,T]$ 划分为 $M$ 个大小为 $\\Delta t = T/M$ 的均匀子步。\n  - 在每个子步 $k$，计算增量切向滑动 $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\,\\Delta t$，但在一个固定的初始参考系中仅累积平面滑动矢量：$\\boldsymbol{s} \\leftarrow \\boldsymbol{s} + \\Delta \\boldsymbol{u}_t^{(k)}$，其中 $\\boldsymbol{s}$ 在 $t=0$ 时初始化为 $\\boldsymbol{0}$。\n  - 最后，计算 $W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$。\n  - 该算法不会将已存储的切向状态随演变的切向参考系一起旋转，因此在滑动方向旋转的情况下不具有客观性。\n\n您的任务是实现一个程序，为以下四个案例的测试套件计算 $W_{\\mathrm{obj}}$ 和 $W_{\\mathrm{no}}$。角度单位使用弧度，角速度单位为 $\\mathrm{rad}/\\mathrm{s}$，长度单位为 $\\mathrm{m}$，时间单位为 $\\mathrm{s}$，力单位为 $\\mathrm{N}$，压力单位为 $\\mathrm{Pa}$，功单位为 $\\mathrm{J}$。为保证数值稳定性和一致性，为每个案例选择一个整数 $M \\geq 10^4$ 作为子步数（您可以选择任何能提供数值稳定结果的固定 $M$；由于 $\\|\\boldsymbol{v}_{\\mathrm{rel}}\\|$ 不随时间变化，客观算法的结果与 $M$ 无关）。\n\n使用以下参数集：\n- 案例 A（一般的旋转滑动方向）：\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.25\\,\\mathrm{s}$。\n- 案例 B（滑动方向恰好完整旋转一圈）：\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 2.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = \\dfrac{2\\pi}{\\omega}\\,\\mathrm{s}$。\n- 案例 C（参考系旋转非常慢，滑动方向近似恒定）：\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.001\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$。\n- 案例 D（不旋转，滑动方向恒定）：\n  - $r = 0.2\\,\\mathrm{m}$, $b = 0.01\\,\\mathrm{m}$, $p = 100000\\,\\mathrm{Pa}$, $\\mu = 0.3$, $v_s = 0.05\\,\\mathrm{m}/\\mathrm{s}$, $\\omega = 0.0\\,\\mathrm{rad}/\\mathrm{s}$, $T = 1.0\\,\\mathrm{s}$。\n\n您的程序必须：\n- 为每个案例计算 $F_N = p \\cdot (2\\pi r b)$。\n- 为每个案例计算如上定义的 $W_{\\mathrm{obj}}$ 和 $W_{\\mathrm{no}}$。\n- 所有功值以 $\\mathrm{J}$ 为单位表示，并四舍五入到六位小数。\n- 生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n  - $[W_{\\mathrm{obj}}^{A}, W_{\\mathrm{no}}^{A}, W_{\\mathrm{obj}}^{B}, W_{\\mathrm{no}}^{B}, W_{\\mathrm{obj}}^{C}, W_{\\mathrm{no}}^{C}, W_{\\mathrm{obj}}^{D}, W_{\\mathrm{no}}^{D}]$。\n\n为覆盖性而设计：\n- 案例 A 代表一个没有特殊对称性的通用旋转滑动方向。\n- 案例 B 是一个边界条件，在此条件下，非客观累积会产生最大的抵消误差。\n- 案例 C 是一个边缘案例，其中参考系旋转非常慢，两种方法的结果几乎一致。\n- 案例 D 是一个滑动方向恒定的极限情况，此时两种方法的结果必须完全一致。\n\n不要读取任何输入；所有参数均按上述规定固定。输出必须是确定性的和可复现的。", "solution": "该问题要求比较两种计算摩擦功的方法，以证明客观性在数值算法中的重要性。该问题在科学上植根于经典力学和摩擦学，基于标准模型（库仑摩擦）和基本原理（机械功、客观性），提出了一个定义明确的计算任务。\n\n首先，我们确定基本的物理量。总法向力 $F_N$ 是均匀压力 $p$ 和接触面积 $A = 2\\pi r b$ 的乘积。因此，\n$$F_N = 2 \\pi p r b$$\n滑动过程中的摩擦力大小是恒定的，由库仑摩擦定律给出：\n$$F_T = \\mu F_N$$\n\n物理上正确的累积摩擦功，代表总耗散能量，是摩擦功率在时间区间上的积分。增量功 $\\mathrm{d}W$ 是摩擦力大小 $F_T$ 和增量滑动距离 $\\mathrm{d}s = \\|\\mathrm{d}\\boldsymbol{u}_t\\|$ 的乘积。速度大小是恒定的，$\\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| = v_s$，因此在时间增量 $\\mathrm{d}t$ 内的滑动距离是 $\\mathrm{d}s = v_s \\mathrm{d}t$。\n因此，总功 $W$ 是对路径长度的积分：\n$$W = \\int_0^T F_T \\|\\boldsymbol{v}_{\\mathrm{rel}}(t)\\| \\mathrm{d}t = \\int_0^T (\\mu F_N) v_s \\mathrm{d}t = \\mu F_N v_s T$$\n此表达式是耗散功的精确解析解。\n\n让我们分析所提出的两种算法。\n\n**客观增量功累积 ($W_{\\mathrm{obj}}$)**\n该算法在每个步骤 $k$ 计算功增量，并将这些标量增量相加。\n增量滑动矢量为 $\\Delta \\boldsymbol{u}_t^{(k)} = \\boldsymbol{v}_{\\mathrm{rel}}(t_k) \\Delta t$。\n其大小为 $\\|\\Delta \\boldsymbol{u}_t^{(k)}\\| = \\|\\boldsymbol{v}_{\\mathrm{rel}}(t_k)\\| \\Delta t = v_s \\Delta t$，对所有步骤都是恒定的。\n功增量为 $\\Delta W_{\\mathrm{obj}}^{(k)} = \\mu F_N \\|\\Delta \\boldsymbol{u}_t^{(k)}\\| = \\mu F_N v_s \\Delta t$。\n总客观功是这些增量的总和：\n$$W_{\\mathrm{obj}} = \\sum_{k=1}^{M} \\Delta W_{\\mathrm{obj}}^{(k)} = \\sum_{k=1}^{M} \\mu F_N v_s \\Delta t = M (\\mu F_N v_s \\Delta t)$$\n由于总时间为 $T = M \\Delta t$，我们得到：\n$$W_{\\mathrm{obj}} = \\mu F_N v_s T$$\n该算法正确地离散了耗散功率的积分，并得出了精确的物理功，与步数 $M$ 无关。它是“客观的”，因为通过在每一步根据瞬时滑动方向重新计算功增量，它正确地考虑了运动路径，这类似于在有限元模拟中使用协同旋转坐标系。\n\n**非客观累积 ($W_{\\mathrm{no}}$)**\n该算法首先在固定参考系中累积增量滑动矢量，然后基于最终净位移矢量 $\\boldsymbol{s}$ 的大小计算功。\n净位移矢量为 $\\boldsymbol{s} = \\sum_{k=1}^{M} \\Delta \\boldsymbol{u}_t^{(k)} = \\Delta t \\sum_{k=1}^{M} \\boldsymbol{v}_{\\mathrm{rel}}(t_k)$。\n当 $M \\to \\infty$ 时，该和接近于速度矢量的积分：\n$$\\boldsymbol{s} = \\int_{0}^{T} \\boldsymbol{v}_{\\mathrm{rel}}(t) \\mathrm{d}t = v_s \\int_{0}^{T} [\\cos(\\omega t), \\sin(\\omega t)] \\mathrm{d}t$$\n对于 $\\omega \\neq 0$ 的情况，积分得出：\n$$\\boldsymbol{s} = v_s \\left[ \\frac{\\sin(\\omega t)}{\\omega}, -\\frac{\\cos(\\omega t)}{\\omega} \\right]_0^T = \\frac{v_s}{\\omega} [\\sin(\\omega T), 1 - \\cos(\\omega T)]$$\n该矢量的大小为：\n$$\\|\\boldsymbol{s}\\| = \\frac{v_s}{\\omega} \\sqrt{\\sin^2(\\omega T) + (1 - \\cos(\\omega T))^2} = \\frac{v_s}{\\omega} \\sqrt{2 - 2\\cos(\\omega T)}$$\n使用半角恒等式 $1 - \\cos(x) = 2\\sin^2(x/2)$，我们得到：\n$$\\|\\boldsymbol{s}\\| = \\frac{v_s}{\\omega} \\sqrt{4\\sin^2(\\omega T/2)} = \\left| \\frac{2 v_s}{\\omega} \\sin(\\frac{\\omega T}{2}) \\right|$$\n对于 $\\omega = 0$ 的情况，速度是恒定的，$\\boldsymbol{v}_{\\mathrm{rel}}(t) = [v_s, 0]$，积分简化为 $\\boldsymbol{s} = [v_s T, 0]$，其大小为 $\\|\\boldsymbol{s}\\| = v_s T$。\n然后，非客观功计算为 $W_{\\mathrm{no}} = \\mu F_N \\|\\boldsymbol{s}\\|$。\n\n对于任何非直线路径（$\\omega \\neq 0$），该算法在物理上是不正确的。它基于从起点到终点的最短距离位移来计算功，忽略了实际所走的更长路径。根据积分的三角不等式，$\\|\\int \\boldsymbol{v}(t) \\mathrm{d}t\\| \\le \\int \\|\\boldsymbol{v}(t)\\| \\mathrm{d}t$，这意味着 $W_{\\mathrm{no}} \\le W_{\\mathrm{obj}}$。仅当运动方向恒定时（$\\omega = 0$），等号成立。这种未能尊重摩擦功的路径依赖性是未使用客观（协同旋转）参考系进行累积的直接后果。\n\n数值实现将首先为所有案例计算一个公共因子 $\\mu F_N$。然后对每个案例，将使用其简单的解析公式计算 $W_{\\mathrm{obj}}$。将通过数值实现问题陈述中描述的求和来计算 $W_{\\mathrm{no}}$，使用 $M=10^5$ 步以确保高精度。\n\n**计算摘要**\n- 公共参数：$r = 0.2\\,\\mathrm{m}$， $b = 0.01\\,\\mathrm{m}$， $p = 10^5\\,\\mathrm{Pa}$， $\\mu = 0.3$。\n- 法向力：$F_N = 2\\pi (10^5)(0.2)(0.01) = 400\\pi\\,\\mathrm{N}$。\n- 摩擦力大小：$\\mu F_N = 0.3 \\cdot 400\\pi = 120\\pi\\,\\mathrm{N}$。\n- 将对每个参数集（A, B, C, D）执行 $\\{W_{\\mathrm{obj}}, W_{\\mathrm{no}}\\}$ 的特定案例计算。\n- **案例A**（$\\omega=2.0$, $T=1.25$）：$W_{\\mathrm{obj}}$ 非零。$W_{\\mathrm{no}}$ 将显著更小，因为 $\\omega T=2.5$ 是一个相当大的角度。\n- **案例B**（$\\omega=2.0$, $T=\\pi$）：滑动方向完成一次完整旋转（$\\omega T = 2\\pi$）。净位移 $\\boldsymbol{s}$ 为零，因此 $W_{\\mathrm{no}}=0$。这最大程度地说明了非客观方法的误差，因为有显著的功被耗散（$W_{\\mathrm{obj}}  0$），但该算法预测的功为零。\n- **案例C**（$\\omega=0.001$, $T=1.0$）：旋转非常慢。路径近似为一条直线，因此 $W_{\\mathrm{no}}$ 将非常接近 $W_{\\mathrm{obj}}$。\n- **案例D**（$\\omega=0.0$, $T=1.0$）：无旋转。路径是一条直线。两种算法必须得出完全相同的结果，$W_{\\mathrm{no}} = W_{\\mathrm{obj}}$。\n\n实现将遵循这些原则以产生所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares objective vs. non-objective frictional work for a\n    set of test cases involving a spinning slip direction.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General spinning slip\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': 1.25},\n        # Case B: Exactly one full revolution\n        # T is calculated dynamically below.\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 2.0, 'T': -1},\n        # Case C: Very slow spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.001, 'T': 1.0},\n        # Case D: No spin\n        {'r': 0.2, 'b': 0.01, 'p': 100000.0, 'mu': 0.3, 'vs': 0.05, 'omega': 0.0, 'T': 1.0},\n    ]\n\n    # For numerical stability, choose M >= 10^4. We use M = 100,000.\n    M = 100000\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        r = case['r']\n        b = case['b']\n        p = case['p']\n        mu = case['mu']\n        vs = case['vs']\n        omega = case['omega']\n        T = case['T']\n\n        # Special handling for Case B where T depends on omega\n        if T == -1:\n            if omega == 0.0:\n                # Avoid division by zero, although not applicable for given cases.\n                # In such a scenario, the concept of a revolution is ill-defined.\n                # For this problem set, omega is 2.0.\n                T = np.inf\n            else:\n                T = 2.0 * np.pi / omega\n        \n        # Calculate total normal force\n        F_N = p * (2.0 * np.pi * r * b)\n        \n        # --- Objective Work Calculation (W_obj) ---\n        # The objective work is the integral of the scalar power, which is\n        # mu * F_N * vs. Since vs is constant, the integral is simply\n        # W_obj = mu * F_N * vs * T.\n        # This result is independent of the number of steps M.\n        W_obj = mu * F_N * vs * T\n        \n        # --- Non-Objective Work Calculation (W_no) ---\n        # This method accumulates the slip vector in a fixed frame and then\n        # computes the work from the magnitude of the final net vector.\n        dt = T / M\n        slip_vector = np.array([0.0, 0.0])\n        \n        if omega == 0.0:\n            # For the constant direction case, the velocity vector is constant.\n            # v_rel = [vs, 0]. The sum is trivial.\n            slip_vector[0] = vs * T\n        else:\n            # Vectorized computation for the sum is faster than a Python loop.\n            # Create an array of time points t_k = k * dt for k = 1, ..., M.\n            # Note: A mid-point rule (t_k = (k-0.5)*dt) would be slightly more accurate\n            # for the numerical integration, but with M=100k, the difference is negligible.\n            # We follow the problem's implicit forward Euler discretization.\n            k_steps = np.arange(1, M + 1)\n            t_k = k_steps * dt\n            \n            # Compute velocity vectors at each time point\n            cos_vals = np.cos(omega * t_k)\n            sin_vals = np.sin(omega * t_k)\n            \n            # Sum the velocity components\n            sum_vx = np.sum(cos_vals)\n            sum_vy = np.sum(sin_vals)\n\n            # Final slip vector s = sum(v_rel * dt)\n            slip_vector[0] = vs * dt * sum_vx\n            slip_vector[1] = vs * dt * sum_vy\n\n        # Calculate the norm of the total slip vector\n        slip_norm = np.linalg.norm(slip_vector)\n        \n        # Calculate The non-objective work\n        W_no = mu * F_N * slip_norm\n        \n        # Append results, rounded to six decimal places\n        results.append(round(W_obj, 6))\n        results.append(round(W_no, 6))\n\n    # Format the final output string as specified\n    output_str = f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2550801"}]}