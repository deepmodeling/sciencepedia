{"hands_on_practices": [{"introduction": "在实现任何本构模型时，首要步骤是验证其是否遵循基本的物理原理。此实践将指导您通过代码验证超弹性模型最重要的特性之一：材料框架无关性（或称客观性），确保模型在任意刚体旋转下都能给出一致的物理响应。这项测试是保证本构程序正确性的基石 [@problem_id:2545696]。", "problem": "设计并实现一个独立的程序，为有限元法 (FEM) 中使用的本构例程执行软件验证测试。目标是针对可压缩和不可压缩超弹性模型，在第一 Piola–Kirchhoff (PK1) 应力及其切线（PK1 相对于变形梯度的方向导数）的层面上，验证材料框架无关性（客观性）原理。\n\n从以下基本基础开始：\n- 对于材料框架无关的固体，其超弹性应变能密度取决于右 Cauchy–Green 张量 $C = F^{\\mathsf T} F$，即对于容许的 $F$，有 $W(F) = \\widehat{W}(C)$。\n- PK1 应力为 $P(F) = \\dfrac{\\partial W}{\\partial F}(F)$。\n- 在叠加的刚体旋转 $Q \\in \\mathrm{SO}(3)$ 下，材料框架无关性要求对于所有满足 $Q^{\\mathsf T} Q = I$ 和 $\\det Q = 1$ 的真正交矩阵 $Q$，都有 $W(QF) = W(F)$。\n\n您必须实现两种本构模型：\n1. 可压缩 Neo-Hookean 模型，其 Lamé 剪切模量为 $\\mu > 0$，体积模量为 $\\kappa > 0$，应变能密度为\n$$\nW_{\\mathrm{c}}(F) = \\frac{\\mu}{2}\\,(I_1 - 3) - \\mu \\ln J + \\frac{\\kappa}{2}\\,(\\ln J)^2,\n$$\n其中 $I_1 = \\mathrm{tr}(C)$ 且 $J = \\det F$。\n2. 不可压缩 Neo-Hookean 模型，其剪切模量为 $\\mu > 0$，拉格朗日乘子（压力）为 $p \\in \\mathbb{R}$，应变能为 $W_{\\mathrm{inc}}(F) = \\dfrac{\\mu}{2}\\,(I_1 - 3)$，并受约束 $J = 1$（由 $p$ 强制施加）。相应的 PK1 应力取决于 $F$ 和 $p$。\n\n在此基础上，为每个模型推导 PK1 应力的表达式，并实现计算以下内容的例程：\n- 对于可压缩模型，计算任意满足 $J>0$ 的可逆 $F$ 的 $P_{\\mathrm{c}}(F;\\mu,\\kappa)$。\n- 对于不可压缩模型，在固定的 $p$ 下，计算任意满足 $J>0$ 的可逆 $F$ 的 $P_{\\mathrm{inc}}(F;\\mu,p)$。\n\n接下来，推导并使用对于任何 $Q \\in \\mathrm{SO}(3)$ 都必须成立的正确客观性变换恒等式：\n- 对于应力：\n$$\nP(QF) = Q\\,P(F).\n$$\n- 对于切线，使用方向导数进行操作性陈述：令 $A(F)$ 表示四阶切线模量，$H'$ 表示一个任意扰动，则需要验证的恒等式为\n$$\nA(QF) : H' \\;=\\; Q \\,\\big( A(F) : (Q^{\\mathsf T} H') \\big),\n$$\n其中 $X:Y = \\mathrm{d}P(F)[Y]$ 表示切线对扰动的作用。您必须通过中心有限差分方向导数计算 $P(\\cdot)$ 来计算作用 $A(\\cdot):(\\cdot)$，从而数值上验证此恒等式。\n\n您的程序必须：\n- 为两种模型实现应力计算例程。\n- 实现一个函数，该函数给定一个本构例程 $P(\\cdot)$、一个基础变形 $F$ 和一个方向 $H$，使用中心有限差分和一个小步长 $\\varepsilon > 0$ 来返回切线作用 $A(F):H$。\n- 实现一个旋转生成器 $Q(\\boldsymbol{a},\\theta)$，该生成器根据给定的轴 $\\boldsymbol{a} \\in \\mathbb{R}^3$ 和角度 $\\theta$（以弧度为单位），使用标准的轴-角构造法生成旋转，并确保 $Q \\in \\mathrm{SO}(3)$。\n\n需要实现的客观性测试：\n- 应力客观性：计算相对 Frobenius 误差\n$$\ne_{\\mathrm{stress}} = \\frac{\\lVert P(QF) - Q P(F) \\rVert_F}{1 + \\lVert P(F) \\rVert_F}.\n$$\n- 切线客观性：对于测试集中的每个指定扰动 $H'$，计算\n$$\n\\Delta_{\\mathrm{left}} = A(QF):H',\\quad \\Delta_{\\mathrm{right}} = Q\\,[A(F):(Q^{\\mathsf T} H')],\n$$\n并报告测试集上的最大相对 Frobenius 误差，\n$$\ne_{\\mathrm{tangent}} = \\max_{H'} \\frac{\\lVert \\Delta_{\\mathrm{left}} - \\Delta_{\\mathrm{right}} \\rVert_F}{1 + \\lVert \\Delta_{\\mathrm{right}} \\rVert_F}.\n$$\n\n角度必须以弧度处理。所有量均为无量纲；不需要物理单位。\n\n测试套件：\n使用以下四种情况，它们涵盖了一般情况、近不可压缩运动学、纯旋转和一个平凡边界情况。在每种情况下，计算并报告 $e_{\\mathrm{stress}}$ 和 $e_{\\mathrm{tangent}}$，结果为浮点数。\n\n每种情况下使用的通用扰动方向 $H'_k$（三个矩阵）：\n- $H'_1 = \\begin{bmatrix} 0.3  -0.2  0.1 \\\\ 0.05  -0.1  0.0 \\\\ 0.2  0.15  -0.05 \\end{bmatrix}$，\n- $H'_2 = \\begin{bmatrix} -0.25  0.4  0.0 \\\\ 0.0  0.1  -0.3 \\\\ 0.05  -0.2  0.25 \\end{bmatrix}$，\n- $H'_3 = \\begin{bmatrix} 0.0  0.2  -0.1 \\\\ -0.15  0.0  0.35 \\\\ 0.2  -0.05  0.0 \\end{bmatrix}$。\n\n情况 1 (可压缩，一般变形)：\n- $\\mu = 2.3$, $\\kappa = 120.7$,\n- $F = \\begin{bmatrix} 1.2  0.1  0.0 \\\\ 0.0  0.9  0.2 \\\\ 0.0  0.0  1.1 \\end{bmatrix}$，\n- 旋转轴 $\\boldsymbol{a} = (0.3,\\,0.7,\\,0.2)$，角度 $\\theta = 0.65$。\n\n情况 2 (不可压缩, $J$ 接近 $1$)：\n- $\\mu = 1.9$, $p = 1.7$,\n- $F = \\begin{bmatrix} 1.05  0.02  0.0 \\\\ 0.01  0.98  0.03 \\\\ 0.0  0.02  0.97 \\end{bmatrix}$，\n- 旋转轴 $\\boldsymbol{a} = (-0.2,\\,0.4,\\,0.5)$，角度 $\\theta = 1.1$。\n\n情况 3 (可压缩，纯旋转作为变形梯度)：\n- $\\mu = 5.0$, $\\kappa = 200.0$,\n- $F$ 是由轴 $\\boldsymbol{a} = (0.2,\\,-0.1,\\,0.3)$ 和角度 $\\theta = 0.5$ 生成的旋转矩阵，\n- 叠加的旋转轴 $\\boldsymbol{a} = (0.5,\\,0.2,\\,-0.4)$，角度 $\\theta = 0.8$。\n\n情况 4 (不可压缩，单位变形)：\n- $\\mu = 3.0$, $p = -0.8$,\n- $F = I$,\n- 旋转轴 $\\boldsymbol{a} = (0.1,\\,0.3,\\,0.2)$，角度 $\\theta = 1.3$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由逗号分隔的 8 个浮点数列表，用方括号括起来，顺序为 $[e_{\\mathrm{stress}}^{(1)}, e_{\\mathrm{tangent}}^{(1)}, e_{\\mathrm{stress}}^{(2)}, e_{\\mathrm{tangent}}^{(2)}, e_{\\mathrm{stress}}^{(3)}, e_{\\mathrm{tangent}}^{(3)}, e_{\\mathrm{stress}}^{(4)}, e_{\\mathrm{tangent}}^{(4)}]$，其中上标 $(k)$ 表示情况 $k$。", "solution": "问题陈述已被解析和验证。我们发现它具有科学依据、问题适定、客观且完整。它代表了计算连续介质力学中的一个标准验证程序。其中没有缺陷，因此提供一个解决方案。\n\n任务是验证两种超弹性本构模型（一种可压缩，一种不可压缩）的材料框架无关性（客观性）。这是通过测试第一 Piola-Kirchhoff 应力张量 $P$ 及其相应切线模量的变换性质来实现的。该原理的基础是应变能函数 $W$ 在叠加的刚体旋转下必须保持不变。对于各向同性材料，这意味着 $W$ 可以表示为应变张量（例如右 Cauchy-Green 张量 $C = F^{\\mathsf T} F$）不变量的函数。问题中给出了 $W(F) = \\widehat{W}(C)$。第一 Piola-Kirchhoff 应力张量 $P$ 是应变能密度 $W$ 相对于变形梯度 $F$ 的导数，即 $P = \\dfrac{\\partial W}{\\partial F}$。\n\n为了推导给定模型的 $P$ 的表达式，我们使用链式法则。$W$ 的变分由 $\\delta W = \\dfrac{\\partial \\widehat{W}}{\\partial I_1} \\delta I_1 + \\dfrac{\\partial \\widehat{W}}{\\partial J} \\delta J$ 给出，其中 $I_1 = \\mathrm{tr}(C)$ 和 $J = \\det F$。$I_1$ 和 $J$ 相对于 $F$ 的变分是 $\\delta I_1 = 2F : \\delta F$ 和 $\\delta J = J F^{-\\mathsf{T}} : \\delta F$。由于 $\\delta W = P : \\delta F$，我们可以确定 PK1 应力的通用表达式为：\n$$\nP = 2 \\frac{\\partial \\widehat{W}}{\\partial I_1} F + \\frac{\\partial \\widehat{W}}{\\partial J} J F^{-\\mathsf{T}}\n$$\n\n首先，对于可压缩 Neo-Hookean 模型，其应变能密度为\n$$\nW_{\\mathrm{c}}(F) = \\frac{\\mu}{2}\\,(I_1 - 3) - \\mu \\ln J + \\frac{\\kappa}{2}\\,(\\ln J)^2\n$$\n关于不变量 $I_1$ 和 $J$ 的偏导数是：\n$$\n\\frac{\\partial W_{\\mathrm{c}}}{\\partial I_1} = \\frac{\\mu}{2} \\quad \\text{and} \\quad \\frac{\\partial W_{\\mathrm{c}}}{\\partial J} = -\\frac{\\mu}{J} + \\frac{\\kappa \\ln J}{J}\n$$\n将这些代入 $P$ 的通用表达式，得到可压缩模型的 PK1 应力：\n$$\nP_{\\mathrm{c}}(F) = 2 \\left(\\frac{\\mu}{2}\\right) F + \\left(-\\frac{\\mu}{J} + \\frac{\\kappa \\ln J}{J}\\right) J F^{-\\mathsf{T}} = \\mu F + (\\kappa \\ln J - \\mu) F^{-\\mathsf{T}}\n$$\n\n其次，对于不可压缩 Neo-Hookean 模型，其行为由一个增广能量泛函描述，该泛函通过拉格朗日乘子 $p$ 引入了不可压缩约束 $J=1$：\n$$\n\\Pi(F,p) = \\frac{\\mu}{2}\\,(I_1 - 3) - p\\,(J-1)\n$$\nPK1 应力是该泛函关于 $F$ 的导数。将 $\\Pi$ 视为我们的等效能量函数，其偏导数为：\n$$\n\\frac{\\partial \\Pi}{\\partial I_1} = \\frac{\\mu}{2} \\quad \\text{and} \\quad \\frac{\\partial \\Pi}{\\partial J} = -p\n$$\n将这些代入 $P$ 的通用形式，得到不可压缩模型在给定压力 $p$ 下的 PK1 应力：\n$$\nP_{\\mathrm{inc}}(F,p) = 2 \\left(\\frac{\\mu}{2}\\right) F + (-p) J F^{-\\mathsf{T}} = \\mu F - p J F^{-\\mathsf{T}}\n$$\n对于混合有限元列式，这种形式是标准的，在迭代求解过程中，变形可能暂时导致 $J \\neq 1$。\n\n验证程序实现了这些推导出的应力例程。它还实现了所需的数值工具。旋转矩阵 $Q \\in \\mathrm{SO}(3)$ 是根据轴 $\\boldsymbol{a}$ 和角 $\\theta$ 使用 Rodrigues 旋转公式生成的。首先将轴归一化为 $\\boldsymbol{n} = \\boldsymbol{a} / \\lVert \\boldsymbol{a} \\rVert$。然后旋转矩阵为 $Q = I + (\\sin\\theta)[\\boldsymbol{n}]_\\times + (1-\\cos\\theta)[\\boldsymbol{n}]_\\times^2$，其中 $[\\boldsymbol{n}]_\\times$ 是与 $\\boldsymbol{n}$ 的叉积算子相关的反对称矩阵。\n\n切线模量的作用 $A(F):H = \\mathrm{d}P(F)[H]$，使用二阶精度的中心有限差分格式和一个小步长 $\\varepsilon > 0$ 来近似：\n$$\nA(F):H \\approx \\frac{P(F + \\varepsilon H) - P(F - \\varepsilon H)}{2\\varepsilon}\n$$\n选择 $\\varepsilon = 10^{-7}$ 是为了平衡截断误差和浮点舍入误差。\n\n有了这些组件，就可以执行客观性测试了。\n对于应力客观性，计算相对 Frobenius 误差 $e_{\\mathrm{stress}}$ 来验证 $P(QF) = Q P(F)$：\n$$\ne_{\\mathrm{stress}} = \\frac{\\lVert P(QF) - Q P(F) \\rVert_F}{1 + \\lVert P(F) \\rVert_F}\n$$\n对于切线客观性，程序为一组扰动矩阵 $\\{H'\\}$ 验证恒等式 $A(QF) : H' = Q ( A(F) : (Q^{\\mathsf T} H') )$。计算该集合上的最大相对 Frobenius 误差：\n$$\ne_{\\mathrm{tangent}} = \\max_{H'} \\frac{\\lVert \\Delta_{\\mathrm{left}} - \\Delta_{\\mathrm{right}} \\rVert_F}{1 + \\lVert \\Delta_{\\mathrm{right}} \\rVert_F}\n$$\n其中 $\\Delta_{\\mathrm{left}}$ 和 $\\Delta_{\\mathrm{right}}$ 分别是使用有限差分格式计算的恒等式的左侧和右侧。分母项 $1 + \\lVert \\cdot \\rVert_F$ 确保了在参考应力或切线作用为零的情况下的数值稳定性。程序系统地将这些测试应用于四个指定的情况，并报告由此产生的八个误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_rotation_matrix(axis, angle):\n    \"\"\"\n    Generates a rotation matrix Q in SO(3) from an axis and angle\n    using Rodrigues' rotation formula.\n    \"\"\"\n    a = np.asarray(axis)\n    norm_a = np.linalg.norm(a)\n    if norm_a == 0:\n        return np.eye(3)\n    n = a / norm_a\n    \n    K = np.array([\n        [0, -n[2], n[1]],\n        [n[2], 0, -n[0]],\n        [-n[1], n[0], 0]\n    ])\n    \n    Q = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)\n    return Q\n\ndef P_compressible(F, mu, kappa):\n    \"\"\"\n    Computes the First Piola-Kirchhoff stress for a compressible Neo-Hookean model.\n    P_c(F) = mu*F + (kappa*ln(J) - mu)*F^{-T}\n    \"\"\"\n    J = np.linalg.det(F)\n    if J == 0:\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F + (kappa * np.log(J) - mu) * F_inv_T\n    return P\n\ndef P_incompressible(F, mu, p):\n    \"\"\"\n    Computes the First Piola-Kirchhoff stress for an incompressible Neo-Hookean model.\n    P_inc(F, p) = mu*F - p*J*F^{-T}\n    \"\"\"\n    J = np.linalg.det(F)\n    if J == 0:\n        raise ValueError(\"Deformation gradient must have a positive determinant.\")\n    F_inv_T = np.linalg.inv(F).T\n    P = mu * F - p * J * F_inv_T\n    return P\n\ndef tangent_action(P_func, F, H, eps):\n    \"\"\"\n    Computes the action of the tangent modulus A(F):H using a centered finite difference.\n    A(F):H approx (P(F + eps*H) - P(F - eps*H)) / (2*eps)\n    \"\"\"\n    P_plus = P_func(F + eps * H)\n    P_minus = P_func(F - eps * H)\n    return (P_plus - P_minus) / (2 * eps)\n\ndef run_verification_test(model_type, params, F_base, Q_params, H_primes, eps):\n    \"\"\"\n    Runs objectivity tests for stress and tangent for a single case.\n    \"\"\"\n    # Unpack parameters\n    if model_type == 'compressible':\n        mu, kappa = params\n        P_func = lambda F_arg: P_compressible(F_arg, mu, kappa)\n    elif model_type == 'incompressible':\n        mu, p = params\n        P_func = lambda F_arg: P_incompressible(F_arg, mu, p)\n    else:\n        raise ValueError(\"Unknown model type.\")\n\n    Q_axis, Q_angle = Q_params\n    Q = get_rotation_matrix(Q_axis, Q_angle)\n\n    # Stress objectivity test\n    P_F = P_func(F_base)\n    F_rot = Q @ F_base\n    P_QF = P_func(F_rot)\n    Q_P_F = Q @ P_F\n    \n    e_stress = np.linalg.norm(P_QF - Q_P_F, 'fro') / (1.0 + np.linalg.norm(P_F, 'fro'))\n\n    # Tangent objectivity test\n    tangent_errors_for_case = []\n    for H_prime in H_primes:\n        # Left side: A(QF):H'\n        delta_left = tangent_action(P_func, F_rot, H_prime, eps)\n        \n        # Right side: Q * [A(F) : (Q^T * H')]\n        H = Q.T @ H_prime\n        delta_base = tangent_action(P_func, F_base, H, eps)\n        delta_right = Q @ delta_base\n        \n        err_h = np.linalg.norm(delta_left - delta_right, 'fro') / (1.0 + np.linalg.norm(delta_right, 'fro'))\n        tangent_errors_for_case.append(err_h)\n        \n    e_tangent = max(tangent_errors_for_case)\n    \n    return e_stress, e_tangent\n\ndef solve():\n    \"\"\"\n    Main solver function that defines and runs all test cases.\n    \"\"\"\n    # Common parameters for all tests\n    eps = 1e-7\n    H_primes = [\n        np.array([[0.3, -0.2, 0.1], [0.05, -0.1, 0.0], [0.2, 0.15, -0.05]]),\n        np.array([[-0.25, 0.4, 0.0], [0.0, 0.1, -0.3], [0.05, -0.2, 0.25]]),\n        np.array([[0.0, 0.2, -0.1], [-0.15, 0.0, 0.35], [0.2, -0.05, 0.0]])\n    ]\n\n    # Define test cases\n    F_case3 = get_rotation_matrix(axis=(0.2, -0.1, 0.3), angle=0.5)\n    \n    test_cases = [\n        # Case 1 (compressible, general deformation)\n        {'model_type': 'compressible', 'params': (2.3, 120.7), \n         'F_base': np.array([[1.2, 0.1, 0.0], [0.0, 0.9, 0.2], [0.0, 0.0, 1.1]]), \n         'Q_params': ((0.3, 0.7, 0.2), 0.65)},\n        # Case 2 (incompressible, J near 1)\n        {'model_type': 'incompressible', 'params': (1.9, 1.7), \n         'F_base': np.array([[1.05, 0.02, 0.0], [0.01, 0.98, 0.03], [0.0, 0.02, 0.97]]), \n         'Q_params': ((-0.2, 0.4, 0.5), 1.1)},\n        # Case 3 (compressible, pure rotation F)\n        {'model_type': 'compressible', 'params': (5.0, 200.0), \n         'F_base': F_case3, \n         'Q_params': ((0.5, 0.2, -0.4), 0.8)},\n        # Case 4 (incompressible, identity deformation)\n        {'model_type': 'incompressible', 'params': (3.0, -0.8), \n         'F_base': np.eye(3), \n         'Q_params': ((0.1, 0.3, 0.2), 1.3)}\n    ]\n\n    results = []\n    for case in test_cases:\n        e_stress, e_tangent = run_verification_test(\n            case['model_type'],\n            case['params'],\n            case['F_base'],\n            case['Q_params'],\n            H_primes,\n            eps\n        )\n        results.append(e_stress)\n        results.append(e_tangent)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2545696"}, {"introduction": "将连续的本构关系离散化为有限元是数值模拟的核心挑战之一，尤其是在处理近不可压缩材料时。此练习聚焦于一个关键的单元技术——选择性缩减积分（SRI），通过动手编程来分析和解决完全积分和缩减积分方案中可能出现的体积锁定和沙漏模式问题 [@problem_id:2545811]。掌握这项技术对于开发稳定且精确的低阶单元至关重要。", "problem": "在有限元法 (FEM) 的背景下，考虑一个具有 $8$ 个节点的三维三线性六面体单元（一个 $8$ 节点砖块单元）。该材料为可压缩超弹性 neo-Hookean 材料，分析在未变形构型下进行，并假设为小应变，以允许进行一致性切线线性化。使用虚功原理和超弹性的定义作为基本依据。\n\n从超弹性的虚功原理出发，对于一个占据坐标为 $\\mathbf{X}$ 的参考区域的物体，其内虚功是总应变能的变分。在未变形构型周围的小应变情况下，一致性切线简化为一个各向同性线性映射，其中应变能密度的偏量部分和体积部分是分离的。在此范围内，对于剪切模量 $\\mu$ 和体积模量 $\\kappa$，应力响应算子解耦为一个由 $\\mu$ 加权的偏量部分和一个由 $\\kappa$ 加权的体积部分，作用于小应变张量。您必须使用参考构型下的小应变切线来组装单元刚度矩阵。\n\n设单元占据一个边长为 $L_x$、$L_y$、$L_z$ 且与坐标轴对齐的长方体。位移场使用等参域 $\\{(\\xi,\\eta,\\zeta)\\in[-1,1]^3\\}$ 中的三线性形函数进行插值。使用标准的 $6$ 分量工程应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{11},\\varepsilon_{22},\\varepsilon_{33},\\gamma_{23},\\gamma_{13},\\gamma_{12}]^\\top$，其中当 $i\\neq j$ 时，$\\gamma_{ij} = 2 \\varepsilon_{ij}$。单元刚度为\n$$\n\\mathbf{K} = \\int_{\\Omega_0} \\mathbf{B}^\\top \\mathbf{C} \\,\\mathbf{B}\\, \\mathrm{d}V,\n$$\n其中 $\\mathbf{B}$ 是 $8$ 节点砖块单元的标准应变-位移矩阵，$\\mathbf{C}$ 是未变形状态下的小应变切线，它可以加性分离为一个偏量算子和一个体积算子。\n\n您的任务是实现三种用于组装 $\\mathbf{K}$ 的积分方案：\n- 方案 $\\mathsf{full}$：对体积部分和偏量部分均使用完全积分，采用 $2\\times 2\\times 2$ 个 Gauss 点，点位于 $\\xi,\\eta,\\zeta \\in \\{\\pm 1/\\sqrt{3}\\}$，每个方向上的权重为单位权重。\n- 方案 $\\mathsf{reduced}$：对整个刚度矩阵使用单点减缩积分，采用位于 $(\\xi,\\eta,\\zeta)=(0,0,0)$ 的单个 Gauss 点，每个方向的权重为 $2$（三维空间中总权重为 $8$）。\n- 方案 $\\mathsf{sri}$（选择性减缩积分）：对偏量部分采用方案 $\\mathsf{full}$ 中的完全积分，对体积部分采用方案 $\\mathsf{reduced}$ 中的单点减缩积分。\n\n通过计算自由单元（即无本质边界条件）的组装单元刚度矩阵 $\\mathbf{K}$ 的特征值，分析对沙漏模式的影响。在一致性小应变公式中，刚体运动贡献了零能模式。当减缩积分未能捕捉所有应变模式时，沙漏模式会作为额外的伪零能模式出现。为了量化这一点，设 $\\lambda_i$ 为 $\\mathbf{K}$ 的特征值，并将模小于容差 $\\tau$ 的特征值定义为近似零特征值，其中\n$$\n\\tau = \\max\\left(10^{-7} \\max_i \\lambda_i,\\; 10^{-12}\\right).\n$$\n统计绝对值小于或等于 $\\tau$ 的特征值的数量。\n\n实现一个完整的、可运行的程序，该程序：\n- 对于每种方案，使用在未变形状态下分解为体积和偏量部分的小应变切线以及上述相应的积分规则，构建 $8$ 节点砖块单元的刚度矩阵 $\\mathbf{K}$。\n- 计算 $\\mathbf{K}$ 的特征值，并对每个测试用例，统计近似零特征值的数量，作为零能模式（刚体运动加上可能的沙漏模式）的度量。\n\n最终的整数计数不需要物理输出单位。不涉及角度。所有计算在任何选定的单位制中都必须内部一致。\n\n测试套件：\n- 用例 1：$\\mu = 8.0\\times 10^{4}$，$\\kappa = 1.6\\times 10^{5}$，$L_x=1$，$L_y=1$，$L_z=1$，方案 $\\mathsf{full}$。\n- 用例 2：与用例 1 参数相同，方案 $\\mathsf{reduced}$。\n- 用例 3：与用例 1 参数相同，方案 $\\mathsf{sri}$。\n- 用例 4：$\\mu = 8.0\\times 10^{4}$，$\\kappa = 1.6\\times 10^{5}$，$L_x=2$，$L_y=1$，$L_z=0.5$，方案 $\\mathsf{sri}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[r_1,r_2,r_3,r_4]$），其中 $r_j$ 是按上述顺序列出的测试用例 $j$ 的近似零特征值的整数数量。", "solution": "所述问题具有科学依据、提法恰当、客观，并包含解决该问题所需的所有信息。它代表了有限元法理论与应用中的一个标准和基础练习。我们开始求解。\n\n分析的基础是虚功原理，对于超弹性材料，它表明内虚功是总应变能的变分，即 $\\delta W_{int} = \\delta \\Pi$。刚度矩阵 $\\mathbf{K}$ 关联了节点力与节点位移，并通过应变能势的二阶变分得到。对于单个有限元，这给出了以下表达式：\n$$\n\\mathbf{K} = \\frac{\\partial^2 \\Pi}{\\partial \\mathbf{d}^2} = \\int_{\\Omega_0} \\mathbf{B}^\\top \\mathbf{C} \\mathbf{B} \\, \\mathrm{d}V\n$$\n其中 $\\mathbf{d}$ 是节点位移向量，$\\Omega_0$ 是单元在参考构型中的体积，$\\mathbf{B}$ 是应变-位移矩阵，$\\mathbf{C}$ 是本构切线模量。问题指定了在未变形状态下的小应变公式，此时 $\\mathbf{C}$ 成为标准的各向同性线弹性张量。\n\n求解需要三部分构建：\n1. 本构矩阵 $\\mathbf{C}$ 的公式及其分解。\n2. $8$ 节点六面体单元的应变-位移矩阵 $\\mathbf{B}$ 的公式。\n3. 使用指定的积分方案对刚度矩阵 $\\mathbf{K}$ 进行数值积分。\n最后，对得到的矩阵 $\\mathbf{K}$ 进行特征值分析，以确定零能模式的数量。\n\n**1. 本构矩阵 $\\mathbf{C}$**\n\n对于各向同性线弹性材料，本构矩阵 $\\mathbf{C}$ 将工程应变向量 $\\boldsymbol{\\varepsilon} = [\\varepsilon_{11}, \\varepsilon_{22}, \\varepsilon_{33}, \\gamma_{23}, \\gamma_{13}, \\gamma_{12}]^\\top$ 映射到应力向量 $\\boldsymbol{\\sigma}$。该矩阵由剪切模量 $\\mu$ 和体积模量 $\\kappa$ 定义。\n\n应变能被加性分解为偏量部分和体积部分。这导致本构矩阵的加性分解：$\\mathbf{C} = \\mathbf{C}_{\\text{dev}} + \\mathbf{C}_{\\text{vol}}$。\n\n体积部分与体积应变 $\\varepsilon_v = \\varepsilon_{11} + \\varepsilon_{22} + \\varepsilon_{33}$ 相关。写成向量形式为 $\\varepsilon_v = \\mathbf{m}^\\top \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{m} = [1, 1, 1, 0, 0, 0]^\\top$。本构矩阵的体积部分为：\n$$\n\\mathbf{C}_{\\text{vol}} = \\kappa \\mathbf{m} \\mathbf{m}^\\top = \\kappa \\begin{bmatrix} 1  1  1  0  0  0 \\\\ 1  1  1  0  0  0 \\\\ 1  1  1  0  0  0 \\\\ 0  0  0  0  0  0 \\\\ 0  0  0  0  0  0 \\\\ 0  0  0  0  0  0 \\end{bmatrix}\n$$\n完整的各向同性本构矩阵 $\\mathbf{C}$ 由下式给出：\n$$\n\\mathbf{C} = \\begin{bmatrix} \\kappa + \\frac{4}{3}\\mu  \\kappa - \\frac{2}{3}\\mu  \\kappa - \\frac{2}{3}\\mu  0  0  0 \\\\ \\kappa - \\frac{2}{3}\\mu  \\kappa + \\frac{4}{3}\\mu  \\kappa - \\frac{2}{3}\\mu  0  0  0 \\\\ \\kappa - \\frac{2}{3}\\mu  \\kappa - \\frac{2}{3}\\mu  \\kappa + \\frac{4}{3}\\mu  0  0  0 \\\\ 0  0  0  \\mu  0  0 \\\\ 0  0  0  0  \\mu  0 \\\\ 0  0  0  0  0  \\mu \\end{bmatrix}\n$$\n偏量部分则为 $\\mathbf{C}_{\\text{dev}} = \\mathbf{C} - \\mathbf{C}_{\\text{vol}}$：\n$$\n\\mathbf{C}_{\\text{dev}} = \\mu \\begin{bmatrix} 4/3  -2/3  -2/3  0  0  0 \\\\ -2/3  4/3  -2/3  0  0  0 \\\\ -2/3  -2/3  4/3  0  0  0 \\\\ 0  0  0  1  0  0 \\\\ 0  0  0  0  1  0 \\\\ 0  0  0  0  0  1 \\end{bmatrix}\n$$\n\n**2. 应变-位移矩阵 $\\mathbf{B}$**\n\n位移场 $\\mathbf{u}(\\mathbf{X})$ 通过三线性形函数 $N_i(\\xi, \\eta, \\zeta)$ 从节点位移 $\\mathbf{d}$ 插值得到：\n$$\n\\mathbf{u}(\\xi, \\eta, \\zeta) = \\sum_{i=1}^{8} N_i(\\xi, \\eta, \\zeta) \\mathbf{u}_i\n$$\n节点 $i$ 的形函数，其等参坐标为 $(\\xi_i, \\eta_i, \\zeta_i) \\in \\{-1, 1\\}^3$，表达式为：\n$$\nN_i(\\xi, \\eta, \\zeta) = \\frac{1}{8}(1+\\xi_i\\xi)(1+\\eta_i\\eta)(1+\\zeta_i\\zeta)\n$$\n应变-位移矩阵 $\\mathbf{B}$ 由 $\\boldsymbol{\\varepsilon} = \\mathbf{B}\\mathbf{d}$ 定义。它是一个 $6\\times24$ 的矩阵，由对应于每个节点的 $8$ 个块 $\\mathbf{B}_i$（每个为 $6\\times3$）组成：$\\mathbf{B} = [\\mathbf{B}_1, \\mathbf{B}_2, \\ldots, \\mathbf{B}_8]$。每个块 $\\mathbf{B}_i$ 由形函数 $N_i$ 的空间导数构建：\n$$\n\\mathbf{B}_i = \\begin{bmatrix} \\frac{\\partial N_i}{\\partial x}  0  0 \\\\ 0  \\frac{\\partial Ni_i}{\\partial y}  0 \\\\ 0  0  \\frac{\\partial N_i}{\\partial z} \\\\ 0  \\frac{\\partial N_i}{\\partial z}  \\frac{\\partial N_i}{\\partial y} \\\\ \\frac{\\partial N_i}{\\partial z}  0  \\frac{\\partial N_i}{\\partial x} \\\\ \\frac{\\partial N_i}{\\partial y}  \\frac{\\partial N_i}{\\partial x}  0 \\end{bmatrix}\n$$\n空间导数通过链式法则，使用从等参坐标到物理坐标的映射的 Jacobian 矩阵求得：\n$$\n\\begin{Bmatrix} \\partial N_i/\\partial x \\\\ \\partial N_i/\\partial y \\\\ \\partial N_i/\\partial z \\end{Bmatrix} = \\mathbf{J}^{-1} \\begin{Bmatrix} \\partial N_i/\\partial \\xi \\\\ \\partial N_i/\\partial \\eta \\\\ \\partial N_i/\\partial \\zeta \\end{Bmatrix}\n$$\n对于一个以原点为中心、尺寸为 $L_x, L_y, L_z$ 的长方体，其映射为 $x = L_x\\xi/2, y = L_y\\eta/2, z = L_z\\zeta/2$。Jacobian 矩阵是对角且恒定的：\n$$\n\\mathbf{J} = \\begin{bmatrix} L_x/2  0  0 \\\\ 0  L_y/2  0 \\\\ 0  0  L_z/2 \\end{bmatrix} \\implies \\mathbf{J}^{-1} = \\begin{bmatrix} 2/L_x  0  0 \\\\ 0  2/L_y  0 \\\\ 0  0  2/L_z \\end{bmatrix}\n$$\n积分的体积元为 $\\mathrm{d}V = \\det(\\mathbf{J})\\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta = \\frac{L_x L_y L_z}{8} \\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta$。\n\n**3. 刚度矩阵 $\\mathbf{K}$ 的数值积分**\n\n$\\mathbf{K}$ 的积分使用 Gauss 积分进行数值计算：\n$$\n\\mathbf{K} = \\int_{-1}^1\\int_{-1}^1\\int_{-1}^1 \\mathbf{B}(\\xi,\\eta,\\zeta)^\\top \\mathbf{C} \\mathbf{B}(\\xi,\\eta,\\zeta) \\det(\\mathbf{J}) \\mathrm{d}\\xi\\mathrm{d}\\eta\\mathrm{d}\\zeta \\approx \\sum_{k} w_k \\mathbf{B}(\\xi_k, \\eta_k, \\zeta_k)^\\top \\mathbf{C} \\mathbf{B}(\\xi_k, \\eta_k, \\zeta_k) \\det(\\mathbf{J})\n$$\n其中 $(\\xi_k, \\eta_k, \\zeta_k)$ 是 Gauss 点，$w_k$ 是对应的权重。\n\n- 方案 $\\mathsf{full}$：使用 $2\\times2\\times2$ 的 Gauss 积分。共有 $8$ 个点，位于 $(\\xi, \\eta, \\zeta) \\in \\{\\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}, \\pm 1/\\sqrt{3}\\}$，每个点的权重 $w_k=1$。该规则足以精确积分矩形单元的刚度矩阵。预计将产生 $6$ 个零能模式，对应于 $3$ 个刚体平移和 $3$ 个刚体旋转。\n\n- 方案 $\\mathsf{reduced}$：对整个矩阵使用位于 $(\\xi, \\eta, \\zeta)=(0,0,0)$ 的单个 Gauss 点，权重 $w_k=8$。该方案计算效率高，但无法检测到某些在单元中心产生零应变的变形模式（沙漏模式）。对于一个 $8$ 节点砖块单元，这会导致在 $6$ 个刚体模式之外，额外产生 $5$ 个伪零能模式，总计 $11$ 个。\n\n- 方案 $\\mathsf{sri}$（选择性减缩积分）：刚度矩阵被分解为：$\\mathbf{K} = \\mathbf{K}_{\\text{dev}} + \\mathbf{K}_{\\text{vol}}$。\n  - $\\mathbf{K}_{\\text{dev}} = \\int \\mathbf{B}^\\top \\mathbf{C}_{\\text{dev}} \\mathbf{B} \\,\\mathrm{d}V$ 使用 `full` 的 $2\\times2\\times2$ 方案进行积分。\n  - $\\mathbf{K}_{\\text{vol}} = \\int \\mathbf{B}^\\top \\mathbf{C}_{\\text{vol}} \\mathbf{B} \\,\\mathrm{d}V$ 使用 `reduced` 的单点方案进行积分。\n该技术用于防止近不可压缩材料中的体积锁定，同时保持足够的秩来抵抗沙漏。偏量部分的完全积分为剪切沙漏模式提供了刚度。预计该方案将只产生 $6$ 个真实的刚体零能模式。\n\n**4. 特征值分析**\n\n在为每个情况组装好 $\\mathbf{K}$ 后，计算其特征值 $\\lambda_i$。近似零特征值的数量对应于零能模式的数量。如果一个特征值的模小于容差 $\\tau = \\max(10^{-7} \\max_i \\lambda_i, 10^{-12})$，则认为该特征值为近似零。这种双重相对/绝对容差能从浮点计算中正确识别数值零点。矩阵 $\\mathbf{K}$ 是对称半正定的，因此其特征值为实数且非负。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function that orchestrates the FEM analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: mu, kappa, Lx, Ly, Lz, scheme\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'full'),\n        # Case 2\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'reduced'),\n        # Case 3\n        (8.0e4, 1.6e5, 1.0, 1.0, 1.0, 'sri'),\n        # Case 4\n        (8.0e4, 1.6e5, 2.0, 1.0, 0.5, 'sri'),\n    ]\n\n    results = []\n    for mu, kappa, Lx, Ly, Lz, scheme in test_cases:\n        K = assemble_stiffness_matrix(mu, kappa, Lx, Ly, Lz, scheme)\n        \n        # Eigenvalue analysis\n        # K is symmetric, use eigvalsh for efficiency and stability\n        eigenvalues = np.linalg.eigvalsh(K)\n        \n        # As K is positive-semidefinite, max(abs(lambda)) is just the max eigenvalue.\n        max_eig = eigenvalues[-1]\n        tolerance = max(1e-7 * max_eig, 1e-12)\n        \n        # Count near-zero eigenvalues\n        zero_modes_count = np.sum(eigenvalues = tolerance)\n        results.append(zero_modes_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef get_constitutive_matrices(mu, kappa):\n    \"\"\"\n    Constructs the deviatoric and volumetric parts of the constitutive matrix C.\n    \"\"\"\n    C_vol = np.zeros((6, 6))\n    m = np.array([1.0, 1.0, 1.0, 0.0, 0.0, 0.0])\n    C_vol = kappa * np.outer(m, m)\n\n    C_dev = np.zeros((6, 6))\n    C_dev[0, 0] = C_dev[1, 1] = C_dev[2, 2] = 4.0 / 3.0 * mu\n    C_dev[0, 1] = C_dev[1, 0] = C_dev[0, 2] = C_dev[2, 0] = C_dev[1, 2] = C_dev[2, 1] = -2.0 / 3.0 * mu\n    C_dev[3, 3] = C_dev[4, 4] = C_dev[5, 5] = mu\n    \n    return C_dev, C_vol\n\ndef get_shape_func_derivatives(xi, eta, zeta, node_iso_coords):\n    \"\"\"\n    Computes derivatives of 8-node hex shape functions w.r.t. isoparametric coordinates.\n    \"\"\"\n    dN_dxi_eta_zeta = np.zeros((8, 3))\n    for i in range(8):\n        xi_i, eta_i, zeta_i = node_iso_coords[i]\n        dN_dxi_eta_zeta[i, 0] = 0.125 * xi_i * (1 + eta_i * eta) * (1 + zeta_i * zeta)\n        dN_dxi_eta_zeta[i, 1] = 0.125 * eta_i * (1 + xi_i * xi) * (1 + zeta_i * zeta)\n        dN_dxi_eta_zeta[i, 2] = 0.125 * zeta_i * (1 + xi_i * xi) * (1 + eta_i * eta)\n    return dN_dxi_eta_zeta\n\ndef get_B_matrix(dN_dxi_eta_zeta, Lx, Ly, Lz):\n    \"\"\"\n    Constructs the strain-displacement matrix B.\n    \"\"\"\n    J_inv_diag = np.array([2.0 / Lx, 2.0 / Ly, 2.0 / Lz])\n    dN_dxyz = dN_dxi_eta_zeta @ np.diag(J_inv_diag)\n\n    B = np.zeros((6, 24))\n    for i in range(8):\n        # Derivatives for node i in x, y, z\n        dN_dx_i = dN_dxyz[i, 0]\n        dN_dy_i = dN_dxyz[i, 1]\n        dN_dz_i = dN_dxyz[i, 2]\n        \n        # Populate the B matrix for node i (columns 3*i, 3*i+1, 3*i+2)\n        B[0, 3 * i] = dN_dx_i\n        B[1, 3 * i + 1] = dN_dy_i\n        B[2, 3 * i + 2] = dN_dz_i\n        B[3, 3 * i + 1] = dN_dz_i\n        B[3, 3 * i + 2] = dN_dy_i\n        B[4, 3 * i] = dN_dz_i\n        B[4, 3 * i + 2] = dN_dx_i\n        B[5, 3 * i] = dN_dy_i\n        B[5, 3 * i + 1] = dN_dx_i\n        \n    return B\n\ndef assemble_stiffness_matrix(mu, kappa, Lx, Ly, Lz, scheme):\n    \"\"\"\n    Assembles the element stiffness matrix K using the specified quadrature scheme.\n    \"\"\"\n    K = np.zeros((24, 24))\n    det_J = Lx * Ly * Lz / 8.0\n\n    # Isoparametric coordinates of the 8 nodes\n    node_iso_coords = np.array([\n        [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],\n        [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]\n    ])\n\n    C_dev, C_vol = get_constitutive_matrices(mu, kappa)\n\n    # Define Gauss quadrature points and weights\n    a = 1.0 / np.sqrt(3.0)\n    gp_8pt = [\n        (-a, -a, -a), ( a, -a, -a), ( a,  a, -a), (-a,  a, -a),\n        (-a, -a,  a), ( a, -a,  a), ( a,  a,  a), (-a,  a,  a)\n    ]\n    w_8pt = [1.0] * 8\n\n    gp_1pt = [(0.0, 0.0, 0.0)]\n    w_1pt = [8.0]\n\n    if scheme == 'full':\n        C = C_dev + C_vol\n        for i, (xi, eta, zeta) in enumerate(gp_8pt):\n            dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n            B = get_B_matrix(dN, Lx, Ly, Lz)\n            K += w_8pt[i] * B.T @ C @ B * det_J\n\n    elif scheme == 'reduced':\n        C = C_dev + C_vol\n        xi, eta, zeta = gp_1pt[0]\n        dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n        B = get_B_matrix(dN, Lx, Ly, Lz)\n        K += w_1pt[0] * B.T @ C @ B * det_J\n\n    elif scheme == 'sri':\n        # Deviatoric part with full integration\n        K_dev = np.zeros((24, 24))\n        for i, (xi, eta, zeta) in enumerate(gp_8pt):\n            dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n            B = get_B_matrix(dN, Lx, Ly, Lz)\n            K_dev += w_8pt[i] * B.T @ C_dev @ B * det_J\n        \n        # Volumetric part with reduced integration\n        K_vol = np.zeros((24, 24))\n        xi, eta, zeta = gp_1pt[0]\n        dN = get_shape_func_derivatives(xi, eta, zeta, node_iso_coords)\n        B = get_B_matrix(dN, Lx, Ly, Lz)\n        K_vol += w_1pt[0] * B.T @ C_vol @ B * det_J\n        \n        K = K_dev + K_vol\n        \n    return K\n\n# Execute the solver\nsolve()\n```", "id": "2545811"}, {"introduction": "即使本构和单元层面都已验证，我们仍需确保整个求解器能够精确地求解控制偏微分方程。此实践将引导您使用强大的代码验证技术——“制造解方法”（Method of Manufactured Solutions, MMS），为不可压缩超弹性问题构造一个解析解。通过检查数值解与该精确解的吻合程度，我们可以量化验证整个有限元程序的正确性与收敛阶 [@problem_id:2545834]。", "problem": "要求您为平面应变不可压缩超弹性问题设计并验证一个制造解，该解适用于使用制造解方法 (MMS) 进行代码验证。验证应在强形式层面完全解析，并必须实现为一个完整的、可运行的程序。重点是推导出正确的体力，使预设的等容运动和压力场满足线性动量平衡和不可压缩约束。该程序必须测试几组参数集，每组参数集都具有非平凡且独特的压力场和等容运动，并报告每个测试是否通过指定的容差。不需要进行有限元离散化；相反，算法必须在指定点检查解析残差。\n\n从以下基本定义和原理开始：\n- 不可压缩 neo-Hookean 固体的第一 Piola–Kirchhoff 应力由 $ \\mathbf{P} = \\mu \\mathbf{F} - p \\mathbf{F}^{-T} $ 给出，其中 $ \\mu $ 是剪切模量，$ \\mathbf{F} = \\dfrac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}} $ 是变形梯度，$ p $ 是强制实现不可压缩性的拉格朗日乘子（压力）。\n- 参考构型中的静态线性动量平衡要求 $ \\operatorname{Div} \\mathbf{P} + \\mathbf{b} = \\mathbf{0} $，其中 $ \\mathbf{b} $ 是单位参考体积的体力。\n- 不可压缩约束为 $ J = \\det \\mathbf{F} = 1 $。\n\n使用具有恒定变形梯度 $ \\mathbf{F} $（因此 $ \\det \\mathbf{F} = 1 $ 恒成立）和空间变化的压力场 $ p(\\boldsymbol{X}) $ 来构造制造解。这导致由压力梯度驱动的动量平衡中出现非平凡的残差。具体而言，使制造解精确成立所需的体力必须满足\n$$\n\\mathbf{b}(\\boldsymbol{X}) = \\mathbf{F}^{-T} \\nabla p(\\boldsymbol{X}),\n$$\n从而使得 $ \\operatorname{Div} \\mathbf{P} + \\mathbf{b} = \\mathbf{0} $ 逐点成立，因为当 $ \\mathbf{F} $ 为常数时，$ \\operatorname{Div}(\\mu \\mathbf{F}) = \\mu \\operatorname{Div} \\mathbf{F} = \\mathbf{0} $。\n\n在参考域 $ \\Omega = [0,1] \\times [0,1] $ 上，于平面应变条件下进行二维计算，坐标为 $ \\boldsymbol{X} = (X_1, X_2) $。使用两种类型的等容运动：\n- 简单剪切，剪切参数为 $ k \\in \\mathbb{R} $：\n$$\n\\boldsymbol{x}(\\boldsymbol{X}) = \\begin{bmatrix} X_1 + k X_2 \\\\ X_2 \\end{bmatrix}, \\quad \\mathbf{F} = \\begin{bmatrix} 1  k \\\\ 0  1 \\end{bmatrix}, \\quad \\det \\mathbf{F} = 1.\n$$\n- 恒定角度 $ \\theta $ 的刚性旋转（角度单位：弧度）：\n$$\n\\boldsymbol{x}(\\boldsymbol{X}) = \\mathbf{R}(\\theta) \\boldsymbol{X}, \\quad \\mathbf{F} = \\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos \\theta  -\\sin \\theta \\\\ \\sin \\theta  \\cos \\theta \\end{bmatrix}, \\quad \\det \\mathbf{F} = 1.\n$$\n\n对于每个制造解，定义压力场 $ p(\\boldsymbol{X}) $ 并根据 $ \\mathbf{b}(\\boldsymbol{X}) = \\mathbf{F}^{-T} \\nabla p(\\boldsymbol{X}) $ 计算体力 $ \\mathbf{b}(\\boldsymbol{X}) $。然后，在一组预设点 $ \\{ \\boldsymbol{X}^{(m)} \\} $ 上验证以下两个条件均成立：\n- 动量残差：$ \\boldsymbol{r}(\\boldsymbol{X}^{(m)}) = \\operatorname{Div} \\mathbf{P}(\\boldsymbol{X}^{(m)}) + \\mathbf{b}(\\boldsymbol{X}^{(m)}) = \\boldsymbol{0} $。\n- 体积约束残差：$ c = \\det \\mathbf{F} - 1 = 0 $。\n\n您的程序必须：\n- 对于每个测试用例，计算指定点上动量残差 $ \\|\\boldsymbol{r}(\\boldsymbol{X}^{(m)})\\|_2 $ 的最大欧几里得范数，以及体积约束残差 $ |c| $ 的绝对值（由于 $ \\mathbf{F} $ 是常数，该值为常数）。\n- 如果 $ \\max_m \\|\\boldsymbol{r}(\\boldsymbol{X}^{(m)})\\|_2 \\leq T_{\\mathrm{eq}} $ 且 $ |c| \\leq T_{J} $ 成立（其中 $ T_{\\mathrm{eq}} = 10^{-10} $ 且 $ T_J = 10^{-12} $），则声明该测试用例通过。\n- 将所有用例的通过/失败结果聚合为一个布尔值列表，并按下述格式单行打印。\n\n角度单位要求：所有角度 $ \\theta $ 均以弧度为单位。\n\n测试套件：\n- 用例 $ 1 $（简单剪切）：$ k = 0.6 $，$ \\mu = 1.7 $，$ p(\\boldsymbol{X}) = \\sin(\\pi X_1)\\cos(2\\pi X_2) $。点 $ \\{ \\boldsymbol{X}^{(m)} \\} $ 为均匀网格 $ \\{ (0,0),(0,0.5),(0,1),(0.5,0),(0.5,0.5),(0.5,1),(1,0),(1,0.5),(1,1) \\} $。\n- 用例 $ 2 $（旋转）：$ \\theta = 0.8 $，$ \\mu = 3.0 $，$ p(\\boldsymbol{X}) = \\exp(X_1 + 2 X_2) $。点 $ \\{ \\boldsymbol{X}^{(m)} \\} = \\{ (0,0),(1,0),(0,1),(1,1),(0.25,0.75) \\} $。\n- 用例 $ 3 $（简单剪切，高剪切）：$ k = 10.0 $，$ \\mu = 5.0 $，$ p(\\boldsymbol{X}) = X_1^3 - 2 X_1 X_2 + X_2^2 $。点 $ \\{ \\boldsymbol{X}^{(m)} \\} = \\{ (0.1,0.2),(0.6,0.4),(0.9,0.9),(0.0,1.0) \\} $。\n- 用例 $ 4 $（旋转，零压力）：$ \\theta = -1.2 $，$ \\mu = 0.7 $，$ p(\\boldsymbol{X}) \\equiv 0 $。点 $ \\{ \\boldsymbol{X}^{(m)} \\} = \\{ (0.3,0.7),(0.8,0.2),(0.0,0.0),(1.0,1.0) \\} $。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表（例如，“[True,False,True,True]”），按顺序对应于用例 1 到 4 的结果。", "solution": "该问题要求为二维、平面应变、不可压缩超弹性问题设计并验证制造解。验证将在控制偏微分方程（即静态线性动量平衡和不可压缩约束）的层面上进行解析分析。\n\n该分析的基础是以下原理。材料响应由不可压缩 neo-Hookean 模型描述，其第一 Piola-Kirchhoff 应力张量 $ \\mathbf{P} $ 由下式给出：\n$$\n\\mathbf{P} = \\mu \\mathbf{F} - p \\mathbf{F}^{-T}\n$$\n在这里，$ \\mu $ 是恒定的剪切模量，$ \\mathbf{F} $ 是变形梯度，$ p $ 是拉格朗日乘子场（通常解释为压力），用于强制实现不可压缩约束。变形梯度的定义为 $ \\mathbf{F} = \\dfrac{\\partial \\boldsymbol{x}}{\\partial \\boldsymbol{X}} $，其中 $ \\boldsymbol{x} $ 是参考构型中位于 $ \\boldsymbol{X} $ 的物质点在当前构型中的位置。\n\n该系统必须在参考域 $ \\Omega $ 中满足两个基本方程。首先，静态线性动量平衡要求应力的散度与单位参考体积的体力 $ \\mathbf{b} $ 相平衡：\n$$\n\\operatorname{Div} \\mathbf{P} + \\mathbf{b} = \\mathbf{0}\n$$\n其次，材料是不可压缩的，这在变形上施加了一个运动学约束，表示为变形梯度的行列式为 1：\n$$\nJ = \\det \\mathbf{F} = 1\n$$\n这是一种等容（保持体积）的运动。\n\n制造解方法 (MMS) 包括预设一个解场，然后计算所需的源项（在本例中为体力 $ \\mathbf{b} $），以使这些场成为控制方程的精确解。对于此问题，我们选择一个恒定的变形梯度 $ \\mathbf{F} $，使其恒满足不可压缩约束 $ \\det \\mathbf{F} = 1 $。我们还预设一个空间变化的压力场 $ p(\\boldsymbol{X}) $。\n\n对于恒定的 $ \\mathbf{F} $，应力张量中的项 $ \\mu \\mathbf{F} $ 的散度为零：$ \\operatorname{Div}(\\mu \\mathbf{F}) = \\mathbf{0} $。因此，动量方程得以简化。应力中与压力相关的部分的散度计算如下：\n$$\n(\\operatorname{Div} (-p \\mathbf{F}^{-T}))_i = -\\frac{\\partial}{\\partial X_J} (p (F^{-T})_{iJ})\n$$\n由于 $ \\mathbf{F} $ 是恒定的，$ \\mathbf{F}^{-T} $ 也是恒定的，从而得到：\n$$\n(\\operatorname{Div} (-p \\mathbf{F}^{-T}))_i = -(F^{-T})_{iJ} \\frac{\\partial p}{\\partial X_J}\n$$\n用矢量表示法，这即是 $ - \\mathbf{F}^{-T} \\nabla p $。动量平衡方程 $ \\operatorname{Div} \\mathbf{P} + \\mathbf{b} = \\mathbf{0} $ 变为：\n$$\n- \\mathbf{F}^{-T} \\nabla p(\\boldsymbol{X}) + \\mathbf{b}(\\boldsymbol{X}) = \\mathbf{0}\n$$\n由此，我们推导出满足该方程所必需的体力：\n$$\n\\mathbf{b}(\\boldsymbol{X}) = \\mathbf{F}^{-T} \\nabla p(\\boldsymbol{X})\n$$\n解析验证过程包括确认在使用此制造体力时，控制方程的残差为零。动量残差 $ \\boldsymbol{r} $ 和体积约束残差 $ c $ 定义为：\n$$\n\\boldsymbol{r}(\\boldsymbol{X}) = \\operatorname{Div} \\mathbf{P}(\\boldsymbol{X}) + \\mathbf{b}(\\boldsymbol{X})\n$$\n$$\nc = \\det \\mathbf{F} - 1\n$$\n根据构造，两个残差都必须恒为零。\n$ \\boldsymbol{r}(\\boldsymbol{X}) = (-\\mathbf{F}^{-T} \\nabla p) + (\\mathbf{F}^{-T} \\nabla p) = \\mathbf{0} $。\n$ c = 1 - 1 = 0 $，因为我们选择了等容变形。\n\n实现部分将针对四个不同的用例测试此解析结果。对于每个用例，我们计算恒定的变形梯度 $ \\mathbf{F} $ 及其逆转置 $ \\mathbf{F}^{-T} $。然后，对于一组指定的点 $ \\{ \\boldsymbol{X}^{(m)} \\} $，我们计算压力的解析梯度 $ \\nabla p(\\boldsymbol{X}^{(m)}) $、所需的体力 $ \\mathbf{b}(\\boldsymbol{X}^{(m)}) $ 以及应力的散度 $ \\operatorname{Div} \\mathbf{P}(\\boldsymbol{X}^{(m)}) $。数值评估必须确认动量残差 $ \\boldsymbol{r}(\\boldsymbol{X}^{(m)}) $ 和体积约束残差 $ c $ 在指定的数值容差 $ T_{\\mathrm{eq}} = 10^{-10} $ 和 $ T_J = 10^{-12} $ 范围之内为零。只有当两个条件都满足时，测试用例才算通过。\n\n具体的变形映射是简单剪切和刚性旋转。\n对于参数为 $ k $ 的简单剪切：\n$$\n\\mathbf{F} = \\begin{bmatrix} 1  k \\\\ 0  1 \\end{bmatrix}, \\quad \\mathbf{F}^{-1} = \\begin{bmatrix} 1  -k \\\\ 0  1 \\end{bmatrix}, \\quad \\mathbf{F}^{-T} = \\begin{bmatrix} 1  0 \\\\ -k  1 \\end{bmatrix}\n$$\n对于角度为 $ \\theta $ 的刚性旋转：\n$$\n\\mathbf{F} = \\mathbf{R}(\\theta) = \\begin{bmatrix} \\cos \\theta  -\\sin \\theta \\\\ \\sin \\theta  \\cos \\theta \\end{bmatrix}\n$$\n由于旋转矩阵是正交的，因此 $ \\mathbf{F}^{-1} = \\mathbf{F}^T $，这意味着 $ \\mathbf{F}^{-T} = (\\mathbf{F}^T)^{-T} = \\mathbf{F} $。\n对于每个用例，解析计算压力梯度 $ \\nabla p $ 并用其计算残差。然后，将测试点上动量残差的最大范数和恒定的体积残差分别与其各自的容差进行比较，以确定通过/失败状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and verifies manufactured solutions for plane-strain incompressible\n    hyperelasticity.\n    \"\"\"\n\n    T_eq = 1e-10\n    T_J = 1e-12\n\n    test_cases = [\n        {\n            \"type\": \"shear\",\n            \"param\": 0.6,\n            \"mu\": 1.7,\n            \"p_func\": lambda X: np.sin(np.pi * X[0]) * np.cos(2 * np.pi * X[1]),\n            \"grad_p_func\": lambda X: np.array([\n                np.pi * np.cos(np.pi * X[0]) * np.cos(2 * np.pi * X[1]),\n                -2 * np.pi * np.sin(np.pi * X[0]) * np.sin(2 * np.pi * X[1])\n            ]),\n            \"points\": [\n                (0.0, 0.0), (0.0, 0.5), (0.0, 1.0),\n                (0.5, 0.0), (0.5, 0.5), (0.5, 1.0),\n                (1.0, 0.0), (1.0, 0.5), (1.0, 1.0)\n            ]\n        },\n        {\n            \"type\": \"rotation\",\n            \"param\": 0.8,\n            \"mu\": 3.0,\n            \"p_func\": lambda X: np.exp(X[0] + 2 * X[1]),\n            \"grad_p_func\": lambda X: np.array([\n                np.exp(X[0] + 2 * X[1]),\n                2 * np.exp(X[0] + 2 * X[1])\n            ]),\n            \"points\": [(0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (1.0, 1.0), (0.25, 0.75)]\n        },\n        {\n            \"type\": \"shear\",\n            \"param\": 10.0,\n            \"mu\": 5.0,\n            \"p_func\": lambda X: X[0]**3 - 2 * X[0] * X[1] + X[1]**2,\n            \"grad_p_func\": lambda X: np.array([\n                3 * X[0]**2 - 2 * X[1],\n                -2 * X[0] + 2 * X[1]\n            ]),\n            \"points\": [(0.1, 0.2), (0.6, 0.4), (0.9, 0.9), (0.0, 1.0)]\n        },\n        {\n            \"type\": \"rotation\",\n            \"param\": -1.2,\n            \"mu\": 0.7,\n            \"p_func\": lambda X: 0.0,\n            \"grad_p_func\": lambda X: np.array([0.0, 0.0]),\n            \"points\": [(0.3, 0.7), (0.8, 0.2), (0.0, 0.0), (1.0, 1.0)]\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        case_type = case[\"type\"]\n        param = case[\"param\"]\n        grad_p_func = case[\"grad_p_func\"]\n        points = case[\"points\"]\n\n        # 1. Define deformation gradient F\n        if case_type == 'shear':\n            k = param\n            F = np.array([[1.0, k], [0.0, 1.0]])\n        elif case_type == 'rotation':\n            theta = param\n            c, s = np.cos(theta), np.sin(theta)\n            F = np.array([[c, -s], [s, c]])\n        else:\n            raise ValueError(f\"Unknown case type: {case_type}\")\n\n        # 2. Compute volume constraint residual c\n        c = np.linalg.det(F) - 1.0\n        is_volume_ok = abs(c) = T_J\n\n        # 3. Compute F inverse transpose\n        F_inv_T = np.linalg.inv(F).T\n\n        # 4. Compute momentum residuals at all points\n        max_r_norm = 0.0\n        for point_coords in points:\n            X = np.array(point_coords)\n            \n            # Calculate manufactured body force b\n            grad_p = grad_p_func(X)\n            b = F_inv_T @ grad_p\n            \n            # Since F is constant, Div(mu*F) = 0.\n            # Div(P) = Div(mu*F - p*F^-T) = -Div(p*F^-T)\n            # Div(p*F^-T) = F^-T * grad(p) + p*Div(F^-T). Since F^-T is constant, Div(F^-T)=0.\n            # So, Div(P) = -F^-T * grad(p)\n            div_P = -F_inv_T @ grad_p\n\n            # Momentum residual r = Div(P) + b\n            r = div_P + b\n            \n            r_norm = np.linalg.norm(r)\n            if r_norm > max_r_norm:\n                max_r_norm = r_norm\n\n        # 5. Check momentum residual against tolerance\n        is_momentum_ok = max_r_norm = T_eq\n\n        # 6. Aggregate results\n        results.append(is_volume_ok and is_momentum_ok)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2545834"}]}