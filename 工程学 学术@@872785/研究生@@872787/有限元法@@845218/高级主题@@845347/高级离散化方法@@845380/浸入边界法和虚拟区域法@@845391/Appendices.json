{"hands_on_practices": [{"introduction": "在浸入边界法和虚拟区域法中，一个核心的数值挑战是如何在被界面任意切割的背景网格单元上精确地进行积分。本练习将通过矩匹配法（method of moments）来构建一个能够对特定多项式空间精确积分的求积法则。掌握这项技术对于保证计算精度和开发稳健的浸入方法实现至关重要 [@problem_id:2567751]。", "problem": "在一个浸入边界 (IB) 和虚拟区域 (FD) 有限元环境中，考虑一个背景单元 $E = [0,1] \\times [0,1]$，它被一个光滑界面切割。该界面由水平集函数 $\\phi(x,y) = x + y - \\frac{3}{5}$ 隐式描述。占据 $E$ 中一部分的物理子域为 $K^{-} := \\{(x,y) \\in E \\,\\mid\\, \\phi(x,y) \\lt 0\\}$。\n\n您的任务是，从第一性原理出发，在 $K^{-}$ 上构建一个矩拟合求积法则，该法则对所有总次数最高为 $2$ 的多项式都是精确的。在被切割的多边形 $K^{-}$ 上（对于此 $\\phi$ 函数，它是一个顶点在坐标轴上的直角三角形），使用以下节点集：\n- 三个顶点 $A=(0,0)$、$B=\\left(\\frac{3}{5},0\\right)$ 和 $C=\\left(0,\\frac{3}{5}\\right)$。\n- 三个边中点 $M_{AB}=\\left(\\frac{3}{10},0\\right)$、$M_{BC}=\\left(\\frac{3}{10},\\frac{3}{10}\\right)$ 和 $M_{CA}=\\left(0,\\frac{3}{10}\\right)$。\n\n设相关的未知权重分别为 $w_A$、$w_B$、$w_C$、$w_{AB}$、$w_{BC}$ 和 $w_{CA}$。对六个单项式 $\\{1, x, y, x^{2}, xy, y^{2}\\}$ 在 $K^{-}$ 上的求积施加精确性条件，以唯一确定这些权重。\n\n请以精确形式的单行矩阵 $\\bigl(w_A,\\, w_B,\\, w_C,\\, w_{AB},\\, w_{BC},\\, w_{CA}\\bigr)$ 提供您的最终答案。无需四舍五入，也不涉及单位。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n逐字提取已知条件如下：\n- 背景单元：$E = [0,1] \\times [0,1]$。\n- 界面水平集函数：$\\phi(x,y) = x + y - \\frac{3}{5}$。\n- 物理子域：$K^{-} := \\{(x,y) \\in E \\,\\mid\\, \\phi(x,y) \\lt 0\\}$。\n- $K^{-}$ 上的求积节点：\n  - 顶点：$A=(0,0)$、$B=\\left(\\frac{3}{5},0\\right)$、$C=\\left(0,\\frac{3}{5}\\right)$。\n  - 边中点：$M_{AB}=\\left(\\frac{3}{10},0\\right)$、$M_{BC}=\\left(\\frac{3}{10},\\frac{3}{10}\\right)$、$M_{CA}=\\left(0,\\frac{3}{10}\\right)$。\n- 相关的未知权重：$w_A$、$w_B$、$w_C$、$w_{AB}$、$w_{BC}$、$w_{CA}$。\n- 精确性条件：该求积法则必须对所有总次数最高为 $2$ 的多项式都精确，这对应于单项式基 $\\{1, x, y, x^{2}, xy, y^{2}\\}$。\n\n使用提取的已知条件进行验证：\n- **科学合理且客观**：该问题是数值分析中的一个标准练习，具体来说是通过矩量法构建求积法则。它基于已建立的数学原理，并以客观、精确的语言陈述。\n- **适定且完整**：该问题是自洽的。它提供了一个明确定义的域、一组求积节点以及对特定多项式空间的精确性条件。约束的数量（六个，来自六个基单项式）与未知权重的数量相匹配，表明可能存在唯一解。该问题是适定的。\n\n结论：该问题是有效的。它是偏微分方程数值方法领域内一个严谨、可解的问题。我们开始求解。\n\n该问题要求构建一个形式为\n$$ \\int_{K^{-}} f(x,y) \\,dA \\approx w_A f(A) + w_B f(B) + w_C f(C) + w_{AB} f(M_{AB}) + w_{BC} f(M_{BC}) + w_{CA} f(M_{CA}) $$\n的求积法则，该法则对任何总次数最多为 $2$ 的多项式 $p(x,y)$ 都是精确的。这等价于对基 $\\{1, x, y, x^2, xy, y^2\\}$ 中的每个单项式强制执行精确性。\n\n积分域 $K^{-}$ 是第一象限内满足 $x+y  3/5$ 的区域，它是一个直角三角形。令 $h = \\frac{3}{5}$。该三角形的顶点是 $(0,0)$、$(h,0)$ 和 $(0,h)$。求积节点被指定为三个顶点 $A(0,0)$、$B(h,0)$、$C(0,h)$ 和三个边中点 $M_{AB}(h/2, 0)$、$M_{BC}(h/2, h/2)$、$M_{CA}(0, h/2)$。\n\n对于单项式 $p_{m,n}(x,y) = x^m y^n$ 的精确性条件是：\n$$ \\sum_{i=1}^{6} w_i p_{m,n}(x_i, y_i) = \\int_{K^{-}} x^m y^n \\,dA $$\n我们必须首先计算矩，$I_{m,n} = \\int_{K^{-}} x^m y^n \\,dA$。$x^m y^n$ 在顶点为 $(0,0)$、$(h,0)$ 和 $(0,h)$ 的三角形上的积分由以下公式给出：\n$$ I_{m,n} = h^{m+n+2} \\frac{m! n!}{(m+n+2)!} $$\n我们计算 $(m+n) \\le 2$ 所需的矩：\n$I_{0,0} = \\int_{K^{-}} 1 \\,dA = h^2 \\frac{0!0!}{2!} = \\frac{h^2}{2} = \\frac{1}{2}\\left(\\frac{3}{5}\\right)^2 = \\frac{9}{50}$。\n$I_{1,0} = \\int_{K^{-}} x \\,dA = h^3 \\frac{1!0!}{3!} = \\frac{h^3}{6} = \\frac{1}{6}\\left(\\frac{3}{5}\\right)^3 = \\frac{27}{750} = \\frac{9}{250}$。\n$I_{0,1} = \\int_{K^{-}} y \\,dA = h^3 \\frac{0!1!}{3!} = \\frac{h^3}{6} = \\frac{9}{250}$。\n$I_{2,0} = \\int_{K^{-}} x^2 \\,dA = h^4 \\frac{2!0!}{4!} = \\frac{2h^4}{24} = \\frac{h^4}{12} = \\frac{1}{12}\\left(\\frac{3}{5}\\right)^4 = \\frac{81}{7500} = \\frac{27}{2500}$。\n$I_{1,1} = \\int_{K^{-}} xy \\,dA = h^4 \\frac{1!1!}{4!} = \\frac{h^4}{24} = \\frac{1}{24}\\left(\\frac{3}{5}\\right)^4 = \\frac{81}{15000} = \\frac{27}{5000}$。\n$I_{0,2} = \\int_{K^{-}} y^2 \\,dA = h^4 \\frac{0!2!}{4!} = \\frac{h^4}{12} = \\frac{27}{2500}$。\n\n现在，我们通过在六个求积点上计算每个基单项式的值来建立六个线性方程组。设权重向量为 $W = (w_A, w_B, w_C, w_{AB}, w_{BC}, w_{CA})^T$。\n\n1. 对于 $p(x,y)=1$：\n$w_A + w_B + w_C + w_{AB} + w_{BC} + w_{CA} = I_{0,0} = \\frac{h^2}{2}$。\n2. 对于 $p(x,y)=x$：\n$0 \\cdot w_A + h \\cdot w_B + 0 \\cdot w_C + \\frac{h}{2} \\cdot w_{AB} + \\frac{h}{2} \\cdot w_{BC} + 0 \\cdot w_{CA} = I_{1,0} = \\frac{h^3}{6}$。\n3. 对于 $p(x,y)=y$：\n$0 \\cdot w_A + 0 \\cdot w_B + h \\cdot w_C + 0 \\cdot w_{AB} + \\frac{h}{2} \\cdot w_{BC} + \\frac{h}{2} \\cdot w_{CA} = I_{0,1} = \\frac{h^3}{6}$。\n4. 对于 $p(x,y)=x^2$：\n$0 \\cdot w_A + h^2 \\cdot w_B + 0 \\cdot w_C + \\frac{h^2}{4} \\cdot w_{AB} + \\frac{h^2}{4} \\cdot w_{BC} + 0 \\cdot w_{CA} = I_{2,0} = \\frac{h^4}{12}$。\n5. 对于 $p(x,y)=xy$：\n$0 \\cdot w_A + 0 \\cdot w_B + 0 \\cdot w_C + 0 \\cdot w_{AB} + \\frac{h^2}{4} \\cdot w_{BC} + 0 \\cdot w_{CA} = I_{1,1} = \\frac{h^4}{24}$。\n6. 对于 $p(x,y)=y^2$：\n$0 \\cdot w_A + 0 \\cdot w_B + h^2 \\cdot w_C + 0 \\cdot w_{AB} + \\frac{h^2}{4} \\cdot w_{BC} + \\frac{h^2}{4} \\cdot w_{CA} = I_{0,2} = \\frac{h^4}{12}$。\n\n我们求解这个方程组。从方程(5)可知：\n$\\frac{h^2}{4} w_{BC} = \\frac{h^4}{24} \\implies w_{BC} = \\frac{4}{h^2} \\frac{h^4}{24} = \\frac{h^2}{6}$。\n\n现在考虑方程(2)和(4)，在分别除以 $h \\neq 0$ 和 $h^2 \\neq 0$ 之后：\n(2') $w_B + \\frac{1}{2} w_{AB} + \\frac{1}{2} w_{BC} = \\frac{h^2}{6}$。\n(4') $w_B + \\frac{1}{4} w_{AB} + \\frac{1}{4} w_{BC} = \\frac{h^2}{12}$。\n将方程(4')乘以 $2$ 得到 $2w_B + \\frac{1}{2} w_{AB} + \\frac{1}{2} w_{BC} = \\frac{h^2}{6}$。\n将此与(2')比较，我们得到 $2w_B = w_B$，这意味着 $w_B = 0$。\n将 $w_B=0$ 代入(2')：\n$\\frac{1}{2} w_{AB} + \\frac{1}{2} w_{BC} = \\frac{h^2}{6} \\implies w_{AB} + w_{BC} = \\frac{h^2}{3}$。\n使用 $w_{BC} = \\frac{h^2}{6}$，我们发现 $w_{AB} = \\frac{h^2}{3} - \\frac{h^2}{6} = \\frac{h^2}{6}$。\n\n根据问题关于直线 $y=x$ 的对称性，与关于该线对称的节点相关联的权重必须相等。因此，我们预期 $w_C = w_B$ 且 $w_{CA} = w_{AB}$。我们使用方程(3)和(6)来正式验证这一点。除以 $h$ 和 $h^2$：\n(3') $w_C + \\frac{1}{2} w_{BC} + \\frac{1}{2} w_{CA} = \\frac{h^2}{6}$。\n(6') $w_C + \\frac{1}{4} w_{BC} + \\frac{1}{4} w_{CA} = \\frac{h^2}{12}$。\n该方程组在结构上与关于 $w_B$ 和 $w_{AB}$ 的方程组相同。同样的逻辑可推断出 $w_C = 0$。\n将 $w_C=0$ 代入(3')得到 $\\frac{1}{2} w_{BC} + \\frac{1}{2} w_{CA} = \\frac{h^2}{6}$，这导致 $w_{CA} = \\frac{h^2}{3} - w_{BC} = \\frac{h^2}{3} - \\frac{h^2}{6} = \\frac{h^2}{6}$。\n\n最后，我们使用方程(1)来求 $w_A$：\n$w_A + w_B + w_C + w_{AB} + w_{BC} + w_{CA} = \\frac{h^2}{2}$。\n$w_A + 0 + 0 + \\frac{h^2}{6} + \\frac{h^2}{6} + \\frac{h^2}{6} = \\frac{h^2}{2}$。\n$w_A + 3\\left(\\frac{h^2}{6}\\right) = \\frac{h^2}{2}$。\n$w_A + \\frac{h^2}{2} = \\frac{h^2}{2} \\implies w_A = 0$。\n\n权重为：\n$w_A = 0$\n$w_B = 0$\n$w_C = 0$\n$w_{AB} = \\frac{h^2}{6} = \\frac{1}{6}\\left(\\frac{3}{5}\\right)^2 = \\frac{1}{6} \\cdot \\frac{9}{25} = \\frac{3}{50}$。\n$w_{BC} = \\frac{h^2}{6} = \\frac{3}{50}$。\n$w_{CA} = \\frac{h^2}{6} = \\frac{3}{50}$。\n\n所得的求积法则对最高 2 次多项式是精确的，它仅使用了三角形各边的中点。对于三角形单元，这是一个已知的结果。权重向量为 $(0, 0, 0, \\frac{3}{50}, \\frac{3}{50}, \\frac{3}{50})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0  0  0  \\frac{3}{50}  \\frac{3}{50}  \\frac{3}{50}\n\\end{pmatrix}\n}\n$$", "id": "2567751"}, {"introduction": "在开发任何计算代码时，验证其准确性都是一个不可或缺的步骤。本练习提供了一个经典的基准问题——振荡平板引起的流体运动（斯托克斯第二问题），它存在精确的解析解。通过将数值模拟结果与解析解在振幅衰减和相位延迟方面进行定量比较，我们可以有效地验证浸入边界法的实现是否能够准确捕捉流固耦合的动态特性 [@problem_id:2567789]。", "problem": "要求您为粘性不可压缩流体中的振荡刚性板问题，形式化一个可复现、可用代码验证的基准测试。该基准测试将作为有限元法 (FEM) 框架下浸入边界 (IB) 方法和虚拟区域 (FD) 方法的目标。目标是基于线性化非定常斯托克斯问题的精确解，计算垂直于振荡板的切向流体速度场的振幅衰减和相位滞后。这为验证数值 IB 和 FD 实现提供了参考目标，这些实现通过分布式拉格朗日乘子或在刚性极限下趋近于无滑移边界条件的罚函数法来施加板-流体运动学约束。\n\n考虑一个占据 $\\{ y \\ge 0 \\}$ 的无界半空间流体域，其中一个刚性的、无限延伸的平板位于 $y = 0$ 处。该平板具有给定的切向速度 $u_{\\text{plate}}(t) = U_0 \\cos(\\omega t)$，其中 $U_0$ 是振幅，$\\omega$ 是角频率。假设如下：\n- 流体为牛顿流体、不可压缩，且密度和粘度恒定。\n- 运动是平面的且平行于平板，因此唯一非零的速度分量是切向分量 $u(y,t)$，它仅依赖于 $y$ 和 $t$。\n- 振幅足够小，以致对流项可以忽略不计，从而得到无背景压力梯度的线性化非定常斯托克斯方程。\n- 与 IB/FD 施加相关的物理目标对应于约束在平板上恢复为无滑移边界的极限情况。\n\n从第一性原理出发，从无压力梯度情况下切向分量 $u(y,t)$ 的线性化动量平衡方程开始，\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial y^2},\n$$\n其中 $\\nu$ 是运动粘度。边界条件为\n$$\nu(0,t) = U_0 \\cos(\\omega t), \\quad \\lim_{y \\to \\infty} u(y,t) = 0.\n$$\n定义振幅比 $A(y)/U_0$ 为 $u(y,t)$ 的局部谐波振幅与平板振幅 $U_0$ 之比，并定义相位滞后 $\\phi(y)$ (以弧度为单位) 为位置 $y$ 处的局部响应相对于平板振荡 $\\cos(\\omega t)$ 的时间相位延迟。\n\n您的任务：\n1. 从给定的控制方程和边界条件出发，推导振幅比 $A(y)/U_0$ 和相位滞后 $\\phi(y)$ 作为 $y$、$\\nu$ 和 $\\omega$ 的函数的闭式表达式。角度必须以弧度表示。\n2. 实现一个程序，该程序针对下面的每个测试用例，使用您推导出的表达式计算数组 $[A(y)/U_0,\\;\\phi(y)]$，将每个量四舍五入到六位小数，并按指定格式在单行上输出所有结果。您可以假设 $U_0 \\ne 0$ 并按定义用 $U_0$ 进行归一化。\n\n物理单位和报告要求：\n- 距离 $y$ 以米为单位。\n- 运动粘度 $\\nu$ 以 $\\text{m}^2/\\text{s}$ 为单位。\n- 角频率 $\\omega$ 以 $\\text{rad}/\\text{s}$ 为单位。\n- 振幅比 $A(y)/U_0$ 是无量纲的。\n- 相位滞后 $\\phi(y)$ 必须以弧度为单位报告。\n- 将所有报告的数字四舍五入到六位小数。\n\n测试套件 (五个案例)：\n- 案例 1：$(\\nu, \\omega, y) = (0.01, 2.0, 0.05)$。\n- 案例 2：$(\\nu, \\omega, y) = (0.01, 2.0, 0.0)$。\n- 案例 3：$(\\nu, \\omega, y) = (0.01, 2.0, 0.3)$。\n- 案例 4：$(\\nu, \\omega, y) = (0.001, 8.0, 0.02)$。\n- 案例 5：$(\\nu, \\omega, y) = (0.004, 0.5, 0.05)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个长度为五的 Python 风格列表，每个条目是一个双元素列表 $[A(y)/U_0,\\;\\phi(y)]$，与上述案例一一对应。例如：\n`[[a1,p1],[a2,p2],[a3,p3],[a4,p4],[a5,p5]]`\n请勿在此列表前后打印任何额外文本。\n\n您的实现必须是完全自包含的，并且无需用户输入即可运行。角度必须以弧度为单位返回，所有数值输出必须按规定四舍五入到六位小数。您的程序产生的数值结果将作为正确性的验收标准。", "solution": "所提出的问题是流体动力学中的一个经典练习，特别是对斯托克斯第二问题的分析，该问题描述了由振荡平板引起的流动。该问题是适定的、有科学依据的，并为推导唯一的解析解提供了所有必要信息。因此，该问题被认为是有效的。我们将开始推导。\n\n在域 $y \\ge 0$ 中，切向流体速度 $u(y,t)$ 的控制方程是一维非定常斯托克斯方程，它在数学上等价于扩散方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial y^2}\n$$\n这里，$\\nu$ 是流体的运动粘度。运动由位于 $y=0$ 处的平板驱动，该平板进行切向振荡。边界条件为：\n$$\nu(0,t) = U_0 \\cos(\\omega t)\n$$\n$$\n\\lim_{y \\to \\infty} u(y,t) = 0\n$$\n第二个条件表明流体在远离平板处是静止的。我们寻求一个周期性稳态解，该解以与平板相同的角频率 $\\omega$ 振荡。\n\n为求解此线性偏微分方程，采用复变量是很有利的。我们将真实速度 $u(y,t)$ 表示为复速度场 $\\tilde{u}(y,t)$ 的实部。令 $u(y,t) = \\text{Re}[\\tilde{u}(y,t)]$。平板处的边界条件可写为 $u(0,t) = \\text{Re}[U_0 e^{i\\omega t}]$，其中 $i$ 是虚数单位。因此，我们用复边界条件来构建关于 $\\tilde{u}(y,t)$ 的问题：\n$$\n\\tilde{u}(0,t) = U_0 e^{i\\omega t}\n$$\n我们假设解的形式为 $\\tilde{u}(y,t) = f(y)e^{i\\omega t}$，这分离了空间和时间的依赖关系。将此拟设代入控制偏微分方程得到：\n$$\n\\frac{\\partial}{\\partial t} \\left( f(y) e^{i\\omega t} \\right) = \\nu \\frac{\\partial^2}{\\partial y^2} \\left( f(y) e^{i\\omega t} \\right)\n$$\n$$\ni\\omega f(y) e^{i\\omega t} = \\nu f''(y) e^{i\\omega t}\n$$\n除以非零项 $e^{i\\omega t}$，得到关于复振幅函数 $f(y)$ 的二阶常微分方程：\n$$\nf''(y) - \\frac{i\\omega}{\\nu} f(y) = 0\n$$\n这是一个线性齐次常系数常微分方程。其特征方程为 $\\lambda^2 - i\\omega/\\nu = 0$，得到 $\\lambda^2 = i\\omega/\\nu$。为了求出根 $\\lambda$，我们必须计算虚数单位 $i$ 的平方根。在极坐标形式中，$i=e^{i\\pi/2}$。其平方根为 $\\pm e^{i\\pi/4} = \\pm(\\cos(\\pi/4) + i\\sin(\\pi/4)) = \\pm\\frac{1+i}{\\sqrt{2}}$。\n因此，特征根为：\n$$\n\\lambda = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\sqrt{i} = \\pm \\sqrt{\\frac{\\omega}{\\nu}} \\frac{1+i}{\\sqrt{2}} = \\pm (1+i) \\sqrt{\\frac{\\omega}{2\\nu}}\n$$\n我们定义一个特征长度尺度 $\\delta = \\sqrt{2\\nu/\\omega}$，通常称为粘性穿透深度或斯托克斯边界层厚度。通过这个定义，根简化为 $\\lambda = \\pm (1+i)/\\delta$。\n\n$f(y)$ 的通解是两个指数解的线性组合：\n$$\nf(y) = C_1 e^{(1+i)y/\\delta} + C_2 e^{-(1+i)y/\\delta}\n$$\n常数 $C_1$ 和 $C_2$ 由边界条件确定。在无穷远处的条件 $\\lim_{y \\to \\infty} u(y,t) = 0$ 意味着复振幅也必须为零，即 $\\lim_{y \\to \\infty} f(y) = 0$。项 $e^{(1+i)y/\\delta} = e^{y/\\delta}e^{iy/\\delta}$ 的模 $e^{y/\\delta}$ 随 $y$ 指数增长。为使解保持有界并衰减至零，其系数 $C_1$ 必须为零。\n因此，解的形式简化为：\n$$\nf(y) = C_2 e^{-(1+i)y/\\delta}\n$$\n剩下的常数 $C_2$ 可通过平板 $y=0$ 处的边界条件求得。我们有 $\\tilde{u}(0,t) = f(0)e^{i\\omega t} = U_0 e^{i\\omega t}$，这要求 $f(0) = U_0$。将此应用于我们关于 $f(y)$ 的解：\n$$\nf(0) = C_2 e^0 = C_2 = U_0\n$$\n因此，复振幅的特解是：\n$$\nf(y) = U_0 e^{-(1+i)y/\\delta} = U_0 e^{-y/\\delta} e^{-iy/\\delta}\n$$\n完整的复速度场则为：\n$$\n\\tilde{u}(y,t) = f(y)e^{i\\omega t} = U_0 e^{-y/\\delta} e^{-iy/\\delta} e^{i\\omega t} = U_0 e^{-y/\\delta} e^{i(\\omega t - y/\\delta)}\n$$\n物理速度 $u(y,t)$ 是 $\\tilde{u}(y,t)$ 的实部：\n$$\nu(y,t) = \\text{Re}\\left[ U_0 e^{-y/\\delta} \\left(\\cos(\\omega t - y/\\delta) + i\\sin(\\omega t - y/\\delta)\\right) \\right]\n$$\n$$\nu(y,t) = U_0 e^{-y/\\delta} \\cos(\\omega t - y/\\delta)\n$$\n该解表示一个从平板传播到流体中的阻尼横波。\n\n从这个最终表达式中，我们可以直接识别出我们感兴趣的量。解的形式为 $u(y,t) = A(y) \\cos(\\omega t - \\phi(y))$，其中 $A(y)$ 是局部振幅，$\\phi(y)$ 是相对于平板运动 $\\cos(\\omega t)$ 的相位滞后。\n通过比较，我们发现：\n1. 局部振幅为 $A(y) = U_0 e^{-y/\\delta}$。所需的振幅比为：\n$$\n\\frac{A(y)}{U_0} = e^{-y/\\delta}\n$$\n2. 相位滞后为 $\\phi(y) = y/\\delta$。\n\n将 $\\delta = \\sqrt{2\\nu/\\omega}$ 的定义代入这些表达式，得到关于给定物理参数的最终公式：\n振幅比为：\n$$\n\\frac{A(y)}{U_0} = \\exp\\left(-y \\sqrt{\\frac{\\omega}{2\\nu}}\\right)\n$$\n相位滞后 (以弧度为单位) 为：\n$$\n\\phi(y) = y \\sqrt{\\frac{\\omega}{2\\nu}}\n$$\n这些是计算基准值所需的闭式表达式。注意，对于 $y0$，振幅衰减且相位正向滞后，这与物理直觉一致。对于 $y=0$ 的情况，这些公式正确地得出了1的振幅比和0的相位滞后。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the amplitude attenuation and phase lag for an oscillating plate\n    in a viscous fluid (Stokes' second problem).\n    \"\"\"\n    # Test cases: tuples of (kinematic_viscosity, angular_frequency, distance_y)\n    # Units: nu (m^2/s), omega (rad/s), y (m)\n    test_cases = [\n        (0.01, 2.0, 0.05),\n        (0.01, 2.0, 0.0),\n        (0.01, 2.0, 0.3),\n        (0.001, 8.0, 0.02),\n        (0.004, 0.5, 0.05),\n    ]\n\n    # A list to store the formatted results for each case.\n    formatted_results = []\n\n    for case in test_cases:\n        nu, omega, y = case\n\n        # The core term y * sqrt(omega / (2 * nu)) appears in both amplitude\n        # and phase calculations.\n        # Handle the case where nu is zero to avoid division errors, although not\n        # present in the test suite.\n        if nu == 0:\n            # Physically, zero viscosity means no momentum transfer, so amplitude\n            # is zero for y > 0.\n            # However, the problem formulation implies nu > 0.\n            # In the limit nu->0, the exponent goes to infinity for y>0.\n            # Amp ratio would be 0, phase lag infinite.\n            # At y=0, the results are 1 and 0.\n            if y == 0:\n                amplitude_ratio = 1.0\n                phase_lag = 0.0\n            else:\n                # This case is physically ill-defined in the context of this problem\n                # but we handle it for robustness.\n                amplitude_ratio = 0.0\n                phase_lag = float('inf')\n        else:\n            alpha = y * np.sqrt(omega / (2 * nu))\n            amplitude_ratio = np.exp(-alpha)\n            phase_lag = alpha\n\n        # Format each number to six decimal places, ensuring trailing zeros.\n        amp_str = f\"{amplitude_ratio:.6f}\"\n        lag_str = f\"{phase_lag:.6f}\"\n\n        # Create the string representation for the pair [amplitude, phase].\n        formatted_results.append(f\"[{amp_str},{lag_str}]\")\n\n    # Combine all formatted pairs into the final output string.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2567789"}, {"introduction": "本练习是一个综合性应用，旨在将理论与实践相结合，解决一个经典的流体动力学问题。它将引导您完成一个完整的虚拟区域模拟流程：首先，使用分布式拉格朗日乘子法推导问题的弱形式；然后，设计并实现一种切割单元积分方案，用于计算浸入体所受的流体动力（如阻力和升力）。这个练习综合运用了浸入式方法中的关键概念和技术，是检验和巩固学习成果的绝佳实践 [@problem_id:2567766]。", "problem": "请使用带有浸入式界面的有限元法，为嵌入在矩形域中的静止圆柱绕流问题，设计一个数学上一致的虚拟区域法。该流动为稳态、不可压缩、低雷诺数流动。从矩形域 $\\,\\Omega \\subset \\mathbb{R}^2\\,$ 内的稳态斯托克斯方程出发，其动力粘度为 $\\,\\mu\\,$。域内包含一个半径为 $\\,R\\,$、中心为 $\\,\\boldsymbol{c}=(c_x,c_y)\\,$ 的圆形刚体 $\\,B\\subset\\Omega\\,$。流体占据区域 $\\,\\Omega_f=\\Omega\\setminus \\overline{B}\\,$，圆柱体边界为 $\\,\\Gamma=\\partial B\\,$。无滑移条件 $\\,\\boldsymbol{u}=\\boldsymbol{0}\\,$ 在 $\\,\\Gamma\\,$ 上成立，且 $\\,\\boldsymbol{u}\\,$ 在 $\\,\\partial\\Omega\\,$ 上满足适当的边界条件（后续推导无需此条件）。请使用以下基本出发点：\n\n- $\\,\\Omega_f\\,$ 内的稳态斯托克斯方程：\n$$\n-\\mu \\nabla^2 \\boldsymbol{u} + \\nabla p = \\boldsymbol{f}, \\quad \\nabla\\cdot \\boldsymbol{u} = 0.\n$$\n\n- 虚功原理以及 $\\,\\Gamma\\,$ 上边界面力与测试函数的对偶配对。\n\nA 部分（推导）。使用分布式拉格朗日乘子（DLM）虚拟区域法，将速度场和压力场扩展到整个区域 $\\,\\Omega\\,$，并引入一个定义在 $\\,\\Gamma\\,$ 上的拉格朗日乘子场 $\\,\\boldsymbol{\\lambda}\\,$，以便在弱意义下强制施加 $\\,\\Gamma\\,$ 上的约束 $\\,\\boldsymbol{u}=\\boldsymbol{0}\\,$。通过将动量方程和不可压缩性方程乘以测试函数，并在适当情况下进行分部积分，来推导 $\\,(\\boldsymbol{u},p,\\boldsymbol{\\lambda})\\,$ 的耦合弱形式，并明确展示界面项 $\\,\\langle \\boldsymbol{\\lambda}, \\boldsymbol{v}\\rangle_{\\Gamma}\\,$ 是如何从在 $\\,\\Gamma\\,$ 上施加无滑移约束中产生的。然后，利用虚功率平衡和应力的定义，严格证明圆柱体所受的流体动力为何可以由界面面力的积分给出，并用 $\\,\\boldsymbol{\\lambda}\\,$ 表示阻力和升力。请清楚说明您所采用的所有假设和符号约定。\n\nB 部分（使用切割单元进行离散化）。考虑将方形域 $\\,\\Omega=[0,1]^2\\,$ 划分为 $\\,N\\times N\\,$ 个边长为 $\\,h=1/N\\,$ 的方形单元的均匀背景笛卡尔网格，并根据需要隐式地分割每个正方形，以支持连续分片线性速度空间和分片常数压力空间。通过水平集函数隐式地表示界面 $\\,\\Gamma\\,$：\n$$\n\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}-\\boldsymbol{c}\\| - R.\n$$\n对于 $\\,\\Gamma\\,$ 上的数值积分，采用切割单元法：在每个 $\\,\\phi\\,$ 在其单元边界上变号的单元中，通过在 $\\,\\phi\\,$ 变号的边上进行线性插值，计算出交点，然后用直线段近似 $\\,\\Gamma\\,$ 与该单元边界的交集。在每个这样的线段上使用中点法则，设计一个程序来近似 $\\,\\Gamma\\,$ 上的线积分。具体而言，请说明如何根据沿 $\\,\\Gamma\\,$ 给定的解析分布 $\\,\\boldsymbol{\\lambda}(\\boldsymbol{x})\\,$ 计算阻力和升力的近似值，包括如何根据由 $\\,\\boldsymbol{x}=\\boldsymbol{c}+R(\\cos\\theta,\\sin\\theta)\\,$ 定义的极角 $\\,\\theta\\,$ 对 $\\,\\boldsymbol{\\lambda}\\,$ 进行参数化。角度必须以弧度为单位。假设使用无量纲单位。\n\nC 部分（可计算的测试套件）。实现在 B 部分中设计的切割单元积分方法，以近似计算在 $\\,\\Omega=[0,1]^2\\,$ 中的以下四个测试案例的阻力和升力，所有案例均使用 $\\,N=250\\,$：\n\n- 案例 $\\,1\\,$（一般常数乘子）：$\\,\\boldsymbol{c}=(0.5,0.5)\\,$，$\\,R=0.3\\,$，以及 $\\,\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)\\,$，其中 $\\,\\alpha=1.2\\,$ 且 $\\,\\beta=-0.3\\,$。\n\n- 案例 $\\,2\\,$（纯径向乘子）：$\\,\\boldsymbol{c}=(0.33,0.65)\\,$，$\\,R=0.22\\,$，以及 $\\,\\boldsymbol{\\lambda}(\\theta)=A(\\cos\\theta,\\sin\\theta)\\,$，其中 $\\,A=1.0\\,$。\n\n- 案例 $\\,3\\,$（混合法向/切向加常数）：$\\,\\boldsymbol{c}=(0.7,0.5)\\,$，$\\,R=0.29\\,$，以及\n$$\n\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)+B(\\cos\\theta,\\sin\\theta)+C(-\\sin\\theta,\\cos\\theta),\n$$\n其中 $\\,\\alpha=0.5\\,$，$\\,\\beta=0.0\\,$，$\\,B=0.7\\,$，且 $\\,C=-0.4\\,$。\n\n- 案例 $\\,4\\,$（小半径常数乘子）：$\\,\\boldsymbol{c}=(0.2,0.2)\\,$，$\\,R=0.05\\,$，以及 $\\,\\boldsymbol{\\lambda}(\\theta)=(\\alpha,\\beta)\\,$，其中 $\\,\\alpha=-0.8\\,$ 且 $\\,\\beta=0.4\\,$。\n\n您的程序应使用您设计的切割线段中点积分法，为每个案例计算阻力和升力，作为两个独立的浮点数。最终输出格式必须是单行，其中包含一个列表，结果按 $[\\text{drag}_1,\\text{lift}_1,\\text{drag}_2,\\text{lift}_2,\\text{drag}_3,\\text{lift}_3,\\text{drag}_4,\\text{lift}_4]$ 的顺序展平。所有角度均使用弧度。由于公式是无量纲的，因此不需要物理单位。输出列表的元素必须是浮点数。代码必须完全自包含，不需要用户输入或外部文件。", "solution": "该问题在科学上和数学上是合理的、适定的，并提供了一组清晰、自包含的任务。这是计算流体动力学和数值分析领域中的一个有效问题。我们开始进行解答。\n\n根据要求，解答分为两部分：A 部分，弱形式和力计算的理论推导；B 部分，数值积分方案的设计。\n\nA 部分：虚拟区域法和力计算的推导\n\n我们从流体域 $\\Omega_f = \\Omega \\setminus \\overline{B}$ 中不可压缩流体的稳态斯托克斯方程开始，其动力粘度为 $\\mu$：\n$$-\\mu \\nabla^2 \\boldsymbol{u} + \\nabla p = \\boldsymbol{f} \\quad \\text{in } \\Omega_f$$\n$$\\nabla\\cdot \\boldsymbol{u} = 0 \\quad \\text{in } \\Omega_f$$\n并服从刚体表面 $\\Gamma = \\partial B$ 上的无滑移边界条件：\n$$\\boldsymbol{u} = \\boldsymbol{0} \\quad \\text{on } \\Gamma$$\n\n分布式拉格朗日乘子（DLM）虚拟区域法将问题从复杂的域 $\\Omega_f$ 扩展到更简单的矩形域 $\\Omega$。速度场 $\\boldsymbol{u}$ 和压力场 $p$ 被扩展为在整个域 $\\Omega$ 上定义。界面 $\\Gamma$ 上的刚体约束 $\\boldsymbol{u} = \\boldsymbol{0}$ 在构造上不再被满足，必须以弱形式强制施加。这是通过引入一个仅在界面 $\\Gamma$ 上定义的拉格朗日乘子场 $\\boldsymbol{\\lambda}$ 来实现的。\n\n为了推导弱形式，我们引入适当的函数空间。令 $V = [H^1(\\Omega)]^2$ 为速度场 $\\boldsymbol{u}$ 的空间，$Q = L^2_0(\\Omega)$ 为压力场 $p$ 的空间（在 $\\Omega$ 上均值为零的函数），$M = [H^{-1/2}(\\Gamma)]^2$ 为拉格朗日乘子 $\\boldsymbol{\\lambda}$ 的空间。速度、压力和拉格朗日乘子对应的测试函数空间分别由 $\\boldsymbol{v} \\in V$、$q \\in Q$ 和 $\\boldsymbol{\\eta} \\in M$ 表示。\n\n弱形式是通过将控制方程乘以测试函数，在域 $\\Omega$ 上积分，并应用分部积分得到的。\n动量方程乘以测试函数 $\\boldsymbol{v} \\in V$：\n$$\\int_{\\Omega} (-\\mu \\nabla^2 \\boldsymbol{u}) \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x} + \\int_{\\Omega} (\\nabla p) \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x} = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\n对拉普拉斯项和散度项应用分部积分（格林第一恒等式），得到：\n$$\\int_{\\Omega} \\mu \\nabla\\boldsymbol{u} : \\nabla\\boldsymbol{v} \\,d\\boldsymbol{x} - \\int_{\\partial\\Omega} \\mu \\frac{\\partial\\boldsymbol{u}}{\\partial\\boldsymbol{n}} \\cdot \\boldsymbol{v} \\,ds - \\int_{\\Omega} p (\\nabla \\cdot \\boldsymbol{v}) \\,d\\boldsymbol{x} + \\int_{\\partial\\Omega} p \\boldsymbol{v} \\cdot \\boldsymbol{n} \\,ds = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\n$\\partial\\Omega$ 上的边界积分由外域上的边界条件处理，我们被指示忽略这些条件。虚拟区域法的关键思想是如何处理内部边界 $\\Gamma$ 上的约束。$\\Gamma$ 上的约束 $\\boldsymbol{u}=\\boldsymbol{0}$ 通过拉格朗日乘子 $\\boldsymbol{\\lambda}$ 添加到系统中，从而在动量方程的弱形式中产生一个附加项。\n\n关于三元组 $(\\boldsymbol{u}, p, \\boldsymbol{\\lambda})$ 的最终方程组是一个鞍点问题。寻找 $(\\boldsymbol{u}, p, \\boldsymbol{\\lambda}) \\in V \\times Q \\times M$，使得对于所有测试函数 $(\\boldsymbol{v}, q, \\boldsymbol{\\eta}) \\in V \\times Q \\times M$：\n1.  动量方程的弱形式：\n    $$\\int_{\\Omega} \\mu \\nabla\\boldsymbol{u} : \\nabla\\boldsymbol{v} \\,d\\boldsymbol{x} - \\int_{\\Omega} p (\\nabla \\cdot \\boldsymbol{v}) \\,d\\boldsymbol{x} + \\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds = \\int_{\\Omega} \\boldsymbol{f} \\cdot \\boldsymbol{v} \\,d\\boldsymbol{x}$$\n2.  不可压缩约束的弱形式：\n    $$\\int_{\\Omega} q (\\nabla \\cdot \\boldsymbol{u}) \\,d\\boldsymbol{x} = 0$$\n3.  $\\Gamma$ 上无滑移约束的弱形式：\n    $$\\int_{\\Gamma} \\boldsymbol{\\eta} \\cdot \\boldsymbol{u} \\,ds = 0$$\n\n界面项 $\\langle \\boldsymbol{\\lambda}, \\boldsymbol{v}\\rangle_{\\Gamma} \\equiv \\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds$ 源于虚功原理。在 $\\Omega_f$ 上的物理问题中，固体通过 $\\Gamma$ 施加于流体上的接触力的虚功率会以边界积分的形式出现。在 DLM 公式中，这种物理相互作用被抽象的拉格朗日乘子项所取代。因此，乘子 $\\boldsymbol{\\lambda}$ 可以解释为约束施加在流体上的力密度。\n\n为了证明力计算的合理性，我们将 $\\boldsymbol{\\lambda}$ 与流体动力应力张量 $\\boldsymbol{\\sigma} = -p\\boldsymbol{I} + \\mu(\\nabla\\boldsymbol{u} + (\\nabla\\boldsymbol{u})^T)$ 联系起来。流体施加在物体上的力由 $\\boldsymbol{F} = \\int_{\\Gamma} \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} \\, ds$ 给出，其中 $\\boldsymbol{n}$ 是 $\\Gamma$ 上从流体域 $\\Omega_f$ 向外指（即指向物体 $B$ 内部）的单位法向量。\n\n如果我们在物理域 $\\Omega_f$ 上推导弱形式，动量方程的分部积分将产生一个在边界 $\\partial\\Omega_f = \\partial\\Omega \\cup \\Gamma$ 上的项。在 $\\Gamma$ 上的积分将是 $\\int_{\\Gamma} \\boldsymbol{v} \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}) \\,ds$。将其与 $\\Omega$ 上的 DLM 弱形式进行比较，我们发现项 $\\int_{\\Gamma} \\boldsymbol{\\lambda} \\cdot \\boldsymbol{v} \\,ds$ 扮演了 $-\\int_{\\Gamma} \\boldsymbol{v} \\cdot (\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}) \\,ds$ 的角色。这个等同关系对所有容许的测试函数 $\\boldsymbol{v}$ 都成立，这意味着在 $\\Gamma$ 上有强关系 $\\boldsymbol{\\lambda} = -\\boldsymbol{\\sigma} \\cdot \\boldsymbol{n}$。\n\n因此，作用在物体上的流体动力 $\\boldsymbol{F}$ 为：\n$$\\boldsymbol{F} = \\int_{\\Gamma} \\boldsymbol{\\sigma} \\cdot \\boldsymbol{n} \\,ds = \\int_{\\Gamma} (-\\boldsymbol{\\lambda}) \\,ds = -\\int_{\\Gamma} \\boldsymbol{\\lambda} \\,ds$$\n假设平均流向与 x 轴正方向一致，阻力 $F_D$ 是 $\\boldsymbol{F}$ 的 x 分量，升力 $F_L$ 是 y 分量。令 $\\boldsymbol{\\lambda} = (\\lambda_x, \\lambda_y)$，我们有：\n$$F_D = -\\int_{\\Gamma} \\lambda_x \\,ds$$\n$$F_L = -\\int_{\\Gamma} \\lambda_y \\,ds$$\n这是从拉格朗日乘子计算力的基本结果。\n\nB 部分：切割单元积分方案\n\n我们的任务是设计一个数值程序，在域 $\\Omega=[0,1]^2$ 的均匀笛卡尔网格上近似力积分 $F_D$ 和 $F_L$。该网格由 $N \\times N$ 个边长为 $h=1/N$ 的方形单元组成。圆形界面 $\\Gamma$ 由水平集函数 $\\phi(\\boldsymbol{x}) = \\|\\boldsymbol{x}-\\boldsymbol{c}\\| - R = 0$ 隐式定义。\n\n积分方案按以下步骤进行：\n1.  **网格生成**：为 $i,j \\in \\{0, 1, \\dots, N\\}$ 定义一个由 $(N+1) \\times (N+1)$ 个顶点 $\\boldsymbol{x}_{i,j} = (i h, j h)$ 组成的网格。这些顶点定义了 $N^2$ 个单元。\n2.  **水平集求值**：在所有网格顶点上计算水平集函数 $\\phi$ 的值。\n3.  **切割单元识别**：遍历每个单元，单元由其左下角 $(i,j)$ 索引，其中 $i,j \\in \\{0, \\dots, N-1\\}$。如果一个单元四个顶点处的 $\\phi$ 值不全是同号，则该单元被识别为“切割单元”。这表明界面 $\\Gamma$ 穿过了该单元的边界。\n4.  **界面近似**：对于每个切割单元，我们用一条直线段来近似穿过它的 $\\Gamma$ 曲线段。该线段通过寻找 $\\Gamma$ 与单元边的交点来确定。\n    - 一条边由两个顶点定义，例如 $\\boldsymbol{p}_1$ 和 $\\boldsymbol{p}_2$。设其对应的水平集值为 $\\phi_1 = \\phi(\\boldsymbol{p}_1)$ 和 $\\phi_2 = \\phi(\\boldsymbol{p}_2)$。\n    - 如果 $\\phi_1 \\phi_2  0$，则界面与该边相交。交点 $\\boldsymbol{p}_{int}$ 通过对水平集函数进行线性插值找到，这等价于找到通过 $(\\boldsymbol{p}_1, \\phi_1)$ 和 $(\\boldsymbol{p}_2, \\phi_2)$ 的线性函数的零点。交点的坐标由下式给出：\n      $$\\boldsymbol{p}_{int} = \\frac{|\\phi_2|\\boldsymbol{p}_1 + |\\phi_1|\\boldsymbol{p}_2}{|\\phi_1| + |\\phi_2|}$$\n    - 对于任何给定的切割单元（不包含特殊拓扑情况，如接触顶点，这对于光滑边界是罕见的），其边界上将恰好有两个这样的交点。我们称它们为 $\\boldsymbol{q}_1$ 和 $\\boldsymbol{q}_2$。连接 $\\boldsymbol{q}_1$ 和 $\\boldsymbol{q}_2$ 的线段就是我们在该单元内对 $\\Gamma$ 的线性近似。\n5.  **中点积分**：我们通过对每个切割单元线段的贡献求和，来近似函数 $g(\\boldsymbol{x})$ 在 $\\Gamma$ 上的线积分。对于由端点 $\\boldsymbol{q}_{1,k}$ 和 $\\boldsymbol{q}_{2,k}$ 定义的单元 $k$ 中的线段，我们使用中点法则。\n    - 计算线段的长度：$\\Delta s_k = \\|\\boldsymbol{q}_{2,k} - \\boldsymbol{q}_{1,k}\\|$。\n    - 计算线段的中点：$\\boldsymbol{m}_k = (\\boldsymbol{q}_{1,k} + \\boldsymbol{q}_{2,k}) / 2$。\n    - 在该线段上的积分近似为 $g(\\boldsymbol{m}_k) \\Delta s_k$。\n6.  **力计算**：为了计算阻力和升力，我们将此积分应用于被积函数 $-\\lambda_x$ 和 $-\\lambda_y$。\n    - 为了计算以极角 $\\theta$ 函数形式给出的 $\\boldsymbol{\\lambda}(\\boldsymbol{m}_k)$，我们首先计算中点 $\\boldsymbol{m}_k$ 相对于圆柱中心 $\\boldsymbol{c}$ 的角度：\n      $$\\theta_k = \\text{atan2}(m_{k,y} - c_y, m_{k,x} - c_x)$$\n      其中 $\\boldsymbol{m}_k = (m_{k,x}, m_{k,y})$ 和 $\\boldsymbol{c} = (c_x, c_y)$。\n    - 中点处的拉格朗日乘子向量则为 $\\boldsymbol{\\lambda}(\\theta_k) = (\\lambda_x(\\theta_k), \\lambda_y(\\theta_k))$。\n    - 总阻力和升力通过对所有切割单元求和来近似：\n      $$F_D \\approx \\sum_{k \\in \\text{cut cells}} (-\\lambda_x(\\theta_k)) \\Delta s_k$$\n      $$F_L \\approx \\sum_{k \\in \\text{cut cells}} (-\\lambda_y(\\theta_k)) \\Delta s_k$$\n\n此过程提供了一个完整的算法，用于从拉格朗日乘子的解析表达式计算所需的力，该算法将在 C 部分的测试案例中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing the cut-element quadrature scheme for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: General constant multiplier\n        {'id': 1, 'c': np.array([0.5, 0.5]), 'R': 0.3, 'params': {'alpha': 1.2, 'beta': -0.3}},\n        \n        # Case 2: Purely radial multiplier\n        {'id': 2, 'c': np.array([0.33, 0.65]), 'R': 0.22, 'params': {'A': 1.0}},\n        \n        # Case 3: Mixed normal/tangential plus constant\n        {'id': 3, 'c': np.array([0.7, 0.5]), 'R': 0.29, 'params': {'alpha': 0.5, 'beta': 0.0, 'B': 0.7, 'C': -0.4}},\n        \n        # Case 4: Small radius constant multiplier\n        {'id': 4, 'c': np.array([0.2, 0.2]), 'R': 0.05, 'params': {'alpha': -0.8, 'beta': 0.4}},\n    ]\n\n    N = 250\n    h = 1.0 / N\n    results = []\n\n    for case in test_cases:\n        c = case['c']\n        R = case['R']\n        params = case['params']\n        case_id = case['id']\n        \n        # Grid vertices\n        x_coords = np.linspace(0.0, 1.0, N + 1)\n        y_coords = np.linspace(0.0, 1.0, N + 1)\n        \n        # Evaluate level-set function phi on all grid vertices\n        X, Y = np.meshgrid(x_coords, y_coords)\n        phi_values = np.sqrt((X - c[0])**2 + (Y - c[1])**2) - R\n        \n        total_drag = 0.0\n        total_lift = 0.0\n\n        # Iterate over each cell in the grid\n        for j in range(N):\n            for i in range(N):\n                # Get phi values at the four corners of the cell (i, j)\n                # (i,j) -> (x_i, y_j)\n                phi00 = phi_values[j, i]\n                phi10 = phi_values[j, i+1]\n                phi01 = phi_values[j+1, i]\n                phi11 = phi_values[j+1, i+1]\n                \n                #\n                # Vertices of the cell, using (x,y) convention\n                # v00: bottom-left, v10: bottom-right, v01: top-left, v11: top-right\n                #\n                v00 = np.array([x_coords[i], y_coords[j]])\n                v10 = np.array([x_coords[i+1], y_coords[j]])\n                v01 = np.array([x_coords[i], y_coords[j+1]])\n                v11 = np.array([x_coords[i+1], y_coords[j+1]])\n\n                corners_phi = np.array([phi00, phi10, phi11, phi01])\n                \n                # Check if the cell is cut by the interface\n                if np.all(corners_phi >= 0) or np.all(corners_phi  0):\n                    continue\n\n                intersections = []\n                # Check each of the four edges for intersections\n                \n                # Bottom edge (v00 -> v10)\n                if phi00 * phi10  0:\n                    t = phi00 / (phi00 - phi10)\n                    intersect_pt = v00 + t * (v10 - v00)\n                    intersections.append(intersect_pt)\n                \n                # Right edge (v10 -> v11)\n                if phi10 * phi11  0:\n                    t = phi10 / (phi10 - phi11)\n                    intersect_pt = v10 + t * (v11 - v10)\n                    intersections.append(intersect_pt)\n\n                # Top edge (v11 -> v01)\n                if phi11 * phi01  0:\n                    t = phi11 / (phi11 - phi01)\n                    intersect_pt = v11 + t * (v01 - v11)\n                    intersections.append(intersect_pt)\n                \n                # Left edge (v01 -> v00)\n                if phi01 * phi00  0:\n                    t = phi01 / (phi01 - phi00)\n                    intersect_pt = v01 + t * (v00 - v01)\n                    intersections.append(intersect_pt)\n                \n                if len(intersections) == 2:\n                    p1, p2 = intersections[0], intersections[1]\n                    \n                    # Midpoint of the segment\n                    midpoint = (p1 + p2) / 2.0\n                    \n                    # Length of the segment\n                    ds = np.linalg.norm(p2 - p1)\n                    \n                    # Angle of the midpoint relative to the cylinder center\n                    # This angle is used to evaluate the analytical lambda function\n                    relative_pos = midpoint - c\n                    theta = np.arctan2(relative_pos[1], relative_pos[0])\n                    \n                    # Evaluate lambda(theta) based on the test case\n                    lambda_val = np.zeros(2)\n                    if case_id == 1:\n                        lambda_val[0] = params['alpha']\n                        lambda_val[1] = params['beta']\n                    elif case_id == 2:\n                        A = params['A']\n                        lambda_val[0] = A * np.cos(theta)\n                        lambda_val[1] = A * np.sin(theta)\n                    elif case_id == 3:\n                        alpha, beta, B, C = params['alpha'], params['beta'], params['B'], params['C']\n                        cos_t, sin_t = np.cos(theta), np.sin(theta)\n                        # base vector + normal component + tangential component\n                        lambda_val[0] = alpha + B * cos_t - C * sin_t\n                        lambda_val[1] = beta  + B * sin_t + C * cos_t\n                    elif case_id == 4:\n                        lambda_val[0] = params['alpha']\n                        lambda_val[1] = params['beta']\n\n                    # Add contribution to total drag and lift\n                    # Force = -integral(lambda * ds)\n                    total_drag += -lambda_val[0] * ds\n                    total_lift += -lambda_val[1] * ds\n\n        results.extend([total_drag, total_lift])\n        \n    # Format the final output string\n    output_str = \"[\" + \",\".join(f\"{res:.8f}\" for res in results) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2567766"}]}