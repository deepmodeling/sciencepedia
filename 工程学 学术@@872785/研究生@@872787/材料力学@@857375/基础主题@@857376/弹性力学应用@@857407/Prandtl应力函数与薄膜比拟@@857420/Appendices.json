{"hands_on_practices": [{"introduction": "对于具有特定对称性的截面，我们可以求得扭转问题的精确解析解。本练习将指导您如何利用等边三角形的对称性，构建一个满足边界条件的多项式试探函数，并从第一性原理出发求解普朗特应力函数 $\\phi$，最终确定其抗扭刚度。这个过程能加深您对普朗特应力函数理论核心概念的理解。[@problem_id:2910859]", "problem": "一个均匀、线性弹性、各向同性的等边三角形截面棱柱杆，绕其形心轴承受圣维南扭转，单位长度扭转角为 $\\theta$。等边三角形的边长为 $s$。设剪切模量为 $G$。引入 Prandtl 应力函数 $\\phi(x,y)$，其在圣维南扭转中的标准定义如下：\n- $\\tau_{xz} = \\dfrac{\\partial \\phi}{\\partial y}$ 和 $\\tau_{yz} = -\\dfrac{\\partial \\phi}{\\partial x}$，\n- 在截面边界上 $\\phi = 0$，\n以及在截面域内满足控制泊松方程 $\\nabla^{2} \\phi = -2 G \\theta$。\n\n采用笛卡尔坐标系 $(x,y)$，原点位于形心。对于等边三角形，其三条边是与原点等垂直距离 $r$ 的直线，向内单位法向量之间相隔 $120^{\\circ}$。用 $l_{1}(x,y)$、$l_{2}(x,y)$ 和 $l_{3}(x,y)$ 表示点 $(x,y)$ 到每条边的有符号垂直距离，规定在三角形内部为正，因此在第 $i$ 条边上 $l_{i} = 0$，在内部 $l_{i} > 0$。\n\n任务：\n1. 仅利用上述基本定义和等边三角形的对称性，为 $\\phi(x,y)$ 提出一个满足 $120^{\\circ}$ 旋转对称性并且在三条边上均为 $\\phi = 0$ 的最低阶多项式拟设。\n2. 在域内应用控制方程，以确定你拟设中的所有待定常数。\n3. 从扭矩定义 $T = \\iint_{A} \\left( x \\,\\tau_{yz} - y \\,\\tau_{xz} \\right) \\, dA$ 出发，推导由 $T = G J_{t} \\theta$ 定义的扭转常数 $J_{t}$ 的表达式，并计算出边长为 $s$ 的等边三角形的精确值。\n\n请将你的最终答案表示为仅含 $s$ 的单个闭式解析表达式。扭转常数 $J_{t}$ 的单位是长度的四次方。请提供精确表达式，无需四舍五入。", "solution": "所述问题是圣维南扭转理论在非圆形截面棱柱杆上的一个标准应用。该问题提法恰当，有科学依据，且内部逻辑一致。因此，该问题被认为是有效的，并将提供解答。\n\n设等边三角形截面为域 $A$。边长为 $s$。我们选择一个笛卡尔坐标系 $(x,y)$，其原点位于三角形的形心，且 $y$ 轴与其中一条高线对齐。这一选择利用了截面的对称性，从而简化了计算。\n\n在此坐标系中，三角形的顶点位于 $(0, 2c)$、$(\\sqrt{3}c, -c)$ 和 $(-\\sqrt{3}c, -c)$，其中 $c$ 是三角形的边心距（内切圆半径）。边心距 $c$ 和高 $h = 3c$ 与边长 $s$ 的关系为 $s = 2\\sqrt{3}c$。因此，$c = \\frac{s}{2\\sqrt{3}}$。三角形的高为 $h = \\frac{\\sqrt{3}}{2}s = 3c$，所以顶点位于 $(0, \\frac{2}{3}h)$，底边位于 $y = -\\frac{1}{3}h$，这证实了形心在原点。\n\n构成三角形边界的三条直线是：\n1.  底边：$y = -c$。直线方程为 $L_1(x,y) \\equiv y+c=0$。\n2.  右边，经过 $(\\sqrt{3}c, -c)$ 和 $(0, 2c)$：斜率为 $\\frac{2c - (-c)}{0 - \\sqrt{3}c} = \\frac{3c}{-\\sqrt{3}c} = -\\sqrt{3}$。方程为 $y - 2c = -\\sqrt{3}x$，即 $L_2(x,y) \\equiv \\sqrt{3}x+y-2c=0$。\n3.  左边，经过 $(-\\sqrt{3}c, -c)$ 和 $(0, 2c)$：斜率为 $\\sqrt{3}$。方程为 $y - 2c = \\sqrt{3}x$，即 $L_3(x,y) \\equiv -\\sqrt{3}x+y-2c=0$。\n\n对于三角形内部的一点 $(x,y)$（例如原点 $(0,0)$），我们发现 $y+c>0$、$\\sqrt{3}x+y-2c<0$ 和 $-\\sqrt{3}x+y-2c<0$。为满足线性函数 $l_i(x,y)$ 在三角形内部为正的条件，我们将其定义为：\n$l_1(x,y) = y+c$\n$l_2(x,y) = -(\\sqrt{3}x+y-2c) = 2c-y-\\sqrt{3}x$\n$l_3(x,y) = -(-\\sqrt{3}x+y-2c) = 2c-y+\\sqrt{3}x$\n\n**1. 提出应力函数 $\\phi(x,y)$ 的拟设**\n\nPrandtl 应力函数 $\\phi$ 必须在三角形的三条边上都满足边界条件 $\\phi=0$。满足整个边界这一条件的最低阶多项式是定义各边的线性函数的乘积。这种形式也内在地拥有等边三角形的 $120^\\circ$ 旋转对称性。因此，我们提出以下拟设：\n$$ \\phi(x,y) = C \\cdot l_1(x,y) \\cdot l_2(x,y) \\cdot l_3(x,y) $$\n其中 $C$ 是一个待定常数。\n代入 $l_i(x,y)$ 的表达式：\n$$ \\phi(x,y) = C(y+c)(2c-y-\\sqrt{3}x)(2c-y+\\sqrt{3}x) $$\n后两项的乘积为 $(2c-y)^2 - (\\sqrt{3}x)^2 = (4c^2 - 4cy + y^2) - 3x^2$。\n$$ \\phi(x,y) = C(y+c)(y^2 - 4cy + 4c^2 - 3x^2) $$\n展开此表达式可得：\n$$ \\phi(x,y) = C(y^3 - 4cy^2 + 4c^2y - 3x^2y + cy^2 - 4c^2y + 4c^3 - 3cx^2) $$\n$$ \\phi(x,y) = C(y^3 - 3cy^2 - 3x^2y - 3cx^2 + 4c^3) $$\n这可以更紧凑地写作：\n$$ \\phi(x,y) = C \\left[ y(y^2-3x^2) - 3c(x^2+y^2) + 4c^3 \\right] $$\n这就是我们提出的应力函数的三次多项式拟设。\n\n**2. 从控制方程确定常数**\n\n控制泊松方程为 $\\nabla^2 \\phi = -2G\\theta$。我们计算拟设的拉普拉斯算子。\n首先，我们求关于 $x$ 和 $y$ 的偏导数：\n$$ \\frac{\\partial \\phi}{\\partial x} = C(-6xy - 6cx) = -6C(xy+cx) $$\n$$ \\frac{\\partial^2 \\phi}{\\partial x^2} = -6C(y+c) $$\n$$ \\frac{\\partial \\phi}{\\partial y} = C(3y^2 - 6cy - 3x^2) $$\n$$ \\frac{\\partial^2 \\phi}{\\partial y^2} = C(6y - 6c) = 6C(y-c) $$\n拉普拉斯算子是二阶偏导数之和：\n$$ \\nabla^2 \\phi = \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} = -6C(y+c) + 6C(y-c) = -6Cy - 6Cc + 6Cy - 6Cc = -12Cc $$\n将此代入控制方程：\n$$ -12Cc = -2G\\theta $$\n解出常数 $C$：\n$$ C = \\frac{2G\\theta}{12c} = \\frac{G\\theta}{6c} $$\n因此，应力函数被完全确定：\n$$ \\phi(x,y) = \\frac{G\\theta}{6c} \\left[ y(y^2-3x^2) - 3c(x^2+y^2) + 4c^3 \\right] $$\n\n**3. 推导扭转常数 $J_t$**\n\n总扭矩 $T$ 在问题中定义为 $T = \\iint_A (x \\tau_{yz} - y \\tau_{xz}) dA$。我们可以将其与应力函数 $\\phi$ 上的一个积分联系起来。使用定义 $\\tau_{yz} = -\\frac{\\partial \\phi}{\\partial x}$ 和 $\\tau_{xz} = \\frac{\\partial \\phi}{\\partial y}$：\n$$ T = \\iint_A \\left(x\\left(-\\frac{\\partial \\phi}{\\partial x}\\right) - y\\left(\\frac{\\partial \\phi}{\\partial y}\\right)\\right) dA = - \\iint_A \\left(x\\frac{\\partial \\phi}{\\partial x} + y\\frac{\\partial \\phi}{\\partial y}\\right) dA $$\n我们使用分部积分法（格林第一恒等式）。例如，对于第一项：\n$$ \\iint_A x\\frac{\\partial \\phi}{\\partial x} dA = \\oint_{\\partial A} x\\phi n_x dS - \\iint_A \\phi \\frac{\\partial x}{\\partial x} dA = \\oint_{\\partial A} x\\phi n_x dS - \\iint_A \\phi dA $$\n其中 $\\partial A$ 是域 $A$ 的边界，$n_x$ 是向外单位法向量的x分量。由于在边界 $\\partial A$ 上 $\\phi = 0$，线积分为零。因此，$\\iint_A x\\frac{\\partial \\phi}{\\partial x} dA = -\\iint_A \\phi dA$。类似地，$\\iint_A y\\frac{\\partial \\phi}{\\partial y} dA = -\\iint_A \\phi dA$。\n将这些代入扭矩表达式：\n$$ T = -(-\\iint_A \\phi dA - \\iint_A \\phi dA) = 2 \\iint_A \\phi dA $$\n现在我们必须计算这个积分。对函数 $\\phi$ 在三角形域 $A$ 上进行积分是一个标准但冗长的过程。其结果为：\n$$ \\iint_A \\phi dA = C \\frac{27\\sqrt{3}}{5}c^5 $$\n因此，扭矩为 $T = 2\\iint_A \\phi dA = 2C \\frac{27\\sqrt{3}}{5}c^5$。\n代入 $C = \\frac{G\\theta}{6c}$：\n$$ T = 2\\left(\\frac{G\\theta}{6c}\\right) \\frac{27\\sqrt{3}}{5}c^5 = \\frac{G\\theta}{3c} \\frac{27\\sqrt{3}}{5}c^5 = \\frac{9\\sqrt{3}}{5}G\\theta c^4 $$\n根据定义 $T = GJ_t\\theta$，我们确定扭转常数 $J_t$ 为：\n$$ J_t = \\frac{9\\sqrt{3}}{5}c^4 $$\n最后，我们使用 $c = \\frac{s}{2\\sqrt{3}}$，将 $J_t$ 用边长 $s$ 表示：\n$$ J_t = \\frac{9\\sqrt{3}}{5} \\left( \\frac{s}{2\\sqrt{3}} \\right)^4 = \\frac{9\\sqrt{3}}{5} \\frac{s^4}{16 \\cdot (\\sqrt{3})^4} = \\frac{9\\sqrt{3}}{5} \\frac{s^4}{16 \\cdot 9} = \\frac{\\sqrt{3}}{80}s^4 $$\n这就是等边三角形截面扭转常数的精确表达式。", "answer": "$$\\boxed{\\frac{\\sqrt{3}}{80}s^{4}}$$", "id": "2910859"}, {"introduction": "除了多项式试探函数，谱方法（如傅里叶级数）为求解矩形等规则截面的扭转问题提供了另一种强大的分析工具。本练习将引导您使用双正弦级数来表示普朗特应力函数，该级数能自动满足边界条件。您将通过推导级数系数和抗扭刚度的表达式，并将该解析解转化为计算程序，从而连接起理论分析与数值计算。[@problem_id:2910802]", "problem": "考虑一根具有矩形截面的棱柱杆的圣维南扭转，其截面占据域 $0 < x < a$, $0 < y < b$，其中 $a > 0$ 和 $b > 0$ 是具有长度量纲的常数。令 $\\phi(x,y)$ 为普朗特应力函数。剪应力分量定义为 $\\tau_{xz} = \\partial \\phi / \\partial y$ 和 $\\tau_{yz} = - \\partial \\phi / \\partial x$，单位长度扭转角记为 $\\theta'$；剪切模量为 $G$。边界条件为 $\\phi = 0$ 在矩形边界上成立。\n\n任务 A (推导)：从无体力情况下的线性动量平衡和圣维南扭转的协调性条件出发，推导出矩形域内 $\\phi(x,y)$ 的控制性边值问题。然后，通过将 $\\phi(x,y)$ 在矩形域内展开为双重正弦级数，设计一个能自动满足齐次狄利克雷边界条件的谱近似。利用正弦基的正交性以及对常数右端项的投影，求出用几何参数 $a$ 和 $b$ 以及常数 $G$ 和 $\\theta'$ 表示的模态系数，过程中不得引入任何非由这些原理推导出的快捷公式。接下来，依据第一性原理和矢量微积分恒等式，用 $\\phi(x,y)$ 表示绕 $z$ 轴的扭矩 $T$，并根据 $T = G J_t \\theta'$ 的定义，求出用正弦级数系数表达的扭转常数 $J_t$ 的显式级数。最后，将结果无量纲化，以分离出一个纯几何函数\n$$\ng(\\beta) \\equiv \\frac{J_t}{a\\, b^3}, \\quad \\beta \\equiv \\frac{b}{a},\n$$\n并提供一个仅使用截至用户指定截断值的奇数指标模态、适用于数值计算的截断级数。\n\n任务 B (计算)：实现一个程序，使用任务 A 中推导出的双重正弦级数来计算 $g(\\beta)$ 的截断谱近似值，其中级数在 $x$ 方向截断至前 $M$ 个奇数模态，在 $y$ 方向截断至前 $N$ 个奇数模态。具体来说，截断近似必须对 $m \\in \\{1,3,5,\\dots,2M-1\\}$ 和 $n \\in \\{1,3,5,\\dots,2N-1\\}$ 进行求和。你的程序必须为下面列出的每个测试用例计算 $g(\\beta)$，结果为一个无量纲实数（无物理单位）。\n\n数值要求：\n- 使用双精度浮点运算。\n- 对于每个测试用例，输出 $g(\\beta)$ 的值，并四舍五入到8位小数。\n- 最终输出必须为单行，包含所有测试用例的结果，形式为方括号内由逗号分隔的列表，无空格，例如：$[0.12345678,0.23456789]$。\n\n测试套件（按以下顺序提供结果）：\n1. $(a,b,M,N) = (\\,1,\\;1,\\;25,\\;25\\,)$\n2. $(a,b,M,N) = (\\,1,\\;1,\\;1,\\;1\\,)$\n3. $(a,b,M,N) = (\\,2,\\;1,\\;25,\\;25\\,)$\n4. $(a,b,M,N) = (\\,1,\\;0.2,\\;25,\\;25\\,)$\n5. $(a,b,M,N) = (\\,1,\\;2,\\;25,\\;25\\,)$\n\n最终输出格式：\n- 你的程序应生成单行输出，包含5个结果，形式为方括号内由逗号分隔的列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应于第 $k$ 个测试用例的 $g(\\beta)$ 的截断近似值，四舍五入到8位小数。", "solution": "问题陈述需经过验证。\n\n**第 1 步：提取已知条件**\n\n-   **区域**：在 $xy$ 平面内具有矩形截面的棱柱杆，由 $0 < x < a$ 和 $0 < y < b$ 定义。$a > 0$ 和 $b > 0$ 是常数。\n-   **场变量**：普朗特应力函数，$\\phi(x,y)$。\n-   **本构关系**：剪应力分量由 $\\tau_{xz} = \\partial \\phi / \\partial y$ 和 $\\tau_{yz} = - \\partial \\phi / \\partial x$ 给出。\n-   **物理常数**：剪切模量为 $G$，单位长度扭转角为 $\\theta'$。\n-   **边界条件**：应力函数在矩形边界上为零：$\\phi(x,y) = 0$ 在 $x=0,a$ 和 $y=0,b$ 上成立。\n-   **任务 A (推导)**：推导出 $\\phi$ 的控制性边值问题，求一个双重正弦级数解，推导出扭转常数 $J_t$ 的表达式，并将其无量纲化以得到 $g(\\beta) = J_t/(ab^3)$，其中 $\\beta=b/a$。截断级数必须对奇数指标 $m \\in \\{1,3,5,\\dots,2M-1\\}$ 和 $n \\in \\{1,3,5,\\dots,2N-1\\}$ 求和。\n-   **任务 B (计算)**：实现一个程序，为五个指定的测试用例计算 $g(\\beta)$ 的截断级数。\n-   **测试套件**：\n    1.  $(a,b,M,N) = (1, 1, 25, 25)$\n    2.  $(a,b,M,N) = (1, 1, 1, 1)$\n    3.  $(a,b,M,N) = (2, 1, 25, 25)$\n    4.  $(a,b,M,N) = (1, 0.2, 25, 25)$\n    5.  $(a,b,M,N) = (1, 2, 25, 25)$\n-   **数值要求**：使用双精度运算。结果四舍五入到8位小数。\n-   **输出格式**：单行 `[r_1,r_2,r_3,r_4,r_5]`。\n\n**第 2 步：问题验证**\n\n该问题是关于圣维南扭转的弹性力学理论中的一个标准习题。它具有科学依据，是适定的，且陈述客观。\n\n1.  **科学合理性**：该问题基于连续介质力学的基本原理，包括线动量平衡（平衡）和应变协调性，这些都是该学科的基石。普朗特应力函数是解决此类问题的标准且正确的公式化方法。\n2.  **适定性**：$\\phi$ 的控制方程是在一个简单矩形域上的泊松方程，带有齐次狄利克雷边界条件。这构成了一个适定的椭圆型边值问题，从而保证了解的存在性、唯一性和稳定性。\n3.  **完整性**：所有必要的参数（$a, b, G, \\theta'$）、本构关系和边界条件都已明确给出。任务也定义清晰。\n\n**第 3 步：结论**\n\n该问题被认为是**有效的**。将提供一个完整的、论证充分的解答。\n\n**推导与求解**\n\n按要求从第一性原理开始推导。\n\n首先，我们建立普朗特应力函数 $\\phi(x,y)$ 的控制偏微分方程。对于圣维南扭转，应力张量只有两个非零分量 $\\tau_{xz}$ 和 $\\tau_{yz}$，且假定它们与轴向坐标 $z$ 无关。在无体力的情况下，平衡方程 $\\nabla \\cdot \\boldsymbol{\\sigma} = \\mathbf{0}$ 可简化为唯一的非平凡方程：\n$$\n\\frac{\\partial \\tau_{xz}}{\\partial x} + \\frac{\\partial \\tau_{yz}}{\\partial y} = 0\n$$\n代入定义 $\\tau_{xz} = \\frac{\\partial \\phi}{\\partial y}$ 和 $\\tau_{yz} = -\\frac{\\partial \\phi}{\\partial x}$，我们发现\n$$\n\\frac{\\partial}{\\partial x}\\left(\\frac{\\partial \\phi}{\\partial y}\\right) + \\frac{\\partial}{\\partial y}\\left(-\\frac{\\partial \\phi}{\\partial x}\\right) = \\frac{\\partial^2 \\phi}{\\partial x \\partial y} - \\frac{\\partial^2 \\phi}{\\partial y \\partial x} = 0\n$$\n这表明应力函数公式恒满足平衡条件。\n\n接下来，我们引入协调性条件。对于纯扭转，应变分量由 $\\frac{\\partial \\gamma_{yz}}{\\partial x} - \\frac{\\partial \\gamma_{xz}}{\\partial y} = 2\\theta'$ 关联。对于剪切模量为 $G$ 的线性弹性各向同性材料，胡克定律给出 $\\tau_{xz} = G\\gamma_{xz}$ 和 $\\tau_{yz} = G\\gamma_{yz}$。将这些代入协调性方程可得：\n$$\n\\frac{\\partial}{\\partial x}\\left(\\frac{\\tau_{yz}}{G}\\right) - \\frac{\\partial}{\\partial y}\\left(\\frac{\\tau_{xz}}{G}\\right) = 2\\theta'\n$$\n代入应力函数定义：\n$$\n\\frac{1}{G} \\left[ \\frac{\\partial}{\\partial x}\\left(-\\frac{\\partial \\phi}{\\partial x}\\right) - \\frac{\\partial}{\\partial y}\\left(\\frac{\\partial \\phi}{\\partial y}\\right) \\right] = 2\\theta'\n$$\n$$\n-\\frac{1}{G} \\left( \\frac{\\partial^2 \\phi}{\\partial x^2} + \\frac{\\partial^2 \\phi}{\\partial y^2} \\right) = 2\\theta'\n$$\n这就给出了应力函数的控制性泊松方程：\n$$\n\\nabla^2 \\phi(x,y) = -2G\\theta'\n$$\n该问题定义在矩形域 $\\Omega = \\{(x,y) : 0 < x < a, 0 < y < b\\}$ 上，边界 $\\partial \\Omega$ 上具有齐次狄利克雷边界条件 $\\phi = 0$。\n\n我们使用谱方法求解此边值问题。我们寻求一个双重正弦级数形式的解，它能自动满足边界条件：\n$$\n\\phi(x,y) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} C_{mn} \\sin\\left(\\frac{m\\pi x}{a}\\right) \\sin\\left(\\frac{n\\pi y}{b}\\right)\n$$\n将此级数代入泊松方程可得：\n$$\n\\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} C_{mn} \\left[ -\\left(\\frac{m\\pi}{a}\\right)^2 - \\left(\\frac{n\\pi}{b}\\right)^2 \\right] \\sin\\left(\\frac{m\\pi x}{a}\\right) \\sin\\left(\\frac{n\\pi y}{b}\\right) = -2G\\theta'\n$$\n为了求出系数 $C_{mn}$，我们将常数右端项 $f(x,y) = -2G\\theta'$ 展开为双重正弦级数，$f(x,y) = \\sum_{m=1}^{\\infty} \\sum_{n=1}^{\\infty} F_{mn} \\sin(\\frac{m\\pi x}{a}) \\sin(\\frac{n\\pi y}{b})$。系数 $F_{mn}$ 可通过利用基函数的正交性进行投影求得：\n$$\nF_{mn} = \\frac{4}{ab} \\int_0^a \\int_0^b (-2G\\theta') \\sin\\left(\\frac{m\\pi x}{a}\\right) \\sin\\left(\\frac{n\\pi y}{b}\\right) \\,dy\\,dx\n$$\n$$\nF_{mn} = -\\frac{8G\\theta'}{ab} \\left[ \\int_0^a \\sin\\left(\\frac{m\\pi x}{a}\\right) dx \\right] \\left[ \\int_0^b \\sin\\left(\\frac{n\\pi y}{b}\\right) dy \\right]\n$$\n积分计算结果为：\n$$\n\\int_0^a \\sin\\left(\\frac{m\\pi x}{a}\\right) dx = \\left[-\\frac{a}{m\\pi}\\cos\\left(\\frac{m\\pi x}{a}\\right)\\right]_0^a = -\\frac{a}{m\\pi}(\\cos(m\\pi) - 1) = \\begin{cases} \\frac{2a}{m\\pi}  \\text{若 } m \\text{ 为奇数} \\\\ 0  \\text{若 } m \\text{ 为偶数} \\end{cases}\n$$\n对 $y$ 的积分也类似。因此，只有当 $m$ 和 $n$ 均为奇数时，$F_{mn}$ 才非零：\n$$\nF_{mn} = -\\frac{8G\\theta'}{ab} \\left(\\frac{2a}{m\\pi}\\right) \\left(\\frac{2b}{n\\pi}\\right) = -\\frac{32G\\theta'}{mn\\pi^2} \\quad \\text{对于奇数 } m, n\n$$\n令正弦级数各项的系数相等：\n$$\n-C_{mn} \\pi^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right) = F_{mn} = -\\frac{32G\\theta'}{mn\\pi^2}\n$$\n对奇数 $m,n$ 求解 $C_{mn}$：\n$$\nC_{mn} = \\frac{32G\\theta'}{mn\\pi^4 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)}\n$$\n绕 $z$ 轴的总扭矩 $T$ 是剪应力在整个截面上产生的力矩的积分：\n$$\nT = \\iint_{\\Omega} (x \\tau_{yz} - y \\tau_{xz}) \\,dx\\,dy = \\iint_{\\Omega} \\left[ x \\left(-\\frac{\\partial \\phi}{\\partial x}\\right) - y \\left(\\frac{\\partial \\phi}{\\partial y}\\right) \\right] \\,dx\\,dy\n$$\n利用分部积分法以及在边界上 $\\phi=0$ 的事实：\n$$\n\\iint_{\\Omega} x \\frac{\\partial \\phi}{\\partial x} \\,dx\\,dy = \\int_0^b \\left( [x\\phi]_{x=0}^{x=a} - \\int_0^a \\phi \\,dx \\right) dy = -\\iint_{\\Omega} \\phi \\,dx\\,dy\n$$\n类似地，$\\iint_{\\Omega} y \\frac{\\partial \\phi}{\\partial y} \\,dx\\,dy = -\\iint_{\\Omega} \\phi \\,dx\\,dy$。因此，\n$$\nT = - \\left( -\\iint_{\\Omega} \\phi \\,dx\\,dy - \\iint_{\\Omega} \\phi \\,dx\\,dy \\right) = 2 \\iint_{\\Omega} \\phi \\,dx\\,dy\n$$\n代入 $\\phi$ 的级数表达式：\n$$\nT = 2 \\iint_{\\Omega} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} C_{mn} \\sin\\left(\\frac{m\\pi x}{a}\\right) \\sin\\left(\\frac{n\\pi y}{b}\\right) \\,dx\\,dy\n$$\n$$\nT = 2 \\sum_{\\substack{m,n \\\\ \\text{奇数}}} C_{mn} \\left[ \\int_0^a \\sin\\left(\\frac{m\\pi x}{a}\\right) dx \\right] \\left[ \\int_0^b \\sin\\left(\\frac{n\\pi y}{b}\\right) dy \\right]\n$$\n$$\nT = 2 \\sum_{\\substack{m,n \\\\ \\text{奇数}}} C_{mn} \\left( \\frac{2a}{m\\pi} \\right) \\left( \\frac{2b}{n\\pi} \\right) = \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{8ab}{mn\\pi^2} C_{mn}\n$$\n代入 $C_{mn}$ 的表达式：\n$$\nT = \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{8ab}{mn\\pi^2} \\frac{32G\\theta'}{mn\\pi^4 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)} = G\\theta' \\frac{256ab}{\\pi^6} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{1}{m^2n^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)}\n$$\n扭转常数为 $J_t = T/(G\\theta')$，所以\n$$\nJ_t = \\frac{256ab}{\\pi^6} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{1}{m^2n^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)}\n$$\n我们将此结果无量纲化。令 $\\beta = b/a$。我们求 $g(\\beta) = J_t/(ab^3)$。\n$$\ng(\\beta) = \\frac{1}{ab^3} \\left[ \\frac{256ab}{\\pi^6} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{1}{m^2n^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)} \\right] = \\frac{256}{\\pi^6 b^2} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{1}{m^2n^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)}\n$$\n包含 $b^2$ 的项可以移入求和号内，与分母合并：\n$$\n\\frac{1}{b^2 \\left( \\frac{m^2}{a^2} + \\frac{n^2}{b^2} \\right)} = \\frac{1}{\\frac{m^2 b^2}{a^2} + n^2} = \\frac{1}{m^2 \\beta^2 + n^2}\n$$\n这就给出了最终的无量纲形式：\n$$\ng(\\beta) = \\frac{256}{\\pi^6} \\sum_{\\substack{m,n \\\\ \\text{奇数}}} \\frac{1}{m^2n^2 (m^2\\beta^2 + n^2)}\n$$\n为便于计算，级数被截断。求和指标 $m$ 和 $n$ 分别被指定为前 $M$ 个和前 $N$ 个奇数。我们可以写作 $m = 2i-1$（$i=1, 2, ..., M$）和 $n = 2j-1$（$j=1, 2, ..., N$）。因此，截断近似 $g_{M,N}(\\beta)$ 为：\n$$\ng_{M,N}(\\beta) = \\frac{256}{\\pi^6} \\sum_{i=1}^{M} \\sum_{j=1}^{N} \\frac{1}{(2i-1)^2 (2j-1)^2 ((2i-1)^2\\beta^2 + (2j-1)^2)}\n$$\n这就是要在程序中实现的表达式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the dimensionless torsional constant g(beta) for a rectangular\n    cross-section using a truncated double sine series derived from the\n    Prandtl stress function formulation.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, b, M, N).\n    test_cases = [\n        (1.0, 1.0, 25, 25),\n        (1.0, 1.0, 1, 1),\n        (2.0, 1.0, 25, 25),\n        (1.0, 0.2, 25, 25),\n        (1.0, 2.0, 25, 25),\n    ]\n\n    results = []\n    \n    # Pre-calculate the constant factor\n    constant_factor = 256.0 / (np.pi**6)\n\n    for case in test_cases:\n        a, b, M, N = case\n        \n        # Calculate the geometric ratio beta\n        beta = b / a\n        beta_squared = beta**2\n        \n        series_sum = 0.0\n        \n        # The sum is over odd indices m and n.\n        # m = 2*i - 1 for i in 1..M\n        # n = 2*j - 1 for j in 1..N\n        \n        # Generate arrays of odd indices to enable vectorized calculation,\n        # though simple loops are equally correct and perhaps more clear.\n        m_vals = 2 * np.arange(1, M + 1) - 1\n        n_vals = 2 * np.arange(1, N + 1) - 1\n        \n        for m in m_vals:\n            m_squared = m**2\n            \n            for n in n_vals:\n                n_squared = n**2\n                \n                # Calculate the term in the double summation\n                denominator = (m_squared * n_squared * \n                               (m_squared * beta_squared + n_squared))\n                \n                term = 1.0 / denominator\n                series_sum += term\n\n        # Calculate the final value for g(beta)\n        g_beta = constant_factor * series_sum\n        \n        # Round the result to 8 decimal places as required\n        results.append(round(g_beta, 8))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2910802"}, {"introduction": "对于任意形状或带有孔洞的多连通截面，解析方法通常不再适用，必须借助数值方法。本练习将带您进入现代计算工程的核心，通过有限元方法 (FEM) 求解复杂截面的扭转问题。您将为普朗特应力函数的泊松方程推导并实现一个混合有限元格式，其中使用拉格朗日乘子来处理多连通区域的边界约束，这是解决实际工程问题的一项关键技能。[@problem_id:2910829]", "problem": "您需要通过膜比拟法，为扭转问题中的Prandtl应力函数建立并实现一个混合有限元方法。Prandtl函数在多连通域上满足一个泊松方程，其外边界上具有本质边界条件，而任意内部孔洞边界上的未知常数值则通过拉格朗日乘子强制施加。\n\n出发点和控制定律：\n- 设 $A \\subset \\mathbb{R}^2$ 是一个开的有界多边形截面，其外边界为多边形 $\\partial A$，并含有一组有限的、不相交的多边形孔洞 $\\{\\Gamma_i\\}_{i=1}^{H}$，因此计算截面为 $\\Omega = A \\setminus \\bigcup_{i=1}^{H} \\overline{\\Gamma_i}$。Prandtl应力函数 $\\phi$ 是一个标量场，使得剪应力为 $\\tau_{xz} = \\partial \\phi / \\partial y$ 和 $\\tau_{yz} = - \\partial \\phi / \\partial x$。\n- 对于给定的单位长度扭转角和剪切模量（等效地表示为一个均匀源项），Prandtl函数满足泊松方程\n$$\n-\\nabla^2 \\phi = q \\quad \\text{in } \\Omega,\n$$\n同时，膜比拟法要求 $\\phi$ 在每个孔洞边界上为常数，并在外边界上为零。\n\n边界条件和约束：\n- 外边界 (Dirichlet)：在 $\\partial A$ 上 $\\phi = 0$。\n- 孔洞边界条件 (无牵引力膜等效)：对于每个 $i \\in \\{1,\\dots,H\\}$，在 $\\Gamma_i$ 上 $\\phi = C_i$，其中 $C_i \\in \\mathbb{R}$ 为某个常数。\n- 在每个 $\\Gamma_i$ 上引入一个拉格朗日乘子场，以便在混合弱形式中强制施加 $\\phi$ 沿 $\\Gamma_i$ 为常数的约束。乘子的选择应能推导出并恢复可解性条件，即边界乘子在每个 $\\Gamma_i$ 上的线积分为零。\n\n任务1：推导一个适用于混合方法的有限元弱形式，其中使用拉格朗日乘子来强制施加孔洞边界常数值。\n- 从强形式 $-\\nabla^2 \\phi = q$（在 $\\Omega$ 中）开始，乘以一个容许的检验函数，进行分部积分，并仔细保留每个 $\\Gamma_i$ 上的边界项。在 $\\partial A$ 上，强加 $\\phi=0$，因此检验函数应在 $\\partial A$ 上为零。\n- 对于每个孔洞 $\\Gamma_i$，引入一个标量未知数 $C_i$ 和一个拉格朗日乘子，以在 $\\Gamma_i$ 上强制施加 $\\phi=C_i$。证明相对于标量未知数 $C_i$ 的平稳性条件会导出拉格朗日乘子在 $\\Gamma_i$ 上的零均值条件。\n- 您的公式必须是一致、对称的，并能导出一个可在结构化网格上使用协调双线性四边形有限元对 $\\phi$ 进行离散化的可解鞍点（Karush–Kuhn–Tucker）线性系统。拉格朗日乘子应使用边界节点上的节点基函数和一致的梯形线积分加权在孔洞边界上进行离散化。\n\n任务2：在一个带有轴对齐矩形孔洞的单位正方形的结构化四边形网格上，实现有限元方法 (Finite Element Method (FEM))。在张量积单元上使用双线性形函数，对区域项使用 $2 \\times 2$ Gauss积分，对孔洞周长使用集中质量梯形法则。将中心严格位于任何孔洞内部的单元视为从网格中移除。将严格位于任何孔洞内部的节点视为移除。将恰好位于任何孔洞边界上的节点视为计算边界的一部分，在该边界上通过拉格朗日乘子强制施加常数值约束。在 $\\partial A$ 上强加 $\\phi=0$。\n\n任务3：数值设置和测试套件。\n- 区域：$A = [0,1] \\times [0,1]$。源项：$q(x,y) = 1$ (无量纲)。\n- 角度和物理单位不适用；所有报告的结果应为无量纲浮点数。\n- 网格参数：设 $N \\in \\mathbb{N}$ 为每边的单元数；网格有 $(N+1)^2$ 个节点，均匀间距为 $h = 1/N$。\n- 矩形孔洞规格：每个孔洞是一个轴对齐的矩形 $[x_1,x_2]\\times [y_1,y_2]$，其边界是 $h$ 的整数倍，以使边界与网格线对齐。\n- 离散化和组装要求：\n  - 使用标准等参映射和高斯积分，为双线性单元组装刚度矩阵。\n  - 组装混合KKT系统，该系统耦合了自由节点上的内部未知数 $\\phi$、孔洞边界节点上的边界拉格朗日乘子以及每个孔洞的标量常数 $C_i$。\n  - 对每个孔洞的拉格朗日乘子强制施加从相对于 $C_i$ 的平稳性中得出的零均值条件。\n  - 求解线性系统并恢复所有未移除节点上 $\\phi$ 的节点值。在外边界节点上设置 $\\phi=0$，并且不在孔洞内部定义 $\\phi$。\n\n任务4：测试套件的输出。\n实现您的程序，在单次运行中计算指定案例的以下输出，并将其打印为单行，形式为方括号内以逗号分隔的列表。对于每个案例，计算指定的标量或列表：\n- 案例1 (理想情况，单连通)：$N = 8$，无孔洞。计算区域积分\n$$\nI_1 = \\int_{\\Omega} \\phi(x,y)\\,dA,\n$$\n每个活动单元使用 $2 \\times 2$ 高斯积分。以浮点数形式返回 $I_1$。\n- 案例2 (单孔洞，约束强制)：$N = 20$，一个孔洞 $\\Gamma_1 = [0.4,0.6] \\times [0.4,0.6]$。设 $\\{\\phi_j\\}$ 为孔洞边界节点集合上的解值，设 $\\bar{\\phi} = \\frac{1}{M}\\sum_{j=1}^M \\phi_j$ 为其算术平均值，其中 $M$ 是此类节点的数量。计算\n$$\nd_1 = \\max_{1 \\le j \\le M} |\\phi_j - \\bar{\\phi}|,\n\\quad\nr_1 = \\left| \\sum_{j=1}^M w_j \\lambda_j \\right|,\n$$\n其中 $w_j$ 是 $\\Gamma_1$ 上的集中质量梯形线积分权重，$\\{\\lambda_j\\}$ 是与孔洞边界节点相关的离散拉格朗日乘子。返回列表 $[d_1, r_1]$。\n- 案例3 (双孔洞，多重约束和边缘覆盖)：$N = 30$，两个孔洞\n$$\n\\Gamma_1 = [0.3,0.5] \\times [0.3,0.5], \\quad\n\\Gamma_2 = [0.7,0.8] \\times [0.2,0.3].\n$$\n与案例2类似，为 $\\Gamma_1$ 定义 $d_1, r_1$，为 $\\Gamma_2$ 定义 $d_2, r_2$。返回列表\n$$\n\\big[\\max(d_1,d_2), \\max(r_1,r_2)\\big].\n$$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按以下顺序排列的结果，形式为方括号内以逗号分隔的列表\n$$\n[I_1, [d_1, r_1], [\\max(d_1,d_2), \\max(r_1,r_2)]].\n$$\n不应打印任何其他文本。所有浮点数都应以标准十进制表示法打印。\n\n重要说明：\n- 推导必须从泊松方程的分部积分和边界约束的合法弱施加开始。\n- 数值方法应为对称且稳定的，以反映鞍点系统的结构。\n- 确保区域积分使用高斯积分计算，而沿孔洞边界的拉格朗日乘子约束使用一致的梯形法则计算。", "solution": "所提出的问题是计算力学领域一个全面且适定的练习，具体涉及混合有限元方法在多连通域弹性扭转分析中的应用。该问题在科学上是合理的，数学上是一致的，并为其解决方案提供了所有必要的规范。因此，它被认为是有效的。我们开始进行求解。\n\n解决方案分为两部分：第一部分是弱形式和相应离散线性系统的推导；第二部分是数值实现的纲要，该实现将在最终代码中完成。\n\n### 第一部分：混合弱形式的推导\n\n区域 $\\Omega$ 中 Prandtl 应力函数 $\\phi$ 的控制方程是泊松方程：\n$$\n-\\nabla^2 \\phi = q \\quad \\text{in } \\Omega\n$$\n区域 $\\Omega$ 是一个有界区域 $A = [0,1] \\times [0,1]$，移除了 $H$ 个不相交的多边形孔洞 $\\{\\Gamma_i\\}_{i=1}^H$。边界条件是：\n1.  在外边界 $\\partial A$ 上，$\\phi = 0$。\n2.  在每个孔洞边界 $\\Gamma_i$ 上，$\\phi = C_i$，其中每个 $C_i$ 是一个未知常数。\n\n为了推导混合弱形式，我们引入拉格朗日乘子来强制施加孔洞边界上的约束。我们在 $\\phi$ 的容许函数空间、拉格朗日乘子场集 $\\{\\lambda_i\\}$ 和未知常数集 $\\{C_i\\}$ 上定义一个拉格朗日泛函 $\\mathcal{L}$。设 $\\phi$ 的函数空间为 $S = \\{ \\psi \\in H^1(\\Omega) \\mid \\psi|_{\\partial A} = 0 \\}$。设 $\\Gamma_i$ 上的拉格朗日乘子空间为 $\\Lambda_i = H^{-1/2}(\\Gamma_i)$。未知数是三元组 $(\\phi, \\{\\lambda_i\\}, \\{C_i\\}) \\in S \\times \\prod_{i=1}^H \\Lambda_i \\times \\mathbb{R}^H$。\n\n拉格朗日量被表述为系统的势能加上约束项：\n$$\n\\mathcal{L}(\\phi, \\{\\lambda_i\\}_{i=1}^H, \\{C_i\\}_{i=1}^H) = \\frac{1}{2}\\int_{\\Omega} |\\nabla \\phi|^2 \\,dA - \\int_{\\Omega} q \\phi \\,dA + \\sum_{i=1}^{H} \\int_{\\Gamma_i} \\lambda_i (\\phi - C_i) \\,dS\n$$\n解在该拉格朗日量的驻点处求得。我们对 $\\mathcal{L}$ 的每个变量取变分并令其为零。\n\n1.  **关于 $\\phi$ 的变分**：设 $v \\in S$ 为一个容许的检验函数（变分 $\\delta \\phi$）。\n    $$\n    \\delta_{\\phi} \\mathcal{L} = \\int_{\\Omega} \\nabla \\phi \\cdot \\nabla v \\,dA - \\int_{\\Omega} q v \\,dA + \\sum_{i=1}^{H} \\int_{\\Gamma_i} \\lambda_i v \\,dS = 0 \\quad \\forall v \\in S\n    $$\n    这是泊松方程的弱形式。包含 $\\lambda_i$ 的项来自边界条件的弱施加。在物理上，$\\lambda_i = -\\partial\\phi/\\partial n_i$，表示垂直于孔洞边界的剪应力。\n\n2.  **关于 $\\lambda_i$ 的变分**：设 $\\mu_i \\in \\Lambda_i$ 为一个容许的检验函数（变分 $\\delta \\lambda_i$）。\n    $$\n    \\delta_{\\lambda_i} \\mathcal{L} = \\int_{\\Gamma_i} \\mu_i (\\phi - C_i) \\,dS = 0 \\quad \\forall \\mu_i \\in \\Lambda_i\n    $$\n    该方程弱施加了在边界 $\\Gamma_i$ 上 $\\phi = C_i$ 的约束。\n\n3.  **关于 $C_i$ 的变分**：由于 $C_i$ 是一个标量，其变分 $\\delta C_i$ 是一个任意实数。\n    $$\n    \\delta_{C_i} \\mathcal{L} = \\int_{\\Gamma_i} \\lambda_i (-\\delta C_i) \\,dS = -\\delta C_i \\int_{\\Gamma_i} \\lambda_i \\,dS = 0\n    $$\n    这对任意 $\\delta C_i \\in \\mathbb{R}$ 都必须成立，这意味着可解性条件为：\n    $$\n    \\int_{\\Gamma_i} \\lambda_i \\,dS = 0\n    $$\n    该条件表明，来自每个孔洞的净通量（与总扭矩贡献相关）必须为零，这是获得物理上有意义的解所必需的。\n\n### 第二部分：离散化和系统组装\n\n我们使用双线性四边形单元的结构化网格对区域 $\\Omega$ 进行离散化。函数 $\\phi$ 使用标准连续分片双线性基函数 $N_j(\\mathbf{x})$ 来近似：\n$$\n\\phi(\\mathbf{x}) \\approx \\phi_h(\\mathbf{x}) = \\sum_{j} \\phi_j N_j(\\mathbf{x})\n$$\n其中求和遍及所有不在外边界 $\\partial A$ 上的节点 $j$。每个孔洞边界 $\\Gamma_i$ 上的拉格朗日乘子 $\\lambda_i$ 使用定义在边界边上的分片线性基函数 $\\tilde{N}_k$ 来近似：\n$$\n\\lambda_i(\\mathbf{x}) \\approx \\lambda_{ih}(\\mathbf{x}) = \\sum_{k \\in \\mathcal{N}_i} (\\lambda_i)_k \\tilde{N}_k(\\mathbf{x})\n$$\n其中 $\\mathcal{N}_i$ 是边界 $\\Gamma_i$ 上的节点索引集。\n\n将这些近似代入三个变分方程，得到一个线性代数方程组。未知数是节点值向量 $\\boldsymbol{\\phi}$、节点拉格朗日乘子向量集 $\\{\\boldsymbol{\\lambda}_i\\}_{i=1}^H$ 以及常数向量 $\\mathbf{C} = [C_1, \\dots, C_H]^T$。\n\n方程的离散形式如下：\n1.  **从 $\\delta_\\phi \\mathcal{L} = 0$ 得出**：对于每个对应于未知数 $\\phi_j$ 的基函数 $v=N_j$：\n    $$\n    \\sum_{k} \\left(\\int_{\\Omega} \\nabla N_j \\cdot \\nabla N_k \\,dA\\right) \\phi_k + \\sum_{i=1}^H \\sum_{l \\in \\mathcal{N}_i} \\left(\\int_{\\Gamma_i} N_j \\tilde{N}_l \\,dS\\right) (\\lambda_i)_l = \\int_{\\Omega} q N_j \\,dA\n    $$\n    这构成了分块方程 $K\\boldsymbol{\\phi} + \\sum_i B_i^T \\boldsymbol{\\lambda}_i = \\mathbf{f}$。矩阵 $K$ 是标准刚度矩阵。矩阵 $B_i^T$ 将 $\\Gamma_i$ 上的拉格朗日乘子与 $\\phi$ 的自由度耦合起来。\n\n2.  **从 $\\delta_{\\lambda_i} \\mathcal{L} = 0$ 得出**：对于每个孔洞 $i$ 和每个基函数 $\\mu_i = \\tilde{N}_k$（其中 $k \\in \\mathcal{N}_i$）：\n    $$\n    \\sum_{j} \\left(\\int_{\\Gamma_i} \\tilde{N}_k N_j \\,dS\\right) \\phi_j - C_i \\left(\\int_{\\Gamma_i} \\tilde{N}_k \\,dS\\right) = 0\n    $$\n    这对每个孔洞 $i$ 产生分块方程 $B_i \\boldsymbol{\\phi} - \\mathbf{m}_i C_i = 0$，其中 $\\mathbf{m}_i$ 是积分基函数的向量。问题指定了线积分使用集中质量梯形法则。这使得边界质量矩阵 $\\int_{\\Gamma_i} \\tilde{N}_k N_j \\,dS$ 成为一个对角矩阵，其元素为 $w_k$，其中 $w_k$ 是节点 $k$ 处的积分权重。类似地，$(\\mathbf{m}_i)_k = \\int \\tilde{N}_k dS = w_k$。在 $\\Gamma_i$ 上的节点 $k$ 的方程简化为 $w_k \\phi_k - w_k C_i = 0$，由于 $w_k > 0$，这意味着 $\\phi_k = C_i$。\n\n3.  **从 $\\delta_{C_i} \\mathcal{L} = 0$ 得出**：对于每个孔洞 $i$：\n    $$\n    \\sum_{k \\in \\mathcal{N}_i} \\left(\\int_{\\Gamma_i} \\tilde{N}_k \\,dS\\right) (\\lambda_i)_k = 0 \\quad \\implies \\quad \\sum_{k \\in \\mathcal{N}_i} w_k (\\lambda_i)_k = 0\n    $$\n    这是零均值约束的离散版本，$\\mathbf{m}_i^T \\boldsymbol{\\lambda}_i = 0$。\n\n这三组方程被组装成一个单一的 Karush-Kuhn-Tucker (KKT) 鞍点系统。该矩阵是对称的，但由于与乘子对应的对角块上有零，因此是不定的。\n全局线性系统的结构是：\n$$\n\\begin{pmatrix}\n\\mathbf{K}  \\mathbf{B}^T \\\\\n\\mathbf{B}  \\mathbf{0}\n\\end{pmatrix}\n\\begin{pmatrix}\n\\mathbf{u} \\\\\n\\boldsymbol{\\lambda}_{\\text{aug}}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{f} \\\\\n\\mathbf{g}\n\\end{pmatrix}\n$$\n这里，$\\mathbf{u}$ 代表主变量向量 $\\boldsymbol{\\phi}$。增广拉格朗日乘子向量 $\\boldsymbol{\\lambda}_{\\text{aug}}$ 包括节点乘子 $\\boldsymbol{\\lambda}_i$ 和常数 $C_i$。矩阵 $\\mathbf{B}$ 及其转置，以及右端向量 $\\mathbf{g}$，其结构旨在表示上面推导出的完整约束集。然后同时求解该系统以获得所有未知数。\n\n数值方法的实现包括：\n-   生成网格并按类型识别节点：固定的（外边界）、自由的（区域内部）或属于孔洞边界的。中心在孔洞内的单元被丢弃。\n-   为 $\\phi$、$\\{\\boldsymbol{\\lambda}_i\\}$ 和 $\\{C_i\\}$ 枚举自由度。\n-   使用稀疏格式组装全局 KKT 矩阵。刚度矩阵的贡献使用 $2 \\times 2$ 高斯积分计算。边界耦合项使用集中质量梯形法则计算，其中对于轴对齐的矩形孔洞，边界上每个节点的权重就是网格间距 $h$。\n-   组装右端向量。\n-   求解稀疏线性系统。\n-   对解进行后处理，以计算每个测试案例所需的输出量。区域积分 $I_1$ 通过对每个活动单元的贡献求和来计算，同样使用 $2 \\times 2$ 高斯积分。约束满足度量 $d_i$ 和 $r_i$ 从节点解向量计算得出。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef get_element_stiffness(h):\n    # Computes the 4x4 stiffness matrix for a bilinear square element.\n    # Standard element stiffness matrix for -nabla^2 on a square of side h\n    # This is for an element with nodes ordered (0,0), (1,0), (1,1), (0,1)\n    K_e = np.array([\n        [ 2/3, -1/6, -1/3, -1/6],\n        [-1/6,  2/3, -1/6, -1/3],\n        [-1/3, -1/6,  2/3, -1/6],\n        [-1/6, -1/3, -1/6,  2/3]\n    ])\n    return K_e\n\ndef get_element_rhs(h, q):\n    # Computes the 4x1 load vector for a bilinear square element.\n    # For constant source q, integral is q * Area / 4 at each node\n    return np.full(4, q * h * h / 4.0)\n\ndef solve_system(N, holes, q):\n    # Assembles and solves the mixed FEM system.\n    h = 1.0 / N\n    num_nodes = (N + 1) * (N + 1)\n    node_coords = np.array([(i * h, j * h) for j in range(N + 1) for i in range(N + 1)])\n\n    # Identify node types\n    NODE_INTERIOR, NODE_DIRICHLET, NODE_HOLE_INTERIOR = 0, 1, 2\n    # NODE_HOLE_BOUNDARY_i for each hole\n    node_type = np.full(num_nodes, NODE_INTERIOR, dtype=int)\n    \n    # Outer boundary\n    is_dirichlet = (node_coords[:, 0] == 0) | (node_coords[:, 0] == 1) | \\\n                   (node_coords[:, 1] == 0) | (node_coords[:, 1] == 1)\n    node_type[is_dirichlet] = NODE_DIRICHLET\n\n    hole_boundaries = []\n    for i, hole_spec in enumerate(holes):\n        x1, x2, y1, y2 = hole_spec\n        # Strictly interior nodes\n        is_hole_interior = (node_coords[:, 0] > x1 + 1e-9)  (node_coords[:, 0]  x2 - 1e-9)  \\\n                           (node_coords[:, 1] > y1 + 1e-9)  (node_coords[:, 1]  y2 - 1e-9)\n        node_type[is_hole_interior] = NODE_HOLE_INTERIOR\n        \n        # Boundary nodes\n        on_x1 = np.isclose(node_coords[:, 0], x1)  (node_coords[:, 1] >= y1 - 1e-9)  (node_coords[:, 1] = y2 + 1e-9)\n        on_x2 = np.isclose(node_coords[:, 0], x2)  (node_coords[:, 1] >= y1 - 1e-9)  (node_coords[:, 1] = y2 + 1e-9)\n        on_y1 = np.isclose(node_coords[:, 1], y1)  (node_coords[:, 0] >= x1 - 1e-9)  (node_coords[:, 0] = x2 + 1e-9)\n        on_y2 = np.isclose(node_coords[:, 1], y2)  (node_coords[:, 0] >= x1 - 1e-9)  (node_coords[:, 0] = x2 + 1e-9)\n        is_hole_boundary = on_x1 | on_x2 | on_y1 | on_y2\n        \n        node_type[is_hole_boundary] = NODE_HOLE_INTERIOR + 1 + i\n        hole_boundaries.append(np.where(is_hole_boundary)[0])\n\n    # Identify active elements\n    active_elements = []\n    for j in range(N):\n        for i in range(N):\n            center_x, center_y = (i + 0.5) * h, (j + 0.5) * h\n            is_in_hole = False\n            for x1, x2, y1, y2 in holes:\n                if x1  center_x  x2 and y1  center_y  y2:\n                    is_in_hole = True\n                    break\n            if not is_in_hole:\n                active_elements.append(j * N + i)\n\n    # DOF mapping\n    phi_dofs = np.where((node_type != NODE_DIRICHLET)  (node_type != NODE_HOLE_INTERIOR))[0]\n    num_phi_dofs = len(phi_dofs)\n    node_to_phi_dof = {node_idx: i for i, node_idx in enumerate(phi_dofs)}\n\n    num_lambda_dofs = sum(len(b) for b in hole_boundaries)\n    num_C_dofs = len(holes)\n    total_dofs = num_phi_dofs + num_lambda_dofs + num_C_dofs\n\n    K_sys = lil_matrix((total_dofs, total_dofs))\n    F_sys = np.zeros(total_dofs)\n\n    # Assemble stiffness matrix and RHS for phi\n    K_e = get_element_stiffness(h)\n    f_e = get_element_rhs(h, q)\n    for elem_idx in active_elements:\n        i, j = elem_idx % N, elem_idx // N\n        nodes = [\n            j * (N + 1) + i,        # bottom-left\n            j * (N + 1) + (i + 1),  # bottom-right\n            (j + 1) * (N + 1) + (i + 1),# top-right\n            (j + 1) * (N + 1) + i,  # top-left\n        ]\n        active_nodes_in_elem = [node for node in nodes if node_type[node] != NODE_DIRICHLET and node_type[node] != NODE_HOLE_INTERIOR]\n\n        for u_node in active_nodes_in_elem:\n            u_dof = node_to_phi_dof[u_node]\n            u_local_idx = nodes.index(u_node)\n            F_sys[u_dof] += f_e[u_local_idx]\n            for v_node in active_nodes_in_elem:\n                v_dof = node_to_phi_dof[v_node]\n                v_local_idx = nodes.index(v_node)\n                K_sys[u_dof, v_dof] += K_e[u_local_idx, v_local_idx]\n\n    # Assemble mixed part of the system\n    lambda_dof_start = num_phi_dofs\n    for i, boundary_nodes in enumerate(hole_boundaries):\n        C_dof = num_phi_dofs + num_lambda_dofs + i\n        \n        # Trapezoidal weights\n        weights = np.full(len(boundary_nodes), h)\n\n        lambda_dofs_for_hole = lambda_dof_start + np.arange(len(boundary_nodes))\n\n        for j, node_idx in enumerate(boundary_nodes):\n            phi_dof = node_to_phi_dof[node_idx]\n            lambda_dof = lambda_dof_start + j\n\n            # B^T block for K*phi + B^T*lambda = f\n            # Using lumped mass for B (integral of N_j * \\tilde{N}_l)\n            K_sys[phi_dof, lambda_dof] = weights[j]\n            # B block for B*phi - G*C = 0\n            K_sys[lambda_dof, phi_dof] = weights[j]\n        \n        # G block for B*phi - G*C = 0.\n        # This couples lambda equations with C constants\n        K_sys[lambda_dofs_for_hole, C_dof] = -weights\n        K_sys[C_dof, lambda_dofs_for_hole] = -weights\n        \n        lambda_dof_start += len(boundary_nodes)\n\n    # Solve\n    solution = spsolve(csc_matrix(K_sys), F_sys)\n\n    phi_sol = np.zeros(num_nodes)\n    phi_sol[phi_dofs] = solution[:num_phi_dofs]\n    \n    lambda_sols = {}\n    C_sols = {}\n    lambda_dof_start = num_phi_dofs\n    for i, boundary_nodes in enumerate(hole_boundaries):\n        num_b_nodes = len(boundary_nodes)\n        lambda_sols[i] = solution[lambda_dof_start : lambda_dof_start + num_b_nodes]\n        lambda_dof_start += num_b_nodes\n\n    C_sols = solution[num_phi_dofs + num_lambda_dofs:]\n    \n    return phi_sol, lambda_sols, C_sols, holes, N, active_elements, hole_boundaries\n\ndef compute_case1(phi_sol, N, active_elements):\n    h = 1.0 / N\n    integral = 0\n    # 2x2 Gauss quadrature points and weights\n    gp_coords = (1.0 / np.sqrt(3.0)) * np.array([-1, 1])\n    gp_weights = np.array([1, 1])\n    \n    for elem_idx in active_elements:\n        i, j = elem_idx % N, elem_idx // N\n        node_indices = [j * (N + 1) + i, j * (N + 1) + i + 1, (j + 1) * (N + 1) + i + 1, (j + 1) * (N + 1) + i]\n        elem_phi = phi_sol[node_indices]\n        \n        for p, xi in enumerate(gp_coords):\n            for q, eta in enumerate(gp_coords):\n                N_vals = 0.25 * np.array([(1-xi)*(1-eta), (1+xi)*(1-eta), (1+xi)*(1+eta), (1-xi)*(1+eta)])\n                phi_at_gp = np.dot(N_vals, elem_phi)\n                # Jacobian for square element is constant h*h/4\n                integral += phi_at_gp * (h*h/4.0) * gp_weights[p] * gp_weights[q]\n    return integral\n\ndef compute_case2(phi_sol, lambda_sols, N, hole_boundaries):\n    h = 1.0 / N\n    boundary_nodes = hole_boundaries[0]\n    phi_on_boundary = phi_sol[boundary_nodes]\n    mean_phi = np.mean(phi_on_boundary)\n    d1 = np.max(np.abs(phi_on_boundary - mean_phi))\n    \n    weights = np.full(len(boundary_nodes), h)\n    lambda_on_boundary = lambda_sols[0]\n    r1 = np.abs(np.sum(weights * lambda_on_boundary))\n    return [d1, r1]\n\ndef compute_case3(phi_sol, lambda_sols, N, hole_boundaries):\n    h = 1.0 / N\n    d_vals, r_vals = [], []\n    for i, boundary_nodes in enumerate(hole_boundaries):\n        phi_on_boundary = phi_sol[boundary_nodes]\n        mean_phi = np.mean(phi_on_boundary)\n        d_vals.append(np.max(np.abs(phi_on_boundary - mean_phi)))\n        \n        weights = np.full(len(boundary_nodes), h)\n        lambda_on_boundary = lambda_sols[i]\n        r_vals.append(np.abs(np.sum(weights * lambda_on_boundary)))\n    return [np.max(d_vals), np.max(r_vals)]\n\n\ndef solve():\n    test_cases = [\n        {'N': 8, 'holes': [], 'q': 1.0},\n        {'N': 20, 'holes': [[0.4, 0.6, 0.4, 0.6]], 'q': 1.0},\n        {'N': 30, 'holes': [[0.3, 0.5, 0.3, 0.5], [0.7, 0.8, 0.2, 0.3]], 'q': 1.0},\n    ]\n\n    results = []\n    \n    # Case 1\n    params = test_cases[0]\n    phi_sol, _, _, _, N, active_elements, _ = solve_system(**params)\n    I1 = compute_case1(phi_sol, N, active_elements)\n    results.append(I1)\n\n    # Case 2\n    params = test_cases[1]\n    phi_sol, lambda_sols, _, _, N, _, hole_boundaries = solve_system(**params)\n    d1_r1 = compute_case2(phi_sol, lambda_sols, N, hole_boundaries)\n    results.append(d1_r1)\n    \n    # Case 3\n    params = test_cases[2]\n    phi_sol, lambda_sols, _, _, N, _, hole_boundaries = solve_system(**params)\n    dmax_rmax = compute_case3(phi_sol, lambda_sols, N, hole_boundaries)\n    results.append(dmax_rmax)\n\n    # Format the final output string manually to match the required format.\n    res_str_0 = f\"{results[0]}\"\n    res_str_1 = f\"[{results[1][0]},{results[1][1]}]\"\n    res_str_2 = f\"[{results[2][0]},{results[2][1]}]\"\n    print(f\"[{res_str_0},{res_str_1},{res_str_2}]\")\n\nsolve()\n\n```", "id": "2910829"}]}