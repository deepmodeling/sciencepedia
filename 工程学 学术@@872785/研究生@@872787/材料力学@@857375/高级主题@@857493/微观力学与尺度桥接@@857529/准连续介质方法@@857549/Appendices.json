{"hands_on_practices": [{"introduction": "我们的第一个练习将从最核心的概念入手。您将为一个简化的一维原子链构建一个准连续介质模型，通过少数代表性原子来描述整个系统的行为。这个练习的目标是实践如何基于线性位移插值和柯西-玻恩法则，来计算系统的总能量并推导出节点力 [@problem_id:2923438]。这是理解局部QC方法能量和力计算框架的基础。", "problem": "考虑一个由 $i=0,1,\\ldots,8$ 索引的 $9$ 个原子组成的一维链，其参考位置为 $X_i=i\\,a_0$，其中 $a_0>0$ 是参考最近邻间距。原子间相互作用仅限于最近邻，通过一个仅取决于当前键长 $r$ 的对势 $\\phi(r)$ 来描述。该链通过准连续介质 (QC) 方法 (QuasiContinuum (QC)) 进行粗粒化，使用一个双单元网格，其代表性原子（也称为 repatom）位于 $i=0,4,8$ 处，从而定义了两个单元：单元 $1$ 跨越 $[X_0,X_4]$，单元 $2$ 跨越 $[X_4,X_8]$。假设在每个单元中采用局部 Cauchy-Born 近似，并在代表性原子之间进行位移的线性插值，同时使用计算每个单元中所有最近邻键的均匀权重求和规则。\n\n对势在 $a_0$ 附近是谐和的，即 $\\phi(r)=\\tfrac{1}{2}k\\,(r-a_0)^2$，其中刚度 $k>0$。设代表性原子的位移被指定为 $u_0=0$、 $u_4=\\bar{u}$ 和 $u_8=2\\bar{u}$，其中 $\\bar{u}>0$ 是一个给定的常数。利用这些数据，QC 总势能定义为各单元贡献之和，其中每个单元的贡献是通过计算该单元中的 $4$ 个键得到的，每个键的变形都与该单元的线性位移场一致。\n\n从线性位移场引起的键长变化和 Cauchy-Born 关系的定义出发，推导出作为代表性原子位移函数的 QC 总能量 $E_{\\mathrm{QC}}(u)$。然后，使用特定值 $k=100~\\mathrm{N/m}$、 $a_0=2.5\\times 10^{-10}~\\mathrm{m}$ 和 $\\bar{u}=4.0\\times 10^{-11}~\\mathrm{m}$ 计算 $E_{\\mathrm{QC}}(u)$。最后，通过微分求出在给定_位移下的代表性原子上的内部节点力 $\\mathbf{F}=-\\nabla E_{\\mathrm{QC}}(u)$，并报告三个分量 $F_0$、$F_4$ 和 $F_8$。\n\n答案规格：\n- 能量以 $\\mathrm{J}$ 表示，力以 $\\mathrm{N}$ 表示。\n- 所有报告的量均四舍五入至三位有效数字。\n- 以单行矩阵的形式提供最终答案，首先是 $E_{\\mathrm{QC}}(u)$，然后依次是 $F_0$、$F_4$ 和 $F_8$。", "solution": "首先对问题陈述进行验证。\n\n步骤 1：提取的已知条件。\n- 一个由 $i=0,1,\\ldots,8$ 索引的 $9$ 个原子组成的一维链。\n- 参考位置：$X_i=i\\,a_0$，晶格参数 $a_0>0$。\n- 相互作用势：最近邻谐和对势 $\\phi(r)=\\tfrac{1}{2}k\\,(r-a_0)^2$，刚度 $k>0$。\n- 粗粒化：采用准连续介质 (QC) 方法，代表性原子（repatom）位于索引 $0$、$4$ 和 $8$ 处。\n- 网格：两个单元，单元 1 跨越 $[X_0,X_4]$，单元 2 跨越 $[X_4,X_8]$。\n- 近似：局部 Cauchy-Born 法则及位移的线性插值。\n- 求和规则：均匀权重求和，计算每个单元中的 $4$ 个键。\n- 指定位移：$u_0=0$、$u_4=\\bar{u}$、$u_8=2\\bar{u}$。\n- 常数：$k=100~\\mathrm{N/m}$、$a_0=2.5\\times 10^{-10}~\\mathrm{m}$、$\\bar{u}=4.0\\times 10^{-11}~\\mathrm{m}$。\n- 要求输出：总 QC 能量 $E_{\\mathrm{QC}}(u)$ 和节点力 $F_0$、$F_4$、$F_8$，数值四舍五入至三位有效数字。\n\n步骤 2：使用提取的已知条件进行验证。\n该问题具有科学依据，因为它描述了准连续介质方法的标准应用，这是一种在计算材料科学中成熟的多尺度技术。使用谐和势对应于线性弹性极限，而 Cauchy-Born 近似则是该方法的基本原则。该问题是适定的；它提供了所有必要的数据、参数和边界条件，以得出一个唯一且有意义的解。定义清晰、自洽且一致。例如，单元 1 的域 $[X_0, X_4]$ 包含原子 $0, 1, 2, 3, 4$，因此包含四个最近邻键 $(0,1), (1,2), (2,3), (3,4)$，这与指定的 $4$ 个键的数量一致。单元 2 同样如此。对于原子系统而言，这些数值在物理上是合理的。该问题不违反任何无效标准。\n\n步骤 3：结论与行动。\n问题有效。将推导解答。\n\nQC 总能量 $E_{\\mathrm{QC}}(u)$ 的推导。\n总能量是两个单元能量之和，$E_{\\mathrm{QC}} = E^{(1)} + E^{(2)}$。\n\n对于跨越代表性原子 $0$ 和 $4$ 的单元 1，其参考长度为 $L_1 = X_4 - X_0 = 4a_0$。对于 $X \\in [X_0, X_4]$，位移场 $u(X)$ 假设为线性：\n$$u(X) = u_0 \\left(1 - \\frac{X-X_0}{L_1}\\right) + u_4 \\left(\\frac{X-X_0}{L_1}\\right)$$\n宏观变形梯度 $F$ 在单元内是恒定的，由 $F = 1 + du/dX$ 给出。\n$$F^{(1)} = 1 + \\frac{u_4 - u_0}{X_4 - X_0} = 1 + \\frac{u_4 - u_0}{4a_0}$$\n根据局部 Cauchy-Born 近似，单元中的每个键都根据此宏观梯度变形。变形后的键长 $r^{(1)}$ 为：\n$$r^{(1)} = F^{(1)} a_0 = \\left(1 + \\frac{u_4 - u_0}{4a_0}\\right) a_0 = a_0 + \\frac{u_4 - u_0}{4}$$\n储存在单个此类键中的能量为：\n$$\\phi(r^{(1)}) = \\frac{1}{2}k(r^{(1)} - a_0)^2 = \\frac{1}{2}k\\left(\\frac{u_4 - u_0}{4}\\right)^2$$\n单元 1 包含 $4$ 个键。使用均匀权重求和规则，单元 1 的能量为：\n$$E^{(1)} = 4 \\times \\phi(r^{(1)}) = 4 \\times \\frac{1}{2}k\\frac{(u_4 - u_0)^2}{16} = \\frac{k}{8}(u_4 - u_0)^2$$\n同样，对于跨越代表性原子 $4$ 和 $8$、参考长度为 $L_2 = X_8 - X_4 = 4a_0$ 的单元 2：\n$$F^{(2)} = 1 + \\frac{u_8 - u_4}{X_8 - X_4} = 1 + \\frac{u_8 - u_4}{4a_0}$$\n$$r^{(2)} = F^{(2)} a_0 = a_0 + \\frac{u_8 - u_4}{4}$$\n同样包含 $4$ 个键的单元 2 的能量为：\n$$E^{(2)} = 4 \\times \\frac{1}{2}k(r^{(2)} - a_0)^2 = \\frac{k}{8}(u_8 - u_4)^2$$\nQC 总能量是各单元能量之和：\n$$E_{\\mathrm{QC}}(u_0, u_4, u_8) = E^{(1)} + E^{(2)} = \\frac{k}{8}(u_4 - u_0)^2 + \\frac{k}{8}(u_8 - u_4)^2$$\n\n能量的数值计算。\n代入指定的位移 $u_0=0$、$u_4=\\bar{u}$ 和 $u_8=2\\bar{u}$：\n$$E_{\\mathrm{QC}} = \\frac{k}{8}(\\bar{u} - 0)^2 + \\frac{k}{8}(2\\bar{u} - \\bar{u})^2 = \\frac{k}{8}\\bar{u}^2 + \\frac{k}{8}\\bar{u}^2 = \\frac{k}{4}\\bar{u}^2$$\n使用给定值 $k=100~\\mathrm{N/m}$ 和 $\\bar{u}=4.0\\times 10^{-11}~\\mathrm{m}$：\n$$E_{\\mathrm{QC}} = \\frac{100~\\mathrm{N/m}}{4} (4.0\\times 10^{-11}~\\mathrm{m})^2 = (25~\\mathrm{N/m}) \\times (16.0 \\times 10^{-22}~\\mathrm{m}^2) = 400 \\times 10^{-22}~\\mathrm{J} = 4.0 \\times 10^{-20}~\\mathrm{J}$$\n四舍五入到三位有效数字，能量为 $E_{\\mathrm{QC}} = 4.00 \\times 10^{-20}~\\mathrm{J}$。\n\n节点力的推导与计算。\n代表性原子上的内力由总势能的负梯度给出，$\\mathbf{F} = -\\nabla E_{\\mathrm{QC}}(u)$。其分量为 $F_i = -\\partial E_{\\mathrm{QC}} / \\partial u_i$。\n$$F_0 = -\\frac{\\partial E_{\\mathrm{QC}}}{\\partial u_0} = -\\frac{k}{8} \\cdot 2(u_4-u_0)(-1) = \\frac{k}{4}(u_4 - u_0)$$\n$$F_8 = -\\frac{\\partial E_{\\mathrm{QC}}}{\\partial u_8} = -\\frac{k}{8} \\cdot 2(u_8-u_4)(1) = -\\frac{k}{4}(u_8 - u_4)$$\n$$F_4 = -\\frac{\\partial E_{\\mathrm{QC}}}{\\partial u_4} = -\\left[ \\frac{k}{8} \\cdot 2(u_4-u_0)(1) + \\frac{k}{8} \\cdot 2(u_8-u_4)(-1) \\right] = -\\frac{k}{4}\\left[ (u_4-u_0) - (u_8-u_4) \\right] = -\\frac{k}{4}(2u_4 - u_0 - u_8)$$\n代入指定的位移（$u_0=0, u_4=\\bar{u}, u_8=2\\bar{u}$）和数值：\n$$F_0 = \\frac{k}{4}(\\bar{u} - 0) = \\frac{k}{4}\\bar{u} = \\frac{100}{4}(4.0\\times 10^{-11}) = 25 \\times 4.0\\times 10^{-11} = 100 \\times 10^{-11}~\\mathrm{N} = 1.0 \\times 10^{-9}~\\mathrm{N}$$\n保留三位有效数字，$F_0 = 1.00 \\times 10^{-9}~\\mathrm{N}$。\n\n$$F_8 = -\\frac{k}{4}(2\\bar{u} - \\bar{u}) = -\\frac{k}{4}\\bar{u} = -1.0 \\times 10^{-9}~\\mathrm{N}$$\n保留三位有效数字，$F_8 = -1.00 \\times 10^{-9}~\\mathrm{N}$。\n\n$$F_4 = -\\frac{k}{4}(2\\bar{u} - 0 - 2\\bar{u}) = -\\frac{k}{4}(0) = 0~\\mathrm{N}$$\n力 $F_4$ 精确为零，因为两个单元的应变是均匀的。均匀应变意味着单元 1 施加在代表性原子 4 上的力与单元 2 施加在代表性原子 4 上的力大小相等、方向相反。其值精确为 $0$。\n\n最终结果为 $E_{\\mathrm{QC}} = 4.00 \\times 10^{-20}~\\mathrm{J}$、$F_0 = 1.00 \\times 10^{-9}~\\mathrm{N}$、$F_4 = 0~\\mathrm{N}$ 和 $F_8 = -1.00 \\times 10^{-9}~\\mathrm{N}$。", "answer": "$$\\boxed{\\begin{pmatrix} 4.00 \\times 10^{-20}  1.00 \\times 10^{-9}  0  -1.00 \\times 10^{-9} \\end{pmatrix}}$$", "id": "2923438"}, {"introduction": "在掌握了基本方法后，我们来探讨一个更深刻的挑战，它源于原子间相互作用的复杂性。许多真实材料的力并不仅限于最近邻原子，当模型中包含这种非局域相互作用时，在原子区域和连续介质区域的界面处可能会出现不符合物理规律的“伪力”。这个练习将通过一个精确的分析计算，揭示这种“伪力”的来源，帮助您理解构建精确多尺度模型的关键难点之一 [@problem_id:2678008]。", "problem": "考虑一个一维（$1$D）无限原子链，其参考晶格参数为 $a>0$，原子由索引 $i \\in \\mathbb{Z}$ 标记，参考位置为 $x_i = i a$。形变后的位置表示为 $y_i \\in \\mathbb{R}$。总原子能量是直至次近邻的对偶相互作用之和，\n$$\nE^{\\mathrm{atom}}(y) \\;=\\; \\sum_{i \\in \\mathbb{Z}} \\Big[ \\phi_1\\!\\big(|y_{i+1}-y_i|\\big) + \\phi_2\\!\\big(|y_{i+2}-y_i|\\big) \\Big],\n$$\n其中 $\\phi_1$ 和 $\\phi_2$ 分别是最近邻和次近邻相互作用的光滑对势。力由能量梯度定义，即原子 $i$ 上的力为 $f_i(y) = -\\partial E/\\partial y_i$。\n\n对于一个固定的拉伸 $F>0$，均匀宏观形变由 $y_i = F x_i = F i a$ 给出。在全原子模型中，对称性意味着在这种均匀形变下，对所有 $i$ 都有 $f_i(y)=0$。\n\n将准连续介质（QC）方法中的鬼力定义为在均匀形变下预测出的非零力。构建以下基于能量的一维原子/连续介质 (a/c) 耦合，其界面位于原子区域 $\\mathcal{A} = \\{ i \\in \\mathbb{Z} : i \\le 0 \\}$ 和连续介质区域 $\\mathcal{C} = \\{ i \\in \\mathbb{Z} : i \\ge 1 \\}$ 之间：\n\n- 所有最近邻键在任何地方都精确保留，即每对 $\\{i,i+1\\}$ 对 QC 能量的贡献为 $\\phi_1(|y_{i+1}-y_i|)$。\n\n- 完全包含在 $\\mathcal{A}$ 内的次近邻键贡献精确，即每对满足 $i+2 \\le 0$ 的 $\\{i,i+2\\}$ 贡献 $\\phi_2(|y_{i+2}-y_i|)$。\n\n- 完全包含在 $\\mathcal{C}$ 内的次近邻键由 Cauchy–Born 连续介质能量近似，该能量是 $\\mathcal{C}$ 中恒定形变梯度 $F$ 的函数；具体来说，每个这样的键贡献 $\\phi_2(2Fa)$，并且该连续介质能量仅依赖于 $\\mathcal{C}$ 中的自由度（因此其相对于 $y_0$ 的变分为零）。\n\n- 跨越界面（即一个端点在 $\\mathcal{A}$ 中，另一个在 $\\mathcal{C}$ 中）的次近邻键在 QC 能量中没有明确表示。\n\n在均匀形变 $y_i = F i a$ 下，计算界面原子 $i=0$ 上的 QC 合力。这个非零力是这种基于能量的 QC 耦合中 a/c 界面上的鬼力。以 $F$、$a$ 和在相关键长处求值的势的导数的形式，提供一个单一的闭式解析表达式作为最终答案。最终答案中不要包含单位。如果可以简化，请提供与所述假设一致的最简表达式。", "solution": "问题要求计算在均匀形变下，界面原子 $i=0$ 上的准连续介质（QC）合力。这个力被称为鬼力，因为它在一个完全一致的粗粒化模型中应为零。\n\n首先，验证问题陈述。\n逐字提取给定条件：\n- 系统：一维无限原子链，参考位置为 $x_i = i a$（$i \\in \\mathbb{Z}$，$a>0$）。形变后位置为 $y_i$。\n- 原子能量：$E^{\\mathrm{atom}}(y) = \\sum_{i \\in \\mathbb{Z}} [ \\phi_1(|y_{i+1}-y_i|) + \\phi_2(|y_{i+2}-y_i|) ]$。\n- 力：$f_i(y) = -\\partial E/\\partial y_i$。\n- 均匀形变：$y_i = F x_i = F i a$（$F>0$）。\n- QC 划分：原子区域 $\\mathcal{A} = \\{ i \\in \\mathbb{Z} : i \\le 0 \\}$，连续介质区域 $\\mathcal{C} = \\{ i \\in \\mathbb{Z} : i \\ge 1 \\}$。\n- QC 能量构建：\n    1. 所有最近邻（NN）键 $\\{i,i+1\\}$ 贡献 $\\phi_1(|y_{i+1}-y_i|)$。\n    2. $i \\le -2$ 的次近邻（NNN）键 $\\{i,i+2\\}$ 贡献 $\\phi_2(|y_{i+2}-y_i|)$。\n    3. $i \\ge 1$ 的 NNN 键被近似，其能量贡献相对于 $y_0$ 的变分为零。\n    4. 跨越界面的 NNN 键 $\\{ -1, 1 \\}$ 和 $\\{ 0, 2 \\}$ 在 QC 能量中不被表示。\n\n该问题具有科学依据，提法明确，客观，并包含足够的信息以获得唯一解。这是研究准连续介质方法中的一个标准问题。因此，该问题是有效的。\n\n原子 $k$ 上的力定义为总能量对其位置 $y_k$ 的负梯度：$f_k^{\\mathrm{qc}} = -\\frac{\\partial E^{\\mathrm{qc}}}{\\partial y_k}$。我们被要求计算界面原子 $k=0$ 上的这个力。\n总 QC 能量 $E^{\\mathrm{qc}}$ 根据提供的规则构建：\n$$\nE^{\\mathrm{qc}}(y) = \\sum_{i \\in \\mathbb{Z}} \\phi_1(|y_{i+1}-y_i|) + \\sum_{i \\in \\mathbb{Z}, i \\le -2} \\phi_2(|y_{i+2}-y_i|) + E_{\\mathcal{C}}^{\\mathrm{NNN}}(y_j | j \\ge 1)\n$$\n其中 $E_{\\mathcal{C}}^{\\mathrm{NNN}}$ 是来自连续介质区域 $\\mathcal{C}$ 中 NNN 键的能量，根据定义，它不依赖于 $y_0$。注意，在全原子求和中对应于 $i=-1$ 和 $i=0$ 的跨界面 NNN 键已从此能量表达式中省略。\n\n为了找到原子 $0$ 上的力 $f_0^{\\mathrm{qc}}$，我们必须对 $E^{\\mathrm{qc}}$ 关于 $y_0$ 求导。我们只需要考虑 $E^{\\mathrm{qc}}$ 中是 $y_0$ 函数的项。\n1. 从 NN 相互作用的总和 $\\sum_i \\phi_1(|y_{i+1}-y_i|)$ 中，涉及 $y_0$ 的项是 $i=0$ 和 $i=-1$ 的情况：$\\phi_1(|y_1 - y_0|)$ 和 $\\phi_1(|y_0 - y_{-1}|)$。\n2. 从 $\\mathcal{A}$ 中 NNN 相互作用的总和 $\\sum_{i \\le -2} \\phi_2(|y_{i+2}-y_i|)$ 中，涉及 $y_0$ 的项是当 $i+2=0$ 时，即 $i=-2$。这满足条件 $i \\le -2$。所以，该项为 $\\phi_2(|y_0 - y_{-2}|)$。$i=0$ 的项不在此总和中。\n3. 根据定义，连续介质能量 $E_{\\mathcal{C}}^{\\mathrm{NNN}}$ 有 $\\frac{\\partial E_{\\mathcal{C}}^{\\mathrm{NNN}}}{\\partial y_0} = 0$。\n4. 原子 $0$ 和原子 $2$ 之间的 NNN 相互作用被明确排除。\n\n因此，依赖于 $y_0$ 的 QC 能量部分是：\n$$\nE_{y_0-\\text{dep}}^{\\mathrm{qc}} = \\phi_1(|y_1 - y_0|) + \\phi_1(|y_0 - y_{-1}|) + \\phi_2(|y_0 - y_{-2}|)\n$$\n原子 $0$ 上的力是 $f_0^{\\mathrm{qc}} = -\\frac{\\partial}{\\partial y_0} E_{y_0-\\text{dep}}^{\\mathrm{qc}}$。让我们使用链式法则计算每一项的导数，其中 $\\phi'(r) = \\frac{d\\phi}{dr}(r)$。\n$$\n\\frac{\\partial}{\\partial y_k} \\phi(|y_j - y_i|) = \\phi'(|y_j - y_i|) \\cdot \\mathrm{sgn}(y_j - y_i) \\cdot (\\delta_{kj} - \\delta_{ki})\n$$\n将此应用于我们的项：\n- 对于 $\\phi_1(|y_1-y_0|)$: $i=0, j=1, k=0$。导数为 $\\phi_1'(|y_1-y_0|) \\mathrm{sgn}(y_1-y_0) (-1) = -\\phi_1'(|y_1-y_0|) \\mathrm{sgn}(y_1-y_0)$。\n- 对于 $\\phi_1(|y_0-y_{-1}|)$: $i=-1, j=0, k=0$。导数为 $\\phi_1'(|y_0-y_{-1}|) \\mathrm{sgn}(y_0-y_{-1}) (1) = \\phi_1'(|y_0-y_{-1}|) \\mathrm{sgn}(y_0-y_{-1})$。\n- 对于 $\\phi_2(|y_0-y_{-2}|)$: $i=-2, j=0, k=0$。导数为 $\\phi_2'(|y_0-y_{-2}|) \\mathrm{sgn}(y_0-y_{-2}) (1) = \\phi_2'(|y_0-y_{-2}|) \\mathrm{sgn}(y_0-y_{-2})$。\n\n将这些导数相加得到 $\\frac{\\partial E^{\\mathrm{qc}}}{\\partial y_0}$。力是这个和的负值：\n$$\nf_0^{\\mathrm{qc}} = -\\left[ -\\phi_1'(|y_1-y_0|)\\mathrm{sgn}(y_1-y_0) + \\phi_1'(|y_0-y_{-1}|)\\mathrm{sgn}(y_0-y_{-1}) + \\phi_2'(|y_0-y_{-2}|)\\mathrm{sgn}(y_0-y_{-2}) \\right]\n$$\n现在，我们在均匀形变 $y_i = F i a$（其中 $F>0$ 且 $a>0$）下计算此表达式。\n- 键长 $y_1 - y_0 = F(1)a - F(0)a = Fa$。由于 $Fa>0$，所以 $|y_1-y_0| = Fa$ 且 $\\mathrm{sgn}(y_1-y_0)=1$。\n- 键长 $y_0 - y_{-1} = F(0)a - F(-1)a = Fa$。由于 $Fa>0$，所以 $|y_0-y_{-1}| = Fa$ 且 $\\mathrm{sgn}(y_0-y_{-1})=1$。\n- 键长 $y_0 - y_{-2} = F(0)a - F(-2)a = 2Fa$。由于 $2Fa>0$，所以 $|y_0-y_{-2}| = 2Fa$ 且 $\\mathrm{sgn}(y_0-y_{-2})=1$。\n\n将这些代入力表达式：\n$$\nf_0^{\\mathrm{qc}} = -\\left[ -\\phi_1'(Fa) \\cdot (1) + \\phi_1'(Fa) \\cdot (1) + \\phi_2'(2Fa) \\cdot (1) \\right]\n$$\n$$\nf_0^{\\mathrm{qc}} = -\\left[ -\\phi_1'(Fa) + \\phi_1'(Fa) + \\phi_2'(2Fa) \\right]\n$$\n$$\nf_0^{\\mathrm{qc}} = - [ 0 + \\phi_2'(2Fa) ] = -\\phi_2'(2Fa)\n$$\n这个非零力就是界面上的鬼力。它产生的原因是 QC 能量公式中缺少了来自原子 $2$ 对原子 $0$ 的力贡献，破坏了全原子系统中存在的力平衡。在原子系统中，来自原子 $2$ 对原子 $0$ 的力将是 $\\phi_2'(|y_2-y_0|)\\mathrm{sgn}(y_2-y_0) = \\phi_2'(2Fa)$，这恰好是在均匀形变下作用于原子 $0$ 上的所有其他力的总和的负值，从而确保总力为零。QC 方法省略了这一个相互作用项，导致了计算出的残余力。\n最终表达式以 $F$、$a$ 和在 NNN 键长 $2Fa$ 处求值的势 $\\phi_2$ 的导数表示。", "answer": "$$\n\\boxed{-\\phi_2'(2Fa)}\n$$", "id": "2678008"}, {"introduction": "本章的最后一个练习将引导您构建一个真正意义上的“智能”多尺度模拟。面对材料中的缺陷（如位错或裂纹），其周围的变形场高度非均匀，全局采用连续介质模型会失效，而完全采用原子模拟又过于昂贵。这个实践要求您设计并实现一个自适应算法，该算法能够自动识别并细化最需要原子精度描述的区域，从而在保证精度的同时最大限度地提高计算效率 [@problem_id:2923446]。", "problem": "您必须从第一性原理出发，设计并实现一种自适应拟连续介质算法。该算法基于缺陷活动性指标来扩展原子区域，并在含单个缺陷键的一维谐波链上验证其有效性。您的程序必须是一个完整、可运行的实现，它无需任何输入，并按如下规定产生单行输出。\n\n物理系统是一个由 $N$ 个原子组成的一维链，其参考位置为 $x_i = i a$，其中 $i \\in \\{0,1,\\dots,N-1\\}$，晶格间距 $a$ 取为 $a=1$ (无量纲)。该链由最近邻谐波弹簧连接。原子 $i$ 和 $i+1$ 之间的键能由 $\\frac{1}{2} k_i \\left( u_{i+1} - u_i \\right)^2$ 给出，其中 $u_i$ 是原子 $i$ 的位移，$k_i$ 是键刚度。除位于索引 $d$ 处的一个刚度为 $\\alpha k$ ($0 < \\alpha \\le 1$) 的缺陷键外，所有键的刚度均为 $k$。系统施加狄利克雷边界条件：左边界位移为 $u_0 = 0$，右边界位移为 $u_{N-1} = U$，其中 $U$ 是给定的 (无量纲)。完全原子尺度平衡定义为在这些边界条件下，总能量 $\\mathcal{E}(u) = \\frac{1}{2}\\sum_{i=0}^{N-2} k_i \\left( u_{i+1} - u_i \\right)^2$ 的最小化子。\n\n在拟连续介质 (QC) 近似中，您必须使用简化的自由度 (DOF) 集合来表示位移。定义一个初始原子核心区，它是缺陷键周围的一个连续原子集，由初始半径 $r_0$ 参数化，使得初始原子集包含索引 $j$ 满足 $j \\in [\\max(1, d-r_0), \\min(N-2, d+1+r_0)]$ 的原子。在原子集之外，使用代表性原子 (repatoms) 定义一个粗化表示，这些代表性原子以原子索引计量的整数步长 $m \\ge 1$ 分布。所有未包含在活性自由度集（由原子区域中的原子和代表性原子组成，不包括固定的边界原子）中的原子，其位移必须通过在其由活性自由度和边界原子组成的支撑集中的最近邻居之间进行线性插值得到。这会从简化自由度向量到完整位移向量产生一个仿射映射，将其代入总能量后，得到一个简化的二次能量，通过最小化该能量可获得 QC 平衡。\n\n使用受约束原子（即非活性自由度且非边界原子）上的完全原子尺度内力残差来定义缺陷活动性指标。设与原子链相关的全局刚度矩阵为 $K \\in \\mathbb{R}^{N \\times N}$，它是通过离散梯度算子，以标准方式由键刚度 $k_i$ 组装而成。给定一个与边界条件一致的 QC 位移向量 $u^{\\mathrm{QC}} \\in \\mathbb{R}^N$，原子 $j$ 处的内力残差定义为 $f_j = - \\left( K u^{\\mathrm{QC}} \\right)_j$。对于粗化区域，较大的 $|f_j|$ 幅值表示更强的非局域非平衡，因此更需要进行细化。您的自适应算法必须迭代执行以下步骤：\n-   通过最小化简化的 QC 能量（边界条件为 $u_0 = 0$ 和 $u_{N-1} = U$）来计算 $u^{\\mathrm{QC}}$，\n-   计算残差向量 $f$，\n-   在受约束原子集合 $\\mathcal{C}$ 中，识别出具有最大指标值 $\\max_{j \\in \\mathcal{C}} |f_j|$ 的原子 $j^\\star$，\n-   如果 $\\max_{j \\in \\mathcal{C}} |f_j| \\le \\tau$（容差），则终止；否则，将 $j^\\star$ 加入原子集以扩展原子区域，并重复此过程。\n\n您必须使用的基本原理是：保守系统中的能量最小化、内力定义为能量对位移的负梯度，以及简化 QC 近似中的线性插值约束。除了这些基本原理外，您不得假设或使用任何专门的拟连续介质公式；所有步骤都必须从这些原理推导出来。\n\n您的程序必须：\n- 从键刚度 $k_i$ 组装完全原子尺度刚度矩阵 $K$。\n- 通过在边界约束下最小化总能量（等效于求解相关的线性系统），计算完全原子尺度的参考解 $u^{\\mathrm{ref}}$。\n- 通过构造线性算子 $T \\in \\mathbb{R}^{N \\times n_{\\mathrm{act}}}$ 和偏移向量 $c \\in \\mathbb{R}^N$ 来实现 QC 映射，使得 $u = T q + c$，其中 $q \\in \\mathbb{R}^{n_{\\mathrm{act}}}$ 是活性自由度（不包括固定的边界自由度）。对于受约束的原子，插值必须在相邻支撑索引之间是严格线性的。\n- 将 $u = T q + c$ 代入总能量，建立并求解关于 $q$ 的简化线性系统，即求解 $T^\\top K T \\, q = - T^\\top K c$。\n- 实现上述自适应增长策略，直到满足停止准则或原子区域覆盖所有内部原子。\n- 在终止时，通过计算相对位移误差 $e = \\| u^{\\mathrm{QC}} - u^{\\mathrm{ref}} \\|_2 / \\| u^{\\mathrm{ref}} \\|_2$ 来量化自适应算法的有效性。\n\n使用以下参数集测试套件，每个参数集指定为一个元组 $(N, d, \\alpha, k, U, r_0, m, \\tau)$：\n- 案例 A (理想路径): $(101, 50, 0.2, 1.0, 0.1, 1, 10, 10^{-3})$。\n- 案例 B (宽松容差边界情况): $(101, 50, 0.2, 1.0, 0.1, 1, 10, 10^{2})$。\n- 案例 C (严格容差边界情况): $(101, 50, 0.2, 1.0, 0.1, 1, 10, 10^{-12})$。\n\n对于每种情况，运行上述自适应 QC 算法，并计算终止时的相对误差 $e$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [案例 A 结果, 案例 B 结果, 案例 C 结果]。每个结果必须是格式化为具有六位有效数字的科学记数法的浮点数。\n\n此问题中没有物理单位；所有量均为无量纲。不涉及角度。最终输出是普通浮点数，而不是百分比。整个实现和计算必须是自包含的，不需要输入文件或用户交互。", "solution": "所提出的问题是计算力学领域一个适定且科学合理的研究练习，具体涉及自适应拟连续介质 (QC) 方法的实现。它基于保守系统中的能量最小化这一已确立的第一性原理，以及将控制方程通过伽辽金投影到简化基上。所有的定义和参数都已明确无误地给出，从而可以得到直接且可验证的计算解。因此，该问题被认为是有效的。\n\n该解决方案分三个阶段展开：首先，构建完全原子尺度问题，以提供参考解；其次，构建拟连续介质近似及其简化的方程组；第三，详细说明用于迭代细化 QC 模型的自适应算法。\n\n### 1. 完全原子尺度构建\n\n物理系统是一个由 $N$ 个原子组成的一维链。总势能 $\\mathcal{E}$ 是存储在最近邻谐波键中的能量之和：\n$$\n\\mathcal{E}(u) = \\frac{1}{2}\\sum_{i=0}^{N-2} k_i (u_{i+1} - u_i)^2\n$$\n其中 $u_i$ 是原子 $i$ 的位移，$k_i$ 是原子 $i$ 和 $i+1$ 之间键的刚度。该表达式是位移向量 $u \\in \\mathbb{R}^N$ 的一个二次型。我们可以使用离散梯度算子 $B \\in \\mathbb{R}^{(N-1) \\times N}$ 来书写此能量，该算子将节点位移向量映射到键伸长向量。能量则为：\n$$\n\\mathcal{E}(u) = \\frac{1}{2} (Bu)^\\top K_b (Bu) = \\frac{1}{2} u^\\top (B^\\top K_b B) u\n$$\n其中 $K_b = \\mathrm{diag}(k_0, k_1, \\dots, k_{N-2})$ 是键刚度的对角矩阵。由此可确定全局原子尺度刚度矩阵为 $K = B^\\top K_b B \\in \\mathbb{R}^{N \\times N}$。这个三对角矩阵的元素由下式给出：\n$$\nK_{j,j} = k_{j-1} + k_j \\quad (\\text{for } 1 \\le j \\le N-2)\n$$\n$$\nK_{j, j+1} = K_{j+1, j} = -k_j \\quad (\\text{for } 0 \\le j \\le N-2)\n$$\n边界原子 $j=0$ 和 $j=N-1$ 的形式特殊。\n\n平衡态是通过在狄利克雷边界条件 $u_0=0$ 和 $u_{N-1}=U$ 约束下最小化 $\\mathcal{E}(u)$ 求得的。这等效于求解关于未知内部位移 $u_j$（其中 $j \\in \\{1, \\dots, N-2\\}$）的线性方程组 $\\nabla_u \\mathcal{E} = 0$。将自由度划分为内部自由度 $u_I = [u_1, \\dots, u_{N-2}]^\\top$ 和边界自由度 $u_B = [u_0, u_{N-1}]^\\top = [0, U]^\\top$，内部节点的平衡方程为：\n$$\nK_{II} u_I = - K_{IB} u_B\n$$\n其中 $K_{II}$ 是 $K$ 中对应于内部-内部相互作用的子矩阵，$K_{IB}$ 对应于内部-边界相互作用。求解这个 $(N-2) \\times (N-2)$ 的线性系统可以得到参考位移向量 $u^{\\mathrm{ref}} = [0, u_I^\\top, U]^\\top$。矩阵 $K_{II}$ 是正定的，保证了唯一解的存在。\n\n### 2. 拟连续介质 (QC) 构建\n\nQC 方法通过用较少数量的活性自由度 (DOF) $q \\in \\mathbb{R}^{n_{\\mathrm{act}}}$ 来描述系统，从而降低了计算成本。这些自由度对应于一个选定的原子子集 $\\mathcal{I}_{\\mathrm{act}} \\subset \\{1, \\dots, N-2\\}$（称为活性原子）的位移。剩余的内部原子被指定为受约束原子。\n\n所有原子的位移由活性自由度 $q$ 和给定的边界条件确定。任何受约束原子的位移是通过在其支撑集 $\\mathcal{I}_{\\mathrm{supp}} = \\mathcal{I}_{\\mathrm{act}} \\cup \\{0, N-1\\}$ 中的最近邻居之间进行分段线性插值得到的。这定义了一个线性运动学约束，可以表示为矩阵形式：\n$$\nu = Tq + c\n$$\n其中 $T \\in \\mathbb{R}^{N \\times n_{\\mathrm{act}}}$ 是插值矩阵，$c \\in \\mathbb{R}^N$ 是施加边界条件的向量。对于与 $q$ 中第 $k$ 个自由度对应的活性原子 $j_k \\in \\mathcal{I}_{\\mathrm{act}}$，其映射是简单的：$u_{j_k} = q_k$。对于一个受约束的原子 $j$，其位移为 $u_j = (1-\\lambda)u_{j_L} + \\lambda u_{j_R}$，其中 $j_L$ 和 $j_R$ 是包围 $j$ 的最近支撑原子的索引，并且由于晶格间距 $a=1$，$\\lambda = (j - j_L) / (j_R - j_L)$。矩阵 $T$ 和向量 $c$ 被构造出来以编码所有原子的这些关系。\n\n将试探解 $u=Tq+c$ 代入完全原子尺度的能量泛函，得到简化能量 $\\mathcal{E}_{\\mathrm{QC}}(q)$：\n$$\n\\mathcal{E}_{\\mathrm{QC}}(q) = \\frac{1}{2} (Tq+c)^\\top K (Tq+c)\n$$\n通过设置 $\\nabla_q \\mathcal{E}_{\\mathrm{QC}}(q) = 0$ 来最小化此二次能量关于 $q$ 的函数，得到 QC 近似的简化线性方程组：\n$$\n(T^\\top K T) q = - (T^\\top K c)\n$$\n求解该系统可得到活性位移向量 $q$，由此可重构出完整位移场 $u^{\\mathrm{QC}} = Tq + c$。\n\n### 3. 自适应细化算法\n\nQC 近似的精度取决于活性原子的选择。采用一种自适应策略来丰富近似效果较差区域的活性集。近似的质量通过受约束节点上的完全原子尺度力残差来评估。\n\n原子 $j$ 上的内力为 $f_j = -\\frac{\\partial \\mathcal{E}}{\\partial u_j} = -(Ku)_j$。对于处于理想平衡状态的系统，所有内力均为零（在没有外部点力的情况下）。在 QC 近似中，力平衡仅在活性自由度上以加权残差的意义上被强制执行。因此，在受约束原子 $j \\in \\mathcal{C}$ 上可能存在非零的力残差 $f_j = -(K u^{\\mathrm{QC}})_j$。其幅值 $|f_j|$ 可作为误差指标。大的残差表明线性插值约束在该位置是不充分的。\n\n自适应算法按以下步骤进行：\n1.  用一组活性原子 $\\mathcal{I}_{\\mathrm{act}}$ 初始化模型，该集合包含缺陷周围的原子区域和一组粗化的代表性原子。\n2.  在一个迭代循环中：\n    a.  为当前的活性集构造插值矩阵 $T$ 和边界条件向量 $c$。\n    b.  组装并求解简化系统 $(T^\\top K T) q = - (T^\\top K c)$ 以获得 $q$。\n    c.  重构完整位移场 $u^{\\mathrm{QC}} = Tq + c$。\n    d.  计算力残差向量 $f = -K u^{\\mathrm{QC}}$。\n    e.  识别具有最大残差幅值的受约束原子 $j^\\star$：$\\max_{j \\in \\mathcal{C}} |f_j|$。\n    f.  如果此最大残差小于或等于预设容差 $\\tau$，或者如果没有更多受约束的原子，则模拟终止。\n    g.  否则，将原子 $j^\\star$ 添加到原子集（并因此添加到 $\\mathcal{I}_{\\mathrm{act}}$）中，并从步骤（a）开始重复循环。\n\n终止时，最终自适应解 $u^{\\mathrm{QC}}$ 的质量通过计算其相对于精确原子解 $u^{\\mathrm{ref}}$ 的相对误差来量化：\n$$\ne = \\frac{\\| u^{\\mathrm{QC}} - u^{\\mathrm{ref}} \\|_2}{\\| u^{\\mathrm{ref}} \\|_2}\n$$\n此方案提供了一种系统性的方法，通过仅在必要的地方集中计算资源，来达到期望的精度水平。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve\n\ndef solve_problem():\n    \"\"\"\n    Main function to run the adaptive quasicontinuum simulation for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        # (N, d, alpha, k, U, r0, m, tau)\n        (101, 50, 0.2, 1.0, 0.1, 1, 10, 1e-3),   # Case A\n        (101, 50, 0.2, 1.0, 0.1, 1, 10, 1e2),    # Case B\n        (101, 50, 0.2, 1.0, 0.1, 1, 10, 1e-12),  # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        N, d, alpha, k, U, r0, m, tau = params\n        \n        # 1. Assemble bond stiffnesses and full atomistic stiffness matrix K\n        k_vals = np.full(N - 1, k)\n        k_vals[d] = alpha * k\n\n        K = np.zeros((N, N))\n        for i in range(N - 1):\n            ki = k_vals[i]\n            K[i, i] += ki\n            K[i + 1, i + 1] += ki\n            K[i, i + 1] -= ki\n            K[i + 1, i] -= ki\n\n        # 2. Compute the full atomistic reference solution u_ref\n        K_int = K[1:N-1, 1:N-1]\n        b_int = np.zeros(N - 2)\n        b_int[-1] = k_vals[N - 2] * U\n        u_int = solve(K_int, b_int, assume_a='sym')\n        u_ref = np.zeros(N)\n        u_ref[1:N-1] = u_int\n        u_ref[N-1] = U\n        \n        norm_u_ref = np.linalg.norm(u_ref)\n\n        # 3. Adaptive QC loop\n        atom_indices = set(range(max(1, d - r0), min(N - 2, d + 1 + r0) + 1))\n        \n        u_qc = np.zeros(N) # Initialize u_qc\n\n        while True:\n            # Define active and constrained sets for the current iteration\n            rep_indices = set(range(m, N - 1, m))\n            active_indices = sorted(list(atom_indices.union(rep_indices)))\n            \n            all_interior_indices = set(range(1, N - 1))\n            constrained_indices = sorted(list(all_interior_indices - set(active_indices)))\n            \n            # Check for loop termination based on full refinement\n            if not constrained_indices:\n                # All interior nodes are active, QC solution is the full solution\n                u_qc = np.copy(u_ref)\n                break\n\n            n_act = len(active_indices)\n            act_map = {idx: i for i, idx in enumerate(active_indices)}\n            \n            support_indices = np.array([0] + active_indices + [N - 1])\n\n            # Construct T and c matrices\n            T = np.zeros((N, n_act))\n            c = np.zeros(N)\n            c[N-1] = U\n\n            for j in range(1, N - 1):\n                if j in act_map:\n                    T[j, act_map[j]] = 1.0\n                else: # j is constrained\n                    # Find bracketing support nodes using searchsorted\n                    # This is efficient for sorted support_indices\n                    idx_right = np.searchsorted(support_indices, j)\n                    jR = support_indices[idx_right]\n                    jL = support_indices[idx_right - 1]\n                    \n                    lam = (j - jL) / (jR - jL)\n\n                    if jL in act_map:\n                        T[j, act_map[jL]] = 1.0 - lam\n                    # if jL is 0, u0=0, so no contribution to T or c\n                    \n                    if jR in act_map:\n                        T[j, act_map[jR]] = lam\n                    elif jR == N - 1:\n                        c[j] = lam * U\n\n            # Solve reduced QC system\n            K_qc = T.T @ K @ T\n            f_qc = -T.T @ K @ c\n            q = solve(K_qc, f_qc, assume_a='sym')\n            \n            # Reconstruct full QC displacement vector\n            u_qc = T @ q + c\n            \n            # Compute force residuals and check termination criterion\n            residuals = -(K @ u_qc)\n            \n            constrained_residuals = np.abs(residuals[constrained_indices])\n            max_residual = np.max(constrained_residuals)\n\n            if max_residual = tau:\n                break\n\n            # Find atom with max residual and add to atomistic set for refinement\n            j_star_local_idx = np.argmax(constrained_residuals)\n            j_star = constrained_indices[j_star_local_idx]\n            atom_indices.add(j_star)\n        \n        # 4. Calculate final relative error\n        if norm_u_ref > 0:\n            error = np.linalg.norm(u_qc - u_ref) / norm_u_ref\n        else:\n            error = np.linalg.norm(u_qc - u_ref)\n\n        results.append(f\"{error:.5e}\")\n\n    print(f\"[{','.join(results)}]\")\n\n\nsolve_problem()\n```", "id": "2923446"}]}