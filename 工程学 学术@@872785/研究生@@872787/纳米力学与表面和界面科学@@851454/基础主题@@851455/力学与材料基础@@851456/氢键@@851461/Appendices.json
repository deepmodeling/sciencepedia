{"hands_on_practices": [{"introduction": "要定量地理解氢键，我们必须建立能够描述其能量与原子间距关系的数学模型。本练习将指导你通过组合Lennard-Jones势和一个简化的静电吸引项，来构建一个代表性的氢键相互作用模型。通过分析这个势能函数，你将练习一个核心技能：通过最小化势能来确定平衡构型，并计算解离能，这是理解所有化学键强度的基础。[@problem_id:123489]", "problem": "一个用于描述氢键（例如N-H···O键）的简化一维模型，将相互作用势能描述为两个重原子（N和O）之间距离 $r$ 的函数。这个势能 $U(r)$ 是范德华项和静电项之和。\n\n1.  范德华相互作用由标准的 Lennard-Jones (LJ) 势描述：\n    $$\n    U_{LJ}(r) = 4\\epsilon \\left[ \\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^{6} \\right]\n    $$\n    此处，$\\epsilon$ 是 LJ 势阱的深度，$\\sigma$ 是 LJ 势为零时的距离。\n\n2.  氢键的方向性、强静电特性由一个等效的吸引势建模，该势由下式给出：\n    $$\n    U_{elec}(r) = -\\frac{A}{r^6}\n    $$\n    其中 $A$ 是一个正常数，代表了这种特定静电相互作用的强度。\n\nN-O 相互作用的总势能是这两项贡献之和：\n$$\nU(r) = U_{LJ}(r) + U_{elec}(r)\n$$\n\n解离能 $D_e$ 定义为将两个重原子从其平衡距离 $r_e$ 分离到无穷远处所需的能量。考虑到无穷远分离处的势能为零，解离能等于平衡距离处势能的负值，即 $D_e = -U(r_e)$。\n\n计算此氢键模型的解离能 $D_e$。请用参数 $\\epsilon$、$\\sigma$ 和 $A$ 将您的答案表示为一个闭合形式的解析表达式。", "solution": "解离能由 $ D_e = -U(r_e) $ 给出，其中 $ r_e $ 是满足 $ \\frac{dU}{dr} \\big|_{r=r_e} = 0 $ 的平衡距离。总势能为：\n\n$$\nU(r) = 4\\epsilon \\left[ \\left( \\frac{\\sigma}{r} \\right)^{12} - \\left( \\frac{\\sigma}{r} \\right)^6 \\right] - \\frac{A}{r^6}\n$$\n\n将 $ U(r) $ 用 $ r^{-6} $ 表示：\n\n$$\nU(r) = 4\\epsilon \\sigma^{12} r^{-12} - 4\\epsilon \\sigma^6 r^{-6} - A r^{-6} = 4\\epsilon \\sigma^{12} (r^{-6})^2 - (4\\epsilon \\sigma^6 + A) r^{-6}\n$$\n\n令 $ x = r^{-6} $，则：\n\n$$\nU = 4\\epsilon \\sigma^{12} x^2 - (4\\epsilon \\sigma^6 + A) x\n$$\n\n对 $ r $ 的导数为：\n\n$$\n\\frac{dU}{dr} = \\frac{dU}{dx} \\frac{dx}{dr} = \\left[ 8\\epsilon \\sigma^{12} x - (4\\epsilon \\sigma^6 + A) \\right] \\cdot (-6 r^{-7})\n$$\n\n在平衡状态下，$ \\frac{dU}{dr} = 0 $，这意味着：\n\n$$\n8\\epsilon \\sigma^{12} x_e - (4\\epsilon \\sigma^6 + A) = 0\n$$\n\n其中 $ x_e = r_e^{-6} $。解出 $ x_e $：\n\n$$\nx_e = \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}}\n$$\n\n现在，计算 $ U(r_e) $：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} x_e^2 - (4\\epsilon \\sigma^6 + A) x_e\n$$\n\n代入 $ x_e $：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} \\left( \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}} \\right)^2 - (4\\epsilon \\sigma^6 + A) \\left( \\frac{4\\epsilon \\sigma^6 + A}{8\\epsilon \\sigma^{12}} \\right)\n$$\n\n化简：\n\n$$\nU(r_e) = 4\\epsilon \\sigma^{12} \\cdot \\frac{(4\\epsilon \\sigma^6 + A)^2}{64 \\epsilon^2 \\sigma^{24}} - \\frac{(4\\epsilon \\sigma^6 + A)^2}{8\\epsilon \\sigma^{12}} = \\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}} - \\frac{(4\\epsilon \\sigma^6 + A)^2}{8\\epsilon \\sigma^{12}}\n$$\n\n\n$$\nU(r_e) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{\\sigma^{12}} \\left( \\frac{1}{16\\epsilon} - \\frac{1}{8\\epsilon} \\right) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{\\sigma^{12}} \\left( -\\frac{1}{16\\epsilon} \\right) = -\\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}}\n$$\n\n因此，解离能为：\n\n$$\nD_e = -U(r_e) = \\frac{(4\\epsilon \\sigma^6 + A)^2}{16\\epsilon \\sigma^{12}}\n$$\n\n展开分子：\n\n$$\n(4\\epsilon \\sigma^6 + A)^2 = 16\\epsilon^2 \\sigma^{12} + 8\\epsilon \\sigma^6 A + A^2\n$$\n\n所以：\n\n$$\nD_e = \\frac{16\\epsilon^2 \\sigma^{12} + 8\\epsilon \\sigma^6 A + A^2}{16\\epsilon \\sigma^{12}} = \\epsilon + \\frac{A}{2\\sigma^6} + \\frac{A^2}{16\\epsilon \\sigma^{12}}\n$$", "answer": "$$\n\\boxed{\\epsilon + \\frac{A}{2\\sigma^{6}} + \\frac{A^{2}}{16\\epsilon \\sigma^{12}}}\n$$", "id": "123489"}, {"introduction": "超越经典的势能图像，氢键的行为在根本上受量子力学规律的支配，尤其体现在其振动特性上。此练习将引导你探究一个重要的量子效应：同位素取代对化学键振动零点能的影响。通过将O-H和O-D键简化为量子谐振子并计算其零点能的比率，你将亲身体会到原子核质量如何通过量子效应对键的性质产生显著影响，这是理解动力学同位素效应的关键一步。[@problem_id:123633]", "problem": "共价键的伸缩振动，例如水和许多生物系统中的O-H键，可以被有效地建模为量子谐振子。这个模型对于理解光谱性质以及同位素取代的热力学效应至关重要。\n\n考虑一个O-H键的伸缩模式。其振动动力学由有效弹性常数 $k$ 和折合质量 $\\mu_{OH}$ 来表征。现在，假设我们用氢原子（H）的重同位素氘（D）来替换它，形成一个O-D键。根据 Born-Oppenheimer 近似，决定化学键的势能面是由电子分布决定的，而电子分布几乎不受原子核质量变化的影响。因此，O-D键的弹性常数 $k$ 与O-H键的相同。\n\n设质子的质量为 $m_p$。对于本题，我们将原子核质量近似如下：氢原子核的质量为 $m_H = m_p$，氘原子核的质量为 $m_D = 2m_p$，最常见的氧同位素原子核的质量为 $m_O = 16m_p$。与原子核质量相比，电子的质量可以忽略不计。\n\n计算O-H伸缩振动的零点能与O-D伸缩振动的零点能的精确比值，$\\mathcal{R} = \\frac{E_{ZPE, OH}}{E_{ZPE, OD}}$。", "solution": "量子谐振子的零点能由下式给出：\n$$ E_{ZPE} = \\frac{1}{2} h \\nu $$\n其中 $ h $ 是普朗克常数，$ \\nu $ 是振动频率。\n\n振动频率 $ \\nu $ 为：\n$$ \\nu = \\frac{1}{2\\pi} \\sqrt{\\frac{k}{\\mu}} $$\n其中 $ k $ 是弹性常数，$ \\mu $ 是折合质量。\n\n将 $ \\nu $ 代入 $ E_{ZPE} $：\n$$ E_{ZPE} = \\frac{1}{2} h \\left( \\frac{1}{2\\pi} \\sqrt{\\frac{k}{\\mu}} \\right) = \\frac{h}{4\\pi} \\sqrt{\\frac{k}{\\mu}} $$\n\n比值 $ \\mathcal{R} $ 定义为：\n$$ \\mathcal{R} = \\frac{E_{ZPE, OH}}{E_{ZPE, OD}} = \\frac{ \\frac{h}{4\\pi} \\sqrt{\\frac{k}{\\mu_{OH}}} }{ \\frac{h}{4\\pi} \\sqrt{\\frac{k}{\\mu_{OD}}} } = \\sqrt{ \\frac{\\mu_{OD}}{\\mu_{OH}} } $$\n\n双原子分子 A-B 的折合质量为：\n$$ \\mu = \\frac{m_A m_B}{m_A + m_B} $$\n\n已知：\n- 氢原子核质量 $ m_H = m_p $\n- 氘原子核质量 $ m_D = 2m_p $\n- 氧原子核质量 $ m_O = 16m_p $\n\n对于 O-H：\n$$ \\mu_{OH} = \\frac{m_O m_H}{m_O + m_H} = \\frac{16m_p \\cdot m_p}{16m_p + m_p} = \\frac{16m_p^2}{17m_p} = \\frac{16}{17} m_p $$\n\n对于 O-D：\n$$ \\mu_{OD} = \\frac{m_O m_D}{m_O + m_D} = \\frac{16m_p \\cdot 2m_p}{16m_p + 2m_p} = \\frac{32m_p^2}{18m_p} = \\frac{32}{18} m_p = \\frac{16}{9} m_p $$\n\n折合质量之比为：\n$$ \\frac{\\mu_{OD}}{\\mu_{OH}} = \\frac{ \\frac{16}{9} m_p }{ \\frac{16}{17} m_p } = \\frac{16}{9} \\cdot \\frac{17}{16} = \\frac{17}{9} $$\n\n因此：\n$$ \\mathcal{R} = \\sqrt{ \\frac{\\mu_{OD}}{\\mu_{OH}} } = \\sqrt{ \\frac{17}{9} } = \\frac{\\sqrt{17}}{3} $$", "answer": "$$ \\boxed{\\dfrac{\\sqrt{17}}{3}} $$", "id": "123633"}, {"introduction": "在真实的凝聚相体系（如液态水或生物界面）中，氢键网络处于持续断裂与重组的动态平衡之中，而非静止不动。本练习将带你进入计算化学与统计力学的前沿，学习如何从分子动力学模拟产生的轨迹数据中定量分析氢键的寿命。你将通过编程实现时间相关函数的计算，并辨析“间歇性”与“连续”两种寿命定义的物理含义，这对于深刻理解液体和界面处复杂的动力学过程至关重要。[@problem_id:2773802]", "problem": "给定一个液-固界面上氢键 (HB) 存在的离散时间表示。对于一个由 $\\alpha$ 索引的供体-受体对系综，定义二元指示函数 $h_{\\alpha}(t)$：如果 $\\alpha$ 对之间的特定氢键在时间 $t$ 存在，则其值为 $1$，否则为 $0$。考虑一个持续 $N$ 个时间步长的均匀采样轨迹，采样周期为 $\\Delta t$，因此 $t_n = n\\,\\Delta t$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。下面提供的所有数组均已筛选，仅包含界面氢键。\n\n仅使用以下基础定义：\n- 将双时间相关性定义为在初始状态条件下对系综进行的平均。\n- 使用间距为 $\\Delta t$ 的离散和对时间积分进行黎曼和近似。\n\n为延迟指数 $k \\in \\{0,1,\\dots,N-1\\}$ 定义间歇和连续氢键时间相关函数，作为对所有有效时间起点和所有对的条件期望：\n- 间歇相关函数 $C_{\\mathrm{i}}(k\\,\\Delta t)$ 是指，在一个氢键于 $t_n$ 时刻存在的条件下，它在 $t_{n+k}$ 时刻仍然存在的条件概率，该概率在所有对和所有满足 $n+k \\le N-1$ 的有效时间起点 $n$ 上取平均。形式上，\n$$\nC_{\\mathrm{i}}(k\\,\\Delta t) \\equiv \\left\\langle \\frac{h_{\\alpha}(t_{n+k})}{1} \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}.\n$$\n- 连续存活相关函数 $C_{\\mathrm{c}}(k\\,\\Delta t)$ 是指，在一个氢键于 $t_n$ 时刻存在的条件下，它在整个区间 $[t_n,t_{n+k}]$ 内保持未断裂的条件概率，该概率在所有对和有效时间起点上取平均。使用乘积来强制实现不间断的键合，\n$$\nC_{\\mathrm{c}}(k\\,\\Delta t) \\equiv \\left\\langle \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}.\n$$\n如果对于给定的 $k$ 不存在有效的时间起点（即，不存在满足 $h_{\\alpha}(t_n)=1$ 和 $n+k \\le N-1$ 的 $\\alpha,n$），则定义 $C_{\\mathrm{i}}(k\\,\\Delta t)=0$ 和 $C_{\\mathrm{c}}(k\\,\\Delta t)=0$。\n\n将平均氢键寿命定义为相关函数的时间积分，\n$$\n\\tau \\equiv \\int_{0}^{\\infty} C(t)\\,dt,\n$$\n并根据离散轨迹，通过黎曼和进行估算\n$$\n\\tau \\approx \\sum_{k=0}^{N-1} C(k\\,\\Delta t)\\,\\Delta t,\n$$\n分别针对间歇和连续定义进行计算。\n\n实现一个程序，为每个提供的测试用例，使用上述定义计算间歇和连续寿命。所有最终寿命均以皮秒 (ps) 为单位表示，并四舍五入到六位小数。\n\n输入作为一组测试用例直接嵌入程序中。每个测试用例指定了 $\\Delta t$（单位为ps）和一份氢键指示序列列表，每个序列对应一个对，长度为 $N$。请精确使用以下测试套件：\n\n- 测试用例 A（正常路径，间歇性重键合）：\n  - $\\Delta t = 0.5\\,\\mathrm{ps}$\n  - 对数 $M=2$\n  - 轨迹：\n    - 对 $1$：$\\{1,1,0,1,1,0\\}$\n    - 对 $2$：$\\{0,1,0,1,0,1\\}$\n- 测试用例 B（边界情况，始终键合）：\n  - $\\Delta t = 0.2\\,\\mathrm{ps}$\n  - 对数 $M=2$\n  - 轨迹：\n    - 对 $1$：$\\{1,1,1,1,1\\}$\n    - 对 $2$：$\\{1,1,1,1,1\\}$\n- 测试用例 C（边界情况，从未键合）：\n  - $\\Delta t = 0.5\\,\\mathrm{ps}$\n  - 对数 $M=3$\n  - 轨迹：\n    - 对 $1$：$\\{0,0,0,0\\}$\n    - 对 $2$：$\\{0,0,0,0\\}$\n    - 对 $3$：$\\{0,0,0,0\\}$\n- 测试用例 D（边缘情况，立即断裂且不重键合）：\n  - $\\Delta t = 1.0\\,\\mathrm{ps}$\n  - 对数 $M=1$\n  - 轨迹：\n    - 对 $1$：$\\{1,0,0,0\\}$\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，值按以下顺序排列：\n- 对于 A、B、C、D 顺序中的每个测试用例，首先附加连续寿命 $\\tau_{\\mathrm{c}}$，然后是间歇寿命 $\\tau_{\\mathrm{i}}$，两者都以 ps 为单位，并四舍五入到六位小数。\n- 因此，输出具有扁平结构 $[\\tau_{\\mathrm{c}}^{\\mathrm{A}},\\tau_{\\mathrm{i}}^{\\mathrm{A}},\\tau_{\\mathrm{c}}^{\\mathrm{B}},\\tau_{\\mathrm{i}}^{\\mathrm{B}},\\tau_{\\mathrm{c}}^{\\mathrm{C}},\\tau_{\\mathrm{i}}^{\\mathrm{C}},\\tau_{\\mathrm{c}}^{\\mathrm{D}},\\tau_{\\mathrm{i}}^{\\mathrm{D}}]$，不含空格。", "solution": "我们从所提供的第一性原理出发，推导计算算法。问题定义了两种关于氢键 (HB) 存在性的时间相关函数：$C_{\\mathrm{i}}(t)$ 和 $C_{\\mathrm{c}}(t)$。它们被定义为对由 $\\alpha$ 索引的供体-受体对系综，以及离散时间起点 $t_n=n\\Delta t$ 的条件期望。\n\n二元指示函数 $h_{\\alpha}(t_n)$ 在 $\\alpha$ 对的氢键于时间 $t_n$ 存在时为 $1$，否则为 $0$。每个对 $\\alpha$ 的轨迹是一个长度为 $N$ 的序列 $\\{h_{\\alpha}(t_n)\\}_{n=0}^{N-1}$。\n\n对于一个延迟时间 $k\\Delta t$，间歇相关函数由下式给出：\n$$\nC_{\\mathrm{i}}(k\\,\\Delta t) = \\left\\langle h_{\\alpha}(t_{n+k}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}\n$$\n连续相关函数为：\n$$\nC_{\\mathrm{c}}(k\\,\\Delta t) = \\left\\langle \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\,\\middle|\\, h_{\\alpha}(t_n)=1 \\right\\rangle_{\\alpha,n}\n$$\n\n符号 $\\langle \\cdot \\rangle_{\\alpha,n}$ 表示对所有对 $\\alpha$ 和所有有效时间起点 $n$ 的平均。对于一个延迟指数 $k$，如果 $n+k \\leq N-1$，则时间起点 $t_n$ 是有效的。条件期望 $\\langle X | A \\rangle$ 的计算方法是：将条件 $A$ 为真的所有事件的结果 $X$ 相加，然后除以这类事件的总数。\n\n将此应用于我们的离散系统，对于给定的延迟指数 $k \\in \\{0, 1, \\dots, N-1\\}$，我们必须对所有对 $\\alpha \\in \\{1, \\dots, M\\}$ 和所有时间起点 $n \\in \\{0, 1, \\dots, N-1-k\\}$ 进行求和。\n\n两个相关函数的分母是在有效时间起点存在氢键的实例总数，它作为归一化因子。这可以表示为：\n$$\n\\text{Denominator}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)\n$$\n如果对于给定的 $k$，此分母为零，则相关函数定义为零。\n\n间歇相关函数 $C_{\\mathrm{i}}$ 的分子是，在 $t_n$ 存在氢键的条件下，延迟时间 $t_{n+k}$ 的氢键存在指示符的总和。这等价于对乘积 $h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)$ 求和：\n$$\n\\text{Numerator}_{\\mathrm{i}}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)\n$$\n\n连续相关函数 $C_{\\mathrm{c}}$ 的分子要求氢键在整个区间 $[t_n, t_{n+k}]$ 内持续存在不中断。这通过区间内指示函数的乘积来体现：\n$$\n\\text{Numerator}_{\\mathrm{c}}(k) = \\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} \\left( \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s}) \\right)\n$$\n请注意，该乘积项隐含了条件 $h_{\\alpha}(t_n)=1$，因为只要有任何一项为零，整个乘积就变为零。\n\n因此，相关函数的完整表达式为：\n$$\nC_{\\mathrm{i}}(k\\Delta t) = \\frac{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_{n+k}) h_{\\alpha}(t_n)}{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)}\n$$\n$$\nC_{\\mathrm{c}}(k\\Delta t) = \\frac{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} \\prod_{s=0}^{k} h_{\\alpha}(t_{n+s})}{\\sum_{\\alpha=1}^{M} \\sum_{n=0}^{N-1-k} h_{\\alpha}(t_n)}\n$$\n\n最后，平均氢键寿命 $\\tau$ 通过对所有计算出的延迟时间上的相应相关函数进行黎曼和来估算：\n$$\n\\tau \\approx \\sum_{k=0}^{N-1} C(k\\,\\Delta t)\\,\\Delta t\n$$\n这会分别使用 $C_{\\mathrm{i}}$ 计算 $\\tau_{\\mathrm{i}}$ 和使用 $C_{\\mathrm{c}}$ 计算 $\\tau_{\\mathrm{c}}$。\n\n实现将包含一个函数，该函数以轨迹和时间步长 $\\Delta t$ 作为输入。轨迹表示为一个 $M \\times N$ 的矩阵。该函数将遍历从 $0$ 到 $N-1$ 的每个延迟指数 $k$。对于每个 $k$，它将通过迭代所有对 $\\alpha$ 和所有有效时间起点 $n$ 来计算分子和分母。在计算出数组 $C_{\\mathrm{i}}(k\\Delta t)$ 和 $C_{\\mathrm{c}}(k\\Delta t)$ 之后，它将执行最终的求和并乘以 $\\Delta t$，以获得寿命 $\\tau_{\\mathrm{i}}$ 和 $\\tau_{\\mathrm{c}}$。然后，每个测试用例的结果将按指定格式进行格式化。", "answer": "```python\nimport numpy as np\n\ndef calculate_lifetimes(trajectories: list[list[int]], delta_t: float) -> tuple[float, float]:\n    \"\"\"\n    Computes the continuous and intermittent HB lifetimes from trajectory data.\n\n    Args:\n        trajectories: A list of lists, where each inner list is a binary\n                      indicator sequence h_alpha(t) for a donor-acceptor pair.\n        delta_t: The time step between trajectory frames, in picoseconds.\n\n    Returns:\n        A tuple containing (tau_c, tau_i), the continuous and intermittent\n        lifetimes in picoseconds.\n    \"\"\"\n    if not trajectories or not trajectories[0]:\n        return 0.0, 0.0\n\n    h = np.array(trajectories, dtype=np.int8)\n    num_pairs, num_steps = h.shape\n\n    C_intermittent = np.zeros(num_steps, dtype=np.float64)\n    C_continuous = np.zeros(num_steps, dtype=np.float64)\n\n    for k in range(num_steps):\n        numerator_i = 0\n        numerator_c = 0\n        denominator = 0\n        \n        # The maximum valid time origin index 'n' for a given lag 'k'\n        max_n = num_steps - 1 - k\n        if max_n  0:\n            continue\n\n        for alpha in range(num_pairs):\n            for n in range(max_n + 1):\n                # Condition: HB exists at the time origin t_n\n                if h[alpha, n] == 1:\n                    denominator += 1\n                    \n                    # Intermittent case: check for HB existence at t_{n+k}\n                    if h[alpha, n + k] == 1:\n                        numerator_i += 1\n                        \n                    # Continuous case: check for uninterrupted HB from t_n to t_{n+k}\n                    # The product is 1 if and only if all elements are 1.\n                    if np.all(h[alpha, n : n + k + 1] == 1):\n                        numerator_c += 1\n                        \n        if denominator > 0:\n            C_intermittent[k] = numerator_i / denominator\n            C_continuous[k] = numerator_c / denominator\n        # If denominator is 0, correlation is defined as 0. Arrays are pre-filled with 0.\n\n    # Calculate lifetimes using Riemann sum approximation\n    tau_i = np.sum(C_intermittent) * delta_t\n    tau_c = np.sum(C_continuous) * delta_t\n    \n    return tau_c, tau_i\n\ndef solve():\n    \"\"\"\n    Runs the predefined test suite and prints the results in the specified format.\n    \"\"\"\n    test_cases = {\n        'A': {\n            'delta_t': 0.5,\n            'trajectories': [\n                [1, 1, 0, 1, 1, 0],\n                [0, 1, 0, 1, 0, 1]\n            ]\n        },\n        'B': {\n            'delta_t': 0.2,\n            'trajectories': [\n                [1, 1, 1, 1, 1],\n                [1, 1, 1, 1, 1]\n            ]\n        },\n        'C': {\n            'delta_t': 0.5,\n            'trajectories': [\n                [0, 0, 0, 0],\n                [0, 0, 0, 0],\n                [0, 0, 0, 0]\n            ]\n        },\n        'D': {\n            'delta_t': 1.0,\n            'trajectories': [\n                [1, 0, 0, 0]\n            ]\n        }\n    }\n\n    results = []\n    case_order = ['A', 'B', 'C', 'D']\n\n    for case_id in case_order:\n        case = test_cases[case_id]\n        tau_c, tau_i = calculate_lifetimes(case['trajectories'], case['delta_t'])\n        \n        # Append results formatted to six decimal places\n        results.append(f\"{tau_c:.6f}\")\n        results.append(f\"{tau_i:.6f}\")\n        \n    # Print the final output in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2773802"}]}