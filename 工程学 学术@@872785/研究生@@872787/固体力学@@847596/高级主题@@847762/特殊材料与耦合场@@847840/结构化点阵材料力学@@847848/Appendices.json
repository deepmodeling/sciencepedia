{"hands_on_practices": [{"introduction": "要理解点阵材料的力学行为，我们首先必须确定其稳定性。本练习将介绍麦克斯韦-卡拉丹指标定理，这是一个用于将点阵分类为欠约束、过约束或静定的强大工具。通过将线性代数的基本原理应用于经典的 Kagome 点阵，你将推导出内部机构与自应力状态之间的关系，从而深刻洞察点阵的刚度。[@problem_id:2660252]", "problem": "一个二维 Kagome 晶格由刚性、销接杆的无限周期性排列构成，这些杆在六边形网格上组装成三角形。考虑一个原始周期性晶胞，在无限晶格中，根据标准晶体学计数约定，每个晶胞计数一次，该晶胞包含 $n_{n} = 3$ 个不同的接头（节点）和 $n_{b} = 6$ 个不同的杆（边）。该晶格是平面的，接头是理想的无摩擦销钉，杆是不可伸长的。假设其几何构型为一般的 Kagome 网格（除了 Kagome 排列固有的共线情况外，没有偶然的共线情况），并将注意力限制在零布洛赫波矢情况（均匀、晶胞周期的形变），采用周期性边界条件，使得晶胞范围的刚性平移和旋转不作为允许的内禀机构出现。\n\n定义 $m$ 为在零波矢下每个晶胞的独立无穷小机构数（零杆伸长模式），$s$ 为每个晶胞的独立自应力状态数（产生零节点合力的非平凡杆张力）。令 $\\mathbf{C}$ 表示将节点位移分量映射到杆伸长量的协调矩阵，令 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$ 表示将杆张力映射到节点力的平衡（静力）矩阵。\n\n仅从以下几点出发：\n- 一个自由平面节点具有 $d = 2$ 个位移分量的运动学计数。\n- 由秩-零度定理所蕴含的，$\\mathbf{C}$ 和 $\\mathbf{A}$ 的零度与秩之间的线性代数关系。\n- 根据 $\\mathbf{C}$ 和 $\\mathbf{A}$ 的零空间对 $m$ 和 $s$ 的物理定义。\n\n推导此周期性 Kagome 晶胞的标量 $m - s$ 并进行数值计算。只报告 $m - s$ 的值。无需四舍五入。最终答案必须是一个无单位的整数。", "solution": "该问题陈述经过验证，被认为是有效的。它具有科学依据、良定、客观且内部一致。它为推导所求量 $m - s$ 提供了所有必要的信息。我们现在开始求解。\n\n该问题关注周期性力学框架中无穷小机构与自应力状态之间的关系。推导过程仅依赖于线性代数原理和所提供的定义。\n\n令 $\\mathbf{u}$ 为晶胞的节点位移分量向量。对于一个二维系统（$d=2$），每个晶胞有 $n_{n}$ 个节点，总自由度数为 $d n_{n}$。问题陈述指出，分析是在零布洛赫波矢下进行的，并应用了周期性边界条件，使得晶胞范围的刚性平移和旋转被排除。因此，位移向量 $\\mathbf{u}$ 的维度是 $d n_{n}$。\n给定 $n_{n} = 3$ 和 $d=2$，$\\mathbf{u}$ 的大小为 $d n_{n} = 2 \\times 3 = 6$。所以，$\\mathbf{u} \\in \\mathbb{R}^{6}$。\n\n令 $\\mathbf{e}$ 为杆伸长量向量。晶胞包含 $n_{b}$ 个杆。给定 $n_{b} = 6$，伸长量向量 $\\mathbf{e}$ 的大小为 $6$。所以，$\\mathbf{e} \\in \\mathbb{R}^{6}$。\n\n协调矩阵 $\\mathbf{C}$ 根据线性关系 $\\mathbf{e} = \\mathbf{C} \\mathbf{u}$ 将节点位移映射到杆伸长量。为使此映射有效，矩阵 $\\mathbf{C}$ 的维度必须是 $n_{b} \\times (d n_{n})$，即 $6 \\times 6$。\n\n独立无穷小机构数 $m$ 定义为不引起任何杆伸长（$\\mathbf{e} = \\mathbf{0}$）的独立、非零位移向量 $\\mathbf{u}$ 的数量。这些是晶格的零能形变模式。在数学上，这些向量 $\\mathbf{u}$ 构成了协调矩阵 $\\mathbf{C}$ 的零空间（或核）。此类独立模式的数量是该零空间的维度。\n$$m = \\dim(\\operatorname{null}(\\mathbf{C}))$$\n\n现在，考虑静力平衡。令 $\\mathbf{t}$ 为 $n_{b} = 6$ 个杆中的标量张力向量，所以 $\\mathbf{t} \\in \\mathbb{R}^{6}$。令 $\\mathbf{f}$ 为 $n_{n}=3$ 个节点上的合力向量。由于每个节点有 $d=2$ 个力分量，力向量 $\\mathbf{f}$ 的维度为 $d n_{n} = 6$，所以 $\\mathbf{f} \\in \\mathbb{R}^{6}$。\n\n平衡矩阵 $\\mathbf{A}$ 将杆张力映射到节点力：$\\mathbf{f} = \\mathbf{A} \\mathbf{t}$。$\\mathbf{A}$ 的维度必须是 $(d n_{n}) \\times n_{b}$，即 $6 \\times 6$。问题陈述中 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$，这是由虚功原理得出的一个基本结果，确保了运动学和静力学之间的一致性。\n\n自应力状态数 $s$ 定义为导致所有节点合力为零（$\\mathbf{f} = \\mathbf{0}$）的独立、非零张力向量 $\\mathbf{t}$ 的数量。这些是具有内应力但没有外部载荷的平衡状态。在数学上，这些向量 $\\mathbf{t}$ 构成了平衡矩阵 $\\mathbf{A}$ 的零空间。此类独立状态的数量是该零空间的维度。\n$$s = \\dim(\\operatorname{null}(\\mathbf{A}))$$\n\n我们现在对矩阵 $\\mathbf{C}$ 和 $\\mathbf{A}$ 应用线性代数中的秩-零度定理。\n对于有 $d n_{n}$ 列的矩阵 $\\mathbf{C}$：\n$$\\operatorname{rank}(\\mathbf{C}) + \\dim(\\operatorname{null}(\\mathbf{C})) = d n_{n}$$\n代入 $m$ 的定义：\n$$\\operatorname{rank}(\\mathbf{C}) + m = d n_{n} \\quad (1)$$\n\n对于有 $n_{b}$ 列的矩阵 $\\mathbf{A}$：\n$$\\operatorname{rank}(\\mathbf{A}) + \\dim(\\operatorname{null}(\\mathbf{A})) = n_{b}$$\n代入 $s$ 的定义：\n$$\\operatorname{rank}(\\mathbf{A}) + s = n_{b} \\quad (2)$$\n\n任何矩阵的一个基本性质是其秩等于其转置矩阵的秩。因为给定 $\\mathbf{A} = \\mathbf{C}^{\\mathsf{T}}$，可得：\n$$\\operatorname{rank}(\\mathbf{A}) = \\operatorname{rank}(\\mathbf{C}^{\\mathsf{T}}) = \\operatorname{rank}(\\mathbf{C})$$\n\n令 $r = \\operatorname{rank}(\\mathbf{C}) = \\operatorname{rank}(\\mathbf{A})$ 为这两个矩阵的共同秩。\n从方程（1）中，我们可以将 $m$ 表示为：\n$$m = d n_{n} - r$$\n从方程（2）中，我们可以将 $s$ 表示为：\n$$s = n_{b} - r$$\n\n问题要求解 $m - s$。我们用 $m$ 的表达式减去 $s$ 的表达式：\n$$m - s = (d n_{n} - r) - (n_{b} - r)$$\n$$m - s = d n_{n} - r - n_{b} + r$$\n$$m - s = d n_{n} - n_{b}$$\n这个结果是周期性晶格的一个普适关系，通常被称为 Maxwell-Calladine 指数定理。\n\n对于平面 Kagome 晶格晶胞，我们已知以下数值：\n- 空间维度：$d = 2$。\n- 每个晶胞的节点数：$n_{n} = 3$。\n- 每个晶胞的杆数：$n_{b} = 6$。\n\n将这些数值代入推导出的表达式：\n$$m - s = (2)(3) - 6$$\n$$m - s = 6 - 6$$\n$$m - s = 0$$\n\n所述周期性 Kagome 晶胞的标量 $m - s$ 为 $0$。", "answer": "$$\\boxed{0}$$", "id": "2660252"}, {"introduction": "在线性稳定性之外，先进结构材料的设计常常利用非线性来实现如状态切换等新颖功能。本练习将通过一个简单单元中的几何不相容性来探索双稳态的起源。通过从第一性原理推导其势能图景，你将确定稳定和不稳定的平衡点，并计算控制状态间转换所需的能垒。[@problem_id:2660237]", "problem": "考虑一个平面内理想化的构筑晶格单胞，它由一个可动节点和两个连接到固定支座的相同、销接的细长杆件组成。固定支座位于笛卡尔坐标系中的坐标 $\\left(-a,\\,0\\right)$ 和 $\\left(a,\\,0\\right)$ 处。可动节点被约束沿竖直对称线 $x=0$ 运动，其竖直位置为广义坐标 $q$。每个细长杆件被建模为一个轴向线性弹性弹簧，其轴向刚度为 $k$，自然（无应力）长度为 $l_{0}$。杆件通过理想无摩擦销连接，不承受任何弯矩。系统中没有外部载荷；唯一的能量是杆件的轴向应变能。假设 $l_{0}  a$，以便该单胞可以通过几何不相容性表现出双稳态。\n\n从固体力学的第一性原理出发，即几何运动学和轴向弹簧的应变能，推导该单胞的总势能 $U(q)$ 作为广义坐标 $q$ 的函数。通过求解 $\\mathrm{d}U/\\mathrm{d}q=0$ 确定所有驻点，并用二阶导数判别法对其进行分类。在给定的几何条件 $l_{0}  a$ 下，找出两个稳定平衡点以及连接这两个稳定状态的最小能量路径上的不稳定平衡点。\n\n将两个稳定状态之间的能垒定义为位于它们之间的不稳定平衡点与任一稳定平衡点之间的总势能差。以闭合形式计算此能垒。\n\n以 $k$、$a$ 和 $l_{0}$ 的单个符号表达式报告能垒。如果进行数值计算，假设 $k$ 的单位为牛顿/米，$a$ 和 $l_{0}$ 的单位为米，则能量以焦耳表示。不要四舍五入；提供精确的符号结果。", "solution": "该问题陈述是一个将固体力学基本原理应用于简单双稳态结构系统的适定练习。它有科学依据、内容自洽，并且没有任何逻辑矛盾或事实错误。所有必需的参数和约束都已明确定义。因此，该问题是有效的，将从第一性原理推导求解。\n\n系统由一个位于坐标 $\\left(0, q\\right)$ 的可动节点组成，该节点通过两个相同的杆件连接到位于 $\\left(-a, 0\\right)$ 和 $\\left(a, 0\\right)$ 的固定支座。节点的竖直位置 $q$ 是唯一的广义坐标。\n\n首先，我们建立运动学关系。每个杆件的长度 $l$ 是广义坐标 $q$ 的函数。根据勾股定理，可动节点 $\\left(0, q\\right)$ 与一个固定支座（例如 $\\left(a, 0\\right)$）之间的距离由下式给出：\n$$\nl(q) = \\sqrt{\\left(a - 0\\right)^{2} + \\left(0 - q\\right)^{2}} = \\sqrt{a^{2} + q^{2}}\n$$\n由于对称性，两个杆件的长度相同。\n\n接下来，我们建立系统的势能。每个杆件是轴向刚度为 $k$、自然长度为 $l_{0}$ 的轴向弹簧。储存在单个弹簧中的应变能 $U_{s}$ 是其伸长量的函数，伸长量是其当前长度 $l(q)$ 与自然长度 $l_{0}$ 之差。线性弹簧的应变能公式为：\n$$\nU_{s} = \\frac{1}{2} k \\left(l(q) - l_{0}\\right)^{2}\n$$\n系统的总势能 $U(q)$ 是两个相同杆件中应变能的总和。由于没有外部载荷，总势能完全是应变能。\n$$\nU(q) = 2 \\times U_{s} = 2 \\times \\frac{1}{2} k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)^{2}\n$$\n$$\nU(q) = k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)^{2}\n$$\n这个表达式表示了单胞的总势能作为广义坐标 $q$ 的函数。\n\n为了找到平衡构型，我们必须找到势能函数 $U(q)$ 的驻点。这通过求解 $U(q)$ 对 $q$ 的一阶导数的根来完成。使用链式求导法则：\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = k \\cdot 2 \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right) \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}q}\\left(\\sqrt{a^{2} + q^{2}}\\right)\n$$\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 2k \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right) \\left(\\frac{1}{2\\sqrt{a^{2} + q^{2}}} \\cdot 2q\\right)\n$$\n$$\n\\frac{\\mathrm{d}U}{\\mathrm{d}q} = \\frac{2kq \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)}{\\sqrt{a^{2} + q^{2}}}\n$$\n令 $\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 0$ 来寻找驻点：\n$$\n\\frac{2kq \\left(\\sqrt{a^{2} + q^{2}} - l_{0}\\right)}{\\sqrt{a^{2} + q^{2}}} = 0\n$$\n如果分子为零，则该方程成立。有两种可能性：\n1. $q = 0$。\n2. $\\sqrt{a^{2} + q^{2}} - l_{0} = 0 \\implies \\sqrt{a^{2} + q^{2}} = l_{0}$。\n将第二种可能性的两边平方得到 $a^{2} + q^{2} = l_{0}^{2}$，从而得出 $q^{2} = l_{0}^{2} - a^{2}$。这给出了 $q$ 的两个解：\n$$\nq = \\pm\\sqrt{l_{0}^{2} - a^{2}}\n$$\n这些解是实数，因为题目说明 $l_{0}  a$，这保证了 $l_{0}^{2} - a^{2}  0$。\n因此，存在三个驻点：$q_{1} = 0$，$q_{2} = \\sqrt{l_{0}^{2} - a^{2}}$ 和 $q_{3} = -\\sqrt{l_{0}^{2} - a^{2}}$。\n\n为了对这些驻点进行分类，我们使用二阶导数判别法。我们计算势能的二阶导数 $\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}$。\n从 $\\frac{\\mathrm{d}U}{\\mathrm{d}q} = 2k\\left(q - \\frac{ql_{0}}{\\sqrt{a^{2} + q^{2}}}\\right)$ 出发：\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\frac{\\mathrm{d}}{\\mathrm{d}q}\\left(q - ql_{0}\\left(a^{2} + q^{2}\\right)^{-1/2}\\right)\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - l_{0}\\left(\\left(a^{2} + q^{2}\\right)^{-1/2} + q \\cdot \\left(-\\frac{1}{2}\\right)\\left(a^{2} + q^{2}\\right)^{-3/2}(2q)\\right)\\right]\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - l_{0}\\left(\\frac{1}{\\sqrt{a^{2} + q^{2}}} - \\frac{q^{2}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right)\\right]\n$$\n$$\n\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}} = 2k \\left[1 - l_{0}\\frac{a^{2} + q^{2} - q^{2}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right] = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(a^{2} + q^{2}\\right)^{3/2}}\\right)\n$$\n现在我们判断二阶导数在每个驻点处的符号。\n- 对于 $q = 0$：\n$$\n\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=0} = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(a^{2}\\right)^{3/2}}\\right) = 2k \\left(1 - \\frac{a^{2}l_{0}}{a^{3}}\\right) = 2k \\left(1 - \\frac{l_{0}}{a}\\right)\n$$\n由于 $l_{0}  a$，我们有 $\\frac{l_{0}}{a}  1$，这意味着 $(1 - \\frac{l_{0}}{a})  0$。因此，$\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=0}  0$，表明 $q = 0$ 对应于一个不稳定平衡点（势能的局部极大值）。\n\n- 对于 $q = \\pm\\sqrt{l_{0}^{2} - a^{2}}$：\n对于这些点，我们有 $q^{2} = l_{0}^{2} - a^{2}$，这意味着 $a^{2} + q^{2} = l_{0}^{2}$。将此代入二阶导数表达式：\n$$\n\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q^{2}=l_{0}^{2}-a^{2}} = 2k \\left(1 - \\frac{a^{2}l_{0}}{\\left(l_{0}^{2}\\right)^{3/2}}\\right) = 2k \\left(1 - \\frac{a^{2}l_{0}}{l_{0}^{3}}\\right) = 2k \\left(1 - \\frac{a^{2}}{l_{0}^{2}}\\right)\n$$\n由于 $l_{0}  a$，我们有 $l_{0}^{2}  a^{2}$ 且 $\\frac{a^{2}}{l_{0}^{2}}  1$。因此，$\\left(1 - \\frac{a^{2}}{l_{0}^{2}}\\right)  0$。所以，$\\left.\\frac{\\mathrm{d}^{2}U}{\\mathrm{d}q^{2}}\\right|_{q=\\pm\\sqrt{l_0^2-a^2}}  0$，表明这两点对应于稳定平衡点（势能的局部极小值）。\n\n两个稳定平衡点位于 $q_{\\text{stable}} = \\pm\\sqrt{l_{0}^{2} - a^{2}}$，连接它们的不稳定平衡点位于 $q_{\\text{unstable}} = 0$。\n\n能垒 $\\Delta U$ 是不稳定平衡点和稳定平衡点之间的势能差。\n首先，我们计算稳定平衡点 $q_{\\text{stable}}$ 处的能量：\n$$\nU(q_{\\text{stable}}) = k \\left(\\sqrt{a^{2} + \\left(l_{0}^{2} - a^{2}\\right)} - l_{0}\\right)^{2} = k \\left(\\sqrt{l_{0}^{2}} - l_{0}\\right)^{2} = k \\left(l_{0} - l_{0}\\right)^{2} = 0\n$$\n在稳定平衡点处能量为零，因为此时杆件处于其自然、无应力的长度 $l_{0}$。\n\n接下来，我们计算不稳定平衡点 $q_{\\text{unstable}} = 0$ 处的能量：\n$$\nU(q_{\\text{unstable}}) = U(0) = k \\left(\\sqrt{a^{2} + 0^{2}} - l_{0}\\right)^{2} = k \\left(a - l_{0}\\right)^{2}\n$$\n能垒是其差值：\n$$\n\\Delta U = U(q_{\\text{unstable}}) - U(q_{\\text{stable}}) = k \\left(a - l_{0}\\right)^{2} - 0 = k \\left(a - l_{0}\\right)^{2}\n$$\n这个表达式等价于 $k \\left(l_{0} - a\\right)^{2}$。\n这是将杆件从其稳定、无应变构型压缩到 $q=0$ 处的平坦构型所需的能量，从而克服几何锁定以过渡到另一个稳定状态。", "answer": "$$\n\\boxed{k\\left(l_{0} - a\\right)^{2}}\n$$", "id": "2660237"}, {"introduction": "单个晶胞的行为是材料宏观性能的构建基石。本计算练习展示了单个晶胞的双稳态如何在一个多晶胞系统中引发出相变行为。你将为一个由双稳态单元组成的条带实现一个模型，运用热力学原理确定相共存的麦克斯韦点，并构建完整的载荷-位移曲线，包括其特征性的力平台区。[@problem_id:2660275]", "problem": "考虑一个由 $N$ 个相同的、可弹性变形的单元串联组成的一维条带。每个单元都被设计成双稳态，其无量纲弹性储能函数 $U(s;\\alpha)$ 是标量单元伸长量 $s$ 的函数，由下式给出：\n$$\nU(s;\\alpha) = \\frac{(s^2 - 1)^2}{4} + \\alpha\\, s,\n$$\n其中 $\\alpha$ 是一个无量纲倾斜参数，它使一个势阱相对于另一个产生偏置。该条带承受准静态位移控制，总伸长量被指定为 $\\Delta$，惯性和耗散可忽略不计。施加的反作用力 $F$ 是强制满足串联单元相容性的拉格朗日乘子。\n\n从最小势能原理和串联系统的基本平衡出发，必须在全局能量最小化的条件下确定载荷-位移路径 $F(\\Delta)$，并识别麦克斯韦点，在该点，单个单元的两个共存平衡态具有相等的吉布斯自由能。仅使用无量纲变量；不需要物理单位。\n\n基本原理：\n- 在共同力 $F$ 的作用下，单元的力-伸长平稳性可从吉布斯自由能 $G(s;F) = U(s;\\alpha) - F s$ 的最小值得到。平稳性满足\n$$\n\\frac{dU}{ds}(s;\\alpha) = F.\n$$\n- 对于在指定总伸长量 $\\Delta$ 下处于平衡状态的串联单元，力 $F$ 对所有单元都是共同的，相容性条件是\n$$\n\\sum_{i=1}^N s_i = \\Delta,\n$$\n其中每个 $s_i$ 是 $G(\\cdot;F)$ 的局部极小值点。\n- 麦克斯韦力 $F_M$ 由 $G(\\cdot;F)$ 的两个共存局部极小值点 $s_a(F)$ 和 $s_b(F)$ 的等能量条件定义，其中 $s_a(F)  s_b(F)$：\n$$\nG(s_a(F_M);F_M) = G(s_b(F_M);F_M).\n$$\n\n您的程序需要完成的目标推导和计算：\n- 对于给定的 $(N,\\alpha)$，计算麦克斯韦力 $F_M$ 和相应的共存单元伸长量 $s_a(F_M)$ 和 $s_b(F_M)$，分别记为 $s_{aM}$ 和 $s_{bM}$。\n- 在位移控制下，能量最小化的载荷-位移路径 $F(\\Delta)$ 分段定义如下：\n  - 对于 $\\Delta \\le N\\, s_{aM}$，由 $\\Delta = N\\, s_a(F)$ 隐式确定的单相左势阱分支。\n  - 对于 $N\\, s_{aM} \\le \\Delta \\le N\\, s_{bM}$，在 $F(\\Delta) = F_M$ 处的一个平台区，混合了左势阱和右势阱。\n  - 对于 $\\Delta \\ge N\\, s_{bM}$，由 $\\Delta = N\\, s_b(F)$ 隐式确定的单相右势阱分支。\n这里 $s_a(F)$ 和 $s_b(F)$ 是 $G(\\cdot;F)$ 在存在时的两个局部极小值点；在双稳态范围之外，唯一的极小值点被一致地用作左分支或右分支。\n\n您的程序必须：\n- 实现上述平衡条件，从第一性原理进行数值计算以得到 $F_M$、$s_{aM}$ 和 $s_{bM}$，不使用任何预先推导的简化公式。\n- 对于每个测试用例，在三个指定的总伸长量下计算 $F(\\Delta)$：\n  1. 一个左分支值\n  $$\n  \\Delta_L = N\\, s_{aM} - \\frac{1}{4}\\, N \\left(s_{bM} - s_{aM}\\right),\n  $$\n  2. 一个中平台值\n  $$\n  \\Delta_M = \\frac{N}{2}\\left(s_{aM} + s_{bM}\\right),\n  $$\n  3. 一个右分支值\n  $$\n  \\Delta_R = N\\, s_{bM} + \\frac{1}{4}\\, N \\left(s_{bM} - s_{aM}\\right).\n  $$\n  报告相应的反作用力 $F(\\Delta_L)$、$F(\\Delta_M)$ 和 $F(\\Delta_R)$。\n\n数值说明：\n- 所有计算都是无量纲的。不需要物理单位。\n- 将所有报告的数值结果表示为四舍五入到 $6$ 位小数的浮点数。\n\n测试套件：\n- 使用以下三组参数集 $(N,\\alpha)$：\n  - 案例 1：$(N,\\alpha) = (8, 0)$。\n  - 案例 2：$(N,\\alpha) = (10, 0.1)$。\n  - 案例 3：$(N,\\alpha) = (6, -0.2)$。\n\n对于每个案例，您的程序必须输出一个包含 $6$ 个浮点数的列表\n$$\n\\left[F_M,\\; s_{aM},\\; s_{bM},\\; F(\\Delta_L),\\; F(\\Delta_M),\\; F(\\Delta_R)\\right],\n$$\n每个条目均按上述定义四舍五入到 $6$ 位小数。\n\n最终输出格式：\n- 将三个特定案例的列表聚合为单行的列表之列表，逗号后没有空格，例如\n$$\n\\left[\\left[\\cdot\\right],\\left[\\cdot\\right],\\left[\\cdot\\right]\\right].\n$$\n您的程序应生成单行输出，包含此聚合列表，并以该括号、逗号分隔的格式精确打印，不带任何附加文本。", "solution": "我们从最小势能原理出发，推导一个由设计的双稳态单元组成的串联系统的载荷-位移响应。单个单元具有无量纲储能\n$$\nU(s;\\alpha) = \\frac{(s^2-1)^2}{4} + \\alpha\\, s,\n$$\n其导数和曲率为\n$$\n\\frac{dU}{ds}(s;\\alpha) = s^3 - s + \\alpha,\\quad \\frac{d^2U}{ds^2}(s) = 3 s^2 - 1.\n$$\n在共同力 $F$ 的作用下，吉布斯自由能为\n$$\nG(s;F) = U(s;\\alpha) - F s,\n$$\n$G$ 的平稳点满足\n$$\n\\frac{dG}{ds} = \\frac{dU}{ds} - F = 0 \\;\\;\\Longleftrightarrow\\;\\; s^3 - s + \\alpha = F.\n$$\n这个三次方程有一个或三个实根，具体取决于 $F$ 和 $\\alpha$。局部极小值点对应于具有正曲率 $d^2U/ds^2 = 3 s^2 - 1  0$ 的根，即 $|s|  1/\\sqrt{3}$。用 $s_a(F)$ 和 $s_b(F)$ 表示两个局部极小值点，当两者都存在时，排序使得 $s_a(F)  s_b(F)$。在双稳态范围之外，存在唯一的极小值点；在这种情况下，在适用时，我们一致地将势垒左侧的极小值点取为 $s_a(F)$，将势垒右侧的极小值点取为 $s_b(F)$。\n\n对于在指定总伸长量 $\\Delta$ 下的 $N$ 个相同串联单元，平衡是通过在相容性约束条件下最小化总能量来找到的，\n$$\n\\min_{s_1,\\dots,s_N}\\;\\sum_{i=1}^N U(s_i;\\alpha)\\quad \\text{subject to}\\quad \\sum_{i=1}^N s_i = \\Delta.\n$$\n为该约束引入拉格朗日乘子 $F$ 得到拉格朗日量\n$$\n\\mathcal{L} = \\sum_{i=1}^N \\left(U(s_i;\\alpha) - F s_i\\right) + F \\Delta = \\sum_{i=1}^N G(s_i;F) + F \\Delta.\n$$\n相对于每个 $s_i$ 的平稳性强制要求\n$$\n\\frac{dU}{ds}(s_i;\\alpha) = F\\quad \\text{for all } i,\n$$\n也就是说，每个 $s_i$ 必须是 $G(\\cdot;F)$ 的一个平稳点（实际上是局部极小值点）。因此，在双稳态范围内给定一个 $F$ 值时，每个单元独立地选择两个极小化伸长量 $s_a(F)$ 或 $s_b(F)$ 中的一个。如果 $k$ 个单元占据右势阱极小值，而 $N-k$ 个单元占据左势阱极小值，相容性条件得出\n$$\n\\Delta = (N-k)\\, s_a(F) + k\\, s_b(F).\n$$\n在固定 $F$ 下对每个单元进行最小化之后，最小化的拉格朗日量为\n$$\n\\mathcal{L}_{\\min}(F,k) = (N-k)\\, G(s_a(F);F) + k\\, G(s_b(F);F) + F \\Delta.\n$$\n为了确定麦克斯韦力，回想一下，在位移控制下的混合平台区，全局能量最小值在力 $F$ 处达到，使得对于单个单元，两相具有相等的吉布斯自由能。因此，麦克斯韦力 $F_M$ 由等能量条件定义\n$$\nG(s_a(F_M);F_M) = G(s_b(F_M);F_M).\n$$\n在 $F = F_M$ 时，左、右极小值点的任意混合比例 $k$ 都会得到相同的和 $(N-k)G(s_a(F_M);F_M)+kG(s_b(F_M);F_M)$，因此 $\\mathcal{L}_{\\min}(F_M,k) = N\\, G(s_a(F_M);F_M) + F_M \\Delta$ 与 $k$ 无关。在 $F_M$ 处的允许总伸长量通过将 $k$ 从 $0$ 变化到 $N$ 来跨越区间\n$$\n\\Delta \\in \\left[N\\, s_a(F_M),\\; N\\, s_b(F_M)\\right]。\n$$\n因此，在位移控制下，能量最小化的载荷-位移路径是分段的：\n- 对于 $\\Delta \\le N s_a(F_M)$，系统保持在单相左势阱分支，其中 $F$ 由 $\\Delta = N s_a(F)$ 隐式确定，这得到 $F(\\Delta)  F_M$。\n- 对于 $N s_a(F_M) \\le \\Delta \\le N s_b(F_M)$，反作用力被锁定在麦克斯韦力 $F(\\Delta) = F_M$ 上，混合比例可变。\n- 对于 $\\Delta \\ge N s_b(F_M)$，系统占据单相右势阱分支，其中 $F$ 由 $\\Delta = N s_b(F)$ 确定，所以 $F(\\Delta)  F_M$。\n\n算法实现：\n1. 对于给定的 $\\alpha$，对于任意力 $F$，通过求解 $s^3 - s + \\alpha = F$ 来计算 $G(\\cdot;F)$ 的实平稳点。在实根中，使用 $3 s^2 - 1  0$ 来识别局部极小值点，并在可用时对它们排序以提取 $s_a(F)$ 和 $s_b(F)$。定义单元吉布斯自由能值 $G(s_a(F);F)$ 和 $G(s_b(F);F)$。\n2. 通过对函数 $\\phi(F) = G(s_b(F);F) - G(s_a(F);F)$ 进行求根来确定 $F_M$，限制在存在两个极小值点的 $F$ 范围内。可以通过在一个对称范围内扫描 $F$ 来找到一个稳健的括号区间，直到检测到 $\\phi(F)$ 符号相反的点。一种二分法类型的方法（例如，Brent 方法）然后得出 $F_M$。共存的伸长量 $s_{aM}$ 和 $s_{bM}$ 分别是 $s_a(F_M)$ 和 $s_b(F_M)$。\n3. 对于任何指定的 $\\Delta$，通过分段规则计算反作用力 $F(\\Delta)$：\n   - 如果 $\\Delta  N s_{aM}$，通过求解 $N s_a(F) = \\Delta$ 来反演左分支，使用一个单调括号 $(F_{\\min}, F_M)$，其中 $F_{\\min}$ 选择得足够负，如果需要则扩展，直到括号内包含 $N s_a(F) - \\Delta$ 的符号变化。\n   - 如果 $N s_{aM} \\le \\Delta \\le N s_{bM}$，返回 $F(\\Delta) = F_M$。\n   - 如果 $\\Delta > N s_{bM}$，通过求解 $N s_b(F) = \\Delta$ 来反演右分支，使用一个单调括号 $(F_M, F_{\\max})$，其中 $F_{\\max}$ 足够大，如果需要则扩展。\n\n测试套件评估：\n对于每个案例 $(N,\\alpha)$，计算 $F_M$、$s_{aM}$ 和 $s_{bM}$。然后在\n$$\n\\Delta_L = N s_{aM} - \\frac{1}{4} N (s_{bM} - s_{aM}),\\quad\n\\Delta_M = \\frac{N}{2}(s_{aM} + s_{bM}),\\quad\n\\Delta_R = N s_{bM} + \\frac{1}{4} N (s_{bM} - s_{aM})\n$$\n处计算反作用力。\n根据构造，$\\Delta_L$ 位于左单相分支上，$\\Delta_M$ 位于麦克斯韦平台上，而 $\\Delta_R$ 位于右单相分支上。对于每个测试用例，程序报告列表\n$$\n\\left[F_M,\\; s_{aM},\\; s_{bM},\\; F(\\Delta_L),\\; F(\\Delta_M),\\; F(\\Delta_R)\\right],\n$$\n所有条目都四舍五入到 6 位小数。最终输出将三个列表聚合为一个列表的列表，打印在单行上，无额外文本。\n\n该方法直接编码了串联双稳态晶格条带的第一性原理变分结构，通过相等的吉布斯自由能识别麦克斯韦点，并构建了位移控制响应，包括由双稳态单元之间的相混合引起的平台区。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\n# Nondimensional single-cell energy and derivatives\ndef U(s, alpha):\n    return 0.25 * (s**2 - 1.0)**2 + alpha * s\n\ndef dU(s, alpha):\n    return s**3 - s + alpha\n\ndef d2U(s):\n    return 3.0 * s**2 - 1.0\n\ndef gibbs(s, F, alpha):\n    return U(s, alpha) - F * s\n\ndef real_roots_cubic(coeffs, tol_im=1e-12):\n    roots = np.roots(coeffs)\n    real = []\n    for r in roots:\n        if abs(r.imag)  tol_im:\n            real.append(r.real)\n    return real\n\ndef minima_at_force(F, alpha):\n    # Solve dU/ds - F = 0 => s^3 - s + (alpha - F) = 0\n    coeffs = [1.0, 0.0, -1.0, alpha - F]\n    roots = real_roots_cubic(coeffs)\n    # Identify minima by positive curvature\n    mins = []\n    for s in roots:\n        if d2U(s) > 0:\n            mins.append(s)\n    mins.sort()\n    return mins  # could be length 1 or 2\n\ndef s_a(F, alpha):\n    mins = minima_at_force(F, alpha)\n    if len(mins) == 0:\n        # Numerically extremely rare; fallback: choose stationary point with largest curvature\n        coeffs = [1.0, 0.0, -1.0, alpha - F]\n        roots = real_roots_cubic(coeffs)\n        if not roots:\n            return np.nan\n        curvatures = [(d2U(s), s) for s in roots]\n        curvatures.sort()  # ascending by curvature\n        # pick the one with positive curvature if any, else the smallest s\n        for c, s in curvatures:\n            if c > 0:\n                return s\n        return min(roots)\n    # left minimum is the smallest\n    return mins[0]\n\ndef s_b(F, alpha):\n    mins = minima_at_force(F, alpha)\n    if len(mins) == 0:\n        coeffs = [1.0, 0.0, -1.0, alpha - F]\n        roots = real_roots_cubic(coeffs)\n        if not roots:\n            return np.nan\n        curvatures = [(d2U(s), s) for s in roots]\n        curvatures.sort()\n        for c, s in reversed(curvatures):\n            if c > 0:\n                return s\n        return max(roots)\n    # right minimum is the largest\n    return mins[-1]\n\ndef diff_gibbs(F, alpha):\n    # G_b - G_a\n    sa = s_a(F, alpha)\n    sb = s_b(F, alpha)\n    Ga = gibbs(sa, F, alpha)\n    Gb = gibbs(sb, F, alpha)\n    return Gb - Ga\n\ndef has_two_minima(F, alpha):\n    return len(minima_at_force(F, alpha)) >= 2\n\ndef bracket_maxwell(alpha, F_span_init=2.0, max_span=50.0, ngrid=1001):\n    span = F_span_init\n    while span = max_span:\n        Fs = np.linspace(-span, span, ngrid)\n        vals = []\n        Fs_two = []\n        for F in Fs:\n            if has_two_minima(F, alpha):\n                Fs_two.append(F)\n                vals.append(diff_gibbs(F, alpha))\n        if len(Fs_two) >= 2:\n            vals = np.array(vals)\n            Fs_two = np.array(Fs_two)\n            # Look for sign change\n            sign = np.sign(vals)\n            for i in range(len(vals) - 1):\n                if sign[i] == 0.0:\n                    # exact zero at grid point, create tiny bracket around it\n                    F0 = Fs_two[i]\n                    return (F0 - 1e-3, F0 + 1e-3)\n                if sign[i] * sign[i+1]  0:\n                    return (Fs_two[i], Fs_two[i+1])\n            # If no adjacent sign change, try global min/max signs\n            if vals.min()  0 and vals.max() > 0:\n                # find indices of min and max to form a wide bracket\n                i_min = np.argmin(vals)\n                i_max = np.argmax(vals)\n                F_lo = min(Fs_two[i_min], Fs_two[i_max])\n                F_hi = max(Fs_two[i_min], Fs_two[i_max])\n                return (F_lo, F_hi)\n        span *= 1.5\n    # As a fallback, assume small tilt and near-symmetric; bracket around zero\n    return (-1.0, 1.0)\n\ndef find_maxwell(alpha):\n    F_lo, F_hi = bracket_maxwell(alpha)\n    # Ensure the bracket lies where two minima exist; shrink if necessary\n    def phi(F):\n        return diff_gibbs(F, alpha)\n    # If phi at endpoints have same sign, try to adjust endpoints inward to two-min region\n    # Use brentq with a safe guard\n    try:\n        FM = brentq(phi, F_lo, F_hi, maxiter=200, xtol=1e-12, rtol=1e-12)\n    except ValueError:\n        # Try to gently expand or shift bracket\n        expand = 0.5\n        for k in range(20):\n            a = F_lo - expand\n            b = F_hi + expand\n            try:\n                FM = brentq(phi, a, b, maxiter=200, xtol=1e-12, rtol=1e-12)\n                break\n            except ValueError:\n                expand *= 1.5\n        else:\n            # As a last resort, sample near zero and pick closest to zero diff\n            Fs = np.linspace(F_lo, F_hi, 1001)\n            diffs = np.array([abs(phi(F)) for F in Fs])\n            FM = Fs[np.argmin(diffs)]\n    saM = s_a(FM, alpha)\n    sbM = s_b(FM, alpha)\n    return FM, saM, sbM\n\ndef invert_branch_for_force(N, alpha, Delta, branch, FM, tol=1e-12):\n    # g(F) = N*s_branch(F) - Delta; solve g(F)=0 with bracketing\n    if branch == 'left':\n        def sbranch(F): return s_a(F, alpha)\n        # start bracket [FM-10, FM]\n        a = FM - 10.0\n        b = FM\n    elif branch == 'right':\n        def sbranch(F): return s_b(F, alpha)\n        a = FM\n        b = FM + 10.0\n    else:\n        raise ValueError(\"branch must be 'left' or 'right'\")\n\n    def g(F):\n        return N * sbranch(F) - Delta\n\n    # Ensure sign change\n    ga = g(a)\n    gb = g(b)\n    # Expand if needed\n    attempts = 0\n    while ga * gb > 0 and attempts  50:\n        if branch == 'left':\n            a -= 10.0\n            ga = g(a)\n        else:\n            b += 10.0\n            gb = g(b)\n        attempts += 1\n    # If still no sign change, try symmetric expansion\n    if ga * gb > 0:\n        a2 = a - 100.0\n        b2 = b + 100.0\n        ga2 = g(a2)\n        gb2 = g(b2)\n        if ga2 * gb2 > 0:\n            # As fallback, use monotone root finding by scanning\n            Fs = np.linspace(a2, b2, 5001)\n            Gs = np.array([g(F) for F in Fs])\n            idx = np.argmin(np.abs(Gs))\n            return Fs[idx]\n        else:\n            a, b = a2, b2\n            ga, gb = ga2, gb2\n    # Now solve with brentq\n    F_sol = brentq(g, a, b, xtol=tol, rtol=tol, maxiter=200)\n    return F_sol\n\ndef reaction_force(N, alpha, Delta, FM, saM, sbM, tol=1e-10):\n    left_thresh = N * saM\n    right_thresh = N * sbM\n    if Delta  left_thresh - tol:\n        return invert_branch_for_force(N, alpha, Delta, branch='left', FM=FM)\n    elif Delta > right_thresh + tol:\n        return invert_branch_for_force(N, alpha, Delta, branch='right', FM=FM)\n    else:\n        return FM\n\ndef compute_case(N, alpha):\n    FM, saM, sbM = find_maxwell(alpha)\n    # Define prescribed total extensions\n    Delta_L = N * saM - 0.25 * N * (sbM - saM)\n    Delta_M = 0.5 * N * (saM + sbM)\n    Delta_R = N * sbM + 0.25 * N * (sbM - saM)\n    FL = reaction_force(N, alpha, Delta_L, FM, saM, sbM)\n    FMid = reaction_force(N, alpha, Delta_M, FM, saM, sbM)\n    FR = reaction_force(N, alpha, Delta_R, FM, saM, sbM)\n    # Round to 6 decimals\n    out = [FM, saM, sbM, FL, FMid, FR]\n    out = [round(x + 0.0, 6) for x in out]\n    return out\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, 0.0),\n        (10, 0.1),\n        (6, -0.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, alpha = case\n        res = compute_case(N, alpha)\n        results.append(res)\n\n    # Format without spaces after commas\n    def format_list(lst):\n        return \"[\" + \",\".join(f\"{x:.6f}\" for x in lst) + \"]\"\n    s = \"[\" + \",\".join(format_list(r) for r in results) + \"]\"\n    print(s)\n\nsolve()\n```", "id": "2660275"}]}