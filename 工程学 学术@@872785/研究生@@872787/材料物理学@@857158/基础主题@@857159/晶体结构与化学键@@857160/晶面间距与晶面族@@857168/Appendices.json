{"hands_on_practices": [{"introduction": "晶体中晶面之间的方向关系对理解材料的各向异性至关重要。本练习将引导你从基本定义出发，实践如何将晶面法线表示为倒易点阵矢量，并利用点积来计算它们之间的夹角，这是定量晶体学分析中的一项基础技能 [@problem_id:2830567]。", "problem": "一个正交晶体的晶格常数为 $a=0.300\\ \\mathrm{nm}$，$b=0.400\\ \\mathrm{nm}$ 和 $c=0.500\\ \\mathrm{nm}$。考虑密勒指数为 $(120)$ 和 $(021)$ 的晶面。仅从密勒指数、倒易晶格矢量和欧几里得点积的基本定义出发，确定这两个晶面之间的二面角。将正交晶格处理为具有相互垂直的正晶格基矢，并采用晶体学惯例，其中正基矢和倒易基矢满足 $ \\mathbf{a}\\cdot\\mathbf{a}^{\\ast}=1$, $\\mathbf{b}\\cdot\\mathbf{b}^{\\ast}=1$, $\\mathbf{c}\\cdot\\mathbf{c}^{\\ast}=1$，且所有其他混合乘积为零。\n\n最终答案以度为单位表示，并四舍五入到 $4$ 位有效数字。在最终的方框答案中不要包含单位。", "solution": "所述问题是有效的。它在科学上基于晶体学原理，提法恰当，并包含获得唯一解所需的所有信息。我们将进行推导。\n\n目标是确定由密勒指数 $(1,2,0)$ 和 $(0,2,1)$ 标识的晶面之间的二面角。两个平面之间的二面角定义为其法向量之间的夹角。在晶体学中，密勒指数为 $(h,k,l)$ 的晶面族的法向量由倒易晶格矢量 $\\mathbf{G}_{hkl} = h\\mathbf{a}^* + k\\mathbf{b}^* + l\\mathbf{c}^*$ 给出，其中 $\\mathbf{a}^*$、$\\mathbf{b}^*$ 和 $\\mathbf{c}^*$ 是倒易晶格的基矢。\n\n问题指定了一个正交晶格，其正晶格基矢 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 相互正交。不失一般性，我们可以将它们与一个笛卡尔坐标系对齐：\n$$ \\mathbf{a} = a\\hat{i} $$\n$$ \\mathbf{b} = b\\hat{j} $$\n$$ \\mathbf{c} = c\\hat{k} $$\n其中 $\\hat{i}$、$\\hat{j}$ 和 $\\hat{k}$ 是笛卡尔坐标系的标准正交基矢，而 $a$、$b$ 和 $c$ 是晶格常数。\n\n倒易晶格基矢由所给关系定义：$\\mathbf{a} \\cdot \\mathbf{a}^* = 1$, $\\mathbf{b} \\cdot \\mathbf{b}^* = 1$, $\\mathbf{c} \\cdot \\mathbf{c}^* = 1$，并且所有混合乘积（如 $\\mathbf{a} \\cdot \\mathbf{b}^*$）均为零。让我们推导 $\\mathbf{a}^*$ 的表达式。由于正晶格的正交性，$\\mathbf{a}^*$ 必须与 $\\mathbf{a}$ 平行，以满足 $\\mathbf{a}^* \\cdot \\mathbf{b} = 0$ 和 $\\mathbf{a}^* \\cdot \\mathbf{c} = 0$。因此，对于某个标量 $K$，我们可以写出 $\\mathbf{a}^* = K \\mathbf{a}$。条件 $\\mathbf{a} \\cdot \\mathbf{a}^* = 1$ 导致：\n$$ \\mathbf{a} \\cdot (K\\mathbf{a}) = K(\\mathbf{a} \\cdot \\mathbf{a}) = K|\\mathbf{a}|^2 = Ka^2 = 1 $$\n这得到 $K = 1/a^2$。因此，$\\mathbf{a}^* = (1/a^2)\\mathbf{a} = (1/a^2)(a\\hat{i}) = (1/a)\\hat{i}$。\n对 $\\mathbf{b}^*$ 和 $\\mathbf{c}^*$ 进行相同的推理，在指定的惯例下，正交晶格的倒易基矢为：\n$$ \\mathbf{a}^* = \\frac{1}{a}\\hat{i} $$\n$$ \\mathbf{b}^* = \\frac{1}{b}\\hat{j} $$\n$$ \\mathbf{c}^* = \\frac{1}{c}\\hat{k} $$\n\n现在，我们为指定的两个晶面构造法向量。\n对于晶面 $(h_1, k_1, l_1) = (1,2,0)$，法向量 $\\mathbf{n}_1$ 是：\n$$ \\mathbf{n}_1 = h_1\\mathbf{a}^* + k_1\\mathbf{b}^* + l_1\\mathbf{c}^* = 1\\mathbf{a}^* + 2\\mathbf{b}^* + 0\\mathbf{c}^* = \\frac{1}{a}\\hat{i} + \\frac{2}{b}\\hat{j} $$\n对于晶面 $(h_2, k_2, l_2) = (0,2,1)$，法向量 $\\mathbf{n}_2$ 是：\n$$ \\mathbf{n}_2 = h_2\\mathbf{a}^* + k_2\\mathbf{b}^* + l_2\\mathbf{c}^* = 0\\mathbf{a}^* + 2\\mathbf{b}^* + 1\\mathbf{c}^* = \\frac{2}{b}\\hat{j} + \\frac{1}{c}\\hat{k} $$\n\n这两个向量之间的夹角 $\\phi$ 由欧几里得点积公式给出：\n$$ \\cos(\\phi) = \\frac{\\mathbf{n}_1 \\cdot \\mathbf{n}_2}{|\\mathbf{n}_1| |\\mathbf{n}_2|} $$\n我们计算该表达式的各部分。\n点积是：\n$$ \\mathbf{n}_1 \\cdot \\mathbf{n}_2 = \\left(\\frac{1}{a}\\hat{i} + \\frac{2}{b}\\hat{j}\\right) \\cdot \\left(\\frac{2}{b}\\hat{j} + \\frac{1}{c}\\hat{k}\\right) = (0)\\left(\\frac{1}{a}\\right) + \\left(\\frac{2}{b}\\right)\\left(\\frac{2}{b}\\right) + (0)\\left(\\frac{1}{c}\\right) = \\frac{4}{b^2} $$\n法向量的模是：\n$$ |\\mathbf{n}_1| = \\sqrt{\\left(\\frac{1}{a}\\right)^2 + \\left(\\frac{2}{b}\\right)^2} = \\sqrt{\\frac{1}{a^2} + \\frac{4}{b^2}} $$\n$$ |\\mathbf{n}_2| = \\sqrt{\\left(\\frac{2}{b}\\right)^2 + \\left(\\frac{1}{c}\\right)^2} = \\sqrt{\\frac{4}{b^2} + \\frac{1}{c^2}} $$\n将这些代入余弦公式：\n$$ \\cos(\\phi) = \\frac{\\frac{4}{b^2}}{\\sqrt{\\frac{1}{a^2} + \\frac{4}{b^2}} \\sqrt{\\frac{4}{b^2} + \\frac{1}{c^2}}} $$\n现在我们代入给定的晶格常数：$a = 0.300 \\text{ nm}$，$b = 0.400 \\text{ nm}$ 和 $c = 0.500 \\text{ nm}$。\n让我们先计算平方项：\n$a^2 = (0.300)^2 = 0.0900 \\text{ nm}^2$\n$b^2 = (0.400)^2 = 0.1600 \\text{ nm}^2$\n$c^2 = (0.500)^2 = 0.2500 \\text{ nm}^2$\n$\\cos(\\phi)$ 表达式中的各项变为：\n$$ \\frac{1}{a^2} = \\frac{1}{0.0900} = \\frac{100}{9} \\text{ nm}^{-2} $$\n$$ \\frac{4}{b^2} = \\frac{4}{0.1600} = 25 \\text{ nm}^{-2} $$\n$$ \\frac{1}{c^2} = \\frac{1}{0.2500} = 4 \\text{ nm}^{-2} $$\n现在我们将这些值代入 $\\cos(\\phi)$ 的表达式中：\n$$ \\cos(\\phi) = \\frac{25}{\\sqrt{\\frac{100}{9} + 25} \\sqrt{25 + 4}} $$\n$$ \\cos(\\phi) = \\frac{25}{\\sqrt{\\frac{100 + 225}{9}} \\sqrt{29}} = \\frac{25}{\\sqrt{\\frac{325}{9}} \\sqrt{29}} = \\frac{25}{\\frac{\\sqrt{325}}{3} \\sqrt{29}} $$\n注意到 $325 = 25 \\times 13$，所以 $\\sqrt{325} = 5\\sqrt{13}$：\n$$ \\cos(\\phi) = \\frac{25 \\times 3}{5\\sqrt{13} \\sqrt{29}} = \\frac{75}{5\\sqrt{377}} = \\frac{15}{\\sqrt{377}} $$\n对此表达式进行数值计算：\n$$ \\cos(\\phi) \\approx \\frac{15}{19.416488} \\approx 0.772530 $$\n角度 $\\phi$ 是该值的反余弦：\n$$ \\phi = \\arccos(0.772530) \\approx 39.4158^\\circ $$\n按要求将结果四舍五入到 $4$ 位有效数字，我们得到 $\\phi = 39.42^\\circ$。", "answer": "$$\\boxed{39.42}$$", "id": "2830567"}, {"introduction": "晶带轴是晶体学中解释衍射花样的核心概念，它是一组晶面所共有的一个方向。本练习要求你应用晶带定律 $hu+kv+lw=0$，找出一系列晶面的公共晶带轴，从而加深对正点阵与倒易点阵之间对偶关系的理解 [@problem_id:2830564]。", "problem": "在一个三维立方布拉菲晶格中，其正晶格基矢为 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$，考虑三个晶面，其密勒指数分别为 $(1\\,\\bar{1}\\,0)$、$(2\\,\\bar{2}\\,0)$ 和 $(3\\,\\bar{3}\\,0)$。仅从以下基本定义出发：(i) 密勒指数为 $(h\\,k\\,l)$ 的平面，其倒易晶格法向量与 $h\\,\\mathbf{a}^{*}+k\\,\\mathbf{b}^{*}+l\\,\\mathbf{c}^{*}$ 成正比；(ii) 方向 $[u\\,v\\,w]$ 对应一个与 $u\\,\\mathbf{a}+v\\,\\mathbf{b}+w\\,\\mathbf{c}$ 成正比的正晶格矢量。请推导晶格方向 $[u\\,v\\,w]$ 位于平面 $(h\\,k\\,l)$ 内的充分必要条件。利用此条件，确定一个由最小正互质整数表示的非零晶格方向，该方向同时位于所有三个给定平面内，并满足附加要求 $w=0$ 以确保唯一性。然后，明确地验证您得到的方向对这三个平面中的每一个都满足所推导的条件。请使用第一性原理简要说明为什么这三个平面属于同一晶面族，并讨论在晶格常数为 $a$ 的立方晶体中，它们晶面间距之间的定性关系。\n\n在您的最终答案中，仅以行矩阵的形式报告最终的方向指数 $[u\\,v\\,w]$。无需进行数值舍入，最终报告的指数不带物理单位。", "solution": "设 $\\mathbf{a}$、$\\mathbf{b}$、$\\mathbf{c}$ 为正晶格基矢，$\\mathbf{a}^{*}$、$\\mathbf{b}^{*}$、$\\mathbf{c}^{*}$ 为相应的倒易晶格基矢，其定义满足 $\\mathbf{a}^{*}\\cdot\\mathbf{a}=1$、$\\mathbf{b}^{*}\\cdot\\mathbf{b}=1$、$\\mathbf{c}^{*}\\cdot\\mathbf{c}=1$，且所有交叉项均为零。一个密勒指数为 $(h\\,k\\,l)$ 的晶面具有倒易晶格法向量\n$$\n\\mathbf{g}=h\\,\\mathbf{a}^{*}+k\\,\\mathbf{b}^{*}+l\\,\\mathbf{c}^{*}.\n$$\n一个晶体学方向 $[u\\,v\\,w]$ 对应一个正晶格矢量\n$$\n\\mathbf{r}=u\\,\\mathbf{a}+v\\,\\mathbf{b}+w\\,\\mathbf{c}.\n$$\n根据几何定义，一个方向位于一个平面内，当且仅当该方向矢量与平面法向量正交。因此，$[u\\,v\\,w]$ 位于 $(h\\,k\\,l)$ 内的充分必要条件是\n$$\n\\mathbf{g}\\cdot\\mathbf{r}=\\left(h\\,\\mathbf{a}^{*}+k\\,\\mathbf{b}^{*}+l\\,\\mathbf{c}^{*}\\right)\\cdot\\left(u\\,\\mathbf{a}+v\\,\\mathbf{b}+w\\,\\mathbf{c}\\right)=0.\n$$\n利用对偶关系 $\\mathbf{a}^{*}\\cdot\\mathbf{a}=1$、$\\mathbf{b}^{*}\\cdot\\mathbf{b}=1$、$\\mathbf{c}^{*}\\cdot\\mathbf{c}=1$ 以及交叉项为零的性质，该式变为\n$$\nh\\,u+k\\,v+l\\,w=0,\n$$\n这就是关联一个方向和一个平面的晶带条件。\n\n将此条件应用于给定的三个平面。对于 $(1\\,\\bar{1}\\,0)$，条件是\n$$\n1\\cdot u+(-1)\\cdot v+0\\cdot w=0\\quad\\Rightarrow\\quad u-v=0.\n$$\n对于 $(2\\,\\bar{2}\\,0)$，条件是\n$$\n2\\,u+(-2)\\,v+0\\cdot w=0\\quad\\Rightarrow\\quad 2\\,(u-v)=0\\quad\\Rightarrow\\quad u-v=0.\n$$\n对于 $(3\\,\\bar{3}\\,0)$，条件是\n$$\n3\\,u+(-3)\\,v+0\\cdot w=0\\quad\\Rightarrow\\quad 3\\,(u-v)=0\\quad\\Rightarrow\\quad u-v=0.\n$$\n因此，所有三个平面共同隐含的约束是 $u=v$，而 $w$ 不受这些方程的约束。为了获得一个唯一的代表性公共晶带轴，我们施加附加要求 $w=0$，并选择最小的正互质整数，得到 $u=v=1$，$w=0$。因此，一个基元公共晶带轴是\n$$\n[1\\,1\\,0].\n$$\n\n对每个平面使用 $h\\,u+k\\,v+l\\,w=0$ 进行验证：\n- 对于 $(1\\,\\bar{1}\\,0)$ 和 $[1\\,1\\,0]$: $1\\cdot 1+(-1)\\cdot 1+0\\cdot 0=1-1+0=0$。\n- 对于 $(2\\,\\bar{2}\\,0)$ 和 $[1\\,1\\,0]$: $2\\cdot 1+(-2)\\cdot 1+0\\cdot 0=2-2+0=0$。\n- 对于 $(3\\,\\bar{3}\\,0)$ 和 $[1\\,1\\,0]$: $3\\cdot 1+(-3)\\cdot 1+0\\cdot 0=3-3+0=0$。\n\n因此 $[1\\,1\\,0]$ 位于所有三个平面内，符合要求。\n\n为了说明平面 $(1\\,\\bar{1}\\,0)$、$(2\\,\\bar{2}\\,0)$ 和 $(3\\,\\bar{3}\\,0)$ 属于同一晶面族，注意到它们的倒易法向量分别为\n$$\n\\mathbf{g}_{1}=1\\,\\mathbf{a}^{*}-1\\,\\mathbf{b}^{*}+0\\,\\mathbf{c}^{*},\\quad\n\\mathbf{g}_{2}=2\\,\\mathbf{a}^{*}-2\\,\\mathbf{b}^{*}+0\\,\\mathbf{c}^{*}=2\\,\\mathbf{g}_{1},\\quad\n\\mathbf{g}_{3}=3\\,\\mathbf{a}^{*}-3\\,\\mathbf{b}^{*}+0\\,\\mathbf{c}^{*}=3\\,\\mathbf{g}_{1}.\n$$\n这三个法向量都是共线的，仅相差正整数比例因子；因此这些平面是平行的，代表了具有相同取向但晶面间距不同的连续平面。在晶格常数为 $a$ 的立方晶格中，晶面间距满足 $d_{hkl}=\\frac{a}{\\sqrt{h^{2}+k^{2}+l^{2}}}$。因此，\n$$\nd_{(1\\,\\bar{1}\\,0)}=\\frac{a}{\\sqrt{2}},\\quad d_{(2\\,\\bar{2}\\,0)}=\\frac{a}{2\\sqrt{2}},\\quad d_{(3\\,\\bar{3}\\,0)}=\\frac{a}{3\\sqrt{2}},\n$$\n它们的比例为 $1: \\frac{1}{2}:\\frac{1}{3}$，这与 $(n\\,\\bar{n}\\,0)$ 平面取向相同但随着 $n$ 的增加间距变得更紧密的事实相符。这与公共晶带轴的结果以及从第一性原理推导出的晶带条件完全一致。", "answer": "$$\\boxed{\\begin{pmatrix}1  1  0\\end{pmatrix}}$$", "id": "2830564"}, {"introduction": "现代材料表征高度依赖于计算方法。这项高级实践将之前所学的概念整合到一个实际问题中：自动标定电子衍射花样。通过设计算法，你将把晶带定律和晶面夹角公式等理论知识转化为一个实用、有效的分析工具 [@problem_id:2830544]。", "problem": "设计并实现一个完整的、可运行的程序，该程序使用两个非共线的晶带轴和一小组测量的晶面夹角，对选区电子衍射（SAED; Selected Area Electron Diffraction）中的晶面族进行标定。您的算法必须基于基本原理：它应从正格子和倒格子的定义出发，利用晶带定律的几何意义来生成候选的密勒指数。然后，使用由给定晶格参数所决定的晶格度规，计算晶面夹角，以选择唯一一组满足所有约束条件和指定角度容差的密勒指数。程序不得依赖于预先制表的简化公式；它必须直接从给定的晶格参数计算所有必要的几何量。\n\n输入是隐式的：您的程序必须硬编码并使用以下测试套件。对于每个测试用例，给定以下信息：\n- 一个由晶胞参数 $a$、$b$、$c$（以埃 Å 为单位）和 $\\alpha$、$\\beta$、$\\gamma$（以度为单位）指定的布拉维格子。\n- 两个在正格子基下表示的非共线整数晶带轴 $[u_{1},v_{1},w_{1}]$ 和 $[u_{2},v_{2},w_{2}]$。\n- 两个测量的晶面夹角列表（以度为单位），这些角度是相对于一个对两个晶带都公共的、未知的单一参考晶面测量的。每个列表对应于两个晶带中的一个。\n- 一个整数上限 $H_{\\max}$，用于限制搜索的密勒指数的大小，以及一个标量容差 $\\Delta\\theta$（以度为单位），用于角度匹配。\n\n您的算法必须：\n1) 分别对每个晶带，枚举满足晶带定律的素候选晶面法线（唯一的密勒指数三元组 $(h,k,l)$，不考虑总体符号和总体整数比例）。仅使用 $|h|,|k|,|l| \\leq H_{\\max}$ 且不包括 $(0,0,0)$ 的指数。\n2) 确定候选参考晶面的集合，该集合中的晶面同时满足两个给定晶带轴的晶带定律。使用素方向进行处理：将 $(h,k,l)$ 除以其最大公约数，并强制采用一种规范符号约定，即第一个非零分量为正。\n3) 对于每个候选参考晶面 $(h_{0},k_{0},l_{0})$，使用完全由给定晶胞参数决定的倒格矢度规，计算此参考晶面与每个晶带中各个候选晶面之间的晶面夹角。按给定顺序匹配测量的角度，绝对角度差不超过 $\\Delta\\theta$。如果有多个候选晶面匹配同一个测量角度，则选择使倒易空间范数平方 $|{\\bf g}|^{2}$ 最小的那个；如果仍然存在平局，则在规范符号约定下选择字典序最小的 $(h,k,l)$。在一个晶带内不要重复指派同一个晶面。\n4) 仅当两个晶带中的所有测量角度都根据上述规则成功匹配时，才接受一个候选参考晶面。如果有多个参考晶面满足所有约束条件，选择其倒易空间范数平方最小的那个；在相同的规范约定下，通过字典序来解决任何剩余的平局。\n\n角度计算必须从第一性原理出发，使用由 $(a,b,c,\\alpha,\\beta,\\gamma)$ 决定的倒格矢度规：两个晶面族 $(h_{1},k_{1},l_{1})$ 和 $(h_{2},k_{2},l_{2})$ 之间的夹角是它们在倒易空间中的法向量 ${\\bf g}_{1}$ 和 ${\\bf g}_{2}$ 之间的夹角；必须使用由 $\\pm{\\bf g}_{1}$ 和 $\\pm{\\bf g}_{2}$ 张成的无向直线之间的较小夹角。输入中的所有角度均以度为单位，所有匹配都必须在指定的容差范围内以度为单位进行。\n\n程序应解决以下三个测试用例并汇总结果。\n\n测试用例 A (立方晶系理想情况):\n- 晶格：$a=3.0$ Å, $b=3.0$ Å, $c=3.0$ Å, $\\alpha=90^\\circ$, $\\beta=90^\\circ$, $\\gamma=90^\\circ$。\n- 晶带轴：$[u_{1},v_{1},w_{1}] = [1,0,0]$, $[u_{2},v_{2},w_{2}] = [1,1,0]$。\n- 每个晶带中相对于公共参考晶面的测量角度：\n  - 晶带 $[1,0,0]$：角度 $[90.0, 45.0]$ (度)。\n  - 晶带 $[1,1,0]$：角度 $[90.0, 54.7356]$ (度)。\n- 边界和容差：$H_{\\max}=2$, $\\Delta\\theta=0.5$ (度)。\n\n测试用例 B (具有各向异性 c 轴的四方晶系):\n- 晶格：$a=3.9$ Å, $b=3.9$ Å, $c=5.2$ Å, $\\alpha=90^\\circ$, $\\beta=90^\\circ$, $\\gamma=90^\\circ$。\n- 晶带轴：$[u_{1},v_{1},w_{1}] = [0,0,1]$, $[u_{2},v_{2},w_{2}] = [1,1,0]$。\n- 每个晶带中相对于公共参考晶面的测量角度：\n  - 晶带 $[0,0,1]$：角度 $[90.0, 45.0]$ (度)。\n  - 晶带 $[1,1,0]$：角度 $[90.0, 27.9]$ (度)。\n- 边界和容差：$H_{\\max}=2$, $\\Delta\\theta=0.5$ (度)。\n\n测试用例 C (带有微小噪声的正交晶系；关于容差和近简并的边缘情况):\n- 晶格：$a=4.0$ Å, $b=4.1$ Å, $c=5.0$ Å, $\\alpha=90^\\circ$, $\\beta=90^\\circ$, $\\gamma=90^\\circ$。\n- 晶带轴：$[u_{1},v_{1},w_{1}] = [1,0,0]$, $[u_{2},v_{2},w_{2}] = [0,1,0]$。\n- 每个晶带中相对于公共参考晶面的测量角度：\n  - 晶带 $[1,0,0]$：角度 $[90.2, 50.5]$ (度)。\n  - 晶带 $[0,1,0]$：角度 $[90.1, 51.7]$ (度)。\n- 边界和容差：$H_{\\max}=2$, $\\Delta\\theta=0.8$ (度)。\n\n最终输出规范：\n- 对每个测试用例，输出两个子列表（顺序与给定的两个晶带轴相同）。每个子列表必须包含已识别的参考晶面，其后是在该晶带中已识别的晶面，顺序与提供测量角度的顺序相同。每个晶面都必须以上述规范化的素表示形式报告为一个由三个整数组成的列表 $[h,k,l]$。\n- 将三个测试用例的结果按 A, B, C 的顺序汇总到一个列表中。\n- 您的程序应生成单行输出，其中包含此嵌套列表，格式为紧凑的、由方括号和逗号分隔、无空格的形式，例如：$[[[...],[...]],[[...],[...]],[[...],[...]]]$。\n\n您的解决方案必须源自正格子和倒格子的基本定义、晶带定律的几何解释以及倒易空间中基于度规的角度计算。所有角度必须以度为单位处理和匹配，晶胞边长必须按规定以埃 (Å) 为单位处理。不允许用户输入；程序必须按原样运行并打印所需的单行输出。", "solution": "问题陈述是材料物理领域中一个有效的、适定的科学问题，具体涉及电子衍射图的晶体学标定。它具有科学依据、客观，并为计算求解提供了一套完整的数据和约束条件。我将从第一性原理出发，给出一个完整的解决方案。\n\n问题的核心是从几何数据中识别晶面 $(h,k,l)$。解决方案的关键在于正格子（由基向量 $\\mathbf{a}, \\mathbf{b}, \\mathbf{c}$ 及其长度 $a,b,c$ 和轴间角 $\\alpha, \\beta, \\gamma$ 描述）与倒格子（由基向量 $\\mathbf{a}^*, \\mathbf{b}^*, \\mathbf{c}^*$ 描述）之间的关系。具有密勒指数 $(h,k,l)$ 的晶面族由一个倒格矢 $\\mathbf{g} = h\\mathbf{a}^* + k\\mathbf{b}^* + l\\mathbf{c}^*$ 表示，该向量垂直于这些晶面。\n\n所有的几何计算，如长度和角度，都由度规张量决定。对于倒格子，度规张量 $G^*$ 由其分量 $G^*_{ij} = \\mathbf{a}_i^* \\cdot \\mathbf{a}_j^*$ 定义，其中 $\\mathbf{a}_1^*, \\mathbf{a}_2^*, \\mathbf{a}_3^*$ 是倒格基矢。张量 $G^*$ 可以直接从正格子参数 $(a,b,c,\\alpha,\\beta,\\gamma)$ 计算得出。正格子晶胞的体积由 $V = abc\\sqrt{1-\\cos^2\\alpha-\\cos^2\\beta-\\cos^2\\gamma+2\\cos\\alpha\\cos\\beta\\cos\\gamma}$ 给出。$G^*$ 的分量为：\n$$\n\\begin{align*}\nG_{11}^* = \\frac{b^2 c^2 \\sin^2\\alpha}{V^2} \\quad G_{12}^* = \\frac{abc^2(\\cos\\alpha \\cos\\beta - \\cos\\gamma)}{V^2} \\\\\nG_{22}^* = \\frac{a^2 c^2 \\sin^2\\beta}{V^2} \\quad G_{13}^* = \\frac{ab^2c(\\cos\\alpha \\cos\\gamma - \\cos\\beta)}{V^2} \\\\\nG_{33}^* = \\frac{a^2 b^2 \\sin^2\\gamma}{V^2} \\quad G_{23}^* = \\frac{a^2bc(\\cos\\beta \\cos\\gamma - \\cos\\alpha)}{V^2}\n\\end{align*}\n$$\n且 $G^*_{ji} = G^*_{ij}$。对于正交晶格（$\\alpha=\\beta=\\gamma=90^\\circ$）的特殊情况，此张量简化为一个对角矩阵：$G^* = \\mathrm{diag}(1/a^2, 1/b^2, 1/c^2)$。\n\n使用倒格矢度规张量，倒格矢 $\\mathbf{g}_{hkl}$ 的模平方由下式给出：\n$$ |\\mathbf{g}_{hkl}|^2 = \\begin{pmatrix} h  k  l \\end{pmatrix} G^* \\begin{pmatrix} h \\\\ k \\\\ l \\end{pmatrix} $$\n两个晶面族 $(h_1, k_1, l_1)$ 和 $(h_2, k_2, l_2)$ 之间的夹角 $\\phi$ 是它们各自的法向量 $\\mathbf{g}_1$ 和 $\\mathbf{g}_2$ 之间的夹角。这个角的余弦通过倒易空间中的点积计算：\n$$ \\cos\\phi = \\frac{\\mathbf{g}_1 \\cdot \\mathbf{g}_2}{|\\mathbf{g}_1| |\\mathbf{g}_2|} = \\frac{\\begin{pmatrix} h_1  k_1  l_1 \\end{pmatrix} G^* \\begin{pmatrix} h_2 \\\\ k_2 \\\\ l_2 \\end{pmatrix}}{\\sqrt{|\\mathbf{g}_1|^2 |\\mathbf{g}_2|^2}} $$\n题目要求使用法向量所张成的无向直线之间的较小夹角，这意味着角度应计算为 $\\phi_{\\text{match}} = \\arccos(|\\cos\\phi|)$。所有的角度比较都必须以度为单位进行。\n\n算法流程如下：\n\n1.  **候选晶面生成**：对于每个晶带轴 $[u, v, w]$，我们枚举所有可能的密勒指数三元组 $(h,k,l)$，其中 $|h|, |k|, |l| \\leq H_{\\max}$ 且 $(h,k,l) \\neq (0,0,0)$。如果一个晶面 $(h,k,l)$ 满足 Weiss 晶带定律：$hu + kv + lw = 0$，则它属于晶带 $[u,v,w]$。每个有效的三元组都被转换为其规范的素形式：将指数除以它们的最大公约数，并调整符号以使第一个非零分量为正。这确保了每个晶面族取向都有一个唯一的表示。存储每个晶带的唯一规范晶面。\n\n2.  **参考晶面识别**：参考晶面对两个衍射图样都是共有的，因此它必须同时属于两个晶带轴。因此，候选参考晶面的集合是为两个晶带分别生成的规范晶面集合的交集。\n\n3.  **角度匹配与晶面标定**：我们遍历每个候选参考晶面 $(h_0, k_0, l_0)$。对于此参考晶面，我们尝试为每个晶带匹配给定的测量角度列表。\n    - 对于一个晶带列表中的每个测量角度 $\\theta_{\\text{meas}}$，我们在该晶带的候选晶面集合中搜索一个匹配的晶面 $(h,k,l)$（不包括参考晶面本身以及任何已指派的晶面）。\n    - 如果 $(h_0, k_0, l_0)$ 和 $(h,k,l)$ 之间计算出的角度 $\\phi_{\\text{match}}$ 满足 $|\\phi_{\\text{match}} - \\theta_{\\text{meas}}| \\leq \\Delta\\theta$，则认为匹配成功。\n    - 如果多个晶面匹配单个测量角度，我们应用一个平局决胜规则：选择具有最小倒易空间范数平方 $|\\mathbf{g}|^2$ 的晶面。如果仍然存在平局，则选择其密勒指数 $(h,k,l)$ 字典序最小的晶面。\n    - 如果在两个晶带中，每个测量角度都找到了唯一的最佳匹配，则该候选参考晶面被认为是一个有效的解。\n\n4.  **最终解的选择**：可能会有多个候选参考晶面产生完整且有效的已标定晶面集合。在这种情况下，应用一个最终的平局决胜规则：选择其参考晶面 $(h_0, k_0, l_0)$ 具有最小 $|\\mathbf{g}_0|^2$ 的解。任何剩余的平局通过选择字典序最小的参考晶面指数来解决。\n\n这个系统的、基于原理的流程保证在问题约束下得到唯一且正确的解。该实现封装了这一逻辑，从提供的基本晶格参数出发执行所有计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print the final aggregated result.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"lattice\": {\"a\": 3.0, \"b\": 3.0, \"c\": 3.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"zones\": [[1, 0, 0], [1, 1, 0]],\n            \"angles\": [[90.0, 45.0], [90.0, 54.7356]],\n            \"H_max\": 2,\n            \"delta_theta\": 0.5,\n        },\n        {\n            \"name\": \"B\",\n            \"lattice\": {\"a\": 3.9, \"b\": 3.9, \"c\": 5.2, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"zones\": [[0, 0, 1], [1, 1, 0]],\n            \"angles\": [[90.0, 45.0], [90.0, 27.9]],\n            \"H_max\": 2,\n            \"delta_theta\": 0.5,\n        },\n        {\n            \"name\": \"C\",\n            \"lattice\": {\"a\": 4.0, \"b\": 4.1, \"c\": 5.0, \"alpha\": 90.0, \"beta\": 90.0, \"gamma\": 90.0},\n            \"zones\": [[1, 0, 0], [0, 1, 0]],\n            \"angles\": [[90.2, 50.5], [90.1, 51.7]],\n            \"H_max\": 2,\n            \"delta_theta\": 0.8,\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(case)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    print(str(all_results).replace(\" \", \"\"))\n\ndef get_g_star(a, b, c, alpha, beta, gamma):\n    \"\"\"Computes the reciprocal metric tensor G* from direct lattice parameters.\"\"\"\n    alpha_rad, beta_rad, gamma_rad = np.deg2rad([alpha, beta, gamma])\n    ca, cb, cg = np.cos(alpha_rad), np.cos(beta_rad), np.cos(gamma_rad)\n    sa, sb, sg = np.sin(alpha_rad), np.sin(beta_rad), np.sin(gamma_rad)\n\n    V_sq = (a*b*c)**2 * (1 - ca**2 - cb**2 - cg**2 + 2*ca*cb*cg)\n    if V_sq == 0:\n        raise ValueError(\"Unit cell volume is zero.\")\n\n    G_star = np.zeros((3, 3))\n    G_star[0, 0] = (b*c*sa)**2 / V_sq\n    G_star[1, 1] = (a*c*sb)**2 / V_sq\n    G_star[2, 2] = (a*b*sg)**2 / V_sq\n    G_star[0, 1] = (a*b*c**2 * (ca*cb - cg)) / V_sq\n    G_star[1, 0] = G_star[0, 1]\n    G_star[0, 2] = (a*c*b**2 * (cg*ca - cb)) / V_sq\n    G_star[2, 0] = G_star[0, 2]\n    G_star[1, 2] = (b*c*a**2 * (cb*cg - ca)) / V_sq\n    G_star[2, 1] = G_star[1, 2]\n    \n    return G_star\n\ndef to_canonical_primitive(h, k, l):\n    \"\"\"Converts Miller indices to a canonical primitive form.\"\"\"\n    if h == 0 and k == 0 and l == 0:\n        return (0, 0, 0)\n    \n    common_divisor = math.gcd(math.gcd(abs(h), abs(k)), abs(l))\n    h, k, l = h // common_divisor, k // common_divisor, l // common_divisor\n    \n    if h  0:\n        h, k, l = -h, -k, -l\n    elif h == 0 and k  0:\n        k, l = -k, -l\n    elif h == 0 and k == 0 and l  0:\n        l = -l\n        \n    return (h, k, l)\n\ndef get_norm_sq(p, G_star):\n    p_vec = np.array(p)\n    return p_vec @ G_star @ p_vec\n\ndef get_angle(p1, p2, G_star):\n    \"\"\"Calculates the angle in degrees between two planes.\"\"\"\n    v1 = np.array(p1)\n    v2 = np.array(p2)\n    \n    dot_product = v1 @ G_star @ v2\n    norm1_sq = get_norm_sq(p1, G_star)\n    norm2_sq = get_norm_sq(p2, G_star)\n    \n    if norm1_sq == 0 or norm2_sq == 0:\n        return 0.0\n\n    cos_val = dot_product / np.sqrt(norm1_sq * norm2_sq)\n    angle_rad = np.arccos(np.clip(np.abs(cos_val), -1.0, 1.0))\n    return np.rad2deg(angle_rad)\n\ndef solve_case(params):\n    G_star = get_g_star(**params[\"lattice\"])\n    zones, angles, H_max, delta_theta = params[\"zones\"], params[\"angles\"], params[\"H_max\"], params[\"delta_theta\"]\n    \n    # 1. Enumerate candidate planes for each zone\n    zone_planes_sets = []\n    for u, v, w in zones:\n        planes = set()\n        for h in range(-H_max, H_max + 1):\n            for k in range(-H_max, H_max + 1):\n                for l in range(-H_max, H_max + 1):\n                    if h == 0 and k == 0 and l == 0:\n                        continue\n                    if h * u + k * v + l * w == 0:\n                        planes.add(to_canonical_primitive(h, k, l))\n        zone_planes_sets.append(planes)\n    \n    # 2. Determine candidate reference planes\n    candidate_refs = sorted(list(zone_planes_sets[0].intersection(zone_planes_sets[1])))\n\n    # 3. Test each candidate reference plane\n    valid_solutions = []\n    for ref_plane in candidate_refs:\n        is_solution_valid = True\n        solution_for_ref = []\n        \n        for i in range(2): # For each zone\n            zone_candidates = list(zone_planes_sets[i] - {ref_plane})\n            measured_angles = angles[i]\n            \n            indexed_planes = []\n            assigned_candidates = set()\n            all_angles_matched = True\n\n            for measured_angle in measured_angles:\n                matches = []\n                # Find all planes that match the angle\n                for cand_plane in zone_candidates:\n                    if cand_plane in assigned_candidates:\n                        continue\n                    \n                    calc_angle = get_angle(ref_plane, cand_plane, G_star)\n                    \n                    if abs(calc_angle - measured_angle) = delta_theta:\n                        norm_sq = get_norm_sq(cand_plane, G_star)\n                        matches.append({\"plane\": cand_plane, \"norm_sq\": norm_sq})\n                \n                if not matches:\n                    all_angles_matched = False\n                    break\n                \n                # Tie-breaking\n                matches.sort(key=lambda x: (x[\"norm_sq\"], x[\"plane\"]))\n                best_match = matches[0][\"plane\"]\n                indexed_planes.append(list(best_match))\n                assigned_candidates.add(best_match)\n\n            if not all_angles_matched:\n                is_solution_valid = False\n                break\n            \n            solution_for_ref.append([list(ref_plane)] + indexed_planes)\n\n        if is_solution_valid:\n            ref_norm_sq = get_norm_sq(ref_plane, G_star)\n            valid_solutions.append({\n                \"ref_plane\": ref_plane,\n                \"norm_sq\": ref_norm_sq,\n                \"solution\": solution_for_ref\n            })\n            \n    # 4. Select the final solution\n    if not valid_solutions:\n        return []\n\n    valid_solutions.sort(key=lambda x: (x[\"norm_sq\"], x[\"ref_plane\"]))\n    \n    return valid_solutions[0][\"solution\"]\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2830544"}]}