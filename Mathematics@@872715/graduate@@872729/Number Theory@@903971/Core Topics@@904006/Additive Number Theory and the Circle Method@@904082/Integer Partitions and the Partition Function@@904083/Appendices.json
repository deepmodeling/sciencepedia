{"hands_on_practices": [{"introduction": "Our hands-on exploration begins with a direct, combinatorial approach to computing the partition function. This exercise [@problem_id:3015950] has you build the values of $p(n)$ from the ground up using a dynamic programming method based on adding parts of increasing size. Implementing this algorithm will provide a concrete feel for the additive structure of partitions and hone your skills in complexity analysis.", "problem": "Given the partition function $p(n)$, which counts the number of ways to write a nonnegative integer $n$ as a sum of positive integers without regard to order, design and implement a Dynamic Programming (DP) algorithm that computes $p(n)$ for all $n \\leq N$ by iterating over part sizes. In particular, use the following structure: maintain a one-dimensional array $d[0\\,..\\,N]$ with $d(0)=1$ and, for each part size $k$ from $1$ to $N$, update $d(n)$ for all $n$ from $k$ to $N$ using the recurrence $d(n) \\leftarrow d(n) + d(n-k)$. This recurrence must be used exactly in the prescribed loop order: the outer loop iterates over $k$ and the inner loop iterates over $n$ increasing from $k$ to $N$.\n\nStart from the fundamental combinatorial definition of $p(n)$ and justify the algorithm purely in terms of counting partitions whose parts are drawn from a bounded set. Then analyze the algorithm’s time and space complexity precisely, under the following conventions:\n\n- Time is measured as the exact number of primitive addition updates performed on the DP array entries $d(n)$, namely the count of operations of the form $d(n) \\leftarrow d(n) + d(n-k)$ across the entire execution for a given $N$.\n- Space is measured as the exact number of array cells required to hold the DP state, not including constant-sized scalars and loop indices.\n- To capture arithmetic growth, additionally compute the maximum bit-length among all computed values $d(n)$ for $0 \\leq n \\leq N$, where the bit-length of a positive integer $m$ is defined as $\\lfloor \\log_2(m) \\rfloor + 1$ and the bit-length of $0$ is defined as $1$.\n\nYour program must implement the above DP algorithm and, for each specified test case $N$, produce the following outputs:\n\n- The exact number of primitive additions performed, denoted $T_{\\text{add}}(N)$.\n- The exact number of DP array cells used, denoted $S_{\\text{cells}}(N)$.\n- The maximum bit-length among the computed counts, denoted $B_{\\max}(N)$.\n- The list of partition counts $\\left[p(0), p(1), \\dots, p(N)\\right]$.\n\nTest Suite:\n- $N = 0$ (boundary case with minimal input),\n- $N = 1$ (small case),\n- $N = 5$ (moderate small case),\n- $N = 30$ (larger case to exercise growth and complexity).\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each element of this list should correspond to one test case $N$ and must itself be a list in the exact order $[T_{\\text{add}}(N), S_{\\text{cells}}(N), B_{\\max}(N), [p(0), p(1), \\dots, p(N)]]$. For example, an output with two test cases would look like $[[t_1,s_1,b_1,[\\dots]], [t_2,s_2,b_2,[\\dots]]]$.", "solution": "The task is to provide a comprehensive justification and complexity analysis for a specified Dynamic Programming (DP) algorithm that computes the integer partition function, $p(n)$, for all non-negative integers $n \\leq N$. The algorithm's implementation and output must conform to a precise set of requirements.\n\n### Step 1: Problem Validation\n\nThe problem statement has been evaluated against the specified criteria and is determined to be **valid**. It is a well-posed, scientifically grounded problem from the field of number theory and algorithms. It provides a clear, complete, and consistent description of the task, including the exact algorithm to be used, the analysis metrics to be computed, and the required output format. All terms are standard and well-defined.\n\n### Step 2: Principle-Based Design and Analysis\n\n**Combinatorial Foundation**\n\nThe partition function $p(n)$ counts the number of ways to write an integer $n$ as a sum of positive integers, where the order of the summands (or \"parts\") does not matter. For example, $p(4) = 5$ because $4$ can be written as: $4$, $3+1$, $2+2$, $2+1+1$, and $1+1+1+1$. By convention, $p(0)=1$, corresponding to the empty sum.\n\nTo construct a DP solution, we introduce a more constrained function. Let $p_k(n)$ be the number of partitions of $n$ where all parts are less than or equal to a given positive integer $k$. Our ultimate goal is to compute $p(n)$ for $n \\le N$. For any such $n$, any partition of $n$ can only contain parts less than or equal to $n$, and therefore less than or equal to $N$. This implies that $p_N(n) = p(n)$ for all $n \\le N$.\n\nWe can establish a recurrence for $p_k(n)$. Any partition of $n$ using parts from the set $\\{1, 2, \\dots, k\\}$ can be classified into two disjoint categories:\n1.  Partitions that do **not** contain the part $k$. These are partitions of $n$ where all parts are from the set $\\{1, 2, \\dots, k-1\\}$. The number of such partitions is, by definition, $p_{k-1}(n)$.\n2.  Partitions that contain the part $k$ at least once. If we remove one part $k$ from such a partition, we are left with a partition of the integer $n-k$. The parts of this remaining partition must also be less than or equal to $k$. The number of such partitions is $p_k(n-k)$.\n\nCombining these two cases gives the recurrence relation:\n$$ p_k(n) = p_{k-1}(n) + p_k(n-k) $$\nwith base cases $p_k(0) = 1$ for all $k \\ge 0$ and $p_0(n) = 0$ for $n  0$.\n\n**Algorithm Justification**\n\nThe problem specifies a DP algorithm using a single one-dimensional array, let's call it $d$, of size $N+1$. The algorithm is specified as:\n1.  Initialize $d[0] = 1$ and $d[n] = 0$ for $n \\in \\{1, \\dots, N\\}$.\n2.  Use nested loops: for $k$ from $1$ to $N$, and for $n$ from $k$ to $N$.\n3.  Perform the update: $d[n] \\leftarrow d[n] + d[n-k]$.\n\nWe now justify that this procedure correctly computes $d[n] = p(n)$ for all $n \\le N$. Let $d_k[n]$ denote the value in the array cell $d[n]$ after the completion of the outer loop for part size $k$.\nThe initialization corresponds to the base case for $k=0$: $d_0[0]=1$ (representing $p_0(0)=1$) and $d_0[n]=0$ for $n0$ (representing $p_0(n)=0$).\n\nWe proceed by induction. Assume that after the outer loop for $k-1$ is complete, the array holds the values for partitions with parts up to $k-1$, i.e., $d_{k-1}[n] = p_{k-1}(n)$ for all $n \\le N$.\n\nNow, consider the execution of the outer loop for part size $k$. The inner loop iterates $n$ from $k$ to $N$. The update is:\n$$ d[n] \\leftarrow d[n] + d[n-k] $$\nWhen this statement is executed for a specific $n$, the value of $d[n]$ on the right-hand side is the value before this update, which is $d_{k-1}[n]$ (since it was last updated in the loop for $k-1$). The crucial observation concerns the term $d[n-k]$. Because the inner loop for $n$ is increasing (i.e., we compute for $n=k, k+1, \\dots$), the value $d[n-k]$ has *already* been updated during the current outer loop for $k$. Therefore, $d[n-k]$ on the right-hand side represents the new value, $d_k[n-k]$.\nThus, the update rule effectively implements:\n$$ d_k[n] = d_{k-1}[n] + d_k[n-k] $$\nThis is precisely the recurrence relation we derived for $p_k(n)$. Therefore, by induction, after the outer loop for $k$ completes, we have $d_k[n] = p_k(n)$ for all $n \\in \\{0, \\dots, N\\}$.\n\nAfter the final iteration of the outer loop (for $k=N$), the array will contain $d[n] = d_N[n] = p_N(n)$. As established earlier, for $n \\le N$, $p_N(n) = p(n)$. The algorithm is therefore correct.\n\n**Complexity Analysis**\n\n*   **Time Complexity ($T_{\\text{add}}(N)$)**: The problem defines time complexity as the exact number of primitive addition updates of the form $d(n) \\leftarrow d(n) + d(n-k)$. This operation is performed exactly once inside the nested loops. The number of additions is the total number of iterations.\n    $$ T_{\\text{add}}(N) = \\sum_{k=1}^{N} \\sum_{n=k}^{N} 1 $$\n    The inner summation counts the number of values from $n=k$ to $n=N$, which is $N - k + 1$.\n    $$ T_{\\text{add}}(N) = \\sum_{k=1}^{N} (N - k + 1) $$\n    This is the sum of an arithmetic progression. Letting $j = N - k + 1$, as $k$ goes from $1$ to $N$, $j$ goes from $N$ to $1$. The sum is equivalent to:\n    $$ T_{\\text{add}}(N) = \\sum_{j=1}^{N} j = \\frac{N(N+1)}{2} $$\n\n*   **Space Complexity ($S_{\\text{cells}}(N)$)**: This is defined as the number of array cells required for the DP state. The algorithm uses a single array $d$ indexed from $0$ to $N$.\n    $$ S_{\\text{cells}}(N) = N + 1 $$\n\n*   **Maximum Bit-Length ($B_{\\max}(N)$)**: This is the maximum bit-length among all computed partition numbers, $\\{p(0), p(1), \\dots, p(N)\\}$. The bit-length of a positive integer $m$ is $\\lfloor \\log_2(m) \\rfloor + 1$. Since $p(n)  0$ for all $n \\ge 0$, this formula applies to all final values in the DP array. $B_{\\max}(N)$ is calculated empirically by the program after the DP table is fully computed.\n    $$ B_{\\max}(N) = \\max_{0 \\le n \\le N} \\left( \\lfloor \\log_2(p(n)) \\rfloor + 1 \\right) $$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport sys\n\n# Per problem specification, no other libraries outside the standard library are permitted.\n# numpy is listed as available but is not used, as Python's native arbitrary-precision\n# integers are better suited for the partition function, which grows very rapidly.\n\ndef solve():\n    \"\"\"\n    Solves the integer partition problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        0,  # boundary case with minimal input\n        1,  # small case\n        5,  # moderate small case\n        30, # larger case to exercise growth and complexity\n    ]\n\n    # Increase recursion limit for potentially deep calculations in other contexts,\n    # though not strictly necessary for this iterative DP approach.\n    # sys.setrecursionlimit(2000)\n\n    final_results = []\n    for N in test_cases:\n        # Calculate T_add(N): the exact number of primitive additions.\n        # This is the sum of an arithmetic series: sum_{j=1 to N} j = N * (N + 1) / 2.\n        T_add = (N * (N + 1)) // 2\n\n        # Calculate S_cells(N): the number of DP array cells.\n        # The array is indexed from 0 to N, so it has N+1 cells.\n        S_cells = N + 1\n\n        # DP algorithm to compute partition numbers p(n) for n = N.\n        # The array `dp` will store p(n).\n        dp = [0] * S_cells\n        \n        # Base case: p(0) = 1 (the empty partition).\n        if S_cells  0:\n            dp[0] = 1\n\n        # The outer loop iterates over the part size 'k'.\n        for k in range(1, N + 1):\n            # The inner loop iterates over the integer 'n' to be partitioned.\n            # The loop for 'n' must be increasing for the space optimization to work correctly.\n            for n in range(k, N + 1):\n                dp[n] += dp[n - k]\n\n        # Calculate B_max(N): the maximum bit-length among the computed counts.\n        # The problem defines the bit-length of a positive integer m as\n        # floor(log2(m)) + 1. Python's int.bit_length() method matches this\n        # for positive integers. Since p(n)  0 for all n = 0, this is sufficient.\n        # The bit-length of 0 is defined as 1, but p(n) is never 0 for n = 0.\n        B_max = 0\n        if dp:\n            B_max = max(val.bit_length() for val in dp)\n\n        # Collate results for the current test case N.\n        result_for_N = [T_add, S_cells, B_max, dp]\n        final_results.append(result_for_N)\n\n    # Format and print the final output as a single-line string.\n    # The output is a list of lists, where each inner list corresponds to a test case.\n    # To avoid extra spaces and ensure exact format, we construct the string manually.\n    output_str_parts = []\n    for res in final_results:\n        # res[3] is the list of partition numbers, which needs its own string representation.\n        p_list_str = f\"[{','.join(map(str, res[3]))}]\"\n        # Combine all parts for one test case.\n        case_str = f\"[{res[0]},{res[1]},{res[2]},{p_list_str}]\"\n        output_str_parts.append(case_str)\n    \n    print(f\"[{','.join(output_str_parts)}]\")\n\nsolve()\n```", "id": "3015950"}, {"introduction": "Having established a combinatorial method for computing $p(n)$, we now turn to the powerful framework of generating functions, a central tool in modern number theory. This practice [@problem_id:3015946] guides you through deriving the highly efficient Euler's pentagonal number recurrence from the generating function identity for $p(n)$. By implementing this recurrence, you will not only build a much faster algorithm but also apply it to computationally verify one of Ramanujan's celebrated congruences, offering a first-hand look at the profound modular properties of the partition function.", "problem": "You are to write a complete, runnable program that computes values of the partition function modulo a fixed modulus by deriving and implementing a principled recurrence from foundational identities in the ring of formal power series. Your implementation must be based on a derivation that starts from the generating function definition of the integer partition function and standard facts about formal power series, without assuming any precomputed values of the partition function. In particular, begin from the fundamental identity in the ring of formal power series\n$$\n\\sum_{n\\ge 0} p(n)\\,x^n \\;=\\; \\prod_{k\\ge 1}\\frac{1}{1-x^k},\n$$\nwhere $p(n)$ denotes the number of integer partitions of $n$, and deduce an effective, finite recurrence that allows you to compute $p(n)\\bmod m$ for all $n$ up to a given bound. You may use any classical consequences that can be rigorously derived from the generating function within this framework, together with the fact that computations can be carried out modulo $m$ inside the ring of formal power series with coefficients in the integers modulo $m$.\n\nYour program must carry out the following tasks:\n- Compute $p(n)\\bmod 5$ for all integers $n$ with $0\\le n\\le 34$.\n- Extract the subsequence $p(5k+4)\\bmod 5$ for all integers $k$ with $0\\le k\\le 6$.\n- Verify computationally whether the congruence $p(5n+4)\\equiv 0 \\pmod{5}$ holds for all integers $n$ with $0\\le n\\le 6$.\n\nTest suite and required outputs:\n- Use the parameters $n_{\\max}=34$ and $m=5$.\n- Your program must produce three results that collectively exercise correctness and boundary behavior:\n    1. The full list of residues $[p(n)\\bmod 5]$ for all integers $n$ with $0\\le n\\le 34$ (this list has length $35$ and includes the boundary case $n=0$).\n    2. The extracted list of residues $[p(5k+4)\\bmod 5]$ for all integers $k$ with $0\\le k\\le 6$ (corresponding to indices $4,9,14,19,24,29,34$).\n    3. A single boolean value indicating whether all entries in the second list are equal to $0$ in $\\mathbb{Z}/5\\mathbb{Z}$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The first element must be the list from item $1$, the second element must be the list from item $2$, and the third element must be the boolean from item $3$. For example, your output should have the form\n$$\n[\\,[\\dots 35\\ \\text{integers}\\dots],\\,[\\dots 7\\ \\text{integers}\\dots],\\,\\text{True or False}\\,].\n$$\nNo inputs are to be read from standard input, and no external files may be used. All integers are to be reported as plain integers without any unit. The boolean must be a literal boolean.", "solution": "The problem requires the computation of the integer partition function $p(n)$ modulo a prime $m=5$ up to a bound $n_{\\max}=34$. We are to derive a valid computational recurrence from the generating function for $p(n)$ in the ring of formal power series $\\mathbb{Z}[[x]]$.\n\nThe generating function for the number of partitions of an integer $n$, denoted $p(n)$, is given by the identity:\n$$P(x) = \\sum_{n=0}^{\\infty} p(n)x^n = \\prod_{k=1}^{\\infty} \\frac{1}{1-x^k}$$\nBy convention, $p(0)=1$, which corresponds to the single partition of $0$ (the empty partition). For $n0$, we define $p(n)=0$.\n\nThis identity holds in the ring of formal power series $\\mathbb{Z}[[x]]$. The multiplicative inverse of $P(x)$ is therefore:\n$$\\Phi(x) = P(x)^{-1} = \\prod_{k=1}^{\\infty} (1-x^k)$$\nA fundamental result in the theory of partitions, Euler's Pentagonal Number Theorem, provides a series expansion for $\\Phi(x)$:\n$$\\Phi(x) = \\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j} = 1 - x - x^2 + x^5 + x^7 - x^{12} - x^{15} + \\dots$$\nwhere the exponents $\\omega_j = \\frac{j(3j-1)}{2}$ are the generalized pentagonal numbers for $j \\in \\mathbb{Z}$.\n\nThe product of $P(x)$ and its inverse $\\Phi(x)$ is the multiplicative identity in $\\mathbb{Z}[[x]]$, which is the formal power series $1$:\n$$P(x) \\Phi(x) = \\left(\\sum_{n=0}^{\\infty} p(n)x^n\\right) \\left(\\sum_{j=-\\infty}^{\\infty} (-1)^j x^{\\omega_j}\\right) = 1$$\nFor any $n0$, the coefficient of $x^n$ in the product series must be $0$. Using the Cauchy product formula for the coefficient of $x^n$, which we denote as $[x^n]$, we have:\n$$[x^n](P(x)\\Phi(x)) = \\sum_{j=-\\infty}^{\\infty} \\left( [x^{\\omega_j}]\\Phi(x) \\right) \\cdot \\left( [x^{n-\\omega_j}]P(x) \\right) = \\sum_{j=-\\infty}^{\\infty} (-1)^j p(n-\\omega_j) = 0$$\nThis holds for all $n0$. The term for $j=0$ corresponds to $\\omega_0=0$, giving $(-1)^0 p(n-0) = p(n)$. We can thus isolate $p(n)$ from the sum:\n$$p(n) + \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = 0$$\nThis yields the desired recurrence relation for $p(n)$:\n$$p(n) = -\\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^j p(n-\\omega_j) = \\sum_{j \\in \\mathbb{Z}, j \\neq 0} (-1)^{j-1} p(n-\\omega_j)$$\nFor computational purposes, it is convenient to group the terms for $j=k$ and $j=-k$ ($k \\in \\mathbb{Z}, k \\ge 1$). The corresponding pentagonal numbers are $\\omega_k = \\frac{k(3k-1)}{2}$ and $\\omega_{-k} = \\frac{k(3k+1)}{2}$. The recurrence becomes:\n$$p(n) = \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right)$$\nwhich can be written more explicitly as:\n$$p(n) = [p(n-1)+p(n-2)] - [p(n-5)+p(n-7)] + [p(n-12)+p(n-15)] - \\dots$$\nwhere the sum is finite, as $p(k)=0$ for $k0$.\n\nThis recurrence relation involves only integer additions and subtractions. Therefore, it is valid to perform all computations modulo an integer $m$. Specifically, we compute $p(n) \\pmod 5$:\n$$p(n) \\equiv \\sum_{k=1}^{\\infty} (-1)^{k-1} \\left( p\\left(n - \\frac{k(3k-1)}{2}\\right) + p\\left(n - \\frac{k(3k+1)}{2}\\right) \\right) \\pmod 5$$\n\nThe algorithm proceeds as follows:\n1.  Initialize an array, say `p_mod_m`, of size $n_{\\max}+1=35$ to store the values of $p(n) \\bmod 5$.\n2.  Set the base case: `p_mod_m[0] = 1`.\n3.  Iterate for $n$ from $1$ to $34$. In each iteration, compute `p_mod_m[n]` using the recurrence relation. The calculation for each $p(n)$ uses previously computed values $p(k)$ where $k  n$.\n4.  After computing all values up to $p(34) \\pmod 5$, a list of these $35$ residues is formed.\n5.  A second list is extracted, containing the values $p(5k+4) \\pmod 5$ for $k \\in \\{0, 1, \\dots, 6\\}$. These correspond to indices $4, 9, 14, 19, 24, 29, 34$ in the main list.\n6.  Finally, a boolean value is determined by checking if all elements of the second list are congruent to $0 \\pmod 5$. This computationally verifies a specific instance of Ramanujan's congruence $p(5k+4) \\equiv 0 \\pmod 5$.\nThe three resulting objects—the full list of residues, the extracted sublist, and the boolean verification—are then formatted into the required final output string.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes partition function values p(n) modulo 5 based on a recurrence\n    derived from the generating function, then verifies a Ramanujan congruence.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    n_max = 34\n    m = 5\n\n    # 1. Compute p(n) mod m for 0 = n = n_max.\n    \n    # Initialize an array to store p(n) mod m.\n    # We use a numpy array for efficient integer operations.\n    p = np.zeros(n_max + 1, dtype=int)\n    \n    # Base case: p(0) = 1 (the empty partition).\n    p[0] = 1\n\n    # Apply the recurrence relation derived from Euler's Pentagonal Number Theorem.\n    # p(n) = sum_{k=1 to inf} (-1)^(k-1) * [p(n - k(3k-1)/2) + p(n - k(3k+1)/2)]\n    for n in range(1, n_max + 1):\n        val = 0\n        sign = 1\n        k = 1\n        while True:\n            # Generalized pentagonal numbers for k and -k.\n            pent_k = k * (3 * k - 1) // 2\n            pent_minus_k = k * (3 * k + 1) // 2\n            \n            # Add p(n - pent_k) term.\n            if n - pent_k = 0:\n                val += sign * p[n - pent_k]\n            else:\n                # Since pentagonal numbers are strictly increasing with k,\n                # we can break if n - pent_k is negative.\n                break\n\n            # Add p(n - pent_minus_k) term.\n            if n - pent_minus_k = 0:\n                val += sign * p[n - pent_minus_k]\n\n            # Alternate the sign for the next pair of terms.\n            sign *= -1\n            k += 1\n        \n        # Store the result modulo m. Python's % operator handles negative\n        # results correctly for modular arithmetic (e.g., -1 % 5 == 4).\n        p[n] = val % m\n\n    # Convert the numpy array of all results to a standard Python list.\n    full_residue_list = p.tolist()\n\n    # 2. Extract the subsequence p(5k+4) mod 5.\n    subsequence_indices = [5 * k + 4 for k in range(7)] # k from 0 to 6\n    extracted_subsequence = [p[i] for i in subsequence_indices]\n\n    # 3. Verify the congruence p(5n+4) = 0 (mod 5).\n    is_congruence_verified = all(x == 0 for x in extracted_subsequence)\n    \n    # Final print statement in the exact required format.\n    # Python's str() for lists and booleans matches the required format.\n    print(f\"[{full_residue_list},{extracted_subsequence},{is_congruence_verified}]\")\n\nsolve()\n\n```", "id": "3015946"}, {"introduction": "The congruences discovered by Ramanujan, which you explored computationally in the previous exercise, begged for a combinatorial explanation. This final practice [@problem_id:3015948] introduces you to the 'rank' and 'crank' of a partition—statistics designed specifically to provide such an explanation. By meticulously enumerating the partitions of a small integer and calculating these statistics, you will gain a deep, hands-on appreciation for how these combinatorial tools group partitions into classes of equal size, beautifully explaining the divisibility properties of $p(n)$.", "problem": "Let $n$ be a positive integer and let a partition $\\pi$ of $n$ be a finite nonincreasing sequence of positive integers whose sum is $n$. Denote by $p(n)$ the number of partitions of $n$. For a partition $\\pi$, define its rank $\\mathrm{rank}(\\pi)$ to be the largest part of $\\pi$ minus the number of parts of $\\pi$. Define its crank $\\mathrm{crank}(\\pi)$ as follows: write $\\lambda(\\pi)$ for the largest part of $\\pi$, $\\mu(\\pi)$ for the number of $1$'s occurring in $\\pi$, and $\\nu(\\pi)$ for the number of parts strictly larger than $\\mu(\\pi)$. Then\n- if $\\mu(\\pi)=0$, set $\\mathrm{crank}(\\pi)=\\lambda(\\pi)$,\n- if $\\mu(\\pi)0$, set $\\mathrm{crank}(\\pi)=\\nu(\\pi)-\\mu(\\pi)$.\n\nFor a fixed $n$, define the rank-distribution and crank-distribution polynomials\n$$R_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{rank}(\\pi)}\\quad\\text{and}\\quad C_{n}(z)=\\sum_{\\pi\\vdash n} z^{\\mathrm{crank}(\\pi)},$$\nwhere the sum ranges over all partitions $\\pi$ of $n$ and $z$ is a formal variable.\n\nStarting from the definitions above and fundamental properties of Ferrers diagram conjugation, compute $R_{9}(z)$ and $C_{9}(z)$ explicitly by enumerating all partitions of $9$, determining $\\mathrm{rank}(\\pi)$ and $\\mathrm{crank}(\\pi)$ for each, and summing their contributions. Then, verify the symmetry properties of these distributions under $z\\mapsto z^{-1}$ for $n=9$ by identifying the appropriate combinatorial involutions and confirming that the coefficient sequences are symmetric. Express your final answer as closed-form polynomials in $z$ for $R_{9}(z)$ and $C_{9}(z)$.", "solution": "The problem is to compute the rank-distribution polynomial $R_{9}(z)$ and the crank-distribution polynomial $C_{9}(z)$ for partitions of the integer $n=9$. This task requires the explicit enumeration of all partitions of $9$, followed by the calculation of the rank and crank for each partition.\n\nThe number of partitions of $n=9$, denoted $p(9)$, is $30$. The partitions of $9$ are:\n$1$. $\\pi_1 = (9)$\n$2$. $\\pi_2 = (8,1)$\n$3$. $\\pi_3 = (7,2)$\n$4$. $\\pi_4 = (7,1,1)$\n$5$. $\\pi_5 = (6,3)$\n$6$. $\\pi_6 = (6,2,1)$\n$7$. $\\pi_7 = (6,1,1,1)$\n$8$. $\\pi_8 = (5,4)$\n$9$. $\\pi_9 = (5,3,1)$\n$10$. $\\pi_{10} = (5,2,2)$\n$11$. $\\pi_{11} = (5,2,1,1)$\n$12$. $\\pi_{12} = (5,1,1,1,1)$\n$13$. $\\pi_{13} = (4,4,1)$\n$14$. $\\pi_{14} = (4,3,2)$\n$15$. $\\pi_{15} = (4,3,1,1)$\n$16$. $\\pi_{16} = (4,2,2,1)$\n$17$. $\\pi_{17} = (4,2,1,1,1)$\n$18$. $\\pi_{18} = (4,1,1,1,1,1)$\n$19$. $\\pi_{19} = (3,3,3)$\n$20$. $\\pi_{20} = (3,3,2,1)$\n$21$. $\\pi_{21} = (3,3,1,1,1)$\n$22$. $\\pi_{22} = (3,2,2,2)$\n$23$. $\\pi_{23} = (3,2,2,1,1)$\n$24$. $\\pi_{24} = (3,2,1,1,1,1)$\n$25$. $\\pi_{25} = (3,1,1,1,1,1,1)$\n$26$. $\\pi_{26} = (2,2,2,2,1)$\n$27$. $\\pi_{27} = (2,2,2,1,1,1)$\n$28$. $\\pi_{28} = (2,2,1,1,1,1,1)$\n$29$. $\\pi_{29} = (2,1,1,1,1,1,1,1)$\n$30$. $\\pi_{30} = (1,1,1,1,1,1,1,1,1)$\n\nFirst, we compute the rank-distribution polynomial $R_{9}(z)$. The rank of a partition $\\pi$ is defined as $\\mathrm{rank}(\\pi) = \\lambda(\\pi) - k(\\pi)$, where $\\lambda(\\pi)$ is the largest part and $k(\\pi)$ is the number of parts. We calculate the rank for each partition of $9$:\n$\\mathrm{rank}(\\pi_1) = 9-1=8$\n$\\mathrm{rank}(\\pi_2) = 8-2=6$\n$\\mathrm{rank}(\\pi_3) = 7-2=5$\n$\\mathrm{rank}(\\pi_4) = 7-3=4$\n$\\mathrm{rank}(\\pi_5) = 6-2=4$\n$\\mathrm{rank}(\\pi_6) = 6-3=3$\n$\\mathrm{rank}(\\pi_7) = 6-4=2$\n$\\mathrm{rank}(\\pi_8) = 5-2=3$\n$\\mathrm{rank}(\\pi_9) = 5-3=2$\n$\\mathrm{rank}(\\pi_{10}) = 5-3=2$\n$\\mathrm{rank}(\\pi_{11}) = 5-4=1$\n$\\mathrm{rank}(\\pi_{12}) = 5-5=0$\n$\\mathrm{rank}(\\pi_{13}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{14}) = 4-3=1$\n$\\mathrm{rank}(\\pi_{15}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{16}) = 4-4=0$\n$\\mathrm{rank}(\\pi_{17}) = 4-5=-1$\n$\\mathrm{rank}(\\pi_{18}) = 4-6=-2$\n$\\mathrm{rank}(\\pi_{19}) = 3-3=0$\n$\\mathrm{rank}(\\pi_{20}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{21}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{22}) = 3-4=-1$\n$\\mathrm{rank}(\\pi_{23}) = 3-5=-2$\n$\\mathrm{rank}(\\pi_{24}) = 3-6=-3$\n$\\mathrm{rank}(\\pi_{25}) = 3-7=-4$\n$\\mathrm{rank}(\\pi_{26}) = 2-5=-3$\n$\\mathrm{rank}(\\pi_{27}) = 2-6=-4$\n$\\mathrm{rank}(\\pi_{28}) = 2-7=-5$\n$\\mathrm{rank}(\\pi_{29}) = 2-8=-6$\n$\\mathrm{rank}(\\pi_{30}) = 1-9=-8$\n\nThe rank-distribution polynomial is $R_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{rank}(\\pi_i)}$. We collect terms with the same exponent:\n- Coefficient of $z^8$: $1$\n- Coefficient of $z^6$: $1$\n- Coefficient of $z^5$: $1$\n- Coefficient of $z^4$: $2$\n- Coefficient of $z^3$: $2$\n- Coefficient of $z^2$: $3$\n- Coefficient of $z^1$: $3$\n- Coefficient of $z^0$: $4$\n- Coefficient of $z^{-1}$: $3$\n- Coefficient of $z^{-2}$: $3$\n- Coefficient of $z^{-3}$: $2$\n- Coefficient of $z^{-4}$: $2$\n- Coefficient of $z^{-5}$: $1$\n- Coefficient of $z^{-6}$: $1$\n- Coefficient of $z^{-8}$: $1$\nAll other coefficients are $0$.\nThus, the polynomial is:\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$.\n\nThe symmetry of the coefficients, where the coefficient of $z^k$ equals that of $z^{-k}$, is evident from the explicit calculation. This symmetry is guaranteed by the combinatorial involution of conjugation of Ferrers diagrams. For any partition $\\pi$, its conjugate $\\pi'$ has its largest part equal to the number of parts of $\\pi$, and its number of parts equal to the largest part of $\\pi$. That is, $\\lambda(\\pi')=k(\\pi)$ and $k(\\pi')=\\lambda(\\pi)$. Therefore, $\\mathrm{rank}(\\pi') = \\lambda(\\pi') - k(\\pi') = k(\\pi) - \\lambda(\\pi) = -\\mathrm{rank}(\\pi)$. This involution pairs partitions of rank $k$ with partitions of rank $-k$. Partitions with rank $0$ are either self-conjugate (fixed by the involution) or come in conjugate pairs of rank-$0$ partitions.\n\nNext, we compute the crank-distribution polynomial $C_{9}(z)$. The crank is defined using $\\lambda(\\pi)$ (largest part), $\\mu(\\pi)$ (number of 1s), and $\\nu(\\pi)$ (number of parts $\\mu(\\pi)$). If $\\mu(\\pi)=0$, $\\mathrm{crank}(\\pi) = \\lambda(\\pi)$. If $\\mu(\\pi)0$, $\\mathrm{crank}(\\pi) = \\nu(\\pi) - \\mu(\\pi)$.\n$\\mathrm{crank}(\\pi_1)$: $\\mu(\\pi_1)=0$, so $\\mathrm{crank}(\\pi_1)=9$.\n$\\mathrm{crank}(\\pi_2)$: $\\mu(\\pi_2)=1$, parts are $(8,1)$. $\\nu(\\pi_2)$=number of parts $1$, is $1$. $\\mathrm{crank}(\\pi_2)=1-1=0$.\n$\\mathrm{crank}(\\pi_3)$: $\\mu(\\pi_3)=0$, so $\\mathrm{crank}(\\pi_3)=7$.\n$\\mathrm{crank}(\\pi_4)$: $\\mu(\\pi_4)=2$, parts are $(7,1,1)$. $\\nu(\\pi_4)$=number of parts $2$, is $1$. $\\mathrm{crank}(\\pi_4)=1-2=-1$.\n$\\mathrm{crank}(\\pi_5)$: $\\mu(\\pi_5)=0$, so $\\mathrm{crank}(\\pi_5)=6$.\n$\\mathrm{crank}(\\pi_6)$: $\\mu(\\pi_6)=1$, parts $(6,2,1)$. $\\nu(\\pi_6)$=parts $1$, is $2$. $\\mathrm{crank}(\\pi_6)=2-1=1$.\n$\\mathrm{crank}(\\pi_7)$: $\\mu(\\pi_7)=3$, parts $(6,1,1,1)$. $\\nu(\\pi_7)$=parts $3$, is $1$. $\\mathrm{crank}(\\pi_7)=1-3=-2$.\n$\\mathrm{crank}(\\pi_8)$: $\\mu(\\pi_8)=0$, so $\\mathrm{crank}(\\pi_8)=5$.\n$\\mathrm{crank}(\\pi_9)$: $\\mu(\\pi_9)=1$, parts $(5,3,1)$. $\\nu(\\pi_9)$=parts $1$, is $2$. $\\mathrm{crank}(\\pi_9)=2-1=1$.\n$\\mathrm{crank}(\\pi_{10})$: $\\mu(\\pi_{10})=0$, so $\\mathrm{crank}(\\pi_{10})=5$.\n$\\mathrm{crank}(\\pi_{11})$: $\\mu(\\pi_{11})=2$, parts $(5,2,1,1)$. $\\nu(\\pi_{11})$=parts $2$, is $1$. $\\mathrm{crank}(\\pi_{11})=1-2=-1$.\n$\\mathrm{crank}(\\pi_{12})$: $\\mu(\\pi_{12})=4$, parts $(5,1,1,1,1)$. $\\nu(\\pi_{12})$=parts $4$, is $1$. $\\mathrm{crank}(\\pi_{12})=1-4=-3$.\n$\\mathrm{crank}(\\pi_{13})$: $\\mu(\\pi_{13})=1$, parts $(4,4,1)$. $\\nu(\\pi_{13})$=parts $1$, is $2$. $\\mathrm{crank}(\\pi_{13})=2-1=1$.\n$\\mathrm{crank}(\\pi_{14})$: $\\mu(\\pi_{14})=0$, so $\\mathrm{crank}(\\pi_{14})=4$.\n$\\mathrm{crank}(\\pi_{15})$: $\\mu(\\pi_{15})=2$, parts $(4,3,1,1)$. $\\nu(\\pi_{15})$=parts $2$, is $2$. $\\mathrm{crank}(\\pi_{15})=2-2=0$.\n$\\mathrm{crank}(\\pi_{16})$: $\\mu(\\pi_{16})=1$, parts $(4,2,2,1)$. $\\nu(\\pi_{16})$=parts $1$, is $3$. $\\mathrm{crank}(\\pi_{16})=3-1=2$.\n$\\mathrm{crank}(\\pi_{17})$: $\\mu(\\pi_{17})=3$, parts $(4,2,1,1,1)$. $\\nu(\\pi_{17})$=parts $3$, is $1$. $\\mathrm{crank}(\\pi_{17})=1-3=-2$.\n$\\mathrm{crank}(\\pi_{18})$: $\\mu(\\pi_{18})=5$, parts $(4,1^5)$. $\\nu(\\pi_{18})$=parts $5$, is $0$. $\\mathrm{crank}(\\pi_{18})=0-5=-5$.\n$\\mathrm{crank}(\\pi_{19})$: $\\mu(\\pi_{19})=0$, so $\\mathrm{crank}(\\pi_{19})=3$.\n$\\mathrm{crank}(\\pi_{20})$: $\\mu(\\pi_{20})=1$, parts $(3,3,2,1)$. $\\nu(\\pi_{20})$=parts $1$, is $3$. $\\mathrm{crank}(\\pi_{20})=3-1=2$.\n$\\mathrm{crank}(\\pi_{21})$: $\\mu(\\pi_{21})=3$, parts $(3,3,1^3)$. $\\nu(\\pi_{21})$=parts $3$, is $0$. $\\mathrm{crank}(\\pi_{21})=0-3=-3$.\n$\\mathrm{crank}(\\pi_{22})$: $\\mu(\\pi_{22})=0$, so $\\mathrm{crank}(\\pi_{22})=3$.\n$\\mathrm{crank}(\\pi_{23})$: $\\mu(\\pi_{23})=2$, parts $(3,2,2,1,1)$. $\\nu(\\pi_{23})$=parts $2$, is $1$. $\\mathrm{crank}(\\pi_{23})=1-2=-1$.\n$\\mathrm{crank}(\\pi_{24})$: $\\mu(\\pi_{24})=4$, parts $(3,2,1^4)$. $\\nu(\\pi_{24})$=parts $4$, is $0$. $\\mathrm{crank}(\\pi_{24})=0-4=-4$.\n$\\mathrm{crank}(\\pi_{25})$: $\\mu(\\pi_{25})=6$, parts $(3,1^6)$. $\\nu(\\pi_{25})$=parts $6$, is $0$. $\\mathrm{crank}(\\pi_{25})=0-6=-6$.\n$\\mathrm{crank}(\\pi_{26})$: $\\mu(\\pi_{26})=1$, parts $(2^4,1)$. $\\nu(\\pi_{26})$=parts $1$, is $4$. $\\mathrm{crank}(\\pi_{26})=4-1=3$.\n$\\mathrm{crank}(\\pi_{27})$: $\\mu(\\pi_{27})=3$, parts $(2^3,1^3)$. $\\nu(\\pi_{27})$=parts $3$, is $0$. $\\mathrm{crank}(\\pi_{27})=0-3=-3$.\n$\\mathrm{crank}(\\pi_{28})$: $\\mu(\\pi_{28})=5$, parts $(2^2,1^5)$. $\\nu(\\pi_{28})$=parts $5$, is $0$. $\\mathrm{crank}(\\pi_{28})=0-5=-5$.\n$\\mathrm{crank}(\\pi_{29})$: $\\mu(\\pi_{29})=7$, parts $(2,1^7)$. $\\nu(\\pi_{29})$=parts $7$, is $0$. $\\mathrm{crank}(\\pi_{29})=0-7=-7$.\n$\\mathrm{crank}(\\pi_{30})$: $\\mu(\\pi_{30})=9$, parts $(1^9)$. $\\nu(\\pi_{30})$=parts $9$, is $0$. $\\mathrm{crank}(\\pi_{30})=0-9=-9$.\n\nThe crank-distribution polynomial is $C_{9}(z)=\\sum_{i=1}^{30} z^{\\mathrm{crank}(\\pi_i)}$. We collect terms:\n- Coeff of $z^9, z^7, z^6, z^4, z^{-4}, z^{-6}, z^{-7}, z^{-9}$: $1$ each\n- Coeff of $z^5, z^2, z^{-2}, z^{-5}$: $2$ each\n- Coeff of $z^3, z, z^{-1}, z^{-3}$: $3$ each\n- Coeff of $z^0$: $2$\nThus, the polynomial is:\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$.\n\nAgain, the symmetry of the coefficients is confirmed by direct computation. This is a general property of crank-distribution polynomials. The combinatorial proof relies on a bijection on the set of partitions, constructed by Andrews and Garvan, which maps a partition with crank $k$ to one with crank $-k$. The existence of this involution establishes that the number of partitions of $n$ with crank $k$ is equal to the number of partitions with crank $-k$, thus ensuring the symmetry of the coefficients of $C_n(z)$.\n\nThe final derived polynomials are:\n$R_{9}(z) = z^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}$\n$C_{9}(z) = z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nz^{8} + z^{6} + z^{5} + 2z^{4} + 2z^{3} + 3z^{2} + 3z + 4 + 3z^{-1} + 3z^{-2} + 2z^{-3} + 2z^{-4} + z^{-5} + z^{-6} + z^{-8}  z^{9} + z^{7} + z^{6} + 2z^{5} + z^{4} + 3z^{3} + 2z^{2} + 3z + 2 + 3z^{-1} + 2z^{-2} + 3z^{-3} + z^{-4} + 2z^{-5} + z^{-6} + z^{-7} + z^{-9}\n\\end{pmatrix}\n}\n$$", "id": "3015948"}]}