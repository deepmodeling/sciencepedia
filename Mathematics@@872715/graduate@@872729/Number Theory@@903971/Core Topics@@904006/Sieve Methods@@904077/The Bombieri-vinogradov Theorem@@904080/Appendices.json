{"hands_on_practices": [{"introduction": "Proofs of the Bombieri-Vinogradov theorem rely on the Large Sieve inequality, which provides a bound on sums over primitive Dirichlet characters. This exercise focuses on the function $\\phi^{\\ast}(q)$ that counts these characters, a quantity that dictates the \"size\" of the sieve. By deriving its properties from first principles [@problem_id:3025098], you will gain a deeper understanding of the fundamental objects in the theory and see how their aggregate count, $\\sum_{q \\le Q} \\phi^{\\ast}(q)$, directly influences the structure of the Large Sieve inequality.", "problem": "Let $q \\geq 1$ be an integer and let a Dirichlet character modulo $q$ be defined as a group homomorphism $\\chi : (\\mathbb{Z}/q\\mathbb{Z})^{\\times} \\to \\mathbb{C}^{\\times}$, extended to $\\mathbb{Z}$ by setting $\\chi(n) = 0$ whenever $\\gcd(n,q) \\neq 1$. The conductor of a Dirichlet character $\\chi$ is the minimal positive integer $f$ such that $\\chi$ is induced from a character modulo $f$ via the natural projection $(\\mathbb{Z}/q\\mathbb{Z})^{\\times} \\to (\\mathbb{Z}/f\\mathbb{Z})^{\\times}$. A character is called primitive if its conductor equals its modulus.\n\nDefine $\\phi(q)$ to be Euler’s totient function, and let $\\phi^{\\ast}(q)$ denote the number of primitive Dirichlet characters modulo $q$. Starting from the fundamental definitions of Dirichlet characters, conductors, and the structure of finite abelian groups, and using standard tools such as the Chinese Remainder Theorem and Möbius inversion, do the following:\n\n- Derive, from first principles, a divisor-sum expression for $\\phi^{\\ast}(q)$ in terms of $\\phi$ and the Möbius function $\\mu$.\n- Prove that $\\phi^{\\ast}(q)$ is multiplicative and compute $\\phi^{\\ast}(p^{k})$ explicitly for prime powers $p^{k}$.\n- Establish bounds of the form $\\phi^{\\ast}(q) \\ll \\phi(q)$ that are suitable for summation over the range $q \\leq Q$, and justify that $\\sum_{q \\leq Q} \\phi^{\\ast}(q) \\ll Q^{2}$, explaining the relevance of such bounds when summing over moduli in applications such as the Bombieri–Vinogradov theorem.\n- Finally, consider the Dirichlet series $F(s) = \\sum_{q=1}^{\\infty} \\frac{\\phi^{\\ast}(q)}{q^{s}}$ for $\\Re(s)$ sufficiently large. Compute $F(s)$ in closed form in terms of the Riemann zeta function $\\zeta(s)$.\n\nYour final answer should be the closed-form analytic expression for $F(s)$. No numerical rounding is required.", "solution": "The problem requires a multi-step analysis of the function $\\phi^{\\ast}(q)$, which counts the number of primitive Dirichlet characters modulo $q$. We will proceed through each required part systematically, grounding the derivation in the fundamental definitions provided.\n\nFirst, we derive a divisor-sum expression for $\\phi^{\\ast}(q)$. Let $X_q$ be the set of all Dirichlet characters modulo $q$. The order of the group $(\\mathbb{Z}/q\\mathbb{Z})^{\\times}$ is $\\phi(q)$, and its character group, $X_q$, is isomorphic to it, so $|X_q| = \\phi(q)$.\nA fundamental property of Dirichlet characters is that any character $\\chi$ modulo $q$ is induced by a unique primitive character $\\chi^{\\ast}$ modulo $f$, where $f$ is the conductor of $\\chi$. For this to be possible, the conductor $f$ must be a divisor of $q$. Conversely, for any divisor $f$ of $q$, any primitive character modulo $f$ induces a unique character modulo $q$. This establishes a partition of the set $X_q$ based on the conductor of its elements.\nThus, the total number of characters modulo $q$ can be expressed as the sum of the number of primitive characters modulo its divisors. This gives the relation:\n$$\n\\phi(q) = \\sum_{f|q} \\phi^{\\ast}(f)\n$$\nThis identity is a standard form for Möbius inversion. Let $g(q) = \\phi(q)$ and $h(q) = \\phi^{\\ast}(q)$. The identity is $g(q) = \\sum_{d|q} h(d)$. Applying the Möbius inversion formula, which states $h(q) = \\sum_{d|q} \\mu(d) g(q/d)$, we obtain the desired expression for $\\phi^{\\ast}(q)$:\n$$\n\\phi^{\\ast}(q) = \\sum_{d|q} \\mu(d) \\phi(q/d)\n$$\nThis expression is the Dirichlet convolution of the Möbius function $\\mu$ and Euler's totient function $\\phi$, denoted as $\\phi^{\\ast} = \\mu * \\phi$.\n\nSecond, we prove that $\\phi^{\\ast}(q)$ is a multiplicative function and compute its value on prime powers. A function $f$ is multiplicative if $f(mn) = f(m)f(n)$ for all coprime integers $m, n$. It is a standard theorem in number theory that the Dirichlet convolution of two multiplicative functions is also multiplicative. Since both the Möbius function $\\mu$ and Euler's totient function $\\phi$ are well-known to be multiplicative, their convolution $\\phi^{\\ast} = \\mu * \\phi$ must also be multiplicative.\nSince $\\phi^{\\ast}$ is multiplicative, its value for any $q$ can be determined from its values on prime powers $p^k$. Let's compute $\\phi^{\\ast}(p^k)$ for a prime $p$ and integer $k \\geq 1$. The divisors of $p^k$ are $1, p, p^2, \\ldots, p^k$. However, $\\mu(d)$ is non-zero only for square-free integers $d$. The only square-free divisors of $p^k$ are $1$ and $p$.\nTherefore, the sum for $\\phi^{\\ast}(p^k)$ simplifies significantly:\n$$\n\\phi^{\\ast}(p^k) = \\sum_{d|p^k} \\mu(d) \\phi(p^k/d) = \\mu(1)\\phi(p^k) + \\mu(p)\\phi(p^{k-1}) + \\sum_{j=2}^{k}\\mu(p^j)\\phi(p^{k-j})\n$$\nSince $\\mu(p^j) = 0$ for $j \\geq 2$, the sum reduces to:\n$$\n\\phi^{\\ast}(p^k) = \\mu(1)\\phi(p^k) + \\mu(p)\\phi(p^{k-1}) = (1)\\phi(p^k) + (-1)\\phi(p^{k-1}) = \\phi(p^k) - \\phi(p^{k-1})\n$$\nWe evaluate this for different values of $k$.\nFor $k=1$: $\\phi^{\\ast}(p) = \\phi(p) - \\phi(1) = (p-1) - 1 = p-2$.\nFor $k \\geq 2$: $\\phi(p^k) = p^k - p^{k-1}$ and $\\phi(p^{k-1}) = p^{k-1} - p^{k-2}$.\n$$\n\\phi^{\\ast}(p^k) = (p^k - p^{k-1}) - (p^{k-1} - p^{k-2}) = p^k - 2p^{k-1} + p^{k-2} = p^{k-2}(p^2 - 2p + 1) = p^{k-2}(p-1)^2\n$$\nFor completeness, for $q=1$, we have $\\phi^{\\ast}(1) = \\sum_{d|1} \\mu(d)\\phi(1/d) = \\mu(1)\\phi(1) = 1$. This corresponds to the single character modulo $1$, which is primitive.\n\nThird, we establish bounds for $\\phi^{\\ast}(q)$ and estimate the sum $\\sum_{q \\leq Q} \\phi^{\\ast}(q)$.\nFrom the derived expression $\\phi^{\\ast}(p^k) = \\phi(p^k) - \\phi(p^{k-1}) \\geq 0$ (since $\\phi(p^k) = p\\phi(p^{k-1}) \\geq \\phi(p^{k-1})$ for $p \\geq 2, k \\geq 1$, and for $p=2, k=1$, $\\phi^*(2)=0$), and the multiplicativity of $\\phi^{\\ast}$, it follows that $\\phi^{\\ast}(q) \\geq 0$ for all $q$.\nAlso, $\\phi^{\\ast}(p^k)  \\phi(p^k)$. By multiplicativity, it follows that $\\phi^{\\ast}(q) \\leq \\phi(q)$ for all $q \\geq 1$. As $\\phi(q)  q$ for $q  1$, we have the simple bound $\\phi^{\\ast}(q)  q$.\nTo estimate the sum, we use this bound:\n$$\n\\sum_{q \\leq Q} \\phi^{\\ast}(q) \\leq \\sum_{q \\leq Q} \\phi(q)\n$$\nA classic result in analytic number theory states that $\\sum_{q \\leq Q} \\phi(q) \\sim \\frac{3}{\\pi^2}Q^2$ as $Q \\to \\infty$. Therefore, we have the asymptotic bound:\n$$\n\\sum_{q \\leq Q} \\phi^{\\ast}(q) \\ll Q^2\n$$\nThe notation $f(x) \\ll g(x)$ means there exists a constant $C$ such that $|f(x)| \\leq C g(x)$ for all large enough $x$.\nThis bound is relevant to the Bombieri-Vinogradov theorem because this theorem provides an estimate on the error term in the prime number theorem for arithmetic progressions, averaged over moduli $q$. A key tool in its proof is the large sieve inequality, which bounds character sums. A typical form of the large sieve states that for any sequence of complex numbers $\\{a_n\\}$:\n$$\n\\sum_{q \\leq Q} \\sideset{}{^*}\\sum_{\\chi \\pmod q} \\left| \\sum_{n=M+1}^{M+N} a_n \\chi(n) \\right|^2 \\ll (N + Q^2) \\sum_{n=M+1}^{M+N} |a_n|^2\n$$\nwhere $\\sideset{}{^*}\\sum$ denotes a sum over primitive characters. The total number of terms on the left-hand side is $\\sum_{q \\leq Q} \\phi^{\\ast}(q)$, the total number of primitive characters with conductor at most $Q$. Our estimate shows that this number is of the order $Q^2$, which explains the presence of the $Q^2$ term in the large sieve inequality. This term is crucial for the strength of the Bombieri-Vinogradov theorem.\n\nFinally, we compute the Dirichlet series $F(s) = \\sum_{q=1}^{\\infty} \\frac{\\phi^{\\ast}(q)}{q^{s}}$.\nWe established that $\\phi^{\\ast}$ is the Dirichlet convolution of $\\mu$ and $\\phi$. The Dirichlet series of a convolution of two arithmetic functions is the product of their respective Dirichlet series.\n$$\nF(s) = D(\\phi^{\\ast}, s) = D(\\mu * \\phi, s) = D(\\mu,s) D(\\phi,s)\n$$\nwhere $D(f, s) = \\sum_{n=1}^\\infty f(n)/n^s$.\nThe Dirichlet series for the Möbius function is the reciprocal of the Riemann zeta function, valid for $\\Re(s)  1$:\n$$\nD(\\mu, s) = \\sum_{q=1}^{\\infty} \\frac{\\mu(q)}{q^s} = \\frac{1}{\\zeta(s)}\n$$\nTo find the Dirichlet series for $\\phi$, we use the identity $\\phi(q) = \\sum_{d|q} \\mu(d) \\frac{q}{d}$. This is the convolution $\\phi = \\mu * \\text{Id}$, where $\\text{Id}(n)=n$.\n$$\nD(\\phi, s) = D(\\mu * \\text{Id}, s) = D(\\mu, s) D(\\text{Id}, s)\n$$\nThe Dirichlet series for the identity function $\\text{Id}(n)=n$ is:\n$$\nD(\\text{Id}, s) = \\sum_{q=1}^{\\infty} \\frac{q}{q^s} = \\sum_{q=1}^{\\infty} \\frac{1}{q^{s-1}} = \\zeta(s-1)\n$$\nThis series converges for $\\Re(s-1)1$, i.e., $\\Re(s)2$.\nCombining these, we find the Dirichlet series for $\\phi$:\n$$\nD(\\phi, s) = \\frac{1}{\\zeta(s)} \\zeta(s-1) = \\frac{\\zeta(s-1)}{\\zeta(s)}\n$$\nNow we can compute $F(s)$ for $\\Re(s)  2$:\n$$\nF(s) = D(\\mu, s) D(\\phi, s) = \\frac{1}{\\zeta(s)} \\cdot \\frac{\\zeta(s-1)}{\\zeta(s)} = \\frac{\\zeta(s-1)}{\\zeta(s)^2}\n$$\nThis gives the closed-form expression for the Dirichlet series $F(s)$ in terms of the Riemann zeta function.", "answer": "$$\\boxed{\\frac{\\zeta(s-1)}{\\zeta(s)^{2}}}$$", "id": "3025098"}, {"introduction": "A key strategy in modern analytic number theory is to use combinatorial decompositions, such as Vaughan's identity, to handle sums involving the von Mangoldt function $\\Lambda(n)$. This process typically splits the sum into \"Type I\" and \"Type II\" components, whose sizes depend on a splitting parameter $U$. This practice [@problem_id:3025077] hones in on the central optimization challenge: by minimizing the total error bound, you will learn how to balance these competing terms, a crucial skill for executing proofs of sieve-theoretic results.", "problem": "Let $x$ be a large real parameter and let $Q$ satisfy $Q \\leq x^{1/2} (\\ln x)^{-B_{0}}$ for some fixed $B_{0}  0$. In a proof of the Bombieri-Vinogradov theorem, one applies Vaughan’s identity with a splitting parameter $U$ and the Large Sieve inequality to obtain an upper bound for the averaged discrepancy of primes in arithmetic progressions of the form\n$$\n\\sum_{q \\leq Q} \\max_{(a,q)=1} \\left| \\psi(x; q, a) - \\frac{x}{\\phi(q)} \\right| \\ll \\mathcal{E}(U),\n$$\nwhere, up to powers of $\\ln x$ that you may treat as harmless, the bound decomposes into a Type I contribution and a Type II contribution given by\n$$\n\\mathcal{E}(U) \\asymp A \\, x \\, Q \\, U^{-1} \\;+\\; B \\, x^{1/2} \\, Q \\, U^{1/2},\n$$\nfor some fixed positive constants $A$ and $B$ depending only on the implicit constants in the application of Vaughan’s identity and the Large Sieve inequality. Assume $U$ is a real parameter constrained by $1 \\leq U \\leq x$, and you may ignore all polylogarithmic factors in $x$ and $Q$ when optimizing.\n\nStarting from the standard forms of Vaughan’s identity and the Large Sieve inequality as foundational tools, and without invoking any additional pre-packaged optimization shortcuts, determine the exact analytic expression for the choice of $U$ that asymptotically minimizes the main size of $\\mathcal{E}(U)$ when the polylogarithmic factors are suppressed. Your final answer should be a single closed-form expression for the optimal $U$ in terms of $x$, $A$, and $B$. Do not include any inequalities in your final answer.", "solution": "The goal is to find the value of the parameter $U$ that minimizes the error term $\\mathcal{E}(U)$. As instructed, we ignore any polylogarithmic factors and treat the asymptotic relation as an equality for the purpose of optimization. Let the function to be minimized be $f(U)$, defined for $U \\in [1, x]$:\n$$\nf(U) = A x Q U^{-1} + B x^{1/2} Q U^{1/2}\n$$\nHere, $A$, $B$, $x$, and $Q$ are treated as positive constants with respect to the optimization variable $U$.\n\nTo find the minimum, we employ differential calculus. We first compute the derivative of $f(U)$ with respect to $U$:\n$$\n\\frac{df}{dU} = \\frac{d}{dU} \\left( A x Q U^{-1} + B x^{1/2} Q U^{1/2} \\right) = - A x Q U^{-2} + \\frac{1}{2} B x^{1/2} Q U^{-1/2}\n$$\nTo find the critical points, we set the derivative equal to zero:\n$$\n- A x Q U^{-2} + \\frac{1}{2} B x^{1/2} Q U^{-1/2} = 0\n$$\nWe can rearrange the equation to solve for $U$. Since $x, Q, A, B$ are all positive, we can simplify:\n$$\nA x U^{-2} = \\frac{1}{2} B x^{1/2} U^{-1/2}\n$$\nTo solve for $U$, we gather the terms involving $U$ on one side and the other terms on the other side:\n$$\n\\frac{U^2}{U^{1/2}} = \\frac{A x}{\\frac{1}{2} B x^{1/2}}\n$$\n$$\nU^{3/2} = \\frac{2A}{B} x^{1/2}\n$$\nFinally, we raise both sides to the power of $\\frac{2}{3}$ to find the optimal $U$:\n$$\nU = \\left( \\frac{2A}{B} x^{1/2} \\right)^{2/3} = \\left( \\frac{2A}{B} \\right)^{2/3} x^{(1/2) \\cdot (2/3)}\n$$\n$$\nU = \\left( \\frac{2A}{B} \\right)^{2/3} x^{1/3}\n$$\nThis critical point corresponds to a minimum, as can be verified by the second derivative test. For large $x$, this value of $U$ falls within the allowed range $[1, x]$. This choice of $U$ optimally balances the contributions from the Type I and Type II sums to minimize the overall error bound.", "answer": "$$\\boxed{\\left( \\frac{2A}{B} \\right)^{2/3} x^{1/3}}$$", "id": "3025077"}, {"introduction": "The Bombieri-Vinogradov theorem provides a profound theoretical guarantee about the distribution of primes in arithmetic progressions on average. This final exercise bridges the gap between abstract theory and concrete observation by asking you to implement a computational test of the theorem's power [@problem_id:3025116]. By numerically calculating the average error term for various scales, you will develop a tangible intuition for what \"equidistribution on average\" means and how the theorem's bounds manifest in practice.", "problem": "Let $x$ be a large real parameter and let $q$ be a positive integer modulus. For each reduced residue class $a$ modulo $q$ with $\\gcd(a,q)=1$, define the progression-restricted Chebyshev function by\n$$\n\\theta(x;q,a) \\;=\\; \\sum_{\\substack{p \\le x \\\\ p \\equiv a \\,(\\bmod q)}} \\log p,\n$$\nand recall Euler’s totient function $\\phi(q)$. Consider the aggregate deviation\n$$\nS_{\\theta}(x,Q) \\;=\\; \\sum_{1 \\le q \\le Q} \\; \\max_{\\substack{0 \\le a  q \\\\ \\gcd(a,q)=1}} \\left| \\theta(x;q,a) \\;-\\; \\frac{x}{\\phi(q)} \\right|.\n$$\nThe Bombieri–Vinogradov theorem (BV) states that, on average over moduli $q$ up to a scale tied to $x^{1/2}$, the prime distribution in arithmetic progressions behaves as if primes were equidistributed among the reduced residue classes. Without appealing to any unproven hypotheses, a computational test of this equidistribution can be designed by examining how $S_{\\theta}(x,Q)$ scales with $x$ and $\\log x$ as $Q$ varies with $x$.\n\nYour task is to implement a program that, for given triples $(x,\\alpha,A)$, computes the following normalized diagnostic based only on the above definitions:\n$$\nM_A(x,Q) \\;=\\; \\frac{(\\log x)^A}{x} \\, S_{\\theta}(x,Q),\n$$\nwhere $Q$ is determined from $(x,\\alpha)$ by\n$$\nQ \\;=\\; \\left\\lfloor \\frac{x^{1/2}}{(\\log x)^{\\alpha}} \\right\\rfloor,\n$$\nwith the convention that $Q$ is set to $1$ if the right-hand side is less than $1$. All logarithms are the natural logarithm.\n\nThis diagnostic $M_A(x,Q)$ scales the aggregate deviation $S_{\\theta}(x,Q)$ by $x$ and $(\\log x)^A$ to reflect average-error normalization suggested by the qualitative content of the Bombieri–Vinogradov theorem (BV), without using any explicit inequality from the theorem in the computation. Your program must compute $M_A(x,Q)$ exactly as defined, using only the definitions of $\\theta(x;q,a)$ and $\\phi(q)$, for each test case.\n\nDesign your implementation from first principles:\n- Use only the definitions of $\\theta(x;q,a)$, $\\phi(q)$, and basic prime generation to compute the sums and maxima exactly as defined.\n- Ensure that the computation over all $q \\le Q$ is efficient enough to handle $Q$ near $x^{1/2}$.\n- Use the natural logarithm for all occurrences of $\\log$.\n\nTest Suite:\nCompute $M_A(x,Q)$ for the following four parameter triples $(x,\\alpha,A)$:\n1. $(x,\\alpha,A) = (10^6, 1.0, 1.0)$.\n2. $(x,\\alpha,A) = (3 \\cdot 10^5, 0.0, 1.0)$.\n3. $(x,\\alpha,A) = (5 \\cdot 10^4, 0.0, 2.0)$.\n4. $(x,\\alpha,A) = (2 \\cdot 10^3, 3.0, 1.0)$.\n\nInput and Output:\n- There is no input. Your program must hard-code the above test suite.\n- Your program must produce a single line of output containing the results for the four test cases as a comma-separated list of floating-point values, in the order listed, enclosed in square brackets. For example, the format must be exactly like\n$[m_1,m_2,m_3,m_4]$\nwhere each $m_i$ is the computed value of $M_A(x,Q)$ for the corresponding test case. Express each $m_i$ as a decimal with exactly six digits after the decimal point.\n\nNotes:\n- The implementation must be universal and purely mathematical, independent of any physical units.\n- Ensure numerical stability and avoid redundant recomputation by reusing prime data across test cases where applicable.\n- Your design should include careful handling of the boundary case $Q=1$.", "solution": "The computation of $M_A(x,Q)$ for each test case is performed by a step-by-step algorithm that directly implements the given mathematical definitions, optimized for feasibility.\n\n1.  **Pre-computation Strategy**: To ensure computational efficiency, shared data are pre-computed.\n    - **Primes and Logarithms**: The maximum value of $x$ in the test suite is $10^6$. All prime numbers $p$ up to $10^6$ and their natural logarithms $\\log p$ are generated and stored once, using a Sieve of Eratosthenes.\n    - **Euler's Totient Function $\\phi(q)$**: The maximum value of $Q$ across all test cases is determined. A sieve-based algorithm is used to efficiently pre-compute $\\phi(q)$ for all integers $q$ up to this maximum $Q$.\n\n2.  **Main Computation Loop**: The program iterates through each of the four test cases $(x, \\alpha, A)$. For each case:\n    - The scale parameter $Q$ is determined using the formula $Q = \\lfloor x^{1/2} (\\log x)^{-\\alpha} \\rfloor$, with the floor set to $1$ if the value is less than $1$.\n    - The sums $\\theta(x;q,a)$ are computed efficiently. The algorithm iterates once through the pre-computed list of primes $p \\le x$. For each prime, it calculates $a = p \\pmod q$ for all $q \\in [1, Q]$ and adds $\\log p$ to the corresponding accumulator for $\\theta(x;q,a)$.\n    - The aggregate deviation $S_{\\theta}(x,Q)$ is calculated. This is done by summing, for each modulus $q$ from $1$ to $Q$, the maximum value of $|\\theta(x;q,a) - x/\\phi(q)|$ over all reduced residue classes $a \\pmod q$.\n    - The final diagnostic $M_A(x,Q)$ is computed as $S_{\\theta}(x,Q) \\cdot (\\log x)^A \\cdot x^{-1}$.\n\n3.  **Output Formatting**: The results for all four test cases are collected and formatted into a single string as specified: a comma-separated list of floating-point numbers with six digits of precision, enclosed in square brackets. This procedure guarantees a solution that is both correct and computationally feasible.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef precompute_primes_and_logs(limit):\n    \"\"\"\n    Generates primes up to a limit using the Sieve of Eratosthenes\n    and computes their natural logarithms.\n    \"\"\"\n    is_prime = np.ones(limit + 1, dtype=bool)\n    is_prime[0:2] = False\n    for i in range(2, int(np.sqrt(limit)) + 1):\n        if is_prime[i]:\n            is_prime[i*i::i] = False\n    primes = np.where(is_prime)[0]\n    log_primes_map = {p: np.log(p) for p in primes}\n    return primes, log_primes_map\n\ndef precompute_phi(limit):\n    \"\"\"\n    Computes Euler's totient function phi(n) for all n = limit\n    using a sieve-based method.\n    \"\"\"\n    if limit  0:\n        return np.array([], dtype=int)\n    phi = np.arange(limit + 1, dtype=int)\n    if limit = 1:\n        phi[1] = 1\n    for i in range(2, limit + 1):\n        if phi[i] == i:  # i is prime\n            for j in range(i, limit + 1, i):\n                phi[j] -= phi[j] // i\n    return phi\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10**6, 1.0, 1.0),\n        (3 * 10**5, 0.0, 1.0),\n        (5 * 10**4, 0.0, 2.0),\n        (2 * 10**3, 3.0, 1.0),\n    ]\n\n    # Pre-computation based on the maximum values in test cases.\n    max_x = int(max(tc[0] for tc in test_cases))\n    \n    # Pre-compute primes and their logs up to max_x.\n    primes, log_primes_map = precompute_primes_and_logs(max_x)\n    \n    # Determine the maximum Q across all test cases to size the phi-sieve.\n    max_q_candidate = 0\n    for x_val, alpha_val, _ in test_cases:\n        log_x_val = np.log(x_val)\n        # alpha_val  0 checks prevent division by zero for x=1, though not in these cases.\n        q_expr = x_val**0.5 / (log_x_val**alpha_val) if log_x_val  0 or alpha_val = 0 else 0\n        max_q_candidate = max(max_q_candidate, int(q_expr))\n    \n    # Q must be at least 1, so phi table must accommodate at least phi(1).\n    max_q = max(1, max_q_candidate)\n    phi_values = precompute_phi(max_q)\n\n    results = []\n    for x, alpha, A in test_cases:\n        log_x = np.log(x)\n\n        # 1. Calculate Q for the current test case.\n        q_pre = x**0.5 / (log_x**alpha) if log_x  0 or alpha = 0 else 0\n        Q = int(q_pre) if q_pre = 1 else 1\n\n        # 2. Compute theta(x; q, a) for p = x, q = Q.\n        theta_sums = [{} for _ in range(Q + 1)]\n\n        # Efficiently select primes = x using binary search on the sorted prime array.\n        end_idx = np.searchsorted(primes, x, side='right')\n        current_primes = primes[:end_idx]\n\n        for p in current_primes:\n            log_p = log_primes_map[p]\n            for q in range(1, Q + 1):\n                a = p % q\n                theta_sums[q][a] = theta_sums[q].get(a, 0.0) + log_p\n\n        # 3. Compute S_theta(x, Q).\n        s_theta = 0.0\n        for q in range(1, Q + 1):\n            phi_q = phi_values[q]\n            expected_val = x / phi_q\n            max_dev = 0.0\n            \n            # Iterate through all reduced residue classes a mod q.\n            for a in range(q):\n                if math.gcd(a, q) == 1:\n                    theta_val = theta_sums[q].get(a, 0.0)\n                    dev = abs(theta_val - expected_val)\n                    if dev  max_dev:\n                        max_dev = dev\n            \n            s_theta += max_dev\n\n        # 4. Compute M_A(x, Q).\n        m_a = (log_x**A / x) * s_theta\n        results.append(m_a)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "3025116"}]}