{"hands_on_practices": [{"introduction": "The undecidability of the halting problem serves as the cornerstone for proving the undecidability of countless other problems via reduction. However, the logical direction of this reduction is critical and often misunderstood. This exercise presents a hypothetical scenario [@problem_id:1457073] to diagnose a common flaw in reasoning, reinforcing the correct methodology for establishing undecidability through mapping reductions.", "problem": "A student in a theory of computation course, Alice, is tasked with proving that a particular language, $\\text{TOTAL\\_TM}$, is undecidable. The language is defined as $\\text{TOTAL\\_TM}$ = $\\{ \\langle M \\rangle \\mid M \\text{ is a Turing Machine (TM) that halts on all possible input strings} \\}$.\n\nAlice knows that the standard halting problem, $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input } w \\}$, is a famous undecidable language.\n\nTo prove her claim, she correctly constructs a computable function $f$ that transforms any instance $\\langle M \\rangle$ of $\\text{TOTAL\\_TM}$ into an instance $\\langle M', w' \\rangle = f(\\langle M \\rangle)$ of $A_{TM}$, such that $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ if and only if $\\langle M', w' \\rangle \\in A_{TM}$. This establishes a mapping reduction from $\\text{TOTAL\\_TM}$ to $A_{TM}$ (denoted as $\\text{TOTAL\\_TM} \\le_m A_{TM}$).\n\nAlice then concludes her proof: \"Since I have shown that $\\text{TOTAL\\_TM}$ is reducible to $A_{TM}$, and we know that $A_{TM}$ is undecidable, it logically follows that $\\text{TOTAL\\_TM}$ must also be undecidable.\"\n\nWhich of the following statements best explains the fundamental flaw in Alice's reasoning?\n\nA. To prove a language $P$ is undecidable via reduction, one must reduce a known undecidable language $U$ *to* $P$ (i.e., show $U \\le_m P$), not the other way around. Alice's reduction direction is incorrect for her stated purpose.\n\nB. The language $\\text{TOTAL\\_TM}$ is not Turing-recognizable, whereas $A_{TM}$ is. A mapping reduction is only valid between languages that are in the same class of recognizability (i.e., both are recognizable or both are not).\n\nC. Alice's argument is circular. In order to construct the computable function $f$, she must have implicitly assumed a method for deciding $\\text{TOTAL\\_TM}$, which contradicts the claim she is trying to prove.\n\nD. The reduction is invalid because $\\text{TOTAL\\_TM}$ is known to be a \"harder\" problem than $A_{TM}$. It is a foundational theorem of computability theory that one cannot reduce a computationally harder problem to an easier one.\n\nE. Any reduction from a language that takes a single encoding $\\langle M \\rangle$ as input to a language that takes a pair $\\langle M, w \\rangle$ as input is inherently flawed because it requires manufacturing information (the string $w$) that was not present in the original input.", "solution": "We are given the language $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ halts on all inputs} \\}$ and the halting problem $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ halts on } w \\}$, where $A_{TM}$ is known to be undecidable. Alice shows a mapping reduction $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ and concludes that $\\text{TOTAL\\_TM}$ is undecidable.\n\nRecall the definition: For languages $A$ and $B$, $A \\le_{m} B$ means there exists a total computable function $f$ such that for all strings $x$, \n$$x \\in A \\iff f(x) \\in B.$$\n\nKey property of mapping reductions:\n- If $A \\le_{m} B$ and $B$ is decidable, then $A$ is decidable. Proof: Given a decider for $B$, decide $A$ on input $x$ by computing $f(x)$ and running the decider for $B$; accept iff it accepts. \n- The contrapositive of this statement is: If $A$ is undecidable and $A \\le_{m} B$, then $B$ is undecidable.\n\nTherefore, to prove that a target language $P$ is undecidable by reduction, one must reduce a known undecidable language $U$ to $P$, that is, show $U \\le_{m} P$. Then, if $P$ were decidable, $U$ would be decidable, contradicting the known undecidability of $U$.\n\nAlice instead showed $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$. From the fundamental property above, this implication only yields:\n$$\\text{If } A_{TM} \\text{ were decidable, then } \\text{TOTAL\\_TM} \\text{ would be decidable.}$$\nBut since $A_{TM}$ is undecidable, this conditional tells us nothing about the decidability of $\\text{TOTAL\\_TM}$. Hence Alice’s conclusion does not follow.\n\nA concrete illustration that such a reduction direction does not prove undecidability: Let $L$ be any decidable language. Let $D$ be its decider. Define a computable $f$ that, on input $x$, runs $D(x)$ and outputs a fixed pair $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$ if $D$ accepts, and a fixed pair $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$ if $D$ rejects. Then $x \\in L \\iff f(x) \\in A_{TM}$, so $L \\le_{m} A_{TM}$, yet $L$ is decidable. Thus, showing $P \\le_{m} A_{TM}$ does not establish that $P$ is undecidable.\n\nTherefore, the fundamental flaw is the direction of the reduction. This corresponds to option A. The other options are incorrect because: mapping reductions do not require equal recognizability status (B is false), constructing $f$ does not assume a decider for $\\text{TOTAL\\_TM}$ (C is false), the “harder to easier” phrasing is not the formal criterion at play (D is misleading), and producing pairs from singles is standard via computable padding or hardcoding (E is false).", "answer": "$$\\boxed{A}$$", "id": "1457073"}, {"introduction": "To rigorously analyze computational problems, we must be precise about the definitions of a Turing machine's behavior. This problem [@problem_id:2986077] explores the crucial distinction between a machine halting and a machine accepting an input. By constructing simple machines and transformations, you will solidify your understanding of these foundational concepts and see how they form the basis for reducibility proofs.", "problem": "Consider the standard model of a deterministic Turing machine (DTM), defined as a tuple $M = (Q,\\Sigma,\\Gamma,\\delta,q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}})$, where $Q$ is a finite set of states, $\\Sigma$ is the input alphabet, $\\Gamma$ is the tape alphabet with $\\Sigma \\subseteq \\Gamma$, $\\delta$ is the (partial) transition function, $q_0 \\in Q$ is the start state, and $q_{\\mathrm{acc}},q_{\\mathrm{rej}} \\in Q$ are halting states designated as the accept and reject states, respectively. By definition, on input $x \\in \\Sigma^{\\star}$, machine $M$ accepts $x$ if the computation halts in state $q_{\\mathrm{acc}}$, rejects $x$ if the computation halts in state $q_{\\mathrm{rej}}$, and otherwise does not halt. The language recognized by $M$ is $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts in } q_{\\mathrm{acc}} \\text{ on input } x\\}$.\n\nTo make concrete the distinction between halting and accepting, define a specific machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ over any fixed nonempty alphabet $\\Sigma$ as follows: $Q = \\{q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}}\\}$, and for every $a \\in \\Gamma$, $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$, with $q_{\\mathrm{rej}}$ halting. Thus, on any input $x \\in \\Sigma^{\\star}$, $M_{\\mathrm{halt\\mbox{-}nonacc}}$ performs one move from $q_0$ and then halts in $q_{\\mathrm{rej}}$, never entering $q_{\\mathrm{acc}}$.\n\nSeparately, given an arbitrary DTM $M$, define a transformed machine $H(M)$ that models acceptance as halting by stipulating that on input $x$, $H(M)$ simulates $M(x)$ step by step; if $M$ ever enters $q_{\\mathrm{acc}}$, then $H(M)$ enters $q_{\\mathrm{acc}}$ and halts; if $M$ ever enters $q_{\\mathrm{rej}}$ or never halts, then $H(M)$ does not halt (for example, by replacing transitions into $q_{\\mathrm{rej}}$ with transitions into a non-halting self-loop state). Hence, $H(M)$ halts on $x$ if and only if $M$ accepts $x$.\n\nUsing only the core definitions above, select all correct statements below.\n\nA. The machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ halts on every input $x \\in \\Sigma^{\\star}$ yet recognizes the empty language $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$, because acceptance is defined as halting specifically in $q_{\\mathrm{acc}}$.\n\nB. If there existed a decider for the halting problem $\\mathrm{HALT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ halts on input } x\\}$, then for any $M$ one could decide the acceptance problem $\\mathrm{ACCEPT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ accepts } x\\}$ by constructing $H(M)$ and asking whether $H(M)$ halts on $x$. Therefore, the undecidability of $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ implies the undecidability of $\\mathrm{HALT}_{\\mathrm{DTM}}$.\n\nC. For every DTM $M$ and input $x$, if $M$ halts on $x$, then $M$ accepts $x$.\n\nD. For every DTM $M$, the halting set $\\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts on } x\\}$ is identical to the language $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ accepts } x\\}$.\n\nE. In the standard model, acceptance is modeled as halting in a designated accept state $q_{\\mathrm{acc}}$, and halting in the designated reject state $q_{\\mathrm{rej}}$ does not constitute acceptance.", "solution": "The problem statement is subjected to validation prior to any attempt at a solution.\n\n### Step 1: Extract Givens\n-   A deterministic Turing machine (DTM) is a tuple $M = (Q,\\Sigma,\\Gamma,\\delta,q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}})$, where $Q$ is a finite set of states, $\\Sigma$ is the input alphabet, $\\Gamma$ is the tape alphabet ($\\Sigma \\subseteq \\Gamma$), $\\delta$ is a partial transition function, $q_0 \\in Q$ is the start state, and $q_{\\mathrm{acc}},q_{\\mathrm{rej}} \\in Q$ are the accept and reject halting states.\n-   On input $x \\in \\Sigma^{\\star}$, $M$ accepts $x$ by halting in state $q_{\\mathrm{acc}}$.\n-   On input $x \\in \\Sigma^{\\star}$, $M$ rejects $x$ by halting in state $q_{\\mathrm{rej}}$.\n-   If neither of the above occurs, $M$ does not halt on $x$.\n-   The language recognized by $M$ is $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts in } q_{\\mathrm{acc}} \\text{ on input } x\\}$.\n-   A specific machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ has $Q = \\{q_0,q_{\\mathrm{acc}},q_{\\mathrm{rej}}\\}$ and for every $a \\in \\Gamma$, its transition is $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$. It halts in $q_{\\mathrm{rej}}$ after one move on any input.\n-   A transformed machine $H(M)$ simulates a given DTM $M$ on input $x$. $H(M)$ halts if and only if $M$ enters $q_{\\mathrm{acc}}$. If $M$ enters $q_{\\mathrm{rej}}$ or loops forever, $H(M)$ loops forever.\n\n### Step 2: Validate Using Extracted Givens\nThe problem statement is found to be valid.\n-   **Scientifically Grounded**: The definitions provided for a DTM, language recognition, acceptance, and rejection are standard and correct within the theory of computation.\n-   **Well-Posed**: The problem is clearly formulated. The questions posed in the options are unambiguous and can be evaluated by logical deduction from the provided definitions.\n-   **Objective**: The language is precise and free of subjective claims. The constructions of $M_{\\mathrm{halt\\mbox{-}nonacc}}$ and $H(M)$ are formal and well-defined.\n-   The problem does not suffer from any of the listed flaws (e.g., incompleteness, contradiction, infeasibility). It is a standard exercise in computability theory.\n\n### Step 3: Verdict and Action\nThe problem is valid. A full solution will be derived.\n\n### Analysis of a DTM's Outcomes\nBased on the provided definitions, for any DTM $M$ and input $x$, there are exactly three possible outcomes for the computation $M(x)$:\n1.  **Accept**: The machine $M$ enters state $q_{\\mathrm{acc}}$ and halts. In this case, $x \\in L(M)$.\n2.  **Reject**: The machine $M$ enters state $q_{\\mathrm{rej}}$ and halts. In this case, $x \\notin L(M)$.\n3.  **Loop**: The machine $M$ never enters a halting state ($q_{\\mathrm{acc}}$ or $q_{\\mathrm{rej}}$). In this case, $x \\notin L(M)$.\n\nThe term \"halting\" refers to outcomes $1$ and $2$. The term \"accepting\" refers exclusively to outcome $1$. This distinction is critical.\n\n### Option-by-Option Evaluation\n\n**A. The machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ halts on every input $x \\in \\Sigma^{\\star}$ yet recognizes the empty language $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$, because acceptance is defined as halting specifically in $q_{\\mathrm{acc}}$.**\n\nThe machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ is defined by the transition $\\delta(q_0,a) = (q_{\\mathrm{rej}},a,R)$ for any symbol $a$ it reads. On any input $x \\in \\Sigma^{\\star}$ (including the empty string), the machine starts in state $q_0$, reads the symbol under the head, and in a single step, transitions to state $q_{\\mathrm{rej}}$. By definition, $q_{\\mathrm{rej}}$ is a halting state. Thus, $M_{\\mathrm{halt\\mbox{-}nonacc}}$ halts on every possible input.\n\nThe language recognized by a DTM, $L(M)$, is the set of inputs on which it halts in the *accept* state, $q_{\\mathrm{acc}}$. The machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ is constructed such that its computation path never enters $q_{\\mathrm{acc}}$; it always halts in $q_{\\mathrm{rej}}$. Therefore, there is no input $x$ for which $M_{\\mathrm{halt\\mbox{-}nonacc}}$ accepts. The set of accepted strings is empty, so $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$. The reasoning provided in the statement is precisely why this is the case. This option correctly illustrates the distinction between halting and accepting.\n\n*Verdict*: **Correct**.\n\n**B. If there existed a decider for the halting problem $\\mathrm{HALT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ halts on input } x\\}$, then for any $M$ one could decide the acceptance problem $\\mathrm{ACCEPT}_{\\mathrm{DTM}} = \\{\\langle M,x\\rangle \\mid M \\text{ accepts } x\\}$ by constructing $H(M)$ and asking whether $H(M)$ halts on $x$. Therefore, the undecidability of $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ implies the undecidability of $\\mathrm{HALT}_{\\mathrm{DTM}}$.**\n\nThis statement describes a many-one reduction from the acceptance problem, $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$, to the halting problem, $\\mathrm{HALT}_{\\mathrm{DTM}}$. Let us formalize the argument.\nSuppose there exists a decider $D_{HALT}$ such that for any DTM $M$ and input $x$, $D_{HALT}(\\langle M,x \\rangle)$ returns `true` if $M$ halts on $x$, and `false` otherwise. We can construct a decider $D_{ACCEPT}$ for $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ as follows:\nOn input $\\langle M,x \\rangle$:\n1.  Construct the DTM $H(M)$ as described in the problem statement. This is a computable step.\n2.  Run the hypothetical decider $D_{HALT}$ on the input $\\langle H(M),x \\rangle$.\n3.  Return the result of $D_{HALT}(\\langle H(M),x \\rangle)$.\n\nBy the definition of $H(M)$, \"$H(M)$ halts on $x$\" is equivalent to \"$M$ accepts $x$\". Therefore, $D_{HALT}(\\langle H(M),x \\rangle)$ returns `true` if and only if $M$ accepts $x$. This means our constructed machine $D_{ACCEPT}$ correctly decides the language $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$. This establishes that $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ is reducible to $\\mathrm{HALT}_{\\mathrm{DTM}}$ ($\\mathrm{ACCEPT}_{\\mathrm{DTM}} \\le_m \\mathrm{HALT}_{\\mathrm{DTM}}$).\n\nFrom the theory of undecidability, if a problem $A$ is reducible to a problem $B$, and $A$ is undecidable, then $B$ must also be undecidable. It is a known fundamental result that $\\mathrm{ACCEPT}_{\\mathrm{DTM}}$ is undecidable. Therefore, the existence of this reduction correctly implies that $\\mathrm{HALT}_{\\mathrm{DTM}}$ must be undecidable. The logic presented in the option is entirely sound.\n\n*Verdict*: **Correct**.\n\n**C. For every DTM $M$ and input $x$, if $M$ halts on $x$, then $M$ accepts $x$.**\n\nThis statement claims that any halting computation is an accepting computation. This contradicts the fundamental definitions provided. A DTM can halt in one of two ways: by entering $q_{\\mathrm{acc}}$ (accepting) or by entering $q_{\\mathrm{rej}}$ (rejecting). A halting computation is not necessarily an accepting one. The machine $M_{\\mathrm{halt\\mbox{-}nonacc}}$ described in the problem is a direct counterexample. For any input $x$, $M_{\\mathrm{halt\\mbox{-}nonacc}}$ halts on $x$ (by entering $q_{\\mathrm{rej}}$), but it does not accept $x$.\n\n*Verdict*: **Incorrect**.\n\n**D. For every DTM $M$, the halting set $\\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts on } x\\}$ is identical to the language $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ accepts } x\\}$.**\n\nThis is a restatement of option C using set notation. Let $S_{halt}(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts on } x\\}$. The statement claims that for any $M$, $S_{halt}(M) = L(M)$.\nAs established, $L(M)$ contains only inputs that cause $M$ to halt in $q_{\\mathrm{acc}}$. In contrast, $S_{halt}(M)$ contains inputs that cause $M$ to halt in *either* $q_{\\mathrm{acc}}$ or $q_{\\mathrm{rej}}$.\nSo, $L(M) \\subseteq S_{halt}(M)$. The sets are identical only if no input causes $M$ to reject. This is not true for all DTMs.\nUsing our counterexample $M_{\\mathrm{halt\\mbox{-}nonacc}}$:\n-   $S_{halt}(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\Sigma^{\\star}$, because it halts on all inputs.\n-   $L(M_{\\mathrm{halt\\mbox{-}nonacc}}) = \\varnothing$, because it accepts no inputs.\nSince the problem specifies a nonempty alphabet $\\Sigma$, we have $\\Sigma^{\\star} \\neq \\varnothing$. Thus, the two sets are not identical for this machine, disproving the universal claim.\n\n*Verdict*: **Incorrect**.\n\n**E. In the standard model, acceptance is modeled as halting in a designated accept state $q_{\\mathrm{acc}}$, and halting in the designated reject state $q_{\\mathrm{rej}}$ does not constitute acceptance.**\n\nThis statement is a summary of the definitions provided in the problem's preamble.\n-   The preamble states: \"$M$ accepts $x$ if the computation halts in state $q_{\\mathrm{acc}}$\". This confirms the first part of the statement.\n-   It also defines the language as $L(M) = \\{x \\in \\Sigma^{\\star} \\mid M \\text{ halts in } q_{\\mathrm{acc}} \\text{ on input } x\\}$. This formally ties acceptance to halting specifically in $q_{\\mathrm{acc}}$.\n-   It further defines rejection as halting in state $q_{\\mathrm{rej}}$. Since acceptance and rejection are distinct outcomes (one leads to inclusion in $L(M)$, the other does not), halting in $q_{\\mathrm{rej}}$ cannot be acceptance. The statement is a direct and accurate recital of the foundational rules laid out for the problem.\n\n*Verdict*: **Correct**.", "answer": "$$\\boxed{ABE}$$", "id": "2986077"}, {"introduction": "The undecidability of the halting problem has profound implications that extend into the foundations of mathematics, particularly through its connection to formal logic. This exercise [@problem_id:2986081] guides you through the process of arithmetization, where statements about machine computations are translated into formulas within first-order arithmetic. By constructing these formulas, you will determine the precise complexity of the halting problem and its complement within the arithmetical hierarchy, linking Turing's work directly to Gödel's.", "problem": "Let $N$ denote the set of natural numbers and work in the language of first-order arithmetic with symbols for $0$, successor, addition, and multiplication. Fix any effective Gödel coding of deterministic Turing machines such that each machine and configuration is represented by a number in $N$. Assume the following foundational facts of computability theory and arithmetization, which you may use without proof:\n\n- There is a primitive recursive relation $R(e,x,t,y)$ that holds exactly when $y$ is the code of the complete computation history (for example, a finite tableau or sequence of configurations) of the machine coded by $e$ on input $x$ for exactly $t$ steps, and this history is correct with respect to the machine’s transition function.\n- There is a primitive recursive relation $H_{\\mathrm{fin}}(e,x,t,y)$ that holds exactly when $R(e,x,t,y)$ holds and the last configuration coded within $y$ is halting (i.e., the machine has entered a designated halting state by time $t$).\n- A formula whose matrix is a primitive recursive relation and whose quantifiers range over $N$ can be put into prenex normal form; its level in the arithmetical hierarchy is determined by the pattern of leading unbounded quantifiers: a $\\Sigma_n$-formula has a leading block of existential quantifiers followed by $n-1$ alternations, and a $\\Pi_n$-formula has a leading block of universal quantifiers followed by $n-1$ alternations, all with a decidable (primitive recursive) matrix.\n\nUsing only these bases:\n\n1. Construct a first-order formula of arithmetic $H(e,x)$ that expresses “the machine coded by $e$ halts on input $x$,” using $R$ and $H_{\\mathrm{fin}}$ as your decidable matrix. Place your formula into prenex normal form and explicitly state its leading quantifier block and matrix.\n\n2. Construct a first-order formula of arithmetic $NH(e,x)$ that expresses “the machine coded by $e$ does not halt on input $x$,” again using only quantification over $N$ and a decidable matrix built from $R$ and $H_{\\mathrm{fin}}$. Place your formula into prenex normal form and explicitly state its leading quantifier block and matrix.\n\n3. For each of $H(e,x)$ and $NH(e,x)$, determine the minimal arithmetical hierarchy level $L(\\cdot)$, defined as follows: if a formula is equivalent (over the standard model of arithmetic) to a $\\Sigma_n$-formula with no fewer than $n$ alternations, take $L$ to be $n$; if it is equivalent to a $\\Pi_n$-formula with no fewer than $n$ alternations, take $L$ to be $n$. Justify your classification by analyzing the quantifier structure and the decidability of the matrix.\n\n4. Compute the exact integer value of $L(H)+L(NH)$. Report your final answer as an exact integer. No rounding is required.", "solution": "The problem requires the construction and classification of first-order arithmetic formulas for the halting problem and its complement, based on provided primitive recursive relations.\n\n**Problem Validation**\n\nA validation of the problem statement is performed first.\n\n*   **Step 1: Extract Givens**\n    *   Domain of discourse: The set of natural numbers, $N$.\n    *   Language: First-order arithmetic with symbols for $0$, successor, addition, and multiplication.\n    *   Gödel Coding: An effective coding scheme maps Turing machines and their configurations to numbers in $N$.\n    *   Primitive Recursive Relation $R(e,x,t,y)$: Holds iff $y$ is the code for the correct computation history of machine $e$ on input $x$ for exactly $t$ steps.\n    *   Primitive Recursive Relation $H_{\\mathrm{fin}}(e,x,t,y)$: Holds iff $R(e,x,t,y)$ is true and the computation is in a halting state at step $t$.\n    *   Arithmetical Hierarchy Definitions: A formula is $\\Sigma_n$ if it has a leading block of existential quantifiers and $n-1$ quantifier alternations over a decidable matrix. A formula is $\\Pi_n$ if it has a leading block of universal quantifiers and $n-1$ quantifier alternations over a decidable matrix.\n    *   Level $L(\\cdot)$: The minimal $n \\in N, n \\ge 1$ such that a formula is equivalent to a $\\Sigma_n$ or $\\Pi_n$ formula.\n\n*   **Step 2: Validate Using Extracted Givens**\n    The problem is a standard exercise in computability theory and mathematical logic. It is scientifically grounded in the formalization of computation (Church-Turing thesis) and its relationship to formal arithmetic (as established by Gödel, Kleene, and others). All terms are precisely defined, and the premises are standard results in the field. The problem is well-posed, objective, and self-contained, with no apparent logical contradictions, ambiguities, or factual unsoundness.\n\n*   **Step 3: Verdict and Action**\n    The problem is deemed valid. A full solution is warranted.\n\n**Part 1: Construction of the Formula $H(e,x)$**\n\nThe assertion \"the machine coded by $e$ halts on input $x$\" is true if there exists a time $t \\in N$ and a corresponding computation history $y \\in N$ that represents a valid, halting computation. The predicate $H_{\\mathrm{fin}}(e,x,t,y)$ captures this for a specific time $t$ and history $y$. To express that a halt occurs at *some* time, we existentially quantify over $t$ and $y$.\n\nThe formula $H(e,x)$ is therefore:\n$$H(e,x) \\equiv \\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y)$$\nThis formula is in prenex normal form.\n*   **Leading Quantifier Block:** $\\exists t \\exists y$. This is a single block of existential quantifiers.\n*   **Matrix:** $H_{\\mathrm{fin}}(e,x,t,y)$. The problem states that this relation is primitive recursive. A primitive recursive relation is, by definition, decidable by a Turing machine. Thus, the matrix is decidable.\n\n**Part 2: Construction of the Formula $NH(e,x)$**\n\nThe assertion \"the machine coded by $e$ does not halt on input $x$\" is the logical negation of $H(e,x)$.\n$$NH(e,x) \\equiv \\neg H(e,x)$$\nWe substitute the expression for $H(e,x)$ and convert the resulting formula to prenex normal form by applying quantifier duality rules ($\\neg \\exists z P(z) \\equiv \\forall z \\neg P(z)$).\n$$NH(e,x) \\equiv \\neg (\\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\, \\neg (\\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\nThe formula $NH(e,x)$ in prenex normal form is:\n$$NH(e,x) \\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n*   **Leading Quantifier Block:** $\\forall t \\forall y$. This is a single block of universal quantifiers.\n*   **Matrix:** $\\neg H_{\\mathrm{fin}}(e,x,t,y)$. Since $H_{\\mathrm{fin}}$ is a decidable relation, its negation $\\neg H_{\\mathrm{fin}}$ is also decidable.\n\n**Part 3: Arithmetical Hierarchy Classification**\n\nWe determine the minimal level $L(\\cdot)$ for each formula.\n\n**Classification of $H(e,x)$:**\nThe formula $H(e,x)$ has a leading block of existential quantifiers and a decidable matrix. This structure corresponds to a $\\Sigma_1$-formula. The set of pairs $(e,x)$ satisfying $H(e,x)$ is the halting set, which is known to be undecidable. A set is decidable if and only if it is definable by a $\\Delta_1$ formula (equivalent to both a $\\Sigma_1$ and a $\\Pi_1$ formula), which in turn is equivalent to having a quantifier-free definition (a $\\Sigma_0$ or $\\Pi_0$ formula over a decidable language). Since the halting set is undecidable, it cannot be defined by a $\\Sigma_0$ formula. Therefore, its minimal classification is $\\Sigma_1$.\nThis means $L(H) = 1$.\n\n**Classification of $NH(e,x)$:**\nThe formula $NH(e,x)$ has a leading block of universal quantifiers and a decidable matrix. This structure corresponds to a $\\Pi_1$-formula. The set of pairs $(e,x)$ satisfying $NH(e,x)$ is the complement of the halting set.\n1.  This set is not decidable, because if it were, its complement (the halting set) would also be decidable, which is a known falsehood. Thus, it cannot be a $\\Sigma_0$ or $\\Pi_0$ set.\n2.  We must also show it is not a $\\Sigma_1$ set. A set is definable by a $\\Sigma_1$ formula if and only if it is recursively enumerable. The halting set (defined by $H(e,x)$) is a $\\Sigma_1$-set, so it is recursively enumerable. By Post's theorem, a set is decidable (recursive) if and only if both the set and its complement are recursively enumerable. If the complement of the halting set were also recursively enumerable (i.e., $\\Sigma_1$), then the halting set would be decidable. This is a contradiction.\nTherefore, the set defined by $NH(e,x)$ is not $\\Sigma_1$. Its simplest classification is $\\Pi_1$.\nThis means $L(NH) = 1$.\n\n**Part 4: Final Calculation**\n\nThe problem asks for the value of $L(H) + L(NH)$. Using the results from Part 3:\n$$L(H) = 1$$\n$$L(NH) = 1$$\nThe sum is:\n$$L(H) + L(NH) = 1 + 1 = 2$$", "answer": "$$\\boxed{2}$$", "id": "2986081"}]}