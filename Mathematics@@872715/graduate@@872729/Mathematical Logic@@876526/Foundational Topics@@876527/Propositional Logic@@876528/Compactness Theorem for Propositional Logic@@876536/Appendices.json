{"hands_on_practices": [{"introduction": "This first exercise provides a classic illustration of how the Compactness Theorem handles infinite sets of logical dependencies. By constructing a theory that represents an infinite descending chain of implications, you will use compactness to prove the existence of a satisfying model and then deduce its unique and surprisingly simple structure. This practice strengthens the fundamental skill of proving finite satisfiability as a pathway to establishing global satisfiability.", "problem": "Consider countably many propositional variables $\\{p_{n} : n \\in \\mathbb{N}\\}$ and the theory $T$ given by\n$$T \\;=\\; \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}.$$\nWork in classical propositional semantics where a valuation $v$ assigns each propositional variable a truth value in $\\{0,1\\}$, with $1$ denoting truth and $0$ denoting falsity, and extends to all formulas in the usual way: $v(\\neg \\varphi) = 1 - v(\\varphi)$, $v(\\varphi \\land \\psi) = \\min\\{v(\\varphi),v(\\psi)\\}$, $v(\\varphi \\lor \\psi) = \\max\\{v(\\varphi),v(\\psi)\\}$, and $v(\\varphi \\to \\psi) = \\max\\{1 - v(\\varphi), v(\\psi)\\}$.\n\nYour tasks are:\n- Build the theory $T$ above and prove that every finite subset of $T$ is satisfiable by explicitly constructing a valuation for an arbitrary finite subset.\n- Using the Compactness Theorem for Propositional Logic (CTPL), deduce that $T$ is satisfiable, and derive a specific global satisfying valuation $v$ that satisfies all formulas in $T$.\n- Prove that any satisfying valuation for $T$ must assign $v(p_{n}) = 0$ for all $n \\in \\mathbb{N}$.\n- Define the real number\n$$S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big),$$\nand evaluate $S$ exactly. No rounding is required.", "solution": "The problem statement is analyzed and found to be valid. It is a well-posed problem in mathematical logic, grounded in standard definitions of classical propositional semantics and the Compactness Theorem. All terms are defined, and the tasks are clear and logically sequential.\n\nThe problem will be solved by addressing each of the four tasks in order.\n\n**Task 1: Prove that every finite subset of $T$ is satisfiable.**\n\nLet $T = \\{\\, p_{n+1} \\to p_{n} : n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg p_{0} \\,\\}$. Let $S$ be an arbitrary finite subset of $T$. We need to construct a valuation $v_S$ that satisfies all formulas in $S$. We consider two cases based on the membership of $\\neg p_0$ in $S$.\n\nCase 1: $\\neg p_0 \\notin S$.\nIn this case, $S$ consists of a finite number of formulas of the form $p_{k+1} \\to p_k$. Let's define a valuation $v_1$ such that $v_1(p_n) = 1$ for all $n \\in \\mathbb{N}$.\nFor any formula $(p_{k+1} \\to p_k) \\in S$, the truth value under $v_1$ is:\n$$v_1(p_{k+1} \\to p_k) = \\max\\{1 - v_1(p_{k+1}), v_1(p_k)\\} = \\max\\{1-1, 1\\} = 1.$$\nThus, $v_1$ satisfies every formula in $S$. Therefore, $S$ is satisfiable.\n\nCase 2: $\\neg p_0 \\in S$.\nIn this case, $S$ contains the formula $\\neg p_0$ and a finite number of formulas of the form $p_{k+1} \\to p_k$.\nLet's define a valuation $v_0$ such that $v_0(p_n) = 0$ for all $n \\in \\mathbb{N}$.\nWe check if this valuation $v_0$ satisfies all formulas in $S$.\nFirst, consider the formula $\\neg p_0$:\n$$v_0(\\neg p_0) = 1 - v_0(p_0) = 1 - 0 = 1.$$\nSo, $\\neg p_0$ is satisfied by $v_0$.\nNext, consider any formula $(p_{k+1} \\to p_k) \\in S$:\n$$v_0(p_{k+1} \\to p_k) = \\max\\{1 - v_0(p_{k+1}), v_0(p_k)\\} = \\max\\{1-0, 0\\} = 1.$$\nSo, any implication in $S$ is also satisfied by $v_0$.\nThus, $v_0$ satisfies every formula in $S$. Therefore, $S$ is satisfiable.\n\nSince in both cases we found a satisfying valuation for any arbitrary finite subset $S$, every finite subset of $T$ is satisfiable.\n\n**Task 2: Using CTPL, deduce that $T$ is satisfiable, and derive a specific global satisfying valuation.**\n\nThe Compactness Theorem for Propositional Logic (CTPL) states that a set of propositional formulas is satisfiable if and only if every finite subset of it is satisfiable.\nFrom Task 1, we have established that every finite subset of $T$ is satisfiable. By the CTPL, we can deduce that the entire infinite set of formulas $T$ is satisfiable.\nThis means there exists a valuation $v$ such that $v(\\phi) = 1$ for all $\\phi \\in T$. Let's determine the properties of such a valuation $v$.\n\nFor $v$ to satisfy $T$, it must satisfy every formula in $T$.\n1.  From $\\neg p_0 \\in T$, we must have $v(\\neg p_0) = 1$. This implies $1 - v(p_0) = 1$, which means $v(p_0) = 0$.\n2.  For every $n \\in \\mathbb{N}$, the formula $(p_{n+1} \\to p_n) \\in T$ must be satisfied. So, $v(p_{n+1} \\to p_n) = 1$. This is equivalent to $\\max\\{1 - v(p_{n+1}), v(p_n)\\} = 1$. This condition is violated only if $1 - v(p_{n+1}) = 0$ and $v(p_n) = 0$, which means $v(p_{n+1}) = 1$ and $v(p_n) = 0$. Therefore, the condition $v(p_{n+1} \\to p_n) = 1$ is equivalent to stating that we cannot have $v(p_{n+1})=1$ and $v(p_n)=0$. Because the variables can only take values in $\\{0,1\\}$, this is equivalent to the inequality $v(p_{n+1}) \\le v(p_n)$.\n\nCombining these conditions, we have a chain of inequalities for the truth values:\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) $$\nSince we already established that $v(p_0) = 0$, the chain becomes:\n$$ \\ldots \\le v(p_{n+1}) \\le v(p_n) \\le \\ldots \\le v(p_1) \\le v(p_0) = 0 $$\nAs truth values are non-negative, for any $n \\in \\mathbb{N}$, we have $0 \\le v(p_n)$.\nCombining these, we get $0 \\le v(p_n) \\le 0$ for all $n \\in \\mathbb{N}$.\nSince $v(p_n)$ must be in $\\{0, 1\\}$, the only possibility is $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.\n\nThe specific global satisfying valuation $v$ is therefore given by $v(p_n) = 0$ for all $n \\in \\mathbb{N}$. We have already verified in Task 1 (Case 2) that this valuation indeed satisfies all formulas in $T$.\n\n**Task 3: Prove that any satisfying valuation for $T$ must assign $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.**\n\nThis task is to formally prove the uniqueness of the satisfying valuation derived in Task 2. We use mathematical induction on $n$.\nLet $v$ be an arbitrary valuation that satisfies the theory $T$.\n\nBase Case: For $n=0$.\nSince $\\neg p_0 \\in T$, it must be the case that $v(\\neg p_0) = 1$. By the definition of the semantics for negation, $1 - v(p_0) = 1$, which implies $v(p_0) = 0$. The base case holds.\n\nInductive Hypothesis: Assume that for some integer $k \\ge 0$, $v(p_k) = 0$.\n\nInductive Step: We must prove that $v(p_{k+1}) = 0$.\nThe theory $T$ contains the formula $p_{k+1} \\to p_k$. Since $v$ satisfies $T$, we have $v(p_{k+1} \\to p_k) = 1$.\nThe semantics for implication gives $\\max\\{1 - v(p_{k+1}), v(p_k)\\} = 1$.\nSubstituting the inductive hypothesis $v(p_k) = 0$ into this equation, we get:\n$$ \\max\\{1 - v(p_{k+1}), 0\\} = 1 $$\nThis equality can only hold if $1 - v(p_{k+1}) = 1$.\nThis implies $v(p_{k+1}) = 0$.\n\nConclusion: By the principle of mathematical induction, we have proven that $v(p_n) = 0$ for all $n \\in \\mathbb{N}$. This shows that the valuation $v(p_n)=0$ for all $n$ is the *only* possible satisfying valuation for the theory $T$.\n\n**Task 4: Evaluate the sum $S$.**\n\nThe real number $S$ is defined as:\n$$ S \\;=\\; \\sum_{n=0}^{\\infty} 2^{-n-1} \\, v\\!\\big(p_{n+1} \\to p_{n}\\big) $$\nThe valuation $v$ in this expression must be a satisfying valuation for the theory $T$. As proven in Task 3, there is only one such valuation, where $v(p_n) = 0$ for all $n \\in \\mathbb{N}$.\nWe must first evaluate the term $v(p_{n+1} \\to p_n)$ using this unique valuation. For any $n \\in \\mathbb{N}$:\n$$ v(p_{n+1} \\to p_n) = \\max\\{1 - v(p_{n+1}), v(p_n)\\} = \\max\\{1 - 0, 0\\} = 1. $$\nSo, for every term in the summation, the factor $v(p_{n+1} \\to p_n)$ is equal to $1$.\nSubstituting this result into the expression for $S$:\n$$ S = \\sum_{n=0}^{\\infty} 2^{-n-1} \\cdot 1 = \\sum_{n=0}^{\\infty} \\frac{1}{2^{n+1}} $$\nThis is a geometric series. We can write out the terms:\n$$ S = \\frac{1}{2^1} + \\frac{1}{2^2} + \\frac{1}{2^3} + \\ldots $$\nThis series has a first term $a = \\frac{1}{2}$ and a common ratio $r = \\frac{1}{2}$. Since $|r|  1$, the sum converges to:\n$$ S = \\frac{a}{1-r} = \\frac{\\frac{1}{2}}{1 - \\frac{1}{2}} = \\frac{\\frac{1}{2}}{\\frac{1}{2}} = 1. $$\nAlternatively, we can shift the index of summation. Let $k = n+1$. As $n$ goes from $0$ to $\\infty$, $k$ goes from $1$ to $\\infty$:\n$$ S = \\sum_{k=1}^{\\infty} \\left(\\frac{1}{2}\\right)^k = \\left(\\sum_{k=0}^{\\infty} \\left(\\frac{1}{2}\\right)^k\\right) - \\left(\\frac{1}{2}\\right)^0 = \\left(\\frac{1}{1-\\frac{1}{2}}\\right) - 1 = 2 - 1 = 1. $$\nThe value of $S$ is exactly $1$.", "answer": "$$\\boxed{1}$$", "id": "2970273"}, {"introduction": "Building on the previous exercise, this problem explores how to use compactness to reason about models satisfying a more complex set of infinite constraints. You will construct a theory stipulating both that an infinite set of propositions are mutually exclusive and that any finite prefix of them must contain a true proposition. The goal is to apply the Compactness Theorem to demonstrate satisfiability and then precisely determine the properties of any model that meets these conditions.", "problem": "Let $\\{p_i\\}_{i \\in \\mathbb{N}}$ be a countable family of propositional variables. Consider the set of propositional sentences\n$$\\Gamma := \\{\\, p_0 \\lor p_1 \\lor \\cdots \\lor p_n \\;:\\; n \\in \\mathbb{N} \\,\\} \\;\\cup\\; \\{\\, \\neg(p_i \\land p_j) \\;:\\; i, j \\in \\mathbb{N},\\; i \\ne j \\,\\}.$$\nA truth assignment (valuation) $v$ maps each $p_i$ to either $\\mathsf{T}$ or $\\mathsf{F}$ and extends to all sentences in the usual way. Using only the fundamental semantics of propositional logic and the Compactness Theorem for propositional logic, carry out the following steps:\n- Prove that every finite subset of $\\Gamma$ is satisfiable by explicitly constructing a truth assignment that satisfies it.\n- Conclude, by the Compactness Theorem, that $\\Gamma$ is satisfiable.\n- For any valuation $v$ that satisfies $\\Gamma$, define the quantity\n$$N := \\sum_{i=0}^{\\infty} \\mathbf{1}_{\\{v(p_i)=\\mathsf{T}\\}},$$\nwhere $\\mathbf{1}_{\\{v(p_i)=\\mathsf{T}\\}}$ is $1$ if $v(p_i)=\\mathsf{T}$ and $0$ otherwise. Compute the exact value of $N$.\n\nProvide your final answer as a single real number. No rounding is necessary.", "solution": "We recall the basic semantics of propositional logic: a valuation $v$ maps each propositional variable $p_i$ to a truth value in $\\{\\mathsf{T},\\mathsf{F}\\}$, and extends compositionally so that $v(\\neg \\varphi)=\\mathsf{T}$ iff $v(\\varphi)=\\mathsf{F}$, $v(\\varphi \\land \\psi)=\\mathsf{T}$ iff $v(\\varphi)=\\mathsf{T}$ and $v(\\psi)=\\mathsf{T}$, and $v(\\varphi \\lor \\psi)=\\mathsf{T}$ iff at least one of $v(\\varphi)$ or $v(\\psi)$ is $\\mathsf{T}$. A set $\\Sigma$ of sentences is satisfiable if there exists a valuation $v$ such that $v(\\sigma)=\\mathsf{T}$ for all $\\sigma \\in \\Sigma$. The Compactness Theorem for propositional logic states: if every finite subset of a set $\\Sigma$ of propositional sentences is satisfiable, then $\\Sigma$ is satisfiable.\n\nStep 1: Finite satisfiability of $\\Gamma$. Let $\\Sigma \\subseteq \\Gamma$ be finite. Then there exists $n_{\\max} \\in \\mathbb{N}$ such that all disjunctions in $\\Sigma$ are among $\\{p_0 \\lor p_1 \\lor \\cdots \\lor p_n : n \\leq n_{\\max}\\}$, and there is a finite collection of constraints of the form $\\neg(p_i \\land p_j)$ with $i \\neq j$. Define a valuation $v_{\\Sigma}$ by\n- $v_{\\Sigma}(p_0) = \\mathsf{T}$,\n- $v_{\\Sigma}(p_i) = \\mathsf{F}$ for all $i \\geq 1$.\nWe verify that $v_{\\Sigma}$ satisfies every sentence in $\\Sigma$:\n- For each disjunction $p_0 \\lor p_1 \\lor \\cdots \\lor p_n$ with $n \\leq n_{\\max}$, we have $v_{\\Sigma}(p_0)=\\mathsf{T}$, so the disjunction evaluates to $\\mathsf{T}$.\n- For each $\\neg(p_i \\land p_j)$ with $i \\neq j$, at most one of $p_i, p_j$ can be $\\mathsf{T}$ under $v_{\\Sigma}$ because only $p_0$ is assigned $\\mathsf{T}$ and all others are $\\mathsf{F}$. Hence $v_{\\Sigma}(p_i \\land p_j)=\\mathsf{F}$, so $v_{\\Sigma}(\\neg(p_i \\land p_j))=\\mathsf{T}$.\nTherefore every finite $\\Sigma \\subseteq \\Gamma$ is satisfiable.\n\nStep 2: Satisfiability of $\\Gamma$ by compactness. Since every finite subset of $\\Gamma$ is satisfiable, the Compactness Theorem for propositional logic implies that $\\Gamma$ itself is satisfiable. Thus there exists a valuation $v$ such that $v(\\varphi)=\\mathsf{T}$ for all $\\varphi \\in \\Gamma$.\n\nStep 3: Computation of $N$. Let $v$ be any valuation satisfying $\\Gamma$. We first note that the sentence corresponding to $n=0$ in the first part of $\\Gamma$ is $p_0$, so $v(p_0)=\\mathsf{T}$. Next, the sentences $\\neg(p_i \\land p_j)$ for all $i \\neq j$ enforce that at most one variable among $\\{p_i : i \\in \\mathbb{N}\\}$ is assigned $\\mathsf{T}$. Together, these two facts imply that exactly one variable is assigned $\\mathsf{T}$, namely $p_0$. Hence\n$$\\mathbf{1}_{\\{v(p_0)=\\mathsf{T}\\}}=1 \\quad \\text{and} \\quad \\mathbf{1}_{\\{v(p_i)=\\mathsf{T}\\}}=0 \\text{ for all } i \\geq 1.$$\nTherefore,\n$$N \\;=\\; \\sum_{i=0}^{\\infty} \\mathbf{1}_{\\{v(p_i)=\\mathsf{T}\\}} \\;=\\; 1 + \\sum_{i=1}^{\\infty} 0 \\;=\\; 1.$$\nThis value is independent of the particular choice of $v$ satisfying $\\Gamma$ (any such $v$ must make precisely $p_0$ true), so the computed $N$ is uniquely determined by $\\Gamma$.", "answer": "$$\\boxed{1}$$", "id": "2970275"}, {"introduction": "This final practice bridges the gap between the abstract theorem and its computational applications in areas like automated reasoning and formal verification. The Compactness Theorem guarantees that any contradiction in a large set of logical rules stems from a finite, identifiable core; this exercise asks you to prove the existence of such a 'Minimal Unsatisfiable Subset' (MUS) and implement an algorithm to find it. This is a hands-on introduction to the concept of unsatisfiable core extraction, a critical technique for debugging logical specifications.", "problem": "Let $\\mathcal{L}$ be a countable set of propositional variables $\\{p_1,p_2,\\dots\\}$ and let a literal be either $p_k$ or $\\neg p_k$. A clause is a finite disjunction of literals, and a Conjunctive Normal Form (CNF) theory is a finite or infinite set of clauses, interpreted as their conjunction. A CNF theory $\\Gamma$ is satisfiable if there exists a truth assignment $\\sigma:\\mathcal{L}\\to\\{\\text{True},\\text{False}\\}$ such that every clause in $\\Gamma$ is true under $\\sigma$, and unsatisfiable otherwise. The compactness theorem for propositional logic states that a CNF theory is satisfiable if and only if every finite subset is satisfiable. Equivalently, if $\\Gamma$ is unsatisfiable, then some finite subset $\\Delta\\subseteq\\Gamma$ is unsatisfiable.\n\nTask Part I (theoretical): Starting from the compactness theorem for propositional logic and the core definitions above, prove that for any unsatisfiable CNF theory $\\Gamma$, there exists a minimal finite unsatisfiable subset (Minimal Unsatisfiable Subset (MUS)) $\\Sigma\\subseteq\\Gamma$ such that $\\Sigma$ is unsatisfiable and every proper subset of $\\Sigma$ is satisfiable. Explain why this follows from the existence of a finite unsatisfiable subset and elementary finiteness arguments. Then, explain two principled ways to locate such a core: (i) using the resolution rule and the existence of a resolution refutation, and (ii) using hitting set duality between MUS and Minimal Correction Sets (MCS), where an MCS is a minimal subset of clauses whose removal makes the theory satisfiable.\n\nTask Part II (algorithmic): Implement a program that, given several CNF theories encoded over $\\{p_1,p_2,\\dots\\}$, computes one MUS per unsatisfiable input and returns the indices of the clauses constituting that MUS with respect to the input ordering. If the input CNF theory is satisfiable, return the empty list for that test case. The program may use any sound and complete satisfiability procedure for propositional CNF (e.g., the Davis–Putnam–Logemann–Loveland (DPLL) algorithm) to test satisfiability and then perform deletion-based shrinking to a MUS. While the theoretical part may rely on resolution or hitting set duality, the implementation may use a satisfiability checker with iterative deletion to ensure minimality.\n\nRepresentation and input encoding for the test suite:\n- A CNF theory is represented as a Python list of clauses.\n- Each clause is a Python list of integers. A positive integer $k$ represents the literal $p_k$, and a negative integer $-k$ represents the literal $\\neg p_k$.\n- The empty clause is represented by the empty list `[]`, which is unsatisfiable by itself.\n- For example, the CNF theory with clauses $(p_1)$, $(\\neg p_1)$, $(p_1\\lor p_2)$ is represented as `[[1],[-1],[1,2]]`.\n\nTest suite (five cases covering distinct facets):\n1. Happy path unsatisfiable with an obvious core:\n   - $\\Gamma_1 = `[[1],[-1],[1,2]]`$. This is unsatisfiable since it contains $(p_1)$ and $(\\neg p_1)$. A MUS has indices `[0,1]`.\n2. Nontrivial unsatisfiable where every clause is required:\n   - $\\Gamma_2 = `[[1,2],[-1],[-2]]`$. This is unsatisfiable, and removing any single clause makes it satisfiable. A MUS has indices `[0,1,2]`.\n3. Unsatisfiable with a tautology present:\n   - $\\Gamma_3 = `[[1,-1],[1],[-1]]`$, where `[1,-1]` encodes $(p_1\\lor\\neg p_1)$, a tautology. A MUS is obtained by dropping the tautology, yielding indices `[1,2]`.\n4. Satisfiable CNF (boundary condition):\n   - $\\Gamma_4 = `[[1,2],[-1,2],[1,-2]]`$. This is satisfiable (e.g., $p_1=\\text{True}$, $p_2=\\text{True}$). The output must be the empty list `[]`.\n5. Edge case with the empty clause:\n   - $\\Gamma_5 = `[[],[1]]`$. This is unsatisfiable because of the empty clause alone; a MUS is the empty clause, with indices `[0]`.\n\nRequired final output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each entry is the list of clause indices forming one MUS for the corresponding test case (or the empty list if the CNF is satisfiable). For the five test cases above, the output must have the form `[[i_1^{(1)},...],[i_1^{(2)},...],[...],[...],[...]]` with no spaces, for example, `[[0,1],[0,1,2],[1,2],[],[0]]`.\n\nYour program must be self-contained, not read any input, and strictly compute and print the specified output line using the test cases above. No physical units, angle units, or percentages are involved in this problem; all answers are integer indices encoded as specified. The algorithm should be principled, sound, and complete for the small test suite provided, reflecting the theoretical basis outlined in Part I.", "solution": "### Part I: Theoretical Foundation\n\n#### Proof of the Existence of a Minimal Unsatisfiable Subset (MUS)\n\nLet $\\Gamma$ be an unsatisfiable Conjunctive Normal Form (CNF) theory over a countable set of propositional variables $\\mathcal{L} = \\{p_1, p_2, \\dots\\}$. A clause is a finite disjunction of literals (e.g., $p_k$ or $\\neg p_k$), and $\\Gamma$ is a set of such clauses.\n\n1.  **Application of the Compactness Theorem**: The compactness theorem for propositional logic states that a theory is satisfiable if and only if every finite subset of it is satisfiable. The contrapositive form, which is more useful here, states that if a theory $\\Gamma$ is unsatisfiable, then there must exist a finite subset $\\Delta \\subseteq \\Gamma$ that is also unsatisfiable.\n\n2.  **Argument from Finiteness**: Since $\\Gamma$ is unsatisfiable, we are guaranteed the existence of at least one finite unsatisfiable subset $\\Delta \\subseteq \\Gamma$. Let us consider the set $\\mathcal{F}$ of all finite unsatisfiable subsets of $\\Gamma$.\n    $$\n    \\mathcal{F} = \\{S \\mid S \\subseteq \\Gamma, |S|  \\infty, \\text{ and } S \\text{ is unsatisfiable}\\}\n    $$\n    By the compactness theorem, $\\mathcal{F}$ is non-empty. We are searching for a minimal element in this set, where minimality is defined with respect to the subset relation $\\subseteq$. An element $\\Sigma \\in \\mathcal{F}$ is minimal if no proper subset of $\\Sigma$ is also in $\\mathcal{F}$. That is, for every $\\Sigma' \\subset \\Sigma$, $\\Sigma'$ is satisfiable. This is precisely the definition of a Minimal Unsatisfiable Subset (MUS).\n\n3.  **Constructive Existence via Minimization**: We can show such a minimal element $\\Sigma$ must exist. Let's start with any element $\\Delta \\in \\mathcal{F}$. $\\Delta$ is a finite set of clauses.\n    - If $\\Delta$ is already a minimal unsatisfiable subset, we have found our MUS, and we are done. Let $\\Sigma = \\Delta$.\n    - If $\\Delta$ is not minimal, then by definition there exists a proper subset $\\Delta' \\subset \\Delta$ such that $\\Delta'$ is also unsatisfiable. Since $\\Delta$ is finite, $\\Delta'$ must also be finite, which implies $\\Delta' \\in \\mathcal{F}$. We can now replace $\\Delta$ with $\\Delta'$ and repeat the process.\n\n    This procedure generates a sequence of finite unsatisfiable sets $\\Delta_0, \\Delta_1, \\Delta_2, \\dots$ such that $\\Delta_0 = \\Delta$ and $\\Delta_{i+1} \\subset \\Delta_i$. Since each set is a *proper* subset of the previous one, their cardinalities must be strictly decreasing: $|\\Delta_0|  |\\Delta_1|  |\\Delta_2|  \\dots$. Because $\\Delta_0$ is a finite set, its cardinality $|\\Delta_0|$ is a non-negative integer. A strictly decreasing sequence of non-negative integers must be finite. Therefore, this process of finding smaller unsatisfiable subsets must terminate in a finite number of steps. It terminates when we reach a finite unsatisfiable set $\\Sigma$ for which no proper subset is unsatisfiable. Such a set $\\Sigma$ is an MUS.\n\nThis argument demonstrates that for any unsatisfiable theory $\\Gamma$, at least one MUS exists within it.\n\n#### Principled Methods for Locating an MUS\n\n1.  **(i) Resolution Rule and Refutation**: The resolution principle is a sound and complete inference rule for CNF theories. The rule states that from two clauses $(A \\lor x)$ and $(B \\lor \\neg x)$, where $A$ and $B$ are disjunctions of literals and $x$ is a literal, one can infer the resolvent clause $(A \\lor B)$. A CNF theory is unsatisfiable if and only if the empty clause, denoted $\\bot$, can be derived from it using a sequence of resolution steps. Such a sequence (or more generally, a directed acyclic graph of derivations) is called a resolution refutation.\n\n    A resolution refutation for an unsatisfiable theory $\\Gamma$ only uses a finite number of clauses from $\\Gamma$. The set of clauses from $\\Gamma$ used as leaves in the refutation proof graph constitutes a finite unsatisfiable subset. To find an MUS, one can seek a *minimal* resolution refutation, where removing any of the initial clauses used in the proof would make it impossible to derive $\\bot$. The set of clauses from $\\Gamma$ used in such a minimal proof forms an MUS. While finding a minimal refutation is computationally hard, the existence of a refutation provides a concrete \"witness\" to the unsatisfiability of a particular subset of clauses, thereby grounding the concept of an unsatisfiable core. Algorithmically, one can start with a finite unsatisfiable set $\\Delta$ and its refutation, then iteratively try to remove clauses and see if a refutation can still be found for the remainder.\n\n2.  **(ii) Hitting Set Duality with Minimal Correction Sets (MCS)**: This approach relates MUSes to another concept, Minimal Correction Sets (MCS). An MCS of an unsatisfiable theory $\\Gamma$ is a minimal subset of clauses $C \\subseteq \\Gamma$ such that removing it makes the theory satisfiable (i.e., $\\Gamma \\setminus C$ is satisfiable).\n\n    The duality principle states that the set of all MUSes and the set of all MCSes of a theory are hitting set duals of each other. Specifically:\n    - A subset $\\Sigma \\subseteq \\Gamma$ is an MUS if and only if it is a minimal hitting set of the collection of all MCSs of $\\Gamma$.\n    - A subset $C \\subseteq \\Gamma$ is an MCS if and only if it is a minimal hitting set of the collection of all MUSes of $\\Gamma$.\n\n    A set $H$ is a *hitting set* for a collection of sets $\\mathcal{S}$ if $H$ has a non-empty intersection with every set in $\\mathcal{S}$ (i.e., $\\forall S \\in \\mathcal{S}, H \\cap S \\ne \\emptyset$).\n\n    This duality provides a principled, albeit often computationally expensive, way to find an MUS. The algorithm would be:\n    1.  Enumerate all MCSs of the theory $\\Gamma$. This can be done using a SAT solver by repeatedly finding a minimal set of clauses to remove to achieve satisfiability.\n    2.  Let the collection of all MCSs be $\\mathcal{C} = \\{M_1, M_2, \\dots\\}$.\n    3.  Formulate and solve the minimal hitting set problem for $\\mathcal{C}$. The solution to this problem is a set of clauses $\\Sigma$ that is guaranteed to be an MUS of $\\Gamma$.\n\n### Part II: Algorithmic Implementation\n\nThe implementation will find an MUS using a deletion-based shrinking algorithm, which relies on an oracle for satisfiability checking (a SAT solver). The following Python code implements this deletion-based shrinking algorithm and computes the results for the given test suite.\n\n```python\nclass SATSolver:\n    \"\"\"\n    A simple DPLL-based SAT solver with memoization.\n    It uses recursion to perform unit propagation, pure literal elimination,\n    and branching.\n    \"\"\"\n    def __init__(self):\n        self.memo = {}\n\n    def check_sat(self, clauses):\n        \"\"\"\n        Checks if a CNF formula, given as a list of clauses, is satisfiable.\n        \"\"\"\n        # A canonical key for the formula for memoization.\n        key = tuple(sorted(tuple(sorted(c)) for c in clauses))\n        if key in self.memo:\n            return self.memo[key]\n\n        # Base cases: empty formula is SAT, formula with empty clause is UNSAT.\n        if not clauses:\n            self.memo[key] = True\n            return True\n        if any(not c for c in clauses):\n            self.memo[key] = False\n            return False\n\n        # Unit Propagation: Find one unit clause and simplify.\n        for clause in clauses:\n            if len(clause) == 1:\n                literal = clause[0]\n                simplified_clauses = []\n                is_unsat = False\n                for c in clauses:\n                    if literal in c:\n                        continue\n                    if -literal in c:\n                        new_c = [l for l in c if l != -literal]\n                        if not new_c:\n                            is_unsat = True\n                            break\n                        simplified_clauses.append(new_c)\n                    else:\n                        simplified_clauses.append(c)\n                \n                if is_unsat:\n                    self.memo[key] = False\n                    return False\n\n                # Recurse on the simplified formula.\n                res = self.check_sat(simplified_clauses)\n                self.memo[key] = res\n                return res\n\n        # Pure Literal Elimination: Find one pure literal and simplify.\n        all_lits = {l for c in clauses for l in c}\n        for pure_lit in all_lits:\n            if -pure_lit not in all_lits:\n                simplified_clauses = [c for c in clauses if pure_lit not in c]\n                res = self.check_sat(simplified_clauses)\n                self.memo[key] = res\n                return res\n\n        # Branching (Splitting Rule): Pick a variable and try both assignments.\n        var = clauses[0][0]\n        \n        # Try var = True by adding a unit clause [var].\n        res1 = self.check_sat(clauses + [[var]])\n        if res1:\n            self.memo[key] = True\n            return True\n        \n        # Try var = False if the first branch failed.\n        res2 = self.check_sat(clauses + [[-var]])\n        self.memo[key] = res2\n        return res2\n\ndef find_mus(cnf):\n    \"\"\"\n    Finds a Minimal Unsatisfiable Subset (MUS) of a CNF formula.\n    Returns a list of indices of the clauses in the MUS.\n    If the formula is satisfiable, returns an empty list.\n    \"\"\"\n    solver = SATSolver()\n    if solver.check_sat(cnf):\n        return []\n\n    mus_indices = list(range(len(cnf)))\n    # Iterate backwards through the original clause indices.\n    for i in range(len(cnf) - 1, -1, -1):\n        # Check if clause 'i' is still a candidate.\n        if i not in mus_indices:\n            continue\n\n        # Temporarily remove clause 'i' and check satisfiability.\n        temp_indices = [idx for idx in mus_indices if idx != i]\n        \n        temp_cnf = [cnf[idx] for idx in temp_indices]\n        \n        # Use a fresh solver for each subproblem to ensure no memoization conflicts.\n        temp_solver = SATSolver()\n        if not temp_solver.check_sat(temp_cnf):\n            # If the formula is still UNSAT, clause 'i' is redundant.\n            mus_indices.remove(i)\n            \n    return sorted(mus_indices)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # 1. Happy path unsatisfiable with an obvious core\n        [[1], [-1], [1, 2]],\n        # 2. Nontrivial unsatisfiable where every clause is required\n        [[1, 2], [-1], [-2]],\n        # 3. Unsatisfiable with a tautology present\n        [[1, -1], [1], [-1]],\n        # 4. Satisfiable CNF (boundary condition)\n        [[1, 2], [-1, 2], [1, -2]],\n        # 5. Edge case with the empty clause\n        [[], [1]],\n    ]\n\n    results = []\n    for cnf in test_cases:\n        mus = find_mus(cnf)\n        results.append(mus)\n\n    # Format the output string to be a single line with no spaces.\n    output_str = str(results).replace(\" \", \"\")\n    print(output_str)\n\n# To generate the answer for the XML file, we can call the solve() function.\n# The expected output is printed to the console. For this problem,\n# we place the output string directly into the answer tag.\n# solve()\n```", "answer": "[[0,1],[0,1,2],[1,2],[],[0]]", "id": "2970266"}]}