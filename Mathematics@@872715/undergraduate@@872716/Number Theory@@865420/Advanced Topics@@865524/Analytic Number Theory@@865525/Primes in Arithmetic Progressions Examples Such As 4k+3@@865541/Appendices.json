{"hands_on_practices": [{"introduction": "The abstract guarantee that a progression contains primes is powerful, but finding them requires a concrete search. This exercise provides direct practice in implementing this search, translating the theoretical concept of an arithmetic progression $a+tm$ into a computational algorithm. By systematically checking each term for primality, you will develop a foundational skill for exploring the distribution of primes and witness Dirichlet's theorem in action for various moduli [@problem_id:3088480].", "problem": "Given integers $m$ and $a$ with $\\gcd(a,m)=1$, consider the arithmetic progression $\\{a+tm : t \\in \\mathbb{Z}_{\\ge 0}\\}$. The objective is to compute, for each provided pair $(m,a)$, the smallest prime $p$ such that $p \\equiv a \\pmod m$. Use only definitions and well-tested facts as a foundation: the definition of a prime number, the definition of congruence modulo $m$, and the property that if $\\gcd(a,m)=1$, then the residue class $a \\pmod m$ is coprime to $m$. Your program must implement a logically sound search method to find $p$ by scanning the arithmetic progression and testing primality of candidates. You must also explain the search method in terms of these foundational concepts.\n\nDefinitions to use:\n- A prime number is an integer $p \\ge 2$ that has no positive divisors other than $1$ and $p$.\n- For integers $x,y,m$ with $m \\ge 1$, $x \\equiv y \\pmod m$ means that $m \\mid x-y$.\n- The Greatest Common Divisor (gcd) of integers $u$ and $v$, denoted $\\gcd(u,v)$, is the largest integer $d$ such that $d$ divides both $u$ and $v$.\n\nDesign a program that, for each test case $(m,a)$, outputs the smallest prime $p$ satisfying $p \\equiv a \\pmod m$.\n\nTest suite:\n- Case $1$: $(m,a)=(4,3)$.\n- Case $2$: $(m,a)=(5,2)$.\n- Case $3$: $(m,a)=(8,1)$.\n- Case $4$: $(m,a)=(7,-1)$.\n- Case $5$: $(m,a)=(9,2)$.\n- Case $6$: $(m,a)=(11,10)$.\n- Case $7$: $(m,a)=(4,1)$.\n- Case $8$: $(m,a)=(100,1)$.\n\nNotes on coverage:\n- Cases $1$ and $7$ exercise arithmetic progressions modulo $4$, including the classic progression $4k+3$.\n- Case $4$ includes a negative residue to test normalization to the least nonnegative residue.\n- Cases $2$ and $5$ show situations where the smallest prime is equal to the residue itself.\n- Case $3$ requires multiple steps through the progression to reach the first prime.\n- Case $6$ tests a residue near $m-1$ for an odd modulus.\n- Case $8$ uses a larger modulus.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[r_1,r_2,r_3]$). For the given test suite, the output must be the list of the smallest primes found for each $(m,a)$ in the order listed.", "solution": "The problem is validated as scientifically grounded, well-posed, and objective. The premises are consistent with established principles of number theory. All provided test cases satisfy the condition $\\gcd(a,m)=1$. The problem is solvable as stated.\n\nThe problem requires finding the smallest prime number $p$ that belongs to the arithmetic progression $\\{a+tm : t \\in \\mathbb{Z}_{\\ge 0}\\}$ for given integers $m$ and $a$ with $\\gcd(a,m)=1$. The solution involves a direct implementation of a search algorithm coupled with a primality test, both founded on the provided definitions.\n\nThe core of the methodology is a systematic search. The algorithm iterates through the elements of the arithmetic progression by starting with the integer $t=0$ and incrementing it by $1$ in each subsequent step. For each value of $t$, a candidate number $c_t$ is generated using the formula $c_t = a + t \\cdot m$.\n\nEach candidate $c_t$ is then subjected to a primality test to determine if it is a prime number. Since the search proceeds in increasing order of $t$, the first candidate found to be prime is guaranteed to be the smallest prime in the specified arithmetic progression. This search process is guaranteed to terminate successfully. A foundational result in number theory, Dirichlet's theorem on arithmetic progressions, states that for any two coprime integers $a$ and $m$, the arithmetic progression $a+tm$ contains infinitely many prime numbers. Therefore, a smallest prime must exist.\n\nThe primality test is derived directly from the definition of a prime number: an integer $p \\ge 2$ that has no positive divisors other than $1$ and $p$. The algorithm for testing if an integer $n$ is prime is as follows:\n$1$. By definition, any integer less than $2$ is not prime. So, if $n  2$, it is composite.\n$2$. The number $2$ is the smallest prime number.\n$3$. Any even number greater than $2$ is divisible by $2$ and is therefore not prime.\n$4$. For any odd integer $n > 2$, we must check for divisors. A key property is that if $n$ is composite, it must have a prime divisor $d$ such that $d \\le \\sqrt{n}$. This means we only need to check for divisibility by odd numbers up to $\\sqrt{n}$. The trial division procedure checks if $n$ is divisible by any odd integer $d$ in the range $3 \\le d \\le \\sqrt{n}$. If such a divisor is found, $n$ is composite. If the loop completes without finding any such divisors, $n$ is prime.\n\nThe overall algorithm for each given pair $(m,a)$ is:\n$1$. Initialize the counter $t=0$.\n$2$. Begin an indefinite loop. Inside the loop, calculate the candidate number $c = a + t \\cdot m$.\n$3$. Apply the primality test to the candidate $c$.\n$4$. If $c$ is determined to be prime, then it is the smallest prime in the progression. The value $c$ is the result for the pair $(m,a)$, and the search for this pair is terminated.\n$5$. If $c$ is not prime, increment the counter $t$ to $t+1$ and continue the loop with the next candidate.\n\nThis procedure correctly handles all cases, including those where $a$ is negative or smaller than $2$, such as in the test case $(m,a)=(7,-1)$. The first candidate, for $t=0$, is $c_0 = -1$, which is correctly identified as not prime. The loop continues for $t=1, 2, \\dots$, generating candidates $6, 13, \\dots$, until the first prime, $13$, is found.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_prime(n):\n    \"\"\"\n    Tests if an integer n is a prime number using trial division.\n    \n    A prime number is an integer p = 2 that has no positive divisors\n    other than 1 and p.\n    \"\"\"\n    # Primes must be = 2.\n    if n  2:\n        return False\n    # 2 is the only even prime.\n    if n == 2:\n        return True\n    # All other even numbers are not prime.\n    if n % 2 == 0:\n        return False\n    # Check for odd divisors from 3 up to sqrt(n).\n    # We only need to check up to the square root of n because if n has a\n    # divisor larger than its square root, it must also have a divisor\n    # smaller than it.\n    # The loop increments by 2 to check only odd numbers.\n    limit = int(np.sqrt(n))\n    for i in range(3, limit + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef find_smallest_prime_in_progression(m, a):\n    \"\"\"\n    Finds the smallest prime p such that p = a (mod m).\n    \n    This is achieved by iterating through the arithmetic progression\n    {a + t*m for t = 0} and testing each number for primality.\n    \"\"\"\n    # The condition gcd(a,m)=1 guarantees a prime exists in this progression.\n    # We search by incrementing t from 0 upwards.\n    t = 0\n    while True:\n        candidate = a + t * m\n        if is_prime(candidate):\n            return candidate\n        t += 1\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (4, 3),    # Case 1\n        (5, 2),    # Case 2\n        (8, 1),    # Case 3\n        (7, -1),   # Case 4\n        (9, 2),    # Case 5\n        (11, 10),  # Case 6\n        (4, 1),    # Case 7\n        (100, 1),  # Case 8\n    ]\n\n    results = []\n    for m, a in test_cases:\n        # For each test case, find the smallest prime in the progression.\n        smallest_prime = find_smallest_prime_in_progression(m, a)\n        results.append(smallest_prime)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3088480"}, {"introduction": "Beyond finding the first prime, number theorists are interested in the frequency and distribution of primes within a progression. This practice focuses on the famous progression of numbers of the form $4k+3$, asking you to sieve a range of terms to identify all the primes it contains. This task moves from a simple search to a more data-oriented analysis, providing hands-on experience with implementing primality tests and observing the density of primes in a specific arithmetic sequence [@problem_id:3088516].", "problem": "You are given an arithmetic progression defined by the rule $t_n = a + n d$ for $n \\in \\{0,1,2,\\dots\\}$, with fixed parameters $a=3$ and $d=4$. This progression enumerates all integers of the form $4k+3$. A prime number is an integer $p \\ge 2$ that has no positive divisors other than $1$ and itself. Your task is to implement a primality test from first principles and apply it to the initial segment of the progression. Specifically, for a given cut-off $N$, examine the first $N$ terms $\\{t_0, t_1, \\dots, t_{N-1}\\}$ and return the sublist consisting of exactly those terms that are prime. The program must be self-contained and must not read any input. The arithmetic, number-theoretic, and algorithmic concepts used should be justified from fundamental definitions such as divisibility, prime numbers, and the structure of arithmetic progressions.\n\nTest Suite:\n- Case $1$: $N=0$ (boundary case with no terms).\n- Case $2$: $N=1$ (the single term $t_0=3$).\n- Case $3$: $N=5$ (a small set including both prime and composite terms).\n- Case $4$: $N=200$ (the first $200$ terms, representing a comprehensive run over the progression $4k+3$).\n\nFor each test case $N$, the required answer is the list of prime terms among the first $N$ terms of the progression. The aggregate output must be a single line containing the results for the four test cases, in order, as a comma-separated list enclosed in square brackets. Each element of this outer list must itself be a bracketed, comma-separated list of integers denoting the primes found for that test case. The final output therefore has the form $[L_0,L_1,L_2,L_3]$ where $L_i$ is the list of primes for Case $i$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$).", "solution": "The problem is valid as it is scientifically grounded in number theory, well-posed, and all its components are formally and unambiguously defined. We shall proceed with a solution founded on first principles.\n\nThe task is to identify prime numbers within the initial segment of a specific arithmetic progression. This requires two main components: a method to generate the terms of the progression and a method to test each term for primality.\n\nFirst, we address the arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between consecutive terms is constant. This constant difference is called the common difference, denoted by $d$. A term $t_n$ in the sequence is defined by the formula $t_n = a + n d$, where $a$ is the first term (corresponding to $n=0$) and $n$ is a non-negative integer, $n \\in \\{0, 1, 2, \\dots\\}$. The problem specifies the parameters $a=3$ and $d=4$. Thus, the sequence under consideration is given by:\n$$t_n = 3 + 4n$$\nThis an infinite sequence of integers: $3, 7, 11, 15, 19, \\dots$. For each test case, we are given a cutoff $N$, and our analysis is restricted to the first $N$ terms: $\\{t_0, t_1, \\dots, t_{N-1}\\}$.\n\nSecond, we must establish a rigorous procedure for primality testing. A prime number is formally defined as an integer $p \\ge 2$ whose only positive divisors are $1$ and $p$. An integer greater than $1$ that is not prime is called a composite number. To determine if a given term $t_n$ is prime, we must verify that it satisfies this definition.\n\nThe most fundamental method for primality testing, derived directly from the definition, is trial division. To test if an integer $m > 1$ is prime, we can check for divisibility by every integer $k$ in the range $2 \\le k  m$. If any such $k$ divides $m$ (i.e., the remainder of the division $m/k$ is $0$), then $m$ has a divisor other than $1$ and itself, and is therefore composite. If the entire range is checked and no divisor is found, $m$ must be prime.\n\nThis naive trial division algorithm can be significantly optimized. A crucial mathematical insight is that if an integer $m$ is composite, it can be written as a product of two factors, $m = k_1 \\cdot k_2$. If both factors were greater than $\\sqrt{m}$, their product $k_1 \\cdot k_2$ would be greater than $\\sqrt{m} \\cdot \\sqrt{m} = m$, which is a contradiction. Therefore, if $m$ is composite, at least one of its divisors must be less than or equal to $\\sqrt{m}$. This principle allows us to reduce the search space for potential divisors. We only need to perform trial division for integers $k$ in the range $2 \\le k \\le \\lfloor\\sqrt{m}\\rfloor$, where $\\lfloor \\cdot \\rfloor$ denotes the floor function.\n\nA further optimization can be made. Any even number greater than $2$ is composite, as it is divisible by $2$. The terms of our sequence $t_n = 4n+3$ are all odd. An odd number cannot have any even divisors. Therefore, we only need to test for odd divisors. The number $2$ can be handled as a special case; it is prime. For any integer $m > 2$, we can first check if it is even. If it is, it is composite. If not, we only need to test for odd divisors $k \\in \\{3, 5, 7, \\dots\\}$ up to $\\lfloor\\sqrt{m}\\rfloor$.\n\nCombining these principles, we formulate the following algorithm for a function `is_prime(m)`:\n1. If $m  2$, it is not prime. Return false.\n2. If $m = 2$, it is prime. Return true.\n3. If $m > 2$ and $m$ is divisible by $2$, it is composite. Return false.\n4. For all odd integers $k$ starting from $3$ up to and including $\\lfloor\\sqrt{m}\\rfloor$:\n   a. If $m$ is divisible by $k$, then $m$ is composite. Return false.\n5. If the loop completes without finding any divisors, $m$ is prime. Return true.\n\nThis robust algorithm will be used to test each term of the progression.\n\nThe overall procedure to solve the problem for a given cutoff $N$ is as follows:\n1. Initialize an empty list, `prime_terms`, to store the results.\n2. If $N = 0$, the set of terms is empty, so we return the empty list.\n3. If $N > 0$, iterate with an index $n$ from $0$ to $N-1$.\n4. In each iteration, calculate the term $t_n = 3 + 4n$.\n5. Apply the `is_prime` function to $t_n$.\n6. If `is_prime(t_n)` returns true, append $t_n$ to the `prime_terms` list.\n7. After the loop completes, `prime_terms` contains all the prime numbers among the first $N$ terms of the sequence.\n\nThis procedure will be executed for each value of $N$ specified in the test suite: $N=0$, $N=1$, $N=5$, and $N=200$. The final output will be an aggregation of the lists generated for each case, formatted as specified. For instance, for $N=5$, the terms are $t_0=3$, $t_1=7$, $t_2=11$, $t_3=15$, and $t_4=19$. Applying the primality test:\n- $3$: prime.\n- $7$: prime.\n- $11$: prime.\n- $15 = 3 \\times 5$: composite.\n- $19$: prime.\nThe resulting list for $N=5$ is $[3, 7, 11, 19]$. This process is repeated for all test cases.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef is_prime(m):\n    \"\"\"\n    Tests if an integer m is prime using an optimized trial division method.\n\n    This function is implemented from first principles as required.\n    1. A number less than 2 is not prime.\n    2. The number 2 is the only even prime.\n    3. Any other even number is composite.\n    4. For an odd number m, we only need to check for odd divisors k\n       up to sqrt(m). If a divisor  sqrt(m) exists, a corresponding\n       divisor  sqrt(m) must also exist.\n    \"\"\"\n    if m  2:\n        return False\n    if m == 2:\n        return True\n    if m % 2 == 0:\n        return False\n    \n    # Check for odd divisors from 3 up to the square root of m.\n    limit = int(np.sqrt(m))\n    for i in range(3, limit + 1, 2):\n        if m % i == 0:\n            return False\n            \n    return True\n\ndef find_primes_in_progression(N, a, d):\n    \"\"\"\n    Generates the first N terms of an arithmetic progression and returns the\n    subset of terms that are prime.\n\n    Args:\n        N (int): The number of terms to examine, from t_0 to t_{N-1}.\n        a (int): The first term of the progression (t_0).\n        d (int): The common difference of the progression.\n\n    Returns:\n        list: A list of prime numbers found among the first N terms.\n    \"\"\"\n    prime_terms = []\n    if N == 0:\n        return []\n        \n    for n in range(N):\n        term = a + n * d\n        if is_prime(term):\n            prime_terms.append(term)\n            \n    return prime_terms\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n    # Define the fixed parameters for the arithmetic progression t_n = a + nd.\n    a = 3\n    d = 4\n\n    # Define the test cases from the problem statement.\n    test_cases = [0, 1, 5, 200]\n\n    results = []\n    for N in test_cases:\n        # Find the list of prime terms for the current test case.\n        result_list = find_primes_in_progression(N, a, d)\n        results.append(result_list)\n\n    # Format the final output according to the problem specification.\n    # The output must be a single line string, e.g., [[3],[7,11],[13]].\n    # Python's default string representation of a list is \"[...]\", which\n    # matches the required format for the inner lists.\n    # We join these string representations with a comma and enclose them in\n    # the outer brackets.\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3088516"}, {"introduction": "Arithmetic progressions often arise as solutions to systems of constraints. This problem beautifully synthesizes the Chinese Remainder Theorem (CRT) with the search for prime numbers. You will first construct an arithmetic progression by solving a system of simultaneous congruences, and then apply your search skills to find the smallest prime number that satisfies these conditions, demonstrating a powerful workflow that connects different pillars of number theory [@problem_id:3088517].", "problem": "Let $x$ be an integer satisfying the simultaneous congruences $x \\equiv 3 \\pmod{4}$, $x \\equiv 1 \\pmod{5}$, and $x \\equiv 2 \\pmod{7}$. Starting from the definition of congruence (that is, $a \\equiv b \\pmod{m}$ means $m \\mid a-b$) and the statement of the Chinese Remainder Theorem (CRT) that for pairwise coprime moduli there is a unique solution modulo their product, derive the unique residue class modulo $140$ of all such $x$ and compute the least nonnegative solution. Then, interpret this residue class as an arithmetic progression and determine the least prime term in this progression, justifying its primality by checking divisibility only by primes up to its square root. Provide your final answer as the least prime in this progression, expressed as an exact integer with no rounding.", "solution": "The user has provided a problem that requires solving a system of linear congruences and then finding the smallest prime number in the resulting arithmetic progression.\n\n**Problem Validation**\n\n**Step 1: Extract Givens**\n-   $x$ is an integer.\n-   $x \\equiv 3 \\pmod{4}$\n-   $x \\equiv 1 \\pmod{5}$\n-   $x \\equiv 2 \\pmod{7}$\n-   Definition of congruence: $a \\equiv b \\pmod{m}$ means $m \\mid a-b$.\n-   Chinese Remainder Theorem (CRT) statement: for pairwise coprime moduli, there is a unique solution modulo their product.\n-   Task 1: Derive the unique residue class of $x$ modulo $140$.\n-   Task 2: Compute the least non-negative solution for $x$.\n-   Task 3: Interpret the solution as an arithmetic progression.\n-   Task 4: Find the least prime term in this progression.\n-   Task 5: Justify the primality of this term by checking divisibility by primes up to its square root.\n\n**Step 2: Validate Using Extracted Givens**\n-   **Scientifically Grounded:** The problem is a standard exercise in elementary number theory, based on the well-established Chinese Remainder Theorem and the definition of prime numbers.\n-   **Well-Posed:** The moduli $4$, $5$, and $7$ are pairwise coprime ($\\gcd(4,5)=1$, $\\gcd(4,7)=1$, $\\gcd(5,7)=1$). The CRT guarantees that a unique solution exists modulo the product $4 \\times 5 \\times 7 = 140$. The tasks are specific and lead to a single, verifiable answer.\n-   **Objective:** The problem is stated using precise mathematical language, free of ambiguity or subjective claims.\n\nThe problem does not exhibit any of the flaws listed in the validation criteria. It is scientifically sound, well-posed, objective, and complete.\n\n**Step 3: Verdict and Action**\nThe problem is **valid**. A solution will be provided.\n\n**Derivation of the Solution**\n\nWe are given the following system of linear congruences:\n$$x \\equiv 3 \\pmod{4}$$\n$$x \\equiv 1 \\pmod{5}$$\n$$x \\equiv 2 \\pmod{7}$$\n\nFrom the first congruence, $x \\equiv 3 \\pmod{4}$, we can express $x$ as $x = 4k_1 + 3$ for some integer $k_1$.\n\nWe substitute this expression into the second congruence, $x \\equiv 1 \\pmod{5}$:\n$$4k_1 + 3 \\equiv 1 \\pmod{5}$$\nSubtracting $3$ from both sides gives:\n$$4k_1 \\equiv -2 \\pmod{5}$$\nSince $-2 \\equiv 3 \\pmod{5}$, the congruence becomes:\n$$4k_1 \\equiv 3 \\pmod{5}$$\nTo solve for $k_1$, we need the multiplicative inverse of $4$ modulo $5$. We can find this by inspection: $4 \\times 1 \\equiv 4 \\pmod{5}$, $4 \\times 2 \\equiv 8 \\equiv 3 \\pmod{5}$, $4 \\times 3 \\equiv 12 \\equiv 2 \\pmod{5}$, $4 \\times 4 \\equiv 16 \\equiv 1 \\pmod{5}$. The inverse of $4$ modulo $5$ is $4$. Multiplying both sides of the congruence by $4$:\n$$4(4k_1) \\equiv 4(3) \\pmod{5}$$\n$$16k_1 \\equiv 12 \\pmod{5}$$\n$$k_1 \\equiv 2 \\pmod{5}$$\nThis implies that $k_1$ must be of the form $k_1 = 5k_2 + 2$ for some integer $k_2$.\n\nNow, we substitute this expression for $k_1$ back into our equation for $x$:\n$$x = 4(5k_2 + 2) + 3$$\n$$x = 20k_2 + 8 + 3$$\n$$x = 20k_2 + 11$$\nThis relationship, $x \\equiv 11 \\pmod{20}$, consolidates the first two congruences.\n\nNext, we use the third congruence, $x \\equiv 2 \\pmod{7}$. Substituting our new expression for $x$:\n$$20k_2 + 11 \\equiv 2 \\pmod{7}$$\nWe reduce the coefficients modulo $7$. Since $20 = (2 \\times 7) + 6$, we have $20 \\equiv 6 \\pmod{7}$ or more conveniently $20 \\equiv -1 \\pmod{7}$. Since $11 = (1 \\times 7) + 4$, we have $11 \\equiv 4 \\pmod{7}$. The congruence becomes:\n$$-k_2 + 4 \\equiv 2 \\pmod{7}$$\nSubtracting $4$ from both sides:\n$$-k_2 \\equiv -2 \\pmod{7}$$\nMultiplying by $-1$:\n$$k_2 \\equiv 2 \\pmod{7}$$\nThis means $k_2$ can be written as $k_2 = 7k_3 + 2$ for some integer $k_3$.\n\nFinally, we substitute this back into the expression $x = 20k_2 + 11$:\n$$x = 20(7k_3 + 2) + 11$$\n$$x = 140k_3 + 40 + 11$$\n$$x = 140k_3 + 51$$\nThis is the general form for all integers $x$ satisfying the system. Thus, the unique residue class modulo $140$ is $x \\equiv 51 \\pmod{140}$.\n\nThe least non-negative solution is found by setting $k_3 = 0$, which yields $x = 51$.\n\nThe set of non-negative solutions forms an arithmetic progression: $a_n = 51 + 140n$ for $n = 0, 1, 2, \\dots$. We are asked to find the least prime term in this progression.\n\nLet's test the first few terms:\nFor $n=0$: $a_0 = 51 + 140(0) = 51$. To check for primality, we see that the sum of the digits is $5+1=6$, which is divisible by $3$. Indeed, $51 = 3 \\times 17$. So, $51$ is not prime.\n\nFor $n=1$: $a_1 = 51 + 140(1) = 191$. To check if $191$ is prime, we must test for divisibility by prime numbers up to $\\sqrt{191}$. We know that $13^2 = 169$ and $14^2 = 196$, so $\\sqrt{191}$ is between $13$ and $14$. We only need to test the primes less than or equal to $13$: $2, 3, 5, 7, 11, 13$.\n-   Divisibility by $2$: $191$ is odd, so it is not divisible by $2$.\n-   Divisibility by $3$: The sum of digits is $1+9+1=11$, which is not divisible by $3$. So $191$ is not divisible by $3$.\n-   Divisibility by $5$: The last digit is $1$, not $0$ or $5$. So $191$ is not divisible by $5$.\n-   Divisibility by $7$: $191 = 7 \\times 27 + 2$. The remainder is $2$, so it is not divisible by $7$.\n-   Divisibility by $11$: $191 = 11 \\times 17 + 4$. The remainder is $4$, so it is not divisible by $11$.\n-   Divisibility by $13$: $191 = 13 \\times 14 + 9$. The remainder is $9$, so it is not divisible by $13$.\n\nSince $191$ is not divisible by any prime less than or equal to its square root, $191$ is a prime number. As this is the first prime found in the sequence (for $n=1$, after checking the non-prime term for $n=0$), it is the least prime term in the progression.", "answer": "$$\\boxed{191}$$", "id": "3088517"}]}