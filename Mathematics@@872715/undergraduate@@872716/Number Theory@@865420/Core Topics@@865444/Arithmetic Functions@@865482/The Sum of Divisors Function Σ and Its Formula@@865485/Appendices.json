{"hands_on_practices": [{"introduction": "The most powerful tool for analyzing arithmetic functions is often the prime factorization of an integer. This practice guides you through deriving the standard formula for the sum of divisors function, $\\sigma(n)$, by first considering its behavior on prime powers and then extending it to all integers using the property of multiplicativity. By working through the calculation for $\\sigma(360)$ and verifying it directly, you will solidify your understanding of how the Unique Factorization Theorem provides a computational shortcut for this fundamental function.", "problem": "Let $n \\in \\mathbb{N}$ and define the sum of divisors function $\\sigma(n)$ to be the sum of all positive divisors of $n$. Starting only from this definition and basic properties of divisors, do the following:\n\n- Establish that if $\\gcd(m,n)=1$ then $\\sigma(mn)=\\sigma(m)\\sigma(n)$ by reasoning directly from the way divisors of $mn$ arise from divisors of $m$ and divisors of $n$.\n- For a prime $p$ and exponent $a \\in \\mathbb{Z}_{\\ge 0}$, derive $\\sigma(p^{a})$ from the definition by enumerating the divisors of $p^{a}$ and evaluating the resulting finite geometric series using standard summation facts.\n- Factor $360$ into prime powers, use your results to compute $\\sigma(360)$, and then verify your computation by directly listing all positive divisors of $360$ and summing them without invoking multiplicativity or any closed-form beyond straightforward addition.\n\nExpress your final answer as an exact integer. No rounding is required.", "solution": "We begin from the definition: for $n \\in \\mathbb{N}$, the sum of divisors function $\\sigma(n)$ is the sum of all positive divisors of $n$.\n\nFirst, we establish multiplicativity for coprime arguments. Suppose $\\gcd(m,n)=1$. Every positive divisor of $mn$ can be written uniquely as $d=ab$ where $a \\mid m$ and $b \\mid n$, because the prime factors of $m$ and $n$ are disjoint. Therefore,\n$$\n\\sigma(mn)\n=\\sum_{d \\mid mn} d\n=\\sum_{a \\mid m} \\sum_{b \\mid n} ab\n=\\left(\\sum_{a \\mid m} a\\right)\\left(\\sum_{b \\mid n} b\\right)\n=\\sigma(m)\\sigma(n).\n$$\nThus, $\\sigma$ is multiplicative on coprime arguments.\n\nSecond, we compute $\\sigma(p^{a})$ for a prime $p$ and integer $a \\ge 0$. The positive divisors of $p^{a}$ are precisely $p^{0},p^{1},\\dots,p^{a}$. Hence\n$$\n\\sigma(p^{a})=\\sum_{j=0}^{a} p^{j}.\n$$\nThis is a finite geometric series with ratio $p$, so by the standard geometric sum identity,\n$$\n\\sigma(p^{a})=\\frac{p^{a+1}-1}{p-1}.\n$$\n\nNow we factor $360$ into prime powers. We have\n$$\n360=36 \\cdot 10= (2^{2}\\cdot 3^{2}) \\cdot (2 \\cdot 5)=2^{3}\\cdot 3^{2}\\cdot 5^{1}.\n$$\nBy multiplicativity over coprime factors and the prime power formula just derived,\n$$\n\\sigma(360)=\\sigma(2^{3})\\sigma(3^{2})\\sigma(5^{1})\n=\\left(\\sum_{j=0}^{3}2^{j}\\right)\\left(\\sum_{j=0}^{2}3^{j}\\right)\\left(\\sum_{j=0}^{1}5^{j}\\right)\n=\\left(1+2+4+8\\right)\\left(1+3+9\\right)\\left(1+5\\right).\n$$\nCompute each sum:\n$$\n1+2+4+8=15, \\quad 1+3+9=13, \\quad 1+5=6.\n$$\nTherefore,\n$$\n\\sigma(360)=15 \\cdot 13 \\cdot 6=195 \\cdot 6=1170.\n$$\n\nFinally, we verify this result by direct divisor summation, listing all positive divisors of $360$ and summing them without invoking multiplicativity. Since $360=2^{3}\\cdot 3^{2}\\cdot 5^{1}$, every positive divisor has the form $2^{a}3^{b}5^{c}$ with $a \\in \\{0,1,2,3\\}$, $b \\in \\{0,1,2\\}$, and $c \\in \\{0,1\\}$. Enumerating:\n\n- For $c=0$ and $b=0$: $1,2,4,8$ with sum $1+2+4+8=15$.\n- For $c=0$ and $b=1$: $3,6,12,24$ with sum $3+6+12+24=45$.\n- For $c=0$ and $b=2$: $9,18,36,72$ with sum $9+18+36+72=135$.\n- For $c=1$ and $b=0$: $5,10,20,40$ with sum $5+10+20+40=75$.\n- For $c=1$ and $b=1$: $15,30,60,120$ with sum $15+30+60+120=225$.\n- For $c=1$ and $b=2$: $45,90,180,360$ with sum $45+90+180+360=675$.\n\nAdding these partial sums,\n$$\n15+45+135+75+225+675=(15+45+135)+(75+225+675)=195+975=1170.\n$$\nThis matches the multiplicative computation, confirming that\n$$\n\\sigma(360)=1170.\n$$", "answer": "$$\\boxed{1170}$$", "id": "3093515"}, {"introduction": "While the prime factorization of $n$ gives us a multiplicative way to compute $\\sigma(n)$, we can also gain insight by studying the structure of its divisors directly. This exercise invites you to explore the symmetry in the set of divisors, where each divisor $d$ can be paired with its counterpart $n/d$. By analyzing how these pairs behave, particularly when $n$ is a perfect square, you will derive an alternative and elegant formula for $\\sigma(n)$ that highlights this pairing structure.", "problem": "Let $n$ be a positive integer and let $\\sigma(n)$ denote the sum of all positive divisors of $n$, that is, $\\sigma(n)=\\sum_{d\\mid n} d$. Starting only from this definition and the basic properties of divisibility, derive a decomposition of the divisor set when $n$ is a perfect square that expresses $\\sigma(n)$ as a sum over divisor pairs strictly less than $\\sqrt{n}$ together with the contribution from $\\sqrt{n}$. Then apply your decomposition to compute $\\sigma(36)$. Provide your final answer as an exact integer value.", "solution": "The problem asks for a derivation of a formula for the sum of divisors function, $\\sigma(n)$, for the specific case where $n$ is a perfect square. This derivation must be based on the definition $\\sigma(n)=\\sum_{d\\mid n} d$ and basic properties of divisibility. Subsequently, this formula is to be applied to compute $\\sigma(36)$.\n\nLet $n$ be a positive integer. The set of all positive divisors of $n$ is denoted by $D_n = \\{d \\in \\mathbb{Z}^+ \\mid d \\text{ divides } n\\}$. The sum of these divisors is $\\sigma(n) = \\sum_{d \\in D_n} d$.\n\nA fundamental property of divisibility is that if $d$ is a divisor of $n$, then the quotient $n/d$ is also a divisor of $n$. This allows us to pair the divisors of $n$. For each divisor $d$, we have a corresponding divisor $n/d$. The product of each pair is $d \\cdot (n/d) = n$.\n\nWe can categorize the divisors based on their relationship with $\\sqrt{n}$.\n1.  If $d  \\sqrt{n}$, then $n/d  \\sqrt{n}$.\n2.  If $d  \\sqrt{n}$, then $n/d  \\sqrt{n}$.\n3.  If $d = \\sqrt{n}$, then $n/d = \\sqrt{n}$. This case is only possible if $n$ is a perfect square, such that $\\sqrt{n}$ is an integer.\n\nThe problem specifies that $n$ is a perfect square. Let $n=k^2$ for some positive integer $k$. Then $\\sqrt{n}=k$. In this case, $\\sqrt{n}$ is itself a divisor of $n$, since $n = \\sqrt{n} \\cdot \\sqrt{n}$.\n\nWe can partition the set of divisors $D_n$ into three disjoint subsets:\n-   $S_1 = \\{d \\in D_n \\mid d  \\sqrt{n}\\}$\n-   $S_2 = \\{d \\in D_n \\mid d  \\sqrt{n}\\}$\n-   $S_3 = \\{d \\in D_n \\mid d = \\sqrt{n}\\} = \\{\\sqrt{n}\\}$\n\nThe set of all divisors is the union of these subsets: $D_n = S_1 \\cup S_2 \\cup S_3$. The function $\\sigma(n)$ can be expressed as the sum of elements over these subsets:\n$$\n\\sigma(n) = \\sum_{d \\in S_1} d + \\sum_{d \\in S_2} d + \\sum_{d \\in S_3} d\n$$\nThe sum over $S_3$ is simply the single element in the set, which is $\\sqrt{n}$.\n$$\n\\sum_{d \\in S_3} d = \\sqrt{n}\n$$\nThe map $f(d) = n/d$ establishes a one-to-one correspondence between the set $S_1$ and the set $S_2$. For every $d \\in S_1$, we have $f(d) = n/d \\in S_2$. Conversely, for every $d' \\in S_2$, we have $n/d' \\in S_1$. Thus, we can rewrite the sum over $S_2$ as a sum over the elements of $S_1$:\n$$\n\\sum_{d \\in S_2} d = \\sum_{d \\in S_1} \\frac{n}{d}\n$$\nSubstituting these back into the expression for $\\sigma(n)$:\n$$\n\\sigma(n) = \\sum_{d \\in S_1} d + \\sum_{d \\in S_1} \\frac{n}{d} + \\sqrt{n}\n$$\nCombining the sums over $S_1$:\n$$\n\\sigma(n) = \\sum_{d \\in S_1} \\left(d + \\frac{n}{d}\\right) + \\sqrt{n}\n$$\nBy the definition of $S_1$, this is a sum over all divisors $d$ of $n$ that are strictly less than $\\sqrt{n}$. This is the desired decomposition. The sum is taken over pairs of divisors $(d, n/d)$ where $d  \\sqrt{n}$, plus the unique self-paired divisor $\\sqrt{n}$.\n\nNow, we apply this decomposition to compute $\\sigma(36)$.\nHere, $n=36$. Since $36 = 6^2$, it is a perfect square. We have $\\sqrt{n} = \\sqrt{36} = 6$.\nThe formula is:\n$$\n\\sigma(36) = \\sum_{d|36, d6} \\left(d + \\frac{36}{d}\\right) + 6\n$$\nWe need to identify the divisors of $36$ that are strictly less than $6$. The positive divisors of $36$ are $1, 2, 3, 4, 6, 9, 12, 18, 36$.\nThe divisors $d$ satisfying $d|36$ and $d6$ are $d \\in \\{1, 2, 3, 4\\}$.\n\nWe compute the terms in the sum for each of these divisors:\n-   For $d=1$: the term is $1 + \\frac{36}{1} = 1 + 36 = 37$.\n-   For $d=2$: the term is $2 + \\frac{36}{2} = 2 + 18 = 20$.\n-   For $d=3$: the term is $3 + \\frac{36}{3} = 3 + 12 = 15$.\n-   For $d=4$: the term is $4 + \\frac{36}{4} = 4 + 9 = 13$.\n\nThe sum is the total of these values:\n$$\n\\sum_{d|36, d6} \\left(d + \\frac{36}{d}\\right) = 37 + 20 + 15 + 13 = 85\n$$\nFinally, we add the $\\sqrt{n}$ term, which is $6$:\n$$\n\\sigma(36) = 85 + 6 = 91\n$$\nThus, the sum of the positive divisors of $36$ is $91$.", "answer": "$$\n\\boxed{91}\n$$", "id": "3093501"}, {"introduction": "Theoretical formulas are not just for abstract proofs; they are essential for practical, computational explorations in number theory. This hands-on programming challenge asks you to investigate the ratio $\\sigma(n)/n$, which measures the 'abundance' of a number's divisors. You will implement an algorithm based on the formula for $\\sigma(n)$ to empirically find numbers that maximize this ratio, connecting your theoretical knowledge to the fascinating properties of highly composite and superabundant numbers.", "problem": "You are to write a complete program that empirically investigates the extremal behavior of the sum of divisors function. Let $\\sigma(n)$ denote the sum of the positive divisors of a positive integer $n$. The objective is to compute, for several upper bounds $B$, the integer $n$ with $1 \\le n \\le B$ that maximizes the ratio $\\sigma(n)/n$, and to analyze the structure of this maximizer. Your work must be built from first principles: use only the Fundamental Theorem of Arithmetic, the definition of divisors, and the standard geometric-series identity, and derive any intermediate steps you need from these bases. Do not assume or quote special-purpose formulas beyond those foundations.\n\nDefinitions and requirements:\n- The function $\\sigma(n)$ is defined by $\\sigma(n) = \\sum_{d \\mid n} d$, where the sum runs over all positive divisors $d$ of $n$.\n- A prime factorization exists and is unique by the Fundamental Theorem of Arithmetic: every $n \\ge 2$ has a unique decomposition $n = \\prod_{i=1}^{k} p_i^{a_i}$ with $p_1  p_2  \\cdots  p_k$ primes and $a_i \\in \\mathbb{N}$.\n- A primorial is defined as $p_k\\# = \\prod_{i=1}^{k} p_i$ for $k \\ge 1$, where $p_i$ denotes the $i$-th prime.\n- For this problem, say that an integer $n \\ge 2$ is near-primorial if its prime divisor set is exactly $\\{p_1, p_2, \\dots, p_k\\}$ for some $k \\ge 1$ (i.e., it contains every prime up to $p_k$ and no larger primes) and if its exponents are nonincreasing with respect to increasing primes, that is, writing $n = \\prod_{i=1}^{k} p_i^{a_i}$, one has $a_1 \\ge a_2 \\ge \\cdots \\ge a_k \\ge 1$. By convention in this task, $n=1$ is neither primorial nor near-primorial.\n\nTasks:\n- Starting from the definition of $\\sigma(n)$ and the Fundamental Theorem of Arithmetic, derive a computable expression for $\\sigma(n)$ in terms of the prime-power decomposition of $n$. Your derivation must rely only on the facts that (i) the divisors of a prime power are of the form $p^j$ and (ii) the finite geometric series identity. Use the logically necessary step that the sum of divisors is multiplicative over relatively prime inputs, justifying this property from the structure of divisors when $\\gcd(m,n)=1$ (where $\\gcd$ denotes the Greatest Common Divisor (GCD)).\n- Design an algorithm that, for a given bound $B$, computes $\\sigma(n)$ for all $1 \\le n \\le B$ efficiently by factoring each $n$ and applying your derived expression. For comparing ratios $\\sigma(n)/n$ across different $n$ without floating-point ambiguity, compare exact integers via cross-multiplication and use a smallest-$n$ tiebreak when equal ratios occur.\n- For each bound $B$ in the test suite below, determine the smallest $n^\\ast \\in [1,B]$ that maximizes $\\sigma(n^\\ast)/n^\\ast$, and compute the value of $\\sigma(n^\\ast)/n^\\ast$, and classify whether $n^\\ast$ is primorial and whether it is near-primorial (under the definition above).\n\nTest suite:\n- Use the bounds $B \\in \\{1, 10, 100, 1000, 10^4\\}$.\n\nOutput specification:\n- For each bound $B$ in the order listed above, produce an item of the form $[B, n^\\ast, r, \\text{is\\_primorial}, \\text{is\\_near\\_primorial}]$ where:\n  - $B$ and $n^\\ast$ are integers.\n  - $r$ is the real number $\\sigma(n^\\ast)/n^\\ast$, rounded to exactly twelve decimal places in computation but printed as a standard floating-point literal (it may omit trailing zeros).\n  - `is_primorial` and `is_near_primorial` are Boolean values indicating the classifications defined above.\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list of these per-bound items, enclosed in square brackets. Concretely, the program must print a single line like `[[...],[...],[...],[...],[...]]` corresponding to $B \\in \\{1, 10, 100, 1000, 10^4\\}$ in that order.\n\nNumerical units:\n- This is a purely mathematical task; no physical units or angle units are involved.\n\nBoundary and edge cases to consider:\n- The case $B=1$ is a boundary where only $n=1$ is admissible; ensure that the primorial and near-primorial indicators follow the conventions above.\n- Consider the possibility of ties in $\\sigma(n)/n$; break ties by choosing the smallest $n$.\n- Ensure the factorization-based computation and multiplicativity remain correct for prime powers and general composite numbers by construction from first principles.", "solution": "The problem requires finding the integer $n^*$, in a given range $1 \\le n \\le B$, that maximizes the ratio of the sum of its divisors, $\\sigma(n)$, to itself. This requires a multi-step process: first, the derivation of a computable formula for $\\sigma(n)$ from foundational principles; second, the design of an efficient and precise algorithm to identify the maximizer $n^*$; and third, the classification of $n^*$ according to specified number-theoretic properties.\n\n### 1. Derivation of the Expression for $\\sigma(n)$\n\nThe derivation begins with the definition $\\sigma(n) = \\sum_{d|n, d0} d$ and proceeds based on the Fundamental Theorem of Arithmetic, which guarantees a unique prime factorization for any integer $n \\ge 2$.\n\n#### 1.1. Case of a Prime Power\n\nLet $n$ be a power of a single prime, $n = p^a$ for some prime $p$ and integer $a \\ge 1$. The positive divisors of $p^a$ are precisely the powers of $p$ from $p^0$ to $p^a$.\n$$\n\\text{Divisors of } p^a = \\{1, p, p^2, \\ldots, p^a\\}\n$$\nThe sum of these divisors is therefore:\n$$\n\\sigma(p^a) = \\sum_{j=0}^{a} p^j = 1 + p + p^2 + \\cdots + p^a\n$$\nThis is a finite geometric series with first term $1$, ratio $p$, and $a+1$ terms. Using the standard identity for the sum of a finite geometric series, $\\sum_{j=0}^{m} r^j = \\frac{r^{m+1}-1}{r-1}$, we obtain:\n$$\n\\sigma(p^a) = \\frac{p^{a+1}-1}{p-1}\n$$\n\n#### 1.2. Multiplicativity of the $\\sigma$ Function\n\nNext, we establish that $\\sigma$ is a multiplicative function. A function $f$ on the positive integers is multiplicative if $f(mn) = f(m)f(n)$ whenever $\\gcd(m, n) = 1$.\n\nLet $m$ and $n$ be two coprime integers. By the Fundamental Theorem of Arithmetic, their prime factorizations are disjoint. Let $d$ be any divisor of the product $mn$. Any prime factor of $d$ must also be a prime factor of $mn$. Since the sets of prime factors of $m$ and $n$ are disjoint, $d$ can be uniquely written as a product $d = d_m d_n$, where $d_m$ is a divisor of $m$ and $d_n$ is a divisor of $n$. This establishes a bijection between the set of divisors of $mn$ and the Cartesian product of the sets of divisors of $m$ and $n$.\n\nThe sum of divisors of $mn$ can thus be expressed as:\n$$\n\\sigma(mn) = \\sum_{d | mn} d = \\sum_{d_m | m, d_n | n} d_m d_n\n$$\nThis double summation can be factored due to the distributive property of multiplication over addition:\n$$\n\\sigma(mn) = \\left( \\sum_{d_m | m} d_m \\right) \\left( \\sum_{d_n | n} d_n \\right) = \\sigma(m) \\sigma(n)\n$$\nThus, the function $\\sigma(n)$ is multiplicative.\n\n#### 1.3. General Formula for $\\sigma(n)$\n\nLet the prime factorization of an integer $n  1$ be $n = \\prod_{i=1}^{k} p_i^{a_i}$, where $p_i$ are distinct primes and $a_i \\ge 1$. The terms $p_i^{a_i}$ are pairwise coprime. By repeated application of the multiplicative property, we have:\n$$\n\\sigma(n) = \\sigma\\left(\\prod_{i=1}^{k} p_i^{a_i}\\right) = \\prod_{i=1}^{k} \\sigma(p_i^{a_i})\n$$\nSubstituting the formula for a prime power from Section 1.1 yields the general expression for $\\sigma(n)$:\n$$\n\\sigma(n) = \\prod_{i=1}^{k} \\frac{p_i^{a_i+1}-1}{p_i-1}\n$$\n\n### 2. Analysis and Maximization of the Ratio $\\sigma(n)/n$\n\nThe objective is to maximize the ratio $\\sigma(n)/n$. Using the derived formula for $\\sigma(n)$:\n$$\n\\frac{\\sigma(n)}{n} = \\frac{\\prod_{i=1}^{k} \\sigma(p_i^{a_i})}{\\prod_{i=1}^{k} p_i^{a_i}} = \\prod_{i=1}^{k} \\frac{\\sigma(p_i^{a_i})}{p_i^{a_i}}\n$$\nFor a single prime power $p^a$, the ratio is:\n$$\n\\frac{\\sigma(p^a)}{p^a} = \\frac{p^{a+1}-1}{p^a(p-1)} = \\frac{p - p^{-a}}{p-1} = \\frac{p}{p-1}\\left(1 - \\frac{1}{p^{a+1}}\\right)\n$$\nThe full ratio is therefore:\n$$\n\\frac{\\sigma(n)}{n} = \\prod_{i=1}^{k} \\frac{p_i}{p_i-1}\\left(1 - \\frac{1}{p_i^{a_i+1}}\\right)\n$$\nTo maximize this product:\n1.  The term $\\frac{p}{p-1}$ is always greater than $1$ and decreases as $p$ increases. This indicates that maximizers should be constructed from the smallest possible primes ($2, 3, 5, \\dots$).\n2.  The term $\\left(1 - \\frac{1}{p^{a+1}}\\right)$ increases with the exponent $a$. This indicates that for a fixed set of prime factors, higher exponents lead to a larger ratio.\n\nThese properties suggest that numbers with a large $\\sigma(n)/n$ ratio, known as abundant numbers, are typically composed of many small prime factors with potentially high exponents. The maximizers for a given bound $B$ are a specific class of such numbers, known as superabundant numbers.\n\n### 3. Algorithmic Design\n\nFor a given upper bound $B$, the integer $n^*$ maximizing $\\sigma(n)/n$ over $n \\in [1, B]$ can be found through a systematic search.\n\n1.  **Iterative Search**: The algorithm iterates through each integer $n$ from $1$ to $B$. It maintains the current maximizer, $n_{max}$, and the corresponding maximum ratio, $(\\sigma/n)_{max}$.\n\n2.  **Prime Factorization**: For each $n$, its prime factorization, $n = \\prod p_i^{a_i}$, is determined. For the given bounds (up to $10^4$), this can be done efficiently by trial division against a pre-computed list of primes generated by a sieve (e.g., Sieve of Eratosthenes).\n\n3.  **Computation of $\\sigma(n)$**: Using the factorization, $\\sigma(n)$ is calculated with the formula derived in Section 1.3. All calculations should use arbitrary-precision integer arithmetic to avoid overflow and precision loss.\n\n4.  **Ratio Comparison**: To avoid floating-point inaccuracies, the comparison of the current ratio $\\sigma(n)/n$ with the stored maximum ratio $\\sigma(n_{max})/n_{max}$ is performed using integer cross-multiplication. The condition $\\frac{\\sigma(n)}{n}  \\frac{\\sigma(n_{max})}{n_{max}}$ is equivalent to $\\sigma(n) \\cdot n_{max}  \\sigma(n_{max}) \\cdot n$.\n\n5.  **Tie-Breaking**: The problem requires that in case of a tie in the ratio, the smaller $n$ is chosen. By iterating $n$ in ascending order, the first time a maximum ratio is encountered, it is associated with the smallest possible $n$. Any subsequent $n'$ with the same ratio will be larger, so no update is necessary, adhering to the tie-breaking rule.\n\n6.  **Classification of $n^*$**: Once the loop completes and $n^*$ is found, it is classified:\n    *   **Primorial**: An integer $n$ is a primorial if it is the product of the first $k$ primes, $n = p_k\\#$, for some $k \\ge 1$. This is checked by generating primorials $p_1\\#, p_2\\#, \\dots$ until they equal or exceed $n^*$.\n    *   **Near-Primorial**: An integer $n \\ge 2$ is near-primorial if its prime factors are exactly the first $k$ primes, $\\{p_1, \\dots, p_k\\}$, and the corresponding exponents $a_1, \\dots, a_k$ are non-increasing ($a_1 \\ge a_2 \\ge \\dots \\ge a_k \\ge 1$). This is verified by inspecting the computed prime factorization of $n^*$.\n\n### 4. Implementation\n\nThe implemented program follows the described algorithm. It first pre-computes primes up to the maximum bound $B_{max} = 10^4$. It then iterates from $n=1$ to $B_{max}$, calculating $\\sigma(n)$ from its factorization and updating the maximal ratio and corresponding $n^*$ as it goes. At each specified bound $B$ from the test suite, the current champion $n^*$ and its properties are recorded. The final results are assembled into a list of lists and printed in the specified format.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Computes the integer n* that maximizes sigma(n)/n for n = B,\n    for several bounds B.\n    \"\"\"\n\n    def sieve(limit):\n        \"\"\"Generates primes up to a given limit using the Sieve of Eratosthenes.\"\"\"\n        primes = []\n        is_prime = [True] * (limit + 1)\n        if limit = 0:\n            is_prime[0] = False\n        if limit = 1:\n            is_prime[1] = False\n        for p in range(2, limit + 1):\n            if is_prime[p]:\n                primes.append(p)\n                for multiple in range(p * p, limit + 1, p):\n                    is_prime[multiple] = False\n        return primes\n\n    def get_prime_factorization(n, primes):\n        \"\"\"Finds the prime factorization of n using a precomputed list of primes.\"\"\"\n        factors = {}\n        if n == 1:\n            return factors\n        temp_n = n\n        for p in primes:\n            if p * p  temp_n:\n                break\n            if temp_n % p == 0:\n                count = 0\n                while temp_n % p == 0:\n                    count += 1\n                    temp_n //= p\n                factors[p] = count\n        if temp_n  1:\n            factors[temp_n] = 1\n        return factors\n\n    def calculate_sigma_from_factors(factors):\n        \"\"\"Calculates sigma(n) from its prime factorization using integer arithmetic.\"\"\"\n        sigma = 1\n        for p, a in factors.items():\n            # sigma(p^a) = (p^(a+1) - 1) / (p - 1)\n            sigma *= (p**(a + 1) - 1) // (p - 1)\n        return sigma\n\n    def is_primorial(n, primes):\n        \"\"\"Checks if n is a primorial p_k#.\"\"\"\n        if n == 1:\n            return False\n        p_k_hash = 1\n        for p in primes:\n            p_k_hash *= p\n            if p_k_hash == n:\n                return True\n            if p_k_hash  n:\n                return False\n        return False\n\n    def is_near_primorial(n, primes, factors):\n        \"\"\"Checks if n is near-primorial based on the given definition.\"\"\"\n        if n == 1:\n            return False\n        if not factors:\n            return False\n            \n        k = len(factors)\n        p_factors = sorted(factors.keys())\n\n        # Check if prime factors are exactly the first k primes\n        if p_factors != primes[:k]:\n            return False\n\n        # Check if exponents are non-increasing and = 1\n        exponents = [factors[p] for p in primes[:k]]\n        for i in range(len(exponents) - 1):\n            if exponents[i]  exponents[i+1]:\n                return False\n        \n        # The condition a_k = 1 is implicitly true since factors only contains primes with positive exponents.\n        return True\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 100, 1000, 10000]\n    max_b = max(test_cases)\n    \n    # Pre-compute primes for efficiency\n    primes = sieve(max_b)\n    \n    # Cache results to share computation across bounds\n    factorizations = {1: {}}\n    \n    results = []\n    \n    n_star = 1\n    max_ratio_num = 1\n    max_ratio_den = 1\n\n    current_b_idx = 0\n    \n    for n in range(1, max_b + 1):\n        if n  1:\n            factors = get_prime_factorization(n, primes)\n            factorizations[n] = factors\n            sigma_n = calculate_sigma_from_factors(factors)\n            \n            # Compare sigma(n)/n with max_ratio_num/max_ratio_den using integer cross-multiplication\n            if sigma_n * max_ratio_den  max_ratio_num * n:\n                max_ratio_num = sigma_n\n                max_ratio_den = n\n                n_star = n\n        \n        # At each boundary B, record the current champion n_star.\n        if n == test_cases[current_b_idx]:\n            B = test_cases[current_b_idx]\n            \n            r = round(max_ratio_num / max_ratio_den, 12)\n            \n            is_p = is_primorial(n_star, primes)\n            n_star_factors = factorizations[n_star]\n            is_np = is_near_primorial(n_star, primes, n_star_factors)\n            \n            results.append([B, n_star, r, is_p, is_np])\n            \n            current_b_idx += 1\n\n    # Final print statement in the exact required format.\n    # Python's str(list) produces a string with spaces like '[1, 2, 3]',\n    # which is consistent with the provided skeleton code's print format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3093519"}]}