{"hands_on_practices": [{"introduction": "Calculating enormous powers in modular arithmetic, like $3^{2023} \\pmod{17}$, may seem daunting. However, the concept of multiplicative order provides an elegant and highly efficient shortcut. This first exercise demonstrates the practical power of order-based methods by using $\\operatorname{ord}_{17}(3)$ to drastically simplify the computation, contrasting it with more direct approaches [@problem_id:3087787].", "problem": "Let $n=17$ and $a=3$. Define the multiplicative order $\\operatorname{ord}_{n}(a)$ to be the least positive integer $t$ such that $\\gcd(a,n)=1$ and $a^{t}\\equiv 1 \\pmod{n}$. Work within the ring of integers modulo $n$ and the group of units modulo $n$. Using only foundational facts such as: for prime $p$ the nonzero residue classes modulo $p$ form a finite group under multiplication of order $p-1$, and in any finite group the order of an element divides the order of the group, proceed as follows:\n\n- Determine $\\operatorname{ord}_{17}(3)$ by testing appropriate divisors of $\\varphi(17)$, where $\\varphi$ denotes Eulerâ€™s totient function.\n- Use the value of $\\operatorname{ord}_{17}(3)$ to reduce the exponent and compute the residue $3^{2023} \\pmod{17}$.\n- Briefly contrast this order-based reduction with straightforward binary exponentiation (left-to-right repeated squaring without prior exponent reduction) by counting modular multiplications in each approach. In your comparison, count one modular squaring as one modular multiplication, assume reuse of any intermediate powers already computed when advantageous, and take the base-$2$ expansion of the exponent into account.\n\nReport only the final residue class representative in $\\{0,1,\\dots,16\\}$ as your numerical answer. No rounding is required, and no units are involved.", "solution": "The problem is validated as self-contained, scientifically grounded in elementary number theory, and well-posed. All required data and definitions are provided, and the tasks are unambiguous.\n\nThe problem asks for three distinct but related tasks regarding modular arithmetic with modulus $n=17$ and base $a=3$. We will address each in sequence.\n\nFirst, we determine the multiplicative order of $3$ modulo $17$, denoted as $\\operatorname{ord}_{17}(3)$. The problem states we are to work within the group of units modulo $n$. For $n=17$, which is a prime number, the group of units $(\\mathbb{Z}/17\\mathbb{Z})^\\times$ consists of the nonzero residue classes $\\{1, 2, \\dots, 16\\}$ under multiplication. The order of this group is given by Euler's totient function, $|\\left(\\mathbb{Z}/17\\mathbb{Z}\\right)^\\times|=\\varphi(17)$. Since $17$ is prime, $\\varphi(17) = 17 - 1 = 16$.\nThe definition of $\\operatorname{ord}_{n}(a)$ requires that $\\gcd(a,n)=1$. For $a=3$ and $n=17$, we have $\\gcd(3,17)=1$, as required.\nA foundational principle of group theory (Lagrange's Theorem) states that the order of an element must divide the order of the group. Therefore, $\\operatorname{ord}_{17}(3)$ must be a divisor of $16$. The positive divisors of $16$ are $1$, $2$, $4$, $8$, and $16$. To find the order, which is the *least* such positive integer, we test these divisors in increasing order.\nAll congruences are modulo $17$.\n\n*   For the exponent $t=1$: $3^1 \\equiv 3 \\not\\equiv 1 \\pmod{17}$.\n*   For the exponent $t=2$: $3^2 = 9 \\equiv 9 \\not\\equiv 1 \\pmod{17}$.\n*   For the exponent $t=4$: $3^4 = (3^2)^2 \\equiv 9^2 = 81$. Since $81 = 4 \\times 17 + 13$, we have $3^4 \\equiv 13 \\not\\equiv 1 \\pmod{17}$.\n*   For the exponent $t=8$: $3^8 = (3^4)^2 \\equiv 13^2 = 169$. Since $169 = 9 \\times 17 + 16$, we have $3^8 \\equiv 16 \\equiv -1 \\pmod{17}$. This is not $1$.\n\nSince the order is not $1$, $2$, $4$, or $8$, it must be $16$. We can verify this: $3^{16} = (3^8)^2 \\equiv (-1)^2 \\equiv 1 \\pmod{17}$. This is also a direct consequence of Fermat's Little Theorem.\nThus, the multiplicative order of $3$ modulo $17$ is $\\operatorname{ord}_{17}(3) = 16$.\n\nSecond, we use this order to compute the residue of $3^{2023}$ modulo $17$. The property of order allows us to reduce the exponent modulo the order. Specifically, if $t = \\operatorname{ord}_{n}(a)$, then $a^k \\equiv a^{k \\pmod t} \\pmod n$.\nWe need to find the remainder of $2023$ when divided by the order, $16$.\n$$2023 = 16 \\times 126 + 7$$\nThis implies that $2023 \\equiv 7 \\pmod{16}$.\nTherefore, we can simplify the original computation:\n$$3^{2023} \\equiv 3^{16 \\times 126 + 7} \\equiv (3^{16})^{126} \\cdot 3^7 \\pmod{17}$$\nSince $3^{16} \\equiv 1 \\pmod{17}$, this simplifies to:\n$$1^{126} \\cdot 3^7 \\equiv 3^7 \\pmod{17}$$\nNow we compute $3^7 \\pmod{17}$. We can use the intermediate powers calculated previously: $3^1 \\equiv 3$, $3^2 \\equiv 9$, and $3^4 \\equiv 13$.\n$$3^7 = 3^{4+2+1} = 3^4 \\cdot 3^2 \\cdot 3^1$$\n$$3^7 \\equiv 13 \\cdot 9 \\cdot 3 \\pmod{17}$$\nFirst, we compute $13 \\cdot 9 = 117$. Dividing by $17$, $117 = 6 \\times 17 + 15$, so $117 \\equiv 15 \\pmod{17}$.\nNext, we compute $15 \\cdot 3 = 45$. Dividing by $17$, $45 = 2 \\times 17 + 11$, so $45 \\equiv 11 \\pmod{17}$.\nThus, $3^{2023} \\equiv 11 \\pmod{17}$. The requested residue class representative is $11$.\n\nThird, we contrast the number of modular multiplications for the two approaches. A modular squaring is counted as one modular multiplication.\n\n**Approach 1: Order-based reduction.**\n1.  Find the order $\\operatorname{ord}_{17}(3)$. This involved computing $3^2$, $3^4$, and $3^8$.\n    *   $3^2 = 3 \\cdot 3$: $1$ multiplication (a squaring).\n    *   $3^4 = (3^2)^2$: $1$ squaring.\n    *   $3^8 = (3^4)^2$: $1$ squaring.\n    This step requires a total of $3$ modular multiplications.\n2.  Compute $3^7 \\pmod{17}$. We reuse the powers $3^1, 3^2, 3^4$ which were computed.\n    $3^7 = 3^4 \\cdot 3^2 \\cdot 3^1$.\n    *   Let $P = 3^4 \\cdot 3^2$: $1$ multiplication.\n    *   Result $= P \\cdot 3^1$: $1$ multiplication.\n    This step requires $2$ additional modular multiplications.\nThe total number of modular multiplications for the order-based approach is $3 + 2 = 5$.\n\n**Approach 2: Straightforward binary exponentiation (left-to-right repeated squaring).**\nWe compute $3^{2023} \\pmod{17}$ directly.\nThe exponent is $2023$. Its binary representation is found:\n$2023 = 1024 + 512 + 256 + 128 + 64 + 32 + 4 + 2 + 1 = 2^{10} + 2^9 + 2^8 + 2^7 + 2^6 + 2^5 + 2^2 + 2^1 + 2^0$.\nSo, $2023_{10} = 11111100111_2$.\nThe binary representation has a length of $11$ bits (from bit $0$ to bit $10$). The number of squarings required by the algorithm is the highest bit position, which is $10$.\nThe number of multiplications is the number of set bits (ones) in the binary string, minus one for the leading bit. The number of ones (Hamming weight) is $9$. So, the number of multiplications is $9-1=8$.\nThe total number of operations is the sum of squarings and multiplications.\nTotal modular multiplications = $10$ (squarings) $+ 8$ (multiplications) $= 18$.\nThe comparison shows a significant efficiency gain for the order-based method ($5$ multiplications) over straightforward binary exponentiation ($18$ multiplications) for this specific problem.\n\nThe final numerical answer required is the residue of $3^{2023} \\pmod{17}$, which is $11$.", "answer": "$$\n\\boxed{11}\n$$", "id": "3087787"}, {"introduction": "Once we appreciate the utility of an element's order, a natural next step is to explore its algebraic properties. This practice focuses on a fundamental relationship: how the order of an element's power, $\\operatorname{ord}_n(a^k)$, relates to the original element's order, $\\operatorname{ord}_n(a)$. Deriving this formula from first principles will deepen your understanding of the cyclic subgroups generated by elements in $(\\mathbb{Z}/n\\mathbb{Z})^\\times$ [@problem_id:3087796].", "problem": "Let $a$ be an element of the multiplicative group $\\left(\\mathbb{Z}/37\\mathbb{Z}\\right)^{\\times}$ with $\\operatorname{ord}_{37}(a)=36$, where $\\operatorname{ord}_{37}(a)$ denotes the multiplicative order of $a$ modulo $37$, defined as the least positive integer $t$ such that $a^{t}\\equiv 1 \\pmod{37}$. Determine $\\operatorname{ord}_{37}(a^{9})$. Your justification must start from the definition of multiplicative order and use only basic divisibility properties, including the fact that if $a^{n}\\equiv 1 \\pmod{37}$ then $\\operatorname{ord}_{37}(a)$ divides $n$. In your reasoning, clearly derive any general relation you use between $\\operatorname{ord}_{37}(a)$ and $\\operatorname{ord}_{37}(a^{k})$ from first principles, explicitly identifying any role played by the Greatest Common Divisor (GCD). Provide your final answer as a single integer.", "solution": "Let $o = \\operatorname{ord}_{37}(a)$ and $m = \\operatorname{ord}_{37}(a^{9})$. We are given $o=36$. We are tasked with finding the value of $m$.\n\nAs per the explicit instructions, we first derive the general relation between the order of an element $a$ and the order of a power of that element, $a^k$, from first principles. Let the modulus be a general integer $N1$, though in our case $N=37$. Let $o = \\operatorname{ord}_{N}(a)$ and let $m' = \\operatorname{ord}_{N}(a^k)$ for some integer $k$.\n\nBy the definition of order, $m'$ is the least positive integer such that $(a^k)^{m'} \\equiv 1 \\pmod{N}$. This is equivalent to the congruence $a^{km'} \\equiv 1 \\pmod{N}$.\n\nWe are to use the property that if $a^n \\equiv 1 \\pmod{N}$, then $\\operatorname{ord}_{N}(a)$ must divide $n$. Applying this to the congruence $a^{km'} \\equiv 1 \\pmod{N}$, we deduce that $o$ must divide the exponent $km'$.\nSo, we have the condition $o | km'$.\n\nLet $d$ be the greatest common divisor of $k$ and $o$, denoted $d = \\gcd(k,o)$. The definition of GCD allows us to write $k = k'd$ and $o = o'd$ for some integers $k'$ and $o'$ such that $\\gcd(k', o') = 1$. The role of the GCD is to factor out the common part of $k$ and $o$, leaving two coprime integers $k'$ and $o'$.\n\nSubstituting these expressions into our divisibility condition $o | km'$, we get:\n$o'd | (k'd)m'$\n\nSince $d = \\gcd(k,o)$ is a positive integer, we can divide both sides of the divisibility relation by $d$:\n$o' | k'm'$\n\nBy Euclid's lemma, since $\\gcd(k', o') = 1$, it must be that $o'$ divides $m'$. This implies that $m'$ must be a multiple of $o'$. Since $m'$ is defined as the *least positive* integer satisfying its congruence, it must be the smallest positive multiple of $o'$. Let us test if $m' = o'$ is a valid solution.\n\nWe must check if $(a^k)^{o'} \\equiv 1 \\pmod{N}$.\n$(a^k)^{o'} = a^{ko'} = a^{(k'd)o'} = a^{k'(do')} = a^{k'o}$\n\nSince $o = \\operatorname{ord}_{N}(a)$, we have $a^o \\equiv 1 \\pmod{N}$. Therefore:\n$a^{k'o} = (a^o)^{k'} \\equiv 1^{k'} \\equiv 1 \\pmod{N}$\n\nThe condition is satisfied for $m' = o'$. Since we established that any valid $m'$ must be a multiple of $o'$, the least positive value for $m'$ must be $o'$ itself.\nThus, we have derived the general relation:\n$m' = o' = \\frac{o}{d} = \\frac{\\operatorname{ord}_{N}(a)}{\\gcd(k, \\operatorname{ord}_{N}(a))}$\n\nNow, we apply this derived formula to the specific problem given.\nWe have $a \\in \\left(\\mathbb{Z}/37\\mathbb{Z}\\right)^{\\times}$, so the modulus is $N=37$.\nWe are given $\\operatorname{ord}_{37}(a) = 36$.\nWe want to find $\\operatorname{ord}_{37}(a^9)$. In this case, $k=9$.\n\nUsing our formula:\n$\\operatorname{ord}_{37}(a^9) = \\frac{\\operatorname{ord}_{37}(a)}{\\gcd(9, \\operatorname{ord}_{37}(a))}$\n\nSubstituting the given value $\\operatorname{ord}_{37}(a)=36$:\n$\\operatorname{ord}_{37}(a^9) = \\frac{36}{\\gcd(9, 36)}$\n\nTo find the greatest common divisor of $9$ and $36$, we note that $36 = 4 \\times 9$. Thus, $9$ is a divisor of $36$. Therefore, the greatest common divisor is $9$:\n$\\gcd(9, 36) = 9$\n\nSubstituting this value back into the expression:\n$\\operatorname{ord}_{37}(a^9) = \\frac{36}{9} = 4$\n\nThe order of $a^9$ modulo $37$ is $4$.", "answer": "$$\\boxed{4}$$", "id": "3087796"}, {"introduction": "The previous exercises highlight the importance of knowing an element's order, but how do we find it efficiently for any given $a$ and $n$, especially when $n$ is composite? This capstone practice moves from theoretical application to algorithmic design, guiding you to build a robust program that computes $\\operatorname{ord}_n(a)$ for any inputs. You will leverage the Carmichael function, $\\lambda(n)$, to create an efficient algorithm that is a cornerstone of computational number theory [@problem_id:3087777].", "problem": "You are asked to design an algorithm to compute the multiplicative order modulo a composite modulus using order-based methods grounded in fundamental number theory. Let the multiplicative order of an integer $a$ modulo $n$, denoted $\\operatorname{ord}_n(a)$, be defined as the least positive integer $k$ such that $a^k \\equiv 1 \\pmod{n}$, provided that $\\gcd(a,n)=1$, where $\\gcd$ denotes the Greatest Common Divisor (GCD). If $\\gcd(a,n) \\neq 1$, the multiplicative order is undefined in the group of units modulo $n$. In that case, for the purposes of this task, your program must output $0$.\n\nStarting from the fundamental definitions of modular arithmetic and finite groups, and using well-tested facts such as the existence of a universal exponent for the group of units modulo $n$, design and implement an algorithm that computes $\\operatorname{ord}_n(a)$ by leveraging the factorization of the universal exponent of the group of units modulo $n$. Specifically, use the Carmichael function $\\lambda(n)$ (the exponent of the multiplicative group of units modulo $n$) as your universal bound and reduce it by its prime factors to obtain the minimal exponent $d$ such that $a^d \\equiv 1 \\pmod{n}$. Your algorithm must:\n\n- Correctly handle all $n \\geq 1$ and integers $a$.\n- Return $0$ when $\\gcd(a,n) \\neq 1$.\n- Compute $\\lambda(n)$ by decomposing $n$ into prime powers and combining their contributions via the Least Common Multiple (LCM).\n- Factor $\\lambda(n)$ into primes and iteratively divide $\\lambda(n)$ by prime factors where the congruence $a^{\\lambda(n)/q} \\equiv 1 \\pmod{n}$ holds, until no further division is possible.\n- Terminate with the minimal $d$ for which $a^d \\equiv 1 \\pmod{n}$.\n\nProve the correctness and termination of your algorithm in terms of the multiplicative order definition and the universal exponent property of the group of units modulo $n$.\n\nImplement your algorithm as a complete, runnable program. Your program must not read input; instead, it must compute the multiplicative orders for the following test suite of parameter pairs $(a,n)$:\n\n- Test case $1$: $(a,n) = (2,29)$.\n- Test case $2$: $(a,n) = (3,16)$.\n- Test case $3$: $(a,n) = (2,27)$.\n- Test case $4$: $(a,n) = (2,45)$.\n- Test case $5$: $(a,n) = (10,40)$.\n- Test case $6$: $(a,n) = (2,231)$.\n- Test case $7$: $(a,n) = (2,9)$.\n- Test case $8$: $(a,n) = (1,2)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example, if the results are $r_1, r_2, \\dots, r_8$, the output must be of the exact form $\\left[ r_1, r_2, \\dots, r_8 \\right]$ with no additional text. The result for each test case must be an integer, with $0$ used when $\\gcd(a,n) \\neq 1$ as specified above.", "solution": "The problem asks for the design and implementation of an algorithm to compute the multiplicative order of an integer $a$ modulo $n$, denoted $\\operatorname{ord}_n(a)$. This is defined as the smallest positive integer $k$ such that $a^k \\equiv 1 \\pmod{n}$, under the condition that $\\gcd(a, n) = 1$. If this condition is not met, the order is undefined within the group of units modulo $n$, and the specified output is $0$.\n\nThe algorithm's design is based on fundamental principles of group theory and number theory, specifically leveraging the properties of the Carmichael function $\\lambda(n)$.\n\n**Theoretical Foundation**\n\nThe set of integers modulo $n$ that are coprime to $n$ forms a finite abelian group under multiplication, known as the multiplicative group of integers modulo $n$, or the group of units, denoted $(\\mathbb{Z}/n\\mathbb{Z})^\\times$. The order of this group is given by Euler's totient function, $\\phi(n)$.\n\nBy Lagrange's theorem, the order of any element of a finite group must divide the order of the group. Therefore, for any $a$ such that $\\gcd(a,n)=1$, its multiplicative order $\\operatorname{ord}_n(a)$ must divide $\\phi(n)$. This gives us Euler's totient theorem, $a^{\\phi(n)} \\equiv 1 \\pmod{n}$.\n\nA stronger result is provided by the Carmichael function, $\\lambda(n)$. The Carmichael function $\\lambda(n)$ is defined as the smallest positive integer $m$ such that $a^m \\equiv 1 \\pmod{n}$ for all integers $a$ coprime to $n$. In group-theoretic terms, $\\lambda(n)$ is the exponent of the group $(\\mathbb{Z}/n\\mathbb{Z})^\\times$. Consequently, for any single element $a$ in this group, its order must divide the exponent of the group. Thus, we have the crucial property:\n$$ \\operatorname{ord}_n(a) \\mid \\lambda(n) $$\nThis property provides a tighter upper bound on the order than $\\phi(n)$ and is the cornerstone of the specified algorithm.\n\nThe Carmichael function $\\lambda(n)$ is computed based on the prime factorization of $n$:\n1. $\\lambda(1) = 1$.\n2. $\\lambda(2) = 1$.\n3. $\\lambda(4) = 2$.\n4. $\\lambda(2^k) = 2^{k-2}$ for $k \\ge 3$.\n5. $\\lambda(p^k) = p^{k-1}(p-1) = \\phi(p^k)$ for an odd prime $p$.\n6. For $n = p_1^{k_1} p_2^{k_2} \\cdots p_r^{k_r}$, $\\lambda(n) = \\operatorname{lcm}(\\lambda(p_1^{k_1}), \\lambda(p_2^{k_2}), \\ldots, \\lambda(p_r^{k_r}))$.\n\n**Algorithm Design**\n\nThe core principle of the algorithm is to leverage the fact that $\\operatorname{ord}_n(a)$ is a divisor of $\\lambda(n)$. We can find $\\operatorname{ord}_n(a)$ by starting with the candidate $\\lambda(n)$ and systematically removing its prime factors.\n\nLet $L = \\lambda(n)$. Let the prime factorization of $L$ be $L = q_1^{e_1} q_2^{e_2} \\cdots q_m^{e_m}$. The order, $\\operatorname{ord}_n(a)$, must be of the form $q_1^{f_1} q_2^{f_2} \\cdots q_m^{f_m}$, where $0 \\leq f_i \\leq e_i$ for all $i$. The algorithm determines the correct exponents $f_i$.\n\nThe detailed steps are as follows:\n1.  **Input:** Integers $a$ and $n \\geq 1$.\n2.  **GCD Check:** Compute $g = \\gcd(a, n)$. If $g > 1$, the order is undefined in the group of units. Return $0$.\n3.  **Carmichael Function:** Compute $L = \\lambda(n)$. This requires helper functions for prime factorization of $n$, calculating $\\lambda$ for prime powers, and computing the least common multiple (LCM).\n4.  **Order Initialization:** Initialize a candidate for the order, $d = L$.\n5.  **Prime Factorization of Lambda:** Find the set of unique prime factors of $L$, let them be $\\{q_1, q_2, \\ldots, q_m\\}$.\n6.  **Iterative Reduction:** For each prime factor $q_i$ in the set:\n    While $d$ is divisible by $q_i$ and the congruence $a^{d/q_i} \\equiv 1 \\pmod{n}$ holds, update the candidate order by setting $d = d/q_i$. This step uses modular exponentiation for efficient computation of $a^k \\pmod{n}$.\n7.  **Termination:** After iterating through all unique prime factors of $L$, the final value of $d$ is the smallest divisor of $L$ that satisfies the order definition. This final $d$ is $\\operatorname{ord}_n(a)$. Return $d$.\n\n**Proof of Correctness and Termination**\n\n**Correctness:** Let the true order be $k = \\operatorname{ord}_n(a)$. We know that $k \\mid \\lambda(n)$. The algorithm initializes a candidate order $d_0 = \\lambda(n)$, so it is true that $k \\mid d_0$.\nThe algorithm proceeds by generating a sequence of candidates $d_0, d_1, \\ldots, d_{\\text{final}}$. At each step, a candidate $d_j$ is updated to $d_{j+1} = d_j/q$ (where $q$ is a prime) only if $a^{d_j/q} \\equiv 1 \\pmod{n}$. By the fundamental property of order, if $a^m \\equiv 1 \\pmod{n}$, then $k \\mid m$. Therefore, the condition for updating $d_j$ implies that $k \\mid (d_j/q)$. This means that the invariant $k \\mid d_j$ is maintained at every step of the algorithm.\nUpon termination, we have a final candidate $d_{\\text{final}}$ such that $k \\mid d_{\\text{final}}$. The termination condition is that for every prime factor $p$ of $d_{\\text{final}}$, we have $a^{d_{\\text{final}}/p} \\not\\equiv 1 \\pmod{n}$.\nNow, assume for contradiction that $k$ is a proper divisor of $d_{\\text{final}}$. This would mean $d_{\\text{final}} = k \\cdot m$ for some integer $m > 1$. Let $p$ be any prime factor of $m$. Then $p$ is also a prime factor of $d_{\\text{final}}$, and $k$ divides $d_{\\text{final}}/p$. This implies $a^{d_{\\text{final}}/p} \\equiv 1 \\pmod{n}$, which contradicts the termination condition. Therefore, our assumption must be false. The only possibility is $m=1$, which means $d_{\\text{final}} = k$. The algorithm correctly computes the order.\n\n**Termination:** The algorithm's main loop iterates through the set of unique prime factors of $\\lambda(n)$, which is a finite set. The inner `while` loop reduces the candidate order $d$ by dividing it by a prime $q > 1$. Since $d$ is initialized to a finite positive integer $\\lambda(n)$, and it is strictly decreasing in each step of the inner loop, this inner loop must terminate. The total number of divisions is bounded by the sum of the exponents in the prime factorization of $\\lambda(n)$. Thus, the entire algorithm is guaranteed to terminate.\n\nThe following Python code implements this validated algorithm.", "answer": "```python\nimport math\n\n# Although numpy and scipy are permitted by the execution environment, they are not\n# necessary for this number-theoretic problem. This implementation uses only the\n# Python standard library for clarity and efficiency.\n# The `numpy` import is included to exactly match the problem's code structure example.\nimport numpy as np\n\n\ndef gcd(a, b):\n    \"\"\"Computes the greatest common divisor of a and b using the Euclidean algorithm.\"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    \"\"\"Computes the least common multiple of a and b.\"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return abs(a * b) // gcd(a, b)\n\ndef power(base, exp, mod):\n    \"\"\"\n    Computes (base^exp) % mod efficiently using exponentiation by squaring.\n    \"\"\"\n    res = 1\n    base %= mod\n    while exp > 0:\n        if exp % 2 == 1:\n            res = (res * base) % mod\n        base = (base * base) % mod\n        exp //= 2\n    return res\n\ndef get_prime_factorization(num):\n    \"\"\"\n    Returns the prime factorization of num as a dictionary {prime: exponent}.\n    \"\"\"\n    factors = {}\n    d = 2\n    temp_num = num\n    while d * d = temp_num:\n        while temp_num % d == 0:\n            factors[d] = factors.get(d, 0) + 1\n            temp_num //= d\n        d += 1\n    if temp_num > 1:\n        factors[temp_num] = factors.get(temp_num, 0) + 1\n    return factors\n\ndef carmichael_lambda(n):\n    \"\"\"\n    Computes the Carmichael function lambda(n).\n    \"\"\"\n    if n == 1:\n        return 1\n    \n    prime_factors = get_prime_factorization(n)\n    \n    lcm_components = []\n    for p, k in prime_factors.items():\n        if p == 2:\n            if k == 1:\n                lcm_components.append(1)  # lambda(2) = 1\n            elif k == 2:\n                lcm_components.append(2)  # lambda(4) = 2\n            else:\n                lcm_components.append(2**(k - 2))  # lambda(2^k) = 2^(k-2) for k>=3\n        else: # odd prime\n            lcm_components.append((p - 1) * (p**(k - 1))) # lambda(p^k) = phi(p^k)\n\n    result = 1\n    for component in lcm_components:\n        result = lcm(result, component)\n    return result\n\ndef multiplicative_order(a, n):\n    \"\"\"\n    Computes the multiplicative order of a modulo n.\n    Returns 0 if gcd(a, n) != 1.\n    \"\"\"\n    if n == 1:\n        return 1\n        \n    if gcd(a, n) != 1:\n        return 0\n\n    lam = carmichael_lambda(n)\n    \n    # Get unique prime factors of lambda(n)\n    prime_factors_of_lam = list(get_prime_factorization(lam).keys())\n    \n    order = lam\n    for p in prime_factors_of_lam:\n        while order % p == 0 and power(a, order // p, n) == 1:\n            order //= p\n            \n    return order\n\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of parameter pairs (a, n).\n    \"\"\"\n    test_cases = [\n        (2, 29),    # Test case 1\n        (3, 16),    # Test case 2\n        (2, 27),    # Test case 3\n        (2, 45),    # Test case 4\n        (10, 40),   # Test case 5\n        (2, 231),   # Test case 6\n        (2, 9),     # Test case 7\n        (1, 2),     # Test case 8\n    ]\n\n    results = []\n    for a, n in test_cases:\n        result = multiplicative_order(a, n)\n        results.append(result)\n\n    # Print results in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3087777"}]}