{"hands_on_practices": [{"introduction": "Solving large modular exponentiation problems often begins not by tackling the exponent, but by dissecting the modulus. This exercise [@problem_id:3087333] showcases a powerful strategy: using the Chinese Remainder Theorem to break the problem into smaller, parallel congruences. You will then solve these simpler parts using tools like Euler's totient theorem, providing a complete demonstration of how foundational theorems work together to simplify complex calculations.", "problem": "Let $m$ be a positive integer modulus and let $a,b \\in \\mathbb{Z}$. Recall the foundational facts of modular arithmetic: if $a \\equiv b \\pmod{m}$ then for any $c \\in \\mathbb{Z}$ one has $a+c \\equiv b+c \\pmod{m}$ and $ac \\equiv bc \\pmod{m}$, and repeated use of these rules justifies reducing intermediate sums and products modulo $m$ at every step of a computation. Using only these properties and any standard theorems from elementary number theory whose statements you can justify from first principles (for example, Eulerâ€™s theorem and the Chinese remainder theorem), compute the least nonnegative residue of $7^{123}$ modulo $1000$ by systematically reducing intermediate products modulo $1000$ and explaining why each reduction is valid. Your final answer must be a single integer in $\\{0,1,2,\\dots,999\\}$.", "solution": "The problem is to find the least non-negative residue of $7^{123}$ modulo $1000$. Let $x = 7^{123}$. We are asked to compute $x \\pmod{1000}$.\n\nThe modulus is $m = 1000$. We can factor the modulus as $1000 = 10^3 = (2 \\cdot 5)^3 = 2^3 \\cdot 5^3 = 8 \\cdot 125$. The factors $m_1=8$ and $m_2=125$ are relatively prime, i.e., $\\gcd(8, 125)=1$. This structure suggests the use of the Chinese Remainder Theorem (CRT). The CRT provides a method to solve a system of simultaneous congruences. Specifically, if we can find the residues of $7^{123}$ modulo $8$ and modulo $125$, we can combine them to find the unique solution modulo $1000$. The use of CRT is justified because it is a standard theorem of elementary number theory derivable from the basic properties of congruences provided in the problem statement.\n\nWe will solve the congruences $x \\equiv 7^{123} \\pmod{8}$ and $x \\equiv 7^{123} \\pmod{125}$ separately.\n\nFirst, let us compute $7^{123} \\pmod{8}$.\nThe base is $7$. We notice that $7 \\equiv -1 \\pmod{8}$. The problem states that if $a \\equiv b \\pmod{m}$, then $ac \\equiv bc \\pmod{m}$. By repeated application of this property for any positive integer exponent $k$, we can conclude that $a^k \\equiv b^k \\pmod{m}$. Applying this to our case:\n$$7^{123} \\equiv (-1)^{123} \\pmod{8}$$\nSince $123$ is an odd integer, $(-1)^{123} = -1$.\nTherefore,\n$$7^{123} \\equiv -1 \\equiv 7 \\pmod{8}$$\n\nSecond, let us compute $7^{123} \\pmod{125}$.\nThe modulus is $125 = 5^3$. Since $\\gcd(7, 125) = 1$, we can apply Euler's totient theorem. The theorem is justified as it is a direct consequence of Lagrange's theorem applied to the multiplicative group of integers modulo $m$, $(\\mathbb{Z}/m\\mathbb{Z})^\\times$, whose order is given by Euler's totient function, $\\phi(m)$. For any $a$ coprime to $m$, $a^{\\phi(m)} \\equiv 1 \\pmod{m}$.\nFor a prime power $p^k$, the totient function is given by $\\phi(p^k) = p^k - p^{k-1}$. In our case, $m=125=5^3$, so\n$$\\phi(125) = \\phi(5^3) = 5^3 - 5^{3-1} = 125 - 25 = 100$$\nAccording to Euler's theorem, we have $7^{\\phi(125)} \\equiv 7^{100} \\equiv 1 \\pmod{125}$.\nWe can use this result to simplify the exponent $123$.\n$$7^{123} = 7^{100} \\cdot 7^{23}$$\n$$7^{123} \\equiv 1 \\cdot 7^{23} \\equiv 7^{23} \\pmod{125}$$\nThis step is valid because we can reduce factors in a product modulo $m$.\nNow, we must compute $7^{23} \\pmod{125}$. We use the method of exponentiation by squaring, which systematically reduces intermediate products modulo $125$. The validity of reducing at each step is again justified by the property that if $a \\equiv b \\pmod m$ and $c \\equiv d \\pmod m$, then $ac \\equiv bd \\pmod m$.\nLet us compute the required powers of $7$ modulo $125$:\n$$7^1 \\equiv 7 \\pmod{125}$$\n$$7^2 = 49 \\equiv 49 \\pmod{125}$$\n$$7^4 = (7^2)^2 \\equiv 49^2 = 2401 \\pmod{125}$$\nSince $2401 = 19 \\cdot 125 + 26$, we have $7^4 \\equiv 26 \\pmod{125}$.\n$$7^8 = (7^4)^2 \\equiv 26^2 = 676 \\pmod{125}$$\nSince $676 = 5 \\cdot 125 + 51$, we have $7^8 \\equiv 51 \\pmod{125}$.\n$$7^{16} = (7^8)^2 \\equiv 51^2 = 2601 \\pmod{125}$$\nSince $2601 = 20 \\cdot 125 + 101$, we have $7^{16} \\equiv 101 \\pmod{125}$.\nTo compute $7^{23}$, we can decompose the exponent as $23 = 16+4+3$. A more direct path is to note $23=20+3$. Let's compute $7^{20}$:\n$$7^{20} = 7^{16} \\cdot 7^4 \\equiv 101 \\cdot 26 \\pmod{125}$$\nThe product is $101 \\cdot 26 = 2626$. Since $2626 = 21 \\cdot 125 + 1$, we have $7^{20} \\equiv 1 \\pmod{125}$.\nNow we can compute $7^{23}$ as follows:\n$$7^{23} = 7^{20} \\cdot 7^3 \\equiv 1 \\cdot 7^3 \\equiv 7^3 \\pmod{125}$$\nWe compute $7^3$:\n$$7^3 = 7 \\cdot 7^2 = 7 \\cdot 49 = 343$$\nSince $343 = 2 \\cdot 125 + 93$, we have $7^3 \\equiv 93 \\pmod{125}$.\nTherefore, $7^{23} \\equiv 93 \\pmod{125}$. This implies $7^{123} \\equiv 93 \\pmod{125}$.\n\nWe have now established the following system of congruences for $x = 7^{123}$:\n$$\n\\begin{cases}\nx \\equiv 7 \\pmod{8} \\\\\nx \\equiv 93 \\pmod{125}\n\\end{cases}\n$$\nFrom the second congruence, we know that $x$ must be of the form $x = 125k + 93$ for some integer $k$. We substitute this expression into the first congruence:\n$$125k + 93 \\equiv 7 \\pmod{8}$$\nTo solve for $k$, we first reduce the coefficients modulo $8$:\n$125 = 15 \\cdot 8 + 5 \\implies 125 \\equiv 5 \\pmod{8}$.\n$93 = 11 \\cdot 8 + 5 \\implies 93 \\equiv 5 \\pmod{8}$.\nThe congruence becomes:\n$$5k + 5 \\equiv 7 \\pmod{8}$$\nSubtracting $5$ from both sides:\n$$5k \\equiv 2 \\pmod{8}$$\nTo isolate $k$, we need to multiply by the multiplicative inverse of $5$ modulo $8$. By inspection, $5 \\cdot 5 = 25 = 3 \\cdot 8 + 1$, so $5^{-1} \\equiv 5 \\pmod{8}$. Multiplying both sides by $5$:\n$$5 \\cdot (5k) \\equiv 5 \\cdot 2 \\pmod{8}$$\n$$25k \\equiv 10 \\pmod{8}$$\n$$k \\equiv 2 \\pmod{8}$$\nThis means that $k$ can be written in the form $k = 8j + 2$ for some integer $j$. We substitute this back into our expression for $x$:\n$$x = 125(8j + 2) + 93$$\n$$x = 125 \\cdot 8j + 125 \\cdot 2 + 93$$\n$$x = 1000j + 250 + 93$$\n$$x = 1000j + 343$$\nThis implies that $x \\equiv 343 \\pmod{1000}$.\nThe least non-negative residue of $7^{123}$ modulo $1000$ is $343$, which is in the required set $\\{0,1,2,\\dots,999\\}$.", "answer": "$$\\boxed{343}$$", "id": "3087333"}, {"introduction": "While theorems can simplify the landscape, the core of efficient computation lies in the algorithm itself. This practice [@problem_id:3087367] focuses on the \"square-and-multiply\" method, the workhorse of modular exponentiation. By manually tracing the algorithm's steps as dictated by the exponent's binary representation, you will gain a concrete understanding of how it avoids massive intermediate numbers and achieves its speed.", "problem": "In modular arithmetic, repeated exponentiation can be computed efficiently by processing the binary expansion of the exponent and combining modular squaring and modular multiplication. This approach rests on the definition of congruence modulo $n$ and the binary representation of integers, together with the closure of multiplication in the multiplicative group modulo $n$. Using the left-to-right square-and-multiply (LTR) method that scans the binary digits of the exponent from most significant to least significant, compute the residue of $3^{1001}$ modulo $437$. You must explicitly list each squaring and multiply step dictated by the bits of the binary expansion of $1001$, indicating at each step whether a multiply occurs. Express the final residue as an integer in the set $\\{0,1,2,\\dots,436\\}$. No rounding is required.", "solution": "The computation is based on two foundational facts: (i) for integers $a$, $b$, and $n$, if $a \\equiv b \\pmod{n}$ then $a \\cdot c \\equiv b \\cdot c \\pmod{n}$ and $a^{2} \\equiv b^{2} \\pmod{n}$, and (ii) every positive integer admits a unique binary expansion, which allows exponentiation to be decomposed into a sequence of squarings and conditional multiplications.\n\nWe apply the left-to-right square-and-multiply (LTR) method. Write the exponent $e = 1001$ in binary. Compute the binary expansion:\n$$\n1001_{10} = 1111101001_{2},\n$$\nwhose bits from most significant to least significant are $b_{9} = 1$, $b_{8} = 1$, $b_{7} = 1$, $b_{6} = 1$, $b_{5} = 1$, $b_{4} = 0$, $b_{3} = 1$, $b_{2} = 0$, $b_{1} = 0$, $b_{0} = 1$.\n\nThe LTR procedure initializes with the leading bit. Since $b_{9} = 1$, set\n$$\nc \\leftarrow 3 \\bmod 437.\n$$\nFor each subsequent bit $b_{i}$ from $i = 8$ down to $i = 0$, perform a modular squaring $c \\leftarrow c^{2} \\bmod 437$; if $b_{i} = 1$, then also perform a modular multiplication $c \\leftarrow c \\cdot 3 \\bmod 437$.\n\nWe list the steps explicitly:\n\n- Bit $b_{8} = 1$:\n  - Squaring: $c \\leftarrow 3^{2} \\bmod 437 = 9$.\n  - Multiply: $c \\leftarrow 9 \\cdot 3 \\bmod 437 = 27$.\n\n- Bit $b_{7} = 1$:\n  - Squaring: $c \\leftarrow 27^{2} \\bmod 437 = 729 \\bmod 437 = 292$ (since $729 - 437 = 292$).\n  - Multiply: $c \\leftarrow 292 \\cdot 3 \\bmod 437 = 876 \\bmod 437 = 2$ (since $876 - 2 \\cdot 437 = 2$).\n\n- Bit $b_{6} = 1$:\n  - Squaring: $c \\leftarrow 2^{2} \\bmod 437 = 4$.\n  - Multiply: $c \\leftarrow 4 \\cdot 3 \\bmod 437 = 12$.\n\n- Bit $b_{5} = 1$:\n  - Squaring: $c \\leftarrow 12^{2} \\bmod 437 = 144$.\n  - Multiply: $c \\leftarrow 144 \\cdot 3 \\bmod 437 = 432$.\n\n- Bit $b_{4} = 0$:\n  - Squaring: $c \\leftarrow 432^{2} \\bmod 437$. Note $432 \\equiv -5 \\pmod{437}$, so $432^{2} \\equiv (-5)^{2} = 25 \\pmod{437}$. Thus $c \\leftarrow 25$.\n  - No multiply.\n\n- Bit $b_{3} = 1$:\n  - Squaring: $c \\leftarrow 25^{2} \\bmod 437 = 625 \\bmod 437 = 188$ (since $625 - 437 = 188$).\n  - Multiply: $c \\leftarrow 188 \\cdot 3 \\bmod 437 = 564 \\bmod 437 = 127$ (since $564 - 437 = 127$).\n\n- Bit $b_{2} = 0$:\n  - Squaring: $c \\leftarrow 127^{2} \\bmod 437$. Compute $127^{2} = 16129$. Since $437 \\cdot 36 = 15732$, the remainder is $16129 - 15732 = 397$. Thus $c \\leftarrow 397$.\n  - No multiply.\n\n- Bit $b_{1} = 0$:\n  - Squaring: $c \\leftarrow 397^{2} \\bmod 437$. Note $397 \\equiv -40 \\pmod{437}$, so $397^{2} \\equiv (-40)^{2} = 1600 \\pmod{437}$. Since $437 \\cdot 3 = 1311$, the remainder is $1600 - 1311 = 289$. Thus $c \\leftarrow 289$.\n  - No multiply.\n\n- Bit $b_{0} = 1$:\n  - Squaring: $c \\leftarrow 289^{2} \\bmod 437$. Compute $289^{2} = 83521$. Since $437 \\cdot 191 = 83467$, the remainder is $83521 - 83467 = 54$. Thus $c \\leftarrow 54$.\n  - Multiply: $c \\leftarrow 54 \\cdot 3 \\bmod 437 = 162$.\n\nTherefore,\n$$\n3^{1001} \\bmod 437 = 162.\n$$\n\nAs a consistency check using the Chinese Remainder Theorem (CRT), note $437 = 19 \\cdot 23$, with $\\varphi(19) = 18$ and $\\varphi(23) = 22$, and $\\gcd(3,437) = 1$. Then\n$$\n3^{1001} \\equiv 3^{11} \\pmod{19} \\quad \\text{and} \\quad 3^{1001} \\equiv 3^{11} \\pmod{23},\n$$\nsince $1001 \\equiv 11 \\pmod{18}$ and $1001 \\equiv 11 \\pmod{22}$. One finds $3^{11} \\equiv 10 \\pmod{19}$ and $3^{11} \\equiv 1 \\pmod{23}$. Solving\n$$\nx \\equiv 10 \\pmod{19}, \\quad x \\equiv 1 \\pmod{23}\n$$\ngives $x = 162$, which matches the computed residue.\n\nThe LTR computation used $9$ modular squarings (one per non-leading bit) and $6$ modular multiplications (one per bit equal to $1$ among the non-leading bits), illustrating its efficiency tied to the bit-length and Hamming weight of the exponent.", "answer": "$$\\boxed{162}$$", "id": "3087367"}, {"introduction": "An algorithm's true power is realized in its implementation. This final hands-on practice [@problem_id:3087334] challenges you to translate the binary exponentiation algorithm into a runnable program. More than just getting the right answer, you will analyze its performance by counting the exact number of multiplications and reductions, providing a tangible measure of the algorithm's efficiency and a crucial skill in computational number theory.", "problem": "You are to design and implement a complete, runnable program that computes modular exponentiation efficiently using binary exponentiation (also known as exponentiation by squaring) while also accounting for operation costs. The fundamental base for your design is that exponentiation is repeated multiplication in the ring of integers modulo a positive modulus, and that binary representation of an exponent enables a divide-and-conquer strategy via squaring. Specifically, for integers $a$, $e \\ge 0$, and $m \\ge 1$, the quantity $a^e \\bmod m$ can be computed using only modular multiplications guided by the bits of $e$.\n\nYour program must implement the right-to-left binary exponentiation algorithm for computing $a^e \\bmod m$ and must, for each test case, return:\n- the value of $a^e \\bmod m$,\n- the number of modular multiplications performed,\n- the number of modular reductions performed.\n\nCounting rules and conventions that you must follow:\n- Each time the algorithm performs an operation of the form $(x \\cdot y) \\bmod m$ for either squaring or conditional multiply-by-base, count exactly one multiplication and exactly one reduction.\n- Do not count the initial normalization $a \\leftarrow a \\bmod m$ as a reduction for the purposes of this tally.\n- Do not count any final normalization of the accumulator (the result) as an additional reduction.\n- If $m = 1$, return $0$ for the value and $0$ for both counts, because all integers are congruent to $0$ modulo $1$ and no modular multiplications are needed.\n- If $e = 0$, return $1 \\bmod m$ for the value and $0$ for both counts, because no modular multiplications are needed to obtain the identity element.\n\nUse these test cases to verify correctness and robustness, covering a typical large exponent, boundary conditions, and diverse behaviors:\n- $(a,e,m) = (\\,13,\\,1234567,\\,10^9 + 7\\,)$\n- $(a,e,m) = (\\,2,\\,0,\\,10^9 + 7\\,)$\n- $(a,e,m) = (\\,2,\\,1,\\,5\\,)$\n- $(a,e,m) = (\\,123456789,\\,2^{20} - 1,\\,10^9 + 7\\,)$\n- $(a,e,m) = (\\,42,\\,987654321,\\,1\\,)$\n- $(a,e,m) = (\\,10^9 + 6,\\,10^9 + 6,\\,10^9 + 7\\,)$\n\nYour program should produce a single line of output containing the results for these test cases, in order, as a comma-separated list of lists enclosed in square brackets, with no spaces. For each test case, output a list $[v,c_{\\mathrm{mul}},c_{\\mathrm{red}}]$, where $v$ is the integer value of $a^e \\bmod m$, $c_{\\mathrm{mul}}$ is the integer count of modular multiplications, and $c_{\\mathrm{red}}$ is the integer count of modular reductions. For example, the overall format must be:\n$$\n\\bigl[\\,[v_1,c_{\\mathrm{mul},1},c_{\\mathrm{red},1}],\\,[v_2,c_{\\mathrm{mul},2},c_{\\mathrm{red},2}],\\,\\dots\\,\\bigr]\n$$\n\nBeyond computing the values, provide an estimate grounded in first principles for the number of operations required in the first test case, $(\\,13,\\,1234567,\\,10^9 + 7\\,)$, based on the bit-length of the exponent and the number of $1$-bits. Your program should still output the exact counts as defined by the counting rules above; the estimate is a theoretical derivation to be explained in your solution.\n\nNo physical units or angle units are involved in this problem. Express every numerical output as an integer. The final output must conform exactly to the single-line format described above.", "solution": "The problem of computing modular exponentiation, specifically the value of $a^e \\bmod m$ for integers $a$, $e \\ge 0$, and $m \\ge 1$, is fundamental in number theory and computer science, particularly in cryptography. A naive approach of first computing $a^e$ and then taking the result modulo $m$ is computationally infeasible for large exponents $e$, as the intermediate value $a^e$ would be astronomically large. A more efficient method is required that keeps all intermediate results within the ring of integers modulo $m$, $\\mathbb{Z}_m$.\n\nThe specified algorithm, right-to-left binary exponentiation (also known as exponentiation by squaring), provides such an efficient method. The core principle is based on the binary representation of the exponent $e$. Let the binary representation of $e$ be $e = (b_k b_{k-1} \\dots b_1 b_0)_2$, where $b_i \\in \\{0, 1\\}$. This can be written as a sum:\n$$e = \\sum_{i=0}^{k} b_i 2^i$$\nwhere $k = \\lfloor \\log_2 e \\rfloor$. Using this, the expression for $a^e$ can be rewritten:\n$$a^e = a^{\\sum_{i=0}^{k} b_i 2^i} = \\prod_{i=0}^{k} a^{b_i 2^i}$$\nSince $b_i$ is either $0$ or $1$, this product only includes terms where $b_i = 1$:\n$$a^e = \\prod_{i \\text{ s.t. } b_i=1} a^{2^i}$$\nAll computations are performed modulo $m$:\n$$a^e \\bmod m = \\left( \\prod_{i \\text{ s.t. } b_i=1} (a^{2^i} \\bmod m) \\right) \\bmod m$$\nThe algorithm efficiently calculates the necessary terms $a^{2^i} \\bmod m$ by repeated squaring. Let $p_i = a^{2^i} \\bmod m$. Then $p_0 = a \\bmod m$, and for $i > 0$, $p_i = (p_{i-1} \\cdot p_{i-1}) \\bmod m$.\n\nThe right-to-left binary algorithm iterates through the bits of $e$ from the least significant bit ($b_0$) to the most significant bit ($b_k$). It maintains two variables: an accumulator, which will hold the final result, and a power of $a$, which is sequentially squared.\n\nThe algorithm proceeds as follows:\n1.  Handle boundary conditions:\n    - If $m=1$, any integer is congruent to $0 \\pmod 1$. The result is $0$ with $0$ operations.\n    - If $e=0$, $a^0 = 1$. The result is $1 \\pmod m$ (which is $1$ for $m > 1$) with $0$ operations.\n2.  Initialize an accumulator `result` to $1$.\n3.  Initialize a variable `base` to $a \\pmod m$. This initial reduction is not counted per the problem rules.\n4.  Iterate while $e > 0$:\n    a. Check the least significant bit of $e$. If it is $1$ (i.e., $e \\bmod 2 = 1$), update the accumulator: `result` $\\leftarrow$ (`result` $\\cdot$ `base`) $\\bmod m$. According to the rules, this counts as one modular multiplication ($1$ multiplication, $1$ reduction).\n    b. Update the exponent by right-shifting its bits: $e \\leftarrow \\lfloor e/2 \\rfloor$.\n    c. If $e$ is still greater than $0$, update the base by squaring it: `base` $\\leftarrow$ (`base` $\\cdot$ `base`) $\\bmod m$. This counts as one modular multiplication ($1$ multiplication, $1$ reduction). This step is skipped on the final iteration to avoid an unnecessary squaring.\n5.  Return the final value of the accumulator.\n\nThis procedure ensures that the number of modular multiplications is minimized. The number of iterations is equal to the number of bits in $e$, which is $k+1 = \\lfloor \\log_2 e \\rfloor + 1$. A squaring operation occurs in each iteration except the last. A conditional multiplication occurs for each bit $b_i$ that is $1$.\n\nLet's provide the requested theoretical estimate of operations for the first test case, $(a,e,m) = (13, 1234567, 10^9 + 7)$.\nThe exponent is $e = 1234567$.\nThe number of bits in the binary representation of $e$ is $N_{bits} = \\lfloor \\log_2(1234567) \\rfloor + 1$.\n$\\log_2(1234567) \\approx 20.21$, so $\\lfloor \\log_2(1234567) \\rfloor = 20$.\nTherefore, $N_{bits} = 20 + 1 = 21$.\nThe loop will execute $21$ times. The squaring operation `base` $\\leftarrow$ (`base` $\\cdot$ `base`) $\\bmod m$ will be performed $N_{bits} - 1 = 21 - 1 = 20$ times. Each performance adds $1$ to the multiplication count and $1$ to the reduction count.\n\nNext, we count the number of set bits (the Hamming weight) in the binary representation of $e$.\n$1234567_{10} = 100101101011010000111_2$.\nThe number of $1$s is $11$.\nThe conditional multiplication `result` $\\leftarrow$ (`result` $\\cdot$ `base`) $\\bmod m$ is performed once for each set bit. This adds $11$ to the multiplication count and $11$ to the reduction count.\n\nThe total number of modular multiplications is the sum of those from squaring and those from conditional multiplication:\n$c_{\\mathrm{mul}} = (\\text{number of squarings}) + (\\text{number of conditional multiplications}) = (N_{bits} - 1) + (\\text{Hamming weight of } e) = 20 + 11 = 31$.\nSimilarly, the total number of modular reductions is:\n$c_{\\mathrm{red}} = 20 + 11 = 31$.\nThus, the theoretical estimate for this case is that both the number of multiplications and reductions should be $31$. The implemented program will calculate the exact value and confirm these counts.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np # Imported to conform to environment, but not used.\n\ndef solve():\n    \"\"\"\n    Solves the modular exponentiation problem for a set of test cases,\n    counting operations as specified.\n    \"\"\"\n\n    def modular_pow(a, e, m):\n        \"\"\"\n        Computes (a^e) mod m using right-to-left binary exponentiation and\n        counts the number of modular multiplications and reductions.\n\n        Args:\n            a (int): The base.\n            e (int): The exponent.\n            m (int): The modulus.\n\n        Returns:\n            list: A list [value, mul_count, red_count].\n        \"\"\"\n        # Per problem rules for specific boundary conditions.\n        if m == 1:\n            return [0, 0, 0]\n        if e == 0:\n            return [1, 0, 0]\n\n        mul_count = 0\n        red_count = 0\n\n        # Initial normalization of the base (not counted per rules).\n        base = a % m\n        result = 1\n\n        # Use a temporary variable for the exponent to iterate.\n        temp_e = e\n        while temp_e > 0:\n            # If the current least significant bit is 1, multiply the result by the current base.\n            if temp_e  1:\n                result = (result * base) % m\n                # Each (x * y) % m is one multiplication and one reduction.\n                mul_count += 1\n                red_count += 1\n\n            # Right-shift the exponent to process the next bit.\n            temp_e >>= 1\n\n            # If there are more bits to process, square the base for the next iteration.\n            # This avoids an unnecessary final squaring operation.\n            if temp_e > 0:\n                base = (base * base) % m\n                # Each (x * y) % m is one multiplication and one reduction.\n                mul_count += 1\n                red_count += 1\n\n        # Final normalization is not counted per rules.\n        return [result, mul_count, red_count]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (13, 1234567, 10**9 + 7),\n        (2, 0, 10**9 + 7),\n        (2, 1, 5),\n        (123456789, 2**20 - 1, 10**9 + 7),\n        (42, 987654321, 1),\n        (10**9 + 6, 10**9 + 6, 10**9 + 7)\n    ]\n\n    results = []\n    for case in test_cases:\n        a, e, m = case\n        result = modular_pow(a, e, m)\n        results.append(result)\n\n    # Format the final output string exactly as required, with no spaces.\n    # e.g., [[v1,c1,r1],[v2,c2,r2],...]\n    formatted_results = []\n    for res in results:\n        v, cm, cr = res\n        formatted_results.append(f\"[{v},{cm},{cr}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3087334"}]}