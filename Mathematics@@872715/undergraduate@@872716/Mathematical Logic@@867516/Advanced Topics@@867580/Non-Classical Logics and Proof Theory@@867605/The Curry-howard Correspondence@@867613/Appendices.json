{"hands_on_practices": [{"introduction": "The Curry-Howard correspondence reveals that a logical proposition can be seen as a type, and a proof of that proposition is a program that \"inhabits\" the type. This first exercise challenges you to build such a program for a proposition corresponding to the transitivity of implication, a principle better known in programming as function composition. By constructing this term and normalizing its application, you will directly experience the identity between a logical proof and a computational process.", "problem": "Work in the simply typed lambda calculus (STLC) under the Curry–Howard correspondence, where propositions are types and proofs are typed lambda terms. Using only the core typing rules for function types, namely implication introduction and elimination for arrows, and the standard definition of capture-avoiding substitution and $\\beta$-reduction, carry out the following.\n\n1. Construct a closed lambda term $t$ that inhabits the type $(A \\to B) \\to (C \\to A) \\to (C \\to B)$.\n2. Derive the type of $t$ from first principles by a formal typing argument using only the typing rules for function introduction and elimination.\n3. Let $f : A \\to B$, $g : C \\to A$, and $x : C$ be variables. Compute the $\\beta$-normal form of the fully applied term $(t\\ f\\ g\\ x)$ by an explicit sequence of $\\beta$-reductions, justifying each step by the definition of $\\beta$-reduction and capture-avoiding substitution.\n4. Express your final answer as a single closed-form analytic expression for the $\\beta$-normal form of $(t\\ f\\ g\\ x)$.\n\nNo numerical computation is required. The final answer must be a single symbolic expression in standard lambda calculus application notation. Do not include any units. Do not write an equation; give only the final expression.", "solution": "The problem is valid as it is well-posed, scientifically grounded in the formal system of the simply typed lambda calculus, and internally consistent. We proceed with the solution, which is divided into three parts as requested by the problem statement: construction of the term, formal typing derivation, and computation of the normal form.\n\n### 1. Construction of the Lambda Term\n\nThe objective is to construct a closed lambda term $t$ that inhabits, or has, the type $(A \\to B) \\to (C \\to A) \\to (C \\to B)$. This type represents a function that takes three arguments in a curried fashion. We can construct the term by analyzing the structure of the type.\n\nThe type is $(A \\to B) \\to ((C \\to A) \\to (C \\to B))$. This is a function type, so the term $t$ must be a lambda abstraction. We introduce a bound variable, let's call it $f$, for the first argument, which has type $A \\to B$.\n$$t = \\lambda f : A \\to B . \\text{body}_1$$\nThe body of this abstraction, $\\text{body}_1$, must have the type $(C \\to A) \\to (C \\to B)$. This is also a function type, so $\\text{body}_1$ must be another lambda abstraction. We introduce a bound variable $g$ for its argument, which has type $C \\to A$.\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\text{body}_2$$\nThe next body, $\\text{body}_2$, must have the type $C \\to B$. This is again a function type, requiring a third lambda abstraction. We introduce a bound variable $x$ for its argument of type $C$.\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . \\text{body}_3$$\nAt this point, the final body, $\\text{body}_3$, must have type $B$. To construct this term, we can use the variables available in the context:\n- $f : A \\to B$\n- $g : C \\to A$\n- $x : C$\n\nOur goal is to produce an expression of type $B$. The only variable that can produce a value of type $B$ is $f$, through an application. The function $f$ requires an argument of type $A$. We can produce a term of type $A$ by applying the function $g : C \\to A$ to an argument of type $C$. We have such an argument, the variable $x : C$.\nThe application $(g\\ x)$ is well-typed and results in a term of type $A$.\nNow, we can provide this term, $(g\\ x)$, as the argument to $f$. The application $(f\\ (g\\ x))$ is well-typed and results in a term of type $B$. This is exactly what is required for $\\text{body}_3$.\n\nSubstituting this back into our structure, we get the complete closed lambda term:\n$$t = \\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))$$\nThis term represents the composition of two functions.\n\n### 2. Formal Typing Derivation\n\nWe now derive the type of the constructed term $t$ using the core typing rules for implication introduction ($\\to_I$) and implication elimination ($\\to_E$). The rules are:\n- Implication Elimination ($\\to_E$ Rule, or Application): \n$$ \\frac{\\Gamma \\vdash M : T_1 \\to T_2 \\quad \\Gamma \\vdash N : T_1}{\\Gamma \\vdash (M\\ N) : T_2} $$\n- Implication Introduction ($\\to_I$ Rule, or Abstraction): \n$$ \\frac{\\Gamma, v:T_1 \\vdash M : T_2}{\\Gamma \\vdash (\\lambda v:T_1 . M) : T_1 \\to T_2} $$\n\nLet us define the sequence of typing contexts:\n- $\\Gamma_0 = \\emptyset$ (the empty context)\n- $\\Gamma_1 = \\{ f : A \\to B \\}$\n- $\\Gamma_2 = \\{ f : A \\to B, g : C \\to A \\}$\n- $\\Gamma_3 = \\{ f : A \\to B, g : C \\to A, x : C \\}$\n\nThe derivation proceeds as follows, starting from the variables in the innermost context $\\Gamma_3$:\n1. From the context $\\Gamma_3$, we can deduce the types of our variables (by the variable rule, or axiom):\n   - $\\Gamma_3 \\vdash f : A \\to B$\n   - $\\Gamma_3 \\vdash g : C \\to A$\n   - $\\Gamma_3 \\vdash x : C$\n2. Using the $\\to_E$ rule on the terms $g$ and $x$ from step $1$:\n   $$ \\frac{\\Gamma_3 \\vdash g : C \\to A \\quad \\Gamma_3 \\vdash x : C}{\\Gamma_3 \\vdash (g\\ x) : A} $$\n3. Using the $\\to_E$ rule again, this time on the terms $f$ from step $1$ and $(g\\ x)$ from step $2$:\n   $$ \\frac{\\Gamma_3 \\vdash f : A \\to B \\quad \\Gamma_3 \\vdash (g\\ x) : A}{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B} $$\n4. Now, we apply the $\\to_I$ rule to abstract over $x$, discharging the assumption $x:C$ and moving from context $\\Gamma_3$ to $\\Gamma_2$:\n   $$ \\frac{\\Gamma_3 \\vdash (f\\ (g\\ x)) : B}{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B} $$\n5. We apply the $\\to_I$ rule again to abstract over $g$, discharging the assumption $g:C \\to A$ and moving from context $\\Gamma_2$ to $\\Gamma_1$:\n   $$ \\frac{\\Gamma_2 \\vdash (\\lambda x : C . (f\\ (g\\ x))) : C \\to B}{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)} $$\n6. Finally, we apply the $\\to_I$ rule one last time to abstract over $f$, discharging the assumption $f:A \\to B$ and moving from context $\\Gamma_1$ to the empty context $\\Gamma_0$:\n   $$ \\frac{\\Gamma_1 \\vdash (\\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (C \\to A) \\to (C \\to B)}{\\Gamma_0 \\vdash (\\lambda f : A \\to B . \\lambda g : C \\to A . \\lambda x : C . (f\\ (g\\ x))) : (A \\to B) \\to (C \\to A) \\to (C \\to B)} $$\nThis completes the formal proof that the term $t$ has the specified type.\n\n### 3. Computation of the $\\beta$-Normal Form\n\nWe are asked to compute the $\\beta$-normal form of the term $(t\\ f\\ g\\ x)$, where $t$ is the term we constructed, and $f : A \\to B$, $g : C \\to A$, and $x : C$ are given variables.\n\nTo avoid confusion between the bound variables in $t$ and the free variables $f$, $g$, and $x$ we are applying, we will write $t$ with primed bound variables:\n$$t = \\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x'))$$\nThe term to be reduced is $(((t\\ f)\\ g)\\ x)$, since application is left-associative.\n\nThe definition of $\\beta$-reduction is $(\\lambda v. E)\\ M \\to_\\beta E[v \\leftarrow M]$, where $E[v \\leftarrow M]$ denotes the capture-avoiding substitution of $M$ for all free occurrences of $v$ in $E$.\n\n**Step 1: First $\\beta$-reduction**\nThe outermost term is $(t\\ f)$, which is a $\\beta$-redex:\n$$(t\\ f) = (\\lambda f' : A \\to B . \\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))\\ f$$\nWe substitute $f$ for $f'$ in the body of the abstraction:\n$$ \\to_\\beta (\\lambda g' : C \\to A . \\lambda x' : C . (f'\\ (g'\\ x')))[f' \\leftarrow f] $$\n$$ = \\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')) $$\nThe substitution is valid as the variable $f$ has no free variables that could be captured by the binders $\\lambda g'$ or $\\lambda x'$.\nAfter this step, the full expression becomes:\n$$(((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x)$$\n\n**Step 2: Second $\\beta$-reduction**\nThe next redex is the application to $g$:\n$$((\\lambda g' : C \\to A . \\lambda x' : C . (f\\ (g'\\ x')))\\ g)$$\nWe substitute $g$ for $g'$ in the body $\\lambda x' : C . (f\\ (g'\\ x'))$:\n$$ \\to_\\beta (\\lambda x' : C . (f\\ (g'\\ x')))[g' \\leftarrow g] $$\n$$ = \\lambda x' : C . (f\\ (g\\ x')) $$\nAgain, the substitution is capture-avoiding as $g$ has no free variables to be captured by $\\lambda x'$.\nThe full expression is now:\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\n\n**Step 3: Third and Final $\\beta$-reduction**\nThe final expression is a redex:\n$$(\\lambda x' : C . (f\\ (g\\ x')))\\ x$$\nWe substitute $x$ for $x'$ in the body $(f\\ (g\\ x'))$:\n$$ \\to_\\beta (f\\ (g\\ x'))[x' \\leftarrow x] $$\n$$ = (f\\ (g\\ x)) $$\nThe substitution is safe. The resulting term is $(f\\ (g\\ x))$. This term is in $\\beta$-normal form because it is an application whose head, $f$, is a variable, not a lambda abstraction. Therefore, no more $\\beta$-reductions are possible.\n\nThe explicit sequence of reductions is:\n$$((( \\lambda f' . \\lambda g' . \\lambda x' . (f'\\ (g'\\ x')) )\\ f )\\ g )\\ x$$\n$$ \\to_\\beta ((\\lambda g' . \\lambda x' . (f\\ (g'\\ x')))\\ g)\\ x $$\n$$ \\to_\\beta (\\lambda x' . (f\\ (g\\ x')))\\ x $$\n$$ \\to_\\beta (f\\ (g\\ x)) $$\nThe final, $\\beta$-normal form of $(t\\ f\\ g\\ x)$ is $(f\\ (g\\ x))$, which intuitively corresponds to applying the composition of $f$ and $g$ to the argument $x$.", "answer": "$$\\boxed{(f\\ (g\\ x))}$$", "id": "3056165"}, {"introduction": "Moving from abstract propositions to concrete data, this practice demonstrates how the Curry-Howard correspondence applies to familiar structures like natural numbers. You will type-check and evaluate a function involving Peano arithmetic, seeing firsthand how a simple calculation is formally equivalent to the normalization (simplification) of a proof within the calculus. This exercise grounds the abstract theory in a tangible computational task.", "problem": "Consider the Simply Typed Lambda Calculus (STLC) under the Curry-Howard correspondence, where types are propositions and typed terms are proofs. Work with the base type of natural numbers $\\mathbb{N}$ equipped with the constants $0 : \\mathbb{N}$ and $\\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$, and the curried addition operator $\\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N}$. Assume the standard call-by-value small-step operational semantics with $\\beta$-reduction and the usual Peano equations for addition:\n- $\\mathsf{add}(0)(n) \\to n$,\n- $\\mathsf{add}(\\mathsf{succ}(m))(n) \\to \\mathsf{succ}(\\mathsf{add}(m)(n))$.\n\nDefine the term\n$$f := \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$$\nand the argument\n$$a := \\mathsf{succ}(\\mathsf{succ}(0)).$$\n\nUsing the standard typing rules for function types (arrows) and the operational semantics above, first justify that the application $f\\,a$ is well-typed by an instance of arrow-elimination (function application), and then evaluate $f\\,a$ to normal form. Express the final result as an integer. No rounding is required.", "solution": "The problem is valid as it is scientifically grounded in mathematical logic, specifically the Simply Typed Lambda Calculus, and is well-posed with all necessary definitions and rules provided for a unique solution.\n\nThe problem asks for two tasks: first, to justify that the application $f\\,a$ is well-typed, and second, to evaluate it to a normal form.\n\nLet's begin with the first task: type checking. The typing context $\\Gamma$ contains the given types for the constants:\n$\\Gamma = \\{ 0 : \\mathbb{N}, \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}, \\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N} \\}$.\nThe core typing rules of the Simply Typed Lambda Calculus (STLC) that we will use are:\n1.  **Variable**: If $(x:T) \\in \\Gamma$, then $\\Gamma \\vdash x:T$.\n2.  **Application (Arrow-Elimination)**: If $\\Gamma \\vdash t_1 : T_1 \\to T_2$ and $\\Gamma \\vdash t_2 : T_1$, then $\\Gamma \\vdash t_1\\,t_2 : T_2$.\n3.  **Abstraction (Arrow-Introduction)**: If $\\Gamma, x:T_1 \\vdash t:T_2$, then $\\Gamma \\vdash (\\lambda x:T_1.\\,t) : T_1 \\to T_2$.\n\nFirst, we derive the type of the argument $a := \\mathsf{succ}(\\mathsf{succ}(0))$.\n1.  From the context, we have $\\Gamma \\vdash 0 : \\mathbb{N}$ and $\\Gamma \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$.\n2.  By the application rule, $\\Gamma \\vdash \\mathsf{succ}(0) : \\mathbb{N}$.\n3.  Applying the rule again with $\\Gamma \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$ and $\\Gamma \\vdash \\mathsf{succ}(0) : \\mathbb{N}$, we get $\\Gamma \\vdash \\mathsf{succ}(\\mathsf{succ}(0)) : \\mathbb{N}$.\nThus, the type of $a$ is $\\mathbb{N}$.\n\nNext, we derive the type of the function $f := \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$.\nTo do this, we use the abstraction rule. We assume $x$ has type $\\mathbb{N}$ and derive the type of the function body. Let $\\Gamma' = \\Gamma, x:\\mathbb{N}$.\n1.  From $\\Gamma'$, we have $\\Gamma' \\vdash x : \\mathbb{N}$ and $\\Gamma' \\vdash \\mathsf{succ} : \\mathbb{N} \\to \\mathbb{N}$. By application, $\\Gamma' \\vdash \\mathsf{succ}(x) : \\mathbb{N}$. Applying again, $\\Gamma' \\vdash \\mathsf{succ}(\\mathsf{succ}(x)) : \\mathbb{N}$.\n2.  From $\\Gamma'$, we have $\\Gamma' \\vdash \\mathsf{add} : \\mathbb{N} \\to \\mathbb{N} \\to \\mathbb{N}$ and $\\Gamma' \\vdash x : \\mathbb{N}$. By application, the partially applied term has type $\\Gamma' \\vdash \\mathsf{add}(x) : \\mathbb{N} \\to \\mathbb{N}$.\n3.  Now we consider the full body, which is an application: $\\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big)$. Using the results from steps 1 and 2, we have a function of type $\\mathbb{N} \\to \\mathbb{N}$ applied to an argument of type $\\mathbb{N}$. By the application rule, the result has type $\\mathbb{N}$. So, $\\Gamma' \\vdash \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big) : \\mathbb{N}$.\n4.  Since we have shown that assuming $x:\\mathbb{N}$ allows us to derive that the body has type $\\mathbb{N}$ (i.e., $\\Gamma, x:\\mathbb{N} \\vdash \\text{body} : \\mathbb{N}$), we can use the abstraction rule to conclude the type of $f$:\n    $$ \\Gamma \\vdash \\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big) : \\mathbb{N} \\to \\mathbb{N} $$\nThus, the type of $f$ is $\\mathbb{N} \\to \\mathbb{N}$.\n\nFinally, we justify that the application $f\\,a$ is well-typed.\nWe have derived $\\Gamma \\vdash f : \\mathbb{N} \\to \\mathbb{N}$ and $\\Gamma \\vdash a : \\mathbb{N}$.\nAccording to the arrow-elimination rule (function application), since the type of the argument $a$ ($\\mathbb{N}$) matches the input type of the function $f$ (the domain of $\\mathbb{N} \\to \\mathbb{N}$), the application $f\\,a$ is well-typed. The resulting type is the output type of the function, which is $\\mathbb{N}$. So, $\\Gamma \\vdash f\\,a : \\mathbb{N}$.\nIn the Curry-Howard correspondence, this is an instance of Modus Ponens: from a proof of $\\mathbb{N} \\implies \\mathbb{N}$ (term $f$) and a proof of $\\mathbb{N}$ (term $a$), we can construct a proof of $\\mathbb{N}$ (term $f\\,a$).\n\nNow for the second task: evaluation. We need to evaluate $f\\,a$ to normal form using call-by-value small-step semantics.\nThe expression is:\n$$ (\\lambda x:\\mathbb{N}.\\ \\mathsf{add}(x)\\big(\\mathsf{succ}(\\mathsf{succ}(x))\\big))(\\mathsf{succ}(\\mathsf{succ}(0))) $$\nIn call-by-value semantics, the argument must be evaluated to a value before substitution. Here, the argument $a = \\mathsf{succ}(\\mathsf{succ}(0))$ is already a value, as it is composed of constructors applied to the constant $0$. We can represent this value as the Peano numeral for $2$.\n\nWe perform $\\beta$-reduction by substituting the value $\\mathsf{succ}(\\mathsf{succ}(0))$ for every free occurrence of $x$ in the body of the lambda-term:\n$$ \\mathsf{add}(\\mathsf{succ}(\\mathsf{succ}(0)))\\big(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0))))\\big) $$\nTo make the reduction clearer, let's use the notation $S(m)$ for $\\mathsf{succ}(m)$ and use Peano numerals. The term is $\\mathsf{add}(S(S(0)))(S(S(S(S(0)))))$. This corresponds to the operation $\\mathsf{add}(2)(4)$.\n\nWe now apply the given reduction rules for addition:\n-   Rule 1: $\\mathsf{add}(0)(n) \\to n$\n-   Rule 2: $\\mathsf{add}(\\mathsf{succ}(m))(n) \\to \\mathsf{succ}(\\mathsf{add}(m)(n))$\n\nLet's trace the evaluation step-by-step:\n$$ \\mathsf{add}(S(S(0)))(S(S(S(S(0))))) $$\nApplying Rule 2, with $m = S(0)$ and $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{add}(S(0))\\big(S(S(S(S(0))))\\big)\\Big) $$\nApplying Rule 2 again inside the parentheses, with $m = 0$ and $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{succ}\\big(\\mathsf{add}(0)(S(S(S(S(0)))))\\big)\\Big) $$\nNow, we can apply Rule 1 to the innermost term, with $n = S(S(S(S(0))))$:\n$$ \\to \\mathsf{succ}\\Big(\\mathsf{succ}\\big(S(S(S(S(0))))\\big)\\Big) $$\nCombining the applications of $\\mathsf{succ}$, we get:\n$$ \\mathsf{succ}(\\mathsf{succ}(S(S(S(S(0)))))) = \\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0)))))) $$\nThis term is in normal form, as no more reduction rules can be applied. It consists of six applications of the successor function $\\mathsf{succ}$ to the constant $0$. This is the Peano representation of the natural number $6$.\n\nThe problem requires the final result as an integer. Therefore, the normal form $\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(\\mathsf{succ}(0))))))$ corresponds to the integer $6$.", "answer": "$$\\boxed{6}$$", "id": "3056166"}, {"introduction": "A robust logical system must be consistent, and in the world of typed lambda calculus, this consistency is guaranteed by a property called type safety. This thought experiment asks you to investigate what happens when this guarantee is broken by introducing a rule that violates type preservation. By deriving a \"stuck\" term—a program that is ill-formed but cannot be computed further—you will gain a deeper appreciation for why the formal rules of the system are essential for the correspondence to hold.", "problem": "Consider a fragment of the simply typed lambda calculus under the Curry-Howard correspondence (CHC), where types correspond to propositions and terms correspond to proofs. The language has base types $\\mathsf{Bool}$ and $\\mathsf{Nat}$, constants $0$, $\\mathsf{true}$, $\\mathsf{false}$, and a unary constructor $\\mathsf{succ}\\, t$ for natural numbers. Typing rules include $\\Gamma \\vdash 0 : \\mathsf{Nat}$, $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$, $\\Gamma \\vdash \\mathsf{false} : \\mathsf{Bool}$, and if $\\Gamma \\vdash t : \\mathsf{Nat}$ then $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$. Small-step operational semantics includes the standard evaluation context rule for the successor: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. Values are defined inductively by $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$.\n\nAugment the reduction system with a single extra rule that is not type-preserving:\n$$\n0 \\to \\mathsf{true}.\n$$\nUsing only the fundamental definitions above and the widely accepted facts of progress and preservation for the unmodified system as the foundational base, construct a closed, well-typed term that, under the augmented reduction system, reduces to a term that is neither a value nor reducible by any rule (a stuck term). Explain precisely what fails under the CHC and the typing discipline when this non type-preserving rule is added, starting from first principles, and derive the explicit stuck term that results from a single-context-step driven by the added rule. Your final answer must be the explicit stuck term as a single symbolic mathematical expression. No rounding or physical units are required.", "solution": "The problem statement is evaluated as valid. It presents a well-defined formal system based on the simply typed lambda calculus and asks for an analysis of the consequences of augmenting it with a specific, non-type-preserving reduction rule. The problem is scientifically grounded in the principles of type theory and operational semantics, is internally consistent, and requires a rigorous derivation based on the provided definitions.\n\nThe foundation of a reliable typed calculus, and by extension the Curry-Howard correspondence (CHC), rests upon the property of type safety. Type safety is typically established by two key theorems: preservation and progress. The problem posits a system where the standard simply typed lambda calculus, known to possess these properties, is augmented with a rule that undermines this foundation.\n\nLet's state the key principles formally:\n1.  **Preservation (Subject Reduction):** If a term $t$ is well-typed with type $T$ in a context $\\Gamma$ (denoted $\\Gamma \\vdash t : T$) and it reduces in one step to a term $t'$ (denoted $t \\to t'$), then $t'$ must also be well-typed with the same type $T$ (i.e., $\\Gamma \\vdash t' : T$). This theorem ensures that computation preserves the type of an expression.\n2.  **Progress:** For any closed, well-typed term $t$ (i.e., $\\emptyset \\vdash t : T$ for some type $T$), either $t$ is a value or there exists a term $t'$ such that $t \\to t'$. This theorem ensures that a well-typed program never gets \"stuck\" in a non-terminal state.\n\nThe problem introduces the reduction rule $0 \\to \\mathsf{true}$. Let's analyze this rule in the context of the preservation property.\nAccording to the given typing rules:\n-   The term $0$ has the type $\\mathsf{Nat}$, formally $\\Gamma \\vdash 0 : \\mathsf{Nat}$.\n-   The term $\\mathsf{true}$ has the type $\\mathsf{Bool}$, formally $\\Gamma \\vdash \\mathsf{true} : \\mathsf{Bool}$.\n\nThe reduction $0 \\to \\mathsf{true}$ transforms a term of type $\\mathsf{Nat}$ into a term of type $\\mathsf{Bool}$. Since $\\mathsf{Nat} \\neq \\mathsf{Bool}$, this rule explicitly violates the preservation theorem. A single reduction step changes the term's type, which is forbidden in a type-safe system.\n\nThe core of the problem is to demonstrate how this violation of preservation leads to a violation of the progress theorem. We need to construct a closed, well-typed term that reduces to a \"stuck\" state—a term that is not a value and to which no reduction rules apply.\n\nWe can exploit the context-sensitive nature of the given reduction semantics. The problem provides a constructor $\\mathsf{succ}$ and a corresponding evaluation context rule: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. This rule allows reduction to occur on the term immediately inside the $\\mathsf{succ}$ constructor. For a term $\\mathsf{succ}\\, t$ to be well-typed, its argument $t$ must have the type $\\mathsf{Nat}$.\n\nLet us construct a term using this structure.\n1.  Begin with the simplest term of type $\\mathsf{Nat}$: the constant $0$. From the given typing rules, we have $\\emptyset \\vdash 0 : \\mathsf{Nat}$.\n2.  Apply the $\\mathsf{succ}$ constructor to this term. The typing rule for $\\mathsf{succ}$ states that if $\\Gamma \\vdash t : \\mathsf{Nat}$, then $\\Gamma \\vdash \\mathsf{succ}\\, t : \\mathsf{Nat}$. Applying this, since we have $\\emptyset \\vdash 0 : \\mathsf{Nat}$, we can derive $\\emptyset \\vdash \\mathsf{succ}\\, 0 : \\mathsf{Nat}$.\n3.  The term $\\mathsf{succ}\\, 0$ is therefore a closed, well-typed term.\n\nNow, we analyze the reduction of this term in the augmented system.\n-   Our starting term is $\\mathsf{succ}\\, 0$.\n-   The system includes the evaluation context rule for $\\mathsf{succ}$: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$.\n-   The system also includes the non-type-preserving rule $0 \\to \\mathsf{true}$.\n-   We can apply the context rule by letting $t = 0$ and $t' = \\mathsf{true}$. The premise of the context rule, $0 \\to \\mathsf{true}$, is satisfied.\n-   Therefore, we derive the one-step reduction: $\\mathsf{succ}\\, 0 \\to \\mathsf{succ}\\, \\mathsf{true}$.\n\nThe well-typed term $\\mathsf{succ}\\, 0$ reduces to the term $\\mathsf{succ}\\, \\mathsf{true}$. Let us now analyze this resulting term to determine if it is stuck.\n1.  **Is $\\mathsf{succ}\\, \\mathsf{true}$ a value?** The definition of values is given as $v ::= 0 \\mid \\mathsf{succ}\\, v \\mid \\mathsf{true} \\mid \\mathsf{false}$. For a term of the form $\\mathsf{succ}\\, t$ to be a value, $t$ itself must be a value of the form $0$ or $\\mathsf{succ}\\, v'$. In our case, the argument to $\\mathsf{succ}$ is $\\mathsf{true}$. While $\\mathsf{true}$ is a value, it is not a natural number value according to the inductive structure of natural numbers ($v_{nat} ::= 0 \\mid \\mathsf{succ}\\, v_{nat}$). Thus, the term $\\mathsf{succ}\\, \\mathsf{true}$ does not match the pattern for values. It is not a value.\n\n2.  **Can $\\mathsf{succ}\\, \\mathsf{true}$ be reduced?** We must check if any reduction rule applies.\n    -   The only rule applicable to terms beginning with $\\mathsf{succ}$ is the context rule: if $t \\to t'$, then $\\mathsf{succ}\\, t \\to \\mathsf{succ}\\, t'$. For this rule to apply to $\\mathsf{succ}\\, \\mathsf{true}$, the inner term $\\mathsf{true}$ must be able to take a reduction step.\n    -   However, $\\mathsf{true}$ is a value. By definition, values are terminal forms of computation and have no further reductions.\n    -   Since the inner term $\\mathsf{true}$ cannot be reduced, the premise of the context rule is not met.\n    -   No other reduction rules are defined that would match the structure $\\mathsf{succ}\\, \\mathsf{true}$.\n\nThe term $\\mathsf{succ}\\, \\mathsf{true}$ is not a value and no reduction rule can be applied to it. By definition, it is a stuck term.\n\nIn summary, the well-typed term $\\mathsf{succ}\\,0$ reduces to the stuck term $\\mathsf{succ}\\,\\mathsf{true}$. This constitutes a violation of the progress theorem. This failure is a direct consequence of the violation of the preservation theorem by the rule $0 \\to \\mathsf{true}$. Under the Curry-Howard correspondence, this implies a breakdown of logical consistency. The \"proof\" $\\mathsf{succ}\\,0$ of proposition $\\mathsf{Nat}$ is transformed into $\\mathsf{succ}\\,\\mathsf{true}$, which is a nonsensical construction that corresponds to neither a valid proof nor a proposition in the original system. It represents a failure in the proof normalization process, which is the logical counterpart to computation. The derived stuck term is the explicit artifact of this systemic failure.", "answer": "$$\n\\boxed{\\mathsf{succ}\\,\\mathsf{true}}\n$$", "id": "3056147"}]}