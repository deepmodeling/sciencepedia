{"hands_on_practices": [{"introduction": "Before we can prove theorems about the natural numbers, we must first agree on how to represent them within the strict confines of our formal language, $\\mathcal{L}_{PA}$. This first practice is about building these representations from the ground up, using only the constant $0$ and the successor function $S$. By constructing the \"numeral\" for a number like four, you will gain a hands-on feel for how the abstract, inductive structure of the natural numbers is mirrored in the very syntax of Peano Arithmetic [@problem_id:3042003].", "problem": "Consider the first-order language of Peano Arithmetic (PA), denoted by $\\mathcal{L}_{PA}$, whose non-logical symbols are the constant symbol $0$, the unary function symbol $S$, the binary function symbols $+$ and $\\cdot$, and the binary predicate symbol $=$. In this language, a term is formed by the following fundamental syntactic rules: if $c$ is a constant symbol, then $c$ is a term; if $f$ is a $k$-ary function symbol and $t_{1},\\dots,t_{k}$ are terms, then $f(t_{1},\\dots,t_{k})$ is a term; and each variable is a term. A term is called closed if it contains no variables. The intended interpretation of $S$ is the successor operation on $\\mathbb{N}$.\n\nUsing only the formation rules above and the symbols $0$ and $S$, define for each $n \\in \\mathbb{N}$ a closed $\\mathcal{L}_{PA}$-term $\\overline{n}$, called the numeral for $n$, that represents $n$ syntactically within $\\mathcal{L}_{PA}$. Justify that your definition is well-founded by a construction based on the fundamental rules for terms and explain why the resulting $\\overline{n}$ is a closed term for every $n \\in \\mathbb{N}$. Then, compute the closed-form expression for the specific numeral $\\overline{4}$ in terms of $S$ and $0$. Your final answer must be a single symbolic expression, and no rounding is required.", "solution": "The problem statement has been rigorously validated. It is scientifically sound, well-posed, objective, and fully compliant with the established principles of first-order logic and Peano Arithmetic. The premises are accurate, the language is precise, and the task is a standard, fundamental exercise in mathematical logic. The problem is therefore deemed valid.\n\nThe task is to define a syntactic representation within the first-order language of Peano Arithmetic, $\\mathcal{L}_{PA}$, for each natural number $n \\in \\mathbb{N}$. These representations, called numerals and denoted $\\overline{n}$, must be closed terms constructed using only the constant symbol $0$ and the unary function symbol $S$.\n\nThe definition of the numeral $\\overline{n}$ is given by recursion on the natural number $n$. This approach mirrors the inductive structure of the natural numbers themselves, where each number is either $0$ or the successor of another number.\n\nThe formal recursive definition is as follows:\n1.  **Base Case**: For the natural number $0$, the corresponding numeral $\\overline{0}$ is defined to be the constant symbol $0$ from the language $\\mathcal{L}_{PA}$.\n    $$ \\overline{0} := 0 $$\n2.  **Recursive Step**: For any natural number $n$, if the numeral $\\overline{n}$ has been defined, then the numeral for the successor of $n$, denoted $n+1$, is defined by applying the successor function symbol $S$ to the term $\\overline{n}$.\n    $$ \\overline{n+1} := S(\\overline{n}) $$\n\nTo justify that this definition produces a valid term for every $n \\in \\mathbb{N}$, we use the principle of mathematical induction on $n$.\n**Base Case ($n=0$)**: The numeral is $\\overline{0} := 0$. According to the problem's term formation rules, \"if $c$ is a constant symbol, then $c$ is a term.\" Since $0$ is a constant symbol in $\\mathcal{L}_{PA}$, $\\overline{0}$ is a valid term.\n**Inductive Step**: Assume as the inductive hypothesis that for some $k \\in \\mathbb{N}$, the numeral $\\overline{k}$ is a valid term. We must show that $\\overline{k+1}$ is also a valid term. From the recursive definition, $\\overline{k+1} := S(\\overline{k})$. The symbol $S$ is a $1$-ary (unary) function symbol, and by the inductive hypothesis, $\\overline{k}$ is a term. The second rule of term formation states, \"if $f$ is a $k$-ary function symbol and $t_{1},\\dots,t_{k}$ are terms, then $f(t_{1},\\dots,t_{k})$ is a term.\" Applying this rule with $f$ as $S$ and the term $t_1$ as $\\overline{k}$, we conclude that $S(\\overline{k})$ is a valid term. Thus, $\\overline{k+1}$ is a valid term.\nBy the principle of mathematical induction, $\\overline{n}$ is a well-defined term for all $n \\in \\mathbb{N}$.\n\nNext, we must explain why $\\overline{n}$ is a closed term for every $n \\in \\mathbb{N}$. A term is closed if it contains no free variables. We again proceed by induction on $n$.\n**Base Case ($n=0$)**: The term is $\\overline{0} := 0$. A constant symbol is not a variable, so the term $0$ contains no variables. Thus, $\\overline{0}$ is a closed term.\n**Inductive Step**: Assume as the inductive hypothesis that for some $k \\in \\mathbb{N}$, the numeral $\\overline{k}$ is a closed term, meaning it contains no variables. The numeral $\\overline{k+1}$ is constructed as $S(\\overline{k})$. The only new symbols introduced are the function symbol $S$ and parentheses, neither of which are variables. Since the sub-term $\\overline{k}$ is, by hypothesis, free of variables, the entire term $S(\\overline{k})$ must also be free of variables. Therefore, $\\overline{k+1}$ is a closed term.\nBy the principle of mathematical induction, $\\overline{n}$ is a closed term for all $n \\in \\mathbb{N}$.\n\nFinally, we are asked to compute the specific closed-form expression for the numeral $\\overline{4}$. We apply the recursive definition step-by-step:\nThe numeral for $0$ is $\\overline{0} := 0$.\nThe numeral for $1$ is $\\overline{1} := S(\\overline{0}) = S(0)$.\nThe numeral for $2$ is $\\overline{2} := S(\\overline{1}) = S(S(0))$.\nThe numeral for $3$ is $\\overline{3} := S(\\overline{2}) = S(S(S(0)))$.\nThe numeral for $4$ is $\\overline{4} := S(\\overline{3}) = S(S(S(S(0))))$.\nThis final expression is a closed term constructed entirely from the symbols $S$ and $0$, as required.", "answer": "$$\n\\boxed{S(S(S(S(0))))}\n$$", "id": "3042003"}, {"introduction": "Having learned to write terms that represent numbers, it is now vital to grasp one of the most fundamental distinctions in all of logic: the difference between syntax and semantics. A term is a syntactic object—a sequence of symbols—while its meaning, or denotation, is a semantic concept. This exercise challenges you to solidify your understanding of this divide by showing how syntactically different terms, like $S(S(0))$ and $S(0)+S(0)$, can be semantically equal in the standard model of arithmetic [@problem_id:3042049].", "problem": "Consider the standard first-order language of arithmetic $\\mathcal{L}_{\\mathrm{PA}}$ for Peano Arithmetic (PA), whose non-logical symbols are the constant $0$, the unary function symbol $S$, the binary function symbols $+$ and $\\times$, and the equality symbol $=$ intended as identity. In this setting, terms are built from variables, constants, and function symbols according to the usual formation rules. An interpretation provides a domain together with denotations for the non-logical symbols, and a variable assignment maps variables to elements of the domain.\n\nWhich option simultaneously gives a precise definition of syntactic equality of $\\mathcal{L}_{\\mathrm{PA}}$-terms, a precise definition of semantic equality of two terms relative to an interpretation and a variable assignment, and a correct example in the standard model $\\mathbb{N}$ (with $0$ interpreted as the number zero, $S$ as the successor function $n \\mapsto n+1$, and $+$ and $\\times$ as the usual addition and multiplication on $\\mathbb{N}$) where $2$ distinct closed terms denote the same element?\n\nA. Syntactic equality: two terms $t_1$ and $t_2$ are syntactically equal if and only if they are literally the same finite sequence of symbols (symbol-by-symbol identical). Semantic equality: for an interpretation $\\mathcal{M}$ and variable assignment $s$, two terms $t_1$ and $t_2$ are semantically equal if and only if $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$. Example in $\\mathbb{N}$: the terms $S(S(0))$ and $S(0) + S(0)$ both denote $2$.\n\nB. Syntactic equality: two terms $t_1$ and $t_2$ are syntactically equal if and only if PA proves the formula $t_1 = t_2$. Semantic equality: two terms are semantically equal if and only if the formula $t_1 = t_2$ is true in every interpretation of $\\mathcal{L}_{\\mathrm{PA}}$. Example in $\\mathbb{N}$: $S(0)$ and $0$ denote the same element.\n\nC. Syntactic equality: two terms are syntactically equal if they can be made identical by using the axioms of PA for $+$ and $\\times$ (for example, associativity or commutativity) to rewrite them. Semantic equality: for an interpretation $\\mathcal{M}$ and assignment $s$, two terms are semantically equal if PA proves $t_1 = t_2$. Example in $\\mathbb{N}$: $0 + 0$ and $0$ denote the same element.\n\nD. Syntactic equality: two terms are syntactically equal if and only if they are the same sequence of symbols. Semantic equality: for an interpretation $\\mathcal{M}$ and assignment $s$, two terms are semantically equal if and only if their denotations coincide under $\\mathcal{M}$ and $s$. Example in $\\mathbb{N}$: $S(0)$ and $S(0) + S(0)$ denote the same element.\n\nE. Syntactic equality: two terms are syntactically equal if they denote the same element in the standard model $\\mathbb{N}$. Semantic equality: two terms are semantically equal if and only if they are literally identical strings. Example in $\\mathbb{N}$: $0 \\times S(0)$ and $0$ denote the same element.", "solution": "The problem statement must first be validated for its scientific and logical integrity before a solution is attempted.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- The language is the standard first-order language of arithmetic, denoted $\\mathcal{L}_{\\mathrm{PA}}$.\n- The non-logical symbols of $\\mathcal{L}_{\\mathrm{PA}}$ are: the constant symbol $0$, the unary function symbol $S$, the binary function symbols $+$ and $\\times$, and the equality symbol $=$.\n- Terms are constructed according to the standard recursive rules from variables, constants, and function symbols.\n- An interpretation $\\mathcal{M}$ specifies a domain and provides denotations for the non-logical symbols.\n- A variable assignment $s$ maps variables to elements of the domain of an interpretation.\n- The problem concerns the distinction between syntactic equality of terms and semantic equality of terms.\n- The standard model of arithmetic is specified: its domain is the set of natural numbers $\\mathbb{N}$, with $0$ interpreted as the number zero, $S$ as the successor function $n \\mapsto n+1$, and $+$ and $\\times$ as standard addition and multiplication.\n- The question asks for the option that simultaneously provides:\n    1. A precise definition of syntactic equality for $\\mathcal{L}_{\\mathrm{PA}}$-terms.\n    2. A precise definition of semantic equality for two terms relative to an interpretation and a variable assignment.\n    3. A correct example in the standard model $\\mathbb{N}$ of two distinct closed terms that denote the same element.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientifically Grounded:** The problem is firmly rooted in mathematical logic, specifically the model theory of first-order arithmetic. The concepts of language, term, interpretation, syntactic equality, and semantic equality are all standard, well-defined, and fundamental to the field.\n- **Well-Posed:** The problem is unambiguous. It asks to identify the option that correctly states three distinct, verifiable facts. A unique correct answer is expected to exist among the choices.\n- **Objective:** The question uses precise, technical language from formal logic, leaving no room for subjective interpretation.\n- **Completeness and Consistency:** The problem provides all necessary background information regarding the language $\\mathcal{L}_{\\mathrm{PA}}$ and its standard interpretation $\\mathbb{N}$, ensuring it is self-contained. There are no internal contradictions.\n\n**Step 3: Verdict and Action**\nThe problem statement is **valid**. It is a standard and well-posed question in mathematical logic. A solution can be derived by analyzing the correctness of each component in the provided options.\n\n### Solution Derivation\n\nTo correctly evaluate the options, we first state the formal definitions of the concepts in question.\n\n1.  **Syntactic Equality of Terms:** In a formal language, terms are syntactic objects, i.e., finite sequences of symbols. Two terms $t_1$ and $t_2$ are syntactically equal (or identical), often written $t_1 \\equiv t_2$, if and only if they consist of the exact same sequence of symbols in the same order. This is a purely structural comparison of the terms as strings. It is distinct from the notion of being provably equal in a theory like Peano Arithmetic (PA), i.e., $PA \\vdash t_1 = t_2$.\n\n2.  **Semantic Equality of Terms:** Semantics attributes meaning to syntactic objects. Given an $\\mathcal{L}_{\\mathrm{PA}}$-interpretation $\\mathcal{M}$ with domain $D_{\\mathcal{M}}$, and a variable assignment $s: \\text{Variables} \\to D_{\\mathcal{M}}$, every term $t$ is assigned a value, or denotation, $\\llbracket t \\rrbracket^{\\mathcal{M},s} \\in D_{\\mathcal{M}}$. This assignment is defined recursively based on the structure of the term. Two terms $t_1$ and $t_2$ are semantically equal with respect to the interpretation $\\mathcal{M}$ and assignment $s$ if and only if their denotations are the same element in the domain, i.e., $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$.\n\n3.  **Example in the Standard Model $\\mathcal{N}$:** The standard model $\\mathcal{N}$ has the natural numbers $\\mathbb{N} = \\{0, 1, 2, ...\\}$ as its domain. For closed terms (terms without variables), the denotation is independent of any variable assignment. We need to find two syntactically distinct closed terms $t_1$ and $t_2$ such that $\\llbracket t_1 \\rrbracket^{\\mathcal{N}} = \\llbracket t_2 \\rrbracket^{\\mathcal{N}}$.\n\nWith these principles established, we analyze each option.\n\n**A. Syntactic equality: two terms $t_1$ and $t_2$ are syntactically equal if and only if they are literally the same finite sequence of symbols (symbol-by-symbol identical). Semantic equality: for an interpretation $\\mathcal{M}$ and variable assignment $s$, two terms $t_1$ and $t_2$ are semantically equal if and only if $\\llbracket t_1 \\rrbracket^{\\mathcal{M},s} = \\llbracket t_2 \\rrbracket^{\\mathcal{M},s}$. Example in $\\mathbb{N}$: the terms $S(S(0))$ and $S(0) + S(0)$ both denote $2$.**\n- The definition of syntactic equality is correct. It precisely captures the notion of structural identity.\n- The definition of semantic equality is correct. It is the standard model-theoretic definition.\n- The example is also correct. The terms $S(S(0))$ and $S(0)+S(0)$ are syntactically distinct sequences of symbols. In the standard model $\\mathcal{N}$, $\\llbracket S(S(0)) \\rrbracket^{\\mathcal{N}} = S^{\\mathcal{N}}(S^{\\mathcal{N}}(0)) = 1+1 = 2$, and $\\llbracket S(0) + S(0) \\rrbracket^{\\mathcal{N}} = \\llbracket S(0) \\rrbracket^{\\mathcal{N}} +^{\\mathcal{N}} \\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1+1=2$. The two distinct terms denote the same number.\n- **Verdict:** Correct.\n\n**B. Syntactic equality: two terms $t_1$ and $t_2$ are syntactically equal if and only if PA proves the formula $t_1 = t_2$. Semantic equality: two terms are semantically equal if and only if the formula $t_1 = t_2$ is true in every interpretation of $\\mathcal{L}_{\\mathrm{PA}}$. Example in $\\mathbb{N}$: $S(0)$ and $0$ denote the same element.**\n- The definition of syntactic equality is incorrect. It describes PA-provable equality, which is a strictly weaker relation than syntactic identity. For instance, $S(0)+S(0)$ and $S(S(0))$ are provably equal in PA but are not syntactically equal.\n- The definition of semantic equality is incorrect. It defines logical validity of the equality $t_1 = t_2$ (i.e., $\\models t_1 = t_2$), not semantic equality relative to a specific interpretation.\n- The example is incorrect. In $\\mathbb{N}$, $\\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1$ and $\\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$. Since $1 \\neq 0$, they do not denote the same element.\n- **Verdict:** Incorrect.\n\n**C. Syntactic equality: two terms are syntactically equal if they can be made identical by using the axioms of PA for $+$ and $\\times$ (for example, associativity or commutativity) to rewrite them. Semantic equality: for an interpretation $\\mathcal{M}$ and assignment $s$, two terms are semantically equal if PA proves $t_1 = t_2$. Example in $\\mathbb{N}$: $0 + 0$ and $0$ denote the same element.**\n- The definition of syntactic equality is incorrect. This is an informal description of PA-provable equality, not syntactic identity.\n- The definition of semantic equality is incorrect. It erroneously equates truth in a model $\\mathcal{M}$ (a semantic notion) with provability in PA (a syntactic notion).\n- The example is correct: $0+0$ and $0$ are syntactically distinct, and $\\llbracket 0+0 \\rrbracket^{\\mathcal{N}} = \\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$. However, the incorrect definitions invalidate the option.\n- **Verdict:** Incorrect.\n\n**D. Syntactic equality: two terms are syntactically equal if and only if they are the same sequence of symbols. Semantic equality: for an interpretation $\\mathcal{M}$ and assignment $s$, two terms are semantically equal if and only if their denotations coincide under $\\mathcal{M}$ and $s$. Example in $\\mathbb{N}$: $S(0)$ and $S(0) + S(0)$ denote the same element.**\n- The definition of syntactic equality is correct.\n- The definition of semantic equality is correct.\n- The example, however, is incorrect. In $\\mathbb{N}$, $\\llbracket S(0) \\rrbracket^{\\mathcal{N}} = 1$ while $\\llbracket S(0) + S(0) \\rrbracket^{\\mathcal{N}} = 1+1=2$. Since $1 \\neq 2$, they do not denote the same element.\n- **Verdict:** Incorrect.\n\n**E. Syntactic equality: two terms are syntactically equal if they denote the same element in the standard model $\\mathbb{N}$. Semantic equality: two terms are semantically equal if and only if they are literally identical strings. Example in $\\mathbb{N}$: $0 \\times S(0)$ and $0$ denote the same element.**\n- The definition of syntactic equality is incorrect; it confuses a syntactic property with a semantic property in a specific model.\n- The definition of semantic equality is incorrect; it confuses semantic equality with syntactic equality. The two definitions have essentially been swapped and misstated.\n- The example is correct: $0 \\times S(0)$ and $0$ are distinct terms, and $\\llbracket 0 \\times S(0) \\rrbracket^{\\mathcal{N}} = 0 \\times 1 = 0$, while $\\llbracket 0 \\rrbracket^{\\mathcal{N}} = 0$. However, the definitions are fundamentally flawed.\n- **Verdict:** Incorrect.\n\nOnly option A provides correct definitions for both syntactic and semantic equality, along with a correct illustrative example.", "answer": "$$\\boxed{A}$$", "id": "3042049"}, {"introduction": "Formal logic requires not only well-defined syntax and semantics, but also precise rules for manipulating expressions. This practice focuses on one of the most crucial and subtle of these rules: substitution. Naively replacing a variable can lead to an error called \"variable capture,\" where the meaning of a formula is accidentally changed. By working through a concrete example [@problem_id:3041997], you will learn why the careful, capture-avoiding definition of substitution is essential for preserving logical integrity when working with quantifiers.", "problem": "In the single-sorted first-order language of Peano Arithmetic, denoted by $\\mathcal{L}_{PA}$, terms are built from variables, the constant $0$, the unary function symbol $S$, and the binary function symbols $+$ and $\\times$. Formulas are built from atomic formulas of the form $t_1 = t_2$ using the logical connectives and quantifiers. A free occurrence of a variable in a formula is one not bound by a quantifier; a bound occurrence is one that lies within the scope of a quantifier binding that variable. The set of free variables of a term or formula is denoted by $FV(\\,\\cdot\\,)$. Substitution $t[x:=s]$ for terms, and $\\varphi[x:=s]$ for formulas, is intended to replace free occurrences of $x$ by the term $s$, while preserving meaning and avoiding variable capture.\n\nSelect the option that gives a correct, fully capture-avoiding definition of substitution in $\\mathcal{L}_{PA}$, including the quantifier case, and correctly identifies both the naive and the corrected outcome in the following concrete scenario that exhibits potential capture:\n\nConsider the formula $\\varphi \\equiv \\forall y\\,\\bigl(x = y + S(0)\\bigr)$ and the term $s \\equiv y$. What is the correct description of when renaming is required to avoid capture, and what is the correct value of $\\varphi[x:=s]$ under capture-avoiding substitution?\n\nA. For terms: $x[x:=s] = s$, $y[x:=s] = y$ if $y \\neq x$, $0[x:=s] = 0$, $S(t)[x:=s] = S\\bigl(t[x:=s]\\bigr)$, $(t_1 + t_2)[x:=s] = t_1[x:=s] + t_2[x:=s]$, and likewise for $\\times$. For formulas: $(t_1 = t_2)[x:=s] = \\bigl(t_1[x:=s] = t_2[x:=s]\\bigr)$; substitution distributes over $\\neg, \\land, \\lor, \\to$. For quantifiers: $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$ if $y = x$; if $y \\neq x$ and $y \\notin FV(s)$ then $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$; if $y \\neq x$ and $y \\in FV(s)$, pick a fresh $z \\notin FV(\\psi) \\cup FV(s)$ and set $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$. In the scenario $\\varphi \\equiv \\forall y\\,(x = y + S(0))$ and $s \\equiv y$, naive substitution yields $\\forall y\\,(y = y + S(0))$, which captures the free $y$ from $s$; capture-avoiding substitution first renames to a fresh $z$ and yields $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$.\n\nB. Substitution acts uniformly inside all quantifiers without exception: $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$ regardless of whether $y$ equals $x$ or whether $y \\in FV(s)$. In the scenario, $\\varphi[x:=s] = \\forall y\\,(y = y + S(0))$, and no renaming is needed because any variable capture is harmless.\n\nC. Renaming is only required if $x \\in FV(\\psi)$; if $x \\notin FV(\\psi)$ then $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$; otherwise $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$, and there is never a need to consider $FV(s)$. In the scenario, $\\varphi[x:=s] = \\forall y\\,(y = y + S(0))$ and the variable $y$ cannot be captured because $x$ is the variable being substituted.\n\nD. For quantifiers, if $y = x$ then $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$; if $y \\neq x$ and $y \\in FV(s)$ then $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$ but with all occurrences of $y$ in $s$ replaced by a fresh $z$. In the scenario, the corrected result is $\\forall z\\,\\bigl(z = y + S(0)\\bigr)$ because the left-hand side should be renamed to avoid capture.\n\nChoose the single option that is correct in full detail.", "solution": "The problem statement is a valid exercise in first-order logic. It asks for the correct definition of capture-avoiding substitution and its application to a concrete example that illustrates the necessity of care in the quantifier case. The problem is well-posed, scientifically grounded in mathematical logic, and uses precise, objective language. All provided information is standard and sufficient to determine a unique correct answer.\n\nThe core of the problem is the definition of substitution for a formula $\\varphi[x:=s]$, which informally means replacing all free occurrences of the variable $x$ in the formula $\\varphi$ with the term $s$. The definition is recursive on the structure of $\\varphi$. The non-trivial case is when $\\varphi$ is a quantified formula, say $\\forall y\\,\\psi$.\n\nA substitution is said to cause \"variable capture\" if a free variable in the term $s$ becomes bound by a quantifier in $\\varphi$ after substitution. This alters the meaning of the formula and must be avoided. The standard definition of substitution, often called \"capture-avoiding substitution,\" includes a mechanism to prevent this.\n\nLet's analyze the substitution $(\\forall y\\,\\psi)[x:=s]$.\n\n1.  If $x$ is not a free variable in $\\forall y\\,\\psi$, then there are no free occurrences of $x$ to replace. This happens if $x$ is the same as the quantified variable $y$, or if $x$ is not free in the subformula $\\psi$. In this case, the substitution has no effect: $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$.\n\n2.  If $x$ is a free variable in $\\forall y\\,\\psi$ (which implies $x \\neq y$ and $x \\in FV(\\psi)$), we must consider the free variables of the term $s$.\n    a.  **Safe Case**: If the quantified variable $y$ does not appear as a free variable in the term $s$ (i.e., $y \\notin FV(s)$), then no variable in $s$ can be \"captured\" by the quantifier $\\forall y$. The substitution can proceed directly into the subformula: $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,(\\psi[x:=s])$.\n    b.  **Capture Case**: If the quantified variable $y$ *does* appear as a free variable in the term $s$ (i.e., $y \\in FV(s)$), a direct substitution $\\forall y\\,(\\psi[x:=s])$ would be incorrect. The free occurrence of $y$ in $s$ would become bound by $\\forall y$. To avoid this, we must first rename the bound variable $y$ in $\\forall y\\,\\psi$ to a \"fresh\" variable, say $z$. A fresh variable $z$ is one that does not interfere with any other variables, meaning $z \\notin FV(\\forall y\\,\\psi) \\cup FV(s)$. The formula $\\forall y\\,\\psi$ is logically equivalent to $\\forall z\\,(\\psi[y:=z])$. After this renaming, we perform the substitution on the equivalent formula:\n    $(\\forall y\\,\\psi)[x:=s] = (\\forall z\\,(\\psi[y:=z]))[x:=s]$.\n    Since $z$ was chosen to be fresh, $z \\neq x$ and $z \\notin FV(s)$. We are now in the safe case (2a) with respect to the quantifier $\\forall z$. Thus, the substitution proceeds:\n    $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$.\n\nNow, we apply this to the given scenario:\n-   Formula: $\\varphi \\equiv \\forall y\\,\\bigl(x = y + S(0)\\bigr)$. Here, the subformula is $\\psi \\equiv (x = y + S(0))$.\n-   Variable to replace: $x$.\n-   Term to substitute: $s \\equiv y$.\n\nWe want to compute $\\varphi[x:=s] \\equiv (\\forall y\\,\\psi)[x:=y]$.\n-   The variable to be substituted, $x$, is different from the quantified variable, $y$.\n-   $x$ is a free variable in $\\psi$. So, $x \\in FV(\\varphi)$.\n-   The set of free variables in the term $s \\equiv y$ is $FV(s) = \\{y\\}$.\n-   The quantified variable $y$ is in $FV(s)$. This is the capture case (2b).\n\nA **naive substitution** would ignore the capture and incorrectly produce $\\forall y\\,(\\psi[x:=y])$.\n$\\psi[x:=y] \\equiv (x = y+S(0))[x:=y] \\equiv (y = y+S(0))$.\nThe naive result is $\\forall y\\,\\bigl(y = y + S(0)\\bigr)$. This is wrong because the free variable $y$ from the term $s$ has been captured by the quantifier $\\forall y$.\n\nA **correct, capture-avoiding substitution** must first rename the bound variable $y$ in $\\varphi$.\n1.  Choose a fresh variable $z$. To be fresh, $z$ cannot be in $FV(\\varphi) \\cup FV(s) = (FV(\\psi) \\setminus \\{y\\}) \\cup FV(s)$. We have $FV(\\psi) = \\{x, y\\}$ and $FV(s)=\\{y\\}$, so $FV(\\varphi) \\cup FV(s) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}$. Let's choose $z$ such that $z \\neq x$ and $z \\neq y$.\n2.  Rename the bound variable $y$ to $z$ in $\\varphi$. The equivalent formula is $\\varphi' \\equiv \\forall z\\,\\bigl((x = y + S(0))[y:=z]\\bigr) \\equiv \\forall z\\,\\bigl(x = z + S(0)\\bigr)$.\n3.  Perform the substitution $[x:=y]$ on $\\varphi'$.\n    $\\varphi'[x:=y] \\equiv \\bigl(\\forall z\\,(x = z + S(0))\\bigr)[x:=y]$.\n    The quantified variable is now $z$. The term being substituted is $s=y$. Since $z \\notin FV(y)$, this is a safe substitution.\n    The result is $\\forall z\\,\\bigl((x = z + S(0))[x:=y]\\bigr)$.\n    The inner substitution gives $(y = z + S(0))$.\n    The final correct result is $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$.\n\nNow, we evaluate each option.\n\n**Option A:**\n-   **Definition**: The option provides a recursive definition for substitution. For quantifiers, it states:\n    -   If $y=x$, $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\psi$. Correct.\n    -   If $y \\neq x$ and $y \\notin FV(s)$, $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$. Correct (safe case).\n    -   If $y \\neq x$ and $y \\in FV(s)$, pick a fresh $z \\notin FV(\\psi) \\cup FV(s)$ and set $(\\forall y\\,\\psi)[x:=s] = \\forall z\\,\\bigl((\\psi[y:=z])[x:=s]\\bigr)$. Correct (capture case).\n-   **Scenario Analysis**:\n    -   It correctly identifies the naive substitution result as $\\forall y\\,(y = y + S(0))$.\n    -   It correctly identifies the reason for failure as the capture of the free $y$ from $s$.\n    -   It correctly states that capture-avoiding substitution renames the bound variable and correctly provides the final result as $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$.\n-   **Verdict**: This option is entirely correct in its definition and application.\n\n**Option B:**\n-   **Definition**: It proposes that $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$ in all cases. This is the definition of naive substitution, which is known to be flawed.\n-   **Scenario Analysis**: It gives the naive result and claims that variable capture is \"harmless\". This is fundamentally false, as capture changes the logical meaning of the expression.\n-   **Verdict**: Incorrect.\n\n**Option C:**\n-   **Definition**: It claims renaming is never needed based on $FV(s)$. It states that if $x \\in FV(\\psi)$, then $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$. This ignores the crucial condition $y \\in FV(s)$ that signals capture, so the definition is flawed.\n-   **Scenario Analysis**: It provides the naive result and gives a nonsensical justification: \"the variable $y$ cannot be captured because $x$ is the variable being substituted.\" This shows a complete misunderstanding of what variable capture is. The variable being captured is a free variable from the term being substituted ($s$), not the variable being replaced ($x$).\n-   **Verdict**: Incorrect.\n\n**Option D:**\n-   **Definition**: It incorrectly states that for $y=x$, $(\\forall y\\,\\psi)[x:=s] = \\forall y\\,\\bigl(\\psi[x:=s]\\bigr)$. If $y=x$, all occurrences of $x$ in $\\psi$ are bound, so substitution of free occurrences has no effect. The result should be $\\forall y\\,\\psi$. The proposed rule is ill-defined. The second part of the rule suggests renaming variables in the term $s$, which is a non-standard (though possible) approach, but the description is confusing.\n-   **Scenario Analysis**: It gives the result $\\forall z\\,\\bigl(z = y + S(0)\\bigr)$. This is incorrect. The correct result is $\\forall z\\,\\bigl(y = z + S(0)\\bigr)$, where $y$ remains a free variable. Option D's result has swapped the roles of the constants and variables. The justification \"the left-hand side should be renamed\" is also confused; it is the *bound variable of the quantifier* that must be renamed to avoid capture, not a part of the expression being substituted into.\n-   **Verdict**: Incorrect.\n\nBased on this analysis, only Option A provides a correct definition and correctly applies it to the scenario.", "answer": "$$\\boxed{A}$$", "id": "3041997"}]}