{"hands_on_practices": [{"introduction": "The concept of representability in Peano Arithmetic ($PA$) begins with understanding how the theory handles its own built-in functions, like multiplication. This exercise explores how $PA$'s axioms, particularly the recursive definitions for multiplication and the Induction Schema, are used to formally prove basic arithmetic facts and the totality of the multiplication function. By working directly from the axioms, you can see how representability is a direct consequence of the way functions are defined in the system.", "problem": "Work in first-order Peano Arithmetic (PA) over the language with symbols $0$, $S$, $+$, $\\cdot$, and $=$, and the full Induction Schema for all formulas $\\varphi(y)$. Recall the following foundational base:\n- The axioms for equality and the usual rules of first-order logic.\n- The successor axioms: $\\forall x\\, (S(x) \\neq 0)$ and $\\forall x\\, \\forall y\\, (S(x)=S(y) \\rightarrow x=y)$.\n- The axioms for addition: $\\forall x\\, (x+0=x)$ and $\\forall x\\, \\forall y\\, (x+S(y)=S(x+y))$.\n- The axioms for multiplication: $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$.\n- The Induction Schema: for each formula $\\varphi(y)$, the axiom $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$.\n\nNumerals are terms of the form $\\overline{n}=S^n(0)$ for $n\\in \\mathbb{N}$. A function $f:\\mathbb{N}^k\\to \\mathbb{N}$ is (strongly) representable in PA if there is a formula $\\varphi(\\vec{x},z)$ such that PA proves $\\forall \\vec{x}\\, \\exists ! z\\, \\varphi(\\vec{x},z)$ and, for each $\\vec{n}$, PA proves $\\varphi(\\overline{\\vec{n}},\\overline{f(\\vec{n})})$.\n\nUsing only these foundations, select all correct statements below about what PA proves and how the multiplication axioms yield multiplication facts for numerals:\n\nA. PA proves $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$. Consequently, PA proves $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$.\n\nB. For each $m,n\\in \\mathbb{N}$, PA proves $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$ by a derivation that can be constructed by iterating the defining equations, and the length of such a derivation is bounded by a polynomial in $m+n$.\n\nC. Even if no axioms for $\\cdot$ are postulated, PA (with only the axioms for $+$ and the Induction Schema) proves $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$.\n\nD. From the given axioms for $+$ and $\\cdot$, PA proves $\\forall x\\, (x\\cdot S(0)=x)$ and, more generally, for each fixed numeral $\\overline{n}$, PA proves $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$.\n\nE. Since multiplication is a computable (indeed, primitive recursive) function, there exists a formula $\\varphi(x,y,z)$ in the language of PA that represents the graph of multiplication in PA in the strong sense: PA proves $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$, and for all $m,n\\in \\mathbb{N}$, PA proves $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$.\n\nChoose all that apply: A, B, C, D, E.", "solution": "The problem statement provides a correct and standard presentation of first-order Peano Arithmetic (PA) and the definition of strong representability of a function. The problem is scientifically grounded, well-posed, and objective. It is a valid problem in mathematical logic. I will proceed to analyze each option.\n\n### Analysis of Option A\nStatement A: `PA proves $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$. Consequently, PA proves $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$.`\n\nThe first part of the statement, \"PA proves $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$,\" is true by definition, as these are listed as axioms of PA in the problem description.\n\nThe second part claims, as a consequence, that PA proves the totality and single-valuedness of the multiplication function, formally stated as $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$. Let's verify this claim. The proof must be conducted within PA.\n\n1.  **Existence**: We need to prove $\\forall x\\, \\forall y\\, \\exists z\\, (z = x\\cdot y)$. We fix an arbitrary $x$ and use the Induction Schema on the variable $y$. Let $\\varphi(y)$ be the formula $\\exists z\\, (z = x\\cdot y)$.\n    *   **Base Case ($y=0$):** We must prove $\\varphi(0)$, which is $\\exists z\\, (z = x\\cdot 0)$. From the axiom $\\forall x\\, (x\\cdot 0=0)$, we have $x\\cdot 0=0$. By the rules of first-order logic (existential generalization), from $x\\cdot 0=0$ we can deduce $\\exists z\\, (z=x\\cdot 0)$. Thus, PA proves $\\varphi(0)$.\n    *   **Inductive Step:** We assume $\\varphi(y)$ holds for an arbitrary $y$, i.e., the induction hypothesis is $\\exists z\\, (z = x\\cdot y)$. Let's call such a $z$ by the name $w$, so $w = x\\cdot y$. We must prove $\\varphi(S(y))$, which is $\\exists z'\\, (z' = x\\cdot S(y))$.\n        By the second multiplication axiom, we have $x\\cdot S(y) = x\\cdot y + x$.\n        Using the induction hypothesis, we can substitute $w$ for $x\\cdot y$, yielding $x\\cdot S(y) = w+x$.\n        The function $+$ is also total in PA (provable by a similar induction), so for any $w$ and $x$, there exists a number equal to their sum, $w+x$. Let this number be $v$. So, $v=w+x$.\n        Therefore, $v = x\\cdot S(y)$. By existential generalization, we have $\\exists v\\, (v = x\\cdot S(y))$, which is $\\varphi(S(y))$.\n    *   By the Induction Schema, $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$, we conclude that PA proves $\\forall y\\, \\varphi(y)$, which is $\\forall y\\, \\exists z\\, (z=x\\cdot y)$. Since $x$ was arbitrary, we can universally generalize to get $\\forall x\\, \\forall y\\, \\exists z\\, (z=x\\cdot y)$.\n\n2.  **Uniqueness**: We need to prove that for any $x, y$, if $z_1 = x\\cdot y$ and $z_2 = x\\cdot y$, then $z_1=z_2$. This is a direct consequence of the properties of equality (specifically, transitivity: if $z_1 = x \\cdot y$ and $x \\cdot y = z_2$, then $z_1 = z_2$). The uniqueness part is thus provable from the axioms of equality.\n\nCombining existence and uniqueness, PA proves $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$. The word \"consequently\" is appropriate in the context of working within PA, as the proof relies on the given axioms plus the Induction Schema.\n\nVerdict for A: **Correct**.\n\n### Analysis of Option B\nStatement B: `For each $m,n\\in \\mathbb{N}$, PA proves $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$ by a derivation that can be constructed by iterating the defining equations, and the length of such a derivation is bounded by a polynomial in $m+n$.`\n\nThis statement makes two claims.\n1.  **Provability by iteration**: PA proves $\\overline{m}\\cdot \\overline{n}=\\overline{m \\cdot n}$ for any concrete numerals $\\overline{m}$ and $\\overline{n}$. The proof proceeds by recursion on $\\overline{n}$.\n    *   If $n=0$, we prove $\\overline{m}\\cdot\\overline{0}=\\overline{0}$, which is $\\overline{m}\\cdot 0=0$. This is an instance of the axiom $\\forall x(x\\cdot 0=0)$.\n    *   If $n>0$, so $\\overline{n}=S(\\overline{n-1})$, we have $\\overline{m}\\cdot S(\\overline{n-1}) = \\overline{m}\\cdot\\overline{n-1} + \\overline{m}$. By (meta-)induction, we assume we can prove $\\overline{m}\\cdot\\overline{n-1} = \\overline{m(n-1)}$. So we have $\\overline{m(n-1)} + \\overline{m}$. A similar iterative process on the definition of addition proves that $\\overline{a}+\\overline{b}=\\overline{a+b}$ in a number of steps proportional to $b$. Here, we need to prove $\\overline{m(n-1)} + \\overline{m} = \\overline{m(n-1)+m} = \\overline{mn}$. This requires $m$ applications of the successor rule for addition. The overall process thus \"iterates the defining equations\".\n2.  **Proof length**: The number of main recursive steps for multiplication is $n$. Each step involves an addition $\\overline{a}+\\overline{m}$, which requires $m$ recursive steps of addition. The total number of applications of the recursive axioms is on the order of $O(m \\cdot n)$. The numerals themselves, e.g., $\\overline{m \\cdot n}$, have length (number of symbols) proportional to $m \\cdot n$. The total length of the proof (sum of lengths of all formulas) will be a polynomial function of $m$ and $n$. Any polynomial in two variables $m, n$ is bounded by a polynomial in their sum $m+n$, since $m \\le m+n$ and $n \\le m+n$. Thus, a term like $m^a n^b$ is bounded by $(m+n)^a (m+n)^b = (m+n)^{a+b}$. This is a known result in proof theory regarding the efficiency of formal proofs for quantifier-free statements in PA.\n\nVerdict for B: **Correct**.\n\n### Analysis of Option C\nStatement C: `Even if no axioms for $\\cdot$ are postulated, PA (with only the axioms for $+$ and the Induction Schema) proves $\\forall x\\, (x\\cdot 0=0)$ and $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$.`\n\nThis statement is false. If the symbol $\\cdot$ is included in the language but no axioms are provided to govern its behavior, it is an uninterpreted function symbol. It is possible to construct a model of the remaining PA axioms (for $0, S, +$ and induction) where the interpretation of $\\cdot$ does not satisfy the stated properties.\n\nFor example, let the universe be $\\mathbb{N}$, with $0, S, +$ interpreted as usual. Let the interpretation of the symbol $\\cdot$, denoted $f(x,y) = x \\cdot y$, be the constant function $f(x,y)=1$ for all $x,y \\in \\mathbb{N}$. This structure is a model for PA without multiplication axioms. In this model, the statement $\\forall x\\, (x\\cdot 0=0)$ translates to \"for all $x \\in \\mathbb{N}, f(x,0)=0$\", which means \"$1=0$\". This is false, and in fact contradicts the PA axiom $\\forall x(S(x) \\neq 0)$, from which $\\overline{1} \\neq 0$ is provable.\n\nSince we have found a model of the reduced theory where the multiplication axioms are false, they cannot be theorems of that theory. The axioms for multiplication are not redundant.\n\nVerdict for C: **Incorrect**.\n\n### Analysis of Option D\nStatement D: `From the given axioms for $+$ and $\\cdot$, PA proves $\\forall x\\, (x\\cdot S(0)=x)$ and, more generally, for each fixed numeral $\\overline{n}$, PA proves $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$.`\n\nFirst part: Prove $\\forall x\\, (x\\cdot S(0)=x)$.\nNote that $S(0)$ is the numeral $\\overline{1}$.\nFrom the multiplication axiom $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$, we instantiate $y$ with $0$: PA proves $\\forall x\\, (x\\cdot S(0)=x\\cdot 0 + x)$.\nFrom the other multiplication axiom $\\forall x\\, (x\\cdot 0=0)$, we substitute to get: PA proves $\\forall x\\, (x\\cdot S(0)=0 + x)$.\nWe now need to show that PA proves $\\forall x\\,(0+x=x)$. This is the left-identity property for addition. It is not an axiom but is provable by induction on $x$.\nLet $\\varphi(x)$ be $0+x=x$.\n*   **Base Case ($x=0$):** $\\varphi(0)$ is $0+0=0$. This follows from the axiom $\\forall z(z+0=z)$ by setting $z=0$.\n*   **Inductive Step:** Assume $\\varphi(x)$, i.e., $0+x=x$. We must show $\\varphi(S(x))$, i.e., $0+S(x)=S(x)$. By the second addition axiom $\\forall z\\forall y(z+S(y)=S(z+y))$, setting $z=0, y=x$, we get $0+S(x)=S(0+x)$. By the induction hypothesis, $0+x=x$, so $S(0+x)=S(x)$. Thus, $0+S(x)=S(x)$.\nBy induction, PA proves $\\forall x\\, (0+x=x)$. Substituting this into our earlier result, PA proves $\\forall x\\, (x\\cdot S(0)=x)$.\n\nSecond part: Prove that for each $n \\in \\mathbb{N}$, PA proves $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$. Let $T_n(x)$ denote the term $\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}$ (with $T_0(x)$ being $0$). We prove this by meta-induction on $n$.\n*   **Base Case ($n=0$):** We must show PA proves $\\forall x(x\\cdot\\overline{0}=T_0(x))$, which is $\\forall x(x\\cdot 0=0)$. This is an axiom.\n*   **Inductive Step:** Assume PA proves $\\forall x(x\\cdot\\overline{k}=T_k(x))$ for some $k \\in \\mathbb{N}$. We want to show PA proves $\\forall x(x\\cdot\\overline{k+1}=T_{k+1}(x))$.\n    $\\overline{k+1}$ is $S(\\overline{k})$. The term is $x \\cdot S(\\overline{k})$.\n    By the multiplication axiom, PA proves $x \\cdot S(\\overline{k}) = (x\\cdot\\overline{k}) + x$.\n    By the meta-induction hypothesis, PA proves $x \\cdot \\overline{k} = T_k(x)$.\n    Substituting this gives $x \\cdot S(\\overline{k}) = T_k(x) + x$.\n    By definition, $T_{k+1}(x)$ is $T_k(x) + x$.\n    Thus, PA proves $\\forall x \\, (x \\cdot \\overline{k+1} = T_{k+1}(x))$.\nThe meta-induction holds, so the statement is correct.\n\nVerdict for D: **Correct**.\n\n### Analysis of Option E\nStatement E: `Since multiplication is a computable (indeed, primitive recursive) function, there exists a formula $\\varphi(x,y,z)$ in the language of PA that represents the graph of multiplication in PA in the strong sense: PA proves $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$, and for all $m,n\\in \\mathbb{N}$, PA proves $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$.`\n\nThis statement makes a claim based on a major theorem in mathematical logic.\n1.  **The Premise**: Multiplication on natural numbers is a primitive recursive function, which is a subset of the computable (or total recursive) functions. This is a correct statement from computability theory.\n2.  **The Consequence**: It is a foundational result of the theory of formal arithmetic (first shown by Gödel) that all computable functions are strongly representable in PA. Since multiplication is computable, it must be strongly representable in PA.\n3.  **Existence of the formula**: The statement asserts the existence of a formula $\\varphi(x,y,z)$ with the properties of a strong representation. According to the general theorem, such a formula must exist.\n4.  **A Concrete Example**: We can even exhibit such a formula directly. Let's choose the most natural candidate: $\\varphi(x,y,z) \\equiv (z = x \\cdot y)$. This formula is in the language of PA.\n    *   Does PA prove $\\forall x\\, \\forall y\\, \\exists ! z\\, (z=x\\cdot y)$? Yes, as established in the analysis of Option A.\n    *   For all $m,n\\in \\mathbb{N}$, does PA prove $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$? This is the statement that PA proves $\\overline{m\\cdot n} = \\overline{m} \\cdot \\overline{n}$. As established in the analysis of Option B, this is true for all $m,n \\in \\mathbb{N}$.\n\nThe reasoning provided in the option is sound, and the claim itself is a fundamental truth about PA.\n\nVerdict for E: **Correct**.\n\n### Summary\nThe analysis shows that statements A, B, D, and E are correct descriptions of theorems or properties of Peano Arithmetic, while statement C is incorrect.\n- **A** is correct because PA is strong enough to prove the totality of primitive recursive functions defined by its axioms.\n- **B** is correct because PA can execute computations, and the proof length for terminating computations is feasibly bounded.\n- **C** is incorrect because the multiplication axioms are not derivable from the other axioms.\n- **D** is correct, showing how PA proves basic algebraic identities from the recursive definitions.\n- **E** is correct, as it is an instance of the fundamental theorem on the representability of computable functions in PA.\n\nThe correct options are A, B, D, and E.", "answer": "$$\\boxed{ABDE}$$", "id": "3050644"}, {"introduction": "Having seen how a single function like multiplication is handled, we now generalize to the entire class of primitive recursive (PR) functions. This exercise guides you through the landmark proof that all PR functions are representable in $PA$, a cornerstone of mathematical logic. You will use structural induction and the powerful technique of sequence coding, which relies on tools like Gödel's $\\beta$-function, to show how complex computations can be systematically described within the language of arithmetic.", "problem": "Let the first-order language of arithmetic be given by symbols $0$, $S$, $+$, $\\cdot$, $=$, together with the usual logical connectives and quantifiers. Consider Peano Arithmetic (PA), the axiomatization of arithmetic over this language with the induction schema. A total function $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ is said to be primitive recursive if it can be obtained from the initial functions $Z(\\bar{x})=0$, $S(x)=x+1$, and the projections $U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$ by finitely many applications of function composition and primitive recursion, where primitive recursion takes a pair $(f,g)$ to a function $h$ satisfying\n$$\nh(0,\\bar{x})=f(\\bar{x}) \\quad\\text{and}\\quad h(S(y),\\bar{x})=g\\big(y,h(y,\\bar{x}),\\bar{x}\\big).\n$$\nA function $f$ is representable in Peano Arithmetic (PA) if there is a formula $\\varphi_{f}(\\bar{x},y)$ in the language such that for every $\\bar{n}\\in\\mathbb{N}^{k}$ and $m\\in\\mathbb{N}$, $\\mathrm{PA}$ proves $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$ and moreover $\\mathrm{PA}$ proves $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$, where $\\overline{n}$ denotes the numeral for $n$ and $\\bar{\\overline{n}}$ the tuple of numerals.\n\nAssume the following well-tested foundational fact: there is a primitive recursive sequence-coding function $\\beta(s,i)$ and a bounded formula $\\mathrm{Seq}(s,\\ell)$ in the language of arithmetic such that, for every finite function $a:\\{0,\\dots,\\ell-1\\}\\to\\mathbb{N}$, there exists $s$ with $\\mathrm{Seq}(s,\\ell)$ and $\\beta(s,i)=a(i)$ for all $i<\\ell$, and these properties about $\\beta$ and $\\mathrm{Seq}$ are provable in $\\mathrm{PA}$.\n\nUsing only the definitions above and this coding fact as the fundamental base, do the following:\n\n- Explain what representability in $\\mathrm{PA}$ requires and why the initial functions are representable.\n- Prove, by structural induction on the formation of primitive recursive functions, that if $f$ and the $g_{i}$ are representable, then so is their composition $h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$.\n- Prove, by structural induction using the sequence-coding fact, that if $f$ and $g$ are representable, then the primitive recursion $h$ determined by $f$ and $g$ is representable.\n- Conclude that every primitive recursive function is representable in $\\mathrm{PA}$.\n- As an illustration, give an explicit representing formula in the language of arithmetic for the primitive recursive addition function $\\mathrm{add}(x,y)=x+y$.\n\nYour final reported answer must be the representing term used inside your explicit addition formula, written as a single closed-form symbolic expression without any equality sign or logical connectives. Do not include units.", "solution": "The problem statement is a standard exercise in mathematical logic concerning the representability of primitive recursive functions within first-order Peano Arithmetic (PA).\n\n### Problem Validation\n**Step 1: Extract Givens**\n-   Language of Arithmetic: Symbols $0$, $S$, $+$, $\\cdot$, $=$, logical connectives, and quantifiers.\n-   Theory: Peano Arithmetic (PA) with the induction schema.\n-   Definition of Primitive Recursive (PR) Functions: The closure of initial functions (Zero $Z$, Successor $S$, Projections $U_{i}^{k}$) under composition and primitive recursion.\n    -   Initial functions: $Z(\\bar{x})=0$; $S(x)=x+1$; $U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$.\n    -   Composition: $h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$.\n    -   Primitive Recursion: $h(0,\\bar{x})=f(\\bar{x})$ and $h(S(y),\\bar{x})=g(y,h(y,\\bar{x}),\\bar{x})$.\n-   Definition of Representability: A function $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ is representable in PA if a formula $\\varphi_{f}(\\bar{x},y)$ exists such that for any $\\bar{n}\\in\\mathbb{N}^{k}$, PA proves $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$ and PA proves $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$. Here, $\\overline{n}$ is the numeral for the number $n$, i.e., the term $S(S(\\dots S(0)\\dots))$ with $n$ applications of $S$.\n-   Assumed Fact (Gödel's β-function Lemma): Existence of a PR sequence-coding function $\\beta(s,i)$ and a bounded formula $\\mathrm{Seq}(s,\\ell)$ with properties provable in PA, allowing for the coding of any finite sequence of natural numbers. Specifically, the relation $v = \\beta(s,i)$ is definable by a formula in the language of arithmetic, which we denote by $\\psi_{\\beta}(s,i,v)$.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, well-posed, and objective.\n-   **Scientifically Grounded**: The problem is a central topic in computability theory and the study of formal arithmetic. The definitions and the assumed lemma are standard and foundational to these fields. It does not violate any mathematical principles.\n-   **Well-Posed**: The problem asks for a proof of a well-established theorem. The steps are clearly outlined, and the definitions provided are sufficient to construct the proof. A unique and correct proof exists.\n-   **Objective**: The language is formal and precise. Terms like \"Peano Arithmetic,\" \"primitive recursive,\" and \"representable\" have unambiguous definitions in mathematical logic.\n\n**Step 3: Verdict and Action**\nThe problem is valid. The solution will proceed as requested.\n\n### Proof of Representability of Primitive Recursive Functions in PA\n\nWe proceed by structural induction on the class of primitive recursive functions.\n\n**1. Representability of Initial Functions**\n\nA function $f$ is representable in PA if there's a formula $\\varphi_f(\\bar{x},y)$ such that PA proves $\\forall \\bar{x} \\exists!y \\varphi_f(\\bar{x},y)$ and for all $\\bar{n} \\in \\mathbb{N}^k$, PA proves $\\varphi_f(\\bar{\\overline{n}}, \\overline{f(\\bar{n})})$. The existence and uniqueness of $y$ for a given $\\bar{x}$ are crucial.\n\n-   **Zero function**: $Z(x_{1},\\dots,x_{k})=0$. This function is represented by the formula $\\varphi_{Z}(\\bar{x},y) \\equiv y=0$.\n    -   PA trivially proves $\\forall \\bar{x} \\exists!y (y=0)$, as $y$ must be $0$.\n    -   For any $\\bar{n}\\in\\mathbb{N}^k$, $Z(\\bar{n})=0$. We need to show PA proves $\\varphi_{Z}(\\bar{\\overline{n}},\\overline{0})$, which is $\\overline{0}=0$. The numeral $\\overline{0}$ is the constant symbol $0$, so this is the trivial logical truth $0=0$.\n\n-   **Successor function**: $S(x)=x+1$. This function is represented by the formula $\\varphi_{S}(x,y) \\equiv y=S(x)$.\n    -   For any term $t$, PA proves $\\exists!y (y=t)$. So $\\forall x \\exists!y (y=S(x))$ is provable.\n    -   For any $n\\in\\mathbb{N}$, $S(n)=n+1$. We need to show PA proves $\\varphi_{S}(\\overline{n},\\overline{n+1})$. This is the formula $\\overline{n+1} = S(\\overline{n})$. By definition of the numeral, $\\overline{n+1}$ is the term $S(\\overline{n})$, so this is the statement $S(\\overline{n}) = S(\\overline{n})$, a logical identity.\n\n-   **Projection functions**: $U_{i}^{k}(x_{1},\\dots,x_{k})=x_i$. This function is represented by the formula $\\varphi_{U_i^k}(\\bar{x},y) \\equiv y=x_i$.\n    -   PA proves $\\forall \\bar{x} \\exists!y (y=x_i)$.\n    -   For any $\\bar{n}=(n_1,\\dots,n_k)\\in\\mathbb{N}^k$, $U_i^k(\\bar{n})=n_i$. We need to show PA proves $\\varphi_{U_i^k}(\\bar{\\overline{n}},\\overline{n_i})$, which is $\\overline{n_i}= \\overline{n_i}$, a logical identity.\n\nThus, all initial functions are representable in PA.\n\n**2. Closure under Composition**\n\nLet $h(\\bar{x}) = f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$. Assume that $f$ and each $g_i$ for $i=1,\\dots,m$ are representable in PA by formulas $\\varphi_f(y_1,\\dots,y_m,z)$ and $\\varphi_{g_i}(\\bar{x},y_i)$, respectively. We define the representing formula for $h$ as:\n$$ \\varphi_h(\\bar{x},z) \\equiv \\exists y_1 \\dots \\exists y_m \\left( \\bigwedge_{i=1}^{m} \\varphi_{g_i}(\\bar{x}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z) \\right) $$\nWe must show this formula represents $h$. For any tuple of numerals $\\bar{\\overline{n}}$:\n-   **Correctness and Existence**: Let $k_i=g_i(\\bar{n})$ for each $i$, and let $p=f(k_1,\\dots,k_m)=h(\\bar{n})$. By the representability of $g_i$ and $f$, PA proves $\\varphi_{g_i}(\\bar{\\overline{n}},\\overline{k_i})$ for each $i$, and PA proves $\\varphi_f(\\overline{k_1},\\dots,\\overline{k_m},\\overline{p})$. By instantiating the existential quantifiers in $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$ with the numerals $\\overline{k_1},\\dots,\\overline{k_m}$, we see that PA proves $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$. This establishes correctness and implies existence for $\\exists z \\varphi_h(\\bar{\\overline{n}},z)$.\n\n-   **Uniqueness**: Assume PA proves $\\varphi_h(\\bar{\\overline{n}},z_1)$ and $\\varphi_h(\\bar{\\overline{n}},z_2)$. We must show PA proves $z_1=z_2$.\n    The premises are:\n    $\\exists y_1 \\dots \\exists y_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z_1))$\n    $\\exists y'_1 \\dots \\exists y'_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y'_i) \\land \\varphi_f(y'_1, \\dots, y'_m, z_2))$\n    By the uniqueness property for each $g_i$, PA proves that for any $y_i, y'_i$, if $\\varphi_{g_i}(\\bar{\\overline{n}},y_i)$ and $\\varphi_{g_i}(\\bar{\\overline{n}},y'_i)$ hold, then $y_i=y'_i$. Therefore, PA proves $y_i=y'_i$ for all $i=1,\\dots,m$.\n    Substituting these equalities, the second premise implies $\\varphi_f(y_1, \\dots, y_m, z_2)$.\n    Now we have $\\varphi_f(y_1, \\dots, y_m, z_1)$ and $\\varphi_f(y_1, \\dots, y_m, z_2)$. By the uniqueness property for $f$, PA proves $z_1=z_2$.\n    Thus, PA proves $\\exists! z \\varphi_h(\\bar{\\overline{n}},z)$. The set of representable functions is closed under composition.\n\n**3. Closure under Primitive Recursion**\n\nLet $h$ be defined by primitive recursion from $f$ and $g$:\n$h(0, \\bar{x}) = f(\\bar{x})$\n$h(S(y), \\bar{x}) = g(y, h(y, \\bar{x}), \\bar{x})$\nAssume $f$ and $g$ are representable by $\\varphi_f(\\bar{x},z)$ and $\\varphi_g(y,u,\\bar{x},v)$. The value $h(y,\\bar{x})$ can be seen as the $(y+1)$-th term of a sequence whose terms are defined recursively. We use the provided sequence-coding machinery to formalize this. The relation $v=\\beta(s,i)$ is definable by a formula $\\psi_{\\beta}(s,i,v)$. The formula $\\varphi_h(y,\\bar{x},z)$ states that there exists a sequence $s$ of length $S(y)$ (i.e., $y+1$) such that its first element is $f(\\bar{x})$, subsequent elements are generated by $g$, and $z$ is the last element.\n$$\n\\varphi_h(y,\\bar{x},z) \\equiv \\exists s \\Bigg( \\mathrm{Seq}(s, S(y)) \\land \\exists v_0 \\bigg( \\psi_{\\beta}(s,0,v_0) \\land \\varphi_f(\\bar{x},v_0) \\bigg) \\land \\\\ \\forall i < y \\bigg( \\exists u \\exists v \\Big( \\psi_{\\beta}(s,i,u) \\land \\psi_{\\beta}(s,S(i),v) \\land \\varphi_g(i,u,\\bar{x},v) \\Big) \\bigg) \\land \\psi_{\\beta}(s,y,z) \\Bigg)\n$$\n-   **Correctness and Existence**: For any $n_y \\in \\mathbb{N}$ and $\\bar{n}_x \\in \\mathbb{N}^k$, consider the finite sequence of values $a_i = h(i, \\bar{n}_x)$ for $i=0,\\dots,n_y$. By the assumed property of the $\\beta$-function, there exists a number $s_0$ that codes this sequence, i.e., PA proves $\\mathrm{Seq}(\\overline{s_0}, S(\\overline{n_y}))$ and $\\psi_\\beta(\\overline{s_0}, \\bar{i}, \\overline{a_i})$ for $i \\le n_y$. By the representability of $f$ and $g$ and the definition of $h$, PA can prove that this sequence satisfies the recursive conditions. Specifically, PA proves $\\varphi_f(\\bar{\\overline{n}_x}, \\overline{a_0})$ and $\\varphi_g(\\bar{i}, \\overline{a_i}, \\bar{\\overline{n}_x}, \\overline{a_{i+1}})$ for $i<n_y$. Thus, PA proves that $\\overline{s_0}$ satisfies the existentially quantified part of $\\varphi_h(\\overline{n_y}, \\bar{\\overline{n}_x}, \\overline{a_{n_y}})$. This shows that PA proves $\\varphi_h(\\overline{n_y}, \\bar{\\overline{n}_x}, \\overline{h(n_y,\\bar{n}_x)})$, establishing correctness and existence.\n\n-   **Uniqueness**: Assume PA proves $\\varphi_h(\\overline{n_y},\\bar{\\overline{n}_x},z_1)$ and $\\varphi_h(\\overline{n_y},\\bar{\\overline{n}_x},z_2)$. This implies the existence of two coding numbers, say $s_1$ and $s_2$. We must show $z_1=z_2$. We prove by induction (within PA) on $i \\le \\overline{n_y}$ that the sequences coded by $s_1$ and $s_2$ are element-wise identical. Let $v_1(i)$ be the $i$-th element of the sequence coded by $s_1$, and $v_2(i)$ for $s_2$.\n    -   Base case $i=0$: From $\\varphi_h$, we have $\\varphi_f(\\bar{\\overline{n}_x}, v_1(0))$ and $\\varphi_f(\\bar{\\overline{n}_x}, v_2(0))$. By uniqueness for $f$, PA proves $v_1(0)=v_2(0)$.\n    -   Inductive step: Assume $v_1(i)=v_2(i)$ for $i < \\overline{n_y}$. Let this common value be $u$. From $\\varphi_h$, we have $\\varphi_g(\\bar{i}, u, \\bar{\\overline{n}_x}, v_1(S(i)))$ and $\\varphi_g(\\bar{i}, u, \\bar{\\overline{n}_x}, v_2(S(i)))$. By uniqueness for $g$, PA proves $v_1(S(i))=v_2(S(i))$.\n    -   By the induction schema of PA, it proves $\\forall i \\le \\overline{n_y} (v_1(i)=v_2(i))$.\n    -   In particular, for $i=\\overline{n_y}$, we have $v_1(\\overline{n_y})=v_2(\\overline{n_y})$. From the definition of $\\varphi_h$, we have $z_1 = v_1(\\overline{n_y})$ and $z_2 = v_2(\\overline{n_y})$. Therefore, PA proves $z_1=z_2$. Uniqueness is established. The set of representable functions is closed under primitive recursion.\n\n**4. Conclusion**\n\nThe set of primitive recursive functions is defined as the smallest set containing the initial functions (zero, successor, projections) and closed under the operations of composition and primitive recursion. We have demonstrated that:\n1.  All initial functions are representable in PA.\n2.  The set of functions representable in PA is closed under composition.\n3.  The set of functions representable in PA is closed under primitive recursion.\n\nBy the principle of structural induction, it follows that every primitive recursive function is representable in Peano Arithmetic.\n\n**5. Illustration: Representing Formula for Addition**\n\nThe addition function $\\mathrm{add}(x,y)=x+y$ is primitive recursive. Its definition is:\n-   $\\mathrm{add}(0,y) = y$\n-   $\\mathrm{add}(S(x),y) = S(\\mathrm{add}(x,y))$\nThis fits the schema of primitive recursion, with $f(y)=y$ (a projection function) and $g(x,u,y) = S(u)$ (composition of successor and projection). Following the proof above, we could construct a complex $\\Sigma_1$ formula for $\\mathrm{add}(x,y,z)$ using sequence coding.\n\nHowever, the problem specifies that the language of arithmetic includes the symbol `$+$`. This allows for a much simpler and more direct representing formula. We can propose the formula:\n$$ \\varphi_{\\mathrm{add}}(x,y,z) \\equiv z = x+y $$\nLet's verify this formula represents the addition function.\n1.  **Existence and Uniqueness**: PA must prove $\\forall x \\forall y \\exists!z (z=x+y)$. For any terms $t_1, t_2$, the term $t_1+t_2$ is well-formed. The statement $\\exists z (z=t_1+t_2)$ is a logical axiom. Uniqueness, $\\forall z_1, z_2 ((z_1=t_1+t_2 \\land z_2=t_1+t_2) \\to z_1=z_2)$, follows from the properties of equality. Thus, PA proves this property.\n2.  **Correctness**: For any natural numbers $n, m$, we must show PA proves $\\varphi_{\\mathrm{add}}(\\overline{n},\\overline{m},\\overline{n+m})$, which is the statement $\\overline{n+m} = \\overline{n}+\\overline{m}$. The axioms of PA for addition are precisely what is needed to prove this equality for all numerals. One can show by induction on $\\overline{m}$ that PA proves $\\overline{n}+\\overline{m}=\\overline{n+m}$.\n\nTherefore, $z=x+y$ is a valid (and maximally simple) formula representing the addition function in the given language. The \"representing term\" used inside this formula, which expresses the value of the function for inputs $x$ and $y$, is the term $x+y$.", "answer": "$$\n\\boxed{x+y}\n$$", "id": "3042040"}, {"introduction": "The previous exercise introduced sequence coding as the key tool for representing complex functions. This practice makes that abstract concept concrete by having you perform an arithmetization of a computation yourself. By applying a specific prime-power coding scheme to a simple register machine, you will trace its execution and encode the entire computational history into a single natural number, demystifying how syntax and processes can be mirrored within number theory.", "problem": "Work in first-order Peano Arithmetic (PA) in the language with symbols for addition and multiplication. Fix the standard prime-power sequence coding as follows. Let $p_i$ denote the $i$-th prime, with $p_0 = 2$, $p_1 = 3$, $p_2 = 5$, and so on. For a finite sequence $\\langle a_0,\\dots,a_n \\rangle$ of natural numbers, its code is the natural number\n$$\n\\prod_{i=0}^{n} p_i^{a_i+1}.\n$$\nWe will model computations of a single-register deterministic register machine $e$ with an instruction pointer. A configuration is a pair $(\\mathit{ip}, r)$ where $\\mathit{ip}$ is the current instruction label and $r$ is the content of the sole register. The halt state is encoded by $\\mathit{ip} = 0$. The code of a configuration $(\\mathit{ip}, r)$ is\n$$\n\\mathrm{ConfCode}(\\mathit{ip}, r) \\;=\\; 2^{\\mathit{ip}+1} \\cdot 3^{r+1}.\n$$\nA finite computation (run) is a finite sequence of configurations $\\langle c_0, c_1, \\dots, c_m \\rangle$ such that $c_0$ is the initial configuration for a given input, each adjacent pair $(c_i, c_{i+1})$ is related by the machine’s one-step transition relation, and $c_m$ is halting (its instruction pointer is $0$). The code of such a run is the prime-power code of the sequence of configuration codes:\n$$\n\\mathrm{RunCode}(c_0,\\dots,c_m) \\;=\\; \\prod_{i=0}^{m} p_i^{\\mathrm{ConfCode}(c_i)+1}.\n$$\nTasks:\n- Define, using only first-order arithmetic with the above coding, a formula $\\mathrm{Halt}_e(x,y)$ that expresses “$y$ is the code of a halting computation of machine $e$ on input $x$,” where a computation is a finite sequence of configurations starting at the initial configuration and ending at a halting configuration, and successive configurations obey the one-step transition relation of $e$. Your definition must be in the $\\Sigma_1$ class.\n- Justify that your formula $\\mathrm{Halt}_e(x,y)$ is $\\Sigma_1$ and explain why this $\\Sigma_1$ definability underlies the representability in Peano Arithmetic of all computably enumerable sets, via predicates of the form $\\exists y\\, \\mathrm{Halt}_e(x,y)$.\n- Consider the specific machine $e$ with two instructions:\n  1. Instruction label $1$: increment the register and jump to label $2$.\n  2. Instruction label $2$: halt.\n  On input $x=1$, compute the exact value of the run code $y$ that encodes the unique halting computation according to the scheme above. Give your final answer as a closed-form product of prime powers. Do not expand it into a base-$10$ numeral.\nProvide the final value of $y$ as your answer. No rounding is required.", "solution": "The problem is found to be valid as it is scientifically grounded in mathematical logic, well-posed, and objective. It contains no contradictions, ambiguities, or unsound premises. We may therefore proceed with a solution.\n\nThe problem consists of three tasks: defining a formula `Halt_e(x, y)`, justifying its properties and relation to computably enumerable sets, and calculating a specific run code.\n\n### Task 1: Definition of the formula $\\mathrm{Halt}_e(x,y)$\n\nWe are asked to define a formula $\\mathrm{Halt}_e(x,y)$ in the language of first-order Peano Arithmetic (PA), which contains symbols for addition ($+$) and multiplication ($\\cdot$), that expresses \"$y$ is the code of a halting computation of machine $e$ on input $x$\". The formula must be in the $\\Sigma_1$ class of the arithmetical hierarchy.\n\nA number $y$ encodes a halting computation if it is a prime-power code for a finite sequence of configuration codes, $\\langle c_0, c_1, \\dots, c_m \\rangle$, satisfying the following conditions:\n1.  The sequence is non-empty.\n2.  The first configuration $c_0$ is the initial configuration for the given input $x$. For a deterministic register machine, the initial configuration is conventionally $(\\mathit{ip}_{start}, x)$. We assume the initial instruction pointer $\\mathit{ip}_{start}$ is $1$.\n3.  The last configuration $c_m$ is a halting configuration, meaning its instruction pointer is $0$.\n4.  Each subsequent configuration $c_{i+1}$ in the sequence is obtained from the preceding one $c_i$ by a single step of the machine $e$'s execution, as defined by its transition relation.\n\nTo formalize this, we build the formula $\\mathrm{Halt}_e(x,y)$ from several auxiliary predicates. These predicates are definable in PA. Key to this is the definability of functions like primality testing, the $i$-th prime function ($p_i$), and exponentiation ($a^b$). While the language of PA only includes $+$ and $\\cdot$, these concepts are indeed definable. In particular, exponentiation is $\\Delta_1$-definable. All primitive recursive functions and relations are $\\Delta_1$-definable in PA. The relation expressed by $\\mathrm{Halt}_e(x,y)$ is primitive recursive, which guarantees its $\\Delta_1$-definability, and hence the existence of an equivalent $\\Sigma_1$ formula.\n\nLet's define the components of the formula.\n\n**Auxiliary Predicates:**\n\n-   $\\mathrm{IsPrime}(p)$: A formula stating that $p$ is a prime number.\n    $\\mathrm{IsPrime}(p) \\equiv p > 1 \\land \\forall d  p (d > 1 \\to \\neg(\\exists k  p (d \\cdot k = p)))$. This is a $\\Delta_0$ formula.\n-   $\\mathrm{NthPrime}(i, p)$: A formula stating that $p$ is the $i$-th prime number ($p_i$). This is $\\Delta_1$-definable.\n-   $\\mathrm{exp}(n, p, k)$: A formula stating that $k$ is the exponent of the prime $p$ in the prime factorization of $n$.\n    $\\mathrm{exp}(n, p, k) \\equiv p^k | n \\land \\neg(p^{k+1} | n)$. This is $\\Delta_1$ due to exponentiation.\n-   $\\mathrm{GetElem}(y, i, c)$: A formula stating that $c$ is the $(i+1)$-th element in the sequence encoded by $y$. Per the problem's encoding, this means $c+1$ is the exponent of $p_i$.\n    $\\mathrm{GetElem}(y, i, c) \\equiv \\exists p (\\mathrm{NthPrime}(i, p) \\land \\mathrm{exp}(y, p, c+1))$.\n-   $\\mathrm{Len}(y, m)$: A formula stating the length of the sequence coded by $y$ is $m$.\n    $\\mathrm{Len}(y, m) \\equiv \\exists p, q (\\mathrm{NthPrime}(m-1, p) \\land p|y \\land \\mathrm{NthPrime}(m, q) \\land \\neg(q|y))$.\n\n**Configuration Predicates:**\n\n-   $\\mathrm{ConfCode}(\\mathit{ip}, r, c)$: A formula stating that $c$ is the code for the configuration $(\\mathit{ip}, r)$.\n    $\\mathrm{ConfCode}(\\mathit{ip}, r, c) \\equiv c = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$.\n-   $\\mathrm{GetIP}(c, \\mathit{ip})$: A formula extracting the instruction pointer from a configuration code $c$.\n    $\\mathrm{GetIP}(c, \\mathit{ip}) \\equiv \\mathrm{exp}(c, 2, \\mathit{ip}+1)$.\n-   $\\mathrm{GetR}(c, r)$: A formula extracting the register value from a configuration code $c$.\n    $\\mathrm{GetR}(c, r) \\equiv \\mathrm{exp}(c, 3, r+1)$.\n\n**Computation Step Predicates:**\n\n-   $\\mathrm{Transition}_e(c, c')$: A formula stating that configuration $c'$ follows from $c$ in one step of machine $e$. This is a disjunction over all instructions of $e$. For a machine with $k$ instructions, this has the form:\n    $\\mathrm{Transition}_e(c, c') \\equiv \\bigvee_{j=1}^{k} \\Phi_j(c, c')$, where $\\Phi_j$ formalizes the effect of instruction $j$. Each $\\Phi_j$ is of the form $\\exists \\mathit{ip}, r, \\mathit{ip}', r' (\\mathrm{GetIP}(c, \\mathit{ip}) \\land \\mathrm{GetR}(c, r) \\land \\mathit{ip}=j \\land (\\text{logic for instruction } j) \\land \\mathrm{ConfCode}(\\mathit{ip}', r', c'))$.\n\n**The Full Formula $\\mathrm{Halt}_e(x,y)$:**\n\nCombining these, we define $\\mathrm{Halt}_e(x,y)$ as follows. It asserts that there exists a length $m+1$ for the computation sequence, and for all steps $i$ from $0$ to $m-1$, the transition from configuration $i$ to $i+1$ is valid.\n\n$\\mathrm{Halt}_e(x,y) \\equiv$\n$\\exists m > 0 \\, \\Big( \\mathrm{Len}(y, m+1) \\land $\n$\\quad \\exists c_0 \\, \\big( \\mathrm{GetElem}(y, 0, c_0) \\land \\mathrm{ConfCode}(1, x, c_0) \\big) \\land $\n$\\quad \\exists c_m \\, \\big( \\mathrm{GetElem}(y, m, c_m) \\land \\exists \\mathit{ip}_m (\\mathrm{GetIP}(c_m, \\mathit{ip}_m) \\land \\mathit{ip}_m = 0) \\big) \\land $\n$\\quad \\forall i  m \\, \\exists c_i, c_{i+1} \\, \\big( \\mathrm{GetElem}(y, i, c_i) \\land \\mathrm{GetElem}(y, i+1, c_{i+1}) \\land \\mathrm{Transition}_e(c_i, c_{i+1}) \\big) \\Big)$\n\nAll quantifiers in this formula are bounded (e.g., $m  y$, $c_i  y$), except for those hidden within the auxiliary predicates (notably exponentiation). The relation is primitive recursive, so it is $\\Delta_1$. According to the definition of the arithmetic hierarchy, a $\\Delta_1$ formula is provably equivalent to a $\\Sigma_1$ formula. Therefore, this construction defines the desired relation, and an equivalent $\\Sigma_1$ formula exists.\n\n### Task 2: Justification of $\\Sigma_1$ Definability and Representability\n\n**$\\Sigma_1$ Definability:** A formula is $\\Sigma_1$ if it is of the form $\\exists z_1 \\dots \\exists z_k \\phi$, where $\\phi$ is a $\\Delta_0$ formula (all its quantifiers are bounded). The predicate $R(x,y) \\equiv$ \"$y$ is the code of a halting computation of machine $e$ on input $x$\" is a decidable predicate. Given $x$ and $y$, one can mechanically check in a finite number of steps whether $y$ has the required properties. Such a predicate is called \"primitive recursive\". It is a fundamental result of computability theory and logic, established by Gödel, that every primitive recursive relation is definable in Peano Arithmetic by a formula that is $\\Delta_1$. A formula is $\\Delta_1$ if it is equivalent in PA to both a $\\Sigma_1$ formula and a $\\Pi_1$ formula. Thus, our predicate $\\mathrm{Halt}_e(x,y)$ is $\\Sigma_1$-definable. The semi-formal definition provided above is a sketch of the proof of this fact.\n\n**Relation to Computably Enumerable Sets:** This $\\Sigma_1$ definability is the foundation for representing all computably enumerable (CE) sets within PA.\n1.  A set $S \\subseteq \\mathbb{N}$ is computably enumerable if there exists a register machine $e$ that halts on input $x$ if and only if $x \\in S$.\n2.  The statement \"machine $e$ halts on input $x$\" is equivalent to asserting the existence of a corresponding halting computation.\n3.  In our formal system, this translates to: \"there exists a number $y$ that is the code of a halting computation of machine $e$ on input $x$\".\n4.  This can be written using our defined predicate as the formula $\\exists y \\, \\mathrm{Halt}_e(x, y)$.\n5.  Since $\\mathrm{Halt}_e(x, y)$ is definable by a $\\Sigma_1$ formula (as argued above), say $\\psi(x, y)$, the formula $\\exists y \\, \\psi(x, y)$ is also $\\Sigma_1$.\nThis establishes a direct correspondence: for every CE set $S$, there is a $\\Sigma_1$ formula $\\Phi_S(x)$ of the form $\\exists y \\, \\mathrm{Halt}_e(x, y)$ such that $x \\in S \\iff \\mathbb{N} \\models \\Phi_S(x)$. This shows that the class of $\\Sigma_1$-definable sets is precisely the class of computably enumerable sets.\nFurthermore, the $\\Sigma_1$ Soundness and Completeness Theorems for PA state that for any $\\Sigma_1$ sentence $\\phi$, $\\mathbb{N} \\models \\phi \\iff PA \\vdash \\phi$. This means that for any $n \\in S$, not only is $\\Phi_S(\\bar{n})$ true, but it is also provable in PA. This property is known as $\\Sigma_1$-representability of CE sets in PA.\n\n### Task 3: Calculation of the Run Code\n\nWe are given a specific machine $e$ and input $x=1$.\n-   **Machine $e$**:\n    1.  Instruction at label $1$: Increment the register, jump to label $2$.\n    2.  Instruction at label $2$: Halt (i.e., jump to label $0$).\n-   **Input**: $x=1$.\n\nWe trace the computation, which is a sequence of configurations $(\\mathit{ip}, r)$.\n1.  **Initial Configuration ($c_0$)**: The computation starts at instruction label $1$ with the input $x=1$ in the register.\n    $c_0 = (\\mathit{ip}=1, r=1)$.\n2.  **Step 1**: Execute instruction $1$. The register $r$ is incremented ($r \\to 1+1=2$) and the instruction pointer $\\mathit{ip}$ jumps to $2$. The next configuration is:\n    $c_1 = (\\mathit{ip}=2, r=2)$.\n3.  **Step 2**: Execute instruction $2$. This is a halt instruction, which we model as setting the instruction pointer to $0$. The register value remains unchanged. The final configuration is:\n    $c_2 = (\\mathit{ip}=0, r=2)$.\nThe machine has halted since $\\mathit{ip}=0$. The full computation trace is the sequence $\\langle c_0, c_1, c_2 \\rangle$.\n\nNext, we calculate the code for each configuration using $\\mathrm{ConfCode}(\\mathit{ip}, r) = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$.\n-   For $c_0 = (1, 1)$: Code $a_0 = \\mathrm{ConfCode}(1, 1) = 2^{1+1} \\cdot 3^{1+1} = 2^2 \\cdot 3^2 = 4 \\cdot 9 = 36$.\n-   For $c_1 = (2, 2)$: Code $a_1 = \\mathrm{ConfCode}(2, 2) = 2^{2+1} \\cdot 3^{2+1} = 2^3 \\cdot 3^3 = 8 \\cdot 27 = 216$.\n-   For $c_2 = (0, 2)$: Code $a_2 = \\mathrm{ConfCode}(0, 2) = 2^{0+1} \\cdot 3^{2+1} = 2^1 \\cdot 3^3 = 2 \\cdot 27 = 54$.\n\nThe sequence of configuration codes is $\\langle a_0, a_1, a_2 \\rangle = \\langle 36, 216, 54 \\rangle$.\n\nFinally, we compute the run code $y$ using the formula $\\mathrm{RunCode} = \\prod_{i=0}^{m} p_i^{a_i+1}$, where $m=2$. The primes are $p_0=2$, $p_1=3$, $p_2=5$.\nThe exponents are $a_i+1$:\n-   For $i=0$: exponent is $a_0+1 = 36+1 = 37$.\n-   For $i=1$: exponent is $a_1+1 = 216+1 = 217$.\n-   For $i=2$: exponent is $a_2+1 = 54+1 = 55$.\n\nThe run code $y$ is the product of these prime powers:\n$$y = p_0^{a_0+1} \\cdot p_1^{a_1+1} \\cdot p_2^{a_2+1} = 2^{37} \\cdot 3^{217} \\cdot 5^{55}$$", "answer": "$$\n\\boxed{2^{37} \\cdot 3^{217} \\cdot 5^{55}}\n$$", "id": "3042000"}]}