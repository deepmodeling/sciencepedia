{"hands_on_practices": [{"introduction": "The arithmetization of syntax begins with translating fundamental logical properties into primitive recursive predicates. This exercise challenges you to formalize one such property: identifying a bound variable occurrence within a formula's encoded parse tree. Success requires translating the syntactic concept of a quantifier's scope into the arithmetic language of Gödel numbers, providing a concrete foundation for more complex operations [@problem_id:3043163].", "problem": "In a fixed first-order language with variables $v_0, v_1, v_2, \\dots$, suppose we have a standard Gödel numbering that assigns to each well-formed formula a natural number code $x$. Positions in the parse tree of the coded formula are represented by finite sequences of child indices, encoded by the prime-power scheme: the sequence $\\langle a_0, a_1, \\dots, a_{n-1} \\rangle$ is coded as $\\prod_{k < n} p_k^{a_k + 1}$, where $p_k$ is the $k$-th prime. For such codings, it is a standard fact that the basic sequence operations (length, element at index, concatenation, prefix) and the syntactic predicates that check whether a node at a given address is a particular symbol (for example, a variable $v_i$ or a quantifier $(\\forall v_i)$ or $(\\exists v_i)$) are primitive recursive.\n\nAssume that in the parse tree, a quantifier node $(Q v_i)$, with $Q \\in \\{\\forall, \\exists\\}$, is labeled by the pair $\\langle Q, i \\rangle$ and has exactly one child, which is the root of its scope. The label of a variable node is the pair $\\langle \\mathrm{var}, i \\rangle$. Let $\\mathrm{IsVar}(x,p,i)$ be the primitive recursive predicate that holds if and only if the node of the parse tree of the formula coded by $x$ at address $p$ is labeled $\\langle \\mathrm{var}, i \\rangle$. Let $\\mathrm{IsQuant}(x,q,i)$ be the primitive recursive predicate that holds if and only if the node at address $q$ is labeled $\\langle Q, i \\rangle$ for some $Q \\in \\{\\forall, \\exists\\}$. Let $\\mathrm{Prefix}(q,p)$ be the primitive recursive predicate that holds if and only if the address $q$ is a prefix of the address $p$ (so the node at $q$ is an ancestor of the node at $p$).\n\nWe want a primitive recursive predicate $\\mathrm{BoundAt}(x,i,p)$ that is intended to hold if and only if the occurrence of $v_i$ at address $p$ in the parse tree of the formula coded by $x$ is bound, in the usual sense of first-order logic, namely that along the unique path from that node to the root there appears a quantifier $(\\forall v_i)$ or $(\\exists v_i)$ whose scope contains the occurrence.\n\nWhich of the following is a correct primitive recursive specification of $\\mathrm{BoundAt}(x,i,p)$ using a path through the parse tree?\n\nA. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\le p$ such that $\\mathrm{Prefix}(q,p)$ and $\\mathrm{IsQuant}(x,q,i)$.\n\nB. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and the parent of $p$ (i.e., the unique $q$ with $\\mathrm{Prefix}(q,p)$ and $\\mathrm{len}(q) = \\mathrm{len}(p) - 1$) satisfies $\\mathrm{IsQuant}(x,q,i)$.\n\nC. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and for all $q \\preceq p$ (i.e., all $q$ with $\\mathrm{Prefix}(q,p)$) we have $\\lnot \\mathrm{IsQuant}(x,q,i)$.\n\nD. $\\mathrm{BoundAt}(x,i,p)$ is defined to hold if and only if $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\preceq p$ such that $\\mathrm{IsQuant}(x,q,j)$ for some $j$ (possibly $j \\ne i$).\n\nHere, $\\le$ is the usual order on $\\mathbb{N}$ and $\\preceq$ abbreviates the $\\mathrm{Prefix}$ relation. Assume all auxiliary notions mentioned are encoded in the usual primitive recursive way via the chosen Gödel numbering and sequence coding.", "solution": "We begin from the fundamental definitions of primitive recursive functions and predicates: they are generated from the zero function, successor function, and projections by composition and primitive recursion, and are closed under bounded search (bounded existential and universal quantification) when the bounding term is primitive recursive. It is a standard result in arithmetization of syntax that, for a fixed Gödel numbering of first-order formulas and a fixed coding of finite sequences, the following are primitive recursive: the set of codes of well-formed formulas, the relation that a sequence code $p$ is a valid address in the parse tree of the formula with code $x$, the function retrieving the label at a node, and the predicates $\\mathrm{IsVar}(x,p,i)$ and $\\mathrm{IsQuant}(x,q,i)$. Furthermore, for prime-power sequence coding, sequence operations such as length, prefix, and element access are primitive recursive. Therefore, conjunctions and bounded quantifications over such relations stay within the primitive recursive class.\n\nThe intended meaning of $\\mathrm{BoundAt}(x,i,p)$ is: the node at address $p$ is a variable $v_i$, and somewhere along the path from that node up to the root there appears a quantifier binding $v_i$. In our tree model, a quantifier node $(Q v_i)$, with $Q \\in \\{\\forall, \\exists\\}$, has exactly one child, which is the root of its scope. Thus, an occurrence of $v_i$ at address $p$ is in the scope of a quantifier $(Q v_i)$ at address $q$ if and only if $q$ is a prefix of $p$. Hence the natural formalization is:\n$$\n\\mathrm{BoundAt}(x,i,p) \\;\\equiv\\; \\mathrm{IsVar}(x,p,i) \\,\\wedge\\, \\exists q \\text{ with } \\mathrm{Prefix}(q,p) \\text{ and } \\mathrm{IsQuant}(x,q,i).\n$$\nTo ensure primitive recursiveness, we express the existential quantifier as bounded. One simple bound is the numerical inequality $q \\le p$, which is sufficient because any code $q$ of a prefix of $p$ is a divisor of $p$ in the prime-power scheme and therefore satisfies $q \\le p$; scanning all $q \\le p$ and testing $\\mathrm{Prefix}(q,p)$ is a bounded search over a primitive recursive predicate. Alternatively, one could bound by the length of $p$, viewing $q$ as the code of some prefix of length at most $\\mathrm{len}(p) + 1$; both bounds are primitive recursive. The key point is that the search over all ancestors is finite and primitive recursive because the number of prefixes of $p$ is at most $\\mathrm{len}(p) + 1$.\n\nWe now evaluate each option.\n\nOption A: $\\mathrm{BoundAt}(x,i,p)$ holds iff $\\mathrm{IsVar}(x,p,i)$ and there exists $q \\le p$ with $\\mathrm{Prefix}(q,p)$ and $\\mathrm{IsQuant}(x,q,i)$. This exactly captures the intended condition: the variable at $p$ is $v_i$, and there is some ancestor $q$ labeled by a quantifier over $v_i$. The existential quantification is bounded by $q \\le p$ and the inner test $\\mathrm{Prefix}(q,p) \\wedge \\mathrm{IsQuant}(x,q,i)$ is primitive recursive. Therefore, this definition is both correct in meaning and primitive recursive. Verdict: Correct.\n\nOption B: $\\mathrm{BoundAt}(x,i,p)$ holds iff the parent of $p$ is a quantifier over $v_i$. This is too restrictive. In general, a bound occurrence of $v_i$ need not be immediately under a quantifier node; it can be nested under connectives or function symbols within the quantifier’s scope. For example, in the formula $(\\forall v_i)\\,(R(f(v_i)) \\wedge S)$, the occurrence of $v_i$ inside $f(v_i)$ is bound by the quantifier at some ancestor address $q$ strictly above the parent of the variable occurrence. Option B would incorrectly return false in such cases. Verdict: Incorrect.\n\nOption C: $\\mathrm{BoundAt}(x,i,p)$ holds iff the node at $p$ is $v_i$ and there is no ancestor quantifier over $v_i$. This contradicts the usual definition: it asserts the exact opposite of being bound. The absence of such a quantifier characterizes free occurrences of $v_i$, not bound ones. Verdict: Incorrect.\n\nOption D: $\\mathrm{BoundAt}(x,i,p)$ holds iff the node at $p$ is $v_i$ and there exists an ancestor quantifier over some variable $v_j$ (possibly $j \\ne i$). This condition is too weak: it would classify as bound any occurrence of $v_i$ that happens to lie within the scope of some quantifier, even a quantifier over a different variable. For example, in $(\\forall v_7)\\,P(v_3)$, the occurrence of $v_3$ is free, yet there is an ancestor quantifier over $v_7$, so Option D would incorrectly return true. Verdict: Incorrect.\n\nTherefore, the only correct specification among the options is Option A. It uses a path through the parse tree to check whether there exists an ancestor quantifier binding the same variable index, and the resulting predicate is primitive recursive by closure under bounded search and the primitive recursiveness of the syntactic and sequence-coding predicates.", "answer": "$$\\boxed{A}$$", "id": "3043163"}, {"introduction": "Beyond static properties, arithmetization must also capture dynamic operations on formulas, the most critical of which is substitution. This problem guides you through the construction of a general, capture-avoiding substitution function, $\\mathrm{Sub}(x,i,y)$, forcing you to confront the core challenge of variable capture and the necessity of renaming bound variables. Mastering this demonstrates how a complex, context-sensitive syntactic manipulation can be rigorously defined as a primitive recursive function [@problem_id:3043154].", "problem": "Consider a fixed language of First-Order Logic (FOL) with variables $v_0, v_1, v_2, \\dots$ and a fixed Gödel numbering that assigns to each finite string over the language’s alphabet a natural number such that the decoding functions for position, length, and symbol recognition are all primitive recursive. Assume a standard prime-power coding of finite sequences based on the Fundamental Theorem of Arithmetic (FTA), and that the predicates “$x$ codes a term,” “$x$ codes a formula,” and “$x$ has a bound occurrence of variable $v_i$” are decidable by primitive recursive means. Let $\\mathrm{Free}(x,i)$ be the primitive recursive predicate stating that the formula coded by $x$ has a free occurrence of $v_i$, and let $\\mathrm{Vars}(y)$ denote the finite set of variable indices that occur in the term coded by $y$; both are given by arithmetization of syntax using the fixed Gödel numbering. We aim to construct the capture-avoiding substitution function $\\mathrm{Sub}(x,i,y)$ that outputs the Gödel code of the formula obtained from the formula coded by $x$ by substituting the term coded by $y$ for the variable $v_i$, while avoiding variable capture.\n\nStarting from these foundational assumptions and definitions, analyze the arithmetization of capture-avoiding substitution and the necessity of bound-variable renaming in order to prevent variable capture. In particular, consider how $\\mathrm{Sub}(x,i,y)$ must treat quantifiers and binding constructs to preserve free variables of the substituted term. Based solely on first principles, select all statements below that are correct.\n\nA. If $y$ codes a variable $v_j$ and the formula coded by $x$ contains a quantifier that binds $v_j$ within the scope where $v_i$ is to be replaced, then naive substitution can turn a free occurrence of $v_j$ from $y$ into a bound occurrence in the result. Therefore, capture-avoiding $\\mathrm{Sub}(x,i,y)$ must detect such conflicts and perform a systematic renaming (alpha-conversion) of bound variables in $x$ to fresh variables before substitution.\n\nB. The function $\\mathrm{Sub}(x,i,y)$ can be defined as a primitive recursive function by recursion on the syntactic structure of the code $x$, provided one uses a primitive recursive “fresh-variable” selector such as $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ to handle renaming under quantifiers. No appeal to the Axiom of Choice (AC) is required for this arithmetization.\n\nC. If $y$ codes a term whose variables are all distinct from every variable that occurs bound anywhere in the formula coded by $x$, then naive substitution of $y$ for $v_i$ in $x$ cannot cause variable capture.\n\nD. The need to handle renaming of bound variables can be entirely avoided by reserving infinitely many variable symbols and stipulating that $y$ never uses any of the variable symbols that occur bound in $x$, so $\\mathrm{Sub}(x,i,y)$ need not check for bound-variable conflicts.\n\nChoose all that apply.", "solution": "The problem asks for an analysis of the arithmetization of the capture-avoiding substitution function, denoted $\\mathrm{Sub}(x,i,y)$, in first-order logic. This function takes the Gödel number $x$ of a formula $\\phi$, an index $i$ for a variable $v_i$, and the Gödel number $y$ of a term $t$, and it should return the Gödel number of the formula $\\phi[t/v_i]$ where all free occurrences of $v_i$ in $\\phi$ are replaced by $t$, and no free variables in $t$ become bound in the process.\n\nLet $\\phi_x$ denote the formula with Gödel number $x$, $v_i$ the variable with index $i$, and $t_y$ the term with Gödel number $y$. The operation is the substitution of $t_y$ for $v_i$ in $\\phi_x$.\n\nThe central issue is \"variable capture\". A variable $v_j$ is captured if it is free in $t_y$ and the substitution places $t_y$ into the scope of a quantifier that binds $v_j$ (i.e., $\\forall v_j$ or $\\exists v_j$).\nFor example, consider the formula $\\phi_x \\equiv \\exists v_j (v_i = v_j)$ and the term $t_y \\equiv v_j$. The set of free variables in $t_y$ is $\\{v_j\\}$. If we naively substitute $t_y$ for $v_i$ in $\\phi_x$, we get the formula $\\exists v_j (v_j = v_j)$. In the original formula $\\phi_x$, the variable $v_i$ is free. After substituting the term $t_y$, which contains the free variable $v_j$, the meaning of the formula has changed drastically because the free variable $v_j$ from $t_y$ has been \"captured\" by the quantifier $\\exists v_j$.\n\nA correct capture-avoiding substitution procedure must prevent this. The standard method is to rename the bound variable in the quantifier. In the example, we would first rename the bound variable $v_j$ in $\\phi_x$ to a fresh variable, say $v_k$, where $v_k$ does not occur in $\\phi_x$ and does not occur in $t_y$. The formula $\\phi_x$ is logically equivalent to $\\phi'_{x} \\equiv \\exists v_k (v_i = v_k)$. Now, substituting $t_y$ for $v_i$ in $\\phi'_{x}$ yields $\\exists v_k (v_j = v_k)$, which correctly preserves the logical structure. The free variable $v_j$ from the term remains free in the resulting formula.\n\nThe problem states that primitive recursive functions and predicates are available for basic syntactic operations on Gödel numbers, such as parsing, identifying terms and formulas ($\\mathrm{Free}(x,i)$, $\\mathrm{Vars}(y)$, etc.). We must analyze the properties of the full capture-avoiding substitution function $\\mathrm{Sub}(x,i,y)$ based on these assumptions.\n\n**Option-by-Option Analysis**\n\n**A. If $y$ codes a variable $v_j$ and the formula coded by $x$ contains a quantifier that binds $v_j$ within the scope where $v_i$ is to be replaced, then naive substitution can turn a free occurrence of $v_j$ from $y$ into a bound occurrence in the result. Therefore, capture-avoiding $\\mathrm{Sub}(x,i,y)$ must detect such conflicts and perform a systematic renaming (alpha-conversion) of bound variables in $x$ to fresh variables before substitution.**\n\nThis statement accurately describes the canonical scenario of variable capture. Let $\\phi_x$ be the formula coded by $x$, and let's assume it has the structure $\\dots \\forall v_j (\\dots v_i \\dots) \\dots$. The term to be substituted (coded by $y$) is the variable $v_j$. The substitution is for $v_i$. A naive replacement would result in $\\dots \\forall v_j (\\dots v_j \\dots) \\dots$. The substituted $v_j$ (which was free, as it was the entire term being substituted) becomes bound by the quantifier $\\forall v_j$. This is precisely what variable capture is. The remedy described, detecting such conflicts and performing a renaming of the bound variable (a process known as alpha-conversion or alpha-equivalence), is the standard and necessary procedure to implement capture-avoiding substitution correctly. The function $\\mathrm{Sub}(x,i,y)$ must implement this logic.\n\n**Verdict:** Correct.\n\n**B. The function $\\mathrm{Sub}(x,i,y)$ can be defined as a primitive recursive function by recursion on the syntactic structure of the code $x$, provided one uses a primitive recursive “fresh-variable” selector such as $1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ to handle renaming under quantifiers. No appeal to the Axiom of Choice (AC) is required for this arithmetization.**\n\nThis statement makes two claims: that $\\mathrm{Sub}(x,i,y)$ is primitive recursive, and that its construction is constructive (does not require AC).\n1.  **Primitive Recursiveness:** The function $\\mathrm{Sub}(x,i,y)$ is defined by recursion on the structure of the formula $\\phi_x$. This corresponds to a course-of-values recursion on the Gödel number $x$.\n    *   Base cases (atomic formulas): Substitution is a simple replacement, which is arithmetically a primitive recursive operation on Gödel numbers.\n    *   Recursive steps (connectives): For $\\phi_x = \\neg \\psi_z$ or $\\phi_x = \\psi_{z_1} \\land \\psi_{z_2}$, the result is built from the results of the recursive calls, e.g., $\\mathrm{Sub}(z_1, i, y)$ and $\\mathrm{Sub}(z_2, i, y)$. These compositions are primitive recursive.\n    *   Recursive step (quantifiers): For $\\phi_x = \\forall v_k \\psi_z$.\n        *   If $i=k$, $v_i$ is the bound variable, so no free occurrences exist to be substituted within the scope of this quantifier. The formula is unchanged.\n        *   If $i \\neq k$, we must check for conflict. A conflict occurs if $v_k$ is a free variable in the term $t_y$. This check is $\\exists j \\in \\mathrm{Vars}(y) \\text{ such that } j=k$, which is primitive recursive given the assumptions.\n        *   If there is no conflict, the result is $\\forall v_k (\\text{result of } \\mathrm{Sub}(z, i, y))$. This is a primitive recursive construction.\n        *   If there is a conflict, we must rename $v_k$. We need a \"fresh\" variable index $m$. The proposed selector $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ provides such an index. $\\mathrm{Vars}(x)$ and $\\mathrm{Vars}(y)$ are finite sets of indices, so their union is finite and the max and successor operations are primitive recursive. Finding this $m$ is a primitive recursive procedure. Then, we perform two substitutions: first, rename $v_k$ to $v_m$ in $\\psi_z$ to get $\\psi'_{z'}$ (this is a recursive call to $\\mathrm{Sub}(z, k, \\text{code of } v_m)$), and then substitute $t_y$ for $v_i$ in $\\psi'_{z'}$.\n    Since all operations (case analysis, checking for conflicts, selecting a fresh variable, and composing Gödel numbers) are primitive recursive, and the recursion is on the structure of the formula (a well-founded order), the entire function $\\mathrm{Sub}(x,i,y)$ is indeed primitive recursive.\n2.  **Axiom of Choice:** AC is needed when one must make an infinite number of arbitrary choices for which no rule can be given. Here, the choice of a fresh variable is entirely constructive and deterministic. The rule $m = 1+\\max(\\mathrm{Vars}(x)\\cup \\mathrm{Vars}(y))$ provides a specific, computable index $m$. No \"arbitrary choice\" is made. Therefore, the Axiom of Choice is not required.\n\nBoth claims in the statement are correct.\n\n**Verdict:** Correct.\n\n**C. If $y$ codes a term whose variables are all distinct from every variable that occurs bound anywhere in the formula coded by $x$, then naive substitution of $y$ for $v_i$ in $x$ cannot cause variable capture.**\n\nLet $t_y$ be the term coded by $y$ and $\\phi_x$ be the formula coded by $x$. Let $\\mathrm{FreeVars}(t_y)$ be the set of indices of free variables in $t_y$, and $\\mathrm{BoundVars}(\\phi_x)$ be the set of indices of variables bound anywhere in $\\phi_x$. The condition given is $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$.\nVariable capture occurs when we substitute $t_y$ for a free occurrence of $v_i$ that is within the scope of a quantifier, say $\\forall v_k$, and $v_k \\in \\mathrm{FreeVars}(t_y)$. The variable $v_k$ is, by definition, a bound variable in $\\phi_x$, so $k \\in \\mathrm{BoundVars}(\\phi_x)$. The premise explicitly states that for any such $k$, $k \\notin \\mathrm{FreeVars}(t_y)$. Therefore, the condition for variable capture is never met. A naive substitution, which directly replaces all free occurrences of $v_i$ with $t_y$ without any checks or renaming, would be safe under this strong assumption.\n\n**Verdict:** Correct.\n\n**D. The need to handle renaming of bound variables can be entirely avoided by reserving infinitely many variable symbols and stipulating that $y$ never uses any of the variable symbols that occur bound in $x$, so $\\mathrm{Sub}(x,i,y)$ need not check for bound-variable conflicts.**\n\nThis statement proposes a convention to sidestep the problem of variable capture. The convention is that for any substitution operation $\\mathrm{Sub}(x,i,y)$, the inputs must satisfy the condition $\\mathrm{FreeVars}(t_y) \\cap \\mathrm{BoundVars}(\\phi_x) = \\emptyset$. While following this convention would indeed make naive substitution safe (as established in Option C), it does not \"entirely avoid\" the need to handle renaming in a general-purpose substitution function.\nA formal system often requires substitutions where this condition is not met. For example, in a proof, one might need to instantiate a universally quantified formula $\\forall v_i \\phi$ with a term $t$, yielding $\\phi[t/v_i]$. The choice of $t$ is determined by the logic of the proof, not by a convenient convention. For instance, one might need to substitute $t_y \\equiv v_j$ into a formula $\\phi_x$ which contains $\\forall v_j$ as a subformula. A general substitution function must be powerful enough to handle this case correctly, which requires renaming.\nThe statement makes two problematic claims:\n1.  The need is \"entirely avoided\": This is false. A fully general $\\mathrm{Sub}$ function, as is required for the arithmetization of metamathematics (e.g., for proving Gödel's theorems), must be able to handle all valid inputs $x, i, y$, including those that violate the proposed stipulation. The need is only avoided for a *restricted class* of substitutions.\n2.  $\\mathrm{Sub}(x,i,y)$ \"need not check\": This is also incorrect. To enforce the stipulation, the function would need to check if the condition is met and perhaps halt with an error if it isn't. This is still a check. A true capture-avoiding function does not halt; it performs a renaming. Therefore, the internal logic to detect the conflict must exist, contradicting the claim that it need not check.\nThe existence of infinitely many variables is a prerequisite for renaming, not a way to avoid it. The core problem is algorithmic, not one of resource limitation.\n\n**Verdict:** Incorrect.\n\nFinal summary: Options A, B, and C are correct descriptions of the properties and requirements of capture-avoiding substitution, while Option D proposes an unrealistic convention that fails to solve the general problem.", "answer": "$$\\boxed{ABC}$$", "id": "3043154"}, {"introduction": "The technical construction of substitution finds its most celebrated application in the diagonalization lemma, the engine of self-reference in formal arithmetic. This practice examines the specific use of substitution within the diagonalization function, $\\mathrm{Diag}(n)$, where a numeral is substituted for a variable. It reveals the subtle but critical reason why the substitution must still distinguish between free and bound variables to avoid syntactic errors, cementing the importance of the robust function developed in the previous exercise [@problem_id:3043154] for achieving Gödel's results [@problem_id:3043153].", "problem": "Consider a first-order language of arithmetic $\\mathcal{L}$ with variables, terms, and the usual logical symbols. Let $\\ulcorner \\cdot \\urcorner$ be a Gödel numbering that assigns to each well-formed expression a natural number encoding it. Define the diagonalization function $\\mathrm{Diag}$ on codes of formulas with exactly one designated free variable symbol $v$ as follows: for a code $n = \\ulcorner \\varphi(v) \\urcorner$, $\\mathrm{Diag}(n)$ is intended to be the code of the formula obtained by substituting the numeral for $n$ into the free occurrences of $v$ in $\\varphi(v)$. The construction of $\\mathrm{Diag}$ relies on an arithmetized substitution function, denoted $\\mathrm{Sub}$, which, given codes for a formula, a variable, and a term, returns the code of the result of capture-avoiding substitution of that term for the variable’s free occurrences in the formula.\n\nStart from the fundamental syntactic definitions of bound and free variable occurrences in first-order logic, and the definition of variable capture: a substitution of a term $t$ for a variable $v$ in a formula $\\varphi$ causes variable capture if a variable occurring free in $t$ becomes bound by a quantifier in $\\varphi$ after substitution, or if the substitution fails to distinguish bound occurrences of $v$ in $\\varphi$ from its free occurrences. In the arithmetization of syntax, the function $\\mathrm{Sub}$ must be defined in a way that inspects the binding structure encoded by $\\ulcorner \\cdot \\urcorner$ and only performs substitution on the free occurrences of $v$, renaming bound variables (alpha-conversion) when necessary to avoid capture.\n\nTo concretize the issue, consider a formula $\\varphi(v)$ that contains both free and bound occurrences of $v$, for example $\\varphi(v) \\equiv (v = 0) \\lor \\exists v\\,(v = 1)$, and also consider a term $t$ that may contain variables, for example $t \\equiv f(y)$. A naive, purely syntactic “replace the symbol $v$ everywhere by $t$” procedure does not parse binding and can therefore attempt to replace $v$ in $\\exists v$ (which would even produce an ill-formed string), or replace $v$ inside the scope of a quantifier that binds a variable occurring in $t$, thereby capturing that variable. Even when the term is a numeral, the substitution must still respect the boundary between free and bound occurrences of $v$ to preserve the formula’s intended meaning.\n\nWhich of the following statements correctly explain why capture-avoiding substitution is necessary in constructing the diagonalization function $\\mathrm{Diag}$ so that correctness is maintained when variables are bound?\n\nA. In the arithmetization, the primitive recursive $\\mathrm{Sub}$ must avoid substituting into bound occurrences of the variable and must perform alpha-conversion if the term contains variables that would otherwise become bound; otherwise, the resulting code can represent a formula with altered meaning, breaking the fixed-point property required by diagonalization.\n\nB. Because the term inserted by $\\mathrm{Diag}$ is always a numeral (which contains no variables), it is safe to replace every occurrence of the variable symbol $v$, including those under quantifiers, without affecting correctness.\n\nC. Capture-avoiding substitution is required to ensure that the output remains a well-formed formula; a naive global symbol replacement can attempt to substitute for the variable symbol in a quantifier, producing an ill-formed expression and invalidating the construction of $\\mathrm{Diag}$.\n\nD. The need for capture-avoidance only arises in second-order logic; in first-order logic, quantifiers cannot cause a variable in a substituted term to become bound.\n\nE. Proper capture-avoidance is needed to make $\\mathrm{Diag}$ primitive recursive; without capture-avoidance, $\\mathrm{Diag}$ would not be computable.\n\nSelect all that apply.", "solution": "The user has provided a problem from the field of mathematical logic, specifically concerning the arithmetization of syntax, Gödel numbering, and the construction of the diagonalization function. I will now validate the problem statement.\n\n### Step 1: Extract Givens\n- **Language**: A first-order language of arithmetic, denoted $\\mathcal{L}$.\n- **Gödel Numbering**: A function $\\ulcorner \\cdot \\urcorner$ that assigns a unique natural number to each well-formed expression of $\\mathcal{L}$.\n- **Diagonalization Function, $\\mathrm{Diag}$**: For a Gödel number $n = \\ulcorner \\varphi(v) \\urcorner$, where $\\varphi(v)$ is a formula with exactly one designated free variable $v$, $\\mathrm{Diag}(n)$ is the Gödel number of the formula obtained by substituting the numeral for $n$ (let's denote it $\\bar{n}$) for all free occurrences of $v$ in $\\varphi(v)$. Thus, $\\mathrm{Diag}(n) = \\ulcorner \\varphi(\\bar{n}) \\urcorner$.\n- **Substitution Function, $\\mathrm{Sub}$**: An arithmetized function that takes the code of a formula, a variable, and a term, and returns the code of the formula resulting from a capture-avoiding substitution. The construction of $\\mathrm{Diag}$ relies on $\\mathrm{Sub}$.\n- **Definition of Capture**: Variable capture occurs when a substitution of a term $t$ for a variable $v$ in a formula $\\varphi$ causes a variable that is free in $t$ to become bound by a quantifier in $\\varphi$.\n- **Definition of Proper Substitution**: Proper substitution must inspect the binding structure, substitute only for free occurrences of a variable, and rename bound variables (alpha-conversion) if necessary to avoid capture.\n- **Example Formula**: $\\varphi(v) \\equiv (v = 0) \\lor \\exists v\\,(v = 1)$, which contains both free and bound occurrences of the same variable symbol $v$.\n- **Question**: Which statements correctly explain the necessity of capture-avoiding substitution for the construction of the $\\mathrm{Diag}$ function?\n\n### Step 2: Validate Using Extracted Givens\n- **Scientific Grounding (Critical)**: The problem is perfectly grounded in established mathematical logic. Gödel numbering, the arithmetization of syntax, the substitution function, the diagonalization lemma, and the concept of variable capture are all standard, central components of the proofs of Gödel's incompleteness theorems. The example formula is valid and illustrates the key issue well. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. It asks for the rationale behind a specific, crucial technical requirement (capture-avoidance) in a standard logical construction ($\\mathrm{Diag}$). There is a definite and non-ambiguous set of reasons for this requirement.\n- **Objective (Critical)**: The problem is stated in precise, objective, and technical language. There are no subjective or opinion-based claims.\n- **Flaw Checklist**: The problem does not exhibit any of the listed flaws. It is not unsound, non-formalizable, incomplete, contradictory, unrealistic, ill-posed, trivial, or unverifiable. The problem correctly describes a subtle but critical aspect of formal logic.\n\n### Step 3: Verdict and Action\nThe problem statement is valid. I will proceed to derive the answer and evaluate the options.\n\n### Derivation\nThe core of the problem is to understand the requirements for the substitution function $\\mathrm{Sub}(\\ulcorner\\varphi\\urcorner, \\ulcorner v \\urcorner, \\ulcorner t \\urcorner) = \\ulcorner \\varphi[t/v] \\urcorner$, and how they apply to the specific case of the diagonalization function $\\mathrm{Diag}(n)$, where $n = \\ulcorner\\varphi(v)\\urcorner$. The diagonalization is defined as $\\mathrm{Diag}(n) = \\mathrm{Sub}(n, \\ulcorner v \\urcorner, \\ulcorner \\bar{n} \\urcorner)$, where $\\bar{n}$ is the numeral for the number $n$.\n\nA \"capture-avoiding substitution\" procedure, when substituting a term $t$ for free occurrences of a variable $v$ in a formula $\\varphi$, must correctly handle two distinct but related issues related to variable binding:\n1.  **Respecting Existing Bindings**: The substitution must only affect the *free* occurrences of the variable $v$. It must not alter any *bound* occurrences of $v$. For instance, in a formula like $\\psi(v) \\land \\exists v \\chi(v)$, the substitution for $v$ should only occur in $\\psi(v)$, leaving $\\exists v \\chi(v)$ untouched.\n2.  **Avoiding New Bindings (Capture)**: If the term $t$ contains a free variable, say $y$, and the substitution for $v$ occurs within the scope of a quantifier binding $y$ (e.g., $\\exists y (\\dots v \\dots)$), then a naive substitution would result in the capture of $y$. To prevent this, the bound variable $y$ in the formula must be renamed (alpha-conversion) to a fresh variable, say $z$, yielding an equivalent formula $\\exists z (\\dots v \\dots)$ before the substitution is performed.\n\nLet's analyze these two requirements in the specific context of the $\\mathrm{Diag}$ function.\nThe term being substituted is always a numeral, $\\bar{n}$. A numeral, such as $SSS0$, is a closed term, meaning it contains no free variables. Consequently, the second issue—the capture of a variable from the substituted term—can never occur when constructing $\\mathrm{Diag}(\\ulcorner\\varphi(v)\\urcorner)$.\n\nHowever, the first issue remains critically important. The formula $\\varphi(v)$ itself can contain both free and bound occurrences of the variable symbol $v$. The problem provides the excellent example $\\varphi(v) \\equiv (v = 0) \\lor \\exists v\\,(v = 1)$.\n- The first occurrence of $v$ in $(v=0)$ is free.\n- The $v$ in $\\exists v$ is a binder.\n- The $v$ in $(v=1)$ is bound by the existential quantifier $\\exists v$.\n\nAccording to the definition of substitution, $\\varphi(\\bar{n})$ should be the formula $(\\bar{n} = 0) \\lor \\exists v\\,(v = 1)$. The substitution must happen only for the free occurrence of $v$.\nA naive \"find-and-replace all\" procedure would attempt to replace all instances of the symbol $v$. This would lead to a string like $(\\bar{n} = 0) \\lor \\exists \\bar{n}\\,(\\bar{n} = 1)$. The expression $\\exists \\bar{n}$ is syntactically invalid because a quantifier must be followed by a variable, not a term (a numeral). The resulting string is not a well-formed formula (wff).\nTherefore, any function that computes the Gödel number of the substituted formula must be able to parse the syntactic structure of the input formula to distinguish free from bound occurrences. This is a non-negotiable part of what \"capture-avoiding substitution\" entails, even when the specific case of variable capture from the term is not a risk.\n\nThe ultimate purpose of the $\\mathrm{Diag}$ function is to enable the proof of the Diagonalization Lemma (or Fixed-Point Theorem), which states that for any formula $\\psi(v)$ with one free variable $v$, there exists a sentence $G$ such that the theory proves $G \\leftrightarrow \\psi(\\ulcorner G \\urcorner)$. The sentence $G$ is constructed as $\\varphi(\\ulcorner\\varphi(v)\\urcorner)$, where $\\varphi(v) \\equiv \\psi(\\mathrm{Diag}(v))$. If the substitution performed by $\\mathrm{Diag}$ were incorrect—either producing an ill-formed expression or a formula with a different meaning—this chain of reasoning would collapse, and the fixed-point property would fail.\n\n### Option-by-Option Analysis\n\n**A. In the arithmetization, the primitive recursive $\\mathrm{Sub}$ must avoid substituting into bound occurrences of the variable and must perform alpha-conversion if the term contains variables that would otherwise become bound; otherwise, the resulting code can represent a formula with altered meaning, breaking the fixed-point property required by diagonalization.**\nThis statement gives a complete and accurate description of a proper, general substitution function $\\mathrm{Sub}$. It correctly identifies the two main requirements: not substituting into bound occurrences and performing alpha-conversion to prevent capture. It then correctly states the consequence of failure: the resulting formula would have an altered meaning (or be ill-formed), which would invalidate the logical equivalence required for the fixed-point theorem that underpins diagonalization. Even though alpha-conversion is not triggered in the specific application of $\\mathrm{Sub}$ within $\\mathrm{Diag}$, the function $\\mathrm{Sub}$ must be defined with this general capability, and the first requirement (avoiding substitution into bound occurrences) is essential for $\\mathrm{Diag}$.\n**Verdict: Correct.**\n\n**B. Because the term inserted by $\\mathrm{Diag}$ is always a numeral (which contains no variables), it is safe to replace every occurrence of the variable symbol $v$, including those under quantifiers, without affecting correctness.**\nThis statement is incorrect. As demonstrated with the example $\\varphi(v) \\equiv (v = 0) \\lor \\exists v\\,(v = 1)$, replacing the bound occurrence of $v$ in the quantifier $\\exists v$ with a numeral $\\bar{n}$ yields $\\exists \\bar{n}$, which is not a well-formed formula. Thus, it is not \"safe\" at all; in fact, it is fundamentally wrong and breaks the syntax.\n**Verdict: Incorrect.**\n\n**C. Capture-avoiding substitution is required to ensure that the output remains a well-formed formula; a naive global symbol replacement can attempt to substitute for the variable symbol in a quantifier, producing an ill-formed expression and invalidating the construction of $\\mathrm{Diag}$.**\nThis statement accurately identifies a primary and fatal flaw of a naive substitution process. A substitution function must be syntactically aware to differentiate between a variable being quantified over and a free occurrence of that variable. Failing to do so can lead to syntactically invalid output (ill-formed expressions). If $\\mathrm{Diag}$ were to produce codes of ill-formed expressions, the entire logical construction it is part of would be meaningless. This is a direct and crucial reason for requiring a more sophisticated substitution procedure.\n**Verdict: Correct.**\n\n**D. The need for capture-avoidance only arises in second-order logic; in first-order logic, quantifiers cannot cause a variable in a substituted term to become bound.**\nThis is factually false. The phenomenon of variable capture is a well-known and standard concept within first-order logic. For example, substituting the term $x$ for $v$ in the first-order formula $\\exists x (v > 0)$ would result in the capture of $x$. The claim that capture-avoidance is not a concern in first-order logic is a fundamental misunderstanding of the topic.\n**Verdict: Incorrect.**\n\n**E. Proper capture-avoidance is needed to make $\\mathrm{Diag}$ primitive recursive; without capture-avoidance, $\\mathrm{Diag}$ would not be computable.**\nThis misrepresents the relationship between computability and logical correctness. A naive, \"incorrect\" substitution (e.g., global find-and-replace) is a very simple string manipulation that is certainly computable and, in fact, primitive recursive. The significant result in arithmetization is that the *correct*, syntactically-aware, capture-avoiding substitution is *also* representable by a primitive recursive function. The need for capture-avoidance is a requirement for logical and syntactic correctness, not for computability itself.\n**Verdict: Incorrect.**", "answer": "$$\\boxed{AC}$$", "id": "3043153"}]}