{"hands_on_practices": [{"introduction": "A common task in experimental and computational physics is to analyze discrete data from a simulation or measurement to find key features of the underlying continuous process. This exercise demonstrates how to use Neville's algorithm to construct a local polynomial interpolant from sampled data, allowing for a precise determination of a feature, such as a local maximum, that lies between the sample points. Practicing this problem [@problem_id:2417614] will equip you with a valuable skill for refining data analysis, bridging the gap between discrete measurements and continuous physical models.", "problem": "You are given time-voltage samples from an underdamped resistor–inductor–capacitor circuit, represented generically by the smooth function $V(t)$ sampled at strictly increasing times $t_i$. Your task is to compute the time of the first local maximum of $V(t)$ by constructing a local polynomial interpolant from the samples using Neville’s algorithm and then locating the first stationary point corresponding to a local maximum. Base your design on the uniqueness of polynomial interpolation for distinct nodes and the calculus fact that local extrema of a differentiable function occur where the first derivative vanishes.\n\nImplement a program that, for each test case, proceeds as follows: detect the first bracket of a local maximum using the discrete samples $\\{(t_i,V_i)\\}$, construct a polynomial interpolant $p(t)$ with nodes surrounding that bracket using Neville’s algorithm, and locate the peak time $\\hat{t}$ within the bracket by solving for the stationary point of $p(t)$ using a numerically robust method that does not require explicit polynomial coefficients. Express all final answers in seconds, rounded to nine decimal places. All angles used in trigonometric functions are in radians.\n\nFor each test case below, the “simulation” data are to be generated by sampling the physically plausible underdamped response\n$$\nV(t) = V_0\\,e^{-\\alpha t}\\,\\sin\\!\\big(\\omega\\,t+\\phi\\big),\n$$\nwhere $V_0$ is in volts, $\\alpha$ is in inverse seconds, $\\omega$ is in radians per second, and $\\phi$ is in radians. For a given case, compute $V_i = V(t_i)$ at the prescribed times $t_i$.\n\nTest suite specification:\n- Case $1$ (uniform sampling, moderate damping):\n  - Parameters: $V_0 = 5.0$, $\\alpha = 50.0$, $\\omega = 600.0$, $\\phi = 0.0$.\n  - Times: $t_i = i\\,\\Delta t$ for $i=0,\\dots,N$ with $\\Delta t = 0.0005$ seconds and $N = 30$.\n- Case $2$ (nonuniform sampling, light damping, nonzero phase):\n  - Parameters: $V_0 = 3.0$, $\\alpha = 5.0$, $\\omega = 80.0$, $\\phi = 0.3$.\n  - Times (seconds): $[\\,0.0,\\,0.007,\\,0.013,\\,0.017,\\,0.023,\\,0.031,\\,0.041\\,]$.\n- Case $3$ (coarse sampling, very light damping):\n  - Parameters: $V_0 = 1.0$, $\\alpha = 2.0$, $\\omega = 10.0$, $\\phi = 0.1$.\n  - Times (seconds): $[\\,0.0,\\,0.08,\\,0.12,\\,0.14,\\,0.2\\,]$.\n\nAlgorithmic requirements:\n- Use Neville’s algorithm to evaluate the interpolating polynomial $p(t)$ at arbitrary $t$ within the first three-point bracket that contains the discrete first local maximum. You must use only data from a small, contiguous neighborhood around that bracket to avoid spurious oscillations; using the three nearest nodes $t_{i-1}, t_i, t_{i+1}$ is acceptable.\n- Locate the peak $\\hat{t}$ inside the detected bracket by solving for the stationary point of $p(t)$, using a numerically stable, derivative-free bracketing method consistent with unimodality over the bracket.\n\nOutput format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for the three test cases in order, with each time in seconds rounded to nine decimal places. For example: “[0.012345678,0.023456789,0.034567891]”.\n\nAngles are in radians. The final numeric answers must be in seconds, rounded to nine decimal places, in the specified single-line list format.", "solution": "The problem presented is subjected to rigorous validation and is deemed valid. It is scientifically grounded in the physics of oscillatory circuits and the mathematics of numerical analysis, well-posed with all necessary data provided, and objective in its formulation. We shall therefore proceed with a complete solution.\n\nThe objective is to determine the time $\\hat{t}$ of the first local voltage maximum, $V_{\\max}$, for an underdamped RLC circuit. The voltage $V(t)$ is sampled at discrete times $t_i$. The method involves three principal stages: first, identifying a three-point bracket around the discrete maximum from the provided samples; second, constructing a local quadratic interpolating polynomial $p(t)$ for these three points; and third, finding the maximum of this polynomial, which serves as our estimate $\\hat{t}$.\n\nThe voltage response of an underdamped RLC circuit is modeled by the function:\n$$\nV(t) = V_0\\,e^{-\\alpha t}\\,\\sin(\\omega\\,t+\\phi)\n$$\nwhere $V_0$ is the initial amplitude, $\\alpha$ is the damping constant, $\\omega$ is the angular frequency, and $\\phi$ is the phase shift. We will generate sample points $(t_i, V_i = V(t_i))$ for each test case as specified.\n\n**Step 1: Locating the Maximum Bracket**\n\nThe first step is to locate the first local maximum within the discrete data set $\\{V_i\\}$. A local maximum at index $i$ is characterized by the condition $V_{i-1}  V_i$ and $V_i > V_{i+1}$ for $i \\in \\{1, 2, \\dots, N-1\\}$. We scan the voltage samples $V_i$ to find the first index $i$ that satisfies this criterion. The three points $(t_{i-1}, V_{i-1})$, $(t_i, V_i)$, and $(t_{i+1}, V_{i+1})$ then form a bracket that contains the true continuous maximum. These three points will serve as the nodes for our local polynomial interpolation.\n\n**Step 2: Polynomial Interpolation via Neville's Algorithm**\n\nThe problem mandates the use of Neville's algorithm to represent the interpolating polynomial $p(t)$. For three distinct nodes $(x_0, y_0)$, $(x_1, y_1)$, and $(x_2, y_2)$, there exists a unique interpolating polynomial of degree at most $2$, which we denote as $p_{0,1,2}(t)$. Neville's algorithm provides a recursive method to evaluate this polynomial at any point $t$.\n\nLet $p_{i,\\dots,j}(t)$ be the polynomial that interpolates the points $(x_i, y_i), \\dots, (x_j, y_j)$. The recurrence relation is:\n$$\np_{i,\\dots,j}(t) = \\frac{(t-x_i)p_{i+1,\\dots,j}(t) - (t-x_j)p_{i,\\dots,j-1}(t)}{x_j - x_i}\n$$\nThe base of the recursion is $p_k(t) = y_k$.\nFor our three points, which we shall label $(t_0, V_0)$, $(t_1, V_1)$, $(t_2, V_2)$ for simplicity (corresponding to $(t_{i-1}, V_{i-1}), (t_i, V_i), (t_{i+1}, V_{i+1})$ from Step 1), the evaluation of the quadratic interpolant $p(t)$ proceeds as follows:\nFirst, we compute the two linear interpolants:\n$$\np_{0,1}(t) = \\frac{(t-t_0)V_1 - (t-t_1)V_0}{t_1 - t_0}\n$$\n$$\np_{1,2}(t) = \\frac{(t-t_1)V_2 - (t-t_2)V_1}{t_2 - t_1}\n$$\nThen, we combine them to obtain the quadratic interpolant:\n$$\np(t) = p_{0,1,2}(t) = \\frac{(t-t_0)p_{1,2}(t) - (t-t_2)p_{0,1}(t)}{t_2 - t_0}\n$$\nThis function $p(t)$ provides a smooth, quadratic approximation to the true function $V(t)$ in the vicinity of the maximum.\n\n**Step 3: Locating the Stationary Point**\n\nThe final step is to find the time $\\hat{t}$ where the interpolating polynomial $p(t)$ reaches its maximum. This occurs at a stationary point, where the derivative $p'(t)$ is zero. The problem specifies the use of a numerically robust, derivative-free method. This suggests we should treat $p(t)$ as a black-box function and employ a numerical optimization algorithm to find its maximum.\n\nWe seek to find $\\hat{t}$ such that:\n$$\n\\hat{t} = \\arg\\max_{t \\in [t_{i-1}, t_{i+1}]} p(t)\n$$\nStandard numerical optimization libraries typically provide routines for minimization. We can find the maximum of $p(t)$ by finding the minimum of $-p(t)$. Thus, we solve:\n$$\n\\hat{t} = \\arg\\min_{t \\in [t_{i-1}, t_{i+1}]} \\{-p(t)\\}\n$$\nWe will use a bounded optimization algorithm, such as Brent's method, which is well-suited for this task. It is derivative-free, robust, and guaranteed to find a local extremum within the provided bracket $[t_{i-1}, t_{i+1}]$.\n\nThe overall algorithm for each test case is as follows:\n1.  Generate the time-voltage samples $(t_i, V_i)$ using the given physical parameters.\n2.  Iterate through the samples to find the first index $i$ such that $V_{i-1}  V_i > V_{i+1}$.\n3.  Define the interpolation nodes as $x_{\\text{nodes}} = [t_{i-1}, t_i, t_{i+1}]$ and $y_{\\text{nodes}} = [V_{i-1}, V_i, V_{i+1}]$.\n4.  Define an objective function, `objective(t)`, which computes $-p(t)$ using Neville's algorithm with the determined nodes.\n5.  Use a numerical minimizer (e.g., `scipy.optimize.minimize_scalar`) on `objective(t)` within the search interval $[t_{i-1}, t_{i+1}]$.\n6.  The time returned by the minimizer is the estimated peak time, $\\hat{t}$.\n7.  Round the result to nine decimal places and store it.\n\nThis procedure is applied to all test cases, and the final results are collected and formatted as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the time of the first local voltage maximum for three test cases\n    of an underdamped RLC circuit using Neville's algorithm for interpolation\n    and numerical optimization.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"params\": {\"V0\": 5.0, \"alpha\": 50.0, \"omega\": 600.0, \"phi\": 0.0},\n            \"times\": np.linspace(0, 30 * 0.0005, 31)\n        },\n        {\n            \"params\": {\"V0\": 3.0, \"alpha\": 5.0, \"omega\": 80.0, \"phi\": 0.3},\n            \"times\": np.array([0.0, 0.007, 0.013, 0.017, 0.023, 0.031, 0.041])\n        },\n        {\n            \"params\": {\"V0\": 1.0, \"alpha\": 2.0, \"omega\": 10.0, \"phi\": 0.1},\n            \"times\": np.array([0.0, 0.08, 0.12, 0.14, 0.2])\n        }\n    ]\n\n    results = []\n    \n    # Voltage function for the underdamped RLC circuit\n    def V_t(t, V0, alpha, omega, phi):\n        return V0 * np.exp(-alpha * t) * np.sin(omega * t + phi)\n\n    # Neville's algorithm implementation\n    def neville(x_nodes, y_nodes, x):\n        \"\"\"\n        Evaluates the interpolating polynomial at a point x using Neville's algorithm.\n        \n        Args:\n            x_nodes (list or np.ndarray): The x-coordinates of the data points.\n            y_nodes (list or np.ndarray): The y-coordinates of the data points.\n            x (float): The point at which to evaluate the polynomial.\n            \n        Returns:\n            float: The interpolated value p(x).\n        \"\"\"\n        n = len(x_nodes)\n        p = np.zeros(n)\n        for i in range(n):\n            p[i] = y_nodes[i]\n\n        for k in range(1, n):\n            for i in range(n - k):\n                p[i] = ((x - x_nodes[i+k]) * p[i] + (x_nodes[i] - x) * p[i+1]) / (x_nodes[i] - x_nodes[i+k])\n        \n        return p[0]\n\n    for case in test_cases:\n        params = case[\"params\"]\n        t_samples = case[\"times\"]\n        \n        # Generate voltage samples a_i = V(t_i)\n        V_samples = V_t(t_samples, **params)\n        \n        # Find the first three-point bracket for the local maximum\n        # (t_{i-1}, V_{i-1}), (t_i, V_i), (t_{i+1}, V_{i+1})\n        # such that V_{i-1}  V_i  V_{i+1}\n        bracket_found = False\n        for i in range(1, len(V_samples) - 1):\n            if V_samples[i]  V_samples[i-1] and V_samples[i]  V_samples[i+1]:\n                # Nodes for interpolation\n                t_nodes = t_samples[i-1:i+2]\n                V_nodes = V_samples[i-1:i+2]\n                \n                # Search interval for optimization\n                t_search_bracket = (t_samples[i-1], t_samples[i+1])\n                bracket_found = True\n                break\n        \n        if not bracket_found:\n            # This should not happen with the given test cases\n            raise ValueError(\"Could not find a local maximum bracket.\")\n            \n        # Define the objective function for the optimizer.\n        # We minimize -p(t) to find the maximum of p(t).\n        def objective_func(t):\n            return -neville(t_nodes, V_nodes, t)\n            \n        # Use a robust, bounded, derivative-free optimization method to find the peak time.\n        # Brent's method is suitable for this.\n        res = minimize_scalar(\n            objective_func,\n            bracket=t_search_bracket,\n            method='brent'\n        )\n        \n        peak_time = res.x\n        results.append(f\"{peak_time:.9f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2417614"}, {"introduction": "Many fundamental concepts in physics, from quantum wavefunctions to the phasors in AC circuits, are described using complex numbers. This practice extends Neville's algorithm from real-valued to complex-valued functions, where the abscissae remain real but the ordinates are complex. By working through this problem [@problem_id:2417627], you will confirm that the algorithm's structure is general enough to handle complex arithmetic, a crucial step for applying interpolation techniques to a wider range of physical phenomena.", "problem": "Consider a set of distinct real abscissae $x_i \\in \\mathbb{R}$ and corresponding complex ordinates $z_i \\in \\mathbb{C}$ representing samples of a one-dimensional quantum wavefunction. For each test case, construct the unique polynomial $p(x)$ of degree at most $n-1$ that satisfies $p(x_i)=z_i$ for all provided pairs $\\{(x_i,z_i)\\}_{i=0}^{n-1}$, and evaluate $p(x)$ at a specified target $x=x_{\\mathrm{t}}$. The complex result $p(x_{\\mathrm{t}})$ should be reported by its real and imaginary parts. All angles are measured in radians. No physical units are attached to $x$ or to the wavefunction values. For numerical reporting, round each real number to eight decimal places.\n\nThe test suite defines $z_i$ via the complex-valued function $\\psi(x)=\\exp(-x^2)\\,\\exp(\\mathrm{i}\\,k\\,x)$, where $k$ is a given real constant. For each test case, generate $z_i=\\psi(x_i)$ using the provided $x_i$ and $k$, then compute the interpolating polynomial $p(x)$ through $\\{(x_i,z_i)\\}$ and evaluate $p(x_{\\mathrm{t}})$ at the provided $x_{\\mathrm{t}}$. Ensure there are no repeated abscissae. Angles $k\\,x$ are in radians.\n\nTest suite:\n1. Happy-path case: $x$-nodes $[-1.0,-0.2,0.3,0.9]$, $k=5.0$, target $x_{\\mathrm{t}}=0.1$.\n2. Interpolation at a node: $x$-nodes $[-0.5,0.0,0.5]$, $k=3.0$, target $x_{\\mathrm{t}}=0.5$ (note $x_{\\mathrm{t}}$ coincides with a node).\n3. Degree-zero boundary case: $x$-nodes $[0.2]$, $k=7.0$, target $x_{\\mathrm{t}}=-1.2$.\n4. Linear case: $x$-nodes $[-1.0,1.0]$, $k=2.5$, target $x_{\\mathrm{t}}=0.0$.\n\nPrecisely:\n- Test $1$: $x_0=-1.0$, $x_1=-0.2$, $x_2=0.3$, $x_3=0.9$, $k=5.0$, $x_{\\mathrm{t}}=0.1$.\n- Test $2$: $x_0=-0.5$, $x_1=0.0$, $x_2=0.5$, $k=3.0$, $x_{\\mathrm{t}}=0.5$.\n- Test $3$: $x_0=0.2$, $k=7.0$, $x_{\\mathrm{t}}=-1.2$.\n- Test $4$: $x_0=-1.0$, $x_1=1.0$, $k=2.5$, $x_{\\mathrm{t}}=0.0$.\n\nFor each test case, compute $z_i=\\psi(x_i)=\\exp(-x_i^2)\\,\\exp(\\mathrm{i}\\,k\\,x_i)$ using the specified $k$, then compute $p(x_{\\mathrm{t}})$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with the real and imaginary parts for each test case presented consecutively in the order of the tests, each rounded to eight decimal places. For example, the format must be\n$[$$\\operatorname{Re}(p(x_{\\mathrm{t},1}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},1}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},2}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},2}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},3}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},3}))$,$\\operatorname{Re}(p(x_{\\mathrm{t},4}))$,$\\operatorname{Im}(p(x_{\\mathrm{t},4}))$$]$.", "solution": "The problem requires the evaluation of a complex-valued interpolating polynomial at a specified real-valued point. The data consists of $n$ pairs $\\{(x_i, z_i)\\}_{i=0}^{n-1}$, where the abscissae $x_i$ are distinct real numbers and the ordinates $z_i$ are complex numbers derived from a given function $\\psi(x)=\\exp(-x^2)\\,\\exp(\\mathrm{i}\\,k\\,x)$. The problem is scientifically valid and mathematically well-posed. The existence and uniqueness of an interpolating polynomial $p(x)$ of degree at most $n-1$ is guaranteed by the fundamental theorem of polynomial interpolation, as the abscissae $x_i$ are stipulated to be distinct.\n\nA direct and robust numerical method for this task is Neville's algorithm. This algorithm is particularly efficient for finding the value of the interpolating polynomial at a single target point $x_{\\mathrm{t}}$, as it obviates the need for explicitly computing the coefficients of the polynomial $p(x)$. The algorithm operates on complex numbers in the same manner as it does on real numbers, as the fields of real and complex numbers share the necessary arithmetic properties.\n\nLet $P_{i,j}(x)$ denote the value at $x$ of the polynomial that interpolates the data points $(x_i, z_i), (x_{i+1}, z_{i+1}), \\dots, (x_j, z_j)$. The algorithm is defined by the following recurrence relation:\nThe base case consists of degree-$0$ polynomials, which are constants equal to the ordinates:\n$$ P_{i,i}(x) = z_i $$\nFor $k  0$, the polynomial $P_{i,i+k}(x)$ interpolating points $i$ through $i+k$ can be constructed from the polynomials interpolating points $i$ through $i+k-1$ and $i+1$ through $i+k$:\n$$ P_{i, i+k}(x) = \\frac{(x - x_{i+k}) P_{i, i+k-1}(x) - (x - x_i) P_{i+1, i+k}(x)}{x_i - x_{i+k}} $$\nThis recurrence computes higher-degree polynomial values from lower-degree ones. To find the value $p(x_{\\mathrm{t}})$ for the full set of $n$ points, we start with $P_{i,i}(x_{\\mathrm{t}}) = z_i$ for $i=0, \\dots, n-1$ and iteratively compute the values for $k=1, \\dots, n-1$ until we obtain the final value $P_{0,n-1}(x_{\\mathrm{t}})$.\n\nThis is organized computationally using a tableau. Let $T_{i,k}$ represent the value $P_{i, i+k}(x_{\\mathrm{t}})$. The tableau is filled as follows:\nThe first column ($k=0$) is initialized with the given ordinates:\n$$ T_{i,0} = z_i \\quad \\text{for } i = 0, 1, \\dots, n-1 $$\nSubsequent columns ($k=1, \\dots, n-1$) are computed using the values from the previous column:\n$$ T_{i,k} = \\frac{(x_{\\mathrm{t}} - x_{i+k}) T_{i, k-1} - (x_{\\mathrm{t}} - x_i) T_{i+1, k-1}}{x_i - x_{i+k}} \\quad \\text{for } i = 0, 1, \\dots, n-1-k $$\nAll arithmetic operations involve complex numbers. The final result, $p(x_{\\mathrm{t}})$, is the top-most element in the last computed column, which is $T_{0,n-1}$.\n\nThis procedure is robust and correctly handles the special cases presented in the test suite.\n- For Test Case $2$, where the target $x_{\\mathrm{t}}$ coincides with a node, say $x_j$, the algorithm will correctly yield $p(x_j) = z_j$. This is a direct consequence of the recurrence relation, where terms of the form $(x_{\\mathrm{t}} - x_j)$ become zero and propagate the value $z_j$ through the computation.\n- For Test Case $3$, with a single data point $(x_0, z_0)$, the interpolating polynomial is of degree $0$, $p(x)=z_0$. The algorithm correctly returns $z_0$ as the result, since the process terminates after the initialization step ($n=1$, so $n-1=0$).\n- For Test Case $4$, with two points, the algorithm performs standard complex linear interpolation.\n\nThe implementation will generate the complex ordinates $z_i = \\exp(-x_i^2)(\\cos(kx_i) + \\mathrm{i}\\sin(kx_i))$ for each test case using the provided values of $x_i$ and $k$. Then, it will apply Neville's algorithm as described to compute $p(x_{\\mathrm{t}})$ and report its real and imaginary components, rounded as specified.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for the given test suite.\n    \"\"\"\n\n    def neville(x_nodes, z_nodes, x_target):\n        \"\"\"\n        Implements Neville's algorithm for polynomial interpolation.\n\n        Args:\n            x_nodes (list of float): The abscissae of the data points.\n            z_nodes (np.ndarray of complex): The ordinates of the data points.\n            x_target (float): The point at which to evaluate the polynomial.\n\n        Returns:\n            complex: The value of the interpolating polynomial at x_target.\n        \"\"\"\n        n = len(x_nodes)\n        if n == 0:\n            return 0.0 + 0.0j # Should not happen with problem constraints\n        \n        # The tableau for Neville's algorithm.\n        # T[i, k] corresponds to P_{i, i+k}(x_target) in the explanation.\n        T = np.zeros((n, n), dtype=np.complex128)\n        \n        # Initialize the first column (k=0) with the ordinates z_i\n        for i in range(n):\n            T[i, 0] = z_nodes[i]\n            \n        # Fill the rest of the tableau column by column\n        for k in range(1, n):\n            for i in range(n - k):\n                # Recurrence relation for P_{i, i+k}\n                numerator1 = (x_target - x_nodes[i+k]) * T[i, k-1]\n                numerator2 = (x_target - x_nodes[i]) * T[i+1, k-1]\n                denominator = x_nodes[i] - x_nodes[i+k]\n                \n                # Check for division by zero, though problem states x_nodes are distinct.\n                if denominator == 0:\n                    # This case indicates an issue with input data (repeated nodes).\n                    # The problem statement guarantees distinct nodes.\n                    # In a general purpose library, an exception would be raised.\n                    # Here we can assume it doesn't happen.\n                    pass\n                \n                T[i, k] = (numerator1 - numerator2) / denominator\n                \n        # The final result is the top element of the last column\n        return T[0, n-1]\n\n    # Test suite as defined in the problem statement.\n    test_cases = [\n        {\"x_nodes\": [-1.0, -0.2, 0.3, 0.9], \"k\": 5.0, \"x_t\": 0.1},\n        {\"x_nodes\": [-0.5, 0.0, 0.5], \"k\": 3.0, \"x_t\": 0.5},\n        {\"x_nodes\": [0.2], \"k\": 7.0, \"x_t\": -1.2},\n        {\"x_nodes\": [-1.0, 1.0], \"k\": 2.5, \"x_t\": 0.0},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        x_nodes = case[\"x_nodes\"]\n        k = case[\"k\"]\n        x_t = case[\"x_t\"]\n        \n        # Ensure nodes are numpy arrays for vectorized operations\n        x_nodes_np = np.array(x_nodes, dtype=float)\n        \n        # Generate the complex ordinates z_i from psi(x_i)\n        z_nodes = np.exp(-x_nodes_np**2) * np.exp(1j * k * x_nodes_np)\n        \n        # Compute the interpolated value p(x_t)\n        p_xt = neville(x_nodes, z_nodes, x_t)\n        \n        # Append real and imaginary parts, rounded to 8 decimal places\n        all_results.append(f\"{p_xt.real:.8f}\")\n        all_results.append(f\"{p_xt.imag:.8f}\")\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2417627"}, {"introduction": "In computational science, a correct algorithm is only the first step; for large-scale problems, efficiency is paramount. This advanced practice challenges you to move beyond implementing Neville's algorithm and instead analyze its internal structure for parallelization. By examining the data dependencies in the algorithm's recursive construction [@problem_id:2417610], you will develop the critical thinking needed to design efficient code for modern multi-core processors, a key skill for any computational physicist.", "problem": "In a computational physics workflow, suppose you have a set of $n+1$ ab initio samples $\\{(x_0,V_0),\\dots,(x_n,V_n)\\}$ of a one-dimensional potential energy function, where $x_i \\in \\mathbb{R}$ are distinct and $V_i \\in \\mathbb{R}$. You wish to evaluate at a single query $x^\\star \\in \\mathbb{R}$ the unique interpolating polynomial of degree at most $n$ that passes through these samples. You select Neville’s algorithm because it builds the interpolant by recursively combining lower-degree interpolants via linear interpolation and is known to have favorable numerical stability.\n\nDefine $T_i^{(0)}(x^\\star) \\equiv V_i$ for $i \\in \\{0,\\dots,n\\}$. For $m \\in \\{1,\\dots,n\\}$ and $i \\in \\{0,\\dots,n-m\\}$, define $T_i^{(m)}(x^\\star)$ to be the degree-$m$ interpolant evaluated at $x^\\star$ that uses the data $\\{(x_i,V_i),\\dots,(x_{i+m},V_{i+m})\\}$, constructed by linearly blending the two adjacent degree-$(m-1)$ interpolants that cover $\\{(x_i,V_i),\\dots,(x_{i+m-1},V_{i+m-1})\\}$ and $\\{(x_{i+1},V_{i+1}),\\dots,(x_{i+m},V_{i+m})\\}$. The final answer returned by Neville’s algorithm is $T_0^{(n)}(x^\\star)$.\n\nUsing only the definition above, analyze the data dependencies among the $T_i^{(m)}(x^\\star)$, and consider multi-threaded scheduling for computing all required $T_i^{(m)}(x^\\star)$ for a single query $x^\\star$. Which of the following parallelization strategies is correct and achieves asymptotic work $O(n^2)$ and parallel depth $O(n)$ for this single-point evaluation, under a standard fork-join model with barrier synchronization and assuming ideal load balance?\n\nA. Stage-by-stage across polynomial order: For each $m$ from $1$ to $n$, compute all $T_i^{(m)}(x^\\star)$ for $i \\in \\{0,\\dots,n-m\\}$ in parallel, using only values from order $m-1$, then synchronize with a barrier before advancing $m$. This uses two working arrays of length $n+1$ for a double-buffered in-place update across $m$.\n\nB. Row-parallel within the tableau: Launch $n+1$ threads, one per $i \\in \\{0,\\dots,n\\}$. In thread $i$, compute $T_i^{(0)}(x^\\star),T_i^{(1)}(x^\\star),\\dots,T_i^{(n-i)}(x^\\star)$ sequentially with no inter-thread synchronization, then return $T_0^{(n)}(x^\\star)$ from thread $0$.\n\nC. Parallel prefix along $i$ for each $m$: For each fixed $m$, compute all $T_i^{(m)}(x^\\star)$ by performing a parallel prefix-scan in $i$ using an associative combine operator derived from the linear blending, so that no global barrier is needed between different $i$ within the same $m$.\n\nD. Block tiling in $i$ with deferred communication: Partition the index set $\\{0,\\dots,n\\}$ into contiguous blocks of size $b$ (with $b \\ge 1$). For each block and for all $m$ from $1$ to $n$, compute all $T_i^{(m)}(x^\\star)$ whose $i$ lies in the block using only data from the same block, deferring any exchange of boundary data with neighboring blocks until all orders $m$ have been completed within each block.\n\nSelect the correct option(s). Your justification should explicitly reference the data dependencies implied by the construction of $T_i^{(m)}(x^\\star)$ from lower-order quantities, and it should address both correctness and parallel complexity for a single evaluation point $x^\\star$.", "solution": "The problem statement is first subjected to validation.\n\n**Step 1: Extract Givens**\n- Data: A set of $n+1$ samples $\\{(x_0,V_0),\\dots,(x_n,V_n)\\}$, where $x_i \\in \\mathbb{R}$ are distinct and $V_i \\in \\mathbb{R}$.\n- Task: Evaluate the unique interpolating polynomial of degree at most $n$ at a single query point $x^\\star \\in \\mathbb{R}$ using Neville's algorithm.\n- Algorithm Definition:\n    - Base Case: $T_i^{(0)}(x^\\star) \\equiv V_i$ for $i \\in \\{0,\\dots,n\\}$.\n    - Recursive Step: For $m \\in \\{1,\\dots,n\\}$ and $i \\in \\{0,\\dots,n-m\\}$, $T_i^{(m)}(x^\\star)$ is the value of the degree-$m$ interpolant for data $\\{(x_i,V_i),\\dots,(x_{i+m},V_{i+m})\\}$, constructed by linearly blending the interpolants for $\\{(x_i,V_i),\\dots,(x_{i+m-1},V_{i+m-1})\\}$ and $\\{(x_{i+1},V_{i+1}),\\dots,(x_{i+m},V_{i+m})\\}$. These correspond to $T_i^{(m-1)}(x^\\star)$ and $T_{i+1}^{(m-1)}(x^\\star)$, respectively.\n- Output: The final result is $T_0^{(n)}(x^\\star)$.\n- Analysis Goal: Determine the correct parallelization strategy for a single-point evaluation that achieves asymptotic work $O(n^2)$ and parallel depth $O(n)$.\n- Parallel Model: Fork-join with barrier synchronization, ideal load balance.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem describes Neville's algorithm for polynomial interpolation, a fundamental and correct method in numerical analysis and its applications, such as computational physics. The problem is scientifically and mathematically sound.\n- **Well-Posed**: The problem is well-posed. The existence and uniqueness of the interpolating polynomial are guaranteed since all $x_i$ are distinct. The question asks for an analysis of parallelization strategies for a well-defined algorithm, which is a standard topic in computer science and parallel computing.\n- **Objective**: The problem is stated using precise, objective mathematical and algorithmic terminology.\n- **Completeness and Consistency**: The definition of Neville's algorithm, though verbal, is standard and sufficient to derive the explicit recurrence relation. The goals for work and depth complexity are explicitly stated. The problem is self-contained and free of contradictions.\n\n**Step 3: Verdict and Action**\nThe problem statement is valid. I will proceed with the derivation and analysis.\n\nThe \"linear blending\" described in the problem statement corresponds to the standard recurrence relation for Neville's algorithm. Let $P_{i,m}(x)$ be the polynomial of degree at most $m$ that interpolates the set of points $\\{(x_i,V_i), \\dots, (x_{i+m},V_{i+m})\\}$. Then by definition, $T_i^{(m)}(x^\\star) = P_{i,m}(x^\\star)$. The recurrence is:\n$$ P_{i,m}(x) = \\frac{(x - x_{i+m}) P_{i,m-1}(x) - (x - x_i) P_{i+1,m-1}(x)}{x_i - x_{i+m}} $$\nEvaluating at the query point $x = x^\\star$, we obtain the recurrence for the values $T_i^{(m)}(x^\\star)$:\n$$ T_i^{(m)}(x^\\star) = \\frac{(x^\\star - x_{i+m}) T_i^{(m-1)}(x^\\star) - (x^\\star - x_i) T_{i+1}^{(m-1)}(x^\\star)}{x_i - x_{i+m}} $$\nThis equation reveals the fundamental data dependency: the computation of $T_i^{(m)}(x^\\star)$ requires exactly two values from the previous stage, $T_i^{(m-1)}(x^\\star)$ and $T_{i+1}^{(m-1)}(x^\\star)$.\n\nThe computation can be visualized as filling a triangular tableau, where columns correspond to the degree $m \\in \\{0, \\dots, n\\}$ and rows to the starting index $i \\in \\{0, \\dots, n-m\\}$.\n- Column $m=0$: $T_0^{(0)}, T_1^{(0)}, \\dots, T_n^{(0)}$ (the inputs $V_i$)\n- Column $m=1$: $T_0^{(1)}, T_1^{(1)}, \\dots, T_{n-1}^{(1)}$\n- ...\n- Column $m=n$: $T_0^{(n)}$ (the final answer)\n\nThe dependency structure forms a directed acyclic graph (DAG). The total number of $T_i^{(m)}$ values to compute (for $m \\ge 1$) is $\\sum_{m=1}^{n} (n-m+1) = \\frac{n(n+1)}{2}$. Each computation is an $O(1)$ operation. Thus, the total work is $O(n^2)$, which matches the problem's requirement.\n\nThe parallel depth is the length of the critical path in this DAG. Any path from an input $T_k^{(0)}$ to the output $T_0^{(n)}$ involves $n$ sequential dependency steps (one for each increment in $m$). For example, the path $T_0^{(n)} \\leftarrow T_0^{(n-1)} \\leftarrow \\dots \\leftarrow T_0^{(1)} \\leftarrow T_0^{(0)}$ has length $n$. Therefore, the parallel depth is $O(n)$, which also matches the requirement.\n\nNow, I will evaluate each proposed parallelization strategy.\n\n**A. Stage-by-stage across polynomial order**\nThis strategy proposes to compute all values for a given order $m$ in parallel, then synchronize, and proceed to order $m+1$.\n- For $m=1$, all $T_i^{(1)}(x^\\star)$ for $i \\in \\{0, \\dots, n-1\\}$ can be computed simultaneously because they only depend on values from order $m=0$, which are given.\n- After a barrier synchronization, all values for $m=1$ are available.\n- For $m=2$, all $T_i^{(2)}(x^\\star)$ for $i \\in \\{0, \\dots, n-2\\}$ can be computed simultaneously because they only depend on values from order $m=1$.\n- This proceeds for $n$ stages. In each stage $m$, all $n-m+1$ computations are independent of each other. This correctly respects the data dependencies.\n- The amount of work is $O(n^2)$. The parallel execution consists of $n$ sequential stages, each taking constant time in a fork-join model with sufficient processors. The total parallel time, or depth, is therefore $O(n)$.\n- The use of double-buffering is a correct and standard implementation detail for this type of wavefront computation to avoid race conditions during in-place updates.\nThis strategy is a correct implementation of parallelizing a wavefront algorithm.\n**Verdict: Correct.**\n\n**B. Row-parallel within the tableau**\nThis strategy assigns thread $i$ to compute the \"row\" of the tableau consisting of $T_i^{(0)}, T_i^{(1)}, \\dots, T_i^{(n-i)}$.\n- Let us analyze the computation of $T_i^{(m)}(x^\\star)$ by thread $i$. According to the recurrence, this requires $T_i^{(m-1)}(x^\\star)$ and $T_{i+1}^{(m-1)}(x^\\star)$.\n- $T_i^{(m-1)}(x^\\star)$ is computed by the same thread $i$ in its previous step. This is fine.\n- However, $T_{i+1}^{(m-1)}(x^\\star)$ must be computed by thread $i+1$.\n- The strategy specifies \"no inter-thread synchronization\". This is a fatal flaw. Thread $i$ cannot proceed with calculating $T_i^{(m)}(x^\\star)$ until it is guaranteed that thread $i+1$ has finished computing $T_{i+1}^{(m-1)}(x^\\star)$. Without synchronization, a race condition occurs, and thread $i$ may read a stale or uninitialized value, leading to an incorrect result.\n**Verdict: Incorrect.**\n\n**C. Parallel prefix along $i$ for each $m$**\nThis strategy suggests using a parallel prefix-scan algorithm for each fixed order $m$.\n- A parallel prefix operation (or scan) computes a sequence of partial results $s_k = a_0 \\otimes a_1 \\otimes \\dots \\otimes a_k$, where $\\otimes$ is an associative binary operator.\n- The recurrence for $T_i^{(m)}(x^\\star)$ depends on $T_i^{(m-1)}(x^\\star)$ and $T_{i+1}^{(m-1)}(x^\\star)$. It does not have the structure $T_i^{(m)} = T_{i-1}^{(m)} \\otimes a_i$ for some associative operator $\\otimes$ and input $a_i$. The dependency is on elements from the *previous* level ($m-1$), not on an adjacent element at the *same* level $m$.\n- Therefore, the computational structure of Neville's algorithm is incompatible with the parallel prefix pattern. One cannot formulate the computation of the set $\\{T_i^{(m)}\\}_{i=0}^{n-m}$ as a prefix scan.\n**Verdict: Incorrect.**\n\n**D. Block tiling in $i$ with deferred communication**\nThis strategy proposes to partition the data points into blocks and perform all computations within a block before communicating.\n- Let a block of threads handle initial indices $i$ in some range $[j, j+b-1]$.\n- To compute $T_i^{(m)}(x^\\star)$, one needs the values of original data points from index $i$ to $i+m$. The \"domain of dependence\" for $T_i^{(m)}$ grows with $m$.\n- For example, to compute $T_j^{(m)}$ for $m \\ge 1$, we need data points up to $(x_{j+m}, V_{j+m})$. If $m \\ge b$, the point $x_{j+m}$ is outside the initial block of data corresponding to indices $[j, j+b-1]$.\n- The strategy states that one computes for \"all $m$ from $1$ to $n$\" within a block, and only then exchanges boundary data. This is fundamentally impossible. To compute $T_j^{(2)}$, for instance, one needs $T_j^{(1)}$ and $T_{j+1}^{(1)}$. The value $T_{j+b-1}^{(1)}$ requires $V_{j+b}$, which is outside the block. Thus, communication to get $V_{j+b}$ is needed to even complete the $m=1$ stage for the entire block.\n- Correct tiled algorithms for such wavefront computations exist, but they require communication between blocks *after each stage* (or a small number of stages) of computation, not deferred until the very end. The proposed strategy mischaracterizes the data flow.\n**Verdict: Incorrect.**\n\nIn summary, only strategy A correctly describes a valid parallelization of Neville's algorithm that meets the specified complexity targets.", "answer": "$$\\boxed{A}$$", "id": "2417610"}]}