{"hands_on_practices": [{"introduction": "Applying numerical methods often begins with translating a standard formula into a functional algorithm. This first practice focuses on implementing the composite Simpson's 3/8 rule, a classic closed Newton-Cotes formula, to solve a tangible problem from calculus: finding the volume of a solid of revolution [@problem_id:2418036]. This exercise provides a solid foundation in constructing a composite quadrature rule from its mathematical definition and applying it to a smooth, well-behaved integrand.", "problem": "Write a complete, runnable program that computes the volume of the solid of revolution generated by rotating the curve $y=\\mathrm{e}^{-x^{2}}$ about the $x$-axis over a finite interval $[a,b]$ by approximating the corresponding definite integral using the closed Newtonâ€“Cotes quadrature rule of degree three, commonly known as Simpson's 3/8 rule. The program must accept no input and must hard-code a test suite of parameter triples $(a,b,n)$, where $a$ and $b$ are real numbers specifying the integration limits and $n$ is a positive integer specifying the number of subintervals. The number $n$ must be a positive integer multiple of $3$. The program must produce the numerical approximation of the volume, for each test case, as a floating-point number. Angles do not appear anywhere in this problem. No physical units are required in the output.\n\nUse the following test suite, expressed as the list of triples $(a,b,n)$:\n- Case $1$: $(a,b,n)=\\big(0,1,300\\big)$.\n- Case $2$: $(a,b,n)=\\big(0,1,3\\big)$.\n- Case $3$: $(a,b,n)=\\big(-1,1,300\\big)$.\n- Case $4$: $(a,b,n)=\\big(0,10^{-3},3\\big)$.\n- Case $5$: $(a,b,n)=\\big(0.5,0.5,3\\big)$.\n\nYour program must apply Simpson's 3/8 rule to approximate the volume for each case, using the standard formula for the volume of a solid of revolution about the $x$-axis. The final program output must be a single line containing a Python-style list of the five results in the order of the cases above, with each result printed in scientific notation with exactly $12$ digits after the decimal point, and with no additional text. For example, the output format must look like a single line\n[result1,result2,result3,result4,result5]\nwhere each result is a floating-point number formatted in scientific notation with exactly $12$ digits after the decimal point (for instance, $\\texttt{1.234000000000e+00}$), and there are no spaces in the list.\n\nThe required final output type is a single list of $5$ floating-point numbers printed on one line, as specified above. The program must not print anything else.", "solution": "The problem presented is to compute the volume of a solid of revolution using a specific numerical quadrature method, namely the composite Simpson's 3/8 rule. The problem is well-defined, scientifically sound, and internally consistent. We shall proceed with its formal solution.\n\nThe volume $V$ of a solid generated by revolving a curve defined by a function $y = g(x)$ about the $x$-axis over the interval $[a, b]$ is given by the definite integral:\n$$ V = \\int_a^b \\pi [g(x)]^2 \\, dx $$\nIn this problem, the function is specified as $g(x) = \\mathrm{e}^{-x^{2}}$. Substituting this into the volume formula, we obtain the integral to be evaluated:\n$$ V = \\int_a^b \\pi \\left(\\mathrm{e}^{-x^{2}}\\right)^2 \\, dx = \\int_a^b \\pi \\mathrm{e}^{-2x^{2}} \\, dx $$\nThis integral does not possess a closed-form solution in terms of elementary functions. Therefore, a numerical approximation is necessary, as stipulated. The problem requires the use of the composite Simpson's 3/8 rule.\n\nLet the integrand be denoted as $f(x) = \\pi \\mathrm{e}^{-2x^{2}}$. We are tasked with approximating the integral $I = \\int_a^b f(x) \\, dx$.\nThe composite Simpson's 3/8 rule is derived by dividing the integration interval $[a, b]$ into $n$ subintervals of equal width, where $n$ must be a positive integer multiple of $3$. The width of each subinterval is $h = \\frac{b-a}{n}$. The interval is partitioned by points $x_i = a + i h$ for $i = 0, 1, 2, \\ldots, n$.\n\nThe composite rule is formed by summing the basic Simpson's 3/8 rule over consecutive groups of three subintervals. The basic rule over an interval $[x_k, x_{k+3}]$ is:\n$$ \\int_{x_k}^{x_{k+3}} f(x) \\, dx \\approx \\frac{3h}{8} [f(x_k) + 3f(x_{k+1}) + 3f(x_{k+2}) + f(x_{k+3})] $$\nSumming these approximations over the entire range of integration from $i=0$ to $n/3-1$ for groups of three subintervals $[x_{3i}, x_{3i+3}]$, we obtain the composite formula:\n$$ I = \\sum_{i=0}^{(n/3) - 1} \\int_{x_{3i}}^{x_{3i+3}} f(x) \\, dx \\approx \\sum_{i=0}^{(n/3) - 1} \\frac{3h}{8} [f(x_{3i}) + 3f(x_{3i+1}) + 3f(x_{3i+2}) + f(x_{3i+3})] $$\nExpanding and collecting terms for the entire sum gives the general formula for the composite Simpson's 3/8 rule:\n$$ I \\approx \\frac{3h}{8} \\left[ f(x_0) + 3f(x_1) + 3f(x_2) + 2f(x_3) + 3f(x_4) + \\ldots + 3f(x_{n-1}) + f(x_n) \\right] $$\nThe pattern of coefficients is $\\{1, 3, 3, 2, 3, 3, 2, \\ldots, 2, 3, 3, 1\\}$. More formally, the integral approximation $I_S$ is:\n$$ I_S = \\frac{3h}{8} \\left( f(x_0) + f(x_n) + 2 \\sum_{j=1}^{n/3 - 1} f(x_{3j}) + 3 \\sum_{i \\in \\{1, \\dots, n-1\\}, i \\pmod 3 \\neq 0} f(x_i) \\right) $$\nAn efficient algorithmic formulation for the sum within the brackets is:\n$$ S = \\sum_{i=0}^{n} w_i f(x_i) $$\nwhere the weights $w_i$ are defined as:\n$$ w_i = \\begin{cases} 1 & \\text{if } i=0 \\text{ or } i=n \\\\ 2 & \\text{if } i \\pmod 3 = 0 \\text{ and } 0 < i < n \\\\ 3 & \\text{if } i \\pmod 3 \\neq 0 \\text{ and } 0 < i < n \\end{cases} $$\nThe final approximation for the volume is then $V \\approx \\frac{3h}{8} S$.\n\nThe algorithm to be implemented is as follows:\n1.  For each test case $(a, b, n)$, calculate the step size $h = \\frac{b-a}{n}$. Note that if $a = b$, then $h = 0$, which correctly yields a volume of $V=0$.\n2.  Generate the set of $n+1$ points $x_i$ from $a$ to $b$ inclusive, i.e., $x_i = a + i h$ for $i \\in \\{0, 1, \\dots, n\\}$.\n3.  Define the integrand function $f(x) = \\pi e^{-2x^2}$.\n4.  Evaluate $f(x_i)$ for all points $x_i$.\n5.  Compute the weighted sum $S = \\sum_{i=0}^{n} w_i f(x_i)$ using the coefficients $w_i$ as defined above.\n6.  Calculate the final volume estimate $V = \\frac{3h}{8} S$.\nThis procedure will be applied to each of the provided test cases. The implementation will use vector operations for computational efficiency and to reduce the likelihood of indexing errors. An array of points $x$ is generated, the function $f$ is applied element-wise, an array of weights $w$ is constructed according to the rule, and the result is computed via a dot product of the weights and function values, scaled by the factor $\\frac{3h}{8}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volume of a solid of revolution using Simpson's 3/8 rule.\n    \"\"\"\n    # The problem specifies the function y = exp(-x^2) is rotated about the x-axis.\n    # The volume is given by the integral of pi * y^2.\n    # The integrand is therefore f(x) = pi * exp(-2*x^2).\n    integrand = lambda x: np.pi * np.exp(-2 * x**2)\n\n    # The test suite is given as a list of triples (a, b, n).\n    # a, b are integration limits, and n is the number of subintervals.\n    test_cases = [\n        (0.0, 1.0, 300),\n        (0.0, 1.0, 3),\n        (-1.0, 1.0, 300),\n        (0.0, 1.0e-3, 3),\n        (0.5, 0.5, 3),\n    ]\n\n    results = []\n    \n    # Process each test case.\n    for a, b, n in test_cases:\n        # The composite Simpson's 3/8 rule requires n to be a multiple of 3.\n        # This is satisfied by all test cases.\n\n        # Calculate the width of each subinterval.\n        # If a=b, h will be 0, correctly yielding a volume of 0 after multiplication.\n        h = (b - a) / n\n\n        # Generate the n+1 evaluation points for the interval [a, b].\n        x_points = np.linspace(a, b, n + 1)\n\n        # Evaluate the integrand at these points.\n        y_values = integrand(x_points)\n\n        # Construct the weight coefficients for Simpson's 3/8 rule.\n        # The pattern of weights is {1, 3, 3, 2, 3, 3, ..., 2, 3, 3, 1}.\n        weights = np.full(n + 1, 3.0)\n        weights[0] = 1.0\n        weights[-1] = 1.0\n        # For interior points with an index divisible by 3, the weight is 2.\n        # Slicing `weights[3:-1:3]` correctly targets these points for n > 3.\n        # For n=3, the slice is empty, so no change is made, which is correct.\n        weights[3:-1:3] = 2.0\n\n        # Compute the integral approximation by taking the dot product of weights\n        # and function values, then scaling by the rule's constant factor.\n        integral_approximation = (3 * h / 8) * np.dot(weights, y_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format specifier \"{:.12e}\" ensures scientific notation with 12 digits\n    # after the decimal point.\n    output_string = \",\".join([f\"{res:.12e}\" for res in results])\n    print(f\"[{output_string}]\")\n\nsolve()\n```", "id": "2418036"}, {"introduction": "While many physical problems involve smooth functions, we often encounter improper integrals with singularities at the boundaries of the integration domain. This practice explores how to numerically handle such cases, where standard closed Newton-Cotes rules would fail by attempting to evaluate the function at the singularity [@problem_id:2418007]. By implementing the composite midpoint rule, an *open* Newton-Cotes formula, you will discover an elegant and effective technique for accurately integrating functions with integrable endpoint singularities, thereby broadening your numerical toolkit.", "problem": "You are to write a complete, runnable program that computes composite open Newtonâ€“Cotes quadrature approximations for integrals with possible algebraic endpoint singularities and reports absolute errors against known analytic values. For an integrable function $f$ on an interval $[a,b]$ and a positive integer $N$, define the composite open Newtonâ€“Cotes quadrature based on the degree-$0$ interpolant (the midpoint quadrature) by\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(a + \\left(k+\\tfrac{1}{2}\\right)h\\right), \\quad h \\equiv \\frac{b-a}{N}.\n$$\nFor each test case below, compute the approximation $Q_N[f;[a,b]]$, the exact integral\n$$\nI \\equiv \\int_a^b f(x)\\,dx,\n$$\nand the absolute error $E \\equiv \\lvert Q_N[f;[a,b]] - I \\rvert$. Angles, where applicable, must be interpreted in radians.\n\nTest suite (each item specifies $f(x)$, $[a,b]$, $N$, and the exact value $I$):\n- Case 1 (boundary minimal resolution): $f(x)=x^{-1/2}$ on $[a,b]=[0,1]$, with $N=1$, and $I=2$.\n- Case 2 (increased resolution): $f(x)=x^{-1/2}$ on $[a,b]=[0,1]$, with $N=8$, and $I=2$.\n- Case 3 (large $N$ on one-endpoint singularity): $f(x)=x^{-1/2}$ on $[a,b]=[0,1]$, with $N=1024$, and $I=2$.\n- Case 4 (singularity at the right endpoint): $f(x)=(1-x)^{-1/2}$ on $[a,b]=[0,1]$, with $N=64$, and $I=2$.\n- Case 5 (singularities at both endpoints): $f(x)=x^{-1/2}(1-x)^{-1/2}$ on $[a,b]=[0,1]$, with $N=1024$, and $I=\\pi$.\n- Case 6 (strong but integrable left-endpoint singularity): $f(x)=x^{-0.9}$ on $[a,b]=[0,1]$, with $N=1000$, and $I=10$.\n- Case 7 (smooth baseline, angles in radians): $f(x)=\\sin(x)$ on $[a,b]=[0,\\pi]$, with $N=100$, and $I=2$.\n- Case 8 (very short interval near a singular endpoint): $f(x)=x^{-1/2}$ on $[a,b]=[0,10^{-6}]$, with $N=4$, and $I=2\\sqrt{10^{-6}}$.\n\nYour program must compute the absolute errors $E$ for the cases above in the given order and produce a single line of output containing the list of these errors as a comma-separated list enclosed in square brackets, with each floating-point number formatted in scientific notation with $12$ significant digits. For example, the required format is\n\"[1.23456789012e+00,3.40000000000e-05,...]\".", "solution": "The problem statement is a valid exercise in computational physics and numerical analysis. It requires the implementation and application of the composite midpoint quadrature rule to approximate definite integrals, including several cases involving improper integrals with algebraic singularities at the endpoints.\n\nThe quadrature rule to be implemented is the composite midpoint rule, a degree-$0$ open Newtonâ€“Cotes formula. For a given integrable function $f(x)$ on an interval $[a,b]$ and $N$ subintervals, the approximation $Q_N[f;[a,b]]$ is defined as:\n$$\nQ_N[f;[a,b]] \\equiv h \\sum_{k=0}^{N-1} f\\!\\left(x_k\\right),\n$$\nwhere the step size is $h = \\frac{b-a}{N}$ and the evaluation points $x_k$ are the midpoints of the subintervals, given by:\n$$\nx_k = a + \\left(k+\\frac{1}{2}\\right)h, \\quad \\text{for} \\quad k \\in \\{0, 1, \\dots, N-1\\}.\n$$\nThe core task is to compute the absolute error $E = \\lvert Q_N[f;[a,b]] - I \\rvert$, where $I$ is the provided exact analytical value of the integral $\\int_a^b f(x)\\,dx$.\n\nA critical feature of the problem is the presence of integrands with endpoint singularities, such as $f(x) = x^{-1/2}$ on $[0,1]$ or $f(x) = x^{-1/2}(1-x)^{-1/2}$ on $[0,1]$. These functions are non-finite at one or both endpoints. The composite midpoint rule is an *open* quadrature formula, meaning it does not evaluate the integrand at the interval endpoints $a$ and $b$. The set of evaluation points $\\{x_k\\}$ is strictly contained within the open interval $(a,b)$. The first point is $x_0 = a + \\frac{h}{2}$ and the last point is $x_{N-1} = b - \\frac{h}{2}$. This property is fundamentally important, as it ensures that the algorithm never attempts to evaluate the function at a singularity, thereby avoiding division-by-zero errors and other fatal computational issues. The method is thus well-suited for numerically approximating this class of improper integrals, provided they are convergent. All integrals specified in the test suite are indeed convergent.\n\nThe computational procedure is as follows:\n$1$. A reusable function is constructed to compute the quadrature $Q_N[f;[a,b]]$. This function takes the integrand $f$, the interval limits $a$ and $b$, and the number of subintervals $N$ as input.\n$2$. The step size $h$ is calculated as $(b-a)/N$. For numerical stability, all calculations are performed using double-precision floating-point arithmetic (`float64` in `numpy`).\n$3$. A vector of the $N$ evaluation points $x_k$ is generated. Using vectorized operations, such as those provided by the `numpy` library, is highly efficient for this task. The points are generated by the formula $a + (\\text{np.arange}(N) + 0.5) \\cdot h$.\n$4$. The integrand $f$ is evaluated at this vector of points to produce a vector of function values, $f(x_k)$.\n$5$. The sum of these values is computed and multiplied by $h$ to yield the final approximation $Q_N$.\n$6$. This process is iterated for each of the eight test cases defined in the problem statement. For each case, the corresponding integrand (represented as a `lambda` function), interval, number of subintervals, and exact integral value are used.\n$7$. The absolute error $E$ is calculated for each case by taking the absolute difference between the numerical approximation $Q_N$ and the given exact value $I$.\n$8$. The resulting list of absolute errors is then formatted into a single string. Each error value is represented in scientific notation with $12$ significant digits of precision, as required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes composite midpoint quadrature approximations for integrals\n    and calculates the absolute error against known analytic values.\n    \"\"\"\n\n    def midpoint_quadrature(f, a, b, N):\n        \"\"\"\n        Calculates the composite midpoint rule approximation for the integral of f from a to b.\n\n        Args:\n            f (callable): The integrand function.\n            a (float): The lower limit of integration.\n            b (float): The upper limit of integration.\n            N (int): The number of subintervals.\n\n        Returns:\n            float: The numerical approximation of the integral.\n        \"\"\"\n        if N <= 0:\n            raise ValueError(\"Number of subintervals N must be positive.\")\n        \n        h = (b - a) / N\n        \n        # Generate the sequence of k values: 0, 1, ..., N-1\n        k = np.arange(N)\n        \n        # Calculate the midpoints of the N subintervals\n        x_k = a + (k + 0.5) * h\n        \n        # Evaluate the function at all midpoints in a vectorized manner\n        f_values = f(x_k)\n        \n        # Compute the sum and multiply by the subinterval width h\n        approximation = h * np.sum(f_values)\n        \n        return approximation\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (integrand_lambda, a, b, N, exact_I)\n    test_cases = [\n        # Case 1: boundary minimal resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 1, 2.0),\n        # Case 2: increased resolution\n        (lambda x: x**(-0.5), 0.0, 1.0, 8, 2.0),\n        # Case 3: large N on one-endpoint singularity\n        (lambda x: x**(-0.5), 0.0, 1.0, 1024, 2.0),\n        # Case 4: singularity at the right endpoint\n        (lambda x: (1.0 - x)**(-0.5), 0.0, 1.0, 64, 2.0),\n        # Case 5: singularities at both endpoints\n        (lambda x: x**(-0.5) * (1.0 - x)**(-0.5), 0.0, 1.0, 1024, np.pi),\n        # Case 6: strong but integrable left-endpoint singularity\n        (lambda x: x**(-0.9), 0.0, 1.0, 1000, 10.0),\n        # Case 7: smooth baseline, angles in radians\n        (lambda x: np.sin(x), 0.0, np.pi, 100, 2.0),\n        # Case 8: very short interval near a singular endpoint\n        (lambda x: x**(-0.5), 0.0, 1e-6, 4, 2.0 * np.sqrt(1e-6)),\n    ]\n\n    absolute_errors = []\n    for f_integrand, a_val, b_val, N_val, I_exact in test_cases:\n        # Calculate the numerical approximation Q_N\n        Q_N = midpoint_quadrature(f_integrand, a_val, b_val, N_val)\n        \n        # Compute the absolute error\n        error = np.abs(Q_N - I_exact)\n        absolute_errors.append(error)\n\n    # Format the results into the required output string.\n    # The format specifier '.11e' provides 12 significant digits.\n    # (1 digit before the decimal + 11 digits after).\n    formatted_errors = [f\"{err:.11e}\" for err in absolute_errors]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_errors)}]\")\n\nsolve()\n```", "id": "2418007"}, {"introduction": "The true power of numerical integration lies in creating algorithms that adapt to the function being integrated, concentrating effort only where it is most needed. This advanced practice guides you through the construction of an adaptive quadrature routine based on Simpson's rule, a cornerstone of modern scientific computing libraries [@problem_id:2417964]. You will implement a recursive strategy that uses a clever local error estimate to automatically refine the integration grid, leading to a highly efficient and accurate method for tackling a wide range of integrands.", "problem": "You are to implement an adaptive quadrature algorithm based on the three-node closed Newtonâ€“Cotes rule (Simpsonâ€™s rule) to approximate definite integrals and to analyze the recursion depth required to meet a specified absolute tolerance. Your implementation must be fully recursive, use a rigorous local error estimate derived from comparing a single-interval approximation with a two-subinterval composition, and report the maximum call stack depth encountered. All trigonometric function arguments are to be interpreted in radians.\n\nFundamental base: Start from the definition of the definite integral as the limit of Riemann sums and from the principle of interpolatory quadrature: approximate a function $f(x)$ on an interval $[a,b]$ with a low-degree polynomial passing through sampled points and integrate that polynomial exactly. Use the three-node closed Newtonâ€“Cotes quadrature, applied recursively by subdividing intervals. Derive a termination criterion that guarantees the absolute error of the returned approximation is no larger than a specified tolerance $\\,\\varepsilon\\,$ by comparing the approximation over $[a,b]$ with the sum of approximations over $[a,c]$ and $[c,b]$, where $c=(a+b)/2$. You must design the recursion to pass already computed function values so as to avoid redundant evaluations.\n\nYour function must:\n- Accept a function $f$, an interval $[a,b]$, and an absolute tolerance $\\,\\varepsilon>0$.\n- Use a recursive adaptive refinement strategy based on the three-node closed Newtonâ€“Cotes formula on $[a,b]$, and two subintervals $[a,c]$ and $[c,b]$ with $c=(a+b)/2$.\n- Use a mathematically justified local error estimate obtained by comparing the one-interval approximation on $[a,b]$ and the two-subinterval composition on $[a,c]$ and $[c,b]$ to decide whether to accept the approximation or to recurse further.\n- Split the tolerance among subproblems in a way that ensures the global absolute error does not exceed $\\,\\varepsilon$.\n- Track and return the maximum call stack depth. Define the depth of the top-level call as $0$, and increment by $1$ upon each recursive call.\n- Include a hard limit on recursion depth to guarantee termination in worst-case scenarios; if this limit is reached, return the best currently available composite approximation on that branch.\n\nTest suite:\nImplement your program to run the following test cases. For each case, compute the approximate integral and the maximum recursion depth encountered. There are no physical units; report only dimensionless quantities. All angles are in radians.\n\n- Test $1$: $f(x)=\\sin(x)$ on $[0,\\pi]$ with tolerance $\\varepsilon=10^{-10}$.\n- Test $2$: $f(x)=\\exp(-x^2)$ on $[0,1]$ with tolerance $\\varepsilon=10^{-8}$.\n- Test $3$: $f(x)=\\dfrac{1}{1+25x^2}$ on $[-1,1]$ with tolerance $\\varepsilon=10^{-8}$.\n- Test $4$: $f(x)=x^8-x^4+1$ on $[0,1]$ with tolerance $\\varepsilon=10^{-12}$.\n- Test $5$ (boundary-scale case): $f(x)=\\cos(x)$ on $[0,10^{-6}]$ with tolerance $\\varepsilon=10^{-14}$.\n- Test $6$ (localized feature): $f(x)=\\exp\\!\\big(-100\\,(x-0.3)^2\\big)$ on $[0,1]$ with tolerance $\\varepsilon=10^{-8}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each test case contributes a two-element list $[I_{\\text{approx}},d_{\\max}]$ with $I_{\\text{approx}}$ the floating-point approximation of the integral and $d_{\\max}$ the integer maximum recursion depth. For example, the overall output must look like\n\"[[I1,d1],[I2,d2],[I3,d3],[I4,d4],[I5,d5],[I6,d6]]\"\nwith no spaces. Replace $I1,\\dots,I6$ and $d1,\\dots,d6$ by your computed values.\n\nConstraints and notes:\n- Implement the recursive algorithm directly; do not rely on prebuilt quadrature adaptivity from external libraries.\n- Ensure that recursive calls reuse already evaluated function values at shared nodes to avoid redundant evaluations.\n- Choose a finite maximum allowed recursion depth sufficiently large to handle the given tolerances without premature termination in typical smooth cases.", "solution": "The problem is valid. It presents a well-defined task in computational physics: to implement and analyze an adaptive quadrature algorithm based on Simpson's rule. The problem is scientifically grounded in the principles of numerical integration and error analysis, is self-contained, and provides a clear and objective set of requirements and test cases.\n\nThe objective is to approximate the definite integral $I = \\int_a^b f(x) dx$ to within a specified absolute error tolerance $\\varepsilon$. The method to be employed is an adaptive quadrature based on the three-node closed Newtonâ€“Cotes formula, commonly known as Simpson's rule.\n\nFirst, we establish the base quadrature rule. Simpson's rule approximates the integrand $f(x)$ with a quadratic polynomial that interpolates $f(x)$ at three equally spaced points: the endpoints $a$ and $b$, and the midpoint $c = (a+b)/2$. The integral of this polynomial provides an approximation to the integral of $f(x)$. The formula for a single interval $[a, b]$ is given by:\n$$ S(a,b) = \\frac{b-a}{6}\\left[f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b)\\right] $$\nThe error of this approximation, $E = I - S(a,b)$, can be shown via Taylor series expansion to be:\n$$ E(a,b) = -\\frac{(b-a)^5}{2880} f^{(4)}(\\xi) $$\nfor some $\\xi \\in (a,b)$. This shows that Simpson's rule is exact for polynomials of degree up to $3$, as for such polynomials the fourth derivative $f^{(4)}(x)$ is identically zero.\n\nAn adaptive strategy is required to achieve a global error tolerance $\\varepsilon$ efficiently. This involves subdividing the interval $[a,b]$ into smaller subintervals where the function $f(x)$ changes more rapidly, and using larger subintervals where it is smoother. The core of the adaptive algorithm lies in a robust local error estimate.\n\nTo derive this estimate, we compare two approximations for the integral over $[a,b]$. The first is the coarse approximation $S_1$, obtained by applying Simpson's rule once over the entire interval:\n$$ S_1 = S(a,b) $$\nThe second is a more refined approximation, $S_2$, obtained by bisecting the interval at $c=(a+b)/2$ and summing the results of Simpson's rule applied to each subinterval, $[a,c]$ and $[c,b]$:\n$$ S_2 = S(a,c) + S(c,b) $$\nLet $I$ be the true value of the integral over $[a,b]$. The errors for $S_1$ and $S_2$ are $E_1 = I - S_1$ and $E_2 = I - S_2$, respectively. If we assume that the fourth derivative $f^{(4)}(x)$ is approximately constant over the interval $[a,b]$, we can relate these two errors. The length of the subintervals for $S_2$ is half that of $S_1$. The error of Simpson's rule is proportional to the fifth power of the interval length, so the error of $S_2$ is approximately $2 \\times (1/2)^5 = 1/16$ of the error of $S_1$.\n$$ E_2 \\approx \\frac{1}{16} E_1 $$\nWe can now estimate the error using the computable quantities $S_1$ and $S_2$:\n$$ I \\approx S_1 + E_1 \\approx S_1 + 16 E_2 $$\n$$ I \\approx S_2 + E_2 $$\nEquating these expressions for $I$ yields $S_1 + 16 E_2 \\approx S_2 + E_2$, which simplifies to:\n$$ 15 E_2 \\approx S_2 - S_1 $$\nThis provides a practical estimate for the error of the more accurate approximation, $S_2$:\n$$ |E_2| = |I - S_2| \\approx \\frac{|S_2 - S_1|}{15} $$\n\nThe recursive algorithm proceeds as follows. A function is defined to compute the integral over an interval $[a,b]$ with a local tolerance $\\text{tol}$.\n1.  Given the interval $[a,b]$ and pre-computed function values $f(a)$, $f(b)$, and $f(c)$ where $c=(a+b)/2$, calculate the coarse approximation $S_1$ and the refined approximation $S_2$. This requires two new function evaluations at the midpoints of $[a,c]$ and $[c,b]$. To avoid redundant work, all computed function values are passed down during recursion.\n2.  Calculate the error estimate, $E_{\\text{est}} = |S_2 - S_1|/15$.\n3.  Compare the error estimate to the local tolerance, $\\text{tol}$. If $E_{\\text{est}} \\le \\text{tol}$, the approximation $S_2$ is deemed sufficiently accurate for this interval. The value $S_2$ (which is more accurate than $S_1$) is returned, and the recursion on this branch terminates.\n4.  If $E_{\\text{est}} > \\text{tol}$, the interval must be refined. The algorithm calls itself recursively for the two subintervals, $[a,c]$ and $[c,b]$. The tolerance is split between the two recursive calls, typically by assigning each a tolerance of $\\text{tol}/2$. This ensures that the sum of the errors from the subproblems remains bounded by the parent's tolerance.\n5.  The results from the two recursive calls are summed to produce the integral over the original interval $[a,b]$.\n6.  The recursion depth is tracked. The initial call is at depth $0$. Each recursive call increments the depth by $1$. The function must return not only the integral approximation but also the maximum depth reached in its branch of the computation. The final maximum depth is the maximum over all branches.\n7.  A hard limit on recursion depth is imposed to prevent stack overflow for pathological integrands. If this limit is reached, the current best approximation ($S_2$) is returned.\n\nThis process guarantees that the total absolute error over the entire integration domain $[a,b]$ is controlled to be less than the initial user-specified tolerance $\\varepsilon$, while automatically adapting the computational effort to the local behavior of the function.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_quadrature(f, a, b, tol, max_depth=50):\n    \"\"\"\n    Computes the definite integral of f from a to b using a recursive\n    adaptive Simpson's rule.\n\n    Args:\n        f (callable): The function to integrate.\n        a (float): The lower limit of integration.\n        b (float): The upper limit of integration.\n        tol (float): The desired absolute error tolerance.\n        max_depth (int): The maximum recursion depth.\n\n    Returns:\n        tuple[float, int]: A tuple containing the approximate integral and\n                           the maximum recursion depth reached.\n    \"\"\"\n    c = (a + b) / 2.0\n    fa = f(a)\n    fb = f(b)\n    fc = f(c)\n    integral, max_d = _adaptive_simpson_recursive(f, a, b, tol, 0, max_depth, fa, fb, fc)\n    return integral, max_d\n\ndef _adaptive_simpson_recursive(f, a, b, tol, depth, max_depth, fa, fb, fc):\n    \"\"\"\n    Recursive helper for adaptive Simpson's rule.\n    It reuses pre-computed function values fa=f(a), fb=f(b), fc=f((a+b)/2).\n    \"\"\"\n    h = b - a\n    c = (a + b) / 2.0\n    \n    # Coarse approximation S1 = S(a,b)\n    s1 = (h / 6.0) * (fa + 4.0 * fc + fb)\n\n    # Refined approximation S2 = S(a,c) + S(c,b)\n    d = (a + c) / 2.0\n    e = (c + b) / 2.0\n    fd = f(d)\n    fe = f(e)\n    \n    s_left = (h / 12.0) * (fa + 4.0 * fd + fc)\n    s_right = (h / 12.0) * (fc + 4.0 * fe + fb)\n    s2 = s_left + s_right\n\n    error_estimate = abs(s2 - s1) / 15.0\n\n    if depth >= max_depth:\n        # Depth limit reached, return best current estimate S2\n        return s2, depth\n\n    if error_estimate <= tol:\n        # Tolerance met, return S2 (more accurate)\n        return s2, depth\n\n    # Tolerance not met, recurse\n    next_depth = depth + 1\n    tol_sub = tol / 2.0\n    \n    left_integral, left_depth = _adaptive_simpson_recursive(f, a, c, tol_sub, next_depth, max_depth, fa, fc, fd)\n    right_integral, right_depth = _adaptive_simpson_recursive(f, c, b, tol_sub, next_depth, max_depth, fc, fb, fe)\n    \n    integral_sum = left_integral + right_integral\n    max_d = max(left_depth, right_depth)\n    \n    return integral_sum, max_d\n\n\ndef solve():\n    \"\"\"\n    Runs the adaptive quadrature algorithm on the defined test suite\n    and prints the results in the required format.\n    \"\"\"\n    \n    # Define test case functions\n    f1 = lambda x: np.sin(x)\n    f2 = lambda x: np.exp(-x**2)\n    f3 = lambda x: 1.0 / (1.0 + 25.0 * x**2)\n    f4 = lambda x: x**8 - x**4 + 1.0\n    f5 = lambda x: np.cos(x)\n    f6 = lambda x: np.exp(-100.0 * (x - 0.3)**2)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, np.pi, 1e-10),\n        (f2, 0.0, 1.0, 1e-8),\n        (f3, -1.0, 1.0, 1e-8),\n        (f4, 0.0, 1.0, 1e-12),\n        (f5, 0.0, 1e-6, 1e-14),\n        (f6, 0.0, 1.0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        f, a, b, tol = case\n        integral, max_depth = adaptive_quadrature(f, a, b, tol)\n        results.append([integral, max_depth])\n\n    # Format the results into the required string format \"[[I1,d1],[I2,d2],...]\"\n    formatted_results = [f\"[{i},{d}]\" for i, d in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2417964"}]}