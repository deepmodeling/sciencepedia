{"hands_on_practices": [{"introduction": "Theory is best understood through practice. This first exercise grounds the abstract concepts of the Hartree-Fock method in a concrete, manual calculation for the helium atom ([@problem_id:2400276]). You will use provided one- and two-electron integrals to build the Fock matrix and compute the total electronic energy from first principles, solidifying your understanding of how these fundamental components interrelate in the simplest multi-electron system.", "problem": "Consider an isolated helium atom with nuclear charge $Z=2$ treated at the closed-shell restricted Hartree–Fock (RHF) self-consistent field (SCF) level in a minimal Slater-type orbital contracted with three Gaussians (STO-3G) atomic orbital basis consisting of a single normalized $1s$-type function $\\chi_{1}$. Work in Hartree atomic units, where $\\hbar = m_{e} = e = 4\\pi \\epsilon_{0} = 1$, and assume an orthonormal basis with $S_{11}=1$. The system has two electrons occupying the single spatial orbital.\n\nYou are given the following one- and two-electron integrals over the atomic orbital $\\chi_{1}$:\n- One-electron (core) integral: $h_{11}=\\langle \\chi_{1} | \\hat{T} + \\hat{V}_{ne} | \\chi_{1} \\rangle = -2.038$.\n- Two-electron Coulomb integral: $(11|11)=\\langle \\chi_{1}\\chi_{1} | r_{12}^{-1} | \\chi_{1}\\chi_{1} \\rangle = 1.216$.\n\nUsing only first principles of the restricted Hartree–Fock formalism, manually construct the Fock matrix element $F_{11}$ from these data and then compute the total RHF electronic energy $E$ of the helium atom in this basis. Express the final energy in Hartree and round your answer to four significant figures. Your final reported result must be a single number.", "solution": "The problem is to compute the total restricted Hartree–Fock (RHF) electronic energy for a helium atom in a minimal STO-3G basis. The problem is well-posed and scientifically grounded. All necessary data are provided.\n\nThe system is a closed-shell atom with $N=2$ electrons. Both electrons occupy a single spatial orbital, which we denote as $\\psi_{1}$. This spatial orbital is constructed as a linear combination of atomic orbitals (LCAO). In this case, the basis is minimal, consisting of a single normalized $1s$-type function $\\chi_{1}$. The expansion is therefore trivial:\n$$ \\psi_{1} = c_{11} \\chi_{1} $$\nThe normalization condition for the spatial orbital is $\\langle \\psi_1 | \\psi_1 \\rangle = 1$. Expanding this gives:\n$$ \\langle c_{11} \\chi_{1} | c_{11} \\chi_{1} \\rangle = |c_{11}|^2 \\langle \\chi_{1} | \\chi_{1} \\rangle = |c_{11}|^2 S_{11} = 1 $$\nWe are given that the basis is orthonormal, meaning the overlap matrix element is $S_{11} = 1$. This implies $|c_{11}|^2 = 1$. We can choose the real, positive coefficient $c_{11}=1$, which means the spatial orbital is identical to the basis function:\n$$ \\psi_{1} = \\chi_{1} $$\nThe first step is to construct the Fock matrix. For a closed-shell RHF calculation, the elements of the Fock matrix $\\mathbf{F}$ are given by:\n$$ F_{\\mu\\nu} = h_{\\mu\\nu} + \\sum_{\\lambda\\sigma} P_{\\lambda\\sigma} \\left[ (\\mu\\nu|\\lambda\\sigma) - \\frac{1}{2}(\\mu\\lambda|\\nu\\sigma) \\right] $$\nwhere $h_{\\mu\\nu}$ are the one-electron (core) integrals, $(\\mu\\nu|\\lambda\\sigma)$ are the two-electron repulsion integrals, and $P_{\\lambda\\sigma}$ are the elements of the density matrix. The indices $\\mu, \\nu, \\lambda, \\sigma$ refer to the basis functions. In this problem, we have only one basis function, $\\chi_{1}$, so all indices must be $1$.\n\nThe density matrix elements $P_{\\lambda\\sigma}$ are defined as:\n$$ P_{\\lambda\\sigma} = 2 \\sum_{i=1}^{N/2} c_{\\lambda i}^{*} c_{\\sigma i} $$\nwhere the sum is over the occupied spatial orbitals. Here, we have one occupied orbital ($i=1$) with $N=2$ electrons, and the coefficient is $c_{11}=1$. Thus, the only non-zero density matrix element is:\n$$ P_{11} = 2 c_{11}^{*} c_{11} = 2(1)(1) = 2 $$\nNow we can construct the single element of the Fock matrix, $F_{11}$:\n$$ F_{11} = h_{11} + \\sum_{\\lambda=1} \\sum_{\\sigma=1} P_{\\lambda\\sigma} \\left[ (11|\\lambda\\sigma) - \\frac{1}{2}(1\\lambda|1\\sigma) \\right] $$\nWith $\\lambda=1$ and $\\sigma=1$, the expression simplifies to:\n$$ F_{11} = h_{11} + P_{11} \\left[ (11|11) - \\frac{1}{2}(11|11) \\right] = h_{11} + \\frac{1}{2} P_{11} (11|11) $$\nSubstituting $P_{11}=2$:\n$$ F_{11} = h_{11} + \\frac{1}{2}(2)(11|11) = h_{11} + (11|11) $$\nWe are given the integral values $h_{11} = -2.038$ and $(11|11) = 1.216$. We can now compute the numerical value of $F_{11}$:\n$$ F_{11} = -2.038 + 1.216 = -0.822 $$\nThe next step is to compute the total RHF electronic energy, $E$. A general formula for the total energy in terms of the density and Fock matrices is:\n$$ E = \\frac{1}{2} \\sum_{\\mu\\nu} P_{\\mu\\nu} (h_{\\mu\\nu} + F_{\\mu\\nu}) $$\nFor our minimal basis system, this sum collapses to a single term:\n$$ E = \\frac{1}{2} P_{11} (h_{11} + F_{11}) $$\nSubstituting the known values for $P_{11}$, $h_{11}$, and the calculated value for $F_{11}$:\n$$ E = \\frac{1}{2} (2) (-2.038 + (-0.822)) = 1 \\times (-2.860) = -2.860 $$\nThe total electronic energy is $E = -2.860$ Hartree.\n\nAlternatively, the total energy for a two-electron system in a single spatial orbital $\\psi_1$ is given by the expectation value of the electronic Hamiltonian:\n$$ E = \\langle \\Psi | \\hat{H}_{el} | \\Psi \\rangle $$\nwhere the Slater determinant is $\\Psi = \\frac{1}{\\sqrt{2}}|\\psi_1\\alpha \\psi_1\\beta|$ and $\\hat{H}_{el} = \\hat{h}_1 + \\hat{h}_2 + r_{12}^{-1}$. This evaluates to:\n$$ E = 2 \\langle \\psi_1 | \\hat{h} | \\psi_1 \\rangle + \\langle \\psi_1 \\psi_1 | r_{12}^{-1} | \\psi_1 \\psi_1 \\rangle $$\nSince $\\psi_1 = \\chi_1$, this becomes:\n$$ E = 2 h_{11} + (11|11) $$\nSubstituting the given values:\n$$ E = 2(-2.038) + 1.216 = -4.076 + 1.216 = -2.860 $$\nBoth methods yield the same result. The problem requires the answer to be rounded to four significant figures. The result $-2.860$ already has four significant figures.", "answer": "$$\n\\boxed{-2.860}\n$$", "id": "2400276"}, {"introduction": "The true power of the Hartree-Fock method is unleashed through computation. In this hands-on coding practice ([@problem_id:2400234]), you will implement both Restricted (RHF) and Unrestricted (UHF) Self-Consistent Field (SCF) solvers from the ground up for a simple atomic system. This exercise not only translates the theoretical framework into a working algorithm but also provides a powerful way to investigate the relationship between the RHF and UHF formalisms by observing the collapse of the UHF solution for a closed-shell atom.", "problem": "Implement from first principles a Self-Consistent Field (SCF) solver for both Restricted Hartree–Fock (RHF) and Unrestricted Hartree–Fock (UHF) for a closed-shell, two-electron atom or ion with a single point nucleus of charge $Z$ at the origin in atomic units. Use a fixed set of real, normalized, $s$-type Gaussian basis functions co-centered at the nucleus. Each basis function is defined by a positive exponent $\\alpha_i$ and has the spatial form $\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2}$, where $r = \\lVert \\mathbf{r} \\rVert$ and $\\mathcal{N}(\\alpha_i)$ is the normalization constant. The total number of electrons is $N_{\\mathrm{e}} = 2$ with $N_{\\alpha} = N_{\\beta} = 1$, and all computations must be performed in atomic units. There is a single nucleus, so the classical nuclear repulsion energy is zero.\n\nLet the one-electron Hamiltonian operator be $\\hat{h} = -\\frac{1}{2}\\nabla^2 - \\frac{Z}{r}$. Construct all one-electron integrals and the two-electron electron-repulsion integrals using their defining expressions:\n- Overlap integrals $S_{ij} = \\int \\phi_i(\\mathbf{r})\\,\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Kinetic integrals $T_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{1}{2}\\nabla^2\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Nuclear attraction integrals $V_{ij} = \\int \\phi_i(\\mathbf{r})\\left(-\\frac{Z}{r}\\right)\\phi_j(\\mathbf{r})\\,\\mathrm{d}^3 \\mathbf{r}$.\n- Two-electron integrals in chemists’ notation $(ij|kl) = \\int\\int \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1)\\frac{1}{\\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert}\\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2)\\,\\mathrm{d}^3 \\mathbf{r}_1\\,\\mathrm{d}^3 \\mathbf{r}_2$.\n\nUse these to form the core Hamiltonian matrix $h_{ij} = T_{ij} + V_{ij}$, the overlap matrix $S_{ij}$, and the electron-repulsion integral tensor $(ij|kl)$.\n\nFormulate the RHF and UHF SCF equations in the atomic orbital basis. In RHF, use a single spin-independent Fock matrix and a spinless density matrix for the closed-shell configuration. In UHF, build separate $\\alpha$ and $\\beta$ Fock matrices and density matrices, with the exchange operator acting only within the same spin channel. Solve the generalized eigenvalue problems for the Fock matrices with respect to the overlap metric to obtain canonical molecular orbitals and orbital energies. Iterate until convergence of the density matrices.\n\nFor each test case, after convergence:\n- Compute the maximum absolute matrix-element difference between the converged $\\alpha$ and $\\beta$ density matrices, that is $\\max_{i,j}\\lvert P^{\\alpha}_{ij} - P^{\\beta}_{ij} \\rvert$.\n- Compute the maximum absolute difference between the converged $\\alpha$ and $\\beta$ orbital energies, that is $\\max_k \\lvert \\varepsilon^{\\alpha}_k - \\varepsilon^{\\beta}_k \\rvert$.\n- Compute the absolute difference between the converged total UHF and RHF energies in Hartree, that is $\\lvert E_{\\mathrm{UHF}} - E_{\\mathrm{RHF}} \\rvert$.\n\nExpress all energy quantities in Hartree and report the three quantities for each test case as real numbers. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each result is itself a list of three floats in the order specified above, for example, \"[[x11,x12,x13],[x21,x22,x23],...]\" with no extra whitespace or text.\n\nUse the following test suite of three parameter sets, each specified by a nuclear charge $Z$ and a list of Gaussian exponents $\\{\\alpha_i\\}$:\n1. $Z = 2$, $\\{\\alpha\\} = [0.50]$.\n2. $Z = 2$, $\\{\\alpha\\} = [0.20, 0.80]$.\n3. $Z = 3$, $\\{\\alpha\\} = [0.15, 0.50, 1.20]$.\n\nThe program must implement the SCF procedure from the definitions above and produce the requested outputs for the test suite. The expected physical behavior for these closed-shell systems is that the Unrestricted Hartree–Fock (UHF) solution collapses to the Restricted Hartree–Fock (RHF) solution, leading to identical $\\alpha$ and $\\beta$ orbitals and energies; your numerical results should reflect this by returning values that are numerically indistinguishable from zero to within a reasonable tolerance. All angles, if any were to appear, must be in radians. All energies must be reported in Hartree as floats without units in the output string.", "solution": "The problem is subjected to validation and is found to be valid. It is a well-posed problem in computational quantum physics, based on established scientific principles (Hartree-Fock theory), with all necessary information provided for its solution. There are no contradictions, ambiguities, or factual inaccuracies. The task is to implement the Restricted and Unrestricted Hartree-Fock Self-Consistent Field (SCF) methods for a two-electron atomic system from first principles.\n\n### 1. Theoretical Framework\n\nThe system under consideration is a two-electron atom or ion with nuclear charge $Z$, described by the electronic Hamiltonian in atomic units:\n$$\n\\hat{H} = \\sum_{i=1}^{2} \\left( -\\frac{1}{2}\\nabla_i^2 - \\frac{Z}{r_i} \\right) + \\frac{1}{r_{12}} = \\sum_{i=1}^{2} \\hat{h}(i) + \\frac{1}{r_{12}}\n$$\nwhere $\\hat{h}(i)$ is the core Hamiltonian for electron $i$, and $r_{12} = \\lVert \\mathbf{r}_1 - \\mathbf{r}_2 \\rVert$ is the inter-electron distance. The nuclear-nuclear repulsion is zero for a single nucleus.\n\nIn the Hartree-Fock approximation, the many-electron wavefunction is approximated as a single Slater determinant. The molecular orbitals (MOs), $\\psi_a$, are expressed as a linear combination of atomic orbitals (AOs), $\\phi_i$:\n$$\n\\psi_a(\\mathbf{r}) = \\sum_{i=1}^{K} C_{ia} \\phi_i(\\mathbf{r})\n$$\nThe basis functions $\\{\\phi_i\\}$ are specified as real, normalized, s-type Gaussian functions centered at the origin:\n$$\n\\phi_i(\\mathbf{r}) = \\mathcal{N}(\\alpha_i)\\,e^{-\\alpha_i r^2} = \\left(\\frac{2\\alpha_i}{\\pi}\\right)^{3/4} e^{-\\alpha_i r^2}\n$$\nwhere $\\alpha_i$ is the exponent of the $i$-th basis function and $\\mathcal{N}(\\alpha_i)$ is its normalization constant.\n\n### 2. Integral Evaluation\n\nThe solution of the Hartree-Fock equations requires the evaluation of one- and two-electron integrals over the Gaussian basis functions. For s-type Gaussians centered at the origin, these integrals have analytical closed-form expressions.\n\n- **Overlap Integral ($S_{ij}$)**:\n$$\nS_{ij} = \\int \\phi_i(\\mathbf{r}) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\left( \\frac{2\\sqrt{\\alpha_i\\alpha_j}}{\\alpha_i+\\alpha_j} \\right)^{3/2}\n$$\n\n- **Kinetic Energy Integral ($T_{ij}$)**:\n$$\nT_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{1}{2}\\nabla^2\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = \\frac{3\\alpha_i\\alpha_j}{\\alpha_i+\\alpha_j} S_{ij}\n$$\n\n- **Nuclear Attraction Integral ($V_{ij}$)**:\n$$\nV_{ij} = \\int \\phi_i(\\mathbf{r}) \\left(-\\frac{Z}{r}\\right) \\phi_j(\\mathbf{r}) d^3\\mathbf{r} = -Z \\mathcal{N}(\\alpha_i)\\mathcal{N}(\\alpha_j) \\frac{2\\pi}{\\alpha_i+\\alpha_j} = -Z \\frac{2\\left(4\\alpha_i\\alpha_j\\right)^{3/4}}{\\sqrt{\\pi}(\\alpha_i+\\alpha_j)}\n$$\n\n- **Two-Electron Repulsion Integral (ERI) ($ij|kl$)**:\n$$\n(ij|kl) = \\iint \\phi_i(\\mathbf{r}_1)\\phi_j(\\mathbf{r}_1) \\frac{1}{r_{12}} \\phi_k(\\mathbf{r}_2)\\phi_l(\\mathbf{r}_2) d^3\\mathbf{r}_1 d^3\\mathbf{r}_2 = \\mathcal{N}_i\\mathcal{N}_j\\mathcal{N}_k\\mathcal{N}_l \\frac{2\\pi^{5/2}}{(\\alpha_i+\\alpha_j)(\\alpha_k+\\alpha_l)\\sqrt{\\alpha_i+\\alpha_j+\\alpha_k+\\alpha_l}}\n$$\nwhere $\\mathcal{N}_i, \\mathcal{N}_j, \\mathcal{N}_k, \\mathcal{N}_l$ are the respective normalization constants.\n\nThe core Hamiltonian matrix, $H_{\\mathrm{core}}$, is constructed by summing the kinetic and nuclear attraction integral matrices: $H_{\\mathrm{core}} = T + V$.\n\n### 3. Self-Consistent Field (SCF) Procedure\n\nThe SCF procedure iteratively refines the set of MO coefficients $\\{C_{ia}\\}$ until the electronic energy and density matrix converge.\n\n**A. Restricted Hartree-Fock (RHF) for Closed-Shell Systems**\n\nFor a closed-shell system ($N_\\alpha = N_\\beta$), RHF uses a single set of spatial orbitals for both spin-up and spin-down electrons. The electronic state has $N_e/2$ doubly occupied orbitals. The central equation is the Roothaan-Hall equation:\n$$\nFC = SCE\n$$\nwhere $F$ is the Fock matrix, $C$ is the matrix of MO coefficients, $S$ is the AO overlap matrix, and $E$ is a diagonal matrix of orbital energies $\\varepsilon_a$. The Fock matrix is given by:\n$$\nF = H_{\\mathrm{core}} + G(D)\n$$\nThe matrix $G$ represents the average two-electron potential, with elements:\n$$\nG_{ij} = \\sum_{k,l} D_{kl} \\left[ 2(ij|kl) - (ik|jl) \\right]\n$$\nHere, $D$ is the spinless density matrix, defined from the MO coefficients of the $N_e/2$ occupied orbitals:\n$$\nD_{kl} = \\sum_{a=1}^{N_e/2} C_{ka} C_{la}^*\n$$\nThe total RHF electronic energy is given by:\n$$\nE_{\\mathrm{RHF}} = \\sum_{i,j} D_{ij} (H_{\\mathrm{core},ij} + F_{ij}) = \\mathrm{Tr}[D(H_{\\mathrm{core}} + F)]\n$$\n\n**B. Unrestricted Hartree-Fock (UHF)**\n\nUHF allows different spatial orbitals for spin-up ($\\alpha$) and spin-down ($\\beta$) electrons. This leads to two coupled Roothaan-Hall equations:\n$$\nF^\\alpha C^\\alpha = S C^\\alpha E^\\alpha \\quad \\text{and} \\quad F^\\beta C^\\beta = S C^\\beta E^\\beta\n$$\nThe Fock matrices for each spin are:\n$$\nF^\\sigma = H_{\\mathrm{core}} + J(P^T) - K(P^\\sigma) \\quad (\\sigma = \\alpha, \\beta)\n$$\nwhere $P^\\alpha$ and $P^\\beta$ are the density matrices for $\\alpha$ and $\\beta$ electrons, and $P^T = P^\\alpha + P^\\beta$ is the total density matrix. The elements of the Coulomb ($J$) and exchange ($K$) matrices are:\n$$\nJ_{ij} = \\sum_{k,l} P^T_{lk} (ij|kl) \\qquad (K^\\sigma)_{ij} = \\sum_{k,l} P^\\sigma_{lk} (ik|jl)\n$$\nThe spin density matrices are built from their respective MO coefficients:\n$$\nP^\\alpha_{kl} = \\sum_{a=1}^{N_\\alpha} C^\\alpha_{ka} (C^\\alpha_{la})^* \\qquad P^\\beta_{kl} = \\sum_{a=1}^{N_\\beta} C^\\beta_{ka} (C^\\beta_{la})^*\n$$\nThe total UHF electronic energy is:\n$$\nE_{\\mathrm{UHF}} = \\frac{1}{2}\\sum_{i,j} \\left[ (P^\\alpha+P^\\beta)_{ji} H_{\\mathrm{core},ij} + P^\\alpha_{ji}F^\\alpha_{ij} + P^\\beta_{ji}F^\\beta_{ij} \\right] = \\frac{1}{2} \\left(\\mathrm{Tr}[P^T H_{\\mathrm{core}}] + \\mathrm{Tr}[P^\\alpha F^\\alpha] + \\mathrm{Tr}[P^\\beta F^\\beta] \\right)\n$$\n\n### 4. Algorithmic Implementation\n\nBoth RHF and UHF are solved iteratively:\n1.  **Compute Integrals**: Evaluate and store all one-electron ($S, T, V$) and two-electron ($ij|kl$) integrals. Form $H_{\\mathrm{core}}$.\n2.  **Initial Guess**: An initial guess for the density matrix is obtained by diagonalizing the core Hamiltonian. The generalized eigenvalue problem $H_{\\mathrm{core}}C = SCE$ is solved, and the MOs corresponding to the lowest energies are used to construct the initial density matrix/matrices. For UHF, the initial guess is symmetric, $P^\\alpha_0 = P^\\beta_0$.\n3.  **SCF Cycle**:\n    a. Construct the Fock matrix (or matrices for UHF) using the current density matrix/matrices.\n    b. Solve the generalized eigenvalue problem(s) $FC=SCE$ to obtain new MO coefficients and orbital energies.\n    c. Form new density matrix/matrices from the MO coefficients of the occupied orbitals ($N_e/2=1$ for RHF, $N_\\alpha=1$, $N_\\beta=1$ for UHF).\n    d. Check for convergence. The process is stopped if the maximum absolute change in the density matrix elements between iterations is below a threshold (e.g., $10^{-9}$).\n    e. If not converged, mix the new and old density matrices to aid stability and repeat the cycle.\n4.  **Post-SCF**: Once converged, compute the total electronic energy and the required observables. For the specified closed-shell systems, the UHF solution is expected to collapse to the RHF solution, meaning $P^\\alpha \\approx P^\\beta$, $\\varepsilon^\\alpha_k \\approx \\varepsilon^\\beta_k$, and $E_{\\mathrm{UHF}} \\approx E_{\\mathrm{RHF}}$. The program calculates the maximum absolute differences between these quantities.", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh, inv, sqrtm\n\ndef solve():\n    \"\"\"\n    Main solver function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {'Z': 2, 'alphas': [0.50]},\n        {'Z': 2, 'alphas': [0.20, 0.80]},\n        {'Z': 3, 'alphas': [0.15, 0.50, 1.20]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        Z = case['Z']\n        alphas = np.array(case['alphas'])\n        num_basis = len(alphas)\n        n_elec = 2\n        n_alpha = 1\n        n_beta = 1\n\n        # 1. Compute integrals\n        S, T, V, eri = compute_integrals(alphas, Z)\n        H_core = T + V\n\n        # 2. Run RHF and UHF\n        rhf_E, D_conv, _ = run_rhf(H_core, eri, S, n_elec, num_basis)\n        uhf_E, P_alpha_conv, P_beta_conv, eps_alpha, eps_beta = run_uhf(\n            H_core, eri, S, n_alpha, n_beta, num_basis\n        )\n\n        # 3. Compute final quantities\n        diff_P = np.max(np.abs(P_alpha_conv - P_beta_conv))\n        diff_eps = np.max(np.abs(eps_alpha - eps_beta))\n        diff_E = np.abs(uhf_E - rhf_E)\n        \n        all_results.append([diff_P, diff_eps, diff_E])\n    \n    # Format output as specified: \"[[x11,x12,x13],[x21,x22,x23],...]\"\n    result_str = \",\".join([f\"[{v[0]},{v[1]},{v[2]}]\" for v in all_results])\n    print(f\"[{result_str}]\")\n\n\ndef compute_integrals(alphas, Z):\n    \"\"\"\n    Computes all one- and two-electron integrals for s-type Gaussians at the origin.\n    \"\"\"\n    num_basis = len(alphas)\n    S = np.zeros((num_basis, num_basis))\n    T = np.zeros((num_basis, num_basis))\n    V = np.zeros((num_basis, num_basis))\n    eri = np.zeros((num_basis, num_basis, num_basis, num_basis))\n\n    # One-electron integrals\n    for i in range(num_basis):\n        for j in range(num_basis):\n            alpha_i = alphas[i]\n            alpha_j = alphas[j]\n            \n            # Overlap\n            S[i, j] = (2 * np.sqrt(alpha_i * alpha_j) / (alpha_i + alpha_j))**1.5\n            \n            # Kinetic\n            T[i, j] = 3 * alpha_i * alpha_j / (alpha_i + alpha_j) * S[i, j]\n            \n            # Nuclear Attraction\n            term1 = 2 * (4 * alpha_i * alpha_j)**0.75\n            term2 = np.sqrt(np.pi) * (alpha_i + alpha_j)\n            V[i, j] = -Z * term1 / term2\n    \n    # Two-electron integrals (ERI)\n    for i in range(num_basis):\n        for j in range(num_basis):\n            for k in range(num_basis):\n                for l in range(num_basis):\n                    alpha_i, alpha_j, alpha_k, alpha_l = alphas[i], alphas[j], alphas[k], alphas[l]\n                    p = alpha_i + alpha_j\n                    q = alpha_k + alpha_l\n                    \n                    term1 = 16 * (alpha_i * alpha_j * alpha_k * alpha_l)**0.75\n                    term2 = np.sqrt(np.pi) * p * q * np.sqrt(p + q)\n                    eri[i, j, k, l] = term1 / term2\n    \n    return S, T, V, eri\n\n\ndef run_rhf(H_core, eri, S, n_elec, num_basis):\n    \"\"\"\n    Performs the RHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n    n_occ = n_elec // 2\n\n    # Initial guess\n    _, C = eigh(H_core, S)\n    D = C[:, :n_occ] @ C[:, :n_occ].T\n\n    for i in range(max_iter):\n        D_old = D.copy()\n        \n        # Build G matrix\n        J = np.einsum('kl,ijkl->ij', D, eri)\n        K = np.einsum('kl,ikjl->ij', D, eri)\n        G = 2 * J - K\n        \n        # Form Fock matrix\n        F = H_core + G\n        \n        # Solve Roothaan-Hall equations\n        eps, C = eigh(F, S)\n        \n        # Form new density matrix\n        D = C[:, :n_occ] @ C[:, :n_occ].T\n        \n        # Damping/Mixing\n        D = (1 - mixing_alpha) * D_old + mixing_alpha * D\n        \n        # Check convergence\n        if np.max(np.abs(D - D_old)) < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = np.sum(D * (H_core + F))\n    \n    return E, D, eps\n\n\ndef run_uhf(H_core, eri, S, n_alpha, n_beta, num_basis):\n    \"\"\"\n    Performs the UHF-SCF calculation.\n    \"\"\"\n    max_iter = 100\n    conv_tol = 1e-9\n    mixing_alpha = 0.5\n\n    # Initial guess (symmetric)\n    _, C = eigh(H_core, S)\n    P_alpha = C[:, :n_alpha] @ C[:, :n_alpha].T\n    P_beta = C[:, :n_beta] @ C[:, :n_beta].T\n\n    for i in range(max_iter):\n        P_alpha_old = P_alpha.copy()\n        P_beta_old = P_beta.copy()\n        \n        P_total = P_alpha + P_beta\n        \n        # Build J and K matrices\n        J = np.einsum('lk,ijkl->ij', P_total, eri)\n        K_alpha = np.einsum('lk,ikjl->ij', P_alpha, eri)\n        K_beta = np.einsum('lk,ikjl->ij', P_beta, eri)\n        \n        # Form Fock matrices\n        F_alpha = H_core + J - K_alpha\n        F_beta = H_core + J - K_beta\n        \n        # Solve Roothaan-Hall equations for each spin\n        eps_alpha, C_alpha = eigh(F_alpha, S)\n        eps_beta, C_beta = eigh(F_beta, S)\n        \n        # Form new density matrices\n        P_alpha = C_alpha[:, :n_alpha] @ C_alpha[:, :n_alpha].T\n        P_beta = C_beta[:, :n_beta] @ C_beta[:, :n_beta].T\n        \n        # Damping/Mixing\n        P_alpha = (1 - mixing_alpha) * P_alpha_old + mixing_alpha * P_alpha\n        P_beta = (1 - mixing_alpha) * P_beta_old + mixing_alpha * P_beta\n        \n        # Check convergence\n        delta = max(np.max(np.abs(P_alpha - P_alpha_old)), \n                    np.max(np.abs(P_beta - P_beta_old)))\n        if delta < conv_tol:\n            break\n            \n    # Calculate final energy\n    E = 0.5 * (np.sum(P_total * H_core) + np.sum(P_alpha * F_alpha) + np.sum(P_beta * F_beta))\n    \n    return E, P_alpha, P_beta, eps_alpha, eps_beta\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2400234"}, {"introduction": "What truly distinguishes the Hartree-Fock method from a classical mean-field theory is the exchange interaction, a purely quantum mechanical effect with a deeply non-intuitive property: non-locality. This coding exercise ([@problem_id:2400245]) provides a direct, hands-on demonstration of this concept. By implementing the action of the exchange operator on a grid, you will see precisely how the exchange potential at one point in space depends on the behavior of an orbital across the entire system, a feature with no classical analogue.", "problem": "You are to implement, from first principles, the action of the Hartree–Fock exchange operator on a spatial orbital in a one-dimensional model that explicitly exhibits non-locality. Consider a closed-shell system with a finite set of occupied spatial orbitals $\\{\\psi_j(x)\\}_{j=1}^M$ and define the exchange operator $K$ acting on a spatial orbital $\\phi(x)$ by\n$$\n(K\\phi)(x) \\;=\\; \\sum_{j=1}^{M} \\psi_j(x)\\,\\int_{-L}^{L} w(x,x')\\,\\psi_j(x')\\,\\phi(x')\\,dx' \\,,\n$$\nwhere the interaction kernel is the soft-Coulomb potential\n$$\nw(x,x') \\;=\\; \\frac{1}{\\sqrt{(x-x')^2 + \\alpha^2}} \\,,\n$$\nwith softness parameter $\\alpha&gt;0$. All quantities are dimensionless in this model.\n\nTo make this definition computable and testable, work on a uniform grid on the interval $[-L,L]$ with the following fixed parameters:\n- Domain half-length $L = 10$.\n- Number of grid points $N = 801$.\n- Grid points $x_i$ uniformly spaced on $[-L,L]$, with spacing $\\Delta x = \\dfrac{2L}{N-1}$.\n\nDiscretize the exchange operator by replacing integrals with Riemann sums over the uniform grid:\n$$\n(K\\phi)(x_i) \\;=\\; \\sum_{j=1}^{M} \\psi_j(x_i) \\left( \\Delta x \\sum_{k=1}^{N} w(x_i,x_k)\\,\\psi_j(x_k)\\,\\phi(x_k) \\right) \\,.\n$$\n\nUse $M=2$ occupied spatial orbitals, modeled as Gaussians on the grid:\n- Define a Gaussian centered at $c$ with width parameter $\\sigma$ by\n$$\ng(x;c,\\sigma) \\;=\\; \\exp\\!\\left( -\\frac{(x-c)^2}{2\\sigma^2} \\right).\n$$\n- The occupied orbitals are\n$$\n\\psi_1(x) \\propto g(x;c_1,\\sigma_1),\\quad \\psi_2(x) \\propto g(x;c_2,\\sigma_2),\n$$\nwith $c_1=-2.5$, $\\sigma_1=0.7$, $c_2=+2.5$, $\\sigma_2=1.0$.\n- Normalize each occupied orbital numerically on the grid so that the discrete $\\ell^2$ norm equals $1$, i.e.,\n$$\n\\sum_{i=1}^{N} |\\psi_j(x_i)|^2 \\,\\Delta x \\;=\\; 1 \\quad \\text{for each } j \\in \\{1,2\\}.\n$$\n\nAll Gaussian test orbitals specified below must also be numerically normalized on the grid to have discrete $\\ell^2$ norm equal to $1$ before use. For linear combinations, use the linear combination as written without any further renormalization, unless explicitly stated.\n\nImplement a function apply_K that takes a grid-represented spatial orbital $\\phi$ and returns the grid-represented $(K\\phi)$ using the above definitions and discretization.\n\nConstruct the following test suite. In all cases, the operator is defined with the above occupied orbitals and grid, and the kernel softness parameter $\\alpha$ is specified per case.\n\n- Test $1$ (Linearity residual):\n  - Use $\\alpha=0.5$.\n  - Let $\\phi_1 \\propto g(x;0.0,0.8)$ and $\\phi_2 \\propto g(x;3.0,0.5)$, both normalized.\n  - Let $a=1.3$ and $b=-0.7$.\n  - Compute the discrete $\\ell^2$ norm\n  $$\n  r_1 \\;=\\; \\left\\| K\\!\\left( a\\,\\phi_1 + b\\,\\phi_2 \\right) \\;-\\; a\\,K(\\phi_1) \\;-\\; b\\,K(\\phi_2) \\right\\|_2,\n  $$\n  where $\\|f\\|_2 = \\sqrt{\\sum_{i=1}^{N} |f(x_i)|^2 \\,\\Delta x}$.\n\n- Test $2$ (Non-locality at a point):\n  - Use $\\alpha=0.5$.\n  - Let the base orbital $\\phi_b \\propto g(x;-6.0,0.5)$ and the distant perturbation $\\delta \\propto g(x;+6.0,0.3)$, both normalized.\n  - Let $\\epsilon=0.10$ and $x_0=0.0$.\n  - Define $\\phi_{\\mathrm{pert}} = \\phi_b + \\epsilon\\,\\delta$ (do not renormalize $\\phi_{\\mathrm{pert}}$).\n  - Compute\n  $$\n  r_2 \\;=\\; \\left| (K\\phi_{\\mathrm{pert}})(x_0) \\;-\\; (K\\phi_b)(x_0) \\right|.\n  $$\n\n- Test $3$ (Zero input):\n  - Use $\\alpha=0.5$.\n  - Let $\\phi_0(x) \\equiv 0$ on the grid.\n  - Compute the discrete $\\ell^\\infty$ norm of $K(\\phi_0)$,\n  $$\n  r_3 \\;=\\; \\max_{1 \\le i \\le N} \\left| (K\\phi_0)(x_i) \\right|.\n  $$\n\n- Test $4$ (Soft kernel, small softness):\n  - Use $\\alpha=0.2$.\n  - Let $\\phi \\propto g(x;0.0,0.7)$ normalized.\n  - Compute\n  $$\n  r_4 \\;=\\; \\left\\| K(\\phi) \\right\\|_2.\n  $$\n\n- Test $5$ (Soft kernel, large softness):\n  - Use $\\alpha=2.0$.\n  - With the same normalized $\\phi \\propto g(x;0.0,0.7)$ as in Test $4$, compute\n  $$\n  r_5 \\;=\\; \\left\\| K(\\phi) \\right\\|_2.\n  $$\n\nYour program must implement the above definitions exactly and produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[r_1,r_2,r_3,r_4,r_5]$. All outputs are dimensionless real numbers. Do not print any other text. For example, the output should look like\n\"[0.0,0.1,0.0,1.2,0.7]\"\nbut with the actual computed values for $r_1$, $r_2$, $r_3$, $r_4$, and $r_5$ for the specified test suite.", "solution": "The problem requires the implementation and testing of a one-dimensional Hartree-Fock exchange operator, a fundamental concept in computational quantum physics. The validity of the problem statement is confirmed, as it is scientifically grounded, well-posed, and provides all necessary parameters and definitions for a direct, verifiable computation. We shall proceed with a systematic, principle-based solution.\n\nThe core of the problem is to compute the action of the exchange operator $K$ on a spatial orbital $\\phi(x)$. The operator is defined by the integral transformation:\n$$\n(K\\phi)(x) \\;=\\; \\sum_{j=1}^{M} \\psi_j(x)\\,\\int_{-L}^{L} w(x,x')\\,\\psi_j(x')\\,\\phi(x')\\,dx'\n$$\nwhere $\\{\\psi_j(x)\\}_{j=1}^M$ are the occupied orbitals and $w(x,x')$ is the interaction kernel.\n\nFirst, we establish the computational domain. The problem is defined on the interval $[-L, L]$ with $L=10$. This interval is discretized into a uniform grid of $N=801$ points, denoted by the vector $\\mathbf{x} = (x_1, x_2, \\dots, x_N)$. The grid spacing is constant, given by $\\Delta x = \\frac{2L}{N-1}$. Any continuous function $f(x)$ is thus represented by a vector $\\mathbf{f}$ of its values at the grid points, $\\mathbf{f} = (f(x_1), f(x_2), \\dots, f(x_N))$.\n\nThe occupied orbitals, $\\psi_1(x)$ and $\\psi_2(x)$, and the test orbitals are based on the Gaussian function:\n$$\ng(x;c,\\sigma) \\;=\\; \\exp\\!\\left( -\\frac{(x-c)^2}{2\\sigma^2} \\right)\n$$\nFor computational purposes, these orbitals are represented as vectors on the grid. They must be normalized according to the discrete $\\ell^2$ inner product, such that the norm is unity:\n$$\n\\|\\psi_j\\|_2 = \\sqrt{\\sum_{i=1}^{N} |\\psi_j(x_i)|^2 \\,\\Delta x} \\;=\\; 1\n$$\nThis is achieved by first evaluating the unnormalized Gaussian function on the grid to obtain a vector $\\mathbf{g}$, computing its discrete norm $\\|\\mathbf{g}\\|_2$, and then scaling the vector as $\\boldsymbol{\\psi}_j = \\mathbf{g} / \\|\\mathbf{g}\\|_2$. The specified occupied orbitals are $\\psi_1 \\propto g(x; c_1=-2.5, \\sigma_1=0.7)$ and $\\psi_2 \\propto g(x; c_2=2.5, \\sigma_2=1.0)$, with $M=2$.\n\nThe integral in the definition of the exchange operator is discretized using a Riemann sum. The action of the operator on a grid-represented orbital $\\boldsymbol{\\phi}$ yields a new grid-represented orbital $\\mathbf{K\\phi}$, where the $i$-th component is:\n$$\n(\\mathbf{K\\phi})_i \\;=\\; (K\\phi)(x_i) \\;=\\; \\sum_{j=1}^{M} \\psi_j(x_i) \\left( \\Delta x \\sum_{k=1}^{N} w(x_i,x_k)\\,\\psi_j(x_k)\\,\\phi(x_k) \\right)\n$$\nThe interaction kernel $w(x,x') = \\frac{1}{\\sqrt{(x-x')^2 + \\alpha^2}}$ is represented by an $N \\times N$ matrix $\\mathbf{W}$, where its elements are $W_{ik} = w(x_i, x_k)$.\n\nTo translate this expression into an efficient numerical algorithm, we leverage matrix-vector operations. For each occupied orbital $\\boldsymbol{\\psi}_j$:\n1.  Form the element-wise product of $\\boldsymbol{\\psi}_j$ and the input orbital $\\boldsymbol{\\phi}$. Let us call this vector $\\boldsymbol{\\rho}_j$, with elements $(\\boldsymbol{\\rho}_j)_k = \\psi_j(x_k)\\,\\phi(x_k)$.\n2.  The inner summation over $k$ is now a matrix-vector product between the kernel matrix $\\mathbf{W}$ and the vector $\\boldsymbol{\\rho}_j$. Let us define the resulting vector as $\\mathbf{I}_j = \\Delta x \\, (\\mathbf{W} \\boldsymbol{\\rho}_j)$. The components of this vector are $(\\mathbf{I}_j)_i = \\Delta x \\sum_{k=1}^{N} W_{ik} (\\boldsymbol{\\rho}_j)_k$.\n3.  The final result is obtained by summing the contributions from all occupied orbitals. For each $j$, the contribution is the element-wise product of $\\boldsymbol{\\psi}_j$ and $\\mathbf{I}_j$.\n$$\n\\mathbf{K\\phi} \\;=\\; \\sum_{j=1}^{M} \\boldsymbol{\\psi}_j \\odot \\mathbf{I}_j \\;=\\; \\sum_{j=1}^{M} \\boldsymbol{\\psi}_j \\odot \\left( \\Delta x \\cdot (\\mathbf{W} (\\boldsymbol{\\psi}_j \\odot \\boldsymbol{\\phi})) \\right)\n$$\nwhere $\\odot$ denotes the element-wise (Hadamard) product. This fully vectorized approach is implemented using the `NumPy` library.\n\nThe test suite is designed to verify fundamental properties of the operator and its dependence on the softness parameter $\\alpha$:\n- **Test 1:** Verifies the linearity of the operator. The quantity $r_1 = \\| K(a\\phi_1 + b\\phi_2) - aK(\\phi_1) - bK(\\phi_2) \\|_2$ should be zero in exact arithmetic. The computed value will be a small number on the order of machine floating-point precision, representing the numerical error.\n- **Test 2:** Demonstrates the non-local nature of the exchange interaction. The change at a point $x_0$, $|(K\\phi_{\\mathrm{pert}})(x_0) - (K\\phi_b)(x_0)|$, is computed, where $\\phi_{\\mathrm{pert}}$ differs from $\\phi_b$ only by a small perturbation at a distant location. A non-zero result confirms that the operator's value at $x_0$ depends on the input function's values across the entire domain.\n- **Test 3:** Confirms that a zero input orbital maps to a zero output orbital, a direct consequence of linearity. The result $r_3 = \\|K(\\mathbf{0})\\|_\\infty$ must be exactly $0.0$.\n- **Tests 4 and 5:** Investigate the behavior of the operator as the softness parameter $\\alpha$ is varied. We compute the norm of the result, $\\|K(\\phi)\\|_2$, for a small $\\alpha=0.2$ and a large $\\alpha=2.0$. A smaller $\\alpha$ leads to a more sharply peaked kernel, resembling the true Coulomb potential more closely and resulting in a stronger interaction (larger norm). Conversely, a larger $\\alpha$ 'softens' or smooths the interaction, leading to a weaker effect (smaller norm).\n\nThe implementation will construct a function for each test, which will be called in sequence to generate the final list of results $[r_1, r_2, r_3, r_4, r_5]$.", "answer": "```python\nimport numpy as np\n\ndef gaussian(x, c, sigma):\n    \"\"\"\n    Computes a Gaussian function on the grid x.\n\n    Args:\n        x (np.ndarray): The 1D grid.\n        c (float): The center of the Gaussian.\n        sigma (float): The width parameter of the Gaussian.\n\n    Returns:\n        np.ndarray: The Gaussian function evaluated on the grid.\n    \"\"\"\n    return np.exp(-((x - c)**2) / (2 * sigma**2))\n\ndef normalize(psi, dx):\n    \"\"\"\n    Normalizes a grid-represented orbital to have a discrete l2 norm of 1.\n\n    Args:\n        psi (np.ndarray): The orbital on the grid.\n        dx (float): The grid spacing.\n\n    Returns:\n        np.ndarray: The normalized orbital.\n    \"\"\"\n    norm_sq = np.sum(np.abs(psi)**2) * dx\n    if norm_sq == 0.0:\n        return psi\n    return psi / np.sqrt(norm_sq)\n\ndef l2_norm(f, dx):\n    \"\"\"\n    Computes the discrete l2 norm of a function on the grid.\n\n    Args:\n        f (np.ndarray): The function on the grid.\n        dx (float): The grid spacing.\n\n    Returns:\n        float: The l2 norm.\n    \"\"\"\n    return np.sqrt(np.sum(np.abs(f)**2) * dx)\n\ndef apply_K(phi, occupied_orbitals, W, dx):\n    \"\"\"\n    Applies the discretized Hartree-Fock exchange operator K to an orbital phi.\n\n    Args:\n        phi (np.ndarray): The input orbital on the grid.\n        occupied_orbitals (list of np.ndarray): List of occupied orbitals.\n        W (np.ndarray): The pre-computed interaction kernel matrix.\n        dx (float): The grid spacing.\n\n    Returns:\n        np.ndarray: The resulting orbital K(phi) on the grid.\n    \"\"\"\n    K_phi = np.zeros_like(phi)\n    for psi_j in occupied_orbitals:\n        rho_j = psi_j * phi\n        integral_vector = dx * np.dot(W, rho_j)\n        K_phi += psi_j * integral_vector\n    return K_phi\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Hartree-Fock exchange operator.\n    \"\"\"\n    # --- Global Parameters and Grid Setup ---\n    L = 10.0\n    N = 801\n    dx = (2 * L) / (N - 1)\n    x = np.linspace(-L, L, N)\n\n    # --- Occupied Orbitals Setup ---\n    c1, sigma1 = -2.5, 0.7\n    c2, sigma2 = 2.5, 1.0\n    M = 2\n\n    psi1_un = gaussian(x, c1, sigma1)\n    psi2_un = gaussian(x, c2, sigma2)\n\n    psi1 = normalize(psi1_un, dx)\n    psi2 = normalize(psi2_un, dx)\n    occupied_orbitals = [psi1, psi2]\n\n    results = []\n\n    # --- Test 1: Linearity Residual ---\n    alpha1 = 0.5\n    a, b = 1.3, -0.7\n    phi1_un = gaussian(x, 0.0, 0.8)\n    phi2_un = gaussian(x, 3.0, 0.5)\n    phi1 = normalize(phi1_un, dx)\n    phi2 = normalize(phi2_un, dx)\n\n    x_col = x[:, np.newaxis]\n    x_row = x[np.newaxis, :]\n    W1 = 1.0 / np.sqrt((x_col - x_row)**2 + alpha1**2)\n    \n    phi_lin_comb = a * phi1 + b * phi2\n    K_phi_lin_comb = apply_K(phi_lin_comb, occupied_orbitals, W1, dx)\n    K_phi1 = apply_K(phi1, occupied_orbitals, W1, dx)\n    K_phi2 = apply_K(phi2, occupied_orbitals, W1, dx)\n    \n    residual1 = K_phi_lin_comb - (a * K_phi1 + b * K_phi2)\n    r1 = l2_norm(residual1, dx)\n    results.append(r1)\n\n    # --- Test 2: Non-locality at a point ---\n    alpha2 = 0.5\n    epsilon = 0.10\n    x0 = 0.0\n    i0 = np.where(x == x0)[0][0]\n    \n    phi_b_un = gaussian(x, -6.0, 0.5)\n    delta_un = gaussian(x, 6.0, 0.3)\n    phi_b = normalize(phi_b_un, dx)\n    delta = normalize(delta_un, dx)\n    \n    phi_pert = phi_b + epsilon * delta\n\n    # W1 from Test 1 can be reused as alpha is the same\n    W2 = W1\n    K_phi_pert = apply_K(phi_pert, occupied_orbitals, W2, dx)\n    K_phi_b = apply_K(phi_b, occupied_orbitals, W2, dx)\n    \n    r2 = np.abs(K_phi_pert[i0] - K_phi_b[i0])\n    results.append(r2)\n\n    # --- Test 3: Zero input ---\n    alpha3 = 0.5\n    phi0 = np.zeros(N)\n    \n    # W1 from Test 1 can be reused\n    W3 = W1\n    K_phi0 = apply_K(phi0, occupied_orbitals, W3, dx)\n    \n    r3 = np.max(np.abs(K_phi0)) # l_infty norm\n    results.append(r3)\n\n    # --- Test 4: Soft kernel, small softness ---\n    alpha4 = 0.2\n    phi_test_un = gaussian(x, 0.0, 0.7)\n    phi_test = normalize(phi_test_un, dx)\n    \n    W4 = 1.0 / np.sqrt((x_col - x_row)**2 + alpha4**2)\n    K_phi4 = apply_K(phi_test, occupied_orbitals, W4, dx)\n    \n    r4 = l2_norm(K_phi4, dx)\n    results.append(r4)\n\n    # --- Test 5: Soft kernel, large softness ---\n    alpha5 = 2.0\n    # Use the same normalized phi_test from Test 4\n    \n    W5 = 1.0 / np.sqrt((x_col - x_row)**2 + alpha5**2)\n    K_phi5 = apply_K(phi_test, occupied_orbitals, W5, dx)\n    \n    r5 = l2_norm(K_phi5, dx)\n    results.append(r5)\n\n    # --- Final Output ---\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400245"}]}