{"hands_on_practices": [{"introduction": "Before we can turn to a computer for answers, we must first master the art of translating a physical or geometric problem into the language of mathematicsâ€”specifically, into a definite integral. This exercise serves as a fundamental drill in this process. By calculating the surface area of a patch on a torus, you will practice the essential vector calculus steps required to set up a surface integral, reinforcing the theoretical foundation upon which numerical methods are built [@problem_id:2415007].", "problem": "A standard torus arises in computational physics when evaluating geometric factors in flux calculations and surface integrals. Consider the torus embedded in three-dimensional Euclidean space with major radius $R$ and minor radius $r$, parameterized by angles $\\theta$ and $\\phi$ according to\n$$\nx(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\cos\\phi,\\quad\ny(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\sin\\phi,\\quad\nz(\\theta,\\phi) = r \\sin\\theta,\n$$\nwhere $-\\pi \\le \\theta \\le \\pi$ and $0 \\le \\phi < 2\\pi$. All angles are measured in radians. A surface patch $\\mathcal{P}$ is defined by the parameter domain $\\theta \\in \\left[-\\frac{\\pi}{3},\\,\\frac{\\pi}{6}\\right]$ and $\\phi \\in \\left[\\frac{\\pi}{4},\\,\\frac{5\\pi}{4}\\right]$. Let $R=3$ and $r=1$.\n\nStarting from the definition of surface area for a smooth parametric surface embedded in three-dimensional Euclidean space, express the area of $\\mathcal{P}$ as a double integral over the parameter domain and evaluate it exactly in closed form. Provide the exact analytic value for the area. Do not approximate or round the result.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- Parametric equations for a torus:\n  $x(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\cos\\phi$\n  $y(\\theta,\\phi) = \\left(R + r \\cos\\theta\\right)\\sin\\phi$\n  $z(\\theta,\\phi) = r \\sin\\theta$\n- Parameter domain for the entire torus: $-\\pi \\le \\theta \\le \\pi$ and $0 \\le \\phi < 2\\pi$.\n- Parameter domain for the surface patch $\\mathcal{P}$: $\\theta \\in \\left[-\\frac{\\pi}{3},\\,\\frac{\\pi}{6}\\right]$ and $\\phi \\in \\left[\\frac{\\pi}{4},\\,\\frac{5\\pi}{4}\\right]$.\n- Constants: Major radius $R=3$ and minor radius $r=1$.\n- Objective: Express the area of $\\mathcal{P}$ as a double integral and evaluate it exactly.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is based on standard vector calculus and the geometry of surfaces of revolution. The parameterization of a torus is a well-established mathematical construct.\n- **Well-Posedness**: The problem is well-posed. It provides a specific parameterization, a well-defined domain of integration, and specific values for all parameters. The task, calculating the surface area, is a standard problem in multivariable calculus with a unique solution.\n- **Objectivity**: The problem is stated using precise, objective mathematical language.\n- **Flaw Analysis**:\n  1. The problem is free of scientific or factual unsoundness. The condition $R > r$ (specifically, $3 > 1$) ensures the torus is a standard, non-self-intersecting ring torus.\n  2. The problem is formalizable and relevant to its stated field. Calculating surface integrals is fundamental in many areas of physics and engineering.\n  3. The setup is complete and consistent. All necessary information is provided.\n  4. The conditions are physically and mathematically realistic.\n  5. The problem is well-structured and unambiguous.\n  6. The result is verifiable through standard mathematical derivation.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. A solution will be derived.\n\nThe area $A$ of a smooth parametric surface $\\mathbf{r}(u, v)$ defined over a domain $D$ in the $uv$-plane is given by the integral:\n$$ A = \\iint_D \\left\\| \\frac{\\partial\\mathbf{r}}{\\partial u} \\times \\frac{\\partial\\mathbf{r}}{\\partial v} \\right\\| \\,du\\,dv $$\nFor the given torus, the parameters are $\\theta$ and $\\phi$. The position vector is:\n$$ \\mathbf{r}(\\theta, \\phi) = \\langle (R + r \\cos\\theta)\\cos\\phi, (R + r \\cos\\theta)\\sin\\phi, r \\sin\\theta \\rangle $$\nFirst, we compute the partial derivatives with respect to $\\theta$ and $\\phi$:\n$$ \\frac{\\partial\\mathbf{r}}{\\partial\\theta} = \\mathbf{r}_\\theta = \\langle -r\\sin\\theta\\cos\\phi, -r\\sin\\theta\\sin\\phi, r\\cos\\theta \\rangle $$\n$$ \\frac{\\partial\\mathbf{r}}{\\partial\\phi} = \\mathbf{r}_\\phi = \\langle -(R + r\\cos\\theta)\\sin\\phi, (R + r\\cos\\theta)\\cos\\phi, 0 \\rangle $$\nNext, we compute the cross product $\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi$:\n$$ \\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ -r\\sin\\theta\\cos\\phi & -r\\sin\\theta\\sin\\phi & r\\cos\\theta \\\\ -(R+r\\cos\\theta)\\sin\\phi & (R+r\\cos\\theta)\\cos\\phi & 0 \\end{vmatrix} $$\nThe components of the cross product are:\n- $\\mathbf{i}$: $( -r\\sin\\theta\\sin\\phi )(0) - ( r\\cos\\theta )((R+r\\cos\\theta)\\cos\\phi) = -r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi$\n- $\\mathbf{j}$: $( r\\cos\\theta )(-(R+r\\cos\\theta)\\sin\\phi) - ( -r\\sin\\theta\\cos\\phi )(0) = -r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi$\n- $\\mathbf{k}$: $( -r\\sin\\theta\\cos\\phi )((R+r\\cos\\theta)\\cos\\phi) - ( -r\\sin\\theta\\sin\\phi )(-(R+r\\cos\\theta)\\sin\\phi)$\n   $= -r(R+r\\cos\\theta)\\sin\\theta(\\cos^2\\phi + \\sin^2\\phi) = -r(R+r\\cos\\theta)\\sin\\theta$\nSo, the cross product vector is:\n$$ \\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi = \\langle -r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi, -r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi, -r(R+r\\cos\\theta)\\sin\\theta \\rangle $$\nNow, we find the magnitude of this vector:\n$$ \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\|^2 = \\left(-r(R+r\\cos\\theta)\\cos\\theta\\cos\\phi\\right)^2 + \\left(-r(R+r\\cos\\theta)\\cos\\theta\\sin\\phi\\right)^2 + \\left(-r(R+r\\cos\\theta)\\sin\\theta\\right)^2 $$\nFactor out the common term $r^2(R+r\\cos\\theta)^2$:\n$$ \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\|^2 = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta\\cos^2\\phi + \\cos^2\\theta\\sin^2\\phi + \\sin^2\\theta \\right) $$\n$$ = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta(\\cos^2\\phi + \\sin^2\\phi) + \\sin^2\\theta \\right) $$\n$$ = r^2(R+r\\cos\\theta)^2 \\left( \\cos^2\\theta + \\sin^2\\theta \\right) = r^2(R+r\\cos\\theta)^2 $$\nThe magnitude, which represents the differential surface element $dS$, is the square root:\n$$ dS = \\|\\mathbf{r}_\\theta \\times \\mathbf{r}_\\phi\\| = \\sqrt{r^2(R+r\\cos\\theta)^2} = |r(R+r\\cos\\theta)| $$\nGiven $R=3$ and $r=1$, we have $R > r > 0$. The term $R+r\\cos\\theta = 3+\\cos\\theta$ is always positive, since $\\cos\\theta \\in [-1, 1]$. Therefore, the absolute value is redundant.\n$$ dS = r(R+r\\cos\\theta)d\\theta d\\phi $$\nThe area of the patch $\\mathcal{P}$ is the integral of $dS$ over the specified domain $D = \\{(\\theta, \\phi) | -\\frac{\\pi}{3} \\le \\theta \\le \\frac{\\pi}{6}, \\frac{\\pi}{4} \\le \\phi \\le \\frac{5\\pi}{4}\\}$:\n$$ A = \\iint_D r(R+r\\cos\\theta) \\,d\\theta\\,d\\phi = \\int_{\\pi/4}^{5\\pi/4} \\int_{-\\pi/3}^{\\pi/6} r(R+r\\cos\\theta) \\,d\\theta\\,d\\phi $$\nSubstitute the values $R=3$ and $r=1$:\n$$ A = \\int_{\\pi/4}^{5\\pi/4} \\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta\\,d\\phi $$\nSince the integrand $(3+\\cos\\theta)$ does not depend on $\\phi$, the integral is separable:\n$$ A = \\left(\\int_{\\pi/4}^{5\\pi/4} d\\phi\\right) \\left(\\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta\\right) $$\nEvaluate each integral separately. The integral with respect to $\\phi$ is:\n$$ \\int_{\\pi/4}^{5\\pi/4} d\\phi = [\\phi]_{\\pi/4}^{5\\pi/4} = \\frac{5\\pi}{4} - \\frac{\\pi}{4} = \\frac{4\\pi}{4} = \\pi $$\nThe integral with respect to $\\theta$ is:\n$$ \\int_{-\\pi/3}^{\\pi/6} (3+\\cos\\theta) \\,d\\theta = [3\\theta + \\sin\\theta]_{-\\pi/3}^{\\pi/6} $$\n$$ = \\left(3\\left(\\frac{\\pi}{6}\\right) + \\sin\\left(\\frac{\\pi}{6}\\right)\\right) - \\left(3\\left(-\\frac{\\pi}{3}\\right) + \\sin\\left(-\\frac{\\pi}{3}\\right)\\right) $$\n$$ = \\left(\\frac{\\pi}{2} + \\frac{1}{2}\\right) - \\left(-\\pi - \\sin\\left(\\frac{\\pi}{3}\\right)\\right) $$\n$$ = \\left(\\frac{\\pi}{2} + \\frac{1}{2}\\right) - \\left(-\\pi - \\frac{\\sqrt{3}}{2}\\right) $$\n$$ = \\frac{\\pi}{2} + \\frac{1}{2} + \\pi + \\frac{\\sqrt{3}}{2} = \\frac{3\\pi}{2} + \\frac{1+\\sqrt{3}}{2} = \\frac{3\\pi + 1 + \\sqrt{3}}{2} $$\nThe total area $A$ is the product of the two results:\n$$ A = (\\pi) \\left(\\frac{3\\pi + 1 + \\sqrt{3}}{2}\\right) = \\frac{3\\pi^2 + \\pi + \\pi\\sqrt{3}}{2} $$\nThis is the exact analytical value for the area of the surface patch $\\mathcal{P}$.", "answer": "$$\\boxed{\\frac{3\\pi^2 + \\pi + \\pi\\sqrt{3}}{2}}$$", "id": "2415007"}, {"introduction": "With the ability to formulate a multidimensional integral, we can now tackle a classic problem in computational physics: numerically verifying a fundamental physical law. This practice challenges you to compute the electric flux through a closed surface and compare your result to the elegant prediction from Gauss's Law. This hands-on coding exercise demonstrates how to decompose a complex problem into manageable parts and apply standard numerical quadrature routines to solve a real-world physics problem [@problem_id:2415017].", "problem": "You are asked to write a complete, runnable program that numerically evaluates the total electric flux through a closed cubical surface due to a point charge and compares the result against the prediction from Gauss's Law. Work in vacuum under the International System of Units (SI). All physical answers involving flux must be expressed in $\\mathrm{N \\cdot m^2/C}$.\n\nA point charge of magnitude $q$ located at position $\\mathbf{r}_0 = (x_q,y_q,z_q)$ in vacuum produces an electric field given by Coulombâ€™s law,\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{4\\pi \\varepsilon_0}\\,\\frac{q\\,(\\mathbf{r}-\\mathbf{r}_0)}{\\lVert \\mathbf{r}-\\mathbf{r}_0\\rVert^3},\n$$\nwhere $\\varepsilon_0$ is the vacuum permittivity. The total electric flux $\\Phi$ through a closed surface $S$ is defined as\n$$\n\\Phi = \\iint_S \\mathbf{E}\\cdot d\\mathbf{A},\n$$\nwhere $d\\mathbf{A}$ is the outward-pointing area element. Gaussâ€™s Law states that for a point charge, the exact flux through any closed surface is\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0},\n$$\nwhere $q_{\\text{enclosed}}=q$ if the charge lies strictly inside the closed surface and $q_{\\text{enclosed}}=0$ if it lies strictly outside. Cases in which the charge lies exactly on the surface are not considered here.\n\nLet the closed surface be an axis-aligned cube of side length $L>0$ centered at $\\mathbf{c}=(c_x,c_y,c_z)$, so its six faces are the planes $x=c_x\\pm L/2$, $y=c_y\\pm L/2$, and $z=c_z\\pm L/2$ with outward normals.\n\nYour program must:\n- Numerically compute the surface integral $\\Phi=\\iint_S \\mathbf{E}\\cdot d\\mathbf{A}$ by integrating over the six faces. Do not assume any symmetry reduction.\n- Determine $q_{\\text{enclosed}}$ by testing whether $(x_q,y_q,z_q)$ lies strictly within the open cube $(c_x-L/2,c_x+L/2)\\times(c_y-L/2,c_y+L/2)\\times(c_z-L/2,c_z+L/2)$.\n- Compute the absolute error $\\Delta=\\lvert \\Phi-\\Phi_{\\text{exact}}\\rvert$ for each test case.\n- Express each $\\Delta$ in $\\mathrm{N \\cdot m^2/C}$ and round each value to six significant figures in scientific notation in the final output.\n\nUse the vacuum permittivity $\\varepsilon_0=8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$, and assume standard SI values for all quantities. Any angles internal to your numerical method, if used, must be in radians.\n\nTest suite: Your program must evaluate the cases below, where $L$ is in $\\mathrm{m}$, positions are in $\\mathrm{m}$, and $q$ is in $\\mathrm{C}$.\n- Case $1$: $\\mathbf{c}=(0,0,0)$, $L=2$, $\\mathbf{r}_0=(0,0,0)$, $q=1.0\\times 10^{-6}$.\n- Case $2$: $\\mathbf{c}=(0,0,0)$, $L=2$, $\\mathbf{r}_0=(3,0,0)$, $q=1.0\\times 10^{-6}$.\n- Case $3$: $\\mathbf{c}=(0.2,-0.1,0.3)$, $L=1.4$, $\\mathbf{r}_0=(0.8,-0.1,0.3)$, $q=-2.0\\times 10^{-6}$.\n- Case $4$: $\\mathbf{c}=(1.0,1.0,1.0)$, $L=0.5$, $\\mathbf{r}_0=(1.1,1.1,1.1)$, $q=5.0\\times 10^{-7}$.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where the $k$-th entry is the absolute error $\\Delta$ for Case $k$ in $\\mathrm{N \\cdot m^2/C}$, rounded to six significant figures in scientific notation. For example, an output line with four results must look like\n$$\n[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4]\n$$\nwith each $\\text{d}_k$ printed in scientific notation with six significant figures.", "solution": "The problem statement has been subjected to rigorous validation and is deemed valid. It constitutes a well-posed exercise in computational physics, is scientifically sound, and provides a complete set of parameters and unambiguous objectives. We will therefore proceed with a full solution. The objective is to numerically compute the electric flux through a closed cubical surface and compare this result to the exact theoretical value given by Gauss's Law.\n\nThe electric field $\\mathbf{E}$ generated by a point charge $q$ at position $\\mathbf{r}_0 = (x_q, y_q, z_q)$ is given by Coulomb's Law:\n$$\n\\mathbf{E}(\\mathbf{r}) = k_e q \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert^3}\n$$\nwhere $\\mathbf{r}=(x,y,z)$ is the observation point and $k_e = \\frac{1}{4\\pi\\varepsilon_0}$ is Coulomb's constant, with $\\varepsilon_0$ being the vacuum permittivity.\n\nThe total electric flux $\\Phi$ through a closed surface $S$ is the surface integral of the electric field:\n$$\n\\Phi = \\iint_S \\mathbf{E} \\cdot d\\mathbf{A}\n$$\nThe surface $S$ in this problem is an axis-aligned cube of side length $L$ centered at $\\mathbf{c} = (c_x, c_y, c_z)$. This closed surface is composed of six planar faces. The total flux is the sum of the fluxes through each of these six faces:\n$$\n\\Phi = \\sum_{i=1}^{6} \\Phi_i = \\sum_{i=1}^{6} \\iint_{S_i} \\mathbf{E} \\cdot d\\mathbf{A}_i\n$$\nwhere $S_i$ is the surface of the $i$-th face.\n\nTo compute the flux through a single face, we must define the integrand $\\mathbf{E} \\cdot d\\mathbf{A}$ and the limits of integration. Let us consider a generic face. For an axis-aligned cube, each face is defined by a constant coordinate (e.g., $x = c_x + L/2$) and has an outward-pointing normal vector $\\mathbf{\\hat{n}}$ that is parallel to one of the coordinate axes. The differential area element is $d\\mathbf{A} = \\mathbf{\\hat{n}} \\, du \\, dv$, where $u$ and $v$ are the two integration variables spanning the planar face. The flux through this face is then:\n$$\n\\Phi_i = \\iint_{S_i} (\\mathbf{E} \\cdot \\mathbf{\\hat{n}}) \\, du \\, dv\n$$\nThe integrand, $\\mathbf{E} \\cdot \\mathbf{\\hat{n}}$, can be expressed more explicitly. Substituting the expression for $\\mathbf{E}(\\mathbf{r})$:\n$$\n\\mathbf{E}(\\mathbf{r}(u,v)) \\cdot \\mathbf{\\hat{n}} = k_e q \\frac{(\\mathbf{r}(u,v) - \\mathbf{r}_0) \\cdot \\mathbf{\\hat{n}}}{\\lVert \\mathbf{r}(u,v) - \\mathbf{r}_0 \\rVert^3}\n$$\nwhere $\\mathbf{r}(u,v)$ is the position vector of a point on the face $S_i$. For example, for the face at $x = c_x + L/2$, the normal is $\\mathbf{\\hat{n}}=(1,0,0)$, the integration variables are $(u,v)=(y,z)$, and the position vector is $\\mathbf{r}(y,z) = (c_x + L/2, y, z)$. The integration limits for $y$ and $z$ are $[c_y - L/2, c_y + L/2]$ and $[c_z - L/2, c_z + L/2]$, respectively. This formulation is applied systematically to all six faces.\n\nThe calculation of each two-dimensional integral $\\Phi_i$ is performed numerically using an adaptive quadrature algorithm. The `scipy.integrate.dblquad` function is suitable for this purpose. This function iteratively refines a grid to achieve a desired accuracy for the integral of a given two-dimensional function over a rectangular domain. Since the problem statement guarantees that the charge $q$ is never located exactly on the surface $S$, the integrand is continuous and well-behaved on each face $S_i$, ensuring the reliability of the numerical integration.\n\nThe numerical result for the total flux, $\\Phi_{\\text{numerical}} = \\sum_i \\Phi_i$, is then compared against the exact theoretical value, $\\Phi_{\\text{exact}}$, given by Gauss's Law:\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0}\n$$\nTo determine $q_{\\text{enclosed}}$, we perform a simple geometric containment test. The charge $q$ is enclosed, so $q_{\\text{enclosed}} = q$, if and only if its coordinates $(x_q, y_q, z_q)$ lie strictly within the volume of the cube. This condition is formally expressed as:\n$$\n(c_x - L/2 < x_q < c_x + L/2) \\land (c_y - L/2 < y_q < c_y + L/2) \\land (c_z - L/2 < z_q < c_z + L/2)\n$$\nIf this condition is not met, the charge is outside the cube, and $q_{\\text{enclosed}} = 0$.\n\nFinally, the absolute error $\\Delta$ between the numerically computed flux and the exact flux is calculated to assess the accuracy of our numerical method:\n$$\n\\Delta = \\lvert \\Phi_{\\text{numerical}} - \\Phi_{\\text{exact}} \\rvert\n$$\nThis procedure is applied to each test case specified in the problem. The resulting error $\\Delta$ quantifies how closely our numerical integration of the fundamental definition of flux aligns with the powerful and elegant statement of Gauss's Law.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Physical constants in SI units\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in F/m\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant\n\n    # Test suite: (center, side_length, charge_position, charge_magnitude)\n    test_cases = [\n        # Case 1: Charge at center, inside\n        ((0.0, 0.0, 0.0), 2.0, (0.0, 0.0, 0.0), 1.0e-6),\n        # Case 2: Charge outside\n        ((0.0, 0.0, 0.0), 2.0, (3.0, 0.0, 0.0), 1.0e-6),\n        # Case 3: Charge inside, off-center\n        ((0.2, -0.1, 0.3), 1.4, (0.8, -0.1, 0.3), -2.0e-6),\n        # Case 4: Charge inside, near corner\n        ((1.0, 1.0, 1.0), 0.5, (1.1, 1.1, 1.1), 5.0e-7),\n    ]\n\n    results = []\n    for c_tuple, L, r0_tuple, q in test_cases:\n        c = np.array(c_tuple)\n        r0 = np.array(r0_tuple)\n        \n        # Calculate numerical flux by integrating over the six faces\n        numerical_flux = calculate_numerical_flux(c, L, r0, q, K_E)\n        \n        # Determine exact flux from Gauss's Law\n        h = L / 2.0\n        is_inside = (\n            (c[0] - h < r0[0] < c[0] + h) and\n            (c[1] - h < r0[1] < c[1] + h) and\n            (c[2] - h < r0[2] < c[2] + h)\n        )\n        q_enclosed = q if is_inside else 0.0\n        exact_flux = q_enclosed / EPSILON_0\n        \n        # Compute the absolute error\n        error = abs(numerical_flux - exact_flux)\n        \n        # Format result to 6 significant figures in scientific notation\n        # Precision p-1 for p significant digits, so 5 for 6 sig figs.\n        results.append(f\"{error:.5e}\")\n\n    # Print an output line in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_numerical_flux(c, L, r0, q, K_E):\n    \"\"\"\n    Numerically computes the total electric flux through a cubical surface.\n\n    Args:\n        c (np.ndarray): Center of the cube (cx, cy, cz).\n        L (float): Side length of the cube.\n        r0 (np.ndarray): Position of the point charge (xq, yq, zq).\n        q (float): Magnitude of the point charge.\n        K_E (float): Coulomb's constant.\n\n    Returns:\n        float: The total numerical flux.\n    \"\"\"\n    h = L / 2.0\n    total_flux = 0.0\n\n    # Define the six faces of the cube.\n    # Each tuple contains: (fixed_dim_idx, sign, integration_dims_indices)\n    # fixed_dim_idx: 0 for x, 1 for y, 2 for z\n    # sign: +1 for positive-side face, -1 for negative-side face\n    # integration_dims: indices of the two integration variables\n    faces = [\n        (0,  1, (1, 2)),  # Right face (x = cx + h)\n        (0, -1, (1, 2)),  # Left face  (x = cx - h)\n        (1,  1, (0, 2)),  # Top face   (y = cy + h)\n        (1, -1, (0, 2)),  # Bottom face(y = cy - h)\n        (2,  1, (0, 1)),  # Front face (z = cz + h)\n        (2, -1, (0, 1)),  # Back face  (z = cz - h)\n    ]\n\n    for fixed_dim, sign, int_dims in faces:\n        fixed_coord_val = c[fixed_dim] + sign * h\n        u_idx, v_idx = int_dims\n        \n        u_min, u_max = c[u_idx] - h, c[u_idx] + h\n        v_min, v_max = c[v_idx] - h, c[v_idx] + h\n\n        def integrand(v, u):\n            # `u` and `v` are the integration variables on the face.\n            # dblquad expects the function signature func(inner_var, outer_var)\n            # Here, v is inner, u is outer.\n            r_surf = np.zeros(3)\n            r_surf[fixed_dim] = fixed_coord_val\n            r_surf[u_idx] = u\n            r_surf[v_idx] = v\n            \n            vec_r = r_surf - r0\n            dist_sq = vec_r @ vec_r\n\n            if dist_sq == 0:\n                # Charge is on the integration path point, which is guaranteed\n                # not to happen for the overall surface but might be sampled\n                # by the quadrature. Return 0 to avoid division by zero.\n                return 0.0\n            \n            dist = np.sqrt(dist_sq)\n\n            # The integrand is the component of E normal to the surface: E . n_hat\n            # E . n_hat = (K_E * q * vec_r / dist^3) . n_hat\n            # vec_r . n_hat is simply the component of vec_r along the normal.\n            vec_r_dot_n_hat = vec_r[fixed_dim] * sign\n            \n            return K_E * q * vec_r_dot_n_hat / (dist**3)\n\n        flux_face, _ = dblquad(\n            integrand,\n            u_min, u_max,       # outer integration limits (u)\n            lambda u: v_min,    # inner integration lower limit (v)\n            lambda u: v_max     # inner integration upper limit (v)\n        )\n        total_flux += flux_face\n\n    return total_flux\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415017"}, {"introduction": "Numerical algorithms can feel like magic, but they operate on specific assumptions about the functions they are integrating. This thought experiment explores what happens when those assumptions are broken by a function that is continuous everywhere but differentiable nowhere. By analyzing how different integration methods fare against this 'pathological' integrand, you will gain a deeper, more critical understanding of their strengths, weaknesses, and an appreciation for the robustness of Monte Carlo methods [@problem_id:2414968].", "problem": "Consider the following two-dimensional ($2$D) Weierstrass-type function defined on the unit square $[0,1]^2$:\n$$\nf(x,y) \\;=\\; \\sum_{n=0}^{\\infty} a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big),\n$$\nwith parameters $a=\\tfrac{1}{2}$ and $b=9$ (so $0<a<1$, $b$ is an odd integer, and $a\\,b>1$), which makes $f$ continuous and nowhere differentiable in each coordinate. Let\n$$\nI \\;=\\; \\iint_{[0,1]^2} f(x,y)\\, \\mathrm{d}x\\,\\mathrm{d}y.\n$$\nYou are asked to assess both the value of $I$ and the stability of numerical integration methods applied to this integrand.\n\nSelect all statements that are correct.\n\nA. The exact value of the integral is $0$.\n\nB. A simple Monte Carlo (MC) estimator based on $N$ independent and identically distributed uniform samples on $[0,1]^2$ is unbiased for $I$, and its standard error scales as $N^{-1/2}$.\n\nC. A tensor-product $n$-point Gaussâ€“Legendre quadrature in each dimension is exact for $I$ for all $n$ because $f$ is a sum of cosines with integer frequencies.\n\nD. A Quasiâ€“Monte Carlo (QMC) method with a Sobol sequence can be proven to converge for this $f$ with deterministic error of order $N^{-1}$, since $f$ is bounded and continuous.\n\nE. An adaptive subdivision scheme that refines based on local error estimates can fail to produce a stable estimate of $I$ unless the refinement proceeds to cell sizes on the order of $b^{-m}$ for sufficiently large $m$, because $f$ contains arbitrarily high-frequency components.", "solution": "The problem as stated is mathematically well-posed and scientifically grounded. It presents a rigorous question concerning the analytical and numerical properties of a two-dimensional Weierstrass-type function, a standard topic in advanced analysis and computational science. We shall proceed with a full derivation and analysis.\n\nFirst, we determine the exact value of the integral $I$. The integral is defined as:\n$$\nI \\;=\\; \\iint_{[0,1]^2} f(x,y)\\, \\mathrm{d}x\\,\\mathrm{d}y\n$$\nwhere the integrand is:\n$$\nf(x,y) \\;=\\; \\sum_{n=0}^{\\infty} a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big)\n$$\nwith parameters $a=\\tfrac{1}{2}$ and $b=9$.\n\nThe series defining $f(x,y)$ converges uniformly on the domain $[0,1]^2$. This is established by the Weierstrass M-test. The absolute value of each term in the series is bounded:\n$$\n\\left| a^n\\Big(\\cos\\!\\big(\\pi\\, b^n x\\big) + \\cos\\!\\big(\\pi\\, b^n y\\big)\\Big) \\right| \\le a^n (1+1) = 2a^n\n$$\nSince $a = \\tfrac{1}{2}$, we have $0 < a < 1$, and the geometric series $\\sum_{n=0}^{\\infty} 2a^n$ converges. Because the series for $f(x,y)$ converges uniformly, we can legally interchange the order of summation and integration:\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n \\iint_{[0,1]^2} \\Big(\\cos(\\pi b^n x) + \\cos(\\pi b^n y)\\Big) \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\nBy linearity of the integral, this becomes:\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n \\left( \\iint_{[0,1]^2} \\cos(\\pi b^n x) \\,\\mathrm{d}x\\,\\mathrm{d}y + \\iint_{[0,1]^2} \\cos(\\pi b^n y) \\,\\mathrm{d}x\\,\\mathrm{d}y \\right)\n$$\nThe integrals are separable. Let us evaluate the first part:\n$$\n\\iint_{[0,1]^2} \\cos(\\pi b^n x) \\,\\mathrm{d}x\\,\\mathrm{d}y \\;=\\; \\left( \\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x \\right) \\left( \\int_0^1 1 \\,\\mathrm{d}y \\right)\n$$\nThe second factor is $\\int_0^1 1 \\,\\mathrm{d}y = 1$. The first factor is:\n$$\n\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x \\;=\\; \\left[ \\frac{\\sin(\\pi b^n x)}{\\pi b^n} \\right]_0^1 \\;=\\; \\frac{\\sin(\\pi b^n)}{\\pi b^n}\n$$\nThis holds for $b^n \\neq 0$, which is true for $b=9$ and all $n \\ge 0$.\nThe parameter $b=9$ is an integer. Consequently, $b^n = 9^n$ is an integer for all integers $n \\ge 0$. The sine of any integer multiple of $\\pi$ is zero. Therefore, $\\sin(\\pi b^n) = 0$ for all $n \\ge 0$.\nThis implies:\n$$\n\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x = 0 \\quad \\text{for all } n \\ge 0.\n$$\nBy symmetry, the integral with respect to $y$ is also zero. Thus, each term in the series for $I$ is zero:\n$$\nI \\;=\\; \\sum_{n=0}^{\\infty} a^n (0 + 0) = 0.\n$$\n\nHaving established that the exact value of the integral is $0$, we now evaluate each statement.\n\n**A. The exact value of the integral is $0$.**\nAs demonstrated above, a direct analytical calculation confirms that $I=0$.\nVerdict: **Correct**.\n\n**B. A simple Monte Carlo (MC) estimator based on $N$ independent and identically distributed uniform samples on $[0,1]^2$ is unbiased for $I$, and its standard error scales as $N^{-1/2}$.**\nThe simple Monte Carlo estimator for $I$ is $\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N f(\\mathbf{u}_i)$, where $\\mathbf{u}_i$ are i.i.d. random vectors from the uniform distribution on $[0,1]^2$.\nThe estimator is unbiased if its expectation equals the true value $I$. By linearity of expectation:\n$$\n\\mathbb{E}[\\hat{I}_N] = \\mathbb{E}\\left[ \\frac{1}{N} \\sum_{i=1}^N f(\\mathbf{u}_i) \\right] = \\frac{1}{N} \\sum_{i=1}^N \\mathbb{E}[f(\\mathbf{u}_i)] = \\mathbb{E}[f(\\mathbf{u}_1)] = \\iint_{[0,1]^2} f(x,y) p(x,y) \\,\\mathrm{d}x\\,\\mathrm{d}y\n$$\nSince the probability density function is $p(x,y)=1$ on the unit square, $\\mathbb{E}[\\hat{I}_N] = I$. The estimator is unbiased for any integrable function, which $f$ is.\nThe standard error of the estimator is $\\sigma_f / \\sqrt{N}$, where $\\sigma_f^2$ is the variance of the function, $\\sigma_f^2 = \\iint_{[0,1]^2} f(x,y)^2 \\,\\mathrm{d}x\\,\\mathrm{d}y - I^2$. For the standard error to scale as $N^{-1/2}$, the variance $\\sigma_f^2$ must be finite. The function $f$ is continuous on the compact set $[0,1]^2$, and therefore it is bounded. Let $M$ be the supremum of $|f(x,y)|$. Then $\\iint f(x,y)^2 \\,\\mathrm{d}x\\,\\mathrm{d}y \\le \\iint M^2 \\,\\mathrm{d}x\\,\\mathrm{d}y = M^2 < \\infty$. The variance is finite.\nThus, the Central Limit Theorem applies, and the standard error of the mean converges as $N^{-1/2}$.\nVerdict: **Correct**.\n\n**C. A tensor-product $n$-point Gaussâ€“Legendre quadrature in each dimension is exact for $I$ for all $n$ because $f$ is a sum of cosines with integer frequencies.**\nThis statement has two parts: the claim of exactness and the justification.\nLet us analyze the claim. An $n$-point Gauss-Legendre quadrature on $[-1,1]$ is exact for any odd function, as the integral is $0$ and the symmetric nodes and weights cause the sum to be $0$. We must analyze the integral of a typical term $\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x$. We map the integration interval $[0,1]$ to $[-1,1]$ via $x = (u+1)/2$. The integral becomes $\\frac{1}{2} \\int_{-1}^1 \\cos(\\pi b^n (u+1)/2) \\,\\mathrm{d}u$. The integrand is $g(u) = \\cos(\\pi b^n/2 + \\pi b^n u/2)$. Since $b=9$, $b^n$ is an odd integer for all $n \\ge 0$. For any odd integer $k$, $\\cos(k\\pi/2 + \\theta) = -\\sin(k\\pi/2)\\sin(\\theta) = \\mp \\sin(\\theta)$. So, $g(u)$ is an odd function of $u$. The Gauss-Legendre quadrature rule, applied to an odd function over a symmetric interval, gives exactly $0$. Since this holds for every term in the series for $f(x,y)$, the tensor-product rule also yields $0$, which is the exact value of $I$. So the claim is true.\nNow, we must scrutinize the justification: \"because $f$ is a sum of cosines with integer frequencies.\" This phrasing likely refers to the fact that in $\\cos(\\pi k x)$, the parameter $k=b^n$ is an integer. This property implies $\\int_0^1 \\cos(\\pi b^n x) \\,\\mathrm{d}x = 0$. However, it is not sufficient to guarantee the exactness of the *quadrature*. Consider a case where $b$ is an even integer, for instance $b=2$. The frequencies would still be integers for $n \\ge 1$, and $\\int_0^1 \\cos(2\\pi x)\\,\\mathrm{d}x=0$. But the transformed integrand is $\\cos(\\pi(u+1)) = -\\cos(\\pi u)$, an even function. An $n$-point quadrature rule will not, in general, yield $0$ for this integral. For example, a $1$-point rule on $[0,1]$ uses node $x=1/2$ and weight $1$, giving $\\cos(2\\pi \\cdot 1/2) = -1 \\neq 0$. The exactness relies critically on $b^n$ being an **odd** integer, a condition not captured by the provided reason. The reasoning is flawed and incomplete.\nVerdict: **Incorrect**.\n\n**D. A Quasiâ€“Monte Carlo (QMC) method with a Sobol sequence can be proven to converge for this $f$ with deterministic error of order $N^{-1}$, since $f$ is bounded and continuous.**\nThe error of a QMC method is bounded by the Koksma-Zaremba inequality, $|I - \\hat{I}_N| \\le V_{HK}(f) \\cdot D_N^*$, where $V_{HK}(f)$ is the total variation of $f$ in the sense of Hardy and Krause and $D_N^*$ is the star discrepancy of the point set. For a Sobol sequence in $d=2$ dimensions, $D_N^* = O(N^{-1}(\\log N)^2)$. The claimed error bound of $O(N^{-1})$ is only achieved for functions with finite Hardy-Krause variation. The given function $f(x,y)$ is stated to be continuous but nowhere differentiable. Such functions have infinite variation. The Weierstrass function is a canonical example of a function for which the standard QMC error bounds are not useful and for which QMC methods perform poorly. The convergence rate for continuous functions is not guaranteed to be better than that of MC. For functions that are only HÃ¶lder continuous with exponent $\\alpha$, the QMC error is of order $O(N^{-\\alpha})$. For this Weierstrass function, the HÃ¶lder exponent is $\\alpha = -\\log(a)/\\log(b) = \\log(2)/\\log(9) \\approx 0.315$. This implies a convergence rate much worse than $O(N^{-1})$. The justification \"since $f$ is bounded and continuous\" is also false; these conditions alone only guarantee convergence of the QMC estimate to the integral value, not any specific rate.\nVerdict: **Incorrect**.\n\n**E. An adaptive subdivision scheme that refines based on local error estimates can fail to produce a stable estimate of $I$ unless the refinement proceeds to cell sizes on the order of $b^{-m}$ for sufficiently large $m$, because $f$ contains arbitrarily high-frequency components.**\nAdaptive quadrature routines rely on local error estimators that are typically based on comparing results from different-order rules or on subdividing an interval and comparing the sum to the original estimate. These estimators perform reliably only if the integrand is sufficiently smooth (e.g., possesses several continuous derivatives) within a given cell. The function $f(x,y)$ is continuous but nowhere differentiable, exhibiting a self-similar, fractal-like structure at all scales. As the adaptive algorithm refines a cell, the integrand in the new, smaller cells is just as non-smooth and oscillatory as in the parent cell. This violates the fundamental assumption of local smoothness. Consequently, the error estimators are unreliable: they can be wildly inaccurate, leading the algorithm to fail to converge, to exhaust memory resources by refining endlessly, or to terminate prematurely with a wrong result. The cause of this pathology is indeed the presence of components $\\cos(\\pi b^n x)$ with arbitrarily high frequencies (growing as $b^n$) and non-negligible amplitudes ($a^n$). To resolve a component with frequency proportional to $b^m$, the cell size must be smaller than the corresponding wavelength, which is of order $b^{-m}$. This statement accurately describes the failure mode of standard adaptive quadrature on such pathological functions.\nVerdict: **Correct**.", "answer": "$$\\boxed{ABE}$$", "id": "2414968"}]}