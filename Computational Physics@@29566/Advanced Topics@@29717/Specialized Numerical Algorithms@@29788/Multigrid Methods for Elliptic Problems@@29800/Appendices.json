{"hands_on_practices": [{"introduction": "This exercise establishes the context by tackling the Poisson equation, the archetypal elliptic problem. On a periodic domain, the structure of the discrete Laplacian operator allows for an elegant and highly efficient solution using the Fast Fourier Transform (FFT). This practice [@problem_id:2415805] not only gives you experience with a powerful numerical technique but also sets a benchmark for performance that highlights why specialized methods are so effective in ideal conditions.", "problem": "Write a complete, runnable program that computes the gravitational potential on a periodic three-dimensional grid by solving the Poisson equation for a set of prescribed right-hand sides. Use a periodic cubic domain of side length $1$ with coordinates $x,y,z \\in [0,1)$ and a uniform Cartesian grid with $N \\times N \\times N$ points, grid spacing $h = 1/N$, and periodic boundary conditions on all faces. Consider the nondimensionalized Poisson equation\n$$\n\\nabla^2 \\phi(x,y,z) = f(x,y,z),\n$$\nwith the gauge condition that the spatial average of $\\phi$ is zero, that is\n$$\n\\frac{1}{|\\Omega|}\\int_{\\Omega}\\phi(x,y,z)\\,dx\\,dy\\,dz = 0,\n$$\nwhere $|\\Omega| = 1$ is the volume of the domain. The equation is to be interpreted in the discrete sense using the standard $7$-point periodic finite difference Laplacian on the grid:\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big),\n$$\nwith indices taken modulo $N$ in each direction to enforce periodicity. The grid points should be located at $(x_i,y_j,z_k) = (i/N, j/N, k/N)$ for integers $i,j,k \\in \\{0,1,\\dots,N-1\\}$.\n\nYour program must, for each test case below, compute a numerical approximation $\\phi_h$ to the solution of the discrete Poisson equation $L_h \\phi_h = f_h$ satisfying the zero-average gauge and then report a scalar quantity as specified. All quantities are dimensionless. Angles, if any, are in radians. The final output must be a single line containing a comma-separated list of three floating-point values enclosed in square brackets, in the order of the test cases given below, with no additional text.\n\nTest suite (each case specifies $N$ and a right-hand side $f(x,y,z)$; define $f_h$ by sampling $f$ on the grid and numerically subtracting its average so that the discrete compatibility condition holds):\n\n- Case $1$: $N=16$. Define\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z).\n$$\nFor this case, also define the continuous analytical reference field\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 3}\\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z),\n$$\nwhich solves $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ in the continuum with zero mean. After computing the numerical solution $\\phi_h$, report the discrete root-mean-square (RMS) error\n$$\nE_1 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- Case $2$: $N=32$. Define\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y) + \\frac{1}{2}\\sin(4\\pi z).\n$$\nFor this case, also define the continuous analytical reference field\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 2}\\sin(2\\pi x)\\sin(2\\pi y) - \\frac{1}{2}\\cdot\\frac{1}{(2\\pi)^2\\cdot 4}\\sin(4\\pi z),\n$$\nwhich solves $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ in the continuum with zero mean. After computing the numerical solution $\\phi_h$, report the discrete RMS error\n$$\nE_2 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- Case $3$: $N=8$. Define\n$$\nf(x,y,z) \\equiv 0.\n$$\nIn this case, the exact continuum solution with the imposed gauge is identically zero. After computing the numerical solution $\\phi_h$, report the discrete RMS magnitude\n$$\nE_3 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)\\right)^2\\right)^{1/2}.\n$$\n\nYour program must produce a single line of output containing the three results $[E_1,E_2,E_3]$ in that order. For example, a valid output line would look like\n\"[0.00123,0.00045,0.0]\".", "solution": "The posed problem is the numerical solution of the three-dimensional Poisson equation, $\\nabla^2 \\phi = f$, on a periodic cubic domain. The problem is well-defined, scientifically grounded, and provides all necessary information for a unique solution. It is a standard problem in computational physics, and we shall proceed with a complete solution.\n\nThe most efficient method for solving a linear partial differential equation with constant coefficients on a periodic domain is the use of the Fast Fourier Transform (FFT). The periodic boundary conditions and the structure of the Laplacian operator mean that the discrete Fourier modes (complex exponentials) are the exact eigenfunctions of the discrete Laplacian operator. This property allows for the transformation of the system of coupled linear algebraic equations in real space into a set of independent algebraic equations in Fourier space, which can be solved trivially.\n\nThe problem is to solve the discrete Poisson equation $L_h \\phi_h = f_h$ on a uniform Cartesian grid of size $N \\times N \\times N$. The grid spacing is $h=1/N$. The discrete field $\\phi_h$ is represented by the values $\\phi_{i,j,k}$ at grid points $(x_i, y_j, z_k) = (i/N, j/N, k/N)$ for integers $i,j,k \\in \\{0, 1, \\dots, N-1\\}$. The $7$-point discrete Laplacian operator, $L_h$, is given by:\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big)\n$$\nwhere indices are taken modulo $N$ to enforce periodicity.\n\nWe apply the three-dimensional discrete Fourier transform (DFT) to the equation $L_h \\phi_h = f_h$. The DFT transforms a real-space grid function $\\psi_{i,j,k}$ into its Fourier-space representation $\\hat{\\psi}_{p,q,r}$, where $(p,q,r)$ are the integer frequency indices. The action of the convolution operator $L_h$ in real space becomes a simple multiplication in Fourier space:\n$$\n\\hat{L}_{p,q,r} \\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r}\n$$\nHere, $\\hat{L}_{p,q,r}$ are the eigenvalues of the operator $L_h$, corresponding to the discrete Fourier mode with frequency vector $(p,q,r)$. These eigenvalues can be found by applying $L_h$ to an eigenfunction $\\exp(2\\pi i (pi/N + qj/N + rk/N))$, which yields:\n$$\n\\hat{L}_{p,q,r} = \\frac{1}{h^2} \\left( e^{2\\pi i p/N} + e^{-2\\pi i p/N} + e^{2\\pi i q/N} + e^{-2\\pi i q/N} + e^{2\\pi i r/N} + e^{-2\\pi i r/N} - 6 \\right)\n$$\nUsing the relation $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$, the eigenvalues are:\n$$\n\\hat{L}_{p,q,r} = \\frac{2}{h^2} \\left[ \\cos\\left(\\frac{2\\pi p}{N}\\right) + \\cos\\left(\\frac{2\\pi q}{N}\\right) + \\cos\\left(\\frac{2\\pi r}{N}\\right) - 3 \\right]\n$$\nThe solution for the Fourier coefficients of the potential $\\phi_h$ is then found by division:\n$$\n\\hat{\\phi}_{p,q,r} = \\frac{\\hat{f}_{p,q,r}}{\\hat{L}_{p,q,r}}\n$$\nThis procedure encounters a singularity for the zero-frequency mode, where $(p,q,r) = (0,0,0)$. For this mode, $\\hat{L}_{0,0,0} = \\frac{2}{h^2} (\\cos(0) + \\cos(0) + \\cos(0) - 3) = 0$. Division by zero is undefined. This is a manifestation of the fact that the Poisson equation on a fully periodic domain is solvable only if a compatibility condition is met by the source term $f_h$. The discrete compatibility condition is that the sum of the source over the grid must be zero: $\\sum_{i,j,k} f_{i,j,k} = 0$. In Fourier space, this corresponds to the zero-frequency component being zero: $\\hat{f}_{0,0,0} = 0$. The problem statement correctly mandates this condition be enforced by numerically subtracting the average of the discrete source term $f_h$.\n\nWith $\\hat{f}_{0,0,0} = 0$, the equation for the zero mode becomes $0 \\cdot \\hat{\\phi}_{0,0,0} = 0$, which means $\\hat{\\phi}_{0,0,0}$ is undetermined. This corresponds to the freedom to add an arbitrary constant to the potential $\\phi$. The problem resolves this ambiguity by imposing a gauge condition: the spatial average of $\\phi$ must be zero. For the discrete solution $\\phi_h$, this means $\\sum_{i,j,k} \\phi_{i,j,k} = 0$, which is equivalent to setting its zero-frequency component to zero: $\\hat{\\phi}_{0,0,0} = 0$.\n\nThe complete algorithm is as follows:\n1. For a given grid size $N$ and source function $f(x,y,z)$, create the discrete source field $f_h$ by evaluating $f$ at the grid points $(x_i, y_j, z_k)$.\n2. Enforce the compatibility condition by subtracting the mean value from $f_h$: $f_h \\leftarrow f_h - \\frac{1}{N^3} \\sum_{i,j,k} f_{i,j,k}$.\n3. Compute the 3D FFT of the modified $f_h$ to obtain $\\hat{f}_{p,q,r}$.\n4. Construct the 3D array of eigenvalues $\\hat{L}_{p,q,r}$.\n5. Compute the Fourier coefficients of the solution $\\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r} / \\hat{L}_{p,q,r}$ for all non-zero frequencies $(p,q,r) \\neq (0,0,0)$.\n6. Set the zero-frequency component of the solution to zero, $\\hat{\\phi}_{0,0,0} = 0$, to satisfy the gauge condition.\n7. Compute the 3D inverse FFT of $\\hat{\\phi}_{p,q,r}$ to obtain the solution $\\phi_h$ in real space. Since the source term is real and the operator is symmetric, the solution $\\phi_h$ must be real. We take the real part of the IFFT result to discard negligible imaginary components arising from floating-point arithmetic errors.\n8. Finally, for each test case, calculate the specified scalar quantity ($E_1, E_2, E_3$) using the computed numerical solution $\\phi_h$.\n\nThis procedure is implemented for the three test cases provided. For cases $1$ and $2$, we compute the root-mean-square (RMS) error relative to the provided analytical solution. For case $3$, with a zero source, the exact solution is zero, and we report the RMS magnitude of the computed numerical solution, which should be close to floating-point precision.", "answer": "```python\nimport numpy as np\n\ndef solve_poisson_fft(N, f_func, phi_ref_func=None):\n    \"\"\"\n    Solves the 3D periodic Poisson equation using the FFT method.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        f_func (callable): A function f(x, y, z) for the right-hand side.\n        phi_ref_func (callable, optional): A function phi_ref(x, y, z) for\n            the analytical reference solution. If None, the RMS magnitude of\n            the solution is computed instead of the error.\n\n    Returns:\n        float: The computed RMS error or RMS magnitude.\n    \"\"\"\n    # 1. Define grid parameters and coordinates.\n    h = 1.0 / N\n    indices = np.indices((N, N, N))\n    x = indices[0] * h\n    y = indices[1] * h\n    z = indices[2] * h\n\n    # 2. Construct discrete source term f_h and enforce compatibility.\n    f_h = f_func(x, y, z)\n    f_h -= np.mean(f_h)\n\n    # 3. Compute the 3D FFT of the source term.\n    f_k = np.fft.fftn(f_h)\n\n    # 4. Construct the array of eigenvalues for the discrete Laplacian.\n    # The frequencies are p/N, where p are integer wave numbers.\n    freq_unit = np.fft.fftfreq(N)\n    p_N, q_N, r_N = np.meshgrid(freq_unit, freq_unit, freq_unit, indexing='ij')\n\n    L_k = (2.0 / h**2) * (np.cos(2 * np.pi * p_N) +\n                           np.cos(2 * np.pi * q_N) +\n                           np.cos(2 * np.pi * r_N) - 3.0)\n\n    # 5. Solve for Fourier coefficients of phi, handling the k=0 singularity.\n    phi_k = np.zeros_like(f_k, dtype=complex)\n    \n    # Create a mask for non-zero frequencies.\n    # L_k is zero at (0,0,0), but f_k is also zero there due to mean subtraction.\n    # The result phi_k[0,0,0] should be 0 due to the gauge condition.\n    # We only compute the division for non-zero k.\n    non_zero_k_mask = (L_k != 0)\n    phi_k[non_zero_k_mask] = f_k[non_zero_k_mask] / L_k[non_zero_k_mask]\n    \n    # Explicitly enforce the gauge condition phi_k[0,0,0]=0\n    # This is already handled by initializing phi_k to zeros and dividing only\n    # for non_zero_k, but we state it for clarity.\n    phi_k[0, 0, 0] = 0.0\n\n    # 6. Compute the inverse 3D FFT to get the real-space solution.\n    phi_h = np.real(np.fft.ifftn(phi_k))\n\n    # 7. Calculate and return the required scalar quantity.\n    if phi_ref_func:\n        phi_ref = phi_ref_func(x, y, z)\n        # RMS Error\n        rms_val = np.sqrt(np.mean((phi_h - phi_ref)**2))\n    else:\n        # RMS Magnitude\n        rms_val = np.sqrt(np.mean(phi_h**2))\n        \n    return rms_val\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define functions for test cases\n    # Case 1: N=16\n    def f1(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) * np.sin(2 * np.pi * z)\n\n    def phi_ref1(x, y, z):\n        return -1.0 / (3.0 * (2 * np.pi)**2) * f1(x, y, z)\n\n    # Case 2: N=32\n    def f2(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) + 0.5 * np.sin(4 * np.pi * z)\n\n    def phi_ref2(x, y, z):\n        term1 = -1.0 / (2.0 * (2 * np.pi)**2) * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        term2 = -0.5 / ((4 * np.pi)**2) * np.sin(4 * np.pi * z)\n        return term1 + term2\n\n    # Case 3: N=8\n    def f3(x, y, z):\n        return np.zeros_like(x)\n\n    test_cases = [\n        {'N': 16, 'f_func': f1, 'phi_ref_func': phi_ref1},\n        {'N': 32, 'f_func': f2, 'phi_ref_func': phi_ref2},\n        {'N': 8, 'f_func': f3, 'phi_ref_func': None}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_poisson_fft(case['N'], case['f_func'], case['phi_ref_func'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415805"}, {"introduction": "For problems with more general geometries or boundary conditions where FFTs are not applicable, we turn to iterative methods like multigrid. This core exercise [@problem_id:2415837] guides you through building a complete geometric multigrid solver, from the weighted Jacobi smoother to the grid transfer operators and the recursive $V$-cycle logic. By implementing these components, you will gain a deep, practical understanding of how multigrid methods achieve their remarkable efficiency by tackling error components across a hierarchy of scales.", "problem": "Consider the two-dimensional elliptic Partial Differential Equation (PDE) on the unit square with homogeneous Dirichlet boundary condition (DBC):\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{for } (x,y)\\in (0,1)\\times (0,1), \\qquad u(x,y)=0 \\quad \\text{on } \\partial([0,1]\\times[0,1]).\n$$\nDiscretize the interior using a uniform Cartesian grid with $N\\times N$ unknowns, grid spacing $h=1/(N+1)$, and the standard $5$-point finite difference stencil for the discrete negative Laplacian. Let the right-hand-side $f$ be a point source modeled as a Dirac delta function at a point that coincides with a grid node. On the grid, represent this point source by a discrete Kronecker delta scaled to preserve unit integral in the continuum limit, i.e., set $f_{i_{0},j_{0}}=1/h^{2}$ at the chosen grid node $(i_{0},j_{0})$ and $f_{i,j}=0$ elsewhere. In all cases below, indices $(i,j)$ refer to interior grid indices with $i\\in\\{0,1,\\dots,N-1\\}$ corresponding to the physical location $(x_{i},y_{j})=((i+1)h,(j+1)h)$.\n\nYour task is to implement a geometric multigrid V-cycle solver for the linear system arising from this discretization. Start from the following fundamental base:\n- The discrete operator corresponding to $-\\Delta$ under $5$-point finite differences on the interior is given by\n$$\n(Au)_{i,j}=\\frac{4u_{i,j}-u_{i+1,j}-u_{i-1,j}-u_{i,j+1}-u_{i,j-1}}{h^{2}},\n$$\nwith homogeneous DBC enforced by treating values outside the interior as zero.\n- The Kronecker-delta representation of a point source at $(i_{0},j_{0})$ with unit integral requires $f_{i_{0},j_{0}}=1/h^{2}$ so that $\\sum_{i,j} f_{i,j} h^{2}=1$.\n\nDesign a V-cycle that, on each level:\n- Uses weighted Jacobi smoothing with weight $\\omega=2/3$ for $\\nu_{1}$ pre-smoothing steps and $\\nu_{2}$ post-smoothing steps. Use $\\nu_{1}=\\nu_{2}=3$. Weighted Jacobi updates are\n$$\nu \\leftarrow u + \\omega D^{-1}(f-Au),\n$$\nwhere $D$ is the diagonal of $A$, i.e., $D_{i,j}=4/h^{2}$ so that $D^{-1}=(h^{2}/4)I$.\n- Employs full-weighting restriction to transfer the fine-grid residual to the coarse grid.\n- Employs bilinear interpolation for prolongation of the coarse-grid error correction.\n- Recurses by standard coarsening with interior sizes $N\\mapsto(N-1)/2$, assuming $N$ is of the form $2^{\\ell}-1$. On the coarsest level with $N\\le 3$, solve the linear system exactly by a direct dense solve for the discrete operator.\n\nQuantify robustness using the relative residual after each full V-cycle:\n$$\n\\rho = \\frac{\\lVert r \\rVert_{2}}{\\lVert f \\rVert_{2}}, \\quad r=f-Au,\n$$\nwhere $\\lVert\\cdot\\rVert_{2}$ is the Euclidean norm. Iterate V-cycles starting from the zero initial guess until either $\\rho \\le \\epsilon$ or a maximum of $K$ cycles has been performed. Report the final $\\rho$ that is achieved for each test case.\n\nTest suite. Implement and run your solver for the following parameter sets, which together probe a happy path, near-boundary behavior, superposition of multiple point sources, and a smaller grid edge case:\n- Case $1$: $N=63$, one point source at $(i_{0},j_{0})=(31,31)$, tolerance $\\epsilon=10^{-8}$, maximum cycles $K=20$.\n- Case $2$: $N=63$, one point source at $(i_{0},j_{0})=(1,1)$, tolerance $\\epsilon=10^{-8}$, maximum cycles $K=20$.\n- Case $3$: $N=31$, two point sources at $(i_{0},j_{0})\\in\\{(7,7),(23,23)\\}$ with both entries set to $1/h^{2}$, tolerance $\\epsilon=10^{-8}$, maximum cycles $K=20$.\n- Case $4$: $N=31$, one point source at $(i_{0},j_{0})=(0,0)$, tolerance $\\epsilon=10^{-8}$, maximum cycles $K=20$.\n\nFinal output format. Your program should produce a single line of output containing the results as a comma-separated list of floats enclosed in square brackets, where each float is the final relative residual $\\rho$ for the corresponding case, rounded to $6$ significant figures (for example, $[3.2e-07,1.1e-09, \\dots]$). No other text should be printed.", "solution": "The problem presented is a valid and well-posed task in computational physics. It asks for the implementation of a geometric multigrid V-cycle solver for the linear system $Au = f$ arising from the finite difference discretization of the two-dimensional Poisson equation, $-\\Delta u = f$, on a unit square with homogeneous Dirichlet boundary conditions. The problem is scientifically grounded, self-contained, and all parameters and algorithms are specified with sufficient precision for a unique implementation.\n\nThe core principle of a multigrid method is to accelerate the convergence of a basic iterative solver (the \"smoother\") by solving for the error on a hierarchy of coarser grids. High-frequency components of the error are efficiently damped by the smoother on a fine grid, while low-frequency components are resolved on coarser grids where they appear as high-frequency and can be damped effectively. A V-cycle is a specific recursive algorithm that traverses this grid hierarchy.\n\nThe solution is structured as follows: First, we define the components of the multigrid algorithm—the discrete operator, the smoother, and the grid transfer operators (restriction and prolongation). Then, we combine these into the recursive V-cycle procedure.\n\n**1. Discretization and Operators**\n\nThe continuous problem is discretized on a uniform grid with $N \\times N$ interior points and mesh size $h = 1/(N+1)$. The solution $u$ and right-hand side $f$ are represented as $N \\times N$ arrays. The discrete negative Laplacian operator, $A$, is given by the $5$-point stencil:\n$$\n(Au)_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2}\n$$\nfor interior indices $i,j \\in \\{0, 1, \\dots, N-1\\}$. Homogeneous Dirichlet boundary conditions are enforced by setting $u_{i,j} = 0$ for any index pair $(i,j)$ outside this interior range.\n\n**2. Weighted Jacobi Smoother**\n\nThe smoother's role is to reduce high-frequency error. We use the weighted Jacobi method. The update for a single smoothing step is:\n$$\nu \\leftarrow u + \\omega D^{-1}(f - Au)\n$$\nHere, $r = f - Au$ is the residual. The matrix $D$ is the diagonal of $A$, which has a constant value $D_{i,j} = 4/h^2$ for all interior points. Thus, its inverse is a scalar multiplication: $D^{-1} = (h^2/4)I$. The weight $\\omega = 2/3$ is chosen for good smoothing properties for this specific operator. We perform $\\nu_1 = 3$ pre-smoothing steps before coarsening and $\\nu_2 = 3$ post-smoothing steps after correction from the coarse grid.\n\n**3. Grid Transfer Operators**\n\nGrid transfer operators move data between fine and coarse grids. The grid hierarchy is defined by the standard coarsening rule for grids of size $N = 2^\\ell - 1$, where a fine grid of size $N_{\\text{fine}}$ is mapped to a coarse grid of size $N_{\\text{coarse}} = (N_{\\text{fine}} - 1)/2$.\n\n**Restriction ($R$):** The fine-grid residual $r^{\\text{fine}}$ is transferred to the coarse grid to form the right-hand side of the coarse-grid error equation, $r^{\\text{coarse}} = R r^{\\text{fine}}$. We use full-weighting restriction, where a coarse-grid value is a weighted average of $9$ corresponding fine-grid values. The stencil for the coarse-grid point $(I,J)$ centered at fine-grid point $(2I+1, 2J+1)$ is:\n$$\nr^{\\text{coarse}}_{I,J} = \\frac{1}{16} \\sum_{i,j \\in \\{-1,0,1\\}} w_{i,j} r^{\\text{fine}}_{2I+1+i, 2J+1+j}, \\quad \\text{with weights } W = \\begin{pmatrix} 1 & 2 & 1 \\\\ 2 & 4 & 2 \\\\ 1 & 2 & 1 \\end{pmatrix}\n$$\n\n**Prolongation ($P$):** After solving the error equation on the coarse grid, the resulting error correction $e^{\\text{coarse}}$ must be interpolated back to the fine grid: $e^{\\text{fine}} = P e^{\\text{coarse}}$. We use bilinear interpolation. A coarse-grid value $e^{\\text{coarse}}_{I,J}$ is used to determine values at a $2 \\times 2$ block of fine-grid points.\n- Fine-grid points coinciding with coarse-grid points are copied directly: $e^{\\text{fine}}_{2I+1, 2J+1} = e^{\\text{coarse}}_{I,J}$.\n- Fine-grid points along horizontal edges are averages of two coarse-grid neighbors: $e^{\\text{fine}}_{2I+1, 2J} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I,J-1})$.\n- Fine-grid points along vertical edges are averages of two coarse-grid neighbors: $e^{\\text{fine}}_{2I, 2J+1} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J})$.\n- Fine-grid points at nexus locations are averages of four coarse-grid neighbors: $e^{\\text{fine}}_{2I, 2J} = \\frac{1}{4}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J} + e^{\\text{coarse}}_{I,J-1} + e^{\\text{coarse}}_{I-1,J-1})$.\nBoundary conditions are handled by assuming values outside the coarse grid are zero.\n\n**4. The V-Cycle Algorithm**\n\nA single V-cycle for solving $A^k u^k = f^k$ on grid level $k$ is defined recursively:\n\n1.  **Base Case:** If the grid is the coarsest (here, $N_k \\le 3$), solve the system $A^k u^k = f^k$ directly. This involves constructing the small, dense matrix $A^k$ and using a standard linear solver like LU decomposition.\n2.  **Recursive Step (for finer grids):**\n    a. **Pre-smoothing:** Apply $\\nu_1 = 3$ steps of the weighted Jacobi smoother to the current approximation of $u^k$.\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_1}(A^k, f^k, u^k)\n    $$\n    b. **Compute Residual:** Calculate the residual on the fine grid: $r^k = f^k - A^k u^k$.\n    c. **Restriction:** Transfer the residual to the next coarser level, $k+1$.\n    $$\n    r^{k+1} = R r^k\n    $$\n    d. **Coarse-Grid Solve:** Solve the residual equation on the coarse grid, $A^{k+1} e^{k+1} = r^{k+1}$, for the error correction $e^{k+1}$. This is done by a recursive call to the V-cycle algorithm, starting with a zero initial guess for the error.\n    $$\n    e^{k+1} = \\text{V-cycle}(A^{k+1}, r^{k+1}, \\text{initial guess } 0)\n    $$\n    e. **Prolongation:** Interpolate the computed error correction back to the fine grid.\n    $$\n    e^k = P e^{k+1}\n    $$\n    f. **Correction:** Update the fine-grid solution.\n    $$\n    u^k \\leftarrow u^k + e^k\n    $$\n    g. **Post-smoothing:** Apply $\\nu_2 = 3$ steps of the weighted Jacobi smoother to the corrected solution.\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_2}(A^k, f^k, u^k)\n    $$\nThe V-cycle process is initiated with a zero initial guess, $u=0$, and is iterated until the relative residual $\\rho = \\lVert f-Au \\rVert_2 / \\lVert f \\rVert_2$ falls below a tolerance $\\epsilon = 10^{-8}$ or a maximum of $K=20$ cycles is reached. The final achieved $\\rho$ is reported.", "answer": "```python\nimport numpy as np\n\nclass VCycleSolver:\n    \"\"\"\n    A geometric multigrid V-cycle solver for the 2D Poisson equation.\n    \"\"\"\n    def __init__(self, omega=2/3, nu1=3, nu2=3, coarsest_n=3):\n        self.omega = omega\n        self.nu1 = nu1\n        self.nu2 = nu2\n        self.coarsest_n = coarsest_n\n        self._coarsest_matrices = {}\n\n    def _apply_A(self, u, h):\n        \"\"\"Applies the 5-point stencil discrete Laplacian operator.\"\"\"\n        u_padded = np.pad(u, 1, mode='constant', constant_values=0)\n        # 4*u_ij - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\n        laplacian = (4 * u -\n                     (u_padded[1:-1, 2:] + u_padded[1:-1, :-2] +\n                      u_padded[2:, 1:-1] + u_padded[:-2, 1:-1]))\n        return laplacian / (h**2)\n\n    def _weighted_jacobi(self, u, f, h, nu):\n        \"\"\"Performs `nu` steps of weighted Jacobi smoothing.\"\"\"\n        D_inv = h**2 / 4.0\n        for _ in range(nu):\n            r = f - self._apply_A(u, h)\n            u += self.omega * D_inv * r\n        return u\n\n    def _restrict(self, r_fine):\n        \"\"\"Performs full-weighting restriction.\"\"\"\n        # Stencil: 1/16 * [[1, 2, 1], [2, 4, 2], [1, 2, 1]]\n        r_coarse = (\n            4 * r_fine[1::2, 1::2] +\n            2 * (r_fine[1::2, 0:-1:2] + r_fine[1::2, 2::2] +\n                 r_fine[0:-1:2, 1::2] + r_fine[2::2, 1::2]) +\n            1 * (r_fine[0:-1:2, 0:-1:2] + r_fine[0:-1:2, 2::2] +\n                 r_fine[2::2, 0:-1:2] + r_fine[2::2, 2::2])\n        ) / 16.0\n        return r_coarse\n\n    def _prolongate(self, e_coarse):\n        \"\"\"Performs bilinear interpolation for prolongation.\"\"\"\n        Nc = e_coarse.shape[0]\n        Nf = 2 * Nc + 1\n        e_fine = np.zeros((Nf, Nf))\n\n        # Direct injection\n        e_fine[1::2, 1::2] = e_coarse\n\n        # Pad for easier interpolation\n        e_coarse_padded = np.pad(e_coarse, 1, mode='constant', constant_values=0)\n\n        # Interpolate vertical edges (average of horizontal neighbors)\n        e_fine[1::2, 0::2] = 0.5 * (e_coarse_padded[1:-1, :-1] + e_coarse_padded[1:-1, 1:])\n\n        # Interpolate horizontal edges (average of vertical neighbors)\n        e_fine[0::2, 1::2] = 0.5 * (e_coarse_padded[:-1, 1:-1] + e_coarse_padded[1:, 1:-1])\n\n        # Interpolate center points (average of 4 diagonal neighbors)\n        e_fine[0::2, 0::2] = 0.25 * (e_coarse_padded[:-1, :-1] + e_coarse_padded[:-1, 1:] +\n                                     e_coarse_padded[1:, :-1] + e_coarse_padded[1:, 1:])\n        return e_fine\n\n    def _get_coarsest_A(self, N, h):\n        \"\"\"Builds and caches the matrix for the coarsest grid.\"\"\"\n        if N in self._coarsest_matrices:\n            return self._coarsest_matrices[N]\n\n        size = N * N\n        if size == 0:\n            return np.zeros((0, 0))\n            \n        T_n = np.diag(np.full(N, 4.0)) - np.diag(np.ones(N - 1), 1) - np.diag(np.ones(N - 1), -1)\n        A = (np.kron(np.eye(N), T_n) +\n             np.kron(np.diag(np.ones(N - 1), 1), -np.eye(N)) +\n             np.kron(np.diag(np.ones(N - 1), -1), -np.eye(N)))\n        A /= h**2\n        self._coarsest_matrices[N] = A\n        return A\n\n    def _solve_coarsest(self, f, N, h):\n        \"\"\"Directly solves the system on the coarsest grid.\"\"\"\n        if N == 0:\n            return np.zeros((0,0))\n        A = self._get_coarsest_A(N, h)\n        u_vec = np.linalg.solve(A, f.flatten())\n        return u_vec.reshape((N, N))\n\n    def run_v_cycle(self, u, f, N):\n        \"\"\"Executes one recursive V-cycle.\"\"\"\n        h = 1.0 / (N + 1)\n\n        # 1. Base case: solve directly on coarsest grid\n        if N <= self.coarsest_n:\n            return self._solve_coarsest(f, N, h)\n\n        # 2. Pre-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu1)\n\n        # 3. Compute residual\n        r = f - self._apply_A(u, h)\n\n        # 4. Restrict residual\n        r_coarse = self._restrict(r)\n\n        # 5. Solve coarse-grid error equation recursively\n        Nc = (N - 1) // 2\n        e_coarse_initial = np.zeros((Nc, Nc))\n        e_coarse = self.run_v_cycle(e_coarse_initial, r_coarse, Nc)\n\n        # 6. Prolongate error correction\n        e_fine = self._prolongate(e_coarse)\n\n        # 7. Correct fine-grid solution\n        u += e_fine\n\n        # 8. Post-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu2)\n\n        return u\n\n    def solve_system(self, N, f, tol, max_cycles):\n        \"\"\"Iteratively solves the system using V-cycles.\"\"\"\n        u = np.zeros((N, N))\n        h = 1.0 / (N + 1)\n        \n        norm_f = np.linalg.norm(f.flatten())\n        if norm_f == 0:\n            return 0.0\n\n        r = f - self._apply_A(u, h)\n        rel_res = np.linalg.norm(r.flatten()) / norm_f\n\n        for _ in range(max_cycles):\n            if rel_res <= tol:\n                break\n            u = self.run_v_cycle(u, f, N)\n            r = f - self._apply_A(u, h)\n            rel_res = np.linalg.norm(r.flatten()) / norm_f\n        \n        return rel_res\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 63, 'sources': [(31, 31)]},\n        {'N': 63, 'sources': [(1, 1)]},\n        {'N': 31, 'sources': [(7, 7), (23, 23)]},\n        {'N': 31, 'sources': [(0, 0)]},\n    ]\n    epsilon = 1e-8\n    K = 20\n\n    solver = VCycleSolver(omega=2/3, nu1=3, nu2=3)\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        sources = case['sources']\n        \n        h = 1.0 / (N + 1)\n        f = np.zeros((N, N))\n        for i0, j0 in sources:\n            f[i0, j0] = 1.0 / h**2\n        \n        final_rho = solver.solve_system(N, f, epsilon, K)\n        results.append(f\"{final_rho:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2415837"}, {"introduction": "After mastering the serial implementation of a multigrid solver, the next step is to consider its performance on parallel hardware. The efficiency of a parallel algorithm is not merely a matter of dividing the work; it is a complex balance between computation, memory access, and communication overhead. This analytical practice [@problem_id:2415818] uses a detailed performance model to help you dissect these factors, identifying bottlenecks like synchronization latency and limits to parallelism on coarse grids, which are critical considerations in high-performance scientific computing.", "problem": "Consider the two-dimensional Poisson equation with Dirichlet boundary conditions discretized on a square grid using the standard five-point finite-difference stencil. Within a multigrid V-cycle, a red-black Gauss–Seidel smoother is applied on each grid level. Let the finest-level interior grid have $n_0 \\times n_0$ points, with coarsening by a factor of $2$ in each spatial direction so that level $\\ell$ has $n_\\ell = \\max\\!\\left(2, \\left\\lfloor \\dfrac{n_0}{2^\\ell} \\right\\rfloor \\right)$ interior points per dimension and $N_\\ell = n_\\ell^2$ interior points in total. Assume that smoothing is performed on each level with a total of $n_{\\mathrm{sweeps}} = \\nu_1 + \\nu_2$ sweeps per V-cycle.\n\nThe red-black Gauss–Seidel method updates half the points (the red set) followed by the other half (the black set) in each sweep. Assume that one point update costs $w_f$ floating-point operations and transfers $w_m$ bytes to or from main memory. The computation runs on a multi-core central processing unit (CPU) with $p$ identical cores, each capable of a sustained floating-point rate $f_{\\mathrm{core}}$ (in floating-point operations per second), and a shared sustained memory bandwidth $B$ (in bytes per second). A global barrier synchronization has latency $\\tau_b$ (in seconds), and the scheduling/launch overhead per color phase has latency $\\tau_\\ell$ (in seconds). Angles do not appear; no specific angle unit is required. All time parameters are in seconds.\n\nFor a given level $\\ell$ and core count $p$, define the effective per-color concurrency as\n$$\nc_\\ell(p) = \\min\\!\\left(p, \\frac{N_\\ell}{2}\\right).\n$$\nThe compute-limited time for one smoothing sweep on level $\\ell$ is\n$$\nT^{(\\mathrm{comp})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, c_\\ell(p)}.\n$$\nThe memory-limited time for one smoothing sweep on level $\\ell$ is\n$$\nT^{(\\mathrm{mem})}_\\ell = \\frac{N_\\ell \\, w_m}{B}.\n$$\nThe base time for one sweep on level $\\ell$ is\n$$\nT^{(\\mathrm{base})}_\\ell(p) = \\max\\!\\left( T^{(\\mathrm{comp})}_\\ell(p), \\, T^{(\\mathrm{mem})}_\\ell \\right).\n$$\nEach sweep has two color phases and thus incurs overheads\n$$\nT^{(\\mathrm{bar})}(p) = \\mathbf{1}_{\\{p>1\\}} \\cdot 2 \\, \\tau_b, \\qquad\nT^{(\\mathrm{sched})}(p) = \\mathbf{1}_{\\{p>1\\}} \\cdot 2 \\, \\tau_\\ell,\n$$\nwhere $\\mathbf{1}_{\\{p>1\\}}$ is $1$ if $p>1$ and $0$ otherwise. The total smoothing time for one sweep on level $\\ell$ is\n$$\nT_\\ell(p) = T^{(\\mathrm{base})}_\\ell(p) + T^{(\\mathrm{bar})}(p) + T^{(\\mathrm{sched})}(p).\n$$\nLet the total smoother time over one V-cycle be\n$$\nT_{\\mathrm{total}}(p) = \\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T_\\ell(p).\n$$\nDefine the parallel speedup and efficiency as\n$$\nS = \\frac{T_{\\mathrm{total}}(1)}{T_{\\mathrm{total}}(p)}, \\qquad E = \\frac{S}{p}.\n$$\nTo identify overhead sources, report the following fractions with respect to $T_{\\mathrm{total}}(p)$:\n- Barrier fraction:\n$$\nF_{\\mathrm{bar}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T^{(\\mathrm{bar})}(p)}{T_{\\mathrm{total}}(p)}.\n$$\n- Scheduling fraction:\n$$\nF_{\\mathrm{sched}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, T^{(\\mathrm{sched})}(p)}{T_{\\mathrm{total}}(p)}.\n$$\n- Parallelism-limit fraction (loss due to insufficient concurrency $c_\\ell(p) < p$ in the compute-limited regime):\nFor each level $\\ell$, define the ideal compute-limited sweep time if full concurrency $p$ were usable as\n$$\nT^{(\\mathrm{comp,ideal})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, p}.\n$$\nThen the per-level loss is\n$$\nL_\\ell(p) = \n\\begin{cases}\nT^{(\\mathrm{comp})}_\\ell(p) - T^{(\\mathrm{comp,ideal})}_\\ell(p), & \\text{if } T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nand the total fraction is\n$$\nF_{\\mathrm{plim}} = \\frac{\\sum_{\\ell} n_{\\mathrm{sweeps}} \\, L_\\ell(p)}{T_{\\mathrm{total}}(p)}.\n$$\n\nYour task is to write a complete, runnable program that, for the specified test suite below, computes for each test case the list $[S, E, F_{\\mathrm{bar}}, F_{\\mathrm{sched}}, F_{\\mathrm{plim}}]$ and prints a single line containing all test-case results as a comma-separated list of these lists enclosed in a single pair of square brackets, for example $[[a_1,a_2,a_3,a_4,a_5],[b_1,b_2,b_3,b_4,b_5]]$. All reported values must be floating-point numbers rounded to exactly $6$ digits after the decimal point. No other text should be printed.\n\nUse the following parameter values for all test cases unless explicitly overridden:\n- Per-update costs: $w_f = 10$ floating-point operations, $w_m = 48$ bytes.\n- Smoother sweep counts: $\\nu_1 = 2$, $\\nu_2 = 1$ so that $n_{\\mathrm{sweeps}} = 3$.\n- Machine parameters: $f_{\\mathrm{core}} = 2 \\times 10^{9}$ floating-point operations per second, $B = 4 \\times 10^{10}$ bytes per second, $\\tau_b = 2 \\times 10^{-6}$ seconds, $\\tau_\\ell = 5 \\times 10^{-6}$ seconds.\n\nTest suite (each case specified by $(n_0, p)$):\n- Case $1$: $(n_0, p) = (512, 1)$.\n- Case $2$: $(n_0, p) = (512, 4)$.\n- Case $3$: $(n_0, p) = (512, 16)$.\n- Case $4$: $(n_0, p) = (128, 16)$.\n- Case $5$: $(n_0, p) = (32, 64)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the test cases above, where each element is itself a list of the five floating-point values $[S, E, F_{\\mathrm{bar}}, F_{\\mathrm{sched}}, F_{\\mathrm{plim}}]$ rounded to $6$ decimal places.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It presents a well-posed computational task based on a clear, explicit, and scientifically sound performance model for a multigrid smoother, a standard algorithm in computational physics. All necessary parameters and definitions are provided, and no contradictions or ambiguities are present. We may therefore proceed with the solution.\n\nThe objective is to compute a set of parallel performance metrics for a multigrid V-cycle smoother using a given analytical performance model. The metrics include parallel speedup ($S$), efficiency ($E$), and fractions of total time attributed to barrier synchronization ($F_{\\mathrm{bar}}$), scheduling overhead ($F_{\\mathrm{sched}}$), and insufficient parallelism ($F_{\\mathrm{plim}}$). The calculation will be performed for several test cases, each defined by a finest grid size $n_0$ and a number of processor cores $p$.\n\nThe computational procedure is built by directly implementing the provided formulae. The overall structure of the calculation for a single test case $(n_0, p)$ is as follows:\n\nFirst, we must determine the grid hierarchy. The V-cycle operates on a sequence of grids, starting from the finest level $\\ell=0$ with $n_0 \\times n_0$ interior points. Each subsequent level $\\ell+1$ is obtained by coarsening the grid on level $\\ell$ by a factor of $2$. The number of interior points per dimension on level $\\ell$ is given by $n_\\ell = \\max\\!\\left(2, \\left\\lfloor \\dfrac{n_0}{2^\\ell} \\right\\rfloor \\right)$. The V-cycle proceeds until the grid size no longer decreases, which occurs when $n_\\ell=2$. We generate the sequence of grid sizes $\\{n_\\ell\\}$ for $\\ell = 0, 1, 2, \\dots$ until this condition is met.\n\nSecond, for each level $\\ell$ in the hierarchy and a given number of cores $p$, we calculate the total time for one smoothing sweep, $T_\\ell(p)$. This involves several steps:\n1.  Calculate the total number of interior points: $N_\\ell = n_\\ell^2$.\n2.  Determine the effective per-color concurrency: $c_\\ell(p) = \\min\\!\\left(p, \\frac{N_\\ell}{2}\\right)$. This reflects that a red-black smoother processes $\\frac{N_\\ell}{2}$ points in parallel during each of its two phases.\n3.  Calculate the compute-limited time for one sweep: $T^{(\\mathrm{comp})}_\\ell(p) = \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, c_\\ell(p)}$. This models the time assuming performance is limited by the floating-point capability of the available cores.\n4.  Calculate the memory-limited time for one sweep: $T^{(\\mathrm{mem})}_\\ell = \\frac{N_\\ell \\, w_m}{B}$. This models the time assuming performance is limited by memory bandwidth.\n5.  The base time for one sweep is the maximum of these two: $T^{(\\mathrm{base})}_\\ell(p) = \\max\\!\\left( T^{(\\mathrm{comp})}_\\ell(p), \\, T^{(\\mathrm{mem})}_\\ell \\right)$. This is a standard roofline model assumption.\n6.  Calculate the parallel overheads for one sweep. Since each sweep consists of two phases (red and black), a barrier and scheduling event may occur for each. The total overheads are $T^{(\\mathrm{bar})}(p) = \\mathbf{1}_{\\{p>1\\}} \\cdot 2 \\, \\tau_b$ and $T^{(\\mathrm{sched})}(p) = \\mathbf{1}_{\\{p>1\\}} \\cdot 2 \\, \\tau_\\ell$, where $\\mathbf{1}_{\\{p>1\\}}$ is the indicator function, equal to $1$ if $p>1$ and $0$ if $p=1$.\n7.  The total time for one sweep on level $\\ell$ is the sum of the base time and overheads: $T_\\ell(p) = T^{(\\mathrm{base})}_\\ell(p) + T^{(\\mathrm{bar})}(p) + T^{(\\mathrm{sched})}(p)$.\n\nThird, we calculate the total smoother time over one complete V-cycle, $T_{\\mathrm{total}}(p)$. This is the sum of the sweep times over all levels, multiplied by the number of sweeps per level, $n_{\\mathrm{sweeps}}$:\n$$\nT_{\\mathrm{total}}(p) = n_{\\mathrm{sweeps}} \\sum_{\\ell} T_\\ell(p)\n$$\n\nFourth, we calculate the total time lost due to insufficient parallelism. For each level $\\ell$, this loss, $L_\\ell(p)$, occurs only if the sweep is compute-limited ($T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell$) and there are fewer independent tasks than cores ($c_\\ell(p) < p$). The loss is the difference between the actual compute time and the ideal time if all $p$ cores could have been used:\n$$\nL_\\ell(p) = \n\\begin{cases}\nT^{(\\mathrm{comp})}_\\ell(p) - \\frac{N_\\ell \\, w_f}{f_{\\mathrm{core}} \\, p}, & \\text{if } T^{(\\mathrm{comp})}_\\ell(p) \\ge T^{(\\mathrm{mem})}_\\ell, \\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nThe total parallelism-limit loss over the V-cycle is $L_{\\mathrm{total}}(p) = n_{\\mathrm{sweeps}} \\sum_{\\ell} L_\\ell(p)$.\n\nFinally, we compute the required performance metrics.\n1.  To find the speedup $S$, we need the serial execution time $T_{\\mathrm{total}}(1)$. This is calculated by applying the entire procedure above with $p=1$. The speedup is then $S = \\frac{T_{\\mathrm{total}}(1)}{T_{\\mathrm{total}}(p)}$.\n2.  The efficiency is $E = \\frac{S}{p}$.\n3.  The overhead fractions are calculated by summing the respective overhead components across all levels, multiplying by $n_{\\mathrm{sweeps}}$, and normalizing by the total time $T_{\\mathrm{total}}(p)$:\n    $F_{\\mathrm{bar}} = \\frac{n_{\\mathrm{sweeps}} \\sum_{\\ell} T^{(\\mathrm{bar})}(p)}{T_{\\mathrm{total}}(p)}$\n    $F_{\\mathrm{sched}} = \\frac{n_{\\mathrm{sweeps}} \\sum_{\\ell} T^{(\\mathrm{sched})}(p)}{T_{\\mathrm{total}}(p)}$\n    $F_{\\mathrm{plim}} = \\frac{L_{\\mathrm{total}}(p)}{T_{\\mathrm{total}}(p)}$\n\nFor the special case of $p=1$, the overheads $T^{(\\mathrm{bar})}(1)$, $T^{(\\mathrm{sched})}(1)$, and $L_\\ell(1)$ are all zero. Consequently, $S=1$, $E=1$, and all overhead fractions are $0$.\n\nThis complete procedure will be implemented and applied to each test case specified in the problem statement.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes parallel performance metrics for a multigrid V-cycle smoother\n    based on a provided analytical performance model.\n    \"\"\"\n\n    # --- Fixed Parameters ---\n    W_F = 10.0  # FLOPs per point update\n    W_M = 48.0  # Bytes per point update\n    N_SWEEPS = 3.0  # n_sweeps = nu_1 + nu_2 = 2 + 1\n    F_CORE = 2.0e9  # FLOPS per core per second\n    B = 4.0e10  # Bytes per second (memory bandwidth)\n    TAU_B = 2.0e-6  # seconds (barrier latency)\n    TAU_L = 5.0e-6  # seconds (scheduling latency)\n\n    # --- Test Suite ---\n    test_cases = [\n        (512, 1),\n        (512, 4),\n        (512, 16),\n        (128, 16),\n        (32, 64),\n    ]\n\n    def calculate_performance_components(n0, p):\n        \"\"\"\n        Calculates total time and overhead components for a given n0 and p.\n        \"\"\"\n        # Generate grid hierarchy\n        n_levels = []\n        n_current = n0\n        if n_current > 0:\n            n_levels.append(n_current)\n        while n_current > 2:\n            n_next = max(2, n_current // 2)\n            if n_next < n_current:\n                n_levels.append(n_next)\n                n_current = n_next\n            else:\n                break\n        \n        num_levels = len(n_levels)\n        total_time = 0.0\n        total_loss_plim = 0.0\n        \n        # Overheads are independent of level, calculated once\n        t_bar_p = 2.0 * TAU_B if p > 1 else 0.0\n        t_sched_p = 2.0 * TAU_L if p > 1 else 0.0\n\n        for n_l in n_levels:\n            N_l = float(n_l**2)\n            \n            # Concurrency\n            c_l_p = min(p, N_l / 2.0)\n            \n            # Compute-limited time\n            # Handle c_l_p = 0 case for very small grids (Nl=1, not possible here as min n_l is 2)\n            t_comp_l_p = (N_l * W_F) / (F_CORE * c_l_p) if c_l_p > 0 else float('inf')\n            \n            # Memory-limited time\n            t_mem_l = (N_l * W_M) / B\n            \n            # Base sweep time\n            t_base_l_p = max(t_comp_l_p, t_mem_l)\n            \n            # Total sweep time per level\n            t_l_p = t_base_l_p + t_bar_p + t_sched_p\n            total_time += t_l_p\n            \n            # Parallelism-limit loss\n            if t_comp_l_p >= t_mem_l:\n                t_comp_ideal_l_p = (N_l * W_F) / (F_CORE * p) if p > 0 else float('inf')\n                loss_l_p = t_comp_l_p - t_comp_ideal_l_p\n                total_loss_plim += loss_l_p\n\n        total_time *= N_SWEEPS\n        total_loss_plim *= N_SWEEPS\n        \n        total_barrier_time = N_SWEEPS * num_levels * t_bar_p\n        total_sched_time = N_SWEEPS * num_levels * t_sched_p\n\n        return total_time, total_barrier_time, total_sched_time, total_loss_plim\n\n    results = []\n    for n0, p in test_cases:\n        if p == 1:\n            # For p=1, S=1, E=1, and all overhead fractions are 0 by definition\n            results.append([1.0, 1.0, 0.0, 0.0, 0.0])\n            continue\n            \n        # Calculate for p=1 (serial baseline)\n        T_total_1, _, _, _ = calculate_performance_components(n0, 1)\n\n        # Calculate for given p\n        T_total_p, T_bar_total, T_sched_total, L_plim_total = calculate_performance_components(n0, p)\n        \n        if T_total_p == 0: # Avoid division by zero\n            S = 0.0\n            E = 0.0\n            F_bar = 0.0\n            F_sched = 0.0\n            F_plim = 0.0\n        else:\n            S = T_total_1 / T_total_p\n            E = S / p\n            F_bar = T_bar_total / T_total_p\n            F_sched = T_sched_total / T_total_p\n            F_plim = L_plim_total / T_total_p\n            \n        results.append([S, E, F_bar, F_sched, F_plim])\n\n    # Format output as specified\n    formatted_results = []\n    for res_list in results:\n        formatted_numbers = [f\"{v:.6f}\" for v in res_list]\n        formatted_results.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\n\nsolve()\n```", "id": "2415818"}]}