{"hands_on_practices": [{"introduction": "To simulate quarks on a lattice, we must first translate the continuum Dirac equation into a discrete form, a process that can introduce both profound insights and numerical challenges. This exercise [@problem_id:2407358] provides direct, hands-on experience in constructing the matrix representation of the Hermitian Wilson-Dirac operator, $H_W = \\gamma_5 D_W$, from first principles. By examining its eigenvalue spectrum for a simplified gauge field, you will investigate the nature of \"exceptional configurations,\" which are crucial for understanding the low-energy behavior of Quantum Chromodynamics (QCD).", "problem": "Consider a two-dimensional lattice formulation of Wilson fermions in a simplified, quenched Quantum Chromodynamics (QCD) toy model with gauge group $U(1)$ to illustrate the mechanism of \"exceptional configurations\" that lead to unphysically small quark masses. Work on a square lattice of linear extent $L$ with periodic boundary conditions and lattice spacing $a=1$ (dimensionless lattice units). Use the Wilson parameter $r=1$ and a two-component Euclidean spinor with gamma matrices given by $\\gamma_1=\\sigma_1$, $\\gamma_2=\\sigma_2$, and $\\gamma_5=\\sigma_3$, where $\\sigma_i$ are Pauli matrices.\n\nLet lattice sites be labeled by $x=(x_1,x_2)$ with $x_\\mu \\in \\{0,1,\\dots,L-1\\}$ and unit vectors $\\hat{\\mu}$ for $\\mu \\in \\{1,2\\}$. The gauge links are $U_\\mu(x) \\in U(1)$, represented as complex phases $U_\\mu(x)=e^{i \\theta_\\mu(x)}$. The two-dimensional Wilson-Dirac operator $D_W(m_0)$ of bare mass $m_0$ acts on spinor fields $\\psi(x)$ as\n$$\n\\left[D_W(m_0)\\psi\\right](x) \\;=\\; \\left(m_0 + 2 d r\\right)\\psi(x) \\;-\\; \\frac{1}{2}\\sum_{\\mu=1}^{2} \\left\\{ \\left(r - \\gamma_\\mu\\right) U_\\mu(x)\\,\\psi(x+\\hat{\\mu}) \\;+\\; \\left(r + \\gamma_\\mu\\right) U_\\mu^\\dagger(x-\\hat{\\mu})\\,\\psi(x-\\hat{\\mu}) \\right\\},\n$$\nwith $d=2$ and periodic boundary conditions understood in the neighbor indices. Define the Hermitian Wilson-Dirac operator $H_W(m_0)$ as\n$$\nH_W(m_0) \\;=\\; \\gamma_5 \\, D_W(m_0).\n$$\nA configuration is deemed \"exceptional\" at a given bare mass $m_0$ if the smallest absolute eigenvalue of $H_W(m_0)$ is strictly less than a specified positive threshold $\\lambda_{\\text{thr}}$, that is,\n$$\n\\min_j \\left|\\lambda_j\\left(H_W(m_0)\\right)\\right| \\;<\\; \\lambda_{\\text{thr}}.\n$$\nHere the $\\lambda_j\\left(H_W(m_0)\\right)$ are the real eigenvalues of the Hermitian matrix $H_W(m_0)$. All quantities are dimensionless; any angle must be expressed in radians.\n\nGauge backgrounds to be considered:\n- \"free\": $U_\\mu(x)=1$ for all $x$ and $\\mu$.\n- \"dislocation\": $U_\\mu(x)=1$ for all $x$ and $\\mu$ except for a single forward link at a specified site and direction set to a nontrivial phase $U_{\\mu^\\star}(x^\\star)=e^{i\\phi}$, with $x^\\star=(0,0)$, $\\mu^\\star=1$, and angle $\\phi$ in radians.\n\nYour task is to write a complete program that, for each test case, constructs $H_W(m_0)$ on the specified lattice and gauge background, computes $\\min_j |\\lambda_j(H_W(m_0))|$, and returns a boolean indicating whether the configuration is exceptional under the strict inequality above.\n\nTest suite (angles are in radians):\n- Case $1$: $L=4$, gauge \"free\", $m_0=-1.90$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $2$: $L=4$, gauge \"free\", $m_0=-1.97$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $3$: $L=4$, gauge \"free\", $m_0=-1.96$, $\\lambda_{\\text{thr}}=0.04$.\n- Case $4$: $L=4$, gauge \"dislocation\" with $\\phi=\\pi$, $m_0=-1.90$, $\\lambda_{\\text{thr}}=0.10$.\n\nFinal output format:\nYour program should produce a single line of output containing the boolean results for the cases in the order listed above as a comma-separated list enclosed in square brackets. For example, an output with four results must look like\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$", "solution": "The problem presented is a well-defined task in computational physics, specifically in the domain of lattice gauge theory. It requires the numerical analysis of the Wilson-Dirac operator in a simplified two-dimensional $U(1)$ gauge model. The problem statement is scientifically sound, all parameters and definitions are provided, and the task is computationally feasible. Therefore, the problem is valid.\n\nThe solution requires constructing the matrix representation of the Hermitian Wilson-Dirac operator, $H_W(m_0) = \\gamma_5 D_W(m_0)$, and then numerically determining its eigenvalues. An 'exceptional configuration' is identified if the smallest absolute eigenvalue falls below a given threshold, $\\lambda_{\\text{thr}}$.\n\nLet us first formalize the construction of the matrix $H_W(m_0)$. The total Hilbert space is a tensor product of the space of lattice sites and the spinor space. For a lattice of size $L \\times L$, there are $N_s = L^2$ sites. With two-component spinors, the total dimension of the vector space is $N_{dim} = 2 \\times N_s$. We can establish a mapping from a site $x=(x_1, x_2)$ and spinor index $\\alpha \\in \\{0, 1\\}$ to a single matrix index. A common choice is a lexicographical ordering, where the composite index for $(\\,(x_1, x_2), \\alpha\\,)$ is $k = 2(x_1 L + x_2) + \\alpha$.\n\nThe operator $H_W(m_0)$ is built from the Wilson-Dirac operator $D_W(m_0)$ given by:\n$$\n\\left[D_W(m_0)\\psi\\right](x) \\;=\\; \\left(m_0 + 2 d r\\right)\\psi(x) \\;-\\; \\frac{1}{2}\\sum_{\\mu=1}^{2} \\left\\{ \\left(r - \\gamma_\\mu\\right) U_\\mu(x)\\,\\psi(x+\\hat{\\mu}) \\;+\\; \\left(r + \\gamma_\\mu\\right) U_\\mu^\\dagger(x-\\hat{\\mu})\\,\\psi(x-\\hat{\\mu}) \\right\\}\n$$\nWith parameters $d=2$ and $r=1$, the on-site term is $(m_0+4)\\psi(x)$. The operator $D_W$ is represented by a matrix whose elements $D_{(x',\\alpha'),(x,\\alpha)}$ describe the coupling from a spinor component $\\alpha$ at site $x$ to a component $\\alpha'$ at site $x'$. From the expression above, we can identify these matrix elements:\n1.  **On-site term**: The term $(m_0+4)\\psi(x)$ contributes to the diagonal blocks of the matrix. It couples spinor components at the same site $x$.\n    $$ D_{(x,\\alpha'),(x,\\alpha)} = (m_0+4)\\delta_{\\alpha'\\alpha} $$\n2.  **Forward hopping term**: The term $-\\frac{1}{2}(r - \\gamma_\\mu) U_\\mu(x)\\psi(x+\\hat{\\mu})$ couples site $x+\\hat{\\mu}$ to site $x$.\n    $$ D_{(x,\\alpha'),(x+\\hat{\\mu},\\alpha)} = -\\frac{1}{2} (r-\\gamma_\\mu)_{\\alpha'\\alpha} U_\\mu(x) $$\n3.  **Backward hopping term**: The term $-\\frac{1}{2}(r + \\gamma_\\mu) U_\\mu^\\dagger(x-\\hat{\\mu})\\psi(x-\\hat{\\mu})$ couples site $x-\\hat{\\mu}$ to site $x$.\n    $$ D_{(x,\\alpha'),(x-\\hat{\\mu},\\alpha)} = -\\frac{1}{2} (r+\\gamma_\\mu)_{\\alpha'\\alpha} U_\\mu^\\dagger(x-\\hat{\\mu}) $$\nAll other matrix elements of $D_W$ are zero. Periodic boundary conditions are applied to find neighboring sites. For a site $x=(x_1,x_2)$, its neighbor in the $+\\hat{1}$ direction is $((x_1+1) \\pmod L, x_2)$, and so on.\n\nThe Hermitian operator $H_W(m_0)$ is defined as $H_W(m_0) = \\gamma_5 D_W(m_0)$. In matrix form, this corresponds to a left-multiplication of each $2 \\times 2$ spinor block of the $D_W$ matrix by the $\\gamma_5$ matrix. The blocks of $H_W$ are:\n1.  **On-site block**: $H_{x,x} = \\gamma_5 D_{x,x} = (m_0+4)\\gamma_5$\n2.  **Forward hopping block**: $H_{x,x+\\hat{\\mu}} = \\gamma_5 D_{x,x+\\hat{\\mu}} = -\\frac{1}{2}\\gamma_5(r-\\gamma_\\mu)U_\\mu(x)$\n3.  **Backward hopping block**: $H_{x,x-\\hat{\\mu}} = \\gamma_5 D_{x,x-\\hat{\\mu}} = -\\frac{1}{2}\\gamma_5(r+\\gamma_\\mu)U_\\mu^\\dagger(x-\\hat{\\mu})$\n\nThe gamma matrices specified are the Pauli matrices: $\\gamma_1=\\sigma_1$, $\\gamma_2=\\sigma_2$, $\\gamma_5=\\sigma_3$. These satisfy the necessary anticommutation relation $\\{\\gamma_\\mu, \\gamma_5\\} = 0$ for $\\mu=1,2$, which ensures the $\\gamma_5$-hermiticity of $D_W$ and thus the hermiticity of $H_W$.\n\nThe algorithm to solve the problem is as follows:\n1.  For each test case, define the parameters $L$, $m_0$, and $\\lambda_{\\text{thr}}$.\n2.  Generate the gauge field configuration $\\{U_\\mu(x)\\}$ for all sites $x$ and directions $\\mu$. For the \"free\" case, all $U_\\mu(x)=1$. For the \"dislocation\" case, $U_1((0,0)) = e^{i\\phi}$ and all other links are $1$.\n3.  Initialize an $N_{dim} \\times N_{dim}$ zero matrix with complex entries for $H_W$.\n4.  Iterate through each lattice site $x=(x_1,x_2)$ from $(0,0)$ to $(L-1,L-1)$. For each site, compute the corresponding $2 \\times 2$ blocks of $H_W$ and place them in the matrix.\n    -   The diagonal block $H_{x,x}$ is placed at the matrix indices corresponding to site $x$ for both row and column.\n    -   For each direction $\\mu \\in \\{1,2\\}$, compute the forward neighbor $x_{fwd} = x+\\hat{\\mu}$ and the backward neighbor $x_{bwd} = x-\\hat{\\mu}$.\n    -   Place the forward hopping block $H_{x,x+\\hat{\\mu}}$ at the row block for $x$ and column block for $x_{fwd}$.\n    -   Place the backward hopping block $H_{x,x-\\hat{\\mu}}$ at the row block for $x$ and column block for $x_{bwd}$.\n5.  Once the full matrix $H_W$ is constructed, its eigenvalues are computed. Since $H_W$ is Hermitian, its eigenvalues are real, and we can use a specialized numerical routine like `numpy.linalg.eigvalsh`.\n6.  Find the minimum value of $|\\lambda_j|$ over all eigenvalues $\\lambda_j$.\n7.  Compare this minimum absolute eigenvalue with the threshold $\\lambda_{\\text{thr}}$. If $\\min_j|\\lambda_j|  \\lambda_{\\text{thr}}$, the configuration is exceptional (True); otherwise, it is not (False).\n\nThis procedure is implemented for each test case to produce the final boolean results. For the free case, the results can be verified analytically by Fourier transforming the operator, which reveals that the eigenvalues are given by $\\lambda = \\pm \\sqrt{(m_0+4 - \\cos p_1 - \\cos p_2)^2 + \\sin^2 p_1 + \\sin^2 p_2}$ for momenta $p_\\mu = \\frac{2\\pi k_\\mu}{L}$. The minimum absolute eigenvalue corresponds to the momentum mode that minimizes this expression. For our parameters, this occurs at $p=(0,0)$ where $|\\lambda| = |m_0+2|$. For the dislocation case, such a simplification is not possible, and a full numerical diagonalization is required.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases provided in the problem.\n    \"\"\"\n    test_cases = [\n        # Case 1: L=4, free, m0=-1.90, thr=0.04\n        (4, ('free',), -1.90, 0.04),\n        # Case 2: L=4, free, m0=-1.97, thr=0.04\n        (4, ('free',), -1.97, 0.04),\n        # Case 3: L=4, free, m0=-1.96, thr=0.04\n        (4, ('free',), -1.96, 0.04),\n        # Case 4: L=4, dislocation, m0=-1.90, thr=0.10\n        (4, ('dislocation', np.pi), -1.90, 0.10)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, gauge_config, m0, lambda_thr = case\n        is_exc = is_exceptional(L, gauge_config, m0, lambda_thr)\n        results.append(is_exc)\n\n    # The final output must be lowercase boolean values.\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\ndef is_exceptional(L, gauge_config, m0, lambda_thr):\n    \"\"\"\n    Determines if a given lattice configuration is exceptional.\n\n    This function constructs the Hermitian Wilson-Dirac operator H_W, computes its\n    eigenvalues, and then checks if the smallest absolute eigenvalue is strictly\n    less than the specified threshold.\n    \n    Args:\n        L (int): The linear extent of the square lattice.\n        gauge_config (tuple): Specifies the gauge field background.\n                              e.g., ('free',) or ('dislocation', phi).\n        m0 (float): The bare mass parameter.\n        lambda_thr (float): The eigenvalue threshold for the exceptional condition.\n\n    Returns:\n        bool: True if the configuration is exceptional, False otherwise.\n    \"\"\"\n    # Construct the full matrix for the operator H_W.\n    Hw = build_hw_matrix(L, m0, gauge_config)\n    \n    # Eigenvalues of a Hermitian matrix are real.\n    # We use numpy's specialized solver for Hermitian matrices.\n    eigenvalues = np.linalg.eigvalsh(Hw)\n    \n    # Find the minimum of the absolute values of the eigenvalues.\n    min_abs_eigenvalue = np.min(np.abs(eigenvalues))\n    \n    # Check the strict inequality for the exceptional condition.\n    return min_abs_eigenvalue  lambda_thr\n\ndef build_hw_matrix(L, m0, gauge_config):\n    \"\"\"\n    Constructs the matrix for the Hermitian Wilson-Dirac operator H_W = gamma_5 * D_W.\n    \n    Args:\n        L (int): The linear extent of the lattice.\n        m0 (float): The bare mass.\n        gauge_config (tuple): The gauge field configuration.\n\n    Returns:\n        numpy.ndarray: The complex matrix representing H_W.\n    \"\"\"\n    N_sites = L * L\n    dim = 2 * N_sites\n    Hw = np.zeros((dim, dim), dtype=np.complex128)\n    \n    # Parameters from problem statement\n    r = 1.0\n    d = 2\n\n    # Gamma matrices (in 2D, these are the Pauli matrices)\n    gamma1 = np.array([[0, 1], [1, 0]], dtype=np.complex128)\n    gamma2 = np.array([[0, -1j], [1j, 0]], dtype=np.complex128)\n    gamma5 = np.array([[1, 0], [0, -1]], dtype=np.complex128)\n    gamma = {1: gamma1, 2: gamma2}\n    I2 = np.identity(2, dtype=np.complex128)\n\n    # Generate the gauge link configuration U_mu(x) as a dictionary.\n    links_U = {}\n    config_type = gauge_config[0]\n    for x1 in range(L):\n        for x2 in range(L):\n            links_U[(x1, x2, 1)] = 1.0 + 0.0j\n            links_U[(x1, x2, 2)] = 1.0 + 0.0j\n    \n    if config_type == \"dislocation\":\n        # Introduce a non-trivial link at x*=(0,0), mu*=1 with angle phi\n        phi = gauge_config[1]\n        links_U[(0, 0, 1)] = np.exp(1j * phi)\n\n    # Prefactor for the mass term from the definition: (m_0 + 2*d*r)\n    mass_term_prefactor = m0 + 2 * d * r\n\n    # Iterate over all lattice sites x (defining the matrix's row blocks)\n    for x1 in range(L):\n        for x2 in range(L):\n            x_idx = x1 * L + x2  # Row-major site index\n            \n            # --- Diagonal Block: connects site x to itself ---\n            # This block is H_{x,x} = gamma_5 * (m_0 + 2*d*r) * I_2\n            diag_block = mass_term_prefactor * gamma5\n            Hw[2*x_idx : 2*x_idx+2, 2*x_idx : 2*x_idx+2] = diag_block\n            \n            # --- Off-diagonal (hopping) blocks ---\n            for mu in [1, 2]:\n                # --- Forward hop: connects site x+mu to x ---\n                # This contributes to matrix block H_{x, x+mu}\n                x_fwd_1 = (x1 + 1) % L if mu == 1 else x1\n                x_fwd_2 = (x2 + 1) % L if mu == 2 else x2\n                x_fwd_idx = x_fwd_1 * L + x_fwd_2\n                \n                U_mu_x = links_U[(x1, x2, mu)]\n                # The block is -1/2 * gamma_5 * (r*I_2 - gamma_mu) * U_mu(x)\n                fwd_hop_block = -0.5 * (gamma5 @ (r * I2 - gamma[mu])) * U_mu_x\n                Hw[2*x_idx : 2*x_idx+2, 2*x_fwd_idx : 2*x_fwd_idx+2] = fwd_hop_block\n                \n                # --- Backward hop: connects site x-mu to x ---\n                # This contributes to matrix block H_{x, x-mu}\n                x_bwd_1 = (x1 - 1 + L) % L if mu == 1 else x1\n                x_bwd_2 = (x2 - 1 + L) % L if mu == 2 else x2\n                x_bwd_idx = x_bwd_1 * L + x_bwd_2\n\n                # The formula requires the link U_mu(x-mu)\n                U_mu_x_minus_mu = links_U[(x_bwd_1, x_bwd_2, mu)]\n                # The block is -1/2 * gamma_5 * (r*I_2 + gamma_mu) * U_mu(x-mu)^dagger\n                bwd_hop_block = -0.5 * (gamma5 @ (r * I2 + gamma[mu])) * np.conj(U_mu_x_minus_mu)\n                Hw[2*x_idx : 2*x_idx+2, 2*x_bwd_idx : 2*x_bwd_idx+2] = bwd_hop_block\n                \n    return Hw\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2407358"}, {"introduction": "A central prediction of Quantum Chromodynamics (QCD), quark confinement, is beautifully demonstrated in lattice simulations by calculating the potential energy $V(r)$ between a static quark and antiquark. This practice [@problem_id:2407364] guides you through extracting this potential from synthetic measurements of Wilson loops, $\\langle W(r, t) \\rangle$. By analyzing the exponential decay of these correlators at large Euclidean times, you will master a fundamental data analysis technique in lattice field theory: isolating the ground state energy from a signal contaminated by excited states.", "problem": "Consider a pure gauge theory in Euclidean space-time discretized on a hypercubic lattice with lattice spacing $a$. All quantities are to be expressed in lattice units, i.e., set $a = 1$, so that all distances and times are dimensionless. In Euclidean Lattice Gauge Theory (LGT), the expectation value of a rectangular Wilson loop $\\langle W(r, t) \\rangle$ encodes the energy of a static quark-antiquark pair separated by spatial distance $r$ propagated for Euclidean time extent $t$. From the transfer-matrix construction, the large-$t$ decay of $\\langle W(r, t) \\rangle$ is governed by the lowest energy state compatible with the static sources at separation $r$. This lowest energy is the static potential $V(r)$ in lattice units. Your task is to implement a principled numerical estimator for $V(r)$ from provided synthetic measurements of $\\langle W(r, t) \\rangle$ as a function of $t$ for several fixed values of $r$. Work entirely with the provided data below and produce numerical answers in lattice units.\n\nDesign your program to:\n- Use only the late-time behavior implied by the transfer-matrix formalism, starting from the general principle that a Euclidean-time correlator is a sum of decaying exponentials dominated at large $t$ by the lowest energy.\n- Construct from $\\log \\langle W(r, t) \\rangle$ a discrete-time effective decay rate based on successive time slices, and detect a ground-state plateau in that effective rate using a stability threshold $\\delta$ and a minimum plateau length $L_{\\min}$.\n- If no plateau of length at least $L_{\\min}$ is found, perform a least-squares linear fit to $\\log \\langle W(r, t) \\rangle$ over the last $K$ time slices with $K = \\max(L_{\\min}+1, \\lfloor T/2 \\rfloor)$, where $T$ is the number of available time slices for that case.\n- Return one estimate per case, each rounded to three decimals.\n\nPlateau detection rule:\n- Let $\\delta = 0.02$ and $L_{\\min} = 3$.\n- Identify the longest contiguous window in the discrete effective decay-rate sequence where successive changes have absolute value smaller than $\\delta$. Among ties, prefer the window with the smallest sample variance. Estimate $V(r)$ by the mean value over that window.\n\nData to analyze (synthetic, self-consistent, and strictly positive to avoid any issues taking logarithms). For each case, $t$ runs over integer slices listed explicitly; all numbers are given to six decimal places. The separation $r$ is provided for context but does not enter the estimator beyond identifying the case.\n\nCase $1$ (separation $r = 2$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(2, t) \\rangle = [0.885200, 0.683800, 0.529500, 0.409900, 0.319400, 0.249000, 0.193900, 0.151200]$\n\nCase $2$ (separation $r = 3$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(3, t) \\rangle = [0.784200, 0.553600, 0.392000, 0.278800, 0.198600, 0.141700, 0.101100, 0.072150]$\n\nCase $3$ (separation $r = 1$, $t \\in \\{1,2,3,4,5\\}$):\n- $\\langle W(1, t) \\rangle = [0.860708, 0.740818, 0.637628, 0.548812, 0.472367]$\n\nCase $4$ (separation $r = 4$, $t \\in \\{1,2,3,4,5,6,7,8\\}$):\n- $\\langle W(4, t) \\rangle = [0.756250, 0.465500, 0.289700, 0.182200, 0.115400, 0.073050, 0.046930, 0.030016]$\n\nNumerical and output requirements:\n- All outputs must be expressed in lattice units (dimensionless).\n- For each case, return a single real number equal to your estimate of $V(r)$, rounded to three decimals.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order of the cases above. For example, the output must look like $[v_1,v_2,v_3,v_4]$ with each $v_i$ shown with exactly three digits after the decimal point.\n\nTest suite and coverage:\n- Case $1$ is a standard “happy path” with mild excited-state contamination and a clear late-time plateau.\n- Case $2$ tests a steeper decay with a longer time series and a well-defined plateau.\n- Case $3$ is a boundary case with a short time range and nearly pure single-exponential decay.\n- Case $4$ is a challenging case with stronger contamination at early times; the estimator must rely on late-time stability.\n\nYour program must be complete and runnable as given, require no user input, and adhere strictly to the final output format.", "solution": "The problem requires the estimation of the static quark-antiquark potential, denoted $V(r)$, from synthetic data for the expectation value of a rectangular Wilson loop, $\\langle W(r, t) \\rangle$. The analysis is performed within the framework of Euclidean Lattice Gauge Theory, with all quantities expressed in dimensionless lattice units where the lattice spacing $a$ is set to $1$.\n\nThe fundamental principle underlying this problem is derived from the transfer-matrix formalism of lattice field theory. A Euclidean-time correlator, such as $\\langle W(r, t) \\rangle$, can be expressed as a sum over energy eigenstates of the system's Hamiltonian:\n$$\n\\langle W(r, t) \\rangle = \\sum_{n=0}^{\\infty} |\\langle n | \\hat{W}(r) | \\Omega \\rangle|^2 e^{-E_n(r) t}\n$$\nwhere $|\\Omega\\rangle$ is the vacuum state, $\\hat{W}(r)$ is the operator creating the Wilson loop of spatial size $r$ at time $t=0$, and $|n\\rangle$ are the energy eigenstates of the system containing the static quark-antiquark sources, with corresponding energies $E_n(r)$. For large Euclidean time $t$, the sum is dominated by the term with the lowest energy, the ground state $E_0(r)$, which is by definition the static potential $V(r)$. Thus, for sufficiently large $t$, we have the approximation:\n$$\n\\langle W(r, t) \\rangle \\approx C \\cdot e^{-V(r)t}\n$$\nwhere $C = |\\langle 0 | \\hat{W}(r) | \\Omega \\rangle|^2$ is a constant overlap factor.\n\nTo extract $V(r)$, we can analyze the logarithm of the Wilson loop data:\n$$\n\\log \\langle W(r, t) \\rangle \\approx \\log(C) - V(r)t\n$$\nThis shows that $\\log \\langle W(r, t) \\rangle$ is approximately a linear function of $t$ with a slope of $-V(r)$. A standard method to estimate this slope locally is to compute the discrete derivative, which defines an effective potential or effective mass, $V_{\\text{eff}}(t)$. It is defined for a discrete time step of $\\Delta t = 1$ as:\n$$\nV_{\\text{eff}}(t) = -\\frac{\\log \\langle W(r, t+1) \\rangle - \\log \\langle W(r, t) \\rangle}{(t+1) - t} = -\\log\\left(\\frac{\\langle W(r, t+1) \\rangle}{\\langle W(r, t) \\rangle}\\right)\n$$\nAs $t$ becomes large, the contributions from excited states with $E_n(r)  V(r)$ become negligible, and $V_{\\text{eff}}(t)$ approaches the true potential $V(r)$, forming a \"plateau\" in a plot of $V_{\\text{eff}}$ versus $t$. The task is to identify this plateau and extract an estimate for $V(r)$.\n\nThe prescribed algorithm for this task is as follows:\n\n1.  For each dataset of $\\langle W(r, t) \\rangle$ values, calculate the sequence of effective potentials $V_{\\text{eff}}(t)$. A dataset with $T$ time slices will yield a sequence of $T-1$ values for $V_{\\text{eff}}$.\n\n2.  Search for a plateau in the $V_{\\text{eff}}(t)$ sequence. A contiguous subsequence (window) of $V_{\\text{eff}}$ values is considered a plateau if the absolute difference between any two successive values in the window is less than a stability threshold, $\\delta = 0.02$.\n\n3.  From all such identified plateaus, select the one that meets the criteria:\n    a. It must have a length of at least $L_{\\min} = 3$.\n    b. Among all plateaus satisfying (a), we choose the one with the maximum length.\n    c. If there is a tie for the maximum length, the tie is broken by selecting the window with the smallest sample variance.\n\n4.  If a unique best plateau is found by this procedure, the estimate for $V(r)$ is the arithmetic mean of the $V_{\\text{eff}}$ values within that plateau window.\n\n5.  If no plateau of length at least $L_{\\min}=3$ is found, a fallback procedure is used. A least-squares linear fit is performed on the last $K$ points of the $\\log \\langle W(r, t) \\rangle$ versus $t$ data. The number of points for the fit is given by $K = \\max(L_{\\min}+1, \\lfloor T/2 \\rfloor)$. The estimate for the potential is then $V(r) = -m$, where $m$ is the slope of the fitted line.\n\nLet us illustrate with Case $4$ ($r=4, T=8$):\nThe data for $\\langle W(4, t) \\rangle$ are given. First, we compute the natural logarithm:\n$\\log \\langle W(4, t) \\rangle = [-0.27941, -0.76461, -1.23891, -1.70261, -2.15951, -2.61641, -2.99720, -3.50600]$\nNext, we calculate the effective potential sequence $V_{\\text{eff}}(t) = -(\\log \\langle W(4, t+1) \\rangle - \\log \\langle W(4, t) \\rangle)$:\n$V_{\\text{eff}} = [0.48520, 0.47430, 0.46370, 0.45690, 0.45690, 0.38079, 0.50880]$\nThis sequence has $T-1 = 7$ values. We search for plateaus with $\\delta=0.02$. The absolute differences between successive values are:\n$|\\Delta V_{\\text{eff}}| = [0.01090, 0.01060, 0.00680, 0.00000, 0.07611, 0.12801]$\nThe first four differences are less than $\\delta = 0.02$. This allows us to identify all possible plateau windows. The longest such window has length $5$ and corresponds to the first five values of $V_{\\text{eff}}$:\n$P_1 = [0.48520, 0.47430, 0.46370, 0.45690, 0.45690]$.\nOther valid plateaus of length at least $L_{\\min}=3$ exist (e.g., $[0.48520, 0.47430, 0.46370]$), but they are shorter. The maximum length found is $5$, which is greater than or equal to $L_{\\min}=3$. Since there is only one plateau of this maximal length, it is selected. The potential $V(4)$ is estimated as the mean of this window:\n$V(4) \\approx \\text{mean}(P_1) = \\frac{0.48520 + 0.47430 + 0.46370 + 0.45690 + 0.45690}{5} = 0.46738$\nRounding to three decimal places gives $0.467$. This procedure is applied to all four cases to obtain the final set of results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: r=2\n        [0.885200, 0.683800, 0.529500, 0.409900, 0.319400, 0.249000, 0.193900, 0.151200],\n        # Case 2: r=3\n        [0.784200, 0.553600, 0.392000, 0.278800, 0.198600, 0.141700, 0.101100, 0.072150],\n        # Case 3: r=1\n        [0.860708, 0.740818, 0.637628, 0.548812, 0.472367],\n        # Case 4: r=4\n        [0.756250, 0.465500, 0.289700, 0.182200, 0.115400, 0.073050, 0.046930, 0.030016]\n    ]\n\n    delta = 0.02\n    L_min = 3\n\n    results = []\n    for w_vals in test_cases:\n        result = estimate_potential(w_vals, delta, L_min)\n        results.append(result)\n\n    # Format the final output string with results rounded to three decimal places.\n    formatted_results = [f\"{r:.3f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef estimate_potential(w_vals, delta, l_min):\n    \"\"\"\n    Estimates the static potential V(r) from Wilson loop data for a single case.\n    \"\"\"\n    w_vals = np.array(w_vals)\n    T = len(w_vals)\n    \n    # Calculate log of Wilson loops and the effective potential\n    log_w = np.log(w_vals)\n    v_eff = -np.diff(log_w)\n    \n    # --- Plateau Detection ---\n    all_plateaus = []\n    for i in range(len(v_eff)):\n        for j in range(i, len(v_eff)):\n            window = v_eff[i:j+1]\n            if len(window) > 1:\n                is_plateau = np.all(np.abs(np.diff(window))  delta)\n            else:\n                is_plateau = True # A single point is a trivial plateau\n            \n            if is_plateau:\n                all_plateaus.append(window)\n\n    valid_plateaus = [p for p in all_plateaus if len(p) >= l_min]\n\n    if valid_plateaus:\n        # Find the longest valid plateau(s)\n        max_len = max(len(p) for p in valid_plateaus)\n        longest_plateaus = [p for p in valid_plateaus if len(p) == max_len]\n        \n        best_plateau = None\n        if len(longest_plateaus) == 1:\n            best_plateau = longest_plateaus[0]\n        else:\n            # Tie-breaking with minimum sample variance\n            min_var = np.inf\n            for p in longest_plateaus:\n                # Use ddof=1 for sample variance. If len is 1, variance is 0.\n                var = np.var(p, ddof=1) if len(p) > 1 else 0\n                if var  min_var:\n                    min_var = var\n                    best_plateau = p\n        \n        # Estimate potential from the mean of the best plateau\n        return np.mean(best_plateau)\n    else:\n        # --- Fallback: Linear Fit ---\n        # No plateau of length L_min found, perform a fit\n        K = max(l_min + 1, T // 2)\n        \n        # time slices are 1, 2, ..., T\n        t_slices = np.arange(1, T + 1)\n        \n        # Select last K points for the fit\n        t_fit = t_slices[-K:]\n        log_w_fit = log_w[-K:]\n        \n        # Perform linear regression: log_w = m*t + c\n        # The potential V is -m (the negative of the slope)\n        slope, _ = np.polyfit(t_fit, log_w_fit, 1)\n        \n        return -slope\n\n# Execute the solver\nsolve()\n```", "id": "2407364"}, {"introduction": "Lattice simulations are necessarily performed in a finite spacetime volume, an approximation that introduces systematic effects that must be carefully understood and controlled. This practice [@problem_id:2407383] illuminates one of the most fundamental of these effects: the quantization of momentum for a particle confined to a periodic spatial box. By applying the relativistic energy-momentum relation, you will quantify how a particle's energy spectrum is altered by the size of its container, providing a clear and tangible understanding of finite-volume systematics.", "problem": "Consider a stable, non-interacting relativistic hadron of rest mass $m$ confined to a cubic spatial box of side length $L$ with Periodic Boundary Conditions (PBC). The spatial directions are periodic and the temporal direction is taken sufficiently large so that temporal finite-size effects can be neglected. Under PBC, single-particle spatial momenta are quantized as $p_i = \\frac{2\\pi \\hbar}{L} n_i$ with $n_i \\in \\mathbb{Z}$ for each Cartesian component $i \\in \\{x,y,z\\}$. In a relativistic theory with natural units where the speed of light $c$ is set to $c=1$, the single-particle energy for momentum $\\mathbf{p}$ is $E = \\sqrt{m^2 + \\mathbf{p}^2}$. When reporting energies in gigaelectronvolt, and lengths in femtometer, use the conversion constant $\\hbar c = 0.1973269804\\,\\mathrm{GeV}\\,\\mathrm{fm}$ exactly as given. Thus, if $L$ is specified in femtometer and $\\mathbf{n}=(n_x,n_y,n_z)$, the magnitude of the spatial momentum in gigaelectronvolt is $|\\mathbf{p}| = \\frac{2\\pi\\,(\\hbar c)}{L}\\,|\\mathbf{n}|$ with $|\\mathbf{n}|=\\sqrt{n_x^2+n_y^2+n_z^2}$.\n\nYour task is to quantify finite-volume effects on energy levels induced solely by spatial momentum quantization. For each test case, compute the finite-volume energy difference\n$$\n\\Delta E = E(\\mathbf{n}, L_1) - E(\\mathbf{n}, L_2),\n$$\nwhere\n$$\nE(\\mathbf{n}, L) = \\sqrt{m^2 + \\left(\\frac{2\\pi\\,(\\hbar c)}{L}\\,|\\mathbf{n}|\\right)^2}.\n$$\nAll energies must be expressed in gigaelectronvolt, and all lengths must be expressed in femtometer. For each test case, the inputs are a tuple $(m, L_1, L_2, n_x, n_y, n_z)$ with $m$ in gigaelectronvolt, $L_1$ and $L_2$ in femtometer, and $n_x, n_y, n_z$ integers. The output for each test case is the floating-point value of $\\Delta E$ in gigaelectronvolt. For $|\\mathbf{n}|=0$, note that $\\Delta E$ must be $0$.\n\nUse the following exact test suite of parameter sets:\n- Test case $1$: $(m, L_1, L_2, n_x, n_y, n_z) = (0.140, 2.0, 4.0, 1, 0, 0)$.\n- Test case $2$: $(m, L_1, L_2, n_x, n_y, n_z) = (0.938, 3.0, 5.0, 0, 0, 0)$.\n- Test case $3$: $(m, L_1, L_2, n_x, n_y, n_z) = (0.140, 1.5, 100.0, 1, 1, 0)$.\n- Test case $4$: $(m, L_1, L_2, n_x, n_y, n_z) = (1.320, 2.5, 3.0, 1, 1, 1)$.\n- Test case $5$: $(m, L_1, L_2, n_x, n_y, n_z) = (0.500, 0.8, 1.6, 2, 0, 0)$.\n\nYour program must:\n- Use $\\hbar c = 0.1973269804\\,\\mathrm{GeV}\\,\\mathrm{fm}$ exactly.\n- Produce, for each test case, the value of $\\Delta E$ in gigaelectronvolt, rounded to six digits after the decimal point.\n- Output a single line containing the results aggregated in order as a comma-separated list enclosed in square brackets, for example $[x_1,x_2,x_3,x_4,x_5]$, where each $x_i$ is the rounded value for test case $i$.\n\nNo external input should be read. The program must execute deterministically and produce the single required output line only.", "solution": "The problem as stated is scientifically grounded, well-posed, and objective. It presents a standard calculation in the field of computational particle physics, specifically the study of finite-volume effects on hadron properties in lattice Quantum Chromodynamics (QCD). The problem provides all necessary definitions, constants, and data, and is free of contradictions or ambiguities. It is therefore valid and can be solved directly.\n\nThe task is to compute the energy difference of a relativistic particle when its confining volume is changed. This energy shift is a direct consequence of the quantization of momentum in a finite spatial volume with periodic boundary conditions. The underlying principles are fundamental to relativistic quantum mechanics.\n\nFirst, the energy $E$ of a relativistic particle with rest mass $m$ and momentum $\\mathbf{p}$ is given by the dispersion relation:\n$$\nE^2 = m^2 + \\mathbf{p}^2\n$$\nHere we use natural units where the speed of light $c=1$.\n\nSecond, in quantum mechanics, the momentum of a particle is related to its wave vector $\\mathbf{k}$ via the de Broglie relation, $\\mathbf{p} = \\hbar \\mathbf{k}$, where $\\hbar$ is the reduced Planck constant.\n\nThird, confining the particle to a cubic box of side length $L$ with periodic boundary conditions imposes a constraint on the particle's wave function, $\\psi(\\mathbf{x})$. The periodicity requirement, $\\psi(x, y, z) = \\psi(x+L, y, z) = \\psi(x, y+L, z) = \\psi(x, y, z+L)$, restricts the allowed components of the wave vector $\\mathbf{k}$ to discrete values:\n$$\nk_i = \\frac{2\\pi}{L} n_i, \\quad \\text{for } i \\in \\{x, y, z\\}\n$$\nwhere $n_x, n_y, n_z$ are integers, which we can group into a vector $\\mathbf{n} = (n_x, n_y, n_z)$.\n\nCombining these principles, the allowed momentum components are quantized:\n$$\np_i = \\hbar k_i = \\frac{2\\pi\\hbar}{L} n_i\n$$\nThe squared magnitude of the momentum vector $\\mathbf{p}$ is then\n$$\n|\\mathbf{p}|^2 = p_x^2 + p_y^2 + p_z^2 = \\left(\\frac{2\\pi\\hbar}{L}\\right)^2 (n_x^2 + n_y^2 + n_z^2) = \\left(\\frac{2\\pi\\hbar}{L}\\right)^2 |\\mathbf{n}|^2\n$$\nwhere $|\\mathbf{n}| = \\sqrt{n_x^2 + n_y^2 + n_z^2}$.\n\nSubstituting this quantized momentum into the relativistic energy-momentum relation, and explicitly using the conversion constant $\\hbar c$, which is necessary when mass and energy are given in units of gigaelectronvolts ($\\mathrm{GeV}$) and length is in femtometers ($\\mathrm{fm}$), we obtain the expression for the quantized energy levels $E(\\mathbf{n}, L)$:\n$$\nE(\\mathbf{n}, L) = \\sqrt{m^2 + |\\mathbf{p}|^2} = \\sqrt{m^2 + \\left(\\frac{2\\pi(\\hbar c)}{L}\\right)^2 |\\mathbf{n}|^2}\n$$\nThis precisely matches the formula provided in the problem statement. The problem asks for the computation of the finite-volume energy difference, $\\Delta E$, for a particle with fixed quantum numbers $\\mathbf{n}$ but confined in two different volumes of side lengths $L_1$ and $L_2$:\n$$\n\\Delta E = E(\\mathbf{n}, L_1) - E(\\mathbf{n}, L_2)\n$$\n\nThe computational procedure is a direct application of this formula for each specified test case. For a given test case, defined by the tuple $(m, L_1, L_2, n_x, n_y, n_z)$:\n$1$. We identify the constants: rest mass $m$, box lengths $L_1$ and $L_2$, and the momentum quantum numbers $(n_x, n_y, n_z)$. The value of the conversion constant is fixed at $\\hbar c = 0.1973269804\\,\\mathrm{GeV}\\,\\mathrm{fm}$.\n$2$. We calculate the magnitude of the integer vector $\\mathbf{n}$: $|\\mathbf{n}| = \\sqrt{n_x^2 + n_y^2 + n_z^2}$.\n$3$. A special case must be considered: if $\\mathbf{n} = \\mathbf{0}$, then $|\\mathbf{n}|=0$. In this case, the momentum $|\\mathbf{p}|$ is zero, and the energy is simply the rest energy, $E(\\mathbf{0}, L) = \\sqrt{m^2+0} = m$, which is independent of the volume size $L$. Consequently, $\\Delta E = E(\\mathbf{0}, L_1) - E(\\mathbf{0}, L_2) = m - m = 0$.\n$4$. For non-zero $\\mathbf{n}$, we first calculate the energy $E(\\mathbf{n}, L_1)$ using the formula:\n$$\nE(\\mathbf{n}, L_1) = \\sqrt{m^2 + \\left(\\frac{2\\pi(\\hbar c)}{L_1} |\\mathbf{n}|\\right)^2}\n$$\n$5$. Next, we calculate the energy $E(\\mathbf{n}, L_2)$:\n$$\nE(\\mathbf{n}, L_2) = \\sqrt{m^2 + \\left(\\frac{2\\pi(\\hbar c)}{L_2} |\\mathbf{n}|\\right)^2}\n$$\n$6$. Finally, the energy difference $\\Delta E$ is computed as their subtraction.\n$7$. The resulting value of $\\Delta E$ for each test case is rounded to six digits after the decimal point and aggregated into the final output format.\n\nThis procedure is implemented for each of the five test cases to produce the final result.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the finite-volume energy differences for a series of test cases.\n    \"\"\"\n    \n    # The problem specifies using this exact value for the hbar*c conversion constant.\n    # Unit: GeV*fm\n    hbar_c = 0.1973269804\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m [GeV], L1 [fm], L2 [fm], nx, ny, nz)\n    test_cases = [\n        (0.140, 2.0, 4.0, 1, 0, 0),\n        (0.938, 3.0, 5.0, 0, 0, 0),\n        (0.140, 1.5, 100.0, 1, 1, 0),\n        (1.320, 2.5, 3.0, 1, 1, 1),\n        (0.500, 0.8, 1.6, 2, 0, 0),\n    ]\n\n    results = []\n\n    def calculate_energy(m, L, n_mag):\n        \"\"\"\n        Calculates the single-particle energy E(n, L).\n        \"\"\"\n        # For the ground state (zero momentum), energy is just the rest mass.\n        if n_mag == 0:\n            return m\n        \n        # Momentum is quantized in a periodic box.\n        p_mag_squared = ((2 * np.pi * hbar_c / L) * n_mag)**2\n        \n        # Relativistic energy-momentum relation E^2 = m^2 + p^2.\n        energy = np.sqrt(m**2 + p_mag_squared)\n        return energy\n\n    for case in test_cases:\n        m, L1, L2, nx, ny, nz = case\n        \n        # Calculate the magnitude of the integer momentum vector n.\n        n_mag = np.sqrt(nx**2 + ny**2 + nz**2)\n        \n        # Calculate the energy in each of the two volumes.\n        E1 = calculate_energy(m, L1, n_mag)\n        E2 = calculate_energy(m, L2, n_mag)\n        \n        # Compute the energy difference.\n        delta_E = E1 - E2\n        \n        # Format the result to six decimal places, as required.\n        results.append(f\"{delta_E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2407383"}]}