{"hands_on_practices": [{"introduction": "Before diving into complex computational methods, let's start with the foundational principle connecting a system's dynamics to its geometry in phase space. For simple, integrable systems, the trajectories traced on a Poincaré section directly correspond to the level sets of the system's Hamiltonian. This exercise inverts the usual process: instead of predicting the trajectory from a known Hamiltonian, you will deduce the governing Hamiltonian itself by analyzing the shape of a given invariant curve, providing a powerful insight into how geometry reveals the underlying physics [@problem_id:2427582].", "problem": "Consider a time-independent Hamiltonian system with one degree of freedom in canonical coordinates $(q,p)$. For such a system, the invariant curves observed in a Poincaré section coincide with the constant-energy level sets of the Hamiltonian in the $(q,p)$ plane. An experimentally obtained Poincaré section at a particular energy shows a single invariant curve given by the ellipse\n$$(\\tfrac{q}{2})^{2}+(\\tfrac{p}{3})^{2}=1.$$\nAssume dimensionless units with unit mass, and that the Hamiltonian is the simplest positive-definite quadratic form separable into kinetic and potential energy,\n$$H(q,p)=\\tfrac{1}{2}p^{2}+\\tfrac{1}{2}k q^{2},$$\nwith $k>0$ to be determined so that the given ellipse is exactly one of its constant-energy curves. Determine the explicit closed-form expression for $H(q,p)$.\n\nExpress your final answer as a single analytic expression in $(q,p)$ using dimensionless units. No rounding is required.", "solution": "The problem statement is subjected to rigorous validation.\n\nStep 1: Extract Givens.\n- A time-independent Hamiltonian system with one degree of freedom in canonical coordinates $(q,p)$.\n- A specific invariant curve from a Poincaré section is given by the equation of an ellipse: $(\\frac{q}{2})^{2}+(\\frac{p}{3})^{2}=1$.\n- Dimensionless units are assumed, with unit mass. The Hamiltonian takes the form $H(q,p)=\\frac{1}{2}p^{2}+\\frac{1}{2}k q^{2}$.\n- The parameter $k$ is positive, $k>0$.\n- The task is to find the explicit closed-form expression for $H(q,p)$.\n\nStep 2: Validate Using Extracted Givens.\n- Scientific Grounding: The problem describes a simple harmonic oscillator, a fundamental model in classical mechanics. The correspondence between constant-energy surfaces in phase space and system trajectories is a core tenet of Hamiltonian dynamics. The specified form of the Hamiltonian is standard for a harmonic oscillator with unit mass. The problem is scientifically sound.\n- Well-Posedness: The problem provides the functional form of the Hamiltonian with one unknown parameter, $k$, and a constraint (the equation of a specific energy level set). This is sufficient information to uniquely determine $k$ and thus the Hamiltonian. The problem is well-posed.\n- Objectivity: The problem is stated in precise, quantitative terms, free of ambiguity or subjective claims.\n\nStep 3: Verdict and Action.\nThe problem is valid as it is scientifically grounded, well-posed, objective, and contains sufficient information for a unique solution. I will proceed with the derivation of the solution.\n\nThe problem states that for a one-degree-of-freedom, time-independent Hamiltonian system, the constant-energy level sets in phase space are the invariant curves. The Hamiltonian is given in the form of a simple harmonic oscillator:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2}$$\nwhere $k>0$ is a constant to be determined. A constant-energy curve is defined by the equation $H(q,p) = E$ for some constant energy $E$.\n$$\\frac{1}{2}p^{2} + \\frac{1}{2}k q^{2} = E$$\nSince the Hamiltonian is a sum of squares with $k>0$, it is a positive-definite quadratic form. For a non-trivial ellipse as given, the energy must be positive, $E>0$. To compare this equation to the standard form of an ellipse, we divide by $E$:\n$$\\frac{p^{2}}{2E} + \\frac{k q^{2}}{2E} = 1$$\nThis equation can be rewritten in the canonical form for an ellipse, $\\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1$, as:\n$$\\left(\\frac{q}{\\sqrt{\\frac{2E}{k}}}\\right)^{2} + \\left(\\frac{p}{\\sqrt{2E}}\\right)^{2} = 1$$\nThis equation describes the family of all possible constant-energy curves for the given Hamiltonian form.\n\nThe problem provides an experimentally determined invariant curve, which must correspond to one specific energy level. The equation for this curve is:\n$$\\left(\\frac{q}{2}\\right)^{2} + \\left(\\frac{p}{3}\\right)^{2} = 1$$\nBy comparing the two expressions for the ellipse, we can equate the semi-axes in the $q$ and $p$ directions.\nThe semi-axis in the $q$ direction gives the equation:\n$$\\sqrt{\\frac{2E}{k}} = 2$$\nThe semi-axis in the $p$ direction gives the equation:\n$$\\sqrt{2E} = 3$$\nThis provides a system of two equations for the two unknowns, $E$ and $k$. From the second equation, we can solve for the energy $E$ of this specific invariant curve. Squaring both sides yields:\n$$2E = 9 \\implies E = \\frac{9}{2}$$\nNow, we substitute this value of $E$ into the first equation to solve for $k$:\n$$\\sqrt{\\frac{2\\left(\\frac{9}{2}\\right)}{k}} = 2$$\n$$\\sqrt{\\frac{9}{k}} = 2$$\nSquaring both sides of this equation gives:\n$$\\frac{9}{k} = 4$$\nSolving for $k$, we find:\n$$k = \\frac{9}{4}$$\nThis value satisfies the condition $k>0$. The problem asks for the explicit closed-form expression for the Hamiltonian $H(q,p)$, not the energy of the particular observed curve. We now substitute the determined value of $k$ back into the general form of the Hamiltonian:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{1}{2}\\left(\\frac{9}{4}\\right)q^{2}$$\nSimplifying this expression gives the final form of the Hamiltonian:\n$$H(q,p) = \\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}$$\nThis is the Hamiltonian that generates the given ellipse as its constant-energy curve for $E = \\frac{9}{2}$.", "answer": "$$\\boxed{\\frac{1}{2}p^{2} + \\frac{9}{8}q^{2}}$$", "id": "2427582"}, {"introduction": "Having established the link between geometry and energy, we now move from simple ellipses to the rich and complex world of chaos. This practice challenges you to numerically generate a Poincaré section for the Hénon-Heiles system, a classic model used to understand chaotic dynamics in everything from star clusters to molecules. You will implement the core algorithm—integrating equations of motion and detecting crossings of a surface—which is a fundamental skill for visualizing and analyzing complex dynamical systems [@problem_id:2427559].", "problem": "Consider the two-degree-of-freedom Hénon-Heiles Hamiltonian system in dimensionless units,\n$$\nH(q_1,q_2,p_1,p_2) = \\frac{1}{2}\\left(p_1^2 + p_2^2 + q_1^2 + q_2^2\\right) + q_1^2 q_2 - \\frac{1}{3} q_2^3.\n$$\nThe equations of motion follow from Hamilton's equations. Define a one-parameter family of rotated section coordinates in the $(q_2,p_2)$ subspace by\n$$\n\\begin{pmatrix}\nu \\\\\nv\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\cos \\theta & \\sin \\theta \\\\\n- \\sin \\theta & \\cos \\theta\n\\end{pmatrix}\n\\begin{pmatrix}\nq_2 \\\\\np_2\n\\end{pmatrix},\n$$\nwith angle $\\theta$ in radians. The Poincaré section hypersurface is defined by the condition $u=0$, with the transverse crossing orientation restricted by $v>0$. At each such crossing, record the pair $(q_1,p_1)$.\n\nFor a given total energy $E>0$, construct the initial condition on the energy shell as follows. Fix $q_1(0)=0$. Choose a small positive amplitude $\\alpha$ and a small offset $\\delta$ and set\n$$\nq_2^{\\star} = -\\alpha \\sin \\theta, \\quad p_2^{\\star} = \\alpha \\cos \\theta,\n$$\nthen apply a shift\n$$\nq_2(0) = q_2^{\\star} - \\delta \\cos \\theta, \\quad p_2(0) = p_2^{\\star} - \\delta \\sin \\theta,\n$$\nso that $u(0) = -\\delta  0$ and $v(0)=\\alpha > 0$. Determine $p_1(0)$ from the energy constraint $H(q_1(0),q_2(0),p_1(0),p_2(0))=E$ by taking the positive root,\n$$\np_1(0) = \\sqrt{\\,2\\left[E - \\left(\\frac{1}{2}\\left(q_1(0)^2 + q_2(0)^2\\right) + q_1(0)^2 q_2(0) - \\frac{1}{3}q_2(0)^3\\right) - \\frac{1}{2}p_2(0)^2\\right]\\,}.\n$$\nEvolve the trajectory and detect the first $N$ crossings of the hypersurface $u=0$ with $v>0$ for times $t>0$ (exclude $t=0$). At each such crossing, collect the corresponding $(q_1,p_1)$ pair.\n\nAngle $\\theta$ must be specified in radians. All quantities are in the same dimensionless units as the Hamiltonian above. The required output for each test case is a list of the first $N$ recorded pairs $(q_1,p_1)$, where each number is rounded to six decimal places.\n\nUse the following test suite, which specifies $(E,\\theta,\\alpha,\\delta,T,N)$ for each case, where $T$ is the maximum integration time and $N$ is the number of crossings to return:\n- Case A (general angled section): $(0.118,\\ \\pi/6,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- Case B (boundary orientation $\\theta=0$): $(0.125,\\ 0,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- Case C (near the escape threshold $E \\approx 1/6$): $(0.166,\\ 1.2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n- Case D (boundary orientation $\\theta=\\pi/2$): $(0.10,\\ \\pi/2,\\ 0.05,\\ 10^{-6},\\ 200,\\ 5)$.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. Each test case result is itself a list of $N$ two-element lists $[q_1,p_1]$ with each float rounded to six decimal places. The exact format is\n$$\n\\big[\\, [ [q_{1,1},p_{1,1}], \\dots, [q_{1,N},p_{1,N}] ],\\ [ [q_{2,1},p_{2,1}], \\dots, [q_{2,N},p_{2,N}] ],\\ [ [q_{3,1},p_{3,1}], \\dots, [q_{3,N},p_{3,N}] ],\\ [ [q_{4,1},p_{4,1}], \\dots, [q_{4,N},p_{4,N}] ] \\,\\big],\n$$\nwith no spaces anywhere in the line. Angles are in radians, and all physical quantities are dimensionless. Round all reported numbers to six decimal places.", "solution": "The problem is valid. It presents a well-defined task in computational physics, specifically the analysis of the Hénon-Heiles system using Poincaré sections. The problem is scientifically grounded, self-contained, and all parameters and initial conditions are specified unambiguously.\n\nThe Hénon-Heiles system is described by the Hamiltonian:\n$$\nH(q_1, q_2, p_1, p_2) = \\frac{1}{2}(p_1^2 + p_2^2 + q_1^2 + q_2^2) + q_1^2 q_2 - \\frac{1}{3} q_2^3\n$$\nThe dynamics of the system are governed by Hamilton's equations, $\\dot{q}_i = \\partial H / \\partial p_i$ and $\\dot{p}_i = -\\partial H / \\partial q_i$. For the state vector $\\mathbf{y}(t) = [q_1(t), q_2(t), p_1(t), p_2(t)]^T$, these equations are:\n$$\n\\begin{aligned}\n\\dot{q}_1 = p_1 \\\\\n\\dot{q}_2 = p_2 \\\\\n\\dot{p}_1 = -q_1 - 2q_1 q_2 = -q_1(1 + 2q_2) \\\\\n\\dot{p}_2 = -q_2 - q_1^2 + q_2^2\n\\end{aligned}\n$$\nThis constitutes a system of four coupled, first-order ordinary differential equations (ODEs). The total energy $E = H(\\mathbf{y}(t))$ is a conserved quantity, a fact which can be used to monitor the numerical accuracy of the integration.\n\nThe Poincaré section is defined on a hypersurface in the phase space. In this problem, the section is defined in a rotated coordinate system in the $(q_2, p_2)$ subspace:\n$$\n\\begin{pmatrix} u \\\\ v \\end{pmatrix} = \\begin{pmatrix} \\cos \\theta  \\sin \\theta \\\\ -\\sin \\theta  \\cos \\theta \\end{pmatrix} \\begin{pmatrix} q_2 \\\\ p_2 \\end{pmatrix}\n$$\nThe section surface is given by the condition $u = q_2 \\cos \\theta + p_2 \\sin \\theta = 0$. Crossings are recorded only if they satisfy the additional condition $v = -q_2 \\sin \\theta + p_2 \\cos \\theta > 0$.\n\nThe solution methodology involves the numerical integration of the equations of motion coupled with an event detection mechanism to identify when the trajectory crosses the Poincaré section. The steps are as follows:\n\n1.  **Initialization**: For each test case, specified by the parameters $(E, \\theta, \\alpha, \\delta, T, N)$, the initial state vector $\\mathbf{y}(0) = [q_1(0), q_2(0), p_1(0), p_2(0)]^T$ is constructed.\n    -   $q_1(0) = 0$.\n    -   $q_2(0) = -\\alpha \\sin \\theta - \\delta \\cos \\theta$.\n    -   $p_2(0) = \\alpha \\cos \\theta - \\delta \\sin \\theta$.\n    -   $p_1(0)$ is determined by solving the energy conservation equation $H(\\mathbf{y}(0)) = E$ for the positive root:\n        $$\n        p_1(0) = \\sqrt{2E - p_2(0)^2 - q_2(0)^2 + \\frac{2}{3}q_2(0)^3}\n        $$\n    The initial state is constructed such that $u(0) = -\\delta  0$, which implies we are interested in crossings where the trajectory moves from the $u0$ region to the $u>0$ region.\n\n2.  **Numerical Integration**: The system of ODEs is integrated forward in time from $t=0$ to a maximum time $t=T$. A high-order adaptive step-size integrator is required for accuracy, as chaotic systems are highly sensitive to initial conditions and integration errors. The `scipy.integrate.solve_ivp` function with the `DOP853` method and strict error tolerances (e.g., relative tolerance $rtol=10^{-11}$ and absolute tolerance $atol=10^{-12}$) is suitable for this purpose.\n\n3.  **Event Detection**: The `solve_ivp` integrator's event detection capability is used to find the times $t_i > 0$ at which $u(t_i) = 0$. The event function is $g(t, \\mathbf{y}) = q_2(t) \\cos\\theta + p_2(t) \\sin\\theta$. We specify a positive crossing direction, meaning the event is triggered only when $g(t, \\mathbf{y})$ crosses zero from a negative to a positive value. This corresponds to the trajectory piercing the section plane with $\\dot{u}>0$.\n\n4.  **Data Collection**: For each event found at time $t_i$, the state of the system $\\mathbf{y}(t_i)$ is evaluated. The condition $v(t_i) > 0$ is then checked. If this condition is met, the pair $(q_1(t_i), p_1(t_i))$ is recorded. This process is repeated until $N$ such pairs are collected.\n\n5.  **Output Formatting**: The collected pairs for each test case are rounded to six decimal places and formatted into the specified string representation.\n\nThe implementation will consist of a function for the Hénon-Heiles equations of motion, a function or class to define the parameter-dependent event function $u(t)$, and a main loop to process each test case according to the steps described above.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves for the Poincaré section points of the Hénon-Heiles system for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Format: (E, theta, alpha, delta, T, N)\n    test_cases = [\n        (0.118, np.pi/6, 0.05, 1e-6, 200, 5),\n        (0.125, 0.0, 0.05, 1e-6, 200, 5),\n        (0.166, 1.2, 0.05, 1e-6, 200, 5),\n        (0.10, np.pi/2, 0.05, 1e-6, 200, 5),\n    ]\n\n    all_results_str = []\n\n    def henon_heiles_eom(t, y):\n        \"\"\"\n        Equations of motion for the Hénon-Heiles system.\n        y = [q1, q2, p1, p2]\n        \"\"\"\n        q1, q2, p1, p2 = y\n        dq1_dt = p1\n        dq2_dt = p2\n        dp1_dt = -q1 * (1 + 2 * q2)\n        dp2_dt = -q2 - q1**2 + q2**2\n        return [dq1_dt, dq2_dt, dp1_dt, dp2_dt]\n\n    for E, theta, alpha, delta, T, N in test_cases:\n        # Calculate initial conditions\n        sin_theta, cos_theta = np.sin(theta), np.cos(theta)\n        \n        q1_0 = 0.0\n        q2_0 = -alpha * sin_theta - delta * cos_theta\n        p2_0 = alpha * cos_theta - delta * sin_theta\n        \n        # Ensure argument of sqrt is non-negative\n        p1_0_sq_arg = 2 * E - p2_0**2 - q2_0**2 + (2/3) * q2_0**3\n        if p1_0_sq_arg  0:\n            # This should not happen with the given test cases\n            p1_0 = 0.0 \n        else:\n            p1_0 = np.sqrt(p1_0_sq_arg)\n\n        y0 = [q1_0, q2_0, p1_0, p2_0]\n\n        # Define event function for Poincare section\n        def poincare_section_event(t, y, theta):\n            q2, p2 = y[1], y[3]\n            return q2 * np.cos(theta) + p2 * np.sin(theta)\n        \n        poincare_section_event.terminal = False\n        poincare_section_event.direction = 1  # Detect crossing from negative to positive\n\n        # Integrate ODE\n        sol = solve_ivp(\n            fun=lambda t, y: henon_heiles_eom(t, y),\n            t_span=(0, T),\n            y0=y0,\n            method='DOP853',\n            events=lambda t, y: poincare_section_event(t, y, theta),\n            dense_output=True,\n            rtol=1e-11,\n            atol=1e-12,\n        )\n        \n        # Collect results\n        crossings = []\n        if sol.t_events[0].size  0:\n            for t_event in sol.t_events[0]:\n                if len(crossings) = N:\n                    break\n                y_event = sol.sol(t_event)\n                q1, q2, p1, p2 = y_event\n\n                # Check the v  0 condition\n                v = -q2 * sin_theta + p2 * cos_theta\n                if v  0:\n                    crossings.append([float(q1), float(p1)])\n\n        # Format the result for the current case\n        case_str = f\"[{','.join([f'[{p[0]:.6f},{p[1]:.6f}]' for p in crossings])}]\"\n        all_results_str.append(case_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n\n```", "id": "2427559"}, {"introduction": "A visualization is only as good as the tools used to create it, a crucial lesson in computational science. Building on the previous exercise, this problem explores how numerical artifacts can distort the very structures we seek to understand, using the chaotic Duffing oscillator as a case study. By comparing results from different integration schemes, you will learn to quantitatively assess the fidelity of your computational model, a critical skill for producing reliable and accurate scientific simulations [@problem_id:2427621].", "problem": "You will study how the choice of time-integration method affects the geometry of a Poincaré section for the forced Duffing oscillator. The Duffing oscillator is governed by the autonomous first-order system obtained from the second-order equation $$\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t),$$ rewritten as $$\\frac{dx}{dt} = v,\\quad \\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi),\\quad \\frac{d\\phi}{dt} = \\omega,$$ where $x$ is the displacement, $v$ is the velocity, and $\\phi$ is the drive phase. The Poincaré section with respect to the drive is the set of states sampled at times when $\\phi$ is an integer multiple of $2\\pi$. Your task is to implement and compare two numerical time integrators, the explicit Euler method and the classical fourth-order Runge–Kutta method, and quantify how their numerical errors distort the Poincaré section of a chaotic Duffing attractor.\n\nStart from the foundational definitions of initial value problems for ordinary differential equations, the concept of a Poincaré map as stroboscopic sampling at a fixed phase, and deterministic numerical integration for time stepping. Do not assume any special-purpose formulas other than the standard update rules for the explicit Euler and classical fourth-order Runge–Kutta methods applied to $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y},t)$.\n\nUse the following physically plausible and widely studied parameter set for chaos in the Duffing oscillator: $$\\alpha = -1.0,\\ \\beta = 1.0,\\ \\delta = 0.3,\\ \\gamma = 0.37,\\ \\omega = 1.2.$$ Use initial conditions $$x(0) = 0,\\ v(0) = 0,\\ \\phi(0) = 0.$$ Interpret $t$ in seconds, $\\phi$ in radians, and treat $x$ and $v$ as dimensionless. Construct the Poincaré section by detecting successive crossings of $\\phi = 2\\pi k$ with $k \\in \\mathbb{Z}_{\\ge 1}$ and use linear interpolation between time steps to sample the state at the exact crossing. Discard the first $200$ crossings as transient, then collect the next $300$ Poincaré points $\\{(x_k, v_k)\\}$.\n\nTo quantify the geometric difference between two Poincaré sections $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ and $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$, compute the symmetric average nearest-neighbor distance $$D(\\mathcal{A},\\mathcal{B}) = \\tfrac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\sqrt{(x_i - x'_j)^2 + (v_i - v'_j)^2} + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\sqrt{(x'_j - x_i)^2 + (v'_j - v_i)^2}\\right).$$\n\nImplement both the explicit Euler method and the classical fourth-order Runge–Kutta method for the autonomous system above and compute Poincaré sections for the following four test cases. In all cases, report $D(\\mathcal{A},\\mathcal{B})$ as a floating-point number rounded to $6$ decimal places. The time step $h$ is in seconds.\n\nTest suite:\n- Case $1$ (happy path): Compare explicit Euler versus classical fourth-order Runge–Kutta with $h = 0.02$.\n- Case $2$ (coarser step): Compare explicit Euler versus classical fourth-order Runge–Kutta with $h = 0.05$.\n- Case $3$ (method consistency control): Compare classical fourth-order Runge–Kutta with $h = 0.02$ against classical fourth-order Runge–Kutta with $h = 0.01$.\n- Case $4$ (Euler self-consistency): Compare explicit Euler with $h = 0.02$ against explicit Euler with $h = 0.01$.\n\nAngle units must be radians. The final output must be four floats, each equal to the $D(\\mathcal{A},\\mathcal{B})$ for the corresponding case, rounded to $6$ decimals. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4]\") with no additional text.\n\nEnsure scientific realism: use the precise phase-crossing construction for the Poincaré section with linear interpolation, deterministic stepping, and the stated parameter values, and perform all computations in double precision. The answers for each test case are floats without units because they are distances in the dimensionless $(x,v)$ plane. Angles must be in radians and time in seconds throughout.", "solution": "The problem presented requires a quantitative comparison of two numerical integration schemes—the explicit Euler method and the classical fourth-order Runge-Kutta method—by analyzing their effect on the computed Poincaré section of a forced Duffing oscillator. This analysis falls within the domain of computational dynamics and the study of numerical artifacts in simulations of chaotic systems. The problem is well-posed, scientifically grounded, and provides all necessary specifications for a rigorous solution.\n\nThe foundational physical system is the forced Duffing oscillator, a second-order non-linear ordinary differential equation (ODE) for displacement $x(t)$:\n$$\n\\frac{d^2 x}{dt^2} + \\delta \\frac{dx}{dt} + \\alpha x + \\beta x^3 = \\gamma \\cos(\\omega t)\n$$\nTo facilitate numerical integration, this equation is transformed into an autonomous system of three first-order ODEs by defining the state vector $\\mathbf{y}(t) = [x(t), v(t), \\phi(t)]^T$, where $v = dx/dt$ is the velocity and $\\phi = \\omega t$ is the phase of the external drive. The system is then given by $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$:\n$$\n\\frac{dx}{dt} = v\n$$\n$$\n\\frac{dv}{dt} = -\\delta v - \\alpha x - \\beta x^3 + \\gamma \\cos(\\phi)\n$$\n$$\n\\frac{d\\phi}{dt} = \\omega\n$$\nThe problem specifies the parameters for chaotic behavior: $\\alpha = -1.0$, $\\beta = 1.0$, $\\delta = 0.3$, $\\gamma = 0.37$, and $\\omega = 1.2$. The initial conditions are set to $\\mathbf{y}(0) = [0, 0, 0]^T$.\n\nNumerical integration methods are employed to approximate the solution trajectory $\\mathbf{y}(t)$ at discrete time steps. We consider a time step $h$. The state at time $t_{n+1} = t_n + h$ is approximated from the state at time $t_n$.\n\nFirst, the explicit Euler method is a first-order method defined by the update rule:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\cdot \\mathbf{f}(\\mathbf{y}_n)\n$$\nThis method is simple but has a local truncation error of order $O(h^2)$ and a global error of order $O(h)$, making it relatively inaccurate and potentially unstable for stiff or chaotic systems.\n\nSecond, the classical fourth-order Runge-Kutta method (RK4) provides a more accurate approximation. It is a fourth-order method with a global error of order $O(h^4)$. The update rule is given by:\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\nwhere the intermediate slopes are:\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n)\n$$\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1)\n$$\n$$\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2)\n$$\n$$\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h \\mathbf{k}_3)\n$$\n\nThe Poincaré section provides a method to visualize the dynamics of the system in a lower-dimensional space. For this periodically driven system, we use a stroboscopic map, sampling the state $(x, v)$ whenever the drive phase $\\phi$ crosses a multiple of $2\\pi$. Since $\\phi(0)=0$ and $\\dot{\\phi}=\\omega$ is a positive constant, we monitor the trajectory and record the state at times $t_k$ such that $\\phi(t_k) = 2\\pi k$ for integers $k \\ge 1$. A numerical time step from $\\mathbf{y}_n$ at $t_n$ to $\\mathbf{y}_{n+1}$ at $t_{n+1}$ may span such a crossing. If $\\phi_n  2\\pi k \\le \\phi_{n+1}$ for some integer $k$, a crossing has occurred. The state $(x^*, v^*)$ on the Poincaré section is found using linear interpolation. The interpolation factor $\\theta \\in [0, 1]$ is calculated from the phase:\n$$\\theta = \\frac{2\\pi k - \\phi_n}{\\phi_{n+1} - \\phi_n}$$\nThe interpolated state is then:\n$$x^* = (1 - \\theta)x_n + \\theta x_{n+1}$$\n$$v^* = (1 - \\theta)v_n + \\theta v_{n+1}$$\nThe first $200$ points are discarded to ensure the trajectory has settled onto the attractor, and the subsequent $300$ points are collected to form the Poincaré section.\n\nTo quantify the geometric difference between two Poincaré sections, $\\mathcal{A} = \\{(x_i, v_i)\\}_{i=1}^{N}$ and $\\mathcal{B} = \\{(x'_j, v'_j)\\}_{j=1}^{M}$ (where $N = M = 300$), we compute the specified symmetric average nearest-neighbor distance, $D(\\mathcal{A},\\mathcal{B})$:\n$$\nD(\\mathcal{A},\\mathcal{B}) = \\frac{1}{2}\\left(\\frac{1}{N}\\sum_{i=1}^{N} \\min_{1 \\le j \\le M} \\|\\mathbf{p}_i - \\mathbf{p}'_j\\|_2 + \\frac{1}{M}\\sum_{j=1}^{M} \\min_{1 \\le i \\le N} \\|\\mathbf{p}'_j - \\mathbf{p}_i\\|_2\\right)\n$$\nwhere $\\mathbf{p}_i = (x_i, v_i)$ and $\\mathbf{p}'_j = (x'_j, v'_j)$, and $\\|\\cdot\\|_2$ is the Euclidean distance. This metric averages the distance from each point in one set to its closest neighbor in the other set, and symmetrizes the result. It provides a robust measure of how well the two point clouds align.\n\nThe overall algorithm proceeds as follows: for each of the four test cases, we generate two Poincaré sections using the specified methods and time steps. For each section, we integrate the system from the initial condition, detect phase crossings, interpolate to find the $300$ attractor points after a $200$-point transient, and store these points. Then, we compute the distance $D(\\mathcal{A}, \\mathcal{B})$ between the two generated sets of points and report the value rounded to $6$ decimal places. This procedure systematically evaluates the impact of numerical method choice and step size on the geometric structure of the chaotic attractor.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial.distance import cdist\n\ndef solve():\n    \"\"\"\n    Computes Poincaré sections of the Duffing oscillator and compares them\n    using a symmetric average nearest-neighbor distance.\n    \"\"\"\n\n    def generate_poincare_section(method, h, params):\n        \"\"\"\n        Generates a Poincaré section for the Duffing oscillator using a specified\n        integration method and step size.\n\n        Args:\n            method (str): The integration method, 'euler' or 'rk4'.\n            h (float): The time step.\n            params (dict): Dictionary of oscillator parameters.\n\n        Returns:\n            numpy.ndarray: An array of shape (300, 2) containing the (x, v)\n                           coordinates of the Poincaré section points.\n        \"\"\"\n        alpha = params['alpha']\n        beta = params['beta']\n        delta = params['delta']\n        gamma = params['gamma']\n        omega = params['omega']\n\n        def f(y):\n            \"\"\"The ODE function dy/dt = f(y) for the Duffing system.\"\"\"\n            x, v, phi = y\n            dxdt = v\n            dvdt = -delta * v - alpha * x - beta * x**3 + gamma * np.cos(phi)\n            dphidt = omega\n            return np.array([dxdt, dvdt, dphidt], dtype=np.float64)\n\n        y = np.array([0.0, 0.0, 0.0], dtype=np.float64)  # Initial state [x, v, phi]\n\n        poincare_points = []\n        num_transient = 200\n        total_points = num_transient + 300\n        \n        two_pi = 2.0 * np.pi\n\n        while len(poincare_points)  total_points:\n            y_prev = y\n            \n            if method == 'euler':\n                y = y_prev + h * f(y_prev)\n            elif method == 'rk4':\n                k1 = f(y_prev)\n                k2 = f(y_prev + 0.5 * h * k1)\n                k3 = f(y_prev + 0.5 * h * k2)\n                k4 = f(y_prev + h * k3)\n                y = y_prev + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            \n            phi_prev = y_prev[2]\n            phi_curr = y[2]\n\n            crossings_prev_count = np.floor(phi_prev / two_pi)\n            crossings_curr_count = np.floor(phi_curr / two_pi)\n\n            if crossings_curr_count  crossings_prev_count:\n                for k in range(int(crossings_prev_count) + 1, int(crossings_curr_count) + 1):\n                    if len(poincare_points) = total_points:\n                        break\n                    \n                    phi_target = k * two_pi\n                    \n                    # Linear interpolation factor\n                    theta = (phi_target - phi_prev) / (phi_curr - phi_prev)\n                    \n                    # Interpolate x and v to the exact crossing time\n                    x_cross = y_prev[0] + theta * (y[0] - y_prev[0])\n                    v_cross = y_prev[1] + theta * (y[1] - y_prev[1])\n                    \n                    poincare_points.append([x_cross, v_cross])\n\n        return np.array(poincare_points[num_transient:], dtype=np.float64)\n\n    def compute_distance(set_A, set_B):\n        \"\"\"\n        Computes the symmetric average nearest-neighbor distance between two point sets.\n        \"\"\"\n        dist_matrix = cdist(set_A, set_B)\n        \n        nn_dist_A_to_B = np.min(dist_matrix, axis=1)\n        nn_dist_B_to_A = np.min(dist_matrix, axis=0)\n        \n        avg_A_to_B = np.mean(nn_dist_A_to_B)\n        avg_B_to_A = np.mean(nn_dist_B_to_A)\n        \n        return 0.5 * (avg_A_to_B + avg_B_to_A)\n\n    params = {\n        'alpha': -1.0, 'beta': 1.0, 'delta': 0.3,\n        'gamma': 0.37, 'omega': 1.2\n    }\n\n    test_cases = [\n        # Case 1: Euler h=0.02 vs RK4 h=0.02\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.02},\n        # Case 2: Euler h=0.05 vs RK4 h=0.05\n        {'method1': 'euler', 'h1': 0.05, 'method2': 'rk4', 'h2': 0.05},\n        # Case 3: RK4 h=0.02 vs RK4 h=0.01\n        {'method1': 'rk4', 'h1': 0.02, 'method2': 'rk4', 'h2': 0.01},\n        # Case 4: Euler h=0.02 vs Euler h=0.01\n        {'method1': 'euler', 'h1': 0.02, 'method2': 'euler', 'h2': 0.01}\n    ]\n\n    # Pre-compute all required sections to avoid redundant calculations\n    computations_to_run = set()\n    for case in test_cases:\n        computations_to_run.add((case['method1'], case['h1']))\n        computations_to_run.add((case['method2'], case['h2']))\n    \n    generated_sections = {\n        (method, h): generate_poincare_section(method, h, params)\n        for method, h in computations_to_run\n    }\n    \n    results = []\n    for case in test_cases:\n        set_A = generated_sections[(case['method1'], case['h1'])]\n        set_B = generated_sections[(case['method2'], case['h2'])]\n        \n        dist = compute_distance(set_A, set_B)\n        results.append(f\"{dist:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2427621"}]}