{"hands_on_practices": [{"introduction": "The logistic map at $r=4$ is a canonical example of a chaotic system, where long-term prediction seems impossible. This exercise reveals a surprising and elegant truth: a clever change of variable can untangle the complexity, transforming the chaotic dynamics into a simple, solvable evolution. By practicing this transformation [@problem_id:2409501], you will gain insight into how underlying mathematical structures can provide exact solutions even for seemingly intractable problems.", "problem": "Consider the logistic map defined by the recurrence\n$$x_{n+1} = 4 x_n (1 - x_n),$$\nfor integer $n \\ge 0$, with an initial condition $x_0 \\in (0,1)$. Introduce an angular variable $\\theta_n \\in [0,\\pi)$ for each $n$ such that\n$$x_n = \\sin^2(\\theta_n),$$\nwith the initial $\\theta_0 \\in [0,\\pi)$ chosen to satisfy $x_0 = \\sin^2(\\theta_0)$. Determine the exact evolution law for $\\theta_{n+1}$ in terms of $\\theta_n$, interpreting angles modulo $\\pi$ whenever necessary to keep them in $[0,\\pi)$. Then, express $x_N$ in closed form as a function of $\\theta_0$ and the nonnegative integer $N$. Give your final answer as a single closed-form analytic expression in terms of $\\theta_0$ and $N$.", "solution": "The problem statement has been validated and is deemed scientifically grounded, well-posed, objective, and self-contained. It presents a standard problem in the study of nonlinear dynamics, specifically the logistic map for the parameter value corresponding to fully developed chaos. A solution will be furnished.\n\nThe system is described by the logistic map recurrence relation:\n$$x_{n+1} = 4 x_n (1 - x_n)$$\nwith an initial condition $x_0 \\in (0,1)$ and for integer indices $n \\ge 0$. We are instructed to use the transformation $x_n = \\sin^2(\\theta_n)$, where $\\theta_n \\in [0, \\pi)$.\n\nFirst, we determine the evolution law for the angular variable $\\theta_n$. We substitute the transformation into the recurrence relation:\n$$x_{n+1} = 4 \\sin^2(\\theta_n) (1 - \\sin^2(\\theta_n))$$\nUsing the fundamental trigonometric identity $\\cos^2(\\alpha) + \\sin^2(\\alpha) = 1$, we replace $(1 - \\sin^2(\\theta_n))$ with $\\cos^2(\\theta_n)$:\n$$x_{n+1} = 4 \\sin^2(\\theta_n) \\cos^2(\\theta_n)$$\nThis expression can be rearranged as the square of a product:\n$$x_{n+1} = (2 \\sin(\\theta_n) \\cos(\\theta_n))^2$$\nWe recognize the term in the parenthesis as the sine double-angle identity, $\\sin(2\\alpha) = 2 \\sin(\\alpha) \\cos(\\alpha)$. Applying this identity yields:\n$$x_{n+1} = (\\sin(2\\theta_n))^2 = \\sin^2(2\\theta_n)$$\nBy the definition of the transformation, we also have $x_{n+1} = \\sin^2(\\theta_{n+1})$. Equating the two expressions for $x_{n+1}$, we get:\n$$\\sin^2(\\theta_{n+1}) = \\sin^2(2\\theta_n)$$\nSince $\\theta_{n+1}$ must lie in the interval $[0, \\pi)$, this equation implies that $\\theta_{n+1}$ is related to $2\\theta_n$ by a shift of an integer multiple of $\\pi$. Specifically, the evolution law for $\\theta_n$ is the dyadic transformation (or Bernoulli shift map) on the circle $\\mathbb{R}/\\pi\\mathbb{Z}$:\n$$\\theta_{n+1} = 2\\theta_n \\pmod{\\pi}$$\nThis means that $\\theta_{n+1}$ is the remainder of $2\\theta_n$ after division by $\\pi$, such that the result is in $[0,\\pi)$. This is the exact evolution law for $\\theta_{n+1}$ in terms of $\\theta_n$.\n\nNext, we seek a closed-form expression for $x_N$. To achieve this, we first solve the recurrence for $\\theta_n$. The relation $\\theta_{n+1} \\equiv 2\\theta_n \\pmod{\\pi}$ is a simple geometric progression modulo $\\pi$. We can solve it by iteration:\n$$\\theta_1 \\equiv 2\\theta_0 \\pmod{\\pi}$$\n$$\\theta_2 \\equiv 2\\theta_1 \\equiv 2(2\\theta_0) \\equiv 2^2\\theta_0 \\pmod{\\pi}$$\n$$\\theta_3 \\equiv 2\\theta_2 \\equiv 2(2^2\\theta_0) \\equiv 2^3\\theta_0 \\pmod{\\pi}$$\nBy induction, it is trivial to see that the general term $\\theta_N$ is given by:\n$$\\theta_N \\equiv 2^N \\theta_0 \\pmod{\\pi}$$\nThis congruence implies that $\\theta_N$ can be written as $\\theta_N = 2^N\\theta_0 - k\\pi$ for some integer $k$ chosen to map the result into the interval $[0, \\pi)$.\n\nFinally, we express $x_N$ in terms of $\\theta_0$ and $N$. We substitute our result for $\\theta_N$ back into the transformation $x_N = \\sin^2(\\theta_N)$:\n$$x_N = \\sin^2(2^N \\theta_0 - k\\pi)$$\nThe sine function has the property that $\\sin(\\alpha - k\\pi) = (-1)^k \\sin(\\alpha)$. Consequently, the square of the sine function is periodic with period $\\pi$:\n$$\\sin^2(\\alpha - k\\pi) = ((-1)^k \\sin(\\alpha))^2 = (-1)^{2k} \\sin^2(\\alpha) = \\sin^2(\\alpha)$$\nApplying this property to our expression for $x_N$, the term $-k\\pi$ has no effect on the value.\n$$x_N = \\sin^2(2^N \\theta_0)$$\nThis is the required closed-form analytic expression for $x_N$ as a function of the initial angle $\\theta_0$ and the number of iterations $N$.", "answer": "$$\\boxed{\\sin^2(2^N \\theta_0)}$$", "id": "2409501"}, {"introduction": "The journey from simple periodic behavior to chaos is marked by a series of critical events in the logistic map's parameter space. This practice guides you in developing a numerical tool to locate some of the most important landmarks: the supercycle parameters [@problem_id:2409482]. By implementing a root-finding algorithm, you will learn how to systematically hunt for parameter values where the system's dynamics exhibit special, highly stable periodic behaviors, effectively mapping the skeleton of the bifurcation diagram.", "problem": "You are given the one-parameter logistic family defined by the iteration of the map $f_{r}(x) = r\\,x\\,(1-x)$ on the unit interval $[0,1]$, where $r \\in [0,4]$. The critical point is $x_{\\mathrm{c}} = 1/2$. A parameter value $r$ is called a supercycle (also called superstable) of primitive period $p \\in \\mathbb{N}$ if the critical point is periodic with exact minimal period $p$, that is, the $p$-fold composition $f_{r}^{(p)}$ satisfies $f_{r}^{(p)}(1/2) = 1/2$ while $f_{r}^{(q)}(1/2) \\neq 1/2$ for every proper divisor $q$ of $p$. Equivalently, a supercycle of period $p$ is a solution $r \\in [0,4]$ of the scalar equation $g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2 = 0$ such that no $g_{q}(r)$ vanishes for any proper divisor $q$ of $p$. The function $g_{p}$ is continuous in $r$ because it is obtained by finitely many compositions of polynomials in $r$ and $x$ with initial $x=1/2$.\n\nYour task is to develop an algorithm that, for each prescribed integer period $p$, locates with high precision the smallest parameter value $r \\in (0,4]$ such that $x=1/2$ is periodic of primitive period $p$. Your algorithm must be justified from first principles by using only foundational facts: continuity of polynomial maps, properties of function iteration, and the Intermediate Value Theorem (IVT). You must not use closed-form expressions for any special parameter values.\n\nAlgorithmic requirements:\n1) Define the logistic map $f_{r}(x) = r\\,x\\,(1-x)$ and its $p$-fold iterate $f_{r}^{(p)}$ at $x=1/2$ by explicit iteration. Define $g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2$.\n2) For each period $p$, search for sign changes of $g_{p}(r)$ over a dense grid on $[0,4]$ to obtain brackets $\\,[a,b]\\,$ for which $g_{p}(a)\\,g_{p}(b) \\le 0$. Use the Intermediate Value Theorem to justify that each bracket contains at least one root. Then refine each bracket to a root with a robust bracketing method such as bisection or Brentâ€™s method, ensuring numerical tolerances that achieve absolute accuracy better than $10^{-10}$ in $r$.\n3) Filter the roots so that only those with primitive period exactly $p$ remain. Concretely, for each candidate root $r^{\\star}$ of $g_{p}$, verify that $|g_{q}(r^{\\star})|$ is larger than a small threshold for every proper divisor $q$ of $p$. Equivalently, numerically confirm that no earlier return $f_{r^{\\star}}^{(q)}(1/2) = 1/2$ occurs for $q$ a proper divisor of $p$. Among the remaining candidates, select the smallest $r$.\n4) All numerical comparisons to zero should use a clearly stated tolerance. Use absolute tolerances for function values and a combined absolute and relative tolerance for root refinement. Your search grid must be sufficiently fine to capture narrow windows of parameter values.\n\nTest suite:\n- Periods to analyze: $p \\in \\{1,2,3,4,5\\}$.\n- Domain for parameter search: $r \\in [0,4]$.\n- Tolerances: target an absolute error in $r$ smaller than $10^{-10}$ for the returned values; when testing primitivity, declare $f_{r}^{(q)}(1/2) = 1/2$ only if $|g_{q}(r)| \\le 10^{-12}$.\n\nAnswer specification:\n- For each $p$ in the order $p=1$, $p=2$, $p=3$, $p=4$, $p=5$, compute the smallest $r \\in (0,4]$ such that $x=1/2$ is periodic of primitive period $p$.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, with each value rounded to $10$ decimal places, for example, $[r_{1},r_{2},r_{3},r_{4},r_{5}]$, where each $r_{k}$ is a decimal numeral rounded to $10$ decimal places.", "solution": "The problem statement is a valid, well-posed computational physics task. It is scientifically grounded in the established theory of discrete dynamical systems, specifically the study of the logistic map. The objective is clearly defined, all necessary parameters and constraints are provided, and the problem is free of ambiguity, contradiction, or factual error. We may therefore proceed with a solution.\n\nThe problem requires the computation of the smallest supercycle parameter $r_{p} \\in (0,4]$ for primitive periods $p \\in \\{1,2,3,4,5\\}$. A parameter value $r$ corresponds to a supercycle of primitive period $p$ if the critical point of the logistic map, $x_{\\mathrm{c}} = 1/2$, is a periodic point of minimal period $p$.\n\nThe logistic map is defined as:\n$$f_{r}(x) = r\\,x\\,(1-x)$$\nwhere the state variable $x$ is on the unit interval $[0,1]$ and the bifurcation parameter $r$ is in the range $[0,4]$.\n\nThe condition for the critical point $x_{\\mathrm{c}} = 1/2$ to be periodic with period $p$ is that its $p$-th iterate returns to itself:\n$$f_{r}^{(p)}(1/2) = 1/2$$\nwhere $f_{r}^{(p)}$ denotes the $p$-fold composition of the map $f_{r}$ with itself. This can be expressed as finding the roots of the function $g_{p}(r)$:\n$$g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2 = 0$$\nThe function $g_{p}(r)$ is constructed by iterating the map, starting with $x_{0} = 1/2$:\n$x_{1} = f_{r}(x_{0}) = f_{r}(1/2) = r/4$\n$x_{2} = f_{r}(x_{1}) = f_{r}(r/4) = r(r/4)(1 - r/4)$\n$...$\n$x_{p} = f_{r}^{(p)}(1/2)$\nThus, $g_{p}(r) = x_{p} - 1/2$. Since $f_{r}(x)$ is a polynomial in both $r$ and $x$, and the iteration starts with a constant, the resulting function $g_{p}(r)$ is a polynomial in $r$. As a polynomial, $g_{p}(r)$ is continuous for all $r \\in \\mathbb{R}$. This fundamental property justifies the use of root-finding algorithms based on the Intermediate Value Theorem (IVT).\n\nA root $r^{\\star}$ of $g_{p}(r) = 0$ corresponds to a supercycle of *primitive* period $p$ only if the orbit of $x_{\\mathrm{c}} = 1/2$ does not return to $1/2$ at any earlier iteration $q$ which is a proper divisor of $p$. That is, for a given root $r^{\\star}$:\n$$f_{r^{\\star}}^{(q)}(1/2) \\neq 1/2 \\quad \\text{for all } q \\in \\{1, 2, ..., p-1\\} \\text{ such that } p \\pmod q = 0$$\nThis is equivalent to the condition $g_{q}(r^{\\star}) \\neq 0$ for all proper divisors $q$ of $p$.\n\nThe algorithmic solution is designed in three stages, as specified.\n\n**1. Bracketing of Roots**\nTo locate the potential supercycle parameters, we first identify intervals (brackets) that are guaranteed to contain a root of $g_{p}(r) = 0$. This is achieved by performing a systematic search over the parameter domain $r \\in [0,4]$. We define a dense grid of points $r_{i}$ spanning this interval with a fine step size, for instance, $\\Delta r = 10^{-4}$. For each period $p$ and for each pair of adjacent grid points $(r_{i}, r_{i+1})$, we evaluate the product $g_{p}(r_{i}) \\cdot g_{p}(r_{i+1})$. If this product is less than or equal to $0$, it signifies a sign change (or a root at one of the endpoints). By the IVT, the continuity of $g_{p}(r)$ guarantees the existence of at least one root $r^{\\star}$ in the interval $[r_{i}, r_{i+1}]$. All such brackets are collected for further processing.\n\n**2. Root Refinement**\nEach bracket $[a,b]$ obtained in the first stage is subjected to a high-precision root-finding algorithm. As suggested, we employ Brent's method, a robust and efficient bracketing algorithm that combines bisection, the secant method, and inverse quadratic interpolation. This method is guaranteed to converge provided that $g_{p}(a)$ and $g_{p}(b)$ have opposite signs. We configure the algorithm to refine each root $r^{\\star}$ until the width of the enclosing interval is less than a specified tolerance of $10^{-10}$, thereby ensuring the required accuracy for the parameter value. This process yields a set of candidate roots for each period $p$.\n\n**3. Primitivity Filtering and Final Selection**\nThe set of candidate roots found for $g_{p}(r) = 0$ includes all parameters for which $x_{\\mathrm{c}}=1/2$ has a period that divides $p$. To isolate the parameters corresponding to a *primitive* period $p$, we must filter out those for which $x_{\\mathrm{c}}=1/2$ has a shorter period $q$ (where $q$ is a proper divisor of $p$). For each candidate root $r^{\\star}$, we perform the following check:\nFor every proper divisor $q$ of $p$, we compute $g_{q}(r^{\\star})$. If $|g_{q}(r^{\\star})|$ is greater than the specified numerical tolerance of $10^{-12}$ for *all* proper divisors $q$, the root $r^{\\star}$ is confirmed to correspond to a primitive period-$p$ supercycle. Otherwise, it is discarded.\n\nAfter filtering, we are left with a set of parameters corresponding to primitive period-$p$ supercycles. The problem requires the smallest such parameter in the domain $(0,4]$. We therefore find the minimum value from this set of validated roots. This entire procedure is repeated for each specified period $p \\in \\{1,2,3,4,5\\}$ to yield the final list of results. This method is systematic and grounded in fundamental numerical principles, ensuring a correct and verifiable solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the smallest supercycle parameter r for primitive periods p from 1 to 5.\n    A supercycle of primitive period p occurs when the critical point x_c = 1/2 is\n    periodic with exact minimal period p.\n    \"\"\"\n    \n    # Define the periods to analyze as per the problem statement.\n    test_cases = [1, 2, 3, 4, 5]\n    \n    # Define parameters for the numerical procedure.\n    r_min, r_max = 0.0, 4.0\n    grid_points = 40001 # Grid step of 1e-4\n    root_tolerance_r = 1e-11 # Target error < 1e-10\n    primitivity_tolerance_g = 1e-12\n\n    results = []\n    \n    def get_g_p(p):\n        \"\"\"\n        Returns a function g_p(r) = f_r^(p)(1/2) - 1/2.\n        This uses a closure to capture the period p.\n        \"\"\"\n        def g(r_val):\n            \"\"\"Calculates the p-th iterate of the logistic map from x=0.5 and subtracts 0.5.\"\"\"\n            x = 0.5\n            # Use high-precision floats for iteration to minimize round-off error.\n            r_val_f = float(r_val)\n            x_f = float(x)\n            for _ in range(p):\n                x_f = r_val_f * x_f * (1.0 - x_f)\n            return x_f - 0.5\n        return g\n\n    def get_proper_divisors(n):\n        \"\"\"\n        Finds all proper divisors of an integer n.\n        For the small p in this problem, a simple loop is sufficient.\n        \"\"\"\n        if n <= 1:\n            return []\n        divisors = {1}\n        for i in range(2, int(np.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(list(divisors))\n\n    # Main loop over each period p\n    for p in test_cases:\n        g_p_func = get_g_p(p)\n        proper_divisors = get_proper_divisors(p)\n        \n        primitive_roots = []\n        \n        # Stage 1: Search for brackets using a dense grid\n        r_grid = np.linspace(r_min, r_max, grid_points)\n        g_values = np.array([g_p_func(r) for r in r_grid])\n\n        for i in range(len(r_grid) - 1):\n            r_a, r_b = r_grid[i], r_grid[i+1]\n            g_a, g_b = g_values[i], g_values[i+1]\n\n            # Check for sign change (bracket found)\n            if g_a * g_b <= 0:\n                # Stage 2: Refine the root within the bracket\n                try:\n                    # Brent's method requires a strict sign change.\n                    # If an endpoint is a root, g_a*g_b = 0.\n                    if g_a == 0:\n                        r_star = r_a\n                    elif g_b == 0:\n                        r_star = r_b\n                    else:\n                        r_star = brentq(g_p_func, r_a, r_b, xtol=root_tolerance_r, rtol=root_tolerance_r)\n                except ValueError:\n                    # This might happen if g_a and g_b have the same sign despite g_a*g_b<=0 (due to rounding)\n                    # or if brentq otherwise fails. It's safe to skip.\n                    continue\n\n                # Stage 3: Filter for primitivity\n                is_primitive = True\n                if proper_divisors:\n                    for q in proper_divisors:\n                        g_q_func = get_g_p(q)\n                        if abs(g_q_func(r_star)) <= primitivity_tolerance_g:\n                            is_primitive = False\n                            break\n                \n                if is_primitive:\n                    # Check for r > 0, as problem asks for r in (0, 4]\n                    if r_star > 1e-12: # Check against small tolerance to exclude r=0\n                        primitive_roots.append(r_star)\n\n        # Final Selection: Find the smallest primitive root\n        if not primitive_roots:\n            # This case should not be reached for the given problem periods.\n            # It would indicate no primitive supercycle was found.\n            # We can append a placeholder, but it implies an issue with the search.\n            # raise RuntimeError(f\"No primitive root found for p={p}\")\n            results.append(np.nan)\n        else:\n            # Find the minimum of the unique roots found\n            unique_roots = sorted(list(set(primitive_roots)))\n            results.append(min(unique_roots))\n\n    # Final print statement in the exact required format.\n    # Round to 10 decimal places as requested.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2409482"}, {"introduction": "While the mathematical theory of chaos is built upon the continuum of real numbers, our computational tools operate with finite precision. This fundamental gap leads to profound differences between the ideal system and its simulation, a crucial concept this exercise explores [@problem_id:2409551]. You will first prove that true aperiodic chaos cannot exist on a finite grid and then implement an algorithm to investigate the properties of the resulting pseudo-random periodic cycles that emerge in computer models of chaotic systems.", "problem": "Consider the logistic map defined by the recurrence\n$$ x_{n+1} = r\\,x_n\\,(1 - x_n), $$\nwith control parameter fixed at $r = 4$ and initial condition $x_0 \\in [0,1]$. To model finite precision arithmetic in a universal and language-agnostic way, fix a precision parameter $B \\in \\mathbb{N}$ and define $N = 2^B$. The admissible state space is the uniform grid\n$$ \\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}. $$\nDefine the quantizer $Q_B:[0,1]\\to \\mathcal{G}_B$ by\n$$ Q_B(y) = \\frac{\\mathrm{round}(N\\,y)}{N}, $$\nwhere $\\mathrm{round}(\\cdot)$ denotes rounding to the nearest integer with ties broken toward the even integer. The finite-precision logistic map $F_B:\\mathcal{G}_B \\to \\mathcal{G}_B$ is\n$$ F_B(x) = Q_B\\!\\left(4\\,x\\,(1-x)\\right). $$\nLet the trajectory be $x_{n+1} = F_B(x_n)$ with $x_0 \\in \\mathcal{G}_B$. Define the eventual period (also called the cycle length) of the trajectory to be the length $ \\lambda \\in \\mathbb{N} $ of the periodic part after any finite transient.\n\nTasks:\n1) Using only first principles, justify that for every fixed $B \\in \\mathbb{N}$ and every initial condition $x_0 \\in \\mathcal{G}_B$, the trajectory under $F_B$ is eventually periodic, meaning it has a finite transient length and then repeats with some finite period $\\lambda$.\n\n2) For the following test suite, compute the average eventual period by averaging the eventual period $\\lambda$ over $S_B$ initial conditions of the form $x_0 = k/N$ with $k \\in \\{1,2,\\dots,S_B\\}$:\n- Case A: $B = 8$, $S_B = 200$.\n- Case B: $B = 12$, $S_B = 200$.\n- Case C: $B = 16$, $S_B = 200$.\nReport each average as a real number rounded to exactly $3$ decimal places.\n\n3) Edge cases (single-seed eventual period):\n- Case D: $B = 8$, $x_0 = 0$.\n- Case E: $B = 8$, $x_0 = \\frac{1}{2}$ (i.e., $k = N/2$).\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A, Case B, Case C, Case D, Case E]. For Cases Aâ€“C, output the averages rounded to exactly $3$ decimal places. For Cases Dâ€“E, output the eventual period as integers. For example, an output should look like\n\"[10.123,40.321,160.654,1,1]\".\nNo other text should be printed.", "solution": "The validity of the problem statement is first subjected to rigorous examination.\n\n### Problem Validation\n\n**Step 1: Extract Givens**\n- **Logistic Map:** $x_{n+1} = r\\,x_n\\,(1 - x_n)$\n- **Parameter:** $r = 4$\n- **Precision Parameter:** $B \\in \\mathbb{N}$\n- **Grid Size:** $N = 2^B$\n- **State Space:** $\\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}$\n- **Quantizer:** $Q_B(y) = \\frac{\\mathrm{round}(N\\,y)}{N}$, with ties broken toward the even integer.\n- **Finite-Precision Map:** $F_B(x) = Q_B\\!\\left(4\\,x\\,(1-x)\\right)$\n- **Trajectory:** $x_{n+1} = F_B(x_n)$ with $x_0 \\in \\mathcal{G}_B$.\n- **Eventual Period ($\\lambda$):** The length of the periodic part of the trajectory.\n- **Task 1:** Justify that all trajectories for any $B$ and $x_0 \\in \\mathcal{G}_B$ are eventually periodic.\n- **Task 2:** Compute the average eventual period for:\n    - Case A: $B = 8$, average over $x_0 = k/N$ for $k \\in \\{1, \\dots, 200\\}$.\n    - Case B: $B = 12$, average over $x_0 = k/N$ for $k \\in \\{1, \\dots, 200\\}$.\n    - Case C: $B = 16$, average over $x_0 = k/N$ for $k \\in \\{1, \\dots, 200\\}$.\n- **Task 3:** Compute the eventual period for:\n    - Case D: $B = 8, x_0 = 0$.\n    - Case E: $B = 8, x_0 = \\frac{1}{2}$.\n- **Output Format:** Comma-separated list `[A, B, C, D, E]`, with A-C rounded to $3$ decimal places.\n\n**Step 2: Validate Using Extracted Givens**\nThe problem is scientifically grounded, investigating the effects of finite precision on a well-known chaotic system, the logistic map. This is a standard topic in computational physics and nonlinear dynamics. All terms are mathematically defined with precision. The map $F_B$ is a deterministic function on a finite state space, which is a well-posed structure. The tasks are specific, objective, and computationally feasible. The problem does not violate any principles of scientific soundness or logical consistency. It is complete and unambiguous.\n\n**Step 3: Verdict and Action**\nThe problem is deemed **valid**. We proceed to the solution.\n\n---\n\n### Solution\n\nThe problem comprises two tasks: a theoretical justification and a set of numerical computations.\n\n**Task 1: Justification of Eventual Periodicity**\n\nThe justification is a direct consequence of the finiteness of the state space $\\mathcal{G}_B$.\nFor a fixed precision parameter $B \\in \\mathbb{N}$, the grid size is $N = 2^B$. The state space is defined as $\\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}$. The number of distinct states in this set, its cardinality, is $|\\mathcal{G}_B| = N+1 = 2^B+1$. For any natural number $B$, this is a finite quantity.\n\nThe function $F_B$ is constructed to map the state space $\\mathcal{G}_B$ to itself, that is, $F_B: \\mathcal{G}_B \\to \\mathcal{G}_B$. For any initial state $x_0 \\in \\mathcal{G}_B$, the trajectory is an infinite sequence of states $x_0, x_1, x_2, \\dots$ where each $x_n = F_B(x_{n-1}) \\in \\mathcal{G}_B$.\n\nWe have an infinite sequence of states being drawn from a finite set of possibilities. By the pigeonhole principle, at least one state must be visited more than once. Let $x_j$ be the first state in the sequence that is a repetition of a previous state, say $x_i$, with $i < j$. Let this pair of indices $(i, j)$ be such that $i$ is minimized.\n\nThe sequence of states is therefore $x_0, x_1, \\dots, x_{i-1}, \\left(x_i, x_{i+1}, \\dots, x_{j-1}\\right), \\dots$.\nThe segment $x_0, \\dots, x_{i-1}$ is the transient part of the trajectory, having a finite length of $i$.\nThe segment $x_i, \\dots, x_{j-1}$ constitutes a cycle. Since the map $F_B$ is deterministic, the state $x_j=x_i$ will necessarily be followed by $x_{j+1} = F_B(x_j) = F_B(x_i) = x_{i+1}$, and the subsequent states will repeat in the same order. This establishes the periodic nature of the sequence after the transient part. The length of this cycle, which is the eventual period, is $\\lambda = j-i$.\n\nSince the existence of such indices $i$ and $j$ is guaranteed for any trajectory on a finite state space, every trajectory under $F_B$ is eventually periodic. This completes the justification.\n\n**Tasks 2 & 3: Computational Algorithm**\n\nTo compute the eventual period $\\lambda$, we must detect the cycle in the trajectory generated from a given initial condition. A robust and efficient method for this is Floyd's cycle-finding algorithm, also known as the \"tortoise and hare\" algorithm.\n\nTo ensure computational accuracy and avoid floating-point representation errors during the simulation, we reformulate the dynamics on the set of integers $\\{0, 1, \\dots, N\\}$. Each state $x_n \\in \\mathcal{G}_B$ is uniquely represented by an integer $k_n$ such that $x_n = k_n / N$. The map $F_B$ on fractions induces a corresponding integer map $f_B(k_n) = k_{n+1}$.\nStarting from $x_{n+1} = F_B(x_n)$, we substitute $x_n = k_n/N$ and $x_{n+1} = k_{n+1}/N$:\n$$\n\\frac{k_{n+1}}{N} = Q_B\\left(4 \\frac{k_n}{N} \\left(1 - \\frac{k_n}{N}\\right)\\right) = \\frac{\\mathrm{round}\\left(N \\cdot 4 \\frac{k_n}{N} \\frac{N-k_n}{N}\\right)}{N}\n$$\nThis gives the integer-based recurrence relation:\n$$\nk_{n+1} = f_B(k_n) = \\mathrm{round}\\left(\\frac{4 k_n (N-k_n)}{N}\\right)\n$$\nThe problem specifies that $\\mathrm{round}(\\cdot)$ breaks ties by choosing the nearest even integer. The `numpy.round` function conforms to this standard.\n\nThe application of Floyd's algorithm to the sequence $k_0, k_1, k_2, \\dots$ generated by $k_{n+1} = f_B(k_n)$ proceeds in three standard phases:\n1.  **Collision Detection:** A \"tortoise\" pointer, advanced one step at a time, and a \"hare\" pointer, advanced two steps at a time, are initialized. They are guaranteed to eventually become equal at a state within the cycle.\n2.  **Cycle Start Identification:** One pointer is reset to the initial state $k_0$, while the other remains at the collision point. Both are then advanced one step at a time. Their next meeting point is the first state of the cycle, $k_\\mu$. The number of steps, $\\mu$, is the transient length.\n3.  **Period Calculation:** A pointer is advanced one step at a time starting from $k_\\mu$ until it returns to $k_\\mu$. The number of steps required is the cycle length, $\\lambda$.\n\nThis algorithm is implemented to solve for the test cases. For Cases A-C, the average of $\\lambda$ over the specified range of initial conditions is calculated. For Cases D-E, $\\lambda$ for a single initial condition is determined. The results are formatted as required.", "answer": "```python\nimport numpy as np\n\ndef find_eventual_period(B: int, k0: int) -> int:\n    \"\"\"\n    Computes the eventual period of the finite-precision logistic map trajectory.\n\n    The algorithm uses Floyd's cycle-finding algorithm (tortoise and hare)\n    on an integer representation of the state space to avoid floating-point issues.\n\n    Args:\n        B: The precision parameter, defining N = 2**B.\n        k0: The initial state represented as an integer k, where x_0 = k/N.\n\n    Returns:\n        The length of the eventual periodic cycle (lambda).\n    \"\"\"\n    N = 2**B\n\n    # The finite-precision map on the integer state space {0, 1, ..., N}.\n    # The rounding rule \"ties to nearest even\" is correctly implemented by np.round().\n    def f(k: int) -> int:\n        # Use floating point for the division, which is safe as the state 'k' is\n        # always an integer, ensuring exact comparisons.\n        val = 4.0 * k * (N - k) / N\n        return int(np.round(val))\n\n    # Floyd's Algorithm\n    # Phase 1: Find a point in the cycle.\n    # The tortoise moves one step at a time, the hare moves two.\n    try:\n        tortoise = f(k0)\n        hare = f(f(k0))\n    except (OverflowError, ValueError):\n        # In rare cases with very large B, intermediate products might overflow standard Python integers\n        # before the division. For the given constraints, this is not an issue.\n        # This is a safeguard for general application.\n        return -1 \n\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n\n    # Phase 2: Find the start of the cycle.\n    # The number of steps 'mu' is the length of the transient part.\n    mu = 0\n    tortoise = k0\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n\n    # Phase 3: Find the length of the cycle (the eventual period, lambda).\n    # Start from the first element of the cycle and count steps until return.\n    lam = 1\n    hare = f(tortoise)\n    while tortoise != hare:\n        hare = f(hare)\n        lam += 1\n\n    return lam\n\ndef compute_average_period(B: int, S_B: int) -> float:\n    \"\"\"\n    Computes the average eventual period over a range of initial conditions.\n\n    Args:\n        B: The precision parameter.\n        S_B: The number of initial conditions to test (k from 1 to S_B).\n\n    Returns:\n        The average period.\n    \"\"\"\n    periods = []\n    for k in range(1, S_B + 1):\n        period = find_eventual_period(B, k)\n        periods.append(period)\n    \n    return np.mean(periods)\n\ndef solve():\n    \"\"\"\n    Solves the given problem by computing results for all five cases\n    and printing them in the specified format.\n    \"\"\"\n    # Case A: B = 8, S_B = 200\n    avg_A = compute_average_period(B=8, S_B=200)\n\n    # Case B: B = 12, S_B = 200\n    avg_B = compute_average_period(B=12, S_B=200)\n\n    # Case C: B = 16, S_B = 200\n    avg_C = compute_average_period(B=16, S_B=200)\n\n    # Case D: B = 8, x_0 = 0 (k=0)\n    period_D = find_eventual_period(B=8, k0=0)\n\n    # Case E: B = 8, x_0 = 1/2 (k = N/2)\n    N_E = 2**8\n    k0_E = N_E // 2\n    period_E = find_eventual_period(B=8, k0=k0_E)\n\n    # Construct the final output string as per requirements.\n    results = [\n        f\"{avg_A:.3f}\",\n        f\"{avg_B:.3f}\",\n        f\"{avg_C:.3f}\",\n        str(period_D),\n        str(period_E)\n    ]\n    \n    # Print the single-line output.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2409551"}]}