{"hands_on_practices": [{"introduction": "A key challenge in modern molecular dynamics is scaling simulations to massive parallel computers. This often involves decomposing the system into spatial domains, but how does this affect global thermostats like Nosé–Hoover that rely on system-wide properties? This exercise [@problem_id:2446283] provides a crucial insight by tasking you to calculate and contrast the correct global thermostat rate with a naive, and incorrect, local implementation, thereby highlighting the necessity of global communication in parallel simulations.", "problem": "You are to write a complete, runnable program that evaluates, for several specified cases, the consistency of a global Nosé–Hoover thermostat under spatial domain decomposition. Consider a one-dimensional system of particles with masses $\\{m_j\\}$ and velocities $\\{v_j\\}$, coupled to a single global Nosé–Hoover thermostat variable $\\zeta$ with thermostat mass parameter $Q$. The system dimensionality is one, so the number of degrees of freedom (DOF) is $g = N$, where $N$ is the number of particles. The instantaneous total kinetic energy is\n$$\nK = \\sum_{j=1}^{N} \\frac{1}{2} m_j v_j^2 \\, .\n$$\nThe global Nosé–Hoover thermostat obeys\n$$\n\\dot{\\zeta} = \\frac{2 K - g \\, k_{\\mathrm{B}} \\, T_0}{Q} \\, ,\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant and $T_0$ is the target temperature. Use $k_{\\mathrm{B}} = 1.380649\\times 10^{-23}\\,\\mathrm{J/K}$ exactly.\n\nIn a spatial domain decomposition, the $N$ particles are partitioned into $M$ disjoint subdomains with index sets $\\{\\mathcal{D}_i\\}_{i=1}^{M}$, where each $\\mathcal{D}_i$ is a set of particle indices. Define the local kinetic energy in subdomain $i$ as\n$$\nK_i = \\sum_{j \\in \\mathcal{D}_i} \\frac{1}{2} m_j v_j^2 \\, ,\n$$\nand the local DOF as $g_i = |\\mathcal{D}_i|$. An inconsistent local implementation that ignores global coupling would compute a per-subdomain thermostat rate as\n$$\n\\dot{\\zeta}_i^{\\mathrm{local}} = \\frac{2 K_i - g_i \\, k_{\\mathrm{B}} \\, T_0}{Q} \\, .\n$$\nFor each test case, compute the following two quantities:\n- The correct global thermostat rate $\\dot{\\zeta}$ in $\\mathrm{s}^{-2}$ from the definition above.\n- The maximum absolute deviation\n$$\n\\Delta_{\\max} = \\max_{1 \\le i \\le M} \\left| \\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta} \\right| \\, ,\n$$\nexpressed in $\\mathrm{s}^{-2}$, which quantifies the inconsistency introduced by using local subdomain quantities instead of the required global quantities.\n\nYour program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order\n$$\n[\\dot{\\zeta}^{(1)}, \\Delta_{\\max}^{(1)}, \\dot{\\zeta}^{(2)}, \\Delta_{\\max}^{(2)}, \\ldots] \\, ,\n$$\nwhere the superscript indicates the test case number. Express all reported numbers in $\\mathrm{s}^{-2}$ rounded to $10^{-6}$.\n\nUse the following test suite (all inputs are in the International System of Units, with velocities in $\\mathrm{m/s}$, masses in $\\mathrm{kg}$, temperature in $\\mathrm{K}$, and $Q$ in $\\mathrm{J\\,s^2}$):\n\n- Test case $1$ (general case):\n  - $N = 4$,\n  - masses: $[1.0\\times 10^{-26},\\, 2.0\\times 10^{-26},\\, 1.5\\times 10^{-26},\\, 0.5\\times 10^{-26}]\\,\\mathrm{kg}$,\n  - velocities: $[500.0,\\, -300.0,\\, 100.0,\\, 0.0]\\,\\mathrm{m/s}$,\n  - $T_0 = 300.0\\,\\mathrm{K}$,\n  - $Q = 1.0\\times 10^{-20}\\,\\mathrm{J\\,s^2}$,\n  - decomposition: $\\mathcal{D}_1 = \\{1,2\\}$, $\\mathcal{D}_2 = \\{3,4\\}$ (indices are $1$-based in this description; in zero-based indexing these are $[0,1]$ and $[2,3]$).\n\n- Test case $2$ (edge case with zero kinetic energy):\n  - $N = 3$,\n  - masses: $[1.0\\times 10^{-26},\\, 1.0\\times 10^{-26},\\, 1.0\\times 10^{-26}]\\,\\mathrm{kg}$,\n  - velocities: $[0.0,\\, 0.0,\\, 0.0]\\,\\mathrm{m/s}$,\n  - $T_0 = 100.0\\,\\mathrm{K}$,\n  - $Q = 1.0\\times 10^{-21}\\,\\mathrm{J\\,s^2}$,\n  - decomposition: $\\mathcal{D}_1 = \\{1,2\\}$, $\\mathcal{D}_2 = \\{3\\}$ (zero-based: $[0,1]$ and $[2]$).\n\n- Test case $3$ (boundary case with a single particle):\n  - $N = 1$,\n  - masses: $[1.0\\times 10^{-26}]\\,\\mathrm{kg}$,\n  - velocities: $[400.0]\\,\\mathrm{m/s}$,\n  - $T_0 = 300.0\\,\\mathrm{K}$,\n  - $Q = 1.0\\times 10^{-20}\\,\\mathrm{J\\,s^2}$,\n  - decomposition: $\\mathcal{D}_1 = \\{1\\}$ (zero-based: $[0]$).\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[\\dot{\\zeta}^{(1)}, \\Delta_{\\max}^{(1)}, \\dot{\\zeta}^{(2)}, \\Delta_{\\max}^{(2)}, \\dot{\\zeta}^{(3)}, \\Delta_{\\max}^{(3)}]$, with each number rounded to $10^{-6}$ in $\\mathrm{s}^{-2}$.", "solution": "The problem presented is a straightforward exercise in computational physics, suitable for verifying a student's comprehension of thermostatting algorithms in molecular dynamics simulations. The problem is well-defined, scientifically sound, and all necessary parameters are provided. We shall proceed directly to the solution.\n\nThe core principle of a global thermostat, such as the Nosé–Hoover thermostat, is that it couples to a global, system-wide property—in this case, the total kinetic energy of all particles. The thermostat's purpose is to regulate this global energy to maintain a target temperature $T_0$ for the entire system, not for individual parts of it. A naive implementation in a parallel code, using a spatial domain decomposition, might incorrectly attempt to thermostat each subdomain locally using only local properties. This problem requires us to quantify the error, or inconsistency, of such a flawed local approach compared to the correct global one.\n\nLet us define the required quantities with precision. The system consists of $N$ particles with masses $\\{m_j\\}_{j=1}^N$ and one-dimensional velocities $\\{v_j\\}_{j=1}^N$. The constant $k_{\\mathrm{B}}$ represents the Boltzmann constant, given as $1.380649 \\times 10^{-23}\\,\\mathrm{J/K}$.\n\nThe total kinetic energy of the system is a sum over all particles:\n$$\nK = \\sum_{j=1}^{N} \\frac{1}{2} m_j v_j^2\n$$\nThe number of degrees of freedom $g$ for this one-dimensional system is simply the number of particles, $g=N$.\n\nThe correct equation of motion for the global Nosé–Hoover thermostat variable $\\zeta$, which has a mass parameter $Q$, is given by:\n$$\n\\dot{\\zeta} = \\frac{2K - g k_{\\mathrm{B}} T_0}{Q}\n$$\nThis is the globally consistent rate, which we must calculate for each test case.\n\nThe system is partitioned into $M$ disjoint subdomains, with particle index sets $\\{\\mathcal{D}_i\\}_{i=1}^{M}$. For each subdomain $i$, one can define a local kinetic energy $K_i$ and a local number of degrees of freedom $g_i$:\n$$\nK_i = \\sum_{j \\in \\mathcal{D}_i} \\frac{1}{2} m_j v_j^2\n\\quad \\text{and} \\quad\ng_i = |\\mathcal{D}_i|\n$$\nIt is a simple matter of algebra to see that $\\sum_{i=1}^{M} K_i = K$ and $\\sum_{i=1}^{M} g_i = g$.\n\nAn inconsistent, local thermostat rate $\\dot{\\zeta}_i^{\\mathrm{local}}$ for each subdomain $i$ would be erroneously calculated as:\n$$\n\\dot{\\zeta}_i^{\\mathrm{local}} = \\frac{2K_i - g_i k_{\\mathrm{B}} T_0}{Q}\n$$\nThis expression is fundamentally incorrect because the thermostat variable $\\zeta$ is a single, global entity. Different parts of the system cannot and must not attempt to drive it at different rates. The inconsistency is measured by the maximum absolute deviation, $\\Delta_{\\max}$:\n$$\n\\Delta_{\\max} = \\max_{1 \\le i \\le M} \\left| \\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta} \\right|\n$$\n\nThe computational procedure is as follows:\n1.  For each test case, read the inputs: $N$, $\\{m_j\\}$, $\\{v_j\\}$, $T_0$, $Q$, and the subdomain decomposition $\\{\\mathcal{D}_i\\}$.\n2.  Calculate the total kinetic energy $K$.\n3.  Calculate the total degrees of freedom $g=N$.\n4.  Compute the correct global thermostat rate $\\dot{\\zeta}$ using its definition.\n5.  For each subdomain $\\mathcal{D}_i$:\n    a. Calculate the local kinetic energy $K_i$.\n    b. Calculate the local degrees of freedom $g_i$.\n    c. Compute the incorrect local rate $\\dot{\\zeta}_i^{\\mathrm{local}}$.\n6.  Calculate the set of absolute deviations $\\{|\\dot{\\zeta}_i^{\\mathrm{local}} - \\dot{\\zeta}|\\}$.\n7.  Determine the maximum value from this set, $\\Delta_{\\max}$.\n8.  Record the results for $\\dot{\\zeta}$ and $\\Delta_{\\max}$, rounded to $10^{-6}\\,\\mathrm{s}^{-2}$.\n\nWe apply this procedure to the specified test cases.\n\n**Test Case 1:**\n- $N=4$, $g=4$, $T_0 = 300.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-20}\\,\\mathrm{J\\,s^2}$.\n- Masses: $m = [1.0, 2.0, 1.5, 0.5] \\times 10^{-26}\\,\\mathrm{kg}$.\n- Velocities: $v = [500.0, -300.0, 100.0, 0.0]\\,\\mathrm{m/s}$.\n- Decomposition: $\\mathcal{D}_1=\\{1, 2\\}$, $\\mathcal{D}_2=\\{3, 4\\}$.\n- Total kinetic energy $K = \\frac{1}{2}\\sum m_j v_j^2 = 2.225 \\times 10^{-21}\\,\\mathrm{J}$.\n- Global rate $\\dot{\\zeta} = (2K - g k_{\\mathrm{B}} T_0)/Q = (2 \\times 2.225 \\times 10^{-21} - 4 \\times 1.380649 \\times 10^{-23} \\times 300.0) / (1.0 \\times 10^{-20}) \\approx -1.211779\\,\\mathrm{s}^{-2}$.\n- Subdomain 1: $g_1=2$, $K_1 = 2.15 \\times 10^{-21}\\,\\mathrm{J}$, $\\dot{\\zeta}_1^{\\mathrm{local}} \\approx -0.398389\\,\\mathrm{s}^{-2}$.\n- Subdomain 2: $g_2=2$, $K_2 = 7.5 \\times 10^{-23}\\,\\mathrm{J}$, $\\dot{\\zeta}_2^{\\mathrm{local}} \\approx -0.813389\\,\\mathrm{s}^{-2}$.\n- Deviations: $|\\dot{\\zeta}_1^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 0.813389\\,\\mathrm{s}^{-2}$, $|\\dot{\\zeta}_2^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 0.398389\\,\\mathrm{s}^{-2}$.\n- $\\Delta_{\\max} \\approx 0.813389\\,\\mathrm{s}^{-2}$.\n\n**Test Case 2:**\n- $N=3$, $g=3$, $T_0 = 100.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-21}\\,\\mathrm{J\\,s^2}$.\n- All velocities are zero, so total kinetic energy $K=0\\,\\mathrm{J}$.\n- Global rate $\\dot{\\zeta} = (0 - g k_{\\mathrm{B}} T_0)/Q = (-3 \\times 1.380649 \\times 10^{-23} \\times 100.0) / (1.0 \\times 10^{-21}) \\approx -4.141947\\,\\mathrm{s}^{-2}$.\n- Subdomain 1 ($\\mathcal{D}_1=\\{1, 2\\}$): $g_1=2$, $K_1=0\\,\\mathrm{J}$, $\\dot{\\zeta}_1^{\\mathrm{local}} \\approx -2.761298\\,\\mathrm{s}^{-2}$.\n- Subdomain 2 ($\\mathcal{D}_2=\\{3\\}$): $g_2=1$, $K_2=0\\,\\mathrm{J}$, $\\dot{\\zeta}_2^{\\mathrm{local}} \\approx -1.380649\\,\\mathrm{s}^{-2}$.\n- Deviations: $|\\dot{\\zeta}_1^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 1.380649\\,\\mathrm{s}^{-2}$, $|\\dot{\\zeta}_2^{\\mathrm{local}} - \\dot{\\zeta}| \\approx 2.761298\\,\\mathrm{s}^{-2}$.\n- $\\Delta_{\\max} \\approx 2.761298\\,\\mathrm{s}^{-2}$.\n\n**Test Case 3:**\n- $N=1$, $g=1$, $T_0 = 300.0\\,\\mathrm{K}$, $Q = 1.0 \\times 10^{-20}\\,\\mathrm{J\\,s^2}$.\n- The system has only one particle, so there is only one \"subdomain\" which is the entire system.\n- Total kinetic energy $K = \\frac{1}{2}(1.0 \\times 10^{-26}\\,\\mathrm{kg})(400.0\\,\\mathrm{m/s})^2 = 8.0 \\times 10^{-22}\\,\\mathrm{J}$.\n- Global rate $\\dot{\\zeta} = (2K - g k_{\\mathrm{B}} T_0)/Q = (2 \\times 8.0 \\times 10^{-22} - 1 \\times 1.380649 \\times 10^{-23} \\times 300.0) / (1.0 \\times 10^{-20}) \\approx -0.254195\\,\\mathrm{s}^{-2}$.\n- For the single subdomain, $g_1=g=1$, $K_1=K$, so $\\dot{\\zeta}_1^{\\mathrm{local}} = \\dot{\\zeta}$.\n- The deviation is necessarily zero: $\\Delta_{\\max} = 0.0\\,\\mathrm{s}^{-2}$.\n\nThis analysis confirms that a naive local implementation leads to inconsistencies unless the subdomains happen to have a distribution of kinetic energy per degree of freedom that exactly matches the global average, or in the trivial case where there is only one domain. For a correct parallel implementation, global communication (a sum or \"Allreduce\" operation) is required to compute the total kinetic energy for the one global thermostat.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the global Nosé-Hoover thermostat rate and the maximum deviation\n    from an inconsistent local implementation for several test cases.\n    \"\"\"\n    # Boltzmann constant in J/K\n    K_B = 1.380649e-23\n\n    # Define the test cases from the problem statement.\n    # Note: Decomposition indices are 0-based.\n    test_cases = [\n        {\n            \"N\": 4,\n            \"masses\": np.array([1.0e-26, 2.0e-26, 1.5e-26, 0.5e-26]),\n            \"velocities\": np.array([500.0, -300.0, 100.0, 0.0]),\n            \"T0\": 300.0,\n            \"Q\": 1.0e-20,\n            \"decomposition\": [np.array([0, 1]), np.array([2, 3])]\n        },\n        {\n            \"N\": 3,\n            \"masses\": np.array([1.0e-26, 1.0e-26, 1.0e-26]),\n            \"velocities\": np.array([0.0, 0.0, 0.0]),\n            \"T0\": 100.0,\n            \"Q\": 1.0e-21,\n            \"decomposition\": [np.array([0, 1]), np.array([2])]\n        },\n        {\n            \"N\": 1,\n            \"masses\": np.array([1.0e-26]),\n            \"velocities\": np.array([400.0]),\n            \"T0\": 300.0,\n            \"Q\": 1.0e-20,\n            \"decomposition\": [np.array([0])]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        masses = case[\"masses\"]\n        velocities = case[\"velocities\"]\n        T0 = case[\"T0\"]\n        Q = case[\"Q\"]\n        decomposition = case[\"decomposition\"]\n\n        # Calculate per-particle kinetic energies\n        particle_kinetic_energies = 0.5 * masses * velocities**2\n\n        # --- Global calculation (correct) ---\n        # Total kinetic energy K\n        K_global = np.sum(particle_kinetic_energies)\n        # Global degrees of freedom g\n        g_global = N\n        # Global thermostat rate zeta_dot\n        zeta_dot_global = (2 * K_global - g_global * K_B * T0) / Q\n        \n        # --- Local calculations (inconsistent) ---\n        zeta_dot_locals = []\n        for subdomain_indices in decomposition:\n            # Local kinetic energy K_i\n            K_local = np.sum(particle_kinetic_energies[subdomain_indices])\n            # Local degrees of freedom g_i\n            g_local = len(subdomain_indices)\n            # Local thermostat rate zeta_dot_i\n            zeta_dot_local = (2 * K_local - g_local * K_B * T0) / Q\n            zeta_dot_locals.append(zeta_dot_local)\n        \n        # --- Deviation calculation ---\n        deviations = np.abs(np.array(zeta_dot_locals) - zeta_dot_global)\n        # Maximum absolute deviation Delta_max\n        # If there are no subdomains, max would fail. This case is not tested.\n        # If there is one subdomain, deviation is 0, so max is 0.\n        delta_max = np.max(deviations) if len(deviations) > 0 else 0.0\n\n        results.append(zeta_dot_global)\n        results.append(delta_max)\n\n    # Final print statement in the exact required format.\n    # Numbers are formatted to 6 decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2446283"}, {"introduction": "Thermostats are not only for equilibrium simulations; they are essential tools for studying non-equilibrium phenomena like heat transport. In this practice [@problem_id:2446245], you will construct a non-equilibrium molecular dynamics (NEMD) simulation of a 1D atomic chain. By coupling each end to a separate thermostat with a different target temperature, you will establish a steady-state heat flow and learn how to measure the resulting heat flux, a fundamental transport coefficient.", "problem": "Consider a one-dimensional chain of $N$ identical particles of mass $m$ arranged along a line and connected by identical harmonic springs of stiffness $k$ and rest length $a$. Let the position of particle $i$ be $x_i(t)$ for $i \\in \\{1,\\dots,N\\}$ with fixed anchors at $x_0(t) \\equiv 0$ and $x_{N+1}(t) \\equiv (N+1)a$. The total potential energy is\n$$\nU(x_0,\\dots,x_{N+1}) = \\sum_{i=0}^{N} \\tfrac{1}{2} k \\left(x_{i+1}-x_i-a\\right)^2,\n$$\nand the equations of motion are\n$$\nm \\,\\ddot{x}_i(t) = -\\frac{\\partial U}{\\partial x_i} = k\\left(x_{i-1}(t) + x_{i+1}(t) - 2 x_i(t)\\right), \\quad i=1,\\dots,N.\n$$\nThe leftmost particle $i=1$ and the rightmost particle $i=N$ are each coupled to separate Berendsen thermostats that attempt to maintain kinetic temperatures $T_1$ and $T_2$, respectively. In one spatial dimension, the instantaneous kinetic temperature of a group with $n_{\\mathrm{dof}}$ degrees of freedom is defined by the equipartition relation\n$$\n\\tfrac{1}{2} n_{\\mathrm{dof}} k_{\\mathrm{B}} T = \\sum \\tfrac{1}{2} m v^2,\n$$\nwhere $k_{\\mathrm{B}}$ is the Boltzmann constant and $v$ denotes velocity. For a single thermostatted particle in one spatial dimension, $n_{\\mathrm{dof}}=1$ and the instantaneous kinetic temperature equals $T = m v^2/k_{\\mathrm{B}}$. The Berendsen thermostat rescales the velocity $v$ of its group at time step $\\Delta t$ by a scalar factor $\\lambda$ given by\n$$\n\\lambda = \\sqrt{1 + \\frac{\\Delta t}{\\tau_T}\\left(\\frac{T_0}{T}-1\\right)},\n$$\nwhere $\\tau_T$ is the thermostat coupling time and $T_0$ is the target temperature ($T_1$ for the left particle, $T_2$ for the right particle). The rescaling $v \\leftarrow \\lambda v$ is applied to the leftmost and rightmost particle after each integration time step. Let $\\Delta K_{\\mathrm{L}}$ denote the change in kinetic energy of the leftmost particle due solely to this rescaling during one time step; the instantaneous power injected by the left thermostat is approximated by $\\Delta K_{\\mathrm{L}}/\\Delta t$. In steady state, the heat flux through the chain equals the average power injected by the left thermostat and also equals the magnitude of the power extracted by the right thermostat. Define the measured steady-state heat flux $J$ to be the time average of $\\Delta K_{\\mathrm{L}}/\\Delta t$ over a specified measurement window, with the convention that $J$ is positive when energy is injected into the chain by the left thermostat.\n\nUse reduced units such that $m=1$, $k=1$, $a=1$, $k_{\\mathrm{B}}=1$. The initial conditions at time $t=0$ are\n$$\nx_i(0) = i a,\\quad i=1,\\dots,N,\n$$\nand deterministic velocities chosen to have a spatial sinusoidal profile,\n$$\nv_i(0) = V_0 \\sin\\!\\left(\\frac{\\pi i}{N+1}\\right),\\quad i=1,\\dots,N,\n$$\nwhere\n$$\nV_0 = \\sqrt{\\frac{2 T_{\\mathrm{mid}}}{m}},\\quad T_{\\mathrm{mid}}=\\frac{T_1+T_2}{2}.\n$$\nEvolve the system with a constant time step $\\Delta t$ for a total simulation time $t_{\\mathrm{tot}}$. Discard an initial transient interval of duration $t_{\\mathrm{trans}}$, then compute $J$ as the time average of $\\Delta K_{\\mathrm{L}}/\\Delta t$ over the remaining time. Express the final answers for $J$ in reduced units of energy per unit time and round each value to three decimal places.\n\nTest suite. For each parameter tuple $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}})$ below, compute the corresponding steady-state heat flux $J$:\n- Case $1$: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 2.0, 1.0, 0.1, 0.001, 50.0, 20.0)$.\n- Case $2$: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (32, 1.5, 1.5, 0.1, 0.001, 50.0, 20.0)$.\n- Case $3$: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (8, 3.0, 0.5, 0.02, 0.001, 50.0, 20.0)$.\n- Case $4$: $(N, T_1, T_2, \\tau_T, \\Delta t, t_{\\mathrm{tot}}, t_{\\mathrm{trans}}) = (16, 2.5, 0.5, 1.0, 0.001, 80.0, 40.0)$.\n\nFinal output format. Your program should produce a single line of output containing the four results $[J_1,J_2,J_3,J_4]$ as a comma-separated list enclosed in square brackets, in the order of the cases above, each $J_i$ rounded to three decimal places in reduced units.", "solution": "The problem describes a non-equilibrium molecular dynamics simulation to study heat conduction. This is a standard and well-established problem in computational physics.\n- **Scientific Soundness**: The model of a harmonic chain, the equations of motion derived from the potential, the concept of a Berendsen thermostat, and the definition of heat flux via thermostat power are all fundamentally sound and widely used in the field.\n- **Well-Posedness**: The problem is well-posed. The system is described by a set of second-order ordinary differential equations with specified initial conditions. A unique solution for the trajectory exists. The quantity to be computed, a time-averaged heat flux, is well-defined.\n- **Objectivity and Completeness**: The problem is stated using precise, objective language and provides all necessary data and equations to proceed with the simulation. All parameters for the system and the simulation protocol are explicitly given. The use of reduced units simplifies the numerical aspects without loss of generality. The provided parameters, including the integration time step $\\Delta t = 0.001$, are physically reasonable and ensure numerical stability. The highest frequency of the chain in reduced units is $\\omega_{\\max} < 2$, corresponding to a period $T_{\\min} > \\pi$. The time step $\\Delta t = 0.001 \\ll T_{\\min}$, satisfying the stability criterion for common integration algorithms.\n\nThe problem is deemed **valid**. A solution will be constructed based on a numerical simulation following the specified principles.\n\n**Solution Design**\n\nThe problem is solved by performing a direct numerical simulation of the system dynamics. The core of the solution consists of three parts: a numerical integrator for the equations of motion, an implementation of the thermostatting procedure, and the calculation of the time-averaged heat flux.\n\n**1. System Initialization**\nIn reduced units, the constants are $m=1$, $k=1$, $a=1$, and $k_{\\mathrm{B}}=1$. For a given test case $(N, T_1, T_2, \\dots)$, the initial states of the $N$ particles are initialized as follows:\n- The position of particle $i$ is $x_i(0) = i$.\n- The velocity of particle $i$ is $v_i(0) = V_0 \\sin(\\frac{\\pi i}{N+1})$, with $V_0 = \\sqrt{2 T_{\\mathrm{mid}}}$ and $T_{\\mathrm{mid}} = (T_1+T_2)/2$.\nThese states are stored in NumPy arrays for efficient computation.\n\n**2. Numerical Integration**\nThe equations of motion are a system of coupled second-order ODEs. The Velocity Verlet algorithm is chosen for its numerical stability, time-reversibility, and symplectic nature, which are advantageous for long-time simulations in mechanics. For each time step $\\Delta t$, the positions $x_i(t)$ and velocities $v_i(t)$ are updated to $x_i(t+\\Delta t)$ and $v_i(t+\\Delta t)$. The algorithm proceeds in two stages:\n\nFirst, velocities are updated by a half-step, and positions are updated by a full step:\n$$\n\\vec{v}(t + \\tfrac{1}{2}\\Delta t) = \\vec{v}(t) + \\vec{a}(t) \\frac{\\Delta t}{2}\n$$\n$$\n\\vec{x}(t + \\Delta t) = \\vec{x}(t) + \\vec{v}(t + \\tfrac{1}{2}\\Delta t) \\Delta t\n$$\nNext, the accelerations $\\vec{a}(t+\\Delta t)$ are re-calculated using the new positions $\\vec{x}(t+\\Delta t)$. The accelerations are given by:\n$$\na_i = x_{i-1} + x_{i+1} - 2x_i, \\quad \\text{for } i \\in \\{2, \\ldots, N-1\\}\n$$\nwith boundary-specific expressions for $i=1$ and $i=N$:\n$$\na_1 = x_0 + x_2 - 2x_1 = 0 + x_2 - 2x_1\n$$\n$$\na_N = x_{N-1} + x_{N+1} - 2x_N = x_{N-1} + (N+1) - 2x_N\n$$\nFinally, the velocities are updated by the second half-step:\n$$\n\\vec{v}(t + \\Delta t) = \\vec{v}(t + \\tfrac{1}{2}\\Delta t) + \\vec{a}(t + \\Delta t) \\frac{\\Delta t}{2}\n$$\n\n**3. Thermostat Application**\nAfter each complete integration step, the Berendsen thermostats are applied to particles $1$ and $N$.\nFor particle $1$, with velocity $v_1$ and target temperature $T_1$:\n1.  The instantaneous kinetic temperature is calculated: $T_{curr,1} = m v_1^2 / k_{\\mathrm{B}} = v_1^2$.\n2.  The velocity scaling factor $\\lambda_1$ is computed. To prevent numerical issues such as division by zero or taking the square root of a negative number (which can happen with large velocity fluctuations), the formula is implemented robustly:\n    $$\n    \\lambda_1 = \\sqrt{\\max\\left(0, 1 + \\frac{\\Delta t}{\\tau_T}\\left(\\frac{T_1}{T_{curr,1} + \\epsilon}-1\\right)\\right)}\n    $$\n    where $\\epsilon$ is a small positive constant to handle the case $T_{curr,1}=0$.\n3.  The kinetic energy before scaling is stored: $K_{old,1} = \\frac{1}{2}m v_1^2 = 0.5 v_1^2$.\n4.  The velocity is rescaled: $v_1 \\leftarrow \\lambda_1 v_1$.\n5.  The kinetic energy after scaling is calculated: $K_{new,1} = 0.5 (\\lambda_1 v_1)^2$.\nThe same procedure is applied to particle $N$ with its velocity $v_N$ and target temperature $T_2$, but the change in its kinetic energy is not needed for the heat flux calculation.\n\n**4. Heat Flux Calculation**\nThe heat flux $J$ is the time-averaged power injected by the left thermostat. The instantaneous power injected during one time step $\\Delta t$ is approximated by $P_L = (K_{new,1} - K_{old,1}) / \\Delta t$. This power is accumulated for every step after the transient time $t_{\\mathrm{trans}}$. The total simulation runs for $t_{\\mathrm{tot}}$. The number of integration steps is $N_{steps,tot} = t_{\\mathrm{tot}} / \\Delta t$, and the number of transient steps is $N_{steps,trans} = t_{\\mathrm{trans}} / \\Delta t$. The heat flux $J$ is the average of $P_L$ over the measurement window:\n$$\nJ = \\frac{1}{N_{steps,tot} - N_{steps,trans}} \\sum_{step=N_{steps,trans}}^{N_{steps,tot}-1} P_L(step)\n$$\nThis procedure is repeated for each test case, and the final result is rounded to three decimal places.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, T1, T2, tau_T, dt, t_tot, t_trans):\n    \"\"\"\n    Performs a non-equilibrium molecular dynamics simulation of heat transport\n    in a 1D harmonic chain with Berendsen thermostats at the ends.\n\n    Args:\n        N (int): Number of particles in the chain.\n        T1 (float): Target temperature for the left thermostat.\n        T2 (float): Target temperature for the right thermostat.\n        tau_T (float): Thermostat coupling time constant.\n        dt (float): Integration time step.\n        t_tot (float): Total simulation time.\n        t_trans (float): Transient time to be discarded for averaging.\n\n    Returns:\n        float: The calculated steady-state heat flux J.\n    \"\"\"\n    # System parameters in reduced units\n    m = 1.0\n    k = 1.0\n    a = 1.0\n    k_B = 1.0\n\n    # Initial conditions\n    # Particle indices from 1 to N\n    i_vals = np.arange(1, N + 1, dtype=float)\n    \n    # Initial positions x_i(0) = i*a\n    x = i_vals * a\n    \n    # Initial velocities v_i(0)\n    T_mid = (T1 + T2) / 2.0\n    V0 = np.sqrt(2.0 * T_mid / m)\n    v = V0 * np.sin(np.pi * i_vals / (N + 1.0))\n\n    # Simulation time steps\n    num_total_steps = int(t_tot / dt)\n    num_trans_steps = int(t_trans / dt)\n\n    # Use a padded position array for easier force calculation\n    # xp[0] is x_0, xp[N+1] is x_{N+1}\n    xp = np.zeros(N + 2)\n    xp[0] = 0.0\n    xp[N + 1] = (N + 1.0) * a\n    \n    # Initial accelerations\n    xp[1:-1] = x\n    # a_i = (k/m) * (x_{i-1} + x_{i+1} - 2x_i)\n    acc = (k / m) * (xp[:-2] + xp[2:] - 2 * xp[1:-1])\n\n    # Measurement variables\n    total_power_injected = 0.0\n    measurement_steps = 0\n\n    # Main simulation loop (Velocity Verlet)\n    for step in range(num_total_steps):\n        # 1. Update velocities for half a time step\n        v += 0.5 * acc * dt\n\n        # 2. Update positions for a full time step\n        x += v * dt\n\n        # 3. Update accelerations using new positions\n        xp[1:-1] = x\n        acc = (k / m) * (xp[:-2] + xp[2:] - 2 * xp[1:-1])\n\n        # 4. Update velocities for the remaining half time step\n        v += 0.5 * acc * dt\n\n        # 5. Apply Berendsen thermostats\n        # Left thermostat (particle i=1, index 0)\n        v1_sq = v[0]**2\n        T_curr_1 = (m * v1_sq) / k_B\n        \n        # Robust calculation of scaling factor\n        # Add a small epsilon to prevent division by zero for T_curr=0\n        arg1 = 1.0 + (dt / tau_T) * (T1 / (T_curr_1 + 1e-15) - 1.0)\n        lambda_1 = np.sqrt(max(0.0, arg1))\n        \n        K_old_L = 0.5 * m * v[0]**2\n        v[0] *= lambda_1\n        K_new_L = 0.5 * m * v[0]**2\n        \n        delta_K_L = K_new_L - K_old_L\n        power_L = delta_K_L / dt\n        \n        # Right thermostat (particle i=N, index N-1)\n        vN_sq = v[-1]**2\n        T_curr_N = (m * vN_sq) / k_B\n        \n        argN = 1.0 + (dt / tau_T) * (T2 / (T_curr_N + 1e-15) - 1.0)\n        lambda_N = np.sqrt(max(0.0, argN))\n        v[-1] *= lambda_N\n\n        # 6. Accumulate heat flux after transient phase\n        if step >= num_trans_steps:\n            total_power_injected += power_L\n            measurement_steps += 1\n\n    # Calculate average heat flux J\n    if measurement_steps > 0:\n        J = total_power_injected / measurement_steps\n    else:\n        J = 0.0\n        \n    return J\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (32, 2.0, 1.0, 0.1, 0.001, 50.0, 20.0),\n        (32, 1.5, 1.5, 0.1, 0.001, 50.0, 20.0),\n        (8, 3.0, 0.5, 0.02, 0.001, 50.0, 20.0),\n        (16, 2.5, 0.5, 1.0, 0.001, 80.0, 40.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T1, T2, tau_T, dt, t_tot, t_trans = case\n        J = run_simulation(N, T1, T2, tau_T, dt, t_tot, t_trans)\n        # Round the result to three decimal places.\n        results.append(f\"{J:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n\n```", "id": "2446245"}, {"introduction": "A thermostat can be viewed as a feedback control algorithm, and like any such algorithm, its stability is not guaranteed. This exercise [@problem_id:2446284] delves into this concept by asking you to simulate a hypothetical \"delayed\" Berendsen thermostat. By analyzing how the system's temperature evolves under feedback that depends on its past state, you will gain a practical understanding of how factors like time delay can lead to numerical instability in thermostatting algorithms.", "problem": "You are asked to study a discrete-time thermostat that attempts to control the kinetic temperature by scaling velocities. Consider a discrete-time thermostat operating at time step size $\\Delta t$ with a time constant $\\tau$ targeting a constant temperature $T_0$ in reduced units with Boltzmann's constant set to $1$ (no physical units are required). At step index $n \\in \\mathbb{Z}$, let $T_n$ denote the instantaneous kinetic temperature. The thermostat rescales the velocities by a factor whose square is\n$$\ns_n^2 = 1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right),\n$$\nwhere $m \\in \\mathbb{N}_0$ denotes an integer delay measured in steps, corresponding to a physical delay $\\Delta t_{\\mathrm{delay}} = m \\,\\Delta t$. The temperature then updates by\n$$\nT_{n+1} = s_n^2 \\, T_n.\n$$\nAssume the delay is an exact integer multiple of the step, so that $m = \\Delta t_{\\mathrm{delay}}/\\Delta t \\in \\mathbb{N}_0$. Assume the delayed history for $n \\le 0$ is initialized by $T_n = T_{\\mathrm{init}}$. The system is stable for a given parameter set if and only if $T_n \\to T_0$ as $n \\to \\infty$.\n\nYou must write a complete, runnable program that, for each provided parameter set, simulates the above recurrence for $N$ steps and classifies stability as follows. Define the absolute relative deviation sequence $r_n = \\left|\\frac{T_n}{T_0} - 1\\right|$. Let $K = \\lfloor 0.2 N \\rfloor$. The parameter set is classified as stable if and only if the maximum of $r_n$ over the last $K$ steps is strictly less than a given tolerance $\\mathrm{tol}$.\n\nYour program must execute the recurrence exactly as stated above for each test case and produce a single line containing a list of boolean results in the required format. Use the following test suite, where all numerical values are given in reduced units:\n\n- Case $1$: $(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 0\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$.\n- Case $2$: $(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 1\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$.\n- Case $3$: $(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 2\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$.\n- Case $4$: $(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 2\\times 10^{-3},\\, 3\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$.\n- Case $5$: $(\\Delta t, \\tau, \\Delta t_{\\mathrm{delay}}, T_0, T_{\\mathrm{init}}, N, \\mathrm{tol}) = \\left(10^{-3},\\, 1.53846153846\\times 10^{-3},\\, 2\\times 10^{-3},\\, 1,\\, 2,\\, 20000,\\, 10^{-3}\\right)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, \"[True,False,True,False,True]\").", "solution": "The problem statement is valid. It presents a well-posed, scientifically grounded problem in computational physics. It asks for the numerical simulation of a discrete-time delayed feedback system, which is a simplified model of a Berendsen thermostat used in molecular dynamics simulations. All necessary parameters, initial conditions, recurrence relations, and a precise operational definition for stability are provided. The problem is self-contained and free from logical contradictions or ambiguities.\n\nThe core of the problem is to determine the stability of a temperature control algorithm described by a nonlinear delayed recurrence relation. The temperature $T_n$ at step $n$ is governed by the equations:\n$$\nT_{n+1} = s_n^2 \\, T_n\n$$\nwhere the velocity scaling factor squared, $s_n^2$, is given by\n$$\ns_n^2 = 1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right).\n$$\nHere, $\\Delta t$ is the time step, $\\tau$ is the thermostat's time constant, $T_0$ is the target temperature, and $m = \\Delta t_{\\mathrm{delay}}/\\Delta t$ is the feedback delay in discrete steps. The history for non-positive step indices is given by $T_k = T_{\\mathrm{init}}$ for all $k \\le 0$.\n\nCombining these equations, we obtain the single recurrence relation for the temperature:\n$$\nT_{n+1} = T_n \\left(1 + \\frac{\\Delta t}{\\tau} \\left(\\frac{T_0}{T_{n-m}} - 1\\right)\\right).\n$$\nThis is a discrete dynamical system. The stability of such a system can be theoretically investigated by linearizing around its fixed point. The fixed point of this recurrence is clearly $T_n = T_0$ for all $n$, as this yields $T_{n+1} = T_0(1+0) = T_0$.\n\nTo analyze the linear stability, we introduce a small perturbation $\\epsilon_n$ such that $T_n = T_0(1 + \\epsilon_n)$. Substituting this into the recurrence relation and linearizing for small $\\epsilon_n$ (i.e., using $(1+\\epsilon_{n-m})^{-1} \\approx 1 - \\epsilon_{n-m}$ and discarding terms of order $\\epsilon^2$ and higher) yields a linear recurrence for the perturbation:\n$$\n\\epsilon_{n+1} \\approx \\epsilon_n - \\frac{\\Delta t}{\\tau} \\epsilon_{n-m}.\n$$\nLet us define the dimensionless constant $C = \\Delta t/\\tau$. The linear recurrence becomes:\n$$\n\\epsilon_{n+1} - \\epsilon_n + C \\epsilon_{n-m} = 0.\n$$\nSeeking solutions of the form $\\epsilon_n = \\lambda^n$, we obtain the characteristic equation:\n$$\n\\lambda^{n+1} - \\lambda^n + C \\lambda^{n-m} = 0.\n$$\nDividing by $\\lambda^{n-m}$ (assuming $\\lambda \\ne 0$), we get:\n$$\n\\lambda^{m+1} - \\lambda^m + C = 0.\n$$\nThe system is linearly stable if and only if all roots $\\lambda$ of this polynomial have a magnitude strictly less than $1$, i.e., $|\\lambda| < 1$. For $m=2$ and $C=0.5$, for instance, one can show that there are roots with $|\\lambda|=1$, placing the system on the boundary of stability. For $C>0.5$, the system becomes unstable. This theoretical analysis serves as a guide but the problem demands a direct simulation.\n\nThe algorithm to be implemented is a direct simulation of the temperature evolution.\n1.  Initialize an array `T` of size $N+1$ to store the temperatures $T_0, T_1, \\dots, T_N$. The value $T_0$ is set to $T_{\\mathrm{init}}$.\n2.  Iterate for step index $n$ from $0$ to $N-1$. In each step:\n    a. Determine the delayed temperature $T_{n-m}$. If $n-m  0$, its value is $T_{\\mathrm{init}}$. Otherwise, it is retrieved from the `T` array at index $n-m$.\n    b. Calculate the scaling factor $s_n^2$ using the value of $T_{n-m}$.\n    c. Calculate the next temperature $T_{n+1} = s_n^2 T_n$ and store it in the `T` array at index $n+1$.\n    d. A robust implementation must consider the case where $T_{n-m} \\le 0$, which would make the scaling factor ill-defined. In such a scenario of extreme instability, subsequent temperatures are set to not-a-number (`NaN`) to signify failure.\n3.  After completing the $N$ steps, the stability is assessed based on the provided numerical criterion. Let $K = \\lfloor 0.2N \\rfloor$.\n4.  The set of absolute relative deviations, $r_n = \\left| \\frac{T_n}{T_0} - 1 \\right|$, is computed for the last $K$ steps of the simulation (i.e., for $n \\in \\{N-K+1, \\dots, N\\}$).\n5.  If this set of deviations contains non-finite values (e.g., `inf` or `NaN`), the system is classified as unstable.\n6.  Otherwise, the maximum value in this set is found, $\\max(r_n)$. The parameter set is classified as stable if and only if this maximum is strictly less than the given tolerance, $\\mathrm{tol}$.\n\nThis procedure is executed for each set of parameters provided in the test suite. The final output is a list of boolean values (`True` for stable, `False` for unstable) in the specified format.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermostat stability problem by simulating the temperature evolution\n    for each test case and applying the specified stability criterion.\n    \"\"\"\n    test_cases = [\n        # Case 1: (dt, tau, dt_delay, T0, T_init, N, tol)\n        (1e-3, 2e-3, 0e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 2\n        (1e-3, 2e-3, 1e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 3\n        (1e-3, 2e-3, 2e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 4\n        (1e-3, 2e-3, 3e-3, 1.0, 2.0, 20000, 1e-3),\n        # Case 5\n        (1e-3, 1.53846153846e-3, 2e-3, 1.0, 2.0, 20000, 1e-3),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        dt, tau, dt_delay, T0, T_init, N, tol = case\n\n        # Calculate integer delay m\n        # Using round to be robust against floating point inaccuracies,\n        # then casting to int.\n        m = int(round(dt_delay / dt))\n\n        # Array to store temperature history from T_0 to T_N\n        T = np.zeros(N + 1, dtype=np.float64)\n        T[0] = T_init\n\n        # Pre-calculate ratio for efficiency\n        dt_div_tau = dt / tau\n\n        # Simulation loop from n=0 to N-1 to compute T_1,...,T_N\n        for n in range(N):\n            # Get the delayed temperature T_{n-m}\n            # For n-m  0, use the initial temperature history\n            if n - m  0:\n                T_delayed = T_init\n            else:\n                T_delayed = T[n - m]\n\n            # If T_delayed is non-positive, the system is highly unstable.\n            # The scaling factor would be undefined or infinite.\n            # We mark subsequent temperatures as NaN and break.\n            if T_delayed = 0:\n                T[n+1:] = np.nan\n                break\n\n            # Calculate the scaling factor squared\n            s_squared = 1 + dt_div_tau * (T0 / T_delayed - 1)\n            \n            # Update the temperature\n            T[n+1] = s_squared * T[n]\n\n        # Stability classification\n        K = int(0.2 * N)\n        \n        # Check stability on the last K steps of the simulation.\n        # Indices are N-K+1, ..., N. Slice is T[N-K+1:].\n        last_K_T = T[N - K + 1:]\n\n        # If any values in the final window are not finite, the system is unstable.\n        if not np.all(np.isfinite(last_K_T)):\n            is_stable = False\n        else:\n            # Calculate absolute relative deviations r_n\n            r_values = np.abs(last_K_T / T0 - 1)\n            max_r = np.max(r_values)\n            # Classify stability based on the tolerance\n            is_stable = max_r  tol\n\n        results.append(is_stable)\n\n    # Format the final output as a comma-separated list of booleans in brackets.\n    # The map(str,...) is used to get \"True\" and \"False\" strings correctly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2446284"}]}