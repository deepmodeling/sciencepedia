{"hands_on_practices": [{"introduction": "At its core, Smoothed Particle Hydrodynamics (SPH) is a method for discretizing the continuous equations of fluid dynamics. A crucial step in this process is approximating spatial derivatives, such as the Laplacian operator that appears in diffusion or pressure terms. This exercise provides foundational practice by guiding you through the implementation of an SPH operator for the second derivative [@problem_id:2439500]. You will explore how the choice of the smoothing kernel, a central element of SPH, influences numerical accuracy by comparing the standard cubic spline with a higher-order quintic spline kernel.", "problem": "Implement a program that, for one-dimensional Smoothed Particle Hydrodynamics (SPH), constructs the second derivative approximation of a scalar field using two compactly supported kernels: the standard cubic spline and a quintic spline. You must derive the needed formulas and implement them from first principles. The comparison must be performed on a periodic domain using equally spaced particles and a difference-consistent SPH operator for the second derivative. The quantities are all dimensionless and angles are in radians.\n\nStart from the fundamental base of SPH: the approximation of a function $f(x)$ via a normalized, positive, radially symmetric kernel $W(r,h)$ with compact support and smoothing length $h$, and the SPH replacement of integrals by sums over particle volumes. Use the following principles:\n- Kernel approximation of derivatives follows from differentiating the kernel inside the convolution integral.\n- For discrete particles with uniform spacing $\\Delta x$ and constant density, the particle volume is $V = \\Delta x$.\n- To avoid zeroth-order errors, use a difference-consistent discrete operator for the second derivative based on kernel second derivatives.\n\nYour tasks:\n1. Derive, from the SPH convolution integral and uniform sampling with periodic boundary conditions on $[0,L)$, a discrete, difference-consistent second derivative operator at particle position $x_i$ of the form\n   $$ f''(x_i) \\approx \\sum_{j} V \\, \\big(f(x_j) - f(x_i)\\big) \\, \\frac{\\partial^2}{\\partial x^2} W\\!\\big(|x_i - x_j|, h\\big), $$\n   where $V = \\Delta x$, $x_j$ are the particle positions, and the sum includes all neighbors within the kernel support. Explain why, in one dimension with $r = |x|$, $\\frac{\\partial^2}{\\partial x^2}W(r,h) = \\frac{d^2}{dr^2}W(r,h)$ for $r \\neq 0$.\n\n2. Implement in one dimension the standard cubic spline kernel and a quintic spline kernel, each with their correct normalizations and compact supports, and derive their one-dimensional second radial derivatives $d^2W/dr^2$ as functions of $q = r/h$ and $h$. The cubic spline has support radius $2h$ and the quintic spline has support radius $3h$. You must provide the piecewise-polynomial expressions you use for both kernels and their second derivatives in your solution.\n\n3. Use the operator from task $1$ to approximate $f''(x)$ for the following test suite. In all cases, use periodic boundary conditions, equally spaced particles, and $h = \\eta \\, \\Delta x$ with the given $\\eta$; angles are in radians.\n   - Case A (single mode): $L = 1$, $N = 200$, $\\eta = 1.2$, $f(x) = \\sin(2\\pi x)$, so the exact second derivative is $f''(x) = - (2\\pi)^2 \\sin(2\\pi x)$.\n   - Case B (two-mode superposition): $L = 1$, $N = 256$, $\\eta = 1.0$, $f(x) = \\sin(2\\pi x) + 0.5 \\sin(6\\pi x)$, so the exact second derivative is $f''(x) = - (2\\pi)^2 \\sin(2\\pi x) - 0.5 \\, (6\\pi)^2 \\sin(6\\pi x)$.\n   - Case C (coarser sampling, smaller smoothing): $L = 1$, $N = 64$, $\\eta = 0.7$, $f(x) = \\sin(2\\pi x)$, exact second derivative as in Case A.\n   - Case D (localized Gaussian): $L = 1$, $N = 400$, $\\eta = 1.0$, $f(x) = \\exp\\!\\big(-\\frac{(x - 0.3)^2}{2 \\sigma^2}\\big)$ with $\\sigma = 0.05$, so the exact second derivative is $f''(x) = f(x)\\Big(\\frac{(x - 0.3)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\Big)$.\n\n4. For each case, compute the relative root-mean-square (RMS) error for each kernel,\n   $$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}}, $$\n   where $\\hat f_i''$ is the SPH approximation and $f_i''$ is the exact value. Report, for each case, the pair of errors for the cubic and quintic kernels, each rounded to six decimal places, and a boolean indicating whether the quintic spline error is strictly smaller than the cubic spline error.\n\nFinal output format:\n- Your program should produce a single line of output containing a comma-separated list of sublists, one per test case, in the order A, B, C, D.\n- Each sublist must be of the form $[e_{\\mathrm{cubic}}, e_{\\mathrm{quintic}}, b]$, where $e_{\\mathrm{cubic}}$ and $e_{\\mathrm{quintic}}$ are the relative RMS errors rounded to six decimal places, and $b$ is a boolean that is $True$ if $e_{\\mathrm{quintic}} < e_{\\mathrm{cubic}}$ and $False$ otherwise.\n- Example pattern (not actual values): $[[0.012345,0.006789,True],[\\dots],\\dots]$.\n\nAll outputs are dimensionless floats for the errors and booleans for the comparisons, and the single line must contain only this list. No other text should be printed.", "solution": "The problem as stated is scientifically grounded, well-posed, and self-contained. It presents a standard exercise in the field of computational physics, specifically concerning the numerical approximation of derivatives using the Smoothed Particle Hydrodynamics (SPH) method. All required data and definitions are provided, and there are no evident contradictions or ambiguities. Therefore, we proceed directly to the derivation and solution.\n\nThe task is to construct and evaluate a one-dimensional SPH approximation for the second derivative of a scalar field, $f''(x)$, using two different smoothing kernels. The core of the problem lies in the correct formulation of the SPH operator and the kernels themselves.\n\nFirst, we derive the specified SPH operator for the second derivative. The foundation of SPH is the kernel approximation of a function $f(x)$, which is expressed as a convolution with a smoothing kernel $W$:\n$$ \\langle f(x) \\rangle = \\int_{\\Omega} f(x') W(|x-x'|, h) \\, dx' $$\nHere, $W$ is a normalized kernel with compact support defined by the smoothing length $h$. An approximation for the second derivative, $\\langle f''(x) \\rangle$, is obtained by differentiating this integral representation twice with respect to $x$. Assuming sufficient smoothness of $W$, we can pass the derivatives under the integral sign:\n$$ \\langle f''(x) \\rangle = \\int_{\\Omega} f(x') \\frac{\\partial^2}{\\partial x^2} W(|x-x'|, h) \\, dx' $$\nTo obtain a numerical method, this integral is discretized into a sum over a set of \"particles\" located at positions $x_j$. Each particle carries a value of the field, $f(x_j)$, and represents a small volume $V_j$. For a uniform one-dimensional particle distribution with spacing $\\Delta x$, each particle represents a volume $V = \\Delta x$. The integral is thus replaced by a summation:\n$$ f''(x_i) \\approx \\sum_{j} V f(x_j) \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) $$\nThis is a standard SPH second derivative formula. However, it is known to suffer from a zeroth-order error, meaning it does not yield exactly zero for a constant field due to discretization error. The problem specifies a superior, difference-consistent formulation:\n$$ f''(x_i) \\approx \\sum_{j} V \\left( f(x_j) - f(x_i) \\right) \\frac{\\partial^2}{\\partial x^2} W(|x_i - x_j|, h) $$\nThe merit of this form is immediately apparent. If $f(x)$ is a constant function, $f(x)=C$, then $f(x_j) - f(x_i) = 0$ for all $j$. Consequently, the summation yields $f''(x_i) \\approx 0$, which is the exact result. This operator corrects the zeroth-order inconsistency.\n\nThe operator requires evaluation of $\\frac{\\partial^2}{\\partial x^2} W(r, h)$, where $r = |x_i - x_j|$. Let $\\Delta x = x_i - x_j$. The relation between the second partial derivative with respect to $\\Delta x$ and the second ordinary derivative with respect to $r=|\\Delta x|$ is found using the chain rule.\n$$ \\frac{\\partial W}{\\partial \\Delta x} = \\frac{dW}{dr} \\frac{\\partial r}{\\partial \\Delta x} = \\frac{dW}{dr} \\text{sgn}(\\Delta x) $$\nDifferentiating again with respect to $\\Delta x$ using the product rule gives:\n$$ \\frac{\\partial^2 W}{\\partial (\\Delta x)^2} = \\left( \\frac{d^2W}{dr^2} \\frac{\\partial r}{\\partial \\Delta x} \\right) \\text{sgn}(\\Delta x) + \\frac{dW}{dr} \\frac{\\partial}{\\partial \\Delta x} (\\text{sgn}(\\Delta x)) = \\frac{d^2W}{dr^2} (\\text{sgn}(\\Delta x))^2 + \\frac{dW}{dr} (2\\delta(\\Delta x)) $$\nFor any distinct pair of particles $i \\ne j$, we have $\\Delta x \\ne 0$ and thus $r \\ne 0$. In this case, $(\\text{sgn}(\\Delta x))^2 = 1$ and the Dirac delta term $\\delta(\\Delta x)$ is zero. The contribution of the particle $j=i$ to the sum is zero because $f(x_i) - f(x_i) = 0$. Therefore, for all terms contributing to the sum, the identity holds:\n$$ \\frac{\\partial^2}{\\partial x^2} W(|x_i-x_j|, h) = \\frac{d^2 W}{dr^2}(r, h) \\quad \\text{for } r = |x_i-x_j| \\neq 0 $$\n\nNext, we specify the kernels and their second derivatives. Let $q=r/h$ be the dimensionless distance.\n\n**1. Cubic Spline Kernel**\nThis kernel has a support radius of $2h$. The one-dimensional normalized form is:\n$$ W(r, h) = \\frac{1}{h} \\begin{cases} \\frac{2}{3} - q^2 + \\frac{1}{2}q^3 & 0 \\le q < 1 \\\\ \\frac{1}{6}(2-q)^3 & 1 \\le q \\le 2 \\\\ 0 & q > 2 \\end{cases} $$\nIts second derivative with respect to $r$ is found via $\\frac{d^2W}{dr^2} = \\frac{1}{h^3}\\frac{d^2}{dq^2}(hW)$. This gives:\n$$ \\frac{d^2W}{dr^2} = \\frac{1}{h^3} \\begin{cases} -2 + 3q & 0 \\le q < 1 \\\\ 2-q & 1 \\le q \\le 2 \\\\ 0 & q > 2 \\end{cases} $$\n\n**2. Quintic Spline Kernel**\nThis kernel offers higher-order accuracy and has a larger support radius of $3h$. The one-dimensional normalized form is:\n$$ W(r, h) = \\frac{1}{120h} \\begin{cases} (3-q)^5 - 6(2-q)^5 + 15(1-q)^5 & 0 \\le q < 1 \\\\ (3-q)^5 - 6(2-q)^5 & 1 \\le q < 2 \\\\ (3-q)^5 & 2 \\le q \\le 3 \\\\ 0 & q > 3 \\end{cases} $$\nIts second derivative with respect to $r$ is:\n$$ \\frac{d^2W}{dr^2} = \\frac{20}{120h^3} \\left. \\frac{d^2}{dq^2}(\\dots) \\right|_{\\text{poly}} = \\frac{1}{6h^3} \\begin{cases} (3-q)^3 - 6(2-q)^3 + 15(1-q)^3 & 0 \\le q < 1 \\\\ (3-q)^3 - 6(2-q)^3 & 1 \\le q < 2 \\\\ (3-q)^3 & 2 \\le q \\le 3 \\\\ 0 & q > 3 \\end{cases} $$\nThese formulae are implemented to compute the SPH approximation $\\hat{f}_i''$ for each particle position $x_i$ in the specified test cases. The domain is periodic, so distances between particles are calculated using the minimum image convention: $r_{ij} = \\min(|x_i-x_j|, L-|x_i-x_j|)$. The accuracy of each kernel is quantified by the relative root-mean-square (RMS) error $\\varepsilon$:\n$$ \\varepsilon = \\frac{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\big(\\hat f_i'' - f_i''\\big)^2}}{\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} \\big(f_i''\\big)^2}} $$\nwhere $\\hat f_i''$ is the SPH approximation and $f_i''$ is the analytical value of the second derivative at $x_i$. The following program performs these calculations for the given test suite.", "answer": "```python\nimport numpy as np\n\ndef d2W_cubic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D cubic spline kernel.\n    The kernel has support 2h.\n    \"\"\"\n    q = r / h\n    factor = 1.0 / (h ** 3)\n    val = 0.0\n    if q < 1.0:\n        val = -2.0 + 3.0 * q\n    elif q < 2.0:\n        val = 2.0 - q\n    return factor * val\n\ndef d2W_quintic_dr2(r, h):\n    \"\"\"\n    Computes the second derivative of the 1D quintic spline kernel.\n    The kernel has support 3h.\n    \"\"\"\n    q = r / h\n    # Normalization factor for d2W/dr2 is (1/120) * 20 / h^3 = 1 / (6*h^3)\n    factor = 1.0 / (6.0 * (h ** 3))\n    val = 0.0\n    if q < 1.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3 + 15.0 * (1.0 - q)**3\n    elif q < 2.0:\n        val = (3.0 - q)**3 - 6.0 * (2.0 - q)**3\n    elif q < 3.0:\n        val = (3.0 - q)**3\n    return factor * val\n\ndef calculate_f_double_prime_sph(x, f_vals, L, h, kernel_d2W_dr2, support_factor):\n    \"\"\"\n    Calculates the SPH approximation of the second derivative using a\n    difference-consistent operator.\n    \"\"\"\n    N = len(x)\n    dx = L / N\n    V = dx\n    f_pp_sph = np.zeros(N)\n    \n    support_radius = support_factor * h\n\n    for i in range(N):\n        sum_val = 0.0\n        for j in range(N):\n            if i == j:\n                continue\n            \n            dist_ij = x[i] - x[j]\n            # Apply periodic boundary conditions using minimum image convention\n            dist_ij -= L * np.round(dist_ij / L)\n            r = np.abs(dist_ij)\n\n            if r < support_radius:\n                d2W = kernel_d2W_dr2(r, h)\n                sum_val += (f_vals[j] - f_vals[i]) * d2W\n        \n        f_pp_sph[i] = V * sum_val\n        \n    return f_pp_sph\n\ndef compute_relative_rms_error(approx, exact):\n    \"\"\"\n    Computes the relative root-mean-square error.\n    \"\"\"\n    numerator = np.sqrt(np.mean((approx - exact)**2))\n    denominator = np.sqrt(np.mean(exact**2))\n    if denominator == 0:\n        return 0.0 if numerator == 0 else np.inf\n    return numerator / denominator\n\ndef solve():\n    test_cases = [\n        # Case A\n        {'L': 1.0, 'N': 200, 'eta': 1.2, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case B\n        {'L': 1.0, 'N': 256, 'eta': 1.0, \n         'f': lambda x: np.sin(2 * np.pi * x) + 0.5 * np.sin(6 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x) - 0.5 * (6 * np.pi)**2 * np.sin(6 * np.pi * x)},\n        # Case C\n        {'L': 1.0, 'N': 64, 'eta': 0.7, \n         'f': lambda x: np.sin(2 * np.pi * x),\n         'f_pp': lambda x: -(2 * np.pi)**2 * np.sin(2 * np.pi * x)},\n        # Case D\n        {'L': 1.0, 'N': 400, 'eta': 1.0, \n         'f': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)),\n         'f_pp': lambda x, sigma=0.05: np.exp(-(x - 0.3)**2 / (2 * sigma**2)) * (((x - 0.3)**2 / sigma**4) - (1 / sigma**2))}\n    ]\n    \n    results = []\n    \n    for case in test_cases:\n        L = case['L']\n        N = case['N']\n        eta = case['eta']\n        f_func = case['f']\n        f_pp_func = case['f_pp']\n        \n        dx = L / N\n        h = eta * dx\n        x = np.linspace(0, L, N, endpoint=False)\n        \n        f_vals = f_func(x)\n        f_pp_exact = f_pp_func(x)\n\n        # Cubic spline calculation\n        f_pp_cubic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_cubic_dr2, 2.0)\n        error_cubic = compute_relative_rms_error(f_pp_cubic, f_pp_exact)\n        \n        # Quintic spline calculation\n        f_pp_quintic = calculate_f_double_prime_sph(x, f_vals, L, h, d2W_quintic_dr2, 3.0)\n        error_quintic = compute_relative_rms_error(f_pp_quintic, f_pp_exact)\n        \n        is_quintic_better = error_quintic < error_cubic\n        \n        results.append([round(error_cubic, 6), round(error_quintic, 6), is_quintic_better])\n        \n    output_parts = []\n    for res_list in results:\n        part = f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\"\n        output_parts.append(part)\n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2439500"}, {"introduction": "Any SPH calculation, whether for density, pressure, or viscosity, relies on summations over a particle's local neighborhood. Because SPH kernels have compact support, we only need to consider particles within a radius of a few smoothing lengths. However, finding these neighbors for millions of particles can be the most time-consuming part of a simulation. This practice introduces a powerful and widely used solution: using a k-dimensional tree (K-D tree) to accelerate the neighbor search from a slow $O(N^2)$ process to a much more manageable one. You will implement this efficient search to perform a fundamental SPH task: calculating the density field of a particle distribution [@problem_id:2416285].", "problem": "In Smoothed Particle Hydrodynamics (SPH), a continuum field such as mass density is approximated by a weighted sum over discrete particles. The foundational starting point is the particle approximation of a continuum integral: given particle positions $\\{\\mathbf{r}_j\\}$, particle masses $\\{m_j\\}$, and a smoothing kernel $W(\\mathbf{r}, h)$ with smoothing length $h$, the density at particle $i$ is approximated by the sum $\\rho_i \\approx \\sum_j m_j \\, W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)$. A widely used choice is the three-dimensional cubic spline kernel with compact support. For three spatial dimensions, write $r = \\lVert \\mathbf{r} \\rVert$, $q = r/h$, and use\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3, & 0 \\le q < 1, \\\\\n\\frac{1}{4} (2 - q)^3, & 1 \\le q < 2, \\\\\n0, & q \\ge 2.\n\\end{cases}\n$$\nThis kernel has compact support of radius $2h$ and therefore only particles within $r \\le 2 h$ influence a given particle. A naive all-pairs neighbor search for $N$ particles requires checking all $N(N-1)/2$ pairs, which is computationally expensive. A $k$-dimensional tree (K-D tree) data structure organizes points in space to enable efficient range queries. By querying only within the kernel support radius, the density calculation can be accelerated while preserving the exact SPH sum defined above. You must implement a program that, for several specified test cases, constructs a K-D tree on the particle positions and computes for each particle:\n- The SPH density $\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$ using the three-dimensional cubic spline kernel, where $\\mathcal{N}_i$ are neighbors returned by a radius query of radius $2 h_i$ around $\\mathbf{r}_i$, and the sum includes the particle itself (self-contribution at $r=0$).\n- The neighbor count $\\lvert \\mathcal{N}_i \\rvert$ returned by the K-D tree within the kernel support, where the condition is $r \\le 2 h_i$.\n\nUse the following, fully specified test suite. All positions are three-dimensional and expressed in kiloparsec (kpc). All masses are in solar masses ($\\text{M}_\\odot$). All smoothing lengths are in kiloparsec (kpc). Densities must be reported in solar masses per cubic kiloparsec ($\\text{M}_\\odot/\\text{kpc}^3$). Angles are not used in this problem. The test suite consists of $3$ cases:\n\n- Test case $1$ (general cluster with uniform smoothing length): positions\n$[\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$, masses $[\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$, and uniform smoothing length $h=0.5$.\n- Test case $2$ (boundary neighbor at exactly the kernel support limit): positions $[\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$, masses $[\\,1.0,\\,1.0\\,]$, and uniform smoothing length $h=0.2$.\n- Test case $3$ (variable per-particle smoothing length): positions $[\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$, masses $[\\,1.0,\\,2.0,\\,1.0\\,]$, and per-particle smoothing lengths $[\\,0.5,\\,0.3,\\,0.7\\,]$.\n\nYour task:\n- Implement the three-dimensional cubic spline kernel exactly as defined above.\n- Build a K-D tree for each test case to find, for each particle $i$, all neighbors within radius $2 h_i$.\n- Compute $\\rho_i$ for each particle using the kernel $W$ and include the self-contribution.\n- Report, for each particle and each test case, both the density and the neighbor count $\\lvert \\mathcal{N}_i \\rvert$.\n\nUnit and formatting requirements:\n- Express densities in $\\text{M}_\\odot/\\text{kpc}^3$ and round each density to $6$ decimal places.\n- Neighbor counts must be integers.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The result for each test case must be a list of two lists: the first list is the per-particle densities for that test case (floats rounded to $6$ decimal places), and the second list is the per-particle neighbor counts (integers). For example, the overall output format is $[\\,[\\,[\\rho_{1,1}, \\rho_{1,2}, \\dots],\\,[c_{1,1}, c_{1,2}, \\dots]\\,],\\,[\\,[\\rho_{2,1}, \\dots],\\,[c_{2,1}, \\dots]\\,],\\,[\\,[\\rho_{3,1}, \\dots],\\,[c_{3,1}, \\dots]\\,]\\,]$ where indices $(t,i)$ denote particle $i$ in test case $t$.\n- The program must be fully self-contained, with the test suite hard-coded, and must not read any input.\n\nDesign your algorithm from first principles, starting from the definition of the SPH sum and the compact support of the kernel to justify the use of a radius query with radius $2 h_i$. Then implement the K-D tree based neighbor search to compute the required outputs for the given test suite. Ensure the logic is correct for the boundary case at $r = 2 h$ and for variable per-particle smoothing lengths. The final output must be a single line in the exact format described above.", "solution": "The problem statement is subjected to validation.\n\n**Step 1: Extract Givens**\n- **Physical Model**: Smoothed Particle Hydrodynamics (SPH) density estimation.\n- **Target Quantity**: Particle density $\\rho_i$.\n- **Formula**: $\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$.\n- **Smoothing Kernel**: A three-dimensional cubic spline kernel, defined as follows. Let $r = \\lVert \\mathbf{r} \\rVert$ and $q = r/h$.\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3, & 0 \\le q < 1, \\\\\n\\frac{1}{4} (2 - q)^3, & 1 \\le q < 2, \\\\\n0, & q \\ge 2.\n\\end{cases}\n$$\n- **Computational Method**: A $k$-dimensional tree (K-D tree) must be used for neighbor searching. The search is a radius query of radius $2h_i$ around each particle $\\mathbf{r}_i$.\n- **Outputs per particle**:\n    1. SPH density $\\rho_i$, including self-contribution.\n    2. Neighbor count $|\\mathcal{N}_i|$ from the radius query, where the condition is $r \\le 2h_i$.\n- **Constants and Units**: Positions in kiloparsec (kpc), masses in solar masses ($\\text{M}_\\odot$), smoothing lengths in kpc. Densities must be in $\\text{M}_\\odot/\\text{kpc}^3$.\n- **Test Cases**:\n    - **Case 1**: positions $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$, masses $m = [\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$, uniform smoothing length $h=0.5$.\n    - **Case 2**: positions $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$, masses $m = [\\,1.0,\\,1.0\\,]$, uniform smoothing length $h=0.2$.\n    - **Case 3**: positions $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$, masses $m = [\\,1.0,\\,2.0,\\,1.0\\,]$, per-particle smoothing lengths $h = [\\,0.5,\\,0.3,\\,0.7\\,]$.\n- **Output Formatting**: A single-line string representing a nested list: $[\\,[\\,[\\text{densities}_1], [\\text{counts}_1]\\,], \\dots\\,]$. Densities are to be rounded to $6$ decimal places.\n\n**Step 2: Validate Using Extracted Givens**\n- **Scientific Grounding**: The problem is well-grounded in computational astrophysics. SPH is a standard numerical method. The cubic spline kernel is a conventional choice with well-understood properties. The use of a K-D tree for neighbor finding is canonical for optimizing SPH calculations.\n- **Well-Posedness**: The problem is mathematically and algorithmically well-posed. The inputs are fully specified. The function to be computed is defined without ambiguity. A unique result exists for the given inputs and prescribed methodology.\n- **Objectivity**: The problem is stated using precise, objective, and formal language.\n\nThe problem formulation is complete, consistent, and scientifically sound. No flaws are identified.\n\n**Step 3: Verdict and Action**\nThe problem is valid. A solution will be constructed.\n\n**Principle-Based Design and Solution**\n\nThe objective is to compute the mass density field as sampled by a set of discrete particles. In Smoothed Particle Hydrodynamics (SPH), any continuous field $A(\\mathbf{r})$ is approximated by a convolution with a smoothing kernel $W$. The particle approximation of the density $\\rho(\\mathbf{r}_i)$ at the position of particle $i$ is given by the summation:\n$$\n\\rho_i = \\rho(\\mathbf{r}_i) \\approx \\sum_{j=1}^{N} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)\n$$\nwhere $\\mathbf{r}_i$ and $\\mathbf{r}_j$ are the position vectors of particles $i$ and $j$, $m_j$ is the mass of particle $j$, $N$ is the total number of particles, and $W$ is the smoothing kernel with a characteristic smoothing length $h_i$ associated with particle $i$.\n\nThe specified kernel, the three-dimensional cubic spline, is defined as a function of the dimensionless distance $q = r/h$, where $r = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$. The crucial property of this kernel is its *compact support*. The definition explicitly states that $W(r,h) = 0$ for $q \\ge 2$, which is equivalent to $r \\ge 2h$. This means that only particles within a distance of $2h_i$ from particle $i$ can have a non-zero contribution to its density. Consequently, the summation over all $N$ particles can be restricted to a sum over only the \"neighbor\" particles within this support radius:\n$$\n\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i), \\quad \\text{where } \\mathcal{N}_i = \\{j \\mid \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert \\le 2h_i\\}\n$$\nThe problem specifies the neighbor search condition as $r \\le 2h_i$. Since the kernel is zero for $q=2$ ($r=2h_i$), including particles exactly on the boundary of the support radius does not alter the density value, but it is necessary for correctly counting the number of neighbors as requested.\n\nA naive an all-pairs search to find neighbors for each particle would require approximately $N(N-1)/2$ distance calculations, leading to an overall computational complexity of $O(N^2)$. For large $N$, this is prohibitive. The problem mandates a more efficient approach using a $k$-dimensional tree (K-D tree). A K-D tree is a space-partitioning data structure for organizing points in a $k$-dimensional space. For our $3$-dimensional problem, it allows for efficient range queries (also known as ball queries). By constructing a K-D tree on the set of particle positions $\\{\\mathbf{r}_j\\}$, we can, for each particle $i$, query the tree to find all particles within a sphere of radius $R_i = 2h_i$ centered at $\\mathbf{r}_i$. This operation is significantly faster than $O(N^2)$, with an average-case complexity closer to $O(N \\log N)$ for building the tree and performing all queries.\n\nThe algorithm is therefore as follows:\n1.  For each test case, take the particle positions and construct a K-D tree. The `scipy.spatial.KDTree` class is suitable for this purpose.\n2.  Initialize empty lists to store the final computed densities and neighbor counts for the current test case.\n3.  Iterate through each particle $i$ from $0$ to $N-1$.\n    a. Identify the smoothing length $h_i$ for the current particle. For test case $3$, this is particle-specific; for cases $1$ and $2$, it is a uniform value for all particles.\n    b. Define the support radius $R_i = 2h_i$.\n    c. Use the K-D tree's `query_ball_point` method with the position $\\mathbf{r}_i$ and radius $R_i$ to find the indices of all neighbor particles, including particle $i$ itself.\n    d. The number of neighbors, $|\\mathcal{N}_i|$, is the length of the list of indices returned by the query. Store this integer value.\n    e. Initialize the density for particle $i$, $\\rho_i$, to $0.0$.\n    f. Iterate through the indices $j$ of the neighbor particles found in step 3c.\n        i.  Retrieve the mass $m_j$ and position $\\mathbf{r}_j$ of the neighbor particle.\n        ii. Calculate the distance $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$.\n        iii. Calculate the dimensionless distance $q = r_{ij} / h_i$. Note that when $h_i=0$, this would be undefined, but the problem provides only positive smoothing lengths.\n        iv. Evaluate the kernel function $W(r_{ij}, h_i)$ using its piecewise definition based on the value of $q$. The normalization factor $\\frac{1}{\\pi h_i^3}$ must be included.\n        v. Add the contribution $m_j W(r_{ij}, h_i)$ to $\\rho_i$.\n    g. After iterating through all neighbors, store the final value of $\\rho_i$.\n4.  After processing all particles in the test case, collect the list of densities and the list of neighbor counts into a single structure for the case.\n5.  Repeat for all test cases and format the final output as specified.\n\nThis procedure correctly implements the SPH density calculation using an efficient K-D tree for neighbor finding, respecting the compact support of the cubic spline kernel and handling both uniform and variable smoothing lengths. The boundary condition at $r=2h$, as highlighted in test case $2$, is correctly managed: the particle is counted as a neighbor but its contribution to density is zero.", "answer": "```python\nimport numpy as np\nfrom scipy.spatial import KDTree\n\ndef solve():\n    \"\"\"\n    Solves the SPH density calculation problem for the specified test suite.\n    \"\"\"\n\n    # Fully specified test suite\n    test_suite = [\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.3, 0.0, 0.0], [0.0, 0.4, 0.0],\n                [0.0, 0.0, 0.5], [1.2, 0.0, 0.0]\n            ]),\n            \"masses\": np.array([1.0, 1.0, 2.0, 1.0, 1.0]),\n            \"h_values\": 0.5\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.4, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 1.0]),\n            \"h_values\": 0.2\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.6, 0.0, 0.0], [1.3, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 2.0, 1.0]),\n            \"h_values\": np.array([0.5, 0.3, 0.7])\n        }\n    ]\n\n    def kernel_3d_cubic_spline(r, h):\n        \"\"\"\n        Computes the value of the 3D cubic spline smoothing kernel.\n        \n        Args:\n            r (float): The distance between particles.\n            h (float): The smoothing length.\n\n        Returns:\n            float: The kernel value W(r, h).\n        \"\"\"\n        if h <= 0:\n            return 0.0\n\n        sigma = 1.0 / (np.pi * h**3)\n        q = r / h\n        \n        if 0 <= q < 1:\n            return sigma * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n        elif 1 <= q < 2:\n            return sigma * (0.25 * (2.0 - q)**3)\n        else: # q >= 2\n            return 0.0\n\n    all_results = []\n\n    for case in test_suite:\n        positions = case[\"positions\"]\n        masses = case[\"masses\"]\n        h_values_input = case[\"h_values\"]\n        num_particles = len(positions)\n\n        # Handle both uniform and per-particle smoothing lengths\n        if isinstance(h_values_input, (int, float)):\n            h_values = np.full(num_particles, h_values_input)\n        else:\n            h_values = h_values_input\n\n        # Build the K-D tree on particle positions\n        kdtree = KDTree(positions)\n\n        case_densities = []\n        case_neighbor_counts = []\n\n        for i in range(num_particles):\n            pos_i = positions[i]\n            h_i = h_values[i]\n            \n            # Query for neighbors within the compact support radius 2*h_i\n            # The query condition is r <= 2*h_i\n            support_radius = 2.0 * h_i\n            neighbor_indices = kdtree.query_ball_point(pos_i, r=support_radius)\n            \n            neighbor_count = len(neighbor_indices)\n            case_neighbor_counts.append(neighbor_count)\n            \n            # Calculate SPH density\n            density_i = 0.0\n            for j in neighbor_indices:\n                pos_j = positions[j]\n                mass_j = masses[j]\n                \n                # Calculate distance between particles i and j\n                distance_rij = np.linalg.norm(pos_i - pos_j)\n                \n                # Calculate kernel contribution and add to density\n                kernel_val = kernel_3d_cubic_spline(distance_rij, h_i)\n                density_i += mass_j * kernel_val\n            \n            case_densities.append(round(density_i, 6))\n            \n        all_results.append([case_densities, case_neighbor_counts])\n\n    # Format the final output string exactly as required\n    # Creates a string representation like \"[[[...],[...]],[[...],[...]]]\"\n    # using the list's default str conversion, which is then joined.\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2416285"}, {"introduction": "Having practiced the core components of SPH, it is time to assemble them into a complete simulation. This exercise guides you in developing a two-dimensional SPH code to model a self-gravitating, rotating gas cloud, incorporating both pressure and gravitational forces [@problem_id:2439484]. The ultimate test of any numerical physics simulation lies in its ability to uphold fundamental conservation laws. You will verify your implementation by tracking the total angular momentum of the system, which must be conserved in the absence of external torques. This practice not only provides experience in building a full simulation but also instills the critical skill of code verification.", "problem": "You are to write a complete, runnable program that numerically evolves a two-dimensional, self-gravitating gas cloud using Smoothed Particle Hydrodynamics (SPH) in nondimensional units and analyzes the conservation of total angular momentum. Work in nondimensional units with gravitational constant $G=1$. Consider a barotropic gas with pressure given by $P(\\rho) = c_s^2 \\rho$, where $c_s$ is a constant sound speed, and treat self-gravity via Newtonian pairwise attraction with a softening length $\\epsilon$.\n\nLet there be $N$ particles in the plane with equal masses $m_i = M/N$, total mass $M=1$, positions $\\vec{r}_i(t) \\in \\mathbb{R}^2$, and velocities $\\vec{v}_i(t) \\in \\mathbb{R}^2$. The total angular momentum about the origin is\n$$\n\\vec{L}(t) = \\sum_{i=1}^{N} m_i \\, \\vec{r}_i(t) \\times \\vec{v}_i(t),\n$$\nwhere the cross product is the standard three-dimensional cross product; in two dimensions, its magnitude corresponds to the out-of-plane component. Evolve the system under the Euler momentum equation with the stated equation of state and self-gravity. Assume no external forces and no physical viscosity. Initialize the particles at $t=0$ as described in each test case below.\n\nYour task is to numerically integrate the equations of motion from $t=0$ to $t=T$ for each test case, track the magnitude $|\\vec{L}(t)|$ at discrete times including the initial and all subsequent time steps, and compute the following diagnostic for each case:\n- If $|\\vec{L}(0)| > 0$, report\n$$\n\\max_{0 \\le t \\le T} \\frac{\\left|\\,|\\vec{L}(t)| - |\\vec{L}(0)|\\,\\right|}{|\\vec{L}(0)|}.\n$$\n- If $|\\vec{L}(0)| = 0$, report\n$$\n\\max_{0 \\le t \\le T} |\\vec{L}(t)|.\n$$\n\nUse the following test suite. In all cases, place particles uniformly on a circle of radius $R$ centered at the origin, at polar angles $\\theta_k = 2\\pi k/N$ for $k \\in \\{0,1,\\dots,N-1\\}$, with positions $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$. Set initial velocities to solid-body rotation with angular speed $\\Omega$ about the origin, $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$.\n\nTest suite (each tuple lists $(N, R, \\Omega, c_s, h, \\epsilon, T, \\Delta t)$):\n1. $(N=32, R=1.0, \\Omega=0.5, c_s=0.05, h=0.2, \\epsilon=0.02, T=2.0, \\Delta t=0.002)$\n2. $(N=1, R=1.0, \\Omega=1.0, c_s=0.0, h=0.1, \\epsilon=0.0, T=1.0, \\Delta t=0.005)$\n3. $(N=32, R=1.0, \\Omega=0.0, c_s=0.05, h=0.2, \\epsilon=0.02, T=1.0, \\Delta t=0.002)$\n\nFor each test case, use SPH to model pressure forces and pairwise softened Newtonian gravity to model self-gravity. You must use a spherically symmetric, compactly supported smoothing kernel with smoothing length $h$ and compute densities via standard SPH density summation, and compute pressure forces using a momentum-conserving symmetric form. Gravitational softening must be implemented so that the pairwise gravitational force between particles $i$ and $j$ is proportional to $(\\vec{r}_i - \\vec{r}_j)/\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}$.\n\nYour program must produce a single line of output containing the three diagnostic values for the three test cases, in order, as a comma-separated list enclosed in square brackets. For example, the output format must be exactly like:\n[diagnostic_case1,diagnostic_case2,diagnostic_case3]\nAll quantities are nondimensional; do not include any units in the output.", "solution": "We need to evolve a two-dimensional, self-gravitating, barotropic gas without external torques and analyze angular momentum conservation. The fundamental physical principle governing angular momentum is that, for a closed system subject only to internal forces that are central and pairwise antisymmetric, the total torque is zero, yielding conservation of total angular momentum. In continuous form, for a system of particles, the time derivative of the total angular momentum is\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\vec{a}_i.\n$$\nIf the forces are sums of pairwise internal forces $m_i \\vec{a}_i = \\sum_{j\\ne i} \\vec{F}_{ij}$ with $\\vec{F}_{ij} = -\\vec{F}_{ji}$ and each $\\vec{F}_{ij}$ parallel to $(\\vec{r}_i - \\vec{r}_j)$, then the total torque\n$$\n\\sum_{i=1}^{N} \\vec{r}_i \\times \\sum_{j\\ne i} \\vec{F}_{ij} = \\frac{1}{2} \\sum_{i\\ne j} (\\vec{r}_i - \\vec{r}_j) \\times \\vec{F}_{ij} = \\vec{0},\n$$\nbecause $(\\vec{r}_i - \\vec{r}_j)$ is parallel to $\\vec{F}_{ij}$ for central forces and their cross product is zero. Hence, in the absence of external torques and non-central forces, $\\vec{L}(t)$ is conserved exactly in the continuous system.\n\nSmoothed Particle Hydrodynamics (SPH) represents the pressure force as a sum of pairwise interactions that, in a symmetric, momentum-conserving discretization, are antisymmetric and central. The density at particle $i$ is estimated by the summation\n$$\n\\rho_i = \\sum_{j=1}^{N} m_j W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\nwhere $W$ is a spherically symmetric kernel with compact support and smoothing length $h$. The barotropic pressure is $P_i = c_s^2 \\rho_i$. A symmetric SPH representation of the pressure acceleration that respects linear and angular momentum conservation is\n$$\n\\vec{a}_i^{\\mathrm{(P)}} = - \\sum_{j=1}^{N} m_j \\left( \\frac{P_i}{\\rho_i^2} + \\frac{P_j}{\\rho_j^2} \\right) \\nabla W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\nwhere, due to spherical symmetry of $W$, $\\nabla W$ is parallel to $(\\vec{r}_i - \\vec{r}_j)$, ensuring that each pairwise contribution is central and antisymmetric. Self-gravity is modeled by Newtonian attraction with softening length $\\epsilon$:\n$$\n\\vec{a}_i^{\\mathrm{(G)}} = - G \\sum_{j\\ne i} m_j \\frac{\\vec{r}_i - \\vec{r}_j}{\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}}.\n$$\nThis is also a sum of pairwise central forces. Therefore, in exact arithmetic, the total angular momentum is conserved:\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\left( \\vec{a}_i^{\\mathrm{(P)}} + \\vec{a}_i^{\\mathrm{(G)}} \\right) = \\vec{0}.\n$$\n\nIn a numerical simulation, discretization and time-integration errors introduce small deviations. To minimize secular drift and preserve invariants in Hamiltonian-like systems, a symplectic second-order integrator such as velocity Verlet can be used. Given positions $\\vec{r}_i^n$, velocities $\\vec{v}_i^n$, and accelerations $\\vec{a}_i^n$ at time $t_n$, velocity Verlet advances by\n$$\n\\vec{r}_i^{n+1} = \\vec{r}_i^{n} + \\vec{v}_i^{n} \\Delta t + \\frac{1}{2} \\vec{a}_i^{n} \\Delta t^2,\n$$\n$$\n\\vec{a}_i^{n+1} = \\vec{a}_i\\big(\\{\\vec{r}_j^{n+1}\\}\\big),\n$$\n$$\n\\vec{v}_i^{n+1} = \\vec{v}_i^{n} + \\frac{1}{2}\\left(\\vec{a}_i^{n} + \\vec{a}_i^{n+1}\\right) \\Delta t,\n$$\nwhere $\\vec{a}_i(\\{\\vec{r}_j\\})$ is computed from the SPH pressure and gravitational interactions at the current positions. At each discrete time, the angular momentum magnitude is\n$$\n|\\vec{L}(t_n)| = \\left| \\sum_{i=1}^{N} m_i \\, \\vec{r}_i^n \\times \\vec{v}_i^n \\right|.\n$$\n\nAlgorithmic design for the program:\n1. For each test case, initialize $N$ particles on a circle of radius $R$ with equal masses $m_i = 1/N$ at angles $\\theta_k = 2\\pi k/N$ and positions $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$. Set velocities $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$, which correspond to solid-body rotation with angular speed $\\Omega$.\n2. At each time step, compute densities via SPH summation using a spherically symmetric, compact kernel. Then compute pressures $P_i = c_s^2 \\rho_i$ and the pressure accelerations via the symmetric SPH force expression. Compute gravitational accelerations using the softened Newtonian formula with $G=1$ and the given $\\epsilon$.\n3. Advance positions and velocities with the velocity Verlet scheme over $T$ with time step $\\Delta t$.\n4. Track $|\\vec{L}(t)|$ from $t=0$ through all time steps. For cases with $|\\vec{L}(0)| > 0$, compute the maximum relative deviation $\\max_t \\big||\\vec{L}(t)| - |\\vec{L}(0)|\\big|/|\\vec{L}(0)|$. For cases with $|\\vec{L}(0)| = 0$, compute $\\max_t |\\vec{L}(t)|$.\n5. Output the three diagnostic values in a single line as a comma-separated list enclosed in square brackets, in the order of the test cases.\n\nExpected qualitative outcomes:\n- For the rotating, self-gravitating cloud with $N=32$, $R=1.0$, and $\\Omega=0.5$, internal SPH pressure forces and gravity are central and pairwise symmetric, so the total angular momentum should be conserved up to small integration and discretization errors; thus the maximum relative deviation should be small.\n- For the single free particle ($N=1$) with $\\Omega=1.0$, there are no internal forces, so $\\vec{a}=\\vec{0}$ and $\\vec{L}(t)$ is exactly constant; numerically, any deviation arises from floating-point arithmetic and should be extremely small.\n- For the non-rotating cloud ($\\Omega=0.0$), the initial angular momentum magnitude is zero; by symmetry and central forces, it should remain near zero, so the maximum magnitude should be small.\n\nThese computations stem directly from Newtonian mechanics, the Euler equations for a barotropic fluid, and the SPH discretization that preserves the antisymmetry and central nature of pairwise internal forces, thereby conserving angular momentum in the absence of external torques.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numpy print options (not strictly necessary, but consistent output)\nnp.set_printoptions(precision=10, floatmode='maxprec')\n\ndef cubic_spline_W_2d(r, h):\n    \"\"\"\n    2D cubic spline (M4) kernel value W(r,h).\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    W = np.zeros_like(r)\n    mask1 = (q >= 0) & (q < 1)\n    mask2 = (q >= 1) & (q < 2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    W[mask1] = 1 - 1.5*q1*q1 + 0.75*q1*q1*q1\n    W[mask2] = 0.25 * (2 - q2)**3\n    return sigma * W\n\ndef cubic_spline_dW_dr_2d(r, h):\n    \"\"\"\n    Derivative dW/dr for 2D cubic spline kernel.\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    dW_dq = np.zeros_like(r)\n    mask1 = (q >= 0) & (q < 1)\n    mask2 = (q >= 1) & (q < 2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    # d/dq of 1 - 1.5 q^2 + 0.75 q^3 is -3 q + 2.25 q^2\n    dW_dq[mask1] = -3.0*q1 + 2.25*q1*q1\n    # d/dq of 0.25 (2 - q)^3 is -0.75 (2 - q)^2\n    dW_dq[mask2] = -0.75 * (2 - q2)**2\n    # dW/dr = (dW/dq) * (1/h) * sigma\n    return sigma * dW_dq / h\n\ndef compute_densities(positions, masses, h):\n    \"\"\"\n    Compute SPH densities by direct summation using the 2D cubic spline kernel.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n    W = cubic_spline_W_2d(dist, h)     # (N,N)\n    rho = W @ masses  # (N,)\n    return rho\n\ndef compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0):\n    \"\"\"\n    Compute accelerations from SPH pressure forces and softened self-gravity.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    N = positions.shape[0]\n    # Density and pressure\n    rho = compute_densities(positions, masses, h)\n    P = (cs * cs) * rho\n\n    # Pairwise vectors\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n\n    # Kernel gradient\n    dW_dr = cubic_spline_dW_dr_2d(dist, h)  # (N,N)\n    # Avoid division by zero\n    inv_r = 1.0 / (dist + 1e-16)\n    gradW = (dW_dr * inv_r)[..., None] * dx  # (N,N,2)\n\n    # Symmetric pressure force factor: (P_i/rho_i^2 + P_j/rho_j^2)\n    # Build matrices via broadcasting\n    Pi_over_rhoi2 = (P / (rho * rho + 1e-30))  # (N,)\n    Pj_over_rhoj2 = Pi_over_rhoi2              # same array, but we'll broadcast\n    term_ij = Pi_over_rhoi2[:, None] + Pj_over_rhoj2[None, :]  # (N,N)\n    # Multiply by masses of j\n    mj = masses[None, :]  # (1,N)\n    facP = term_ij * mj   # (N,N)\n\n    # Pressure acceleration\n    aP = -np.sum(facP[..., None] * gradW, axis=1)  # (N,2)\n\n    # Gravity: softened Newtonian\n    soft2 = eps_soft * eps_soft\n    inv_r3 = 1.0 / (dist*dist + soft2)**1.5  # (N,N)\n    # Exclude self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    aG = -G * np.sum((mj[..., None] * inv_r3[..., None]) * dx, axis=1)  # (N,2)\n\n    return aP + aG\n\ndef angular_momentum_z(positions, velocities, masses):\n    \"\"\"\n    Compute total angular momentum (z-component) for 2D system: Lz = sum m (x vy - y vx)\n    \"\"\"\n    x = positions[:, 0]\n    y = positions[:, 1]\n    vx = velocities[:, 0]\n    vy = velocities[:, 1]\n    Lz = np.sum(masses * (x * vy - y * vx))\n    return Lz\n\ndef simulate_case(N, R, Omega, cs, h, eps_soft, T, dt):\n    \"\"\"\n    Simulate one test case and return the diagnostic:\n    - If |L0| > 0: max_t | |L(t)| - |L0| | / |L0|\n    - If |L0| == 0: max_t |L(t)|\n    \"\"\"\n    # Initialize masses\n    M = 1.0\n    masses = np.full(N, M / N)\n    # Initialize positions on a circle\n    if N == 1:\n        thetas = np.array([0.0])\n    else:\n        thetas = 2.0 * np.pi * np.arange(N) / N\n    positions = np.column_stack([R * np.cos(thetas), R * np.sin(thetas)])\n    # Solid-body rotation velocities v = Omega * (-y, x)\n    velocities = Omega * np.column_stack([-positions[:, 1], positions[:, 0]])\n\n    # Initial acceleration\n    acc = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n\n    # Track angular momentum magnitude over time\n    L0 = angular_momentum_z(positions, velocities, masses)\n    L_mags = [abs(L0)]\n\n    steps = int(np.round(T / dt))\n    # Velocity Verlet integration\n    for _ in range(steps):\n        # r_{n+1} = r_n + v_n dt + 0.5 a_n dt^2\n        positions = positions + velocities * dt + 0.5 * acc * (dt * dt)\n        # a_{n+1}\n        acc_new = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n        # v_{n+1} = v_n + 0.5 (a_n + a_{n+1}) dt\n        velocities = velocities + 0.5 * (acc + acc_new) * dt\n        # Prepare for next step\n        acc = acc_new\n        # Record angular momentum magnitude\n        L_mags.append(abs(angular_momentum_z(positions, velocities, masses)))\n\n    L0_abs = abs(L0)\n    if L0_abs > 1e-14:\n        deviations = np.abs(np.array(L_mags) - L0_abs) / L0_abs\n        diagnostic = float(np.max(deviations))\n    else:\n        diagnostic = float(np.max(L_mags))\n    return diagnostic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, Omega, cs, h, eps, T, dt)\n        (32, 1.0, 0.5, 0.05, 0.2, 0.02, 2.0, 0.002),\n        (1,  1.0, 1.0, 0.0,  0.1, 0.0,  1.0, 0.005),\n        (32, 1.0, 0.0, 0.05, 0.2, 0.02, 1.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, Omega, cs, h, eps_soft, T, dt = case\n        result = simulate_case(N, R, Omega, cs, h, eps_soft, T, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2439484"}]}