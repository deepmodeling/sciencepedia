{"hands_on_practices": [{"introduction": "The heart of any Particle-in-Cell simulation is its central computational loop, which self-consistently models the interplay between charged particles and the fields they generate. This first practice [@problem_id:2424112] guides you through the implementation of a complete one-dimensional electrostatic PIC code from first principles. By building the essential components—charge deposition, field solving, and particle pushing—and incorporating a physically relevant photoionization source term, you will gain a foundational, hands-on understanding of how these complex plasma systems are modeled.", "problem": "Implement a one-dimensional, electrostatic Particle-In-Cell (PIC) method with periodic boundary conditions that includes a photoionization source term producing new electron-ion pairs uniformly in space from a stationary, uniform neutral gas. The algorithm must be self-consistent: charges are deposited to a grid, the electric field is obtained from Gauss’s law, and particles are pushed by the Lorentz force specialized to electrostatics. New electron-ion pairs are created stochastically each time step according to a deterministic rate law and a fixed random seed.\n\nFundamental base:\n- Use Newton’s second law for each charged particle, $m \\, dv/dt = q \\, E(x,t)$, and kinematics $dx/dt = v$.\n- Use Gauss’s law in one dimension under electrostatic conditions, $\\partial E/\\partial x = \\rho/\\varepsilon_0$, with periodic boundary conditions on a domain of length $L$.\n- The source term for photoionization is a uniform volumetric pair-creation rate $S$ defined by $S = \\sigma \\, \\Phi \\, n_n$, where $\\sigma$ is the photoionization cross section, $\\Phi$ is the photon flux, and $n_n$ is the neutral gas number density. Per time step $\\Delta t$, the expected number of real pairs created in the domain of length $L$ (assuming unit cross-sectional area) is $S \\, L \\, \\Delta t$.\n- Use macro-particles of weight $W$ such that each macro-particle represents $W$ real particles. Therefore, the expected number of macro-pairs per time step is $\\mu = (S \\, L \\, \\Delta t)/W$.\n\nNumerical specification:\n- Represent the one-dimensional domain of length $L$ with $N_g$ uniformly spaced grid nodes and periodic boundary conditions.\n- Deposit charge density $\\rho(x)$ to the grid using a consistent first-order (cloud-in-cell) scheme from electron and ion macro-particles. For electrons use charge $q_e = -e \\, W$ per macro-particle, and for ions use charge $q_i = +e \\, W$ per macro-particle, where $e$ is the elementary charge. Divide by the cell volume $V_{\\text{cell}} = \\Delta x$ (unit cross-sectional area) so that $\\rho$ has units of $\\mathrm{C/m^3}$.\n- Solve for the electric field $E(x)$ such that $\\partial E/\\partial x = \\rho/\\varepsilon_0$ under periodic boundary conditions. Maintain the periodic solvability condition by enforcing zero mean of $E(x)$.\n- Interpolate $E(x)$ from the grid back to particle positions using the same first-order shape function used for charge deposition.\n- Advance particle velocities and positions using a time-centered leapfrog scheme:\n  - $v^{n+1/2} = v^{n-1/2} + (q/m) \\, E(x^n) \\, \\Delta t$\n  - $x^{n+1} = x^n + v^{n+1/2} \\, \\Delta t$\n  Impose periodic boundary conditions on positions.\n- At each time step, create new macro electron-ion pairs:\n  - Compute $\\mu = (S \\, L \\, \\Delta t)/W$ with $S = \\sigma \\, \\Phi \\, n_n$.\n  - Generate the actual number of new macro-pairs by probabilistic rounding: let $n_{\\text{base}} = \\lfloor \\mu \\rfloor$ and $f = \\mu - \\lfloor \\mu \\rfloor$. Add one more pair with probability $f$. Use independent, uniformly distributed random positions in $[0,L)$ for the new pairs, and set their initial leapfrog velocities to zero. Use a fixed pseudorandom number generator seed of $42$ so that results are reproducible.\n\nPhysical constants to use (in the International System of Units):\n- Elementary charge $e = 1.602176634 \\times 10^{-19}\\,\\mathrm{C}$.\n- Electron mass $m_e = 9.1093837015 \\times 10^{-31}\\,\\mathrm{kg}$.\n- Ion mass $m_i = 6.6335209 \\times 10^{-26}\\,\\mathrm{kg}$ (representative of singly ionized argon).\n- Vacuum permittivity $\\varepsilon_0 = 8.8541878128 \\times 10^{-12}\\,\\mathrm{F/m}$.\n\nInitialization and boundary conditions:\n- Start with no charged particles in the domain.\n- Use periodic boundary conditions for both fields and particles.\n- Use unit cross-sectional area so that the effective domain volume is $L$.\n\nTask:\n- Implement the algorithm above and run it for the specified test suite below.\n- For each test case, after advancing exactly $N_t$ time steps, report the total number of macro-electrons present (an integer count). There is no need to report positions, velocities, or fields.\n- Angles do not appear in this problem.\n- No physical units are required in the final results since the outputs are counts (dimensionless).\n\nTest suite (each tuple encodes $(L, N_g, \\Delta t, N_t, \\sigma, \\Phi, n_n, W)$):\n1. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$.\n2. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 0.0\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 5.0\\times 10^{4})$.\n3. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 2.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 1.0\\times 10^{21}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 2.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 2.0\\times 10^{5})$.\n4. $(L = 0.1\\,\\mathrm{m}, N_g = 64, \\Delta t = 1.0\\times 10^{-11}\\,\\mathrm{s}, N_t = 50, \\sigma = 1.0\\times 10^{-22}\\,\\mathrm{m}^2, \\Phi = 5.0\\times 10^{20}\\,\\mathrm{m}^{-2}\\mathrm{s}^{-1}, n_n = 1.0\\times 10^{19}\\,\\mathrm{m}^{-3}, W = 1.0\\times 10^{7})$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[x_1,x_2,x_3,x_4]$), where each $x_i$ is the final number of macro-electrons for test case $i$ as an integer.", "solution": "The problem presented is a well-posed and scientifically sound task in computational plasma physics. It requires the implementation of a one-dimensional electrostatic Particle-In-Cell (PIC) code. The model includes periodic boundary conditions and a photoionization source term, which introduces new electron-ion pairs into the simulation domain over time. The problem is self-contained, providing all necessary physical laws, numerical methods, physical constants, and test parameters. It is free of contradictions or vagaries. Therefore, we proceed with a full solution.\n\nThe core of the algorithm is the PIC cycle, which self-consistently models the interaction between charged particles and the electric field they collectively generate. This cycle is executed at each discrete time step, $\\Delta t$. We begin with a description of the discretized domain and then detail each step of the PIC cycle.\n\n**System Discretization**\n\nThe one-dimensional spatial domain of length $L$ is discretized into $N_g$ grid cells of uniform width $\\Delta x = L/N_g$. The grid nodes are located at positions $x_j = j \\Delta x$ for $j = 0, 1, \\dots, N_g-1$. Physical quantities defined on the grid, such as charge density $\\rho$ and electric field $E$, are discretized at these nodes. The simulation advances in discrete time steps of duration $\\Delta t$.\n\n**The Particle-In-Cell (PIC) Cycle**\n\nThe simulation starts with no charged particles. At each time step $n$, the following sequence of operations is performed for a total of $N_t$ steps.\n\n**1. Source Term: Particle Creation**\nThe photoionization of a stationary neutral gas creates new electron-ion pairs. The volumetric creation rate is given as $S = \\sigma \\Phi n_n$, where $\\sigma$ is the photoionization cross-section, $\\Phi$ is the photon flux, and $n_n$ is the neutral gas density. For the one-dimensional domain of length $L$ and unit cross-sectional area, the total number of real pairs created per time step $\\Delta t$ is $S L \\Delta t$.\n\nEach computational macro-particle represents $W$ real particles. Thus, the expected number of new macro-pairs to be created in one time step is:\n$$\n\\mu = \\frac{S L \\Delta t}{W}\n$$\nTo ensure a statistically correct injection rate, we employ probabilistic rounding. The number of pairs created in a given time step, $N_{\\text{new}}$, is determined as:\n$$\nN_{\\text{new}} = \\lfloor \\mu \\rfloor + \\begin{cases} 1 & \\text{with probability } f \\\\ 0 & \\text{with probability } 1-f \\end{cases}\n$$\nwhere $f = \\mu - \\lfloor \\mu \\rfloor$ is the fractional part of $\\mu$. This is implemented by drawing a random number $r$ from a uniform distribution on $[0, 1)$ and adding an extra pair if $r < f$. A fixed random seed ensures reproducibility. For each new pair, an electron and an ion are created at the same random position $x_{\\text{new}}$, drawn uniformly from $[0, L)$. Their initial velocities, required for the leapfrog integrator, are set to zero.\n\n**2. Charge Deposition (Scatter)**\nThe continuous charge distribution of the plasma is represented by a discrete set of macro-particles. The charge of these particles must be deposited onto the grid to compute the charge density $\\rho_j$. We use the first-order, or Cloud-in-Cell (CIC), weighting scheme.\n\nFor a particle $p$ with charge $q_p$ located at position $x_p$, we first identify the index of the grid node to its immediate left, $j = \\lfloor x_p / \\Delta x \\rfloor$. The particle's charge is distributed between this node and the adjacent node to the right, $j+1$ (with periodic wrap-around, i.e., index $(j+1) \\pmod{N_g}$). The fractions of charge assigned to each node are determined by linear weighting. Let $h = (x_p/\\Delta x) - j$ be the normalized distance from the left node. The charge contributions are:\n$$\n\\delta \\rho'_{j} = q_p (1-h)\n$$\n$$\n\\delta \\rho'_{(j+1) \\pmod{N_g}} = q_p h\n$$\nThe total charge on each grid node, $\\rho'_j$, is the sum of contributions from all particles (electrons and ions, with $q_e = -eW$ and $q_i = +eW$). The charge density $\\rho_j$ at node $j$ is then found by dividing by the cell volume, which in our one-dimensional case with unit area is just the cell width $\\Delta x$:\n$$\n\\rho_j = \\frac{\\rho'_j}{\\Delta x}\n$$\n\n**3. Field Solver**\nWith the charge density $\\rho_j$ known on the grid, we solve for the electric field $E_j$ using the one-dimensional Gauss's law under electrostatic conditions:\n$$\n\\frac{\\partial E}{\\partial x} = \\frac{\\rho}{\\varepsilon_0}\n$$\nFor a periodic domain, a spectral method using the Fast Fourier Transform (FFT) is highly efficient and accurate. In Fourier space, the spatial derivative $\\partial/\\partial x$ becomes a multiplication by $ik$, where $k$ is the wavenumber. Transforming Gauss's law gives:\n$$\nik \\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{\\varepsilon_0}\n$$\nwhere $\\hat{E}(k)$ and $\\hat{\\rho}(k)$ are the Fourier transforms of the electric field and charge density, respectively.\n\nWe can solve for the Fourier components of the electric field:\n$$\n\\hat{E}(k) = \\frac{\\hat{\\rho}(k)}{ik\\varepsilon_0} = -i \\frac{\\hat{\\rho}(k)}{k\\varepsilon_0}, \\quad \\text{for } k \\neq 0\n$$\nFor the $k=0$ (DC) component, the denominator is zero. The solvability condition for the periodic system requires the net charge in the domain to be zero, which implies $\\hat{\\rho}(k=0) = 0$. This condition is satisfied here because we always create electron-ion pairs, maintaining charge neutrality. The problem specifies that the mean electric field must be zero, which corresponds to setting $\\hat{E}(k=0) = 0$.\n\nThe numerical procedure is:\n1. Compute the discrete Fourier transform of the charge density: $\\hat{\\rho}_m = \\text{FFT}(\\rho_j)$.\n2. For each discrete wavenumber $k_m$ (where $m$ is the frequency index), compute $\\hat{E}_m$. Set $\\hat{E}_0 = 0$.\n3. Compute the inverse Fourier transform to obtain the electric field on the grid: $E_j = \\text{IFFT}(\\hat{E}_m)$. The result must be real, so any small imaginary part due to numerical error is discarded.\n\n**4. Field Interpolation (Gather)**\nTo update the particle velocities, the electric field must be evaluated at each particle's position $x_p$. This is achieved by interpolating the grid-based field $E_j$ back to the particle positions. To ensure conservation of momentum and prevent self-forces, the interpolation scheme must be consistent with the charge deposition scheme. We therefore use the same first-order (CIC) weighting:\n$$\nE(x_p) = E_j (1-h) + E_{(j+1) \\pmod{N_g}} h\n$$\nwhere $j = \\lfloor x_p / \\Delta x \\rfloor$ and $h = (x_p/\\Delta x) - j$ are the same as in the deposition step.\n\n**5. Particle Pusher**\nThe motion of each particle is governed by Newton's second law, with the force given by the Lorentz force, which in this electrostatic case simplifies to $F = qE$. The equations of motion are:\n$$\n\\frac{d\\vec{v}}{dt} = \\frac{q}{m} \\vec{E}, \\quad \\frac{d\\vec{x}}{dt} = \\vec{v}\n$$\nThese equations are integrated using the time-centered leapfrog algorithm, known for its long-term stability and second-order accuracy. Velocities are defined at half-integer time steps ($t^{n-1/2}, t^{n+1/2}, \\dots$) and positions at integer time steps ($t^n, t^{n+1}, \\dots$). The update rules are:\n$$\nv_p^{n+1/2} = v_p^{n-1/2} + \\frac{q_p}{m_p} E(x_p^n) \\Delta t\n$$\n$$\nx_p^{n+1} = x_p^n + v_p^{n+1/2} \\Delta t\n$$\nAfter the position is updated, periodic boundary conditions are applied: $x_p^{n+1} \\leftarrow x_p^{n+1} \\pmod L$. This completes one cycle of the PIC algorithm. The entire process is repeated for $N_t$ time steps. The final required output is the total number of macro-electrons in the simulation at the end.", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the 1D electrostatic PIC simulation.\n    \"\"\"\n    test_cases = [\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 0.0, 1.0e19, 5.0e4),\n        (0.1, 64, 1.0e-11, 50, 2.0e-22, 1.0e21, 2.0e19, 2.0e5),\n        (0.1, 64, 1.0e-11, 50, 1.0e-22, 5.0e20, 1.0e19, 1.0e7),\n    ]\n\n    results = []\n    for params in test_cases:\n        final_electron_count = run_pic_simulation(*params)\n        results.append(final_electron_count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_pic_simulation(L, N_g, dt, N_t, sigma, Phi, n_n, W):\n    \"\"\"\n    Executes a one-dimensional electrostatic Particle-In-Cell simulation.\n\n    Args:\n        L (float): Domain length (m).\n        N_g (int): Number of grid nodes.\n        dt (float): Time step duration (s).\n        N_t (int): Total number of time steps.\n        sigma (float): Photoionization cross section (m^2).\n        Phi (float): Photon flux (m^-2 s^-1).\n        n_n (float): Neutral gas number density (m^-3).\n        W (float): Macro-particle weight.\n\n    Returns:\n        int: Total number of macro-electrons at the end of the simulation.\n    \"\"\"\n    # Physical constants\n    E_CHARGE = 1.602176634e-19\n    M_E = 9.1093837015e-31\n    M_I = 6.6335209e-26\n    EPS_0 = 8.8541878128e-12\n\n    # Grid parameters\n    dx = L / N_g\n\n    # Source term calculation\n    S = sigma * Phi * n_n\n    mu = (S * L * dt) / W\n    mu_base = int(mu)\n    mu_frac = mu - mu_base\n\n    # Pre-allocate particle arrays\n    # A safe upper bound for the number of particles is estimated\n    max_new_per_step = mu_base + 1\n    max_particles = max_new_per_step * N_t + 10 # Add a small buffer\n    \n    pos_e = np.zeros(max_particles)\n    vel_e = np.zeros(max_particles)\n    n_elec = 0\n    \n    pos_i = np.zeros(max_particles)\n    vel_i = np.zeros(max_particles)\n    n_ions = 0\n    \n    # Initialize random number generator with fixed seed\n    rng = np.random.default_rng(42)\n\n    # Pre-calculate FFT wavenumbers\n    k_fft = 2 * np.pi * fft.fftfreq(N_g, d=dx)\n    \n    # Main simulation loop\n    for _ in range(N_t):\n        # 1. Source: Create new particles\n        num_new = mu_base\n        if rng.random() < mu_frac:\n            num_new += 1\n\n        if num_new > 0:\n            # Add new electrons\n            start_idx_e = n_elec\n            end_idx_e = n_elec + num_new\n            pos_e[start_idx_e:end_idx_e] = rng.random(size=num_new) * L\n            vel_e[start_idx_e:end_idx_e] = 0.0 # Initial leapfrog velocity is zero\n            n_elec = end_idx_e\n\n            # Add new ions\n            start_idx_i = n_ions\n            end_idx_i = n_ions + num_new\n            pos_i[start_idx_i:end_idx_i] = pos_e[start_idx_e:end_idx_e] # Same position\n            vel_i[start_idx_i:end_idx_i] = 0.0\n            n_ions = end_idx_i\n\n        if n_elec == 0:\n            continue\n        \n        # Slices for active particles\n        active_pos_e = pos_e[:n_elec]\n        active_vel_e = vel_e[:n_elec]\n        active_pos_i = pos_i[:n_ions]\n        active_vel_i = vel_i[:n_ions]\n\n        # 2. Charge Deposition (Scatter)\n        rho_grid = np.zeros(N_g)\n\n        # Electrons\n        q_e = -E_CHARGE * W\n        norm_pos_e = active_pos_e / dx\n        i1_e = np.floor(norm_pos_e).astype(int)\n        h_e = norm_pos_e - i1_e\n        i2_e = (i1_e + 1) % N_g\n        np.add.at(rho_grid, i1_e, q_e * (1.0 - h_e))\n        np.add.at(rho_grid, i2_e, q_e * h_e)\n\n        # Ions\n        q_i = E_CHARGE * W\n        norm_pos_i = active_pos_i / dx\n        i1_i = np.floor(norm_pos_i).astype(int)\n        h_i = norm_pos_i - i1_i\n        i2_i = (i1_i + 1) % N_g\n        np.add.at(rho_grid, i1_i, q_i * (1.0 - h_i))\n        np.add.at(rho_grid, i2_i, q_i * h_i)\n        \n        rho_grid /= dx # Convert charge to charge density\n\n        # 3. Field Solve\n        rho_k = fft.fft(rho_grid)\n        E_k = np.zeros_like(rho_k)\n        \n        # Avoid division by zero for k=0\n        non_zero_k = k_fft != 0\n        E_k[non_zero_k] = -1j * rho_k[non_zero_k] / (k_fft[non_zero_k] * EPS_0)\n        \n        E_grid = np.real(fft.ifft(E_k))\n\n        # 4. Field Interpolation (Gather)\n        # Electrons\n        E_p_e = E_grid[i1_e] * (1.0 - h_e) + E_grid[i2_e] * h_e\n        # Ions\n        E_p_i = E_grid[i1_i] * (1.0 - h_i) + E_grid[i2_i] * h_i\n\n        # 5. Particle Push\n        # Electrons\n        active_vel_e += (q_e / M_E) * E_p_e * dt\n        active_pos_e += active_vel_e * dt\n        pos_e[:n_elec] = active_pos_e % L\n        \n        # Ions\n        active_vel_i += (q_i / M_I) * E_p_i * dt\n        active_pos_i += active_vel_i * dt\n        pos_i[:n_ions] = active_pos_i % L\n        \n    return n_elec\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424112"}, {"introduction": "A powerful simulation is not just about getting a result; it's about understanding the accuracy and limitations of the numerical methods employed. This practice [@problem_id:2424113] moves from implementation to analysis, tasking you with computing the discrete Green's function for an electrostatic field solver. This powerful diagnostic reveals how the discretized grid and particle shape functions cause the simulated force law to deviate from the true physical interaction, introducing numerical artifacts such as anisotropy that you will learn to quantify.", "problem": "You are tasked with developing a complete, runnable program that constructs and analyzes the Discrete Green’s Function for a three-dimensional electrostatic Particle-In-Cell (PIC) solver on a uniform Cartesian grid with periodic boundary conditions. Your PIC solver uses a second-order central-difference discretization of the Laplacian operator and solves Poisson’s equation in Fourier space.\n\nStart from the fundamental base: the electrostatic limit of Maxwell’s equations yields Poisson’s equation, $\\nabla^2 \\phi(\\mathbf{x}) = -\\rho(\\mathbf{x})/\\varepsilon_0$. On a uniform grid with spacing $h$ and periodic boundary conditions, the second-order discrete Laplacian approximates $\\nabla^2$. The discrete Green’s Function $G_d(\\mathbf{r})$ is defined as the potential response at grid points to a unit point charge placed at the origin, as computed by the specified discrete solver and grid. In Particle-In-Cell (PIC) methods, the finite particle size implied by the particle-to-grid assignment and the field-to-particle interpolation modifies the effective source and measurement in wave number space by the square of the Fourier transform of the chosen shape function.\n\nImplement the following in your program:\n\n1) Construct the discrete Green’s Function in three dimensions for a uniform periodic grid of size $N \\times N \\times N$, using the second-order central-difference Laplacian combined with a spectral (Discrete Fourier Transform) inversion of the Poisson equation. Enforce the zero-mean condition by setting the wave number zero mode to zero so that the potential is uniquely defined under periodic boundary conditions.\n\n2) Incorporate the effect of the particle shape. Use one-dimensional B-spline shape functions of order $m$ with Fourier transform $S_m(k) = \\left[\\operatorname{sinc}\\!\\left(\\frac{k h}{2}\\right)\\right]^{m+1}$, where $\\operatorname{sinc}(x) = \\frac{\\sin x}{x}$. Assume identical shape functions are used for both particle-to-grid deposition and grid-to-particle interpolation, so that the effective spectral response multiplies by $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$. Use $m=0$ for Nearest-Grid-Point (NGP) and $m=1$ for Cloud-In-Cell (CIC).\n\n3) Work in dimensionless lattice units to compare with the continuum Green’s function. Let $\\hat{\\mathbf{r}} = \\mathbf{r}/h$ be the lattice coordinate. Define the dimensionless discrete Green’s function $\\hat{G}_d(\\hat{\\mathbf{r}})$ via the inverse Discrete Fourier Transform of the effective spectral Green’s function. Compare $\\hat{G}_d(\\hat{\\mathbf{r}})$ to the continuum expression $\\hat{G}_c(\\hat{r}) = \\frac{1}{4\\pi \\hat{r}}$ (which corresponds to the physical $1/(4\\pi r)$ after appropriate scaling). All metrics you report must be dimensionless.\n\n4) Analyze anisotropy and deviation from the continuum:\n   - Group grid points into spherical shells by integer squared distance $s = i^2 + j^2 + k^2$, where $(i,j,k)$ are the shortest periodic displacements from the source. For each shell with radius $\\hat{r} = \\sqrt{s}$, compute:\n     a) The shell mean $\\overline{G}_s$ and shell standard deviation $\\sigma_s$ of $\\hat{G}_d$ values on that shell.\n     b) The shell anisotropy as $\\sigma_s / \\overline{G}_s$.\n     c) The shell relative error $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$.\n   - Consider only shells with $\\hat{r}_{\\min} < \\hat{r} < \\hat{r}_{\\max}$ to avoid the singular cell at the origin and to reduce the influence of periodic images. Use $\\hat{r}_{\\min} = 1.5$ and $\\hat{r}_{\\max} = N/4$.\n   - Report two global metrics per case: the maximum shell anisotropy and the root-mean-square of the shell relative error, $\\sqrt{\\langle \\delta_s^2 \\rangle}$, averaging uniformly over the considered shells. Both metrics are dimensionless.\n\n5) Use the following test suite of parameter sets to exercise your implementation:\n   - Case 1 (happy path): $N = 32$, $h = 1.0$, shape = NGP.\n   - Case 2 (shape effect): $N = 32$, $h = 1.0$, shape = CIC.\n   - Case 3 (resolution/spacing variation): $N = 48$, $h = 0.5$, shape = CIC.\n\nYour program must perform the computation for all cases and print a single line containing a flat list of six floats: for each case in order, print the maximum shell anisotropy followed by the root-mean-square relative error. The required final output format is a single line:\n\"[a1,e1,a2,e2,a3,e3]\"\nwhere each number is rounded to exactly six digits after the decimal point. For example, a syntactically correct output could look like \"[0.123456,0.012345,0.234567,0.023456,0.345678,0.034567]\". The reported quantities are dimensionless, so no physical units are required or permitted in the output.", "solution": "The problem requires the construction and analysis of the discrete Green's function for a three-dimensional electrostatic Particle-In-Cell (PIC) solver on a periodic Cartesian grid. The analysis will focus on quantifying the anisotropy and deviation from the continuum solution introduced by the grid, the finite-difference operator, and the particle shape function.\n\nThe fundamental equation is Poisson's equation for the electrostatic potential $\\phi(\\mathbf{x})$ given a charge density $\\rho(\\mathbf{x})$:\n$$ \\nabla^2 \\phi(\\mathbf{x}) = -\\frac{\\rho(\\mathbf{x})}{\\varepsilon_0} $$\nWe consider a uniform Cartesian grid of size $N \\times N \\times N$ with grid spacing $h$. The positions on the grid are denoted by $\\mathbf{r}_{\\mathbf{j}} = (j_x h, j_y h, j_z h)$, where $\\mathbf{j} = (j_x, j_y, j_z)$ is a triplet of integer indices. The potential and charge density are discretized on this grid as $\\phi_{\\mathbf{j}} = \\phi(\\mathbf{r}_{\\mathbf{j}})$ and $\\rho_{\\mathbf{j}} = \\rho(\\mathbf{r}_{\\mathbf{j}})$.\n\nThe Laplacian operator $\\nabla^2$ is approximated using a second-order accurate central-difference stencil. In three dimensions, this discrete operator $D^2$ acting on the potential at grid point $\\mathbf{j}$ is:\n$$ (D^2 \\phi)_{\\mathbf{j}} = \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_x} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_x}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_y} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_y}}{h^2} + \\frac{\\phi_{\\mathbf{j}+\\mathbf{e}_z} - 2\\phi_{\\mathbf{j}} + \\phi_{\\mathbf{j}-\\mathbf{e}_z}}{h^2} $$\nwhere $\\mathbf{e}_x, \\mathbf{e}_y, \\mathbf{e}_z$ are unit vectors along the grid axes.\nWith this, the discrete Poisson equation is $(D^2 \\phi)_{\\mathbf{j}} = -\\rho_{\\mathbf{j}}/\\varepsilon_0$.\n\nDue to the periodic boundary conditions, this system is efficiently solved in Fourier space. The Discrete Fourier Transform (DFT) of a grid quantity $f_{\\mathbf{j}}$ is $\\tilde{f}_{\\mathbf{n}} = \\sum_{\\mathbf{j}} f_{\\mathbf{j}} e^{-i \\mathbf{k}_{\\mathbf{n}} \\cdot \\mathbf{r}_{\\mathbf{j}}}$, where the discrete wave vectors are $\\mathbf{k}_{\\mathbf{n}} = (2\\pi n_x/(Nh), 2\\pi n_y/(Nh), 2\\pi n_z/(Nh))$ for integer mode indices $\\mathbf{n}=(n_x, n_y, n_z)$. The DFT transforms the convolution-like difference operator into a simple multiplication. The Fourier representation (eigenvalue) of the discrete Laplacian operator is:\n$$ \\hat{D}^2(\\mathbf{k}_{\\mathbf{n}}) = \\sum_{i \\in \\{x,y,z\\}} \\frac{2}{h^2} (\\cos(k_{n_i} h) - 1) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{k_{n_i} h}{2}\\right) $$\nSubstituting the expression for $k_{n_i}$, this becomes:\n$$ \\hat{D}^2(\\mathbf{n}) = -\\frac{4}{h^2} \\sum_{i \\in \\{x,y,z\\}} \\sin^2\\left(\\frac{\\pi n_i}{N}\\right) $$\nThe discrete Poisson equation in Fourier space is $\\hat{D}^2(\\mathbf{n}) \\tilde{\\phi}_{\\mathbf{n}} = -\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0$.\n\nThe discrete Green's function $G_d$ is the potential response to a single unit point charge $q=1$ placed at the origin grid point $\\mathbf{j}=(0,0,0)$. This corresponds to a discrete charge density $\\rho_{\\mathbf{j}} = \\delta_{\\mathbf{j}0} / h^3$, where $\\delta_{\\mathbf{j}0}$ is the Kronecker delta and $h^3$ is the cell volume. The DFT of this source is a constant, $\\tilde{\\rho}_{\\mathbf{n}} = 1/h^3$.\n\nIn a PIC simulation, the interaction between particles is softened by the particle shape function, used for both charge deposition onto the grid and field interpolation back to the particles. For a deposition function $W(\\mathbf{x})$ and interpolation function $I(\\mathbf{x})$, the effective potential felt by a test particle from a source particle is mediated by the solver and these two filters. In Fourier space, this leads to a modification of the interaction by the factor $\\tilde{I}^*(\\mathbf{k})\\tilde{W}(\\mathbf{k})$. The problem states that the deposition and interpolation functions are identical B-splines of order $m$, $W=I=S_m$, for which the Fourier transform is real. Thus, the effective interaction is modified by $|S_m(\\mathbf{k})|^2$. The problem gives the form:\n$$ S_m(k) = \\left[\\operatorname{sinc}\\left(\\frac{kh}{2}\\right)\\right]^{m+1} \\quad \\text{where } \\operatorname{sinc}(x) = \\frac{\\sin x}{x} $$\nThe total modification factor in three dimensions is $\\lvert S_m(\\mathbf{k}) \\rvert^2 = \\prod_{i=x,y,z}\\left[\\operatorname{sinc}\\!\\left(\\frac{k_i h}{2}\\right)\\right]^{2(m+1)}$.\n\nCombining these elements, the effective spectral potential $\\tilde{G}_{d, \\text{eff}}$ that describes the particle-particle interaction is:\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{-\\tilde{\\rho}_{\\mathbf{n}}/\\varepsilon_0}{\\hat{D}^2(\\mathbf{n})} |S_m(\\mathbf{k}_{\\mathbf{n}})|^2 = \\frac{-(1/h^3)/\\varepsilon_0}{-\\frac{4}{h^2} \\sum_i \\sin^2(\\frac{\\pi n_i}{N})} \\prod_j \\left[\\operatorname{sinc}\\left(\\frac{\\pi n_j}{N}\\right)\\right]^{2(m+1)} $$\n$$ \\tilde{G}_{d, \\text{eff}}(\\mathbf{n}) = \\frac{1}{4 \\varepsilon_0 h} \\frac{\\prod_j \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{\\sum_i \\sin^2(\\pi n_i/N)} $$\nWe seek a dimensionless Green's function, $\\hat{G}_d$. The continuum Green's function is $G_c(r) = 1/(4\\pi\\varepsilon_0 r)$. The dimensionless comparison function is given as $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$, where $\\hat{r}=r/h$. This suggests a normalization of $4\\pi\\varepsilon_0 h$ and setting $\\varepsilon_0=1/(4\\pi)$. A more direct way is to define the dimensionless spectral Green's function $\\hat{\\tilde{G}}_d(\\mathbf{n})$ that, when transformed to real space, can be compared to $\\hat{G}_c(\\hat{r})$. From the expression for $\\tilde{G}_{d, \\text{eff}}$, we can formulate a dimensionless spectral function independent of $h$ and $\\varepsilon_0$:\n$$ \\hat{\\tilde{G}}_d(\\mathbf{n}) = \\frac{\\prod_{j \\in \\{x,y,z\\}} \\left[\\operatorname{sinc}(\\pi n_j/N)\\right]^{2(m+1)}}{4 \\sum_{i \\in \\{x,y,z\\}} \\sin^2(\\pi n_i/N)} $$\nThe mode for $\\mathbf{n}=(0,0,0)$ has a zero denominator and represents the mean potential. For periodic systems with implicit charge neutrality, this mode is set to zero, $\\hat{\\tilde{G}}_d(\\mathbf{0}) = 0$.\n\nThe computational procedure is as follows:\n1. For a given grid size $N$ and shape order $m$, construct the $3$D array $\\hat{\\tilde{G}}_d(\\mathbf{n})$ for all mode indices $\\mathbf{n}$.\n2. Compute the real-space dimensionless Green's function $\\hat{G}_d(\\hat{\\mathbf{r}})$ by performing a $3$D inverse DFT of $\\hat{\\tilde{G}}_d(\\mathbf{n})$.\n3. To analyze the result, grid points are grouped into shells of constant squared distance $s = i^2+j^2+k^2$ from the origin, where $(i,j,k)$ are the shortest periodic displacements. The shell radius is $\\hat{r} = \\sqrt{s}$.\n4. For each shell within the range $1.5 < \\hat{r} < N/4$, we compute:\n   - The shell mean $\\overline{G}_s$ and standard deviation $\\sigma_s$ of the values of $\\hat{G}_d$ on that shell.\n   - The shell anisotropy $\\alpha_s = \\sigma_s / \\overline{G}_s$.\n   - The continuum value $\\hat{G}_c(\\hat{r}) = 1/(4\\pi\\hat{r})$.\n   - The shell relative error $\\delta_s = \\overline{G}_s / \\hat{G}_c(\\hat{r}) - 1$.\n5. Finally, we compute two global metrics over all considered shells: the maximum shell anisotropy, $\\max(\\alpha_s)$, and the root-mean-square of the shell relative errors, $\\sqrt{\\langle \\delta_s^2 \\rangle}$. These two dimensionless quantities are calculated for each test case.", "answer": "```python\nimport numpy as np\n\ndef calculate_metrics(N, h, shape_str):\n    \"\"\"\n    Constructs and analyzes the discrete Green's function for a 3D PIC solver.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        h (float): The grid spacing (not used in the dimensionless calculation but kept for parameter consistency).\n        shape_str (str): The particle shape function, \"NGP\" or \"CIC\".\n\n    Returns:\n        tuple[float, float]: A tuple containing the maximum shell anisotropy and the RMS relative error.\n    \"\"\"\n    if shape_str == 'NGP':\n        m = 0\n    elif shape_str == 'CIC':\n        m = 1\n    else:\n        raise ValueError(\"Invalid shape string. Must be 'NGP' or 'CIC'.\")\n\n    # 1. Create wave-number index grid\n    n_coords_1d = np.fft.fftfreq(N) * N\n    nx, ny, nz = np.meshgrid(n_coords_1d, n_coords_1d, n_coords_1d, indexing='ij')\n\n    # 2. Numerator: Shape function factor |S_m(k)|^2\n    # np.sinc(x) computes sin(pi*x)/(pi*x). We need sinc(pi*n/N) = sin(pi*n/N)/(pi*n/N).\n    # This corresponds to np.sinc(n/N).\n    sinc_arg_x = nx / N\n    sinc_arg_y = ny / N\n    sinc_arg_z = nz / N\n\n    sinc_val_x = np.sinc(sinc_arg_x)\n    sinc_val_y = np.sinc(sinc_arg_y)\n    sinc_val_z = np.sinc(sinc_arg_z)\n\n    shape_factor_sq = (sinc_val_x * sinc_val_y * sinc_val_z)**(2 * (m + 1))\n\n    # 3. Denominator: Fourier representation of the -Laplacian operator\n    # Denom = 4 * sum(sin^2(pi*n_i/N))\n    K_sq = 4 * (np.sin(np.pi * nx / N)**2 + \n                np.sin(np.pi * ny / N)**2 + \n                np.sin(np.pi * nz / N)**2)\n\n    # 4. Spectral Green's function, handling k=0 singularity\n    with np.errstate(divide='ignore', invalid='ignore'):\n        G_k = shape_factor_sq / K_sq\n    \n    G_k[0, 0, 0] = 0.0 # Set DC mode to zero\n    \n    # 5. Inverse FFT to get real-space Green's function\n    G_r = np.real(np.fft.ifftn(G_k))\n\n    # 6. Analysis of anisotropy and error\n    r_min = 1.5\n    r_max = N / 4.0\n\n    # Create coordinate grid for distance calculation. fftshift centers the result.\n    G_r_shifted = np.fft.fftshift(G_r)\n    coords_1d = np.arange(-N // 2, N // 2)\n    ix, iy, iz = np.meshgrid(coords_1d, coords_1d, coords_1d, indexing='ij')\n    s = ix**2 + iy**2 + iz**2\n    \n    # Group grid points into shells by squared distance 's'\n    shell_data = {}\n    unique_s_values = np.unique(s)\n    \n    for s_val in unique_s_values:\n        if s_val == 0:\n            continue\n        \n        r_val = np.sqrt(s_val)\n        \n        if r_min < r_val < r_max:\n            indices = np.where(s == s_val)\n            g_d_values = G_r_shifted[indices]\n            \n            mean_g = np.mean(g_d_values)\n            std_g = np.std(g_d_values)\n            \n            anisotropy = 0.0\n            if abs(mean_g) > 1e-16: # Avoid division by zero\n                anisotropy = std_g / mean_g\n            \n            g_c = 1.0 / (4.0 * np.pi * r_val)\n            rel_error = mean_g / g_c - 1.0\n            \n            shell_data[s_val] = {\n                'anisotropy': anisotropy, \n                'rel_error_sq': rel_error**2\n            }\n\n    # 7. Compute final global metrics\n    anisotropies = [d['anisotropy'] for d in shell_data.values()]\n    rel_errors_sq = [d['rel_error_sq'] for d in shell_data.values()]\n    \n    max_anisotropy = 0.0\n    if anisotropies:\n        max_anisotropy = np.max(anisotropies)\n        \n    rms_rel_error = 0.0\n    if rel_errors_sq:\n        rms_rel_error = np.sqrt(np.mean(rel_errors_sq))\n        \n    return max_anisotropy, rms_rel_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (32, 1.0, \"NGP\"),\n        (32, 1.0, \"CIC\"),\n        (48, 0.5, \"CIC\"),\n    ]\n\n    results = []\n    for N, h, shape in test_cases:\n        max_anisotropy, rms_rel_error = calculate_metrics(N, h, shape)\n        results.append(max_anisotropy)\n        results.append(rms_rel_error)\n\n    # Format the final output string\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2424113"}, {"introduction": "In computational science, a correct algorithm is only the first step; for large-scale problems, performance is paramount, often limited by how efficiently data is accessed from memory. This final practice [@problem_id:2424079] delves into the crucial topic of code optimization by exploring how the order of particle processing impacts cache efficiency. You will compare different particle sorting strategies, including a bit-reversed ordering, to see how structuring data to match the computer's memory hierarchy is a key technique in high-performance scientific computing.", "problem": "A one-dimensional electrostatic Particle-In-Cell (PIC) method models a set of computational particles that deposit quantities to a regular mesh of grid cells. Consider a discrete grid of $N_{\\mathrm{c}}$ cells indexed by integers $i \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$. Each particle $p \\in \\{1,2,\\dots,N_{\\mathrm{p}}\\}$ is associated with a grid cell index $i_p \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$. A traversal order of the particles is represented by a permutation $\\pi$ of $\\{1,2,\\dots,N_{\\mathrm{p}}\\}$. Define the cache-coherency cost functional\n$$\nJ(\\pi) \\equiv \\sum_{k=1}^{N_{\\mathrm{p}}-1} \\left|\\, i_{\\pi(k+1)} - i_{\\pi(k)} \\,\\right|.\n$$\nYou are to evaluate this functional for three traversal orders:\n- The original order $\\pi_{\\mathrm{orig}}$ (the given sequence of particle cell indices).\n- A cell-sorted order $\\pi_{\\mathrm{cell}}$ that is any non-decreasing ordering of the multiset $\\{i_p\\}$.\n- A bit-reversed order $\\pi_{\\mathrm{br}}$ defined as follows. Let $b \\equiv \\lceil \\log_2 N_{\\mathrm{c}} \\rceil$. For any cell index $i \\in \\{0,1,\\dots,N_{\\mathrm{c}}-1\\}$, write its $b$-bit binary representation (including leading zeros if necessary), reverse the order of these $b$ bits, and interpret the result as a nonnegative integer $r_b(i) \\in \\{0,1,\\dots,2^b-1\\}$. The bit-reversed order $\\pi_{\\mathrm{br}}$ is any stable ordering of the particles by non-decreasing keys $r_b(i_p)$.\n\nYour task is to write a complete program that, for each test case below, computes and returns the triple $[J(\\pi_{\\mathrm{orig}}), J(\\pi_{\\mathrm{cell}}), J(\\pi_{\\mathrm{br}})]$ as integers.\n\nUse the following test suite of parameter values:\n- Test case $1$: $N_{\\mathrm{c}} = 8$, particle cell index list $[\\,0,7,0,7,0,7,0,7\\,]$.\n- Test case $2$: $N_{\\mathrm{c}} = 6$, particle cell index list $[\\,0,5,1,4,2,3\\,]$.\n- Test case $3$: $N_{\\mathrm{c}} = 1$, particle cell index list $[\\,0,0,0,0\\,]$.\n- Test case $4$: $N_{\\mathrm{c}} = 8$, particle cell index list $[\\,0,4,0,4,2,6,2,6,1,5,1,5,3,7,3,7\\,]$.\n\nFinal output format requirement:\n- Your program should produce a single line of output containing the list of results for all test cases as a comma-separated list enclosed in square brackets, where each test case result is itself a three-element list of integers in the order $[J(\\pi_{\\mathrm{orig}}),J(\\pi_{\\mathrm{cell}}),J(\\pi_{\\mathrm{br}})]$. For example, a valid output looks like $[[\\dots],[\\dots],[\\dots],[\\dots]]$.", "solution": "The problem statement has been validated and is found to be scientifically grounded, well-posed, and objective. It presents a clearly defined computational task within the field of computational physics, specifically related to performance optimization in Particle-In-Cell (PIC) methods. All required data and definitions are provided, and the problem admits a unique, verifiable solution. We may therefore proceed with the derivation and implementation of the solution.\n\nThe objective is to compute a cache-coherency cost functional, $J(\\pi)$, for a set of particles distributed across a one-dimensional grid. The grid consists of $N_{\\mathrm{c}}$ cells, and there are $N_{\\mathrm{p}}$ particles. The position of each particle is given by its cell index, and a traversal of the particles is described by a permutation $\\pi$. The cost functional is defined as:\n$$\nJ(\\pi) \\equiv \\sum_{k=1}^{N_{\\mathrm{p}}-1} \\left|\\, i_{\\pi(k+1)} - i_{\\pi(k)} \\,\\right|\n$$\nHere, $i_{\\pi(k)}$ denotes the cell index of the $k$-th particle in the ordered sequence defined by $\\pi$. We are tasked with evaluating this functional for three distinct traversal orders: the original order ($\\pi_{\\mathrm{orig}}$), the cell-sorted order ($\\pi_{\\mathrm{cell}}$), and the bit-reversed order ($\\pi_{\\mathrm{br}}$).\n\nLet the given sequence of particle cell indices be represented by a list $I = [c_1, c_2, \\dots, c_{N_{\\mathrm{p}}}]$.\n\n1.  **Original Order Cost ($J(\\pi_{\\mathrm{orig}})$)**\n    The original traversal order corresponds to processing particles as they are given in the input list. Thus, $\\pi_{\\mathrm{orig}}$ is the identity permutation, meaning the sequence of cell indices is simply $I$. The cost is a direct application of the definition:\n    $$\n    J(\\pi_{\\mathrm{orig}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |c_{k+1} - c_k|\n    $$\n    This is calculated by summing the absolute differences between all adjacent elements in the input list.\n\n2.  **Cell-Sorted Order Cost ($J(\\pi_{\\mathrm{cell}})$)**\n    This order is achieved by sorting the particles based on their cell indices in a non-decreasing fashion. Let the sorted list of cell indices be $I' = [c'_1, c'_2, \\dots, c'_{N_{\\mathrm{p}}}]$, where $c'_1 \\le c'_2 \\le \\dots \\le c'_{N_{\\mathrm{p}}}$. The cost functional becomes:\n    $$\n    J(\\pi_{\\mathrm{cell}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |c'_{k+1} - c'_k|\n    $$\n    Due to the non-decreasing nature of the sorted list, we have $c'_{k+1} - c'_k \\ge 0$ for all $k$. Therefore, the absolute value operation is redundant:\n    $$\n    J(\\pi_{\\mathrm{cell}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} (c'_{k+1} - c'_k)\n    $$\n    This sum is a telescoping series:\n    $$\n    J(\\pi_{\\mathrm{cell}}) = (c'_2 - c'_1) + (c'_3 - c'_2) + \\dots + (c'_{N_{\\mathrm{p}}} - c'_{N_{\\mathrm{p}}-1}) = c'_{N_{\\mathrm{p}}} - c'_1\n    $$\n    The cost is simply the difference between the maximum and minimum cell indices present in the particle list.\n\n3.  **Bit-Reversed Order Cost ($J(\\pi_{\\mathrm{br}})$)**\n    This ordering requires a multi-step process. First, we determine the number of bits required to represent any cell index, which is given by $b = \\lceil \\log_2 N_{\\mathrm{c}} \\rceil$. For a cell index $i \\in \\{0, 1, \\dots, N_{\\mathrm{c}}-1\\}$, we define a key $r_b(i)$ by the following procedure:\n    - Convert the integer $i$ to its $b$-bit binary string representation, padding with leading zeros if necessary.\n    - Reverse the order of the bits in this string.\n    - Convert the resulting binary string back to an integer. This is the key $r_b(i)$.\n    For the special case where $N_{\\mathrm{c}}=1$, we have $b=0$, and we define $r_0(0) = 0$.\n\n    Next, we sort the particles according to these keys. The problem specifies a stable sort, meaning that if two particles have the same key, their relative order in the original sequence must be preserved in the sorted sequence.\n    Let the original list of cell indices be $I = [c_1, c_2, \\dots, c_{N_{\\mathrm{p}}}]$, and let the corresponding keys be $K = [r_b(c_1), r_b(c_2), \\dots, r_b(c_{N_{\\mathrm{p}}})]$. We sort the particle indices $\\{1, 2, \\dots, N_{\\mathrm{p}}\\}$ based on the values in $K$, maintaining stability. This produces a new permutation of particles and thus a new sequence of cell indices, $I_{\\mathrm{br}}$. The cost $J(\\pi_{\\mathrm{br}})$ is then calculated by applying the cost functional to this new list $I_{\\mathrm{br}}$:\n    $$\n    J(\\pi_{\\mathrm{br}}) = \\sum_{k=1}^{N_{\\mathrm{p}}-1} |I_{\\mathrm{br}, k+1} - I_{\\mathrm{br}, k}|\n    $$\n    where $I_{\\mathrm{br}, k}$ is the $k$-th element of the bit-reversal-sorted list.\n\nThe implementation will systematically apply these three procedures to each test case provided.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the cache-coherency cost functional for three different\n    particle traversal orders in a 1D PIC simulation context.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (8, [0, 7, 0, 7, 0, 7, 0, 7]),\n        (6, [0, 5, 1, 4, 2, 3]),\n        (1, [0, 0, 0, 0]),\n        (8, [0, 4, 0, 4, 2, 6, 2, 6, 1, 5, 1, 5, 3, 7, 3, 7]),\n    ]\n\n    results = []\n\n    def bit_reverse(i, num_bits):\n        \"\"\"\n        Reverses the bottom num_bits of an integer i.\n        \"\"\"\n        if num_bits == 0:\n            return 0\n        bin_str = bin(i)[2:].zfill(num_bits)\n        rev_bin_str = bin_str[::-1]\n        return int(rev_bin_str, 2)\n\n    def calculate_cost(arr):\n        \"\"\"\n        Calculates the cost functional for a given sequence of cell indices.\n        \"\"\"\n        if arr.size < 2:\n            return 0\n        return np.sum(np.abs(np.diff(arr)))\n\n    for Nc, I_list in test_cases:\n        I = np.array(I_list, dtype=np.int64)\n        Np = I.size\n\n        if Np < 2:\n            results.append([0, 0, 0])\n            continue\n        \n        # 1. Original order cost\n        J_orig = calculate_cost(I)\n\n        # 2. Cell-sorted order cost\n        # The cost is simply max(I) - min(I).\n        J_cell = np.max(I) - np.min(I)\n\n        # 3. Bit-reversed order cost\n        if Nc > 1:\n            # b = ceil(log2(Nc)), which can be computed using bit_length\n            b = (Nc - 1).bit_length()\n        else:\n            b = 0\n            \n        # Compute keys for each particle\n        keys = np.array([bit_reverse(val, b) for val in I])\n        \n        # Perform a stable sort of particle indices based on keys\n        # numpy.argsort with kind='stable' preserves relative order for equal keys.\n        sorted_indices = np.argsort(keys, kind='stable')\n        \n        # Create the new list of cell indices\n        I_br = I[sorted_indices]\n        \n        # Calculate cost for the bit-reversed order\n        J_br = calculate_cost(I_br)\n\n        results.append([int(J_orig), int(J_cell), int(J_br)])\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    final_output_str = str(results).replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n```", "id": "2424079"}]}