{"hands_on_practices": [{"introduction": "Before diving into complex simulations, it is essential to grasp the fundamental goal of statistical mechanics: calculating the average properties of a system in thermal equilibrium. For systems with a small number of states, we can achieve this with perfect accuracy through exact enumeration. This practice [@problem_id:2413243] provides a hands-on exercise in this foundational method by asking you to compute observables for a model of opinion dynamics on a small, weighted social network. By explicitly calculating properties over all possible configurations, you will solidify your understanding of the partition function and thermal averages, which are the very quantities that approximation methods like Metropolis are designed to estimate.", "problem": "Consider a system of binary opinions represented by spins on a finite undirected graph. Each individual is a node indexed by $i \\in \\{0,1,\\dots,N-1\\}$ with spin $s_i \\in \\{-1,+1\\}$. Let the \"friendship strength\" between two distinct individuals $i$ and $j$ be a nonnegative, symmetric weight $w_{ij} = w_{ji} \\ge 0$, with $w_{ii} = 0$, and assume there is an edge between $i$ and $j$ if and only if $w_{ij} > 0$. The interaction energy of a configuration $s = (s_0,\\dots,s_{N-1})$ at temperature $T > 0$ in an external uniform field $h$ is given by the Ising Hamiltonian\n$$\nH(s) \\;=\\; -\\sum_{0 \\le i  j \\le N-1} J_{ij} \\, s_i s_j \\;-\\; h \\sum_{i=0}^{N-1} s_i,\n$$\nwith couplings $J_{ij} = J_0 \\, w_{ij}$, where $J_0 > 0$ is a uniform coupling scale. Work in units where the Boltzmann constant $k_B$ equals $1$ so that the canonical probability of configuration $s$ is\n$$\n\\mathbb{P}(s) \\;=\\; \\frac{1}{Z} \\exp\\!\\left(-\\frac{H(s)}{T}\\right), \\qquad Z \\;=\\; \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\!\\left(-\\frac{H(s)}{T}\\right).\n$$\n\nFor each specified test case below, compute the following equilibrium observables:\n- The absolute magnetization per spin,\n$$\nm \\;=\\; \\frac{1}{N} \\, \\Big\\langle \\big| \\sum_{i=0}^{N-1} s_i \\big| \\Big\\rangle,\n$$\n- The energy per spin,\n$$\ne \\;=\\; \\frac{1}{N} \\, \\langle H(s) \\rangle,\n$$\nwhere $\\langle \\cdot \\rangle$ denotes the canonical expectation with respect to $\\mathbb{P}(s)$ at the given temperature $T$. All quantities are dimensionless in these units. Energies are to be expressed in units of $J_0$ and temperatures in units where $k_B = 1$.\n\nTest suite (each case is fully specified by $(N,\\{(i,j,w_{ij})\\},J_0,h,T)$):\n- Case $1$: $N = 4$; weighted edges $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 0.1$.\n- Case $2$: $N = 4$; weighted edges $\\{(0,1,1.0),(1,2,1.0),(2,3,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 5.0$.\n- Case $3$: $N = 3$; weighted edges $\\{(0,1,2.0),(1,2,0.5),(0,2,1.0)\\}$; $J_0 = 1.0$; $h = 0.0$; $T = 1.5$.\n- Case $4$: $N = 4$; weighted edges $\\{(0,1,1.5),(2,3,1.5),(1,2,0.1)\\}$; $J_0 = 1.0$; $h = 0.2$; $T = 1.0$.\n\nRequired final output format:\n- Your program must produce a single line of output containing the results for the four cases as a comma-separated list enclosed in square brackets. Each caseâ€™s result must itself be a two-element list $[m,e]$, with both $m$ and $e$ rounded to exactly $6$ decimal places using standard rounding to nearest. There must be no spaces anywhere in the output.\n- Concretely, the output must have the form\n$$\n[[m_1,e_1],[m_2,e_2],[m_3,e_3],[m_4,e_4]],\n$$\nwhere each $m_k$ and $e_k$ are decimal numbers with exactly $6$ digits after the decimal point.\n\nNo angles or percentages are involved; do not use angle units or percentage signs. All temperatures and energies are dimensionless in the specified units. The problem is fully determined by the definitions above; use only the provided parameters. Your code must use exactly the test suite above and produce the final output in the required single-line format.", "solution": "The problem statement is critically examined and found to be valid. It is scientifically grounded in the principles of statistical mechanics, well-posed for its small system sizes, and expressed with objective, mathematical precision. It does not violate any of the criteria for invalidity. The problem describes the standard Ising model on a finite, weighted, undirected graph and asks for the computation of fundamental equilibrium observables: the absolute magnetization per spin and the energy per spin.\n\nThe crucial observation is that for the small number of spins $N$ given in the test cases ($N=3$ and $N=4$), the total number of system configurations, $2^N$, is very small ($2^3 = 8$ and $2^4 = 16$, respectively). This allows for a direct, exact calculation of the partition function and thermal expectation values by enumerating all possible states. This approach is computationally feasible and yields exact results, obviating the need for stochastic methods such as Metropolis Monte Carlo simulations, which would only provide statistical estimates.\n\nThe solution is based on the principles of the canonical ensemble in statistical mechanics. The probability of a system being in a specific configuration $s$ with energy $H(s)$ at a given temperature $T$ is given by the Boltzmann distribution:\n$$\n\\mathbb{P}(s) = \\frac{1}{Z} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nwhere $Z$ is the partition function, which normalizes the probability distribution. It is the sum of the Boltzmann factors over all possible configurations:\n$$\nZ = \\sum_{s \\in \\{-1,+1\\}^N} \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nThe Hamiltonian $H(s)$ for a given configuration $s = (s_0, \\dots, s_{N-1})$ is defined as:\n$$\nH(s) = -\\sum_{0 \\le i  j \\le N-1} J_{ij} s_i s_j - h \\sum_{i=0}^{N-1} s_i\n$$\nThe couplings $J_{ij}$ are derived from the problem-specified friendship weights $w_{ij}$ and the uniform coupling scale $J_0$ as $J_{ij} = J_0 w_{ij}$.\n\nThe thermal expectation value of any observable quantity $A(s)$ is then calculated by averaging $A(s)$ over all possible configurations, weighted by their respective probabilities:\n$$\n\\langle A \\rangle = \\sum_s A(s) \\mathbb{P}(s) = \\frac{1}{Z} \\sum_s A(s) \\exp\\left(-\\frac{H(s)}{T}\\right)\n$$\nThe two observables required are:\n1.  The energy per spin, $e = \\frac{1}{N} \\langle H \\rangle$.\n2.  The absolute magnetization per spin, $m = \\frac{1}{N} \\langle \\left| M \\right| \\rangle$, where the total magnetization of a state $s$ is $M(s) = \\sum_{i=0}^{N-1} s_i$.\n\nThe computational procedure is as follows:\nFirst, for each test case, we construct the symmetric $N \\times N$ coupling matrix $J$ where $J_{ij} = J_0 w_{ij}$.\nSecond, we systematically generate all $2^N$ spin configurations $s$. This is achieved by iterating through integers from $0$ to $2^N - 1$ and using their binary representations to define the spin states (e.g., bit $0 \\mapsto +1$, bit $1 \\mapsto -1$).\nFor each configuration $s$, we compute its energy $H(s)$ and its absolute total magnetization $|M(s)|$.\n\nA key numerical consideration is the evaluation of the Boltzmann factor $\\exp(-H(s)/T)$. When $T$ is small, the argument $-H(s)/T$ can become very large and positive, leading to numerical overflow. To ensure stability, we subtract the minimum energy of the system, $H_{\\text{min}} = \\min_s H(s)$, from all energies before exponentiating. The expectation value calculation is invariant under this shift:\n$$\n\\langle A \\rangle = \\frac{\\sum_s A(s) \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}{\\sum_s \\exp\\left(-\\frac{H(s) - H_{\\text{min}}}{T}\\right)}\n$$\nThis reformulation guarantees that all arguments to the exponential function are less than or equal to zero, thus preventing overflow and maintaining numerical precision.\n\nThe algorithm for each test case is implemented by:\n1.  Initializing sums for the numerator of $\\langle H \\rangle$, the numerator of $\\langle |M| \\rangle$, and the (shifted) partition function to zero.\n2.  Iterating through all $2^N$ states. For each state $s$:\n    a.  Calculate $H(s)$ and $|M(s)|$.\n    b.  Calculate the shifted Boltzmann factor $W'(s) = \\exp(-(H(s) - H_{\\text{min}})/T)$.\n    c.  Update the sums: add $W'(s)$ to the partition function sum, add $H(s) \\cdot W'(s)$ to the energy sum, and add $|M(s)| \\cdot W'(s)$ to the magnetization sum.\n3.  After iterating through all states, compute the final expectation values $\\langle H \\rangle$ and $\\langle |M| \\rangle$ by dividing the accumulated sums by the total sum of shifted Boltzmann factors.\n4.  Finally, divide these expectation values by $N$ to obtain the per-spin quantities $e$ and $m$. These are then formatted as required by the problem statement.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observables(N, edges, J0, h, T):\n    \"\"\"\n    Calculates equilibrium observables for an Ising model on a graph by exact enumeration.\n    \n    Args:\n        N (int): Number of spins.\n        edges (list): List of tuples (i, j, w_ij) representing weighted edges.\n        J0 (float): Uniform coupling scale.\n        h (float): External uniform field.\n        T (float): Temperature (with k_B = 1).\n        \n    Returns:\n        tuple: A tuple (m, e) containing the absolute magnetization per spin\n               and the energy per spin.\n    \"\"\"\n    # 1. Construct the coupling matrix J\n    J_mat = np.zeros((N, N))\n    for i, j, w_ij in edges:\n        J_mat[i, j] = J0 * w_ij\n        J_mat[j, i] = J0 * w_ij\n\n    num_states = 1  N\n    all_energies = np.zeros(num_states)\n    all_abs_mags = np.zeros(num_states)\n\n    # 2. Enumerate all 2^N states and calculate H and |M| for each\n    for i in range(num_states):\n        # Generate spin configuration s from the bits of integer i.\n        # bit 0 -> spin +1, bit 1 -> spin -1\n        s = np.array([1 if not ((i >> j)  1) else -1 for j in range(N)])\n        \n        # Calculate Hamiltonian H(s) = -0.5 * s.T @ J_mat @ s - h * sum(s)\n        interaction_energy = -0.5 * np.dot(s, np.dot(J_mat, s))\n        field_energy = -h * np.sum(s)\n        H_s = interaction_energy + field_energy\n        \n        M_s = np.sum(s)\n        \n        all_energies[i] = H_s\n        all_abs_mags[i] = np.abs(M_s)\n        \n    # 3. Calculate expectation values using numerically stable method\n    if T = 0:\n        # In the zero-temperature limit, the system occupies the ground state(s).\n        min_energy = np.min(all_energies)\n        ground_state_indices = np.where(all_energies == min_energy)[0]\n        \n        avg_H = min_energy\n        avg_abs_M = np.mean(all_abs_mags[ground_state_indices])\n    else:\n        # For T > 0, use Boltzmann statistics with a shift to avoid overflow.\n        min_energy = np.min(all_energies)\n        shifted_boltzmann_factors = np.exp(-(all_energies - min_energy) / T)\n        \n        Z_prime = np.sum(shifted_boltzmann_factors)\n        \n        avg_H = np.sum(all_energies * shifted_boltzmann_factors) / Z_prime\n        avg_abs_M = np.sum(all_abs_mags * shifted_boltzmann_factors) / Z_prime\n\n    # 4. Compute per-spin observables\n    e = avg_H / N\n    m = avg_abs_M / N\n\n    return m, e\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (N, edges, J0, h, T)\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 0.1),\n        # Case 2\n        (4, [(0, 1, 1.0), (1, 2, 1.0), (2, 3, 1.0)], 1.0, 0.0, 5.0),\n        # Case 3\n        (3, [(0, 1, 2.0), (1, 2, 0.5), (0, 2, 1.0)], 1.0, 0.0, 1.5),\n        # Case 4\n        (4, [(0, 1, 1.5), (2, 3, 1.5), (1, 2, 0.1)], 1.0, 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, edges, J0, h, T = case\n        m, e = calculate_observables(N, edges, J0, h, T)\n        \n        # Format each [m, e] pair as a string with 6 decimal places and no spaces.\n        result_str = f\"[{m:.6f},{e:.6f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413243"}, {"introduction": "For most systems of interest in physics, the number of possible states is astronomically large, making exact enumeration computationally infeasible. This is where methods like the Metropolis algorithm become indispensable tools for the computational physicist. This practice [@problem_id:2413296] transitions from exact calculation to stochastic simulation, tasking you with implementing the workhorse Metropolis algorithm for the two-dimensional Ising model. You will not only simulate the system's behavior but also investigate important physical and computational concepts such as different boundary conditions and the nature of finite-size corrections to thermodynamic quantities, connecting your simulation results to established theory.", "problem": "You are tasked with designing and executing a Metropolis single-spin-flip simulation of the two-dimensional Ising model to quantify how different boundary conditions modify finite-size corrections to the magnetization. Your implementation must be a complete, runnable program. The model consists of spins $s_i \\in \\{-1,+1\\}$ on a square lattice of linear size $L$, with Hamiltonian\n$$\nH(\\{s\\}) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\nwhere $J>0$ and $\\langle i,j \\rangle$ denotes nearest-neighbor pairs defined by a boundary condition. Use $J=1$ and Boltzmann constant $k_{\\mathrm{B}}=1$, so temperature $T$ is dimensionless. The Metropolis algorithm with a single-spin-flip proposal must be employed, using the acceptance probability\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right),\n$$\nwhere $\\Delta E$ is the energy change due to a proposed flip and $\\beta = 1/T$.\n\nBoundary conditions to implement:\n- Periodic boundary condition (PBC): neighbors of a site at coordinates $(x,y)$ are $((x+1)\\!\\!\\mod L, y)$, $((x-1)\\!\\!\\mod L, y)$, $(x, (y+1)\\!\\!\\mod L)$, $(x, (y-1)\\!\\!\\mod L)$.\n- Open boundary condition (OBC): neighbors outside the lattice are absent and do not contribute to $H$.\n- Helical boundary condition (HBC): flatten the lattice to one-dimensional index $i = x + L y \\in \\{0,\\dots,L^2-1\\}$, and use neighbors $\\{(i+1)\\!\\!\\mod N, (i-1)\\!\\!\\mod N, (i+L)\\!\\!\\mod N, (i-L)\\!\\!\\mod N\\}$ with $N=L^2$. For algorithmic efficiency, you must use a checkerboard (red-black) parallel Metropolis update; to strictly preserve independence of sublattice updates under HBC, choose odd $L$.\n\nMagnetization per spin is\n$$\nm(\\{s\\}) = \\frac{1}{N}\\left|\\sum_{i=1}^N s_i\\right|, \\quad N=L^2.\n$$\nDefine the finite-size correction at temperature $T$ for a lattice of size $L$ under a boundary condition $\\mathcal{B}$ as\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T},\n$$\nwhere $\\langle m \\rangle_{L,\\mathcal{B},T}$ is the Monte Carlo average of $m(\\{s\\})$ in equilibrium, and $m_{\\infty}(T)$ is the exact infinite-lattice spontaneous magnetization for the two-dimensional Ising model at $TT_{\\mathrm{c}}$, given by the well-tested expression\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\!\\left(\\frac{2}{T}\\right)\\right]^{1/8}, \\quad TT_{\\mathrm{c}},\n$$\nand $m_{\\infty}(T)=0$ for $T \\ge T_{\\mathrm{c}}$. The critical temperature is\n$$\nT_{\\mathrm{c}} = \\frac{2}{\\ln\\!\\left(1+\\sqrt{2}\\right)}.\n$$\n\nStart from the Boltzmann distribution and the Metropolis transition rule. Implement a checkerboard (two-sublattice) update that flips all spins on one sublattice in parallel, then the other. Use a hot start with random initial spins $s_i \\in \\{-1,+1\\}$ with equal probability. Thermalize for a specified number of full sweeps, then perform measurements of $m$ after each sweep and average them to estimate $\\langle m \\rangle_{L,\\mathcal{B},T}$. Use fixed random seeds for reproducibility.\n\nTest Suite. Run your program for the following parameter sets, all at $T=2.2$ (which satisfies $TT_{\\mathrm{c}}$), using the listed number of thermalization sweeps and measurement sweeps. All lattice sizes are odd to ensure helical boundary condition compatibility with checkerboard updates. Each test case is independent with its own fixed seed.\n- Case $1$: $(\\mathcal{B}=\\mathrm{PBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231101)$.\n- Case $2$: $(\\mathcal{B}=\\mathrm{OBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231102)$.\n- Case $3$: $(\\mathcal{B}=\\mathrm{HBC},\\, L=9,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231103)$.\n- Case $4$: $(\\mathcal{B}=\\mathrm{PBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231104)$.\n- Case $5$: $(\\mathcal{B}=\\mathrm{OBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231105)$.\n- Case $6$: $(\\mathcal{B}=\\mathrm{HBC},\\, L=13,\\, T=2.2,\\, N_{\\mathrm{therm}}=1000,\\, N_{\\mathrm{meas}}=2000,\\, \\text{seed}=20231106)$.\n\nYour output must be the list\n$$\n[\\Delta m_1,\\Delta m_2,\\Delta m_3,\\Delta m_4,\\Delta m_5,\\Delta m_6],\n$$\nwhere $\\Delta m_k$ is the finite-size correction computed for Case $k$, rounded to $6$ decimal places. The program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[0.123456,0.234567,0.345678,0.456789,0.567890,0.678901]$). No physical units are required since all quantities are dimensionless. Angles are not used.\n\nYour solution must be derived from the Boltzmann weight, the definition of the Ising Hamiltonian, and the Metropolis acceptance rule. Do not use any pre-computed simulation outputs. Your program must be fully self-contained and require no user input. All mathematical symbols and numbers in this problem statement are written in LaTeX. Ensure scientific realism and internal consistency in your assumptions and numerical choices.", "solution": "The problem statement has been rigorously validated and is determined to be valid. It is scientifically grounded, well-posed, objective, and internally consistent. It presents a standard problem in computational statistical mechanics with all necessary parameters, definitions, and constraints clearly specified.\n\nThe task is to perform a Metropolis Monte Carlo simulation of the two-dimensional Ising model to compute the finite-size correction to the spontaneous magnetization, $\\Delta m$, for various lattice sizes and boundary conditions. The solution is derived from the fundamental principles of statistical mechanics and the Monte Carlo method.\n\nThe foundational principle is that in thermal equilibrium, the probability of a physical system being in a microscopic state $\\{s\\}$ with energy $H(\\{s\\})$ is given by the Boltzmann distribution:\n$$\nP(\\{s\\}) = \\frac{1}{Z} e^{-\\beta H(\\{s\\})}\n$$\nwhere $Z$ is the partition function and $\\beta = 1/(k_{\\mathrm{B}}T)$. For the Ising model on a square lattice, the Hamiltonian is given by:\n$$\nH(\\{s\\}) = -J \\sum_{\\langle i,j \\rangle} s_i s_j\n$$\nwith $J=1$ and $k_{\\mathrm{B}}=1$.\n\nDirectly sampling from the Boltzmann distribution is intractable for any non-trivial system size. Instead, we employ a Markov Chain Monte Carlo (MCMC) method, specifically the Metropolis algorithm, to generate a sequence of states that are distributed according to $P(\\{s\\})$. This algorithm ensures that the system evolves towards equilibrium by satisfying the detailed balance condition. The Metropolis transition rule for a proposed single-spin flip $s_k \\to -s_k$ is governed by the acceptance probability:\n$$\nP_{\\mathrm{acc}} = \\min\\left(1, e^{-\\beta \\Delta E}\\right)\n$$\nwhere $\\Delta E$ is the change in energy resulting from the flip. For a flip of spin $s_k$, the energy change is:\n$$\n\\Delta E = E_{\\text{final}} - E_{\\text{initial}} = -J \\sum_{\\langle k,j \\rangle} (-s_k)s_j - \\left(-J \\sum_{\\langle k,j \\rangle} s_k s_j\\right) = 2J s_k \\sum_{\\langle k,j \\rangle} s_j\n$$\nHere, $\\sum_{\\langle k,j \\rangle} s_j$ is the sum of the spins neighboring site $k$.\n\nFor computational efficiency, a checkerboard update scheme is implemented. The lattice sites are partitioned into two independent sublattices, \"red\" and \"black,\" akin to a chessboard. A site $(x,y)$ is red if $(x+y)$ is even, and black if $(x+y)$ is odd. Crucially, all nearest neighbors of a red site are black, and vice versa. This independence allows for the simultaneous (vectorized) update of all spins on one sublattice, followed by the simultaneous update of all spins on the other. A full Monte Carlo sweep consists of updating the red sublattice and then the black sublattice.\n\nThe simulation protocol for each test case proceeds as follows:\n1.  **Initialization**: The system is initialized in a \"hot\" state, where each spin $s_i$ is randomly assigned a value of $+1$ or $-1$ with equal probability. An appropriate random number generator is seeded for reproducibility.\n2.  **Thermalization**: The system is evolved for a specified number of thermalization sweeps, $N_{\\mathrm{therm}}$. During this phase, the system relaxes from its random initial state towards thermal equilibrium. No measurements are taken.\n3.  **Measurement**: Following thermalization, the simulation continues for $N_{\\mathrm{meas}}$ measurement sweeps. After each full sweep, the instantaneous absolute magnetization per spin, $m(\\{s\\}) = \\frac{1}{N}|\\sum_i s_i|$, is calculated and recorded.\n4.  **Averaging**: The equilibrium expectation value of the magnetization, $\\langle m \\rangle_{L,\\mathcal{B},T}$, is estimated by averaging the instantaneous values of $m(\\{s\\})$ collected during the measurement phase.\n\nThe neighbor sum calculation depends critically on the boundary condition ($\\mathcal{B}$):\n-   **Periodic Boundary Condition (PBC)**: The lattice is treated as a torus. The neighbors of a site are found by applying modulo $L$ arithmetic to their coordinates. This is efficiently implemented using `numpy.roll` on a two-dimensional array.\n-   **Open Boundary Condition (OBC)**: Spins at the edges and corners have fewer than four neighbors as any connection extending beyond the lattice boundary is absent. This is implemented by constructing the neighbor-sum array and adding contributions from each direction using appropriate array slices that exclude the boundaries.\n-   **Helical Boundary Condition (HBC)**: The $L \\times L$ lattice is flattened into a one-dimensional array of size $N=L^2$. The neighbors of a site with index $i$ are at indices $(i\\pm 1) \\pmod N$ and $(i\\pm L) \\pmod N$. This configuration is compatible with the checkerboard update scheme for odd $L$, as specified. This is efficiently implemented using `numpy.roll` on the one-dimensional array.\n\nFinally, the finite-size correction is computed using the provided exact result for the infinite-lattice spontaneous magnetization, $m_{\\infty}(T)$, for $TT_{\\mathrm{c}}$:\n$$\n\\Delta m(L,\\mathcal{B},T) = m_{\\infty}(T) - \\langle m \\rangle_{L,\\mathcal{B},T}\n$$\nwhere $T=2.2$ is below the critical temperature $T_{\\mathrm{c}} = 2/\\ln(1+\\sqrt{2}) \\approx 2.269$. The formula for $m_{\\infty}(T)$ is:\n$$\nm_{\\infty}(T) = \\left[1 - \\sinh^{-4}\\left(\\frac{2}{T}\\right)\\right]^{1/8}\n$$\nThe entire procedure is repeated for each of the six specified test cases, and the results are aggregated.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the Ising model simulations and compute finite-size corrections.\n    \"\"\"\n\n    def calculate_avg_m(L, T, bc_type, n_therm, n_meas, seed):\n        \"\"\"\n        Performs a Metropolis simulation of the 2D Ising model.\n\n        Args:\n            L (int): Linear size of the lattice.\n            T (float): Temperature.\n            bc_type (str): Boundary condition type ('PBC', 'OBC', 'HBC').\n            n_therm (int): Number of thermalization sweeps.\n            n_meas (int): Number of measurement sweeps.\n            seed (int): Seed for the random number generator.\n\n        Returns:\n            float: The time-averaged absolute magnetization per spin.\n        \"\"\"\n        rng = np.random.default_rng(seed)\n        beta = 1.0 / T\n        N = L * L\n        J = 1.0\n\n        # Initialize spins and checkerboard masks\n        if bc_type == 'HBC':\n            spins = rng.choice([-1, 1], size=N)\n            # Create 2D indices to define masks, then flatten\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = ((x + y) % 2 == 0).flatten()\n            mask_black = ((x + y) % 2 == 1).flatten()\n        else: # PBC, OBC\n            spins = rng.choice([-1, 1], size=(L, L))\n            x, y = np.meshgrid(np.arange(L), np.arange(L))\n            mask_red = (x + y) % 2 == 0\n            mask_black = (x + y) % 2 == 1\n        \n        num_red = np.sum(mask_red)\n        num_black = np.sum(mask_black)\n\n        def update_sublattice(spins, mask, num_sites_in_mask):\n            \"\"\"Applies one parallel update to a sublattice.\"\"\"\n            # Calculate sum of neighbors for all sites\n            if bc_type == 'PBC':\n                neighbors_sum = (np.roll(spins, 1, axis=0) + np.roll(spins, -1, axis=0) +\n                                 np.roll(spins, 1, axis=1) + np.roll(spins, -1, axis=1))\n            elif bc_type == 'OBC':\n                neighbors_sum = np.zeros_like(spins, dtype=np.int8)\n                neighbors_sum[1:, :] += spins[:-1, :]  # Neighbors from top\n                neighbors_sum[:-1, :] += spins[1:, :]  # Neighbors from bottom\n                neighbors_sum[:, 1:] += spins[:, :-1]  # Neighbors from left\n                neighbors_sum[:, :-1] += spins[:, 1:]  # Neighbors from right\n            elif bc_type == 'HBC':\n                neighbors_sum = (np.roll(spins, 1) + np.roll(spins, -1) +\n                                 np.roll(spins, L) + np.roll(spins, -L))\n\n            sublattice_spins = spins[mask]\n            sublattice_neighbors_sum = neighbors_sum[mask]\n\n            # Calculate energy change for a flip for all spins on the sublattice\n            delta_E = 2.0 * J * sublattice_spins * sublattice_neighbors_sum\n            \n            # Metropolis acceptance condition\n            accept = (delta_E = 0) | (rng.random(size=num_sites_in_mask)  np.exp(-beta * delta_E))\n            \n            # Apply flips. Must assign back to the masked array to modify in place.\n            new_sublattice_spins = sublattice_spins.copy()\n            new_sublattice_spins[accept] *= -1\n            spins[mask] = new_sublattice_spins\n            \n            return spins\n\n        # Thermalization sweeps\n        for _ in range(n_therm):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n\n        # Measurement sweeps\n        magnetization_values = []\n        for _ in range(n_meas):\n            spins = update_sublattice(spins, mask_red, num_red)\n            spins = update_sublattice(spins, mask_black, num_black)\n            m = np.abs(np.sum(spins)) / N\n            magnetization_values.append(m)\n        \n        return np.mean(magnetization_values)\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        ('PBC', 9, 2.2, 1000, 2000, 20231101),\n        ('OBC', 9, 2.2, 1000, 2000, 20231102),\n        ('HBC', 9, 2.2, 1000, 2000, 20231103),\n        ('PBC', 13, 2.2, 1000, 2000, 20231104),\n        ('OBC', 13, 2.2, 1000, 2000, 20231105),\n        ('HBC', 13, 2.2, 1000, 2000, 20231106),\n    ]\n\n    # Calculate exact infinite-lattice magnetization for T=2.2\n    T_val = 2.2\n    Tc = 2.0 / np.log(1.0 + np.sqrt(2.0))\n    if T_val  Tc:\n        m_infinity = (1.0 - np.sinh(2.0 / T_val)**(-4))**(1.0/8.0)\n    else:\n        m_infinity = 0.0\n\n    results = []\n    for case in test_cases:\n        bc_type, L, T_case, n_therm, n_meas, seed = case\n        avg_m = calculate_avg_m(L, T_case, bc_type, n_therm, n_meas, seed)\n        delta_m = m_infinity - avg_m\n        results.append(f\"{delta_m:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413296"}, {"introduction": "The power of the Metropolis algorithm extends far beyond the realm of physical systems. Its core logic of probabilistically exploring a complex 'energy' landscape can be adapted to find optimal solutions to challenging combinatorial problems. This practice [@problem_id:2413263] guides you through this conceptual leap by implementing simulated annealing, a Metropolis-based metaheuristic, to tackle the famous Traveling Salesperson Problem (TSP). By mapping a tour's length to an energy function, you will see how the principles of statistical annealing provide a powerful tool for computational optimization, bridging the gap between statistical physics and computer science.", "problem": "You are to implement a simulated annealing procedure, interpreted as a Metropolis algorithm with a time-dependent temperature, to approximately solve instances of the Traveling Salesperson Problem (TSP) by minimizing a physically motivated energy. Your design must start from the canonical Metropolis framework used in the Ising model, and your implementation must apply the same transition rule and Boltzmann acceptance logic on a discrete configuration space representing permutations. The goal is to produce a reproducible program that outputs final tour lengths for a specified test suite. All distances are to be expressed in arbitrary length units (a.u.), and all reported tour lengths must be rounded to six decimal places in a.u.\n\nFundamental base to use and derive from:\n- The Boltzmann distribution at temperature $T$ assigns probability $P(\\boldsymbol{s}) \\propto \\exp\\!\\left(-E(\\boldsymbol{s})/T\\right)$ to configuration $\\boldsymbol{s}$ with energy $E(\\boldsymbol{s})$.\n- The Metropolis transition rule uses the acceptance probability $A(\\boldsymbol{s}\\to\\boldsymbol{s}') = \\min\\!\\left\\{1,\\exp\\!\\left(-\\Delta E/T\\right)\\right\\}$, where $\\Delta E = E(\\boldsymbol{s}')-E(\\boldsymbol{s})$, to satisfy detailed balance with respect to the Boltzmann distribution.\n- Simulated annealing is a nonstationary Metropolis procedure in which the temperature $T$ is gradually reduced according to a cooling schedule $T_{t+1} = \\alpha T_t$ with fixed $0\\alpha1$, starting from an initial temperature $T_0$.\n\nModeling the Traveling Salesperson Problem (TSP) as an energy minimization:\n- Consider $N$ cities with positions $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$ in the plane, and let $d_{ij}$ be the Euclidean distance between $\\boldsymbol{r}_i$ and $\\boldsymbol{r}_j$ in a.u.\n- A tour is a cyclic ordering represented by a permutation $\\boldsymbol{p} = (p_0,p_1,\\dots,p_{N-1})$, where each $p_k$ is a distinct city index in $\\{0,\\dots,N-1\\}$, and $p_N \\equiv p_0$.\n- Define the tour energy (to be minimized) as the total path length\n$$\nE(\\boldsymbol{p}) \\equiv \\sum_{k=0}^{N-1} d_{p_k,\\,p_{k+1}} \\quad \\text{(in a.u.)}.\n$$\n\nAlgorithmic requirement:\n- Use the Metropolis acceptance rule with the above $E(\\boldsymbol{p})$ and a geometric cooling schedule $T_{t+1}=\\alpha T_t$.\n- Use a configuration-space move that preserves the permutation constraint to maintain physical realism analogous to single-spin-flip proposals in the Ising model but adapted to the constrained manifold. For computational efficiency and physical interpretability as a local topological change of a cyclic path, use a $2$-opt move: select indices $i$ and $j$ with $0 \\le i  j \\le N-1$ that are not immediate neighbors on the cycle (including wrap-around), and reverse the segment between them. The energy change $\\Delta E$ must be computed exactly from the distances of the four affected edges only, not by recomputing the full sum.\n- Initialize each run with a permutation drawn uniformly at random from all $N!$ permutations using the given pseudorandom seed.\n\nCooling schedule and parameters to use:\n- Initial temperature $T_0 = 1.0$ (in the same energy units as $E$, i.e., a.u.).\n- Geometric cooling factor $\\alpha = 0.995$.\n- Number of temperature levels $N_T = 1000$.\n- At each temperature level, perform $M = 20N$ independent $2$-opt Metropolis proposals.\n\nTest suite to implement and report:\nFor each test case below, run the simulated annealing with the specified seed and parameters above, then apply a final deterministic $2$-opt descent (repeat any strictly improving $2$-opt move until no such move exists) to ensure a $2$-opt local minimum. Report the final tour length $E(\\boldsymbol{p}_{\\mathrm{final}})$ in a.u., rounded to six decimal places.\n\n- Test case A (convex square on the unit circle): $N=4$, cities at angles $\\theta_k = \\frac{2\\pi k}{4}$ with positions $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$ for $k\\in\\{0,1,2,3\\}$. Use seed $7$.\n- Test case B (regular pentagon on the unit circle): $N=5$, cities at angles $\\theta_k = \\frac{2\\pi k}{5}$ with positions $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$ for $k\\in\\{0,1,2,3,4\\}$. Use seed $13$.\n- Test case C (regular hexagon on the unit circle): $N=6$, cities at angles $\\theta_k = \\frac{2\\pi k}{6}$ with positions $\\boldsymbol{r}_k = (\\cos\\theta_k,\\sin\\theta_k)$ for $k\\in\\{0,1,2,3,4,5\\}$. Use seed $29$.\n\nAngle unit specification: all angles are in radians.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [A,B,C], where each entry is the final tour length in a.u. rounded to six decimal places. For example, a valid output format is like \"[x.xxxxxx,y.yyyyyy,z.zzzzzz]\" with exactly six digits after the decimal point for each value.", "solution": "The problem statement presented is valid. It is scientifically grounded, well-posed, objective, and complete. It describes a standard application of the Metropolis algorithm, in the form of simulated annealing, to a classic combinatorial optimization problemâ€”the Traveling Salesperson Problem (TSP). The physical analogy of minimizing a tour's length as finding a system's ground state energy is a cornerstone of statistical mechanics applications in optimization. All parameters for the algorithm, the initial conditions, and the test cases are specified unambiguously, including pseudorandom seeds to ensure reproducibility. The required move set, the 2-opt move, is a well-defined and standard heuristic for the TSP. The problem is formalizable and algorithmically tractable.\n\nI will now proceed with a detailed derivation and description of the solution.\n\n### 1. Modeling the Traveling Salesperson Problem\n\nThe problem is to find the shortest possible route that visits each city in a given set exactly once and returns to the origin city. This can be mapped to a problem in statistical physics.\n\n- **Configuration Space ($S$):** A state of the system, or a configuration, is a specific tour. For $N$ cities indexed from $0$ to $N-1$, a tour can be represented by a permutation $\\boldsymbol{p} = (p_0, p_1, \\dots, p_{N-1})$ of the city indices. The set of all $N!$ such permutations forms the configuration space.\n\n- **Energy Function ($E$):** The \"energy\" of a configuration $\\boldsymbol{p}$ is defined as the total length of the tour. Given the positions $\\{\\boldsymbol{r}_i\\}_{i=0}^{N-1}$ of the cities, we first compute the Euclidean distance matrix $d_{ij} = ||\\boldsymbol{r}_i - \\boldsymbol{r}_j||_2$. The energy is then:\n$$ E(\\boldsymbol{p}) = \\sum_{k=0}^{N-1} d_{p_k, p_{(k+1) \\pmod N}} $$\nThe goal of the TSP is to find the permutation $\\boldsymbol{p}^*$ that minimizes this energy function, i.e., the ground state of the system.\n\n### 2. The Simulated Annealing Algorithm\n\nSimulated annealing is a metaheuristic inspired by the annealing process in metallurgy. It uses the Metropolis algorithm at a sequence of decreasing temperatures to guide its search for the global minimum of the energy function.\n\n- **Initial State:** The simulation starts with a random tour, generated by drawing a uniform random permutation of the city indices $\\{0, 1, \\dots, N-1\\}$. A pseudorandom number generator initialized with a specific seed is used for reproducibility.\n\n- **Metropolis Step:** At a given temperature $T$, the system transitions from a current configuration $\\boldsymbol{p}$ to a new proposed configuration $\\boldsymbol{p}'$. The transition is accepted with a probability given by the Metropolis criterion:\n$$ A(\\boldsymbol{p} \\to \\boldsymbol{p}') = \\min\\left\\{1, \\exp\\left(-\\frac{\\Delta E}{T}\\right)\\right\\} $$\nwhere $\\Delta E = E(\\boldsymbol{p}') - E(\\boldsymbol{p})$ is the change in energy. If $\\Delta E \\le 0$, the new configuration is better or equal, and the move is always accepted. If $\\Delta E  0$, the move is accepted with a probability $\\exp(-\\Delta E/T)$, allowing the system to occasionally escape local minima.\n\n- **Proposal of a New Configuration (2-Opt Move):** A new tour $\\boldsymbol{p}'$ is generated from the current tour $\\boldsymbol{p}$ by a 2-opt move. This move consists of selecting two indices $i$ and $j$ from the permutation array (with $0 \\le i  j \\le N-1$) and reversing the segment of the tour between them.\nLet the current tour be $\\boldsymbol{p} = (p_0, \\dots, p_{i-1}, p_i, \\dots, p_j, p_{j+1}, \\dots, p_{N-1})$. The new tour $\\boldsymbol{p}'$ is formed by reversing the sub-array from index $i$ to $j$:\n$$ \\boldsymbol{p}' = (p_0, \\dots, p_{i-1}, \\boldsymbol{p_j, p_{j-1}, \\dots, p_i}, p_{j+1}, \\dots, p_{N-1}) $$\nThis operation breaks two edges in the tour, $(p_{(i-1)\\pmod N}, p_i)$ and $(p_j, p_{(j+1)\\pmod N})$, and creates two new edges, $(p_{(i-1)\\pmod N}, p_j)$ and $(p_i, p_{(j+1)\\pmod N})$. The change in energy can be calculated efficiently without re-summing the entire tour length:\n$$ \\Delta E = \\left( d_{p_{(i-1)\\pmod N}, p_j} + d_{p_i, p_{(j+1)\\pmod N}} \\right) - \\left( d_{p_{(i-1)\\pmod N}, p_i} + d_{p_j, p_{(j+1)\\pmod N}} \\right) $$\nTo ensure the move is non-trivial, we must select $i$ and $j$ such that the segment reversal does not correspond to reversing the entire tour (which results in $\\Delta E=0$). We will generate pairs $(i, j)$ and reject them if they correspond to this trivial case.\n\n- **Cooling Schedule:** The temperature $T$ is gradually lowered according to a geometric cooling schedule. Starting from an initial temperature $T_0$, the temperature is updated after a fixed number of Metropolis steps:\n$$ T_{k+1} = \\alpha T_k $$\nwhere $\\alpha \\in (0, 1)$ is the cooling factor. The process is run for a fixed number of temperature levels, $N_T$. At each temperature level, $M = 20N$ Metropolis proposals are performed.\n\n### 3. Final Local Optimization\n\nAfter the simulated annealing process concludes, the final tour may not be a local minimum with respect to 2-opt moves. A deterministic local search, or descent, is performed to guarantee a 2-opt locally optimal solution. This procedure involves systematically checking every possible 2-opt move on the current tour. If a move is found that strictly decreases the tour length ($\\Delta E  0$), it is immediately accepted, and the search is restarted from the new, improved tour. This process is repeated until a full pass over all possible 2-opt moves yields no further improvement.\n\n### 4. Implementation for Test Cases\n\nThe algorithm will be implemented according to the specified parameters:\n- **Initial Temperature:** $T_0 = 1.0$\n- **Cooling Factor:** $\\alpha = 0.995$\n- **Number of Temperature Levels:** $N_T = 1000$\n- **Steps per Temperature:** $M = 20N$\n\nThe city coordinates for each test case are generated on a unit circle: $\\boldsymbol{r}_k = (\\cos(2\\pi k/N), \\sin(2\\pi k/N))$.\n- **Case A:** $N=4$, seed$=7$\n- **Case B:** $N=5$, seed$=13$\n- **Case C:** $N=6$, seed$=29$\n\nFor each case, the full procedure (initialization, simulated annealing, and final 2-opt descent) will be executed. The final tour length, rounded to six decimal places, will be reported.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulated annealing for the TSP test cases.\n    \"\"\"\n    test_cases = [\n        # (N, seed)\n        (4, 7),  # Test case A\n        (5, 13), # Test case B\n        (6, 29)  # Test case C\n    ]\n\n    # Annealing parameters\n    t0 = 1.0\n    alpha = 0.995\n    n_temp_levels = 1000\n\n    results = []\n    for n_cities, seed in test_cases:\n        # Generate city coordinates on a unit circle\n        angles = 2 * np.pi * np.arange(n_cities) / n_cities\n        cities = np.array([np.cos(angles), np.sin(angles)]).T\n        \n        # Pre-compute distance matrix\n        dist_matrix = np.sqrt(\n            np.sum(\n                (cities[:, np.newaxis, :] - cities[np.newaxis, :, :]) ** 2, axis=2\n            )\n        )\n        \n        # Number of Metropolis steps per temperature\n        m_steps = 20 * n_cities\n\n        # Initialize random number generator with seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. INITIALIZATION: Start with a random tour\n        current_tour = rng.permutation(n_cities)\n        current_energy = 0\n        for i in range(n_cities):\n            current_energy += dist_matrix[current_tour[i], current_tour[(i + 1) % n_cities]]\n\n        # 2. SIMULATED ANNEALING\n        t = t0\n        for _ in range(n_temp_levels):\n            for _ in range(m_steps):\n                # Propose a 2-opt move\n                # Select two distinct indices i and j\n                i, j = rng.choice(n_cities, 2, replace=False)\n                if i > j:\n                    i, j = j, i\n                \n                # A reversal of the whole tour is trivial (delta_E=0)\n                # and just wastes computation. Skip it.\n                if i == 0 and j == n_cities - 1:\n                    continue\n\n                # Calculate energy change (Delta E) for the 2-opt move\n                # Edges to be broken: (p[i-1], p[i]) and (p[j], p[j+1])\n                # New edges: (p[i-1], p[j]) and (p[i], p[j+1])\n                p_i_minus_1 = current_tour[i - 1] # works for i=0 due to -1 index\n                p_i = current_tour[i]\n                p_j = current_tour[j]\n                p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                delta_e = (\n                    dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                ) - (\n                    dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                )\n\n                # Metropolis acceptance criterion\n                if delta_e  0 or rng.random()  np.exp(-delta_e / t):\n                    # Accept move: reverse the segment p[i:j+1]\n                    current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                    current_energy += delta_e\n            \n            # Cool down\n            t *= alpha\n            \n        # 3. FINAL 2-OPT LOCAL SEARCH\n        improved = True\n        while improved:\n            improved = False\n            for i in range(n_cities - 1):\n                for j in range(i + 1, n_cities):\n                    # Avoid trivial full reversal\n                    if i == 0 and j == n_cities - 1:\n                        continue\n                    \n                    p_i_minus_1 = current_tour[i - 1]\n                    p_i = current_tour[i]\n                    p_j = current_tour[j]\n                    p_j_plus_1 = current_tour[(j + 1) % n_cities]\n\n                    delta_e = (\n                        dist_matrix[p_i_minus_1, p_j] + dist_matrix[p_i, p_j_plus_1]\n                    ) - (\n                        dist_matrix[p_i_minus_1, p_i] + dist_matrix[p_j, p_j_plus_1]\n                    )\n                    \n                    # Accept any strictly improving move\n                    if delta_e  -1e-9: # Use a small tolerance for float comparison\n                        current_tour[i:j+1] = current_tour[i:j+1][::-1]\n                        current_energy += delta_e\n                        improved = True\n                        # Restart search from the new tour\n                        break\n                if improved:\n                    break\n        \n        results.append(f\"{current_energy:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2413263"}]}