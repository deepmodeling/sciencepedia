{"hands_on_practices": [{"introduction": "Understanding complex systems often begins with analyzing their simplest equilibrium states. This practice grounds our study of boundary conditions by starting with a fundamental physical scenario: the steady-state temperature distribution in a one-dimensional rod. By analytically solving the heat equation with fixed-temperature (Dirichlet) boundary conditions, you will derive the linear temperature profile that serves as an essential benchmark for more complex numerical simulations [@problem_id:946].", "problem": "Consider a one-dimensional, uniform rod of length $L$. The temperature distribution within the rod, denoted by $u(x, t)$, where $x$ is the position along the rod ($0 \\le x \\le L$) and $t$ is time, is governed by the one-dimensional heat equation:\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nHere, $\\alpha$ is the thermal diffusivity of the material, a positive constant.\n\nWe are interested in the steady-state temperature distribution, which is the temperature profile $u(x)$ after a sufficiently long time has passed, such that the temperature no longer changes with time. This implies that $\\frac{\\partial u}{\\partial t} = 0$.\n\nThe ends of the rod are maintained at fixed, constant temperatures. These are known as Dirichlet boundary conditions:\n1. At $x=0$, the temperature is $u(0) = T_0$.\n2. At $x=L$, the temperature is $u(L) = T_1$.\n\nStarting from the heat equation, derive the expression for the steady-state temperature distribution $u(x)$ along the rod as a function of position $x$, the length $L$, and the boundary temperatures $T_0$ and $T_1$.", "solution": "Starting from the steady-state condition $\\frac{\\partial u}{\\partial t}=0$, the heat equation becomes $\\alpha \\frac{d^2u}{dx^2} = 0$. Since $\\alpha \\neq 0$, we must have $\\frac{d^2u}{dx^2} = 0$. Integrating once yields $\\frac{du}{dx}=A$, and integrating again gives the general solution $u(x) = Ax + B$, where $A$ and $B$ are constants. We apply the Dirichlet conditions to solve for the constants. At $x=0$, we have $u(0) = T_0$, so $B=T_0$. At $x=L$, we have $u(L) = T_1$, so $AL + B = T_1$. Substituting $B=T_0$ into the second equation gives $AL + T_0 = T_1$, which yields $A = \\frac{T_1 - T_0}{L}$. Putting the constants back into the general solution, the final steady-state temperature distribution is:\n$$u(x) = T_0 + \\frac{T_1 - T_0}{L}x$$", "answer": "$$\\boxed{T_0 + \\frac{(T_1 - T_0)x}{L}}$$", "id": "946"}, {"introduction": "Transitioning from analytical theory to computational practice requires careful implementation of boundary conditions, especially the Neumann type which specifies a flux or derivative. This exercise dives into the details of the finite difference method, guiding you to derive and implement a second-order accurate scheme for a Neumann condition on a non-uniform grid [@problem_id:2386433]. Mastering this technique is crucial for building accurate simulations where boundary derivatives, such as heat flux or fluid velocity gradients, are prescribed.", "problem": "Consider the one-dimensional steady Poisson equation, a linear second-order partial differential equation (PDE), on the domain $[0,1]$:\n$$\n\\frac{d^2 u}{dx^2} = f(x), \\quad x \\in (0,1),\n$$\nwith mixed boundary conditions: a Dirichlet condition at the left endpoint and a Neumann condition at the right endpoint. Let the exact solution be\n$$\nu_{\\text{exact}}(x) = \\sin(\\pi x) + x,\n$$\nso that\n$$\nf(x) = \\frac{d^2 u_{\\text{exact}}}{dx^2} = -\\pi^2 \\sin(\\pi x), \\quad u(0) = u_{\\text{exact}}(0), \\quad \\frac{du}{dx}(1) = \\frac{du_{\\text{exact}}}{dx}(1).\n$$\nAll quantities are non-dimensional; no physical units are required.\n\nYour task is to derive from first principles and implement a second-order accurate finite difference (FD) method on a nonuniform grid to solve this boundary value problem, with particular attention to the effect of grid point density near the right boundary on the accuracy of imposing the Neumann boundary condition. The derivation must start from Taylor expansions and basic definitions of derivatives, without introducing pre-assembled stencils from external sources.\n\nGrid generation: Use a family of monotone grids parameterized by a clustering parameter $\\gamma \\ge 0$ that controls the density of grid points near $x=1$. For a given integer $N \\ge 2$ (the total number of subintervals), define the reference grid points $\\xi_i = i/N$ for $i=0,1,\\dots,N$, and map them to physical points $x_i \\in [0,1]$ by\n$$\nx_i = \\begin{cases}\n\\xi_i, & \\text{if } \\gamma = 0, \\\\\n1 - \\dfrac{e^{\\gamma (1 - \\xi_i)} - 1}{e^{\\gamma} - 1}, & \\text{if } \\gamma > 0.\n\\end{cases}\n$$\nThis mapping increases the grid point density near $x=1$ as $\\gamma$ increases, while $\\gamma=0$ produces a uniform grid.\n\nDiscretization requirements:\n- For each interior node $x_i$ with $i=1,2,\\dots,N-1$, derive a second-order accurate approximation of $\\dfrac{d^2 u}{dx^2}(x_i)$ on the nonuniform grid using only $x_{i-1}$, $x_i$, $x_{i+1}$ and the corresponding unknowns $u_{i-1}$, $u_i$, $u_{i+1}$. Your derivation must start from Taylor series about $x_i$ for $u(x_{i-1})$ and $u(x_{i+1})$ in terms of $u$ and its derivatives at $x_i$, eliminating lower-order errors to achieve second-order accuracy.\n- At the right boundary $x_N = 1$, derive a second-order accurate one-sided approximation of $\\dfrac{du}{dx}(x_N)$ on the nonuniform grid using a quadratic polynomial interpolation through the last three nodes $x_{N-2}$, $x_{N-1}$, $x_N$. This yields a linear relation between $u_{N-2}$, $u_{N-1}$, $u_N$ and the boundary flux $\\dfrac{du}{dx}(1)$. Do not introduce any auxiliary ghost points; enforce the Neumann boundary condition directly on $u_{N-2}$, $u_{N-1}$, $u_N$.\n- At the left boundary $x_0=0$, enforce the Dirichlet condition by taking $u_0 = u_{\\text{exact}}(0)$ as known.\n\nAssemble the resulting linear system for the unknown vector $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$ and solve it numerically. Then, quantify the accuracy of the computed solution by comparing it to $u_{\\text{exact}}(x)$ at the grid points.\n\nTest suite:\nEvaluate the implementation on the following parameter sets $(N,\\gamma)$:\n- $(40, 0)$,\n- $(40, 1)$,\n- $(40, 3)$,\n- $(40, 8)$,\n- $(12, 3)$.\nFor each parameter set, compute two scalar error metrics:\n1. The root-mean-square (RMS) error over all grid points, defined as\n$$\nE_{\\text{RMS}} = \\sqrt{\\frac{1}{N+1} \\sum_{i=0}^{N} \\left(u_i - u_{\\text{exact}}(x_i)\\right)^2 }.\n$$\n2. The maximum absolute error restricted to the near-boundary region $x \\ge 0.9$, defined as\n$$\nE_{\\text{max,bdry}} = \\max\\left\\{ \\left| u_i - u_{\\text{exact}}(x_i) \\right| \\, : \\, x_i \\ge 0.9 \\right\\}.\n$$\nIf no grid point satisfies $x_i \\ge 0.9$ (which can happen for small $N$ and extreme clustering), then take the near-boundary region to consist of the single rightmost node $x_N$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, append the two floating-point numbers in order: first $E_{\\text{RMS}}$, then $E_{\\text{max,bdry}}$. Concatenate the five test cases in the order listed above, resulting in a list of length $10$. For example, the output must have the form\n$$\n[ E_{\\text{RMS}}^{(1)}, E_{\\text{max,bdry}}^{(1)}, E_{\\text{RMS}}^{(2)}, E_{\\text{max,bdry}}^{(2)}, E_{\\text{RMS}}^{(3)}, E_{\\text{max,bdry}}^{(3)}, E_{\\text{RMS}}^{(4)}, E_{\\text{max,bdry}}^{(4)}, E_{\\text{RMS}}^{(5)}, E_{\\text{max,bdry}}^{(5)} ].\n$$\nAll outputs are non-dimensional real numbers with no units, printed in standard decimal notation.", "solution": "The problem presented is a well-posed one-dimensional boundary value problem for the Poisson equation. It is scientifically grounded, mathematically consistent, and all necessary information for its numerical solution and verification is provided. The method of manufactured solutions is employed, which is a standard and rigorous technique for assessing the accuracy of numerical algorithms. The problem is therefore deemed valid. I will now proceed with the derivation and solution.\n\nThe problem requires the numerical solution of the following differential equation on the domain $x \\in [0, 1]$:\n$$\n\\frac{d^2 u}{dx^2} = f(x)\n$$\nwith the source term $f(x)$ and boundary conditions derived from the specified exact solution $u_{\\text{exact}}(x) = \\sin(\\pi x) + x$.\nThe source term is the second derivative of the exact solution:\n$$\nf(x) = \\frac{d^2}{dx^2} (\\sin(\\pi x) + x) = -\\pi^2 \\sin(\\pi x)\n$$\nThe boundary conditions are of a mixed type:\n- Dirichlet condition at $x=0$: $u(0) = u_{\\text{exact}}(0) = \\sin(0) + 0 = 0$.\n- Neumann condition at $x=1$: $\\frac{du}{dx}(1) = \\frac{d}{dx}|_{x=1} (\\sin(\\pi x) + x) = \\pi \\cos(\\pi x) + 1 |_{x=1} = \\pi \\cos(\\pi) + 1 = 1 - \\pi$.\n\nWe will discretize the domain $[0, 1]$ using a set of $N+1$ grid points $x_0, x_1, \\dots, x_N$, where $x_0=0$ and $x_N=1$. The grid may be non-uniform. The step sizes are defined as $h_i = x_i - x_{i-1}$ for $i=1, \\dots, N$. The unknown values of the solution at the grid points are denoted by $u_i \\approx u(x_i)$.\n\nThe task is to assemble a system of linear equations for the unknown vector $\\mathbf{v} = [u_1, u_2, \\dots, u_N]^T$. Note that $u_0 = 0$ is known and not part of the vector of unknowns.\n\nFirst, we derive the finite difference approximation for the second derivative at an interior node $x_i$, where $i \\in \\{1, \\dots, N-1\\}$. We use Taylor series expansions for $u(x_{i+1})$ and $u(x_{i-1})$ about the point $x_i$:\n$$\nu(x_{i+1}) = u(x_i) + h_{i+1} u'(x_i) + \\frac{h_{i+1}^2}{2} u''(x_i) + \\frac{h_{i+1}^3}{6} u'''(x_i) + \\mathcal{O}(h_{i+1}^4)\n$$\n$$\nu(x_{i-1}) = u(x_i) - h_i u'(x_i) + \\frac{h_i^2}{2} u''(x_i) - \\frac{h_i^3}{6} u'''(x_i) + \\mathcal{O}(h_i^4)\n$$\nwhere $h_{i+1} = x_{i+1} - x_i$ and $h_i = x_i - x_{i-1}$. To eliminate the first derivative term $u'(x_i)$, we multiply the first equation by $h_i$ and the second by $h_{i+1}$ and add them:\n$$\nh_i u_{i+1} + h_{i+1} u_{i-1} = (h_i + h_{i+1}) u_i + \\frac{h_i h_{i+1}^2 + h_{i+1} h_i^2}{2} u''_i + \\frac{h_i h_{i+1}^3 - h_{i+1} h_i^3}{6} u'''_i + \\dots\n$$\n$$\nh_i u_{i+1} + h_{i+1} u_{i-1} = (h_i + h_{i+1}) u_i + \\frac{h_i h_{i+1}(h_i + h_{i+1})}{2} u''_i + \\frac{h_i h_{i+1}(h_{i+1}^2 - h_i^2)}{6} u'''_i + \\dots\n$$\nSolving for $u''_i$, we obtain:\n$$\nu''(x_i) = \\frac{h_i u_{i+1} + h_{i+1} u_{i-1} - (h_i + h_{i+1}) u_i}{\\frac{h_i h_{i+1}(h_i+h_{i+1})}{2}} - \\frac{h_{i+1}-h_i}{3} u'''(x_i) + \\mathcal{O}((h_i+h_{i+1})^2)\n$$\nThe stencil is thus:\n$$\n\\frac{d^2 u}{dx^2}\\bigg|_{x_i} \\approx \\frac{2}{h_i+h_{i+1}} \\left( \\frac{u_{i+1} - u_i}{h_{i+1}} - \\frac{u_i - u_{i-1}}{h_i} \\right) = \\frac{2}{h_i(h_i+h_{i+1})} u_{i-1} - \\frac{2}{h_i h_{i+1}} u_i + \\frac{2}{h_{i+1}(h_i+h_{i+1})} u_{i+1}\n$$\nThe leading term of the truncation error is $\\frac{1}{3}(h_i - h_{i+1}) u'''(x_i)$. For a general non-uniform grid, this stencil is only first-order accurate. However, the problem specifies a grid generated by a smooth mapping $x(\\xi)$. In this case, $h_i = x_i - x_{i-1} = x'( \\xi_{i-1/2} ) \\Delta\\xi + \\mathcal{O}((\\Delta\\xi)^3)$, where $\\Delta\\xi = 1/N$. The difference in step sizes is $h_{i+1} - h_i \\approx x''(\\xi_i)(\\Delta\\xi)^2 = \\mathcal{O}(N^{-2})$. Consequently, the leading error term behaves as $\\mathcal{O}(N^{-2})$, and the scheme is indeed second-order accurate on such a smoothly varying grid.\n\nFor each interior node $i=1, \\dots, N-1$, the discretized PDE is:\n$$\n\\frac{2}{h_i(h_i+h_{i+1})} u_{i-1} - \\frac{2}{h_i h_{i+1}} u_i + \\frac{2}{h_{i+1}(h_i+h_{i+1})} u_{i+1} = f(x_i)\n$$\n\nNext, we derive the second-order one-sided approximation for the Neumann condition $\\frac{du}{dx}(x_N) = g_N = 1-\\pi$. We use a Taylor series expansion for $u_{N-1}$ and $u_{N-2}$ around $x_N$:\n$$\nu_{N-1} = u_N - h_N u'(x_N) + \\frac{h_N^2}{2} u''(x_N) + \\mathcal{O}(h_N^3)\n$$\n$$\nu_{N-2} = u_N - (h_N + h_{N-1}) u'(x_N) + \\frac{(h_N + h_{N-1})^2}{2} u''(x_N) + \\mathcal{O}((h_N + h_{N-1})^3)\n$$\nwhere $h_N = x_N - x_{N-1}$ and $h_{N-1} = x_{N-1} - x_{N-2}$. We eliminate the second derivative term $u''(x_N)$. From the first equation, $\\frac{1}{2}u''(x_N) = \\frac{u_{N-1} - u_N + h_N u'_N}{h_N^2}+\\mathcal{O}(h_N)$. Substituting this into the second equation creates an inconsistent mixture of error terms. A more sound procedure is to combine the two equations to eliminate $u''$:\nMultiply the first equation by $(h_N+h_{N-1})^2$ and the second by $h_N^2$, then subtract the second from the first.\n$$\n(h_N+h_{N-1})^2 u_{N-1} - h_N^2 u_{N-2} = ((h_N+h_{N-1})^2 - h_N^2) u_N - [h_N(h_N+h_{N-1})^2 - h_N^2(h_N+h_{N-1})] u'_N + \\mathcal{O}(h^4)\n$$\nThe term multiplying $u'_N$ simplifies to $h_N(h_N+h_{N-1})[(h_N+h_{N-1})-h_N] = h_N h_{N-1}(h_N+h_{N-1})$.\nSolving for $u'_N$:\n$$\nu'(x_N) = \\frac{h_N^2 u_{N-2} - (h_N+h_{N-1})^2 u_{N-1} + (2h_N h_{N-1} + h_{N-1}^2) u_N}{h_N h_{N-1}(h_N+h_{N-1})} + \\mathcal{O}(h_N h_{N-1})\n$$\nThe stencil for the Neumann boundary condition is:\n$$\n\\frac{h_N}{h_{N-1}(h_N+h_{N-1})} u_{N-2} - \\frac{h_N+h_{N-1}}{h_N h_{N-1}} u_{N-1} + \\frac{2h_N+h_{N-1}}{h_N(h_N+h_{N-1})} u_N = g_N\n$$\nThis approximation is second-order accurate.\n\nWe construct an $N \\times N$ linear system $A\\mathbf{v}=\\mathbf{b}$ for the unknown vector $\\mathbf{v} = [u_1, \\dots, u_N]^T$.\n\nThe first $N-1$ rows correspond to the interior points $i=1, \\dots, N-1$. Using 0-based indexing for the matrix $A$ (rows/columns $k=0, \\dots, N-1$) and vector $\\mathbf{b}$ (entries $k=0, \\dots, N-1$):\nFor $k=0$ (point $i=1$):\n$$\nA_{0,0} = -\\frac{2}{h_1 h_2} \\quad , \\quad A_{0,1} = \\frac{2}{h_2(h_1+h_2)}\n$$\n$$\nb_0 = f(x_1) - \\frac{2}{h_1(h_1+h_2)}u_0 = f(x_1) \\quad (\\text{since } u_0=0)\n$$\nFor $k=1, \\dots, N-2$ (points $i=2, \\dots, N-1$), the equation for $u_i$ populates row $k=i-1$ of the matrix:\n$$\nA_{k, k-1} = \\frac{2}{h_{k+1}(h_{k+1}+h_{k+2})} \\quad , \\quad A_{k, k} = -\\frac{2}{h_{k+1} h_{k+2}} \\quad , \\quad A_{k, k+1} = \\frac{2}{h_{k+2}(h_{k+1}+h_{k+2})}\n$$\n$$\nb_k = f(x_{k+1})\n$$\nThe last row, $k=N-1$, is from the Neumann boundary condition at $i=N$:\n$$\nA_{N-1, N-3} = \\frac{h_N}{h_{N-1}(h_N+h_{N-1})}\n$$\n$$\nA_{N-1, N-2} = -\\frac{h_N+h_{N-1}}{h_N h_{N-1}}\n$$\n$$\nA_{N-1, N-1} = \\frac{2h_N+h_{N-1}}{h_N(h_N+h_{N-1})}\n$$\n$$\nb_{N-1} = g_N = 1-\\pi\n$$\nThis fully defines the linear system. The matrix $A$ is almost tridiagonal, with the exception of the last row having three non-zero entries. This system can be efficiently solved using a standard linear solver. Once the vector $\\mathbf{v}$ is found, the complete numerical solution on the grid is given by $[u_0, v_0, v_1, \\dots, v_{N-1}]$. The error is then evaluated by comparison against $u_{\\text{exact}}(x_i)$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Main function to solve the BVP for all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (40, 0),\n        (40, 1),\n        (40, 3),\n        (40, 8),\n        (12, 3),\n    ]\n\n    results = []\n    for N, gamma in test_cases:\n        u_numerical, x_grid = solve_bvp(N, gamma)\n        u_exact_vals = u_exact(x_grid)\n        \n        # 1. Root-Mean-Square (RMS) error\n        N_points = N + 1\n        rms_error = np.sqrt(np.sum((u_numerical - u_exact_vals)**2) / N_points)\n        \n        # 2. Maximum absolute error in the near-boundary region x >= 0.9\n        boundary_region_indices = np.where(x_grid >= 0.9)[0]\n        if len(boundary_region_indices) == 0:\n            # If no points in region, use the rightmost node as per problem spec\n            boundary_region_indices = np.array([N])\n            \n        max_boundary_error = np.max(np.abs(u_numerical[boundary_region_indices] - u_exact_vals[boundary_region_indices]))\n        \n        results.extend([rms_error, max_boundary_error])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_bvp(N, gamma):\n    \"\"\"\n    Solves the 1D Poisson BVP for a given N and gamma.\n    \n    Args:\n        N (int): Number of subintervals.\n        gamma (float): Grid clustering parameter.\n        \n    Returns:\n        tuple: (u_numerical, x) where u_numerical is the solution on grid x.\n    \"\"\"\n    \n    # 1. Grid Generation\n    xi = np.linspace(0.0, 1.0, N + 1)\n    if gamma == 0:\n        x = xi\n    else:\n        x = 1.0 - (np.exp(gamma * (1.0 - xi)) - 1.0) / (np.exp(gamma) - 1.0)\n\n    # 2. Setup Linear System A*v = b for unknowns v = [u_1, ..., u_N]\n    A = np.zeros((N, N))\n    b = np.zeros(N)\n    \n    # Grid spacings h_i = x_i - x_{i-1}\n    # h_steps[i-1] corresponds to h_i\n    h_steps = np.diff(x)\n\n    # Boundary value at x=0\n    u0 = u_exact(x[0]) # which is 0\n\n    # 3. Populate matrix A and vector b\n    \n    # First N-1 rows for interior points i = 1, ..., N-1\n    for i in range(1, N):\n        h_i = h_steps[i - 1]\n        h_i_plus_1 = h_steps[i]\n        \n        # Coefficients for u_{i-1}, u_i, u_{i+1}\n        coeff_im1 = 2.0 / (h_i * (h_i + h_i_plus_1))\n        coeff_i = -2.0 / (h_i * h_i_plus_1)\n        coeff_ip1 = 2.0 / (h_i_plus_1 * (h_i + h_i_plus_1))\n        \n        # Row index k = i - 1\n        k = i - 1\n        \n        if i == 1: # Equation for u_1\n            # A[k, k] corresponds to u_1, A[k, k+1] to u_2\n            A[k, k] = coeff_i\n            A[k, k + 1] = coeff_ip1\n            # u_0 term moves to RHS\n            b[k] = f_source(x[i]) - coeff_im1 * u0\n        else: # Equation for u_i, i > 1\n            # A[k, k-1] -> u_{i-1}, A[k, k] -> u_i, A[k, k+1] -> u_{i+1}\n            A[k, k - 1] = coeff_im1\n            A[k, k] = coeff_i\n            A[k, k + 1] = coeff_ip1\n            b[k] = f_source(x[i])\n            \n    # Last row for Neumann boundary condition at x_N = 1\n    h_N = h_steps[N - 1]\n    h_Nm1 = h_steps[N - 2]\n    \n    # Point i = N, corresponds to row k = N - 1\n    k = N - 1\n    \n    # Coefficients for u_{N-2}, u_{N-1}, u_N\n    coeff_Nm2 = h_N / (h_Nm1 * (h_N + h_Nm1))\n    coeff_Nm1 = -(h_N + h_Nm1) / (h_N * h_Nm1)\n    coeff_N = (2.0 * h_N + h_Nm1) / (h_N * (h_N + h_Nm1))\n    \n    # A[k, k-2] -> u_{N-2}, A[k, k-1] -> u_{N-1}, A[k, k] -> u_N\n    A[k, k - 2] = coeff_Nm2\n    A[k, k - 1] = coeff_Nm1\n    A[k, k] = coeff_N\n    \n    g_N = 1.0 - np.pi # Boundary value du/dx(1)\n    b[k] = g_N\n\n    # 4. Solve the system\n    u_unknowns = solve_linear_system(A, b)\n\n    # 5. Assemble full solution vector [u_0, u_1, ..., u_N]\n    u_numerical = np.concatenate(([u0], u_unknowns))\n    \n    return u_numerical, x\n\ndef u_exact(x):\n    \"\"\"\n    Exact solution u(x) = sin(pi*x) + x.\n    \"\"\"\n    return np.sin(np.pi * x) + x\n\ndef f_source(x):\n    \"\"\"\n    Source term f(x) = d^2(u_exact)/dx^2 = -pi^2 * sin(pi*x).\n    \"\"\"\n    return -(np.pi**2) * np.sin(np.pi * x)\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2386433"}, {"introduction": "This advanced practice challenges you to synthesize your skills by modeling a realistic physical system: the acoustic resonances within a T-shaped tube network. You will use the powerful Finite Element Method (FEM) to solve the wave equation, combining Dirichlet (open end), Neumann (closed end), and junction (conservation law) conditions in a single framework [@problem_id:2386432]. Successfully completing this problem demonstrates the ability to apply boundary condition principles to complex geometries and advanced numerical methods.", "problem": "Consider small-amplitude, one-dimensional linear acoustics for air in a T-shaped tube comprised of three straight branches that meet at a single junction node. Let the acoustic pressure be denoted by $p(x,t)$, the spatial coordinate along a branch by $x$, and the speed of sound by $c$. Neglect viscous and thermal losses and assume the plane-wave approximation holds (tube diameters are sufficiently small compared to the wavelengths of interest). On each branch, the governing equation is the one-dimensional wave equation $p_{tt} = c^2 p_{xx}$. At the open end of the stem, impose a Dirichlet boundary condition $p = 0$. At the two closed ends of the arms, impose Neumann boundary conditions $p_x = 0$. At the junction, impose continuity of pressure across all incident branches and conservation of volume velocity, which reduces in one dimension to the Kirchhoff condition that the sum of outward volume velocity fluxes vanishes: $\\sum_{i=1}^3 A_i \\, p_x^{(i)}(0,t) = 0$, where $A_i$ is the cross-sectional area of branch $i$ and $x=0$ is the junction coordinate for each branch with $x$ increasing outward along that branch.\n\nFormulate the time-harmonic eigenvalue problem by seeking separable solutions $p(x,t) = \\Re\\{ \\phi(x) e^{\\mathrm{i}\\omega t} \\}$, where $\\omega$ is the angular frequency and $\\phi(x)$ is the complex-valued spatial mode shape. Show that on each branch the spatial component satisfies the Helmholtz equation $-\\phi''(x) = k^2 \\phi(x)$ with $k = \\omega/c$, together with the boundary conditions described above and the junction conditions $\\phi$ continuous and $\\sum_{i=1}^3 A_i \\, \\phi_x^{(i)}(0) = 0$.\n\nDerive the finite element weak form on the network from the fundamental base of the one-dimensional wave equation and integration by parts. Using continuous, piecewise-linear shape functions on each branch, assemble the global stiffness matrix $K$ and mass matrix $M$ such that the discrete generalized eigenproblem $K \\mathbf{u} = \\lambda M \\mathbf{u}$ holds, with $\\lambda = \\omega^2/c^2$. Impose the Dirichlet boundary condition at the open end of the stem as an essential constraint. The Neumann boundary conditions at the closed ends are natural and require no explicit modification. The junction continuity is enforced by sharing the junction node across all incident branches; the Kirchhoff flux condition is enforced implicitly by assembling elemental contributions weighted by cross-sectional area.\n\nImplement a program that:\n- Constructs the global finite element matrices $K$ and $M$ for a T-shaped tube comprised of three branches meeting at a single junction, with branch-specific lengths and cross-sectional areas, using $n$ uniform linear elements per branch.\n- Solves the generalized symmetric eigenproblem $K \\mathbf{u} = \\lambda M \\mathbf{u}$ and computes the smallest positive eigenfrequency $f_1 = \\omega_1/(2\\pi)$ in Hertz, where $\\omega_1 = c \\sqrt{\\lambda_1}$.\n- Uses the speed of sound $c$ given in meters per second.\n- Reports frequencies in Hertz, rounded to two decimal places.\n\nUse the following test suite. In all cases, the stem is the branch with the Dirichlet boundary condition at its free end (open end), and the two arms have Neumann boundary conditions (closed ends). All lengths are in meters, all areas are in square meters, and $c$ is in meters per second. For each case, also specify the number of uniform linear elements per branch.\n\n- Case A (symmetric arms, equal areas; happy path):\n  - $c = 343$\n  - Stem length $L_s = 0.60$, Arm $1$ length $L_1 = 0.40$, Arm $2$ length $L_2 = 0.40$\n  - Stem area $A_s = 2.0\\times 10^{-4}$, Arm $1$ area $A_1 = 2.0\\times 10^{-4}$, Arm $2$ area $A_2 = 2.0\\times 10^{-4}$\n  - Elements: stem $n_s = 120$, Arm $1$ $n_1 = 80$, Arm $2$ $n_2 = 80$\n\n- Case B (asymmetric arm lengths; geometric edge case):\n  - $c = 343$\n  - $L_s = 0.60$, $L_1 = 0.20$, $L_2 = 0.80$\n  - $A_s = 2.0\\times 10^{-4}$, $A_1 = 2.0\\times 10^{-4}$, $A_2 = 2.0\\times 10^{-4}$\n  - $n_s = 120$, $n_1 = 40$, $n_2 = 160$\n\n- Case C (symmetric arm lengths; unequal areas; junction-weighting edge case):\n  - $c = 343$\n  - $L_s = 0.60$, $L_1 = 0.40$, $L_2 = 0.40$\n  - $A_s = 2.0\\times 10^{-4}$, $A_1 = 1.0\\times 10^{-4}$, $A_2 = 4.0\\times 10^{-4}$\n  - $n_s = 120$, $n_1 = 80$, $n_2 = 80$\n\nYour program must compute, for each case, the fundamental frequency $f_1$ in Hertz as a floating-point number rounded to two decimal places. The final output format must be a single line containing the results as a comma-separated list enclosed in square brackets, in the order [Case A result, Case B result, Case C result], for example, \"[$f_A$,$f_B$,$f_C$]\". No additional text should be printed. All outputs must be in Hertz.", "solution": "The problem presented is a standard eigenvalue problem in computational acoustics, requiring formulation and solution via the finite element method. Before proceeding to the solution, a rigorous validation is necessary.\n\n**Problem Validation**\n\n1.  **Givens Extraction**:\n    *   Governing Equation: One-dimensional wave equation, $p_{tt} = c^2 p_{xx}$.\n    *   Domain: A T-shaped tube network of three branches meeting at a junction.\n    *   Boundary Conditions (BCs): Dirichlet BC $p=0$ at the open end of the stem; Neumann BC $p_x=0$ at the closed ends of the two arms.\n    *   Junction Conditions: Continuity of pressure, $\\phi$ continuous at junction; Kirchhoff's law for volume velocity flux, $\\sum_{i=1}^3 A_i \\, p_x^{(i)}(0,t) = 0$, with $x=0$ at the junction.\n    *   Assumed Solution Form: $p(x,t) = \\Re\\{ \\phi(x) e^{\\mathrm{i}\\omega t} \\}$.\n    *   Derived Spatial Problem: Helmholtz equation $-\\phi''(x) = k^2 \\phi(x)$ with $k = \\omega/c$, subject to the given BCs and junction conditions on $\\phi(x)$.\n    *   Numerical Method: Finite Element Method (FEM) using continuous, piecewise-linear shape functions to formulate a discrete generalized eigenproblem $K \\mathbf{u} = \\lambda M \\mathbf{u}$ where $\\lambda = \\omega^2/c^2$.\n    *   Task: Compute the smallest positive eigenfrequency $f_1 = \\omega_1/(2\\pi) = c\\sqrt{\\lambda_1}/(2\\pi)$ for three specific test cases.\n    *   Test Cases: Specific values for speed of sound $c$, branch lengths $L_i$, cross-sectional areas $A_i$, and number of elements per branch $n_i$ are provided.\n\n2.  **Validation Check**:\n    *   **Scientific Grounding**: The problem is fundamentally based on the linear wave equation, which is the standard model for small-amplitude acoustics. The boundary conditions and junction principles (Kirchhoff's laws) are well-established in acoustics. The use of the finite element method to solve the resulting Helmholtz eigenvalue problem is a standard and robust technique in computational physics. The problem is scientifically sound.\n    *   **Well-Posedness**: The problem is to find the eigenvalues of a second-order differential operator with specified boundary conditions. This constitutes a Sturm-Liouville type problem on a network graph, which is known to be well-posed and to possess a discrete spectrum of real eigenvalues. The request for the smallest positive eigenfrequency is unambiguous.\n    *   **Objectivity**: The problem is stated using precise, objective, and quantitative language. All necessary physical and discretization parameters are provided.\n    *   **Completeness and Consistency**: The problem is self-contained. It provides all data required for its numerical solution. There are no contradictions in the setup.\n    *   **Other Flaws**: The problem is not unrealistic, ill-posed, unverifiable, or non-formalizable. The setup is a classic textbook example of applying FEM to a network domain.\n\n3.  **Verdict**: The problem is valid. A reasoned solution may be constructed.\n\n**Derivation of the Finite Element Formulation**\n\nThe analysis begins with the time-harmonic wave equation, which is the Helmholtz equation, defined on each branch $i$ of the T-tube network. To correctly account for the physical conservation law at the junction, we consider the area-weighted form of the equation:\n$$\n-A_i \\phi_i''(x) = k^2 A_i \\phi_i(x) \\quad \\text{for } x \\in (0, L_i)\n$$\nwhere $\\phi_i(x)$ is the spatial pressure mode on branch $i$, $A_i$ is its cross-sectional area, $L_i$ is its length, and $k^2 = \\lambda = \\omega^2/c^2$ is the eigenvalue to be determined.\n\nTo derive the weak form, we multiply by an arbitrary test function $v(x)$ (which adheres to the same continuity and essential boundary conditions as $\\phi$) and integrate over the entire domain $\\Omega = \\bigcup_i [0, L_i]$:\n$$\n\\sum_{i=1}^3 \\int_{0}^{L_i} -A_i \\phi_i''(x) v(x) \\, dx = \\lambda \\sum_{i=1}^3 \\int_{0}^{L_i} A_i \\phi_i(x) v(x) \\, dx\n$$\nApplying integration by parts to the left-hand side term for each branch yields:\n$$\n\\int_{0}^{L_i} -A_i \\phi_i'' v \\, dx = \\left[-A_i \\phi_i' v\\right]_0^{L_i} + \\int_{0}^{L_i} A_i \\phi_i' v' \\, dx\n$$\nSumming over all three branches (stem $s$, arm 1, arm 2), the full equation becomes:\n$$\n\\sum_{i=s,1,2} \\int_{0}^{L_i} A_i \\phi_i' v' \\, dx + \\sum_{i=s,1,2} \\left[-A_i \\phi_i' v\\right]_0^{L_i} = \\lambda \\sum_{i=s,1,2} \\int_{0}^{L_i} A_i \\phi_i v \\, dx\n$$\nThe boundary terms are analyzed at the external ends ($x=L_i$) and the internal junction ($x=0$):\n*   At the open end of the stem ($x=L_s$), we have a Dirichlet condition $\\phi_s(L_s)=0$. This is an essential boundary condition, meaning it must be imposed on the space of solutions. We enforce this by requiring the test function to also be zero at this point, $v(L_s)=0$. Thus, the boundary term at $x=L_s$ vanishes.\n*   At the closed ends of the arms ($x=L_1, x=L_2$), we have Neumann conditions $\\phi_1'(L_1)=0$ and $\\phi_2'(L_2)=0$. These are natural boundary conditions. The boundary terms $-A_1 \\phi_1'(L_1) v(L_1)$ and $-A_2 \\phi_2'(L_2) v(L_2)$ vanish automatically due to these conditions, without any constraint on the test function $v$.\n*   At the junction ($x=0$), the sum of boundary terms is $\\sum_{i=s,1,2} A_i \\phi_i'(0) v_i(0)$. By pressure continuity, $\\phi_s(0)=\\phi_1(0)=\\phi_2(0)$, a property that is also imposed on the test function $v$, so $v_s(0)=v_1(0)=v_2(0) \\equiv v(0)$. The sum becomes $v(0) \\sum_{i} A_i \\phi_i'(0)$. The Kirchhoff condition requires the net volume velocity flux to be zero, which translates to $\\sum_{i} A_i \\phi_i'(0) = 0$. This is also a natural boundary condition, and it forces the sum of junction boundary terms to be zero.\n\nWith all boundary terms eliminated, the weak formulation is: find $\\phi$ (satisfying $\\phi_s(L_s)=0$) such that for all admissible test functions $v$ (satisfying $v(L_s)=0$):\n$$\n\\underbrace{\\sum_{i=s,1,2} \\int_{0}^{L_i} A_i \\phi' v' \\, dx}_{a(\\phi, v)} = \\lambda \\underbrace{\\sum_{i=s,1,2} \\int_{0}^{L_i} A_i \\phi v \\, dx}_{b(\\phi, v)}\n$$\nThis is a variational form $a(\\phi,v) = \\lambda b(\\phi,v)$, which leads to the generalized matrix eigenvalue problem.\n\nFor discretization, we use continuous, piecewise-linear basis functions (hat functions) $N_j(x)$ on a mesh of $n_i$ elements for each branch $i$. We approximate the solution as $\\phi_h(x) = \\sum_{j} u_j N_j(x)$, where $u_j$ are the unknown pressure values at the nodes. Using the Galerkin method, where the test functions are chosen from the same basis, $v_h(x) = N_i(x)$, we obtain the matrix system $K \\mathbf{u} = \\lambda M \\mathbf{u}$, with matrix elements:\n$$\nK_{ij} = a(N_j, N_i) \\quad \\text{and} \\quad M_{ij} = b(N_j, N_i)\n$$\nFor a single linear element of length $h$ and area $A$, the local element stiffness and mass matrices, $k^e$ and $m^e$, are calculated as:\n$$\nk^e = \\frac{A}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad m^e = \\frac{Ah}{6} \\begin{pmatrix} 2 & 1 \\\\ 1 & 2 \\end{pmatrix}\n$$\nThe global matrices $K$ and $M$ are assembled by summing the contributions from all elements, correctly mapped to the global degrees of freedom. The continuity at the junction is physically enforced by assigning a single global node index to the junction, to which the first element of each of the three branches connects. The area-weighting $A_i$ required by the Kirchhoff condition is naturally included through its presence in the element matrix formulas.\n\nFinally, the essential Dirichlet condition $\\phi_s(L_s)=0$ is imposed by eliminating the row and column corresponding to the node at the end of the stem from the global matrices $K$ and $M$. The resulting reduced system is solved for the smallest eigenvalue $\\lambda_1$. The fundamental natural frequency is then computed as $f_1 = \\frac{c}{2\\pi}\\sqrt{\\lambda_1}$.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: Symmetric arms, equal areas\n        {\n            \"c\": 343, \"Ls\": 0.60, \"L1\": 0.40, \"L2\": 0.40,\n            \"As\": 2.0e-4, \"A1\": 2.0e-4, \"A2\": 2.0e-4,\n            \"ns\": 120, \"n1\": 80, \"n2\": 80\n        },\n        # Case B: Asymmetric arm lengths\n        {\n            \"c\": 343, \"Ls\": 0.60, \"L1\": 0.20, \"L2\": 0.80,\n            \"As\": 2.0e-4, \"A1\": 2.0e-4, \"A2\": 2.0e-4,\n            \"ns\": 120, \"n1\": 40, \"n2\": 160\n        },\n        # Case C: Symmetric arm lengths, unequal areas\n        {\n            \"c\": 343, \"Ls\": 0.60, \"L1\": 0.40, \"L2\": 0.40,\n            \"As\": 2.0e-4, \"A1\": 1.0e-4, \"A2\": 4.0e-4,\n            \"ns\": 120, \"n1\": 80, \"n2\": 80\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f1 = solve_fem_acoustics(**case)\n        results.append(f\"{f1:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef assemble(K, M, i, j, A, h):\n    \"\"\"\n    Assembles a 1D linear element's stiffness and mass matrices into global matrices.\n    \n    Args:\n        K (np.ndarray): Global stiffness matrix.\n        M (np.ndarray): Global mass matrix.\n        i (int): Global index of the first node.\n        j (int): Global index of the second node.\n        A (float): Cross-sectional area of the element's branch.\n        h (float): Length of the element.\n    \"\"\"\n    ke = (A / h) * np.array([[1, -1], [-1, 1]])\n    me = (A * h / 6) * np.array([[2, 1], [1, 2]])\n    \n    indices = np.ix_([i, j], [i, j])\n    K[indices] += ke\n    M[indices] += me\n\ndef solve_fem_acoustics(c, Ls, L1, L2, As, A1, A2, ns, n1, n2):\n    \"\"\"\n    Constructs and solves the FEM eigenproblem for a T-tube.\n\n    Returns:\n        float: The fundamental frequency f1 in Hertz.\n    \"\"\"\n    # Total number of nodes = junction (1) + stem nodes + arm1 nodes + arm2 nodes\n    num_nodes = 1 + ns + n1 + n2\n    \n    # Initialize global stiffness (K) and mass (M) matrices\n    K = np.zeros((num_nodes, num_nodes))\n    M = np.zeros((num_nodes, num_nodes))\n\n    # Node indexing\n    # Node 0: Junction\n    # Nodes 1 to ns: Stem\n    # Nodes ns+1 to ns+n1: Arm 1\n    # Nodes ns+n1+1 to ns+n1+n2: Arm 2\n    \n    # Assemble Stem Branch\n    hs = Ls / ns\n    # First element: junction to first stem node\n    assemble(K, M, 0, 1, As, hs)\n    # Remaining elements along the stem\n    for i in range(1, ns):\n        assemble(K, M, i, i + 1, As, hs)\n\n    # Assemble Arm 1 Branch\n    h1 = L1 / n1\n    # First element: junction to first arm1 node\n    assemble(K, M, 0, ns + 1, A1, h1)\n    # Remaining elements along arm 1\n    for i in range(1, n1):\n        assemble(K, M, ns + i, ns + i + 1, A1, h1)\n        \n    # Assemble Arm 2 Branch\n    h2 = L2 / n2\n    # First element: junction to first arm2 node\n    assemble(K, M, 0, ns + n1 + 1, A2, h2)\n    # Remaining elements along arm 2\n    for i in range(1, n2):\n        assemble(K, M, ns + n1 + i, ns + n1 + i + 1, A2, h2)\n\n    # Impose Dirichlet boundary condition at the end of the stem (node ns)\n    # This is done by removing the corresponding row and column.\n    dirichlet_node_idx = ns\n    \n    free_dofs = np.delete(np.arange(num_nodes), dirichlet_node_idx)\n    \n    K_red = K[np.ix_(free_dofs, free_dofs)]\n    M_red = M[np.ix_(free_dofs, free_dofs)]\n    \n    # Solve the generalized eigenvalue problem K*u = lambda*M*u\n    # scipy.linalg.eigh returns eigenvalues in ascending order.\n    eigenvalues, _ = linalg.eigh(K_red, M_red)\n    \n    # The smallest eigenvalue lambda_1 (k^2). It must be positive.\n    # The solver might return very small negative values due to numerical precision.\n    lambda_1 = eigenvalues[0]\n    if lambda_1  0:\n        lambda_1 = 0 # Or handle error, but for this problem it should be positive.\n\n    # Calculate the fundamental frequency f1\n    # lambda = (omega/c)^2 => omega = c * sqrt(lambda)\n    # f = omega / (2*pi)\n    omega_1 = c * np.sqrt(lambda_1)\n    f1 = omega_1 / (2 * np.pi)\n    \n    return f1\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2386432"}]}