{"hands_on_practices": [{"introduction": "The Crank-Nicolson scheme is a prominent member of the wider family of $\\theta$-methods for time integration, and this practice allows you to computationally explore the stability of this family. By calculating the spectral radius of the time-evolution operator for cases ranging from the explicit Forward Euler ($\\theta=0$) to the fully implicit Backward Euler ($\\theta=1$), you will gain a hands-on understanding of conditional and unconditional stability [@problem_id:2443588]. This exercise solidifies the theoretical advantages of the Crank-Nicolson scheme for stiff problems and clarifies the practical meaning of numerical stability conditions.", "problem": "Implement a program that analyzes the generalized $\\theta$-method in time for the one-dimensional heat equation using a uniform spatial discretization and periodic boundary conditions, and classifies stability for specified parameter sets.\n\nMathematical model and discretization:\n- Continuous problem: the heat equation $u_t = \\alpha u_{xx}$ on the periodic domain $x \\in [0, L)$ with $L = 1$, where $\\alpha > 0$ is a constant, and all quantities are dimensionless.\n- Spatial discretization: use $N$ uniform points with grid spacing $h = L/N$. Define the discrete second derivative operator (discrete Laplacian) $D \\in \\mathbb{R}^{N \\times N}$ by\n$$\n(D \\mathbf{u})_i = \\frac{\\mathbf{u}_{i-1} - 2 \\mathbf{u}_i + \\mathbf{u}_{i+1}}{h^2},\n$$\nwith periodic indexing, i.e., $\\mathbf{u}_{-1} \\equiv \\mathbf{u}_{N-1}$ and $\\mathbf{u}_{N} \\equiv \\mathbf{u}_{0}$.\n- Time discretization: for time step $\\Delta t > 0$ and parameter $\\theta \\in [0,1]$, define the one-step update operator $M \\in \\mathbb{R}^{N \\times N}$ of the generalized $\\theta$-method by\n$$\n\\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)\\,\\mathbf{u}^{n+1} = \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right)\\,\\mathbf{u}^{n},\n$$\nso that\n$$\nM = \\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)^{-1} \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right).\n$$\n\nStability criterion to classify each parameter set:\n- Define the spectral radius $\\rho(M)$ as the maximum magnitude of the eigenvalues of $M$.\n- A parameter set is classified as stable if $\\rho(M) \\le 1 + \\varepsilon$, where $\\varepsilon = 10^{-10}$ is a fixed numerical tolerance; otherwise it is classified as unstable.\n\nTest suite:\nUse the following six parameter sets, each with $L = 1$ and $\\alpha = 1$:\n1. $N = 64$, $\\theta = 0$, $\\Delta t = 0.25\\,h^2$.\n2. $N = 64$, $\\theta = 0$, $\\Delta t = 0.75\\,h^2$.\n3. $N = 64$, $\\theta = 0.5$, $\\Delta t = 30\\,h^2$.\n4. $N = 64$, $\\theta = 1$, $\\Delta t = 100\\,h^2$.\n5. $N = 64$, $\\theta = 0.25$, $\\Delta t = 1\\,h^2$.\n6. $N = 64$, $\\theta = 0.49$, $\\Delta t = 30\\,h^2$.\n\nRequired final output format:\n- Your program should produce a single line of output containing the six boolean stability classifications, in order of the test suite above, as a comma-separated list enclosed in square brackets, for example, $[\\text{True},\\text{False},\\dots]$.", "solution": "The problem posed is to determine the numerical stability of the generalized $\\theta$-method for the one-dimensional heat equation, $u_t = \\alpha u_{xx}$, on a periodic domain. The analysis is to be performed for six specific sets of parameters. The problem is well-defined, scientifically sound, and represents a standard topic in computational scienceâ€”the stability analysis of finite difference schemes.\n\nThe analysis hinges on the spectral radius, $\\rho(M)$, of the one-step time evolution operator $M$. The scheme is defined as stable if $\\rho(M) \\le 1 + \\varepsilon$ for a given numerical tolerance $\\varepsilon = 10^{-10}$. The operator $M$ is given by\n$$\nM = \\left(I - \\theta \\,\\alpha \\,\\Delta t \\, D \\right)^{-1} \\left(I + (1-\\theta)\\,\\alpha \\,\\Delta t \\, D \\right),\n$$\nwhere $I$ is the identity matrix, $D$ is the matrix representing the discrete spatial second derivative, $\\Delta t$ is the time step, $\\alpha$ is the thermal diffusivity, and $\\theta$ is the parameter of the method.\n\nA direct numerical computation involving the construction of the $N \\times N$ matrix $M$ and the subsequent calculation of its eigenvalues is a valid but computationally inefficient approach. A more rigorous and elegant method, which we shall follow, is to perform a modal analysis. The eigenvectors of the discrete Laplacian $D$ are the discrete Fourier modes, which also form a basis of eigenvectors for the operator $M$. Consequently, the eigenvalues of $M$, denoted by $\\mu_k$, can be expressed directly in terms of the eigenvalues of $D$, denoted by $\\lambda_k$. If $\\mathbf{v}_k$ is an eigenvector of $D$ with eigenvalue $\\lambda_k$, then it is also an eigenvector of $M$ with eigenvalue\n$$\n\\mu_k = \\frac{1 + (1-\\theta)\\alpha \\Delta t \\lambda_k}{1 - \\theta \\alpha \\Delta t \\lambda_k}.\n$$\nThis expression is the amplification factor for the $k$-th mode. The stability of the scheme is thus determined by the maximum magnitude of these amplification factors over all modes, i.e., $\\rho(M) = \\max_k |\\mu_k|$.\n\nThe discrete Laplacian $D$ for a uniform grid with $N$ points, spacing $h = L/N$, and periodic boundary conditions is a circulant matrix. Its eigenvalues are known analytically:\n$$\n\\lambda_k = -\\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad \\text{for } k = 0, 1, \\dots, N-1.\n$$\nThese eigenvalues are real and non-positive, ranging from $\\lambda_0 = 0$ to a minimum of approximately $-\\frac{4}{h^2}$ for the highest-frequency mode.\n\nSubstituting the expression for $\\lambda_k$ into the equation for $\\mu_k$ yields:\n$$\n\\mu_k = \\frac{1 - (1-\\theta)\\alpha \\Delta t \\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right)}{1 + \\theta \\alpha \\Delta t \\frac{4}{h^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right)}.\n$$\nLet us introduce the dimensionless parameter, often called the parabolic Courant number, $r = \\frac{\\alpha \\Delta t}{h^2}$. The amplification factor simplifies to:\n$$\n\\mu_k = \\frac{1 - 4r(1-\\theta)\\sin^2\\left(\\frac{\\pi k}{N}\\right)}{1 + 4r\\theta\\sin^2\\left(\\frac{\\pi k}{N}\\right)}.\n$$\nThe spectral radius is the maximum of $|\\mu_k|$ over all $k$. The term $\\sin^2(\\frac{\\pi k}{N})$ varies between $0$ (for $k=0$) and $1$ (for $k=N/2$ if $N$ is even). Since the function $f(x) = \\frac{1 - 4r(1-\\theta)x}{1 + 4r\\theta x}$ is monotonic for $x \\in [0, 1]$, the maximum of its magnitude is found at one of the endpoints. At $x=0$, $\\mu_0 = 1$. The critical value is typically at $x=1$, corresponding to the highest frequency. Thus, the stability condition $\\rho(M) \\le 1$ reduces to $|\\frac{1 - 4r(1-\\theta)}{1 + 4r\\theta}| \\le 1$. This inequality leads to the well-known stability criterion:\n$$\n2r(1 - 2\\theta) \\le 1.\n$$\nIf $\\theta \\ge 1/2$, the term $(1 - 2\\theta)$ is non-positive, so the inequality holds for any positive $r$. These schemes are unconditionally stable. This includes the Crank-Nicolson scheme ($\\theta=0.5$) and the backward Euler method ($\\theta=1$). If $0 \\le \\theta < 1/2$, stability is conditional upon $r \\le \\frac{1}{2(1-2\\theta)}$.\n\nWe now apply this analytical framework to each test case, with constants $L=1$, $\\alpha=1$, and $N=64$, so $h = 1/64$. The parameter $r$ is simply $\\Delta t / h^2$.\n\n1.  $N = 64$, $\\theta = 0$ (Forward Euler), $\\Delta t = 0.25\\,h^2$.\n    Here, $r = 0.25$. The stability condition for $\\theta=0$ is $r \\le 0.5$. Since $0.25 \\le 0.5$, the scheme is **stable**. The maximum amplification factor is $|\\mu_{32}| = |1 - 4(0.25)| = 0$. The spectral radius is $\\rho(M) = 1$ (from the $k=0$ mode).\n\n2.  $N = 64$, $\\theta = 0$, $\\Delta t = 0.75\\,h^2$.\n    Here, $r = 0.75$. The condition $r \\le 0.5$ is violated. The scheme is **unstable**. The maximum amplification factor $|\\mu_{32}| = |1 - 4(0.75)| = |-2| = 2$.\n\n3.  $N = 64$, $\\theta = 0.5$ (Crank-Nicolson), $\\Delta t = 30\\,h^2$.\n    Here, $r = 30$. As $\\theta = 0.5$, the scheme is unconditionally stable. The scheme is **stable**. For any $r$, $|\\mu_k| = |\\frac{1 - 2r \\sin^2(\\dots)}{1 + 2r \\sin^2(\\dots)}| \\le 1$. Thus $\\rho(M)=1$.\n\n4.  $N = 64$, $\\theta = 1$ (Backward Euler), $\\Delta t = 100\\,h^2$.\n    Here, $r = 100$. As $\\theta = 1$, the scheme is unconditionally stable. The scheme is **stable**. The amplification factors are $\\mu_k = (1 + 4r \\sin^2(\\dots))^{-1}$, which are all less than or equal to $1$.\n\n5.  $N = 64$, $\\theta = 0.25$, $\\Delta t = 1\\,h^2$.\n    Here, $r = 1$. For $\\theta = 0.25$, the stability condition is $r \\le \\frac{1}{2(1 - 2 \\cdot 0.25)} = 1$. Since $r=1$, the condition is met at its boundary. The scheme is **stable**. The maximum amplification factor is $|\\mu_{32}| = |\\frac{1-4(1-0.25)}{1+4(0.25)}| = |\\frac{1-3}{1+1}| = |-1| = 1$.\n\n6.  $N = 64$, $\\theta = 0.49$, $\\Delta t = 30\\,h^2$.\n    Here, $r = 30$. For $\\theta = 0.49$, the stability condition is $r \\le \\frac{1}{2(1 - 2 \\cdot 0.49)} = \\frac{1}{0.04} = 25$. Since $30 > 25$, the condition is violated. The scheme is **unstable**. Indeed, $|\\mu_{32}| = |\\frac{1-4(30)(0.51)}{1+4(30)(0.49)}| = |\\frac{1-61.2}{1+58.8}| = |\\frac{-60.2}{59.8}| \\approx 1.0067 > 1$.\n\nThe final results are therefore `[True, False, True, True, True, False]`. The provided program implements this analytical calculation to arrive at the solution.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the stability of the generalized theta-method for the 1D heat\n    equation by calculating the spectral radius of the update operator for\n    several parameter sets.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, theta, dt_over_h_squared)\n    # L and alpha are fixed at 1 for all cases.\n    test_cases = [\n        (64, 0.0, 0.25),   # Case 1\n        (64, 0.0, 0.75),   # Case 2\n        (64, 0.5, 30.0),   # Case 3\n        (64, 1.0, 100.0),  # Case 4\n        (64, 0.25, 1.0),   # Case 5\n        (64, 0.49, 30.0),  # Case 6\n    ]\n\n    L = 1.0\n    alpha = 1.0\n    epsilon = 1e-10\n\n    results = []\n    \n    for N, theta, r in test_cases:\n        # The parameter 'r' in the code corresponds to the dimensionless\n        # number r = alpha * dt / h^2.\n        # Since the problem gives dt in terms of h^2 (e.g., dt = 0.25 * h^2),\n        # and alpha = 1, the value of r is simply the given coefficient.\n\n        # The eigenvalues of the update operator M are given by the\n        # amplification factor mu_k, which depends on the eigenvalues of the\n        # discrete Laplacian D. This avoids constructing the matrices explicitly.\n        # mu_k = (1 - 4*r*(1-theta)*sin^2(pi*k/N)) / \n        #        (1 + 4*r*theta*sin^2(pi*k/N))\n        # where k = 0, 1, ..., N-1.\n\n        # We compute the amplification factor for all Fourier modes.\n        k = np.arange(N)\n        sin_sq_term = np.sin(np.pi * k / N)**2\n\n        numerator = 1.0 - 4.0 * r * (1.0 - theta) * sin_sq_term\n        denominator = 1.0 + 4.0 * r * theta * sin_sq_term\n\n        # The eigenvalues of the update matrix M.\n        mu = numerator / denominator\n\n        # The spectral radius is the maximum absolute value of the eigenvalues.\n        spectral_radius = np.max(np.abs(mu))\n\n        # Check stability against the given criterion.\n        is_stable = spectral_radius <= 1.0 + epsilon\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443588"}, {"introduction": "While the Crank-Nicolson scheme is celebrated for its unconditional $L_2$-stability, this property does not guarantee that the numerical solution will always be physically realistic, a crucial lesson for any practitioner. This practice demonstrates this limitation by applying the scheme to an initial condition with a sharp discontinuity, which can produce non-physical oscillations when a large time step is used [@problem_id:2393571]. You will quantify the amplitude of these spurious oscillations, learning the vital distinction between numerical stability and physical fidelity.", "problem": "Consider the one-dimensional heat (diffusion) equation on the interval $[0,1]$ with homogeneous Dirichlet boundary conditions,\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t > 0, \\quad u(0,t) = 0, \\ u(1,t) = 0,\n$$\nand a discontinuous initial condition\n$$\nu(x,0) = \\begin{cases}\n1, & x \\in [0.45, 0.55],\\\\\n0, & \\text{otherwise}.\n\\end{cases}\n$$\nAll quantities are dimensionless. Use a uniform spatial grid with $N=201$ equally spaced points (including boundaries), so that $\\Delta x = 1/(N-1)$. Let $\\alpha = 1$.\n\nLet $u_i^n$ denote the numerical approximation to $u(x_i,t_n)$ at the interior grid points $x_i = i \\, \\Delta x$ for $i=1,2,\\dots,N-2$ and time level $t_n = n \\, \\Delta t$. Define the Crank-Nicolson finite difference scheme for advancing one time step from $t_n$ to $t_{n+1}$ as the unique solution $u^{n+1}$ of\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\, \\Delta t}{(\\Delta x)^2},\n$$\nwhere $I$ is the identity operator on the interior grid, and $L$ is the standard second-difference operator with homogeneous Dirichlet boundary conditions acting on interior grid values:\n$$\n(L u)_i = u_{i+1} - 2 u_i + u_{i-1}, \\quad i=1,2,\\dots,N-2,\n$$\nwith the understanding that $u_0 = 0$ and $u_{N-1} = 0$ due to the boundary conditions.\n\nFor a given time step $\\Delta t$, define the oscillation amplitude after one Crank-Nicolson time step by\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\nThis quantity is the sum of the overshoot above the physical upper bound $1$ and the undershoot below the physical lower bound $0$ in the interior after a single time step, starting from the specified discontinuous initial condition at $t=0$.\n\nTest Suite:\n- Use $N=201$ and $\\alpha = 1$ as specified.\n- Let $\\Delta x = 1/(N-1)$.\n- Consider the four time steps\n  1. $\\Delta t_1 = 0.2 \\, (\\Delta x)^2 / \\alpha$,\n  2. $\\Delta t_2 = 1.0 \\, (\\Delta x)^2 / \\alpha$,\n  3. $\\Delta t_3 = 5.0 \\, (\\Delta x)^2 / \\alpha$,\n  4. $\\Delta t_4 = 25.0 \\, (\\Delta x)^2 / \\alpha$.\n  \nFor each $\\Delta t_k$, compute $A(\\Delta t_k)$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$, with each value rounded to six decimal places. The output is dimensionless and contains floating-point numbers only.", "solution": "We begin from the heat equation $\\partial_t u = \\alpha \\partial_{xx} u$ on $[0,1]$ with homogeneous Dirichlet boundary conditions and a discontinuous step initial condition confined to $[0.45,0.55]$. The maximum principle for the continuous problem implies that, for $t>0$, the solution remains between $0$ and $1$. However, certain time discretizations, while stable in a norm, are not monotone and can produce nonphysical oscillations such as undershoot (values below $0$) or overshoot (values above $1$) when the initial data has sharp discontinuities. The Crank-Nicolson scheme is a second-order accurate, implicit, unconditionally stable method in the $\\ell^2$ sense, but it is not total variation diminishing nor monotonicity preserving, and can produce such oscillations for sufficiently large time steps.\n\nWe discretize the spatial domain with $N=201$ uniformly spaced nodes, including boundaries, so that $\\Delta x = 1/(N-1)$. We index interior nodes by $i=1,2,\\dots,N-2$ and denote by $u_i^n$ the numerical approximation at $x_i=i\\Delta x$ and time $t_n=n\\Delta t$. The standard centered second-difference operator with homogeneous Dirichlet boundary conditions is defined on interior indices by\n$$\n(Lu)_i = u_{i+1} - 2u_i + u_{i-1}, \\quad i=1,\\dots,N-2,\n$$\nwith boundary values $u_0=0$ and $u_{N-1}=0$ enforced.\n\nThe Crank-Nicolson time-stepping scheme for the semidiscrete system $\\dot{u}=\\alpha \\Delta_x u$ is\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\nOn a one-dimensional uniform grid, this becomes a tridiagonal linear system for $u^{n+1}$ at interior indices. Writing componentwise for $i=1,\\dots,N-2$,\n$$\n-\\frac{r}{2} \\, u_{i-1}^{n+1} + (1+r) \\, u_i^{n+1} - \\frac{r}{2} \\, u_{i+1}^{n+1}\n=\n\\frac{r}{2} \\, u_{i-1}^{n} + (1-r) \\, u_i^{n} + \\frac{r}{2} \\, u_{i+1}^{n},\n$$\nwith boundary contributions vanishing because $u_0^n=u_{N-1}^n=0$.\n\nThe initial data is set by\n$$\nu_i^0 = \\begin{cases}\n1, & x_i \\in [0.45,0.55],\\\\\n0, & \\text{otherwise},\n\\end{cases}\n\\qquad x_i = i \\Delta x, \\quad i=1,\\dots,N-2.\n$$\n\nTo quantify nonphysical oscillations after one time step, we define the amplitude\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\nThe first term measures overshoot beyond the physical bound $1$, and the second term measures undershoot below $0$. For the heat equation with nonnegative, bounded initial data, the exact solution remains in $[0,1]$, so any positive $A(\\Delta t)$ indicates an unphysical oscillation caused by the discrete scheme.\n\nWe now discuss why large $r$ leads to oscillations. The discrete Laplacian $L$ on a uniform grid has eigenmodes resembling discrete sines. For a Fourier component with wavenumber $\\theta$, the discrete Laplacian has eigenvalue $\\lambda_d(\\theta) = -4\\sin^2(\\theta/2)$. The Crank-Nicolson amplification factor for this mode is\n$$\ng(\\theta; r) = \\frac{1 + \\frac{r}{2}\\lambda_d(\\theta)}{1 - \\frac{r}{2}\\lambda_d(\\theta)}\n= \\frac{1 - 2 r \\sin^2(\\theta/2)}{1 + 2 r \\sin^2(\\theta/2)}.\n$$\nFor any $r>0$, we have $|g(\\theta;r)|\\le 1$, ensuring unconditional stability in $\\ell^2$. However, if $2 r \\sin^2(\\theta/2) > 1$, then $g(\\theta;r) < 0$, which flips the sign of those Fourier components in a single time step, generating oscillations near sharp discontinuities where high-frequency content is present. The largest $\\sin^2(\\theta/2)$ is $1$, hence for $r > 1/2$, the highest frequency modes are inverted in sign after one step. Therefore we anticipate negligible oscillations for $r=0.2$, increasing oscillatory undershoot/overshoot for $r=1$, and more pronounced oscillations for $r=5$ and $r=25$.\n\nAlgorithmically, for each specified $\\Delta t_k$ (equivalently $r_k$), we:\n1. Construct $u^0$ from the step initial condition on the interior grid.\n2. Form the tridiagonal system with subdiagonal entries $-r_k/2$, diagonal entries $1+r_k$, and superdiagonal entries $-r_k/2$.\n3. Assemble the right-hand side $(I + \\frac{r_k}{2} L) u^0$ using interior values and $0$ at the boundaries.\n4. Solve the tridiagonal system to obtain $u^1$.\n5. Compute $A(\\Delta t_k)$ as defined above from the interior values of $u^1$.\n6. Repeat for the four test values of $\\Delta t_k$ in the suite.\n\nFinally, we output the list $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$, each rounded to six decimal places, as a single line, comma-separated within brackets. This procedure directly reflects the mathematical structure of the Crank-Nicolson method and quantifies the unphysical oscillations that can arise for large time steps with discontinuous initial data.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_tridiagonal(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal system Ax = rhs with A having\n    lower (a), diagonal (b), and upper (c) diagonals.\n    All inputs are 1D numpy arrays:\n      lower: length n-1\n      diag:  length n\n      upper: length n-1\n      rhs:   length n\n    Returns x of length n.\n    \"\"\"\n    n = diag.size\n    # Copy to avoid modifying inputs\n    a = lower.astype(float).copy()\n    b = diag.astype(float).copy()\n    c = upper.astype(float).copy()\n    d = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        w = a[i-1] / b[i-1]\n        b[i] = b[i] - w * c[i-1]\n        d[i] = d[i] - w * d[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = d[-1] / b[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n\n    return x\n\ndef crank_nicolson_first_step_amplitude(N, alpha, dt):\n    \"\"\"\n    Compute the oscillation amplitude A(dt) after one Crank-Nicolson step\n    for the 1D heat equation on [0,1] with homogeneous Dirichlet BCs and\n    discontinuous initial condition: u(x,0)=1 on [0.45,0.55], 0 otherwise.\n    \"\"\"\n    # Grid setup\n    L = 1.0\n    dx = L / (N - 1)\n    r = alpha * dt / (dx * dx)\n\n    # Interior indices: 1..N-2 (Python 0..M-1)\n    M = N - 2\n    x_interior = np.linspace(dx, L - dx, M)\n\n    # Initial condition on interior: 1 on [0.45,0.55], else 0\n    u0 = np.where((x_interior >= 0.45) & (x_interior <= 0.55), 1.0, 0.0)\n\n    # Build Crank-Nicolson matrices (implicit LHS tridiagonal, RHS vector)\n    # LHS: (I - r/2 * L) => diag: 1 + r; off-diag: -r/2\n    lower = -0.5 * r * np.ones(M - 1)\n    diag = (1.0 + r) * np.ones(M)\n    upper = -0.5 * r * np.ones(M - 1)\n\n    # RHS: (I + r/2 * L) u0 => (1 - r) * u0 + (r/2) * (u0_{i-1} + u0_{i+1})\n    rhs = (1.0 - r) * u0.copy()\n    rhs[:-1] += 0.5 * r * u0[1:]     # contribution from u0_{i+1}\n    rhs[1:]  += 0.5 * r * u0[:-1]    # contribution from u0_{i-1}\n    # Boundary contributions are zero due to homogeneous Dirichlet BCs.\n\n    # Solve for u1\n    u1 = thomas_tridiagonal(lower, diag, upper, rhs)\n\n    # Compute amplitude A(dt) over interior values\n    max_val = float(np.max(u1))\n    min_val = float(np.min(u1))\n    overshoot = max(0.0, max_val - 1.0)\n    undershoot = max(0.0, -min_val)\n    A = overshoot + undershoot\n    return A\n\ndef solve():\n    # Parameters from the problem statement\n    N = 201\n    alpha = 1.0\n    L = 1.0\n    dx = L / (N - 1)\n\n    # Test suite time steps: dt_k = [0.2, 1.0, 5.0, 25.0] * dx^2 / alpha\n    r_values = [0.2, 1.0, 5.0, 25.0]\n    test_dts = [r * dx * dx / alpha for r in r_values]\n\n    results = []\n    for dt in test_dts:\n        A = crank_nicolson_first_step_amplitude(N, alpha, dt)\n        results.append(f\"{A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2393571"}, {"introduction": "Building on the previous lessons, this exercise introduces a powerful strategy for tackling realistic, multi-physics problems: Implicit-Explicit (IMEX) schemes. Many models combine stiff processes like diffusion with non-stiff ones like reaction, and IMEX methods allow us to apply the most suitable numerical technique to each part [@problem_id:2443592]. You will design a second-order accurate predictor-corrector method that handles the stiff diffusion term with the implicit Crank-Nicolson scheme while treating the non-stiff reaction term explicitly, bridging the gap from basic methods to the design of sophisticated, efficient solvers.", "problem": "Consider the one-dimensional reaction-diffusion initial-boundary value problem\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; g(u(x,t)), \\quad x\\in(0,1), \\; t\\in(0,T],\n$$\nwith homogeneous Dirichlet boundary conditions\n$$\nu(0,t)=0, \\quad u(1,t)=0, \\quad t\\in[0,T],\n$$\nand a smooth initial condition\n$$\nu(x,0)=\\sin(\\pi x), \\quad x\\in[0,1].\n$$\nAssume that the diffusion coefficient $D$ is a nonnegative constant and the reaction term $g(u)$ is non-stiff and sufficiently smooth. Adopt a method-of-lines semi-discretization in space using a uniform grid with $N_x$ points (including boundaries) and second-order centered finite differences for the Laplacian. Let $\\Delta x = 1/(N_x-1)$ and denote by $\\boldsymbol{u}(t)\\in\\mathbb{R}^{N_x-2}$ the vector of interior-point approximations at time $t$.\n\nDesign an Implicit-Explicit (IMEX) time integrator in which:\n- the stiff linear diffusion operator is treated by the Crank-Nicolson method (which is the trapezoidal rule in time for linear terms), and\n- the non-stiff nonlinear reaction term is treated by an explicit method based on the trapezoidal rule in time (that is, the explicit trapezoidal or improved Euler method).\n\nStart from the following fundamental bases:\n- the method-of-lines formulation $\\boldsymbol{u}'(t) = \\boldsymbol{L}\\,\\boldsymbol{u}(t) + \\boldsymbol{N}(\\boldsymbol{u}(t))$, where $\\boldsymbol{L}$ is the matrix representation of $D\\,\\partial_{xx}$ with homogeneous Dirichlet boundary conditions, and $\\boldsymbol{N}(\\boldsymbol{u})$ is the pointwise reaction term,\n- the trapezoidal rule in time for a smooth function $y(t)$, given by $y^{n+1} \\approx y^n + \\tfrac{\\Delta t}{2}\\left(f(t^n,y^n) + f(t^{n+1},y^{n+1})\\right)$.\n\nDerive, without skipping conceptual steps, a two-stage IMEX predictor-corrector scheme that is globally second-order accurate in time, where:\n- the predictor uses implicit Euler for the linear part and explicit Euler for the nonlinear part, and\n- the corrector uses Crank-Nicolson for the linear part and the explicit trapezoidal rule for the nonlinear part.\n\nThen implement the fully discrete algorithm using the above spatial and temporal discretizations. Use the following test suite, each to be run twice with two time steps to estimate the observed temporal order of accuracy:\n- Test A (pure diffusion): $D=1$, $g(u)=0$, $N_x=201$, $T=0.1$, coarse step $\\Delta t_{\\text{coarse}} = T/10$, fine step $\\Delta t_{\\text{fine}} = T/20$.\n- Test B (linear reaction-diffusion, decaying): $D=1$, $g(u)=\\lambda u$ with $\\lambda=-1$, $N_x=201$, $T=0.1$, coarse step $\\Delta t_{\\text{coarse}} = T/10$, fine step $\\Delta t_{\\text{fine}} = T/20$.\n- Test C (pure reaction, decoupled in space): $D=0$, $g(u)=\\lambda u$ with $\\lambda=-1$, $N_x=201$, $T=0.1$, coarse step $\\Delta t_{\\text{coarse}} = T/10$, fine step $\\Delta t_{\\text{fine}} = T/20$.\n\nFor Tests A and B, the exact solution at time $T$ for the chosen initial condition is\n$$\nu_{\\text{exact}}(x,T) \\;=\\; \\sin(\\pi x)\\,\\exp\\!\\left(\\left(\\lambda - D\\,\\pi^2\\right)T\\right),\n$$\nwith $\\lambda=0$ for Test A. For Test C, the exact solution is\n$$\nu_{\\text{exact}}(x,T) \\;=\\; \\sin(\\pi x)\\,\\exp\\!\\left(\\lambda\\,T\\right),\n$$\nsince the diffusion is absent.\n\nFor each test, compute the discrete $L^2$-error at the final time $T$ for both $\\Delta t_{\\text{coarse}}$ and $\\Delta t_{\\text{fine}}$, using the interior-plus-boundary grid values with uniform quadrature weight $\\Delta x$, that is,\n$$\nE(\\Delta t) \\;=\\; \\left( \\Delta x \\sum_{j=0}^{N_x-1} \\left(u_j^{\\text{num}}(T;\\Delta t) - u_{\\text{exact}}(x_j,T)\\right)^2 \\right)^{1/2},\n$$\nwhere $x_j = j\\,\\Delta x$ and $u_0^{\\text{num}}(T;\\Delta t)=u_{N_x-1}^{\\text{num}}(T;\\Delta t)=0$. Estimate the observed temporal order $p$ by\n$$\np \\;=\\; \\log_2\\!\\left(\\frac{E(\\Delta t_{\\text{coarse}})}{E(\\Delta t_{\\text{fine}})}\\right).\n$$\n\nYour program must:\n- implement the derived IMEX scheme with the specified spatial discretization,\n- run the three tests with the given parameters,\n- compute the three observed orders $p$ as $64$-bit floating-point numbers, and\n- produce a single line of output containing the results as a comma-separated list enclosed in square brackets, for example, $[p_A,p_B,p_C]$.\n\nNo external input is provided; all parameters are fixed by this statement. No physical unit reporting is required in the output since the requested outputs are dimensionless orders of accuracy.", "solution": "The problem statement is parsed and validated. It is scientifically grounded, well-posed, unambiguous, and contains all necessary information for its resolution. It represents a standard exercise in the numerical analysis of partial differential equations. We may therefore proceed with the derivation and solution.\n\nThe problem is the one-dimensional reaction-diffusion equation:\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t) \\;+\\; g(u(x,t))\n$$\non the domain $x\\in(0,1)$ and $t\\in(0,T]$, with diffusion coefficient $D \\ge 0$. The boundary conditions are homogeneous Dirichlet, $u(0,t)=0$ and $u(1,t)=0$, and the initial condition is $u(x,0)=\\sin(\\pi x)$.\n\nFirst, we apply the method of lines by discretizing the spatial domain. We introduce a uniform grid $x_j = j\\,\\Delta x$ for $j=0, 1, \\dots, N_x-1$, where the spatial step is $\\Delta x = 1/(N_x-1)$. Let $u_j(t)$ be the approximation of $u(x_j, t)$. We are concerned with the interior points, $j=1, \\dots, N_x-2$, since the boundary values $u_0(t)$ and $u_{N_x-1}(t)$ are fixed at $0$.\n\nThe second spatial derivative is approximated using a second-order centered finite difference stencil:\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_j,t) \\approx \\frac{u_{j-1}(t) - 2u_j(t) + u_{j+1}(t)}{\\Delta x^2}\n$$\nSubstituting this into the partial differential equation for each interior point $j$ yields a system of ordinary differential equations (ODEs):\n$$\n\\frac{d u_j}{d t}(t) = D\\,\\frac{u_{j-1}(t) - 2u_j(t) + u_{j+1}(t)}{\\Delta x^2} + g(u_j(t)), \\quad \\text{for } j=1, \\dots, N_x-2\n$$\nLet $\\boldsymbol{u}(t) \\in \\mathbb{R}^{N_x-2}$ be the vector of solutions at the interior grid points, $\\boldsymbol{u}(t) = [u_1(t), u_2(t), \\dots, u_{N_x-2}(t)]^T$. The system of ODEs can be expressed in the specified matrix form $\\boldsymbol{u}'(t) = \\boldsymbol{L}\\,\\boldsymbol{u}(t) + \\boldsymbol{N}(\\boldsymbol{u}(t))$.\n\nThe linear operator $\\boldsymbol{L}$ is the $(N_x-2) \\times (N_x-2)$ matrix representing the discretized diffusion term, incorporating the homogeneous Dirichlet boundary conditions ($u_0=0, u_{N_x-1}=0$). This matrix is tridiagonal:\n$$\n\\boldsymbol{L} = \\frac{D}{\\Delta x^2}\n\\begin{pmatrix}\n-2 & 1 & 0 & \\dots & 0 \\\\\n1 & -2 & 1 & \\dots & 0 \\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots \\\\\n\\vdots & & 1 & -2 & 1 \\\\\n0 & \\dots & 0 & 1 & -2\n\\end{pmatrix}\n$$\nThe nonlinear reaction term $\\boldsymbol{N}(\\boldsymbol{u}(t))$ is a vector function that applies the scalar function $g$ element-wise to the components of $\\boldsymbol{u}(t)$:\n$$\n\\boldsymbol{N}(\\boldsymbol{u}(t)) = [g(u_1(t)), g(u_2(t)), \\dots, g(u_{N_x-2}(t))]^T\n$$\nWith the semi-discretization established, we now design the specified two-stage Implicit-Explicit (IMEX) predictor-corrector time integration scheme to advance the solution from time $t^n$ to $t^{n+1} = t^n + \\Delta t$. Let $\\boldsymbol{u}^n \\approx \\boldsymbol{u}(t^n)$.\n\nThe scheme consists of a predictor stage and a corrector stage.\n\n**Stage 1: Predictor**\n\nThe predictor computes an intermediate solution $\\boldsymbol{u}^*$ at time $t^{n+1}$. It uses the implicit Euler method for the stiff linear part $\\boldsymbol{L}\\boldsymbol{u}$ and the explicit Euler method for the non-stiff nonlinear part $\\boldsymbol{N}(\\boldsymbol{u})$. This is formulated as:\n$$\n\\frac{\\boldsymbol{u}^* - \\boldsymbol{u}^n}{\\Delta t} = \\boldsymbol{L}\\,\\boldsymbol{u}^* + \\boldsymbol{N}(\\boldsymbol{u}^n)\n$$\nTo solve for $\\boldsymbol{u}^*$, we rearrange the equation into a linear system:\n$$\n\\boldsymbol{u}^* - \\Delta t\\,\\boldsymbol{L}\\,\\boldsymbol{u}^* = \\boldsymbol{u}^n + \\Delta t\\,\\boldsymbol{N}(\\boldsymbol{u}^n)\n$$\n$$\n(\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{L}) \\boldsymbol{u}^* = \\boldsymbol{u}^n + \\Delta t\\,\\boldsymbol{N}(\\boldsymbol{u}^n)\n$$\nwhere $\\boldsymbol{I}$ is the identity matrix of size $(N_x-2) \\times (N_x-2)$. This system must be solved for the predictor vector $\\boldsymbol{u}^*$.\n\n**Stage 2: Corrector**\n\nThe corrector computes the final solution $\\boldsymbol{u}^{n+1}$ using the Crank-Nicolson method for the linear part and the explicit trapezoidal rule for the nonlinear part. The Crank-Nicolson method is an application of the trapezoidal rule to the linear term, while the explicit trapezoidal rule requires an approximation of the solution at $t^{n+1}$ to evaluate the nonlinear term, for which we use the predictor $\\boldsymbol{u}^*$.\n\nThe combined scheme is:\n$$\n\\frac{\\boldsymbol{u}^{n+1} - \\boldsymbol{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\boldsymbol{L}\\,\\boldsymbol{u}^n + \\boldsymbol{L}\\,\\boldsymbol{u}^{n+1} \\right) + \\frac{1}{2} \\left( \\boldsymbol{N}(\\boldsymbol{u}^n) + \\boldsymbol{N}(\\boldsymbol{u}^*) \\right)\n$$\nThis formulation is implicit in the linear term but explicit in the nonlinear term. We rearrange to form a linear system for $\\boldsymbol{u}^{n+1}$:\n$$\n\\boldsymbol{u}^{n+1} - \\frac{\\Delta t}{2}\\,\\boldsymbol{L}\\,\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^n + \\frac{\\Delta t}{2}\\,\\boldsymbol{L}\\,\\boldsymbol{u}^n + \\frac{\\Delta t}{2} \\left( \\boldsymbol{N}(\\boldsymbol{u}^n) + \\boldsymbol{N}(\\boldsymbol{u}^*) \\right)\n$$\n$$\n\\left(\\boldsymbol{I} - \\frac{\\Delta t}{2}\\,\\boldsymbol{L}\\right) \\boldsymbol{u}^{n+1} = \\left(\\boldsymbol{I} + \\frac{\\Delta t}{2}\\,\\boldsymbol{L}\\right) \\boldsymbol{u}^n + \\frac{\\Delta t}{2} \\left( \\boldsymbol{N}(\\boldsymbol{u}^n) + \\boldsymbol{N}(\\boldsymbol{u}^*) \\right)\n$$\nThis is the final update step. The matrices $(\\boldsymbol{I} - \\Delta t\\,\\boldsymbol{L})$ and $(\\boldsymbol{I} - \\frac{\\Delta t}{2}\\,\\boldsymbol{L})$ are tridiagonal, allowing the linear systems in both stages to be solved efficiently, for example, with the Thomas algorithm in $\\mathcal{O}(N_x)$ operations.\n\nThis completes the derivation. The resulting algorithm is a second-order accurate IMEX scheme suitable for reaction-diffusion problems with stiff diffusion and non-stiff reaction. The implementation will follow this derived procedure to solve the test problems and compute the temporal order of accuracy.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test suite and print the results.\n    \"\"\"\n\n    def solve_case(D, g, u_exact_func, Nx, T, dt):\n        \"\"\"\n        Solves the reaction-diffusion problem for one specific test case.\n\n        Args:\n            D (float): Diffusion coefficient.\n            g (callable): Reaction function g(u).\n            u_exact_func (callable): Function u_exact(x, t) for the exact solution.\n            Nx (int): Number of spatial grid points.\n            T (float): Final time.\n            dt (float): Time step.\n\n        Returns:\n            float: The discrete L2-error at the final time T.\n        \"\"\"\n        # 1. Setup Grid and Initial Condition\n        dx = 1.0 / (Nx - 1)\n        x = np.linspace(0.0, 1.0, Nx)\n        u_n = np.sin(np.pi * x[1:-1])  # Initial condition on interior points\n        size = Nx - 2\n        \n        # Guard against zero-size case\n        if size <= 0:\n            u_num_full = np.zeros(Nx)\n            u_exact_final = u_exact_func(x, T)\n            error = np.sqrt(dx * np.sum((u_num_full - u_exact_final)**2))\n            return error\n\n        # Semi-discretization matrix L represents D*d^2/dx^2\n        if D == 0.0:\n            L_diag_val = 0.0\n            L_offdiag_val = 0.0\n        else:\n            L_diag_val = -2.0 * D / dx**2\n            L_offdiag_val = 1.0 * D / dx**2\n        \n        # 2. Setup matrices for the IMEX scheme\n        num_steps = int(round(T / dt))\n        dt_actual = T / num_steps  # Adjust dt to hit T exactly\n\n        # Predictor matrix: Ap = I - dt*L\n        Ap_banded = np.zeros((3, size))\n        Ap_banded[0, 1:] = -dt_actual * L_offdiag_val\n        Ap_banded[1, :] = 1.0 - dt_actual * L_diag_val\n        Ap_banded[2, :-1] = -dt_actual * L_offdiag_val\n\n        # Corrector matrix: Ac = I - (dt/2)*L\n        Ac_banded = np.zeros((3, size))\n        Ac_banded[0, 1:] = -0.5 * dt_actual * L_offdiag_val\n        Ac_banded[1, :] = 1.0 - 0.5 * dt_actual * L_diag_val\n        Ac_banded[2, :-1] = -0.5 * dt_actual * L_offdiag_val\n\n        # Constants for corrector RHS matrix-vector product B*u_n where B = I + (dt/2)*L\n        B_diag_val = 1.0 + 0.5 * dt_actual * L_diag_val\n        B_offdiag_val = 0.5 * dt_actual * L_offdiag_val\n\n        # 3. Time-stepping loop\n        for _ in range(num_steps):\n            # -- Predictor Stage --\n            # Solve (I - dt*L) u* = u_n + dt * N(u_n)\n            b_p = u_n + dt_actual * g(u_n)\n            u_star = solve_banded((1, 1), Ap_banded, b_p)\n            \n            # -- Corrector Stage --\n            # Solve (I - dt/2*L) u^{n+1} = (I + dt/2*L)u_n + dt/2*(N(u_n) + N(u*))\n            \n            # RHS Term 1: (I + dt/2*L)u_n (efficient tridiagonal mat-vec)\n            op_B_on_u = np.zeros(size)\n            if size > 1:\n                op_B_on_u[1:-1] = B_offdiag_val * u_n[:-2] + B_diag_val * u_n[1:-1] + B_offdiag_val * u_n[2:]\n                op_B_on_u[0] = B_diag_val * u_n[0] + B_offdiag_val * u_n[1]\n                op_B_on_u[-1] = B_offdiag_val * u_n[-2] + B_diag_val * u_n[-1]\n            elif size == 1:\n                op_B_on_u[0] = B_diag_val * u_n[0]\n            \n            # RHS Term 2: dt/2*(N(u_n) + N(u*))\n            term2 = 0.5 * dt_actual * (g(u_n) + g(u_star))\n            \n            b_c = op_B_on_u + term2\n            \n            u_np1 = solve_banded((1, 1), Ac_banded, b_c)\n            \n            u_n = u_np1\n\n        # 4. Compute error at final time T\n        u_num_full = np.zeros(Nx)\n        u_num_full[1:-1] = u_n\n        u_exact_final = u_exact_func(x, T)\n        \n        error = np.sqrt(dx * np.sum((u_num_full - u_exact_final)**2))\n        return error\n\n    # Define test cases from the problem statement.\n    test_cases = [\n        # Test A: Pure Diffusion\n        {\n            \"D\": 1.0, \n            \"g\": lambda u: 0.0,\n            \"u_exact\": lambda x, t: np.sin(np.pi * x) * np.exp(-1.0 * (np.pi**2) * t)\n        },\n        # Test B: Linear Reaction-Diffusion\n        {\n            \"D\": 1.0, \n            \"g\": lambda u: -1.0 * u,\n            \"u_exact\": lambda x, t: np.sin(np.pi * x) * np.exp((-1.0 - 1.0 * (np.pi**2)) * t)\n        },\n        # Test C: Pure Reaction\n        {\n            \"D\": 0.0,\n            \"g\": lambda u: -1.0 * u,\n            \"u_exact\": lambda x, t: np.sin(np.pi * x) * np.exp(-1.0 * t)\n        }\n    ]\n\n    # Shared parameters for all tests\n    Nx = 201\n    T = 0.1\n    dt_coarse = T / 10.0\n    dt_fine = T / 20.0\n\n    results = []\n    for case in test_cases:\n        # Run simulation with coarse and fine time steps to find error\n        E_coarse = solve_case(case[\"D\"], case[\"g\"], case[\"u_exact\"], Nx, T, dt_coarse)\n        E_fine = solve_case(case[\"D\"], case[\"g\"], case[\"u_exact\"], Nx, T, dt_fine)\n\n        # Estimate the temporal order of accuracy\n        if E_fine > 0.0 and E_coarse > 0.0:\n            order = np.log2(E_coarse / E_fine)\n        else:\n            order = 0.0 # Avoid division by zero if error is negligible\n        \n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2443592"}]}