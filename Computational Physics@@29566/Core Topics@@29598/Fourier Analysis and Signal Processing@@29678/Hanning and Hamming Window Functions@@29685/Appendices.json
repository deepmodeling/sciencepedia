{"hands_on_practices": [{"introduction": "This practice moves beyond using off-the-shelf windows and invites you to become a window designer. By creating a hybrid window as a mix of the Hanning and Hamming types, you will directly explore the fundamental trade-off between main-lobe width and side-lobe suppression. This exercise will help you develop an intuition for how a window's shape in the time domain translates to its performance in the frequency domain, a core skill in spectral analysis [@problem_id:2399871].", "problem": "You are given the task of constructing and analyzing a hybrid discrete-time window function formed by a convex combination of the Hanning window and the Hamming window. Let the window length be $N=128$, and let the sample index be $n \\in \\{0,1,\\ldots,N-1\\}$. Define the Hanning window $W_{Hanning}(n)$ and the Hamming window $W_{Hamming}(n)$ by\n$$\nW_{Hanning}(n) = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right), \\quad\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\nFor a mixing parameter $\\alpha \\in [0,1]$, define the hybrid window\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n).\n$$\nLet $x[n]$ be the zero-padded sequence of length $L=262144$ defined by $x[n]=W(n;\\alpha)$ for $0 \\le n \\le N-1$ and $x[n]=0$ otherwise. Let $X[k]$ denote the $L$-point Discrete Fourier Transform (DFT) of $x[n]$:\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}, \\quad k=0,1,\\ldots,L-1.\n$$\nDefine the centered spectrum $X_s[m]$ by a circular shift\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad m=0,1,\\ldots,L-1,\n$$\nand let the corresponding magnitude be $A[m]=|X_s[m]|$. Let $m_0 = \\tfrac{L}{2}$ denote the index of the direct current (DC) component in the centered spectrum. Define $m_L$ and $m_R$ as the nearest indices with $m_L &lt; m_0 &lt; m_R$ such that $A[m_L]$ and $A[m_R]$ are strict local minima of the discrete sequence $A[m]$, and there is no other strict local minimum in the open intervals $(m_L,m_0)$ and $(m_0,m_R)$, respectively.\n\nUsing these definitions, for each given value of $\\alpha$, compute the following three scalar metrics:\n1. The mainlobe width in normalized frequency (cycles per sample), defined by\n$$\nw(\\alpha) = \\frac{m_R - m_L}{L}.\n$$\n2. The peak sidelobe level in decibels, defined by\n$$\n\\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\big\\{\\max_{0 \\le m &lt; m_L} A[m],\\ \\max_{m_R &lt; m \\le L-1} A[m]\\big\\}}{A[m_0]} \\right).\n$$\n3. The equivalent noise bandwidth (ENBW) in DFT-bin units, defined by\n$$\n\\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}.\n$$\n\nAll quantities above are dimensionless. The decibel scale for $\\mathrm{PSL}(\\alpha)$ must be computed using the base-$10$ logarithm of the amplitude ratio as given. Angles are not used in the final answers and therefore no angle unit is required.\n\nTest Suite:\nEvaluate the triple $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$ for the following five values of $\\alpha$:\n- $\\alpha = 0.0$,\n- $\\alpha = 0.5$,\n- $\\alpha = 1.0$,\n- $\\alpha = 0.2$,\n- $\\alpha = 0.8$.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a list of three floating-point numbers $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$ for the corresponding $\\alpha$ in the order listed above. Each floating-point number must be rounded to six decimal places. For example, a valid output format is\n$$\n\\big[\\,[w_1,\\mathrm{PSL}_1,\\mathrm{ENBW}_1],[w_2,\\mathrm{PSL}_2,\\mathrm{ENBW}_2],\\ldots\\,\\big],\n$$\nwith the exact numeric values determined by your computation.", "solution": "The problem as stated is well-defined, internally consistent, and scientifically sound. It presents a standard exercise in the analysis of digital window functions, a fundamental topic in signal processing and computational physics. We shall proceed with the solution.\n\nThe objective is to synthesize and analyze a hybrid window function, which is a convex combination of the Hanning and Hamming windows, by computing three standard performance metrics: mainlobe width, peak sidelobe level, and equivalent noise bandwidth.\n\nFirst, we define the constituent windows and the hybrid window. The window length is given as $N=128$, and the sample index is $n \\in \\{0, 1, \\dots, N-1\\}$. The Hanning window, $W_{Hanning}(n)$, and the Hamming window, $W_{Hamming}(n)$, are defined as:\n$$\nW_{Hanning}(n) = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n$$\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\nThese are \"symmetric\" or \"DFT-even\" versions of the windows, which are zero at the first and last samples for Hanning, and near-zero for Hamming. The hybrid window, $W(n;\\alpha)$, is formed by a linear interpolation controlled by the parameter $\\alpha \\in [0,1]$:\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n)\n$$\nFor $\\alpha=1$, the window is pure Hanning, and for $\\alpha=0$, it is pure Hamming. The Hanning window is known for its good sidelobe roll-off, while the Hamming window is optimized to minimize the peak sidelobe level, at the cost of a slightly wider mainlobe. The parameter $\\alpha$ thus navigates the trade-off between these properties.\n\nTo analyze the spectral characteristics of this window, we examine its Discrete Fourier Transform (DFT). The window sequence of length $N$ is zero-padded to a much larger length $L=262144$. This creates a new sequence $x[n]$ of length $L$. Zero-padding does not alter the underlying continuous spectrum of the window, but it interpolates the spectrum by computing the DFT at a finer frequency grid. This dense sampling is essential for accurately measuring features like lobe widths and peak levels. The $L$-point DFT, $X[k]$, is computed as:\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}\n$$\nFor analysis, the spectrum is circularly shifted to place the zero-frequency (DC) component at the center of the array. The centered spectrum $X_s[m]$ and its magnitude $A[m]$ are given by:\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad A[m] = |X_s[m]|\n$$\nThe peak of the mainlobe is located at the center index $m_0 = L/2$.\n\nWith these definitions in place, we proceed to calculate the three specified metrics for each given value of $\\alpha$.\n\n1.  **Equivalent Noise Bandwidth (ENBW)**: This metric measures the effective bandwidth of the window as if it were an ideal rectangular filter, in units of DFT bins. It is calculated directly from the window coefficients (not the zero-padded sequence) using the formula:\n    $$\n    \\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}\n    $$\n    This calculation does not require the DFT. It is a measure of how the window spreads the energy of a white noise signal.\n\n2.  **Mainlobe Width ($w$)**: The mainlobe width is a key indicator of frequency resolution. It is defined by the distance between the first nulls (minima) on either side of the central peak. We must find the indices $m_L$ and $m_R$ which are the nearest strict local minima to the central peak at $m_0$. A strict local minimum at index $m$ is defined by the condition $A[m] < A[m-1]$ and $A[m] < A[m+1]$. We find $m_L$ by searching downwards from $m_0-1$ and $m_R$ by searching upwards from $m_0+1$. The mainlobe width is then the normalized frequency difference:\n    $$\n    w(\\alpha) = \\frac{m_R - m_L}{L}\n    $$\n\n3.  **Peak Sidelobe Level (PSL)**: The PSL quantifies the spectral leakage, which can obscure weak signals. It is the magnitude of the highest sidelobe peak relative to the mainlobe peak, expressed in decibels. The sidelobes exist in the spectral regions outside the mainlobe, i.e., for indices $m \\in [0, m_L-1] \\cup [m_R+1, L-1]$. The peak sidelobe magnitude is found by taking the maximum of $A[m]$ over these regions. The PSL is then:\n    $$\n    \\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\left\\{\\max_{0 \\le m < m_L} A[m], \\max_{m_R < m \\le L-1} A[m]\\right\\}}{A[m_0]} \\right)\n    $$\n    A more negative value in dB indicates better sidelobe suppression.\n\nThe computational procedure involves implementing these steps for each value of $\\alpha$ in the test suite $\\{0.0, 0.5, 1.0, 0.2, 0.8\\}$, and collecting the resulting triple $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$. Numerical computations are performed using the `NumPy` library in `Python`.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a hybrid Hanning-Hamming window function.\n    \n    For several mixing parameters alpha, it computes three metrics:\n    1. Mainlobe width (w)\n    2. Peak Sidelobe Level (PSL)\n    3. Equivalent Noise Bandwidth (ENBW)\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 128           # Window length\n    L = 262144        # DFT length (zero-padding)\n    test_alphas = [0.0, 0.5, 1.0, 0.2, 0.8] # Mixing parameters\n\n    # --- Container for results ---\n    results = []\n\n    # --- Main loop over test cases ---\n    for alpha in test_alphas:\n        # Step 1: Construct the hybrid window function W(n; alpha)\n        n = np.arange(N, dtype=np.float64)\n        \n        w_hanning = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n        \n        W = alpha * w_hanning + (1 - alpha) * w_hamming\n\n        # Step 2: Calculate Equivalent Noise Bandwidth (ENBW)\n        # This is calculated from the original window coefficients.\n        sum_W = np.sum(W)\n        sum_W_sq = np.sum(W**2)\n        enbw = N * sum_W_sq / (sum_W**2)\n\n        # Step 3: Compute the L-point DFT of the zero-padded window\n        # Create zero-padded sequence x[n]\n        x = np.zeros(L, dtype=np.float64)\n        x[:N] = W\n        \n        # Compute DFT and then shift it to center the DC component\n        X = np.fft.fft(x)\n        Xs = np.fft.fftshift(X)\n        A = np.abs(Xs)\n\n        # Step 4: Analyze the magnitude spectrum A[m] to find mainlobe width (w)\n        m0 = L // 2  # Index of the DC component (mainlobe peak)\n\n        # Find m_L, the first strict local minimum to the left of the peak\n        m_L = -1\n        # Search from m0-1 down to 1. Index m=0 is not checked for minimum.\n        for m in range(m0 - 1, 0, -1):\n            if A[m] < A[m - 1] and A[m] < A[m + 1]:\n                m_L = m\n                break\n        \n        # Find m_R, the first strict local minimum to the right of the peak\n        m_R = -1\n        # Search from m0+1 up to L-2. Index L-1 is not checked.\n        for m in range(m0 + 1, L - 1):\n            if A[m] < A[m - 1] and A[m] < A[m + 1]:\n                m_R = m\n                break\n\n        # A check for robustness, though minima should exist for these windows.\n        if m_L == -1 or m_R == -1:\n            raise ValueError(f\"Could not find mainlobe nulls for alpha = {alpha}\")\n\n        # Calculate mainlobe width in normalized frequency\n        w = (m_R - m_L) / L\n        \n        # Step 5: Calculate Peak Sidelobe Level (PSL)\n        A_m0 = A[m0] # Magnitude of the mainlobe peak\n        \n        # Find peak magnitude in the sidelobe regions\n        sidelobe_region_left = A[0:m_L]\n        sidelobe_region_right = A[m_R + 1:]\n        \n        peak_sidelobe = max(np.max(sidelobe_region_left), np.max(sidelobe_region_right))\n        \n        # Calculate PSL in decibels\n        psl = 20 * np.log10(peak_sidelobe / A_m0)\n\n        # Store the triple of metrics for this alpha\n        results.append([w, psl, enbw])\n    \n    # --- Final Output Formatting ---\n    # The output format is a string representation of a list of lists,\n    # with each float formatted to 6 decimal places.\n    outer_list_parts = []\n    for res_tuple in results:\n        inner_list_str = f\"[{res_tuple[0]:.6f},{res_tuple[1]:.6f},{res_tuple[2]:.6f}]\"\n        outer_list_parts.append(inner_list_str)\n\n    final_output_string = f\"[{','.join(outer_list_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2399871"}, {"introduction": "Understanding the theoretical properties of window functions is one thing; seeing them in action is another. This exercise challenges you to design a specific test signal that exploits the key difference in side-lobe behavior between the Hanning and Hamming windows. Your goal is to create a scenario where the Hamming window's poor far-out side-lobe decay obscures a weak signal that the Hanning window can successfully reveal, providing a concrete demonstration of their respective strengths and weaknesses [@problem_id:2399887].", "problem": "You are given two deterministic window functions on a discrete-time sequence of length $N$: the Hanning (Hann) window and the Hamming window. For any integer sample index $n$ with $0 \\le n \\le N-1$, define the Hanning window $w_{\\mathrm{Hann}}[n]$ and the Hamming window $w_{\\mathrm{Hamming}}[n]$ by\n$$\nw_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right),\n\\quad\nw_{\\mathrm{Hamming}}[n] = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\nConsider a real-valued discrete-time test signal $x[n]$ composed of two cosines with normalized frequencies (in cycles per sample) $\\nu_0$ and $\\nu_1$, amplitudes $A_0$ and $A_1$, and phases $\\phi_0$ and $\\phi_1$ given by\n$$\nx[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n + \\phi_0\\right) + A_1 \\cos\\!\\left(2\\pi \\nu_1 n + \\phi_1\\right), \\quad 0 \\le n \\le N-1.\n$$\nFor any window $w[n]$, define the $N$-point Discrete Fourier Transform $X_w[k]$ of the windowed signal $x[n]w[n]$ by\n$$\nX_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-i 2\\pi kn/N}, \\quad 0 \\le k \\le N-1,\n$$\nand define the window-sum normalization constant\n$$\nS_w = \\sum_{n=0}^{N-1} w[n].\n$$\nLet $k_1$ be the nearest Discrete Fourier Transform bin index to the weak-tone frequency $\\nu_1$, defined by\n$$\nk_1 = \\left\\lfloor \\nu_1 N + \\tfrac{1}{2} \\right\\rfloor \\bmod N.\n$$\nTo quantify whether the weak tone at frequency $\\nu_1$ is revealed or obscured in the presence of the strong tone at frequency $\\nu_0$, proceed as follows. For a given window $w[n]$, form two spectra at bin $k_1$:\n$$\nM_{\\mathrm{both},w} = \\frac{\\left|X^{(\\mathrm{both})}_w[k_1]\\right|}{S_w}, \\quad\nM_{\\mathrm{strong},w} = \\frac{\\left|X^{(\\mathrm{strong})}_w[k_1]\\right|}{S_w},\n$$\nwhere $X^{(\\mathrm{both})}_w[k]$ is the Discrete Fourier Transform of the full signal $x[n]$ and $X^{(\\mathrm{strong})}_w[k]$ is the Discrete Fourier Transform of the signal obtained by setting $A_1$ to $0$ (that is, containing only the strong tone at $\\nu_0$). Define the signal-to-leakage ratio\n$$\n\\mathrm{SLR}_w = \\frac{M_{\\mathrm{both},w}}{M_{\\mathrm{strong},w}},\n$$\nwith the convention that any division by $0$ is to be treated as $+\\infty$ if $M_{\\mathrm{both},w} > 0$ and as $0$ if $M_{\\mathrm{both},w} = 0$. Declare that the weak tone at $\\nu_1$ is detected under window $w[n]$ if and only if both of the following conditions hold:\n$$\n\\mathrm{SLR}_w \\ge r, \\quad M_{\\mathrm{both},w} \\ge \\theta,\n$$\nfor given thresholds $r$ and $\\theta$.\n\nYour task is to design and analyze a test signal that highlights the difference between the far-out side-lobe behavior of the Hamming and Hanning windows, such that the Hamming window’s relatively high far-out side-lobes obscure a weak feature that the Hanning window’s faster-decaying side-lobes reveal.\n\nUse the following fixed parameter values, which constitute the test suite. In all cases, take $N = 4096$, $\\phi_0 = 0$, $\\phi_1 = 0$, $r = 2$, and $\\theta = 10^{-5}$. The units for $\\nu_0$ and $\\nu_1$ are cycles per sample.\n\n- Test case $1$: $A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 10^{-4}$, $\\nu_1 = 0.6$.\n- Test case $2$: $A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 5 \\times 10^{-3}$, $\\nu_1 = 0.6$.\n- Test case $3$: $A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 10^{-6}$, $\\nu_1 = 0.6$.\n\nFor each test case, compute two booleans indicating whether the weak tone at $\\nu_1$ is detected under the Hanning window and under the Hamming window, respectively, using the detection rule above.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to a test case and is itself a two-element list $[\\text{Hann\\_detected}, \\text{Hamming\\_detected}]$ with literal booleans. For example, the output should have the form\n$[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$.", "solution": "The problem requires an analysis of the spectral characteristics of the Hanning and Hamming window functions. Specifically, we are to construct a scenario where a weak sinusoidal signal, obscured by the spectral leakage of a strong, distant tone under a Hamming window, is correctly detected when a Hanning window is used instead. This exercise demonstrates the fundamental trade-off in window function design: the suppression of near versus far side-lobes.\n\nFirst, we establish the theoretical foundation. The Discrete Fourier Transform (DFT) of a finite-duration signal inherently suffers from spectral leakage. This phenomenon arises because the implicit rectangular windowing of the signal corresponds to a convolution of the true signal spectrum with the spectrum of the rectangular window, which is a sinc function. The sinc function possesses high-amplitude side-lobes that decay slowly, at a rate of $1/\\nu$, where $\\nu$ is the frequency offset. Tapered window functions, such as the Hanning and Hamming windows, are applied to the signal to reduce this leakage by providing a spectrum with much lower side-lobes.\n\nThe Hanning and Hamming windows are both members of the generalized cosine window family. Their definitions are given as:\n$$\nw_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right) = 0.5 - 0.5\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\n$$\n$$\nw_{\\mathrm{Hamming}}[n] = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\n$$\nfor the sample index $n$ from $0$ to $N-1$. The choice of coefficients dictates their spectral properties. The Hanning window exhibits excellent far-out side-lobe suppression, with its spectral envelope decaying at approximately $18$ dB per octave (proportional to $1/\\nu^3$). However, its main lobe is wider and its first side-lobe is relatively high, at approximately $-31.5$ dB relative to the main lobe peak.\n\nThe Hamming window, by contrast, is optimized to minimize the amplitude of the highest side-lobe, achieving a peak side-lobe level of approximately $-42.8$ dB. This is achieved at the cost of slower asymptotic decay. The far-out side-lobes of the Hamming window's spectrum decay at only $6$ dB per octave (proportional to $1/\\nu$), which is no better than the rectangular window.\n\nThis problem is designed to exploit this difference. The strong tone at frequency $\\nu_0$ is placed far from the weak tone at frequency $\\nu_1$. The spectral leakage from the strong tone at the frequency bin corresponding to the weak tone, $k_1$, is therefore determined by the *far-out* side-lobes of the window's transform. We expect the leakage noise floor from the Hamming window to be substantially higher than that from the Hanning window at this large frequency separation.\n\nThe computational procedure to verify this is as follows:\n\n1.  For each test case, we are given amplitudes $A_0, A_1$ and normalized frequencies $\\nu_0, \\nu_1$. The signal length is fixed at $N=4096$, and phases are $\\phi_0 = \\phi_1 = 0$. We generate two discrete-time signals over $n \\in [0, N-1]$:\n    $$\n    x^{(\\mathrm{both})}[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n\\right) + A_1 \\cos\\!\\left(2\\pi \\nu_1 n\\right)\n    $$\n    $$\n    x^{(\\mathrm{strong})}[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n\\right)\n    $$\n\n2.  We generate the Hanning, $w_{\\mathrm{Hann}}[n]$, and Hamming, $w_{\\mathrm{Hamming}}[n]$, window sequences of length $N=4096$ according to their definitions.\n\n3.  For each window $w[n]$, we compute the windowed signals, for instance, $x^{(\\mathrm{both})}[n]w[n]$. Then, we compute their $N$-point DFTs, $X^{(\\mathrm{both})}_w[k]$ and $X^{(\\mathrm{strong})}_w[k]$, using the formula:\n    $$\n    X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-i 2\\pi kn/N}\n    $$\n\n4.  We identify the target frequency bin $k_1$ for the weak tone. With $\\nu_1 = 0.6$ and $N=4096$, the index is:\n    $$\n    k_1 = \\left\\lfloor \\nu_1 N + \\tfrac{1}{2} \\right\\rfloor \\bmod N = \\left\\lfloor 0.6 \\times 4096 + 0.5 \\right\\rfloor \\bmod 4096 = \\left\\lfloor 2457.6 + 0.5 \\right\\rfloor = 2458\n    $$\n\n5.  We calculate the window-sum normalization constants, $S_{\\mathrm{Hann}} = \\sum w_{\\mathrm{Hann}}[n]$ and $S_{\\mathrm{Hamming}} = \\sum w_{\\mathrm{Hamming}}[n]$.\n\n6.  For each window, we compute the normalized DFT magnitudes at bin $k_1$:\n    $$\n    M_{\\mathrm{both},w} = \\frac{\\left|X^{(\\mathrm{both})}_w[k_1]\\right|}{S_w}, \\quad\n    M_{\\mathrm{strong},w} = \\frac{\\left|X^{(\\mathrm{strong})}_w[k_1]\\right|}{S_w}\n    $$\n    $M_{\\mathrm{strong},w}$ represents the spectral leakage from the strong tone into the target bin. $M_{\\mathrm{both},w}$ represents the coherent sum of this leakage and the contribution from the weak tone.\n\n7.  We compute the signal-to-leakage ratio, $\\mathrm{SLR}_w = M_{\\mathrm{both},w} / M_{\\mathrm{strong},w}$. The problem specifies handling of the case $M_{\\mathrm{strong},w}=0$, although this is physically improbable here.\n\n8.  Finally, for each window and each test case, we apply the detection rule. The weak tone is detected if and only if both conditions are met:\n    $$\n    \\mathrm{SLR}_w \\ge r, \\quad M_{\\mathrm{both},w} \\ge \\theta\n    $$\n    where the thresholds are given as $r=2$ and $\\theta=10^{-5}$.\n\nThe separation between the tones is $\\Delta \\nu = |\\nu_1 - \\nu_0| = |0.6 - 0.101234567| \\approx 0.499$, which is a very large frequency offset. At this offset, the Hanning window's $-18$ dB/octave rolloff will result in a much smaller leakage magnitude $M_{\\mathrm{strong, Hann}}$ compared to the Hamming window's $-6$ dB/octave rolloff, which will produce a larger $M_{\\mathrm{strong, Hamming}}$. This will directly impact the $\\mathrm{SLR}$ criterion.\n\n-   For Test Case 1 ($A_1=10^{-4}$): The weak tone's amplitude is modest. The Hanning window's low leakage should yield a large $\\mathrm{SLR}_{\\mathrm{Hann}}$, leading to detection. The Hamming window's high leakage will make $M_{\\mathrm{strong, Hamming}}$ comparable to the weak tone's contribution, so $M_{\\mathrm{both, Hamming}} \\approx M_{\\mathrm{strong, Hamming}}$, thus $\\mathrm{SLR}_{\\mathrm{Hamming}} \\approx 1$, failing the $\\mathrm{SLR} \\ge 2$ test.\n-   For Test Case 2 ($A_1=5 \\times 10^{-3}$): The weak tone is much stronger. Its contribution to $M_{\\mathrm{both},w}$ will dominate the leakage term for both windows. Thus, $M_{\\mathrm{both},w} \\gg M_{\\mathrm{strong},w}$ in both cases, leading to a large $\\mathrm{SLR}_w$ and successful detection for both.\n-   For Test Case 3 ($A_1=10^{-6}$): The weak tone is extremely faint. The magnitude of the weak tone's own spectral peak is approximately $A_1/2 = 5 \\times 10^{-7}$. This is below the absolute detection threshold $\\theta = 10^{-5}$. Therefore, we predict that $M_{\\mathrm{both},w}$ will fail to meet the threshold for either window, resulting in non-detection in both instances.\n\nThe algorithm will now be implemented to confirm this analysis.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the detection of a weak sinusoidal signal in the presence of a strong\n    one using Hanning and Hamming windows, based on specified criteria.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    N = 4096\n    phi0 = 0.0\n    phi1 = 0.0\n    r_threshold = 2.0\n    theta_threshold = 1e-5\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 1e-4, 'nu1': 0.6},\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 5e-3, 'nu1': 0.6},\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 1e-6, 'nu1': 0.6},\n    ]\n\n    results = []\n\n    # Discrete time sequence index\n    n = np.arange(N)\n\n    # Generate window functions\n    w_hann = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n    w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n    windows = {'Hann': w_hann, 'Hamming': w_hamming}\n\n    for case in test_cases:\n        A0, nu0, A1, nu1 = case['A0'], case['nu0'], case['A1'], case['nu1']\n\n        # Generate test signals\n        x_strong = A0 * np.cos(2 * np.pi * nu0 * n + phi0)\n        x_both = x_strong + A1 * np.cos(2 * np.pi * nu1 * n + phi1)\n\n        # Calculate the target bin index for the weak tone\n        k1 = int(np.floor(nu1 * N + 0.5)) % N\n\n        case_results = []\n        # Process for both Hanning and Hamming windows\n        for window_name in ['Hann', 'Hamming']:\n            w = windows[window_name]\n\n            # Calculate window-sum normalization constant\n            S_w = np.sum(w)\n\n            # Apply windowing and compute DFTs\n            X_strong_w = np.fft.fft(x_strong * w)\n            X_both_w = np.fft.fft(x_both * w)\n\n            # Calculate normalized magnitudes at bin k1\n            M_strong_w = np.abs(X_strong_w[k1]) / S_w\n            M_both_w = np.abs(X_both_w[k1]) / S_w\n            \n            # Calculate Signal-to-Leakage Ratio (SLR)\n            if M_strong_w == 0.0:\n                slr_w = np.inf if M_both_w > 0.0 else 0.0\n            else:\n                slr_w = M_both_w / M_strong_w\n\n            # Apply detection criteria\n            is_detected = (slr_w >= r_threshold) and (M_both_w >= theta_threshold)\n            case_results.append(is_detected)\n            \n        results.append(case_results)\n\n    # Format the final output string as specified\n    inner_parts = [f\"[{hann_res},{hamming_res}]\" for hann_res, hamming_res in results]\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2399887"}, {"introduction": "In many real-world applications, from astronomy to acoustics, we need to detect faint signals in the presence of much stronger ones. This task puts your understanding of window functions to a practical test, evaluating which window—Hanning or Hamming—is better suited for resolving a weak tone under different conditions. By implementing a quantitative \"detection advantage\" metric, you will learn to make informed, data-driven decisions about which window to use based on the specific characteristics of the signal being analyzed [@problem_id:2399897].", "problem": "A continuous-time signal is defined by the superposition of two sinusoidal components with markedly different amplitudes: $$x(t) = \\sin(2\\pi f_1 t) + 10^{-4}\\,\\sin(2\\pi f_2 t),$$ where $t$ is time in seconds, and $f_1$ and $f_2$ are frequencies in Hertz. Consider the uniformly sampled discrete-time sequence of length $N$ obtained with sampling frequency $f_s$ as $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1,$$ where all angles are in radians. To suppress spectral leakage when estimating the spectrum, the data are multiplied by a window $w[n]$ prior to computing the Discrete Fourier Transform (DFT). Two classical windows are to be compared:\n\n- The Hann (sometimes called “Hanning”) window: $$w_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)\\right), \\quad n=0,1,\\dots,N-1.$$\n- The Hamming window: $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right), \\quad n=0,1,\\dots,N-1.$$\n\nStart from the fundamental definitions that windowing in the time domain is multiplication of $x[n]$ by $w[n]$, and that the DFT of a windowed signal $x[n]w[n]$ at frequency bin $k$ of an $N_{\\mathrm{FFT}}$-point transform is $$X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-j 2\\pi \\frac{k n}{N_{\\mathrm{FFT}}}}, \\quad k=0,1,\\dots,N_{\\mathrm{FFT}}-1,$$ where $j$ is the imaginary unit and $N_{\\mathrm{FFT}}$ is a positive integer used for zero-padding to refine spectral sampling. Use the magnitude spectrum computed via a Fast Fourier Transform (FFT) consistent with the DFT definition.\n\nYour task is to design and implement an algorithm that, for each specified test case, decides which window better “reveals” the weak component at frequency $f_2$ in the presence of the much stronger component at $f_1$. To make this decision precise and reproducible, define the following detection advantage metric for a given window $w$:\n\n1. Choose an FFT length $N_{\\mathrm{FFT}} = L N$ for a fixed integer zero-padding factor $L$.\n2. Map frequency $f$ in Hertz to the nearest integer FFT bin index $k(f) = \\left\\lfloor \\frac{f}{f_s} N_{\\mathrm{FFT}} + \\tfrac{1}{2}\\right\\rfloor$.\n3. Define a local signal band around $f_2$ as the bins $k \\in \\{k(f_2)-K, \\dots, k(f_2)+K\\}$ for a fixed small integer $K$ and take $$P_{\\mathrm{sig}}(w) = \\max_{k \\in \\{k(f_2)-K,\\dots,k(f_2)+K\\}} |X_w[k]|.$$\n4. Define a local floor band around $f_2$ as the bins $k \\in \\{k(f_2)-B, \\dots, k(f_2)+B\\}$ excluding a guard band around $f_2$ of half-width $G$ bins, that is, exclude $k \\in \\{k(f_2)-G, \\dots, k(f_2)+G\\}$. If indices fall outside the valid range, clamp them to the nearest valid index. Compute $$F_{\\mathrm{floor}}(w) = \\max_{\\substack{k \\in \\{k(f_2)-B,\\dots,k(f_2)+B\\} \\\\ k \\notin \\{k(f_2)-G,\\dots,k(f_2)+G\\}}} |X_w[k]|.$$\n5. The detection advantage is $$R(w) = \\frac{P_{\\mathrm{sig}}(w)}{F_{\\mathrm{floor}}(w)}.$$\n\nUsing this metric, declare the better window for a test case as follows: output $1$ if $R(w_{\\mathrm{Hann}}) > R(w_{\\mathrm{Hamm}})$ by more than a relative tolerance $\\varepsilon$, output $2$ if $R(w_{\\mathrm{Hamm}}) > R(w_{\\mathrm{Hann}})$ by more than the same tolerance, and output $0$ if the two advantages are within tolerance. Use $$\\varepsilon = 10^{-3}.$$ The tolerance comparison must be performed as $$\\left|R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\right| \\le \\varepsilon \\,\\max\\!\\left(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}})\\right).$$\n\nImplement the computation using the following fixed analysis parameters for all test cases:\n- Zero-padding factor $L = 8$, so that $N_{\\mathrm{FFT}} = 8N$.\n- Signal-band half-width $K = 2$.\n- Floor-band half-width $B = 400$.\n- Guard-band half-width $G = 5$.\n\nPhysical and numerical units:\n- Frequencies $f_s$, $f_1$, $f_2$ are in Hertz.\n- Time is in seconds.\n- Angles inside trigonometric functions are in radians.\n\nTest suite:\n- Case $1$: $f_s = 32768$, $N = 8192$, $f_1 = 1000$, $f_2 = 10000$.\n- Case $2$: $f_s = 32768$, $N = 8192$, $f_1 = 5000$, $f_2 = 5000.5$.\n- Case $3$: $f_s = 48000$, $N = 4096$, $f_1 = 1000$, $f_2 = 1234$.\n\nYour program must compute the decision for each case as an integer in $\\{0,1,2\\}$ using the rule above and produce a single line of output containing the three results as a comma-separated list enclosed in square brackets, for example, $$[r_1,r_2,r_3],$$ where $r_i$ corresponds to Case $i$ in order. No other text should be printed.", "solution": "The problem as stated is valid. It is a well-posed, scientifically grounded problem in the domain of digital signal processing, a fundamental area of computational physics and engineering. All parameters, definitions, and procedures are specified with sufficient mathematical and algorithmic rigor to permit a unique and verifiable solution. There are no contradictions, ambiguities, or violations of established scientific principles. We may therefore proceed with the solution.\n\nThe objective is to compare the efficacy of the Hann and Hamming window functions in resolving a weak sinusoidal signal component at frequency $f_2$ in the presence of a strong sinusoidal component at frequency $f_1$. The comparison is not qualitative but is based on a quantitative detection advantage metric, $R(w)$, which is defined as the ratio of the peak signal magnitude in a narrow band around $f_2$ to the peak spectral floor magnitude in a nearby, but non-contiguous, band. The spectral floor is predominantly composed of leakage from the strong signal at $f_1$. A higher value of $R(w)$ signifies a better ability to distinguish the weak signal from this leakage background.\n\nThe theoretical basis for this comparison lies in the differing properties of the two windows in the frequency domain. Windowing in the time domain is equivalent to convolution in the frequency domain. The Discrete Fourier Transform (DFT) of a windowed sinusoid is a shifted version of the window's own transform.\n- The **Hann window**, with coefficients derived from a raised cosine, has side-lobes that decay rapidly (approximately $18$ dB per octave). This property is advantageous for resolving signals with large frequency separation, as the leakage from the strong signal diminishes quickly with distance.\n- The **Hamming window**, a modification of the Hann window, is optimized to minimize the level of the highest side-lobe (to approximately $-42.7$ dB relative to the main lobe peak). This comes at the cost of a slower side-lobe decay rate. This is beneficial for resolving closely spaced signals, where the nearest side-lobes of the strong signal create the most significant interference.\n\nThe problem, therefore, presents test cases that probe these different regimes: large frequency separation (Case $1$), extremely small separation (Case $2$), and intermediate separation (Case $3$). The solution requires a direct numerical implementation of the specified algorithm.\n\nThe procedure for each test case is as follows:\n\n1.  **Signal and Window Generation**: For a given set of parameters $\\{f_s, N, f_1, f_2\\}$, we generate the discrete-time signal $x[n]$ of length $N$ according to the formula:\n    $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1.$$\n    The Hann and Hamming window functions, $w_{\\mathrm{Hann}}[n]$ and $w_{\\mathrm{Hamm}}[n]$, of length $N$ are generated according to their definitions:\n    $$w_{\\mathrm{Hann}}[n] = 0.5 - 0.5 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n    $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n\n2.  **Spectral Analysis**: For each window $w[n]$, the windowed signal $x[n]w[n]$ is computed. The $N_{\\mathrm{FFT}}$-point DFT of this signal is then calculated using a Fast Fourier Transform (FFT) algorithm, with zero-padding up to length $N_{\\mathrm{FFT}} = L N = 8N$. This gives the complex spectrum $X_w[k]$. The magnitude spectrum $|X_w[k]|$ is used for the subsequent calculations.\n\n3.  **Metric Calculation**: The detection advantage metric $R(w)$ is computed.\n    a. The frequency $f_2$ is mapped to the nearest integer FFT bin index $k(f_2) = \\left\\lfloor \\frac{f_2}{f_s} N_{\\mathrm{FFT}} + \\frac{1}{2}\\right\\rfloor$.\n    b. The peak signal magnitude, $P_{\\mathrm{sig}}(w)$, is found by taking the maximum of $|X_w[k]|$ over the signal band, defined as the set of bins $\\{k | k \\in [k(f_2)-K, k(f_2)+K]\\}$, with $K=2$.\n    c. The peak floor magnitude, $F_{\\mathrm{floor}}(w)$, is found by taking the maximum of $|X_w[k]|$ over the floor-band region. This region includes bins from $k(f_2)-B$ to $k(f_2)+B$ ($B=400$) but excludes a central guard band from $k(f_2)-G$ to $k(f_2)+G$ ($G=5$). Specifically, the search for the maximum is over the union of two disjoint index ranges: $[k(f_2)-B, k(f_2)-G-1]$ and $[k(f_2)+G+1, k(f_2)+B]$. Any indices falling outside the valid range $[0, N_{\\mathrm{FFT}}-1]$ are clamped to the nearest boundary.\n    d. The detection advantage is the ratio $R(w) = P_{\\mathrm{sig}}(w) / F_{\\mathrm{floor}}(w)$.\n\n4.  **Decision**: The calculated advantages $R(w_{\\mathrm{Hann}})$ and $R(w_{\\mathrm{Hamm}})$ are compared. A decision is made based on the specified relative tolerance rule with $\\varepsilon = 10^{-3}$:\n    - If $|\\,R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\,| \\le \\varepsilon \\max(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}}))$, the windows are considered equivalent in performance, and the result is $0$.\n    - If $R(w_{\\mathrm{Hann}})$ is greater than $R(w_{\\mathrm{Hamm}})$ beyond this tolerance, the Hann window is superior, and the result is $1$.\n    - If $R(w_{\\mathrm{Hamm}})$ is greater than $R(w_{\\mathrm{Hann}})$ beyond this tolerance, the Hamming window is superior, and the result is $2$.\n\nThis complete procedure is executed for each of the three test cases provided. The final output is an ordered list of these integer results.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    # Define the fixed analysis parameters from the problem statement.\n    L = 8\n    K = 2\n    B = 400\n    G = 5\n    epsilon = 1e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_s, N, f_1, f_2)\n        (32768, 8192, 1000, 10000),\n        (32768, 8192, 5000, 5000.5),\n        (48000, 4096, 1000, 1234),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f_s, N, f_1, f_2 = case\n        \n        N_fft = L * N\n        n = np.arange(N)\n        \n        # Generate the discrete-time signal\n        x_n = np.sin(2 * np.pi * f_1 / f_s * n) + 1e-4 * np.sin(2 * np.pi * f_2 / f_s * n)\n        \n        # Define the windows. Note: np.hanning and np.hamming implement the required symmetric (N-1) form.\n        windows = {\n            \"hann\": 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1)),\n            \"hamm\": 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1)),\n        }\n        \n        adv_ratios = {}\n        \n        for name, w in windows.items():\n            # Apply the window to the signal\n            x_w = x_n * w\n            \n            # Compute the FFT and its magnitude\n            X_w = fft(x_w, n=N_fft)\n            mag_X_w = np.abs(X_w)\n            \n            # Map frequency f2 to the nearest integer bin index\n            k_f2 = int(np.round((f_2 / f_s) * N_fft))\n            \n            # 1. Compute P_sig(w)\n            sig_band_start = np.clip(k_f2 - K, 0, N_fft - 1)\n            sig_band_end = np.clip(k_f2 + K, 0, N_fft - 1)\n            P_sig = np.max(mag_X_w[sig_band_start : sig_band_end + 1])\n            \n            # 2. Compute F_floor(w)\n            # The floor is the max over two bands:\n            # [k_f2 - B, k_f2 - G - 1] and [k_f2 + G + 1, k_f2 + B]\n            \n            # Lower band\n            lower_band_start = k_f2 - B\n            lower_band_end = k_f2 - G - 1\n            \n            # Upper band\n            upper_band_start = k_f2 + G + 1\n            upper_band_end = k_f2 + B\n            \n            # Clamp indices to valid range [0, N_fft - 1]\n            c_lower_start = np.clip(lower_band_start, 0, N_fft - 1)\n            c_lower_end = np.clip(lower_band_end, 0, N_fft - 1)\n            c_upper_start = np.clip(upper_band_start, 0, N_fft - 1)\n            c_upper_end = np.clip(upper_band_end, 0, N_fft - 1)\n            \n            max_lower = 0.0\n            if c_lower_start <= c_lower_end:\n                max_lower = np.max(mag_X_w[c_lower_start : c_lower_end + 1])\n            \n            max_upper = 0.0\n            if c_upper_start <= c_upper_end:\n                max_upper = np.max(mag_X_w[c_upper_start : c_upper_end + 1])\n            \n            F_floor = np.max([max_lower, max_upper])\n            \n            # 3. Compute detection advantage R(w)\n            adv_ratios[name] = P_sig / F_floor if F_floor > 0 else np.inf\n\n        # Compare R(w_hann) and R(w_hamm)\n        R_hann = adv_ratios[\"hann\"]\n        R_hamm = adv_ratios[\"hamm\"]\n        \n        # Apply the decision rule with relative tolerance\n        if abs(R_hann - R_hamm) <= epsilon * max(R_hann, R_hamm):\n            results.append(0)\n        elif R_hann > R_hamm:\n            results.append(1)\n        else: # R_hamm > R_hann\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399897"}]}