{"hands_on_practices": [{"introduction": "To begin our hands-on exploration, we will tackle the fundamental challenge of simulating orbital motion: long-term stability. This first exercise [@problem_id:2390259] contrasts the standard explicit Euler method with its semi-implicit counterpart, the Euler-Cromer method. By implementing both, you will directly observe how a subtle change in the update logic creates a simple symplectic integrator, leading to dramatically better energy conservation over many orbits and revealing a core principle of computational astrophysics.", "problem": "Consider a Newtonian two-body system modeling a comet of negligible mass orbiting a central massive body. Work in non-dimensional gravitational units where the product of the gravitational constant and the central mass is normalized to $G M = 1$, and the comet mass is $m = 1$. The motion is confined to a plane, and the position vector is $\\mathbf{x}(t) \\in \\mathbb{R}^2$ with velocity $\\mathbf{v}(t) = d\\mathbf{x}/dt$. The fundamental laws to be used are Newton’s second law and the inverse-square gravitational force, which imply the first-order system\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\nThe total mechanical energy (the Hamiltonian) in these units is\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\nwhich is constant in time for the continuous dynamics.\n\nYour task is to design and implement two first-order time-stepping integrators for this ordinary differential equation (ODE) based only on the core definitions $d\\mathbf{x}/dt = \\mathbf{v}$ and $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$:\n- A standard explicit Euler integrator that advances position using the velocity evaluated at the current time level.\n- A semi-implicit Euler integrator (also called Euler–Cromer) that advances velocity using acceleration at the current position and then advances position using the updated velocity within the same step.\n\nFrom first principles, derive the update logic for each method by discretizing time in steps of size $\\Delta t$ and consistently applying the definitions above to construct the step-to-step advances. Do not introduce any extraneous approximations beyond this explicit time discretization, and ensure that both methods use the same force evaluation $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$ at the start of each step.\n\nUse the following test suite. For each case, integrate for a prescribed number of orbital periods $P$ using a fixed time step $\\Delta t$. The orbital period for a Keplerian ellipse with semi-major axis $a$ in these units is $T = 2\\pi a^{3/2}$. The initial states are chosen to be on either a circular orbit or at aphelion of an ellipse, with the initial velocity perpendicular to the radius vector and directed for prograde motion. All quantities are dimensionless in these units.\n\n- Test case $1$ (circular “happy path”): $a = 1$, $e = 0$, initial state $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.01$, $P = 50$.\n- Test case $2$ (moderately eccentric comet): $a = 1$, $e = 0.6$, initial state at aphelion $\\mathbf{x}_0 = (1.6, 0)$, $\\mathbf{v}_0 = (0, 0.5)$, $\\Delta t = 0.001$, $P = 20$.\n- Test case $3$ (highly eccentric comet): $a = 1$, $e = 0.9$, initial state at aphelion $\\mathbf{x}_0 = (1.9, 0)$, $\\mathbf{v}_0 \\approx (0, 0.22941573387)$, $\\Delta t = 0.0005$, $P = 5$.\n- Test case $4$ (boundary time step, circular): $a = 1$, $e = 0$, initial state $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.05$, $P = 5$.\n\nFor each test case, compute the relative terminal energy drift for each integrator,\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\nwhere $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ is the number of steps taken, and then return the ratio\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\nThis ratio $r$ is dimensionless. A value $r < 1$ indicates that the semi-implicit Euler (Euler–Cromer) method exhibits smaller absolute energy drift than the standard explicit Euler over the same duration.\n\nFinal output format: Your program should produce a single line of output containing the results as a comma-separated list of the $r$ values for test cases $1$–$4$ in order, enclosed in square brackets, for example, $[r_1,r_2,r_3,r_4]$. The entries must be floating-point numbers. No physical units appear in the output because all quantities are non-dimensional by construction.\n\nYour implementation must be completely self-contained and must not read any input. The answer for each test case is a single floating-point number $r$. The set of four outputs must appear on one line following the format above. Ensure numerical stability by using standard double-precision arithmetic throughout and by faithfully implementing the two requested integrators as derived from the stated fundamental laws and definitions.", "solution": "The problem statement has been subjected to rigorous validation and is found to be valid. It is scientifically grounded in the principles of classical mechanics, specifically the Kepler problem, and is mathematically well-posed as an initial value problem for a system of ordinary differential equations. The parameters and objectives are defined with precision, containing no contradictions, ambiguities, or factual inaccuracies. The task is a standard exercise in computational physics, requiring the derivation and comparison of two fundamental numerical integrators.\n\nWe proceed with the derivation and solution.\n\nThe system is described by a set of first-order ordinary differential equations (ODEs) for the position vector $\\mathbf{x}(t) \\in \\mathbb{R}^2$ and velocity vector $\\mathbf{v}(t) \\in \\mathbb{R}^2$:\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\nHere, $\\mathbf{a}(\\mathbf{x})$ is the acceleration due to gravity, with the gravitational parameter $G M$ set to $1$.\n\nWe will discretize time with a constant time step $\\Delta t$. Let the state of the system at time $t_n = n \\Delta t$ be $(\\mathbf{x}_n, \\mathbf{v}_n)$. We seek to find the state $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$ at time $t_{n+1} = t_n + \\Delta t$.\n\n**Derivation of the Standard Explicit Euler Integrator**\n\nThe explicit, or forward, Euler method approximates the derivatives using the values at the current time level, $t_n$.\nThe discrete approximation of the first ODE is:\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\nSimilarly, for the second ODE:\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\nRearranging these expressions gives the update rules for the explicit Euler method. First, the acceleration $\\mathbf{a}_n$ is computed from the current position $\\mathbf{x}_n$. Then, both position and velocity are advanced using the state at time $t_n$.\n\nThe update logic for a single step is:\n1.  Compute acceleration: $\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  Update velocity: $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  Update position: $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\nThe critical feature is that the new position $\\mathbf{x}_{n+1}$ is calculated using the old velocity $\\mathbf{v}_n$, not the newly computed velocity $\\mathbf{v}_{n+1}$.\n\n**Derivation of the Semi-Implicit Euler (Euler–Cromer) Integrator**\n\nThe semi-implicit Euler method, also known as the Euler-Cromer method, introduces a subtle but crucial modification. The update for the velocity is performed first, and this newly computed velocity is then immediately used to update the position. This \"mixing\" of time levels within a single step defines its semi-implicit nature.\n\nThe update for velocity remains the same as the explicit method:\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\nHowever, the position update uses the new velocity $\\mathbf{v}_{n+1}$:\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\nThe update logic for a single step is:\n1.  Compute acceleration: $\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  Update velocity: $\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  Update position: $\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\nThis method is a simple symplectic integrator. For Hamiltonian systems like the Kepler problem, such integrators exhibit superior long-term stability, particularly concerning energy conservation. They do not conserve energy exactly but the energy error typically remains bounded, oscillating around the true value, whereas the explicit Euler method often leads to a secular drift in energy.\n\n**Simulation and Evaluation Methodology**\n\nFor each test case, we perform two simulations, one with each integrator.\nThe initial state is $(\\mathbf{x}_0, \\mathbf{v}_0)$.\nThe total integration time is specified by the number of orbital periods, $P$. The period $T$ for a Keplerian orbit with semi-major axis $a$ is $T = 2\\pi a^{3/2}$.\nThe total number of required steps is $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$.\n\nThe conserved quantity for the continuous system is the mechanical energy, or Hamiltonian:\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\nWe calculate the initial energy $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$. After $N$ steps, we obtain the final state $(\\mathbf{x}_N, \\mathbf{v}_N)$ and calculate the final energy $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$.\n\nThe performance of each integrator is quantified by the relative terminal energy drift, $\\delta$:\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\nThe problem requires the computation of the ratio $r$ of these drifts for the two methods:\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\nA value of $r < 1$ indicates that the semi-implicit Euler-Cromer method provides better long-term energy conservation than the standard explicit Euler method for the given parameters. The implementation will follow these derivations precisely.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            # If Euler has no drift, and Cromer does, ratio is infinity.\n            # If neither has drift, ratio is undefined, but 1.0 is a neutral choice.\n            # In practice, with finite precision, this is unlikely.\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390259"}, {"introduction": "Having seen the limitations of the simplest explicit method, we now turn to more powerful and widely used algorithms. This exercise [@problem_id:2423025] pits the famous fourth-order Runge-Kutta ($RK4$) method against the second-order symplectic Leapfrog integrator. You will discover that for preserving physical invariants like energy in long-term orbital simulations, the geometric structure-preserving nature of a symplectic method can be far more important than formal order of accuracy.", "problem": "Consider the planar two-body gravitational problem under Newton's law with gravitational parameter $\\mu$. In nondimensional units, set $\\mu = 1$ so that an orbit with semi-major axis $a = 1$ has period $T = 2\\pi$. The state is $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t)) \\in \\mathbb{R}^{4}$, where $\\mathbf{r}(t) \\in \\mathbb{R}^{2}$ is position and $\\mathbf{v}(t) \\in \\mathbb{R}^{2}$ is velocity. The equations of motion are the ordinary differential equation (ODE)\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad\n\\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}},\n$$\nwhere $\\|\\cdot\\|$ is the Euclidean norm. The conserved specific orbital energy (per unit mass) of the exact solution is\n$$\nE(\\mathbf{r},\\mathbf{v}) = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^{2} - \\frac{1}{\\|\\mathbf{r}\\|}.\n$$\nFor an ellipse with semi-major axis $a$ and eccentricity $e$, the pericenter radius is $r_{\\mathrm{p}} = a(1-e)$ and the pericenter speed is given by the vis-viva relation $v_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}$. You will use this to initialize the orbit at pericenter with $\\mathbf{r}(0) = (r_{\\mathrm{p}},0)$ and $\\mathbf{v}(0) = (0,v_{\\mathrm{p}})$ in the plane.\n\nYour task is to quantify and compare the long-term energy behavior of two numerical time integrators applied to this Keplerian orbit:\n\n- The classical fourth-order Runge–Kutta method (RK4) of order $p=4$.\n- The second-order symplectic Leapfrog (velocity Verlet) method of order $p=2$.\n\nFrom first principles, the order of accuracy of a one-step method is defined by the rate at which its global error decreases with time step $h$ over a fixed finite time, while the symplectic property concerns structure preservation in Hamiltonian systems. In gravitational two-body motion, the exact energy $E$ is constant, so any deviation is purely a numerical artifact. You will measure:\n\n1. A linear drift metric for RK4: construct the time series $y(t_n) = \\big(E(\\mathbf{r}_n,\\mathbf{v}_n) - E_0\\big)/|E_0|$ at discrete times $t_n = nh$ for $n=0,1,\\dots,N$, where $E_0 = E(\\mathbf{r}_0,\\mathbf{v}_0)$. Perform a least-squares linear fit of $y$ versus $t$ to estimate the drift rate $\\hat{s}$ (dimensionless per unit nondimensional time), and report the total linear drift over the simulation horizon as $\\Delta_{\\mathrm{RK4}} = \\hat{s}\\,T_{\\mathrm{end}}$, where $T_{\\mathrm{end}}$ is the total simulated time.\n2. A bounded oscillation metric for Leapfrog: compute the maximum absolute relative energy deviation over the trajectory, $\\mathcal{A}_{\\mathrm{LF}} = \\max_{0\\le n\\le N} |y(t_n)|$.\n\nImplement both integrators and compute these two metrics for the following test suite. All quantities are nondimensional; no physical units are required beyond the definitions given here. No angles are to be provided as inputs, and any internal angles used in your reasoning or code are in radians by default.\n\nTest suite (each case uses $a=1$, $\\mu=1$, and simulates for $N_{\\mathrm{per}}=200$ complete periods, so $T_{\\mathrm{end}} = N_{\\mathrm{per}}\\cdot 2\\pi$):\n\n- Case $1$: eccentricity $e=0$, time step $h=0.05$.\n- Case $2$: eccentricity $e=0.6$, time step $h=0.05$.\n- Case $3$: eccentricity $e=0.6$, time step $h=0.02$.\n\nFor each case, initialize at pericenter using the vis-viva relation as specified. For RK4, compute $\\Delta_{\\mathrm{RK4}}$ as defined above. For Leapfrog, compute $\\mathcal{A}_{\\mathrm{LF}}$ as defined above. Your program should produce a single line of output containing the results as a comma-separated list of three items, one per test case, where each item is itself a two-element list in the order $[\\Delta_{\\mathrm{RK4}},\\mathcal{A}_{\\mathrm{LF}}]$. For example, the overall output format must be\n$$\n[\\,[\\Delta_{\\mathrm{RK4}}^{(1)},\\mathcal{A}_{\\mathrm{LF}}^{(1)}],\\,[\\Delta_{\\mathrm{RK4}}^{(2)},\\mathcal{A}_{\\mathrm{LF}}^{(2)}],\\,[\\Delta_{\\mathrm{RK4}}^{(3)},\\mathcal{A}_{\\mathrm{LF}}^{(3)}]\\,],\n$$\nprinted on a single line with floating-point numbers. Round your printed floating-point numbers to a reasonable number of significant digits for readability.\n\nYour code must be completely self-contained, require no user input, and must implement both integrators and the energy diagnostics precisely as defined here.", "solution": "The problem requires a quantitative comparison of two numerical integrators, the fourth-order Runge-Kutta method (RK4) and the second-order Leapfrog method, applied to the planar gravitational two-body problem. The objective is to numerically demonstrate their characteristic long-term behavior with respect to a conserved quantity, the specific orbital energy. For a generic, non-structure-preserving method like RK4, the energy is expected to exhibit a secular drift. For a symplectic method like Leapfrog, the energy error is expected to remain bounded. We will compute specific metrics to quantify these phenomena.\n\nThe system is described by the state vector $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t))$ where $\\mathbf{r} \\in \\mathbb{R}^2$ is the position and $\\mathbf{v} \\in \\mathbb{R}^2$ is the velocity. The equations of motion are given by a first-order Ordinary Differential Equation (ODE) system $\\dot{\\mathbf{y}} = f(\\mathbf{y})$:\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}}\n$$\nThis corresponds to a gravitational parameter $\\mu=1$. The system is Hamiltonian, and its specific orbital energy $E$ is a conserved quantity of the exact solution:\n$$\nE(\\mathbf{r}, \\mathbf{v}) = \\frac{1}{2}\\|\\mathbf{v}\\|^{2} - \\frac{1}{\\|\\mathbf{r}\\|}\n$$\nThe orbits are initialized at pericenter. For a given semi-major axis $a$ and eccentricity $e$, the pericenter radius is $r_{\\mathrm{p}} = a(1-e)$. The initial position is set to $\\mathbf{r}(0) = (r_{\\mathrm{p}}, 0)$. The corresponding pericenter speed $v_{\\mathrm{p}}$ is found from the vis-viva equation:\n$$\nv_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}\n$$\nThe initial velocity is then $\\mathbf{v}(0) = (0, v_{\\mathrm{p}})$. For all specified test cases, we have $a=1$ and $\\mu=1$, which implies the exact initial energy is $E_0 = E(\\mathbf{r}(0), \\mathbf{v}(0)) = -\\frac{\\mu}{2a} = -0.5$.\n\nWe will implement two different one-step methods to approximate the solution $\\mathbf{y}_{n+1}$ at time $t_{n+1} = t_n + h$ from the solution $\\mathbf{y}_n$ at time $t_n$.\n\nFirst, the classical fourth-order Runge-Kutta (RK4) method of order $p=4$. For an ODE $\\dot{\\mathbf{y}} = f(t, \\mathbf{y})$, a single step is:\n$$\n\\begin{aligned}\n\\mathbf{k}_1 &= f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 &= f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 &= f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 &= f(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} &= \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\nHere, $\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ is a $4$-dimensional vector and the function $f$ does not depend explicitly on time $t$, so $f(t, \\mathbf{y}) = f(\\mathbf{y}) = (\\mathbf{v}, -\\mathbf{r}/\\|\\mathbf{r}\\|^3)$.\n\nSecond, the second-order Leapfrog method of order $p=2$, in its velocity Verlet formulation. This method is particularly suited for separable Hamiltonians of the form $H(\\mathbf{r},\\mathbf{v}) = T(\\mathbf{v}) + U(\\mathbf{r})$. The acceleration $\\mathbf{a}(\\mathbf{r})$ depends only on position. A single step, starting with $(\\mathbf{r}_n, \\mathbf{v}_n)$ and the pre-computed acceleration $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$, proceeds as follows:\n$$\n\\begin{aligned}\n\\mathbf{r}_{n+1} &= \\mathbf{r}_n + h \\mathbf{v}_n + \\frac{h^2}{2} \\mathbf{a}_n \\\\\n\\mathbf{a}_{n+1} &= \\mathbf{a}(\\mathbf{r}_{n+1}) = -\\frac{\\mathbf{r}_{n+1}}{\\|\\mathbf{r}_{n+1}\\|^{3}} \\\\\n\\mathbf{v}_{n+1} &= \\mathbf{v}_n + \\frac{h}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\n\\end{aligned}\n$$\nThis method is symplectic, which guarantees that it preserves the geometric structure of the phase space flow for Hamiltonian systems. A consequence is that while the numerical energy is not exactly conserved, its error remains bounded over very long integration times.\n\nAt each step $n=0, 1, \\dots, N$, we compute the numerical energy $E_n = E(\\mathbf{r}_n, \\mathbf{v}_n)$ and the relative energy error:\n$$\ny_n = \\frac{E_n - E_0}{|E_0|}\n$$\nThe evaluation of these integrators relies on two distinct metrics. For the RK4 method, we quantify the linear drift in energy. We perform a linear least-squares fit to the time series $(t_n, y_n)$, where $t_n = nh$, to find the model $y(t) = \\hat{s}t + c$. The slope $\\hat{s}$ represents the energy drift rate. The total drift over the simulation horizon $T_{\\mathrm{end}} = N_{\\mathrm{per}} \\cdot 2\\pi = 400\\pi$ is reported as:\n$$\n\\Delta_{\\mathrm{RK4}} = \\hat{s} \\cdot T_{\\mathrm{end}}\n$$\nFor the Leapfrog method, we quantify the bounded oscillation of the energy error by computing the maximum absolute relative energy deviation over the entire simulation:\n$$\n\\mathcal{A}_{\\mathrm{LF}} = \\max_{0 \\le n \\le N} |y_n|\n$$\n\nWe perform simulations for a total time of $T_{\\mathrm{end}} = 200 \\cdot 2\\pi = 400\\pi$. The number of steps is $N = \\text{round}(T_{\\mathrm{end}}/h)$. For each of the three test cases, we calculate the initial conditions, run both integrators, and compute the required metrics.\n\nCase 1: $e=0$, $h=0.05$.\n- Initial conditions: $a=1$, $e=0 \\implies r_{\\mathrm{p}} = 1$. $v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{1} - \\frac{1}{1})} = 1$. $\\mathbf{r}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$.\n- $N = \\text{round}(400\\pi / 0.05) = 25133$.\n\nCase 2: $e=0.6$, $h=0.05$.\n- Initial conditions: $a=1$, $e=0.6 \\implies r_{\\mathrm{p}} = 0.4$. $v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{0.4} - \\frac{1}{1})} = 2$. $\\mathbf{r}_0 = (0.4, 0)$, $\\mathbf{v}_0 = (0, 2)$.\n- $N = \\text{round}(400\\pi / 0.05) = 25133$.\n\nCase 3: $e=0.6$, $h=0.02$.\n- Initial conditions: Same as Case 2. $\\mathbf{r}_0 = (0.4, 0)$, $\\mathbf{v}_0 = (0, 2)$.\n- $N = \\text{round}(400\\pi / 0.02) = 62832$.\n\nFor each case, the initial energy is $E_0 = -0.5$. The computations are carried out according to the specified procedures. The implementation involves writing functions for the acceleration, the RK4 step, and the Leapfrog step, then orchestrating the simulations and metric calculations for each case in the test suite. The final output will be a list containing the pairs $[\\Delta_{\\mathrm{RK4}}, \\mathcal{A}_{\\mathrm{LF}}]$ for each test case.", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares RK4 and Leapfrog integrators for the Kepler problem\n    and computes energy drift/oscillation metrics.\n    \"\"\"\n    # Define problem constants and test suite\n    MU_GRAV = 1.0\n    SEMI_MAJOR_AXIS = 1.0\n    N_PERIODS = 200\n    T_END = N_PERIODS * 2 * np.pi\n\n    test_cases = [\n        {'e': 0.0, 'h': 0.05},\n        {'e': 0.6, 'h': 0.05},\n        {'e': 0.6, 'h': 0.02},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        eccentricity = case['e']\n        h = case['h']\n\n        # --- Initial Conditions ---\n        r_pericenter = SEMI_MAJOR_AXIS * (1 - eccentricity)\n        v_pericenter = np.sqrt(MU_GRAV * (2 / r_pericenter - 1 / SEMI_MAJOR_AXIS))\n        \n        r0 = np.array([r_pericenter, 0.0])\n        v0 = np.array([0.0, v_pericenter])\n        \n        y0 = np.concatenate([r0, v0])\n\n        E0 = 0.5 * np.linalg.norm(v0)**2 - MU_GRAV / np.linalg.norm(r0)\n        \n        N_steps = int(np.round(T_END / h))\n        times = np.linspace(0, N_steps * h, N_steps + 1)\n        \n        # --- Helper functions ---\n        def acceleration(r):\n            dist_cubed = np.linalg.norm(r)**3\n            return -MU_GRAV * r / dist_cubed\n\n        def f_ode(y):\n            r = y[:2]\n            v = y[2:]\n            accel = acceleration(r)\n            return np.concatenate([v, accel])\n            \n        def energy(r, v):\n            return 0.5 * np.linalg.norm(v)**2 - MU_GRAV / np.linalg.norm(r)\n\n        # --- Integrator 1: RK4 ---\n        y_rk4 = np.zeros((N_steps + 1, 4))\n        y_rk4[0] = y0\n        \n        for n in range(N_steps):\n            k1 = f_ode(y_rk4[n])\n            k2 = f_ode(y_rk4[n] + 0.5 * h * k1)\n            k3 = f_ode(y_rk4[n] + 0.5 * h * k2)\n            k4 = f_ode(y_rk4[n] + h * k3)\n            y_rk4[n+1] = y_rk4[n] + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        \n        energies_rk4 = np.array([energy(y[:2], y[2:]) for y in y_rk4])\n        rel_energy_error_rk4 = (energies_rk4 - E0) / np.abs(E0)\n        \n        # Calculate Delta_RK4\n        slope, _ = np.polyfit(times, rel_energy_error_rk4, 1)\n        delta_rk4 = slope * T_END\n\n        # --- Integrator 2: Leapfrog (Velocity Verlet) ---\n        r_lf = np.zeros((N_steps + 1, 2))\n        v_lf = np.zeros((N_steps + 1, 2))\n        \n        r_lf[0] = r0\n        v_lf[0] = v0\n        \n        a_n = acceleration(r_lf[0])\n        \n        for n in range(N_steps):\n            # Update position to full step\n            r_lf[n+1] = r_lf[n] + h * v_lf[n] + 0.5 * h**2 * a_n\n            \n            # Compute new acceleration\n            a_n_plus_1 = acceleration(r_lf[n+1])\n            \n            # Update velocity to full step\n            v_lf[n+1] = v_lf[n] + 0.5 * h * (a_n + a_n_plus_1)\n            \n            # Store new acceleration for a_n in the next step\n            a_n = a_n_plus_1\n\n        energies_lf = np.array([energy(r_lf[i], v_lf[i]) for i in range(N_steps + 1)])\n        rel_energy_error_lf = (energies_lf - E0) / np.abs(E0)\n\n        # Calculate A_LF\n        A_lf = np.max(np.abs(rel_energy_error_lf))\n\n        results.append([delta_rk4, A_lf])\n\n    # Format the final output string according to the problem specification\n    result_str = '[' + ','.join([f\"[{res[0]:.6e},{res[1]:.6e}]\" for res in results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "2423025"}, {"introduction": "Our final practice moves from stable, repeating orbits to the dramatic dynamics of a gravitational flyby. By simulating a comet's encounter with Jupiter [@problem_id:2389921], you will investigate how small changes in initial conditions can lead to vastly different outcomes, a hallmark of chaotic systems. This exercise also presents a crucial lesson in numerical analysis, demonstrating how a seemingly straightforward calculation can suffer from catastrophic cancellation and why choosing a numerically stable algorithm is paramount for obtaining reliable results.", "problem": "Simulate a planar gravitational flyby of a comet past Jupiter to study numerical error propagation and catastrophic cancellation. Model the comet as a test particle moving under the Newtonian gravitational force of Jupiter only, in a Jupiter-centered inertial frame. Let the Jupiter gravitational parameter be $\\mu_J = G M_J$, where $G$ is the gravitational constant and $M_J$ is the mass of Jupiter. The comet state is $(x(t),y(t),v_x(t),v_y(t))$ evolving according to the second-order system\n$$\n\\frac{d x}{d t} = v_x,\\quad \\frac{d y}{d t} = v_y,\\quad \\frac{d v_x}{d t} = -\\mu_J \\frac{x}{(x^2+y^2)^{3/2}},\\quad \\frac{d v_y}{d t} = -\\mu_J \\frac{y}{(x^2+y^2)^{3/2}}.\n$$\nInitialize each scattering trajectory at time $t=0$ from a distant point at $x(0) = -R_0$, $y(0) = b$, with constant incoming velocity $v_x(0) = v_\\infty$ and $v_y(0) = 0$. The incoming unit direction is thus $\\hat{u}_{\\text{in}} = (1,0)$. Integrate forward in time until the comet reaches periapsis (the minimum distance to the origin where $(x v_x + y v_y) = 0$), and continue until the comet returns to the circle of radius $R_0$ outbound. At that outbound crossing, record the velocity vector $\\mathbf{v}_{\\text{out}}$ and define the outgoing unit direction $\\hat{u}_{\\text{out}} = \\mathbf{v}_{\\text{out}}/\\|\\mathbf{v}_{\\text{out}}\\|$. The deflection (scattering) angle is the angle between $\\hat{u}_{\\text{in}}$ and $\\hat{u}_{\\text{out}}$.\n\nAll physical constants must be treated as follows:\n- Use $G = 6.67430\\times 10^{-11}\\ \\mathrm{m^3\\,kg^{-1}\\,s^{-2}}$.\n- Use $M_J = 1.89813\\times 10^{27}\\ \\mathrm{kg}$.\n- Use the equatorial radius of Jupiter $R_J = 7.1492\\times 10^{7}\\ \\mathrm{m}$.\n\nYou must design the computation to be based on first principles, namely Newton’s law of universal gravitation and Newton’s second law. You must not invoke any pre-derived scattering formula for hyperbolic orbits; all results must be obtained by numerically solving the given ordinary differential equation.\n\nTo quantify numerical sensitivity and catastrophic cancellation, produce three scalar results for the following test suite. In every case, express angles in radians.\n\nTest suite:\n- Case A (strong encounter sensitivity, “small initial error” amplification): Use $v_\\infty = 5.0\\times 10^{3}\\ \\mathrm{m/s}$, $R_0 = 100\\,R_J$, baseline impact parameter $b_0 = 1.20\\,R_J$, and perturbation $\\Delta b = 1.0\\times 10^{3}\\ \\mathrm{m}$. Compute two trajectories with $b=b_0$ and $b=b_0+\\Delta b$. Let $\\theta(b)$ denote the deflection angle computed from the numerical trajectory as the angle between $\\hat{u}_{\\text{in}}$ and $\\hat{u}_{\\text{out}}$. The required result is the absolute separation $|\\theta(b_0+\\Delta b)-\\theta(b_0)|$ in radians, reported as a float.\n- Case B (moderate encounter, “happy path”): Use $v_\\infty = 5.0\\times 10^{3}\\ \\mathrm{m/s}$, $R_0 = 100\\,R_J$, baseline impact parameter $b_0 = 30\\,R_J$, and perturbation $\\Delta b = 1.0\\times 10^{3}\\ \\mathrm{m}$. As in Case A, compute the absolute separation $|\\theta(b_0+\\Delta b)-\\theta(b_0)|$ in radians, reported as a float.\n- Case C (catastrophic cancellation demonstration in angle extraction): Use $v_\\infty = 5.0\\times 10^{3}\\ \\mathrm{m/s}$, $R_0 = 400\\,R_J$, and $b_0 = 200\\,R_J$. From the single trajectory with $b=b_0$, compute two estimates of the deflection angle from $(\\hat{u}_{\\text{in}},\\hat{u}_{\\text{out}})$: \n  1. A numerically stable angle $\\theta_{\\text{stable}} = \\operatorname{atan2}\\!\\left(\\left|\\hat{u}_{\\text{in},x}\\hat{u}_{\\text{out},y} - \\hat{u}_{\\text{in},y}\\hat{u}_{\\text{out},x}\\right|,\\ \\hat{u}_{\\text{in}}\\cdot \\hat{u}_{\\text{out}}\\right)$, which uses the two-argument arctangent with the signed area (the $z$-component magnitude of the cross product in two dimensions) and the dot product.\n  2. A numerically fragile “naive small-angle” estimate that suffers from catastrophic cancellation when $\\hat{u}_{\\text{in}}$ and $\\hat{u}_{\\text{out}}$ are nearly parallel:\n  $$\n  \\theta_{\\text{naive}} = \\sqrt{\\max\\left(0,\\ 2\\left(1 - \\hat{u}_{\\text{in}}\\cdot \\hat{u}_{\\text{out}}\\right)\\right)}.\n  $$\n  Report the absolute difference $|\\theta_{\\text{stable}} - \\theta_{\\text{naive}}|$ in radians, as a float.\n\nRequirements and constraints:\n- Treat all quantities in the International System of Units (SI). Express the final outputs in radians.\n- Detect the periapsis by the condition $(x v_x + y v_y)=0$ and continue integration until the outbound crossing of the circle $r = \\sqrt{x^2 + y^2} = R_0$ occurs after periapsis.\n- You must ensure that the initial impact parameter $b$ always satisfies $b > R_J$ to avoid collision with Jupiter.\n- Your program must produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the order [Case A result, Case B result, Case C result]. For example, the format must be exactly like $[r_1,r_2,r_3]$ where each $r_i$ is a float in radians.\n\nYour program must be a complete, runnable implementation that takes no input and prints the single required output line.", "solution": "The problem presented is a standard exercise in computational physics, specifically in the domain of celestial mechanics. It requires the numerical simulation of a comet's trajectory, treated as a test particle, under the gravitational field of Jupiter. This is an instance of the Kepler problem, which we are instructed to solve not by analytical means but through direct numerical integration of the governing equations of motion.\n\nThe physical model is grounded in Newtonian mechanics. The state of the comet at any time $t$ is defined by a four-component state vector $\\mathbf{y}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$. Here, $(x, y)$ are the position coordinates and $(v_x, v_y)$ are the velocity components within a Jupiter-centered inertial reference frame. The gravitational force exerted by Jupiter (mass $M_J$) on the comet (mass $m_c$) is given by Newton's law of universal gravitation, $\\mathbf{F} = -\\frac{G M_J m_c}{r^2}\\hat{\\mathbf{r}}$, where $G$ is the gravitational constant, $r = \\sqrt{x^2+y^2}$ is the distance, and $\\hat{\\mathbf{r}} = (x/r, y/r)$ is the radial unit vector.\n\nFrom Newton's second law, $\\mathbf{F} = m_c \\mathbf{a}$, the acceleration of the comet is $\\mathbf{a} = \\mathbf{F}/m_c = -\\frac{G M_J}{r^3}\\mathbf{r}$. Denoting the gravitational parameter of Jupiter as $\\mu_J = G M_J$, the acceleration components are $a_x = -\\mu_J x / r^3$ and $a_y = -\\mu_J y / r^3$. This provides a system of two second-order ordinary differential equations (ODEs). For numerical processing, we convert this into a system of four first-order ODEs:\n$$\n\\frac{d}{dt}\n\\begin{pmatrix} x \\\\ y \\\\ v_x \\\\ v_y \\end{pmatrix}\n=\n\\begin{pmatrix} v_x \\\\ v_y \\\\ -\\mu_J x / (x^2+y^2)^{3/2} \\\\ -\\mu_J y / (x^2+y^2)^{3/2} \\end{pmatrix}\n$$\nThis system is the mathematical foundation of our simulation.\n\nThe integration of this ODE system is performed using a high-quality adaptive numerical solver. The `solve_ivp` function available in the SciPy library is an appropriate instrument for this task. Given that the problem investigates numerical sensitivity—specifically, the amplification of initial errors (Case A) and catastrophic cancellation (Case C)—it is imperative to minimize the numerical error originating from the integration process itself. To this end, we impose strict accuracy requirements, setting both the relative tolerance, `rtol`, and the absolute tolerance, `atol`, to a small value, for instance, $10^{-12}$.\n\nEach simulation begins at $t=0$ with the prescribed initial conditions: $x(0) = -R_0$, $y(0) = b$, $v_x(0) = v_\\infty$, and $v_y(0) = 0$. A critical aspect of the simulation design is the termination condition. The integration must cease precisely when the comet, after passing its closest point to Jupiter (periapsis), returns to a circular orbit of radius $R_0$. This compound condition is implemented using the event detection capabilities of the ODE solver.\n\nThe event logic is twofold:\n1.  **Periapsis Passage**: Periapsis is the point of minimum distance, which is kinematically equivalent to the condition where the position vector $\\mathbf{r} = (x, y)$ and the velocity vector $\\mathbf{v} = (v_x, v_y)$ are orthogonal. This means their dot product, $\\mathbf{r} \\cdot \\mathbf{v} = x v_x + y v_y$, is zero. Prior to periapsis, the comet is approaching, so $\\mathbf{r} \\cdot \\mathbf{v} < 0$. After periapsis, it is receding, and $\\mathbf{r} \\cdot \\mathbf{v} > 0$. Our event logic will first wait for this quantity to become positive, thereby confirming that periapsis has been passed.\n2.  **Outbound Crossing**: Once the comet is on its outbound path, we monitor its radial distance $r = \\sqrt{x^2+y^2}$. The simulation is terminated when this distance again equals $R_0$. This condition, $r - R_0 = 0$, is defined as a terminal event for the solver, which will be activated only after the periapsis passage criterion is met.\n\nUpon successful termination at the outbound crossing, the solver yields the final state vector $\\mathbf{y}_{\\text{out}}$. From this vector, we extract the final velocity $\\mathbf{v}_{\\text{out}} = (v_{x,\\text{out}}, v_{y,\\text{out}})$ and compute the final unit direction vector $\\hat{\\mathbf{u}}_{\\text{out}} = \\mathbf{v}_{\\text{out}} / \\|\\mathbf{v}_{\\text{out}}\\|$. The initial unit direction is fixed by the problem statement as $\\hat{\\mathbf{u}}_{\\text{in}} = (1, 0)$.\n\nThe deflection angle $\\theta$ is the angle between $\\hat{\\mathbf{u}}_{\\text{in}}$ and $\\hat{\\mathbf{u}}_{\\text{out}}$.\nFor Cases A and B, the objective is to assess the sensitivity of $\\theta$ to the impact parameter $b$. We compute the deflection angles $\\theta(b_0)$ and $\\theta(b_0 + \\Delta b)$ from two separate simulations and report the magnitude of their difference, $|\\theta(b_0 + \\Delta b) - \\theta(b_0)|$. Case A involves a close encounter ($b_0 = 1.20\\,R_J$) where high sensitivity is expected, while Case B represents a more distant, stable encounter ($b_0 = 30\\,R_J$).\n\nCase C is designed to exhibit the numerical artifact of catastrophic cancellation. A very distant encounter ($b_0 = 200\\,R_J$, $R_0 = 400\\,R_J$) is simulated, which produces a very small deflection angle $\\theta$. In such a scenario, $\\hat{\\mathbf{u}}_{\\text{out}}$ is nearly co-linear with $\\hat{\\mathbf{u}}_{\\text{in}}$, and their dot product $\\hat{\\mathbf{u}}_{\\text{in}} \\cdot \\hat{\\mathbf{u}}_{\\text{out}}$ is infinitesimally less than $1$. We are required to compute $\\theta$ using two distinct formulae:\n1.  A numerically stable formula, $\\theta_{\\text{stable}} = \\operatorname{atan2}\\!\\left(\\left|\\det(\\hat{\\mathbf{u}}_{\\text{in}}, \\hat{\\mathbf{u}}_{\\text{out}})\\right|,\\ \\hat{\\mathbf{u}}_{\\text{in}}\\cdot \\hat{\\mathbf{u}}_{\\text{out}}\\right)$. The two-argument arctangent function is robust as it uses both the sine-like (from the 2D cross-product, or determinant) and cosine-like (from the dot product) components of the angle.\n2.  A numerically naive formula, $\\theta_{\\text{naive}} = \\sqrt{\\max(0, 2(1 - \\hat{\\mathbf{u}}_{\\text{in}}\\cdot \\hat{\\mathbf{u}}_{\\text{out}}))}$. This formula, derived from the half-angle identity, is susceptible to catastrophic cancellation in the term $1 - \\hat{\\mathbf{u}}_{\\text{in}}\\cdot \\hat{\\mathbf{u}}_{\\text{out}}$ when the dot product is close to $1$. The difference between the two results, $|\\theta_{\\text{stable}} - \\theta_{\\text{naive}}|$, is a direct measure of the precision lost to this numerical instability.\n\nThe implementation encapsulates this logic into a single program that defines the physical constants, the ODE system, and a simulation function that handles the integration and event detection. This function is then applied to the parameters of each test case to produce the required outputs, which are then formatted into a single line. All computations are rigorously performed in SI units.", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the gravitational flyby problem by numerically integrating the\n    equations of motion for a comet passing Jupiter.\n    \"\"\"\n    # Physical Constants in SI units\n    G = 6.67430e-11  # Gravitational constant in m^3 kg^-1 s^-2\n    M_J = 1.89813e27  # Mass of Jupiter in kg\n    R_J = 7.1492e7    # Equatorial radius of Jupiter in m\n\n    # Jupiter's gravitational parameter\n    MU_J = G * M_J\n\n    def simulate_flyby(v_inf, R0_val, b_val, t_max):\n        \"\"\"\n        Simulates a single flyby trajectory.\n\n        Args:\n            v_inf (float): Incoming velocity at infinity.\n            R0_val (float): Initial and final radial distance marker.\n            b_val (float): Impact parameter.\n            t_max (float): Maximum integration time.\n\n        Returns:\n            tuple: A tuple containing the deflection angle (theta) and the\n                   outgoing unit velocity vector (u_out).\n        \"\"\"\n        # Initial state vector: [x, y, vx, vy]\n        y0 = np.array([-R0_val, b_val, v_inf, 0.0])\n\n        # ODE system for the two-body problem\n        def ode_system(t, y):\n            x, pos_y, vx, vy = y\n            r_sq = x**2 + pos_y**2\n            # Avoid division by zero, though unlikely with proper setup\n            if r_sq == 0:\n                return [vx, vy, 0, 0]\n            r_cubed = r_sq**1.5\n            ax = -MU_J * x / r_cubed\n            ay = -MU_J * pos_y / r_cubed\n            return [vx, vy, ax, ay]\n\n        # Event detection: terminate when comet crosses R0 after periapsis\n        event_handler_state = {'periapsis_passed': False}\n\n        def event_function(t, y):\n            # Check for periapsis passage. Periapsis is when dot(r, v) = 0.\n            # The value goes from negative (approaching) to positive (receding).\n            r_dot_v = y[0] * y[2] + y[1] * y[3]\n            if not event_handler_state['periapsis_passed'] and r_dot_v > 0:\n                event_handler_state['periapsis_passed'] = True\n            \n            # If past periapsis, check for outbound crossing of R0.\n            if event_handler_state['periapsis_passed']:\n                r = np.sqrt(y[0]**2 + y[1]**2)\n                return r - R0_val\n            \n            # If not past periapsis, return a positive value to not trigger the event.\n            return 1.0\n        \n        event_function.terminal = True\n        # The event triggers when the function value increases through zero.\n        # This is correct for r - R0_val as r is increasing on the outbound leg.\n        event_function.direction = 1\n\n        # Time span for integration\n        t_span = [0, t_max]\n\n        # Integrate the ODEs with high precision\n        sol = solve_ivp(\n            ode_system,\n            t_span,\n            y0,\n            method='DOP853',\n            events=event_function,\n            rtol=1e-12,\n            atol=1e-12,\n            dense_output=True\n        )\n\n        if not sol.t_events or len(sol.t_events[0]) == 0:\n            raise RuntimeError(f\"Integration failed: Outbound crossing event not found within t_max={t_max}s.\")\n\n        # Get state at the precise event time\n        y_final = sol.sol(sol.t_events[0][0])\n        vx_out, vy_out = y_final[2], y_final[3]\n        \n        v_out_norm = np.sqrt(vx_out**2 + vy_out**2)\n        u_out = np.array([vx_out, vy_out]) / v_out_norm\n\n        # Deflection angle from stable atan2 method\n        # u_in is [1, 0], so cross_prod_z = u_out[1] and dot_prod = u_out[0].\n        # Deflection angle is conventionally positive.\n        theta = np.arctan2(np.abs(u_out[1]), u_out[0])\n        \n        return theta, u_out\n\n    results = []\n    test_cases = [\n        # Case A: Strong encounter\n        {'v_inf': 5.0e3, 'R0': 100 * R_J, 'b0': 1.20 * R_J, 'db': 1.0e3, 't_max': 5e6},\n        # Case B: Moderate encounter\n        {'v_inf': 5.0e3, 'R0': 100 * R_J, 'b0': 30.0 * R_J, 'db': 1.0e3, 't_max': 5e6},\n        # Case C: Catastrophic cancellation demo\n        {'v_inf': 5.0e3, 'R0': 400 * R_J, 'b0': 200.0 * R_J, 't_max': 2e7}\n    ]\n\n    # --- Case A ---\n    case_A = test_cases[0]\n    if case_A['b0'] <= R_J or (case_A['b0'] + case_A['db']) <= R_J:\n        raise ValueError(\"Case A: Impact parameter b must be > R_J.\")\n    theta1_A, _ = simulate_flyby(case_A['v_inf'], case_A['R0'], case_A['b0'], case_A['t_max'])\n    theta2_A, _ = simulate_flyby(case_A['v_inf'], case_A['R0'], case_A['b0'] + case_A['db'], case_A['t_max'])\n    result_A = np.abs(theta2_A - theta1_A)\n    results.append(result_A)\n\n    # --- Case B ---\n    case_B = test_cases[1]\n    if case_B['b0'] <= R_J or (case_B['b0'] + case_B['db']) <= R_J:\n        raise ValueError(\"Case B: Impact parameter b must be > R_J.\")\n    theta1_B, _ = simulate_flyby(case_B['v_inf'], case_B['R0'], case_B['b0'], case_B['t_max'])\n    theta2_B, _ = simulate_flyby(case_B['v_inf'], case_B['R0'], case_B['b0'] + case_B['db'], case_B['t_max'])\n    result_B = np.abs(theta2_B - theta1_B)\n    results.append(result_B)\n\n    # --- Case C ---\n    case_C = test_cases[2]\n    if case_C['b0'] <= R_J:\n        raise ValueError(\"Case C: Impact parameter b must be > R_J.\")\n    _, u_out_C = simulate_flyby(case_C['v_inf'], case_C['R0'], case_C['b0'], case_C['t_max'])\n\n    # u_in is implicitly [1.0, 0.0]\n    dot_prod = u_out_C[0]\n    cross_prod_mag = np.abs(u_out_C[1])\n    \n    # Stable angle calculation\n    theta_stable = np.arctan2(cross_prod_mag, dot_prod)\n\n    # Naive small-angle calculation prone to catastrophic cancellation\n    naive_term = 2.0 * (1.0 - dot_prod)\n    theta_naive = np.sqrt(max(0.0, naive_term))\n    \n    result_C = np.abs(theta_stable - theta_naive)\n    results.append(result_C)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2389921"}]}