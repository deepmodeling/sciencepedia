## 引言
在数学逻辑与计算机科学的殿堂中，一阶逻辑的证明系统扮演着基石般的角色。它们不仅是进行严谨数学推理的形式化工具，更是连接人类直观真理与机器可执行符号操作的桥梁。然而，一个纯粹基于符号变换的句法系统，如何能够精确捕捉和保证语义上的真理呢？这一核心问题是[形式逻辑](@entry_id:263078)诞生之初便致力于解决的知识鸿沟。

本文旨在系统性地回答这一问题，为读者构建一幅关于一阶逻辑证明系统的完整图景。在接下来的内容中，我们将首先在“原理与机制”一章深入探讨[一阶逻辑](@entry_id:154340)的句法与语义，建立可靠性与完全性这两个关键的[元理论](@entry_id:638043)概念，并详细剖析[希尔伯特系统](@entry_id:635230)、自然演绎等主流[证明系统](@entry_id:156272)的内部运作方式。随后，在“应用与跨学科联系”一章，我们将展示这些理论如何在[自动定理证明](@entry_id:154648)、[软件验证](@entry_id:151426)和计算理论等领域大放异彩。最后，通过“动手实践”部分提供的具体问题，您将有机会将所学知识付诸实践，加深对这些抽象概念的理解。

## 原理与机制

本章旨在深入探讨[一阶逻辑](@entry_id:154340)[证明系统](@entry_id:156272)的核心原理与运作机制。在一阶逻辑中，我们区分了语言的**语法（syntax）**（即如何构造合法的表达式）与**语义（semantics）**（即这些表达式的意义）。[证明系统](@entry_id:156272)构成了连接这两者的桥梁：它是一种纯粹基于符号操作的句法工具，旨在捕捉语义上的真理概念。我们将首先精确定义一阶逻辑的句法和语义，然后介绍连接二者的关键[元理论](@entry_id:638043)概念——可靠性（soundness）与完全性（completeness）。最后，我们将详细阐述几种主流的[证明系统](@entry_id:156272)——[希尔伯特系统](@entry_id:635230)、自然演绎、[相继式演算](@entry_id:154229)和语义tableau——并探讨它们的内在机制以及它们在一阶逻辑的[可计算性理论](@entry_id:149179)中所扮演的角色。

### 逻辑的语言：[语法与语义](@entry_id:148153)

任何[形式逻辑](@entry_id:263078)系统的第一步都是精确定义其语言。这包括规定哪些符号序列是合法的，以及如何解释这些合法的序列。

#### 语法：构造合式表达式

[一阶逻辑](@entry_id:154340)的语法始于一个**署名（signature）**，记作 $\Sigma$，它规定了我们所讨论的特定数学领域中的非逻辑符号。一个署名由以下部分组成：

*   一组**函数符号** $\mathcal{F}$
*   一组**关系符号**（或称谓词符号）$\mathcal{R}$
*   一个**元数函数** $\operatorname{ar}: \mathcal{F} \cup \mathcal{R} \to \mathbb{N}_0$，它为每个符号指定一个固定的非负整数元数（arity）。元数为 $n$ 的符号称为 $n$-元符号。

值得注意的是，**常数符号**可以被视为元数为0的函数符号。除了这些由署名决定的非逻辑符号外，[一阶逻辑](@entry_id:154340)还包含一组固定的逻辑符号，包括无限可数的**变量**集 $\mathcal{V}$ (例如 $x, y, z, \dots$)、[逻辑联结词](@entry_id:146395)（如 $\neg, \land, \lor, \to$）、[量词](@entry_id:159143)（$\forall, \exists$）以及一个特殊的逻辑关系符号——等号（$=$）。

基于这些符号，我们可以通过归纳法构造两类重要的表达式：**项（term）**和**公式（formula）** [@problem_id:2979676]。

**项**是用来指代[论域](@entry_id:265834)中对象的表达式。项集是满足以下条件的最小集合：
1.  **基础情况**：任何变量 $x \in \mathcal{V}$ 都是一个项。
2.  **基础情况**：任何元数为0的函数符号（即常数）$c \in \mathcal{F}$ 都是一个项。
3.  **[归纳步骤](@entry_id:144594)**：如果 $f \in \mathcal{F}$ 是一个 $n$-元函数符号（$n>0$），且 $t_1, \dots, t_n$ 都是项，那么字符串 $f(t_1, \dots, t_n)$ 也是一个项。

例如，在一个包含常数 $c$ 和一元函数符号 $f$ 的语言中，$c$, $f(c)$, $f(f(x))$ 都是项。

**公式**是用来表达命题的表达式，其真值可以被判断。公式的构造分为两步。首先定义**原子公式（atomic formula）**：
1.  如果 $R \in \mathcal{R}$ 是一个 $n$-元关系符号，且 $t_1, \dots, t_n$ 都是项，那么 $R(t_1, \dots, t_n)$ 是一个原子公式。
2.  如果 $t_1$ 和 $t_2$ 是项，那么 $(t_1 = t_2)$ 是一个原子公式。

然后，所有**[合式公式](@entry_id:636348)（well-formed formula）**的集合是满足以下条件的最小集合：
1.  **基础情况**：任何原子公式都是一个公式。
2.  **[归纳步骤](@entry_id:144594)（联结词）**：如果 $\varphi$ 和 $\psi$ 是公式，那么 $\neg\varphi$, $(\varphi \land \psi)$, $(\varphi \lor \psi)$, 和 $(\varphi \to \psi)$ 也是公式。
3.  **[归纳步骤](@entry_id:144594)（量词）**：如果 $\varphi$ 是一个公式且 $x \in \mathcal{V}$ 是一个变量，那么 $\forall x\,\varphi$ 和 $\exists x\,\varphi$ 也是公式。

在这一构造过程中，**元数**扮演着至关重要的角色。它像语法规则一样，强制规定了一个 $n$-元函数或关系符号必须且只能跟随 $n$ 个项作为其参数。这种严格的匹配确保了任何合式项或公式都具有唯一的语法[解析树](@entry_id:272911)，这是定义其语义和进行结构归纳证明的基础。

#### 语义：赋予意义

语法仅仅是符号游戏，而语义则为这些符号赋予了生命。[一阶逻辑](@entry_id:154340)的语义，通常称为**塔斯基语义（Tarskian semantics）**，其核心是**结构（structure）**（或称**模型（model）**）的概念。对于一个给定的署名 $\Sigma$，一个 $\Sigma$-结构 $\mathcal{M}$ 包括：

1.  一个非空的**[论域](@entry_id:265834)（domain）** $|\mathcal{M}|$，即我们讨论的所有对象的集合。
2.  一个**解释函数** $\cdot^{\mathcal{M}}$，它将署名中的每个符号映射到[论域](@entry_id:265834)上的具体对象、函数或关系。
    *   对于每个常数符号 $c$，它指定一个元素 $c^{\mathcal{M}} \in |\mathcal{M}|$.
    *   对于每个 $n$-元函数符号 $f$，它指定一个全函数 $f^{\mathcal{M}}: |\mathcal{M}|^n \to |\mathcal{M}|$.
    *   对于每个 $n$-元关系符号 $R$，它指定一个关系 $R^{\mathcal{M}} \subseteq |\mathcal{M}|^n$.

一个结构固定了非逻辑符号的意义，但公式中可能还包含[自由变量](@entry_id:151663)。为了解释这些公式，我们需要一个**变量赋值（variable assignment）**函数 $s$，它将每个变量 $x \in \mathcal{V}$ 映射到[论域](@entry_id:265834)中的一个元素 $s(x) \in |\mathcal{M}|$。

有了结构 $\mathcal{M}$ 和赋值 $s$，我们便可以递归地定义项的**指称（denotation）**和公式的**满足（satisfaction）**关系 [@problem_id:2979666]。

一个项 $t$ 在 $\mathcal{M}$ 和 $s$下的指称，记为 $t^{\mathcal{M}, s}$，是一个[论域](@entry_id:265834)中的元素，其定义如下：
*   对于变量 $x$，$x^{\mathcal{M}, s} = s(x)$。
*   对于常数 $c$，$c^{\mathcal{M}, s} = c^{\mathcal{M}}$。
*   对于复合项 $f(t_1, \dots, t_n)$，$(f(t_1, \dots, t_n))^{\mathcal{M}, s} = f^{\mathcal{M}}(t_1^{\mathcal{M}, s}, \dots, t_n^{\mathcal{M}, s})$。

一个公式 $\varphi$ 在 $\mathcal{M}$ 和 $s$下被满足，记为 $\mathcal{M}, s \models \varphi$，其定义如下：
*   对于原子公式 $R(t_1, \dots, t_n)$，当且仅当 $(t_1^{\mathcal{M}, s}, \dots, t_n^{\mathcal{M}, s}) \in R^{\mathcal{M}}$ 时，$\mathcal{M}, s \models R(t_1, \dots, t_n)$。
*   对于等式 $t_1 = t_2$，当且仅当 $t_1^{\mathcal{M}, s}$ 与 $t_2^{\mathcal{M}, s}$ 是同一元素时，$\mathcal{M}, s \models t_1 = t_2$。
*   对于 $\neg\varphi$，当且仅当 $\mathcal{M}, s \not\models \varphi$ 时，$\mathcal{M}, s \models \neg\varphi$。
*   对于 $\varphi \land \psi$，当且仅当 $\mathcal{M}, s \models \varphi$ 且 $\mathcal{M}, s \models \psi$ 时，$\mathcal{M}, s \models \varphi \land \psi$。其他布尔联结词的规则类似。
*   对于 $\forall x\,\varphi$，当且仅当对于所有[论域](@entry_id:265834)元素 $a \in |\mathcal{M}|$，都有 $\mathcal{M}, s[x \mapsto a] \models \varphi$ 时，$\mathcal{M}, s \models \forall x\,\varphi$。其中 $s[x \mapsto a]$ 是一个新的赋值，它将 $x$ 映射到 $a$，而对其他变量的映射与 $s$ 相同。
*   对于 $\exists x\,\varphi$，当且仅当存在某个[论域](@entry_id:265834)元素 $a \in |\mathcal{M}|$，使得 $\mathcal{M}, s[x \mapsto a] \models \varphi$ 时，$\mathcal{M}, s \models \exists x\,\varphi$。

例如，考虑公式 $\psi = \forall x \, \exists y \, R(f(y), x)$。在一个结构 $\mathcal{M}$ 中，要判断其真假，我们需要检查：对于[论域](@entry_id:265834)中任意一个元素 $a$，是否都能找到另一个元素 $b$，使得由 $f(y)$ 指称的元素（即 $f^{\mathcal{M}}(b)$）与由 $x$ 指称的元素（即 $a$）满足关系 $R^{\mathcal{M}}$。假设[论域](@entry_id:265834)是整数集 $\mathbb{Z}$，$f^{\mathcal{M}}(n) = 2n+3$，$R^{\mathcal{M}}$ 是小于关系 $$。那么 $\psi$ 的真假就取决于：对于任意整数 $a$，是否存在一个整数 $b$，使得 $2b+3  a$。由于整数集向下无界，这个问题的答案是肯定的，因此在这个结构中 $\psi$ 为真 [@problem_id:2979666]。

#### 代入与变量捕获

在定义证明规则时，一个关键的技术性操作是**代入（substitution）**，即用一个项 $t$ 替换一个公式 $\varphi$ 中变量 $x$ 的所有**自由出现（free occurrences）**，记为 $\varphi[t/x]$。一个变量的出现是自由的，如果它不位于约束该变量的量词的作用域内。

代入操作必须小心处理，以避免一种称为**变量捕获（variable capture）**的现象。变量捕获发生于，当项 $t$ 中的一个变量，在代入 $\varphi$ 后，不幸地被 $\varphi$ 中原有的一个[量词](@entry_id:159143)所约束。例如，考虑公式 $\varphi = \exists y (x \neq y)$，它在任何至少有两个元素的模型中都为真。如果我们想用项 $t = y$ 来代入 $x$，一个“天真”的代入会得到 $\exists y (y \neq y)$，这个公式在任何模型中都为假。这里的变量 $y$ 在项 $t$ 中是自由的，但在代入后被公式 $\varphi$ 中的量词 $\exists y$“捕获”了，从而根本性地改变了公式的意义。

为了防止这种情况，我们引入了“项 $t$ 对变量 $x$ 在公式 $\varphi$ 中是**自由的**（free for）”这一条件。其精确定义是：对于 $t$ 中出现的任何变量 $y \in \mathrm{FV}(t)$，$\varphi$ 中没有任何 $x$ 的自由出现位于约束 $y$ 的量词（如 $\forall y$ 或 $\exists y$）的作用域内 [@problem_id:2979696]。在所有证明系统的[量词](@entry_id:159143)规则中，这个条件是保证可靠性的基石。一个更健壮的代入定义会包含对绑定变量的自动重命名，以主动避免捕获。

### 连接证明与真理的桥梁：可靠性与完全性

有了语法的形式化和语义的真理定义后，我们便可以引入证明系统，并评估其质量。

#### 句法推导与[语义蕴涵](@entry_id:153506)

我们关心两种核心的后承关系 [@problem_id:2979684]：

1.  **句法推导（Syntactic Derivability）**，记作 $\Gamma \vdash \varphi$。它是一个纯句法的概念，意为“在给定的[证明系统](@entry_id:156272) $\mathcal{P}$ 中，存在一个从前提集 $\Gamma$ 出发，推导出结论 $\varphi$ 的形式证明”。一个形式证明是一系列公式的有限序列，其中每个公式要么是 $\Gamma$ 中的一个前提，要么是系统的一条公理，要么是根据系统的一条[推理规则](@entry_id:273148)从序列中前面的公式得出的。

2.  **[语义蕴涵](@entry_id:153506)（Semantic Entailment）**，记作 $\Gamma \models \varphi$。它是一个语义概念，意为“$\varphi$ 是 $\Gamma$ 的一个[逻辑后承](@entry_id:155068)”。其形式化定义为：对于任何结构 $\mathcal{M}$ 和任何变量赋值 $s$，如果 $\mathcal{M}$ 和 $s$ 满足了 $\Gamma$ 中的所有公式，那么它们也必然满足 $\varphi$。换言之，不存在一个使得 $\Gamma$ 全为真而 $\varphi$ 为假的模型。

直观上，$\vdash$ 是我们“能够证明什么”，而 $\models$ 是“什么必须为真”。一个理想的[证明系统](@entry_id:156272)，其目标就是使 $\vdash$ 尽可能地与 $\models$ 重合。

#### 基石般的元定理

**可靠性（Soundness）**和**完全性（Completeness）**是衡量证明系统质量的两个最重要的元定理。

*   **可靠性**：一个证明系统是可靠的，如果它所能证明的都是语义上为真的。形式化地：如果 $\Gamma \vdash \varphi$，那么 $\Gamma \models \varphi$。可靠性保证了我们的[证明系统](@entry_id:156272)不会产出谬误，它是任何一个有用的[证明系统](@entry_id:156272)所必须具备的最低标准。

*   **完全性**：一个证明系统是完全的，如果所有语义上为真的陈述都能在系统中被证明。形式化地：如果 $\Gamma \models \varphi$，那么 $\Gamma \vdash \varphi$。完全性保证了我们的证明系统足够强大，不会遗漏任何真理。

对于[一阶逻辑](@entry_id:154340)，**哥德尔完全性定理（Gödel's Completeness Theorem）**是一个里程碑式的结果，它表明存在着既可靠又完全的证明系统。这意味着，对于[一阶逻辑](@entry_id:154340)而言，句法推导和[语义蕴涵](@entry_id:153506)这两个概念在范围上是完全一致的。需要强调的是，这个定理不应与更为人熟知的**[哥德尔](@entry_id:637876)不完全性定理（Gödel's Incompleteness Theorems）**相混淆。不完全性定理探讨的是包含了算术的特定**理论**（如[皮亚诺算术](@entry_id:150593)），并指出任何这样的一致且可递归公理化的理论都必然是不完全的（即存在该理论无法证明也无法[否证](@entry_id:260896)的真命题）。而完全性定理则是关于一阶逻辑这个**框架本身**的，它断言这个框架的演绎能力足以捕捉其全部[语义后承](@entry_id:637166) [@problem_id:2979684]。

#### 相容性与模型的存在性

可靠性和完全性共同揭示了一个深刻的联系：一个理论的句法相容性与其语义相容性是等价的 [@problem_id:2979693]。

*   **句法相容性（Syntactic Consistency）**：一个理论（即一组语句）$T$ 是句法相容的，如果从 $T$ 出发不能证明出矛盾。如果我们用 $⊥$ 表示一个永假的公式（例如 $P \land \neg P$），那么句法相容性就意味着 $T \nvdash \bot$。

*   **语义相容性（Semantic Consistency）**：一个理论 $T$ 是语义相容的，如果它至少有一个模型，即存在一个结构 $\mathcal{M}$ 使得 $\mathcal{M} \models T$。

现在，让我们看看可靠性和完全性如何将这两者联系起来：
1.  **从语义到句法（需要可靠性）**：假设一个理论 $T$ 有一个模型 $\mathcal{M}$。根据可靠性的[逆否命题](@entry_id:265332)，如果 $T$ 在句法上不相容（即 $T \vdash \bot$），那么 $T$ 在语义上也不相容（即 $T \models \bot$，意味着 $T$ 没有模型）。这与我们的假设矛盾。因此，任何有模型的理论必定是句法相容的。

2.  **从句法到语义（需要完全性）**：假设一个理论 $T$ 是句法相容的（即 $T \nvdash \bot$）。根据完全性的[逆否命题](@entry_id:265332)，如果 $T$ 在语义上不相容（即 $T$ 没有模型，等价于 $T \models \bot$），那么它在句法上也不相容（即 $T \vdash \bot$）。这也与我们的假设矛盾。因此，任何句法相容的理论必定有模型。

综上所述，对于一个可靠且完全的证明系统，我们得到如下基本结果：一个理论 $T$ 有一个模型当且仅当它不能证明出矛盾（$T$ 是句法相容的）[@problem_id:2979693]。这个结果是[模型论](@entry_id:150447)的基石之一。

### 主流证明系统剖析

存在多种为一阶逻辑设计的、可靠且完全的[证明系统](@entry_id:156272)。它们在哲学思想、证明风格和应用领域上各有千秋。

#### [希尔伯特系统](@entry_id:635230)：公理化的方法

[希尔伯特系统](@entry_id:635230)（Hilbert System）的特点是**公理重，规则轻**。它包含大量的**公理模式（axiom schemata）**和极少的**[推理规则](@entry_id:273148)**，通常只有**分离规则（Modus Ponens）**和**概括规则（Generalization）** [@problem_id:2979695]。

*   **公理模式**：这是一组模板，可以生成无穷多的具体公理。例如，$\alpha \to (\beta \to \alpha)$ 是一个常见的命题公理模式。对于[量词](@entry_id:159143)，关键的公理模式包括：
    *   **量词实例化（Q1）**: $\forall x\, \varphi \to \varphi[t/x]$，其中项 $t$ 对 $x$ 在 $\varphi$ 中是自由的。这个公理允许我们从一个普遍陈述得到它的一个特例。
    *   **[量词](@entry_id:159143)[分布](@entry_id:182848)（Q2）**: $\forall x\, (\varphi \to \psi) \to (\varphi \to \forall x\, \psi)$，其中 $x$ 在 $\varphi$ 中不自由出现。
*   **[推理规则](@entry_id:273148)**：
    *   **分离规则**: 从 $\varphi$ 和 $\varphi \to \psi$ 可以推导出 $\psi$。
    *   **概括规则**: 从 $\varphi$ 可以推导出 $\forall x\, \varphi$。

当从一个非空的前提集 $\Gamma$ 进行证明时，概括规则必须受到严格的限制以保证可靠性：只有当变量 $x$ 在 $\Gamma$ 的任何前提中都不自由出现时，才能从 $\varphi$ 推导出 $\forall x\, \varphi$。这是因为 $\varphi$ 的真理可能依赖于 $x$ 的某个特定解释，而这个解释是由前提所限定的。[希尔伯特系统](@entry_id:635230)中的证明通常冗长且不直观，但其结构简单，易于机器验证。

#### 自然演绎：模拟人类推理

自然演绎（Natural Deduction）系统旨在模拟人类的逻辑推理过程，其核心是为每个[逻辑联结词](@entry_id:146395)和量词都提供一对**引入规则（Introduction Rule）**和**消去规则（Elimination Rule）** [@problem_id:2979664]。

*   **引入规则**告诉你如何“构造”一个以该联结词为主要联结词的公式。例如，要证明 $\varphi \land \psi$，你需要分别证明 $\varphi$ 和 $\psi$（$\land$-引入）。要证明 $\varphi \to \psi$，你需要暂时**假设** $\varphi$，然后在此假设下推导出 $\psi$，最后**解除（discharge）**这个假设（$\to$-引入）。

*   **消去规则**告诉你如何“使用”一个以该联结词为主要联结词的公式。例如，如果你有 $\varphi \land \psi$，你可以从中得到 $\varphi$ 或 $\psi$（$\land$-消去）。如果你有 $\varphi \to \psi$ 和 $\varphi$，你可以得到 $\psi$（$\to$-消去，即分离规则）。

量词规则同样需要严格的附带条件：
*   **$\forall$-引入**：要证明 $\forall x\,\varphi(x)$，你必须证明 $\varphi(c)$ 对于一个“任意的”个体 $c$ 成立。这种“任意性”通过**本征变量条件（eigenvariable condition）**来保证：变量 $c$ 不能在任何未被解除的假设中自由出现。
*   **$\forall$-消去**：从 $\forall x\,\varphi(x)$，你可以推断 $\varphi(t)$ 对于任何项 $t$ 成立，但必须满足“$t$ 对 $x$ 在 $\varphi$ 中是自由的”这一条件以避免变量捕获。
*   **$\exists$-引入**：要证明 $\exists x\,\varphi(x)$，你只需提供一个“见证者” $t$，并证明 $\varphi(t)$ 成立即可。
*   **$\exists$-消去**：要使用 $\exists x\,\varphi(x)$，你可以假设 $\varphi(c)$ 对于一个“新鲜的”个体 $c$ 成立，并从中推导出一个不依赖于 $c$ 的结论 $\psi$。这里的“新鲜性”同样由本征变量条件保证：$c$ 不能在 $\psi$ 或其他任何活跃的假设中自由出现。

自然演绎的证明过程更符合直觉，但其假设管理机制比[希尔伯特系统](@entry_id:635230)复杂。

#### [相继式演算](@entry_id:154229)：对称的视角

[相继式演算](@entry_id:154229)（Sequent Calculus），特别是Gentzen的LK系统，是为了元逻辑研究而设计的，其结构具有高度的对称性。它的核心是**相继式（sequent）**，形如 $\Gamma \Rightarrow \Delta$，其中 $\Gamma$ 和 $\Delta$ 都是公式的有限多重集 [@problem_id:2979692]。其直观语义是：“如果 $\Gamma$ 中的所有公式都为真，那么 $\Delta$ 中至少有一个公式为真”。

证明是从**初始相继式**（公理），如 $A \Rightarrow A$，开始，通过[推理规则](@entry_id:273148)向上构建证明树。与自然演绎不同，[相继式演算](@entry_id:154229)的规则不是关于单个公式的，而是关于如何变换整个相继式。对于每个逻辑符号，都有一条**左规则**（在 $\Rightarrow$ 左侧引入该符号）和一条**右规则**（在右侧引入）。

例如，$\land$ 的规则如下：
*   **$\land$-右**：要证明 $\Gamma \Rightarrow \Delta, A \land B$，你需要分别证明 $\Gamma \Rightarrow \Delta, A$ 和 $\Gamma \Rightarrow \Delta, B$。
*   **$\land$-左**：要从 $A \land B$ 推理，相当于同时从 $A$ 和 $B$ 推理。规则是：从 $\Gamma, A, B \Rightarrow \Delta$ 可以推导出 $\Gamma, A \land B \Rightarrow \Delta$。

[相继式演算](@entry_id:154229)的量词规则同样有严格的本征变量和自由代入条件，与自然演绎中的类似。由于其优美的对称性和可逆的规则，[相继式演算](@entry_id:154229)在[证明论](@entry_id:151111)中是分析证明结构和证明**切消定理（Cut-Elimination Theorem）**的核心工具。

#### 语义tableau：寻找反例的系统

语义tableau方法（Semantic Tableaux）可以被看作是一种系统性地寻找一个公式集**反例模型（countermodel）**的算法。证明一个公式 $\varphi$ 的有效性，等价于证明其否定 $\neg\varphi$ 是不可满足的。于是，我们从包含 $\neg\varphi$ 的一个tableau开始，通过分解规则来扩展它 [@problem_id:2979672]。

这些分解规则直接反映了联结词的语义：
*   如果一个分支上包含 $\varphi \land \psi$，我们将 $\varphi$ 和 $\psi$ 都添加到该分支上。
*   如果一个分支上包含 $\varphi \lor \psi$，该分支会分裂成两个子分支，一个加入 $\varphi$，另一个加入 $\psi$。

量词规则引入了**参数（parameters）**或**本征参数（eigenparameters）**，它们可以被看作是模型中元素的临时名称：
*   **$\forall$-规则（$\gamma$-规则）**：如果一个分支上有 $\forall x\,\varphi(x)$，那么对于**已经**出现在该分支上的**每一个**参数 $p$，我们都可以将 $\varphi(p)$ 加入该分支。这个公式是可重复使用的。
*   **$\exists$-规则（$\delta$-规则）**：如果一个分支上有 $\exists x\,\varphi(x)$，我们必须引入一个**全新的**、从未在该分支上出现过的参数 $p$，然后将 $\varphi(p)$ 加入该分支。这个公式之后被视为已使用。

如果一个分支上同时出现了某个原子公式 $A$ 及其否定 $\neg A$，则称该分支**闭合（closed）**，意味着这条路径上的假设导向了矛盾，不可能存在满足它的模型。如果一个tableau的所有分支都闭合，那么初始公式集就是不可满足的，从而证明了原公式 $\varphi$ 的有效性。

语义tableau最引人入胜的一点是它与模型构造的直接联系：如果tableau（在公平的规则应用策略下）完成后仍然存在一个**开放（open）**的分支，那么这个开放分支就直接为我们提供了一个模型。这个模型的[论域](@entry_id:265834)就是该分支上出现的所有参数的集合，而关系的解释则由分支上的原子公式决定。这个过程被称为**[亨金构造](@entry_id:154738)（Henkin construction）**，是完全性定理一个极具启发性的证明方法。

### [可计算性](@entry_id:276011)与逻辑的边界

#### 有效性的[半可判定性](@entry_id:635094)

[一阶逻辑](@entry_id:154340)的有效性问题（即判断任意给定的句子 $\varphi$ 是否在所有模型中都为真）的[计算复杂性](@entry_id:204275)是什么？答案是，它是**半可判定的（semi-decidable）**，但不是**可判定的（decidable）** [@problem_id:2979674]。

这个结论可以直接从我们前面讨论的[证明系统](@entry_id:156272)的性质中得出。一个可靠、完全且**可递归公理化（recursively axiomatizable）**的[证明系统](@entry_id:156272)保证了有效性是半可判定的。“可递归公理化”意味着存在一个算法，可以判断任意一个有限的公式序列是否构成一个合法的证明。

我们可以构造如下的算法（图灵机）来“半判定”一个公式 $\varphi$ 的有效性：
1.  系统地、逐一地生成所有可能的有限长度的符号串。
2.  对于每一个生成的符号串 $S$，使用由可递归公理化性质所保证的算法，检查 $S$ 是否是一个合法的证明。
3.  如果 $S$ 是一个合法的证明，检查其结论是否为 $\varphi$。
4.  如果以上两步都成立，则停机并输出“是”。

分析这个算法的行为：
*   如果 $\varphi$ 是有效的（$\models \varphi$），那么根据**完全性**，必然存在一个对 $\varphi$ 的有限长度的形式证明。这个证明最终会被我们的算法生成和检验到，此时算法停机。
*   如果 $\varphi$ 是无效的（$\not\models \varphi$），那么根据**可靠性**，必然不存在对 $\varphi$ 的形式证明。因此，我们的算法将永远寻找下去，永不停机。

这个算法在且仅在输入为有效公式时停机，这正是[半可判定性](@entry_id:635094)的定义。而**[丘奇定理](@entry_id:636046)（Church's Theorem）**则进一步证明了不存在一个能在所有输入上（无论是有效还是无效）都停机的算法来解决这个问题，即一阶逻辑的有效性问题是不可判定的。这意味着，虽然我们可以系统地证明所有的逻辑真理，但我们却无法用一个统一的算法来识别所有的[逻辑谬误](@entry_id:273186)。