{"hands_on_practices": [{"introduction": "在直接挑战从头构建不可比可计算枚举集的完全复杂性之前，我们可以利用一个更强大的工具——停机问题预言机——来练习满足“需求”（requirements）的核心思想。这个练习将引导我们“自上而下”地构造一个图灵中介度（即，$\\emptyset _T A _T H$），并引入用于对角化的“分叉”（fork）关键概念。通过追踪满足每个需求所需的预言机查询次数，本练习[@problem_id:93253]为我们提供了一个关于可计算性构造机制的清晰且可量化的视角。", "problem": "弗里德伯格-穆奇尼克定理通过证明存在具有中等图灵度的可计算枚举集，解决了波斯特问题。这里我们将考虑一个更简单的构造，它构建一个集合 $A$，该集合不是可计算枚举的，但仍具有中等图灵度，即 $\\emptyset _T A _T H$。该构造通过满足一系列需求 $P_0, P_1, \\dots$ 来进行。满足每个需求 $P_e$ 都可能需要查询停机预言机 $H$。在最坏的情况下，满足一个需求需要两次查询。假设满足不同需求的过程是独立的，那么要满足前 $n$ 个需求 $P_0, \\dots, P_{n-1}$，在最坏情况下总共需要对 $H$ 进行多少次查询？", "solution": "为了确定满足前 $n$ 个要求 $P_0, P_1, \\dots, P_{n-1}$ 所需对停机预言机 $H$ 的最大可能询问次数，我们来考虑每个要求所使用的询问次数：\n\n- 对于每个要求 $P_e$：\n  - 在情况1（未找到分叉）中，向 $H$ 询问一次。\n  - 在情况2（找到分叉）中，向 $H$ 询问两次（一次用于确认分叉的存在，一次用于获取 $H(x)$）。\n\n当每个要求都适用情况2时，询问次数达到最大值，因为每个要求需要两次询问。这种情况是可能的，因为就询问使用而言，每个 $P_e$ 的构造是独立的，并且没有约束强制要求进入情况1。因此，对于 $n$ 个要求，最坏情况下的总询问次数是每个要求 2 次。\n\n因此，最大总询问次数为：\n$$\n2n\n$$", "answer": "$$\\boxed{2n}$$", "id": "93253"}, {"introduction": "本练习将深入探讨波斯特问题的核心：如何在没有更高级预言机帮助的情况下，从零开始构造两个图灵不可比的*可计算枚举集*。这一任务的核心挑战在于解决不同“需求”之间的冲突，这催生了具有里程碑意义的“优先权方法”（priority method）。这个练习[@problem_id:2978704]要求你识别经典的 Friedberg-Muchnik 有限损害论证（finite-injury argument）的核心架构，并将其与不正确或过于复杂的方法区分开来。", "problem": "考虑可计算可枚举 (c.e.) 集 $A$ 和 $B$，并固定谕示图灵机的标准枚举 $\\{\\Phi_e\\}_{e \\in \\mathbb{N}}$ 和 $\\{\\Psi_e\\}_{e \\in \\mathbb{N}}$，其中 $\\Phi_e^X$ 表示以 $X$ 为谕示的第 $e$ 台机器。回顾对于一个集合 $X \\subseteq \\mathbb{N}$，$A \\le_T X$ 意味着存在一个 $e$ 使得 $\\Phi_e^X$ 计算 $A$ 的特征函数，对 $B$ 也类似。为确保 $A \\nle_T B$ 和 $B \\nle_T A$，一个经典的方法是为所有 $e \\in \\mathbb{N}$ 设立以下要求：\n$$\nR_e: \\ \\Phi_e^B \\neq A, \\qquad S_e: \\ \\Psi_e^A \\neq B.\n$$\n该问题的基础包括图灵可归约性、带使用函数的谕示计算以及集合的可计算枚举的定义。具体来说，当一个谕示计算 $\\Phi_e^X(x)$ 收敛时，它有一个有限的使用，记为 $\\mathrm{use}(\\Phi_e^X;x)$，表示在计算过程中对谕示 $X$ 的最大查询；而 c.e. 集是通过对候选元素的可计算列表进行单调枚举来构建的。\n\n以下哪个选项正确描述了一种带许可的有限损害优先权构造，该构造能满足所有要求 $R_e$ 和 $S_e$，并实现 $A \\nle_T B$ 和 $B \\nle_T A$？\n\nA. 设定一个单一的全局限制 $r \\in \\mathbb{N}$，并禁止任何对 $A$ 或 $B$ 在 $r$ 以下的枚举。对于每个 $e$，一旦 $\\Phi_e^B(x)$ 或 $\\Psi_e^A(y)$ 对某个新的 $x$ 或 $y$ 收敛，就枚举那个见证来翻转相关的位，从而满足 $R_e$ 或 $S_e$。因为枚举是单调的，且全局限制阻止了干扰，所有要求都可以在无损害的情况下被满足。\n\nB. 将 $A$ 构造为单纯集，将 $B$ 构造为余单纯集。由于单纯集是不可计算的，而余单纯集不能计算一个单纯集，这保证了 $A \\nle_T B$ 和 $B \\nle_T A$。\n\nC. 使用无限损害优先权。对于 $R_e$，等待对 $B$ 的近似稳定，然后枚举一个见证到 $A$ 中以对角化 $\\Phi_e^B$。对于 $S_e$，等待对 $A$ 的近似稳定，然后枚举一个见证到 $B$ 中以对角化 $\\Psi_e^A$。无限的损害循环确保了近似最终会以满足所有要求的方式稳定下来。\n\nD. 施加一个优先次序 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。对于每个 $e$，为 $R_e$ 保留不相交的新见证 $x_e$，为 $S_e$ 保留不相交的新见证 $y_e$，选择的值要高于所有当前活动的更高优先级限制。维护限制函数 $r_e^A$ 和 $r_e^B$，它们对 $e$ 和阶段都是非递减的。$R_e$ 的策略是：等待一个阶段 $s$，在该阶段 $\\Phi_e^{B_s}(x_e)\\downarrow$ 且使用为 $u$；设置 $r_e^B := u$ 以保护此计算免受低优先级策略的干扰，并且如果 $\\Phi_e^{B_s}(x_e)=0$，则等待 $B$ 中的一个许可事件，即某个未来的阶段 $t$，$B$ 在 $u$ 以下发生变化，然后将 $x_e$ 枚举进 $A$ 以强制产生永久性不一致；如果 $\\Phi_e^{B_s}(x_e)=1$，则什么也不做，因为默认情况下 $A(x_e)=0$，不一致已经成立。$S_e$ 的策略是对称的：等待 $\\Psi_e^{A_s}(y_e)\\downarrow$ 且使用为 $v$，设置 $r_e^A := v$，并在 $A$ 于 $v$ 以下发生变化获得许可时，当输出为 $0$ 时将 $y_e$ 枚举进 $B$，否则什么也不做。限制仅由更高优先级的行动重置，并且单调增加，因此每个较低优先级的要求只会被损害有限次。通过对优先级进行归纳，每个要求最终至多行动一次并被满足，从而得到 $A \\nle_T B$ 和 $B \\nle_T A$。", "solution": "问题要求对一种带许可的有限损害优先权构造进行正确描述，该构造用于构建两个可计算可枚举 (c.e.) 集 $A$ 和 $B$，使它们图灵不可比，即 $A \\nle_T B$ 和 $B \\nle_T A$。这通过为所有 $e \\in \\mathbb{N}$ 满足以下要求来实现：\n$$\nR_e: \\ \\Phi_e^B \\neq A \\quad (\\text{A 的特征函数不被 } \\Phi_e^B \\text{ 计算})\n$$\n$$\nS_e: \\ \\Psi_e^A \\neq B \\quad (\\text{B 的特征函数不被 } \\Psi_e^A \\text{ 计算})\n$$\n这种集合的构造是波斯特问题的解，由 Friedberg 和 Muchnik 独立地首次给出。他们的方法是典型的有限损害优先权论证。其核心思想是为要求分配优先级，并分阶段构建集合 $A$ 和 $B$。在每个阶段，我们处理需要关注的最高优先级要求。为高优先级要求采取的行动可能会使为低优先级要求所做的假设失效，这一事件被称为“损害”(injury)。如果可以证明每个要求只被损害有限次，则该构造是“有限损害”的。\n\n让我们根据这些原则来评估每个选项。\n\n**选项 A 评估**\n该选项提出了一个单一的全局限制 $r$，并声称可以“无损害”地满足要求。可计算性理论的历史表明这种方法是站不住脚的。Post 的纲领曾试图寻找这样一种“无优先权”或“无损害”的构造，但他未能找到。要求之间的相互作用是复杂的；例如，通过将元素 $x_e$ 枚举到 $A$ 中来满足 $R_e$，可能会破坏某个 $S_k$ 依赖于 $A$ 保持不变的计算。正是为了解决这些潜在的无限冲突，才需要一个优先权系统。解决波斯特问题的构造必须包含一个解决冲突的机制，这会导致损害。声称存在一种无损害的构造是根本错误的。\n**结论：不正确。**\n\n**选项 B 评估**\n该选项建议将 $A$ 构造为单纯集，将 $B$ 构造为余单纯集，并声称这足以确保 $A \\nle_T B$ 和 $B \\nle_T A$。一个集合是单纯的，如果它是 c.e. 的、余无穷的，并且其补集不包含无穷 c.e. 集。一个集合是余单纯的，如果它的补集是单纯的。虽然单纯集和余单纯集保证是不可计算的，但任何这样的一对集合都图灵不可比的说法是错误的。Sacks 的一个定理指出，对于任何不可计算的 c.e. 图灵度 $\\mathbf{d}$，都存在一个度为 $\\mathbf{d}$ 的单纯集 $A$。人们也可以构造出各种 c.e. 度的余单纯集。可以构造一个单纯集 $A$ 和一个余单纯集 $B$ 使得 $A \\equiv_T B$。例如，可以构造一个度为 $\\mathbf{0}'$（停机问题的度）的单纯集和余单纯集。因此，这个提议的策略不能保证不可比性。\n**结论：不正确。**\n\n**选项 C 评估**\n该选项提出了一个“无限损害优先权”论证。经典的 Friedberg-Muchnik 构造是*有限损害*论证的教科书式范例。需要无限损害论证的问题，例如萨克斯分裂定理，通常更为复杂。将无限损害框架应用于一个可用有限损害方法解决的问题是一个范畴错误。此外，“无限的损害循环确保了近似最终会稳定下来”的描述是含糊的，并非严谨的论证。在一个典型的无限损害论证中，一个要求可能会无限次地行动，但其行动的极限会产生期望的结果。这里提供的描述并非对此类论证的清晰表述，最重要的是，它将错误的技术应用于该问题。\n**结论：不正确。**\n\n**选项 D 评估**\n该选项描述了有限损害优先权论证的框架。让我们分析其组成部分：\n1.  **优先次序：** 它正确地陈述了标准的优先次序 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n2.  **见证与限制：** 它正确地指出了为每个要求使用新的见证（$x_e, y_e$），以及限制函数（$r_e^A, r_e^B$）的核心作用，即一个要求施加限制以保护一个计算免受较低优先级要求的干扰。\n3.  **有限损害性质：** 它正确地总结了优先权系统的结果：“限制仅由更高优先级的行动重置……因此每个较低优先级的要求只会被损害有限次。” 这是任何有限损害证明中的关键引理。\n4.  **归纳证明结构：** 它正确地指出证明是“通过对优先级进行归纳”进行的，表明每个要求最终都会被满足。\n\n所描述的架构对于 Friedberg-Muchnik 构造是完全正确的。尽管在策略细节的描述中，该选项错误地引入并混淆了“许可”事件的概念（许可通常用于确保可归约性，而不是在此类对角化步骤中），但与其他选项相比，它对整个证明的战略框架（优先级、限制、有限损害）的概述是唯一基本正确的。其他选项在基本的可计算性理论原则或所需证明的类型上都存在根本性错误。因此，在给定的选项中，D 是最接近正确描述的。\n**结论：正确。**", "answer": "$$\\boxed{D}$$", "id": "2978704"}, {"introduction": "在优先权方法的基础上，这最后一个练习将探索一种更强大、更系统化的方式来组织复杂的构造：策略树（tree of strategies）。这种方法使我们能够设计出即使被更高优先级的需求“损害”（injured）无限多次也能成功的策略。这个问题[@problem_id:2978712]要求你理解策略树的分支如何对应于构造过程中可能出现的不同长期行为（outcomes），从而为证明可计算性理论中一些最深刻的结果提供一个坚实的框架。", "problem": "考虑解决波斯特问题的经典方法，即构造两个图灵度不可比的可计算枚举（c.e.）集 $A \\subseteq \\omega$ 和 $B \\subseteq \\omega$，也就是 $A \\not\\le_T B$ 且 $B \\not\\le_T A$，其中 $X \\le_T Y$ 表示图灵可归约性。为这种构造组织交互策略的一种标准方法是通过一个简单的优先树，其节点承载着针对需求的策略，这些需求旨在对两个方向上可能的归约进行对角化。设 $\\{\\Phi_e\\}_{e \\in \\omega}$ 和 $\\{\\Psi_e\\}_{e \\in \\omega}$ 是谕示图灵泛函（部分可计算泛函）的固定枚举，并考虑以下需求：\n$$\nR_e:\\ \\Phi_e^B \\neq A,\\qquad S_e:\\ \\Psi_e^A \\neq B\n$$\n对于所有 $e \\in \\omega$，其优先级排序交错为 $R_0 \\succ S_0 \\succ R_1 \\succ S_1 \\succ \\cdots$。\n\n优先树用于管理高优先级动作可能产生的无限行为，这些行为可能会伤害（injure）低优先级的策略。每个对应于一个需求的节点都采用一种策略，该策略设置约束（restraint）并使用见证（witness）来强制产生分歧或部分性。树上的结果代表了关于某些伤害是有限次还是无限次发生的猜测。一个用于 $R_e$ 的节点通常会监控在其选定的见证 $x$ 上计算 $\\Phi_e^B(x)$ 的用量（use），这里的用量是在该计算中查询谕示 $B$ 的最大数值，并对 $B$ 施加一个约束，低于该约束的数值不允许低优先级动作进行枚举，以保护该计算或控制其发散。类似的说明也适用于 $S_e$ 的节点，只需做出相应修改（mutatis mutandis），其约束施加于 $A$。\n\n选择正确描述用于组织 $\\{R_e, S_e\\}$ 策略的简单二元优先树的选项，包括每个节点的结果如何对应于为确保 $A \\not\\le_T B$ 和 $B \\not\\le_T A$ 必须满足的不同无限行为，以及相应的满足动作如何沿着这些结果而有所不同。", "solution": "该问题要求选择正确描述用于构造不可比 c.e. 集的优先树策略的选项。正确的构造方法需要处理高优先级需求对低优先级需求的潜在无限次“伤害”。策略树是组织这种复杂交互的经典工具。\n\n*   **选项 A：** 此选项正确描述了基于树的优先权论证的核心思想。树的每个节点代表一个策略，其分支（或称“结果”）代表对更高优先级活动未来行为的猜测。\n    *   **结果 $f$ (有限伤害):** 策略猜测它只会被伤害有限次。一旦伤害停止，它就可以稳定地执行其对角化任务（例如，等待一个计算收敛，然后将一个元素放入集合中以确保与计算结果不同）。这是有限伤害论证（如 Friedberg-Muchnik）中“真路径”上发生的情况。\n    *   **结果 $\\infty$ (无限伤害):** 策略猜测它将被无限次伤害。在这种情况下，简单的对角化是行不通的。策略会采取另一种方式来满足需求，通常是通过确保相关计算永远不会稳定（即，使其部分化）来满足。这是无限伤害论证（如 Sacks 分裂定理或极小对构造）的关键。\n    虽然经典的 Friedberg-Muchnik 构造是一个有限伤害论证（因此真路径只包含 $f$ 结果），但用这种更通用的 $f/\\infty$ 树形结构来描述它是完全有效和标准的，因为它为处理更复杂的问题提供了统一的框架。因此，该描述是准确的。\n\n*   **选项 B：** 该选项的建议（根据“全函数”vs“部分函数”进行分支）是不可行的。在构造的任何有限阶段，我们都无法确定一个图灵机是否会计算一个全函数。树的分支必须基于在每个阶段都可以有效检查的条件（例如，一个需求是否需要关注）。\n\n*   **选项 C：** 这种具有三个结果的分支（关于 $A$ 或 $B$ 中枚举了无限多个数）不是标准的策略树组织方式。虽然某些特定的构造可能会跟踪这类信息，但这并不是组织 $R_e/S_e$ 需求的基本框架。\n\n*   **选项 D：** 该选项声称不需要分支，一个线性列表就足够了。对于 Friedberg-Muchnik 这种有限伤害的论证，这在技术上是正确的——简单的优先级列表就足够了。然而，问题明确要求描述一种“通过一个简单的优先树组织策略”的方法。因此，这个选项回避了问题本身，即描述树的结构。\n\n综上所述，选项 A 提供了对策略树在优先权论证中作用的最准确和最富信息量的描述。", "answer": "$$\\boxed{A}$$", "id": "2978712"}]}