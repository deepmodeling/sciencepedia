{"hands_on_practices": [{"introduction": "通用图灵机的魔力在于它能将其他机器的描述当作输入数据来处理。为了将这个抽象概念具体化，第一个练习将提供一套明确的规则，用于将一个简单图灵机的状态、符号和转移函数编码成一个二进制字符串[@problem_id:1377308]。这项实践旨在巩固“机器可以被表示为符号数据”这一核心基础概念，让你亲手体验通用计算的基石。", "problem": "通用图灵机 (UTM) 是一种可以模拟任何其他图灵机的图灵机。为此，UTM 的输入带上会提供要模拟的机器的编码描述 $\\langle M \\rangle$，其后是该机器的编码输入串 $\\langle w \\rangle$。\n\n考虑一个特定的图灵机 (TM)，记为 $M$。$M$ 的组成部分定义如下：\n-   **状态：** $Q = \\{q_s, q_f\\}$，其中 $q_s$ 是起始状态，$q_f$ 是接受状态。\n-   **输入字母表：** $\\Sigma = \\{x, y\\}$\n-   **带字母表：** $\\Gamma = \\{x, y, \\beta\\}$，其中 $\\beta$ 代表空白符号。\n-   **转移函数 $\\delta$：** 机器的行为由以下三个按特定顺序给出的转移定义：\n    1.  $\\delta(q_s, x) = (q_s, y, R)$：在状态 $q_s$ 下，读取到符号 $x$ 时，它会写入符号 $y$，将读写头向右 (R) 移动，并保持在状态 $q_s$。\n    2.  $\\delta(q_s, y) = (q_f, x, L)$：在状态 $q_s$ 下，读取到符号 $y$ 时，它会写入符号 $x$，将读写头向左 (L) 移动，并转移到状态 $q_f$。\n    3.  $\\delta(q_s, \\beta) = (q_f, \\beta, R)$：在状态 $q_s$ 下，读取到空白符号 $\\beta$ 时，它会写入 $\\beta$，向右 (R) 移动，并转移到状态 $q_f$。\n\n该 UTM 使用一种二进制编码方案（仅使用符号 `0` 和 `1`）来表示机器 $M$ 及其输入串 $w$。编码规则如下：\n\n-   **组件到整数的映射：**\n    -   状态：$q_s \\to 1, q_f \\to 2$\n    -   带符号：$x \\to 1, y \\to 2, \\beta \\to 3$\n    -   方向：$L \\to 1, R \\to 2$\n\n-   **整数编码：** 一个整数 $n$ 被一元编码为一个由 $n$ 个 `0` 组成的字符串。例如，整数 3 编码为 `000`。\n\n-   **转移编码：** 一个形如 $\\delta(q_{curr}, S_{read}) = (q_{next}, S_{write}, D_{move})$ 的单次转移，通过将其五个组件（按定义中出现的顺序）的一元编码用符号 `1` 分隔并连接起来进行编码。模式为：`code(q_curr)1code(S_read)1code(q_next)1code(S_write)1code(D_move)`。\n\n-   **机器描述 $\\langle M \\rangle$：** 机器 $M$ 的完整描述是通过将其所有转移的编码表示（按照上面列出的特定顺序）用字符串 `11` 分隔并连接起来形成的。\n\n-   **输入串编码 $\\langle w \\rangle$：** 一个输入串 $w$ 是通过将其符号的编码表示从左到右用符号 `1` 分隔并连接起来进行编码的。\n\n-   **UTM 输入带：** UTM 带上的完整输入是字符串 $\\langle M \\rangle$，后跟分隔符 `111`，再后跟编码的输入串 $\\langle w \\rangle$。\n\n你的任务是确定为了在输入串 $w = \"xy\"$ 上模拟机器 $M$，必须放置在 UTM 输入带上的完整二进制串。", "solution": "我们首先按规定将机器组件映射到整数：$q_{s} \\to 1$，$q_{f} \\to 2$；$x \\to 1$，$y \\to 2$，$\\beta \\to 3$；$L \\to 1$，$R \\to 2$。每个整数 $n$ 被一元编码为 $n$ 个零组成的字符串。因此，一元编码为：$1 \\mapsto 0$，$2 \\mapsto 00$，$3 \\mapsto 000$。\n\n我们将每个转移 $\\delta(q_{\\text{curr}}, S_{\\text{read}}) = (q_{\\text{next}}, S_{\\text{write}}, D_{\\text{move}})$ 编码为 code$(q_{\\text{curr}})$ 1 code$(S_{\\text{read}})$ 1 code$(q_{\\text{next}})$ 1 code$(S_{\\text{write}})$ 1 code$(D_{\\text{move}})$。\n\n对于转移 1，$\\delta(q_{s}, x) = (q_{s}, y, R)$，其组件为 $q_{s} \\mapsto 0$，$x \\mapsto 0$，$q_{s} \\mapsto 0$，$y \\mapsto 00$，$R \\mapsto 00$，所以编码为：\n$$T_{1} = 0\\,1\\,0\\,1\\,0\\,1\\,00\\,1\\,00 = 01010100100.$$\n\n对于转移 2，$\\delta(q_{s}, y) = (q_{f}, x, L)$，其组件为 $q_{s} \\mapsto 0$，$y \\mapsto 00$，$q_{f} \\mapsto 00$，$x \\mapsto 0$，$L \\mapsto 0$，所以编码为：\n$$T_{2} = 0\\,1\\,00\\,1\\,00\\,1\\,0\\,1\\,0 = 01001001010.$$\n\n对于转移 3，$\\delta(q_{s}, \\beta) = (q_{f}, \\beta, R)$，其组件为 $q_{s} \\mapsto 0$，$\\beta \\mapsto 000$，$q_{f} \\mapsto 00$，$\\beta \\mapsto 000$，$R \\mapsto 00$，所以编码为：\n$$T_{3} = 0\\,1\\,000\\,1\\,00\\,1\\,000\\,1\\,00 = 010001001000100.$$\n\n机器描述是这三个转移按顺序用分隔符 $11$ 连接起来：\n$$\\langle M \\rangle = T_{1}\\,11\\,T_{2}\\,11\\,T_{3} = 01010100100\\,11\\,01001001010\\,11\\,010001001000100 = 01010100100110100100101011010001001000100.$$\n\n输入串 $w = \\text{\"xy\"}$ 通过用分隔符 $1$ 连接符号编码来得到：$x \\mapsto 0$，$y \\mapsto 00$，因此\n$$\\langle w \\rangle = 0\\,1\\,00 = 0100.$$\n\nUTM 输入带是 $\\langle M \\rangle$ 后跟分隔符 $111$，然后是 $\\langle w \\rangle$：\n$$\\langle M \\rangle\\,111\\,\\langle w \\rangle = 01010100100110100100101011010001001000100\\,111\\,0100 = 010101001001101001001010110100010010001001110100.$$", "answer": "$$\\boxed{010101001001101001001010110100010010001001110100}$$", "id": "1377308"}, {"introduction": "在理解通用图灵机模拟另一台机器的机制之后，一个自然而关键的问题随之而来：这种模拟的效率有多高？这个问题将带你深入研究通用图灵机模拟的时间复杂性，要求你分析判定一个给定机器是否在特定步数内停机这一问题的性能[@problem_id:1466984]。掌握这种分析是理解从特定图灵机到通用图灵机模拟时著名的“多项式减速”的关键，这是计算复杂性理论的基石之一。", "problem": "考虑在有界时间内验证程序终止的问题。在理论计算机科学中，这可以用图灵机来建模。我们定义一个语言 $L$，它由在指定步数内在空输入带上停机的图灵机 (TM) 的编码组成。\n\n该语言形式化定义为：\n$L = \\{ \\langle M, 1^t \\rangle \\mid M \\text{ 是 TM 的字符串描述，且 } M \\text{ 在空输入带上最多 } t \\text{ 个计算步骤内停机} \\}$。\n\n一个假设的判定机的输入是单个字符串 $w = \\langle M, 1^t \\rangle$，它是由机器 $M$ 的描述和表示时间界限的 $t$ 个 1 的字符串组成的对偶的良定义编码。为了进行复杂度分析，你可以假设输入字符串的总长度为 $n = |\\langle M \\rangle| + t$，其中 $|\\langle M \\rangle|$ 是机器 $M$ 描述的长度，$t$ 是时间界限的整数值。\n\n你的任务是确定一个多带图灵机判定该语言 $L$ 的时间复杂度。对于此分析，假设使用一个多带通用图灵机 (UTM) 来模拟机器 $M$。此 UTM 的关键性能特征是，模拟机器 $M$ 的一个计算步骤所需的时间与 $M$ 描述的长度成正比。也就是说，对于某个常数 $c$，模拟 $M$ 的一步可以在 $c \\cdot |\\langle M \\rangle|$ 的时间内完成。\n\n设多带图灵机判定语言 $L$ 的时间复杂度由一个最紧的大O界 $O(f(n))$ 描述，其中 $n$ 是输入字符串的总长度。确定函数 $f(n)$ 的最简多项式表达式。", "solution": "设输入为 $w=\\langle M,1^{t}\\rangle$，并设 $m=|\\langle M\\rangle|$ 表示 $M$ 编码的长度。根据题目陈述，总输入长度为 $n=m+t$。\n判定过程：使用给定的多带 UTM 在空输入上模拟 $M$ 最多 $t$ 步。如果 $M$ 在 $t$ 步内停机，则接受；否则拒绝。\n\n成本构成：\n1) 解析/验证输入并从 $1^{t}$ 计算 $t$ 的成本为 $O(m+t)=O(n)$ 时间。\n2) 根据假设，对于某个常数 $c$，模拟 $M$ 的一步需要 $c \\cdot m$ 的时间。在最坏情况下，模拟会执行全部 $t$ 步，因此模拟成本至多为 $c \\cdot m \\cdot t$。\n3) 跨越 $t$ 次迭代的循环控制和簿记最多增加 $O(t)$，当 $m \\ge 1$ 时，这被 $O(mt)$ 所吸收。\n\n因此，总运行时间满足 $T(m,t)=O(mt+n)$。\n为了仅用 $n$ 来表示，使用 $m+t=n$ 和不等式 $mt \\le \\frac{(m+t)^2}{4} = \\frac{n^2}{4}$，这给出 $T(n)=O(\\frac{n^2}{4}+n) = O(n^2)$。\n紧致性：存在 $m=\\Theta(n)$ 和 $t=\\Theta(n)$ 的输入（例如 $m=\\lfloor n/2\\rfloor, t=\\lceil n/2\\rceil$），对于这些输入，判定机必须模拟 $\\Theta(t)$ 步，每步成本为 $\\Theta(m)$，产生的运行时间为 $\\Theta(mt)=\\Theta(n^2)$。因此，最紧的大O界具有 $f(n)=n^2$。\n\n因此，$f(n)$ 的最简多í式表达式是 $n^2$。", "answer": "$$\\boxed{n^2}$$", "id": "1466984"}, {"introduction": "通用性的力量超越了单一的计算类型。最后的这个练习将挑战你思考计算函数（转换器）的通用机器与识别语言（识别器）的通用机器之间的深层联系[@problem_id:2988365]。通过思考如何从一种构造出另一种，你将运用到$s$-$m$-$n$定理等可计算性理论的基本成果，从而体会到通用性本身是计算的一个稳健而灵活的属性。", "problem": "通用转换器是一台单一的图灵机 $U$，它在以下意义上计算一个通用的部分可计算函数：存在一个固定的关于字符串上的部分可计算函数的可接受的哥德尔编号 $\\{ \\varphi_e \\}_{e \\in \\mathbb{N}}$，使得对于所有索引 $e$ 和输入 $x$，$U$ 在输入 $\\langle e,x \\rangle$ 上停机并输出 $y$ 当且仅当 $\\varphi_e(x)$ 有定义且等于 $y$，否则 $U(\\langle e,x \\rangle)$ 发散。通用识别器是一台单一的图灵机 $V$，它在以下意义上对于语言识别是通用的：存在一个固定的关于递归可枚举语言 $\\{ L_e \\}_{e \\in \\mathbb{N}}$ 的识别器（半判定器）的可接受的哥德尔编号 $\\{ R_e \\}_{e \\in \\mathbb{N}}$，使得对于所有 $e$ 和 $x$，$V(\\langle e,x \\rangle)$ 接受当且仅当 $R_e$ 接受输入 $x$（否则 $V(\\langle e,x \\rangle)$ 根据相同的识别约定拒绝或发散）。假设存在一个固定的可计算双射（配对函数）$(x,y) \\mapsto \\langle x,y \\rangle$ 以及上述两种意义下的固定可接受的哥德尔编号；你也可以假设标准的推论，如 $s$-$m$-$n$ 定理和 Kleene 范式定理作为基础事实，但不应假设任何特殊用途的包装器已经存在。\n\n要求你通过从第一性原理出发，展示如何从通用转换器构建通用识别器，反之亦然，并分析这些构造的正确性需要哪些包装器约定是必要和充分的，从而比较识别的通用性与计算的通用性。\n\n在上述假设下，以下哪些陈述是正确的？\n\nA. 给定一个通用转换器 $U$，存在一个可计算的包装器映射 $e \\mapsto w(e)$，使得由以下方式定义的机器 $V^U$ 是一个用于递归可枚举语言的通用识别器：在输入 $\\langle e,x \\rangle$ 上，模拟 $U$ 在输入 $\\langle w(e), x \\rangle$ 上的行为，并且当且仅当该模拟停机时接受。\n\nB. 给定一个通用识别器 $V$，存在一个可计算的包装器映射 $e \\mapsto g(e)$，使得由以下方式定义的机器 $U^V$ 是一个用于部分可计算函数的通用转换器：在输入 $\\langle e,x \\rangle$ 上，对 $y \\in \\mathbb{N}$ 和在输入 $\\langle g(e), \\langle x,y \\rangle \\rangle$ 上对 $V$ 的模拟进行交叉模拟（dovetail），一旦某个此类模拟接受，则输出该 $y$ 并停机（否则发散）。\n\nC. 选项 B 中的构造无需任何进一步的约定即可工作，因为对于每个 $e$ 和 $x$，最多只有一个 $y$ 使得 $V(\\langle g(e), \\langle x,y \\rangle \\rangle)$ 接受，而这与 $g$ 如何选择无关。\n\nD. 为使选项 B 中的构造能够工作，底层的识别器 $R_e$ 必须是其语言的全判定器（total deciders）；否则，在 $U^V$ 中模拟的对输出的搜索将无法计算部分函数。\n\nE. 选项 A 中的构造会失败，除非 $U$ 在所有被模拟的识别器会接受的输入上都是全函数（即，除非只要目标识别器 $R_e$ 接受 $x$，$U(\\langle w(e), x \\rangle)$ 就保证停机），而这是对 $U$ 的通用性之外的额外要求。\n\nF. 两种构造都需要一个必要条件，即不仅需要一个固定的可计算双射 $\\langle \\cdot, \\cdot \\rangle$，还需要一个无前缀码来界定输入上的 $\\langle e,x \\rangle$；否则通用性可能会失效。\n\nG. 选项 A 和 B 中声称的可计算包装器 $w$ 和 $g$ 的存在性，在给定一个可接受的哥德尔编号的情况下，由 $s$-$m$-$n$ 定理保证的参数化所保证。\n\nH. 从通用转换器构造通用识别器是不可能的，因为接受关乎成员关系，而 $U$ 的停机关乎终止，且停机问题是不可判定的。\n\n选择所有正确的选项。", "solution": "该问题要求基于通用转换器（用于计算部分函数）和通用识别器（用于识别递归可枚举语言）之间的相互可构造性，分析它们之间的关系。我们将根据可计算性理论的第一性原理来评估每个陈述。\n\n问题定义了一个通用转换器 $U$，它针对一个可接受的部分可计算函数哥德尔编号 $\\{ \\varphi_e \\}_{e \\in \\mathbb{N}}$，使得 $U(\\langle e,x \\rangle)$ 输出 $y$ 如果 $\\varphi_e(x) = y$，否则发散。它还定义了一个通用识别器 $V$，它针对一个可接受的 RE 语言 $\\{ L_e \\}_{e \\in \\mathbb{N}}$ 的识别器 $\\{ R_e \\}_{e \\in \\mathbb{N}}$ 的哥德尔编号，使得 $V(\\langle e,x \\rangle)$ 接受如果 $x \\in L_e$。我们假设存在一个可计算的配对函数 $\\langle \\cdot, \\cdot \\rangle$ 和诸如 $s$-$m$-$n$ 定理等基础定理。\n\n让我们逐一评估每个选项。\n\nA. 给定一个通用转换器 $U$，存在一个可计算的包装器映射 $e \\mapsto w(e)$，使得由以下方式定义的机器 $V^U$ 是一个用于递归可枚举语言的通用识别器：在输入 $\\langle e,x \\rangle$ 上，模拟 $U$ 在输入 $\\langle w(e), x \\rangle$ 上的行为，并且当且仅当该模拟停机时接受。\n\n这个陈述建议从一个通用转换器 $U$ 构建一个通用识别器 $V^U$。所提议的机器 $V^U$ 接受 $\\langle e,x \\rangle$ 当且仅当 $U(\\langle w(e), x \\rangle)$ 停机。根据 $U$ 的定义，这等价于 $x$ 属于函数 $\\varphi_{w(e)}$ 的定义域。为了使 $V^U$ 成为编号 $\\{L_e\\}_{e \\in \\mathbb{N}}$ 的通用识别器，其行为必须与 $R_e$ 的行为相匹配。也就是说，$V^U(\\langle e,x \\rangle)$ 必须当且仅当 $x \\in L_e$ 时接受。因此，该构造是正确的，当且仅当存在一个全可计算函数 $w(e)$，使得对于每个 $e$，$L_e = \\text{dom}(\\varphi_{w(e)})$。\n\n这依赖于可计算性理论的一个基本定理：一个语言 $L$ 是递归可枚举的（RE），当且仅当它是一个部分可计算函数的定义域。从 RE 语言的识别器到其定义域为该语言的部分可计算函数的转换是有效的。给定一个识别器 $R_e$ 的索引 $e$，我们可以构造一个图灵机 $M$，它在输入 $x$ 上模拟 $R_e(x)$，如果 $R_e(x)$ 接受，则停机并输出一个固定值（例如，$0$）。如果 $R_e(x)$ 不接受（它拒绝或发散），则 $M(x)$ 发散。由 $M$ 计算的部分可计算函数 $\\psi_e$ 具有 $\\text{dom}(\\psi_e) = L_e$。因为这个构造对 $e$ 是一致的，$s$-$m$-$n$ 定理保证存在一个全可计算函数 $w$ 使得 $\\varphi_{w(e)} = \\psi_e$。有了这个包装器 $w$，机器 $V^U$ 正确地模拟了一个通用识别器。\n\n因此，该陈述是**正确的**。\n\nB. 给定一个通用识别器 $V$，存在一个可计算的包装器映射 $e \\mapsto g(e)$，使得由以下方式定义的机器 $U^V$ 是一个用于部分可计算函数的通用转换器：在输入 $\\langle e,x \\rangle$ 上，对 $y \\in \\mathbb{N}$ 和在输入 $\\langle g(e), \\langle x,y \\rangle \\rangle$ 上对 $V$ 的模拟进行交叉模拟（dovetail），一旦某个此类模拟接受，则输出该 $y$ 并停机（否则发散）。\n\n这建议从一个通用识别器 $V$ 构建一个通用转换器 $U^V$。$U^V$ 应该计算 $\\varphi_e(x)$。所提议的构造通过搜索输出来工作。如果对 $V(\\langle g(e), \\langle x,y \\rangle \\rangle)$ 的模拟接受，它就停机并输出 $y$。为了使这个构造正确，$V(\\langle g(e), \\langle x,y \\rangle \\rangle)$ 必须当且仅当 $\\varphi_e(x) = y$ 时接受。根据 $V$ 的定义，这等价于要求识别器 $R_{g(e)}$ 接受输入 $\\langle x,y \\rangle$ 当且仅当 $\\varphi_e(x) = y$。换句话说，语言 $L_{g(e)}$ 必须是函数 $\\varphi_e$ 的图：$L_{g(e)} = \\{ \\langle x,y \\rangle \\mid \\varphi_e(x)=y \\}$。\n\n这依赖于另一个基本定理：一个函数 $f$ 是部分可计算的，当且仅当它的图 $\\text{Graph}(f)$ 是一个 RE 集。从函数 $\\varphi_e$ 的索引 $e$ 到其图的识别器的转换是有效的。给定一个用于 $\\varphi_e$ 的机器，可以构造一个识别器，它在输入 $z$ 时将其解析为 $\\langle x,y \\rangle$，模拟 $\\varphi_e(x)$ 的计算，如果它停机并输出 $y$，则接受。这个构造对 $e$ 是一致的。根据 $s$-$m$-$n$ 定理，存在一个全可计算函数 $g$，它将 $\\varphi_e$ 的索引 $e$ 映射到其图的识别器 $R_{g(e)}$ 的索引 $g(e)$。\n\n燕尾式模拟过程正确地处理了潜在的无限搜索空间。如果 $\\varphi_e(x)$ 有定义且等于 $y_0$，则对于 $y=y_0$ 的模拟最终会接受，机器将停机并输出正确的输出。如果 $\\varphi_e(x)$ 未定义，则没有模拟会接受，机器将发散。这正确地实现了一个通用转换器。\n\n因此，该陈述是**正确的**。\n\nC. 选项 B 中的构造无需任何进一步的约定即可工作，因为对于每个 $e$ 和 $x$，最多只有一个 $y$ 使得 $V(\\langle g(e), \\langle x,y \\rangle \\rangle)$ 接受，而这与 $g$ 如何选择无关。\n\nB 中的构造确实是有效的，因为对于任何给定的 $x$ 和一个正确选择的 $g(e)$，最多只有一个 $y$ 会导致接受。这是因为 $L_{g(e)}$ 是函数 $\\varphi_e$ 的图，而一个函数将每个输入映射到最多一个输出。然而，这个陈述声称这个性质“无论如何选择 $g$”都成立。这是错误的。函数 $g$ 必须被专门选择，以将 $e$ 映射到 $\\varphi_e$ 的图的索引。如果选择另一个可计算函数 $g'$，例如，对于所有 $e$，$g'(e)=k$，其中 $L_k$ 是一个不是函数图的 RE 集（例如，$L_k = \\{\\langle 0,0 \\rangle, \\langle 0,1 \\rangle\\}$），那么对于输入 $x=0$，机器 $U^V$ 可能会找到两个“输出”$0$ 和 $1$，其行为将是未定义的（取决于燕尾式模拟的调度），从而无法计算一个函数。由于“因为”子句中提供的推理是错误的，整个陈述是谬误的。\n\n因此，该陈述是**不正确的**。\n\nD. 为使选项 B 中的构造能够工作，底层的识别器 $R_e$ 必须是其语言的全判定器（total deciders）；否则，在 $U^V$ 中模拟的对输出的搜索将无法计算部分函数。\n\n该陈述声称在构造 B 中使用的识别器 $R_{g(e)}$ 必须是判定器（即，它们必须在所有输入上停机，接受或拒绝）。这意味着语言 $L_{g(e)} = \\text{Graph}(\\varphi_e)$ 必须是递归的。这不是必需的。燕尾式模拟的目的恰恰是处理可能不会终止的模拟。$U^V$ 的搜索过程并行地模拟所有 $y \\in \\mathbb{N}$ 的 $V(\\langle g(e), \\langle x,y \\rangle \\rangle)$。如果 $\\varphi_e(x)=y_0$，对于 $y_0$ 的模拟最终会停机并接受。对于任何 $y \\neq y_0$，输入 $\\langle x,y \\rangle$ 不在 $L_{g(e)}$ 中，所以 $R_{g(e)}$ 不会接受它。识别器 $R_{g(e)}$（以及因此的 $V$）可能会在这些输入上发散。这对燕尾式搜索没有问题，它将继续为所有正在运行的模拟分配计算步骤，并最终找到那个接受的（如果存在的话）。如果要求所有部分可计算函数的图都必须是递归的，这将意味着所有 RE 集都是递归的，这是错误的。\n\n因此，该陈述是**不正确的**。\n\nE. 选项 A 中的构造会失败，除非 $U$ 在所有被模拟的识别器会接受的输入上都是全函数（即，除非只要目标识别器 $R_e$ 接受 $x$，$U(\\langle w(e), x \\rangle)$ 就保证停机），而这是对 $U$ 的通用性之外的额外要求。\n\n该陈述声称 A 中的构造需要 $U$ 具备一个额外的属性。让我们分析这个条件：“只要 $R_e$ 接受 $x$，$U(\\langle w(e), x \\rangle)$ 就保证停机。”这不是一个额外的要求，而是设定的直接结果。包装器 $w$ 的构造使得 $L_e = \\text{dom}(\\varphi_{w(e)})$。根据定义，$R_e$ 接受 $x$ 当且仅当 $x \\in L_e$。这意味着 $R_e$ 接受 $x$ 当且仅当 $x \\in \\text{dom}(\\varphi_{w(e)})$。根据通用转换器 $U$ 的定义，$U(\\langle i, z \\rangle)$ 停机当且仅当 $z \\in \\text{dom}(\\varphi_i)$。将此应用于 $i=w(e)$ 和 $z=x$，我们看到 $U(\\langle w(e), x \\rangle)$ 停机当且仅当 $x \\in \\text{dom}(\\varphi_{w(e)})$。结合这些等价关系，我们得到：$R_e$ 接受 $x \\iff U(\\langle w(e), x \\rangle)$ 停机。这正是构造工作所需要的，并且它源于 $U$ 的通用性和 $w$ 的定义。该陈述将此结果误解为一个失败或一个外部条件。\n\n因此，该陈述是**不正确的**。\n\nF. 两种构造都需要一个必要条件，即不仅需要一个固定的可计算双射 $\\langle \\cdot, \\cdot \\rangle$，还需要一个无前缀码来界定输入上的 $\\langle e,x \\rangle$；否则通用性可能会失效。\n\n问题假设了一个用于配对的“固定的可计算双射”。这是关键要求。它确保图灵机带上的单个字符串可以被明确地解析回其组成部分（例如，$e$ 和 $x$）。无前缀码是为字符串实现这种双射的一种方法，但它不是唯一的方法。例如，使用一个不出现在数据字符串中的特殊分隔符，或者使用长度前缀方案（例如，将 $s_1$ 和 $s_2$ 编码为 $\\text{bin}(|s_1|) \\# s_1 s_2$），也是实现唯一可解码性的有效方法。自然数的康托尔配对函数 $\\pi(a,b) = \\frac{1}{2}(a+b)(a+b+1)+b$ 提供了从 $\\mathbb{N} \\times \\mathbb{N}$ 到 $\\mathbb{N}$ 的一个可计算双射，并且其逆是可计算的。一个数字可以唯一地编码为字符串。无前缀码是一个充分条件，但不是必要条件。该陈述关于必要性的主张过于强烈。所需要和充分的是一个可计算双射的存在，而这已经被假设了。\n\n因此，该陈述是**不正确的**。\n\nG. 选项 A 和 B 中声称的可计算包装器 $w$ 和 $g$ 的存在性，在给定一个可接受的哥德尔编号的情况下，由 $s$-$m$-$n$ 定理保证的参数化所保证。\n\n$s$-$m$-$n$（或参数化）定理是证明这种可计算包装器存在的形式化工具。\n对于选项 A 的包装器 $w$：我们可以定义一个部分可计算函数 $\\Psi(e,x)$，它模拟 $R_e(x)$ 并在 $R_e$ 接受时停机。$s$-$m$-$n$ 定理指出，存在一个全可计算函数 $w(e)$ 使得对于所有 $x$，$\\varphi_{w(e)}(x) = \\Psi(e,x)$。这个 $w$ 就是所需的包装器。\n对于选项 B 的包装器 $g$：我们可以定义一个其行为由 $e$ 参数化的识别器。让我们定义一个图灵机，它接受输入 $\\langle e, z \\rangle$，将 $z$ 解析为 $\\langle x,y \\rangle$，并且如果 $\\varphi_e(x)=y$ 则接受。这描述了一个部分可计算函数 $\\Xi(e,z)$，其定义域是 $\\varphi_e$ 的图。$s$-$m$-$n$ 定理给了我们一个可计算函数 $s(e)$ 使得 $\\varphi_{s(e)}(z) = \\Xi(e,z)$。索引 $s(e)$ 是一个函数的索引，其定义域是我们需要的图。由于可接受的编号是递归同构的，我们可以将这个索引 $s(e)$ 映射到编号 $\\{R_j \\}$ 中的一个索引 $g(e)$。因此，这两个可计算包装器的存在是 $s$-$m$-$n$ 定理的直接推论。\n\n因此，该陈述是**正确的**。\n\nH. 从通用转换器构造通用识别器是不可能的，因为接受关乎成员关系，而 $U$ 的停机关乎终止，且停机问题是不可判定的。\n\n这个陈述是错误的。对选项 A 的分析表明，这种构造确实是可能的。给出的理由是有缺陷的。虽然接受对应于成员关系（$x \\in L_e$），而 $U$ 的停机对应于终止（$x \\in \\text{dom}(\\varphi_i)$），但关键的洞见是 RE 语言的类别与部分可计算函数的定义域的类别是相同的。如 A 中所讨论的，这种等价是有效的。停机问题的不可判定性并不意味着这种构造是不可能的；相反，它意味着我们构造的通用识别器将有一个不可判定的接受问题（即，语言 $\\{\\langle e,x \\rangle \\mid V^U(\\langle e,x \\rangle) \\text{ 接受}\\}$ 不是递归的）。这是预料之中的，因为这是通用的 RE 语言，已知它是 RE 但不是递归的。该论证混淆了一个性质的不可判定性与构造一个拥有该性质的对象的不可行性。\n\n因此，该陈述是**不正确的**。\n\n总结来说，陈述 A、B 和 G 是正确的。", "answer": "$$\\boxed{ABG}$$", "id": "2988365"}]}