{"hands_on_practices": [{"introduction": "我们从算术层级的基础开始。这项练习将计算理论中的核心概念——停机问题——与一阶算术的语言直接联系起来。通过从原始递归谓词出发构建公式，你将亲手实践如何将一个算法性质（“图灵机停机”）转化为一个具有特定量词结构的逻辑表达式，从而确定其在层级中的基础位置，即 $\\Sigma_1$ 和 $\\Pi_1$ 类。这个练习 [@problem_id:2986081] 是理解计算复杂性如何被逻辑公式精确刻画的第一步。", "problem": "设 $N$ 表示自然数集，我们使用一阶算术语言，该语言包含符号 $0$、后继、加法和乘法。固定一个确定性图灵机的有效 Gödel 编码，使得每台机器和每个格局都由 $N$ 中的一个数表示。假定以下可计算性理论和算术化的基本事实，你可以不加证明地使用它们：\n\n- 存在一个原始递归关系 $R(e,x,t,y)$，它当且仅当 $y$ 是由 $e$ 编码的机器在输入 $x$ 上精确执行 $t$ 步的完整计算历史（例如，一个有限的表或格局序列）的编码，并且该历史相对于机器的转移函数是正确的时成立。\n- 存在一个原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$，它当且仅当 $R(e,x,t,y)$ 成立且 $y$ 中编码的最后一个格局是停机格局（即，机器在时间 $t$ 前已进入指定的停机状态）时成立。\n- 一个矩阵是原始递归关系且其量词范围为 $N$ 的公式可以化为前束范式；其在算术层级中的级别由前导无界量词的模式决定：一个 $\\Sigma_{n}$-公式有一个存在量词的前导块，后跟 $n-1$ 次交替，一个 $\\Pi_{n}$-公式有一个全称量词的前导块，后跟 $n-1$ 次交替，所有这些公式都有一个可判定的（原始递归的）矩阵。\n\n仅使用这些基础：\n\n1. 构造一个一阶算术公式 $H(e,x)$，表示“由 $e$ 编码的机器在输入 $x$ 上停机”，使用 $R$ 和 $H_{\\mathrm{fin}}$ 作为你的可判定矩阵。将你的公式化为前束范式，并明确说明其前导量词块和矩阵。\n\n2. 构造一个一阶算术公式 $NH(e,x)$，表示“由 $e$ 编码的机器在输入 $x$ 上不停机”，同样仅使用对 $N$ 的量化和一个由 $R$ 和 $H_{\\mathrm{fin}}$ 构成的可判定矩阵。将你的公式化为前束范式，并明确说明其前导量词块和矩阵。\n\n3. 对于 $H(e,x)$ 和 $NH(e,x)$ 中的每一个，确定其最小算术层级级别 $L(\\cdot)$，定义如下：如果一个公式（在标准算术模型上）等价于一个具有不少于 $n$ 次交替的 $\\Sigma_{n}$-公式，则取 $L$ 为 $n$；如果它等价于一个具有不少于 $n$ 次交替的 $\\Pi_{n}$-公式，则取 $L$ 为 $n$。通过分析量词结构和矩阵的可判定性来证明你的分类。\n\n4. 计算 $L(H)+L(NH)$ 的精确整数值。将你的最终答案报告为一个精确的整数。不需要四舍五入。", "solution": "该问题要求基于给定的原始递归关系，为停机问题及其补集构造和分类一阶算术公式。\n\n**问题验证**\n\n首先对问题陈述进行验证。\n\n*   **步骤 1：提取已知条件**\n    *   论域：自然数集 $N$。\n    *   语言：一阶算术，包含符号 $0$、后继、加法和乘法。\n    *   Gödel 编码：一个有效的编码方案将图灵机及其格局映射到 $N$ 中的数。\n    *   原始递归关系 $R(e,x,t,y)$：当且仅当 $y$ 是机器 $e$ 在输入 $x$ 上精确执行 $t$ 步的正确计算历史的编码时成立。\n    *   原始递归关系 $H_{\\mathrm{fin}}(e,x,t,y)$：当且仅当 $R(e,x,t,y)$ 为真且计算在第 $t$ 步处于停机状态时成立。\n    *   算术层级定义：如果一个公式有一个存在量词的前导块和 $n-1$ 次量词交替，且其矩阵是可判定的，则该公式是 $\\Sigma_n$ 公式。如果一个公式有一个全称量词的前导块和 $n-1$ 次量词交替，且其矩阵是可判定的，则该公式是 $\\Pi_n$ 公式。\n    *   级别 $L(\\cdot)$：使得一个公式等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式的最小 $n \\in N, n \\ge 1$。\n\n*   **步骤 2：使用提取的已知条件进行验证**\n    该问题是可计算性理论和数理逻辑中的一个标准练习。它在科学上植根于计算的形式化（Church-Turing 论题）及其与形式算术的关系（由 Gödel、Kleene 等人建立）。所有术语都得到了精确定义，前提是该领域的标准结果。问题提法得当、客观且自洽，没有明显的逻辑矛盾、歧义或事实错误。\n\n*   **步骤 3：结论与行动**\n    该问题被认为是有效的。有必要提供一个完整的解答。\n\n**第 1 部分：构造公式 $H(e,x)$**\n\n“由 $e$ 编码的机器在输入 $x$ 上停机”这一断言为真，如果存在一个时间 $t \\in N$ 和一个相应的计算历史 $y \\in N$，它们代表了一个有效的、停机的计算。谓词 $H_{\\mathrm{fin}}(e,x,t,y)$ 捕捉了特定时间 $t$ 和历史 $y$ 的这种情况。为了表示在*某个*时间发生停机，我们对 $t$ 和 $y$ 进行存在量化。\n\n公式 $H(e,x)$ 因此是：\n$$H(e,x) \\equiv \\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y)$$\n这个公式是前束范式。\n*   **前导量词块：** $\\exists t \\exists y$。这是一个单一的存在量词块。\n*   **矩阵：** $H_{\\mathrm{fin}}(e,x,t,y)$。问题陈述此关系是原始递归的。根据定义，原始递归关系可由图灵机判定。因此，该矩阵是可判定的。\n\n**第 2 部分：构造公式 $NH(e,x)$**\n\n“由 $e$ 编码的机器在输入 $x$ 上不停机”这一断言是 $H(e,x)$ 的逻辑否定。\n$$NH(e,x) \\equiv \\neg H(e,x)$$\n我们代入 $H(e,x)$ 的表达式，并通过应用量词对偶规则（$\\neg \\exists z P(z) \\equiv \\forall z \\neg P(z)$）将所得公式转换为前束范式。\n$$NH(e,x) \\equiv \\neg (\\exists t \\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\, \\neg (\\exists y \\, H_{\\mathrm{fin}}(e,x,t,y))$$\n$$\\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n$NH(e,x)$ 的前束范式是：\n$$NH(e,x) \\equiv \\forall t \\forall y \\, \\neg H_{\\mathrm{fin}}(e,x,t,y)$$\n*   **前导量词块：** $\\forall t \\forall y$。这是一个单一的全称量词块。\n*   **矩阵：** $\\neg H_{\\mathrm{fin}}(e,x,t,y)$。由于 $H_{\\mathrm{fin}}$ 是一个可判定关系，其否定 $\\neg H_{\\mathrm{fin}}$ 也是可判定的。\n\n**第 3 部分：算术层级分类**\n\n我们确定每个公式的最小级别 $L(\\cdot)$。\n\n**$H(e,x)$ 的分类：**\n公式 $H(e,x)$ 有一个存在量词的前导块和一个可判定的矩阵。这种结构对应于一个 $\\Sigma_1$-公式。满足 $H(e,x)$ 的数对 $(e,x)$ 的集合是停机集，已知该集合是不可判定的。一个集合是可判定的，当且仅当它可由一个 $\\Delta_1$ 公式定义（等价于同时是一个 $\\Sigma_1$ 和一个 $\\Pi_1$ 公式），而这又等价于有一个无量词的定义（在一个可判定语言上的 $\\Sigma_0$ 或 $\\Pi_0$ 公式）。由于停机集是不可判定的，它不能由 $\\Sigma_0$ 公式定义。因此，它的最小分类是 $\\Sigma_1$。\n这意味着 $L(H) = 1$。\n\n**$NH(e,x)$ 的分类：**\n公式 $NH(e,x)$ 有一个全称量词的前导块和一个可判定的矩阵。这种结构对应于一个 $\\Pi_1$-公式。满足 $NH(e,x)$ 的数对 $(e,x)$ 的集合是停机集的补集。\n1.  这个集合是不可判定的，因为如果它是可判定的，那么它的补集（停机集）也将是可判定的，而这是一个已知的谬误。因此，它不能是 $\\Sigma_0$ 或 $\\Pi_0$ 集。\n2.  我们还必须证明它不是一个 $\\Sigma_1$ 集。一个集合可由一个 $\\Sigma_1$ 公式定义，当且仅当它是递归可枚举的。停机集（由 $H(e,x)$ 定义）是一个 $\\Sigma_1$-集，因此它是递归可枚举的。根据 Post 定理，一个集合是可判定的（递归的），当且仅当该集合及其补集都是递归可枚举的。如果停机集的补集也是递归可枚举的（即 $\\Sigma_1$），那么停机集将是可判定的。这是一个矛盾。\n因此，由 $NH(e,x)$ 定义的集合不是 $\\Sigma_1$。其最简单的分类是 $\\Pi_1$。\n这意味着 $L(NH) = 1$。\n\n**第 4 部分：最终计算**\n\n问题要求计算 $L(H) + L(NH)$ 的值。使用第 3 部分的结果：\n$$L(H) = 1$$\n$$L(NH) = 1$$\n总和是：\n$$L(H) + L(NH) = 1 + 1 = 2$$", "answer": "$$\\boxed{2}$$", "id": "2986081"}, {"introduction": "在掌握了基础层面后，我们将向算术层级的更高处攀登。这项练习 [@problem_id:2984438] 提供了一个更复杂的公式，其挑战不仅在于识别其 $\\exists\\forall\\exists$ 的量词结构，更在于理解其背后深刻的计算意义——它定义了所有余有限（cofinite）的递归可枚举集。你需要证明它属于 $\\Sigma_3$ 类，并论证这个分类是精确的，这通常涉及到证明该集合的 $\\Sigma_3$-完备性。这个实践揭示了算术层级如何用于分类递归可枚举集本身的性质。", "problem": "设语言为一阶算术，其符号包含 $0$, $1$, $+$, $\\times$, 和 $\\leq$。固定一种通过克林（Kleene）的$\\mathcal{T}$-谓词对图灵机和计算进行的原始递归编码：存在一个原始递归关系$H(e,x,s)$，表示索引为$e$的图灵机在输入$x$上最多在$s$步内停机。考虑自然数上的一元谓词，由以下公式定义\n$$\n\\Theta(e)\\;:\\;\\exists m\\;\\forall x\\;\\exists s\\;\\big(x > m \\rightarrow H(e,x,s)\\big)\n$$\n这个谓词 $\\Theta(e)$ 意味着由索引 $e$ 定义的可计算可枚举集合的定义域是余有限的（即，它包含除有限个之外的所有自然数）。\n在算术层级中对由 $\\Theta(e)$ 定义的集合进行分类。确定最小的自然数 $n \\geq 1$，使得 $\\Theta(e)$ 等价于一个 $\\Sigma_n$ 或 $\\Pi_n$ 公式。你的答案应该是一个整数。", "solution": "该问题是有效的，因为它是可计算性理论和数理逻辑领域内一个适定（well-posed）的问题，依赖于标准定义（算术分层，克林的$\\mathcal{T}$-谓词），并且没有不一致或模糊之处。\n\n任务是找到最小的自然数$n$，使得谓词$\\Theta(e)$等价于一个$\\Sigma_n$或$\\Pi_n$公式。该谓词定义如下：\n$$\n\\Theta(e)\\;:\\;\\exists m\\;\\forall x\\;\\exists s\\;\\big(x > m \\rightarrow H(e,x,s)\\big)\n$$\n这个公式表示“存在一个数 $m$，使得对于所有大于 $m$ 的数 $x$，机器 $e$ 在输入 $x$ 上最终会停机（即存在一个停机步骤 $s$）”。这正是“机器 $e$ 的停机集合是余有限的”这一性质的形式化表达。\n\n首先，我们分析公式的量词结构。它已经是前束范式，量词前缀为 $\\exists m \\, \\forall x \\, \\exists s$。\n*   第一个量词块是 $\\exists m$（存在量词）。\n*   第二个量词块是 $\\forall x$（全称量词）。\n*   第三个量词块是 $\\exists s$（存在量词）。\n\n量词以 $\\exists$ 开头，然后交替为 $\\forall$，再交替为 $\\exists$。我们总共有三个量词块，以存在量词开头。母式（matrix）是 $(x > m \\rightarrow H(e,x,s))$。因为 $x>m$ 是可判定的，$H(e,x,s)$ 根据问题陈述是原始递归的（因此是可判定的），所以整个母式也是可判定的。\n\n根据算术层级的定义，一个前缀为 $\\exists\\forall\\exists\\dots$ 并且有 $n$ 个量词块的公式是 $\\Sigma_n$ 公式。在我们的例子中，有3个量词块，所以这个公式是 $\\Sigma_3$ 公式。因此，由 $\\Theta(e)$ 定义的集合属于 $\\Sigma_3^0$ 类。\n\n接下来，我们需要确定这个分类是否是最小的。也就是说，这个集合是否真的是 $\\Sigma_3^0$-完备的，或者它是否可以被一个更简单的公式（如 $\\Pi_2^0$, $\\Sigma_2^0$, $\\Pi_1^0$, $\\Sigma_1^0$）所定义。\n\n在可计算性理论中，集合 $\\{e \\mid W_e \\text{ is cofinite}\\}$（这里 $W_e$ 是由机器 $e$ 枚举的集合，其定义域与停机集合相同）是一个标准的 $\\Sigma_3^0$-完备集合。证明其 $\\Sigma_3^0$-完备性通常需要将任何 $\\Sigma_3^0$ 集合多一归约到它。这是一个标准的、非平凡的结果，通常在高级可计算性理论课程中教授。\n\n直观上，我们可以论证它为什么不太可能是更简单的。\n*   它不可能是 $\\Delta_1^0$（可计算的），因为这会与莱斯定理（Rice's Theorem）相矛盾，该定理指出任何关于 c.e. 集合的非平凡语义性质都是不可判定的。余有限性是一个非平凡的语义性质。\n*   它也不属于 $\\Sigma_2^0$ 或 $\\Pi_2^0$。例如，集合 $\\text{FIN} = \\{e \\mid W_e \\text{ is finite}\\}$ 是 $\\Sigma_2^0$-完备的。我们的集合 $\\text{COF} = \\{e \\mid W_e \\text{ is cofinite}\\}$ 并不是 $\\text{FIN}$ 的补集（因为一个集合可以既不是有限的也不是余有限的），所以我们不能直接通过对偶性来论证。然而，标准的证明表明 $\\text{COF}$ 的复杂性确实比 $\\text{FIN}$ 更高。\n\n既然该问题要求最小的自然数 $n$，并且我们已经确定该公式是 $\\Sigma_3^0$ 形式，而该集合在可计算性理论中被确认为 $\\Sigma_3^0$-完备，那么最小的 $n$ 就是 3。\n\n因此，$\\Theta(e)$ 是一个 $\\Sigma_3$ 公式，并且它定义的集合是 $\\Sigma_3^0$-完备的，所以最小的 $n$ 是 3。", "answer": "$$\\boxed{3}$$", "id": "2984438"}, {"introduction": "集合的分类并不总是简单地通过其最明显的量词范式来确定。这项练习 [@problem_id:483857] 探讨了一个复杂性介于 $\\Sigma$ 类和 $\\Pi$ 类之间的集合，它属于 $\\Delta_2$ 类。为了精确地对其进行分类，你需要证明该集合既有一个 $\\Sigma_2$ 定义，也有一个 $\\Pi_2$ 定义，同时还要证明它不属于任何更低的类别（即 $\\Sigma_1$ 或 $\\Pi_1$）。这个过程将加深你对 $\\Delta$ 类的理解，并展示了在算术层级中进行精细分类所需的严谨论证技巧。", "problem": "考虑集合 $ A = \\{ e \\in \\mathbb{N} \\mid \\phi_e(0) \\downarrow \\ \\text{and} \\ \\phi_e(1) \\uparrow \\} $，其中 $\\phi_e$ 表示由索引为 $e$ 的图灵机计算的部分可计算函数，$\\downarrow$ 表示计算停机，而 $\\uparrow$ 表示计算不停机。\n\n在算术层级中对集合 $A$ 进行分类。具体来说，确定包含 $A$ 的最小类（例如某个 $n$ 的 $\\Sigma^0_n$、$\\Pi^0_n$ 或 $\\Delta^0_n$）。请通过证明其成员资格条件的量词复杂度，并提供必要的归约来确定该类的最小性，从而证明你的答案。\n\n**关于算术层级的背景知识：**\n- 如果一个集合是递归的，则它属于 $\\Sigma^0_0 = \\Pi^0_0 = \\Delta^0_0$。\n- 对于 $n \\geq 0$，如果一个集合可以由一个在一个递归谓词上以存在量词开头的 $n+1$ 个交替量词的公式来定义，则该集合是 $\\Sigma^0_{n+1}$ 的。类似地，如果它以全称量词开头，则它是 $\\Pi^0_{n+1}$ 的。\n- 如果一个集合既是 $\\Sigma^0_n$ 的又是 $\\Pi^0_n$ 的，则它是 $\\Delta^0_n$ 的。\n- 停机集 $K = \\{ e \\mid \\phi_e(e) \\downarrow \\}$ 是 $\\Sigma^0_1$-完全的，其补集 $\\bar{K} = \\{ e \\mid \\phi_e(e) \\uparrow \\}$ 是 $\\Pi^0_1$-完全的。", "solution": "为了对 $A$ 进行分类，我们使用量词来表示其成员资格条件。条件 $e \\in A$ 要求：\n1. $\\phi_e(0) \\downarrow$，意味着存在一个步骤 $t_0$，使得计算在步骤 $t_0$ 前停机。\n2. $\\phi_e(1) \\uparrow$，意味着对于所有的步骤 $t_1$，计算都不会在步骤 $t_1$ 前停机。\n\n使用递归谓词 $H(e, x, t)$（如果索引为 $e$ 的机器在输入为 $x$ 时在 $t$ 步内停机，则该谓词为真），该条件是：\n\n$$\ne \\in A \\iff (\\exists t_0) \\, H(e, 0, t_0) \\land (\\forall t_1) \\, \\neg H(e, 1, t_1).\n$$\n  \n\n**步骤 1：证明 $A \\in \\Sigma^0_2$ 且 $A \\in \\Pi^0_2$（因此 $A \\in \\Delta^0_2$）**\n- 重新排列量词以形成一个 $\\Sigma^0_2$ 表达式：\n  \n$$\n  e \\in A \\iff \\exists t_0 \\, \\forall t_1 \\, [H(e, 0, t_0) \\land \\neg H(e, 1, t_1)].\n  $$\n  \n  这里，$\\exists t_0 \\, \\forall t_1$ 是一个 $\\Sigma^0_2$ 前束，并且矩阵是递归的。\n- 重新排列以形成一个 $\\Pi^0_2$ 表达式：\n  \n$$\n  e \\in A \\iff \\forall t_1 \\, \\exists t_0 \\, [H(e, 0, t_0) \\land \\neg H(e, 1, t_1)].\n  $$\n  \n  这个式子成立，因为如果 $e \\in A$，那么对于任何 $t_1$，$\\neg H(e, 1, t_1)$ 都为真，并且存在一个固定的 $t_0$（输入 0 的停机时间）满足 $H(e, 0, t_0)$，这个 $t_0$ 的存在不依赖于 $t_1$。反之，如果该公式成立，$\\forall t_1 \\, \\neg H(e, 1, t_1)$ 意味着 $\\phi_e(1) \\uparrow$，并且 $(\\forall t_1) (\\exists t_0 \\, H(e, 0, t_0) \\land \\dots)$ 蕴含了 $\\exists t_0 \\, H(e, 0, t_0)$，这意味着 $\\phi_e(0) \\downarrow$。\n由于 $A$ 同时属于 $\\Sigma^0_2$ 和 $\\Pi^0_2$，所以它属于 $\\Delta^0_2$。\n\n**步骤 2：证明 $A \\not\\in \\Sigma^0_1$ 且 $A \\not\\in \\Pi^0_1$**\n- **证明 $A \\not\\in \\Sigma^0_1$（不是递归可枚举的）：** 进行归约 $\\bar{K} \\leq_m A$。定义一个可计算函数 $f$，使得 $e \\in \\bar{K} \\iff f(e) \\in A$。对于任意 $e$，令 $\\phi_{f(e)}$ 为：\n  - 输入为 0 时：立即停机。\n  - 输入为 1 时：模拟 $\\phi_e(e)$；如果它停机，则停机；否则，永远循环。\n  那么：\n  - 如果 $e \\in \\bar{K}$（$\\phi_e(e) \\uparrow$），那么 $\\phi_{f(e)}(0) \\downarrow$（停机）且 $\\phi_{f(e)}(1) \\uparrow$（模拟循环），所以 $f(e) \\in A$。\n  - 如果 $e \\not\\in \\bar{K}$（$\\phi_e(e) \\downarrow$），那么 $\\phi_{f(e)}(1) \\downarrow$，所以 $f(e) \\not\\in A$。\n  由于 $\\bar{K}$ 是 $\\Pi^0_1$-完全集，它不属于 $\\Sigma^0_1$。因为存在从 $\\bar{K}$ 到 $A$ 的多一归约，所以 $A$ 也不可能属于 $\\Sigma^0_1$。\n\n- **证明 $A \\not\\in \\Pi^0_1$（不是余递归可枚举的）：** 我们通过将 $\\Sigma^0_1$-完备集 $K$ 多一归约到 $A$ (即 $K \\leq_m A$) 来证明 $A$ 是 $\\Sigma^0_1$-难的。定义一个可计算函数 $g$，对于任意 $e$，$\\phi_{g(e)}$ 定义如下：\n  - 输入为 0 时：模拟 $\\phi_e(e)$ 的计算。如果 $\\phi_e(e)$ 停机，则停机。\n  - 输入为 1 时：永远循环。\n  那么：\n  - 如果 $e \\in K$（$\\phi_e(e) \\downarrow$），则 $\\phi_{g(e)}(0) \\downarrow$ 且 $\\phi_{g(e)}(1) \\uparrow$。因此，$g(e) \\in A$。\n  - 如果 $e \\not\\in K$（$\\phi_e(e) \\uparrow$），则 $\\phi_{g(e)}(0) \\uparrow$。因此，$g(e) \\not\\in A$。\n  我们已经建立了 $K \\leq_m A$。如果 $A$ 属于 $\\Pi^0_1$，那么 $K$ 也将属于 $\\Pi^0_1$（因为 $\\Pi^0_1$ 在多一归约下是向后封闭的）。然而，我们知道 $K$ 是不可判定的 c.e. 集，它不属于 $\\Pi^0_1$。这是一个矛盾。因此，$A$ 不属于 $\\Pi^0_1$。\n\n**结论：**\n$A$ 属于 $\\Delta^0_2$ 且不属于任何更低的类（$\\Sigma^0_1$ 或 $\\Pi^0_1$），因此包含 $A$ 的最小类是 $\\Delta^0_2$。", "answer": "$$ \\boxed{\\Delta^0_2} $$", "id": "483857"}]}