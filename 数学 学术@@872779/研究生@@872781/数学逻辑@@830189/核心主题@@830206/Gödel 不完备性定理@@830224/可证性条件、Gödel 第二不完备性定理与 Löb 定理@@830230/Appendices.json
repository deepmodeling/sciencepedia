{"hands_on_practices": [{"introduction": "要理解哥德尔和勒布的深刻定理，我们必须首先掌握像“证明”这样的抽象逻辑概念是如何被编码为数字并在算术内部进行操作的。这个基础练习聚焦于证明谓词的精确算术定义，特别是如何形式化“一个定理是有效证明序列中的最后一个陈述”这一关键思想。掌握这一技术细节对于确立可证性谓词具有正确的逻辑复杂性（即 $\\Sigma_1$ 形式）至关重要，而这正是证明可推导性条件的基石。[@problem_id:2971586]", "problem": "设 $T$ 是一阶算术语言中 $\\Sigma_1$ 公式归纳法 ($I\\Sigma_1$) 的一个可计算公理化扩张，并固定一个公式编码的有限序列和证明对象的标准原始递归哥德尔编码。特别地，存在一些原始递归函数，其图像可在 $I\\Sigma_1$ 中由有界 ($\\Delta_0$) 公式定义，例如返回由 $y$ 编码的有限序列中的项数的长度函数 $y \\mapsto \\mathrm{len}(y)$，以及对于 $i\\mathrm{len}(y)$ 返回由 $y$ 编码的序列的第 $i$ 项的项函数 $(y,i) \\mapsto \\mathrm{entry}(y,i)$。此外，还有一个原始递归谓词 $\\mathrm{Prf}_T(y)$，它表示 $y$ 在一个固定的希尔伯特式演算中编码了一个正确的 $T$-证明，即每一行要么是一个逻辑公理，要么是 $T$ 的一个公理，要么是通过肯定前件式从前面的行推导出来的。\n\n可证性的算术化需要一个公式来捕捉“$p$ 是由 $y$ 编码的证明的最后一行”这一概念，并用它来定义二元证明谓词 $\\mathrm{Proof}_T(y,x)$，进而得到一元可证性谓词 $\\mathrm{Prov}_T(x) \\equiv \\exists y\\, \\mathrm{Proof}_T(y,x)$。$I\\Sigma_1$ 中此类定义的正确性为 Gödel 第二不完备性定理和 Löb 定理中使用的可证性条件提供了基础。\n\n以下哪个选项给出了“$p$ 是由 $y$ 编码的证明的最后一行”的正确 $I\\Sigma_1$-形式化，并正确解释了如何用它来定义 $\\mathrm{Proof}_T(y,x)$ 从而使 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$ 的？\n\nA. 通过有界公式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; \\mathrm{Seq}(y)\\;\\wedge\\;\\mathrm{len}(y)>0\\;\\wedge\\; p=\\mathrm{entry}\\!\\big(y,\\mathrm{len}(y)-1\\big),$$\n其中 $\\mathrm{Seq}(y)$ 断言 $y$ 编码了一个公式编码的有限序列。然后设置\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\mathrm{Last}(y,x),$$\n因此\n$$\\mathrm{Prov}_T(x)\\;\\;\\equiv\\;\\;\\exists y\\,\\mathrm{Proof}_T(y,x).$$\n因为 $\\mathrm{Prf}_T$ 和编码函数是原始递归的，所以 $I\\Sigma_1$ 证明了 $\\mathrm{Last}(y,p)$ 是 $\\Delta_0$ 且 $\\mathrm{Proof}_T(y,x)$ 是 $\\Delta_0$，这使得 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Sigma_1$ 公式，并使得在 $I\\Sigma_1$ 中内化肯定前件式和 Hilbert–Bernays–Löb 可证性条件成为可能。\n\nB. 通过以下方式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; p\\in y\\;\\wedge\\;\\forall i\\mathrm{len}(y)\\,\\big(p\\ge \\mathrm{entry}(y,i)\\big),$$\n因此最后一行是编码证明中出现的最大哥德尔数。然后设置\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\; x\\in y,$$\n因为对于可证性而言，重要的是 $x$ 出现在证明的某个地方。通过对 $y$ 进行存在量化，这确保了 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$ 的。\n\nC. “最后一行”属性不能在 $I\\Sigma_1$ 中用有界 ($\\Delta_0$) 公式表示，因为它内在地对序列的所有扩张进行量化，因此需要一个 $\\Pi_2$ 条件。因此，必须定义\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\;\\forall z\\,\\big(\\text{$z$ 扩展 $y$} \\rightarrow \\text{$z$ 的最后一个条目是 $x$}\\big),$$\n这使得 $\\mathrm{Prov}_T(x)$ 成为一个 $\\Pi_2$ 公式。这种更高的复杂性对于恢复 Gödel 和 Löb 定理中使用的可证性条件是必要的。\n\nD. 通过以下方式定义“最后一行”关系\n$$\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\;\\exists i\\mathrm{len}(y)\\,\\big(p=\\mathrm{entry}(y,i)\\big),$$\n也就是说，$p$ 是证明的某一行。然后设置\n$$\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\exists i\\mathrm{len}(y)\\,\\big(x=\\mathrm{entry}(y,i)\\big),$$\n因为 $x$ 在有效证明中的任何出现都足以证明 $x$ 是可证的。这使得 $\\mathrm{Prov}_T(x)$ 保持在 $\\Sigma_1$ 中，并且对于可证性条件是足够的。", "solution": "任务是为指定理论 $T$ 确定可证性谓词 $\\mathrm{Prov}_T(x)$ 的正确形式化，确保该谓词是一个 $\\Sigma_1$ 公式，并满足证明 Gödel 定理和 Löb 定理的要求。这取决于谓词 $\\mathrm{Proof}_T(y,x)$ 的正确算术化，该谓词代表“$y$ 是哥德尔数为 $x$ 的公式的一个 $T$-证明的编码”。\n\n在希尔伯特式系统中，一个形式证明是一个公式的有限序列，其中每个公式要么是一个公理，要么是通过推理规则（在此情况下是肯定前件式）从前面的公式推导出来的。一个公式 $\\phi$ 被这样一个序列所证明，当且仅当 $\\phi$ 是该序列中的**最后**一个公式。\n\n$\\mathrm{Prov}_T(x)$ 的定义通常由 $\\exists y \\, \\mathrm{Proof}_T(y,x)$ 给出。根据算术分层，为了使 $\\mathrm{Prov}_T(x)$ 是一个 $\\Sigma_1$ 公式，其母式 $\\mathrm{Proof}_T(y,x)$ 必须是一个 $\\Delta_0$ 公式（一个所有量词都有界的公式）。\n\n公式 $\\mathrm{Proof}_T(y,x)$ 必须断言两个条件：\n1.  $y$ 编码了一个有效的 $T$-证明。这由谓词 $\\mathrm{Prf}_T(y)$ 给出。问题陈述 $\\mathrm{Prf}_T(y)$ 是一个原始递归谓词。可计算性理论的一个基本定理（可在弱算术如 $I\\Sigma_1$ 中证明）指出，每个原始递归谓词都可以由一个 $\\Delta_0$ 公式定义。\n2.  哥德尔数为 $x$ 的公式是由 $y$ 编码的证明的结论。如前所述，这意味着 $x$ 必须是由 $y$ 编码的序列中最后一个公式的哥德尔数。\n\n我们来构造第二个条件的公式。问题提供了一个用于有限序列的标准哥德尔编码机制，带有原始递归函数 $\\mathrm{len}(y)$ 和 $\\mathrm{entry}(y,i)$，它们的图像可由 $\\Delta_0$ 公式定义。如果一个序列的长度大于0，则它非空。长度为 $L$ 的序列的索引从 $0$ 到 $L-1$。因此，最后一项的索引是 $\\mathrm{len}(y)-1$。\n断言“$p$ 是由 $y$ 编码的证明的最后一行”被形式化为：“$y$ 编码了一个非空的公式序列，并且 $p$ 是索引为 $\\mathrm{len}(y)-1$ 的项”。\n用形式化符号表示，即：\n$$ \\mathrm{Last}(y,p) \\equiv \\mathrm{Seq}(y) \\land \\mathrm{len}(y) > 0 \\land p = \\mathrm{entry}(y, \\mathrm{len}(y)-1) $$\n此处，$\\mathrm{Seq}(y)$ 是一个谓词（假定为 $\\Delta_0$），用于检查 $y$ 是否是一个序列的有效编码。关系 $l = \\mathrm{len}(y)$ 和 $e = \\mathrm{entry}(y,i)$ 是 $\\Delta_0$ 的。基本的算术运算和比较，如 $k = l-1$ 和 $l>0$，也是 $\\Delta_0$ 的。由于所有组件和操作都是 $\\Delta_0$ 的，复合公式 $\\mathrm{Last}(y,p)$ 是一个 $\\Delta_0$ 公式。\n\n现在，我们可以将 $\\mathrm{Proof}_T(y,x)$ 定义为这两个条件的合取：\n$$ \\mathrm{Proof}_T(y,x) \\equiv \\mathrm{Prf}_T(y) \\land \\mathrm{Last}(y,x) $$\n由于 $\\mathrm{Prf}_T(y)$ 和 $\\mathrm{Last}(y,x)$ 都是 $\\Delta_0$ 公式，它们的合取 $\\mathrm{Proof}_T(y,x)$ 也是一个 $\\Delta_0$ 公式。\n\n最后，可证性谓词定义为：\n$$ \\mathrm{Prov}_T(x) \\equiv \\exists y \\, \\mathrm{Proof}_T(y,x) $$\n这是一个对 $\\Delta_0$ 公式的存在量化，根据定义，它是一个 $\\Sigma_1$ 公式。这个标准构造正是证明 Hilbert-Bernays-Löb 可证性条件所需要的，特别是第三个条件 $T \\vdash \\mathrm{Prov}_T(\\ulcorner \\phi \\urcorner) \\to \\mathrm{Prov}_T(\\ulcorner \\mathrm{Prov}_T(\\ulcorner \\phi \\urvenir) \\urvenir)$，其证明依赖于 $\\Sigma_1$ 公式 $\\mathrm{Prov}_T(\\ulcorner \\phi \\urvenir)$ 的 $\\Sigma_1$-完备性。\n\n现在我们根据这个推导来评估给出的选项。\n\n**A. 通过有界公式定义“最后一行”关系...**\n这个选项展示了上面推导出的确切构造。\n-   $\\mathrm{Last}(y,p)\\;\\;\\equiv\\;\\; \\mathrm{Seq}(y)\\;\\wedge\\;\\mathrm{len}(y)>0\\;\\wedge\\; p=\\mathrm{entry}\\!\\big(y,\\mathrm{len}(y)-1\\big)$：这是序列最后一行的正确定义。\n-   $\\mathrm{Proof}_T(y,x)\\;\\;\\equiv\\;\\; \\mathrm{Prf}_T(y)\\;\\wedge\\;\\mathrm{Last}(y,x)$：这正确地将证明的有效性与结论结合起来。\n-   $\\mathrm{Prov}_T(x)\\;\\;\\equiv\\;\\;\\exists y\\,\\mathrm{Proof}_T(y,x)$：这是可证性谓词的标准定义。\n-   所提供的推理完全正确：原始递归性意味着 $\\mathrm{Prf}_T$ 和编码函数具有 $\\Delta_0$ 可表示性，这使得 $\\mathrm{Proof}_T(y,x)$ 是一个 $\\Delta_0$ 公式，而 $\\mathrm{Prov}_T(x)$ 是一个 $\\Sigma_1$ 公式。这种结构对于证明可证性条件至关重要。\n*   **结论：** 正确。\n\n**B. 通过...最大哥德尔数...定义“最后一行”关系...**\n这个选项提出将最后一行定义为证明中具有最大哥德尔数的公式。这在概念上是错误的。一个证明的结论是由其在推导序列中的位置决定的，而不是其编码的数值。该选项还提出将 $\\mathrm{Proof}_T(y,x) \\equiv \\mathrm{Prf}_T(y) \\wedge x \\in y$ 定义为 $x$ 仅仅出现在证明的某个地方。这也是不正确的；出现在证明中的公式不一定是该证明所证明的定理。它可能是一个公理、一个子推导中的假设或一个中间引理。\n*   **结论：** 错误。\n\n**C. “最后一行”属性不能用有界($\\Delta_0$)公式表示...**\n该选项声称形式化“最后一行”属性需要一个 $\\Pi_2$ 条件。这是错误的。如对选项 A 的分析所示，该属性可用一个 $\\Delta_0$ 公式定义。对序列的所有扩张进行量化的想法与识别给定固定序列 $y$ 的最后一个元素无关。此外，它声称这种更高的复杂性对于可证性条件是必要的，这与事实恰恰相反。标准的证明要求 $\\mathrm{Prov}_T(x)$ 是 $\\Sigma_1$ 的。一个更复杂的谓词将使第三可证性条件的通常证明失效。\n*   **结论：** 错误。\n\n**D. 通过...$p$是证明的某一行...定义“最后一行”关系...**\n这个选项将该关系定义为 $\\exists i\\mathrm{len}(y)\\,\\big(p=\\mathrm{entry}(y,i)\\big)$，意味着 $p$ 是证明序列中出现的任何公式。这与选项 B 犯了同样的概念错误。虽然这会导出一个 $\\Sigma_1$ 可证性谓词，但该谓词不会表示定理性的正确概念。一个公式是可证的，意味着存在一个以它为结论的证明，而不仅仅是存在一个包含它的证明。这个错误的定义将不满足可证性条件；例如，肯定前件式 (D2) 的形式化将会失败。\n*   **结论：** 错误。", "answer": "$$\\boxed{A}$$", "id": "2971586"}, {"introduction": "希尔伯特-伯奈斯-勒布可推导性条件为可证性谓词的行为提供了一种抽象刻画，而这些条件又被可证性逻辑 GL 的公理完美地反映。本练习将这种对应关系具体化，要求你将一个 GL 中的形式证明逐步转化为算术中的形式推导。通过主动追踪模态公理和规则如何映射到可推导性条件，你将对为何 GL 被认为是“可证性的逻辑”获得一个具体而深刻的理解。[@problem_id:2971576]", "problem": "令 $GL$ 表示 Gödel–Löb 可证性逻辑 (GL)，这是一个正规模态逻辑，其公理化系统由所有命题重言式、由 $\\Box(\\varphi \\rightarrow \\psi) \\rightarrow (\\Box \\varphi \\rightarrow \\Box \\psi)$ 给出的模态公理模式 $K$、Löb 公理模式 $\\Box(\\Box \\varphi \\rightarrow \\varphi) \\rightarrow \\Box \\varphi$ 构成，并在分离规则和必然化规则下封闭。令 $T$ 为 Peano 算术的一个固定的、递归公理化的、相容的扩张，它承认一个标准的 $\\Sigma_{1}$ 可证性谓词 $\\operatorname{Prov}_{T}(x)$，且该谓词满足 Hilbert–Bernays–Löb 可证性条件：\n- $(D1)$ 如果 $T \\vdash \\varphi$，那么 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner)$。\n- $(D2)$ $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\rightarrow \\psi \\urcorner) \\rightarrow \\big(\\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\psi \\urcorner)\\big)$。\n- $(D3)$ $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urcorner) \\urcorner)$。\n\n固定一个算术解释 $\\langle \\cdot \\rangle$，它将命题变元映为封闭的算术语句，将布尔联结词以同态方式映射，并将模态算子通过 $\\langle \\Box \\chi \\rangle := \\operatorname{Prov}_{T}(\\ulcorner \\langle \\chi \\rangle \\urcorner)$ 进行映射。具体来说，固定两个任意的封闭算术语句 $\\alpha$ 和 $\\beta$，并作如下解释：$p \\mapsto \\alpha$，$q \\mapsto \\beta$。\n\n任务：\n1. 仅使用公理、分离规则和必然化规则，在 $GL$ 中给出模态公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 的一个有限推导。\n2. 在该算术解释下，追踪每一步推理，将其转化为 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urcorner) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urcorner)$ 的一个形式 $T$-推导，该推导仅从可证性条件 $(D1)$–$(D3)$ 和 $T$ 内部的命题推理出发。\n3. 令 $n_{1}$、$n_{2}$ 和 $n_{3}$ 分别为您在 $T$-推导中调用条件 $(D1)$、$(D2)$ 和 $(D3)$ 的次数。计算有序三元组 $(n_{1}, n_{2}, n_{3})$。\n\n将最终的有序三元组以行矩阵格式的单一表达式报告。无需四舍五入。", "solution": "该问题要求完成三项任务：在模态逻辑 $GL$ 中推导一个公式，将此推导翻译为算术理论 $T$ 中的一个形式证明，并统计在翻译后的证明中给定的可证性条件的使用次数。\n\n首先，对问题进行验证。Gödel-Löb 逻辑 $GL$、算术理论 $T$、可证性谓词 $\\operatorname{Prov}_{T}(x)$ 以及三个 Hilbert–Bernays–Löb 可证性条件（$(D1)$、$(D2)$、$(D3)$）的定义在数理逻辑领域是标准的且陈述正确。该问题是自洽的、有科学依据的、且定义明确的。任务的规定足够精确，可以得出唯一且可验证的解法。因此，该问题是有效的。\n\n解答将分三部分呈现，对应于三项任务。\n\n### 第一部分：在 $GL$ 中的推导\n\n目标是在逻辑 $GL$ 中为模态公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 提供一个有限推导。可用的推理规则是分离规则（从 $\\varphi$ 和 $\\varphi \\rightarrow \\psi$ 推断出 $\\psi$）和必然化规则（从 $\\vdash \\varphi$ 推断出 $\\vdash \\Box \\varphi$）。公理包括所有命题重言式、公理 $K: \\Box(\\varphi \\rightarrow \\psi) \\rightarrow (\\Box \\varphi \\rightarrow \\Box \\psi)$ 以及 Löb 公理 $L: \\Box(\\Box \\varphi \\rightarrow \\varphi) \\rightarrow \\Box \\varphi$。\n\n目标公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 是逻辑 $K$ 的一个定理，而 $K$ 是 $GL$ 的一个子逻辑。因此，我们不需要使用 Löb 公理。推导如下：\n\n1.  $p \\rightarrow (q \\rightarrow p)$\n    这是命题重言式的一个实例，因此它是 $GL$ 中的一条公理。\n\n2.  $\\Box(p \\rightarrow (q \\rightarrow p))$\n    这由第 (1) 行通过必然化规则得出。由于 $p \\rightarrow (q \\rightarrow p)$ 是一个定理，$\\Box(p \\rightarrow (q \\rightarrow p))$ 也是一个定理。\n\n3.  $\\Box(p \\rightarrow (q \\rightarrow p)) \\rightarrow (\\Box p \\rightarrow \\Box(q \\rightarrow p))$\n    这是公理模式 $K$ 的一个实例，即 $\\Box(A \\rightarrow B) \\rightarrow (\\Box A \\rightarrow \\Box B)$，其中代换为 $A := p$ 和 $B := q \\rightarrow p$。\n\n4.  $\\Box p \\rightarrow \\Box(q \\rightarrow p)$\n    这由第 (2) 和 (3) 行通过分离规则得出。\n\n至此完成了该公式在 $GL$ 中的推导。\n\n### 第二部分：算术翻译为 $T$-推导\n\n第二项任务是将上述推导翻译为理论 $T$ 内的一个形式证明。该解释将 $p$ 映为算术语句 $\\alpha$，$q$ 映为语句 $\\beta$，并将 $\\Box \\varphi$ 映为 $\\operatorname{Prov}_{T}(\\ulcorner \\langle \\varphi \\rangle \\urvenir)$。最终目标是推导出 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urvenir)$。唯一允许的工具是可证性条件 $(D1)$、$(D2)$、$(D3)$ 和 $T$ 内部的命题推理。\n\n我们逐步追踪 GL 的推导过程：\n\n1.  **GL 步骤 1：** 公理 $p \\rightarrow (q \\rightarrow p)$ 是一个命题重言式。\n    **$T$-推导步骤 1：** 其翻译 $\\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$ 也是一个命题重言式。由于 $T$ 是 Peano 算术的一个扩张，它能证明所有命题重言式的实例。\n    $$T \\vdash \\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$$\n    此步骤不调用任何可证性条件。\n\n2.  **GL 步骤 2：** 公式 $\\Box(p \\rightarrow (q \\rightarrow p))$ 通过必然化规则推导得出。\n    **$T$-推导步骤 2：** 必然化规则对应于可证性条件 $(D1)$。由于我们在上一步中已经确立了 $T \\vdash \\alpha \\rightarrow (\\beta \\rightarrow \\alpha)$，我们可以应用 $(D1)$：如果 $T \\vdash \\varphi$，那么 $T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urvenir)$。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urvenir)$$\n    此步骤构成对条件 $(D1)$ 的一次调用。\n\n3.  **GL 步骤 3：** 公式 $\\Box(p \\rightarrow (q \\rightarrow p)) \\rightarrow (\\Box p \\rightarrow \\Box(q \\rightarrow p))$ 是公理 $K$ 的一个实例。\n    **$T$-推导步骤 3：** 公理 $K$ 对应于可证性条件 $(D2)$：$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\rightarrow \\psi \\urvenir) \\rightarrow (\\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\psi \\urvenir))$。我们使用该模式的一个实例，其中 $\\varphi$ 是语句 $\\alpha$，$\\psi$ 是语句 $\\beta \\rightarrow \\alpha$。这给了我们一个 $T$ 的定理。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urvenir) \\rightarrow \\big(\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urvenir)\\big)$$\n    此步骤构成对条件 $(D2)$ 的一次调用。请注意，此推导不需要条件 $(D3)$，它对应于模态公理 $4$ ($\\Box\\varphi \\to \\Box\\Box\\varphi$)。\n\n4.  **GL 步骤 4：** 最终公式 $\\Box p \\rightarrow \\Box(q \\rightarrow p)$ 通过分离规则推导得出。\n    **$T$-推导步骤 4：** 我们在理论 $T$ 中应用分离规则。令 $A$ 为语句 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\rightarrow (\\beta \\rightarrow \\alpha) \\urvenir)$，令 $B$ 为语句 $\\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urvenir)$。从步骤 2，我们有 $T \\vdash A$。从步骤 3，我们有 $T \\vdash A \\rightarrow B$。通过分离规则，我们得出 $T \\vdash B$。\n    $$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\alpha \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\beta \\rightarrow \\alpha \\urvenir)$$\n    此步骤依赖于 $T$ 内部的命题推理，不调用任何可证性条件。\n\n### 第三部分：统计调用次数\n\n最后一项任务是计算有序三元组 $(n_{1}, n_{2}, n_{3})$，它表示在第二部分呈现的 $T$-推导中，条件 $(D1)$、$(D2)$ 和 $(D3)$ 被调用的次数。\n\n-   $n_{1}$：条件 $(D1)$ 在 $T$-推导的步骤 2 中被使用了一次，用于将重言式的可证性内在化。\n-   $n_{2}$：条件 $(D2)$ 在 $T$-推导的步骤 3 中被使用了一次，作为模态公理 $K$ 的算术对应物。\n-   $n_{3}$：条件 $(D3)$，$T \\vdash \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urvenir) \\rightarrow \\operatorname{Prov}_{T}(\\ulcorner \\operatorname{Prov}_{T}(\\ulcorner \\varphi \\urvenir) \\urvenir)$，在推导中完全没有被使用。\n\n因此，计数为 $n_{1} = 1$，$n_{2} = 1$ 和 $n_{3} = 0$。有序三元组是 $(1, 1, 0)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  0\n\\end{pmatrix}\n}\n$$", "id": "2971576"}, {"introduction": "模态逻辑与算术之间关系的巅峰之一，在于它们各自不动点定理之间的对应。对角引理是算术中自我指涉的引擎，而模态不动点引理在 GL 中扮演着类似的角色。这个高级练习将引导你探究后者在算术解释下如何产生前者的一个版本，从而揭示了两个系统之间深刻的结构对齐。这种联系不仅是一个巧合，它揭示了为什么模态逻辑是分析算术可证性的如此强大的工具。[@problem_id:2971593]", "problem": "设 $T$ 是一个一致的、递归公理化的理论，它扩展了罗宾逊算术 (Robinson Arithmetic)，并用一阶算术语言表述。其标准可证性谓词 $\\mathrm{Prov}_T(x)$ 在 $T$ 内部满足希尔伯特-伯奈斯-洛布 (Hilbert–Bernays–Löb) 可导性条件。设 $\\mathsf{GL}$ 表示哥德尔-洛布 (Gödel–Löb) 可证性逻辑（即通过在基本模态逻辑 $\\mathsf{K}$ 中加入洛布公理得到的正规模态逻辑）。考虑相对于 $T$ 的、将模态公式进行标准算术解释到算术中的方法，记作 $\\varphi \\mapsto \\varphi^{*}$，其定义如下：\n- 命题联结词映射到其算术对应物，\n- 对任意模态公式 $\\varphi$，使用条款 $\\,(\\Box \\varphi)^{*} \\equiv \\mathrm{Prov}_T(\\ulcorner \\varphi^{*} \\urcorner)\\,$。\n\n假设 $\\mathsf{GL}$ 中的模态不动点引理：如果 $A(p)$ 是一个只有一个命题变量 $p$ 的模态公式，并且 $p$ 的每次出现都在模态算子 $\\Box$ 的作用范围内，那么存在一个模态语句 $F$ 使得 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$。\n\n固定一个算术语言中的算術公式 $\\psi(x)$，其唯一的自由变量是 $x$，并假设 $\\psi(x)$ 中 $x$ 的每次自由出现都在某个形如 $\\mathrm{Prov}_T(t)$（其中 $t$ 是某个项）的子公式的作用范围内；换言之，$x$ 在 $\\psi(x)$ 中是 $\\mathrm{Prov}_T$-受限的。仅使用上述基本事实和定义，仔细推理在算術解释 $(\\cdot)^{*}$ 和 $\\mathrm{Prov}_T$ 的可导性条件下，模态不动点引理如何对应于 $T$ 内部关于 $\\mathrm{Prov}_T$ 的对角化原理。\n\n关于此对应关系，以下哪些陈述是正确的？\n\nA. 在将 $\\,\\Box \\varphi\\,$ 映射到 $\\,\\mathrm{Prov}_T(\\ulcorner \\varphi \\urcorner)\\,$ 的算术解释下，模态不动点引理产生了以下算术不动点：对于每个算术公式 $\\psi(x)$，只要其中 $x$ 的所有自由出现都是 $\\mathrm{Prov}_T$-受限的，就存在一个语句 $\\theta$ 使得 $\\,T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urcorner)\\,$。\n\nB. 上述对应关系不需要在 $T$ 内部使用希尔伯特-伯奈斯-洛布可导性条件；它仅在纯一阶逻辑中就成立。\n\nC. 只要 $T$ 是 $\\Sigma_1$-完备的，该对应关系就能无限制地为任意的 $\\psi(x)$（允许 $x$ 不受限地出现）得出完整的算术对角引理。\n\nD. 该对应关系的证明仅使用了 $T$ 的标准可证性谓词的存在性；不需要语法的算术化。\n\nE. 为了从模态不动点 $F$ 中提取出满足 $\\,T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urcorner)\\,$ 的算術不动点 $\\theta$，只要 $T$ 满足希尔伯特-伯奈斯-洛布可导性条件以保证 $\\mathsf{GL}$ 的算术解释是可靠的，就足够了；不需要索洛维 (Solovay) 关于 $\\mathsf{GL}$ 的算术完备性定理。\n\n选择所有适用选项。", "solution": "我们从所述的基本基础开始：将模态公式映射到算术语句的算术解释 $(\\cdot)^{*}$ 的定义，其中 $\\,(\\Box \\varphi)^{*} \\equiv \\mathrm{Prov}_T(\\ulcorner \\varphi^{*} \\urvenir)$；以及 $\\mathsf{GL}$ 中的模态不动点引理，该引理断言：对于任何模态公式 $A(p)$，若 $p$ 仅在 $\\Box$ 的作用范围内出现，则存在一个模态语句 $F$ 使得 $\\,\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$。我们还依赖于 $T$ 中的希尔伯特-伯奈斯-洛布可导性条件，这些条件确保了在解释 $(\\cdot)^{*}$ 下 $\\mathsf{GL}$ 的算术可靠性：只要 $\\,\\mathsf{GL} \\vdash \\varphi\\,$，我们就有 $\\,T \\vdash \\varphi^{*}$。\n\n我们将解释如何将一个 $\\mathrm{Prov}_T$-受限的算术公式 $\\psi(x)$ 转化为一个模态矩阵 $A(p)$，使得对于任何模态语句 $G$，$A(G)$ 的算术解释在 $T$ 内部与将 $G^{*}$ 的哥德尔数代入 $\\psi$ 的结果相一致。这种对 $\\psi$ 的“模态化”过程按 $\\psi$ 的结构归纳进行，如下所示。\n\n考虑算术语言的一个片段 $\\mathcal{L}_{\\mathrm{Prov}}(x)$，它由形如 $\\mathrm{Prov}_T(t)$ 的原子公式的布尔组合构成，其中 $t$ 是任何可能提及 $x$ 的算术项。我们假设 $x$ 仅在这样的 $\\mathrm{Prov}_T(\\cdot)$ 内部自由出现。定义一个翻译\n$$\n\\tau:\\mathcal{L}_{\\mathrm{Prov}}(x) \\to \\text{关于变量 }p\\text{ 的模态公式}\n$$\n通过递归进行：\n- $\\tau$ 与布尔联结词可交换：$\\tau(\\neg \\alpha)=\\neg \\tau(\\alpha)$，$\\tau(\\alpha \\wedge \\beta)=\\tau(\\alpha)\\wedge \\tau(\\beta)$，对于 $\\vee,\\rightarrow$ 也类似。\n- 对于原子公式，设置 $\\tau(\\mathrm{Prov}_T(t(x)))=\\Box\\,\\sigma_{t}(p)$，其中 $\\sigma_t(p)$ 是一个命题模态公式，其算术解释是通过在算术内部计算当 $x$ 被实例化为 $\\ulcorner G^{*}\\urcorner$ 的数码时项 $t$ 的值，然后将该值用作 $\\mathrm{Prov}_T$ 参数的哥德尔编码所得到的算术语句。具体来说，我们固定一个标准的公式原始递归编码和一个原始递归函数 $\\mathrm{sub}(\\cdot,\\cdot)$，使得 $\\mathrm{sub}(\\ulcorner \\chi(x)\\urvenir,\\ulcorner \\theta\\urvenir)=\\ulcorner \\chi(\\ulcorner \\theta\\urvenir)\\urvenir$，并且我们将 $t(x)$ 视为计算一个编码。模态原子 $\\sigma_t(p)$ 的选择要使得对于任何模态语句 $G$，我们有\n$$\n(\\sigma_t(G))^{*} \\;\\equiv\\; \\text{哥德尔编码为 } \\bigl(t(\\ulcorner G^{*}\\urvenir)\\bigr) \\text{ 的算术语句}，\n$$\n因此\n$$\n(\\Box\\,\\sigma_t(G))^{*} \\;\\equiv\\; \\mathrm{Prov}_T\\!\\left(\\ulcorner (\\sigma_t(G))^{*} \\urvenir\\right) \\;\\equiv\\; \\mathrm{Prov}_T\\!\\bigl(t(\\ulcorner G^{*}\\urvenir)\\bigr).\n$$\n\n这样的 $\\sigma_t(p)$ 的存在性源于语法的标准算术化以及编码和代入函数在算术中的可定义性：对于每个原始递归的 $t$，我们可以一致地为 $p$ 分配一个模态公式 $\\sigma_t(p)$，其算術解釋是哥德尔编码等于 $t(\\ulcorner p^{*}\\urvenir)$ 的唯一语句。此处算术化的使用是必不可少的。\n\n通过对 $\\psi$ 的结构进行归纳，可以得出对于每个模态语句 $G$，\n$$\n(\\tau(\\psi)(G))^{*} \\;\\leftrightarrow\\; \\psi(\\ulcorner G^{*}\\urvenir)\n$$\n在 $T$ 中是可证的。实际上，布尔步骤因 $(\\cdot)^{*}$ 对联结词的同态行为而直接成立，而原子步骤则通过 $\\sigma_t(p)$ 的构造来安排。\n\n现在，将 $\\mathsf{GL}$ 中的模态不动点引理应用于 $A(p):=\\tau(\\psi)(p)$。由于 $p$ 在 $A$ 中仅出现在 $\\Box$ 内部，我们得到一个模态语句 $F$ 满足\n$$\n\\mathsf{GL} \\vdash F \\leftrightarrow A(F) \\;=\\; \\tau(\\psi)(F).\n$$\n根据 $\\mathsf{GL}$ 在 $(\\cdot)^{*}$ 下的算术可靠性（这使用了 $T$ 中的希尔伯特-伯奈斯-洛布可导性条件），我们推断出\n$$\nT \\vdash F^{*} \\leftrightarrow (\\tau(\\psi)(F))^{*}.\n$$\n根据 $\\tau$ 的定义属性，\n$$\nT \\vdash (\\tau(\\psi)(F))^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urvenir).\n$$\n结合这些，我们得出结论\n$$\nT \\vdash F^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urvenir).\n$$\n令 $\\theta := F^{*}$ 正好产生了 $\\mathrm{Prov}_T$-受限的算术不动点。这就建立了所期望的对应关系。\n\n有了这个推导，我们来评估各个选项。\n\n选项 A。这正是我们所证明的：对于任何 $\\mathrm{Prov}_T$-受限的 $\\psi(x)$，存在一个语句 $\\theta$ 满足 $T \\vdash \\theta \\leftrightarrow \\psi(\\ulcorner \\theta \\urvenir)$。该构造使用了模态化 $\\tau$、用于获得 $F$ 的模态不动点引理，以及将 $F \\leftrightarrow \\tau(\\psi)(F)$ 转换到 $T$ 中的算术可靠性，随后进行了 $(\\tau(\\psi)(F))^{*} \\leftrightarrow \\psi(\\ulcorner F^{*}\\urvenir)$ 的等同。结论：正确。\n\n选项 B。$\\mathsf{GL}$ 相对于 $T$ 的 $\\mathrm{Prov}_T$ 的算术可靠性需要希尔伯特-伯奈斯-洛布可导性条件。特别是，洛布公理 $\\Box(\\Box p \\rightarrow p) \\rightarrow \\Box p$ 的可靠性即是洛布定理，其在 $T$ 中的证明使用了这些可导性条件。没有它们，一般不能从 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$ 推断出 $T \\vdash F^{*} \\leftrightarrow A(F)^{*}$。结论：不正确。\n\n选项 C。模态不动点引理仅保证了 $p$ 只在 $\\Box$ 下出现的模态矩阵 $A(p)$ 的不动点。因此，通过 $\\tau$-翻译，我们只对那些 $x$ 仅在 $\\mathrm{Prov}_T(\\cdot)$ 内部出现的 $\\psi(x)$ 获得算术不动点。$x$ 的任意不受限出现（例如，出现在与 $\\mathrm{Prov}_T$ 无关的原子算术公式中，如 $x=0$ 或 $x$ 出现在算术项中）无法在纯命题模态语言中模拟，因此超出了此对应关系的范围。针对任意 $\\psi(x)$ 的完整算术对角引理是一个独立的定理，其证明使用了一般的代入算术化，而不仅仅是 $\\mathsf{GL}$ 不动点。结论：不正确。\n\n选项 D。该构造关键性地使用了语法的算术化：我们需要公式的原始递归编码、代入函数的可定义性，以及为每个模态 $G$ 识别出作为 $\\mathrm{Prov}_T$ 参数出现的编码 $\\ulcorner G^{*}\\urvenir$ 的能力。此外，$\\mathrm{Prov}_T$ 本身的定义就是 $T$ 的證明謂詞的算術化。因此，算術化是不可或缺的。结论：不正确。\n\n选项 E。在将 $\\mathsf{GL} \\vdash F \\leftrightarrow A(F)$ 转换到 $T \\vdash F^{*} \\leftrightarrow A(F)^{*}$ 的过程中，只使用了 $\\mathsf{GL}$ 对于 $\\mathrm{Prov}_T$ 的算术可靠性。这种可靠性源于希尔伯特-伯奈斯-洛布可导性条件，而不需要索洛维 (Solovay) 的算术完备性（这是一个反方向的结论：如果一个模态公式在所有源于合适的 $T$ 的算术解释下都有效，那么它在 $\\mathsf{GL}$ 中是可证的）。因此，要获得不动点对应关系，并不需要索洛维完备性。结论：正确。\n\n因此，正确的陈述是 A 和 E。", "answer": "$$\\boxed{AE}$$", "id": "2971593"}]}