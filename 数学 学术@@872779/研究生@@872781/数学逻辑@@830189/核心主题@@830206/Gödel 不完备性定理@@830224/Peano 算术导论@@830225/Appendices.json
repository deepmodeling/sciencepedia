{"hands_on_practices": [{"introduction": "在我们能够对算术进行推理之前，我们必须首先掌握算术的形式语言。本练习着重于一个关键的句法区别：自由变量与约束变量。自由变量相当于数字的占位符，而约束变量则用于量化，掌握这个概念是理解任何逻辑公式结构的第一步，也是后续学习替换、量化等更复杂操作的基础[@problem_id:2974905]。", "problem": "考虑皮亚诺算术 (PA) 的标准一阶语言（记作 $L_{PA}$），其用于构造项的符号包括变量、常量符号 $0$、一元函数符号 $S$ 以及二元函数符号 $+$ 和 $\\cdot$。公式是由原子公式，通过使用二元谓词符号 $=$、命题联结词以及量词 $\\forall$ 和 $\\exists$ 构造而成的。从这些形成规则出发，给出函数的精确归纳定义，该函数将每个项 $t$ 映射到 $t$ 中出现的变量集合，并将每个公式 $\\varphi$ 映射到其自由变量集合 $\\mathsf{FV}(\\varphi)$。你的定义必须涵盖上述所有构造子（变量、$0$、$S$、$+$、$\\cdot$、$=$、命题联结词和量词），并对项和公式进行结构递归。然后，仅使用你的定义，计算公式 $\\mathsf{FV}(\\exists x\\,\\forall y\\,(x\\cdot z=y))$ 的自由变量集合。请用一个单一的封闭形式符号表达式（一个以枚举形式书写的集合）来表示你的最终答案。[@problem_id:123]", "solution": "该问题是有效的，因为它是数理逻辑领域内一个良定的、有科学依据的客观问题。它要求在皮亚诺算术语言中，为项中的变量集合和公式中的自由变量集合给出标准的归纳定义，然后将这些定义应用于一个特定的公式。\n\n令 $L_{PA}$ 为皮亚诺算术的一阶语言。$L_{PA}$ 的所有项的集合和所有公式的集合是通过结构归纳法定义的。因此，我们可以通过结构递归在这些集合上定义函数。\n\n首先，我们定义函数 $\\mathsf{Var}$，它将每个项 $t$ 映射到其中出现的变量集合，记为 $\\mathsf{Var}(t)$。该定义通过对项 $t$ 的结构进行递归。\n\n1.  **基础情况（变量）：** 如果 $t$ 是一个变量，例如 $x$，那么 $\\mathsf{Var}(x) = \\{x\\}$。\n2.  **基础情况（常量）：** 如果 $t$ 是常量符号 $0$，那么 $\\mathsf{Var}(0) = \\emptyset$。\n3.  **归纳步骤（后继）：** 如果 $t$ 的形式为 $S(t')$，其中 $t'$ 是一个项，那么 $\\mathsf{Var}(S(t')) = \\mathsf{Var}(t')$。\n4.  **归纳步骤（加法）：** 如果 $t$ 的形式为 $(t_1 + t_2)$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{Var}(t_1 + t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n5.  **归纳步骤（乘法）：** 如果 $t$ 的形式为 $(t_1 \\cdot t_2)$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{Var}(t_1 \\cdot t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n\n接下来，我们定义函数 $\\mathsf{FV}$，它将每个公式 $\\varphi$ 映射到其自由变量的集合，记为 $\\mathsf{FV}(\\varphi)$。该定义通过对公式 $\\varphi$ 的结构进行递归。命题联结词的定义是为功能完备集 $\\{\\neg, \\land\\}$ 给出的；其他联结词如 $\\lor$、$\\to$ 和 $\\leftrightarrow$ 的定义，基于它们与 $\\neg$ 和 $\\land$ 的关系，遵循类似的模式。\n\n1.  **基础情况（原子公式）：** 如果 $\\varphi$ 的形式为 $t_1 = t_2$，其中 $t_1$ 和 $t_2$ 是项，那么 $\\mathsf{FV}(t_1 = t_2) = \\mathsf{Var}(t_1) \\cup \\mathsf{Var}(t_2)$。\n2.  **归纳步骤（否定）：** 如果 $\\varphi$ 的形式为 $\\neg\\psi$，其中 $\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\neg\\psi) = \\mathsf{FV}(\\psi)$。\n3.  **归纳步骤（合取）：** 如果 $\\varphi$ 的形式为 $(\\psi_1 \\land \\psi_2)$，其中 $\\psi_1$ 和 $\\psi_2$ 是公式，那么 $\\mathsf{FV}(\\psi_1 \\land \\psi_2) = \\mathsf{FV}(\\psi_1) \\cup \\mathsf{FV}(\\psi_2)$。\n4.  **归纳步骤（存在量词）：** 如果 $\\varphi$ 的形式为 $\\exists x\\,\\psi$，其中 $x$ 是一个变量且 $\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\exists x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\}$。\n5.  **归纳步骤（全称量词）：** 如果 $\\varphi$ 的形式为 $\\forall x\\,\\psi$，其中 $x$ 是一个变量且 $\\psi$ 是一个公式，那么 $\\mathsf{FV}(\\forall x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\}$。\n\n现在，我们使用这些定义来计算公式 $\\exists x\\,\\forall y\\,(x\\cdot z=y)$ 的自由变量集合。我们从公式最内层的组成部分开始向外分析其结构。\n\n设给定公式为 $\\varphi = \\exists x\\,\\forall y\\,(x\\cdot z=y)$。\n设子公式 $\\forall y\\,(x\\cdot z=y)$ 记为 $\\psi$。\n设原子子公式 $x\\cdot z=y$ 记为 $\\chi$。\n\n**步骤 1：计算 $\\mathsf{FV}(\\chi)$**\n公式 $\\chi$ 是一个形如 $t_1 = t_2$ 的原子公式，其中 $t_1$ 是 $x \\cdot z$，$t_2$ 是 $y$。\n根据 $\\mathsf{FV}$ 的定义 (1)，我们有：\n$$ \\mathsf{FV}(x \\cdot z=y) = \\mathsf{Var}(x \\cdot z) \\cup \\mathsf{Var}(y) $$\n我们首先计算项 $x \\cdot z$ 和 $y$ 的 $\\mathsf{Var}$ 集合。\n- 使用 $\\mathsf{Var}$ 的定义 (5)：$\\mathsf{Var}(x \\cdot z) = \\mathsf{Var}(x) \\cup \\mathsf{Var}(z)$。\n- 使用 $\\mathsf{Var}$ 的定义 (1)：$\\mathsf{Var}(x) = \\{x\\}$ 且 $\\mathsf{Var}(z) = \\{z\\}$。\n- 因此，$\\mathsf{Var}(x \\cdot z) = \\{x\\} \\cup \\{z\\} = \\{x, z\\}$。\n- 再次使用 $\\mathsf{Var}$ 的定义 (1)：$\\mathsf{Var}(y) = \\{y\\}$。\n\n将这些结果代回到 $\\mathsf{FV}(\\chi)$ 的表达式中：\n$$ \\mathsf{FV}(\\chi) = \\mathsf{FV}(x \\cdot z=y) = \\{x, z\\} \\cup \\{y\\} = \\{x, y, z\\} $$\n\n**步骤 2：计算 $\\mathsf{FV}(\\psi)$**\n公式 $\\psi$ 是 $\\forall y\\,\\chi$。其形式为 $\\forall y\\,\\dots$，其中 $y$ 是被量化的变量。\n根据 $\\mathsf{FV}$ 的定义 (5)：\n$$ \\mathsf{FV}(\\psi) = \\mathsf{FV}(\\forall y\\,\\chi) = \\mathsf{FV}(\\chi) \\setminus \\{y\\} $$\n使用步骤 1 的结果 $\\mathsf{FV}(\\chi) = \\{x, y, z\\}$：\n$$ \\mathsf{FV}(\\psi) = \\{x, y, z\\} \\setminus \\{y\\} = \\{x, z\\} $$\n\n**步骤 3：计算 $\\mathsf{FV}(\\varphi)$**\n公式 $\\varphi$ 是 $\\exists x\\,\\psi$。其形式为 $\\exists x\\,\\dots$，其中 $x$ 是被量化的变量。\n根据 $\\mathsf{FV}$ 的定义 (4)：\n$$ \\mathsf{FV}(\\varphi) = \\mathsf{FV}(\\exists x\\,\\psi) = \\mathsf{FV}(\\psi) \\setminus \\{x\\} $$\n使用步骤 2 的结果 $\\mathsf{FV}(\\psi) = \\{x, z\\}$：\n$$ \\mathsf{FV}(\\varphi) = \\{x, z\\} \\setminus \\{x\\} = \\{z\\} $$\n\n因此，公式 $\\exists x\\,\\forall y\\,(x\\cdot z=y)$ 中的自由变量集合是 $\\{z\\}$。变量 $z$ 是自由的，因为它不被任何量词所约束。变量 $y$ 被全称量词 $\\forall y$ 约束，变量 $x$ 被存在量词 $\\exists x$ 约束。", "answer": "$$ \\boxed{ \\{z\\} } $$", "id": "2974905"}, {"introduction": "掌握了句法之后，下一步是将其与预期意义——自然数的世界——联系起来。本练习通过证明语言中每个不含变量的表达式（即封闭项）都对应于标准模型中的一个唯一自然数，从而在抽象符号和具体数值之间架起了一座桥梁。这是一个语义学的基础练习，它揭示了我们的形式语言是如何“谈论”数字的[@problem_id:2974946]。", "problem": "设 $\\mathcal{L}_{\\mathrm{PA}}$ 为皮亚诺算术 (PA) 的一阶语言，其包含常数符号 $0$、一元函数符号 $S$ 以及二元函数符号 $+$ 和 $\\times$。设 $\\mathcal{N}$ 表示标准模型，其论域为 $\\mathbb{N}$，并将 $0$ 解释为 $0$，$S$ 解释为后继函数 $n \\mapsto n+1$，$+$ 解释为 $\\mathbb{N}$ 上的普通加法，$\\times$ 解释为 $\\mathbb{N}$ 上的普通乘法。如果一个项 $t$ 不包含任何变量，则称其为闭项。对于每个自然数 $n \\in \\mathbb{N}$，将数符 $\\overline{n}$ 定义为将 $S$ 连续应用于 $0$ 共 $n$ 次所得到的 $\\mathcal{L}_{\\mathrm{PA}}$-项，即 $\\overline{0} := 0$ 且 $\\overline{n+1} := S(\\overline{n})$。\n\n仅使用用于解释一阶结构中项的标准语义子句以及 $\\mathcal{L}_{\\mathrm{PA}}$ 中项的归纳构成，完成以下任务：\n- 证明：如果 $t$ 是一个闭 $\\mathcal{L}_{\\mathrm{PA}}$-项，则在标准模型 $\\mathcal{N}$ 中存在唯一的 $n \\in \\mathbb{N}$，使得 $t$ 和 $\\overline{n}$ 指代 $\\mathbb{N}$ 中的同一个元素。换句话说，每个闭项在 $\\mathcal{N}$ 中都指代一个数符。\n- 计算特定闭项 $S(S(0)+S(0))$ 在 $\\mathcal{N}$ 中的指代。\n\n最终答案以单个整数形式给出（无单位，不四舍五入）。", "solution": "问题陈述在形式上是有效的。它是一个适定的问题，在数理逻辑中有坚实的科学基础，并且所有术语都得到了精确定义。我们将按问题的两个部分进行：证明和计算。\n\n**第一部分：证明**\n\n我们要证明，对于任何闭 $\\mathcal{L}_{\\mathrm{PA}}$-项 $t$，其在标准模型 $\\mathcal{N}$ 中的解释（记作 $t^{\\mathcal{N}}$）等于一个唯一的自然数 $n \\in \\mathbb{N}$。这等价于证明存在唯一的 $n \\in \\mathbb{N}$ 使得 $t^{\\mathcal{N}} = \\overline{n}^{\\mathcal{N}}$，因为数符 $\\overline{n}$ 在标准模型 $\\mathcal{N}$ 中的解释就是数 $n$ 本身（即 $\\overline{n}^{\\mathcal{N}} = n$）。\n\n证明将对 $\\mathcal{L}_{\\mathrm{PA}}$ 语言中闭项的构成进行结构归纳。$\\mathcal{L}_{\\mathrm{PA}}$ 中的项递归定义如下：\n1.  常数符号 $0$ 是一个项。任何变量 $v_i$ 是一个项。\n2.  如果 $t_1$ 是一个项，那么 $S(t_1)$ 也是一个项。\n3.  如果 $t_1$ 和 $t_2$ 是项，那么 $(t_1+t_2)$ 和 $(t_1 \\times t_2)$ 也是项。\n\n由于我们只关心*闭*项，因此在我们的归纳基础中不考虑变量。\n\n一个项 $t$ 在结构 $\\mathcal{N}$ 中的解释，记作 $t^{\\mathcal{N}}$，由以下语义子句定义：\n-   $0^{\\mathcal{N}} = 0 \\in \\mathbb{N}$。\n-   $(S(t_1))^{\\mathcal{N}} = S^{\\mathcal{N}}(t_1^{\\mathcal{N}})$，其中 $S^{\\mathcal{N}}$ 是后继函数 $n \\mapsto n+1$。\n-   $(t_1+t_2)^{\\mathcal{N}} = t_1^{\\mathcal{N}} +^{\\mathcal{N}} t_2^{\\mathcal{N}}$，其中 $+^{\\mathcal{N}}$ 是 $\\mathbb{N}$ 上的标准加法。\n-   $(t_1 \\times t_2)^{\\mathcal{N}} = t_1^{\\mathcal{N}} \\times^{\\mathcal{N}} t_2^{\\mathcal{N}}$，其中 $\\times^{\\mathcal{N}}$ 是 $\\mathbb{N}$ 上的标准乘法。\n\n设 $P(t)$ 为性质“存在唯一的 $n \\in \\mathbb{N}$ 使得 $t^{\\mathcal{N}} = n$”。我们证明 $P(t)$ 对所有闭 $\\mathcal{L}_{\\mathrm{PA}}$-项 $t$ 成立。\n\n**基本情形：** 最简单的闭项是常数符号 $0$。\n设项 $t$ 为 $0$。根据语义规则，其解释为 $t^{\\mathcal{N}} = 0^{\\mathcal{N}} = 0$。在这里，自然数是 $n=0$。这个数是唯一的。因此，$P(0)$ 成立。\n\n**归纳步骤：** 我们假设对于某些闭项 $t_1$ 和 $t_2$，性质 $P$ 成立。即，存在唯一的自然数 $n_1, n_2 \\in \\mathbb{N}$ 使得 $t_1^{\\mathcal{N}} = n_1$ 且 $t_2^{\\mathcal{N}} = n_2$。我们必须证明对于由 $t_1$ 和 $t_2$ 构造的项，$P$ 也成立。\n\n**情况1：后继。** 设 $t = S(t_1)$。\n根据归纳假设，$t_1^{\\mathcal{N}} = n_1$，其中 $n_1 \\in \\mathbb{N}$ 是唯一的。\n使用函数符号 $S$ 的语义子句：\n$$t^{\\mathcal{N}} = (S(t_1))^{\\mathcal{N}} = S^{\\mathcal{N}}(t_1^{\\mathcal{N}}) = S^{\\mathcal{N}}(n_1)$$\n鉴于 $S^{\\mathcal{N}}$ 是函数 $m \\mapsto m+1$，我们有：\n$$t^{\\mathcal{N}} = n_1 + 1$$\n由于 $\\mathbb{N}$ 在后继运算下是封闭的，$n_1+1$ 是一个自然数。令 $n = n_1+1$。$n$ 的唯一性来自于 $n_1$ 的唯一性以及后继函数是单射函数这一事实。因此，$P(S(t_1))$ 成立。\n\n**情况2：加法。** 设 $t = (t_1+t_2)$。\n根据归纳假设，$t_1^{\\mathcal{N}} = n_1$ 且 $t_2^{\\mathcal{N}} = n_2$，其中 $n_1, n_2 \\in \\mathbb{N}$ 是唯一的。\n使用函数符号 $+$ 的语义子句：\n$$t^{\\mathcal{N}} = (t_1+t_2)^{\\mathcal{N}} = t_1^{\\mathcal{N}} +^{\\mathcal{N}} t_2^{\\mathcal{N}} = n_1 + n_2$$\n由于 $\\mathbb{N}$ 在加法下是封闭的，和 $n_1+n_2$ 是一个自然数。令 $n = n_1+n_2$。$n$ 的唯一性来自于 $n_1$ 和 $n_2$ 的唯一性以及加法是一个良定义函数这一事实。因此，$P(t_1+t_2)$ 成立。\n\n**情况3：乘法。** 设 $t = (t_1 \\times t_2)$。\n根据归纳假设，$t_1^{\\mathcal{N}} = n_1$ 且 $t_2^{\\mathcal{N}} = n_2$，其中 $n_1, n_2 \\in \\mathbb{N}$ 是唯一的。\n使用函数符号 $\\times$ 的语义子句：\n$$t^{\\mathcal{N}} = (t_1 \\times t_2)^{\\mathcal{N}} = t_1^{\\mathcal{N}} \\times^{\\mathcal{N}} t_2^{\\mathcal{N}} = n_1 \\times n_2$$\n由于 $\\mathbb{N}$ 在乘法下是封闭的，积 $n_1 \\times n_2$ 是一个自然数。令 $n = n_1 \\times n_2$。$n$ 的唯一性来自于 $n_1$ 和 $n_2$ 的唯一性以及乘法是一个良定义函数这一事实。因此，$P(t_1 \\times t_2)$ 成立。\n\n根据结构归纳原理，性质 $P(t)$ 对所有闭 $\\mathcal{L}_{\\mathrm{PA}}$-项 $t$ 成立。证明完毕。\n\n**第二部分：计算**\n\n我们需要计算闭项 $t = S(S(0)+S(0))$ 在 $\\mathcal{N}$ 中的指代。我们从最内层的项开始，递归地应用语义子句向外计算。\n\n1.  首先，我们找到常数符号 $0$ 的指代：\n    $$0^{\\mathcal{N}} = 0$$\n\n2.  接下来，我们找到项 $S(0)$ 的指代：\n    $$(S(0))^{\\mathcal{N}} = S^{\\mathcal{N}}(0^{\\mathcal{N}}) = S^{\\mathcal{N}}(0) = 0+1 = 1$$\n\n3.  现在，我们可以计算和 $S(0)+S(0)$：\n    $$(S(0)+S(0))^{\\mathcal{N}} = (S(0))^{\\mathcal{N}} +^{\\mathcal{N}} (S(0))^{\\mathcal{N}} = 1 + 1 = 2$$\n\n4.  最后，我们将最外层的后继函数 $S$ 应用于上一步的结果：\n    $$(S(S(0)+S(0)))^{\\mathcal{N}} = S^{\\mathcal{N}}((S(0)+S(0))^{\\mathcal{N}}) = S^{\\mathcal{N}}(2) = 2+1 = 3$$\n\n项 $S(S(0)+S(0))$ 在标准模型 $\\mathcal{N}$ 中的指代是自然数 $3$。这对应于数符 $\\overline{3}$，即项 $S(S(S(0)))$。", "answer": "$$\\boxed{3}$$", "id": "2974946"}, {"introduction": "我们在构建公理时，心中想的是标准的自然数，但我们的形式系统是否唯一地捕捉了它们？这个高级练习将运用逻辑学中最强大的工具之一——紧致性定理，来揭示一个惊人的事实：任何拥有一阶算术标准模型的公理化系统，也必然存在包含无穷大数的“非标准”模型。这个练习展示了一阶逻辑的表达局限性，并为我们打开了通往模型论这个丰富领域的大门[@problem_id:2974931]。", "problem": "设 $Q$ 表示一阶语言 $L = \\{0, S, +, \\times, \\leq\\}$ 中的罗宾逊算术，并设 $\\overline{n}$ 表示 $n \\in \\mathbb{N}$ 的常规数符。$Q$ 的标准模型是 $\\mathbb{N}$ 及其常规解释。在一阶逻辑中进行研究，其中紧致性定理和勒文海姆–斯科伦定理是可用的基本事实。考虑 $Q$ 是否有非标准模型的问题，以及紧致性在确定其存在性中的作用。\n\n选择所有正确的陈述。\n\nA. 以下紧致性论证是有效的：用一个新的常数符号 $c$ 扩展 $L$，并将语句集 $\\Sigma = \\{\\overline{n}  c : n \\in \\mathbb{N}\\}$ 添加到 $Q$ 中。通过将 $c$ 解释为一个足够大的标准数，可以在 $\\mathbb{N}$ 中满足 $Q \\cup \\Sigma$ 的每个有限子集。根据紧致性定理，$Q \\cup \\Sigma$ 有一个模型；其到 $L$ 的归约是 $Q$ 的一个非标准模型。\n\nB. 紧致性定理不能应用于 $Q$ 来获得非标准模型，因为 $Q$ 是不完备的，并且缺乏皮亚诺算术（PA）的归纳模式。\n\nC. 存在 $Q$ 的可数非标准模型。\n\nD. 任何包含一个元素 $c$（使得对于所有 $n \\in \\mathbb{N}$ 都有 $\\overline{n}  c$）的 $Q$ 的模型都必须满足完全的一阶归纳模式。\n\nE. 无限集 $\\Sigma = \\{\\overline{n}  c : n \\in \\mathbb{N}\\}$ 可以被替换为单个语句 $\\forall x\\,(x  c)$，以获得相同的基于紧致性的结论，即 $Q$ 有一个非标准模型。", "solution": "问题陈述描述了数理逻辑中关于算术非标准模型存在性的一个标准场景。它介绍了罗宾逊算术（$Q$）、其语言（$L$）、标准模型（$\\mathbb{N}$），并引用了一阶逻辑的基本定理，如紧致性定理和勒文海姆–斯科伦定理。问题设定在模型论领域内是一致的、良定的，并且具有科学依据。因此，这是一个有效的问题。\n\n我们接下来分析每个陈述。\n\nA. 以下紧致性论证是有效的：用一个新的常数符号 $c$ 扩展 $L$，并将语句集 $\\Sigma = \\{\\overline{n}  c : n \\in \\mathbb{N}\\}$ 添加到 $Q$ 中。通过将 $c$ 解释为一个足够大的标准数，可以在 $\\mathbb{N}$ 中满足 $Q \\cup \\Sigma$ 的每个有限子集。根据紧致性定理，$Q \\cup \\Sigma$ 有一个模型；其到 $L$ 的归约是 $Q$ 的一个非标准模型。\n\n这个陈述描述了证明算术非标准模型存在的经典紧致性论证。让我们逐步验证其有效性。\n1.  设 $T = Q \\cup \\Sigma$ 是扩展语言 $L' = L \\cup \\{c\\}$ 中的一个理论。这里，$Q$ 是罗宾逊算术的公理集，$\\Sigma = \\{\\overline{0}  c, \\overline{1}  c, \\overline{2}  c, \\dots\\}$。\n2.  要应用紧致性定理，我们必须证明 $T$ 的每个有限子集都有一个模型。设 $\\Delta$ 是 $T$ 的任意有限子集。$\\Delta$ 将包含 $Q$ 的（有限）公理以及来自 $\\Sigma$ 的一个有限语句集合，例如 $\\{\\overline{n_1}  c, \\overline{n_2}  c, \\dots, \\overline{n_k}  c\\}$。\n3.  设 $N = \\max\\{n_1, n_2, \\dots, n_k\\} + 1$。我们可以使用算术的标准模型 $\\mathbb{N}$ 为 $\\Delta$ 构造一个模型。我们像往常一样在 $\\mathbb{N}$ 中解释 $L$ 的符号。我们将新常数 $c$ 解释为标准自然数 $N$。\n4.  在这种解释下，$Q$ 的公理得到满足，因为 $\\mathbb{N}$ 是 $Q$ 的一个模型。语句 $\\overline{n_i}  c$ 变为陈述 $n_i  N$，根据我们对 $N$ 的选择，这对所有 $i=1, \\dots, k$ 都为真。因此，$\\Delta$ 有一个模型。\n5.  因为 $T$ 的每个有限子集都有模型，所以紧致性定理保证整个集合 $T$ 有一个模型，我们记为 $\\mathcal{M}$。\n6.  在 $\\mathcal{M}$ 中，$T$ 的所有语句都为真。特别是，$\\mathcal{M} \\models Q$ 且对于所有 $n \\in \\mathbb{N}$ 都有 $\\mathcal{M} \\models \\overline{n}  c$。这意味着解释 $c$ 的元素，我们称之为 $c^{\\mathcal{M}}$，大于任何解释标准数符 $\\overline{n}$ 的元素。\n7.  $\\mathcal{M}$ 到语言 $L$ 的归约是 $Q$ 的一个模型。这个模型包含元素集 $\\{\\overline{0}^{\\mathcal{M}}, \\overline{1}^{\\mathcal{M}}, \\overline{2}^{\\mathcal{M}}, \\dots\\}$，它构成了一个与 $\\mathbb{N}$ 同构的初始段。然而，它还包含元素 $c^{\\mathcal{M}}$，该元素不在这个初始段中。因此，该模型与 $\\mathbb{N}$ 不同构，是 $Q$ 的一个非标准模型。\n这个论证是完全正确的。\n结论：**正确**。\n\nB. 紧致性定理不能应用于 $Q$ 来获得非标准模型，因为 $Q$ 是不完备的，并且缺乏皮亚诺算术（PA）的归纳模式。\n\n紧致性定理是一阶逻辑的一个基本性质。它指出，一个语句集有模型当且仅当它的每个有限子集都有模型。该定理的适用性仅取决于所使用的逻辑是一阶逻辑，而不取决于所讨论的特定理论的性质（如完备性、可判定性或是否包含像归纳这样的特定公理）。正如在选项A的分析中所展示的，该定理正是用于为像 $Q$（以及PA）这样的理论建立非标准模型存在性的工具。$Q$ 相对于PA的弱点并不妨碍使用紧致性定理。\n结论：**错误**。\n\nC. 存在 $Q$ 的可数非标准模型。\n\n选项A中的论证建立了一个非标准模型 $\\mathcal{M}$ 的存在性。语言 $L' = L \\cup \\{c\\}$ 是可数的。公理集 $T = Q \\cup \\Sigma$ 也是可数的，因为 $Q$ 是有限的，而 $\\Sigma$ 是可数无限的。因此，$T$ 是一个可数理论。由紧致性定理保证其存在的模型 $\\mathcal{M}$ 可以具有任何无限基数。然而，向下勒文海姆–斯科伦定理指出，如果一个一阶语言中的可数理论有一个无限模型，那么它就有一个可数的无限模型。\n由于 $T$ 有一个模型（$\\mathcal{M}$），它必定有一个可数模型，记为 $\\mathcal{M}_{coun}$。这个模型 $\\mathcal{M}_{coun}$ 满足 $T$ 中的所有公理，这意味着它是 $Q$ 的一个模型，其中包含一个元素 $c^{\\mathcal{M}_{coun}}$，该元素比所有标准自然数都大。因此，$\\mathcal{M}_{coun}$ 是 $Q$ 的一个可数非标准模型。\n结论：**正确**。\n\nD. 任何包含一个元素 $c$（使得对于所有 $n \\in \\mathbb{N}$ 都有 $\\overline{n}  c$）的 $Q$ 的模型都必须满足完全的一阶归纳模式。\n\n这个陈述声称 $Q$ 的任何非标准模型也是皮亚诺算术（PA）的模型，因为PA本质上是 $Q$ 加上一阶归纳模式。这是错误的。$Q$ 是一个比PA严格更弱的理论。有些在PA中可证的陈述在 $Q$ 中是不可证的。事实上，归纳模式本身就存在一些实例是无法从 $Q$ 的公理中证明的。\n设 $\\psi$ 是一个在 $Q$ 中不可证的归纳模式实例。那么理论 $Q \\cup \\{\\neg\\psi\\}$ 是一致的。由于这个理论是一致的，根据完备性定理，它有一个模型 $\\mathcal{M'}$。这个模型 $\\mathcal{M'}$ 满足 $Q$，但未能满足归纳模式的一个实例，所以它不是PA的模型。\n$\\mathcal{M'}$ 会是标准模型 $\\mathbb{N}$ 吗？不会，因为 $\\mathbb{N}$ 是PA的模型，因此满足所有归纳模式的实例，包括 $\\psi$。既然 $\\mathcal{M'} \\neq \\mathbb{N}$，那么 $\\mathcal{M'}$ 必须是 $Q$ 的一个非标准模型。\n因此，$\\mathcal{M'}$ 是 $Q$ 的一个非标准模型，它不满足完全的一阶归纳模式。这为该陈述提供了一个直接的反例。\n结论：**错误**。\n\nE. 无限集 $\\Sigma = \\{\\overline{n}  c : n \\in \\mathbb{N}\\}$ 可以被替换为单个语句 $\\forall x\\,(x  c)$，以获得相同的基于紧致性的结论，即 $Q$ 有一个非标准模型。\n\n这个建议是构建理论 $T' = Q \\cup \\{\\forall x\\,(x  c)\\}$。我们来分析 $T'$ 的一致性。假设 $T'$ 有一个模型 $\\mathcal{M}$。那么 $\\mathcal{M} \\models Q$ 且 $\\mathcal{M} \\models \\forall x\\,(x  c)$。语句 $\\forall x\\,(x  c)$ 断言，对于 $\\mathcal{M}$ 论域中的每个元素 $a$，关系 $a  c$ 都成立。由于这必须对*所有*元素都成立，它也必须对解释 $c$ 本身的元素成立。也就是说，模型 $\\mathcal{M}$ 必须满足 $c  c$。然而，$Q$ 的公理足以证明小于关系的非自反性，即 $Q \\vdash \\forall z \\, \\neg(z  z)$。定义 $x  y$ 是 $x \\leq y \\land x \\neq y$ 的简写。因此，$z  z$ 将意味着 $z \\leq z \\land z \\neq z$，这是一个矛盾。因此，理论 $T'$ 是不一致的，没有任何模型。这个方法不能用来证明非标准模型存在。\n结论：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "2974931"}]}