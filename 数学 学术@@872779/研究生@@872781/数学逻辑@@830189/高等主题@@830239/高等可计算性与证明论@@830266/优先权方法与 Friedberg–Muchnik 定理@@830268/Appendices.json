{"hands_on_practices": [{"introduction": "优先权方法充满了阶段、需求和限制等抽象概念。第一个练习通过引导您逐步具体地模拟一个简化的 Friedberg-Muchnik 构造，将这些概念带入现实。通过手动追踪集合 $A$ 和 $B$ 的变化，您将直接观察到高优先权需求如何施加限制，以及低优先权需求如何被“伤害”，从而巩固您对核心机制的理解 [@problem_id:2986940]。", "problem": "考虑经典的 Friedberg–Muchnik 构造，该构造用于生成两个不可比较的递归可枚举 (r.e.) 集合。我们只关注两个最低优先级的对角化需求 $R_{0}^{A}$ 和 $R_{0}^{B}$。对于本题，固定一个具体的图灵泛函枚举 $\\left(\\Phi_{e}\\right)_{e \\in \\mathbb{N}}$ 如下，其中 $\\Phi_{e}^{X}$ 表示以谕示 $X$ 进行计算的第 $e$ 个部分泛函：\n\n1. $\\Phi_{0}^{X}(y)$: 在输入为 $y$ 时，查询 $X(0), X(1), \\ldots, X(y)$ 并输出 $X(y)$。其用度为 $u_{0}(y) = y$。\n2. $\\Phi_{1}^{X}(y)$: 在输入为 $y$ 时，查询 $X(0), X(1), \\ldots, X(y)$ 并输出 $\\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$。其用度为 $u_{1}(y) = y$。\n\n在对角化需求中，$R_{0}^{B}$ 试图确保 $\\Phi_{0}^{B} \\neq A$（特征函数的逐点不等），而 $R_{0}^{A}$ 试图确保 $\\Phi_{1}^{A} \\neq B$。为了使阶段模拟具体化，并揭示约束和伤害的机制，我们假设 $R_{0}^{B}$ 和 $R_{0}^{A}$ 都旨在通过在无穷多个输入上强制产生分歧来满足其需求的更强版本，在其每个阶段选择大于当前已知约束的最小的未使用见证元。\n\n采用以下阶段安排和优先级规则：\n\n- 优先级顺序：$R_{0}^{B} \\succ R_{0}^{A}$。\n- 阶段 $s \\in \\mathbb{N}$ 按需求轮流进行：如果 $s$ 是偶数，则为 $R_{0}^{B}$ 行动；如果 $s$ 是奇数，则为 $R_{0}^{A}$ 行动。\n- 在其阶段，$R_{0}^{B}$ 选择 $R_{0}^{B}$ 尚未使用的最小的未使用见证元 $y$，并试图通过在必要时将元素枚举进 $A(y)$ 来满足 $\\Phi_{0}^{B}(y) \\neq A(y)$。然后，它将其对 $B$ 的约束设置或更新为 $r_{0}^{B} := \\max\\{r_{0}^{B}, u_{0}(y)\\}$。\n- 在其阶段，$R_{0}^{A}$ 选择严格大于当前约束 $r_{0}^{B}$ 的最小的未使用见证元 $y$，并试图通过在必要时将元素枚举进 $B(y)$ 来满足 $\\Phi_{1}^{A}(y) \\neq B(y)$。然后，它将其对 $A$ 的约束设置或更新为 $r_{0}^{A} := \\max\\{r_{0}^{A}, u_{1}(y)\\}$。\n- 低优先级的行动必须尊重高优先级的约束：$R_{0}^{A}$ 绝不将元素枚举进 $B(z)$（对于 $z \\leq r_{0}^{B}$）。同样，任何改变 $A(z)$（其中 $z \\leq r_{0}^{A}$）的行动都构成对 $R_{0}^{A}$ 当前计算的一次伤害；任何改变 $B(z)$（其中 $z \\leq r_{0}^{B}$）的行动都会构成对 $R_{0}^{B}$ 当前计算的一次伤害。对于这个双需求模拟，只有 $R_{0}^{B}$ 的行动才能伤害 $R_{0}^{A}$，因为 $R_{0}^{B}$ 具有更高的优先级。\n\n在阶段 $s = 0$ 初始化，设 $A = \\emptyset$，$B = \\emptyset$，$r_{0}^{B} = -1$ 以及 $r_{0}^{A} = -1$。对于阶段 $s = 0, 1, 2, 3, 4, 5$，完全按照上述规定执行构造，追踪计算、用度、约束以及是否发生伤害。\n\n问题：设 $I_{0}^{A}$ 是到阶段 $s = 5$ 结束时 $R_{0}^{A}$ 所受伤害的总次数，设 $I_{0}^{B}$ 是到阶段 $s = 5$ 结束时 $R_{0}^{B}$ 所受伤害的总次数。计算行矩阵 $$\\begin{pmatrix} I_{0}^{A}  I_{0}^{B} \\end{pmatrix}$$。", "solution": "本题要求对一个简化的 Friedberg-Muchnik 构造（用于构造两个递归可枚举集合 $A$ 和 $B$）的前六个阶段（$s=0, \\ldots, 5$）进行详细模拟。我们必须追踪构造的状态——集合 $A$ 和 $B$、约束 $r_{0}^{A}$ 和 $r_{0}^{B}$ 以及对每个需求的伤害次数——以确定总伤害次数 $I_{0}^{A}$ 和 $I_{0}^{B}$。\n\n给定两个需求：\n1. $R_{0}^{B}: \\Phi_{0}^{B} \\neq A$，优先级高于 $R_{0}^{A}$。\n2. $R_{0}^{A}: \\Phi_{1}^{A} \\neq B$。\n\n图灵泛函定义如下：\n- $\\Phi_{0}^{X}(y) = X(y)$，用度为 $u_{0}(y) = y$。\n- $\\Phi_{1}^{X}(y) = \\left(\\sum_{i=0}^{y} X(i)\\right) \\bmod 2$，用度为 $u_{1}(y) = y$。\n\n对需求 $R_{0}^{Q}$（$Q \\in \\{A, B\\}$）的伤害，发生在另一个需求的谕示集在一个小于或等于 $R_0^Q$ 所施加的约束的输入上被修改时。具体来说：\n- 如果对于某个 $z \\leq r_{0}^{A}$，$A(z)$ 发生改变，则对 $R_{0}^{A}$ 造成一次伤害。\n- 如果对于某个 $z \\leq r_{0}^{B}$，$B(z)$ 发生改变，则对 $R_{0}^{B}$ 造成一次伤害。\n\n低优先级需求 $R_{0}^{A}$ 必须尊重高优先级需求 $R_{0}^{B}$ 的约束。因此，$R_{0}^{A}$ 永远不能将一个数 $z \\leq r_{0}^{B}$ 枚举进 $B$。这意味着 $R_{0}^{A}$ 永远不能伤害 $R_{0}^{B}$。因此，我们可以立即得出结论：$I_{0}^{B} = 0$。我们将通过模拟来验证这一点。\n\n阶段 $s=0$ 开始时的初始状态是：\n- $A_0 = \\emptyset$（特征函数处处为 0）\n- $B_0 = \\emptyset$（特征函数处处为 0）\n- $r_{0,0}^{A} = -1$\n- $r_{0,0}^{B} = -1$\n- $I_{0}^{A} = 0$, $I_{0}^{B} = 0$\n- $W_A = \\emptyset$, $W_B = \\emptyset$（每个需求使用的见证元集合）\n\n我们逐个阶段进行。对于任何集合 $S$，我们将其在阶段 $s$ 开始时的状态表示为 $S_s$。\n\n**阶段 $s=0$（为 $R_{0}^{B}$ 行动）**\n- $R_{0}^{B}$ 行动。它选择尚未使用的最小的未使用见证元 $y$。最小的这样的 $y$ 是 $0$。\n- 我们检查是否 $\\Phi_{0}^{B_0}(0) \\neq A_0(0)$。\n- $\\Phi_{0}^{B_0}(0) = B_0(0) = 0$。\n- $A_0(0) = 0$。\n- 由于 $\\Phi_{0}^{B_0}(0) = A_0(0)$，$R_{0}^{B}$ 行动以产生分歧。它将 $0$ 枚举进 $A$。得到的集合是 $A_1 = \\{0\\}$。\n- 如果我们改变了 $z \\leq r_{0,0}^{A}$ 的 $A(z)$，就会对 $R_{0}^{A}$ 造成伤害。这里，$z=0$ 且 $r_{0,0}^{A} = -1$。由于 $0 \\not\\leq -1$，没有发生伤害。\n- $R_{0}^{B}$ 更新其约束：$r_{0,1}^{B} = \\max(r_{0,0}^{B}, u_{0}(0)) = \\max(-1, 0) = 0$。\n- 阶段 $0$ 结束时的状态：$A_1 = \\{0\\}$，$B_1 = \\emptyset$，$r_{0,1}^{A} = -1$，$r_{0,1}^{B} = 0$，$I_{0}^{A} = 0$，$I_{0}^{B} = 0$。\n\n**阶段 $s=1$（为 $R_{0}^{A}$ 行动）**\n- $R_{0}^{A}$ 行动。它选择满足 $y  r_{0,1}^{B}$ 的最小的未使用见证元 $y$。当前约束是 $r_{0,1}^{B} = 0$。对于 $R_0^A$ 来说，大于 $0$ 的最小未使用见证元是 $y=1$。\n- 我们检查是否 $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$。\n- $\\Phi_{1}^{A_1}(1) = (A_1(0) + A_1(1)) \\bmod 2 = (1 + 0) \\bmod 2 = 1$。\n- $B_1(1) = 0$。\n- 由于 $\\Phi_{1}^{A_1}(1) \\neq B_1(1)$，对于这个见证元，需求已经满足。不采取任何行动。\n- $R_{0}^{A}$ 更新其约束：$r_{0,2}^{A} = \\max(r_{0,1}^{A}, u_{1}(1)) = \\max(-1, 1) = 1$。\n- 阶段 $1$ 结束时的状态：$A_2 = \\{0\\}$，$B_2 = \\emptyset$，$r_{0,2}^{A} = 1$，$r_{0,2}^{B} = 0$，$I_{0}^{A} = 0$，$I_{0}^{B} = 0$。\n\n**阶段 $s=2$（为 $R_{0}^{B}$ 行动）**\n- $R_{0}^{B}$ 行动。它选择最小的未使用见证元，即 $y=1$。\n- 我们检查是否 $\\Phi_{0}^{B_2}(1) \\neq A_2(1)$。\n- $\\Phi_{0}^{B_2}(1) = B_2(1) = 0$。\n- $A_2(1) = 0$。\n- 由于 $\\Phi_{0}^{B_2}(1) = A_2(1)$，$R_{0}^{B}$ 通过将 $1$ 枚举进 $A$ 来行动。得到的集合是 $A_3 = \\{0, 1\\}$。\n- 我们检查是否对 $R_{0}^{A}$ 造成伤害。我们改变了 $A(1)$。$R_{0}^{A}$ 的当前约束是 $r_{0,2}^{A} = 1$。由于 $1 \\leq r_{0,2}^{A}$，发生一次**伤害**。我们将伤害计数加一：$I_{0}^{A} = 1$。一次伤害会使建立该约束的计算无效，因此 $r_0^A$ 被重置为其初始值 $-1$。\n- $R_{0}^{B}$ 更新其约束：$r_{0,3}^{B} = \\max(r_{0,2}^{B}, u_{0}(1)) = \\max(0, 1) = 1$。\n- 阶段 $2$ 结束时的状态：$A_3 = \\{0, 1\\}$，$B_3 = \\emptyset$，$r_{0,3}^{A} = -1$ (重置)，$r_{0,3}^{B} = 1$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=3$（为 $R_{0}^{A}$ 行动）**\n- $R_{0}^{A}$ 行动。它选择满足 $y  r_{0,3}^{B}$ 的最小的未使用见证元 $y$。约束是 $r_{0,3}^{B} = 1$。大于 $1$ 的最小未使用见证元是 $y=2$。\n- 我们检查是否 $\\Phi_{1}^{A_3}(2) \\neq B_3(2)$。\n- $\\Phi_{1}^{A_3}(2) = (A_3(0) + A_3(1) + A_3(2)) \\bmod 2 = (1 + 1 + 0) \\bmod 2 = 0$。\n- $B_3(2) = 0$。\n- 由于 $\\Phi_{1}^{A_3}(2) = B_3(2)$，$R_{0}^{A}$ 行动。它必须尊重 $r_{0,3}^{B}=1$，所以它只能在 $z  1$ 的位置将元素枚举进 $B$。它将 $2$ 枚举进 $B$。得到的集合是 $B_4 = \\{2\\}$。\n- 我们检查是否对 $R_{0}^{B}$ 造成伤害。我们改变了 $B(2)$。约束是 $r_{0,3}^{B} = 1$。由于 $2 \\not\\leq 1$，没有发生伤害。\n- $R_{0}^{A}$ 更新其约束：$r_{0,4}^{A} = \\max(r_{0,3}^{A}, u_{1}(2)) = \\max(-1, 2) = 2$。\n- 阶段 $3$ 结束时的状态：$A_4 = \\{0, 1\\}$，$B_4 = \\{2\\}$，$r_{0,4}^{A} = 2$，$r_{0,4}^{B} = 1$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=4$（为 $R_{0}^{B}$ 行动）**\n- $R_{0}^{B}$ 行动。它选择最小的未使用见证元，即 $y=2$。\n- 我们检查是否 $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$。\n- $\\Phi_{0}^{B_4}(2) = B_4(2) = 1$。\n- $A_4(2) = 0$。\n- 由于 $\\Phi_{0}^{B_4}(2) \\neq A_4(2)$，需求已经满足。不采取任何行动。\n- $R_{0}^{B}$ 更新其约束：$r_{0,5}^{B} = \\max(r_{0,4}^{B}, u_{0}(2)) = \\max(1, 2) = 2$。\n- 阶段 $4$ 结束时的状态：$A_5 = \\{0, 1\\}$，$B_5 = \\{2\\}$，$r_{0,5}^{A} = 2$，$r_{0,5}^{B} = 2$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n**阶段 $s=5$（为 $R_{0}^{A}$ 行动）**\n- $R_{0}^{A}$ 行动。它选择满足 $y  r_{0,5}^{B}$ 的最小的未使用见证元 $y$。约束是 $r_{0,5}^{B}=2$。大于 $2$ 的最小未使用见证元是 $y=3$。\n- 我们检查是否 $\\Phi_{1}^{A_5}(3) \\neq B_5(3)$。\n- $\\Phi_{1}^{A_5}(3) = (A_5(0) + A_5(1) + A_5(2) + A_5(3)) \\bmod 2 = (1 + 1 + 0 + 0) \\bmod 2 = 0$。\n- $B_5(3) = 0$。\n- 由于 $\\Phi_{1}^{A_5}(3) = B_5(3)$，$R_{0}^{A}$ 行动。它必须尊重 $r_{0,5}^{B}=2$。它将 $3$ 枚举进 $B$。得到的集合是 $B_6 = \\{2, 3\\}$。\n- 我们检查是否对 $R_{0}^{B}$ 造成伤害。我们改变了 $B(3)$。约束是 $r_{0,5}^{B} = 2$。由于 $3 \\not\\leq 2$，没有发生伤害。\n- $R_{0}^{A}$ 更新其约束：$r_{0,6}^{A} = \\max(r_{0,5}^{A}, u_{1}(3)) = \\max(2, 3) = 3$。\n- 阶段 $5$ 结束时的状态：$A_6 = \\{0, 1\\}$，$B_6 = \\{2, 3\\}$，$r_{0,6}^{A} = 3$，$r_{0,6}^{B} = 2$，$I_{0}^{A} = 1$，$I_{0}^{B} = 0$。\n\n在模拟了阶段 $s=0$ 到 $s=5$ 之后，$R_{0}^{A}$ 所受伤害的总次数是 $I_{0}^{A} = 1$，$R_{0}^{B}$ 所受伤害的总次数是 $I_{0}^{B} = 0$。\n\n问题要求计算行矩阵 $$\\begin{pmatrix} I_{0}^{A}  I_{0}^{B} \\end{pmatrix}$$。结果是 $$\\begin{pmatrix} 1  0 \\end{pmatrix}$$。", "answer": "$$\\boxed{\\begin{pmatrix} 1   0 \\end{pmatrix}}$$", "id": "2986940"}, {"introduction": "在优先权构造的任何给定阶段，一个策略都必须做出关键决策：如何在满足自身需求的同时，不破坏更高优先权策略的工作。这个实践问题聚焦于这样一个瞬间，为您提供一组特定的生效限制和用途界限。您的任务是应用伤害规避规则来评估提议的行动，并确定正确、安全的行动方案，从而磨练您在优先权框架的约束下进行导航的能力 [@problem_id:2986970]。", "problem": "考虑一个用于 Friedberg–Muchnik 定理的有限伤害优先权构造，该定理断言存在两个具有不可比图灵度的可计算可枚举 (c.e.) 集合。该构造通过满足形式为 $$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A}$$ 的需求来进行，其中 $\\Phi_{e}$ 和 $\\Psi_{e}$ 是图灵泛函，$\\Phi_{e}^{B}$ 和 $\\Psi_{e}^{A}$ 分别表示使用 $B$ 和 $A$ 作为预言机的计算。需求 $R_{e}$ 通过确保在某个见证 $x$ 上存在分歧来满足；为了保护更高优先级的计算，每个更高优先级的策略都会维持数值约束和保留使用界。\n\n在当前阶段 $s$，假设以下更高优先级的保护参数处于活跃状态：\n- 对 $A$ 的约束等于 $r_{A} = 30$。\n- 对 $B$ 的约束等于 $r_{B} = 22$。\n- 涉及 $A$ 的保留使用界等于 $u_{A}^{\\mathrm{HP}} = 28$。\n- 涉及 $B$ 的保留使用界等于 $u_{B}^{\\mathrm{HP}} = 19$。\n\n你正在处理需求 $R_{2}$，当前见证为 $x = 10$，并且你已观察到计算 $\\Phi_{2}^{B}(x)$ 在阶段 $s$ 收敛，其仅使用了对 $B$ 的低于界 $u_{B}^{(2)} = 21$ 的预言机查询。你正在考虑两个提议的行动：\n- 对 $A$ 的提议：将数 $a_{A} = 27$ 枚举到 $A$ 中。\n- 对 $B$ 的提议：将数 $b_{B} = 20$ 枚举到 $B$ 中。\n\n在此构造中，如果一个较低优先级的行动将数 $n$ 枚举到集合 $S \\in \\{A, B\\}$ 中，而 $n$ 并不严格大于 $S$ 上的每个活跃约束和相关使用界，则该行动会伤害一个被保护的计算或约束。也就是说，为避免伤害，将 $n$ 枚举到 $S$ 中必须满足 $n > r_{S}$ 和 $n > u_{S}^{\\mathrm{HP}}$。\n\n仅使用所述参数和此伤害避免规则，判断每个提议的行动是否伤害更高优先级的需求。然后，计算最小的自然数 $n_{A}$，使得在阶段 $s$ 将 $n_{A}$ 枚举到 $A$ 中可以避免不必要的伤害，同时仍允许你在当前阶段通过对 $\\Phi_{2}^{B}(x)$ 进行对角化来满足 $R_{2}$。你的最终答案必须是单个数字 $n_{A}$。", "solution": "我们首先回顾 Friedberg–Muchnik 定理的优先权构造的基本设置。我们的目标是构造两个可计算可枚举 (c.e.) 集合 $A$ 和 $B$，以满足需求 $$R_{e}:\\ A \\neq \\Phi_{e}^{B} \\quad \\text{and} \\quad S_{e}:\\ B \\neq \\Psi_{e}^{A}.$$ 在任何阶段 $s$，更高优先级的策略通过施加约束 $r_{A}$ 和 $r_{B}$ 以及维持保留使用界 $u_{A}^{\\mathrm{HP}}$ 和 $u_{B}^{\\mathrm{HP}}$ 来确保某些计算的保留。较低优先级的策略必须在不违反这些约束或使用界的情况下行动。具体来说，只有当 $n > r_{S}$ 和 $n > u_{S}^{\\mathrm{HP}}$ 时，将数 $n$ 枚举到 $S \\in \\{A,B\\}$ 中才是安全的。这保证了读取低于使用界的预言机位的受保护计算不会被干扰，也没有约束被违反。\n\n在阶段 $s$，给定的参数是：\n- 对于集合 $A$，$r_{A} = 30$ 且 $u_{A}^{\\mathrm{HP}} = 28$，\n- 对于集合 $B$，$r_{B} = 22$ 且 $u_{B}^{\\mathrm{HP}} = 19$，\n- 目标需求是 $R_{2}$，见证为 $x = 10$，当前计算 $\\Phi_{2}^{B}(x)$ 收敛，使用的 $B$ 的预言机位严格低于 $u_{B}^{(2)} = 21$。\n\n我们首先评估两个提议的行动的安全性。\n\n1. 对 $A$ 的提议：将 $a_{A} = 27$ 枚举到 $A$ 中。\n   为保证安全，我们需要 $a_{A} > r_{A}$ 和 $a_{A} > u_{A}^{\\mathrm{HP}}$。代入给定值，我们检查 $27 > 30$ 和 $27 > 28$。两个不等式都不成立。因此，将 $27$ 枚举到 $A$ 中会违反对 $A$ 的约束，并伤害一个依赖于低于使用界 $u_{A}^{\\mathrm{HP}}$ 的 $A$ 的保留计算。\n\n2. 对 $B$ 的提议：将 $b_{B} = 20$ 枚举到 $B$ 中。\n   为保证安全，我们需要 $b_{B} > r_{B}$ 和 $b_{B} > u_{B}^{\\mathrm{HP}}$。代入给定值，我们检查 $20 > 22$ 和 $20 > 19$。第一个不等式不成立，而第二个成立。因此，将 $20$ 枚举到 $B$ 中会违反对 $B$ 的约束，从而伤害一个保护 $B$ 中低于 $22$ 部分的更高优先级需求。\n\n两个提议的行动都伤害了更高优先级的保护。\n\n接下来，我们计算最小的数 $n_{A}$，使得将 $n_{A}$ 枚举到 $A$ 中可以避免伤害。根据伤害避免规则，$n_{A}$ 必须满足 $n_{A} > r_{A}$ 和 $n_{A} > u_{A}^{\\mathrm{HP}}$。由于 $r_{A} = 30$ 和 $u_{A}^{\\mathrm{HP}} = 28$，严格不等式意味着 $n_{A} > \\max\\{30, 28\\} = 30$。因此，满足这两个约束的最小自然数是 $n_{A} = 31$。\n\n最后，我们验证在当前阶段对 $A$ 以 $n_{A} = 31$ 行动是适合满足 $R_{2}$ 的。需求 $R_{2}$ 旨在对 $\\Phi_{2}^{B}(x)$ 进行对角化。由于我们已观察到 $\\Phi_{2}^{B}(x)$ 以使用界 $u_{B}^{(2)} = 21$ 收敛，在 $31$ 处改变 $A$ 不会影响预言机 $B$，因此不会干扰该计算。此外，因为 $31$ 超过了 $r_{A}$ 和 $u_{A}^{\\mathrm{HP}}$，所以没有涉及 $A$ 的受保护计算被伤害。因此，将 $31$ 枚举到 $A$ 中避免了不必要的伤害，并允许满足 $R_{2}$。\n\n因此，最小的安全选择是 $n_{A} = 31$。", "answer": "$$\\boxed{31}$$", "id": "2986970"}, {"introduction": "在练习了单个阶段和决策的机制之后，这最后一个练习将挑战您评估一个有限伤害论证的整体逻辑。您将看到对一个“玩具问题”的几种完整策略描述。您的目标是识别出那个正确阐述了策略、限制和伤害处理之间相互作用的描述，以确保您能从有缺陷的构造中辨别出可靠的优先权构造 [@problem_id:2986972]。", "problem": "考虑在有限伤害优先权框架下，构造满足两个冲突需求的递归可枚举集 $A$ 和 $B$ 这一目标。该构造必须是分阶段的，使用施加并遵守限制的策略，允许可证明为有限的伤害，并包含一个验证所有需求都得到满足的过程。在图灵可归约性和谕示计算的层面上进行。\n\n基本和核心定义：\n- 如果存在一个图灵机 (TM) 枚举集合 $S$ 的所有元素，则集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的 (r.e.)。\n- 图灵泛函 $\\Phi_e$ 是一个索引 $e$，编码一个部分可计算算子。给定一个谕示 $X \\subseteq \\mathbb{N}$，该算子计算一个（可能部分的）函数或集合 $\\Phi_e^X$。如果 $\\Phi_e^X(x)$ 收敛，我们记作 $\\Phi_e^X(x) \\downarrow$，并用 $\\mathrm{use}(\\Phi_e^X(x))$ 表示在输入 $x$ 的计算中对 $X$ 进行的最大谕示查询。\n- 图灵可归约性 $A \\le_T B$ 意味着存在一个索引 $e$，使得对于所有 $x \\in \\mathbb{N}$，$\\Phi_e^B(x)$ 停机并等于 $A$ 在 $x$ 处的特征函数。要迫使 $A \\nleq_T B$，只需满足需求 $R_e : A \\neq \\Phi_e^B$，即存在某个 $x$，使得 $\\Phi_e^B(x) \\uparrow$ 或 $\\Phi_e^B(x) \\downarrow \\neq \\chi_A(x)$。\n- 有限伤害优先权论证通过优先级（例如，$R_0$ 高于 $S_0$）来组织需求，分配可能对枚举施加限制以保护已识别计算的策略，并允许较低优先级的策略被较高优先级的行动伤害。必须证明每次伤害对每个需求只发生有限次，并且验证必须表明每个需求最终都得到满足。\n\n示例问题设置：\n我们关注具有固定优先级顺序 $R_0 \\succ S_0$ 的两个需求：\n- $R_0$: 确保 $A \\neq \\Phi_0^B$。\n- $S_0$: 确保 $B \\neq \\Phi_0^A$。\n\n一个分阶段的构造在阶段 $s$ 产生递增的有限近似 $A_s$ 和 $B_s$，其中 $A = \\bigcup_s A_s$ 且 $B = \\bigcup_s B_s$。策略可以对枚举到 $B$ 施加限制 $r_{R_0}^B$，对枚举到 $A$ 施加限制 $r_{S_0}^A$，以通过它们的谕示用途来保护收敛的计算。\n\n问题：\n哪个选项正确地描述了上述示例构造的有限伤害优先权论证，包括精确的策略、与谕示用途相关的限制、对伤害及其有限性的解释，以及对 $R_0$ 和 $S_0$ 均得到满足的验证？\n\n选择一项。\n\nA. $R_0$ 的策略：维护一个单一见证元 $x_R$（初始为尚未分配的最小的 $x$）。在阶段 $s$，搜索 $\\Phi_0^{B_s}(x_R) \\downarrow$；如果找到，且其用途为 $\\mathrm{use}(\\Phi_0^{B_s}(x_R)) = u_R$，则设置限制 $r_{R_0}^B := \\max(r_{R_0}^B, u_R)$，然后通过枚举到 $A$ 来迫使在 $x_R$ 处产生不一致：如果 $\\Phi_0^{B_s}(x_R) = 0$，则在阶段 $s$ 将 $x_R$ 放入 $A$；如果 $\\Phi_0^{B_s}(x_R) = 1$，则确保 $x_R \\notin A$。行动后，$R_0$ 宣布自己已满足，并且不再更改 $x_R$。$S_0$ 的策略：维护一个单一见证元 $y_S$。在阶段 $s$，搜索 $\\Phi_0^{A_s}(y_S) \\downarrow$；如果找到，且其用途为 $\\mathrm{use}(\\Phi_0^{A_s}(y_S)) = v_S$，则设置限制 $r_{S_0}^A := \\max(r_{S_0}^A, v_S)$，然后类似地通过枚举到 $B$ 来迫使在 $y_S$ 处产生不一致。限制规则和伤害：在每个阶段 $s$ 处理 $S_0$ 时，禁止向 $B$ 中枚举小于 $r_{R_0}^B$ 的数，从而遵守与当前在 $\\Phi_0^{B}(x_R)$ 中受保护的用途相关联的较高优先级限制。$R_0$ 不施加任何限制来遵守 $S_0$，并可能通过向 $A$ 中枚举小于 $r_{S_0}^A$ 的数来伤害 $S_0$，但 $R_0$ 最多行动一次，因此 $S_0$ 最多被伤害一次；在任何伤害之后，$S_0$ 将 $y_S$ 重置为大于被伤害的用途的值，然后继续。验证：由于 $S_0$ 遵守 $r_{R_0}^B$，一旦 $R_0$ 看到了一个收敛的计算并设置了 $r_{R_0}^B$，那么用途为 $u_R$ 的受保护计算 $\\Phi_0^{B}(x_R)$ 就永远不会被破坏，$R_0$ 可以在 $x_R$ 处迫使 $A \\neq \\Phi_0^B$。$R_0$ 只行动一次，因此 $S_0$ 因 $A$ 的变化最多遭受一次伤害；此后，$S_0$ 最终会找到一个收敛的 $\\Phi_0^{A}(y_S)$，其用途 $v_S$ 高于任何未来对 $A$ 的更改（因为较高优先级已经稳定），设置 $r_{S_0}^A$，并在 $y_S$ 处迫使 $B \\neq \\Phi_0^A$。因此，两个需求都得到满足，且每个需求只被伤害有限次。\n\nB. $R_0$ 的策略：同选项 A，但在找到计算 $\\Phi_0^{B}(x_R)$ 时，对向 $A$ 中枚举设置限制 $r_{R_0}^A$ 而不是对 $B$ 设置；当找到 $\\Phi_0^{A}(y_S)$ 时，$S_0$ 设置 $r_{S_0}^B$。伤害：$S_0$ 遵守 $r_{R_0}^A$ 且 $R_0$ 遵守 $r_{S_0}^B$。验证：由于每个需求都限制其自身的集合，两个计算都得以保留，两个对角化都成功。\n\nC. $R_0$ 的策略：按递增顺序循环遍历见证元 $x$，每当看到 $\\Phi_0^{B_s}(x) \\downarrow$ 时，就设置一个限制 $r_{R_0}^B := \\mathrm{use}(\\Phi_0^{B_s}(x))$ 并在 $x$ 处迫使不一致。如果之后 $\\Phi_0^{B_t}(x) \\uparrow$，则将 $r_{R_0}^B$ 减少到之前的值并选择一个新的见证元；$S_0$ 以对称的方式对 $r_{S_0}^A$ 进行操作。伤害：限制可能会根据不同阶段的表面收敛情况而增加或减少。验证：由于限制会适应变化的计算，最终两个对角化都成功。\n\nD. $R_0$ 的策略：在阶段 $s$ 预先设置一个大的限制 $r_{R_0}^B := s^2$，如果 $s$ 是偶数，则将 $x_R := s$ 枚举到 $A$ 中，否则什么也不做；$S_0$ 对称地设置 $r_{S_0}^A := s^2$，如果 $s$ 是奇数，则将 $y_S := s$ 枚举到 $B$ 中。伤害：允许任意的限制增长；每个策略都忽略任何计算中的实际谕示用途。验证：由于限制无限增长，最终不会发生伤害，并且两个对角化必须通过基于奇偶性的不一致而成立。\n\n选择一个选项，该选项正确地规定了一个有限伤害优先权论证，具有适当的策略、与谕示用途相关的限制、对伤害及其有限性的正确解释，以及一个关于 $A \\neq \\Phi_0^B$ 和 $B \\neq \\Phi_0^A$ 的合理验证。", "solution": "用户要求对所提供的问题陈述进行严格验证，然后给出详细的解决方案和对给定选项的评估。\n\n### 第 1 步：提取已知条件\n- **目标**：构造两个递归可枚举 (r.e.) 集 $A$ 和 $B$。\n- **方法**：分阶段的有限伤害优先权论证。\n- **背景**：图灵可归约性（$\\le_T$）和谕示计算（$\\Phi_e^X$）。\n- **定义**：\n    - 一个 r.e. 集 $S \\subseteq \\mathbb{N}$ 是一个枚举图灵机的输出。\n    - $\\Phi_e$ 是一个图灵泛函。$\\Phi_e^X(x) \\downarrow$ 表示收敛，$\\mathrm{use}(\\Phi_e^X(x))$ 是最大的谕示查询。\n    - $A \\le_T B$ 当且仅当对于某个索引 $e$，$\\chi_A = \\Phi_e^B$。\n    - 迫使 $A \\nleq_T B$ 需要满足需求 $R_e : A \\neq \\Phi_e^B$。\n    - 有限伤害优先权论证涉及带优先级的需求、策略、限制以及有限伤害的证明。\n- **示例问题**：\n    - 需求：$R_0: A \\neq \\Phi_0^B$ 和 $S_0: B \\neq \\Phi_0^A$。\n    - 优先级顺序：$R_0 \\succ S_0$（$R_0$ 的优先级高于 $S_0$）。\n    - 构造细节：$A = \\bigcup_s A_s$ 且 $B = \\bigcup_s B_s$，其中 $A_s$ 和 $B_s$ 是在阶段 $s$ 的有限近似。\n    - 限制：对 $B$ 的限制 $r_{R_0}^B$ 和对 $A$ 的限制 $r_{S_0}^A$。\n- **问题**：确定哪个选项正确描述了此示例问题的有限伤害论证，包括策略、限制、伤害分析和验证。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题明确属于可计算性理论，这是数理逻辑的一个主要分支。所有定义——递归可枚举集、图灵泛函、图灵可归约性以及优先权论证的结构——都是标准的且陈述正确。构造图灵不可比的 r.e. 集的目标是著名的 Friedberg–Muchnik 定理的主题，有限伤害优先权方法正是为此发明的。因此，该问题在科学上和事实上都是合理的。\n2.  **适定性**：该问题是适定的。它提出了一个标准证明技术的简化“示例”版本，并要求对其机制进行正确描述。由于有限伤害方法的逻辑是明确的，因此预计在选项中有一个正确且唯一的答案。\n3.  **客观性**：所用语言是形式化的、技术性的，并且没有主观或含糊的术语。\n4.  **其他缺陷**：该问题没有其他任何无效标准方面的问题。它是完整的、一致的、可形式化的，并且并非无足轻重。其设置直接反映了可计算性理论标准教科书中介绍有限伤害方法的方式。\n\n### 第 3 步：结论和行动\n问题陈述是**有效的**。这是一个形式良好且标准的可计算性理论问题。我们可以继续进行解答。\n\n### 推导与选项分析\n\n目标是构造 r.e. 集 $A$ 和 $B$，使得 $A \\nleq_T B$ 且 $B \\nleq_T A$。问题将其简化为满足两个需求：$R_0: A \\neq \\Phi_0^B$ 和 $S_0: B \\neq \\Phi_0^A$，优先级为 $R_0 \\succ S_0$。构造按阶段 $s=0, 1, 2, \\dots$ 进行。\n\n优先权方法的核心逻辑：\n每个需求都有一个策略来确保其得到满足。对于像 $R_e: A \\neq \\Phi_e^B$ 这样的需求，其策略试图创造一个“不一致点”，即找到一个见证元 $x$ 使得 $\\chi_A(x) \\neq \\Phi_e^B(x)$。\n\n1.  **$R_0: A \\neq \\Phi_0^B$ 的策略（高优先级）**\n    - 该策略必须找到一个 $x$ 使得 $\\chi_A(x) \\neq \\Phi_0^B(x)$。它选择一个潜在的见证元，比如 $x_R$，并等待一个阶段 $s$ 使得计算 $\\Phi_0^{B_s}(x_R)$ 收敛。设 $\\Phi_0^{B_s}(x_R) \\downarrow = y$。\n    - 为了创造不一致，策略希望使 $\\chi_A(x_R) \\neq y$。由于我们只能向 r.e. 集 $A$ 中添加元素，最简单的情况是当 $x_R \\notin A_s$ 时我们发现 $y=0$。在这种情况下，策略的行动是将 $x_R$ 枚举到 $A$ 中。\n    - 这个计算 $\\Phi_0^{B_s}(x_R)$ 仅依赖于谕示 $B_s$ 直到某个有限的用途 $u_R = \\mathrm{use}(\\Phi_0^{B_s}(x_R))$。为确保这种不一致是永久的，我们必须保护这个计算不被后续加入到 $B$ 的元素所“破坏”。\n    - 因此，$R_0$ 的策略必须**对 $B$ 施加一个限制**。它声明，任何小于或等于 $u_R$ 的数都不能被枚举到 $B$ 中。我们可以定义限制函数 $r_{R_0}^B = u_R + 1$。因为 $R_0$ 具有最高优先级，所有其他策略都必须遵守这个限制。\n\n2.  **$S_0: B \\neq \\Phi_0^A$ 的策略（低优先级）**\n    - 策略是对称的：它选择一个见证元 $y_S$ 并等待 $\\Phi_0^{A_s}(y_S) \\downarrow = z$。\n    - 为了创造不一致，它可能想要将 $y_S$ 枚举到 $B$ 中（如果 $z=0$ 且 $y_S \\notin B_s$）。\n    - 为了保护其计算，它将基于用途 $v_S = \\mathrm{use}(\\Phi_0^{A_s}(y_S))$ **对 $A$ 施加一个限制**。设此限制为 $r_{S_0}^A = v_S+1$。\n\n3.  **优先级、伤害与验证**\n    - 由于 $R_0 \\succ S_0$，$S_0$ 的策略**必须遵守**由 $R_0$ 施加的任何限制 $r_{R_0}^B$。也就是说，$S_0$ 被禁止向 $B$ 中枚举任何数 $k  r_{R_0}^B$。\n    - 反之，$R_0$ **不遵守**来自 $S_0$ 的限制。如果 $R_0$ 决定将 $x_R$ 枚举到 $A$ 中以满足自身需求，即使 $x_R  r_{S_0}^A$，它也会这样做。\n    - 当一个较高优先级的需求采取的行动使一个较低优先级需求的受保护计算失效时，就发生了**伤害**。在这里，如果 $R_0$ 将 $x_R$ 放入 $A$ 且 $x_R \\leq v_S = \\mathrm{use}(\\Phi_0^{A_s}(y_S))$，那么 $S_0$ 的计算很可能被破坏。于是 $S_0$ 就被“伤害”了。\n    - 受到伤害后，$S_0$ 必须放弃其当前的见证元 $y_S$ 和策略，并重新开始（通常使用一个新的、更大的见证元）。\n    - **有限伤害**：关键的洞见是，每个需求 $R_e$ 只需行动有限次即可被永久满足。对于 $R_0$，一个简单的策略是找到第一个创造不一致的机会，采取行动，然后宣布自己已满足，永不再行动。这意味着 $R_0$ 最多行动一次。因此，$S_0$ 将最多被 $R_0$ 伤害一次。在 $R_0$ 稳定下来之后（无论是通过行动还是因为 $\\Phi_0^B$ 是部分的），$S_0$ 不会再受到来自 $R_0$ 的伤害。\n    - **最终成功**：在某个阶段 $s^*$ 之后，$R_0$ 被永久满足，其限制 $r_{R_0}^B$ 及其对 $A$ 的影响是最终的。然后 $S_0$ 的策略可以继续进行。它最终会找到一个稳定的计算 $\\Phi_0^{A_s}(y_S)$（对于 $s > s^*$），并可以通过将 $y_S$ 放入 $B$ 来满足自己。只要它遵守 $r_{R_0}^B$，这是可能的，而这可以通过选择一个足够大的见证元 $y_S$（$y_S \\ge r_{R_0}^B$）来保证。因此，两个需求最终都得到满足。\n\n在这个正确的框架建立之后，我们评估各个选项。\n\n**选项 A 评估：**\n- **$R_0$ 策略**：正确描述了选择见证元 $x_R$，等待收敛 $\\Phi_0^{B_s}(x_R) \\downarrow$，基于用途 $u_R$ 对 $B$ 施加限制 $r_{R_0}^B$，并通过枚举到 $A$ 中来创造不一致。它正确地指出 $R_0$ 随后得到满足。\n- **$S_0$ 策略**：正确描述了对于 $B \\neq \\Phi_0^A$ 的对称过程，该过程对 $A$ 施加限制 $r_{S_0}^A$。\n- **规则和伤害**：正确地指出 $S_0$ 必须遵守 $r_{R_0}^B$，而 $R_0$ 不遵守 $r_{S_0}^A$ 并可能伤害 $S_0$。它正确地识别出，$R_0$ 最多行动一次意味着 $S_0$ 最多被伤害一次（有限次）。\n- **验证**：正确地论证了 $S_0$ 遵守 $r_{R_0}^B$ 保证了 $R_0$ 的成功。然后它正确地论证了，在 $R_0$ 稳定后，$S_0$ 不再被伤害，可以找到自己的稳定计算并采取行动来满足自己。\n- **结论**：此选项为该问题提供了有限伤害优先权论证的完整而准确的描述。**正确**。\n\n**选项 B 评估：**\n- **策略**：该选项声称 $R_0$（处理 $\\Phi_0^B$）限制 $A$，而 $S_0$（处理 $\\Phi_0^A$）限制 $B$。这从根本上是错误的。为了保护一个计算 $\\Phi_e^X(z)$，必须限制谕示 $X$。限制一个不同的集合对于保护计算没有任何作用。通过限制来保留计算的整个逻辑被颠倒了。\n- **结论**：**不正确**。\n\n**选项 C 评估：**\n- **策略**：该选项建议，如果一个受保护的计算 $\\Phi_0^{B_t}(x)$ 变得无定义，限制 $r_{R_0}^B$ 会被减小。这是对优先级层次的误解。$R_0$ 具有最高优先级。任何东西都不允许伤害它的计算。在设置限制后，计算 $\\Phi_0^{B_s}(x)$ 不应该变得无定义，因为限制的根本目的就是防止对谕示 $B$ 的更改导致这种情况。所描述的场景不应该发生。这种减少限制的机制不是标准有限伤害论证的一部分，并且歪曲了优先级和保护的作用。\n- **结论**：**不正确**。\n\n**选项 D 评估：**\n- **策略**：提出的策略是任意设置限制（$r^B_{R_0} := s^2$），并根据一个简单的奇偶规则（$A$ 获得偶数，$B$ 获得奇数）来构造集合 $A$ 和 $B$，完全忽略了实际的计算 $\\Phi_0^B$ 和 $\\Phi_0^A$。这不是一个优先权论证。这是一个直接的构造，未能与问题需求接轨。\n- **验证**：该构造产生可计算集 $A$ 和 $B$。可计算集之间可以平凡地相互归约（$A \\le_T B$ 且 $B \\le_T A$）。因此，该构造未能产生图灵不可比的集合，而这才是最终目标。例如，如果 $\\Phi_0$ 是一个无论其谕示如何都计算偶数特征函数的泛函，那么 $\\Phi_0^B$ 将与 $A$ 相同，需求 $R_0$ 将会失败。所提出的策略没有机制来阻止这种情况。\n- **结论**：**不正确**。\n\n基于详细分析，选项 A 是唯一一个正确且准确地描述了应用于给定示例问题的有限伤害优先权论证的选项。", "answer": "$$\\boxed{A}$$", "id": "2986972"}]}