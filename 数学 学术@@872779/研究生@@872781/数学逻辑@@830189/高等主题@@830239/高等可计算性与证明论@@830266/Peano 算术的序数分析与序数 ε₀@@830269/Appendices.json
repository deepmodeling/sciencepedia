{"hands_on_practices": [{"introduction": "序数分析的一个经典应用是证明某些在皮亚诺算术（PA）中无法证明的数论命题，古德斯坦定理（Goodstein's theorem）就是一个绝佳的例子。通过这个实践，你将亲手计算一个古德斯坦序列的初始几项，并追踪其对应的序数度量。你会具体地看到，尽管整数序列的数值以惊人的速度增长，但其对应的序数度量却严格递减，这直观地展示了超限归纳法直至$\\varepsilon_0$的力量 [@problem_id:2978410]。", "problem": "考虑下面的古德斯坦过程（Goodstein process）及其序数解释，它们是通过序数 $\\varepsilon_0$ 对皮亚诺算术（Peano Arithmetic）进行序数分析的标准工具。\n\n定义与设置：\n- 对于每个基数 $b \\geq 2$，自然数 $n$ 的遗传b进制表示 $H_{b}(n)$ 通过以下方式获得：首先将 $n$ 写成基数为 $b$ 的有限和 $\\sum_{i} c_{i} b^{e_{i}}$，其中系数 $0 \\leq c_{i}  b$，然后递归地将每个指数 $e_{i}$ 写成遗传b进制形式。\n- 给定一个遗传b进制项，其序数解释 $\\Phi(H_{b}(n))$ 的定义是：将每一次出现的 $b$ 替换为第一个无限序数 $\\omega$，将加法和乘法解释为序数运算，将指数解释为序数乘方。结果是一个小于 $\\varepsilon_0$ 且呈康托尔范式（Cantor normal form）的序数。\n- 定义基函数为 $b(k) \\coloneqq k+2$ 的古德斯坦序列 $(G(k))_{k \\in \\mathbb{N}}$ 如下：\n  1. 通过其遗传2进制表示法固定 $G(0)$\n     $$H_{2}(G(0)) \\;=\\; 2^{2^{1}} \\;+\\; 2^{2^{1}} \\;+\\; 1.$$\n     等价地，其数值为 $G(0)=9$。\n  2. 对于每个 $k \\geq 0$，通过以下步骤获得 $G(k+1)$：首先在 $H_{b(k)}(G(k))$ 中将每一个 $b(k)$ 替换为 $b(k+1)$，将其作为自然数求值，然后减去 $1$。\n- 对于每个 $k$，定义序数测度\n  $$\\alpha_{k} \\;\\coloneqq\\; \\Phi\\!\\big(H_{b(k)}(G(k))\\big),$$\n  它是一个小于 $\\varepsilon_{0}$ 且呈康托尔范式的序数。已知 $\\alpha_{k+1}  \\alpha_{k}$。\n\n任务：\n1. 通过明确执行变基和减法步骤来计算 $G(1)$、$G(2)$ 和 $G(3)$，并将每个 $G(k)$ 表示为其遗传 $b(k)$ 进制形式。\n2. 对于 $k=0,1,2,3$ 中的每一个，通过在 $H_{b(k)}(G(k))$ 中将基数 $b(k)$ 替换为 $\\omega$ 来计算呈康托尔范式的 $\\alpha_{k}$。\n3. 明确验证 $\\alpha_{0} > \\alpha_{1} > \\alpha_{2} > \\alpha_{3}$ 且所有 $\\alpha_{k}$ 都小于 $\\varepsilon_{0}$。\n\n$\\alpha_{3}$ 的显式康托尔范式表达式是什么？请以单个闭式表达式的形式提供最终答案。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是自洽的、在数理逻辑上有科学依据且是良定的。为 $G(0)$ 提供的初始表示法虽然非规范，但是作为古德斯坦过程初始状态的定义，这是一种有效的问题设定方式。后续步骤也都是良定义的。\n\n问题要求给出从一个类古德斯坦序列导出的序数 $\\alpha_3$ 的显式康托尔范式。我将按照任务要求，对 $k=0, 1, 2, 3$ 进行计算，以推导出最终答案。第 $k$ 步的基数为 $b(k) = k+2$。\n\n**步骤 $k=0$：**\n基数为 $b(0) = 2$。初始状态由遗传2进制表示法定义：\n$$H_{2}(G(0)) = 2^{2^{1}} + 2^{2^{1}} + 1$$\n其数值为 $G(0) = 2^{2} + 2^{2} + 1 = 4+4+1=9$。\n相应的序数 $\\alpha_0$ 通过将基数 $2$ 替换为 $\\omega$ 并使用序数算术解释该表达式得到。\n$$\\alpha_0 = \\Phi(H_{2}(G(0))) = \\omega^{\\omega^{1}} + \\omega^{\\omega^{1}} + 1 = \\omega^{\\omega}\\cdot 2 + 1$$\n这是一个呈康托尔范式（CNF）的序数。\n\n**步骤 $k=1$：**\n基数为 $b(1) = 1+2 = 3$。为了计算 $G(1)$，我们首先在 $H_2(G(0))$ 的表达式中将基数从 $2$ 变为 $3$：\n$$2^{2^{1}} + 2^{2^{1}} + 1 \\quad \\xrightarrow{\\text{base } 2 \\to 3} \\quad 3^{3^{1}} + 3^{3^{1}} + 1$$\n对这个新表达式求值得出 $3^3 + 3^3 + 1 = 27 + 27 + 1 = 55$。\n古德斯坦过程接着要求减去 $1$：\n$$G(1) = 55 - 1 = 54$$\n接下来，我们求 $G(1)=54$ 的遗传3进制表示法。\n$$G(1) = 54 = 2 \\times 27 = 2 \\times 3^3$$\n由于指数 $3$ 等于基数，它也必须用3进制表示：$3 = 1 \\cdot 3^1$。所以，遗传3进制表示法为：\n$$H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$$\n相应的序数 $\\alpha_1$ 是通过应用映射 $\\Phi$ 得到的。项 $c \\cdot b^{e}$ 映射为 $\\omega^{\\Phi(e)}\\cdot c$。\n$$\\alpha_1 = \\Phi(2 \\cdot 3^{3^{1}}) = \\omega^{\\Phi(3^1)}\\cdot 2$$\n指数的表示 $3^1$ 映射为 $\\omega^1 = \\omega$。因此：\n$$\\alpha_1 = \\omega^{\\omega}\\cdot 2$$\n\n**步骤 $k=2$：**\n基数为 $b(2) = 2+2 = 4$。我们取 $H_{3}(G(1)) = 2 \\cdot 3^{3^{1}}$ 并将基数从 $3$ 变为 $4$：\n$$2 \\cdot 3^{3^{1}} \\quad \\xrightarrow{\\text{base } 3 \\to 4} \\quad 2 \\cdot 4^{4^{1}}$$\n对此求值得出 $2 \\cdot 4^4 = 2 \\cdot 256 = 512$。\n减去 $1$ 得到 $G(2)$：\n$$G(2) = 512 - 1 = 511$$\n现在，我们求 $G(2)=511$ 的遗传4进制表示法。我们可以从表达式 $2\\cdot4^4-1$ 推导出来：\n$$2\\cdot4^4 - 1 = 1\\cdot4^4 + (1\\cdot4^4 - 1)$$\n使用恒等式 $b^n-1 = \\sum_{i=0}^{n-1} (b-1)b^i$，我们有 $4^4-1 = 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$。\n因此，$G(2)$ 的4进制表示法是：\n$$G(2) = 1\\cdot4^4 + 3\\cdot4^3 + 3\\cdot4^2 + 3\\cdot4^1 + 3$$\n对于遗传表示法，指数必须是4进制的。指数 $4$ 写成 $1 \\cdot 4^1$。指数 $3, 2, 1$ 小于基数 $4$，所以它们已经是正确的形式。\n$$H_{4}(G(2)) = 1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3$$\n相应的序数 $\\alpha_2$ 是：\n$$\\alpha_2 = \\Phi(H_{4}(G(2))) = \\omega^{\\Phi(4^1)}\\cdot 1 + \\omega^{\\Phi(3)}\\cdot 3 + \\omega^{\\Phi(2)}\\cdot 3 + \\omega^{\\Phi(1)}\\cdot 3 + \\Phi(3)$$\n$$\\alpha_2 = \\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega\\cdot 3 + 3$$\n\n**步骤 $k=3$：**\n基数为 $b(3) = 3+2 = 5$。我们取 $H_{4}(G(2))$ 并将基数从 $4$ 变为 $5$：\n$$1 \\cdot 4^{4^{1}} + 3 \\cdot 4^3 + 3 \\cdot 4^2 + 3 \\cdot 4^1 + 3 \\quad \\xrightarrow{\\text{base } 4 \\to 5} \\quad 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 3$$\n求值：\n$$5^5 + 3\\cdot5^3 + 3\\cdot5^2 + 3\\cdot5^1 + 3 = 3125 + 3\\cdot125 + 3\\cdot25 + 3\\cdot5 + 3 = 3125 + 375 + 75 + 15 + 3 = 3593$$\n减去 $1$ 得到 $G(3)$：\n$$G(3) = 3593 - 1 = 3592$$\n为了找到 $H_5(G(3))$，我们从 $3593$ 的5进制表达式中减去 $1$。这只影响最后一项：\n$$H_{5}(G(3)) = 1 \\cdot 5^{5^{1}} + 3 \\cdot 5^3 + 3 \\cdot 5^2 + 3 \\cdot 5^1 + 2$$\n这已经是遗传5进制形式，因为所有系数都小于 $5$，并且指数 $5$ 被写为 $5^1$。\n最后，我们计算序数 $\\alpha_3$，即为问题的答案：\n$$\\alpha_3 = \\Phi(H_{5}(G(3))) = \\omega^{\\Phi(5^1)}\\cdot 1 + \\omega^{\\Phi(3)}\\cdot 3 + \\omega^{\\Phi(2)}\\cdot 3 + \\omega^{\\Phi(1)}\\cdot 3 + \\Phi(2)$$\n$$\\alpha_3 = \\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega \\cdot 3 + 2$$\n\n**验证：**\n序数序列为：\n$\\alpha_0 = \\omega^{\\omega}\\cdot 2 + 1$\n$\\alpha_1 = \\omega^{\\omega}\\cdot 2$\n$\\alpha_2 = \\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega \\cdot 3 + 3$\n$\\alpha_3 = \\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega \\cdot 3 + 2$\n我们可以验证 $\\alpha_0 > \\alpha_1 > \\alpha_2 > \\alpha_3$。\n$\\alpha_1  \\alpha_0$ 因为 $\\omega^\\omega\\cdot 2  \\omega^\\omega\\cdot 2+1$。\n$\\alpha_2  \\alpha_1$ 因为 $\\alpha_1 = \\omega^\\omega + \\omega^\\omega$，而尾部 $\\omega^3 \\cdot 3 + \\omega^2 \\cdot 3 + \\omega \\cdot 3 + 3$ 小于 $\\omega^\\omega$。\n$\\alpha_3  \\alpha_2$ 因为它们仅在最后一项上有所不同，其中 $2  3$。\n所有序数都小于 $\\varepsilon_0 = \\sup\\{\\omega, \\omega^\\omega, \\omega^{\\omega^\\omega}, \\dots\\}$，因为它们的最大项是 $\\omega^\\omega$。\n\n$\\alpha_3$ 的显式康托尔范式是 $\\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega \\cdot 3 + 2$。", "answer": "$$\n\\boxed{\\omega^{\\omega} + \\omega^{3}\\cdot 3 + \\omega^{2}\\cdot 3 + \\omega \\cdot 3 + 2}\n$$", "id": "2978410"}, {"introduction": "本练习将带你深入根岑（Gentzen）一致性证明的核心：切消定理（cut-elimination theorem）。你将亲手构造一个包含非平凡切（cut）的PA形式化证明，并分析消除此切的过程如何对应于一个指定的序数度量的减小。这个练习旨在将证明变换这一抽象概念具体化，让你通过一个实例，体验序数如何被用作衡量证明复杂度的“尺子” [@problem_id:2978411]。", "problem": "考虑在根岑式一阶相继式演算中的皮亚诺算术（PA），该演算包含等式以及包含常数 $0$、用于后继的一元函数 $S(\\cdot)$ 以及二元函数符号 $+,\\times$ 的常规算术语言。在由PA的归纳模式增强的经典相继式演算（通常记为LK）中进行演算。结构规则和逻辑规则是标准的，包括切割规则。回顾切割规则：从 $\\Gamma \\vdash \\Delta, A$ 和 $A, \\Sigma \\vdash \\Pi$ 可推导出 $\\Gamma, \\Sigma \\vdash \\Delta, \\Pi$。我们将通过为证明赋予以epsilon数 $\\varepsilon_{0}$ 为上界的序数来追踪切割消去过程，赋值方式要确保局部切割化简严格减小所赋的序数。\n\n使用以下基本定义。\n\n- 通过递归定义公式 $A$ 的逻辑秩 $r(A)$：对于原子公式 $A$（包括 $t=s$），$r(A)=0$；对于 $A \\vee B$ 或 $A \\wedge B$，$r(A \\circ B)=\\max\\{r(A),r(B)\\}$；对于 $A \\rightarrow B$，$r(A \\rightarrow B)=\\max\\{r(A),r(B)\\}$；对于 $\\forall x\\,A$ 或 $\\exists x\\,A$，$r(Qx\\,A)=r(A)+1$。\n- 通过逻辑符号的数量定义公式 $A$ 的逻辑大小 $s(A)$：对于原子公式 $A$，$s(A)=0$；对于 $A \\vee B$，$s(A \\vee B)=s(A)+s(B)+1$；对于 $A \\wedge B$ 和 $A \\rightarrow B$ 也类似；对于 $Qx\\,A$ 且 $Q\\in\\{\\forall,\\exists\\}$，$s(Qx\\,A)=s(A)+1$。\n- 对于一个包含切割的证明 $\\mathcal{P}$，定义其初始序数权重\n$$\nW(\\mathcal{P}) \\;=\\; \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A),\n$$\n其中和以康托尔范式计算，而 $\\omega$ 是第一个无限序数。在本任务中，忽略来自非切割推导的任何有限高度贡献；仅关注 $W(\\mathcal{P})$。\n\n任务。显式地构造一个PA相继式推导，证明“每个自然数要么是零要么是后继数”这一算术事实，并利用它通过一个非平凡的切割来推导相继式\n$$\n\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big).\n$$\n具体而言：\n- 首先，通过对谓词 $P(x) \\equiv \\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$ 使用归纳模式，推导引理相继式 $\\vdash \\forall x\\,\\big(x=0 \\,\\vee\\, \\exists y\\, S(y)=x\\big)$。\n- 其次，通过对析取式进行情况分析，并适当使用带有显式见证的存在-右规则，来推导相继式 $x=0 \\,\\vee\\, \\exists y\\, S(y)=x \\;\\vdash\\; \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n- 第三，将这两个推导与在公式 $C(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$ 上的单个非平凡切割相结合，以获得 $\\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的推导，然后推广到 $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n\n使用 $r(\\cdot)$ 和 $s(\\cdot)$ 的定义，计算你所构造的含切割证明 $\\mathcal{P}$ 的初始序数权重 $W(\\mathcal{P})$，然后对 $C(x)$ 上的切割执行标准的切割化简步骤，在每次化简时追踪序数权重的减少情况：\n- 首先将析取式上的切割化简为其各分量上的切割。\n- 然后将存在量词公式上的切割化简为其母式（使用一个项作为见证）上的切割，并最终消去产生的原子切割。\n\n在每一步中验证序数权重是否严格减小，并验证序数权重序列以 $0$ 为下界且位于 $\\varepsilon_{0}$ 之下。以无切割推导结束。你最终报告的量必须是你所构造证明计算出的初始序数权重 $W(\\mathcal{P})$ 的显式康托尔范式。将你的最终答案表示为单个闭式序数表达式。无需四舍五入。不涉及物理单位。不适用角度和百分比。", "solution": "问题陈述已经过验证，被认为是合理的。它在数理逻辑这一成熟领域内，特别是在证明论和序数分析方面，提出了一个适定任务。所有定义和条件都已提供，未发现科学、逻辑或事实上的不一致之处。\n\n任务是在根岑式相继式演算中构造一个皮亚诺算术（PA）的特定证明，然后计算该证明中一个指定切割的初始序数权重。该证明将建立相继式 $\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$。\n\n设公式 $P(x)$ 定义为 $P(x) \\equiv x=0 \\,\\vee\\, \\exists y\\, S(y)=x$。为简洁起见，当此公式用作切割公式时，我们亦将其记为 $C(x)$。\n\n**第1部分：引理 $\\vdash \\forall x\\,P(x)$ 的推导**\n\n推导过程通过使用PA的归纳模式进行。在相继式演算中，这可以表述为一条规则：如果可以推导出 $\\vdash P(0)$ 和 $P(x) \\vdash P(S(x))$，则可以推断出 $\\vdash \\forall x\\,P(x)$。我们将为这两个前提构造推导。\n\n**基础情形：$\\vdash P(0)$ 的推导**\n$P(0)$ 是公式 $0=0 \\vee \\exists y\\, S(y)=0$。\n1. $\\vdash 0=0$ (逻辑公理, $t=t$)\n2. $\\vdash 0=0, \\exists y\\, S(y)=0$ (对第1行使用右弱化规则)\n3. $\\vdash 0=0 \\vee \\exists y\\, S(y)=0$ (对第2行使用 $\\vee$-右规则)\n至此完成了 $\\vdash P(0)$ 的推导。\n\n**归纳步骤：$P(x) \\vdash P(S(x))$ 的推导**\n$P(S(x))$ 是公式 $S(x)=0 \\vee \\exists y\\, S(y)=S(x)$。我们首先直接推导 $\\vdash P(S(x))$。\n1. $\\vdash S(x)=S(x)$ (逻辑公理, $t=t$)\n2. $\\vdash \\exists y\\, S(y)=S(x)$ (对第1行使用 $\\exists$-右规则，见证为 $t=x$)\n3. $\\vdash S(x)=0, \\exists y\\, S(y)=S(x)$ (对第2行使用右弱化规则)\n4. $\\vdash S(x)=0 \\vee \\exists y\\, S(y)=S(x)$ (对第3行使用 $\\vee$-右规则)\n这是一个 $\\vdash P(S(x))$ 的推导。由此，我们可以通过在左侧进行弱化来获得归纳步骤所需的相继式：\n5. $P(x) \\vdash P(S(x))$ (对第4行使用左弱化规则，将 $P(x)$ 添加到前件中)\n\n有了 $\\vdash P(0)$ 和 $P(x) \\vdash P(S(x))$ 的推导，PA归纳规则允许推断出 $\\vdash \\forall x\\,P(x)$。我们将这个引理的完整推导记为 $\\mathcal{D}_{lemma}$。\n\n**第2部分：$P(x) \\vdash \\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的推导**\n\n该推导通过对公式 $P(x) \\equiv x=0 \\vee \\exists y\\, S(y)=x$ 进行情况分析来进行，这对应于相继式演算中的 $\\vee$-左规则。令 $\\Pi(x,y)$ 表示公式 $x=0 \\vee S(y)=x$。\n\n**情况1：$x=0 \\vdash \\exists y\\,\\Pi(x,y)$**\n1. $x=0 \\vdash x=0$ (逻辑公理)\n2. $x=0 \\vdash x=0, S(0)=x$ (对第1行使用右弱化规则)\n3. $x=0 \\vdash x=0 \\vee S(0)=x$ (对第2行使用 $\\vee$-右规则)\n4. $x=0 \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ (对第3行使用 $\\exists$-右规则，见证为 $t=0$)\n\n**情况2：$\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$**\n这个子推导使用 $\\exists$-左规则。我们为一个新的本征变量 $a$ 假设 $S(a)=x$。\n1. $S(a)=x \\vdash S(a)=x$ (逻辑公理)\n2. $S(a)=x \\vdash x=0, S(a)=x$ (对第1行使用右弱化规则)\n3. $S(a)=x \\vdash x=0 \\vee S(a)=x$ (对第2行使用 $\\vee$-右规则)\n4. $S(a)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ (对第3行使用 $\\exists$-右规则，见证为 $t=a$)\n对第4行应用 $\\exists$-左规则（消除假设 $S(a)=x$）：\n5. $\\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$\n\n**合并情况：** 使用来自情况1和情况2的结果以及 $\\vee$-左规则：\n从 $x=0 \\vdash \\exists y\\,\\Pi(x,y)$ 和 $\\exists y\\, S(y)=x \\vdash \\exists y\\,\\Pi(x,y)$，我们推断出：\n$x=0 \\vee \\exists y\\, S(y)=x \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$。\n至此完成了推导，我们将其记为 $\\mathcal{D}_{R}$。\n\n**第3部分：切割与最终证明的构造**\n\n我们现在组装最终的证明 $\\mathcal{P}$，它涉及在公式 $C(x) \\equiv P(x)$ 上的单个指定切割。\n首先，从第1部分推导出的引理 $\\vdash \\forall x\\,C(x)$，我们获得 $\\vdash C(x)$ 的一个推导。这可以形式化地通过与公理 $\\forall x\\,C(x) \\vdash C(x)$ 的切割来完成，但为了本问题的目的，我们将从引理到 $\\vdash C(x)$ 的推导视为一个预备步骤，它引出了我们主切割的左前提。我们将这个 $\\vdash C(x)$ 的推导记为 $\\mathcal{D}_{L}$。\n\n$\\vdash \\forall x\\,\\exists y\\,\\big(x=0 \\,\\vee\\, S(y)=x\\big)$ 的最终证明构造如下：\n1. 应用切割规则，切割公式为 $C(x)$：\n   - 左前提：$\\vdash C(x)$ 的推导 $\\mathcal{D}_{L}$。\n   - 右前提：$C(x) \\vdash \\exists y\\,(x=0 \\vee S(y)=x)$ 的推导 $\\mathcal{D}_{R}$。\n   结论是相继式 $\\vdash \\exists y\\,(x=0 \\vee S(y)=x)$。令这个包含切割的证明为 $\\mathcal{P}$。\n2. 应用 $\\forall$-右规则对自由变量 $x$ 进行推广：\n   $\\vdash \\forall x\\,\\exists y\\,(x=0 \\vee S(y)=x)$。变量 $x$ 在上下文中（为空）不是自由的，因此这一步是有效的。\n\n问题要求的是在这个最终推广步骤之前的证明 $\\mathcal{P}$ 的序数权重。我们被指示唯一要考虑的切割是 $C(x)$ 上的那个。\n\n**初始序数权重 $W(\\mathcal{P})$ 的计算**\n\n初始权重由 $W(\\mathcal{P}) = \\sum_{A \\in \\mathsf{Cuts}(\\mathcal{P})} \\omega^{r(A)} \\cdot s(A)$ 给出。在我们的构造中，只有一个在公式 $A = C(x) = x=0 \\vee \\exists y\\, S(y)=x$ 上的切割。因此，权重是 $W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x))$。\n\n我们使用所提供的定义来计算秩 $r(C(x))$ 和大小 $s(C(x))$。令 $C_1 \\equiv x=0$ 且 $C_2 \\equiv \\exists y\\, S(y)=x$。公式 $S(y)=x$ 是原子的。根据定义：\n- $r(S(y)=x) = 0$\n- $s(S(y)=x) = 0$\n\n对于原子公式 $C_1 \\equiv x=0$：\n- $r(C_1) = 0$\n- $s(C_1) = 0$\n\n对于 $C_2 \\equiv \\exists y\\, S(y)=x$：\n- $r(C_2) = r(S(y)=x) + 1 = 0 + 1 = 1$\n- $s(C_2) = s(S(y)=x) + 1 = 0 + 1 = 1$\n\n对于切割公式 $C(x) = C_1 \\vee C_2$：\n- $r(C(x)) = \\max\\{r(C_1), r(C_2)\\} = \\max\\{0, 1\\} = 1$\n- $s(C(x)) = s(C_1) + s(C_2) + 1 = 0 + 1 + 1 = 2$\n\n因此，证明 $\\mathcal{P}$ 的初始序数权重为：\n$W(\\mathcal{P}) = \\omega^{r(C(x))} \\cdot s(C(x)) = \\omega^{1} \\cdot 2 = \\omega \\cdot 2$。\n\n**切割消去与序数递减分析**\n\n切割消去过程系统地降低了切割的复杂性，在每一步都严格减小所赋的序数，直到获得一个无切割的证明。\n\n1.  **初始状态：** 证明中有一个在 $C(x) = (x=0) \\vee (\\exists y\\,S(y)=x)$ 上的切割。序数权重为 $W_0 = \\omega \\cdot 2$。\n\n2.  **第一次化简：** 切割公式是一个析取式。切割的右前提 $C(x) \\vdash \\exists y\\,\\Pi(x,y)$ 主要通过使用 $\\vee$-左规则推导得出。对析取式的切割被化简为其分量 $C_1 \\equiv x=0$ 和 $C_2 \\equiv \\exists y\\,S(y)=x$ 上的两个新切割。新证明的序数权重是这些新切割的权重的序数和：\n    $W_1 = (\\omega^{r(C_1)} \\cdot s(C_1)) + (\\omega^{r(C_2)} \\cdot s(C_2))$\n    $W_1 = (\\omega^0 \\cdot 0) + (\\omega^1 \\cdot 1) = 0 + \\omega = \\omega$。\n    我们验证严格递减：$W_1 = \\omega  \\omega \\cdot 2 = W_0$。\n\n3.  **第二次化简：** 证明现在包含两个切割。\n    - 对原子公式 $C_1 \\equiv x=0$ 的切割被直接消去（因为任何此类切割最终都必须追溯到公理 $A \\vdash A$）。它对序数权重的贡献变为 $0$。\n    - 剩下的切割是在公式 $C_2 \\equiv \\exists y\\,S(y)=x$ 上。此切割的右前提（来自第2部分，情况2）是使用 $\\exists$-左规则推导的。该化简将这个存在量词公式上的切割替换为其母式 $S(y)=x$ 上的切割，其中本征变量被左前提中相应 $\\exists$-右规则的见证所替换。得到的切割公式是原子的。新的权重是：\n    $W_2 = \\omega^{r(S(t)=x)} \\cdot s(S(t)=x) = \\omega^0 \\cdot 0 = 0$。\n    我们验证严格递减：$W_2 = 0  \\omega = W_1$。\n\n4.  **最终状态：** 第二次化简后，任何剩余的切割都在原子公式上，然后被消去。最终的证明是无切割的，其序数权重为 $0$。\n\n序数权重序列为 $\\omega \\cdot 2 \\rightarrow \\omega \\rightarrow 0$。这证实了在每个化简步骤中都有严格的递减。此序列中的所有序数都小于 $\\varepsilon_0$，符合要求。\n\n所要求的最终答案是所构造证明 $\\mathcal{P}$ 的初始序数权重。", "answer": "$$\n\\boxed{\\omega \\cdot 2}\n$$", "id": "2978411"}, {"introduction": "在理解了切消过程的基本原理后，这项实践将挑战你将该过程的终止性论证本身进行形式化。通过编程实现序数算术并模拟一个关键的规约步骤，你将验证切消的每一步都会严格降低证明的序数复杂度这一核心属性。这不仅能让你从算法层面理解良序性（well-foundedness）论证，而且还能加深对序数分析为何能保证证明转换过程必然终止的认识 [@problem_id:2978413]。", "problem": "要求您在 Gentzen 风格的皮亚诺算术（PA, Peano Arithmetic）相继演算中，形式化一个单切归约步骤，并验证在该归约下所赋值的序数度量的严格递减。请完全在序数 $\\varepsilon_{0}$ 以下的良基序数表示系统内工作，并使用康托尔范式。\n\n基本基础包括：\n- 通过康托尔范式定义 $\\varepsilon_{0}$ 以下的序数算术：每个序数 $\\alpha  \\varepsilon_{0}$ 都可以唯一地写成 $$\\alpha = \\omega^{\\alpha_{1}} \\cdot c_{1} + \\omega^{\\alpha_{2}} \\cdot c_{2} + \\cdots + \\omega^{\\alpha_{k}} \\cdot c_{k},$$ 其中 $k \\in \\mathbb{N}$，$c_{i} \\in \\mathbb{N}$，且 $\\alpha_{1} \\geq \\alpha_{2} \\geq \\cdots \\geq \\alpha_{k}$，并且每个指数 $\\alpha_{i}$ 本身都是一个低于 $\\varepsilon_{0}$ 的序数。\n- PA 相继演算中的切规则以及对秩为 $r \\in \\mathbb{N}$ 的公式的单切概念。\n- 为确保切消去的可终止性，要求赋予证明的序数度量在切归约步骤下必须严格递减。\n\n任务：\n1. 构造一个显式的归约过程，记为 $\\mathrm{CutReduce}$，它将一个包含对秩为 $r$ 的公式的单切的证明，转换为一个在秩 $r$ 上没有切，或者仅在严格小于 $r$ 的秩上有切的证明。您的设计应捕捉复制子推导对度量的组合效应，但必须确保与秩 $r$ 相关联的首项序数项被移除或严格减小。\n2. 为这样一个形式为 $$\\mu(P) = \\omega^{r} \\cdot h + \\sigma,$$ 的证明 $P$ 定义一个序数度量 $\\mu(P)$，其中 $h \\in \\mathbb{N}$ 反映了被归约的切的左右推导的组合高度，而 $\\sigma$ 是一个严格小于 $\\omega^{r}$ 的背景序数，捕捉了低秩结构的贡献。您的赋值必须与康托尔范式一致，并且必须映射到低于 $\\varepsilon_{0}$ 的序数。\n3. 证明归约过程 $\\mathrm{CutReduce}$ 严格减小了序数度量：$$\\mu\\bigl(\\mathrm{CutReduce}(P)\\bigr)  \\mu(P).$$\n\n实现要求：\n- 以康托尔范式表示低于 $\\varepsilon_{0}$ 的序数，具有递归指数和正整数系数。使用一个能强制指数递减并合并指数相等的相邻项的数据结构。\n- 在康托尔范式中实现序数比较，以实现标准的良序关系：按字典序比较首项指数，若相等则比较系数，然后继续处理后续项。\n- 实现度量构造器 $$\\mu(r, h_{L}, h_{R}, \\sigma) = \\omega^{r} \\cdot (h_{L} + h_{R}) + \\sigma,$$ 其中 $\\sigma$ 以康托尔范式给出，且其所有指数都严格小于 $r$。此处 $h_{L}, h_{R} \\in \\mathbb{N}$。\n- 实现归约步骤 $\\mathrm{CutReduce}$，它输出一个新的度量 $$\\mu'(r, h_{L}, h_{R}, \\sigma) = \\begin{cases}\n\\sigma  \\text{if } r = 0,\\\\\n\\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\geq 1,\n\\end{cases}$$ 其中 $k \\in \\mathbb{N}$ 由复制子推导的组合学确定。选择一个具体的 $k$，它单调依赖于 $h_{L}$ 和 $h_{R}$，并且在切非平凡时为正，例如 $k = h_{L} \\cdot h_{R} + h_{L} + h_{R} + 1$。\n- 对于一个小型测试套件，通过编程方式验证度量在此归约下严格递减。\n\n测试套件：\n对于每个测试用例，输入为 $(r, h_{L}, h_{R}, \\sigma)$，其中 $\\sigma$ 是一个序对 $(e_{i}, c_{i})$ 的列表，编码了 $\\omega^{e_{i}} \\cdot c_{i}$，其中 $e_{i} \\in \\mathbb{N}$ 和 $c_{i} \\in \\mathbb{N}$，按 $e_{i}$ 降序排序，且 $e_{i}  r$。程序必须计算\n$$\\mu'(r, h_{L}, h_{R}, \\sigma)  \\mu(r, h_{L}, h_{R}, \\sigma)$$\n是否成立，并为每个用例返回一个布尔值。\n\n使用以下测试用例：\n- 案例 A (一般情况)：$r = 3$，$h_{L} = 2$，$h_{R} = 3$，$\\sigma = [\\, (2, 1), (1, 4) \\,]$。\n- 案例 B (最小非平凡秩的边界情况)：$r = 1$，$h_{L} = 1$，$h_{R} = 1$，$\\sigma = [\\, ]$。\n- 案例 C (更高秩，非平凡背景)：$r = 5$，$h_{L} = 4$，$h_{R} = 1$，$\\sigma = [\\, (3, 2), (2, 1), (1, 7) \\,]$。\n- 案例 D (一侧高度为零，有有限尾部的边缘情况)：$r = 2$，$h_{L} = 0$，$h_{R} = 5$，$\\sigma = [\\, (1, 1), (0, 10) \\,]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4]”），其中每个结果是一个布尔值，表示相应测试用例的度量是否严格递减。不应打印任何额外文本。", "solution": "该问题是有效的。这是一个在数理逻辑的子领域——证明论中，具有良好设定和科学依据的练习。它要求对 Gentzen 的皮亚诺算术切消去证明中的一个关键步骤进行形式化和验证，特别是要展示序数度量的减少，而这是该过程终止性论证的基石。所有定义和参数均已提供，该问题是自洽且客观的。\n\n以下是推理得到的解决方案：\n\n这个问题涉及到在 Gentzen 风格的皮亚诺算术（$PA$）相继演算中对证明进行的序数分析。该领域的核心成果是 Gentzen 的切消去定理，该定理指出，任何使用 `cut` 规则的证明都可以被转换为一个证明相同末相继式的无切证明。该定理的证明是构造性的：它提供了一个显式算法来系统地移除切。为了证明该算法会终止，需要为每个证明赋予一个来自良序集的序数。归约算法的每一步都必须对应于所赋予序数的严格减少。由于序数不存在无限递减链，该过程必然会终止。对于 $PA$，所需的序数集合是序数 $\\varepsilon_0$ 以下的片段。\n\n**1. 序数表示与比较**\n\n低于 $\\varepsilon_0$ 的序数使用康托尔范式（CNF）表示。一个序数 $\\alpha  \\varepsilon_0$ 有一个唯一的表示形式，即一个有限和：\n$$ \\alpha = \\omega^{\\alpha_1} \\cdot c_1 + \\omega^{\\alpha_2} \\cdot c_2 + \\dots + \\omega^{\\alpha_k} \\cdot c_k $$\n其中 $k$ 是一个非负整数，系数 $c_i$ 是正整数，指数 $\\alpha_i$ 本身是满足 $\\alpha > \\alpha_1 \\geq \\alpha_2 \\geq \\dots \\geq \\alpha_k \\geq 0$ 的序数。\n\n问题通过指定所有指数（$r$ 和 $\\sigma$ 中的 $e_i$）都是自然数（即 $r, e_i \\in \\mathbb{N}$）来简化这个通用结构。这将我们的关注点限制在低于 $\\omega^\\omega$ 的序数上，这是低于 $\\varepsilon_0$ 的序数的一个真初始段。\n\n序数比较是字典序的。给定两个 CNF 形式的序数：\n$$ \\alpha = \\omega^{a_1} \\cdot c_1 + \\omega^{a_2} \\cdot c_2 + \\dots $$\n$$ \\beta = \\omega^{b_1} \\cdot d_1 + \\omega^{b_2} \\cdot d_2 + \\dots $$\n我们说 $\\beta  \\alpha$ 是指，在第一个项不同的索引 $i$ 处，要么有 $b_i  a_i$，要么有 $b_i = a_i$ 且 $d_i  c_i$。如果 $\\beta$ 的项序列是 $\\alpha$ 的项序列的一个真前缀，那么 $\\beta  \\alpha$。\n\n**2. 证明的序数度量**\n\n问题为一个包含特定切的证明 $P$ 定义了一个序数度量 $\\mu(P)$。该切作用于一个逻辑复杂度（或秩）为 $r \\in \\mathbb{N}$ 的公式。切规则的前提是由高度为 $h_L, h_R \\in \\mathbb{N}$ 的子证明推导出来的。该度量是：\n$$ \\mu(P) \\equiv \\mu(r, h_L, h_R, \\sigma) = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n在这里，$\\sigma$ 是一个序数，代表证明所有其他部分的复杂度贡献。一个关键条件是 $\\sigma$ 的 CNF 中的所有指数都严格小于 $r$。这确保了只要 $h_L+h_R > 0$，$\\omega^r \\cdot (h_L + h_R)$ 就是 $\\mu(P)$ 的首项。\n\n**3. 切归约步骤**\n\nGentzen 过程的核心是将秩为 $r$ 的公式上的切归约为一个或多个秩严格小于 $r$ 的公式上的切。问题对这种归约（$\\mathrm{CutReduce}$）对序数度量的影响进行建模。新的度量 $\\mu'$ 由下式给出：\n$$ \\mu'(r, h_L, h_R, \\sigma) = \\begin{cases} \\sigma  \\text{if } r = 0 \\\\ \\omega^{r-1} \\cdot k + \\sigma  \\text{if } r \\ge 1 \\end{cases} $$\n其中 $k = h_L \\cdot h_R + h_L + h_R + 1$。整数 $k$ 组合地反映了新引入的、更低秩的切的数量和复杂性。当归约一个秩 $r \\ge 1$ 的切时，主公式被分解，子推导被复制，导致多个秩为 $r-1$ 的切。$k$ 的值界定了这个新配置的复杂性。\n\n**4. 序数减少的验证**\n\n我们必须证明 $\\mu'  \\mu$。我们分析 $r$ 的两种情况。\n\n**情况1：$r \\ge 1$**\n在这种情况下，度量为：\n$$ \\mu = \\omega^r \\cdot (h_L + h_R) + \\sigma $$\n$$ \\mu' = \\omega^{r-1} \\cdot k + \\sigma $$\n一个非平凡的切意味着其前提的推导不是空的，即 $h_L$ 或 $h_R$ 至少有一个为正。所有测试用例都满足 $h_L+h_R > 0$。在这个条件下，$\\mu$ 中 $\\omega^r$ 项的系数 $(h_L+h_R)$ 是一个正整数。\n\n$\\mu$ 的 CNF 是 $\\mu = \\omega^r \\cdot (h_L + h_R) + (\\text{指数小于 } r \\text{ 的项})$。它的首项指数是 $r$。\n度量 $\\mu'$ 是 $\\omega^{r-1} \\cdot k$ 和 $\\sigma$ 的序数和。$\\sigma$ 中的指数都小于 $r$。因此，在执行加法并归一化为 CNF 后，$\\mu'$ 中可能的最大指数是 $\\max(r-1, \\sigma \\text{ 的指数})$。由于 $\\sigma$ 中的所有指数都小于 $r$，这个最大值是 $r-1$。\n所以，$\\mu$ 的首项指数是 $r$，而 $\\mu'$ 的首项指数是 $r-1$。\n根据序数比较的定义，由于 $r-1  r$，立即得出 $\\mu'  \\mu$。\n\n**情况2：$r = 0$**\n一个秩为 0 的切是作用于原子公式的切。这是归约的基例。$\\mu'$ 的规则指定该切被完全移除：\n$$ \\mu = \\omega^0 \\cdot (h_L + h_R) + \\sigma = 1 \\cdot (h_L + h_R) + \\sigma = (h_L+h_R) + \\sigma $$\n$$ \\mu' = \\sigma $$\n给定一个非平凡的切，$h_L+h_R > 0$。由于序数加法通常不满足交换律，我们必须精确。项 $(h_L+h_R)$ 是形式为 $\\omega^0 \\cdot (h_L+h_R)$ 的序数。由于 $\\sigma$ 中的最小指数可以是 0（但根据问题条件 $e_i  r$，当 $r=0$ 时，$\\sigma$ 必须是 0），所以我们有 $\\mu = (h_L+h_R)$ 且 $\\mu' = 0$。只要 $h_L+h_R > 0$，就有 $\\mu'  \\mu$。\n\n**测试用例分析**\n\n所有测试用例都属于 $r \\ge 1$ 的情况。\n\n- **案例 A:** $r=3, h_L+h_R = 5 > 0$。$\\mu$ 的首项是 $\\omega^3 \\cdot 5$。$\\mu'$ 的首项是 $\\omega^2 \\cdot k$ (其中 $k = 6+2+3+1 = 12$)。由于首项指数 $2  3$，$\\mu'  \\mu$。结果为 `True`。\n- **案例 B:** $r=1, h_L+h_R = 2 > 0$。$\\mu$ 的首项是 $\\omega^1 \\cdot 2$。$\\mu'$ 的首项是 $\\omega^0 \\cdot k$ (其中 $k = 1+1+1+1 = 4$)。由于首项指数 $0  1$，$\\mu'  \\mu$。结果为 `True`。\n- **案例 C:** $r=5, h_L+h_R = 5 > 0$。$\\mu$ 的首项是 $\\omega^5 \\cdot 5$。$\\mu'$ 的首项是 $\\omega^4 \\cdot k$ (其中 $k = 4+4+1+1 = 10$)。由于首项指数 $4  5$，$\\mu'  \\mu$。结果为 `True`。\n- **案例 D:** $r=2, h_L+h_R = 5 > 0$。$\\mu$ 的首项是 $\\omega^2 \\cdot 5$。$\\mu'$ 的首项是 $\\omega^1 \\cdot k$ (其中 $k = 0+0+5+1 = 6$)。由于首项指数 $1  2$，$\\mu'  \\mu$。结果为 `True`。\n\n所有测试用例都验证了度量是严格递减的。因此，预期输出是 `[True,True,True,True]`。提供的 Python 代码实现了这个逻辑，并且应该会产生这个输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of verifying ordinal decrease in a simulated\n    cut-elimination step for Peano Arithmetic.\n    \"\"\"\n\n    class Ordinal:\n        \"\"\"\n        Represents an ordinal below omega^omega in Cantor Normal Form.\n        The ordinal is stored as a list of (exponent, coefficient) tuples,\n        sorted in descending order of exponents. Exponents are integers.\n        \"\"\"\n        def __init__(self, terms=None):\n            \"\"\"\n            Initializes an Ordinal object.\n            Args:\n                terms (list, optional): A list of (exponent, coefficient) tuples.\n                                        Defaults to an empty list, representing the ordinal 0.\n            \"\"\"\n            if terms is None:\n                self.terms = []\n            else:\n                self.terms = self._normalize(terms)\n\n        @staticmethod\n        def _normalize(terms):\n            \"\"\"\n            Normalizes a list of terms into Cantor Normal Form:\n            1. Filters out terms with zero or negative coefficients.\n            2. Sorts terms by exponent in descending order.\n            3. Merges terms with identical exponents by summing their coefficients.\n            \"\"\"\n            # Filter terms with positive coefficients\n            filtered_terms = [t for t in terms if t[1] > 0]\n            if not filtered_terms:\n                return []\n\n            # Sort by exponent, descending\n            filtered_terms.sort(key=lambda t: t[0], reverse=True)\n\n            # Merge terms with same exponent\n            if len(filtered_terms) = 1:\n                return filtered_terms\n\n            merged = []\n            current_exp, current_coeff = filtered_terms[0]\n\n            for next_exp, next_coeff in filtered_terms[1:]:\n                if next_exp == current_exp:\n                    current_coeff += next_coeff\n                else:\n                    merged.append((current_exp, current_coeff))\n                    current_exp, current_coeff = next_exp, next_coeff\n            \n            merged.append((current_exp, current_coeff))\n            return merged\n\n        def __add__(self, other):\n            \"\"\"\n            Implements ordinal addition.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            # Concatenate term lists and re-normalize\n            new_terms = self.terms + other.terms\n            return Ordinal(new_terms)\n\n        def __lt__(self, other):\n            \"\"\"\n            Implements strict less-than comparison () for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            \n            terms1 = self.terms\n            terms2 = other.terms\n            \n            i, j = 0, 0\n            while i  len(terms1) and j  len(terms2):\n                exp1, coef1 = terms1[i]\n                exp2, coef2 = terms2[j]\n\n                if exp1  exp2:\n                    return True  # self is smaller\n                if exp1 > exp2:\n                    return False  # self is larger\n\n                # Exponents are equal, compare coefficients\n                if coef1  coef2:\n                    return True  # self is smaller\n                if coef1 > coef2:\n                    return False  # self is larger\n\n                # Terms are identical, move to the next\n                i += 1\n                j += 1\n            \n            # One list is exhausted. If self is exhausted but other is not, self is smaller.\n            if i == len(terms1) and j  len(terms2):\n                return True\n            \n            # If other is exhausted, or both are, self is not strictly smaller.\n            return False\n\n        def __eq__(self, other):\n            \"\"\"\n            Implements equality comparison (==) for ordinals.\n            \"\"\"\n            if not isinstance(other, Ordinal):\n                return NotImplemented\n            return self.terms == other.terms\n\n        def __repr__(self):\n            \"\"\"\n            Provides a string representation for debugging purposes.\n            \"\"\"\n            if not self.terms:\n                return \"0\"\n            return \" + \".join([f\"w^{e}*{c}\" for e, c in self.terms])\n\n    def construct_mu(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the ordinal measure mu = omega^r * (hL + hR) + sigma.\n        \"\"\"\n        h_sum = hL + hR\n        sigma_ord = Ordinal(sigma_list)\n        \n        if h_sum > 0:\n            term_r = Ordinal([(r, h_sum)])\n            return term_r + sigma_ord\n        else:\n            return sigma_ord\n\n    def construct_mu_prime(r, hL, hR, sigma_list):\n        \"\"\"\n        Constructs the reduced ordinal measure mu'.\n        \"\"\"\n        sigma_ord = Ordinal(sigma_list)\n\n        if r == 0:\n            # For r=0, the cut is removed, the measure becomes sigma.\n            # The prompt condition e_i  r means sigma_list should be empty.\n            # We follow the formula mu' = sigma.\n            return sigma_ord\n        \n        # For r >= 1\n        k = hL * hR + hL + hR + 1\n        \n        if k > 0:\n            term_r_minus_1 = Ordinal([(r - 1, k)])\n            return term_r_minus_1 + sigma_ord\n        else:\n            # k is only 0 if hL, hR are not non-negative integers.\n            # For hL, hR in N, k >= 1.\n            return sigma_ord\n\n    test_cases = [\n        # Case A: r=3, hL=2, hR=3, sigma=[(2,1), (1,4)]\n        (3, 2, 3, [(2, 1), (1, 4)]),\n        # Case B: r=1, hL=1, hR=1, sigma=[]\n        (1, 1, 1, []),\n        # Case C: r=5, hL=4, hR=1, sigma=[(3,2), (2,1), (1,7)]\n        (5, 4, 1, [(3, 2), (2, 1), (1, 7)]),\n        # Case D: r=2, hL=0, hR=5, sigma=[(1,1), (0,10)]\n        (2, 0, 5, [(1, 1), (0, 10)]),\n    ]\n\n    results = []\n    for r, hL, hR, sigma_list in test_cases:\n        mu = construct_mu(r, hL, hR, sigma_list)\n        mu_prime = construct_mu_prime(r, hL, hR, sigma_list)\n        results.append(mu_prime  mu)\n\n    # Format output as a single line: [result1,result2,...]\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n```", "id": "2978413"}]}