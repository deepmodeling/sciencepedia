{"hands_on_practices": [{"introduction": "本练习将介绍一个型无法被实现的最根本原因：逻辑上的不一致性。通过一个简单的有限全域的例子，你将具体理解一组条件（一个型）如何与一个理论的公理发生冲突，从而使其变得无法满足。[@problem_id:2981066]", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，由等号 $=$ 和常数符号 $c_{1}, c_{2}, \\dots, c_{7}$ 构成。考虑语言 $\\mathcal{L}$ 中的理论 $T_{7}$，其公理为：\n- 一阶逻辑的等价公理。\n- 常数的两两相异性：$\\bigwedge_{1 \\leq i  j \\leq 7} c_{i} \\neq c_{j}$。\n- 常数对论域的覆盖性：$\\forall y\\, \\bigvee_{i=1}^{7} y = c_{i}$。\n\n将 $T_{7}$ 上的部分型 $p(x)$ 定义为\n$$\np(x) \\;=\\; \\{\\, x \\neq c_{i} \\mid i = 1,2,\\dots,7 \\,\\}.\n$$\n\n仅使用模型论中的基础定义（型、部分型、理论中的相容性以及紧致性定理），确定有限子集 $p_{0}(x) \\subseteq p(x)$ 的最小基数 $k$，使得 $p_{0}(x)$ 与 $T_{7}$ 不相容（即不存在 $T_{7}$ 的模型以及解释 $x$ 的元素能够同时满足 $p_{0}(x)$ 中的所有公式）。请以单个整数的形式给出最终答案。无需四舍五入。", "solution": "题目要求找到一个与理论 $T_7$ 不相容的有限子集 $p_0(x) \\subseteq p(x)$ 的最小基数 $k$。\n\n首先，我们必须精确理解理论 $T_7$ 及其模型。语言 $\\mathcal{L}$ 由等号和七个常数符号 $c_1, c_2, \\dots, c_7$ 构成。$T_7$ 的公理如下：\n1. 一阶逻辑中等价关系的标准公理。\n2. 两两相异性公理：$\\bigwedge_{1 \\leq i  j \\leq 7} c_{i} \\neq c_{j}$。该公理确保在任何模型中，这七个常数符号的解释都两两相异。\n3. 论域覆盖公理：$\\forall y\\, \\bigvee_{i=1}^{7} y = c_{i}$。该公理指出，任何模型的论域中的每个元素都必须是常数符号 $c_1, \\dots, c_7$ 之一的解释。\n\n总之，这些公理精确地刻画了任何 $T_7$ 模型的结构。任何 $T_7$ 的模型 $\\mathcal{M}$ 必须有一个论域（全集）$M$，该论域恰好由七个不同的元素构成，这些元素是常数符号的解释。也就是说，$M = \\{c_1^{\\mathcal{M}}, c_2^{\\mathcal{M}}, \\dots, c_7^{\\mathcal{M}}\\}$ 并且对于任何 $i \\neq j$，都有 $c_i^{\\mathcal{M}} \\neq c_j^{\\mathcal{M}}$。\n\n接下来，我们考虑部分型 $p(x)$，定义为 $p(x) = \\{ x \\neq c_i \\mid i = 1, 2, \\dots, 7 \\}$。这是一个包含 7 个公式的集合，其中 $x$ 是唯一的自由变元。\n\n问题的核心在于不相容性的定义。如果 $T$ 的任何模型都不能实现部分型 $q(x)$，则称 $q(x)$ 与理论 $T$ 不相容。如果在 $T$ 的模型 $\\mathcal{M}$ 的论域中存在一个元素 $a$，使得对于 $q(x)$ 中的每一个公式 $\\phi(x)$，陈述 $\\phi(a)$ 在 $\\mathcal{M}$ 中都为真（记作 $\\mathcal{M} \\models \\phi(a)$），则称模型 $\\mathcal{M}$ 实现了 $q(x)$。\n因此，为了找到最小基数 $k$，我们必须找到最小的整数 $m$，使得大小为 $m$ 的子集 $p_0(x) \\subseteq p(x)$ 在 $T_7$ 的任何模型中都不能被实现。\n\n让我们测试 $p(x)$ 的基数递增的子集。设 $p_0(x)$ 是 $p(x)$ 的一个子集，其基数为 $|p_0(x)| = m$。$p_0(x)$ 中的公式形如 $x \\neq c_i$。设 $I \\subseteq \\{1, 2, \\dots, 7\\}$ 是索引集，使得 $p_0(x) = \\{ x \\neq c_i \\mid i \\in I \\}$。$p_0(x)$ 的基数是 $m = |I|$。\n\n**情况 1：$m  7$**\n假设 $p_0(x)$ 的基数是 $m  7$。这意味着索引集 $I$ 是 $\\{1, 2, \\dots, 7\\}$ 的一个真子集。因此，必定存在至少一个索引 $j \\in \\{1, 2, \\dots, 7\\}$ 使得 $j \\notin I$。\n为了检查 $p_0(x)$ 是否与 $T_7$ 相容，我们必须确定是否存在一个模型 $\\mathcal{M} \\models T_7$ 及其论域 $M$ 中的一个元素 $a$ 来实现 $p_0(x)$。\n设 $\\mathcal{M}$ 是 $T_7$ 的任意一个模型。其论域为 $M = \\{ c_1^{\\mathcal{M}}, \\dots, c_7^{\\mathcal{M}} \\}$。我们从这个论域中选择一个元素 $a$。我们选择 $a = c_j^{\\mathcal{M}}$，其中 $j$ 是一个不在 $I$ 中的索引。\n为了实现 $p_0(x)$，元素 $a$ 必须满足 $p_0(x)$ 中的所有公式 $\\phi(x)$。这意味着对于所有 $i \\in I$，我们必须有 $\\mathcal{M} \\models a \\neq c_i$。代入我们选择的 $a$，我们必须验证对于所有 $i \\in I$，是否有 $\\mathcal{M} \\models c_j^{\\mathcal{M}} \\neq c_i^{\\mathcal{M}}$。\n因为 $j \\notin I$，所以对于所有 $i \\in I$，我们有 $j \\neq i$。$T_7$ 中的两两相异性公理指出，对于任何 $i' \\neq j'$，都有 $c_{i'} \\neq c_{j'}$。该公理保证了对于所有 $i \\in I$，都有 $c_j^{\\mathcal{M}} \\neq c_i^{\\mathcal{M}}$。\n因此，元素 $a = c_j^{\\mathcal{M}}$ 实现了 $p_0(x)$。因为我们可以在 $T_7$ 的任何模型中找到这样一个元素，所以任何基数 $m  7$ 的 $p(x)$ 的子集 $p_0(x)$ 都与 $T_7$ 相容。\n这意味着一个不相容子集的最小基数 $k$ 必须至少为 $7$。\n\n**情况 2：$m = 7$**\n现在，考虑一个基数为 $m=7$ 的子集 $p_0(x) \\subseteq p(x)$。由于 $p(x)$ 本身有 7 个元素，所以唯一的这样的子集就是 $p(x)$ 本身。因此，$p_0(x) = p(x) = \\{ x \\neq c_i \\mid i = 1, 2, \\dots, 7 \\}$。\n我们来检验其不相容性。假设，为了引出矛盾， $p_0(x)$ 与 $T_7$ 相容。\n这个假设意味着存在一个模型 $\\mathcal{M} \\models T_7$ 和一个元素 $a \\in M$ 实现了 $p_0(x)$。\n实现 $p_0(x)$ 要求对于所有 $i \\in \\{1, 2, \\dots, 7\\}$，都有 $\\mathcal{M} \\models a \\neq c_i$。\n然而， $\\mathcal{M}$ 是 $T_7$ 的一个模型，因此它必须满足 $T_7$ 的所有公理。特别地，它必须满足论域覆盖公理：$\\forall y \\bigvee_{i=1}^{7} y = c_{i}$。\n将此公理应用于元素 $a \\in M$，则必须有 $\\mathcal{M} \\models \\bigvee_{i=1}^{7} a = c_{i}$ 为真。这表明 $a$ 必须等于元素 $c_1^{\\mathcal{M}}, \\dots, c_7^{\\mathcal{M}}$ 中的至少一个。\n因此，存在某个索引 $j \\in \\{1, 2, \\dots, 7\\}$，使得 $a = c_j^{\\mathcal{M}}$。\n这个结论 $a = c_j^{\\mathcal{M}}$ 与实现 $p_0(x)$ 的要求直接矛盾，该要求是对于所有的 $i$（包括 $i=j$），都有 $a \\neq c_i^{\\mathcal{M}}$。\n这个矛盾意味着我们最初的假设是错误的。在 $T_7$ 的任何模型中都不可能存在这样的元素 $a$。\n因此，基数为 7 的集合 $p_0(x)$ 与 $T_7$ 不相容。\n\n综合两种情况的结果：\n- 任何基数小于 7 的 $p(x)$ 的子集都与 $T_7$ 相容。\n- 基数为 7 的 $p(x)$ 的子集与 $T_7$ 不相容。\n\n因此，与 $T_7$ 不相容的 $p(x)$ 的有限子集的最小基数 $k$ 为 $7$。题目陈述中对紧致性定理的引用，是为了将问题置于模型论的标准框架之下，在该框架下，一个可能无限的型的不相容性等价于其某个有限子集的不相容性。在这个问题中，完整的型 $p(x)$ 本身就是有限的，这使得分析更为直接。", "answer": "$$\\boxed{7}$$", "id": "2981066"}, {"introduction": "在简单的“不一致性”之外，本练习将探索一个更微妙的情形：一个型是一致的，但在某个特定模型中却未被实现。利用有限二元序列的结构，我们将构造一个“有限可满足”却被该模型“省略”的型，这揭示了给定结构的局限性，并引出了省略型定理的核心问题。[@problem_id:2981087]", "problem": "设 $L$ 是带有一个二元关系符号 $\\preceq$ 的语言，并设 $\\mathcal{M}=(2^{\\omega},\\preceq)$ 是一个结构，其论域为所有有限 0-1 序列的集合 $2^{\\omega}$，并由前缀关系排序：对于 $s,t\\in 2^{\\omega}$，$s\\preceq t$ 成立当且仅当 $s$ 是 $t$ 的一个前缀。设 $A$ 是 $\\mathcal{M}$ 的基集。考虑通过为 $A$ 中的每个元素添加一个常数符号而得到的扩充 $L(A)$，在书写公式时，我们将这些常数符号与 $A$ 中对应的元素等同看待。\n\n对于每个无限二进制序列（分支）$b\\in 2^{\\omega}$，定义变量 $x$ 中的 $A$-型 $p_b(x)$ 如下\n$$\np_b(x)\\;=\\;\\bigl\\{\\, s\\preceq x \\;\\mid\\; s\\in 2^{\\omega}\\text{ and } s \\text{ 是 } b \\text{ 的一个前缀} \\,\\bigr\\},\n$$\n视为一个 $L(A)$-公式集合，其中参数 $s\\in A$ 出现在原子公式 $s\\preceq x$ 中。\n\n任务：\n1) 仅从模型中型、实现和有限可满足性的核心定义出发，证明对于每个 $b\\in 2^{\\omega}$，型 $p_b(x)$ 在 $\\mathcal{M}$ 中是有限可满足的（也就是说，$p_b(x)$ 的每个有限子集都在 $\\mathcal{M}$ 中被实现），但在 $\\mathcal{M}$ 中没有被实现。\n\n2) 对于每个 $n\\in\\mathbb{N}$，定义 $N(n)$ 为形如\n$$\nF_{b,n}(x)\\;=\\;\\bigl\\{\\, b\\upharpoonright k \\preceq x \\;\\mid\\; k=0,1,\\dots,n-1 \\,\\bigr\\},\n$$\n的、在 $\\mathcal{M}$ 中被实现的、成对不同的有限片段的数量，其中 $b\\upharpoonright k$ 是 $b$ 的长度为 $k$ 的前缀。计算指数增长率\n$$\nL\\;=\\;\\lim_{n\\to\\infty} \\bigl(N(n)\\bigr)^{1/n}.\n$$\n\n您的最终答案必须是 $L$ 的精确值的单个封闭形式表达式。不需要近似或四舍五入。您的最终答案应不带单位。", "solution": "这个问题分为两部分。我将依次解决每一部分。\n\n语言是 $L=\\{\\preceq\\}$，结构是 $\\mathcal{M}=(A, \\preceq^{\\mathcal{M}})$，其中论域 $A=2^{\\omega}$ 是所有有限二进制序列的集合，且 $s \\preceq^{\\mathcal{M}} t$ 成立当且仅当 $s$ 是 $t$ 的一个前缀。我们考虑语言 $L(A)$，它为 $A$ 的每个元素增加了一个常数符号。对于一个无限二进制序列 $b \\in 2^\\omega$，型 $p_b(x)$ 是 $L(A)$-公式的集合 $p_b(x) = \\{ s \\preceq x \\mid s \\in 2^{\\omega} \\text{ and } s \\text{ is a prefix of } b \\}$。\n\n**第 1 部分：型 $p_b(x)$ 的性质验证**\n\n首先，我们证明对于任何 $b \\in 2^\\omega$，型 $p_b(x)$ 在 $\\mathcal{M}$ 中是有限可满足的。\n如果一个型的每个有限子集都在该结构中被实现，则称该型在该结构中是有限可满足的。设 $p_0(x)$ 是 $p_b(x)$ 的一个任意有限子集。根据 $p_b(x)$ 的定义，$p_0(x)$ 必具有形式 $\\{s_1 \\preceq x, s_2 \\preceq x, \\dots, s_m \\preceq x\\}$，对于某个有限整数 $m > 0$，其中每个 $s_j$ (对于 $j \\in \\{1, \\dots, m\\}$) 都是无限序列 $b$ 的一个前缀。设 $|s_j|$ 表示有限序列 $s_j$ 的长度。令 $k_{max} = \\max\\{|s_1|, |s_2|, \\dots, |s_m|\\}$。设 $s_{max}$ 是 $b$ 的长度为 $k_{max}$ 的前缀。由于每个 $s_j$ 都是 $b$ 的前缀，且 $|s_j| \\le k_{max}$，因此每个 $s_j$ 都是 $s_{max}$ 的前缀。也就是说，对于所有 $j \\in \\{1, \\dots, m\\}$，都有 $s_j \\preceq s_{max}$。\n\n为了证明 $p_0(x)$ 在 $\\mathcal{M}$ 中被实现，我们必须找到一个元素 $a \\in A = 2^{\\omega}$，使得对于所有 $j \\in \\{1, \\dots, m\\}$，都有 $\\mathcal{M} \\models s_j \\preceq a$。我们选择 $a = s_{max}$。由于 $s_{max}$ 是 $b$ 的一个有限前缀，它是 $2^{\\omega}$ 的一个元素，所以 $a \\in A$。条件 $s_j \\preceq a$ 变为 $s_j \\preceq s_{max}$，我们已经确定这对所有 $j \\in \\{1, \\dots, m\\}$ 都成立。因此，元素 $a = s_{max}$ 实现了公式集 $p_0(x)$。由于 $p_0(x)$ 是 $p_b(x)$ 的一个任意有限子集，我们得出结论，型 $p_b(x)$ 在 $\\mathcal{M}$ 中是有限可满足的。\n\n其次，我们证明 $p_b(x)$ 在 $\\mathcal{M}$ 中没有被实现。\n为了证明这一点，我们必须说明不存在单个元素 $a \\in A$ 能同时满足 $p_b(x)$ 中的所有公式。我们假设，为了引出矛盾，存在这样一个元素 $a \\in A = 2^{\\omega}$。设 $|a|$ 是这个有限序列 $a$ 的长度。由于 $a \\in 2^{\\omega}$，$|a|$ 是一个有限的自然数。\n\n如果 $a$ 实现了 $p_b(x)$，那么对于 $p_b(x)$ 中的每个公式 $(s \\preceq x)$，都必须有 $\\mathcal{M} \\models s \\preceq a$。公式集 $p_b(x)$ 对 $b$ 的每个前缀 $s$ 都包含 $s \\preceq x$。$b$ 的前缀是对于每个自然数 $k \\in \\mathbb{N}=\\{0, 1, 2, \\dots\\}$ 的序列 $b\\upharpoonright k$。\n所以，对于我们的实现元素 $a$，必须对所有的 $k \\in \\mathbb{N}$ 都有 $b\\upharpoonright k \\preceq a$。\n关系 $s \\preceq t$ 意味着 $s$ 的长度小于或等于 $t$ 的长度，即 $|s| \\le |t|$。将此应用于我们的情况，我们必须有 $|b\\upharpoonright k| \\le |a|$ 对所有 $k \\in \\mathbb{N}$ 成立。\n前缀 $b\\upharpoonright k$ 的长度是 $k$。所以，该条件变为对所有 $k \\in \\mathbb{N}$ 都有 $k \\le |a|$。\n这意味着所有自然数的集合 $\\mathbb{N}$ 被有限数 $|a|$ 上界。这是一个矛盾，因为自然数集是无界的。\n因此，我们的初始假设必定是错误的。在 $2^{\\omega}$ 中不可能存在这样的元素 $a$，所以型 $p_b(x)$ 在 $\\mathcal{M}$ 中没有被实现。\n\n**第 2 部分：指数增长率 $L$ 的计算**\n\n我们需要计算 $L = \\lim_{n\\to\\infty} (N(n))^{1/n}$，其中 $N(n)$ 是被实现的、不同的有限片段 $F_{b,n}(x) = \\{b\\upharpoonright k \\preceq x \\mid k = 0, 1, \\dots, n-1\\}$ 的数量。\n\n首先，让我们确定当 $b$ 遍历所有 $2^\\omega$ 时，不同的片段 $F_{b,n}(x)$ 的数量。一个片段 $F_{b,n}(x)$ 是一个包含 $n$ 个公式的集合。这个集合完全由前缀集合 $\\{b\\upharpoonright 0, b\\upharpoonright 1, \\dots, b\\upharpoonright(n-1)\\}$ 决定。由于这些前缀构成一个链（对于 $i \\le j$，有 $b\\upharpoonright i \\preceq b\\upharpoonright j$），这个前缀集合由其最长的元素 $b\\upharpoonright(n-1)$ 唯一指定。\n因此，两个片段 $F_{b_1, n}(x)$ 和 $F_{b_2, n}(x)$ 相等当且仅当 $b_1\\upharpoonright(n-1) = b_2\\upharpoonright(n-1)$。不同片段 $F_{b,n}(x)$ 的数量因此等于长度为 $n-1$ 的不同二进制序列的数量。一个长度为 $n-1$ 的二进制序列是一个由 $n-1$ 个比特组成的字符串，每个比特可以是 0 或 1。这样的序列总数为 $2^{n-1}$。\n\n接下来，我们确定这 $2^{n-1}$ 个不同片段中有哪些在 $\\mathcal{M}$ 中被实现。一个片段 $F_{b,n}(x)$ 被实现，如果存在一个元素 $a \\in 2^{\\omega}$ 使得对于所有 $k \\in \\{0, 1, \\dots, n-1\\}$，都有 $\\mathcal{M} \\models b\\upharpoonright k \\preceq a$。\n由于前缀的链属性，这组 $n$ 个条件等价于单个条件，即最长的前缀是 $a$ 的一个前缀。也就是说，我们需要找到一个 $a \\in 2^{\\omega}$ 使得 $b\\upharpoonright(n-1) \\preceq a$。\n设 $s = b\\upharpoonright(n-1)$。问题简化为：对于任何有限二进制序列 $s$，是否存在一个 $a \\in 2^{\\omega}$ 使得 $s \\preceq a$？\n答案是肯定的。我们可以简单地选择 $a = s$。由于 $s$ 是一个有限序列，它是 $2^{\\omega}$ 的一个元素。条件 $s \\preceq a$ 变为 $s \\preceq s$，根据前缀关系的定义（任何序列都是其自身的前缀），这是成立的。\n这表明对于任何 $b \\in 2^\\omega$，片段 $F_{b,n}(x)$ 都在 $\\mathcal{M}$ 中被实现。因此，所有 $2^{n-1}$ 个不同的片段都被实现。\n所以，被实现的、不同的片段数量为 $N(n) = 2^{n-1}$。\n\n最后，我们计算极限 $L$：\n$$L = \\lim_{n\\to\\infty} \\bigl(N(n)\\bigr)^{1/n} = \\lim_{n\\to\\infty} \\left(2^{n-1}\\right)^{1/n}$$\n我们可以简化极限内的表达式：\n$$L = \\lim_{n\\to\\infty} 2^{\\frac{n-1}{n}} = \\lim_{n\\to\\infty} 2^{1 - \\frac{1}{n}}$$\n由于函数 $f(y) = 2^y$ 处处连续，我们可以将极限移入函数内部：\n$$L = 2^{\\lim_{n\\to\\infty} \\left(1 - \\frac{1}{n}\\right)}$$\n指数的极限是：\n$$\\lim_{n\\to\\infty} \\left(1 - \\frac{1}{n}\\right) = 1 - 0 = 1$$\n将此代回，我们得到 $L$ 的值：\n$$L = 2^1 = 2$$\n指数增长率为 $2$。", "answer": "$$\\boxed{2}$$", "id": "2981087"}, {"introduction": "最后一个练习深入探讨了主型与非主型之间的关键区别，这个区别决定了一个型是否可以被省略。我们将看到，这个性质不是绝对的，而是相对于参数集而言的。通过展示一个非主型（即可省略的型）如何通过简单地添加一个新参数而被“强制”变成主型（即不可省略的型），你将掌握模型构造中的一个强大技巧。[@problem_id:2981073]", "problem": "设 $T$ 是环语言 $\\mathcal{L}=\\{+, \\cdot, 0, 1\\}$ 中特征为 $0$ 的代数闭域 (ACF) 的完全理论。我们在一个充分饱和且强齐次的怪兽模型 $\\mathfrak{C} \\models T$ 中进行讨论。回顾：一个在参数集 $A$ 上的完全 $1$-型 $p(x)$ 被称为主型（或称孤立型），如果存在一个带 $A$ 中参数的单一公式 $\\varphi(x)\\in p(x)$，使得对于任意一个带 $A$ 中参数的公式 $\\psi(x)$，都有 $T \\vdash \\forall x(\\varphi(x) \\rightarrow \\psi(x))$ 或 $T \\vdash \\forall x(\\varphi(x) \\rightarrow \\neg \\psi(x))$。\n\n设 $A=\\emptyset$，并设 $p(x)=\\operatorname{tp}(t/\\emptyset)$ 是一个在素域上的超越元 $t \\in \\mathfrak{C}$ 在 $\\emptyset$ 上的完全 $1$-型。仅使用基本定义和关于代数闭域的标准事实（例如量词消去，以及域中带 $\\emptyset$ 参数的单自由变元可定义子集是有限或余有限的），完成以下任务：\n\n1. 证明 $p(x)$ 在 $\\emptyset$ 上不是主型。\n2. 给出一个显式的参数集 $B \\supseteq \\emptyset$，使得 $p(x)$ 到 $S_{1}(B)$ 的一个扩张是主型，并证明该扩张确实是主型。\n3. 确定一个参数集 $B \\supseteq \\emptyset$ 的最小基数 $\\kappa$，该参数集需满足以下性质：$p(x)$ 到 $S_{1}(B)$ 的某个扩张是主型。换言之，计算\n$$\n\\kappa \\;=\\; \\min\\bigl\\{\\,|B| \\,:\\, p(x)\\text{ 的某个扩张 } q(x)\\in S_{1}(B) \\text{ 是主型}\\,\\bigr\\}。\n$$\n4. 简要讨论这一现象对略去型策略的影响，对比在 $A=\\emptyset$ 上的情况和在这样一个 $B$ 上的情况。\n\n将最小基数 $\\kappa$ 作为你的最终答案。你的最终答案必须是一个整数。不需要四舍五入。不要包含任何单位。", "solution": "该问题要求分析特征为零的代数闭域理论 $T = \\text{ACF}_0$ 中超越元的型。我们已知 $T$ 具有量词消去性质，并且其在空集 $\\emptyset$ 上单变元的可定义子集是有限或余有限的。设 $p(x) = \\operatorname{tp}(t/\\emptyset)$，其中 $t$ 是怪兽模型 $\\mathfrak{C}$ 中的一个元素，它在素域 $\\mathbb{Q}$ 上是超越的。\n\n1. 证明 $p(x)$ 在 $\\emptyset$ 上不是主型。\n\n一个完全型是主型，如果它被单个公式所孤立。为寻求矛盾，假设 $p(x)$ 是 $\\emptyset$ 上的一个主型。这意味着存在一个带 $\\emptyset$ 中参数（即整数系数）的公式 $\\varphi(x)$，使得 $\\varphi(x) \\in p(x)$，并且对于 $\\emptyset$ 上的任何其他公式 $\\psi(x)$，若 $\\psi(x) \\in p(x)$，则 $T \\vdash \\forall x(\\varphi(x) \\rightarrow \\psi(x))$。\n\n设 $X$ 是由 $\\varphi(x)$ 在 $\\mathfrak{C}$ 中定义的元素集合，即 $X = \\{a \\in \\mathfrak{C} : \\mathfrak{C} \\models \\varphi(a)\\}$。\n由于 $\\varphi(x)$ 孤立了 $p(x)$，$X$ 中的任何元素 $a$ 都必须实现 $p(x)$。一个元素实现 $p(x)$ 当且仅当它在 $\\mathbb{Q}$ 上是超越的。要理解这一点，考虑任意非零多项式 $P(y) \\in \\mathbb{Q}[y]$。由于 $t$ 是超越的，公式 $P(y) \\neq 0$ 在 $p(x)$ 中。如果 $a \\in X$ 实现 $p(x)$，那么 $a$ 必须满足 $P(a) \\neq 0$。这对所有非零多项式 $P(y) \\in \\mathbb{Q}[y]$ 都成立，而这正是在 $\\mathbb{Q}$ 上 $a$ 是超越元的定义。因此，集合 $X$ 只能包含在 $\\mathbb{Q}$ 上超越的元素。\n\n我们已知任何在单变元中的 $\\emptyset$-可定义集是有限或余有限的。因此，$X$ 要么是有限的，要么是余有限的。\n\n情况1：$X$ 是有限的。在一个代数闭域中，一个 $\\emptyset$-可定义的有限集 $\\{c_1, \\dots, c_n\\}$ 必须由在素域 $\\mathbb{Q}$ 上是代数的元素组成。这是因为 $\\mathfrak{C}$ 在 $\\emptyset$ 上的任何自同构都必须将 $X$ 映到自身。如果 $X$ 中的某个元素 $c \\in X$ 是超越的，它在固定 $\\mathbb{Q}$ 的自同构下的轨道将是无限的，这与 $X$ 是有限的相矛盾。因此，如果 $X$ 是有限的，它必须只包含代数元。这与我们发现的 $X$ 必须只包含超越元相矛盾。\n\n情况2：$X$ 是余有限的。一个余有限集的形式为 $\\mathfrak{C} \\setminus F$，其中 $F$ 是一个有限集。在 $\\mathbb{Q}$ 上的所有代数元的集合，记作 $\\mathbb{Q}^{\\text{alg}}$，是一个无限集。由于 $F$ 是有限的，集合 $X = \\mathfrak{C} \\setminus F$ 必须包含除了有限个代数元之外的所有代数元。特别地，$X$ 必须包含无限多个代数元。这再次与 $X$ 只能包含超越元的事实相矛盾。\n\n由于两种情况都导致了矛盾，我们的初始假设必定是错误的。型 $p(x)$ 不能被 $\\emptyset$ 上的任何公式所孤立，因此不是主型。\n\n2. 找出一个参数集 $B$ 和一个主扩张。\n\n设 $t$ 是用于定义 $p(x) = \\operatorname{tp}(t/\\emptyset)$ 的超越元。我们选择参数集 $B = \\{t\\}$。现在，考虑 $t$ 在这个新参数集上的完全 $1$-型，我们将其记为 $q(x) = \\operatorname{tp}(t/B) = \\operatorname{tp}(t/\\{t\\})$。\n\n根据定义，一个在 $B$ 上的公式 $\\psi(x)$ 在 $q(x)$ 中当且仅当 $\\mathfrak{C} \\models \\psi(t)$。一个在 $\\emptyset$ 上的公式也是一个在 $B$ 上的公式。因此，如果 $\\varphi(x) \\in p(x)$，那么 $\\mathfrak{C} \\models \\varphi(t)$，这意味着 $\\varphi(x) \\in q(x)$。因此，$p(x) \\subseteq q(x)$，并且 $q(x)$ 是 $p(x)$ 到 $S_1(B)$ 的一个扩张。\n\n现在，我们证明 $q(x)$ 是主型。考虑由 $x=t$ 给出的公式 $\\chi(x)$。这个公式有一个参数 $t$，它在 $B$ 中。由于 $t=t$ 是真的，所以 $\\chi(x) \\in q(x)$。我们断言 $\\chi(x)$ 孤立了 $q(x)$。\n\n为了证明这一点，我们必须验证对于任何带 $B$ 中参数的公式 $\\theta(x)$，要么 $T \\vdash \\forall x(\\chi(x) \\rightarrow \\theta(x))$，要么 $T \\vdash \\forall x(\\chi(x) \\rightarrow \\neg\\theta(x))$。\n陈述 $T \\vdash \\forall x(x=t \\rightarrow \\theta(x))$ 在逻辑上等价于 $T \\vdash \\theta(t)$。\n陈述 $T \\vdash \\forall x(x=t \\rightarrow \\neg\\theta(x))$ 在逻辑上等价于 $T \\vdash \\neg\\theta(t)$。\n这里，$\\theta(t)$ 是语言 $\\mathcal{L}(B)$ 中的一个句子。由于 $T$ 是一个完全理论，对于扩展语言中的任何句子 $\\sigma$，要么 $T \\vdash \\sigma$，要么 $T \\vdash \\neg\\sigma$。在我们的例子中，$\\mathfrak{C}$ 是 $T$ 的一个模型，所以对于句子 $\\theta(t)$，要么 $\\mathfrak{C} \\models \\theta(t)$，要么 $\\mathfrak{C} \\models \\neg\\theta(t)$。由于 $T$ 是 $\\mathfrak{C}$ 的完全理论，这意味着 $T \\vdash \\theta(t)$ 或 $T \\vdash \\neg\\theta(t)$。\n因此，公式 $x=t$ 孤立了型 $q(x) = \\operatorname{tp}(t/\\{t\\})$。这使得 $q(x)$ 成为一个主型。\n\n3. 确定最小基数 $\\kappa$。\n\n我们寻求一个集合 $B$ 的最小基数 $\\kappa$，使得 $p(x)$ 到 $S_1(B)$ 的一个扩张是主型。\n从第2部分，我们找到了这样一个集合 $B = \\{t\\}$，其基数为 $|B|=1$。这就建立了一个上界：$\\kappa \\le 1$。\n\n现在我们必须确定 $\\kappa$ 是否可以为 $0$。如果 $\\kappa=0$，参数集将是 $B=\\emptyset$。在 $\\emptyset$ 上的完全 $1$-型集合 $S_1(\\emptyset)$ 只包含 $p(x)$ 的一个扩张，即 $p(x)$ 本身。在第1部分，我们严格证明了 $p(x)$ 在 $\\emptyset$ 上不是主型。因此，$p(x)$ 到 $S_1(\\emptyset)$ 的任何扩张都不可能是主型。这意味着 $\\kappa$ 不能为 $0$，所以 $\\kappa > 0$。\n\n因为 $\\kappa$ 是一个基数，并且我们已经证明了 $\\kappa > 0$ 和 $\\kappa \\le 1$，所以唯一的可能性是 $\\kappa = 1$。\n\n4. 关于略去型的讨论。\n\n略去型定理 (OTT) 指出，对于一个可数语言，任何在有限或可数参数集上的非主型都可以在理论的某个可数模型中被略去。语言 $\\mathcal{L}$ 是有限的。如第1部分所示，型 $p(x) = \\operatorname{tp}(t/\\emptyset)$ 在 $\\emptyset$ 上不是主型。因此，略去型定理意味着存在一个 $T=\\text{ACF}_0$ 的模型略去了 $p(x)$。一个模型略去 $p(x)$ 是指它不包含任何实现 $p(x)$ 的元素，即不包含任何在 $\\mathbb{Q}$ 上是超越的元素。代数数域 $\\mathbb{Q}^{\\text{alg}}$ 正是这样一个模型。它是一个特征为0的代数闭域，并且根据定义，其所有元素在 $\\mathbb{Q}$ 上都是代数的。因此，在 $\\emptyset$ 上，超越元的型是可略去的，这对应于存在超越次数为0的模型。\n\n当我们扩展参数集时，情况发生了巨大变化。在 $B=\\{t\\}$ 上，$p(x)$ 的扩张 $q(x)=\\operatorname{tp}(t/B)$ 成为主型。一个主型永远不能被一个包含其参数的模型所略去。如果 $\\varphi(x, b)$ 是一个在 $B$ 上的型的孤立公式，那么任何包含 $B$ 的 $T$ 的模型 $M$ ($B \\subseteq M$) 都必须满足句子 $\\exists x \\, \\varphi(x, b)$，并且任何实现该公式的元素都将实现该型。在我们的例子中，对于任何包含 $B=\\{t\\}$ 的模型 $M$，元素 $t$ 本身就实现了孤立公式 $x=t$，从而实现了型 $q(x)$。因此，在任何包含参数 $t$ 的模型中，型 $q(x)$ 都必然被实现。\n\n这种对比说明了模型论的一个基本方面：一个型是否为主型（以及因此是否不可略去）是相对于参数集而言的。添加参数可以将一个可略去的型转变为一个必然被实现的型。这种机制在构造具有特定性质的模型中至关重要，因为向基底添加元素可以强制某些结构或型在所有后续扩张中存在。", "answer": "$$\\boxed{1}$$", "id": "2981073"}]}