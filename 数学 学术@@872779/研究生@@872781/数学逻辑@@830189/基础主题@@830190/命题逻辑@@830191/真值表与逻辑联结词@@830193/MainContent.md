## 引言
在[数理逻辑](@entry_id:636840)的宏伟殿堂中，[真值表](@entry_id:145682)与[逻辑联结词](@entry_id:146395)共同构成了经典[命题逻辑](@entry_id:143535)的坚固基石。它们不仅是逻辑学家用于分析论证有效性的基本工具，更是现代计算理论与数字世界的底层语言。然而，从自然语言中模糊的“如果...那么...”到逻辑上精确的[实质条件](@entry_id:152262)，从直觉的推理到可被机械验证的[语义后承](@entry_id:637166)，这其中横亘着一道需要严谨形式化来跨越的鸿沟。本文旨在系统性地填补这一鸿沟，为读者提供一个关于真值函项语义的全面、深入且具前瞻性的研究生级别视角。

本文将引领读者踏上一段从基础原理到前沿应用的探索之旅。在第一章“原则与机理”中，我们将从最基本的[组合性](@entry_id:637804)原则出发，阐明如何通过[真值](@entry_id:636547)指派唯一地确定任意复杂公式的[真值](@entry_id:636547)。我们将详细剖析标准[逻辑联结词](@entry_id:146395)的[真值表](@entry_id:145682)定义，特别是[实质条件](@entry_id:152262)的合理性，并介绍如何运用[真值表](@entry_id:145682)这一强大的决策程序来判定[重言式](@entry_id:143929)与[逻辑后承](@entry_id:155068)，最后将深入探讨[功能完备性](@entry_id:138720)的深刻理论与[波斯特定理](@entry_id:155425)。

在第二章“应用与跨学科关联”中，我们将走出纯逻辑的范畴，探索这些理论在现实世界中的巨大影响力。我们将看到[逻辑联结词](@entry_id:146395)如何化身为计算机中的逻辑门，驱动着数字革命；它们又如何被用来建模生命科学中的[神经元活动](@entry_id:174309)与[基因调控网络](@entry_id:150976)。同时，我们也将审视[经典逻辑](@entry_id:264911)的边界，通过与处理知识和必然性的内涵逻辑对比，并介绍如[三值逻辑](@entry_id:153539)这样的非经典系统，以应对不确定性与矛盾。

最后，在“动手实践”部分，我们精选了一系列练习，旨在将理论知识转化为实际的分析与计算能力。通过这些从构建基础[真值表](@entry_id:145682)到分析多值逻辑系统的逐步深入的练习，读者将能够巩固并内化所学内容。现在，让我们从[经典逻辑](@entry_id:264911)最核心的语义原则开始，揭开真值表与[逻辑联结词](@entry_id:146395)的奥秘。

## 原则与机理

在本章中，我们将深入探讨经典[命题逻辑](@entry_id:143535)的语义基础。我们将从最基本的原则——[真值](@entry_id:636547)如何赋予原子命题开始，然后系统地构建一套理论，用以理解复合命题的意义、[逻辑联结词](@entry_id:146395)的性质，以及如何利用这些工具来分析逻辑论证。本章的核心工具是**真值表 (truth table)**，它不仅是一种计算工具，更是揭示逻辑结构与可能性的理论棱镜。

### 语义的[组合性](@entry_id:637804)原则：从[真值](@entry_id:636547)指派到赋值

经典[命题逻辑](@entry_id:143535)的基石是一个强大而直观的原则：**[组合性](@entry_id:637804)原则 (principle of compositionality)**。该原则断言，一个复杂表达式的意义是由其组成部分的意义以及将它们组合起来的规则唯一确定的。在[命题逻辑](@entry_id:143535)的语境下，这意味着一个复合公式的真假，完全取决于其构成的原子命题的真假以及所使用的[逻辑联结词](@entry_id:146395)的定义。

让我们将此原则形式化。首先，我们设定一个由两个[元素组成](@entry_id:161166)的**[真值](@entry_id:636547)集合**，通常表示为 $\{0, 1\}$ 或 $\{\bot, \top\}$，其中 $0$（或 $\bot$）代表“假”，$1$（或 $\top$）代表“真”。[命题逻辑](@entry_id:143535)的语言建立在一个可数的原子命题集合之上，我们称之为**命题变量 (propositional variables)**，记作 $\mathsf{Var}$。

一个**[真值](@entry_id:636547)指派 (truth assignment)** 是一个函数 $v$，它将每个命题变量映射到一个[真值](@entry_id:636547)。形式上，$v: \mathsf{Var} \to \{0, 1\}$。这个函数仅仅规定了最基本的命题是真是假。

[组合性](@entry_id:637804)原则的威力在于，任何一个给定的[真值](@entry_id:636547)指派 $v$ 都可以被唯一地扩展为一个**赋值 (valuation)** 函数 $\hat{v}$，该函数能确定语言中*所有*公式的[真值](@entry_id:636547)，无论其多么复杂。这个扩展是根据公式的递归结构进行的。[@problem_id:2987709]

这个扩展过程的存在性和唯一性可以通过**[结构归纳法](@entry_id:150215) (structural induction)** 来证明。因为每个[合式公式](@entry_id:636348) (well-formed formula) 都有一个唯一的构造方式（或者说，唯一的[语法分析树](@entry_id:272911)），我们可以通过以下方式定义 $\hat{v}$：

1.  **基本情况**：对于任何命题变量 $p \in \mathsf{Var}$，我们定义 $\hat{v}(p) = v(p)$。这确保了 $\hat{v}$ 是 $v$ 的一个扩展。如果语言包含逻辑常数，如“假”($\bot$) 和“真”($\top$)，我们也定义 $\hat{v}(\bot) = 0$ 和 $\hat{v}(\top) = 1$。

2.  **[归纳步骤](@entry_id:144594)**：假设我们已经为公式 $\varphi$ 和 $\psi$ 定义了真值 $\hat{v}(\varphi)$ 和 $\hat{v}(\psi)$。那么，对于由它们通过[逻辑联结词](@entry_id:146395)构成的更复杂的公式，其[真值](@entry_id:636547)由固定的[真值](@entry_id:636547)函数 (truth function) 决定。例如，对于否定 ($\neg$) 和合取 ($\wedge$)：
    *   $\hat{v}(\neg\varphi) = 1 - \hat{v}(\varphi)$
    *   $\hat{v}(\varphi \wedge \psi) = \min\{\hat{v}(\varphi), \hat{v}(\psi)\}$

由于每个公式都是从原子命题通过有限次应用联结词构造而来的，这个[递归定义](@entry_id:266613)覆盖了所有公式。[结构归纳法](@entry_id:150215)保证了，对于任意给定的 $v$，满足这些条件的赋值函数 $\hat{v}$ 不仅存在，而且是唯一的。[@problem_id:2987709]

从泛代数的角度看，公式集合 $\mathsf{Fm}$ 是由命题变量 $\mathsf{Var}$ 自由生成的[代数结构](@entry_id:137052)，而[真值](@entry_id:636547)集合 $\{0, 1\}$ 在[逻辑联结词](@entry_id:146395)的解释下也构成一个代数。赋值 $\hat{v}$ 正是那个从自由代数到真值代数的、唯一地扩展了函数 $v$ 的**同态 (homomorphism)**。[@problem_id:2987709]

这一原则的直接推论是，一个公式 $\varphi$ 在赋值 $v$ 下的真值，仅仅依赖于 $v$ 对出现在 $\varphi$ 中的那些命题变量的指派。换言之，如果两个真值指派 $v$ 和 $w$ 对于 $\varphi$ 中出现的所有变量都给出相同的值，那么它们对于 $\varphi$ 本身的赋值也必然相同，即 $v(\varphi) = w(\varphi)$。这个性质也称为**局部性 (locality)**，它是[真值](@entry_id:636547)函项语义的标志。[@problem_id:2987715]

### [逻辑联结词](@entry_id:146395)的语义

[组合性](@entry_id:637804)原则的实现依赖于每个[逻辑联结词](@entry_id:146395)都有一个固定的、明确的语义解释。这种解释就是**[真值](@entry_id:636547)函数**，通常通过[真值表](@entry_id:145682)来呈现。

以下是五个标准联结词的[真值表](@entry_id:145682)定义，其中我们用 $A$ 和 $B$ 代表任意的子公式：

**否定 (Negation, $\neg$)**：反转其操作数的[真值](@entry_id:636547)。
$$
\begin{array}{c|c}
A  \neg A \\
\hline
0  1 \\
1  0
\end{array}
$$

**合取 (Conjunction, $\land$)**：当且仅当其两个操作数都为真时，结果为真。
$$
\begin{array}{cc|c}
A  B  A \land B \\
\hline
0  0  0 \\
0  1  0 \\
1  0  0 \\
1  1  1
\end{array}
$$

**析取 (Disjunction, $\lor$)**：当其至少一个操作数为真时，结果为真。
$$
\begin{array}{cc|c}
A  B  A \lor B \\
\hline
0  0  0 \\
0  1  1 \\
1  0  1 \\
1  1  1
\end{array}
$$

**双条件 (Biconditional, $\leftrightarrow$)**：当且仅当其两个操作数具有相同的[真值](@entry_id:636547)时，结果为真。
$$
\begin{array}{cc|c}
A  B  A \leftrightarrow B \\
\hline
0  0  1 \\
0  1  0 \\
1  0  0 \\
1  1  1
\end{array}
$$

**[实质条件](@entry_id:152262) (Material Conditional, $\to$)**：
$$
\begin{array}{cc|c}
A  B  A \to B \\
\hline
0  0  1 \\
0  1  1 \\
1  0  0 \\
1  1  1
\end{array}
$$

其中，否定、合取、析取和双条件的[真值表](@entry_id:145682)定义通常被认为是符合直觉的。然而，[实质条件](@entry_id:152262)的定义，特别是“假前提蕴涵任何结论”（即当 $A$ 为假时，$A \to B$ 为真）的所谓“[实质蕴涵](@entry_id:147812)悖论”，常常引起困惑。

为了理解这个定义，我们必须认识到，逻辑学家并非试图捕捉日常语言中“如果……那么……”的全部微妙含义（如因果关系、反事实等）。相反，他们旨在定义一个满足特定逻辑功能的最小化、[真值](@entry_id:636547)函项性的联结词。这个核心功能就是**分离规则 (Modus Ponens)**，即从 $A$ 和 $A \to B$ 可以有效地推断出 $B$。形式上，这意味着在任何赋值 $v$ 下，如果 $v(A)=1$ 且 $v(A \to B)=1$，那么必须有 $v(B)=1$。

让我们从这个要求出发，来推导 $A \to B$ 的真值表。[@problem_id:2987733]
*   当 $v(A)=1, v(B)=1$ 时，为了满足分离规则，我们不能让 $v(A \to B)=0$，因为那样的话，$1$ 和 $0$ 将推出 $1$，这是不保真的。所以，如果我们希望分离规则有效，至少当 $v(A)=1$ 且 $v(A \to B)=1$ 时 $v(B)=1$。
*   当 $v(A)=1, v(B)=0$ 时，如果此时 $v(A \to B)=1$，那么我们就会有 $v(A)=1$ 和 $v(A \to B)=1$ 但 $v(B)=0$ 的情况，这直接违反了分离规则。因此，为了使分离规则成立，我们**必须**定义 $v(A \to B)=0$。这是唯一被分离规则强制确定的情况。
*   当 $v(A)=0, v(B)=0$ 时，以及当 $v(A)=0, v(B)=1$ 时，分离规则的前件 ($v(A)=1$) 未被满足，因此规则本身不适用。这意味着无论 $v(A \to B)$ 取何值，分离规则都不会被违反。

我们现在面临一个选择。对于前提为假的情况，我们可以将 $A \to B$ 定义为真或假。这里，逻辑学家采用了一个**最大化真值原则 (principle of maximal truth)**：除非有明确的理由将一个命题判为假，否则就应将其判为真。这是一种“无罪推定”原则，它使条件句的断言尽可能地弱（即尽可能地为真）。因此，在不受分离规则约束的情况下，我们选择将 $A \to B$ 的值设为 $1$。

这套推理唯一地确定了[实质条件](@entry_id:152262)的真值表。它恰好等价于 $\neg A \lor B$ 的真值表。这正是[经典逻辑](@entry_id:264911)中将 $A \to B$ 定义为 $\neg A \lor B$ 的语义基础。[@problem_id:2987733]

### 作为分析工具的真值表

一旦我们为所有联结词建立了真值表，我们就有了一个强大的机械化工具来分析[命题逻辑](@entry_id:143535)的任何方面。

#### 真值表的规模

真值表方法的核心在于其穷举性。对于一个包含 $n$ 个不同命题变量的公式 $\varphi$，我们需要考虑这些变量的所有可能的[真值](@entry_id:636547)组合。一个[真值](@entry_id:636547)指派本质上是一个从这 $n$ 个变量的集合到 $\{0, 1\}$ 的函数。根据[组合学](@entry_id:144343)的基本[乘法原理](@entry_id:273377)，如果对第一个变量有 2 种选择，对第二个变量有 2 种选择，以此类推，直到第 $n$ 个变量，那么总共就有 $\underbrace{2 \times 2 \times \dots \times 2}_{n \text{ times}} = 2^n$ 种不同的真值指派。[@problem_id:2987696]

因此，一个包含 $n$ 个不同命题变量的公式的完整真值表恰好有 $2^n$ 行。每一行代表一个“可能的世界”或一种估值情况。

#### 公式的分类

通过构建一个公式 $\varphi$ 的完整真值表，并计算出其在每一行（即每一种赋值下）的最终真值，我们可以将公式分为三类：[@problem_id:2987695]

1.  **重言式 (Tautology)**：如果一个公式在其[真值表](@entry_id:145682)的最后一列中**全为真** ($1$)，那么它就是一个[重言式](@entry_id:143929)。这意味着该公式在任何可能的[真值](@entry_id:636547)指派下都为真。例如，$A \lor \neg A$。
2.  **矛盾式 (Contradiction)**：如果一个公式在其真值表的最后一列中**全为假** ($0$)，那么它就是一个矛盾式。这意味着该公式在任何[真值](@entry_id:636547)指派下都为假。例如，$A \land \neg A$。
3.  **偶然式 (Contingent Formula)**：如果一个公式在其[真值表](@entry_id:145682)的最后一列中**既有真也有假**，那么它就是一个偶然式。这意味着它的真假取决于其原子命题的具体[真值](@entry_id:636547)。例如，$A$ 或 $A \land B$。

这个使用[真值表](@entry_id:145682)的分类方法是一个**判定程序 (decision procedure)**：对于任何给定的[命题逻辑](@entry_id:143535)公式，该算法都能在有限的步骤内（尽管步骤数可能随变量数量[指数增长](@entry_id:141869)）明确地确定它属于上述三类中的哪一类。其正确性（[可靠性与完备性](@entry_id:148267)）是由我们之前讨论的[组合性](@entry_id:637804)原则和真值表的穷举性保证的。真值表的每一行都精确对应一个赋值，因此检查所有行就等同于检查所有可能的赋值。[@problem_id:2987695]

#### 判定[逻辑后承](@entry_id:155068)

[真值表](@entry_id:145682)最重要的应用之一是判定**[语义后承](@entry_id:637166) (semantic entailment)**，或称[逻辑推论](@entry_id:155068)关系，记作 $\Gamma \vDash \varphi$。它表示：从前提集合 $\Gamma$ 出发，结论 $\varphi$ 在逻辑上是必然的。其形式化定义是：

 $\Gamma \vDash \varphi$ 当且仅当，对于任何赋值 $v$，如果 $v$ 使得 $\Gamma$ 中的**所有**公式都为真，那么 $v$ 也必须使得 $\varphi$ 为真。

换言之，不存在一个“反例”赋值，使得所有前提都为真而结论为假。

要用[真值表](@entry_id:145682)来检验 $\Gamma \vDash \varphi$ 是否成立，我们只需执行以下步骤：[@problem_id:2987707]
1.  构建一个包含 $\Gamma$ 和 $\varphi$ 中所有命题变量的真值表。
2.  为 $\Gamma$ 中的每个前提公式以及结论 $\varphi$ 计算出它们在每一行的[真值](@entry_id:636547)。
3.  **只关注**那些使得 $\Gamma$ 中所有前提公式的真值都为 $1$ 的行。
4.  在这些行中，检查结论 $\varphi$ 的真值。如果 $\varphi$ 在**所有这些行**中也都为 $1$，那么后承关系 $\Gamma \vDash \varphi$ 成立。如果存在哪怕一行，所有前提都为 $1$ 而 $\varphi$ 为 $0$，则后承关系不成立。

以分离规则本身为例，让我们检验 $\{A \to B, A\} \vDash B$。[@problem_id:2987707]
我们构造包含 $A$ 和 $B$ 的[真值表](@entry_id:145682)：
$$
\begin{array}{cc|cc|c}
A  B  A \to B  A  B \\
\hline
0  0  1  0  0 \\
0  1  1  0  1 \\
1  0  0  1  0 \\
1  1  \mathbf{1}  \mathbf{1}  \mathbf{1}
\end{array}
$$
我们寻找两个前提 $A \to B$ 和 $A$ 都为 $1$ 的行。只有最后一行满足这个条件。在该行中，结论 $B$ 的值也是 $1$。由于不存在前提皆真而结论为假的情况，我们判定 $\{A \to B, A\} \vDash B$ 成立。

### 联结词的[表达能力](@entry_id:149863)：[功能完备性](@entry_id:138720)

我们已经看到，五个标准联结词足以表达许多逻辑概念。一个自然的问题是：我们是否需要所有这些联结词？或者，是否存在一个更小的联结词集合，其[表达能力](@entry_id:149863)足以等同于整个标准集合？

#### 可定义性与[功能完备性](@entry_id:138720)

如果一个联结词的[真值](@entry_id:636547)函数可以通过其他联结词组合成的公式来表达，我们就说这个联结词是**可定义的 (definable)**。例如，$A \to B$ 可由 $\{\neg, \lor\}$ 定义为 $\neg A \lor B$。

一个联结词集合 $C$ 被称为**功能完备的 (functionally complete)**，如果**所有**可能的[布尔函数](@entry_id:276668)（即任何可能的[真值表](@entry_id:145682)）都可以由 $C$ 中的联结词来定义。我们已知，集合 $\{\neg, \land, \lor\}$ 是功能完备的。由于 $\land$ 和 $\lor$ 可以通过[德摩根定律](@entry_id:138529)相互定义（例如，$A \lor B \equiv \neg(\neg A \land \neg B)$），所以 $\{\neg, \land\}$ 和 $\{\neg, \lor\}$ 也都是功能完备的。

令人惊讶的是，存在仅包含单个联结词的功能完备集。最著名的两个例子是**谢弗竖线 (Sheffer stroke)**，即“与非” (NAND)，记作 $\mid$；以及**皮尔斯箭头 (Peirce arrow)**，即“或非” (NOR)，记作 $\downarrow$。[@problem_id:2987732]

*   **与非 (NAND)**：$A \mid B$ 的定义是 $\neg(A \land B)$。它当且仅当 $A$ 和 $B$ 不全为真时为真。
    我们可以用它来定义 $\neg$ 和 $\land$：
    *   $\neg A \equiv A \mid A$ （因为 $\neg(A \land A) \equiv \neg A$）
    *   $A \land B \equiv \neg(A \mid B) \equiv (A \mid B) \mid (A \mid B)$

*   **或非 (NOR)**：$A \downarrow B$ 的定义是 $\neg(A \lor B)$。它当且仅当 $A$ 和 $B$ 都为假时为真。
    我们可以用它来定义 $\neg$ 和 $\lor$：
    *   $\neg A \equiv A \downarrow A$ （因为 $\neg(A \lor A) \equiv \neg A$）
    *   $A \lor B \equiv \neg(A \downarrow B) \equiv (A \downarrow B) \downarrow (A \downarrow B)$

由于 $\{\mid\}$ 和 $\{\downarrow\}$ 都能定义一个已知的完备集（如 $\{\neg, \land\}$ 或 $\{\neg, \lor\}$），因此它们自身都是功能完备的。[@problem_id:2987732]

#### 完备性判据：[波斯特定理](@entry_id:155425)

如何系统地判断一个任意给定的联结词集合 $C$ 是否功能完备？Emil Post 在 20 世纪早期给出了一个优雅而强大的答案，即**[波斯特定理](@entry_id:155425) (Post's Completeness Theorem)**。该定理指出，一个联结词集合是功能完备的，当且仅当它**不**完全包含于以下五个特殊的布尔函数类别（称为 Post 极大克隆）中的任何一个。[@problem_id:2987716]

这五个类别是：
1.  **保 $0$ 函数 ($T_0$)**: 那些当所有输入都为 $0$ 时，输出也为 $0$ 的函数。即 $f(0, 0, \dots, 0) = 0$。例如，$\land$ 和 $\lor$ 都是保 $0$ 的，但 $\neg$ 和 $\leftrightarrow$ 不是。
2.  **保 $1$ 函数 ($T_1$)**: 那些当所有输入都为 $1$ 时，输出也为 $1$ 的函数。即 $f(1, 1, \dots, 1) = 1$。例如，$\land$ 和 $\lor$ 都是保 $1$ 的，但 $\neg$ 和 $\leftrightarrow$ 不是。
3.  **单调函数 ($M$)**: 那些当你将其任一输入从 $0$ 变为 $1$ 时，其输出如果变化，只能从 $0$ 变为 $1$（而绝不能从 $1$ 变为 $0$）的函数。形式上，如果输入向量 $\vec{x} \le \vec{y}$（逐分量比较），则 $f(\vec{x}) \le f(\vec{y})$。例如，$\land$ 和 $\lor$ 是单调的，但 $\neg$ 和 $\to$ 不是。[@problem_id:2987730]
4.  **[自对偶函数](@entry_id:178669) ($S$)**: 那些将其所有输入反转后，其输出也随之反转的函数。即 $f(\neg x_1, \dots, \neg x_n) = \neg f(x_1, \dots, x_n)$。例如，$\neg$ 是自对偶的，但 $\land$ 和 $\lor$ 不是。
5.  **[仿射函数](@entry_id:635019) ($L$)** (或线性函数)：那些可以表示为 $f(x_1, \dots, x_n) = a_0 \oplus a_1 x_1 \oplus \dots \oplus a_n x_n$ 形式的函数，其中 $\oplus$ 是模 2 加法（[异或](@entry_id:172120)），系数 $a_i \in \{0, 1\}$。例如，$\neg$ (即 $1 \oplus x$) 和 $\leftrightarrow$ (即 $1 \oplus x \oplus y$) 是仿射的，但 $\land$ 不是。

这五个类别中的每一个都具有**闭包性**：用该类别中的函数进行组合，得到的新函数仍然属于该类别。因此，如果一个联结词集合 $C$ 中的所有成员都属于某个类别 $P$，那么 $C$ 只能生成 $P$ 内部的函数，永远无法生成 $P$ 之外的函数，从而不可能是功能完备的。

[波斯特定理](@entry_id:155425)的深刻之处在于其“当且仅当”的断言。它告诉我们，这五个类别是**唯一**的障碍。因此，要测试一个集合 $C$ 是否功能完备，我们只需进行如下算法：[@problem_id:2987716]
*   **对于保 $0$ 性**：检查 $C$ 中是否存在至少一个不保 $0$ 的函数。
*   **对于保 $1$ 性**：检查 $C$ 中是否存在至少一个不保 $1$ 的函数。
*   **对于单调性**：检查 $C$ 中是否存在至少一个非单调的函数。
*   **对于[自对偶性](@entry_id:140268)**：检查 $C$ 中是否存在至少一个非自对偶的函数。
*   **对于仿射性**：检查 $C$ 中是否存在至少一个非仿射的函数。

如果对这五个问题，答案都是“是”，那么 $C$ 就是功能完备的。否则，它不是。所有这些检查都可以通过分析联结词的真值表来机械地完成。

### 真值函项性的边界与意义

到目前为止，我们探讨的所有联结词都是**外延的 (extensional)** 或**真值函项的 (truth-functional)**。这意味着由它们构成的复合命题的[真值](@entry_id:636547)，完全由其直接组成部分的[真值](@entry_id:636547)决定。真值表的存在性是这种性质的最终证明。[@problem_id:2987698]

然而，自然语言和许多哲学、计算机科学的逻辑系统中，充满了**内涵的 (intensional)** 或非[真值](@entry_id:636547)函项的联结词。一个典型的例子是[模态逻辑](@entry_id:149086)中的“必然性”算子 $\Box$。$\Box \varphi$ 意为“必然地，$\varphi$ 为真”。

$\Box$ 不是[真值](@entry_id:636547)函项的。仅仅知道 $\varphi$ 在当前情况下为真（或为假），并不足以确定 $\Box \varphi$ 是否为真。例如，假设“今天是星期三”($P$) 为真，但“$2+2=4$”($Q$) 也为真。$v(P)=1$ 且 $v(Q)=1$。然而，我们直觉上会认为 $\Box Q$（必然地，$2+2=4$）为真，而 $\Box P$（必然地，今天是星期三）为假，因为它只是一个偶然事实。

我们可以使用 **Kripke 语义** 来形式化地展示这一点。在 [Kripke 模型](@entry_id:153269)中，[真值](@entry_id:636547)是在不同的“可能世界”中评估的。$\Box \varphi$ 在世界 $w$ 为真，当且仅当在所有从 $w$ 可达的世界 $w'$ 中 $\varphi$ 都为真。考虑一个模型，其中有两个世界 $\{w, u\}$，并且从 $w$ 可以到达 $u$。让命题 $p$ 在世界 $w$ 和 $u$ 都为真。再考虑另一个模型，结构相同，但命题 $p$ 只在 $w$ 为真，在 $u$ 为假。在这两个模型中，“$p$ 在世界 $w$ 为真”这个事实是相同的。然而，在第一个模型中，$\Box p$ 在 $w$ 为真（因为它在所有可达世界 $u$ 都为真），但在第二个模型中，$\Box p$ 在 $w$ 为假（因为它在可达世界 $u$ 为假）。这表明 $\Box p$ 在 $w$ 的[真值](@entry_id:636547)不完全由 $p$ 在 $w$ 的[真值](@entry_id:636547)决定，因此不存在一个简单的 $\{0,1\} \to \{0,1\}$ 真值表能捕捉 $\Box$ 的语义。[@problem_id:2987698]

这个区别凸显了真值函项性的深刻意义。经典[命题逻辑](@entry_id:143535)的[组合性](@entry_id:637804)原则保证了**[语义等价](@entry_id:754673)替换原理 (principle of substitution for semantic equivalents)**。如果两个公式 $\varphi$ 和 $\psi$ 是[语义等价](@entry_id:754673)的（即在所有赋值下[真值](@entry_id:636547)都相同，$\varphi \equiv \psi$），那么在任何更大的公式上下文中，用 $\psi$ 替换 $\varphi$ 都不会改变该更大公式的[真值](@entry_id:636547)。[@problem_id:2987715] 然而，对于像 $\Box$ 这样的内涵上下文，这种替换就不再安全。两个在当前世界恰好真值相同的公式，未必能在所有可达世界中都保持[真值](@entry_id:636547)相同，因此在 $\Box$ 的作用范围内替换它们可能会改变[真值](@entry_id:636547)。

最后，[真值](@entry_id:636547)函项性带来了巨大的**认知和计算优势**。[@problem_id:2987698]
1.  **评估效率**：对于一个给定的公式和[真值](@entry_id:636547)指派，我们可以在线性于公式长度的时间内自底向上地计算出其[真值](@entry_id:636547)。每个联结词的处理都只是一个固定大小的查表操作。
2.  **判定能力**：虽然对于 $n$ 个变量，真值表的大小是指数级的（$2^n$），但它提供了一个确定的、有限的、机械的程序来判定重言性、矛盾性和[逻辑后承](@entry_id:155068)等关键的逻辑属性。

相比之下，内涵逻辑的语义通常需要量化一个可能无限的世界集合，其[判定问题](@entry_id:636780)（如果可判定的话）的[计算复杂性](@entry_id:204275)通常要高得多。因此，经典[命题逻辑](@entry_id:143535)及其真值表方法，尽管在表达力上有限，却为我们提供了一个坚实、清晰且可计算的推理基础。它是更复杂逻辑系统所建立于其上的基石，也是衡量它们复杂性的一个重要参照点。