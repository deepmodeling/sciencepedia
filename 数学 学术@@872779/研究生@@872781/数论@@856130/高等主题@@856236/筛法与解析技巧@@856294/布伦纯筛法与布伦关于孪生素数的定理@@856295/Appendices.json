{"hands_on_practices": [{"introduction": "筛法通过估算在一个筛选过程中幸存下来的数的比例来发挥作用。这个比例通常被建模为一系列“局部密度”的乘积，每个局部密度代表对于单个素数的存活率。第一个练习将邀请你计算在孪生素数问题中，对于特殊素数 $p=2$ 的局部因子，这将为你理解布朗筛法核心的算术结构提供一个基础性视角 [@problem_id:3009398]。", "problem": "考虑二元模式 $\\mathcal{H}=\\{0,2\\}$，它编码了对整数 $n$ 的孪生素数约束，要求 $n$ 和 $n+2$ 都能避免被小素数整除。在 Brun 纯筛法的框架中，我们通过移除满足 $p \\mid n(n+2)$（对于任何低于某个阈值的素数 $p$）的 $n$ 来筛选序列 $\\{n \\leq x\\}$。对于一个素数 $p$，令 $r(p)$ 表示使 $a(a+2) \\equiv 0 \\pmod{p}$ 成立的剩余类 $a \\pmod{p}$ 的数量。对于 $k=2$ 的模式，在归一化筛密度中与 $p$ 相关联的局部乘性因子定义为\n$$\nf_{p} \\;=\\; \\frac{1-\\frac{r(p)}{p}}{\\left(1-\\frac{1}{p}\\right)^{2}} \\, .\n$$\n在这种情况下，素数 $p=2$ 是一个例外，因为 $\\mathcal{H}$ 中的两个位移模2同余。仅使用 $r(p)$ 的定义和基本的模算术，计算因子 $f_{2}$ 的精确值。\n\n你的答案应该是一个精确的数字。", "solution": "问题要求在 Brun 纯筛法的背景下，计算与孪生素数问题相关的局部乘性因子 $f_{2}$。对于一个素数 $p$，该因子定义为：\n$$\nf_{p} \\;=\\; \\frac{1-\\frac{r(p)}{p}}{\\left(1-\\frac{1}{p}\\right)^{2}}\n$$\n其中 $r(p)$ 是使得代表素数模式的多项式（在此例中为 $a(a+2)$）同余于零的模 $p$ 剩余类 $a$ 的数量。\n\n为了求出 $f_{2}$ 的值，我们必须首先确定 $r(2)$ 的值。根据所给定义，$r(2)$ 是同余方程\n$$\na(a+2) \\equiv 0 \\pmod{2}\n$$\n的不同解的数量，其中 $a$ 是模2的剩余类。模2的整数由两个剩余类组成，由 $a=0$ 和 $a=1$ 代表。我们分别检验这两种情况：\n\n情况1：$a \\equiv 0 \\pmod{2}$\n将 $a=0$ 代入同余方程，我们得到：\n$$\n0 \\cdot (0+2) \\equiv 0 \\cdot 2 \\equiv 0 \\pmod{2}\n$$\n这个同余式是成立的。因此，$a \\equiv 0 \\pmod{2}$ 是一个解。\n\n情况2：$a \\equiv 1 \\pmod{2}$\n将 $a=1$ 代入同余方程，我们得到：\n$$\n1 \\cdot (1+2) \\equiv 1 \\cdot 3 \\equiv 3 \\pmod{2}\n$$\n由于 $3 \\equiv 1 \\pmod{2}$，该同余方程变为 $1 \\equiv 0 \\pmod{2}$，这是不成立的。因此，$a \\equiv 1 \\pmod{2}$ 不是一个解。\n\n从这两种情况中，我们发现只有一个模2的剩余类满足条件，即 $a \\equiv 0 \\pmod{2}$。因此，这样的剩余类的数量为 $r(2) = 1$。\n\n这个结果阐明了为什么 $p=2$ 在孪生素数问题中被认为是一个例外素数。对于任何其他素数 $p>2$，同余方程 $a(a+2) \\equiv 0 \\pmod{p}$ 有两个不同的解：$a \\equiv 0 \\pmod{p}$ 和 $a \\equiv -2 \\pmod{p}$（因为 $p>2$，所以 $0 \\not\\equiv -2 \\pmod{p}$）。因此，对于 $p>2$，我们有 $r(p)=2$。而对于 $p=2$，两个潜在的根 $0$ 和 $-2$ 模2同余，因此它们合并成一个根，得到 $r(2)=1$。\n\n现在，我们可以将 $p=2$ 和 $r(2)=1$ 代入 $f_{p}$ 的公式中：\n$$\nf_{2} = \\frac{1-\\frac{r(2)}{2}}{\\left(1-\\frac{1}{2}\\right)^{2}} = \\frac{1-\\frac{1}{2}}{\\left(1-\\frac{1}{2}\\right)^{2}}\n$$\n该表达式可以被简化。分子是：\n$$\n1-\\frac{1}{2} = \\frac{1}{2}\n$$\n分母是：\n$$\n\\left(1-\\frac{1}{2}\\right)^{2} = \\left(\\frac{1}{2}\\right)^{2} = \\frac{1}{4}\n$$\n因此，$f_{2}$ 的值是分子与分母的比值：\n$$\nf_{2} = \\frac{\\frac{1}{2}}{\\frac{1}{4}} = \\frac{1}{2} \\cdot \\frac{4}{1} = 2\n$$\n因子 $f_{2}$ 的精确值是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3009398"}, {"introduction": "从局部到全局，我们的下一个练习将涉及实现一个布朗筛法的数值版本。这个计算练习将巩固你对筛法整体如何运作的理解，从建立初始集合到遍历筛选素数。你将直接比较筛法得出的严格上界、一个更简单的启发式估计以及孪生素数的真实数量，从而为该方法的能力及其著名的“奇偶性问题”的来源提供一个切实的视角 [@problem_id:3009401]。", "problem": "在 Brun 纯筛法的框架内考虑孪生素数问题。令 $x \\in \\mathbb{N}$ 为一个量级参数，令 $z \\in \\mathbb{N}$ 为一个筛法水平。将孪生素数的候选基集定义为奇数\n$$\n\\mathcal{A}(x) := \\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ odd} \\}.\n$$\n对于每个素数 $p$，定义淘汰集\n$$\n\\mathcal{A}_p := \\{ n \\in \\mathcal{A}(x) : p \\mid n \\text{ or } p \\mid (n+2) \\}.\n$$\n令 $\\mathbb{P}_{\\le z}$ 表示不超过 $z$ 的素数集合。为避免被素数 $p=2$ 平凡地消去，筛法将只使用奇素数，即\n$$\n\\mathbb{P}^{\\text{odd}}_{\\le z} := \\{ p \\in \\mathbb{P}_{\\le z} : p \\ge 3 \\}.\n$$\n将水平 $z$ 处的被筛集合定义为\n$$\nS_z(x) := \\left| \\mathcal{A}(x) \\setminus \\bigcup_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\mathcal{A}_p \\right|,\n$$\n即，$\\mathcal{A}(x)$ 中，对于每个奇素数 $p \\le z$，条件 $p \\mid n$ 和 $p \\mid (n+2)$ 都不成立的 $n$ 的数量。\n\n通过 Brun 纯筛法对 $S_z(x)$ 进行建模的基本依据是剩余类淘汰原则：对于一个固定的奇素数 $p$，恰好有两个模 $p$ 的剩余类被条件 $p \\mid n$ 或 $p \\mid (n+2)$ 淘汰，即 $n \\equiv 0 \\pmod{p}$ 和 $n \\equiv -2 \\pmod{p}$。在一个均匀性假设（纯筛法所基于的组合独立性理想化）下，因此每个素数 $p$ 的预期存活密度为 $1 - \\frac{2}{p}$，并且直到水平 $z$ 的存活因子的启发式乘积为\n$$\nW(z) := \\prod_{p \\in \\mathbb{P}^{\\text{odd}}_{\\le z}} \\left(1 - \\frac{2}{p}\\right).\n$$\n令\n$$\nX(x) := |\\mathcal{A}(x)| = \\max\\!\\left( \\left\\lfloor \\frac{x-1}{2} \\right\\rfloor - 1, \\, 0 \\right),\n$$\n它计算了 $[3, x-2]$ 中的奇数 $n$ 的数量。那么，对于被筛计数的相应乘性模型预测为\n$$\nU_{\\text{prod}}(x,z) := X(x) \\cdot W(z).\n$$\n\n为了与孪生素数联系起来，定义截至 $x$ 的精确孪生素数计数函数，\n$$\nT(x) := \\left| \\{ n \\in \\mathbb{N} : 3 \\le n \\le x-2, \\; n \\text{ and } n+2 \\text{ are both prime} \\} \\right|.\n$$\n观察到，任何两个素数都超过 $z$ 的孪生素数对，必然能在所有 $\\le z$ 的奇素数淘汰过程中存活下来，因此属于被筛集合。然而，至少有一个素数 $\\le z$ 的孪生素数对可能会被筛法排除。为了恢复一个上界，定义\n$$\nB_z(x) := \\left| \\{ n \\in \\mathbb{N} : 3 \\le n \\le \\min(x-2, z), \\; n \\text{ and } n+2 \\text{ are both prime} \\} \\right|,\n$$\n其较小成员至多为 $z$ 的孪生素数对的数量。那么量\n$$\nU_{\\text{bound}}(x,z) := S_z(x) + B_z(x)\n$$\n是 $T(x)$ 的一个显式、可计算的上界，即对于所有的 $x$ 和 $z$，$T(x) \\le U_{\\text{bound}}(x,z)$。\n\n您的任务是实现一个完整的、可运行的程序，该程序为每个测试用例 $(x,z)$ 计算五元组\n$$\n\\left[ S_z(x), \\; U_{\\text{prod}}(x,z), \\; U_{\\text{bound}}(x,z), \\; T(x), \\; \\big( T(x) \\le U_{\\text{bound}}(x,z) \\big) \\right].\n$$\n所有计算在适当的情况下（计数）必须精确执行，在涉及乘积的情况下必须以合理的精度进行数值计算；您的程序应将浮点值 $U_{\\text{prod}}(x,z)$ 四舍五入到小数点后 $6$ 位。\n\n测试套件：\n- 案例 1：$(x,z) = (200,13)$，一个中等量级和一个非平凡的筛法水平。\n- 案例 2：$(x,z) = (1000,37)$，一个较大的量级和中等筛法水平。\n- 案例 3：$(x,z) = (50,2)$，一个边界筛法水平，没有 $\\le z$ 的奇素数，用于检查基集行为。\n- 案例 4：$(x,z) = (10000,97)$，一个较大的量级和一个可观的筛法水平。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。外层列表的每个元素必须是对应测试用例的列表\n$$\n\\left[ S_z(x), \\; U_{\\text{prod}}(x,z), \\; U_{\\text{bound}}(x,z), \\; T(x), \\; \\big( T(x) \\le U_{\\text{bound}}(x,z) \\big) \\right]\n$$\n，顺序与上面列出的顺序一致。例如，输出格式应如下所示\n$$\n\\big[ [\\cdots], [\\cdots], [\\cdots], [\\cdots] \\big].\n$$", "solution": "本题要求为给定的参数 $(x,z)$ 实现一个完整的计算流程，以验证布朗纯筛法的上界，并将其与启发式模型和真实孪生素数计数进行比较。解决方案的核心是设计一个高效的算法来计算问题中定义的五个量：$S_z(x)$, $U_{\\text{prod}}(x,z)$, $U_{\\text{bound}}(x,z)$, $T(x)$, 以及一个验证不等式的布尔值。\n\n### 算法设计与实现步骤\n\n**1. 素数生成**\n由于所有计算都依赖于素数，第一步是高效地生成一个素数列表。埃拉托斯特尼筛法（Sieve of Eratosthenes）是完成此任务的理想选择。考虑到测试用例中 $x$ 的最大值为 $10000$，我们需要对高达 $10000+2$ 的数进行素性测试。因此，我们将预先计算直到 $10002$ 的所有素数。这会生成一个布尔数组 `is_prime` 用于快速素性判断，以及一个排序的素数列表。\n\n**2. 计算 $S_z(x)$**\n$S_z(x)$ 是在筛选后幸存的元素数量。\n- **基集**: 我们需要表示基集 $\\mathcal{A}(x) = \\{ n \\mid 3 \\le n \\le x-2, n \\text{ 是奇数} \\}$。该集合的大小为 $X(x) = \\max(\\lfloor (x-1)/2 \\rfloor - 1, 0)$。我们可以使用一个大小为 $X(x)$ 的布尔数组 `survivors` 来代表这些奇数，其中索引 $k$ 对应奇数 $n_k = 2k+3$。\n- **筛选过程**: 我们遍历所有小于等于 $z$ 的奇素数 $p$。对于每个 $p$，我们淘汰掉 $\\mathcal{A}(x)$ 中满足 $n \\equiv 0 \\pmod p$ 或 $n \\equiv -2 \\pmod p$ 的元素。\n- **索引映射**: 这些同余条件可以转化为关于数组索引 $k$ 的线性同余方程：\n  - $2k+3 \\equiv 0 \\pmod p \\implies k \\equiv -3 \\cdot 2^{-1} \\pmod p$\n  - $2k+3 \\equiv -2 \\pmod p \\implies k \\equiv -5 \\cdot 2^{-1} \\pmod p$\n  其中 $2^{-1} \\pmod p$ 是 2 在模 $p$ 下的乘法逆元，对于奇素数 $p$ 等于 $(p+1)/2$。\n- **执行筛选**: 对于每个素数 $p$，我们计算出两个起始索引 $k_0, k_1 \\in [0, p-1]$，然后在 `survivors` 数组中将所有形如 $k_0+jp$ 和 $k_1+jp$ 的索引位置标记为 `false`。\n- **最终计数**: $S_z(x)$ 就是 `survivors` 数组中最终为 `true` 的元素个数。\n\n**3. 计算 $U_{\\text{prod}}(x,z)$**\n这是一个直接的乘积计算：$U_{\\text{prod}}(x,z) = X(x) \\cdot W(z)$。\n- $X(x)$ 的计算如上所述。\n- $W(z) = \\prod_{3 \\le p \\le z, p \\text{ is prime}} \\left(1 - \\frac{2}{p}\\right)$ 可以通过遍历预先计算好的素数列表并累乘这些因子来得到。如果不存在 $3 \\le p \\le z$ 的素数，则空积为 1。\n- 最终结果需四舍五入到小数点后 6 位。\n\n**4. 计算 $T(x)$ 和 $B_z(x)$**\n这两个量是直接的计数。\n- **$T(x)$**: 遍历从 3 到 $x-2$ 的所有奇数 $n$。对于每个 $n$，使用预计算的 `is_prime` 数组检查 $n$ 和 $n+2$ 是否都为素数。若是，则计数器加一。\n- **$B_z(x)$**: 过程与 $T(x)$ 相同，但循环的上限为 $\\min(x-2, z)$。\n\n**5. 组装五元组**\n在计算完所有部分后，我们组装最终结果：\n- $U_{\\text{bound}}(x,z)$ 由 $S_z(x) + B_z(x)$ 给出。该上界是有效的，因为任何孪生素数对 $(n, n+2)$ 要么满足 $n \\le z$（被 $B_z(x)$ 计入），要么满足 $n > z$。在后一种情况下，$n$ 和 $n+2$ 都是大于 $z$ 的素数，因此它们必然会在以 $z$ 为上限的筛选过程中幸存下来，其数量由 $S_z(x)$ 提供上界。\n- 检查不等式 $T(x) \\le U_{\\text{bound}}(x,z)$ 是否成立。\n- 将这五个值按顺序放入一个列表中，对所有测试用例重复此过程，并格式化最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef sieve_eratosthenes(n_max):\n    \"\"\"\n    Generates primes up to n_max using the Sieve of Eratosthenes.\n    Returns:\n        is_prime (np.ndarray): A boolean array where is_prime[i] is True if i is prime.\n        primes (list): A list of prime numbers up to n_max.\n    \"\"\"\n    if n_max  2:\n        return np.zeros(n_max + 1, dtype=bool), []\n    \n    is_prime = np.ones(n_max + 1, dtype=bool)\n    is_prime[0:2] = False\n    for i in range(2, int(np.sqrt(n_max)) + 1):\n        if is_prime[i]:\n            is_prime[i*i::i] = False\n    \n    primes = np.where(is_prime)[0].tolist()\n    return is_prime, primes\n\ndef compute_quintuple(x, z, all_primes, is_prime):\n    \"\"\"\n    Computes the quintuple [S_z(x), U_prod(x,z), U_bound(x,z), T(x), check]\n    for a given (x, z) test case.\n    \"\"\"\n    # Calculate X(x): size of the base set A(x) = {n odd: 3 = n = x-2}\n    X = max(((x - 1) // 2) - 1, 0)\n\n    # Calculate S_z(x): sifted set count\n    if X = 0:\n        S_z_x = 0\n    else:\n        # Array of booleans representing n_k = 2k+3 for k in [0, X-1]\n        survivors = np.ones(X, dtype=bool)\n        sieve_primes = [p for p in all_primes if 3 = p = z]\n        \n        for p in sieve_primes:\n            # Modular inverse of 2 mod p is (p+1)/2 for odd prime p\n            inv2 = (p + 1) // 2\n            \n            # Find starting index k for n = 0 (mod p)\n            # 2k + 3 = 0 (mod p) => 2k = -3 (mod p) => k = -3 * inv2 (mod p)\n            k0 = (-3 * inv2) % p\n            \n            # Find starting index k for n = -2 (mod p)\n            # 2k + 3 = -2 (mod p) => 2k = -5 (mod p) => k = -5 * inv2 (mod p)\n            k1 = (-5 * inv2) % p\n            \n            # Sieve the candidates array\n            if k0  X:\n                survivors[k0::p] = False\n            # k0 != k1 for odd p, so no need to check for double-sieving the same progression\n            if k1  X:\n                survivors[k1::p] = False\n                \n        S_z_x = int(np.sum(survivors))\n\n    # Calculate W(z) and U_prod(x, z)\n    sieve_primes_for_W = [p for p in all_primes if 3 = p = z]\n    W_z = 1.0\n    if sieve_primes_for_W:\n        factors = [1.0 - 2.0/p for p in sieve_primes_for_W]\n        W_z = np.prod(factors)\n    \n    U_prod_x_z = round(X * W_z, 6)\n\n    # Calculate T(x): twin prime counting function up to x\n    T_x = 0\n    upper_n_T = x - 2\n    # n must be odd so we can step by 2\n    for n in range(3, upper_n_T + 1, 2):\n        if n + 2  len(is_prime) and is_prime[n] and is_prime[n+2]:\n            T_x += 1\n\n    # Calculate B_z(x): twin primes with smaller member = min(x-2, z)\n    B_z_x = 0\n    upper_n_B = min(x - 2, z)\n    for n in range(3, upper_n_B + 1, 2):\n        if n + 2  len(is_prime) and is_prime[n] and is_prime[n+2]:\n            B_z_x += 1\n            \n    # Calculate U_bound(x, z)\n    U_bound_x_z = S_z_x + B_z_x\n    \n    # Check the inequality T(x) = U_bound(x, z)\n    bound_check = (T_x = U_bound_x_z)\n    \n    return [S_z_x, U_prod_x_z, U_bound_x_z, T_x, bound_check]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (200, 13),\n        (1000, 37),\n        (50, 2),\n        (10000, 97),\n    ]\n\n    max_x = 0\n    if test_cases:\n        max_x = max(case[0] for case in test_cases)\n\n    # Pre-compute primes up to a safe limit. Primality of n+2 for n up to x-2 is needed.\n    # The largest n+2 is max_x.\n    prime_limit = max_x + 2 # Safely cover n+2\n    is_prime, all_primes = sieve_eratosthenes(prime_limit)\n\n    results = []\n    for x, z in test_cases:\n        result = compute_quintuple(x, z, all_primes, is_prime)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    result_strings = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3009401"}, {"introduction": "在任何筛法应用中，一个关键的策略性决策是选择篩選上限 $z$。一个更大的 $z$ 会改进主项，但会使误差项变差。最后一个练习将让你扮演理论家的角色，任务是为一个布朗筛上界模型优化这种权衡。通过应用微积分和渐近分析，你将确定 $z$ 的最优选择，从而从筛法中获得最强的可能结果 [@problem_id:3009399]。", "problem": "设 $x \\geq \\exp(\\exp(1))$ 是一个大的实数参数。考虑将布朗纯筛法应用于集合 $\\mathcal{A} = \\{n \\leq x : n \\text{ 和 } n+2 \\text{ 均为素数}\\}$，其中筛分集合 $\\mathcal{P}$ 为所有素数的集合，筛分水平为 $z \\in [2,x)$。对于多项式 $n(n+2)$，该筛法的维数为 $\\kappa = 2$，其在经典纯筛法框架下的上界可分为一个主项和一个误差项。使用维数 $\\kappa = 2$ 和关于素数的默滕斯型乘积估计，主项可以被一致地建模为一个量级为 $(\\ln z)^{-2}$ 的因子，而截断误差可以被一个关于 $z$ 的多项式项所控制。特别地，在这些被广泛接受的筛法启发式下，可以得到一个形式如下的上界\n$$\nU(x,z) \\leq \\frac{A\\,x}{(\\ln z)^{2}} + B\\,z^{2},\n$$\n其中 $A0$ 和 $B0$ 是绝对常数，分别来自于筛法的局部权重（对于 $\\kappa = 2$）和组合截断余项，且与 $x$ 和 $z$ 无关。\n\n将 $U(x,z)$ 视为固定大数 $x$ 下关于 $z$ 的函数，确定一个渐近最优选择 $z = z^{\\ast}(x)$，它在 $x \\to \\infty$ 时最小化 $U(x,z)$，并以 $x$, $A$, $B$ 的闭式形式表示。你的最终答案必须是一个单一的解析表达式。不需要四舍五入。", "solution": "问题要求我们找到筛分水平 $z$ 的渐近最优选择，记为 $z^{\\ast}(x)$，使得对于一个固定的大的 $x$，上界函数 $U(x,z)$ 被最小化。该函数由下式给出：\n$$U(x,z) = \\frac{A x}{(\\ln z)^{2}} + B z^{2}$$\n其中 $x$ 是一个大参数，$z \\in [2, x)$ 是待优化的变量，$A  0, B  0$ 是绝对常数。\n\n为了找到最小化 $U(x,z)$ 的 $z$ 值，我们将 $U$ 视为 $z$ 的函数，并使用微积分来找到其临界点。我们计算 $U(x,z)$ 关于 $z$ 的一阶导数，并将其设为零。\n\n设 $f(z) = U(x,z)$。$f(z)$ 关于 $z$ 的导数是：\n$$\\frac{d f}{dz} = \\frac{d}{dz} \\left( A x (\\ln z)^{-2} + B z^{2} \\right)$$\n使用链式法则和幂法则进行微分：\n$$\\frac{d}{dz} \\left( A x (\\ln z)^{-2} \\right) = A x \\cdot (-2) (\\ln z)^{-3} \\cdot \\frac{d}{dz}(\\ln z) = -2 A x (\\ln z)^{-3} \\cdot \\frac{1}{z} = -\\frac{2 A x}{z (\\ln z)^{3}}$$\n第二项的导数是：\n$$\\frac{d}{dz} (B z^{2}) = 2 B z$$\n结合这两部分， $f(z)$ 的导数是：\n$$\\frac{d f}{dz} = 2 B z - \\frac{2 A x}{z (\\ln z)^{3}}$$\n为了求最小值，我们将导数设为零，这发生在 $z = z^{\\ast}$ 处：\n$$2 B z^{\\ast} - \\frac{2 A x}{z^{\\ast} (\\ln z^{\\ast})^{3}} = 0$$\n$$2 B z^{\\ast} = \\frac{2 A x}{z^{\\ast} (\\ln z^{\\ast})^{3}}$$\n两边乘以 $z^{\\ast}$ 并除以 $2$，我们得到定义最优 $z^{\\ast}$ 的方程：\n$$B (z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = A x$$\n$$(z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = \\frac{A x}{B}$$\n这个方程无法用初等函数解出 $z^{\\ast}$。然而，问题要求的是当 $x \\to \\infty$ 时的渐近最优选择。我们可以找到 $z^{\\ast}$ 的一个渐近解。\n\n当 $x \\to \\infty$ 时，右侧的 $\\frac{A x}{B}$ 增长，这意味着 $z^{\\ast}$ 也必须增长。我们对方程两边取自然对数：\n$$\\ln\\left((z^{\\ast})^{2} (\\ln z^{\\ast})^{3}\\right) = \\ln\\left(\\frac{A x}{B}\\right)$$\n$$2 \\ln(z^{\\ast}) + 3 \\ln(\\ln z^{\\ast}) = \\ln(x) + \\ln\\left(\\frac{A}{B}\\right)$$\n对于大的 $x$，$z^{\\ast}$ 也很大，并且 $\\ln(z^{\\ast})$ 比 $\\ln(\\ln z^{\\ast})$ 增长得快得多。因此，方程中的主导项是左边的 $2 \\ln(z^{\\ast})$ 和右边的 $\\ln(x)$。这给了我们一个一阶渐近近似：\n$$2 \\ln(z^{\\ast}) \\approx \\ln(x)$$\n$$\\ln(z^{\\ast}) \\approx \\frac{1}{2} \\ln(x)$$\n现在我们可以用这个近似来找到 $z^{\\ast}$ 的一个渐近表达式。从方程 $(z^{\\ast})^{2} (\\ln z^{\\ast})^{3} = \\frac{A x}{B}$，我们可以写出：\n$$(z^{\\ast})^{2} = \\frac{A x}{B(\\ln z^{\\ast})^{3}}$$\n$$z^{\\ast} = \\sqrt{\\frac{A x}{B(\\ln z^{\\ast})^{3}}} = \\left(\\frac{A x}{B}\\right)^{1/2} (\\ln z^{\\ast})^{-3/2}$$\n将我们的近似 $\\ln(z^{\\ast}) \\approx \\frac{1}{2} \\ln(x)$ 代入这个表达式中：\n$$z^{\\ast} \\approx \\left(\\frac{A x}{B}\\right)^{1/2} \\left(\\frac{1}{2} \\ln x\\right)^{-3/2}$$\n$$z^{\\ast} \\approx \\left(\\frac{A}{B}\\right)^{1/2} x^{1/2} \\left(\\frac{1}{2}\\right)^{-3/2} (\\ln x)^{-3/2}$$\n因为 $(\\frac{1}{2})^{-3/2} = (2^{ -1})^{-3/2} = 2^{3/2} = 2\\sqrt{2}$，我们有：\n$$z^{\\ast} \\approx \\left(\\frac{A}{B}\\right)^{1/2} x^{1/2} (2\\sqrt{2}) (\\ln x)^{-3/2}$$\n$$z^{\\ast} \\approx 2\\sqrt{2} \\sqrt{\\frac{A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}$$\n这可以更紧凑地写作：\n$$z^{\\ast} \\approx \\sqrt{\\frac{8A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}$$\n这就是最优筛分水平 $z^{\\ast}(x)$ 的主阶渐近表达式。\n\n为了确认这是一个最小值，我们可以检查 $f(z)$ 的二阶导数的符号：\n$$\\frac{d^2 f}{dz^2} = \\frac{d}{dz} \\left( 2 B z - 2 A x z^{-1} (\\ln z)^{-3} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B - 2 A x \\left( (-1)z^{-2}(\\ln z)^{-3} + z^{-1}(-3)(\\ln z)^{-4} \\frac{1}{z} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B + 2 A x \\left( z^{-2}(\\ln z)^{-3} + 3 z^{-2}(\\ln z)^{-4} \\right)$$\n$$\\frac{d^2 f}{dz^2} = 2 B + \\frac{2 A x}{z^2 (\\ln z)^3} \\left( 1 + \\frac{3}{\\ln z} \\right)$$\n在临界点 $z^{\\ast}$ 处，我们知道 $B(z^{\\ast})^2(\\ln z^{\\ast})^3 = Ax$。因此，$\\frac{Ax}{(z^{\\ast})^2(\\ln z^{\\ast})^3} = B$。将此代入在 $z=z^{\\ast}$ 处计算的二阶导数表达式中：\n$$\\left. \\frac{d^2 f}{dz^2} \\right|_{z=z^{\\ast}} = 2 B + 2 B \\left( 1 + \\frac{3}{\\ln z^{\\ast}} \\right) = 4 B + \\frac{6 B}{\\ln z^{\\ast}}$$\n由于 $B  0$ 且 $z^{\\ast}$ 很大（因此 $\\ln z^{\\ast}  0$），二阶导数为正。因此，临界点 $z^{\\ast}$ 对应一个局部最小值，由于函数的形状，它在指定范围内也是全局最小值。\n因此，渐近最优选择 $z = z^{\\ast}(x)$ 由导出的表达式给出。", "answer": "$$\\boxed{\\sqrt{\\frac{8A}{B}} \\frac{x^{1/2}}{(\\ln x)^{3/2}}}$$", "id": "3009399"}]}