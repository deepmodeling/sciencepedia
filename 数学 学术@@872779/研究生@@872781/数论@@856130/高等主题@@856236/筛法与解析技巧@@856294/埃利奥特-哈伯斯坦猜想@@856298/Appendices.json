{"hands_on_practices": [{"introduction": "理论的深度最终需要通过经验数据来感受和检验。这项练习将理论付诸实践，要求您通过计算来直接观察算术级数中的素数分布 [@problem_id:3025852]。通过编写程序计算切比雪夫函数 $\\psi(x;q,a)$ 并将其与期望的主项进行比较，您将对误差项的实际大小及其与启发式预测的 $\\sqrt{x}$ 尺度的关系有一个具体的认识。", "problem": "设 $q$ 为一个正整数，$a$ 为模 $q$ 的一个整数剩余类，并令 $\\Lambda(n)$ 表示冯·曼戈尔特函数，其定义为 $$\\Lambda(n)=\\begin{cases}\\log p,  \\text{若 } n=p^k \\text{ 对于某个素数 } p \\text{ 和整数 } k\\geq 1,\\\\ 0,  \\text{其他情况。}\\end{cases}$$ 定义等差数列中的切比雪夫函数为 $$\\psi(x;q,a)=\\sum_{\\substack{1\\leq n\\leq x\\\\ n\\equiv a\\ (\\mathrm{mod}\\ q)}}\\Lambda(n)。$$ 设 $\\varphi(q)$ 为欧拉总计函数，并定义期望主项 $$M(x;q,a)=\\begin{cases}\\dfrac{x}{\\varphi(q)},  \\text{若 } \\gcd(a,q)=1,\\\\ 0,  \\text{若 } \\gcd(a,q)>1。\\end{cases}$$ 定义偏差 $$E(x;q,a)=\\psi(x;q,a)-M(x;q,a)。$$ 埃利奥特-哈伯斯坦猜想（EH）关注的是在模 $q$ 达到 $x^{1-\\varepsilon}$ 时这些偏差的平均大小，而启发式方法表明，在许多情况下，平方根对消尺度（例如 $|E(x;q,a)|$）平均与 $\\sqrt{x}$ 相当。\n\n你的任务是使用自然对数实现 $\\Lambda(n)$ 的计算模型，并计算 $\\psi(x;q,a)$、偏差 $E(x;q,a)$，然后将 $|E(x;q,a)|$ 与指定测试套件的启发式大小 $\\sqrt{x}$ 进行比较。对于每个测试用例，你必须输出列表 $$\\big[\\psi(x;q,a),\\ E(x;q,a),\\ |E(x;q,a)|/\\sqrt{x},\\ |E(x;q,a)|\\leq \\sqrt{x}\\big]，$$ 其中最后一项是一个布尔值，表示观测到的偏差是否最多为启发式基准。\n\n仅使用纯粹的数学和算法推理；不要依赖任何外部数据。所有对数都必须是自然对数。不涉及物理单位。不涉及角度。所有百分比（如有）必须表示为小数或分数，但此处不需要。\n\n所需的测试套件包括以下参数集：\n- 正常路径，素数模和简化剩余类：$(x,q,a)=(10^4,5,1)$, $(10^4,5,2)$, $(10^4,5,3)$, $(10^4,5,4)$。\n- 最小 $x$ 值的边界条件：$(x,q,a)=(1,5,1)$。\n- 非互质剩余类的边缘情况：$(x,q,a)=(100,5,0)$。\n- 同时包含互质和非互质剩余类的合数模：$(x,q,a)=(10^4,8,1)$ 和 $(10^4,8,2)$。\n- 备用素数模：$(x,q,a)=(10^3,7,3)$。\n- 相对于 $x$ 的大模数：$(x,q,a)=(200,97,1)$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个元素对应上面列出的一个测试用例（顺序相同），并且每个元素本身都是一个形如 $[\\psi,E,|E|/\\sqrt{x},\\text{布尔值}]$ 的方括号逗号分隔列表。例如，输出格式必须是 $$\\big[[\\cdots],[\\cdots],\\ldots,[\\cdots]\\big]，$$ 不含任何附加文本。", "solution": "该问题是有效的。这是一个在解析数论领域中定义明确的计算问题，基于标准的、普遍接受的定义和一个著名的猜想。所有必要的数据和定义都已提供，问题是自洽且客观的。\n\n### **问题验证**\n\n#### **步骤 1：提取已知信息**\n-   **冯·曼戈尔特函数, $\\Lambda(n)$**:\n    $$\\Lambda(n)=\\begin{cases}\\log p,  \\text{若 } n=p^k \\text{ 对于某个素数 } p \\text{ 和整数 } k\\geq 1,\\\\ 0,  \\text{其他情况。}\\end{cases}$$\n-   **切比雪夫函数, $\\psi(x;q,a)$**:\n    $$\\psi(x;q,a)=\\sum_{\\substack{1\\leq n\\leq x\\\\ n\\equiv a\\ (\\mathrm{mod}\\ q)}}\\Lambda(n)。$$\n-   **欧拉总计函数, $\\varphi(q)$**。\n-   **期望主项, $M(x;q,a)$**:\n    $$M(x;q,a)=\\begin{cases}\\dfrac{x}{\\varphi(q)},  \\text{若 } \\gcd(a,q)=1,\\\\ 0,  \\text{若 } \\gcd(a,q)>1。\\end{cases}$$\n-   **偏差, $E(x;q,a)$**:\n    $$E(x;q,a)=\\psi(x;q,a)-M(x;q,a)。$$\n-   **启发式基准**: 将 $|E(x;q,a)|$ 与 $\\sqrt{x}$ 进行比较。\n-   **每个测试用例的所需输出**: 一个包含四个值的列表：\n    $$\\big[\\psi(x;q,a),\\ E(x;q,a),\\ |E(x;q,a)|/\\sqrt{x},\\ |E(x;q,a)|\\leq \\sqrt{x}\\big]。$$\n-   **测试套件**:\n    1.  $(x,q,a)=(10^4,5,1)$\n    2.  $(x,q,a)=(10^4,5,2)$\n    3.  $(x,q,a)=(10^4,5,3)$\n    4.  $(x,q,a)=(10^4,5,4)$\n    5.  $(x,q,a)=(1,5,1)$\n    6.  $(x,q,a)=(100,5,0)$\n    7.  $(x,q,a)=(10^4,8,1)$\n    8.  $(x,q,a)=(10^4,8,2)$\n    9.  $(x,q,a)=(10^3,7,3)$\n    10. $(x,q,a)=(200,97,1)$\n\n#### **步骤 2：使用提取的已知信息进行验证**\n-   **科学依据**: 该问题基于解析数论的基本概念：冯·曼戈尔特函数、等差数列中的切比雪夫 psi 函数和欧拉总计函数。对埃利奥特-哈伯斯坦猜想和平方根对消启发式的引用是素数分布研究的核心主题。所有定义和原理在科学上都是合理的。\n-   **定义明确**: 对于任何有效的输入集 $(x,q,a)$，要计算的量都是唯一定义的。计算任务清晰，每个测试用例都有一个可验证的唯一解。\n-   **客观性**: 该问题使用精确的数学语言和定义进行陈述，没有任何主观性或歧义。\n\n该问题没有任何无效性缺陷。它是数论领域内一个定义明确的计算任务。\n\n#### **步骤 3：结论与行动**\n问题陈述是**有效的**。将提供解决方案。\n\n### **方法论与解决方案**\n\n目标是为每个测试用例 $(x,q,a)$ 计算四个量：$\\psi(x;q,a)$、$E(x;q,a)$、比率 $|E(x;q,a)|/\\sqrt{x}$ 以及布尔比较 $|E(x;q,a)| \\le \\sqrt{x}$。这需要实现几个数论函数。\n\n#### **1. 预计算冯·曼戈尔特函数 $\\Lambda(n)$**\n\n为了高效计算涉及 $\\Lambda(n)$ 值求和的 $\\psi(x;q,a)$，最好预先计算所有整数 $n$（直至测试套件中 $x$ 的最大值 $10^4$）的 $\\Lambda(n)$。一种类似于埃拉托斯特尼筛法的基于筛法的方法适用于此目的。\n\n算法如下：\n1.  初始化一个大小为 $x_{max}+1$ 的数组 `lambda_vals` 并用零填充，其中 $x_{max} = 10^4$。\n2.  初始化一个大小为 $x_{max}+1$ 的布尔数组 `is_prime`，从索引 2 开始的所有条目均为 `True`。将 0 和 1 标记为非素数。\n3.  从 2 遍历到 $x_{max}$ 的整数 $p$。\n4.  如果 `is_prime[p]` 为 `True`，则 $p$ 是一个素数。\n    a.  首先，在 `is_prime` 数组中将 $p$ 的所有倍数（$2p, 3p, ...$）标记为非素数。\n    b.  接下来，计算 $\\log p$。该值被赋给此素数的所有幂 $n = p^k$ 的 $\\Lambda(n)$。只要 $p^k \\le x_{max}$，就遍历 $p$ 的幂 $p^k = p, p^2, p^3, \\dots$，并设置 `lambda_vals[p^k] = log(p)`。\n\n这个过程高效地填充了 `lambda_vals` 数组。对于任何非素数幂的合数 $n$，`lambda_vals[n]` 将保持为 0，这与 $\\Lambda(n)$ 的定义一致。\n\n#### **2. 辅助函数的计算**\n\n主项 $M(x;q,a)$ 的计算需要欧拉总计函数 $\\varphi(q)$ 和最大公约数 $\\gcd(a,q)$。\n\n**欧拉总计函数 $\\varphi(q)$:**\n对于整数 $q > 1$，$\\varphi(q)$ 是小于等于 $q$ 且与 $q$ 互质的正整数的个数。它可以使用基于 $q$ 的不同素因子的乘积公式计算：\n$$ \\varphi(q) = q \\prod_{p|q, p \\text{ 是素数}} \\left(1 - \\frac{1}{p}\\right) $$\n一个有效的计算算法是：\n1.  初始化 `result = q`。\n2.  从 2 开始遍历候选素数 $p$。\n3.  如果 $p$ 整除 $q$ 的剩余部分，则通过 `result = result - result/p` 更新结果，并从 $q$ 中除掉所有因子 $p$。\n4.  重复此过程，直到 $q$ 的剩余部分为 1 或 $p$ 的平方超过它。如果还剩下一个大于 $\\sqrt{q}$ 的素因子，则需要对该因子进行最后一次更新。\n\n**最大公约数 $\\gcd(a,q)$:**\n这使用标准的欧几里得算法计算，该算法在 Python 的 `math` 库中可用。对于测试用例 $(100, 5, 0)$，我们注意到 $\\gcd(0,q) = q$。\n\n#### **3. 主要量的计算**\n\n对于每个测试用例 $(x,q,a)$：\n\n1.  **切比雪夫函数 $\\psi(x;q,a)$**:\n    $$\\psi(x;q,a)=\\sum_{\\substack{1\\leq n\\leq x\\\\ n\\equiv a\\ (\\mathrm{mod}\\ q)}}\\Lambda(n)$$\n    该和通过遍历从 1 到 $x$ 满足同余式 $n \\equiv a \\pmod{q}$ 的所有整数 $n$ 来计算。一种高效的方法是确定等差数列的第一项 $n_{start}$，即满足 $n_{start} \\equiv a \\pmod{q}$ 的最小正整数。这可以计算为 $n_{start} = (a-1) \\pmod q + 1$。然后，求和就变成对 $n = n_{start}, n_{start}+q, n_{start}+2q, \\dots$ 直到 $x$ 的迭代，累加预先计算的 `lambda_vals[n]`。\n\n2.  **期望主项 $M(x;q,a)$**:\n    $$M(x;q,a)=\\begin{cases}\\dfrac{x}{\\varphi(q)},  \\text{若 } \\gcd(a,q)=1,\\\\ 0,  \\text{若 } \\gcd(a,q)>1。\\end{cases}$$\n    首先，计算 $g = \\gcd(a,q)$。如果 $g=1$，则计算 $\\varphi_q = \\varphi(q)$ 并设置 $M(x;q,a) = x / \\varphi_q$。否则，$M(x;q,a)=0$。\n\n3.  **偏差 $E(x;q,a)$**:\n    这是直接的差值：$E(x;q,a) = \\psi(x;q,a) - M(x;q,a)$。\n\n4.  **比率和启发式检查**:\n    最后两个值由 $E(x;q,a)$ 导出：\n    -   比率为 $|E(x;q,a)| / \\sqrt{x}$。\n    -   布尔检查是比较 $|E(x;q,a)| \\le \\sqrt{x}$ 的结果。\n\n这种结构化方法确保每个组件都得到正确而高效的计算，从而为每个测试用例生成最终的四元素列表。然后将所有测试用例的结果汇总到一个列表的列表中，作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef sieve_for_lambda(limit):\n    \"\"\"\n    Computes von Mangoldt function Lambda(n) for n up to limit using a sieve.\n    \"\"\"\n    lambda_vals = np.zeros(limit + 1)\n    is_prime = np.ones(limit + 1, dtype=bool)\n    is_prime[0] = is_prime[1] = False\n    for p in range(2, limit + 1):\n        if is_prime[p]:\n            log_p = np.log(p)\n            # Sieve out multiples\n            for multiple in range(2 * p, limit + 1, p):\n                is_prime[multiple] = False\n            # Assign log(p) to powers of p\n            p_power = p\n            while p_power = limit:\n                lambda_vals[p_power] = log_p\n                # Prevent overflow before multiplication\n                if p_power > limit // p:\n                    break\n                p_power *= p\n    return lambda_vals\n\ndef phi(q):\n    \"\"\"\n    Computes Euler's totient function phi(q).\n    \"\"\"\n    if q == 1:\n        return 1\n    result = q\n    p = 2\n    temp_q = q\n    while p * p = temp_q:\n        if temp_q % p == 0:\n            while temp_q % p == 0:\n                temp_q //= p\n            result -= result // p\n        p += 1\n    if temp_q > 1:\n        result -= result // temp_q\n    return result\n\ndef calculate_psi(x, q, a, lambda_vals):\n    \"\"\"\n    Computes the Chebyshev function psi(x; q, a).\n    \"\"\"\n    x_int = int(x)\n    psi_val = 0.0\n    \n    # Start iteration from the first positive integer n = a (mod q)\n    # The formula (a-1)%q + 1 works for a >= 0 in Python.\n    # e.g., a=5, q=5 -> (4%5)+1 = 5. a=0, q=5 -> (-1%5)+1 = 4+1=5. a=1, q=5 -> (0%5)+1=1.\n    n_start = (a - 1) % q + 1\n    \n    for n in range(n_start, x_int + 1, q):\n        psi_val += lambda_vals[n]\n        \n    return psi_val\n\ndef solve():\n    \"\"\"\n    Main solver function to process test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10**4, 5, 1),\n        (10**4, 5, 2),\n        (10**4, 5, 3),\n        (10**4, 5, 4),\n        (1, 5, 1),\n        (100, 5, 0),\n        (10**4, 8, 1),\n        (10**4, 8, 2),\n        (10**3, 7, 3),\n        (200, 97, 1),\n    ]\n\n    max_x = 0\n    if test_cases:\n        max_x = int(max(tc[0] for tc in test_cases))\n\n    # Pre-compute Lambda values\n    lambda_vals = sieve_for_lambda(max_x)\n    \n    results = []\n    for x, q, a in test_cases:\n        # 1. Compute psi(x; q, a)\n        psi = calculate_psi(x, q, a, lambda_vals)\n        \n        # 2. Compute M(x; q, a)\n        g = math.gcd(a, q)\n        if g == 1:\n            phi_q = phi(q)\n            m_xaq = x / phi_q\n        else:\n            m_xaq = 0.0\n            \n        # 3. Compute E(x; q, a)\n        e_xaq = psi - m_xaq\n        \n        # 4. Compute ratio and boolean check\n        sqrt_x = np.sqrt(x)\n        ratio = np.abs(e_xaq) / sqrt_x if sqrt_x > 0 else 0.0\n        is_le_heuristic = np.abs(e_xaq) = sqrt_x\n        \n        results.append([psi, e_xaq, ratio, is_le_heuristic])\n\n    # Final print statement in the exact required format without spaces.\n    inner_strings = []\n    for r in results:\n        # Convert boolean to lowercase 'true'/'false' if required, but str(bool) gives 'True'/'False'\n        # The example format [...,boolean] suggests str(bool) is fine.\n        inner_strings.append(f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\")\n    \n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3025852"}, {"introduction": "在解析数论中，直接处理模 $q$ 的同余类通常很困难，更有效的方法是使用狄利克雷特征进行“傅里叶分析”。这项练习揭示了将关于同余类的和（物理空间）转化为关于特征的和（频率空间）的关键机制 [@problem_id:3025892]。掌握这种转换对于理解邦别里-维诺格拉多夫定理及其推广（如埃利奥特-哈伯斯坦猜想）的证明至关重要。", "problem": "设 $q \\geq 1$ 为一个整数，$\\varphi(q)$ 表示欧拉函数。对于一个模 $q$ 的狄利克雷特征，记为 $\\chi \\pmod q$，并用 $\\chi_{0}$ 表示主特征。定义由特征扭曲的切比雪夫函数为\n$$\n\\psi(x,\\chi) \\;=\\; \\sum_{n \\leq x} \\Lambda(n)\\,\\chi(n),\n$$\n以及在缩剩余类 $a \\pmod q$ (其中 $(a,q)=1$) 中的切比雪夫函数为\n$$\n\\psi(x;q,a) \\;=\\; \\sum_{\\substack{n \\leq x \\\\ n \\equiv a \\,(\\bmod q)}} \\Lambda(n).\n$$\n定义算术级数中的素数定理的误差项为\n$$\nE(x;q,a) \\;=\\; \\psi(x;q,a) \\;-\\; \\frac{x}{\\varphi(q)}.\n$$\n\n假设狄利克雷特征的正交性成立：\n$$\n\\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a)\\,\\chi(n)\n\\;=\\;\n\\begin{cases}\n1,  \\text{若 } n \\equiv a \\pmod q \\text{ 且 } (n,q)=1, \\\\\n0,  \\text{其它情况},\n\\end{cases}\n$$\n并假设对于某个函数 $\\mathcal{B}(x,Q)$ 以及所有模 $q \\leq Q$，我们有以下的一致界\n$$\n\\sum_{\\chi \\,(\\bmod q)} \\big|\\psi(x,\\chi)\\big| \\;\\leq\\; \\mathcal{B}(x,Q).\n$$\n\n仅使用这些输入以及狄利克雷特征和冯·曼戈尔特函数的基本性质，推导一个形如下式的误差项平均界\n$$\n\\frac{1}{\\varphi(q)} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} \\big|E(x;q,a)\\big|\n\\;\\leq\\; C(q)\\, \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_{0}}} \\big|\\psi(x,\\chi)\\big| \\;+\\; \\text{(明确的主特征修正项)},\n$$\n确定从剩余类求和与特征求和之间的转换中确定性地产生的精确乘法常数 $C(q)$。明确地计算 $C(q)$，给出其作为 $q$ 的闭式表达式。\n\n你的最终答案必须仅为 $C(q)$ 的表达式，不含单位。如果选择简化，请提供精确的符号表达式（不要数值近似）。", "solution": "问题在于为算術级数中的素数定理误差项的平均值推导一个界，并确定由此产生的乘法常数 $C(q)$。\n\n首先，我们将算術级数的切比雪夫函数 $\\psi(x;q,a)$ 用扭曲的切比雪夫函数 $\\psi(x,\\chi)$ 来表示。问题给出了模 $q$ 的狄利克雷特征的正交关系：对于 $(a,q)=1$，\n$$\n\\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a)\\,\\chi(n)\n\\;=\\;\n\\begin{cases}\n1,  \\text{若 } n \\equiv a \\pmod q,\\\\\n0,  \\text{其它情况}.\n\\end{cases}\n$$\n注意，对于 $n \\equiv a \\pmod q$ 且 $(a,q)=1$ 的情况，必然有 $(n,q)=1$。冯·曼戈尔特函数 $\\Lambda(n)$ 仅当 $n$ 是素数幂 $n=p^k$ 时才非零。对于一个模 $q$ 的特征 $\\chi$，标准定义是当 $(n,q)>1$ 时 $\\chi(n)=0$。因此，求和 $\\sum_{n \\leq x} \\Lambda(n)\\chi(n)$ 中的任何非零项都隐含了条件 $(n,q)=1$，除非 $q$ 是一个素数幂且 $n$ 是该素数的幂。然而，根据由本原特征诱导的特征的标准定义，对于所有模 $q$ 的特征 $\\chi$ (可能 $q=1$ 除外)，当 $(n,q)>1$ 时，$\\chi(n) = 0$。问题陈述意味着我们正在使用以这种标准方式定义在 $\\mathbb{Z}$ 上的特征。\n\n使用正交关系，我们可以将 $\\psi(x;q,a)$ 写为：\n$$\n\\psi(x;q,a) \\;=\\; \\sum_{\\substack{n \\leq x \\\\ n \\equiv a \\,(\\bmod q)}} \\Lambda(n) \\;=\\; \\sum_{n \\leq x} \\Lambda(n) \\left( \\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a)\\chi(n) \\right).\n$$\n我们可以交换求和顺序：\n$$\n\\psi(x;q,a) \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a) \\sum_{n \\leq x} \\Lambda(n)\\chi(n) \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a) \\psi(x,\\chi).\n$$\n\n接下来，我们构造误差项 $E(x;q,a)$：\n$$\nE(x;q,a) \\;=\\; \\psi(x;q,a) \\;-\\; \\frac{x}{\\varphi(q)} \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\chi \\,(\\bmod q)} \\overline{\\chi}(a) \\psi(x,\\chi) \\;-\\; \\frac{x}{\\varphi(q)}.\n$$\n我们分离出主特征 $\\chi_0$ 的贡献。由于 $(a,q)=1$，我们有 $\\overline{\\chi_0}(a)=1$。\n$$\nE(x;q,a) \\;=\\; \\frac{1}{\\varphi(q)} \\left( \\overline{\\chi_0}(a)\\psi(x,\\chi_0) + \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right) \\;-\\; \\frac{x}{\\varphi(q)}\n$$\n$$\nE(x;q,a) \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\;+\\; \\frac{\\psi(x,\\chi_0) - x}{\\varphi(q)}.\n$$\n问题要求推导 $|E(x;q,a)|$ 在所有模 $q$ 的缩剩余类 $a$ 上的平均值的界。所要求的界的形式是两项之和，这提示我们使用三角不等式 $|A+B| \\leq |A|+|B|$。\n$$\n|E(x;q,a)| \\;\\leq\\; \\left| \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right| \\;+\\; \\left| \\frac{\\psi(x,\\chi_0) - x}{\\varphi(q)} \\right|.\n$$\n现在，我们将此不等式对满足 $(a,q)=1$ 的 $\\varphi(q)$ 个 $a$ 值进行平均：\n$$\n\\frac{1}{\\varphi(q)} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} |E(x;q,a)| \\;\\leq\\; \\frac{1}{\\varphi(q)} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} \\left| \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right| \\;+\\; \\frac{|\\psi(x,\\chi_0) - x|}{\\varphi(q)}.\n$$\n第二项 $\\frac{|\\psi(x,\\chi_0) - x|}{\\varphi(q)}$ 是问题陈述中提到的“明确的主特征修正项”，因为它对 $a$ 的平均值就是其自身。\n\n现在我们关注第一项的上界，它必须具有 $C(q) \\sum_{\\chi \\neq \\chi_0} |\\psi(x,\\chi)|$ 的形式。设此项为 $M$：\n$$\nM \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} \\left| \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right| \\;=\\; \\frac{1}{\\varphi(q)^2} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} \\left| \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right|.\n$$\n为了获得一个以 $\\sum |\\psi(x,\\chi)|$ 表示的界，我们对内部关于特征的求和应用三角不等式：\n$$\n\\left| \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right| \\;\\leq\\; \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\overline{\\chi}(a)\\psi(x,\\chi)|.\n$$\n由于对于任何特征 $\\chi$ 和任何满足 $(a,q)=1$ 的 $a$，都有 $|\\overline{\\chi}(a)| = 1$，这可以简化为：\n$$\n\\left| \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} \\overline{\\chi}(a)\\psi(x,\\chi) \\right| \\;\\leq\\; \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\psi(x,\\chi)|.\n$$\n将此代回 $M$ 的表达式中：\n$$\nM \\;\\leq\\; \\frac{1}{\\varphi(q)^2} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} \\left( \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\psi(x,\\chi)| \\right).\n$$\n内部关于 $\\chi \\neq \\chi_0$ 的求和不依赖于 $a$。外部关于 $a$ 的求和包含 $\\varphi(q)$ 个相同的项。\n$$\nM \\;\\leq\\; \\frac{1}{\\varphi(q)^2} \\cdot \\varphi(q) \\left( \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\psi(x,\\chi)| \\right) \\;=\\; \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\psi(x,\\chi)|.\n$$\n这个推导得出了所需形式的界。通过将此结果与目标表达式\n$$\nM \\leq C(q)\\, \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_{0}}} \\big|\\psi(x,\\chi)\\big|,\n$$\n进行比较，我们可以确定从这一系列标准步骤中“确定性地”产生的常数 $C(q)$。\n该常数为：\n$$\nC(q) \\;=\\; \\frac{1}{\\varphi(q)}.\n$$\n推导出的完整不等式是：\n$$\n\\frac{1}{\\varphi(q)} \\sum_{\\substack{a \\,(\\bmod q) \\\\ (a,q)=1}} |E(x;q,a)| \\;\\leq\\; \\frac{1}{\\varphi(q)} \\sum_{\\substack{\\chi \\,(\\bmod q) \\\\ \\chi \\neq \\chi_0}} |\\psi(x,\\chi)| \\;+\\; \\frac{|\\psi(x,\\chi_0) - x|}{\\varphi(q)}.\n$$\n问题要求给出 $C(q)$ 的明确闭式表达式，我们已经找到了它。", "answer": "$$\\boxed{\\frac{1}{\\varphi(q)}}$$", "id": "3025892"}, {"introduction": "埃利奥特-哈伯斯坦猜想的核心思想是“弥散”现象，即素数在*平均意义下*对许多不同的模 $q$ 都表现出良好的分布。为了抓住这一核心思想而又不陷入全部技术复杂性，我们可以研究一个更简单的“玩具模型”[@problem_id:3025862]。这项练习用结构更清晰的拉马努金和来代替狄利克雷特征，通过计算其平均“能量”，您将以一种清晰可控的方式领会弥散法的精神。", "problem": "设 $c_{q}(n)$ 表示拉马努金和\n$$\nc_{q}(n) \\;=\\; \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} \\exp\\!\\Bigl(2\\pi i \\,\\frac{a n}{q}\\Bigr).\n$$\n本着作为 Elliott-Halberstam (EH) 猜想基础的离散法的精神，我们考虑以下玩具模型，其中拉马努金和取代了狄利克雷特征。对每个模 $q \\in \\mathbb{N}$，定义模型方差代理\n$$\nV(q) \\;:=\\; \\frac{1}{q}\\sum_{n=1}^{q} \\bigl|c_{q}(n)\\bigr|^{2}.\n$$\n将 $V(q)$ 解释为模 $q$ 处模型偏差的“能量”。为了说明在不同模之间的离散情况，构建截至 $Q$ 的归一化平均能量：\n$$\nA(Q) \\;:=\\; \\frac{1}{Q^{3}} \\sum_{q=1}^{Q} q\\,V(q).\n$$\n仅从上述定义和复指数的正交性出发，确定以下极限的精确值\n$$\n\\lim_{Q\\to\\infty} A(Q).\n$$\n请给出单一的精确表达式作为最终答案。无需四舍五入。", "solution": "问题要求计算当 $Q \\to \\infty$ 时，归一化平均能量 $A(Q)$ 的极限。所给定义如下：\n拉马努金和：\n$$\nc_{q}(n) \\;=\\; \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} \\exp\\!\\Bigl(2\\pi i \\,\\frac{a n}{q}\\Bigr)\n$$\n模型方差代理：\n$$\nV(q) \\;:=\\; \\frac{1}{q}\\sum_{n=1}^{q} \\bigl|c_{q}(n)\\bigr|^{2}\n$$\n归一化平均能量：\n$$\nA(Q) \\;:=\\; \\frac{1}{Q^{3}} \\sum_{q=1}^{Q} q\\,V(q)\n$$\n\n第一步是为 $q\\,V(q)$ 找出一个更简单的表达式。根据定义，\n$$\nq\\,V(q) = \\sum_{n=1}^{q} \\bigl|c_{q}(n)\\bigr|^{2}\n$$\n我们将 $|c_{q}(n)|^{2}$ 展开为 $c_{q}(n)\\overline{c_{q}(n)}$。使用 $c_q(n)$ 的定义：\n$$\n|c_{q}(n)|^{2} = \\left( \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} \\exp\\left(2\\pi i \\frac{an}{q}\\right) \\right) \\left( \\sum_{\\substack{b \\,(\\mathrm{mod}\\, q) \\\\ (b,q)=1}} \\exp\\left(-2\\pi i \\frac{bn}{q}\\right) \\right)\n$$\n合并求和，我们得到一个双重求和：\n$$\n|c_{q}(n)|^{2} = \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} \\sum_{\\substack{b \\,(\\mathrm{mod}\\, q) \\\\ (b,q)=1}} \\exp\\left(2\\pi i \\frac{(a-b)n}{q}\\right)\n$$\n现在，我们将其代入 $q\\,V(q)$ 的表达式中，并交换求和顺序：\n$$\nq\\,V(q) = \\sum_{n=1}^{q} \\sum_{\\substack{a, b \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1 \\\\ (b,q)=1}} \\exp\\left(2\\pi i \\frac{(a-b)n}{q}\\right) = \\sum_{\\substack{a, b \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1 \\\\ (b,q)=1}} \\sum_{n=1}^{q} \\exp\\left(2\\pi i \\frac{(a-b)n}{q}\\right)\n$$\n关于 $n$ 的内层求和是一个几何级数，可以使用复指数的正交性来求值。对于整数 $k$，该和由下式给出：\n$$\n\\sum_{n=1}^{q} \\exp\\left(2\\pi i \\frac{kn}{q}\\right) = \\begin{cases} q  \\text{如果 } q \\mid k \\\\ 0  \\text{如果 } q \\nmid k \\end{cases}\n$$\n在我们的例子中，$k = a-b$。由于 $a$ 和 $b$ 是模 $q$ 的剩余类的代表，通常从 $\\{1, 2, \\ldots, q\\}$ 中选取，因此条件 $q \\mid (a-b)$ 等价于 $a=b$。所以，如果 $a=b$，内层求和为 $q$；如果 $a \\neq b$，则为 $0$。\n\n这极大地简化了 $q\\,V(q)$ 的表达式，因为只有 $a=b$ 的项才能保留下来：\n$$\nq\\,V(q) = \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} \\sum_{\\substack{b \\,(\\mathrm{mod}\\, q) \\\\ (b,q)=1}} q \\cdot \\delta_{a,b} = \\sum_{\\substack{a \\,(\\mathrm{mod}\\, q) \\\\ (a,q)=1}} q\n$$\n这最后一个和式中的项数是集合 $\\{1, 2, \\ldots, q\\}$ 中满足 $(a,q)=1$ 的整数 $a$ 的数量。这正是欧拉函数 $\\phi(q)$ 的定义。\n因此，我们得到：\n$$\nq\\,V(q) = q\\,\\phi(q)\n$$\n\n现在我们将此结果代入 $A(Q)$ 的定义中：\n$$\nA(Q) = \\frac{1}{Q^{3}} \\sum_{q=1}^{Q} q\\,\\phi(q)\n$$\n问题现在简化为求和函数 $S(Q) = \\sum_{q=1}^{Q} q\\,\\phi(q)$ 的渐进行为。我们使用涉及莫比乌斯函数 $\\mu(d)$ 的著名恒等式：\n$$\n\\phi(q) = \\sum_{d|q} \\mu(d)\\frac{q}{d}\n$$\n因此，\n$$\nq\\,\\phi(q) = q \\sum_{d|q} \\mu(d)\\frac{q}{d} = \\sum_{d|q} \\mu(d)\\frac{q^2}{d}\n$$\n将此式从 $q=1$ 加到 $Q$：\n$$\nS(Q) = \\sum_{q=1}^{Q} \\sum_{d|q} \\mu(d)\\frac{q^2}{d}\n$$\n我们改变求和顺序。条件 $d|q$ 和 $1 \\le q \\le Q$ 等价于 $1 \\le d \\le Q$ 且对于某个整数 $k$ 有 $q=kd$，使得 $1 \\le kd \\le Q$，这意味着 $1 \\le k \\le \\lfloor Q/d \\rfloor$。\n$$\nS(Q) = \\sum_{d=1}^{Q} \\mu(d) \\sum_{k=1}^{\\lfloor Q/d \\rfloor} \\frac{(kd)^2}{d} = \\sum_{d=1}^{Q} d\\,\\mu(d) \\sum_{k=1}^{\\lfloor Q/d \\rfloor} k^2\n$$\n我们使用前 $N$ 个平方数的求和公式：$\\sum_{k=1}^{N} k^2 = \\frac{N(N+1)(2N+1)}{6} = \\frac{N^3}{3} + \\frac{N^2}{2} + \\frac{N}{6}$。令 $N_{d} = \\lfloor Q/d \\rfloor$。\n$$\nS(Q) = \\sum_{d=1}^{Q} d\\,\\mu(d) \\left( \\frac{N_d^3}{3} + \\frac{N_d^2}{2} + \\frac{N_d}{6} \\right)\n$$\n我们近似 $N_d = Q/d - \\{Q/d\\}$，其中 $0 \\le \\{Q/d\\}  1$。主项来自 $(Q/d)^3/3$。\n$$\nS(Q) = \\sum_{d=1}^{Q} d\\,\\mu(d) \\left( \\frac{1}{3}\\left(\\frac{Q}{d}\\right)^3 + O\\left(\\left(\\frac{Q}{d}\\right)^2\\right) \\right) = \\frac{Q^3}{3} \\sum_{d=1}^{Q} \\frac{\\mu(d)}{d^2} + O\\left(Q^2 \\sum_{d=1}^{Q}\\frac{|\\mu(d)|}{d}\\right)\n$$\n误差项是有界的，因为 $\\sum_{d=1}^{Q} \\frac{1}{d} \\sim \\ln(Q)$，所以误差为 $O(Q^2\\ln Q)$。\n对于主项，当 $Q \\to \\infty$ 时，有限和收敛于无穷级数：\n$$\n\\sum_{d=1}^{\\infty} \\frac{\\mu(d)}{d^2} = \\frac{1}{\\zeta(2)}\n$$\n其中 $\\zeta(s)$ 是黎曼zeta函数。$\\zeta(2)$ 的值是 $\\frac{\\pi^2}{6}$。因此，该和为 $\\frac{6}{\\pi^2}$。\n因此，$S(Q)$ 的渐进行为是：\n$$\nS(Q) \\sim \\frac{Q^3}{3} \\cdot \\frac{1}{\\zeta(2)} = \\frac{Q^3}{3} \\cdot \\frac{6}{\\pi^2} = \\frac{2Q^3}{\\pi^2}\n$$\n更正式地，\n$$\nS(Q) = \\frac{2Q^3}{\\pi^2} + O(Q^2 \\ln Q)\n$$\n最后，我们可以计算 $A(Q)$ 的极限：\n$$\n\\lim_{Q\\to\\infty} A(Q) = \\lim_{Q\\to\\infty} \\frac{1}{Q^3} \\sum_{q=1}^{Q} q\\,\\phi(q) = \\lim_{Q\\to\\infty} \\frac{1}{Q^3} \\left( \\frac{2Q^3}{\\pi^2} + O(Q^2 \\ln Q) \\right)\n$$\n$$\n\\lim_{Q\\to\\infty} A(Q) = \\lim_{Q\\to\\infty} \\left( \\frac{2}{\\pi^2} + O\\left(\\frac{\\ln Q}{Q}\\right) \\right) = \\frac{2}{\\pi^2}\n$$", "answer": "$$\\boxed{\\frac{2}{\\pi^2}}$$", "id": "3025862"}]}