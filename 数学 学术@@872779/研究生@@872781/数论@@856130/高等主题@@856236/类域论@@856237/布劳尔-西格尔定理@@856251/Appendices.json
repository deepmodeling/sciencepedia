{"hands_on_practices": [{"introduction": "任何深刻的理论都应从最基础的例子中得到验证。在深入探讨布劳尔-西格尔定理复杂的渐近行为之前，我们首先通过一个基础实践来巩固对解析类数公式的理解。[@problem_id:3025182] 将引导我们对最简单的数域——有理数域 $\\mathbb{Q}$——进行检验，从而揭示该公式中各个不变量（如类数、判别式、调节子）在这一基本情形下的具体含义。", "problem": "设 $K=\\mathbb{Q}$，并令 $\\zeta_{K}(s)$ 表示 $K$ 的戴德金zeta函数。从 $K=\\mathbb{Q}$ 的基本定义和标准性质出发进行推导。\n\n(a) 使用戴德金zeta函数作为 $\\mathcal{O}_{K}$ 的非零理想上的狄利克雷级数的定义，以及 $\\mathcal{O}_{\\mathbb{Q}}=\\mathbb{Z}$ 这一等同关系，明确地用经典的黎曼zeta函数表示 $\\zeta_{K}(s)$，并计算其留数 $\\operatorname{Res}_{s=1}\\zeta_{K}(s)$。\n\n(b) 确定 $K=\\mathbb{Q}$ 的每一个标准算术不变量：实嵌入的个数 $r_{1}$，复嵌入对的个数 $r_{2}$，判别式 $D_{K}$，类数 $h_{K}$，调节子 $R_{K}$，以及 $\\mathcal{O}_{K}$ 中单位根的个数 $w_{K}$。仅使用关于 $\\mathbb{Q}$ 的定义和熟知的结论。\n\n(c) 在不引用任何未证明的结论的情况下，解释为什么 (a) 部分得到的值与一般数域的解析类数公式在特定于 $K=\\mathbb{Q}$ 的情况下所预测的值相吻合，从而验证这个与布劳尔-西格尔框架相关的基本情形。\n\n将 $\\operatorname{Res}_{s=1}\\zeta_{K}(s)$ 的最终答案表示为一个精确的实数。", "solution": "此问题经验证为自洽、有科学依据且表述清晰。我们可以开始解答。\n\n(a) 我们的任务是确定数域 $K=\\mathbb{Q}$ 的戴德金zeta函数 $\\zeta_{K}(s)$，并求其在 $s=1$ 处的留数。\n\n对于数域 $K$，其戴德金zeta函数在 $\\operatorname{Re}(s) > 1$ 上定义为在其整数环 $\\mathcal{O}_{K}$ 的非零理想上构成的狄利克雷级数：\n$$ \\zeta_{K}(s) = \\sum_{0 \\neq \\mathfrak{a} \\subseteq \\mathcal{O}_{K}} \\frac{1}{(N(\\mathfrak{a}))^s} $$\n其中 $N(\\mathfrak{a}) = |\\mathcal{O}_{K}/\\mathfrak{a}|$ 是理想 $\\mathfrak{a}$ 的范数。\n\n对于数域 $K=\\mathbb{Q}$，其整数环是 $\\mathcal{O}_{\\mathbb{Q}} = \\mathbb{Z}$。由于 $\\mathbb{Z}$ 是一个主理想整环 (PID)，每个非零理想 $\\mathfrak{a}$ 都具有形式 $(n) = n\\mathbb{Z}$，其中 $n$ 是某个非零整数。理想 $(n)$ 和 $(-n)$ 是相同的，因此我们可以用一个正整数 $n \\in \\mathbb{Z}_{>0}$ 来唯一地表示每个非零理想。也就是说，在 $\\mathbb{Z}$ 的非零理想与正整数 $n=1, 2, 3, \\ldots$ 之间存在一一对应关系。\n\n$\\mathbb{Z}$ 中一个非零主理想 $(n)$ 的范数由商环的基数给出：\n$$ N((n)) = |\\mathbb{Z}/n\\mathbb{Z}| = |n| $$\n由于我们使用正整数 $n$ 来表示理想，范数就是 $N((n))=n$。\n\n将这些结果代入 $K=\\mathbb{Q}$ 的戴德金zeta函数的定义中，我们得到：\n$$ \\zeta_{\\mathbb{Q}}(s) = \\sum_{n=1}^{\\infty} \\frac{1}{(N((n)))^s} = \\sum_{n=1}^{\\infty} \\frac{1}{n^s} $$\n这个级数是经典的黎曼zeta函数 $\\zeta(s)$ 的定义。因此，我们有恒等式 $\\zeta_{\\mathbb{Q}}(s) = \\zeta(s)$。\n\n问题要求 $\\zeta_{K}(s)$ 在点 $s=1$ 处的留数。这等价于求黎曼zeta函数在 $s=1$ 处的留数。在黎曼zeta函数理论中，一个基本结果是 $\\zeta(s)$ 可以解析延拓到复平面 $\\mathbb{C} \\setminus \\{1\\}$，并在 $s=1$ 处有一个留数为 $1$ 的简单极点。\n$$ \\operatorname{Res}_{s=1}\\zeta_{K}(s) = \\operatorname{Res}_{s=1}\\zeta_{\\mathbb{Q}}(s) = \\operatorname{Res}_{s=1}\\zeta(s) = 1 $$\n\n(b) 现在我们确定 $K=\\mathbb{Q}$ 的标准算术不变量。\n\n$r_{1}$、$r_{2}$：将 $\\mathbb{Q}$ 嵌入 $\\mathbb{C}$ 是一个单射域同态 $\\sigma: \\mathbb{Q} \\to \\mathbb{C}$。由于任何此类同态都必须将 $1$ 映为 $1$，所以它在子域 $\\mathbb{Q}$ 上是恒等映射。因此，只存在一个嵌入，即对所有 $x \\in \\mathbb{Q}$ 都有 $\\sigma(x)=x$。这个嵌入的像是 $\\mathbb{Q}$，它是实数集 $\\mathbb{R}$ 的一个子集。因此，这是一个实嵌入。我们有 $r_1=1$ 个实嵌入。共轭复嵌入的对数是 $r_2$。扩张的次数为 $[K:\\mathbb{Q}] = n = r_1+2r_2$。对于 $K=\\mathbb{Q}$，我们有 $n=1$，所以 $1 = 1 + 2r_2$，这意味着 $r_2=0$。\n\n$D_{K}$：数域 $K$ 的判别式是 $\\mathcal{O}_{K}$ 的一个整基的判别式。对于 $K=\\mathbb{Q}$，$\\mathcal{O}_{K}=\\mathbb{Z}$，一个整基是 $\\{1\\}$。判别式定义为 $D_K = \\det( (\\sigma_i(b_j)) )^2$，其中 $\\{\\sigma_i\\}$ 是嵌入，$\\{b_j\\}$ 是整基。这里我们有一个嵌入 $\\sigma_1 = \\text{id}$ 和一个基元素 $b_1=1$。矩阵是 $1 \\times 1$ 矩阵 $(\\sigma_1(b_1)) = (1)$。因此，判别式为 $D_{\\mathbb{Q}} = \\det((1))^2 = 1^2 = 1$。\n\n$h_{K}$：类数 $h_{K}$ 是 $K$ 的理想类群的阶。理想类群衡量了一个整数环在多大程度上不是主理想整环。如 (a) 部分所述，$\\mathcal{O}_{\\mathbb{Q}} = \\mathbb{Z}$ 是一个主理想整环。这意味着每个理想都是主理想，所以理想类群是平凡群。平凡群的阶是 $1$。因此，类数为 $h_{\\mathbb{Q}} = 1$。\n\n$w_{K}$：数 $w_{K}$ 是包含在整数环 $\\mathcal{O}_{K}$ 中的单位根的个数。对于 $K=\\mathbb{Q}$，我们寻找元素 $\\zeta \\in \\mathbb{Z}$，使得对于某个整数 $m \\ge 1$ 有 $\\zeta^m = 1$。仅有的这类整数是 $1$ 和 $-1$。因此，$\\mathbb{Q}$ 中的单位根群是 $\\{1, -1\\}$，其个数为 $w_{\\mathbb{Q}}=2$。\n\n$R_{K}$：调节子 $R_{K}$ 与单位群 $\\mathcal{O}_{K}^{\\times}$ 相关。根据狄利克雷单位定理，单位群的秩为 $r = r_1 + r_2 - 1$。对于 $K=\\mathbb{Q}$，秩为 $r = 1 + 0 - 1 = 0$。秩为 $0$ 意味着单位群是有限群，仅由单位根组成。确实，$\\mathcal{O}_{\\mathbb{Q}}^{\\times} = \\mathbb{Z}^{\\times} = \\{1, -1\\}$。对于单位群的秩为 $0$ 的数域，根据约定，调节子定义为 $R_{K}=1$。这对应于一个 $0 \\times 0$ 矩阵的行列式。\n\n(c) 我们现在验证 (a) 部分的结果与解析类数公式是一致的。该公式指出，对于一个数域 $K$，$\\zeta_{K}(s)$ 在 $s=1$ 处的留数由以下公式给出：\n$$ \\operatorname{Res}_{s=1}\\zeta_{K}(s) = \\frac{2^{r_1}(2\\pi)^{r_2}h_K R_K}{w_K \\sqrt{|D_K|}} $$\n我们将 (b) 部分确定的 $K=\\mathbb{Q}$ 的不变量代入：\n- $r_1=1$\n- $r_2=0$\n- $h_K=1$\n- $R_K=1$\n- $w_K=2$\n- $D_K=1$\n\n将这些值代入公式中，得到：\n$$ \\operatorname{Res}_{s=1}\\zeta_{\\mathbb{Q}}(s) = \\frac{2^{1}(2\\pi)^{0} \\cdot 1 \\cdot 1}{2 \\cdot \\sqrt{|1|}} = \\frac{2 \\cdot 1 \\cdot 1 \\cdot 1}{2 \\cdot 1} = \\frac{2}{2} = 1 $$\n这个值 $1$ 与 (a) 部分通过直接计算得到的值 $\\operatorname{Res}_{s=1}\\zeta_{\\mathbb{Q}}(s)=1$ 完全吻合。这表明 $K=\\mathbb{Q}$ 的情况是广义解析类数公式的一个基本的、起验证作用的基准情形。这个公式将一个数域的深层算术不变量与其 zeta 函数的解析行为联系起来，它对于这个最简单的数域是成立的。\n所要求的最终答案是这个留数的值。", "answer": "$$\\boxed{1}$$", "id": "3025182"}, {"introduction": "在验证了基础情形后，我们转向布劳尔-西格尔定理的核心应用：描述一族数域中代数不变量的渐进行为。虚二次域为我们提供了一个理想的“实验室”，因为它们的调节子 $R_K$ 是平凡的。[@problem_id:3025206] 聚焦于这类数域，通过理论推导，让我们亲身体会布劳尔-西格尔定理如何简化为关于类数 $h_K$ 增长的纯粹论断，从而揭示判别式大小与类数复杂性之间的深刻联系。", "problem": "设 $K$ 是一个虚二次数域，其绝对判别式为 $|d_{K}|$，符号差为 $(r_{1}(K),r_{2}(K))$，类数为 $h_{K}$，调节子为 $R_{K}$，$\\mathcal{O}_{K}$ 中单位根的个数为 $w_{K}$。\n\n(a) 计算此类域 $K$ 的 $r_{1}(K)$、$r_{2}(K)$、$R_{K}$ 和 $w_{K}$，并指出对于特殊域 $K$ 出现的任何例外情况。\n\n(b) 考虑任意一个虚二次数域序列 $(K_{j})_{j\\geq 1}$，满足 $|d_{K_{j}}|\\to \\infty$。定义\n$$\nL \\;=\\; \\lim_{j\\to\\infty}\\frac{\\ln\\!\\big(h_{K_{j}}\\,R_{K_{j}}\\big)}{\\ln\\!\\big(\\sqrt{|d_{K_{j}}|}\\big)},\n$$\n（如果该极限存在）。确定 $L$ 的精确值。您的最终答案必须是一个精确的数字；不需要四舍五入。", "solution": "这个问题包含两部分。部分 (a) 要求计算一个虚二次数域 $K$ 的基本不变量。部分 (b) 要求计算一个与这类域的序列相关的特定极限值，这是布劳尔-西格尔定理的一个应用。\n\n(a) 设 $K$ 是一个虚二次数域。这意味着 $K = \\mathbb{Q}(\\sqrt{m})$，其中 $m < 0$ 是某个无平方因子的整数。扩张次数为 $[K:\\mathbb{Q}] = 2$。\n\n符号差 $(r_{1}(K), r_{2}(K))$ 由 $K$ 到 $\\mathbb{C}$ 中的实嵌入和复嵌入的数量决定。$\\sqrt{m}$ 在 $\\mathbb{Q}$ 上的最小多项式是 $x^2 - m = 0$，其根为 $\\pm\\sqrt{m} = \\pm i\\sqrt{|m|}$。由于 $m < 0$，两个根都是纯虚数。因此，没有实嵌入，即 $r_{1}(K) = 0$。有两个复嵌入，它们成共轭对：$\\sigma_1: \\sqrt{m} \\mapsto i\\sqrt{|m|}$ 和 $\\sigma_2 = \\overline{\\sigma_1}: \\sqrt{m} \\mapsto -i\\sqrt{|m|}$。共轭复嵌入的对数为 $r_{2}(K) = 1$。扩张次数为 $n = r_1(K) + 2r_2(K) = 0 + 2(1) = 2$，这是一致的。\n因此，对于任何虚二次数域 $K$，我们有 $r_{1}(K) = 0$ 和 $r_{2}(K) = 1$。\n\n调节子 $R_K$ 与整数环 $\\mathcal{O}_K$ 的单位群 $\\mathcal{O}_K^\\times$ 的结构有关。根据狄利克雷单位定理，$\\mathcal{O}_K^\\times$ 自由部分的秩为 $r = r_1(K) + r_2(K) - 1$。对于虚二次数域，这个秩为 $r = 0 + 1 - 1 = 0$。这意味着单位群是有限的，并且只包含 $K$ 中的单位根。调节子 $R_K$ 被定义为由一组基本单位的绝对值的对数构成的 $r \\times r$ 矩阵的行列式的绝对值。由于 $r=0$，这是一个 $0 \\times 0$ 矩阵。根据约定，$0 \\times 0$ 矩阵的行列式为 $1$。\n因此，对于任何虚二次数域 $K$，调节子为 $R_K = 1$。\n\n$w_K$ 是 $\\mathcal{O}_K$ 中单位根的个数。这些是 $\\mathcal{O}_K^\\times$ 挠子群的元素。对于一个一般数域，仅有的单位根是 $\\pm 1$，所以 $w_K = 2$。然而，某些虚二次数域包含额外的单位根。一个 $n$ 次单位根 $\\zeta_n$ 在 $\\mathbb{Q}$ 上的次数为 $\\phi(n)$，其中 $\\phi$ 是欧拉$\\phi$函数。为了使 $\\mathbb{Q}(\\zeta_n)$ 成为二次域 $K$ 的一个子域，我们必须有 $\\phi(n) \\le 2$。满足 $\\phi(n) \\le 2$ 的 $n$ 的值为 $n \\in \\{1, 2, 3, 4, 6\\}$。\n- $n=1, 2$：$\\mathbb{Q}(\\zeta_1) = \\mathbb{Q}(\\zeta_2) = \\mathbb{Q}$。它们给出单位根 $\\pm 1$。\n- $n=4$：$\\mathbb{Q}(\\zeta_4) = \\mathbb{Q}(i) = \\mathbb{Q}(\\sqrt{-1})$。判别式为 $d_K = -4$。对于这个域，单位根是 $\\{\\pm 1, \\pm i\\}$，所以 $w_K = 4$。\n- $n=3, 6$：$\\mathbb{Q}(\\zeta_3) = \\mathbb{Q}(\\zeta_6) = \\mathbb{Q}(\\sqrt{-3})$。判别式为 $d_K = -3$。对于这个域，单位根是六次单位根，即 $\\{\\pm 1, \\frac{\\pm 1 \\pm \\sqrt{-3}}{2}\\}$，所以 $w_K = 6$。\n对于所有其他虚二次数域 $K$，仅有的单位根是 $\\{\\pm 1\\}$。\n总之，对于 $w_K$，存在两种例外情况：\n- 如果 $K = \\mathbb{Q}(\\sqrt{-1})$，则 $w_K = 4$。\n- 如果 $K = \\mathbb{Q}(\\sqrt{-3})$，则 $w_K = 6$。\n- 对于所有其他虚二次数域 $K$，$w_K = 2$。\n\n(b) 我们被要求确定极限\n$$ L = \\lim_{j\\to\\infty}\\frac{\\ln(h_{K_j} R_{K_j})}{\\ln(\\sqrt{|d_{K_j}|})} $$\n的值，其中 $(K_j)_{j\\geq 1}$ 是一个虚二次数域序列，且 $|d_{K_j}|\\to \\infty$。\n\n从 (a) 部分我们知道，对于任何虚二次数域 $K_j$，调节子 $R_{K_j} = 1$。将此代入 $L$ 的表达式中，得到：\n$$ L = \\lim_{j\\to\\infty}\\frac{\\ln(h_{K_j} \\cdot 1)}{\\ln(\\sqrt{|d_{K_j}|})} = \\lim_{j\\to\\infty}\\frac{\\ln(h_{K_j})}{\\frac{1}{2}\\ln(|d_{K_j}|)} = 2 \\lim_{j\\to\\infty}\\frac{\\ln(h_{K_j})}{\\ln(|d_{K_j}|)} $$\n这个极限是数论中的一个著名结果，是布劳尔-西格尔定理的一个特例。我们可以使用解析类数公式推导其值。对于一个虚二次数域 $K$，该公式将其戴德金zeta函数 $\\zeta_K(s)$ 在 $s=1$ 处的留数与该域的不变量联系起来：\n$$ \\lim_{s\\to 1} (s-1)\\zeta_K(s) = \\frac{2^{r_1}(2\\pi)^{r_2}h_K R_K}{w_K \\sqrt{|d_K|}} $$\n对于 $K=K_j$，使用 $r_1=0$，$r_2=1$ 和 $R_K=1$，公式变为：\n$$ \\lim_{s\\to 1} (s-1)\\zeta_{K_j}(s) = \\frac{2\\pi h_{K_j}}{w_{K_j} \\sqrt{|d_{K_j}|}} $$\n戴德金zeta函数可分解为 $\\zeta_{K_j}(s) = \\zeta(s)L(s, \\chi_{K_j})$，其中 $\\zeta(s)$ 是黎曼zeta函数，$L(s, \\chi_{K_j})$ 是与域 $K_j$ 对应的二次特征 $\\chi_{K_j}$ 相关联的狄利克雷L-函数。由于 $\\lim_{s\\to 1} (s-1)\\zeta(s) = 1$，我们有：\n$$ \\lim_{s\\to 1} (s-1)\\zeta_{K_j}(s) = L(1, \\chi_{K_j}) $$\n令留数的两个表达式相等，我们得到：\n$$ L(1, \\chi_{K_j}) = \\frac{2\\pi h_{K_j}}{w_{K_j} \\sqrt{|d_{K_j}|}} $$\n我们可以解出类数 $h_{K_j}$：\n$$ h_{K_j} = \\frac{w_{K_j} \\sqrt{|d_{K_j}|}}{2\\pi} L(1, \\chi_{K_j}) $$\n我们现在对这个表达式取自然对数。条件 $|d_{K_j}| \\to \\infty$ 确保对于所有足够大的 $j$，$K_j$ 既不是 $\\mathbb{Q}(\\sqrt{-1})$ (其中 $|d_K|=4$) 也不是 $\\mathbb{Q}(\\sqrt{-3})$ (其中 $|d_K|=3$)。因此，对于大的 $j$，我们有 $w_{K_j} = 2$。\n$$ h_{K_j} = \\frac{2 \\sqrt{|d_{K_j}|}}{2\\pi} L(1, \\chi_{K_j}) = \\frac{\\sqrt{|d_{K_j}|}}{\\pi} L(1, \\chi_{K_j}) $$\n取对数：\n$$ \\ln(h_{K_j}) = \\ln\\left(\\frac{|d_{K_j}|^{1/2}}{\\pi} L(1, \\chi_{K_j})\\right) = \\frac{1}{2}\\ln(|d_{K_j}|) - \\ln(\\pi) + \\ln(L(1, \\chi_{K_j})) $$\n现在我们将此代入我们关于 $L$ 的表达式：\n$$ L = \\lim_{j\\to\\infty}\\frac{2 \\left( \\frac{1}{2}\\ln(|d_{K_j}|) - \\ln(\\pi) + \\ln(L(1, \\chi_{K_j})) \\right)}{\\ln(|d_{K_j}|)} $$\n$$ L = \\lim_{j\\to\\infty}\\left( 1 - \\frac{2\\ln(\\pi)}{\\ln(|d_{K_j}|)} + \\frac{2\\ln(L(1, \\chi_{K_j}))}{\\ln(|d_{K_j}|)} \\right) $$\n当 $j \\to \\infty$ 时，我们有 $|d_{K_j}| \\to \\infty$，因此 $\\ln(|d_{K_j}|) \\to \\infty$。第二项趋于零：\n$$ \\lim_{j\\to\\infty} \\frac{-2\\ln(\\pi)}{\\ln(|d_{K_j}|)} = 0 $$\n对于第三项，我们使用关于狄利克雷L-函数的西格尔定理。该定理指出，对于任意 $\\epsilon > 0$，存在常数 $C_1(\\epsilon) > 0$ 和 $C_2 > 0$，使得对于任何判别式为 $d$ 的本原二次特征 $\\chi_d$：\n$$ C_1(\\epsilon)|d|^{-\\epsilon} < L(1, \\chi_d) < C_2 \\ln|d| $$\n取对数，我们得到：\n$$ \\ln(C_1(\\epsilon)) - \\epsilon\\ln|d| < \\ln(L(1, \\chi_d)) < \\ln(C_2) + \\ln(\\ln|d|) $$\n除以 $\\ln|d|$：\n$$ \\frac{\\ln(C_1(\\epsilon))}{\\ln|d|} - \\epsilon < \\frac{\\ln(L(1, \\chi_d))}{\\ln|d|} < \\frac{\\ln(C_2)}{\\ln|d|} + \\frac{\\ln(\\ln|d|)}{\\ln|d|} $$\n当 $|d| \\to \\infty$ 时，项 $\\frac{\\ln(C_1(\\epsilon))}{\\ln|d|}$、$\\frac{\\ln(C_2)}{\\ln|d|}$ 和 $\\frac{\\ln(\\ln|d|)}{\\ln|d|}$ 都趋近于 $0$。这剩下：\n$$ -\\epsilon \\le \\liminf_{|d|\\to\\infty} \\frac{\\ln(L(1, \\chi_d))}{\\ln|d|} \\le \\limsup_{|d|\\to\\infty} \\frac{\\ln(L(1, \\chi_d))}{\\ln|d|} \\le 0 $$\n由于这对任意小的 $\\epsilon > 0$ 都必须成立，我们得出结论，极限存在且等于 $0$：\n$$ \\lim_{|d|\\to\\infty} \\frac{\\ln(L(1, \\chi_d))}{\\ln|d|} = 0 $$\n将此应用于我们的序列 $(K_j)$：\n$$ \\lim_{j\\to\\infty} \\frac{2\\ln(L(1, \\chi_{K_j}))}{\\ln(|d_{K_j}|)} = 2 \\cdot 0 = 0 $$\n将各单项的极限代回 $L$ 的表达式中：\n$$ L = 1 - 0 + 0 = 1 $$\n这个结果就是布劳尔-西格尔定理对于虚二次数域族的陈述。", "answer": "$$ \\boxed{1} $$", "id": "3025206"}, {"introduction": "理论的最终检验离不开经验数据的支持。在前一个实践中，我们探讨了调节子平凡的特殊情况，现在我们转向更普遍的情形：实二次域，其调节子 $R_K$ 不再是 $1$。[@problem_id:3025175] 是一个计算性实践，要求我们通过编程实现寻找基本单位和估算类数的算法，从而对 $h_K R_K$ 这一完整乘积的增长进行数值检验。这个练习将抽象的定理与具体的计算和数据联系起来，展现了现代数论研究中理论与计算相结合的范式。", "problem": "您的任务是通过编程来检验布劳尔-西格尔定理在实二次域这种特殊情况下的表现。对于一个实二次域 $K = \\mathbb{Q}(\\sqrt{d})$（其中 $d \\geq 2$ 为无平方因子数），其域判别式 $\\Delta_K$ 定义如下：\n- 如果 $d \\equiv 1 \\pmod{4}$，则 $\\Delta_K = d$；\n- 如果 $d \\equiv 2,3 \\pmod{4}$，则 $\\Delta_K = 4d$。\n如果一个正整数 $\\Delta$ 对于某个无平方因子数 $d$ 等于 $\\Delta_K$，则称其为基本判别式。对于这样的域 $K$，其调节子（regulator）$R_K$ 由狄利克雷单位定理定义为基本单位 $\\varepsilon_K > 1$ 的自然对数，该基本单位生成了整数环 $\\mathcal{O}_K$ 的单位群的自由部分，即 $R_K = \\log \\varepsilon_K$。对于实二次域，基本单位可以通过 $\\sqrt{d}$ 的连分数展开和佩尔型方程 $x^2 - d y^2 = \\pm 1$ 来计算。\n\n令 $\\zeta_K(s)$ 表示 $K$ 的戴德金zeta函数，并令 $h_K$ 表示其（宽）类数。经典的类数公式给出\n$$\n\\lim_{s \\to 1} (s-1)\\zeta_K(s) = \\frac{2^{r_1}(2\\pi)^{r_2} h_K R_K}{w_K \\sqrt{|\\Delta_K|}},\n$$\n其中 $r_1$ 是实嵌入的个数，$r_2$ 是复嵌入对的个数，$w_K$ 是 $K$ 中单位根的个数。对于实二次域，$r_1 = 2$，$r_2 = 0$，$w_K = 2$。使用因子分解 $\\zeta_K(s) = \\zeta(s) L(s, \\chi_{\\Delta_K})$，其中包含与 $\\Delta_K$ 相关的狄利克雷$L$-函数和二次狄利克雷特征 $\\chi_{\\Delta_K}(\\cdot)$，可以得到恒等式\n$$\nL(1, \\chi_{\\Delta_K}) = \\frac{2 h_K R_K}{\\sqrt{\\Delta_K}}.\n$$\n布劳尔-西格尔定理预测，对于一列次数固定且判别式趋于无穷的数域，我们有\n$$\n\\frac{\\log(h_K R_K)}{\\log(\\sqrt{|\\Delta_K|})} \\to 1 \\quad \\text{as } |\\Delta_K| \\to \\infty.\n$$\n\n您的程序必须：\n- 枚举所有实二次域 $K = \\mathbb{Q}(\\sqrt{d})$（其中 $d \\geq 2$ 为无平方因子数），使其判别式 $\\Delta_K$ 为受给定阈值 $B$ 限制的正基本判别式。\n- 对于每个这样的域，通过 $\\sqrt{d}$ 的连分数找到单位群的最小生成元，从而数值计算调节子 $R_K$。即，找到最小的 $\\varepsilon_K > 1$，使得 $x^2 - d y^2 = \\pm 1$ 且 $\\varepsilon_K = x + y\\sqrt{d}$，然后取 $R_K = \\log \\varepsilon_K$。\n- 使用恒等式\n$$\nL(1, \\chi_{\\Delta}) = \\sum_{n=1}^{\\infty} \\frac{\\chi_{\\Delta}(n)}{n},\n$$\n并重组为模 $q = |\\Delta|$ 的算术级数来计算 $L(1, \\chi_{\\Delta_K})$ 的近似值。对于截断水平 $K \\in \\mathbb{N}$，这会产生近似式\n$$\nL(1, \\chi_{\\Delta}) \\approx \\frac{1}{q} \\sum_{r=1}^{q} \\chi_{\\Delta}(r)\\left(\\psi\\!\\left(K + \\frac{r}{q}\\right) - \\psi\\!\\left(\\frac{r}{q}\\right)\\right),\n$$\n其中 $\\psi$ 是digamma函数。使用克罗内克符号来实现 $\\chi_{\\Delta}(n)$，并确保当 $\\gcd(n, \\Delta) \\neq 1$ 时 $\\chi_{\\Delta}(n) = 0$。\n- 使用计算出的 $R_K$ 和近似的 $L(1, \\chi_{\\Delta_K})$，通过\n$$\nh_K \\approx \\frac{\\sqrt{\\Delta_K}}{2 R_K} \\, L(1, \\chi_{\\Delta_K}),\n$$\n计算 $h_K$ 的近似值，然后构建布劳尔-西格尔比率\n$$\n\\operatorname{BS}(K) = \\frac{\\log\\!\\big(h_K R_K\\big)}{\\log\\!\\big(\\sqrt{\\Delta_K}\\big)}.\n$$\n\n测试套件：\n- 使用以下判别式界限 $B$：\n    1. $B = 50$,\n    2. $B = 200$,\n    3. $B = 800$.\n- 对于每个界限 $B$，计算集合 $\\{K : \\Delta_K \\leq B\\}$ 中所有域的比率 $\\operatorname{BS}(K)$ 列表，然后为该界限返回一个包含以下三个值的三元组：\n    - 该集合上所有比率的算术平均值，\n    - 该集合上的最小比率，\n    - 该集合上的最大比率。\n- 如果某个界限没有产生任何域（对于给定的数值，这种情况不应发生），则将该三元组定义为 $(\\text{NaN}, \\text{NaN}, \\text{NaN})$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按 $B=50$, $B=200$, $B=800$ 顺序排列的三个三元组的结果，以逗号分隔，并用方括号括起来。例如：“[[mean50,min50,max50],[mean200,min200,max200],[mean800,min800,max800]]”。\n- 所有数值输出必须是纯十进制浮点数。不涉及物理单位或角度。不需要百分比。不强制要求四舍五入；使用计算产生的全精度 Python 浮点数。\n\n您的实现必须是一个完整的、可按规定运行的程序，不得读取任何外部输入，也不得访问网络。", "solution": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom scipy.special import digamma as psi\n\ndef is_squarefree(n):\n    \"\"\"\n    Checks if a positive integer n is square-free.\n    \"\"\"\n    if n % 4 == 0:\n        return False\n    i = 3\n    # Only need to check for odd prime factors up to sqrt(n)\n    limit = int(math.sqrt(n))\n    while i = limit:\n        if n % (i * i) == 0:\n            return False\n        i += 2\n    \n    # Handle the case where n is even but not divisible by 4.\n    # The initial check n % 4 == 0 handles all cases where n is a multiple of 4.\n    # If n is even, n = 2k. If k is even, n is a multiple of 4.\n    # So we only need to check if k is square-free.\n    # This logic is simplified by handling d=2,3 mod 4 cases for discriminant later.\n    # The check is sufficient for its purpose in the main loop.\n    return True\n\ndef compute_fundamental_solution(d):\n    \"\"\"\n    Computes the fundamental solution (x, y) to Pell's equation x^2 - d*y^2 = +/-1\n    using the continued fraction method for sqrt(d).\n    d must be a non-square positive integer.\n    \"\"\"\n    if int(math.sqrt(d))**2 == d:\n      raise ValueError(\"d must be a non-square integer\")\n    \n    m = 0\n    q = 1\n    a0 = int(math.sqrt(d))\n    a = a0\n\n    # Initialize convergents p_n/q_n.\n    # p_{n-2}=0, p_{n-1}=1\n    # q_{n-2}=1, q_{n-1}=0\n    p_prev, p_curr = 0, 1\n    q_prev, q_curr = 1, 0\n\n    # Calculate p_0, q_0\n    p_curr, p_prev = a * p_curr + p_prev, p_curr\n    q_curr, q_prev = a * q_curr + q_prev, q_curr\n\n    while p_curr**2 - d * q_curr**2 != 1 and p_curr**2 - d * q_curr**2 != -1:\n        m_next = q * a - m\n        q_next = (d - m_next**2) // q\n        a_next = (a0 + m_next) // q_next\n\n        m, q, a = m_next, q_next, a_next\n        \n        # Calculate next convergent\n        p_curr, p_prev = a * p_curr + p_prev, p_curr\n        q_curr, q_prev = a * q_curr + q_prev, q_curr\n\n    return p_curr, q_curr\n\ndef kronecker_symbol(a, n):\n    \"\"\"\n    Computes the Kronecker symbol (a/n).\n    Assumes a is a positive fundamental discriminant (a > 0).\n    \"\"\"\n    if n == 0:\n        return 1 if a == 1 else 0\n    if n == 1:\n        return 1\n    if n  0:\n        # Since a > 0, (a/-1) = 1.\n        return kronecker_symbol(a, -n)\n\n    if math.gcd(a, n) > 1:\n        return 0\n\n    # Factor out powers of 2 from 'n'\n    t = 1\n    while n % 2 == 0:\n        n //= 2\n        a_mod_8 = a % 8\n        if a_mod_8 == 3 or a_mod_8 == 5:\n            t = -t\n    \n    if n == 1:\n        return t\n\n    # Now n is odd > 1. Quadratic Reciprocity.\n    # (a/n) = (-1)^((a-1)/2 * (n-1)/2) * (n/a)\n    if a % 4 == 3 and n % 4 == 3:\n        t = -t\n    \n    # Recurse with swapped arguments, reducing the larger one.\n    return t * kronecker_symbol(n, a % n)\n\ndef compute_L_1_chi(Delta, K_trunc):\n    \"\"\"\n    Approximates L(1, chi_Delta) using the digamma function formula.\n    \"\"\"\n    q = Delta\n    total = 0.0\n    for r in range(1, q):\n        chi_val = kronecker_symbol(Delta, r)\n        if chi_val == 0:\n            continue\n        # The core of the approximation formula\n        term = chi_val * (psi(K_trunc + r / q) - psi(r / q))\n        total += term\n    return total / q\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [50, 200, 800]\n    \n    # Define the truncation parameter for the L-function approximation.\n    K_TRUNC = 1000\n\n    results = []\n    \n    for B in test_cases:\n        bs_ratios = []\n        # Per problem, d is a squarefree integer >= 2.\n        # Max d to check: if d=1 mod 4, Delta=d=B. if d=2,3 mod 4, Delta=4d=B -> d=B/4.\n        # So we can safely iterate d up to B.\n        for d in range(2, B + 1):\n            if not is_squarefree(d):\n                continue\n            \n            # Calculate the discriminant Delta_K\n            if d % 4 == 1:\n                Delta = d\n            else:  # d % 4 == 2 or d % 4 == 3\n                Delta = 4 * d\n            \n            if Delta > B:\n                continue\n            \n            # We have a valid field. Proceed with calculations.\n            \n            # 1. Compute Regulator R_K\n            x, y = compute_fundamental_solution(d)\n            epsilon_K = x + y * math.sqrt(d)\n            R_K = math.log(epsilon_K)\n            \n            # 2. Compute L(1, chi_Delta)\n            L1_chi = compute_L_1_chi(Delta, K_TRUNC)\n            \n            # 3. Approximate class number h_K\n            h_K_approx = (math.sqrt(Delta) / (2 * R_K)) * L1_chi\n            \n            # 4. Compute Brauer-Siegel ratio\n            hR_product = h_K_approx * R_K\n            \n            # log argument must be positive. h_K, R_K, L(1,chi) should be positive.\n            if hR_product = 0:\n                continue\n\n            log_hR = math.log(hR_product)\n            log_sqrt_Delta = 0.5 * math.log(Delta)\n            \n            bs_ratio = log_hR / log_sqrt_Delta\n            bs_ratios.append(bs_ratio)\n\n        if not bs_ratios:\n            results.append([np.nan, np.nan, np.nan])\n        else:\n            mean_val = np.mean(bs_ratios)\n            min_val = np.min(bs_ratios)\n            max_val = np.max(bs_ratios)\n            results.append([mean_val, min_val, max_val])\n\n    # Final print statement in the exact required format.\n    output_str = \"[\" + \",\".join([f\"[{r[0]},{r[1]},{r[2]}]\" for r in results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "answer": "[[0.9634934751419747,0.7282862095982855,1.2185563914445582],[0.9926941193165249,0.7282862095982855,1.385458925565509],[1.0069352726466982,0.7282862095982855,1.458993855598177]]", "id": "3025175"}]}