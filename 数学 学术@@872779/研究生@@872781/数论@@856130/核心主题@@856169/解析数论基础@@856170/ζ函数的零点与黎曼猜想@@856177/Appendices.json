{"hands_on_practices": [{"introduction": "在深入研究黎曼猜想的核心——非平凡零点之前，理解黎曼 $\\zeta$ 函数的全局解析性质至关重要。本练习将引导你通过解析延拓，来确定 $\\zeta(s)$ 在负整数点上的取值，这些值与所谓的“平凡零点”密切相关。完成这个推导，你将掌握处理 $\\zeta(s)$ 解析性质的一项基本功，为后续更复杂的分析奠定基础。[@problem_id:3031541]", "problem": "设 $\\,\\zeta(s)\\,$ 表示 Riemann zeta 函数，其初始定义为在 $\\operatorname{Re}(s)>1$ 上的 Dirichlet 级数 $\\,\\zeta(s)=\\sum_{n=1}^{\\infty}n^{-s}\\,$；设 $\\,\\zeta(s,a)\\,$ 表示 Hurwitz zeta 函数，其初始定义为在 $\\operatorname{Re}(s)>1$ 和 $a\\in(0,1]$ 上的 $\\,\\zeta(s,a)=\\sum_{n=0}^{\\infty}(n+a)^{-s}\\,$。Bernoulli 多项式 $\\,B_{n}(a)\\,$ 和 Bernoulli 数 $\\,B_{n}=B_{n}(1)\\,$ 由生成函数定义：\n$$\n\\frac{t\\,\\exp(a t)}{\\exp(t)-1}=\\sum_{n=0}^{\\infty}B_{n}(a)\\,\\frac{t^{n}}{n!},\\qquad |t|<2\\pi.\n$$\n从这些基本定义和经过充分验证的积分表示出发：\n$$\n\\Gamma(s)\\,\\zeta(s,a)=\\int_{0}^{\\infty}\\frac{x^{\\,s-1}\\,\\exp(-a x)}{1-\\exp(-x)}\\,\\mathrm{d}x\\qquad\\text{对于 }\\operatorname{Re}(s)>1,\n$$\n推导 $\\,\\zeta(s,a)\\,$ 到负整数的解析延拓，并证明对于每个整数 $m\\ge 1$，有\n$$\n\\zeta(-m)=-\\frac{B_{m+1}}{m+1}.\n$$\n然后显式计算 $\\,\\zeta(-1)\\,$ 和 $\\,\\zeta(-3)\\,$。最终答案应为精确值，无需四舍五入。", "solution": "本题要求从给定的 Hurwitz zeta 函数 $\\zeta(s,a)$ 的积分表示出发，推导 Riemann zeta 函数 $\\zeta(s)$ 在负整数处的值。推导过程包括：为 $\\zeta(s,a)$ 寻找一个解析延拓，然后特殊化到 $\\zeta(s) = \\zeta(s,1)$，最后使用 Bernoulli 数计算所需的值。\n\n出发点是 Hurwitz zeta 函数 $\\zeta(s,a)$ 的积分表示，它在 $\\operatorname{Re}(s)>1$ 和 $a \\in (0,1]$ 时成立：\n$$ \\Gamma(s)\\,\\zeta(s,a)=\\int_{0}^{\\infty}\\frac{x^{\\,s-1}\\,\\exp(-a x)}{1-\\exp(-x)}\\,\\mathrm{d}x $$\n为了获得解析延拓，我们分析被积函数。项 $\\frac{\\exp(-ax)}{1-\\exp(-x)}$ 可以与 Bernoulli 多项式 $B_k(a)$ 的生成函数关联起来，该生成函数由下式给出：\n$$ \\frac{t\\,\\exp(a t)}{\\exp(t)-1}=\\sum_{k=0}^{\\infty}B_{k}(a)\\,\\frac{t^{k}}{k!} $$\n我们来处理积分中的这一项。令 $t = -x$，则 $x=-t$。表达式 $\\frac{\\exp(-ax)}{1-\\exp(-x)}$ 可以写成：\n$$ \\frac{\\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\frac{x \\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\frac{-t \\exp(at)}{1-\\exp(t)} = \\frac{1}{x} \\frac{t \\exp(at)}{\\exp(t)-1} $$\n代入生成函数：\n$$ \\frac{\\exp(-ax)}{1-\\exp(-x)} = \\frac{1}{x} \\sum_{k=0}^{\\infty}B_{k}(a)\\,\\frac{(-x)^{k}}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k B_k(a)}{k!} x^{k-1} $$\n该展开式在 $|x|<2\\pi$ 时有效。我们将其代入积分表示中：\n$$ \\Gamma(s)\\zeta(s,a) = \\int_0^\\infty x^{s-1} \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k-1} \\right) \\mathrm{d}x = \\int_0^\\infty \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x $$\n为了处理积分的发散性和级数的收敛域问题，我们将积分在一个收敛半径内的点（例如 $x=1$）处拆分：\n$$ \\Gamma(s)\\zeta(s,a) = \\int_0^1 \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x + \\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x $$\n第二个积分 $\\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x$ 对所有 $s \\in \\mathbb{C}$ 都收敛，因为当 $x \\to \\infty$ 时，被积函数呈指数衰减。因此，该积分定义了一个关于 $s$ 的整函数。\n\n对于第一个积分，当 $\\operatorname{Re}(s)>1$ 时，我们可以交换求和与积分的顺序：\n$$ \\int_0^1 \\left( \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} x^{k+s-2} \\right) \\mathrm{d}x = \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!} \\int_0^1 x^{k+s-2} \\mathrm{d}x $$\n内部积分计算结果为：\n$$ \\int_0^1 x^{k+s-2} \\mathrm{d}x = \\left[\\frac{x^{k+s-1}}{k+s-1}\\right]_0^1 = \\frac{1}{k+s-1} $$\n这在 $\\operatorname{Re}(k+s-2) > -1$，即 $\\operatorname{Re}(s) > 1-k$ 时有效。由于我们假设 $\\operatorname{Re}(s)>1$，这对所有 $k \\ge 0$ 都成立。\n因此，对于 $\\operatorname{Re}(s)>1$，我们有：\n$$ \\Gamma(s)\\zeta(s,a) = \\sum_{k=0}^\\infty \\frac{(-1)^k B_k(a)}{k!(k+s-1)} + \\int_1^\\infty \\frac{x^{s-1} \\exp(-ax)}{1-e^{-x}} \\mathrm{d}x $$\n右侧提供了 $\\Gamma(s)\\zeta(s,a)$ 到整个复平面的解析延拓，其在 $s=1-k$（其中 $k=0, 1, 2, \\ldots$）处有简单极点，这些极点源于级数中的项。我们称此函数为 $\\Phi(s,a)$。因此，$\\zeta(s,a) = \\Phi(s,a)/\\Gamma(s)$。\n\n我们想要求出 $\\zeta(s,a)$ 在负整数处的值，比如 $s = -m$，其中 $m \\in \\mathbb{Z}_{\\ge 1}$。我们来寻找一个对于 $k \\in \\mathbb{Z}_{\\ge 1}$ 的 $\\zeta(1-k, a)$ 的通用公式。\n我们计算 $\\zeta(1-k, a) = \\lim_{s \\to 1-k} \\frac{\\Phi(s,a)}{\\Gamma(s)}$。这是一个 $\\infty/\\infty$ 型的不定式，因为 $\\Phi(s,a)$（由于级数的第 $k$ 项）和 $\\Gamma(s)$（由于 $1-k \\le 0$）在 $s=1-k$ 处都有极点。\n\n在 $s = 1-k$ 附近，$\\Phi(s,a)$ 中的主导项是带极点的那一项：\n$$ \\Phi(s,a) \\sim \\frac{(-1)^k B_k(a)}{k!(k+s-1)} = \\frac{(-1)^k B_k(a)}{k!(s - (1-k))} $$\n$\\Phi(s,a)$ 在 $s=1-k$ 处的留数是 $\\operatorname{Res}_{s=1-k} \\Phi(s,a) = \\frac{(-1)^k B_k(a)}{k!}$。\nGamma 函数 $\\Gamma(s)$ 在 $s = -(k-1) = 1-k$ 处有一个简单极点。其留数为：\n$$ \\operatorname{Res}_{s=1-k} \\Gamma(s) = \\frac{(-1)^{k-1}}{(k-1)!} $$\n所以在 $s=1-k$ 附近，$\\Gamma(s)$ 的行为类似于：\n$$ \\Gamma(s) \\sim \\frac{(-1)^{k-1}}{(k-1)!(s - (1-k))} $$\n现在，我们可以计算 $\\zeta(1-k, a)$ 的极限：\n$$ \\zeta(1-k, a) = \\lim_{s \\to 1-k} \\frac{\\Phi(s,a)}{\\Gamma(s)} = \\frac{ \\frac{(-1)^k B_k(a)}{k!(s - (1-k))} }{ \\frac{(-1)^{k-1}}{(k-1)!(s - (1-k))} } = \\frac{(-1)^k B_k(a)}{k!} \\cdot \\frac{(k-1)!}{(-1)^{k-1}} $$\n$$ \\zeta(1-k, a) = -\\frac{B_k(a)}{k} \\quad \\text{对于整数 } k \\ge 1. $$\n题目要求计算整数 $m \\ge 1$ 时的 $\\zeta(-m)$。我们令 $-m = 1-k$，这意味着 $k = m+1$。由于 $m \\ge 1$，所以 $k \\ge 2$，因此该公式适用。\n$$ \\zeta(-m, a) = -\\frac{B_{m+1}(a)}{m+1} $$\nRiemann zeta 函数 $\\zeta(s)$ 与 Hurwitz zeta 函数 $\\zeta(s,a)$ 的关系为，在 $\\operatorname{Re}(s)>1$ 时 $\\zeta(s) = \\zeta(s,1)$。根据解析延拓的唯一性，此关系在两个函数都有定义的所有 $s$ 上都成立。我们令 $a=1$：\n$$ \\zeta(-m) = \\zeta(-m, 1) = -\\frac{B_{m+1}(1)}{m+1} $$\n题目将 Bernoulli 数定义为 $B_n = B_n(1)$。因此，对于任意整数 $m \\ge 1$：\n$$ \\zeta(-m) = -\\frac{B_{m+1}}{m+1} $$\n这就完成了所需公式的推导。\n\n现在，我们必须计算 $\\zeta(-1)$ 和 $\\zeta(-3)$。这需要 Bernoulli 数 $B_2$ 和 $B_4$。我们使用 $B_n = B_n(1)$ 的生成函数：\n$$ \\frac{t\\,\\exp(t)}{\\exp(t)-1}=\\sum_{n=0}^{\\infty}B_{n}\\,\\frac{t^{n}}{n!} $$\n我们可以通过将左侧在 $t=0$ 附近展开为 Taylor 级数来找到前几项：\n$$ \\frac{t\\,\\exp(t)}{\\exp(t)-1} = t + \\frac{t}{\\exp(t)-1} $$\nBernoulli 数（我们称之为 $b_k$）的标准生成函数是 $\\frac{t}{\\exp(t)-1} = \\sum_{k=0}^{\\infty} b_k \\frac{t^k}{k!}$，其中 $b_0=1, b_1=-1/2, b_2=1/6, b_3=0, b_4=-1/30$ 等。\n$$ \\sum_{n=0}^{\\infty}B_{n}\\,\\frac{t^{n}}{n!} = t + \\left( b_0 + b_1 t + b_2 \\frac{t^2}{2!} + b_3 \\frac{t^3}{3!} + b_4 \\frac{t^4}{4!} + \\dots \\right) $$\n$$ B_0 + B_1 t + B_2 \\frac{t^2}{2} + B_3 \\frac{t^3}{6} + B_4 \\frac{t^4}{24} + \\dots = b_0 + (1+b_1)t + b_2 \\frac{t^2}{2} + b_3 \\frac{t^3}{6} + b_4 \\frac{t^4}{24} + \\dots $$\n通过比较系数，我们发现：\n$B_0 = b_0 = 1$。\n$B_1 = 1+b_1 = 1 - 1/2 = 1/2$。\n$B_2 = b_2 = 1/6$。\n$B_3 = b_3 = 0$。\n$B_4 = b_4 = -1/30$。\n\n现在我们可以计算 $\\zeta(s)$ 的具体值了。\n对于 $m=1$：\n$$ \\zeta(-1) = -\\frac{B_{1+1}}{1+1} = -\\frac{B_2}{2} = -\\frac{1/6}{2} = -\\frac{1}{12} $$\n对于 $m=3$：\n$$ \\zeta(-3) = -\\frac{B_{3+1}}{3+1} = -\\frac{B_4}{4} = -\\frac{-1/30}{4} = \\frac{1}{120} $$\n计算出的值为 $\\zeta(-1) = -1/12$ 和 $\\zeta(-3) = 1/120$。", "answer": "$$\n\\boxed{\\begin{pmatrix} -\\frac{1}{12} & \\frac{1}{120} \\end{pmatrix}}\n$$", "id": "3031541"}, {"introduction": "在建立了 $\\zeta$ 函数的全局视图后，我们的焦点转向了临界带，尤其是黎曼猜想所预言的临界线。本计算练习将向你介绍用于在临界线上数值定位零点的工具，例如哈代 $Z$ 函数和格兰姆点（Gram points）。通过编程寻找格兰姆法则的失效之处，你将亲身体验到这些零点分布的复杂性与出人意料的特性。[@problem_id:3031532]", "problem": "令 $\\zeta(s)$ 表示 Riemann ζ函数，对于 $\\Re(s) > 1$ 的情况，它由级数 $\\zeta(s) = \\sum_{n=1}^{\\infty} n^{-s}$ 定义，并通过解析延拓扩展到整个复平面，但在 $s=1$ 处有一个简单极点。定义 Hardy Z函数为 $Z(t) = e^{i \\theta(t)} \\zeta\\!\\left(\\tfrac{1}{2} + i t\\right)$，其中 $\\theta(t)$ 是 Riemann–Siegel θ函数，由下式给出\n$$\n\\theta(t) = \\arg \\Gamma\\!\\left(\\tfrac{1}{4} + \\tfrac{i t}{2}\\right) - \\tfrac{t}{2} \\log \\pi,\n$$\n其中辐角的分支是为 $t \\ge 0$ 连续选取的。Gram 点 $\\{g_n\\}_{n \\ge 0}$ 由 $\\theta(g_n) = n \\pi$（对于整数 $n \\ge 0$）隐式定义。Gram 定律启发性地断言，$Z(g_n)$ 的值在连续的 Gram 点上应该符号交替。当两个连续值 $Z(g_n)$ 和 $Z(g_{n+1})$ 具有相同的符号（或其中一个为零）时，就观察到 Gram 定律的失效，即符号交替性质被违反。\n\n从以下基本依据出发：\n- Riemann ζ函数的函数方程，等价地通过 Hardy Z函数 $Z(t)$ 对于实数 $t$ 是实值函数来表达。\n- 从用于伽马函数的 Stirling 近似推导出的、适用于大 $t$ 的 Riemann–Siegel θ函数渐近式：\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5},\n$$\n其导数为\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}.\n$$\n- $Z(t)$ 的 Riemann–Siegel 近似函数方程，它给出了截断主和\n$$\nZ(t) \\approx 2 \\sum_{n=1}^{N} n^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log n\\big), \\quad \\text{其中 } N = \\left\\lfloor \\sqrt{\\tfrac{t}{2\\pi}} \\right\\rfloor,\n$$\n对于中等到大的 $t$ 值，被忽略的余项是低阶的。\n\n您的任务是构建一个程序，通过在选定的索引范围内计算连续的 Gram 点 $g_n$，利用截断的 Riemann–Siegel 主和评估 $Z(g_n)$，并检查 $Z(g_n)$ 的符号是否交替，从而展示一个 Gram 定律失效的具体实例。使用上述渐近展开来计算 $\\theta(t)$ 和 $\\theta'(t)$，并使用稳定的求根方法（例如 Newton 法，并在需要时稳健地回退到二分法）数值求解方程 $\\theta(t) = n \\pi$ 以得到 $t$。然后评估 $Z(t)$ 的截断和并确定其符号。将 $Z(t)$ 在数值上与零无法区分的值（在一个小的绝对容差范围内）视为破坏了交替性。\n\n设计程序以处理以下索引范围 $(n_{\\text{start}}, n_{\\text{end}})$ 的测试套件：\n- 情况1（理想路径）：$(10, 30)$。\n- 情况2（目标失效搜索）：$(120, 140)$。\n- 情况3（更大索引窗口）：$(500, 520)$。\n\n对于每种情况，从 $n_{\\text{start}}$ 到 $n_{\\text{end}}-1$ 扫描 $n$，计算 $g_n$ 和 $g_{n+1}$，并确定区间内使得 $Z(g_n)$ 和 $Z(g_{n+1})$ 符号不交替的最小整数 $n$。如果整个区间内符号交替性都成立，则该情况返回 $-1$。因此，这三种情况所需的输出都是整数。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表（例如，“[result1,result2,result3]”）。不需要物理单位或角度单位。您实现的数值算法必须在科学上是合理的，与所述的基本公式一致，并且您的数值容差的选择必须合理，以反映所涉及的近似。", "solution": "所提出的问题是数论中一个定义明确的计算练习，要求对 Riemann ζ函数的 Gram 定律进行数值研究。该问题提供了进行计算所需的所有数学定义和近似公式。它有科学依据，内部一致，并且不需要超出所提供信息的任何额外信息。因此，该问题被认为是有效的，并将提出一个解决方案。\n\n任务的核心是在指定的范围 $(n_{\\text{start}}, n_{\\text{end}})$ 内，找到使 Gram 定律失效的最小整数索引 $n$。Gram 定律启发性地预测 Hardy Z函数 $Z(t)$ 的符号在连续的 Gram 点 $g_n$ 和 $g_{n+1}$ 处交替。如果 $Z(g_n)$ 和 $Z(g_{n+1})$ 具有相同的符号，或者其中一个为零，则发生失效。这等效于测试条件 $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$。\n\n解决方案通过一系列有条理的步骤构建：\n$1$. 实现所提供的 Riemann-Siegel θ函数 $\\theta(t)$ 及其导数 $\\theta'(t)$ 的渐近公式。\n$2$. 开发一个数值程序，通过求解方程 $\\theta(g_n) = n\\pi$ 来找到 Gram 点 $g_n$。\n$3$. 实现所提供的截断 Riemann-Siegel 主和来近似 Hardy Z函数 $Z(t)$。\n$4$. 系统地扫描给定的索引范围，以检测首次出现的符号交替失效。\n\n**1. 渐近公式的实现**\n\n问题提供了 Riemann-Siegel θ函数 $\\theta(t)$ 及其导数 $\\theta'(t)$ 的特定渐近展开式。这些函数是计算的基础。\n\n- 函数 $\\theta(t)$ 使用以下展开式实现：\n$$\n\\theta(t) \\approx \\tfrac{t}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{t}{2} - \\tfrac{\\pi}{8} + \\tfrac{1}{48 t} + \\tfrac{7}{5760 t^3} + \\tfrac{31}{80640 t^5}\n$$\n这个近似对于大的 $t$ 值是有效的。\n\n- 求根算法所需的导数 $\\theta'(t)$ 使用其对应的展开式实现：\n$$\n\\theta'(t) \\approx \\tfrac{1}{2} \\log\\!\\left(\\tfrac{t}{2\\pi}\\right) - \\tfrac{1}{48 t^2} - \\tfrac{7}{1920 t^4} - \\tfrac{31}{16128 t^6}\n$$\n\n**2. Gram 点的计算**\n\nGram 点 $\\{g_n\\}$ 被定义为方程 $\\theta(t) = n\\pi$（对于非负整数 $n$）的解。这是一个关于函数 $f(t) = \\theta(t) - n\\pi$ 的求根问题。鉴于其解析导数 $f'(t) = \\theta'(t)$ 可用，按照建议，Newton 法是一个高效且合适的选择。其迭代更新规则是：\n$$\nt_{k+1} = t_k - \\frac{f(t_k)}{f'(t_k)} = t_k - \\frac{\\theta(t_k) - n\\pi}{\\theta'(t_k)}\n$$\n为了确保收敛，需要一个好的 $g_n$ 初始猜测值 $t_0$。通过反演 $\\theta(t)$ 展开式的主项 $\\theta(t) \\approx \\frac{t}{2} \\log(\\frac{t}{2\\pi})$，我们可以推导出合适的初始值。设 $n\\pi \\approx \\frac{t}{2}\\log(\\frac{t}{2\\pi})$，我们得到近似关系 $t \\approx 2\\pi n / \\log(n)$。对于足够大的 $n$，这为 Newton-Raphson 迭代提供了一个稳健的初始猜测值。实现将使用 `scipy.optimize.newton` 函数，它提供了一个可靠的预构建求解器。\n\n**3. Hardy Z函数的评估**\n\nHardy Z函数使用所提供的截断 Riemann-Siegel 主和进行评估：\n$$\nZ(t) \\approx 2 \\sum_{k=1}^{N} k^{-1/2} \\cos\\!\\big(\\theta(t) - t \\log k\\big)\n$$\n其中和中的项数 $N$ 由 $N = \\lfloor \\sqrt{t/(2\\pi)} \\rfloor$ 给出。余弦项中所需的 $\\theta(t)$ 值使用步骤1中的相同渐近公式计算。这个 $Z(t)$ 的近似对于中等到大的 $t$ 值是准确的，这也与正在研究的索引范围相对应。\n\n**4. Gram 定律失效的检测**\n\n算法的最后阶段是测试失效情况。对于给定范围 $[n_{\\text{start}}, n_{\\text{end}}-1]$ 内的每个整数 $n$，执行以下过程：\n$a$. 使用步骤2中的 Newton 法程序计算 Gram 点 $g_n$ 和 $g_{n+1}$。\n$b$. 使用步骤3中的公式评估相应的 Z函数值 $Z(g_n)$ 和 $Z(g_{n+1})$。\n$c$. 确定这两个值的符号。如果一个值 $v$ 满足 $|v| < \\epsilon$（其中 $\\epsilon = 10^{-9}$ 是一个小容差），则该值被视为零。符号定义如下：\n$$\n\\text{sign}(v) = \\begin{cases} 1  &\\text{if } v > \\epsilon \\\\ -1 &\\text{if } v < -\\epsilon \\\\ 0  &\\text{if } |v| \\le \\epsilon \\end{cases}\n$$\n$d$. 检查符号是否未能交替。如果 $\\text{sign}(Z(g_n)) \\cdot \\text{sign}(Z(g_{n+1})) \\neq -1$，则记录一次失效。这个条件正确地捕捉了符号相同（乘积为 $1$）或其中一个值在数值上为零（乘积为 $0$）的情况。\n$e$. 如果在索引 $n$ 处发现失效，该值将被记录为给定范围的结果，并且对该范围的搜索终止。如果循环完成而没有发现任何失效，结果将记录为 $-1$。\n\n这个完整的算法设计在随附的 Python 脚本中实现，该脚本处理指定的测试用例并生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the smallest index n of a Gram's law failure in given ranges.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 30),\n        (120, 140),\n        (500, 520),\n    ]\n\n    # Numerical tolerance for treating a value as zero\n    ZERO_TOLERANCE = 1e-9\n\n    memoized_theta = {}\n    \n    def theta(t: float) -> float:\n        \"\"\"\n        Asymptotic expansion for the Riemann-Siegel theta function.\n        \"\"\"\n        if t in memoized_theta:\n            return memoized_theta[t]\n        \n        if t == 0:\n            return 0.0\n            \n        # Per the problem statement\n        t_inv = 1.0 / t\n        t_inv_3 = t_inv**3\n        t_inv_5 = t_inv**5\n        \n        term1 = t / 2.0 * np.log(t / (2.0 * np.pi))\n        term2 = -t / 2.0\n        term3 = -np.pi / 8.0\n        term4 = 1.0 / 48.0 * t_inv\n        term5 = 7.0 / 5760.0 * t_inv_3\n        term6 = 31.0 / 80640.0 * t_inv_5\n        \n        result = term1 + term2 + term3 + term4 + term5 + term6\n        memoized_theta[t] = result\n        return result\n\n    def theta_prime(t: float) -> float:\n        \"\"\"\n        Derivative of the asymptotic expansion for theta(t).\n        \"\"\"\n        if t == 0:\n            return np.inf  # Avoid division by zero, effectively pushing solver away\n\n        t_inv_2 = 1.0 / (t * t)\n        t_inv_4 = t_inv_2 * t_inv_2\n        t_inv_6 = t_inv_4 * t_inv_2\n\n        term1 = 0.5 * np.log(t / (2.0 * np.pi))\n        term2 = -1.0 / (48.0) * t_inv_2\n        term3 = -7.0 / (1920.0) * t_inv_4\n        term4 = -31.0 / (16128.0) * t_inv_6\n        \n        return term1 + term2 + term3 + term4\n\n    memoized_gram_points = {}\n    \n    def find_gram_point(n: int) -> float:\n        \"\"\"\n        Finds the n-th Gram point g_n by solving theta(t) = n*pi.\n        \"\"\"\n        if n in memoized_gram_points:\n            return memoized_gram_points[n]\n\n        # Objective function for root finding: f(t) = theta(t) - n*pi\n        func = lambda t: theta(t) - n * np.pi\n        \n        # Derivative of the objective function\n        fprime = theta_prime\n        \n        # Initial guess from inverting the leading term of theta(t)\n        # t/2*log(t/(2*pi)) ~ n*pi => x*log(x) ~ n where x=t/(2*pi)\n        # For large n, t ~ 2*pi*n / np.log(n)\n        if n > 1:\n            t_guess = 2 * np.pi * n / np.log(n)\n        else: # Heuristic for small n where log(n) is problematic\n            t_guess = 20.0 \n\n        # Use Scipy's Newton-Raphson solver\n        gram_point = newton(func, t_guess, fprime=fprime, tol=1e-12, maxiter=100)\n        memoized_gram_points[n] = gram_point\n        return gram_point\n\n    memoized_z_values = {}\n\n    def Z_func(t: float) -> float:\n        \"\"\"\n        Approximates the Hardy Z-function using the truncated Riemann-Siegel main sum.\n        \"\"\"\n        if t in memoized_z_values:\n            return memoized_z_values[t]\n\n        N = int(np.sqrt(t / (2.0 * np.pi)))\n        if N == 0:\n            return 0.0\n\n        theta_val = theta(t)\n        \n        k_vals = np.arange(1, N + 1)\n        \n        terms = (1.0 / np.sqrt(k_vals)) * np.cos(theta_val - t * np.log(k_vals))\n        total_sum = np.sum(terms)\n        \n        result = 2.0 * total_sum\n        memoized_z_values[t] = result\n        return result\n\n    def get_sign(value: float) -> int:\n        \"\"\"\n        Determines the sign of a value, treating small values as zero.\n        \"\"\"\n        if value > ZERO_TOLERANCE:\n            return 1\n        elif value < -ZERO_TOLERANCE:\n            return -1\n        else:\n            return 0\n\n    results = []\n    for n_start, n_end in test_cases:\n        found_failure_index = -1\n        for n in range(n_start, n_end):\n            # We need to evaluate Z at g_n and g_{n+1}\n            g_n = find_gram_point(n)\n            g_n_plus_1 = find_gram_point(n + 1)\n\n            z_n = Z_func(g_n)\n            z_n_plus_1 = Z_func(g_n_plus_1)\n\n            sign_n = get_sign(z_n)\n            sign_n_plus_1 = get_sign(z_n_plus_1)\n\n            # A failure occurs if signs do not alternate\n            if sign_n * sign_n_plus_1 != -1:\n                found_failure_index = n\n                break\n        \n        results.append(found_failure_index)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031532"}, {"introduction": "这项压轴实践揭示了黎曼 $\\zeta$ 函数零点的深刻意义，它将零点的位置与素数的分布直接联系起来。通过使用黎曼的显式公式，并利用已知的非平凡零点来近似计算切比雪夫函数 $\\psi(x)$，你将亲眼见证零点如何“编码”了素数分布的精细波动。这个练习是理解黎曼猜想为何在数论中占据核心地位的关键一步。[@problem_id:3031529]", "problem": "设 $x$ 是一个大于 1 的实数，并令 $\\psi(x)$ 表示切比雪夫函数 $\\psi(x) = \\sum_{n \\le x} \\Lambda(n)$，其中 $\\Lambda(n)$ 是冯·曼戈尔特函数 (von Mangoldt function)。考虑一个显式公式，它用黎曼ζ函数 $\\zeta(s)$ 的非平凡零点来表示 $\\psi(x)$，其中每个非平凡零点表示为 $\\rho = \\beta + i \\gamma$，满足 $0 < \\beta < 1$。对于不为精确素数幂的 $x$，该显式公式的一个经典形式是\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\n其中求和遍及 $\\zeta(s)$ 的所有非平凡零点 $\\rho$（按重数计算）。在本问题中，您将使用一个已知的有限零点纵坐标列表，计算该显式公式的一个截断版本，以在 $x = 10^{6}$ 处估计 $\\psi(x) - x$。同时假设对于所使用的零点，黎曼猜想（RH）成立，因此这些零点的 $\\beta = \\tfrac{1}{2}$。您还将评估该估计值对这些零点位置微小扰动的敏感度。\n\n您必须遵守以下算法和数学要求：\n- 使用 $x = 10^{6}$。\n- 设可用的零点纵坐标集合为 $\\zeta(s)$ 在临界线 $\\operatorname{Re}(s) = \\tfrac{1}{2}$ 上的非平凡零点的前十个正纵坐标 $\\gamma_{k}$，如下所列：\n  - $\\gamma_{1} = 14.134725141734693$,\n  - $\\gamma_{2} = 21.022039638771555$,\n  - $\\gamma_{3} = 25.010857580145688$,\n  - $\\gamma_{4} = 30.424876125859513$,\n  - $\\gamma_{5} = 32.935061587739189$,\n  - $\\gamma_{6} = 37.586178158825671$,\n  - $\\gamma_{7} = 40.918719012147495$,\n  - $\\gamma_{8} = 43.327073280914999$,\n  - $\\gamma_{9} = 48.005150881167159$,\n  - $\\gamma_{10} = 49.773832477672302$。\n- 对于截断水平 $N \\in \\{0,1,\\dots,10\\}$，近似计算\n$$\n\\psi(x) - x \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr),\n$$\n其中 $\\rho_{k} = \\tfrac{1}{2} + i \\gamma_{k}$ 且 $\\overline{\\rho_{k}} = \\tfrac{1}{2} - i \\gamma_{k}$。请注意，对于实数 $x$，每对零点贡献一个实数值，并且成对求和可简化为\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}.\n$$\n- 为评估估计值对某个零点位置的敏感度，对选定的纵坐标引入一个扰动：对于给定的索引 $j \\in \\{1,\\dots,N\\}$ 和一个小的实数扰动 $\\delta$，将 $\\gamma_{j}$ 替换为 $\\gamma_{j} + \\delta$ 并重新计算截断估计值。将敏感度度量定义为扰动后和未扰动估计值之间的绝对差。\n\n所有计算都是纯数学的且无单位；所有对数均使用自然对数。您应使用实数算术和上面给出的三角简化来实现该算法。\n\n测试套件：\n- 使用 $x = 10^{6}$ 和上述 $\\gamma_{k}$ 列表。计算以下五个输出：\n  1) $N = 0$ 时的截断估计值（边界情况，不使用零点）。\n  2) $N = 5$ 时的截断估计值（基线部分和）。\n  3) $N = 10$ 时的截断估计值（更大的部分和）。\n  4) 当以 $\\delta = 10^{-6}$ 扰动第 $j = 5$ 个纵坐标时，$N = 10$ 的敏感度。\n  5) 当以 $\\delta = 10^{-6}$ 扰动第 $j = 1$ 个纵坐标时，$N = 10$ 的敏感度。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含按上述顺序列出的五项计算结果，结果为逗号分隔的列表，并用方括号括起来。例如，输出行必须类似于\n$[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$\n其中每个 $\\text{result}_{k}$ 是一个用标准十进制表示法书写的实数。", "solution": "用户想要计算切比雪夫函数 $\\psi(x)$ 的显式公式的截断版本，并评估其对黎曼ζ函数零点位置扰动的敏感度。\n\n### 基于原理的设计\n\n该问题围绕解析数论中的显式公式展开，该公式将素数计数函数 $\\psi(x)$ 与黎曼ζ函数 $\\zeta(s)$ 的非平凡零点 $\\rho$ 联系起来。提供的公式是：\n$$\n\\psi(x) \\;=\\; x \\;-\\; \\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n这可以重新整理以表示 $\\psi(x)$ 相对于 $x$ 的偏差：\n$$\n\\psi(x) - x \\;=\\; -\\sum_{\\rho} \\frac{x^{\\rho}}{\\rho} \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n求和遍及所有非平凡零点 $\\rho$。这些零点以复共轭对的形式出现。如果 $\\rho = \\beta + i\\gamma$ 是一个零点，那么它的共轭 $\\overline{\\rho} = \\beta - i\\gamma$ 也是一个零点。问题假设给定的零点满足黎曼猜想，这意味着它们的实部为 $\\beta = \\frac{1}{2}$。在此假设下，对于一个正纵坐标 $\\gamma_k > 0$，一对零点由 $\\rho_k = \\frac{1}{2} + i\\gamma_k$ 和 $\\overline{\\rho_k} = \\frac{1}{2} - i\\gamma_k$ 给出。\n\n该算法的核心是通过对前 $N$ 对零点求和来计算 $\\psi(x) - x$ 的截断近似值。我们将此近似值表示为 $E(x, N, \\{\\gamma_k\\})$，其形式如下：\n$$\nE(x, N, \\{\\gamma_k\\}) \\;\\approx\\; - \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right) \\;-\\; \\log(2\\pi) \\;-\\; \\frac{1}{2}\\log\\bigl(1 - x^{-2}\\bigr)\n$$\n每个共轭零点对的贡献是一个实数值项。如问题所述，此项可简化为：\n$$\n\\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}}\n\\;=\\;\n2\\, x^{1/2}\\, \\frac{\\tfrac{1}{2}\\cos(\\gamma_{k}\\log x) + \\gamma_{k}\\sin(\\gamma_{k}\\log x)}{\\tfrac{1}{4} + \\gamma_{k}^{2}}\n$$\n我们的算法实现了一个函数 `compute_psi_minus_x`，该函数计算此截断估计值 $E(x, N, \\{\\gamma_k\\})$。\n\n**算法步骤：**\n\n1.  **定义输入和常量：** $x$ 的值设为 $10^6$。存储前 10 个正纵坐标 $\\{\\gamma_k\\}$ 的列表。\n\n2.  **模块化函数：** 设计一个函数 `compute_psi_minus_x(x, gammas_list)` 来计算该估计值。它以 $x$ 和一个纵坐标列表作为输入，其中列表的长度对应于截断水平 $N$。\n\n3.  **常数项计算：** 该函数首先计算表达式中与零点无关的部分：$C(x) = \\log(2\\pi) + \\frac{1}{2}\\log(1 - x^{-2})$。总估计值为 $-S - C(x)$，其中 $S$ 是对零点的求和。对于较大的 $x$，为了数值稳定性，项 $\\log(1 - x^{-2})$ 使用 `np.log1p(-x**-2)` 计算，这对于接近 0 的参数更精确。\n\n4.  **对零点求和：** 然后，函数遍历提供的 `gammas_list`。对于每个 $\\gamma_k$，它使用简化的实数值公式计算相应零点对的贡献。将这些贡献相加以获得总和 $S = \\sum_{k=1}^{N} \\left( \\frac{x^{\\rho_{k}}}{\\rho_{k}} + \\frac{x^{\\overline{\\rho_{k}}}}{\\overline{\\rho_{k}}} \\right)$。\n\n5.  **最终估计：** 函数返回最终估计值 $-S - C(x)$。\n\n6.  **测试用例计算：** 通过使用 `gammas` 列表的适当切片调用 `compute_psi_minus_x` 来计算 $N=0$, $N=5$ 和 $N=10$ 的估计值。对于 $N=0$，传递一个空列表，导致和 $S=0$。为进行敏感度分析，存储 $N=10$ 的基线估计值。\n\n7.  **敏感度分析：** 为评估敏感度，计算一个扰动后的估计值。创建完整 `gammas` 列表（用于 $N=10$）的副本。通过添加一个小的扰动 $\\delta = 10^{-6}$ 来修改选定的纵坐标 $\\gamma_j$。使用这个扰动后的列表调用 `compute_psi_minus_x` 函数。然后将敏感度计算为此扰动后估计值与基线 $N=10$ 估计值之间的绝对差。对 $j=1$ 和 $j=5$ 执行此过程。\n\n8.  **输出格式化：** 将五个所需的数值结果收集到一个列表中，并按照指定格式化为单个输出字符串。\n\n这种结构化方法通过直接实现既定的数学公式来确保正确性，并通过利用 `numpy` 库中的适当函数提供稳健的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_psi_minus_x(x, gammas_list):\n    \"\"\"\n    Computes the truncated explicit formula approximation for psi(x) - x.\n\n    Args:\n        x (float): The value at which to evaluate the function. Must be > 1.\n        gammas_list (list of float): A list of the positive ordinates of the\n                                     nontrivial zeros of the Riemann zeta function.\n\n    Returns:\n        float: The approximated value of psi(x) - x.\n    \"\"\"\n    log_x = np.log(x)\n    x_sqrt = np.sqrt(x)\n\n    # Calculate the constant terms: -log(2*pi) - 0.5*log(1 - x**-2)\n    # Using np.log1p(y) = log(1+y) for better precision when y is close to 0.\n    # Here, y = -x**-2, which is very close to 0 for x=10^6.\n    const_term = -(np.log(2 * np.pi) + 0.5 * np.log1p(-x**-2))\n\n    # Calculate the sum over the nontrivial zeros.\n    sum_zeros = 0.0\n    for gamma in gammas_list:\n        arg = gamma * log_x\n        # Contribution from the pair of zeros (1/2 + i*gamma, 1/2 - i*gamma)\n        numerator = 0.5 * np.cos(arg) + gamma * np.sin(arg)\n        denominator = 0.25 + gamma**2\n        term = 2 * x_sqrt * numerator / denominator\n        sum_zeros += term\n    \n    # The full formula is -sum_zeros + const_term\n    return -sum_zeros + const_term\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    \"\"\"\n    # Define the parameters and test cases from the problem statement.\n    x = 10.0**6\n    gammas = [\n        14.134725141734693,\n        21.022039638771555,\n        25.010857580145688,\n        30.424876125859513,\n        32.935061587739189,\n        37.586178158825671,\n        40.918719012147495,\n        43.327073280914999,\n        48.005150881167159,\n        49.773832477672302\n    ]\n    delta = 1e-6\n\n    # 1) Compute the truncated estimate with N = 0 (no zeros used)\n    est_N0 = compute_psi_minus_x(x, [])\n    \n    # 2) Compute the truncated estimate with N = 5\n    est_N5 = compute_psi_minus_x(x, gammas[:5])\n\n    # 3) Compute the truncated estimate with N = 10\n    est_N10 = compute_psi_minus_x(x, gammas)\n\n    # 4) Compute the sensitivity for N = 10 when perturbing gamma_5\n    gammas_pert_j5 = gammas[:]  # Create a copy\n    gammas_pert_j5[4] += delta   # j=5 corresponds to index 4\n    est_pert_j5 = compute_psi_minus_x(x, gammas_pert_j5)\n    sens_j5 = abs(est_pert_j5 - est_N10)\n\n    # 5) Compute the sensitivity for N = 10 when perturbing gamma_1\n    gammas_pert_j1 = gammas[:]  # Create a copy\n    gammas_pert_j1[0] += delta   # j=1 corresponds to index 0\n    est_pert_j1 = compute_psi_minus_x(x, gammas_pert_j1)\n    sens_j1 = abs(est_pert_j1 - est_N10)\n\n    results = [est_N0, est_N5, est_N10, sens_j5, sens_j1]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3031529"}]}