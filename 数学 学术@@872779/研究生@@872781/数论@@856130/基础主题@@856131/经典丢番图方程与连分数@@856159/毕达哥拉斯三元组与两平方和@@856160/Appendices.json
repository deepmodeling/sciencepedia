{"hands_on_practices": [{"introduction": "本练习将理论付诸实践，让你亲手操作高斯整数环 $\\mathbb{Z}[i]$ 中的欧几里得算法。这个过程不仅是为了计算一个结果，更是为了体验一个构造性的证明：费马双平方和定理是如何通过高斯整数的结构得到证明的。通过计算最大公约数 [@problem_id:3021535]，你将揭示一个素数如何分解为两个平方和的内在机制。", "problem": "设$p$为有理素数$p=97$。在高斯整数环$\\mathbb{Z}[i]=\\{a+bi:a,b\\in\\mathbb{Z}\\}$中进行运算，其范数为$N(a+bi)=a^2+b^2$。回顾一下，$\\mathbb{Z}[i]$是关于范数$N$的欧几里得整环，因此最大公约数（在相伴数意义下，即相差一个单位元的乘积）存在，并且可以通过欧几里得算法计算。再回顾一下，如果$p\\equiv 1 \\pmod{4}$，那么在$\\mathbb{Z}$中$-1$是模$p$的二次剩余。\n\n你的任务是仅利用这些基本事实和在$\\mathbb{Z}[i]$中的欧几里得算法，将$p$明确地表示为两个平方数之和。请按以下步骤操作：\n\n1. 找一个整数$a$满足$0  a  p/2$且$a^2 \\equiv -1 \\pmod p$。\n2. 使用欧几里得算法计算高斯整数$p$和$a+i$的最大公约数。\n3. 从该最大公约数中，提取$p$的两个平方和表示。", "solution": "解题过程遵循问题中指定的步骤，但核心在于在高斯整数环 $\\mathbb{Z}[i]$ 中执行欧几里得算法，而非在整数环 $\\mathbb{Z}$ 中。\n\n**第1步：找一个整数 $a$ 满足 $0  a  p/2$ 且 $a^2 \\equiv -1 \\pmod{p}$**\n\n给定素数 $p=97$。我们需要找到一个整数 $a$ 使得 $a^2+1$ 是 $97$ 的倍数。通过试错法或使用Tonelli-Shanks算法，我们找到 $a=22$。我们验证：\n$$22^2 = 484 = 5 \\times 97 - 1 \\equiv -1 \\pmod{97}$$\n由于 $0  22  97/2 = 48.5$，这个 $a$ 符合所有条件。\n\n**第2步：在高斯整数环 $\\mathbb{Z}[i]$ 中计算 $\\gcd(p, a+i)$**\n\n我们现在计算 $\\gcd(97, 22+i)$。我们使用基于范数的欧几里得算法。\n\n第一步，用 $22+i$ 除 $97$。商是通过将复数除法结果 $\\frac{97}{22+i}$ 四舍五入到最近的高斯整数得到的：\n$$\\frac{97}{22+i} = \\frac{97(22-i)}{(22+i)(22-i)} = \\frac{97(22-i)}{484+1} = \\frac{97(22-i)}{485} = \\frac{22-i}{5} = 4.4 - 0.2i$$\n最近的高斯整数是 $4$。\n现在我们计算余数 $r_1$：\n$$r_1 = 97 - 4(22+i) = 97 - (88+4i) = 9 - 4i$$\n其范数是 $N(9-4i) = 9^2 + (-4)^2 = 81 + 16 = 97$。\n\n第二步，用余数 $r_1 = 9-4i$ 除之前的除数 $22+i$：\n$$\\frac{22+i}{9-4i} = \\frac{(22+i)(9+4i)}{(9-4i)(9+4i)} = \\frac{198 + 88i + 9i - 4}{81+16} = \\frac{194 + 97i}{97} = 2+i$$\n这是一个高斯整数，所以除法是精确的，余数为 $0$。\n\n由于余数为零，算法终止。最后一个非零余数是最大公约数（在相伴数意义下）。因此，$\\gcd(97, 22+i) = 9-4i$。\n\n**第3步：从最大公约数中提取平方和**\n\n理论告诉我们，对于 $p \\equiv 1 \\pmod 4$，$\\gcd(p, a+i)$ 的范数将等于 $p$。我们验证一下：\n$$N(9-4i) = 9^2 + (-4)^2 = 81 + 16 = 97 = p$$\n高斯整数 $9-4i$ 的实部和虚部（的绝对值）就是构成平方和的两个数。从高斯整数 $9-4i$ 中，我们得到整数对 $(9, -4)$。其平方和为 $9^2+(-4)^2=97$。最终答案要求一个有序对，通常是正整数，所以我们取绝对值得到数对 $(9,4)$。\n\n这证实了 $97 = 9^2 + 4^2$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9  4 \\end{pmatrix}}\n$$", "id": "3021535"}, {"introduction": "在掌握了高斯整数环中的直接方法后，我们来探索一个更高效、完全在整数域内操作的算法——科纳基亚算法。这个练习 [@problem_id:3021527] 的精髓在于，它不仅要求你执行一个计算流程，更挑战你从理论上证明其正确性。你需要将这个基于整数的欧几里得算法与高斯整数环中的最大公约数理论联系起来，从而加深对不同数学工具间深层联系的理解。", "problem": "设 $p$ 为素数 $p=2017$，满足 $p\\equiv 1 \\pmod{4}$。在配备了范数 $N(a+bi)=a^{2}+b^{2}$ 的高斯整数环 $\\mathbb{Z}[i]=\\{a+bi : a,b\\in \\mathbb{Z}\\}$ 上进行运算。仅使用以下基本事实作为出发点：(i) 对于素数 $p\\equiv 1 \\pmod{4}$，剩余类 $-1$ 是模 $p$ 的二次剩余，因此存在 $t\\in \\mathbb{Z}$ 使得 $t^{2}\\equiv -1 \\pmod{p}$；(ii) $\\mathbb{Z}[i]$ 是关于范数 $N$ 的欧几里得整环，特别地，其上有最大公约数（GCD）和唯一分解；(iii) 如果 $\\pi\\in \\mathbb{Z}[i]$ 整除 $p$ 且 $\\pi$ 不是一个单位元，那么 $N(\\pi)$ 整除 $p^2$，所以 $N(\\pi)\\in \\{p,p^{2}\\}$。\n\n你的任务如下：\n1. 明确地找出一个整数 $t$ 使得 $t^{2}\\equiv -1 \\pmod{p}$，并通过直接的模运算来验证你的结论。\n2. 从这个 $t$ 出发，执行 Cornacchia 算法来构造整数 $x,y\\ge 0$ 使得 $x^{2}+y^{2}=p$，其中你必须选择 $x\\le y$ 的表示。展示 Cornacchia 方法所要求的欧几里得算法的所有步骤，并验证其输出确实满足 $x^{2}+y^{2}=p$。\n3. 通过将整数上的欧几里得算法与 $\\mathbb{Z}[i]$ 中关于范数 $N$ 的除法联系起来，证明 Cornacchia 算法在此实例中的正确性。特别地，证明如果 $t^{2}\\equiv -1 \\pmod{p}$，那么 $p$ 和 $t+i$ 在 $\\mathbb{Z}[i]$ 中的高斯整数最大公约数的范数为 $p$，并解释为什么这样一个最大公约数的实部和虚部（在不考虑顺序和符号的情况下）与 Cornacchia 算法产生的数对 $(x,y)$ 一致。\n\n你的最终答案必须是满足 $x\\le y$ 的有序对 $(x,y)$，写成一个单行矩阵的形式。不需要四舍五入，也不涉及单位。最终答案必须是精确的。", "solution": "所述问题是有效的。这是一个基于既定原理的、适定的数论问题。我们将按要求分三部分进行。\n\n### 第 1 部分：寻找整数 $t$ 使得 $t^{2}\\equiv -1 \\pmod{p}$\n\n设 $p=2017$。已知这是一个素数且 $p \\equiv 1 \\pmod{4}$，这是正确的，因为 $2017 = 4 \\times 504 + 1$。Fermat 的平方和定理保证了这样一个素数可以唯一地写成两个平方数之和。通过观察或简单搜索，我们找到这个表示：\n$$\n2017 = 9^2 + 44^2 = 81 + 1936\n$$\n正如将在第 3 部分中证明的，这种表示 $p=x^2+y^2$ 的存在性与 $p$ 在高斯整数环 $\\mathbb{Z}[i]$ 中分解为 $p=(x+yi)(x-yi)$ 有内在联系。而这种分解又与是否存在一个整数 $t$ 使得 $t^2 \\equiv -1 \\pmod{p}$ 有关。具体来说，$p$ 和 $t+i$ 在 $\\mathbb{Z}[i]$ 中的最大公约数（GCD）将是因子 $x+yi$ 或 $x-yi$ 之一（在乘以单位元 $\\pm 1, \\pm i$ 的意义下）。\n\n让我们假设 GCD 是 $\\pi = 44+9i$ 的相伴元。要使其成为 $p$ 和 $t+i$ 的 GCD，$t+i$ 必须是 $\\pi$ 的倍数。也就是说，$t+i = \\gamma \\cdot \\pi$，其中某个 $\\gamma = a+bi \\in \\mathbb{Z}[i]$。\n$$\nt+i = (a+bi)(44+9i) = (44a - 9b) + i(9a+44b)\n$$\n令虚部相等，我们必须有 $9a+44b=1$。这是一个线性丢番图方程。我们可以使用扩展欧几里得算法来求解它。\n$$\n\\begin{aligned}\n44 = 4 \\times 9 + 8 \\\\\n9 = 1 \\times 8 + 1\n\\end{aligned}\n$$\n反向回代：\n$$\n1 = 9 - 1 \\times 8 = 9 - 1 \\times (44 - 4 \\times 9) = 9 - 44 + 4 \\times 9 = 5 \\times 9 - 1 \\times 44\n$$\n所以我们得到一个解 $a=5$ 和 $b=-1$。将这些值代入实部的表达式中得到 $t$：\n$$\nt = 44a - 9b = 44(5) - 9(-1) = 220 + 9 = 229\n$$\n因此，我们找到了一个候选值 $t=229$。现在我们必须验证它是否满足 $t^{2}\\equiv -1 \\pmod{2017}$。\n$$\n229^2 = 52441\n$$\n为了求模 $2017$ 的余数，我们进行除法运算：\n$$\n52441 = 25 \\times 2017 + 2016\n$$\n由于 $2016 \\equiv -1 \\pmod{2017}$，我们成功地验证了我们的结论：\n$$\n229^2 \\equiv 2016 \\equiv -1 \\pmod{2017}\n$$\n因此，一个明确的整数 $t$ 是 $t=229$。\n\n### 第 2 部分：Cornacchia 算法\n\nCornacchia 算法使用第 1 部分中找到的整数 $t=229$ 来寻找整数 $x,y \\ge 0$ 使得 $x^2+y^2=p$。该算法包括对数对 $(p, t)$ 应用欧几里得算法，并在第一个小于 $\\sqrt{p}$ 的余数处停止。\n\n给定 $p=2017$ 和 $t=229$。我们注意到 $\\sqrt{2017} \\approx 44.9$。\n设 $r_0 = p = 2017$ 和 $r_1 = t = 229$。\n欧几里得算法的步骤是：\n$$\nr_0 = q_1 r_1 + r_2 \\implies 2017 = 8 \\times 229 + 185\n$$\n第一个余数是 $r_2=185$。因为 $185 > 44.9$，我们继续。\n$$\nr_1 = q_2 r_2 + r_3 \\implies 229 = 1 \\times 185 + 44\n$$\n下一个余数是 $r_3=44$。因为 $44  44.9$，我们在此停止。\n该算法建议将其中一个数，比如说 $x$，设为这个余数：\n$$\nx = r_3 = 44\n$$\n另一个数 $y$ 通过计算得到：\n$$\ny^2 = p - x^2 = 2017 - 44^2 = 2017 - 1936 = 81\n$$\n取正平方根，我们得到：\n$$\ny = \\sqrt{81} = 9\n$$\n这给出了数对 $(x,y)=(44,9)$。问题要求 $x \\le y$ 的表示，所以我们将它们排序为 $(9, 44)$。\n\n为了验证结果，我们计算平方和：\n$$\n9^2 + 44^2 = 81 + 1936 = 2017\n$$\n这与素数 $p$ 相符，因此数对 $(x,y)=(9,44)$ 是正确的表示。\n\n### 第 3 部分：算法正确性的证明\n\nCornacchia 算法的正确性源于高斯整数 $\\mathbb{Z}[i]$ 的性质。其逻辑可以总结如下：\n\n1.  **$p$ 在 $\\mathbb{Z}[i]$ 中的分解**：一个有理素数 $p \\in \\mathbb{Z}$ 在 $\\mathbb{Z}[i]$ 中也是素数的充要条件是 $p \\equiv 3 \\pmod{4}$。由于我们的素数是 $p=2017 \\equiv 1 \\pmod{4}$，它在 $\\mathbb{Z}[i]$ 中不是素数。它必须在 $\\mathbb{Z}[i]$ 中分解为两个素元。$p$ 作为高斯整数的范数是 $N(p) = p^2$。如果它的分解是 $p=\\pi_1 \\pi_2 \\dots \\pi_k$，那么 $N(p) = p^2 = N(\\pi_1)N(\\pi_2)\\dots N(\\pi_k)$。问题陈述给出，对于 $p$ 的一个非单位因子 $\\pi$，其范数 $N(\\pi)$ 可以是 $p$ 或 $p^2$。如果 $N(\\pi)=p^2$，那么 $\\pi$ 是 $p$ 的相伴元，这意味着 $p$ 在 $\\mathbb{Z}[i]$ 中是素数，这是一个矛盾。因此，$p$ 的任何素因子 $\\pi$ 的范数必须为 $p$。分解的形式必须是 $p = \\pi \\bar{\\pi}$（在单位元范围内），其中 $\\pi=x+yi$ 是一个高斯素数，且 $N(\\pi) = x^2+y^2=p$。\n\n2.  **与 $t^2 \\equiv -1 \\pmod p$ 的联系**：条件 $t^2 \\equiv -1 \\pmod p$ 意味着 $t^2+1$ 是 $p$ 的倍数，即对某个整数 $k$ 有 $t^2+1=kp$。在 $\\mathbb{Z}[i]$ 中，这个方程是 $(t+i)(t-i) = kp$。由于 $p=\\pi\\bar{\\pi}$，我们有 $(t+i)(t-i) = k\\pi\\bar{\\pi}$。这意味着 $\\pi$ 必须整除 $(t+i)$ 或 $(t-i)$，因为 $\\pi$ 是 $\\mathbb{Z}[i]$ 中的一个素数。\n    - 如果 $\\pi | (t+i)$，那么 $\\pi$ 是 $p$（因为 $\\pi|p$）和 $t+i$ 的一个公因子。\n    - 如果 $\\pi | (t-i)$，那么通过取共轭，有 $\\bar{\\pi} | \\overline{(t-i)} = t+i$。所以 $\\bar{\\pi}$ 是 $p$（因为 $\\bar{\\pi}|\\bar{p}=p$）和 $t+i$ 的一个公因子。\n    无论哪种情况，$p$ 的一个素因子，$\\pi$ 或 $\\bar{\\pi}$，必须整除 $t+i$。因此，$p$ 和 $t+i$ 在 $\\mathbb{Z}[i]$ 中的最大公约数，我们称之为 $\\pi_0 = \\gcd(p, t+i)$，必须是 $\\pi$ 或 $\\bar{\\pi}$ 的相伴元。它的范数必须是 $N(\\pi_0) = N(\\pi) = p$。\n\n3.  **与欧几里得算法的联系**：设 $\\pi_0 = \\gcd(p, t+i) = x+yi$，现在我们知道 $x^2+y^2=p$。Cornacchia 算法本质上是一种仅使用整数算术从这个 GCD 关系中提取整数 $x$ 和 $y$ 的方法。\n    对整数 $p$ 和 $t$ 使用欧几里得算法会生成一个余数序列 $r_k$，它们是 $p$ 和 $t$ 的整系数线性组合：$r_k = u_k p + v_k t$。\n    在 $\\mathbb{Z}[i]$ 中，由于 $\\pi_0 | p$ 和 $\\pi_0 | t+i$，我们可以将这些关系写成模 $\\pi_0$ 的同余式：\n    $$\n    p \\equiv 0 \\pmod{\\pi_0} \\quad \\text{和} \\quad t+i \\equiv 0 \\pmod{\\pi_0} \\implies t \\equiv -i \\pmod{\\pi_0}\n    $$\n    现在考虑整数欧几里得算法中的余数 $r_k$，模 $\\pi_0$：\n    $$\n    r_k = u_k p + v_k t \\equiv u_k(0) + v_k(-i) \\equiv -iv_k \\pmod{\\pi_0}\n    $$\n    算法在第一个满足 $r_k  \\sqrt{p}$ 的余数 $r_k$ 处停止。我们称这个余数为 $x'$。因此，对于某个来自扩展欧几里得算法的整数 $v$，我们有 $x' \\equiv -iv \\pmod{\\pi_0}$。这意味着 $x'$ 与一个纯虚数模 $\\pi_0=x+yi$ 同余。\n    Cornacchia 算法将这个 $x'$ 识别为所需数对 $(x,y)$ 的一个分量（比如 $x$）。然后它通过 $y=\\sqrt{p-x'^2}$ 找到另一个分量 $y$。支撑该算法的定理保证，对于正确的 $t$ 选择，这个 $y$ 将是一个整数。在我们的例子中，算法得出了 $(44,9)$。对于 $t=229$，在 $\\mathbb{Z}[i]$ 中的 GCD 是 $44+9i$ 或 $44-9i$ 的相伴元。实部和虚部 $44$ 和 $9$，在不考虑顺序的情况下，恰好是 Cornacchia 算法产生的数对 $(x,y)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n9  44\n\\end{pmatrix}\n}\n$$", "id": "3021527"}, {"introduction": "从素数到合数，是数论研究中自然的一步。这个练习 [@problem_id:3021526] 将我们之前处理素数的工具扩展到更广泛的场景。你将通过编写程序，利用高斯整数范数的乘法性质（即婆罗摩笈多－斐波那契恒等式）来为合数寻找双平方和表示。此练习不仅巩固了理论，还引入了“下降法”这一优化策略，锻炼了将抽象理论转化为高效算法的实际编程能力。", "problem": "您需要实现一个完整的、可运行的程序。该程序从素数幂的平方和表示出发，通过在高斯整数环中重复复合给定的素数幂表示，来构建一个合数 $n$ 的平方和表示。该算法必须体现一种下降策略，在每个复合步骤中，从可用的相伴数中进行选择，以最小化所得数对中较大的分量。该程序还必须通过将高斯整数的乘法结构与平方和的复合联系起来，来证明该方法的正确性。\n\n基本基础和范围：\n- 使用高斯整数环 $\\mathbb{Z}[i]$、其定义及其范数 $N(a+bi)$（定义为 $N(a+bi)=a^2+b^2$）作为基础出发点。范数在环乘法下是可乘的，并且该环是关于范数的欧几里得整环。\n- 不要在问题陈述中假设或引用任何显式的复合公式。您的解答必须从环结构和上述性质中推导出任何所需的恒等式。\n\n任务规范：\n- 输入模型：您的程序不会读取输入。相反，它将在内部定义一个测试套件，其中包含作为素数幂表示序列的合数目标。每个素数幂表示以一个有序整数对 $(a,b)$ 的形式给出，满足 $a^2+b^2=p^e$，其中 $p$ 为某个素数，$e\\in\\mathbb{Z}_{\\ge 0}$ 为指数。在某些边界情况下，某个因子可能被声明为不可表示（例如，对于素数 $p\\equiv 3 \\pmod{4}$ 且指数为奇数），此时使用一个哨兵值来传达不可行性。\n- 算法目标：给定一个可表示的素数幂的有限序列 $(a_1,b_1),\\dots,(a_m,b_m)$，通过在 $\\mathbb{Z}[i]$ 中复合这些表示，构建一个表示 $(x,y)$，使得 $x^2+y^2=\\prod_{j=1}^m(a_j^2+b_j^2)$。在每个复合步骤中，选择相伴数以使得所得数对的两个分量中较大的那个最小化。通过强制 $x\\ge 0$，$y\\ge 0$ 和 $x\\le y$ 来规范化输出。\n- 不可行性处理：如果任何因子被声明为不可表示（例如，一个素数 $p\\equiv 3 \\pmod{4}$ 的奇次幂），您的程序必须为该测试用例输出布尔值 $\\mathrm{False}$，以反映该合数 $n$ 不能表示为两个平方之和。\n\n单位和表示：\n- 不涉及物理单位。所有输出均为纯整数。此问题不涉及角度或百分比。\n\n测试套件：\n实现并解决以下内置测试用例。每个用例是一个因子序列，其中因子可以是一个可表示的数对 $(a,b)$，解释为范数为 $a^2+b^2$ 的高斯整数 $a+bi$；也可以是一个指示素数幂 $p^e$ 不可表示的哨兵值。\n\n- 案例 1（顺利路径，两个与 $1$ 模 $4$ 同余的不同素数）：因子 $[(1,2),(2,3)]$，分别表示 $5$ 和 $13$。合数 $n$ 是 $65$。\n- 案例 2（素数幂乘以一个素数）：因子 $[(3,4),(2,3)]$，表示 $5^2$ 和 $13$。合数 $n$ 是 $325$。\n- 案例 3（因一个与 $3$ 模 $4$ 同余且指数为奇数的素数而不可行）：因子 $[\\mathrm{None\\ for\\ }(3,1),(1,2)]$，表示 $3^1$（不可表示）和 $5$。合数 $n$ 是 $15$；程序必须输出 $\\mathrm{False}$。\n- 案例 4（包含素数 $2$）：因子 $[(1,1),(1,2),(2,3)]$，表示 $2$、$5$ 和 $13$。合数 $n$ 是 $130$。\n- 案例 5（两个不同的素数）：因子 $[(2,3),(1,4)]$，表示 $13$ 和 $17$。合数 $n$ 是 $221$。\n- 案例 6（与 $3$ 模 $4$ 同余的素数的偶数次幂）：因子 $[(0,3),(1,2)]$，表示 $3^2$ 和 $5$。合数 $n$ 是 $45$。\n- 案例 7（更高次素数幂与一个素数复合）：因子 $[(7,24),(2,3)]$，表示 $5^4$ 和 $13$。合数 $n$ 是 $8125$。\n- 案例 8（更高次的 $2$ 的幂与一个素数复合）：因子 $[(2,2),(1,4)]$，表示 $2^3$ 和 $17$。合数 $n$ 是 $136$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含上述八个案例的结果，格式为一个包含在方括号内的逗号分隔列表。每个可表示的案例打印为一个无空格的双元素列表 $[x,y]$，每个不可行的案例打印为布尔字面量 $\\mathrm{False}$。例如，形如 $[[x_1,y_1],\\mathrm{False},[x_3,y_3],\\dots]$ 的输出。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。其科学基础在于数论原理，特别是关于高斯整数环的性质。该问题是适定的，为构建一个唯一的、确定性的解提供了所有必要的定义、条件和约束。它以客观、正式的语言表达，没有歧义或主观论断。因此，我们可以着手提供一个完整的解决方案。\n\n问题的核心在于将一个整数 $n$ 表示为两个平方之和，即 $n=x^2+y^2$。这与高斯整数环（记作 $\\mathbb{Z}[i]$）的代数结构有内在的联系。\n\n**1. 理论基础：高斯整数环**\n\n高斯整数环是集合 $\\mathbb{Z}[i] = \\{a+bi \\mid a,b \\in \\mathbb{Z}\\}$，其中 $i$ 是满足 $i^2 = -1$ 的虚数单位。对于 $\\mathbb{Z}[i]$ 中的任意元素 $\\alpha = a+bi$，其范数定义为：\n$$N(\\alpha) = N(a+bi) = (a+bi)(a-bi) = a^2+b^2$$\n范数是一个非负整数。一个整数 $n$ 能写成两个平方之和，当且仅当它是某个高斯整数的范数。也就是说，对于整数 $x, y$，$n = x^2+y^2$ 等价于 $n = N(x+yi)$。\n\n问题要求从 $\\mathbb{Z}[i]$ 的性质推导出平方和的复合。关键性质是范数是可乘的。设 $\\alpha = a+bi$ 和 $\\beta = c+di$ 是两个高斯整数。它们在 $\\mathbb{Z}[i]$ 中的乘积是：\n$$\\alpha\\beta = (a+bi)(c+di) = (ac-bd) + (ad+bc)i$$\n该乘积的范数是：\n$$N(\\alpha\\beta) = N((ac-bd) + (ad+bc)i) = (ac-bd)^2 + (ad+bc)^2$$\n展开此表达式：\n$$(ac-bd)^2 + (ad+bc)^2 = (a^2c^2 - 2abcd + b^2d^2) + (a^2d^2 + 2abcd + b^2c^2)$$\n$$= a^2c^2 + b^2d^2 + a^2d^2 + b^2c^2 = a^2(c^2+d^2) + b^2(c^2+d^2) = (a^2+b^2)(c^2+d^2)$$\n这证明了 $N(\\alpha\\beta) = N(\\alpha)N(\\beta)$。这个结果是婆罗摩笈多－斐波那契恒等式的一种重述。它表明，如果两个整数 $n_1$ 和 $n_2$ 都能表示为两个平方之和，那么它们的乘积 $n_1n_2$ 也能表示为两个平方之和。\n\n**2. 复合与下降的算法策略**\n\n任务是为一个合数 $n = \\prod_{j=1}^{m} p_j^{e_j}$ 找到一个表示 $(x,y)$，而已知每个因子 $n_j = p_j^{e_j}$ 的表示为 $(a_j, b_j)$，其中 $n_j = a_j^2+b_j^2$。这对应于一个高斯整数序列 $\\gamma_j = a_j+b_j i$，使得 $n_j = N(\\gamma_j)$。目标合数是 $n = \\prod n_j = \\prod N(\\gamma_j) = N(\\prod \\gamma_j)$。因此，高斯整数乘积 $\\Gamma = \\prod \\gamma_j$ 的分量将给出 $n$ 的一个所需表示。\n\n指定的“下降策略”要求在复合的每一步做出选择，以最小化所得数对中较大的分量。对于任何给定的因子 $n_j = a_j^2+b_j^2$，它既是 $\\gamma_j = a_j+b_j i$ 的范数，也是其复共轭 $\\bar{\\gamma}_j = a_j-b_j i$ 的范数。这在每个复合步骤中提供了两个不同的选择。\n\n设 $k-1$ 步后的累积乘积为 $\\Pi_{k-1} = u+vi$。下一个因子是 $n_k=a_k^2+b_k^2$，对应于 $\\gamma_k=a_k+b_k i$ 和 $\\bar{\\gamma}_k=a_k-b_k i$。我们为第 $k$ 步计算两个候选乘积：\n\n1. 与 $\\gamma_k$ 的乘积：$\\Pi_A = \\Pi_{k-1} \\cdot \\gamma_k = (u+vi)(a_k+b_k i) = (ua_k - vb_k) + (ub_k + va_k)i$。\n2. 与 $\\bar{\\gamma}_k$ 的乘积：$\\Pi_B = \\Pi_{k-1} \\cdot \\bar{\\gamma}_k = (u+vi)(a_k-b_k i) = (ua_k + vb_k) + (-ub_k + va_k)i$。\n\n设 $\\Pi_A = X_A + Y_A i$ 且 $\\Pi_B = X_B + Y_B i$。下降准则规定我们比较代价 $C_A = \\max(|X_A|, |Y_A|)$ 和 $C_B = \\max(|X_B|, |Y_B|)$，并选择代价最小的乘积作为 $\\Pi_k$。\n\n问题还提到了“可用的相伴数”。一个高斯整数 $\\alpha$ 的相伴数是 $\\alpha, i\\alpha, -\\alpha, -i\\alpha$。如果 $\\alpha=X+Yi$，其相伴数是 $X+Yi, -Y+Xi, -X-Yi$ 和 $Y-Xi$。其分量的绝对值只是被交换，即 $\\{|X|,|Y|\\}$ 变成 $\\{|-Y|,|X|\\} = \\{|Y|,|X|\\}$。因此，$\\max(|X|,|Y|)$ 在所有相伴数中是不变的。相伴数的选择不影响所定义的下降准则。关键的选择是在乘以 $\\gamma_k$ 和其共轭 $\\bar{\\gamma}_k$ 之间进行。\n\n**3. 逐步算法**\n\n对于给定的测试用例（一个因子序列），算法如下：\n\n1. **初始化**：检查因子序列。如果任何因子是不可表示的哨兵值（例如 `None`），则该合数不是两个平方之和。该用例的结果是 $\\mathrm{False}$。\n2. 如果所有因子都可表示为数对 $(a_j, b_j)$，取第一个数对 $(a_1, b_1)$ 并将当前累积的高斯整数初始化为 $\\Pi_1 = a_1 + b_1 i$。设其分量为 $(u,v) = (a_1,b_1)$。\n3. **迭代**：对于从 $k=2$ 到 $m$ 的每个后续因子 $(a_k, b_k)$：\n    a. 计算两个候选乘积：\n        - $(X_A, Y_A) = (u a_k - v b_k, u b_k + v a_k)$\n        - $(X_B, Y_B) = (u a_k + v b_k, -u b_k + v a_k)$\n    b. 计算它们各自的代价：\n        - $C_A = \\max(|X_A|, |Y_A|)$\n        - $C_B = \\max(|X_B|, |Y_B|)$\n    c. 应用下降法则：如果 $C_A \\le C_B$，更新 $(u,v) = (X_A, Y_A)$。否则，更新 $(u,v) = (X_B, Y_B)$。在相等的情况下，此规则提供了一个确定性的选择。\n4. **最终化**：迭代完所有因子后，最终累积的分量是 $(u,v)$。问题要求输出数对 $(x,y)$ 需要规范化以满足 $x \\ge 0$，$y \\ge 0$ 和 $x \\le y$。这通过以下方式实现：\n    $$x = \\min(|u|, |v|)$$\n    $$y = \\max(|u|, |v|)$$\n5. 该测试用例的结果是数对 $[x,y]$。\n\n**4. 不可行性条件**\n\n由 Legendre 推广的 Fermat 平方和定理指出，一个正整数 $n$ 可以写成两个平方之和，当且仅当 $n$ 的素因数分解中不包含任何形如 $p \\equiv 3 \\pmod 4$ 的素数的奇数次幂。输入中像 $3^1$ 这样的因子的哨兵值 `None` 意味着这个条件被违反了。因此，整个合数 $n$ 不能表示为两个平方之和。\n\n**示例：案例 4：因子 $[(1,1),(1,2),(2,3)]$，$n=130$**\n\n1. **初始化**：因子都是有效的数对。从第一个因子 $(1,1)$ 开始。当前累积的高斯整数是 $\\Pi_1 = 1+1i$。所以 $(u,v)=(1,1)$。\n2. **第 2 步**：与第二个因子 $(1,2)$ 复合，对应于 $\\gamma_2=1+2i$。\n    - 当前 $(u,v)=(1,1)$。新因子 $(a_2,b_2)=(1,2)$。\n    - 候选 A：$(1\\cdot1 - 1\\cdot2, 1\\cdot2 + 1\\cdot1) = (-1, 3)$。代价 $C_A = \\max(|-1|,|3|) = 3$。\n    - 候选 B：$(1\\cdot1 + 1\\cdot2, -1\\cdot2 + 1\\cdot1) = (3, -1)$。代价 $C_B = \\max(|3|,|-1|) = 3$。\n    - 代价相等 ($3 \\le 3$)。我们选择候选 A。累积乘积变为 $\\Pi_2 = -1+3i$。新的 $(u,v)=(-1,3)$。\n3. **第 3 步**：与第三个因子 $(2,3)$ 复合，对应于 $\\gamma_3=2+3i$。\n    - 当前 $(u,v)=(-1,3)$。新因子 $(a_3,b_3)=(2,3)$。\n    - 候选 A：$(-1\\cdot2 - 3\\cdot3, -1\\cdot3 + 3\\cdot2) = (-11, 3)$。代价 $C_A = \\max(|-11|,|3|) = 11$。\n    - 候选 B：$(-1\\cdot2 + 3\\cdot3, -(-1)\\cdot3 + 3\\cdot2) = (7, 9)$。代价 $C_B = \\max(|7|,|9|) = 9$。\n    - 因为 $C_B  C_A$ ($9  11$)，我们选择候选 B。最终累积的乘积是 $\\Pi_3 = 7+9i$。最终 $(u,v)=(7,9)$。\n4. **最终化**：规范化 $(7,9)$。\n    - $x = \\min(|7|,|9|) = 7$。\n    - $y = \\max(|7|,|9|) = 9$。\n    - 此案例的结果是 $[7,9]$。我们验证 $7^2+9^2 = 49+81 = 130$。\n\n这个从 $\\mathbb{Z}[i]$ 的乘法结构推导出的系统化过程，正确地实现了所要求的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves a series of problems on representing a composite integer n as a sum\n    of two squares, x^2 + y^2. The method uses the multiplicative structure\n    of Gaussian integers Z[i] and a descent strategy to choose among\n    composition paths.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: n = 5 * 13 = 65\n        [(1, 2), (2, 3)],\n        # Case 2: n = 5^2 * 13 = 25 * 13 = 325\n        [(3, 4), (2, 3)],\n        # Case 3: n = 3 * 5 = 15 (impossible)\n        [None, (1, 2)],\n        # Case 4: n = 2 * 5 * 13 = 130\n        [(1, 1), (1, 2), (2, 3)],\n        # Case 5: n = 13 * 17 = 221\n        [(2, 3), (1, 4)],\n        # Case 6: n = 3^2 * 5 = 9 * 5 = 45\n        [(0, 3), (1, 2)],\n        # Case 7: n = 5^4 * 13 = 625 * 13 = 8125\n        [(7, 24), (2, 3)],\n        # Case 8: n = 2^3 * 17 = 8 * 17 = 136\n        [(2, 2), (1, 4)],\n    ]\n\n    results = []\n    for factors in test_cases:\n        # Step 1: Handle impossibility\n        if any(f is None for f in factors):\n            results.append(False)\n            continue\n        \n        # Step 2: Initialize with the first factor\n        # The accumulated Gaussian integer is represented by a tuple (u, v) for u + vi\n        if not factors:\n            # Handle empty factor list, though not in test cases\n            results.append([0, 0])\n            continue\n            \n        u, v = factors[0]\n\n        # Step 3: Iterate through the remaining factors and compose\n        for i in range(1, len(factors)):\n            a, b = factors[i]\n\n            # The current accumulated Gaussian integer is u + vi.\n            # The new factor corresponds to Gaussian integers a+bi and a-bi.\n            # We compute two candidate products.\n\n            # Candidate A: (u+vi)(a+bi) = (ua - vb) + (ub + va)i\n            xa, ya = u * a - v * b, u * b + v * a\n            \n            # Candidate B: (u+vi)(a-bi) = (ua + vb) + (-ub + va)i\n            xb, yb = u * a + v * b, -u * b + v * a\n\n            # Calculate costs based on the descent strategy: minimize the larger component\n            cost_a = max(abs(xa), abs(ya))\n            cost_b = max(abs(xb), abs(yb))\n\n            # Apply the descent rule\n            if cost_a = cost_b:\n                u, v = xa, ya\n            else:\n                u, v = xb, yb\n\n        # Step 4: Normalize the final result\n        # The result (x,y) must satisfy x >= 0, y >= 0, and x = y\n        x = min(abs(u), abs(v))\n        y = max(abs(u), abs(v))\n        \n        results.append([x, y])\n\n    # Final print statement in the exact required format.\n    # The format is a list where representable cases are [x,y] and impossible cases are False.\n    # To match the output format exactly, boolean False needs to be lowercase.\n    # The string representation of Python's list and boolean objects matches this perfectly.\n    # e.g., str([1,2]) -> '[1, 2]' and str(False) -> 'False'\n    # We join these string representations, removing spaces for lists.\n    output_str = \",\".join(str(res).replace(\" \", \"\") if isinstance(res, list) else \"False\" for res in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3021526"}]}