{"hands_on_practices": [{"introduction": "在将一个数学概念付诸实践之前，通过具体计算来掌握其内在机制是至关重要的。本练习将引导你逐步应用雅可比符号的各个性质——包括分子乘法性、二次互反律及其补充定律——来计算一个具体的值 [@problem_id:1441656]。这个过程不仅能巩固你对理论的理解，也为后续更抽象和计算化的任务奠定了坚实的基础。", "problem": "在密码学算法和素性检验中，例如 Solovay-Strassen 素性检验，高效计算雅可比符号是一项基本操作。雅可比符号，记作 $(\\frac{a}{n})$，是为整数 $a$ 和正奇数 $n$ 定义的。雅可比符号的一个关键优势是，它的值可以快速确定，而无需找出分母 $n$ 的素因数分解。这是通过应用一套变换规则来实现的，这些规则在精神上类似于求最大公约数的欧几里得算法的步骤。\n\n根据这些计算性质，您的任务是计算雅可比符号 $(\\frac{38}{105})$ 的值。您的最终答案应该是一个整数。", "solution": "我们被要求计算雅可比符号 $(\\frac{38}{105})$。我们将使用雅可比符号的性质来简化表达式，直到得出最终值。\n\n我们将使用的主要性质有：\n1.  分子的乘法性质：$(\\frac{ab}{n}) = (\\frac{a}{n})(\\frac{b}{n})$。\n2.  $(\\frac{2}{n})$ 的值：$(\\frac{2}{n}) = (-1)^{(n^2 - 1)/8}$，当 $n \\equiv 1, 7 \\pmod{8}$ 时值为 $1$，当 $n \\equiv 3, 5 \\pmod{8}$ 时值为 $-1$。\n3.  二次互反律：对于互质的奇整数 $m$ 和 $n$，$(\\frac{m}{n}) = (\\frac{n}{m})(-1)^{\\frac{m-1}{2}\\frac{n-1}{2}}$。符号项 $(-1)^{\\frac{m-1}{2}\\frac{n-1}{2}}$ 仅当 $m$ 和 $n$ 都同余于 $3 \\pmod{4}$ 时为 $-1$，否则为 $1$。\n4.  分子的简化：如果 $a \\equiv b \\pmod{n}$，则 $(\\frac{a}{n}) = (\\frac{b}{n})$。\n5.  完全平方数：如果 $\\gcd(a, n) = 1$，则 $(\\frac{a^2}{n}) = 1$。\n\n让我们开始计算 $(\\frac{38}{105})$。\n\n步骤 1：对分子应用乘法性质。\n$38 = 2 \\times 19$。\n$$\n\\left(\\frac{38}{105}\\right) = \\left(\\frac{2 \\cdot 19}{105}\\right) = \\left(\\frac{2}{105}\\right)\\left(\\frac{19}{105}\\right)\n$$\n\n步骤 2：计算项 $(\\frac{2}{105})$。\n我们需要确定 $105$ 模 $8$ 的值。\n$105 = 13 \\times 8 + 1$，所以 $105 \\equiv 1 \\pmod{8}$。\n根据 $(\\frac{2}{n})$ 的规则，当 $n \\equiv 1 \\pmod{8}$ 时，其值为 $1$。\n$$\n\\left(\\frac{2}{105}\\right) = 1\n$$\n将此代入我们的表达式中得到：\n$$\n\\left(\\frac{38}{105}\\right) = 1 \\cdot \\left(\\frac{19}{105}\\right) = \\left(\\frac{19}{105}\\right)\n$$\n\n步骤 3：对 $(\\frac{19}{105})$ 应用二次互反律。\n我们可以翻转分子和分母，这可能会引入一个符号变化。符号取决于分子和分母模 $4$ 的值。\n$m = 19$, $n = 105$。\n$19 = 4 \\times 4 + 3$，所以 $19 \\equiv 3 \\pmod{4}$。\n$105 = 26 \\times 4 + 1$，所以 $105 \\equiv 1 \\pmod{4}$。\n由于只有一个数（$m=19$）同余于 $3 \\pmod{4}$，符号项为 $(-1)^{\\frac{19-1}{2}\\frac{105-1}{2}} = (-1)^{9 \\cdot 52} = 1$。因此，没有符号变化。\n$$\n\\left(\\frac{19}{105}\\right) = \\left(\\frac{105}{19}\\right)\n$$\n\n步骤 4：通过对分母取模来简化分子。\n我们计算 $105$ 模 $19$。\n$105 = 5 \\times 19 + 10 = 95 + 10$。所以，$105 \\equiv 10 \\pmod{19}$。\n根据简化性质：\n$$\n\\left(\\frac{105}{19}\\right) = \\left(\\frac{10}{19}\\right)\n$$\n\n步骤 5：计算现在简化为求 $(\\frac{10}{19})$。我们再次使用乘法性质。\n$10 = 2 \\times 5$。\n$$\n\\left(\\frac{10}{19}\\right) = \\left(\\frac{2}{19}\\right)\\left(\\frac{5}{19}\\right)\n$$\n\n步骤 6：分别计算两个得到的符号。首先是 $(\\frac{2}{19})$。\n我们需要确定 $19$ 模 $8$ 的值。\n$19 = 2 \\times 8 + 3$，所以 $19 \\equiv 3 \\pmod{8}$。\n根据 $(\\frac{2}{n})$ 的规则，当 $n \\equiv 3 \\pmod{8}$ 时，其值为 $-1$。\n$$\n\\left(\\frac{2}{19}\\right) = -1\n$$\n\n步骤 7：接下来，计算 $(\\frac{5}{19})$。我们再次应用二次互反律。\n$m = 5$, $n = 19$。\n$5 = 1 \\times 4 + 1$，所以 $5 \\equiv 1 \\pmod{4}$。\n$19 = 4 \\times 4 + 3$，所以 $19 \\equiv 3 \\pmod{4}$。\n同样，只有一个数同余于 $3 \\pmod{4}$，所以翻转时没有符号变化。\n$$\n\\left(\\frac{5}{19}\\right) = \\left(\\frac{19}{5}\\right)\n$$\n\n步骤 8：将分子 $19$ 模 $5$ 进行简化。\n$19 = 3 \\times 5 + 4$，所以 $19 \\equiv 4 \\pmod{5}$。\n$$\n\\left(\\frac{19}{5}\\right) = \\left(\\frac{4}{5}\\right)\n$$\n\n步骤 9：计算 $(\\frac{4}{5})$。\n因为 $4 = 2^2$ 是一个完全平方数且 $\\gcd(2, 5) = 1$，其雅可比符号为 $1$。\n$$\n\\left(\\frac{4}{5}\\right) = \\left(\\frac{2^2}{5}\\right) = 1\n$$\n所以，从步骤 7 我们得到 $(\\frac{5}{19}) = 1$。\n\n步骤 10：结合步骤 6 和步骤 9 的结果。\n从步骤 5，我们有 $(\\frac{10}{19}) = (\\frac{2}{19})(\\frac{5}{19})$。\n$$\n\\left(\\frac{10}{19}\\right) = (-1)(1) = -1\n$$\n\n步骤 11：回溯我们的计算以找到最终答案。\n从步骤 4，$(\\frac{105}{19}) = (\\frac{10}{19}) = -1$。\n从步骤 3，$(\\frac{19}{105}) = (\\frac{105}{19}) = -1$。\n从步骤 2，$(\\frac{38}{105}) = (\\frac{19}{105}) = -1$。\n\n因此，雅可比符号的最终值为 $-1$。", "answer": "$$\\boxed{-1}$$", "id": "1441656"}, {"introduction": "掌握了计算方法后，我们需深入探究雅可比符号与勒让德符号之间的关键区别。本练习是一个思想实验，旨在揭示雅可比符号的一个重要特性：符号值为 $1$ 并不保证二次同余式 $x^2 \\equiv a \\pmod n$ 有解 [@problem_id:3027697]。通过解决这个问题，你将更深刻地理解雅可比符号、其对应的勒让德符号因子以及中国剩余定理三者之间的联系。", "problem": "设 $p$ 和 $q$ 是不同的奇素数，且 $n=pq$。对于奇素数 $p$，勒让德符号 $(a/p)$ 的定义为：当且仅当同余式 $x^2\\equiv a \\pmod p$ 有解且 $p\\nmid a$ 时，$(a/p)=1$；当且仅当同余式 $x^2\\equiv a \\pmod p$ 无解且 $p\\nmid a$ 时，$(a/p)=-1$；如果 $p\\mid a$，则 $(a/p)=0$。对于奇数 $n$（其素数分解为 $n=\\prod_{i=1}^k p_i^{e_i}$），雅可比符号 $(a/n)$ 定义为 $(a/n)=\\prod_{i=1}^k (a/p_i)^{e_i}$，对于无平方因子的数 $n=pq$，它简化为 $(a/n)=(a/p)(a/q)$。中国剩余定理（CRT）指出，对于 $\\gcd(p,q)=1$，同余方程组 $x\\equiv x_1\\pmod p$，$x\\equiv x_2\\pmod q$ 对任意给定的 $x_1$ 和 $x_2$ 都有解 $x\\pmod{pq}$。特别地，$x^2\\equiv a\\pmod{pq}$ 有解当且仅当 $x^2\\equiv a\\pmod p$ 和 $x^2\\equiv a\\pmod q$ 都有解。\n\n仅使用这些基本定义和事实，找出一个具体的数对 $(n,a)$，其中 $n=pq$ 且 $p\\equiv q\\equiv 3\\bmod 4$，使得雅可比符号 $(a/n)=1$ 但同余式 $x^2\\equiv a\\pmod n$ 无解。你的选择必须满足对 $p$ 和 $q$ 的模条件，并且你必须识别出尽管 $(a/n)=1$ 但仍导致方程无解的障碍。\n\n哪个选项满足所有这些要求？\n\nA. $n=21$, $a=5$.\n\nB. $n=33$, $a=4$.\n\nC. $n=77$, $a=2$.\n\nD. $n=35$, $a=6$.", "solution": "问题陈述已经过验证，是良构的且科学上合理的，其基础是初等数论的基本原理。\n\n任务是从给定选项中找出一个满足一组特定条件的数对 $(n,a)$。让我们首先分析这些条件，以建立一个明确的评估标准。\n\n条件是：\n1.  $n = pq$，其中 $p$ 和 $q$ 是不同的奇素数。\n2.  $p \\equiv 3 \\pmod 4$ 且 $q \\equiv 3 \\pmod 4$。\n3.  雅可比符号 $(a/n) = 1$。\n4.  同余式 $x^2 \\equiv a \\pmod n$ 无解。\n\n问题提供信息，$x^2 \\equiv a \\pmod n$ 有解当且仅当同余式 $x^2 \\equiv a \\pmod p$ 和 $x^2 \\equiv a \\pmod q$ 都有解。用勒让德符号表示，这意味着 $x^2 \\equiv a \\pmod n$ 有解当且仅当 $(a/p) = 1$ 且 $(a/q) = 1$。注意，勒让德符号要为 $\\pm 1$，必须有 $p \\nmid a$ 和 $q \\nmid a$；如果 $p \\mid a$，则 $(a/p)=0$，同余式 $x^2 \\equiv a \\pmod p$ 变为 $x^2 \\equiv 0 \\pmod p$，其解为 $x=0$。如果对于 $a \\neq 0$ 出现这种情况，那么 $a$ 将是 $p$ 的倍数，而模 $n=pq$ 的可解性问题会变得更加复杂。我们应假设 $\\gcd(a,n)=1$，这对于此类问题是典型的，并且对所有提供的选项都成立。\n\n要求 $x^2 \\equiv a \\pmod n$ 无解，意味着 $(a/p)=1$ 和 $(a/q)=1$ 不会同时成立。因此，$(a/p)$ 或 $(a/q)$ 中至少有一个必须是 $-1$。\n\n对雅可比符号的要求是 $(a/n) = 1$。根据定义 $(a/n) = (a/p)(a/q)$，我们有 $(a/p)(a/q) = 1$。\n\n结合这两个逻辑推论，要满足 $(a/p)(a/q) = 1$ 且至少有一个符号为 $-1$ 的唯一方式是两者都为 $-1$。也就是说，我们必须有：\n$$(\\frac{a}{p}) = -1 \\quad \\text{且} \\quad (\\frac{a}{q}) = -1$$\n这就是问题所指的“障碍”：尽管勒让德符号的乘积为 $1$，从而得到雅可比符号为 $1$，但各个同余式在模素数因子下都不可解，从而阻止了在模合数 $n$ 下存在解。\n\n因此，我们必须找到一个选项 $(n, a)$，使得 $n=pq$，其中 $p, q \\equiv 3 \\pmod 4$，并且 $(a/p) = -1$ 和 $(a/q) = -1$。我们将根据这些标准评估每个选项，通过枚举每个素数因子模下的二次剩余来使用勒让德符号的定义。\n\n**A. $n=21$, $a=5$.**\n首先，我们检查 $n = 21$ 的素数因子。我们有 $n=3 \\times 7$。令 $p=3$ 和 $q=7$。两者都是不同的奇素数。\n我们检查模条件：\n$p=3 \\equiv 3 \\pmod 4$。满足。\n$q=7 \\equiv 3 \\pmod 4$。满足。\n接下来，我们计算勒让德符号 $(5/3)$ 和 $(5/7)$。\n对于 $(5/3)$：$5 \\equiv 2 \\pmod 3$。我们检查 $2$ 是否是模 $3$ 的二次剩余。非零余数为 $1$ 和 $2$。它们的平方是 $1^2 \\equiv 1 \\pmod 3$ 和 $2^2 \\equiv 4 \\equiv 1 \\pmod 3$。模 $3$ 的二次剩余集合是 $\\{1\\}$。因为 $2$ 不在这个集合中，所以 $(2/3) = -1$。因此，$(5/3) = -1$。\n对于 $(5/7)$：我们检查 $5$ 是否是模 $7$ 的二次剩余。模 $7$ 的二次剩余是 $1^2 \\equiv 1$, $2^2 \\equiv 4$, $3^2 \\equiv 9 \\equiv 2$。二次剩余的集合是 $\\{1, 2, 4\\}$。因为 $5$ 不在这个集合中，所以 $(5/7)=-1$。\n$(a/p)=-1$ 和 $(a/q)=-1$ 这两个条件都满足了。\n这意味着雅可比符号 $(5/21) = (5/3)(5/7) = (-1)(-1) = 1$，满足条件3。此外，由于 $(5/3)=-1$，同余式 $x^2 \\equiv 5 \\pmod 3$ 无解，这又意味着 $x^2 \\equiv 5 \\pmod{21}$ 无解，满足条件4。\n这个选项满足所有要求。\n结论：**正确**。\n\n**B. $n=33$, $a=4$.**\n首先，我们检查 $n = 33$ 的素数因子。我们有 $n=3 \\times 11$。令 $p=3$ 和 $q=11$。两者都是不同的奇素数。\n我们检查模条件：\n$p=3 \\equiv 3 \\pmod 4$。满足。\n$q=11 \\equiv 3 \\pmod 4$。满足。\n接下来，我们考察同余式 $x^2 \\equiv 4 \\pmod{33}$。\n这个同余式显然有解，因为 $x=2$ 是一个解 ($2^2 = 4$)。问题要求同余式 $x^2 \\equiv a \\pmod n$ 无解。这个选项不满足这个关键条件。为了完整性，$(4/3) = (1/3) = 1$ 且 $(4/11) = 1$，所以 $(4/33)=1$。这是真二次剩余的情况，而不是伪平方。\n结论：**不正确**。\n\n**C. $n=77$, $a=2$.**\n首先，我们检查 $n = 77$ 的素数因子。我们有 $n=7 \\times 11$。令 $p=7$ 和 $q=11$。两者都是不同的奇素数。\n我们检查模条件：\n$p=7 \\equiv 3 \\pmod 4$。满足。\n$q=11 \\equiv 3 \\pmod 4$。满足。\n接下来，我们计算勒让德符号 $(2/7)$ 和 $(2/11)$。\n对于 $(2/7)$：模 $7$ 的二次剩余是 $\\{1^2, 2^2, 3^2\\} \\pmod 7 = \\{1, 4, 2\\}$。因为 $2$ 在这个集合中，所以 $(2/7)=1$。\n对于 $(2/11)$：模 $11$ 的二次剩余是 $\\{1^2, 2^2, 3^2, 4^2, 5^2\\} \\pmod{11} = \\{1, 4, 9, 16 \\equiv 5, 25 \\equiv 3\\}$。因为 $2$ 不在这个集合中，所以 $(2/11)=-1$。\n雅可比符号是 $(2/77) = (2/7)(2/11) = (1)(-1) = -1$。这不满足 $(a/n)=1$ 的条件。\n结论：**不正确**。\n\n**D. $n=35$, $a=6$.**\n首先，我们检查 $n = 35$ 的素数因子。我们有 $n=5 \\times 7$。令 $p=5$ 和 $q=7$。\n我们检查模条件：\n$p=5 \\equiv 1 \\pmod 4$。\n$q=7 \\equiv 3 \\pmod 4$。\n两个素数因子都必须同余于 $3 \\pmod 4$ 的条件未被满足。因此，这个选项从一开始就是无效的。\n结论：**不正确**。\n\n根据系统性分析，只有选项A满足问题的所有规定条件。", "answer": "$$\\boxed{A}$$", "id": "3027697"}, {"introduction": "理论知识的最终目的是应用于解决实际问题，尤其是在计算数论和密码学等领域。本练习要求你将雅可比符号的所有性质综合起来，设计一个类似于二分GCD算法的高效计算程序 [@problem_id:3027698]。这个任务将理论与实践联系起来，展示了如何将抽象的数学定律转化为快速且实用的代码，从而避免了对模数进行因式分解这一计算成本高昂的步骤。", "problem": "设 $n$ 是一个正奇数，$a$ 是一个任意整数。雅可比符号 $(a/n)$ 是勒让德符号 $(a/p)$ 从奇素数 $p$ 到奇合数 $n$ 的推广。目标是推导、证明并实现一个类似二进制最大公约数 (GCD) 的算法，该算法仅使用二次剩余和互反律的基本性质来计算 $(a/n)$，而无需对 $n$ 进行因式分解。\n\n出发点和约束条件：\n- 仅使用以下基本事实：\n  - 勒让德符号 $(a/p)$（对于奇素数 $p$）和雅可比符号 $(a/n)$（对于奇数 $n$）的定义，以及它们在分子和分母上的乘法性质。\n  - 二次互反律：对于互质的奇整数 $a$ 和 $n$，有 $(a/n)\\,(n/a)=(-1)^{\\frac{(a-1)(n-1)}{4}}$。\n  - 补充定律：对于奇数 $n$，有 $(-1/n)=(-1)^{\\frac{n-1}{2}}$ 和 $(2/n)=(-1)^{\\frac{n^2-1}{8}}$。\n  - 约化性质：$(a/n)=(a \\bmod n\\,/\\,n)$。\n- 设计一个作用于数对 $(a,n)$ 的约化过程，模仿二进制 GCD 方法：\n  - 使用 $(2/n)$ 从分子中重复移除因子 $2$，并更新累积的符号。\n  - 在有利时应用互反律交换 $a$ 和 $n$ 的角色，并根据互反律所蕴含的奇偶性条件更新符号。\n  - 通过模运算约化新的分子，以确保算法的进程。\n- 明确地跟踪符号变化，以便算法维持一个不变量，该不变量将 $(a/n)$ 的当前值表示为累积符号与一个待处理的约化符号的乘积。\n- 以一个明确定义的规则终止，返回集合 $\\{-1,0,1\\}$ 中的一个整数：\n  - 如果在终止时 $\\gcd(a,n)1$，结果必须是 $0$。\n  - 如果分母已被约化为 $1$，结果必须是累积的符号。\n- 不要使用 $n$ 的因式分解或任何非基本的“黑箱”捷径。\n\n实现一个完整、可运行的程序，该程序：\n- 对每个测试用例，使用上述设计计算 $(a/n)$。\n- 仅使用整数算术。\n- 生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n\n测试套件：\n- 案例 1：$a=5, n=11$。\n- 案例 2：$a=2, n=21$。\n- 案例 3：$a=10, n=21$。\n- 案例 4：$a=0, n=33$。\n- 案例 5：$a=7, n=15$。\n- 案例 6：$a=-3, n=35$。\n- 案例 7：$a=21, n=35$。\n- 案例 8：$a=1234567, n=1$。\n- 案例 9：$a=5, n=289$。\n- 案例 10：$a=3, n=11$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[r_1,r_2,\\dots,r_{10}]$），其中每个 $r_i$ 是相应案例的雅可比符号在 $\\{-1,0,1\\}$ 中的整数值。", "solution": "用户希望解决一个给定的问题。\n该问题已经过验证，是合理的。\n\n该问题要求推导并实现一个算法，用于计算整数 $a$ 和正奇数 $n$ 的雅可比符号 $(a/n)$。该算法的设计风格必须类似于二进制 GCD 算法，并且必须仅依赖于一组给定的雅可比符号基本性质，而无需对 $n$ 进行因式分解。\n\n此类算法的核心原理是在一个状态上定义一组变换，这些变换在每一步都降低问题的复杂性，同时保持最终结果不变。对于雅可比符号 $(a/n)$，状态可以由一个三元组 $(a, n, s)$ 表示，其中要计算的量是 $s \\cdot (a/n)$。算法从一个初始状态开始，迭代应用变换规则，直到达到一个其值已知的终止状态。\n\n初始状态为 $(a_0, n_0, 1)$，其中 $a_0$ 和 $n_0$ 是问题的输入。我们想要找到 $1 \\cdot (a_0/n_0)$ 的值。算法流程如下：\n\n1.  **基本情况：** 定义规定，对于任意整数 $a$，$(a/1)=1$。因此，如果 $n=1$，结果为 $1$。此外，根据定义，如果 $\\gcd(a,n) > 1$，则 $(a/n) = 0$。处理这种情况的方法是观察到，如果算法状态演变为 $a$ 变为 $0$ 而 $n>1$，这意味着约简序列中较早的数对 $(a', n')$ 满足 $n'$ 是 $a'$ 的一个因子，这会保持最大公约数不变。因此，原始的 $\\gcd(a_0, n_0)$ 必然大于 $1$。\n\n2.  **处理负分子：** 问题陈述中包含 $a$ 的负值。我们可以使用关于 $(-1/n)$ 的补充定律来处理。利用乘法性质 $(ab/n)=(a/n)(b/n)$，我们可以写出 $(-|a|/n) = (-1/n)(|a|/n)$。该定律指出 $(-1/n) = (-1)^{\\frac{n-1}{2}}$。如果 $(n-1)/2$ 是奇数（即 $n \\equiv 3 \\pmod 4$），这个因子是 $-1$；如果 $(n-1)/2$ 是偶数（即 $n \\equiv 1 \\pmod 4$），这个因子是 $1$。因此，如果 $a$ 是负数，我们将其变为正数，并在 $n \\equiv 3 \\pmod 4$ 时将累积符号 $s$ 乘以 $-1$。\n\n3.  **约化分子：** 性质 $(a/n) = (a \\bmod n\\,/\\,n)$ 允许我们减小 $a$ 的大小。我们可以在任何时候用 $a \\bmod n$ 替换 $a$。这一步对于确保算法终止至关重要，因为它减小了所涉及数的大小。\n\n4.  **提取因子 2：** 这一步赋予了算法“二进制 GCD”的特性。任何偶数分子 $a$ 都可以写成 $a=2^k \\cdot a'$，其中 $a'$ 是奇数。利用乘法性质，$(a/n) = (2^k a'/n) = (2/n)^k (a'/n)$。对于每个因子 $2$，我们将累积符号 $s$ 乘以 $(2/n)$。第二补充定律给出 $(2/n) = (-1)^{\\frac{n^2-1}{8}}$。如果 $(n^2-1)/8$ 是奇数（即 $n \\equiv 3, 5 \\pmod 8$），这个因子是 $-1$；否则（即 $n \\equiv 1, 7 \\pmod 8$），这个因子是 $1$。因此，我们可以从 $a$ 中移除所有因子 $2$，计算它们的数量（假设为 $k$），如果 $k$ 是奇数，并且 $n \\equiv 3, 5 \\pmod 8$，则将 $s$ 乘以 $-1$。\n\n5.  **二次互反律：** 经过前面的步骤，$a$ 是一个小于 $n$ 的正奇数。如果 $a=1$，则符号 $(1/n)=1$，其值为累积符号 $s$。如果 $a>1$，我们应用二次互反律：$(a/n)(n/a) = (-1)^{\\frac{(a-1)(n-1)}{4}}$。这允许我们交换分子和分母：$(a/n) = (n/a) \\cdot (-1)^{\\frac{(a-1)(n-1)}{4}}$。当且仅当 $(a-1)/2$ 和 $(n-1)/2$ 都为奇数时，指数为奇数，这意味着 $a \\equiv 3 \\pmod 4$ 且 $n \\equiv 3 \\pmod 4$。因此，如果 $a$ 和 $n$ 都与 $3 \\pmod 4$ 同余，我们将 $s$ 乘以 $-1$。然后我们交换 $a$ 和 $n$。新问题是计算 $(n_{old}/a_{old})$，我们可以再次使用模性质将其约化为：$(n_{old} \\bmod a_{old} \\,/\\, a_{old})$。\n\n完整的算法在一个循环中结合了这些步骤，该循环会终止，因为每次应用互反律和约化后，整数对 $(a,n)$ 的大小都会减小，这与欧几里得算法类似。\n\n算法结构如下：\n- 初始化符号 $s=1$。\n- 处理负数 $a$ 并应用初始约化 $a \\leftarrow a \\bmod n$。\n- 进入一个只要 $a \\neq 0$ 就持续的循环：\n    - 从 $a$ 中移除所有因子 $2$，并根据关于 $(2/n)$ 的定律更新 $s$。\n    - 此后，$a$ 是奇数。如果 $a=1$，循环终止，答案为 $s$。\n    - 应用互反律交换 $a$ 和 $n$，并在必要时更新 $s$。\n    - 将新的 $a$ 对新的 $n$ 取模进行约化。\n- 如果循环因 $a$ 变为 $0$ 而终止，则结果为 $0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Jacobi symbol for a list of test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (5, 11),\n        (2, 21),\n        (10, 21),\n        (0, 33),\n        (7, 15),\n        (-3, 35),\n        (21, 35),\n        (1234567, 1),\n        (5, 289),\n        (3, 11),\n    ]\n\n    def jacobi(a, n):\n        \"\"\"\n        Computes the Jacobi symbol (a/n) using a binary GCD-like algorithm.\n\n        Args:\n            a: An arbitrary integer.\n            n: A positive odd integer.\n        \n        Returns:\n            An integer in {-1, 0, 1}.\n        \"\"\"\n        # Per the problem statement, n is a positive odd integer.\n        # Rule: (a/1) = 1\n        if n == 1:\n            return 1\n\n        # State initialization: the desired value is s * (a/n)\n        s = 1\n\n        # Step 1: Handle negative a using (-1/n) = (-1)^((n-1)/2)\n        if a  0:\n            a = -a\n            # Sign flips if n = 3 (mod 4)\n            if (n  3) == 3:\n                s = -s\n        \n        # Step 2: Initial reduction\n        a %= n\n\n        # Main loop: reduces (a,n) until a is 0 or 1\n        while a != 0:\n            # Step 3: Remove factors of 2 from a, using (2/n) = (-1)^((n^2-1)/8)\n            # k is the number of factors of 2 in a.\n            # (a  -a) isolates the lowest set bit. Its bit_length - 1 is the number of trailing zeros.\n            k = (a  -a).bit_length() - 1\n            a >>= k\n            \n            # If k is odd, update sign based on n mod 8.\n            if (k  1):\n                n_mod_8 = n  7\n                if n_mod_8 == 3 or n_mod_8 == 5:\n                    s = -s\n            \n            # Base case for termination\n            if a == 1:\n                return s\n\n            # Step 4: Apply quadratic reciprocity: (a/n) = (n/a) * (-1)^(((a-1)/2)*((n-1)/2))\n            # Sign flips if a = 3 (mod 4) and n = 3 (mod 4)\n            if (a  3) == 3 and (n  3) == 3:\n                s = -s\n            \n            # Step 5: Swap a and n, and reduce. This ensures progress.\n            a, n = n, a\n            a %= n\n        \n        # If loop terminates, a became 0, which implies gcd(original_a, original_n) > 1.\n        return 0\n\n    results = [jacobi(a, n) for a, n in test_cases]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3027698"}]}