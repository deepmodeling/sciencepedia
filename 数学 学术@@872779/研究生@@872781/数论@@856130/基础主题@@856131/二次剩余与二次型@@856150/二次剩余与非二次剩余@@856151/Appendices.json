{"hands_on_practices": [{"introduction": "掌握二次剩余理论始于亲手计算。本练习要求你为一系列素数找出最小的二次非剩余。通过系统地检验小整数，你将获得应用勒让德符号基本性质（尤其是二次互反律）的实践经验，而二次互反律正是该理论的基石。", "problem": "设 $p$ 为一个奇素数，且对于整数 $a$，勒让德符号 $(\\frac{a}{p})$ 定义为：如果 $a$ 是模 $p$ 的二次剩余，则 $(\\frac{a}{p}) = 1$；如果 $a$ 是模 $p$ 的二次非剩余，则 $(\\frac{a}{p}) = -1$；如果 $p$ 整除 $a$，则 $(\\frac{a}{p}) = 0$。定义 $n(p)$ 为满足 $(\\frac{n}{p}) = -1$ 的最小正整数 $n \\geq 2$。仅使用勒让德符号的基本性质，包括欧拉判别法和二次互反律，通过从 $a=2$ 开始对连续整数 $a$ 直接计算 $(\\frac{a}{p})$，来为集合 $P = \\{3, 5, 7, 11, 13, 17, 19, 23, 29, 31\\}$ 中的每个素数 $p$ 确定一个明確的数值界限 $b_{p}$，使得 $n(p) \\leq b_{p}$。然后计算单个数值 $B = \\max_{p \\in P} b_{p}$。请以精确整数形式给出您的最终 $B$ 值；无需四舍五入。", "solution": "该问题要求确定给定素数集合 $P = \\{3, 5, 7, 11, 13, 17, 19, 23, 29, 31\\}$ 中每个素数 $p$ 的最小正二次非剩余 $n(p)$（其中 $n(p) \\ge 2$），并找出这些值中的最大值 $B$。\n\n我们将对每个 $p \\in P$ 逐一计算 $n(p)$，方法是从整数 $a=2$ 开始，依次检验勒让德符号 $(\\frac{a}{p})$ 的值，直到找到第一个使得 $(\\frac{a}{p}) = -1$ 的 $a$。这个 $a$ 就是 $n(p)$。计算中将使用二次互反律及其补充定律。\n\n*   **对于 $p=3$**：\n    检验 $a=2$：$(\\frac{2}{3}) = (-1)^{(3^2-1)/8} = (-1)^1 = -1$。因此，$n(3) = 2$。\n\n*   **对于 $p=5$**：\n    检验 $a=2$：$(\\frac{2}{5}) = (-1)^{(5^2-1)/8} = (-1)^3 = -1$。因此，$n(5) = 2$。\n\n*   **对于 $p=7$**：\n    检验 $a=2$：$(\\frac{2}{7}) = (-1)^{(7^2-1)/8} = (-1)^6 = 1$。\n    检验 $a=3$：根据二次互反律，$(\\frac{3}{7}) = -(\\frac{7}{3}) = -(\\frac{1}{3}) = -1$。因此，$n(7) = 3$。\n\n*   **对于 $p=11$**：\n    检验 $a=2$：$(\\frac{2}{11}) = (-1)^{(11^2-1)/8} = (-1)^{15} = -1$。因此，$n(11) = 2$。\n\n*   **对于 $p=13$**：\n    检验 $a=2$：$(\\frac{2}{13}) = (-1)^{(13^2-1)/8} = (-1)^{21} = -1$。因此，$n(13) = 2$。\n\n*   **对于 $p=17$**：\n    检验 $a=2$：$(\\frac{2}{17}) = (-1)^{(17^2-1)/8} = (-1)^{36} = 1$。\n    检验 $a=3$：根据二次互反律，$(\\frac{3}{17}) = (\\frac{17}{3}) = (\\frac{2}{3}) = -1$。因此，$n(17) = 3$。\n\n*   **对于 $p=19$**：\n    检验 $a=2$：$(\\frac{2}{19}) = (-1)^{(19^2-1)/8} = (-1)^{45} = -1$。因此，$n(19) = 2$。\n\n*   **对于 $p=23$**：\n    检验 $a=2$：$(\\frac{2}{23}) = (-1)^{(23^2-1)/8} = (-1)^{66} = 1$。\n    检验 $a=3$：根据二次互反律，$(\\frac{3}{23}) = -(\\frac{23}{3}) = -(\\frac{2}{3}) = -(-1) = 1$。\n    检验 $a=4$：$(\\frac{4}{23}) = 1$。\n    检验 $a=5$：根据二次互反律，$(\\frac{5}{23}) = (\\frac{23}{5}) = (\\frac{3}{5}) = -1$。因此，$n(23) = 5$。\n\n*   **对于 $p=29$**：\n    检验 $a=2$：$(\\frac{2}{29}) = (-1)^{(29^2-1)/8} = (-1)^{105} = -1$。因此，$n(29) = 2$。\n\n*   **对于 $p=31$**：\n    检验 $a=2$：$(\\frac{2}{31}) = (-1)^{(31^2-1)/8} = (-1)^{120} = 1$。\n    检验 $a=3$：根据二次互反律，$(\\frac{3}{31}) = -(\\frac{31}{3}) = -(\\frac{1}{3}) = -1$。因此，$n(31) = 3$。\n\n**总结与最终计算**：\n我们得到的最小二次非剩余值 $n(p)$ 的集合为：\n$\\{n(3)=2, n(5)=2, n(7)=3, n(11)=2, n(13)=2, n(17)=3, n(19)=2, n(23)=5, n(29)=2, n(31)=3\\}$。\n这些值中的最大值是 $5$。\n因此，$B = \\max_{p \\in P} n(p) = 5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3021794"}, {"introduction": "虽然二次剩余理论在素数模下最为简洁，但许多应用都涉及合数。本练习旨在搭建从素数模到合数模的桥梁，要求你确定二次同余方程在模 $n=pq$ 意义下的解的个数。通过结合中国剩余定理和对勒让德符号的理解，你将发现模素数的解结构如何决定了总解数。[@problem_id:3021799]", "problem": "设 $p$ 和 $q$ 是不同的奇素数，且令 $n = pq$。对于 $a \\in \\mathbb{Z}$，考虑同余方程 $x^{2} \\equiv a \\pmod{n}$。从模奇素数的二次剩余的定义和中国剩余定理 (CRT) 出发，推导在以下两种情况下，同余方程 $x^{2} \\equiv a \\pmod{n}$ 在 $\\mathbb{Z}/n\\mathbb{Z}$ 中解 $x$ 的确切数量：\n\n- 情况 (i)：$\\gcd(a,n) = 1$（即，$a$ 是模 $n$ 的一个单位）。\n- 情况 (ii)：$p \\mid a$ 且 $q \\nmid a$。\n\n你的推导必须是明确且自洽的，从以下基本事实出发：对于一个奇素数 $r$，同余方程 $x^{2} \\equiv b \\pmod{r}$ 在 $\\mathbb{Z}/r\\mathbb{Z}$ 中有零个、一个或两个解，这分别取决于 $b \\equiv 0 \\pmod{r}$、$b$ 是模 $r$ 的二次剩余，还是 $b$ 是模 $r$ 的二次非剩余；以及中国剩余定理 (CRT) 确定了 $\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z} \\times \\mathbb{Z}/q\\mathbb{Z}$。用勒让德符号 $\\left( \\frac{a}{p} \\right)$ 和 $\\left( \\frac{a}{q} \\right)$ 以闭合形式表示你的最终答案。不需要数值近似。", "solution": "问题要求在 $a \\in \\mathbb{Z}$ 的两种不同条件下，求解同余方程 $x^2 \\equiv a \\pmod{n}$ 的解的数量，其中 $n=pq$，$p$ 和 $q$ 是不同的奇素数。推导将基于指定的基本原理：中国剩余定理 (CRT) 和模奇素数的二次剩余的性质。\n\n令 $N$ 表示解 $x \\in \\mathbb{Z}/n\\mathbb{Z}$ 的数量。同余方程 $x^2 \\equiv a \\pmod{n}$ 等价于以下联立同余方程组：\n$$\n\\begin{cases}\nx^2 \\equiv a \\pmod{p} \\\\\nx^2 \\equiv a \\pmod{q}\n\\end{cases}\n$$\n中国剩余定理建立了一个环同构 $\\mathbb{Z}/n\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z} \\times \\mathbb{Z}/q\\mathbb{Z}$。这意味着对于每一对解 $(x_p, x_q)$，其中 $x_p$ 是第一个同余方程的解，$x_q$ 是第二个同余方程的解，都存在一个唯一的解 $x \\pmod{n}$ 同时满足两者。因此，总解数 $N$ 是每个单独同余方程解数的乘积。设 $N_p$ 是 $x^2 \\equiv a \\pmod{p}$ 的解数，$N_q$ 是 $x^2 \\equiv a \\pmod{q}$ 的解数。则 $N = N_p \\times N_q$。\n\n我们已知对于奇素数 $r$，$x^2 \\equiv b \\pmod{r}$ 的解数规则。这个数量可以用勒让德符号 $\\left(\\frac{b}{r}\\right)$ 方便地表示。勒让德符号定义为：\n$$\n\\left(\\frac{b}{r}\\right) =\n\\begin{cases}\n1  &\\text{如果 } b \\text{ 是模 } r \\text{ 的二次剩余且 } r \\nmid b \\\\\n-1 &\\text{如果 } b \\text{ 是模 } r \\text{ 的二次非剩余} \\\\\n0  &\\text{如果 } r \\mid b\n\\end{cases}\n$$\n$x^2 \\equiv b \\pmod{r}$ 的解数恰好是 $1 + \\left(\\frac{b}{r}\\right)$。这个公式对所有三种情况都成立：\n- 如果 $b$ 是模 $r$ 的二次剩余，有 $2$ 个解，且 $1 + \\left(\\frac{b}{r}\\right) = 1 + 1 = 2$。\n- 如果 $b$ 是模 $r$ 的二次非剩余，有 $0$ 个解，且 $1 + \\left(\\frac{b}{r}\\right) = 1 + (-1) = 0$。\n- 如果 $r \\mid b$，有 $1$ 个解 ($x \\equiv 0 \\pmod{r}$)，且 $1 + \\left(\\frac{b}{r}\\right) = 1 + 0 = 1$。\n\n将此应用于我们的系统，我们得到 $N_p = 1 + \\left(\\frac{a}{p}\\right)$ 和 $N_q = 1 + \\left(\\frac{a}{q}\\right)$。\n因此，$x^2 \\equiv a \\pmod{n}$ 的总解数由以下通用公式给出：\n$$\nN = \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right)\n$$\n我们现在使用这个公式分析指定的两种情况。\n\n情况 (i)：$\\gcd(a, n) = 1$。\n条件 $\\gcd(a, n) = 1$ 等价于 $\\gcd(a, pq) = 1$。因为 $p$ 和 $q$ 是素数，这意味着 $p \\nmid a$ 且 $q \\nmid a$。\n因此，$a \\not\\equiv 0 \\pmod{p}$ 且 $a \\not\\equiv 0 \\pmod{q}$。\n这意味着勒让德符号 $\\left(\\frac{a}{p}\\right)$ 和 $\\left(\\frac{a}{q}\\right)$ 不能为 $0$；它们必须是 $1$ 或 $-1$。\n解数 $N$ 由我们的通用公式直接给出。不需要进一步简化，因为这个表达式根据 $a$ 相对于 $p$ 和 $q$ 的二次特征提供了确切的解数。\n解的数量为 $N = \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right)$。\n例如，如果 $a$ 同时是模 $p$ 和模 $q$ 的二次剩余，则 $\\left(\\frac{a}{p}\\right) = 1$ 且 $\\left(\\frac{a}{q}\\right) = 1$，所以 $N = (1+1)(1+1) = 4$。如果 $a$ 是模 $p$ 或模 $q$（或两者）的二次非剩余，那么至少有一个因子是 $1-1=0$，使得 $N=0$。\n\n情况 (ii)：$p \\mid a$ 且 $q \\nmid a$。\n我们再次使用 $N$ 的通用公式。\n条件 $p \\mid a$ 表示 $a \\equiv 0 \\pmod{p}$。根据勒让德符号的定义，这意味着 $\\left(\\frac{a}{p}\\right) = 0$。\n$x^2 \\equiv a \\pmod{p}$ 的解数为 $N_p = 1 + \\left(\\frac{a}{p}\\right) = 1 + 0 = 1$。这对应于唯一的解 $x \\equiv 0 \\pmod{p}$。\n条件 $q \\nmid a$ 表示 $a \\not\\equiv 0 \\pmod{q}$。因此，勒让德符号 $\\left(\\frac{a}{q}\\right)$ 是 $1$ 或 $-1$。\n$x^2 \\equiv a \\pmod{q}$ 的解数为 $N_q = 1 + \\left(\\frac{a}{q}\\right)$。如果 $a$ 是模 $q$ 的二次剩余，此值为 $2$；如果 $a$ 是模 $q$ 的二次非剩余，则为 $0$。\n总解数是乘积 $N = N_p \\times N_q$。\n代入 $N_p$ 和 $N_q$ 的值：\n$$\nN = 1 \\times \\left(1 + \\left(\\frac{a}{q}\\right)\\right) = 1 + \\left(\\frac{a}{q}\\right)\n$$\n这是这种情况下解数的最终闭合形式表达式。如果 $\\left(\\frac{a}{q}\\right) = 1$，解的数量为 $2$；如果 $\\left(\\frac{a}{q}\\right) = -1$，解的数量为 $0$。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\left(1 + \\left(\\frac{a}{p}\\right)\\right) \\left(1 + \\left(\\frac{a}{q}\\right)\\right)  1 + \\left(\\frac{a}{q}\\right) \\end{pmatrix}}\n$$", "id": "3021799"}, {"introduction": "除了判断平方根是否存在，一个核心挑战是实际计算出它。这个高级练习将引导你推导并实现 Cipolla 算法，这是一种在 $\\mathbb{F}_p$ 中寻找平方根的优美而高效的方法。你将看到二次非剩余的概念如何被创造性地用于构建一个更大的域 $\\mathbb{F}_{p^2}$，在这个域中，通过简单的幂运算，问题便迎刃而解。[@problem_id:3021789]", "problem": "设 $p$ 是一个奇素数，并用 $\\mathbb{F}_{p}$ 表示包含 $p$ 个元素的有限域。如果存在 $x \\in \\mathbb{F}_{p}$ 使得 $x^{2} \\equiv a \\ (\\mathrm{mod}\\ p)$，则称元素 $a \\in \\mathbb{F}_{p}$ 为模 $p$ 的二次剩余。对于 $a \\in \\mathbb{F}_{p}^{\\times}$，勒让德符号 $\\left( \\frac{a}{p} \\right)$ 的定义为：如果 $a$ 是二次剩余，则 $\\left( \\frac{a}{p} \\right) = 1$，否则 $\\left( \\frac{a}{p} \\right) = -1$。此外，定义 $\\left( \\frac{0}{p} \\right) = 0$。欧拉判别法断言，对于 $a \\in \\mathbb{F}_{p}^{\\times}$，有 $a^{(p-1)/2} \\equiv \\left( \\frac{a}{p} \\right) \\ (\\mathrm{mod}\\ p)$。\n\n从有限域、二次剩余、欧拉判别法和弗罗贝尼乌斯自同态的基本性质出发，推导一个算法。当 $a$ 是模 $p$ 的二次剩余时，该算法通过在二次扩域 $\\mathbb{F}_{p^2}$ 中进行运算来计算 $a$ 的平方根。该扩域 $\\mathbb{F}_{p^2}$ 是通过在 $\\mathbb{F}_{p}$ 上添加一个不可约二次多项式的根而构造的。你的推导必须从核心定义和定律开始，进而得出一个完整且逻辑上完备的方法，该方法将 $\\mathbb{F}_{p}$ 中的平方根提取问题转化为 $\\mathbb{F}_{p^2}$ 内的幂运算。你必须完全依据特征为 $p$ 的域论基本原理，包括弗罗贝尼乌斯自同态在 $\\mathbb{F}_{p^2}$ 上的作用，来证明你的方法的正确性，并论证当 $a$ 是二次剩余时，为何输出结果落在 $\\mathbb{F}_{p}$ 中。\n\n在 $\\mathbb{Z}/p\\mathbb{Z}$ 算术的标准位复杂度模型下，分析算法的期望运行时间，并通过量化寻找合适的二次非剩余所需的期望尝试次数以及在 $\\mathbb{F}_{p^2}$ 中进行幂运算的成本，证明该算法的期望运行时间是 $\\log p$ 的多项式时间。\n\n然后将推导出的算法实现为一个程序。该程序必须：\n- 程序不接受任何输入，并使用以下固定的 $(a,p)$ 对（其中 $p$ 为奇素数）作为测试集：\n  1. $(0,3)$，\n  2. $(2,3)$，\n  3. $(10,13)$，\n  4. $(2,13)$，\n  5. $(643499475,1000000007)$，\n  6. $(5,11)$，\n  7. $(3,11)$。\n- 对于每个测试用例，如果存在模 $p$ 的平方根，则计算其中一个根 $r \\in \\{0,1,\\dots,p-1\\}$。当 $a \\neq 0$ 时，输出两个根 $r$ 和 $p-r$ 中较小的一个。如果 $\\mathbb{F}_{p}$ 中不存在平方根，则输出 $-1$。对于 $a=0$ 的情况，输出 $0$。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，顺序与测试集相同，且不含空格。例如，格式必须类似于“[r_1,r_2,\\dots,r_7]”，其中每个 $r_i$ 是第 $i$ 个测试用例的整数结果。\n\n你的推理必须避免启发式捷径，且必须基于所述的定义和性质基础。不涉及任何物理量，也没有角度单位。测试集中的所有数值答案均为整数。最终程序的输出必须严格符合上述指定的单行格式。", "solution": "本解法推导并实现了 Cipolla 算法，用于在有限域 $\\mathbb{F}_{p}$（其中 $p$ 为奇素数）中计算平方根。该方法基于在二次扩域 $\\mathbb{F}_{p^2}$ 中的运算。\n\n首先，判断 $a \\in \\mathbb{F}_p$ 的平方根是否存在。若 $a=0$，其唯一平方根为 $x=0$。若 $a \\in \\mathbb{F}_p^\\times$，其平方根存在的充要条件是 $a$ 为模 $p$ 的二次剩余。这可通过欧拉判别法检验：若 $a^{(p-1)/2} \\equiv 1 \\pmod p$，则 $a$ 是二次剩余；若 $a^{(p-1)/2} \\equiv -1 \\pmod p$，则 $a$ 是二次非剩余，无平方根。\n\n当 $a$ 是一个非零二次剩余时，我们按以下步骤计算其平方根。\n\n**1. 算法推导**\n\nCipolla 算法的核心思想是在一个二次扩域 $\\mathbb{F}_{p^2}$ 中找到一个平方为 $a$ 的元素，并证明该元素实际上位于基域 $\\mathbb{F}_p$ 中。\n\n**1.1. 构造扩域 $\\mathbb{F}_{p^2}$**\n二次扩域 $\\mathbb{F}_{p^2}$ 可以构造为商环 $\\mathbb{F}_p[x] / (f(x))$，其中 $f(x)$ 是 $\\mathbb{F}_p$ 上的一个不可约二次多项式。此类多项式的一个简单选择是 $f(x) = x^2 - n$，其中 $n$ 是 $\\mathbb{F}_p$ 中的一个二次非剩余。如果 $x^2-n$ 在 $\\mathbb{F}_p$ 中没有根，则其不可约性得到保证，这当且仅当 $n$ 在 $\\mathbb{F}_p$ 中不是一个平方数，即 $n$ 是二次非剩余。我们将 $\\mathbb{F}_{p^2}$ 表示为元素集合 $\\{u + v\\omega \\mid u, v \\in \\mathbb{F}_p\\}$，其中 $\\omega$ 是 $x^2-n$ 的一个形式根，因此 $\\omega^2 = n$。\n\n算法首先找到一个元素 $t \\in \\mathbb{F}_p$，使得 $n = t^2 - a$ 是一个二次非剩余。这样的 $t$ 保证存在，并且可以通过随机选择 $t$ 的值并使用欧拉判别法检验 $\\left(\\frac{t^2-a}{p}\\right) = -1$ 是否成立来高效地找到。在 $n = t^2 - a$ 是二次非剩余的情况下，我们构造 $\\mathbb{F}_{p^2} \\cong \\mathbb{F}_p[x] / (x^2 - n)$。\n\n**1.2. 平方根公式**\n该算法断言，$a$ 的一个平方根由 $\\mathbb{F}_{p^2}$ 中的元素 $x = (t + \\omega)^{(p+1)/2}$ 给出。我们必须证明两件事：首先，$x^2 = a$；其次，$x \\in \\mathbb{F}_p$。\n\n**证明 $x^2 = a$：**\n我们计算 $x^2$：\n$$x^2 = \\left((t + \\omega)^{(p+1)/2}\\right)^2 = (t + \\omega)^{p+1} = (t + \\omega)^p (t + \\omega)$$\n为计算 $(t + \\omega)^p$，我们使用特征为 $p$ 的域中弗罗贝尼乌斯自同态 $\\phi(z) = z^p$ 的性质。对于任意 $u, v \\in \\mathbb{F}_p$，我们有 $(u+v)^p = u^p + v^p$。由于 $\\mathbb{F}_p$ 的元素被弗罗贝尼乌斯映射固定（根据费马小定理，$u^p=u$），我们有：\n$$(t + \\omega)^p = t^p + \\omega^p = t + \\omega^p$$\n现在我们必须计算 $\\omega^p$。我们知道 $\\omega^2 = n$。\n$$\\omega^p = \\omega \\cdot \\omega^{p-1} = \\omega \\cdot (\\omega^2)^{(p-1)/2} = \\omega \\cdot n^{(p-1)/2}$$\n根据我们对 $n=t^2-a$ 的选择，它是一个模 $p$ 的二次非剩余。因此，根据欧拉判别法，$n^{(p-1)/2} \\equiv -1 \\pmod p$。将此代回，我们得到 $\\omega^p = \\omega \\cdot (-1) = -\\omega$。\n因此，弗罗贝尼乌斯自同态对我们元素的作用是 $(t + \\omega)^p = t - \\omega$。\n现在我们可以完成 $x^2$ 的计算：\n$$x^2 = (t - \\omega)(t + \\omega) = t^2 - \\omega^2$$\n根据 $\\omega$ 的定义，我们有 $\\omega^2 = n = t^2 - a$。\n$$x^2 = t^2 - (t^2 - a) = a$$\n这证明了 $x = (t + \\omega)^{(p+1)/2}$ 确实是 $a$ 在域 $\\mathbb{F}_{p^2}$ 中的一个平方根。\n\n**证明 $x \\in \\mathbb{F}_p$：**\n扩域 $\\mathbb{F}_{p^2}$ 中的一个元素 $z$ 属于基域 $\\mathbb{F}_p$ 的充要条件是它被弗罗贝尼乌斯自同态固定，即 $z^p = z$。让我们计算 $x^p$：\n$$x^p = \\left((t + \\omega)^{(p+1)/2}\\right)^p = ((t+\\omega)^p)^{(p+1)/2}$$\n我们已经证明了 $(t+\\omega)^p = t - \\omega$。所以，\n$$x^p = (t - \\omega)^{(p+1)/2}$$\n为证明它等于 $x$，考虑到 $(t - \\omega)(t + \\omega) = t^2 - \\omega^2 = a$。因此，$t-\\omega = a(t+\\omega)^{-1}$。\n$$x^p = \\left(a(t+\\omega)^{-1}\\right)^{(p+1)/2} = a^{(p+1)/2} \\cdot \\left((t+\\omega)^{-1}\\right)^{(p+1)/2} = a^{(p+1)/2} \\cdot \\left((t+\\omega)^{(p+1)/2}\\right)^{-1} = a^{(p+1)/2} \\cdot x^{-1}$$\n我们有 $a^{(p+1)/2} = a \\cdot a^{(p-1)/2}$。由于 $a$ 是一个二次剩余，$a^{(p-1)/2} = 1$。所以，$a^{(p+1)/2} = a$。这得到 $x^p = a \\cdot x^{-1}$。两边乘以 $x$，我们得到 $x^{p+1} = a$。\n这并非我们直接需要的结果。让我们使用一种更直接的方法。我们已经证明了 $x^2=a$。因此，$x^{p-1} = (x^2)^{(p-1)/2} = a^{(p-1)/2}$。由于 $a$ 是二次剩余，$a^{(p-1)/2}=1$。因此，$x^{p-1}=1$。两边乘以 $x$（因为 $a \\neq 0$，所以 $x \\neq 0$），我们得到 $x^p = x$。这证实了 $x$ 位于基域 $\\mathbb{F}_p$ 中。\n\n因此，该算法正确地计算出 $a$ 在 $\\mathbb{F}_p$ 中的一个平方根。另一个根是 $-x \\equiv p-x \\pmod p$。\n\n**2. 复杂度分析**\n\n该算法包含三个主要步骤：\n1.  检查 $a$ 是否为二次剩余。\n2.  寻找一个元素 $t$ 使得 $n = t^2 - a$ 是一个二次非剩余。\n3.  在 $\\mathbb{F}_{p^2}$ 中执行幂运算。\n\n复杂度在标准位复杂度模型中分析，其中对大小为 $p$ 的整数进行算术运算的时间是 $\\log p$ 的多项式。一次模 $p$ 的乘法或除法耗时 $O((\\log p)^2)$。\n\n**步骤 1：** 通过 $a^{(p-1)/2} \\pmod p$ 来检验 $\\left(\\frac{a}{p}\\right)$ 需要进行模幂运算，这可以在 $O(\\log((p-1)/2)) = O(\\log p)$ 次模乘法内完成。此步骤的总时间为 $O((\\log p)^3)$。\n\n**步骤 2：** 寻找 $t$。我们遍历 $t=1, 2, 3, \\dots$，计算 $n=t^2-a$，并使用欧拉判别法检查 $n$ 是否为非剩余。使 $t^2-a$ 为二次非剩余的 $t \\in \\mathbb{F}_p$ 的值的数量是 $(p-1)/2$。这意味着随机选择的 $t$ 成功的概率是 $(p-1)/(2p) \\approx 1/2$。因此，找到一个合适的 $t$ 的期望尝试次数约为 2 次。\n每次尝试涉及一次平方、一次减法和一次模幂运算来检验 $n$。每次尝试的成本主要由幂运算决定，耗时 $O((\\log p)^3)$。因此，该步骤的期望时间是 $O((\\log p)^3)$。\n\n**步骤 3：** 在 $\\mathbb{F}_{p^2}$ 中进行幂运算。我们计算 $x=(t+\\omega)^{(p+1)/2}$。这是在 $\\mathbb{F}_{p^2}$ 中的一次模幂运算，指数大小为 $O(p)$，需要 $O(\\log p)$ 次 $\\mathbb{F}_{p^2}$ 中的乘法。\n$\\mathbb{F}_{p^2}$ 中的一次算术运算比 $\\mathbb{F}_p$ 中的成本更高。两个元素 $(u_1 + v_1\\omega)$ 和 $(u_2 + v_2\\omega)$ 的乘法是：\n$(u_1u_2 + v_1v_2n) + (u_1v_2 + u_2v_1)\\omega$。\n这需要 $\\mathbb{F}_p$ 中的 4 次乘法和 2 次加法（或使用 Karatsuba 方法的 3 次乘法）。一次 $\\mathbb{F}_{p^2}$ 乘法的成本是 $O((\\log p)^2)$。\n幂运算的总时间是 $O(\\log p) \\times O((\\log p)^2) = O((\\log p)^3)$。\n\n**总复杂度：** 算法的期望运行时间是这些步骤复杂度的总和，主要由模幂运算决定。总期望时间复杂度为 $O((\\log p)^3)$，这是输入大小 $\\log p$ 的多项式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem for a fixed test suite of (a, p) pairs.\n    It computes a square root of a modulo p if one exists.\n    \"\"\"\n\n    test_cases = [\n        (0, 3),\n        (2, 3),\n        (10, 13),\n        (2, 13),\n        (643499475, 1000000007),\n        (5, 11),\n        (3, 11),\n    ]\n\n    def sqrt_mod_p(a, p):\n        \"\"\"\n        Computes a square root of a modulo p using Cipolla's algorithm.\n        Returns the smaller root, or -1 if no root exists.\n        \"\"\"\n        a %= p\n        if a == 0:\n            return 0\n        if p == 2:\n            return a\n\n        # Step 1: Check if a is a quadratic residue using Euler's criterion.\n        legendre = pow(a, (p - 1) // 2, p)\n        if legendre == p - 1:\n            return -1  # a is a quadratic non-residue\n\n        # If p = 3 (mod 4), there's a simpler formula.\n        # But this problem asks for the F_p^2 based derivation which works for all odd p.\n        # We will implement the general Cipolla's algorithm as required.\n        \n        # Step 2: Find t such that t^2 - a is a quadratic non-residue.\n        t = 1\n        while True:\n            n = (t * t - a) % p\n            if pow(n, (p - 1) // 2, p) == p - 1:\n                break\n            t += 1\n\n        # We need to perform arithmetic in F_p^2 = F_p[x] / (x^2 - n)\n        # An element is represented as a tuple (u, v) for u + v*omega.\n        \n        def f_p2_mul(x, y, n_val, p_val):\n            \"\"\"\n            Multiplies two numbers in F_p^2.\n            x = (x_u, x_v), y = (y_u, y_v)\n            \"\"\"\n            # (x_u + x_v*w) * (y_u + y_v*w) = x_u*y_u + (x_u*y_v + x_v*y_u)*w + x_v*y_v*w^2\n            # = (x_u*y_u + x_v*y_v*n) + (x_u*y_v + x_v*y_u)*w\n            res_u = (x[0] * y[0] + x[1] * y[1] * n_val) % p_val\n            res_v = (x[0] * y[1] + x[1] * y[0]) % p_val\n            return (res_u, res_v)\n        \n        def f_p2_pow(base, exp, n_val, p_val):\n            \"\"\"\n            Exponentiation in F_p^2 using binary exponentiation (exponentiation by squaring).\n            \"\"\"\n            res = (1, 0) # Multiplicative identity in F_p^2\n            while exp > 0:\n                if exp % 2 == 1:\n                    res = f_p2_mul(res, base, n_val, p_val)\n                base = f_p2_mul(base, base, n_val, p_val)\n                exp //= 2\n            return res\n\n        # Step 3: Compute x = (t + omega)^((p+1)/2).\n        # The base is (t, 1) which represents t + omega.\n        # The exponent is (p + 1) // 2.\n        base = (t, 1)\n        exponent = (p + 1) // 2\n        \n        root_pair = f_p2_pow(base, exponent, n, p)\n\n        # The result must be in F_p, so its imaginary part is 0.\n        # The root is the real part.\n        r1 = root_pair[0]\n        \n        # The other root is p - r1.\n        r2 = p - r1\n\n        # The problem asks for the smaller of the two roots.\n        return min(r1, r2)\n        \n    results = []\n    for a, p in test_cases:\n        result = sqrt_mod_p(a, p)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3021789"}]}