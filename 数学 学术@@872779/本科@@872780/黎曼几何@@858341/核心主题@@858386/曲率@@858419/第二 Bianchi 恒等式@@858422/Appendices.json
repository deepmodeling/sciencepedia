{"hands_on_practices": [{"introduction": "本练习触及了证明第二比安基恒等式的核心。对一个定理的深刻理解，往往源于辨识那些看似合理却存在谬误的论证。这个练习 [@problem_id:3077203] 要求你分析一个常见但错误的证明策略，并在此过程中掌握法坐标系和协变性原理在建立张量恒等式中的关键作用。掌握这一点，是领会微分几何中证明过程的严谨与精妙之处的关键。", "problem": "设 $(M,g)$ 是一个光滑黎曼流形，其 Levi-Civita 联络为 $\\nabla$。在局部坐标 $\\{x^i\\}$ 下，将 Christoffel 符号写为 $\\Gamma^{\\ell}{}_{ik}$，黎曼曲率张量的分量写为 $R^{\\ell}{}_{ijk}$。一个证明第二比安基恒等式的尝试论证如下：选取法坐标，将 $\\Gamma^{\\ell}{}_{ik}=0$ 处处成立，然后在 $R^{\\ell}{}_{ijk}$ 的协变导数中去掉所有含 $\\Gamma^{\\ell}{}_{ik}$ 的项，从而得出该恒等式。\n\n请仅使用黎曼几何中的基本事实和定义，分析这一论证。你可以使用以下标准基础：\n- Levi-Civita 联络是无挠且度量兼容的。\n- 在点 $p\\in M$ 的法坐标中，有 $\\Gamma^{\\ell}{}_{ik}(p)=0$，但不假定其导数 $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ 为零。\n- 曲率张量由协变导数的交换子产生，在坐标下的局部表达式为\n$$\nR^{\\ell}{}_{ijk}=\\partial_j\\Gamma^{\\ell}{}_{ik}-\\partial_k\\Gamma^{\\ell}{}_{ij}+\\Gamma^{\\ell}{}_{js}\\Gamma^{s}{}_{ik}-\\Gamma^{\\ell}{}_{ks}\\Gamma^{s}{}_{ij}.\n$$\n- 张量在坐标下的协变导数等于偏导数加上 Christoffel 符号的线性项。\n\n哪个选项正确解释了上述证明策略的缺陷，并概述了一个能得出第二比安基恒等式的有效逐点修正方法？\n\nA. 该论证是有效的，因为在法坐标中 $\\Gamma^{\\ell}{}_{ik}$ 在一个邻域内恒为零，所以 $R^{\\ell}{}_{ijk}=0$ 在该邻域成立，该恒等式是平凡的。为了全局修正该证明，应选择使 $\\Gamma^{\\ell}{}_{ik}$ 处处为零的调和坐标。\n\nB. 该论证是有缺陷的，因为在法坐标中，$\\Gamma^{\\ell}{}_{ik}=0$ 仅在单一点 $p$ 得到保证，而不是在一个邻域上；并且尽管 $\\Gamma^{\\ell}{}_{ik}(p)=0$，其导数 $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ 通常不为零。一个正确的逐点证明是在法坐标下计算 $p$ 点的 $\\nabla_{l}R^{\\ell}{}_{ijk}$，观察到在该点协变导数简化为偏导数，使用 $R^{\\ell}{}_{ijk}(p)=\\partial_j\\Gamma^{\\ell}{}_{ik}(p)-\\partial_k\\Gamma^{\\ell}{}_{ij}(p)$，并证明三个偏导数的循环和 $\\partial_l R^{\\ell}{}_{ijk} + \\partial_j R^{\\ell}{}_{ikl} + \\partial_k R^{\\ell}{}_{ilj}$ 因混合偏导数的交换性而为零。由于该恒等式是张量性的，且 $p$ 是任意的，所以它处处成立。\n\nC. 缺陷在于忽略了度量兼容性：可以选择坐标使得 $\\Gamma^{\\ell}{}_{ik}(p)$ 和 $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ 在 $p$ 点都为零。正确的证明是去掉所有含 $\\Gamma^{\\ell}{}_{ik}$ 和 $\\partial_m\\Gamma^{\\ell}{}_{ik}$ 的项，并从对称性 $R_{lijk}=R_{ljik}$ 得出该恒等式。\n\nD. 缺陷在于忽略了挠率：法坐标迫使 $\\Gamma^{\\ell}{}_{ik}$ 在下指标上是反对称的，所以处处设 $\\Gamma^{\\ell}{}_{ik}=0$ 与无挠性矛盾。修正是假定无挠，这意味着 $R^{\\ell}{}_{ijk}=0$，从而证明了该恒等式。\n\nE. 问题在于 $\\Gamma^{\\ell}{}_{ik}$ 是非齐次地变换的，因此基于坐标的证明是行不通的。修正是沿测地线使用平行标架以确保在所有径向上 $\\nabla R=0$，这直接蕴含了第二比安基恒等式。", "solution": "问题陈述是微分几何中的一个有效练习，要求指出对第二比安基恒等式的一个常见但错误的“证明”中的缺陷，并描述正确、标准的证明策略。\n\n所呈现的有缺陷的论证如下：\n1.  选取法坐标。\n2.  将 Christoffel 符号 $\\Gamma^{\\ell}{}_{ik}=0$ *处处*成立。\n3.  以此简化黎曼张量的协变导数 $\\nabla R$，并得出该恒等式。\n\n此论证中主要且关键的缺陷是第2步。在以点 $p \\in M$ 为中心的法坐标中，Christoffel 符号*在该点*为零，即 $\\Gamma^{\\ell}{}_{ik}(p) = 0$。然而，它们通常不会在 $p$ 的一个开邻域内为零。对于一个一般的弯曲流形，不可能找到一个坐标系使得 Christoffel 符号在一个开集内处处为零。如果存在这样的坐标，黎曼曲率张量在该集合中将恒为零，这意味着流形是平坦的。因此，对于任何非平坦流形，该论证的前提是错误的。\n\n因此，第3步也是无效的。由于 $\\Gamma^{\\ell}{}_{ik}$ 在 $p$ 点之外不为零，它们的导数 $\\partial_m \\Gamma^{\\ell}{}_{ik}$ 通常也不为零，即使在 $p$ 点也是如此。所提出的简化错误地丢弃了这些关键的导数项。\n\n一个有效的证明利用了法坐标在单个任意点 $p$ 的性质。协变性原理指出，如果一个张量方程在一个坐标系中成立，那么它在所有坐标系中都成立。因此，在一个特殊坐标系中证明该恒等式在一个任意点 $p$ 成立，就足以确立其处处有效。\n\n第二比安基恒等式是关于黎曼张量协变导数循环和的一个陈述。一个标准形式是：\n$$ \\nabla_l R^{\\ell}{}_{ijk} + \\nabla_j R^{\\ell}{}_{ikl} + \\nabla_k R^{\\ell}{}_{ilj} = 0 $$\n黎曼张量协变导数的表达式是：\n$$ \\nabla_l R^{\\ell}{}_{ijk} = \\partial_l R^{\\ell}{}_{ijk} + \\Gamma^{\\ell}{}_{lm} R^{m}{}_{ijk} - \\Gamma^{m}{}_{li} R^{\\ell}{}_{mjk} - \\Gamma^{m}{}_{lj} R^{\\ell}{}_{imk} - \\Gamma^{m}{}_{lk} R^{\\ell}{}_{ijm} $$\n在 $p$ 点的法坐标中，我们有 $\\Gamma^{\\beta}{}_{\\alpha \\gamma}(p) = 0$。在 $p$ 点计算上述表达式，所有包含 Christoffel 符号的项都为零：\n$$ (\\nabla_l R^{\\ell}{}_{ijk})(p) = (\\partial_l R^{\\ell}{}_{ijk})(p) $$\n因此，在 $p$ 点，协变导数简化为偏导数。\n\n接下来，我们考察 $p$ 点的黎曼张量本身。其完整表达式为：\n$$ R^{\\ell}{}_{ijk} = \\partial_j\\Gamma^{\\ell}{}_{ik}-\\partial_k\\Gamma^{\\ell}{}_{ij}+\\Gamma^{\\ell}{}_{jm}\\Gamma^{m}{}_{ik}-\\Gamma^{\\ell}{}_{km}\\Gamma^{m}{}_{ij} $$\n在 $p$ 点，由于 $\\Gamma^{\\ell}{}_{ik}(p) = 0$，二次项为零，剩下：\n$$ R^{\\ell}{}_{ijk}(p) = (\\partial_j\\Gamma^{\\ell}{}_{ik})(p) - (\\partial_k\\Gamma^{\\ell}{}_{ij})(p) $$\n这表明 $p$ 点的曲率取决于 Christoffel 符号在 $p$ 点的*一阶导数*，而这些导数通常是非零的。\n\n为了计算 $(\\partial_l R^{\\ell}{}_{ijk})(p)$，我们必须首先将 $R^{\\ell}{}_{ijk}$ 的完整表达式对 $x^l$ 求导，*然后*在 $p$ 点求值。对二次 $\\Gamma$ 项求导会产生形如 $(\\partial \\Gamma)\\Gamma$ 的项，这些项在 $p$ 点为零，因为它们包含一个未求导的 $\\Gamma$ 因子。因此，在 $p$ 点：\n$$ (\\partial_l R^{\\ell}{}_{ijk})(p) = \\partial_l \\left( \\partial_j\\Gamma^{\\ell}{}_{ik} - \\partial_k\\Gamma^{\\ell}{}_{ij} \\right)(p) = (\\partial_l \\partial_j\\Gamma^{\\ell}{}_{ik})(p) - (\\partial_l \\partial_k\\Gamma^{\\ell}{}_{ij})(p) $$\n在 $p$ 点的第二比安基恒等式变成了这些偏导数的循环和：\n$$ (\\nabla_l R^{\\ell}{}_{ijk} + \\nabla_j R^{\\ell}{}_{ikl} + \\nabla_k R^{\\ell}{}_{ilj})(p) = (\\partial_l R^{\\ell}{}_{ijk} + \\partial_j R^{\\ell}{}_{ikl} + \\partial_k R^{\\ell}{}_{ilj})(p) $$\n代入我们关于 $R$ 的偏导数的表达式：\n$$ = \\left[ (\\partial_l \\partial_j\\Gamma^{\\ell}{}_{ik})(p) - (\\partial_l \\partial_k\\Gamma^{\\ell}{}_{ij})(p) \\right] + \\left[ (\\partial_j \\partial_k\\Gamma^{\\ell}{}_{il})(p) - (\\partial_j \\partial_l\\Gamma^{\\ell}{}_{ik})(p) \\right] + \\left[ (\\partial_k \\partial_l\\Gamma^{\\ell}{}_{ij})(p) - (\\partial_k \\partial_j\\Gamma^{\\ell}{}_{il})(p) \\right] $$\n在光滑流形上，偏导数是可交换的（$\\partial_a \\partial_b = \\partial_b \\partial_a$）。将各项分组，我们看到它们两两相消：\n$$ [(\\partial_l \\partial_j\\Gamma^{\\ell}{}_{ik}) - (\\partial_j \\partial_l\\Gamma^{\\ell}{}_{ik})] + [(\\partial_j \\partial_k\\Gamma^{\\ell}{}_{il}) - (\\partial_k \\partial_j\\Gamma^{\\ell}{}_{il})] + [(\\partial_k \\partial_l\\Gamma^{\\ell}{}_{ij}) - (\\partial_l \\partial_k\\Gamma^{\\ell}{}_{ij})] = 0 + 0 + 0 = 0 $$\n该恒等式在 $p$ 点成立。由于 $p$ 是一个任意点，该恒等式在 $M$ 上处处成立。\n\n现在我们来评估给出的选项。\n\n**A. 这个选项是错误的。在法坐标中 $\\Gamma^{\\ell}{}_{ik}$ 在一个邻域内为零的断言是错误的。调和坐标通常不会使 $\\Gamma^{\\ell}{}_{ik}$ 处处为零。**\n\n**B. 这个选项是正确的。它精确地指出了所提论证的核心缺陷（即 $\\Gamma^{\\ell}{}_{ik}$ 仅在一点 $p$ 为零，而非在一个邻域内）。然后它正确地概述了基于法坐标中逐点计算的标准、有效的证明方法，正如上面的推导所详述。所描述的所有步骤都是有效的，并能导向期望的结论。**\n\n**C. 这个选项是错误的。通常不可能同时使 $\\Gamma^{\\ell}{}_{ik}(p)$ 及其所有一阶导数 $\\partial_m\\Gamma^{\\ell}{}_{ik}(p)$ 都为零。如果可以，那么黎曼张量在 $p$ 点将为零。此外，从黎曼张量的代数对称性推出*第二*（微分）比安基恒等式是一个根本性的错误。对称性 $R_{lijk}=R_{ljik}$ 也是错误的。**\n\n**D. 这个选项是错误的。对于像 Levi-Civita 联络这样的无挠联络，Christoffel 符号在其下指标上是对称的，即 $\\Gamma^{\\ell}{}_{ik} = \\Gamma^{\\ell}{}_{ki}$，而不是反对称的。此外，无挠并不意味着曲率为零。**\n\n**E. 这个选项是错误的。关于基于坐标的证明行不通的说法根本上是错误的；协变性原理正是使此类证明有效的原因。建议的“修正”也是有缺陷的；通常无法找到使 $\\nabla R=0$ 的标架。**", "answer": "$$\\boxed{B}$$", "id": "3077203"}, {"introduction": "第二比安基恒等式揭示了黎曼曲率张量的一个深刻且不那么显而易见的性质。要真正领会其重要性，一个有效的方法是看看这个恒等式是否对任意张量场都成立。本练习 [@problem_id:3077216] 将引导你构建一个自定义的张量，并计算相同的循环和，从而证明其结果不为零。这种对比突显出比安基恒等式并非一个简单的代数形式，而是由无挠率联络所导出的曲率张量所特有的一种深刻的结构性约束。", "problem": "令 $\\left(\\mathbb{R}^2,g\\right)$ 为欧几里得平面，其具有标准欧几里得度量 $g$ 及其 Levi-Civita 联络 $\\nabla$。在全局笛卡尔坐标 $(x,y)$ 及坐标标架 $\\partial_x,\\partial_y$ 下进行计算。定义一个 $(1,3)$-张量场 $T$，其对标架的作用规定如下：\n- $T(\\partial_x,\\partial_y,\\partial_x) = f(x,y)\\,\\partial_x$，其中 $f(x,y)=x^2 y$，\n- 对于标架中所有其他的三元组 $(Y,Z,W)$，有 $T(Y,Z,W)=0$，\n并通过多重线性和光滑性将其扩展到所有向量场上。\n\n令 $X=\\partial_x$，$Y=\\partial_x$，$Z=\\partial_y$，$W=\\partial_x$。定义关于前三个输入的循环和为\n$$\n\\operatorname{cyc}_{X,Y,Z} S(X,Y,Z) \\;=\\; S(X,Y,Z) \\;+\\; S(Y,Z,X) \\;+\\; S(Z,X,Y),\n$$\n对于任意三线性映射 $S$。仅使用协变导数和 $\\mathbb{R}^2$ 上张量场的基本定义，计算标量\n$$\nS \\;=\\; g\\!\\left(\\operatorname{cyc}_{X,Y,Z}(\\nabla_X T)(Y,Z,W),\\;\\partial_x\\right)\n$$\n在点 $p=(1,2)$ 处的值。\n\n最后，简要解释为什么当 $T$ 是 Levi-Civita 联络的黎曼曲率张量 $R$ 时，与之类似的循环和会消失。\n\n给出 $S$ 的最终数值，结果为一个精确的实数，无需四舍五入。", "solution": "问题要求计算一个标量值 $S$，该值由欧几里得平面 $\\left(\\mathbb{R}^2, g\\right)$ 上的一个用户定义的 $(1,3)$-张量场 $T$ 导出，并解释对于黎曼曲率张量 $R$ 的类似计算。\n\n首先，我们计算标量 $S$。该流形是具有标准欧几里得度量 $g$ 的 $\\mathbb{R}^2$。我们使用全局笛卡尔坐标 $(x,y)$，所以坐标基向量是 $\\partial_x$ 和 $\\partial_y$。在这些坐标下，Levi-Civita 联络 $\\nabla$ 的所有 Christoffel 符号都为零：$\\Gamma^k_{ij}=0$。这意味着任何基向量的协变导数都为零：对于 $i,j \\in \\{x,y\\}$，有 $\\nabla_{\\partial_i} \\partial_j = 0$。\n\n张量场 $T$ 是 $(1,3)$ 型的，可解释为一个映射 $T: (Y,Z,W) \\mapsto T(Y,Z)W$，它在其向量场变量上是三线性的。问题定义了它在基向量 $\\{\\partial_x, \\partial_y\\}$ 上的作用为：\n$T(\\partial_x, \\partial_y, \\partial_x) = f(x,y)\\partial_x$，其中 $f(x,y) = x^2 y$。\n对于所有其他基向量三元组，$T(Y,Z,W) = 0$。\n令 $\\partial_1 = \\partial_x$ 和 $\\partial_2 = \\partial_y$。$T$ 的分量 $T^k_{ijl}$ 由 $T(\\partial_i, \\partial_j, \\partial_l) = T^k_{ijl} \\partial_k$ 定义。给定条件意味着唯一非零的分量函数是 $T^1_{121} = f(x,y) = x^2y$。所有其他分量，如 $T^2_{121}$、$T^k_{211}$、$T^k_{111}$ 等，都恒等于零。\n\n需要计算的标量是 $S = g(\\operatorname{cyc}_{X,Y,Z}(\\nabla_X T)(Y,Z,W), \\partial_x)$ 在点 $p=(1,2)$ 处的值，给定的向量场为 $X=\\partial_x$，$Y=\\partial_x$，$Z=\\partial_y$ 和 $W=\\partial_x$。\n\n循环和定义为 $\\operatorname{cyc}_{X,Y,Z} S(X,Y,Z) = S(X,Y,Z) + S(Y,Z,X) + S(Z,X,Y)$。将此应用于表达式 $(\\nabla_\\cdot T)(\\cdot,\\cdot,W)$，得到向量场 $V$：\n$$\nV = (\\nabla_X T)(Y,Z,W) + (\\nabla_Y T)(Z,X,W) + (\\nabla_Z T)(X,Y,W).\n$$\n代入给定的向量场 $X=\\partial_x$，$Y=\\partial_x$，$Z=\\partial_y$ 和 $W=\\partial_x$：\n$$\nV = (\\nabla_{\\partial_x} T)(\\partial_x, \\partial_y, \\partial_x) + (\\nabla_{\\partial_x} T)(\\partial_y, \\partial_x, \\partial_x) + (\\nabla_{\\partial_y} T)(\\partial_x, \\partial_x, \\partial_x).\n$$\n我们分别计算每一项。一个 $(1,3)$-张量 $T$ 的协变导数的一般定义是：\n$$\n(\\nabla_A T)(B,C,D) = \\nabla_A(T(B,C,D)) - T(\\nabla_A B, C, D) - T(B, \\nabla_A C, D) - T(B, C, \\nabla_A D).\n$$\n因为我们在平坦几何中使用坐标基向量，所以 $\\nabla_{\\partial_i} \\partial_j = 0$。该公式显著简化为：\n$$\n(\\nabla_{\\partial_i} T)(\\partial_j, \\partial_l, \\partial_m) = \\nabla_{\\partial_i}(T(\\partial_j, \\partial_l, \\partial_m)).\n$$\n现在我们计算 $V$ 的三项：\n\n第1项：$(\\nabla_{\\partial_x} T)(\\partial_x, \\partial_y, \\partial_x) = \\nabla_{\\partial_x}(T(\\partial_x, \\partial_y, \\partial_x))$。\n根据 $T$ 的定义，我们有 $T(\\partial_x, \\partial_y, \\partial_x) = f(x,y)\\partial_x = x^2 y \\partial_x$。所以，\n$$\n\\nabla_{\\partial_x}(x^2 y \\partial_x) = (\\nabla_{\\partial_x} (x^2 y)) \\partial_x + (x^2 y) (\\nabla_{\\partial_x} \\partial_x).\n$$\n标量函数的协变导数是其偏导数，所以 $\\nabla_{\\partial_x} (x^2 y) = \\frac{\\partial}{\\partial x}(x^2 y) = 2xy$。第二项因为 $\\nabla_{\\partial_x} \\partial_x = 0$ 而消失。\n因此，第一项是 $(2xy)\\partial_x$。\n\n第2项：$(\\nabla_{\\partial_x} T)(\\partial_y, \\partial_x, \\partial_x) = \\nabla_{\\partial_x}(T(\\partial_y, \\partial_x, \\partial_x))$。\n参数三元组是 $(\\partial_y, \\partial_x, \\partial_x)$，而不是 $(\\partial_x, \\partial_y, \\partial_x)$。根据问题定义，$T(\\partial_y, \\partial_x, \\partial_x) = 0$。\n因此，第二项是 $\\nabla_{\\partial_x}(0) = 0$。\n\n第3项：$(\\nabla_{\\partial_y} T)(\\partial_x, \\partial_x, \\partial_x) = \\nabla_{\\partial_y}(T(\\partial_x, \\partial_x, \\partial_x))$。\n参数三元组是 $(\\partial_x, \\partial_x, \\partial_x)$，也不是 $(\\partial_x, \\partial_y, \\partial_x)$。根据定义，$T(\\partial_x, \\partial_x, \\partial_x) = 0$。\n因此，第三项是 $\\nabla_{\\partial_y}(0) = 0$。\n\n合并各项，总向量场为 $V = (2xy)\\partial_x + 0 + 0 = (2xy)\\partial_x$。\n\n标量 $S$ 通过计算 $V$ 与 $\\partial_x$ 的内积得到：\n$$\nS = g(V, \\partial_x) = g((2xy)\\partial_x, \\partial_x).\n$$\n利用度量 $g$ 的双线性，我们有 $S = (2xy)g(\\partial_x, \\partial_x)$。\n在具有笛卡尔坐标的标准欧几里得度量中，基 $\\{\\partial_x, \\partial_y\\}$ 是标准正交的，所以 $g(\\partial_x, \\partial_x) = 1$。\n因此，标量函数是 $S = 2xy$。\n\n我们必须在点 $p=(1,2)$ 处计算该值，即 $x=1$ 和 $y=2$：\n$$\nS|_{p=(1,2)} = 2(1)(2) = 4.\n$$\n\n最后，我们来回答为什么如果 $T$ 是 Levi-Civita 联络 $\\nabla$ 的黎曼曲率张量 $R$，那么类似的和会消失。所讨论的和将是：\n$$\n(\\nabla_X R)(Y,Z)W + (\\nabla_Y R)(Z,X)W + (\\nabla_Z R)(X,Y)W.\n$$\n这个表达式是**第二比安基恒等式** (second Bianchi identity) 的主题。这个恒等式是与任何无挠联络（包括 Levi-Civita 联络）相关的黎曼曲率张量的一个基本性质。该恒等式表明，对于所有向量场 $X, Y, Z, W$，这个和恒等于零：\n$$\n(\\nabla_X R)(Y,Z)W + (\\nabla_Y R)(Z,X)W + (\\nabla_Z R)(X,Y)W = 0.\n$$\n该恒等式成立，因为黎曼张量 $R$ 不是一个任意的张量场，而是由联络 $\\nabla$ 本身内在地定义的，具体通过关系式 $R(X,Y)Z = \\nabla_X\\nabla_Y Z - \\nabla_Y\\nabla_X Z - \\nabla_{[X,Y]}Z$。第二比安基恒等式可以从此定义和协变导数算子的雅可比恒等式导出。相比之下，本问题中的张量 $T$ 是一个人为构造的场，与联络 $\\nabla$ 没有内在关系。它不具备黎曼张量的特殊对称性和性质，因此没有理由满足第二比安基恒等式。我们的计算得出了一个非零结果，明确地证明了这一点。对于欧几里得平面，其黎曼张量 $R$ 恒等于零，所以这个和会平凡地为零，但该恒等式对任何流形都成立，无论其曲率如何。", "answer": "$$\\boxed{4}$$", "id": "3077216"}, {"introduction": "在现代数学中，连接抽象理论与实际应用是一项至关重要的技能。理论证明确立了恒等式的真理性，而计算验证则能在复杂、非平凡的情景中建立直观并确认其有效性。本练习 [@problem_id:3077229] 将挑战你将黎曼几何的基本定义转化为一个计算算法。通过编写程序来检验第二比安基恒等式在一族弯曲空间上的成立情况，你将对这些复杂的几何对象如何运作获得一种强有力的、亲身实践的理解。", "problem": "考虑一个带有黎曼度量和相关列维-奇维塔联络的光滑流形。黎曼曲率张量由该联络定义，其协变导数满足一个称为第二比安基恒等式的基本恒等式。你的任务是通过从核心几何定义出发，逐步构造相关张量，为一类特定的度量族实现并测试第二比安基恒等式的算法验证。\n\n从以下基础出发：\n- 一个黎曼度量在每一点上赋予切空间一个正定对称双线性形式。在局部坐标中，这由一个函数对称矩阵 $g_{ij}(x)$ 编码。\n- 列维-奇维塔联络是唯一的无挠、与度量相容的联络。其克里斯托费尔符号由以下公式给出：\n$$\n\\Gamma^{\\ell}{}_{ij} = \\tfrac{1}{2} g^{\\ell s} \\left(\\partial_i g_{js} + \\partial_j g_{is} - \\partial_s g_{ij}\\right),\n$$\n其中 $g^{\\ell s}$ 是 $g_{\\ell s}$ 的逆矩阵，$\\partial_i$ 表示对坐标 $x^i$ 的偏导数。\n- 带有一个上指标的黎曼曲率张量定义为：\n$$\nR^{\\ell}{}_{ijk} = \\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij} + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij},\n$$\n此处对重复指标遵循爱因斯坦求和约定。\n- 一个 $(1,3)$ 型张量 $T^{\\ell}{}_{ijk}$ 的协变导数由以下公式给出：\n$$\n(\\nabla_m T)^{\\ell}{}_{ijk} = \\partial_m T^{\\ell}{}_{ijk} + \\Gamma^{\\ell}{}_{ms} T^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} T^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} T^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} T^{\\ell}{}_{ijs}.\n$$\n\n你必须构建一个程序，该程序：\n1. 根据上述定义，实现从度量计算克里斯托费尔符号。\n2. 根据克里斯托费尔符号的定义，实现黎曼曲率张量的计算。\n3. 根据上述定义，实现黎曼曲率张量的协变导数的计算。\n4. 对于给定的点 $x$ 和给定的度量 $g_{ij}(x)$，计算循环和\n$$\n(\\nabla_m R)^{\\ell}{}_{ijk} + (\\nabla_k R)^{\\ell}{}_{ijm} + (\\nabla_j R)^{\\ell}{}_{ikm}\n$$\n并评估其最大绝对值分量（即在所有自由指标上的上确界范数）。\n\n验证目标：\n- 第二比安基恒等式表明，上述循环和恒等于零：\n$$\n\\nabla_m R^{\\ell}{}_{ijk} + \\nabla_k R^{\\ell}{}_{ijm} + \\nabla_j R^{\\ell}{}_{ikm} = 0.\n$$\n\n待测度量族：\n- 限定于共形平坦度量，其形式为\n$$\ng_{ij}(x) = e^{2\\phi(x)} \\delta_{ij},\n$$\n其中 $\\delta_{ij}$ 是克罗内克符号，$\\phi$ 是一个光滑标量函数。你必须实现一个程序，使用上述定义从第一性原理构造所有所需的对象。对于这些共形度量，允许利用将 $g_{ij}(x) = e^{2\\phi(x)} \\delta_{ij}$ 代入核心定义所带来的代数简化，只要这些简化是从给定的基础推导出来的。\n\n测试指南：\n- 为通用维度 $n \\in \\{2,3\\}$ 实现上述过程。\n- 对于共形度量 $g_{ij} = e^{2\\phi} \\delta_{ij}$，使用以下 $\\phi$ 的选择：\n  - 情况 A（平坦）：$\\phi(x) = 0$。\n  - 情况 B（线性）：$\\phi(x) = a_1 x^1 + \\cdots + a_n x^n$，其中系数为预设常数。\n  - 情况 C（二次径向）：$\\phi(x) = \\alpha \\sum_{i=1}^n (x^i)^2$，其中 $\\alpha$ 为预设常数。\n\n你的程序必须对每个测试用例计算上述循环和的上确界范数，并返回一个布尔值，指示该范数是否小于给定的容差。使用 $10^{-10}$ 作为容差。\n\n测试套件：\n- 使用以下维度、参数值和评估点：\n  1. $n=3$, $\\phi(x) = 0$，在 $x = (0.12,-0.30,0.05)$ 处评估。\n  2. $n=3$, $\\phi(x) = 0.2 x^1 - 0.1 x^2 + 0.05 x^3$，在 $x = (0.3,-0.4,0.1)$ 处评估。\n  3. $n=3$, $\\phi(x) = 0.2 \\sum_{i=1}^3 (x^i)^2$，在 $x = (-0.2,0.5,0.4)$ 处评估。\n  4. $n=2$, $\\phi(x) = -0.3 \\sum_{i=1}^2 (x^i)^2$，在 $x = (0.6,-0.4)$ 处评估。\n\n可量化输出规范：\n- 对于每个测试用例，计算张量\n$$\nB^{\\ell}{}_{ijkm} = (\\nabla_m R)^{\\ell}{}_{ijk} + (\\nabla_k R)^{\\ell}{}_{ijm} + (\\nabla_j R)^{\\ell}{}_{ikm},\n$$\n在所有指标上的最大绝对值，如果该最大值严格小于 $10^{-10}$，则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是与上面列出的测试用例顺序对应的 $\\mathrm{True}$ 或 $\\mathrm{False}$。不应打印其他任何文本。", "solution": "我们从黎曼流形的基本定义开始。在坐标系中，度量是一个由函数组成的对称正定矩阵 $g_{ij}(x)$。列维-奇维塔联络的特点是无挠且与度量相容，由此可得克里斯托费尔符号\n$$\n\\Gamma^{\\ell}{}_{ij} = \\tfrac{1}{2} g^{\\ell s} \\left(\\partial_i g_{js} + \\partial_j g_{is} - \\partial_s g_{ij}\\right).\n$$\n带有一个上指标的黎曼曲率张量由 $\\Gamma$ 构造如下：\n$$\nR^{\\ell}{}_{ijk} = \\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij} + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij}.\n$$\n对于一个 $(1,3)$ 型张量 $T^{\\ell}{}_{ijk}$，其协变导数为\n$$\n(\\nabla_m T)^{\\ell}{}_{ijk} = \\partial_m T^{\\ell}{}_{ijk} + \\Gamma^{\\ell}{}_{ms} T^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} T^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} T^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} T^{\\ell}{}_{ijs}.\n$$\n\n我们的目标是验证第二比安基恒等式，\n$$\n\\nabla_m R^{\\ell}{}_{ijk} + \\nabla_k R^{\\ell}{}_{ijm} + \\nabla_j R^{\\ell}{}_{ikm} = 0,\n$$\n对于共形平坦度量\n$$\ng_{ij}(x) = e^{2\\phi(x)} \\delta_{ij}.\n$$\n为了从第一性原理通过算法实现这一点，我们应用上述定义，并将度量的特殊形式代入其中。对于 $g_{ij} = e^{2\\phi} \\delta_{ij}$，通过直接代入定义公式，可以推导出列维-奇维塔联络的以下显式表达式。首先计算 $\\partial_i g_{js} = 2 e^{2\\phi} (\\partial_i \\phi) \\delta_{js}$。然后 $g^{\\ell s} = e^{-2\\phi} \\delta^{\\ell s}$。代入并化简可得\n$$\n\\Gamma^{\\ell}{}_{ij} = \\delta^{\\ell}{}_i \\, \\partial_j \\phi + \\delta^{\\ell}{}_j \\, \\partial_i \\phi - \\delta_{ij} \\, \\partial^\\ell \\phi,\n$$\n其中 $\\partial^\\ell \\phi = \\delta^{\\ell s} \\partial_s \\phi$。这完全是由专门针对共形度量的列维-奇维塔公式以及克罗内克符号的代数性质得出的。\n\n接下来，我们使用曲率张量关于联络的定义来计算它。曲率取决于 $\\partial_j \\Gamma^{\\ell}{}_{ik}$ 和 $\\Gamma \\Gamma$ 乘积项。对于共形度量，$\\partial_m \\Gamma^{\\ell}{}_{ij}$ 仅取决于黑塞矩阵 $\\partial_i \\partial_j \\phi$：\n$$\n\\partial_m \\Gamma^{\\ell}{}_{ij} = \\delta^{\\ell}{}_i \\, \\partial_{jm} \\phi + \\delta^{\\ell}{}_j \\, \\partial_{im} \\phi - \\delta_{ij} \\, \\partial^{\\ell}{}_m \\phi,\n$$\n其中 $\\partial^{\\ell}{}_m \\phi = \\delta^{\\ell s} \\partial_{sm} \\phi$ 且 $\\partial_{jm} \\phi = \\partial_j \\partial_m \\phi$。\n\n因此，对于 $R^{\\ell}{}_{ijk}$，我们可以完全用梯度 $\\partial_i \\phi$ 和黑塞矩阵 $\\partial_{ij} \\phi$ 来评估\n$$\nR^{\\ell}{}_{ijk} = \\left(\\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij}\\right) + \\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij},\n$$\n而无需调用任何数值微分。\n\n为计算协变导数 $(\\nabla_m R)^{\\ell}{}_{ijk}$，我们使用其定义。偏导数部分 $\\partial_m R^{\\ell}{}_{ijk}$ 包含两类项：$\\partial_j \\Gamma^{\\ell}{}_{ik} - \\partial_k \\Gamma^{\\ell}{}_{ij}$ 的导数，以及 $\\Gamma \\Gamma$ 乘积项的导数。前者取决于 $\\phi$ 的三阶导数（黑塞矩阵的导数），而后者通过 $\\partial_m \\Gamma$ 取决于黑塞矩阵。对于此处使用的特定测试函数族 $\\phi$（常数、线性和二次函数），三阶导数均为零：\n- 对于 $\\phi(x) = 0$，所有导数都为零。\n- 对于线性函数 $\\phi(x)$，其黑塞矩阵为零，因此曲率完全由 $\\Gamma \\Gamma$ 项构成，且所有二阶导数均为零。\n- 对于二次函数 $\\phi(x)$，其黑塞矩阵是常数，因此其导数为零，且 $\\partial_m \\partial_j \\Gamma^{\\ell}{}_{ik} = 0$。\n\n因此，对于我们的测试套件，我们有\n$$\n\\partial_m R^{\\ell}{}_{ijk} = \\partial_m\\left(\\Gamma^{\\ell}{}_{js} \\Gamma^{s}{}_{ik} - \\Gamma^{\\ell}{}_{ks} \\Gamma^{s}{}_{ij}\\right)\n= (\\partial_m \\Gamma^{\\ell}{}_{js}) \\Gamma^{s}{}_{ik} + \\Gamma^{\\ell}{}_{js} (\\partial_m \\Gamma^{s}{}_{ik})\n- (\\partial_m \\Gamma^{\\ell}{}_{ks}) \\Gamma^{s}{}_{ij} - \\Gamma^{\\ell}{}_{ks} (\\partial_m \\Gamma^{s}{}_{ij}),\n$$\n其中 $\\partial_m \\Gamma^{\\ell}{}_{ij}$ 由上述的黑塞矩阵显式给出。这使得我们能够为所选的 $\\phi$ 函数精确计算 $\\partial_m R^{\\ell}{}_{ijk}$（在浮点运算精度内），而无需借助数值微分。\n\n最后，我们使用联络修正项来组装 $(\\nabla_m R)^{\\ell}{}_{ijk}$：\n$$\n(\\nabla_m R)^{\\ell}{}_{ijk} = \\partial_m R^{\\ell}{}_{ijk}\n+ \\Gamma^{\\ell}{}_{ms} R^{s}{}_{ijk} - \\Gamma^{s}{}_{mi} R^{\\ell}{}_{sjk} - \\Gamma^{s}{}_{mj} R^{\\ell}{}_{isk} - \\Gamma^{s}{}_{mk} R^{\\ell}{}_{ijs}.\n$$\n然后我们计算循环和\n$$\nB^{\\ell}{}_{ijkm} = (\\nabla_m R)^{\\ell}{}_{ijk} + (\\nabla_k R)^{\\ell}{}_{ijm} + (\\nabla_j R)^{\\ell}{}_{ikm}.\n$$\n\n算法计划：\n1. 实现一个例程，用于在维度 $n=2$ 和 $n=3$ 下，为 $\\phi(x)=0$、线性 $\\phi$ 和二次径向 $\\phi$ 的情况评估 $\\phi$、其梯度 $\\partial_i \\phi$ 及其黑塞矩阵 $\\partial_{ij} \\phi$。\n2. 构建克罗内克符号 $\\delta_{ij}$。\n3. 根据为共形度量特化的推导公式，从梯度计算 $\\Gamma^{\\ell}{}_{ij}$。\n4. 从黑塞矩阵计算 $\\partial_m \\Gamma^{\\ell}{}_{ij}$。\n5. 从 $\\partial_j \\Gamma^{\\ell}{}_{ik}$、$\\partial_k \\Gamma^{\\ell}{}_{ij}$ 和 $\\Gamma \\Gamma$ 计算 $R^{\\ell}{}_{ijk}$。\n6. 使用上述的乘法法则计算 $\\partial_m R^{\\ell}{}_{ijk}$（对于我们的测试套件，三阶导数为零）。\n7. 使用其定义计算 $(\\nabla_m R)^{\\ell}{}_{ijk}$。\n8. 构造循环和 $B^{\\ell}{}_{ijkm}$ 并取所有指标上的上确界范数。\n9. 将上确界范数与容差 $10^{-10}$ 进行比较，为每个测试用例生成一个布尔结果。\n\n测试套件：\n- 情况 1：$n=3$, $\\phi(x)=0$，在 $x=(0.12,-0.30,0.05)$ 处。\n- 情况 2：$n=3$, $\\phi(x)=0.2 x^1 - 0.1 x^2 + 0.05 x^3$，在 $x=(0.3,-0.4,0.1)$ 处。\n- 情况 3：$n=3$, $\\phi(x)=0.2 \\sum_{i=1}^3 (x^i)^2$，在 $x=(-0.2,0.5,0.4)$ 处。\n- 情况 4：$n=2$, $\\phi(x)=-0.3 \\sum_{i=1}^2 (x^i)^2$，在 $x=(0.6,-0.4)$ 处。\n\n对于每种情况，程序计算 $B^{\\ell}{}_{ijkm}$ 的上确界范数，如果该值小于 $10^{-10}$，则返回 $\\mathrm{True}$，从而在数值精度上证实了第二比安基恒等式。因为对于这些情况，所有计算都是基于 $\\partial_i \\phi$ 和 $\\partial_{ij} \\phi$ 的精确代数求值，所以上确界范数应处于浮点舍入误差的水平，从而确保所有测试用例的布尔值均为 $\\mathrm{True}$。最终输出将是单行文本，包含一个按测试套件顺序排列的布尔值 Python 列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef kronecker_delta(n):\n    return np.eye(n)\n\ndef phi_and_derivatives(n, phi_type, params, x):\n    \"\"\"\n    Returns phi, grad (shape (n,)), hess (shape (n,n)) for given phi_type.\n    Supported:\n      - 'zero': phi = 0\n      - 'linear': phi = sum_i coeffs[i] * x[i]\n      - 'quadratic': phi = alpha * sum_i x[i]^2\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    assert x.shape == (n,)\n    if phi_type == 'zero':\n        phi = 0.0\n        grad = np.zeros(n)\n        hess = np.zeros((n, n))\n    elif phi_type == 'linear':\n        coeffs = np.asarray(params.get('coeffs', np.zeros(n)), dtype=float)\n        assert coeffs.shape == (n,)\n        phi = float(np.dot(coeffs, x))\n        grad = coeffs.copy()\n        hess = np.zeros((n, n))\n    elif phi_type == 'quadratic':\n        alpha = float(params.get('alpha', 0.0))\n        phi = float(alpha * np.dot(x, x))\n        grad = 2.0 * alpha * x\n        hess = 2.0 * alpha * np.eye(n)\n    else:\n        raise ValueError(\"Unsupported phi_type\")\n    return phi, grad, hess\n\ndef gamma_from_grad(grad):\n    \"\"\"Compute Christoffel symbols Gamma^l_{ij} for conformal metric g=e^{2phi} delta.\"\"\"\n    n = grad.shape[0]\n    delta = kronecker_delta(n)\n    Gamma = np.zeros((n, n, n))  # l, i, j\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                Gamma[l, i, j] = (delta[l, i] * grad[j]\n                                  + delta[l, j] * grad[i]\n                                  - delta[i, j] * grad[l])\n    return Gamma\n\ndef dgamma_from_hess(hess):\n    \"\"\"Compute partial derivatives of Gamma: dGamma[p, l, i, j] = ∂_p Gamma^l_{ij}.\"\"\"\n    n = hess.shape[0]\n    delta = kronecker_delta(n)\n    dGamma = np.zeros((n, n, n, n))  # p, l, i, j\n    # ∂_p Γ^l_{ij} = δ^l_i φ_{jp} + δ^l_j φ_{ip} - δ_{ij} φ^l_p\n    # here φ^l_p = δ^{ls} φ_{sp} = φ_{lp}\n    for p in range(n):\n        for l in range(n):\n            for i in range(n):\n                for j in range(n):\n                    dGamma[p, l, i, j] = (delta[l, i] * hess[j, p]\n                                          + delta[l, j] * hess[i, p]\n                                          - delta[i, j] * hess[l, p])\n    return dGamma\n\ndef riemann_from_grad_hess(grad, hess):\n    \"\"\"Compute Riemann tensor R^l_{ijk} for conformal metric using grad and hess.\"\"\"\n    n = grad.shape[0]\n    Gamma = gamma_from_grad(grad)\n    dGamma = dgamma_from_hess(hess)\n    R = np.zeros((n, n, n, n))  # l, i, j, k\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    val = dGamma[j, l, i, k] - dGamma[k, l, i, j]\n                    # add Gamma-Gamma terms\n                    tmp = 0.0\n                    for s in range(n):\n                        tmp += Gamma[l, j, s] * Gamma[s, i, k] - Gamma[l, k, s] * Gamma[s, i, j]\n                    R[l, i, j, k] = val + tmp\n    return R, Gamma, dGamma\n\ndef dR_from_grad_hess(grad, hess, Gamma, dGamma):\n    \"\"\"\n    Compute partial derivatives of R: dR[m, l, i, j, k] = ∂_m R^l_{ijk}.\n    For phi up to quadratic, third derivatives vanish, so derivative of (∂_j Γ - ∂_k Γ) is zero.\n    Only derivatives of Gamma-Gamma products contribute.\n    \"\"\"\n    n = grad.shape[0]\n    dR = np.zeros((n, n, n, n, n))  # m, l, i, j, k\n    for m in range(n):\n        for l in range(n):\n            for i in range(n):\n                for j in range(n):\n                    for k in range(n):\n                        acc = 0.0\n                        for s in range(n):\n                            # derivative of Γ^l_{js} Γ^s_{ik}\n                            acc += dGamma[m, l, j, s] * Gamma[s, i, k] + Gamma[l, j, s] * dGamma[m, s, i, k]\n                            # subtract derivative of Γ^l_{ks} Γ^s_{ij}\n                            acc -= dGamma[m, l, k, s] * Gamma[s, i, j] + Gamma[l, k, s] * dGamma[m, s, i, j]\n                        dR[m, l, i, j, k] = acc\n    return dR\n\ndef covariant_derivative_of_R(m, R, dR, Gamma):\n    \"\"\"\n    Compute (nabla_m R)^l_{ijk} using:\n    (∇_m R)^l_{ijk} = ∂_m R^l_{ijk} + Γ^l_{ms} R^s_{ijk} - Γ^s_{mi} R^l_{sjk}\n                      - Γ^s_{mj} R^l_{isk} - Γ^s_{mk} R^l_{ijs}\n    Returns array of shape (l, i, j, k).\n    \"\"\"\n    n = Gamma.shape[0]\n    DmR = np.zeros((n, n, n, n))\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    val = dR[m, l, i, j, k]\n                    for s in range(n):\n                        val += Gamma[l, m, s] * R[s, i, j, k]\n                        val -= Gamma[s, m, i] * R[l, s, j, k]\n                        val -= Gamma[s, m, j] * R[l, i, s, k]\n                        val -= Gamma[s, m, k] * R[l, i, j, s]\n                    DmR[l, i, j, k] = val\n    return DmR\n\ndef bianchi_max_norm(grad, hess):\n    \"\"\"\n    Compute the maximum absolute value of the cyclic sum:\n    B^l_{ijkm} = (∇_m R)^l_{ijk} + (∇_k R)^l_{ijm} + (∇_j R)^l_{ikm}\n    Returns the sup norm over all indices.\n    \"\"\"\n    R, Gamma, dGamma = riemann_from_grad_hess(grad, hess)\n    dR = dR_from_grad_hess(grad, hess, Gamma, dGamma)\n    n = grad.shape[0]\n    # Precompute DmR for all m\n    D = np.zeros((n, n, n, n, n))  # m, l, i, j, k\n    for m in range(n):\n        D[m] = covariant_derivative_of_R(m, R, dR, Gamma)\n    max_abs = 0.0\n    for l in range(n):\n        for i in range(n):\n            for j in range(n):\n                for k in range(n):\n                    for m in range(n):\n                        val = D[m, l, i, j, k] + D[k, l, i, j, m] + D[j, l, i, k, m]\n                        absval = abs(val)\n                        if absval > max_abs:\n                            max_abs = absval\n    return max_abs\n\ndef run_test_case(n, phi_type, params, x, tol=1e-10):\n    _, grad, hess = phi_and_derivatives(n, phi_type, params, x)\n    max_norm = bianchi_max_norm(grad, hess)\n    return max_norm  tol\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: n=3, phi=0, x=(0.12,-0.30,0.05)\n        {'n': 3, 'phi_type': 'zero', 'params': {}, 'x': [0.12, -0.30, 0.05]},\n        # Case 2: n=3, phi=0.2 x1 - 0.1 x2 + 0.05 x3, x=(0.3,-0.4,0.1)\n        {'n': 3, 'phi_type': 'linear', 'params': {'coeffs': [0.2, -0.1, 0.05]}, 'x': [0.3, -0.4, 0.1]},\n        # Case 3: n=3, phi=0.2 (x1^2 + x2^2 + x3^2), x=(-0.2,0.5,0.4)\n        {'n': 3, 'phi_type': 'quadratic', 'params': {'alpha': 0.2}, 'x': [-0.2, 0.5, 0.4]},\n        # Case 4: n=2, phi=-0.3 (x1^2 + x2^2), x=(0.6,-0.4)\n        {'n': 2, 'phi_type': 'quadratic', 'params': {'alpha': -0.3}, 'x': [0.6, -0.4]},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        phi_type = case['phi_type']\n        params = case['params']\n        x = case['x']\n        res = run_test_case(n, phi_type, params, x, tol=1e-10)\n        results.append(res)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3077229"}]}