{"hands_on_practices": [{"introduction": "里奇流在二维曲面上的作用是改变度规的共形因子。因此，在研究度规如何随时间演化之前，我们必须首先理解在静态的共形变换下，基本的几何量（如长度、角度和面积）是如何变化的。这个练习 [@problem_id:3060653] 为我们掌握曲面上的里奇流奠定了至关重要的计算基础。", "problem": "设 $(M,g)$ 是一个维度为 $2$ 的光滑、有向黎曼曲面，并设 $(x^{1},x^{2})$ 是一个正定向的局部坐标卡，其中度量分量为 $g_{ij}=g\\left(\\frac{\\partial}{\\partial x^{i}},\\frac{\\partial}{\\partial x^{j}}\\right)$。将与 $g$ 相关联的面积元记为 $d\\mu_{g}$，在局部坐标中定义为 $d\\mu_{g}=\\sqrt{\\det\\left(g_{ij}\\right)}\\,dx^{1}\\wedge dx^{2}$。设 $u:M\\to\\mathbb{R}$ 是一个光滑函数，并考虑共形相关的度量 $g'=e^{2u}g$。\n\n仅从黎曼长度、角度的定义、面积元的坐标表达式以及关于行列式的基本线性代数知识出发，完成以下任务：\n- 确定切向量 $v\\in T_{p}M$ 的长度 $\\|v\\|_{g}$ 如何变换为 $\\|v\\|_{g'}$。\n- 确定两个非零切向量 $v,w\\in T_{p}M$ 之间的夹角如何变换，其中在度量 $h$ 下的角度 $\\theta$ 通过 $\\cos\\theta=\\dfrac{h(v,w)}{\\|v\\|_{h}\\,\\|w\\|_{h}}$ 定义。\n- 计算变换后的面积元 $d\\mu_{g'}$，用 $d\\mu_{g}$ 和 $u$ 表示。\n\n将满足 $d\\mu_{g'}=F(u)\\,d\\mu_{g}$ 的乘法因子 $F(u)$ 作为你的最终答案。最终答案必须是单一的闭式解析表达式。无需四舍五入。", "solution": "问题要求分析在一个二维黎曼曲面上，几何量在度量的共形变换下如何变化。设 $(M,g)$ 是一个维度为 $2$ 的光滑、有向黎曼曲面。设 $u:M\\to\\mathbb{R}$ 是一个光滑函数。共形相关的度量由 $g' = e^{2u}g$ 给出。我们将按顺序解决问题的三个部分。\n\n首先，我们确定切向量长度的变换。设 $p \\in M$ 是一个点， $v \\in T_p M$ 是点 $p$ 处的一个切向量。$v$ 关于度量 $g$ 的长度定义为 $\\|v\\|_g = \\sqrt{g(v,v)}$。为了找到 $v$ 关于新度量 $g'$ 的长度，记为 $\\|v\\|_{g'}$，我们使用相同的定义：\n$$\n\\|v\\|_{g'} = \\sqrt{g'(v,v)}\n$$\n度量 $g$ 和 $g'$ 通过 $g' = e^{2u}g$ 相关联。这意味着对于任意一对切向量 $v, w \\in T_p M$，其内积由 $g'(v,w)|_p = e^{2u(p)} g(v,w)|_p$ 给出。将此应用于 $v=w$ 的情况，我们有：\n$$\ng'(v,v) = e^{2u}g(v,v)\n$$\n这里，$u$ 是在点 $p$ 处取值的。将此代入 $\\|v\\|_{g'}$ 的表达式中：\n$$\n\\|v\\|_{g'} = \\sqrt{e^{2u}g(v,v)} = \\sqrt{e^{2u}} \\sqrt{g(v,v)}\n$$\n由于 $u$ 是一个实值函数，$e^{2u}$ 总是正的，所以 $\\sqrt{e^{2u}} = e^u$。因此，我们找到了长度之间的关系：\n$$\n\\|v\\|_{g'} = e^{u} \\|v\\|_g\n$$\n在共形变换下，切向量的长度被缩放了一个因子 $e^u$。\n\n第二，我们确定两个非零切向量之间的夹角如何变换。设 $v, w \\in T_p M$ 是两个非零切向量。它们之间关于度量 $g$ 的夹角 $\\theta_g$ 由以下关系定义：\n$$\n\\cos\\theta_g = \\frac{g(v,w)}{\\|v\\|_g \\|w\\|_g}\n$$\n类似地，关于度量 $g'$ 的夹角 $\\theta_{g'}$ 定义为：\n$$\n\\cos\\theta_{g'} = \\frac{g'(v,w)}{\\|v\\|_{g'} \\|w\\|_{g'}}\n$$\n我们代入刚刚推导出的内积和长度的变换规则。分子变换如下：\n$$\ng'(v,w) = e^{2u}g(v,w)\n$$\n分母中的长度变换如下：\n$$\n\\|v\\|_{g'} = e^u \\|v\\|_g\n$$\n$$\n\\|w\\|_{g'} = e^u \\|w\\|_g\n$$\n将这些代入 $\\cos\\theta_{g'}$ 的表达式中：\n$$\n\\cos\\theta_{g'} = \\frac{e^{2u}g(v,w)}{(e^u \\|v\\|_g) (e^u \\|w\\|_g)} = \\frac{e^{2u}g(v,w)}{e^{2u} \\|v\\|_g \\|w\\|_g} = \\frac{g(v,w)}{\\|v\\|_g \\|w\\|_g}\n$$\n我们观察到右侧恰好是 $\\cos\\theta_g$ 的表达式。因此：\n$$\n\\cos\\theta_{g'} = \\cos\\theta_g\n$$\n由于角度通常取值于区间 $[0, \\pi]$，并且余弦函数在此区间上是单射的，我们可以得出结论 $\\theta_{g'} = \\theta_g$。这证实了共形变换的定义性质：它保持角度不变。\n\n第三，我们计算变换后的面积元 $d\\mu_{g'}$。在局部坐标卡 $(x^1, x^2)$ 中，度量 $h$ 的面积元由 $d\\mu_h = \\sqrt{\\det(h_{ij})} \\, dx^1 \\wedge dx^2$ 给出，其中 $h_{ij}$ 是度量 $h$ 在该坐标卡中的分量。\n对于度量 $g$，其分量为 $g_{ij} = g(\\frac{\\partial}{\\partial x^i}, \\frac{\\partial}{\\partial x^j})$，面积元为 $d\\mu_g = \\sqrt{\\det(g_{ij})} \\, dx^1 \\wedge dx^2$。对于共形变换后的度量 $g' = e^{2u}g$，其分量 $g'_{ij}$ 是：\n$$\ng'_{ij} = g'\\left(\\frac{\\partial}{\\partial x^i}, \\frac{\\partial}{\\partial x^j}\\right) = e^{2u} g\\left(\\frac{\\partial}{\\partial x^i}, \\frac{\\partial}{\\partial x^j}\\right) = e^{2u} g_{ij}\n$$\n设 $G$ 是元素为 $g_{ij}$ 的 $2 \\times 2$ 矩阵，$G'$ 是元素为 $g'_{ij}$ 的 $2 \\times 2$ 矩阵。这些矩阵之间的关系是 $G' = e^{2u}G$。我们需要计算 $G'$ 的行列式。利用行列式的性质，即对于一个 $n \\times n$ 矩阵 $A$ 和一个标量 $c$，有 $\\det(cA) = c^n \\det(A)$，对于我们的 $2 \\times 2$ 矩阵，我们有：\n$$\n\\det(g'_{ij}) = \\det(e^{2u}G) = (e^{2u})^2 \\det(G) = e^{4u} \\det(g_{ij})\n$$\n现在我们可以写出 $g'$ 的面积元：\n$$\nd\\mu_{g'} = \\sqrt{\\det(g'_{ij})} \\, dx^1 \\wedge dx^2 = \\sqrt{e^{4u} \\det(g_{ij})} \\, dx^1 \\wedge dx^2\n$$\n由于 $e^{4u}$ 是正数，我们可以将其从平方根中提出来：\n$$\nd\\mu_{g'} = \\sqrt{e^{4u}} \\sqrt{\\det(g_{ij})} \\, dx^1 \\wedge dx^2 = e^{2u} \\sqrt{\\det(g_{ij})} \\, dx^1 \\wedge dx^2\n$$\n认识到 $d\\mu_g = \\sqrt{\\det(g_{ij})} \\, dx^1 \\wedge dx^2$，我们得到了面积元的最终变换规则：\n$$\nd\\mu_{g'} = e^{2u} d\\mu_g\n$$\n问题要求满足 $d\\mu_{g'} = F(u) d\\mu_g$ 的乘法因子 $F(u)$。根据我们的推导，这个因子是 $F(u) = e^{2u}$。", "answer": "$$\\boxed{\\exp(2u)}$$", "id": "3060653"}, {"introduction": "在掌握了共形变换的基础知识后，我们可以开始求解里奇流方程本身。这个练习 [@problem_id:3060676] 考虑了一个非常特殊且富有启发性的情况：一个初始度规已经具有常曲率。通过求解这个简单的例子，我们将看到里奇流如何表现为一种简单的缩放变换，从而将抽象的偏微分方程化为具体的常微分方程，直观地揭示流的动力学行为。", "problem": "考虑一个光滑闭曲面，其上赋有一个黎曼度量 $g_{0}$，该度量具有常高斯曲率 $K_{g_{0}}$。令 $g(t)$ 按里奇流演化，该演化由偏微分方程(PDE) $\\partial_{t} g(t) = -2 \\operatorname{Ric}(g(t))$ 定义，其中 $\\operatorname{Ric}(g)$ 表示里奇张量。假设演化中的度量始终与 $g_{0}$ 位似，即 $g(t) = c(t)\\, g_{0}$，其中 $c(t)$ 是一个正的尺度因子，并假设初始条件为 $g(0) = g_{0}$，因此 $c(0) = 1$。从里奇流的基本定义和标准的曲率缩放性质出发，推导 $c(t)$ 满足的常微分方程，并计算出 $c(t)$ 关于 $t$ 和 $K_{g_{0}}$ 的显式公式。你的最终答案必须是 $c(t)$ 的一个单一闭式解析表达式。", "solution": "该问题要求我们推导并求解一个描述度规演化中尺度因子 $c(t)$ 的常微分方程。\n\n1.  **建立方程**\n\n    我们从里奇流的基本方程出发：\n    $$ \\partial_t g(t) = -2 \\mathrm{Ric}(g(t)) $$\n    在二维曲面上，里奇曲率张量 $\\mathrm{Ric}$ 与度规 $g$ 和高斯曲率 $K$ 的关系非常简单：$\\mathrm{Ric}(g) = K_g g$。因此，二维的里奇流方程简化为：\n    $$ \\partial_t g(t) = -2 K_{g(t)} g(t) $$\n    其中 $K_{g(t)}$ 是度规 $g(t)$ 的高斯曲率。\n\n2.  **代入位似关系**\n\n    问题假设演化中的度规始终与初始度规 $g_0$ 位似，即 $g(t) = c(t) g_0$，其中 $c(t)$ 是一个仅依赖于时间 $t$ 的正尺度因子。\n    我们将这个关系代入里奇流方程的两边。\n\n    方程的左边（LHS）是 $g(t)$ 对时间的导数：\n    $$ \\mathrm{LHS} = \\partial_t (c(t) g_0) = \\frac{dc(t)}{dt} g_0 = c'(t) g_0 $$\n    因为 $g_0$ 不依赖于时间。\n\n    方程的右边（RHS）涉及到演化中的度规 $g(t)$ 的高斯曲率 $K_{g(t)}$。对于共形（或位似）变换 $g = c g_0$，高斯曲率的变换法则是 $K_g = \\frac{1}{c} K_{g_0}$。因此，$K_{g(t)} = \\frac{1}{c(t)} K_{g_0}$。\n    现在我们可以写出右边的表达式：\n    $$ \\mathrm{RHS} = -2 K_{g(t)} g(t) = -2 \\left(\\frac{1}{c(t)} K_{g_0}\\right) (c(t) g_0) $$\n    尺度因子 $c(t)$ 和 $1/c(t)$ 相互抵消，得到：\n    $$ \\mathrm{RHS} = -2 K_{g_0} g_0 $$\n\n3.  **推导常微分方程（ODE）**\n\n    现在我们令左边等于右边：\n    $$ c'(t) g_0 = -2 K_{g_0} g_0 $$\n    由于 $g_0$ 是一个非退化的度规张量，我们可以从方程两边“消去”它，得到一个关于 $c(t)$ 的常微分方程：\n    $$ \\frac{dc}{dt} = -2 K_{g_0} $$\n    由于初始度规 $g_0$ 的高斯曲率 $K_{g_0}$ 是一个常数，这是一个非常简单的常微分方程。\n\n4.  **求解常微分方程**\n\n    我们对上述方程关于时间 $t$ 进行积分：\n    $$ \\int \\frac{dc}{dt} dt = \\int -2 K_{g_0} dt $$\n    $$ c(t) = -2 K_{g_0} t + C $$\n    其中 $C$ 是积分常数。\n\n    为了确定常数 $C$，我们使用初始条件 $g(0) = g_0$。在 $t=0$ 时，我们有 $g(0) = c(0) g_0$。因此，我们必须有 $c(0) = 1$。\n    将 $t=0$ 和 $c(0)=1$ 代入解中：\n    $$ c(0) = -2 K_{g_0} (0) + C = 1 $$\n    这给出 $C=1$。\n\n    因此，$c(t)$ 的显式公式为：\n    $$ c(t) = 1 - 2 K_{g_0} t $$", "answer": "$$\n\\boxed{1 - 2K_{g_{0}}t}\n$$", "id": "3060676"}, {"introduction": "里奇流的最终威力在于它能够实际“找到”一个常曲率度规，从而为均匀化定理提供了一个强大的分析证明。这项高级实践练习 [@problem_id:3063275] 将我们从纸笔理论带入计算实践。我们将通过对曲面和流方程进行离散化，数值模拟亏格为 $g \\ge 2$ 的曲面上任意初始度规如何演化为唯一的双曲度规，从而将抽象的定理转化为一个具体、可观测的过程。", "problem": "您将通过在等温坐标下离散化的共形 Ricci 流，实现并研究亏格 $g \\geq 2$ 的闭曲面上双曲度量的数值构造。目标是从二维黎曼几何的基本原理出发，编写一个程序，该程序能够构造一个三角化的亏格为 $g=2$ 的曲面，通过演化离散共形因子将离散高斯曲率驱动至与 Gauss–Bonnet 定理相容的恒定负值，并报告定量的收敛诊断结果。\n\n请从以下基本基础和定义开始。\n\n- 在局部坐标中，一个二维黎曼度量与一个参考度量是共形的，这意味着任何度量 $g$ 都可以写成 $g = e^{2u} g_{0}$ 的形式，其中 $u$ 是一个称为共形因子的标量函数，$g_{0}$ 是一个固定的参考度量。$g$ 的高斯曲率 $K_{g}$ 与 $u$ 以及 $g_{0}$ 的高斯曲率 $K_{0}$ 通过一个关系式相联系，该关系式源于共形坐标中曲率的定义以及 $g_{0}$ 的 Laplace–Beltrami 算子。在二维情况下，Ricci 流通过偏微分方程 $\\partial_{t} g = -2 K_{g} g$ 来演化度量，该过程保持共形类。Gauss–Bonnet 定理指出，对于一个闭曲面 $M$，有 $\\int_{M} K_{g} \\, dA_{g} = 2 \\pi \\chi(M)$，其中 $\\chi(M)$ 是 $M$ 的欧拉示性数。\n\n- 在一个闭的三角化曲面上的离散设置中，顶点的离散高斯曲率定义为角亏：在顶点 $i$ 处，曲率 $K_{i}$ 是 $2 \\pi$ 减去所有与 $i$ 相邻的三角形在顶点 $i$ 处的内角之和，其中每个三角形都是一个欧几里得三角形，其边长由度量给出。离散共形变化由顶点权重 $u_{i}$ 表示，它通过一个依赖于 $u_{i}$ 和 $u_{j}$ 的因子来缩放每条边长 $l_{ij}$，使得 $l_{ij}$ 的变化方式模拟了光滑度量的共形变化。\n\n任务：\n\n1) 从 Ricci 流方程 $\\partial_{t} g = -2 K_{g} g$ 和曲面上的共形表示 $g = e^{2u} g_{0}$ 出发，推导标量场 $u$ 的演化方程以及表征同一共形类中恒定高斯曲率度量的稳态方程。解释为什么对于欧拉示性数 $\\chi(M)  0$ 的闭曲面，归一化 Ricci 流在保持面积的同时收敛到一个具有恒定负高斯曲率的度量，并说明 Gauss–Bonnet 定理如何确定平均曲率。\n\n2) 构造一个适合在三角化曲面上进行计算的离散模拟。使用顶点的角亏作为离散高斯曲率，并使用顶点权重对边长进行共形缩放。根据您在第1项中的推导，为顶点权重 $u_{i}$ 设计一个显式时间步进格式，该格式倾向于将离散曲率 $K_{i}$ 驱动至与 Gauss–Bonnet 定理一致的恒定目标值。解释如何选择每个顶点的目标曲率 $K_{i}^{\\star}$，以使得 $\\sum_{i} K_{i}^{\\star} = 2 \\pi \\chi(M)$ 且目标在所有顶点上是恒定的，并说明为什么这代表了在全局尺度下的单值化的离散模拟。\n\n3) 通过取两个三角化环面的连通和，构造一个亏格为 $g=2$ 的闭合三角化曲面。每个环面应通过对一个对边认同的正方形上的 $3 \\times 3$ 网格进行周期性三角剖分来生成；将每个单元格以一致的定向三角化为两个三角形，以使结果成为环面的一个闭合三角剖分。为了形成连通和，从每个环面中移除一个三角形，并将一个被移除三角形的三个边界顶点与另一个被移除三角形的三个边界顶点以反向循环顺序进行认同，以保持定向。通过计算 $V - E + F$ 来验证所得三角剖分的欧拉示性数为 $\\chi = -2$，其中 $V$ 是顶点数，$E$ 是边数，$F$ 是面数。对参考度量使用单位基础边长。\n\n4) 在第3项中得到的亏格为 $g=2$ 的三角剖分上，实现您在第2项中推导的离散等温 Ricci 流。从所有顶点处的 $u_{i} = 0$ 开始。在每一步中，根据当前边长计算每个三角形中的欧几里得角和每个顶点的离散高斯曲率，然后根据您的显式时间步进格式更新共形权重。使用任何简单的机制来确保数值稳定性，例如夹紧 arccosine 函数的参数或使用回溯步长规则。\n\n5) 使用与目标的最大绝对曲率偏差来解释收敛性，即 $E_{\\infty} = \\max_{i} \\lvert K_{i} - K_{i}^{\\star} \\rvert$。对于下面的每个测试用例，从相同的初始状态开始运行流固定的迭代次数，并以浮点数形式报告最终的 $E_{\\infty}$。\n\n测试套件：\n\n- 案例 A：时间步长 $\\Delta t = 0.05$，迭代次数 $N = 12000$。\n\n- 案例 B：时间步长 $\\Delta t = 0.02$，迭代次数 $N = 12000$。\n\n- 案例 C：时间步长 $\\Delta t = 0.08$，迭代次数 $N = 8000$。\n\n最终输出格式：\n\n您的程序必须生成单行输出，其中包含三个案例的最终 $E_{\\infty}$ 值的逗号分隔列表，按 A、B、C 的顺序排列，并用方括号括起来。例如，输出应类似于 $[x_{A},x_{B},x_{C}]$，其中每个 $x_{\\bullet}$ 是一个浮点数。输出中不允许有任何额外的文本或换行。", "solution": "该问题是有效的。它提出了一个在计算微分几何领域内定义明确、有科学依据的任务，其根植于已建立的 Ricci 流理论和曲面单值化定理。该问题是自洽的，提供了所有必要的定义和一套清晰的任务，导向一个数值实现。亏格为二的曲面的构造是一个标准的拓扑学步骤，而离散 Ricci 流公式是该领域中一个已知且有效的方法。\n\n解决方案遵循问题陈述中概述的五个任务进行。\n\n首先，我们按照任务1的要求，处理曲面上 Ricci 流的连续理论。黎曼度量 $g$ 的 Ricci 流方程是 $\\partial_{t} g = -2 K_{g} g$，其中 $K_{g}$ 是 $g$ 的高斯曲率。在一个二维曲面上，任何度量 $g$ 都通过一个标量函数 $u$（共形因子）与一个固定的参考度量 $g_{0}$ 共形相关：$g = e^{2u} g_{0}$。为了找到 $u$ 的演化方程，我们将此关系对时间 $t$ 求导：$\\partial_{t} g = \\partial_{t}(e^{2u}) g_{0} = (2e^{2u} \\partial_{t}u) g_{0}$。由于 $g_{0} = e^{-2u} g$，这变为 $\\partial_{t} g = (2 \\partial_{t}u) g$。将此与 Ricci 流方程相等，得到 $2(\\partial_{t}u)g = -2K_g g$，简化后得到共形因子的演化方程：$\\partial_{t}u = -K_{g}$。高斯曲率 $K_{g}$ 与参考度量曲率 $K_{0}$ 通过著名公式 $K_{g} = e^{-2u}(K_{0} - \\Delta_{0}u)$ 相关联，其中 $\\Delta_{0}$ 是关于 $g_{0}$ 的 Laplace-Beltrami 算子。因此，$u$ 的流方程为 $\\partial_{t}u = -e^{-2u}(K_{0} - \\Delta_{0}u)$。\n\n具有恒定高斯曲率的度量不是这个流的稳态解，而是归一化 Ricci 流的稳态解，后者保持总曲面面积。归一化流由 $\\partial_{t} g = (-2K_{g} + 2\\bar{K})g$ 给出，其中 $\\bar{K} = (\\int_{M} K_{g} dA_{g}) / (\\int_{M} dA_{g})$ 是平均曲率。对应的 $u$ 的演化是 $\\partial_{t}u = -K_{g} + \\bar{K}$。一个稳态解（$\\partial_{t}u=0$）意味着在曲面上所有点都有 $K_{g} = \\bar{K}$，这是一个具有恒定高斯曲率的度量。Gauss–Bonnet 定理 $\\int_{M} K_{g} \\, dA_{g} = 2 \\pi \\chi(M)$ 固定了平均曲率。由于归一化流保持总面积 $A = \\int_{M} dA_{g}$ 不变，目标曲率是恒定的：$\\bar{K} = \\frac{2\\pi \\chi(M)}{A}$。对于亏格 $g \\geq 2$ 的闭曲面，欧拉示性数 $\\chi(M) = 2-2g$ 是负的，所以单值化度量具有恒定的负曲率。\n\n其次，对于任务2，我们构造一个离散模拟。曲面由一个三角剖分 $(V, E, F)$ 表示。离散度量由所有边长集合 $\\{l_{ij}\\}$ 给出。离散共形变换通过顶点权重 $\\{u_{i}\\}$ 实现，这些权重缩放具有长度 $\\{l_{ij}^{0}\\}$ 的参考度量。顶点 $i$ 和 $j$ 之间的边的相应新边长由 $l_{ij} = l_{ij}^{0} e^{(u_{i}+u_{j})/2}$ 给出。顶点 $i$ 处的离散高斯曲率定义为角亏，$K_{i} = 2\\pi - \\sum_{\\triangle_{ijk} \\ni i} \\theta_{i}^{jk}$，其中求和遍历所有与顶点 $i$ 相邻的三角形。具有顶点 $(i,j,k)$ 的三角形内的角 $\\theta_{i}^{jk}$ 使用余弦定理从边长计算得出：$\\theta_{i}^{jk} = \\arccos\\left(\\frac{l_{ij}^2 + l_{ik}^2 - l_{jk}^2}{2 l_{ij} l_{ik}}\\right)$。连续的归一化 Ricci 流方程 $\\partial_{t}u = -K_{g} + \\bar{K}$ 使用前向欧拉格式在时间上进行离散化，从而得到顶点权重的更新规则：$u_{i}(t+\\Delta t) = u_{i}(t) + \\Delta t(-K_{i}(t) + K_{i}^{\\star})$。因此，显式时间步进格式为 $u_{i} \\leftarrow u_{i} - \\Delta t (K_{i} - K_{i}^{\\star})$。离散 Gauss-Bonnet 定理指出 $\\sum_{i \\in V} K_i = 2\\pi\\chi(M)$。为了达到恒定曲率的状态，我们为所有顶点 $i \\in V$ 设置一个恒定的目标曲率 $K_{i}^{\\star} = K^{\\star}$。对所有顶点求和得到 $|V|K^{\\star} = 2\\pi\\chi(M)$，因此目标曲率为 $K^{\\star} = \\frac{2\\pi\\chi(M)}{|V|}$。这个过程通过数值演化顶点权重 $\\{u_i\\}$ 来寻找同一共形类中具有恒定离散高斯曲率的离散度量，从而提供了单值化定理的计算实现。\n\n第三，对于任务3，我们构造一个亏格为 $g=2$ 的闭合三角化曲面。我们从两个相同的环面开始，每个环面都由一个 $3 \\times 3$ 网格的周期性三角剖分形成。对于单个环面，这导致 $|V|=9$ 个顶点， $|F|=18$ 个面和 $|E|=27$ 条边，满足 $\\chi = 9 - 27 + 18 = 0$。为了形成连通和，我们从每个环面中选择并移除一个三角形。设被移除的三角形的顶点分别为第一个环面的 $(v_{1a}, v_{1b}, v_{1c})$ 和第二个环面的 $(v_{2a}, v_{2b}, v_{2c})$。然后，我们以反向循环顺序认同这三对边界顶点以保持可定向性，例如，映射 $v_{1a} \\leftrightarrow v_{2a}$，$v_{1b} \\leftrightarrow v_{2c}$ 和 $v_{1c} \\leftrightarrow v_{2b}$。此操作合并了三对顶点和三对边界边。最终的三角剖分包含 $|V|=18-3=15$ 个顶点， $|F|=36-2=34$ 个面和 $|E|=54-3=51$ 条边。欧拉示性数为 $\\chi = |V| - |E| + |F| = 15 - 51 + 34 = -2$，这正确地对应于一个亏格为 $g=2$ 的曲面，因为 $\\chi = 2 - 2g = 2 - 4 = -2$。参考度量通过将所有初始边长 $l_{ij}^{0}$ 设置为 $1$ 来定义。\n\n第四，对于任务4，我们详细说明离散 Ricci 流算法的实现。该过程始于如上所述构造亏格为2的三角剖分。我们将共形权重初始化为零，即对于所有顶点 $u_i = 0$，这意味着初始度量是所有边长等于1的参考度量。目标曲率计算为 $K^{\\star} = 2\\pi(-2)/15 = -4\\pi/15$。模拟按指定的迭代次数 $N$ 进行。在每次迭代中，执行以下步骤：\n1. 对于三角剖分中的所有边，计算当前边长 $l_{ij} = e^{(u_i+u_j)/2}$。\n2. 通过对内角求和来计算所有顶点的离散高斯曲率 $K_i$。对于每个三角形，使用余弦定理找到其三个内角。为确保数值稳定性，`arccos` 函数的参数被夹紧到区间 $[-1, 1]$ 内。每个顶点的角度总和从 $2\\pi$ 中减去，以获得角亏。\n3. 使用规则更新共形权重：$u_i \\leftarrow u_i - \\Delta t (K_i - K^{\\star})$。\n这个迭代过程将顶点曲率 $K_i$ 驱动至目标值 $K^{\\star}$。\n\n第五，对于任务5，使用曲率误差的 $L^{\\infty}$-范数 $E_{\\infty} = \\max_{i} \\lvert K_{i} - K^{\\star} \\rvert$ 来评估收敛性。该度量量化了任何顶点曲率与恒定目标值的最大偏差。对指定的三个测试用例运行算法，并报告每个用例的最终 $E_{\\infty}$ 值。最终输出是这三个浮点数的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_genus2_surface():\n    \"\"\"\n    Constructs a closed triangulated surface of genus g=2.\n\n    The construction starts with two tori, each formed from a 3x3 grid.\n    One triangle is removed from each torus, and the boundaries are identified\n    in reverse cyclic order to form a connected sum.\n\n    Returns:\n        tuple: A tuple containing:\n            - final_faces (list): A list of tuples, where each tuple represents a face\n              as a set of three vertex indices.\n            - V (int): The number of vertices.\n            - E (int): The number of edges.\n            - F (int): The number of faces.\n            - edges (set): A set of tuples representing unique edges.\n    \"\"\"\n    # 1. Create faces for a single torus from a 3x3 grid\n    torus_faces = []\n    for i in range(3):\n        for j in range(3):\n            p00 = 3 * i + j\n            p10 = 3 * ((i + 1) % 3) + j\n            p01 = 3 * i + ((j + 1) % 3)\n            p11 = 3 * ((i + 1) % 3) + ((j + 1) % 3)\n            # Triangulate each square cell consistently\n            torus_faces.append(tuple(sorted((p00, p10, p11))))\n            torus_faces.append(tuple(sorted((p00, p11, p01))))\n\n    # 2. Create two disjoint tori\n    faces1 = torus_faces\n    faces2 = [tuple(v + 9 for v in face) for face in faces1]\n    all_faces = faces1 + faces2\n\n    # 3. Perform surgery (connected sum)\n    # Select triangles to remove.\n    # Triangle from torus 1: (0, 1, 4) from vertices (0,0), (0,1), (1,1)\n    # Corresponding triangle from torus 2: (9, 10, 13)\n    f1_remove = tuple(sorted((0, 4, 1)))\n    f2_remove = tuple(sorted((9, 13, 10)))\n\n    # Boundary vertices of f1 are {0, 1, 4}\n    # Boundary vertices of f2 are {9, 10, 13}\n    # Identification in reversed cyclic order: 0-9, 1-13, 4-10\n    id_map = {9: 0, 13: 1, 10: 4}\n\n    # Apply identification and remove the two faces\n    new_faces = []\n    for face in all_faces:\n        if face != f1_remove and face != f2_remove:\n            new_face = tuple(id_map.get(v, v) for v in face)\n            new_faces.append(new_face)\n            \n    # 4. Re-index vertices to be contiguous from 0 to V-1\n    used_vertices = sorted(list(set(v for face in new_faces for v in face)))\n    reindex_map = {old_v: new_v for new_v, old_v in enumerate(used_vertices)}\n    \n    final_faces = [tuple(reindex_map[v] for v in face) for face in new_faces]\n\n    V = len(used_vertices)\n    F = len(final_faces)\n\n    # 5. Calculate number of edges and verify Euler characteristic\n    edges = set()\n    for face in final_faces:\n        v = sorted(face)\n        edges.add((v[0], v[1]))\n        edges.add((v[0], v[2]))\n        edges.add((v[1], v[2]))\n    E = len(edges)\n\n    chi = V - E + F\n    if chi != -2:\n        raise ValueError(f\"Euler characteristic is {chi}, expected -2.\")\n\n    return final_faces, V, E, F, edges\n\ndef run_ricci_flow(faces, V, edges, dt, n_iter):\n    \"\"\"\n    Runs the discrete Ricci flow simulation.\n    \n    Args:\n        faces (list): List of triangle faces.\n        V (int): Number of vertices.\n        edges (set): Set of unique edges.\n        dt (float): Time step for the simulation.\n        n_iter (int): Number of iterations.\n        \n    Returns:\n        float: The final L-infinity error of the curvature.\n    \"\"\"\n    # Initialize conformal factors u_i = 0\n    u = np.zeros(V, dtype=np.float64)\n\n    # Calculate target curvature\n    chi = -2\n    K_star = 2.0 * np.pi * chi / V\n\n    # Pre-build vertex-to-face mapping for efficiency\n    vertex_face_map = [[] for _ in range(V)]\n    for i, face in enumerate(faces):\n        for vertex_idx in face:\n            vertex_face_map[vertex_idx].append(i)\n\n    # Main simulation loop\n    for _ in range(n_iter):\n        # 1. Compute current edge lengths\n        edge_lengths = {}\n        for v1, v2 in edges:\n            # l_ij = l_ij^0 * exp((u_i + u_j)/2), with l_ij^0 = 1\n            length = np.exp((u[v1] + u[v2]) / 2.0)\n            edge_lengths[tuple(sorted((v1, v2)))] = length\n\n        # 2. Compute angles and curvatures\n        K = np.full(V, 2.0 * np.pi, dtype=np.float64)\n        for face in faces:\n            v_i, v_j, v_k = face\n            \n            l_ij = edge_lengths[tuple(sorted((v_i, v_j)))]\n            l_jk = edge_lengths[tuple(sorted((v_j, v_k)))]\n            l_ki = edge_lengths[tuple(sorted((v_k, v_i)))]\n\n            # Law of cosines, with clamping for numerical stability\n            cos_i = (l_ki**2 + l_ij**2 - l_jk**2) / (2.0 * l_ki * l_ij)\n            cos_j = (l_ij**2 + l_jk**2 - l_ki**2) / (2.0 * l_ij * l_jk)\n            cos_k = (l_jk**2 + l_ki**2 - l_ij**2) / (2.0 * l_jk * l_ki)\n\n            angle_i = np.arccos(np.clip(cos_i, -1.0, 1.0))\n            angle_j = np.arccos(np.clip(cos_j, -1.0, 1.0))\n            angle_k = np.arccos(np.clip(cos_k, -1.0, 1.0))\n\n            K[v_i] -= angle_i\n            K[v_j] -= angle_j\n            K[v_k] -= angle_k\n\n        # 3. Update conformal factors u\n        u = u - dt * (K - K_star)\n\n    # Recalculate final curvatures after loop for error measurement\n    edge_lengths = {}\n    for v1, v2 in edges:\n        length = np.exp((u[v1] + u[v2]) / 2.0)\n        edge_lengths[tuple(sorted((v1, v2)))] = length\n    \n    K_final = np.full(V, 2.0 * np.pi, dtype=np.float64)\n    for face in faces:\n        v_i, v_j, v_k = face\n        l_ij = edge_lengths[tuple(sorted((v_i, v_j)))]\n        l_jk = edge_lengths[tuple(sorted((v_j, v_k)))]\n        l_ki = edge_lengths[tuple(sorted((v_k, v_i)))]\n\n        cos_i = (l_ki**2 + l_ij**2 - l_jk**2) / (2.0 * l_ki * l_ij)\n        cos_j = (l_ij**2 + l_jk**2 - l_ki**2) / (2.0 * l_ij * l_jk)\n        cos_k = (l_jk**2 + l_ki**2 - l_ij**2) / (2.0 * l_jk * l_ki)\n\n        angle_i = np.arccos(np.clip(cos_i, -1.0, 1.0))\n        angle_j = np.arccos(np.clip(cos_j, -1.0, 1.0))\n        angle_k = np.arccos(np.clip(cos_k, -1.0, 1.0))\n\n        K_final[v_i] -= angle_i\n        K_final[v_j] -= angle_j\n        K_final[v_k] -= angle_k\n\n    # 4. Calculate final L-infinity error\n    E_infinity = np.max(np.abs(K_final - K_star))\n    return E_infinity\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'dt': 0.05, 'n_iter': 12000},  # Case A\n        {'dt': 0.02, 'n_iter': 12000},  # Case B\n        {'dt': 0.08, 'n_iter': 8000},   # Case C\n    ]\n\n    # Build the surface once\n    faces, V, E, F, edges = build_genus2_surface()\n\n    results = []\n    for case in test_cases:\n        dt = case['dt']\n        n_iter = case['n_iter']\n        \n        # Run the simulation for the current case\n        final_error = run_ricci_flow(faces, V, edges, dt, n_iter)\n        results.append(final_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\nsolve()\n```", "id": "3063275"}]}