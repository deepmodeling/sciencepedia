{"hands_on_practices": [{"introduction": "研究二元二次型的第一步是对其进行分类。本练习将指导你设计一个算法，用于枚举给定判别式的所有“简约”二次型，这些简约二次型是每个等价类的唯一代表。通过实现这个基本过程 [@problem_id:3082340]，你将为探索二次型的世界构建起一套必要的工具。", "problem": "考虑一个具有整数系数 $a$、$b$ 和 $c$ 的二元二次型 $f(x,y)=ax^2+bxy+cy^2$。$f$ 的判别式是整数 $D=b^2-4ac$。如果 $D0$ 且 $a>0$，则该形式称为正定形式。如果一个正定形式满足不等式 $|b|\\le a\\le c$，并且在边界情况 $|b|=a$ 或 $a=c$ 时，还额外满足 $b\\ge 0$，则称该形式为约化形式。作为一个基本事实，任何整系数二元二次型的判别式都满足 $D\\equiv 0$ 或 $D\\equiv 1\\pmod{4}$。\n\n使用这些核心定义和事实，设计并实现一个算法，在给定一个负判别式 $D0$ 的情况下，列出所有判别式为 $D$ 的约化正定二元二次型。你的算法必须依赖于从约化不等式与 $D=b^2-4ac0$ 共同推导出的界限 $a\\le \\sqrt{|D|/3}$，以确保对 $a$ 的搜索是有限的。该算法必须：\n- 拒绝不满足 $D\\equiv 0$ 或 $D\\equiv 1\\pmod{4}$ 的 $D$，对此类 $D$ 返回一个空列表。\n- 枚举所有满足 $a>0$ 的整数三元组 $(a,b,c)$，它们需满足 $D=b^2-4ac$、严格不等式 $-a  b \\le a$ 和 $a \\le c$。\n- 对每个生成的三元组 $(a,b,c)$，必须验证它是约化的，即除了已经通过循环强制执行的条件外，还需满足 $a \\le c$ 和“如果 $a=c$，则 $b\\ge 0$”的边界条件。", "solution": "如上所述，该问题在形式上是合理的，并在数论这一数学学科中构成了一个适定问题。所有的定义、约束和目标都清晰且内部一致。该问题植根于二元二次型的标准理论，并且所提出的算法约束（包括系数 $a$ 的界限）都是从基本原理中得出的正确推论。因此，我将继续提供一个完整的解决方案。\n\n目标是对于给定的负判别式 $D = b^2 - 4ac  0$，枚举所有约化正定二元二次型 $f(x,y) = ax^2 + bxy + cy^2$。系数 $a$、$b$ 和 $c$ 均为整数。\n\n如果一个二元二次型的判别式 $D  0$ 且首项系数 $a > 0$，则该形式被定义为正定的。如果一个形式满足不等式 $|b| \\le a \\le c$，则它被认为是约化的。此外，还施加了一个边界条件：如果 $|b|=a$ 或 $a=c$，那么系数 $b$ 必须是非负的，即 $b \\ge 0$。\n\n任何整系数二元二次型判别式的一个基本性质是，它必须模 $4$ 同余于 $0$ 或 $1$。也就是说，$D \\equiv 0 \\pmod{4}$ 或 $D \\equiv 1 \\pmod{4}$。任何不满足此条件的整数 $D$ 都不能是这种形式的判别式。\n\n寻找给定判别式 $D$ 的所有约化形式的算法利用了这些定义和性质来构建一个有限的搜索。\n\n**算法步骤**\n\n1.  **判别式有效性检查：** 第一步是验证输入的判别式 $D$。如果 $D$ 不满足同余式 $D \\equiv 0 \\pmod{4}$ 或 $D \\equiv 1 \\pmod{4}$，则不存在判别式为 $D$ 的整系数形式。在这种情况下，约化形式的集合为空。\n\n2.  **建立搜索界限：** 对于一个约化正定形式，其系数受到不等式 $|b| \\le a \\le c$ 的约束。我们可以利用这一点来推导系数 $a$ 的一个界限。判别式为 $D = b^2 - 4ac$。由于形式是正定的，所以 $D  0$。令 $|D| = -D$。判别式方程可以写成 $4ac = b^2 + |D|$。\n    根据约化条件，我们有 $b^2 \\le a^2$ 和 $c \\ge a$。将这些代入判别式关系中，得到：\n    $$4a^2 \\le 4ac = b^2 + |D| \\le a^2 + |D|$$\n    这意味着 $3a^2 \\le |D|$，从而得出 $a^2 \\le |D|/3$。由于对于正定形式 $a > 0$，我们得到了一个对 $a$ 进行搜索的关键上界：\n    $$a \\le \\sqrt{\\frac{|D|}{3}}$$\n    这个不等式保证了对系数 $a$ 的搜索是有限的。\n\n3.  **系统性枚举：** 算法通过迭代满足约化条件和推导出的界限的所有可能的整数值 $a$ 和 $b$ 来进行。\n    - **遍历 $a$：** 我们从 $1$ 开始遍历所有整数 $a$，直到 $\\lfloor\\sqrt{|D|/3}\\rfloor$。\n    - **遍历 $b$：** 对于每个 $a$ 值，我们遍历可能的整数值 $b$。问题陈述指定了范围 $-a  b \\le a$。这个范围等价于条件 $|b| \\le a$，并特别排除了 $b = -a$（对于 $a>0$）。这是正确的，因为约化形式的边界条件规定，如果 $|b| = a$，则 $b \\ge 0$。由于 $a>0$，这迫使 $b=a$，从而排除了 $b=-a$。\n\n4.  **确定 $c$ 并验证：** 对于在循环中找到的每一对 $(a, b)$，系数 $c$ 由判别式公式确定：\n    $$4ac = b^2 - D \\implies c = \\frac{b^2 - D}{4a}$$\n    为了使 $c$ 是一个整数，分子 $b^2 - D$ 必须是 $4a$ 的整数倍。如果满足此条件，我们就得到一个整数三元组 $(a, b, c)$。\n\n5.  **最终约化检查：** 必须对照剩余的约化条件检查这个三元组 $(a, b, c)$：\n    - $a \\le c$：计算出的 $c$ 值必须大于或等于 $a$。\n    - **边界条件：** 必须满足“如果 $|b|=a$ 或 $a=c$，则 $b \\ge 0$”的条件。如前所述，从 $-a+1$ 到 $a$ 的 $b$ 循环自动处理了 $|b|=a$ 的情况。因此，我们只需要验证 $a=c$ 的情况：如果 $a=c$，则必须有 $b \\ge 0$。\n\n任何生成并通过所有这些检查的三元组 $(a, b, c)$ 都对应于一个唯一的判别式为 $D$ 的约化正定二元二次型。算法收集所有这样的三元组。\n\n**示例演练：$D = -20$**\n\n1.  **有效性：** $D = -20 \\equiv 0 \\pmod{4}$。有效。\n2.  **界限：** $|D| = 20$。$a$ 的搜索界限是 $a \\le \\sqrt{20/3} \\approx 2.58$，所以我们搜索 $a \\in \\{1, 2\\}$。\n3.  **枚举：**\n    - 对于 $a=1$：\n        - 我们在范围 $-1  b \\le 1$ 内迭代 $b$，所以 $b \\in \\{0, 1\\}$。\n        - 如果 $b=0$：$c = \\frac{0^2 - (-20)}{4(1)} = 5$。我们得到三元组 $(1, 0, 5)$。\n            - 检查：$a \\le c$（$1 \\le 5$）为真。边界情况 $|b|=a$ 和 $a=c$ 不适用。这是一个约化形式。\n        - 如果 $b=1$：$1^2 - (-20) = 21$，不能被 $4a=4$ 整除。没有整数 $c$。\n    - 对于 $a=2$：\n        - 我们在范围 $-2  b \\le 2$ 内迭代 $b$，所以 $b \\in \\{-1, 0, 1, 2\\}$。\n        - 如果 $b=-1, 0, 1$：分子 $b^2 - (-20)$ 分别是 $21, 20, 21$。没有一个能被 $4a=8$ 整除。没有整数 $c$。\n        - 如果 $b=2$：$c = \\frac{2^2 - (-20)}{4(2)} = \\frac{24}{8} = 3$。我们得到三元组 $(2, 2, 3)$。\n            - 检查：$a \\le c$（$2 \\le 3$）为真。边界情况 $|b|=a$ 适用（$|2|=2$）。条件 $b \\ge 0$ 满足（$2 \\ge 0$）。这是一个约化形式。\n\n因此，$D=-20$ 的约化形式集合是 $\\{[1,0,5], [2,2,3]\\}$。此过程应用于所有测试用例以生成最终输出。", "answer": "```python\nimport numpy as np\n\ndef find_reduced_forms(D: int) -> list[list[int]]:\n    \"\"\"\n    Calculates all reduced positive definite binary quadratic forms for a given discriminant D.\n\n    Args:\n        D: A negative integer discriminant.\n\n    Returns:\n        A list of lists, where each inner list [a, b, c] represents a\n        reduced form. Returns an empty list if D is not a valid discriminant.\n    \"\"\"\n    # Step 1: Validate the discriminant. D must be negative and congruent to 0 or 1 mod 4.\n    if D >= 0 or (D % 4 != 0 and D % 4 != 1):\n        return []\n\n    reduced_forms = []\n    abs_D = -D\n    \n    # Step 2: Establish the search bound for 'a'.\n    a_max = int(np.sqrt(abs_D / 3.0))\n\n    # Step 3: Iterate through possible values of a and b.\n    # Loop over a from 1 up to the calculated max.\n    for a in range(1, a_max + 1):\n        # Loop over b from -a  b = a, which is range(-a + 1, a + 1).\n        # This range for b ensures that if |b|=a, then b=a > 0, satisfying one\n        # of the boundary conditions automatically.\n        for b in range(-a + 1, a + 1):\n            \n            # Step 4: Determine c and check for integer divisibility.\n            # From D = b^2 - 4ac, we have 4ac = b^2 - D.\n            numerator = b**2 - D\n            denominator = 4 * a\n            \n            if numerator % denominator == 0:\n                c = numerator // denominator\n                \n                # Step 5: Check the remaining reduction conditions.\n                # The reduction conditions are |b| = a = c and boundary rules.\n                # The loop for b ensures |b| = a.\n                \n                # Condition 1: a = c\n                cond1_a_le_c = (a = c)\n                \n                # Condition 2: Boundary condition check\n                # If a=c, we must have b >= 0. The case |b|=a is handled by the b-loop range.\n                cond2_boundary = (a != c or b >= 0)\n                \n                if cond1_a_le_c and cond2_boundary:\n                    reduced_forms.append([a, b, c])\n                        \n    return reduced_forms\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of discriminants and\n    prints the result in the specified format.\n    \"\"\"\n    test_cases = [\n        -3,\n        -4,\n        -23,\n        -20,\n        -15,\n        -14,\n    ]\n\n    all_results = []\n    for D in test_cases:\n        result = find_reduced_forms(D)\n        all_results.append(result)\n\n    # Format the final output string as per problem specification:\n    # A single line, comma-separated, enclosed in brackets, with no spaces.\n    # Example: [[[1,1,1]],[[1,0,1]],[],...]\n    output_str = '[' + ','.join([str(res).replace(' ', '') for res in all_results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "3082340"}, {"introduction": "一旦我们将二次型划分为不同的等价类，一个自然的问题便随之产生：这种分类的实际意义是什么？本练习 [@problem_id:3082328] 提供了一个实践性的答案，引导你通过计算来探索不同等价类的二次型能够表示哪些整数。你将发现一条深刻的规律：不同类别的二次型所能表示的素数集合是不同的。", "problem": "令 $f(x,y)=ax^{2}+bxy+cy^{2}$ 是一个系数为整数 $a$、$b$ 和 $c$ 的本原正定二元二次型。其判别式为 $D=b^{2}-4ac$。如果一个二次型可以通过特殊线性群 $\\mathrm{SL}_{2}(\\mathbb{Z})$ 的元素作用于变量得到另一个二次型，则称这两个二次型是真等价的。一个二次型是简约的，如果它满足 $|b|\\le a\\le c$，并且在 $|b|=a$ 或 $a=c$ 的情况下有 $b\\ge 0$。主形式是主类（类群的单位元）中唯一的简约形式。如果存在互质整数 $x$ 和 $y$ 使得 $f(x,y)=n$，则称正整数 $n$ 可被 $f$ 真表示。在本问题中，我们处理判别式 $D=-20$。\n\n从上述核心定义（二元二次型、判别式、真等价、简约形式和真表示）出发，完成以下任务：\n\n1. 确定判别式为 $D=-20$ 的所有简约本原正定二次型，并从中找出主形式。\n\n2. 对于判别式为 $D=-20$ 的主形式 $f_{1}$ 和另一个判别式相同的简约形式 $f_{2}$，对每个界 $N\\in\\{30,50,100\\}$，计算以下正整数集合：\n   - $S_{1}(N)=\\{\\,n\\in\\mathbb{Z}_{0}\\mid n\\le N,\\ \\exists x,y\\in\\mathbb{Z},\\ \\gcd(x,y)=1,\\ f_{1}(x,y)=n\\,\\}$。\n   - $S_{2}(N)=\\{\\,n\\in\\mathbb{Z}_{0}\\mid n\\le N,\\ \\exists x,y\\in\\mathbb{Z},\\ \\gcd(x,y)=1,\\ f_{2}(x,y)=n\\,\\}$。\n   - $I(N)=S_{1}(N)\\cap S_{2}(N)$。\n   - $A_{1}(N)=S_{1}(N)\\setminus S_{2}(N)$。\n   - $A_{2}(N)=S_{2}(N)\\setminus S_{1}(N)$。\n\n3. 你的程序必须仅使用从定义推导出的第一性原理逻辑来计算这些集合。具体而言，利用二次型的正定性和不等式 $f(x,y)\\le N$ 来限定对 $(x,y)$ 的整数搜索范围。你可以利用以下事实：对于固定的 $y$，满足 $f(x,y)\\le N$ 的 $x$ 值是关于 $x$ 的一个二次不等式的解；并且对于固定的 $y$，$f(x,y)$ 作为 $x$ 的函数，在 $x=-\\frac{by}{2a}$ 处取得最小值，其值为 $\\frac{-D}{4a}\\,y^{2}$，从而推导出对 $|y|$ 的一个界。不允许使用任何其他关于表示的现成结果。\n\n4. 测试套件和要求的输出：\n   - 使用你在步骤1中找到的两个简约形式，将主形式记为 $f_{1}$，另一个简约形式记为 $f_{2}$。\n   - 使用界 $N=30$、$N=50$ 和 $N=100$。\n   - 对于 $N=30$ 和 $N=50$，按顺序 $[\\ |S_{1}(N)|,\\ |S_{2}(N)|,\\ |I(N)|,\\ |A_{1}(N)|,\\ |A_{2}(N)|\\ ]$ 输出包含整数计数的摘要。\n   - 对于 $N=100$，按顺序 $[\\ S_{1}(100),\\ S_{2}(100),\\ I(100),\\ A_{1}(100),\\ A_{2}(100)\\ ]$ 输出详细的已排序列表。\n   - 最终输出格式：你的程序应该生成单行输出，包含一个含三项的列表，即 $N=30$ 和 $N=50$ 的两个计数摘要，后面跟着 $N=100$ 的详细列表。确切地说，该行必须是如下形式：\n     $$\n     [\\ [c_{1,30},c_{2,30},c_{I,30},c_{A_{1},30},c_{A_{2},30}],\\ [c_{1,50},c_{2,50},c_{I,50},c_{A_{1},50},c_{A_{2},50}],\\ [\\ S_{1}(100),\\ S_{2}(100),\\ I(100),\\ A_{1}(100),\\ A_{2}(100)\\ ]\\ ].\n     $$\n   不涉及物理单位或角度。\n\n你的最终答案必须是如下所述的一个完整的、可运行的程序，该程序需精确地以上述格式打印一行输出。答案必须按要求表示为整数或整数列表，每个列表都按升序排序且不含重复项。", "solution": "我们从二元二次型、判别式、简约形式和真表示的定义开始。令 $f(x,y)=ax^{2}+bxy+cy^{2}$ 为一个本原正定形式，因此 $a>0$, $c>0$, 且 $D=b^{2}-4ac0$。对于 $D0$，简约条件是 $|b|\\le a\\le c$，并且如果 $|b|=a$ 或 $a=c$，则 $b\\ge 0$。正整数 $n$ 可被 $f$ 真表示意味着存在整数 $x$ 和 $y$ 且 $\\gcd(x,y)=1$ 使得 $f(x,y)=n$。\n\n步骤 1：找出判别式为 $D=-20$ 的简约形式，并确定主形式。\n\n我们在简约约束条件下求解 $b^{2}-4ac=-20$。因为 $D\\equiv 0\\pmod{4}$，系数 $b$ 必须是偶数。我们检查小的偶数 $b$ 和整数对 $(a,c)$。\n\n- 情况 $b=0$：则 $-4ac=-20$，因此 $ac=5$。在 $a\\le c$ 和 $a>0$ 的条件下，我们得到 $(a,c)=(1,5)$。该形式为 $(a,b,c)=(1,0,5)$。它满足 $|b|=0\\le a=1\\le c=5$，是简约的。这是主形式，因为它在简约形式列表中的 $a=1$。\n\n- 情况 $b=\\pm 2$：则 $4-4ac=-20$，因此 $4ac=24$ 且 $ac=6$。考虑到 $a\\le c$ 和 $|b|\\le a$，我们取 $(a,c)=(2,3)$。当 $|b|=a$ 时，简约条件要求 $b\\ge 0$，因此 $(a,b,c)=(2,2,3)$ 是简约且本原的。\n\n- 情况 $|b|\\ge 4$：对于 $b=\\pm 4$，我们得到 $16-4ac=-20$，因此 $ac=9$。约束 $|b|\\le a$ 强制 $a\\ge 4$，但在 $a\\le c$ 条件下对 $ac=9$ 进行因式分解，没有满足 $a\\ge 4$ 的解。更大的 $|b|$ 在 $a\\le c$ 条件下也没有解。\n\n因此，判别式为 $D=-20$ 的简约本原正定二次型恰好是 $(1,0,5)$ 和 $(2,2,3)$，其中 $(1,0,5)$ 是主形式。\n\n步骤 2：计算两种形式在界 $N$ 内所表示的数集。\n\n令 $f_{1}(x,y)=x^{2}+5y^{2}$ 和 $f_{2}(x,y)=2x^{2}+2xy+3y^{2}$。对于给定的 $N$，我们定义\n- $S_{1}(N)=\\{\\,n\\le N:\\exists x,y\\in\\mathbb{Z},\\ \\gcd(x,y)=1,\\ f_{1}(x,y)=n\\,\\}$，\n- $S_{2}(N)=\\{\\,n\\le N:\\exists x,y\\in\\mathbb{Z},\\ \\gcd(x,y)=1,\\ f_{2}(x,y)=n\\,\\}$，\n以及比较集合 $I(N)=S_{1}(N)\\cap S_{2}(N)$、$A_{1}(N)=S_{1}(N)\\setminus S_{2}(N)$、$A_{2}(N)=S_{2}(N)\\setminus S_{1}(N)$。\n\n步骤 3：从第一性原理推导算法。\n\n对于固定的 $y$，二次型 $f(x,y)$ 是 $x$ 的二次函数。不等式 $f(x,y)\\le N$ 将 $x$ 约束在 $ax^{2}+bxy+cy^{2}-N\\le 0$ 的实根之间，前提是关于 $x$ 的判别式为非负。关于 $x$ 的判别式是\n$$\n\\Delta_{x}(y)=b^{2}y^{2}-4a(cy^{2}-N)=-Dy^{2}+4aN>0,\n$$\n由于 $D0$。因此，允许的整数 $x$ 满足\n$$\n\\frac{-by-\\sqrt{\\Delta_{x}(y)}}{2a}\\le x\\le \\frac{-by+\\sqrt{\\Delta_{x}(y)}}{2a}.\n$$\n因为 $x$ 必须是整数，使用带有 $\\lfloor \\sqrt{\\Delta_{x}(y)}\\rfloor$ 的整数界就足够了，这在整数层面上是精确的：\n$$\nx_{\\min}(y)=\\left\\lceil\\frac{-by-\\lfloor\\sqrt{\\Delta_{x}(y)}\\rfloor}{2a}\\right\\rceil,\\quad\nx_{\\max}(y)=\\left\\lfloor\\frac{-by+\\lfloor\\sqrt{\\Delta_{x}(y)}\\rfloor}{2a}\\right\\rfloor.\n$$\n对于固定的 $y$，$f(x,y)$ 作为 $x$ 的函数的最小值出现在 $x^{*}=-\\frac{by}{2a}$ 处，其值为\n$$\nf_{\\min}(y)=\\left(c-\\frac{b^{2}}{4a}\\right)y^{2}=\\frac{4ac-b^{2}}{4a}\\,y^{2}=\\frac{-D}{4a}\\,y^{2}.\n$$\n因此，若存在某个 $x$ 使得 $f(x,y)\\le N$，则必然有 $f_{\\min}(y)\\le N$，所以\n$$\n|y|\\le \\sqrt{\\frac{4aN}{-D}}.\n$$\n这给出了一个关于 $y$ 的完备且有限的搜索，并且对每个这样的 $y$，在整数 $x\\in[x_{\\min}(y),x_{\\max}(y)]$ 上进行有限搜索。对于遇到的每个整数对 $(x,y)$，我们检查 $\\gcd(x,y)=1$ 和 $1\\le f(x,y)\\le N$，并将 $f(x,y)$ 收集到一个集合中。最后，我们对结果集合进行排序。\n\n步骤 4：应用于 $D=-20$ 的情况。\n\n我们取 $f_{1}(x,y)=x^{2}+5y^{2}$ 和 $f_{2}(x,y)=2x^{2}+2xy+3y^{2}$。对于每个 $N\\in\\{30,50,100\\}$，我们用上述算法计算 $S_{1}(N)$ 和 $S_{2}(N)$，然后构成 $I(N)$、$A_{1}(N)$ 和 $A_{2}(N)$，并按要求的格式生成输出。\n\n程序精确地实现了上面推导的定界策略，包括界 $|y|\\le \\left\\lfloor \\sqrt{\\frac{4aN}{-D}}\\right\\rfloor$ 和使用 $\\lfloor\\sqrt{\\Delta_{x}(y)}\\rfloor$ 确定的 $x$ 的整数区间。然后它返回：\n- 对于 $N=30$: $[\\,|S_{1}(30)|,\\ |S_{2}(30)|,\\ |I(30)|,\\ |A_{1}(30)|,\\ |A_{2}(30)|\\,]$。\n- 对于 $N=50$: $[\\,|S_{1}(50)|,\\ |S_{2}(50)|,\\ |I(50)|,\\ |A_{1}(50)|,\\ |A_{2}(50)|\\,]$。\n- 对于 $N=100$: $[\\,S_{1}(100),\\ S_{2}(100),\\ I(100),\\ A_{1}(100),\\ A_{2}(100)\\,]$，每个列表都已排序。\n\n通过直接计算（由程序执行），简约形式为 $f_{1}(x,y)=x^{2}+5y^{2}$（主形式）和 $f_{2}(x,y)=2x^{2}+2xy+3y^{2}$，且直到 $N=100$ 的结果集合是不相交的，具体为\n$$\nS_{1}(100)=\\{1,5,6,9,14,21,29,30,41,45,46,49,54,61,69,70,81,86,89,94\\},\n$$\n$$\nS_{2}(100)=\\{2,3,7,10,15,18,23,27,35,42,43,47,58,63,67,82,83,87,90,98\\}.\n$$\n因此 $I(100)=\\varnothing$，$A_{1}(100)=S_{1}(100)$，且 $A_{2}(100)=S_{2}(100)$。对于 $N=30$ 和 $N=50$，用同样方法计算出的相应计数为\n$$\n[\\,8,8,0,8,8\\,]\\ \\text{对于}\\ N=30,\\quad [\\,12,12,0,12,12\\,]\\ \\text{对于}\\ N=50.\n$$\n程序以所要求的精确单行格式打印这些结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nfrom typing import List, Tuple, Set\n\ndef integer_sqrt(n: int) -> int:\n    \"\"\"Return floor(sqrt(n)) for n >= 0.\"\"\"\n    if n  0:\n        raise ValueError(\"integer_sqrt domain error\")\n    return int(math.isqrt(n))\n\ndef ceil_div(a: int, b: int) -> int:\n    \"\"\"Return ceil(a/b) for integers, b != 0.\"\"\"\n    if b == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    # Python's // is floor division; use identity ceil(a/b) = -floor((-a)/b)\n    return -(-a // b)\n\ndef reduced_forms_discriminant_neg(D: int) -> List[Tuple[int,int,int]]:\n    \"\"\"\n    Enumerate reduced primitive positive definite binary quadratic forms (a,b,c)\n    of negative discriminant D (0), satisfying |b| = a = c and if |b|=a or a=c then b >= 0.\n    Restrict to primitive forms gcd(a,b,c)=1.\n    \"\"\"\n    if D >= 0:\n        raise ValueError(\"D must be negative\")\n    forms = []\n    # Standard bound for a in reduced positive definite case: 1 = a = sqrt(|D|/3)\n    a_max = int(math.floor(math.sqrt(abs(D) / 3))) + 5  # generous bound\n    for a in range(1, a_max + 1):\n        # b congruence: D == b^2 mod 4 implies b has parity of D\n        # For D even, b even; for D odd, b odd.\n        b_parity = D % 2  # 0 if even, 1 if odd\n        # b ranges from -a to a\n        for b in range(-a, a + 1):\n            if (b % 2) != b_parity:\n                continue\n            # compute c from discriminant equation: b^2 - 4ac = D -> c = (b^2 - D) / (4a)\n            numer = b*b - D\n            denom = 4 * a\n            if numer % denom != 0:\n                continue\n            c = numer // denom\n            if a > c:\n                continue\n            # positive definite requires a > 0 and c > 0\n            if c = 0:\n                continue\n            # reduced tie-breaker: if |b| = a or a = c, then b >= 0\n            if (abs(b) == a or a == c) and b  0:\n                continue\n            # primitive:\n            if math.gcd(a, math.gcd(b, c)) != 1:\n                continue\n            # verify discriminant exactly\n            if b*b - 4*a*c != D:\n                continue\n            forms.append((a,b,c))\n    # Sort canonically: by a, then by b, then by c\n    forms.sort()\n    return forms\n\ndef represented_set_up_to_N(a: int, b: int, c: int, D: int, N: int, proper: bool = True) -> List[int]:\n    \"\"\"\n    Compute sorted list of positive integers n = N that are (properly) represented by f(x,y) = a x^2 + b x y + c y^2\n    with discriminant D = b^2 - 4ac (0). Proper means gcd(x,y)=1.\n    \"\"\"\n    if D != b*b - 4*a*c:\n        raise ValueError(\"Inconsistent discriminant\")\n    if N  1:\n        return []\n    # Bound on y from f_min(y) = (-D/(4a)) y^2 = N\n    # So |y| = sqrt(4 a N / (-D))\n    y_bound_sq = (4 * a * N) // (-D) if D  0 else 0\n    y_bound = int(math.floor(math.sqrt(y_bound_sq)))\n    represented: Set[int] = set()\n    two_a = 2 * a\n    for y in range(-y_bound, y_bound + 1):\n        # Discriminant in x for inequality f(x,y) = N\n        delta_x = -D * (y * y) + 4 * a * N  # guaranteed nonnegative\n        k = integer_sqrt(delta_x)\n        qmin = -b * y - k\n        qmax = -b * y + k\n        x_min = ceil_div(qmin, two_a)\n        x_max = qmax // two_a  # floor division\n        for x in range(x_min, x_max + 1):\n            if proper and math.gcd(x, y) != 1:\n                continue\n            n = a * x * x + b * x * y + c * y * y\n            if 1 = n = N:\n                represented.add(n)\n    return sorted(represented)\n\ndef solve():\n    # Discriminant and forms\n    D = -20\n    forms = reduced_forms_discriminant_neg(D)\n    # Identify principal form: the reduced form with a=1\n    principal_forms = [f for f in forms if f[0] == 1]\n    if not principal_forms:\n        raise RuntimeError(\"Principal form not found\")\n    f1 = principal_forms[0]  # principal: (1,0,5)\n    # Choose another reduced form distinct from principal\n    others = [f for f in forms if f != f1]\n    if not others:\n        raise RuntimeError(\"No other reduced form found\")\n    f2 = others[0]  # e.g., (2,2,3)\n\n    # Test suite bounds\n    test_Ns = [30, 50, 100]\n\n    results = []\n    for N in test_Ns:\n        S1 = represented_set_up_to_N(f1[0], f1[1], f1[2], D, N, proper=True)\n        S2 = represented_set_up_to_N(f2[0], f2[1], f2[2], D, N, proper=True)\n        set_S1 = set(S1)\n        set_S2 = set(S2)\n        I = sorted(set_S1.intersection(set_S2))\n        A1 = sorted(set_S1.difference(set_S2))\n        A2 = sorted(set_S2.difference(set_S1))\n        if N in (30, 50):\n            # summary counts\n            results.append([len(S1), len(S2), len(I), len(A1), len(A2)])\n        else:\n            # detailed lists for N=100\n            results.append([S1, S2, I, A1, A2])\n\n    # Final print statement in the exact required format.\n    print(f\"{results}\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3082328"}, {"introduction": "除了对二次型进行分类并研究它们所能表示的数之外，我们还可以通过考察其对称性来更深入地探究单个二次型的内在结构。自同构群捕捉了所有保持二次型不变的变换。在此练习中 [@problem_id:3082299]，你将计算两种基本二次型的自同构群，从而深入了解这些数学对象的特殊几何性质。", "problem": "设 $Q(x,y)=a x^{2}+b x y+c y^{2}$ 是一个整系数的二元二次型，其判别式为 $D=b^{2}-4 a c$。对于负判别式 $D$，该二次型是正定的。在每个判别式类中，主形式是满足 $a=1$ 且与 $D$ 一致的最小 $b$ 值的既约形式。\n\n定义二次型 $[a,b,c]$ 的自同构群为\n$$\\mathrm{Aut}(Q)=\\left\\{M\\in \\mathrm{SL}_{2}(\\mathbb{Z})\\mid Q(M\\cdot(x,y))=Q(x,y)\\text{ for all }(x,y)\\in\\mathbb{Z}^{2}\\right\\},$$\n其中 $\\mathrm{SL}_{2}(\\mathbb{Z})$ 表示整数上的2阶特殊线性群（行列式为1的 $2\\times 2$ 整系数矩阵构成的群）。\n\n考虑 $D=-3$ 和 $D=-4$ 的主形式：\n- 对于 $D=-3$，主形式为 $Q_{-3}(x,y)=x^{2}+x y+y^{2}$。\n- 对于 $D=-4$，主形式为 $Q_{-4}(x,y)=x^{2}+y^{2}$。\n\n仅从上述定义和正定二元二次型的基本性质（如自同构群的有限性）出发，通过给出明确的生成元并系统地排除任何其他保向自同构，来确定作为 $\\mathrm{SL}_{2}(\\mathbb{Z})$ 子群的 $\\mathrm{Aut}(Q_{-3})$ 和 $\\mathrm{Aut}(Q_{-4})$。然后，作为你的最终计算，报告 $\\mathrm{Aut}(Q_{-3})$ 和 $\\mathrm{Aut}(Q_{-4})$ 的阶。\n\n将您的最终答案以行矩阵的形式写出，该矩阵包含 $D=-3$ 和 $D=-4$ 的群阶。无需四舍五入。", "solution": "该问题要求确定主二元二次型 $Q_{-3}(x,y)=x^{2}+x y+y^{2}$ 和 $Q_{-4}(x,y)=x^{2}+y^{2}$ 的自同构群 $\\mathrm{Aut}(Q_{-3})$ 和 $\\mathrm{Aut}(Q_{-4})$。自同构群 $\\mathrm{Aut}(Q)$ 由所有使二次型 $Q$ 保持不变的矩阵 $M \\in \\mathrm{SL}_{2}(\\mathbb{Z})$ 组成。设 $M = \\begin{pmatrix} p  q \\\\ r  s \\end{pmatrix}$ 是 $\\mathrm{SL}_{2}(\\mathbb{Z})$ 中的一个矩阵，这意味着 $p, q, r, s \\in \\mathbb{Z}$ 且行列式 $ps - qr = 1$。$M$ 在向量 $(x,y)$ 上的作用将其变换为 $(x', y') = (px+qy, rx+sy)$。$M$ 属于 $\\mathrm{Aut}(Q)$ 的条件是对于所有整数 $x, y$，$Q(x', y') = Q(x,y)$。这个多项式恒等式意味着 $x$ 和 $y$ 各次幂的系数必须相同。\n\n**第一部分：确定 $\\mathrm{Aut}(Q_{-4})$**\n\n二次型为 $Q_{-4}(x,y) = x^{2}+y^{2}$。不变性条件为：\n$$Q_{-4}(px+qy, rx+sy) = (px+qy)^{2} + (rx+sy)^{2} = x^{2}+y^{2}$$\n展开左边，我们得到：\n$$(p^{2}x^{2} + 2pqxy + q^{2}y^{2}) + (r^{2}x^{2} + 2rsxy + s^{2}y^{2}) = x^{2}+y^{2}$$\n按 $x$ 和 $y$ 的幂次合并同类项：\n$$(p^{2}+r^{2})x^{2} + (2pq+2rs)xy + (q^{2}+s^{2})y^{2} = 1 \\cdot x^{2} + 0 \\cdot xy + 1 \\cdot y^{2}$$\n令 $x^{2}$、$xy$ 和 $y^{2}$ 的系数相等，得到关于整数 $p, q, r, s$ 的方程组：\n1. $p^{2}+r^{2} = 1$\n2. $2pq+2rs = 0 \\implies pq+rs = 0$\n3. $q^{2}+s^{2} = 1$\n\n由方程(1)，因为 $p, r$ 是整数，唯一可能的解是 $(p,r) \\in \\{(1,0), (-1,0), (0,1), (0,-1)\\}$。\n类似地，由方程(3)，$(q,s)$ 唯一可能的解是 $(q,s) \\in \\{(1,0), (-1,0), (0,1), (0,-1)\\}$。\n\n我们系统地检验这些可能性，同时要满足约束条件 $pq+rs=0$ 和 $ps-qr=1$。\n\n情况A：$p=1, r=0$。\n由 $pq+rs=0$，我们有 $q=0$。然后由 $q^{2}+s^{2}=1$，得到 $s^{2}=1$，所以 $s=\\pm 1$。\n行列式条件 $ps-qr=1$ 变为 $(1)s - (0)(0) = s = 1$。因此，$s=1$。\n这给出了矩阵 $M_{1} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = I$。\n\n情况B：$p=-1, r=0$。\n由 $pq+rs=0$，我们有 $-q=0$，所以 $q=0$。然后 $q^{2}+s^{2}=1$ 意味着 $s^{2}=1$，所以 $s=\\pm 1$。\n行列式条件 $ps-qr=1$ 变为 $(-1)s - (0)(0) = -s = 1$。因此，$s=-1$。\n这给出了矩阵 $M_{2} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$。\n\n情况C：$p=0, r=1$。\n由 $pq+rs=0$，我们有 $s=0$。然后 $q^{2}+s^{2}=1$ 意味着 $q^{2}=1$，所以 $q=\\pm 1$。\n行列式条件 $ps-qr=1$ 变为 $(0)(0) - q(1) = -q = 1$。因此，$q=-1$。\n这给出了矩阵 $M_{3} = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}$。\n\n情况D：$p=0, r=-1$。\n由 $pq+rs=0$，我们有 $-s=0$，所以 $s=0$。然后 $q^{2}+s^{2}=1$ 意味着 $q^{2}=1$，所以 $q=\\pm 1$。\n行列式条件 $ps-qr=1$ 变为 $(0)(0) - q(-1) = q = 1$。因此，$q=1$。\n这给出了矩阵 $M_{4} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$。\n\n对于 $(p,r)$ 没有其他可能的组合。找到的四个矩阵是：\n$$I = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}, \\quad -I = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix}, \\quad S = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix}, \\quad S^{-1} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix}$$\n我们用生成元 $S=M_3$ 来检验群结构。\n$S^{2} = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$。\n$S^{3} = S \\cdot S^{2} = \\begin{pmatrix} 0  -1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ -1  0 \\end{pmatrix} = S^{-1}$。\n$S^{4} = (S^{2})^{2} = (-I)^{2} = I$。\n群 $\\mathrm{Aut}(Q_{-4})$ 是一个由 $S$ 生成的4阶循环群。其阶为 $|\\mathrm{Aut}(Q_{-4})| = 4$。\n\n**第二部分：确定 $\\mathrm{Aut}(Q_{-3})$**\n\n二次型为 $Q_{-3}(x,y) = x^{2}+xy+y^{2}$。不变性条件为：\n$$Q_{-3}(px+qy, rx+sy) = (px+qy)^{2} + (px+qy)(rx+sy) + (rx+sy)^{2} = x^{2}+xy+y^{2}$$\n展开左边并合并同类项：\n$$(p^{2}+pr+r^{2})x^{2} + (2pq+ps+qr+2rs)xy + (q^{2}+qs+s^{2})y^{2} = 1 \\cdot x^{2} + 1 \\cdot xy + 1 \\cdot y^{2}$$\n这给出了以下方程组：\n1. $p^{2}+pr+r^{2} = 1$\n2. $q^{2}+qs+s^{2} = 1$\n3. $2pq+ps+qr+2rs = 1$\n\n我们使用行列式条件 $ps-qr=1$。将 $ps = 1+qr$ 代入方程(3)：\n$2pq+(1+qr)+qr+2rs = 1 \\implies 2pq+2qr+2rs+1=1 \\implies pq+qr+rs=0$。\n所以整数 $p,q,r,s$ 的方程组是：\n(A) $p^{2}+pr+r^{2}=1$\n(B) $q^{2}+qs+s^{2}=1$\n(C) $pq+qr+rs=0$\n(D) $ps-qr=1$\n\n从方程(A)，将其看作关于 $p$ 的一元二次方程，$p = \\frac{-r \\pm \\sqrt{r^{2}-4(r^{2}-1)}}{2} = \\frac{-r \\pm \\sqrt{4-3r^{2}}}{2}$。为了使 $p$ 为整数，$4-3r^{2}$ 必须是一个完全平方数且非负。这意味着 $r^{2} \\le 4/3$，所以 $r \\in \\{-1, 0, 1\\}$。\n如果 $r=0$, $p^{2}=1 \\implies p=\\pm1$。\n如果 $r=1$, $p^{2}+p=0 \\implies p(p+1)=0 \\implies p=0$ 或 $p=-1$。\n如果 $r=-1$, $p^{2}-p=0 \\implies p(p-1)=0 \\implies p=0$ 或 $p=1$。\n可能的 $(p,r)$ 对是：$(1,0), (-1,0), (0,1), (0,-1), (1,-1), (-1,1)$。\n类似地，由(B)可得 $(q,s)$ 的可能对是 $(1,0), (-1,0), (0,1), (0,-1), (1,-1), (-1,1)$。\n\n我们现在用这些对来检验条件 (C) 和 (D)。\n情况1：$(p,r)=(1,0)$。(D)给出 $s=1$。(C)给出 $q=0$。这意味着 $(q,s)=(0,1)$，满足(B)。矩阵：$\\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = I$。\n情况2：$(p,r)=(-1,0)$。(D)给出 $-s=1 \\implies s=-1$。(C)给出 $-q=0 \\implies q=0$。这意味着 $(q,s)=(0,-1)$，满足(B)。矩阵：$\\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$。\n情况3：$(p,r)=(0,1)$。(D)给出 $-q=1 \\implies q=-1$。(C)给出 $q+s=0 \\implies s=-q=1$。这意味着 $(q,s)=(-1,1)$，满足(B)因为 $(-1)^2+(-1)(1)+1^2=1$。矩阵：$\\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix}$。\n情况4：$(p,r)=(0,-1)$。(D)给出 $q=1$。(C)给出 $-q-s=0 \\implies s=-q=-1$。这意味着 $(q,s)=(1,-1)$，满足(B)。矩阵：$\\begin{pmatrix} 0  1 \\\\ -1  -1 \\end{pmatrix}$。\n情况5：$(p,r)=(1,-1)$。(D)给出 $s+q=1$。(C)给出 $q-q-s=0 \\implies s=0$。那么 $q=1$。这意味着 $(q,s)=(1,0)$，满足(B)。矩阵：$\\begin{pmatrix} 1  1 \\\\ -1  0 \\end{pmatrix}$。\n情况6：$(p,r)=(-1,1)$。(D)给出 $-s-q=1$。(C)给出 $-q+q+s=0 \\implies s=0$。那么 $q=-1$。这意味着 $(q,s)=(-1,0)$，满足(B)。矩阵：$\\begin{pmatrix} -1  -1 \\\\ 1  0 \\end{pmatrix}$。\n\n这就是 $\\mathrm{Aut}(Q_{-3})$ 中的6个唯一矩阵。设 $T = \\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix}$。我们计算它的幂：\n$T^{1} = \\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix}$\n$T^{2} = \\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix}^{2} = \\begin{pmatrix} -1  -1 \\\\ 1  0 \\end{pmatrix}$\n$T^{3} = T \\cdot T^{2} = \\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix} \\begin{pmatrix} -1  -1 \\\\ 1  0 \\end{pmatrix} = \\begin{pmatrix} -1  0 \\\\ 0  -1 \\end{pmatrix} = -I$\n$T^{4} = T \\cdot T^{3} = \\begin{pmatrix} 0  -1 \\\\ 1  1 \\end{pmatrix} (-I) = \\begin{pmatrix} 0  1 \\\\ -1  -1 \\end{pmatrix}$\n$T^{5} = T^{2} \\cdot T^{3} = \\begin{pmatrix} -1  -1 \\\\ 1  0 \\end{pmatrix} (-I) = \\begin{pmatrix} 1  1 \\\\ -1  0 \\end{pmatrix}$\n$T^{6} = (T^{3})^{2} = (-I)^{2} = I$\n所有6个矩阵都是 $T$ 的幂。因此，$\\mathrm{Aut}(Q_{-3})$ 是一个由 $T$ 生成的6阶循环群。其阶为 $|\\mathrm{Aut}(Q_{-3})| = 6$。\n\n最终答案要求 $\\mathrm{Aut}(Q_{-3})$ 和 $\\mathrm{Aut}(Q_{-4})$ 的阶。\n$\\mathrm{Aut}(Q_{-3})$ 的阶是 $6$。\n$\\mathrm{Aut}(Q_{-4})$ 的阶是 $4$。\n问题要求的是 $D=-3$ 和 $D=-4$ 的群阶对。", "answer": "$$\n\\boxed{\n\\begin{pmatrix} 6  4 \\end{pmatrix}\n}\n$$", "id": "3082299"}]}