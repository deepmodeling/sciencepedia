{"hands_on_practices": [{"introduction": "Rogers-Ramanujan 恒等式的一个核心特征是其优美的无限乘积形式。然而，我们如何从这个紧凑的表达式中提取出具体的级数系数呢？本练习将指导你使用对数微分这一强大分析工具，直接从乘积定义中推导出一个递推关系，从而逐个计算出级数的系数。这个方法不仅适用于本例，也是处理各种生成函数的通用技巧。", "problem": "设 $q$ 为一个不定元，并定义 Rogers–Ramanujan 函数 $R(q)$ 为无穷乘积\n$$\nR(q) \\;=\\; \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}},\n$$\n其中 $q$-Pochhammer 符号为 $(a;q)_{\\infty} \\coloneqq \\prod_{n=0}^{\\infty} (1 - a\\,q^{n})$。根据 Rogers–Ramanujan 恒等式，这个 $R(q)$ 也等于级数 $\\sum_{n=0}^{\\infty} \\frac{q^{n^{2}}}{(q;q)_{n}}$，但在本题中，你可以将此乘积形式作为出发点。\n\n将 $R(q)$ 写成\n$$\nR(q) \\;=\\; \\sum_{n=0}^{\\infty} a_{n}\\,q^{n},\n$$\n并将其视为一个形式幂级数，其中 $a_{0}\\neq 0$。\n\n仅从给定的无穷乘积定义以及形式幂级数和对数微分的基本性质出发，完成以下任务：\n\n1) 推导一个关于 $q\\,\\frac{R'(q)}{R(q)}$ 的函数方程，并用它推导出一个用先前的系数确定系数 $a_{n}$ 的递推关系。你的递推关系必须以由模 $5$ 的剩余类决定的算术数据明确表示。\n\n2) 使用你的递推关系精确计算前五个系数 $a_{0},a_{1},a_{2},a_{3},a_{4}$。\n\n你的最终答案必须只包含这五个系数，并按顺序以单行矩阵的形式呈现。无需四舍五入。", "solution": "本题要求完成与 Rogers-Ramanujan 函数 $R(q)$ 相关的两个主要任务，该函数由无穷乘积 $R(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}$ 定义。我们需要处理其形式幂级数表示 $R(q) = \\sum_{n=0}^{\\infty} a_{n}\\,q^{n}$。\n\n首先，我们验证题目陈述的有效性。Rogers-Ramanujan 函数和 $q$-Pochhammer 符号的定义在整数分拆理论和 $q$-级数理论中是标准的。任务涉及标准数学技巧，如对数微分和形式幂级数的操作。该问题是自洽的，在数论中有科学依据，并且是适定的。因此，该问题是有效的，我们可以继续求解。\n\n**第一部分：推导递推关系**\n\n函数 $R(q)$ 由下式给出：\n$$\nR(q) = \\frac{1}{(q;q^{5})_{\\infty}\\,(q^{4};q^{5})_{\\infty}}\n$$\n使用 $q$-Pochhammer 符号的定义 $(a;q)_{\\infty} = \\prod_{k=0}^{\\infty} (1 - a\\,q^{k})$，我们可以展开分母：\n$$\nR(q) = \\frac{1}{\\left(\\prod_{k=0}^{\\infty} (1 - q \\cdot (q^5)^k)\\right) \\left(\\prod_{k=0}^{\\infty} (1 - q^4 \\cdot (q^5)^k)\\right)} = \\frac{1}{\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})}\n$$\n为了求对数导数，我们取 $R(q)$ 的自然对数：\n$$\n\\ln R(q) = \\ln \\left( \\left(\\prod_{k=0}^{\\infty} (1 - q^{5k+1}) (1 - q^{5k+4})\\right)^{-1} \\right) = - \\sum_{k=0}^{\\infty} \\left[\\ln(1 - q^{5k+1}) + \\ln(1 - q^{5k+4})\\right]\n$$\n对 $q$ 求导，我们得到 $\\frac{R'(q)}{R(q)} = \\frac{d}{dq} \\ln R(q)$：\n$$\n\\frac{R'(q)}{R(q)} = - \\sum_{k=0}^{\\infty} \\left[ \\frac{-(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{-(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right] = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+3}}{1 - q^{5k+4}} \\right]\n$$\n题目要求一个关于 $q \\frac{R'(q)}{R(q)}$ 的函数方程。两边乘以 $q$：\n$$\nq \\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} \\left[ \\frac{(5k+1)q^{5k+1}}{1 - q^{5k+1}} + \\frac{(5k+4)q^{5k+4}}{1 - q^{5k+4}} \\right]\n$$\n为推导递推关系，我们将此表达式展开为幂级数。使用（对形式幂级数有效的）几何级数展开 $\\frac{x}{1-x} = \\sum_{j=1}^{\\infty} x^j$：\n$$\nq \\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty} (5k+1) \\sum_{j=1}^{\\infty} (q^{5k+1})^j + \\sum_{k=0}^{\\infty} (5k+4) \\sum_{j=1}^{\\infty} (q^{5k+4})^j\n$$\n$$\nq \\frac{R'(q)}{R(q)} = \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+1)q^{j(5k+1)} + \\sum_{k=0}^{\\infty}\\sum_{j=1}^{\\infty} (5k+4)q^{j(5k+4)}\n$$\n设此级数为 $C(q) = \\sum_{m=1}^{\\infty} c_m q^m$。系数 $c_m$ 是对 $q^m$ 次幂的贡献之和。如果 $m = j(5k+1)$，项 $(5k+1)q^{j(5k+1)}$ 对 $q^m$ 的系数贡献 $5k+1$。这意味着 $d = 5k+1$ 是 $m$ 的一个因子。这样的因子满足 $d \\equiv 1 \\pmod 5$。类似地，如果 $d = 5k+4$ 是 $m$ 的一个因子，项 $(5k+4)q^{j(5k+4)}$ 贡献 $5k+4$。这样的因子满足 $d \\equiv 4 \\pmod 5$。\n因此，系数 $c_m$ 是 $m$ 的所有模 $5$ 同余于 $1$ 或 $4$ 的因子之和：\n$$\nc_m = \\sum_{d|m, \\, d \\equiv 1 \\pmod 5} d + \\sum_{d|m, \\, d \\equiv 4 \\pmod 5} d\n$$\n我们有恒等式 $q R'(q) = R(q) C(q)$。代入 $R(q)$ 和 $C(q)$ 的幂级数：\n$$\nq \\frac{d}{dq} \\left(\\sum_{n=0}^{\\infty} a_n q^n\\right) = \\left(\\sum_{k=0}^{\\infty} a_k q^k\\right) \\left(\\sum_{m=1}^{\\infty} c_m q^m\\right)\n$$\n左边变为：\n$$\nq \\sum_{n=1}^{\\infty} n a_n q^{n-1} = \\sum_{n=1}^{\\infty} n a_n q^n\n$$\n右边是一个柯西乘积。$q^n$ 的系数是 $\\sum_{k=0}^{n-1} a_k c_{n-k}$。\n通过对 $n \\ge 1$ 的 $q^n$ 系数进行相等比较，我们得到递推关系：\n$$\nn a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}\n$$\n这用先前的系数 $a_0, \\dots, a_{n-1}$ 和值 $c_j$（即所需的算术数据）确定了 $a_n$（对于 $n \\ge 1$）。\n\n**第二部分：计算前五个系数**\n\n首先，我们求 $a_0 = R(0)$。根据无穷乘积的定义，令 $q=0$ 会使分母为 $1$。\n$$\na_0 = R(0) = 1\n$$\n接下来，我们计算必要的 $c_m$ 值：\n- $c_1$: $1$ 的因子是 $\\{1\\}$。$1 \\equiv 1 \\pmod 5$。所以，$c_1 = 1$。\n- $c_2$: $2$ 的因子是 $\\{1, 2\\}$。$1 \\equiv 1 \\pmod 5$，$2 \\equiv 2 \\pmod 5$。所以，$c_2 = 1$。\n- $c_3$: $3$ 的因子是 $\\{1, 3\\}$。$1 \\equiv 1 \\pmod 5$，$3 \\equiv 3 \\pmod 5$。所以，$c_3 = 1$。\n- $c_4$: $4$ 的因子是 $\\{1, 2, 4\\}$。$1 \\equiv 1 \\pmod 5$，$2 \\equiv 2 \\pmod 5$，$4 \\equiv 4 \\pmod 5$。所以，$c_4 = 1+4 = 5$。\n\n现在我们对 $n=1, 2, 3, 4$ 应用递推关系 $n a_n = \\sum_{k=0}^{n-1} a_k c_{n-k}$。\n\n- 当 $n=1$ 时：\n$$\n1 \\cdot a_1 = a_0 c_1 = 1 \\cdot 1 = 1 \\implies a_1 = 1\n$$\n- 当 $n=2$ 时：\n$$\n2 \\cdot a_2 = a_0 c_2 + a_1 c_1 = 1 \\cdot 1 + 1 \\cdot 1 = 2 \\implies a_2 = 1\n$$\n- 当 $n=3$ 时：\n$$\n3 \\cdot a_3 = a_0 c_3 + a_1 c_2 + a_2 c_1 = 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 3 \\implies a_3 = 1\n$$\n- 当 $n=4$ 时：\n$$\n4 \\cdot a_4 = a_0 c_4 + a_1 c_3 + a_2 c_2 + a_3 c_1 = 1 \\cdot 5 + 1 \\cdot 1 + 1 \\cdot 1 + 1 \\cdot 1 = 8 \\implies a_4 = 2\n$$\n前五个系数是 $a_0=1$，$a_1=1$，$a_2=1$，$a_3=1$ 和 $a_4=2$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1  1  1  1  2\n\\end{pmatrix}\n}\n$$", "id": "3093197"}, {"introduction": "Rogers-Ramanujan 恒等式的另一面涉及具有特殊“分离”条件的整数划分，即划分中的各部分之间至少相差 $2$。本练习通过一个有限版本的情形，让你亲手实践如何利用费勒斯图这一可视化工具，将这种看似复杂的划分转化为标准的整数划分。这个精巧的组合构造是理解并证明该恒等式的关键一步。", "problem": "设 $q$ 为一个不定元。一个非负整数 $n$ 的划分是一个其和为 $n$ 的非增正整数有限序列。一个划分的费勒斯图（Ferrers diagram）是用左对齐的点行来表示该划分的方法，其中第 $i$ 行的点的数量等于第 $i$ 个部分的大小。考虑集合 $\\mathcal{R}_{N}$，它是由满足以下条件的划分 $\\lambda$ 组成：对于所有适用的指标 $i$，连续部分之差满足 $\\lambda_{i} - \\lambda_{i+1} \\ge 2$，并且最大部分满足 $\\lambda_{1} \\le N$。令 $|\\lambda|$ 表示 $\\lambda$ 的各部分之和（即其大小）。定义有限生成多项式\n$$F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}.$$\n从划分、费勒斯图的基本定义以及生成函数作为加权计数的解释出发，利用费勒斯图通过移除一个合适的阶梯形状来为 $\\mathcal{R}_{N}$ 推导一种计数方法，并将 $F_{N}(q)$ 表示为一个关于部分数求和的、包含标准 $q$-模拟计数多项式的表达式。然后为 $N = 1,2,3,4,5,6$ 显式计算 $F_{N}(q)$，将每个 $F_{N}(q)$ 表示为 $q$ 的多项式。以有序 $6$-元组 $\\left(F_{1}(q),F_{2}(q),F_{3}(q),F_{4}(q),F_{5}(q),F_{6}(q)\\right)$ 的形式返回你的最终答案。", "solution": "该问题是有效的，因为它在科学上基于整数划分理论和生成函数理论，问题提法得当，并使用了客观、无歧义的数学语言。\n\n设 $\\mathcal{R}_{N}$ 为划分 $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k)$ 的集合，其中各部分为正整数，满足 $\\lambda_1 \\le N$ 且对于 $i=1, \\dots, k-1$ 有 $\\lambda_i - \\lambda_{i+1} \\ge 2$。空划分 $\\lambda=()$ 是 $0$ 的一个划分，它自然满足这些条件，其最大部分可视为 $0$，故对于任意 $N \\ge 0$ 都有 $0 \\le N$。其各部分之和为 $|\\lambda| = 0$。\n\n生成函数 $F_N(q)$ 定义为 $F_{N}(q) = \\sum_{\\lambda \\in \\mathcal{R}_{N}} q^{|\\lambda|}$。我们可以根据部分数 $k$ 对集合 $\\mathcal{R}_{N}$ 进行分类。设 $\\mathcal{R}_{N,k}$ 是 $\\mathcal{R}_N$ 中恰好有 $k$ 个部分的划分所构成的子集。生成函数可以写成：\n$$F_N(q) = 1 + \\sum_{k=1}^{\\infty} \\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|}$$\n其中 $1$ 对应于空划分（$k=0$）。\n\n题目建议使用费勒斯图并移除一个“阶梯形状”。设 $\\lambda = (\\lambda_1, \\lambda_2, \\dots, \\lambda_k) \\in \\mathcal{R}_{N,k}$。其各部分满足的条件是：\n1. $N \\ge \\lambda_1$\n2. $\\lambda_i - \\lambda_{i+1} \\ge 2$ 对于 $i=1, \\dots, k-1$\n3. $\\lambda_k \\ge 1$\n\n我们通过从 $\\lambda$ 中“移除一个阶梯”来定义一个新的整数序列 $\\mu = (\\mu_1, \\mu_2, \\dots, \\mu_k)$。从 $\\lambda$ 的费勒斯图中移除的合适阶梯形状是划分 $(2k-1, 2k-3, \\dots, 3, 1)$，它有 $k$ 个部分，大小为 $k^2$。这对应于变换：\n$$\\mu_i = \\lambda_i - (2(k-i)+1) \\quad \\text{对 } i=1, \\dots, k \\text{ 成立}$$\n我们需要验证这个变换将 $\\lambda \\in \\mathcal{R}_{N,k}$ 映射到一个标准划分 $\\mu$，并且该映射是一个双射。\n\n首先，我们来检验 $\\mu$ 的性质：\n-   条件 $\\lambda_i - \\lambda_{i+1} \\ge 2$ 意味着：\n    $$(\\mu_i + (2k-2i+1)) - (\\mu_{i+1} + (2k-2(i+1)+1)) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + (2k-2i+1) - (2k-2i-1) \\ge 2$$\n    $$\\mu_i - \\mu_{i+1} + 2 \\ge 2 \\implies \\mu_i \\ge \\mu_{i+1}$$\n    这表明 $\\mu_1 \\ge \\mu_2 \\ge \\dots \\ge \\mu_k$。\n-   条件 $\\lambda_k \\ge 1$ 意味着：\n    $$\\mu_k + (2(k-k)+1) \\ge 1 \\implies \\mu_k + 1 \\ge 1 \\implies \\mu_k \\ge 0$$\n    因此，$\\mu$ 是一个由非负整数构成的划分，这意味着它是一个标准的整数划分，如果某些 $\\mu_i$ 为 $0$，其正部分的数量可能少于 $k$。\n-   条件 $\\lambda_1 \\le N$ 意味着：\n    $$\\mu_1 + (2(k-1)+1) \\le N \\implies \\mu_1 + 2k - 1 \\le N \\implies \\mu_1 \\le N - 2k + 1$$\n    这个变换是一个双射。对于任何满足 $\\mu_1 \\ge \\dots \\ge \\mu_k \\ge 0$ 和 $\\mu_1 \\le N - 2k + 1$ 的划分 $\\mu$，我们可以通过令 $\\lambda_i = \\mu_i + (2(k-i)+1)$ 来唯一地恢复一个划分 $\\lambda \\in \\mathcal{R}_{N,k}$。\n\n$\\lambda$ 的各部分之和与 $\\mu$ 的各部分之和相关：\n$$|\\lambda| = \\sum_{i=1}^k \\lambda_i = \\sum_{i=1}^k (\\mu_i + 2(k-i)+1) = \\sum_{i=1}^k \\mu_i + \\sum_{i=1}^k (2j-1) \\text{ 其中 } j=k-i+1$$\n第二个和是前 $k$ 个奇数之和，即 $k^2$。因此，$|\\lambda| = |\\mu| + k^2$。\n\n在 $\\mathcal{R}_{N,k}$ 中的划分的生成函数为：\n$$\\sum_{\\lambda \\in \\mathcal{R}_{N,k}} q^{|\\lambda|} = \\sum_{\\mu} q^{|\\mu| + k^2} = q^{k^2} \\sum_{\\mu} q^{|\\mu|}$$\n求和遍及所有满足以下条件的划分 $\\mu$：\n1. 部分数至多为 $k$（即其费勒斯图至多有 $k$ 行）。\n2. 最大部分至多为 $N - 2k + 1$（即其费勒斯图至多有 $N - 2k + 1$ 列）。\n\n其费勒斯图能放入一个 $k \\times m$ 盒子（部分数至多为 $k$，最大部分至多为 $m$）的划分的生成函数由 $q$-二项式系数（或高斯多项式）$\\binom{k+m}{k}_q$ 给出。\n这里，$m = N - 2k + 1$。因此 $\\mu$ 的生成函数为 $\\binom{k + (N - 2k + 1)}{k}_q = \\binom{N-k+1}{k}_q$。\n对 $\\mathcal{R}_{N,k}$ 的求和非空，当且仅当可以形成一个划分。最小的此类划分是 $(2k-1, 2k-3, \\dots, 1)$，其最大部分为 $\\lambda_1 = 2k-1$。我们必须有 $2k-1 \\le N$，这意味着 $k \\le (N+1)/2$。这与 $q$-二项式系数的性质一致，即若 $kn$ 则 $\\binom{n}{k}_q=0$，因为 $N-k+1  k$ 等价于 $N+1  2k$。\n\n所以，总生成函数为：\n$$F_N(q) = 1 + \\sum_{k=1}^{\\lfloor(N+1)/2\\rfloor} q^{k^2} \\binom{N-k+1}{k}_q$$\n\n我们现在计算当 $N=1, \\dots, 6$ 时的 $F_N(q)$。我们使用公式 $\\binom{n}{k}_q = \\frac{\\prod_{i=1}^n (1-q^i)}{\\left(\\prod_{i=1}^k (1-q^i)\\right)\\left(\\prod_{i=1}^{n-k} (1-q^i)\\right)}$。\n当 $k=1$ 时，$\\binom{n}{1}_q = \\frac{1-q^n}{1-q} = 1+q+\\dots+q^{n-1}$。当 $k=n$ 时，$\\binom{n}{n}_q = 1$。\n\n-   **N = 1**：$k \\le 1$。\n    $F_1(q) = 1 + q^{1^2} \\binom{1-1+1}{1}_q = 1 + q \\binom{1}{1}_q = 1 + q(1) = 1+q$。\n\n-   **N = 2**：$k \\le 1.5$，所以 $k=1$。\n    $F_2(q) = 1 + q^{1^2} \\binom{2-1+1}{1}_q = 1 + q \\binom{2}{1}_q = 1 + q(1+q) = 1+q+q^2$。\n\n-   **N = 3**：$k \\le 2$。\n    $F_3(q) = 1 + q^{1^2} \\binom{3-1+1}{1}_q + q^{2^2} \\binom{3-2+1}{2}_q = 1 + q \\binom{3}{1}_q + q^4 \\binom{2}{2}_q = 1 + q(1+q+q^2) + q^4(1) = 1+q+q^2+q^3+q^4$。\n\n-   **N = 4**：$k \\le 2.5$，所以 $k=1, 2$。\n    $F_4(q) = 1 + q \\binom{4}{1}_q + q^4 \\binom{4-2+1}{2}_q = 1 + q \\binom{4}{1}_q + q^4 \\binom{3}{2}_q$。\n    $\\binom{4}{1}_q = 1+q+q^2+q^3$。\n    $\\binom{3}{2}_q = \\binom{3}{1}_q = 1+q+q^2$。\n    $F_4(q) = 1 + q(1+q+q^2+q^3) + q^4(1+q+q^2) = 1 + q+q^2+q^3+q^4 + q^4+q^5+q^6 = 1+q+q^2+q^3+2q^4+q^5+q^6$。\n\n-   **N = 5**：$k \\le 3$。\n    $F_5(q) = 1 + q \\binom{5}{1}_q + q^4 \\binom{5-2+1}{2}_q + q^9 \\binom{5-3+1}{3}_q = 1 + q \\binom{5}{1}_q + q^4 \\binom{4}{2}_q + q^9 \\binom{3}{3}_q$。\n    $\\binom{5}{1}_q = 1+q+q^2+q^3+q^4$。\n    $\\binom{4}{2}_q = \\frac{(1-q^4)(1-q^3)}{(1-q)(1-q^2)} = (1+q+q^2)(1+q^2) = 1+q+2q^2+q^3+q^4$。\n    $\\binom{3}{3}_q = 1$。\n    $F_5(q) = 1 + q(1+q+q^2+q^3+q^4) + q^4(1+q+2q^2+q^3+q^4) + q^9(1) = 1 + (q+q^2+q^3+q^4+q^5) + (q^4+q^5+2q^6+q^7+q^8) + q^9 = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$。\n\n-   **N = 6**：$k \\le 3.5$，所以 $k=1, 2, 3$。\n    $F_6(q) = 1 + q\\binom{6}{1}_q + q^4\\binom{6-2+1}{2}_q + q^9\\binom{6-3+1}{3}_q = 1 + q\\binom{6}{1}_q + q^4\\binom{5}{2}_q + q^9\\binom{4}{3}_q$。\n    $\\binom{6}{1}_q = 1+q+q^2+q^3+q^4+q^5$。\n    $\\binom{5}{2}_q = \\frac{(1-q^5)(1-q^4)}{(1-q)(1-q^2)} = (1+q+q^2+q^3+q^4)(1+q^2) = 1+q+2q^2+2q^3+2q^4+q^5+q^6$。\n    $\\binom{4}{3}_q = \\binom{4}{1}_q = 1+q+q^2+q^3$。\n    $F_6(q) = 1 + q(1+q+q^2+q^3+q^4+q^5) + q^4(1+q+2q^2+2q^3+2q^4+q^5+q^6) + q^9(1+q+q^2+q^3)$。\n    $F_6(q) = 1 + (q+q^2+q^3+q^4+q^5+q^6) + (q^4+q^5+2q^6+2q^7+2q^8+q^9+q^{10}) + (q^9+q^{10}+q^{11}+q^{12})$。\n    $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$。\n\n这 6 个多项式的元组是：\n1. $F_1(q) = 1+q$\n2. $F_2(q) = 1+q+q^2$\n3. $F_3(q) = 1+q+q^2+q^3+q^4$\n4. $F_4(q) = 1+q+q^2+q^3+2q^4+q^5+q^6$\n5. $F_5(q) = 1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9$\n6. $F_6(q) = 1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1+q  1+q+q^2  1+q+q^2+q^3+q^4  1+q+q^2+q^3+2q^4+q^5+q^6  1+q+q^2+q^3+2q^4+2q^5+2q^6+q^7+q^8+q^9  1+q+q^2+q^3+2q^4+2q^5+3q^6+2q^7+2q^8+2q^9+2q^{10}+q^{11}+q^{12}\n\\end{pmatrix}\n}\n$$", "id": "3093195"}, {"introduction": "Rogers-Ramanujan 恒等式的奇妙之处在于，它连接了两个看似毫无关联的计数问题：一个是关于特定同余类别的划分，另一个是关于部分之间有最小差的划分。本练习将引导你设计并实现两种不同的动态规划算法，分别计算恒等式两边的级数系数，并通过计算机来验证它们在一定范围内完全相等。这不仅是一次编程实践，更是一次通过计算体验数学之美的旅程。", "problem": "设 $q$ 是一个形式变量，令 $(a;q)_n$ 表示 $q$-Pochhammer 符号，定义为 $(a;q)_0=1$ 且对于每个整数 $n\\ge 1$ 有 $(a;q)_n=\\prod_{k=0}^{n-1}(1-aq^k)$。考虑整数分拆，其中非负整数 $n$ 的一个分拆是和为 $n$ 的正整数的有限多重集。其允许的拆分项大小来自子集 $S\\subseteq \\mathbb{Z}_{\\ge 1}$ 的分拆的生成函数是形式幂级数 $\\prod_{s\\in S}\\frac{1}{1-q^s}$，其中 $q^n$ 的系数等于将 $n$ 写成 $S$ 中元素之和（不限重复次数，不计顺序）的方法数。\n\n定义两个分拆族：\n- 对于第一个分拆族，允许的拆分项大小是所有模 $5$ 同余于 $1$ 或 $4$ 的正整数，即 $S_1=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 1 \\text{ or } 4 \\pmod{5}\\}$。\n- 对于第二个分拆族，允许的拆分项大小是所有模 $5$ 同余于 $2$ 或 $3$ 的正整数，即 $S_2=\\{s\\in \\mathbb{Z}_{\\ge 1} : s\\equiv 2 \\text{ or } 3 \\pmod{5}\\}$。\n\n独立地，考虑由截断稳定的和定义的两个形式幂级数：\n- $S_1^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m^2}}{(q;q)_m}$，\n- $S_2^{\\text{sum}}(q)=\\sum_{m\\ge 0} \\dfrac{q^{m(m+1)}}{(q;q)_m}$，\n其中 $(q;q)_m=\\prod_{k=1}^{m}(1-q^k)$，其倒数 $\\dfrac{1}{(q;q)_m}$ 被解释为允许的拆分项大小为从 $1$到 $m$ 的整数（不限重复次数）的分拆的生成函数。\n\n你的任务是设计并实现一个动态规划算法，该算法在给定一个非负整数 $N$ 的情况下，计算乘积端分拆族（分别基于 $S_1$ 和 $S_2$）的系数数组 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，并计算和式端级数 $S_1^{\\text{sum}}(q)$ 和 $S_2^{\\text{sum}}(q)$ 直到 $N$ 次的系数数组 $\\{A_1(n)\\}_{n=0}^N$ 和 $\\{A_2(n)\\}_{n=0}^N$。\n\n算法要求：\n- 对于乘积端数组，使用一个无界硬币找零动态规划递推来计算 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，其中允许的拆分项大小被限制在集合 $S_1$ 和 $S_2$ 与 $\\{1,2,\\dots,N\\}$ 的交集中。\n- 对于和式端数组，通过以 $m$ 为变量的动态规划增量构建，计算所有需要的 $m$ 的 $\\dfrac{1}{(q;q)_m}$ 直到 $N$ 次。然后，通过对所有满足 $m^2\\le N$ 的整数 $m$ 求和对应的移位数组 $q^{m^2}\\dfrac{1}{(q;q)_m}$ 来形成 $\\{A_1(n)\\}_{n=0}^N$，并通过对所有满足 $m(m+1)\\le N$ 的整数 $m$ 求和对应的移位数组 $q^{m(m+1)}\\dfrac{1}{(q;q)_m}$ 来形成 $\\{A_2(n)\\}_{n=0}^N$。\n- 分析两种方法关于 $N$ 的渐近时间复杂度，并说明其对允许的拆分项数量的依赖性。\n\n验证要求：\n- 对于每个测试 $N$，验证对于所有 $0\\le n\\le N$ 的整数 $n$ 等式 $P_1(n)=A_1(n)$ 和 $P_2(n)=A_2(n)$ 均成立，并将此验证结果报告为布尔值。\n\n测试套件：\n- 使用以下测试值 $N$：$N\\in\\{0,1,12,25,60\\}$。\n- 这些测试用例涵盖了一个平凡的边界情况 ($N=0$)、最小的非平凡情况 ($N=1$)、一个小型通用情况 ($N=12$)、一个中等情况 ($N=25$) 以及一个对两种算法都有压力的大型情况 ($N=60$)。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例 $N$，输出列表 $[b_1,b_2]$，其中 $b_1$ 是确认对于所有 $0\\le n\\le N$，$P_1(n)=A_1(n)$ 的布尔值，$b_2$ 是确认对于所有 $0\\le n\\le N$，$P_2(n)=A_2(n)$ 的布尔值。因此，最终行应类似于 $[[b_{1,1},b_{1,2}],[b_{2,1},b_{2,2}],\\dots]$。", "solution": "该问题要求在给定的整数范围内对两个 Rogers-Ramanujan 恒等式进行计算验证。这些恒等式将两个以变量 $q$ 表示的特定形式幂级数的无穷和表示与无穷乘积表示等同起来。\n\n第一个恒等式是：\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m^2}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+1})(1-q^{5k+4})}\n$$\n第二个恒等式是：\n$$\n\\sum_{m=0}^{\\infty} \\frac{q^{m(m+1)}}{(q;q)_m} = \\prod_{k=0}^{\\infty} \\frac{1}{(1-q^{5k+2})(1-q^{5k+3})}\n$$\n\n这里，$(q;q)_m = \\prod_{k=1}^{m}(1-q^k)$ 是当 $a=q$ 时的 $q$-Pochhammer 符号。左边是“和式端”，右边是“积式端”。\n\n用整数分拆的语言来说，积式端生成函数 $\\prod_{s \\in S} \\frac{1}{1-q^s}$ 中 $q^n$ 的系数计算了将整数 $n$ 分拆成取自集合 $S$ 的部分的方法数。\n因此，第一个恒等式指出，将 $n$ 分拆成模 $5$ 同余于 $1$ 或 $4$ 的部分（集合 $S_1$）的方法数，等于将 $n$ 分拆成任意两部分之差至少为 $2$ 的部分的方法数。和式端的生成函数对应于这第二个条件。\n第二个恒等式指出，将 $n$ 分拆成模 $5$ 同余于 $2$ 或 $3$ 的部分（集合 $S_2$）的方法数，等于将 $n$ 分拆成大于 $1$ 且任意两部分之差至少为 $2$ 的部分的方法数。\n\n任务是使用两种不同的动态规划算法——一个用于积式端表示（$P_1(n)$, $P_2(n)$），一个用于和式端表示（$A_1(n)$, $A_2(n)$）——来计算这些级数直到 $N$ 次的系数数组，然后验证对于所有 $n \\in \\{0, 1, \\dots, N\\}$，它们是相等的。\n\n**算法1：积式端系数计算**\n\n为了计算系数 $\\{P_1(n)\\}_{n=0}^N$ 和 $\\{P_2(n)\\}_{n=0}^N$，我们将问题解释为无界背包或硬币找零问题的一个变种。使用来自集合 $S$ 的部分来分拆 $n$ 的方法数，记为 $p_S(n)$，是 $\\prod_{s\\in S} \\frac{1}{1-q^s}$ 中 $q^n$ 的系数。我们可以使用动态规划来计算它。\n\n设 $dp[i]$ 为使用一组给定允许大小的部分来分拆整数 $i$ 的方法数。我们初始化 $dp[0] = 1$ 和 $dp[i] = 0$（对于 $i  0$）。然后我们遍历每个允许的部分大小 $s \\in S$（直到 $N$）并根据递推关系更新 $dp$ 表：\n$dp_{new}[i] = dp_{old}[i] + dp_{new}[i-s]$。\n这可以通过对每个部分大小 $s$ 进行原地更新来实现：\n对于每个 $s \\in S \\cap \\{1, \\dots, N\\}$：\n  对于 $n$ 从 $s$ 到 $N$：\n    $dp[n] \\leftarrow dp[n] + dp[n-s]$\n\n此过程应用两次：\n1.  对于 $\\{P_1(n)\\}_{n=0}^N$，部分集合为 $S_1 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 1 \\text{ or } 4 \\pmod{5}, s \\le N\\}$。\n2.  对于 $\\{P_2(n)\\}_{n=0}^N$，部分集合为 $S_2 = \\{s \\in \\mathbb{Z}_{\\ge 1} : s \\equiv 2 \\text{ or } 3 \\pmod{5}, s \\le N\\}$。\n\n**复杂度分析（积式端）：** 该算法涉及一个遍历允许部分大小集合的外层循环，设为 $S_N = S \\cap \\{1, \\dots, N\\}$，以及一个从 $s$ 到 $N$ 的内层循环。在 $S_1$ 或 $S_2$ 中直到 $N$ 的部分大小数量为 $|S_{i,N}| \\approx \\frac{2}{5}N$。总操作数约等于 $\\sum_{s \\in S_N} (N-s) \\approx \\int_0^N (N-x) \\frac{|S_N|}{N} dx$，这与 $N^2$ 成正比。因此，对于给定的集合 $S_1$ 和 $S_2$，时间复杂度为 $O(|S_N| \\cdot N)$，即 $O(N^2)$。\n\n**算法2：和式端系数计算**\n\n为了计算系数 $\\{A_1(n)\\}_{n=0}^N$ 和 $\\{A_2(n)\\}_{n=0}^N$，我们必须计算和式 $S_1^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m^2}}{(q;q)_m}$ 和 $S_2^{\\text{sum}}(q) = \\sum_{m\\ge 0} \\frac{q^{m(m+1)}}{(q;q)_m}$ 直到 $N$ 次。求和可以在 $m$ 处截断，使得分子中 $q$ 的指数，$m^2$ 或 $m(m+1)$，超过 $N$。这意味着求和进行到 $m \\approx \\sqrt{N}$。\n\n该算法分两个主要阶段进行：\n1.  **计算 $D_m(q) = 1/(q;q)_m$ 的系数**：我们增量地计算 $D_m(q)$ 的系数。我们从 $D_0(q)=1$ 开始，其系数数组是 $[1, 0, \\dots]$。然后，对于 $m \\ge 1$，我们使用关系 $D_m(q) = D_{m-1}(q) \\cdot \\frac{1}{1-q^m}$。如果 $d_{k,n}$ 是 $D_k(q)$ 中 $q^n$ 的系数，则系数 $d_{m,n}$ 可以通过递推关系 $d_{m,n} = d_{m-1,n} + d_{m,n-m}$ 从 $d_{m-1,n}$ 计算得出。这实现为对每个 $m$ 的系数数组进行原地更新。\n\n2.  **对级数项求和**：我们将结果数组 $\\{A_1(n)\\}$、$\\{A_2(n)\\}$ 初始化为零。我们从 $m=0$ 开始向上循环。在每次迭代 $m$ 中，我们首先如上所述计算 $D_m(q)$ 的系数数组。然后，我们将第 $m$ 项的贡献加到总和中：\n    - 对于 $A_1$，我们将 $D_m(q)$ 的系数加到数组 $A_1$ 中，索引偏移量为 $m^2$。这对应于将 $D_m(q)$ 乘以 $q^{m^2}$。\n    - 对于 $A_2$，我们将 $D_m(q)$ 的系数加到数组 $A_2$ 中，索引偏移量为 $m(m+1)$。\n    - 当 $m^2  N$ 时，关于 $m$ 的循环终止，因为没有更多的项能对直到 $N$ 次的系数做出贡献。\n\n**复杂度分析（和式端）：** 主循环从 $m=1$ 迭代到最大值 $M \\approx \\sqrt{N}$。在循环内部，更新 $D_m(q)$ 的系数数组需要 $O(N)$ 时间。将移位的系数加到 $A_1$ 和 $A_2$ 也需要 $O(N)$ 时间。因此，总时间复杂度为 $O(M \\cdot N) = O(N\\sqrt{N})$。\n\n**验证**\n对于每个测试用例 $N$，在计算了四个系数数组 $\\{P_1(n)\\}$、$\\{P_2(n)\\}$、$\\{A_1(n)\\}$ 和 $\\{A_2(n)\\}$ 直到 $N$ 次之后，我们执行直接的逐元素比较。生成两个布尔值：一个用于验证对于所有 $n \\in \\{0, \\dots, N\\}$，$P_1(n) = A_1(n)$ 是否成立；另一个用于验证对于所有 $n \\in \\{0, \\dots, N\\}$，$P_2(n) = A_2(n)$ 是否成立。由于 Rogers-Ramanujan 恒等式是已证明的定理，这些等式必须成立。", "answer": "```python\nimport numpy as np\n\ndef compute_product_side(N):\n    \"\"\"\n    Computes coefficients for the product-side generating functions using dynamic programming.\n    This is equivalent to the unbounded coin change problem.\n    Time complexity: O(N^2)\n    \"\"\"\n    if N  0:\n        return [], []\n\n    # For P1: partitions with parts congruent to 1 or 4 (mod 5)\n    S1_parts = [s for s in range(1, N + 1) if s % 5 == 1 or s % 5 == 4]\n    P1 = [0] * (N + 1)\n    P1[0] = 1\n    for s in S1_parts:\n        for n in range(s, N + 1):\n            P1[n] += P1[n - s]\n\n    # For P2: partitions with parts congruent to 2 or 3 (mod 5)\n    S2_parts = [s for s in range(1, N + 1) if s % 5 == 2 or s % 5 == 3]\n    P2 = [0] * (N + 1)\n    P2[0] = 1\n    for s in S2_parts:\n        for n in range(s, N + 1):\n            P2[n] += P2[n - s]\n\n    return P1, P2\n\ndef compute_sum_side(N):\n    \"\"\"\n    Computes coefficients for the sum-side series using dynamic programming.\n    Time complexity: O(N*sqrt(N))\n    \"\"\"\n    if N  0:\n        return [], []\n    \n    A1 = [0] * (N + 1)\n    A2 = [0] * (N + 1)\n    \n    # The sums start from m=0. The term for m=0 is q^0/(q;q)_0 = 1 for both series.\n    if N >= 0:\n        A1[0] = 1\n        A2[0] = 1\n\n    # D_coeffs stores coefficients of 1/(q;q)_m.\n    # We initialize it for m=0, where 1/(q;q)_0 = 1.\n    D_coeffs = [0] * (N + 1)\n    D_coeffs[0] = 1\n    \n    m = 1\n    while True:\n        m_squared = m * m\n        # If m^2 > N, no higher-m terms can contribute to coefficients = N.\n        if m_squared > N:\n            break\n\n        # Update D_coeffs from representing 1/(q;q)_{m-1} to 1/(q;q)_m.\n        # This is done by multiplying by 1/(1-q^m), which corresponds to the\n        # recurrence d_m[n] = d_{m-1}[n] + d_m[n-m].\n        # The inner loop performs this update in-place.\n        for n in range(m, N + 1):\n            D_coeffs[n] += D_coeffs[n - m]\n        \n        # Now D_coeffs contains coefficients for 1/(q;q)_m.\n        \n        # Add contribution to A1: q^(m^2) * [1/(q;q)_m]\n        for n in range(m_squared, N + 1):\n            A1[n] += D_coeffs[n - m_squared]\n        \n        # Add contribution to A2: q^(m(m+1)) * [1/(q;q)_m]\n        m_m_p1 = m * (m + 1)\n        if m_m_p1 = N:\n            for n in range(m_m_p1, N + 1):\n                A2[n] += D_coeffs[n - m_m_p1]\n\n        m += 1\n            \n    return A1, A2\n\ndef solve():\n    \"\"\"\n    Main solver function to run verification for all test cases.\n    \"\"\"\n    test_cases = [0, 1, 12, 25, 60]\n\n    results = []\n    for N in test_cases:\n        # Compute coefficients using both methods\n        P1, P2 = compute_product_side(N)\n        A1, A2 = compute_sum_side(N)\n\n        # Verify that the resulting coefficient arrays are identical\n        # np.array_equal is efficient for this comparison.\n        b1 = np.array_equal(P1, A1)\n        b2 = np.array_equal(P2, A2)\n        \n        results.append([b1, b2])\n\n    # Format the final output as specified in the problem statement.\n    # Example: [[True,True],[True,True]]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3093186"}]}