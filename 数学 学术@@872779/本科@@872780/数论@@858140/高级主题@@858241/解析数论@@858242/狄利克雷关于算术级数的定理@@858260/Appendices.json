{"hands_on_practices": [{"introduction": "狄利克雷定理是数论中的一块基石，但要应用它，我们首先必须精确理解其适用范围。这个练习将带你回到基本定义，通过一个具体的例子，确定哪些算术级数有资格拥有无穷多个素数，从而巩固你对该定理条件的理解。[@problem_id:3084158]", "problem": "设 $q$ 是一个正整数模，考虑形如 $qn+a$ 的等差数列，其中 $n$ 为整数，$a$ 为模 $q$ 的余数。狄利克雷关于等差数列的定理断言，如果 $\\gcd(a,q)=1$（其中 $\\gcd$ 表示最大公约数 GCD），那么在数列 $qn+a$ 中有无穷多个素数。仅使用欧拉函数 $\\phi(q)$（即模 $q$ 下与 $q$ 互质的余数的个数）的定义以及模 $q$ 的简化剩余系的概念，确定对于特定模 $q=12$ 的以下内容：\n\n1. 通过找出模 $12$ 下与 $12$ 互质的余数，从基本定义出发计算 $\\phi(12)$。\n2. 枚举所有满足 $0 \\le a \\le 11$ 且 $\\gcd(a,12)=1$ 的余数 $a$，这些余数类正是狄利克雷定理在模 $12$ 下适用的类别。\n\n按递增顺序列出符合条件的余数。将最终答案表示为一个单行矩阵，其第一个元素是 $\\phi(12)$，后面是按递增顺序排列的符合条件的余数。无需四舍五入，不涉及单位。", "solution": "该问题要求确定关于模 $q=12$ 的两个量：首先是欧拉函数的值 $\\phi(12)$，其次是模 12 下与 12 互质的余数 $a$ 的明确集合。对于这些余数，狄利克雷关于等差数列的定理保证了数列 $12n+a$ 包含无穷多个素数。\n\n根据所给定义，$\\phi(q)$ 是模 $q$ 下与 $q$ 互质的余数的个数。我们被要求从基本定义出发，为 $q=12$ 计算这个值。模 12 的余数是集合 $\\{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\\}$ 中的整数。对于此集合中的每个余数 $a$，我们必须确定它是否与 12 互质，即 $\\gcd(a, 12) = 1$ 是否成立。\n\n一个整数与 12 互质，当且仅当它与 12 没有共同的素因子。12 的素数分解是 $12 = 2^2 \\cdot 3$。因此，一个整数 $a$ 与 12 互质，当且仅当 $a$ 不能被 2 整除且不能被 3 整除。我们现在系统地检查范围 $0 \\le a \\le 11$ 内的每个余数 $a$。\n\n1.  对于 $a=0$：$\\gcd(0, 12) = 12$。因为 $12 \\ne 1$，所以 0 与 12 不互质。\n2.  对于 $a=1$：$\\gcd(1, 12) = 1$。因此，1 与 12 互质。\n3.  对于 $a=2$：$\\gcd(2, 12) = 2$。因为 $2 \\ne 1$，所以 2 与 12 不互质。\n4.  对于 $a=3$：$\\gcd(3, 12) = 3$。因为 $3 \\ne 1$，所以 3 与 12 不互质。\n5.  对于 $a=4$：$\\gcd(4, 12) = 4$。因为 $4 \\ne 1$，所以 4 与 12 不互质。\n6.  对于 $a=5$：$\\gcd(5, 12) = 1$。因此，5 与 12 互质。\n7.  对于 $a=6$：$\\gcd(6, 12) = 6$。因为 $6 \\ne 1$，所以 6 与 12 不互质。\n8.  对于 $a=7$：$\\gcd(7, 12) = 1$。因此，7 与 12 互质。\n9.  对于 $a=8$：$\\gcd(8, 12) = 4$。因为 $4 \\ne 1$，所以 8 与 12 不互质。\n10. 对于 $a=9$：$\\gcd(9, 12) = 3$。因为 $3 \\ne 1$，所以 9 与 12 不互质。\n11. 对于 $a=10$：$\\gcd(10, 12) = 2$。因为 $2 \\ne 1$，所以 10 与 12 不互质。\n12. 对于 $a=11$：$\\gcd(11, 12) = 1$。因此，11 与 12 互质。\n\n在范围 $0 \\le a \\le 11$ 内与 12 互质的余数 $a$ 是 $\\{1, 5, 7, 11\\}$。这个集合是模 12 的简化剩余系。\n\n对于问题的第一部分，我们通过计算该集合中元素的数量来计算 $\\phi(12)$。\n$$\n\\phi(12) = |\\{1, 5, 7, 11\\}| = 4\n$$\n\n对于问题的第二部分，我们按递增顺序列出这些符合条件的余数：\n$$\n1, 5, 7, 11\n$$\n\n最终答案要求是一个单行矩阵，其中第一个元素是 $\\phi(12)$，随后的元素是按递增顺序排列的符合条件的余数。结合我们的结果，我们得到值 $\\phi(12)=4$ 和余数 $1, 5, 7, 11$。因此，得到的矩阵由元素 $4, 1, 5, 7, 11$ 组成。", "answer": "$$\n\\boxed{\\begin{pmatrix} 4  1  5  7  11 \\end{pmatrix}}\n$$", "id": "3084158"}, {"introduction": "狄利克雷定理的证明巧妙地运用了狄利克雷特征的正交性来“筛选”出特定算术级数中的素数。这个练习让你通过一个直接的计算，亲身体验这一关键的数学工具是如何运作的，并理解为什么它在证明中如此强大。[@problem_id:3084154]", "problem": "令 $q=5$。模 $q$ 的狄利克雷特征是一个完全积性函数 $\\chi:\\mathbb{Z}\\to\\mathbb{C}$，它以 $q$ 为周期，当 $\\gcd(n,q)>1$ 时满足 $\\chi(n)=0$，并且其在 $\\left(\\mathbb{Z}/q\\mathbb{Z}\\right)^{\\times}$ 上的限制是从该群到 $\\mathbb{C}^{\\times}$ 的群同态。模 $q$ 的这种特征恰好有 $\\varphi(q)$ 个，其中 $\\varphi$ 表示欧拉函数，它们在逐点乘法下构成一个有限阿贝尔群。有限阿贝尔群上特征的正交性是狄利克雷算术级数定理证明的基础，它允许人们分离出模 $q$ 的剩余类。\n\n计算\n$$\nS \\;=\\; \\sum_{\\chi \\bmod 5} \\chi(2),\n$$\n的精确值，其中求和遍及所有模 $5$ 的狄利克雷特征（包括主特征）。然后，根据特征的正交性及其在分离剩余类 $1 \\bmod 5$ 中的作用，简要解释您的计算。您的最终答案必须是一个精确的数，无需四舍五入。", "solution": "问题陈述有效。这是一个定义明确的数论问题，基于标准的狄利克雷特征理论，并包含了唯一解所需的所有信息。\n\n该问题要求计算和式\n$$\nS \\;=\\; \\sum_{\\chi \\bmod 5} \\chi(2)\n$$\n其中求和遍历所有模 $q=5$ 的狄利克雷特征。\n\n一个模整数 $q$ 的狄利克雷特征 $\\chi$ 可以被看作是有限阿贝尔群 $G = \\left(\\mathbb{Z}/q\\mathbb{Z}\\right)^{\\times}$（即模 $q$ 整数乘法群）的一个特征。该群的元素是满足 $\\gcd(n,q)=1$ 的剩余类 $n \\pmod q$。该群的阶由欧拉函数给出，即 $|G| = \\varphi(q)$。\n\n对于给定的模 $q=5$，该群为 $G = \\left(\\mathbb{Z}/5\\mathbb{Z}\\right)^{\\times}$。由于 $5$ 是一个素数，该群由剩余类 $\\{1, 2, 3, 4\\} \\pmod 5$ 组成。该群的阶为 $|G| = \\varphi(5) = 5-1=4$。\n\n有限阿贝尔群 $G$ 的特征集 $\\hat{G}$ 具有一个称为正交关系的基本性质。第一正交关系涉及在单个群元素 $a \\in G$ 上求值的所有特征值的总和：\n$$\n\\sum_{\\chi \\in \\hat{G}} \\chi(a) =\n\\begin{cases}\n|G|  \\text{if } a = e \\\\\n0  \\text{if } a \\neq e\n\\end{cases}\n$$\n这里，$e$ 表示群 $G$ 的单位元。\n\n在我们的具体问题中，群是 $G = \\left(\\mathbb{Z}/5\\mathbb{Z}\\right)^{\\times}$，其阶为 $|G| = \\varphi(5)=4$，单位元是剩余类 $1 \\pmod 5$。求和是在元素 $a=2 \\pmod 5$ 上进行的。\n\n我们应用正交关系。由于元素 $a=2$ 不是群 $\\left(\\mathbb{Z}/5\\mathbb{Z}\\right)^{\\times}$ 中的单位元 $e=1$（即 $2 \\not\\equiv 1 \\pmod 5$），我们处于该关系的第二种情况。因此，和必为零。\n$$\nS = \\sum_{\\chi \\bmod 5} \\chi(2) = 0\n$$\n\n这可以通过显式构造来验证。群 $G = \\left(\\mathbb{Z}/5\\mathbb{Z}\\right)^{\\times}$ 是一个4阶循环群，一个生成元是 $g=2$。这 $\\varphi(5)=4$ 个不同的特征，我们可以将其标记为 $\\chi_k$（其中 $k \\in \\{0, 1, 2, 3\\}$），由它们在该生成元上的值确定。值 $\\chi_k(g)$ 必须是4次单位根。具体来说，我们可以定义 $\\chi_k(2) = \\exp(2\\pi i k/4) = i^k$。\n这四个特征在参数 $2$ 处的值是：\n\\begin{itemize}\n    \\item 对于 $k=0$（主特征）：$\\chi_0(2) = i^0 = 1$\n    \\item 对于 $k=1$：$\\chi_1(2) = i^1 = i$\n    \\item 对于 $k=2$：$\\chi_2(2) = i^2 = -1$\n    \\item 对于 $k=3$：$\\chi_3(2) = i^3 = -i$\n\\end{itemize}\n于是和为\n$$\nS = \\chi_0(2) + \\chi_1(2) + \\chi_2(2) + \\chi_3(2) = 1 + i + (-1) + (-i) = 0\n$$\n这个直接计算证实了从正交关系得到的结果。\n\n这个结果的解释与特征在分离剩余类中的作用有关。正交关系意味着由\n$$\nf(n) = \\frac{1}{\\varphi(q)} \\sum_{\\chi \\bmod q} \\chi(n)\n$$\n定义的函数，对于与 $q$ 互质的整数 $n$，充当了剩余类 $1 \\pmod q$ 的指示函数。也就是说，如果 $n \\equiv 1 \\pmod q$，则 $f(n)=1$；如果 $n \\not\\equiv 1 \\pmod q$（并且 $\\gcd(n,q)=1$），则 $f(n)=0$。这种“筛选”或“过滤”性质是狄利克雷算术级数定理证明的基础，因为它允许人们计算特定级数内的素数数量。我们的计算 $S = \\sum_{\\chi \\bmod 5} \\chi(2) = 0$ 是这一原理的直接展示。和恰好为 $0$ 是因为 $2 \\not\\equiv 1 \\pmod 5$。如果求和是针对 $\\chi(1)$，结果将会是 $\\varphi(5)=4$，对应于指示函数非零的情况。", "answer": "$$\\boxed{0}$$", "id": "3084154"}, {"introduction": "理论的优雅最终要在数据的现实中得到体现。通过编写一个简单的程序来计算和比较不同算术级数中的素数数量，你将从经验上验证狄利克雷定理，并可能观察到被称为“素数竞赛”的有趣现象。[@problem_id:3084184]", "problem": "设 $q$ 为一个正整数，设 $a$ 为一个整数，满足 $0 \\le a  q$。由数对 $(a,q)$ 定义的等差数列是集合 $\\{a + kq : k \\in \\mathbb{Z}_{\\ge 0}\\}$。关于等差数列的狄利克雷定理断言，如果最大公约数 (GCD) $\\gcd(a,q)=1$，那么该数列中存在无穷多个素数。其一个核心的定性结论是，对于固定的模 $q$ 和与 $q$ 互质的剩余类 $a$，素数在这些剩余类中呈渐进均匀分布。在本问题中，您将研究特定剩余类中素数的有限计数，以观察这种定性行为在有限边界下的表现。\n\n您必须编写一个程序，为每个测试用例计算以下量：\n- 给定一个上界 $B$、一个模 $q$ 以及两个剩余类 $r_1$ 和 $r_2$（满足 $0 \\le r_1, r_2  q$ 且 $\\gcd(r_1,q)=\\gcd(r_2,q)=1$），计算：\n  1. $C_1(B;q,r_1) = \\sum_{p \\le B,\\, p \\equiv r_1 \\bmod q} 1$，其中求和项为素数 $p$。\n  2. $C_2(B;q,r_2) = \\sum_{p \\le B,\\, p \\equiv r_2 \\bmod q} 1$，其中求和项为素数 $p$。\n- 计算差值 $D(B;q,r_1,r_2) = C_1(B;q,r_1) - C_2(B;q,r_2)$。\n\n您的程序必须基于以下第一性原理实现计算：\n- 素数的定义：一个整数 $p \\ge 2$ 是素数，如果它的正因数只有 $1$ 和 $p$。\n- 同余的定义：整数 $x$ 和 $y$ 满足 $x \\equiv y \\bmod q$，如果 $q$ 整除 $x-y$。\n- 要求只对素数 $p \\le B$ 进行计数，并且只有满足 $p \\equiv r_1 \\bmod q$ 或 $p \\equiv r_2 \\bmod q$ 的素数才分别包含在各自的和中。\n\n您应该实现一个正确且高效的素数枚举算法，直至测试套件中出现的最大上界 $B$。本问题不涉及物理单位或角度单位。\n\n测试套件：\n- 用例 1（理想情况，受狄利克雷定理启发的经典比较）：$B=200$，$q=4$，$r_1=1$，$r_2=3$。\n- 用例 2（边界行为，上界非常小）：$B=3$，$q=4$，$r_1=1$，$r_2=3$。\n- 用例 3（更大的上界以观察更接近的平衡）：$B=1000$，$q=4$，$r_1=1$，$r_2=3$。\n- 用例 4（不同模数和两个互质剩余类）：$B=200$，$q=3$，$r_1=1$，$r_2=2$。\n\n对于每个测试用例，您的程序必须以整数形式输出列表 $[C_1(B;q,r_1), C_2(B;q,r_2), D(B;q,r_1,r_2)]$。您的程序应生成单行输出，其中包含所有测试用例的结果，并聚合成一个列表的列表，不含空格，格式如下：\n$[[C_1,C_2,D],[C_1,C_2,D],[C_1,C_2,D],[C_1,C_2,D]]$。", "solution": "已根据指定标准对用户提供的问题进行了分析和验证。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n- **定义**：\n  - 关于 $(a,q)$ 的等差数列：$\\{a + kq : k \\in \\mathbb{Z}_{\\ge 0}\\}$。\n  - 关于等差数列的狄利克雷定理：如果 $\\gcd(a,q)=1$，数列 $\\{a + kq\\}$ 包含无穷多个素数。\n  - 素数：一个整数 $p \\ge 2$，其正因数只有 $1$ 和 $p$。\n  - 同余：$x \\equiv y \\bmod q$，如果 $q$ 整除 $x-y$。\n- **待计算的量**：对于给定的上界 $B$、模 $q$ 和剩余类 $r_1, r_2$：\n  1. $C_1(B;q,r_1) = \\sum_{p \\le B,\\, p \\equiv r_1 \\bmod q} 1$，其中求和项为素数 $p$。\n  2. $C_2(B;q,r_2) = \\sum_{p \\le B,\\, p \\equiv r_2 \\bmod q} 1$，其中求和项为素数 $p$。\n  3. $D(B;q,r_1,r_2) = C_1(B;q,r_1) - C_2(B;q,r_2)$。\n- **约束条件**：\n  - $q$ 是一个正整数。\n  - $0 \\le r_1, r_2  q$。\n  - $\\gcd(r_1,q)=1$ 且 $\\gcd(r_2,q)=1$。\n  - 求和项为素数 $p \\le B$。\n- **测试套件**：\n  - 用例 1：$B=200$，$q=4$，$r_1=1$，$r_2=3$。\n  - 用例 2：$B=3$，$q=4$，$r_1=1$，$r_2=3$。\n  - 用例 3：$B=1000$，$q=4$，$r_1=1$，$r_2=3$。\n  - 用例 4：$B=200$，$q=3$，$r_1=1$，$r_2=2$。\n- **输出格式**：一个不含空格的列表的列表，例如 $[[C_1,C_2,D],[C_1,C_2,D],...]$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n问题被认定为有效。\n- **科学性**：本问题基于数论中已确立的概念，即素数、模运算和关于等差数列的狄利克雷定理。其前提在事实上是正确的。\n- **适定性**：问题定义清晰。对于任何一组有效的输入 $(B, q, r_1, r_2)$，量 $C_1$、$C_2$ 和 $D$ 都是唯一可确定的。每个测试用例都提供了所有必要的参数。\n- **客观性**：语言精确且数学化，没有歧义或主观论断。\n- 提供的测试用例满足所述约束，特别是每个用例都满足 $\\gcd(r_1,q)=1$ 和 $\\gcd(r_2,q)=1$。例如，在用例 1 中，$\\gcd(1,4)=1$ 且 $\\gcd(3,4)=1$。在用例 4 中，$\\gcd(1,3)=1$ 且 $\\gcd(2,3)=1$。\n- 计算任务定义明确，在典型的计算限制内是可行的。\n\n**第 3 步：结论与行动**\n\n此问题是 **有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案\n\n解决此问题需要两个主要的计算步骤：首先，生成所有小于等于所需最大上界的素数；其次，遍历这些素数，为每个测试用例计算有多少素数落入指定的剩余类中。\n\n**1. 素数生成**\n\n问题要求一种“从第一性原理”出发的方法来识别素数。生成小于等于特定限制 $N$ 的所有素数的高效标准算法是埃拉托斯特尼筛法 (Sieve of Eratosthenes)。测试套件中指定的最大上界是 $B=1000$，因此我们将筛法上限设为 $N=1000$。\n\n埃拉托斯特尼筛法的过程如下：\n- 创建一个大小为 $N+1$ 的布尔数组 `is_prime`，并将从索引 $2$ 到 $N$ 的所有条目初始化为 `True`。索引 $0$ 和 $1$ 的条目被标记为 `False`，因为它们不是素数。\n- 从第一个素数 $p=2$ 开始。\n- 在 `is_prime` 数组中，将 $p$ 的所有倍数（即 $2p, 3p, 4p, \\dots$）直到 $N$ 都标记为 `False`，因为它们是合数。\n- 找到下一个大于 $p$ 且仍标记为 `True` 的数。这是下一个素数。重复标记其倍数为 `False` 的过程。\n- 此过程一直持续到 $p$ 超过 $\\sqrt{N}$。对 $p$ 设置此上限的原因是，任何合数 $c \\le N$ 必定至少有一个素因子小于或等于 $\\sqrt{c} \\le \\sqrt{N}$。\n\n筛法完成后，`is_prime` 数组可作为所有小于等于 $N$ 的整数的素性完整查找表。`is_prime[i]` 为 `True` 当且仅当 $i$ 是一个素数。这个预计算对整个测试用例集只执行一次。\n\n**2. 统计剩余类中的素数**\n\n有了预计算的 `is_prime` 数组，我们现在可以处理每个测试用例 $(B, q, r_1, r_2)$。对于每个用例，我们需要计算 $C_1(B;q,r_1)$、$C_2(B;q,r_2)$ 以及它们的差值 $D$。\n\n单个测试用例的算法如下：\n- 初始化两个计数器，$c_1 = 0$ 和 $c_2 = 0$。\n- 遍历从 $2$ 到给定上界 $B$ 的所有整数 $p$。\n- 对于每个 $p$，通过查找 `is_prime[p]` 来检查它是否为素数。\n- 如果 $p$ 是素数，计算其模 $q$ 的余数，即 $p \\pmod q$。\n  - 如果 $p \\pmod q = r_1$，则计数器 $c_1$ 加一。\n  - 如果 $p \\pmod q = r_2$，则计数器 $c_2$ 加一。\n- 循环完成后，最终的计数为 $C_1 = c_1$ 和 $C_2 = c_2$。\n- 然后计算差值 $D = C_1 - C_2$。\n\n对测试套件中的每个测试用例重复此过程，并收集每个用例的结果 $[C_1, C_2, D]$。最终输出被格式化为单个字符串，表示这些结果列表的列表，不含多余字符或空格。\n\n此方法正确实现了问题陈述中提供的定义，依赖于素性和模运算的基本定义，并使用了适合给定约束的高效算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the prime counting problem for the given test cases.\n    \n    The method involves two main steps:\n    1. Pre-computation: Generate all primes up to the maximum bound specified\n       in the test suite using an efficient Sieve of Eratosthenes. The largest\n       bound is 1000.\n    2. Case-by-case processing: For each test case (B, q, r1, r2), iterate\n       through numbers up to the bound B, use the sieve to check for primality,\n       and count the primes that fall into the required residue classes r1 and r2\n       modulo q.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (B, q, r1, r2)\n        (200, 4, 1, 3),  # Case 1\n        (3, 4, 1, 3),    # Case 2\n        (1000, 4, 1, 3), # Case 3\n        (200, 3, 1, 2)   # Case 4\n    ]\n\n    # Find the maximum bound needed for the sieve.\n    max_B = 0\n    if test_cases:\n        max_B = max(case[0] for case in test_cases)\n    \n    # Step 1: Sieve of Eratosthenes to find all primes up to max_B.\n    # is_prime[i] will be True if i is prime.\n    # We use a numpy array for efficient boolean indexing and slicing.\n    is_prime = np.ones(max_B + 1, dtype=bool)\n    if max_B >= 0:\n        is_prime[0] = False\n    if max_B >= 1:\n        is_prime[1] = False\n        \n    # The sieve loop only needs to go up to sqrt(max_B).\n    for p in range(2, int(np.sqrt(max_B)) + 1):\n        if is_prime[p]:\n            # Mark all multiples of p as not prime.\n            # Start marking from p*p, as smaller multiples are already marked.\n            is_prime[p*p :: p] = False\n\n    # A list to store the results of each test case.\n    results = []\n\n    # Step 2: Process each test case.\n    for B, q, r1, r2 in test_cases:\n        # C1 corresponds to r1, C2 corresponds to r2.\n        c1 = 0\n        c2 = 0\n        \n        # Iterate through numbers up to the specific bound B for this case.\n        # We start from 2, the first prime.\n        for p in range(2, B + 1):\n            if is_prime[p]:  # Check if p is prime using the pre-computed sieve.\n                residue = p % q\n                if residue == r1:\n                    c1 += 1\n                elif residue == r2:\n                    c2 += 1\n                    \n        # Calculate the difference D.\n        d = c1 - c2\n        \n        # Append the result triplet for the current case.\n        results.append([c1, c2, d])\n\n    # Final print statement in the exact required format.\n    # The format is [[C1,C2,D],[C1,C2,D],...] with no spaces.\n    # We build the string manually to ensure no spaces are introduced.\n    result_str_parts = []\n    for res_list in results:\n        # Format each inner list as \"[val1,val2,val3]\"\n        result_str_parts.append(f\"[{res_list[0]},{res_list[1]},{res_list[2]}]\")\n    \n    # Join the inner lists with commas and wrap with outer brackets.\n    final_output_str = f\"[{','.join(result_str_parts)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3084184"}]}