{"hands_on_practices": [{"introduction": "掌握扩展欧几里得算法的理论是第一步，而亲手实践是巩固理解的关键。本练习提供了一对具体的正整数，旨在引导你完整地走一遍算法流程，通过回代等方法计算出满足裴蜀等式的整数解，从而牢固掌握其核心计算技巧。[@problem_id:3082249]", "problem": "设 $a$ 和 $b$ 为整数，其中 $a=141$ 且 $b=96$。最大公约数 $\\gcd(a,b)$ 定义为能同时整除 $a$ 和 $b$ 的最大正整数。一个基本事实是，$a$ 和 $b$ 的任何公约数都能整除它们的每一个整数组合 $ua+vb$（其中 $u$ 和 $v$ 为整数），反之，所有整数组合的集合 $\\{ua+vb: u,v \\in \\mathbb{Z}\\}$ 正好由 $\\gcd(a,b)$ 的所有倍数构成。欧几里得算法是基于久经检验的恒等式 $\\gcd(a,b)=\\gcd(b,a \\bmod b)$，通过重复带余除法来计算 $\\gcd(a,b)$ 的过程。Bézout’s identity（裴蜀恒等式）断言，存在整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$。扩展欧几里得算法（EEA）是在执行欧几里得算法的同时，追踪得出这种表示的整数系数的方法。\n\n基于这些基础，对 $a=141$ 和 $b=96$ 执行扩展欧几里得算法（EEA），以计算满足 $141x+96y=\\gcd(141,96)$ 的具体整数 $x$ 和 $y$。您必须展示欧几里得算法的除法步骤，并通过这些方程进行回代，或者维护系数的迭代更新，将每个余数表示为 $141$ 和 $96$ 的整数组合。您的最终答案必须是验证了这些输入的裴蜀恒等式的特定有序对 $(x,y)$。不需要四舍五入。", "solution": "任务是找到整数 $x$ 和 $y$，使得 $141x + 96y = \\gcd(141, 96)$。我们将使用扩展欧几里得算法。\n\n第一阶段是使用标准的欧几里得算法通过一系列带余除法来计算最大公约数 $\\gcd(141, 96)$。\n设 $a = 141$ 且 $b = 96$。\n\n第1步：用 $96$ 除 $141$。\n$$141 = 1 \\cdot 96 + 45$$\n余数为 $r_1 = 45$。\n\n第2步：用前一个余数 $45$ 除 $96$。\n$$96 = 2 \\cdot 45 + 6$$\n余数为 $r_2 = 6$。\n\n第3步：用前一个余数 $6$ 除 $45$。\n$$45 = 7 \\cdot 6 + 3$$\n余数为 $r_3 = 3$。\n\n第4步：用前一个余数 $3$ 除 $6$。\n$$6 = 2 \\cdot 3 + 0$$\n余数为 $r_4 = 0$。\n\n最后一个非零余数即为最大公约数。因此，$\\gcd(141, 96) = 3$。\n\n第二阶段是通过回溯欧几里得算法的步骤（回代法），将最大公约数 $3$ 表示为 $141$ 和 $96$ 的整数线性组合。\n\n我们从产生最大公约数的方程（第3步）开始，解出余数 $3$：\n$$3 = 45 - 7 \\cdot 6$$\n\n接下来，我们使用前一步（第2步）的方程，将余数 $6$ 表示为 $96$ 和 $45$ 的形式：$6 = 96 - 2 \\cdot 45$。将这个表达式代入到关于 $3$ 的方程中：\n$$3 = 45 - 7 \\cdot (96 - 2 \\cdot 45)$$\n展开并合并含有公因子 $45$ 和 $96$ 的项：\n$$3 = 45 - 7 \\cdot 96 + 14 \\cdot 45$$\n$$3 = (1 + 14) \\cdot 45 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 45 - 7 \\cdot 96$$\n\n最后，我们使用第一步的方程，将余数 $45$ 表示为原始数字 $141$ 和 $96$ 的形式：$45 = 141 - 1 \\cdot 96$。将这个表达式代入我们当前关于 $3$ 的方程中：\n$$3 = 15 \\cdot (141 - 1 \\cdot 96) - 7 \\cdot 96$$\n再次展开并合并项，这次是含有公因子 $141$ 和 $96$ 的项：\n$$3 = 15 \\cdot 141 - 15 \\cdot 96 - 7 \\cdot 96$$\n$$3 = 15 \\cdot 141 + (-15 - 7) \\cdot 96$$\n$$3 = 15 \\cdot 141 - 22 \\cdot 96$$\n\n这个最终方程的形式是 $141x + 96y = 3$。通过直接比较，我们可以确定整数系数 $x$ 和 $y$：\n$$x = 15$$\n$$y = -22$$\n\n作为检验，我们可以计算该表达式的值：$141(15) + 96(-22) = 2115 - 2112 = 3$。这证实了解答的正确性。所求的有序对是 $(15, -22)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n15  -22\n\\end{pmatrix}\n}\n$$", "id": "3082249"}, {"introduction": "真实的数学问题往往比基础模型更复杂，例如涉及负数以及解的唯一性问题。本练习将挑战你处理带有负数的情况，并要求你在找到满足裴蜀等式的一组解后，进一步探索其通解的结构，最终找出一个满足特定最小化条件 $|x|$ 的解。[@problem_id:3082279] 这个过程将让你深刻体会到从一个特解推导通解的重要性。", "problem": "设 $a=-84$ 且 $b=30$。回顾最大公约数 $\\gcd(a,b)$ 的定义，即理想 $\\{au+bv: u,v \\in \\mathbb{Z}\\}$ 的唯一正生成元。贝祖恒等式断言存在整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$。仅使用 $\\gcd$ 作为理想的正生成元的定义以及带回代的欧几里得算法，确定整数 $x$ 和 $y$ 使得 $ax+by=\\gcd(a,b)$，并确保即使 $a0$，$\\gcd(a,b)>0$。在所有这样的整数对中，报告 $|x|$ 最小的那一对 $(x,y)$。你的最终答案应为这个有序整数对。", "solution": "问题要求找到满足 $a=-84$ 和 $b=30$ 的贝祖等式的整数 $x$ 和 $y$，并附加约束条件 $|x|$ 最小。该等式由方程 $ax+by=\\gcd(a,b)$ 给出。\n\n首先，我们确定最大公约数 $\\gcd(a,b)$。根据定义，$\\gcd(-84, 30)$ 必须是一个正整数。由于最大公约数对其参数的符号不敏感，我们有 $\\gcd(-84, 30) = \\gcd(84, 30)$。我们对正整数 $84$ 和 $30$ 应用欧几里得算法：\n$$84 = 2 \\cdot 30 + 24$$\n$$30 = 1 \\cdot 24 + 6$$\n$$24 = 4 \\cdot 6 + 0$$\n最后一个非零余数是 $6$。因此，$\\gcd(-84, 30) = 6$。\n\n需要求解的方程是 $-84x + 30y = 6$。\n\n接下来，我们使用扩展欧几里得算法（通过回代）来找到一个特解。我们使用上述算法中的方程，从得到最大公约数的那个方程开始：\n$$6 = 30 - 1 \\cdot 24$$\n从算法的第一步，我们有 $24 = 84 - 2 \\cdot 30$。将这个 $24$ 的表达式代入到关于 $6$ 的方程中：\n$$6 = 30 - 1 \\cdot (84 - 2 \\cdot 30)$$\n分配 $-1$：\n$$6 = 30 - 1 \\cdot 84 + 2 \\cdot 30$$\n合并含有 $30$ 和 $84$ 的项：\n$$6 = (1+2) \\cdot 30 - 1 \\cdot 84$$\n$$6 = 3 \\cdot 30 - 1 \\cdot 84$$\n这给出了关系式 $84(-1) + 30(3) = 6$。\n\n我们的目标方程是 $-84x + 30y = 6$。我们可以将恒等式 $84(-1) + 30(3) = 6$ 重写为：\n$$-84(1) + 30(3) = 6$$\n将此与 $-84x + 30y = 6$ 比较，我们确定一个特解 $(x_0, y_0) = (1, 3)$。\n验证：$-84(1) + 30(3) = -84 + 90 = 6$。该解是正确的。\n\n现在，我们求丢番图方程 $-84x + 30y = 6$ 的通解。首先，将所有项除以 $\\gcd(-84, 30) = 6$ 来简化方程：\n$$-14x + 5y = 1$$\n我们的特解 $(x_0, y_0) = (1, 3)$ 也满足这个简化后的方程：$-14(1) + 5(3) = -14 + 15 = 1$。\n相关的齐次方程是 $-14x + 5y = 0$，即 $5y = 14x$。由于 $\\gcd(5, 14)=1$，齐次方程的通解必须是 $x_h = 5k$ 和 $y_h = 14k$ 的形式，其中 $k$ 是任意整数。\n\n非齐次方程的通解是一个特解与齐次方程通解的和：\n$$x(k) = x_0 + x_h = 1 + 5k$$\n$$y(k) = y_0 + y_h = 3 + 14k$$\n其中 $k$ 是任意整数。\n\n问题要求我们找到使 $|x|$ 最小的整数对 $(x,y)$。我们需要找到使 $|x(k)| = |1+5k|$ 最小的整数 $k$。\n我们寻找一个整数 $k$，使得 $1+5k$ 的值尽可能接近 $0$。使 $1+5t=0$ 的实数 $t = -1/5 = -0.2$。最接近 $-0.2$ 的整数是 $0$ 和 $-1$。我们测试这些值：\n如果 $k=0$，则 $x(0) = 1+5(0) = 1$，且 $|x(0)|=1$。\n如果 $k=-1$，则 $x(-1) = 1+5(-1) = -4$，且 $|x(-1)|=4$。\n$x$ 的最小绝对值是 $1$，这在 $k=0$ 时出现。\n\n最后，我们将 $k=0$ 代入 $(x,y)$ 的通解中，以找到所需的整数对：\n$$x = 1 + 5(0) = 1$$\n$$y = 3 + 14(0) = 3$$\n得到的整数对是 $(1, 3)$。\n\n我们验证这个最终答案：$-84(1) + 30(3) = -84+90 = 6 = \\gcd(-84, 30)$。该解与所有条件一致。", "answer": "$$\\boxed{\\begin{pmatrix} 1  3 \\end{pmatrix}}$$", "id": "3082279"}, {"introduction": "将数学理论转化为可靠的计算工具是学以致用的最高体现。这个综合性练习要求你编写一个完整的计算机程序，实现扩展欧几里得算法，使其能够处理各种边界情况，如输入为零或极大整数。[@problem_id:3085685] 此外，你还需要从底层算术的角度分析并解决在计算中可能遇到的整数溢出问题，这是连接纯粹数学与计算实践的关键一步。", "problem": "你需要实现一个完整、可运行的程序，通过扩展欧几里得算法计算整数对的贝祖系数，以及最大公约数和最小公倍数。整数的界限为 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。你的方法必须从基本的数论定义出发，并且除了这些基础知识外，不能假定任何预先打包好的结果。\n\n基本依据：\n- 最大公约数的定义：对于不全为零的整数 $a$ 和 $b$，最大公约数 $\\gcd(a,b)$ 是唯一的非负整数 $g$，满足 $g \\mid a$，$g \\mid b$，并且对于任何满足 $d \\mid a$ 和 $d \\mid b$ 的整数 $d$，都有 $d \\le g$。\n- 除法算法：对于整数 $x$ 和 $y \\ne 0$，存在唯一的整数 $q$ 和 $r$，满足 $x = y q + r$ 且 $0 \\le r  \\lvert y \\rvert$。\n- 欧几里得算法：余数序列 $r_0 = \\lvert a \\rvert$，$r_1 = \\lvert b \\rvert$ 和 $r_{k+1} = r_{k-1} - q_k r_k$（其中 $q_k = \\lfloor r_{k-1} / r_k \\rfloor$）最终会终止于 $r_m = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。\n- 贝祖系数的定义：整数 $x$ 和 $y$ 满足 $a x + b y = \\gcd(a,b)$。\n- 最小公倍数的定义：最小公倍数 $\\operatorname{lcm}(a,b)$ 是能同时被 $a$ 和 $b$ 整除的最小非负整数 $L$；对于不全为零的 $a$ 和 $b$，$\\operatorname{lcm}(a,b) = \\lvert a b \\rvert / \\gcd(a,b)$ 且 $\\operatorname{lcm}(0,0) = 0$。\n\n任务：\n- 根据上述原理实现扩展欧几里得算法，为每个测试用例计算一个四元组 $\\big(\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)\\big)$，其中 $x$ 和 $y$ 满足 $a x + b y = \\gcd(a,b)$ 且 $\\gcd(a,b) \\ge 0$，并约定 $\\gcd(0,0) = 0$，此时任何有效的贝祖对 $x = 0, y = 0$ 均可。\n- 根据底层整数运算解释，如何避免在除法算法产生的系数更新 $x \\leftarrow x - q y$ 和 $y \\leftarrow y - q x$ 中出现整数溢出，以及如何计算 $\\operatorname{lcm}(a,b)$ 以避免溢出。\n\n约束条件：\n- 输入满足 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$。\n- 最小公倍数应报告为非负整数，对于任意整数 $b$，$\\operatorname{lcm}(0,b) = 0$。\n\n测试套件：\n你的程序必须为以下 $(a,b)$ 对列表计算结果：\n- $(12,18)$\n- $(0,0)$\n- $(0,5)$\n- $(10^9,1)$\n- $(-10^9,10^9)$\n- $(832040,514229)$\n- $(-24,-18)$\n- $(123456789,987654321)$\n- $(0,-7)$\n- $(1,10^9)$\n- $(7,-3)$\n\n答案规范：\n- 对于每个测试用例，输出列表 $[\\gcd(a,b), x, y, \\operatorname{lcm}(a,b)]$。\n- 将所有测试用例的结果按给定顺序汇总到单行中，该行为一个用方括号括起来的逗号分隔列表，其中每个元素本身是对应一个测试用例的列表。例如，整体格式必须类似于 $[[g_1,x_1,y_1,\\ell_1],[g_2,x_2,y_2,\\ell_2],\\dots]$。\n- 输出必须是程序打印的单行内容。不应打印任何额外注释。\n- 你提交的必须是如上所述的完整、可运行的程序，无用户输入。", "solution": "任务是为整数对 $(a,b)$ 计算一个四元组 $(\\gcd(a,b), x, y, \\operatorname{lcm}(a,b))$，其中 $x$ 和 $y$ 是满足 $ax+by = \\gcd(a,b)$ 的贝祖系数。解决方案的核心在于实现扩展欧几里得算法，并谨慎处理符号、特殊情况和潜在的整数溢出。\n\n### 数学基础\n\n1.  **最大公约数 (GCD) 和欧几里得算法**：欧几里得算法是计算两个整数最大公约数的高效方法，它基于原理 $\\gcd(a, b) = \\gcd(b, a \\pmod b)$。算法迭代应用此属性。给定输入 $r_0 = a$ 和 $r_1 = b$，序列定义为 $r_{k+1} = r_{k-1} \\pmod{r_k}$，这等同于除法算法中的 $r_{k-1} = q_k r_k + r_{k+1}$。最后一个非零余数 $r_m$ 即为 GCD。GCD 被定义为非负数，因此我们通常使用绝对值：$\\gcd(a,b) = \\gcd(\\lvert a \\rvert, \\lvert b \\rvert)$。按照惯例，$\\gcd(0,0)=0$。\n\n2.  **扩展欧几里得算法和贝祖恒等式**：贝祖恒等式指出，对于整数 $a$ 和 $b$，存在整数 $x$ 和 $y$（贝祖系数），使得 $ax + by = \\gcd(a,b)$。扩展欧几里得算法在计算 GCD 的同时计算这些系数。它维护两个序列 $s_k$ 和 $t_k$，使得在每一步 $k$，恒等式 $r_k = a s_k + b t_k$ 都成立。\n    从 $r_0=a$ 和 $r_1=b$ 开始，我们有：\n    - $r_0 = a \\cdot 1 + b \\cdot 0 \\implies (s_0, t_0) = (1, 0)$\n    - $r_1 = a \\cdot 0 + b \\cdot 1 \\implies (s_1, t_1) = (0, 1)$\n    余数的递推关系是 $r_{k+1} = r_{k-1} - q_k r_k$。代入贝祖表达式：\n    $$a s_{k+1} + b t_{k+1} = (a s_{k-1} + b t_{k-1}) - q_k (a s_k + b t_k)$$\n    $$a s_{k+1} + b t_{k+1} = a(s_{k-1} - q_k s_k) + b(t_{k-1} - q_k t_k)$$\n    这就得出了系数的递推关系：\n    - $s_{k+1} = s_{k-1} - q_k s_k$\n    - $t_{k+1} = t_{k-1} - q_k t_k$\n    当 $r_{k+1}=0$ 时算法终止，此时 $r_k = \\gcd(a,b)$，对应的系数是 $s_k$ 和 $t_k$。\n\n3.  **最小公倍数 (LCM)**：对于非零的 $a, b$，最小公倍数由恒等式 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a b \\rvert}{\\gcd(a,b)}$ 定义。问题规定，对于任意整数 $b$，$\\operatorname{lcm}(a,0)=\\operatorname{lcm}(0,b)=0$。\n\n### 算法实现\n\n实现将包含一个主函数，用于处理所有情况，包括一个或两个输入为零的边界情况。对于非零输入的一般情况，它将使用一个辅助函数来实现扩展欧几里得算法。\n\n**处理特殊情况**：\n- 如果 $a = 0$ 且 $b = 0$：问题规定 $\\gcd(0,0) = 0$，我们选择 $x=0, y=0$。$\\operatorname{lcm}(0,0)=0$。结果为 $(0, 0, 0, 0)$。\n- 如果 $a = 0, b \\ne 0$：$\\gcd(0,b) = \\lvert b \\rvert$。我们需要 $0 \\cdot x + b \\cdot y = \\lvert b \\rvert$，解得 $y = \\operatorname{sgn}(b)$，可选 $x=0$。$\\operatorname{lcm}(0,b)=0$。\n- 如果 $a \\ne 0, b = 0$：对称地，$\\gcd(a,0) = \\lvert a \\rvert$。我们需要 $a \\cdot x + 0 \\cdot y = \\lvert a \\rvert$，解得 $x = \\operatorname{sgn}(a)$，可选 $y=0$。$\\operatorname{lcm}(a,0)=0$。\n\n**一般情况 ($a \\ne 0, b \\ne 0$):**\n为简化逻辑，我们对输入的绝对值 $\\lvert a \\rvert$ 和 $\\lvert b \\rvert$ 应用扩展欧几里得算法。假设这得到 $(g, x', y')$，使得 $\\lvert a \\rvert x' + \\lvert b \\rvert y' = g$，其中 $g = \\gcd(a,b)$。我们需要为原始的 $a, b$ 找到 $x, y$。\n我们知道 $a = \\operatorname{sgn}(a) \\lvert a \\rvert$ 和 $b = \\operatorname{sgn}(b) \\lvert b \\rvert$。将这些代入恒等式：\n$$g = a (\\operatorname{sgn}(a)x') + b (\\operatorname{sgn}(b)y')$$\n因此，最终系数为 $x = \\operatorname{sgn}(a) x'$ 和 $y = \\operatorname{sgn}(b) y'$。这系统地处理了所有符号组合。\n\n### 避免整数溢出\n\n问题要求解释如何管理潜在的整数溢出，这在使用定长整数的语言（例如 C++ 中的 `long long`）中尤其重要。Python 的任意精度整数抽象了这个问题，但底层的算术原理很重要。\n\n1.  **贝祖系数更新**：更新步骤为 $s_{\\text{new}} = s_{\\text{old}} - q \\cdot s$ 和 $t_{\\text{new}} = t_{\\text{old}} - q \\cdot t$。在算法执行过程中，系数 $s$ 和 $t$ 会增长。一个已知的结论是，对于正整数 $a, b$，标准算法产生的最终贝祖系数 $x, y$ 满足 $\\lvert x \\rvert \\le b/\\gcd(a,b)$ 和 $\\lvert y \\rvert \\le a/\\gcd(a,b)$。中间系数的大小也受此限制。对于给定的约束 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$，这些系数本身不会溢出 64 位整数。然而，中间乘积 $q \\cdot s$ 或 $q \\cdot t$ 可能很大。其最大值量级约为 $\\lvert ab \\rvert / \\gcd(a,b)^2$。对于给定的约束，这个值最大可达约 $10^{18}$，这可以容纳在一个标准的 64 位有符号整数中（其最大值约为 $9 \\times 10^{18}$）。因此，使用 64 位整数类型执行计算足以防止系数更新中的溢出。Python 的标准整数自动处理此问题。\n\n2.  **LCM 计算**：LCM 的公式是 $\\operatorname{lcm}(a,b) = \\frac{\\lvert a \\cdot b \\rvert}{\\gcd(a,b)}$。如果 $a$ 和 $b$ 很大，对分子 $\\lvert a \\cdot b \\rvert$ 的朴素计算可能会溢出。当 $\\lvert a \\rvert, \\lvert b \\rvert \\le 10^9$ 时，乘积可达 $10^{18}$。为了在通用库函数中稳健地处理，最佳实践是避免这个大的中间乘积。由于 $\\gcd(a,b)$ 能整除 $a$（和 $b$），我们可以在乘法之前执行除法，以确保中间结果不会不必要地增大。计算 LCM 的安全方法是：\n    $$\\operatorname{lcm}(a,b) = \\left( \\frac{\\lvert a \\rvert}{\\gcd(a,b)} \\right) \\cdot \\lvert b \\rvert$$\n    除法 $\\lvert a \\rvert / \\gcd(a,b)$ 会得到一个精确的整数。随后的乘法对给定约束下的 64 位整数也是安全的。\n\n所提供的 Python 代码实现了这一逻辑。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n\n    def _compute_bezout_lcm(a, b):\n        \"\"\"\n        Computes the GCD, Bézout coefficients (x, y), and LCM for a pair of integers (a, b).\n        The result is a tuple (g, x, y, l) where:\n        - g = gcd(a, b) = 0\n        - ax + by = g\n        - l = lcm(a, b) = 0\n        \"\"\"\n        if a == 0 and b == 0:\n            return 0, 0, 0, 0\n\n        # Handle cases where one input is zero.\n        # gcd(a, 0) = |a|, lcm(a, 0) = 0.\n        # ax + 0y = |a| = x = |a|/a = sgn(a), y can be 0.\n        if b == 0:\n            g = abs(a)\n            x = 1 if a = 0 else -1\n            y = 0\n            lcm = 0\n            return g, x, y, lcm\n        \n        # gcd(0, b) = |b|, lcm(0, b) = 0.\n        # 0x + by = |b| = y = |b|/b = sgn(b), x can be 0.\n        if a == 0:\n            g = abs(b)\n            x = 0\n            y = 1 if b = 0 else -1\n            lcm = 0\n            return g, x, y, lcm\n\n        # General case (a!=0, b!=0)\n        # We run the extended Euclidean algorithm on |a| and |b|\n        # to ensure the gcd is non-negative and simplify the iteration.\n        sign_a = 1 if a  0 else -1\n        sign_b = 1 if b  0 else -1\n        abs_a = abs(a)\n        abs_b = abs(b)\n\n        # Extended Euclidean Algorithm\n        # Initializes such that old_r = old_s*abs_a + old_t*abs_b and r = s*abs_a + t*abs_b\n        s, old_s = 0, 1\n        t, old_t = 1, 0\n        r, old_r = abs_b, abs_a\n        \n        while r != 0:\n            quotient = old_r // r\n            old_r, r = r, old_r - quotient * r\n            old_s, s = s, old_s - quotient * s\n            old_t, t = t, old_t - quotient * t\n\n        # Result of algorithm on absolute values:\n        # g = gcd(|a|, |b|), x_abs = old_s, y_abs = old_t\n        # such that |a|*x_abs + |b|*y_abs = g\n        g = old_r\n        x_abs = old_s\n        y_abs = old_t\n\n        # Adjust coefficients for original signs of a and b.\n        # We want a*x + b*y = g.\n        # We have |a|*x_abs + |b|*y_abs = g.\n        # Substituting a = sgn(a)*|a| and b = sgn(b)*|b|:\n        # a/(sgn(a))*x_abs + b/(sgn(b))*y_abs = g\n        # a*(sgn(a)*x_abs) + b*(sgn(b)*y_abs) = g\n        # So x = sgn(a)*x_abs and y = sgn(b)*y_abs\n        x = x_abs * sign_a\n        y = y_abs * sign_b\n        \n        # Calculate LCM safely to avoid overflow\n        # lcm(a,b) = (|a| * |b|) / gcd(a,b)\n        # To avoid intermediate overflow, compute as (|a| / gcd) * |b|\n        lcm = (abs_a // g) * abs_b\n        \n        return g, x, y, lcm\n\n    test_cases = [\n        (12, 18),\n        (0, 0),\n        (0, 5),\n        (10**9, 1),\n        (-10**9, 10**9),\n        (832040, 514229),\n        (-24, -18),\n        (123456789, 987654321),\n        (0, -7),\n        (1, 10**9),\n        (7, -3),\n    ]\n\n    results = []\n    for a, b in test_cases:\n        g, x, y, l = _compute_bezout_lcm(a, b)\n        results.append(f\"[{g},{x},{y},{l}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3085685"}]}