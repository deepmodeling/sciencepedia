{"hands_on_practices": [{"introduction": "这个练习不仅仅是简单的计算，它更强调策略性地解决问题。当面对一个巨大的指数和一个合数模时，直接计算是不切实际的。本练习将引导你运用数论中的两个强大工具：使用中国剩余定理将问题分解为更小、更易于管理的部分，并使用欧拉降幂定理来大幅削减指数的规模。掌握这种方法 [@problem_id:3087333] 是高效解决复杂模算术问题的关键。", "problem": "设 $m$ 是一个正整数模数，且 $a,b \\in \\mathbb{Z}$。回顾模运算的基本事实：若 $a \\equiv b \\pmod{m}$，则对于任意 $c \\in \\mathbb{Z}$，有 $a+c \\equiv b+c \\pmod{m}$ 和 $ac \\equiv bc \\pmod{m}$，并且重复使用这些规则使得在计算的每一步将中间和与积对 $m$ 取模是合理的。仅使用这些性质以及任何你可以从第一性原理证明其陈述的初等数论中的标准定理（例如，欧拉定理和中国剩余定理），通过系统地将中间乘积对 $1000$ 取模，并解释每次取模为何有效，来计算 $7^{123}$ 模 $1000$ 的最小非负余数。你的最终答案必须是集合 $\\{0,1,2,\\dots,999\\}$ 中的一个整数。", "solution": "问题是求 $7^{123}$ 模 $1000$ 的最小非负余数。令 $x = 7^{123}$。我们需要计算 $x \\pmod{1000}$。\n\n模数是 $m = 1000$。我们可以将模数分解为 $1000 = 10^3 = (2 \\cdot 5)^3 = 2^3 \\cdot 5^3 = 8 \\cdot 125$。因子 $m_1=8$ 和 $m_2=125$ 是互质的，即 $\\gcd(8, 125)=1$。这个结构提示我们可以使用中国剩余定理（CRT）。CRT 提供了一种求解同余方程组的方法。具体来说，如果我们能求出 $7^{123}$ 模 $8$ 和模 $125$ 的余数，我们就可以将它们组合起来，求出模 $1000$ 的唯一解。使用CRT是合理的，因为它是初等数论中的一个标准定理，可以从问题陈述中提供的同余基本性质推导出来。\n\n我们将分别求解同余方程 $x \\equiv 7^{123} \\pmod{8}$ 和 $x \\equiv 7^{123} \\pmod{125}$。\n\n首先，我们来计算 $7^{123} \\pmod{8}$。\n底数是 $7$。我们注意到 $7 \\equiv -1 \\pmod{8}$。题目陈述了如果 $a \\equiv b \\pmod{m}$，则 $ac \\equiv bc \\pmod{m}$。对任意正整数指数 $k$ 重复应用此性质，我们可以得出 $a^k \\equiv b^k \\pmod{m}$。将此应用于我们的情况：\n$$7^{123} \\equiv (-1)^{123} \\pmod{8}$$\n因为 $123$ 是一个奇数，所以 $(-1)^{123} = -1$。\n因此，\n$$7^{123} \\equiv -1 \\equiv 7 \\pmod{8}$$\n\n其次，我们来计算 $7^{123} \\pmod{125}$。\n模数是 $125 = 5^3$。由于 $\\gcd(7, 125) = 1$，我们可以应用欧拉降幂定理。该定理是合理的，因为它是拉格朗日定理应用于模 $m$ 整数乘法群 $(\\mathbb{Z}/m\\mathbb{Z})^\\times$ 的直接推论，该群的阶由欧拉函数 $\\phi(m)$ 给出。对于任何与 $m$ 互质的 $a$，有 $a^{\\phi(m)} \\equiv 1 \\pmod{m}$。\n对于素数的幂 $p^k$，欧拉函数由 $\\phi(p^k) = p^k - p^{k-1}$ 给出。在我们的例子中，$m=125=5^3$，所以\n$$\\phi(125) = \\phi(5^3) = 5^3 - 5^{3-1} = 125 - 25 = 100$$\n根据欧拉定理，我们有 $7^{\\phi(125)} \\equiv 7^{100} \\equiv 1 \\pmod{125}$。\n我们可以使用这个结果来简化指数 $123$。\n$$7^{123} = 7^{100} \\cdot 7^{23}$$\n$$7^{123} \\equiv 1 \\cdot 7^{23} \\equiv 7^{23} \\pmod{125}$$\n这一步是有效的，因为我们可以在乘积中对因子进行模 $m$ 运算。\n现在，我们必须计算 $7^{23} \\pmod{125}$。我们使用平方求幂法，该方法系统地将中间乘积模 $125$ 化简。每一步化简的有效性再次由性质“若 $a \\equiv b \\pmod m$ 且 $c \\equiv d \\pmod m$，则 $ac \\equiv bd \\pmod m$”来保证。\n让我们计算 $7$ 的各次幂模 $125$ 的值：\n$$7^1 \\equiv 7 \\pmod{125}$$\n$$7^2 = 49 \\equiv 49 \\pmod{125}$$\n$$7^4 = (7^2)^2 \\equiv 49^2 = 2401 \\pmod{125}$$\n因为 $2401 = 19 \\cdot 125 + 26$，我们有 $7^4 \\equiv 26 \\pmod{125}$。\n$$7^8 = (7^4)^2 \\equiv 26^2 = 676 \\pmod{125}$$\n因为 $676 = 5 \\cdot 125 + 51$，我们有 $7^8 \\equiv 51 \\pmod{125}$。\n$$7^{16} = (7^8)^2 \\equiv 51^2 = 2601 \\pmod{125}$$\n因为 $2601 = 20 \\cdot 125 + 101$，我们有 $7^{16} \\equiv 101 \\pmod{125}$。\n为了计算 $7^{23}$，我们可以将指数分解为 $23 = 16+4+3$。一个更直接的方法是注意到 $23=20+3$。让我们计算 $7^{20}$：\n$$7^{20} = 7^{16} \\cdot 7^4 \\equiv 101 \\cdot 26 \\pmod{125}$$\n乘积是 $101 \\cdot 26 = 2626$。因为 $2626 = 21 \\cdot 125 + 1$，我们有 $7^{20} \\equiv 1 \\pmod{125}$。\n现在我们可以如下计算 $7^{23}$：\n$$7^{23} = 7^{20} \\cdot 7^3 \\equiv 1 \\cdot 7^3 \\equiv 7^3 \\pmod{125}$$\n我们计算 $7^3$：\n$$7^3 = 7 \\cdot 7^2 = 7 \\cdot 49 = 343$$\n因为 $343 = 2 \\cdot 125 + 93$，我们有 $7^3 \\equiv 93 \\pmod{125}$。\n因此，$7^{23} \\equiv 93 \\pmod{125}$。这意味着 $7^{123} \\equiv 93 \\pmod{125}$。\n\n我们现在已经建立了关于 $x = 7^{123}$ 的以下同余方程组：\n$$\n\\begin{cases}\nx \\equiv 7 \\pmod{8} \\\\\nx \\equiv 93 \\pmod{125}\n\\end{cases}\n$$\n从第二个同余方程，我们知道 $x$ 必须是 $x = 125k + 93$ 的形式，其中 $k$ 是某个整数。我们将这个表达式代入第一个同余方程：\n$$125k + 93 \\equiv 7 \\pmod{8}$$\n为了解出 $k$，我们首先将系数模 $8$ 化简：\n$125 = 15 \\cdot 8 + 5 \\implies 125 \\equiv 5 \\pmod{8}$。\n$93 = 11 \\cdot 8 + 5 \\implies 93 \\equiv 5 \\pmod{8}$。\n同余方程变为：\n$$5k + 5 \\equiv 7 \\pmod{8}$$\n两边同时减去 $5$：\n$$5k \\equiv 2 \\pmod{8}$$\n为了分离出 $k$，我们需要乘以 $5$ 模 $8$ 的乘法逆元。通过观察，$5 \\cdot 5 = 25 = 3 \\cdot 8 + 1$，所以 $5^{-1} \\equiv 5 \\pmod{8}$。两边同时乘以 $5$：\n$$5 \\cdot (5k) \\equiv 5 \\cdot 2 \\pmod{8}$$\n$$25k \\equiv 10 \\pmod{8}$$\n$$k \\equiv 2 \\pmod{8}$$\n这意味着 $k$ 可以写成 $k = 8j + 2$ 的形式，其中 $j$ 是某个整数。我们把这个表达式代回到 $x$ 的表达式中：\n$$x = 125(8j + 2) + 93$$\n$$x = 125 \\cdot 8j + 125 \\cdot 2 + 93$$\n$$x = 1000j + 250 + 93$$\n$$x = 1000j + 343$$\n这意味着 $x \\equiv 343 \\pmod{1000}$。\n$7^{123}$ 模 $1000$ 的最小非负余数是 $343$，它在所要求的集合 $\\{0,1,2,\\dots,999\\}$ 中。", "answer": "$$\\boxed{343}$$", "id": "3087333"}, {"introduction": "即使在应用了高阶定理之后，我们通常仍需处理一个核心的幂运算。这时，高效的算法就显得至关重要。本练习将深入探讨经典的“平方-乘”算法的内部机制。通过根据指数的二进制表示，手动追踪其所对应的平方和乘法操作序列，你将对该方法如何避免巨大的中间数并实现其卓越效率 [@problem_id:3087367] 建立起一个具体而深刻的理解。", "problem": "在模算术中，可以通过处理指数的二进制展开并结合模平方和模乘法来高效地计算重复幂运算。该方法基于模 $n$ 同余的定义、整数的二进制表示，以及模 $n$ 乘法群在乘法下的封闭性。使用从左到右平方-乘法 (LTR) 方法，该方法从最高有效位到最低有效位扫描指数的二进制位，计算 $3^{1001}$ 模 $437$ 的余数。你必须明确列出由 $1001$ 的二进制展开的各位决定的每个平方和乘法步骤，并在每一步中指明是否发生了乘法。将最终余数表示为集合 $\\{0,1,2,\\dots,436\\}$ 中的一个整数。无需四舍五入。", "solution": "该计算基于两个基本事实：(i) 对于整数 $a$、$b$ 和 $n$，如果 $a \\equiv b \\pmod{n}$，那么 $a \\cdot c \\equiv b \\cdot c \\pmod{n}$ 且 $a^{2} \\equiv b^{2} \\pmod{n}$；(ii) 每个正整数都有唯一的二进制展开，这允许将幂运算分解为一系列的平方和条件乘法。\n\n我们应用从左到右平方-乘法 (LTR) 方法。将指数 $e = 1001$ 写成二进制。计算其二进制展开：\n$$\n1001_{10} = 1111101001_{2},\n$$\n其从最高有效位到最低有效位的各位是 $b_{9} = 1$, $b_{8} = 1$, $b_{7} = 1$, $b_{6} = 1$, $b_{5} = 1$, $b_{4} = 0$, $b_{3} = 1$, $b_{2} = 0$, $b_{1} = 0$, $b_{0} = 1$。\n\nLTR 过程从最高位开始初始化。由于 $b_{9} = 1$，设\n$$\nc \\leftarrow 3 \\bmod 437.\n$$\n对于从 $i = 8$ 向下到 $i = 0$ 的每个后续位 $b_i$，执行一次模平方 $c \\leftarrow c^{2} \\bmod 437$；如果 $b_i = 1$，则再执行一次模乘法 $c \\leftarrow c \\cdot 3 \\bmod 437$。\n\n我们明确列出步骤：\n\n- 位 $b_{8} = 1$：\n  - 平方：$c \\leftarrow 3^{2} \\bmod 437 = 9$。\n  - 乘法：$c \\leftarrow 9 \\cdot 3 \\bmod 437 = 27$。\n\n- 位 $b_{7} = 1$：\n  - 平方：$c \\leftarrow 27^{2} \\bmod 437 = 729 \\bmod 437 = 292$ (因为 $729 - 437 = 292$)。\n  - 乘法：$c \\leftarrow 292 \\cdot 3 \\bmod 437 = 876 \\bmod 437 = 2$ (因为 $876 - 2 \\cdot 437 = 2$)。\n\n- 位 $b_{6} = 1$：\n  - 平方：$c \\leftarrow 2^{2} \\bmod 437 = 4$。\n  - 乘法：$c \\leftarrow 4 \\cdot 3 \\bmod 437 = 12$。\n\n- 位 $b_{5} = 1$：\n  - 平方：$c \\leftarrow 12^{2} \\bmod 437 = 144$。\n  - 乘法：$c \\leftarrow 144 \\cdot 3 \\bmod 437 = 432$。\n\n- 位 $b_{4} = 0$：\n  - 平方：$c \\leftarrow 432^{2} \\bmod 437$。注意 $432 \\equiv -5 \\pmod{437}$，所以 $432^{2} \\equiv (-5)^{2} = 25 \\pmod{437}$。因此 $c \\leftarrow 25$。\n  - 无乘法。\n\n- 位 $b_{3} = 1$：\n  - 平方：$c \\leftarrow 25^{2} \\bmod 437 = 625 \\bmod 437 = 188$ (因为 $625 - 437 = 188$)。\n  - 乘法：$c \\leftarrow 188 \\cdot 3 \\bmod 437 = 564 \\bmod 437 = 127$ (因为 $564 - 437 = 127$)。\n\n- 位 $b_{2} = 0$：\n  - 平方：$c \\leftarrow 127^{2} \\bmod 437$。计算 $127^{2} = 16129$。因为 $437 \\cdot 36 = 15732$，余数为 $16129 - 15732 = 397$。因此 $c \\leftarrow 397$。\n  - 无乘法。\n\n- 位 $b_{1} = 0$：\n  - 平方：$c \\leftarrow 397^{2} \\bmod 437$。注意 $397 \\equiv -40 \\pmod{437}$，所以 $397^{2} \\equiv (-40)^{2} = 1600 \\pmod{437}$。因为 $437 \\cdot 3 = 1311$，余数为 $1600 - 1311 = 289$。因此 $c \\leftarrow 289$。\n  - 无乘法。\n\n- 位 $b_{0} = 1$：\n  - 平方：$c \\leftarrow 289^{2} \\bmod 437$。计算 $289^{2} = 83521$。因为 $437 \\cdot 191 = 83467$，余数为 $83521 - 83467 = 54$。因此 $c \\leftarrow 54$。\n  - 乘法：$c \\leftarrow 54 \\cdot 3 \\bmod 437 = 162$。\n\n因此，\n$$\n3^{1001} \\bmod 437 = 162.\n$$\n\n作为使用中国剩余定理 (CRT) 的一致性检验，注意到 $437 = 19 \\cdot 23$，其中 $\\varphi(19) = 18$ 且 $\\varphi(23) = 22$，并且 $\\gcd(3,437) = 1$。那么\n$$\n3^{1001} \\equiv 3^{11} \\pmod{19} \\quad \\text{and} \\quad 3^{1001} \\equiv 3^{11} \\pmod{23},\n$$\n因为 $1001 \\equiv 11 \\pmod{18}$ 且 $1001 \\equiv 11 \\pmod{22}$。可以求得 $3^{11} \\equiv 10 \\pmod{19}$ 且 $3^{11} \\equiv 1 \\pmod{23}$。求解\n$$\nx \\equiv 10 \\pmod{19}, \\quad x \\equiv 1 \\pmod{23}\n$$\n得出 $x = 162$，这与计算出的余数相符。\n\nLTR 计算使用了 9 次模平方（每个非最高位一次）和 6 次模乘法（非最高位中每个为 1 的位一次），这说明了其效率与指数的位长和汉明权重有关。", "answer": "$$\\boxed{162}$$", "id": "3087367"}, {"introduction": "理论知识和手动计算通过编程实现而获得实践意义。这最后一个练习将挑战你将算法转化为代码，并分析其在现实世界中的权衡。你将实现并比较一个基准的二进制幂运算方法与一个更高级的优化技巧——滑动窗口法。这个练习 [@problem_id:3087355] 突显了算法设计中的一个基本概念：预计算开销与主计算循环效率之间的平衡。", "problem": "设计并实现一个程序，用于计算模幂运算，并在一个清晰、可复现的成本模型下比较算法效率。您必须实现两种算法来计算 $a^e \\bmod m$ 的余数：\n\n1. 一种基准的从左到右二进制方法（也称为从最高有效位开始进行位扫描的重复平方法）。\n2. 一种固定窗口大小 $w = 5$ 的从左到右滑动窗口方法。\n\n从以下数论和算术的基本事实出发：\n- 对于整数 $a$、$b$ 和正模数 $m$，约简性质 $(ab) \\bmod m = \\big((a \\bmod m)(b \\bmod m)\\big) \\bmod m$ 成立。\n- 如果 $e$ 是一个非负整数，其二进制展开为 $e = \\sum_{i=0}^{L-1} b_i 2^i$，其中每个 $b_i \\in \\{0,1\\}$，并且当 $e > 0$ 时 $b_{L-1} = 1$，那么 $a^e$ 可以通过由比特 $b_i$引导的平方和乘法运算来构建。\n- 两种算法都必须纯粹用模 $m$ 的模乘法和模约简来表示。\n\n需要实现的成本模型和计数规则：\n- 将每次模 $m$ 的模乘法计为单位成本 $1$。这包括平方运算，因为平方是乘法的一种特殊情况。\n- 对于基准二进制方法：没有预计算成本。该方法从最高有效位到最低有效位扫描 $e$ 的比特。在每个比特位，首先将当前累加器模 $m$ 平方，然后，如果该比特位是 $1$，则乘以底数模 $m$。对于 $e = 0$，直接返回 $1$，成本为零。\n- 对于窗口大小 $w = 5$ 的滑动窗口方法：\n  - 如果 $e=0$，直接返回 $1$，成本为零，并跳过预计算。\n  - 预计算底数的奇数次幂，直到小于 $2^w$ 的最大奇数：为每个满足 $1 \\le u  2^w$ 的奇数 $u$ 存储 $a^u \\bmod m$。使用递推关系 $a^1 \\bmod m = a \\bmod m$，计算 $a^2 \\bmod m$，然后对于 $u = 3,5,\\dots,2^w-1$，通过乘以 $a^2 \\bmod m$ 从先前的值计算出 $a^u \\bmod m$。计算此预计算过程中的每次模乘法。\n  - 从最高有效位到最低有效位扫描 $e$ 的比特。当遇到一个 $0$ 比特时，对累加器执行一次模 $m$ 的平方运算。当在位置 $i$ 遇到一个 $1$ 比特时，选择从 $i$ 开始的长度 $\\ell \\le w$ 的最长比特窗口，使得该窗口的最后一位是 $1$；将该窗口解释为一个在 $\\{1,3,\\dots,2^w-1\\}$ 中的奇数 $u$；对累加器执行 $\\ell$ 次平方运算，然后与预计算的 $a^u \\bmod m$ 进行一次乘法运算；向前推进 $\\ell$ 个比特。计算所有的模乘法，包括用于平方的运算和乘以 $a^u \\bmod m$ 的运算。\n\n您的程序必须：\n- 严格按照上述规定实现两种算法，并返回计算出的余数以及在给定成本模型下的总模乘法次数。\n- 对于每个测试用例，使用两种方法计算余数，并验证余数是否一致。\n- 对于每个测试用例，报告基准成本、滑动窗口成本以及定义为比率 $\\text{speedup} = \\dfrac{\\text{基准成本}}{\\text{滑动窗口成本}}$ 的观测加速比。如果两个成本都为零，则将加速比定义为 $1.0$。\n\n要实现和评估的测试套件：\n- 案例 A (主要): $a = 13$, $e = 1234567$, $m = 10^9 + 7$, $w = 5$。\n- 案例 B (边界指数): $a = 13$, $e = 0$, $m = 10^9 + 7$, $w = 5$。\n- 案例 C (小指数): $a = 13$, $e = 1$, $m = 10^9 + 7$, $w = 5$。\n- 案例 D (幂等底数): $a = 1$, $e = 987654321$, $m = 10^9 + 7$, $w = 5$。\n- 案例 E (混合比特指数): $a = 123456789$, $e = 2^{20} + 123$, $m = 10^9 + 7$, $w = 5$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个由逗号分隔的列表组成的列表，用方括号括起来，不含空格。每个内部列表必须具有 $[v,b,w,s]$ 的形式，其中：\n  - $v$ 是公共余数 $a^e \\bmod m$（整数），\n  - $b$ 是基准模乘法计数（整数），\n  - $w$ 是滑动窗口模乘法计数（整数），\n  - $s$ 是加速比（浮点数，四舍五入到六位小数）。\n- 对于五个测试用例 A 到 E，输出必须是形如 $[[v_A,b_A,w_A,s_A],[v_B,b_B,w_B,s_B],[v_C,b_C,w_C,s_C],[v_D,b_D,w_D,s_D],[v_E,b_E,w_E,s_E]]$ 的单行。\n\n此任务不涉及物理单位、角度单位或百分比；所有输出均为指定的纯数字。", "solution": "题目要求实现并比较两种模幂运算算法的效率：一种是基准的从左到右二进制方法，另一种是固定窗口大小 $w=5$ 的从左到右滑动窗口方法。比较将在一个特定的成本模型下进行，其中每次模乘法（包括平方）贡献单位成本 $1$。\n\n### 问题验证\n分析问题陈述的有效性。\n\n**步骤1：提取给定信息**\n- **算法**：\n  1.  **基准二进制方法**：计算 $a^e \\pmod m$。对于 $e>0$，从最高有效位到最低有效位遍历 $e$ 的比特。对于每个比特，首先对累加器进行平方，然后如果比特为 $1$，则乘以 $a$。对于 $e=0$，结果为 $1$。\n  2.  **滑动窗口方法 ($w=5$)**：计算 $a^e \\pmod m$。对于 $e>0$，首先预计算所有在 $[1, 2^w-1]$ 区间内的奇数 $u$ 对应的 $a^u \\pmod m$。然后，扫描 $e$ 的比特。对于 '0'，对累加器进行平方。对于 '1'，找到以 '1' 结尾且长度 $\\ell \\le w$ 的最长有效窗口，执行 $\\ell$ 次平方，并乘以预计算出的幂。对于 $e=0$，结果为 $1$。\n- **成本模型**：\n  - 每次模乘法或平方的成本为 $1$。\n  - **基准成本**：幂运算循环中乘法和平方的总和。$e=0$ 时的成本为 $0$。\n  - **滑动窗口成本**：预计算和幂运算的成本总和。$e=0$ 时的成本为 $0$。\n- **测试套件**：提供了五个测试用例 (A-E)，包含 $a$、$e$ 和 $m$ 的值。\n- **输出**：一个单行字符串，表示一个列表的列表，其中每个内部列表为 $[v, b, w, s]$，分别对应余数、基准成本、滑动窗口成本和加速比 ($b/w$)。\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据**：该问题在数论和算法分析方面有充分的依据。所描述的模算术性质和幂运算算法是标准且正确的。\n- **适定性**：问题被完全指定。所有输入、算法步骤和成本计算规则都得到了明确的定义。每个测试用例都存在一个唯一的、确定性的解。\n- **客观性**：问题以精确、客观的语言陈述，没有主观性断言。\n- **缺陷分析**：\n  - 该问题在科学上是合理的，并且是可形式化的。\n  - 设置是完整的且内部一致的。对基准算法的描述（“在每个比特位，首先平方……”）是具体的，对于一个比特长度为 $L$ 且置位比特数为 $\\text{popcount}(e)$ 的指数，其成本恰好为 $L + \\text{popcount}(e)$。\n  - 对滑动窗口算法的描述，包括预计算和窗口查找规则，也是精确的，可以直接实现。\n  - 该问题既不平凡也非同义反复；它提出了一个实质性的实现和分析任务。\n\n**步骤3：结论与行动**\n该问题被判定为 **有效**。这是一个计算数论领域中适定的、有科学依据的问题。将按规定进行求解。\n\n### 算法设计与实现\n\n**1. 基准从左到右二进制方法**\n\n此方法根据 $e$ 的二进制表示来计算 $a^e \\pmod m$。设 $e = (b_{L-1} b_{L-2} \\dots b_0)_2$。\n\n- **初始化**：如果 $e=0$，结果为 $1$，成本为 $0$。否则，累加器 `result` 初始化为 $1$，成本为 $0$。\n- **迭代**：算法从最高有效位 ($b_{L-1}$)到最低有效位 ($b_0$) 迭代 $L$ 次。在第 $i$ 步中：\n    1.  累加器平方：`result = (result * result) % m`。此操作使成本增加 $1$。\n    2.  如果当前比特 $b_{L-1-i}$ 为 $1$，则累加器乘以底数：`result = (result * a) % m`。此操作也使成本增加 $1$。\n- **成本分析**：设 $L$ 为 $e$ 的比特长度，$\\text{popcount}(e)$ 为置位比特数，则循环执行 $L$ 次平方和 $\\text{popcount}(e)$ 次乘法。总成本为 $L + \\text{popcount}(e)$。\n\n**2. 从左到右滑动窗口方法 ($w=5$)**\n\n该方法通过一次处理多个比特（一个“窗口”）来改进二进制方法。\n\n- **初始化**：如果 $e=0$，结果为 $1$，成本为 $0$。\n- **预计算 ($w=5$)**：对于 $e>0$，我们预计算 $a$ 的奇数次幂。\n    1.  计算 $a^2 \\pmod m$。成本：$1$。\n    2.  预计算幂的表中填充 $a^1, a^3, \\dots, a^{31}$。\n    3.  $a^1 \\pmod m$ 是给定的。\n    4.  后续的奇数次幂 $a^u \\pmod m$ 通过 $a^u = a^{u-2} \\cdot a^2 \\pmod m$ 计算。对于 $u \\in \\{3, 5, \\dots, 31\\}$，共有 $15$ 次这样的乘法。\n    5.  总预计算成本：$1 + 15 = 16$。\n- **幂运算**：$e$ 的二进制字符串从左到右扫描。\n    - 如果当前比特是 $0$，累加器平方，然后前进一个位置。成本：$1$ 次平方。\n    - 如果当前比特是 $1$，我们找到从当前位置开始的、长度 $\\ell \\le w$ 的、其值代表一个奇数（即最后一位是 $1$）的最长可能窗口。该窗口对应一个已预计算的奇数次幂 $a^u$。然后累加器平方 $\\ell$ 次，接着与预计算的 $a^u \\pmod m$ 进行一次乘法。然后我们前进 $\\ell$ 个位置。成本：$\\ell$ 次平方和 $1$ 次乘法。\n- **成本分析**：平方的总次数始终等于指数的比特长度 $L$。额外乘法的次数等于找到的窗口数。滑动窗口的总成本是预计算成本和幂运算成本的总和：$16 + L + (\\text{窗口数})$。\n\n**3. 程序结构**\n\n解决方案封装在 `solve` 函数中。两个辅助函数 `baseline_binary_method` 和 `sliding_window_method` 实现了上述逻辑。主函数遍历测试套件，调用两个辅助函数，验证计算出的余数是否匹配，计算加速比，并按要求格式化输出字符串。加速比定义为基准成本与滑动窗口成本之比。如果两个成本都为零（仅当 $e=0$ 时），则加速比定义为 $1.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Implements and compares two modular exponentiation algorithms\n    based on the problem specification.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, e, m, w)\n        (13, 1234567, 10**9 + 7, 5),          # Case A\n        (13, 0, 10**9 + 7, 5),                # Case B\n        (13, 1, 10**9 + 7, 5),                # Case C\n        (1, 987654321, 10**9 + 7, 5),         # Case D\n        (123456789, 2**20 + 123, 10**9 + 7, 5) # Case E\n    ]\n\n    def baseline_binary_method(a, e, m):\n        \"\"\"\n        Computes (a^e mod m) using the specified baseline left-to-right binary method.\n        Returns the result and the total cost in modular multiplications.\n        \"\"\"\n        if e == 0:\n            return 1, 0\n\n        a_mod = a % m\n        e_bin = bin(e)[2:]\n        e_len = len(e_bin)\n        \n        cost = 0\n        result = 1\n        \n        for i in range(e_len):\n            # Square\n            result = (result * result) % m\n            cost += 1\n            # Multiply if bit is 1\n            if e_bin[i] == '1':\n                result = (result * a_mod) % m\n                cost += 1\n        \n        return result, cost\n\n    def sliding_window_method(a, e, m, w):\n        \"\"\"\n        Computes (a^e mod m) using the specified left-to-right sliding-window method.\n        Returns the result and the total cost in modular multiplications.\n        \"\"\"\n        if e == 0:\n            return 1, 0\n\n        a_mod = a % m\n        \n        # --- Precomputation Step ---\n        precomp_cost = 0\n        precomputed_powers = {}\n        \n        # a^1 is the base\n        precomputed_powers[1] = a_mod\n        \n        # Compute a^2\n        if w >= 2:\n            a_sq = (a_mod * a_mod) % m\n            precomp_cost += 1\n        \n        # Compute odd powers a^3, a^5, ..., a^(2^w - 1)\n        # using u_i = u_{i-1} * a^2\n        limit = 2**w\n        for u in range(3, limit, 2):\n            prev_u_power = precomputed_powers[u-2]\n            current_u_power = (prev_u_power * a_sq) % m\n            precomp_cost += 1\n            precomputed_powers[u] = current_u_power\n            \n        # --- Exponentiation Step ---\n        exp_cost = 0\n        result = 1\n        \n        e_bin = bin(e)[2:]\n        e_len = len(e_bin)\n        i = 0\n        while i  e_len:\n            if e_bin[i] == '0':\n                # Process a zero bit: one squaring\n                result = (result * result) % m\n                exp_cost += 1\n                i += 1\n            else:\n                # Process a one bit: find longest valid window\n                search_end = min(i + w, e_len)\n                window_end_idx = i # Default to a 1-bit window\n                \n                # Find the end of the longest valid window (must end in '1')\n                # by searching backwards from the end of the potential window area.\n                for j in range(search_end - 1, i - 1, -1):\n                    if e_bin[j] == '1':\n                        window_end_idx = j\n                        break\n                \n                l = window_end_idx - i + 1\n                window_str = e_bin[i : window_end_idx + 1]\n                u = int(window_str, 2)\n                \n                # Perform l squarings\n                for _ in range(l):\n                    result = (result * result) % m\n                    exp_cost += 1\n                \n                # Perform one multiplication by the precomputed odd power\n                result = (result * precomputed_powers[u]) % m\n                exp_cost += 1\n                \n                i += l\n                \n        total_cost = precomp_cost + exp_cost\n        return result, total_cost\n\n    results_data = []\n    for case in test_cases:\n        a, e, m, w_val = case\n\n        v_base, b = baseline_binary_method(a, e, m)\n        v_win, w_cost = sliding_window_method(a, e, m, w_val)\n        \n        # This assertion verifies correctness; it should always pass for a correct implementation.\n        if v_base != v_win:\n             raise ValueError(f\"Mismatch in results for case {case}: base={v_base}, win={v_win}\")\n\n        if b == 0 and w_cost == 0:\n            s = 1.0\n        else:\n            # Avoid division by zero, though w_cost should not be 0 if b is not 0\n            s = round(b / w_cost, 6) if w_cost > 0 else float('inf')\n\n        results_data.append(f\"[{v_base},{b},{w_cost},{s}]\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_data)}]\")\n\nsolve()\n```", "id": "3087355"}]}