{"hands_on_practices": [{"introduction": "这项练习是进入周期连分数世界的经典切入点。我们将从最简单的二次无理数之一 $\\sqrt{2}$ 开始，通过计算其连分数展开式，揭示其简洁而优美的周期结构。这一过程不仅是一个有趣的数值计算，更重要的是，它将引导我们发现一种强大的方法，用以寻找著名的佩尔方程 (Pell's equation) $x^2 - 2y^2 = 1$ 的整数解，从而揭示数论与丢番图分析之间的深刻联系 [@problem_id:3086645]。", "problem": "设 $\\,\\alpha \\in \\mathbb{R}\\,$ 是一个二次无理数，意即 $\\,\\alpha\\,$ 是一个整系数二次多项式的实根，且 $\\,\\alpha\\,$ 不是有理数。实数 $\\,\\alpha\\,$ 的简单连分数（SCF）是形如\n$$\n\\alpha = a_{0} + \\cfrac{1}{a_{1} + \\cfrac{1}{a_{2} + \\cfrac{1}{\\ddots}}}\n$$\n的表达式，其中 $\\,a_{0} \\in \\mathbb{Z}\\,$ 且对所有 $\\,k \\geq 1\\,$ 都有 $\\,a_{k} \\in \\mathbb{Z}_{\\geq 1}\\,$。第 $\\,k\\,$ 个渐近分数 $\\,\\frac{p_{k}}{q_{k}}\\,$ 是通过将简单连分数在深度 $\\,k\\,$ 处截断并计算该有限分数的值得到的。关于二次无理数的 Lagrange 定理指出，任何二次无理数的简单连分数最终都是周期的。\n\n从以上定义出发，对 $\\,\\sqrt{2}\\,$ 完成以下任务：\n1. 通过算法约简计算 $\\,\\sqrt{2}\\,$ 的简单连分数展开，并确定其周期。\n2. 利用 $\\,\\sqrt{2}\\,$ 的渐近分数 $\\,\\frac{p_{k}}{q_{k}}\\,$ 的结构，证明存在无穷多对整数 $\\,\\bigl(x,y\\bigr) \\in \\mathbb{Z}^{2}\\,$ 解佩尔方程 $\\,x^{2} - 2 y^{2} = 1\\,$，并描述这些解是如何从连续的渐近分数中产生的。\n3. 从第一性原理出发，在不假设任何预先存在的闭式解的情况下，为方程 $\\,x^{2} - 2 y^{2} = 1\\,$ 的第 $\\,n\\,$ 个正整数解 $\\,\\bigl(x_{n}, y_{n}\\bigr)\\,$（按 $\\,x_{n}\\,$ 严格递增排序，$\\,n \\geq 1\\,$）推导出一个闭式表达式。将你的最终答案表示为关于 $\\,n\\,$ 的 $\\,x_{n} + y_{n} \\sqrt{2}\\,$ 的单一解析表达式。无需进行取整。", "solution": "该问题是有效的，因为它是数论这一成熟数学领域内一个关于连分数、二次无理数和佩尔方程之间关系的良定且自洽的问题。所有前提和定义都是标准和正确的。\n\n解答按要求分为三个部分。\n\n**1. $\\sqrt{2}$ 的简单连分数**\n\n为了求 $\\sqrt{2}$ 的简单连分数（SCF），我们使用标准算法。设 $\\alpha_0 = \\sqrt{2}$。该算法按如下步骤进行：\n$a_k = \\lfloor \\alpha_k \\rfloor$\n$\\alpha_{k+1} = \\frac{1}{\\alpha_k - a_k}$\n\n对于 $k=0$：\n$\\alpha_0 = \\sqrt{2}$。因为 $1  \\sqrt{2}  2$，所以整数部分为 $a_0 = \\lfloor \\sqrt{2} \\rfloor = 1$。\n余项为 $\\alpha_0 - a_0 = \\sqrt{2} - 1$。\n\n对于 $k=1$：\n$\\alpha_1 = \\frac{1}{\\sqrt{2} - 1}$。为了求其整数部分，我们将分母有理化：\n$\\alpha_1 = \\frac{1}{\\sqrt{2} - 1} \\times \\frac{\\sqrt{2} + 1}{\\sqrt{2} + 1} = \\frac{\\sqrt{2} + 1}{2-1} = \\sqrt{2} + 1$。\n因为 $1  \\sqrt{2}  2$，我们有 $2  \\sqrt{2} + 1  3$。所以，整数部分为 $a_1 = \\lfloor \\sqrt{2} + 1 \\rfloor = 2$。\n余项为 $\\alpha_1 - a_1 = (\\sqrt{2}+1) - 2 = \\sqrt{2} - 1$。\n\n对于 $k=2$：\n$\\alpha_2 = \\frac{1}{\\alpha_1 - a_1} = \\frac{1}{\\sqrt{2} - 1}$。\n这与 $\\alpha_1$ 的表达式相同。因此，$\\alpha_2 = \\alpha_1 = \\sqrt{2}+1$，这意味着 $a_2 = a_1 = 2$。\n由于 $\\alpha_{k+1}$ 仅依赖于 $\\alpha_k$，$\\alpha_k$ 值的序列，以及部分商 $a_k$ 的序列，将从此开始是周期的。我们有对所有 $k \\ge 1$，$\\alpha_k = \\sqrt{2}+1$ 且 $a_k = 2$。\n\n部分商序列为 $a_0 = 1, a_1 = 2, a_2 = 2, a_3 = 2, \\dots$。\n$\\sqrt{2}$ 的简单连分数展开为：\n$$ \\sqrt{2} = 1 + \\cfrac{1}{2 + \\cfrac{1}{2 + \\cfrac{1}{2 + \\ddots}}} $$\n这通常记作 $[1; 2, 2, 2, \\dots]$ 或 $[1; \\overline{2}]$。\n连分数的周期是重复块，即 $\\{2\\}$。周期长度为 $1$。\n\n**2. 佩尔方程与 $\\sqrt{2}$ 的渐近分数**\n\n简单连分数的渐近分数 $\\frac{p_k}{q_k}$ 使用以下递推关系计算：\n$p_k = a_k p_{k-1} + p_{k-2}$\n$q_k = a_k q_{k-1} + q_{k-2}$\n初始值为 $p_{-1}=1, q_{-1}=0, p_0=a_0=1, q_0=1$。\n\n让我们计算 $\\sqrt{2}=[1; \\overline{2}]$ 的前几个渐近分数，其中 $a_0=1$ 且对 $k \\ge 1$ 有 $a_k=2$：\n- $k=0$: $\\frac{p_0}{q_0} = \\frac{1}{1}$\n- $k=1$: $p_1 = a_1 p_0 + p_{-1} = 2(1) + 1 = 3$; $q_1 = a_1 q_0 + q_{-1} = 2(1) + 0 = 2$。渐近分数为 $\\frac{3}{2}$。\n- $k=2$: $p_2 = a_2 p_1 + p_0 = 2(3) + 1 = 7$; $q_2 = a_2 q_1 + q_0 = 2(2) + 1 = 5$。渐近分数为 $\\frac{7}{5}$。\n- $k=3$: $p_3 = a_3 p_2 + p_1 = 2(7) + 3 = 17$; $q_3 = a_3 q_2 + q_1 = 2(5) + 2 = 12$。渐近分数为 $\\frac{17}{12}$。\n- $k=4$: $p_4 = a_4 p_3 + p_2 = 2(17) + 7 = 41$; $q_4 = a_4 q_3 + q_2 = 2(12) + 5 = 29$。渐近分数为 $\\frac{41}{29}$。\n\n现在，让我们将这些数对 $(p_k, q_k)$ 代入表达式 $x^2 - 2y^2$ 中：\n- $(p_0, q_0)=(1,1): 1^2 - 2(1^2) = 1 - 2 = -1$。\n- $(p_1, q_1)=(3,2): 3^2 - 2(2^2) = 9 - 8 = 1$。\n- $(p_2, q_2)=(7,5): 7^2 - 2(5^2) = 49 - 50 = -1$。\n- $(p_3, q_3)=(17,12): 17^2 - 2(12^2) = 289 - 2(144) = 289 - 288 = 1$。\n- $(p_4, q_4)=(41,29): 41^2 - 2(29^2) = 1681 - 2(841) = 1681 - 1682 = -1$。\n\n观察到的模式是 $p_k^2 - 2q_k^2 = (-1)^{k+1}$。这是 $\\sqrt{D}$ 的渐近分数的一个已知性质。对于佩尔方程 $x^2 - 2y^2 = 1$ 的任何解，我们必须有 $p_k^2 - 2q_k^2 = 1$。这发生在指数 $k+1$ 为偶数时，即 $k$ 必须为奇数。\n\n因此，对于 $k=1, 3, 5, \\dots$，数对 $(x,y) = (p_k, q_k)$ 提供了佩尔方程 $x^2 - 2y^2 = 1$ 的解。\n当 $k \\ge 1$ 时，渐近分数的分子序列 $p_k$ 和分母序列 $q_k$ 是严格递增的。因为有无穷多个奇数 $k$，所以存在无穷多个不同的 $k$ 为奇数的渐近分数 $\\frac{p_k}{q_k}$。这些渐近分数中的每一个都为该方程提供了一个不同的解 $(x,y)=(p_k,q_k)$。这证明了存在无穷多对整数 $(x,y)$ 解方程 $x^2 - 2y^2 = 1$。\n这些解是奇数下标的渐近分数的分子和分母：$(p_1,q_1), (p_3,q_3), (p_5,q_5), \\ldots$。\n\n**3. 解的闭式表达式**\n\n我们寻求对于 $n \\ge 1$ 的第 $n$ 个正整数解 $(x_n, y_n)$（按 $x_n$ 递增排序）的闭式表达式。根据第 2 部分，这些解由 $(x_n,y_n) = (p_{2n-1}, q_{2n-1})$ 给出。为了找到闭式解，我们求解 $p_k$ 和 $q_k$ 的递推关系。\n\n对于 $k \\ge 1$，部分商总是 $a_k=2$。递推关系变为：\n$p_k = 2 p_{k-1} + p_{k-2}$\n$q_k = 2 q_{k-1} + q_{k-2}$\n这些是常系数线性齐次递推关系。两者的特征方程均为 $r^2 - 2r - 1 = 0$。\n其根由二次公式给出：$r = \\frac{2 \\pm \\sqrt{4 - 4(1)(-1)}}{2} = \\frac{2 \\pm \\sqrt{8}}{2} = 1 \\pm \\sqrt{2}$。\n设根为 $\\lambda_1 = 1+\\sqrt{2}$ 和 $\\lambda_2 = 1-\\sqrt{2}$。\n\n对于 $k \\ge 1$，$p_k$ 的通解为 $p_k = A\\lambda_1^k + B\\lambda_2^k$。我们使用初始值 $p_1=3$ 和 $p_2=7$ 来求常数 $A$ 和 $B$。\n对于 $k=1: 3 = A(1+\\sqrt{2}) + B(1-\\sqrt{2})$。\n对于 $k=2: 7 = A(1+\\sqrt{2})^2 + B(1-\\sqrt{2})^2 = A(3+2\\sqrt{2}) + B(3-2\\sqrt{2})$。\n这可以写成一个方程组：\n$3 = (A+B) + (A-B)\\sqrt{2}$\n$7 = 3(A+B) + 2(A-B)\\sqrt{2}$\n设 $U=A+B$ 且 $V=(A-B)\\sqrt{2}$。该方程组为 $3 = U+V$ 和 $7 = 3U+2V$。\n将第一个方程乘以 $2$ 得到 $6 = 2U+2V$。从第二个方程中减去此式得到 $1=U$，所以 $A+B=1$。\n然后 $V = 3-U = 2$，这意味着 $(A-B)\\sqrt{2}=2$，所以 $A-B=\\sqrt{2}$。\n求解 $A$ 和 $B$：$2A = 1+\\sqrt{2} \\implies A = \\frac{1+\\sqrt{2}}{2}$，以及 $2B = 1-\\sqrt{2} \\implies B = \\frac{1-\\sqrt{2}}{2}$。\n对于 $k \\ge 1$，$p_k$ 的闭式解为：\n$p_k = \\frac{1+\\sqrt{2}}{2}(1+\\sqrt{2})^k + \\frac{1-\\sqrt{2}}{2}(1-\\sqrt{2})^k = \\frac{1}{2}\\left((1+\\sqrt{2})^{k+1} + (1-\\sqrt{2})^{k+1}\\right)$。\n\n类似地，对于 $k \\ge 1$，$q_k$ 的通解为 $q_k = C\\lambda_1^k + D\\lambda_2^k$。我们使用初始值 $q_1=2$ 和 $q_2=5$。\n对于 $k=1: 2 = C(1+\\sqrt{2}) + D(1-\\sqrt{2})$。\n对于 $k=2: 5 = C(3+2\\sqrt{2}) + D(3-2\\sqrt{2})$。\n方程组：$2 = (C+D) + (C-D)\\sqrt{2}$ 和 $5 = 3(C+D) + 2(C-D)\\sqrt{2}$。\n设 $U'=C+D$ 且 $V'=(C-D)\\sqrt{2}$。该方程组为 $2 = U'+V'$ 和 $5 = 3U'+2V'$。\n$4 = 2U'+2V'$。相减得到 $1=U'$，所以 $C+D=1$。然后 $V'=1$，所以 $(C-D)\\sqrt{2}=1 \\implies C-D = \\frac{1}{\\sqrt{2}}$。\n求解 $C$ 和 $D$：$2C = 1+\\frac{1}{\\sqrt{2}} \\implies C = \\frac{\\sqrt{2}+1}{2\\sqrt{2}}$。\n$2D = 1-\\frac{1}{\\sqrt{2}} \\implies D = \\frac{\\sqrt{2}-1}{2\\sqrt{2}}$。\n对于 $k \\ge 1$，$q_k$ 的闭式解为：\n$q_k = \\frac{\\sqrt{2}+1}{2\\sqrt{2}}(1+\\sqrt{2})^k + \\frac{\\sqrt{2}-1}{2\\sqrt{2}}(1-\\sqrt{2})^k = \\frac{1}{2\\sqrt{2}}\\left((1+\\sqrt{2})^{k+1} - (1-\\sqrt{2})^{k+1}\\right)$，这里我们使用了 $(\\sqrt{2}-1) = -(1-\\sqrt{2})$。\n\n第 $n$ 个正整数解是 $(x_n, y_n) = (p_{2n-1}, q_{2n-1})$。我们将 $k=2n-1$ 代入 $p_k$ 和 $q_k$ 的公式中：\n$x_n = p_{2n-1} = \\frac{1}{2}\\left((1+\\sqrt{2})^{(2n-1)+1} + (1-\\sqrt{2})^{(2n-1)+1}\\right) = \\frac{1}{2}\\left((1+\\sqrt{2})^{2n} + (1-\\sqrt{2})^{2n}\\right)$。\n$y_n = q_{2n-1} = \\frac{1}{2\\sqrt{2}}\\left((1+\\sqrt{2})^{(2n-1)+1} - (1-\\sqrt{2})^{(2n-1)+1}\\right) = \\frac{1}{2\\sqrt{2}}\\left((1+\\sqrt{2})^{2n} - (1-\\sqrt{2})^{2n}\\right)$。\n\n题目要求我们给出 $x_n + y_n\\sqrt{2}$ 的表达式：\n$x_n + y_n\\sqrt{2} = \\frac{1}{2}\\left((1+\\sqrt{2})^{2n} + (1-\\sqrt{2})^{2n}\\right) + \\sqrt{2} \\cdot \\frac{1}{2\\sqrt{2}}\\left((1+\\sqrt{2})^{2n} - (1-\\sqrt{2})^{2n}\\right)$\n$x_n + y_n\\sqrt{2} = \\frac{1}{2}\\left((1+\\sqrt{2})^{2n} + (1-\\sqrt{2})^{2n}\\right) + \\frac{1}{2}\\left((1+\\sqrt{2})^{2n} - (1-\\sqrt{2})^{2n}\\right)$\n$x_n + y_n\\sqrt{2} = \\frac{1}{2}\\left( (1+\\sqrt{2})^{2n} + (1-\\sqrt{2})^{2n} + (1+\\sqrt{2})^{2n} - (1-\\sqrt{2})^{2n} \\right)$\n$x_n + y_n\\sqrt{2} = \\frac{1}{2}\\left( 2(1+\\sqrt{2})^{2n} \\right) = (1+\\sqrt{2})^{2n}$。\n\n这个表达式可以通过计算 $(1+\\sqrt{2})^2$ 来简化：\n$(1+\\sqrt{2})^2 = 1^2 + 2(1)\\sqrt{2} + (\\sqrt{2})^2 = 1 + 2\\sqrt{2} + 2 = 3+2\\sqrt{2}$。\n因此，第 $n$ 个解的表达式是：\n$x_n + y_n\\sqrt{2} = ((1+\\sqrt{2})^2)^n = (3+2\\sqrt{2})^n$。\n这对应于取基本解 $(x_1,y_1) = (p_1,q_1) = (3,2)$ 的幂，其中 $x_1+y_1\\sqrt{2} = 3+2\\sqrt{2}$。", "answer": "$$ \\boxed{(3+2\\sqrt{2})^n} $$", "id": "3086645"}, {"introduction": "在学会了分析给定数字的连分数之后，我们现在逆转这个过程。这项练习将挑战你成为一名“数字建筑师”，从一个预设的连分数结构——一个特定的预周期（pre-period）紧跟着一个循环节——出发，构造出拥有此精确展开式的二次无理数。这种“逆向工程”的方法能让你更深刻地理解一个数的代数性质与其连分数的几何结构之间的对应关系 [@problem_id:3086647]。", "problem": "设 $x$ 为一个实二次无理数，这意味着 $x$ 是一个整系数二次方程的实数根，且 $x$ 不是有理数。$x$ 的简单连分数是通过迭代映射 $T(x) = \\dfrac{1}{x - \\lfloor x \\rfloor}$ 得到的，由此产生部分商序列 $a_{0} = \\lfloor x \\rfloor$，$a_{1} = \\lfloor T(x) \\rfloor$，依此类推。如果一个连分数在 $k$ 次应用映射 $T$ 之后，达到一个其连分数为纯周期的实二次无理数，则称该连分数具有长度为 $k$ 的预周期（非周期部分）。一个实二次无理数 $y$ 被称为是简约的，如果 $y  1$ 且其代数共轭 $y'$ 满足 $-1  y'  0$，在这种情况下，$y$ 的简单连分数是纯周期的。\n\n仅使用这些定义和简单连分数的迭代构造法，构造一个简单连分数具有长度为 $k=3$ 的预周期的实二次无理数的具体例子。通过选择一个具有纯周期的简约代表数 $y$，然后前置 $k$ 次移位来形成一个非简约代表数 $x$ 来完成此任务。具体来说，取纯周期目标为简单连分数为 $\\left[\\overline{1,2}\\right]$ 的二次无理数，并在其前面加上三个数字 $a_{0} = 2$，$a_{1} = 3$ 和 $a_{2} = 4$ 以获得一个非简约代表数 $x$。\n\n计算 $x$ 的精确、简化的根式形式，并验证三次连分数移位运算可以恢复到具有纯周期的简约代表数。你的最终答案必须是你得到的 $x$ 的精确表达式，写成最简根式形式。不要提供任何中间值，只提供最终的精确表达式。", "solution": "题目要求构造一个实二次无理数 $x$，其简单连分数的预周期长度为 $k=3$，数字为 $a_0 = 2$，$a_1 = 3$ 和 $a_2 = 4$，其后跟着一个对应于简约二次无理数 $y = [\\overline{1,2}]$ 的纯周期部分。在以简化根式形式找到 $x$ 的值之后，我们必须验证三次应用连分数算法能恢复出 $y$。\n\n首先，我们确定纯周期部分 $y$ 的值。连分数 $y = [\\overline{1,2}]$ 可以写成：\n$$y = [1; 2, 1, 2, \\dots] = 1 + \\cfrac{1}{2 + \\cfrac{1}{1 + \\cfrac{1}{2 + \\dots}}}$$\n这种结构意味着 $y$ 满足方程：\n$$y = 1 + \\frac{1}{2 + \\frac{1}{y}}$$\n我们化简这个表达式来求出 $y$ 的二次方程：\n$$y = 1 + \\frac{y}{2y + 1} = \\frac{(2y + 1) + y}{2y + 1} = \\frac{3y + 1}{2y + 1}$$\n两边乘以分母 $(2y + 1)$ 得到：\n$$y(2y + 1) = 3y + 1$$\n$$2y^2 + y = 3y + 1$$\n$$2y^2 - 2y - 1 = 0$$\n使用二次方程求根公式 $y = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$，其中 $a=2$，$b=-2$，$c=-1$：\n$$y = \\frac{-(-2) \\pm \\sqrt{(-2)^2 - 4(2)(-1)}}{2(2)} = \\frac{2 \\pm \\sqrt{4 + 8}}{4} = \\frac{2 \\pm \\sqrt{12}}{4} = \\frac{2 \\pm 2\\sqrt{3}}{4} = \\frac{1 \\pm \\sqrt{3}}{2}$$\n由于 $y = [1; \\dots]$，其值必须大于 1。因此，我们选择正根：\n$$y = \\frac{1 + \\sqrt{3}}{2}$$\n作为检验，我们确认 $y$ 是一个简约二次无理数。我们有 $y = \\frac{1 + \\sqrt{3}}{2} \\approx \\frac{1+1.732}{2} = 1.366  1$。其代数共轭是 $y' = \\frac{1 - \\sqrt{3}}{2} \\approx -0.366$，满足 $-1  y'  0$。因此，$y$ 确实是简约的。\n\n接下来，我们使用前置数字 $a_0 = 2$，$a_1 = 3$，$a_2 = 4$ 和周期部分 $y$ 来构造 $x$。$x$ 的连分数是 $[a_0; a_1, a_2, y]$。\n$$x = [2; 3, 4, y] = 2 + \\cfrac{1}{3 + \\cfrac{1}{4 + \\cfrac{1}{y}}}$$\n我们通过代入 $y = \\frac{1 + \\sqrt{3}}{2}$ 并从内向外化简来计算这个值。\n首先，我们求 $4 + \\frac{1}{y}$ 的值：\n$$4 + \\frac{1}{y} = 4 + \\frac{2}{1 + \\sqrt{3}} = 4 + \\frac{2(1 - \\sqrt{3})}{(1 + \\sqrt{3})(1 - \\sqrt{3})} = 4 + \\frac{2(1 - \\sqrt{3})}{1 - 3} = 4 + \\frac{2(1 - \\sqrt{3})}{-2} = 4 - (1 - \\sqrt{3}) = 3 + \\sqrt{3}$$\n接下来，我们将此结果代入分数的下一层：\n$$3 + \\frac{1}{4 + \\frac{1}{y}} = 3 + \\frac{1}{3 + \\sqrt{3}} = 3 + \\frac{3 - \\sqrt{3}}{(3 + \\sqrt{3})(3 - \\sqrt{3})} = 3 + \\frac{3 - \\sqrt{3}}{9 - 3} = 3 + \\frac{3 - \\sqrt{3}}{6} = \\frac{18 + 3 - \\sqrt{3}}{6} = \\frac{21 - \\sqrt{3}}{6}$$\n最后，我们计算 $x$：\n$$x = 2 + \\frac{1}{\\frac{21 - \\sqrt{3}}{6}} = 2 + \\frac{6}{21 - \\sqrt{3}}$$\n为了化简，我们对分数进行分母有理化：\n$$\\frac{6}{21 - \\sqrt{3}} = \\frac{6(21 + \\sqrt{3})}{(21 - \\sqrt{3})(21 + \\sqrt{3})} = \\frac{6(21 + \\sqrt{3})}{21^2 - (\\sqrt{3})^2} = \\frac{6(21 + \\sqrt{3})}{441 - 3} = \\frac{6(21 + \\sqrt{3})}{438}$$\n由于 $438 = 6 \\times 73$，我们可以化简这个分数：\n$$\\frac{6(21 + \\sqrt{3})}{438} = \\frac{21 + \\sqrt{3}}{73}$$\n现在，我们将其代回 $x$ 的表达式中：\n$$x = 2 + \\frac{21 + \\sqrt{3}}{73} = \\frac{2 \\times 73 + 21 + \\sqrt{3}}{73} = \\frac{146 + 21 + \\sqrt{3}}{73} = \\frac{167 + \\sqrt{3}}{73}$$\n这就是 $x$ 的精确、简化的根式形式。\n\n为完成题目，我们验证三次应用连分数映射 $T(z) = \\frac{1}{z - \\lfloor z \\rfloor}$ 于 $x$ 能恢复出 $y$。设 $x_0 = x$。\n\n第一步：\n$$x_0 = \\frac{167 + \\sqrt{3}}{73}$$\n由于 $1  \\sqrt{3}  2$，我们有 $168  167 + \\sqrt{3}  169$。因此，$\\frac{168}{73}  x_0  \\frac{169}{73}$，约等于 $2.301  x_0  2.315$。\n所以，$a_0 = \\lfloor x_0 \\rfloor = 2$，这与给定的第一个数字相匹配。\n第一个余项是 $x_1$：\n$$x_1 = \\frac{1}{x_0 - a_0} = \\frac{1}{\\frac{167 + \\sqrt{3}}{73} - 2} = \\frac{1}{\\frac{167 + \\sqrt{3} - 146}{73}} = \\frac{73}{21 + \\sqrt{3}}$$\n$$x_1 = \\frac{73(21 - \\sqrt{3})}{(21 + \\sqrt{3})(21 - \\sqrt{3})} = \\frac{73(21 - \\sqrt{3})}{438} = \\frac{21 - \\sqrt{3}}{6}$$\n\n第二步：\n$$x_1 = \\frac{21 - \\sqrt{3}}{6}$$\n由于 $1  \\sqrt{3}  2$，我们有 $19  21 - \\sqrt{3}  20$。因此，$\\frac{19}{6}  x_1  \\frac{20}{6}$，约等于 $3.16  x_1  3.34$。\n所以，$a_1 = \\lfloor x_1 \\rfloor = 3$，这与给定的第二个数字相匹配。\n第二个余项是 $x_2$：\n$$x_2 = \\frac{1}{x_1 - a_1} = \\frac{1}{\\frac{21 - \\sqrt{3}}{6} - 3} = \\frac{1}{\\frac{21 - \\sqrt{3} - 18}{6}} = \\frac{6}{3 - \\sqrt{3}}$$\n$$x_2 = \\frac{6(3 + \\sqrt{3})}{(3 - \\sqrt{3})(3 + \\sqrt{3})} = \\frac{6(3 + \\sqrt{3})}{9 - 3} = \\frac{6(3 + \\sqrt{3})}{6} = 3 + \\sqrt{3}$$\n\n第三步：\n$$x_2 = 3 + \\sqrt{3}$$\n由于 $1.7  \\sqrt{3}  1.8$，我们有 $4.7  x_2  4.8$。\n所以，$a_2 = \\lfloor x_2 \\rfloor = 4$，这与给定的第三个数字相匹配。\n第三个余项是 $x_3$：\n$$x_3 = \\frac{1}{x_2 - a_2} = \\frac{1}{(3 + \\sqrt{3}) - 4} = \\frac{1}{\\sqrt{3} - 1}$$\n$$x_3 = \\frac{1(\\sqrt{3} + 1)}{(\\sqrt{3} - 1)(\\sqrt{3} + 1)} = \\frac{\\sqrt{3} + 1}{3 - 1} = \\frac{1 + \\sqrt{3}}{2}$$\n得到的这个值 $x_3$ 正是我们开始时 $y$ 的值。验证成功。数 $x = \\frac{167 + \\sqrt{3}}{73}$ 的连分数是 $[2; 3, 4, \\overline{1,2}]$。", "answer": "$$\\boxed{\\frac{167 + \\sqrt{3}}{73}}$$", "id": "3086647"}, {"introduction": "最后的这项实践练习将连接抽象理论与计算现实的鸿沟。你将推导并实现一个仅使用整数运算来计算 $\\sqrt{D}$ 连分数的算法，这对于保证计算的精确性和效率至关重要。这项练习将促使你仔细审视连分数算法的递推关系，并展示如何在不依赖浮点数的情况下稳健地实现它们，从而体现数论方法在计算科学中的力量 [@problem_id:3086643]。", "problem": "给定一个固定的非平方正整数 $D$，$\\sqrt{D}$ 的连分数展开是周期的。这是针对二次无理数的 Lagrange 定理的一个特例。目标是推导、证明并实现一个纯整数算法，该算法仅基于简单连分数的基本定义和二次无理数的代数运算，通过在每一步维护和更新一个整数三元组 $(m_n,d_n,a_n)$ 来计算 $\\sqrt{D}$ 的连分数。你必须根据所操作整数的二进制长度，分析算术运算的每步位复杂度。你的最终程序必须只使用整数算术，不得依赖浮点运算，并且绝不能要求外部输入。\n\n你的推导应从简单连分数的定义以及通过反转小数部分来产生下一个完全商的恒等式开始。从这个起点和二次无理数的代数恒等式出发，为三元组 $(m_n,d_n,a_n)$ 推导出一个纯整数更新规则，以产生 $\\sqrt{D}$ 的连续部分商。你必须证明更新规则在需要时保持整数性和正性，并且该过程无需任何浮点近似即可检测到 Lagrange 定理所保证的周期性。你还必须论证每次迭代的位复杂度：特别是，用依赖于 $D$ 大小的整数的二进制长度来表示单次迭代的成本，并解释为什么每步位复杂度受限于表示 $D$ 所需位数的一个常数倍。\n\n你的程序必须实现所推导的纯整数算法。对于每个测试用例，它必须：\n- 从程序中硬编码的固定测试套件中接受一个数对 $(D,k)$，其中 $D$ 是一个正整数，$k$ 也是一个正整数。\n- 如果 $D$ 是一个完全平方数，则输出仅由整数部分 $a_0=\\lfloor \\sqrt{D}\\rfloor$ 组成的平凡连分数，并报告周期长度为 $0$。\n- 如果 $D$ 不是完全平方数，则计算：\n  - $\\sqrt{D}$ 的连分数的周期长度 $L$。\n  - 使用严格的整数算术计算 $\\sqrt{D}$ 的前 $k$ 个部分商，从整数部分 $a_0$ 开始。\n  - 在检测一个完整周期过程中遇到的所有整数 $m_n$ 和 $d_n$ 的最大观测二进制长度（必须包括所有 $m_n$ 和 $d_n$，直到并包括首次检测到得出周期性所需的状态重复的那一步）。\n  - 一个布尔指示符，表示该观测到的最大二进制长度不超过界限 $\\lceil \\log_2(4\\lfloor \\sqrt{D}\\rfloor)\\rceil$。此界限可作为一个实践证明，表明每步涉及的整数相对于 $D$ 较小。对于完全平方数，按惯例只考虑 $a_0$，并且必须相应地报告此布尔值。\n\n你的程序必须生成一行输出，其中包含所有测试用例的结果，格式如下。对于给定顺序中的每个测试用例 $(D,k)$，输出一个列表\n$[L,\\ \\text{partials},\\ M,\\ B,\\ \\text{ok}]$\n其中：\n- $L$ 是周期长度（一个整数，当 $D$ 是完全平方数时 $L=0$），\n- $\\text{partials}$ 是非平方数 $D$ 的前 $k$ 个部分商的列表，对于完全平方数则是单元素列表 $[a_0]$，\n- $M$ 是在周期检测期间使用的所有 $m_n$ 和 $d_n$ 的最大观测二进制长度（一个整数；对于完全平方数，取 $M$ 为 $a_0$ 的二进制长度），\n- $B=\\lceil \\log_2(4\\lfloor \\sqrt{D}\\rfloor)\\rceil$（一个整数），\n- $\\text{ok}$ 是 $M\\le B$ 的布尔值。\n\n你的程序必须将所有测试用例的结果聚合到一个列表中，并将其作为一行打印，例如：\n$[[L_1,\\ \\text{partials}_1,\\ M_1,\\ B_1,\\ \\text{ok}_1],\\ [L_2,\\ \\text{partials}_2,\\ M_2,\\ B_2,\\ \\text{ok}_2],\\ \\ldots]$。\n\n要使用的测试套件（按此顺序硬编码在程序中）：\n- $(D,k)=(2,10)$,\n- $(D,k)=(3,8)$,\n- $(D,k)=(4,5)$,\n- $(D,k)=(7,12)$,\n- $(D,k)=(13,15)$,\n- $(D,k)=(61,18)$,\n- $(D,k)=(991,20)$,\n- $(D,k)=(2000,25)$.\n\n所有输出必须是纯数字或布尔值。不涉及物理单位。不出现角度。除了指定的单行结果列表外，不要打印任何其他文本。程序必须是完全确定性的和自包含的。唯一允许的库是执行环境所允许的库。最终输出必须是指定格式的唯一一行。", "solution": "该问题被评估为有效。它构成了一项定义明确的计算数论任务，基于已建立的数学原理（关于周期连分数的 Lagrange 定理），并具有一套清晰、客观且内部一致的要求。该问题要求推导、实现并分析一个用于计算 $\\sqrt{D}$ 连分数展开的纯整数算法的复杂度。\n\n### 1. 纯整数算法的推导\n\n一个实数 $\\xi$ 的简单连分数由以下递推关系定义：\n设 $\\xi_0 = \\xi$。对于 $n \\ge 0$，定义 $a_n = \\lfloor \\xi_n \\rfloor$ 和 $\\xi_{n+1} = \\frac{1}{\\xi_n - a_n}$，前提是 $\\xi_n$ 不是整数。序列 $a_0, a_1, a_2, \\ldots$ 就是部分商序列。\n\n我们关心的是 $\\xi = \\sqrt{D}$，其中 $D$ 是一个正的非平方整数。我们寻求将每个完全商 $\\xi_n$ 表示为二次无理数的形式：\n$$\n\\xi_n = \\frac{m_n + \\sqrt{D}}{d_n}\n$$\n其中 $m_n$ 和 $d_n$ 是整数。\n\n**初始化 (n=0):**\n对于初始项 $\\xi_0 = \\sqrt{D}$，我们可以将其写为 $\\xi_0 = \\frac{0 + \\sqrt{D}}{1}$。因此，我们用 $m_0 = 0$ 和 $d_0 = 1$ 来初始化我们的整数三元组。两者都是整数。第一个部分商是 $a_0 = \\lfloor \\xi_0 \\rfloor = \\lfloor \\sqrt{D} \\rfloor$。\n\n**递推关系的推导：**\n假设在第 $n$ 步我们有 $\\xi_n = \\frac{m_n + \\sqrt{D}}{d_n}$，我们推导 $\\xi_{n+1}$ 的形式：\n$$\n\\xi_{n+1} = \\frac{1}{\\xi_n - a_n} = \\frac{1}{\\frac{m_n + \\sqrt{D}}{d_n} - a_n} = \\frac{d_n}{m_n + \\sqrt{D} - a_n d_n} = \\frac{d_n}{(m_n - a_n d_n) + \\sqrt{D}}\n$$\n为了使分母有理化并匹配我们的目标形式，我们将分子和分母乘以分母的共轭项，即 $(m_n - a_n d_n) - \\sqrt{D}$。为方便代数运算，我们将分母写为 $\\sqrt{D} - (a_n d_n - m_n)$，其共轭项为 $\\sqrt{D} + (a_n d_n - m_n)$。\n$$\n\\xi_{n+1} = \\frac{d_n \\left( (a_n d_n - m_n) + \\sqrt{D} \\right)}{\\left(\\sqrt{D} - (a_n d_n - m_n)\\right)\\left(\\sqrt{D} + (a_n d_n - m_n)\\right)} = \\frac{d_n( (a_n d_n - m_n) + \\sqrt{D})}{D - (a_n d_n - m_n)^2}\n$$\n我们从分子中定义一个新的整数 $m_{n+1}$：\n$$\nm_{n+1} = a_n d_n - m_n\n$$\n将此代入 $\\xi_{n+1}$ 的表达式中得到：\n$$\n\\xi_{n+1} = \\frac{d_n (m_{n+1} + \\sqrt{D})}{D - m_{n+1}^2}\n$$\n为了匹配形式 $\\xi_{n+1} = \\frac{m_{n+1} + \\sqrt{D}}{d_{n+1}}$，我们必须有：\n$$\n\\frac{1}{d_{n+1}} = \\frac{d_n}{D - m_{n+1}^2}\n$$\n这得出了 $d_{n+1}$ 的更新规则：\n$$\nd_{n+1} = \\frac{D - m_{n+1}^2}{d_n}\n$$\n部分商 $a_n$ 本身需要使用整数算术来计算。由于 $a_n = \\lfloor \\xi_n \\rfloor = \\left\\lfloor \\frac{m_n + \\sqrt{D}}{d_n} \\right\\rfloor$，我们使用 $\\sqrt{D}$ 的整数部分，即 $a_0 = \\lfloor \\sqrt{D} \\rfloor$。我们将 $a_n$ 计算为：\n$$\na_n = \\left\\lfloor \\frac{m_n + a_0}{d_n} \\right\\rfloor\n$$\n这是正确的，因为可以证明，对于为 $\\sqrt{D}$ 生成的序列，这种纯整数计算与浮点版本产生相同的 $a_n$。\n\n**整数性和正性的证明：**\n如果 $m_n$ 和 $d_n$ 对所有 $n$ 都保持为整数，那么该算法就是一个“纯整数”算法。\n- **基本情况：** $m_0=0$ 和 $d_0=1$ 是整数。\n- **归纳步骤：** 假设在第 $n$ 步，$m_n, d_n$ 是整数。根据定义，$a_n = \\lfloor (m_n+a_0)/d_n \\rfloor$ 是一个整数。那么 $m_{n+1} = a_n d_n - m_n$ 显然是一个整数。要使 $d_{n+1}$ 成为整数，$d_n$ 必须整除 $D - m_{n+1}^2$。我们通过将其与上一步的值 $d_n = (D - m_n^2)/d_{n-1}$ 相关联来证明这一点，这意味着 $D-m_n^2 = d_n d_{n-1}$。\n$$\nD - m_{n+1}^2 = D - (a_n d_n - m_n)^2 = D - m_n^2 - (a_n d_n)^2 + 2a_n d_n m_n = d_{n-1} d_n - a_n^2 d_n^2 + 2a_n d_n m_n\n$$\n$$\nD - m_{n+1}^2 = d_n (d_{n-1} - a_n^2 d_n + 2a_n m_n)\n$$\n这表明 $D - m_{n+1}^2$ 是 $d_n$ 的整数倍，因此 $d_{n+1} = (D-m_{n+1}^2)/d_n$ 是一个整数。通过归纳法，所有的 $m_n$ 和 $d_n$ 都是整数。\n\n此外，对于 $n \\ge 1$，$\\xi_n = 1/(\\xi_{n-1}-a_{n-1})  1$。由于 $\\xi_n = (m_n+\\sqrt{D})/d_n$，并且可以证明其共轭 $\\xi'_n = (m_n-\\sqrt{D})/d_n$ 对于 $n \\ge 1$ 满足 $-1  \\xi'_n  0$，我们可以推断出 $d_n0$。具体来说，$\\xi_n - \\xi'_n = 2\\sqrt{D}/d_n > 1 - 0 = 1$。$\\xi_n\\xi'_n = (m_n^2-D)/d_n^2  0$，所以 $m_n^2  D$。这意味着 $D-m_n^2  0$。由于 $d_{n+1} = (D-m_{n+1}^2)/d_n$ 并且 $d_0=10$，通过归纳法可知，如果 $d_n  0$，那么 $d_{n+1}  0$。因此，所有的 $d_n$ 都是正整数。\n\n### 2. 周期性和有界性\n\n已知对于非平方数 $D$，$\\sqrt{D}$ 的连分数是周期的，形式为 $[a_0; \\overline{a_1, a_2, \\ldots, a_L}]$。该算法通过观察整数对 $(m_n, d_n)$ 序列中的重复来检测这个周期。\n对于 $n \\ge 1$，$m_n$ 和 $d_n$ 的值是有界的：\n$$\n0  m_n \\le \\lfloor\\sqrt{D}\\rfloor \\quad \\text{and} \\quad 0  d_n \\le 2\\lfloor\\sqrt{D}\\rfloor\n$$\n由于可能的整数对 $(m_n, d_n)$ 的数量是有限的，该序列最终必然会重复。根据鸽巢原理，存在索引 $i  j$ 使得 $(m_i, d_i) = (m_j, d_j)$。由于递推关系唯一地确定了下一个状态，这意味着三元组 $(m_k, d_k, a_k)$ 的序列对于 $k \\ge i$ 是周期的。对于 $\\sqrt{D}$，已知周期从 $n=1$ 开始。因此，第一次重复发生在当 $(m_{L+1}, d_{L+1}) = (m_1, d_1)$ 时，对于某个周期长度 $L \\ge 1$。\n\n### 3. 每步位复杂度分析\n\n设 $k_{bit} = \\lceil \\log_2 D \\rceil$ 是表示 $D$ 所需的位数。\n$m_n$ 和 $d_n$ 的界限意味着它们的大小为 $O(\\sqrt{D})$。因此，这些整数的位长为 $O(\\log(\\sqrt{D})) = O(\\frac{1}{2} \\log D) = O(k_{bit})$。部分商 $a_n$ 的大小也为 $O(\\sqrt{D})$，所以它们的位长也是 $O(k_{bit})$。\n\n我们分析算法单次迭代中算术运算的复杂度：\n1.  $a_n = \\lfloor (m_n + a_0) / d_n \\rfloor$：这涉及两个 $O(k_{bit})$ 位整数的加法，耗时 $O(k_{bit})$，然后是一个 $O(k_{bit})$ 位整数除以另一个 $O(k_{bit})$ 位整数。使用标准长除法，这耗时 $O(k_{bit}^2)$。\n2.  $m_{n+1} = a_n d_n - m_n$：这涉及两个 $O(k_{bit})$ 位整数 $a_n$ 和 $d_n$ 的乘法。乘积 $a_n d_n$ 的大小可达 $O(D)$，意味着其位长为 $O(k_{bit})$。乘法耗时 $O(k_{bit}^2)$。随后的减法耗时 $O(k_{bit})$。\n3.  $d_{n+1} = (D - m_{n+1}^2) / d_n$：此步骤涉及对一个 $O(k_{bit})$ 位整数 $m_{n+1}$ 进行平方，成本为 $O(k_{bit}^2)$ 并产生一个 $O(k_{bit})$ 位的结果（因为 $m_{n+1}^2  D$）。从 $D$ 中减去该值耗时 $O(k_{bit})$。最后将 $O(k_{bit})$ 位的结果除以 $O(k_{bit})$ 位的整数 $d_n$ 耗时 $O(k_{bit}^2)$。\n\n每一步都由位长与 $\\log D$ 成正比的数字的乘法和除法运算主导。因此，每步位复杂度为 $O((\\log D)^2)$。\n\n问题中关于为什么复杂度受限于“表示 $D$ 所需位数的一个常数倍”的询问，很可能指的是操作数的大小，而不是运算的时间复杂度。如上所示，循环内操作的所有整数（$m_n, d_n, a_n$ 以及像 $a_n d_n$ 或 $m_{n+1}^2$ 这样的中间乘积）的位长都是 $O(\\log D)$，这本身就是 $D$ 的位长的一个常数倍。这个性质至关重要，因为它防止了数字无限增长，确保了每步成本保持稳定。\n\n程序将验证实际界限 $M \\le B$，其中 $M$ 是观测到的 $m_n, d_n$ 的最大位长，而 $B = \\lceil \\log_2(4\\lfloor \\sqrt{D}\\rfloor)\\rceil$。$m_n$ 和 $d_n$ 的理论界限表明这个不等式应该成立。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the continued fraction problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        (2, 10),\n        (3, 8),\n        (4, 5),\n        (7, 12),\n        (13, 15),\n        (61, 18),\n        (991, 20),\n        (2000, 25),\n    ]\n\n    all_results = []\n    for D, k in test_cases:\n        result = compute_cf_sqrt_d(D, k)\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase for standard JSON-like output.\n    # The problem implies a python list `repr` output.\n    # [[L1, partials1, M1, B1, True], [L2, partials2, M2, B2, False], ...]\n    print(str(all_results).replace(\"'\", \"\"))\n\n\ndef compute_cf_sqrt_d(D, k):\n    \"\"\"\n    Computes the continued fraction of sqrt(D) using an integer-only algorithm.\n\n    Args:\n        D (int): A positive integer.\n        k (int): The number of partial quotients to compute.\n\n    Returns:\n        list: A list containing [L, partials, M, B, ok].\n    \"\"\"\n    if D == 0:\n        raise ValueError(\"D must be a positive integer.\")\n\n    a0 = math.isqrt(D)\n    \n    # Calculate the bound B = ceil(log2(4*a0))\n    # (N-1).bit_length() computes ceil(log2(N)) for N>0.\n    # If a0 is 0 (only if D=0, which is ruled out), this would be ill-defined.\n    # Since D is positive, a0 >= 1 if D is a perfect square >= 1.\n    # if a0=0 for D1, then this would fail. But D is a positive integer.\n    # for D>=1, a0 >= 1.\n    B = (4 * a0 - 1).bit_length() if a0 > 0 else 1\n\n\n    # Case 1: D is a perfect square\n    if a0 * a0 == D:\n        L = 0\n        partials = [a0]\n        # Per problem, for perfect squares, M is bit length of a0\n        M = a0.bit_length()\n        ok = M = B\n        return [L, partials, M, B, ok]\n\n    # Case 2: D is not a perfect square\n    partials_list = [a0]\n\n    m = 0\n    d = 1\n    \n    # Track m_n, d_n for period detection and bit length analysis.\n    # We must include m0, d0, and all subsequent pairs up to the one that\n    # detects the period.\n    m_history = [m]\n    d_history = [d]\n\n    # seen stores (m_n, d_n) -> n\n    seen_states = {}\n\n    # The period of sqrt(D) starts from a_1. So we look for a repeat of (m_n, d_n)\n    # where the first occurrence is n=1.\n    n = 0\n    while True:\n        n += 1\n        \n        # Calculate m_{n}, d_{n}\n        # Note: the a used here is a_{n-1}\n        m = partials_list[-1] * d - m\n        d = (D - m * m) // d\n        \n        m_history.append(m)\n        d_history.append(d)\n\n        state = (m, d)\n        if state in seen_states:\n            # Period detected\n            start_index = seen_states[state]\n            L = n - start_index\n            break\n        \n        seen_states[state] = n\n\n        #Calculate a_n\n        a_n = (m + a0) // d\n        partials_list.append(a_n)\n\n    # After finding the period, construct the list of first k partials.\n    final_partials = partials_list[:k]\n    \n    # Calculate M: maximum observed binary length of any m_n or d_n\n    # up to and including the step that detected the period.\n    max_val = 0\n    for val in m_history + d_history:\n        if val > max_val:\n            max_val = val\n    M = max_val.bit_length()\n    \n    ok = M = B\n\n    return [L, final_partials, M, B, ok]\n\nsolve()\n```", "id": "3086643"}]}