{"hands_on_practices": [{"introduction": "这项练习将挑战你应用关于两平方和的基本定理。通过分析素因子（特别是形如 $4k+3$ 的素数）如何决定一个数能否被写成两个平方的和，你将深化对高斯整数所提供的底层结构的理解。它还通过探索表示受限的情景，将这一概念与四平方和定理联系起来。[@problem_id:3089714]", "problem": "设 $n\\ge 1$ 是一个整数。对于将 $n$ 表示为两个平方和的情形，使用高斯整数环 $\\mathbb{Z}[i]$（形如 $a+bi$ 的复数，其中 $a,b\\in\\mathbb{Z}$）的结构、其唯一分解性质、以及范数 $N(a+bi)=a^2+b^2$ 和范数的乘法性质 $N(\\alpha\\beta)=N(\\alpha)N(\\beta)$。对于表示为四个平方和的情形，使用 Lagrange 四平方和定理这一事实，即每个正整数都是四个平方数之和。\n\n分析在 $n$ 的素因数分解中，素数 $q\\equiv 3\\pmod{4}$ 的指数的奇偶性如何决定了哪些表示存在以及何时必须出现零坐标。判断下列哪些陈述是正确的（选择所有适用项）：\n\nA. 整数 $n$ 可以表示为 $x^2+y^2$（其中 $x,y\\in\\mathbb{Z}$）的充要条件是，在 $n$ 的素因数分解中，每个形如 $q\\equiv 3\\pmod{4}$ 的素数都以偶数次幂出现。\n\nB. 在 $n=x^2+y^2$（其中 $x,y\\in\\mathbb{Z}$）的任何表示中，如果一个形如 $q\\equiv 3\\pmod{4}$ 的素数整除 $n$，那么 $q$ 也整除 $x$ 和 $y$。\n\nC. 如果某个形如 $q\\equiv 3\\pmod{4}$ 的素数在 $n$ 的分解中具有奇数次幂，那么在 $n=u_1^2+u_2^2+u_3^2+u_4^2$（其中 $u_i\\in\\mathbb{Z}$）的每个表示中，至少有三个 $u_i$ 是非零的。\n\nD. 如果在 $n$ 中每个形如 $q\\equiv 3\\pmod{4}$ 的素因数都以偶数次幂出现，并且至少有一个这样的素数整除 $n$，那么 $n=u_1^2+u_2^2+u_3^2+u_4^2$ 的任何表示都必须有一个零坐标。", "solution": "该问题要求基于整数 $n \\ge 1$ 的素因数分解，分析其作为两个和四个平方和的表示。我们将验证问题陈述，然后继续评估四个给定的陈述（A、B、C、D）。\n\n**问题验证**\n\n*   **第1步：提取已知条件**\n    *   $n \\ge 1$ 是一个整数。\n    *   对于两个平方和，利用高斯整数环 $\\mathbb{Z}[i] = \\{a+bi \\mid a,b \\in \\mathbb{Z}\\}$、其唯一分解性质、范数 $N(a+bi) = a^2+b^2$ 和范数的乘法性质 $N(\\alpha\\beta) = N(\\alpha)N(\\beta)$。\n    *   对于四个平方和，给出了 Lagrange 四平方和定理：每个正整数都是四个平方数之和。\n    *   分析的核心是 $n$ 的素因数分解中，形如 $q \\equiv 3 \\pmod 4$ 的素数的指数的奇偶性所起的作用。\n\n*   **第2步：使用已知条件进行验证**\n    *   **科学依据：** 该问题完全基于数论中已建立的定理，即费马平方和定理（由 $\\mathbb{Z}[i]$ 的算术性质推导）和 Lagrange 四平方和定理。$\\mathbb{Z}[i]$ 的性质是标准的。该问题在数学上是合理的。\n    *   **良定的：** 该问题要求评估四个不同的、精确的数学陈述。每个陈述都有一个确定的真值（真或假），可以通过逻辑证明或反例来确定。\n    *   **客观性：** 语言是形式化且明确的。像 $q \\equiv 3 \\pmod 4$ 这样的标准在数学上是精确的。\n    *   **完整性与一致性：** 问题为解决这些陈述提供了必要的理论框架（$\\mathbb{Z}[i]$ 用于两个平方和，Lagrange 定理用于四个平方和）。没有矛盾之处。\n\n*   **第3步：结论与行动**\n    *   问题陈述是有效的。我们将对每个陈述进行详细分析。\n\n**陈述分析**\n\n**陈述A：整数 $n$ 可以表示为 $x^2+y^2$（其中 $x,y\\in\\mathbb{Z}$）的充要条件是，在 $n$ 的素因数分解中，每个形如 $q\\equiv 3\\pmod{4}$ 的素数都以偶数次幂出现。**\n\n这是费马平方和定理的一个陈述。我们按照指示使用高斯整数 $\\mathbb{Z}[i]$ 的性质。\n\n整数 $x,y$ 的一个表示 $n=x^2+y^2$ 等价于陈述 $n$ 是某个高斯整数 $\\alpha = x+iy \\in \\mathbb{Z}[i]$ 的范数，即 $n = N(\\alpha)$。\n\n有理素数 $p \\in \\mathbb{Z}$ 在唯一分解整环 $\\mathbb{Z}[i]$ 中的素因数分解如下：\n1.  如果 $p=2$，那么 $2 = (1+i)(1-i) = -i(1+i)^2$。$1+i$ 是 $\\mathbb{Z}[i]$ 中的一个素数，其范数为 $N(1+i)=2$。\n2.  如果 $p \\equiv 1 \\pmod 4$，那么 $p$ 可以写成 $\\mathbb{Z}$ 中的两个平方和，所以 $p=a^2+b^2 = (a+bi)(a-bi)$。这里，$p$ 在 $\\mathbb{Z}[i]$ 中分裂成两个不同（在相伴意义下）的素因子。\n3.  如果 $p \\equiv 3 \\pmod 4$，那么 $p$ 不能写成两个平方和。它在 $\\mathbb{Z}[i]$ 中保持为素数（它是一个惰性素数）。$N(p) = p^2$。\n\n让我们来证明这个“充要条件”陈述。\n\n($\\Rightarrow$) “仅当”部分：假设 $n = x^2+y^2 = N(x+iy)$。设 $n$ 在 $\\mathbb{Z}$ 中的素因数分解为 $n = 2^k \\prod p_i^{a_i} \\prod q_j^{b_j}$，其中 $p_i \\equiv 1 \\pmod 4$ 且 $q_j \\equiv 3 \\pmod 4$。\n设 $q$ 是 $n$ 的一个素因子且 $q \\equiv 3 \\pmod 4$。由于 $n = (x+iy)(x-iy)$，$q$ 必须整除乘积 $(x+iy)(x-iy)$。因为 $q$ 在 $\\mathbb{Z}[i]$ 中是素数，所以 $q$ 必须整除 $x+iy$ 或 $x-iy$。如果 $q$ 整除 $x+iy$，那么取复共轭，$\\bar{q}=q$ 必须整除 $\\overline{x+iy} = x-iy$。因此，$q$ 整除两个因子。\n设 $q^e$ 是整除 $x+iy$ 的 $q$ 的最高次幂。那么 $q^e$ 也是整除 $x-iy$ 的 $q$ 的最高次幂。因此，在 $n=(x+iy)(x-iy)$ 于 $\\mathbb{Z}[i]$ 中的素因数分解中，$q$ 的总次幂是 $q^{2e}$。这对应于 $n$ 在 $\\mathbb{Z}$ 中分解的一个因子 $q^{2e}$。因此，在 $n$ 的分解中，任何形如 $q_j \\equiv 3 \\pmod 4$ 的素数的指数 $b_j$ 必须是偶数。\n\n($\\Leftarrow$) “如果”部分：假设在 $n$ 的素因数分解中，每个形如 $q \\equiv 3 \\pmod 4$ 的素数都有偶数指数，比如 $2e_j$。所以 $n = 2^k \\prod p_i^{a_i} \\prod q_j^{2e_j}$。\n我们想证明 $n$ 是某个高斯整数的范数。\n- $N( (1+i)^k ) = (N(1+i))^k = 2^k$。\n- 对于每个 $p_i \\equiv 1 \\pmod 4$，$p_i$ 是一个范数，例如，$p_i = N(\\pi_i)$ 对于某个素数 $\\pi_i \\in \\mathbb{Z}[i]$。因此 $p_i^{a_i} = N(\\pi_i)^{a_i} = N(\\pi_i^{a_i})$。\n- 对于每个 $q_j \\equiv 3 \\pmod 4$，$q_j^{2e_j} = (q_j^{e_j})^2 + 0^2 = N(q_j^{e_j})$。\n因为范数是乘性的，$n$ 是一系列高斯整数乘积的范数：\n$n = N((1+i)^k) \\cdot \\prod N(\\pi_i^{a_i}) \\cdot \\prod N(q_j^{e_j}) = N( (1+i)^k \\prod \\pi_i^{a_i} \\prod q_j^{e_j} )$。\n令 $\\alpha = (1+i)^k \\prod \\pi_i^{a_i} \\prod q_j^{e_j}$，它是某个高斯整数 $X+iY$，我们有 $n=N(\\alpha)=X^2+Y^2$。\n\n该陈述是该定理的正确表述。\n结论：**正确**。\n\n**陈述B：在 $n=x^2+y^2$（其中 $x,y\\in\\mathbb{Z}$）的任何表示中，如果一个形如 $q\\equiv 3\\pmod{4}$ 的素数整除 $n$，那么 $q$ 也整除 $x$ 和 $y$。**\n\n设 $q$ 是一个素数且 $q \\equiv 3 \\pmod 4$。假设 $q$ 整除 $n=x^2+y^2$。这意味着 $x^2+y^2 \\equiv 0 \\pmod q$，可以写成 $x^2 \\equiv -y^2 \\pmod q$。\n为寻求矛盾，我们假设 $q$ 不整除 $y$。由于 $q$ 是素数，$y$ 存在模 $q$ 的乘法逆元，记作 $y^{-1}$。我们可以用 $(y^{-1})^2$ 乘以该同余式：\n$(xy^{-1})^2 \\equiv -1 \\pmod q$。\n这意味着 $-1$ 是模 $q$ 的二次剩余。\n然而，根据二次互反律的第一补充定律，勒让德符号 $(\\frac{-1}{q})$ 由 $(-1)^{(q-1)/2}$ 给出。\n因为 $q \\equiv 3 \\pmod 4$，我们可以写成 $q=4k+3$ 对于某个整数 $k \\ge 0$。那么，指数是 $(q-1)/2 = (4k+2)/2 = 2k+1$，这是一个奇数。\n因此，$(\\frac{-1}{q}) = (-1)^{2k+1} = -1$。\n这意味着 $-1$ 是模 $q$ 的二次非剩余，这与我们发现的 $(xy^{-1})^2 \\equiv -1 \\pmod q$ 相矛盾。\n这个矛盾源于假设 $q$ 不整除 $y$。因此，我们的假设必须是错误的，所以 $q$ 必须整除 $y$。\n因为 $q|y$，我们有 $y \\equiv 0 \\pmod q$。从 $x^2+y^2 \\equiv 0 \\pmod q$，我们得到 $x^2+0^2 \\equiv 0 \\pmod q$，所以 $x^2 \\equiv 0 \\pmod q$。因为 $q$ 是素数，这意味着 $x \\equiv 0 \\pmod q$，即 $q$ 整除 $x$。\n因此，如果 $q|(x^2+y^2)$，那么 $q|x$ 且 $q|y$。\n\n结论：**正确**。\n\n**陈述C：如果某个形如 $q\\equiv 3\\pmod{4}$ 的素数在 $n$ 的分解中具有奇数次幂，那么在 $n=u_1^2+u_2^2+u_3^2+u_4^2$（其中 $u_i\\in\\mathbb{Z}$）的每个表示中，至少有三个 $u_i$ 是非零的。**\n\n陈述“至少有三个 $u_i$ 是非零的”等价于“零坐标的数量至多为一个”。让我们检查一下是否可能有两或三个零坐标。\n根据 Lagrange 定理，由于 $n \\ge 1$，一个表示 $n=u_1^2+u_2^2+u_3^2+u_4^2$ 总是存在的。\n\n情况1：三个零坐标。\n如果三个 $u_i$ 为零，那么 $n = u_1^2$ 对于某个整数 $u_1$。这意味着 $n$ 是一个完全平方数。如果 $n$ 是一个完全平方数，那么在其素因数分解 $n = \\prod p_i^{e_i}$ 中，所有指数 $e_i$ 都必须是偶数。这与给定的条件“某个形如 $q \\equiv 3 \\pmod 4$ 的素数在 $n$ 的分解中具有奇数次幂”相矛盾。因此，有三个零的表示是不可能的。\n\n情况2：两个零坐标。\n如果两个 $u_i$ 为零，那么 $n = u_1^2+u_2^2$ 对于某些整数 $u_1, u_2$。根据陈述A（费马定理），一个整数可以表示为两个平方和的充要条件是其素因数分解中每个形如 $q \\equiv 3 \\pmod 4$ 的素因数的指数都是偶数。这与给定的条件“某个形如 $q \\equiv 3 \\pmod 4$ 的素数在 $n$ 的分解中具有奇数次幂”相矛盾。因此，有二个零的表示是不可能的。\n\n由于具有两个或三个零坐标的表示是不可能的（四个零也是不可能的，因为 $n \\ge 1$），$n$ 作为四个平方和的任何表示都必须至多有一个零坐标。这意味着非零坐标的数量必须至少是 $4-1=3$。\n\n结论：**正确**。\n\n**陈述D：如果在 $n$ 中每个形如 $q\\equiv 3\\pmod{4}$ 的素因数都以偶数次幂出现，并且至少有一个这样的素数整除 $n$，那么 $n=u_1^2+u_2^2+u_3^2+u_4^2$ 的任何表示都必须有一个零坐标。**\n\n该陈述声称这样的整数 $n$ 不能表示为四个*非零*平方数之和。“任何”一词使这是一个非常强的断言。我们可以用一个反例来检验它。\n\n让我们找一个满足假设的整数 $n$。\n我们选择最小的素数 $q \\equiv 3 \\pmod 4$，即 $q=3$。假设要求其指数为偶数且为正，所以我们用 $3^2=9$。让我们通过乘以另一个素数来构造 $n$。\n设 $n = 3^2 \\cdot 2 = 18$。\n其素因数分解为 $n=2 \\cdot 3^2$。\n形如 $q \\equiv 3 \\pmod 4$ 的素因数集合是 $\\{3\\}$。$3$ 的指数是 $2$，是偶数。\n“至少有一个这样的素数整除 $n$”：正确，因为 $3|18$。\n所以，$n=18$ 满足假设。\n\n陈述 D 声称 $18 = u_1^2+u_2^2+u_3^2+u_4^2$ 的*任何*表示都必须有一个零坐标。让我们看看是否能找到一个有四个非零平方的表示。\n可能的平方数有 $1^2=1$, $2^2=4$, $3^2=9$, $4^2=16$。\n我们可以写出 $18 = 9+4+4+1$。\n这对应于表示 $18 = 3^2+2^2+2^2+1^2$。\n在这个表示中，($u_1, u_2, u_3, u_4$) 可以取为 ($3, 2, 2, 1$)。所有坐标都是非零的。\n这个表示直接反驳了“*任何*表示都必须有一个零坐标”的断言。\n\n让我们尝试另一个反例。设 $n = 3^2 \\cdot 5 = 45$。\n唯一的形如 $q \\equiv 3 \\pmod 4$ 的素因数是 $3$，指数为 $2$（偶数）。所以满足假设。\n陈述 D 声称 $45$ 作为四个平方和的任何表示都必须有一个零。\n让我们找一个表示：$45 = 36+9 = 6^2+3^2+0^2+0^2$。这个有零。\n让我们尝试找一个没有零的。\n$45 = 16+16+9+4 = 4^2+4^2+3^2+2^2$。\n这是 $45$ 的一个四个非零平方和的表示。这也构成一个反例。\n\n该陈述是错误的。虽然关于 $n$ 的条件保证了其作为两个平方和的表示存在（例如，$n = x^2+y^2+0^2+0^2$），但这并不禁止其作为四个非零平方和的表示。\n\n结论：**不正确**。", "answer": "$$\\boxed{ABC}$$", "id": "3089714"}, {"introduction": "虽然 Lagrange 定理保证了任何正整数都是四个平方的和，但其背后的原因深深植根于代数。本练习让你亲手实践 Hamilton 四元数的代数运算，正是这种结构支撑着 Euler 四平方和恒等式。通过手动计算两个四元数的乘积并验证其范数的乘法性质，你将亲自完成证明四平方和集合在乘法下封闭的核心计算。[@problem_id:3089687]", "problem": "设 $a$、$b$、$c$ 和 $d$ 为整数，并将四元组 $\\left(a,b,c,d\\right)$ 与哈密顿四元数 $q \\coloneqq a + b\\,\\mathbf{i} + c\\,\\mathbf{j} + d\\,\\mathbf{k}$ 等同起来，其中 $\\mathbf{i}$、$\\mathbf{j}$ 和 $\\mathbf{k}$ 满足 $\\mathbf{i}^2=\\mathbf{j}^2=\\mathbf{k}^2=-1$ 和 $\\mathbf{i}\\mathbf{j}=\\mathbf{k}$、$\\mathbf{j}\\mathbf{k}=\\mathbf{i}$、$\\mathbf{k}\\mathbf{i}=\\mathbf{j}$ 以及反交换律 $\\mathbf{j}\\mathbf{i}=-\\mathbf{k}$、$\\mathbf{k}\\mathbf{j}=-\\mathbf{i}$、$\\mathbf{i}\\mathbf{k}=-\\mathbf{j}$。$q$ 的平方范数定义为 $N(q)\\coloneqq a^2+b^2+c^2+d^2$。四平方和的复合源于将此类四元数相乘并比较其平方范数。\n\n仅使用这些定义，对以下小的整数四元组 $\\left(1,2,2,3\\right)$ 和 $\\left(1,1,2,2\\right)$ 执行以下操作：\n\n- 将它们解释为四元数 $q \\coloneqq 1 + 2\\,\\mathbf{i} + 2\\,\\mathbf{j} + 3\\,\\mathbf{k}$ 和 $r \\coloneqq 1 + 1\\,\\mathbf{i} + 2\\,\\mathbf{j} + 2\\,\\mathbf{k}$。\n- 仅使用上述乘法规则计算乘积 $s \\coloneqq q\\,r$，然后直接根据其分量计算 $N(s)$。\n- 分别计算 $N(q)$ 和 $N(r)$，形成乘积 $N(q)\\,N(r)$，并通过显式计算来数值验证它与您计算的 $N(s)$ 相匹配。\n\n报告 $N(s)$ 和 $N(q)\\,N(r)$ 的共同数值。您的最终答案必须是一个整数。不要四舍五入。", "solution": "我们从哈密顿四元数的定义、其乘法规则以及平方范数的定义 $N(a + b\\,\\mathbf{i} + c\\,\\mathbf{j} + d\\,\\mathbf{k}) \\coloneqq a^2 + b^2 + c^2 + d^2$ 开始。\n\n首先，将给定的四元组解释为四元数：\n- $q \\coloneqq 1 + 2\\,\\mathbf{i} + 2\\,\\mathbf{j} + 3\\,\\mathbf{k}$，\n- $r \\coloneqq 1 + 1\\,\\mathbf{i} + 2\\,\\mathbf{j} + 2\\,\\mathbf{k}$。\n\n根据分配律和乘法规则 $\\mathbf{i}^2=\\mathbf{j}^2=\\mathbf{k}^2=-1$、$\\mathbf{i}\\mathbf{j}=\\mathbf{k}$、$\\mathbf{j}\\mathbf{k}=\\mathbf{i}$、$\\mathbf{k}\\mathbf{i}=\\mathbf{j}$，以及逆序的反交换律，计算乘积 $s \\coloneqq q\\,r$：\n\n逐项展开 $q\\,r$：\n- 来自 $1 \\cdot r$：$1 + 1\\,\\mathbf{i} + 2\\,\\mathbf{j} + 2\\,\\mathbf{k}$。\n- 来自 $2\\,\\mathbf{i} \\cdot r$：$2\\,\\mathbf{i} + 2\\,\\mathbf{i}^2 + 4\\,\\mathbf{i}\\mathbf{j} + 4\\,\\mathbf{i}\\mathbf{k} = 2\\,\\mathbf{i} - 2 + 4\\,\\mathbf{k} - 4\\,\\mathbf{j}$，使用 $\\mathbf{i}^2=-1$、$\\mathbf{i}\\mathbf{j}=\\mathbf{k}$、$\\mathbf{i}\\mathbf{k}=-\\mathbf{j}$。\n- 来自 $2\\,\\mathbf{j} \\cdot r$：$2\\,\\mathbf{j} + 2\\,\\mathbf{j}\\mathbf{i} + 4\\,\\mathbf{j}^2 + 4\\,\\mathbf{j}\\mathbf{k} = 2\\,\\mathbf{j} - 2\\,\\mathbf{k} - 4 + 4\\,\\mathbf{i}$，使用 $\\mathbf{j}\\mathbf{i}=-\\mathbf{k}$、$\\mathbf{j}^2=-1$、$\\mathbf{j}\\mathbf{k}=\\mathbf{i}$。\n- 来自 $3\\,\\mathbf{k} \\cdot r$：$3\\,\\mathbf{k} + 3\\,\\mathbf{k}\\mathbf{i} + 6\\,\\mathbf{k}\\mathbf{j} + 6\\,\\mathbf{k}^2 = 3\\,\\mathbf{k} + 3\\,\\mathbf{j} - 6\\,\\mathbf{i} - 6$，使用 $\\mathbf{k}\\mathbf{i}=\\mathbf{j}$、$\\mathbf{k}\\mathbf{j}=-\\mathbf{i}$、$\\mathbf{k}^2=-1$。\n\n现在，将标量部分、$\\mathbf{i}$ 部分、$\\mathbf{j}$ 部分和 $\\mathbf{k}$ 部分组合起来：\n\n- 标量部分：$1 + (-2) + (-4) + (-6) = -11$。\n- $\\mathbf{i}$ 部分：$1 + 2 + 4 + (-6) = 1$。\n- $\\mathbf{j}$ 部分：$2 + (-4) + 2 + 3 = 3$。\n- $\\mathbf{k}$ 部分：$2 + 4 + (-2) + 3 = 7$。\n\n因此，\n$$\ns \\coloneqq q\\,r = -11 + 1\\,\\mathbf{i} + 3\\,\\mathbf{j} + 7\\,\\mathbf{k}.\n$$\n\n计算其平方范数：\n$$\nN(s) = (-11)^2 + 1^2 + 3^2 + 7^2 = 121 + 1 + 9 + 49 = 180.\n$$\n\n现在分别计算 $N(q)$ 和 $N(r)$：\n- $N(q) = 1^2 + 2^2 + 2^2 + 3^2 = 1 + 4 + 4 + 9 = 18$。\n- $N(r) = 1^2 + 1^2 + 2^2 + 2^2 = 1 + 1 + 4 + 4 = 10$。\n\n它们的乘积是\n$$\nN(q)\\,N(r) = 18 \\cdot 10 = 180.\n$$\n\n我们已经通过定义的直接计算，对这些特定的元组进行了数值验证，$N(s)$ 等于 $N(q)\\,N(r)$，其共同值为 $180$。因此，所求的值是 $180$。", "answer": "$$\\boxed{180}$$", "id": "3089687"}, {"introduction": "知道一个表示存在是一回事，而找到它则是另一回事。这个编程挑战要求你实现 Cornacchia 算法，这是一种优美而高效的方法，用于寻找素数 $p \\equiv 1 \\pmod 4$ 的两平方和表示。这项实践综合了多个概念，从二次剩余和 Tonelli-Shanks 算法到欧几里得算法，将抽象的数论转化为一个具体可行的程序。[@problem_id:3089708]", "problem": "实现一个完整的程序，对每个给定的素数输入 $p$，尝试使用 Cornacchia 算法寻找非负整数 $a$ 和 $b$，使得 $a^2 + b^2 = p$。您的实现必须基于数论的第一性原理：使用模素数的二次剩余概念、勒让德符号的欧拉判别法以及用于计算模素数平方根的 Tonelli–Shanks 算法。您可以使用的数学基础包括以下经过充分检验的事实和核心定义：\n- 对于奇素数 $p$，根据欧拉判别法，勒让德符号 $\\left(\\frac{n}{p}\\right)$ 等于 $n^{\\frac{p-1}{2}} \\bmod p \\in \\{1,p-1\\}$，这表明 $n$ 是否是模 $p$ 的二次剩余。\n- 对于满足 $p \\equiv 1 \\pmod{4}$ 的奇素数 $p$，整数 $-1$ 是模 $p$ 的二次剩余。\n- Tonelli–Shanks 算法可以确定性地计算出模奇素数 $p$ 的二次剩余的一个平方根。\n- Cornacchia 算法，在 $D = 1$ 的特殊情况下，使用任意满足 $r^2 \\equiv -1 \\pmod p$ 的 $r$ 和欧几里得算法，生成一个满足 $x^2 \\le p$ 的候选值 $x$，然后检查 $p - x^2$ 是否为完全平方数。\n\n您的任务：\n- 为特定丢番图方程 $a^2 + b^2 = p$（其中 $p$ 为素数）实现 Cornacchia 算法。\n- 当 $p = 2$ 时，返回平凡表示 $1^2 + 1^2 = 2$。\n- 当 $p \\equiv 3 \\pmod{4}$ 时，不存在非平凡表示，您的程序必须不返回任何数对。\n- 当 $p \\equiv 1 \\pmod{4}$ 时，使用 Tonelli–Shanks 算法计算 $-1 \\bmod p$ 的一个平方根，然后执行 Cornacchia 的下降过程以获得候选数对。\n- 您的程序必须验证其输出的数对 $(a,b)$ 满足 $a^2 + b^2 = p$。如果未找到有效数对，则输出不存在表示。\n\n本挑战的输入规范：\n- 无外部输入。您的程序必须在下面固定的测试集上自行运行。\n\n测试集：\n- 待测试的素数：$[2, 5, 13, 29, 37, 97, 101, 109, 149, 3, 7, 11, 999983, 104729]$。\n\n输出规范：\n- 对于测试集中的每个 $p$，产生以下任一结果：\n  - 一个包含两个非负整数的列表 $[a,b]$，按 $a \\ge b \\ge 0$ 排序，且满足 $a^2 + b^2 = p$，或者\n  - 如果不存在这样的表示，则返回空列表 $[]$。\n- 将所有测试用例的结果汇总到单行输出中，该行包含一个由各测试用例输出组成的逗号分隔列表，并用方括号括起来。例如，输出可能看起来像 $[[a_1,b_1],[],[a_3,b_3],\\dots]$，不含空格。\n\n您的实现必须是自包含的，仅使用标准库（以及允许的库），并且不得从输入读取数据，也不得在要求的单行输出之外写入任何额外文本。所有整数和表达式都是无单位的纯数；不涉及物理单位或角度。最终输出是如上所述的整数列表的列表。", "solution": "将素数 $p$ 表示为两个平方数之和的问题，即寻找非负整数 $a$ 和 $b$ 使得 $a^2 + b^2 = p$，是数论中的一个经典问题。这种表示存在的条件由费马平方和定理给出，该定理指出，一个奇素数 $p$ 能表示为两个平方数之和的充分必要条件是 $p \\equiv 1 \\pmod{4}$。素数 $2$ 是一个特例，$2=1^2+1^2$。所述问题是适定且科学合理的，通过既有算法为求解提供了清晰的路径。我们将通过分析 $p$ 的各种情况，并在适当之处应用 Cornacchia 算法来求解。\n\n解法根据素数 $p$ 分为三种情况：\n\n1.  **情况一：$p=2$**：素数 $p=2$ 是唯一的偶素数。其表示是平凡的 $2 = 1^2 + 1^2$。整数对为 $(1, 1)$。\n\n2.  **情况二：$p \\equiv 3 \\pmod{4}$**：对于任意整数 $x$，其平方 $x^2$ 模 $4$ 只能同余于 $0$ 或 $1$。\n    - 如果 $x$ 是偶数，$x=2k$（对于某个整数 $k$）。那么 $x^2 = (2k)^2 = 4k^2 \\equiv 0 \\pmod{4}$。\n    - 如果 $x$ 是奇数，$x=2k+1$（对于某个整数 $k$）。那么 $x^2 = (2k+1)^2 = 4k^2+4k+1 \\equiv 1 \\pmod{4}$。\n    因此，两个平方数之和 $a^2+b^2$ 模 $4$ 只能同余于 $0+0=0$、$0+1=1$ 或 $1+1=2$。两个平方数之和永远不可能模 $4$ 同余于 $3$。因为给定的素数 $p$ 满足 $p \\equiv 3 \\pmod{4}$，所以不存在整数 $a, b$ 使得 $a^2+b^2=p$。\n\n3.  **情况三：$p \\equiv 1 \\pmod{4}$**：对于这种形式的素数，费马定理保证了存在唯一的（在不计顺序的情况下）两个非负平方数之和的表示。问题要求使用 Cornacchia 算法的构造性方法，我们现在详细说明该算法。\n\n**用于 $a^2 + b^2 = p$ 的 Cornacchia 算法**\n\n该算法基于费马定理的一个构造性证明。$p=a^2+b^2$ 的解对 $(a,b)$ 的存在性意味着 $a^2 \\equiv -b^2 \\pmod p$。假设 $b \\not\\equiv 0 \\pmod p$（这必然成立，否则 $p$ 将是一个完全平方数，而素数不可能是完全平方数），则 $b$ 存在模 $p$ 的乘法逆元。因此，我们可以写成 $(a \\cdot b^{-1})^2 \\equiv -1 \\pmod p$。这表明 $p$ 能表示为两个平方数之和的一个必要条件是 $-1$ 必须是模 $p$ 的二次剩余。Cornacchia 算法构造性地逆转了这一推理过程。\n\n**第一步：计算 $-1$ 模 $p$ 的一个平方根**\n\n对于满足 $p \\equiv 1 \\pmod{4}$ 的素数 $p$，我们必须首先找到一个整数 $r$ 满足 $r^2 \\equiv -1 \\pmod p$。这种根的存在性由勒让德符号的欧拉判别法保证：\n$$ \\left(\\frac{-1}{p}\\right) \\equiv (-1)^{\\frac{p-1}{2}} \\pmod p $$\n由于 $p \\equiv 1 \\pmod{4}$，我们可以写成 $p=4k+1$（对于某个整数 $k \\ge 1$）。那么指数为 $\\frac{p-1}{2} = \\frac{4k}{2} = 2k$，这是一个偶数。因此，$\\left(\\frac{-1}{p}\\right) = 1$，这证实了 $-1$ 是模 $p$ 的二次剩余。\n\n要计算 $r$，我们使用 **Tonelli-Shanks 算法**，这是一种用于寻找模素数平方根的通用方法。\n设 $n \\equiv -1 \\pmod p$。该算法流程如下：\n1.  将 $p-1$ 分解为 $p-1 = 2^S \\cdot Q$，其中 $Q$ 是奇数。\n2.  找到一个模 $p$ 的二次非剩余 $z$。这可以通过测试整数 $z=2, 3, \\dots$ 并检查 $\\left(\\frac{z}{p}\\right) = z^{(p-1)/2} \\equiv -1 \\pmod p$ 是否成立来完成。这样的 $z$ 保证存在且通常很小。\n3.  初始化主循环的变量：\n    -   $M \\leftarrow S$\n    -   $c \\leftarrow z^Q \\pmod p$\n    -   $t \\leftarrow n^Q \\pmod p$\n    -   $R \\leftarrow n^{(Q+1)/2} \\pmod p$\n4.  重复更新变量，直到 $t \\equiv 1 \\pmod p$。在每次迭代中：\n    -   如果 $t \\equiv 1 \\pmod p$，循环终止，$R$ 是 $n$ 的一个平方根。\n    -   找到最小的指数 $i \\in \\{1, 2, \\dots, M-1\\}$，使得 $t^{2^i} \\equiv 1 \\pmod p$。\n    -   计算一个因子 $b \\leftarrow c^{2^{M-i-1}} \\pmod p$。\n    -   更新变量：$M \\leftarrow i$, $c \\leftarrow b^2 \\pmod p$, $t \\leftarrow t \\cdot c \\pmod p$ 以及 $R \\leftarrow R \\cdot b \\pmod p$。\n设计算出的根为 $r_0$。如果 $r_0  p/2$，为方便起见，我们可以使用 $r = p - r_0$，尽管该算法对两个根都有效。\n\n**第二步：应用欧几里得算法（Cornacchia 下降法）**\n\n在获得满足 $r^2+1 \\equiv 0 \\pmod p$ 的根 $r$ 后，我们将标准欧几里得算法应用于数对 $(p, r)$。\n我们生成余数序列 $r_0=p, r_1=r, r_2 = r_0 \\pmod{r_1}, \\dots$。\n设序列由 $r_{k+1} = r_{k-1} \\pmod{r_k}$ 定义。我们持续此过程，直到找到第一个满足 $r_k  \\sqrt{p}$ 的余数 $r_k$。设此余数为 $x=r_k$。Thue 引理保证了这样的余数存在，并为 $x$ 是一个有效候选值提供了理论基础。\n\n**第三步：测试候选解**\n\n设 $x$ 是第二步中找到的候选整数。我们计算 $s = p - x^2$ 的值。如果 $s$ 是一个完全平方数，即 $s=y^2$（对于某个整数 $y0$），那么我们就找到了表示 $p = x^2+y^2$。我们可以通过计算 $s$ 的整数平方根 $y = \\lfloor\\sqrt{s}\\rfloor$ 并检查是否 $y^2 = s$ 来验证 $s$ 是否为完全平方数。如果是，则整数对为 $(x,y)$。然后对最终结果进行排序，使得 $a \\ge b$，因此我们设 $a = \\max(x,y)$ 和 $b = \\min(x,y)$。如果 $s$ 不是完全平方数，则 Cornacchia 算法失败。然而，对于素数 $p \\equiv 1 \\pmod 4$，理论保证该算法会成功。\n\n至此，完整的算法介绍完毕。实现将系统地将这些步骤应用于测试集中的每个素数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport math\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Main function to run the algorithm on the test suite and print the results.\n    \"\"\"\n    test_cases = [2, 5, 13, 29, 37, 97, 101, 109, 149, 3, 7, 11, 999983, 104729]\n\n    results = []\n    for p in test_cases:\n        pair = find_sum_two_squares(p)\n        results.append(pair)\n\n    # Format the final output string as specified.\n    # str(list) adds spaces, so we build the string representation manually.\n    formatted_results = []\n    for res in results:\n        if res:\n            formatted_results.append(f\"[{res[0]},{res[1]}]\")\n        else:\n            formatted_results.append(\"[]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef find_sum_two_squares(p: int) - list[int]:\n    \"\"\"\n    Finds a representation of a prime p as a sum of two squares.\n    \n    Args:\n        p: A prime number.\n    \n    Returns:\n        A list [a, b] with a = b = 0 such that a^2 + b^2 = p,\n        or an empty list if no such representation exists.\n    \"\"\"\n    if p == 2:\n        return [1, 1]\n    \n    if p % 4 == 3:\n        return []\n\n    # Case p % 4 == 1\n    # Step 1: Find a square root of -1 mod p using Tonelli-Shanks\n    r = tonelli_shanks(p - 1, p)\n    \n    # Cornacchia's algorithm\n    # Step 2: Use Euclidean algorithm to find a candidate x\n    # We can choose the smaller root of -1 mod p\n    r = min(r, p - r)\n    \n    p_sqrt = math.isqrt(p)\n    \n    a, b = p, r\n    while b  p_sqrt:\n        a, b = b, a % b\n    \n    x = b\n    \n    # Step 3: Check if p a_candidate^2 is a perfect square\n    s = p - x*x\n    if s  0:\n        y = math.isqrt(s)\n        if y*y == s:\n            result = sorted([x, y], reverse=True)\n            # Verification\n            if result[0]**2 + result[1]**2 == p:\n                return result\n\n    return []\n\ndef tonelli_shanks(n: int, p: int) - int:\n    \"\"\"\n    Tonelli-Shanks algorithm to find a square root of n modulo p.\n    Assumes p is an odd prime and n is a quadratic residue modulo p.\n    \n    Args:\n        n: An integer that is a quadratic residue modulo p.\n        p: An odd prime number.\n        \n    Returns:\n        An integer x such that x^2 % p == n.\n    \"\"\"\n    # Simple case for p % 4 == 3\n    if p % 4 == 3:\n        return pow(n, (p + 1) // 4, p)\n\n    # Decompose p-1 = 2^S * Q\n    Q = p - 1\n    S = 0\n    while Q % 2 == 0:\n        Q //= 2\n        S += 1\n\n    # Find a quadratic non-residue z\n    z = 2\n    while pow(z, (p - 1) // 2, p) == 1:\n        z += 1\n\n    # Initialize\n    M = S\n    c = pow(z, Q, p)\n    t = pow(n, Q, p)\n    R = pow(n, (Q + 1) // 2, p)\n\n    # Main loop\n    while t != 1:\n        if t == 0:\n            return 0\n        \n        i = 0\n        temp_t = t\n        while temp_t != 1:\n            temp_t = (temp_t * temp_t) % p\n            i += 1\n            if i == M: # Should not happen if n is a quadratic residue\n                return -1 \n        \n        power = M - i - 1\n        b = pow(c, 2**power, p)\n        \n        M = i\n        c = (b * b) % p\n        t = (t * c) % p\n        R = (R * b) % p\n        \n    return R\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "3089708"}]}