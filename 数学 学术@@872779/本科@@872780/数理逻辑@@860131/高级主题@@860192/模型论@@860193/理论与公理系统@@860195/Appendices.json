{"hands_on_practices": [{"introduction": "理论不仅仅是公理的集合，它包含了从这些公理出发可以推导出的所有命题。这个练习将帮助你将这一抽象概念具体化，从一个简单的公理集 $\\Gamma$ 出发，构建并刻画其完整的演绎闭包 $\\operatorname{Th}(\\Gamma)$ [@problem_id:3057851]。通过这个过程，你将亲身体验句法上的“可证明性”与语义上的“逻辑蕴涵”之间通过可靠性与完备性建立的深刻联系，并探索如何将逻辑公式分类为优雅的代数结构，即 Lindenbaum–Tarski 代数。", "problem": "令 $L$ 为经典命题逻辑的语言，其命题变量为 $\\{p,q\\}$，原始联结词为 $\\lnot$ 和 $\\to$（使用常规缩写 $p \\land q := \\lnot(p \\to \\lnot q)$，$p \\lor q := (\\lnot p) \\to q$，以及 $p \\leftrightarrow q := (p \\to q) \\land (q \\to p)$）。令 $\\vdash$ 表示在任何一个针对经典命题逻辑的可靠且完备的希尔伯特式演绎系统中的可推导性，该系统以肯定前件式为唯一的推理规则。一个 $L$-公式集 $T$ 被称为一个理论，如果它非空且在可推导性下闭合。\n\n1) 精确陈述一个理论 $T$ 在可推导性下闭合的含义，并定义一个 $L$-公式集 $\\Gamma$ 的演绎闭包 $\\operatorname{Th}(\\Gamma)$。\n\n2) 考虑集合 $\\Gamma = \\{\\,p \\leftrightarrow q\\,\\}$。仅使用基本定义和公认事实（特别是，给定系统对经典命题逻辑的可靠性和完备性），构建并刻画演绎闭包 $\\operatorname{Th}(\\Gamma)$，将其作为所有 $L$-公式集合的一个子集。\n\n3) 定义模 $\\Gamma$ 的可证等价性为 $\\varphi \\equiv_{\\Gamma} \\psi$ 当且仅当 $\\Gamma \\vdash \\varphi \\leftrightarrow \\psi$，并令 $\\mathcal{L}_{\\Gamma}$ 表示 $L$-公式在 $\\equiv_{\\Gamma}$ 关系下的等价类集合（即模 $\\Gamma$ 的 Lindenbaum–Tarski 代数 (LTA)）。确定 $\\mathcal{L}_{\\Gamma}$ 的确切基数 $N$。你的最终答案应为一个精确整数，无需四舍五入。", "solution": "该问题陈述经核实具有科学依据、问题明确且客观。它提出了一个关于理论和 Lindenbaum-Tarski 代数的数理逻辑标准练习。所有术语都在经典命题逻辑的标准框架内有正式定义。\n\n解答分为问题所要求的三部分。\n\n1) “在可推导性下闭合”和“演绎闭包”的定义。\n\n一个 $L$-公式集 $T$ 被称为一个理论，如果它非空且在可推导性下闭合。这意味着对于语言 $L$ 中的任何公式 $\\varphi$，如果 $\\varphi$ 可从公式集 $T$ 推导得出，那么 $\\varphi$ 必须是 $T$ 的一个元素。更形式化地说，$T$ 在可推导性下闭合，如果：\n$$ \\text{对于所有 } \\varphi, \\text{ 如果 } T \\vdash \\varphi, \\text{ 那么 } \\varphi \\in T $$\n这个定义意味着一个理论包含其自身所有的逻辑推论。\n\n一个 $L$-公式集 $\\Gamma$ 的演绎闭包，记作 $\\operatorname{Th}(\\Gamma)$，是所有可以使用给定演绎系统从 $\\Gamma$ 推导出的 $L$-公式的集合。形式上，它被定义为：\n$$ \\operatorname{Th}(\\Gamma) = \\{ \\varphi \\mid \\Gamma \\vdash \\varphi \\} $$\n根据这个定义，$\\operatorname{Th}(\\Gamma)$ 是包含 $\\Gamma$ 的最小理论。\n\n2) 对于 $\\Gamma = \\{p \\leftrightarrow q\\}$，$\\operatorname{Th}(\\Gamma)$ 的构建和刻画。\n\n我们已知该希尔伯特式演绎系统对于经典命题逻辑是可靠且完备的。完备性定理指出，一个公式 $\\varphi$ 可以从一个前提集 $\\Gamma$ 推导得出，当且仅当 $\\varphi$ 是 $\\Gamma$ 的一个语义后承。这可以写作：\n$$ \\Gamma \\vdash \\varphi \\iff \\Gamma \\models \\varphi $$\n使用这一定理，我们可以从语义上刻画演绎闭包 $\\operatorname{Th}(\\Gamma)$：\n$$ \\operatorname{Th}(\\Gamma) = \\{ \\varphi \\mid \\Gamma \\models \\varphi \\} $$\n关系 $\\Gamma \\models \\varphi$ 成立，当且仅当每一个满足 $\\Gamma$ 中所有公式的真值赋值也满足 $\\varphi$。这样的一个赋值被称为 $\\Gamma$ 的一个模型。\n\n在本问题中，$\\Gamma = \\{p \\leftrightarrow q\\}$。语言 $L$ 有两个命题变量 $p$ 和 $q$，这产生了 $2^2 = 4$ 种可能的真值赋值。一个赋值 $v$ 是 $\\Gamma$ 的模型，如果 $v(p \\leftrightarrow q) = \\text{真}$。这恰好在 $v(p) = v(q)$ 时发生。让我们列出四种可能的赋值 $v: \\{p, q\\} \\to \\{\\text{真}, \\text{假}\\}$：\n\\begin{itemize}\n    \\item $v_1$: $v_1(p) = \\text{真}$，$v_1(q) = \\text{真}$。此时，$v_1(p \\leftrightarrow q) = \\text{真}$。因此，$v_1$ 是 $\\Gamma$ 的一个模型。\n    \\item $v_2$: $v_2(p) = \\text{真}$，$v_2(q) = \\text{假}$。此时，$v_2(p \\leftrightarrow q) = \\text{假}$。\n    \\item $v_3$: $v_3(p) = \\text{假}$，$v_3(q) = \\text{真}$。此时，$v_3(p \\leftrightarrow q) = \\text{假}$。\n    \\item $v_4$: $v_4(p) = \\text{假}$，$v_4(q) = \\text{假}$。此时，$v_4(p \\leftrightarrow q) = \\text{真}$。因此，$v_4$ 是 $\\Gamma$ 的一个模型。\n\\end{itemize}\n$\\Gamma = \\{p \\leftrightarrow q\\}$ 的模型是赋值 $v_1$ 和 $v_4$。\n\n一个公式 $\\varphi$ 属于 $\\operatorname{Th}(\\Gamma)$ 当且仅当它在 $\\Gamma$ 的所有模型下都为真。因此，$\\varphi \\in \\operatorname{Th}(\\Gamma)$ 当且仅当 $v_1(\\varphi) = \\text{真}$ 且 $v_4(\\varphi) = \\text{真}$。\n\n这就给出了刻画：$\\operatorname{Th}(\\{p \\leftrightarrow q\\})$ 是语言 $L$（含变量 $p,q$）中所有在 $p$ 和 $q$ 具有相同真值时为真的公式的集合。\n\n3) Lindenbaum-Tarski 代数 $\\mathcal{L}_{\\Gamma}$ 的基数的确定。\n\n集合 $\\mathcal{L}_{\\Gamma}$ 是 $L$-公式在关系 $\\equiv_{\\Gamma}$ 下的等价类集合。该关系定义为：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff \\Gamma \\vdash \\varphi \\leftrightarrow \\psi $$\n再次使用完备性定理，这等价于：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff \\Gamma \\models \\varphi \\leftrightarrow \\psi $$\n条件 $\\Gamma \\models \\varphi \\leftrightarrow \\psi$ 意味着对于 $\\Gamma$ 的每一个模型 $v$，公式 $\\varphi \\leftrightarrow \\psi$ 必须为真。这等价于说，对于 $\\Gamma$ 的每一个模型 $v$，$v(\\varphi) = v(\\psi)$。\n\n从第 2 部分可知，$\\Gamma = \\{p \\leftrightarrow q\\}$ 的模型是 $v_1$ 和 $v_4$。因此，两个公式 $\\varphi$ 和 $\\psi$ 是模 $\\Gamma$ 等价的，当且仅当它们在这两个模型下具有相同的真值：\n$$ \\varphi \\equiv_{\\Gamma} \\psi \\iff (v_1(\\varphi) = v_1(\\psi) \\text{ 且 } v_4(\\varphi) = v_4(\\psi)) $$\n这意味着一个等价类 $[\\varphi]_{\\equiv_{\\Gamma}}$ 由真值对 $(v_1(\\varphi), v_4(\\varphi))$唯一确定。在一个给定的赋值下，一个公式的真值可以是真（$T$）或假（$F$）。因此，最多有 $2 \\times 2 = 4$ 种可能的真值对，从而最多有 $4$ 个不同的等价类。这些可能的行为是 $(T,T)$, $(T,F)$, $(F,T)$, 和 $(F,F)$。\n\n为了证明恰好有 4 个类，我们必须证明这四种行为中的每一种都至少可以由语言 $L$ 中的一个公式实现。\n\n\\begin{itemize}\n    \\item **行为 $(T,T)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=T$ 且 $v_4(\\varphi)=T$。任何重言式，例如 $\\varphi_1 = p \\to p$，都满足这个条件。它对于所有赋值的真值都是 $T$。所以，$[\\varphi_1]$ 对应于 $(T,T)$。集合 $\\operatorname{Th}(\\Gamma)$ 本身就是这个等价类，因为 $\\varphi \\in \\operatorname{Th}(\\Gamma)$ 意味着 $\\Gamma \\vdash \\varphi \\leftrightarrow (p \\to p)$。\n\n    \\item **行为 $(T,F)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=T$ 且 $v_4(\\varphi)=F$。让我们测试 $\\varphi_2 = p$。$v_1(p)=T$ 因为在 $v_1$ 中 $p$ 被赋值为真。$v_4(p)=F$ 因为在 $v_4$ 中 $p$ 被赋值为假。所以，公式 $p$ 实现了行为 $(T,F)$。公式 $q$ 也实现了这个行为，并且实际上 $p \\equiv_\\Gamma q$ 因为 $\\Gamma \\vdash p \\leftrightarrow q$。所以 $[\\varphi_2] = [p]_\\Gamma$ 对应于 $(T,F)$。\n\n    \\item **行为 $(F,T)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=F$ 且 $v_4(\\varphi)=T$。让我们测试 $\\varphi_3 = \\lnot p$。$v_1(\\lnot p) = \\lnot v_1(p) = \\lnot T = F$。$v_4(\\lnot p) = \\lnot v_4(p) = \\lnot F = T$。所以，公式 $\\lnot p$ 实现了行为 $(F,T)$。公式 $\\lnot q$ 同样如此，并且 $\\lnot p \\equiv_\\Gamma \\lnot q$。所以 $[\\varphi_3] = [\\lnot p]_\\Gamma$ 对应于 $(F,T)$。\n\n    \\item **行为 $(F,F)$**：我们需要一个公式 $\\varphi$ 使得 $v_1(\\varphi)=F$ 且 $v_4(\\varphi)=F$。任何矛盾式，例如 $\\varphi_4 = p \\land \\lnot p$，都满足这个条件。它对于所有赋值的真值都是 $F$。所以，$[\\varphi_4]$ 对应于 $(F,F)$。\n\\end{itemize}\n\n因为我们已经为 $\\Gamma$ 模型上的四种可能的真值对都找到了对应的公式，所以恰好有四个不同的等价类。\n\n因此，Lindenbaum-Tarski 代数 $\\mathcal{L}_{\\Gamma}$ 的基数 $N$ 是 $4$。", "answer": "$$\\boxed{4}$$", "id": "3057851"}, {"introduction": "从命题逻辑进入表达能力更强的一阶逻辑后，我们如何检验一个陈述是否是公理的逻辑推论？这个实践聚焦于模型构建这一核心技能，它将理论与具体数学结构联系起来 [@problem_id:3057860]。你将像一个逻辑侦探一样，通过构造一个特定的“世界”（即模型）来证明某些结论是必然的，同时构造一个“反例世界”（即反模型）来揭示另一些结论并非普遍成立，从而精确地划定一个公理系统的语义边界。", "problem": "考虑经典的具有标准塔尔斯基语义的一阶逻辑，其论域为非空集合。设语言包含两个一元谓词符号 $Q$ 和 $R$。令 $\\Gamma$ 为句子集合\n$$\n\\Gamma \\;=\\; \\left\\{ \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big),\\; \\exists x\\,Q(x) \\right\\}.\n$$\n定义句子 $\\varphi$ 和 $\\psi$ 如下\n$$\n\\varphi \\;=\\; \\exists x\\,R(x), \\qquad \\psi \\;=\\; \\forall x\\,R(x).\n$$\n你的任务是：\n- 仅使用满足和语义后承的定义，证明 $\\Gamma \\models \\varphi$。\n- 为说明一个语义后承不必加强为一个全称陈述，构造一个反模型（即一个结构）$\\mathcal{M}$，使得 $\\mathcal{M} \\models \\Gamma$ 但 $\\mathcal{M} \\not\\models \\psi$，从而证明 $\\Gamma \\not\\models \\psi$。\n- 在所有满足 $\\Gamma$ 但证伪 $\\psi$ 的反模型 $\\mathcal{M}$ 中，确定 $\\mathcal{M}$ 的论域的最小可能有限基数。将这个最小基数作为你的最终答案。你的最终答案应表示为一个不带单位的整数。无需四舍五入。", "solution": "该问题要求对一阶逻辑中的语义后承进行分析。给定一个句子集合 $\\Gamma \\;=\\; \\left\\{ \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big),\\; \\exists x\\,Q(x) \\right\\}$ 和另外两个句子 $\\varphi \\;=\\; \\exists x\\,R(x)$ 以及 $\\psi \\;=\\; \\forall x\\,R(x)$。任务是证明一个语义后承，通过构造反模型来反驳另一个，并找出这种反模型论域的最小基数。\n\n首先，我们证明 $\\Gamma \\models \\varphi$。\n根据定义，语义后承 $\\Gamma \\models \\varphi$ 成立，当且仅当对于每一个结构 $\\mathcal{M}$，如果 $\\mathcal{M} \\models \\Gamma$，那么 $\\mathcal{M} \\models \\varphi$。\n设 $\\mathcal{M}$ 是一个具有非空论域 $D$ 的任意结构。令 $Q^\\mathcal{M} \\subseteq D$ 和 $R^\\mathcal{M} \\subseteq D$ 分别为一元谓词符号 $Q$ 和 $R$ 在结构 $\\mathcal{M}$ 中的解释。\n假设 $\\mathcal{M} \\models \\Gamma$。这意味着 $\\mathcal{M}$ 满足 $\\Gamma$ 中的所有句子：\n$1$. $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$。根据塔尔斯基语义，这意味着对于每一个元素 $a \\in D$，陈述“$a \\in Q^\\mathcal{M}$ 蕴含 $a \\in R^\\mathcal{M}$”为真。这等价于集合论条件 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。\n$2$. $\\mathcal{M} \\models \\exists x\\,Q(x)$。在语义上，这意味着存在至少一个元素 $c \\in D$，使得 $c \\in Q^\\mathcal{M}$。因此，集合 $Q^\\mathcal{M}$ 必须是非空的，即 $Q^\\mathcal{M} \\neq \\emptyset$。\n我们的目标是证明 $\\mathcal{M} \\models \\varphi$，也就是 $\\mathcal{M} \\models \\exists x\\,R(x)$。此式成立，当且仅当存在某个元素 $d \\in D$，使得 $d \\in R^\\mathcal{M}$。换句话说，我们必须证明 $R^\\mathcal{M}$ 是非空的。\n从前提（2）可知，存在一个元素 $c \\in D$，使得 $c \\in Q^\\mathcal{M}$。\n从前提（1）可知，对于所有 $a \\in D$，蕴含式 $a \\in Q^\\mathcal{M} \\rightarrow a \\in R^\\mathcal{M}$ 均成立。特别地，它对元素 $c$ 也成立。\n因为 $c \\in Q^\\mathcal{M}$，通过逻辑推导（肯定前件式）可得 $c \\in R^\\mathcal{M}$。\n在 $R^\\mathcal{M}$ 中存在元素 $c$ 证明了 $R^\\mathcal{M}$ 是非空的。\n因此，$\\mathcal{M} \\models \\exists x\\,R(x)$，这意味着 $\\mathcal{M} \\models \\varphi$。\n由于我们选择的 $\\mathcal{M}$ 是 $\\Gamma$ 的一个任意模型，我们已经证明了 $\\Gamma$ 的任何模型也都是 $\\varphi$ 的模型。我们得出结论 $\\Gamma \\models \\varphi$。\n\n其次，我们将构造一个反模型来证明 $\\Gamma \\not\\models \\psi$。\n为了证明 $\\Gamma \\not\\models \\psi$，我们需要找到一个单一的结构 $\\mathcal{M}$，使得 $\\mathcal{M} \\models \\Gamma$ 并且 $\\mathcal{M} \\not\\models \\psi$。让我们指定这样一个具有论域 $D$ 和解释 $Q^\\mathcal{M}$、$R^\\mathcal{M}$ 的结构 $\\mathcal{M}$ 的属性：\n- $\\mathcal{M} \\models \\Gamma$：\n    - $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big) \\implies Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。\n    - $\\mathcal{M} \\models \\exists x\\,Q(x) \\implies Q^\\mathcal{M} \\neq \\emptyset$。\n- $\\mathcal{M} \\not\\models \\psi$：\n    - $\\mathcal{M} \\not\\models \\forall x\\,R(x)$。这意味着存在至少一个元素 $b \\in D$，使得 $b \\notin R^\\mathcal{M}$。这等价于 $R^\\mathcal{M}$ 是 $D$ 的一个真子集。\n\n让我们尝试用最小可能的论域来构造这样一个模型。一个大小为 $1$ 的论域是行不通的，因为如果 $D = \\{a\\}$，那么 $Q^\\mathcal{M} \\neq \\emptyset$ 要求 $Q^\\mathcal{M} = \\{a\\}$。然后 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$ 要求 $R^\\mathcal{M} = \\{a\\}$。但这意味着 $R^\\mathcal{M} = D$，这就蕴含了 $\\mathcal{M} \\models \\forall x\\,R(x)$，与要求 $\\mathcal{M} \\not\\models \\psi$ 相矛盾。\n让我们尝试一个大小为 $2$ 的论域。设论域为 $D = \\{c_1, c_2\\}$。\n我们定义结构 $\\mathcal{M}$ 如下：\n- 论域 $D = \\{c_1, c_2\\}$。\n- $Q$ 的解释：$Q^\\mathcal{M} = \\{c_1\\}$。\n- $R$ 的解释：$R^\\mathcal{M} = \\{c_1\\}$。\n\n现在，我们验证这个结构 $\\mathcal{M}$ 是一个反模型：\n- $\\mathcal{M} \\models \\Gamma$ 是否成立？\n    - 要检查 $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$，我们检查 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$ 是否成立。因为 $\\{c_1\\} \\subseteq \\{c_1\\}$，所以这是成立的。\n    - 要检查 $\\mathcal{M} \\models \\exists x\\,Q(x)$，我们检查 $Q^\\mathcal{M} \\neq \\emptyset$ 是否成立。因为 $Q^\\mathcal{M}=\\{c_1\\}$，它不是空的。所以这是成立的。\n    - 由于 $\\Gamma$ 中的两个句子都得到满足，所以 $\\mathcal{M} \\models \\Gamma$。\n- $\\mathcal{M} \\not\\models \\psi$ 是否成立？\n    - 要检查 $\\mathcal{M} \\not\\models \\forall x\\,R(x)$，我们必须在 $D$ 中找到一个不在 $R^\\mathcal{M}$ 中的元素。考虑元素 $c_2 \\in D$。$R^\\mathcal{M}$ 的解释是 $\\{c_1\\}$，而 $c_2 \\notin \\{c_1\\}$。因此，全称陈述 $\\forall x\\,R(x)$ 在 $\\mathcal{M}$ 中是假的。\n    - 因此，$\\mathcal{M} \\not\\models \\psi$。\n既然我们找到了一个结构 $\\mathcal{M}$，其中 $\\Gamma$ 为真而 $\\psi$ 为假，我们就成功地证明了 $\\Gamma \\not\\models \\psi$。\n\n第三，我们将确定这样一个反模型的论域的最小可能有限基数。\n设 $\\mathcal{M}$ 是任何一个具有有限论域 $D$ 的反模型，它满足 $\\Gamma$ 但证伪 $\\psi$。对于解释 $Q^\\mathcal{M}$ 和 $R^\\mathcal{M}$，必须满足以下条件：\n$1$. 从 $\\mathcal{M} \\models \\exists x\\,Q(x)$，我们知道 $Q^\\mathcal{M} \\neq \\emptyset$。这意味着存在至少一个元素，我们称之为 $a$，使得 $a \\in Q^\\mathcal{M}$。\n$2$. 从 $\\mathcal{M} \\models \\forall x\\,\\big(Q(x) \\rightarrow R(x)\\big)$，我们有 $Q^\\mathcal{M} \\subseteq R^\\mathcal{M}$。由于从第（1）点可知 $a \\in Q^\\mathcal{M}$，那么也必然有 $a \\in R^\\mathcal{M}$。\n$3$. 从 $\\mathcal{M} \\not\\models \\forall x\\,R(x)$，我们知道论域中存在某个元素不在 $R$ 的解释中。设这个元素为 $b$。所以，$b \\in D$ 且 $b \\notin R^\\mathcal{M}$。\n现在，比较元素 $a$ 和 $b$。我们有 $a \\in R^\\mathcal{M}$ 和 $b \\notin R^\\mathcal{M}$。这直接意味着 $a$ 和 $b$不可能是同一个元素，所以 $a \\neq b$。\n由于论域 $D$ 必须至少包含这两个不同的元素 $a$ 和 $b$，所以 $D$ 的基数必须至少为 $2$。所以 $|D| \\geq 2$。\n在本解答的第二部分，我们明确地构造了一个基数为 $2$ 的论域的反模型。这表明最小可能基数 $2$ 是可以实现的。\n因此，一个反模型的论域的最小可能有限基数是 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3057860"}, {"introduction": "形式系统的核心在于其句法——一套操作符号的规则。但是，这些操作能否由机器自动执行？这最后一个练习将逻辑学与计算理论联系起来 [@problem_id:3057862]。通过为符号、公式和证明过程本身分配唯一的编码（即 Gödel 数），你将把“证明”这一概念形式化为一个可计算的对象，并探索在一个公理系统中，“可被证明”这一性质的计算复杂度，最终理解递归可枚举理论的本质。", "problem": "设 $\\mathcal{L}_{\\to}$ 是仅含单个命题字母 $p$ 和二元联结词 $\\to$ 的命题语言。公式是完全加括号的。考虑由 $A \\to (B \\to A)$ 给出的希尔伯特公理模式 $\\mathrm{Ax}_{1}$，其中 $A$ 和 $B$ 遍历所有 $\\mathcal{L}_{\\to}$-公式。我们对字母表 $\\Sigma=\\{(,),\\to,p\\}$ 上的有限符号串使用以下哥德尔配数法。\n\n1. 分配符号编码：$c(()=1$, $c())=2$, $c(\\to)=3$, $c(p)=4$。\n2. 设 $\\pi_0=2,\\pi_1=3,\\pi_2=5,\\pi_3=7,\\ldots$ 是递增的素数序列。如果一个有限串的符号编码序列为 $(a_0,\\ldots,a_{n-1})$，则其哥德尔编码定义为\n$$\n\\langle a_0,\\ldots,a_{n-1}\\rangle \\;=\\; \\left(\\prod_{i=0}^{n-1} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_n.\n$$\n因此，末尾的因子 $\\pi_n$ 用于编码长度。\n\n你可以不加证明地使用以下基础事实和定义：原始递归函数类在复合和原始递归下是封闭的；$p$-进赋值 $\\nu_{p}(x)$ 是原始递归的；返回第 $i$ 个素数 $\\pi_i$ 的函数是原始递归的；以及在上述编码下对有限序列的基本操作（长度、第 $i$ 项、拼接）是原始递归的。\n\n任务 A. 显式地定义一个原始递归函数 $g\\colon \\mathbb{N}\\to\\mathbb{N}$，其值域恰好是 $\\mathcal{L}_{\\to}$-公式的哥德尔编码集合。你的 $g$ 必须通过对 $n$ 的原始递归来定义，并且只使用原始递归子程序。然后定义一个原始递归函数 $E\\colon \\mathbb{N}\\to\\mathbb{N}$，使得 $E(n)$ 是公理实例 $A \\to (B \\to A)$ 的哥德尔编码，其中 $A$ 是由 $g(\\nu_{2}(n))$ 编码的公式，$B$ 是由 $g(\\nu_{3}(n))$ 编码的公式。\n\n任务 B. 使用 $E$，定义一个原始递归二元关系 $\\mathrm{Proof}(s,\\varphi)$，该关系形式化了“$s$ 是一个有限希尔伯特式证明的哥德尔编码，其最后一行是哥德尔编码为 $\\varphi$ 的公式”，其中唯一的公理模式是由 $E$ 生成的 $\\mathrm{Ax}_{1}$ 实例，唯一的推理规则是肯定前件式 (modus ponens)。从第一性原理出发，证明集合 $\\mathrm{Th}=\\{\\varphi \\in \\mathbb{N} \\mid \\exists s\\, \\mathrm{Proof}(s,\\varphi)\\}$ 是递归可枚举的（递归可枚举 (r.e.) 指存在一个原始递归谓词 $R(s,\\varphi)$，使得 $\\varphi\\in \\mathrm{Th}$ 当且仅当 $\\exists s\\,R(s,\\varphi)$）。\n\n任务 C. 计算特定公理实例 $(p \\to (p \\to p))$ 的哥德尔数（在上述编码下）。你的最终答案必须是单一的精确表达式。不要进行数值化简；将其表示为带有指数的素数的有限乘积。不需要四舍五入。[@problem_id:150]", "solution": "该问题提出了一个三部分任务，涉及哥德尔配数、原始递归函数以及在一个简单命题逻辑中定理集的可递归枚举性。该问题陈述在数理逻辑领域内被确认为合理、自洽且适定的。\n\n### 任务 A：函数 $g$ 和 $E$ 的定义\n\n$\\mathcal{L}_{\\to}$-公式的集合是归纳定义的：\n1.  命题字母 $p$ 是一个公式。\n2.  如果 $A$ 和 $B$ 是公式，那么 $(A \\to B)$ 是一个公式。\n\n我们被要求定义一个原始递归(PR)函数 $g \\colon \\mathbb{N} \\to \\mathbb{N}$，其值域是所有这些公式的哥德尔编码的集合。该函数必须通过对 $n$ 的原始递归来定义。这表明需要一种通过从较简单的公式构建更复杂公式的枚举方法。\n\n设 $\\pi(i,j) = \\frac{1}{2}(i+j)(i+j+1)+j$ 是康托尔配对函数，它是从 $\\mathbb{N}^2$ 到 $\\mathbb{N}$ 的一个原始递归双射。设 $\\pi_1(n)$ 和 $\\pi_2(n)$ 是其原始递归反函数，使得 $\\pi(\\pi_1(n), \\pi_2(n)) = n$。\n\n首先，我们定义单个符号的哥德尔编码，它们是常数：\n$\\ulcorner(\\urcorner = \\langle c(() \\rangle = \\langle 1 \\rangle = \\pi_0^{1+1} \\cdot \\pi_1 = 2^2 \\cdot 3$。\n$\\ulcorner)\\urcorner = \\langle c()) \\rangle = \\langle 2 \\rangle = \\pi_0^{2+1} \\cdot \\pi_1 = 2^3 \\cdot 3$。\n$\\ulcorner\\to\\urcorner = \\langle c(\\to) \\rangle = \\langle 3 \\rangle = \\pi_0^{3+1} \\cdot \\pi_1 = 2^4 \\cdot 3$。\n$\\ulcorner p\\urcorner = \\langle c(p) \\rangle = \\langle 4 \\rangle = \\pi_0^{4+1} \\cdot \\pi_1 = 2^5 \\cdot 3$。\n\n我们还假设存在一个原始递归函数 $\\mathrm{concat}(s_1, \\dots, s_k)$，它接受几个字符串的哥德尔编码并返回它们拼接后字符串的哥德尔编码。这是原始递归函数理论中的一个标准结果。\n\n我们按如下方式定义函数 $g(n)$：\n- **基本情况：** $g(0) = \\ulcorner p \\urcorner = 2^5 \\cdot 3$。\n- **递归步骤：** 对于 $n  0$，设 $n-1 = \\pi(i,j)$，其中 $i=\\pi_1(n-1)$ 且 $j=\\pi_2(n-1)$。我们定义 $g(n)$ 为公式 $(A \\to B)$ 的哥德尔编码，其中 $A$ 是编码为 $g(i)$ 的公式，$B$ 是编码为 $g(j)$ 的公式。因此，\n$$\ng(n) = \\mathrm{concat}(\\ulcorner(\\urcorner, g(\\pi_1(n-1)), \\ulcorner\\to\\urcorner, g(\\pi_2(n-1)), \\ulcorner)\\urcorner) \\quad \\text{对于 } n0\n$$\n该定义确保了 $g$ 的值域恰好是 $\\mathcal{L}_{\\to}$-公式的哥德尔编码集合。基本情况提供了原子公式。递归步骤从任意两个先前生成的公式 $A$ 和 $B$ 生成所有可能的复合公式 $(A \\to B)$，因为 $\\pi$ 是一个双射，对于任何索引对 $(i,j)$，都存在一个唯一的 $n = \\pi(i,j)+1$ 来组合公式 $g(i)$ 和 $g(j)$。\n\n这个定义是行程值递归的一个实例，因为 $g(n)$ 依赖于 $g(i)$ 和 $g(j)$ 的值，其中 $i,j  n$（因为 $\\pi_1(k), \\pi_2(k) \\le k$）。已知行程值递归可以归约为原始递归。我们可以定义一个辅助函数 $\\bar{g}(n) = \\prod_{k=0}^{n-1} \\pi_k^{g(k)}$，它编码了序列 $(g(0), \\ldots, g(n-1))$。$\\bar{g}(n)$ 可以通过原始递归定义，然后 $g(n)$ 可以用 $\\bar{g}(n)$ 来定义。因此，$g(n)$ 是一个原始递归函数。\n\n接下来，我们定义原始递归函数 $E(n)$。$E(n)$ 是公理实例 $A \\to (B \\to A)$ 的哥德尔编码，其中 $A$ 是由 $g(\\nu_{2}(n))$ 编码的公式，$B$ 是由 $g(\\nu_{3}(n))$ 编码的公式。设 $\\varphi_A = g(\\nu_{2}(n))$ 和 $\\varphi_B = g(\\nu_{3}(n))$。\n首先，我们构造子公式 $(B \\to A)$ 的编码：\n$$\n\\varphi_{(B \\to A)} = \\mathrm{concat}(\\ulcorner(\\urcorner, \\varphi_B, \\ulcorner\\to\\urcorner, \\varphi_A, \\ulcorner)\\urcorner)\n$$\n然后，我们构造完整公理实例 $(A \\to (B \\to A))$ 的编码：\n$$\nE(n) = \\mathrm{concat}(\\ulcorner(\\urcorner, \\varphi_A, \\ulcorner\\to\\urcorner, \\varphi_{(B \\to A)}, \\ulcorner)\\urcorner)\n$$\n函数 $E(n)$ 是通过函数 $g$、$\\nu_2$、$\\nu_3$、$\\mathrm{concat}$ 和常数函数的复合来构建的。由于所有这些函数都是原始递归的，并且原始递归函数类在复合下是封闭的，所以 $E(n)$ 是一个原始递归函数。\n\n### 任务 B：关系 $\\mathrm{Proof}(s,\\varphi)$ 和 $\\mathrm{Th}$ 的递归可枚举性\n\n我们被要求定义一个原始递归二元关系 $\\mathrm{Proof}(s,\\varphi)$，该关系形式化了 $s$ 是对编码为 $\\varphi$ 的公式的证明的编码。一个证明是公式的有限序列，其中每个公式要么是一个公理，要么是通过肯定前件式 (Modus Ponens) 从两个在前的公式推导出来的。\n\n首先，让我们建立一种原始递归的方法来处理哥德尔数的序列。一个有限的数序列 $(\\varphi_0, \\varphi_1, \\ldots, \\varphi_k)$ 可以被编码为单个数字 $s$，例如 $s = \\prod_{i=0}^k \\pi_i^{\\varphi_i+1}$。从 $s$ 中，序列的长度 $k+1$ 及其元素 $\\varphi_i$ 可以通过原始递归函数检索。设 $\\mathrm{len}(s)$ 和 $\\mathrm{get}(s,i)$ 是这样的原始递归函数。\n\n关系 $\\mathrm{Proof}(s,\\varphi)$ 必须是原始递归的。这意味着检查一个公式是否是公理或肯定前件式 (Modus Ponens) 的结果必须是一个原始递归操作。\n\n1.  **公理检查**：一个编码为 $\\psi$ 的公式是一个公理，如果它在由 $E$ 生成的 $\\mathrm{Ax}_1$ 实例集合中。如在任务A中所述，$g$ 的值域是所有公式编码的集合。由于当 $n$ 遍历 $\\mathbb{N}$ 时，$\\nu_2(n)$ 和 $\\nu_3(n)$ 都遍历所有自然数，因此项 $g(\\nu_2(n))$ 和 $g(\\nu_3(n))$ 遍历所有可能的公式编码。因此，$E$ 的值域是所有语法上有效的模式 $A \\to (B \\to A)$ 实例的哥德尔编码集合。\n    因此，要检查编码为 $\\psi$ 的公式是否是公理，我们不需要检查 $\\psi \\in \\mathrm{range}(E)$。我们只需要检查由 $\\psi$ 表示的公式是否具有 $(A \\to (B \\to A))$ 的语法结构，其中 $A$ 和 $B$ 是合式公式。这个检查可以通过一个原始递归函数 $\\mathrm{IsAxiom}(\\psi)$ 来执行，该函数解析由 $\\psi$ 编码的字符串。解析涉及查找子串和检查括号平衡，这些都是基于算术哥德尔配数的原始递归操作。\n\n2.  **肯定前件式检查**：如果 $\\psi_j$ 的公式形式为 $(A \\to B)$，$\\psi_i$ 的公式为 $A$，而 $\\psi_k$ 的公式为 $B$，则公式 $\\psi_k$ 是由 $\\psi_i$ 和 $\\psi_j$（$i,j  k$）通过肯定前件式（MP）推导出来的。这个检查对应于验证是否 $\\psi_j = \\mathrm{concat}(\\ulcorner(\\urcorner, \\psi_i, \\ulcorner\\to\\urcorner, \\psi_k, \\ulcorner)\\urcorner)$。这是一个原始递归关系，我们将其表示为 $\\mathrm{IsMP}(\\psi_k, \\psi_i, \\psi_j)$。\n\n有了这些构建块，我们可以定义 $\\mathrm{Proof}(s,\\varphi)$：\n$\\mathrm{Proof}(s, \\varphi) \\iff$\n  (1) $\\mathrm{get}(s, \\mathrm{len}(s)-1) = \\varphi$\n  $\\land$\n  (2) $(\\forall i  \\mathrm{len}(s)) \\Big[ \\mathrm{IsAxiom}(\\mathrm{get}(s,i)) \\lor \\big( (\\exists j  i)(\\exists k  i) \\mathrm{IsMP}(\\mathrm{get}(s,i), \\mathrm{get}(s,k), \\mathrm{get}(s,j)) \\big) \\Big]$\n\n该定义使用了有界全称量词（$\\forall i  N$）和有界存在量词（$\\exists j  N$），以及原始递归谓词（$\\mathrm{get}$、$\\mathrm{len}$、$\\mathrm{IsAxiom}$、$\\mathrm{IsMP}$）的布尔组合。原始递归关系类在这些操作下是封闭的。因此，$\\mathrm{Proof}(s,\\varphi)$ 是一个原始递归二元关系。\n\n现在，我们证明定理集 $\\mathrm{Th} = \\{\\varphi \\in \\mathbb{N} \\mid \\exists s\\, \\mathrm{Proof}(s,\\varphi)\\}$ 是递归可枚举的（r.e.）。\n根据定义，一个集合 $X$ 是 r.e. 的，如果存在一个原始递归谓词 $R(s,x)$ 使得 $x \\in X \\iff \\exists s, R(s,x)$。\n对于集合 $\\mathrm{Th}$，我们刚刚构造了这样一个谓词，即 $\\mathrm{Proof}(s,\\varphi)$。\n因此，$\\varphi \\in \\mathrm{Th} \\iff \\exists s, \\mathrm{Proof}(s,\\varphi)$。\n由于 $\\mathrm{Proof}(s,\\varphi)$ 是一个原始递归关系，根据定义，集合 $\\mathrm{Th}$ 是递归可枚举的。\n\n### 任务 C：哥德尔数的计算\n\n我们需要计算公式 $(p \\to (p \\to p))$ 的哥德尔数。\n符号序列是：$(, p, \\to, (, p, \\to, p, ), )$。\n这个序列的长度是 $n=9$。\n符号编码是：$c(()=1$, $c())=2$, $c(\\to)=3$, $c(p)=4$。\n符号编码序列 $(a_0, a_1, \\ldots, a_8)$ 是：\n$a_0 = c(() = 1$\n$a_1 = c(p) = 4$\n$a_2 = c(\\to) = 3$\n$a_3 = c(() = 1$\n$a_4 = c(p) = 4$\n$a_5 = c(\\to) = 3$\n$a_6 = c(p) = 4$\n$a_7 = c()) = 2$\n$a_8 = c()) = 2$\n\n哥德尔编码由公式 $\\langle a_0,\\ldots,a_{n-1}\\rangle = \\left(\\prod_{i=0}^{n-1} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_n$ 给出，其中 $\\pi_i$ 是第 $i$ 个素数（$\\pi_0=2, \\pi_1=3, \\ldots$）。\n对于 $n=9$，公式变为：\n$$\n\\langle a_0,\\ldots,a_8\\rangle = \\left(\\prod_{i=0}^{8} \\pi_i^{\\,a_i+1}\\right)\\cdot \\pi_9\n$$\n我们列出所需的素数：$\\pi_0=2, \\pi_1=3, \\pi_2=5, \\pi_3=7, \\pi_4=11, \\pi_5=13, \\pi_6=17, \\pi_7=19, \\pi_8=23, \\pi_9=29$。\n\n现在我们计算指数 $a_i+1$：\n$a_0+1 = 1+1 = 2$\n$a_1+1 = 4+1 = 5$\n$a_2+1 = 3+1 = 4$\n$a_3+1 = 1+1 = 2$\n$a_4+1 = 4+1 = 5$\n$a_5+1 = 3+1 = 4$\n$a_6+1 = 4+1 = 5$\n$a_7+1 = 2+1 = 3$\n$a_8+1 = 2+1 = 3$\n\n乘积部分是：\n$\\pi_0^{a_0+1} \\cdot \\pi_1^{a_1+1} \\cdot \\pi_2^{a_2+1} \\cdot \\pi_3^{a_3+1} \\cdot \\pi_4^{a_4+1} \\cdot \\pi_5^{a_5+1} \\cdot \\pi_6^{a_6+1} \\cdot \\pi_7^{a_7+1} \\cdot \\pi_8^{a_8+1}$\n$= 2^{2} \\cdot 3^{5} \\cdot 5^{4} \\cdot 7^{2} \\cdot 11^{5} \\cdot 13^{4} \\cdot 17^{5} \\cdot 19^{3} \\cdot 23^{3}$\n\n最后，我们乘以长度编码因子 $\\pi_9=29$：\n哥德尔数 $= 2^2 \\cdot 3^5 \\cdot 5^4 \\cdot 7^2 \\cdot 11^5 \\cdot 13^4 \\cdot 17^5 \\cdot 19^3 \\cdot 23^3 \\cdot 29$。", "answer": "$$\\boxed{2^2 \\cdot 3^5 \\cdot 5^4 \\cdot 7^2 \\cdot 11^5 \\cdot 13^4 \\cdot 17^5 \\cdot 19^3 \\cdot 23^3 \\cdot 29}$$", "id": "3057862"}]}