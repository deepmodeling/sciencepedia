{"hands_on_practices": [{"introduction": "要真正掌握省略类型定理，关键在于理解它在何种情况下是必需的，而在何种情况下又是大材小用。本题旨在帮助你厘清这些界限。通过分析不同类型的可省略性，你将学会区分那些与理论不相容、因而任何模型都自然会省略的“平凡”情形，以及那些由非主类型所引发的、需要借助省略类型定理这一深刻工具才能处理的“非平凡”情形。[@problem_id:3057275]", "problem": "设 $\\mathcal{L}$ 是一个可数的一阶语言，且 $T$ 是一个相容的 $\\mathcal{L}$-理论。一个关于空集的（部分）型是含单个自由变元 $x$ 的 $\\mathcal{L}$-公式的集合 $p(x)$。对于一个模型 $\\mathcal{M} \\models T$ 和一个元素 $a \\in M$，如果对于每个 $\\varphi(x) \\in p(x)$ 都有 $\\mathcal{M} \\models \\varphi(a)$，我们就说 $a$ 在 $\\mathcal{M}$ 中实现了 $p(x)$。如果 $M$ 中没有元素实现 $p(x)$，则模型 $\\mathcal{M} \\models T$ 省略 $p(x)$。如果对于 $p(x)$ 的每个有限子集 $F$，集合 $T \\cup \\{\\exists x \\bigwedge_{\\varphi \\in F} \\varphi(x)\\}$ 都是相容的，则型 $p(x)$ 与 $T$ 相容；否则，$p(x)$ 与 $T$ 不相容。如果存在单个公式 $\\psi(x)$ 使得 $T \\cup \\{\\exists x \\psi(x)\\}$ 相容，并且对于每个 $\\varphi(x) \\in p(x)$ 都有 $T \\vdash \\forall x(\\psi(x) \\rightarrow \\varphi(x))$，则型 $p(x)$ 是**孤立的 (isolated)**。一个与 $T$ 相容的型如果不是孤立的，则称其为**非孤立的 (non-isolated)**。省略类型定理 (Omitting Types Theorem, OTT) 指出，一个型可以在理论 $T$ 的某个模型中被省略，当且仅当它是一个非孤立的型。\n\n考虑以下关于型的省略和实现的陈述：\n\nA. 如果 $p(x)$ 与 $T$ 不相容，那么 $T$ 的每个模型都省略 $p(x)$；这不需要使用省略类型定理 (OTT)。\n\nB. 如果 $q(x)$ 是非孤立型且与 $T$ 相容，那么在一般情况下，无需借助任何全局存在性原理（如紧致性定理 (Compactness Theorem) 或省略类型定理 (OTT)），就可以构造一个省略 $q(x)$ 的 $T$ 的模型。\n\nC. 假设 $\\mathcal{L}$ 和 $T$ 是可数的且 $T$ 是相容的。如果 $q(x)$ 是一个与 $T$ 相容的关于 $\\emptyset$ 的单个非孤立型，那么存在一个省略 $q(x)$ 的 $T$ 的可数模型；这是省略类型定理 (OTT) 的推论。\n\nD. 如果 $r(x)$ 是孤立的型且与 $T$ 相容，那么 $r(x)$ 在 $T$ 的每个模型中都被实现。\n\nE. 如果 $p(x)$ 与 $T$ 不相容，那么必须援引省略类型定理 (OTT) 来确保存在一个省略 $p(x)$ 的 $T$ 的模型。", "solution": "首先将对问题陈述的科学合理性、一致性和清晰性进行验证。\n\n**步骤1：提取已知条件**\n- $\\mathcal{L}$ 是一个可数的一阶语言。\n- $T$ 是一个相容的 $\\mathcal{L}$-理论。\n- 对“型”、“实现”、“省略”、“与 $T$ 相容”给出了标准定义。\n- 孤立型 (isolated type) 的定义：存在单个公式 $\\psi(x)$ 使得 $T \\cup \\{\\exists x \\psi(x)\\}$ 相容，并且对于每个 $\\varphi(x) \\in p(x)$ 都有 $T \\vdash \\forall x(\\psi(x) \\rightarrow \\varphi(x))$。\n- 非孤立型 (non-isolated type) 的定义：一个与 $T$ 相容的型，如果它不是孤立的。\n- 省略类型定理 (Omitting Types Theorem, OTT)：一个型可以在理论 $T$ 的某个模型中被省略，当且仅当它是一个非孤立的型。\n\n**步骤2：使用提取的已知条件进行验证**\n问题陈述现在设定在模型论的正确形式框架内，术语是标准的。\n- **科学依据：** 所提供的关于型、实现、省略、相容性、孤立型以及省略型定理的陈述都是模型论中标准和基础性的。它们在事实上和逻辑上都是合理的。\n- **良构性：** 该问题要求基于给定的定义和定理来评估几个命题。每个命题都是一个定义明确的数学陈述，可以在此框架内证明其真伪。\n- **客观性：** 语言是形式化的、精确的，并且没有任何主观或模棱两可的术语。\n- **完备性与相容性：** 问题提供了分析选项所需的所有必要定义。没有内部矛盾。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个在数理逻辑中表述良好的问题。我现在将开始分析每个陈述。\n\n***\n\n**陈述分析**\n\n**A. 如果 $p(x)$ 与 $T$ 不相容，那么 $T$ 的每个模型都省略 $p(x)$；这不需要使用省略类型定理 (OTT)。**\n\n设 $p(x)$ 是一个与 $T$ 不相容的型。根据所提供的定义，这意味着存在 $p(x)$ 的一个有限子集 $F = \\{\\varphi_1(x), \\varphi_2(x), \\dots, \\varphi_n(x)\\}$，使得语句集 $T \\cup \\{\\exists x \\bigwedge_{i=1}^n \\varphi_i(x)\\}$ 是不相容的。\n\n根据逻辑不相容性的定义，一个不相容的语句集没有模型。这意味着对于 $T$ 的任何模型 $\\mathcal{M}$，都必然有 $\\mathcal{M} \\not\\models \\exists x \\bigwedge_{i=1}^n \\varphi_i(x)$。\n这在逻辑上等价于 $\\mathcal{M} \\models \\neg \\exists x \\bigwedge_{i=1}^n \\varphi_i(x)$，而这又等价于 $\\mathcal{M} \\models \\forall x \\neg \\bigwedge_{i=1}^n \\varphi_i(x)$。\n\n现在，为寻求矛盾，假设一个模型 $\\mathcal{M} \\models T$ *不*省略 $p(x)$。这意味着存在一个元素 $a \\in M$ 实现了 $p(x)$。根据实现的定义，对于每个公式 $\\varphi(x) \\in p(x)$ 都有 $\\mathcal{M} \\models \\varphi(a)$。\n特别是，对于有限子集 $F$，这意味着对于所有的 $i \\in \\{1, \\dots, n\\}$ 都有 $\\mathcal{M} \\models \\varphi_i(a)$。因此，$\\mathcal{M} \\models \\bigwedge_{i=1}^n \\varphi_i(a)$。\n\n这与我们之前的结论 $\\mathcal{M} \\models \\forall x \\neg \\bigwedge_{i=1}^n \\varphi_i(x)$ 相矛盾，该结论要求对于论域中的任何元素（包括 $a$），公式 $\\neg \\bigwedge_{i=1}^n \\varphi_i(x)$ 都必须为真。\n因此，我们最初的假设必定是错误的。没有元素 $a \\in M$ 能够实现 $p(x)$。这意味着 $T$ 的每个模型 $\\mathcal{M}$ 都省略了型 $p(x)$。\n\n这整个论证仅依赖于相容性、满足性和基本逻辑等价的定义。它没有使用省略类型定理 (Omitting Types Theorem)。\n\n**结论：** 该陈述是 **正确的**。\n\n**B. 如果 $q(x)$ 是非孤立型且与 $T$ 相容，那么在一般情况下，无需借助任何全局存在性原理（如紧致性定理 (Compactness Theorem) 或省略类型定理 (OTT)），就可以构造一个省略 $q(x)$ 的 $T$ 的模型。**\n\n这个陈述声称，构造一个省略非孤立型的模型是直接的，并且不需要强大的工具。这从根本上是错误的。由省略类型定理 (Omitting Types Theorem) 所解决的挑战恰恰是保证省略一个非孤立型是一项非平凡的任务，其证明本身就是一个“全局存在性原理”。\n\nOTT 的证明涉及一个复杂的 Henkin 式构造。这种方法通过向语言中添加可数多个新常数符号，并在扩展语言中系统地构造一个完备理论来建立模型，该理论明确地省略了给定的型。在构造的每个阶段，都必须确保向理论中添加公式能保持相容性。这个过程远非简单或初等的构造。没有这样的机制，就无法通过一般方法来确保为建立 $T$ 的模型而引入的元素不会意外地实现非孤立型 $q(x)$。因此，借助像 OTT 这样的原理或其证明方法是必不可少的。\n\n**结论：** 该陈述是 **不正确的**。\n\n**C. 假设 $\\mathcal{L}$ 和 $T$ 是可数的且 $T$ 是相容的。如果 $q(x)$ 是一个与 $T$ 相容的关于 $\\emptyset$ 的单个非孤立型，那么存在一个省略 $q(x)$ 的 $T$ 的可数模型；这是省略类型定理 (OTT) 的推论。**\n\n让我们检查一下问题中所述的省略类型定理 (Omitting Types Theorem) 的条件。该定理指出，一个型可以被省略当且仅当它是非孤立的。\n陈述假设 $q(x)$ 是一个非孤立型。根据 OTT，这直接意味着存在一个省略 $q(x)$ 的 $T$ 的模型。经典 OTT 证明（如 Henkin 构造）在可数语言和理论的条件下，会构造出一个可数模型。\n因此，该陈述是省略类型定理的直接推论。$q(x)$ 与 $T$ 相容这一事实使得问题并非平凡；如果它不相容，如 A 所示，结论将是平凡成立的。\n\n该陈述是省略类型定理的直接且正确的应用。\n\n**结论：** 该陈述是 **正确的**。\n\n**D. 如果 $r(x)$ 是孤立的型且与 $T$ 相容，那么 $r(x)$ 在 $T$ 的每个模型中都被实现。**\n\n设 $r(x)$ 是一个孤立的型。根据定义，存在一个公式 $\\psi(x)$（孤立公式），使得 $T \\cup \\{\\exists x \\psi(x)\\}$ 相容，并且对于所有 $\\varphi(x) \\in r(x)$，都有 $T \\vdash \\forall x(\\psi(x) \\rightarrow \\varphi(x))$。\n$T \\cup \\{\\exists x \\psi(x)\\}$ 相容，根据哥德尔完备性定理，意味着存在一个 $T$ 的模型，在其中 $\\exists x \\, \\psi(x)$ 为真。任何这样的模型都会实现型 $r(x)$，因为任何满足 $\\psi(x)$ 的元素都会满足 $r(x)$ 中的所有公式。\n\n然而，该陈述声称 $r(x)$ 在 $T$ 的*每个*模型中都被实现。这个更强的论断等价于断言 $T \\vdash \\exists x \\, \\psi(x)$。但孤立的定义只要求 $T \\cup \\{\\exists x \\, \\psi(x)\\}$ 相容，这并不意味着 $T \\vdash \\exists x \\, \\psi(x)$，除非 $T$ 是完备的。\n\n考虑一个反例。设 $\\mathcal{L}$ 是域的语言 $\\{+, \\cdot, -, 0, 1\\}$。设 $T$ 是域理论（这是一套公理，但不是完备理论）。考虑型 $r(x) = \\{x^2 + 1 = 0\\}$。这个型是孤立的，由公式 $\\psi(x) \\equiv (x^2 + 1 = 0)$ 孤立。该型与 $T$ 相容，因为理论 $T \\cup \\{\\exists x (x^2 + 1 = 0)\\}$ 是相容的；例如，复数域 $\\mathbb{C}$ 就是一个模型。\n然而，并非 $T$ 的每个模型都实现这个型。实数域 $\\mathbb{R}$ 是域理论的一个模型，但不存在元素 $a \\in \\mathbb{R}$ 使得 $a^2 + 1 = 0$。因此，$\\mathbb{R}$ 是一个省略了型 $r(x)$ 的 $T$ 的模型。\n\n**结论：** 该陈述是 **不正确的**。\n\n**E. 如果 $p(x)$ 与 $T$ 不相容，那么必须援引省略类型定理 (OTT) 来确保存在一个省略 $p(x)$ 的 $T$ 的模型。**\n\n这个陈述与对陈述 A 的分析中得出的结论直接矛盾。正如我们对陈述 A 所证明的，如果一个型 $p(x)$ 与 $T$ 不相容，那么 $T$ 的*每个*模型都会省略 $p(x)$。至少存在一个 $T$ 的模型，这一点由 $T$ 相容的初始假设所保证（根据完备性定理）。\n因此，存在一个省略不相容型的 $T$ 的模型是定义的初等推论。它不需要像省略类型定理 (Omitting Types Theorem) 这样强大的结果，该定理是为解决省略非孤立型这一更困难的问题而设计的。\n\n**结论：** 该陈述是 **不正确的**。", "answer": "$$\\boxed{AC}$$", "id": "3057275"}, {"introduction": "理解了“为何”需要省略类型定理之后，我们来动手实践“如何”操作。本题提供了一个具体的理论和类型，要求你构造出特定的模型。通过亲手构建一个实现了给定非主类型的模型和另一个省略了它的模型，你将直观地体验到类型的实现与否并非绝对，而是依赖于模型的具体结构，这正是模型论中一个核心且强大的思想。[@problem_id:2981095]", "problem": "设 $L$ 为一个一阶语言，其含有一个二元关系符号 $E$ 和一个可数常数符号族 $\\{c_{n} : n \\in \\mathbb{N}\\}$。考虑 $L$ 中的理论 $T$，它由以下公理模式公理化：\n- $E$ 是一个等价关系：自反、对称和传递。\n- 不同的常数位于不同的 $E$-等价类中：对所有 $n \\neq m$，$\\neg E(c_{n}, c_{m})$。\n- 每个 $E$-等价类都是无穷的：对每个 $k \\in \\mathbb{N}$，包含公理 $\\forall x\\, \\exists y_{1},\\dots,y_{k}\\,\\Big(\\bigwedge_{i=1}^{k} E(x,y_{i}) \\wedge \\bigwedge_{1 \\leq i  j \\leq k} y_{i} \\neq y_{j}\\Big)$。\n\n定义在空集 $\\emptyset$ 上的 $1$-型 $p(x)$ 为集合 $\\{\\neg E(x,c_{n}) : n \\in \\mathbb{N}\\}$。这个型直观地表示 $x$ 属于一个与所有由常数命名的 $E$-等价类都不相交的 $E$-等价类。\n\n从一阶模型论中型、主型、实现和省略的核心定义出发，并且不借助任何预先给定的构造技巧，完成以下任务：\n1. 证明 $p(x)$ 是一个与 $T$ 相容的、在 $\\emptyset$ 上的非主（非孤立）型，并解释它的实现如何依赖于模型。\n2. 对每个 $m \\in \\mathbb{N}$，构造一个 $T$ 的模型 $M_{m}$，其论域是常数 $\\{c_{n} : n \\in \\mathbb{N}\\}$ 的 $E$-等价类与恰好 $m$ 个额外 $E$-等价类的不交并，并确定使得 $p(x)$ 在 $M_{m}$ 中被实现的 $m$ 的最小值。\n\n你的最终答案必须是所需的 $m$ 的最小值，以无单位的整数形式表示。如果求得精确值，请勿四舍五入或取近似值。", "solution": "该问题要求分析一个特定的一阶理论 $T$、一个与之相关的型 $p(x)$，以及 $T$ 的某些模型的构造。我们将按顺序处理问题的每个部分，从必要的有效性验证开始。\n\n该问题是有效的。这是一个数理逻辑（模型论）中的良定问题。语言 $L$、理论 $T$ 和型 $p(x)$ 的定义都清晰且一致。$T$ 的公理是相容的；例如，可以通过将论域取为 $\\mathbb{N} \\times \\mathbb{N}$，并将 $(n,k) E (n',k')$ 定义为当且仅当 $n=n'$，同时将 $c_n$ 解释为 $(n,0)$ 来构造一个模型。该问题具有科学依据，是客观的，并且包含了得到严谨解答所需的所有信息。因此，我们可以继续。\n\n第一部分：对型 $p(x)$ 的分析。\n\n该型定义为空集 $\\emptyset$ 上的 $p(x) = \\{\\neg E(x,c_{n}) : n \\in \\mathbb{N}\\}$。我们必须证明它是一个与 $T$ 相容的非主型。\n\n首先，我们证明 $p(x)$ 与 $T$ 相容。如果一个型的每个有限子集都能在理论的某个模型中被满足，那么该型与这个理论相容。根据紧致性定理，如果 $T \\cup p(x)$ 的每个有限子集都有一个模型，那么 $T \\cup p(x)$ 就有一个模型。这等价于证明对于 $p(x)$ 的任意有限子集 $p_0(x) \\subseteq p(x)$，公式 $\\exists x \\bigwedge_{\\varphi(x) \\in p_0} \\varphi(x)$与 $T$ 相容。\n设 $p_0(x)$ 是 $p(x)$ 的一个任意有限子集。它必然具有形式 $\\{\\neg E(x, c_{n_1}), \\neg E(x, c_{n_2}), \\dots, \\neg E(x, c_{n_k})\\}$，其中 $\\{n_1, \\dots, n_k\\} \\subset \\mathbb{N}$ 是一个有限下标集。我们需要证明存在一个 $T$ 的模型和一个元素满足 $\\bigwedge_{i=1}^k \\neg E(x, c_{n_i})$。\n设 $M$ 是 $T$ 的任意一个模型。由于常数集 $\\{c_n : n \\in \\mathbb{N}\\}$ 是无穷的，我们可以选择一个下标 $m \\in \\mathbb{N}$ 使得 $m \\notin \\{n_1, \\dots, n_k\\}$。考虑元素 $c_m^M$，即常数 $c_m$ 在模型 $M$ 中的解释。根据 $T$ 的公理，对任意 $i \\in \\{1, \\dots, k\\}$，因为 $m \\neq n_i$，我们有 $M \\models \\neg E(c_m, c_{n_i})$。因此，元素 $c_m^M$ 满足公式 $\\bigwedge_{i=1}^k \\neg E(x, c_{n_i})$。这表明对于 $p(x)$ 的任何有限子集，在 $T$ 的任何模型中都存在一个元素来满足它。因此，$p(x)$ 与 $T$ 相容。\n\n其次，我们证明 $p(x)$ 是一个非主（非孤立）型。如果一个型被单个公式 $\\psi(x)$（参数来自 $\\emptyset$）所孤立，则称其为主型。如果 $p(x)$ 是主型，那么在语言 $L$ 中会存在一个公式 $\\psi(x)$，使得 $T \\vdash \\forall x(\\psi(x) \\rightarrow \\varphi(x))$ 对于所有 $\\varphi(x) \\in p(x)$ 成立。\n根据紧致性定理，如果 $\\psi(x)$ 蕴含 $p(x)$ 中的所有公式，那么它必定蕴含 $p(x)$ 的某个有限子集，例如 $\\{\\neg E(x, c_n) : n \\leq N\\}$（对于某个整数 $N \\in \\mathbb{N}$），能够蕴含 $\\psi(x)$ 本身。这意味着：\n$$T \\vdash \\forall x \\left( \\left(\\bigwedge_{n=0}^{N} \\neg E(x, c_n)\\right) \\rightarrow \\psi(x) \\right)$$\n现在，我们将此与 $\\psi(x)$ 必须蕴含 $p(x)$ 中所有公式这一事实结合，特别是对于下标 $n = N+1$：\n$$T \\vdash \\forall x (\\psi(x) \\rightarrow \\neg E(x, c_{N+1}))$$\n利用逻辑蕴涵的传递性，这两个陈述共同蕴涵：\n$$T \\vdash \\forall x \\left( \\left(\\bigwedge_{n=0}^{N} \\neg E(x, c_n)\\right) \\rightarrow \\neg E(x, c_{N+1}) \\right)$$\n我们将通过在 $T$ 的任意模型中找到一个反例来证明这个结论是错误的。设 $M$ 是 $T$ 的一个任意模型。我们通过对元素 $c_{N+1}^M$ 进行求值来检验这个所谓定理的有效性。\n设 $a = c_{N+1}^M$。蕴涵式的前件是 $\\bigwedge_{n=0}^{N} \\neg E(a, c_n^M)$。代入 $a$，我们得到 $\\bigwedge_{n=0}^{N} \\neg E(c_{N+1}^M, c_n^M)$。对于任何 $n \\in \\{0, \\dots, N\\}$，我们有 $n \\neq N+1$。$T$ 的公理之一是对于 $i \\neq j$ 有 $\\neg E(c_i, c_j)$。因此，对于所有 $n \\in \\{0, \\dots, N\\}$，$M \\models \\neg E(c_{N+1}^M, c_n^M)$。对于 $a$ 的这个选择，前件为真。\n蕴涵式的后件是 $\\neg E(a, c_{N+1}^M)$。代入 $a$，我们得到 $\\neg E(c_{N+1}^M, c_{N+1}^M)$。这在 $T$ 的任何模型 $M$ 中都是假的，因为 $E$ 是一个等价关系，必须是自反的，所以 $M \\models E(c_{N+1}^M, c_{N+1}^M)$。\n因为我们在 $T$ 的一个任意模型中找到了一个元素，它使得前件为真而后件为假，所以蕴涵式本身在该模型中是假的。这意味着该陈述不是 $T$ 的一个定理。这个矛盾推翻了我们最初关于 $p(x)$ 是主型的假设。我们得出结论，$p(x)$ 是非主型。\n\n最后，我们解释 $p(x)$ 的实现如何依赖于模型。由于 $L$ 是一个可数语言且 $T$ 是一个可数理论（其公理是一个可数集），我们可以应用模型论的标准结果。如我们所证，$p(x)$ 与 $T$ 相容，因此根据哥德尔完备性定理，存在一个实现 $p(x)$ 的 $T$ 的模型。另一方面，由于 $p(x)$ 是一个非主型，省略类型定理保证了存在一个省略 $p(x)$ 的 $T$ 的模型。如果一个模型的论域中没有任何元素实现 $p(x)$，则称该模型省略 $p(x)$。既存在实现 $p(x)$ 的模型，又存在省略 $p(x)$ 的模型，这表明该型的实现是依赖于模型的。\n\n第二部分：模型构造和最小实现。\n\n题目要求我们对每个 $m \\in \\mathbb{N}$（假设 $\\mathbb{N}=\\{0, 1, 2, \\dots\\}$）构造一个模型 $M_m$，其论域由常数 $\\{c_n : n \\in \\mathbb{N}\\}$ 的 $E$-等价类以及恰好 $m$ 个额外的 $E$-等价类组成，然后找出使 $p(x)$ 被实现的最小 $m \\ge 0$。\n\n让我们为任意整数 $m \\geq 0$ 定义模型 $M_m$。\n$M_m$ 的论域，记作 $|M_m|$，是集合：\n$$|M_m| = \\left(\\bigcup_{n \\in \\mathbb{N}} \\{(n, k) : k \\in \\mathbb{N} \\}\\right) \\cup \\left(\\bigcup_{j=1}^m \\{(s_j, k) : k \\in \\mathbb{N} \\}\\right)$$\n在这里，$\\{s_1, \\dots, s_m\\}$ 是 $m$ 个不同符号的集合，其中没有一个符号在 $\\mathbb{N}$ 中。如果 $m=0$，则并集的第二部分为空。\n常数符号的解释是 $c_n^{M_m} = (n, 0)$，对每个 $n \\in \\mathbb{N}$ 成立。\n关系符号 $E$ 的解释定义如下：对于 $|M_m|$中的任意两个元素 $a = (i_1, k_1)$ 和 $b = (i_2, k_2)$，我们设定 $M_m \\models E(a,b)$ 当且仅当 $i_1 = i_2$。\n\n我们验证 $M_m$ 是 $T$ 的一个模型。\n1. $E$ 是一个等价关系：具有相同第一分量的关系是自反、对称和传递的。此公理成立。\n2. 不同的常数位于不同的等价类中：对于 $n \\neq l$，$c_n^{M_m} = (n, 0)$ 和 $c_l^{M_m} = (l, 0)$。由于 $n \\neq l$，它们的第一分量不同，所以 $M_m \\models \\neg E(c_n, c_l)$。此公理成立。\n3. 每个 $E$-等价类都是无穷的：等价类是集合 $C_i = \\{(i, k) : k \\in \\mathbb{N}\\}$，其中 $i$ 在下标集 $\\mathbb{N} \\cup \\{s_1, \\dots, s_m\\}$ 中。每个这样的集合都是可数无限的。公理要求对于任何 $j \\in \\mathbb{N}$，任何等价类都至少包含 $j$ 个不同的元素。由于每个类都是无穷的，这个条件得到满足。此公理成立。\n因此，对每个 $m \\geq 0$，$M_m$ 都是 $T$ 的一个模型。根据构造，它拥有常数的 $E$-等价类（由 $\\mathbb{N}$ 索引）和恰好 $m$ 个额外的 $E$-等价类（由 $\\{s_1, \\dots, s_m\\}$ 索引）。\n\n现在我们确定对于哪些 $m$ 值，型 $p(x)$ 在 $M_m$ 中被实现。\n如果对所有 $n \\in \\mathbb{N}$ 都有 $M_m \\models \\neg E(a, c_n^{M_m})$，则元素 $a \\in |M_m|$ 实现 $p(x)$。\n设 $a = (i, k)$ 是 $|M_m|$ 的一个任意元素。条件 $M_m \\models \\neg E(a, c_n^{M_m})$ 等价于 $M_m \\models \\neg E((i,k), (n,0))$，根据我们对 $E$ 的定义，这意味着 $i \\neq n$。\n为了让 $a$ 实现 $p(x)$，这个条件必须对所有 $n \\in \\mathbb{N}$ 成立。所以，元素 $a$ 的第一分量 $i$ 不能是任何自然数。\n在 $|M_m|$ 中可能的第一分量是 $\\mathbb{N} \\cup \\{s_1, \\dots, s_m\\}$ 中的元素。\n因此，一个元素 $a = (i,k)$ 实现 $p(x)$ 当且仅当 $i \\in \\{s_1, \\dots, s_m\\}$。\n\n- 如果 $m=0$，下标集就是 $\\mathbb{N}$。对于 $|M_0|$ 中的任何元素 $a=(n,k)$，它的第一分量是 $n \\in \\mathbb{N}$。这个元素 $a$ 未能满足 $\\neg E(x, c_n)$，因为 $M_0 \\models E((n,k), (n,0))$。因此，$M_0$ 中没有元素实现 $p(x)$，该型被省略。\n- 如果 $m \\geq 1$，下标集包含 $s_1$。考虑元素 $a = (s_1, 0) \\in |M_m|$。其第一分量是 $s_1$。对于任何 $n \\in \\mathbb{N}$，$s_1 \\neq n$。因此，对所有 $n \\in \\mathbb{N}$，$M_m \\models \\neg E((s_1,0), (n,0))$。这意味着元素 $a=(s_1,0)$ 实现了型 $p(x)$。\n\n型 $p(x)$ 在 $M_m$ 中被实现当且仅当 $m \\geq 1$。问题要求的是使此为真的 $m$ 的最小值。满足 $m \\geq 1$ 的最小非负整数是 $m=1$。", "answer": "$$\\boxed{1}$$", "id": "2981095"}, {"introduction": "省略类型定理的全部威力在于它能够同时省略可数多个非主类型。这项练习将挑战你分析多种情境，以找出一个可以同时省略两个非主类型的实例。通过这个过程，你将提升自己辨别非主类型以及检验定理适用条件的能力，从而学会如何运用该定理来构造具有高度特定性质的模型。[@problem_id:3059049]", "problem": "设 $L$ 是一个可数一阶语言，$T$ 是一个相容的 $L$-理论。空集上的一个（完全）1-型是一个含一个自由变元 $x$ 且无参数的 $L$-公式的极大相容集 $p(x)$。如果一个型被某个与 $T$ 相容的公式 $\\varphi(x)$ 所孤立（即对于型中任意公式 $\\psi(x)$ 都有 $T \\vdash \\forall x\\,(\\varphi(x) \\rightarrow \\psi(x))$），则称其为**孤立的 (isolated)**。一个型如果不是孤立的，则称为**非孤立的 (non-isolated)**。丢型定理（OTT）陈述：如果 $L$ 是可数的，$T$ 是一个相容的 $L$-理论，那么一个可数非孤立 1-型集合 $\\{p_n(x) : n \\in \\mathbb{N}\\}$ 可以在 $T$ 的某个可数模型中被同时丢掉。\n\n下列哪个选项正确地给出了一个可数语言 $L$、一个 $L$ 中的相容理论 $T$，以及两个不同的、可以在 $T$ 的某个模型中被同时丢掉的空集 $\\emptyset$ 上的非孤立 1-型 $p(x)$ 和 $q(x)$？\n\nA. 设 $L$ 有一元谓词符号 $\\{P_n : n \\in \\mathbb{N}\\}$。设 $T$ 断言：\n- 对于每个有限子集 $F \\subseteq \\mathbb{N}$ 和函数 $\\varepsilon : F \\to \\{0,1\\}$，存在无限多个 $x$ 使得 $\\bigwedge_{n \\in F} \\bigl(P_n(x) \\leftrightarrow \\varepsilon(n) = 1\\bigr)$。\n定义 $p(x) := \\{P_n(x) : n \\in \\mathbb{N}\\}$ 和 $q(x) := \\{\\neg P_n(x) : n \\in \\mathbb{N}\\}$。\n\nB. 设 $L$ 有一个一元谓词 $R$ 和一个常数符号 $c$。设 $T$ 断言 $R(c)$ 和 $\\forall x\\,(R(x) \\rightarrow x = c)$。定义 $p(x) := \\{R(x)\\}$ 和 $q(x) := \\{x \\neq c\\}$。\n\nC. 设 $L$ 有一个二元关系 $$ 和常数 $\\{d_n : n \\in \\mathbb{N}\\}$。设 $T$ 断言 $$ 是一个无端点的稠密线性序，并且 $\\{d_n : n \\in \\mathbb{N}\\}$ 是严格递增且双向共尾的：$\\forall x\\,\\exists n\\,(x  d_n)$ 和 $\\forall x\\,\\exists n\\,(d_n  x)$。定义 $p(x) := \\{x > d_n : n \\in \\mathbb{N}\\}$ 和 $q(x) := \\{x  d_n : n \\in \\mathbb{N}\\}$。\n\nD. 设 $L$ 有一个单元谓词 $P$。设 $T$ 断言 $P$ 挑出论域的一个无限且余无限的子集：对于每个 $k \\in \\mathbb{N}$，$\\exists^{\\geq k} x\\, P(x)$ 和 $\\exists^{\\geq k} x\\, \\neg P(x)$ 都成立。定义 $p(x) := \\{P(x)\\}$ 和 $q(x) := \\{\\neg P(x)\\}$。\n\n选择正确的选项，并从第一性原理出发论证你的选择，包括理论的相容性、型的孤立与非孤立状态，以及应用丢型定理来保证存在一个同时丢掉 $p(x)$ 和 $q(x)$ 的模型的适用性。", "solution": "问题要求我们找出一个正确的例子，包含一个可数语言 $L$、一个相容理论 $T$，以及两个不同的、可以在 $T$ 的某个模型中被同时丢掉的非孤立 1-型 $p(x)$ 和 $q(x)$。\n\n根据问题中给出的定义：\n- **孤立型**：被一个与 $T$ 相容的公式所孤立。\n- **非孤立型**：不是孤立的。\n- **丢型定理 (OTT)**：一个可数非孤立型集合可以在某个可数模型中被同时丢掉。\n\n一个型能被丢掉，意味着它不能被任何公式孤立。\n\n我们现在来分析每个选项。\n\n**A. 设 $L$ 有一元谓词符号 $\\{P_n : n \\in \\mathbb{N}\\}$。设 $T$ 断言：对于每个有限子集 $F \\subseteq \\mathbb{N}$ 和函数 $\\varepsilon : F \\to \\{0,1\\}$，存在无限多个 $x$ 使得 $\\bigwedge_{n \\in F} \\bigl(P_n(x) \\leftrightarrow \\varepsilon(n) = 1\\bigr)$。定义 $p(x) := \\{P_n(x) : n \\in \\mathbb{N}\\}$ 和 $q(x) := \\{\\neg P_n(x) : n \\in \\mathbb{N}\\}$。**\n\n1.  **语言和理论**：语言 $L = \\{P_n : n \\in \\mathbb{N}\\}$ 是可数的。理论 $T$ 是相容的。为了证明这一点，我们使用紧致性定理。T 的任何有限公理子集只涉及有限多个谓词符号，比如对于某个有限集 $I \\subseteq \\mathbb{N}$，涉及 $\\{P_n : n \\in I\\}$。我们可以在论域 $\\mathbb{N}$ 上为这个有限公理集构造一个模型，方法是将 $\\mathbb{N}$ 划分为 $2^{|I|}$ 个无限子集，每个子集对应于 $\\{P_n : n \\in I\\}$ 中谓词的一种可能的真值指派。这满足了该有限公理子集。根据紧致性定理，$T$ 有模型，因而是相容的。\n\n2.  **型**：公式集 $p(x) = \\{P_n(x) : n \\in \\mathbb{N}\\}$ 和 $q(x) = \\{\\neg P_n(x) : n \\in \\mathbb{N}\\}$ 显然是不同的。\n\n3.  **非孤立状态**：我们来检查 $p(x)$ 是否为非孤立型。我们需要证明没有单个与 $T$ 相容的公式 $\\varphi(x)$ 能孤立 $p(x)$。设 $\\varphi(x)$ 是语言 $L$ 中的任意公式。由于公式长度有限，$\\varphi(x)$ 只能提及有限个谓词符号，比如对于某个有限集 $F \\subset \\mathbb{N}$，提及 $\\{P_n : n \\in F\\}$。若要 $\\varphi(x)$ 孤立 $p(x)$，则必须对所有 $m \\in \\mathbb{N}$ 都有 $T \\vdash \\forall x (\\varphi(x) \\rightarrow P_m(x))$。我们来证明这是不可能的。\n    取一个索引 $m \\in \\mathbb{N}$ 使得 $m \\notin F$。根据 $T$ 的公理，对于集合 $F \\cup \\{m\\}$ 和一个将 $m$ 映为 0，将 $F$ 中元素映为任意值的函数 $\\varepsilon$，存在一个元素 $b$ 满足相应的真值指派。这意味着 $b$ 满足 $\\neg P_m(b)$。但是，$\\varphi(b)$ 的真值仅取决于 $F$ 上的谓词值，我们可以选择一个满足 $\\varphi(x)$ 的真值组合。更明确地说，假设 $\\varphi(x)$ 与 $T$ 相容。那么存在一个模型和一个元素 $a$ 满足 $\\varphi(a)$。$a$ 确定了 $F$ 上的一个真值指派 $\\varepsilon_0$。现在我们考虑一个新的指派 $\\varepsilon_1$，它在 $F$ 上与 $\\varepsilon_0$ 一致，但在 $m$ 上取值为 0。根据 $T$，存在一个元素 $b$ 实现 $\\varepsilon_1$。由于 $\\varphi$ 不依赖于 $P_m$，$\\varphi(b)$ 的真值与 $\\varphi(a)$ 相同，所以 $b$ 满足 $\\varphi(b)$。然而， $b$ 满足 $\\neg P_m(b)$。\n    因此，在 $T$ 的一个模型中，存在一个元素 $b$ 使得 $\\varphi(b) \\wedge \\neg P_m(b)$ 为真。这意味着 $T \\not\\vdash \\forall x(\\varphi(x) \\rightarrow P_m(x))$。\n    既然我们找到了 $p(x)$ 中的一个公式（即 $P_m(x)$），它在 $T$ 下不是 $\\varphi(x)$ 的推论，那么就没有这样的 $\\varphi(x)$ 可以孤立 $p(x)$。因此，$p(x)$ 是非孤立的。\n    一个对称的论证表明 $q(x) = \\{\\neg P_n(x) : n \\in \\mathbb{N}\\}$ 也是非孤立的。\n\n4.  **可丢性**：由于 $p(x)$ 和 $q(x)$ 都是非孤立的，且语言是可数的，丢型定理保证了存在一个 $T$ 的可数模型，它同时丢掉这两个型。\n\n结论：选项 A 满足所有给定条件。\n**对 A 的判定：正确。**\n\n**B. 设 $L$ 有一个一元谓词 $R$ 和一个常数符号 $c$。设 $T$ 断言 $R(c)$ 和 $\\forall x\\,(R(x) \\rightarrow x = c)$。定义 $p(x) := \\{R(x)\\}$ 和 $q(x) := \\{x \\neq c\\}$。**\n\n公理 $T \\vdash R(c)$ 直接蕴含 $T \\vdash \\exists x R(x)$。公式 $\\varphi(x) \\equiv R(x)$ 与 $T$ 相容。并且，它（平凡地）蕴含 $p(x)$ 的所有公式（也就是它自己）。因此，$p(x)$ 被 $R(x)$ 孤立。因为孤立的型不能被丢掉，此选项不满足“型可以被丢掉”这个主要要求。\n**对 B 的判定：不正确。**\n\n**C. 设 $L$ 有一个二元关系 $$ 和常数 $\\{d_n : n \\in \\mathbb{N}\\}$。设 $T$ 断言 $$ 是一个无端点的稠密线性序，并且 $\\{d_n : n \\in \\mathbb{N}\\}$ 是严格递增且双向共尾的：$\\forall x\\,\\exists n\\,(x  d_n)$ 和 $\\forall x\\,\\exists n\\,(d_n  x)$。定义 $p(x) := \\{x > d_n : n \\in \\mathbb{N}\\}$ 和 $q(x) := \\{x  d_n : n \\in \\mathbb{N}\\}$。**\n\n此选项中的理论 $T$ 是不相容的。公理“$\\{d_n : n \\in \\mathbb{N}\\}$ 是严格递增的”意味着 $d_0  d_1  d_2  \\dots$。这蕴含了 $d_0$ 是常数集合 $D = \\{d_n : n \\in \\mathbb{N}\\}$ 的一个下界。\n然而，公理“双向共尾”包含了陈述 $\\forall x\\,\\exists n\\,(d_n  x)$。这说明集合 $D$ 没有下界。如果我们用 $x = d_0$ 来例化这个公理，它断言存在一个 $n \\in \\mathbb{N}$ 使得 $d_n  d_0$。这与 $d_0$ 是该序列的一个下界（即对所有 $n \\ge 0$, $d_n \\ge d_0$）这一事实直接矛盾。\n由于理论 $T$ 不相容，它没有任何模型。因此，在 $T$ 的模型中丢掉型的问题是空洞的。\n**对 C 的判定：不正确。**\n\n**D. 设 $L$ 有一个单元谓词 $P$。设 $T$ 断言 $P$ 挑出论域的一个无限且余无限的子集：对于每个 $k \\in \\mathbb{N}$，$\\exists^{\\geq k} x\\, P(x)$ 和 $\\exists^{\\geq k} x\\, \\neg P(x)$ 都成立。定义 $p(x) := \\{P(x)\\}$ 和 $q(x) := \\{\\neg P(x)\\}$。**\n\n1.  **语言和理论**：语言 $L=\\{P\\}$ 是可数的。理论 $T$ 是相容的；一个模型是自然数集 $\\mathbb{N}$，其中 $P$ 被解释为偶数集。\n2.  **型与孤立状态**：该理论是完备的（可以通过量词消去证明），并且是 $\\aleph_0$-范畴的。根据 Ryll-Nardzewski 定理，一个可数完备理论是 $\\aleph_0$-范畴的，当且仅当它的所有完全型都是孤立的（主型）。\n    在这个具体的理论中，恰好有两个 1-型：一个包含 $P(x)$，另一个包含 $\\neg P(x)$。我们来确认包含 $p(x) = \\{P(x)\\}$ 的型是孤立的。公式 $\\varphi(x) \\equiv P(x)$ 与 $T$ 相容，因为 $T$ 断言 $\\exists x P(x)$。并且 $\\varphi(x)$ 平凡地蕴含了 $p(x)$ 的所有公式。因此，型 $p(x)$ 是孤立的。同理，由 $q(x) = \\{\\neg P(x)\\}$ 生成的型也是孤立的。\n    因为两个型都是孤立的，所以它们不能被丢掉。问题要求非孤立型。\n**对 D 的判定：不正确。**\n\n根据以上分析，只有选项 A 提供了一个满足所有要求条件的有效例子。", "answer": "$$\\boxed{A}$$", "id": "3059049"}]}