{"hands_on_practices": [{"introduction": "要真正理解克林递归定理 (Kleene's Recursion Theorem)，最好的起点是将其视为一个强大的不动点定理。这个练习旨在帮助你建立关于该定理核心思想的直观认识。我们不直接构造一个复杂的程序，而是通过一个思想实验，利用递归定理来证明一个特定类型程序的“存在性”，即一个其行为与某个程序转换函数的不动点相对应的程序。[@problem_id:3045831]", "problem": "设 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 是通过一个通用部分可计算函数 $U$ 对所有部分可计算函数 $\\mathbb{N} \\to \\mathbb{N}$ 的一个固定有效枚举，使得对于所有 $e,x \\in \\mathbb{N}$，都有 $\\varphi_{e}(x) = U(e,x)$。假设存在一个全可计算函数 $f \\colon \\mathbb{N} \\to \\mathbb{N}$，它具有以下性质：对于每个指标 $e \\in \\mathbb{N}$ 和所有输入 $x \\in \\mathbb{N}$，指标为 $f(e)$ 的函数计算的是常数零函数，即 $\\varphi_{f(e)}(x) = 0$。仅使用可计算性的核心定义（包括通用部分可计算函数的存在性和参数化引理，也称为 $s\\text{-}m\\text{-}n$ 定理），以及 Kleene 递归定理的机制，严格证明存在一个指标 $e \\in \\mathbb{N}$，使得 $\\varphi_{e}$ 是常数零函数。然后，确定 $\\varphi_{e}(2^{10} + 3)$ 的确切值。将你的最终答案表示为单个数字。无需四舍五入。", "solution": "该问题陈述是可计算性理论中的一个有效练习。它要求使用 Kleene 递归定理证明常数零函数的指标的存在性，然后计算该函数的一个值。我们可以进行形式化的求解。\n\n所需的核心工具是 Kleene 第二递归定理，其陈述如下：对于任意全可计算函数 $g \\colon \\mathbb{N} \\to \\mathbb{N}$，存在一个指标 $n \\in \\mathbb{N}$，使得对于所有 $x \\in \\mathbb{N}$，由指标 $n$ 和 $g(n)$ 索引的部分可计算函数是相同的。用符号表示为 $\\varphi_n = \\varphi_{g(n)}$。这个指标 $n$ 通常被称为函数 $g$ 的一个不动点。\n\n问题提供了一个全可计算函数 $f \\colon \\mathbb{N} \\to \\mathbb{N}$。因此，我们可以将 Kleene 递归定理直接应用于这个函数 $f$。根据该定理，必然存在一个指标，我们称之为 $e \\in \\mathbb{N}$，使得 $\\varphi_e = \\varphi_{f(e)}$。\n\n接下来，我们使用问题陈述中给出的函数 $f$ 的性质。陈述指出，对于每个指标 $k \\in \\mathbb{N}$ 和所有输入 $x \\in \\mathbb{N}$，指标为 $f(k)$ 的函数是常数零函数。这意味着对于所有 $k, x \\in \\mathbb{N}$，都有 $\\varphi_{f(k)}(x) = 0$。\n\n现在，我们可以结合这两个事实。我们有一个特定的指标 $e$，它是 $f$ 的一个不动点。$f$ 的性质对任何指标 $k$ 都成立，所以它也必须对我们的特定指标 $e$ 成立。将 $k=e$ 代入 $f$ 的性质中，我们发现函数 $\\varphi_{f(e)}$ 是常数零函数。也就是说，对于所有 $x \\in \\mathbb{N}$，$\\varphi_{f(e)}(x) = 0$。\n\n既然我们从递归定理知道 $\\varphi_e = \\varphi_{f(e)}$，就可以立即得出 $\\varphi_e$ 也必定是常数零函数。因此，对于我们的不动点指标 $e$，对于所有 $x \\in \\mathbb{N}$，都有 $\\varphi_e(x) = 0$ 成立。这严格证明了常数零函数的指标 $e$ 的存在性，正如问题所要求的。\n\n问题的第二部分要求计算 $\\varphi_e(2^{10} + 3)$ 的值。我们刚刚证明了 $\\varphi_e$ 是常数零函数，这意味着对于其定义域 $\\mathbb{N}$ 中的任何输入，其输出都是 $0$。输入是 $2^{10} + 3 = 1024 + 3 = 1027$，这是一个自然数。\n\n因此，我们可以计算该函数的值：\n$$\n\\varphi_e(2^{10} + 3) = \\varphi_e(1027) = 0\n$$\n其值恰好为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3045831"}, {"introduction": "在理解了递归定理保证了“不动点”程序的存在性之后，下一步是亲手构造一个。这个练习将引导你完成克林递归定理的构造性证明过程，其目标是构建计算机科学中最经典、最令人着迷的自引用程序之一：一个能够输出自身代码（或索引）的程序，通常被称为“蒯因”(Quine)。通过这个实践，你将深入了解参数定理（$s\\text{-}m\\text{-}n$ 定理）是如何成为实现这种自引用的关键引擎。[@problem_id:2970608]", "problem": "固定一个可接受的偏可计算函数的哥德尔数系，使得对每个 $e \\in \\mathbb{N}$，索引 $e$ 命名一个一元偏可计算函数 $y \\mapsto \\varphi_{e}(y)$，并且对每个 $e \\in \\mathbb{N}$，索引 $e$ 也命名一个二元偏可计算函数 $(x,y) \\mapsto \\varphi_{e}^{(2)}(x,y)$（通过任何标准的输入统一配对得到）。假设以下基本事实。\n\n1. 存在一个全原始递归配对函数 $\\langle \\cdot,\\cdot \\rangle : \\mathbb{N}^{2} \\to \\mathbb{N}$，该函数是双射的，并带有原始递归的投影函数。\n2. 对于二元枚举，存在一个通用索引 $U$，使得对所有 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{U}^{(2)}(\\langle e,a \\rangle, y) = \\varphi_{e}^{(2)}(a,y)$。\n3. (Kleene $s\\text{-}m\\text{-}n$ 定理) 存在一个全原始递归函数 $s : \\mathbb{N}^{2} \\to \\mathbb{N}$，使得对所有 $e,a,y \\in \\mathbb{N}$，有 $\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)$。\n4. 固定一个二元“打印”程序的索引 $p$，定义为对所有 $x,y \\in \\mathbb{N}$，$\\varphi_{p}^{(2)}(x,y) = x$。\n\n定义二元偏可计算函数 $D : \\mathbb{N}^{2} \\rightrightarrows \\mathbb{N}$ 如下\n$$\nD(x,y) \\;=\\; \\varphi_{s(p,\\,s(x,x))}(y),\n$$\n并固定任何满足 $\\varphi_{d}^{(2)}(x,y) = D(x,y)$（对所有 $x,y \\in \\mathbb{N}$）的索引 $d$。\n\n只使用上述基本事实（特别是 Kleene 递归定理和 $s\\text{-}m\\text{-}n$ 定理），构造一个一元自指程序（一个“quine”），该程序对任何输入 $y$ 都输出其自身的索引。你的构造必须从第一性原理出发，通过给定的基元 $s$、$p$ 和选定的索引 $d$ 显式地构建该索引，使其成为一个可计算表达式。在你的推导过程中，解释 $s\\text{-}m\\text{-}n$ 定理在实现自引用中所扮演的概念性角色。\n\n对于这样一个 quine 的索引 $e^{\\star}$，用上面介绍的符号 $s$ 和 $d$ 表示的单一封闭形式表达式是什么？请以单个符号表达式的形式提供最终答案。不需要数值近似或四舍五入。", "solution": "问题陈述被认定为有效。这是一个在数理逻辑的一个子领域——可计算性理论的既定框架内的适定问题。它具有科学依据、客观，并包含了获得唯一解所需的所有必要信息。任务是从一组给定的原始可计算函数和索引中构造一个自指程序（quine）的索引。\n\n目标是找到一个索引 $e^{\\star} \\in \\mathbb{N}$，使得对于所有输入 $y \\in \\mathbb{N}$，偏可计算函数 $\\varphi_{e^{\\star}}$ 停机并输出其自身的索引：$\\varphi_{e^{\\star}}(y) = e^{\\star}$。\n\n该构造从根本上依赖于 Kleene $s\\text{-}m\\text{-}n$ 定理。该定理提供了一个全原始递归函数 $s: \\mathbb{N}^2 \\to \\mathbb{N}$，使得对于任何二元偏可计算函数 $\\varphi_e^{(2)}(x,y)$ 的索引 $e$ 以及第一个输入的任何值 $a \\in \\mathbb{N}$，我们都可以计算出结果一元函数的一个新索引 $s(e,a)$。即 $\\varphi_{s(e,a)}(y) = \\varphi_e^{(2)}(a,y)$。从概念上讲，$s\\text{-}m\\text{-}n$ 定理形式化了“特化”或“部分求值”的过程：它提供了一种可计算的方法，通过固定通用程序（索引 $e$）的一个输入，将其转换为一个专用程序（索引 $s(e,a)$）。程序能够机械地为其他程序生成索引的这种能力，是实现 quine 所需自引用的关键机制，正如 Kleene 递归定理的构造性证明所示。\n\n构造过程首先从分析问题陈述中提供的函数 $D(x,y)$ 开始。该函数定义为 $D(x,y) = \\varphi_{s(p, s(x,x))}(y)$。我们已知 $d$ 是这个函数的索引，意味着对于所有 $x,y \\in \\mathbb{N}$，有 $\\varphi_d^{(2)}(x,y) = D(x,y)$。\n\n让我们来简化 $D(x,y)$ 的表达式。\n根据 $s\\text{-}m\\text{-}n$ 定理的定义，我们可以陈述对于任何 $e, a, y \\in \\mathbb{N}$：\n$$\n\\varphi_{s(e,a)}(y) = \\varphi_{e}^{(2)}(a,y)\n$$\n在 $D(x,y)$ 的表达式中，我们可以识别出 $e=p$ 和 $a=s(x,x)$。应用该定理可得：\n$$\n\\varphi_{s(p, s(x,x))}(y) = \\varphi_{p}^{(2)}(s(x,x), y)\n$$\n问题将索引 $p$ 定义为对应于二元“打印”程序，使得对于所有 $z, y \\in \\mathbb{N}$，有 $\\varphi_{p}^{(2)}(z,y) = z$。代入 $z = s(x,x)$，我们得到：\n$$\n\\varphi_{p}^{(2)}(s(x,x), y) = s(x,x)\n$$\n结合这些结果，我们得到 $D(x,y)$ 的简化形式：\n$$\nD(x,y) = \\varphi_{s(p, s(x,x))}(y) = s(x,x)\n$$\n由于 $d$ 是 $D(x,y)$ 的索引，我们已经确定了索引为 $d$ 的程序的一个关键性质：\n$$\n\\varphi_{d}^{(2)}(x,y) = s(x,x)\n$$\n这意味着索引为 $d$ 的二元程序接受两个输入 $x$ 和 $y$，忽略第二个输入 $y$，并返回值 $s(x,x)$。\n\n我们现在采用一个模仿 Kleene 递归定理证明的构造来找到所需的不动点。该定理的构造性证明表明，对于像 $\\varphi_d^{(2)}$ 这样的函数，不动点通常可以通过将 $s$-函数应用于函数本身的索引来找到。让我们提出我们的 quine 的候选索引 $e^{\\star}$ 为：\n$$\ne^{\\star} = s(d,d)\n$$\n为了验证该索引对应一个 quine，我们必须对任意输入 $y \\in \\mathbb{N}$ 求值函数 $\\varphi_{e^{\\star}}(y)$。\n\n根据 $e^{\\star}$ 的定义，我们有：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y)\n$$\n我们将 $s\\text{-}m\\text{-}n$ 定理应用于右侧，其中 $e=d$ 且 $a=d$：\n$$\n\\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y)\n$$\n现在，我们使用我们先前推导出的函数 $\\varphi_d^{(2)}$ 的性质，该性质表明对于所有 $x,y$，$\\varphi_d^{(2)}(x,y) = s(x,x)$。我们代入 $x=d$：\n$$\n\\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n将这些等式串联起来，我们得到：\n$$\n\\varphi_{e^{\\star}}(y) = \\varphi_{s(d,d)}(y) = \\varphi_{d}^{(2)}(d,y) = s(d,d)\n$$\n因为我们定义了 $e^{\\star} = s(d,d)$，我们已经证明对于任何输入 $y$，\n$$\n\\varphi_{e^{\\star}}(y) = e^{\\star}\n$$\n这证实了索引 $e^{\\star} = s(d,d)$ 确实是一个 quine 的索引。该表达式完全由给定的基元 $s$ 和 $d$ 构建，符合要求。", "answer": "$$\n\\boxed{s(d,d)}\n$$", "id": "2970608"}, {"introduction": "这个高级练习将递归定理置于更广阔的计算理论背景下，旨在综合运用多个核心概念。通过结合使用克林递归定理和 $s$-$m$-$n$ 定理，你将构造出两个语法不同（代码不同）但语义相同（计算相同的函数）的程序。这个构造将成为一个强大的工具，帮助你探索程序语法和语义之间的深刻区别，并最终导向对计算基本限制的理解，正如莱斯定理 (Rice's Theorem) 所揭示的那样。[@problem_id:2982151]", "problem": "设 $\\{\\phi_{e}\\}_{e \\in \\mathbb{N}}$ 是所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分可计算函数通过图灵机（TM）编码的一个标准有效枚举。如果对于所有 $e, e' \\in \\mathbb{N}$，只要作为部分函数有 $\\phi_{e} = \\phi_{e'}$，就有 $E(e) = E(e')$，那么指标的一个性质 $E$ 被称为外延性的（extensional）。如果指标的一个性质 $S$ 可以依赖于指标的具体编码，而不必由其计算的部分函数所决定，那么它被称为语法性的（syntactic）。\n\n从上述基本定义以及可计算性理论中以下公认的事实出发：\n\n- $s\\text{-}m\\text{-}n$（参数化）定理：存在一个全可计算函数 $s$，使得对于每个可计算函数 $\\psi(n,p,x)$，都存在 $s(n,p)$ 满足对于所有 $x$，有 $\\phi_{s(n,p)}(x) = \\psi(n,p,x)$。\n- Kleene 递归定理：对于任意关于指标的全可计算变换器 $F$，都存在一个 $p$ 使得 $\\phi_{p} = \\phi_{F(p)}$。\n- Rice 定理：部分可计算函数的任何非平凡外延性质都是不可判定的。\n\n执行以下操作：\n\n1. 使用 Kleene 递归定理来证明存在一个指标 $p$，使得对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{p}(x) = 0$。\n2. 使用 $s$-$m$-$n$ 定理，定义一个全可计算且单射的“包装”函数 $b \\colon \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$，使得对于所有 $n, p, x \\in \\mathbb{N}$，指标 $b(n,p)$ 编码一个程序，该程序首先执行恰好 $n$ 个语法的“无操作”（no-op）步骤，然后模拟 $\\phi_{p}(x)$，因此有 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$。你可以假设底层的代码模型允许将 $n$ 字面地嵌入到程序中，从而使得 $b(n,p)$ 在对 $(n,p)$ 上是单射的。\n3. 构造两个不同的指标 $e_{1} = b(3,p)$ 和 $e_{2} = b(7,p)$，并从第一性原理出发论证 $\\phi_{e_{1}} = \\phi_{e_{2}}$ 同时 $e_{1} \\neq e_{2}$。\n4. 定义外延性质 $E(e)$ 如下：\n   $$E(e) = \\begin{cases}\n   1  \\text{若 } \\forall x \\in \\mathbb{N},\\, \\phi_{e}(x) = 0,\\\\\n   0  \\text{其他情况。}\n   \\end{cases}$$\n   解释为什么 Rice 定理意味着 $E$ 是不可判定的，并直接验证 $E(e_{1}) = E(e_{2})$。\n5. 定义语法性质 $S(e)$ 为由包装函数 $b$ 产生的代码中前导无操作步骤的数量。形式上，设\n   $$S(e) = \\begin{cases}\n   n  \\text{若对于第 1 部分中的固定 } p，e = b(n,p), \\\\\n   0  \\text{其他情况。}\n   \\end{cases}$$\n   证明 $S$ 是可判定的，并且 $S(e_{1}) \\neq S(e_{2})$。\n\n最后，计算实数值\n$$F \\;=\\; E(e_{1}) \\;+\\; E(e_{2}) \\;+\\; \\big|S(e_{1}) - S(e_{2})\\big|.$$\n无需四舍五入。将最终答案表示为单个无单位的数字。", "solution": "该问题被评估为有效。它在科学上植根于可计算性理论，问题提出得当且客观。这是一个标准的练习，旨在说明 Kleene 递归定理、$s$-$m$-$n$ 定理和 Rice 定理的应用，以及程序的外延性与语法性属性之间的关键区别。我们接下来将给出完整解答。\n\n该问题要求进行分步构建和分析，并最终进行计算。我们将依次处理每个部分。\n\n1.  **常数零函数的指标 $p$ 的存在性**\n\n我们被要求使用 Kleene 递归定理来证明存在一个指标 $p$，使得对于所有 $x \\in \\mathbb{N}$，都有 $\\phi_{p}(x) = 0$。\n\n考虑函数 $\\psi(e, x) = 0$。这个函数显然是全可计算的，因为它忽略其输入并输出一个常数。根据 s-m-n 定理（在一个简化形式中，第二个参数不存在），存在一个全可计算函数，我们将其表示为 $F: \\mathbb{N} \\to \\mathbb{N}$，使得对于任何指标 $e \\in \\mathbb{N}$，有 $\\phi_{F(e)}(x) = \\psi(e, x)$。代入 $\\psi$ 的定义，我们得到对于所有 $x \\in \\mathbb{N}$，有 $\\phi_{F(e)}(x) = 0$。\n\n函数 $F$ 是一个作用于指标上的全可计算变换器。根据 Kleene 递归定理，这个变换器必定存在一个不动点，即一个指标 $p \\in \\mathbb{N}$ 使得 $\\phi_{p} = \\phi_{F(p)}$。\n\n根据 $F$ 的定义，我们知道 $\\phi_{F(p)}$ 是这样一个部分函数：对于所有 $x \\in \\mathbb{N}$，它计算 $\\phi_{F(p)}(x) = 0$。因为 $\\phi_{p} = \\phi_{F(p)}$，所以直接得出对于所有 $x \\in \\mathbb{N}$，有 $\\phi_{p}(x) = 0$。这就确立了所需指标 $p$ 的存在性。在问题的剩余部分，我们将固定使用这个特定的指标 $p$。\n\n2.  **包装函数 $b(n, p)$ 的定义**\n\n我们需要使用 s-m-n 定理来定义一个全可计算且单射的函数 $b(n, p)$。这个函数应该产生一个程序的指标，该程序的行为与指标为 $p$ 的程序完全相同，但在执行 $n$ 个语法的“无操作”（no operation）步骤之后。\n\n让我们定义一个三元函数 $\\Psi(n, p, x)$。$\\Psi$ 的预期行为是模拟 $\\phi_{p}(x)$ 的计算，但 $\\Psi$ 的底层图灵机代码将在语法上依赖于 $n$。然而，其*函数*输出与 $n$ 无关。我们将该函数定义为 $\\Psi(n, p, x) = \\phi_{p}(x)$。根据 Church-Turing 论题和通用图灵机的存在性，函数 $\\Psi(n, p, x)$ 是其三个参数的一个部分可计算函数。\n\n根据 s-m-n 定理，存在一个全可计算函数，我们称之为 $b$，使得对于所有 $n, p, x \\in \\mathbb{N}$，我们有 $\\phi_{b(n,p)}(x) = \\Psi(n,p,x)$。代入我们对 $\\Psi$ 的定义，得到 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$。\n\n问题指出，我们可以假设底层模型允许将 $n$ 字面地作为一系列无操作指令嵌入到程序 $b(n,p)$ 的代码中。这确保了如果 $(n_1, p_1) \\neq (n_2, p_2)$，那么得到的代码 $b(n_1, p_1)$ 和 $b(n_2, p_2)$ 是不同的。因此，函数 $b: \\mathbb{N} \\times \\mathbb{N} \\to \\mathbb{N}$ 是单射的。\n\n3.  **$e_1$ 和 $e_2$ 的构造与分析**\n\n令 $p$ 为第 1 部分中找到的常数零函数的指标。我们使用第 2 部分中的包装函数 $b$ 定义两个新指标 $e_1$ 和 $e_2$：\n$$e_1 = b(3, p)$$\n$$e_2 = b(7, p)$$\n\n首先，我们论证 $\\phi_{e_1} = \\phi_{e_2}$。根据 $b$ 的定义，对于所有的 $n, p, x$，我们有 $\\phi_{b(n,p)}(x) = \\phi_{p}(x)$。\n对于 $e_1$，我们有对于所有 $x$，$\\phi_{e_1}(x) = \\phi_{b(3,p)}(x) = \\phi_{p}(x)$。\n对于 $e_2$，我们有对于所有 $x$，$\\phi_{e_2}(x) = \\phi_{b(7,p)}(x) = \\phi_{p}(x)$。\n因为 $\\phi_{e_1}$ 和 $\\phi_{e_2}$ 都等于同一个函数 $\\phi_p$，所以它们必然彼此相等：$\\phi_{e_1} = \\phi_{e_2}$。\n\n接下来，我们论证 $e_1 \\neq e_2$。函数 $b$ 是单射的。对于 $e_1$ 和 $e_2$，$b$ 的输入分别是数对 $(3, p)$ 和 $(7, p)$。因为 $3 \\neq 7$，所以这两个数对是不同的：$(3, p) \\neq (7, p)$。因为 $b$ 是单射的，它将不同的输入映射到不同的输出。因此，$b(3,p) \\neq b(7,p)$，这意味着 $e_1 \\neq e_2$。\n\n4.  **外延性质 $E(e)$**\n\n性质 $E$ 定义如下：\n$$E(e) = \\begin{cases} 1  \\text{若 } \\forall x \\in \\mathbb{N},\\, \\phi_{e}(x) = 0, \\\\ 0  \\text{其他情况。} \\end{cases}$$\nRice 定理指出，部分可计算函数的任何非平凡外延性质都是不可判定的。要应用该定理，我们必须验证 $E$ 既是外延的又是非平凡的。\n\n- **外延性**：假设 $\\phi_e = \\phi_{e'}$。如果 $\\forall x, \\phi_e(x)=0$，那么也必然有 $\\forall x, \\phi_{e'}(x)=0$。在这种情况下，$E(e) = 1$ 且 $E(e')=1$。如果不是 $\\forall x, \\phi_e(x)=0$ 的情况，那么对于 $\\phi_{e'}$ 也同样不是。在这种情况下，$E(e)=0$ 且 $E(e')=0$。在所有情况下，如果 $\\phi_e = \\phi_{e'}$，那么 $E(e) = E(e')$。因此，$E$ 是一个外延性质。\n\n- **非平凡性**：一个性质是“非平凡的”，如果它对于至少一个函数为真，且对于至少另一个函数为假。在第 1 部分，我们确立了存在一个指标 $p$，使得 $\\phi_p$ 是常数零函数。所以，$E(p) = 1$。现在考虑一个处处无定义的函数。该函数的指标可以是一个立即进入无限循环的程序，我们称这个指标为 $u$。由于 $\\phi_u$ 不是常数零函数，所以 $E(u) = 0$。因为该性质对某些指标成立而对另一些不成立，所以它是非平凡的。\n\n由于 $E$ 是一个非平凡的外延性质，Rice 定理意味着 $E$ 是不可判定的。\n\n最后，我们验证 $E(e_1) = E(e_2)$。从第 3 部分，我们知道 $\\phi_{e_1} = \\phi_{e_2} = \\phi_p$。由于 $\\phi_p$ 是常数零函数，$\\phi_{e_1}$ 和 $\\phi_{e_2}$ 也都是常数零函数。根据 $E$ 的定义，这意味着 $E(e_1) = 1$ 和 $E(e_2) = 1$。因此，$E(e_1) = E(e_2)$。\n\n5.  **语法性质 $S(e)$**\n\n对于第 1 部分中的固定指标 $p$，性质 $S$ 定义如下：\n$$S(e) = \\begin{cases} n  \\text{若对于某个 } n \\in \\mathbb{N}，e = b(n,p), \\\\ 0  \\text{其他情况。} \\end{cases}$$\n我们必须证明 $S$ 是可判定的。要计算给定输入 $e$ 的 $S(e)$，我们需要一个总是停机的算法。$S$ 的定义基于指标 $e$ 是否具有特定的语法结构，即由包装函数 $b(n,p)$ 产生的结构。\n\n函数 $b$ 是全可计算的。指标 $p$ 是一个固定的常数。一个判定 $S(e)$ 的算法可以设计如下：\n给定一个输入指标 $e$，我们可以分析其代码结构。我们可以检查机器 $e$ 的代码是否以一个无操作指令块开始，以及代码的其余部分是否实现了对已知指标 $p$ 的机器的模拟。这种结构分析或“反编译”是一个对程序代码的语法而不是其行为进行操作的有限过程。\n形式上，算法如下：\n1.  解析具有代码 $e$ 的图灵机的描述。\n2.  检查它是否匹配模板“一个无操作指令序列，后跟一个通用图灵机模拟机器 $p$ 的代码”。\n3.  如果不匹配此模板，则停机并输出 $0$。\n4.  如果匹配，则计算前导无操作指令的数量，令此数量为 $n$。停机并输出 $n$。\n\n这个过程总是终止的，因为它是在给定代码 $e$ 的结构上进行的有限检查。因此，函数 $S(e)$ 是可计算的，这意味着性质 $S$ 是可判定的。\n\n接下来，我们证明 $S(e_1) \\neq S(e_2)$。\n对于 $e_1 = b(3, p)$，输入 $e_1$ 满足条件 $e = b(n,p)$，其中 $n=3$。根据 $S$ 的定义，我们有 $S(e_1) = 3$。\n对于 $e_2 = b(7, p)$，输入 $e_2$ 满足条件 $e = b(n,p)$，其中 $n=7$。根据 $S$ 的定义，我们有 $S(e_2) = 7$。\n因为 $3 \\neq 7$，所以我们有 $S(e_1) \\neq S(e_2)$。这突显了 $S$ 是一个语法性质，因为它可以区分两个不同的程序（$e_1 \\neq e_2$），即使它们计算完全相同的函数（$\\phi_{e_1} = \\phi_{e_2}$）。\n\n**最终计算**\n\n我们被要求计算 $F$ 的值：\n$$F = E(e_{1}) + E(e_{2}) + \\big|S(e_{1}) - S(e_{2})\\big|$$\n使用我们在前面部分中导出的值：\n- 从第 4 部分， $E(e_1) = 1$。\n- 从第 4 部分， $E(e_2) = 1$。\n- 从第 5 部分， $S(e_1) = 3$。\n- 从第 5 部分， $S(e_2) = 7$。\n\n将这些值代入 $F$ 的表达式：\n$$F = 1 + 1 + |3 - 7|$$\n$$F = 2 + |-4|$$\n$$F = 2 + 4$$\n$$F = 6$$\n最终值为 $6$。", "answer": "$$\\boxed{6}$$", "id": "2982151"}]}