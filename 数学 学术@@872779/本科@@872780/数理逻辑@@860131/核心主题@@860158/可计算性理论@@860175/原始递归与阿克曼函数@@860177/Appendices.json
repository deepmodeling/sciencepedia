{"hands_on_practices": [{"introduction": "要理解一个函数类别（如原始递归函数）的边界，我们首先需要牢固掌握哪些函数属于该类别。斐波那契数列是一个经典的递归例子，但它的定义 $F_{n+1} = F_n + F_{n-1}$ 依赖于前两项，不直接符合原始递归的模式。这个练习将指导你如何通过状态编码这一关键技巧——将多个状态（如 $F_n$ 和 $F_{n+1}$）打包成一个单一数字——来形式化地证明斐波那契函数是原始递归的。[@problem_id:3049701] 这个实践将让你亲手体验原始递归的严谨定义，并掌握将复杂递归关系转化为原始递归形式的强大方法。", "problem": "令 $\\mathbb{N}$ 表示包含 $0$ 的自然数集合。在原始递归的框架下，一个函数被称为原始递归（PR）函数，如果它可以由初始函数——零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 和投影函数 $P^{n}_{i}(x_{0},\\dots,x_{n-1})=x_{i}$——通过有限次复合和原始递归模式得到：给定函数 $f$ 和 $g$，由 $h(0,\\vec{x})=f(\\vec{x})$ 和 $h(n+1,\\vec{x})=g(n,h(n,\\vec{x}),\\vec{x})$ 定义的函数 $h$是原始递归的。\n\n你的任务是仅使用从初始函数开始的PR定义，构造一个PR函数 $\\mathrm{Fib}:\\mathbb{N}\\to\\mathbb{N}$，它将 $n$ 映射到第 $n$ 个斐波那契数 $F_{n}$，其中 $F_{0}=0$，$F_{1}=1$，且对于所有 $n\\geq 1$ 都有 $F_{n+1}=F_{n}+F_{n-1}$。你必须通过对 $n$ 的有界递归来完成此任务，并使用一种对偶累积编码来表示状态，其中有序对 $(a,b)$被编码为单个自然数\n$$E(a,b)=2^{a}\\cdot 3^{b}。$$\n具体来说：\n- 从第一性原理出发，定义实现对偶在 $E$ 下编码和解码所需的辅助PR函数，包括幂运算 $p^{k}$、相等性测试、有界可除性谓词，以及分别返回能整除 $m$ 的 $2$ 和 $3$ 的最大指数的素数指数函数 $v_{2}(m)$ 和 $v_{3}(m)$。\n- 定义一个作用于编码的PR更新函数 $U$，对于给定的 $e=E(a,b)$，它返回下一个编码 $E(b,a+b)$，且不脱离PR框架。\n- 通过对 $n$ 的原始递归定义一个PR函数 $G$，其基例为 $G(0)=E(F_{0},F_{1})$，递归步骤为 $G(n+1)=U(G(n))$，并令 $\\mathrm{Fib}(n)=v_{2}(G(n))$。\n- 在每一步中，证明所构造的函数是PR的，并且 $G(n)$ 的语义对应于期望的数对 $(F_{n},F_{n+1})$。\n\n最后，计算 $\\mathrm{Fib}(9)$。將你的最终答案以单个整数形式给出。不需要四舍五入。", "solution": "问题要求将斐波那契函数构造为一个原始递归（PR）函数，从初始PR函数出发，并仅使用复合和原始递归模式。指定的方法涉及对数对进行编码，并在这些编码上定义一个递归函数。我们将首先构建必要的辅助PR函数，然后构造主函数，证明其性质，最后计算所需的值。\n\n**1. 基础原始递归函数**\n\n初始函数是零函数 $Z(x)=0$、后继函数 $S(x)=x+1$ 和投影函数 $P^{n}_{i}(\\vec{x}) = x_i$。所有其他PR函数都是由这些函数构建的。\n\n- **加法**：$\\mathrm{add}(x,y)$，记作 $x+y$。\n  $\\mathrm{add}(x,0) = x$\n  $\\mathrm{add}(x, S(y)) = S(\\mathrm{add}(x,y))$\n  这是原始递归模式的一个应用，因此加法是PR的。\n\n- **乘法**：$\\mathrm{mult}(x,y)$，记作 $x \\cdot y$。\n  $\\mathrm{mult}(x,0) = 0$\n  $\\mathrm{mult}(x, S(y)) = \\mathrm{add}(x, \\mathrm{mult}(x,y))$\n  这是PR的，因为它通过递归定义，并使用了已经建立的PR函数——加法。\n\n- **幂运算**：$\\mathrm{expn}(x,y)$，记作 $x^y$。\n  $\\mathrm{expn}(x,0) = S(Z(x)) = 1$\n  $\\mathrm{expn}(x, S(y)) = \\mathrm{mult}(x, \\mathrm{expn}(x,y))$\n  这是PR的，通过递归并使用乘法来定义。\n\n- **前驱**：$\\mathrm{pred}(x)$。\n  $\\mathrm{pred}(0) = 0$\n  $\\mathrm{pred}(S(x)) = x$\n  这通过递归模式是PR的。\n\n- **真减法**：$\\mathrm{sub}(x,y)$，记作 $x-y$。如果 $x \\ge y$，它返回 $x-y$；否则返回 $0$。\n  $\\mathrm{sub}(x,0) = x$\n  $\\mathrm{sub}(x, S(y)) = \\mathrm{pred}(\\mathrm{sub}(x,y))$\n  这是PR的，通过递归并使用前驱函数来定义。\n\n**2. 原始递归谓词和有界运算**\n\n谓词由其特征函数表示，真时返回 $1$，假时返回 $0$。\n\n- **符号函数（非零的特征函数）**：$\\mathrm{sg}(x)$。\n  $\\mathrm{sg}(0) = 0$\n  $\\mathrm{sg}(x+1) = 1$\n  这是PR的。\n\n- **零测试（零的特征函数）**：$\\mathrm{is\\_zero}(x)$。\n  $\\mathrm{is\\_zero}(x) = 1 - \\mathrm{sg}(x)$。这是一个PR函数的复合，因此是PR的。\n\n- **相等性测试**：$\\mathrm{eq}(x,y)$。\n  两个数 $x$ 和 $y$ 相等当且仅当 $x-y=0$ 和 $y-x=0$ 都成立。\n  $\\mathrm{eq}(x,y) = \\mathrm{is\\_zero}((x-y) + (y-x))$。这是一个PR函数的复合，因此是PR的。\n\n- **有界和与有界积**：如果 $f(i, \\vec{z})$ 是一个PR函数，那么有界和 $g(y, \\vec{z}) = \\sum_{i=0}^{y} f(i, \\vec{z})$ 和有界积 $h(y, \\vec{z}) = \\prod_{i=0}^{y} f(i, \\vec{z})$ 也是PR的，因为它们可以通过原始递归来定义。\n\n- **有界可除性谓词**：$\\mathrm{divides}(d,n)$。如果 $d|n$ 且 $d \\neq 0$，此函数为 $1$，否则为 $0$。为简单起见，我们假设 $d>0$，将 $d=0$ 作为特殊情况处理。陈述“$d$ 整除 $n$”等价于“存在一个 $k$，$0 \\le k \\le n$，使得 $n = d \\cdot k$”。\n  这个有界存在量化的特征函数 $(\\exists k \\le n)[\\mathrm{eq}(n, d \\cdot k)=1]$ 可以定义为 $\\mathrm{sg}(\\sum_{k=0}^{n} \\mathrm{eq}(n, d \\cdot k))$。由于 $\\mathrm{eq}$、乘法和有界和都是PR的，它们的复合函数 $\\mathrm{divides}(d,n)$ 也是PR的。\n\n- **有界最大化**：如果 $f(i)$ 是一个PR函数，那么 $g(y) = \\max_{i=0}^{y} f(i)$ 也是PR的。它可以由递归 $g(0) = f(0)$ 和 $g(y+1) = \\max(g(y), f(y+1))$ 定义，其中 $\\max(a,b) = a+(b-a)$ 是一个PR函数。\n\n**3. 编码和解码函数**\n\n问题指定了有序对 $(a,b)$ 的编码函数为 $E(a,b) = 2^a \\cdot 3^b$。解码函数 $v_{2}(m)$ 和 $v_{3}(m)$ 从整数 $m$ 中提取素数 $2$ 和 $3$ 的指数。\n\n- **素数指数函数**：$v_p(m)$ 是使得 $p^k$ 整除 $m$ 的最大整数 $k$。如果 $m=0$，$v_p(0)=0$。对于 $m>0$，$p^k \\le m$，这意味着 $k \\le m$。因此，对 $k$ 的搜索是有界的，其上界为 $m$。\n  我们定义一个辅助函数 $H(k,m,p) = k \\cdot \\mathrm{divides}(p^k, m)$。这个函数是PR的。如果 $p^k|m$，它等于 $k$，否则等于 $0$。\n  那么，$v_p(m) = \\max_{k=0}^{m} H(k,m,p)$。由于这是一个PR函数的有界最大化，所以 $v_p(m)$ 是PR的。\n  具体而言，所需的解码函数是：\n  $v_2(m) = \\max_{k=0}^{m} \\{ k \\cdot \\mathrm{divides}(2^k, m) \\}$。\n  $v_3(m) = \\max_{k=0}^{m} \\{ k \\cdot \\mathrm{divides}(3^k, m) \\}$。\n  $v_2(m)$ 和 $v_3(m)$ 都是PR的。\n\n**4. 斐波那契函数的递归构造**\n\n现在我们使用已开发的工具来构造斐波那契函数。递归的状态需要前两个斐波那契数 $(F_n, F_{n+1})$，它被存储在一个单一的整数编码中。\n\n- **更新函数 $U$**：此函数接受一个编码 $e = E(a,b) = 2^a \\cdot 3^b$ 并返回下一个状态的编码，$E(b, a+b) = 2^b \\cdot 3^{a+b}$。\n  为了计算这个，我们首先解码 $e$：$a = v_2(e)$ 和 $b = v_3(e)$。\n  然后我们计算新的指数：新的以2为底的指数是 $b=v_3(e)$，新的以3为底的指数是 $a+b = v_2(e)+v_3(e)$。\n  因此，更新函数是 $U(e) = 2^{v_3(e)} \\cdot 3^{v_2(e) + v_3(e)}$。\n  由于 $v_2$、$v_3$、加法和幂运算都是PR的，它们的复合函数 $U(e)$ 也是一个PR函数。\n\n- **状态函数 $G$**：此函数迭代地应用更新函数 $U$。它由原始递归定义。\n  基例：$G(0) = E(F_0, F_1) = E(0,1) = 2^0 \\cdot 3^1 = 3$。这是一个常数函数，是PR的。\n  递归步骤：$G(n+1) = U(G(n))$。\n  这符合原始递归模式 $h(n+1) = g(n, h(n))$，其中 $g(n,y) = U(y)$ 是PR的。因此，$G(n)$ 是一个PR函数。\n\n- **$G(n)$ 的正确性**：我们通过归纳法证明 $G(n) = E(F_n, F_{n+1}) = 2^{F_n} \\cdot 3^{F_{n+1}}$。\n  基例 ($n=0$)：$G(0) = 3 = 2^0 \\cdot 3^1 = E(0,1) = E(F_0, F_1)$。性质成立。\n  归纳步骤：假设对于某个 $k \\ge 0$，$G(k) = E(F_k, F_{k+1})$。\n  我们必须证明 $G(k+1) = E(F_{k+1}, F_{k+2})$。\n  根据定义，$G(k+1) = U(G(k))$。\n  使用归纳假设，$G(k) = 2^{F_k} \\cdot 3^{F_{k+1}}$。\n  由此，我们有 $v_2(G(k)) = F_k$ 和 $v_3(G(k)) = F_{k+1}$。\n  应用 $U$ 的定义：\n  $G(k+1) = U(G(k)) = 2^{v_3(G(k))} \\cdot 3^{v_2(G(k)) + v_3(G(k))} = 2^{F_{k+1}} \\cdot 3^{F_k + F_{k+1}}$。\n  根据斐波那契数列的定义，$F_{k+2} = F_{k+1} + F_k$。\n  因此，$G(k+1) = 2^{F_{k+1}} \\cdot 3^{F_{k+2}} = E(F_{k+1}, F_{k+2})$。\n  性质对 $k+1$ 成立。根据归纳原理，$G(n)$ 的公式对所有 $n \\in \\mathbb{N}$ 都成立。\n\n- **斐波那契函数 $\\mathrm{Fib}(n)$**：该函数定义为 $\\mathrm{Fib}(n) = v_2(G(n))$。\n  因为我们已经证明了 $G(n) = 2^{F_n} \\cdot 3^{F_{n+1}}$，所以可得：\n  $\\mathrm{Fib}(n) = v_2(G(n)) = v_2(2^{F_n} \\cdot 3^{F_{n+1}}) = F_n$。\n  函数 $\\mathrm{Fib}(n)$ 是PR函数 $G$ 和 $v_2$ 的复合，因此它是一个正确计算第 $n$ 个斐波那契数的PR函数。\n\n**5. 最终计算**\n\n问题要求计算 $\\mathrm{Fib}(9)$。根据我们的构造，这等同于求第9个斐波那契数 $F_9$。\n$F_0 = 0$\n$F_1 = 1$\n$F_2 = F_1 + F_0 = 1+0=1$\n$F_3 = F_2 + F_1 = 1+1=2$\n$F_4 = F_3 + F_2 = 2+1=3$\n$F_5 = F_4 + F_3 = 3+2=5$\n$F_6 = F_5 + F_4 = 5+3=8$\n$F_7 = F_6 + F_5 = 8+5=13$\n$F_8 = F_7 + F_6 = 13+8=21$\n$F_9 = F_8 + F_7 = 21+13=34$\n\n因此，$\\mathrm{Fib}(9) = 34$。", "answer": "$$\\boxed{34}$$", "id": "3049701"}, {"introduction": "了解了原始递归函数的构造方式后，我们现在转向阿克曼函数，它是一个著名的、超越了原始递归函数类的可计算函数。在深入探讨其非原始递归性之前，我们必须首先熟悉它的定义和行为。这个练习要求你直接应用阿克曼函数 $A(m, n)$ 的嵌套递归定义，为 $m$ 的前几个值推导出其封闭形式。[@problem_id:3049711] 通过为 $A(0, n)$、$A(1, n)$ 和 $A(2, n)$ 找到具体的表达式，你将直观地感受到其复杂性是如何逐级递增的，为理解其惊人增长率和最终超越任何原始递归函数的原因打下基础。", "problem": "设 $\\mathbb{N}=\\{0,1,2,\\dots\\}$。考虑由以下基本子句定义的二元 Ackermann–Péter 函数 $A:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$：\n$$\nA(0,n)=n+1,\\quad A(m+1,0)=A(m,1),\\quad A(m+1,n+1)=A\\bigl(m,\\,A(m+1,n)\\bigr),\n$$\n对所有 $m,n\\in\\mathbb{N}$ 成立。请仅使用这些子句，并在适当时对 $n$ 进行归纳，推导三个一元函数 $n\\mapsto A(0,n)$、$n\\mapsto A(1,n)$ 和 $n\\mapsto A(2,n)$ 关于 $n$ 的显式闭式解，并通过基于给定定义方程的完整归纳论证来验证每个解。将您的最终结果表示为行矩阵 $\\bigl(A(0,n)\\;A(1,n)\\;A(2,n)\\bigr)$，形式为不含自由参数的关于 $n$ 的闭式表达式。不需要数值近似。", "solution": "任务是基于 Ackermann-Péter 函数 $A:\\mathbb{N}\\times\\mathbb{N}\\to\\mathbb{N}$ 的定义子句，找到并验证函数 $n \\mapsto A(0,n)$、$n \\mapsto A(1,n)$ 和 $n \\mapsto A(2,n)$ 的闭式表达式，其中 $\\mathbb{N}=\\{0,1,2,\\dots\\}$。定义子句如下：\n$$\n\\begin{align*}\nA(0,n) = n+1 \\quad (1) \\\\\nA(m+1,0) = A(m,1) \\quad (2) \\\\\nA(m+1,n+1) = A\\bigl(m,\\,A(m+1,n)\\bigr) \\quad (3)\n\\end{align*}\n$$\n我们将依次处理 $m=0, 1, 2$ 的每种情况。\n\n**情况 1：$A(0,n)$ 的推导与验证**\n\n$A(0,n)$ 的闭式解由定义中的子句 (1) 明确给出：\n$$\nA(0,n) = n+1\n$$\n根据定义，此方程对所有 $n \\in \\mathbb{N}$ 成立。问题要求通过完整的归纳论证进行验证。然而，由于待证明的性质 $P(n): A(0,n)=n+1$ 本身就是该函数对所有 $n$ 定义的基础子句，因此通过归纳法证明会成为一个重言式。根据公理，该公式对所有 $n \\in \\mathbb{N}$ 均成立，无需进一步验证。\n\n**情况 2：$A(1,n)$ 的推导与验证**\n\n我们寻求 $A(1,n)$ 的一个闭式解。首先，我们建立 $A(1,n)$ 关于 $n$ 的递推关系。使用子句 (3) 并令 $m=0$：\n$$\nA(1,n+1) = A(0, A(1,n))\n$$\n根据 $m=0$ 的结果，我们知道对任何 $x \\in \\mathbb{N}$ 都有 $A(0,x) = x+1$。代入 $x=A(1,n)$，我们得到：\n$$\nA(1,n+1) = A(1,n) + 1\n$$\n这是一个一阶线性递推关系。为找到唯一解，我们需要 $n=0$ 时的基本情况。使用子句 (2) 并令 $m=0$：\n$$\nA(1,0) = A(0,1)\n$$\n使用 $A(0,n)$ 的公式，我们得到 $A(0,1) = 1+1=2$。因此，基本情况是 $A(1,0)=2$。\n展开递推关系 $A(1,n+1) = A(1,n)+1$：\n$$\nA(1,n) = A(1,n-1)+1 = A(1,n-2)+2 = \\dots = A(1,0) + n\n$$\n代入基本情况 $A(1,0)=2$，我们推导出闭式解：\n$$\nA(1,n) = n+2\n$$\n现在，我们按要求对 $n$ 进行归纳来验证此结果。设 $P(n)$ 为命题 $A(1,n)=n+2$。\n\n**基本情况 ($n=0$)：**\n我们必须证明 $P(0)$ 为真，即 $A(1,0)=0+2=2$。\n根据子句 (2) 并令 $m=0$，有 $A(1,0)=A(0,1)$。\n根据子句 (1) 并令 $n=1$，有 $A(0,1)=1+1=2$。\n因此 $A(1,0)=2$，基本情况成立。\n\n**归纳假设：**\n假设对某个任意的 $k \\in \\mathbb{N}$，$P(k)$ 为真，即 $A(1,k)=k+2$。\n\n**归纳步骤：**\n我们必须证明 $P(k+1)$ 为真，即 $A(1,k+1)=(k+1)+2=k+3$。\n根据子句 (3) 并令 $m=0$ 和 $n=k$：\n$$\nA(1,k+1) = A(0, A(1,k))\n$$\n应用归纳假设 $A(1,k)=k+2$，我们得到：\n$$\nA(1,k+1) = A(0, k+2)\n$$\n根据子句 (1)，我们知道 $A(0,x)=x+1$。令 $x=k+2$：\n$$\nA(1,k+1) = (k+2)+1 = k+3\n$$\n这样就完成了归纳步骤。根据数学归纳法原理，$A(1,n)=n+2$ 对所有 $n \\in \\mathbb{N}$ 成立。\n\n**情况 3：$A(2,n)$ 的推导与验证**\n\n我们对 $A(2,n)$ 进行类似处理。我们使用子句 (3) 并令 $m=1$ 来建立一个递推关系：\n$$\nA(2,n+1) = A(1, A(2,n))\n$$\n根据我们对 $m=1$ 验证过的结果，我们知道 $A(1,x) = x+2$。代入 $x=A(2,n)$：\n$$\nA(2,n+1) = A(2,n) + 2\n$$\n这是另一个一阶线性递推关系。使用子句 (2) 并令 $m=1$ 来找到 $n=0$ 时的基本情况：\n$$\nA(2,0) = A(1,1)\n$$\n使用 $A(1,n)$ 的公式，我们得到 $A(1,1)=1+2=3$。因此，基本情况是 $A(2,0)=3$。\n展开递推关系 $A(2,n+1) = A(2,n)+2$：\n$$\nA(2,n) = A(2,n-1)+2 = A(2,n-2)+2\\cdot 2 = \\dots = A(2,0) + n\\cdot 2\n$$\n代入基本情况 $A(2,0)=3$，我们推导出闭式解：\n$$\nA(2,n) = 2n+3\n$$\n现在，我们对 $n$ 进行归纳来验证此结果。设 $Q(n)$ 为命题 $A(2,n)=2n+3$。\n\n**基本情况 ($n=0$)：**\n我们必须证明 $Q(0)$ 为真，即 $A(2,0)=2(0)+3=3$。\n根据子句 (2) 并令 $m=1$，有 $A(2,0)=A(1,1)$。\n根据我们已证明的 $A(1,n)$ 公式，有 $A(1,1)=1+2=3$。\n因此 $A(2,0)=3$，基本情况成立。\n\n**归纳假设：**\n假设对某个任意的 $k \\in \\mathbb{N}$，$Q(k)$ 为真，即 $A(2,k)=2k+3$。\n\n**归纳步骤：**\n我们必须证明 $Q(k+1)$ 为真，即 $A(2,k+1)=2(k+1)+3=2k+5$。\n根据子句 (3) 并令 $m=1$ 和 $n=k$：\n$$\nA(2,k+1) = A(1, A(2,k))\n$$\n应用归纳假设 $A(2,k)=2k+3$，我们得到：\n$$\nA(2,k+1) = A(1, 2k+3)\n$$\n根据我们已证明的 $A(1,n)$ 公式，我们知道 $A(1,x)=x+2$。令 $x=2k+3$：\n$$\nA(2,k+1) = (2k+3)+2 = 2k+5\n$$\n这样就完成了归纳步骤。根据数学归纳法原理，$A(2,n)=2n+3$ 对所有 $n \\in \\mathbb{N}$ 成立。\n\n总之，闭式表达式为 $A(0,n)=n+1$、$A(1,n)=n+2$ 和 $A(2,n)=2n+3$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nn+1 & n+2 & 2n+3\n\\end{pmatrix}\n}\n$$", "id": "3049711"}, {"introduction": "理论联系实践是加深理解的最佳途径。最后的这个练习将为你搭建一座桥梁，连接原始递归的抽象定义与具体的计算机编程。你将实现一个程序，它能解释并计算任何通过原始递归的构造规则所定义的函数。[@problem_id:3049723] 通过将函数表示为数据结构（表达式树），你的程序将模拟原始递归的形式演算，同时你也会独立实现阿克曼函数。这个编程挑战不仅能巩固你对原始递归函数结构的理解，更重要的是，通过构建两种不同的计算器，你将具体地感受到阿克曼函数虽然完全可计算，但其递归结构却无法被原始递归的有限迭代模式所捕捉。", "problem": "您需要实现对自然数 $\\mathbb{N}$（其中 $\\mathbb{N}$ 包含 $0$）上编码的原始递归（PR）函数的求值。该实现必须遵循原始递归及其基本构建块的基础定义，从基本原理出发。您的程序必须使用一个有限构造器树来编码PR函数，并在给定的小输入上对这些编码进行求值。您还必须包含一个独立的阿克曼函数求值器，以突显其与原始递归的区别，并在小输入上计算其值。\n\n需要实现的定义和语义：\n- 基本函数：\n  - 元数为 $k$ 的零函数 $Z_k$ 是 $Z_k(x_1,\\dots,x_k) = 0$。\n  - 后继函数 $S$ 是一个一元函数 $S(n) = n + 1$。\n  - 元数为 $k$ 的投影函数 $U_i^k$ 是 $U_i^k(x_1,\\dots,x_k) = x_i$，其中 $1 \\leq i \\leq k$。\n- 复合：如果 $f$ 是一个 $m$ 元函数，$g_1,\\dots,g_m$ 是 $n$ 元函数，那么复合 $\\mathrm{Comp}(f; g_1,\\dots,g_m)$ 是一个 $n$ 元函数\n  $$\\mathrm{Comp}(f; g_1,\\dots,g_m)(\\vec{x}) = f\\big(g_1(\\vec{x}),\\dots,g_m(\\vec{x})\\big),$$\n  其中 $\\vec{x} = (x_1,\\dots,x_n)$。\n- 原始递归：给定一个 $k$ 元基函数 $f$ 和一个 $(k+2)$ 元步进函数 $g$，原始递归 $\\mathrm{PrimRec}(f,g)$ 定义了一个 $(k+1)$ 元函数 $h$：\n  $$h(0,\\vec{x}) = f(\\vec{x}), \\quad h(n+1,\\vec{x}) = g\\big(n, h(n,\\vec{x}), \\vec{x}\\big),$$\n  其中 $\\vec{x} = (x_1,\\dots,x_k)$。\n\n编码方案要求：\n- 每个函数由一个编码表示，该编码是一个有限树，其节点标签是构造器 $\\{Z_k, S, U_i^k, \\mathrm{Comp}, \\mathrm{PrimRec}\\}$ 之一，并带有适当的参数，其子树对应于 $\\mathrm{Comp}$ 和 $\\mathrm{PrimRec}$ 的参数。\n- 求值的语义必须严格遵循上述数学定义。特别地，对于 $\\mathrm{PrimRec}(f,g)$，您的求值器必须通过从基本情况 $n = 0$ 开始，使用步进函数 $g$ 迭代到给定的输入 $n$，来计算 $h(n,\\vec{x})$。\n\n阿克曼函数要求：\n- 为阿克曼函数 $A(m,n)$ 实现一个独立的（非PR编码的）求值器，其定义如下：\n  $$A(0,n) = n + 1, \\quad A(m+1,0) = A(m,1), \\quad A(m+1,n+1) = A\\big(m, A(m+1,n)\\big),$$\n  并在测试套件指定的小输入上计算它。该求值器不属于PR编码方案，必须直接根据上述定义实现。\n\n您的程序必须构建以下由编码函数和输入组成的测试套件，对它们进行求值，并以指定的输出格式生成结果：\n- 测试 1：求值 $Z_3$ 在 $(2,3,5)$ 处的值。\n- 测试 2：求值 $S$ 在 $(0)$ 处的值。\n- 测试 3：求值 $U_2^3$ 在 $(7,4,9)$ 处的值。\n- 测试 4：求值 $\\mathrm{Comp}(S; U_2^2)$ 在 $(5,6)$ 处的值，即二元函数 $(x,y) \\mapsto S(U_2^2(x,y)) = y + 1$。\n- 测试 5：求值 $\\mathrm{Comp}(S; S)$ 在 $(2)$ 处的值，即一元函数 $n \\mapsto S(S(n))$。\n- 测试 6：通过原始递归定义加法 $h = \\mathrm{PrimRec}\\big(U_1^1, \\mathrm{Comp}(S; U_2^3)\\big)$，其中 $h(n,y)$ 计算 $y + n$。求值 $h(3,4)$。\n- 测试 7：求值相同的加法函数 $h(0,9)$ 以检查基本情况的行为。\n- 测试 8：求值多元复合 $\\mathrm{Comp}\\!\\big(U_3^3; Z_2, \\mathrm{Comp}(S; U_1^2), \\mathrm{Comp}(S; U_2^2)\\big)$ 在 $(8,10)$ 处的值，应返回第三个内部组件的值。\n- 测试 9：求值阿克曼函数 $A(2,2)$。\n- 测试 10：求值阿克曼函数 $A(3,2)$。\n\n设计约束：\n- 所有函数都在 $\\mathbb{N}$ 上操作，所有输入和输出都是 $\\mathbb{N}$ 中的整数。\n- 您的程序必须实现一个PR编码的求值器和一个阿克曼函数的直接求值器。\n- 您的程序必须在求值期间确保元数一致性，如果编码格式错误，则应引发错误或明确失败；对于提供的测试套件，所有编码都必须是格式正确的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，例如 $$[r_1,r_2,\\dots,r_{10}]$$ 其中每个 $r_i$ 是第 $i$ 个测试的整数结果。不允许有任何额外输出。\n\n预期的输出是数学整数，不带任何物理单位、角度或百分比。结果必须以指定的精确单行格式提供。", "solution": "用户的要求是创建一个程序来求值原始递归（PR）函数和阿克曼函数。该问题定义明确，数学上合理，并且对于给定的测试用例在计算上是可行的。我将继续提供一个完整的解决方案。\n\n该解决方案围绕两个主要组件构建：一个用于表示为表达式树的PR函数的求值器，以及一个用于阿克曼函数的直接递归求值器。\n\n**1. 表示和求值原始递归函数**\n\n原始递归函数是通过对一组有限的基本函数进行有限次的复合和原始递归应用而构建的。这种组合结构自然地映射到一个抽象语法树（AST）。本实现采用面向对象的方法，其中AST中的每个节点都是一个特定类的对象。\n\n一个抽象基类 `PRFunction` 建立了一个通用接口，主要是一个接受参数元组的 `evaluate` 方法。为每个基本函数和构造器定义了具体类：\n\n- `Zero(k)`: 表示零函数 $Z_k(x_1, \\dots, x_k) = 0$。其 `evaluate` 方法在验证输入具有正确的元数 $k$ 后返回 $0$。\n- `Successor()`: 表示后继函数 $S(n) = n + 1$。其 `evaluate` 方法返回其单个参数加 $1$。其元数固定为 $1$。\n- `Projection(i, k)`: 表示投影函数 $U_i^k(x_1, \\dots, x_k) = x_i$。它使用索引 $i$（其中 $1 \\leq i \\leq k$）和元数 $k$ 进行初始化。其 `evaluate` 方法返回输入元组中第 $(i-1)$ 个位置的参数（使用基于 $0$ 的索引）。\n- `Composition(f, gs)`: 表示复合 $\\mathrm{Comp}(f; g_1, \\dots, g_m)$。它使用一个外部函数对象 $f$ 和一个内部函数对象列表 `gs` = $[g_1, \\dots, g_m]$ 进行初始化。复合函数的元数是内部函数 $g_j$ 的公共元数 $n$。`evaluate` 方法在给定长度为 $n$ 的参数向量 $\\vec{x}$ 时，首先通过求值每个 $g_j(\\vec{x})$ 来计算一个中间结果向量。然后将这些结果作为参数传递给外部函数 $f$。在构造时会检查元数一致性：所有 $g_j$ 必须具有相同的元数，并且 $f$ 的元数必须等于内部函数的数量 $m$。\n- `PrimitiveRecursion(f, g)`: 表示由 $h(0, \\vec{x}) = f(\\vec{x})$ 和 $h(n+1, \\vec{x}) = g(n, h(n, \\vec{x}), \\vec{x})$ 定义的函数 $h = \\mathrm{PrimRec}(f, g)$。它使用一个元数为 $k$ 的基函数 $f$ 和一个元数为 $k+2$ 的步进函数 $g$ 进行初始化。结果函数 $h$ 的元数为 $k+1$。根据问题要求，$h(n, \\vec{x})$ 的求值是迭代实现的，而非递归。对于输入 $(n, x_1, \\dots, x_k)$，如果 $n=0$，它返回 $f(\\vec{x})$。如果 $n>0$，它首先计算基本情况的值 $v_0 = f(\\vec{x})$。然后进入一个从 $i=0$ 到 $n-1$ 的循环。在每次迭代 $i$ 中，它计算下一个值 $v_{i+1} = g(i, v_i, \\vec{x})$。最后返回最终值 $v_n$。\n\n**2. 求值阿克曼函数**\n\n阿克曼函数 $A(m,n)$ 不是原始递归的。一个独立的求值器被实现为一个标准的 Python 函数 `ackermann(m, n)`，它直接遵循其递归定义。问题陈述中给出的定义是阿克曼-佩特（Ackermann-Péter）函数的一种标准形式：\n$$\nA(m, n) = \\begin{cases}\nn + 1 & \\text{若 } m = 0 \\\\\nA(m-1, 1) & \\text{若 } m > 0 \\text{ 且 } n = 0 \\\\\nA(m-1, A(m, n-1)) & \\text{若 } m > 0 \\text{ 且 } n > 0\n\\end{cases}\n$$\n由于其计算中存在大量的重复子问题，记忆化对于效率至关重要。使用一个字典作为缓存来存储 `ackermann(m, n)` 的结果。在计算一个值之前，会检查缓存。如果结果存在，则立即返回，避免重复计算。\n\n**3. 测试套件执行**\n\n主函数 `solve` 协调测试过程。对于 10 个测试用例中的每一个，它执行以下操作：\n1.  对于PR函数测试（测试 1 到 8），它通过实例化上面定义的类来构造相应的 AST。\n2.  它使用指定的输入元组调用根对象的 `evaluate` 方法。\n3.  对于阿克曼函数测试（测试 9 和 10），它使用指定的整数参数调用 `ackermann` 函数。\n4.  每个测试的整数结果被收集到一个列表中。\n5.  最后，这个结果列表被格式化为所需的字符串 `\"[r_1,r_2,...,r_10]\"` 并打印到标准输出。\n\n这种方法论确保了一个严谨和正确的实现，遵循了问题陈述所要求的基本原理方法。手动验证的结果是：$0$, $1$, $4$, $7$, $4$, $7$, $9$, $11$, $7$, $29$。这些将由程序执行来确认。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\nackermann_cache = {}\n\ndef ackermann(m, n):\n    \"\"\"\n    Evaluates the Ackermann function A(m, n) with memoization.\n    The definition used is the standard Ackermann-Péter function:\n    A(0, n) = n + 1\n    A(m > 0, 0) = A(m - 1, 1)\n    A(m > 0, n > 0) = A(m - 1, A(m, n - 1))\n    \"\"\"\n    if (m, n) in ackermann_cache:\n        return ackermann_cache[(m, n)]\n    \n    if m == 0:\n        result = n + 1\n    elif m > 0 and n == 0:\n        result = ackermann(m - 1, 1)\n    elif m > 0 and n > 0:\n        # Note: The problem defines A(m+1, n+1) = A(m, A(m+1, n)).\n        # This is equivalent to A(m, n) = A(m-1, A(m, n-1)) for m, n > 0.\n        result = ackermann(m - 1, ackermann(m, n - 1))\n    else:\n        # Should not happen for natural number inputs\n        raise ValueError(\"Invalid arguments for Ackermann function\")\n\n    ackermann_cache[(m, n)] = result\n    return result\n\nclass PRFunction:\n    \"\"\"Abstract base class for a primitive recursive function.\"\"\"\n    def get_arity(self) -> int:\n        raise NotImplementedError(\"Subclasses must implement get_arity\")\n\n    def evaluate(self, args: tuple) -> int:\n        \"\"\"Public evaluation method with arity check.\"\"\"\n        expected_arity = self.get_arity()\n        if len(args) != expected_arity:\n            raise ValueError(\n                f\"Arity mismatch for {self.__class__.__name__}: \"\n                f\"expected {expected_arity}, got {len(args)}\"\n            )\n        return self._evaluate(args)\n\n    def _evaluate(self, args: tuple) -> int:\n        \"\"\"Protected evaluation method for subclasses to implement logic.\"\"\"\n        raise NotImplementedError(\"Subclasses must implement _evaluate\")\n\nclass Zero(PRFunction):\n    \"\"\"The zero function Z_k.\"\"\"\n    def __init__(self, k: int):\n        if k  0: raise ValueError(\"Arity k must be non-negative.\")\n        self.k = k\n\n    def get_arity(self) -> int:\n        return self.k\n        \n    def _evaluate(self, args: tuple) -> int:\n        return 0\n\nclass Successor(PRFunction):\n    \"\"\"The successor function S.\"\"\"\n    def get_arity(self) -> int:\n        return 1\n        \n    def _evaluate(self, args: tuple) -> int:\n        return args[0] + 1\n        \nclass Projection(PRFunction):\n    \"\"\"The projection function U_i^k.\"\"\"\n    def __init__(self, i: int, k: int):\n        if not (1 = i = k):\n            raise ValueError(f\"Projection index i must be 1 = i = k ({i}, {k})\")\n        self.i = i\n        self.k = k\n        \n    def get_arity(self) -> int:\n        return self.k\n        \n    def _evaluate(self, args: tuple) -> int:\n        return args[self.i - 1]\n\nclass Composition(PRFunction):\n    \"\"\"The composition constructor Comp(f; g_1, ..., g_m).\"\"\"\n    def __init__(self, f: PRFunction, gs: list):\n        self.f = f\n        self.gs = gs\n        if not gs:\n            raise ValueError(\"Composition requires at least one inner function.\")\n        \n        n = gs[0].get_arity()\n        if not all(g.get_arity() == n for g in gs):\n            raise ValueError(\"All inner functions in a composition must have the same arity.\")\n        \n        m = f.get_arity()\n        if m != len(gs):\n            raise ValueError(\"Arity of outer function must match number of inner functions.\")\n            \n        self.n = n\n\n    def get_arity(self) -> int:\n        return self.n\n        \n    def _evaluate(self, args: tuple) -> int:\n        intermediate_results = tuple(g.evaluate(args) for g in self.gs)\n        return self.f.evaluate(intermediate_results)\n\nclass PrimitiveRecursion(PRFunction):\n    \"\"\"The primitive recursion constructor PrimRec(f, g).\"\"\"\n    def __init__(self, f: PRFunction, g: PRFunction):\n        self.f = f  # base function, k-ary\n        self.g = g  # step function, (k+2)-ary\n        self.k = f.get_arity()\n        \n        if g.get_arity() != self.k + 2:\n            raise ValueError(\"Arity of step function g must be k+2 for a k-ary base function f.\")\n\n    def get_arity(self) -> int:\n        return self.k + 1\n    \n    def _evaluate(self, args: tuple) -> int:\n        n = args[0]\n        vec_x = args[1:]\n        \n        if n == 0:\n            return self.f.evaluate(vec_x)\n        else:\n            current_val = self.f.evaluate(vec_x)\n            for i in range(n):\n                g_args = (i, current_val) + vec_x\n                current_val = self.g.evaluate(g_args)\n            return current_val\n\ndef solve():\n    \"\"\"\n    Constructs and evaluates the test suite of PR functions and the Ackermann function.\n    \"\"\"\n    results = []\n\n    # Test 1: Evaluate Z_3 at (2,3,5).\n    t1_func = Zero(3)\n    results.append(t1_func.evaluate((2, 3, 5)))\n\n    # Test 2: Evaluate S at (0).\n    t2_func = Successor()\n    results.append(t2_func.evaluate((0,)))\n\n    # Test 3: Evaluate U_2^3 at (7,4,9).\n    t3_func = Projection(2, 3)\n    results.append(t3_func.evaluate((7, 4, 9)))\n\n    # Test 4: Evaluate Comp(S; U_2^2) at (5,6).\n    t4_func = Composition(Successor(), [Projection(2, 2)])\n    results.append(t4_func.evaluate((5, 6)))\n\n    # Test 5: Evaluate Comp(S; S) at (2).\n    t5_func = Composition(Successor(), [Successor()])\n    results.append(t5_func.evaluate((2,)))\n\n    # Test 6: Define addition h = PrimRec(U_1^1, Comp(S; U_2^3)) and evaluate h(3,4).\n    add_func = PrimitiveRecursion(\n        Projection(1, 1), \n        Composition(Successor(), [Projection(2, 3)])\n    )\n    results.append(add_func.evaluate((3, 4)))\n    \n    # Test 7: Evaluate the same addition function h(0,9).\n    results.append(add_func.evaluate((0, 9)))\n    \n    # Test 8: Evaluate Comp(U_3^3; Z_2, Comp(S; U_1^2), Comp(S; U_2^2)) at (8,10).\n    t8_func = Composition(\n        Projection(3, 3), \n        [\n            Zero(2),\n            Composition(Successor(), [Projection(1, 2)]),\n            Composition(Successor(), [Projection(2, 2)])\n        ]\n    )\n    results.append(t8_func.evaluate((8, 10)))\n\n    # Test 9: Evaluate the Ackermann function A(2,2).\n    ackermann_cache.clear()\n    results.append(ackermann(2, 2))\n\n    # Test 10: Evaluate the Ackermann function A(3,2).\n    ackermann_cache.clear()\n    results.append(ackermann(3, 2))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3049723"}]}