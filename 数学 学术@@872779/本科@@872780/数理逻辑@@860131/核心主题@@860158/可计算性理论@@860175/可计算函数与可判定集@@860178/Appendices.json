{"hands_on_practices": [{"introduction": "可计算性理论的基石之一是能够从一组最基本的初始函数和操作（如组合和原始递归）来构建更复杂的函数。这个练习将指导你亲手构建算术中的基本运算——加法、乘法和截断减法。通过这个过程，你将深刻理解原始递归函数的构造性本质，并体会到看似复杂的计算是如何分解为一系列简单、明确的步骤的 [@problem_id:3038773]。", "problem": "令 $\\mathbb{N}$ 表示自然数集。$\\mathbb{N}^{k}$ 上的原始递归（PR）函数类是由初始函数通过复合和原始递归闭包生成的。初始函数包括：零函数 $Z^{n}:\\mathbb{N}^{n}\\to\\mathbb{N}$，定义为 $Z^{n}(\\vec{x})=0$；后继函数 $S:\\mathbb{N}\\to\\mathbb{N}$，定义为 $S(x)=x+1$；以及投影函数 $U^{n}_{i}:\\mathbb{N}^{n}\\to\\mathbb{N}$，定义为 $U^{n}_{i}(x_{1},\\dots,x_{n})=x_{i}$（其中 $1\\leq i\\leq n$）。复合运算将函数 $f$ 和 $g_{1},\\dots,g_{m}$ 映射为 $C(f,g_{1},\\dots,g_{m})(\\vec{x})=f(g_{1}(\\vec{x}),\\dots,g_{m}(\\vec{x}))$。原始递归运算将函数 $g:\\mathbb{N}^{n}\\to\\mathbb{N}$ 和 $h:\\mathbb{N}^{n+2}\\to\\mathbb{N}$ 映射为满足以下条件的唯一函数 $f:\\mathbb{N}^{n+1}\\to\\mathbb{N}$：\n$$\nf(0,\\vec{x})=g(\\vec{x}),\\quad f(S(y),\\vec{x})=h\\big(y,\\vec{x},f(y,\\vec{x})\\big).\n$$\n仅从这些基本定义出发，构造显式的原始递归方案，以证明以下三个函数是原始递归（PR）函数：\n- 加法 $A:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $A(x,y)=x+y$。\n- 乘法 $M:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $M(x,y)=x\\cdot y$。\n- 截断减法 $T:\\mathbb{N}^{2}\\to\\mathbb{N}$，其中 $T(x,y)=\\max(x-y,0)$。\n\n在你的构造中，你可以引入并证明所需的辅助原始递归函数（例如，前驱函数）。完成构造后，定义复合函数\n$$\nF(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big),\n$$\n并计算 $F(3,5)$ 的值。将你的最终答案表示为单个实数。无需四舍五入。", "solution": "该问题是有效的，因为它是可计算性理论中的一个标准练习，基于原始递归函数定义明确且数学上合理的原理。所有术语都是标准的，任务陈述清晰明确。\n\n我们将从初始函数（零函数 $Z^n$、后继函数 $S$ 和投影函数 $U^n_i$）以及复合和原始递归运算出发，显式地构造所需的函数。我们假设自然数集为 $\\mathbb{N}=\\{0, 1, 2, \\dots\\}$，这与原始递归定义中的基本情况 $f(0,\\vec{x})$ 相一致。\n\n1.  **加法: $A(x,y) = x+y$**\n\n    我们通过对第一个参数 $x$ 进行递归来定义加法。\n    函数 $A:\\mathbb{N}^2 \\to \\mathbb{N}$ 满足以下两个方程：\n    $$A(0,y) = y$$\n    $$A(S(x),y) = (x+1)+y = (x+y)+1 = S(A(x,y))$$\n    这是一个原始递归方案 $f(0,\\vec{x}) = g(\\vec{x})$ 和 $f(S(y),\\vec{x}) = h(y, \\vec{x}, f(y,\\vec{x}))$ 的实例。在我们的例子中，递归作用于 $x$，参数是 $y$，函数是 $A(x,y)$。\n    $A(x,y)$ 的方案是：\n    -   基本情况: $A(0,y) = g(y)$。我们有 $A(0,y) = y$，因此我们可以定义 $g:\\mathbb{N} \\to \\mathbb{N}$ 为 $g(y) = y$。这是投影函数 $U^1_1(y)$。函数 $U^1_1$ 是一个初始函数，因此是原始递归（PR）的。\n    -   递归步骤: $A(S(x), y) = h(x,y,A(x,y))$。我们有 $A(S(x),y) = S(A(x,y))$。因此我们定义 $h:\\mathbb{N}^3 \\to \\mathbb{N}$ 为 $h(x,y,z) = S(z)$，其中 $z$ 代表 $A(x,y)$ 的值。形式上，这是 $h(x,y,z) = S(U^3_3(x,y,z))$。该函数是初始函数 $S$ 和初始函数 $U^3_3$ 的复合，因此是PR的。\n    由于 $g=U^1_1$ 和 $h=S \\circ U^3_3$ 都是PR的，由它们通过原始递归定义的函数 $A$ 也是PR的。\n\n2.  **乘法: $M(x,y) = x \\cdot y$**\n\n    我们通过对 $x$ 进行递归，并使用先前已证明为PR的加法函数 $A$ 来定义乘法。\n    函数 $M:\\mathbb{N}^2 \\to \\mathbb{N}$ 满足：\n    $$M(0,y) = 0 \\cdot y = 0$$\n    $$M(S(x),y) = (x+1) \\cdot y = x \\cdot y + y = A(M(x,y), y)$$\n    这符合 $M(x,y)$ 的原始递归方案：\n    -   基本情况: $M(0,y) = g(y)$。我们有 $M(0,y)=0$。因此我们定义 $g:\\mathbb{N} \\to \\mathbb{N}$ 为 $g(y)=0$。这是零函数 $Z^1(y)$，它是一个初始函数，因此是PR的。\n    -   递归步骤: $M(S(x),y) = h(x,y,M(x,y))$。我们有 $M(S(x),y) = A(M(x,y), y)$。令 $z = M(x,y)$，则我们需要 $h(x,y,z) = A(z,y)$。形式上，这是 $h(x,y,z) = A(U^3_3(x,y,z), U^3_2(x,y,z))$。由于 $A$ 是PR的，且投影函数是初始函数，所以 $h$ 是通过PR函数的复合得到的，因此也是PR的。\n    由于 $g=Z^1$ 和 $h=A \\circ (U^3_3, U^3_2)$ 都是PR的，通过原始递归定义的函数 $M$ 也是PR的。\n\n3.  **截断减法: $T(x,y) = \\max(x-y,0)$**\n\n    为了定义截断减法，我们首先需要一个辅助函数，即前驱函数 $P(x) = \\max(x-1,0)$。\n    -   **辅助函数：前驱函数 $P(x)$**\n        函数 $P:\\mathbb{N} \\to \\mathbb{N}$ 通过对 $x$ 进行递归定义：\n        $$P(0)=0$$\n        $$P(S(x)) = x$$\n        对于一元函数，原始递归方案是 $f(0)=c$ 和 $f(S(x))=h(x,f(x))$。\n        -   基本情况: $P(0)=0$。常数 $0$ 由零函数 $Z^0()$ 给出。\n        -   递归步骤: $P(S(x)) = h(x,P(x))$。我们有 $P(S(x))=x$，所以 $h(x,z) = x$。这是投影函数 $U^2_1(x,z)$。\n        由于常数 $0$ 和函数 $U^2_1$ 是PR的，前驱函数 $P$ 是PR的。\n\n    现在我们定义截断减法 $T(x,y)$，也记作 $x \\dot{-} y$。递归必须作用于被定义函数的第一个参数。为了对 $y$ 进行递归，我们定义一个中间函数 $f(y,x) = x \\dot{-} y$。\n    $$f(0,x) = x \\dot{-} 0 = x$$\n    $$f(S(y),x) = x \\dot{-} (y+1) = P(x \\dot{-} y) = P(f(y,x))$$\n    -   基本情况: $f(0,x) = g(x)$。我们有 $f(0,x)=x$。所以 $g(x) = U^1_1(x)$，它是PR的。\n    -   递归步骤: $f(S(y),x) = h(y,x,f(y,x))$。我们有 $f(S(y),x) = P(f(y,x))$。令 $z=f(y,x)$，所以 $h(y,x,z) = P(z) = P(U^3_3(y,x,z))$。由于 $P$ 是PR的且 $U^3_3$ 是初始函数，所以 $h$ 通过复合是PR的。\n    因此，$f(y,x)$ 是PR的。我们想要的函数是 $T(x,y) = x \\dot{-} y = f(y,x)$。我们可以通过交换参数从 $f$ 得到 $T$，这是一个复合运算：$T(x,y) = f(U^2_2(x,y), U^2_1(x,y))$。由于 $f$ 和投影函数都是PR的，$T$ 也是PR的。\n\n4.  **$F(3,5)$ 的求值**\n\n    复合函数由以下公式给出：\n    $$F(x,y)\\;=\\;T\\Big(M\\big(x,\\,S(S(y))\\big),\\;A\\big(x,\\,T\\big(y,\\,S(x)\\big)\\big)\\Big)$$\n    我们需要计算 $F(3,5)$。我们代入 $x=3$ 和 $y=5$：\n    $$F(3,5)\\;=\\;T\\Big(M\\big(3,\\,S(S(5))\\big),\\;A\\big(3,\\,T\\big(5,\\,S(3)\\big)\\big)\\Big)$$\n    我们从内到外计算各项。\n    -   $S(3) = 3+1 = 4$。\n    -   $S(5) = 5+1 = 6$。\n    -   $S(S(5)) = S(6) = 6+1 = 7$。\n    代入这些值得到：\n    $$F(3,5)\\;=\\;T\\Big(M(3, 7),\\;A\\big(3,\\,T(5, 4)\\big)\\Big)$$\n    现在我们计算最外层函数 $T$ 的参数：\n    -   第一个参数是 $M(3, 7) = 3 \\cdot 7 = 21$。\n    -   第二个参数是 $A\\big(3,\\,T(5, 4)\\big)$。我们首先计算 $T(5,4)$:\n        $T(5,4) = \\max(5-4, 0) = \\max(1, 0) = 1$。\n        现在我们计算 $A(3,1)$:\n        $A(3,1) = 3+1 = 4$。\n    所以，第二个参数是 $4$。\n    最后，我们将这些值代回 $F(3,5)$ 的表达式中：\n    $$F(3,5) = T(21, 4)$$\n    然后我们计算最终结果：\n    $$T(21, 4) = \\max(21-4, 0) = \\max(17, 0) = 17$$\n    $F(3,5)$ 的值是 $17$。", "answer": "$$\\boxed{17}$$", "id": "3038773"}, {"introduction": "在确定一个关于程序的属性是否可计算时，区分其“语法”属性（关于代码本身）和“语义”属性（关于程序执行的行为）至关重要。莱斯定理（Rice's Theorem）为所有非平凡的语义属性的不可判定性提供了强有力的证明，但它并不适用于语法属性。本练习旨在通过具体示例来巩固你对这一关键区别的理解，并阐明莱斯定理的应用边界 [@problem_id:3038772]。", "problem": "固定一种图灵机 (TM) 程序的标准有效编码，使得每个程序都被赋予自然数集 $\\mathbb{N}$ 中的一个唯一哥德尔编码。对于每个编码 $e \\in \\mathbb{N}$，令 $\\varphi_e$ 表示由编码为 $e$ 的图灵机程序所计算的部分可计算函数。如果一个子集 $A \\subseteq \\mathbb{N}$ 的特征函数 $\\chi_A \\colon \\mathbb{N} \\to \\{0,1\\}$ 是可计算的，那么该子集被称为是可判定的。如果一个程序性质仅依赖于程序的表示或描述（例如，其长度或其编码中是否存在某个特定符号），则称该性质是句法的；如果它仅依赖于所计算函数的外延行为（例如，$\\varphi_e$ 的值和定义域），则称该性质是语义的。\n\n选择所有正确指明了一个可判定的句法性质，并正确解释了为什么 Rice 定理不适用于它的选项。每个选项描述了一个下标集合和一个简要的理由。\n\nA. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{编码为 } e \\text{ 的程序指令少于 } 100 \\text{ 条} \\}$。这个性质是可判定的，因为可以通过解析有限的编码并计算指令数量来判定；并且 Rice 定理不适用，因为该性质依赖于程序的句法而不是函数 $\\varphi_e$。\n\nB. $Z = \\{ e \\in \\mathbb{N} : \\text{对所有 } x \\in \\mathbb{N} \\text{，} \\varphi_e(x) = 0 \\}$。这个性质是可判定的，因为可以通过测试输入来判定；并且 Rice 定理不适用，因为该性質与程序的句法有关。\n\nC. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ 有定义} \\}$。这个性质是句法的并且是可判定的，因为可以通过检查输入为 $0$ 时的代码路径来判定；并且 Rice 定理适用，意味着它是不可判定的。\n\nD. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ 是一个素数} \\}$。这个性质是可判定的，因为可以使用素性测试来判定；并且 Rice 定理不适用，因为该性质仅依赖于数值上的哥德尔编码 $e$，而不依赖于 $\\varphi_e$ 的外延行为。\n\nE. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ 是全函数} \\}$。这个性质是可判定的，因为一个不循环的程序必须在每个输入上停机；且 Rice 定理在此处不相关。\n\n选择所有正确的选项。", "solution": "用户希望我找出哪些选项正确地描述了一个图灵机程序的性质，该性质是句法的、可判定的，并且对其不适用 Rice 定理的解释是正确的。\n\n首先，让我们根据问题陈述来确定核心定义和定理。\n- 哥德尔编码为每个图灵机程序分配一个唯一的自然数 $e \\in \\mathbb{N}$。$\\varphi_e$ 表示由编码为 $e$ 的程序计算的部分可计算函数。\n- 如果一个集合 $A \\subseteq \\mathbb{N}$ 的特征函数 $\\chi_A: \\mathbb{N} \\to \\{0, 1\\}$ 是可计算的，那么该集合是可判定的。这意味着存在一个算法，对于任何输入 $n \\in \\mathbb{N}$，如果 $n \\in A$，该算法停机并输出 $1$；如果 $n \\notin A$，则停机并输出 $0$。\n- 如果一个程序性质仅依赖于编码 $e$ 本身，那么它是**句法的**。形式上，如果一个下标集合 $S \\subseteq \\mathbb{N}$ 不是一个语义性质，那么它代表一个句法性质。\n- 如果一个程序性质依赖于该程序所计算的函数 $\\varphi_e$，那么它是**语义的**。形式上，一个下标集合 $S \\subseteq \\mathbb{N}$ 代表一个语义性质，如果对于任意两个程序编码 $e, f \\in \\mathbb{N}$，若 $\\varphi_e = \\varphi_f$ （意味着它们计算相同的部分函数），则 $e \\in S$ 当且仅当 $f \\in S$。\n- **Rice 定理**：部分可计算函数的任何非平凡语义性质都是不可判定的。一个性质是非平凡的，如果至少存在一个具有该性质的可计算函数，并且至少存在一个不具有该性质的可计算函数。\n\n任务是找到满足以下三个标准的选项：其中所描述的下标集合 $S$ 1. 定义 $S$ 的性质是句法的。2. 集合 $S$ 是可判定的。3. 关于为什么 Rice 定理不适用的解释是正确的。\n\n让我们逐一评估每个选项。\n\n**A. $S_{\\text{len}} = \\{ e \\in \\mathbb{N} : \\text{编码为 } e \\text{ 的程序指令少于 } 100 \\text{ 条} \\}$。这个性质是可判定的，因为可以通过解析有限的编码并计算指令数量来判定；并且 Rice 定理不适用，因为该性质依赖于程序的句法而不是函数 $\\varphi_e$。**\n\n1.  **句法性质**：指令数量是程序描述（其编码）的一个特征，而不是它所计算的函数的特征。可以创建两个不同的程序 $p_1$ 和 $p_2$，其编码为 $e_1$ 和 $e_2$，使得 $\\varphi_{e_1} = \\varphi_{e_2}$，但 $p_1$ 的指令少于 100 条，而 $p_2$ 有 100 条或更多（例如，通过向 $p_1$ 添加冗余的“无操作”指令来创建 $p_2$）。因此，即使它们计算相同的函数，$e_1$ 可能在 $S_{\\text{len}}$ 中而 $e_2$ 不在。这违反了语义性质的条件，因此该性质是句法的。这部分陈述是正确的。\n\n2.  **可判定集合**：问题陈述中提到存在一种“标准有效编码”。这意味着给定一个数 $e$，我们可以通过算法将其解码以获得程序的表示。解码后，计算指令数量是在有限字符串或结构上进行的简单解析任务。一个算法可以接受 $e$ 作为输入，将其解码，计算指令数，将计数与 100 比较，如果计数小于 100 则输出 1，否则输出 0。该算法总是会停机。因此，集合 $S_{\\text{len}}$ 是可判定的。这部分陈述是正确的。\n\n3.  **对 Rice 定理的解释**：给出的解释是“Rice 定理不适用，因为该性质依赖于程序的句法而不是函数 $\\varphi_e$”。这完全正确。Rice 定理仅适用于非平凡的*语义*性质。由于该性质是句法的，因此 Rice 定理不适用。\n\n**对 A 的结论**：此选项正确地指明了一个句法的、可判定的性质，并为 Rice 定理的不适用性提供了正确的原因。**正确**。\n\n**B. $Z = \\{ e \\in \\mathbb{N} : \\text{对所有 } x \\in \\mathbb{N} \\text{，} \\varphi_e(x) = 0 \\}$。这个性质是可判定的，因为可以通过测试输入来判定；并且 Rice 定理不适用，因为该性質与程序的句法有关。**\n\n1.  **句法性质**：计算常数零函数的性质是函数行为（其输入-输出映射）的一个性质。如果 $\\varphi_e$ 是常数零函数且 $\\varphi_f = \\varphi_e$，那么 $\\varphi_f$ 也必须是常数零函数。所以，$e \\in Z \\iff f \\in Z$。这是语义性质的定义。声称它“与程序的句法有关”是错误的。\n\n2.  **可判定集合**：“计算常数零函数”的性质是一个非平凡的语义性质。常数零函数是可计算的，所以有些程序具有这个性质。后繼函数 $s(x) = x+1$ 也是可计算的，但不具有这个性质。因此，根据 Rice 定理，集合 $Z$ 是不可判定的。声称它“可以通过测试输入来判定”是错误的，因为人们无法在有限时间内测试所有无限多个输入 $x \\in \\mathbb{N}$。\n\n3.  **对 Rice 定理的解释**：该选项声称 Rice 定理不适用。这是错误的。由于该性质是非平凡的和语义的，Rice 定理恰恰是证明其不可判定性的工具。\n\n**对 B 的结论**：这个选项在所有三个要点上都是错误的。该性质是语义的且不可判定的，并且 Rice 定理确实适用。**错误**。\n\n**C. $D_0 = \\{ e \\in \\mathbb{N} : \\varphi_e(0) \\text{ 有定义} \\}$。这个性质是句法的并且是可判定的，因为可以通过检查输入为 $0$ 时的代码路径来判定；并且 Rice 定理适用，意味着它是不可判定的。**\n\n1.  **句法性质**：$\\varphi_e(0)$ 是否停机是函数 $\\varphi_e$ 定义域的一个性质。如果 $\\varphi_e = \\varphi_f$，它们的定义域必须相同。因此，如果 $\\varphi_e(0)$ 有定义，那么 $\\varphi_f(0)$ 也必须有定义。这是一个语义性质。声称它是句法的说法是错误的。\n\n2.  **可判定集合**：集合 $D_0$ 是在输入 $0$ 上停机的程序的下标集合。这是针对固定输入的停机问题，通常表示为 $K_0$。在可计算性理论中，这是一个经典结果，即该集合是不可判定的。声称它“可以通过检查代码路径来判定”是错误的；这种检查恰恰就是停机问题。\n\n3.  **对 Rice 定理的解释**：该选项提出了相互矛盾的说法。它首先声称该性质是可判定的，但随后又说“Rice 定理适用，意味着它是不可判定的。”虽然 Rice 定理确实适用（该性质是非平凡的和语义的）并且确实意味着不可判定性，但这与最初的可判定性断言相矛盾。整个陈述是不一致的。\n\n**对 C 的结论**：该选项错误地将性质认定为句法的和可判定的。其推理是自相矛盾的。**错误**。\n\n**D. $P_{\\text{prime}} = \\{ e \\in \\mathbb{N} : e \\text{ 是一个素数} \\}$。这个性质是可判定的，因为可以使用素性测试来判定；并且 Rice 定理不适用，因为该性质仅依赖于数值上的哥德尔编码 $e$，而不依赖于 $\\varphi_e$ 的外延行为。**\n\n1.  **句法性质**：整数 $e$ 是素数的性质仅取决于 $e$ 本身的值。它与编码为 $e$ 的程序所计算的函数 $\\varphi_e$ 没有任何关系。我们可以有两个编码为 $e$ 和 $f$ 的程序，使得 $\\varphi_e = \\varphi_f$，但 $e$ 是素数而 $f$ 是合数。这是下标的性质，而不是函数的性质，因此是句法的。这部分陈述是正确的。\n\n2.  **可判定集合**：素数集是 $\\mathbb{N}$ 的一个可判定子集。存在许多著名的算法（例如，试除法、埃拉托斯特尼筛法、Miller-Rabin 测试），可以在有限步内确定一个给定的数 $e$ 是否为素数。这部分陈述是正确的。\n\n3.  **对 Rice 定理的解释**：解释是 Rice 定理不适用，因为该性质仅依赖于编码 $e$ 而不是函数 $\\varphi_e$。这是正确的。Rice 定理只适用于语义性质。由于下标 $e$ 的素性是一个句法性质，Rice 定理与其可判定性无关。\n\n**对 D 的结论**：此选项正确地指明了一个句法的、可判定的性质，并为 Rice 定理的不适用性提供了正确的原因。**正确**。\n\n**E. $T = \\{ e \\in \\mathbb{N} : \\varphi_e \\text{ 是全函数} \\}$。这个性质是可判定的，因为一个不循环的程序必须在每个输入上停机；且 Rice 定理在此处不相关。**\n\n1.  **句法性质**：全域性（在所有输入上停机）是函数 $\\varphi_e$ 的一个性质。如果 $\\varphi_e = \\varphi_f$ 且 $\\varphi_e$ 是全函数，那么 $\\varphi_f$ 也必须是全函数。这是一个语义性质。\n\n2.  **可判定集合**：全域性是一个非平凡的语义性质。恒等函数是全函数，而处处无定义的函数则不是。根据 Rice 定理，集合 $T$ 是不可判定的。事实上，一个著名的结果是 $T$ 甚至不是半可判定的（它在算术层次中是 $\\Pi_2$-完全的）。声称它是可判定的是错误的。\n\n3.  **对 Rice 定理的解释**：该选项声称 Rice 定理“在此处不相关”。这是错误的。由于该性质是非平凡的和语义的，Rice 定理是直接相关的，并且是用于证明 $T$ 不可判定性的标准工具。\n\n**对 E 的结论**：这个选项是错误的。该性质是语义的且不可判定的，并且 Rice 定理直接适用。**错误**。\n\n总之，只有选项 A 和 D 满足所有要求的条件。", "answer": "$$\\boxed{AD}$$", "id": "3038772"}, {"introduction": "停机问题是可计算性理论中的一个核心难题，它揭示了计算的内在局限性。本练习将引导你运用通用函数、函数定义域和莱斯定理等概念，一步步证明一个关键结论：对角停机问题（$A = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$）是半可判定的，但不是完全可判定的。这个实践将多个理论知识点联系起来，让你亲身体验推导可计算性理论中一个深刻结果的过程 [@problem_id:3048503]。", "problem": "设 $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$ 是所有从 $\\mathbb{N}$ 到 $\\mathbb{N}$ 的部分递归（部分可计算）函数的一个标准有效枚举，它由一个通用部分递归函数 $U$ 导出，满足对所有 $e,x \\in \\mathbb{N}$ 都有 $U(e,x) \\simeq \\varphi_{e}(x)$。定义部分递归谓词 $P(x)$，它在且仅在 $\\varphi_{x}(x)$ 停机时成立。等价地，记集合 $A \\subseteq \\mathbb{N}$ 为 $A = \\{x \\in \\mathbb{N} : P(x) \\text{ 成立}\\} = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$，其中 $\\downarrow$ 表示收敛。\n\n仅使用部分递归函数和一般递归函数理论中的基本定义和事实，完成以下任务：\n\n1) 构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$（用 $U$ 表示），使其定义域恰好为 $A$。证明 $f$ 是部分递归的。\n\n2) 根据此构造以及递归可枚举集与部分递归函数定义域之间的标准等价关系，推断 $A$ 是否是半可判定的（递归可枚举的）。\n\n3) 使用 Rice 定理（该定理指出部分可计算函数的任何非平凡广延性质都是不可判定的），确定 $A$ 是否是可判定的。由此推断其补集 $\\overline{A}$ 是否是半可判定的。\n\n4) 定义指示值 $\\chi_{A}$ 和 $\\chi_{\\overline{A}}$：若 $A$ 是半可判定的，则 $\\chi_{A} = 1$，否则 $\\chi_{A} = 0$；对 $\\chi_{\\overline{A}}$ 的定义也类似。计算单个实数值\n$$\nS \\;=\\; \\chi_{A} \\;+\\; \\chi_{\\overline{A}}.\n$$\n\n你的最终答案必须是一个数字。不需要四舍五入。不要包含任何单位。", "solution": "首先将根据指定标准验证问题陈述。\n\n### 步骤 1：提取已知条件\n- $\\{\\varphi_{e}\\}_{e \\in \\mathbb{N}}$：所有从 $\\mathbb{N}$到$\\mathbb{N}$的部分递归函数的一个标准有效枚举。\n- $U$：一个通用部分递归函数，满足对所有 $e,x \\in \\mathbb{N}$ 都有 $U(e,x) \\simeq \\varphi_{e}(x)$。\n- $P(x)$：一个当且仅当 $\\varphi_{x}(x)$ 停机时成立的部分递归谓词。\n- $A$：集合 $A = \\{x \\in \\mathbb{N} : P(x) \\text{ 成立}\\} = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$。\n- 任务 1：构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$（用 $U$ 表示），使其定义域恰好为 $A$，并证明 $f$ 是部分递归的。\n- 任务 2：根据任务 1 中的构造推断 $A$ 是否是半可判定的（递归可枚举的）。\n- 任务 3：使用 Rice 定理确定 $A$ 是否是可判定的，并由此推断其补集 $\\overline{A}$ 是否是半可判定的。\n- 任务 4：定义 $\\chi_{A} = 1$（若 $A$ 是半可判定的）和 $\\chi_{A} = 0$（否则），对 $\\chi_{\\overline{A}}$ 也类似定义。计算 $S = \\chi_{A} + \\chi_{\\overline{A}}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据**：该问题完全设定在可计算性理论（数理逻辑的一个分支）的形式框架内。所使用的所有定义和概念——如部分递归函数、通用函数、半可判定性（递归可枚举）、可判定性（递归）和 Rice 定理——都是该领域的基础和标准。集合 $A$ 是经典的对角停机集，通常记作 $K$。\n- **良构性**：该问题由四个清晰、相互关联的任务序列构成。每个问题都很精确，并且在已建立的理论框架内有确切、唯一的答案。\n- **客观性**：语言正式，没有任何主观或模糊的术语。\n- **结论**：该问题是自洽的、逻辑一致且科学上合理的。它是数理逻辑中的一个有效问题。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整解答。\n\n### 解答\n\n解答过程按顺序处理四个任务。\n\n**1) 部分函数 $f$ 的构造**\n\n题目要求我们构造一个部分函数 $f \\colon \\mathbb{N} \\rightharpoonup \\mathbb{N}$，其定义域为集合 $A = \\{x \\in \\mathbb{N} : \\varphi_{x}(x) \\downarrow\\}$。部分函数的定义域是使其函数收敛（停机）的输入集合。我们已知一个通用部分递归函数 $U$，满足 $U(e,x) \\simeq \\varphi_e(x)$。\n\n我们如下定义函数 $f$：\n$$f(x) \\simeq U(x,x)$$\n该定义使用了通用函数 $U$，并将其两个参数都设为输入 $x$。\n\n我们必须证明这个 $f$ 是一个部分递归函数。根据递归函数理论，新的部分递归函数可以通过对现有函数进行复合来构造。在这里，$f$ 是通过将通用函数 $U$ 与投影函数 $\\pi_1^1(x)=x$ 和 $\\pi_1^1(x)=x$ 复合而定义的。形式上，$f(x) \\simeq U(\\pi_1^1(x), \\pi_1^1(x))$。由于根据定义 $U$ 是部分递归的，且投影函数是原始递归的（因此也是部分递归的），它们的复合函数 $f$ 也是一个部分递归函数。\n\n接下来，我们必须证明 $f$ 的定义域，记作 $\\text{dom}(f)$，恰好是 $A$。\n$f$ 的定义域是所有使 $f(x)$ 停机的 $x \\in \\mathbb{N}$ 的集合。\n$$\\text{dom}(f) = \\{x \\in \\mathbb{N} : f(x) \\downarrow\\}$$\n根据我们对 $f$ 的定义，$f(x) \\downarrow$ 当且仅当 $U(x,x) \\downarrow$。\n根据通用函数的定义，$U(x,x) \\downarrow$ 当且仅当 $\\varphi_x(x) \\downarrow$。\n这正是集合 $A$ 的定义。因此，\n$$\\text{dom}(f) = \\{x \\in \\mathbb{N} : \\varphi_x(x) \\downarrow\\} = A$$\n这完成了第一个任务的构造和证明。\n\n**2) $A$ 的半可判定性**\n\n可计算性理论中的一个基本结果建立了递归可枚举集与部分递归函数定义域之间的等价性。一个集合 $S \\subseteq \\mathbb{N}$ 是递归可枚举的（RE），当且仅当存在一个部分递归函数 $g$ 使得 $S = \\text{dom}(g)$。“半可判定的”是“递归可枚举的”的同义词。图灵机半判定一个集合 $S$ 的方式是：当且仅当输入 $x \\in S$ 时停机。在第（1）部分中构造的计算函数 $f$ 的图灵机对集合 $A$ 正是这样做的。\n\n由于我们已经构造了一个部分递归函数 $f$ 使得 $\\text{dom}(f) = A$，我们可以直接根据该定理得出结论：集合 $A$ 是递归可枚举的，因此是半可判定的。\n\n**3) $A$ 的可判定性与 $\\overline{A}$ 的半可判定性**\n\n首先，我们确定 $A$ 是否是可判定的（或递归的）。题目指示我们使用 Rice 定理。Rice 定理指出，对于部分递归函数的任何非平凡性质 $\\mathcal{P}$，其指标集 $I_{\\mathcal{P}} = \\{e \\in \\mathbb{N} : \\varphi_e \\in \\mathcal{P}\\}$ 是不可判定的。一个性质是非平凡的，如果至少有一个部分递归函数具有该性质，且至少有一个不具有。\n\n集合 $A = \\{x : \\varphi_x(x) \\downarrow\\}$ 并不是 Rice 定理所需形式的指标集。然而，我们可以使用 Rice 定理来证明停机问题是不可判定的，然后将停机问题归约到 $A$。\n\n让我们考虑“在输入 $0$ 上停机”这个性质。设该性质为 $\\mathcal{P}_0 = \\{\\psi : \\psi(0) \\downarrow\\}$。\n- 这个性质是非平凡的：处处无定义的函数不具有性质 $\\mathcal{P}_0$。对所有 $x$ 都满足 $g(x) = 0$ 的函数具有性质 $\\mathcal{P}_0$。\n- 根据 Rice 定理，该性质的指标集 $H_0 = \\{e \\in \\mathbb{N} : \\varphi_e(0) \\downarrow\\}$ 是不可判定的。\n\n现在，我们证明如果 $A$ 是可判定的，那么 $H_0$ 也将是可判定的，这是一个矛盾。我们构造一个从 $H_0$ 到 $A$ 的多一归约。根据 s-m-n 定理（或参数定理），对于任意给定的指标 $e$，存在一个全递归函数 $s(e)$，使得对所有 $y \\in \\mathbb{N}$：\n$$\\varphi_{s(e)}(y) \\simeq \\varphi_e(0)$$\n这意味着函数 $\\varphi_{s(e)}$ 是一个常数函数，其行为（停机或发散）与 $\\varphi_e(0)$ 的行为相同。\n现在，考虑 $\\varphi_{s(e)}$ 在其自身指标 $s(e)$ 上的行为。根据上述定义：\n$$\\varphi_{s(e)}(s(e)) \\text{ 停机 } \\iff \\varphi_e(0) \\text{ 停机}$$\n这等价于逻辑陈述：\n$$s(e) \\in A \\iff e \\in H_0$$\n这就构成了从 $H_0$ 到 $A$ 的一个多一归约。如果 $A$ 是可判定的，我们就可以通过先计算指标 $s(e)$（因为 $s$ 是全递归的），然后使用 $A$ 的判定器检查 $s(e) \\in A$ 是否成立，来判定任意 $e$ 是否属于 $H_0$。这将使得 $H_0$ 成为可判定的，这与 Rice 定理的推论相矛盾。因此，我们的初始假设必定是错误的：**$A$ 是不可判定的**。\n\n接下来，我们推断补集 $\\overline{A} = \\{x \\in \\mathbb{N} : \\varphi_x(x) \\uparrow\\}$ 是否是半可判定的。我们使用一个称为 Post 定理的核心结果，该定理指出，一个集合 $S$ 是可判定的（递归的），当且仅当 $S$ 和其补集 $\\overline{S}$ 都是半可判定的（递归可枚举的）。\n\n根据我们的分析：\n- 在第（2）部分中，我们确定了 $A$ 是半可判定的。\n- 我们刚刚证明了 $A$ 是不可判定的。\n\n如果我们假设 $\\overline{A}$ 也是半可判定的，那么根据 Post 定理，由于 $A$ 和 $\\overline{A}$ 都将是半可判定的，所以 $A$ 必须是可判定的。这与我们发现 $A$ 是不可判定的结论直接矛盾。因此，$\\overline{A}$ 是半可判定的这一假设必定是错误的。我们得出结论：**$\\overline{A}$ 不是半可判定的**。\n\n**4) $S$ 的计算**\n\n题目根据相应集合是否为半可判定的来定义指示值 $\\chi_{A}$ 和 $\\chi_{\\overline{A}}$。\n- 若 $A$ 是半可判定的，则 $\\chi_{A} = 1$，否则 $\\chi_{A} = 0$。\n- 若 $\\overline{A}$ 是半可判定的，则 $\\chi_{\\overline{A}} = 1$，否则 $\\chi_{\\overline{A}} = 0$。\n\n我们需要计算 $S = \\chi_{A} + \\chi_{\\overline{A}}$。\n- 从第（2）部分，我们得出结论 $A$ 是半可判定的。因此，$\\chi_{A} = 1$。\n- 从第（3）部分，我们得出结论 $\\overline{A}$ 不是半可判定的。因此，$\\chi_{\\overline{A}} = 0$。\n\n将这些值代入 $S$ 的表达式中：\n$$S = \\chi_{A} + \\chi_{\\overline{A}} = 1 + 0 = 1$$\n最终值为 $1$。", "answer": "$$\\boxed{1}$$", "id": "3048503"}]}