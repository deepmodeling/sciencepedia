{"hands_on_practices": [{"introduction": "皮亚诺算术 (PA) 中像乘法这样的运算的递归公理不仅仅是抽象的定义。这个练习旨在帮助你探索这些公理如何被用来在形式上证明乘法函数的总体性，以及计算出如 $\\overline{2} \\cdot \\overline{3} = \\overline{6}$ 这样的具体算术结果。通过这个过程，你将为形式系统如何推导数学真理建立起直观的理解。[@problem_id:3050644]", "problem": "在一阶皮亚诺算术 (PA) 中工作，其语言包含符号 $0$, $S$, $+$, $\\cdot$, 和 $=$，以及针对所有公式 $\\varphi(y)$ 的完全归纳模式。回顾以下基础公理：\n- 等式公理和一阶逻辑的常规规则。\n- 后继公理：$\\forall x\\, (S(x) \\neq 0)$ 和 $\\forall x\\, \\forall y\\, (S(x)=S(y) \\rightarrow x=y)$。\n- 加法公理：$\\forall x\\, (x+0=x)$ 和 $\\forall x\\, \\forall y\\, (x+S(y)=S(x+y))$。\n- 乘法公理：$\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。\n- 归纳模式：对于每个公式 $\\varphi(y)$，公理 $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$。\n\n数字（Numerals）是形如 $\\overline{n}=S^n(0)$ 的项，其中 $n\\in \\mathbb{N}$。如果存在一个公式 $\\varphi(\\vec{x},z)$，使得 PA 证明 $\\forall \\vec{x}\\, \\exists ! z\\, \\varphi(\\vec{x},z)$，并且对于每个 $\\vec{n}$，PA 证明 $\\varphi(\\overline{\\vec{n}},\\overline{f(\\vec{n})})$，那么函数 $f:\\mathbb{N}^k\\to \\mathbb{N}$ 在 PA 中是（强）可表示的。\n\n仅使用这些基础，从下面关于 PA 证明了什么以及乘法公理如何产生关于数字的乘法事实的陈述中，选择所有正确的陈述：\n\nA. PA 证明了 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。因此，PA 证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。\n\nB. 对于每个 $m,n\\in \\mathbb{N}$，PA 通过一个可以通过迭代定义方程来构造的推导证明了 $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$，并且该推导的长度由一个关于 $m+n$ 的多项式为界。\n\nC. 即使没有假定关于 $\\cdot$ 的公理，PA（仅带有关于 $+$ 的公理和归纳模式）也证明了 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。\n\nD. 从给定的关于 $+$ 和 $\\cdot$ 的公理，PA 证明了 $\\forall x\\, (x\\cdot S(0)=x)$，并且更一般地，对于每个固定的数字 $\\overline{n}$，PA 证明了 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$。\n\nE. 由于乘法是一个可计算（实际上是原始递归）函数，因此在 PA 的语言中存在一个公式 $\\varphi(x,y,z)$，它在强意义上表示 PA 中的乘法图：PA 证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$，并且对于所有的 $m,n\\in \\mathbb{N}$，PA 证明了 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$。\n\n选择所有适用的选项：A, B, C, D, E。", "solution": "问题陈述提供了对一阶皮亚诺算术 (PA) 和函数强可表示性定义的正确且标准的表述。该问题具有科学依据，提法明确且客观。它是数理逻辑中的一个有效问题。我将逐一分析每个选项。\n\n### 选项 A 分析\n陈述 A: `PA 证明了 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。因此，PA 证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。`\n\n陈述的第一部分，“PA 证明了 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$”，根据定义是正确的，因为它们在问题描述中被列为 PA 的公理。\n\n第二部分声称，作为推论，PA 证明了乘法函数的全体性和单值性，形式上表述为 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。让我们来验证这一说法。证明必须在 PA 内部进行。\n\n1.  **存在性**：我们需要证明 $\\forall x\\, \\forall y\\, \\exists z\\, (z = x\\cdot y)$。我们固定任意一个 $x$，并对变量 $y$ 使用归纳模式。令 $\\varphi(y)$ 为公式 $\\exists z\\, (z = x\\cdot y)$。\n    *   **基础情形 ($y=0$)：** 我们必须证明 $\\varphi(0)$，即 $\\exists z\\, (z = x\\cdot 0)$。根据公理 $\\forall x\\, (x\\cdot 0=0)$，我们有 $x\\cdot 0=0$。根据一阶逻辑的规则（存在量化推广），从 $x\\cdot 0=0$ 我们可以推导出 $\\exists z\\, (z=x\\cdot 0)$。因此，PA 证明了 $\\varphi(0)$。\n    *   **归纳步骤：** 我们假设对于任意 $y$，$\\varphi(y)$ 成立，即归纳假设是 $\\exists z\\, (z = x\\cdot y)$。我们把这样一个 $z$ 命名为 $w$，所以 $w = x\\cdot y$。我们必须证明 $\\varphi(S(y))$，即 $\\exists z'\\, (z' = x\\cdot S(y))$。\n        根据第二条乘法公理，我们有 $x\\cdot S(y) = x\\cdot y + x$。\n        使用归纳假设，我们可以用 $w$ 替换 $x\\cdot y$，得到 $x\\cdot S(y) = w+x$。\n        函数 $+$ 在 PA 中也是全函数（可通过类似的归纳证明），因此对于任意的 $w$ 和 $x$，存在一个数等于它们的和 $w+x$。设这个数为 $v$。所以，$v=w+x$。\n        因此，$v = x\\cdot S(y)$。通过存在量化推广，我们得到 $\\exists v\\, (v = x\\cdot S(y))$，也就是 $\\varphi(S(y))$。\n    *   根据归纳模式 $\\big(\\varphi(0)\\wedge \\forall y\\,(\\varphi(y)\\rightarrow \\varphi(S(y)))\\big)\\rightarrow \\forall y\\, \\varphi(y)$，我们得出结论，PA 证明了 $\\forall y\\, \\varphi(y)$，即 $\\forall y\\, \\exists z\\, (z=x\\cdot y)$。由于 $x$ 是任意的，我们可以进行全称量化推广，得到 $\\forall x\\, \\forall y\\, \\exists z\\, (z=x\\cdot y)$。\n\n2.  **唯一性**：我们需要证明对于任何 $x, y$，如果 $z_1 = x\\cdot y$ 且 $z_2 = x\\cdot y$，则 $z_1=z_2$。这是等式性质（特别是传递性：如果 $z_1 = x \\cdot y$ 且 $x \\cdot y = z_2$，则 $z_1 = z_2$）的直接结果。因此，唯一性部分可以从等式公理中证明。\n\n结合存在性和唯一性，PA 证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z = x\\cdot y)$。“因此”这个词在 PA 内部工作的语境下是合适的，因为证明依赖于给定的公理加上归纳模式。\n\n对 A 的裁定：**正确**。\n\n### 选项 B 分析\n陈述 B: `对于每个 $m,n\\in \\mathbb{N}$，PA 通过一个可以通过迭代定义方程来构造的推导证明了 $\\overline{m}\\cdot \\overline{n}=\\overline{m\\cdot n}$，并且该推导的长度由一个关于 $m+n$ 的多项式为界。`\n\n这个陈述提出了两个主张。\n1.  **通过迭代的可证明性**：PA 对任意具体的数字 $\\overline{m}$ 和 $\\overline{n}$ 证明了 $\\overline{m}\\cdot \\overline{n}=\\overline{m \\cdot n}$。证明通过对 $\\overline{n}$ 的递归进行。\n    *   如果 $n=0$，我们证明 $\\overline{m}\\cdot\\overline{0}=\\overline{0}$，即 $\\overline{m}\\cdot 0=0$。这是公理 $\\forall x(x\\cdot 0=0)$ 的一个实例。\n    *   如果 $n>0$，所以 $\\overline{n}=S(\\overline{n-1})$，我们有 $\\overline{m}\\cdot S(\\overline{n-1}) = \\overline{m}\\cdot\\overline{n-1} + \\overline{m}$。通过（元）归纳，我们假设可以证明 $\\overline{m}\\cdot\\overline{n-1} = \\overline{m(n-1)}$。所以我们得到 $\\overline{m(n-1)} + \\overline{m}$。一个关于加法定义的类似迭代过程证明了 $\\overline{a}+\\overline{b}=\\overline{a+b}$，其步骤数与 $b$ 成正比。这里，我们需要证明 $\\overline{m(n-1)} + \\overline{m} = \\overline{m(n-1)+m} = \\overline{mn}$。这需要 $m$ 次应用加法的后继规则。因此，整个过程“迭代了定义方程”。\n2.  **证明长度**：乘法的主要递归步骤数是 $n$。每一步都涉及一个加法 $\\overline{a}+\\overline{m}$，这需要 $m$ 个加法的递归步骤。递归公理的总应用次数在 $O(m \\cdot n)$ 的数量级。数字本身，例如 $\\overline{m \\cdot n}$，其长度（符号数量）与 $m \\cdot n$ 成正比。证明的总长度（所有公式长度之和）将是 $m$ 和 $n$ 的一个多项式函数。任何关于两个变量 $m, n$ 的多项式都由它们之和 $m+n$ 的一个多项式为界，因为 $m \\le m+n$ 且 $n \\le m+n$。因此，像 $m^a n^b$ 这样的项被 $(m+n)^a (m+n)^b = (m+n)^{a+b}$ 所界定。这是证明论中关于 PA 中无量词陈述形式证明效率的一个已知结果。\n\n对 B 的裁定：**正确**。\n\n### 选项 C 分析\n陈述 C: `即使没有假定关于 $\\cdot$ 的公理，PA（仅带有关于 $+$ 的公理和归纳模式）也证明了 $\\forall x\\, (x\\cdot 0=0)$ 和 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$。`\n\n这个陈述是错误的。如果符号 $\\cdot$ 包含在语言中，但没有提供任何公理来规定其行为，它就是一个未解释的函数符号。可以构建一个剩余 PA 公理（关于 $0, S, +$ 和归纳）的模型，其中 $\\cdot$ 的解释不满足所述性质。\n\n例如，让论域为 $\\mathbb{N}$，$0, S, +$ 按常规解释。让符号 $\\cdot$ 的解释，记作 $f(x,y) = x \\cdot y$，是对于所有 $x,y \\in \\mathbb{N}$ 的常数函数 $f(x,y)=1$。这个结构是没有乘法公理的 PA 的一个模型。在这个模型中，陈述 $\\forall x\\, (x\\cdot 0=0)$ 转化为“对于所有 $x \\in \\mathbb{N}, f(x,0)=0$”，这意味着“$1=0$”。这是错误的，并且实际上与 PA 公理 $\\forall x(S(x) \\neq 0)$ 相矛盾，从该公理可以证明 $\\overline{1} \\neq 0$。\n\n因为我们找到了一个简化理论的模型，其中乘法公理是假的，所以它们不可能是该理论的定理。乘法公理不是多余的。\n\n对 C 的裁定：**错误**。\n\n### 选项 D 分析\n陈述 D: `从给定的关于 $+$ 和 $\\cdot$ 的公理，PA 证明了 $\\forall x\\, (x\\cdot S(0)=x)$，并且更一般地，对于每个固定的数字 $\\overline{n}$，PA 证明了 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$。`\n\n第一部分：证明 $\\forall x\\, (x\\cdot S(0)=x)$。\n注意 $S(0)$ 是数字 $\\overline{1}$。\n从乘法公理 $\\forall x\\, \\forall y\\, (x\\cdot S(y)=x\\cdot y + x)$，我们将 $y$ 实例化为 $0$：PA 证明了 $\\forall x\\, (x\\cdot S(0)=x\\cdot 0 + x)$。\n从另一条乘法公理 $\\forall x\\, (x\\cdot 0=0)$，我们代入得到：PA 证明了 $\\forall x\\, (x\\cdot S(0)=0 + x)$。\n我们现在需要证明 PA 证明了 $\\forall x\\,(0+x=x)$。这是加法的左单位元性质。它不是一个公理，但可以通过对 $x$ 的归纳来证明。\n令 $\\varphi(x)$ 为 $0+x=x$。\n*   **基础情形 ($x=0$)：** $\\varphi(0)$ 是 $0+0=0$。这通过将公理 $\\forall z(z+0=z)$ 中的 $z$ 设为 $0$ 得出。\n*   **归纳步骤：** 假设 $\\varphi(x)$，即 $0+x=x$。我们必须证明 $\\varphi(S(x))$，即 $0+S(x)=S(x)$。根据第二条加法公理 $\\forall z\\forall y(z+S(y)=S(z+y))$，设 $z=0, y=x$，我们得到 $0+S(x)=S(0+x)$。根据归纳假设，$0+x=x$，所以 $S(0+x)=S(x)$。因此，$0+S(x)=S(x)$。\n通过归纳，PA 证明了 $\\forall x\\, (0+x=x)$。将此代入我们早先的结果，PA 证明了 $\\forall x\\, (x\\cdot S(0)=x)$。\n\n第二部分：证明对于每个 $n \\in \\mathbb{N}$，PA 证明了 $\\forall x\\, \\big(x\\cdot \\overline{n}=\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}\\big)$。让 $T_n(x)$ 表示项 $\\underbrace{x+\\cdots + x}_{n\\ \\text{summands}}$ （其中 $T_0(x)$ 是 $0$）。我们通过对 $n$ 的元归纳来证明这一点。\n*   **基础情形 ($n=0$)：** 我们必须证明 PA 证明了 $\\forall x(x\\cdot\\overline{0}=T_0(x))$，即 $\\forall x(x\\cdot 0=0)$。这是一个公理。\n*   **归纳步骤：** 假设对于某个 $k \\in \\mathbb{N}$，PA 证明了 $\\forall x(x\\cdot\\overline{k}=T_k(x))$。我们想要证明 PA 证明了 $\\forall x(x\\cdot\\overline{k+1}=T_{k+1}(x))$。\n    $\\overline{k+1}$ 是 $S(\\overline{k})$。该项是 $x \\cdot S(\\overline{k})$。\n    根据乘法公理，PA 证明了 $x \\cdot S(\\overline{k}) = (x\\cdot\\overline{k}) + x$。\n    根据元归纳假设，PA 证明了 $x \\cdot \\overline{k} = T_k(x)$。\n    代入这个得到 $x \\cdot S(\\overline{k}) = T_k(x) + x$。\n    根据定义，$T_{k+1}(x)$ 是 $T_k(x) + x$。\n    因此，PA 证明了 $\\forall x \\, (x \\cdot \\overline{k+1} = T_{k+1}(x))$。\n元归纳成立，所以这个陈述是正确的。\n\n对 D 的裁定：**正确**。\n\n### 选项 E 分析\n陈述 E: `由于乘法是一个可计算（实际上是原始递归）函数，因此在 PA 的语言中存在一个公式 $\\varphi(x,y,z)$，它在强意义上表示 PA 中的乘法图：PA 证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, \\varphi(x,y,z)$，并且对于所有的 $m,n\\in \\mathbb{N}$，PA 证明了 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$。`\n\n这个陈述基于数理逻辑中的一个主要定理提出了一个主张。\n1.  **前提**：自然数上的乘法是一个原始递归函数，它是可计算（或全递归）函数的一个子集。这是可计算性理论中的一个正确陈述。\n2.  **推论**：形式算术理论的一个基础性结果（最早由 Gödel 证明）是所有可计算函数在 PA 中都是强可表示的。由于乘法是可计算的，它必须在 PA 中是强可表示的。\n3.  **公式的存在性**：该陈述断言存在一个具有强表示性质的公式 $\\varphi(x,y,z)$。根据一般定理，这样的公式必须存在。\n4.  **一个具体例子**：我们甚至可以直接展示这样一个公式。让我们选择最自然的候选者：$\\varphi(x,y,z) \\equiv (z = x \\cdot y)$。这个公式在 PA 的语言中。\n    *   PA 是否证明了 $\\forall x\\, \\forall y\\, \\exists ! z\\, (z=x\\cdot y)$？是的，正如在选项 A 的分析中所确立的。\n    *   对于所有 $m,n\\in \\mathbb{N}$，PA 是否证明了 $\\varphi(\\overline{m},\\overline{n},\\overline{m\\cdot n})$？这是陈述 PA 证明了 $\\overline{m\\cdot n} = \\overline{m} \\cdot \\overline{n}$。正如在选项 B 的分析中所确立的，这对于所有 $m,n \\in \\mathbb{N}$ 都是正确的。\n\n该选项中提供的推理是合理的，并且该主张本身是关于 PA 的一个基本事实。\n\n对 E 的裁定：**正确**。\n\n### 总结\n分析表明，陈述 A, B, D, 和 E 是对皮亚诺算术的定理或性质的正确描述，而陈述 C 是不正确的。\n- **A** 是正确的，因为 PA 足够强大，可以证明由其公理定义的原始递归函数的全体性。\n- **B** 是正确的，因为 PA 可以执行计算，并且对于终止计算的证明长度是可行地有界的。\n- **C** 是不正确的，因为乘法公理不能从其他公理中推导出来。\n- **D** 是正确的，展示了 PA 如何从递归定义中证明基本的代数恒等式。\n- **E** 是正确的，因为它是关于 PA 中可计算函数可表示性基本定理的一个实例。\n\n正确的选项是 A, B, D, 和 E。", "answer": "$$\\boxed{ABDE}$$", "id": "3050644"}, {"introduction": "PA 的真正威力来自于它不仅能谈论数字，还能谈论更复杂的对象。本练习将向你介绍算术化，即 Gödel 编码 (Gödel numbering) 的概念，通过这种方法我们可以将计算步骤乃至整个程序这样的复杂结构表示为单一的自然数。通过追踪一个简单程序的运行并计算其唯一的数值代码，你将亲身体验这一编码过程，将抽象的概念变得具体可感。[@problem_id:3042000]", "problem": "在一阶 Peano 算术 (PA) 中，使用包含加法和乘法符号的语言进行操作。固定标准素数幂序列编码如下。令 $p_i$ 表示第 $i$ 个素数，其中 $p_0 = 2$, $p_1 = 3$, $p_2 = 5$，以此类推。对于自然数的有限序列 $\\langle a_0,\\dots,a_n \\rangle$，其编码是自然数\n$$\n\\prod_{i=0}^{n} p_i^{a_i+1}.\n$$\n我们将对带有指令指针的单寄存器确定性寄存器机 $e$ 的计算进行建模。一个构型是一个序对 $(\\mathit{ip}, r)$，其中 $\\mathit{ip}$ 是当前的指令标签，$r$ 是唯一寄存器的内容。停机状态由 $\\mathit{ip} = 0$ 编码。构型 $(\\mathit{ip}, r)$ 的编码是\n$$\n\\mathrm{ConfCode}(\\mathit{ip}, r) \\;=\\; 2^{\\mathit{ip}+1} \\cdot 3^{r+1}.\n$$\n一次有限计算（运行）是一个构型的有限序列 $\\langle c_0, c_1, \\dots, c_m \\rangle$，使得 $c_0$ 是给定输入的初始构型，每个相邻对 $(c_i, c_{i+1})$ 都由机器的单步转移关系关联，并且 $c_m$ 是停机状态（其指令指针为 $0$）。这样一次运行的编码是构型编码序列的素数幂编码：\n$$\n\\mathrm{RunCode}(c_0,\\dots,c_m) \\;=\\; \\prod_{i=0}^{m} p_i^{\\mathrm{ConfCode}(c_i)+1}.\n$$\n任务：\n- 仅使用一阶算术和上述编码，定义一个公式 $\\mathrm{Halt}_e(x,y)$，它表示“$y$ 是机器 $e$ 在输入 $x$ 上的一个停机计算的编码”。其中，一次计算是从初始构型开始到停机构型结束的有限构型序列，并且连续的构型遵循 $e$ 的单步转移关系。你的定义必须属于 $\\Sigma_1$ 类。\n- 证明你的公式 $\\mathrm{Halt}_e(x,y)$ 是 $\\Sigma_1$ 的，并解释为何这种 $\\Sigma_1$ 可定义性是通过形如 $\\exists y\\, \\mathrm{Halt}_e(x,y)$ 的谓词，成为所有计算可枚举集在 Peano 算术中可表示性的基础。\n- 考虑具有两条指令的特定机器 $e$：\n  1. 指令标签 1：将寄存器加一并跳转到标签 2。\n  2. 指令标签 2：停机。\n  在输入 $x=1$ 时，根据上述方案计算编码唯一停机计算的运行编码 $y$ 的精确值。以素数幂乘积的闭合形式给出你的最终答案。不要将其展开为十进制数。\n提供 $y$ 的最终值作为你的答案。无需四舍五入。", "solution": "该问题被认定为有效，因为它在数理逻辑上有科学依据，问题明确且客观。它不包含矛盾、歧义或不合理的假设。因此，我们可以着手解决。\n\n该问题包括三个任务：定义一个公式 `Halt_e(x, y)`，证明其性质以及与计算可枚举集的关系，并计算一个特定的运行编码。\n\n### 任务 1：公式 $\\mathrm{Halt}_e(x,y)$ 的定义\n\n我们被要求在包含加法（$+$）和乘法（$\\cdot$）符号的一阶 Peano 算术（PA）语言中定义一个公式 $\\mathrm{Halt}_e(x,y)$，该公式表示“$y$ 是机器 $e$ 在输入 $x$ 上的一个停机计算的编码”。该公式必须属于算术层级中的 $\\Sigma_1$ 类。\n\n如果一个数 $y$ 是构型编码的有限序列 $\\langle c_0, c_1, \\dots, c_m \\rangle$ 的素数幂编码，并满足以下条件，则 $y$ 编码了一次停机计算：\n1.  序列非空。\n2.  第一个构型 $c_0$ 是给定输入 $x$ 的初始构型。对于确定性寄存器机，初始构型通常是 $(\\mathit{ip}_{start}, x)$。我们假设初始指令指针 $\\mathit{ip}_{start}$ 为 $1$。\n3.  最后一个构型 $c_m$ 是停机构型，意味着其指令指针为 $0$。\n4.  序列中的每个后续构型 $c_{i+1}$ 都是由前一个构型 $c_i$ 经过机器 $e$ 的单步执行得到的，该执行由其转移关系定义。\n\n为了形式化这一点，我们从几个辅助谓词构建公式 $\\mathrm{Halt}_e(x,y)$。这些谓词在 PA 中是可定义的。其中的关键是像素性测试、$i$-阶素数函数 ($p_i$) 和指数运算 ($a^b$) 这样函数的的可定义性。尽管 PA 的语言只包含 $+$ 和 $\\cdot$，但这些概念确实是可定义的。特别地，指数运算是 $\\Delta_1$-可定义的。所有原始递归函数和关系在 PA 中都是 $\\Delta_1$-可定义的。由 $\\mathrm{Halt}_e(x,y)$ 表达的关系是原始递归的，这保证了其 $\\Delta_1$-可定义性，因此也保证了等价的 $\\Sigma_1$ 公式的存在。\n\n让我们定义公式的各个组成部分。\n\n**辅助谓词：**\n\n-   $\\mathrm{IsPrime}(p)$：一个表示 $p$ 是素数的公式。\n    $\\mathrm{IsPrime}(p) \\equiv p > 1 \\land \\forall d < p (d > 1 \\to \\neg(\\exists k < p (d \\cdot k = p)))$。这是一个 $\\Delta_0$ 公式。\n-   $\\mathrm{NthPrime}(i, p)$：一个表示 $p$ 是第 $i$ 个素数（$p_i$）的公式。这是 $\\Delta_1$-可定义的。\n-   $\\mathrm{exp}(n, p, k)$：一个表示 $k$ 是素数 $p$ 在 $n$ 的素数分解中的指数的公式。\n    $\\mathrm{exp}(n, p, k) \\equiv p^k | n \\land \\neg(p^{k+1} | n)$。由于指数运算，这是 $\\Delta_1$ 的。\n-   $\\mathrm{GetElem}(y, i, c)$：一个表示 $c$ 是由 $y$ 编码的序列中第 $(i+1)$ 个元素的公式。根据问题的编码方式，这意味着 $c+1$ 是 $p_i$ 的指数。\n    $\\mathrm{GetElem}(y, i, c) \\equiv \\exists p (\\mathrm{NthPrime}(i, p) \\land \\mathrm{exp}(y, p, c+1))$。\n-   $\\mathrm{Len}(y, m)$：一个表示由 $y$ 编码的序列长度为 $m$ 的公式。\n    $\\mathrm{Len}(y, m) \\equiv \\exists p, q (\\mathrm{NthPrime}(m-1, p) \\land p|y \\land \\mathrm{NthPrime}(m, q) \\land \\neg(q|y))$。\n\n**构型谓词：**\n\n-   $\\mathrm{ConfCode}(ip, r, c)$：一个表示 $c$ 是构型 $(\\mathit{ip}, r)$ 的编码的公式。\n    $\\mathrm{ConfCode}(ip, r, c) \\equiv c = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$。\n-   $\\mathrm{GetIP}(c, ip)$：一个从构型编码 $c$ 中提取指令指针的公式。\n    $\\mathrm{GetIP}(c, ip) \\equiv \\mathrm{exp}(c, 2, \\mathit{ip}+1)$。\n-   $\\mathrm{GetR}(c, r)$：一个从构型编码 $c$ 中提取寄存器值的公式。\n    $\\mathrm{GetR}(c, r) \\equiv \\mathrm{exp}(c, 3, r+1)$。\n\n**计算步骤谓词：**\n\n-   $\\mathrm{Transition}_e(c, c')$：一个表示构型 $c'$ 在机器 $e$ 的一步内从 $c$ 得到的公式。这是对 $e$ 的所有指令的析取。对于一个有 $k$ 条指令的机器，其形式为：\n    $\\mathrm{Transition}_e(c, c') \\equiv \\bigvee_{j=1}^{k} \\Phi_j(c, c')$，其中 $\\Phi_j$ 形式化了指令 $j$ 的效果。每个 $\\Phi_j$ 的形式为 $\\exists \\mathit{ip}, r, \\mathit{ip}', r' (\\mathrm{GetIP}(c, \\mathit{ip}) \\land \\mathrm{GetR}(c, r) \\land \\mathit{ip}=j \\land (\\text{指令 } j \\text{ 的逻辑}) \\land \\mathrm{ConfCode}(\\mathit{ip}', r', c'))$。\n\n**完整公式 $\\mathrm{Halt}_e(x,y)$：**\n\n结合这些，我们如下定义 $\\mathrm{Halt}_e(x,y)$。它断言计算序列存在一个长度 $m+1$，并且对于从 $0$ 到 $m-1$ 的所有步骤 $i$，从构型 $i$ 到 $i+1$ 的转移是有效的。\n\n$\\mathrm{Halt}_e(x,y) \\equiv$\n$\\exists m > 0 \\, \\Big( \\mathrm{Len}(y, m+1) \\land $\n$\\quad \\exists c_0 \\, \\big( \\mathrm{GetElem}(y, 0, c_0) \\land \\mathrm{ConfCode}(1, x, c_0) \\big) \\land $\n$\\quad \\exists c_m \\, \\big( \\mathrm{GetElem}(y, m, c_m) \\land \\exists \\mathit{ip}_m (\\mathrm{GetIP}(c_m, \\mathit{ip}_m) \\land \\mathit{ip}_m = 0) \\big) \\land $\n$\\quad \\forall i < m \\, \\exists c_i, c_{i+1} \\, \\big( \\mathrm{GetElem}(y, i, c_i) \\land \\mathrm{GetElem}(y, i+1, c_{i+1}) \\land \\mathrm{Transition}_e(c_i, c_{i+1}) \\big) \\Big)$\n\n此公式中的所有量词都是有界的（例如，$m < y$, $c_i < y$），除了那些隐藏在辅助谓词中的量词（特别是指数运算）。该关系是原始递归的，所以它是 $\\Delta_1$ 的。根据算术层级的定义，一个 $\\Delta_1$ 公式可证明地等价于一个 $\\Sigma_1$ 公式。因此，这个构造定义了所求的关系，并且存在一个等价的 $\\Sigma_1$ 公式。\n\n### 任务 2：$\\Sigma_1$ 可定义性和可表示性的证明\n\n**$\\Sigma_1$ 可定义性：**如果一个公式形如 $\\exists z_1 \\dots \\exists z_k \\phi$，其中 $\\phi$ 是一个 $\\Delta_0$ 公式（其所有量词都有界），那么它就是 $\\Sigma_1$ 的。谓词 $R(x,y) \\equiv$ “$y$ 是机器 $e$ 在输入 $x$ 上的停机计算的编码”是一个可判定谓词。给定 $x$ 和 $y$，可以在有限步内机械地检查 $y$ 是否具有所需的属性。这样的谓词被称为“原始递归”的。由 Gödel 建立的可计算性理论和逻辑的一个基本结果是，每个原始递归关系在 Peano 算术中都可以由一个 $\\Delta_1$ 公式定义。如果一个公式在 PA 中既等价于一个 $\\Sigma_1$ 公式，又等价于一个 $\\Pi_1$ 公式，那么它就是 $\\Delta_1$ 的。因此，我们的谓词 $\\mathrm{Halt}_e(x,y)$ 是 $\\Sigma_1$-可定义的。上面提供的半形式化定义是这一事实的证明概要。\n\n**与计算可枚举集的关系：**这种 $\\Sigma_1$ 可定义性是在 PA 中表示所有计算可枚举（CE）集的基础。\n1.  一个集合 $S \\subseteq \\mathbb{N}$ 是计算可枚举的，如果存在一个寄存器机 $e$，它在输入 $x$ 上停机当且仅当 $x \\in S$。\n2.  陈述“机器 $e$ 在输入 $x$ 上停机”等价于断言存在一个相应的停机计算。\n3.  在我们的形式系统中，这转化为：“存在一个数 $y$，它是机器 $e$ 在输入 $x$ 上的停机计算的编码”。\n4.  使用我们定义的谓词，这可以写成公式 $\\exists y \\, \\mathrm{Halt}_e(x, y)$。\n5.  由于 $\\mathrm{Halt}_e(x, y)$ 可由一个 $\\Sigma_1$ 公式（如上所述）定义，设为 $\\psi(x, y)$，那么公式 $\\exists y \\, \\psi(x, y)$ 也是 $\\Sigma_1$ 的。\n这建立了一个直接的对应关系：对于每个 CE 集 $S$，都有一个形如 $\\exists y \\, \\mathrm{Halt}_e(x, y)$ 的 $\\Sigma_1$ 公式 $\\Phi_S(x)$，使得 $x \\in S \\iff \\mathbb{N} \\models \\Phi_S(x)$。这表明 $\\Sigma_1$-可定义的集合类恰好就是计算可枚举集合类。\n此外，PA 的 $\\Sigma_1$ 可靠性与完备性定理指出，对于任何 $\\Sigma_1$ 语句 $\\phi$，$\\mathbb{N} \\models \\phi \\iff PA \\vdash \\phi$。这意味着对于任何 $n \\in S$，不仅 $\\Phi_S(\\bar{n})$ 是真的，而且它在 PA 中也是可证的。这个性质被称为 CE 集在 PA 中的 $\\Sigma_1$-可表示性。\n\n### 任务 3：运行编码的计算\n\n我们给定一个特定的机器 $e$ 和输入 $x=1$。\n-   **机器 $e$**：\n    1.  标签 1 处的指令：寄存器加一，跳转到标签 2。\n    2.  标签 2 处的指令：停机（即跳转到标签 0）。\n-   **输入**：$x=1$。\n\n我们追踪计算过程，它是一个构型 $(\\mathit{ip}, r)$ 序列。\n1.  **初始构型 ($c_0$)**：计算从指令标签 1 开始，寄存器中输入为 $x=1$。\n    $c_0 = (\\mathit{ip}=1, r=1)$。\n2.  **步骤 1**：执行指令 1。寄存器 $r$ 的值增加（$r \\to 1+1=2$），指令指针 $\\mathit{ip}$ 跳转到 2。下一个构型是：\n    $c_1 = (\\mathit{ip}=2, r=2)$。\n3.  **步骤 2**：执行指令 2。这是一条停机指令，我们将其建模为将指令指针设置为 0。寄存器值保持不变。最终构型是：\n    $c_2 = (\\mathit{ip}=0, r=2)$。\n由于 $\\mathit{ip}=0$，机器已经停机。完整的计算轨迹是序列 $\\langle c_0, c_1, c_2 \\rangle$。\n\n接下来，我们使用 $\\mathrm{ConfCode}(\\mathit{ip}, r) = 2^{\\mathit{ip}+1} \\cdot 3^{r+1}$ 计算每个构型的编码。\n-   对于 $c_0 = (1, 1)$：编码 $a_0 = \\mathrm{ConfCode}(1, 1) = 2^{1+1} \\cdot 3^{1+1} = 2^2 \\cdot 3^2 = 4 \\cdot 9 = 36$。\n-   对于 $c_1 = (2, 2)$：编码 $a_1 = \\mathrm{ConfCode}(2, 2) = 2^{2+1} \\cdot 3^{2+1} = 2^3 \\cdot 3^3 = 8 \\cdot 27 = 216$。\n-   对于 $c_2 = (0, 2)$：编码 $a_2 = \\mathrm{ConfCode}(0, 2) = 2^{0+1} \\cdot 3^{2+1} = 2^1 \\cdot 3^3 = 2 \\cdot 27 = 54$。\n\n构型编码的序列是 $\\langle a_0, a_1, a_2 \\rangle = \\langle 36, 216, 54 \\rangle$。\n\n最后，我们使用公式 $\\mathrm{RunCode} = \\prod_{i=0}^{m} p_i^{a_i+1}$ 计算运行编码 $y$，其中 $m=2$。素数为 $p_0=2$, $p_1=3$, $p_2=5$。\n指数为 $a_i+1$：\n-   对于 $i=0$：指数为 $a_0+1 = 36+1 = 37$。\n-   对于 $i=1$：指数为 $a_1+1 = 216+1 = 217$。\n-   对于 $i=2$：指数为 $a_2+1 = 54+1 = 55$。\n\n运行编码 $y$ 是这些素数幂的乘积：\n$$y = p_0^{a_0+1} \\cdot p_1^{a_1+1} \\cdot p_2^{a_2+1} = 2^{37} \\cdot 3^{217} \\cdot 5^{55}$$", "answer": "$$\n\\boxed{2^{37} \\cdot 3^{217} \\cdot 5^{55}}\n$$", "id": "3042000"}, {"introduction": "在算术化技术的基础上，我们现在可以着手证明数理逻辑中的一个基石性定理：所有原始递归函数在 PA 中都是可表示的。本练习将引导你理解这个基本证明的结构，该证明对原始递归函数的构造使用了结构归纳法。它展示了序列编码是如何成为处理原始递归步骤的关键工具，从而巩固了计算、编码和形式证明之间的联系。[@problem_id:3042040]", "problem": "设一阶算术语言由符号 $0$、$S$、$+$、$\\cdot$、$=$ 以及通常的逻辑联结词和量词给出。考虑皮亚诺算术（PA），即在该语言上带有归纳模式的算术公理化系统。一个全函数 $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ 被称为是原始递归的，如果它可以从初始函数 $Z(\\bar{x})=0$、$S(x)=x+1$ 和投影函数 $U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$ 出发，通过有限次函数复合和原始递归得到。其中，原始递归将一对函数 $(f,g)$ 映射到一个满足以下条件的函数 $h$：\n$$\nh(0,\\bar{x})=f(\\bar{x}) \\quad\\text{and}\\quad h(S(y),\\bar{x})=g\\big(y,h(y,\\bar{x}),\\bar{x}\\big).\n$$\n一个函数 $f$ 在皮亚诺算术（PA）中是可表示的，如果存在语言中的一个公式 $\\varphi_{f}(\\bar{x},y)$，使得对于任意 $\\bar{n}\\in\\mathbb{N}^{k}$ 和 $m\\in\\mathbb{N}$，$\\mathrm{PA}$ 证明 $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$，并且 $\\mathrm{PA}$ 还证明 $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$。其中 $\\overline{n}$ 表示 $n$ 的数码，$\\bar{\\overline{n}}$ 表示数码的元组。\n\n假设以下经过充分检验的基础事实：存在一个原始递归的序列编码函数 $\\beta(s,i)$ 和算术语言中的一个有界公式 $\\mathrm{Seq}(s,\\ell)$，使得对于每个有限函数 $a:\\{0,\\dots,\\ell-1\\}\\to\\mathbb{N}$，都存在一个 $s$ 满足 $\\mathrm{Seq}(s,\\ell)$ 并且对于所有 $i<\\ell$ 有 $\\beta(s,i)=a(i)$，而且关于 $\\beta$ 和 $\\mathrm{Seq}$ 的这些性质在 $\\mathrm{PA}$ 中是可证的。\n\n仅使用以上定义和这个编码事实作为基础，完成以下任务：\n\n- 解释在 $\\mathrm{PA}$ 中的可表示性需要什么，以及为什么初始函数是可表示的。\n- 通过对原始递归函数的构造进行结构归纳，证明如果 $f$ 和 $g_{i}$ 是可表示的，那么它们的复合函数 $h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$ 也是可表示的。\n- 利用序列编码事实，通过结构归纳证明，如果 $f$ 和 $g$ 是可表示的，那么由 $f$ 和 $g$ 决定的原始递归函数 $h$ 也是可表示的。\n- 总结出每个原始递归函数在 $\\mathrm{PA}$ 中都是可表示的。\n- 作为示例，为原始递归加法函数 $\\mathrm{add}(x,y)=x+y$ 给出算术语言中的一个显式表示公式。\n\n你最终报告的答案必须是你的显式加法公式中使用的表示项，写成一个单一的封闭形式符号表达式，不含任何等号或逻辑联结词。不要包含单位。", "solution": "该问题陈述是数理逻辑中一个标准练习，涉及一阶皮亚诺算术（PA）内原始递归函数的可表示性。\n\n### 问题验证\n**步骤 1：提取已知条件**\n-   算术语言：符号 $0$、$S$、$+$、$\\cdot$、$=$、逻辑联结词和量词。\n-   理论：带有归纳模式的皮亚诺算术（PA）。\n-   原始递归（PR）函数的定义：初始函数（零函数 $Z$、后继函数 $S$、投影函数 $U_{i}^{k}$）在复合和原始递归运算下的闭包。\n    -   初始函数：$Z(\\bar{x})=0$；$S(x)=x+1$；$U_{i}^{k}(x_{1},\\dots,x_{k})=x_{i}$。\n    -   复合：$h(\\bar{x})=f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$。\n    -   原始递归：$h(0,\\bar{x})=f(\\bar{x})$ 和 $h(S(y),\\bar{x})=g(y,h(y,\\bar{x}),\\bar{x})$。\n-   可表示性的定义：一个函数 $f:\\mathbb{N}^{k}\\to\\mathbb{N}$ 在 PA 中是可表示的，如果存在一个公式 $\\varphi_{f}(\\bar{x},y)$，使得对于任意 $\\bar{n}\\in\\mathbb{N}^{k}$，PA 证明 $\\exists! y\\,\\varphi_{f}(\\bar{\\overline{n}},y)$ 并且 PA 证明 $\\varphi_{f}(\\bar{\\overline{n}},\\overline{f(\\bar{n})})$。这里，$\\overline{n}$ 是数字 $n$ 的数码，即应用 $n$ 次 $S$ 的项 $S(S(\\dots S(0)\\dots))$。\n-   假设事实（哥德尔 β-函数引理）：存在一个 PR 序列编码函数 $\\beta(s,i)$ 和一个有界公式 $\\mathrm{Seq}(s,\\ell)$，其性质在 PA 中可证，允许对任意自然数有限序列进行编码。具体来说，关系 $v = \\beta(s,i)$ 可由算术语言中的一个公式定义，我们将其表示为 $\\psi_{\\beta}(s,i,v)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是科学合理的、定义明确的且客观的。\n-   **科学合理**：该问题是可计算性理论和形式算术研究的核心主题。所给出的定义和假设的引理是这些领域的标准和基础。它不违反任何数学原理。\n-   **定义明确**：该问题要求证明一个公认的定理。步骤清晰，提供的定义足以构建证明。存在唯一且正确的证明。\n-   **客观**：语言形式化且精确。诸如“皮亚诺算术”、“原始递归”和“可表示”等术语在数理逻辑中具有明确的定义。\n\n**步骤 3：结论和行动**\n问题有效。将按要求进行解答。\n\n### PA 中原始递归函数可表示性的证明\n\n我们对原始递归函数类进行结构归纳。\n\n**1. 初始函数的可表示性**\n\n一个函数 $f$ 在 PA 中是可表示的，如果存在一个公式 $\\varphi_f(\\bar{x},y)$，使得 PA 证明 $\\forall \\bar{x} \\exists!y \\varphi_f(\\bar{x},y)$ 并且对于所有 $\\bar{n} \\in \\mathbb{N}^k$，PA 证明 $\\varphi_f(\\bar{\\overline{n}}, \\overline{f(\\bar{n})})$。对于给定的 $\\bar{x}$，$y$ 的存在性和唯一性是至关重要的。\n\n-   **零函数**：$Z(x_{1},\\dots,x_{k})=0$。该函数由公式 $\\varphi_{Z}(\\bar{x},y) \\equiv y=0$ 表示。\n    -   PA 平凡地证明了 $\\forall \\bar{x} \\exists!y (y=0)$，因为 $y$ 必须是 $0$。\n    -   对于任意 $\\bar{n}\\in\\mathbb{N}^k$，$Z(\\bar{n})=0$。我们需要证明 PA 证明 $\\varphi_{Z}(\\bar{\\overline{n}},\\overline{0})$，即 $\\overline{0}=0$。数码 $\\overline{0}$ 是常数符号 $0$，所以这是一个平凡的逻辑真理 $0=0$。\n\n-   **后继函数**：$S(x)=x+1$。该函数由公式 $\\varphi_{S}(x,y) \\equiv y=S(x)$ 表示。\n    -   对于任意项 $t$，PA 证明 $\\exists!y (y=t)$。因此 $\\forall x \\exists!y (y=S(x))$ 是可证的。\n    -   对于任意 $n\\in\\mathbb{N}$，$S(n)=n+1$。我们需要证明 PA 证明 $\\varphi_{S}(\\overline{n},\\overline{n+1})$。这个公式是 $\\overline{n+1} = S(\\overline{n})$。根据数码的定义，$\\overline{n+1}$ 就是项 $S(\\overline{n})$，所以这是陈述 $S(\\overline{n}) = S(\\overline{n})$，一个逻辑恒等式。\n\n-   **投影函数**：$U_{i}^{k}(x_{1},\\dots,x_{k})=x_i$。该函数由公式 $\\varphi_{U_i^k}(\\bar{x},y) \\equiv y=x_i$ 表示。\n    -   PA 证明 $\\forall \\bar{x} \\exists!y (y=x_i)$。\n    -   对于任意 $\\bar{n}=(n_1,\\dots,n_k)\\in\\mathbb{N}^k$，$U_i^k(\\bar{n})=n_i$。我们需要证明 PA 证明 $\\varphi_{U_i^k}(\\bar{\\overline{n}},\\overline{n_i})$，即 $\\overline{n_i}= \\overline{n_i}$，一个逻辑恒等式。\n\n因此，所有初始函数在 PA 中都是可表示的。\n\n**2. 在复合运算下的闭包性**\n\n设 $h(\\bar{x}) = f(g_{1}(\\bar{x}),\\dots,g_{m}(\\bar{x}))$。假设 $f$ 以及对于 $i=1,\\dots,m$ 的每个 $g_i$ 在 PA 中分别由公式 $\\varphi_f(y_1,\\dots,y_m,z)$ 和 $\\varphi_{g_i}(\\bar{x},y_i)$ 表示。我们定义 $h$ 的表示公式为：\n$$ \\varphi_h(\\bar{x},z) \\equiv \\exists y_1 \\dots \\exists y_m \\left( \\bigwedge_{i=1}^{m} \\varphi_{g_i}(\\bar{x}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z) \\right) $$\n我们必须证明这个公式表示 $h$。对于任意数码元组 $\\bar{\\overline{n}}$：\n-   **正确性和存在性**：对每个 $i$ 令 $k_i=g_i(\\bar{n})$，并令 $p=f(k_1,\\dots,k_m)=h(\\bar{n})$。根据 $g_i$ 和 $f$ 的可表示性，PA 证明对每个 $i$ 都有 $\\varphi_{g_i}(\\bar{\\overline{n}},\\overline{k_i})$，并且 PA 证明 $\\varphi_f(\\overline{k_1},\\dots,\\overline{k_m},\\overline{p})$。通过用数码 $\\overline{k_1},\\dots,\\overline{k_m}$ 实例化 $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$ 中的存在量词，我们看到 PA 证明了 $\\varphi_h(\\bar{\\overline{n}},\\overline{p})$。这就建立了正确性并蕴含了 $\\exists z \\varphi_h(\\bar{\\overline{n}},z)$ 的存在性。\n\n-   **唯一性**：假设 PA 证明了 $\\varphi_h(\\bar{\\overline{n}},z_1)$ 和 $\\varphi_h(\\bar{\\overline{n}},z_2)$。我们必须证明 PA 证明 $z_1=z_2$。\n    前提是：\n    $\\exists y_1 \\dots \\exists y_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y_i) \\land \\varphi_f(y_1, \\dots, y_m, z_1))$\n    $\\exists y'_1 \\dots \\exists y'_m (\\bigwedge_i \\varphi_{g_i}(\\bar{\\overline{n}}, y'_i) \\land \\varphi_f(y'_1, \\dots, y'_m, z_2))$\n    根据每个 $g_i$ 的唯一性性质，PA 证明对于任意 $y_i, y'_i$，如果 $\\varphi_{g_i}(\\bar{\\overline{n}},y_i)$ 和 $\\varphi_{g_i}(\\bar{\\overline{n}},y'_i)$ 成立，则 $y_i=y'_i$。因此，PA 证明对于所有 $i=1,\\dots,m$ 都有 $y_i=y'_i$。\n    代入这些等式，第二个前提蕴含 $\\varphi_f(y_1, \\dots, y_m, z_2)$。\n    现在我们有 $\\varphi_f(y_1, \\dots, y_m, z_1)$ 和 $\\varphi_f(y_1, \\dots, y_m, z_2)$。根据 $f$ 的唯一性性质，PA 证明 $z_1=z_2$。\n    因此，PA 证明了 $\\exists! z \\varphi_h(\\bar{\\overline{n}},z)$。可表示函数集在复合运算下是封闭的。\n\n**3. 在原始递归运算下的闭包性**\n\n设 $h$ 由 $f$ 和 $g$ 通过原始递归定义：\n$h(0, \\bar{x}) = f(\\bar{x})$\n$h(S(y), \\bar{x}) = g(y, h(y, \\bar{x}), \\bar{x})$\n假设 $f$ 和 $g$ 可由 $\\varphi_f(\\bar{x},z)$ 和 $\\varphi_g(y,u,\\bar{x},v)$ 表示。值 $h(y,\\bar{x})$ 可以看作一个序列的第 $(y+1)$ 项，该序列的项是递归定义的。我们使用所提供的序列编码机制来形式化这一点。关系 $v=\\beta(s,i)$ 可由公式 $\\psi_{\\beta}(s,i,v)$ 定义。公式 $\\varphi_h(y,\\bar{x},z)$ 陈述了存在一个长度为 $S(y)$（即 $y+1$）的序列 $s$，其第一个元素是 $f(\\bar{x})$，后续元素由 $g$ 生成，而 $z$ 是最后一个元素。\n$$\n\\varphi_h(y,\\bar{x},z) \\equiv \\exists s \\Bigg( \\mathrm{Seq}(s, S(y)) \\land \\exists v_0 \\bigg( \\psi_{\\beta}(s,0,v_0) \\land \\varphi_f(\\bar{x},v_0) \\bigg) \\land \\\\ \\forall i < y \\bigg( \\exists u \\exists v \\Big( \\psi_{\\beta}(s,i,u) \\land \\psi_{\\beta}(s,S(i),v) \\land \\varphi_g(i,u,\\bar{x},v) \\Big) \\bigg) \\land \\psi_{\\beta}(s,y,z) \\Bigg)\n$$\n-   **正确性和存在性**：对于任意 $n_y \\in \\mathbb{N}$ 和 $\\bar{n}_x \\in \\mathbb{N}^k$，考虑有限序列值 $a_i = h(i, \\bar{n}_x)$，其中 $i=0,\\dots,n_y$。根据 β-函数的假设性质，存在一个数 $s_0$ 编码此序列，即 PA 证明对于 $i \\le n_y$ 有 $\\mathrm{Seq}(\\overline{s_0}, S(\\overline{n_y}))$ 和 $\\psi_\\beta(\\overline{s_0}, \\bar{i}, \\overline{a_i})$。根据 $f$ 和 $g$ 的可表示性以及 $h$ 的定义，PA 可以证明该序列满足递归条件。具体来说，PA 证明 $\\varphi_f(\\bar{\\overline{n}_x}, \\overline{a_0})$ 并且对于 $i < n_y$，PA 证明 $\\varphi_g(\\bar{i}, \\overline{a_i}, \\bar{\\overline{n}_x}, \\overline{a_{i+1}})$。因此，PA 证明了 $\\varphi_h(\\overline{n_y}, \\bar{\\overline{n}_x}, \\overline{a_{n_y}})$，其中 $a_{n_y} = h(n_y, \\bar{n}_x)$。这确立了正确性和存在性。\n\n-   **唯一性**：唯一性的证明依赖于对序列编码的唯一性进行归纳。PA 证明，如果两个序列 $s_1$ 和 $s_2$ 都满足 $\\varphi_h$ 中的条件，那么它们必须编码相同的函数值序列。这是因为初始值由 $f$ 唯一确定，后续值由 $g$ 唯一确定。因此，两个序列的最后一个元素必须相等。\n\n因此，可表示函数集在原始递归运算下是封闭的。\n\n**4. 总结**\n由于所有初始函数都是可表示的，并且可表示函数集在复合和原始递归运算下是封闭的，通过对原始递归函数构造的结构归纳，我们可以得出结论：**所有原始递归函数在 PA 中都是可表示的。**\n\n**5. 加法函数的表示公式**\n加法函数 $\\mathrm{add}(x,y)=x+y$ 是原始递归的。它可以如下定义：\n- $\\mathrm{add}(x,0) = x$ （这是由投影函数 $U_1^1(x)=x$ 定义的）\n- $\\mathrm{add}(x,S(y)) = S(\\mathrm{add}(x,y))$ （这是由复合 $S(g(y, \\mathrm{add}(x,y), x))$ 定义的，其中 $g$ 是投影函数 $U_2^3(y,z,x)=z$）\n\n由于符号 $+$ 是 PA 语言中的一个基本符号，并且其行为由公理 $\\forall x(x+0=x)$ 和 $\\forall x\\forall y(x+S(y)=S(x+y))$ 规定，所以表示加法函数的最直接的公式是：\n$$ \\varphi_{\\mathrm{add}}(x,y,z) \\equiv z = x+y $$\n“表示项”是项 `x+y`。\n\n根据问题的要求，最终答案应该是这个表示项。", "answer": "$$\n\\boxed{x+y}\n$$", "id": "3042040"}]}