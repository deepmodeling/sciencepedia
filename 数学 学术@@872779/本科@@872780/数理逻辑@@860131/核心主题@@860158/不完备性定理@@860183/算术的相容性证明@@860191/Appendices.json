{"hands_on_practices": [{"introduction": "在深入探讨对算术的相容性证明之前，我们必须首先牢固掌握我们所研究的系统本身——皮亚诺算术（PA）。这个练习将带你回到最基本的层面，使用 PA 的递归定义来形式化地推导一个我们认为理所当然的算术事实。通过这个过程，你将亲身体验算术是如何在纯粹的逻辑框架内构建起来的。[@problem_id:3039646]", "problem": "在皮亚诺算术 (PA) 中，我们使用一阶语言，其包含常量符号 $0$、表示后继的一元函数符号 $S$，以及二元函数符号 $+$ 和 $\\cdot$。数码是闭项 $\\bar{n}$，其定义为 $\\bar{0} := 0$ 和 $\\bar{n+1} := S(\\bar{n})$。后继公理规定了 $S$ 是单射的且 $S(x) \\neq 0$ 等性质，但对于本任务，您只需关注使用 $+$ 和 $\\cdot$ 的定义方程来操作闭项。加法和乘法通过以下定义方程，以对第二个参数进行原始递归的方式被公理化地给出：\n$$\\forall x\\ (x + 0 = x), \\qquad \\forall x\\,\\forall y\\ (x + S(y) = S(x + y)),$$\n和\n$$\\forall x\\ (x \\cdot 0 = 0), \\qquad \\forall x\\,\\forall y\\ (x \\cdot S(y) = (x \\cdot y) + x).$$\n请解释在PA中，这些方程如何将 $+$ 和 $\\cdot$ 刻画为对第二个参数进行原始递归的函数，即它们通过迭代使用这些方程和数码的定义，唯一地确定了所有数码 $x + y$ 和 $x \\cdot y$ 的值。然后，仅使用 $+$ 的这些定义方程以及数码的定义，推导出项 $\\bar{2} + \\bar{3}$ 的闭式形式，并将其完全化简为一个单独的数码。将您的最终答案写成结果数码 $\\bar{n}$ 的形式。无需进行舍入。", "solution": "问题要求解释皮亚诺算术 (PA) 中给出的加法 ($+$) 和乘法 ($\\cdot$) 的公理化定义如何将这些运算刻画为通过原始递归定义的函数，并要求形式化推导 $\\bar{2} + \\bar{3}$ 的值。\n\n首先，我们来讨论通过原始递归进行的刻画。一个具有 $k+1$ 个参数的函数 $f$ 的原始递归定义模式，是根据一个具有 $k$ 个参数的函数 $g$ 和一个具有 $k+2$ 个参数的函数 $h$ 定义的，如下所示：\n$$f(x_1, \\dots, x_k, 0) = g(x_1, \\dots, x_k)$$\n$$f(x_1, \\dots, x_k, S(y)) = h(x_1, \\dots, x_k, y, f(x_1, \\dots, x_k, y))$$\n这个模式定义了函数 $f$ 在参数为 $0$ 时的值，并根据其在 $y$ 处的值来定义其在 $S(y)$ 处的值。由于每个自然数要么是 $0$，要么是另一个自然数的后继，因此这就对其最后一个参数上的所有自然数递归地定义了该函数。\n\n在此背景下，让我们审视加法和乘法的定义方程。变量 $x$ 和 $y$ 被理解为在结构的论域（对于 PA 来说是自然数）上取值。数码 $\\bar{n}$ 是 PA 语言中表示自然数的形式项。\n\n对于加法，我们将该运算表示为函数 $f_+(x, y) = x+y$。其定义方程为：\n1. $\\forall x\\ (x + 0 = x)$\n2. $\\forall x\\,\\forall y\\ (x + S(y) = S(x + y))$\n\n这符合 $k=1$（一个参数 $x$）的原始递归模式。\n基本情况是第二个参数为 $0$：$x+0 = x$。这符合 $f_+(x, 0) = g(x)$ 的形式，其中 $g(x) = x$ 是恒等函数。\n递归步骤是第二个参数为后继 $S(y)$：$x+S(y) = S(x+y)$。这符合 $f_+(x, S(y)) = h(x, y, f_+(x, y))$ 的形式。这里，$f_+(x, y)$ 是 $x+y$，右侧是 $S(x+y)$。所以函数 $h$ 是 $h(x, y, z) = S(z)$，其中 $z = f_+(x, y)$。函数 $h$ 仅仅是将后继函数应用于递归前一步的结果。由于恒等函数和后继函数是构建所有原始递归函数的基本函数，因此加法确实是通过原始递归定义的。\n\n对于乘法，我们将该运算表示为函数 $f_\\cdot(x, y) = x \\cdot y$。其定义方程为：\n1. $\\forall x\\ (x \\cdot 0 = 0)$\n2. $\\forall x\\,\\forall y\\ (x \\cdot S(y) = (x \\cdot y) + x)$\n\n这也符合 $k=1$ 的原始递归模式。\n基本情况是第二个参数为 $0$：$x \\cdot 0 = 0$。这符合 $f_\\cdot(x, 0) = g(x)$ 的形式，其中 $g(x) = 0$ 是常数零函数。\n递归步骤是第二个参数为后继 $S(y)$：$x \\cdot S(y) = (x \\cdot y) + x$。这符合 $f_\\cdot(x, S(y)) = h(x, y, f_\\cdot(x, y))$ 的形式。这里，$f_\\cdot(x, y)$ 是 $x \\cdot y$，右侧是 $(x \\cdot y) + x$。所以函数 $h$ 是 $h(x, y, z) = z+x$，其中 $z = f_\\cdot(x, y)$。函数 $h$ 使用了加法运算，而我们已经证明加法是原始递归的。这是一个有效的构造，因此乘法也是通过原始递归定义的。\n\n这种递归结构确保了对于任意两个数码，例如 $\\bar{m}$ 和 $\\bar{n}$，项 $\\bar{m} + \\bar{n}$ 和 $\\bar{m} \\cdot \\bar{n}$ 的值都是唯一确定的。求值过程通过重复应用递归规则进行，这会降低第二个参数中数码的复杂性。由于任何 $n > 0$ 的数码 $\\bar{n}$ 都可以写成 $S(S(...S(0)...))$（$n$ 次），因此递归在 $n$ 步后，当第二个参数达到基本情况 $\\bar{0}$ 时，保证会终止。\n\n现在，我们将仅使用数码的定义和加法的定义方程来推导项 $\\bar{2} + \\bar{3}$ 的闭式形式。\n\n首先，我们确定所涉及数码的定义：\n$\\bar{0} := 0$\n$\\bar{1} := S(\\bar{0})$\n$\\bar{2} := S(\\bar{1}) = S(S(\\bar{0}))$\n$\\bar{3} := S(\\bar{2}) = S(S(S(\\bar{0})))$\n$\\bar{4} := S(\\bar{3})$\n$\\bar{5} := S(\\bar{4})$\n\n推导过程如下：\n$$ \\bar{2} + \\bar{3} = \\bar{2} + S(\\bar{2}) \\quad (\\text{根据 $\\bar{3}$ 的定义}) $$\n我们应用加法的第二条公理 $\\forall x\\,\\forall y\\ (x + S(y) = S(x + y))$，令 $x = \\bar{2}$ 且 $y = \\bar{2}$：\n$$ \\bar{2} + S(\\bar{2}) = S(\\bar{2} + \\bar{2}) $$\n现在我们必须计算内部的项 $\\bar{2} + \\bar{2}$：\n$$ \\bar{2} + \\bar{2} = \\bar{2} + S(\\bar{1}) \\quad (\\text{根据 $\\bar{2}$ 的定义}) $$\n再次应用加法的第二条公理，令 $x = \\bar{2}$ 且 $y = \\bar{1}$：\n$$ \\bar{2} + S(\\bar{1}) = S(\\bar{2} + \\bar{1}) $$\n接下来，我们计算 $\\bar{2} + \\bar{1}$：\n$$ \\bar{2} + \\bar{1} = \\bar{2} + S(\\bar{0}) \\quad (\\text{根据 $\\bar{1}$ 的定义}) $$\n应用加法的第二条公理，令 $x = \\bar{2}$ 且 $y = \\bar{0}$：\n$$ \\bar{2} + S(\\bar{0}) = S(\\bar{2} + \\bar{0}) $$\n最后，我们计算 $\\bar{2} + \\bar{0}$。为此，我们使用加法的第一条公理 $\\forall x\\ (x+0=x)$，令 $x = \\bar{2}$：\n$$ \\bar{2} + \\bar{0} = \\bar{2} $$\n现在我们将我们的结果代回到原始表达式中：\n$$ \\bar{2} + \\bar{3} = S(\\bar{2} + \\bar{2}) = S(S(\\bar{2} + \\bar{1})) = S(S(S(\\bar{2} + \\bar{0}))) = S(S(S(\\bar{2}))) $$\n问题要求将此化简为 $\\bar{n}$ 形式的单个数码。我们使用数码的定义 $\\overline{k+1} = S(\\bar{k})$ 来化简表达式：\n$$ S(\\bar{2}) = \\bar{3} $$\n$$ S(S(\\bar{2})) = S(\\bar{3}) = \\bar{4} $$\n$$ S(S(S(\\bar{2}))) = S(\\bar{4}) = \\bar{5} $$\n因此，推导的结果是数码 $\\bar{5}$。\n$$ \\bar{2} + \\bar{3} = \\bar{5} $$", "answer": "$$\\boxed{\\bar{5}}$$", "id": "3039646"}, {"introduction": "Gentzen 证明中的一个关键创举是使用超限序数来度量证明的复杂性。为了理解这个证明，我们必须熟悉序数算术的独特规则，尤其是它与我们直觉的有限算术有何不同。这个练习将指导你通过序数加法和乘法的递归定义，来计算一些揭示其非交换性质的关键例子。[@problem_id:3039662]", "problem": "在 Gentzen 对皮亚诺算术 (PA) 的相容性证明中，归约是通过低于 $\\varepsilon_{0}$ 的序数来度量的，其中使用了由超限递归定义的序数算术。从 von Neumann 的序数定义和序数上的超限递归定理出发，完成以下任务：\n\n1. 通过为每个运算指定基础、后继和极限条款来定义序数加法、乘法和幂运算。您的定义必须以关于第二个（右）参数的递归条款形式给出。\n\n2. 仅使用您的定义和 von Neumann 序数的基本性质（特别是，一个序数集合的上确界是它们的并集），将以下表达式计算并简化为标准序数表示法：\n   - $\\omega + 1$,\n   - $1 + \\omega$,\n   - $\\omega \\cdot 2$.\n\n将您的最终结果以单个行向量的形式表示，顺序为 $(\\omega+1,\\;1+\\omega,\\;\\omega\\cdot 2)$。最终答案必须是单个表达式。不需要四舍五入，也不涉及单位。", "solution": "该问题是有效的，因为它是良定的，其科学基础根植于数理逻辑和集合论的原理，并且包含了得出严格解所需的所有信息。\n\n该问题的基础是 von Neumann 的序数定义，其中每个序数 $\\alpha$ 是所有比它小的序数的集合，即 $\\alpha = \\{\\beta \\mid \\beta  \\alpha\\}$。一个序数 $\\alpha$ 的后继是 $\\alpha+1 = \\alpha \\cup \\{\\alpha\\}$。一个非零且不是后继的序数是极限序数。第一个无限序数 $\\omega$ 是所有有限序数的集合，$\\omega = \\{0, 1, 2, \\dots\\}$。由此定义导出的一个关键性质是，对于任何序数集合 $S$，其上确界 $\\sup(S)$ 是它们的并集 $\\bigcup S$。\n\n**1. 序数运算的定义**\n\n序数加法、乘法和幂运算是通过对第二个（右）参数进行超限递归来定义的。设 $\\alpha$ 和 $\\beta$ 为序数。\n\n*序数加法 ($\\alpha + \\beta$):*\n1.  **基础情况 (${\\beta = 0}$):** $\\alpha + 0 = \\alpha$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha + (\\gamma + 1) = (\\alpha + \\gamma) + 1$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** $\\alpha + \\beta = \\sup\\{\\alpha + \\delta \\mid \\delta  \\beta\\}$。\n\n*序数乘法 ($\\alpha \\cdot \\beta$):*\n1.  **基础情况 (${\\beta = 0}$):** $\\alpha \\cdot 0 = 0$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha \\cdot (\\gamma + 1) = (\\alpha \\cdot \\gamma) + \\alpha$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** $\\alpha \\cdot \\beta = \\sup\\{\\alpha \\cdot \\delta \\mid \\delta  \\beta\\}$。\n\n*序数幂运算 ($\\alpha^\\beta$):*\n1.  **基础情况 (${\\beta = 0}$):** $\\alpha^0 = 1$。\n2.  **后继情况 (${\\beta = \\gamma + 1}$):** $\\alpha^{\\gamma+1} = \\alpha^\\gamma \\cdot \\alpha$。\n3.  **极限情况 (${\\beta}$ 是极限序数):** 对于 $\\alpha > 0$，$\\alpha^\\beta = \\sup\\{\\alpha^\\delta \\mid \\delta  \\beta\\}$。对于 $\\alpha = 0$，若 $\\beta > 0$ 则 $0^\\beta = 0$。\n\n**2. 表达式的计算与简化**\n\n我们现在仅使用这些定义和 von Neumann 序数的指定性质来计算给定的表达式。\n\n*计算 ${\\omega + 1}$*\n此表达式涉及 $\\omega$ 与后继序数 $1$ 的加法。由于 $1$ 被定义为 $0$ 的后继，即 $1 = 0+1$，我们可以应用加法的后继条款，令 $\\alpha = \\omega$ 并使用 $1=\\gamma+1$（其中 $\\gamma=0$）：\n$$ \\omega + 1 = \\omega + (0 + 1) = (\\omega + 0) + 1 $$\n根据加法的基础条款，$\\alpha + 0 = \\alpha$，所以 $\\omega + 0 = \\omega$。将其代回得到：\n$$ (\\omega + 0) + 1 = \\omega + 1 $$\n表达式 $\\omega + 1$ 已经是其标准的简化形式。它表示序数 $\\omega$ 的直接后继。\n\n*计算 ${1 + \\omega}$*\n此表达式涉及将极限序数 $\\omega$ 作为第二个参数。我们使用加法的极限条款，令 $\\alpha=1$ 且 $\\beta=\\omega$：\n$$ 1 + \\omega = \\sup\\{1 + \\delta \\mid \\delta  \\omega\\} $$\n满足 $\\delta  \\omega$ 的序数 $\\delta$ 是有限序数 $n \\in \\{0, 1, 2, \\dots\\}$。因此，上确界中的集合是 $\\{1+0, 1+1, 1+2, \\dots, 1+n, \\dots\\}$。对于有限序数，序数加法与标准算术一致，所以这个集合是 $\\{1, 2, 3, \\dots, n+1, \\dots\\}$。\n这个序数集合的上确界是大于或等于集合中每个元素的最小序数。利用上确界是并集这一性质：\n$$ \\sup\\{1, 2, 3, \\dots\\} = \\bigcup\\{\\{0\\}, \\{0,1\\}, \\{0,1,2\\}, \\dots\\} $$\n这些集合的并集是 $\\{0, 1, 2, \\dots\\}$，这正是 $\\omega$ 的定义。\n因此，简化的结果是：\n$$ 1 + \\omega = \\omega $$\n\n*计算 ${\\omega \\cdot 2}$*\n此表达式涉及与后继序数 $2$ 的乘法。我们将 $2$ 写为 $1+1$，并应用乘法的后继条款，令 $\\alpha = \\omega$ 并使用 $2=\\gamma+1$（其中 $\\gamma=1$）：\n$$ \\omega \\cdot 2 = \\omega \\cdot (1+1) = (\\omega \\cdot 1) + \\omega $$\n为了计算它，我们首先必须计算 $\\omega \\cdot 1$。我们再次使用后继条款，由于 $1 = 0+1$，令 $\\gamma=0$：\n$$ \\omega \\cdot 1 = \\omega \\cdot (0+1) = (\\omega \\cdot 0) + \\omega $$\n根据乘法的基础条款，$\\alpha \\cdot 0 = 0$，所以 $\\omega \\cdot 0 = 0$。这得到：\n$$ \\omega \\cdot 1 = 0 + \\omega $$\n现在我们计算 $0+\\omega$。由于 $\\omega$ 是极限序数，我们使用加法的极限条款：\n$$ 0 + \\omega = \\sup\\{0 + \\delta \\mid \\delta  \\omega\\} $$\n由于 $0$ 是序数的加法单位元，对于任何序数 $\\delta$，$0+\\delta = \\delta$。因此：\n$$ 0 + \\omega = \\sup\\{\\delta \\mid \\delta  \\omega\\} = \\sup\\{0, 1, 2, \\dots\\} = \\omega $$\n将其代回，我们发现 $\\omega \\cdot 1 = \\omega$。\n最后，我们将其代入 $\\omega \\cdot 2$ 的表达式中：\n$$ \\omega \\cdot 2 = (\\omega \\cdot 1) + \\omega = \\omega + \\omega $$\n表达式 $\\omega + \\omega$ 表示的序数具有将两个 $\\omega$ 的副本一个接一个放置所得到的序型。这正是标准表示法 $\\omega \\cdot 2$ 所代表的。因此，计算证实了该等式，简化的表达式是 $\\omega \\cdot 2$。\n\n最终结果是 $(\\omega+1, \\omega, \\omega \\cdot 2)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\omega+1  \\omega  \\omega \\cdot 2\n\\end{pmatrix}\n}\n$$", "id": "3039662"}, {"introduction": "现在我们将把前面的概念结合起来，观察 Gentzen 策略的核心机制。这个练习将让你对一个包含“切”规则的实际证明进行一步“切消减”，然后计算变换前后证明的序数度量。通过直接计算并看到序数的减小，你将具体地理解相容性证明是如何通过确保证明“简化”过程的终止来运作的。[@problem_id:3039618]", "problem": "考虑在 Gentzen 风格的一阶算术相容性证明中使用的切除消去框架，并在 Gentzen 的直觉主义相继式演算 (LJ) 中进行操作。使用以下基本数据。\n\n- 公式的阶（逻辑复杂度）$\\rho(\\cdot)$ 通过对公式的递归定义：对于原子公式 $A$，$\\rho(A)=0$；对于像合取这样的二元联结词，$\\rho(A \\land B)=\\max\\{\\rho(A),\\rho(B)\\}+1$。\n- 序数取小于 $\\epsilon_{0}$ 的值，使用序数加法和乘法写成 Cantor 范式。使用通常的序数定律：$\\omega^{0}=1$，序数加法和乘法满足结合律，对于有限的 $m,n \\in \\mathbb{N}$，$m+n$ 是普通整数加法，$\\omega \\cdot m$ 表示与有限数 $m$ 的右乘法。\n- 通过对最后一步推理的递归，为推导 $\\mathcal{D}$ 定义一个序数赋值 $o(\\mathcal{D})$：\n  1. 如果 $\\mathcal{D}$ 是一个初始公理 $A \\vdash A$，那么 $o(\\mathcal{D})=1$。\n  2. 如果 $\\mathcal{D}$ 的最后一步推理是单前提非切除规则（结构性或逻辑性），其直接子推导为 $\\mathcal{D}_{1}$，那么 $o(\\mathcal{D})=o(\\mathcal{D}_{1})+1$。\n  3. 如果 $\\mathcal{D}$ 的最后一步推理是双前提非切除规则（例如，$\\land$-右规则），其直接子推导为 $\\mathcal{D}_{1}$ 和 $\\mathcal{D}_{2}$，那么 $o(\\mathcal{D})=\\max\\{o(\\mathcal{D}_{1}),o(\\mathcal{D}_{2})\\}+1$。\n  4. 如果 $\\mathcal{D}$ 的最后一步推理是关于公式 $C$ 的切除，其直接子推导为 $\\mathcal{D}_{L}$ 和 $\\mathcal{D}_{R}$，那么\n  $$o(\\mathcal{D}) \\;=\\; \\omega^{\\rho(C)} \\cdot \\bigl(o(\\mathcal{D}_{L}) + o(\\mathcal{D}_{R})\\bigr) + 1.$$\n\n构造以下具体推导 $\\mathcal{D}$，它在公式 $P \\land Q$ 上使用单次切除，其中 $P$ 和 $Q$ 是原子公式：\n\n- 左前提 $\\mathcal{D}_{L}$ 推导出 $P,Q \\vdash P \\land Q$，方法是首先使用左弱化从初始公理 $P \\vdash P$ 和 $Q \\vdash Q$ 推导出 $P,Q \\vdash P$ 和 $P,Q \\vdash Q$，然后应用 $\\land$-右规则。\n- 右前提 $\\mathcal{D}_{R}$ 通过对初始公理 $P \\vdash P$ 应用 $\\land$-左$_1$ 规则来推导出 $P \\land Q \\vdash P$。\n- 通过在 $P \\land Q$ 上对 $\\mathcal{D}_{L}$ 和 $\\mathcal{D}_{R}$ 进行切除，得出结论 $P,Q \\vdash P$。\n\n然后，当右前提以 $\\land$-左$_1$ 结尾时，对 LJ 中合取式上的切除执行单步标准切除-消去步骤：将切除推到 $\\land$-左$_1$ 规则下方，用对 $P$ 的切除替换对 $P \\land Q$ 的切除，并使用 $\\mathcal{D}_{L}$ 中推导出 $P,Q \\vdash P$ 的相应左子推导。\n\n使用上述序数赋值，明确计算：\n- 消去前的序数量度 $o(\\mathcal{D})$（即，对 $P \\land Q$ 的单切除推导）。\n- 单步切除-消去后的序数量度 $o(\\mathcal{D}')$（即，得到的对 $P$ 的单切除推导）。\n\n将两个量度都以 Cantor 范式给出。你的最终答案必须是这两个序数表达式的有序对，写成一个行矩阵。无需舍入。", "solution": "该问题已被确认为数理逻辑（证明论）领域内一个良定、自洽且有科学依据的问题。所有必要的定义和条件均已提供，任务是将这些定义直接应用于一个具体例子。因此，我们将着手进行解答。\n\n问题要求计算两个序数量度 $o(\\mathcal{D})$ 和 $o(\\mathcal{D}')$，分别对应于一个逻辑推导在切除-消去步骤之前和之后的情况。框架是 Gentzen 的直觉主义相继式演算 LJ。\n\n首先，我们计算初始推导的序数 $o(\\mathcal{D})$。推导 $\\mathcal{D}$ 通过对公式 $P \\land Q$ 的切除得出 $P,Q \\vdash P$。其结构如下：\n$$\n\\mathcal{D} = \\frac{\n  \\mathcal{D}_{L}: P,Q \\vdash P \\land Q\n  \\quad\n  \\mathcal{D}_{R}: P \\land Q \\vdash P\n}{P,Q \\vdash P} (\\text{对 } P \\land Q \\text{ 切除})\n$$\n我们必须计算子推导 $\\mathcal{D}_L$ 和 $\\mathcal{D}_R$ 的序数。\n\n左前提 $\\mathcal{D}_L$ 使用 $\\land$-右规则作用于两个子推导（我们称之为 $\\mathcal{D}_{LP}$ 和 $\\mathcal{D}_{LQ}$）来推导出 $P,Q \\vdash P \\land Q$：\n$$\n\\mathcal{D}_L = \\frac{\n  \\mathcal{D}_{LP}: P,Q \\vdash P\n  \\quad\n  \\mathcal{D}_{LQ}: P,Q \\vdash Q\n}{P,Q \\vdash P \\land Q} (\\land\\text{-右})\n$$\n- $\\mathcal{D}_{LP}$ 是通过对公理 $P \\vdash P$ 应用左弱化规则形成的。设 $\\mathcal{A}_P$ 是 $P \\vdash P$ 的公理推导。根据所给规则，$o(\\mathcal{A}_P) = 1$。弱化是单前提非切除规则，因此根据规则2，$o(\\mathcal{D}_{LP}) = o(\\mathcal{A}_P) + 1 = 1 + 1 = 2$。\n- 类似地，$\\mathcal{D}_{LQ}$ 是通过对公理 $Q \\vdash Q$ 应用左弱化规则形成的。设 $\\mathcal{A}_Q$ 是 $Q \\vdash Q$ 的公理推导，则 $o(\\mathcal{A}_Q) = 1$。那么 $o(\\mathcal{D}_{LQ}) = o(\\mathcal{A}_Q) + 1 = 1 + 1 = 2$。\n$\\land$-右规则是双前提非切除规则。根据规则3，$\\mathcal{D}_L$ 的序数为：\n$$o(\\mathcal{D}_L) = \\max\\{o(\\mathcal{D}_{LP}), o(\\mathcal{D}_{LQ})\\} + 1 = \\max\\{2, 2\\} + 1 = 2 + 1 = 3$$\n\n右前提 $\\mathcal{D}_R$ 通过对公理 $P \\vdash P$ 应用 $\\land$-左$_1$ 规则推导出 $P \\land Q \\vdash P$。这是一个单前提非切除规则。根据规则2：\n$$o(\\mathcal{D}_R) = o(\\mathcal{A}_P) + 1 = 1 + 1 = 2$$\n\n现在我们计算使用切除规则的完整推导 $\\mathcal{D}$ 的序数。我们首先需要切除公式 $C = P \\land Q$ 的阶。由于 $P$ 和 $Q$ 是原子的，$\\rho(P) = 0$ 且 $\\rho(Q) = 0$。阶定义为 $\\rho(P \\land Q) = \\max\\{\\rho(P), \\rho(Q)\\} + 1 = \\max\\{0, 0\\} + 1 = 1$。\n对切除使用规则4：\n$$o(\\mathcal{D}) = \\omega^{\\rho(P \\land Q)} \\cdot \\bigl(o(\\mathcal{D}_{L}) + o(\\mathcal{D}_{R})\\bigr) + 1$$\n代入计算出的值：\n$$o(\\mathcal{D}) = \\omega^{1} \\cdot (3 + 2) + 1$$\n对于有限序数，加法是标准加法。所以，$3 + 2 = 5$。\n$$o(\\mathcal{D}) = \\omega \\cdot 5 + 1$$\n此表达式是 Cantor 范式。\n\n接下来，我们分析消去后的推导 $\\mathcal{D}'$。对于右前提是 $\\land$-左$_1$ 规则结论的合取式上的切除，其切除-消去步骤将对 $P \\land Q$ 的切除替换为一个新的、更简单的切除。原始推导是：\n$$ \\frac{ \\frac{P,Q \\vdash P \\quad P,Q \\vdash Q}{P,Q \\vdash P \\land Q} (\\land\\text{-右}) \\qquad \\frac{P \\vdash P}{P \\land Q \\vdash P} (\\land\\text{-左}_1) }{P,Q \\vdash P} (\\text{对 } P \\land Q \\text{ 切除}) $$\n消去步骤将其替换为一个推导 $\\mathcal{D}'$，它将原始 $\\land$-右规则的左前提（$\\mathcal{D}_{LP}: P,Q \\vdash P$）与原始 $\\land$-左$_1$ 规则的前提（$\\mathcal{A}_P: P \\vdash P$）进行切除。新的切除作用于一个更简单的公式 $P$。\n消去后的推导 $\\mathcal{D}'$ 是：\n$$\n\\mathcal{D}' = \\frac{ \\mathcal{D}_{LP}: P,Q \\vdash P \\qquad \\mathcal{A}_P: P \\vdash P }{P,Q \\vdash P} (\\text{对 } P \\text{ 切除})\n$$\n我们使用规则4计算序数 $o(\\mathcal{D}')$。\n- 新的切除公式是 $P$。它的阶是 $\\rho(P) = 0$。\n- 新切除的左前提是 $\\mathcal{D}_{LP}$，我们已经算出 $o(\\mathcal{D}_{LP}) = 2$。\n- 新切除的右前提是公理 $\\mathcal{A}_P$，其 $o(\\mathcal{A}_P) = 1$。\n应用序数的切除规则：\n$$o(\\mathcal{D}') = \\omega^{\\rho(P)} \\cdot \\bigl(o(\\mathcal{D}_{LP}) + o(\\mathcal{A}_P)\\bigr) + 1 = \\omega^{0} \\cdot (2 + 1) + 1$$\n使用序数定律 $\\omega^0 = 1$：\n$$o(\\mathcal{D}') = 1 \\cdot (3) + 1 = 3 + 1 = 4$$\n数字 $4$ 是一个有限序数，并且是 Cantor 范式。\n\n计算出的序数对是 $(o(\\mathcal{D}), o(\\mathcal{D}')) = (\\omega \\cdot 5 + 1, 4)$。正如所料，序数量度在消去步骤后严格减小，因为 $\\omega \\cdot 5 + 1 > 4$。", "answer": "$$\\boxed{\\begin{pmatrix} \\omega \\cdot 5 + 1  4 \\end{pmatrix}}$$", "id": "3039618"}]}