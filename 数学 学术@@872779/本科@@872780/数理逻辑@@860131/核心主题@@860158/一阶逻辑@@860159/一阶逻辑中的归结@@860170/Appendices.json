{"hands_on_practices": [{"introduction": "归结原理只适用于一种称为子句范式的特定公式格式。本练习将引导你完成一个系统的、多步骤的过程，将一个标准的一阶逻辑语句转换为这种必需的格式[@problem_id:3050816]。掌握这个转换过程对于使用任何基于归结的自动定理证明器来说，都是至关重要的第一步。", "problem": "设 $\\Phi$ 为一阶逻辑（FOL）中的一阶句子，其形式为\n$$\n\\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big).\n$$\n从一阶逻辑的基本等价变换（蕴含消除、使用量词定律移至前束范式，以及通过一个 Skolem 函数替换每个存在量化变量，该函数依赖于其作用域内的所有全称量化变量的Skolem化）出发，对 $\\Phi$ 进行完整的子句转换，将其化为合取范式（CNF）。这依次包括：消除蕴含，内移否定，产生前束范式，变量标准化（区分不同变量），用具有正确依赖关系的 Skolem 符号对存在量词进行 Skolem 化，去掉全称量词，分配为 CNF，最后形成子句集，其中子句间的变量已经标准化（区分开），并且移除了重复的文字和重言式子句。\n\n计算所得子句集中的不同子句总数。将最终答案以单个整数形式给出。", "solution": "问题要求对给定的一阶逻辑（FOL）句子 $\\Phi$ 进行子句转换，并确定所得集合中的子句数量。这个问题定义明确，并基于数理逻辑的原理。我将按照指定的转换步骤顺序进行求解。\n\n初始的 FOL 句子是：\n$$ \\Phi \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(R(y,z)\\rightarrow R(x,z))\\big) $$\n\n第一步是消除蕴含。子公式 $R(y,z)\\rightarrow R(x,z)$ 使用等价式 $A \\rightarrow B \\equiv \\neg A \\lor B$ 进行转换。应用此规则后，句子变为：\n$$ \\Phi_1 \\equiv \\forall x\\,\\exists y\\,\\big(R(x,y)\\,\\land\\,\\forall z\\,(\\neg R(y,z)\\lor R(x,z))\\big) $$\n\n第二步是内移否定。在 $\\Phi_1$ 中，唯一的否定符号 $\\neg$ 已经直接作用于原子公式 $R(y,z)$。因此，此步骤无需更改。\n\n第三步是将公式转换为前束范式，即将所有量词移到最前面。在 $\\Phi_1$ 中，量词 $\\forall z$ 在合取的作用域内。变量 $z$ 在第一个合取项 $R(x,y)$ 中不是自由变量。因此，我们可以使用等价式 $P \\land (\\forall z\\,Q(z)) \\equiv \\forall z\\,(P \\land Q(z))$（其中 $z$ 在 $P$ 中不是自由变量）将量词 $\\forall z$ 外移。应用此规则得到：\n$$ \\Phi_2 \\equiv \\forall x\\,\\exists y\\,\\forall z\\,\\big(R(x,y)\\,\\land\\,(\\neg R(y,z)\\lor R(x,z))\\big) $$\n此公式现在是前束范式。\n\n第四步是变量标准化（区分变量）。在 $\\Phi_2$ 中，每个量词（$\\forall x$, $\\exists y$, $\\forall z$）都绑定一个唯一的变量名。此阶段无需重命名。\n\n第五步是 Skolem 化，即消除存在量词。句子 $\\Phi_2$ 有一个存在量词 $\\exists y$。变量 $y$ 在全称量词 $\\forall x$ 的作用域内。因此，我们将 $y$ 替换为一个以 $x$ 为变量的 Skolem 函数。设此函数用符号 $f$ 表示。我们将所有出现的 $y$ 替换为 $f(x)$ 并移除量词 $\\exists y$。所得公式为：\n$$ \\Phi_3 \\equiv \\forall x\\,\\forall z\\,\\big(R(x,f(x))\\,\\land\\,(\\neg R(f(x),z)\\lor R(x,z))\\big) $$\n\n第六步是去掉所有全称量词。变量 $x$ 和 $z$ 现在被视为隐式全称量化的。这给我们留下了无量词的母式：\n$$ M \\equiv R(x,f(x))\\,\\land\\,(\\neg R(f(x),z)\\lor R(x,z)) $$\n\n第七步是将母式 $M$ 转换为合取范式（CNF）。公式 $M$ 已经是 CNF，因为它是一个由两个子句组成的合取式。第一个子句是文字 $R(x,f(x))$，第二个子句是两个文字的析取 $\\neg R(f(x),z)\\lor R(x,z)$。无需进一步分配。\n\n第八步是形成子句集。从 CNF 公式 $M$ 中，我们提取出子句。子句集为：\n$$ S = \\{ \\{R(x,f(x))\\}, \\{\\neg R(f(x),z), R(x,z)\\} \\} $$\n\n第九步是对子句间的变量进行标准化。在集合 $S$ 中，变量 $x$ 出现在两个子句中。在一个子句集中，变量是其各自子句的局部变量。为了明确这一点，我们重命名变量，使得没有两个子句共享一个变量名。让我们将第一个子句中的变量 $x$ 重命名为 $v_1$，并将第二个子句中的变量 $x$ 和 $z$ 分别重命名为 $v_2$ 和 $v_3$。所得子句集为：\n$$ S' = \\{ \\{R(v_1,f(v_1))\\}, \\{\\neg R(f(v_2),v_3), R(v_2,v_3)\\} \\} $$\n\n第十步是从集合中移除子句内的任何重复文字和任何重言式子句。\n- 第一个子句 $\\{R(v_1,f(v_1))\\}$ 只包含一个文字，并且不是重言式。\n- 第二个子句 $\\{\\neg R(f(v_2),v_3), R(v_2,v_3)\\}$ 由两个不同的文字组成。它不是重言式，因为一个子句是重言式当且仅当它包含一个文字及其精确的补（例如，$L$ 和 $\\neg L$）。这里的文字是 $\\neg R(f(v_2),v_3)$ 和 $R(v_2,v_3)$，它们互不为补，因为它们的参数不同。\n因此，子句集 $S'$ 已经是其最终的简化形式。\n\n最后一步是计算所得集合 $S'$ 中不同子句的总数。该集合包含两个不同的子句：\n1. $C_1 = \\{R(v_1,f(v_1))\\}$\n2. $C_2 = \\{\\neg R(f(v_2),v_3), R(v_2,v_3)\\}$\n因此，子句的总数为 $2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3050816"}, {"introduction": "一阶归结的核心引擎是合一（unification），即寻找一个替换使得两个项在语法上变得相同的过程。本练习聚焦于一个关键的细节：“出现检查”（occurs check），它防止了无限循环的定义并确保了合一过程的正确终止[@problem_id:3050868]。理解这一点是掌握为何某些看似相似的项无法合一的关键。", "problem": "在含函数符号和变量的一阶逻辑中，归结（resolution）依赖于合一（unify）项的能力。合一试图找到一个代换（substitution），使得两个项在语法上相同，此过程受出现检查（occurs check）的约束，该检查禁止将一个变量指派给一个包含该变量的项。给定一个项集 $\\{f(x,x), f(g(y), y)\\}$，其语言包含一元函数符号 $g$、二元函数符号 $f$ 以及变量 $x$ 和 $y$。请通过系统地尝试求解其对应子项所导出的方程，并识别任何对出现检查的违反，来确定这两个项在出现检查下是否是可合一的。如果它们是可合一的，请以集合表示法 $\\{x \\mapsto t_{x}, y \\mapsto t_{y}\\}$ 的形式，提供作为单一代换的最概括合一（Most General Unifier, MGU）。如果它们在出现检查下不可合一，你的最终答案必须是空集 $\\varnothing$，以表示合一集为空。最终答案必须是单一的符号数学表达式。", "solution": "该问题要求确定项 $f(x,x)$ 和 $f(g(y), y)$ 在出现检查（occurs check）的约束下是否是可合一的。合一（Unification）是找到一个变量代换，使两个逻辑表达式在语法上相同的过程。如果存在这样的代换，这些项就是可合一的；否则，它们就不是。最概括合一（MGU）是比任何其他合一更具一般性的代换。\n\n我们首先建立这两个项之间的方程：\n$$f(x,x) = f(g(y), y)$$\n\n合一算法通过分解初始方程来进行。由于两边最外层的函数符号相同（都是 $f$），我们可以令它们各自的参数相等。这会产生一个包含两个联立方程的方程组：\n1. $$x = g(y)$$\n2. $$x = y$$\n\n必须求解这个方程组 $\\{x = g(y), x = y\\}$ 以找到一个一致的代换。我们可以尝试用一个方程代入另一个方程来求解这个系统。\n\n让我们使用第二个方程 $x = y$。这个方程建议一个代换，即用 $y$ 替换 $x$ 或用 $x$ 替换 $y$。我们选择代换 $\\sigma_1 = \\{x \\mapsto y\\}$。我们将此代换应用于第一个方程 $x = g(y)$。\n\n将 $\\sigma_1$ 应用于第一个方程的左侧 $x$，结果为 $y$。\n将 $\\sigma_1$ 应用于右侧 $g(y)$，结果为 $g(y)$（因为变量 $x$ 没有出现）。\n\n这将第一个方程转换为：\n$$y = g(y)$$\n\n现在我们有一个新的方程需要求解。根据合一规则，形式为 $V = T$ 的方程（其中 $V$ 是一个变量，$T$ 是一个项）可以通过代换 $\\{V \\mapsto T\\}$ 来解决。然而，这仅在变量 $V$ 不出现在项 $T$ 中的情况下才被允许。这个条件被称为出现检查（occurs check）。\n\n在我们导出的方程 $y = g(y)$ 中，要被代换的变量是 $y$，项是 $g(y)$。我们必须执行出现检查：变量 $y$ 是否出现在项 $g(y)$ 中？是的，它很明显出现在其中。\n\n代换 $\\{y \\mapsto g(y)\\}$ 会导致无限回归。用 $g(y)$ 替换 $y$ 会得到 $g(y) = g(g(y))$，再次应用代换后会简化为 $y = g(y)$，如此循环往复。这代表了试图将一个变量与一个包含该变量自身的项进行合一，从而会创建一个在标准一阶逻辑中不允许的无限项。\n\n因为变量 $y$ 出现在项 $g(y)$ 中，所以出现检查失败。此步骤中出现检查的失败意味着不存在能使原始方程组一致的有限代换。\n\n因此，合一过程以失败告终。项 $f(x,x)$ 和 $f(g(y), y)$ 是不可合一的。因此，合一集是空集。", "answer": "$$\\boxed{\\varnothing}$$", "id": "3050868"}, {"introduction": "现在，是时候将所有知识融会贯通了。本练习提供了一个子句集，要求你给出一个完整的归结反驳，即推导出空子句 $\\Box$ [@problem_id:3050890]。这个练习模拟了基于归结的定理证明器的完整工作流程，它结合了合一与归结规则，最终证明给定子句集的不可满足性。", "problem": "设 $\\mathcal{L}$ 是一个一阶语言，包含一个常量符号 $a$、一个一元函数符号 $f$ 和一个一元谓词符号 $P$。考虑以下子句形式的子句集：\n- $C_{1}: P(a)$,\n- $C_{2}: \\lnot P(x) \\lor P(f(x))$,\n- $C_{3}: \\lnot P(f(f(a)))$.\n\n任务：\n1. 使用带标准合一的一阶归结规则，从 $\\{C_{1}, C_{2}, C_{3}\\}$ 构造一个完整的归结反驳，推导出空子句 $\\Box$。\n2. 定义一次二元归结推理为：在两个子句之间对恰好一对互补文字进行归结以生成它们的归结式（不允许因子化、代入或其他推理规则）。仅将此类二元归结推理计为步骤。反驳 $\\{C_{1}, C_{2}, C_{3}\\}$ 所需的最小二元归结推理次数是多少？\n\n请基于子句、合一和归结规则的基本原理提供你的推理过程。最终答案必须是给出最小二元归结推理次数的单个整数。无需四舍五入。", "solution": "以下是从给定的子句集 $\\{C_{1}, C_{2}, C_{3}\\}$ 推导出空子句 ($\\Box$) 的一个最小步骤的归结反驳过程：\n\n1.  $C_4: \\{P(f(a))\\}$  (通过归结 $C_1: \\{P(a)\\}$ 和 $C_2: \\{\\lnot P(x) \\lor P(f(x))\\}$，使用最概括合一子 MGU $\\{x \\mapsto a\\}$)\n2.  $C_5: \\{P(f(f(a)))\\}$ (通过归结 $C_4: \\{P(f(a))\\}$ 和 $C_2: \\{\\lnot P(x) \\lor P(f(x))\\}$，使用 MGU $\\{x \\mapsto f(a)\\}$，其中 $C_2$ 的变量已标准化)\n3.  $\\Box$ (通过归结 $C_5: \\{P(f(f(a)))\\}$ 和 $C_3: \\{\\lnot P(f(f(a)))\\}$)\n\n这个过程包含了 3 次二元归结推理。要从 $P(a)$ 生成与 $\\lnot P(f(f(a)))$ 矛盾的文字，必须应用规则 $C_2$ 两次，以引入两层函数符号 $f$。这需要两步归结。然后，第三步归结才能产生空子句。因此，最小推理次数为 3。", "answer": "$$ \\boxed{3} $$", "id": "3050890"}]}