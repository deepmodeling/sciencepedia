## 引言
[一阶逻辑](@entry_id:154340)中的归结（Resolution）是[自动定理证明](@entry_id:154648)领域的一块基石，它为机器如何系统地、机械地进行逻辑推理提供了第一个真正有效的答案。在计算机诞生之初，如何将人类复杂的[逻辑演绎](@entry_id:267782)过程自动化，是一个巨大的挑战。归结方法的出现，通过一个简单、统一的[推理规则](@entry_id:273148)，巧妙地解决了这个问题，将证明问题转化为一个可计算的搜索过程。本文旨在全面而深入地介绍[一阶逻辑](@entry_id:154340)归结的理论与实践。

在接下来的内容中，读者将踏上一段从理论基础到实际应用的探索之旅。我们将分三个主要部分展开：
- **原理与机制** 将深入归结的核心，从其专用的语言——子句[范式](@entry_id:161181)——讲起，详细介绍如何将任意公式转换为这种标准形式。接着，我们将剖析作为其引擎的合一（Unification）算法，并阐明归结作为一种反驳完备系统的策略和理论依据。
- **应用与跨学科联系** 将展示这些理论如何在人工智能、[逻辑编程](@entry_id:151199)（特别是Prolog）、软件工程和形式化方法中发挥作用，揭示其从抽象理论到解决现实问题的桥梁作用。
- **动手实践** 将通过一系列精心设计的练习，引导读者亲手操作公式转换、执行[合一算法](@entry_id:635007)并构建完整的归结反驳，从而巩固所学知识。

通过这三个部分的学习，您将不仅理解归结“是什么”，更将掌握它“如何工作”以及“为何重要”。

## 原理与机制

在介绍了一阶逻辑归结的基本概念之后，本章将深入探讨其核心工作原理与理论基础。我们将从归结演算所需的基本语言结构——[子句形式](@entry_id:151648)——开始，详细阐述如何将任意[一阶逻辑](@entry_id:154340)语句转换为这种[标准形式](@entry_id:153058)。接着，我们将剖析归结[推理规则](@entry_id:273148)本身，特别是作为其核心引擎的合一（unification）机制。随后，我们将阐明归结作为一种反驳（refutation）系统的策略，并最终通过探讨[Herbrand定理](@entry_id:154319)和提升引理（Lifting Lemma）来揭示其完备性的深刻理论根基。

### 归结的语言：[子句形式](@entry_id:151648)

归结推理并非直接作用于任意形式的[一阶逻辑](@entry_id:154340)语句，而是要求所有公式都必须被转换成一种称为**子句[范式](@entry_id:161181)**（Clausal Normal Form）的[标准化](@entry_id:637219)结构。为了理解子句，我们必须首先定义其构成要素。

- **项（Term）**: 在一阶逻辑中，项是用来指代[论域](@entry_id:265834)中对象（object）的表达式。一个项可以是一个**变量**（如 $x, y$），一个**常量**（如 $a, b$），或者一个**函数符号**作用于一个或多个项而构成的复合项（如 $f(x), g(a, y)$）。值得注意的是，谓词应用于项构成的是公式，而非项。[@problem_id:3050840]

- **原子（Atom）**: 一个**原子公式**（或简称原子）是一个谓词符号作用于一个项的元组。例如，$P(x)$、 $Q(a, f(b))$ 都是原子。在带等词的[一阶逻辑](@entry_id:154340)中，形如 $t_1 = t_2$ 的表达式也被视为原子，其中 $t_1$ 和 $t_2$ 是项。[@problem_id:3050840]

- **文字（Literal）**: 一个**文字**是一个原子或一个原子的否定。一个原子本身称为**正文字**（positive literal），例如 $P(x)$。一个原子的否定称为**负文字**（negative literal），例如 $\lnot P(x)$。[@problem_id:3050840]

- **子句（Clause）**: 一个**子句**是有限个文字的析取（disjunction，用 $\lor$ 连接）。例如，$\lnot P(x) \lor Q(f(x)) \lor R(a)$ 是一个子句。在归结的上下文中，一个重要的约定是：子句中出现的所有[自由变量](@entry_id:151663)都被隐式地**全称量化**。因此，上述子句的真正含义是 $\forall x, (\lnot P(x) \lor Q(f(x)) \lor R(a))$。一个不包含任何文字的子句称为**空子句**（empty clause），记为 $\square$，它恒为假。

- **子句[范式](@entry_id:161181)（Clausal Form）**: 一个公式如果是一系列子句的合取（conjunction，用 $\land$ 连接），则称该公式处于**子句[范式](@entry_id:161181)**中。例如，$(\lnot P(x) \lor Q(x)) \land (P(a)) \land (\lnot Q(b))$ 就是一个子句[范式](@entry_id:161181)。在实践中，一个处于子句[范式](@entry_id:161181)的公式通常被表示为一个**子句集**，其中每个子句都是集合中的一个元素。例如，上述公式可以表示为集合 $\{\{\lnot P(x), Q(x)\}, \{P(a)\}, \{\lnot Q(b)\}\}$。

逻辑上，由于析取算子 $\lor$ 满足[交换律](@entry_id:141214)（$A \lor B \equiv B \lor A$）、结合律（$(A \lor B) \lor C \equiv A \lor (B \lor C)$）和[幂等律](@entry_id:269266)（$A \lor A \equiv A$），一个子句中文字的顺序和重复是不影响其真值的。因此，将一个子句视为一个**文字的集合**（set of literals）是最符合其逻辑本质的表示，这种表示会自动忽略顺序并消除重复。然而，在算法实现中，有时也会将其视为一个**多重集**（multiset）以保留重复文字的计数信息，或视为一个**序列**（sequence）以保留原始的输入顺序。[@problem_id:3050840]

### 归结的准备：转换为[子句形式](@entry_id:151648)

为了应用归结，我们必须有一个可靠的程序，将任何一阶逻辑语句 $\phi$ 转换为一个在满足性上等价的子句集。这个转换过程涉及一系列保持逻辑性质的步骤，是[自动定理证明](@entry_id:154648)的基石。[@problem_id:3050844]

转换流程如下：

1.  **消除蕴含和双蕴含**: 首先，使用标准定义消除所有 $\rightarrow$ 和 $\leftrightarrow$ 符号：
    -   $A \rightarrow B$ 替换为 $\lnot A \lor B$
    -   $A \leftrightarrow B$ 替换为 $(\lnot A \lor B) \land (A \lor \lnot B)$
    此步骤保持**[逻辑等价](@entry_id:146924)性**。

2.  **内移否定（[否定范式](@entry_id:636683) NNF）**: 重复应用[德摩根定律](@entry_id:138529)（De Morgan's laws）和[量词](@entry_id:159143)对偶律，将否定符号 $\lnot$ 向[内移](@entry_id:265618)动，直至其只作用于原子。
    -   $\lnot(A \land B) \equiv \lnot A \lor \lnot B$
    -   $\lnot(A \lor B) \equiv \lnot A \land \lnot B$
    -   $\lnot(\lnot A) \equiv A$
    -   $\lnot \forall x \psi \equiv \exists x \lnot \psi$
    -   $\lnot \exists x \psi \equiv \forall x \lnot \psi$
    此步骤同样保持**[逻辑等价](@entry_id:146924)性**。

3.  **变量标准化**: 为避免后续步骤中量词作用域引发的混淆，重命名所有约束变量，使得每个[量词](@entry_id:159143)都绑定一个唯一的变量名。例如，$(\forall x P(x)) \land (\exists x Q(x))$ 变为 $(\forall x P(x)) \land (\exists y Q(y))$。这本质上是 $\alpha$-变换，保持**[逻辑等价](@entry_id:146924)性**。

4.  **形成[前束范式](@entry_id:152485)（Prenex Form）**: 将所有量词移动到公式的最前端，形成一个量词前缀，其后跟一个无量词的矩阵（matrix）。例如，$(\forall x P(x)) \lor \psi$ 变为 $\forall x (P(x) \lor \psi)$（前提是 $x$ 不在 $\psi$ 中自由出现，变量标准化保证了这一点）。此步骤保持**[逻辑等价](@entry_id:146924)性**。

5.  **[Skolem化](@entry_id:154933)（Skolemization）**: 这是转换过程中最关键且不保持[逻辑等价](@entry_id:146924)性的一步。其目标是消除所有[存在量词](@entry_id:144554)。
    -   如果一个[存在量词](@entry_id:144554) $\exists y$ 的作用域内有[全称量词](@entry_id:145989) $\forall x_1, \dots, \forall x_k$，则删除 $\exists y$，并将公式中所有出现的 $y$ 替换为一个全新的函数 $f(x_1, \dots, x_k)$，这个函数 $f$ 称为**[Skolem函数](@entry_id:153504)**。
    -   如果 $\exists y$ 不在任何[全称量词](@entry_id:145989)的作用域内，则用一个全新的常量 $c$（即一个0元[Skolem函数](@entry_id:153504)）替换 $y$。
    [Skolem化](@entry_id:154933)破坏了[逻辑等价](@entry_id:146924)性，但它保持了一个更弱但对于反驳证明至关重要的性质：**满足等价性**（equisatisfiability）。即，原始公式是可满足的，当且仅当其[Skolem化](@entry_id:154933)后的公式是可满足的。[@problem_id:3050844]

6.  **丢弃[全称量词](@entry_id:145989)**: 经过[Skolem化](@entry_id:154933)后，公式矩阵前的所有量词都是[全称量词](@entry_id:145989)。我们可以直接丢弃这些量词前缀，并约定矩阵中所有出现的变量都是隐式全称量化的。

7.  **转换为[合取范式](@entry_id:148377)（CNF）**: 对无[量词](@entry_id:159143)的矩阵重复应用[分配律](@entry_id:144084) $A \lor (B \land C) \equiv (A \lor B) \land (A \lor C)$，将其转换为子句的合取。此步骤保持**[逻辑等价](@entry_id:146924)性**。

8.  **形成子句集**: 最后，将形如 $C_1 \land C_2 \land \dots \land C_m$ 的公式表示为子句集 $\{C_1, C_2, \dots, C_m\}$。

经过这一系列步骤，任何一阶逻辑语句都被转换成一个准备好进行归结的子句集。

### 核心推理引擎：合一与归结规则

[命题逻辑](@entry_id:143535)中的归结规则很简单：从子句 $P \lor \Gamma$ 和 $\lnot P \lor \Delta$ 可以推导出新的子句 $\Gamma \lor \Delta$。在一阶逻辑中，情况要复杂得多，因为文字可能包含变量。例如，我们可能需要归结 $P(f(x), a)$ 和 $\lnot P(u, a)$。这两个文字虽然互补，但其原子部分并不完全相同。[@problem_id:3050889] 这就引出了**合一**（Unification）的概念。

**合一**是通过寻找一个**代换**（substitution）$\sigma$，使得两个表达式在应用代换后变得语法上完全相同的过程。代换是一个从变量到项的映射，例如 $\sigma = \{u \mapsto f(x), z \mapsto a\}$。将代换 $\sigma$ 应用于表达式 $E$ 的结果记为 $E\sigma$。

对于原子 $P(f(x), a)$ 和 $P(u, a)$，代换 $\sigma = \{u \mapsto f(x)\}$ 就是一个**合一子**（unifier），因为：
$P(f(x), a)\sigma = P(f(x), a)$
$P(u, a)\sigma = P(f(x), a)$
应用代换后两个原子完全相同。

在所有可能的合一子中，我们最感兴趣的是**最概括合一子**（Most General Unifier, MGU）。MGU是这样一个合一子 $\theta$，任何其他的合一子 $\tau$ 都可以通过先应用 $\theta$ 再应用另一个代换 $\delta$ 得到（即 $\tau = \theta\delta$）。MGU作出了最少的绑定承诺，从而能推导出最概括的结论，这对于保证归结的完备性至关重要。对于上述例子，$\sigma = \{u \mapsto f(x)\}$ 就是一个MGU。[@problem_id:3050889]

有了合一的概念，我们就可以定义**提升的归结规则**（Lifted Resolution Rule）：[@problem_id:3050876]

> 设有子句 $C_1 = L \lor \Gamma$ 和 $C_2 = \lnot L' \lor \Delta$，其中 $L$ 和 $L'$ 是原子，$\Gamma$ 和 $\Delta$ 是其余文字的析取。
> 1.  首先，对子句 $C_1$ 和 $C_2$ 进行**变量[标准化](@entry_id:637219)**，确保它们不共享任何变量。
> 2.  寻找 $L$ 和 $L'$ 的最概括合一子 $\theta = \text{MGU}(L, L')$。如果不存在这样的合一子，则不能对这两个文字进行归结。
> 3.  推导出的**归结式**（resolvent）是新子句 $(\Gamma \lor \Delta)\theta$。

这个规则的本质是：找到一对可以通过代换$\theta$变得互补的文字 $(L, \lnot L')$，消除它们，然后将这个使它们互补的代换 $\theta$ 应用到两个父子句剩余部分的并集上。

在实现[合一算法](@entry_id:635007)时，有一个必须处理的微妙之处：**[出现检查](@entry_id:637991)**（occurs check）。该检查确保在试图将变量 $v$ 与项 $t$ 合一时，$v$ 本身不能出现在 $t$ 中。例如，试图合一 $x$ 和 $f(x)$，对应的方程是 $x=f(x)$。如果不进行[出现检查](@entry_id:637991)而错误地接受了这个绑定，将会导致逻辑上的不健全。例如，考虑可满足的子句集 $\{\{P(x,x)\}, \{\lnot P(f(y), y)\}\}$。若忽略[出现检查](@entry_id:637991)，合一 $P(x,x)$ 和 $P(f(y), y)$ 会错误地“成功”（通过求解 $x=f(y)$ 和 $x=y$，导致 $y=f(y)$），从而允许我们归结出空子句 $\square$，即从一个可满足集推导出矛盾。这证明了忽略[出现检查](@entry_id:637991)会导致不健全的推理。[@problem_id:3050813] 因此，标准的[合一算法](@entry_id:635007)必须包含[出现检查](@entry_id:637991)。

### 策略：反驳证明

归结方法的一个显著特点是它并非一个通用的演绎系统，它不能从一个理论 $T$ 直接推导出其所有的[逻辑推论](@entry_id:155068)。例如，从 $\{P(a)\}$ 无法用归结推导出 $\{P(a) \lor Q(b)\}$，尽管后者是前者的[逻辑推论](@entry_id:155068)。

归结的威力在于它是一个**反驳完备**（refutation-complete）的系统。这意味着：**如果一个子句集是不可满足的（即矛盾的），那么通过归结规则一定可以在有限步内从该集合推导出空子句 $\square$**。[@problem_id:3050820]

这一性质决定了归结在[自动定理证明](@entry_id:154648)中的标准用法——**反驳证明**（proof by refutation）。要证明一个理论 $T$ 蕴含一个结论 $\varphi$（记为 $T \models \varphi$），我们不直接从 $T$ 推导 $\varphi$，而是采用反证法。根据逻辑基本定理，$T \models \varphi$ 等价于集合 $T \cup \{\lnot\varphi\}$ 是不可满足的。[@problem_id:3050820]

因此，证明 $T \models \varphi$ 的过程如下：
1.  将 $T$ 中的所有语句和**否定后的结论** $\lnot\varphi$ 合并成一个集合 $S = T \cup \{\lnot\varphi\}$。
2.  将 $S$ 中的所有语句转换为一个子句集 $S_{clausal}$。
3.  对 $S_{clausal}$ 应用归结规则，尝试推导出空子句 $\square$。
4.  如果成功推导出 $\square$，说明 $S_{clausal}$ 是不可满足的。由于转换过程保持满足等价性，原始集合 $S$ 也是不可满足的。因此，我们成功证明了 $T \models \varphi$。

例如，要证明 $\{\forall x (P(x) \rightarrow Q(x)), \forall x P(x)\} \models \forall x Q(x)$：[@problem_id:3050820]
- **前提子句**: $\forall x (P(x) \rightarrow Q(x))$ 变为 $\{\lnot P(x), Q(x)\}$。$\forall x P(x)$ 变为 $\{P(x)\}$。
- **否定结论**: $\lnot (\forall x Q(x))$ 变为 $\exists x \lnot Q(x)$。
- **[Skolem化](@entry_id:154933)**: $\exists x \lnot Q(x)$ 变为 $\{\lnot Q(a)\}$，其中 $a$ 是一个新的Skolem常量。
- **归结过程**:
    1.  归结 $\{\lnot P(x_1), Q(x_1)\}$ 和 $\{P(x_2)\}$，MGU为 $\{x_1 \mapsto x_2\}$，得到归结式 $\{Q(x_2)\}$，或简写为 $\{Q(x)\}$。
    2.  归结 $\{Q(x)\}$ 和 $\{\lnot Q(a)\}$，MGU为 $\{x \mapsto a\}$，得到归结式 $\square$（空子句）。
由于我们导出了空子句，证明完成。

### 理论基础：为何归结是完备的

我们已经断言归结是反驳完备的，但为什么呢？这个深刻结果的证明依赖于两个一阶逻辑中的基石性定理：[Herbrand定理](@entry_id:154319)和提升引理。这个证明巧妙地将[一阶逻辑](@entry_id:154340)的不[可满足性问题](@entry_id:262806)规约到[命题逻辑](@entry_id:143535)的层面。[@problem_id:3050827]

**[Herbrand定理](@entry_id:154319)** 建立了[一阶逻辑](@entry_id:154340)语义和[命题逻辑](@entry_id:143535)语义之间的桥梁。其核心思想是，一个一阶子句集 $S$ 的模型可以被一个只涉及项的特殊模型——Herbrand模型——所替代。对于反驳完备性的证明，[Herbrand定理](@entry_id:154319)的一个关键形式是：[@problem_id:3050815]

> 一个子句集 $S$ 是不可满足的，当且仅当存在一个从 $S$ 的子句生成的**有限**的**基实例**（ground instances）集合，该集合在[命题逻辑](@entry_id:143535)意义下是不可满足的。

基实例是指通过代换将子句中的所有[变量替换](@entry_id:141386)为Herbrand域（由公式中的常量和函数符号构成的所有基项）中的项所得到的无变量子句。这个定理的惊人之处在于，即使Herbrand域和所有可能的基实例是无限的，一个矛盾也总能在一个有限的[子集](@entry_id:261956)中被发现。

**提升引理（Lifting Lemma）** 则将命题层面的归结与一阶层面的归结联系起来。它保证了我们在基实例上执行的任何归结步骤，都对应于在原始的一阶子句上执行的一个更概括的归结步骤。[@problem_id:3050850]

> 如果基子句 $C'$ 是从基子句 $C'_1$ 和 $C'_2$ 归结得到的，并且 $C'_1$ 和 $C'_2$ 分别是一阶子句 $C_1$ 和 $C_2$ 的实例，那么存在一个从 $C_1$ 和 $C_2$ 归结得到的一阶子句 $C$，使得 $C'$ 是 $C$ 的一个实例。

这两个构件共同构成了归结完备性的证明：[@problem_id:3050827]
1.  假设一个子句集 $S$ 是**不可满足的**。
2.  根据 **[Herbrand定理](@entry_id:154319)**，存在一个有限的、命题上不可满足的基实例集 $S'$。
3.  由于命题归结是完备的，必然存在一个从 $S'$ 出发的归结序列，最终推导出空子句 $\square$。这是一个**基反驳**（ground refutation）。
4.  根据 **提升引理**，这个基反驳的每一步都可以被“提升”到一阶层面。因此，我们可以构造一个从原始子句集 $S$ 出发的一阶归结序列，它与基反驳平行，并最终同样推导出空子句 $\square$。
5.  这就证明了，对于任何不可满足的子句集，都存在一个一阶归结反驳。

### 归结的范围与局限性

尽管归结是一个强大的工具，但了解其理论边界也同样重要。

首先，[一阶逻辑](@entry_id:154340)是**半可判定的**（semi-decidable），而不是可判定的。归结方法完美地体现了这一点。反驳完备性保证了如果一个语句是有效的（其否定是不可满足的），归结过程最终会停机并给出证明。但是，如果一个语句是无效的（其否定是可满足的），归结过程可能会永不停止，因为它会不断地生成新的、非矛盾的子句。例如，对于可满足集 $\{P(a), \lnot P(x) \lor P(f(x))\}$，归结会无限地生成 $P(f(a)), P(f(f(a))), \dots$，永远不会推导出空子句，也无法得出“可满足”的结论。[@problem_id:3050818]

其次，我们所描述的“纯”归结规则对于带有**等词**（equality）的[一阶逻辑](@entry_id:154340)是不完备的。等词的语义（即 $a=b$ 意味着 $a$ 和 $b$ 是同一个对象）无法被标准的合一机制所捕捉。例如，从子句集 $\{a=b, P(a), \lnot P(b)\}$，我们应该能推导出矛盾，因为 $a=b$ 和 $P(a)$ 蕴含 $P(b)$。但纯归结无法做到这一点，因为 $P(a)$ 和 $P(b)$ 的原子部分无法合一。[@problem_id:3050834]

为了处理等词，有两种标准方法：
1.  **公理化方法**: 将等词的性质（[自反性、对称性、传递性](@entry_id:140945)）以及所有函数和谓词的**合同性公理**（congruence axioms）作为额外的子句加入到集合中。例如，为谓词 $P$ 添加公理 $\forall x \forall y ((x=y \land P(x)) \rightarrow P(y))$。
2.  **过程化方法**: 扩展归结规则，引入专门处理等词的[推理规则](@entry_id:273148)，如**参数调节**（paramodulation）或**重叠**（superposition）。这些规则允许基于等式在项的内部进行代换，从而将等词的语义直接内置到推理过程中。[@problem_id:3050834]

通过这些扩展，归结才能成为一个真正强大的、可用于包含等词在内的广阔数学领域的[自动推理](@entry_id:151826)工具。