{"hands_on_practices": [{"introduction": "掌握集合代数是理解更复杂数学结构的基础。这个练习 [@problem_id:1786446] 旨在通过运用德摩根定律和其他基本集合运算法则，将一个看似复杂的表达式化简为其最核心的形式。这有助于我们锻炼集合论的“代数肌肉”，为处理更高级的逻辑问题打下坚实基础。", "problem": "在设计数据库逻辑过滤器的背景下，设 $U$ 是代表所有用户个人资料的全集。考虑两个子集：集合 $A$ 包含在过去30天内有过购买行为的用户，集合 $B$ 包含订阅了推广简报的用户。一位数据科学家构建了一个复杂的筛选标准，由集合表达式 $(A^c \\cup B)^c \\cup (A \\cap B)$ 表示，其中 $X^c$ 表示集合 $X$ 相对于全集 $U$ 的补集。你的任务是利用集合代数的基本定律将此表达式化简为其最基本的形式。", "solution": "设给定的表达式为\n$$\nS=(A^{c} \\cup B)^{c} \\cup (A \\cap B).\n$$\n对第一项应用德摩根定律：\n$$\n(A^{c} \\cup B)^{c}=(A^{c})^{c} \\cap B^{c}=A \\cap B^{c}.\n$$\n将此代入 $S$：\n$$\nS=(A \\cap B^{c}) \\cup (A \\cap B).\n$$\n使用分配律提取因子 $A$：\n$$\n(A \\cap B^{c}) \\cup (A \\cap B)=A \\cap (B^{c} \\cup B).\n$$\n应用补集律 $B^{c} \\cup B=U$：\n$$\nA \\cap (B^{c} \\cup B)=A \\cap U.\n$$\n最后，使用同一律 $A \\cap U=A$：\n$$\nS=A.\n$$\n因此，该表达式化简为 $A$。", "answer": "$$\\boxed{A}$$", "id": "1786446"}, {"introduction": "德摩根定律不仅是代数技巧，更体现了基本的逻辑原则。这个练习 [@problem_id:1786450] 展示了对这些定律的误解如何在现实世界中导致严重错误，例如在一个安全系统的逻辑设计中。通过识别并纠正这个错误，你将更深刻地理解补集、并集和交集之间的精确逻辑关系。", "problem": "一家为数据中心开发高级安全系统的公司定义了触发高级别警报的两个关键条件。该系统监控一个网络数据包流。如果一个数据包同时满足以下两个标准，系统将触发警报：\n1. 数据包来自外部、非白名单的 IP 地址。\n2. 数据包的有效载荷包含一个匹配已知恶意软件模式的签名。\n\n设 $U$ 为系统扫描的所有网络数据包的全集。\n设 $A$ 为来自外部、非白名单 IP 地址的数据包子集。\n设 $B$ 为有效载荷包含已知恶意软件签名的数据包子集。\n\n如果一个数据包属于集合 $A \\cap B$，则它被视为“高风险”。所有其他数据包都被视为“低风险”。因此，所有低风险数据包的集合是高风险集合的补集，即 $(A \\cap B)^c$。\n\n一名工程师的任务是配置一条日志记录规则，以记录每个被归类为“低风险”的数据包。该工程师实现了以下逻辑：\n\n“一个数据包 $x$ 被记录为‘低风险’，当且仅当该数据包 $x$ 不来自外部、非白名单的 IP 地址，并且该数据包 $x$ 不包含已知的恶意软件签名。”\n\n这个实现是有缺陷的，因为它未能记录某些类别的低风险数据包。你的任务是识别出那些确实属于低风险但*未被*工程师的有缺陷规则记录下来的确切数据包集合。\n\n以下哪个集合论表达式正确地表示了这组未被记录的低风险数据包？\n\nA. $A \\cap B$\n\nB. $(A \\cup B)^c$\n\nC. $A^c \\cap B^c$\n\nD. $(A \\cap B^c) \\cup (A^c \\cap B)$\n\nE. $A \\cup B$", "solution": "让我们根据提供的信息定义集合来分析问题。\n所有数据包的集合是 $U$。\n来自外部、非白名单 IP 的数据包集合是 $A$。\n带有恶意软件签名的数据包集合是 $B$。\n\n首先，我们确定“高风险”数据包的集合。如果一个数据包同时满足这两个条件，则其为高风险。因此，高风险数据包的集合是 $A$ 和 $B$ 的交集。\n$$S_{\\text{high-risk}} = A \\cap B$$\n\n接下来，我们确定真正的“低风险”数据包集合。这个集合由所有非高风险的数据包组成。这是高风险集合相对于全集 $U$ 的补集。\n$$S_{\\text{low-risk, true}} = (A \\cap B)^{c}$$\n应用集合的德摩根定律，即 $(X \\cap Y)^{c} = X^{c} \\cup Y^{c}$，我们可以将真正的低风险数据包集合重写为：\n$$S_{\\text{low-risk, true}} = A^{c} \\cup B^{c}$$\n换句话说，如果一个数据包*不*是来自外部 IP，*或者*它*不*包含恶意软件签名，或者两者兼有，那么它就是真正的低风险数据包。\n\n现在，我们来分析被工程师的有缺陷规则记录为“低风险”的数据包集合。该规则是：“一个数据包 $x$ 被记录为‘低风险’，当且仅当该数据包 $x$ 不来自外部、非白名单的 IP 地址，并且该数据包 $x$ 不包含已知的恶意软件签名。”\n一个数据包 $x$ 不来自外部 IP 意味着 $x \\in A^{c}$。\n一个数据包 $x$ 不包含恶意软件签名意味着 $x \\in B^{c}$。\n逻辑上的“与”对应于集合的交集。因此，被工程师记录的数据包集合是：\n$$S_{\\text{logged}} = A^{c} \\cap B^{c}$$\n\n问题要求的是那些确实属于低风险但*未被*有缺陷规则记录的数据包集合。这对应于真正的低风险集合与被记录的数据包集合之间的集合差。\n$$\\text{Unlogged packets} = S_{\\text{low-risk, true}} \\setminus S_{\\text{logged}}$$\n代入我们找到的表达式：\n$$\\text{Unlogged packets} = (A^{c} \\cup B^{c}) \\setminus (A^{c} \\cap B^{c})$$\n集合差 $X \\setminus Y$ 是指在 $X$ 中但不在 $Y$ 中的元素集合。表达式 $(X \\cup Y) \\setminus (X \\cap Y)$ 是集合 $X$ 和 $Y$ 的对称差的定义，通常表示为 $X \\Delta Y$。\n在我们的例子中，未被记录的数据包集合是 $A^{c}$ 和 $B^{c}$ 的对称差。\n$$ \\text{Unlogged packets} = A^{c} \\Delta B^{c} = (A^{c} \\setminus B^{c}) \\cup (B^{c} \\setminus A^{c}) $$\n我们可以使用恒等式 $X \\setminus Y = X \\cap Y^{c}$ 来简化这些项。\n第一项是 $A^{c} \\setminus B^{c} = A^{c} \\cap (B^{c})^{c} = A^{c} \\cap B$。\n第二项是 $B^{c} \\setminus A^{c} = B^{c} \\cap (A^{c})^{c} = B^{c} \\cap A$。\n将这两项合并，未被记录的数据包集合是：\n$$\\text{Unlogged packets} = (A^{c} \\cap B) \\cup (A \\cap B^{c})$$\n这个表达式表示满足两个条件中恰好一个的数据包集合：要么它们来自外部源但没有恶意软件签名 ($A \\cap B^c$), 要么它们不来自外部源但确实包含恶意软件签名 ($A^c \\cap B$)。这些确实是低风险数据包（因为它们没有同时满足两个高风险条件），但它们被工程师的逻辑遗漏了，该逻辑要求一个数据包必须*同时*不满足两个条件才会被记录。\n\n将我们的结果与给定选项进行比较：\nA. $A \\cap B$: 高风险数据包。不正确。\nB. $(A \\cup B)^c$: 根据德摩根定律，这是 $A^c \\cap B^c$。这是*被*记录的集合。不正确。\nC. $A^c \\cap B^c$: 这是*被*记录的集合。不正确。\nD. $(A \\cap B^c) \\cup (A^c \\cap B)$: 这与我们推导出的未被记录的低风险数据包的表达式相匹配。正确。\nE. $A \\cup B$: 具有至少一个风险因素的数据包集合。不正确。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1786450"}, {"introduction": "掌握了代数和逻辑之后，让我们看看德摩根定律如何成为解决其他数学领域问题的有力工具。这个练习 [@problem_id:1786493] 将该定律应用于一个组合数学中的计数问题。它展示了德摩根定律如何与容斥原理协同作用，优雅地解决那些初看起来颇为棘手的计数任务。", "problem": "考虑整数全集 $U = \\{n \\in \\mathbb{Z} \\mid 1 \\le n \\le 50\\}$。我们感兴趣的是 $U$ 中那些既不能被 3 整除也不能被 5 整除的元素所构成的子集。请计算这个子集的基数。", "solution": "设 $U$ 为从 1 到 50 的整数构成的全集。$U$ 的基数为 $|U| = 50$。\n\n设 $A$ 是 $U$ 中能被 3 整除的整数构成的子集。\n设 $B$ 是 $U$ 中能被 5 整除的整数构成的子集。\n\n问题要求的是 $U$ 中既不能被 3 整除也不能被 5 整除的元素的数量。用集合符号表示，这对应于求不在 $A$ 中也不在 $B$ 中的元素的集合的基数。这个集合是 $A$ 和 $B$ 的补集的交集，记为 $A^c \\cap B^c$。\n\n我们可以使用集合的德摩根定律，该定律指出对于任意两个集合 $A$ 和 $B$，有 $(A \\cup B)^c = A^c \\cap B^c$。\n因此，我们需要求 $|(A \\cup B)^c|$。\n\n一个集合的补集的基数公式为 $|S^c| = |U| - |S|$。应用这个公式，我们得到：\n$|A^c \\cap B^c| = |(A \\cup B)^c| = |U| - |A \\cup B|$。\n\n为了求出 $|A \\cup B|$，我们使用容斥原理：\n$|A \\cup B| = |A| + |B| - |A \\cap B|$。\n\n现在我们来计算每个集合的基数：\n1.  **$|A|$**：$U$ 中能被 3 整除的整数的数量。这由 $50/3$ 的下取整函数给出。\n    $|A| = \\lfloor \\frac{50}{3} \\rfloor = \\lfloor 16.66... \\rfloor = 16$。\n\n2.  **$|B|$**：$U$ 中能被 5 整除的整数的数量。这由 $50/5$ 的下取整函数给出。\n    $|B| = \\lfloor \\frac{50}{5} \\rfloor = \\lfloor 10 \\rfloor = 10$。\n\n3.  **$|A \\cap B|$**：$U$ 中既能被 3 整除也能被 5 整除的整数集合。一个整数能同时被 3 和 5 整除，当且仅当它能被它们的最小公倍数整除，即 $\\text{lcm}(3, 5) = 15$。\n    $|A \\cap B| = \\lfloor \\frac{50}{15} \\rfloor = \\lfloor 3.33... \\rfloor = 3$。\n\n现在，将这些值代入容斥原理公式：\n$|A \\cup B| = 16 + 10 - 3 = 23$。\n\n最后，我们可以求出所求集合的基数：\n$|A^c \\cap B^c| = |U| - |A \\cup B| = 50 - 23 = 27$。\n\n因此，在 1 到 50 之间（含两端）有 27 个整数既不能被 3 整除也不能被 5 整除。", "answer": "$$\\boxed{27}$$", "id": "1786493"}]}