{
    "hands_on_practices": [
        {
            "introduction": "The first step in any computational method is translating continuous physical laws into a discrete system of algebraic equations. This exercise guides you through this fundamental process for a reactive transport problem. By deriving the finite volume residuals for transport and reaction using a fully implicit scheme, you will construct the core nonlinear equations that a global implicit solver must tackle . This practice builds the essential bridge between the governing partial differential equations and their numerical representation.",
            "id": "4081042",
            "problem": "Consider a one-dimensional saturated reactive porous column of length $L$ and constant cross-sectional area $A$, discretized into $N$ uniform finite volumes of width $\\Delta x$ (so each cell has volume $V_{i} = A \\Delta x$). Let the porosity be spatially uniform and equal to $\\phi$, the pore-water advective velocity be a constant $u > 0$ directed from left to right, and the hydrodynamic dispersion coefficient be a constant $D > 0$. Two dissolved primary components are transported: calcium with concentration $c_{\\mathrm{Ca}}(x,t)$ and carbonate with concentration $c_{\\mathrm{CO_3}}(x,t)$. These components react with a mineral phase, calcite, with mineral mass per bulk volume $m(x,t)$, through the reversible reaction $\\mathrm{CaCO_3(s)} \\rightleftharpoons \\mathrm{Ca^{2+}} + \\mathrm{CO_3^{2-}}$.\n\nAssume the following physically standard transport and reaction principles as the fundamental base:\n\n- Local mass conservation of each dissolved component in a saturated porous medium with advectionâ€“dispersion and reaction: for component $j \\in \\{\\mathrm{Ca}, \\mathrm{CO_3}\\}$,\n$$\n\\phi \\frac{\\partial c_{j}}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u \\, c_{j} - D \\frac{\\partial c_{j}}{\\partial x}\\right) = \\nu_{j} \\, r,\n$$\nwhere $\\nu_{\\mathrm{Ca}} = 1$ and $\\nu_{\\mathrm{CO_3}} = 1$ are stoichiometric coefficients for production of dissolved components by dissolution (positive for production), and $r$ is the volumetric reaction rate.\n\n- Local mass conservation of the mineral:\n$$\n\\frac{\\partial m}{\\partial t} = - r,\n$$\nso that mineral dissolution ($r > 0$) decreases $m$ and produces dissolved components, while precipitation ($r < 0$) increases $m$ and consumes dissolved components.\n\n- A well-tested Transition-State Theory style rate law for calcite dissolution/precipitation per bulk volume:\n$$\nr = k \\, s \\left(\\frac{c_{\\mathrm{Ca}} c_{\\mathrm{CO_3}}}{K_{\\mathrm{eq}}} - 1\\right),\n$$\nwhere $k > 0$ is a kinetic constant, $s > 0$ is an effective reactive surface area per bulk volume (assumed constant in space and time for this derivation), and $K_{\\mathrm{eq}} > 0$ is an equilibrium constant.\n\nDerive a conservative, fully implicit finite volume residual for the coupled system in an interior cell $i$ at time $t^{n+1}$ using backward Euler time integration. Evaluate all fluxes and reaction rates at $t^{n+1}$ so that transport and reactions are embedded implicitly and coupled globally. Use upwind discretization for advection consistent with $u > 0$ and centered differences for dispersion. Denote face $i+1/2$ between cells $i$ and $i+1$ and face $i-1/2$ between cells $i-1$ and $i$. For any dissolved component $j$, define the conservative face fluxes at time $t^{n+1}$:\n$$\nF_{j,i+\\frac{1}{2}}^{n+1} = u \\, c_{j,i}^{n+1} - D \\frac{c_{j,i+1}^{n+1} - c_{j,i}^{n+1}}{\\Delta x}, \\quad\nF_{j,i-\\frac{1}{2}}^{n+1} = u \\, c_{j,i-1}^{n+1} - D \\frac{c_{j,i}^{n+1} - c_{j,i-1}^{n+1}}{\\Delta x}.\n$$\n\nLet $r_{i}^{n+1} = k \\, s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right)$ be the cell-centered reaction rate evaluated at $t^{n+1}$. Starting from the stated laws, use finite volume integration over the control volume $V_{i}$ and backward Euler over the time interval $[t^{n}, t^{n+1}]$ to derive the three coupled residuals $R_{\\mathrm{Ca},i}$, $R_{\\mathrm{CO_3},i}$, and $R_{m,i}$, each expressed in terms of $(A, \\Delta x, \\phi, \\Delta t, u, D, k, s, K_{\\mathrm{eq}})$ and the unknowns $(c_{\\mathrm{Ca},i-1}^{n+1}, c_{\\mathrm{Ca},i}^{n+1}, c_{\\mathrm{Ca},i+1}^{n+1}, c_{\\mathrm{CO_3},i-1}^{n+1}, c_{\\mathrm{CO_3},i}^{n+1}, c_{\\mathrm{CO_3},i+1}^{n+1}, m_{i}^{n+1})$, together with the known previous-time values $(c_{\\mathrm{Ca},i}^{n}, c_{\\mathrm{CO_3},i}^{n}, m_{i}^{n})$. Your residuals must ensure exact balance of face fluxes and reaction source terms in each control volume.\n\nProvide the final residual vector for cell $i$ in closed form. No numerical evaluation or rounding is required, and no units are to be included in the final expression.",
            "solution": "The user has requested the derivation of the fully implicit finite volume residuals for a coupled reactive transport system in a one-dimensional porous medium. The problem statement has been validated and found to be scientifically sound, well-posed, and complete. We may therefore proceed with the derivation.\n\nThe system involves three unknown fields: the concentration of dissolved calcium, $c_{\\mathrm{Ca}}(x,t)$; the concentration of dissolved carbonate, $c_{\\mathrm{CO_3}}(x,t)$; and the mass of the mineral calcite per bulk volume, $m(x,t)$. The governing partial differential equations (PDEs) provided are:\nFor the dissolved components $j \\in \\{\\mathrm{Ca}, \\mathrm{CO_3}\\}$:\n$$ \\phi \\frac{\\partial c_{j}}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u \\, c_{j} - D \\frac{\\partial c_{j}}{\\partial x}\\right) = \\nu_{j} \\, r $$\nFor the mineral phase:\n$$ \\frac{\\partial m}{\\partial t} = - r $$\nThe reaction rate, $r$, is given by the Transition-State Theory (TST) rate law:\n$$ r = k \\, s \\left(\\frac{c_{\\mathrm{Ca}} c_{\\mathrm{CO_3}}}{K_{\\mathrm{eq}}} - 1\\right) $$\nwhere the stoichiometric coefficients are $\\nu_{\\mathrm{Ca}}=1$ and $\\nu_{\\mathrm{CO_3}}=1$.\n\nOur goal is to discretize these three coupled PDEs using a finite volume method for an interior cell $i$. The discretization will be fully implicit, employing a backward Euler scheme for time integration. The residual for each equation, denoted $R_j$, is an expression that must equal zero at the solution for the unknowns at the new time step $t^{n+1}$.\n\nWe begin by integrating each PDE over the control volume of cell $i$, which is $V_i = A \\Delta x$. This corresponds to integrating over the spatial interval $[x_{i-1/2}, x_{i+1/2}]$.\n\n**1. Residual for Calcium, $R_{\\mathrm{Ca},i}$**\n\nThe governing equation for calcium is:\n$$ \\phi \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial t} + \\frac{\\partial F_{\\mathrm{Ca}}}{\\partial x} = r $$\nwhere $F_{\\mathrm{Ca}} = u \\, c_{\\mathrm{Ca}} - D \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial x}$ is the total flux of calcium. Integrating over the control volume $V_i = A \\Delta x$ gives:\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\phi \\frac{\\partial c_{\\mathrm{Ca}}}{\\partial t} \\right) A \\, dx + \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{\\partial F_{\\mathrm{Ca}}}{\\partial x} \\right) A \\, dx = \\int_{x_{i-1/2}}^{x_{i+1/2}} r \\, A \\, dx $$\nAssuming the cell-centered value is a good approximation of the cell average, and applying the fundamental theorem of calculus to the flux term, we obtain the semi-discretized equation:\n$$ \\phi A \\Delta x \\frac{d c_{\\mathrm{Ca},i}}{dt} + A \\left( F_{\\mathrm{Ca},i+1/2} - F_{\\mathrm{Ca},i-1/2} \\right) = r_i A \\Delta x $$\nNow, we apply the backward Euler method for time discretization. The time derivative is approximated as $\\frac{d c_{\\mathrm{Ca},i}}{dt} \\approx \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t}$, and all other terms are evaluated at the new time level $n+1$. This yields the fully discrete equation:\n$$ \\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( F_{\\mathrm{Ca},i+1/2}^{n+1} - F_{\\mathrm{Ca},i-1/2}^{n+1} \\right) - r_i^{n+1} A \\Delta x = 0 $$\nThe left-hand side of this equation is the residual, $R_{\\mathrm{Ca},i}$. We substitute the provided discrete expressions for the fluxes and the reaction rate:\n- $ F_{\\mathrm{Ca},i+1/2}^{n+1} = u \\, c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} $\n- $ F_{\\mathrm{Ca},i-1/2}^{n+1} = u \\, c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} $\n- $ r_{i}^{n+1} = k \\, s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $\n\nSubstituting these into the residual equation gives the final form for $R_{\\mathrm{Ca},i}$:\n$$ R_{\\mathrm{Ca},i} = \\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\n\n**2. Residual for Carbonate, $R_{\\mathrm{CO_3},i}$**\n\nThe governing equation for carbonate is identical in form to that for calcium, as $\\nu_{\\mathrm{CO_3}}=1$.\n$$ \\phi \\frac{\\partial c_{\\mathrm{CO_3}}}{\\partial t} + \\frac{\\partial F_{\\mathrm{CO_3}}}{\\partial x} = r $$\nThe derivation follows the exact same steps. We integrate over the control volume, apply the backward Euler scheme, and substitute the discrete fluxes and reaction rate. This results in a residual $R_{\\mathrm{CO_3},i}$ with the same structure as $R_{\\mathrm{Ca},i}$, but expressed in terms of the carbonate concentrations:\n$$ R_{\\mathrm{CO_3},i} = \\phi A \\Delta x \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{CO_3},i}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i+1}^{n+1} - c_{\\mathrm{CO_3},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{CO_3},i-1}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\nNote that both $R_{\\mathrm{Ca},i}$ and $R_{\\mathrm{CO_3},i}$ are coupled through the nonlinear reaction term, which depends on both $c_{\\mathrm{Ca},i}^{n+1}$ and $c_{\\mathrm{CO_3},i}^{n+1}$.\n\n**3. Residual for the Mineral, $R_{m,i}$**\n\nThe governing equation for the mineral mass, $m$, is:\n$$ \\frac{\\partial m}{\\partial t} = -r $$\nThis equation is an ordinary differential equation in time at each spatial location, as it contains no spatial derivatives. We again integrate over the control volume $V_i = A \\Delta x$:\n$$ \\int_{x_{i-1/2}}^{x_{i+1/2}} \\left( \\frac{\\partial m}{\\partial t} \\right) A \\, dx = - \\int_{x_{i-1/2}}^{x_{i+1/2}} r \\, A \\, dx $$\nApproximating the integrands with their cell-centered values gives the semi-discretized form:\n$$ A \\Delta x \\frac{d m_i}{dt} = - r_i A \\Delta x $$\nApplying the backward Euler scheme, we get:\n$$ A \\Delta x \\frac{m_i^{n+1} - m_i^n}{\\Delta t} = - r_i^{n+1} A \\Delta x $$\nThe residual $R_{m,i}$ is obtained by moving all terms to one side:\n$$ R_{m,i} = A \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + r_i^{n+1} A \\Delta x = 0 $$\nSubstituting the expression for $r_i^{n+1}$:\n$$ R_{m,i} = A \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) $$\nThis residual couples the mineral mass $m_i^{n+1}$ to the dissolved concentrations $c_{\\mathrm{Ca},i}^{n+1}$ and $c_{\\mathrm{CO_3},i}^{n+1}$.\n\nThe three derived residuals, $R_{\\mathrm{Ca},i}$, $R_{\\mathrm{CO_3},i}$, and $R_{m,i}$, form a system of three coupled nonlinear algebraic equations for the three unknowns ($c_{\\mathrm{Ca},i}^{n+1}$, $c_{\\mathrm{CO_3},i}^{n+1}$, $m_i^{n+1}$) at each interior cell $i$. These equations, when assembled for all cells, are solved simultaneously in a global implicit method. The residual vector for cell $i$ is presented in the final answer.",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\phi A \\Delta x \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{Ca},i}^{n+1} - D \\frac{c_{\\mathrm{Ca},i+1}^{n+1} - c_{\\mathrm{Ca},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{Ca},i-1}^{n+1} - D \\frac{c_{\\mathrm{Ca},i}^{n+1} - c_{\\mathrm{Ca},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) \\\\\n\\\\\n\\phi A \\Delta x \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i}^{n}}{\\Delta t} + A \\left( u c_{\\mathrm{CO_3},i}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i+1}^{n+1} - c_{\\mathrm{CO_3},i}^{n+1}}{\\Delta x} \\right) - A \\left( u c_{\\mathrm{CO_3},i-1}^{n+1} - D \\frac{c_{\\mathrm{CO_3},i}^{n+1} - c_{\\mathrm{CO_3},i-1}^{n+1}}{\\Delta x} \\right) - A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right) \\\\\n\\\\\nA \\Delta x \\left( \\frac{m_i^{n+1} - m_i^n}{\\Delta t} \\right) + A \\Delta x k s \\left(\\frac{c_{\\mathrm{Ca},i}^{n+1} c_{\\mathrm{CO_3},i}^{n+1}}{K_{\\mathrm{eq}}} - 1\\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "Why insist on a \"global\" or \"fully coupled\" implicit approach? This practice provides a compelling answer by exploring a common simplification: neglecting the feedback of reactions on physical properties like porosity within a time step. Through a combination of analytical derivation and coding, you will demonstrate that such simplifications can break fundamental physical laws, leading to cumulative mass conservation errors . This exercise powerfully illustrates the importance of robust coupling for the long-term physical fidelity of a simulation.",
            "id": "4080936",
            "problem": "Consider a spatially uniform, closed pore-water control volume in which a single aqueous reactant undergoes precipitation that transforms aqueous mass into a solid mineral. Let the volumetric porosity be denoted by $\\phi$, the aqueous concentration by $c$ in $\\mathrm{mol\\,m^{-3}}$, and the mineral molar volume by $V_m$ in $\\mathrm{m^3\\,mol^{-1}}$. Assume a first-order kinetic rate law with reaction rate coefficient $k$ in $\\mathrm{s^{-1}}$. Neglect advection and diffusion; the system evolves only by reaction.\n\nAs a fundamental base, use the following two ordinary differential equations (ODEs) expressing mass conservation and porosity evolution:\n- Aqueous mass conservation per bulk volume: $\\dfrac{d}{dt}\\left(\\phi\\,c\\right) = -k\\,c$.\n- Porosity evolution due to mineral formation: $\\dfrac{d\\phi}{dt} = -V_m\\,k\\,c$.\n\nThese ODEs couple $\\phi$ and $c$ and embody a globally implicit nonlinear residual when discretized in time. Consider a fully implicit time discretization over a single time step of size $\\Delta t$ from $(\\phi^n,c^n)$ to $(\\phi^{n+1},c^{n+1})$. The globally implicit residual uses the updated porosity $\\phi^{n+1}$ inside the accumulation term. In contrast, a common approximation neglects the porosity update inside the accumulation term by using the lagged porosity $\\phi^n$ in the residual while still updating $\\phi$ separately after computing $c^{n+1}$.\n\nYour tasks are:\n1. Starting from the two ODEs given above, derive the fully implicit discrete system where both $\\phi^{n+1}$ and $c^{n+1}$ appear in the accumulation term and sink term, enforcing global coupling. In a separate derivation, write the scheme that neglects porosity updates in the accumulation term by using $\\phi^n$ instead of $\\phi^{n+1}$ within the nonlinear residual.\n2. Prove analytically that the lagged-porosity residual omits a term proportional to $c^{n+1}\\left(\\phi^{n+1}-\\phi^n\\right)/\\Delta t$ and therefore cannot satisfy the same discrete mass conservation identity as the globally implicit residual. Express the per-step mass error in terms of $\\Delta t$, $k$, $V_m$, and $c^{n+1}$.\n3. Implement both time-integration schemes over a total time $T$ using constant $\\Delta t$, with initial conditions $\\phi(0)=\\phi_0$ and $c(0)=c_0$, and parameter $V_m$. For the globally implicit scheme, solve for $(\\phi^{n+1},c^{n+1})$ at each step from $(\\phi^n,c^n)$ by enforcing the two discrete equations simultaneously. For the lagged-porosity scheme, update $c^{n+1}$ using $\\phi^n$ inside the accumulation term and then update $\\phi^{n+1}$ from the porosity evolution equation.\n4. Define the cumulative mass error at final time $T$ as the signed difference between the aqueous mass per bulk volume predicted by the lagged-porosity scheme and that predicted by the globally implicit scheme, namely $E_{\\mathrm{cum}} = \\phi^{N}_{\\mathrm{lag}}\\,c^{N}_{\\mathrm{lag}} - \\phi^{N}_{\\mathrm{glob}}\\,c^{N}_{\\mathrm{glob}}$ in $\\mathrm{mol\\,m^{-3}}$, where $N=T/\\Delta t$ is an integer number of steps. Quantify $E_{\\mathrm{cum}}$ for each specified test case, and express numerical answers in $\\mathrm{mol\\,m^{-3}}$.\n\nUse the following physically consistent parameter values for all test cases unless otherwise specified:\n- Initial porosity $\\phi_0 = 0.30$ (dimensionless).\n- Initial concentration $c_0 = 100.0$ in $\\mathrm{mol\\,m^{-3}}$.\n- Mineral molar volume $V_m = 3.7\\times 10^{-5}$ in $\\mathrm{m^3\\,mol^{-1}}$.\n\nImplement the two schemes over the following test suite of $(\\Delta t, k, T)$, where $\\Delta t$ and $T$ are in $\\mathrm{s}$ and $k$ is in $\\mathrm{s^{-1}}$:\n- Test case $1$: $\\Delta t = 1.0$, $k = 1.0\\times 10^{-4}$, $T = 1000.0$.\n- Test case $2$: $\\Delta t = 100.0$, $k = 1.0\\times 10^{-4}$, $T = 100000.0$.\n- Test case $3$: $\\Delta t = 1000.0$, $k = 1.0\\times 10^{-4}$, $T = 100000.0$.\n- Test case $4$: $\\Delta t = 100.0$, $k = 0.0$, $T = 100000.0$.\n- Test case $5$: $\\Delta t = 500.0$, $k = 5.0\\times 10^{-3}$, $T = 10000.0$.\n\nFor each test case, compute $E_{\\mathrm{cum}}$ as defined above and provide the result as a floating-point number in $\\mathrm{mol\\,m^{-3}}$. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$). Each listed result must correspond, in order, to test cases $1$ through $5$.\n\nAngles do not appear in this problem. All physical answers must be in the unit $\\mathrm{mol\\,m^{-3}}$ and printed as floating-point numbers. No percentage-based answers are allowed. The program must be complete and runnable.",
            "solution": "The problem requires a critical comparison of two numerical time-integration schemes for a coupled system of ordinary differential equations (ODEs) describing mineral precipitation in a porous medium. The core task involves deriving the discrete equations for a globally implicit scheme and a simplified lagged-porosity scheme, analytically quantifying the mass conservation error of the latter, and implementing both to compute the cumulative error for a given set of test cases.\n\nThe governing continuous system is given by the conservation of aqueous mass and the evolution of porosity:\n$$\n\\frac{d}{dt}\\left(\\phi\\,c\\right) = -k\\,c \\quad (1)\n$$\n$$\n\\frac{d\\phi}{dt} = -V_m\\,k\\,c \\quad (2)\n$$\nwhere $\\phi$ is porosity, $c$ is aqueous concentration, $k$ is a first-order reaction rate coefficient, and $V_m$ is the molar volume of the solid mineral product.\n\n### Task 1: Derivation of Numerical Schemes\n\nWe consider a single time step of size $\\Delta t$ from time $t^n$ to $t^{n+1}$, with state variables evolving from $(\\phi^n, c^n)$ to $(\\phi^{n+1}, c^{n+1})$. A fully implicit (backward Euler) time discretization evaluates all terms, including nonlinear coefficients, at the future time level $t^{n+1}$.\n\n**Globally Implicit Scheme:**\nApplying a fully implicit discretization to both ODEs yields a coupled nonlinear system.\nFor equation $(1)$, the time derivative is approximated as $\\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t}$. The sink term on the right-hand side is evaluated at $t^{n+1}$. This gives the discrete mass conservation equation:\n$$\n\\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1} \\quad (3)\n$$\nFor equation $(2)$, the same discretization approach gives the discrete porosity evolution equation:\n$$\n\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = -V_m k c^{n+1} \\quad (4)\n$$\nEquations $(3)$ and $(4)$ form a system of two nonlinear algebraic equations for the two unknowns $\\phi^{n+1}$ and $c^{n+1}$. To solve this system, we can express $\\phi^{n+1}$ in terms of $c^{n+1}$ from equation $(4)$:\n$$\n\\phi^{n+1} = \\phi^n - \\Delta t V_m k c^{n+1} \\quad (5)\n$$\nSubstituting this expression for $\\phi^{n+1}$ into equation $(3)$ yields a single equation in $c^{n+1}$:\n$$\n\\frac{(\\phi^n - \\Delta t V_m k c^{n+1})c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1}\n$$\nRearranging this equation gives a quadratic equation for $c^{n+1}$:\n$$\n\\phi^n c^{n+1} - \\Delta t V_m k (c^{n+1})^2 - \\phi^n c^n = -\\Delta t k c^{n+1}\n$$\n$$\n(\\Delta t V_m k)(c^{n+1})^2 - (\\phi^n + \\Delta t k)c^{n+1} + \\phi^n c^n = 0 \\quad (6)\n$$\nThis quadratic equation can be solved for $c^{n+1}$. Once $c^{n+1}$ is found, $\\phi^{n+1}$ is determined from equation $(5)$.\n\n**Lagged-Porosity Scheme:**\nThis scheme is a simplification where the porosity in the accumulation term $\\frac{d}{dt}(\\phi c)$ is treated explicitly, i.e., evaluated at time $t^n$. This decouples the system, allowing for a sequential solution.\nThe discrete mass conservation equation becomes:\n$$\n\\frac{\\phi^n c^{n+1} - \\phi^n c^n}{\\Delta t} = -k c^{n+1} \\quad (7)\n$$\nThis equation is now linear in the unknown $c^{n+1}$ and can be solved directly:\n$$\n\\phi^n c^{n+1} + \\Delta t k c^{n+1} = \\phi^n c^n\n$$\n$$\nc^{n+1} = \\frac{\\phi^n c^n}{\\phi^n + \\Delta t k} \\quad (8)\n$$\nAfter solving for $c^{n+1}$, the porosity is updated using the same fully implicit equation as before, which is equation $(4)$:\n$$\n\\phi^{n+1} = \\phi^n - \\Delta t V_m k c^{n+1} \\quad (9)\n$$\n\n### Task 2: Analysis of Mass Conservation Error\n\nThe globally implicit residual for mass conservation, which must be zero for an exact solution to the discrete system, is:\n$$\nR_{\\mathrm{glob}}^{n+1} = \\frac{\\phi^{n+1}c^{n+1} - \\phi^n c^n}{\\Delta t} + k c^{n+1}\n$$\nWe can rewrite this by adding and subtracting $\\phi^n c^{n+1}$ in the numerator:\n$$\nR_{\\mathrm{glob}}^{n+1} = \\frac{\\phi^n c^{n+1} - \\phi^n c^n + \\phi^{n+1}c^{n+1} - \\phi^n c^{n+1}}{\\Delta t} + k c^{n+1}\n$$\n$$\nR_{\\mathrm{glob}}^{n+1} = \\left( \\frac{\\phi^n c^{n+1} - \\phi^n c^n}{\\Delta t} + k c^{n+1} \\right) + \\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t}\n$$\nThe term in parentheses is the residual for the lagged-porosity scheme for concentration, $R_{\\mathrm{lag},c}^{n+1}$. By design, the lagged scheme sets this term to zero. Therefore, the lagged-porosity scheme omits the second term, $\\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t}$, from the correct, globally-implicit mass balance equation. This omission is the source of the mass conservation error.\n\nThe per-step mass error is this omitted term. We are asked to express it in terms of $\\Delta t$, $k$, $V_m$, and $c^{n+1}$. We can use the porosity evolution equation, $\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t} = -V_m k c^{n+1}$, to substitute for the difference quotient:\n$$\n\\text{Mass Error Rate} = \\frac{(\\phi^{n+1} - \\phi^n)c^{n+1}}{\\Delta t} = \\left(\\frac{\\phi^{n+1} - \\phi^n}{\\Delta t}\\right)c^{n+1} = (-V_m k c^{n+1})c^{n+1}\n$$\n$$\n\\text{Mass Error Rate} = -V_m k (c^{n+1})^2\n$$\nThis quantity, with units of $\\mathrm{mol\\,m^{-3}\\,s^{-1}}$, represents the rate at which mass is artificially lost (since the sign is negative) by the lagged-porosity scheme in each time step relative to the mass-conserving globally implicit scheme.\n\n### Task 3 & 4: Implementation and Error Quantification\n\nThe two schemes are implemented as time-stepping loops from $t=0$ to $t=T$ with a constant step size $\\Delta t$.\n\n**Globally Implicit Scheme Implementation:**\nAt each time step $n$, given $(\\phi^n, c^n)$:\n1.  Handle the special case where $k=0$. Equation $(6)$ becomes $-\\phi^n c^{n+1} + \\phi^n c^n = 0$, so $c^{n+1} = c^n$. From equation $(5)$, $\\phi^{n+1} = \\phi^n$. The state is static.\n2.  For $k>0$, solve the quadratic equation $(6)$, $A(c^{n+1})^2 + B c^{n+1} + C = 0$, where $A = \\Delta t V_m k$, $B = -(\\phi^n + \\Delta t k)$, and $C = \\phi^n c^n$. The physically meaningful root is the smaller one, which approaches $c^n$ as $\\Delta t \\to 0$. To avoid subtractive cancellation, we use the stabilized quadratic formula for this root:\n    $$\n    c^{n+1} = \\frac{-B - \\sqrt{B^2 - 4AC}}{2A} = \\frac{2C}{-B + \\sqrt{B^2 - 4AC}}\n    $$\n    $$\n    c^{n+1} = \\frac{2(\\phi^n c^n)}{(\\phi^n + \\Delta t k) + \\sqrt{(\\phi^n + \\Delta t k)^2 - 4(\\Delta t V_m k)(\\phi^n c^n)}}\n    $$\n3.  Calculate the new porosity $\\phi^{n+1}$ using equation $(5)$.\n4.  Repeat for $N = T/\\Delta t$ steps.\n\n**Lagged-Porosity Scheme Implementation:**\nAt each time step $n$, given $(\\phi^n, c^n)$:\n1.  Calculate the new concentration $c^{n+1}$ using the direct formula from equation $(8)$.\n2.  Calculate the new porosity $\\phi^{n+1}$ using equation $(9)$.\n3.  Repeat for $N = T/\\Delta t$ steps.\n\n**Cumulative Error Calculation:**\nFor each test case, we run both simulations for $N=T/\\Delta t$ steps starting from $(\\phi_0, c_0)$. We obtain the final states $(\\phi^N_{\\mathrm{glob}}, c^N_{\\mathrm{glob}})$ and $(\\phi^N_{\\mathrm{lag}}, c^N_{\\mathrm{lag}})$. The cumulative mass error is then computed as:\n$$\nE_{\\mathrm{cum}} = \\phi^{N}_{\\mathrm{lag}} c^{N}_{\\mathrm{lag}} - \\phi^{N}_{\\mathrm{glob}} c^{N}_{\\mathrm{glob}}\n$$\nThis calculation is repeated for all five test cases provided.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    It runs two different time-integration schemes for a coupled ODE system\n    and calculates the difference in final mass.\n    \"\"\"\n    # Define constants and initial conditions from the problem statement.\n    phi_0 = 0.30  # Initial porosity (dimensionless)\n    c_0 = 100.0   # Initial concentration (mol/m^3)\n    V_m = 3.7e-5  # Mineral molar volume (m^3/mol)\n\n    # Define the test cases.\n    test_cases = [\n        # (dt, k, T)\n        (1.0, 1.0e-4, 1000.0),      # Test case 1\n        (100.0, 1.0e-4, 100000.0),   # Test case 2\n        (1000.0, 1.0e-4, 100000.0),  # Test case 3\n        (100.0, 0.0, 100000.0),      # Test case 4\n        (500.0, 5.0e-3, 10000.0)      # Test case 5\n    ]\n\n    results = []\n\n    for dt, k, T in test_cases:\n        num_steps = int(round(T / dt))\n\n        # Run globally implicit simulation\n        phi_glob, c_glob = run_simulation(\n            'globally_implicit', phi_0, c_0, V_m, k, dt, num_steps\n        )\n        # Run lagged porosity simulation\n        phi_lag, c_lag = run_simulation(\n            'lagged_porosity', phi_0, c_0, V_m, k, dt, num_steps\n        )\n\n        # Calculate the final aqueous mass per bulk volume for each scheme\n        mass_glob = phi_glob * c_glob\n        mass_lag = phi_lag * c_lag\n\n        # Calculate the cumulative mass error\n        E_cum = mass_lag - mass_glob\n        results.append(E_cum)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n\ndef run_simulation(scheme_type, phi_n, c_n, V_m, k, dt, num_steps):\n    \"\"\"\n    Runs a time-stepping simulation for the given scheme.\n\n    Args:\n        scheme_type (str): 'globally_implicit' or 'lagged_porosity'.\n        phi_n (float): Initial porosity.\n        c_n (float): Initial concentration.\n        V_m (float): Mineral molar volume.\n        k (float): Reaction rate coefficient.\n        dt (float): Time step size.\n        num_steps (int): Number of time steps.\n\n    Returns:\n        tuple: A tuple containing the final porosity and final concentration.\n    \"\"\"\n    for _ in range(num_steps):\n        if k == 0.0:\n            # If there is no reaction, phi and c do not change.\n            c_np1 = c_n\n            phi_np1 = phi_n\n        elif scheme_type == 'globally_implicit':\n            # Solve the quadratic equation for c^(n+1)\n            # A*x^2 + B*x + C = 0 where x = c^(n+1)\n            A = dt * V_m * k\n            B = -(phi_n + dt * k)\n            C = phi_n * c_n\n            \n            # Use the numerically stable quadratic formula for the smaller root\n            discriminant = B**2 - 4 * A * C\n            # The problem parameters ensure the discriminant is non-negative.\n            c_np1 = (2 * C) / (-B + np.sqrt(discriminant))\n\n            # Update porosity\n            phi_np1 = phi_n - dt * V_m * k * c_np1\n\n        elif scheme_type == 'lagged_porosity':\n            # Sequentially update c and then phi\n            c_np1 = (phi_n * c_n) / (phi_n + dt * k)\n            phi_np1 = phi_n - dt * V_m * k * c_np1\n        else:\n            raise ValueError(\"Unknown scheme type\")\n            \n        c_n, phi_n = c_np1, phi_np1\n        \n    return phi_n, c_n\n\n\n# Execute the main function\nsolve()\n```"
        },
        {
            "introduction": "Once a system of nonlinear residual equations is assembled, the workhorse for solving it is the Newton-Raphson method, which relies on the Jacobian matrix. This exercise delves into the practicalities of the Jacobian, from verifying your hand-derivation with automatic differentiation to analyzing the consequences of using an incomplete or approximate Jacobian . By applying the concepts of Inexact Newton theory, you will quantify how Jacobian errors slow convergence, providing critical insight into the performance and robustness of global implicit solvers.",
            "id": "4081056",
            "problem": "Consider a chemistry-only model problem that captures the essential nonlinearity and coupling encountered in Global Implicit Methods for Coupled Systems within Computational Geochemistry. We study a weak acid in water with electroneutrality and water autoionization. Let $h$ denote the hydrogen ion concentration $[\\mathrm{H}^+]$, $o$ denote the hydroxide ion concentration $[\\mathrm{OH}^-]$, and $a$ denote the conjugate base concentration $[\\mathrm{A}^-]$. The model is defined by three nonlinear equations based on well-tested geochemical relations: the law of mass action for water autoionization, electroneutrality, and total mass balance for the acid with the mass action relation for dissociation.\n\nThe residual vector $\\mathbf{F}(\\mathbf{x})$ maps $\\mathbb{R}^3$ to $\\mathbb{R}^3$ with $\\mathbf{x} = [h,a,o]^\\top$ and parameters $(K_w, K_a, C_T)$:\n- Water autoionization (law of mass action): $$f_1(h,a,o) = h\\,o - K_w.$$\n- Electroneutrality: $$f_2(h,a,o) = h - a - o.$$\n- Total acid mass balance with dissociation relation $[\\mathrm{HA}] = \\frac{h\\,a}{K_a}$: $$f_3(h,a,o) = C_T - a - \\dfrac{h\\,a}{K_a}.$$\n\nThe Newton method updates $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{s}_k$ by solving the linear system $$\\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k = -\\mathbf{F}(\\mathbf{x}_k),$$ where $\\mathbf{J}(\\mathbf{x}) = \\dfrac{\\partial \\mathbf{F}}{\\partial \\mathbf{x}}$ is the Jacobian matrix. The Inexact Newton theory studies the effect of solving the Newton linear system inexactly. If the step $\\mathbf{s}_k$ satisfies the forcing condition $$\\frac{\\left\\| \\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k + \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2} \\le \\eta_k,$$ then, under standard regularity assumptions near the solution, the next residual norm obeys a contraction estimate of the form $$\\frac{\\left\\|\\mathbf{F}(\\mathbf{x}_{k+1})\\right\\|_2}{\\left\\|\\mathbf{F}(\\mathbf{x}_k)\\right\\|_2} \\lesssim \\eta_k,$$ with equality in the limit for linear problems and with a proportionality constant approaching $1$ as $\\mathbf{x}_k$ approaches the solution for nonlinear problems with Lipschitz-continuous Jacobians.\n\nYou are to compare three Jacobian constructions:\n1. A hand-derived Jacobian $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$ computed analytically from $\\mathbf{F}(\\mathbf{x})$.\n2. An Automatic Differentiation (AD) Jacobian $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$ computed via forward-mode dual numbers.\n3. An incomplete hand Jacobian $\\tilde{\\mathbf{J}}(\\mathbf{x})$ that is missing the cross derivative term $\\dfrac{\\partial f_3}{\\partial h}$, i.e., set $\\dfrac{\\partial f_3}{\\partial h} = 0$ while keeping all other entries the same as $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$.\n\nStarting from an initial guess $$h_0 = \\sqrt{K_w}, \\quad a_0 = \\min(C_T, h_0), \\quad o_0 = \\frac{K_w}{h_0},$$ perform a single Newton update for both the exact and incomplete Jacobians:\n- Exact step: solve $\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{exact}} = -\\mathbf{F}(\\mathbf{x}_0)$ and set $\\mathbf{x}^{+}_{\\text{exact}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{exact}}$.\n- Incomplete step: solve $\\tilde{\\mathbf{J}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{inc}} = -\\mathbf{F}(\\mathbf{x}_0)$ and set $\\mathbf{x}^{+}_{\\text{inc}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{inc}}$.\n\nCompute the following five quantitative metrics for each test case:\n- The Frobenius norm of the difference between the hand-derived and AD Jacobians at the initial guess: $$\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F.$$\n- The Inexact Newton forcing term induced by the incomplete Jacobian at the initial guess: $$\\eta = \\frac{\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\,\\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n- The observed contraction for the incomplete Jacobian step: $$r_{\\text{inc}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n- The ratio of observed contraction to the forcing term: $$\\rho = \\frac{r_{\\text{inc}}}{\\eta}.$$\n- The observed contraction for the exact Jacobian step: $$r_{\\text{exact}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}.$$\n\nScientific realism and numerical plausibility are enforced by the parameter choices. Use molar concentration units implicitly; you do not need to output concentrations, only dimensionless metrics. The following four test cases form the test suite and must be used exactly as given:\n- Test Case 1 (moderately weak acid): $(K_w, K_a, C_T) = (10^{-14}, 1.8\\times 10^{-5}, 10^{-2})$.\n- Test Case 2 (very weak acid, dilute): $(K_w, K_a, C_T) = (10^{-14}, 10^{-9}, 10^{-3})$.\n- Test Case 3 (stronger acid behavior): $(K_w, K_a, C_T) = (10^{-14}, 10^{-1}, 10^{-3})$.\n- Test Case 4 (extremely dilute total acid): $(K_w, K_a, C_T) = (10^{-14}, 10^{-6}, 10^{-8})$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of five floating-point numbers in the order $[\\left\\| \\mathbf{J}_{\\text{hand}} - \\mathbf{J}_{\\text{AD}} \\right\\|_F,\\ \\eta,\\ r_{\\text{inc}},\\ \\rho,\\ r_{\\text{exact}}]$. For example, the output format must be of the form $$\\texttt{[[m11,m12,m13,m14,m15],[m21,m22,m23,m24,m25],[m31,m32,m33,m34,m35],[m41,m42,m43,m44,m45]]},$$ where each $\\texttt{mij}$ is a decimal representation of a float. No other text should be printed.",
            "solution": "The supplied problem is a valid exercise in computational science, specifically at the intersection of numerical analysis and computational geochemistry. It is scientifically grounded in fundamental chemical principles, mathematically well-posed, and all necessary components for a solution are specified unambiguously. I shall proceed with a detailed solution.\n\nThe core of this problem is the application and analysis of Newton's method for solving a system of nonlinear equations that models a weak acid equilibrium in water. The system, represented by the residual function $\\mathbf{F}(\\mathbf{x}) = \\mathbf{0}$, captures the essential nonlinearities and coupling between chemical species' concentrations.\n\nLet the state vector be $\\mathbf{x} = [h, a, o]^\\top$, where $h$, $a$, and $o$ are the concentrations of $\\mathrm{H}^+$, $\\mathrm{A}^-$, and $\\mathrm{OH}^-$, respectively. The system of equations is given by:\n$$f_1(h,a,o) = h\\,o - K_w = 0 \\quad (\\text{Water autoionization})$$\n$$f_2(h,a,o) = h - a - o = 0 \\quad (\\text{Electroneutrality})$$\n$$f_3(h,a,o) = C_T - a - \\frac{h\\,a}{K_a} = 0 \\quad (\\text{Total acid mass balance})$$\nHere, $K_w$ is the ion product of water, $K_a$ is the acid dissociation constant, and $C_T$ is the total concentration of the acid species $(\\mathrm{HA} + \\mathrm{A}^-)$.\n\nNewton's method iteratively refines an estimate $\\mathbf{x}_k$ by solving the linear system $\\mathbf{J}(\\mathbf{x}_k)\\,\\mathbf{s}_k = -\\mathbf{F}(\\mathbf{x}_k)$ for the update step $\\mathbf{s}_k$, where $\\mathbf{J}(\\mathbf{x})$ is the Jacobian matrix of $\\mathbf{F}(\\mathbf{x})$. The next iterate is then $\\mathbf{x}_{k+1} = \\mathbf{x}_k + \\mathbf{s}_k$.\n\n**1. Jacobian Matrix Derivations**\n\nThe Jacobian matrix $\\mathbf{J}(\\mathbf{x})$ is a matrix of first-order partial derivatives, $\\mathbf{J}_{ij} = \\frac{\\partial f_i}{\\partial x_j}$, where $\\mathbf{x} = [x_1, x_2, x_3]^\\top = [h, a, o]^\\top$.\n\n**Hand-Derived Jacobian, $\\mathbf{J}_{\\text{hand}}(\\mathbf{x})$**:\nWe compute the partial derivatives for each component of $\\mathbf{F}$:\n- For $f_1(h,a,o) = h\\,o - K_w$:\n  $$ \\frac{\\partial f_1}{\\partial h} = o, \\quad \\frac{\\partial f_1}{\\partial a} = 0, \\quad \\frac{\\partial f_1}{\\partial o} = h $$\n- For $f_2(h,a,o) = h - a - o$:\n  $$ \\frac{\\partial f_2}{\\partial h} = 1, \\quad \\frac{\\partial f_2}{\\partial a} = -1, \\quad \\frac{\\partial f_2}{\\partial o} = -1 $$\n- For $f_3(h,a,o) = C_T - a - \\frac{h\\,a}{K_a}$:\n  $$ \\frac{\\partial f_3}{\\partial h} = -\\frac{a}{K_a}, \\quad \\frac{\\partial f_3}{\\partial a} = -1 - \\frac{h}{K_a}, \\quad \\frac{\\partial f_3}{\\partial o} = 0 $$\n\nAssembling these derivatives yields the analytical Jacobian matrix:\n$$ \\mathbf{J}_{\\text{hand}}(\\mathbf{x}) = \\begin{pmatrix} o & 0 & h \\\\ 1 & -1 & -1 \\\\ -a/K_a & -1 - h/K_a & 0 \\end{pmatrix} $$\n\n**Automatic Differentiation Jacobian, $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$**:\nAutomatic Differentiation (AD) is a computational technique for evaluating derivatives of functions specified by computer programs. We use forward-mode AD based on dual numbers. A dual number has the form $z = u + \\epsilon v$, where $u$ is the \"primal\" part, $v$ is the \"tangent\" part, and $\\epsilon$ is an infinitesimal such that $\\epsilon^2 = 0$. Function evaluation $f(u + \\epsilon v)$ yields $f(u) + \\epsilon f'(u)v$ by Taylor expansion.\n\nTo compute the $j$-th column of the Jacobian, $\\frac{\\partial \\mathbf{F}}{\\partial x_j}$, we evaluate $\\mathbf{F}$ with the input vector $\\mathbf{x} + \\epsilon \\mathbf{e}_j$, where $\\mathbf{e}_j$ is the $j$-th standard basis vector. The tangent part of the result, $\\mathbf{F}(\\mathbf{x} + \\epsilon \\mathbf{e}_j) = \\mathbf{F}(\\mathbf{x}) + \\epsilon \\frac{\\partial \\mathbf{F}}{\\partial x_j}(\\mathbf{x})$, gives the desired column. For a $3$-variable system, this is performed $3$ times to construct the full Jacobian $\\mathbf{J}_{\\text{AD}}(\\mathbf{x})$. The first metric, $\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F$, serves as a verification that the hand-derivation is correct. We expect this norm to be zero up to machine precision.\n\n**Incomplete Jacobian, $\\tilde{\\mathbf{J}}(\\mathbf{x})$**:\nThis Jacobian is constructed by deliberately introducing an error into the analytical Jacobian. As specified, we set the cross-derivative term $\\frac{\\partial f_3}{\\partial h}$ to zero:\n$$ \\tilde{\\mathbf{J}}(\\mathbf{x}) = \\begin{pmatrix} o & 0 & h \\\\ 1 & -1 & -1 \\\\ 0 & -1 - h/K_a & 0 \\end{pmatrix} $$\nThis type of approximation is common in computational science, where certain coupling terms may be ignored to simplify the Jacobian structure (e.g., for block-diagonal preconditioning) or because they are assumed to be small.\n\n**2. The Inexact Newton Framework and Metrics**\n\nUsing an approximate Jacobian $\\tilde{\\mathbf{J}}$ instead of the true Jacobian $\\mathbf{J}$ transforms the Newton iteration into an Inexact Newton method. The step $\\mathbf{s}_{\\text{inc}}$ is computed from $\\tilde{\\mathbf{J}}(\\mathbf{x}_0) \\mathbf{s}_{\\text{inc}} = -\\mathbf{F}(\\mathbf{x}_0)$.\n\nThe degree to which this step fails to satisfy the true Newton linear system is measured by the residual of that system:\n$$ \\mathbf{r}_{\\text{lin}} = \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) \\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) $$\nThe Inexact Newton forcing term, $\\eta$, is the normalized magnitude of this linear residual:\n$$ \\eta = \\frac{\\left\\| \\mathbf{r}_{\\text{lin}} \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2} = \\frac{\\left\\| \\left(\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\tilde{\\mathbf{J}}(\\mathbf{x}_0)\\right) \\mathbf{s}_{\\text{inc}} \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2} $$\nInexact Newton theory posits that if $\\eta$ is sufficiently small, convergence is still achieved. The theory predicts a one-step contraction of the nonlinear residual norm, $\\left\\| \\mathbf{F}(\\mathbf{x}_{k+1}) \\right\\|_2 / \\left\\| \\mathbf{F}(\\mathbf{x}_k) \\right\\|_2$, that is proportional to $\\eta_k$.\n\nThe required metrics formalize this comparison:\n- $r_{\\text{inc}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$: The observed single-step reduction in the residual norm using the incomplete Jacobian.\n- $\\rho = \\frac{r_{\\text{inc}}}{\\eta}$: This ratio compares the observed contraction to the theoretical upper bound. Values of $\\rho$ near $1$ indicate that the forcing term $\\eta$ is a sharp predictor of the method's performance.\n- $r_{\\text{exact}} = \\frac{\\left\\| \\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}}) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$: The observed contraction for a true Newton step, which serves as a benchmark for quadratic convergence (i.e., this value should be very small).\n\n**3. Computational Procedure**\n\nFor each test case defined by parameters $(K_w, K_a, C_T)$:\n1.  Calculate the initial guess $\\mathbf{x}_0 = [h_0, a_0, o_0]^\\top$ where $h_0 = \\sqrt{K_w}$, $a_0 = \\min(C_T, h_0)$, and $o_0 = K_w/h_0$.\n2.  Evaluate the residual vector $\\mathbf{F}(\\mathbf{x}_0)$.\n3.  Construct the three Jacobians at $\\mathbf{x}_0$: $\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)$, $\\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0)$, and $\\tilde{\\mathbf{J}}(\\mathbf{x}_0)$.\n4.  Compute the Frobenius norm of the difference, $\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0) - \\mathbf{J}_{\\text{AD}}(\\mathbf{x}_0) \\right\\|_F$.\n5.  Solve the two linear systems to find the steps:\n    -   $\\mathbf{s}_{\\text{exact}} = - (\\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0))^{-1} \\mathbf{F}(\\mathbf{x}_0)$.\n    -   $\\mathbf{s}_{\\text{inc}} = - (\\tilde{\\mathbf{J}}(\\mathbf{x}_0))^{-1} \\mathbf{F}(\\mathbf{x}_0)$.\n6.  Calculate the updated states $\\mathbf{x}^{+}_{\\text{exact}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{exact}}$ and $\\mathbf{x}^{+}_{\\text{inc}} = \\mathbf{x}_0 + \\mathbf{s}_{\\text{inc}}$.\n7.  Compute the forcing term $\\eta = \\frac{\\left\\| \\mathbf{J}_{\\text{hand}}(\\mathbf{x}_0)\\mathbf{s}_{\\text{inc}} + \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}{\\left\\| \\mathbf{F}(\\mathbf{x}_0) \\right\\|_2}$.\n8.  Evaluate the new residuals $\\mathbf{F}(\\mathbf{x}^{+}_{\\text{inc}})$ and $\\mathbf{F}(\\mathbf{x}^{+}_{\\text{exact}})$.\n9.  Compute the contraction ratios $r_{\\text{inc}}$, $\\rho$, and $r_{\\text{exact}}$.\n10. Collect these five metrics for the final output. The procedure is repeated for all four test cases.",
            "answer": "```python\nimport numpy as np\n\nclass Dual:\n    \"\"\"\n    A simple implementation of a dual number for forward-mode automatic differentiation.\n    \"\"\"\n    def __init__(self, u, v=0.0):\n        # u: primal part, v: tangent part\n        self.u = u\n        self.v = v\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u + other.u, self.v + other.v)\n        return Dual(self.u + other, self.v)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u - other.u, self.v - other.v)\n        return Dual(self.u - other, self.v)\n\n    def __rsub__(self, other):\n        return Dual(other - self.u, -self.v)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u * other.u, self.u * other.v + self.v * other.u)\n        return Dual(self.u * other, self.v * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.u / other.u, (self.v * other.u - self.u * other.v) / (other.u ** 2))\n        return Dual(self.u / other, self.v / other)\n        \n    def __rtruediv__(self, other):\n        return Dual(other / self.u, -other * self.v / (self.u ** 2))\n\ndef solve():\n    \"\"\"\n    Main function to execute the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        (1e-14, 1.8e-5, 1e-2),  # Case 1: moderately weak acid\n        (1e-14, 1e-9, 1e-3),   # Case 2: very weak acid, dilute\n        (1e-14, 1e-1, 1e-3),   # Case 3: stronger acid behavior\n        (1e-14, 1e-6, 1e-8),   # Case 4: extremely dilute total acid\n    ]\n\n    results = []\n\n    for Kw, Ka, Ct in test_cases:\n        # --- State and Function Definitions ---\n        \n        def F_vec(x, Kw, Ka, Ct):\n            \"\"\" Residual vector F(x) \"\"\"\n            h, a, o = x\n            f1 = h * o - Kw\n            f2 = h - a - o\n            f3 = Ct - a - (h * a) / Ka\n            return np.array([f1, f2, f3])\n\n        def J_hand(x, Ka):\n            \"\"\" Hand-derived Jacobian J_hand(x) \"\"\"\n            h, a, o = x\n            J = np.array([\n                [o, 0, h],\n                [1, -1, -1],\n                [-a / Ka, -1 - h / Ka, 0]\n            ])\n            return J\n\n        def J_AD(x, Kw, Ka, Ct):\n            \"\"\" AD-computed Jacobian J_AD(x) \"\"\"\n            J = np.zeros((3, 3))\n            \n            def F_dual(x_dual, Kw, Ka, Ct):\n                h, a, o = x_dual\n                f1 = h * o - Kw\n                f2 = h - a - o\n                f3 = Ct - a - (h * a) / Ka\n                return [f1, f2, f3]\n\n            for j in range(3):\n                x_dual = [Dual(val, 1.0 if i == j else 0.0) for i, val in enumerate(x)]\n                F_res_dual = F_dual(x_dual, Kw, Ka, Ct)\n                J[:, j] = [res.v for res in F_res_dual]\n            return J\n            \n        def J_incomplete(x, Ka):\n            \"\"\" Incomplete Jacobian J_tilde(x) \"\"\"\n            h, a, o = x\n            J = np.array([\n                [o, 0, h],\n                [1, -1, -1],\n                [0, -1 - h / Ka, 0]\n            ])\n            return J\n\n        # --- Step 1: Initial Guess ---\n        h0 = np.sqrt(Kw)\n        a0 = min(Ct, h0)\n        o0 = Kw / h0\n        x0 = np.array([h0, a0, o0])\n\n        # --- Step 2: Evaluate residuals and Jacobians at x0 ---\n        F_x0 = F_vec(x0, Kw, Ka, Ct)\n        J_hand_x0 = J_hand(x0, Ka)\n        J_ad_x0 = J_AD(x0, Kw, Ka, Ct)\n        J_inc_x0 = J_incomplete(x0, Ka)\n\n        # --- Step 3: Compute Metrics ---\n\n        # Metric 1: Frobenius norm of Jacobian difference\n        metric1 = np.linalg.norm(J_hand_x0 - J_ad_x0, 'fro')\n\n        # --- Solve linear systems for Newton steps ---\n        s_exact = np.linalg.solve(J_hand_x0, -F_x0)\n        s_inc = np.linalg.solve(J_inc_x0, -F_x0)\n\n        # --- Update states ---\n        x_plus_exact = x0 + s_exact\n        x_plus_inc = x0 + s_inc\n\n        # --- Evaluate new residuals ---\n        F_x_plus_exact = F_vec(x_plus_exact, Kw, Ka, Ct)\n        F_x_plus_inc = F_vec(x_plus_inc, Kw, Ka, Ct)\n        \n        # Norms of residuals\n        norm_F_x0 = np.linalg.norm(F_x0, 2)\n        norm_F_x_plus_exact = np.linalg.norm(F_x_plus_exact, 2)\n        norm_F_x_plus_inc = np.linalg.norm(F_x_plus_inc, 2)\n        \n        # Prevent division by zero if initial residual is zero\n        if norm_F_x0 == 0:\n            # This case corresponds to starting at the solution. All metrics would be 0 or undefined.\n            # Setting them to 0 is a reasonable convention.\n            metric2 = 0.0\n            metric3 = 0.0\n            metric4 = 0.0\n            metric5 = 0.0\n        else:\n            # Metric 2: Inexact Newton forcing term (eta)\n            linear_residual = J_hand_x0 @ s_inc + F_x0\n            metric2 = np.linalg.norm(linear_residual, 2) / norm_F_x0\n            \n            # Metric 3: Observed contraction for incomplete Jacobian (r_inc)\n            metric3 = norm_F_x_plus_inc / norm_F_x0\n            \n            # Metric 4: Ratio of observed contraction to forcing term (rho)\n            metric4 = metric3 / metric2 if metric2 != 0 else float('inf')\n\n            # Metric 5: Observed contraction for exact Jacobian (r_exact)\n            metric5 = norm_F_x_plus_exact / norm_F_x0\n        \n        case_results = [metric1, metric2, metric3, metric4, metric5]\n        results.append(case_results)\n    \n    # Final print statement in the exact required format.\n    # The format '[[m11,...],[m21,...],...]' is constructed by str(list_of_lists)\n    # and removing spaces, which is more robust than manual string formatting.\n    formatted_results = str(results).replace(\" \", \"\")\n    print(formatted_results)\n\nsolve()\n```"
        }
    ]
}