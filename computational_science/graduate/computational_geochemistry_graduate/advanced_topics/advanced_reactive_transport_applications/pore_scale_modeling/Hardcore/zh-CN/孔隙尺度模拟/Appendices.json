{
    "hands_on_practices": [
        {
            "introduction": "孔隙尺度建模工作流的初始阶段，是处理和净化从微计算机断层扫描（micro-CT）等成像技术中获得的数字岩石图像。此练习旨在通过应用数学形态学中的基本运算——开运算和闭运算，来处理一个合成的二进制岩石图像。通过这个实践，您将学习如何有效去除常见的“椒盐”噪声伪影，并量化这些平滑操作对孔隙-岩石界面总面积的影响，这是表征多孔介质几何特征的关键一步 。",
            "id": "4095925",
            "problem": "给定一个三维二元图像，它代表了在孔隙尺度上的数字岩石物理分割，该分割在一个立方晶格上建模，体素边长为 $\\Delta$ 米。该二元场为 $X:\\mathbb{Z}^3\\to\\{0,1\\}$，其中 $X(\\mathbf{i})=1$ 表示孔隙体素，$X(\\mathbf{i})=0$ 表示岩石体素。考虑定义在离散晶格集合上的数学形态学操作。设 $B\\subset \\mathbb{Z}^3$ 是一个以原点为中心、半径为 $r$ 个体素的球形结构元，并设 $X$ 表示孔隙集合。腐蚀操作 $X\\ominus B$ 会移除那些不能完全容纳 $B$ 的孔隙体素，而膨胀操作 $X\\oplus B$ 则会添加通过平移 $B$ 可以触及的孔隙体素。形态学开运算为 $(X\\ominus B)\\oplus B$，形态学闭运算为 $(X\\oplus B)\\ominus B$。对 $X$ 进行这些操作可用于抑制椒盐噪声伪影，并平滑相间的锯齿状界面。在离散晶格中，孔隙相与岩石相之间的界面表面积可以通过计算界面处的体素面来求得。从离散晶格的描述出发，并根据每个界面面的面积贡献等于 $\\Delta^2$（一个体素面的面积）的定义，通过沿立方晶格主轴方向计数界面面并在不重复计数的情况下汇总其面积贡献，推导出一个用于计算孔隙-岩石界面总表面积 $S(X,\\Delta)$ 的基于体素的估计器。使用该估计器量化形态学开运算和闭运算如何改变界面面积。\n\n你的任务是使用半径为 $r$ 个体素的球形结构元 $B$，对孔隙集合 $X$ 实现形态学开运算和闭运算，并计算每次操作前后的 $S(X,\\Delta)$。然后计算变化量 $\\Delta S_{\\mathrm{open}}=S(X_{\\mathrm{open}},\\Delta)-S(X,\\Delta)$ 和 $\\Delta S_{\\mathrm{close}}=S(X_{\\mathrm{close}},\\Delta)-S(X,\\Delta)$，其中 $X_{\\mathrm{open}}$ 和 $X_{\\mathrm{close}}$ 分别是对 $X$ 应用开运算和闭运算的结果。所有表面积必须以 $\\mathrm{m}^2$ 为单位表示。\n\n实现一个程序，构建包含以下合成二元体数据和参数的科学真实测试套件：\n\n- 案例A（包含球形孔隙和散斑噪声的一般情况）：\n    - 体数据大小：$N=(64,64,64)$ 体素。\n    - 体素大小：$\\Delta=2\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：一个半径为 15 个体素的单一球形孔隙，中心位于 $(32,32,32)$。\n    - 散斑伪影：在整个体数据上，随机均匀地翻转比例为 $p=5\\times 10^{-3}$ 的体素状态（影响两相的椒盐噪声）。\n    - 结构元：半径为 $r=2$ 个体素的球形 $B$。\n    - 用于可复现性的随机种子：$42$。\n\n- 案例B（具有平面界面且无噪声的边界条件）：\n    - 体数据大小：$N=(64,64,64)$ 体素。\n    - 体素大小：$\\Delta=2\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：一个平面半空间孔隙，其中如果 $i_x  32$，则 $X(i_x,i_y,i_z)=1$，否则 $X(i_x,i_y,i_z)=0$。\n    - 散斑伪影：无，$p=0$。\n    - 结构元：半径为 $r=2$ 个体素的球形 $B$。\n\n- 案例C（具有接近形态学阈值的微小孔隙并带有噪声的边缘情况）：\n    - 体数据大小：$N=(32,32,32)$ 体素。\n    - 体素大小：$\\Delta=1\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：在其余为岩石基质中，有三个半径为 1 个体素的微小球形孔隙，中心分别位于 $(8,8,8)$、$(16,20,12)$ 和 $(24,10,24)$。\n    - 散斑伪影：随机均匀地翻转比例为 $p=10^{-2}$ 的体素状态。\n    - 结构元：半径为 $r=2$ 个体素的球形 $B$。\n    - 用于可复现性的随机种子：$7$。\n\n对每个案例，计算列表 $[S(X,\\Delta), S(X_{\\mathrm{open}},\\Delta), S(X_{\\mathrm{close}},\\Delta), \\Delta S_{\\mathrm{open}}, \\Delta S_{\\mathrm{close}}]$。将所有表面积以 $\\mathrm{m}^2$ 为单位表示为浮点数。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表将按顺序把案例 A、B 和 C 的结果聚合为一个列表的列表，例如 $[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "用户提供的问题是有效的。它在科学上基于数学形态学和计算物理学的原理，特别是在数字岩石物理领域。问题是适定的，提供了所有必要的参数，包括体数据维度、体素分辨率、几何定义、结构元规格以及用于可复现性的随机种子。问题陈述是客观的，使用了精确、正式的语言。它没有表现出验证标准中列出的任何缺陷，例如事实不健全、模糊不清或不适定。因此，将提供一个合理的解决方案。\n\n这个问题的核心在于实现和量化两种基本形态学操作（开运算和闭运算）对多孔介质的离散三维二元表示的影响。这些操作用于过滤噪声和正则化界面，这反过来又会影响诸如界面表面积之类的几何属性。\n\n首先，我们必须在离散立方晶格的背景下形式化这些定义。设二元图像由函数 $X(\\mathbf{i}): \\mathbb{Z}^3 \\to \\{0, 1\\}$ 表示，其中 $\\mathbf{i}=(i_x, i_y, i_z)$ 是一个体素索引。$X(\\mathbf{i})=1$ 表示孔隙相，$X(\\mathbf{i})=0$ 表示固相（岩石）。所有孔隙体素的集合是 $P = \\{\\mathbf{i} \\in \\mathbb{Z}^3 \\mid X(\\mathbf{i}) = 1\\}$。\n\n结构元 $B$ 是一个相对于原点的体素偏移量集合，也定义在 $\\mathbb{Z}^3$ 上。问题指定了一个半径为 $r$ 个体素的球形结构元，它是所有与原点的欧几里得距离小于或等于 $r$ 的整数格点的集合：\n$$ B = \\{ \\mathbf{b} \\in \\mathbb{Z}^3 \\mid \\|\\mathbf{b}\\|_2 \\le r \\} = \\{ (b_x, b_y, b_z) \\in \\mathbb{Z}^3 \\mid \\sqrt{b_x^2 + b_y^2 + b_z^2} \\le r \\} $$\n\n用结构元 $B$ 对孔隙集 $P$ 进行的基本形态学操作——腐蚀和膨胀定义如下：\n- **腐蚀**：$P \\ominus B = \\{ \\mathbf{p} \\in \\mathbb{Z}^3 \\mid B_{\\mathbf{p}} \\subseteq P \\}$，其中 $B_{\\mathbf{p}} = \\{ \\mathbf{p} + \\mathbf{b} \\mid \\mathbf{b} \\in B \\}$ 是将 $B$ 平移到点 $\\mathbf{p}$。腐蚀通过移除任何不能使结构元完全容纳于原始孔隙空间内的孔隙体素，从而有效地收缩了孔隙空间。\n- **膨胀**：$P \\oplus B = \\bigcup_{\\mathbf{p} \\in P} B_{\\mathbf{p}}$。膨胀会扩张孔隙空间。如果结构元以某个体素为中心时与原始孔隙空间重叠，则该体素被包含在膨胀后的集合中。对于像球体这样的对称结构元，这等价于 $\\{ \\mathbf{q} \\in \\mathbb{Z}^3 \\mid B_{\\mathbf{q}} \\cap P \\neq \\emptyset \\}$。\n\n基于这些，开运算和闭运算被定义为复合运算：\n- **开运算**：$P_{\\mathrm{open}} = (P \\ominus B) \\oplus B$。开运算可以平滑孔隙空间的轮廓，断开狭窄的连接（峡部），并消除比结构元小的、孤立的孔隙区域（岛）。\n- **闭运算**：$P_{\\mathrm{close}} = (P \\oplus B) \\ominus B$。闭运算同样可以平滑轮廓，但它是通过填充比结构元小的、孔隙空间中的狭窄缝隙和小孔来实现的。\n\n接下来，我们讨论界面表面积 $S(X, \\Delta)$ 的估计。在一个立方晶格上，每个体素的边长为 $\\Delta$，因此一个体素面的面积为 $\\Delta^2$。总界面面积是孔隙体素与岩石体素之间所有共享面的面积之和。一个稳健且能避免重复计数这些面的方法是：遍历所有体素，并对每个体素检查其在正轴方向上的邻居。如果体素 $\\mathbf{i}$ 与其邻居 $\\mathbf{i}+\\mathbf{e}_k$（其中 $\\mathbf{e}_k$ 是沿坐标轴 $k \\in \\{x,y,z\\}$ 的单位向量）的相值不同，即 $X(\\mathbf{i}) \\neq X(\\mathbf{i}+\\mathbf{e}_k)$，则它们之间存在一个界面。此类界面面的总数 $N_{\\text{faces}}$ 为：\n$$ N_{\\text{faces}}(X) = \\sum_{i_x, i_y, i_z} \\left( \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x+1, i_y, i_z)] + \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x, i_y+1, i_z)] + \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x, i_y, i_z+1)] \\right) $$\n其中 $\\mathbb{I}[\\cdot]$ 是指示函数，求和遍及所有使体素对有效的索引。总表面积则为：\n$$ S(X, \\Delta) = N_{\\text{faces}}(X) \\cdot \\Delta^2 $$\n\n实现过程将首先为每个指定的测试案例构建二元体数据。形态学操作是计算密集型的，最好使用优化的库函数来执行，例如 `scipy.ndimage` 中提供的函数。`scipy.ndimage.binary_opening` 和 `scipy.ndimage.binary_closing` 函数使用所提供的结构元直接实现了所需的操作。表面积将使用离散求和公式计算，该公式可以通过比较体数据数组的移位版本，利用 `numpy` 数组操作高效实现。\n\n最后，对于每个案例，我们将计算初始表面积 $S(X, \\Delta)$、开运算后的面积 $S(X_{\\mathrm{open}}, \\Delta)$ 以及闭运算后的面积 $S(X_{\\mathrm{close}}, \\Delta)$。表面积的变化量为 $\\Delta S_{\\mathrm{open}} = S(X_{\\mathrm{open}}, \\Delta) - S(X, \\Delta)$ 和 $\\Delta S_{\\mathrm{close}} = S(X_{\\mathrm{close}}, \\Delta) - S(X, \\Delta)$。开运算和闭运算都是平滑操作，通常会减少高频空间变化（如噪声和尖角），因此通常会导致总界面表面积的减少（即 $\\Delta S \\le 0$）。\n\n每个测试案例的流程如下：\n1.  定义参数：体数据大小 $N$、体素大小 $\\Delta$、结构元半径 $r$ 和噪声参数。\n2.  根据几何规定生成初始三维二元体数据 $X$，如果指定，则使用给定的随机种子添加噪声以保证可复现性。\n3.  生成半径为 $r$ 的球形结构元 $B$。\n4.  计算初始表面积 $S_0 = S(X, \\Delta)$。\n5.  使用 $B$ 对 $X$ 应用形态学开运算以获得 $X_{\\mathrm{open}}$。计算新表面积 $S_{\\mathrm{open}} = S(X_{\\mathrm{open}}, \\Delta)$。\n6.  使用 $B$ 对 $X$ 应用形态学闭运算以获得 $X_{\\mathrm{close}}$。计算新表面积 $S_{\\mathrm{close}} = S(X_{\\mathrm{close}}, \\Delta)$。\n7.  计算差值 $\\Delta S_{\\mathrm{open}} = S_{\\mathrm{open}} - S_0$ 和 $\\Delta S_{\\mathrm{close}} = S_{\\mathrm{close}} - S_0$。\n8.  汇总五个计算值 $[S_0, S_{\\mathrm{open}}, S_{\\mathrm{close}}, \\Delta S_{\\mathrm{open}}, \\Delta S_{\\mathrm{close}}]$。\n最终输出将是一个包含所有三个测试案例汇总结果的列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    \"\"\"\n\n    def generate_sphere_strele(radius: int) -> np.ndarray:\n        \"\"\"\n        Generates a 3D spherical structuring element.\n        \n        Args:\n            radius: The radius of the sphere in voxels.\n\n        Returns:\n            A boolean numpy array representing the spherical structuring element.\n        \"\"\"\n        diameter = 2 * radius + 1\n        x, y, z = np.mgrid[-radius:radius+1, -radius:radius+1, -radius:radius+1]\n        dist_sq = x**2 + y**2 + z**2\n        return dist_sq = radius**2\n\n    def calculate_surface_area(volume: np.ndarray, delta: float) -> float:\n        \"\"\"\n        Calculates the interfacial surface area of a 3D binary volume.\n\n        Args:\n            volume: A 3D numpy array with 0s and 1s.\n            delta: The edge length of a single voxel in meters.\n\n        Returns:\n            The total interfacial surface area in square meters.\n        \"\"\"\n        if volume.ndim != 3:\n            raise ValueError(\"Input volume must be a 3D array.\")\n        \n        # Count interfaces along each axis by comparing neighboring voxels\n        # An interface exists if adjacent voxels have different values (0 vs 1)\n        faces_x = np.sum(volume[:-1, :, :] != volume[1:, :, :])\n        faces_y = np.sum(volume[:, :-1, :] != volume[:, 1:, :])\n        faces_z = np.sum(volume[:, :, :-1] != volume[:, :, 1:])\n        \n        total_faces = faces_x + faces_y + faces_z\n        return total_faces * (delta ** 2)\n\n    def generate_noisy_volume(base_volume: np.ndarray, noise_fraction: float, seed: int) -> np.ndarray:\n        \"\"\"Applies salt-and-pepper noise to a binary volume.\"\"\"\n        if noise_fraction == 0:\n            return base_volume.copy()\n            \n        rng = np.random.default_rng(seed)\n        noisy_volume = base_volume.copy()\n        total_voxels = noisy_volume.size\n        num_flips = int(noise_fraction * total_voxels)\n        \n        # Generate unique indices to flip\n        indices_to_flip = rng.choice(total_voxels, size=num_flips, replace=False)\n        flat_volume = noisy_volume.flatten()\n        flat_volume[indices_to_flip] = 1 - flat_volume[indices_to_flip]\n        \n        return flat_volume.reshape(base_volume.shape)\n\n    def process_case(params: dict):\n        \"\"\"Processes a single test case.\"\"\"\n        N = params['N']\n        delta = params['delta']\n        r = params['r']\n        noise_p = params['p']\n        seed = params['seed']\n\n        # Generate base geometry\n        if params['case_id'] == 'A':\n            center = np.array(params['pore_center'])\n            radius = params['pore_radius']\n            coords = np.mgrid[0:N[0], 0:N[1], 0:N[2]]\n            dist_sq = np.sum((coords - center[:, np.newaxis, np.newaxis, np.newaxis])**2, axis=0)\n            initial_volume = (dist_sq = radius**2).astype(np.int8)\n        elif params['case_id'] == 'B':\n            initial_volume = np.zeros(N, dtype=np.int8)\n            initial_volume[:32, :, :] = 1\n        elif params['case_id'] == 'C':\n            initial_volume = np.zeros(N, dtype=np.int8)\n            coords = np.mgrid[0:N[0], 0:N[1], 0:N[2]]\n            for center_info in params['pore_info']:\n                center, radius = np.array(center_info[0]), center_info[1]\n                dist_sq = np.sum((coords - center[:, np.newaxis, np.newaxis, np.newaxis])**2, axis=0)\n                initial_volume[dist_sq = radius**2] = 1\n        else:\n            raise ValueError(f\"Unknown case_id: {params['case_id']}\")\n\n        # Add noise\n        X = generate_noisy_volume(initial_volume, noise_p, seed)\n        \n        # Generate structuring element\n        B = generate_sphere_strele(r)\n\n        # Calculate initial surface area\n        S_initial = calculate_surface_area(X, delta)\n\n        # Morphological opening\n        X_open = ndimage.binary_opening(X, structure=B).astype(X.dtype)\n        S_open = calculate_surface_area(X_open, delta)\n        dS_open = S_open - S_initial\n\n        # Morphological closing\n        X_close = ndimage.binary_closing(X, structure=B).astype(X.dtype)\n        S_close = calculate_surface_area(X_close, delta)\n        dS_close = S_close - S_initial\n\n        return [S_initial, S_open, S_close, dS_open, dS_close]\n\n    test_cases = [\n        {\n            'case_id': 'A',\n            'N': (64, 64, 64), 'delta': 2e-6,\n            'pore_radius': 15, 'pore_center': (32, 32, 32),\n            'p': 5e-3, 'r': 2, 'seed': 42\n        },\n        {\n            'case_id': 'B',\n            'N': (64, 64, 64), 'delta': 2e-6,\n            'p': 0.0, 'r': 2, 'seed': None\n        },\n        {\n            'case_id': 'C',\n            'N': (32, 32, 32), 'delta': 1e-6,\n            'pore_info': [\n                ((8, 8, 8), 1),\n                ((16, 20, 12), 1),\n                ((24, 10, 24), 1)\n            ],\n            'p': 1e-2, 'r': 2, 'seed': 7\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result_list = process_case(case_params)\n        results.append(result_list)\n    \n    # Format output as a list of lists string\n    # e.g., [[val1, val2], [val3, val4]]\n    # str() on a list produces the correct string representation\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在拥有一个清晰的数字岩石几何模型后，下一步是使用诸如格子玻尔兹曼方法（LBM）之类的数值工具来模拟流体流动并计算渗透率等物理性质。然而，在使用任何模拟结果之前，我们必须验证其数值准确性。本练习将指导您完成一个标准的网格加密研究，使用理查德森外推法（Richardson extrapolation）来分析不同分辨率下的模拟渗透率数据，从而估算数值方案的收敛阶数 $p$ 和连续介质极限下的渗透率 $k_{\\infty}$ 。掌握这项技能对于确保计算模型的可靠性和准确性至关重要。",
            "id": "4096000",
            "problem": "考虑一个在计算地球化学领域内，基于数字岩石物理（Digital Rock Physics, DRP）和格子玻尔兹曼方法（Lattice Boltzmann Method, LBM）的二维孔隙尺度流动问题。一个高度为 $H$ 的直通道被离散化到规则的晶格上，作为估算渗透率的代表性“数字岩石”，并通过改变壁面边界格式来研究其对分辨率相关误差的影响。平面泊肃叶流的连续介质极限渗透率由达西定律作为本构关系定义：对于高度为 $H$ 的通道，在无量纲晶格单位下，连续介质极限渗透率为 $k_{\\infty} = H^2 / 12$，这是平行板间粘性层流中广为接受的事实。在使用无滑移壁面的LBM数值离散化中，由于依赖于网格间距 $h$ 和壁面边界格式的截断误差，计算出的渗透率 $k(h)$ 会偏离连续介质极限 $k_{\\infty}$。我们采用标准的数值分析模型，即在网格加密的渐近区域（$h \\rightarrow 0$），主阶误差表现为 $k(h) = k_{\\infty} + C \\, h^{p}$，其中 $C$ 是一个依赖于格式的常数，$p$ 是给定几何形状下壁面边界格式的精度阶。目标是通过网格加密研究估计 $p$ 和 $k_{\\infty}$，然后量化每个分辨率下的相对渗透率误差。\n\n您的任务是编写一个完整的程序，该程序在给定来自LBM的、具有恒定加密比和两种不同壁面边界格式的三个连续网格加密级别的实测渗透率值的情况下，将：\n\n- 通过网格加密和使用渐近误差模型 $k(h) = k_{\\infty} + C \\, h^{p}$ 外推到连续介质极限，来估计表观精度阶 $p$ 和连续介质极限渗透率 $k_{\\infty}$。\n- 计算每个分辨率下的相对误差 $E = |k(h) - k_{\\infty}| / k_{\\infty}$。\n- 按照指定的输出格式汇总所有测试用例的结果。\n\n本问题中的所有量均为无量纲晶格单位。不涉及角度，也不需要进行物理单位转换。\n\n该测试套件包括应用于相同通道几何高度 $H = 1$ 的两种边界格式，具有三个网格分辨率，其特征是通道上的节点数 $N \\in \\{32, 64, 128\\}$，因此 $h = H/N$。恒定的加密比因此为 $r = h_1 / h_2 = h_2 / h_3 = 2$。\n\n- 测试用例1（方案A：阶梯状壁上的基本反弹格式）：\n  - 通道高度 $H = 1$。\n  - 分辨率 $N = [32, 64, 128]$。\n  - 每个 $N$ 对应的实测渗透率 $k(h)$：$[0.09895833333333333, 0.09114583333333333, 0.08723958333333333]$。\n\n- 测试用例2（方案B：模拟插值反弹的改进壁面处理）：\n  - 通道高度 $H = 1$。\n  - 分辨率 $N = [32, 64, 128]$。\n  - 每个 $N$ 对应的实测渗透率 $k(h)$：$[0.08338216145833333, 0.08334554036458333, 0.08333638509114583]$。\n\n您的程序必须为每个测试用例计算：\n1. 从三级网格加密中估计出的壁面边界格式的精度阶 $p$。\n2. 外推得到的连续介质极限渗透率 $k_{\\infty}$。\n3. 在每个分辨率 $N = 32, 64, 128$ 下的相对误差 $E$，计算公式为 $E = |k(h) - k_{\\infty}| / k_{\\infty}$，以十进制数（而非百分比）表示。\n\n最终输出格式规范：\n- 您的程序应生成一行输出，其中包含两个测试用例的汇总结果，形式为方括号内以逗号分隔的列表。\n- 条目的顺序必须是：$[k_{\\infty}^{(A)}, p^{(A)}, E_{32}^{(A)}, E_{64}^{(A)}, E_{128}^{(A)}, k_{\\infty}^{(B)}, p^{(B)}, E_{32}^{(B)}, E_{64}^{(B)}, E_{128}^{(B)}]$。\n- 所有输出必须是浮点数。\n\n您的解决方案必须可由任何使用现代编程语言的开发人员实现，并且必须依赖于以下基本原理，不得调用问题陈述中的任何捷径公式：\n- 达西定律，将渗透率定义为低雷诺数区域内平均流量与驱动力之间的比例常数。\n- 对于足够精细的网格，渐近截断误差模型为 $k(h) = k_{\\infty} + C \\, h^{p}$。",
            "solution": "该问题是有效的，因为它具有科学依据、提法明确且客观。它提出了一个来自计算流体动力学领域的标准数值验证任务，具体来说是使用格子玻尔兹曼方法（LBM）模拟的网格加密数据来确定精度阶并外推到连续介质极限。所有数据和条件都已提供，方法论基于已确立的数值分析原理。\n\n解决此问题的基本原理是将理查森外推应用于渐近误差展开。问题陈述指出，对于足够小的网格间距 $h$，数值计算的渗透率 $k(h)$ 通过以下模型与真实的连续介质极限渗透率 $k_{\\infty}$ 相关：\n$$k(h) = k_{\\infty} + C h^p$$\n其中 $p$ 是数值格式的精度阶，$C$ 是一个依赖于格式但不依赖于网格分辨率 $h$ 的常数。我们的目标是从一组三个测量值中确定未知参数 $p$ 和 $k_{\\infty}$，然后量化误差。\n\n我们给定了三个渗透率测量值 $k_1$、$k_2$ 和 $k_3$，分别对应于三个网格间距 $h_1 > h_2 > h_3$。网格以恒定的比率 $r$ 加密，使得 $h_2 = h_1/r$ 和 $h_3 = h_2/r = h_1/r^2$。在本问题中，分辨率以通道上节点数 $N_1=32$、$N_2=64$ 和 $N_3=128$ 的形式给出，通道高度为 $H=1$。网格间距定义为 $h=H/N = 1/N$。因此，$h_1 = 1/32$，$h_2 = 1/64$ 和 $h_3 = 1/128$，这给出了恒定的加密比 $r = h_1/h_2 = h_2/h_3 = 2$。\n\n根据误差模型，我们可以写出三元方程组：\n1. $k_1 = k(h_1) = k_{\\infty} + C h_1^p$\n2. $k_2 = k(h_2) = k_{\\infty} + C h_2^p = k_{\\infty} + C (h_1/r)^p$\n3. $k_3 = k(h_3) = k_{\\infty} + C h_3^p = k_{\\infty} + C (h_2/r)^p$\n\n为了求出精度阶 $p$，我们首先通过取连续方程之间的差来消除 $k_{\\infty}$：\n$$k_1 - k_2 = (k_{\\infty} + C h_1^p) - (k_{\\infty} + C (h_1/r)^p) = C h_1^p (1 - r^{-p})$$\n$$k_2 - k_3 = (k_{\\infty} + C (h_1/r)^p) - (k_{\\infty} + C (h_1/r^2)^p) = C (h_1/r)^p (1 - r^{-p})$$\n接下来，我们取这两个差的比值以消除常数 $C$ 和对 $h_1$ 的依赖：\n$$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{C h_1^p (1 - r^{-p})}{C (h_1/r)^p (1 - r^{-p})} = \\frac{h_1^p}{(h_1/r)^p} = r^p$$\n这为表观精度阶 $p$ 提供了一个直接的公式。通过对两边取对数，我们可以解出 $p$：\n$$p = \\frac{\\log\\left(\\frac{k_1 - k_2}{k_2 - k_3}\\right)}{\\log(r)}$$\n一旦确定了 $p$，我们就可以通过外推法找到 $k_{\\infty}$ 的一个改进估计。为了获得更高的精度，我们使用两个最精细的网格解，$k_2$ 和 $k_3$。这些解的误差为 $E_2 = k_2 - k_{\\infty} \\approx C h_2^p$ 和 $E_3 = k_3 - k_{\\infty} \\approx C h_3^p = C (h_2/r)^p = E_2 / r^p$。由此，我们有 $E_2 \\approx r^p E_3$，这导致：\n$$k_2 - k_{\\infty} \\approx r^p (k_3 - k_{\\infty})$$\n$$k_2 - k_{\\infty} \\approx r^p k_3 - r^p k_{\\infty}$$\n$$k_{\\infty} (r^p - 1) \\approx r^p k_3 - k_2$$\n解出 $k_{\\infty}$ 得到理查森外推公式：\n$$k_{\\infty} = \\frac{k_3 r^p - k_2}{r^p - 1}$$\n此公式提供了在连续介质极限（$h \\rightarrow 0$）下渗透率的外推值。\n\n最后，利用估计出的 $k_{\\infty}$，我们可以使用以下定义计算每个分辨率 $N \\in \\{32, 64, 128\\}$（对应渗透率 $k_1, k_2, k_3$）的相对误差 $E$：\n$$E_i = \\frac{|k_i - k_{\\infty}|}{k_{\\infty}}$$\n\n我们现在将此过程应用于提供的两个测试用例。加密比为 $r=2$。\n\n**测试用例1（方案A）：**\n- 给定实测渗透率：\n  - $k_1 = k(1/32) = 0.09895833333333333$\n  - $k_2 = k(1/64) = 0.09114583333333333$\n  - $k_3 = k(1/128) = 0.08723958333333333$\n- 首先，我们计算差值比：\n  $$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{0.09895833333333333 - 0.09114583333333333}{0.09114583333333333 - 0.08723958333333333} = \\frac{0.0078125}{0.00390625} = 2.0$$\n- 精度阶 $p^{(A)}$ 为：\n  $$p^{(A)} = \\frac{\\log(2.0)}{\\log(2)} = 1.0$$\n- 使用 $p=1$，我们外推求得 $k_{\\infty}^{(A)}$：\n  $$k_{\\infty}^{(A)} = \\frac{k_3 \\cdot 2^1 - k_2}{2^1 - 1} = 2 k_3 - k_2 = 2(0.08723958333333333) - 0.09114583333333333 = 0.08333333333333333$$\n  该值与理论上的连续介质极限渗透率 $H^2/12 = 1^2/12 \\approx 0.08333...$ 完全吻合。\n- 相对误差为：\n  - $E_{32}^{(A)} = |0.09895833333333333 - 1/12| / (1/12) = 0.015625 / (1/12) = 0.1875$\n  - $E_{64}^{(A)} = |0.09114583333333333 - 1/12| / (1/12) = 0.0078125 / (1/12) = 0.09375$\n  - $E_{128}^{(A)} = |0.08723958333333333 - 1/12| / (1/12) = 0.00390625 / (1/12) = 0.046875$\n\n**测试用例2（方案B）：**\n- 给定实测渗透率：\n  - $k_1 = k(1/32) = 0.08338216145833333$\n  - $k_2 = k(1/64) = 0.08334554036458333$\n  - $k_3 = k(1/128) = 0.08333638509114583$\n- 首先，我们计算差值比：\n  $$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{0.08338216145833333 - 0.08334554036458333}{0.08334554036458333 - 0.08333638509114583} = \\frac{3.6621... \\times 10^{-5}}{9.1552... \\times 10^{-6}} \\approx 4.0$$\n- 精度阶 $p^{(B)}$ 为：\n  $$p^{(B)} = \\frac{\\log(4.0)}{\\log(2)} = 2.0$$\n- 使用 $p=2$，我们外推求得 $k_{\\infty}^{(B)}$：\n  $$k_{\\infty}^{(B)} = \\frac{k_3 \\cdot 2^2 - k_2}{2^2 - 1} = \\frac{4k_3 - k_2}{3} = \\frac{4(0.08333638509114583) - 0.08334554036458333}{3} = \\frac{0.25}{3} = 0.08333333333333333$$\n  再次，外推值恰好为 $1/12$。\n- 相对误差为：\n  - $E_{32}^{(B)} = |0.08338216145833333 - 1/12| / (1/12) = 4.8828125 \\times 10^{-5} / (1/12) = 0.0005859375$\n  - $E_{64}^{(B)} = |0.08334554036458333 - 1/12| / (1/12) = 1.220703125 \\times 10^{-5} / (1/12) = 0.000146484375$\n  - $E_{128}^{(B)} = |0.08333638509114583 - 1/12| / (1/12) = 3.0517578125 \\times 10^{-6} / (1/12) = 0.00003662109375$\n\n程序实现将遵循此逻辑为每个方案计算所需的值，并将它们汇总成最终指定的输出格式。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the apparent order of accuracy (p), extrapolated continuum-limit\n    permeability (k_inf), and relative errors (E) for two different numerical\n    schemes based on a three-level grid refinement study.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each inner list contains measured permeabilities [k_coarse, k_medium, k_fine]\n    test_cases = [\n        # Test Case 1 (Scheme A)\n        [0.09895833333333333, 0.09114583333333333, 0.08723958333333333],\n        # Test Case 2 (Scheme B)\n        [0.08338216145833333, 0.08334554036458333, 0.08333638509114583]\n    ]\n\n    # Grid refinement ratio r = h_coarse/h_medium = h_medium/h_fine\n    r = 2.0\n\n    # List to store all results in the final required order.\n    aggregated_results = []\n\n    for case_data in test_cases:\n        k1, k2, k3 = case_data  # k1: coarse, k2: medium, k3: fine\n\n        # Step 1: Estimate the apparent order of accuracy 'p'\n        # The formula is derived from the ratio of differences in permeability:\n        # r^p = (k1 - k2) / (k2 - k3)\n        # p = log((k1 - k2) / (k2 - k3)) / log(r)\n        \n        diff1 = k1 - k2\n        diff2 = k2 - k3\n        \n        # In a well-behaved convergence study, diff2 should be > 0.\n        # If diff2 is zero or negative, the method is not applicable, but\n        # problem validation ensures the data is well-behaved.\n        if diff2 = 0:\n             # This case is not expected based on problem description but is a good practice.\n            raise ValueError(\"Permeability is not converging monotonically.\")\n\n        ratio_of_differences = diff1 / diff2\n        p = np.log(ratio_of_differences) / np.log(r)\n\n        # Step 2: Estimate the continuum-limit permeability 'k_inf'\n        # Richardson extrapolation formula using the two finest grid results:\n        # k_inf = (k3 * r^p - k2) / (r^p - 1)\n        \n        rp = r**p\n        k_inf = (k3 * rp - k2) / (rp - 1)\n\n        # Step 3: Compute the relative errors for each resolution\n        # E = |k(h) - k_inf| / k_inf\n        \n        e1 = abs(k1 - k_inf) / k_inf\n        e2 = abs(k2 - k_inf) / k_inf\n        e3 = abs(k3 - k_inf) / k_inf\n\n        # Append the results for the current test case to the aggregate list.\n        aggregated_results.extend([k_inf, p, e1, e2, e3])\n\n    # Final print statement in the exact required format.\n    # The format is a single-line comma-separated list of floating point numbers\n    # enclosed in square brackets.\n    output_str = \",\".join(map(str, aggregated_results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在验证了数值方法的准确性之后，最终的挑战是将我们的物理模型与真实的实验室测量结果进行对比和校准。本练习模拟了这一关键的验证步骤，要求您建立一个孔隙网络模型来模拟压汞实验（MICP），并将模拟的毛细管压力曲线与给定的实验数据进行比较。您需要通过系统地调整接触角 $\\theta$ 和考虑图像分辨率的限制，来最小化模拟与实验之间的均方根误差（RMSE），从而深入理解“墨水瓶效应”等物理现象并找出最佳的模型参数 。",
            "id": "4095981",
            "problem": "您的任务是通过计算，将模拟的压汞毛细管压力（MICP）曲线与从数字岩石物理中获得的实验数据进行比较，并通过系统地考虑接触角、图像分辨率和墨水瓶效应来调和观察到的差异。目标是实现一个孔隙尺度的侵入模型，并评估参数选择如何影响与实验测量值的一致性。\n\n基本原理：\n- Washburn 方程将毛细管压力与侵入多孔介质的非润湿性流体的喉道半径联系起来：$$P_c = -\\frac{2\\gamma \\cos \\theta}{r},$$ 其中 $P_c$ 是毛细管压力，$\\gamma$ 是界面张力，$\\theta$ 是接触角，$r$ 是喉道半径。对于汞（非润湿性）侵入，当 $\\theta > 90^\\circ$ 时，$P_c$ 为正，因为 $\\cos \\theta  0$ 且负号使得压力为正。\n- 侵入逾渗控制着孔隙体的连通性控制填充：通过在施加压力下满足毛细管阈值的喉道进入新的孔隙体，侵入从入口通过可及路径进行。墨水瓶效应是指大孔隙体只能通过更小的窄道进入的现象，这使得控制进入压力由沿路径的限制性喉道决定，而不是由孔隙体本身的大小决定。\n- 数字岩石物理中的图像分辨率设定了一个最小可分辨喉道半径，此处表示为 $r_{\\min}$，它会截断观察到的孔喉分布。半径 $r  r_{\\min}$ 的喉道在重建网络中缺失，从而改变了模拟的 MICP 响应。\n\n定义与假设：\n- 在实验室条件下，汞的界面张力取为 $\\gamma = 0.485 \\ \\mathrm{N/m}$。\n- 汞侵入从一组定义的入口孔隙开始；侵入饱和度计算为在施加压力下，通过满足进入阈值的喉道与入口相连的孔隙体积占总孔隙体积的比例。\n- 考虑两种建模模式：\n  1. 墨水瓶模式（考虑连通性）：侵入取决于是否存在一条从入口开始，穿过满足进入阈值的喉道的连通路径，即喉道必须满足 $P_c \\ge -2\\gamma \\cos \\theta / r$ 才被包含。在给定 $P_c$ 下的饱和度是侵入的连通孔隙体积与总孔隙体积之比。\n  2. 毛细管束模式（忽略连通性）：假设每个孔隙体仅基于其相邻喉道决定的局部进入阈值独立填充，忽略与入口的连通性。在给定 $P_c$ 下的饱和度是其局部阈值被满足的孔隙体的体积总和除以总孔隙体积。\n- 通过从网络中排除半径 $r  r_{\\min}$ 的喉道来施加分辨率截断。\n- 对于每种情况，模拟必须在提供的压力网格上计算饱和度曲线，并通过计算定义的均方根误差（RMSE）与提供的实验饱和度数据进行比较：$$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(S_{\\mathrm{sim}}(P_{c,i}) - S_{\\mathrm{exp}}(P_{c,i})\\right)^2},$$ 其中 $S_{\\mathrm{sim}}$ 是模拟饱和度，$S_{\\mathrm{exp}}$ 是实验饱和度，$N$ 是压力点数。\n\n程序要求：\n- 实现一个函数，该函数针对给定的网络、接触角、分辨率阈值 $r_{\\min}$、压力网格和模式选择，计算模拟的饱和度曲线以及相对于实验数据的 RMSE。\n- 对候选的接触角、分辨率阈值以及两种建模模式进行网格搜索，为每个测试案例选择使 RMSE 最小化的组合。\n- 使用以下候选接触角（单位：度）：$[110, 130, 140, 150, 160, 170]$ 和分辨率阈值（单位：米）：$[50\\times 10^{-9}, 100\\times 10^{-9}, 200\\times 10^{-9}]$。对于相等的 RMSE，平局打破规则必须优先选择墨水瓶模式，其次是更小的 $r_{\\min}$，最后是与 $140$ 度最接近的接触角。\n\n单位与最终报告：\n- 毛细管压力在模拟和报告中必须以 $\\mathrm{MPa}$ 为单位处理。Washburn 方程必须通过将帕斯卡（$\\mathrm{Pa}$）单位的压力除以 $10^6$ 来转换为 $\\mathrm{MPa}$。\n- 接触角必须以度为单位报告。\n- 分辨率阈值必须以纳米为单位报告为数值。\n- RMSE 必须报告为十进制数。\n\n测试套件：\n- 案例 $1$（理想情况；喉道尺寸混合且连通性中等）\n  - 孔隙体积（单位：$\\mathrm{m}^3$）：$[1.2\\times 10^{-18}, 0.9\\times 10^{-18}, 1.5\\times 10^{-18}, 1.1\\times 10^{-18}, 0.8\\times 10^{-18}, 1.3\\times 10^{-18}]$。\n  - 喉道：边以 $(i,j,r)$ 形式给出，其中 $r$ 的单位为米：\n    - $(0,1, 0.8\\times 10^{-6})$, $(1,2, 0.2\\times 10^{-6})$, $(2,3, 0.6\\times 10^{-6})$, $(3,4, 0.15\\times 10^{-6})$, $(4,5, 0.5\\times 10^{-6})$, $(0,5, 1.2\\times 10^{-6})$, $(1,4, 0.3\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位：$\\mathrm{MPa}$）：$[0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 16.0]$。\n  - 实验饱和度：$[0.15, 0.25, 0.40, 0.60, 0.80, 0.90, 1.00]$。\n- 案例 $2$（接触角敏感性；喉道较大且侵入较快）\n  - 孔隙体积（单位：$\\mathrm{m}^3$）：$[1.0\\times 10^{-18}, 0.7\\times 10^{-18}, 1.6\\times 10^{-18}, 1.1\\times 10^{-18}, 1.4\\times 10^{-18}]$。\n  - 喉道：\n    - $(0,1, 1.5\\times 10^{-6})$, $(1,2, 0.9\\times 10^{-6})$, $(2,3, 0.4\\times 10^{-6})$, $(3,4, 0.3\\times 10^{-6})$, $(0,4, 1.0\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位：$\\mathrm{MPa}$）：$[0.3, 0.6, 1.2, 2.4, 4.8, 9.6, 14.4]$。\n  - 实验饱和度：$[0.20, 0.35, 0.55, 0.75, 0.90, 0.95, 1.00]$。\n- 案例 $3$（受分辨率限制，墨水瓶效应主导；存在许多小喉道）\n  - 孔隙体积（单位：$\\mathrm{m}^3$）：$[0.8\\times 10^{-18}, 0.6\\times 10^{-18}, 0.9\\times 10^{-18}, 1.2\\times 10^{-18}, 1.1\\times 10^{-18}, 0.7\\times 10^{-18}, 1.0\\times 10^{-18}]$。\n  - 喉道：\n    - $(0,1, 0.12\\times 10^{-6})$, $(1,2, 0.08\\times 10^{-6})$, $(2,3, 0.10\\times 10^{-6})$, $(3,4, 0.20\\times 10^{-6})$, $(4,5, 0.15\\times 10^{-6})$, $(5,6, 0.18\\times 10^{-6})$, $(0,6, 0.30\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位：$\\mathrm{MPa}$）：$[1.0, 2.0, 4.0, 8.0, 12.0, 16.0, 20.0]$。\n  - 实验饱和度：$[0.05, 0.10, 0.20, 0.35, 0.55, 0.80, 1.00]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试案例的结果必须是一个包含四个元素的列表：最佳接触角（单位：度）、最佳分辨率阈值（单位：纳米）、所选模式标志（墨水瓶模式用 $1$，毛细管束模式用 $0$）以及找到的最小 RMSE。例如，输出应如下所示：$$[[\\theta_1,r_{\\min,1},m_1,\\mathrm{RMSE}_1],[\\theta_2,r_{\\min,2},m_2,\\mathrm{RMSE}_2],[\\theta_3,r_{\\min,3},m_3,\\mathrm{RMSE}_3]].$$",
            "solution": "用户提供了一个数字岩石物理领域的计算问题，该领域是计算地球化学的一个子领域。任务是通过对流体侵入孔隙网络进行建模，来比较模拟的压汞毛细管压力（MICP）曲线与实验数据。目标是找到一组最优的模型参数（接触角 $\\theta$、图像分辨率截止值 $r_{\\min}$ 和侵入模型类型），以最小化模拟与实验之间的差异，该差异通过均方根误差（RMSE）来量化。\n\n### **1. 问题验证**\n\n首先，我将根据所需标准验证问题陈述。\n\n*   **已知条件提取**：\n    *   **方程**：Washburn 方程，$P_c = -\\frac{2\\gamma \\cos \\theta}{r}$。\n    *   **常数**：汞的界面张力，$\\gamma = 0.485 \\ \\mathrm{N/m}$。\n    *   **模型**：1. 墨水瓶模式（考虑连通性的侵入逾渗）。2. 毛细管束模式（忽略连通性）。\n    *   **误差度量**：RMSE，$\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(S_{\\mathrm{sim}}(P_{c,i}) - S_{\\mathrm{exp}}(P_{c,i}))^2}$。\n    *   **网格搜索的参数空间**：\n        *   接触角 $\\theta \\in [110, 130, 140, 150, 160, 170]$ 度。\n        *   分辨率阈值 $r_{\\min} \\in [50\\times 10^{-9}, 100\\times 10^{-9}, 200\\times 10^{-9}]$ 米。\n    *   **平局打破规则**：对于相等的 RMSE，优先选择 (1) 墨水瓶模式，然后 (2) 更小的 $r_{\\min}$，最后 (3) 与 $140^\\circ$ 最接近的 $\\theta$。\n    *   **数据**：提供了三个测试案例，每个案例都包含一个孔隙网络（孔隙体积、带半径的喉道连接）、入口孔隙、用于模拟的压力网格以及相应的实验饱和度数据。\n    *   **单位**：所有单位和要求的输出格式都已明确定义。\n\n*   **验证结论**：\n    *   **科学依据**：该问题基于多孔介质中流体力学的基本原理（Washburn 方程）和标准的孔隙尺度建模技术（侵入逾渗、墨水瓶效应）。这些概念是数字岩石物理领域的核心。物理常数和参数范围是现实的。\n    *   **适定性**：问题定义清晰。它指定了输入数据、要实现的模型、要最小化的目标函数（RMSE）以及明确的平局打破规则。这确保了可以找到一个唯一且稳定的解。\n    *   **客观性**：语言精确且量化，没有主观或模糊的术语。\n    *   **完整性**：提供了构建和运行模拟所需的所有必要数据和定义。问题是自包含的。\n\n该问题被判定为 **有效**。这是一个结构良好且科学上合理的计算任务。\n\n### **2. 求解方法**\n\n解决方案需要在指定的参数空间内进行系统的网格搜索。对于每个参数组合（$\\theta$、$r_{\\min}$、模型类型），我们将执行一次 MICP 模拟，并计算其与实验数据的 RMSE。在遵循平局打破规则的前提下，产生最小 RMSE 的组合将作为该测试案例的结果。\n\n解决方案的核心是 MICP 模拟函数。该函数将网络结构和一组参数作为输入，并生成一条饱和度曲线。总体算法如下：\n\n1.  **遍历测试案例**：主循环将处理提供的三个测试案例中的每一个。\n\n2.  **网格搜索**：对于每个测试案例，嵌套循环将遍历：\n    *   两种建模模式（`ink-bottle` 和 `bundle-of-tubes`）。\n    *   每个候选的分辨率阈值 $r_{\\min}$。\n    *   每个候选的接触角 $\\theta$。\n\n3.  **每个参数集的预计算**：\n    *   首先过滤网络的喉道列表，排除任何半径 $r  r_{\\min}$ 的喉道。\n    *   对于每个剩余的喉道，使用当前的接触角 $\\theta$ 通过 Washburn 方程计算其毛细管进入压力 $P_{c, \\text{entry}}$。角度必须从度转换为弧度以用于三角函数。以帕斯卡（$\\mathrm{N/m^2}$）为单位的结果压力通过除以 $10^6$ 转换为兆帕斯卡（$\\mathrm{MPa}$）。\n    *   通过对所有单个孔隙体积求和来计算网络的总孔隙体积 $V_{\\text{total}}$。\n\n4.  **MICP 模拟循环**：对于提供的压力网格中的每个压力点 $P_c$，根据所选的建模模式确定被侵入的孔隙集合。\n    *   **墨水瓶模式（考虑连通性）**：此模式模拟侵入逾渗。在给定压力 $P_c$下，如果喉道的进入压力 $P_{c, \\text{entry}} \\le P_c$，则该喉道被视为“开放”。侵入从指定的 `inlet_pores` 开始。使用图遍历算法（如广度优先搜索，BFS）来查找所有可以从入口孔隙通过连续的开放喉道路径到达的孔隙。所有访问过的孔隙集合构成了侵入簇。\n    *   **毛细管束模式（忽略连通性）**：该模型通过忽略到入口的连通路径要求来简化物理过程。如果一个孔隙的*任何*一个相连喉道在当前压力 $P_c$ 下是开放的，则该孔隙被视为已侵入。算法遍历网络中的每个孔隙，并检查其相邻喉道的进入压力。\n\n5.  **饱和度计算**：在确定给定 $P_c$ 的侵入孔隙集合后，通过对这些孔隙的体积求和来计算侵入体积 $V_{\\text{invaded}}$。然后饱和度为 $S(P_c) = V_{\\text{invaded}} / V_{\\text{total}}$。对所有压力点重复此过程以生成模拟的饱和度曲线 $S_{\\text{sim}}$。\n\n6.  **RMSE 与参数选择**：\n    *   计算模拟曲线 $S_{\\text{sim}}$ 与实验曲线 $S_{\\text{exp}}$ 之间的 RMSE。\n    *   为了管理选择过程和平局打破规则，为每个参数集创建一个排序键：`(RMSE, -mode_flag, r_min, abs(theta - 140))`。`mode_flag` 对于墨水瓶模式为 $1$，对于毛细管束模式为 $0$；对其取反可确保在最小化上下文中优先选择墨水瓶模式。此复合键按字典序进行比较。与最小键对应的参数集被存储为当前最佳。\n\n7.  **最终输出**：在完成一个测试案例的网格搜索后，存储找到的最佳参数（接触角，单位为度；分辨率，单位为纳米；模式标志）和相应的最小 RMSE。对所有测试案例重复此过程。最终输出格式化为列表的列表，如问题陈述中所指定。\n\n这种详细、基于原理的方法确保了模型能正确表示预期的物理过程，并且参数优化严格按照问题的约束条件执行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pore-scale modeling problem by performing a grid search to find the\n    best-fit parameters for three different digital rock test cases.\n    \"\"\"\n    \n    GAMMA = 0.485  # Interfacial tension for mercury in N/m\n\n    test_cases = [\n        {\n            \"pore_volumes\": np.array([1.2e-18, 0.9e-18, 1.5e-18, 1.1e-18, 0.8e-18, 1.3e-18]),\n            \"throats\": [\n                (0, 1, 0.8e-6), (1, 2, 0.2e-6), (2, 3, 0.6e-6), (3, 4, 0.15e-6),\n                (4, 5, 0.5e-6), (0, 5, 1.2e-6), (1, 4, 0.3e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 16.0]),\n            \"S_exp\": np.array([0.15, 0.25, 0.40, 0.60, 0.80, 0.90, 1.00]),\n        },\n        {\n            \"pore_volumes\": np.array([1.0e-18, 0.7e-18, 1.6e-18, 1.1e-18, 1.4e-18]),\n            \"throats\": [\n                (0, 1, 1.5e-6), (1, 2, 0.9e-6), (2, 3, 0.4e-6), (3, 4, 0.3e-6), (0, 4, 1.0e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([0.3, 0.6, 1.2, 2.4, 4.8, 9.6, 14.4]),\n            \"S_exp\": np.array([0.20, 0.35, 0.55, 0.75, 0.90, 0.95, 1.00]),\n        },\n        {\n            \"pore_volumes\": np.array([0.8e-18, 0.6e-18, 0.9e-18, 1.2e-18, 1.1e-18, 0.7e-18, 1.0e-18]),\n            \"throats\": [\n                (0, 1, 0.12e-6), (1, 2, 0.08e-6), (2, 3, 0.10e-6), (3, 4, 0.20e-6),\n                (4, 5, 0.15e-6), (5, 6, 0.18e-6), (0, 6, 0.30e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([1.0, 2.0, 4.0, 8.0, 12.0, 16.0, 20.0]),\n            \"S_exp\": np.array([0.05, 0.10, 0.20, 0.35, 0.55, 0.80, 1.00]),\n        }\n    ]\n\n    candidate_thetas = [110, 130, 140, 150, 160, 170]\n    candidate_r_mins = [50e-9, 100e-9, 200e-9]\n    modes = [(\"ink-bottle\", 1), (\"bundle-of-tubes\", 0)]\n\n    all_results = []\n\n    for case in test_cases:\n        pore_volumes = case[\"pore_volumes\"]\n        throats = case[\"throats\"]\n        inlet_pores = case[\"inlet_pores\"]\n        P_c_grid = case[\"P_c_grid\"]\n        S_exp = case[\"S_exp\"]\n\n        num_pores = len(pore_volumes)\n        total_pore_volume = np.sum(pore_volumes)\n\n        best_params = {}\n        best_key = (float('inf'),)\n\n        for mode_name, mode_flag in modes:\n            for r_min in candidate_r_mins:\n                for theta_deg in candidate_thetas:\n                    \n                    current_throats = [t for t in throats if t[2] >= r_min]\n                    \n                    adj_with_pc = {i: [] for i in range(num_pores)}\n                    theta_rad = np.deg2rad(theta_deg)\n                    washburn_const = -2 * GAMMA * np.cos(theta_rad) / 1e6 # Constant for P_c in MPa\n                    for p1, p2, r in current_throats:\n                        pc_entry_mpa = washburn_const / r\n                        adj_with_pc[p1].append((p2, pc_entry_mpa))\n                        adj_with_pc[p2].append((p1, pc_entry_mpa))\n\n                    S_sim = []\n                    for pc_step in P_c_grid:\n                        invaded_pores = set()\n                        if mode_name == \"ink-bottle\":\n                            queue = list(inlet_pores)\n                            visited = set(inlet_pores)\n                            # Use an index-based queue for efficiency\n                            head = 0\n                            while head  len(queue):\n                                u = queue[head]\n                                head += 1\n                                for v, pc_entry in adj_with_pc[u]:\n                                    if pc_entry = pc_step and v not in visited:\n                                        visited.add(v)\n                                        queue.append(v)\n                            invaded_pores = visited\n                        else:  # bundle-of-tubes\n                            for i in range(num_pores):\n                                for _, pc_entry in adj_with_pc[i]:\n                                    if pc_entry = pc_step:\n                                        invaded_pores.add(i)\n                                        break\n                        \n                        invaded_volume = np.sum(pore_volumes[list(invaded_pores)]) if invaded_pores else 0.0\n                        saturation = invaded_volume / total_pore_volume if total_pore_volume > 0 else 0\n                        S_sim.append(saturation)\n\n                    S_sim_np = np.array(S_sim)\n                    rmse = np.sqrt(np.mean((S_sim_np - S_exp)**2))\n                    \n                    # Tie-breaking key: (rmse, -mode, r_min, |theta-140|)\n                    current_key = (rmse, -mode_flag, r_min, abs(theta_deg - 140))\n                    \n                    if current_key  best_key:\n                        best_key = current_key\n                        best_params = {\n                            \"theta\": theta_deg,\n                            \"r_min_nm\": r_min * 1e9,\n                            \"mode\": mode_flag,\n                            \"rmse\": rmse\n                        }\n        \n        all_results.append([\n            best_params[\"theta\"],\n            best_params[\"r_min_nm\"],\n            best_params[\"mode\"],\n            best_params[\"rmse\"]\n        ])\n\n    result_str = \",\".join([f\"[{int(r[0])},{int(r[1])},{r[2]},{r[3]:.6f}]\" for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}