{
    "hands_on_practices": [
        {
            "introduction": "从微CT扫描等成像技术获得的原始数字岩石模型通常包含噪声和伪影。在进行任何流体流动模拟之前，必须对这些三维图像进行处理，以确保几何结构的准确性。本实践将指导您应用数学形态学中的开运算和闭运算等基本图像滤波技术，并量化这些操作对孔隙-岩石界面面积这一关键几何参数的影响，这是孔隙尺度建模工作流程中的关键第一步。",
            "id": "4095925",
            "problem": "给定一个三维二值图像，它表示在孔隙尺度下的数字岩石物理学分割结果，该分割结果建立在立方晶格上，体素边长 $\\Delta$ 以米为单位。二值场为 $X:\\mathbb{Z}^3\\to\\{0,1\\}$，其中 $X(\\mathbf{i})=1$ 表示孔隙体素，$X(\\mathbf{i})=0$ 表示岩石体素。考虑在离散晶格中的集合上定义的数学形态学操作。设 $B\\subset \\mathbb{Z}^3$ 是一个以原点为中心、半径为 $r$ 体素的球形结构元素，并令 $X$ 表示孔隙集。腐蚀操作 $X\\ominus B$ 会移除无法完全容纳 $B$ 的孔隙体素，而膨胀操作 $X\\oplus B$ 会添加通过平移 $B$ 可以到达的孔隙体素。形态学开运算为 $(X\\ominus B)\\oplus B$，形态学闭运算为 $(X\\oplus B)\\ominus B$。对 $X$ 进行这些操作可以抑制椒盐噪声伪影并平滑相间的锯齿状界面。在离散晶格中，孔隙相和岩石相之间的界面表面积可以通过计算界面上的体素面来求得。从离散晶格的描述出发，并根据每个界面面的面积等于 $\\Delta^2$（一个体素面的面积）的定义，通过沿立方晶格主轴方向统计界面面并汇总其面积贡献（无重复计数），推导出一个基于体素的孔隙-岩石界面总表面积 $S(X,\\Delta)$ 的估计量。使用该估计量来量化形态学开运算和形态学闭运算如何改变界面面积。\n\n您的任务是使用半径为 $r$ 体素的球形结构元素 $B$ 对孔隙集 $X$ 实现形态学开运算和闭运算，并计算每次操作前后的 $S(X,\\Delta)$。然后计算变化量 $\\Delta S_{\\mathrm{open}}=S(X_{\\mathrm{open}},\\Delta)-S(X,\\Delta)$ 和 $\\Delta S_{\\mathrm{close}}=S(X_{\\mathrm{close}},\\Delta)-S(X,\\Delta)$，其中 $X_{\\mathrm{open}}$ 和 $X_{\\mathrm{close}}$ 分别是应用于 $X$ 的开运算和闭运算的结果。所有表面积必须以 $\\mathrm{m}^2$ 为单位表示。\n\n实现一个程序，构建以下科学真实的合成测试套件和参数：\n\n- 情况 A（包含球形孔隙和散斑噪声的一般情况）：\n    - 体积大小：$N=(64,64,64)$ 体素。\n    - 体素大小：$\\Delta=2\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：一个半径为 $15$ 体素的球形孔隙，中心位于 $(32,32,32)$。\n    - 散斑伪影：在整个体积中，随机翻转比例为 $p=5\\times 10^{-3}$ 的体素的状态（影响两相的椒盐噪声）。\n    - 结构元素：半径为 $r=2$ 体素的球形 $B$。\n    - 用于可复现性的随机种子：$42$。\n\n- 情况 B（无噪声的平面界面边界条件）：\n    - 体积大小：$N=(64,64,64)$ 体素。\n    - 体素大小：$\\Delta=2\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：一个平面半空间孔隙，其中如果 $i_x  32$，则 $X(i_x,i_y,i_z)=1$，否则 $X(i_x,i_y,i_z)=0$。\n    - 散斑伪影：无，$p=0$。\n    - 结构元素：半径为 $r=2$ 体素的球形 $B$。\n\n- 情况 C（包含接近形态学阈值的微小孔隙和噪声的边缘情况）：\n    - 体积大小：$N=(32,32,32)$ 体素。\n    - 体素大小：$\\Delta=1\\times 10^{-6}\\ \\mathrm{m}$。\n    - 孔隙几何形状：在原本为岩石基质中，有三个半径为 $1$ 体素的微小球形孔隙，中心分别位于 $(8,8,8)$、$(16,20,12)$ 和 $(24,10,24)$。\n    - 散斑伪影：随机翻转比例为 $p=10^{-2}$ 的体素的状态。\n    - 结构元素：半径为 $r=2$ 体素的球形 $B$。\n    - 用于可复现性的随机种子：$7$。\n\n对于每种情况，计算列表 $[S(X,\\Delta), S(X_{\\mathrm{open}},\\Delta), S(X_{\\mathrm{close}},\\Delta), \\Delta S_{\\mathrm{open}}, \\Delta S_{\\mathrm{close}}]$。所有表面积均以 $\\mathrm{m}^2$ 为单位，表示为浮点数。您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表，该列表按顺序汇总了情况 A、B 和 C 的结果，形式为列表的列表，例如 $[[\\dots],[\\dots],[\\dots]]$。",
            "solution": "用户提供的问题是有效的。它在科学上基于数学形态学和计算物理学的原理，特别是在数字岩石物理学领域内。该问题定义明确，提供了所有必要的参数，包括体积维度、体素分辨率、几何定义、结构元素规格以及用于可复现性的随机种子。问题陈述是客观的，使用了精确、正式的语言。它没有表现出验证标准中列出的任何缺陷，例如事实不健全、模糊不清或定义不当。因此，将提供一个合理的解决方案。\n\n该问题的核心在于实现和量化两种基本的形态学操作——开运算和闭运算——对多孔介质的离散三维二值表示的影响。这些操作用于过滤噪声和规整化界面，这反过来又会影响界面表面积等几何属性。\n\n首先，我们必须在离散立方晶格的背景下形式化这些定义。设二值图像由函数 $X(\\mathbf{i}): \\mathbb{Z}^3 \\to \\{0, 1\\}$ 表示，其中 $\\mathbf{i}=(i_x, i_y, i_z)$ 是一个体素索引。$X(\\mathbf{i})=1$ 表示孔隙相，$X(\\mathbf{i})=0$ 表示固体（岩石）相。所有孔隙体素的集合是 $P = \\{\\mathbf{i} \\in \\mathbb{Z}^3 \\mid X(\\mathbf{i}) = 1\\}$。\n\n结构元素 $B$ 是相对于原点的一组体素偏移，也定义在 $\\mathbb{Z}^3$ 上。问题指定了一个半径为 $r$ 体素的球形结构元素，它是所有与原点的欧几里得距离小于或等于 $r$ 的整数格点的集合：\n$$ B = \\{ \\mathbf{b} \\in \\mathbb{Z}^3 \\mid \\|\\mathbf{b}\\|_2 \\le r \\} = \\{ (b_x, b_y, b_z) \\in \\mathbb{Z}^3 \\mid \\sqrt{b_x^2 + b_y^2 + b_z^2} \\le r \\} $$\n\n孔隙集 $P$ 被结构元素 $B$ 腐蚀和膨胀的基本形态学操作定义如下：\n- **腐蚀**：$P \\ominus B = \\{ \\mathbf{p} \\in \\mathbb{Z}^3 \\mid B_{\\mathbf{p}} \\subseteq P \\}$，其中 $B_{\\mathbf{p}} = \\{ \\mathbf{p} + \\mathbf{b} \\mid \\mathbf{b} \\in B \\}$ 是 $B$ 到点 $\\mathbf{p}$ 的平移。腐蚀有效地收缩了孔隙空间，移除了任何无法使结构元素完全包含在原始孔隙空间内的孔隙体素。\n- **膨胀**：$P \\oplus B = \\bigcup_{\\mathbf{p} \\in P} B_{\\mathbf{p}}$。膨胀扩展了孔隙空间。如果以某个体素为中心的结构元素与原始孔隙空间重叠，则该体素被包含在膨胀后的集合中。对于像球体这样的对称结构元素，这等价于 $\\{ \\mathbf{q} \\in \\mathbb{Z}^3 \\mid B_{\\mathbf{q}} \\cap P \\neq \\emptyset \\}$。\n\n基于这些，开运算和闭运算被定义为复合操作：\n- **开运算**：$P_{\\mathrm{open}} = (P \\ominus B) \\oplus B$。开运算平滑孔隙空间的轮廓，断开狭窄的连接（isthmuses），并消除比结构元素小的孤立孔隙区域（islands）。\n- **闭运算**：$P_{\\mathrm{close}} = (P \\oplus B) \\ominus B$。闭运算也平滑轮廓，但它是通过填充孔隙空间中比结构元素小的狭窄间隙和小孔来实现的。\n\n接下来，我们讨论界面表面积 $S(X, \\Delta)$ 的估算。在一个立方晶格上，每个体素的边长为 $\\Delta$，体素面的面积为 $\\Delta^2$。总界面面积是所有孔隙体素和岩石体素之间共享面的面积之和。一种可靠的无重复计数这些面的方法是遍历所有体素，并对每个体素检查其在正轴方向上的邻居。如果体素 $\\mathbf{i}$ 和其邻居 $\\mathbf{i}+\\mathbf{e}_k$（其中 $\\mathbf{e}_k$ 是沿轴 $k \\in \\{x,y,z\\}$ 的单位向量）的相值不同，即 $X(\\mathbf{i}) \\neq X(\\mathbf{i}+\\mathbf{e}_k)$，则它们之间存在一个界面。这类界面面的总数 $N_{\\text{faces}}$ 为：\n$$ N_{\\text{faces}}(X) = \\sum_{i_x, i_y, i_z} \\left( \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x+1, i_y, i_z)] + \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x, i_y+1, i_z)] + \\mathbb{I}[X(i_x, i_y, i_z) \\neq X(i_x, i_y, i_z+1)] \\right) $$\n其中 $\\mathbb{I}[\\cdot]$ 是指示函数，求和在所有使配对有效的索引上进行。总表面积则为：\n$$ S(X, \\Delta) = N_{\\text{faces}}(X) \\cdot \\Delta^2 $$\n\n实现将首先为每个指定的测试用例构建二值体。形态学操作计算量大，最好使用优化的库函数，例如 `scipy.ndimage` 中提供的函数。`scipy.ndimage.binary_opening` 和 `scipy.ndimage.binary_closing` 函数使用提供的结构元素直接实现所需的操作。表面积将使用离散求和公式计算，这可以通过比较体积数组的移位版本，使用 `numpy` 数组操作来高效实现。\n\n最后，对于每种情况，我们将计算初始表面积 $S(X, \\Delta)$、开运算后的面积 $S(X_{\\mathrm{open}}, \\Delta)$ 和闭运算后的面积 $S(X_{\\mathrm{close}}, \\Delta)$。表面积的变化量为 $\\Delta S_{\\mathrm{open}} = S(X_{\\mathrm{open}}, \\Delta) - S(X, \\Delta)$ 和 $\\Delta S_{\\mathrm{close}} = S(X_{\\mathrm{close}}, \\Delta) - S(X, \\Delta)$。开运算和闭运算都是平滑操作，通常会减少高频空间变化，例如噪声和尖角，因此通常会导致总界面表面积减小（即 $\\Delta S \\le 0$）。\n\n每个测试用例的流程如下：\n1.  定义参数：体积大小 $N$、体素大小 $\\Delta$、结构元素半径 $r$ 和噪声参数。\n2.  根据几何规定生成初始三维二值体 $X$，如果指定，则添加噪声，并使用给定的随机种子以保证可复现性。\n3.  生成半径为 $r$ 的球形结构元素 $B$。\n4.  计算初始表面积 $S_0 = S(X, \\Delta)$。\n5.  对 $X$ 应用形态学开运算，使用 $B$ 得到 $X_{\\mathrm{open}}$。计算新表面积 $S_{\\mathrm{open}} = S(X_{\\mathrm{open}}, \\Delta)$。\n6.  对 $X$ 应用形态学闭运算，使用 $B$ 得到 $X_{\\mathrm{close}}$。计算新表面积 $S_{\\mathrm{close}} = S(X_{\\mathrm{close}}, \\Delta)$。\n7.  计算差值 $\\Delta S_{\\mathrm{open}} = S_{\\mathrm{open}} - S_0$ 和 $\\Delta S_{\\mathrm{close}} = S_{\\mathrm{close}} - S_0$。\n8.  汇总五个计算值 $[S_0, S_{\\mathrm{open}}, S_{\\mathrm{close}}, \\Delta S_{\\mathrm{open}}, \\Delta S_{\\mathrm{close}}]$。\n最终输出将是一个包含所有三个测试用例汇总结果的列表。",
            "answer": "```python\nimport numpy as np\nfrom scipy import ndimage\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the specified test cases.\n    \"\"\"\n\n    def generate_sphere_strele(radius: int) - np.ndarray:\n        \"\"\"\n        Generates a 3D spherical structuring element.\n        \n        Args:\n            radius: The radius of the sphere in voxels.\n\n        Returns:\n            A boolean numpy array representing the spherical structuring element.\n        \"\"\"\n        diameter = 2 * radius + 1\n        x, y, z = np.mgrid[-radius:radius+1, -radius:radius+1, -radius:radius+1]\n        dist_sq = x**2 + y**2 + z**2\n        return dist_sq = radius**2\n\n    def calculate_surface_area(volume: np.ndarray, delta: float) - float:\n        \"\"\"\n        Calculates the interfacial surface area of a 3D binary volume.\n\n        Args:\n            volume: A 3D numpy array with 0s and 1s.\n            delta: The edge length of a single voxel in meters.\n\n        Returns:\n            The total interfacial surface area in square meters.\n        \"\"\"\n        if volume.ndim != 3:\n            raise ValueError(\"Input volume must be a 3D array.\")\n        \n        # Count interfaces along each axis by comparing neighboring voxels\n        # An interface exists if adjacent voxels have different values (0 vs 1)\n        faces_x = np.sum(volume[:-1, :, :] != volume[1:, :, :])\n        faces_y = np.sum(volume[:, :-1, :] != volume[:, 1:, :])\n        faces_z = np.sum(volume[:, :, :-1] != volume[:, :, 1:])\n        \n        total_faces = faces_x + faces_y + faces_z\n        return total_faces * (delta ** 2)\n\n    def generate_noisy_volume(base_volume: np.ndarray, noise_fraction: float, seed: int) - np.ndarray:\n        \"\"\"Applies salt-and-pepper noise to a binary volume.\"\"\"\n        if noise_fraction == 0:\n            return base_volume.copy()\n            \n        rng = np.random.default_rng(seed)\n        noisy_volume = base_volume.copy()\n        total_voxels = noisy_volume.size\n        num_flips = int(noise_fraction * total_voxels)\n        \n        # Generate unique indices to flip\n        indices_to_flip = rng.choice(total_voxels, size=num_flips, replace=False)\n        flat_volume = noisy_volume.flatten()\n        flat_volume[indices_to_flip] = 1 - flat_volume[indices_to_flip]\n        \n        return flat_volume.reshape(base_volume.shape)\n\n    def process_case(params: dict):\n        \"\"\"Processes a single test case.\"\"\"\n        N = params['N']\n        delta = params['delta']\n        r = params['r']\n        noise_p = params['p']\n        seed = params['seed']\n\n        # Generate base geometry\n        if params['case_id'] == 'A':\n            center = np.array(params['pore_center'])\n            radius = params['pore_radius']\n            coords = np.mgrid[0:N[0], 0:N[1], 0:N[2]]\n            dist_sq = np.sum((coords - center[:, np.newaxis, np.newaxis, np.newaxis])**2, axis=0)\n            initial_volume = (dist_sq = radius**2).astype(np.int8)\n        elif params['case_id'] == 'B':\n            initial_volume = np.zeros(N, dtype=np.int8)\n            initial_volume[:32, :, :] = 1\n        elif params['case_id'] == 'C':\n            initial_volume = np.zeros(N, dtype=np.int8)\n            coords = np.mgrid[0:N[0], 0:N[1], 0:N[2]]\n            for center_info in params['pore_info']:\n                center, radius = np.array(center_info[0]), center_info[1]\n                dist_sq = np.sum((coords - center[:, np.newaxis, np.newaxis, np.newaxis])**2, axis=0)\n                initial_volume[dist_sq = radius**2] = 1\n        else:\n            raise ValueError(f\"Unknown case_id: {params['case_id']}\")\n\n        # Add noise\n        X = generate_noisy_volume(initial_volume, noise_p, seed)\n        \n        # Generate structuring element\n        B = generate_sphere_strele(r)\n\n        # Calculate initial surface area\n        S_initial = calculate_surface_area(X, delta)\n\n        # Morphological opening\n        X_open = ndimage.binary_opening(X, structure=B).astype(X.dtype)\n        S_open = calculate_surface_area(X_open, delta)\n        dS_open = S_open - S_initial\n\n        # Morphological closing\n        X_close = ndimage.binary_closing(X, structure=B).astype(X.dtype)\n        S_close = calculate_surface_area(X_close, delta)\n        dS_close = S_close - S_initial\n\n        return [S_initial, S_open, S_close, dS_open, dS_close]\n\n    test_cases = [\n        {\n            'case_id': 'A',\n            'N': (64, 64, 64), 'delta': 2e-6,\n            'pore_radius': 15, 'pore_center': (32, 32, 32),\n            'p': 5e-3, 'r': 2, 'seed': 42\n        },\n        {\n            'case_id': 'B',\n            'N': (64, 64, 64), 'delta': 2e-6,\n            'p': 0.0, 'r': 2, 'seed': None\n        },\n        {\n            'case_id': 'C',\n            'N': (32, 32, 32), 'delta': 1e-6,\n            'pore_info': [\n                ((8, 8, 8), 1),\n                ((16, 20, 12), 1),\n                ((24, 10, 24), 1)\n            ],\n            'p': 1e-2, 'r': 2, 'seed': 7\n        }\n    ]\n\n    results = []\n    for case_params in test_cases:\n        result_list = process_case(case_params)\n        results.append(result_list)\n    \n    # Format output as a list of lists string\n    # e.g., [[val1, val2], [val3, val4]]\n    # str() on a list produces the correct string representation\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n    print(final_output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "在获得一个干净的数字岩石几何模型后，下一步通常是模拟流体流过孔隙网络以计算其宏观输运性质，例如渗透率$k$。然而，任何基于离散网格的数值方法（如格子玻尔兹曼方法）的计算结果都包含与网格分辨率相关的数值误差。本实践将引导您完成一次网格加密研究，这是一种用于评估和验证计算模型的标准技术，您将通过它来估计数值方案的精度阶数$p$并推断出连续介质极限下的渗透率$k_{\\infty}$。",
            "id": "4096000",
            "problem": "考虑一个在数字岩石物理（DRP）和格子玻尔兹曼方法（LBM）框架下的计算地球化学中的二维孔隙尺度流动问题。一个在规则格子上离散化的高度为 $H$ 的直通道被用作代表性的“数字岩石”来估算渗透率，并通过改变壁面边界格式来研究其对分辨率相关误差的影响。平面泊肃叶流的连续介质极限渗透率由达西定律定义为本构关系：对于高度为 $H$ 的通道，在无量纲格子单位下，连续介质极限渗透率为 $k_{\\infty} = H^2 / 12$，这是平行板间粘性层流中一个公认的事实。在带有无滑移壁面的LBM数值离散化中，由于存在取决于网格间距 $h$ 和壁面边界格式的截断误差，计算出的渗透率 $k(h)$ 会偏离连续介质极限渗透率 $k_{\\infty}$。我们采用标准的数值分析模型，即在网格细化的渐近区域（$h \\rightarrow 0$），主阶误差表现为 $k(h) = k_{\\infty} + C \\, h^{p}$，其中 $C$ 是一个与格式相关的常数，而 $p$ 是该壁面边界格式在给定几何形状下的精度阶数。目标是通过网格细化研究来估算 $p$ 和 $k_{\\infty}$，然后量化每个分辨率下的相对渗透率误差。\n\n你的任务是编写一个完整的程序，该程序在给定来自LBM的、具有恒定细化比的三个连续网格细化以及两种不同壁面边界格式的渗透率测量值的情况下，将执行以下操作：\n\n- 通过网格细化和使用渐近误差模型 $k(h) = k_{\\infty} + C \\, h^{p}$ 外推到连续介质极限，来估算表观精度阶数 $p$ 和连续介质极限渗透率 $k_{\\infty}$。\n- 计算每个分辨率下的相对误差 $E = |k(h) - k_{\\infty}| / k_{\\infty}$。\n- 以指定的输出格式汇总所有测试用例的结果。\n\n本问题中的所有量均为无量纲格子单位。不涉及角度，也无需进行物理单位转换。\n\n测试套件包含应用于相同通道几何（高度 $H = 1$）的两咱边界格式，具有三种网格分辨率，由通道上的节点数 $N \\in \\{32, 64, 128\\}$ 表征，因此 $h = H/N$。恒定的细化比因此为 $r = h_1 / h_2 = h_2 / h_3 = 2$。\n\n- 测试用例 1（格式 A：阶梯状壁面上的基本反弹格式）：\n  - 通道高度 $H = 1$。\n  - 分辨率 $N = [32, 64, 128]$。\n  - 每个 $N$ 对应的测量渗透率 $k(h)$：$[0.09895833333333333, 0.09114583333333333, 0.08723958333333333]$。\n\n- 测试用例 2（格式 B：模拟插值反弹的改进壁面处理）：\n  - 通道高度 $H = 1$。\n  - 分辨率 $N = [32, 64, 128]$。\n  - 每个 $N$ 对应的测量渗透率 $k(h)$：$[0.08338216145833333, 0.08334554036458333, 0.08333638509114583]$。\n\n对于每个测试用例，你的程序必须计算：\n1. 从三层网格细化中估算出的壁面边界格式的精度阶数 $p$。\n2. 外推得到的连续介质极限渗透率 $k_{\\infty}$。\n3. 在每个分辨率 $N = 32, 64, 128$ 下的相对误差 $E$，计算公式为 $E = |k(h) - k_{\\infty}| / k_{\\infty}$，以十进制数表示（而非百分比）。\n\n最终输出格式规范：\n- 你的程序应生成单行输出，其中包含两个测试用例的汇总结果，格式为方括号括起来的逗号分隔列表。\n- 条目顺序必须是：$[k_{\\infty}^{(A)}, p^{(A)}, E_{32}^{(A)}, E_{64}^{(A)}, E_{128}^{(A)}, k_{\\infty}^{(B)}, p^{(B)}, E_{32}^{(B)}, E_{64}^{(B)}, E_{128}^{(B)}]$。\n- 所有输出必须是浮点数。\n\n你的解决方案必须可由任何开发者使用现代编程语言实现，并且必须依赖于以下基本原理，而不能调用问题陈述中的快捷公式：\n- 达西定律，它将在低雷诺数范围内，渗透率定义为平均流量与驱动力之间的比例常数。\n- 针对足够细化网格的渐近截断误差模型 $k(h) = k_{\\infty} + C \\, h^{p}$。",
            "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了一个来自计算流体动力学领域的标准数值验证任务，特别是使用来自格子玻尔兹曼方法（LBM）模拟的网格细化数据来确定精度阶数并外推到连续介质极限。所有数据和条件都已提供，并且所用方法基于数值分析的既定原则。\n\n解决这个问题的基本原理是对一个渐近误差展开应用 Richardson 外推法。问题陈述指出，对于足够小的网格间距 $h$，数值计算的渗透率 $k(h)$ 与真实的连续介质极限渗透率 $k_{\\infty}$ 通过以下模型相关联：\n$$k(h) = k_{\\infty} + C h^p$$\n其中 $p$ 是数值格式的精度阶数，而 $C$ 是一个依赖于格式但不依赖于网格分辨率 $h$ 的常数。我们的目标是从一组三个测量值中确定未知参数 $p$ 和 $k_{\\infty}$，然后量化误差。\n\n我们得到了三个渗透率的测量值 $k_1$、$k_2$ 和 $k_3$，分别对应于三个网格间距 $h_1 > h_2 > h_3$。网格以一个恒定的比率 $r$ 进行细化，使得 $h_2 = h_1/r$ 且 $h_3 = h_2/r = h_1/r^2$。在本问题中，分辨率以通道高度 $H=1$ 上的节点数给出，即 $N_1=32$、$N_2=64$ 和 $N_3=128$。网格间距 $h$ 定义为 $h=H/N = 1/N$。因此，$h_1 = 1/32$，$h_2 = 1/64$，$h_3 = 1/128$，这给出了一个恒定的细化比 $r = h_1/h_2 = h_2/h_3 = 2$。\n\n根据误差模型，我们可以写出三方程系统：\n1. $k_1 = k(h_1) = k_{\\infty} + C h_1^p$\n2. $k_2 = k(h_2) = k_{\\infty} + C h_2^p = k_{\\infty} + C (h_1/r)^p$\n3. $k_3 = k(h_3) = k_{\\infty} + C h_3^p = k_{\\infty} + C (h_2/r)^p$\n\n为了求出精度阶数 $p$，我们首先通过对连续方程作差来消去 $k_{\\infty}$：\n$$k_1 - k_2 = (k_{\\infty} + C h_1^p) - (k_{\\infty} + C (h_1/r)^p) = C h_1^p (1 - r^{-p})$$\n$$k_2 - k_3 = (k_{\\infty} + C (h_1/r)^p) - (k_{\\infty} + C (h_1/r^2)^p) = C (h_1/r)^p (1 - r^{-p})$$\n接下来，我们求这两个差值的比率，以消去常数 $C$ 和对 $h_1$ 的依赖：\n$$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{C h_1^p (1 - r^{-p})}{C (h_1/r)^p (1 - r^{-p})} = \\frac{h_1^p}{(h_1/r)^p} = r^p$$\n这为表观精度阶数 $p$ 提供了一个直接的公式。通过对两边取对数，我们可以解出 $p$：\n$$p = \\frac{\\log\\left(\\frac{k_1 - k_2}{k_2 - k_3}\\right)}{\\log(r)}$$\n一旦确定了 $p$，我们就可以通过外推法找到一个对 $k_{\\infty}$ 的改进估计值。为了获得更高的精度，我们使用两个最细网格的解 $k_2$ 和 $k_3$。这些解的误差为 $E_2 = k_2 - k_{\\infty} \\approx C h_2^p$ 和 $E_3 = k_3 - k_{\\infty} \\approx C h_3^p = C (h_2/r)^p = E_2 / r^p$。由此，我们得到 $E_2 \\approx r^p E_3$，这导致：\n$$k_2 - k_{\\infty} \\approx r^p (k_3 - k_{\\infty})$$\n$$k_2 - k_{\\infty} \\approx r^p k_3 - r^p k_{\\infty}$$\n$$k_{\\infty} (r^p - 1) \\approx r^p k_3 - k_2$$\n解出 $k_{\\infty}$ 得到 Richardson 外推公式：\n$$k_{\\infty} = \\frac{k_3 r^p - k_2}{r^p - 1}$$\n该公式提供了在连续介质极限（$h \\rightarrow 0$）下渗透率的外推值。\n\n最后，利用估算出的 $k_{\\infty}$，我们可以使用以下定义计算每个分辨率 $N \\in \\{32, 64, 128\\}$（对应渗透率 $k_1, k_2, k_3$）的相对误差 $E$：\n$$E_i = \\frac{|k_i - k_{\\infty}|}{k_{\\infty}}$$\n\n现在我们将此过程应用于提供的两个测试用例。细化比为 $r=2$。\n\n**测试用例 1 (格式 A):**\n- 给定的测量渗透率：\n  - $k_1 = k(1/32) = 0.09895833333333333$\n  - $k_2 = k(1/64) = 0.09114583333333333$\n  - $k_3 = k(1/128) = 0.08723958333333333$\n- 首先，我们计算差值比：\n  $$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{0.09895833333333333 - 0.09114583333333333}{0.09114583333333333 - 0.08723958333333333} = \\frac{0.0078125}{0.00390625} = 2.0$$\n- 精度阶数 $p^{(A)}$ 为：\n  $$p^{(A)} = \\frac{\\log(2.0)}{\\log(2)} = 1.0$$\n- 使用 $p=1$，我们外推求得 $k_{\\infty}^{(A)}$：\n  $$k_{\\infty}^{(A)} = \\frac{k_3 \\cdot 2^1 - k_2}{2^1 - 1} = 2 k_3 - k_2 = 2(0.08723958333333333) - 0.09114583333333333 = 0.08333333333333333$$\n  这个值与理论上的连续介质极限渗透率 $H^2/12 = 1^2/12 \\approx 0.08333...$ 完全吻合。\n- 相对误差为：\n  - $E_{32}^{(A)} = |0.09895833333333333 - 1/12| / (1/12) = 0.015625 / (1/12) = 0.1875$\n  - $E_{64}^{(A)} = |0.09114583333333333 - 1/12| / (1/12) = 0.0078125 / (1/12) = 0.09375$\n  - $E_{128}^{(A)} = |0.08723958333333333 - 1/12| / (1/12) = 0.00390625 / (1/12) = 0.046875$\n\n**测试用例 2 (格式 B):**\n- 给定的测量渗透率：\n  - $k_1 = k(1/32) = 0.08338216145833333$\n  - $k_2 = k(1/64) = 0.08334554036458333$\n  - $k_3 = k(1/128) = 0.08333638509114583$\n- 首先，我们计算差值比：\n  $$\\frac{k_1 - k_2}{k_2 - k_3} = \\frac{0.08338216145833333 - 0.08334554036458333}{0.08334554036458333 - 0.08333638509114583} = \\frac{3.6621... \\times 10^{-5}}{9.1552... \\times 10^{-6}} = 4.0$$\n- 精度阶数 $p^{(B)}$ 为：\n  $$p^{(B)} = \\frac{\\log(4.0)}{\\log(2)} = 2.0$$\n- 使用 $p=2$，我们外推求得 $k_{\\infty}^{(B)}$：\n  $$k_{\\infty}^{(B)} = \\frac{k_3 \\cdot 2^2 - k_2}{2^2 - 1} = \\frac{4k_3 - k_2}{3} = \\frac{4(0.08333638509114583) - 0.08334554036458333}{3} = \\frac{0.25}{3} = 0.08333333333333333$$\n  同样，外推值恰好是 $1/12$。\n- 相对误差为：\n  - $E_{32}^{(B)} = |0.08338216145833333 - 1/12| / (1/12) = 4.8828125 \\times 10^{-5} / (1/12) = 0.0005859375$\n  - $E_{64}^{(B)} = |0.08334554036458333 - 1/12| / (1/12) = 1.220703125 \\times 10^{-5} / (1/12) = 0.000146484375$\n  - $E_{128}^{(B)} = |0.08333638509114583 - 1/12| / (1/12) = 3.0517578125 \\times 10^{-6} / (1/12) = 0.00003662109375$\n\n程序实现将遵循这一逻辑，为每个格式计算所需的值，并将它们汇总到最终指定的输出格式中。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the apparent order of accuracy (p), extrapolated continuum-limit\n    permeability (k_inf), and relative errors (E) for two different numerical\n    schemes based on a three-level grid refinement study.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each inner list contains measured permeabilities [k_coarse, k_medium, k_fine]\n    test_cases = [\n        # Test Case 1 (Scheme A)\n        [0.09895833333333333, 0.09114583333333333, 0.08723958333333333],\n        # Test Case 2 (Scheme B)\n        [0.08338216145833333, 0.08334554036458333, 0.08333638509114583]\n    ]\n\n    # Grid refinement ratio r = h_coarse/h_medium = h_medium/h_fine\n    r = 2.0\n\n    # List to store all results in the final required order.\n    aggregated_results = []\n\n    for case_data in test_cases:\n        k1, k2, k3 = case_data  # k1: coarse, k2: medium, k3: fine\n\n        # Step 1: Estimate the apparent order of accuracy 'p'\n        # The formula is derived from the ratio of differences in permeability:\n        # r^p = (k1 - k2) / (k2 - k3)\n        # p = log((k1 - k2) / (k2 - k3)) / log(r)\n        \n        diff1 = k1 - k2\n        diff2 = k2 - k3\n        \n        # In a well-behaved convergence study, diff2 should be > 0.\n        # If diff2 is zero or negative, the method is not applicable, but\n        # problem validation ensures the data is well-behaved.\n        if diff2 = 0:\n             # This case is not expected based on problem description but is a good practice.\n            raise ValueError(\"Permeability is not converging monotonically.\")\n\n        ratio_of_differences = diff1 / diff2\n        p = np.log(ratio_of_differences) / np.log(r)\n\n        # Step 2: Estimate the continuum-limit permeability 'k_inf'\n        # Richardson extrapolation formula using the two finest grid results:\n        # k_inf = (k3 * r^p - k2) / (r^p - 1)\n        \n        rp = r**p\n        k_inf = (k3 * rp - k2) / (rp - 1)\n\n        # Step 3: Compute the relative errors for each resolution\n        # E = |k(h) - k_inf| / k_inf\n        \n        e1 = abs(k1 - k_inf) / k_inf\n        e2 = abs(k2 - k_inf) / k_inf\n        e3 = abs(k3 - k_inf) / k_inf\n\n        # Append the results for the current test case to the aggregate list.\n        aggregated_results.extend([k_inf, p, e1, e2, e3])\n\n    # Final print statement in the exact required format.\n    # The format is a single-line comma-separated list of floating point numbers\n    # enclosed in square brackets.\n    output_str = \",\".join(map(str, aggregated_results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "孔隙尺度建模的真正威力在于其能够揭示复杂的物理过程，并与实验室测量结果建立联系。本实践将超越单相流，探索非润湿流体（如汞）侵入多孔介质的多相流过程，这对于表征毛细管压力至关重要。您将实现一个考虑了“墨水瓶效应”等关键连通性物理的侵入渗流模型，并通过将模拟结果与实验数据进行比较来校准接触角$\\theta$等模型参数，这是连接理论模型与现实世界的完整科学工作流程。",
            "id": "4095981",
            "problem": "您接获一项任务，通过计算将模拟的压汞毛细管压力（MICP）曲线与从数字岩石物理中获得的实验数据进行比较，并通过系统性地考虑接触角、图像分辨率和墨水瓶效应来调和观察到的差异。目标是实现一个孔隙尺度侵入模型，并评估参数选择如何影响与实验测量值的一致性。\n\n基本原理：\n- Washburn方程将毛细管压力与非润湿流体侵入多孔介质的喉道半径联系起来：$$P_c = -\\frac{2\\gamma \\cos \\theta}{r},$$ 其中，$P_c$ 是毛细管压力，$\\gamma$ 是界面张力，$\\theta$ 是接触角，$r$ 是喉道半径。对于汞（非润湿性）侵入，当 $\\theta  90^\\circ$ 时，$P_c$ 为正，因为 $\\cos \\theta  0$，而负号使得压力为正。\n- 侵入逾渗控制着孔隙体的连通性控制填充：进入新的孔隙体需通过在施加压力下满足毛细管阈值的喉道，侵入从入口通过可及路径进行。“墨水瓶效应”是指大的孔隙体只能通过较小的收缩部（喉道）进入的现象，使得控制进入压力由路径上的限制性喉道决定，而非孔隙体本身的大小。\n- 数字岩石物理中的图像分辨率设定了最小可解析喉道半径，此处记为 $r_{\\min}$，这会截断观察到的孔喉分布。半径 $r  r_{\\min}$ 的喉道在重建的网络中缺失，从而改变了模拟的MICP响应。\n\n定义与假设：\n- 汞的界面张力在实验室条件下取为 $\\gamma = 0.485 \\ \\mathrm{N/m}$。\n- 汞侵入从一组定义的入口孔隙开始；侵入饱和度计算为在施加压力下，通过满足进入阈值的喉道与入口连通的孔隙体积占总孔隙体积的比例。\n- 考虑两种建模模式：\n  1. 墨水瓶模式（考虑连通性）：侵入取决于是否存在从入口通过满足进入阈值的喉道的连通路径，即喉道必须满足 $P_c \\ge -2\\gamma \\cos \\theta / r$ 才能被包含。在给定的 $P_c$ 下，饱和度是侵入的连通孔隙体积与总孔隙体积之比。\n  2. 管束模式（不考虑连通性）：假设每个孔隙体仅基于其由相邻喉道决定的局部进入阈值独立填充，忽略与入口的连通性。在给定的 $P_c$ 下，饱和度是其局部阈值被满足的孔隙体体积之和除以总孔隙体积。\n- 通过从网络中排除半径 $r  r_{\\min}$ 的喉道来施加分辨率截断。\n- 对于每种情况，模拟必须在提供的压力网格上计算饱和度曲线，并通过计算均方根误差（RMSE）与提供的实验饱和度数据进行比较，RMSE定义为：$$\\mathrm{RMSE} = \\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}\\left(S_{\\mathrm{sim}}(P_{c,i}) - S_{\\mathrm{exp}}(P_{c,i})\\right)^2},$$ 其中 $S_{\\mathrm{sim}}$ 是模拟饱和度，$S_{\\mathrm{exp}}$ 是实验饱和度，$N$ 是压力点数。\n\n程序要求：\n- 实现一个函数，对于给定的网络、接触角、分辨率阈值 $r_{\\min}$、压力网格和模式选择，计算模拟的饱和度曲线以及相对于实验数据的RMSE。\n- 在候选接触角、分辨率阈值以及两种建模模式上进行网格搜索，为每个测试用例选择使RMSE最小化的组合。\n- 使用以下候选接触角（单位：度）：$[110, 130, 140, 150, 160, 170]$ 和分辨率阈值（单位：米）：$[50\\times 10^{-9}, 100\\times 10^{-9}, 200\\times 10^{-9}]$。对于RMSE相等的平局打破规则必须优先选择墨水瓶模式，然后是更小的 $r_{\\min}$，最后是离 $140$ 度最近的接触角。\n\n单位与最终报告：\n- 在模拟和报告中，毛细管压力必须以 $\\mathrm{MPa}$ 为单位处理。Washburn方程必须通过将以 $\\mathrm{Pa}$ 为单位的压力除以 $10^6$ 来转换为 $\\mathrm{MPa}$。\n- 接触角必须以度为单位报告。\n- 分辨率阈值必须以纳米为单位报告为数值。\n- RMSE必须报告为十进制数。\n\n测试套件：\n- 案例1（理想情况；喉道尺寸混合，连通性适中）\n  - 孔隙体积（单位 $\\mathrm{m}^3$）：$[1.2\\times 10^{-18}, 0.9\\times 10^{-18}, 1.5\\times 10^{-18}, 1.1\\times 10^{-18}, 0.8\\times 10^{-18}, 1.3\\times 10^{-18}]$。\n  - 喉道：边由 $(i,j,r)$ 给出，其中 $r$ 单位为米：\n    - $(0,1, 0.8\\times 10^{-6})$, $(1,2, 0.2\\times 10^{-6})$, $(2,3, 0.6\\times 10^{-6})$, $(3,4, 0.15\\times 10^{-6})$, $(4,5, 0.5\\times 10^{-6})$, $(0,5, 1.2\\times 10^{-6})$, $(1,4, 0.3\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位 $\\mathrm{MPa}$）：$[0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 16.0]$。\n  - 实验饱和度：$[0.15, 0.25, 0.40, 0.60, 0.80, 0.90, 1.00]$。\n- 案例2（边界角敏感性；喉道较大，侵入较快）\n  - 孔隙体积（单位 $\\mathrm{m}^3$）：$[1.0\\times 10^{-18}, 0.7\\times 10^{-18}, 1.6\\times 10^{-18}, 1.1\\times 10^{-18}, 1.4\\times 10^{-18}]$。\n  - 喉道：\n    - $(0,1, 1.5\\times 10^{-6})$, $(1,2, 0.9\\times 10^{-6})$, $(2,3, 0.4\\times 10^{-6})$, $(3,4, 0.3\\times 10^{-6})$, $(0,4, 1.0\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位 $\\mathrm{MPa}$）：$[0.3, 0.6, 1.2, 2.4, 4.8, 9.6, 14.4]$。\n  - 实验饱和度：$[0.20, 0.35, 0.55, 0.75, 0.90, 0.95, 1.00]$。\n- 案例3（分辨率受限，墨水瓶效应主导；许多小喉道）\n  - 孔隙体积（单位 $\\mathrm{m}^3$）：$[0.8\\times 10^{-18}, 0.6\\times 10^{-18}, 0.9\\times 10^{-18}, 1.2\\times 10^{-18}, 1.1\\times 10^{-18}, 0.7\\times 10^{-18}, 1.0\\times 10^{-18}]$。\n  - 喉道：\n    - $(0,1, 0.12\\times 10^{-6})$, $(1,2, 0.08\\times 10^{-6})$, $(2,3, 0.10\\times 10^{-6})$, $(3,4, 0.20\\times 10^{-6})$, $(4,5, 0.15\\times 10^{-6})$, $(5,6, 0.18\\times 10^{-6})$, $(0,6, 0.30\\times 10^{-6})$。\n  - 入口孔隙：$[0]$。\n  - 压力网格 $P_c$（单位 $\\mathrm{MPa}$）：$[1.0, 2.0, 4.0, 8.0, 12.0, 16.0, 20.0]$。\n  - 实验饱和度：$[0.05, 0.10, 0.20, 0.35, 0.55, 0.80, 1.00]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个包含四个元素的列表：最佳接触角（度），最佳分辨率阈值（纳米），选择的模式标志（墨水瓶模式用$1$，管束模式用$0$），以及找到的最小RMSE。例如，输出应如下所示：$$[[\\theta_1,r_{\\min,1},m_1,\\mathrm{RMSE}_1],[\\theta_2,r_{\\min,2},m_2,\\mathrm{RMSE}_2],[\\theta_3,r_{\\min,3},m_3,\\mathrm{RMSE}_3]]$$",
            "solution": "用户提供了一个数字岩石物理领域的计算问题，该领域是计算地球化学的一个子领域。任务是通过对流体侵入孔隙网络进行建模，将模拟的压汞毛细管压力（MICP）曲线与实验数据进行比较。目标是找到模型参数（接触角 $\\theta$、图像分辨率截止值 $r_{\\min}$ 和侵入模型类型）的最优组合，以最小化模拟与实验之间的差异，该差异通过均方根误差（RMSE）来量化。\n\n### **1. 问题验证**\n\n首先，我将根据所需标准验证问题陈述。\n\n*   **已知条件提取**：\n    *   **方程**：Washburn 方程，$P_c = -\\frac{2\\gamma \\cos \\theta}{r}$。\n    *   **常数**：汞的界面张力，$\\gamma = 0.485 \\ \\mathrm{N/m}$。\n    *   **模型**：1. 墨水瓶模型（考虑连通性的侵入逾渗）。2. 管束模型（不考虑连通性）。\n    *   **误差度量**：RMSE，$\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N}(S_{\\mathrm{sim}}(P_{c,i}) - S_{\\mathrm{exp}}(P_{c,i}))^2}$。\n    *   **网格搜索的参数空间**：\n        *   接触角 $\\theta \\in [110, 130, 140, 150, 160, 170]$ 度。\n        *   分辨率阈值 $r_{\\min} \\in [50\\times 10^{-9}, 100\\times 10^{-9}, 200\\times 10^{-9}]$ 米。\n    *   **平局打破规则**：对于相等的RMSE，优先选择 (1) 墨水瓶模式，然后 (2) 较小的 $r_{\\min}$，最后 (3) 最接近 $140^\\circ$ 的 $\\theta$。\n    *   **数据**：提供了三个测试用例，每个用例都包含一个孔隙网络（孔隙体积、带半径的喉道连接）、入口孔隙、用于模拟的压力网格以及相应的实验饱和度数据。\n    *   **单位**：所有单位和要求的输出格式都已明确定义。\n\n*   **验证结论**：\n    *   **科学依据**：该问题基于多孔介质流体力学的基本原理（Washburn方程）和标准的孔隙尺度建模技术（侵入逾渗、墨水瓶效应）。这些概念是数字岩石物理领域的核心。所给出的物理常数和参数范围是符合实际的。\n    *   **适定性**：问题定义清晰。它明确了输入数据、需要实现的模型、要最小化的目标函数（RMSE）以及明确的平局打破规则。这确保了可以找到一个唯一且稳定的解。\n    *   **客观性**：语言精确且定量，没有主观或模糊的术语。\n    *   **完整性**：提供了构建和运行模拟所需的所有必要数据和定义。问题是自包含的。\n\n该问题被判定为**有效**。这是一个结构良好且科学上合理的计算任务。\n\n### **2. 求解方法**\n\n解决方案需要在指定的参数空间上进行系统性的网格搜索。对于每个参数组合（$\\theta$、$r_{\\min}$、模型类型），我们将执行一次MICP模拟，并计算与实验数据之间的RMSE。在遵循平局打破规则的前提下，产生最小RMSE的组合将是该测试用例的结果。\n\n解决方案的核心是MICP模拟函数。该函数将网络结构和一组参数作为输入，并生成一条饱和度曲线。总体算法如下：\n\n1.  **遍历测试用例**：主循环将处理提供的三个测试用例中的每一个。\n\n2.  **网格搜索**：对于每个测试用例，嵌套循环将遍历：\n    *   两种建模模式（`ink-bottle` 和 `bundle-of-tubes`）。\n    *   每个候选分辨率阈值 $r_{\\min}$。\n    *   每个候选接触角 $\\theta$。\n\n3.  **每个参数集的预计算**：\n    *   首先过滤网络的喉道列表，排除任何半径 $r  r_{\\min}$ 的喉道。\n    *   对于每个剩余的喉道，使用当前的接触角 $\\theta$ 通过Washburn方程计算其毛细管进入压力 $P_{c, \\text{entry}}$。角度必须从度转换为弧度以用于三角函数。结果压力单位为帕斯卡（$\\mathrm{N/m^2}$），需通过除以 $10^6$ 转换为兆帕斯卡（$\\mathrm{MPa}$）。\n    *   通过对所有单个孔隙体积求和，计算网络的总孔隙体积 $V_{\\text{total}}$。\n\n4.  **MICP模拟循环**：对于提供的压力网格中的每个压力点 $P_c$，根据所选的建模模式确定被侵入的孔隙集合。\n    *   **墨水瓶模式（考虑连通性）**：此模式模拟侵入逾渗。在给定压力 $P_c$ 下，如果一个喉道的进入压力 $P_{c, \\text{entry}} \\le P_c$，则该喉道被视为“开放”。侵入从指定的 `inlet_pores` 开始。使用图遍历算法（如广度优先搜索，BFS）来找到所有可以从入口孔隙通过连续的开放喉道路径到达的孔隙。所有访问过的孔隙集合构成了侵入簇。\n    *   **管束模式（不考虑连通性）**：此模型通过忽略到入口的连通路径要求来简化物理过程。如果一个孔隙的*任何*一个相连喉道在当前压力 $P_c$ 下是开放的，则该孔隙被视为已侵入。算法遍历网络中的每个孔隙，并检查其相邻喉道的进入压力。\n\n5.  **饱和度计算**：在确定了给定 $P_c$ 下的侵入孔隙集合后，通过对这些孔隙的体积求和来计算侵入体积 $V_{\\text{invaded}}$。然后饱和度为 $S(P_c) = V_{\\text{invaded}} / V_{\\text{total}}$。对所有压力点重复此过程，以生成模拟的饱和度曲线 $S_{\\text{sim}}$。\n\n6.  **RMSE与参数选择**：\n    *   计算模拟曲线 $S_{\\text{sim}}$ 和实验曲线 $S_{\\text{exp}}$ 之间的RMSE。\n    *   为了管理选择过程和处理平局，为每个参数集创建一个排序键：`(RMSE, -mode_flag, r_min, abs(theta - 140))`。`mode_flag` 对于墨水瓶模式为 $1$，对于管束模式为 $0$；对其取反可确保在最小化上下文中优先选择墨水瓶模式。此复合键按字典序进行比较。将与最小键对应的参数集存储为当前最优。\n\n7.  **最终输出**：在一个测试用例的网格搜索完成后，存储找到的最佳参数（接触角（度）、分辨率（纳米）、模式标志）和相应的最小RMSE。对所有测试用例重复此过程。最终输出格式化为列表的列表，如问题陈述中所指定。\n\n这种详细的、基于原理的方法确保了模型正确地表示了预期的物理过程，并且参数优化严格按照问题的约束进行。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pore-scale modeling problem by performing a grid search to find the\n    best-fit parameters for three different digital rock test cases.\n    \"\"\"\n    \n    GAMMA = 0.485  # Interfacial tension for mercury in N/m\n\n    test_cases = [\n        {\n            \"pore_volumes\": np.array([1.2e-18, 0.9e-18, 1.5e-18, 1.1e-18, 0.8e-18, 1.3e-18]),\n            \"throats\": [\n                (0, 1, 0.8e-6), (1, 2, 0.2e-6), (2, 3, 0.6e-6), (3, 4, 0.15e-6),\n                (4, 5, 0.5e-6), (0, 5, 1.2e-6), (1, 4, 0.3e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([0.5, 1.0, 2.0, 4.0, 8.0, 12.0, 16.0]),\n            \"S_exp\": np.array([0.15, 0.25, 0.40, 0.60, 0.80, 0.90, 1.00]),\n        },\n        {\n            \"pore_volumes\": np.array([1.0e-18, 0.7e-18, 1.6e-18, 1.1e-18, 1.4e-18]),\n            \"throats\": [\n                (0, 1, 1.5e-6), (1, 2, 0.9e-6), (2, 3, 0.4e-6), (3, 4, 0.3e-6), (0, 4, 1.0e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([0.3, 0.6, 1.2, 2.4, 4.8, 9.6, 14.4]),\n            \"S_exp\": np.array([0.20, 0.35, 0.55, 0.75, 0.90, 0.95, 1.00]),\n        },\n        {\n            \"pore_volumes\": np.array([0.8e-18, 0.6e-18, 0.9e-18, 1.2e-18, 1.1e-18, 0.7e-18, 1.0e-18]),\n            \"throats\": [\n                (0, 1, 0.12e-6), (1, 2, 0.08e-6), (2, 3, 0.10e-6), (3, 4, 0.20e-6),\n                (4, 5, 0.15e-6), (5, 6, 0.18e-6), (0, 6, 0.30e-6)\n            ],\n            \"inlet_pores\": [0],\n            \"P_c_grid\": np.array([1.0, 2.0, 4.0, 8.0, 12.0, 16.0, 20.0]),\n            \"S_exp\": np.array([0.05, 0.10, 0.20, 0.35, 0.55, 0.80, 1.00]),\n        }\n    ]\n\n    candidate_thetas = [110, 130, 140, 150, 160, 170]\n    candidate_r_mins = [50e-9, 100e-9, 200e-9]\n    modes = [(\"ink-bottle\", 1), (\"bundle-of-tubes\", 0)]\n\n    all_results = []\n\n    for case in test_cases:\n        pore_volumes = case[\"pore_volumes\"]\n        throats = case[\"throats\"]\n        inlet_pores = case[\"inlet_pores\"]\n        P_c_grid = case[\"P_c_grid\"]\n        S_exp = case[\"S_exp\"]\n\n        num_pores = len(pore_volumes)\n        total_pore_volume = np.sum(pore_volumes)\n\n        best_params = {}\n        best_key = (float('inf'),)\n\n        for mode_name, mode_flag in modes:\n            for r_min in candidate_r_mins:\n                for theta_deg in candidate_thetas:\n                    \n                    current_throats = [t for t in throats if t[2] >= r_min]\n                    \n                    adj_with_pc = {i: [] for i in range(num_pores)}\n                    theta_rad = np.deg2rad(theta_deg)\n                    washburn_const = -2 * GAMMA * np.cos(theta_rad) / 1e6 # Constant for P_c in MPa\n                    for p1, p2, r in current_throats:\n                        pc_entry_mpa = washburn_const / r\n                        adj_with_pc[p1].append((p2, pc_entry_mpa))\n                        adj_with_pc[p2].append((p1, pc_entry_mpa))\n\n                    S_sim = []\n                    for pc_step in P_c_grid:\n                        invaded_pores = set()\n                        if mode_name == \"ink-bottle\":\n                            queue = list(inlet_pores)\n                            visited = set(inlet_pores)\n                            # Use an index-based queue for efficiency\n                            head = 0\n                            while head  len(queue):\n                                u = queue[head]\n                                head += 1\n                                for v, pc_entry in adj_with_pc[u]:\n                                    if pc_entry = pc_step and v not in visited:\n                                        visited.add(v)\n                                        queue.append(v)\n                            invaded_pores = visited\n                        else:  # bundle-of-tubes\n                            for i in range(num_pores):\n                                for _, pc_entry in adj_with_pc[i]:\n                                    if pc_entry = pc_step:\n                                        invaded_pores.add(i)\n                                        break\n                        \n                        invaded_volume = np.sum(pore_volumes[list(invaded_pores)]) if invaded_pores else 0.0\n                        saturation = invaded_volume / total_pore_volume if total_pore_volume > 0 else 0\n                        S_sim.append(saturation)\n\n                    S_sim_np = np.array(S_sim)\n                    rmse = np.sqrt(np.mean((S_sim_np - S_exp)**2))\n                    \n                    # Tie-breaking key: (rmse, -mode, r_min, |theta-140|)\n                    current_key = (rmse, -mode_flag, r_min, abs(theta_deg - 140))\n                    \n                    if current_key  best_key:\n                        best_key = current_key\n                        best_params = {\n                            \"theta\": theta_deg,\n                            \"r_min_nm\": r_min * 1e9,\n                            \"mode\": mode_flag,\n                            \"rmse\": rmse\n                        }\n        \n        all_results.append([\n            best_params[\"theta\"],\n            best_params[\"r_min_nm\"],\n            best_params[\"mode\"],\n            best_params[\"rmse\"]\n        ])\n\n    result_str = \",\".join([f\"[{int(r[0])},{int(r[1])},{r[2]},{r[3]:.6f}]\" for r in all_results])\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```"
        }
    ]
}