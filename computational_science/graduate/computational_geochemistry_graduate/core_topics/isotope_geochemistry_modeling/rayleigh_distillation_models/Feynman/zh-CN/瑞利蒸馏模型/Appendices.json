{
    "hands_on_practices": [
        {
            "introduction": "该实践专注于计算地球化学中的一项核心技能：从一组测量数据中估算分馏系数 $\\alpha$。您将学习如何将瑞利方程线性化，并应用加权最小二乘法和贝叶斯线性回归来确定 $\\alpha$ 及其不确定性，为您分析初始状态已知或未知的真实世界数据做好准备。",
            "id": "4097453",
            "problem": "您正在计算地球化学领域中，使用瑞利分馏模型来模拟一个封闭体系移除过程中的同位素演化。设残留物中的同位素比值为 $R$，定义为残留物中重同位素与轻同位素的比值；设 $f$ 为原始储库的剩余分数。瞬时产物相对于储库的分馏由分馏因子 $\\alpha$ 描述，$\\alpha$ 定义为移除过程中产物与储库中同位素比值的比率。初始同位素比值（在 $f = 1$ 时）为 $R_0$。测量提供了在几个 $f$ 值下的 $R$ 值以及 $R$ 的相关不确定度，但 $R_0$ 可能被直接测量，也可能没有。您的任务是：\n- 从同位素分馏和瑞利分馏质量平衡的基本定义出发，推导出一个经过适当变量转换后的线性关系，该关系允许通过线性回归估算分馏因子 $\\alpha$。解释当 $R_0$ 已知时与当 $R_0$ 不确定且未被直接测量时应使用哪种回归形式。\n- 设计算法，用于 (i) 当 $R_0$ 已知时，使用一个基于统计学原理、截距为零的线性回归公式来估算 $\\alpha$；以及 (ii) 当 $R_0$ 未被直接测量，但其不确定性由一个关于 $\\ln R_0$ 的高斯先验表征时，通过将 $\\ln R_0$ 视为具有高斯先验的讨厌参数，使用贝叶斯线性回归来估算 $\\alpha$。在这两种情况下，报告与假设的高斯测量噪声（以及在贝叶斯情况下的指定先验）一致的 $\\alpha$ 的一倍标准差不确定度。\n- 使用对数的一阶不确定度传播来转换测量不确定度：如果在某一点 $R$ 的测量不确定度为 $\\sigma_R$，则 $\\ln R$ 的不确定度为 $\\sigma_{\\ln R} \\approx \\sigma_R / R$。当使用 $\\ln(R/R_0)$ 且 $R_0$ 已知时，假设 $R_0$ 没有不确定度，其不确定度相同，为 $\\sigma_{\\ln(R/R_0)} \\approx \\sigma_R / R$。\n\n本问题中所有量均为无量纲。您的程序必须为以下测试套件实现所要求的估算程序。每个测试案例指定了 $f$、测量的 $R$ 和 $\\sigma_R$ 的数组；对于已知 $R_0$ 的情况，提供了常数 $R_0$；对于未知 $R_0$ 的情况，通过均值和标准差指定了 $\\ln R_0$ 的高斯先验，并通过标准差指定了斜率的高斯先验。对于每个测试案例，计算两个输出：估算的 $\\alpha$ 及其一倍标准差不确定度，两者均表示为小数（无量纲），并四舍五入到六位小数。\n\n测试套件：\n- 案例 A（已知 $R_0$，宽 $f$ 范围）：\n  - $f = [1.0, 0.8, 0.6, 0.5, 0.35]$\n  - $R_0 = 0.0112372$\n  - $R = [0.0112372, 0.0112435, 0.0112516, 0.0112567, 0.0112668]$\n  - $\\sigma_R = [5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}, 5 \\times 10^{-7}]$\n- 案例 B（未知 $R_0$，对 $\\ln R_0$ 有信息先验）：\n  - $f = [1.0, 0.7, 0.5, 0.3, 0.15]$\n  - $R = [0.0020550, 0.0020631, 0.0020708, 0.0020824, 0.0020983]$\n  - $\\sigma_R = [2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}, 2 \\times 10^{-6}]$\n  - $\\ln R_0$ 的先验：均值 $\\mu_{\\ln R_0} = \\ln(0.0020)$，标准差 $\\sigma_{\\ln R_0} = 0.1$\n  - 斜率的先验：标准差 $\\sigma_{\\text{slope}} = 1.0$\n- 案例 C（已知 $R_0$，$f$ 接近 $1$，弱分馏）：\n  - $f = [1.0, 0.95, 0.9]$\n  - $R_0 = 0.0112372$\n  - $R = [0.0112372, 0.0112369, 0.0112366]$\n  - $\\sigma_R = [3 \\times 10^{-7}, 3 \\times 10^{-7}, 3 \\times 10^{-7}]$\n- 案例 D（未知 $R_0$，对 $\\ln R_0$ 有宽先验，非常小的 $f$）：\n  - $f = [1.0, 0.5, 0.25, 0.125, 0.0625]$\n  - $R = [0.0032000, 0.0032111, 0.0032223, 0.0032333, 0.0032444]$\n  - $\\sigma_R = [8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}, 8 \\times 10^{-7}]$\n  - $\\ln R_0$ 的先验：均值 $\\mu_{\\ln R_0} = \\ln(0.0035)$，标准差 $\\sigma_{\\ln R_0} = 0.2$\n  - 斜率的先验：标准差 $\\sigma_{\\text{slope}} = 2.0$\n- 案例 E（已知 $R_0$，一个点具有高测量不确定度）：\n  - $f = [1.0, 0.8, 0.6, 0.4]$\n  - $R_0 = 0.002055$\n  - $R = [0.0020550, 0.0020619, 0.0020708, 0.0020834]$\n  - $\\sigma_R = [1 \\times 10^{-6}, 1 \\times 10^{-5}, 1 \\times 10^{-6}, 1 \\times 10^{-6}]$\n\n算法要求：\n- 对于已知 $R_0$ 的情况，使用 $y = \\ln(R/R_0)$ 对 $x = \\ln f$ 进行零截距的加权线性回归。设权重为 $w_i = 1 / \\sigma_{y_i}^2$，其中 $\\sigma_{y_i} \\approx \\sigma_{R_i} / R_i$。计算斜率 $\\hat{s}$ 及其方差 $\\operatorname{Var}(\\hat{s})$，并报告 $\\hat{\\alpha} = \\hat{s} + 1$ 和 $\\sigma_{\\alpha} = \\sqrt{\\operatorname{Var}(\\hat{s})}$。\n- 对于未知 $R_0$ 的情况，使用 $y = \\ln R$ 对 $x = \\ln f$ 进行贝叶斯线性回归，其中截距为 $b = \\ln R_0$，斜率为 $m = \\alpha - 1$。假设似然为 $y_i \\sim \\mathcal{N}(m x_i + b, \\sigma_{y_i}^2)$，并对 $m$ 和 $b$ 采用独立的高斯先验 $m \\sim \\mathcal{N}(\\mu_m, \\sigma_m^2)$ 和 $b \\sim \\mathcal{N}(\\mu_b, \\sigma_b^2)$。计算 $(m, b)$ 的后验均值和协方差；报告 $\\hat{\\alpha} = \\mathbb{E}[m] + 1$ 和 $\\sigma_{\\alpha} = \\sqrt{\\operatorname{Var}(m)}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表。该列表必须包含 $10$ 个数字：对于从 A 到 E 的五个案例中的每一个，按顺序输出估算的 $\\alpha$ 及其一倍标准差不确定度，每个都四舍五入到六位小数。例如，格式应为 $[\\alpha_A,\\sigma_A,\\alpha_B,\\sigma_B,\\alpha_C,\\sigma_C,\\alpha_D,\\sigma_D,\\alpha_E,\\sigma_E]$，所有值均为小数，无单位（无量纲）。",
            "solution": "已对用户提供的问题陈述进行分析，并认定其**有效**。该问题在科学上基于同位素地球化学原理，表述清晰，并提供了所有必要信息，且提问方式客观。任务涉及标准的推导以及将已建立的统计方法（加权最小二乘法和贝叶斯线性回归）应用于地球化学数据。此问题并非微不足道，内容一致且可验证。\n\n### 线性关系的推导\n\n瑞利分馏过程描述了在一个有限储库中，当产物被连续且不可逆地移除时，体系中同位素比值的演化。我们被要求从该模型的基本原理中推导出一个线性关系。\n\n设 $N_h$ 和 $N_l$ 分别是储库中在任意时刻重同位素和轻同位素的摩尔数。储库中的同位素比值为 $R = N_h/N_l$。从储库中移出一个无穷小量的物质，其中包含 $dN_h$ 和 $dN_l$ 摩尔的重同位素和轻同位素。这个瞬时产物的同位素比值为 $R_p = dN_h/dN_l$。\n\n分馏因子 $\\alpha$ 定义为产物中的同位素比值与储库中的同位素比值的比率：\n$$\n\\alpha = \\frac{R_p}{R}\n$$\n代入 $R_p$ 和 $R$ 的定义得到：\n$$\n\\alpha = \\frac{dN_h/dN_l}{N_h/N_l}\n$$\n这个方程可以重排成一个可分离的微分形式：\n$$\n\\frac{dN_h}{N_h} = \\alpha \\frac{dN_l}{N_l}\n$$\n为了找到初始状态和最终状态之间的关系，我们对该方程从初始状态（用下标 $0$ 表示）到后来的状态进行积分：\n$$\n\\int_{N_{h,0}}^{N_h} \\frac{d\\tilde{N}_h}{\\tilde{N}_h} = \\alpha \\int_{N_{l,0}}^{N_l} \\frac{d\\tilde{N}_l}{\\tilde{N}_l}\n$$\n假设在整个过程中 $\\alpha$ 是恒定的，积分得到：\n$$\n\\ln\\left(\\frac{N_h}{N_{h,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n我们可以用同位素比值 $R = N_h/N_l$ 和 $R_0 = N_{h,0}/N_{l,0}$ 来表示 $N_h$ 和 $N_{h,0}$：\n$$\n\\ln\\left(\\frac{R N_l}{R_0 N_{l,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n利用对数的性质，我们分离各项：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) + \\ln\\left(\\frac{N_l}{N_{l,0}}\\right) = \\alpha \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n整理后得到：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) = (\\alpha - 1) \\ln\\left(\\frac{N_l}{N_{l,0}}\\right)\n$$\n原始储库的剩余分数 $f$ 通常用主要（轻）同位素的剩余分数来近似，即 $f \\approx N_l/N_{l,0}$，尤其是在重同位素稀少的情况下。将 $f$ 代入方程，得到标准的瑞利分馏方程：\n$$\n\\ln\\left(\\frac{R}{R_0}\\right) = (\\alpha - 1) \\ln f\n$$\n这个方程提供了所需的线性关系。\n\n- **当 $R_0$ 已知时：** 我们可以定义变量 $y = \\ln(R/R_0)$ 和 $x = \\ln f$。模型变为 $y = m x$，其中斜率为 $m = \\alpha - 1$。这是一个通过原点 $(0,0)$ 的线性模型。分馏因子 $\\alpha$ 可以通过强制通过原点的线性回归的斜率来估算。\n\n- **当 $R_0$ 未知或不确定时：** 我们不能直接构建变量 $y = \\ln(R/R_0)$。相反，我们将瑞利方程重排为：\n$$\n\\ln R = (\\alpha - 1) \\ln f + \\ln R_0\n$$\n这是一个 $y = m x + b$ 形式的线性模型，其中 $y = \\ln R$，$x = \\ln f$，斜率为 $m = \\alpha - 1$，截距为 $b = \\ln R_0$。$\\alpha$ 和 $R_0$ 都可以从标准线性回归的斜率和截距中估算出来。\n\n### 算法设计\n\n**i. 已知 $R_0$：零截距的加权线性回归**\n\n当 $R_0$ 已知且没有不确定度时，我们使用模型 $y_i = m x_i + \\epsilon_i$，其中：\n- $y_i = \\ln(R_i/R_0)$\n- $x_i = \\ln f_i$\n- $m = \\alpha - 1$\n- 误差 $\\epsilon_i$ 假定为独立且服从均值为 $0$、方差为 $\\sigma_{y_i}^2$ 的正态分布。\n\n不确定度 $\\sigma_{y_i}$ 是由测量不确定度 $\\sigma_{R_i}$ 通过对数的一阶近似传播得到的：$\\sigma_{y_i} = \\sigma_{\\ln(R_i/R_0)} \\approx \\sigma_{R_i}/R_i$。我们使用加权线性回归来处理异方差性（不同的不确定度）。权重为 $w_i = 1/\\sigma_{y_i}^2$。\n\n斜率的最佳估计值 $\\hat{m}$ 是使加权残差平方和 $\\chi^2 = \\sum_i w_i (y_i - m x_i)^2$ 最小化的值。解为：\n$$\n\\hat{m} = \\frac{\\sum_i w_i x_i y_i}{\\sum_i w_i x_i^2}\n$$\n该估计的方差为：\n$$\n\\operatorname{Var}(\\hat{m}) = \\frac{1}{\\sum_i w_i x_i^2}\n$$\n由此，我们计算 $\\alpha$ 的估计值及其一倍标准差不确定度 $\\sigma_\\alpha$：\n$$\n\\hat{\\alpha} = \\hat{m} + 1 \\quad \\text{和} \\quad \\sigma_\\alpha = \\sqrt{\\operatorname{Var}(\\hat{m})}\n$$\n在 $f=1$ 处的数据点对应于 $x=\\ln(1)=0$ 和 $y=\\ln(R_0/R_0)=0$。这个点 $(0,0)$ 对于估算斜率没有提供信息，因此从求和中排除。\n\n**ii. 未知 $R_0$：贝叶斯线性回归**\n\n当 $R_0$ 未被直接测量并被视为一个具有相关先验的讨厌参数时，我们使用模型 $y_i = m x_i + b + \\epsilon_i$，其中：\n- $y_i = \\ln R_i$\n- $x_i = \\ln f_i$\n- $m = \\alpha - 1$\n- $b = \\ln R_0$\n- 误差 $\\epsilon_i$ 服从 $\\mathcal{N}(0, \\sigma_{y_i}^2)$，其中 $\\sigma_{y_i} \\approx \\sigma_{R_i}/R_i$。\n\n设参数向量为 $\\boldsymbol{\\theta} = [m, b]^T$。矩阵形式的模型为 $\\mathbf{y} = \\mathbf{X}\\boldsymbol{\\theta} + \\boldsymbol{\\epsilon}$，其中 $\\mathbf{X}$ 是设计矩阵，$\\boldsymbol{\\epsilon} \\sim \\mathcal{N}(\\mathbf{0}, \\boldsymbol{\\Sigma}_y)$，$\\boldsymbol{\\Sigma}_y$ 是方差 $\\sigma_{y_i}^2$ 组成的对角矩阵。似然函数为 $p(\\mathbf{y}|\\boldsymbol{\\theta}) \\propto \\exp(-\\frac{1}{2}(\\mathbf{y}-\\mathbf{X}\\boldsymbol{\\theta})^T \\boldsymbol{\\Sigma}_y^{-1} (\\mathbf{y}-\\mathbf{X}\\boldsymbol{\\theta}))$。\n\n我们假设参数具有独立的高斯先验：\n- 斜率：$m \\sim \\mathcal{N}(\\mu_m, \\sigma_m^2)$。根据规定，我们采用零均值先验，$\\mu_m=0$，方差 $\\sigma_m^2$ 由给定的先验标准差的平方得出。\n- 截距：$b \\sim \\mathcal{N}(\\mu_b, \\sigma_b^2)$，其中 $\\mu_b=\\mu_{\\ln R_0}$ 和 $\\sigma_b^2=\\sigma_{\\ln R_0}^2$ 是给定的。\n\n$\\boldsymbol{\\theta}$ 的先验分布为 $p(\\boldsymbol{\\theta}) \\propto \\exp(-\\frac{1}{2}(\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_0)^T \\boldsymbol{\\Sigma}_0^{-1} (\\boldsymbol{\\theta}-\\boldsymbol{\\mu}_0))$，其中 $\\boldsymbol{\\mu}_0 = [\\mu_m, \\mu_b]^T$，$\\boldsymbol{\\Sigma}_0$ 是对角先验协方差矩阵。\n\n$\\boldsymbol{\\theta}$ 的后验分布也是高斯分布，$\\boldsymbol{\\theta} | \\mathbf{y} \\sim \\mathcal{N}(\\boldsymbol{\\mu}_N, \\boldsymbol{\\Sigma}_N)$，其后验协方差 $\\boldsymbol{\\Sigma}_N$ 和均值 $\\boldsymbol{\\mu}_N$ 由下式给出：\n$$\n\\boldsymbol{\\Sigma}_N = \\left(\\mathbf{X}^T \\boldsymbol{\\Sigma}_y^{-1} \\mathbf{X} + \\boldsymbol{\\Sigma}_0^{-1}\\right)^{-1}\n$$\n$$\n\\boldsymbol{\\mu}_N = \\boldsymbol{\\Sigma}_N \\left(\\mathbf{X}^T \\boldsymbol{\\Sigma}_y^{-1} \\mathbf{y} + \\boldsymbol{\\Sigma}_0^{-1} \\boldsymbol{\\mu}_0\\right)\n$$\n斜率 $m$ 的估计值是其后验均值，$\\mathbb{E}[m] = (\\boldsymbol{\\mu}_N)_1$，其方差是后验协方差矩阵中相应的对角元素，$\\operatorname{Var}(m) = (\\boldsymbol{\\Sigma}_N)_{11}$。所需的输出则为：\n$$\n\\hat{\\alpha} = \\mathbb{E}[m] + 1 \\quad \\text{和} \\quad \\sigma_\\alpha = \\sqrt{\\operatorname{Var}(m)}\n$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_known_r0(f, R, sigma_R, R0):\n    \"\"\"\n    Estimates alpha and its uncertainty for known R0 using weighted linear \n    regression through the origin.\n    \"\"\"\n    f_arr = np.array(f, dtype=float)\n    R_arr = np.array(R, dtype=float)\n    sigma_R_arr = np.array(sigma_R, dtype=float)\n    \n    # Exclude the point at f=1, as it provides no information on the slope.\n    # The model is y = m*x, so the point (0,0) is automatically satisfied.\n    mask = f_arr  1.0\n    if not np.any(mask):\n        return np.nan, np.nan # Not enough data to determine slope\n\n    # Transformed variables and uncertainties\n    x = np.log(f_arr[mask])\n    y = np.log(R_arr[mask] / R0)\n    sigma_y = sigma_R_arr[mask] / R_arr[mask]\n    \n    # Weights for WLS\n    w = 1.0 / sigma_y**2\n    \n    # Calculate slope and its variance for y = m*x\n    sum_wxy = np.sum(w * x * y)\n    sum_wx2 = np.sum(w * x**2)\n    \n    m_hat = sum_wxy / sum_wx2\n    var_m_hat = 1.0 / sum_wx2\n    \n    # Calculate alpha from the slope m = alpha - 1\n    alpha_hat = m_hat + 1.0\n    sigma_alpha = np.sqrt(var_m_hat)\n    \n    return alpha_hat, sigma_alpha\n\ndef solve_unknown_r0(f, R, sigma_R, prior_lnR0_mean, prior_lnR0_std, prior_slope_std):\n    \"\"\"\n    Estimates alpha and its uncertainty for unknown R0 using Bayesian linear regression.\n    \"\"\"\n    f_arr = np.array(f, dtype=float)\n    R_arr = np.array(R, dtype=float)\n    sigma_R_arr = np.array(sigma_R, dtype=float)\n    \n    # Transformed variables and uncertainties\n    x = np.log(f_arr)\n    y = np.log(R_arr)\n    sigma_y = sigma_R_arr / R_arr\n    \n    # Weight matrix (inverse of data covariance matrix)\n    W = np.diag(1.0 / sigma_y**2)\n    \n    # Design matrix for y = m*x + b\n    # Column 0 for slope (m), column 1 for intercept (b)\n    X = np.vstack((x, np.ones_like(x))).T\n\n    # Prior distributions\n    # Slope (m) prior: N(0, prior_slope_std^2)\n    # Intercept (b = ln R0) prior: N(prior_lnR0_mean, prior_lnR0_std^2)\n    mu_m = 0.0\n    sigma_m = prior_slope_std\n    mu_b = prior_lnR0_mean\n    sigma_b = prior_lnR0_std\n\n    mu_0 = np.array([mu_m, mu_b])\n    Sigma_0_inv = np.diag([1.0 / sigma_m**2, 1.0 / sigma_b**2])\n\n    # Posterior distribution calculation\n    Sigma_N_inv = X.T @ W @ X + Sigma_0_inv\n    Sigma_N = np.linalg.inv(Sigma_N_inv)\n    \n    mu_N = Sigma_N @ (X.T @ W @ y + Sigma_0_inv @ mu_0)\n    \n    # Extract posterior mean and variance for the slope m\n    m_hat_posterior_mean = mu_N[0]\n    m_hat_posterior_var = Sigma_N[0, 0]\n\n    # Calculate alpha from the slope m = alpha - 1\n    alpha_hat = m_hat_posterior_mean + 1.0\n    sigma_alpha = np.sqrt(m_hat_posterior_var)\n    \n    return alpha_hat, sigma_alpha\n\ndef solve():\n    \"\"\"\n    Main function to process all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Case A (known R0)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.8, 0.6, 0.5, 0.35],\n            \"R0\": 0.0112372,\n            \"R\": [0.0112372, 0.0112435, 0.0112516, 0.0112567, 0.0112668],\n            \"sigma_R\": [5e-7, 5e-7, 5e-7, 5e-7, 5e-7],\n        },\n        # Case B (unknown R0)\n        {\n            \"type\": \"unknown_r0\",\n            \"f\": [1.0, 0.7, 0.5, 0.3, 0.15],\n            \"R\": [0.0020550, 0.0020631, 0.0020708, 0.0020824, 0.0020983],\n            \"sigma_R\": [2e-6, 2e-6, 2e-6, 2e-6, 2e-6],\n            \"prior_lnR0_mean\": np.log(0.0020),\n            \"prior_lnR0_std\": 0.1,\n            \"prior_slope_std\": 1.0,\n        },\n        # Case C (known R0)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.95, 0.9],\n            \"R0\": 0.0112372,\n            \"R\": [0.0112372, 0.0112369, 0.0112366],\n            \"sigma_R\": [3e-7, 3e-7, 3e-7],\n        },\n        # Case D (unknown R0)\n        {\n            \"type\": \"unknown_r0\",\n            \"f\": [1.0, 0.5, 0.25, 0.125, 0.0625],\n            \"R\": [0.0032000, 0.0032111, 0.0032223, 0.0032333, 0.0032444],\n            \"sigma_R\": [8e-7, 8e-7, 8e-7, 8e-7, 8e-7],\n            \"prior_lnR0_mean\": np.log(0.0035),\n            \"prior_lnR0_std\": 0.2,\n            \"prior_slope_std\": 2.0,\n        },\n        # Case E (known R0, high uncertainty point)\n        {\n            \"type\": \"known_r0\",\n            \"f\": [1.0, 0.8, 0.6, 0.4],\n            \"R0\": 0.002055,\n            \"R\": [0.0020550, 0.0020619, 0.0020708, 0.0020834],\n            \"sigma_R\": [1e-6, 1e-5, 1e-6, 1e-6],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[\"type\"] == \"known_r0\":\n            alpha, sigma = solve_known_r0(\n                case[\"f\"], case[\"R\"], case[\"sigma_R\"], case[\"R0\"]\n            )\n        elif case[\"type\"] == \"unknown_r0\":\n            alpha, sigma = solve_unknown_r0(\n                case[\"f\"], case[\"R\"], case[\"sigma_R\"], \n                case[\"prior_lnR0_mean\"], case[\"prior_lnR0_std\"], case[\"prior_slope_std\"]\n            )\n        results.extend([alpha, sigma])\n\n    # Format output to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "自然过程很少在恒定条件下发生。本练习挑战您模拟一个更真实的瑞利蒸馏场景，其中分馏系数 $\\alpha$ 随着系统演化而随温度变化。您将推导控制方程的积分形式并实施数值求解，这是一种处理非理想地球化学系统的强大技术。",
            "id": "4097501",
            "problem": "一个经历瑞利分馏的封闭储库，在瞬时平衡分配的条件下，每一步都会损失微量的挥发性组分。设该组分拥有一对同位素，重同位素的储库摩尔数为 $N_h$，轻同位素的储库摩尔数为 $N_l$，并定义瞬时储库同位素比值为 $R = N_h / N_l$。令 $N = N_h + N_l$ 为该组分的总储库摩尔数，并定义剩余分数 $f = N / N_0$，其中 $N_0$ 是初始总摩尔数，因此 $f \\in (0,1]$。假设分馏因子与温度相关，记为 $\\alpha(T)$，并定义为产物同位素比值与储库同位素比值的平衡比率，即 $\\alpha(T) = R_{\\mathrm{product}} / R_{\\mathrm{reservoir}}$，其中 $R_{\\mathrm{product}}$ 是该步骤中移除的微量物质的同位素比值。温度通过一个已知的映射 $T = T(f)$ 随 $f$ 确定性地变化，单位为开尔文。\n\n任务：\n- 从同位素质量平衡和分馏因子的定义出发，当 $\\alpha$ 通过 $T = T(f)$ 依赖于温度时，建立描述储库同位素比值 $R$ 作为剩余分数 $f$ 的函数的控制性常微分方程（ODE）。解释对 $f$ 的对数依赖性的出现以及 $\\alpha(T(f))$ 在该ODE中的作用，不要引用任何快捷公式。\n- 概述在给定 $R(1) = R_0$、$\\alpha(T)$ 的特定函数形式以及 $T(f)$ 的特定映射的情况下，获得 $R(f)$ 的积分过程。明确说明所使用的任何近似以及导致对 $f$ 进行积分的变量数学变换。\n- 基于推导出的ODE，实现一个程序，使用对 $f$ 的稳健求积方法，为给定的参数集数值计算 $R(f)$。程序必须使用以下分馏因子模型：\n  $$ \\alpha(T) = \\exp\\!\\left(\\frac{A}{T^2} + \\frac{B}{T} + C\\right), $$\n  其中 $A$、$B$ 和 $C$ 是无量纲系数，$T$ 的单位是开尔文。使用指定为以下任一形式的温度模型：\n  1. 线性模型：$$T(f) = T_{\\min} + \\left(T_{\\max} - T_{\\min}\\right) f,$$\n  2. 恒定模型：$$T(f) = T_{\\mathrm{const}},$$\n  3. 幂律模型：$$T(f) = T_{\\min} + \\left(T_{\\max} - T_{\\min}\\right) f^{p}.$$\n  所有温度都必须以开尔文为单位进行解释，$p$ 是无量纲的。同位素比值 $R$ 是无量纲的。\n- 假设重同位素相对于轻同位素是痕量的，因此在典型的地球化学系统中，任何援引 $R \\ll 1$ 的近似在物理上都是合理的。\n\n你的程序必须为以下每个测试用例计算 $R(f_{\\mathrm{end}})$，其中 $R_0$ 是初始比值 $R(1)$，$f_{\\mathrm{end}}$ 是最终剩余分数：\n1. $R_0 = 0.002$，$f_{\\mathrm{end}} = 0.3$，线性温度模型，$T_{\\min} = 280\\,\\mathrm{K}$，$T_{\\max} = 300\\,\\mathrm{K}$，分馏系数 $A = 2.0$，$B = 0.5$，$C = -0.0005$。\n2. $R_0 = 0.002$，$f_{\\mathrm{end}} = 0.5$，恒定温度模型，$T_{\\mathrm{const}} = 298\\,\\mathrm{K}$，分馏系数 $A = 0.0$，$B = 0.0$，$C = 0.002$。\n3. $R_0 = 0.0015$，$f_{\\mathrm{end}} = 0.1$，幂律温度模型，$T_{\\min} = 270\\,\\mathrm{K}$，$T_{\\max} = 320\\,\\mathrm{K}$，$p = 0.5$，分馏系数 $A = 1.0$，$B = -0.2$，$C = 0.0002$。\n4. $R_0 = 0.0025$，$f_{\\mathrm{end}} = 0.99$，幂律温度模型，$T_{\\min} = 295\\,\\mathrm{K}$，$T_{\\max} = 300\\,\\mathrm{K}$，$p = 2.0$，分馏系数 $A = 3.0$，$B = 0.0$，$C = 0.0$。\n5. $R_0 = 0.001$，$f_{\\mathrm{end}} = 0.01$，线性温度模型，$T_{\\min} = 260\\,\\mathrm{K}$，$T_{\\max} = 310\\,\\mathrm{K}$，分馏系数 $A = 0.5$，$B = 0.3$，$C = -0.0003$。\n\n所有输出都必须表示为无量纲的浮点数。你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是第 $i$ 个测试用例计算出的 $R(f_{\\mathrm{end}})$ 值，顺序与上面列出的一致。",
            "solution": "该问题要求推导并随后数值求解在瑞利分馏过程中同位素分馏的控制方程，其中分馏因子 $\\alpha$ 依赖于温度 $T$，而温度 $T$ 又是组分剩余分数 $f$ 的一个确定性函数。推导从质量平衡的第一性原理出发。\n\n**1. 控制性常微分方程（ODE）的建立**\n\n令 $N_h$ 和 $N_l$ 分别代表储库中重同位素和轻同位素的摩尔数。该组分的总摩尔数为 $N = N_h + N_l$。储库的同位素比值定义为 $R = N_h / N_l$。\n\n在瑞利过程中，微量的组分 $dN^{\\mathrm{prod}}$ 从储库中移除。这次移除导致储库总摩尔数发生变化 $dN$，其中 $dN = -dN^{\\mathrm{prod}}$。由于移除的是正量，所以 $dN^{\\mathrm{prod}}  0$，因此 $dN$ 是一个负量。储库中重同位素和轻同位素摩尔数的变化分别为 $dN_h$ 和 $dN_l$。\n\n被移除产物的同位素比值为 $R_{\\mathrm{product}} = dN_h^{\\mathrm{prod}} / dN_l^{\\mathrm{prod}}$。质量守恒要求每种同位素移除的量等于储库中该同位素变化的负值，因此 $dN_h^{\\mathrm{prod}} = -dN_h$ 且 $dN_l^{\\mathrm{prod}} = -dN_l$。所以，\n$$ R_{\\mathrm{product}} = \\frac{-dN_h}{-dN_l} = \\frac{dN_h}{dN_l} $$\n分馏因子 $\\alpha$ 定义为产物同位素组成与储库同位素组成的比值：\n$$ \\alpha = \\frac{R_{\\mathrm{product}}}{R_{\\mathrm{reservoir}}} = \\frac{dN_h/dN_l}{N_h/N_l} $$\n这给出了同位素丰度微分变化之间的直接关系：\n$$ \\frac{dN_h}{dN_l} = \\alpha R $$\n由此可得 $dN_h = \\alpha R dN_l$。\n\n为了找出储库比值 $R$ 的演化，我们使用商法则对 $R = N_h / N_l$ 进行微分：\n$$ dR = \\frac{N_l dN_h - N_h dN_l}{N_l^2} = \\frac{dN_h}{N_l} - \\frac{N_h}{N_l} \\frac{dN_l}{N_l} = \\frac{dN_h}{N_l} - R \\frac{dN_l}{N_l} $$\n将 $dN_h = \\alpha R dN_l$ 代入此表达式可得：\n$$ dR = \\frac{\\alpha R dN_l}{N_l} - R \\frac{dN_l}{N_l} = (\\alpha - 1) R \\frac{dN_l}{N_l} $$\n这个方程将储库同位素比值的变化与轻同位素丰度的分数变化联系起来。为了用总摩尔数 $N$ 来表示，我们使用问题中陈述的近似，即重同位素是痕量组分，即 $N_h \\ll N_l$。这意味着总摩尔数 $N = N_h + N_l \\approx N_l$，因此，微分变化 $dN \\approx dN_l$。在这个标准且物理上合理的近似下，方程变为：\n$$ \\frac{dR}{R} = (\\alpha - 1) \\frac{dN}{N} $$\n这是同位素地球化学中的一个开创性方程。最后一步是将自变量从总摩尔数 $N$ 变为剩余分数 $f$。分数 $f$ 定义为 $f = N/N_0$，其中 $N_0$ 是过程开始时（$f=1$）的初始总摩尔数。对这个定义进行微分得到 $df = dN/N_0$，或 $dN = N_0 df$。将此式和 $N = N_0 f$ 代入 $dN/N$ 的表达式中：\n$$ \\frac{dN}{N} = \\frac{N_0 df}{N_0 f} = \\frac{df}{f} $$\n这个代换直接得出了 $R$ 作为 $f$ 函数的控制性ODE：\n$$ \\frac{dR}{R} = (\\alpha - 1) \\frac{df}{f} \\quad \\implies \\quad \\frac{dR}{df} = \\frac{R}{f}(\\alpha - 1) $$\n问题指明分馏因子 $\\alpha$ 是温度 $T$ 的函数，而温度 $T$ 本身是剩余分数 $f$ 的函数，即 $\\alpha = \\alpha(T(f))$。因此，ODE的最终形式是：\n$$ \\frac{dR}{df} = \\frac{R}{f}(\\alpha(T(f)) - 1) $$\n对 $f$ 的对数依赖性的出现是 $df/f$ 项的直接结果。积分后，该项将产生自然对数 $\\ln(f)$。$\\alpha(T(f))$ 的作用是在这个一阶线性ODE中充当可变系数。与 $\\alpha$ 是常数的简单情况不同，在这里分馏的程度随着过程的演化而改变，由预设的温度路径 $T(f)$ 决定。\n\n**2. 积分过程**\n\n推导出的ODE是可分离的。我们可以重新排列各项，将变量 $R$ 和 $f$ 分别置于方程的两边：\n$$ \\frac{dR}{R} = \\frac{\\alpha(T(f)) - 1}{f} df $$\n为了求出在最终分数 $f_{\\mathrm{end}}$ 时的同位素比值 $R(f_{\\mathrm{end}})$，我们对两边从初始状态（在 $f=1$ 时，比值为 $R_0$）到最终状态（在 $f=f_{\\mathrm{end}}$ 时，比值为 $R(f_{\\mathrm{end}})$）进行积分。我们使用一个哑积分变量 $f'$，以避免与积分上限混淆。\n$$ \\int_{R_0}^{R(f_{\\mathrm{end}})} \\frac{dR}{R} = \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' $$\n左边积分得到：\n$$ \\int_{R_0}^{R(f_{\\mathrm{end}})} \\frac{dR}{R} = \\left[ \\ln R \\right]_{R_0}^{R(f_{\\mathrm{end}})} = \\ln(R(f_{\\mathrm{end}})) - \\ln(R_0) = \\ln\\left(\\frac{R(f_{\\mathrm{end}})}{R_0}\\right) $$\n将此与右边相等，可得：\n$$ \\ln\\left(\\frac{R(f_{\\mathrm{end}})}{R_0}\\right) = \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' $$\n对两边取指数，得到 $R(f_{\\mathrm{end}})$ 的解：\n$$ R(f_{\\mathrm{end}}) = R_0 \\exp\\left( \\int_{1}^{f_{\\mathrm{end}}} \\frac{\\alpha(T(f')) - 1}{f'} df' \\right) $$\n此推导中援引的唯一近似是 $R \\ll 1$。从 $N$ 到 $f$ 的变量变换在积分内部引入了因子 $1/f'$。对于 $\\alpha(T(f))$ 的一般函数形式，该积分没有简单的解析解。因此，必须进行数值计算。该过程包括：\n1.  定义被积函数 $g(f') = (\\alpha(T(f')) - 1) / f'$。\n2.  使用稳健的数值求积方法（例如Python中`scipy.integrate.quad`提供的方法）来计算定积分 $I = \\int_{1}^{f_{\\mathrm{end}}} g(f') df'$。\n3.  计算最终同位素比值 $R(f_{\\mathrm{end}}) = R_0 \\exp(I)$。\n\n**3. 数值计算**\n\n程序将实现此积分过程。对于每个测试用例，它将为 $\\alpha(T)$ 和 $T(f)$ 模型定义具体参数。将构建一个被积函数来计算给定 $f$ 的 $(\\alpha(T(f)) - 1)/f$。此函数将被传递给SciPy库中的一个数值求积例程，以计算在区间 $[1, f_{\\mathrm{end}}]$ 上的积分。然后，通过将初始比值 $R_0$ 乘以积分值的指数来计算最终比值 $R(f_{\\mathrm{end}})$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves for the final isotopic ratio in a Rayleigh distillation model with\n    temperature-dependent fractionation.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"R0\": 0.002, \"f_end\": 0.3, \"model\": \"linear\",\n            \"T_params\": {\"Tmin\": 280.0, \"Tmax\": 300.0},\n            \"alpha_params\": {\"A\": 2.0, \"B\": 0.5, \"C\": -0.0005}\n        },\n        {\n            \"R0\": 0.002, \"f_end\": 0.5, \"model\": \"constant\",\n            \"T_params\": {\"Tconst\": 298.0},\n            \"alpha_params\": {\"A\": 0.0, \"B\": 0.0, \"C\": 0.002}\n        },\n        {\n            \"R0\": 0.0015, \"f_end\": 0.1, \"model\": \"power\",\n            \"T_params\": {\"Tmin\": 270.0, \"Tmax\": 320.0, \"p\": 0.5},\n            \"alpha_params\": {\"A\": 1.0, \"B\": -0.2, \"C\": 0.0002}\n        },\n        {\n            \"R0\": 0.0025, \"f_end\": 0.99, \"model\": \"power\",\n            \"T_params\": {\"Tmin\": 295.0, \"Tmax\": 300.0, \"p\": 2.0},\n            \"alpha_params\": {\"A\": 3.0, \"B\": 0.0, \"C\": 0.0}\n        },\n        {\n            \"R0\": 0.001, \"f_end\": 0.01, \"model\": \"linear\",\n            \"T_params\": {\"Tmin\": 260.0, \"Tmax\": 310.0},\n            \"alpha_params\": {\"A\": 0.5, \"B\": 0.3, \"C\": -0.0003}\n        }\n    ]\n\n    # --- Helper functions for physical models ---\n\n    def alpha_model(T, A, B, C):\n        \"\"\"Calculates the fractionation factor alpha(T).\"\"\"\n        return np.exp(A / T**2 + B / T + C)\n\n    def T_linear(f, Tmin, Tmax):\n        \"\"\"Linear temperature model T(f).\"\"\"\n        return Tmin + (Tmax - Tmin) * f\n\n    def T_constant(f, Tconst):\n        \"\"\"Constant temperature model T(f).\"\"\"\n        # f is unused but kept for consistent function signature.\n        return Tconst\n\n    def T_power(f, Tmin, Tmax, p):\n        \"\"\"Power-law temperature model T(f).\"\"\"\n        return Tmin + (Tmax - Tmin) * f**p\n\n    # Map model names to temperature functions\n    T_models = {\n        \"linear\": T_linear,\n        \"constant\": T_constant,\n        \"power\": T_power\n    }\n\n    def integrand(f_prime, case_params):\n        \"\"\"\n        Calculates the value of the integrand for the Rayleigh equation:\n        (alpha(T(f')) - 1) / f'\n        \n        Args:\n            f_prime (float): The remaining fraction (variable of integration).\n            case_params (dict): A dictionary containing all parameters for the case.\n        \"\"\"\n        # Unpack parameters\n        model_type = case_params[\"model\"]\n        T_params = case_params[\"T_params\"]\n        alpha_params = case_params[\"alpha_params\"]\n\n        # Calculate temperature T(f')\n        T_func = T_models[model_type]\n        # The ** operator unpacks the dictionary into keyword arguments\n        T = T_func(f_prime, **T_params)\n\n        # Calculate fractionation factor alpha(T)\n        alpha = alpha_model(T, **alpha_params)\n\n        # Return the integrand value\n        # A small epsilon is added to f_prime to avoid division by zero if f_prime=0,\n        # though integration limits should prevent this.\n        return (alpha - 1.0) / (f_prime + 1e-15)\n\n    results = []\n    for case in test_cases:\n        # Perform the numerical integration\n        # The integral is from f=1 to f=f_end\n        integral_value, _ = quad(\n            integrand, \n            1.0, \n            case[\"f_end\"], \n            args=(case,)\n        )\n\n        # Calculate the final isotopic ratio R(f_end)\n        R_f_end = case[\"R0\"] * np.exp(integral_value)\n        results.append(R_f_end)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "近似方法功能强大，但必须明智地使用。本实践深入探讨了常用的线性化 $\\delta$-瑞利关系，引导您推导其误差并建立其有效使用的标准。掌握这种分析将使您能够批判性地评估数据，并避免因在超出模型极限的情况下应用简化模型而可能产生的重大误解。",
            "id": "4097488",
            "problem": "在一个二元同位素对的封闭系统同位素瑞利分馏过程中，随着质量被移除，残余相中的同位素比值会发生演化，该过程由分馏因子 $\\alpha$ 和主体相的剩余分数 $f$ 控制。同位素组成以相对于公认标准的 $\\delta$ 标记法报告，其中 $\\delta$ 由重同位素与轻同位素的比值 $R$ 定义。许多从业者使用线性化的 $\\delta$-瑞利关系式，因为它简化了计算和解释，但在大分馏或小 $f$ 值的情况下可能会产生偏差。仅从 $\\delta$ 的基本定义、单步平衡分配中分馏因子 $\\alpha$ 的含义，以及同位素比值的瑞利质量平衡定律出发，推导 $\\delta$、$\\delta_0$、$\\alpha$ 和 $f$ 之间的精确关系式。然后，通过对 $\\delta/1000$ 和 $|(\\alpha - 1)\\ln f|$ 的小值进行受控的渐近展开，得到线性化 $\\delta$-瑞利近似的绝对误差的显式主阶表达式。使用此误差表达式，以 $\\delta_0$ 和 $f$（以及 $\\alpha$）的形式提出了一个定量标准，该标准指明了何时必须使用精确公式以使线性化误差保持在约 1‰ 以下。最后，选择一个选项，该选项陈述了与您的推导一致且数学上可辩护的标准，并对与大分馏或小 $f$ 值相关的常见陷阱提出了警示。\n\nA. 当 $\\lvert \\delta_0 \\rvert  20$‰ 或 $\\lvert (\\alpha - 1)\\ln f \\rvert  0.02$ 时，使用精确的 $\\delta$-瑞利公式。如果 $\\lvert \\delta_0 \\rvert \\le 20$‰ 且 $\\lvert (\\alpha - 1)\\ln f \\rvert \\le 0.02$，则线性化关系式的绝对误差上限约为 0.6‰，满足 1‰ 的容差。\n\nB. 只要 $f  0.1$ 且 $\\lvert \\delta_0 \\rvert  500$‰，线性化的 $\\delta$-瑞利关系式就是有效的，因为在这些界限下 $\\ln f$ 保持适中，且高阶项可以忽略不计。\n\nC. 仅当 $f  0.01$ 时才有必要使用精确的 $\\delta$-瑞利公式，因为对数在零附近发散；对于任何 $f \\ge 0.01$，无论 $\\alpha$ 或 $\\delta_0$ 如何，线性化关系式实际上都是精确的。\n\nD. 如果初始组成满足 $\\delta_0 = 0$，则线性化的 $\\delta$-瑞利关系式对所有的 $f$ 和 $\\alpha$ 都是精确的，因此不需要特殊标准。",
            "solution": "问题陈述是计算地球化学领域一个有效的理论练习。它以已建立的同位素分馏原理为科学基础，通过要求进行特定的推导和分析而提法恰当，并且表述客观。对于熟悉其引用的标准定义的从业者来说，这个问题是自洽的。因此，我将继续进行推导和评估。\n\n核心任务是推导线性化瑞利分馏公式的误差，并为其使用建立一个标准。这需要从第一性原理出发。\n\n**1. 精确 $\\delta$-瑞利方程的推导**\n\n该过程始于三个基本关系：\n1.  同位素比值 $R$ 是重同位素与轻同位素的比值。\n2.  $\\delta$ 标记法表示该比值相对于一个标准 ($R_{std}$) 的值：\n    $$ \\delta = \\left( \\frac{R}{R_{std}} - 1 \\right) \\times 1000 $$\n    根据这个定义，我们可以将比值 $R$ 表示为 $\\delta$ 的函数：\n    $$ \\frac{R}{R_{std}} = 1 + \\frac{\\delta}{1000} \\implies R = R_{std} \\left( 1 + \\frac{\\delta}{1000} \\right) $$\n    初始组成 $\\delta_0$ 通过相同的公式与初始比值 $R_0$ 相关联：\n    $$ R_0 = R_{std} \\left( 1 + \\frac{\\delta_0}{1000} \\right) $$\n3.  瑞利分馏定律描述了残余储库中同位素比值 $R$ 随剩余分数 $f$ 和分馏因子 $\\alpha$ 变化的演化过程：\n    $$ \\frac{R}{R_0} = f^{(\\alpha - 1)} $$\n\n为了推导 $\\delta$ 标记法下的精确关系，我们将 $R$ 和 $R_0$ 的表达式代入瑞利定律：\n$$ \\frac{R_{std} \\left( 1 + \\frac{\\delta}{1000} \\right)}{R_{std} \\left( 1 + \\frac{\\delta_0}{1000} \\right)} = f^{(\\alpha - 1)} $$\n$R_{std}$ 项消去，得到**精确的 $\\delta$-瑞利方程**：\n$$ \\frac{1 + \\delta/1000}{1 + \\delta_0/1000} = f^{(\\alpha - 1)} $$\n这个方程可以解出 $\\delta$ 得到其显式形式：\n$$ \\delta_{exact} = 1000 \\left[ \\left( 1 + \\frac{\\delta_0}{1000} \\right) f^{(\\alpha - 1)} - 1 \\right] $$\n\n**2. 线性化近似及其绝对误差的推导**\n\n线性化形式是通过近似得到的。对精确方程取自然对数：\n$$ \\ln\\left(1 + \\frac{\\delta}{1000}\\right) - \\ln\\left(1 + \\frac{\\delta_0}{1000}\\right) = (\\alpha - 1) \\ln f $$\n使用泰勒级数展开 $\\ln(1+x) = x - x^2/2 + O(x^3)$，对于小的 $x$，近似为 $\\ln(1+x) \\approx x$。如果 $\\delta/1000$ 和 $\\delta_0/1000$ 很小，我们得到：\n$$ \\frac{\\delta}{1000} - \\frac{\\delta_0}{1000} \\approx (\\alpha - 1) \\ln f $$\n$$ \\delta - \\delta_0 \\approx 1000 (\\alpha - 1) \\ln f $$\n这就得到了**线性化的 $\\delta$-瑞利近似**，我们将其记为 $\\delta_{lin}$：\n$$ \\delta_{lin} = \\delta_0 + 1000 (\\alpha - 1) \\ln f $$\n该近似的绝对误差是 $E = |\\delta_{exact} - \\delta_{lin}|$。为了找到这个误差的表达式，我们进行更仔细的展开。让我们回到 $\\delta_{exact}$ 的显式形式，并展开项 $f^{(\\alpha - 1)} = e^{(\\alpha - 1)\\ln f}$。令 $X = (\\alpha - 1)\\ln f$。$e^X$ 的泰勒展开是 $1 + X + X^2/2! + O(X^3)$。\n$$ \\delta_{exact} = 1000 \\left[ \\left( 1 + \\frac{\\delta_0}{1000} \\right) \\left( 1 + X + \\frac{X^2}{2} + \\dots \\right) - 1 \\right] $$\n$$ \\frac{\\delta_{exact}}{1000} = \\left( 1 + \\frac{\\delta_0}{1000} \\right) \\left( 1 + X + \\frac{X^2}{2} + \\dots \\right) - 1 $$\n展开乘积：\n$$ \\frac{\\delta_{exact}}{1000} = \\left( 1 + X + \\frac{X^2}{2} \\right) + \\left( \\frac{\\delta_0}{1000} + \\frac{\\delta_0}{1000}X + \\frac{\\delta_0}{1000}\\frac{X^2}{2} \\right) + \\dots - 1 $$\n合并同类项：\n$$ \\frac{\\delta_{exact}}{1000} = \\left( \\frac{\\delta_0}{1000} + X \\right) + \\left( \\frac{\\delta_0}{1000}X + \\frac{X^2}{2} \\right) + \\dots $$\n乘以 1000：\n$$ \\delta_{exact} = \\left( \\delta_0 + 1000 X \\right) + \\left( \\delta_0 X + 500 X^2 \\right) + \\dots $$\n代入 $X = (\\alpha - 1)\\ln f$：\n$$ \\delta_{exact} = \\underbrace{\\left( \\delta_0 + 1000 (\\alpha - 1)\\ln f \\right)}_{\\delta_{lin}} + \\underbrace{\\left( \\delta_0 (\\alpha - 1)\\ln f + 500 ((\\alpha - 1)\\ln f)^2 \\right)}_{\\text{主阶误差项, } \\Delta} + \\dots $$\n绝对误差 $E$ 近似为主阶误差项的绝对值：\n$$ E = |\\delta_{exact} - \\delta_{lin}| \\approx |\\Delta| = \\left| \\delta_0 (\\alpha - 1)\\ln f + 500 ((\\alpha - 1)\\ln f)^2 \\right| $$\n\n**3. 建立定量标准**\n\n为了使误差 $E$ 保持在约 1‰ 以下，我们需要对误差表达式中的各项进行约束。使用三角不等式，我们可以建立误差的上限：\n$$ E \\le |\\delta_0 (\\alpha - 1)\\ln f| + |500 ((\\alpha - 1)\\ln f)^2| $$\n令 $X = (\\alpha-1)\\ln f$。误差界为 $E_{bound} = |\\delta_0 X| + 500X^2$。我们想找到 $\\delta_0$ 和 $X$ 的条件，使得 $E_{bound} \\lesssim 1$。\n\n让我们测试选项 A 中提出的标准：如果 $|\\delta_0| \\le 20$‰ 且 $|X| = |(\\alpha-1)\\ln f| \\le 0.02$，则线性化近似是可以接受的。在这些条件下，当 $|\\delta_0|$ 和 $|X|$ 都取其允许的最大值时，会出现最大误差：\n$$ E_{bound, max} = (20)(0.02) + 500(0.02)^2 = 0.4 + 500(0.0004) = 0.4 + 0.2 = 0.6 $$\n0.6‰ 的误差上限远在约 1‰ 的容差范围内。因此，当 $|\\delta_0|  20$‰ 或 $|(\\alpha-1)\\ln f|  0.02$ 时使用精确公式的标准，是一个合理且有数学依据的指导方针，以确保线性化误差保持在可接受的小范围内。\n\n**4. 选项评估**\n\n*   **A. 当 $\\lvert \\delta_0 \\rvert  20$‰ 或 $\\lvert (\\alpha - 1)\\ln f \\rvert  0.02$ 时，使用精确的 $\\delta$-瑞利公式。如果 $\\lvert \\delta_0 \\rvert \\le 20$‰ 且 $\\lvert (\\alpha - 1)\\ln f \\rvert \\le 0.02$，则线性化关系式的绝对误差上限约为 0.6‰，满足 1‰ 的容差。**\n    这个陈述与上述推导完全一致。所提出的关于 $\\delta_0$ 和 $(\\alpha - 1)\\ln f$ 的界限定义了一个区域，在该区域内计算出的最大主阶误差为 0.6‰，满足要求。逻辑合理，数字正确。\n    结论：**正确**。\n\n*   **B. 只要 $f  0.1$ 且 $\\lvert \\delta_0 \\rvert  500$‰，线性化的 $\\delta$-瑞利关系式就是有效的，因为在这些界限下 $\\ln f$ 保持适中，且高阶项可以忽略不计。**\n    这个标准是有缺陷的，因为它没有考虑分馏因子 $\\alpha$ 的大小。让我们测试一下它的界限。设 $f=0.5$，$\\delta_0 = 400$‰，$\\alpha = 1.02$。那么 $\\ln f \\approx -0.693$ 且 $\\alpha-1 = 0.02$。\n    误差为 $E \\approx |\\Delta| = |(400)(0.02)(-0.693) + 500((0.02)(-0.693))^2| = |-5.54 + 500(-0.01386)^2| = |-5.54 + 0.096| \\approx 5.4$‰。这个误差是巨大的，远非可以忽略不计。所提出的界限是危险且不充分的。\n    结论：**不正确**。\n\n*   **C. 仅当 $f  0.01$ 时才有必要使用精确的 $\\delta$-瑞利公式，因为对数在零附近发散；对于任何 $f \\ge 0.01$，无论 $\\alpha$ 或 $\\delta_0$ 如何，线性化关系式实际上都是精确的。**\n    这个陈述是错误的。误差除了取决于 $f$ 外，还取决于 $\\delta_0$ 和 $\\alpha$。对于 $f \\ge 0.01$，可以轻易找到导致大误差的 $\\delta_0$ 和 $\\alpha$ 的组合。例如，设 $f=0.1$，$\\delta_0=50$‰，$\\alpha=1.04$。那么 $\\ln f \\approx -2.30$ 且 $\\alpha-1 = 0.04$。\n    误差为 $E \\approx |\\Delta| = |(50)(0.04)(-2.30) + 500 ((0.04)(-2.30))^2| = |-4.6 + 500(-0.092)^2| = |-4.6 + 4.23| \\approx 0.37$‰。这个误差很小。\n    但如果 $\\alpha = 1.05$， $E \\approx |(50)(0.05)(-2.30) + 500((0.05)(-2.30))^2| = |-5.75 + 500(-0.115)^2| = |-5.75+6.61| \\approx 0.86$‰。\n    如果 $\\delta_0 = 100$ 且 $\\alpha=1.05$， $E \\approx |-11.5 + 6.61| \\approx 4.89$‰。声称该关系“实际上是精确的”显然是错误的。\n    结论：**不正确**。\n\n*   **D. 如果初始组成满足 $\\delta_0 = 0$，则线性化的 $\\delta$-瑞利关系式对所有的 $f$ 和 $\\alpha$ 都是精确的，因此不需要特殊标准。**\n    这个陈述意味着如果 $\\delta_0 = 0$，那么 $\\delta_{exact} = \\delta_{lin}$。\n    当 $\\delta_0=0$ 时，$\\delta_{lin} = 1000(\\alpha-1)\\ln f$。\n    当 $\\delta_0=0$ 时，$\\delta_{exact} = 1000(f^{(\\alpha-1)} - 1)$。\n    这个说法等同于 $1000(\\alpha-1)\\ln f = 1000(f^{(\\alpha-1)} - 1)$。令 $u = (\\alpha-1)\\ln f$。该说法可简化为断言 $u = e^u - 1$ 对所有 $u$ 都是一个恒等式。这是错误的。等式两边仅在 $u=0$ 时相等。对于任何非零的 $u$ 值，都存在差异。当 $\\delta_0=0$ 时，误差为 $E \\approx |500((\\alpha-1)\\ln f)^2|$，这是非零的。\n    结论：**不正确**。",
            "answer": "$$\\boxed{A}$$"
        }
    ]
}