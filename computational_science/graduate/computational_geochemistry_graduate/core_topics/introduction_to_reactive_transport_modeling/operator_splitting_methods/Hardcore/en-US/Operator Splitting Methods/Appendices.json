{
    "hands_on_practices": [
        {
            "introduction": "The Advection-Diffusion-Reaction (ADR) equation is a cornerstone of transport modeling. This practice provides a fundamental exercise where you will both theoretically and numerically dissect the Lie operator splitting method. By deriving the splitting error from first principles and then implementing a numerical code to verify its order of accuracy, you will build a concrete understanding of how and why splitting errors arise from non-commuting operators. ",
            "id": "4079402",
            "problem": "Consider a one-dimensional Advection–Diffusion–Reaction (ADR) Partial Differential Equation (PDE) for a scalar concentration field $C(x,t)$ on a periodic spatial domain $x \\in [0,L]$ and time $t \\ge 0$, with spatially varying advection velocity $v(x)$, constant molecular diffusion coefficient $D$, and spatially varying first-order reaction rate $k(x)$. The governing equation is\n$$\n\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t),\n$$\nsubject to periodic boundary conditions and a smooth periodic initial condition. The Advection–Diffusion–Reaction (ADR) processes arise in Computational Geochemistry when modeling the transport and transformation of aqueous species in porous media and reactive flows.\n\nTask 1 (Derivation): Starting from the definitions of the advection operator $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$, the diffusion operator $\\mathcal{D} u = D\\,\\partial_{xx} u$, and the reaction operator $\\mathcal{R} u = -\\,k(x)\\,u$, derive a first-order Lie operator splitting for one time step $\\Delta t$ that evolves $C(x,t)$ by sequentially solving subproblems for advection, diffusion, and reaction over the same $\\Delta t$ in the order advection, then diffusion, then reaction. Use a principle-based derivation starting from semigroup composition, and quantify the leading-order local splitting error in terms of commutators of the operators. Your derivation must start from fundamental definitions of linear operators and the composition of flows; do not use pre-stated shortcut formulas or give the final commutator result without derivation.\n\nTask 2 (Implementation): Implement a numerical algorithm that realizes the first-order Lie splitting you derived. Use a spatially discrete periodic grid and the following numerical procedures:\n- For advection substeps, solve the Ordinary Differential Equation (ODE) semi-discrete system $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C}$ over one substep $\\Delta t$ with a high-accuracy ODE integrator. Here $\\mathbf{C}$ is the vector of concentration values at grid points, $\\mathbf{v}$ is the vector of advection speeds at grid points, $\\odot$ denotes componentwise multiplication, and $\\partial_x \\mathbf{C}$ is the spectral first derivative computed via the Fast Fourier Transform (FFT) on the periodic domain.\n- For diffusion substeps, evolve $\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C}$ exactly in Fourier space over one substep $\\Delta t$ by multiplying each Fourier mode by $\\exp(-D\\,k^2\\,\\Delta t)$, where $k$ is the angular wavenumber.\n- For reaction substeps, evolve $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C}$ exactly over one substep $\\Delta t$ by multiplying componentwise by $\\exp(-\\mathbf{k}\\,\\Delta t)$.\n\nTo quantify the splitting error, compute a high-accuracy unsplit reference solution $\\mathbf{C}_{\\text{ref}}(T)$ by solving the full semi-discrete ADR system\n$$\n\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}\n$$\nfrom $t = 0$ to $t = T$ using a high-order adaptive ODE integrator with tight tolerances. Then compute the relative discrete $\\ell^2$-error at the final time $T$,\n$$\nE \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2},\n$$\nwhere $\\left\\|\\cdot\\right\\|_2$ is the Euclidean norm on the grid. Report this error as a dimensionless decimal.\n\nDomain, coefficients, and initial condition:\n- Domain length $L$ in meters is $L = 1$ with periodic boundary conditions.\n- Grid size $N$ is $N = 128$ uniformly spaced points.\n- Advection velocity $v(x) = v_0 + v_1\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)$ with $v_0$ in meters per second and $v_1$ in meters per second.\n- Diffusion coefficient $D$ in square meters per second is constant.\n- Reaction rate $k(x) = k_0 + k_1\\,\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)$ with $k_0$ in per second and $k_1$ in per second.\n- Initial condition $C(x,0) = C_0\\,\\left[1 + a\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\right]$ with $C_0$ an arbitrary concentration unit and $a$ dimensionless amplitude. Since the requested outputs are error norms and ratios, they are dimensionless; no physical units are required in the final outputs.\n\nTime parameters:\n- Final time $T$ in seconds and splitting time step $\\Delta t$ in seconds will be specified per test case. Ensure that $T$ is an integer multiple of $\\Delta t$.\n\nTest Suite:\nImplement your program to evaluate the following four test cases and aggregate the results:\n- Case $1$ (general variable-coefficient ADR):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_1$ at $t = T$ as a decimal.\n- Case $2$ (order verification via halving the time step):\n  - Same parameters as Case $1$.\n  - Compute $E_{\\Delta t}$ for $\\Delta t = T/40$ and $E_{\\Delta t/2}$ for $\\Delta t = T/80$, and output the ratio $R = E_{\\Delta t}/E_{\\Delta t/2}$ as a decimal to assess first-order global accuracy.\n- Case $3$ (no diffusion):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.0$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_3$ at $t = T$ as a decimal.\n- Case $4$ (constant coefficients, expected near-zero splitting error):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.0$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.0$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_4$ at $t = T$ as a decimal.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results from the four test cases as a comma-separated list enclosed in square brackets, in the order $[E_1, R, E_3, E_4]$. For example, the program must print one line exactly of the form $[E_1,R,E_3,E_4]$ with no additional text. All outputs are dimensionless decimals.",
            "solution": "#### Task 1: Derivation of Lie Splitting and Error Analysis\n\nThe governing Advection-Diffusion-Reaction (ADR) equation is\n$$\n\\frac{\\partial C}{\\partial t} = \\mathcal{A}C + \\mathcal{D}C + \\mathcal{R}C = (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})C\n$$\nwhere $\\mathcal{A} = -v(x)\\partial_x$, $\\mathcal{D} = D\\partial_{xx}$, and $\\mathcal{R} = -k(x)$ are linear operators representing advection, diffusion, and reaction, respectively. Let $\\mathcal{L} = \\mathcal{A} + \\mathcal{D} + \\mathcal{R}$ be the total evolution operator.\n\nThe formal solution to this linear PDE over a time interval $\\Delta t$ can be expressed using the concept of a semigroup, represented by the operator exponential:\n$$\nC(t+\\Delta t) = e^{\\Delta t \\mathcal{L}} C(t) = e^{\\Delta t (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})} C(t)\n$$\nOperator splitting methods approximate the exponential of a sum of operators by a product of exponentials of the individual operators. The first-order Lie splitting scheme, for the specified order of advection, then diffusion, then reaction, approximates the exact solution propagator $e^{\\Delta t \\mathcal{L}}$ by the composition of propagators for each subproblem:\n$$\n\\Phi_{\\text{split}}(\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}}\n$$\nApplying this to the solution at time $t$ gives the approximate solution at $t+\\Delta t$:\n$$\nC_{\\text{split}}(t+\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} C(t)\n$$\nThis corresponds to solving three separate, simpler PDEs sequentially over the time step $\\Delta t$:\n1.  **Advection**: $\\frac{\\partial C^*}{\\partial t} = \\mathcal{A}C^*$, solved from $C(t)$ to get $C^*(\\Delta t) = e^{\\Delta t \\mathcal{A}}C(t)$.\n2.  **Diffusion**: $\\frac{\\partial C^{**}}{\\partial t} = \\mathcal{D}C^{**}$, solved from $C^*(\\Delta t)$ to get $C^{**}(\\Delta t) = e^{\\Delta t \\mathcal{D}}C^*(\\Delta t)$.\n3.  **Reaction**: $\\frac{\\partial C^{*** }}{\\partial t} = \\mathcal{R}C^{*** }$, solved from $C^{**}(\\Delta t)$ to get $C^{***}(\\Delta t) = e^{\\Delta t \\mathcal{R}}C^{**}(\\Delta t)$.\nThe final result is $C_{\\text{split}}(t+\\Delta t) = C^{***}(\\Delta t)$.\n\nThe local truncation error is the difference between the action of the split and exact propagators. To find the leading-order term, we expand both propagators in a Taylor series in $\\Delta t$.\n\nThe exact propagator expands as:\n$$\ne^{\\Delta t \\mathcal{L}} = I + \\Delta t \\mathcal{L} + \\frac{(\\Delta t \\mathcal{L})^2}{2!} + O(\\Delta t^3)\n$$\n$$\ne^{\\Delta t (\\mathcal{A}+\\mathcal{D}+\\mathcal{R})} = I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}+\\mathcal{D}+\\mathcal{R})^2 + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) + O(\\Delta t^3)\n$$\nThe split propagator is a product of exponentials:\n$$\ne^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} = \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t \\mathcal{D} + \\frac{\\Delta t^2}{2}\\mathcal{D}^2\\right) \\left(I + \\Delta t \\mathcal{A} + \\frac{\\Delta t^2}{2}\\mathcal{A}^2\\right) + O(\\Delta t^3)\n$$\nExpanding this product and retaining terms up to order $\\Delta t^2$:\n$$\n= \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t(\\mathcal{A}+\\mathcal{D}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA}\\right)\\right) + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD} + \\frac{\\mathcal{R}^2}{2}\\right) + O(\\Delta t^3)\n$$\nThe local error operator is the difference, $\\Phi_{\\text{split}}(\\Delta t) - e^{\\Delta t \\mathcal{L}}$. The terms of order $I$ and $\\Delta t$ cancel exactly. The difference of the $\\Delta t^2$ terms is:\n$$\n\\Delta t^2 \\left[ \\left(\\frac{\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD}\\right) - \\frac{1}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (2\\mathcal{DA} - (\\mathcal{AD}+\\mathcal{DA})) + (2\\mathcal{RA} - (\\mathcal{AR}+\\mathcal{RA})) + (2\\mathcal{RD} - (\\mathcal{DR}+\\mathcal{RD})) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (\\mathcal{DA} - \\mathcal{AD}) + (\\mathcal{RA} - \\mathcal{AR}) + (\\mathcal{RD} - \\mathcal{DR}) \\right]\n$$\nThis expression is simplified using the commutator notation $[\\mathcal{X}, \\mathcal{Y}] = \\mathcal{XY} - \\mathcal{YX}$:\n$$\n\\text{Error Term} = \\frac{\\Delta t^2}{2} \\left( [\\mathcal{D}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{D}] \\right)\n$$\nThe local truncation error is of order $O(\\Delta t^2)$. Since approximately $N_{\\text{steps}} = T/\\Delta t$ steps are taken to reach the final time $T$, the global error accumulates to be of order $N_{\\text{steps}} \\times O(\\Delta t^2) \\sim (T/\\Delta t) \\times O(\\Delta t^2) \\sim O(\\Delta t)$. The Lie splitting is therefore a first-order accurate method. The splitting error vanishes if and only if all the operators commute, i.e., $[\\mathcal{D}, \\mathcal{A}]=0$, $[\\mathcal{R}, \\mathcal{A}]=0$, and $[\\mathcal{R}, \\mathcal{D}]=0$. This occurs when the coefficients $v(x)$ and $k(x)$ are constants.\n\n#### Task 2: Numerical Implementation Strategy\n\nThe numerical implementation follows the derived splitting scheme on a discrete grid and compares its accuracy against a reference solution.\n\n1.  **Discretization**: The spatial domain $x \\in [0, L]$ is discretized into $N$ uniformly spaced grid points $x_j = j L/N$ for $j=0, \\dots, N-1$. The concentration field $C(x,t)$ becomes a vector $\\mathbf{C}(t)$ of length $N$, where $C_j(t) \\approx C(x_j, t)$. The functions $v(x)$ and $k(x)$ become vectors $\\mathbf{v}$ and $\\mathbf{k}$.\n\n2.  **Reference Solution**: A high-accuracy reference solution $\\mathbf{C}_{\\text{ref}}(T)$ is computed by solving the fully-coupled semi-discrete ODE system,\n    $$\n    \\frac{d\\mathbf{C}}{dt} = \\mathcal{L}\\mathbf{C} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C}) + D (\\partial_{xx} \\mathbf{C}) - \\mathbf{k} \\odot \\mathbf{C}\n    $$\n    from $t=0$ to $t=T$. The spatial derivatives $\\partial_x \\mathbf{C}$ and $\\partial_{xx} \\mathbf{C}$ are computed spectrally using the Fast Fourier Transform (FFT), which is highly accurate for periodic functions. The integration in time is performed using a high-order adaptive-step solver, specifically `scipy.integrate.solve_ivp` with the `DOP853` method and stringent error tolerances (e.g., `rtol=1e-12`, `atol=1e-14`).\n\n3.  **Split Solution**: The split solution $\\mathbf{C}_{\\text{split}}(T)$ is computed by iterating $N_{\\text{steps}} = T/\\Delta t$ times. In each step from $t$ to $t+\\Delta t$:\n    -   **Advection Step**: The ODE system $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C})$ is solved over one time step $\\Delta t$, again using `solve_ivp` with `DOP853` and tight tolerances. The spectral method is used for $\\partial_x \\mathbf{C}$.\n    -   **Diffusion Step**: The system $\\frac{d\\mathbf{C}}{dt} = D (\\partial_{xx} \\mathbf{C})$ is solved exactly in Fourier space. Taking the FFT of the state vector $\\mathbf{C}$, we get $\\hat{\\mathbf{C}}$. The ODE becomes $\\frac{d\\hat{C}_m}{dt} = D(i\\omega_m)^2 \\hat{C}_m = -D\\omega_m^2 \\hat{C}_m$ for each Fourier mode $m$ with angular wavenumber $\\omega_m$. The exact solution is $\\hat{C}_m(\\Delta t) = \\hat{C}_m(0) e^{-D\\omega_m^2 \\Delta t}$. The state vector is updated by `ifft(fft(C) * exp(-D*omega**2*dt))`.\n    -   **Reaction Step**: The system $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{k} \\odot \\mathbf{C}$ is a set of uncoupled ODEs, $dC_j/dt = -k_j C_j$. The solution is $C_j(\\Delta t) = C_j(0) e^{-k_j \\Delta t}$. The state vector is updated by componentwise multiplication: $\\mathbf{C} \\leftarrow \\mathbf{C} \\odot e^{-\\mathbf{k}\\Delta t}$.\n\n4.  **Error Calculation and Test Cases**:\n    -   The relative $\\ell^2$-error between the split and reference solutions is computed at $T$.\n    -   **Case 1** measures the error for a general ADR problem with variable coefficients.\n    -   **Case 2** verifies the first-order convergence of the splitting method. The error $E$ is proportional to $\\Delta t$, so the ratio of errors $E_{\\Delta t}/E_{\\Delta t/2}$ should be approximately $2$.\n    -   **Case 3** ($D=0$) isolates the splitting error from the non-commuting advection and reaction operators ($[\\mathcal{R}, \\mathcal{A}] \\neq 0$).\n    -   **Case 4** ($v_1=0, k_1=0$) makes the advection and reaction coefficients constant. As shown in the derivation, all commutators become zero. The theoretical splitting error is zero. The measured error $E_4$ will be a small number reflecting the numerical precision of the ODE solvers and floating-point arithmetic, demonstrating the correctness of the commutator analysis.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the ADR equation using Lie splitting and compares it to a reference\n    solution to quantify splitting error for four different test cases.\n    \"\"\"\n\n    def run_simulation(L, N, v0, v1, D, k0, k1, C0, a, T, dt, use_split_method):\n        \"\"\"\n        Runs a single simulation, either the full reference or the split method.\n        \"\"\"\n        # 1. Setup grid, initial condition, and parameters\n        x = np.linspace(0, L, N, endpoint=False)\n        v = v0 + v1 * np.sin(2 * np.pi * x / L)\n        k_rate = k0 + k1 * np.cos(2 * np.pi * x / L)\n        C_initial = C0 * (1 + a * np.sin(2 * np.pi * x / L))\n\n        # Wavenumbers for spectral derivatives\n        # fftfreq returns frequencies in cycles per unit of sample spacing (dx=L/N)\n        # We convert to angular wavenumbers (radians per unit length)\n        dx = L / N\n        angular_wavenumbers = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define derivative functions and RHS of the full PDE\n        def d_dx(C_vec):\n            return np.real(ifft(1j * angular_wavenumbers * fft(C_vec)))\n\n        def d2_dx2(C_vec):\n            return np.real(ifft(-angular_wavenumbers**2 * fft(C_vec)))\n\n        def full_rhs(t, C_vec):\n            dC_advection = -v * d_dx(C_vec)\n            dC_diffusion = D * d2_dx2(C_vec)\n            dC_reaction = -k_rate * C_vec\n            return dC_advection + dC_diffusion + dC_reaction\n\n        # 3. Compute solution\n        if not use_split_method:\n            # High-accuracy reference solution\n            sol = solve_ivp(full_rhs, (0, T), C_initial, method='DOP853', rtol=1e-12, atol=1e-14)\n            return sol.y[:, -1]\n        else:\n            # Lie splitting solution\n            def advection_rhs(t, C_vec):\n                return -v * d_dx(C_vec)\n            \n            C = C_initial.copy()\n            num_steps = int(round(T / dt))\n\n            for _ in range(num_steps):\n                # Step 1: Advection substep\n                sol_adv = solve_ivp(advection_rhs, (0, dt), C, method='DOP853', rtol=1e-12, atol=1e-12)\n                C = sol_adv.y[:, -1]\n\n                # Step 2: Diffusion substep (exact in Fourier space)\n                C_hat = fft(C)\n                C_hat *= np.exp(-D * angular_wavenumbers**2 * dt)\n                C = np.real(ifft(C_hat))\n\n                # Step 3: Reaction substep (exact pointwise)\n                C *= np.exp(-k_rate * dt)\n            \n            return C\n\n    def calculate_error(params, dt):\n        \"\"\"Helper to compute error for a given dt.\"\"\"\n        C_ref = run_simulation(**params, dt=dt, use_split_method=False)\n        C_split = run_simulation(**params, dt=dt, use_split_method=True)\n        error = np.linalg.norm(C_split - C_ref) / np.linalg.norm(C_ref)\n        return error\n\n    results = []\n\n    # --- Test Case 1 ---\n    # General ADR with variable coefficients\n    params1 = {'L': 1.0, 'N': 128, 'v0': 0.5, 'v1': 0.25, 'D': 0.001, 'k0': 1.0, 'k1': 0.5, 'C0': 1.0, 'a': 0.5, 'T': 0.1}\n    dt1 = params1['T'] / 40.0\n    E1 = calculate_error(params1, dt1)\n    results.append(E1)\n\n    # --- Test Case 2 ---\n    # Order verification by halving the time step\n    params2 = params1\n    dt_large = params2['T'] / 40.0\n    dt_small = params2['T'] / 80.0\n    E_dt = calculate_error(params2, dt_large)\n    E_dthalf = calculate_error(params2, dt_small)\n    R = E_dt / E_dthalf\n    results.append(R)\n\n    # --- Test Case 3 ---\n    # No diffusion (D=0)\n    params3 = params1.copy()\n    params3['D'] = 0.0\n    dt3 = params3['T'] / 40.0\n    E3 = calculate_error(params3, dt3)\n    results.append(E3)\n\n    # --- Test Case 4 ---\n    # Constant coefficients (v1=0, k1=0), commuting operators\n    params4 = params1.copy()\n    params4['v1'] = 0.0\n    params4['k1'] = 0.0\n    dt4 = params4['T'] / 40.0\n    E4 = calculate_error(params4, dt4)\n    results.append(E4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from linear Partial Differential Equations to nonlinear reaction systems, this exercise tackles a common geochemical scenario: mineral precipitation. Here, you will implement and compare the two most common operator splitting strategies, the Sequential Non-Iterative Approach (SNIA) and the Sequential Iterative Approach (SIA). This practice is designed to highlight the practical differences in accuracy and stability between these methods when dealing with the stiff, nonlinear kinetics typical of reactive transport problems. ",
            "id": "4094620",
            "problem": "Construct a zero-dimensional batch-reactor benchmark to evaluate operator splitting methods in reactive transport for carbonate precipitation. The aqueous system contains dissolved calcium and carbonate that can precipitate as a solid carbonate mineral when supersaturation occurs. The governing evolution is based on conservation of mass and a precipitation rate law derived from mass action. The objective is to compute the mass of solid carbonate formed and to compare sequential operator-splitting schemes against a monolithic unsplit reference.\n\nAssumptions and definitions:\n- The reactor volume is constant and equal to $1$ liter, so species amounts in moles equal concentrations in $\\mathrm{mol/L}$.\n- Let $C_{\\mathrm{Ca}}(t)$ and $C_{\\mathrm{CO_3}}(t)$ denote the dissolved calcium and carbonate concentrations, respectively, and $S(t)$ denote the cumulative precipitated solid carbonate amount (in $\\mathrm{mol/L}$).\n- Precipitation kinetics follow a mass-action rate:\n  $$ r(t) \\;=\\; k \\,\\max\\!\\left(0,\\, C_{\\mathrm{Ca}}(t)\\,C_{\\mathrm{CO_3}}(t) \\;-\\; K_{\\mathrm{sp}} \\right), $$\n  where $k$ has units $\\mathrm{L\\,mol^{-1}\\,s^{-1}}$ and $K_{\\mathrm{sp}}$ is the solubility product in $\\mathrm{(mol/L)^2}$. Activities are assumed equal to concentrations (unit activity coefficients).\n- Mass balance in the batch reactor with a time-dependent source term for carbonate is\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} \\;=\\; J_{\\mathrm{Ca}}(t) \\;-\\; r(t), \\qquad \\frac{dC_{\\mathrm{CO_3}}}{dt} \\;=\\; J_{\\mathrm{CO_3}}(t) \\;-\\; r(t), \\qquad \\frac{dS}{dt} \\;=\\; r(t). $$\n- There is no calcium source, so $J_{\\mathrm{Ca}}(t) \\equiv 0$. The carbonate source is a square pulse defined by\n  $$ J_{\\mathrm{CO_3}}(t) \\;=\\; \\begin{cases}\n  J_0, & 0 \\le t < t_{\\mathrm{inj}},\\\\\n  0, & t \\ge t_{\\mathrm{inj}},\n  \\end{cases} $$\n  with constant injection rate $J_0$ over a duration $t_{\\mathrm{inj}}$.\n\nOperator splitting methods to be implemented:\n- Sequential Non-Iterative Approach (SNIA): In each time step of size $\\Delta t$, first apply the transport operator (the source term) over $\\Delta t$, and then apply the reaction operator over $\\Delta t$ using an explicit forward Euler update with $r$ evaluated at the transported state. During the reaction update, enforce non-negativity by capping the consumption so that neither $C_{\\mathrm{Ca}}$ nor $C_{\\mathrm{CO_3}}$ becomes negative within the step. This yields a first-order accurate splitting in time.\n- Sequential Iterative Approach (SIA): In each time step of size $\\Delta t$, iterate between transport and reaction within the step to reduce the splitting error. Implement a fixed-point (Picard) iteration where the within-step update satisfies\n  $$ C^{(m+1)}_{\\mathrm{Ca}} \\;=\\; C^{n}_{\\mathrm{Ca}} \\;+\\; \\Delta t\\,J_{\\mathrm{Ca}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ C^{(m+1)}_{\\mathrm{CO_3}} \\;=\\; C^{n}_{\\mathrm{CO_3}} \\;+\\; \\Delta t\\,J_{\\mathrm{CO_3}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ S^{(m+1)} \\;=\\; S^{n} \\;+\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  with suitable capping to enforce non-negativity within each iteration and a fixed maximum number of iterations per step. Use the last iterate as the step update.\n- Monolithic unsplit reference: Solve the coupled ordinary differential equations for $C_{\\mathrm{Ca}}(t)$, $C_{\\mathrm{CO_3}}(t)$, and $S(t)$ over the time interval $[0,T]$ using an implicit stiff solver to high accuracy. The monolithic solution is taken as the reference for comparison.\n\nFundamental base for derivation:\n- Conservation of mass for each component with sources and sinks.\n- Mass-action kinetics for precipitation rate with a solubility product threshold.\n- Numerical operator splitting as a decomposition of the evolution operator into transport and reaction sub-operators.\n\nYour program must implement the three approaches above and compute the total precipitated solid at the final time $t=T$ for the following test suite. All parameters are in SI-consistent units for chemistry: concentrations in $\\mathrm{mol/L}$, time in $\\mathrm{s}$, and the solubility product $K_{\\mathrm{sp}}$ in $\\mathrm{(mol/L)^2}$. Report all requested outputs in $\\mathrm{mol/L}$.\n\nTest suite (three cases):\n- Case A (precipitation clearly triggered):\n  - $C_{\\mathrm{Ca}}(0) = 5\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 2\\times 10^{-3}$, $t_{\\mathrm{inj}} = 2$, $T=10$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n- Case B (near-equilibrium start, slight supersaturation pulse):\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = K_{\\mathrm{sp}}/C_{\\mathrm{Ca}}(0) = 3.3\\times 10^{-6}$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 5\\times 10^{-7}$, $t_{\\mathrm{inj}} = 1$, $T=10$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n- Case C (no precipitation expected):\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-6}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 1\\times 10^{-5}$, $t_{\\mathrm{inj}} = 0.1$, $T=5$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n\nAlgorithmic details to enforce:\n- In SNIA and SIA, during any reaction update over a time step of size $\\Delta t$, the consumption $\\Delta c = r\\,\\Delta t$ must be capped as $\\Delta c \\le \\min\\!\\left(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}\\right)$ to avoid negative concentrations. Use the rate law as stated above with $r \\ge 0$ and $r=0$ if undersaturated.\n- In SIA, use a fixed number of iterations per time step equal to $8$ and a convergence check with a tolerance of $10^{-12}$ in the max-norm; terminate early if converged.\n- In the monolithic reference, use a stiff implicit integrator with tight tolerances to approximate the exact solution over $[0,T]$.\n\nRequired outputs for each case:\n- The program must compute five floats for each case:\n  - $S_{\\mathrm{ref}}(T)$ from the monolithic unsplit reference,\n  - $S_{\\mathrm{SNIA}}(T)$ from the Sequential Non-Iterative Approach,\n  - $S_{\\mathrm{SIA}}(T)$ from the Sequential Iterative Approach,\n  - $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$,\n  - $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$.\n- Express each value in $\\mathrm{mol/L}$ rounded to eight decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be formed by concatenating, in order, the five rounded floats for Case A, then for Case B, then for Case C. For example, your output must look like\n  $$ [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10},x_{11},x_{12},x_{13},x_{14},x_{15}] $$\n  where each $x_i$ is a decimal with eight digits after the decimal point, representing the required quantities in $\\mathrm{mol/L}$ for the three cases.",
            "solution": "The solution is implemented by creating three distinct numerical solvers as specified: a high-accuracy monolithic reference solver, a Sequential Non-Iterative Approach (SNIA) solver, and a Sequential Iterative Approach (SIA) solver.\n\n**1. Monolithic (Reference) Solution**\nThe reference solution is obtained by solving the coupled system of ODEs simultaneously. Given the potential for stiffness from fast reaction kinetics, a stiff implicit solver is appropriate. The system is defined as $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$, where $\\mathbf{y} = [C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}, S]^T$. The vector function $\\mathbf{f}$ is:\n$$ \\mathbf{f}(t, \\mathbf{y}) = \\begin{bmatrix} -r(y_1, y_2) \\\\ J_{\\mathrm{CO_3}}(t) - r(y_1, y_2) \\\\ r(y_1, y_2) \\end{bmatrix} $$\nwhere $y_1=C_{\\mathrm{Ca}}$ and $y_2=C_{\\mathrm{CO_3}}$. This system is integrated using a high-order stiff solver (e.g., `scipy.integrate.solve_ivp` with the `BDF` method) with tight error tolerances to serve as the ground truth.\n\n**2. Sequential Non-Iterative Approach (SNIA)**\nThis is a first-order operator splitting method. Over each time step $\\Delta t$, the transport and reaction operators are applied sequentially.\n- **Transport Step:** First, account for external source terms. Let $\\mathbf{C}^n = [C_{\\mathrm{Ca}}^n, C_{\\mathrm{CO_3}}^n]^T$.\n  $$ \\mathbf{C}^* = \\mathbf{C}^n + \\Delta t \\, \\mathbf{J}(t_n) $$\n  where $\\mathbf{J}(t_n) = [0, J_{\\mathrm{CO_3}}(t_n)]^T$.\n- **Reaction Step:** Next, solve the reaction part using the state from the transport step, $\\mathbf{C}^*$, with an explicit Euler update.\n  $$ r^* = k \\cdot \\max(0, C_{\\mathrm{Ca}}^* C_{\\mathrm{CO_3}}^* - K_{\\mathrm{sp}}) $$\n  The potential amount of precipitate formed is $\\Delta S = r^* \\Delta t$. This amount is capped to ensure non-negativity of concentrations:\n  $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S, C_{\\mathrm{Ca}}^*, C_{\\mathrm{CO_3}}^*) $$\n  The final state for the step is then calculated by subtracting this capped amount from the aqueous species and adding it to the solid.\n\n**3. Sequential Iterative Approach (SIA)**\nSIA reduces splitting error by iterating within a time step. The specified Picard iteration is used to solve the implicit system. For each time step from $t_n$ to $t_{n+1}$:\nThe iteration scheme starts with an initial guess $\\mathbf{y}^{(0)} = \\mathbf{y}^n$. For iteration $m$:\n1.  Calculate the reaction rate $r^{(m)}$ using the previous iterate's concentrations, $(C_{\\mathrm{Ca}}^{(m)}, C_{\\mathrm{CO_3}}^{(m)})$.\n2.  The potential change in solid is $\\Delta S_{\\mathrm{potential}} = r^{(m)} \\Delta t$.\n3.  The amount of reactants available is based on the state at the beginning of the step, $\\mathbf{y}^n$, plus transport effects. The total available Ca is $C_{\\mathrm{Ca}}^n$ and CO3 is $C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)$.\n4.  The change in solid is capped by these available amounts:\n    $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S_{\\mathrm{potential}}, \\, C_{\\mathrm{Ca}}^n, \\, C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)) $$\n5.  The state for the next iterate, $(m+1)$, is updated based on the state at the beginning of the time step, $n$, and the capped change:\n    $$ C_{\\mathrm{Ca}}^{(m+1)} = C_{\\mathrm{Ca}}^n - \\Delta S_{\\mathrm{capped}} $$\n    $$ C_{\\mathrm{CO_3}}^{(m+1)} = (C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)) - \\Delta S_{\\mathrm{capped}} $$\n    $$ S^{(m+1)} = S^n + \\Delta S_{\\mathrm{capped}} $$\n6.  This process is repeated for a fixed number of iterations or until the change between iterates is below a tolerance. The final iterate becomes the solution $\\mathbf{y}^{n+1}$.\n\nThe implementation will process each of the three test cases, compute the required outputs, and format them as specified.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes and compares operator splitting methods for a carbonate precipitation benchmark.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (precipitation clearly triggered)\n        {\n            \"name\": \"A\",\n            \"C_Ca0\": 5e-3,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 2e-3,\n            \"t_inj\": 2.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case B (near-equilibrium start, slight supersaturation pulse)\n        {\n            \"name\": \"B\",\n            \"C_Ca0\": 1e-3,\n            \"C_CO30\": 3.3e-9 / 1e-3,  # K_sp / C_Ca(0)\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 5e-7,\n            \"t_inj\": 1.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case C (no precipitation expected)\n        {\n            \"name\": \"C\",\n            \"C_Ca0\": 1e-6,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 1e-5,\n            \"t_inj\": 0.1,\n            \"T\": 5.0,\n            \"dt\": 0.05,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        C_Ca0, C_CO30, S0 = case[\"C_Ca0\"], case[\"C_CO30\"], case[\"S0\"]\n        K_sp, k = case[\"K_sp\"], case[\"k\"]\n        J0, t_inj = case[\"J0\"], case[\"t_inj\"]\n        T, dt = case[\"T\"], case[\"dt\"]\n        \n        def rate_law(C_Ca, C_CO3, k_val, K_sp_val):\n            ion_product = C_Ca * C_CO3\n            if ion_product > K_sp_val:\n                return k_val * (ion_product - K_sp_val)\n            return 0.0\n\n        # --- 1. Monolithic Unsplit Reference Solution ---\n        def ode_system(t, y):\n            C_Ca, C_CO3, S = y\n            J_CO3 = J0 if t  t_inj else 0.0\n            r = rate_law(C_Ca, C_CO3, k, K_sp)\n            dC_Ca_dt = -r\n            dC_CO3_dt = J_CO3 - r\n            dS_dt = r\n            return [dC_Ca_dt, dC_CO3_dt, dS_dt]\n\n        y0 = [C_Ca0, C_CO30, S0]\n        sol = solve_ivp(\n            ode_system, \n            [0, T], \n            y0, \n            method='BDF', \n            rtol=1e-12, \n            atol=1e-15\n        )\n        S_ref = sol.y[2, -1]\n\n        # --- 2. Sequential Non-Iterative Approach (SNIA) ---\n        C_Ca, C_CO3, S = C_Ca0, C_CO30, S0\n        num_steps = int(round(T / dt))\n        time_points = np.linspace(0, T, num_steps + 1)\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            # Transport step\n            J_CO3_step = J0 if t  t_inj else 0.0\n            C_CO3_after_transport = C_CO3 + J_CO3_step * dt\n            C_Ca_after_transport = C_Ca  # J_Ca is 0\n\n            # Reaction step\n            r = rate_law(C_Ca_after_transport, C_CO3_after_transport, k, K_sp)\n            delta_s = r * dt\n            \n            # Capping to enforce non-negativity\n            capped_delta_s = min(delta_s, C_Ca_after_transport, C_CO3_after_transport)\n            \n            # Update state\n            C_Ca = C_Ca_after_transport - capped_delta_s\n            C_CO3 = C_CO3_after_transport - capped_delta_s\n            S = S + capped_delta_s\n        \n        S_snia = S\n\n        # --- 3. Sequential Iterative Approach (SIA) ---\n        C_Ca_n, C_CO3_n, S_n = C_Ca0, C_CO30, S0\n        max_iter = 8\n        tol = 1e-12\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            C_Ca_start, C_CO3_start, S_start = C_Ca_n, C_CO3_n, S_n\n            \n            # Initial guess for the iteration (state at n)\n            y_m = np.array([C_Ca_start, C_CO3_start, S_start])\n\n            J_CO3_step = J0 if t  t_inj else 0.0\n\n            for _ in range(max_iter):\n                y_prev_iter = y_m.copy()\n                C_Ca_m_iter, C_CO3_m_iter, _ = y_prev_iter\n\n                r_m = rate_law(C_Ca_m_iter, C_CO3_m_iter, k, K_sp)\n                delta_s_potential = r_m * dt\n                \n                # Budgets are based on state 'n' plus transport\n                budget_Ca = C_Ca_start\n                budget_CO3 = C_CO3_start + J_CO3_step * dt\n                \n                capped_delta_s = min(delta_s_potential, budget_Ca, budget_CO3)\n                \n                # Update to get next iterate (m+1) based on state 'n'\n                C_Ca_new = C_Ca_start - capped_delta_s\n                C_CO3_new = budget_CO3 - capped_delta_s\n                S_new = S_start + capped_delta_s\n                \n                y_m = np.array([C_Ca_new, C_CO3_new, S_new])\n                \n                if np.max(np.abs(y_m - y_prev_iter))  tol:\n                    break\n            \n            C_Ca_n, C_CO3_n, S_n = y_m\n        S_sia = S_n\n        \n        error_snia = abs(S_snia - S_ref)\n        error_sia = abs(S_sia - S_ref)\n\n        all_results.extend([S_ref, S_snia, S_sia, error_snia, error_sia])\n\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The devil is in the details, and for operator splitting, one of the most critical is the correct handling of boundary conditions. This practice focuses on a finite volume discretization and challenges you to derive how a Dirichlet boundary condition is incorporated into a transport substep. You will then reason about how to preserve flux continuity during the reaction substep, a crucial step for ensuring global mass conservation in a numerical model. ",
            "id": "4094643",
            "problem": "A one-dimensional reactive transport of an aqueous solute is modeled by the species conservation law on the interval adjacent to the inflow boundary at position $x=0$,\n$\\frac{\\partial C}{\\partial t} + \\frac{\\partial J}{\\partial x} = R(C)$, with advective–diffusive flux $J = u\\,C - D\\,\\frac{\\partial C}{\\partial x}$ and a first-order reaction $R(C) = -k\\,C$. Consider the Sequential Non-Iterative Approach (SNIA), in which one advances a full time step by first solving the transport-only problem ($R=0$) over a time increment $\\Delta t$, followed by the reaction-only problem (no transport) over the same time increment $\\Delta t$. The spatial discretization is finite volume on a uniform mesh with cell width $\\Delta x$, and the first control volume (cell $1$) is adjacent to the inflow boundary at $x=0$. The boundary condition at $x=0$ during the transport substep is a Dirichlet inflow concentration $C(0,t)=C_b$. The flux discretization is first-order upwind for advection and centered differences for diffusion. Let $C_j^n$ denote the cell-average concentration in cell $j$ at time $t^n$, and let $C_j^{*}$ denote the intermediate concentration in cell $j$ at the end of the transport substep.\n\nStart from the conservative finite-volume balance for cell $1$ and derive the explicit Euler update that yields $C_1^{*}$ in terms of $C_1^n$, $C_2^n$, $C_b$, $u$, $D$, $\\Delta x$, and $\\Delta t$, making explicit how the Dirichlet boundary enters the left-face flux. Then, using the principle that the reaction substep contains no transport, formulate how the boundary condition is to be applied during the reaction substep so that the boundary flux is preserved (i.e., no artificial boundary mass transfer occurs during reaction). Using these results, compute the total moles per unit area that enter the domain through $x=0$ over the full time step, defined as $F = J_T\\,\\Delta t$, where $J_T$ is the left-face flux at the end of the transport substep.\n\nUse the following physically plausible parameters: $u=1.0\\times 10^{-5}\\ \\text{m s}^{-1}$, $D=1.0\\times 10^{-9}\\ \\text{m}^2\\ \\text{s}^{-1}$, $k=2.0\\times 10^{-1}\\ \\text{s}^{-1}$, $\\Delta x=1.0\\times 10^{-3}\\ \\text{m}$, $\\Delta t=5.0\\ \\text{s}$, $C_b=1.0\\ \\text{mol m}^{-3}$, $C_1^n=0$, and $C_2^n=0$. For the transport substep, define the left-face flux at $x=0$ using the boundary value $C_b$ and the cell-center value $C_1$ through a one-sided gradient over a half-cell, and define the right-face flux at $x=\\Delta x$ using the upwind value for advection and a centered gradient for diffusion. For the reaction substep, enforce the boundary condition that preserves the transport flux continuity. Finally, report the numerical value of $F$ in $\\text{mol m}^{-2}$, rounded to four significant figures. Do not include units in your final boxed answer.",
            "solution": "### Part 1: Derivation of the Transport Update for $C_1^*$\nThe SNIA method first solves the transport-only problem:\n$$\n\\frac{\\partial C}{\\partial t} + \\frac{\\partial J}{\\partial x} = 0\n$$\nThe conservative finite volume formulation for cell $j$ over a time step $\\Delta t$ using an explicit Euler time integration is:\n$$\n\\frac{C_j^* - C_j^n}{\\Delta t} \\Delta x = J_{j-1/2}^n - J_{j+1/2}^n\n$$\nwhere $C_j^*$ is the intermediate concentration after the transport substep. For cell $1$, which spans from $x=0$ to $x=\\Delta x$, the update equation is:\n$$\nC_1^* = C_1^n + \\frac{\\Delta t}{\\Delta x} (J_{1/2}^n - J_{3/2}^n)\n$$\nwhere $J_{1/2}^n$ is the flux at the left face ($x=0$) and $J_{3/2}^n$ is the flux at the right face ($x=\\Delta x$). We now derive the expressions for these fluxes.\n\n**Left-face flux $J_{1/2}^n$ at $x=0$:**\nThe flux is $J = uC - D \\frac{\\partial C}{\\partial x}$.\n- Advective part: The flow is into the domain ($u0$), so first-order upwinding uses the upstream concentration, which is the boundary value $C_b$. The advective flux is $uC_b$.\n- Diffusive part: The gradient is approximated using a one-sided difference between the boundary value $C_b$ and the first cell-center value $C_1^n$ over a half-cell distance $\\Delta x/2$.\n$$\n\\left.\\frac{\\partial C}{\\partial x}\\right|_{x=0} \\approx \\frac{C_1^n - C(0,t^n)}{\\Delta x/2} = \\frac{C_1^n - C_b}{\\Delta x/2}\n$$\nThe diffusive flux is $-D (\\frac{C_1^n - C_b}{\\Delta x/2}) = 2D \\frac{C_b - C_1^n}{\\Delta x}$.\nCombining terms, the total flux at the left face is:\n$$\nJ_{1/2}^n = uC_b + 2D \\frac{C_b - C_1^n}{\\Delta x}\n$$\nThis explicitly shows how the Dirichlet boundary concentration $C_b$ enters the left-face flux calculation.\n\n**Right-face flux $J_{3/2}^n$ at $x=\\Delta x$:**\nThis face is between cell $1$ and cell $2$.\n- Advective part: Since $u0$, first-order upwinding uses the concentration from the upstream cell, which is cell $1$. The advective flux is $uC_1^n$.\n- Diffusive part: The gradient is approximated by a centered difference between the adjacent cell centers, $C_1^n$ and $C_2^n$.\n$$\n\\left.\\frac{\\partial C}{\\partial x}\\right|_{x=\\Delta x} \\approx \\frac{C_2^n - C_1^n}{\\Delta x}\n$$\nThe diffusive flux is $-D \\frac{C_2^n - C_1^n}{\\Delta x}$.\nCombining terms, the total flux at the right face is:\n$$\nJ_{3/2}^n = uC_1^n - D \\frac{C_2^n - C_1^n}{\\Delta x}\n$$\nSubstituting these flux expressions into the update equation for $C_1^*$ gives the final derived form for the explicit Euler update.\n\n### Part 2: Boundary Condition for the Reaction Substep\nThe second step in the SNIA scheme is to solve the reaction-only problem over $\\Delta t$, using $C^*$ as the initial condition. The governing equation for this substep is:\n$$\n\\frac{\\partial C}{\\partial t} = R(C) = -kC\n$$\nThis is a set of uncoupled ordinary differential equations (ODEs) for each cell's average concentration: $\\frac{dC_j}{dt} = -kC_j$. The principle of operator splitting is that this substep involves no transport. There is no spatial coupling and, critically, no flux across any cell boundaries. To preserve transport flux continuity, the reaction step must not introduce any artificial flux at the boundary. The only way to achieve this is to enforce a zero-flux condition at the boundary during this substep. In practice, because the ODEs are solved independently for each cell, this zero-flux condition is implicitly satisfied; no mechanism for transport exists in this step of the algorithm.\n\n### Part 3: Calculation of Total Moles Transferred, $F$\nThe problem asks for the total moles per unit area that enter the domain over the full time step, defined as $F = J_T\\,\\Delta t$. For the SNIA scheme, the reaction substep is local and involves no transport, so the total transfer is determined entirely by the transport substep. For an explicit Euler time integration, the flux is assumed to be constant over the time step $\\Delta t$ and is evaluated using the state at the beginning of the step, $t^n$. Therefore, the total moles transferred is the product of the left-face flux at time $t^n$, $J_{1/2}^n$, and the time step duration, $\\Delta t$. The term $J_T$ is interpreted as this constant flux applied during the transport step.\n\n**1. Calculate the left-face flux $J_{1/2}^n$ at time $t^n$:**\nUsing the expression derived in Part 1 and the given parameters: $u=1.0 \\times 10^{-5}$, $D=1.0 \\times 10^{-9}$, $\\Delta x=1.0 \\times 10^{-3}$, $C_b=1.0$, $C_1^n=0$.\n$$\nJ_{1/2}^n = uC_b + 2D \\frac{C_b - C_1^n}{\\Delta x} = (1.0 \\times 10^{-5})(1.0) + 2(1.0 \\times 10^{-9}) \\frac{1.0 - 0}{1.0 \\times 10^{-3}}\n$$\n$$\nJ_{1/2}^n = 1.0 \\times 10^{-5} + 2.0 \\times 10^{-6} = 1.2 \\times 10^{-5} \\text{ mol m}^{-2}\\text{s}^{-1}\n$$\n\n**2. Calculate the total moles transferred, $F$:**\nGiven $\\Delta t = 5.0\\ \\text{s}$.\n$$\nF = J_{1/2}^n \\Delta t = (1.2 \\times 10^{-5})(5.0) = 6.0 \\times 10^{-5} \\text{ mol m}^{-2}\n$$\nRounding to four significant figures as requested, the result is $6.000 \\times 10^{-5}$.",
            "answer": "$$\n\\boxed{6.000 \\times 10^{-5}}\n$$"
        }
    ]
}