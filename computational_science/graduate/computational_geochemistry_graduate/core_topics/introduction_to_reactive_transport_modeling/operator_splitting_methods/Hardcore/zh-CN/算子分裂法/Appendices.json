{
    "hands_on_practices": [
        {
            "introduction": "算子分裂方法的核心思想是将一个复杂的问题分解为一系列更简单、可以独立求解的子问题。然而，这种分解会引入一种被称为“分裂误差”的近似误差。本练习将通过经典的平流-扩散-反应（ADR）方程，引导你从第一性原理出发，推导一阶李分裂（Lie splitting）格式的局部截断误差，并将其与算子对易子联系起来。通过理论推导和数值验证相结合，你将对分裂误差的来源和量级建立深刻的直观理解。",
            "id": "4079402",
            "problem": "考虑一个标量浓度场 $C(x,t)$ 的一维平流-扩散-反应 (ADR) 偏微分方程 (PDE)，定义在周期性空间域 $x \\in [0,L]$ 和时间 $t \\ge 0$ 上。该方程包含空间变化的平流速度 $v(x)$、恒定的分子扩散系数 $D$ 以及空间变化的一阶反应速率 $k(x)$。其控制方程为\n$$\n\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t),\n$$\n该方程满足周期性边界条件和一个光滑的周期性初始条件。在计算地球化学中，当模拟多孔介质和反应流中水相物质的输运和转化时，会遇到平流-扩散-反应 (ADR) 过程。\n\n任务 1 (推导)：从平流算子 $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$、扩散算子 $\\mathcal{D} u = D\\,\\partial_{xx} u$ 和反应算子 $\\mathcal{R} u = -\\,k(x)\\,u$ 的定义出发，推导一个用于单个时间步长 $\\Delta t$ 的一阶 Lie 算子分裂方案。该方案通过在同一个 $\\Delta t$ 内按平流、扩散、反应的顺序依次求解子问题来演化 $C(x,t)$。请使用从半群复合出发的、基于原理的推导方法，并用算子的对易子来量化主阶局部算子分裂误差。你的推导必须从线性算子和流的复合的基本定义开始；不要使用预先给出的简化公式，也不要不加推导地直接给出最终的对易子结果。\n\n任务 2 (实现)：实现一个数值算法来完成你所推导的一阶 Lie 分裂。使用空间离散的周期性网格和以下数值方法：\n- 对于平流子步骤，使用高精度 ODE 积分器求解常微分方程 (ODE) 半离散系统 $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C}$ 一个子步长 $\\Delta t$。这里 $\\mathbf{C}$ 是网格点上的浓度值向量，$\\mathbf{v}$ 是网格点上的平流速度向量，$\\odot$ 表示逐分量乘法，$\\partial_x \\mathbf{C}$ 是通过在周期域上使用快速傅里叶变换 (FFT) 计算的谱方法一阶导数。\n- 对于扩散子步骤，通过将每个傅里叶模态乘以 $e^{-D\\,k^2\\,\\Delta t}$，在傅里叶空间中精确演化 $\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C}$ 一个子步长 $\\Delta t$。其中 $k$ 是角波数。\n- 对于反应子步骤，通过逐分量乘以 $e^{-\\mathbf{k}\\,\\Delta t}$，精确演化 $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C}$ 一个子步长 $\\Delta t$。\n\n为了量化分裂误差，通过使用具有严格容差的高阶自适应 ODE 积分器，求解从 $t = 0$ 到 $t = T$ 的完整半离散 ADR 系统\n$$\n\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}\n$$\n来计算一个高精度的非分裂参考解 $\\mathbf{C}_{\\text{ref}}(T)$。然后计算在最终时间 $T$ 的相对离散 $\\ell^2$ 误差，\n$$\nE \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2},\n$$\n其中 $\\left\\|\\cdot\\right\\|_2$ 是网格上的欧几里得范数。将此误差报告为一个无量纲小数。\n\n域、系数和初始条件：\n- 域长度 $L$ 为 $1$ 米，具有周期性边界条件。\n- 网格大小 $N$ 为 $128$ 个均匀间隔的点。\n- 平流速度 $v(x) = v_0 + v_1\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)$，其中 $v_0$ 的单位是米/秒，$v_1$ 的单位是米/秒。\n- 扩散系数 $D$ 是常数，单位是平方米/秒。\n- 反应速率 $k(x) = k_0 + k_1\\,\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)$，其中 $k_0$ 的单位是 1/秒，$k_1$ 的单位是 1/秒。\n- 初始条件 $C(x,0) = C_0\\,\\left[1 + a\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\right]$，其中 $C_0$ 是任意浓度单位，$a$ 是无量纲振幅。由于要求的输出是误差范数和比率，它们都是无量纲的；最终输出中不需要物理单位。\n\n时间参数：\n- 最终时间 $T$（单位：秒）和分裂时间步长 $\\Delta t$（单位：秒）将针对每个测试案例指定。请确保 $T$ 是 $\\Delta t$ 的整数倍。\n\n测试套件：\n实现你的程序以评估以下四个测试案例并汇总结果：\n- 案例 1 (一般的变系数 ADR)：\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$。\n  - 以小数形式输出 $t = T$ 时的相对 $\\ell^2$ 误差 $E_1$。\n- 案例 2 (通过将时间步长减半来验证阶数)：\n  - 参数与案例 1 相同。\n  - 计算 $\\Delta t = T/40$ 时的 $E_{\\Delta t}$ 和 $\\Delta t = T/80$ 时的 $E_{\\Delta t/2}$，并以小数形式输出比率 $R = E_{\\Delta t}/E_{\\Delta t/2}$，以评估一阶全局精度。\n- 案例 3 (无扩散)：\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.0$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$。\n  - 以小数形式输出 $t = T$ 时的相对 $\\ell^2$ 误差 $E_3$。\n- 案例 4 (常数系数，预期分裂误差接近于零)：\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.0$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.0$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$。\n  - 以小数形式输出 $t = T$ 时的相对 $\\ell^2$ 误差 $E_4$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含四个测试案例的结果，格式为方括号内以逗号分隔的列表，顺序为 $[E_1, R, E_3, E_4]$。例如，程序必须精确地打印一行形如 $[E_1,R,E_3,E_4]$ 的内容，不含任何额外文本。所有输出均为无量纲小数。",
            "solution": "在尝试解答之前，对问题进行验证。\n\n### 第 1 步：提取已知条件\n-   **控制方程**：一维平流-扩散-反应 (ADR) PDE 为 $\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t)$。\n-   **域和条件**：$x \\in [0,L]$, $t \\ge 0$，具有周期性边界条件和一个光滑的周期性初始条件。\n-   **算子定义**：平流算子 $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$，扩散算子 $\\mathcal{D} u = D\\,\\partial_{xx} u$，以及反应算子 $\\mathcal{R} u = -\\,k(x)\\,u$。\n-   **任务 1 (推导)**：推导一个一阶 Lie 算子分裂方案，形式为平流-扩散-反应，通过依次求解每个子问题来使解演化 $\\Delta t$。推导必须从半群复合开始，并使用算子对易子量化主阶局部算子分裂误差。\n-   **任务 2 (实现)**：为 Lie 分裂实现一个数值算法。\n    -   平流子步骤 $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C})$：使用高精度 ODE 积分器，采用谱微分 (FFT)。\n    -   扩散子步骤 $(\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C})$：在傅里叶空间中进行精确演化。\n    -   反应子步骤 $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C})$：使用精确的逐分量演化。\n-   **误差分析**：将分裂解与通过使用高阶自适应 ODE 积分器积分完整半离散系统 $\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}$ 获得的高精度非分裂参考解进行比较。误差度量是相对离散 $\\ell^2$-范数 $E \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}$。\n-   **参数**：\n    -   域：$L = 1$，网格大小 $N=128$。\n    -   系数：$v(x) = v_0 + v_1\\,\\sin(2\\pi x/L)$，$D$ 是常数，$k(x) = k_0 + k_1\\,\\cos(2\\pi x/L)$。\n    -   初始条件：$C(x,0) = C_0\\,[1 + a\\,\\sin(2\\pi x/L)]$。\n-   **测试案例**：定义了四个具体案例，提供了所有参数值 ($v_0, v_1, D, k_0, k_1, C_0, a, T, \\Delta t$)，用于计算特定的误差度量 $E_1, R, E_3, E_4$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n-   **科学依据**：ADR 方程是输运现象中的一个基本模型，在地球化学等领域至关重要。算子定义、边界条件以及系数的函数形式都是标准的，并且在科学上是合理的。所提出的数值方法（算子分裂、谱方法、高阶 ODE 积分）是科学计算中的成熟技术。该问题在科学上和数学上都是合理的。\n-   **适定性和一致性**：该问题是适定的。具有指定光滑系数和周期性边界条件的 ADR 方程构成了一个适定的初边值问题。所有必要的参数和方法都已定义，使得问题自洽且明确无误。使用“高精度 ODE 积分器”的指令是标准做法，可以通过库例程（如 SciPy 的 `solve_ivp`）使用适当的方法和容差轻松满足。\n-   **客观性和可行性**：该问题以精确、客观的数学语言陈述。参数值对于一个模型系统是物理上合理的，不会导致不可行的计算。任务是具体且可验证的。\n\n### 第 3 步：结论和行动\n问题是**有效的**。这是一个在数值分析和计算科学领域中定义明确、科学合理且有意义的问题。将提供一个解决方案。\n\n### 解答\n\n按照要求，解决方案分两部分呈现：理论推导和数值实现的纲要。\n\n#### 任务 1：Lie 分裂的推导与误差分析\n\n控制平流-扩散-反应 (ADR) 方程为\n$$\n\\frac{\\partial C}{\\partial t} = \\mathcal{A}C + \\mathcal{D}C + \\mathcal{R}C = (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})C\n$$\n其中 $\\mathcal{A} = -v(x)\\partial_x$、$\\mathcal{D} = D\\partial_{xx}$ 和 $\\mathcal{R} = -k(x)$ 分别是代表平流、扩散和反应的线性算子。设 $\\mathcal{L} = \\mathcal{A} + \\mathcal{D} + \\mathcal{R}$ 为总演化算子。\n\n这个线性 PDE 在时间间隔 $\\Delta t$ 上的形式解可以用半群的概念表示，即算子指数：\n$$\nC(t+\\Delta t) = e^{\\Delta t \\mathcal{L}} C(t) = e^{\\Delta t (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})} C(t)\n$$\n算子分裂方法通过单个算子指数的乘积来近似算子和的指数。对于指定的平流、然后扩散、然后反应的顺序，一阶 Lie 分裂格式通过每个子问题的传播子的复合来近似精确解的传播子 $e^{\\Delta t \\mathcal{L}}$：\n$$\n\\Phi_{\\text{split}}(\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}}\n$$\n将此应用于时间 $t$ 的解，得到 $t+\\Delta t$ 时的近似解：\n$$\nC_{\\text{split}}(t+\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} C(t)\n$$\n这对应于在一个时间步长 $\\Delta t$ 内依次求解三个独立的、更简单的 PDE：\n1.  **平流**：$\\frac{\\partial C^*}{\\partial t} = \\mathcal{A}C^*$，从 $C(t)$ 求解得到 $C^*(\\Delta t) = e^{\\Delta t \\mathcal{A}}C(t)$。\n2.  **扩散**：$\\frac{\\partial C^{**}}{\\partial t} = \\mathcal{D}C^{**}$，从 $C^*(\\Delta t)$ 求解得到 $C^{**}(\\Delta t) = e^{\\Delta t \\mathcal{D}}C^*(\\Delta t)$。\n3.  **反应**：$\\frac{\\partial C^{*** }}{\\partial t} = \\mathcal{R}C^{*** }$，从 $C^{**}(\\Delta t)$ 求解得到 $C^{***}(\\Delta t) = e^{\\Delta t \\mathcal{R}}C^{**}(\\Delta t)$。\n最终结果是 $C_{\\text{split}}(t+\\Delta t) = C^{***}(\\Delta t)$。\n\n局部截断误差是分裂传播子与精确传播子作用的差。为了找到主阶项，我们将两个传播子在 $\\Delta t$ 处展开为泰勒级数。\n\n精确传播子展开为：\n$$\ne^{\\Delta t \\mathcal{L}} = I + \\Delta t \\mathcal{L} + \\frac{(\\Delta t \\mathcal{L})^2}{2!} + O(\\Delta t^3)\n$$\n$$\ne^{\\Delta t (\\mathcal{A}+\\mathcal{D}+\\mathcal{R})} = I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}+\\mathcal{D}+\\mathcal{R})^2 + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) + O(\\Delta t^3)\n$$\n分裂传播子是指数的乘积：\n$$\ne^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} = \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t \\mathcal{D} + \\frac{\\Delta t^2}{2}\\mathcal{D}^2\\right) \\left(I + \\Delta t \\mathcal{A} + \\frac{\\Delta t^2}{2}\\mathcal{A}^2\\right) + O(\\Delta t^3)\n$$\n展开此乘积并保留到 $\\Delta t^2$ 阶的项：\n$$\n= \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t(\\mathcal{A}+\\mathcal{D}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA}\\right)\\right) + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD} + \\frac{\\mathcal{R}^2}{2}\\right) + O(\\Delta t^3)\n$$\n局部误差算子是二者之差，$\\Phi_{\\text{split}}(\\Delta t) - e^{\\Delta t \\mathcal{L}}$。$I$ 阶和 $\\Delta t$ 阶的项完全抵消。$\\Delta t^2$ 阶项的差为：\n$$\n\\Delta t^2 \\left[ \\left(\\frac{\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD}\\right) - \\frac{1}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (2\\mathcal{DA} - (\\mathcal{AD}+\\mathcal{DA})) + (2\\mathcal{RA} - (\\mathcal{AR}+\\mathcal{RA})) + (2\\mathcal{RD} - (\\mathcal{DR}+\\mathcal{RD})) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (\\mathcal{DA} - \\mathcal{AD}) + (\\mathcal{RA} - \\mathcal{AR}) + (\\mathcal{RD} - \\mathcal{DR}) \\right]\n$$\n使用对易子记号 $[\\mathcal{X}, \\mathcal{Y}] = \\mathcal{XY} - \\mathcal{YX}$ 来简化此表达式：\n$$\n\\text{误差项} = \\frac{\\Delta t^2}{2} \\left( [\\mathcal{D}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{D}] \\right)\n$$\n局部截断误差为 $O(\\Delta t^2)$ 阶。由于到达最终时间 $T$ 大约需要 $N_{\\text{steps}} = T/\\Delta t$ 步，全局误差累积到 $N_{\\text{steps}} \\times O(\\Delta t^2) \\sim (T/\\Delta t) \\times O(\\Delta t^2) \\sim O(\\Delta t)$ 阶。因此，Lie 分裂是一种一阶精度方法。当且仅当所有算子都对易时，即 $[\\mathcal{D}, \\mathcal{A}]=0$、$[\\mathcal{R}, \\mathcal{A}]=0$ 和 $[\\mathcal{R}, \\mathcal{D}]=0$ 时，分裂误差为零。这种情况发生在系数 $v(x)$ 和 $k(x)$ 为常数时。\n\n#### 任务 2：数值实现策略\n\n数值实现遵循在离散网格上推导出的分裂格式，并将其精度与参考解进行比较。\n\n1.  **离散化**：将空间域 $x \\in [0, L]$ 离散为 $N$ 个均匀间隔的网格点 $x_j = j L/N$（$j=0, \\dots, N-1$）。浓度场 $C(x,t)$ 变成一个长度为 $N$ 的向量 $\\mathbf{C}(t)$，其中 $C_j(t) \\approx C(x_j, t)$。函数 $v(x)$ 和 $k(x)$ 成为向量 $\\mathbf{v}$ 和 $\\mathbf{k}$。\n\n2.  **参考解**：通过求解全耦合半离散 ODE 系统，\n    $$\n    \\frac{d\\mathbf{C}}{dt} = \\mathcal{L}\\mathbf{C} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C}) + D (\\partial_{xx} \\mathbf{C}) - \\mathbf{k} \\odot \\mathbf{C}\n    $$\n    从 $t=0$ 到 $t=T$，计算一个高精度参考解 $\\mathbf{C}_{\\text{ref}}(T)$。空间导数 $\\partial_x \\mathbf{C}$ 和 $\\partial_{xx} \\mathbf{C}$ 使用快速傅里叶变换 (FFT) 进行谱方法计算，这对周期函数非常精确。时间积分使用高阶自适应步长求解器执行，特别是 `scipy.integrate.solve_ivp` 的 `DOP853` 方法和严格的误差容差（例如，`rtol=1e-12`, `atol=1e-14`）。\n\n3.  **分裂解**：分裂解 $\\mathbf{C}_{\\text{split}}(T)$ 通过迭代 $N_{\\text{steps}} = T/\\Delta t$ 次来计算。在从 $t$ 到 $t+\\Delta t$ 的每一步中：\n    -   **平流步骤**：同样使用 `solve_ivp` 和 `DOP853` 方法以及严格的容差，求解 ODE 系统 $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C})$ 一个时间步长 $\\Delta t$。对 $\\partial_x \\mathbf{C}$ 使用谱方法。\n    -   **扩散步骤**：系统 $\\frac{d\\mathbf{C}}{dt} = D (\\partial_{xx} \\mathbf{C})$ 在傅里叶空间中精确求解。对状态向量 $\\mathbf{C}$ 进行 FFT 得到 $\\hat{\\mathbf{C}}$。对于角波数为 $\\omega_m$ 的每个傅里叶模态 $m$，ODE 变为 $\\frac{d\\hat{C}_m}{dt} = D(i\\omega_m)^2 \\hat{C}_m = -D\\omega_m^2 \\hat{C}_m$。精确解为 $\\hat{C}_m(\\Delta t) = \\hat{C}_m(0) e^{-D\\omega_m^2 \\Delta t}$。状态向量通过 `ifft(fft(C) * exp(-D*omega**2*dt))` 更新。\n    -   **反应步骤**：系统 $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{k} \\odot \\mathbf{C}$ 是一组解耦的 ODE，$dC_j/dt = -k_j C_j$。解为 $C_j(\\Delta t) = C_j(0) e^{-k_j \\Delta t}$。状态向量通过逐分量相乘来更新：$\\mathbf{C} \\leftarrow \\mathbf{C} \\odot e^{-\\mathbf{k}\\Delta t}$。\n\n4.  **误差计算和测试案例**：\n    -   在 $T$ 时刻计算分裂解与参考解之间的相对 $\\ell^2$ 误差。\n    -   **案例 1** 测量具有变系数的一般 ADR 问题的误差。\n    -   **案例 2** 验证分裂方法的一阶收敛性。误差 $E$ 与 $\\Delta t$ 成正比，因此误差比率 $E_{\\Delta t}/E_{\\Delta t/2}$ 应约等于 2。\n    -   **案例 3** ($D=0$) 分离出由非对易的平流和反应算子 ($[\\mathcal{R}, \\mathcal{A}] \\neq 0$) 引起的分裂误差。\n    -   **案例 4** ($v_1=0, k_1=0$) 使平流和反应系数为常数。如推导所示，所有对易子都变为零。理论分裂误差为零。测得的误差 $E_4$ 将是一个很小的数，反映了 ODE 求解器的数值精度和浮点运算的精度，从而证明了对易子分析的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the ADR equation using Lie splitting and compares it to a reference\n    solution to quantify splitting error for four different test cases.\n    \"\"\"\n\n    def run_simulation(L, N, v0, v1, D, k0, k1, C0, a, T, dt, use_split_method):\n        \"\"\"\n        Runs a single simulation, either the full reference or the split method.\n        \"\"\"\n        # 1. Setup grid, initial condition, and parameters\n        x = np.linspace(0, L, N, endpoint=False)\n        v = v0 + v1 * np.sin(2 * np.pi * x / L)\n        k_rate = k0 + k1 * np.cos(2 * np.pi * x / L)\n        C_initial = C0 * (1 + a * np.sin(2 * np.pi * x / L))\n\n        # Wavenumbers for spectral derivatives\n        # fftfreq returns frequencies in cycles per unit of sample spacing (dx=L/N)\n        # We convert to angular wavenumbers (radians per unit length)\n        dx = L / N\n        angular_wavenumbers = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define derivative functions and RHS of the full PDE\n        def d_dx(C_vec):\n            return np.real(ifft(1j * angular_wavenumbers * fft(C_vec)))\n\n        def d2_dx2(C_vec):\n            return np.real(ifft(-angular_wavenumbers**2 * fft(C_vec)))\n\n        def full_rhs(t, C_vec):\n            dC_advection = -v * d_dx(C_vec)\n            dC_diffusion = D * d2_dx2(C_vec)\n            dC_reaction = -k_rate * C_vec\n            return dC_advection + dC_diffusion + dC_reaction\n\n        # 3. Compute solution\n        if not use_split_method:\n            # High-accuracy reference solution\n            sol = solve_ivp(full_rhs, (0, T), C_initial, method='DOP853', rtol=1e-12, atol=1e-14)\n            return sol.y[:, -1]\n        else:\n            # Lie splitting solution\n            def advection_rhs(t, C_vec):\n                return -v * d_dx(C_vec)\n            \n            C = C_initial.copy()\n            num_steps = int(round(T / dt))\n\n            for _ in range(num_steps):\n                # Step 1: Advection substep\n                sol_adv = solve_ivp(advection_rhs, (0, dt), C, method='DOP853', rtol=1e-12, atol=1e-12)\n                C = sol_adv.y[:, -1]\n\n                # Step 2: Diffusion substep (exact in Fourier space)\n                C_hat = fft(C)\n                C_hat *= np.exp(-D * angular_wavenumbers**2 * dt)\n                C = np.real(ifft(C_hat))\n\n                # Step 3: Reaction substep (exact pointwise)\n                C *= np.exp(-k_rate * dt)\n            \n            return C\n\n    def calculate_error(params, dt):\n        \"\"\"Helper to compute error for a given dt.\"\"\"\n        C_ref = run_simulation(**params, dt=dt, use_split_method=False)\n        C_split = run_simulation(**params, dt=dt, use_split_method=True)\n        error = np.linalg.norm(C_split - C_ref) / np.linalg.norm(C_ref)\n        return error\n\n    results = []\n\n    # --- Test Case 1 ---\n    # General ADR with variable coefficients\n    params1 = {'L': 1.0, 'N': 128, 'v0': 0.5, 'v1': 0.25, 'D': 0.001, 'k0': 1.0, 'k1': 0.5, 'C0': 1.0, 'a': 0.5, 'T': 0.1}\n    dt1 = params1['T'] / 40.0\n    E1 = calculate_error(params1, dt1)\n    results.append(E1)\n\n    # --- Test Case 2 ---\n    # Order verification by halving the time step\n    params2 = params1\n    dt_large = params2['T'] / 40.0\n    dt_small = params2['T'] / 80.0\n    E_dt = calculate_error(params2, dt_large)\n    E_dthalf = calculate_error(params2, dt_small)\n    R = E_dt / E_dthalf\n    results.append(R)\n\n    # --- Test Case 3 ---\n    # No diffusion (D=0)\n    params3 = params1.copy()\n    params3['D'] = 0.0\n    dt3 = params3['T'] / 40.0\n    E3 = calculate_error(params3, dt3)\n    results.append(E3)\n\n    # --- Test Case 4 ---\n    # Constant coefficients (v1=0, k1=0), commuting operators\n    params4 = params1.copy()\n    params4['v1'] = 0.0\n    params4['k1'] = 0.0\n    dt4 = params4['T'] / 40.0\n    E4 = calculate_error(params4, dt4)\n    results.append(E4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在理论基础之上，我们将注意力转向算子分裂在地球化学中的实际应用。本练习构建了一个模拟碳酸盐矿物沉淀的零维间歇反应器模型，这是一个典型的非线性反应输运问题。你将实现并对比两种主流的分裂格式：顺序非迭代法（SNIA）和顺序迭代法（SIA），并以高精度的整体求解（monolithic）结果为基准，评估它们的准确性。这个实践将帮助你理解在处理强耦合、非线性化学反应时，不同分裂策略的优劣与选择。",
            "id": "4094620",
            "problem": "构建一个零维间歇式反应器基准问题，用于评估在碳酸盐沉淀反应输运中算子分裂法的性能。该水相体系包含溶解的钙和碳酸盐，当发生过饱和时，它们会沉淀形成固体碳酸盐矿物。其控制演化过程基于质量守恒和源于质量作用定律的沉淀速率定律。目标是计算生成的固体碳酸盐质量，并将顺序算子分裂方案与一个整体式非分裂参考解进行比较。\n\n假设与定义：\n- 反应器体积恒为$1$升，因此物种的摩尔量等于其浓度（单位为 $\\mathrm{mol/L}$）。\n- 令 $C_{\\mathrm{Ca}}(t)$ 和 $C_{\\mathrm{CO_3}}(t)$ 分别表示溶解的钙和碳酸盐的浓度，令 $S(t)$ 表示累计沉淀的固体碳酸盐量（单位为 $\\mathrm{mol/L}$）。\n- 沉淀动力学遵循质量作用速率：\n  $$ r(t) \\;=\\; k \\,\\max\\!\\left(0,\\, C_{\\mathrm{Ca}}(t)\\,C_{\\mathrm{CO_3}}(t) \\;-\\; K_{\\mathrm{sp}} \\right), $$\n  其中 $k$ 的单位为 $\\mathrm{L\\,mol^{-1}\\,s^{-1}}$，$K_{\\mathrm{sp}}$ 为溶度积，单位为 $(\\mathrm{mol/L})^2$。假定活度等于浓度（活度系数为1）。\n- 间歇式反应器中，考虑随时间变化的碳酸盐源项，其质量平衡方程为：\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} \\;=\\; J_{\\mathrm{Ca}}(t) \\;-\\; r(t), \\qquad \\frac{dC_{\\mathrm{CO_3}}}{dt} \\;=\\; J_{\\mathrm{CO_3}}(t) \\;-\\; r(t), \\qquad \\frac{dS}{dt} \\;=\\; r(t). $$\n- 不存在钙源，因此 $J_{\\mathrm{Ca}}(t) \\equiv 0$。碳酸盐源是一个由下式定义的方波脉冲：\n  $$ J_{\\mathrm{CO_3}}(t) \\;=\\; \\begin{cases}\n  J_0, & 0 \\le t  t_{\\mathrm{inj}},\\\\\n  0,  t \\ge t_{\\mathrm{inj}},\n  \\end{cases} $$\n  在持续时间 $t_{\\mathrm{inj}}$ 内，注入速率为常数 $J_0$。\n\n待实现的算子分裂方法：\n- 顺序非迭代法 (SNIA)：在每个大小为 $\\Delta t$ 的时间步内，首先在 $\\Delta t$ 上应用输运算子（源项），然后使用显式前向欧拉更新，在 $\\Delta t$ 上应用反应算子，其中速率 $r$ 在输运后的状态下进行评估。在反应更新期间，通过限制消耗量来强制非负性，以确保 $C_{\\mathrm{Ca}}$ 和 $C_{\\mathrm{CO_3}}$ 在该步内均不为负。这将得到一个时间上一阶精度的分裂。\n- 顺序迭代法 (SIA)：在每个大小为 $\\Delta t$ 的时间步内，通过在步内对输运和反应进行迭代来减小分裂误差。实现一个定点（Picard）迭代，其步内更新满足：\n  $$ C^{(m+1)}_{\\mathrm{Ca}} \\;=\\; C^{n}_{\\mathrm{Ca}} \\;+\\; \\Delta t\\,J_{\\mathrm{Ca}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ C^{(m+1)}_{\\mathrm{CO_3}} \\;=\\; C^{n}_{\\mathrm{CO_3}} \\;+\\; \\Delta t\\,J_{\\mathrm{CO_3}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ S^{(m+1)} \\;=\\; S^{n} \\;+\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  每次迭代中需进行适当的限制以强制非负性，并为每步设定固定的最大迭代次数。将最后一次迭代的结果作为该步的更新值。\n- 整体式非分裂参考解：使用隐式刚性求解器在时间区间 $[0,T]$ 上求解关于 $C_{\\mathrm{Ca}}(t)$、$C_{\\mathrm{CO_3}}(t)$ 和 $S(t)$ 的耦合常微分方程，以达到高精度。该整体解将作为比较的参考。\n\n推导的基本依据：\n- 各组分带源汇项的质量守恒。\n- 带有溶度积阈值的沉淀速率质量作用动力学。\n- 将演化算子分解为输运和反应子算子的数值算子分裂方法。\n\n您的程序必须实现上述三种方法，并为以下测试套件计算在最终时间 $t=T$ 时的总沉淀固体量。所有参数均采用化学领域中的SI一致单位：浓度单位为 $\\mathrm{mol/L}$，时间单位为 $\\mathrm{s}$，溶度积 $K_{\\mathrm{sp}}$ 单位为 $(\\mathrm{mol/L})^2$。所有要求的输出均以 $\\mathrm{mol/L}$ 为单位报告。\n\n测试套件（三种情况）：\n- 情况 A（明显触发沉淀）：\n  - $C_{\\mathrm{Ca}}(0) = 5 \\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3 \\times 10^{-9}$, $k = 10$。\n  - $J_0 = 2 \\times 10^{-3}$, $t_{\\mathrm{inj}} = 2$, $T=10$。\n  - 分裂法的时间步长: $\\Delta t = 0.05$。\n- 情况 B（初始状态接近平衡，有轻微的过饱和脉冲）：\n  - $C_{\\mathrm{Ca}}(0) = 1 \\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = K_{\\mathrm{sp}}/C_{\\mathrm{Ca}}(0) = 3.3 \\times 10^{-6}$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3 \\times 10^{-9}$, $k = 10$。\n  - $J_0 = 5 \\times 10^{-7}$, $t_{\\mathrm{inj}} = 1$, $T=10$。\n  - 分裂法的时间步长: $\\Delta t = 0.05$。\n- 情况 C（预计无沉淀）：\n  - $C_{\\mathrm{Ca}}(0) = 1 \\times 10^{-6}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3 \\times 10^{-9}$, $k = 10$。\n  - $J_0 = 1 \\times 10^{-5}$, $t_{\\mathrm{inj}} = 0.1$, $T=5$。\n  - 分裂法的时间步长: $\\Delta t = 0.05$。\n\n需强制执行的算法细节：\n- 在 SNIA 和 SIA 中，在任何大小为 $\\Delta t$ 的时间步内的反应更新期间，消耗量 $\\Delta c = r\\,\\Delta t$ 必须被限制为 $\\Delta c \\le \\min\\!\\left(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}\\right)$，以避免出现负浓度。使用如上所述的速率定律，其中 $r \\ge 0$，若未饱和则 $r=0$。\n- 在 SIA 中，每个时间步使用固定的迭代次数，等于 $8$，并使用最大范数下 $10^{-12}$ 的容差进行收敛性检查；如果收敛则提前终止。\n- 在整体式参考解中，使用带有严格容差的刚性隐式积分器来近似在 $[0,T]$ 上的精确解。\n\n每种情况的必需输出：\n- 程序必须为每种情况计算五个浮点数：\n  - 来自整体式非分裂参考解的 $S_{\\mathrm{ref}}(T)$，\n  - 来自顺序非迭代法 (SNIA) 的 $S_{\\mathrm{SNIA}}(T)$，\n  - 来自顺序迭代法 (SIA) 的 $S_{\\mathrm{SIA}}(T)$，\n  - $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$,\n  - $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$.\n- 将每个值以 $\\mathrm{mol/L}$ 为单位表示，并四舍五入到八位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起的逗号分隔列表。该列表必须按顺序串联构成，首先是情况A的五个四舍五入的浮点数，然后是情况B的，最后是情况C的。例如，您的输出必须类似于：\n  $$ [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10},x_{11},x_{12},x_{13},x_{14},x_{15}] $$\n  其中每个 $x_i$ 是一个小数点后有八位数字的小数，代表了三种情况下所需的量，单位为 $\\mathrm{mol/L}$。",
            "solution": "用户提供了一个计算地球化学基准问题的陈述。根据协议，第一步是验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **系统变量：** $C_{\\mathrm{Ca}}(t)$ (溶解的钙浓度, $\\mathrm{mol/L}$)，$C_{\\mathrm{CO_3}}(t)$ (溶解的碳酸盐浓度, $\\mathrm{mol/L}$)，$S(t)$ (沉淀的固体碳酸盐, $\\mathrm{mol/L}$)。反应器体积为 $1$ 升。\n- **沉淀动力学：** $r(t) = k \\cdot \\max(0, C_{\\mathrm{Ca}}(t)C_{\\mathrm{CO_3}}(t) - K_{\\mathrm{sp}})$，其中 $k$ 是速率常数 ($\\mathrm{L\\,mol^{-1}\\,s^{-1}}$)，$K_{\\mathrm{sp}}$ 是溶度积 ($\\mathrm{(mol/L)^2}$)。\n- **质量平衡方程 (ODEs)：**\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} = J_{\\mathrm{Ca}}(t) - r(t) $$\n  $$ \\frac{dC_{\\mathrm{CO_3}}}{dt} = J_{\\mathrm{CO_3}}(t) - r(t) $$\n  $$ \\frac{dS}{dt} = r(t) $$\n- **源项：** $J_{\\mathrm{Ca}}(t) = 0$。$J_{\\mathrm{CO_3}}(t)$ 是一个方波脉冲：对于 $0 \\le t  t_{\\mathrm{inj}}$ 为 $J_0$，对于 $t \\ge t_{\\mathrm{inj}}$ 为 $0$。\n- **数值方案：**\n    1.  **整体式：** 使用高精度隐式刚性ODE求解器获取参考解。\n    2.  **SNIA (顺序非迭代法)：** 一阶分裂。\n        - 输运步骤：用源项在 $\\Delta t$ 内更新浓度。\n        - 反应步骤：使用在输运后状态下评估的速率进行显式欧拉更新。\n        - 限制：消耗量 $\\Delta c = r\\Delta t$ 受输运后反应物可用量的限制，即 $\\Delta c \\le \\min(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}})$。\n    3.  **SIA (顺序迭代法)：** 在每个时间步 $\\Delta t$ 内进行 Picard 迭代。\n        - 更新规则：$C^{(m+1)} = C^n + \\Delta t(J - r(C^{(m)}))$。\n        - 最大迭代次数：$8$。\n        - 收敛容差：最大范数为 $10^{-12}$。\n        - 限制：在每次迭代中必须强制非负性。\n- **测试用例：** 提供了三种不同的情况（A, B, C），包含具体的初始条件、参数（$K_{\\mathrm{sp}}, k$）、源项（$J_0, t_{\\mathrm{inj}}$）和模拟时间（$T, \\Delta t$）。\n- **所需输出：** 对于每种情况，报告五个四舍五入到八位小数的值：$S_{\\mathrm{ref}}(T)$, $S_{\\mathrm{SNIA}}(T)$, $S_{\\mathrm{SIA}}(T)$，以及绝对误差 $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$ 和 $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行严格评估：\n- **科学依据：** 该问题基于质量守恒和标准质量作用化学动力学的基本原理。将其表述为常微分方程（ODE）系统是模拟间歇式反应器的标准方法。该问题在科学上是合理的。\n- **适定性：** 该问题定义了一个具有指定初始条件和分段常数强迫函数的一阶常微分方程系统。速率函数是连续且Lipschitz的，这保证了解的存在性和唯一性。所有必需的参数和算法细节都已提供。该问题是适定的。\n- **客观性：** 问题陈述使用了精确的数学定义和客观、定量的语言。没有歧义或主观内容。\n- **完整性与一致性：** 问题是自洽的。所有必要的数据、初始条件、常数和算法约束都已提供。设置中没有矛盾之处。\n- **真实性与可行性：** 所选的浓度、速率常数和时间尺度参数对于碳酸盐水溶液化学是合理的，这使其成为一个现实的基准问题。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。它是一个定义明确、科学合理且具有一定挑战性的基准问题，适用于比较反应输运模型中的数值方法。将提供一个解决方案。\n\n### 求解方案设计\n\n解决方案将使用 Python 实现，并遵循指定的环境。该问题要求评估三种不同的数值方法，用于求解描述间歇式反应器中碳酸盐沉淀的常微分方程组。\n\n**1. 整体式（参考）解**\n参考解是通过整体式求解耦合的ODE系统获得的，这意味着所有项（源项和反应项）都同时处理。鉴于系统可能存在刚性（由于与源注入相比，反应动力学可能非常快），使用刚性隐式求解器是合适的。\n该系统定义为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，其中 $\\mathbf{y} = [C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}, S]^T$。向量函数 $\\mathbf{f}$ 是：\n$$ \\mathbf{f}(t, \\mathbf{y}) = \\begin{bmatrix} -r(y_1, y_2) \\\\ J_{\\mathrm{CO_3}}(t) - r(y_1, y_2) \\\\ r(y_1, y_2) \\end{bmatrix} $$\n其中 $y_1=C_{\\mathrm{Ca}}$ 且 $y_2=C_{\\mathrm{CO_3}}$。我们将使用 `scipy.integrate.solve_ivp` 的 `BDF`（向后微分公式）方法，并设置严格的容差（$rtol=10^{-12}$, $atol=10^{-15}$），以确保获得高精度的参考解。\n\n**2. 顺序非迭代法 (SNIA)**\n这是一种一阶算子分裂法。在从 $t_n$ 到 $t_{n+1}$ 的每个时间步 $\\Delta t$ 内，我们依次应用输运算子和反应算子。\n- **输运步骤：** 首先，我们考虑外部源项。令 $\\mathbf{C}^n = [C_{\\mathrm{Ca}}^n, C_{\\mathrm{CO_3}}^n]^T$。\n  $$ \\mathbf{C}^* = \\mathbf{C}^n + \\Delta t \\, \\mathbf{J}(t_n) $$\n  其中 $\\mathbf{J}(t_n) = [0, J_{\\mathrm{CO_3}}(t_n)]^T$。\n- **反应步骤：** 接着，我们使用输运步骤得到的状态 $\\mathbf{C}^*$ 通过显式欧拉步来求解反应部分。\n  $$ r^* = k \\cdot \\max(0, C_{\\mathrm{Ca}}^* C_{\\mathrm{CO_3}}^* - K_{\\mathrm{sp}}) $$\n  可能形成的沉淀量为 $\\Delta S = r^* \\Delta t$。为确保浓度非负，该量将被限制：\n  $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S, C_{\\mathrm{Ca}}^*, C_{\\mathrm{CO_3}}^*) $$\n  该时间步的最终浓度为：\n  $$ C_{\\mathrm{Ca}}^{n+1} = C_{\\mathrm{Ca}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ C_{\\mathrm{CO_3}}^{n+1} = C_{\\mathrm{CO_3}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ S^{n+1} = S^n + \\Delta S_{\\mathrm{capped}} $$\n\n**3. 顺序迭代法 (SIA)**\nSIA 通过在一个时间步内对输运和反应进行迭代来减小分裂误差。问题指定使用 Picard 迭代来求解该隐式系统。对于从 $t_n$ 到 $t_{n+1}$ 的每个时间步：\n我们寻求一个满足隐式关系的解 $\\mathbf{y}^{n+1}$。Picard 迭代格式如下：\n$$ \\mathbf{y}^{(m+1)} = \\mathbf{y}^n + \\Delta t \\left( \\mathbf{J}(t_n) - \\mathbf{R}(\\mathbf{y}^{(m)}) \\right) $$\n其中 $\\mathbf{R}$ 表示反应项向量。让我们按分量写出这个过程，包括非负性限制。迭代的初始猜测是 $\\mathbf{y}^{(0)} = \\mathbf{y}^n$。对于第 $m$ 次迭代：\n1.  使用上一次迭代的浓度计算速率：$r^{(m)} = \\text{rate}(C_{\\mathrm{Ca}}^{(m)}, C_{\\mathrm{CO_3}}^{(m)})$。\n2.  计算固体的潜在变化量：$\\Delta S_{\\mathrm{potential}} = r^{(m)} \\Delta t$。\n3.  可用于沉淀的资源量基于时间步开始时的状态 $\\mathbf{y}^n$ 加上输运量。可被消耗的物种量为 $C_{\\mathrm{Ca}}^n$ 和 $C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)$。\n4.  对固体的变化量应用限制：\n    $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S_{\\mathrm{potential}}, \\, C_{\\mathrm{Ca}}^n, \\, C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)) $$\n5.  基于时间步开始时的状态 $n$ 来更新下一次迭代 $(m+1)$ 的状态：\n    $$ C_{\\mathrm{Ca}}^{(m+1)} = C_{\\mathrm{Ca}}^n - \\Delta S_{\\mathrm{capped}} $$\n    $$ C_{\\mathrm{CO_3}}^{(m+1)} = C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n) - \\Delta S_{\\mathrm{capped}} $$\n    $$ S^{(m+1)} = S^n + \\Delta S_{\\mathrm{capped}} $$\n6.  此迭代最多持续 $8$ 次，或直到连续迭代之间的变化量在最大范数下小于 $10^{-12}$ 的容差为止。最后一次迭代的结果成为该时间步的解 $\\mathbf{y}^{n+1}$。\n\n该实现将处理三个测试用例中的每一个，使用所有三种方法计算最终的沉淀固体量 $S(T)$，计算 SNIA 和 SIA 相对于整体式参考解的绝对误差，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes and compares operator splitting methods for a carbonate precipitation benchmark.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (precipitation clearly triggered)\n        {\n            \"name\": \"A\",\n            \"C_Ca0\": 5e-3,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 2e-3,\n            \"t_inj\": 2.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case B (near-equilibrium start, slight supersaturation pulse)\n        {\n            \"name\": \"B\",\n            \"C_Ca0\": 1e-3,\n            \"C_CO30\": 3.3e-9 / 1e-3,  # K_sp / C_Ca(0)\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 5e-7,\n            \"t_inj\": 1.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case C (no precipitation expected)\n        {\n            \"name\": \"C\",\n            \"C_Ca0\": 1e-6,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 1e-5,\n            \"t_inj\": 0.1,\n            \"T\": 5.0,\n            \"dt\": 0.05,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        C_Ca0, C_CO30, S0 = case[\"C_Ca0\"], case[\"C_CO30\"], case[\"S0\"]\n        K_sp, k = case[\"K_sp\"], case[\"k\"]\n        J0, t_inj = case[\"J0\"], case[\"t_inj\"]\n        T, dt = case[\"T\"], case[\"dt\"]\n        \n        def rate_law(C_Ca, C_CO3, k_val, K_sp_val):\n            ion_product = C_Ca * C_CO3\n            if ion_product > K_sp_val:\n                return k_val * (ion_product - K_sp_val)\n            return 0.0\n\n        # --- 1. Monolithic Unsplit Reference Solution ---\n        def ode_system(t, y):\n            C_Ca, C_CO3, S = y\n            J_CO3 = J0 if t  t_inj else 0.0\n            r = rate_law(C_Ca, C_CO3, k, K_sp)\n            dC_Ca_dt = -r\n            dC_CO3_dt = J_CO3 - r\n            dS_dt = r\n            return [dC_Ca_dt, dC_CO3_dt, dS_dt]\n\n        y0 = [C_Ca0, C_CO30, S0]\n        sol = solve_ivp(\n            ode_system, \n            [0, T], \n            y0, \n            method='BDF', \n            rtol=1e-12, \n            atol=1e-15\n        )\n        S_ref = sol.y[2, -1]\n\n        # --- 2. Sequential Non-Iterative Approach (SNIA) ---\n        C_Ca, C_CO3, S = C_Ca0, C_CO30, S0\n        num_steps = int(round(T / dt))\n        time_points = np.linspace(0, T, num_steps + 1)\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            # Transport step\n            J_CO3_step = J0 if t  t_inj else 0.0\n            C_CO3_after_transport = C_CO3 + J_CO3_step * dt\n            C_Ca_after_transport = C_Ca  # J_Ca is 0\n\n            # Reaction step\n            r = rate_law(C_Ca_after_transport, C_CO3_after_transport, k, K_sp)\n            delta_s = r * dt\n            \n            # Capping to enforce non-negativity\n            capped_delta_s = min(delta_s, C_Ca_after_transport, C_CO3_after_transport)\n            \n            # Update state\n            C_Ca = C_Ca_after_transport - capped_delta_s\n            C_CO3 = C_CO3_after_transport - capped_delta_s\n            S = S + capped_delta_s\n        \n        S_snia = S\n\n        # --- 3. Sequential Iterative Approach (SIA) ---\n        C_Ca_n, C_CO3_n, S_n = C_Ca0, C_CO30, S0\n        max_iter = 8\n        tol = 1e-12\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            C_Ca_start, C_CO3_start, S_start = C_Ca_n, C_CO3_n, S_n\n            \n            # Initial guess for the iteration (state at n)\n            y_m = np.array([C_Ca_start, C_CO3_start, S_start])\n\n            J_CO3_step = J0 if t  t_inj else 0.0\n\n            for _ in range(max_iter):\n                y_prev_iter = y_m.copy()\n                C_Ca_m_iter, C_CO3_m_iter, _ = y_prev_iter\n\n                r_m = rate_law(C_Ca_m_iter, C_CO3_m_iter, k, K_sp)\n                delta_s_potential = r_m * dt\n                \n                # Budgets are based on state 'n' plus transport\n                budget_Ca = C_Ca_start\n                budget_CO3 = C_CO3_start + J_CO3_step * dt\n                \n                capped_delta_s = min(delta_s_potential, budget_Ca, budget_CO3)\n                \n                # Update to get next iterate (m+1) based on state 'n'\n                C_Ca_new = C_Ca_start - capped_delta_s\n                C_CO3_new = budget_CO3 - capped_delta_s\n                S_new = S_start + capped_delta_s\n                \n                y_m = np.array([C_Ca_new, C_CO3_new, S_new])\n                \n                if np.max(np.abs(y_m - y_prev_iter))  tol:\n                    break\n            \n            C_Ca_n, C_CO3_n, S_n = y_m\n        S_sia = S_n\n        \n        error_snia = abs(S_snia - S_ref)\n        error_sia = abs(S_sia - S_ref)\n\n        all_results.extend([S_ref, S_snia, S_sia, error_snia, error_sia])\n\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "数值格式的正确性不仅取决于其截断误差的阶数，更关键的是它是否遵守基本的物理守恒定律。本练习旨在揭示算子分裂方法中一个常见的陷阱：对边界条件的不当处理如何导致全局质量不守恒。你将设计并执行一个诊断性计算，量化一个错误实现的分裂格式所造成的质量平衡残差。通过这个“反面教材”，你将深刻认识到在分裂格式中，输运和反应子步骤之间进行严谨、守恒耦合的至关重要性。",
            "id": "4094629",
            "problem": "一种一维反应溶质通过一个长度为 $L$、横截面积恒为 $A$ 的饱和多孔柱进行运移。该介质的孔隙度恒为 $\\phi$，水流是稳定的，具有从 $x=0$（入口）到 $x=L$（出口）的恒定达西通量 $q$。移动相浓度 $c(x,t)$ 遵循平流和一级反应的质量守恒定律，且机械弥散可忽略不计。其控制平衡关系为：控制体积内的总质量变化等于净平流输入（流入减去流出）与积分反应项之和。考虑一个代表整个柱体的单个有限体积单元，其宽度为 $\\Delta x = L$，具有狄利克雷（Dirichlet）入流边界 $c(0,t)=c_{\\mathrm{in}}$ 和在 $x=L$ 处的对流出流边界。在时间 $t$ 时，单元内的总溶质质量为 $M(t) = \\phi A \\Delta x \\, c(t)$。\n\n我们研究一种与顺序非迭代法（SNIA）一致的分裂格式，其中运移子问题（平流）首先在一个时间步 $\\Delta t$ 内推进，然后是反应子问题；而顺序迭代法（SIA）会迭代地协调这些子步骤。对平流使用显式有限体积更新，在入口和出口面使用迎风通量，对反应 $R(c)=-k\\,c$ 使用显式欧拉法。\n\n假设在时间 $t^{n}$ 时的初始单元平均浓度为 $c^{n}$，平流通量使用迎风浓度计算：入流通量 $F_{\\mathrm{in}}^{n}=A q\\,c_{\\mathrm{in}}$ 和出流通量 $F_{\\mathrm{out}}^{n}=A q\\,c^{n}$。平流步骤产生一个中间浓度 $c^{*}$，然后在 $\\Delta t$ 内的反应步骤更新得到 $c^{n+1}$。现在，考虑一种对边界条件的不当处理：在完成反应步骤后，该格式错误地通过设置 $c^{n+1}:=c_{\\mathrm{in}}$（而不是仅将其应用于运移子步骤）在单元内部重新施加狄利克雷边界。这是分裂格式中一个已知的陷阱，可能会违反全局质量平衡。\n\n您必须设计并执行一个诊断计算来检测这种违规。将诊断性质的质量平衡残差定义为：由处理不当的分裂步骤产生的最终单元质量，与根据平流输入（流入减去流出，即运移子步骤中实际使用的量）积分加上反应贡献（即反应子步骤中实际使用的量）所预测的质量之间的差值。使用以下物理上一致的参数集，在一个时间步后计算该诊断残差：\n- $L=\\Delta x = 0.10\\ \\mathrm{m}$,\n- $A = 1.0 \\times 10^{-3}\\ \\mathrm{m}^2$,\n- $\\phi = 0.25$,\n- $q = 1.0 \\times 10^{-5}\\ \\mathrm{m\\ s^{-1}}$,\n- $c_{\\mathrm{in}} = 1.0\\ \\mathrm{mol\\ m^{-3}}$,\n- $c^{n} = 0.20\\ \\mathrm{mol\\ m^{-3}}$,\n- $k = 1.0 \\times 10^{-6}\\ \\mathrm{s}^{-1}$,\n- $\\Delta t = 1.0 \\times 10^{3}\\ \\mathrm{s}$.\n\n将您的最终答案表示为以 mol 为单位的诊断残差。将答案四舍五入到四位有效数字。",
            "solution": "我们从一个宽度为 $\\Delta x$、横截面积为 $A$、孔隙度为 $\\phi$ 的有限体积控制体内的质量守恒定律开始。单元中的总质量为 $M(t)=\\phi A \\Delta x\\,c(t)$。在一个时间步 $\\Delta t$ 内，精确的质量平衡会将质量变化量等同于时间积分后的净流入（流入减去流出）加上时间积分后的反应源/汇项。在分裂格式中，我们必须与每个子步骤中实际使用的贡献项保持一致。\n\n我们使用顺序非迭代法 (SNIA)：首先在 $\\Delta t$ 时间内进行运移（平流），然后在 $\\Delta t$ 时间内进行反应。采用迎风平流和显式时间积分，运移子步骤使用根据 $t^{n}$ 时刻的已知浓度计算的入口和出口平流通量：\n- $x=0$ 处的入流平流通量：$F_{\\mathrm{in}}^{n} = A q\\, c_{\\mathrm{in}}$，\n- $x=L$ 处的出流平流通量：$F_{\\mathrm{out}}^{n} = A q\\, c^{n}$。\n\n平流的有限体积显式更新给出中间浓度 $c^{*}$：\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; \\frac{\\Delta t}{\\phi A \\Delta x}\\,\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; c^{n} \\;+\\; \\frac{\\Delta t\\, q}{\\phi\\, \\Delta x}\\,\\big(c_{\\mathrm{in}} - c^{n}\\big).\n$$\n\n然后，反应子步骤对一级衰减 $R(c)=-k\\,c$ 使用显式欧拉法，并应用于 $c^{*}$：\n\n$$\nc^{n+1}_{\\mathrm{scheme}} \\;=\\; c^{*} \\;+\\; \\Delta t\\,(-k\\,c^{*}) \\;=\\; c^{*}\\,(1 - k\\,\\Delta t).\n$$\n\n如果边界条件处理正确（即仅应用于运移子步骤），则两个子步骤后的最终质量将为 $M^{n+1}_{\\mathrm{scheme}}=\\phi A \\Delta x\\,c^{n+1}_{\\mathrm{scheme}}$，并且离散质量平衡恒等式将得到满足：\n\n$$\nM^{n+1}_{\\mathrm{scheme}} \\;=\\; M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big).\n$$\n\n然而，所描述的不当边界处理在反应步骤之后将最终浓度重置为 $c_{\\mathrm{in}}$：$c^{n+1}_{\\mathrm{mis}} := c_{\\mathrm{in}}$。由此产生的最终质量为 $M^{n+1}_{\\mathrm{mis}} = \\phi A \\Delta x\\, c_{\\mathrm{in}}$。诊断残差定义为此处理不当的最终质量与分裂步骤中使用的贡献项之和之间的差值：\n\n$$\nR_{\\mathrm{diag}} \\;=\\; M^{n+1}_{\\mathrm{mis}} \\;-\\; \\Big[\\, M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\\,\\Big].\n$$\n\n根据构造，一个一致的分裂格式应该有 $R_{\\mathrm{diag}}=0$，因此任何非零值都表明违反了质量平衡。\n\n我们现在用给定的参数计算 $R_{\\mathrm{diag}}$。首先，计算平流通量：\n\n$$\nF_{\\mathrm{in}}^{n} \\;=\\; A q\\, c_{\\mathrm{in}} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(1.0\\big) \\;=\\; 1.0 \\times 10^{-8},\n$$\n\n\n$$\nF_{\\mathrm{out}}^{n} \\;=\\; A q\\, c^{n} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(0.20\\big) \\;=\\; 2.0 \\times 10^{-9}.\n$$\n\n单元中的初始质量为\n\n$$\nM^{n} \\;=\\; \\phi A \\Delta x\\, c^{n} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(0.20\\big) \\;=\\; 5.0 \\times 10^{-6}.\n$$\n\n从平流子步骤计算中间浓度 $c^{*}$：\n\n$$\n\\frac{\\Delta t\\, q}{\\phi\\, \\Delta x} \\;=\\; \\frac{\\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)}{\\big(0.25\\big)\\,\\big(0.10\\big)} \\;=\\; \\frac{1.0 \\times 10^{-2}}{2.5 \\times 10^{-2}} \\;=\\; 0.40,\n$$\n\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; 0.40\\,\\big(c_{\\mathrm{in}} - c^{n}\\big) \\;=\\; 0.20 \\;+\\; 0.40\\,\\big(1.0 - 0.20\\big) \\;=\\; 0.20 \\;+\\; 0.40 \\times 0.80 \\;=\\; 0.52.\n$$\n\n分裂步骤中使用的反应贡献项是\n\n$$\n\\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\n\\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0 \\times 10^{3}\\big)\\,\\big(-1.0 \\times 10^{-6}\\big)\\,\\big(0.52\\big)\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big)\\,\\big(-5.2 \\times 10^{-4}\\big)\n\\;=\\; -1.3 \\times 10^{-8}.\n$$\n\n在 $\\Delta t$ 内的净平流质量输入为\n\n$$\n\\Delta t\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-8} - 2.0 \\times 10^{-9}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(8.0 \\times 10^{-9}\\big)\n\\;=\\; 8.0 \\times 10^{-6}.\n$$\n\n处理不当的最终质量为\n\n$$\nM^{n+1}_{\\mathrm{mis}} \\;=\\; \\phi A \\Delta x\\, c_{\\mathrm{in}} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0\\big) \\;=\\; 2.5 \\times 10^{-5}.\n$$\n\n因此，诊断残差为\n\n$$\nR_{\\mathrm{diag}} \\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\Big[\\, \\big(5.0 \\times 10^{-6}\\big) \\;+\\; \\big(8.0 \\times 10^{-6}\\big) \\;+\\; \\big(-1.3 \\times 10^{-8}\\big) \\,\\Big]\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\big(1.2987 \\times 10^{-5}\\big)\n\\;=\\; 1.2013 \\times 10^{-5}.\n$$\n\n四舍五入到四位有效数字并以 mol 为单位表示，诊断残差为 $1.201 \\times 10^{-5}$。一个非零的正值 $R_{\\mathrm{diag}}$ 表明，在反应步骤后将单元浓度不当地重置为狄利克雷边界值，注入了运移和反应子步骤未曾计入的额外质量。在顺序迭代法（SIA）中，迭代耦合的子步骤同时保持边界条件的一致性，将会使 $R_{\\mathrm{diag}}$ 趋于零，从而恢复全局质量平衡。",
            "answer": "$$\\boxed{1.201 \\times 10^{-5}}$$"
        }
    ]
}