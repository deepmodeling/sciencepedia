{
    "hands_on_practices": [
        {
            "introduction": "To build a solid understanding of operator splitting, we begin with a foundational exercise that explores the method's mathematical underpinnings. This practice involves applying a first-order Lie splitting scheme to the classic Advection-Diffusion-Reaction (ADR) equation . By both deriving the local truncation error in terms of operator commutators and numerically verifying the scheme's convergence order, you will gain direct insight into why splitting introduces an error and how that error depends on the non-commutativity of the underlying physical processes.",
            "id": "4079402",
            "problem": "Consider a one-dimensional Advection–Diffusion–Reaction (ADR) Partial Differential Equation (PDE) for a scalar concentration field $C(x,t)$ on a periodic spatial domain $x \\in [0,L]$ and time $t \\ge 0$, with spatially varying advection velocity $v(x)$, constant molecular diffusion coefficient $D$, and spatially varying first-order reaction rate $k(x)$. The governing equation is\n$$\n\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t),\n$$\nsubject to periodic boundary conditions and a smooth periodic initial condition. The Advection–Diffusion–Reaction (ADR) processes arise in Computational Geochemistry when modeling the transport and transformation of aqueous species in porous media and reactive flows.\n\nTask 1 (Derivation): Starting from the definitions of the advection operator $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$, the diffusion operator $\\mathcal{D} u = D\\,\\partial_{xx} u$, and the reaction operator $\\mathcal{R} u = -\\,k(x)\\,u$, derive a first-order Lie operator splitting for one time step $\\Delta t$ that evolves $C(x,t)$ by sequentially solving subproblems for advection, diffusion, and reaction over the same $\\Delta t$ in the order advection, then diffusion, then reaction. Use a principle-based derivation starting from semigroup composition, and quantify the leading-order local splitting error in terms of commutators of the operators. Your derivation must start from fundamental definitions of linear operators and the composition of flows; do not use pre-stated shortcut formulas or give the final commutator result without derivation.\n\nTask 2 (Implementation): Implement a numerical algorithm that realizes the first-order Lie splitting you derived. Use a spatially discrete periodic grid and the following numerical procedures:\n- For advection substeps, solve the Ordinary Differential Equation (ODE) semi-discrete system $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C}$ over one substep $\\Delta t$ with a high-accuracy ODE integrator. Here $\\mathbf{C}$ is the vector of concentration values at grid points, $\\mathbf{v}$ is the vector of advection speeds at grid points, $\\odot$ denotes componentwise multiplication, and $\\partial_x \\mathbf{C}$ is the spectral first derivative computed via the Fast Fourier Transform (FFT) on the periodic domain.\n- For diffusion substeps, evolve $\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C}$ exactly in Fourier space over one substep $\\Delta t$ by multiplying each Fourier mode by $\\exp(-D\\,k^2\\,\\Delta t)$, where $k$ is the angular wavenumber.\n- For reaction substeps, evolve $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C}$ exactly over one substep $\\Delta t$ by multiplying componentwise by $\\exp(-\\mathbf{k}\\,\\Delta t)$.\n\nTo quantify the splitting error, compute a high-accuracy unsplit reference solution $\\mathbf{C}_{\\text{ref}}(T)$ by solving the full semi-discrete ADR system\n$$\n\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}\n$$\nfrom $t = 0$ to $t = T$ using a high-order adaptive ODE integrator with tight tolerances. Then compute the relative discrete $\\ell^2$-error at the final time $T$,\n$$\nE \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2},\n$$\nwhere $\\left\\|\\cdot\\right\\|_2$ is the Euclidean norm on the grid. Report this error as a dimensionless decimal.\n\nDomain, coefficients, and initial condition:\n- Domain length $L$ in meters is $L = 1$ with periodic boundary conditions.\n- Grid size $N$ is $N = 128$ uniformly spaced points.\n- Advection velocity $v(x) = v_0 + v_1\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)$ with $v_0$ in meters per second and $v_1$ in meters per second.\n- Diffusion coefficient $D$ in square meters per second is constant.\n- Reaction rate $k(x) = k_0 + k_1\\,\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)$ with $k_0$ in per second and $k_1$ in per second.\n- Initial condition $C(x,0) = C_0\\,\\left[1 + a\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\right]$ with $C_0$ an arbitrary concentration unit and $a$ dimensionless amplitude. Since the requested outputs are error norms and ratios, they are dimensionless; no physical units are required in the final outputs.\n\nTime parameters:\n- Final time $T$ in seconds and splitting time step $\\Delta t$ in seconds will be specified per test case. Ensure that $T$ is an integer multiple of $\\Delta t$.\n\nTest Suite:\nImplement your program to evaluate the following four test cases and aggregate the results:\n- Case $1$ (general variable-coefficient ADR):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_1$ at $t = T$ as a decimal.\n- Case $2$ (order verification via halving the time step):\n  - Same parameters as Case $1$.\n  - Compute $E_{\\Delta t}$ for $\\Delta t = T/40$ and $E_{\\Delta t/2}$ for $\\Delta t = T/80$, and output the ratio $R = E_{\\Delta t}/E_{\\Delta t/2}$ as a decimal to assess first-order global accuracy.\n- Case $3$ (no diffusion):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.25$, $D = 0.0$, $k_0 = 1.0$, $k_1 = 0.5$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_3$ at $t = T$ as a decimal.\n- Case $4$ (constant coefficients, expected near-zero splitting error):\n  - $L = 1$, $N = 128$, $v_0 = 0.5$, $v_1 = 0.0$, $D = 0.001$, $k_0 = 1.0$, $k_1 = 0.0$, $C_0 = 1.0$, $a = 0.5$, $T = 0.1$, $\\Delta t = T/40$.\n  - Output the relative $\\ell^2$-error $E_4$ at $t = T$ as a decimal.\n\nFinal Output Format:\nYour program should produce a single line of output containing the results from the four test cases as a comma-separated list enclosed in square brackets, in the order $[E_1, R, E_3, E_4]$. For example, the program must print one line exactly of the form $[E_1,R,E_3,E_4]$ with no additional text. All outputs are dimensionless decimals.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n-   **Governing Equation**: The one-dimensional Advection–Diffusion–Reaction (ADR) PDE is $\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t)$.\n-   **Domain and Conditions**: $x \\in [0,L]$, $t \\ge 0$, with periodic boundary conditions and a smooth periodic initial condition.\n-   **Operator Definitions**: Advection operator $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$, diffusion operator $\\mathcal{D} u = D\\,\\partial_{xx} u$, and reaction operator $\\mathcal{R} u = -\\,k(x)\\,u$.\n-   **Task 1 (Derivation)**: Derive a first-order Lie operator splitting of the form Advection-Diffusion-Reaction, evolving the solution by $\\Delta t$ by sequentially solving each subproblem. The derivation must start from semigroup composition and quantify the leading-order local splitting error using operator commutators.\n-   **Task 2 (Implementation)**: Implement a numerical algorithm for the Lie splitting.\n    -   Advection substep $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C})$: Use a high-accuracy ODE integrator, with spectral differentiation (FFT).\n    -   Diffusion substep $(\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C})$: Use exact evolution in Fourier space.\n    -   Reaction substep $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C})$: Use exact componentwise evolution.\n-   **Error Analysis**: Compare the split solution to a high-accuracy unsplit reference solution obtained by integrating the full semi-discrete system $\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}$ with a high-order adaptive ODE integrator. The error metric is the relative discrete $\\ell^2$-norm $E \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}$.\n-   **Parameters**:\n    -   Domain: $L = 1$, grid size $N=128$.\n    -   Coefficients: $v(x) = v_0 + v_1\\,\\sin(2\\pi x/L)$, $D$ is constant, $k(x) = k_0 + k_1\\,\\cos(2\\pi x/L)$.\n    -   Initial condition: $C(x,0) = C_0\\,[1 + a\\,\\sin(2\\pi x/L)]$.\n-   **Test Cases**: Four specific cases are defined with all parameter values ($v_0, v_1, D, k_0, k_1, C_0, a, T, \\Delta t$) provided to compute specific error metrics $E_1, R, E_3, E_4$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is analyzed against the validation criteria.\n-   **Scientific Grounding**: The ADR equation is a fundamental model in transport phenomena, central to fields like geochemistry. The operator definitions, boundary conditions, and functional forms for coefficients are standard and scientifically sound. The proposed numerical methods (operator splitting, spectral methods, high-order ODE integration) are established techniques in scientific computing. The problem is scientifically and mathematically sound.\n-   **Well-Posedness and Consistency**: The problem is well-posed. The ADR equation with the specified smooth coefficients and periodic boundary conditions constitutes a well-posed initial-boundary value problem. All necessary parameters and methods are defined, making the problem self-contained and unambiguous. The instruction to use a \"high-accuracy ODE integrator\" is standard practice and is readily satisfied by library routines like SciPy's `solve_ivp` with appropriate methods and tolerances.\n-   **Objectivity and Feasibility**: The problem is stated in precise, objective mathematical language. The parameter values are physically plausible for a model system and do not lead to infeasible computations. The tasks are concrete and verifiable.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound, and non-trivial problem in numerical analysis and computational science. A solution will be provided.\n\n### Solution\n\nThe solution is presented in two parts as requested: a theoretical derivation followed by an outline of the numerical implementation.\n\n#### Task 1: Derivation of Lie Splitting and Error Analysis\n\nThe governing Advection-Diffusion-Reaction (ADR) equation is\n$$\n\\frac{\\partial C}{\\partial t} = \\mathcal{A}C + \\mathcal{D}C + \\mathcal{R}C = (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})C\n$$\nwhere $\\mathcal{A} = -v(x)\\partial_x$, $\\mathcal{D} = D\\partial_{xx}$, and $\\mathcal{R} = -k(x)$ are linear operators representing advection, diffusion, and reaction, respectively. Let $\\mathcal{L} = \\mathcal{A} + \\mathcal{D} + \\mathcal{R}$ be the total evolution operator.\n\nThe formal solution to this linear PDE over a time interval $\\Delta t$ can be expressed using the concept of a semigroup, represented by the operator exponential:\n$$\nC(t+\\Delta t) = e^{\\Delta t \\mathcal{L}} C(t) = e^{\\Delta t (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})} C(t)\n$$\nOperator splitting methods approximate the exponential of a sum of operators by a product of exponentials of the individual operators. The first-order Lie splitting scheme, for the specified order of advection, then diffusion, then reaction, approximates the exact solution propagator $e^{\\Delta t \\mathcal{L}}$ by the composition of propagators for each subproblem:\n$$\n\\Phi_{\\text{split}}(\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}}\n$$\nApplying this to the solution at time $t$ gives the approximate solution at $t+\\Delta t$:\n$$\nC_{\\text{split}}(t+\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} C(t)\n$$\nThis corresponds to solving three separate, simpler PDEs sequentially over the time step $\\Delta t$:\n1.  **Advection**: $\\frac{\\partial C^*}{\\partial t} = \\mathcal{A}C^*$, solved from $C(t)$ to get $C^*(\\Delta t) = e^{\\Delta t \\mathcal{A}}C(t)$.\n2.  **Diffusion**: $\\frac{\\partial C^{**}}{\\partial t} = \\mathcal{D}C^{**}$, solved from $C^*(\\Delta t)$ to get $C^{**}(\\Delta t) = e^{\\Delta t \\mathcal{D}}C^*(\\Delta t)$.\n3.  **Reaction**: $\\frac{\\partial C^{*** }}{\\partial t} = \\mathcal{R}C^{*** }$, solved from $C^{**}(\\Delta t)$ to get $C^{***}(\\Delta t) = e^{\\Delta t \\mathcal{R}}C^{**}(\\Delta t)$.\nThe final result is $C_{\\text{split}}(t+\\Delta t) = C^{***}(\\Delta t)$.\n\nThe local truncation error is the difference between the action of the split and exact propagators. To find the leading-order term, we expand both propagators in a Taylor series in $\\Delta t$.\n\nThe exact propagator expands as:\n$$\ne^{\\Delta t \\mathcal{L}} = I + \\Delta t \\mathcal{L} + \\frac{(\\Delta t \\mathcal{L})^2}{2!} + O(\\Delta t^3)\n$$\n$$\ne^{\\Delta t (\\mathcal{A}+\\mathcal{D}+\\mathcal{R})} = I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}+\\mathcal{D}+\\mathcal{R})^2 + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) + O(\\Delta t^3)\n$$\nThe split propagator is a product of exponentials:\n$$\ne^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} = \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t \\mathcal{D} + \\frac{\\Delta t^2}{2}\\mathcal{D}^2\\right) \\left(I + \\Delta t \\mathcal{A} + \\frac{\\Delta t^2}{2}\\mathcal{A}^2\\right) + O(\\Delta t^3)\n$$\nExpanding this product and retaining terms up to order $\\Delta t^2$:\n$$\n= \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t(\\mathcal{A}+\\mathcal{D}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA}\\right)\\right) + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD} + \\frac{\\mathcal{R}^2}{2}\\right) + O(\\Delta t^3)\n$$\nThe local error operator is the difference, $\\Phi_{\\text{split}}(\\Delta t) - e^{\\Delta t \\mathcal{L}}$. The terms of order $I$ and $\\Delta t$ cancel exactly. The difference of the $\\Delta t^2$ terms is:\n$$\n\\Delta t^2 \\left[ \\left(\\frac{\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD}\\right) - \\frac{1}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (2\\mathcal{DA} - (\\mathcal{AD}+\\mathcal{DA})) + (2\\mathcal{RA} - (\\mathcal{AR}+\\mathcal{RA})) + (2\\mathcal{RD} - (\\mathcal{DR}+\\mathcal{RD})) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (\\mathcal{DA} - \\mathcal{AD}) + (\\mathcal{RA} - \\mathcal{AR}) + (\\mathcal{RD} - \\mathcal{DR}) \\right]\n$$\nThis expression is simplified using the commutator notation $[\\mathcal{X}, \\mathcal{Y}] = \\mathcal{XY} - \\mathcal{YX}$:\n$$\n\\text{Error Term} = \\frac{\\Delta t^2}{2} \\left( [\\mathcal{D}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{D}] \\right)\n$$\nThe local truncation error is of order $O(\\Delta t^2)$. Since approximately $N_{\\text{steps}} = T/\\Delta t$ steps are taken to reach the final time $T$, the global error accumulates to be of order $N_{\\text{steps}} \\times O(\\Delta t^2) \\sim (T/\\Delta t) \\times O(\\Delta t^2) \\sim O(\\Delta t)$. The Lie splitting is therefore a first-order accurate method. The splitting error vanishes if and only if all the operators commute, i.e., $[\\mathcal{D}, \\mathcal{A}]=0$, $[\\mathcal{R}, \\mathcal{A}]=0$, and $[\\mathcal{R}, \\mathcal{D}]=0$. This occurs when the coefficients $v(x)$ and $k(x)$ are constants.\n\n#### Task 2: Numerical Implementation Strategy\n\nThe numerical implementation follows the derived splitting scheme on a discrete grid and compares its accuracy against a reference solution.\n\n1.  **Discretization**: The spatial domain $x \\in [0, L]$ is discretized into $N$ uniformly spaced grid points $x_j = j L/N$ for $j=0, \\dots, N-1$. The concentration field $C(x,t)$ becomes a vector $\\mathbf{C}(t)$ of length $N$, where $C_j(t) \\approx C(x_j, t)$. The functions $v(x)$ and $k(x)$ become vectors $\\mathbf{v}$ and $\\mathbf{k}$.\n\n2.  **Reference Solution**: A high-accuracy reference solution $\\mathbf{C}_{\\text{ref}}(T)$ is computed by solving the fully-coupled semi-discrete ODE system,\n    $$\n    \\frac{d\\mathbf{C}}{dt} = \\mathcal{L}\\mathbf{C} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C}) + D (\\partial_{xx} \\mathbf{C}) - \\mathbf{k} \\odot \\mathbf{C}\n    $$\n    from $t=0$ to $t=T$. The spatial derivatives $\\partial_x \\mathbf{C}$ and $\\partial_{xx} \\mathbf{C}$ are computed spectrally using the Fast Fourier Transform (FFT), which is highly accurate for periodic functions. The integration in time is performed using a high-order adaptive-step solver, specifically `scipy.integrate.solve_ivp` with the `DOP853` method and stringent error tolerances (e.g., `rtol=1e-12`, `atol=1e-14`).\n\n3.  **Split Solution**: The split solution $\\mathbf{C}_{\\text{split}}(T)$ is computed by iterating $N_{\\text{steps}} = T/\\Delta t$ times. In each step from $t$ to $t+\\Delta t$:\n    -   **Advection Step**: The ODE system $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C})$ is solved over one time step $\\Delta t$, again using `solve_ivp` with `DOP853` and tight tolerances. The spectral method is used for $\\partial_x \\mathbf{C}$.\n    -   **Diffusion Step**: The system $\\frac{d\\mathbf{C}}{dt} = D (\\partial_{xx} \\mathbf{C})$ is solved exactly in Fourier space. Taking the FFT of the state vector $\\mathbf{C}$, we get $\\hat{\\mathbf{C}}$. The ODE becomes $\\frac{d\\hat{C}_m}{dt} = D(i\\omega_m)^2 \\hat{C}_m = -D\\omega_m^2 \\hat{C}_m$ for each Fourier mode $m$ with angular wavenumber $\\omega_m$. The exact solution is $\\hat{C}_m(\\Delta t) = \\hat{C}_m(0) e^{-D\\omega_m^2 \\Delta t}$. The state vector is updated by `ifft(fft(C) * exp(-D*omega**2*dt))`.\n    -   **Reaction Step**: The system $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{k} \\odot \\mathbf{C}$ is a set of uncoupled ODEs, $dC_j/dt = -k_j C_j$. The solution is $C_j(\\Delta t) = C_j(0) e^{-k_j \\Delta t}$. The state vector is updated by componentwise multiplication: $\\mathbf{C} \\leftarrow \\mathbf{C} \\odot e^{-\\mathbf{k}\\Delta t}$.\n\n4.  **Error Calculation and Test Cases**:\n    -   The relative $\\ell^2$-error between the split and reference solutions is computed at $T$.\n    -   **Case 1** measures the error for a general ADR problem with variable coefficients.\n    -   **Case 2** verifies the first-order convergence of the splitting method. The error $E$ is proportional to $\\Delta t$, so the ratio of errors $E_{\\Delta t}/E_{\\Delta t/2}$ should be approximately $2$.\n    -   **Case 3** ($D=0$) isolates the splitting error from the non-commuting advection and reaction operators ($[\\mathcal{R}, \\mathcal{A}] \\neq 0$).\n    -   **Case 4** ($v_1=0, k_1=0$) makes the advection and reaction coefficients constant. As shown in the derivation, all commutators become zero. The theoretical splitting error is zero. The measured error $E_4$ will be a small number reflecting the numerical precision of the ODE solvers and floating-point arithmetic, demonstrating the correctness of the commutator analysis.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the ADR equation using Lie splitting and compares it to a reference\n    solution to quantify splitting error for four different test cases.\n    \"\"\"\n\n    def run_simulation(L, N, v0, v1, D, k0, k1, C0, a, T, dt, use_split_method):\n        \"\"\"\n        Runs a single simulation, either the full reference or the split method.\n        \"\"\"\n        # 1. Setup grid, initial condition, and parameters\n        x = np.linspace(0, L, N, endpoint=False)\n        v = v0 + v1 * np.sin(2 * np.pi * x / L)\n        k_rate = k0 + k1 * np.cos(2 * np.pi * x / L)\n        C_initial = C0 * (1 + a * np.sin(2 * np.pi * x / L))\n\n        # Wavenumbers for spectral derivatives\n        # fftfreq returns frequencies in cycles per unit of sample spacing (dx=L/N)\n        # We convert to angular wavenumbers (radians per unit length)\n        dx = L / N\n        angular_wavenumbers = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define derivative functions and RHS of the full PDE\n        def d_dx(C_vec):\n            return np.real(ifft(1j * angular_wavenumbers * fft(C_vec)))\n\n        def d2_dx2(C_vec):\n            return np.real(ifft(-angular_wavenumbers**2 * fft(C_vec)))\n\n        def full_rhs(t, C_vec):\n            dC_advection = -v * d_dx(C_vec)\n            dC_diffusion = D * d2_dx2(C_vec)\n            dC_reaction = -k_rate * C_vec\n            return dC_advection + dC_diffusion + dC_reaction\n\n        # 3. Compute solution\n        if not use_split_method:\n            # High-accuracy reference solution\n            sol = solve_ivp(full_rhs, (0, T), C_initial, method='DOP853', rtol=1e-12, atol=1e-14)\n            return sol.y[:, -1]\n        else:\n            # Lie splitting solution\n            def advection_rhs(t, C_vec):\n                return -v * d_dx(C_vec)\n            \n            C = C_initial.copy()\n            num_steps = int(round(T / dt))\n\n            for _ in range(num_steps):\n                # Step 1: Advection substep\n                sol_adv = solve_ivp(advection_rhs, (0, dt), C, method='DOP853', rtol=1e-12, atol=1e-12)\n                C = sol_adv.y[:, -1]\n\n                # Step 2: Diffusion substep (exact in Fourier space)\n                C_hat = fft(C)\n                C_hat *= np.exp(-D * angular_wavenumbers**2 * dt)\n                C = np.real(ifft(C_hat))\n\n                # Step 3: Reaction substep (exact pointwise)\n                C *= np.exp(-k_rate * dt)\n            \n            return C\n\n    def calculate_error(params, dt):\n        \"\"\"Helper to compute error for a given dt.\"\"\"\n        C_ref = run_simulation(**params, dt=dt, use_split_method=False)\n        C_split = run_simulation(**params, dt=dt, use_split_method=True)\n        error = np.linalg.norm(C_split - C_ref) / np.linalg.norm(C_ref)\n        return error\n\n    results = []\n\n    # --- Test Case 1 ---\n    # General ADR with variable coefficients\n    params1 = {'L': 1.0, 'N': 128, 'v0': 0.5, 'v1': 0.25, 'D': 0.001, 'k0': 1.0, 'k1': 0.5, 'C0': 1.0, 'a': 0.5, 'T': 0.1}\n    dt1 = params1['T'] / 40.0\n    E1 = calculate_error(params1, dt1)\n    results.append(E1)\n\n    # --- Test Case 2 ---\n    # Order verification by halving the time step\n    params2 = params1\n    dt_large = params2['T'] / 40.0\n    dt_small = params2['T'] / 80.0\n    E_dt = calculate_error(params2, dt_large)\n    E_dthalf = calculate_error(params2, dt_small)\n    R = E_dt / E_dthalf\n    results.append(R)\n\n    # --- Test Case 3 ---\n    # No diffusion (D=0)\n    params3 = params1.copy()\n    params3['D'] = 0.0\n    dt3 = params3['T'] / 40.0\n    E3 = calculate_error(params3, dt3)\n    results.append(E3)\n\n    # --- Test Case 4 ---\n    # Constant coefficients (v1=0, k1=0), commuting operators\n    params4 = params1.copy()\n    params4['v1'] = 0.0\n    params4['k1'] = 0.0\n    dt4 = params4['T'] / 40.0\n    E4 = calculate_error(params4, dt4)\n    results.append(E4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Moving from linear transport to the complexities of geochemistry, our next practice focuses on a common scenario: mineral precipitation from a supersaturated solution . This benchmark problem requires you to implement and compare the two most prevalent splitting schemes, the Sequential Non-Iterative Approach (SNIA) and the Sequential Iterative Approach (SIA). By contrasting these methods against a high-accuracy reference solution for a system with non-linear reaction kinetics, you will develop a practical understanding of the accuracy-cost trade-off and the importance of iterative coupling in stiff geochemical systems.",
            "id": "4094620",
            "problem": "Construct a zero-dimensional batch-reactor benchmark to evaluate operator splitting methods in reactive transport for carbonate precipitation. The aqueous system contains dissolved calcium and carbonate that can precipitate as a solid carbonate mineral when supersaturation occurs. The governing evolution is based on conservation of mass and a precipitation rate law derived from mass action. The objective is to compute the mass of solid carbonate formed and to compare sequential operator-splitting schemes against a monolithic unsplit reference.\n\nAssumptions and definitions:\n- The reactor volume is constant and equal to $1$ liter, so species amounts in moles equal concentrations in $\\mathrm{mol/L}$.\n- Let $C_{\\mathrm{Ca}}(t)$ and $C_{\\mathrm{CO_3}}(t)$ denote the dissolved calcium and carbonate concentrations, respectively, and $S(t)$ denote the cumulative precipitated solid carbonate amount (in $\\mathrm{mol/L}$).\n- Precipitation kinetics follow a mass-action rate:\n  $$ r(t) \\;=\\; k \\,\\max\\!\\left(0,\\, C_{\\mathrm{Ca}}(t)\\,C_{\\mathrm{CO_3}}(t) \\;-\\; K_{\\mathrm{sp}} \\right), $$\n  where $k$ has units $\\mathrm{L\\,mol^{-1}\\,s^{-1}}$ and $K_{\\mathrm{sp}}$ is the solubility product in $\\mathrm{(mol/L)^2}$. Activities are assumed equal to concentrations (unit activity coefficients).\n- Mass balance in the batch reactor with a time-dependent source term for carbonate is\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} \\;=\\; J_{\\mathrm{Ca}}(t) \\;-\\; r(t), \\qquad \\frac{dC_{\\mathrm{CO_3}}}{dt} \\;=\\; J_{\\mathrm{CO_3}}(t) \\;-\\; r(t), \\qquad \\frac{dS}{dt} \\;=\\; r(t). $$\n- There is no calcium source, so $J_{\\mathrm{Ca}}(t) \\equiv 0$. The carbonate source is a square pulse defined by\n  $$ J_{\\mathrm{CO_3}}(t) \\;=\\; \\begin{cases}\n  J_0, & 0 \\le t < t_{\\mathrm{inj}},\\\\\n  0, & t \\ge t_{\\mathrm{inj}},\n  \\end{cases} $$\n  with constant injection rate $J_0$ over a duration $t_{\\mathrm{inj}}$.\n\nOperator splitting methods to be implemented:\n- Sequential Non-Iterative Approach (SNIA): In each time step of size $\\Delta t$, first apply the transport operator (the source term) over $\\Delta t$, and then apply the reaction operator over $\\Delta t$ using an explicit forward Euler update with $r$ evaluated at the transported state. During the reaction update, enforce non-negativity by capping the consumption so that neither $C_{\\mathrm{Ca}}$ nor $C_{\\mathrm{CO_3}}$ becomes negative within the step. This yields a first-order accurate splitting in time.\n- Sequential Iterative Approach (SIA): In each time step of size $\\Delta t$, iterate between transport and reaction within the step to reduce the splitting error. Implement a fixed-point (Picard) iteration where the within-step update satisfies\n  $$ C^{(m+1)}_{\\mathrm{Ca}} \\;=\\; C^{n}_{\\mathrm{Ca}} \\;+\\; \\Delta t\\,J_{\\mathrm{Ca}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ C^{(m+1)}_{\\mathrm{CO_3}} \\;=\\; C^{n}_{\\mathrm{CO_3}} \\;+\\; \\Delta t\\,J_{\\mathrm{CO_3}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ S^{(m+1)} \\;=\\; S^{n} \\;+\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  with suitable capping to enforce non-negativity within each iteration and a fixed maximum number of iterations per step. Use the last iterate as the step update.\n- Monolithic unsplit reference: Solve the coupled ordinary differential equations for $C_{\\mathrm{Ca}}(t)$, $C_{\\mathrm{CO_3}}(t)$, and $S(t)$ over the time interval $[0,T]$ using an implicit stiff solver to high accuracy. The monolithic solution is taken as the reference for comparison.\n\nFundamental base for derivation:\n- Conservation of mass for each component with sources and sinks.\n- Mass-action kinetics for precipitation rate with a solubility product threshold.\n- Numerical operator splitting as a decomposition of the evolution operator into transport and reaction sub-operators.\n\nYour program must implement the three approaches above and compute the total precipitated solid at the final time $t=T$ for the following test suite. All parameters are in SI-consistent units for chemistry: concentrations in $\\mathrm{mol/L}$, time in $\\mathrm{s}$, and the solubility product $K_{\\mathrm{sp}}$ in $\\mathrm{(mol/L)^2}$. Report all requested outputs in $\\mathrm{mol/L}$.\n\nTest suite (three cases):\n- Case A (precipitation clearly triggered):\n  - $C_{\\mathrm{Ca}}(0) = 5\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 2\\times 10^{-3}$, $t_{\\mathrm{inj}} = 2$, $T=10$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n- Case B (near-equilibrium start, slight supersaturation pulse):\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = K_{\\mathrm{sp}}/C_{\\mathrm{Ca}}(0) = 3.3\\times 10^{-6}$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 5\\times 10^{-7}$, $t_{\\mathrm{inj}} = 1$, $T=10$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n- Case C (no precipitation expected):\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-6}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$.\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$.\n  - $J_0 = 1\\times 10^{-5}$, $t_{\\mathrm{inj}} = 0.1$, $T=5$.\n  - Time step for splitting: $\\Delta t = 0.05$.\n\nAlgorithmic details to enforce:\n- In SNIA and SIA, during any reaction update over a time step of size $\\Delta t$, the consumption $\\Delta c = r\\,\\Delta t$ must be capped as $\\Delta c \\le \\min\\!\\left(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}\\right)$ to avoid negative concentrations. Use the rate law as stated above with $r \\ge 0$ and $r=0$ if undersaturated.\n- In SIA, use a fixed number of iterations per time step equal to $8$ and a convergence check with a tolerance of $10^{-12}$ in the max-norm; terminate early if converged.\n- In the monolithic reference, use a stiff implicit integrator with tight tolerances to approximate the exact solution over $[0,T]$.\n\nRequired outputs for each case:\n- The program must compute five floats for each case:\n  - $S_{\\mathrm{ref}}(T)$ from the monolithic unsplit reference,\n  - $S_{\\mathrm{SNIA}}(T)$ from the Sequential Non-Iterative Approach,\n  - $S_{\\mathrm{SIA}}(T)$ from the Sequential Iterative Approach,\n  - $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$,\n  - $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$.\n- Express each value in $\\mathrm{mol/L}$ rounded to eight decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must be formed by concatenating, in order, the five rounded floats for Case A, then for Case B, then for Case C. For example, your output must look like\n  $$ [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10},x_{11},x_{12},x_{13},x_{14},x_{15}] $$\n  where each $x_i$ is a decimal with eight digits after the decimal point, representing the required quantities in $\\mathrm{mol/L}$ for the three cases.",
            "solution": "The user has provided a problem statement for a computational geochemistry benchmark. The first step, as per protocol, is to validate the problem statement.\n\n### Step 1: Extract Givens\n- **System variables:** $C_{\\mathrm{Ca}}(t)$ (dissolved calcium concentration, $\\mathrm{mol/L}$), $C_{\\mathrm{CO_3}}(t)$ (dissolved carbonate concentration, $\\mathrm{mol/L}$), $S(t)$ (precipitated solid carbonate, $\\mathrm{mol/L}$). Reactor volume is $1$ L.\n- **Precipitation kinetics:** $r(t) = k \\cdot \\max(0, C_{\\mathrm{Ca}}(t)C_{\\mathrm{CO_3}}(t) - K_{\\mathrm{sp}})$, where $k$ is the rate constant ($\\mathrm{L\\,mol^{-1}\\,s^{-1}}$) and $K_{\\mathrm{sp}}$ is the solubility product ($\\mathrm{(mol/L)^2}$).\n- **Mass balance equations (ODEs):**\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} = J_{\\mathrm{Ca}}(t) - r(t) $$\n  $$ \\frac{dC_{\\mathrm{CO_3}}}{dt} = J_{\\mathrm{CO_3}}(t) - r(t) $$\n  $$ \\frac{dS}{dt} = r(t) $$\n- **Source terms:** $J_{\\mathrm{Ca}}(t) = 0$. $J_{\\mathrm{CO_3}}(t)$ is a square pulse: $J_0$ for $0 \\le t < t_{\\mathrm{inj}}$ and $0$ for $t \\ge t_{\\mathrm{inj}}$.\n- **Numerical schemes:**\n    1.  **Monolithic:** High-accuracy implicit stiff ODE solver for the reference solution.\n    2.  **SNIA (Sequential Non-Iterative Approach):** First-order splitting.\n        - Transport step: Update concentrations with source terms over $\\Delta t$.\n        - Reaction step: Explicit Euler update using rate evaluated at the transported state.\n        - Capping: Consumption $\\Delta c = r\\Delta t$ is limited by reactant availability, i.e., $\\Delta c \\le \\min(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}})$ post-transport.\n    3.  **SIA (Sequential Iterative Approach):** Picard iteration within each time step $\\Delta t$.\n        - Update rule: $C^{(m+1)} = C^n + \\Delta t(J - r(C^{(m)}))$.\n        - Maximum iterations: $8$.\n        - Convergence tolerance: $10^{-12}$ in max-norm.\n        - Capping: Non-negativity must be enforced within each iteration.\n- **Test Cases:** Three distinct cases (A, B, C) are provided with specific initial conditions, parameters ($K_{\\mathrm{sp}}, k$), source terms ($J_0, t_{\\mathrm{inj}}$), and simulation times ($T, \\Delta t$).\n- **Required Outputs:** For each case, report five values rounded to eight decimal places: $S_{\\mathrm{ref}}(T)$, $S_{\\mathrm{SNIA}}(T)$, $S_{\\mathrm{SIA}}(T)$, and the absolute errors $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$ and $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$.\n\n### Step 2: Validate Using Extracted Givens\nThe problem is critically evaluated against the validation criteria:\n- **Scientifically Grounded:** The problem is based on fundamental principles of mass conservation and standard mass-action chemical kinetics. The formulation as a system of ordinary differential equations (ODEs) is a standard approach in modeling batch reactors. The problem is scientifically sound.\n- **Well-Posed:** The problem defines a system of first-order ODEs with specified initial conditions and a piecewise-constant forcing function. The rate function is continuous and Lipschitz, which guarantees the existence and uniqueness of a solution. All required parameters and algorithmic details are provided. The problem is well-posed.\n- **Objective:** The problem is stated using precise mathematical definitions and objective, quantitative language. There is no ambiguity or subjective content.\n- **Completeness and Consistency:** The problem is self-contained. All necessary data, initial conditions, constants, and algorithmic constraints are provided. There are no contradictions in the setup.\n- **Realism and Feasibility:** The chosen parameters for concentrations, rate constants, and time scales are plausible for aqueous carbonate chemistry, making this a realistic benchmark problem.\n\n### Step 3: Verdict and Action\nThe problem is **valid**. It is a well-defined, scientifically sound, and non-trivial benchmark for comparing numerical methods in reactive transport modeling. A solution will be provided.\n\n### Solution Design\n\nThe solution will be implemented in Python, adhering to the specified environment. The problem requires evaluating three different numerical methods for solving a system of ODEs that describe carbonate precipitation in a batch reactor.\n\n**1. Monolithic (Reference) Solution**\nThe reference solution is obtained by solving the coupled system of ODEs monolithically, meaning all terms (sources and reactions) are treated simultaneously. Given the potential for stiffness (due to fast reaction kinetics compared to source injection), a stiff implicit solver is appropriate.\nThe system is defined as $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$, where $\\mathbf{y} = [C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}, S]^T$. The vector function $\\mathbf{f}$ is:\n$$ \\mathbf{f}(t, \\mathbf{y}) = \\begin{bmatrix} -r(y_1, y_2) \\\\ J_{\\mathrm{CO_3}}(t) - r(y_1, y_2) \\\\ r(y_1, y_2) \\end{bmatrix} $$\nwhere $y_1=C_{\\mathrm{Ca}}$ and $y_2=C_{\\mathrm{CO_3}}$. We will use `scipy.integrate.solve_ivp` with the `BDF` (Backward Differentiation Formula) method and tight tolerances ($rtol=10^{-12}$, $atol=10^{-15}$) to ensure a high-accuracy reference solution.\n\n**2. Sequential Non-Iterative Approach (SNIA)**\nThis is a first-order operator splitting method. Over each time step $\\Delta t$ from $t_n$ to $t_{n+1}$, we sequentially apply the transport and reaction operators.\n- **Transport Step:** First, we account for the external source terms. Let $\\mathbf{C}^n = [C_{\\mathrm{Ca}}^n, C_{\\mathrm{CO_3}}^n]^T$.\n  $$ \\mathbf{C}^* = \\mathbf{C}^n + \\Delta t \\, \\mathbf{J}(t_n) $$\n  where $\\mathbf{J}(t_n) = [0, J_{\\mathrm{CO_3}}(t_n)]^T$.\n- **Reaction Step:** Next, we solve the reaction part using the state from the transport step, $\\mathbf{C}^*$, with an explicit Euler step.\n  $$ r^* = k \\cdot \\max(0, C_{\\mathrm{Ca}}^* C_{\\mathrm{CO_3}}^* - K_{\\mathrm{sp}}) $$\n  The potential amount of precipitate formed is $\\Delta S = r^* \\Delta t$. To ensure non-negativity of concentrations, this amount is capped:\n  $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S, C_{\\mathrm{Ca}}^*, C_{\\mathrm{CO_3}}^*) $$\n  The final concentrations for the step are:\n  $$ C_{\\mathrm{Ca}}^{n+1} = C_{\\mathrm{Ca}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ C_{\\mathrm{CO_3}}^{n+1} = C_{\\mathrm{CO_3}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ S^{n+1} = S^n + \\Delta S_{\\mathrm{capped}} $$\n\n**3. Sequential Iterative Approach (SIA)**\nSIA reduces splitting error by iterating between transport and reaction within a time step. The problem specifies a Picard iteration to solve the implicit system. For each time step from $t_n$ to $t_{n+1}$:\nWe seek a solution $\\mathbf{y}^{n+1}$ that satisfies an implicit relation. The Picard iteration scheme is given as:\n$$ \\mathbf{y}^{(m+1)} = \\mathbf{y}^n + \\Delta t \\left( \\mathbf{J}(t_n) - \\mathbf{R}(\\mathbf{y}^{(m)}) \\right) $$\nwhere $\\mathbf{R}$ represents the reaction term vector. Let's write this out per component, including the non-negativity capping. The initial guess is $\\mathbf{y}^{(0)} = \\mathbf{y}^n$. For iteration $m$:\n1.  Calculate rate using the previous iterate's concentrations: $r^{(m)} = \\text{rate}(C_{\\mathrm{Ca}}^{(m)}, C_{\\mathrm{CO_3}}^{(m)})$.\n2.  Calculate the potential change in solid: $\\Delta S_{\\mathrm{potential}} = r^{(m)} \\Delta t$.\n3.  The resources available for precipitation are based on the state at the beginning of the step, $\\mathbf{y}^n$, plus transport. The amount of species available to be consumed is $C_{\\mathrm{Ca}}^n$ and $C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)$.\n4.  Apply capping to the change in solid:\n    $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S_{\\mathrm{potential}}, \\, C_{\\mathrm{Ca}}^n, \\, C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)) $$\n5.  Update the state for the next iterate, $(m+1)$, based on the state at the beginning of the time step, $n$:\n    $$ C_{\\mathrm{Ca}}^{(m+1)} = C_{\\mathrm{Ca}}^n - \\Delta S_{\\mathrm{capped}} $$\n    $$ C_{\\mathrm{CO_3}}^{(m+1)} = C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n) - \\Delta S_{\\mathrm{capped}} $$\n    $$ S^{(m+1)} = S^n + \\Delta S_{\\mathrm{capped}} $$\n6.  This iteration continues for a maximum of $8$ times or until the change between successive iterates falls below a tolerance of $10^{-12}$ in the maximum norm. The result of the last iteration becomes the solution for the step, $\\mathbf{y}^{n+1}$.\n\nThe implementation will process each of the three test cases, compute the final precipitated solid $S(T)$ using all three methods, calculate the absolute errors for SNIA and SIA against the monolithic reference, and format the results as requested.",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes and compares operator splitting methods for a carbonate precipitation benchmark.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (precipitation clearly triggered)\n        {\n            \"name\": \"A\",\n            \"C_Ca0\": 5e-3,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 2e-3,\n            \"t_inj\": 2.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case B (near-equilibrium start, slight supersaturation pulse)\n        {\n            \"name\": \"B\",\n            \"C_Ca0\": 1e-3,\n            \"C_CO30\": 3.3e-9 / 1e-3,  # K_sp / C_Ca(0)\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 5e-7,\n            \"t_inj\": 1.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case C (no precipitation expected)\n        {\n            \"name\": \"C\",\n            \"C_Ca0\": 1e-6,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 1e-5,\n            \"t_inj\": 0.1,\n            \"T\": 5.0,\n            \"dt\": 0.05,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        C_Ca0, C_CO30, S0 = case[\"C_Ca0\"], case[\"C_CO30\"], case[\"S0\"]\n        K_sp, k = case[\"K_sp\"], case[\"k\"]\n        J0, t_inj = case[\"J0\"], case[\"t_inj\"]\n        T, dt = case[\"T\"], case[\"dt\"]\n        \n        def rate_law(C_Ca, C_CO3, k_val, K_sp_val):\n            ion_product = C_Ca * C_CO3\n            if ion_product > K_sp_val:\n                return k_val * (ion_product - K_sp_val)\n            return 0.0\n\n        # --- 1. Monolithic Unsplit Reference Solution ---\n        def ode_system(t, y):\n            C_Ca, C_CO3, S = y\n            J_CO3 = J0 if t < t_inj else 0.0\n            r = rate_law(C_Ca, C_CO3, k, K_sp)\n            dC_Ca_dt = -r\n            dC_CO3_dt = J_CO3 - r\n            dS_dt = r\n            return [dC_Ca_dt, dC_CO3_dt, dS_dt]\n\n        y0 = [C_Ca0, C_CO30, S0]\n        sol = solve_ivp(\n            ode_system, \n            [0, T], \n            y0, \n            method='BDF', \n            rtol=1e-12, \n            atol=1e-15\n        )\n        S_ref = sol.y[2, -1]\n\n        # --- 2. Sequential Non-Iterative Approach (SNIA) ---\n        C_Ca, C_CO3, S = C_Ca0, C_CO30, S0\n        num_steps = int(round(T / dt))\n        time_points = np.linspace(0, T, num_steps + 1)\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            # Transport step\n            J_CO3_step = J0 if t < t_inj else 0.0\n            C_CO3_after_transport = C_CO3 + J_CO3_step * dt\n            C_Ca_after_transport = C_Ca  # J_Ca is 0\n\n            # Reaction step\n            r = rate_law(C_Ca_after_transport, C_CO3_after_transport, k, K_sp)\n            delta_s = r * dt\n            \n            # Capping to enforce non-negativity\n            capped_delta_s = min(delta_s, C_Ca_after_transport, C_CO3_after_transport)\n            \n            # Update state\n            C_Ca = C_Ca_after_transport - capped_delta_s\n            C_CO3 = C_CO3_after_transport - capped_delta_s\n            S = S + capped_delta_s\n        \n        S_snia = S\n\n        # --- 3. Sequential Iterative Approach (SIA) ---\n        C_Ca_n, C_CO3_n, S_n = C_Ca0, C_CO30, S0\n        max_iter = 8\n        tol = 1e-12\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            C_Ca_start, C_CO3_start, S_start = C_Ca_n, C_CO3_n, S_n\n            \n            # Initial guess for the iteration (state at n)\n            y_m = np.array([C_Ca_start, C_CO3_start, S_start])\n\n            J_CO3_step = J0 if t < t_inj else 0.0\n\n            for _ in range(max_iter):\n                y_prev_iter = y_m.copy()\n                C_Ca_m_iter, C_CO3_m_iter, _ = y_prev_iter\n\n                r_m = rate_law(C_Ca_m_iter, C_CO3_m_iter, k, K_sp)\n                delta_s_potential = r_m * dt\n                \n                # Budgets are based on state 'n' plus transport\n                budget_Ca = C_Ca_start\n                budget_CO3 = C_CO3_start + J_CO3_step * dt\n                \n                capped_delta_s = min(delta_s_potential, budget_Ca, budget_CO3)\n                \n                # Update to get next iterate (m+1) based on state 'n'\n                C_Ca_new = C_Ca_start - capped_delta_s\n                C_CO3_new = budget_CO3 - capped_delta_s\n                S_new = S_start + capped_delta_s\n                \n                y_m = np.array([C_Ca_new, C_CO3_new, S_new])\n                \n                if np.max(np.abs(y_m - y_prev_iter)) < tol:\n                    break\n            \n            C_Ca_n, C_CO3_n, S_n = y_m\n        S_sia = S_n\n        \n        error_snia = abs(S_snia - S_ref)\n        error_sia = abs(S_sia - S_ref)\n\n        all_results.extend([S_ref, S_snia, S_sia, error_snia, error_sia])\n\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The power of operator splitting comes with a responsibility for careful implementation, as subtle errors can lead to non-physical results. This final practice is a diagnostic exercise designed to illustrate one of the most critical pitfalls: the improper handling of boundary conditions, which can violate global mass conservation . By designing and computing a mass balance residual for a scheme with a deliberately flawed boundary treatment, you will learn how to detect such violations and gain a deeper appreciation for why each substep in a split scheme must be treated with conceptual consistency.",
            "id": "4094629",
            "problem": "A one-dimensional reactive solute is transported through a saturated porous column of length $L$ and constant cross-sectional area $A$. The medium has constant porosity $\\phi$, and the flow is steady with constant Darcy flux $q$ directed from $x=0$ (inlet) to $x=L$ (outlet). The mobile concentration $c(x,t)$ obeys conservation of mass for advection and first-order reaction, with negligible mechanical dispersion. The governing balance is that the total mass in the control volume changes due to the net advective inflow minus outflow and the integrated reaction term. Consider a single finite-volume cell representing the entire column, of width $\\Delta x = L$, with a Dirichlet inflow boundary $c(0,t)=c_{\\mathrm{in}}$ and a convective outflow boundary at $x=L$. The total solute mass in the cell at time $t$ is $M(t) = \\phi A \\Delta x \\, c(t)$.\n\nWe examine a split scheme consistent with a Sequential Non-Iterative Approach (SNIA), in which the transport subproblem (advection) is advanced first over a time step $\\Delta t$, followed by the reaction subproblem; the Sequential Iterative Approach (SIA) would iteratively reconcile these substeps. Use an explicit finite-volume update for advection with upwind fluxes at the inlet and outlet faces, and explicit Euler for the reaction $R(c)=-k\\,c$.\n\nSuppose the initial cell-averaged concentration is $c^{n}$ at time $t^{n}$, and the advective fluxes are computed using upwind concentrations: inlet flux $F_{\\mathrm{in}}^{n}=A q\\,c_{\\mathrm{in}}$ and outlet flux $F_{\\mathrm{out}}^{n}=A q\\,c^{n}$. The advection step produces an intermediate concentration $c^{*}$, then the reaction step updates to $c^{n+1}$ over $\\Delta t$. Now, consider an improper handling of the boundary condition: after completing the reaction step, the scheme erroneously re-imposes the Dirichlet boundary inside the cell by setting $c^{n+1}:=c_{\\mathrm{in}}$ (instead of applying it only to the transport substep). This is a known pitfall in split schemes that can violate global mass balance.\n\nYou must design and carry out a diagnostic calculation to detect the violation. Define the diagnostic mass-balance residual as the difference between the final cell mass produced by the mis-handled split step and the mass predicted by integrating the advective inflow minus outflow (as actually used in the transport substep) plus the reaction contribution (as actually used in the reaction substep). Compute this diagnostic residual after one time step, using the following physically consistent parameter set:\n- $L=\\Delta x = 0.10$ m,\n- $A = 1.0 \\times 10^{-3}$ m$^{2}$,\n- $\\phi = 0.25$,\n- $q = 1.0 \\times 10^{-5}$ m s$^{-1}$,\n- $c_{\\mathrm{in}} = 1.0$ mol m$^{-3}$,\n- $c^{n} = 0.20$ mol m$^{-3}$,\n- $k = 1.0 \\times 10^{-6}$ s$^{-1}$,\n- $\\Delta t = 1.0 \\times 10^{3}$ s.\n\nExpress your final answer as the diagnostic residual in mol. Round your answer to four significant figures.",
            "solution": "We start from conservation of mass in a finite-volume control volume of width $\\Delta x$ and cross-sectional area $A$, with porosity $\\phi$. The total mass in the cell is $M(t)=\\phi A \\Delta x\\,c(t)$. Over a time step $\\Delta t$, the exact mass balance would equate the change in mass to the time-integrated net inflow minus outflow plus the time-integrated reaction source/sink. In a split scheme, we must be consistent with the contributions actually used in each substep.\n\nWe use a Sequential Non-Iterative Approach (SNIA): first transport (advection) for $\\Delta t$, then reaction for $\\Delta t$. With upwind advection and explicit time integration, the transport substep uses inlet and outlet advective fluxes computed from known concentrations at $t^{n}$:\n- Inlet advective flux at $x=0$: $F_{\\mathrm{in}}^{n} = A q\\, c_{\\mathrm{in}}$\n- Outlet advective flux at $x=L$: $F_{\\mathrm{out}}^{n} = A q\\, c^{n}$\n\nThe finite-volume explicit update for advection gives the intermediate concentration $c^{*}$:\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; \\frac{\\Delta t}{\\phi A \\Delta x}\\,\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; c^{n} \\;+\\; \\frac{\\Delta t\\, q}{\\phi\\, \\Delta x}\\,\\big(c_{\\mathrm{in}} - c^{n}\\big).\n$$\n\nThen, the reaction substep uses explicit Euler for the first-order decay $R(c)=-k\\,c$, applied to $c^{*}$:\n\n$$\nc^{n+1}_{\\mathrm{scheme}} \\;=\\; c^{*} \\;+\\; \\Delta t\\,(-k\\,c^{*}) \\;=\\; c^{*}\\,(1 - k\\,\\Delta t).\n$$\n\nIf boundary conditions are correctly handled (i.e., only applied to the transport substep), the final mass after both substeps would be $M^{n+1}_{\\mathrm{scheme}}=\\phi A \\Delta x\\,c^{n+1}_{\\mathrm{scheme}}$, and the discrete mass balance identity would be satisfied:\n\n$$\nM^{n+1}_{\\mathrm{scheme}} \\;=\\; M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big).\n$$\n\nHowever, the improper boundary handling described resets the final concentration to $c_{\\mathrm{in}}$ after the reaction step: $c^{n+1}_{\\mathrm{mis}} := c_{\\mathrm{in}}$. The resulting final mass is $M^{n+1}_{\\mathrm{mis}} = \\phi A \\Delta x\\, c_{\\mathrm{in}}$. The diagnostic residual is defined as the difference between this mis-handled final mass and the sum of the contributions used in the split steps:\n\n$$\nR_{\\mathrm{diag}} \\;=\\; M^{n+1}_{\\mathrm{mis}} \\;-\\; \\Big[\\, M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\\,\\Big].\n$$\n\nBy construction, a consistent split scheme would have $R_{\\mathrm{diag}}=0$, so any nonzero value signals violation of mass balance.\n\nWe now compute $R_{\\mathrm{diag}}$ with the given parameters. First, compute the advective fluxes:\n\n$$\nF_{\\mathrm{in}}^{n} \\;=\\; A q\\, c_{\\mathrm{in}} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(1.0\\big) \\;=\\; 1.0 \\times 10^{-8}\n$$\n\n$$\nF_{\\mathrm{out}}^{n} \\;=\\; A q\\, c^{n} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(0.20\\big) \\;=\\; 2.0 \\times 10^{-9}\n$$\n\nThe initial mass in the cell is\n\n$$\nM^{n} \\;=\\; \\phi A \\Delta x\\, c^{n} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(0.20\\big) \\;=\\; 5.0 \\times 10^{-6}.\n$$\n\nCompute the intermediate concentration $c^{*}$ from the advection substep:\n\n$$\n\\frac{\\Delta t\\, q}{\\phi\\, \\Delta x} \\;=\\; \\frac{\\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)}{\\big(0.25\\big)\\,\\big(0.10\\big)} \\;=\\; \\frac{1.0 \\times 10^{-2}}{2.5 \\times 10^{-2}} \\;=\\; 0.40\n$$\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; 0.40\\,\\big(c_{\\mathrm{in}} - c^{n}\\big) \\;=\\; 0.20 \\;+\\; 0.40\\,\\big(1.0 - 0.20\\big) \\;=\\; 0.20 \\;+\\; 0.40 \\times 0.80 \\;=\\; 0.52.\n$$\n\nThe reaction contribution used in the split step is\n\n$$\n\\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\n\\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0 \\times 10^{3}\\big)\\,\\big(-1.0 \\times 10^{-6}\\big)\\,\\big(0.52\\big)\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big)\\,\\big(-5.2 \\times 10^{-4}\\big)\n\\;=\\; -1.3 \\times 10^{-8}.\n$$\n\nThe net advective mass input over $\\Delta t$ is\n\n$$\n\\Delta t\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-8} - 2.0 \\times 10^{-9}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(8.0 \\times 10^{-9}\\big)\n\\;=\\; 8.0 \\times 10^{-6}.\n$$\n\nThe mis-handled final mass is\n\n$$\nM^{n+1}_{\\mathrm{mis}} \\;=\\; \\phi A \\Delta x\\, c_{\\mathrm{in}} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0\\big) \\;=\\; 2.5 \\times 10^{-5}.\n$$\n\nTherefore, the diagnostic residual is\n\n$$\nR_{\\mathrm{diag}} \\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\Big[\\, \\big(5.0 \\times 10^{-6}\\big) \\;+\\; \\big(8.0 \\times 10^{-6}\\big) \\;+\\; \\big(-1.3 \\times 10^{-8}\\big) \\,\\Big]\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\big(1.2987 \\times 10^{-5}\\big)\n\\;=\\; 1.2013 \\times 10^{-5}.\n$$\n\nRounded to four significant figures and expressed in mol, the diagnostic residual is $1.201 \\times 10^{-5}$. A nonzero positive $R_{\\mathrm{diag}}$ indicates that improperly resetting the cell concentration to the Dirichlet boundary value after the reaction step has injected extra mass not accounted for by the transport and reaction substeps. In a Sequential Iterative Approach (SIA), iterating the coupled substeps while maintaining boundary condition consistency would drive $R_{\\mathrm{diag}}$ toward zero, restoring global mass balance.",
            "answer": "$$\\boxed{1.201 \\times 10^{-5}}$$"
        }
    ]
}