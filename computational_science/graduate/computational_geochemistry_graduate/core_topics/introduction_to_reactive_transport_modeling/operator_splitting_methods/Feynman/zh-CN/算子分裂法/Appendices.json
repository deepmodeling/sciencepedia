{
    "hands_on_practices": [
        {
            "introduction": "本练习将从一个经典的偏微分方程——平流-扩散-反应（ADR）方程入手，带你深入算子分裂方法的核心。你将把复杂的ADR算子分解为一系列更简单的子问题，并从理论上推导一阶分裂格式产生的局部截断误差。通过将理论推导出的算子对易子与数值实验结果进行对比，你将直观地理解分裂误差的来源及其量级，为后续更复杂的应用打下坚实的理论基础。",
            "id": "4079402",
            "problem": "考虑一个一维平流-扩散-反应 (Advection–Diffusion–Reaction, ADR) 偏微分方程 (Partial Differential Equation, PDE)，用于描述在周期性空间域 $x \\in [0,L]$ 和时间 $t \\ge 0$ 上的标量浓度场 $C(x,t)$。该方程包含空间变化的平流速度 $v(x)$、恒定的分子扩散系数 $D$ 和空间变化的一阶反应速率 $k(x)$。其控制方程为\n$$\n\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t),\n$$\n方程需满足周期性边界条件和一个光滑的周期性初始条件。在计算地球化学领域，当模拟多孔介质和反应流中水相物质的输运和转化时，会遇到平流-扩散-反应 (ADR) 过程。\n\n任务1 (推导)：从平流算子 $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$、扩散算子 $\\mathcal{D} u = D\\,\\partial_{xx} u$ 和反应算子 $\\mathcal{R} u = -\\,k(x)\\,u$ 的定义出发，推导一个针对单个时间步长 $\\Delta t$ 的一阶李氏 (Lie) 算子分裂格式。该格式通过在同一个 $\\Delta t$ 内，按平流、然后扩散、然后反应的顺序，依次求解子问题来演化 $C(x,t)$。使用基于半群复合原理的推导方法，并用算子的对易子来量化主阶局部劈裂误差。您的推导必须从线性算子和流的复合的基本定义开始；不要使用预先给定的快捷公式，也不要未经推导直接给出最终的对易子结果。\n\n任务2 (实现)：实现一个数值算法，以应用您推导的一阶李氏分裂格式。使用空间离散的周期性网格和以下数值程序：\n- 对于平流子步骤，使用高精度常微分方程 (Ordinary Differential Equation, ODE) 积分器求解在一个子步长 $\\Delta t$ 内的常微分方程半离散系统 $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C}$。此处 $\\mathbf{C}$ 是网格点上的浓度值向量，$\\mathbf{v}$ 是网格点上的平流速度向量，$\\odot$ 表示逐分量乘法，$\\partial_x \\mathbf{C}$ 是通过在周期域上使用快速傅里叶变换 (Fast Fourier Transform, FFT) 计算的谱方法一阶导数。\n- 对于扩散子步骤，通过将每个傅里叶模乘以 $\\exp(-D\\,k^2\\,\\Delta t)$，在傅里叶空间中精确演化 $\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C}$ 一个子步长 $\\Delta t$，其中 $k$ 是角波数。\n- 对于反应子步骤，通过逐分量乘以 $\\exp(-\\mathbf{k}\\,\\Delta t)$，精确演化 $\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C}$ 一个子步长 $\\Delta t$。\n\n为了量化劈裂误差，通过使用高阶自适应 ODE 积分器和严格的容差，从 $t = 0$ 到 $t = T$ 求解完整的半离散 ADR 系统\n$$\n\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}\n$$\n来计算一个高精度的未分裂参考解 $\\mathbf{C}_{\\text{ref}}(T)$。然后计算在最终时间 $T$ 的相对离散 $\\ell^2$ 误差，\n$$\nE \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2},\n$$\n其中 $\\left\\|\\cdot\\right\\|_2$ 是网格上的欧几里得范数。将此误差报告为无量纲小数。\n\n域、系数和初始条件：\n- 域长度 $L$ (单位：米) 为 $L = 1$，具有周期性边界条件。\n- 网格大小 $N$ 为 $N = 128$ 个均匀间隔点。\n- 平流速度 $v(x) = v_0 + v_1\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)$，其中 $v_0$ 单位为米/秒，$v_1$ 单位为米/秒。\n- 扩散系数 $D$ (单位：平方米/秒) 为常数。\n- 反应速率 $k(x) = k_0 + k_1\\,\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)$，其中 $k_0$ 单位为1/秒，$k_1$ 单位为1/秒。\n- 初始条件 $C(x,0) = C_0\\,\\left[1 + a\\,\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\right]$，其中 $C_0$ 为任意浓度单位，$a$ 为无量纲振幅。由于所要求的输出是误差范数和比率，它们都是无量纲的；最终输出中不需要物理单位。\n\n时间参数：\n- 最终时间 $T$ (单位：秒) 和劈裂时间步长 $\\Delta t$ (单位：秒) 将根据每个测试用例指定。确保 $T$ 是 $\\Delta t$ 的整数倍。\n\n测试套件：\n实现您的程序以评估以下四个测试用例并汇总结果：\n- 用例1 (一般变系数 ADR)：\n  - $L = 1$，$N = 128$，$v_0 = 0.5$，$v_1 = 0.25$，$D = 0.001$，$k_0 = 1.0$，$k_1 = 0.5$，$C_0 = 1.0$，$a = 0.5$，$T = 0.1$，$\\Delta t = T/40$。\n  - 以小数形式输出在 $t = T$ 时的相对 $\\ell^2$ 误差 $E_1$。\n- 用例2 (通过减半时间步长进行阶数验证)：\n  - 参数与用例1相同。\n  - 分别计算 $\\Delta t = T/40$ 时的 $E_{\\Delta t}$ 和 $\\Delta t = T/80$ 时的 $E_{\\Delta t/2}$，并以小数形式输出比率 $R = E_{\\Delta t}/E_{\\Delta t/2}$，以评估一阶全局精度。\n- 用例3 (无扩散)：\n  - $L = 1$，$N = 128$，$v_0 = 0.5$，$v_1 = 0.25$，$D = 0.0$，$k_0 = 1.0$，$k_1 = 0.5$，$C_0 = 1.0$，$a = 0.5$，$T = 0.1$，$\\Delta t = T/40$。\n  - 以小数形式输出在 $t = T$ 时的相对 $\\ell^2$ 误差 $E_3$。\n- 用例4 (常系数，预期劈裂误差接近于零)：\n  - $L = 1$，$N = 128$，$v_0 = 0.5$，$v_1 = 0.0$，$D = 0.001$，$k_0 = 1.0$，$k_1 = 0.0$，$C_0 = 1.0$，$a = 0.5$，$T = 0.1$，$\\Delta t = T/40$。\n  - 以小数形式输出在 $t = T$ 时的相对 $\\ell^2$ 误差 $E_4$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序为 $[E_1, R, E_3, E_4]$。例如，程序必须精确打印一行形如 $[E_1,R,E_3,E_4]$ 的内容，不含任何额外文本。所有输出均为无量纲小数。",
            "solution": "在尝试解答之前，此问题已经过验证。\n\n### 步骤1：提取已知条件\n-   **控制方程**：一维平流-扩散-反应 (ADR) 偏微分方程为 $\\frac{\\partial C}{\\partial t}(x,t) + v(x)\\,\\frac{\\partial C}{\\partial x}(x,t) \\;=\\; D\\,\\frac{\\partial^2 C}{\\partial x^2}(x,t) \\;-\\; k(x)\\,C(x,t)$。\n-   **域和条件**：$x \\in [0,L]$，$t \\ge 0$，具有周期性边界条件和光滑的周期性初始条件。\n-   **算子定义**：平流算子 $\\mathcal{A} u = -\\,v(x)\\,\\partial_x u$，扩散算子 $\\mathcal{D} u = D\\,\\partial_{xx} u$，以及反应算子 $\\mathcal{R} u = -\\,k(x)\\,u$。\n-   **任务1 (推导)**：推导一个形式为“平流-扩散-反应”的一阶李氏算子分裂格式，通过依次求解每个子问题来将解演化 $\\Delta t$。推导必须从半群复合开始，并使用算子对易子量化主阶局部劈裂误差。\n-   **任务2 (实现)**：为李氏分裂实现一个数值算法。\n    -   平流子步骤 $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C})$：使用高精度ODE积分器，并采用谱方法微分 (FFT)。\n    -   扩散子步骤 $(\\frac{d\\mathbf{C}}{dt} = D\\,\\partial_{xx} \\mathbf{C})$：在傅里叶空间中进行精确演化。\n    -   反应子步骤 $(\\frac{d\\mathbf{C}}{dt} = -\\,\\mathbf{k}\\,\\odot\\,\\mathbf{C})$：使用精确的逐分量演化。\n-   **误差分析**：将劈裂解与通过高阶自适应ODE积分器求解完整半离散系统 $\\frac{d\\mathbf{C}}{dt} \\;=\\; -\\,\\mathbf{v}\\,\\odot\\,\\partial_x \\mathbf{C} \\;+\\; D\\,\\partial_{xx} \\mathbf{C} \\;-\\; \\mathbf{k}\\,\\odot\\,\\mathbf{C}$ 得到的高精度未分裂参考解进行比较。误差度量是相对离散 $\\ell^2$ 范数 $E \\;=\\; \\frac{\\left\\|\\mathbf{C}_{\\text{split}}(T) - \\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}{\\left\\|\\mathbf{C}_{\\text{ref}}(T)\\right\\|_2}$。\n-   **参数**：\n    -   域：$L = 1$，网格大小 $N=128$。\n    -   系数：$v(x) = v_0 + v_1\\,\\sin(2\\pi x/L)$，$D$ 是常数，$k(x) = k_0 + k_1\\,\\cos(2\\pi x/L)$。\n    -   初始条件：$C(x,0) = C_0\\,[1 + a\\,\\sin(2\\pi x/L)]$。\n-   **测试用例**：定义了四个具体用例，提供了所有参数值 ($v_0, v_1, D, k_0, k_1, C_0, a, T, \\Delta t$)，以计算特定的误差度量 $E_1, R, E_3, E_4$。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行分析。\n-   **科学基础**：ADR方程是输运现象中的一个基本模型，是地球化学等领域的核心。算子定义、边界条件以及系数的函数形式都是标准的，并且在科学上是合理的。所提出的数值方法（算子分裂、谱方法、高阶ODE积分）是科学计算中的成熟技术。此问题在科学和数学上都是合理的。\n-   **适定性和一致性**：问题是适定的。具有指定光滑系数和周期性边界条件的ADR方程构成了一个适定的初边值问题。所有必要的参数和方法都已定义，使得问题自洽且明确。使用“高精度ODE积分器”的指令是标准做法，可以通过库例程（如SciPy的`solve_ivp`）使用适当的方法和容差轻松满足。\n-   **客观性和可行性**：问题以精确、客观的数学语言陈述。参数值对于模型系统是物理上合理的，并且不会导致不可行的计算。任务是具体且可验证的。\n\n### 步骤3：结论与行动\n此问题是**有效的**。它是一个在数值分析和计算科学领域中定义明确、科学合理且具有一定挑战性的问题。将提供一个解答。\n\n### 解答\n\n根据要求，解答分为两部分：首先是理论推导，然后是数值实现的纲要。\n\n#### 任务1：李氏分裂的推导与误差分析\n\n控制方程——平流-扩散-反应 (ADR) 方程为\n$$\n\\frac{\\partial C}{\\partial t} = \\mathcal{A}C + \\mathcal{D}C + \\mathcal{R}C = (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})C\n$$\n其中 $\\mathcal{A} = -v(x)\\partial_x$, $\\mathcal{D} = D\\partial_{xx}$ 和 $\\mathcal{R} = -k(x)$ 分别是代表平流、扩散和反应的线性算子。令 $\\mathcal{L} = \\mathcal{A} + \\mathcal{D} + \\mathcal{R}$ 为总演化算子。\n\n这个线性偏微分方程在时间间隔 $\\Delta t$ 上的正式解可以使用半群的概念来表示，记作算子指数：\n$$\nC(t+\\Delta t) = e^{\\Delta t \\mathcal{L}} C(t) = e^{\\Delta t (\\mathcal{A} + \\mathcal{D} + \\mathcal{R})} C(t)\n$$\n算子分裂方法通过将单个算子的指数乘积来近似算子之和的指数。对于指定的平流、然后扩散、然后反应的顺序，一阶李氏分裂格式通过每个子问题的演化算子的复合来近似精确解的演化算子 $e^{\\Delta t \\mathcal{L}}$：\n$$\n\\Phi_{\\text{split}}(\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}}\n$$\n将此应用于时间 $t$ 的解，得到在 $t+\\Delta t$ 时的近似解：\n$$\nC_{\\text{split}}(t+\\Delta t) = e^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} C(t)\n$$\n这对应于在时间步长 $\\Delta t$ 内依次求解三个更简单的偏微分方程：\n1.  **平流**：$\\frac{\\partial C^*}{\\partial t} = \\mathcal{A}C^*$，从 $C(t)$ 求解得到 $C^*(\\Delta t) = e^{\\Delta t \\mathcal{A}}C(t)$。\n2.  **扩散**：$\\frac{\\partial C^{**}}{\\partial t} = \\mathcal{D}C^{**}$，从 $C^*(\\Delta t)$ 求解得到 $C^{**}(\\Delta t) = e^{\\Delta t \\mathcal{D}}C^*(\\Delta t)$。\n3.  **反应**：$\\frac{\\partial C^{*** }}{\\partial t} = \\mathcal{R}C^{*** }$，从 $C^{**}(\\Delta t)$ 求解得到 $C^{***}(\\Delta t) = e^{\\Delta t \\mathcal{R}}C^{**}(\\Delta t)$。\n最终结果是 $C_{\\text{split}}(t+\\Delta t) = C^{***}(\\Delta t)$。\n\n局部截断误差是分裂演化算子与精确演化算子作用之差。为了找到主阶项，我们将两个演化算子在 $\\Delta t$ 中进行泰勒级数展开。\n\n精确演化算子展开为：\n$$\ne^{\\Delta t \\mathcal{L}} = I + \\Delta t \\mathcal{L} + \\frac{(\\Delta t \\mathcal{L})^2}{2!} + O(\\Delta t^3)\n$$\n$$\ne^{\\Delta t (\\mathcal{A}+\\mathcal{D}+\\mathcal{R})} = I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}+\\mathcal{D}+\\mathcal{R})^2 + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\frac{\\Delta t^2}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) + O(\\Delta t^3)\n$$\n分裂演化算子是指数的乘积：\n$$\ne^{\\Delta t \\mathcal{R}} e^{\\Delta t \\mathcal{D}} e^{\\Delta t \\mathcal{A}} = \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t \\mathcal{D} + \\frac{\\Delta t^2}{2}\\mathcal{D}^2\\right) \\left(I + \\Delta t \\mathcal{A} + \\frac{\\Delta t^2}{2}\\mathcal{A}^2\\right) + O(\\Delta t^3)\n$$\n展开此乘积并保留至 $\\Delta t^2$ 阶的项：\n$$\n= \\left(I + \\Delta t \\mathcal{R} + \\frac{\\Delta t^2}{2}\\mathcal{R}^2\\right) \\left(I + \\Delta t(\\mathcal{A}+\\mathcal{D}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA}\\right)\\right) + O(\\Delta t^3)\n$$\n$$\n= I + \\Delta t(\\mathcal{A}+\\mathcal{D}+\\mathcal{R}) + \\Delta t^2\\left(\\frac{\\mathcal{A}^2}{2} + \\frac{\\mathcal{D}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD} + \\frac{\\mathcal{R}^2}{2}\\right) + O(\\Delta t^3)\n$$\n局部误差算子是二者之差，即 $\\Phi_{\\text{split}}(\\Delta t) - e^{\\Delta t \\mathcal{L}}$。$I$ 阶和 $\\Delta t$ 阶的项完全抵消。$\\Delta t^2$ 阶项的差为：\n$$\n\\Delta t^2 \\left[ \\left(\\frac{\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2}{2} + \\mathcal{DA} + \\mathcal{RA} + \\mathcal{RD}\\right) - \\frac{1}{2}(\\mathcal{A}^2+\\mathcal{D}^2+\\mathcal{R}^2 + \\mathcal{AD}+\\mathcal{DA} + \\mathcal{AR}+\\mathcal{RA} + \\mathcal{DR}+\\mathcal{RD}) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (2\\mathcal{DA} - (\\mathcal{AD}+\\mathcal{DA})) + (2\\mathcal{RA} - (\\mathcal{AR}+\\mathcal{RA})) + (2\\mathcal{RD} - (\\mathcal{DR}+\\mathcal{RD})) \\right]\n$$\n$$\n= \\frac{\\Delta t^2}{2} \\left[ (\\mathcal{DA} - \\mathcal{AD}) + (\\mathcal{RA} - \\mathcal{AR}) + (\\mathcal{RD} - \\mathcal{DR}) \\right]\n$$\n该表达式使用对易子记法 $[\\mathcal{X}, \\mathcal{Y}] = \\mathcal{XY} - \\mathcal{YX}$ 可简化为：\n$$\n\\text{误差项} = \\frac{\\Delta t^2}{2} \\left( [\\mathcal{D}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{A}] + [\\mathcal{R}, \\mathcal{D}] \\right)\n$$\n局部截断误差的阶数为 $O(\\Delta t^2)$。由于到达最终时间 $T$ 大约需要 $N_{\\text{steps}} = T/\\Delta t$ 步，全局误差累积到 $N_{\\text{steps}} \\times O(\\Delta t^2) \\sim (T/\\Delta t) \\times O(\\Delta t^2) \\sim O(\\Delta t)$ 阶。因此，李氏分裂是一种一阶精度方法。当且仅当所有算子都对易时，即 $[\\mathcal{D}, \\mathcal{A}]=0$、$[\\mathcal{R}, \\mathcal{A}]=0$ 和 $[\\mathcal{R}, \\mathcal{D}]=0$ 时，劈裂误差为零。这在系数 $v(x)$ 和 $k(x)$ 为常数时发生。\n\n#### 任务2：数值实现策略\n\n数值实现遵循推导出的分裂格式，在离散网格上进行，并将其精度与参考解进行比较。\n\n1.  **离散化**：将空间域 $x \\in [0, L]$ 离散为 $N$ 个均匀间隔的网格点 $x_j = j L/N$，$j=0, \\dots, N-1$。浓度场 $C(x,t)$ 变为长度为 $N$ 的向量 $\\mathbf{C}(t)$，其中 $C_j(t) \\approx C(x_j, t)$。函数 $v(x)$ 和 $k(x)$ 变为向量 $\\mathbf{v}$ 和 $\\mathbf{k}$。\n\n2.  **参考解**：通过求解完全耦合的半离散ODE系统，计算出高精度的参考解 $\\mathbf{C}_{\\text{ref}}(T)$，\n    $$\n    \\frac{d\\mathbf{C}}{dt} = \\mathcal{L}\\mathbf{C} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C}) + D (\\partial_{xx} \\mathbf{C}) - \\mathbf{k} \\odot \\mathbf{C}\n    $$\n    求解时间从 $t=0$ 到 $t=T$。空间导数 $\\partial_x \\mathbf{C}$ 和 $\\partial_{xx} \\mathbf{C}$ 使用快速傅里叶变换 (FFT) 的谱方法计算，该方法对周期函数具有高精度。时间积分使用高阶自适应步长求解器进行，特别是 `scipy.integrate.solve_ivp` 的 `DOP853` 方法和严格的误差容差（例如，`rtol=1e-12`, `atol=1e-14`）。\n\n3.  **劈裂解**：通过迭代 $N_{\\text{steps}} = T/\\Delta t$ 次来计算劈裂解 $\\mathbf{C}_{\\text{split}}(T)$。在从 $t$ 到 $t+\\Delta t$ 的每一步中：\n    -   **平流步骤**：在单个时间步长 $\\Delta t$ 内求解ODE系统 $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{v} \\odot (\\partial_x \\mathbf{C})$，同样使用 `solve_ivp` 和 `DOP853` 方法及严格的容差。$\\partial_x \\mathbf{C}$ 使用谱方法计算。\n    -   **扩散步骤**：在傅里叶空间中精确求解系统 $\\frac{d\\mathbf{C}}{dt} = D (\\partial_{xx} \\mathbf{C})$。对状态向量 $\\mathbf{C}$ 进行FFT，得到 $\\hat{\\mathbf{C}}$。对于每个具有角波数 $\\omega_m$ 的傅里叶模态 $m$，ODE变为 $\\frac{d\\hat{C}_m}{dt} = D(i\\omega_m)^2 \\hat{C}_m = -D\\omega_m^2 \\hat{C}_m$。其精确解为 $\\hat{C}_m(\\Delta t) = \\hat{C}_m(0) e^{-D\\omega_m^2 \\Delta t}$。状态向量通过 `ifft(fft(C) * exp(-D*omega**2*dt))` 进行更新。\n    -   **反应步骤**：系统 $\\frac{d\\mathbf{C}}{dt} = -\\mathbf{k} \\odot \\mathbf{C}$ 是一组解耦的ODE，$dC_j/dt = -k_j C_j$。其解为 $C_j(\\Delta t) = C_j(0) e^{-k_j \\Delta t}$。状态向量通过逐分量乘法更新：$\\mathbf{C} \\leftarrow \\mathbf{C} \\odot e^{-\\mathbf{k}\\Delta t}$。\n\n4.  **误差计算与测试用例**：\n    -   在 $T$ 时刻计算劈裂解与参考解之间的相对 $\\ell^2$ 误差。\n    -   **用例1** 测量具有变系数的一般ADR问题的误差。\n    -   **用例2** 验证分裂方法的一阶收敛性。误差 $E$ 与 $\\Delta t$ 成正比，因此误差比率 $E_{\\Delta t}/E_{\\Delta t/2}$ 应约等于 $2$。\n    -   **用例3** ($D=0$) 隔离了由非对易的平流和反应算子（$[\\mathcal{R}, \\mathcal{A}] \\neq 0$）引起的劈裂误差。\n    -   **用例4** ($v_1=0, k_1=0$) 使平流和反应系数为常数。如推导所示，所有对易子都变为零。理论劈裂误差为零。测得的误差 $E_4$ 将是一个很小的数，反映了ODE求解器和浮点运算的数值精度，从而证明了对易子分析的正确性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom numpy.fft import fft, ifft, fftfreq\n\ndef solve():\n    \"\"\"\n    Solves the ADR equation using Lie splitting and compares it to a reference\n    solution to quantify splitting error for four different test cases.\n    \"\"\"\n\n    def run_simulation(L, N, v0, v1, D, k0, k1, C0, a, T, dt, use_split_method):\n        \"\"\"\n        Runs a single simulation, either the full reference or the split method.\n        \"\"\"\n        # 1. Setup grid, initial condition, and parameters\n        x = np.linspace(0, L, N, endpoint=False)\n        v = v0 + v1 * np.sin(2 * np.pi * x / L)\n        k_rate = k0 + k1 * np.cos(2 * np.pi * x / L)\n        C_initial = C0 * (1 + a * np.sin(2 * np.pi * x / L))\n\n        # Wavenumbers for spectral derivatives\n        # fftfreq returns frequencies in cycles per unit of sample spacing (dx=L/N)\n        # We convert to angular wavenumbers (radians per unit length)\n        dx = L / N\n        angular_wavenumbers = 2 * np.pi * fftfreq(N, d=dx)\n\n        # 2. Define derivative functions and RHS of the full PDE\n        def d_dx(C_vec):\n            return np.real(ifft(1j * angular_wavenumbers * fft(C_vec)))\n\n        def d2_dx2(C_vec):\n            return np.real(ifft(-angular_wavenumbers**2 * fft(C_vec)))\n\n        def full_rhs(t, C_vec):\n            dC_advection = -v * d_dx(C_vec)\n            dC_diffusion = D * d2_dx2(C_vec)\n            dC_reaction = -k_rate * C_vec\n            return dC_advection + dC_diffusion + dC_reaction\n\n        # 3. Compute solution\n        if not use_split_method:\n            # High-accuracy reference solution\n            sol = solve_ivp(full_rhs, (0, T), C_initial, method='DOP853', rtol=1e-12, atol=1e-14)\n            return sol.y[:, -1]\n        else:\n            # Lie splitting solution\n            def advection_rhs(t, C_vec):\n                return -v * d_dx(C_vec)\n            \n            C = C_initial.copy()\n            num_steps = int(round(T / dt))\n\n            for _ in range(num_steps):\n                # Step 1: Advection substep\n                sol_adv = solve_ivp(advection_rhs, (0, dt), C, method='DOP853', rtol=1e-12, atol=1e-12)\n                C = sol_adv.y[:, -1]\n\n                # Step 2: Diffusion substep (exact in Fourier space)\n                C_hat = fft(C)\n                C_hat *= np.exp(-D * angular_wavenumbers**2 * dt)\n                C = np.real(ifft(C_hat))\n\n                # Step 3: Reaction substep (exact pointwise)\n                C *= np.exp(-k_rate * dt)\n            \n            return C\n\n    def calculate_error(params, dt):\n        \"\"\"Helper to compute error for a given dt.\"\"\"\n        C_ref = run_simulation(**params, dt=dt, use_split_method=False)\n        C_split = run_simulation(**params, dt=dt, use_split_method=True)\n        error = np.linalg.norm(C_split - C_ref) / np.linalg.norm(C_ref)\n        return error\n\n    results = []\n\n    # --- Test Case 1 ---\n    # General ADR with variable coefficients\n    params1 = {'L': 1.0, 'N': 128, 'v0': 0.5, 'v1': 0.25, 'D': 0.001, 'k0': 1.0, 'k1': 0.5, 'C0': 1.0, 'a': 0.5, 'T': 0.1}\n    dt1 = params1['T'] / 40.0\n    E1 = calculate_error(params1, dt1)\n    results.append(E1)\n\n    # --- Test Case 2 ---\n    # Order verification by halving the time step\n    params2 = params1\n    dt_large = params2['T'] / 40.0\n    dt_small = params2['T'] / 80.0\n    E_dt = calculate_error(params2, dt_large)\n    E_dthalf = calculate_error(params2, dt_small)\n    R = E_dt / E_dthalf\n    results.append(R)\n\n    # --- Test Case 3 ---\n    # No diffusion (D=0)\n    params3 = params1.copy()\n    params3['D'] = 0.0\n    dt3 = params3['T'] / 40.0\n    E3 = calculate_error(params3, dt3)\n    results.append(E3)\n\n    # --- Test Case 4 ---\n    # Constant coefficients (v1=0, k1=0), commuting operators\n    params4 = params1.copy()\n    params4['v1'] = 0.0\n    params4['k1'] = 0.0\n    dt4 = params4['T'] / 40.0\n    E4 = calculate_error(params4, dt4)\n    results.append(E4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在掌握了线性系统的基础后，我们将把算子分裂方法应用于一个更具挑战性的非线性地球化学问题——碳酸盐沉淀。本练习将引导你构建一个零维间歇反应器模型，并实现两种在反应输运模拟中应用最广的分裂方案：顺序非迭代法（SNIA）和顺序迭代法（SIA）。通过将这两种方法的计算结果与精确的整体求解（monolithic）参考解进行比较，你将深刻体会到在处理复杂的非线性反应时，不同分裂策略在计算效率和精度之间的权衡。",
            "id": "4094620",
            "problem": "构建一个零维间歇式反应器基准，用于评估反应输运中碳酸盐沉淀的算子分裂法。该水相体系包含溶解的钙和碳酸盐，当发生过饱和时，它们可以沉淀为固体碳酸盐矿物。控制演化基于质量守恒和源于质量作用的沉淀速率定律。目标是计算形成的固体碳酸盐的质量，并将顺序算子分裂方案与整体未分裂参考解进行比较。\n\n假设与定义：\n- 反应器体积恒为 $1$ 升，因此物种的摩尔量等于以 $\\mathrm{mol/L}$ 为单位的浓度。\n- 令 $C_{\\mathrm{Ca}}(t)$ 和 $C_{\\mathrm{CO_3}}(t)$ 分别表示溶解的钙和碳酸盐的浓度，令 $S(t)$ 表示累积沉淀的固体碳酸盐量（单位为 $\\mathrm{mol/L}$）。\n- 沉淀动力学遵循质量作用速率：\n  $$ r(t) \\;=\\; k \\,\\max\\!\\left(0,\\, C_{\\mathrm{Ca}}(t)\\,C_{\\mathrm{CO_3}}(t) \\;-\\; K_{\\mathrm{sp}} \\right), $$\n  其中 $k$ 的单位为 $\\mathrm{L\\,mol^{-1}\\,s^{-1}}$，$K_{\\mathrm{sp}}$ 是以 $\\mathrm{(mol/L)^2}$ 为单位的溶度积。假设活度等于浓度（单位活度系数）。\n- 具有随时间变化的碳酸盐源项的间歇式反应器中的质量平衡为：\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} \\;=\\; J_{\\mathrm{Ca}}(t) \\;-\\; r(t), \\qquad \\frac{dC_{\\mathrm{CO_3}}}{dt} \\;=\\; J_{\\mathrm{CO_3}}(t) \\;-\\; r(t), \\qquad \\frac{dS}{dt} \\;=\\; r(t). $$\n- 没有钙源，因此 $J_{\\mathrm{Ca}}(t) \\equiv 0$。碳酸盐源是一个方波脉冲，定义为：\n  $$ J_{\\mathrm{CO_3}}(t) \\;=\\; \\begin{cases}\n  J_0, & 0 \\le t < t_{\\mathrm{inj}},\\\\\n  0, & t \\ge t_{\\mathrm{inj}},\n  \\end{cases} $$\n  其中 $J_0$ 是在持续时间 $t_{\\mathrm{inj}}$ 内的恒定注入速率。\n\n待实现的算子分裂法：\n- 顺序非迭代法 (SNIA)：在每个大小为 $\\Delta t$ 的时间步中，首先在 $\\Delta t$ 上应用输运算子（源项），然后使用在输运后状态下评估的 $r$ 进行显式前向欧拉更新，在 $\\Delta t$ 上应用反应算子。在反应更新期间，通过限制消耗量来强制非负性，以确保 $C_{\\mathrm{Ca}}$ 和 $C_{\\mathrm{CO_3}}$ 在该步内都不会变为负值。这产生了一阶时间精度的分裂。\n- 顺序迭代法 (SIA)：在每个大小为 $\\Delta t$ 的时间步中，在步内迭代输运和反应以减少分裂误差。实现一个定点（Picard）迭代，其中步内更新满足：\n  $$ C^{(m+1)}_{\\mathrm{Ca}} \\;=\\; C^{n}_{\\mathrm{Ca}} \\;+\\; \\Delta t\\,J_{\\mathrm{Ca}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ C^{(m+1)}_{\\mathrm{CO_3}} \\;=\\; C^{n}_{\\mathrm{CO_3}} \\;+\\; \\Delta t\\,J_{\\mathrm{CO_3}} \\;-\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  $$ S^{(m+1)} \\;=\\; S^{n} \\;+\\; \\Delta t\\,r\\!\\left(C^{(m)}_{\\mathrm{Ca}},C^{(m)}_{\\mathrm{CO_3}}\\right), $$\n  每次迭代中都进行适当的限制以强制非负性，并且每步有固定的最大迭代次数。使用最后一次迭代作为步更新。\n- 整体未分裂参考解：使用隐式刚性求解器以高精度求解 $C_{\\mathrm{Ca}}(t)$、$C_{\\mathrm{CO_3}}(t)$ 和 $S(t)$ 在时间区间 $[0,T]$ 上的耦合常微分方程。整体解被作为比较的参考。\n\n推导的基本依据：\n- 每个组分带有源和汇的质量守恒。\n- 具有溶度积阈值的沉淀速率的质量作用动力学。\n- 作为将演化算子分解为输运和反应子算子的数值算子分裂法。\n\n您的程序必须实现上述三种方法，并为以下测试套件计算最终时间 $t=T$ 时的总沉淀固体量。所有参数均采用化学中与国际单位制一致的单位：浓度单位为 $\\mathrm{mol/L}$，时间单位为 $\\mathrm{s}$，溶度积 $K_{\\mathrm{sp}}$ 单位为 $\\mathrm{(mol/L)^2}$。所有请求的输出均以 $\\mathrm{mol/L}$ 报告。\n\n测试套件（三种情况）：\n- 情况 A（明显触发沉淀）：\n  - $C_{\\mathrm{Ca}}(0) = 5\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$。\n  - $J_0 = 2\\times 10^{-3}$, $t_{\\mathrm{inj}} = 2$, $T=10$。\n  - 分裂的时间步长：$\\Delta t = 0.05$。\n- 情况 B（接近平衡的起始状态，轻微的过饱和脉冲）：\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-3}$, $C_{\\mathrm{CO_3}}(0) = K_{\\mathrm{sp}}/C_{\\mathrm{Ca}}(0) = 3.3\\times 10^{-6}$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$。\n  - $J_0 = 5\\times 10^{-7}$, $t_{\\mathrm{inj}} = 1$, $T=10$。\n  - 分裂的时间步长：$\\Delta t = 0.05$。\n- 情况 C（预期无沉淀）：\n  - $C_{\\mathrm{Ca}}(0) = 1\\times 10^{-6}$, $C_{\\mathrm{CO_3}}(0) = 0$, $S(0)=0$。\n  - $K_{\\mathrm{sp}} = 3.3\\times 10^{-9}$, $k = 10$。\n  - $J_0 = 1\\times 10^{-5}$, $t_{\\mathrm{inj}} = 0.1$, $T=5$。\n  - 分裂的时间步长：$\\Delta t = 0.05$。\n\n需强制执行的算法细节：\n- 在 SNIA 和 SIA 中，在大小为 $\\Delta t$ 的时间步内的任何反应更新期间，消耗量 $\\Delta c = r\\,\\Delta t$ 必须被限制为 $\\Delta c \\le \\min\\!\\left(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}\\right)$ 以避免负浓度。使用如上所述的速率定律，其中 $r \\ge 0$，如果未饱和则 $r=0$。\n- 在 SIA 中，每个时间步使用固定的迭代次数，等于 $8$，并使用最大范数下 $10^{-12}$ 的容差进行收敛检查；如果收敛则提前终止。\n- 在整体参考解中，使用具有严格容差的刚性隐式积分器来近似 $[0,T]$ 上的精确解。\n\n每种情况所需的输出：\n- 程序必须为每种情况计算五个浮点数：\n  - 来自整体未分裂参考解的 $S_{\\mathrm{ref}}(T)$，\n  - 来自顺序非迭代法的 $S_{\\mathrm{SNIA}}(T)$，\n  - 来自顺序迭代法的 $S_{\\mathrm{SIA}}(T)$，\n  - $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$，\n  - $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$。\n- 将每个值以 $\\mathrm{mol/L}$ 表示，并四舍五入到八位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序由情况 A 的五个四舍五入的浮点数，然后是情况 B，然后是情况 C 的浮点数连接而成。例如，您的输出必须如下所示：\n  $$ [x_1,x_2,x_3,x_4,x_5,x_6,x_7,x_8,x_9,x_{10},x_{11},x_{12},x_{13},x_{14},x_{15}] $$\n  其中每个 $x_i$ 是一个小数点后有八位数字的小数，代表三种情况下所需的以 $\\mathrm{mol/L}$ 为单位的量。",
            "solution": "用户提供了一个计算地球化学基准的问题陈述。根据协议，第一步是验证问题陈述。\n\n### 第 1 步：提取已知条件\n- **系统变量：** $C_{\\mathrm{Ca}}(t)$（溶解钙浓度，$\\mathrm{mol/L}$），$C_{\\mathrm{CO_3}}(t)$（溶解碳酸盐浓度，$\\mathrm{mol/L}$），$S(t)$（沉淀的固体碳酸盐，$\\mathrm{mol/L}$）。反应器体积为 $1$ 升。\n- **沉淀动力学：** $r(t) = k \\cdot \\max(0, C_{\\mathrm{Ca}}(t)C_{\\mathrm{CO_3}}(t) - K_{\\mathrm{sp}})$，其中 $k$ 是速率常数（$\\mathrm{L\\,mol^{-1}\\,s^{-1}}$），$K_{\\mathrm{sp}}$ 是溶度积（$\\mathrm{(mol/L)^2}$）。\n- **质量平衡方程 (ODEs):**\n  $$ \\frac{dC_{\\mathrm{Ca}}}{dt} = J_{\\mathrm{Ca}}(t) - r(t) $$\n  $$ \\frac{dC_{\\mathrm{CO_3}}}{dt} = J_{\\mathrm{CO_3}}(t) - r(t) $$\n  $$ \\frac{dS}{dt} = r(t) $$\n- **源项：** $J_{\\mathrm{Ca}}(t) = 0$。$J_{\\mathrm{CO_3}}(t)$ 是一个方波脉冲：当 $0 \\le t < t_{\\mathrm{inj}}$ 时为 $J_0$，当 $t \\ge t_{\\mathrm{inj}}$ 时为 $0$。\n- **数值方案：**\n    1.  **整体法：** 高精度隐式刚性 ODE 求解器，用于参考解。\n    2.  **SNIA (顺序非迭代法):** 一阶分裂。\n        - 输运步骤：用源项在 $\\Delta t$ 内更新浓度。\n        - 反应步骤：使用在输运后状态下评估的速率进行显式欧拉更新。\n        - 限制：消耗量 $\\Delta c = r\\Delta t$ 受反应物可用量的限制，即输运后 $\\Delta c \\le \\min(C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}})$。\n    3.  **SIA (顺序迭代法):** 在每个时间步 $\\Delta t$ 内进行 Picard 迭代。\n        - 更新规则：$C^{(m+1)} = C^n + \\Delta t(J - r(C^{(m)}))$。\n        - 最大迭代次数：$8$。\n        - 收敛容差：最大范数为 $10^{-12}$。\n        - 限制：必须在每次迭代中强制非负性。\n- **测试用例：** 提供了三个不同的用例（A, B, C），包含具体的初始条件、参数（$K_{\\mathrm{sp}}, k$）、源项（$J_0, t_{\\mathrm{inj}}$）和模拟时间（$T, \\Delta t$）。\n- **所需输出：** 对每个用例，报告五个四舍五入到八位小数的值：$S_{\\mathrm{ref}}(T)$、$S_{\\mathrm{SNIA}}(T)$、$S_{\\mathrm{SIA}}(T)$，以及绝对误差 $|S_{\\mathrm{SNIA}}(T) - S_{\\mathrm{ref}}(T)|$ 和 $|S_{\\mathrm{SIA}}(T) - S_{\\mathrm{ref}}(T)|$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行严格评估：\n- **科学基础：** 该问题基于质量守恒和标准质量作用化学动力学的基本原理。将其表述为常微分方程组（ODEs）是模拟间歇式反应器的标准方法。该问题在科学上是合理的。\n- **适定性：** 问题定义了一个具有指定初始条件和分段常数强迫函数的一阶常微分方程组。速率函数是连续且 Lipschitz 的，这保证了解的存在性和唯一性。所有必需的参数和算法细节都已提供。该问题是适定的。\n- **客观性：** 问题使用精确的数学定义和客观、定量的语言进行陈述。没有歧义或主观内容。\n- **完整性和一致性：** 问题是自洽的。所有必要的数据、初始条件、常数和算法约束都已提供。设置中没有矛盾。\n- **现实性和可行性：** 所选的浓度、速率常数和时间尺度的参数对于水相碳酸盐化学是合理的，使其成为一个现实的基准问题。\n\n### 第 3 步：结论与行动\n该问题是**有效的**。它是一个定义明确、科学合理且不平凡的基准，用于比较反应输运模型中的数值方法。将提供一个解决方案。\n\n### 求解设计\n\n解决方案将使用 Python 实现，并遵循指定的环境。问题要求评估三种不同的数值方法，用于求解描述间歇式反应器中碳酸盐沉淀的常微分方程组。\n\n**1. 整体（参考）解**\n参考解是通过整体求解耦合的 ODE 系统获得的，这意味着所有项（源和反应）都同时处理。鉴于可能存在的刚性（由于与源注入相比反应动力学较快），使用刚性隐式求解器是合适的。\n系统定义为 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t, \\mathbf{y})$，其中 $\\mathbf{y} = [C_{\\mathrm{Ca}}, C_{\\mathrm{CO_3}}, S]^T$。向量函数 $\\mathbf{f}$ 是：\n$$ \\mathbf{f}(t, \\mathbf{y}) = \\begin{bmatrix} -r(y_1, y_2) \\\\ J_{\\mathrm{CO_3}}(t) - r(y_1, y_2) \\\\ r(y_1, y_2) \\end{bmatrix} $$\n其中 $y_1=C_{\\mathrm{Ca}}$ 和 $y_2=C_{\\mathrm{CO_3}}$。我们将使用 `scipy.integrate.solve_ivp` 和 `BDF` (后向差分公式) 方法，并设置严格的容差（$rtol=10^{-12}$, $atol=10^{-15}$）以确保高精度的参考解。\n\n**2. 顺序非迭代法 (SNIA)**\n这是一种一阶算子分裂法。在从 $t_n$ 到 $t_{n+1}$ 的每个时间步 $\\Delta t$ 内，我们依次应用输运和反应算子。\n- **输运步骤：** 首先，我们考虑外部源项。令 $\\mathbf{C}^n = [C_{\\mathrm{Ca}}^n, C_{\\mathrm{CO_3}}^n]^T$。\n  $$ \\mathbf{C}^* = \\mathbf{C}^n + \\Delta t \\, \\mathbf{J}(t_n) $$\n  其中 $\\mathbf{J}(t_n) = [0, J_{\\mathrm{CO_3}}(t_n)]^T$。\n- **反应步骤：** 接下来，我们使用来自输运步骤的状态 $\\mathbf{C}^*$ 通过显式欧拉步骤求解反应部分。\n  $$ r^* = k \\cdot \\max(0, C_{\\mathrm{Ca}}^* C_{\\mathrm{CO_3}}^* - K_{\\mathrm{sp}}) $$\n  形成的潜在沉淀物量为 $\\Delta S = r^* \\Delta t$。为确保浓度的非负性，该量受到限制：\n  $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S, C_{\\mathrm{Ca}}^*, C_{\\mathrm{CO_3}}^*) $$\n  该步骤的最终浓度为：\n  $$ C_{\\mathrm{Ca}}^{n+1} = C_{\\mathrm{Ca}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ C_{\\mathrm{CO_3}}^{n+1} = C_{\\mathrm{CO_3}}^* - \\Delta S_{\\mathrm{capped}} $$\n  $$ S^{n+1} = S^n + \\Delta S_{\\mathrm{capped}} $$\n\n**3. 顺序迭代法 (SIA)**\nSIA 通过在时间步内迭代输运和反应来减少分裂误差。问题指定使用 Picard 迭代来求解隐式系统。对于从 $t_n$ 到 $t_{n+1}$ 的每个时间步：\n我们寻求一个满足隐式关系的解 $\\mathbf{y}^{n+1}$。Picard 迭代方案给出为：\n$$ \\mathbf{y}^{(m+1)} = \\mathbf{y}^n + \\Delta t \\left( \\mathbf{J}(t_n) - \\mathbf{R}(\\mathbf{y}^{(m)}) \\right) $$\n其中 $\\mathbf{R}$ 代表反应项向量。让我们按分量写出这个过程，包括非负性限制。初始猜测为 $\\mathbf{y}^{(0)} = \\mathbf{y}^n$。对于迭代 $m$：\n1.  使用前一次迭代的浓度计算速率：$r^{(m)} = \\text{rate}(C_{\\mathrm{Ca}}^{(m)}, C_{\\mathrm{CO_3}}^{(m)})$。\n2.  计算固体的潜在变化：$\\Delta S_{\\mathrm{potential}} = r^{(m)} \\Delta t$。\n3.  可用于沉淀的资源基于时间步开始时的状态 $\\mathbf{y}^n$ 加上输运量。可被消耗的物种量为 $C_{\\mathrm{Ca}}^n$ 和 $C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)$。\n4.  对固体的变化应用限制：\n    $$ \\Delta S_{\\mathrm{capped}} = \\min(\\Delta S_{\\mathrm{potential}}, \\, C_{\\mathrm{Ca}}^n, \\, C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n)) $$\n5.  基于时间步开始时的状态 $n$ 更新下一次迭代 $(m+1)$ 的状态：\n    $$ C_{\\mathrm{Ca}}^{(m+1)} = C_{\\mathrm{Ca}}^n - \\Delta S_{\\mathrm{capped}} $$\n    $$ C_{\\mathrm{CO_3}}^{(m+1)} = C_{\\mathrm{CO_3}}^n + \\Delta t \\, J_{\\mathrm{CO_3}}(t_n) - \\Delta S_{\\mathrm{capped}} $$\n    $$ S^{(m+1)} = S^n + \\Delta S_{\\mathrm{capped}} $$\n6.  此迭代最多进行 $8$ 次，或直到连续迭代之间的变化在最大范数下小于 $10^{-12}$ 的容差。最后一次迭代的结果成为该步骤的解 $\\mathbf{y}^{n+1}$。\n\n该实现将处理三个测试用例中的每一个，使用所有三种方法计算最终沉淀的固体 $S(T)$，计算 SNIA 和 SIA 相对于整体参考解的绝对误差，并按要求格式化结果。",
            "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Computes and compares operator splitting methods for a carbonate precipitation benchmark.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (precipitation clearly triggered)\n        {\n            \"name\": \"A\",\n            \"C_Ca0\": 5e-3,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 2e-3,\n            \"t_inj\": 2.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case B (near-equilibrium start, slight supersaturation pulse)\n        {\n            \"name\": \"B\",\n            \"C_Ca0\": 1e-3,\n            \"C_CO30\": 3.3e-9 / 1e-3,  # K_sp / C_Ca(0)\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 5e-7,\n            \"t_inj\": 1.0,\n            \"T\": 10.0,\n            \"dt\": 0.05,\n        },\n        # Case C (no precipitation expected)\n        {\n            \"name\": \"C\",\n            \"C_Ca0\": 1e-6,\n            \"C_CO30\": 0.0,\n            \"S0\": 0.0,\n            \"K_sp\": 3.3e-9,\n            \"k\": 10.0,\n            \"J0\": 1e-5,\n            \"t_inj\": 0.1,\n            \"T\": 5.0,\n            \"dt\": 0.05,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        C_Ca0, C_CO30, S0 = case[\"C_Ca0\"], case[\"C_CO30\"], case[\"S0\"]\n        K_sp, k = case[\"K_sp\"], case[\"k\"]\n        J0, t_inj = case[\"J0\"], case[\"t_inj\"]\n        T, dt = case[\"T\"], case[\"dt\"]\n        \n        def rate_law(C_Ca, C_CO3, k_val, K_sp_val):\n            ion_product = C_Ca * C_CO3\n            if ion_product > K_sp_val:\n                return k_val * (ion_product - K_sp_val)\n            return 0.0\n\n        # --- 1. Monolithic Unsplit Reference Solution ---\n        def ode_system(t, y):\n            C_Ca, C_CO3, S = y\n            J_CO3 = J0 if t < t_inj else 0.0\n            r = rate_law(C_Ca, C_CO3, k, K_sp)\n            dC_Ca_dt = -r\n            dC_CO3_dt = J_CO3 - r\n            dS_dt = r\n            return [dC_Ca_dt, dC_CO3_dt, dS_dt]\n\n        y0 = [C_Ca0, C_CO30, S0]\n        sol = solve_ivp(\n            ode_system, \n            [0, T], \n            y0, \n            method='BDF', \n            rtol=1e-12, \n            atol=1e-15\n        )\n        S_ref = sol.y[2, -1]\n\n        # --- 2. Sequential Non-Iterative Approach (SNIA) ---\n        C_Ca, C_CO3, S = C_Ca0, C_CO30, S0\n        num_steps = int(round(T / dt))\n        time_points = np.linspace(0, T, num_steps + 1)\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            # Transport step\n            J_CO3_step = J0 if t < t_inj else 0.0\n            C_CO3_after_transport = C_CO3 + J_CO3_step * dt\n            C_Ca_after_transport = C_Ca  # J_Ca is 0\n\n            # Reaction step\n            r = rate_law(C_Ca_after_transport, C_CO3_after_transport, k, K_sp)\n            delta_s = r * dt\n            \n            # Capping to enforce non-negativity\n            capped_delta_s = min(delta_s, C_Ca_after_transport, C_CO3_after_transport)\n            \n            # Update state\n            C_Ca = C_Ca_after_transport - capped_delta_s\n            C_CO3 = C_CO3_after_transport - capped_delta_s\n            S = S + capped_delta_s\n        \n        S_snia = S\n\n        # --- 3. Sequential Iterative Approach (SIA) ---\n        C_Ca_n, C_CO3_n, S_n = C_Ca0, C_CO30, S0\n        max_iter = 8\n        tol = 1e-12\n\n        for i in range(num_steps):\n            t = time_points[i]\n            \n            C_Ca_start, C_CO3_start, S_start = C_Ca_n, C_CO3_n, S_n\n            \n            # Initial guess for the iteration (state at n)\n            y_m = np.array([C_Ca_start, C_CO3_start, S_start])\n\n            J_CO3_step = J0 if t < t_inj else 0.0\n\n            for _ in range(max_iter):\n                y_prev_iter = y_m.copy()\n                C_Ca_m_iter, C_CO3_m_iter, _ = y_prev_iter\n\n                r_m = rate_law(C_Ca_m_iter, C_CO3_m_iter, k, K_sp)\n                delta_s_potential = r_m * dt\n                \n                # Budgets are based on state 'n' plus transport\n                budget_Ca = C_Ca_start\n                budget_CO3 = C_CO3_start + J_CO3_step * dt\n                \n                capped_delta_s = min(delta_s_potential, budget_Ca, budget_CO3)\n                \n                # Update to get next iterate (m+1) based on state 'n'\n                C_Ca_new = C_Ca_start - capped_delta_s\n                C_CO3_new = budget_CO3 - capped_delta_s\n                S_new = S_start + capped_delta_s\n                \n                y_m = np.array([C_Ca_new, C_CO3_new, S_new])\n                \n                if np.max(np.abs(y_m - y_prev_iter)) < tol:\n                    break\n            \n            C_Ca_n, C_CO3_n, S_n = y_m\n        S_sia = S_n\n        \n        error_snia = abs(S_snia - S_ref)\n        error_sia = abs(S_sia - S_ref)\n\n        all_results.extend([S_ref, S_snia, S_sia, error_snia, error_sia])\n\n    formatted_results = [f\"{val:.8f}\" for val in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "算子分裂方法的强大功能也伴随着一些实现上的陷阱，其中最常见的就是对边界条件处理不当导致的质量不守恒。本练习将通过一个精心设计的“反面教材”来揭示这一关键问题。你将分析一个在反应步骤后错误地重置边界浓度的分裂格式，并设计一个诊断计算来精确量化由此产生的质量平衡残差。这个实践将让你深刻认识到在分裂格式中正确处理边界通量的极端重要性，并掌握一种验证模型物理守恒性的有效方法。",
            "id": "4094629",
            "problem": "一维反应溶质在长度为 $L$、恒定横截面积为 $A$ 的饱和多孔介质柱中输运。该介质具有恒定的孔隙度 $\\phi$，水流是稳定的，具有从 $x=0$（入口）到 $x=L$（出口）的恒定达西通量 $q$。移动相浓度 $c(x,t)$ 遵循平流和一级反应的质量守恒，其中机械弥散可忽略不计。其控制平衡关系是：控制体积中的总质量变化等于平流净流入减去流出以及积分后的反应项。考虑一个代表整个柱体的单一有限体积单元，其宽度为 $\\Delta x = L$，在入口处有狄利克雷（Dirichlet）流入边界条件 $c(0,t)=c_{\\mathrm{in}}$，在 $x=L$ 处有对流流出边界。在时间 $t$ 时，单元内的总溶质质量为 $M(t) = \\phi A \\Delta x \\, c(t)$。\n\n我们研究一个与序贯非迭代法（Sequential Non-Iterative Approach, SNIA）一致的分裂格式，其中输运子问题（平流）首先在一个时间步 $\\Delta t$ 内推进，然后是反应子问题；而序贯迭代法（Sequential Iterative Approach, SIA）会迭代地协调这些子步骤。对平流使用显式有限体积法更新，在入口和出口面采用迎风格式通量；对反应 $R(c)=-k\\,c$ 使用显式欧拉法。\n\n假设在时间 $t^{n}$ 时的初始单元平均浓度为 $c^{n}$，平流通量使用迎风浓度计算：入口通量 $F_{\\mathrm{in}}^{n}=A q\\,c_{\\mathrm{in}}$ 和出口通量 $F_{\\mathrm{out}}^{n}=A q\\,c^{n}$。平流步骤产生一个中间浓度 $c^{*}$，然后反应步骤在 $\\Delta t$ 时间内更新至 $c^{n+1}$。现在，考虑一种不当的边界条件处理方式：在完成反应步骤后，该格式错误地通过设置 $c^{n+1}:=c_{\\mathrm{in}}$ 在单元内部重新施加狄利克雷边界（而不是仅将其应用于输运子步骤）。这是分裂格式中一个已知的陷阱，它可能违反全局质量平衡。\n\n您必须设计并执行一个诊断计算来检测这种违规。将诊断性质的质量平衡残差定义为：由处理不当的分裂步骤产生的最终单元质量，与通过对（输运子步骤中实际使用的）平流流入减去流出进行积分，再加上（反应子步骤中实际使用的）反应贡献所预测的质量之间的差值。使用以下物理上一致的参数集，计算一个时间步后的该诊断残差：\n- $L=\\Delta x = 0.10$ m,\n- $A = 1.0 \\times 10^{-3}$ m$^{2}$,\n- $\\phi = 0.25$,\n- $q = 1.0 \\times 10^{-5}$ m s$^{-1}$,\n- $c_{\\mathrm{in}} = 1.0$ mol m$^{-3}$,\n- $c^{n} = 0.20$ mol m$^{-3}$,\n- $k = 1.0 \\times 10^{-6}$ s$^{-1}$,\n- $\\Delta t = 1.0 \\times 10^{3}$ s.\n\n将您的最终答案表示为以 mol 为单位的诊断残差。将答案四舍五入至四位有效数字。",
            "solution": "我们从一个宽度为 $\\Delta x$、横截面积为 $A$、孔隙度为 $\\phi$ 的有限体积控制体中的质量守恒开始。单元中的总质量为 $M(t)=\\phi A \\Delta x\\,c(t)$。在一个时间步 $\\Delta t$ 内，精确的质量平衡会将质量变化与时间积分的净流入减去流出，再加上时间积分的反应源/汇项相等。在分裂格式中，我们必须与每个子步骤中实际使用的贡献项保持一致。\n\n我们使用序贯非迭代法（SNIA）：首先在 $\\Delta t$ 时间内进行输运（平流），然后在 $\\Delta t$ 时间内进行反应。采用迎风平流和显式时间积分，输运子步骤使用根据 $t^{n}$ 时刻的已知浓度计算的入口和出口平流通量：\n- 入口平流通量（在 $x=0$ 处）：$F_{\\mathrm{in}}^{n} = A q\\, c_{\\mathrm{in}}$，\n- 出口平流通量（在 $x=L$ 处）：$F_{\\mathrm{out}}^{n} = A q\\, c^{n}$。\n\n用于平流的有限体积显式更新给出了中间浓度 $c^{*}$：\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; \\frac{\\Delta t}{\\phi A \\Delta x}\\,\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; c^{n} \\;+\\; \\frac{\\Delta t\\, q}{\\phi\\, \\Delta x}\\,\\big(c_{\\mathrm{in}} - c^{n}\\big).\n$$\n\n然后，反应子步骤对 $c^{*}$ 应用显式欧拉法处理一级衰减 $R(c)=-k\\,c$：\n\n$$\nc^{n+1}_{\\mathrm{scheme}} \\;=\\; c^{*} \\;+\\; \\Delta t\\,(-k\\,c^{*}) \\;=\\; c^{*}\\,(1 - k\\,\\Delta t).\n$$\n\n如果边界条件得到正确处理（即，仅应用于输运子步骤），则在两个子步骤之后的最终质量将是 $M^{n+1}_{\\mathrm{scheme}}=\\phi A \\Delta x\\,c^{n+1}_{\\mathrm{scheme}}$，并且离散质量平衡恒等式将得到满足：\n\n$$\nM^{n+1}_{\\mathrm{scheme}} \\;=\\; M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big).\n$$\n\n然而，所述的不当边界处理在反应步骤之后将最终浓度重置为 $c_{\\mathrm{in}}$：$c^{n+1}_{\\mathrm{mis}} := c_{\\mathrm{in}}$。由此产生的最终质量为 $M^{n+1}_{\\mathrm{mis}} = \\phi A \\Delta x\\, c_{\\mathrm{in}}$。诊断残差定义为这个处理不当的最终质量与分裂步骤中使用的各项贡献之和的差值：\n\n$$\nR_{\\mathrm{diag}} \\;=\\; M^{n+1}_{\\mathrm{mis}} \\;-\\; \\Big[\\, M^{n} \\;+\\; \\Delta t \\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big) \\;+\\; \\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\\,\\Big].\n$$\n\n根据其构造，一个一致的分裂格式应有 $R_{\\mathrm{diag}}=0$，因此任何非零值都表示违反了质量平衡。\n\n现在我们用给定的参数计算 $R_{\\mathrm{diag}}$。首先，计算平流通量：\n\n$$\nF_{\\mathrm{in}}^{n} \\;=\\; A q\\, c_{\\mathrm{in}} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(1.0\\big) \\;=\\; 1.0 \\times 10^{-8},\n$$\n\n\n$$\nF_{\\mathrm{out}}^{n} \\;=\\; A q\\, c^{n} \\;=\\; \\big(1.0 \\times 10^{-3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)\\,\\big(0.20\\big) \\;=\\; 2.0 \\times 10^{-9}.\n$$\n\n单元内的初始质量为\n\n$$\nM^{n} \\;=\\; \\phi A \\Delta x\\, c^{n} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(0.20\\big) \\;=\\; 5.0 \\times 10^{-6}.\n$$\n\n从平流子步骤计算中间浓度 $c^{*}$：\n\n$$\n\\frac{\\Delta t\\, q}{\\phi\\, \\Delta x} \\;=\\; \\frac{\\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-5}\\big)}{\\big(0.25\\big)\\,\\big(0.10\\big)} \\;=\\; \\frac{1.0 \\times 10^{-2}}{2.5 \\times 10^{-2}} \\;=\\; 0.40,\n$$\n\n\n$$\nc^{*} \\;=\\; c^{n} \\;+\\; 0.40\\,\\big(c_{\\mathrm{in}} - c^{n}\\big) \\;=\\; 0.20 \\;+\\; 0.40\\,\\big(1.0 - 0.20\\big) \\;=\\; 0.20 \\;+\\; 0.40 \\times 0.80 \\;=\\; 0.52.\n$$\n\n在分裂步骤中使用的反应贡献为\n\n$$\n\\phi A \\Delta x\\, \\Delta t\\,\\big(-k\\,c^{*}\\big)\n\\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0 \\times 10^{3}\\big)\\,\\big(-1.0 \\times 10^{-6}\\big)\\,\\big(0.52\\big)\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big)\\,\\big(-5.2 \\times 10^{-4}\\big)\n\\;=\\; -1.3 \\times 10^{-8}.\n$$\n\n在 $\\Delta t$ 内的净平流质量输入为\n\n$$\n\\Delta t\\big(F_{\\mathrm{in}}^{n} - F_{\\mathrm{out}}^{n}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(1.0 \\times 10^{-8} - 2.0 \\times 10^{-9}\\big)\n\\;=\\; \\big(1.0 \\times 10^{3}\\big)\\,\\big(8.0 \\times 10^{-9}\\big)\n\\;=\\; 8.0 \\times 10^{-6}.\n$$\n\n处理不当的最终质量为\n\n$$\nM^{n+1}_{\\mathrm{mis}} \\;=\\; \\phi A \\Delta x\\, c_{\\mathrm{in}} \\;=\\; \\big(0.25\\big)\\,\\big(1.0 \\times 10^{-3}\\big)\\,\\big(0.10\\big)\\,\\big(1.0\\big) \\;=\\; 2.5 \\times 10^{-5}.\n$$\n\n因此，诊断残差为\n\n$$\nR_{\\mathrm{diag}} \\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\Big[\\, \\big(5.0 \\times 10^{-6}\\big) \\;+\\; \\big(8.0 \\times 10^{-6}\\big) \\;+\\; \\big(-1.3 \\times 10^{-8}\\big) \\,\\Big]\n\\;=\\; \\big(2.5 \\times 10^{-5}\\big) \\;-\\; \\big(1.2987 \\times 10^{-5}\\big)\n\\;=\\; 1.2013 \\times 10^{-5}.\n$$\n\n四舍五入到四位有效数字并以 mol 表示，诊断残差为 $1.201 \\times 10^{-5}$。一个非零的正值 $R_{\\mathrm{diag}}$ 表明，在反应步骤后不当地将单元浓度重置为狄利克雷边界值，注入了输运和反应子步骤未计入的额外质量。在序贯迭代法（SIA）中，迭代耦合的子步骤同时保持边界条件的一致性，将使 $R_{\\mathrm{diag}}$趋向于零，从而恢复全局质量平衡。",
            "answer": "$$\\boxed{1.201 \\times 10^{-5}}$$"
        }
    ]
}