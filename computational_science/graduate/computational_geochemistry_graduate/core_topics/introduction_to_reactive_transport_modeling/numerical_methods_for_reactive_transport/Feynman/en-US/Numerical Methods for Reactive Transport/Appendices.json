{
    "hands_on_practices": [
        {
            "introduction": "Before implementing complex models, we must have a robust strategy for verifying our code's correctness. The Method of Manufactured Solutions (MMS) provides a powerful framework for this, allowing us to test our implementation against a problem with a known analytical solution. This practice  guides you through the design of a verification test using MMS and Grid Convergence Testing (GCT), a fundamental procedure for developing reliable scientific software and ensuring your numerical results are accurate.",
            "id": "4094101",
            "problem": "An Advection–Dispersion–Reaction (ADR) transport equation for a dissolved aqueous species concentration $c(x,t)$ in one spatial dimension is given by the balance of advection, dispersion, and first-order reaction, together with a volumetric source term:\n$$\n\\frac{\\partial c}{\\partial t} + v \\,\\frac{\\partial c}{\\partial x} = D \\,\\frac{\\partial^2 c}{\\partial x^2} - k \\, c + q(x,t),\n$$\non the domain $x \\in [0,1]$ and $t \\in [0,T]$, where $v$ is the advective velocity, $D$ is the dispersion coefficient, $k$ is a first-order rate constant, and $q(x,t)$ is a known source term. Suppose the numerical discretization uses backward Euler in time, first-order upwind for the advective flux, and second-order central differences for the dispersive flux on a uniform grid with spatial spacing $\\Delta x$ and time step $\\Delta t$. The theoretical local truncation errors for these choices scale as $\\mathcal{O}(\\Delta t)$ for time, $\\mathcal{O}(\\Delta x)$ for advection, and $\\mathcal{O}(\\Delta x^2)$ for dispersion, so that the expected leading-order global convergence in space for the fully discrete solution is first order when advection is present and not negligible.\n\nYou are asked to define Grid Convergence Testing (GCT) with the Method of Manufactured Solutions (MMS) and to outline a scientifically sound, verifiable procedure to confirm that the observed error rates match the theoretical orders for the above ADR discretization. Your answer should be based on first principles: governing equation balance, consistency of boundary and initial data, and asymptotic error behavior $E(h) = C \\, h^p$ for mesh size $h$ with order $p$. In particular, address how to design a manufactured solution $c_{\\text{exact}}(x,t)$ and corresponding source $q(x,t)$, how to set boundary and initial conditions, how to choose refinement ratios for $\\Delta x$ and $\\Delta t$ to isolate spatial versus temporal convergence, and how to compute observed convergence rates using suitable norms and sequences of grids. Consider scientifically realistic parameters, for example $v = 10^{-4} \\,\\mathrm{m/s}$, $D = 10^{-6} \\,\\mathrm{m^2/s}$, $k = 10^{-5} \\,\\mathrm{s^{-1}}$, and $T = 1.0 \\,\\mathrm{s}$, but do not rely on any special numerical values beyond demonstrating soundness of the procedure.\n\nWhich option correctly defines GCT with MMS and outlines an appropriate verification procedure for the stated ADR discretization?\n\nA. Choose a smooth manufactured solution $c_{\\text{exact}}(x,t)$ on $x \\in [0,1]$, $t \\in [0,T]$, derive $q(x,t)$ by substituting $c_{\\text{exact}}$ into the continuous ADR equation, and impose boundary and initial conditions exactly consistent with $c_{\\text{exact}}$. To verify spatial order, fix a sequence of meshes with $\\Delta x$, $\\Delta x/2$, $\\Delta x/4$ and choose $\\Delta t$ sufficiently small that temporal errors are negligible relative to spatial errors, for example $\\Delta t \\propto \\Delta x^2$. For each mesh, solve the fully discrete system and compute errors $E_h$ in a chosen norm (for instance, the discrete $L_2$ norm at final time) by comparing $c_h$ to $c_{\\text{exact}}$ restricted to the grid. Estimate the observed order $p_{\\text{obs}} = \\frac{\\log(E_h/E_{h/2})}{\\log(2)}$ using at least three successively refined meshes, and check $p_{\\text{obs}} \\approx 1$ for the present scheme in the advective regime. To verify temporal order, fix a sufficiently fine spatial grid to suppress spatial errors and refine $\\Delta t$ (e.g., $\\Delta t$, $\\Delta t/2$, $\\Delta t/4$) to confirm $p_{\\text{obs}} \\approx 1$ in time. If $p_{\\text{obs}}$ stabilizes across refinements, conclude that observed rates match theoretical orders.\n\nB. Use $c_{\\text{exact}}(x,t)$ satisfying homogeneous boundary conditions, set $q(x,t) = 0$ to avoid complicating terms, and run the discretization on grids with $\\Delta x$, $\\Delta x/2$, $\\Delta x/4$ while maintaining a constant Courant–Friedrichs–Lewy (CFL) number, that is $\\Delta t \\propto \\Delta x$. Compute $E_h$ at final time in the $L_\\infty$ norm and use $p_{\\text{obs}} = \\frac{\\log_{10}(E_h/E_{h/2})}{\\log_{10}(2)}$. Expect second-order spatial convergence because the dispersion term is second-order and dominates advection on fine meshes. Two grid levels suffice to confirm the order.\n\nC. Define $c_{\\text{exact}}(x,t)$ and compute a discrete source $q_h$ by applying the fully discrete ADR operator to $c_{\\text{exact}}$ on each grid so that the discrete residual is identically zero. Then, for any $\\Delta x$ and $\\Delta t$, the numerical solution equals $c_{\\text{exact}}$ and the error vanishes, which confirms infinite-order convergence. This demonstrates MMS without the need to analyze boundary conditions or norms. No grid refinement is required.\n\nD. Pick $c_{\\text{exact}}(x,t)$ arbitrarily, enforce boundary conditions that are simple constants independent of $c_{\\text{exact}}$, and derive $q(x,t)$ from the ADR equation but omit the reaction term $k c$ to reduce stiffness. Use three grids with $\\Delta x$, $\\Delta x/3$, $\\Delta x/9$ and a fixed time step $\\Delta t$ equal to the coarse-grid $\\Delta x$ to keep run times manageable. Measure error by interpolating the fine-grid solution to the coarse grid at the final time and compute $p_{\\text{obs}}$ from these two levels only. Since dispersion is second-order, claim that the overall method is second-order in space even with upwind advection.",
            "solution": "The problem statement is a valid exercise in the verification of numerical methods for partial differential equations. I will proceed with the analysis.\n\nThe task is to define a scientifically sound procedure for Grid Convergence Testing (GCT) using the Method of Manufactured Solutions (MMS) to verify the theoretical convergence orders of a given numerical discretization for an Advection–Dispersion–Reaction (ADR) equation.\n\nThe governing PDE is:\n$$\n\\frac{\\partial c}{\\partial t} + v \\,\\frac{\\partial c}{\\partial x} = D \\,\\frac{\\partial^2 c}{\\partial x^2} - k \\, c + q(x,t)\n$$\nThis can be written using a differential operator $\\mathcal{L}$ as $\\mathcal{L}(c) = q(x,t)$, where $\\mathcal{L}(c) \\equiv \\frac{\\partial c}{\\partial t} + v \\,\\frac{\\partial c}{\\partial x} - D \\,\\frac{\\partial^2 c}{\\partial x^2} + k \\, c$.\n\nThe numerical scheme uses:\n1.  Time discretization: Backward Euler, with theoretical local truncation error (LTE) of $\\mathcal{O}(\\Delta t)$.\n2.  Advective flux discretization: First-order upwind, with LTE of $\\mathcal{O}(\\Delta x)$.\n3.  Dispersive flux discretization: Second-order central differences, with LTE of $\\mathcal{O}(\\Delta x^2)$.\n\nThe global error of a stable and consistent numerical method is expected to be of the same order as its LTE. For the spatial discretization, the overall order is determined by the lowest-order term. In this case, the first-order upwind scheme for advection dictates that the overall spatial convergence will be first-order, i.e., of order $\\mathcal{O}(\\Delta x)$, provided the advective term is non-negligible. The problem states that advection is present and not negligible. The temporal convergence is first-order, $\\mathcal{O}(\\Delta t)$.\n\nThe core of the verification procedure is as follows:\n\n**1. Method of Manufactured Solutions (MMS)**\nThe purpose of MMS is to create a test problem for which the exact analytical solution is known a priori. This is achieved by:\n-   Choosing a manufactured solution, $c_{\\text{exact}}(x,t)$, which must be sufficiently smooth (i.e., possess continuous derivatives up to the highest order appearing in the PDE) and non-trivial (i.e., it should excite all terms in the operator $\\mathcal{L}$). A function involving trigonometric or polynomial terms is a common choice, for example, $c_{\\text{exact}}(x,t) = A \\sin(n\\pi x/L) \\cos(\\omega t) + C_0$.\n-   Substituting this chosen $c_{\\text{exact}}(x,t)$ into the continuous differential operator $\\mathcal{L}$ to generate the corresponding source term $q(x,t)$:\n    $$\n    q(x,t) = \\mathcal{L}(c_{\\text{exact}}) = \\frac{\\partial c_{\\text{exact}}}{\\partial t} + v \\,\\frac{\\partial c_{\\text{exact}}}{\\partial x} - D \\,\\frac{\\partial^2 c_{\\text{exact}}}{\\partial x^2} + k \\, c_{\\text{exact}}\n    $$\n-   Setting the initial condition and boundary conditions of the numerical problem to be exactly consistent with the manufactured solution:\n    -   Initial Condition: $c(x,0) = c_{\\text{exact}}(x,0)$ for $x \\in [0,1]$.\n    -   Boundary Conditions: $c(0,t) = c_{\\text{exact}}(0,t)$ and $c(1,t) = c_{\\text{exact}}(1,t)$ for $t \\in [0,T]$.\nBy constructing the problem in this way, the function $c_{\\text{exact}}(x,t)$ is, by definition, the exact solution to the manufactured PDE problem with its specific source term and boundary/initial conditions.\n\n**2. Grid Convergence Testing (GCT)**\nGCT involves solving the manufactured problem on a sequence of systematically refined grids to demonstrate that the numerical error decreases at the theoretically predicted rate.\n-   **Error Calculation**: On a grid with characteristic spacing $h$ (where $h$ can represent $\\Delta x$ or $\\Delta t$), the numerical solution $c_h$ is computed. The error, $E_h$, is the difference between the numerical solution and the exact solution, measured in a suitable norm. For example, the discrete $L_2$ norm at the final time $T$ is:\n    $$\n    E_h = \\left( \\frac{1}{N} \\sum_{i=1}^{N} [c_h(x_i, T) - c_{\\text{exact}}(x_i, T)]^2 \\right)^{1/2}\n    $$\n    where $N$ is the number of grid points.\n-   **Observed Order of Convergence**: For a method with convergence order $p$, the error is expected to behave as $E_h \\approx C h^p$ for sufficiently small $h$. Using two successively refined grids, one with spacing $h_1$ and another with $h_2 = h_1/r$ (where $r$ is the refinement factor), the observed order $p_{\\text{obs}}$ can be computed:\n    $$\n    \\frac{E_{h_1}}{E_{h_2}} \\approx \\frac{C h_1^p}{C (h_1/r)^p} = r^p \\implies p_{\\text{obs}} \\approx \\frac{\\log(E_{h_1}/E_{h_2})}{\\log(r)}\n    $$\n    Using at least three grids (e.g., $h$, $h/2$, $h/4$, for which $r=2$) allows one to check if $p_{\\text{obs}}$ is stabilizing, which indicates that the simulation is in the asymptotic convergence regime.\n\n**3. Isolating Spatial and Temporal Convergence**\nThe total error is a sum of spatial and temporal contributions: $E \\approx C_x \\Delta x^p + C_t \\Delta t^q$. To verify $p$ and $q$ independently, one must be made negligible relative to the other.\n-   **To verify spatial order $p$**: A sequence of spatial grids is used, e.g., with spacings $\\Delta x$, $\\Delta x/2$, $\\Delta x/4$. To ensure the temporal error $C_t \\Delta t^q$ does not corrupt the measurement of the spatial error $C_x \\Delta x^p$, the time step $\\Delta t$ must be refined more aggressively than $\\Delta x$. For our case, $p=1$ and $q=1$. A common strategy is to set $\\Delta t \\propto \\Delta x^2$. This makes the temporal error term $\\mathcal{O}(\\Delta t) = \\mathcal{O}(\\Delta x^2)$, which vanishes faster than the spatial error term $\\mathcal{O}(\\Delta x)$, thereby isolating the spatial convergence. One should then observe $p_{\\text{obs}} \\approx 1$.\n-   **To verify temporal order $q$**: A single, sufficiently fine spatial grid is chosen so that the spatial error $C_x \\Delta x^p$ is negligible. Then, a sequence of time steps is used, e.g., $\\Delta t$, $\\Delta t/2$, $\\Delta t/4$, while holding $\\Delta x$ fixed. One should then observe $p_{\\text{obs}} \\approx 1$ for the temporal convergence.\n\nNow, I will evaluate each option based on these principles.\n\n**Option A:** This option correctly outlines the entire procedure. It accurately describes:\n-   The MMS setup: choose $c_{\\text{exact}}$, derive $q(x,t)$ from the continuous PDE, and set BCs/ICs from $c_{\\text{exact}}$.\n-   The GCT for spatial order: use a sequence of refined meshes ($\\Delta x, \\Delta x/2, \\Delta x/4$), use a suitable error norm ($L_2$), and calculate the observed order $p_{\\text{obs}} = \\frac{\\log(E_h/E_{h/2})}{\\log(2)}$. It correctly identifies the need for three meshes to check for asymptotic behavior.\n-   Isolation of spatial error: It proposes setting $\\Delta t \\propto \\Delta x^2$ to make temporal errors negligible compared to the first-order spatial error, which is a sound and standard technique.\n-   The expected result: It correctly predicts $p_{\\text{obs}} \\approx 1$ for the spatial order due to the first-order upwind scheme in an advection-dominated regime.\n-   Verification of temporal order: It correctly describes fixing a fine spatial grid and refining $\\Delta t$ to observe $p_{\\text{obs}} \\approx 1$.\n-   The final conclusion: It correctly states that the goal is to see if $p_{\\text{obs}}$ stabilizes and matches the theoretical rate.\n**Verdict: Correct.**\n\n**Option B:** This option contains several fundamental errors.\n-   It incorrectly suggests setting $q(x,t) = 0$ and using $c_{\\text{exact}}$ that satisfies homogeneous BCs. This is not MMS. The core of MMS is to derive $q(x,t)$ from a chosen $c_{\\text{exact}}$; setting $q(x,t)=0$ means one is solving the homogeneous problem, for which the solution is generally not known.\n-   It suggests maintaining a constant CFL number, $\\Delta t \\propto \\Delta x$. This procedure jointly refines time and space and does not isolate the spatial order of convergence.\n-   It incorrectly expects second-order convergence. The overall order is limited by the lowest-order term, which is the first-order upwind scheme for advection.\n-   It incorrectly claims that two grid levels are sufficient, which is poor practice.\n**Verdict: Incorrect.**\n\n**Option C:** This option describes a completely different procedure that is not a convergence test.\n-   It proposes defining the source term $q_h$ from the *discrete* operator applied to $c_{\\text{exact}}$. This creates a problem where the numerical solution is, by construction, identical to the exact solution on the grid nodes (up to floating-point error). The resulting error is zero, providing no information about the method's convergence order for the original *continuous* PDE.\n-   The conclusion of \"infinite-order convergence\" is a meaningless artifact of this flawed setup. This procedure does not verify the code's implementation of the continuous model.\n**Verdict: Incorrect.**\n\n**Option D:** This option is replete with methodological flaws.\n-   It suggests using boundary conditions independent of $c_{\\text{exact}}$. This introduces boundary errors that will corrupt the solution and prevent the measurement of the true interior convergence rate.\n-   It suggests omitting the reaction term. This means the test is verifying a code for a different PDE, not the one specified.\n-   It proposes using a fixed time step $\\Delta t$ while refining $\\Delta x$. As $\\Delta x \\to 0$, the fixed temporal error will eventually dominate the shrinking spatial error, causing the observed convergence rate to decay towards zero, which spoils the test.\n-   It suggests measuring error by comparing solutions on different grids, rather than comparing to the known exact solution. This is a method for estimating error when the exact solution is unknown, which is not the case in MMS.\n-   It incorrectly claims the method is second-order.\n**Verdict: Incorrect.**\n\nIn summary, Option A is the only one that describes a scientifically rigorous and standard procedure for verification using the Method of Manufactured Solutions and Grid Convergence Testing.",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "Numerical schemes for transport equations can introduce errors that mimic physical processes, such as numerical diffusion, where the discretization itself causes artificial spreading of a solute plume. This hands-on coding exercise  challenges you to implement a finite difference scheme and use the method of moments to quantify this numerical diffusion. By comparing results on coarse and fine meshes, you will learn to distinguish numerical artifacts from physical reality, a critical skill for interpreting simulation results.",
            "id": "4094145",
            "problem": "Consider one-dimensional solute transport in a homogeneous saturated porous medium governed by conservation of mass and Fickian dispersion. The fundamental basis is the one-dimensional advection–dispersion equation for a conservative solute, derived from continuity and Fick’s law: $$\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = D \\frac{\\partial^2 c}{\\partial x^2},$$ where $c(x,t)$ is concentration, $u$ is constant pore water velocity (assumed positive), and $D$ is the physical dispersion coefficient. Assume a linear relation $D = \\alpha u$, where $\\alpha$ is the physical dispersivity. The computational domain is the interval $x \\in [0,L]$, with zero diffusive flux at both boundaries, and advection oriented from left to right. The initial condition is a Gaussian pulse centered at $x_0$ with standard deviation $\\sigma_0$, $$c(x,0) = \\frac{1}{\\sqrt{2 \\pi \\sigma_0^2}} \\exp\\left( -\\frac{(x-x_0)^2}{2 \\sigma_0^2} \\right).$$\n\nYou must implement a fully implicit finite difference scheme in time (Backward Euler) with first-order upwind for the advective term and centered difference for the dispersive term on a uniform mesh of spacing $\\Delta x$. Let $\\Delta t$ denote the time step, and let $c_i^n$ denote the discrete concentration at node $i$ and time level $n$. For positive $u$, the discrete implicit scheme for interior nodes $i$ is defined by\n$$\\frac{c_i^{n+1} - c_i^n}{\\Delta t} + u \\frac{c_i^{n+1} - c_{i-1}^{n+1}}{\\Delta x} = D \\frac{c_{i+1}^{n+1} - 2 c_i^{n+1} + c_{i-1}^{n+1}}{\\Delta x^2}.$$\nImpose zero diffusive flux at $x=0$ and $x=L$ via mirrored ghost values $c_{-1}^{n+1} = c_{1}^{n+1}$ and $c_{N}^{n+1} = c_{N-2}^{n+1}$, where $N$ is the number of grid points, and treat the advective derivative at the left boundary consistently with the upwind stencil. The implicit system at each time step should be solved exactly for $c^{n+1}$ on the tridiagonal system induced by the above discretization.\n\nThe apparent dispersivity at time $t$ is defined by the second central moment of the discrete solution, which for a finite volume approximation is computed from the discrete mass $m(t) = \\sum_i c_i(t) \\Delta x$, the center-of-mass $x_\\mathrm{cm}(t) = \\frac{1}{m(t)} \\sum_i x_i c_i(t) \\Delta x$, and the variance $\\mathrm{Var}(t) = \\frac{1}{m(t)} \\sum_i (x_i - x_\\mathrm{cm}(t))^2 c_i(t) \\Delta x$. The apparent dispersion coefficient is estimated as $$D_{\\mathrm{app}} = \\frac{\\mathrm{Var}(t) - \\mathrm{Var}(0)}{2 t},$$ and the apparent dispersivity is $$\\alpha_{\\mathrm{app}} = \\frac{D_{\\mathrm{app}}}{|u|}.$$ Express $\\alpha_{\\mathrm{app}}$ in meters.\n\nYour program must run two mesh resolutions for each test case, a coarse mesh and a fine mesh, and compute $\\alpha_{\\mathrm{app}}$ at a specified final time $t_{\\mathrm{final}}$ for both meshes. By comparing $\\alpha_{\\mathrm{app}}$ across mesh resolutions, the program enables distinguishing physical dispersion from numerical diffusion: if numerical diffusion is present, $\\alpha_{\\mathrm{app}}$ will be larger on the coarse mesh and will decrease toward the known physical dispersivity as the mesh is refined.\n\nUse the following test suite. For each case, use $N_t = 200$ time steps so that $\\Delta t = t_{\\mathrm{final}} / N_t$. The Gaussian initial condition parameters are the same unless specified otherwise. For all cases, the initial condition parameters are $x_0 = 1.0\\,\\mathrm{m}$ and $\\sigma_0 = 0.02\\,\\mathrm{m}$. The domain length is $L = 10.0\\,\\mathrm{m}$ in all cases. The velocity is $u = 1.0 \\times 10^{-4}\\,\\mathrm{m/s}$ in all cases.\n\n- Case $1$ (moderate physical dispersion): $\\alpha = 0.01\\,\\mathrm{m}$, $D = \\alpha u$, $t_{\\mathrm{final}} = 5.0 \\times 10^{4}\\,\\mathrm{s}$, coarse mesh $\\Delta x = 0.5\\,\\mathrm{m}$, fine mesh $\\Delta x = 0.01\\,\\mathrm{m}$.\n- Case $2$ (strong physical dispersion): $\\alpha = 0.5\\,\\mathrm{m}$, $D = \\alpha u$, $t_{\\mathrm{final}} = 2.0 \\times 10^{4}\\,\\mathrm{s}$, coarse mesh $\\Delta x = 0.5\\,\\mathrm{m}$, fine mesh $\\Delta x = 0.01\\,\\mathrm{m}$.\n- Case $3$ (no physical dispersion): $\\alpha = 0.0\\,\\mathrm{m}$, $D = \\alpha u = 0.0\\,\\mathrm{m^2/s}$, $t_{\\mathrm{final}} = 5.0 \\times 10^{4}\\,\\mathrm{s}$, coarse mesh $\\Delta x = 0.5\\,\\mathrm{m}$, fine mesh $\\Delta x = 0.01\\,\\mathrm{m}$.\n\nFor each case, compute $\\alpha_{\\mathrm{app}}$ at $t_{\\mathrm{final}}$ for both meshes, and aggregate the results in the following final output format. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, in the exact order:\n$$[\\alpha_{\\mathrm{app}}^{(1,\\mathrm{coarse})}, \\alpha_{\\mathrm{app}}^{(1,\\mathrm{fine})}, \\alpha_{\\mathrm{app}}^{(2,\\mathrm{coarse})}, \\alpha_{\\mathrm{app}}^{(2,\\mathrm{fine})}, \\alpha_{\\mathrm{app}}^{(3,\\mathrm{coarse})}, \\alpha_{\\mathrm{app}}^{(3,\\mathrm{fine})}],$$\nwith each entry a floating-point number in meters.",
            "solution": "The user-provided problem has been critically validated and is determined to be a valid, well-posed, and scientifically sound exercise in computational geochemistry. It presents a standard one-dimensional advection-dispersion problem to be solved with a specific finite difference method. The objective is to quantify the effect of numerical diffusion by comparing apparent dispersivity across different mesh resolutions. The problem is complete, free of contradictions, and uses standard, verifiable principles.\n\nThe solution proceeds as follows. First, the specified fully implicit finite difference scheme is formulated as a linear system of equations for each time step. Second, the boundary conditions are incorporated into this system, resulting in a tridiagonal matrix structure. Third, a time-stepping algorithm is designed to solve for the concentration profile at the final time. Finally, the apparent dispersivity is calculated from the second central moment of the initial and final concentration profiles as prescribed.\n\nThe governing advection-dispersion equation (ADE) is given by:\n$$\n\\frac{\\partial c}{\\partial t} + u \\frac{\\partial c}{\\partial x} = D \\frac{\\partial^2 c}{\\partial x^2}\n$$\nwhere $c(x,t)$ is the solute concentration, $u$ is the constant positive pore water velocity, and $D$ is the dispersion coefficient. The domain is $x \\in [0, L]$.\n\nWe discretize this equation on a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$. Let $c_i^n \\approx c(i\\Delta x, n\\Delta t)$. The problem specifies a fully implicit scheme (Backward Euler in time), with a first-order upwind difference for the advection term and a second-order central difference for the dispersion term. For an interior grid node $i$, this yields:\n$$\n\\frac{c_i^{n+1} - c_i^n}{\\Delta t} + u \\frac{c_i^{n+1} - c_{i-1}^{n+1}}{\\Delta x} = D \\frac{c_{i+1}^{n+1} - 2c_i^{n+1} + c_{i-1}^{n+1}}{\\Delta x^2}\n$$\nThis equation can be rearranged to group the unknown terms at time level $n+1$ on the left-hand side (LHS) and the known terms at time level $n$ on the right-hand side (RHS):\n$$\n- \\left(\\frac{u \\Delta t}{\\Delta x} + \\frac{D \\Delta t}{\\Delta x^2}\\right) c_{i-1}^{n+1} + \\left(1 + \\frac{u \\Delta t}{\\Delta x} + \\frac{2 D \\Delta t}{\\Delta x^2}\\right) c_i^{n+1} - \\left(\\frac{D \\Delta t}{\\Delta x^2}\\right) c_{i+1}^{n+1} = c_i^n\n$$\nDefining the Courant number, $C_r = \\frac{u \\Delta t}{\\Delta x}$, and the numerical diffusion number (related to the Péclet number), $P_e = \\frac{D \\Delta t}{\\Delta x^2}$, the equation for interior nodes becomes:\n$$\n-(C_r + P_e) c_{i-1}^{n+1} + (1 + C_r + 2P_e) c_i^{n+1} - P_e c_{i+1}^{n+1} = c_i^n\n$$\nThis forms a system of linear equations $A \\mathbf{c}^{n+1} = \\mathbf{c}^n$, where $\\mathbf{c}^n$ is the vector of concentrations at time level $n$.\n\nThe boundary conditions of zero diffusive flux are imposed using ghost nodes. The grid consists of $N$ points indexed $i=0, 1, \\dots, N-1$.\nAt the left boundary ($x=0$, node $i=0$), the condition $c_{-1}^{n+1} = c_{1}^{n+1}$ is used. Substituting this into the general discrete equation for $i=0$:\n$$\n(1 + C_r + 2P_e) c_0^{n+1} - (C_r + 2P_e) c_1^{n+1} = c_0^n\n$$\nAt the right boundary ($x=L$, node $i=N-1$), the condition is $c_{N}^{n+1} = c_{N-2}^{n+1}$. Substituting this into the general equation for $i=N-1$:\n$$\n-(C_r + 2P_e) c_{N-2}^{n+1} + (1 + C_r + 2P_e) c_{N-1}^{n+1} = c_{N-1}^n\n$$\nThe resulting $N \\times N$ matrix $A$ is tridiagonal and can be solved efficiently at each time step. The main diagonal elements are all $(1 + C_r + 2P_e)$. The sub-diagonal elements are $-(C_r + P_e)$, except for the last one which is $-(C_r + 2P_e)$. The super-diagonal elements are $-P_e$, except for the first one which is $-(C_r + 2P_e)$.\n\nThe simulation starts with the Gaussian initial condition at $t=0$:\n$$\nc(x,0) = \\frac{1}{\\sqrt{2 \\pi \\sigma_0^2}} \\exp\\left( -\\frac{(x-x_0)^2}{2 \\sigma_0^2} \\right)\n$$\nThe value of variance at $t=0$, $\\mathrm{Var}(0)$, is computed from this initial profile using the provided discrete moment formulas. The simulation then proceeds for $N_t$ time steps, from $t=0$ to $t=t_{\\mathrm{final}}$, by repeatedly solving the tridiagonal system. After the final step, the variance $\\mathrm{Var}(t_{\\mathrm{final}})$ is calculated from the resulting concentration profile $c(x, t_{\\mathrm{final}})$.\n\nFinally, the apparent dispersion coefficient $D_{\\mathrm{app}}$ and apparent dispersivity $\\alpha_{\\mathrm{app}}$ are computed:\n$$\nD_{\\mathrm{app}} = \\frac{\\mathrm{Var}(t_{\\mathrm{final}}) - \\mathrm{Var}(0)}{2 t_{\\mathrm{final}}}, \\quad \\alpha_{\\mathrm{app}} = \\frac{D_{\\mathrm{app}}}{|u|}\n$$\nThis procedure is executed for each combination of physical parameters and mesh resolutions specified in the problem statement.",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef run_simulation(L, u, alpha, x0, sigma0, t_final, Nt, dx):\n    \"\"\"\n    Runs a single 1D advection-dispersion simulation and computes apparent dispersivity.\n\n    Args:\n        L (float): Domain length [m].\n        u (float): Pore water velocity [m/s].\n        alpha (float): Physical dispersivity [m].\n        x0 (float): Initial pulse center [m].\n        sigma0 (float): Initial pulse standard deviation [m].\n        t_final (float): Final simulation time [s].\n        Nt (int): Number of time steps.\n        dx (float): Spatial grid spacing [m].\n\n    Returns:\n        float: The computed apparent dispersivity alpha_app [m].\n    \"\"\"\n    # 1. Setup grid and parameters\n    # The grid has N points, from x=0 to x=L inclusive.\n    N = int(round(L / dx)) + 1\n    x = np.linspace(0, L, N)\n    \n    # Check if dx from linspace matches input dx\n    actual_dx = x[1] - x[0]\n\n    dt = t_final / Nt\n    D = alpha * u\n    \n    # Dimensionless numbers\n    C = u * dt / actual_dx  # Courant number\n    P = D * dt / actual_dx**2 # Diffusion number\n\n    # 2. Initial condition and its moments\n    c_initial = (1.0 / np.sqrt(2 * np.pi * sigma0**2)) * np.exp(-(x - x0)**2 / (2 * sigma0**2))\n    \n    m0 = np.sum(c_initial) * actual_dx\n    x_cm0 = (1.0 / m0) * np.sum(x * c_initial) * actual_dx\n    var0 = (1.0 / m0) * np.sum((x - x_cm0)**2 * c_initial) * actual_dx\n\n    # 3. Assemble the tridiagonal system matrix A in banded form\n    # The matrix A is for the system A * c_next = c_current\n    \n    # Main diagonal\n    diag = np.full(N, 1.0 + C + 2.0 * P)\n    \n    # Lower diagonal (a_{i, i-1})\n    lower = np.full(N - 1, -(C + P))\n    lower[-1] = -(C + 2.0 * P)  # For equation at node N-1\n    \n    # Upper diagonal (a_{i, i+1})\n    upper = np.full(N - 1, -P)\n    upper[0] = -(C + 2.0 * P)  # For equation at node 0\n\n    # SciPy's banded matrix format (l=1, u=1)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = upper      # Super-diagonal\n    ab[1, :] = diag        # Main diagonal\n    ab[2, :-1] = lower     # Sub-diagonal\n    \n    # 4. Time stepping loop\n    c_current = c_initial.copy()\n    for _ in range(Nt):\n        # Solve the linear system A * c_next = c_current\n        c_next = solve_banded((1, 1), ab, c_current)\n        c_current = c_next\n    \n    # 5. Calculate final moments and apparent dispersivity\n    c_final = c_current\n    m_final = np.sum(c_final) * actual_dx\n    if m_final == 0:  # Avoid division by zero if all mass leaves the domain\n        return np.nan\n        \n    x_cm_final = (1.0 / m_final) * np.sum(x * c_final) * actual_dx\n    var_final = (1.0 / m_final) * np.sum((x - x_cm_final)**2 * c_final) * actual_dx\n    \n    # Apparent dispersion coefficient and dispersivity\n    D_app = (var_final - var0) / (2.0 * t_final)\n    alpha_app = D_app / np.abs(u)\n\n    return alpha_app\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement\n    # Format: (alpha, t_final, dx_coarse, dx_fine)\n    test_cases = [\n        (0.01, 5.0e4, 0.5, 0.01),  # Case 1\n        (0.5, 2.0e4, 0.5, 0.01),   # Case 2\n        (0.0, 5.0e4, 0.5, 0.01),   # Case 3\n    ]\n\n    # Shared parameters for all cases\n    L = 10.0          # m\n    u = 1.0e-4        # m/s\n    x0 = 1.0          # m\n    sigma0 = 0.02     # m\n    Nt = 200\n\n    results = []\n    for alpha, t_final, dx_coarse, dx_fine in test_cases:\n        # Run simulation for the coarse mesh\n        alpha_app_coarse = run_simulation(L, u, alpha, x0, sigma0, t_final, Nt, dx_coarse)\n        results.append(alpha_app_coarse)\n\n        # Run simulation for the fine mesh\n        alpha_app_fine = run_simulation(L, u, alpha, x0, sigma0, t_final, Nt, dx_fine)\n        results.append(alpha_app_fine)\n\n    # Print final results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver\nsolve()\n```"
        },
        {
            "introduction": "Solving reactive transport problems involves coupling transport and chemical reactions, which often operate on different timescales. Two common strategies are to solve all processes simultaneously in a \"globally implicit\" scheme or sequentially using an \"operator splitting\" approach like the Sequential Non-Iterative Approach (SNIA). This advanced practice  requires you to implement both methods to gain practical insight into the trade-offs between computational simplicity and numerical accuracy, helping you make informed decisions when modeling complex geochemical systems.",
            "id": "4094096",
            "problem": "Consider the one-dimensional reactive transport of a single aqueous species with concentration $C(x,t)$ governed by conservation of mass, constant linear advection, Fickian dispersion, and a linear first-order reaction. The governing partial differential equation is\n$$\n\\frac{\\partial C}{\\partial t} + v \\frac{\\partial C}{\\partial x} = D \\frac{\\partial^2 C}{\\partial x^2} - k C,\n$$\non the spatial domain $x \\in [0,L]$ with periodic boundary conditions and an initial Gaussian condition centered at $x_0$,\n$$\nC(x,0) = \\frac{M_0}{\\sqrt{2\\pi}\\,\\sigma_0} \\exp\\left(-\\frac{(x-x_0)^2}{2\\sigma_0^2}\\right).\n$$\nHere $v$ is the constant pore-water velocity in $\\mathrm{m/s}$, $D$ is the constant hydrodynamic dispersion coefficient in $\\mathrm{m^2/s}$, and $k$ is the first-order reaction rate in $\\mathrm{s^{-1}}$. The mass parameter $M_0$ has units $\\mathrm{mol/m^2}$ so that $C$ has units $\\mathrm{mol/m^3}$. The Gaussian width is $\\sigma_0$ in $\\mathrm{m}$.\n\nYour task is to implement and compare two numerical schemes on the same uniform spatial mesh and time step:\n- The Sequential Non-Iterative Approach (SNIA): advance one time step by solving the transport subproblem without reaction, then apply the reaction subproblem, both implicitly in time (Backward Euler).\n- The Globally Implicit scheme: advance one time step by solving the fully coupled transport-reaction system implicitly (Backward Euler).\n\nUse a uniform grid with $N$ cells of spacing $\\Delta x = L/N$. Discretize the advection term with first-order upwind differences and the dispersion term with second-order centered differences. Enforce periodic boundary conditions in the spatial discretization. Use Backward Euler time stepping with time step $\\Delta t$; integrate to final time $T$ using $N_t = T/\\Delta t$ steps (assume $T/\\Delta t$ is an integer). In all cases, set $x_0=L/2$.\n\nYou must compute the following two quantitative diagnostics at the final time $T$:\n- Numerical diffusion metric: compute the mass-weighted second central moment (variance) of the final concentration field, denoted $\\sigma_\\mathrm{num}^2(T)$, and subtract the physically expected variance $\\sigma_\\mathrm{phys}^2(T)$ for advection-dispersion with constant coefficients and a Gaussian initial condition. The physical variance increment due to dispersion over time $T$ is given by $2 D T$, and advection preserves the variance while reaction uniformly rescales $C$ without changing its shape. Therefore,\n$$\n\\sigma_\\mathrm{phys}^2(T) = \\sigma_0^2 + 2 D T,\n$$\nand your numerical diffusion metric must be reported as the float\n$$\nE_\\mathrm{diff} = \\sigma_\\mathrm{num}^2(T) - \\sigma_\\mathrm{phys}^2(T),\n$$\nin units of $\\mathrm{m^2}$.\n- Splitting error metric: compute the root-mean-square difference per unit length between the Globally Implicit and SNIA solutions at time $T$,\n$$\nE_\\mathrm{split} = \\left(\\frac{1}{L} \\int_0^L \\left(C_\\mathrm{GI}(x,T) - C_\\mathrm{SNIA}(x,T)\\right)^2 \\, dx \\right)^{1/2},\n$$\nand report it as a float in units of $\\mathrm{mol/m^3}$.\n\nImplementation details for discretization:\n- For $v \\ge 0$, the first-order upwind discrete derivative for node $i$ is $\\left(\\frac{C_i - C_{i-1}}{\\Delta x}\\right)$; for $v  0$, use $\\left(\\frac{C_{i+1} - C_i}{\\Delta x}\\right)$. Apply periodic indexing for $i=0$ and $i=N-1$.\n- The discrete Laplacian uses the centered second difference: $\\left(\\frac{C_{i+1} - 2C_i + C_{i-1}}{\\Delta x^2}\\right)$ with periodic indexing.\n- Backward Euler for the transport subproblem solves $\\left(I - \\Delta t\\,(-v D_x + D L)\\right) C^\\ast = C^n$, and the implicit reaction update performs $C^{n+1} = \\frac{C^\\ast}{1 + k \\Delta t}$, where $D_x$ and $L$ denote the discrete advection and Laplacian operators, respectively.\n- Backward Euler for the fully coupled scheme solves $\\left(I - \\Delta t\\,(-v D_x + D L - k I)\\right) C^{n+1} = C^n$.\n\nDefine the mass-weighted mean and variance of a discrete field $C$ at nodes $x_i$ with spacing $\\Delta x$ by\n$$\nM = \\sum_{i=0}^{N-1} C_i\\,\\Delta x,\\quad \\mu = \\frac{1}{M} \\sum_{i=0}^{N-1} x_i\\, C_i\\,\\Delta x,\\quad \\sigma_\\mathrm{num}^2 = \\frac{1}{M} \\sum_{i=0}^{N-1} (x_i - \\mu)^2\\, C_i\\,\\Delta x.\n$$\n\nTest suite:\nUse the following four parameter sets, each specifying $(L,N,\\sigma_0,M_0,\\Delta t,T,v,D,k)$:\n- Case $1$ (baseline): $(L=\\;10\\ \\mathrm{m},\\, N=\\;200,\\, \\sigma_0=\\;0.20\\ \\mathrm{m},\\, M_0=\\;1.0\\ \\mathrm{mol/m^2},\\, \\Delta t=\\;0.01\\ \\mathrm{s},\\, T=\\;1.00\\ \\mathrm{s},\\, v=\\;0.50\\ \\mathrm{m/s},\\, D=\\;0.010\\ \\mathrm{m^2/s},\\, k=\\;0.10\\ \\mathrm{s^{-1}})$.\n- Case $2$ (high Péclet number, $D=0$): $(L=\\;10\\ \\mathrm{m},\\, N=\\;200,\\, \\sigma_0=\\;0.20\\ \\mathrm{m},\\, M_0=\\;1.0\\ \\mathrm{mol/m^2},\\, \\Delta t=\\;0.01\\ \\mathrm{s},\\, T=\\;1.00\\ \\mathrm{s},\\, v=\\;1.00\\ \\mathrm{m/s},\\, D=\\;0.000\\ \\mathrm{m^2/s},\\, k=\\;0.05\\ \\mathrm{s^{-1}})$.\n- Case $3$ (reverse flow): $(L=\\;10\\ \\mathrm{m},\\, N=\\;200,\\, \\sigma_0=\\;0.20\\ \\mathrm{m},\\, M_0=\\;1.0\\ \\mathrm{mol/m^2},\\, \\Delta t=\\;0.01\\ \\mathrm{s},\\, T=\\;1.00\\ \\mathrm{s},\\, v=\\;-0.50\\ \\mathrm{m/s},\\, D=\\;0.020\\ \\mathrm{m^2/s},\\, k=\\;0.10\\ \\mathrm{s^{-1}})$.\n- Case $4$ (stiff reaction): $(L=\\;10\\ \\mathrm{m},\\, N=\\;200,\\, \\sigma_0=\\;0.20\\ \\mathrm{m},\\, M_0=\\;1.0\\ \\mathrm{mol/m^2},\\, \\Delta t=\\;0.005\\ \\mathrm{s},\\, T=\\;1.00\\ \\mathrm{s},\\, v=\\;0.50\\ \\mathrm{m/s},\\, D=\\;0.010\\ \\mathrm{m^2/s},\\, k=\\;5.00\\ \\mathrm{s^{-1}})$.\n\nYour program must:\n- Implement both schemes on the same mesh and time step for each case.\n- Advance both schemes to time $T$.\n- Compute and return, for each case, the pair $[E_\\mathrm{diff}, E_\\mathrm{split}]$ where $E_\\mathrm{diff}$ is in $\\mathrm{m^2}$ and $E_\\mathrm{split}$ is in $\\mathrm{mol/m^3}$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each case contributes a sub-list of two floats in the order described above, for example, $[[e_{1,d},e_{1,s}],[e_{2,d},e_{2,s}],\\dots]$.",
            "solution": "The user has specified a valid problem in computational geochemistry, requiring the implementation and comparison of two numerical schemes for a one-dimensional reactive transport equation. The problem is scientifically grounded, well-posed, and provides a complete and consistent set of parameters, discretization rules, and evaluation metrics. I will proceed with a detailed solution.\n\n### Principle-Based Design of the Numerical Solution\n\nThe problem involves solving the one-dimensional advection-dispersion-reaction equation (ADRE):\n$$\n\\frac{\\partial C}{\\partial t} + v \\frac{\\partial C}{\\partial x} = D \\frac{\\partial^2 C}{\\partial x^2} - k C\n$$\nThis equation can be written in the form $\\frac{\\partial C}{\\partial t} = \\mathcal{L}(C)$, where $\\mathcal{L}$ is the spatial operator $\\mathcal{L}(C) = -v \\frac{\\partial C}{\\partial x} + D \\frac{\\partial^2 C}{\\partial x^2} - k C$. We will discretize this equation in space using finite differences on a uniform grid with $N$ points $x_i = i \\Delta x$ for $i=0, \\dots, N-1$, where $\\Delta x = L/N$. The concentration field is represented by a vector $\\mathbf{C}(t) = [C_0(t), C_1(t), \\dots, C_{N-1}(t)]^T$.\n\nThe spatial discretization transforms the partial differential equation into a system of ordinary differential equations (ODEs):\n$$\n\\frac{d\\mathbf{C}}{dt} = \\mathbf{A}\\mathbf{C}\n$$\nwhere $\\mathbf{A}$ is an $N \\times N$ matrix representing the discrete spatial operator $\\mathcal{L}$. The matrix $\\mathbf{A}$ is the sum of matrices for each physical process:\n$$\n\\mathbf{A} = -v \\mathbf{D}_x + D \\mathbf{L} - k \\mathbf{I}\n$$\nHere, $\\mathbf{D}_x$ is the matrix for the first-order advection derivative, $\\mathbf{L}$ is the matrix for the second-order Laplacian, and $\\mathbf{I}$ is the identity matrix.\n\n#### Spatial Discretization Matrices\n\nDue to the periodic boundary conditions, the matrices $\\mathbf{D}_x$ and $\\mathbf{L}$ are circulant.\n\n1.  **Advection Operator $\\mathbf{D}_x$**: First-order upwinding is used.\n    - If velocity $v \\ge 0$, the forward difference $(\\frac{\\partial C}{\\partial x})_i \\approx \\frac{C_i - C_{i-1}}{\\Delta x}$ is used. The corresponding matrix $\\mathbf{D}_x$ has $1/\\Delta x$ on its main diagonal, $-1/\\Delta x$ on its sub-diagonal, and a $-1/\\Delta x$ at the top-right corner, $\\mathbf{D}_x[0, N-1]$, due to periodicity.\n    - If velocity $v  0$, the backward difference $(\\frac{\\partial C}{\\partial x})_i \\approx \\frac{C_{i+1} - C_i}{\\Delta x}$ is used. The matrix $\\mathbf{D}_x$ has $-1/\\Delta x$ on its main diagonal, $1/\\Delta x$ on its super-diagonal, and a $1/\\Delta x$ at the bottom-left corner, $\\mathbf{D}_x[N-1, 0]$.\n\n2.  **Dispersion Operator $\\mathbf{L}$**: A second-order central difference is used for the Laplacian, $(\\frac{\\partial^2 C}{\\partial x^2})_i \\approx \\frac{C_{i+1} - 2C_i + C_{i-1}}{\\Delta x^2}$. The matrix $\\mathbf{L}$ has $-2/\\Delta x^2$ on its main diagonal, $1/\\Delta x^2$ on its sub- and super-diagonals, and $1/\\Delta x^2$ at the corners $\\mathbf{L}[0, N-1]$ and $\\mathbf{L}[N-1, 0]$ to enforce periodicity.\n\n#### Time Integration Schemes\n\nThe system of ODEs is advanced in time from $t=0$ to $t=T$ using a constant time step $\\Delta t$. We use the Backward Euler method, which is an implicit scheme. For an ODE system $\\frac{d\\mathbf{C}}{dt} = \\mathbf{A}\\mathbf{C}$, the Backward Euler update from time $t_n$ to $t_{n+1}$ is:\n$$\n\\frac{\\mathbf{C}^{n+1} - \\mathbf{C}^n}{\\Delta t} = \\mathbf{A}\\mathbf{C}^{n+1} \\implies (\\mathbf{I} - \\Delta t \\mathbf{A})\\mathbf{C}^{n+1} = \\mathbf{C}^n\n$$\nAt each time step, this requires solving a linear system of equations.\n\n1.  **Globally Implicit (GI) Scheme**: This scheme treats all physical processes (advection, dispersion, reaction) simultaneously and implicitly. The matrix $\\mathbf{A}$ includes all terms: $\\mathbf{A}_{\\text{GI}} = -v \\mathbf{D}_x + D \\mathbf{L} - k \\mathbf{I}$. The linear system to be solved at each step is:\n    $$\n    (\\mathbf{I} - \\Delta t \\mathbf{A}_{\\text{GI}})\\mathbf{C}^{n+1} = \\mathbf{C}^n\n    $$\n    $$\n    (\\mathbf{I} - \\Delta t(-v \\mathbf{D}_x + D \\mathbf{L} - k \\mathbf{I}))\\mathbf{C}^{n+1} = \\mathbf{C}^n\n    $$\n    The matrix $\\mathbf{M}_{\\text{GI}} = (1+k\\Delta t)\\mathbf{I} + v\\Delta t\\mathbf{D}_x - D\\Delta t\\mathbf{L}$ is constant in time, improving computational efficiency if factorized once.\n\n2.  **Sequential Non-Iterative Approach (SNIA)**: This is an operator splitting scheme. The full evolution is split into a transport step and a reaction step.\n    - **Step 1: Transport**: Solve $\\frac{\\partial C}{\\partial t} = -v \\frac{\\partial C}{\\partial x} + D \\frac{\\partial^2 C}{\\partial x^2}$ for one time step $\\Delta t$. The operator is $\\mathbf{A}_{\\text{T}} = -v\\mathbf{D}_x + D \\mathbf{L}$. Using Backward Euler, we get an intermediate solution $\\mathbf{C}^*$:\n      $$\n      (\\mathbf{I} - \\Delta t \\mathbf{A}_{\\text{T}})\\mathbf{C}^* = \\mathbf{C}^n\n      $$\n      The matrix $\\mathbf{M}_{\\text{SNIA}} = \\mathbf{I} + v\\Delta t\\mathbf{D}_x - D\\Delta t\\mathbf{L}$ is constant.\n    - **Step 2: Reaction**: Solve $\\frac{\\partial C}{\\partial t} = -kC$ for one time step, using $\\mathbf{C}^*$ as the initial condition. The Backward Euler discretization is $\\frac{C_i^{n+1}-C_i^*}{\\Delta t} = -kC_i^{n+1}$. This is a scalar equation for each grid point $i$, which yields an explicit update formula:\n      $$\n      C_i^{n+1} = \\frac{C_i^*}{1+k\\Delta t}\n      $$\n\n#### Initial Condition and Diagnostics\n\n- **Initial Condition**: A Gaussian profile is initialized on the grid at $t=0$:\n  $$\n  C_i(0) = \\frac{M_0}{\\sqrt{2\\pi}\\,\\sigma_0} \\exp\\left(-\\frac{(x_i-x_0)^2}{2\\sigma_0^2}\\right) \\quad \\text{with } x_0=L/2.\n  $$\n\n- **Numerical Diffusion Metric ($E_\\mathrm{diff}$)**: This metric quantifies the artificial diffusion introduced by the numerical scheme. It is the difference between the numerically computed variance of the concentration profile and the analytical variance for the pure advection-dispersion problem. The variance is computed from the Globally Implicit solution at the final time $T$.\n  $$\n  E_\\mathrm{diff} = \\sigma_\\mathrm{num}^2(T) - \\sigma_\\mathrm{phys}^2(T)\n  $$\n  where $\\sigma_\\mathrm{phys}^2(T) = \\sigma_0^2 + 2 D T$. The numerical variance $\\sigma_\\mathrm{num}^2$ is calculated from its definition, using numerical integration (summation over grid points):\n  $$\n  M = \\sum_{i=0}^{N-1} C_i\\,\\Delta x, \\quad \\mu = \\frac{1}{M} \\sum_{i=0}^{N-1} x_i\\, C_i\\,\\Delta x, \\quad \\sigma_\\mathrm{num}^2 = \\frac{1}{M} \\sum_{i=0}^{N-1} (x_i - \\mu)^2\\, C_i\\,\\Delta x\n  $$\n  We follow the problem's explicit formulas for these moments.\n\n- **Splitting Error Metric ($E_\\mathrm{split}$)**: This metric measures the discrepancy between the GI and SNIA solutions, which arises from the operator splitting in SNIA. It is computed as the Root-Mean-Square Difference (RMSD) between the two final concentration profiles.\n  $$\n  E_\\mathrm{split} = \\left(\\frac{1}{L} \\int_0^L \\left(C_\\mathrm{GI}(x,T) - C_\\mathrm{SNIA}(x,T)\\right)^2 \\, dx \\right)^{1/2}\n  $$\n  The integral is approximated by a sum over the grid:\n  $$\n  E_\\mathrm{split} = \\left(\\frac{\\Delta x}{L} \\sum_{i=0}^{N-1} (C_{\\mathrm{GI},i}(T) - C_{\\mathrm{SNIA},i}(T))^2 \\right)^{1/2}\n  $$\n\nThe implementation will proceed by constructing the necessary matrices, setting up the linear systems for the GI and SNIA schemes, iterating through the time steps, and finally computing the specified diagnostics for each test case.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef build_advection_matrix(N, dx, v):\n    \"\"\"Builds the first-order upwind advection matrix with periodic BCs.\"\"\"\n    mat = np.zeros((N, N))\n    if v >= 0:\n        # Standard upwind (forward difference)\n        for i in range(N):\n            mat[i, i] = 1.0 / dx\n            mat[i, (i - 1 + N) % N] = -1.0 / dx\n    else:\n        # Backward difference\n        for i in range(N):\n            mat[i, i] = -1.0 / dx\n            mat[i, (i + 1) % N] = 1.0 / dx\n    return mat\n\ndef build_laplacian_matrix(N, dx):\n    \"\"\"Builds the second-order centered difference Laplacian matrix with periodic BCs.\"\"\"\n    mat = np.zeros((N, N))\n    for i in range(N):\n        mat[i, i] = -2.0 / dx**2\n        mat[i, (i - 1 + N) % N] = 1.0 / dx**2\n        mat[i, (i + 1) % N] = 1.0 / dx**2\n    return mat\n\ndef solve_case(params):\n    \"\"\"\n    Solves the reactive transport problem for a single parameter case.\n    \"\"\"\n    L, N, sigma0, M0, dt, T, v, D, k = params\n    \n    # Grid and initial condition\n    dx = L / N\n    x = np.linspace(0, L - dx, N)\n    x0 = L / 2\n    \n    # The normalization constant is such that the integral over R is M0.\n    # On a finite domain, this is an excellent approximation if sigma0  L.\n    A = M0 / (np.sqrt(2 * np.pi) * sigma0)\n    C0 = A * np.exp(-(x - x0)**2 / (2 * sigma0**2))\n\n    Nt = int(round(T / dt))\n\n    # Build spatial operator matrices\n    D_x = build_advection_matrix(N, dx, v)\n    L_mat = build_laplacian_matrix(N, dx)\n    I = np.identity(N)\n\n    # --- Globally Implicit (GI) Scheme ---\n    A_gi = -v * D_x + D * L_mat - k * I\n    M_gi = I - dt * A_gi\n    \n    C_gi = np.copy(C0)\n    for _ in range(Nt):\n        C_gi = linalg.solve(M_gi, C_gi)\n\n    # --- Sequential Non-Iterative Approach (SNIA) ---\n    A_t = -v * D_x + D * L_mat\n    M_snia_t = I - dt * A_t\n    \n    C_snia = np.copy(C0)\n    for _ in range(Nt):\n        # Transport step\n        C_star = linalg.solve(M_snia_t, C_snia)\n        # Reaction step\n        C_snia = C_star / (1.0 + k * dt)\n    \n    # --- Compute Diagnostics ---\n    # 1. Numerical diffusion metric (E_diff)\n    sigma_phys_sq = sigma0**2 + 2 * D * T\n    \n    # Compute numerical moments from GI solution\n    # Note: total mass changes due to reaction, must use final mass for normalization\n    final_mass_gi = np.sum(C_gi) * dx\n    \n    # Check for mass depletion, if mass is ~0, moments are undefined/unstable\n    if final_mass_gi  1e-15:\n        # If mass is zero, concentration is zero everywhere.\n        # Variance is ill-defined, but practically it's 0.\n        sigma_num_sq = 0.0\n    else:\n        # Standard moment calculation as specified\n        mean_num = (1.0 / final_mass_gi) * np.sum(x * C_gi) * dx\n        # For variance, compute distance from mean for periodic domain\n        # The problem statement gives a simple (x_i - mu)^2, which we must use.\n        sigma_num_sq = (1.0 / final_mass_gi) * np.sum((x - mean_num)**2 * C_gi) * dx\n        \n    E_diff = sigma_num_sq - sigma_phys_sq\n    \n    # 2. Splitting error metric (E_split)\n    mse = np.sum((C_gi - C_snia)**2)\n    E_split = np.sqrt(mse * dx / L)\n\n    return [E_diff, E_split]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n    \n    # (L, N, sigma0, M0, dt, T, v, D, k)\n    test_cases = [\n        # Case 1 (baseline)\n        (10.0, 200, 0.20, 1.0, 0.01, 1.00, 0.50, 0.010, 0.10),\n        # Case 2 (high Péclet number, D=0)\n        (10.0, 200, 0.20, 1.0, 0.01, 1.00, 1.00, 0.000, 0.05),\n        # Case 3 (reverse flow)\n        (10.0, 200, 0.20, 1.0, 0.01, 1.00, -0.50, 0.020, 0.10),\n        # Case 4 (stiff reaction)\n        (10.0, 200, 0.20, 1.0, 0.005, 1.00, 0.50, 0.010, 5.00),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        results = solve_case(case)\n        all_results.append(f\"[{results[0]},{results[1]}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}