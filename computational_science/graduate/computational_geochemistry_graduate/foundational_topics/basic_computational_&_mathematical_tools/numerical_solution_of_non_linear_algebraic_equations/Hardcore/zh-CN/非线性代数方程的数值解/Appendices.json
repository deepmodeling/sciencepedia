{
    "hands_on_practices": [
        {
            "introduction": "计算地球化学中的许多基本问题，例如计算水溶液的pH值，都可以归结为求解单个非线性代数方程。这个练习将指导你从第一性原理（电中性、质量作用和质量平衡）出发，构建一个描述碳酸盐体系的电中性方程。通过实现二分法这一稳健的根区间法，你将能够实践如何将基本的化学原理与可靠的数值算法相结合，并确保解的收敛性。",
            "id": "4094375",
            "problem": "考虑一个温度为 $25\\,^{\\circ}\\mathrm{C}$ 的水溶液，其中包含弱酸碱体系和强电解质。目标是数值求解一个以酸度 $\\mathrm{pH}$ 表示的非线性代数方程形式的电中性条件。基本出发点是电中性原理，即在平衡状态下，正电荷总和等于负电荷总和，以及酸碱体系的平衡质量作用关系和总质量平衡约束。假设为理想溶液行为，因此化学活度可以用摩尔浓度来近似。\n\n设弱酸体系为无机碳体系 $\\mathrm{H_{2}CO_{3}^{*}}/\\mathrm{HCO_{3}^{-}}/\\mathrm{CO_{3}^{2-}}$，其一级和二级酸解离常数分别表示为 $K_{1}$ 和 $K_{2}$。设水的自电离由离子积 $K_{w}$ 表征。所有常数均在 $25\\,^{\\circ}\\mathrm{C}$ 下：\n- $K_{1} = 10^{-6.3}$，\n- $K_{2} = 10^{-10.3}$，\n- $K_{w} = 10^{-14}$。\n\n定义溶解无机碳 (DIC) 的总浓度为 $C_{\\mathrm{T}}$ (单位 $\\mathrm{mol/L}$)，强电解质离子钠和氯的总浓度分别为 $C_{\\mathrm{Na}}$ 和 $C_{\\mathrm{Cl}}$ (单位 $\\mathrm{mol/L}$)。将钠和氯视为完全解离。\n\n对于给定的 $\\mathrm{pH}$，记 $H = [\\mathrm{H^{+}}] = 10^{-\\mathrm{pH}}$ 和 $[\\mathrm{OH^{-}}] = K_{w}/H$。利用碳酸盐体系的质量作用和守恒定律，物种浓度 $[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$ 是 $H$、$K_{1}$、$K_{2}$ 和 $C_{\\mathrm{T}}$ 的函数，可从解离平衡和总 $C_{\\mathrm{T}}$ 约束中获得。构建电中性函数 $f(\\mathrm{pH})$，其定义为正电荷总和与负电荷总和之差，\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + C_{\\mathrm{Na}} \\right) - \\left( [\\mathrm{OH^{-}}] + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right),\n$$\n通过 $H=10^{-\\mathrm{pH}}$ 和碳酸盐形态函数，将其完全表示为 $\\mathrm{pH}$ 的函数。\n\n任务：\n1. 从上述基本原理（电中性、质量作用和质量平衡）出发，数学推导如何将 $[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$ 表示为 $H$、$K_{1}$、$K_{2}$ 和 $C_{\\mathrm{T}}$ 的函数，且不引入任何无法从这些原理推导出的简化公式。\n2. 使用这些表达式，构建一个二分法算法，在闭区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ 上求解 $f(\\mathrm{pH}) = 0$。假设函数 $f$ 在该区间上连续且在端点处变号。明确论证 $f(\\mathrm{pH})$ 的连续性，并解释为什么符号变化 $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$ 意味着区间内存在一个根。\n3. 实现二分法，为下面的每个测试案例找到 $\\mathrm{pH}$。使用 $10^{-8}$ 的容差，可应用于区间宽度或 $|f(\\mathrm{pH})|$，具体执行哪种标准由您选择。所有浓度必须以 $\\mathrm{mol/L}$ 为单位处理，最终的 $\\mathrm{pH}$ 是无量纲的。解决方案不得依赖任何外部输入，并且必须是数值稳定的。\n\n测试套件（每个条目为 $(C_{\\mathrm{T}}, C_{\\mathrm{Na}}, C_{\\mathrm{Cl}}, \\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$）：\n- 案例 A (一般淡水碳酸盐体系)：$(2.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 4,\\; 10)$。\n- 案例 B (富含氯离子的酸性体系)：$(1.0 \\times 10^{-4},\\; 0.0,\\; 1.0 \\times 10^{-3},\\; 0,\\; 7)$。\n- 案例 C (富含钠离子的碱性体系)：$(1.0 \\times 10^{-3},\\; 5.0 \\times 10^{-4},\\; 0.0,\\; 4,\\; 14)$。\n\n最终输出格式：\n您的程序应生成单行输出，包含案例 A、B 和 C 的三个计算出的 $\\mathrm{pH}$ 值，格式为用方括号括起来的逗号分隔列表，每个 $\\mathrm{pH}$ 值四舍五入到六位小数，例如 $[\\mathrm{pH}_{A},\\mathrm{pH}_{B},\\mathrm{pH}_{C}]$。",
            "solution": "该问题要求通过数值求解电中性方程，找到含有无机碳体系和强电解质的水溶液的平衡 $\\mathrm{pH}$。这是计算地球化学中的一个基本问题。解决方案按要求包括三个主要部分：从第一性原理推导控制方程，构建数值算法，以及实现该解决方案。\n\n### 第一部分：碳酸盐物种浓度的推导\n\n水中碳酸盐体系的形态分布受化学平衡和质量平衡约束的控制。我们首先陈述这些基本关系。所有浓度单位均为 $\\mathrm{mol/L}$。\n\n设 $H = [\\mathrm{H^{+}}]$。碳酸盐体系的解离反应如下：\n1.  $$\\mathrm{H_{2}CO_{3}^{*}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{HCO_{3}^{-}}$$\n2.  $$\\mathrm{HCO_{3}^{-}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{CO_{3}^{2-}}$$\n\n假设为理想溶液行为，根据质量作用定律可得平衡常数表达式：\n$$\nK_{1} = \\frac{[\\mathrm{H^{+}}][\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]} = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]}\n$$\n$$\nK_{2} = \\frac{[\\mathrm{H^{+}}][\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]} = \\frac{H \\cdot [\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]}\n$$\n\n溶解无机碳的总浓度 $C_{\\mathrm{T}}$ 由质量平衡方程给出：\n$$\nC_{\\mathrm{T}} = [\\mathrm{H_{2}CO_{3}^{*}}] + [\\mathrm{HCO_{3}^{-}}] + [\\mathrm{CO_{3}^{2-}}]\n$$\n\n我们的目标是将每种碳酸盐物种的浓度（$[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$）表示为已知量 $H$、$C_{\\mathrm{T}}$、$K_{1}$ 和 $K_{2}$ 的函数。\n\n从平衡表达式中，我们可以将 $[\\mathrm{H_{2}CO_{3}^{*}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$ 用 $[\\mathrm{HCO_{3}^{-}}]$ 和 $H$ 表示：\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}}\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H}\n$$\n\n接下来，我们将这些表达式代入 $C_{\\mathrm{T}}$ 的质量平衡方程：\n$$\nC_{\\mathrm{T}} = \\left( \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}} \\right) + [\\mathrm{HCO_{3}^{-}}] + \\left( \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H} \\right)\n$$\n\n我们提取公因式 $[\\mathrm{HCO_{3}^{-}}]$：\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H}{K_{1}} + 1 + \\frac{K_{2}}{H} \\right)\n$$\n\n为了简化括号中的项，我们通分，公分母为 $K_{1}H$：\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H^2 + K_{1}H + K_{1}K_{2}}{K_{1}H} \\right)\n$$\n\n现在，我们可以解出 $[\\mathrm{HCO_{3}^{-}}]$：\n$$\n[\\mathrm{HCO_{3}^{-}}] = C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n\n有了 $[\\mathrm{HCO_{3}^{-}}]$ 的表达式，我们可以通过回代法求出另外两种物种的表达式：\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H}{K_{1}} [\\mathrm{HCO_{3}^{-}}] = \\frac{H}{K_{1}} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{H^2}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2}}{H} [\\mathrm{HCO_{3}^{-}}] = \\frac{K_{2}}{H} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n这些就是所求的碳酸盐物种浓度表达式。\n\n### 第二部分：二分法算法的构建\n\n问题的核心是求解电中性方程 $f(\\mathrm{pH}) = 0$。函数 $f(\\mathrm{pH})$ 代表溶液中的净电荷，定义为所有正电荷之和减去所有负电荷之和。\n\n阳离子（正离子）是 $\\mathrm{H^{+}}$ 和 $\\mathrm{Na^{+}}$。阴离子（负离子）是 $\\mathrm{OH^{-}}$、$\\mathrm{Cl^{-}}$、$\\mathrm{HCO_{3}^{-}}$ 和 $\\mathrm{CO_{3}^{2-}}$。碳酸根离子 $\\mathrm{CO_{3}^{2-}}$ 的电荷为 $-2$，因此在电荷平衡中其浓度乘以 $2$。\n$$\nf(\\mathrm{pH}) = \\sum (\\mathrm{positive\\;charges}) - \\sum (\\mathrm{negative\\;charges})\n$$\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + [\\mathrm{Na^{+}}] \\right) - \\left( [\\mathrm{OH^{-}}] + [\\mathrm{Cl^{-}}] + [\\mathrm{HCO_{3}^{-}}] + 2 \\cdot [\\mathrm{CO_{3}^{2-}}] \\right)\n$$\n考虑到 $\\mathrm{Na^{+}}$ 和 $\\mathrm{Cl^{-}}$ 来自强电解质，它们的浓度分别为 $C_{\\mathrm{Na}}$ 和 $C_{\\mathrm{Cl}}$。我们使用第一部分中的表达式以及水的自电离关系式 $[\\mathrm{OH^{-}}] = K_{w}/H$，其中 $H = 10^{-\\mathrm{pH}}$。\n$$\nf(\\mathrm{pH}) = \\left( H + C_{\\mathrm{Na}} \\right) - \\left( \\frac{K_{w}}{H} + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right)\n$$\n代入推导出的物种浓度：\n$$\n[\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] = C_{\\mathrm{T}} \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} + 2 \\cdot C_{\\mathrm{T}} \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} = C_{\\mathrm{T}} \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}}\n$$\n因此，需要求解的最终函数是：\n$$\nf(\\mathrm{pH}) = H + C_{\\mathrm{Na}} - \\frac{K_{w}}{H} - C_{\\mathrm{Cl}} - C_{\\mathrm{T}} \\left( \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n其中 $H=10^{-\\mathrm{pH}}$。\n\n二分法是一种适用于连续函数的迭代求根算法。在此处使用它的理由基于 $f(\\mathrm{pH})$ 的两个属性：连续性和在给定区间内存在根。\n\n**$f(\\mathrm{pH})$ 的连续性**：\n函数 $f(\\mathrm{pH})$ 是几个更简单的 $\\mathrm{pH}$ 函数的复合和代数和：\n1.  $H(\\mathrm{pH}) = 10^{-\\mathrm{pH}}$ 对所有实数 $\\mathrm{pH}$ 都是连续的。\n2.  项 $K_{w}/H$ 对所有 $H>0$ (即对任何有限的 $\\mathrm{pH}$) 都是连续的。\n3.  碳酸盐形态项是关于 $H$ 的有理函数。它们的分母是 $D(H) = H^2 + K_{1}H + K_{1}K_{2}$。由于所有参数（$H$、$K_{1}$、$K_{2}$）对于任何物理溶液都是严格为正的，分母 $D(H)$ 始终为正且不为零。因此，碳酸盐项是关于 $H$ 的连续函数。\n由于 $f(\\mathrm{pH})$ 是由这些连续函数的和、差及复合构成的，因此它本身在任何区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ (其中 $0 \\le \\mathrm{pH}_{\\min}  \\mathrm{pH}_{\\max}  \\infty$) 上都是一个关于 $\\mathrm{pH}$ 的连续函数。\n\n**根的存在性**：\n二分法依赖于**介值定理 (IVT)**。介值定理指出，如果函数 $g(x)$ 在闭区间 $[a, b]$ 上连续，那么对于介于 $g(a)$ 和 $g(b)$ 之间的任何值 $N$，必定在 $[a, b]$ 中存在至少一个点 $c$，使得 $g(c) = N$。\n在我们的问题中，指定了一个搜索区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ 并假设存在符号变化，即 $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$。这意味着 $f(\\mathrm{pH}_{\\min})$ 和 $f(\\mathrm{pH}_{\\max})$ 中一个为正，另一个为负。因此，值 $N=0$ 位于 $f(\\mathrm{pH}_{\\min})$ 和 $f(\\mathrm{pH}_{\\max})$ 之间。由于 $f(\\mathrm{pH})$ 在此区间上是连续的，介值定理保证了在 $(\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$ 内至少存在一个根 $\\mathrm{pH}_{\\text{root}}$，使得 $f(\\mathrm{pH}_{\\text{root}}) = 0$。\n\n**二分法算法**：\n设搜索区间为 $[a, b]$，初始化为 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$。我们要求 $f(a)$ 和 $f(b)$ 符号相反。算法流程如下：\n1.  设置一个容差 $\\epsilon$ (例如 $10^{-8}$)。\n2.  当区间宽度 $(b-a)$ 大于 $\\epsilon$ 时，重复以下步骤：\n    a. 计算区间的中点：$m = a + (b-a)/2$。\n    b. 计算中点处的函数值 $f(m)$。\n    c. 如果 $f(a)$ 和 $f(m)$ 符号相反（即 $f(a) \\cdot f(m)  0$），则根必在区间 $[a, m]$ 内。通过设置 $b = m$ 来更新区间。\n    d. 否则，根必在 $[m, b]$ 内（即 $f(m) \\cdot f(b) \\le 0$）。通过设置 $a = m$ 来更新区间。\n3.  循环终止后，区间 $[a, b]$ 的宽度小于容差 $\\epsilon$。根可以近似为这个最终区间的中点 $(a+b)/2$。\n\n该算法保证收敛到一个根，每次迭代都会将不确定性区间减半。\n\n### 第三部分：实现\n\n二分法算法使用 Python 实现。一个函数用于计算给定参数集下电中性函数 $f(\\mathrm{pH})$ 的值。第二个函数实现二分法搜索。此过程应用于三个测试案例中的每一个。常数定义为 $K_{1} = 10^{-6.3}$、$K_{2} = 10^{-10.3}$ 和 $K_{w} = 10^{-14}$。使用基于区间宽度小于 $10^{-8}$ 容差的停止准则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the pH of an aqueous carbonate system using the bisection method.\n    The function sets up the problem parameters for three test cases and computes\n    the equilibrium pH for each by finding the root of the electroneutrality equation.\n    \"\"\"\n\n    # Define constants at 25 degrees Celsius\n    K1 = 10**(-6.3)\n    K2 = 10**(-10.3)\n    KW = 10**(-14.0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple: (C_T, C_Na, C_Cl, pH_min, pH_max)\n    test_cases = [\n        # Case A: General freshwater carbonate system\n        (2.0e-3, 1.0e-3, 1.0e-3, 4.0, 10.0),\n        # Case B: Acidic chloride-rich system\n        (1.0e-4, 0.0, 1.0e-3, 0.0, 7.0),\n        # Case C: Basic sodium-rich system\n        (1.0e-3, 5.0e-4, 0.0, 4.0, 14.0),\n    ]\n\n    def electroneutrality_func(ph, C_T, C_Na, C_Cl):\n        \"\"\"\n        Calculates the value of the electroneutrality function f(pH).\n\n        f(pH) = (sum of positive charges) - (sum of negative charges)\n        \"\"\"\n        H = 10**(-ph)\n        OH = KW / H\n\n        # Carbonate speciation term: [HCO3-] + 2*[CO3^2-]\n        # Denominator of the speciation fractions\n        denominator = H**2 + K1 * H + K1 * K2\n        \n        # Avoid division by zero, though for H>0 denominator is always  0\n        if denominator == 0:\n            # This case is physically impossible for H  0\n            return np.inf\n\n        # [HCO3-] + 2*[CO3^2-] = C_T * (K1*H / denom) + 2 * C_T * (K1*K2 / denom)\n        carbonate_charge_term = C_T * (K1 * H + 2 * K1 * K2) / denominator\n        \n        # Calculate net charge (the function f(pH) we want to find the root of)\n        # f(pH) = [H+] + [Na+] - ([OH-] + [Cl-] + [HCO3-] + 2*[CO3^2-])\n        net_charge = (H + C_Na) - (OH + C_Cl + carbonate_charge_term)\n\n        return net_charge\n\n    def bisection_solver(params, tol=1.0e-8, max_iter=100):\n        \"\"\"\n        Finds the root of the electroneutrality function using the bisection method.\n        \"\"\"\n        C_T, C_Na, C_Cl, ph_min, ph_max = params\n        \n        a = ph_min\n        b = ph_max\n        \n        f_a = electroneutrality_func(a, C_T, C_Na, C_Cl)\n        f_b = electroneutrality_func(b, C_T, C_Na, C_Cl)\n\n        # Check if a root is guaranteed to be in the interval\n        if f_a * f_b >= 0:\n            # This case should not occur with the problem's given brackets\n            # but is good practice to check.\n            if abs(f_a)  tol: return a\n            if abs(f_b)  tol: return b\n            raise ValueError(\"Bisection method fails: f(a) and f(b) must have opposite signs.\")\n            \n        for _ in range(max_iter):\n            mid = a + (b - a) / 2\n            f_mid = electroneutrality_func(mid, C_T, C_Na, C_Cl)\n\n            if abs(f_mid)  tol or (b - a) / 2  tol:\n                return mid\n            \n            # Update the interval\n            if f_a * f_mid  0:\n                b = mid\n            else:\n                a = mid\n                f_a = f_mid # Update f_a to f_mid\n\n        return (a + b) / 2\n\n    results = []\n    for case in test_cases:\n        ph_solution = bisection_solver(case)\n        results.append(f\"{ph_solution:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当化学体系从单一反应扩展到包含多种组分和络合物时，问题就从单个方程演变为一个大型非线性方程组 $F(x)=0$。对于这类问题，基于牛顿法的高效求解器依赖于对雅可比矩阵 $J$ 结构特征的利用。这个练习的核心任务是学习如何根据体系的化学计量关系，自动地推导出雅可比矩阵的稀疏模式，这是构建可扩展的地球化学模拟软件的一项基本技能。",
            "id": "4094338",
            "problem": "考虑一个用于计算地球化学中化学形态平衡的非线性代数系统，该系统由独立组分和络合物构成。假设有 $n_c$ 个独立组分和 $n_x$ 个络合物，总物种数为 $n_s = n_c + n_x$。定义化学计量矩阵 $S \\in \\mathbb{R}^{n_c \\times n_x}$，其条目 $S_{i j} \\ge 0$ 是络合物 $j$ 中组分 $i$ 的化学计量系数。为所有物种定义整数电荷向量 $z \\in \\mathbb{Z}^{n_s}$，物种排序为先独立组分后络合物。未知量是排列为 $\\{m_k\\}_{k=1}^{n_s}$ 的物种重量摩尔浓度，在数值求解中我们使用其自然对数 $\\{\\ln m_k\\}_{k=1}^{n_s}$。\n\n根据化学平衡和守恒的基本定律：\n- 络合物 $j$ 的质量作用定律表明 $m_j \\propto \\prod_{i=1}^{n_c} m_i^{S_{i j}}$，其对数形式产生以下类型的残差 $R_j^{\\mathrm{ma}} = \\ln m_j - \\sum_{i=1}^{n_c} S_{i j} \\ln m_i - \\ln K_j$，其中 $K_j$ 是络合物 $j$ 的平衡常数。\n- 组分 $i$ 的质量平衡强制要求 $R_i^{\\mathrm{mb}} = m_i + \\sum_{j=1}^{n_x} S_{i j} m_j - T_i$，其中 $T_i$ 是组分 $i$ 的总浓度。\n- 当存在电中性约束时，它强制要求 $R^{\\mathrm{en}} = \\sum_{k=1}^{n_s} z_k m_k = 0$。\n\n我们只关心雅可比稀疏模式，这是一个二元结构，用于指示哪些偏导数 $\\partial R / \\partial x$ 在结构上非零，而不关心它们的数值。为此，只需确定一个残差是否依赖于某个变量即可。我们按如下方式对行（残差）和列（变量）施加一个规范排序：\n- 行：首先是 $n_x$ 个络合物质量作用残差 $\\{R_j^{\\mathrm{ma}}\\}_{j=1}^{n_x}$，然后是 $n_c$ 个组分质量平衡残差 $\\{R_i^{\\mathrm{mb}}\\}_{i=1}^{n_c}$，如果存在，最后是单个电中性残差 $R^{\\mathrm{en}}$。因此，残差的数量为 $m = n_x + n_c + \\delta_{\\mathrm{en}}$，其中 $\\delta_{\\mathrm{en}} \\in \\{0,1\\}$ 表示是否包含 $R^{\\mathrm{en}}$。\n- 列：首先是 $n_c$ 个独立组分变量 $\\{\\ln m_i\\}_{i=1}^{n_c}$，然后是 $n_x$ 个络合物变量 $\\{\\ln m_j\\}_{j=1}^{n_x}$，映射到列 $n_c + j$。\n\n仅使用化学计量矩阵 $S$ 和电荷向量 $z$，根据从上述基本方程派生的以下结构依赖关系规则，构造雅可比稀疏模式 $P \\in \\{0,1\\}^{m \\times n_s}$：\n- 对于每个络合物质量作用残差 $R_j^{\\mathrm{ma}}$，非零条目位于其自身的络合物变量列，以及满足 $S_{i j} \\neq 0$ 的独立组分变量列 $i$。\n- 对于每个组分质量平衡残差 $R_i^{\\mathrm{mb}}$，非零条目位于其自身的组分变量列 $i$，以及满足 $S_{i j} \\neq 0$ 的络合物变量列 $n_c + j$。\n- 对于电中性残差 $R^{\\mathrm{en}}$，非零条目位于所有满足 $z_k \\neq 0$ 的物种变量列 $k$。\n\n识别并报告非零条目的索引对，这些索引对被分组为对应于独立组分、络合物和约束的块结构。使用以下块定义以及上述指定的行和列索引约定：\n- 块 $A$：络合物质量作用残差 vs. 独立组分变量，即，当 $S_{i j} \\neq 0$ 且 $j \\in \\{0,\\dots,n_x-1\\}$, $i \\in \\{0,\\dots,n_c-1\\}$ 时的索引对 $(\\text{行 } j, \\text{列 } i)$。\n- 块 $B$：络合物质量作用残差 vs. 络合物变量（此子块中的对角线），即，对于 $j \\in \\{0,\\dots,n_x-1\\}$ 的索引对 $(\\text{行 } j, \\text{列 } n_c + j)$。\n- 块 $C$：组分质量平衡残差 vs. 独立组分变量（此子块中的对角线），即，对于 $i \\in \\{0,\\dots,n_c-1\\}$ 的索引对 $(\\text{行 } n_x + i, \\text{列 } i)$。\n- 块 $D$：组分质量平衡残差 vs. 络合物变量，即，当 $S_{i j} \\neq 0$ 时的索引对 $(\\text{行 } n_x + i, \\text{列 } n_c + j)$。\n- 块 $E$：电中性残差 vs. 所有带非零电荷的物种变量，即，在包含电中性残差的情况下，当 $z_k \\neq 0$ 时的索引对 $(\\text{行 } n_x + n_c, \\text{列 } k)$。\n\n您的任务是实现一个程序，为每个测试用例构建这些块，并为该测试用例输出以下列表：\n$[m, n_s, A, B, C, D, E]$，\n其中 $m$ 和 $n_s$ 是整数，每个块是一个由整数索引对 $[r, c]$ 组成的列表。如果测试用例中不包含电中性残差，则为 $E$ 输出一个空列表。\n\n测试套件：\n- 情况1（正常路径，多个组分和络合物，带电荷）：\n$n_c = 3$， $n_x = 2$，组分排序为 $(\\mathrm{H}^+, \\mathrm{Na}^+, \\mathrm{Cl}^-)$，络合物排序为 $(\\mathrm{HCl}, \\mathrm{NaCl})$。\n$$\nS = \\begin{bmatrix}\n1  0 \\\\\n0  1 \\\\\n1  1\n\\end{bmatrix}, \\quad\nz = \\begin{bmatrix}\n1 \\\\ 1 \\\\ -1 \\\\ 0 \\\\ 0\n\\end{bmatrix}, \\quad \\text{包含电中性约束}。\n$$\n- 情况2（边界情况，一个络合物，带电荷）：\n$n_c = 2$， $n_x = 1$，组分排序为 $(\\mathrm{Ca}^{2+}, \\mathrm{CO}_3^{2-})$，络合物为 $(\\mathrm{CaCO}_3)$。\n$$\nS = \\begin{bmatrix}\n1 \\\\\n1\n\\end{bmatrix}, \\quad\nz = \\begin{bmatrix}\n2 \\\\ -2 \\\\ 0\n\\end{bmatrix}, \\quad \\text{包含电中性约束}。\n$$\n- 情况3（边界情况，无络合物，带电荷）：\n$n_c = 2$, $n_x = 0$，组分排序为 $(\\mathrm{H}^+, \\mathrm{OH}^-)$，无络合物。\n$$\nS = \\begin{bmatrix}\n\\ \\\\\n\\ \n\\end{bmatrix} \\text{ 形状为 } (2,0), \\quad\nz = \\begin{bmatrix}\n1 \\\\ -1\n\\end{bmatrix}, \\quad \\text{包含电中性约束}。\n$$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素按上面列出的顺序对应一个测试用例。每个测试用例的结果必须是一个具有 $[m, n_s, A, B, C, D, E]$ 结构的列表。例如，打印时它应看起来像 $[[\\cdots],[\\cdots],[\\cdots]]$，其中所有条目都是整数、布尔值、浮点数或这些类型的列表。",
            "solution": "所陈述的问题是有效的。它在科学上基于化学平衡原理，在数学上是适定的，并且表述客观。它要求为计算地球化学中常见的非线性代数方程组构建雅可比稀疏模式。这是一项基于从基本化学定律派生的一套清晰规则的确定性任务。\n\n我们将构建指定的索引块（$A, B, C, D, E$），它们共同定义了雅可比矩阵的稀疏模式。解决方案通过将所提供的依赖规则系统地转化为算法来进行。\n\n**系统定义**\n\n该问题涉及一个处于平衡状态的化学系统，包含 $n_c$ 个独立组分和 $n_x$ 个络合物，总共 $n_s = n_c + n_x$ 个物种。系统状态由物种重量摩尔浓度向量 $\\{m_k\\}_{k=1}^{n_s}$ 描述。为保证数值稳定性，求解器对重量摩尔浓度的自然对数 $\\{\\ln m_k\\}_{k=1}^{n_s}$ 进行操作。\n\n该系统由一组非线性代数方程控制，表示为在平衡时必须为零的残差：\n1.  **质量作用定律（对于 $n_x$ 个络合物）：** 对于每个络合物 $j$，质量作用定律定义了一个平衡关系。其对数形式给出了一个残差 $R_j^{\\mathrm{ma}}$：\n    $$R_j^{\\mathrm{ma}} = \\ln m_{n_c+j} - \\sum_{i=1}^{n_c} S_{i j} \\ln m_i - \\ln K_j = 0$$\n    这里，$S_{ij}$（来自化学计量矩阵 $S \\in \\mathbb{R}^{n_c \\times n_x}$）是每单位络合物 $j$ 中组分 $i$ 的单位数，$K_j$ 是平衡常数，我们使用的约定是物种索引 $k=1, \\dots, n_c$ 对应于组分，$k=n_c+1, \\dots, n_s$ 对应于络合物。\n\n2.  **质量平衡（对于 $n_c$ 个组分）：** 对于每个组分 $i$，总浓度 $T_i$ 必须守恒。这给出了一个残差 $R_i^{\\mathrm{mb}}$：\n    $$R_i^{\\mathrm{mb}} = m_i + \\sum_{j=1}^{n_x} S_{i j} m_{n_c+j} - T_i = 0$$\n\n3.  **电中性（可选）：** 溶液的总电荷必须为零。这给出了单个残差 $R^{\\mathrm{en}}$：\n    $$R^{\\mathrm{en}} = \\sum_{k=1}^{n_s} z_k m_k = 0$$\n    其中 $z_k$ 是物种 $k$ 的整数电荷。\n\n**雅可比稀疏模式**\n\n雅可比矩阵 $J$ 包含每个残差对每个变量的偏导数，$J_{pq} = \\partial R_p / \\partial x_q$，其中 $R_p$ 是残差，$x_q = \\ln m_q$ 是变量。稀疏模式是一个二元矩阵，指示这些导数中哪些在结构上非零。行（残差）和列（变量）的排序规定如下：\n-   **行（索引 $r$）：** $n_x$ 个残差 $\\{R_j^{\\mathrm{ma}}\\}$，后跟 $n_c$ 个残差 $\\{R_i^{\\mathrm{mb}}\\}$，以及一个可选的 $R^{\\mathrm{en}}$。总行数 $m = n_x + n_c + \\delta_{\\mathrm{en}}$。\n-   **列（索引 $c$）：** $n_c$ 个变量 $\\{\\ln m_i\\}$，后跟 $n_x$ 个变量 $\\{\\ln m_j\\}$。总列数 $n_s$。\n\n结构依赖关系如下：\n-   $\\partial R_j^{\\mathrm{ma}} / \\partial (\\ln m_k)$: 此残差在对数摩尔浓度上是线性的。对于其自身的络合物变量 $\\ln m_{n_c+j}$ 和满足 $S_{ij} \\neq 0$ 的组分变量 $\\ln m_i$，导数非零。\n-   $\\partial R_i^{\\mathrm{mb}} / \\partial (\\ln m_k)$: 此残差是摩尔浓度 $m_k$ 的函数。使用链式法则，$\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_k) = (\\partial R_i^{\\mathrm{mb}}/\\partial m_k) \\cdot (\\partial m_k/\\partial \\ln m_k) = (\\partial R_i^{\\mathrm{mb}}/\\partial m_k) \\cdot m_k$。由于 $m_k  0$，当且仅当 $R_i^{\\mathrm{mb}}$ 依赖于 $m_k$ 时，该导数在结构上非零。这种情况发生在其自身的组分 $m_i$ 和组分 $i$ 是其构成部分（$S_{ij} \\neq 0$）的络合物 $m_{n_c+j}$ 上。\n-   $\\partial R^{\\mathrm{en}} / \\partial (\\ln m_k)$: 类似地，对于任何具有非零电荷 $z_k \\neq 0$ 的物种 $k$，此导数在结构上非零。\n\n**稀疏块的算法构建**\n\n我们实现一个算法，它以化学计量矩阵 $S$、电荷向量 $z$ 和电中性标志 $\\delta_{\\mathrm{en}}$ 作为输入。在实现中，所有索引都是从0开始的。维度为 $n_c = \\text{S.shape}[0]$，$n_x = \\text{S.shape}[1]$，$n_s = n_c + n_x$，以及 $m = n_x + n_c + \\delta_{\\mathrm{en}}$。\n\n1.  **块 $A$ (质量作用 vs. 组分):** 这些条目对应于 $\\partial R_j^{\\mathrm{ma}} / \\partial(\\ln m_i)$。非零对为 $(r, c) = (j, i)$，其中 $j \\in \\{0, \\dots, n_x-1\\}$ 且 $i \\in \\{0, \\dots, n_c-1\\}$，并且 $S_{ij} \\neq 0$。我们遍历所有 $(i, j)$，如果 $S_{ij} \\neq 0$，我们将坐标对 $[j, i]$ 添加到列表 $A$ 中。\n\n2.  **块 $B$ (质量作用 vs. 络合物):** 这些条目对应于 $\\partial R_j^{\\mathrm{ma}} / \\partial(\\ln m_{n_c+j})$。非零对为 $(r, c) = (j, n_c+j)$，其中 $j \\in \\{0, \\dots, n_x-1\\}$。这形成一个对角线结构。我们从 $0$ 迭代到 $n_x-1$，并将 $[j, n_c+j]$ 添加到列表 $B$ 中。\n\n3.  **块 $C$ (质量平衡 vs. 组分):** 这些条目对应于 $\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_i)$。非零对为 $(r, c) = (n_x+i, i)$，其中 $i \\in \\{0, \\dots, n_c-1\\}$。这也形成一个对角线结构。我们从 $0$ 迭代到 $n_c-1$，并将 $[n_x+i, i]$ 添加到列表 $C$ 中。\n\n4.  **块 $D$ (质量平衡 vs. 络合物):** 这些条目对应于 $\\partial R_i^{\\mathrm{mb}} / \\partial(\\ln m_{n_c+j})$。非零对为 $(r, c) = (n_x+i, n_c+j)$，其中 $i \\in \\{0, \\dots, n_c-1\\}$ 且 $j \\in \\{0, \\dots, n_x-1\\}$，并且 $S_{ij} \\neq 0$。这个块结构实际上是 $S$ 的转置。我们遍历所有 $(i, j)$，如果 $S_{ij} \\neq 0$，我们将 $[n_x+i, n_c+j]$ 添加到列表 $D$ 中。\n\n5.  **块 $E$ (电中性 vs. 所有物种):** 如果包含电中性约束（$\\delta_{\\mathrm{en}}=1$），这些条目对应于 $\\partial R^{\\mathrm{en}} / \\partial(\\ln m_k)$。行索引固定为 $r = n_x+n_c$。非零对为 $(r, c) = (n_x+n_c, k)$，适用于所有满足 $z_k \\neq 0$ 的物种 $k \\in \\{0, \\dots, n_s-1\\}$。我们从 $0$ 迭代到 $n_s-1$，如果 $z_k \\neq 0$，则将 $[n_x+n_c, k]$ 添加到列表 $E$ 中。如果 $\\delta_{\\mathrm{en}}=0$，$E$ 是一个空列表。\n\n每个测试用例的最终输出是一个列表，包含计算出的维度和五个块列表：$[m, n_s, A, B, C, D, E]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the result.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: happy path, multiple components and complexes, with charges\n        {\n            \"S\": np.array([[1, 0], [0, 1], [1, 1]]),\n            \"z\": np.array([1, 1, -1, 0, 0]),\n            \"include_en\": True\n        },\n        # Case 2: edge case, one complex, with charges\n        {\n            \"S\": np.array([[1], [1]]),\n            \"z\": np.array([2, -2, 0]),\n            \"include_en\": True\n        },\n        # Case 3: boundary case, no complexes, with charges\n        {\n            \"S\": np.array([[], []]).reshape(2, 0),\n            \"z\": np.array([1, -1]),\n            \"include_en\": True\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        S = case[\"S\"]\n        z = case[\"z\"]\n        include_en = case[\"include_en\"]\n\n        # Determine dimensions based on the shapes of S and z\n        if S.ndim == 1:\n            S = S.reshape(-1, 1) # Handle 1D array for single complex\n        \n        n_c = S.shape[0]  # Number of components\n        n_x = S.shape[1]  # Number of complexes\n        n_s = n_c + n_x   # Total number of species\n        delta_en = 1 if include_en else 0\n        m = n_x + n_c + delta_en # Total number of residuals/rows\n\n        # Initialize lists for each block of non-zero indices\n        A, B, C, D, E = [], [], [], [], []\n\n        # Find non-zero indices in S for blocks A and D\n        # S_ij is coeff of component i in complex j\n        # In numpy, S[i,j]\n        component_indices, complex_indices = np.nonzero(S)\n\n        # Block A: mass action residuals vs. independent component variables\n        # (row j, col i) for S_ij != 0\n        A = sorted([[int(j), int(i)] for i, j in zip(component_indices, complex_indices)])\n\n        # Block B: mass action residuals vs. complex variables (diagonal)\n        # (row j, col n_c + j)\n        B = [[j, n_c + j] for j in range(n_x)]\n\n        # Block C: component mass balance residuals vs. independent component variables (diagonal)\n        # (row n_x + i, col i)\n        C = [[n_x + i, i] for i in range(n_c)]\n\n        # Block D: component mass balance residuals vs. complex variables\n        # (row n_x + i, col n_c + j) for S_ij != 0\n        D = sorted([[n_x + int(i), n_c + int(j)] for i, j in zip(component_indices, complex_indices)])\n        \n        # Block E: electroneutrality residual vs. all species variables\n        if include_en:\n            en_row = n_x + n_c\n            charged_species_indices, = np.nonzero(z)\n            E = [[en_row, int(k)] for k in charged_species_indices]\n\n        case_result = [m, n_s, A, B, C, D, E]\n        results.append(case_result)\n    \n    # Custom string representation to match format without spaces\n    def list_to_compact_str(item):\n        if isinstance(item, list):\n            return f\"[{','.join(map(list_to_compact_str, item))}]\"\n        return str(item)\n\n    # Convert the list of results to a single string\n    # The default str() in Python adds spaces, which we avoid for exactness.\n    # The prompt's example format is `[[...],[...],[...]]`, which is compact.\n    output_str = list_to_compact_str(results)\n\n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "即使有了精确的雅可比矩阵，标准的牛顿法在处理高度非线性或初始猜测不佳的问题时也可能失败。同伦延拓法是一种强大的全局化策略，它通过构建一条从一个易解问题（如理想溶液模型）通往目标问题（如包含活度系数的非理想模型）的路径来解决这一难题。在这个练习中，你将实现一个自适应步长的同伦延拓框架，亲身体验如何系统性地解决那些对于标准方法而言可能难以处理的复杂、真实的地球化学模型。",
            "id": "4094405",
            "problem": "考虑一个标准条件下的碳酸盐水溶液体系，其中钠和氯化物提供背景电解质。目标是求解一个包含质量作用定律和电荷平衡的非线性代数平衡模型，并构建和遍历一个同伦延拓，从理想溶液近似过渡到使用 Davies 方程的完整活度系数模型。设未知数向量为 $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$，其中 $m_i$ 表示摩尔浓度（单位为 $\\mathrm{mol/L}$），活度为 $a_i = \\gamma_i m_i$。\n\n基本依据：\n- 使用活度的酸解离和水自电离的质量作用定律：\n  - 碳酸一级解离：$K_1 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{a_{\\mathrm{H}_2\\mathrm{CO}_3}}$。\n  - 二级解离：$K_2 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}}}{a_{\\mathrm{HCO}_3^-}}$。\n  - 水自电离：$K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$。\n- 电中性：对于所有带电物质 $i$，$\\sum z_i m_i = 0$，其中 $z_i$ 是物质 $i$ 的电荷。\n- 总无机碳质量平衡：$C_T = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}}$。\n- 离子强度定义：$I = \\dfrac{1}{2} \\sum_i m_i z_i^2$。\n- $25^\\circ\\mathrm{C}$ 时离子活度系数的 Davies 方程：$\\log_{10} \\gamma_i = -A z_i^2\\left( \\dfrac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I \\right)$，其中 $A = 0.509$。中性物质的活度系数 $\\gamma$ 取为 1。\n\n设钠和氯的总量已知，分别为 $N_T$ 和 $Cl_T$，并假设它们仅以 $\\mathrm{Na}^+$ 和 $\\mathrm{Cl}^-$ 的形式存在。$25^\\circ\\mathrm{C}$ 时的常数为 $K_1 = 10^{-6.3}$，$K_2 = 10^{-10.3}$ 和 $K_w = 10^{-14}$。\n\n定义一个同伦 $H(\\ell,t) = F_t(\\ell)$，其中 $t \\in [0,1]$ 控制活度效应的包含程度。具体来说，根据当前浓度计算离子强度 $I(\\ell)$，并在 Davies 方程中使用一个缩放后的离子强度 $I_t(\\ell) = t\\, I(\\ell)$ 来获得 $\\gamma_i(t)$，使得所有离子的 $\\gamma_i(0)=1$（理想溶液），而 $\\gamma_i(1)$ 是完整的 Davies 值。构建方程组 $F_t(\\ell)=0$ 如下：\n- 碳质量平衡：\n  $F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T,$\n  其中 $m_{\\mathrm{H}_2\\mathrm{CO}_3} = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{K_1}$ 且 $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(t) m_{\\mathrm{H}^+}$，$a_{\\mathrm{HCO}_3^-} = \\gamma_{\\mathrm{HCO}_3^-}(t) m_{\\mathrm{HCO}_3^-}$，以及 $\\gamma_{\\mathrm{H}_2\\mathrm{CO}_3}=1$。\n- 二级解离平衡：\n  $F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-},$\n  其中 $a_{\\mathrm{CO}_3^{2-}} = \\gamma_{\\mathrm{CO}_3^{2-}}(t) m_{\\mathrm{CO}_3^{2-}}$。\n- 电中性：\n  $F_{t,3}(\\ell) = N_T + m_{\\mathrm{H}^+} - \\left(Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}} \\right),$\n  其中 $m_{\\mathrm{OH}^-}$ 由 $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ 隐式确定为 $m_{\\mathrm{OH}^-} = \\dfrac{K_w}{a_{\\mathrm{H}^+}\\, \\gamma_{\\mathrm{OH}^-}(t)}$。\n\n任务是：\n1. 在变量 $\\ell$ 中实现一个带有数值雅可比矩阵的牛顿法，以求解固定 $t$ 时的 $F_t(\\ell)=0$，并使用线搜索来稳健地减小残差。\n2. 实现一个同伦延拓策略，该策略从 $t=0$（理想溶液）开始，并通过使用自适应步长 $\\Delta t$ 选择将 $t$ 推进到 $t=1$，以保持牛顿法的收敛性。使用在 $t$ 处的解作为 $t+\\Delta t$ 的初始猜测值。如果牛顿法在几次迭代内收敛，则增加 $\\Delta t$；如果收敛缓慢或失败，则减小 $\\Delta t$ 并重试。\n3. 对于每个测试用例，计算在 $t=1$ 时氢离子活度的负常用对数，$pH = -\\log_{10}\\left(a_{\\mathrm{H}^+}\\right)$。\n\n测试套件：\n- 案例 A（一般情况）：$C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$。\n- 案例 B（高离子强度）：$C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $N_T = 0.5\\ \\mathrm{mol/L}$, $Cl_T = 0.5\\ \\mathrm{mol/L}$。\n- 案例 C（低碳边界）：$C_T = 1.0\\times 10^{-5}\\ \\mathrm{mol/L}$, $N_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$, $Cl_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$。\n\n答案规范：\n- 对于每个测试用例，输出 $t=1$ 时的最终 $pH$ 值，为一个浮点数，四舍五入到四位小数。$pH$ 是无单位的。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[pH_A,pH_B,pH_C]$），结果顺序与上面列出的测试用例顺序一致。",
            "solution": "问题陈述经评估有效。它在计算地球化学领域提出了一个适定且有科学依据的挑战，要求对代表化学平衡的非线性代数方程组进行数值求解。该问题是自洽的，所有必要的常数、方程和边界条件都已明确指定。使用同伦延拓法是从简化的理想模型过渡到更复杂的非理想模型的合适且标准的技术。\n\n解决方案的实现首先基于质量平衡、化学平衡和电荷平衡的原理，构建包含三个非线性方程的方程组 $F_t(\\ell) = 0$。未知数向量 $\\ell$ 包含主要离子物质摩尔浓度的自然对数：$\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$。使用对数作为变量是一种常见做法，有助于提高数值稳定性，并自然地强制执行浓度为正的物理约束。\n\n方程组 $F_t(\\ell)=0$ 定义如下：\n1.  **碳质量平衡 ($F_{t,1}$):** 该方程确保所有溶解无机碳物质的浓度之和等于指定的总量 $C_T$。\n    $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T = 0$$\n    这里，$m_{\\mathrm{HCO}_3^-} = e^{\\ell_1}$ 和 $m_{\\mathrm{CO}_3^{2-}} = e^{\\ell_2}$。碳酸浓度 $m_{\\mathrm{H}_2\\mathrm{CO}_3}$ 通过 $\\mathrm{H}_2\\mathrm{CO}_3$ 一级解离的质量作用定律表示：$m_{\\mathrm{H}_2\\mathrm{CO}_3} = (a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}) / K_1$，其中活度为 $a_i = \\gamma_i m_i$。\n\n2.  **二级解离平衡 ($F_{t,2}$):** 该方程表示碳酸氢根解离为碳酸根的平衡。\n    $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-} = 0$$\n\n3.  **电中性 ($F_{t,3}$):** 该方程强制电荷平衡，即溶液中正电荷的总和必须等于负电荷的总和。\n    $$F_{t,3}(\\ell) = (N_T + m_{\\mathrm{H}^+}) - (Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}}) = 0$$\n    氢氧根离子浓度 $m_{\\mathrm{OH}^-}$ 由水的自电离常数 $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ 确定。\n\n一个关键的复杂性在于，活度系数 $\\gamma_i$ 依赖于离子强度 $I = \\frac{1}{2} \\sum_i m_i z_i^2$，而离子强度又依赖于包括 $m_{\\mathrm{OH}^-}$ 在内的所有离子的浓度。这产生了一种隐式关系。这一挑战通过在每次函数 $F_t(\\ell)$ 求值时实现一个不动点迭代来解决。对于给定的 $\\ell$，这个迭代过程计算出一组自洽的离子强度和活度系数。同伦参数 $t \\in [0,1]$ 对离子强度进行缩放，$I_t = t \\cdot I$，从而允许从理想溶液（$t=0$ 时 $\\gamma_i=1$）逐渐过渡到完整的 Davies 模型（$t=1$）。Davies 方程为 $\\log_{10} \\gamma_i = -A z_i^2\\left( \\frac{\\sqrt{I_t}}{1+\\sqrt{I_t}} - 0.3 I_t \\right)$。\n\n方程组 $F_t(\\ell)=0$ 使用稳健的 Newton-Raphson 方法求解。迭代更新规则为 $\\ell_{k+1} = \\ell_k - \\lambda J_k^{-1} F_t(\\ell_k)$。雅可比矩阵 $J_k$ 包含 $F_t$ 相对于 $\\ell$ 各分量的偏导数，它是使用有限差分格式进行数值计算的。为确保稳健收敛，采用回溯线搜索来寻找一个合适的步长 $\\lambda \\in (0,1]$，以保证残差向量的范数 $\\|F_t\\|$ 有足够的减小。\n\n同伦延拓方法统筹整个求解过程。它首先使用一个初始化学猜测值求解理想情况（$t=0$）下的方程组。然后将在给定步骤 $t_i$ 的解用作下一步 $t_{i+1} = t_i + \\Delta t$ 处牛顿求解器的初始猜测值。步长 $\\Delta t$ 根据牛顿求解器的性能进行自适应调整：如果收敛迅速，则增加步长；如果收敛缓慢或失败，则减小步长，从而确保从 $t=0$ 到 $t=1$ 的路径跟踪是稳定的。\n\n成功延拓到 $t=1$ 后，获得最终向量 $\\ell_{final}$。氢离子活度计算为 $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(1) \\cdot e^{\\ell_{final,0}}$，由此确定最终的 pH 值为 $pH = -\\log_{10}(a_{\\mathrm{H}^+})$。此过程应用于每个测试用例，以生成所需结果。",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import norm, solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that encapsulates the entire logic as per the problem specification.\n    \"\"\"\n\n    # --- Start of self-contained definitions ---\n\n    # Constants\n    K1 = 10**-6.3\n    K2 = 10**-10.3\n    KW = 10**-14.0\n    A_DAVIES = 0.509\n    \n    def compute_auxiliary_vars(l, t, N_T, Cl_T):\n        \"\"\"\n        Computes self-consistent ionic strength, activity coefficients, and\n        concentrations of dependent species (m_OH, m_H2CO3) for a given state (l, t).\n        \"\"\"\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        # Fixed-point iteration for ionic strength I\n        I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + N_T + Cl_T)\n\n        for _ in range(10): # 10 iterations typically suffice for convergence\n            I_scaled = t * I\n            \n            if I_scaled  1e-15: # Ideal solution or very low I\n                gamma_H = 1.0\n                gamma_OH = 1.0\n                gamma_HCO3 = 1.0\n                gamma_CO3 = 1.0\n            else:\n                sqrt_I_scaled = np.sqrt(I_scaled)\n                davies_term = (sqrt_I_scaled / (1.0 + sqrt_I_scaled)) - 0.3 * I_scaled\n                \n                log10_gamma_H = -A_DAVIES * (1**2) * davies_term\n                log10_gamma_CO3 = -A_DAVIES * (-2**2) * davies_term\n                \n                gamma_H = 10**log10_gamma_H\n                gamma_OH = gamma_H  # z^2 = (-1)^2 = 1^2\n                gamma_HCO3 = gamma_H # z^2 = (-1)^2 = 1^2\n                gamma_CO3 = 10**log10_gamma_CO3\n            \n            denominator = gamma_H * m_H * gamma_OH\n            m_OH = KW / denominator if denominator > 1e-30 else 0.0\n\n            I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + m_OH + N_T + Cl_T)\n\n        gammas = {'H': gamma_H, 'OH': gamma_OH, 'HCO3': gamma_HCO3, 'CO3': gamma_CO3}\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        m_H2CO3 = (a_H * a_HCO3) / K1\n\n        return {'gammas': gammas, 'm_H2CO3': m_H2CO3, 'm_OH': m_OH}\n\n    def system_function(l, t, params):\n        \"\"\"\n        Computes the residual vector F(l, t) for the system of non-linear equations.\n        \"\"\"\n        C_T, N_T, Cl_T = params['C_T'], params['N_T'], params['Cl_T']\n        \n        aux = compute_auxiliary_vars(l, t, N_T, Cl_T)\n        gammas, m_H2CO3, m_OH = aux['gammas'], aux['m_H2CO3'], aux['m_OH']\n\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        F1 = m_H2CO3 + m_HCO3 + m_CO3 - C_T\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        a_CO3 = gammas['CO3'] * m_CO3\n        F2 = a_H * a_CO3 - K2 * a_HCO3\n        \n        F3 = (N_T + m_H) - (Cl_T + m_OH + m_HCO3 + 2 * m_CO3)\n        \n        return np.array([F1, F2, F3])\n\n    def numerical_jacobian(F_func, l, t, params):\n        \"\"\"\n        Computes the Jacobian matrix of F_func w.r.t. l using finite differences.\n        \"\"\"\n        f0 = F_func(l, t, params)\n        n = len(l)\n        J = np.zeros((n, n))\n        h = 1e-8\n        \n        for j in range(n):\n            l_plus_h = l.copy()\n            l_plus_h[j] += h\n            f_plus_h = F_func(l_plus_h, t, params)\n            J[:, j] = (f_plus_h - f0) / h\n            \n        return J\n\n    def newton_solver(F_func, l_guess, t, params, tol=1e-10, max_iter=25):\n        \"\"\"\n        Solves F(l) = 0 using Newton's method with a backtracking line search.\n        \"\"\"\n        l = l_guess.copy()\n        alpha = 1e-4\n        beta = 0.5\n        \n        for i in range(max_iter):\n            F_val = F_func(l, t, params)\n            norm_F = norm(F_val)\n\n            if norm_F  tol:\n                return l, True, i + 1\n\n            J_val = numerical_jacobian(F_func, l, t, params)\n            \n            try:\n                delta_l = linsolve(J_val, -F_val)\n            except np.linalg.LinAlgError:\n                return l, False, i + 1\n\n            lambda_step = 1.0\n            for _ in range(10): # Max 10 backtracking steps\n                l_new = l + lambda_step * delta_l\n                F_new_norm = norm(F_func(l_new, t, params))\n                if F_new_norm  (1 - alpha * lambda_step) * norm_F:\n                    break\n                lambda_step *= beta\n            else: # No suitable step found\n                return l, False, i + 1\n            \n            l = l_new\n\n        return l, norm(F_func(l, t, params))  tol, max_iter\n\n    def solve_case(params):\n        \"\"\"\n        Performs homotopy continuation to solve the geochemical system for a given case.\n        \"\"\"\n        m_H_guess = 1e-7\n        m_HCO3_guess = params['C_T']\n        m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess > 0 else 1e-10\n        l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n\n        t = 0.0\n        dt, min_dt, max_dt = 0.05, 1e-5, 0.2\n        \n        l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n        if not converged:\n            m_H_guess = 1e-4\n            m_HCO3_guess = K1 * params['C_T'] / m_H_guess if m_H_guess > 0 else 1e-5\n            m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess > 0 else 1e-10\n            l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n            l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n            if not converged:\n                raise RuntimeError(\"Initial solver failed for t=0\")\n\n        while t  1.0:\n            t_next = min(1.0, t + dt)\n            l_next, converged, iters = newton_solver(system_function, l_current, t_next, params)\n\n            if converged:\n                l_current, t = l_next, t_next\n                if iters  4: dt = min(dt * 1.5, max_dt)\n            else:\n                dt *= 0.5\n                if dt  min_dt: raise RuntimeError(f\"Homotopy failed at t={t}\")\n        \n        l_final = l_current\n        m_H_final = np.exp(l_final[0])\n        gamma_H_final = compute_auxiliary_vars(l_final, 1.0, params['N_T'], params['Cl_T'])['gammas']['H']\n        a_H_final = gamma_H_final * m_H_final\n        return -np.log10(a_H_final)\n\n    # --- End of self-contained definitions ---\n\n    test_cases = [\n        {'C_T': 2.0e-3, 'N_T': 1.0e-2, 'Cl_T': 1.0e-2}, # Case A\n        {'C_T': 2.0e-3, 'N_T': 0.5, 'Cl_T': 0.5},       # Case B\n        {'C_T': 1.0e-5, 'N_T': 1.0e-3, 'Cl_T': 1.0e-3}, # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        pH_final = solve_case(params)\n        results.append(f\"{pH_final:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}