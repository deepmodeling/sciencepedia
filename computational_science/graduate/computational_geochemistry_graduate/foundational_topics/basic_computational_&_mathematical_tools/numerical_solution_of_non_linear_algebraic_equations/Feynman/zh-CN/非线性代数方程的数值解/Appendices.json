{
    "hands_on_practices": [
        {
            "introduction": "本节的第一个实践将从一个基本问题入手：计算水溶液的$\\mathrm{pH}$值。这个练习的核心是将地球化学的基本原理——电中性、质量作用和质量平衡——转化为一个可以求解的非线性代数方程。通过为这个方程设计和实现一个二分法求解器，你将掌握一种最稳健的求根算法，并深入理解保证数值方法收敛的条件。",
            "id": "4094375",
            "problem": "考虑一个温度为 $25\\,^{\\circ}\\mathrm{C}$ 的水溶液，其中含有弱酸碱体系和强电解质。目标是数值求解一个以酸度 $\\mathrm{pH}$ 表示的非线性代数方程形式的电中性条件。其基本出发点是电中性原理，即在平衡状态下，正电荷总和等于负电荷总和，同时还需结合酸碱体系的平衡质量作用关系和总质量平衡约束。假设溶液为理想溶液，因此化学活度可用摩尔浓度近似。\n\n设弱酸体系为无机碳体系 $\\mathrm{H_{2}CO_{3}^{*}}/\\mathrm{HCO_{3}^{-}}/\\mathrm{CO_{3}^{2-}}$，其一级和二级酸解离常数分别表示为 $K_{1}$ 和 $K_{2}$。设水的自偶电离由离子积 $K_{w}$ 表征。所有常数均为 $25\\,^{\\circ}\\mathrm{C}$ 下的值：\n- $K_{1} = 10^{-6.3}$，\n- $K_{2} = 10^{-10.3}$，\n- $K_{w} = 10^{-14}$。\n\n定义溶解无机碳（DIC）的总浓度为 $C_{\\mathrm{T}}$，单位为 $\\mathrm{mol/L}$；强电解质离子钠和氯的总浓度分别为 $C_{\\mathrm{Na}}$ 和 $C_{\\mathrm{Cl}}$，单位为 $\\mathrm{mol/L}$。视钠和氯为完全解离。\n\n对于给定的 $\\mathrm{pH}$，记 $H = [\\mathrm{H^{+}}] = 10^{-\\mathrm{pH}}$ 和 $[\\mathrm{OH^{-}}] = K_{w}/H$。利用碳酸盐体系的质量作用和守恒定律，物种浓度 $[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$ 是可通过解离平衡和总 $C_{\\mathrm{T}}$ 约束得到的关于 $H$、$K_{1}$、$K_{2}$ 和 $C_{\\mathrm{T}}$ 的函数。构建电中性函数 $f(\\mathrm{pH})$ 为正电荷总和与负电荷总和之差，\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + C_{\\mathrm{Na}} \\right) - \\left( [\\mathrm{OH^{-}}] + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right),\n$$\n该函数通过 $H=10^{-\\mathrm{pH}}$ 和碳酸盐形态函数完全表示为 $\\mathrm{pH}$ 的函数。\n\n任务：\n1.  从上述基本原理（电中性、质量作用和质量平衡）出发，在不引入任何非由这些原理推导出的简化公式的情况下，从数学上推导出如何用 $H$、$K_{1}$、$K_{2}$ 和 $C_{\\mathrm{T}}$ 表示 $[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$。\n2.  利用这些表达式，构建一个二分算法来求解闭区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ 上的 $f(\\mathrm{pH}) = 0$。假设 $f$ 在该区间上连续且在端点处变号。明确论证 $f(\\mathrm{pH})$ 的连续性，并解释为什么符号改变 $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$ 意味着区间内存在一个根。\n3.  实现二分法，为下述每个测试用例求解 $\\mathrm{pH}$。对区间宽度或 $|f(\\mathrm{pH})|$ 使用 $10^{-8}$ 的容差，具体执行哪个标准由您选择。所有浓度必须以 $\\mathrm{mol/L}$ 为单位处理，最终的 $\\mathrm{pH}$ 是无量纲的。解决方案不得依赖任何外部输入，且必须数值稳定。\n\n测试套件（每个条目为 $(C_{\\mathrm{T}}, C_{\\mathrm{Na}}, C_{\\mathrm{Cl}}, \\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$）：\n-   案例 A（一般淡水碳酸盐体系）：$(2.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 1.0 \\times 10^{-3},\\; 4,\\; 10)$。\n-   案例 B（酸性富氯体系）：$(1.0 \\times 10^{-4},\\; 0.0,\\; 1.0 \\times 10^{-3},\\; 0,\\; 7)$。\n-   案例 C（碱性富钠体系）：$(1.0 \\times 10^{-3},\\; 5.0 \\times 10^{-4},\\; 0.0,\\; 4,\\; 14)$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含案例 A、B 和 C 的三个计算出的 $\\mathrm{pH}$ 值，格式为逗号分隔的列表并用方括号括起来，每个 $\\mathrm{pH}$ 值四舍五入到六位小数，例如 $[\\mathrm{pH}_{A},\\mathrm{pH}_{B},\\mathrm{pH}_{C}]$。",
            "solution": "该问题要求通过数值求解电中性方程，来找出含有无机碳体系和强电解质的水溶液的平衡 $\\mathrm{pH}$ 值。这是计算地球化学中的一个基本问题。解决方案按要求分为三个主要部分：从第一性原理推导控制方程，构建数值算法，以及实现该解决方案。\n\n### 第 1 部分：碳酸盐物种浓度的推导\n\n碳酸盐体系在水中的形态分布受化学平衡和质量平衡约束的控制。我们首先陈述这些基本关系。所有浓度单位均为 $\\mathrm{mol/L}$。\n\n设 $H = [\\mathrm{H^{+}}]$。碳酸盐体系的解离反应为：\n1.  $\\mathrm{H_{2}CO_{3}^{*}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{HCO_{3}^{-}}$\n2.  $\\mathrm{HCO_{3}^{-}} \\rightleftharpoons \\mathrm{H^{+}} + \\mathrm{CO_{3}^{2-}}$\n\n假设为理想溶液行为，质量作用定律得出平衡常数表达式：\n$$\nK_{1} = \\frac{[\\mathrm{H^{+}}][\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]} = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{[\\mathrm{H_{2}CO_{3}^{*}}]}\n$$\n$$\nK_{2} = \\frac{[\\mathrm{H^{+}}][\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]} = \\frac{H \\cdot [\\mathrm{CO_{3}^{2-}}]}{[\\mathrm{HCO_{3}^{-}}]}\n$$\n\n溶解无机碳的总浓度 $C_{\\mathrm{T}}$ 由质量平衡方程给出：\n$$\nC_{\\mathrm{T}} = [\\mathrm{H_{2}CO_{3}^{*}}] + [\\mathrm{HCO_{3}^{-}}] + [\\mathrm{CO_{3}^{2-}}]\n$$\n\n我们的目标是将每种碳酸盐物种的浓度（$[\\mathrm{H_{2}CO_{3}^{*}}]$、$[\\mathrm{HCO_{3}^{-}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$）表示为已知量 $H$、$C_{\\mathrm{T}}$、$K_{1}$ 和 $K_{2}$ 的函数。\n\n从平衡表达式中，我们可以用 $[\\mathrm{HCO_{3}^{-}}]$ 和 $H$ 来表示 $[\\mathrm{H_{2}CO_{3}^{*}}]$ 和 $[\\mathrm{CO_{3}^{2-}}]$：\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}}\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H}\n$$\n\n接下来，我们将这些表达式代入 $C_{\\mathrm{T}}$ 的质量平衡方程：\n$$\nC_{\\mathrm{T}} = \\left( \\frac{H \\cdot [\\mathrm{HCO_{3}^{-}}]}{K_{1}} \\right) + [\\mathrm{HCO_{3}^{-}}] + \\left( \\frac{K_{2} \\cdot [\\mathrm{HCO_{3}^{-}}]}{H} \\right)\n$$\n\n我们提出公因子 $[\\mathrm{HCO_{3}^{-}}]$：\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H}{K_{1}} + 1 + \\frac{K_{2}}{H} \\right)\n$$\n\n为简化括号中的项，我们找到公分母 $K_{1}H$：\n$$\nC_{\\mathrm{T}} = [\\mathrm{HCO_{3}^{-}}] \\left( \\frac{H^2 + K_{1}H + K_{1}K_{2}}{K_{1}H} \\right)\n$$\n\n现在，我们可以解出 $[\\mathrm{HCO_{3}^{-}}]$：\n$$\n[\\mathrm{HCO_{3}^{-}}] = C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n\n有了 $[\\mathrm{HCO_{3}^{-}}]$ 的表达式，我们可以通过回代找到另外两种物种的表达式：\n$$\n[\\mathrm{H_{2}CO_{3}^{*}}] = \\frac{H}{K_{1}} [\\mathrm{HCO_{3}^{-}}] = \\frac{H}{K_{1}} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{H^2}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n$$\n[\\mathrm{CO_{3}^{2-}}] = \\frac{K_{2}}{H} [\\mathrm{HCO_{3}^{-}}] = \\frac{K_{2}}{H} C_{\\mathrm{T}} \\left( \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} \\right) = C_{\\mathrm{T}} \\left( \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n这些就是所需的碳酸盐物种浓度的表达式。\n\n### 第 2 部分：二分算法的构建\n\n问题的核心是求解电中性方程 $f(\\mathrm{pH}) = 0$。函数 $f(\\mathrm{pH})$ 表示溶液中的净电荷，定义为所有正电荷之和减去所有负电荷之和。\n\n阳离子（正离子）是 $\\mathrm{H^{+}}$ 和 $\\mathrm{Na^{+}}$。阴离子（负离子）是 $\\mathrm{OH^{-}}$、$\\mathrm{Cl^{-}}$、$\\mathrm{HCO_{3}^{-}}$ 和 $\\mathrm{CO_{3}^{2-}}$。碳酸根离子 $\\mathrm{CO_{3}^{2-}}$ 的电荷为 -2，因此在电荷平衡中其浓度乘以 2。\n$$\nf(\\mathrm{pH}) = \\sum (\\mathrm{正电荷}) - \\sum (\\mathrm{负电荷})\n$$\n$$\nf(\\mathrm{pH}) = \\left( [\\mathrm{H^{+}}] + [\\mathrm{Na^{+}}] \\right) - \\left( [\\mathrm{OH^{-}}] + [\\mathrm{Cl^{-}}] + [\\mathrm{HCO_{3}^{-}}] + 2 \\cdot [\\mathrm{CO_{3}^{2-}}] \\right)\n$$\n鉴于 $\\mathrm{Na^{+}}$ 和 $\\mathrm{Cl^{-}}$ 来自强电解质，它们的浓度分别为 $C_{\\mathrm{Na}}$ 和 $C_{\\mathrm{Cl}}$。我们使用第 1 部分的表达式和水的自偶电离反应，即 $[\\mathrm{OH^{-}}] = K_{w}/H$，其中 $H = 10^{-\\mathrm{pH}}$。\n$$\nf(\\mathrm{pH}) = \\left( H + C_{\\mathrm{Na}} \\right) - \\left( \\frac{K_{w}}{H} + C_{\\mathrm{Cl}} + [\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] \\right)\n$$\n代入推导出的物种浓度：\n$$\n[\\mathrm{HCO_{3}^{-}}] + 2[\\mathrm{CO_{3}^{2-}}] = C_{\\mathrm{T}} \\frac{K_{1}H}{H^2 + K_{1}H + K_{1}K_{2}} + 2 \\cdot C_{\\mathrm{T}} \\frac{K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} = C_{\\mathrm{T}} \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}}\n$$\n因此，最终待求解的函数是：\n$$\nf(\\mathrm{pH}) = H + C_{\\mathrm{Na}} - \\frac{K_{w}}{H} - C_{\\mathrm{Cl}} - C_{\\mathrm{T}} \\left( \\frac{K_{1}H + 2K_{1}K_{2}}{H^2 + K_{1}H + K_{1}K_{2}} \\right)\n$$\n其中 $H=10^{-\\mathrm{pH}}$。\n\n二分法是一种适用于连续函数的迭代求根算法。在此处使用它的理由基于 $f(\\mathrm{pH})$ 的两个性质：连续性和在给定区间内存在根。\n\n**$f(\\mathrm{pH})$ 的连续性**：\n函数 $f(\\mathrm{pH})$ 是由几个更简单的 $\\mathrm{pH}$ 函数通过复合和代数和构成的：\n1.  $H(\\mathrm{pH}) = 10^{-\\mathrm{pH}}$ 对所有实数 $\\mathrm{pH}$ 都是连续的。\n2.  项 $K_{w}/H$ 对所有 $H>0$ 都是连续的，即对任何有限的 $\\mathrm{pH}$ 值都是连续的。\n3.  碳酸盐形态项是关于 $H$ 的有理函数。它们的分母是 $D(H) = H^2 + K_{1}H + K_{1}K_{2}$。由于所有参数（$H$、$K_{1}$、$K_{2}$）对于任何物理溶液都是严格为正的，分母 $D(H)$ 总是为正且永不为零。因此，碳酸盐项是关于 $H$ 的连续函数。\n因为 $f(\\mathrm{pH})$ 是由这些连续函数的和、差和复合构成的，所以它本身在任何区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$（其中 $0 \\le \\mathrm{pH}_{\\min}  \\mathrm{pH}_{\\max}  \\infty$）上都是 $\\mathrm{pH}$ 的连续函数。\n\n**根的存在性**：\n二分法依赖于**介值定理（IVT）**。IVT 指出，如果函数 $g(x)$ 在闭区间 $[a, b]$ 上连续，那么对于 $g(a)$ 和 $g(b)$ 之间的任何值 $N$，必定存在至少一点 $c \\in [a, b]$ 使得 $g(c) = N$。\n在我们的情况下，问题指定了一个搜索区间 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$ 并假设存在符号改变，即 $f(\\mathrm{pH}_{\\min}) \\cdot f(\\mathrm{pH}_{\\max})  0$。这意味着 $f(\\mathrm{pH}_{\\min})$ 和 $f(\\mathrm{pH}_{\\max})$ 中一个为正，另一个为负。因此，值 $N=0$ 位于 $f(\\mathrm{pH}_{\\min})$ 和 $f(\\mathrm{pH}_{\\max})$ 之间。由于 $f(\\mathrm{pH})$ 在此区间上是连续的，IVT 保证了至少存在一个根 $\\mathrm{pH}_{\\text{root}} \\in (\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max})$ 使得 $f(\\mathrm{pH}_{\\text{root}}) = 0$。\n\n**二分算法**：\n设搜索区间为 $[a, b]$，初始化为 $[\\mathrm{pH}_{\\min}, \\mathrm{pH}_{\\max}]$。我们要求 $f(a)$ 和 $f(b)$ 异号。算法流程如下：\n1.  设定一个容差 $\\epsilon$（例如 $10^{-8}$）。\n2.  当区间宽度 $(b-a)$ 大于 $\\epsilon$ 时，重复以下步骤：\n    a. 计算区间的中点：$m = a + (b-a)/2$。\n    b. 在中点处计算函数值 $f(m)$。\n    c. 如果 $f(a)$ 和 $f(m)$ 异号（即 $f(a) \\cdot f(m)  0$），则根必在区间 $[a, m]$ 内。通过设置 $b = m$ 来更新区间。\n    d. 否则，根必在 $[m, b]$ 内（即 $f(m) \\cdot f(b) \\le 0$）。通过设置 $a = m$ 来更新区间。\n3.  一旦循环终止，区间 $[a, b]$ 将小于容差 $\\epsilon$。根可以近似为此最终区间的中点 $(a+b)/2$。\n\n该算法保证收敛到一个根，每次迭代都会将不确定性区间减半。\n\n### 第 3 部分：实现\n\n二分算法用 Python 实现。一个函数用于计算给定参数集下电中性函数 $f(\\mathrm{pH})$ 的值。第二个函数实现二分搜索。此过程应用于三个测试用例中的每一个。常数定义为 $K_{1} = 10^{-6.3}$、$K_{2} = 10^{-10.3}$ 和 $K_{w} = 10^{-14}$。使用基于区间宽度小于 $10^{-8}$ 容差的停止准则。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the pH of an aqueous carbonate system using the bisection method.\n    The function sets up the problem parameters for three test cases and computes\n    the equilibrium pH for each by finding the root of the electroneutrality equation.\n    \"\"\"\n\n    # Define constants at 25 degrees Celsius\n    K1 = 10**(-6.3)\n    K2 = 10**(-10.3)\n    KW = 10**(-14.0)\n\n    # Define the test cases from the problem statement.\n    # Each tuple: (C_T, C_Na, C_Cl, pH_min, pH_max)\n    test_cases = [\n        # Case A: General freshwater carbonate system\n        (2.0e-3, 1.0e-3, 1.0e-3, 4.0, 10.0),\n        # Case B: Acidic chloride-rich system\n        (1.0e-4, 0.0, 1.0e-3, 0.0, 7.0),\n        # Case C: Basic sodium-rich system\n        (1.0e-3, 5.0e-4, 0.0, 4.0, 14.0),\n    ]\n\n    def electroneutrality_func(ph, C_T, C_Na, C_Cl):\n        \"\"\"\n        Calculates the value of the electroneutrality function f(pH).\n\n        f(pH) = (sum of positive charges) - (sum of negative charges)\n        \"\"\"\n        H = 10**(-ph)\n        OH = KW / H\n\n        # Carbonate speciation term: [HCO3-] + 2*[CO3^2-]\n        # Denominator of the speciation fractions\n        denominator = H**2 + K1 * H + K1 * K2\n        \n        # Avoid division by zero, though for H>0 denominator is always > 0\n        if denominator == 0:\n            # This case is physically impossible for H > 0\n            return np.inf\n\n        # [HCO3-] + 2*[CO3^2-] = C_T * (K1*H / denom) + 2 * C_T * (K1*K2 / denom)\n        carbonate_charge_term = C_T * (K1 * H + 2 * K1 * K2) / denominator\n        \n        # Calculate net charge (the function f(pH) we want to find the root of)\n        # f(pH) = [H+] + [Na+] - ([OH-] + [Cl-] + [HCO3-] + 2*[CO3^2-])\n        net_charge = (H + C_Na) - (OH + C_Cl + carbonate_charge_term)\n\n        return net_charge\n\n    def bisection_solver(params, tol=1.0e-8, max_iter=100):\n        \"\"\"\n        Finds the root of the electroneutrality function using the bisection method.\n        \"\"\"\n        C_T, C_Na, C_Cl, ph_min, ph_max = params\n        \n        a = ph_min\n        b = ph_max\n        \n        f_a = electroneutrality_func(a, C_T, C_Na, C_Cl)\n        f_b = electroneutrality_func(b, C_T, C_Na, C_Cl)\n\n        # Check if a root is guaranteed to be in the interval\n        if f_a * f_b >= 0:\n            # This case should not occur with the problem's given brackets\n            # but is good practice to check.\n            if abs(f_a)  tol: return a\n            if abs(f_b)  tol: return b\n            raise ValueError(\"Bisection method fails: f(a) and f(b) must have opposite signs.\")\n            \n        for _ in range(max_iter):\n            mid = a + (b - a) / 2\n            f_mid = electroneutrality_func(mid, C_T, C_Na, C_Cl)\n\n            if abs(f_mid)  tol or (b - a) / 2  tol:\n                return mid\n            \n            # Update the interval\n            if f_a * f_mid  0:\n                b = mid\n            else:\n                a = mid\n                f_a = f_mid # Update f_a to f_mid\n\n        return (a + b) / 2\n\n    results = []\n    for case in test_cases:\n        ph_solution = bisection_solver(case)\n        results.append(f\"{ph_solution:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "虽然二分法非常稳健，但其收敛速度较慢，对于更复杂的多维问题效率不高。因此，我们需要一种更强大的工具：牛顿法。这个练习将通过直接比较二分法和牛顿法来求解同一个$\\mathrm{pH}$问题，引导你分析这两种算法在收敛速度和稳健性上的关键差异，从而理解为什么牛顿法是求解非线性方程组的主力方法，以及使用它时需要注意的潜在陷阱。",
            "id": "4094382",
            "problem": "在总分析浓度为 $C_T$、酸解离常数为 $K_a$ 的一元弱酸 $\\mathrm{HA}$ 水溶液中，假设为理想行为，溶解物质的电中性（电荷平衡）条件可以写为\n$$[\\mathrm{H}^+] - [\\mathrm{OH}^-] - [\\mathrm{A}^-] = 0,$$\n其中，根据水的自电离平衡有 $[\\mathrm{OH}^-] = K_w/[\\mathrm{H}^+]$，根据质量作用关系和酸物质守恒有 $[\\mathrm{A}^-] = \\dfrac{K_a C_T}{[\\mathrm{H}^+] + K_a}$。这为 $x = [\\mathrm{H}^+]$ 产生一个标量非线性方程，\n$$f(x) = x - \\frac{K_w}{x} - \\frac{K_a C_T}{x + K_a} = 0.$$\n将 $\\mathrm{pH}$（氢离子电势）定义为 $h = -\\log_{10}(x)$，并将该方程用 $h$ 重写为函数\n$$g(h) = 10^{-h} - 10^{h - 14} - \\frac{K_a C_T}{10^{-h} + K_a} = 0.$$\n考虑参数集 $K_w = 1.0 \\times 10^{-14}$，$K_a = 1.0 \\times 10^{-6}$ 和 $C_T = 1.0 \\times 10^{-7}$，这代表了标准条件下稀弱酸水溶液。你需要通过推导迭代次数并解释收敛行为和稳健性的差异，来比较应用于同一问题中标量区间法和牛顿法（应用于 $g(h)$）。\n\n对于数值求解，请使用以下规范：\n- 在 $\\mathrm{pH}$ 变量 $h$ 上进行计算，使用区间 $[h_{\\min}, h_{\\max}] = [4, 10]$，该区间包含物理上相关的解，并满足 $g(4) > 0$ 和 $g(10)  0$。\n- 收敛容差为绝对 $\\mathrm{pH}$ 容差 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$，这意味着当区间半宽（对于区间法）或连续迭代差 $|h_{k+1} - h_k|$（对于牛顿法）小于或等于 $\\varepsilon_{\\mathrm{pH}}$ 时，算法应停止。\n- 对于 $g(h)$ 上的牛顿法，使用标准迭代 $h_{k+1} = h_k - g(h_k)/g'(h_k)$，初始猜测值为 $h_0 = 6$，其中 $g'(h)$ 是根据第一性原理，使用链式法则和上述定义推导出来的。\n\n哪个选项最能说明此问题所需的迭代次数，并解释收敛行为和稳健性方面的差异？\n\nA. 在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $13$ 次迭代。对 $g(h)$ 使用牛顿法，从 $h_0 = 6$ 开始，大约在 $5$ 次迭代后达到相同的容差。区间法是全局收敛的，并且对初始猜测值具有稳健性，而牛顿法是局部二次收敛的，在没有良好初始猜测值或保障措施的情况下可能会失败。\n\nB. 在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $6$ 次迭代。对 $g(h)$ 使用牛顿法，从 $h_0 = 6$ 开始，大约在 $3$ 次迭代后达到相同的容差。牛顿法比区间法更稳健，因为它不需要符号变化。\n\nC. 对于此 $g(h)$，试位法是二次收敛的，通常需要大约 $4$ 次迭代才能达到 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$。二分法在没有导数信息的情况下会失败，而牛顿法总是从任何初始猜测值收敛。\n\nD. 在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $13$ 次迭代，但牛顿法需要超过 $13$ 次迭代，因为在整个区间内 $g'(h)  0$。对于此问题，区间法不如牛顿法稳健。",
            "solution": "用户希望我验证问题陈述，解决问题，并评估给定的选项。\n\n### 第一步：提取已知条件\n- **控制方程（以 $x = [\\mathrm{H}^+]$ 表示）：** $f(x) = x - \\frac{K_w}{x} - \\frac{K_a C_T}{x + K_a} = 0$。\n- **控制方程（以 $h = \\mathrm{pH} = -\\log_{10}(x)$ 表示）：** $g(h) = 10^{-h} - 10^{h - 14} - \\frac{K_a C_T}{10^{-h} + K_a} = 0$。\n- **参数：**\n    - 水的自电离常数：$K_w = 1.0 \\times 10^{-14}$。\n    - 弱酸解离常数：$K_a = 1.0 \\times 10^{-6}$。\n    - 酸的总分析浓度：$C_T = 1.0 \\times 10^{-7}$。\n- **求根的数值规范：**\n    - 在变量 $h$ (pH) 上进行求根。\n    - **区间法：**\n        - 初始区间：$[h_{\\min}, h_{\\max}] = [4, 10]$。\n        - 问题陈述 $g(4) > 0$ 和 $g(10)  0$。\n        - 停止准则：当区间半宽小于或等于绝对 pH 容差 $\\varepsilon_{\\mathrm{pH}}$ 时，算法停止。\n    - **牛顿法：**\n        - 应用于函数 $g(h)$。\n        - 初始猜测值：$h_0 = 6$。\n        - 迭代公式：$h_{k+1} = h_k - g(h_k)/g'(h_k)$。\n        - 停止准则：当连续迭代的绝对差 $|h_{k+1} - h_k|$ 小于或等于 $\\varepsilon_{\\mathrm{pH}}$ 时，算法停止。\n    - **收敛容差：** $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$。\n\n### 第二步：使用提取的已知条件进行验证\n1.  **科学依据：**该问题描述了如何确定一元弱酸溶液的 pH 值。电荷平衡方程 $f(x)=0$ 及其以 pH 表示的重构形式 $g(h)=0$ 均源自化学平衡的基本原理（电中性、质量作用、质量守恒），并且是水化学中的标准内容。参数值在物理上是现实的。该问题在科学上是合理的。\n\n2.  **适定性：**为了确认问题是适定的，我们必须验证在指定上下文中存在唯一解。\n    - 我们得到了区间 $[4, 10]$ 和陈述 $g(4) > 0$ 和 $g(10)  0$。让我们使用所提供的参数来验证这一点。\n        - $g(h) = 10^{-h} - 10^{h - 14} - \\frac{(1.0 \\times 10^{-6})(1.0 \\times 10^{-7})}{10^{-h} + 1.0 \\times 10^{-6}} = 10^{-h} - 10^{h-14} - \\frac{10^{-13}}{10^{-h} + 10^{-6}}$。\n        - 对于 $h=4$：$g(4) = 10^{-4} - 10^{-10} - \\frac{10^{-13}}{10^{-4} + 10^{-6}} \\approx 10^{-4} - 10^{-10} - 10^{-9}$。该值为正，因为 $10^{-4}$ 占主导地位。\n        - 对于 $h=10$：$g(10) = 10^{-10} - 10^{-4} - \\frac{10^{-13}}{10^{-10} + 10^{-6}} \\approx 10^{-10} - 10^{-4} - 10^{-7}$。该值为负，因为 $-10^{-4}$ 占主导地位。\n        - 由于 $g(h)$ 是一个连续函数，并在区间 $[4, 10]$ 上改变符号，根据介值定理，可以保证在 $(4, 10)$ 中至少存在一个根 $h^*$。\n    - 为了检查唯一性，我们考察导数 $g'(h)$。\n        - $g'(h) = \\frac{d}{dh} \\left( 10^{-h} - 10^{h - 14} - \\frac{K_a C_T}{10^{-h} + K_a} \\right)$。\n        - 使用 $\\frac{d}{dh}(a^u) = a^u \\ln(a) \\frac{du}{dh}$，我们得到：\n        $$g'(h) = 10^{-h} (\\ln 10)(-1) - 10^{h-14} (\\ln 10)(1) - K_a C_T (-1) (10^{-h} + K_a)^{-2} (10^{-h} (\\ln 10)(-1))$$\n        $$g'(h) = -(\\ln 10) 10^{-h} - (\\ln 10) 10^{h-14} - \\frac{(\\ln 10) K_a C_T 10^{-h}}{(10^{-h} + K_a)^2}$$\n        - 由于 $\\ln 10 > 0$，且对于任何实数 $h$，所有其他量（$K_a$, $C_T$, $10^{-h}$, $10^{h-14}$）均为正，因此 $g'(h)$ 表达式中的每一项都是负的。因此，对于所有 $h$，$g'(h)  0$。\n        - 一个严格单调的函数最多只能穿过横轴一次。因此，根 $h^*$ 是唯一的。\n    - 该问题是适定的。\n\n3.  **客观性和完整性：**问题以精确、客观的语言陈述。求解所需的所有常数、初始条件和收敛准则都已明确提供。\n\n### 第三步：结论和行动\n问题是有效的。它有科学依据，是适定的，并且提供了所有必要的信息。我现在将继续进行求解。\n\n### 推导与分析\n\n**1. 二分法迭代次数**\n\n二分法从一个长度为 $L_0 = b_0 - a_0$ 的区间 $[a_0, b_0]$ 开始。经过 $k$ 次迭代后，区间长度减小为 $L_k = L_0 / 2^k$。\n\n初始区间为 $[4, 10]$，所以初始长度为 $L_0 = 10 - 4 = 6$。\n\n问题陈述的停止准则是“当区间半宽...小于或等于 $\\varepsilon_{\\mathrm{pH}}$”。经过 $k$ 次迭代后，区间 $[a_k, b_k]$ 的半宽为 $w_k = (b_k - a_k)/2 = L_k/2 = L_0/2^{k+1}$。\n\n我们需要找到满足 $w_k \\leq \\varepsilon_{\\mathrm{pH}}$ 的最小迭代次数 $k$。\n$$ \\frac{6}{2^{k+1}} \\leq 1.0 \\times 10^{-3} $$\n$$ 6000 \\leq 2^{k+1} $$\n对两边取以 2 为底的对数：\n$$ \\log_2(6000) \\leq k+1 $$\n使用计算器，$\\log_2(6000) = \\frac{\\ln(6000)}{\\ln(2)} \\approx \\frac{8.6996}{0.6931} \\approx 12.55$。\n所以，我们需要 $12.55 \\leq k+1$，这意味着 $k \\geq 11.55$。满足此条件的最小整数 $k$ 是 $12$。\n\n然而，选项A和D指出该方法需要“至少 $13$ 次迭代”。如果停止准则应用于整个区间宽度 $L_k$，而不是半宽，就会得到这个结果：\n$$ L_k \\leq \\varepsilon_{\\mathrm{pH}} \\implies \\frac{6}{2^k} \\leq 1.0 \\times 10^{-3} $$\n$$ 6000 \\leq 2^k $$\n$$ \\log_2(6000) \\leq k \\implies 12.55 \\leq k $$\n满足此条件的最小整数 $k$ 是 $13$。虽然这与问题的字面表述（“区间半宽”）相矛盾，但这是二分法问题的一种常见提法，并且它出现在选项中强烈暗示这是预期的解释。我们将假定需要 $13$ 次迭代继续进行。\n\n**2. 牛顿法迭代次数**\n\n迭代公式为 $h_{k+1} = h_k - g(h_k)/g'(h_k)$，其中 $h_0=6$，停止准则为 $|h_{k+1}-h_k| \\leq 10^{-3}$。我们执行迭代过程：\n$g(h) = 10^{-h} - 10^{h-14} - \\frac{10^{-13}}{10^{-h} + 10^{-6}}$\n$g'(h) = -(\\ln 10) \\left( 10^{-h} + 10^{h-14} + \\frac{10^{-13} \\cdot 10^{-h}}{(10^{-h} + 10^{-6})^2} \\right)$\n$\\ln 10 \\approx 2.302585$\n\n- **迭代 $k=0$：**\n  $h_0 = 6$\n  $g(6) = 10^{-6} - 10^{-8} - \\frac{10^{-13}}{10^{-6} + 10^{-6}} = 9.4 \\times 10^{-7}$\n  $g'(6) \\approx -2.3026 \\left( 10^{-6} + 10^{-8} + \\frac{10^{-19}}{4 \\times 10^{-12}} \\right) = -2.3026 (1.035 \\times 10^{-6}) \\approx -2.383 \\times 10^{-6}$\n  $h_1 = 6 - \\frac{9.4 \\times 10^{-7}}{-2.383 \\times 10^{-6}} \\approx 6 + 0.3945 = 6.3945$\n  $|h_1 - h_0| = 0.3945 > 10^{-3}$。\n\n- **迭代 $k=1$：**\n  $h_1 = 6.3945$\n  $g(6.3945) \\approx 3.07 \\times 10^{-7}$\n  $g'(6.3945) \\approx -1.03 \\times 10^{-6}$\n  $h_2 = 6.3945 - \\frac{3.07 \\times 10^{-7}}{-1.03 \\times 10^{-6}} \\approx 6.3945 + 0.298 = 6.6925$\n  $|h_2 - h_1| = 0.298 > 10^{-3}$。\n\n- **迭代 $k=2$：**\n  $h_2 = 6.6925$\n  $g(6.6925) \\approx 7.08 \\times 10^{-8}$\n  $g'(6.6925) \\approx -5.81 \\times 10^{-7}$\n  $h_3 = 6.6925 - \\frac{7.08 \\times 10^{-8}}{-5.81 \\times 10^{-7}} \\approx 6.6925 + 0.1219 = 6.8144$\n  $|h_3 - h_2| = 0.1219 > 10^{-3}$。\n\n- **迭代 $k=3$：**\n  $h_3 = 6.8144$\n  $g(6.8144) \\approx 1.55 \\times 10^{-9}$\n  $g'(6.8144) \\approx -5.04 \\times 10^{-7}$\n  $h_4 = 6.8144 - \\frac{1.55 \\times 10^{-9}}{-5.04 \\times 10^{-7}} \\approx 6.8144 + 0.00308 = 6.81748$\n  $|h_4 - h_3| = 0.00308 > 10^{-3}$。\n\n- **迭代 $k=4$：**\n  $h_4 = 6.81748$\n  $g(6.81748) \\approx 8.1 \\times 10^{-13}$\n  $g'(6.81748) \\approx -5.02 \\times 10^{-7}$\n  $h_5 = 6.81748 - \\frac{8.1 \\times 10^{-13}}{-5.02 \\times 10^{-7}} \\approx 6.81748 + 1.6 \\times 10^{-6} = 6.8174816$\n  $|h_5 - h_4| = 1.6 \\times 10^{-6} \\leq 10^{-3}$。\n在第 4 次迭代后（计算 $h_5$ 时）满足停止准则。该算法总共执行了 5 次更新（从 $h_1$ 到 $h_5$）。因此，需要 5 次迭代。\n\n**3. 方法比较与选项评估**\n\n- **区间法（如二分法）：**这些方法是稳健的。给定一个初始区间 $[a,b]$，其中连续函数 $f$ 满足 $f(a)f(b)0$，它们保证能找到一个根。此性质称为全局收敛（在初始区间内）。它们的收敛速度是线性的且可预测，但通常较慢。\n- **牛顿法：**这是一种开放方法，不保证收敛。其收敛性取决于初始猜测值 $h_0$ 以及函数及其导数的行为。当它确实收敛到一个简单根（其中 $g'(h^*) \\neq 0$）时，其收敛是二次的，速度非常快。如果初始猜测不好，它可能会发散到无穷大、振荡或收敛到非预期的根（如果存在）。在实践中，通常使用保障措施（例如，与二分法结合）来提高稳健性。\n\n现在我们根据我们的发现评估这些选项。\n\n**选项 A：**“在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $13$ 次迭代。对 $g(h)$ 使用牛顿法，从 $h_0 = 6$ 开始，大约在 $5$ 次迭代后达到相同的容差。区间法是全局收敛的，并且对初始猜测值具有稳健性，而牛顿法是局部二次收敛的，在没有良好初始猜测值或保障措施的情况下可能会失败。”\n- 二分法迭代次数：$13$。这与我们基于可能的预期停止准则的计算相符。\n- 牛顿法迭代次数：$5$。这与我们的计算相符。\n- 定性比较：该陈述完美地概括了区间法和牛顿法之间的标准权衡。\n- **结论：正确。**\n\n**选项 B：**“在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $6$ 次迭代。对 $g(h)$ 使用牛顿法，从 $h_0 = 6$ 开始，大约在 $3$ 次迭代后达到相同的容差。牛顿法比区间法更稳健，因为它不需要符号变化。”\n- 二分法迭代次数：$6$。不正确。\n- 牛顿法迭代次数：$3$。不正确。\n- 定性比较：声称“牛顿法比区间法更稳健”是根本错误的。\n- **结论：不正确。**\n\n**选项 C：**“对于此 $g(h)$，试位法是二次收敛的，通常需要大约 $4$ 次迭代才能达到 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$。二分法在没有导数信息的情况下会失败，而牛顿法总是从任何初始猜测值收敛。”\n- 试位法收敛性：标准试位法的收敛阶是线性的，不是二次的。\n- “二分法在没有导数信息的情况下会失败”：二分法不使用也不需要导数信息；这是一个优点。\n- “牛顿法总是从任何初始猜测值收敛”：错误，它只有局部收敛保证。\n- **结论：不正确。**\n\n**选项 D：**“在 $[4, 10]$ 上对 $h$ 使用二分法，当 $\\varepsilon_{\\mathrm{pH}} = 1.0 \\times 10^{-3}$ 时，需要至少 $13$ 次迭代，但牛顿法需要超过 $13$ 次迭代，因为在整个区间内 $g'(h)  0$。对于此问题，区间法不如牛顿法稳健。”\n- 二分法迭代次数：$13$。这部分是一致的。\n- 牛顿法迭代次数：“超过 $13$”。这是错误的；它只需要 $5$ 次。其理由“因为 $g'(h)  0$”是有缺陷的；非零导数是牛顿法良好工作的必要条件。\n- 定性比较：声称“区间法不如牛顿法稳健”是错误的。\n- **结论：不正确。**\n\n基于详细分析，选项A提供了正确的迭代次数和对数值方法的准确定性比较。",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "在解决了理想模型之后，我们面临着一个更真实的挑战：如何求解包含活度系数的非理想体系，这类问题往往使标准的牛顿法难以收敛。这个高级实践将介绍一种强大的全局化策略——同伦延拓法。你将构建一个从简单的理想模型平滑过渡到复杂非理想模型的路径，并学习如何通过自适应地调整步长来“引导”牛顿法找到正确解，从而掌握解决实际地球化学模拟中复杂非线性问题的关键技术。",
            "id": "4094405",
            "problem": "考虑一个在标准条件下的碳酸盐水溶液体系，其中钠和氯化物提供背景电解质。目标是求解一个包含质量作用定律和电荷平衡的非线性代数平衡模型，并构建和遍历一个从理想溶液近似到使用 Davies 方程的完整活度系数模型的同伦延拓。设未知量向量为 $\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$，其中 $m_i$ 表示摩尔浓度（单位为 $\\mathrm{mol/L}$），活度为 $a_i = \\gamma_i m_i$。\n\n基本原理：\n- 酸解离和水自偶电离的质量作用定律，使用活度：\n  - 碳酸的一级解离：$K_1 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{a_{\\mathrm{H}_2\\mathrm{CO}_3}}$。\n  - 二级解离：$K_2 = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}}}{a_{\\mathrm{HCO}_3^-}}$。\n  - 水的自偶电离：$K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$。\n- 电中性：对于所有带电物质 $i$，$\\sum z_i m_i = 0$，其中 $z_i$ 是物质 $i$ 的电荷。\n- 总无机碳质量平衡：$C_T = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}}$。\n- 离子强度定义：$I = \\dfrac{1}{2} \\sum_i m_i z_i^2$。\n- Davies 方程计算 $25^\\circ\\mathrm{C}$ 时离子的活度系数：$\\log_{10} \\gamma_i = -A z_i^2\\left( \\dfrac{\\sqrt{I}}{1+\\sqrt{I}} - 0.3 I \\right)$，其中 $A = 0.509$。中性物质的活度系数取 $\\gamma=1$。\n\n设钠和氯化物的已知总量分别为 $N_T$ 和 $Cl_T$，并假设它们仅以 $\\mathrm{Na}^+$ 和 $\\mathrm{Cl}^-$ 的形式存在。$25^\\circ\\mathrm{C}$ 时的常数为 $K_1 = 10^{-6.3}$、$K_2 = 10^{-10.3}$ 和 $K_w = 10^{-14}$。\n\n定义一个同伦 $H(\\ell,t) = F_t(\\ell)$，其中 $t \\in [0,1]$ 控制活度效应的包含程度。具体来说，根据当前浓度计算离子强度 $I(\\ell)$，并在 Davies 方程中使用一个缩放后的离子强度 $I_t(\\ell) = t\\, I(\\ell)$ 来获得 $\\gamma_i(t)$，这样所有离子的 $\\gamma_i(0)=1$（理想溶液），而 $\\gamma_i(1)$ 是完整的 Davies 值。将 $F_t(\\ell)=0$ 构建为以下方程组：\n- 碳质量平衡：\n  $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T,$$\n  其中 $m_{\\mathrm{H}_2\\mathrm{CO}_3} = \\dfrac{a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}}{K_1}$，$a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(t) m_{\\mathrm{H}^+}$，$a_{\\mathrm{HCO}_3^-} = \\gamma_{\\mathrm{HCO}_3^-}(t) m_{\\mathrm{HCO}_3^-}$，且 $\\gamma_{\\mathrm{H}_2\\mathrm{CO}_3}=1$。\n- 二级解离平衡：\n  $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-},$$\n  其中 $a_{\\mathrm{CO}_3^{2-}} = \\gamma_{\\mathrm{CO}_3^{2-}}(t) m_{\\mathrm{CO}_3^{2-}}$。\n- 电中性：\n  $$F_{t,3}(\\ell) = N_T + m_{\\mathrm{H}^+} - \\left(Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}} \\right),$$\n  其中 $m_{\\mathrm{OH}^-}$ 由 $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ 隐式确定为 $m_{\\mathrm{OH}^-} = \\dfrac{K_w}{a_{\\mathrm{H}^+}\\, \\gamma_{\\mathrm{OH}^-}(t)}$。\n\n任务是：\n1. 实现一个以 $\\ell$ 为变量、带有数值雅可比矩阵的牛顿法，用于在固定的 $t$ 值下求解 $F_t(\\ell)=0$，并采用线搜索来稳健地减小残差。\n2. 实现一个同伦延拓策略，从 $t=0$（理想溶液）开始，将 $t$ 推进到 $t=1$，使用自适应步长 $\\Delta t$ 选择来保持牛顿法的收敛性。将上一步 $t$ 的解作为 $t+\\Delta t$ 的初始猜测。如果牛顿法在几次迭代内收敛，则增加 $\\Delta t$；如果收敛缓慢或失败，则减小 $\\Delta t$ 并重试。\n3. 对于每个测试用例，计算在 $t=1$ 时氢离子活度的负常用对数，$pH = -\\log_{10}\\left(a_{\\mathrm{H}^+}\\right)$。\n\n测试用例：\n- 情况 A（一般情况）：$C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$，$N_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$，$Cl_T = 1.0\\times 10^{-2}\\ \\mathrm{mol/L}$。\n- 情况 B（高离子强度）：$C_T = 2.0\\times 10^{-3}\\ \\mathrm{mol/L}$，$N_T = 0.5\\ \\mathrm{mol/L}$，$Cl_T = 0.5\\ \\mathrm{mol/L}$。\n- 情况 C（低碳边界）：$C_T = 1.0\\times 10^{-5}\\ \\mathrm{mol/L}$，$N_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$，$Cl_T = 1.0\\times 10^{-3}\\ \\mathrm{mol/L}$。\n\n答案规格：\n- 对于每个测试用例，输出 $t=1$ 时的最终 $pH$ 值，为浮点数，保留四位小数。$pH$ 是无量纲的。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，$[pH_A,pH_B,pH_C]$），并按上述测试用例的顺序列出。",
            "solution": "问题陈述被评估为有效。它在计算地球化学领域提出了一个适定且有科学依据的挑战，要求对代表化学平衡的非线性代数方程组进行数值求解。该问题是自洽的，所有必要的常数、方程和边界条件都已明确指定。使用同伦延拓方法是从简化的理想模型过渡到更复杂的非理想模型的合适且标准的技术。\n\n解决方案的实现首先是根据质量平衡、化学平衡和电荷平衡原理，构建三个非线性方程组成的方程组 $F_t(\\ell) = 0$。未知量向量 $\\ell$ 包含主要离子物质摩尔浓度的自然对数：$\\ell = (\\ln m_{\\mathrm{H}^+}, \\ln m_{\\mathrm{HCO}_3^-}, \\ln m_{\\mathrm{CO}_3^{2-}})$。使用对数作为变量是一种常见做法，它有助于提高数值稳定性，并自然地强制执行浓度为正的物理约束。\n\n方程组 $F_t(\\ell)=0$ 定义如下：\n1.  **碳质量平衡 ($F_{t,1}$):** 该方程确保所有溶解无机碳物质的浓度之和等于指定的总量 $C_T$。\n    $$F_{t,1}(\\ell) = m_{\\mathrm{H}_2\\mathrm{CO}_3} + m_{\\mathrm{HCO}_3^-} + m_{\\mathrm{CO}_3^{2-}} - C_T = 0$$\n    这里，$m_{\\mathrm{HCO}_3^-} = e^{\\ell_1}$ 和 $m_{\\mathrm{CO}_3^{2-}} = e^{\\ell_2}$。碳酸的浓度 $m_{\\mathrm{H}_2\\mathrm{CO}_3}$ 通过 $\\mathrm{H}_2\\mathrm{CO}_3$ 一级解离的质量作用定律表示：$m_{\\mathrm{H}_2\\mathrm{CO}_3} = (a_{\\mathrm{H}^+} a_{\\mathrm{HCO}_3^-}) / K_1$，其中活度为 $a_i = \\gamma_i m_i$。\n\n2.  **二级解离平衡 ($F_{t,2}$):** 该方程表示碳酸氢根解离为碳酸根的平衡。\n    $$F_{t,2}(\\ell) = a_{\\mathrm{H}^+} a_{\\mathrm{CO}_3^{2-}} - K_2 a_{\\mathrm{HCO}_3^-} = 0$$\n\n3.  **电中性 ($F_{t,3}$):** 该方程强制电荷平衡，即溶液中正电荷的总和必须等于负电荷的总和。\n    $$F_{t,3}(\\ell) = (N_T + m_{\\mathrm{H}^+}) - (Cl_T + m_{\\mathrm{OH}^-} + m_{\\mathrm{HCO}_3^-} + 2 m_{\\mathrm{CO}_3^{2-}}) = 0$$\n    氢氧根离子的浓度 $m_{\\mathrm{OH}^-}$ 由水的自偶电离常数 $K_w = a_{\\mathrm{H}^+} a_{\\mathrm{OH}^-}$ 决定。\n\n一个关键的复杂性在于，活度系数 $\\gamma_i$ 依赖于离子强度 $I = \\frac{1}{2} \\sum_i m_i z_i^2$，而离子强度又依赖于所有离子的浓度，包括 $m_{\\mathrm{OH}^-}$。这产生了一个隐式关系。这个挑战通过在每次函数 $F_t(\\ell)$ 求值中实现不动点迭代来解决。对于给定的 $\\ell$，这个迭代过程计算一组自洽的离子强度和活度系数。同伦参数 $t \\in [0,1]$ 对离子强度进行缩放，$I_t = t \\cdot I$，从而允许从理想溶液（$t=0$ 时 $\\gamma_i=1$）逐步过渡到完整的 Davies 模型（$t=1$）。Davies 方程由 $\\log_{10} \\gamma_i = -A z_i^2\\left( \\frac{\\sqrt{I_t}}{1+\\sqrt{I_t}} - 0.3 I_t \\right)$ 给出。\n\n方程组 $F_t(\\ell)=0$ 使用一个稳健的牛顿-拉弗森方法求解。迭代更新规则为 $\\ell_{k+1} = \\ell_k - \\lambda J_k^{-1} F_t(\\ell_k)$。雅可比矩阵 $J_k$ 包含了 $F_t$ 相对于 $\\ell$ 各分量的偏导数，它是通过有限差分格式进行数值计算的。为确保稳健收敛，采用回溯线搜索来寻找一个合适的步长 $\\lambda \\in (0,1]$，以保证残差向量的范数 $\\|F_t\\|$ 有足够的下降。\n\n同伦延拓方法协调整个求解过程。它首先使用一个初始化学猜测值求解理想情况（$t=0$）下的系统。然后，在某一步 $t_i$ 的解被用作牛顿求解器在下一步 $t_{i+1} = t_i + \\Delta t$ 的初始猜测值。步长 $\\Delta t$ 根据牛顿求解器的性能进行自适应调整：如果收敛快，则增大步长；如果收敛慢或失败，则减小步长，以确保从 $t=0$ 到 $t=1$ 的路径跟踪是稳定的。\n\n在成功延拓到 $t=1$ 后，获得最终向量 $\\ell_{final}$。氢离子活度计算为 $a_{\\mathrm{H}^+} = \\gamma_{\\mathrm{H}^+}(1) \\cdot e^{\\ell_{final,0}}$，由此确定最终的 pH 值：$pH = -\\log_{10}(a_{\\mathrm{H}^+})$。将此过程应用于每个测试用例以生成所需的结果。",
            "answer": "```python\nimport numpy as np\nfrom numpy.linalg import norm, solve as linsolve\n\ndef solve():\n    \"\"\"\n    Main solver function that encapsulates the entire logic as per the problem specification.\n    \"\"\"\n\n    # --- Start of self-contained definitions ---\n\n    # Constants\n    K1 = 10**-6.3\n    K2 = 10**-10.3\n    KW = 10**-14.0\n    A_DAVIES = 0.509\n    \n    def compute_auxiliary_vars(l, t, N_T, Cl_T):\n        \"\"\"\n        Computes self-consistent ionic strength, activity coefficients, and\n        concentrations of dependent species (m_OH, m_H2CO3) for a given state (l, t).\n        \"\"\"\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        # Fixed-point iteration for ionic strength I\n        I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + N_T + Cl_T)\n\n        for _ in range(10): # 10 iterations typically suffice for convergence\n            I_scaled = t * I\n            \n            if I_scaled  1e-15: # Ideal solution or very low I\n                gamma_H = 1.0\n                gamma_OH = 1.0\n                gamma_HCO3 = 1.0\n                gamma_CO3 = 1.0\n            else:\n                sqrt_I_scaled = np.sqrt(I_scaled)\n                davies_term = (sqrt_I_scaled / (1.0 + sqrt_I_scaled)) - 0.3 * I_scaled\n                \n                log10_gamma_H = -A_DAVIES * (1**2) * davies_term\n                log10_gamma_CO3 = -A_DAVIES * (-2**2) * davies_term\n                \n                gamma_H = 10**log10_gamma_H\n                gamma_OH = gamma_H  # z^2 = (-1)^2 = 1^2\n                gamma_HCO3 = gamma_H # z^2 = (-1)^2 = 1^2\n                gamma_CO3 = 10**log10_gamma_CO3\n            \n            denominator = gamma_H * m_H * gamma_OH\n            m_OH = KW / denominator if denominator > 1e-30 else 0.0\n\n            I = 0.5 * (m_H + m_HCO3 + 4 * m_CO3 + m_OH + N_T + Cl_T)\n\n        gammas = {'H': gamma_H, 'OH': gamma_OH, 'HCO3': gamma_HCO3, 'CO3': gamma_CO3}\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        m_H2CO3 = (a_H * a_HCO3) / K1\n\n        return {'gammas': gammas, 'm_H2CO3': m_H2CO3, 'm_OH': m_OH}\n\n    def system_function(l, t, params):\n        \"\"\"\n        Computes the residual vector F(l, t) for the system of non-linear equations.\n        \"\"\"\n        C_T, N_T, Cl_T = params['C_T'], params['N_T'], params['Cl_T']\n        \n        aux = compute_auxiliary_vars(l, t, N_T, Cl_T)\n        gammas, m_H2CO3, m_OH = aux['gammas'], aux['m_H2CO3'], aux['m_OH']\n\n        m_H = np.exp(l[0])\n        m_HCO3 = np.exp(l[1])\n        m_CO3 = np.exp(l[2])\n\n        F1 = m_H2CO3 + m_HCO3 + m_CO3 - C_T\n        \n        a_H = gammas['H'] * m_H\n        a_HCO3 = gammas['HCO3'] * m_HCO3\n        a_CO3 = gammas['CO3'] * m_CO3\n        F2 = a_H * a_CO3 - K2 * a_HCO3\n        \n        F3 = (N_T + m_H) - (Cl_T + m_OH + m_HCO3 + 2 * m_CO3)\n        \n        return np.array([F1, F2, F3])\n\n    def numerical_jacobian(F_func, l, t, params):\n        \"\"\"\n        Computes the Jacobian matrix of F_func w.r.t. l using finite differences.\n        \"\"\"\n        f0 = F_func(l, t, params)\n        n = len(l)\n        J = np.zeros((n, n))\n        h = 1e-8\n        \n        for j in range(n):\n            l_plus_h = l.copy()\n            l_plus_h[j] += h\n            f_plus_h = F_func(l_plus_h, t, params)\n            J[:, j] = (f_plus_h - f0) / h\n            \n        return J\n\n    def newton_solver(F_func, l_guess, t, params, tol=1e-10, max_iter=25):\n        \"\"\"\n        Solves F(l) = 0 using Newton's method with a backtracking line search.\n        \"\"\"\n        l = l_guess.copy()\n        alpha = 1e-4\n        beta = 0.5\n        \n        for i in range(max_iter):\n            F_val = F_func(l, t, params)\n            norm_F = norm(F_val)\n\n            if norm_F  tol:\n                return l, True, i + 1\n\n            J_val = numerical_jacobian(F_func, l, t, params)\n            \n            try:\n                delta_l = linsolve(J_val, -F_val)\n            except np.linalg.LinAlgError:\n                return l, False, i + 1\n\n            lambda_step = 1.0\n            for _ in range(10): # Max 10 backtracking steps\n                l_new = l + lambda_step * delta_l\n                F_new_norm = norm(F_func(l_new, t, params))\n                if F_new_norm  (1 - alpha * lambda_step) * norm_F:\n                    break\n                lambda_step *= beta\n            else: # No suitable step found\n                return l, False, i + 1\n            \n            l = l_new\n\n        return l, norm(F_func(l, t, params))  tol, max_iter\n\n    def solve_case(params):\n        \"\"\"\n        Performs homotopy continuation to solve the geochemical system for a given case.\n        \"\"\"\n        m_H_guess = 1e-7\n        m_HCO3_guess = params['C_T']\n        m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess > 0 else 1e-10\n        l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n\n        t = 0.0\n        dt, min_dt, max_dt = 0.05, 1e-5, 0.2\n        \n        l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n        if not converged:\n            m_H_guess = 1e-4\n            m_HCO3_guess = K1 * params['C_T'] / m_H_guess if m_H_guess > 0 else 1e-5\n            m_CO3_guess = K2 * m_HCO3_guess / m_H_guess if m_H_guess > 0 else 1e-10\n            l_guess = np.log(np.array([m_H_guess, m_HCO3_guess, m_CO3_guess]))\n            l_current, converged, _ = newton_solver(system_function, l_guess, t, params)\n            if not converged:\n                raise RuntimeError(\"Initial solver failed for t=0\")\n\n        while t  1.0:\n            t_next = min(1.0, t + dt)\n            l_next, converged, iters = newton_solver(system_function, l_current, t_next, params)\n\n            if converged:\n                l_current, t = l_next, t_next\n                if iters  4: dt = min(dt * 1.5, max_dt)\n            else:\n                dt *= 0.5\n                if dt  min_dt: raise RuntimeError(f\"Homotopy failed at t={t}\")\n        \n        l_final = l_current\n        m_H_final = np.exp(l_final[0])\n        gamma_H_final = compute_auxiliary_vars(l_final, 1.0, params['N_T'], params['Cl_T'])['gammas']['H']\n        a_H_final = gamma_H_final * m_H_final\n        return -np.log10(a_H_final)\n\n    # --- End of self-contained definitions ---\n\n    test_cases = [\n        {'C_T': 2.0e-3, 'N_T': 1.0e-2, 'Cl_T': 1.0e-2}, # Case A\n        {'C_T': 2.0e-3, 'N_T': 0.5, 'Cl_T': 0.5},       # Case B\n        {'C_T': 1.0e-5, 'N_T': 1.0e-3, 'Cl_T': 1.0e-3}, # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        pH_final = solve_case(params)\n        results.append(f\"{pH_final:.4f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```"
        }
    ]
}