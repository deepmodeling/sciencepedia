{
    "hands_on_practices": [
        {
            "introduction": "Accurately simulating the movement of solutes is a cornerstone of computational geochemistry. This first practice  delves into the numerical treatment of pure advection, the simplest form of transport. By analyzing and implementing both a centered-difference scheme and an upwind scheme, you will discover firsthand why seemingly intuitive methods can fail and learn the principles behind constructing stable, physically meaningful numerical solutions.",
            "id": "4079372",
            "problem": "Consider the one-dimensional conservative transport of a nonreactive, nondecaying, dissolved tracer in a saturated, homogeneous porous medium with constant advective velocity. The governing statement of conservation of mass for the dissolved concentration is the linear advection (or pure transport) equation\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\nwhere $u(x,t)$ is the dimensionless concentration and $a$ is a constant velocity in units of length per time.\n\nYour tasks are as follows.\n\n1) Starting from the notion of local conservation and a uniform grid with spacing $\\Delta x$ and time increment $\\Delta t$, construct a finite-difference scheme that uses a centered difference for the spatial derivative and a forward difference for the time derivative. Perform a Fourier mode (von Neumann) stability analysis of this scheme to determine the amplification factor as a function of the nondimensional wavenumber and the Courant number $r = |a| \\Delta t / \\Delta x$. Use this analysis to explain from first principles why centered differencing for advection can generate oscillations in the numerical solution.\n\n2) Starting from the same conservation statement and grid, construct a first-order upwind discretization based on choosing the numerical flux consistent with the upstream state. Derive the explicit update formula for both $a > 0$ and $a < 0$. Prove a sufficient condition for monotonicity by showing that the update can be written as a convex combination of neighboring values and identifying the corresponding condition on the Courant number $r$.\n\n3) Implement both schemes on a periodic domain of length $L = 1$ using $N$ uniformly spaced points with spacing $\\Delta x = L/N$. Use the piecewise-constant initial condition\n$$\nu(x,0) =\n\\begin{cases}\n1, & x \\in [0.2, 0.4),\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\ninterpreted with periodicity on $[0,1)$ so that the interval $[0.2,0.4)$ wraps within the domain as usual. For each test case below, compute a single explicit time step $\\Delta t = r \\Delta x / |a|$. Impose periodic boundary conditions.\n\nFor each test case, compute the following three diagnostics after one time step for each scheme:\n- A boolean $B_{\\mathrm{FTCS}}$ that is true if any nodal value from the centered scheme lies outside the closed interval $[0,1]$, and false otherwise.\n- A boolean $B_{\\mathrm{UP}}$ that is true if any nodal value from the upwind scheme lies outside the closed interval $[0,1]$, and false otherwise.\n- A float $\\rho_{\\mathrm{TV}}$ defined as the ratio of total variation after one upwind step to the initial total variation, where the total variation for a periodic grid function $v_i$ is\n$$\nTV(v) = \\sum_{i=0}^{N-1} \\left| v_{i+1} - v_{i} \\right|,\n$$\nwith periodic indexing $v_{N} \\equiv v_{0}$. Report $\\rho_{\\mathrm{TV}}$ rounded to $6$ decimal places.\n\nTest suite (all cases use $L = 1$ and the initial condition above):\n- Case A: $N = 200$, $a = +1$, $r = 0.5$.\n- Case B: $N = 200$, $a = +1$, $r = 1.0$.\n- Case C: $N = 200$, $a = +1$, $r = 1.2$.\n- Case D: $N = 200$, $a = -1$, $r = 0.8$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of four inner lists, one per test case, in the same order as listed above. Each inner list must have the form $[B_{\\mathrm{FTCS}}, B_{\\mathrm{UP}}, \\rho_{\\mathrm{TV}}]$, where booleans are written as $True$ or $False$ and $\\rho_{\\mathrm{TV}}$ is printed with exactly $6$ digits after the decimal point. For example,\n$$\n\\left[\\,[True,False,0.875000],[\\dots],\\dots\\,\\right].\n$$",
            "solution": "The problem presents a set of tasks related to the numerical solution of the one-dimensional linear advection equation, a foundational model in computational geochemistry for conservative transport. The tasks are to derive and analyze two common finite-difference schemes—the forward-time, centered-space (FTCS) scheme and the first-order upwind scheme—and then to implement them to compute specific diagnostics for a given set of test cases. Each task will be addressed sequentially.\n\n### 1. FTCS Scheme: Derivation and Stability Analysis\n\nThe governing partial differential equation (PDE) is the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the concentration and $a$ is the constant advective velocity.\n\nTo construct the requested finite-difference scheme, we discretize the domain with a uniform spatial grid of spacing $\\Delta x$ and time increments of $\\Delta t$. Let $u_i^n \\approx u(i\\Delta x, n\\Delta t)$. The time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a forward difference:\n$$\n\\left. \\frac{\\partial u}{\\partial t} \\right|_{i,n} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe spatial derivative $\\frac{\\partial u}{\\partial x}$ is approximated using a centered difference:\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_{i,n} \\approx \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x}\n$$\nSubstituting these approximations into the PDE yields:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x} = 0\n$$\nSolving for the value at the new time step, $u_i^{n+1}$, gives the explicit update formula for the FTCS scheme:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{2 \\Delta x} (u_{i+1}^n - u_{i-1}^n)\n$$\nLet us define a modified Courant number $r' = \\frac{a \\Delta t}{\\Delta x}$. The problem defines the Courant number as $r = \\frac{|a| \\Delta t}{\\Delta x}$, so $r' = \\text{sign}(a) r$. The scheme is:\n$$\nu_i^{n+1} = u_i^n - \\frac{r'}{2} (u_{i+1}^n - u_{i-1}^n)\n$$\nTo perform a von Neumann stability analysis, we examine the behavior of a single Fourier mode of the form $u_i^n = G^n e^{jki\\Delta x}$, where $G$ is the complex amplification factor, $k$ is the wavenumber, and $j=\\sqrt{-1}$. Substituting this into the difference equation:\n$$\nG^{n+1} e^{jki\\Delta x} = G^n e^{jki\\Delta x} - \\frac{r'}{2} \\left( G^n e^{jk(i+1)\\Delta x} - G^n e^{jk(i-1)\\Delta x} \\right)\n$$\nDividing by $G^n e^{jki\\Delta x}$ isolates the amplification factor $G$:\n$$\nG = 1 - \\frac{r'}{2} \\left( e^{jk\\Delta x} - e^{-jk\\Delta x} \\right)\n$$\nUsing Euler's identity, $e^{j\\theta} - e^{-j\\theta} = 2j \\sin(\\theta)$, with $\\theta = k\\Delta x$, we get:\n$$\nG = 1 - \\frac{r'}{2} (2j \\sin(k\\Delta x)) = 1 - j r' \\sin(k\\Delta x)\n$$\nFor a scheme to be stable, the magnitude of the amplification factor must satisfy $|G| \\leq 1$ for all wavenumbers. The squared magnitude of $G$ is:\n$$\n|G|^2 = (\\text{Re}(G))^2 + (\\text{Im}(G))^2 = 1^2 + (-r' \\sin(k\\Delta x))^2 = 1 + (r' \\sin(k\\Delta x))^2\n$$\nSubstituting $r' = \\text{sign}(a) r$, we have $(r')^2 = r^2$. Thus:\n$$\n|G|^2 = 1 + r^2 \\sin^2(k\\Delta x)\n$$\nFor any non-zero Courant number $r>0$ and any wavenumber $k$ such that $\\sin(k\\Delta x) \\neq 0$, the term $r^2 \\sin^2(k\\Delta x)$ is strictly positive. Consequently, $|G|^2 > 1$, which implies $|G| > 1$. The scheme amplifies certain Fourier modes at every time step, making it **unconditionally unstable** for the linear advection equation.\n\nThis instability manifests as spurious oscillations. A more direct explanation for why the scheme can generate oscillations (i.e., new extrema not present in the initial data) is that the update formula is not a convex combination of neighboring values. Rewriting the scheme:\n$$\nu_i^{n+1} = \\left(\\frac{r'}{2}\\right) u_{i-1}^n + (1) u_i^n + \\left(-\\frac{r'}{2}\\right) u_{i+1}^n\n$$\nFor this to be a convex combination, all coefficients must be non-negative. However, if $r' > 0$ (i.e., $a>0$), the coefficient of $u_{i+1}^n$ is negative. If $r' < 0$ (i.e., $a<0$), the coefficient of $u_{i-1}^n$ is negative. Since one of the stencil coefficients is always negative, the scheme does not satisfy a discrete maximum principle. As a result, the value $u_i^{n+1}$ can be outside the range $[\\min(u_{i-1}^n, u_i^n, u_{i+1}^n), \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)]$, leading to the creation of unphysical oscillations (undershoots and overshoots).\n\n### 2. First-Order Upwind Scheme: Derivation and Monotonicity\n\nThe upwind scheme is derived from a finite volume perspective. Integrating the conservative form of the equation, $\\frac{\\partial u}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0$ where $F=au$ is the flux, over a cell $[x_{i-1/2}, x_{i+1/2}] \\times [t_n, t_{n+1}]$ gives:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nThe upwind principle dictates that the flux at a cell interface, e.g., $F_{i+1/2}$, is determined by the state in the \"upwind\" cell, i.e., the cell from which information is flowing.\n$$\nF_{i+1/2} = \\begin{cases} a u_i^n, & \\text{if } a > 0 \\\\ a u_{i+1}^n, & \\text{if } a < 0 \\end{cases}\n$$\nThis leads to two distinct update formulas depending on the sign of $a$.\n\n**Case 1: $a > 0$** (Flow is to the right)\nThe fluxes are $F_{i+1/2} = a u_i^n$ and $F_{i-1/2} = a u_{i-1}^n$. Substituting into the finite volume formula:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_i^n - a u_{i-1}^n)\n$$\nUsing the Courant number $r = \\frac{a \\Delta t}{\\Delta x}$ (since $a>0$, $|a|=a$):\n$$\nu_i^{n+1} = u_i^n - r(u_i^n - u_{i-1}^n) = (1-r)u_i^n + r u_{i-1}^n\n$$\n\n**Case 2: $a < 0$** (Flow is to the left)\nThe fluxes are $F_{i+1/2} = a u_{i+1}^n$ and $F_{i-1/2} = a u_i^n$. Substituting gives:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_{i+1}^n - a u_i^n)\n$$\nUsing the Courant number $r = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which implies $\\frac{a \\Delta t}{\\Delta x} = -r$:\n$$\nu_i^{n+1} = u_i^n - (-r)(u_{i+1}^n - u_i^n) = (1-r)u_i^n + r u_{i+1}^n\n$$\n\nTo prove a sufficient condition for monotonicity, we show that the update is a convex combination of neighboring values.\nIn both cases ($a>0$ and $a<0$), the update has the form $u_i^{n+1} = (1-r)u_i^n + r u_k^n$, where $u_k^n$ is an adjacent cell value ($u_{i-1}^n$ or $u_{i+1}^n$).\nFor this to be a convex combination, two conditions must be met:\n1. The sum of the coefficients must be $1$: $(1-r) + r = 1$. This is always true.\n2. All coefficients must be non-negative. By definition, $r = \\frac{|a| \\Delta t}{\\Delta x} \\ge 0$. The second condition is $1-r \\ge 0$, which implies $r \\le 1$.\n\nTherefore, a sufficient condition for the first-order upwind scheme to be monotone is $0 \\le r \\le 1$. This is the Courant-Friedrichs-Lewy (CFL) condition for this scheme. If satisfied, $u_i^{n+1}$ is a weighted average of two values from the previous time step, ensuring that its value lies between those two values and preventing the formation of new extrema.\n\n### 3. Numerical Implementation\n\nThe implementation involves discretizing the periodic domain $[0,1)$ into $N$ grid points $x_i = i(L/N)$ for $i=0, \\dots, N-1$. The piecewise-constant initial condition is mapped onto this grid. For each test case, a single time step of size $\\Delta t = r \\Delta x / |a|$ is computed using both the FTCS and upwind schemes derived above. Periodic boundary conditions are handled by using array-rolling operations, which naturally implement the required wraparound indexing. After the time step, the three diagnostics are computed:\n- $B_{\\mathrm{FTCS}}$: A boolean indicating if any value in the FTCS solution lies outside the initial range of $[0,1]$.\n- $B_{\\mathrm{UP}}$: A boolean indicating if any value in the upwind solution lies outside the initial range of $[0,1]$. For $r \\le 1$, this is expected to be false due to monotonicity. For $r > 1$, it may be true.\n- $\\rho_{\\mathrm{TV}}$: The ratio of the total variation of the upwind solution to the initial total variation. The total variation for a periodic grid function $v_i$ is $TV(v) = \\sum_{i=0}^{N-1} |v_{i+1} - v_i|$, with $v_N \\equiv v_0$. For the given boxcar initial condition, the total variation is $TV(u(x,0)) = |1-0| + |0-1| = 2$.\nThe code in the final answer will perform these calculations for all specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem using FTCS and Upwind schemes\n    for a suite of test cases and computes specified diagnostics.\n    \"\"\"\n    test_cases = [\n        # (N, a, r)\n        (200, 1.0, 0.5),  # Case A\n        (200, 1.0, 1.0),  # Case B\n        (200, 1.0, 1.2),  # Case C\n        (200, -1.0, 0.8), # Case D\n    ]\n\n    all_results = []\n\n    for N, a, r in test_cases:\n        # Domain and Grid Setup\n        L = 1.0\n        dx = L / N\n        dt = r * dx / abs(a)\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initial Condition: Piecewise-constant (boxcar) function\n        u0 = np.zeros(N)\n        u0[(x >= 0.2) & (x < 0.4)] = 1.0\n\n        # --- Scheme Implementations for one time step ---\n\n        # 1. FTCS (Forward-Time, Centered-Space) Scheme\n        # u_i^{n+1} = u_i^n - (a*dt / (2*dx)) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev = np.roll(u0, 1)   # u_{i-1}\n        u_next = np.roll(u0, -1)  # u_{i+1}\n        u_ftcs = u0 - (a * dt / (2.0 * dx)) * (u_next - u_prev)\n        \n        # 2. First-Order Upwind Scheme\n        u_upwind = np.zeros(N)\n        if a > 0:\n            # u_i^{n+1} = u_i^n - r * (u_i^n - u_{i-1}^n)\n            u_prev = np.roll(u0, 1)\n            u_upwind = u0 - r * (u0 - u_prev)\n        else: # a < 0\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - u_i^n)\n            u_next = np.roll(u0, -1)\n            u_upwind = u0 + r * (u_next - u0)\n\n        # --- Diagnostic Calculations ---\n\n        # B_FTCS: Boolean check for oscillations in FTCS solution\n        # The problem asks if any value lies outside [0,1].\n        # Floating point precision requires a small tolerance for comparison.\n        # However, the problem text implies a strict check, so we avoid tolerance.\n        B_ftcs = np.any((u_ftcs < 0.0) | (u_ftcs > 1.0))\n\n        # B_UP: Boolean check for oscillations in Upwind solution\n        B_up = np.any((u_upwind < 0.0) | (u_upwind > 1.0))\n\n        # rho_TV: Ratio of Total Variation for the upwind scheme\n        def calculate_tv(v):\n            return np.sum(np.abs(np.roll(v, -1) - v))\n\n        tv_initial = calculate_tv(u0)\n        tv_upwind = calculate_tv(u_upwind)\n        \n        rho_tv = tv_upwind / tv_initial if tv_initial > 0 else 0.0\n\n        # Assemble the results for the current case\n        case_result_str = f\"[{str(B_ftcs)},{str(B_up)},{rho_tv:.6f}]\"\n        all_results.append(case_result_str)\n\n    # Format the final output string as a list of lists representation\n    final_output = f\"[{','.join(all_results)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Geochemical systems are often characterized by reactions that proceed at vastly different rates, from geological timescales to near-instantaneous. This disparity gives rise to a numerical challenge known as stiffness. This exercise  guides you through a stability analysis of the explicit Euler method to reveal why it is unsuitable for stiff kinetic systems, providing the fundamental justification for using more advanced implicit solvers in reactive transport modeling.",
            "id": "4079418",
            "problem": "In reactive transport modeling in computational geochemistry, dissolution-precipitation kinetics couple with transport to control aqueous concentrations. Consider a single grid cell treated by operator splitting during the reaction step, so that the local chemistry is advanced in time without advection or diffusion. Let $c(t)$ denote the concentration of an aqueous species involved in a dissolution-precipitation process with a smooth kinetic source term $S(c)$ that drives the system toward a chemical equilibrium $c^{\\ast}$ satisfying $S(c^{\\ast})=0$. Assume isothermal conditions, constant porosity, and that mass conservation gives the ordinary differential equation (ODE) $dc/dt=S(c)$. Near $c^{\\ast}$, the linearization of the kinetics yields $S(c)\\approx S(c^{\\ast})+S^{\\prime}(c^{\\ast})(c-c^{\\ast})$, so that the perturbation $\\delta c(t)=c(t)-c^{\\ast}$ obeys an approximately linear ODE whose stability is governed by the sign and magnitude of $S^{\\prime}(c^{\\ast})$. In multi-species systems with vector state $\\mathbf{c}(t)\\in\\mathbb{R}^{m}$, mass conservation and smooth kinetics $\\mathbf{S}(\\mathbf{c})$ linearized about a steady state $\\mathbf{c}^{\\ast}$ with $\\mathbf{S}(\\mathbf{c}^{\\ast})=\\mathbf{0}$ lead to $d\\boldsymbol{\\delta c}/dt=\\mathbf{J}\\boldsymbol{\\delta c}$, where $\\mathbf{J}=\\partial \\mathbf{S}/\\partial \\mathbf{c}|_{\\mathbf{c}^{\\ast}}$ is the Jacobian matrix. In many geochemical systems, dissolution-precipitation kinetics produce stiffness, meaning that the eigenvalues of $\\mathbf{J}$ can have large negative real parts compared to the slow transport time scales.\n\nAn explicit Euler time discretization is sometimes applied to the reaction step: in the scalar case, $c^{n+1}=c^{n}+\\Delta t\\,S(c^{n})$; in the linearized multi-species case, $\\boldsymbol{\\delta c}^{\\,n+1}=(\\mathbf{I}+\\Delta t\\,\\mathbf{J})\\,\\boldsymbol{\\delta c}^{\\,n}$, where $\\Delta t$ is the time step and $\\mathbf{I}$ is the identity matrix. Using only fundamental principles of mass conservation, smoothness of the rate law, and linear stability analysis of the linearized system, explain why explicit Euler becomes unstable in the presence of stiff dissolution-precipitation kinetics and derive the condition on $\\Delta t$ that guarantees linear stability in the scalar case and in the general multi-species case.\n\nChoose all statements that are correct:\n\nA. In the scalar linearized case $d\\delta c/dt=\\lambda\\,\\delta c$ with $\\lambda=S^{\\prime}(c^{\\ast})<0$, explicit Euler is linearly stable if and only if $|1+\\Delta t\\,\\lambda|<1$, which for real $\\lambda<0$ is equivalent to $0<\\Delta t<\\dfrac{2}{|\\lambda|}$. For $\\Delta t$ exceeding this bound, the numerical solution oscillates and diverges.\n\nB. For any scalar $\\lambda<0$, explicit Euler is unconditionally stable for all $\\Delta t>0$ because the exact solution decays, hence the numerical solution must also decay.\n\nC. In the linearized multi-species case $d\\boldsymbol{\\delta c}/dt=\\mathbf{J}\\,\\boldsymbol{\\delta c}$, explicit Euler is linearly stable if and only if every eigenvalue $\\lambda_{i}$ of $\\mathbf{J}$ satisfies $|1+\\Delta t\\,\\lambda_{i}|<1$, equivalently the spectral radius condition $\\rho(\\mathbf{I}+\\Delta t\\,\\mathbf{J})<1$; geometrically, $\\Delta t\\,\\lambda_{i}$ must lie strictly inside the open disk in the complex plane centered at $-1$ with radius $1$.\n\nD. When reaction is coupled to transport, the only relevant restriction on $\\Delta t$ is the Courant–Friedrichs–Lewy (CFL) condition from advection, $\\Delta t\\leq \\Delta x/|u|$, so stiff dissolution-precipitation kinetics do not impose any additional stability restriction on explicit Euler.\n\nE. The instability of explicit Euler for stiff dissolution-precipitation kinetics is caused primarily by round-off errors; with exact arithmetic, explicit Euler would be stable for large $\\Delta t$ even if the kinetics are stiff.",
            "solution": "The problem statement is a valid and well-posed question in the field of numerical analysis applied to computational geochemistry. It presents a standard scenario of operator splitting in reactive transport models, where the chemical reaction step can introduce stiffness, and asks for an analysis of the stability of the explicit Euler method. All terms are standard and the premises are scientifically sound.\n\nThe problem asks for an explanation of the instability mechanism and a derivation of the stability conditions for a stiff ordinary differential equation (ODE) system discretized with the explicit Euler method.\n\nLet's begin with the general multi-species case, as the scalar case is a special instance of it. The linearized system for the perturbation from equilibrium, $\\boldsymbol{\\delta c}(t) = \\mathbf{c}(t) - \\mathbf{c}^{\\ast}$, is given by:\n$$\n\\frac{d\\boldsymbol{\\delta c}}{dt} = \\mathbf{J}\\boldsymbol{\\delta c}\n$$\nwhere $\\mathbf{J}$ is the Jacobian matrix of the kinetic source term $\\mathbf{S}(\\mathbf{c})$ evaluated at the equilibrium state $\\mathbf{c}^{\\ast}$. For the physical system to be stable (i.e., for perturbations to decay and the system to return to equilibrium), the real parts of all eigenvalues of $\\mathbf{J}$ must be non-positive. We assume a stable equilibrium, so $\\text{Re}(\\lambda_i) \\leq 0$ for all eigenvalues $\\lambda_i$ of $\\mathbf{J}$.\n\nThe explicit Euler method is used to discretize this ODE system:\n$$\n\\boldsymbol{\\delta c}^{\\,n+1} = \\boldsymbol{\\delta c}^{\\,n} + \\Delta t \\, (\\mathbf{J}\\boldsymbol{\\delta c}^{\\,n})\n$$\nFactoring out $\\boldsymbol{\\delta c}^{\\,n}$ on the right-hand side gives the iterative map:\n$$\n\\boldsymbol{\\delta c}^{\\,n+1} = (\\mathbf{I} + \\Delta t\\,\\mathbf{J})\\,\\boldsymbol{\\delta c}^{\\,n}\n$$\nwhere $\\mathbf{I}$ is the identity matrix and $\\Delta t$ is the time step. Let $\\mathbf{G} = \\mathbf{I} + \\Delta t\\,\\mathbf{J}$ be the amplification matrix. After $k$ steps, the solution is $\\boldsymbol{\\delta c}^{\\,k} = \\mathbf{G}^k \\boldsymbol{\\delta c}^{\\,0}$.\n\nFor the numerical solution to be stable (i.e., for $\\boldsymbol{\\delta c}^{\\,k} \\to \\mathbf{0}$ as $k \\to \\infty$ for any initial perturbation $\\boldsymbol{\\delta c}^{\\,0}$), the amplification matrix $\\mathbf{G}$ must be a \"contraction\". In linear algebra, this is equivalent to the condition that the spectral radius of $\\mathbf{G}$, denoted $\\rho(\\mathbf{G})$, must be strictly less than $1$.\n$$\n\\rho(\\mathbf{G}) < 1\n$$\nThe spectral radius is defined as the maximum of the absolute values of the eigenvalues of $\\mathbf{G}$. Let the eigenvalues of $\\mathbf{J}$ be $\\{\\lambda_i\\}$. Then the eigenvalues of $\\mathbf{G} = \\mathbf{I} + \\Delta t\\,\\mathbf{J}$ are $\\{1+\\Delta t\\,\\lambda_i\\}$.\nThe stability condition thus becomes:\n$$\n\\rho(\\mathbf{I} + \\Delta t\\,\\mathbf{J}) = \\max_{i} |1 + \\Delta t\\,\\lambda_i| < 1\n$$\nThis means the condition $|1 + \\Delta t\\,\\lambda_i| < 1$ must hold for *every* eigenvalue $\\lambda_i$ of the Jacobian $\\mathbf{J}$.\n\nGeometrically, this condition can be interpreted in the complex plane. If we let $z = \\Delta t\\,\\lambda_i$, the condition is $|1+z| < 1$, or $|z - (-1)| < 1$. This describes an open disk of radius $1$ centered at the point $-1+0i$ in the complex plane. Thus, for the explicit Euler method to be stable, all values of $\\Delta t\\,\\lambda_i$ (for all eigenvalues $\\lambda_i$ of $\\mathbf{J}$) must lie strictly inside this disk. This disk is the region of absolute stability for the explicit Euler method.\n\nStiffness in geochemical kinetics means that some of the reactions are very fast compared to others or to transport timescales. Mathematically, this translates to the Jacobian $\\mathbf{J}$ having at least one eigenvalue $\\lambda_s$ with a large-magnitude negative real part. Let $\\lambda_s = a+ib$ where $a = \\text{Re}(\\lambda_s) \\ll 0$. The stability condition requires that $\\Delta t\\,\\lambda_s$ lie in the stability disk. The leftmost point of this disk is at $-2$. So we must have $\\text{Re}(\\Delta t\\,\\lambda_s) > -2$, which means $\\Delta t \\cdot a > -2$. Since $a$ is negative, this implies $\\Delta t < -2/a = 2/|a| = 2/|\\text{Re}(\\lambda_s)|$.\nThis is the explanation for the instability: stiffness (large $|\\text{Re}(\\lambda_s)|$) imposes a very small upper limit on the time step $\\Delta t$ for a stable numerical integration. If a larger $\\Delta t$ is chosen, the amplification factor for the stiffest mode, $|1+\\Delta t\\,\\lambda_s|$, will exceed $1$, causing the corresponding component of the numerical solution to grow exponentially, leading to catastrophic instability.\n\nNow we can derive the condition for the scalar case. Here, the system is $d\\delta c/dt = \\lambda \\delta c$, where $\\lambda = S'(c^{\\ast})$. For a stable equilibrium, we must have $\\lambda < 0$. The explicit Euler update is $\\delta c^{n+1} = (1 + \\Delta t \\lambda) \\delta c^n$. The stability condition is simply that the magnitude of the scalar amplification factor is less than $1$:\n$$\n|1 + \\Delta t \\lambda| < 1\n$$\nSince $\\lambda$ is a real, negative number, this inequality is equivalent to:\n$$\n-1 < 1 + \\Delta t \\lambda < 1\n$$\nSubtracting $1$ from all parts gives:\n$$\n-2 < \\Delta t \\lambda < 0\n$$\nSince $\\Delta t > 0$ and we require $\\lambda < 0$ for physical stability, the right-hand inequality $\\Delta t \\lambda < 0$ is always satisfied. We focus on the left-hand inequality:\n$$\n-2 < \\Delta t \\lambda\n$$\nDividing by $\\lambda$ (which is negative, so we reverse the inequality sign):\n$$\n\\frac{-2}{\\lambda} > \\Delta t\n$$\nSince $\\lambda$ is negative, $-\\lambda = |\\lambda|$. The final stability condition is:\n$$\n0 < \\Delta t < \\frac{2}{|\\lambda|}\n$$\n\nWe now evaluate each option.\n\nA. In the scalar linearized case $d\\delta c/dt=\\lambda\\,\\delta c$ with $\\lambda=S^{\\prime}(c^{\\ast})<0$, explicit Euler is linearly stable if and only if $|1+\\Delta t\\,\\lambda|<1$, which for real $\\lambda<0$ is equivalent to $0<\\Delta t<\\dfrac{2}{|\\lambda|}$. For $\\Delta t$ exceeding this bound, the numerical solution oscillates and diverges.\nThis statement is perfectly aligned with our derivation. The stability condition $|1+\\Delta t\\,\\lambda|<1$ is correct. The derived bound $0<\\Delta t<2/|\\lambda|$ is correct. If this bound is exceeded, i.e., $\\Delta t > 2/|\\lambda|$, then $\\Delta t \\lambda < -2$, which means $1+\\Delta t \\lambda < -1$. The amplification factor is a real number with magnitude greater than $1$ and a negative sign. This will cause the numerical solution to alternate in sign (oscillate) and grow in magnitude (diverge) at each step.\n**Verdict: Correct.**\n\nB. For any scalar $\\lambda<0$, explicit Euler is unconditionally stable for all $\\Delta t>0$ because the exact solution decays, hence the numerical solution must also decay.\nThis is incorrect. As shown in the analysis for option A, the stability of explicit Euler is conditional on $\\Delta t$. The reasoning is fallacious; the stability of the analytical solution of an ODE does not guarantee the stability of its numerical approximation by a given method. The explicit Euler method is a well-known example of a conditionally stable method.\n**Verdict: Incorrect.**\n\nC. In the linearized multi-species case $d\\boldsymbol{\\delta c}/dt=\\mathbf{J}\\,\\boldsymbol{\\delta c}$, explicit Euler is linearly stable if and only if every eigenvalue $\\lambda_{i}$ of $\\mathbf{J}$ satisfies $|1+\\Delta t\\,\\lambda_{i}|<1$, equivalently the spectral radius condition $\\rho(\\mathbf{I}+\\Delta t\\,\\mathbf{J})<1$; geometrically, $\\Delta t\\,\\lambda_{i}$ must lie strictly inside the open disk in the complex plane centered at $-1$ with radius $1$.\nThis statement is a correct and complete description of the stability condition for the multi-species case. Our derivation showed that stability requires the spectral radius of the amplification matrix $\\mathbf{G} = \\mathbf{I}+\\Delta t\\,\\mathbf{J}$ to be less than $1$, which is equivalent to $|1+\\Delta t\\,\\lambda_i|<1$ for all eigenvalues $\\lambda_i$ of $\\mathbf{J}$. The geometric interpretation as an open disk of radius $1$ centered at $-1+0i$ is also correct.\n**Verdict: Correct.**\n\nD. When reaction is coupled to transport, the only relevant restriction on $\\Delta t$ is the Courant–Friedrichs–Lewy (CFL) condition from advection, $\\Delta t\\leq \\Delta x/|u|$, so stiff dissolution-precipitation kinetics do not impose any additional stability restriction on explicit Euler.\nThis is incorrect. When using operator splitting with explicit methods for both transport and reaction, the overall time step must satisfy the stability constraints of *all* sub-problems. In the presence of stiff kinetics, the reaction stability constraint, $\\Delta t < 2/|\\text{Re}(\\lambda_{max})|$, is often far more restrictive than the advective CFL condition. Stiff kinetics impose a severe additional restriction on $\\Delta t$ for explicit methods.\n**Verdict: Incorrect.**\n\nE. The instability of explicit Euler for stiff dissolution-precipitation kinetics is caused primarily by round-off errors; with exact arithmetic, explicit Euler would be stable for large $\\Delta t$ even if the kinetics are stiff.\nThis is incorrect. The instability is an inherent mathematical property of the algorithm, not an artifact of finite-precision arithmetic. The analysis of the amplification factor $|1+\\Delta t\\lambda|$ shows that it can be greater than $1$ for certain combinations of $\\Delta t$ and $\\lambda$. When this occurs, the numerical solution is guaranteed to grow, irrespective of round-off error. This is a manifestation of truncation error leading to an unstable discrete dynamical system.\n**Verdict: Incorrect.**",
            "answer": "$$\\boxed{AC}$$"
        },
        {
            "introduction": "Having explored the nuances of discretizing transport and reaction terms individually, this final practice  integrates these concepts into a complete solver for the time-dependent Advection-Diffusion-Reaction (ADR) equation. You will employ the Method of Manufactured Solutions, a rigorous verification technique used to confirm that a numerical model correctly solves the governing equations. This exercise provides essential hands-on experience in building a solver from the ground up and quantitatively assessing its accuracy.",
            "id": "4079440",
            "problem": "Consider one-dimensional solute transport in a saturated geochemical column modeled by the Advection–Diffusion–Reaction (ADR) Partial Differential Equation (PDE). Let $u(x,t)$ denote aqueous concentration in $\\mathrm{mol}\\,\\mathrm{m}^{-3}$, with spatial coordinate $x \\in [0,L]$ in $\\mathrm{m}$ and time $t \\in [0,T]$ in $\\mathrm{s}$. The ADR PDE is\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t),\n$$\nwhere $a$ is the advective velocity in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D$ is the diffusion (hydrodynamic dispersion) coefficient in $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k$ is a first-order reaction rate constant in $\\mathrm{s}^{-1}$, and $s(x,t)$ is a source term in $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$ representing external inputs.\n\nUsing the method of manufactured solutions, define the exact concentration field\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\big(2\\pi x/L\\big)\\,\\mathrm{e}^{-t} \\;+\\; \\tfrac{1}{2}\\,x\\,(L-x),\n$$\nwith domain length $L = 1$ $\\mathrm{m}$ and final time $T = 0.1$ $\\mathrm{s}$. Impose Dirichlet boundary conditions that match the manufactured solution, so that $u(0,t) = u_{\\mathrm{m}}(0,t)$ and $u(L,t) = u_{\\mathrm{m}}(L,t)$ for all $t \\in [0,T]$, and an initial condition $u(x,0) = u_{\\mathrm{m}}(x,0)$ for all $x \\in [0,L]$. Starting from the ADR definition above, derive the source term $s(x,t)$ that makes $u_{\\mathrm{m}}(x,t)$ an exact solution of the continuous ADR PDE for arbitrary constants $a$, $D$, and $k$.\n\nDiscretize the spatial domain by a uniform grid with $N$ interior points (so there are $N+2$ nodes including the boundaries), spacing $h = L/(N+1)$. Use an upwind finite difference for the first derivative $\\partial u/\\partial x$, a second-order central difference for the second derivative $\\partial^2 u/\\partial x^2$, and a forward Euler time integrator for $\\partial u/\\partial t$. Specifically, for a given sign of $a$, use the appropriate upwind one-sided difference. Let the time step $\\Delta t$ satisfy explicit stability conditions, taking\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right),\n$$\nwith the convention that terms with zero denominator are treated as $+\\infty$ in the minimum. Integrate from $t=0$ to $t=T$ by forward Euler using the manufactured source term $s(x,t)$ evaluated at the current time level, and enforce Dirichlet boundary values from $u_{\\mathrm{m}}(x,t)$ at every time step. After reaching $t=T$, compute the relative discrete $L^2$ error\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}},\n$$\nwhich is dimensionless. Using mesh refinements $N \\in \\{40, 80, 160\\}$, estimate the observed convergence rate\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)},\n$$\nwhere $h_j = L/(N_j+1)$ and $N_2=80$, $N_3=160$.\n\nTest Suite:\n- Set $\\mathrm{A}$ (diffusion-dominated): $a = 0.05$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-3}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{B}$ (advection-dominated, positive velocity): $a = 1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{C}$ (advection-dominated, negative velocity): $a = -1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{D}$ (reaction-dominated): $a = 0.01$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 5.0$ $\\mathrm{s}^{-1}$.\n\nYour program must:\n- Derive and implement the manufactured source $s(x,t)$ from the ADR PDE and $u_{\\mathrm{m}}(x,t)$.\n- For each parameter set $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, and $\\mathrm{D}$, compute the relative discrete $L^2$ errors $E_{h}$ for $N \\in \\{40,80,160\\}$ and then compute $p$ using the formula above.\n- Produce a single line of output containing the observed convergence rates for the four sets as a comma-separated list enclosed in square brackets, in the order $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, $\\mathrm{D}$, with each float rounded to three decimal places, for example $[p_A,p_B,p_C,p_D]$.\n\nAll outputs are dimensionless and must be reported as floats. Angles are not involved. No percentages are involved.",
            "solution": "The user-provided problem is a well-posed exercise in computational science, specifically the numerical solution of a partial differential equation (PDE) using the method of manufactured solutions for code verification. The problem is scientifically grounded, self-contained, and all parameters and methods are clearly defined. It will be solved by first deriving the necessary source term, then developing a numerical model based on the specified finite difference scheme, and finally using this model to compute the empirical convergence rate for several physical scenarios.\n\n### 1. Derivation of the Manufactured Source Term\n\nThe problem is governed by the Advection–Diffusion–Reaction (ADR) equation:\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t)\n$$\nThe source term $s(x,t)$ must be chosen such that the manufactured solution, $u_{\\mathrm{m}}(x,t)$, is an exact solution to this PDE. We can find $s(x,t)$ by rearranging the ADR equation and substituting $u_{\\mathrm{m}}(x,t)$:\n$$\ns(x,t) = \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} + a\\,\\frac{\\partial u_{\\mathrm{m}}}{\\partial x} - D\\,\\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} + k\\,u_{\\mathrm{m}}\n$$\nThe manufactured solution is given as:\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} \\;+\\; \\frac{1}{2}\\,x\\,(L-x)\n$$\nTo find $s(x,t)$, we first compute the necessary partial derivatives of $u_{\\mathrm{m}}(x,t)$:\n\\begin{itemize}\n    \\item Time derivative:\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} = -\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\n    $$\n    \\item First spatial derivative:\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial x} = \\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\n    $$\n    \\item Second spatial derivative:\n    $$\n    \\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} = -\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\n    $$\n\\end{itemize}\nSubstituting these expressions into the equation for $s(x,t)$:\n$$\ns(x,t) = \\left[-\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\\right] + a\\left[\\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\\right] - D\\left[-\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\\right] + k\\left[\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{1}{2}\\,x\\,(L-x)\\right]\n$$\nGrouping terms by their functional dependence on $x$ and $t$:\n$$\ns(x,t) = \\left(k - 1 + D\\left(\\frac{2\\pi}{L}\\right)^2\\right)\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + \\left(\\frac{2\\pi a}{L}\\right)\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + a\\left(\\frac{L}{2} - x\\right) + D + \\frac{k}{2}x(L-x)\n$$\nThis is the analytical expression for the source term that will be implemented in the numerical model.\n\n### 2. Numerical Discretization\n\nThe PDE is discretized on a uniform spatial grid $x_i = i h$ for $i \\in \\{0, 1, \\dots, N+1\\}$, where $h = L/(N+1)$ is the grid spacing. Time is discretized as $t_n = n \\Delta t$. We denote the numerical approximation of $u(x_i, t_n)$ as $u_i^n$.\n\nThe specified numerical scheme is:\n\\begin{itemize}\n    \\item **Time Derivative**: Forward Euler, $\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$.\n    \\item **Diffusion Term**: Second-order central difference, $\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}$.\n    \\item **Advection Term**: First-order upwind difference. The form depends on the sign of the velocity $a$:\n    \\begin{itemize}\n        \\item If $a \\ge 0$ (flow to the right), a backward difference is used: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_i^n - u_{i-1}^n}{h}$.\n        \\item If $a < 0$ (flow to the left), a forward difference is used: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{i+1}^n - u_i^n}{h}$.\n    \\end{itemize}\n\\end{itemize}\n\nRearranging the PDE as $\\frac{\\partial u}{\\partial t} = \\dots$ and substituting the discrete approximations gives the update rule $u_i^{n+1} = u_i^n + \\Delta t (\\dots)$.\n\nFor $a \\ge 0$:\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_i^n - u_{i-1}^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\nFor $a < 0$:\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_{i+1}^n - u_i^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\nThese equations are applied to all interior grid points $i \\in \\{1, 2, \\dots, N\\}$. The boundary values are fixed by the Dirichlet conditions: $u_0^{n+1} = u_{\\mathrm{m}}(0, t_{n+1}) = 0$ and $u_{N+1}^{n+1} = u_{\\mathrm{m}}(L, t_{n+1}) = 0$.\n\n### 3. Time Step and Convergence Analysis\n\nThe time step $\\Delta t$ is chosen to satisfy the explicit stability conditions for the forward Euler scheme:\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right)\n$$\nThe factor $0.4$ is a safety factor ensuring that the Courant–Friedrichs–Lewy (CFL) conditions for advection and diffusion, as well as a stability condition for the reaction term, are all met.\n\nThe simulation starts from the initial condition $u_i^0 = u_{\\mathrm{m}}(x_i, 0)$ and proceeds until the final time $T$. The accuracy of the numerical solution $u_i(T)$ is quantified by the relative discrete $L^2$ error:\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}\n$$\nThe observed order of convergence, $p$, is estimated by computing the error for two different grid resolutions, $h_2$ (with $N_2=80$) and $h_3$ (with $N_3=160$):\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)}\n$$\nThe numerical scheme employs first-order methods for time integration (Forward Euler) and advection (upwinding), and a second-order method for diffusion. The overall accuracy is limited by the lowest order term, so the theoretical convergence rate is expected to be $p \\approx 1$.\n\n### 4. Implementation\n\nThe algorithm is implemented in Python using the `numpy` library for efficient vectorized operations. A function is defined to run the simulation for a given set of parameters $(a, D, k)$ and grid size $N$. This function initializes the grid and the solution vector, calculates the stable time step, and iteratively updates the solution in a time loop. Within the loop, the source term is evaluated at the current time, and the appropriate upwind scheme is chosen based on the sign of $a$. After reaching the final time $T$, the function computes and returns the relative $L^2$ error. The main part of the script loops through the four test suites, calls the simulation function for $N=80$ and $N=160$, calculates the convergence rate $p$ for each suite, and prints the results in the specified format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the observed convergence rates for the ADR equation\n    solution for four different parameter sets.\n    \"\"\"\n\n    def u_manufactured(x: np.ndarray, t: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured solution u_m(x, t).\n        \"\"\"\n        term1 = np.sin(2 * np.pi * x / L) * np.exp(-t)\n        term2 = 0.5 * x * (L - x)\n        return term1 + term2\n\n    def source_manufactured(x: np.ndarray, t: float, a: float, D: float, k: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured source term s(x, t).\n        \"\"\"\n        pi_term = 2 * np.pi / L\n        exp_t = np.exp(-t)\n        \n        sin_term = np.sin(pi_term * x)\n        cos_term = np.cos(pi_term * x)\n        \n        # Grouping terms as derived in the solution\n        term1 = (k - 1 + D * pi_term**2) * sin_term * exp_t\n        term2 = a * pi_term * cos_term * exp_t\n        term3 = a * (L/2 - x)\n        term4 = D\n        term5 = k * 0.5 * x * (L - x)\n\n        return term1 + term2 + term3 + term4 + term5\n\n    def run_simulation(N: int, a: float, D: float, k: float, L: float, T: float) -> float:\n        \"\"\"\n        Runs one simulation for a given grid size and parameter set.\n        \n        Returns:\n            The relative discrete L2 error.\n        \"\"\"\n        # Grid setup\n        h = L / (N + 1)\n        x = np.linspace(0, L, N + 2)\n\n        # Time step calculation based on stability criteria\n        # Handle cases where denominators might be zero\n        dt_adv = h / abs(a) if a != 0 else np.inf\n        dt_diff = h**2 / (2 * D) if D != 0 else np.inf\n        dt_react = 1 / k if k != 0 else np.inf\n        \n        dt = 0.4 * min(dt_adv, dt_diff, dt_react)\n        \n        num_steps = int(np.ceil(T / dt))\n        dt = T / num_steps  # Adjust dt to hit T exactly\n\n        # Initial condition\n        u = u_manufactured(x, 0, L)\n        \n        # Time-stepping loop\n        t = 0\n        for n in range(num_steps):\n            t = n * dt\n            u_n = u.copy()\n            \n            # Evaluate source term for interior points at current time t\n            s = source_manufactured(x[1:-1], t, a, D, k, L)\n\n            # Slicing for vectorized update\n            u_interior = u_n[1:-1]\n            u_left = u_n[0:-2]\n            u_right = u_n[2:]\n\n            # Diffusion and reaction terms\n            diffusion_term = D * (u_left - 2 * u_interior + u_right) / h**2\n            reaction_term = -k * u_interior\n\n            # Advection term (upwinding)\n            if a >= 0:\n                advection_term = -a * (u_interior - u_left) / h\n            else: # a < 0\n                advection_term = -a * (u_right - u_interior) / h\n\n            # Update interior points\n            u[1:-1] = u_interior + dt * (diffusion_term + advection_term + reaction_term + s)\n\n            # Boundary conditions for the next step (t + dt) are u_m(0, t+dt) and u_m(L, t+dt)\n            # which are both 0 for all t > 0.\n            u[0] = u_manufactured(x[0], t + dt, L)\n            u[-1] = u_manufactured(x[-1], t + dt, L)\n\n        # Final time reached\n        t_final = T\n        u_exact_T = u_manufactured(x, t_final, L)\n\n        # Compute relative discrete L2 error\n        # The sqrt(h) factor in numerator and denominator can be cancelled if numpy's\n        # default L2 norm is used, but we'll implement the formula exactly for clarity.\n        err_numerator_sq = h * np.sum((u - u_exact_T)**2)\n        err_denominator_sq = h * np.sum(u_exact_T**2)\n        \n        if err_denominator_sq == 0:\n            return 0.0 if err_numerator_sq == 0 else np.inf\n            \n        error = np.sqrt(err_numerator_sq) / np.sqrt(err_denominator_sq)\n        \n        return error\n\n    def calculate_convergence_rate(params: tuple) -> float:\n        \"\"\"\n        Calculates the convergence rate for a given parameter set.\n        \"\"\"\n        a, D, k = params\n        L, T = 1.0, 0.1\n        N_vals = {'N2': 80, 'N3': 160}\n\n        h2 = L / (N_vals['N2'] + 1)\n        h3 = L / (N_vals['N3'] + 1)\n        \n        E_h2 = run_simulation(N_vals['N2'], a, D, k, L, T)\n        E_h3 = run_simulation(N_vals['N3'], a, D, k, L, T)\n        \n        # Handle cases where error might be zero\n        if E_h2 == 0 or E_h3 == 0:\n            return np.nan # Or some other indicator of non-standard convergence\n            \n        p = np.log(E_h2 / E_h3) / np.log(h2 / h3)\n        return p\n\n    # Test suite from the problem statement\n    test_cases = [\n        (0.05, 1.0e-3, 0.1),    # Set A: diffusion-dominated\n        (1.0, 1.0e-4, 0.1),     # Set B: advection-dominated, positive a\n        (-1.0, 1.0e-4, 0.1),    # Set C: advection-dominated, negative a\n        (0.01, 1.0e-4, 5.0),    # Set D: reaction-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        p = calculate_convergence_rate(case)\n        results.append(p)\n\n    # Format output as specified: [p_A,p_B,p_C,p_D] rounded to 3 decimal places.\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}