{
    "hands_on_practices": [
        {
            "introduction": "The diffusion equation is a cornerstone of transport modeling, describing the net movement of a solute driven by random molecular motion. When solving this equation numerically with an explicit time-stepping scheme, a critical challenge arises: the potential for catastrophic instability where small errors grow uncontrollably. This practice  guides you through a von Neumann stability analysis, a fundamental technique for deriving the precise mathematical conditions on the time step and grid spacing that guarantee a stable solution.",
            "id": "4079415",
            "problem": "A one-dimensional diffusion of a conservative aqueous tracer through a homogeneous, water-saturated sediment core of length $L$ is modeled under isothermal conditions and constant porosity. Let $C(x,t)$ denote the dissolved tracer concentration (moles per unit volume of porewater). Under the assumptions of no advection and no chemical reactions, the governing equation follows from mass conservation and Fick's first law of diffusion: the conservation statement is $\\partial C/\\partial t + \\partial J/\\partial x = 0$, and the flux is $J = -D\\,\\partial C/\\partial x$, where $D$ is the constant effective diffusion coefficient. Combining these gives the diffusion equation $\\partial C/\\partial t = D\\,\\partial^{2} C/\\partial x^{2}$.\n\nConsider a uniform grid with spatial step $\\Delta x$ and time step $\\Delta t$, and the following explicit time-marching scheme obtained by forward Euler in time and a centered second-order finite difference in space:\n$$\nC_{j}^{n+1} \\;=\\; C_{j}^{n} \\;+\\; \\alpha \\,\\big(C_{j+1}^{n} \\;-\\; 2\\,C_{j}^{n} \\;+\\; C_{j-1}^{n}\\big),\n$$\nwhere $j$ indexes space, $n$ indexes time, and $\\alpha \\equiv D\\,\\Delta t/\\Delta x^{2}$ is the dimensionless diffusion number (also known as the Fourier number).\n\nAssume periodic boundary conditions so that Fourier modes span the discrete solution space, and perform a von Neumann stability analysis starting from the governing conservation law and constitutive relation stated above, and the stated discretization. Impose the necessary and sufficient condition that the magnitude of the amplification factor does not exceed unity for all resolvable wavenumbers. Determine the largest admissible value $\\alpha_{\\max}$ such that the scheme is stable for all $0 \\leq \\alpha \\leq \\alpha_{\\max}$. Provide your answer as a single exact number with no units.",
            "solution": "The user has provided a valid problem statement. The governing partial differential equation, its finite difference discretization, and the method of analysis are all standard and well-posed. The problem is scientifically grounded, formally stated, and contains all necessary information to derive a unique solution.\n\nThe task is to perform a von Neumann stability analysis on the given explicit finite difference scheme for the one-dimensional diffusion equation to find the maximum allowable value of the dimensionless diffusion number, $\\alpha$.\n\nThe finite difference scheme is given by:\n$$\nC_{j}^{n+1} \\;=\\; C_{j}^{n} \\;+\\; \\alpha \\,\\big(C_{j+1}^{n} \\;-\\; 2\\,C_{j}^{n} \\;+\\; C_{j-1}^{n}\\big)\n$$\nwhere $C_j^n$ represents the concentration at spatial index $j$ and time index $n$, and $\\alpha = \\frac{D \\Delta t}{\\Delta x^2}$.\n\nIn von Neumann stability analysis, we examine the amplification of a single Fourier mode of the solution as it evolves in time. A discrete Fourier mode can be represented as:\n$$\nC_j^n = \\hat{C}^n(k) \\exp(i k x_j)\n$$\nwhere $x_j = j \\Delta x$ is the spatial coordinate, $k$ is the wavenumber, $i = \\sqrt{-1}$, and $\\hat{C}^n(k)$ is the amplitude of the mode at time level $n$.\n\nDue to the linearity of the finite difference equation, the solution at the next time step, $n+1$, for this single mode will have the form:\n$$\nC_j^{n+1} = \\hat{C}^{n+1}(k) \\exp(i k x_j)\n$$\nThe amplification factor, $\\mathcal{G}(k)$, is defined as the ratio of the amplitudes at successive time steps:\n$$\n\\mathcal{G}(k) = \\frac{\\hat{C}^{n+1}(k)}{\\hat{C}^n(k)}\n$$\nThus, we can write $C_j^{n+1} = \\mathcal{G}(k) C_j^n$. The scheme is stable if and only if the magnitude of the amplification factor is less than or equal to unity for all possible wavenumbers, i.e., $|\\mathcal{G}(k)| \\le 1$.\n\nWe substitute the Fourier mode representation into the finite difference scheme.\nFor the term $C_j^n$, we have $\\hat{C}^n \\exp(i k j \\Delta x)$.\nFor $C_{j+1}^n$, we have $\\hat{C}^n \\exp(i k (j+1) \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) \\exp(i k \\Delta x)$.\nFor $C_{j-1}^n$, we have $\\hat{C}^n \\exp(i k (j-1) \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) \\exp(-i k \\Delta x)$.\nFor $C_j^{n+1}$, we have $\\mathcal{G} \\hat{C}^n \\exp(i k j \\Delta x)$.\n\nSubstituting these into the scheme gives:\n$$\n\\mathcal{G} \\hat{C}^n \\exp(i k j \\Delta x) = \\hat{C}^n \\exp(i k j \\Delta x) + \\alpha \\left[ \\hat{C}^n \\exp(i k j \\Delta x) \\exp(i k \\Delta x) - 2\\hat{C}^n \\exp(i k j \\Delta x) + \\hat{C}^n \\exp(i k j \\Delta x) \\exp(-i k \\Delta x) \\right]\n$$\nWe can divide through by the common non-zero term $\\hat{C}^n \\exp(i k j \\Delta x)$ to solve for $\\mathcal{G}$:\n$$\n\\mathcal{G} = 1 + \\alpha \\left( \\exp(i k \\Delta x) - 2 + \\exp(-i k \\Delta x) \\right)\n$$\nUsing Euler's formula, $\\exp(i\\theta) + \\exp(-i\\theta) = 2\\cos(\\theta)$, with $\\theta = k \\Delta x$, we simplify the expression in the parenthesis:\n$$\n\\mathcal{G} = 1 + \\alpha \\left( 2\\cos(k \\Delta x) - 2 \\right) = 1 + 2\\alpha \\left( \\cos(k \\Delta x) - 1 \\right)\n$$\nNext, we use the trigonometric identity $\\cos(\\theta) - 1 = -2\\sin^2(\\theta/2)$:\n$$\n\\mathcal{G} = 1 + 2\\alpha \\left( -2\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\right)\n$$\n$$\n\\mathcal{G} = 1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\nThe amplification factor $\\mathcal{G}$ is a real number. The stability condition is $|\\mathcal{G}| \\le 1$, which is equivalent to the two inequalities $-1 \\le \\mathcal{G} \\le 1$.\n\nLet's analyze each inequality:\n1.  $\\mathcal{G} \\le 1$:\n    $$1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 1$$\n    $$-4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le 0$$\n    Since $\\alpha = D \\Delta t / \\Delta x^2$ is non-negative (as $D \\ge 0$, $\\Delta t > 0$, and $\\Delta x^{2} > 0$) and $\\sin^2(\\cdot)$ is always non-negative, the product $-4\\alpha \\sin^2(\\cdot)$ is always less than or equal to zero. Thus, this inequality is always satisfied and places no restriction on $\\alpha$.\n\n2.  $\\mathcal{G} \\ge -1$:\n    $$1 - 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\ge -1$$\n    $$2 \\ge 4\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$$\n    $$\\alpha \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\le \\frac{2}{4}$$\n    $$\\alpha \\le \\frac{1}{2\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)}$$\nThis condition must hold for all wavenumbers $k$ that can be represented on the grid. To ensure this, we must consider the \"worst-case\" scenario, which is the one that places the most stringent (i.e., smallest) upper bound on $\\alpha$. This occurs when the denominator, $2\\sin^2(k \\Delta x / 2)$, is at its maximum value.\n\nThe maximum value of the function $\\sin^2(\\theta)$ is $1$. The argument is $\\theta = k \\Delta x / 2$. The term $\\sin^2(k \\Delta x / 2)$ reaches its maximum value of $1$ for the highest-frequency (most oscillatory) mode resolvable on the grid, which corresponds to a wavelength of $2 \\Delta x$. This is the Nyquist frequency, where the wavenumber is $k = \\pi/\\Delta x$, which makes the argument $k \\Delta x / 2 = \\pi/2$.\n\nFor this \"worst-case\" mode, we have:\n$$\n\\sin^2\\left(\\frac{\\pi \\Delta x}{2 \\Delta x}\\right) = \\sin^2\\left(\\frac{\\pi}{2}\\right) = 1^2 = 1\n$$\nSubstituting this maximum value into the stability inequality gives the most restrictive condition on $\\alpha$:\n$$\n\\alpha \\le \\frac{1}{2(1)} \\implies \\alpha \\le \\frac{1}{2}\n$$\nTherefore, for the scheme to be stable for all resolvable modes, the dimensionless diffusion number $\\alpha$ must be no greater than $1/2$. The largest admissible value, $\\alpha_{\\max}$, is this upper bound.\n$$\n\\alpha_{\\max} = \\frac{1}{2}\n$$",
            "answer": "$$\\boxed{\\frac{1}{2}}$$"
        },
        {
            "introduction": "Unlike diffusive transport, advection describes the directed movement of a solute with the flow of a fluid. Discretizing the first-order spatial derivative in the advection equation poses unique challenges; an intuitive centered-difference approach can paradoxically lead to severe, non-physical oscillations. This practice  demonstrates this failure and introduces the concept of upwinding, a robust alternative that constructs a stable and monotone scheme by respecting the direction of information flow in the system.",
            "id": "4079372",
            "problem": "Consider the one-dimensional conservative transport of a nonreactive, nondecaying, dissolved tracer in a saturated, homogeneous porous medium with constant advective velocity. The governing statement of conservation of mass for the dissolved concentration is the linear advection (or pure transport) equation\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0,\n$$\nwhere $u(x,t)$ is the dimensionless concentration and $a$ is a constant velocity in units of length per time.\n\nYour tasks are as follows.\n\n1) Starting from the notion of local conservation and a uniform grid with spacing $\\Delta x$ and time increment $\\Delta t$, construct a finite-difference scheme that uses a centered difference for the spatial derivative and a forward difference for the time derivative. Perform a Fourier mode (von Neumann) stability analysis of this scheme to determine the amplification factor as a function of the nondimensional wavenumber and the Courant number $r = |a| \\Delta t / \\Delta x$. Use this analysis to explain from first principles why centered differencing for advection can generate oscillations in the numerical solution.\n\n2) Starting from the same conservation statement and grid, construct a first-order upwind discretization based on choosing the numerical flux consistent with the upstream state. Derive the explicit update formula for both $a > 0$ and $a < 0$. Prove a sufficient condition for monotonicity by showing that the update can be written as a convex combination of neighboring values and identifying the corresponding condition on the Courant number $r$.\n\n3) Implement both schemes on a periodic domain of length $L = 1$ using $N$ uniformly spaced points with spacing $\\Delta x = L/N$. Use the piecewise-constant initial condition\n$$\nu(x,0) =\n\\begin{cases}\n1, & x \\in [0.2, 0.4),\\\\\n0, & \\text{otherwise},\n\\end{cases}\n$$\ninterpreted with periodicity on $[0,1)$ so that the interval $[0.2,0.4)$ wraps within the domain as usual. For each test case below, compute a single explicit time step $\\Delta t = r \\Delta x / |a|$. Impose periodic boundary conditions.\n\nFor each test case, compute the following three diagnostics after one time step for each scheme:\n- A boolean $B_{\\mathrm{FTCS}}$ that is true if any nodal value from the centered scheme lies outside the closed interval $[0,1]$, and false otherwise.\n- A boolean $B_{\\mathrm{UP}}$ that is true if any nodal value from the upwind scheme lies outside the closed interval $[0,1]$, and false otherwise.\n- A float $\\rho_{\\mathrm{TV}}$ defined as the ratio of total variation after one upwind step to the initial total variation, where the total variation for a periodic grid function $v_i$ is\n$$\nTV(v) = \\sum_{i=0}^{N-1} \\left| v_{i+1} - v_{i} \\right|,\n$$\nwith periodic indexing $v_{N} \\equiv v_{0}$. Report $\\rho_{\\mathrm{TV}}$ rounded to $6$ decimal places.\n\nTest suite (all cases use $L = 1$ and the initial condition above):\n- Case A: $N = 200$, $a = +1$, $r = 0.5$.\n- Case B: $N = 200$, $a = +1$, $r = 1.0$.\n- Case C: $N = 200$, $a = +1$, $r = 1.2$.\n- Case D: $N = 200$, $a = -1$, $r = 0.8$.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list of four inner lists, one per test case, in the same order as listed above. Each inner list must have the form $[B_{\\mathrm{FTCS}}, B_{\\mathrm{UP}}, \\rho_{\\mathrm{TV}}]$, where booleans are written as $True$ or $False$ and $\\rho_{\\mathrm{TV}}$ is printed with exactly $6$ digits after the decimal point. For example,\n$$\n\\left[\\,[True,False,0.875000],[\\dots],\\dots\\,\\right].\n$$",
            "solution": "The problem presents a set of tasks related to the numerical solution of the one-dimensional linear advection equation, a foundational model in computational geochemistry for conservative transport. The tasks are to derive and analyze two common finite-difference schemes—the forward-time, centered-space (FTCS) scheme and the first-order upwind scheme—and then to implement them to compute specific diagnostics for a given set of test cases. Each task will be addressed sequentially.\n\n### 1. FTCS Scheme: Derivation and Stability Analysis\n\nThe governing partial differential equation (PDE) is the linear advection equation:\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\nwhere $u(x,t)$ is the concentration and $a$ is the constant advective velocity.\n\nTo construct the requested finite-difference scheme, we discretize the domain with a uniform spatial grid of spacing $\\Delta x$ and time increments of $\\Delta t$. Let $u_i^n \\approx u(i\\Delta x, n\\Delta t)$. The time derivative $\\frac{\\partial u}{\\partial t}$ is approximated using a forward difference:\n$$\n\\left. \\frac{\\partial u}{\\partial t} \\right|_{i,n} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\nThe spatial derivative $\\frac{\\partial u}{\\partial x}$ is approximated using a centered difference:\n$$\n\\left. \\frac{\\partial u}{\\partial x} \\right|_{i,n} \\approx \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x}\n$$\nSubstituting these approximations into the PDE yields:\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_{i-1}^n}{2\\Delta x} = 0\n$$\nSolving for the value at the new time step, $u_i^{n+1}$, gives the explicit update formula for the FTCS scheme:\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{2 \\Delta x} (u_{i+1}^n - u_{i-1}^n)\n$$\nLet us define a modified Courant number $r' = \\frac{a \\Delta t}{\\Delta x}$. The problem defines the Courant number as $r = \\frac{|a| \\Delta t}{\\Delta x}$, so $r' = \\text{sign}(a) r$. The scheme is:\n$$\nu_i^{n+1} = u_i^n - \\frac{r'}{2} (u_{i+1}^n - u_{i-1}^n)\n$$\nTo perform a von Neumann stability analysis, we examine the behavior of a single Fourier mode of the form $u_i^n = G^n e^{jki\\Delta x}$, where $G$ is the complex amplification factor, $k$ is the wavenumber, and $j=\\sqrt{-1}$. Substituting this into the difference equation:\n$$\nG^{n+1} e^{jki\\Delta x} = G^n e^{jki\\Delta x} - \\frac{r'}{2} \\left( G^n e^{jk(i+1)\\Delta x} - G^n e^{jk(i-1)\\Delta x} \\right)\n$$\nDividing by $G^n e^{jki\\Delta x}$ isolates the amplification factor $G$:\n$$\nG = 1 - \\frac{r'}{2} \\left( e^{jk\\Delta x} - e^{-jk\\Delta x} \\right)\n$$\nUsing Euler's identity, $e^{j\\theta} - e^{-j\\theta} = 2j \\sin(\\theta)$, with $\\theta = k\\Delta x$, we get:\n$$\nG = 1 - \\frac{r'}{2} (2j \\sin(k\\Delta x)) = 1 - j r' \\sin(k\\Delta x)\n$$\nFor a scheme to be stable, the magnitude of the amplification factor must satisfy $|G| \\leq 1$ for all wavenumbers. The squared magnitude of $G$ is:\n$$\n|G|^2 = (\\text{Re}(G))^2 + (\\text{Im}(G))^2 = 1^2 + (-r' \\sin(k\\Delta x))^2 = 1 + (r' \\sin(k\\Delta x))^2\n$$\nSubstituting $r' = \\text{sign}(a) r$, we have $(r')^2 = r^2$. Thus:\n$$\n|G|^2 = 1 + r^2 \\sin^2(k\\Delta x)\n$$\nFor any non-zero Courant number $r>0$ and any wavenumber $k$ such that $\\sin(k\\Delta x) \\neq 0$, the term $r^2 \\sin^2(k\\Delta x)$ is strictly positive. Consequently, $|G|^2 > 1$, which implies $|G| > 1$. The scheme amplifies certain Fourier modes at every time step, making it **unconditionally unstable** for the linear advection equation.\n\nThis instability manifests as spurious oscillations. A more direct explanation for why the scheme can generate oscillations (i.e., new extrema not present in the initial data) is that the update formula is not a convex combination of neighboring values. Rewriting the scheme:\n$$\nu_i^{n+1} = \\left(\\frac{r'}{2}\\right) u_{i-1}^n + (1) u_i^n + \\left(-\\frac{r'}{2}\\right) u_{i+1}^n\n$$\nFor this to be a convex combination, all coefficients must be non-negative. However, if $r' > 0$ (i.e., $a>0$), the coefficient of $u_{i+1}^n$ is negative. If $r' < 0$ (i.e., $a<0$), the coefficient of $u_{i-1}^n$ is negative. Since one of the stencil coefficients is always negative, the scheme does not satisfy a discrete maximum principle. As a result, the value $u_i^{n+1}$ can be outside the range $[\\min(u_{i-1}^n, u_i^n, u_{i+1}^n), \\max(u_{i-1}^n, u_i^n, u_{i+1}^n)]$, leading to the creation of unphysical oscillations (undershoots and overshoots).\n\n### 2. First-Order Upwind Scheme: Derivation and Monotonicity\n\nThe upwind scheme is derived from a finite volume perspective. Integrating the conservative form of the equation, $\\frac{\\partial u}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0$ where $F=au$ is the flux, over a cell $[x_{i-1/2}, x_{i+1/2}] \\times [t_n, t_{n+1}]$ gives:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (F_{i+1/2} - F_{i-1/2})\n$$\nThe upwind principle dictates that the flux at a cell interface, e.g., $F_{i+1/2}$, is determined by the state in the \"upwind\" cell, i.e., the cell from which information is flowing.\n$$\nF_{i+1/2} = \\begin{cases} a u_i^n, & \\text{if } a > 0 \\\\ a u_{i+1}^n, & \\text{if } a < 0 \\end{cases}\n$$\nThis leads to two distinct update formulas depending on the sign of $a$.\n\n**Case 1: $a > 0$** (Flow is to the right)\nThe fluxes are $F_{i+1/2} = a u_i^n$ and $F_{i-1/2} = a u_{i-1}^n$. Substituting into the finite volume formula:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_i^n - a u_{i-1}^n)\n$$\nUsing the Courant number $r = \\frac{a \\Delta t}{\\Delta x}$ (since $a>0$, $|a|=a$):\n$$\nu_i^{n+1} = u_i^n - r(u_i^n - u_{i-1}^n) = (1-r)u_i^n + r u_{i-1}^n\n$$\n\n**Case 2: $a < 0$** (Flow is to the left)\nThe fluxes are $F_{i+1/2} = a u_{i+1}^n$ and $F_{i-1/2} = a u_i^n$. Substituting gives:\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} (a u_{i+1}^n - a u_i^n)\n$$\nUsing the Courant number $r = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$, which implies $\\frac{a \\Delta t}{\\Delta x} = -r$:\n$$\nu_i^{n+1} = u_i^n - (-r)(u_{i+1}^n - u_i^n) = (1-r)u_i^n + r u_{i+1}^n\n$$\n\nTo prove a sufficient condition for monotonicity, we show that the update is a convex combination of neighboring values.\nIn both cases ($a>0$ and $a<0$), the update has the form $u_i^{n+1} = (1-r)u_i^n + r u_k^n$, where $u_k^n$ is an adjacent cell value ($u_{i-1}^n$ or $u_{i+1}^n$).\nFor this to be a convex combination, two conditions must be met:\n1. The sum of the coefficients must be $1$: $(1-r) + r = 1$. This is always true.\n2. All coefficients must be non-negative. By definition, $r = \\frac{|a| \\Delta t}{\\Delta x} \\ge 0$. The second condition is $1-r \\ge 0$, which implies $r \\le 1$.\n\nTherefore, a sufficient condition for the first-order upwind scheme to be monotone is $0 \\le r \\le 1$. This is the Courant-Friedrichs-Lewy (CFL) condition for this scheme. If satisfied, $u_i^{n+1}$ is a weighted average of two values from the previous time step, ensuring that its value lies between those two values and preventing the formation of new extrema.\n\n### 3. Numerical Implementation\n\nThe implementation involves discretizing the periodic domain $[0,1)$ into $N$ grid points $x_i = i(L/N)$ for $i=0, \\dots, N-1$. The piecewise-constant initial condition is mapped onto this grid. For each test case, a single time step of size $\\Delta t = r \\Delta x / |a|$ is computed using both the FTCS and upwind schemes derived above. Periodic boundary conditions are handled by using array-rolling operations, which naturally implement the required wraparound indexing. After the time step, the three diagnostics are computed:\n- $B_{\\mathrm{FTCS}}$: A boolean indicating if any value in the FTCS solution lies outside the initial range of $[0,1]$.\n- $B_{\\mathrm{UP}}$: A boolean indicating if any value in the upwind solution lies outside the initial range of $[0,1]$. For $r \\le 1$, this is expected to be false due to monotonicity. For $r > 1$, it may be true.\n- $\\rho_{\\mathrm{TV}}$: The ratio of the total variation of the upwind solution to the initial total variation. The total variation for a periodic grid function $v_i$ is $TV(v) = \\sum_{i=0}^{N-1} |v_{i+1} - v_i|$, with $v_N \\equiv v_0$. For the given boxcar initial condition, the total variation is $TV(u(x,0)) = |1-0| + |0-1| = 2$.\nThe code in the final answer will perform these calculations for all specified test cases.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection problem using FTCS and Upwind schemes\n    for a suite of test cases and computes specified diagnostics.\n    \"\"\"\n    test_cases = [\n        # (N, a, r)\n        (200, 1.0, 0.5),  # Case A\n        (200, 1.0, 1.0),  # Case B\n        (200, 1.0, 1.2),  # Case C\n        (200, -1.0, 0.8), # Case D\n    ]\n\n    all_results = []\n\n    for N, a, r in test_cases:\n        # Domain and Grid Setup\n        L = 1.0\n        dx = L / N\n        dt = r * dx / abs(a)\n        x = np.linspace(0, L, N, endpoint=False)\n\n        # Initial Condition: Piecewise-constant (boxcar) function\n        u0 = np.zeros(N)\n        u0[(x >= 0.2) & (x < 0.4)] = 1.0\n\n        # --- Scheme Implementations for one time step ---\n\n        # 1. FTCS (Forward-Time, Centered-Space) Scheme\n        # u_i^{n+1} = u_i^n - (a*dt / (2*dx)) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev = np.roll(u0, 1)   # u_{i-1}\n        u_next = np.roll(u0, -1)  # u_{i+1}\n        u_ftcs = u0 - (a * dt / (2.0 * dx)) * (u_next - u_prev)\n        \n        # 2. First-Order Upwind Scheme\n        u_upwind = np.zeros(N)\n        if a > 0:\n            # u_i^{n+1} = u_i^n - r * (u_i^n - u_{i-1}^n)\n            u_prev = np.roll(u0, 1)\n            u_upwind = u0 - r * (u0 - u_prev)\n        else: # a < 0\n            # u_i^{n+1} = u_i^n + r * (u_{i+1}^n - u_i^n)\n            u_next = np.roll(u0, -1)\n            u_upwind = u0 + r * (u_next - u0)\n\n        # --- Diagnostic Calculations ---\n\n        # B_FTCS: Boolean check for oscillations in FTCS solution\n        # The problem asks if any value lies outside [0,1].\n        # Floating point precision requires a small tolerance for comparison.\n        # However, the problem text implies a strict check, so we avoid tolerance.\n        B_ftcs = np.any((u_ftcs < 0.0) | (u_ftcs > 1.0))\n\n        # B_UP: Boolean check for oscillations in Upwind solution\n        B_up = np.any((u_upwind < 0.0) | (u_upwind > 1.0))\n\n        # rho_TV: Ratio of Total Variation for the upwind scheme\n        def calculate_tv(v):\n            return np.sum(np.abs(np.roll(v, -1) - v))\n\n        tv_initial = calculate_tv(u0)\n        tv_upwind = calculate_tv(u_upwind)\n        \n        rho_tv = tv_upwind / tv_initial if tv_initial > 0 else 0.0\n\n        # Assemble the results for the current case\n        case_result_str = f\"[{str(B_ftcs)},{str(B_up)},{rho_tv:.6f}]\"\n        all_results.append(case_result_str)\n\n    # Format the final output string as a list of lists representation\n    final_output = f\"[{','.join(all_results)}]\"\n    print(final_output)\n\nsolve()\n\n```"
        },
        {
            "introduction": "Real-world geochemical systems often involve the simultaneous action of advection, diffusion, and reaction, which are combined in the Advection-Diffusion-Reaction (ADR) equation. After writing a numerical solver for such a complex equation, how can you be sure your code is correct? This practice  introduces the Method of Manufactured Solutions (MMS), an indispensable technique for code verification that allows you to precisely measure your solver's error and confirm its theoretical convergence rate by testing it against a problem with a known, pre-defined exact solution.",
            "id": "4079440",
            "problem": "Consider one-dimensional solute transport in a saturated geochemical column modeled by the Advection–Diffusion–Reaction (ADR) Partial Differential Equation (PDE). Let $u(x,t)$ denote aqueous concentration in $\\mathrm{mol}\\,\\mathrm{m}^{-3}$, with spatial coordinate $x \\in [0,L]$ in $\\mathrm{m}$ and time $t \\in [0,T]$ in $\\mathrm{s}$. The ADR PDE is\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t),\n$$\nwhere $a$ is the advective velocity in $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D$ is the diffusion (hydrodynamic dispersion) coefficient in $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k$ is a first-order reaction rate constant in $\\mathrm{s}^{-1}$, and $s(x,t)$ is a source term in $\\mathrm{mol}\\,\\mathrm{m}^{-3}\\,\\mathrm{s}^{-1}$ representing external inputs.\n\nUsing the method of manufactured solutions, define the exact concentration field\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\big(2\\pi x/L\\big)\\,\\mathrm{e}^{-t} \\;+\\; \\tfrac{1}{2}\\,x\\,(L-x),\n$$\nwith domain length $L = 1$ $\\mathrm{m}$ and final time $T = 0.1$ $\\mathrm{s}$. Impose Dirichlet boundary conditions that match the manufactured solution, so that $u(0,t) = u_{\\mathrm{m}}(0,t)$ and $u(L,t) = u_{\\mathrm{m}}(L,t)$ for all $t \\in [0,T]$, and an initial condition $u(x,0) = u_{\\mathrm{m}}(x,0)$ for all $x \\in [0,L]$. Starting from the ADR definition above, derive the source term $s(x,t)$ that makes $u_{\\mathrm{m}}(x,t)$ an exact solution of the continuous ADR PDE for arbitrary constants $a$, $D$, and $k$.\n\nDiscretize the spatial domain by a uniform grid with $N$ interior points (so there are $N+2$ nodes including the boundaries), spacing $h = L/(N+1)$. Use an upwind finite difference for the first derivative $\\partial u/\\partial x$, a second-order central difference for the second derivative $\\partial^2 u/\\partial x^2$, and a forward Euler time integrator for $\\partial u/\\partial t$. Specifically, for a given sign of $a$, use the appropriate upwind one-sided difference. Let the time step $\\Delta t$ satisfy explicit stability conditions, taking\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right),\n$$\nwith the convention that terms with zero denominator are treated as $+\\infty$ in the minimum. Integrate from $t=0$ to $t=T$ by forward Euler using the manufactured source term $s(x,t)$ evaluated at the current time level, and enforce Dirichlet boundary values from $u_{\\mathrm{m}}(x,t)$ at every time step. After reaching $t=T$, compute the relative discrete $L^2$ error\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}},\n$$\nwhich is dimensionless. Using mesh refinements $N \\in \\{40, 80, 160\\}$, estimate the observed convergence rate\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)},\n$$\nwhere $h_j = L/(N_j+1)$ and $N_2=80$, $N_3=160$.\n\nTest Suite:\n- Set $\\mathrm{A}$ (diffusion-dominated): $a = 0.05$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-3}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{B}$ (advection-dominated, positive velocity): $a = 1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{C}$ (advection-dominated, negative velocity): $a = -1.0$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 0.1$ $\\mathrm{s}^{-1}$.\n- Set $\\mathrm{D}$ (reaction-dominated): $a = 0.01$ $\\mathrm{m}\\,\\mathrm{s}^{-1}$, $D = 1.0\\times 10^{-4}$ $\\mathrm{m}^2\\,\\mathrm{s}^{-1}$, $k = 5.0$ $\\mathrm{s}^{-1}$.\n\nYour program must:\n- Derive and implement the manufactured source $s(x,t)$ from the ADR PDE and $u_{\\mathrm{m}}(x,t)$.\n- For each parameter set $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, and $\\mathrm{D}$, compute the relative discrete $L^2$ errors $E_{h}$ for $N \\in \\{40,80,160\\}$ and then compute $p$ using the formula above.\n- Produce a single line of output containing the observed convergence rates for the four sets as a comma-separated list enclosed in square brackets, in the order $\\mathrm{A}$, $\\mathrm{B}$, $\\mathrm{C}$, $\\mathrm{D}$, with each float rounded to three decimal places, for example $[p_A,p_B,p_C,p_D]$.\n\nAll outputs are dimensionless and must be reported as floats. Angles are not involved. No percentages are involved.",
            "solution": "The user-provided problem is a well-posed exercise in computational science, specifically the numerical solution of a partial differential equation (PDE) using the method of manufactured solutions for code verification. The problem is scientifically grounded, self-contained, and all parameters and methods are clearly defined. It will be solved by first deriving the necessary source term, then developing a numerical model based on the specified finite difference scheme, and finally using this model to compute the empirical convergence rate for several physical scenarios.\n\n### 1. Derivation of the Manufactured Source Term\n\nThe problem is governed by the Advection–Diffusion–Reaction (ADR) equation:\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} \\;=\\; D\\,\\frac{\\partial^2 u}{\\partial x^2} \\;-\\; k\\,u \\;+\\; s(x,t)\n$$\nThe source term $s(x,t)$ must be chosen such that the manufactured solution, $u_{\\mathrm{m}}(x,t)$, is an exact solution to this PDE. We can find $s(x,t)$ by rearranging the ADR equation and substituting $u_{\\mathrm{m}}(x,t)$:\n$$\ns(x,t) = \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} + a\\,\\frac{\\partial u_{\\mathrm{m}}}{\\partial x} - D\\,\\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} + k\\,u_{\\mathrm{m}}\n$$\nThe manufactured solution is given as:\n$$\nu_{\\mathrm{m}}(x,t) \\;=\\; \\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} \\;+\\; \\frac{1}{2}\\,x\\,(L-x)\n$$\nTo find $s(x,t)$, we first compute the necessary partial derivatives of $u_{\\mathrm{m}}(x,t)$:\n\\begin{itemize}\n    \\item Time derivative:\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial t} = -\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\n    $$\n    \\item First spatial derivative:\n    $$\n    \\frac{\\partial u_{\\mathrm{m}}}{\\partial x} = \\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\n    $$\n    \\item Second spatial derivative:\n    $$\n    \\frac{\\partial^2 u_{\\mathrm{m}}}{\\partial x^2} = -\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\n    $$\n\\end{itemize}\nSubstituting these expressions into the equation for $s(x,t)$:\n$$\ns(x,t) = \\left[-\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t}\\right] + a\\left[\\frac{2\\pi}{L}\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{L}{2} - x\\right] - D\\left[-\\left(\\frac{2\\pi}{L}\\right)^2\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} - 1\\right] + k\\left[\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\,\\mathrm{e}^{-t} + \\frac{1}{2}\\,x\\,(L-x)\\right]\n$$\nGrouping terms by their functional dependence on $x$ and $t$:\n$$\ns(x,t) = \\left(k - 1 + D\\left(\\frac{2\\pi}{L}\\right)^2\\right)\\sin\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + \\left(\\frac{2\\pi a}{L}\\right)\\cos\\!\\left(\\frac{2\\pi x}{L}\\right)\\mathrm{e}^{-t} + a\\left(\\frac{L}{2} - x\\right) + D + \\frac{k}{2}x(L-x)\n$$\nThis is the analytical expression for the source term that will be implemented in the numerical model.\n\n### 2. Numerical Discretization\n\nThe PDE is discretized on a uniform spatial grid $x_i = i h$ for $i \\in \\{0, 1, \\dots, N+1\\}$, where $h = L/(N+1)$ is the grid spacing. Time is discretized as $t_n = n \\Delta t$. We denote the numerical approximation of $u(x_i, t_n)$ as $u_i^n$.\n\nThe specified numerical scheme is:\n\\begin{itemize}\n    \\item **Time Derivative**: Forward Euler, $\\frac{\\partial u}{\\partial t} \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}$.\n    \\item **Diffusion Term**: Second-order central difference, $\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}$.\n    \\item **Advection Term**: First-order upwind difference. The form depends on the sign of the velocity $a$:\n    \\begin{itemize}\n        \\item If $a \\ge 0$ (flow to the right), a backward difference is used: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_i^n - u_{i-1}^n}{h}$.\n        \\item If $a < 0$ (flow to the left), a forward difference is used: $\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{i+1}^n - u_i^n}{h}$.\n    \\end{itemize}\n\\end{itemize}\n\nRearranging the PDE as $\\frac{\\partial u}{\\partial t} = \\dots$ and substituting the discrete approximations gives the update rule $u_i^{n+1} = u_i^n + \\Delta t (\\dots)$.\n\nFor $a \\ge 0$:\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_i^n - u_{i-1}^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\nFor $a < 0$:\n$$\nu_i^{n+1} = u_i^n + \\Delta t \\left[ D\\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2} - a\\frac{u_{i+1}^n - u_i^n}{h} - k u_i^n + s(x_i, t_n) \\right]\n$$\nThese equations are applied to all interior grid points $i \\in \\{1, 2, \\dots, N\\}$. The boundary values are fixed by the Dirichlet conditions: $u_0^{n+1} = u_{\\mathrm{m}}(0, t_{n+1}) = 0$ and $u_{N+1}^{n+1} = u_{\\mathrm{m}}(L, t_{n+1}) = 0$.\n\n### 3. Time Step and Convergence Analysis\n\nThe time step $\\Delta t$ is chosen to satisfy the explicit stability conditions for the forward Euler scheme:\n$$\n\\Delta t \\;=\\; 0.4 \\times \\min\\!\\left(\\frac{h}{|a|}, \\; \\frac{h^2}{2D}, \\; \\frac{1}{k}\\right)\n$$\nThe factor $0.4$ is a safety factor ensuring that the Courant–Friedrichs–Lewy (CFL) conditions for advection and diffusion, as well as a stability condition for the reaction term, are all met.\n\nThe simulation starts from the initial condition $u_i^0 = u_{\\mathrm{m}}(x_i, 0)$ and proceeds until the final time $T$. The accuracy of the numerical solution $u_i(T)$ is quantified by the relative discrete $L^2$ error:\n$$\nE_h \\;=\\; \\frac{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_i(T) - u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}{\\left(\\,h \\sum_{i=0}^{N+1} \\big(u_{\\mathrm{m}}(x_i,T)\\big)^2\\,\\right)^{1/2}}\n$$\nThe observed order of convergence, $p$, is estimated by computing the error for two different grid resolutions, $h_2$ (with $N_2=80$) and $h_3$ (with $N_3=160$):\n$$\np \\;=\\; \\frac{\\ln\\!\\big(E_{h_2}/E_{h_3}\\big)}{\\ln\\!\\big(h_2/h_3\\big)}\n$$\nThe numerical scheme employs first-order methods for time integration (Forward Euler) and advection (upwinding), and a second-order method for diffusion. The overall accuracy is limited by the lowest order term, so the theoretical convergence rate is expected to be $p \\approx 1$.\n\n### 4. Implementation\n\nThe algorithm is implemented in Python using the `numpy` library for efficient vectorized operations. A function is defined to run the simulation for a given set of parameters $(a, D, k)$ and grid size $N$. This function initializes the grid and the solution vector, calculates the stable time step, and iteratively updates the solution in a time loop. Within the loop, the source term is evaluated at the current time, and the appropriate upwind scheme is chosen based on the sign of $a$. After reaching the final time $T$, the function computes and returns the relative $L^2$ error. The main part of the script loops through the four test suites, calls the simulation function for $N=80$ and $N=160$, calculates the convergence rate $p$ for each suite, and prints the results in the specified format.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and prints the observed convergence rates for the ADR equation\n    solution for four different parameter sets.\n    \"\"\"\n\n    def u_manufactured(x: np.ndarray, t: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured solution u_m(x, t).\n        \"\"\"\n        term1 = np.sin(2 * np.pi * x / L) * np.exp(-t)\n        term2 = 0.5 * x * (L - x)\n        return term1 + term2\n\n    def source_manufactured(x: np.ndarray, t: float, a: float, D: float, k: float, L: float) -> np.ndarray:\n        \"\"\"\n        Calculates the manufactured source term s(x, t).\n        \"\"\"\n        pi_term = 2 * np.pi / L\n        exp_t = np.exp(-t)\n        \n        sin_term = np.sin(pi_term * x)\n        cos_term = np.cos(pi_term * x)\n        \n        # Grouping terms as derived in the solution\n        term1 = (k - 1 + D * pi_term**2) * sin_term * exp_t\n        term2 = a * pi_term * cos_term * exp_t\n        term3 = a * (L/2 - x)\n        term4 = D\n        term5 = k * 0.5 * x * (L - x)\n\n        return term1 + term2 + term3 + term4 + term5\n\n    def run_simulation(N: int, a: float, D: float, k: float, L: float, T: float) -> float:\n        \"\"\"\n        Runs one simulation for a given grid size and parameter set.\n        \n        Returns:\n            The relative discrete L2 error.\n        \"\"\"\n        # Grid setup\n        h = L / (N + 1)\n        x = np.linspace(0, L, N + 2)\n\n        # Time step calculation based on stability criteria\n        # Handle cases where denominators might be zero\n        dt_adv = h / abs(a) if a != 0 else np.inf\n        dt_diff = h**2 / (2 * D) if D != 0 else np.inf\n        dt_react = 1 / k if k != 0 else np.inf\n        \n        dt = 0.4 * min(dt_adv, dt_diff, dt_react)\n        \n        num_steps = int(np.ceil(T / dt))\n        dt = T / num_steps  # Adjust dt to hit T exactly\n\n        # Initial condition\n        u = u_manufactured(x, 0, L)\n        \n        # Time-stepping loop\n        t = 0\n        for n in range(num_steps):\n            t = n * dt\n            u_n = u.copy()\n            \n            # Evaluate source term for interior points at current time t\n            s = source_manufactured(x[1:-1], t, a, D, k, L)\n\n            # Slicing for vectorized update\n            u_interior = u_n[1:-1]\n            u_left = u_n[0:-2]\n            u_right = u_n[2:]\n\n            # Diffusion and reaction terms\n            diffusion_term = D * (u_left - 2 * u_interior + u_right) / h**2\n            reaction_term = -k * u_interior\n\n            # Advection term (upwinding)\n            if a >= 0:\n                advection_term = -a * (u_interior - u_left) / h\n            else: # a < 0\n                advection_term = -a * (u_right - u_interior) / h\n\n            # Update interior points\n            u[1:-1] = u_interior + dt * (diffusion_term + advection_term + reaction_term + s)\n\n            # Boundary conditions for the next step (t + dt) are u_m(0, t+dt) and u_m(L, t+dt)\n            # which are both 0 for all t > 0.\n            u[0] = u_manufactured(x[0], t + dt, L)\n            u[-1] = u_manufactured(x[-1], t + dt, L)\n\n        # Final time reached\n        t_final = T\n        u_exact_T = u_manufactured(x, t_final, L)\n\n        # Compute relative discrete L2 error\n        # The sqrt(h) factor in numerator and denominator can be cancelled if numpy's\n        # default L2 norm is used, but we'll implement the formula exactly for clarity.\n        err_numerator_sq = h * np.sum((u - u_exact_T)**2)\n        err_denominator_sq = h * np.sum(u_exact_T**2)\n        \n        if err_denominator_sq == 0:\n            return 0.0 if err_numerator_sq == 0 else np.inf\n            \n        error = np.sqrt(err_numerator_sq) / np.sqrt(err_denominator_sq)\n        \n        return error\n\n    def calculate_convergence_rate(params: tuple) -> float:\n        \"\"\"\n        Calculates the convergence rate for a given parameter set.\n        \"\"\"\n        a, D, k = params\n        L, T = 1.0, 0.1\n        N_vals = {'N2': 80, 'N3': 160}\n\n        h2 = L / (N_vals['N2'] + 1)\n        h3 = L / (N_vals['N3'] + 1)\n        \n        E_h2 = run_simulation(N_vals['N2'], a, D, k, L, T)\n        E_h3 = run_simulation(N_vals['N3'], a, D, k, L, T)\n        \n        # Handle cases where error might be zero\n        if E_h2 == 0 or E_h3 == 0:\n            return np.nan # Or some other indicator of non-standard convergence\n            \n        p = np.log(E_h2 / E_h3) / np.log(h2 / h3)\n        return p\n\n    # Test suite from the problem statement\n    test_cases = [\n        (0.05, 1.0e-3, 0.1),    # Set A: diffusion-dominated\n        (1.0, 1.0e-4, 0.1),     # Set B: advection-dominated, positive a\n        (-1.0, 1.0e-4, 0.1),    # Set C: advection-dominated, negative a\n        (0.01, 1.0e-4, 5.0),    # Set D: reaction-dominated\n    ]\n\n    results = []\n    for case in test_cases:\n        p = calculate_convergence_rate(case)\n        results.append(p)\n\n    # Format output as specified: [p_A,p_B,p_C,p_D] rounded to 3 decimal places.\n    print(f\"[{','.join([f'{r:.3f}' for r in results])}]\")\n\nsolve()\n```"
        }
    ]
}