{
    "hands_on_practices": [
        {
            "introduction": "Before we can calculate chemical equilibrium, we must first describe the system in a way a computer can process. This involves representing the elemental composition of each chemical species as a vector, and the entire system as a stoichiometric matrix, $\\mathbf{A}$. This practice  introduces a robust numerical method, QR decomposition with column pivoting, to automatically select a linearly independent set of \"basis species\" that span all possible compositions. Mastering this technique is a crucial first step in building a reliable geochemical solver, as it correctly formulates the algebraic structure of the problem and ensures numerical stability.",
            "id": "4069180",
            "problem": "You are given a stoichiometric matrix $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$ where each column encodes the elemental composition of a chemical species in terms of $m$ conserved elements, and there are $n$ total species (primary species and complexes). In algorithms for equilibrium calculations in computational geochemistry, it is often necessary to select a set of basis species (a subset of columns of $\\mathbf{A}$) that spans the column space of $\\mathbf{A}$ and then express every complex as a linear combination of these basis species consistent with elemental conservation.\n\nStarting from the fundamental laws of mass conservation and the definition of the column space in linear algebra, construct an algorithm to:\n\n- Select a basis species set from the column space of $\\mathbf{A}$ using QR decomposition with column pivoting that is numerically robust to near dependencies.\n- Derive, for any subset of complexes, a mapping that expresses each complex's elemental composition vector as a linear combination of the selected basis species. That is, for each complex with column vector $\\mathbf{a}_j \\in \\mathbb{R}^m$, determine coefficients $\\mathbf{c}_j \\in \\mathbb{R}^r$ such that $\\mathbf{a}_j$ lies in the span of the selected $r$ basis columns, with all computations done in double precision.\n\nYour program must implement the above for the following test suite. For each test case, you are provided a specific $\\mathbf{A}$ and a list of complex column indices. Indices refer to zero-based positions of species columns. For each complex listed, compute the coefficient vector $\\mathbf{c}_j$ relative to the selected basis species and round each coefficient to $6$ decimal places.\n\nTest Suite:\n\n- Test Case $1$ (Happy path; carbonate system):\n  Elements ordered as [$\\mathrm{H}$, $\\mathrm{O}$, $\\mathrm{C}$] with species ordered as [$\\mathrm{H}^+$, $\\mathrm{OH}^-$, $\\mathrm{H_2O}$, $\\mathrm{HCO_3^-}$, $\\mathrm{CO_3^{2-}}$, $\\mathrm{CO_2(aq)}$].\n  The stoichiometric matrix $\\mathbf{A}_1 \\in \\mathbb{R}^{3 \\times 6}$ is\n  $$\n  \\mathbf{A}_1 =\n  \\begin{bmatrix}\n  1  1  2  1  0  0 \\\\\n  0  1  1  3  3  2 \\\\\n  0  0  0  1  1  1\n  \\end{bmatrix}.\n  $$\n  Complex indices to map: $[2, 3, 4]$ (i.e., $\\mathrm{H_2O}$, $\\mathrm{HCO_3^-}$, $\\mathrm{CO_3^{2-}}$).\n\n- Test Case $2$ (Boundary; duplicate composition):\n  Elements ordered as [$\\mathrm{H}$, $\\mathrm{O}$, $\\mathrm{C}$] with species ordered as [$\\mathrm{H}^+$, $\\mathrm{OH}^-$, $\\mathrm{H_2O}$, `H_2O_dup`].\n  The stoichiometric matrix $\\mathbf{A}_2 \\in \\mathbb{R}^{3 \\times 4}$ is\n  $$\n  \\mathbf{A}_2 =\n  \\begin{bmatrix}\n  1  1  2  2 \\\\\n  0  1  1  1 \\\\\n  0  0  0  0\n  \\end{bmatrix}.\n  $$\n  Complex indices to map: $[3]$ (i.e., `H_2O_dup`).\n\n- Test Case $3$ (Edge case; numerical noise):\n  Elements ordered as [$\\mathrm{H}$, $\\mathrm{O}$, $\\mathrm{C}$] with species ordered as [$\\mathrm{H}^+$, $\\mathrm{OH}^-$, $\\mathrm{CO_2}$, `CO_2_noisy`, $\\mathrm{H_2O}$].\n  The stoichiometric matrix $\\mathbf{A}_3 \\in \\mathbb{R}^{3 \\times 5}$ is\n  $$\n  \\mathbf{A}_3 =\n  \\begin{bmatrix}\n  1  1  0  0  2 \\\\\n  0  1  2  2 + 10^{-12}  1 \\\\\n  0  0  1  1  0\n  \\end{bmatrix}.\n  $$\n  Complex indices to map: $[3]$ (i.e., `CO_2_noisy`).\n\nAlgorithmic Requirements:\n\n- Use QR decomposition with column pivoting to select a numerically stable set of basis species from the columns of $\\mathbf{A}$; determine the numerical rank $r$ using a tolerance based on machine precision and the scale of the triangular factor.\n- For each complex index $j$ provided, solve the consistent linear system that enforces elemental conservation to obtain $\\mathbf{c}_j$ with respect to the selected basis. Use a method based on triangular solves derived from QR or an equivalent stable least-squares approach suitable for full column rank systems.\n- Round each coefficient to $6$ decimal places.\n\nFinal Output Specification:\n\n- For each test case, output a list of lists. Each inner list contains the rounded coefficients for a complex in the order given by the complex indices, expressed in the order of the selected basis species determined by pivoted QR (i.e., the basis order is the pivot order of the first $r$ columns).\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[ \\text{result1}, \\text{result2}, \\text{result3} ]$), where each $\\text{result}$ is itself a list of lists of floats corresponding to that test case.\n- No physical units are involved in this computation, and no angles or percentages are used.\n\nAll computations must be performed in double precision. The program must be fully self-contained and produce the described single-line output without any user input, external files, or network access.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of chemical stoichiometry and linear algebra, well-posed with a clear objective and sufficient data, and objective in its formulation. We can proceed with a solution.\n\nThe fundamental principle governing chemical systems at equilibrium is the conservation of mass. In the context of geochemistry, this means the total amount of each fundamental element (e.g., Carbon, Hydrogen, Oxygen) remains constant, regardless of how these elements are distributed among various aqueous species, gases, or minerals. This conservation law can be elegantly expressed using the language of linear algebra.\n\nLet us define a system with $m$ conserved elements and $n$ chemical species. The elemental composition of each species $j$ can be represented by a column vector $\\mathbf{a}_j \\in \\mathbb{R}^m$, where the $i$-th component of the vector, $(\\mathbf{a}_j)_i$, is the number of atoms of element $i$ in one mole of species $j$. The collection of these vectors for all $n$ species forms the columns of the stoichiometric matrix $\\mathbf{A} \\in \\mathbb{R}^{m \\times n}$, where $\\mathbf{A} = [\\mathbf{a}_1, \\mathbf{a}_2, \\dots, \\mathbf{a}_n]$.\n\nAny chemical reaction involving these species is a statement of linear dependence among the columns of $\\mathbf{A}$. For example, the reaction $\\mathrm{H}^+ + \\mathrm{OH}^- \\rightleftharpoons \\mathrm{H_2O}$ corresponds to the vector equation $\\mathbf{a}_{\\mathrm{H}^+} + \\mathbf{a}_{\\mathrm{OH}^-} - \\mathbf{a}_{\\mathrm{H_2O}} = \\mathbf{0}$. The set of all possible stoichiometries of reactions and compositions in the system is spanned by the columns of $\\mathbf{A}$, which defines the column space, $\\mathrm{Col}(\\mathbf{A})$.\n\nTo computationally manage the system, it is efficient to select a minimal set of species, called basis species, from which all other species, called complexes or secondary species, can be formed. Mathematically, this is equivalent to finding a basis for the column space $\\mathrm{Col}(\\mathbf{A})$. A basis is a set of linearly independent vectors that spans the entire space. The number of vectors in this basis is the dimension of the column space, which is the rank of the matrix $\\mathbf{A}$, denoted as $r = \\mathrm{rank}(\\mathbf{A})$.\n\nThe problem requires an algorithm to first select a set of $r$ basis species and then express any given complex as a linear combination of this basis.\n\nStep 1: Basis Selection and Rank Determination\n\nA numerically robust method for finding a basis for the column space of a matrix is the QR decomposition with column pivoting. This algorithm decomposes the stoichiometric matrix $\\mathbf{A}$ such that $\\mathbf{A}\\mathbf{P} = \\mathbf{Q}\\mathbf{R}$, where:\n- $\\mathbf{P}$ is a permutation matrix of size $n \\times n$ that reorders the columns of $\\mathbf{A}$. The permutation is chosen to prioritize columns that are most linearly independent.\n- $\\mathbf{Q}$ is an orthogonal matrix of size $m \\times m$ (i.e., $\\mathbf{Q}^T\\mathbf{Q} = \\mathbf{I}$).\n- $\\mathbf{R}$ is an upper triangular matrix of size $m \\times n$.\n\nThe column pivoting ensures that the diagonal elements of $\\mathbf{R}$ appear in decreasing order of magnitude: $|\\mathbf{R}_{11}| \\ge |\\mathbf{R}_{22}| \\ge \\dots$. Due to finite precision arithmetic, some columns may be nearly linearly dependent. The numerical rank $r$ can be determined by finding the point where the diagonal elements of $\\mathbf{R}$ become negligible. A common tolerance, $\\tau$, is used for this purpose, defined relative to the magnitude of the largest element and machine precision, $\\epsilon$:\n$$ \\tau = \\max(m, n) \\cdot |\\mathbf{R}_{11}| \\cdot \\epsilon $$\nThe rank $r$ is the count of diagonal elements $|\\mathbf{R}_{kk}|$ such that $|\\mathbf{R}_{kk}|  \\tau$.\n\nThe first $r$ columns of the permuted matrix $\\mathbf{A}\\mathbf{P}$ constitute a well-conditioned basis for $\\mathrm{Col}(\\mathbf{A})$. These columns correspond to the chosen basis species. If the permutation matrix $\\mathbf{P}$ is represented by a vector of indices $\\mathbf{p}$, the indices of the basis species in the original matrix $\\mathbf{A}$ are given by the first $r$ elements of $\\mathbf{p}$. The basis matrix $\\mathbf{B}$ is then constructed by taking these $r$ columns from $\\mathbf{A}$:\n$$ \\mathbf{B} = \\mathbf{A}_{:, \\mathbf{p}(1:r)} \\in \\mathbb{R}^{m \\times r} $$\n\nStep 2: Expressing Complexes in the Basis\n\nOnce the basis matrix $\\mathbf{B}$ is established, any complex represented by its composition vector $\\mathbf{a}_j$ (which is a column of $\\mathbf{A}$) can be expressed as a linear combination of the basis vectors. We seek a coefficient vector $\\mathbf{c}_j \\in \\mathbb{R}^r$ such that:\n$$ \\mathbf{B} \\mathbf{c}_j = \\mathbf{a}_j $$\nThis is a system of linear equations. Since the columns of $\\mathbf{B}$ form a basis for $\\mathrm{Col}(\\mathbf{A})$ and $\\mathbf{a}_j \\in \\mathrm{Col}(\\mathbf{A})$, a unique solution for $\\mathbf{c}_j$ is guaranteed to exist. The system may be overdetermined if $m  r$, but it will be consistent.\n\nA stable method for solving this system is to find the least-squares solution to $\\min_{\\mathbf{c}_j} \\|\\mathbf{B} \\mathbf{c}_j - \\mathbf{a}_j\\|_2$. Because the system is consistent, the minimum residual will be zero (within machine precision). This can be robustly solved using the QR decomposition of $\\mathbf{B}$ or by functions purpose-built for least-squares problems, such as `scipy.linalg.lstsq` in Python. The resulting vector $\\mathbf{c}_j$ contains the stoichiometric coefficients that express the complex $j$ in terms of the ordered basis species.\n\nThe implemented algorithm will follow these two steps for each test case, providing the coefficient vectors rounded to the specified precision.",
            "answer": "```python\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the final result.\n    \"\"\"\n\n    def process_case(A, complex_indices, precision=6):\n        \"\"\"\n        Selects a basis for the column space of A using pivoted QR, and for each\n        specified complex, computes the coefficients of its linear combination \n        in terms of that basis.\n\n        Args:\n            A (np.ndarray): The stoichiometric matrix.\n            complex_indices (list[int]): A list of column indices for the complexes to map.\n            precision (int): The number of decimal places to round the coefficients to.\n\n        Returns:\n            list[list[float]]: A list of coefficient vectors, one for each complex.\n        \"\"\"\n        # Ensure A is a double precision floating point array\n        A = np.array(A, dtype=np.float64)\n        m, n = A.shape\n\n        if m == 0 or n == 0:\n            # Handle empty matrix case\n            return [[] for _ in complex_indices]\n\n        # Step 1: Perform QR decomposition with column pivoting\n        Q, R, P = linalg.qr(A, pivoting=True)\n\n        # Step 2: Determine the numerical rank\n        # A standard tolerance is based on the matrix dimensions, machine epsilon,\n        # and the magnitude of the first diagonal element of R.\n        if abs(R[0, 0])  np.finfo(A.dtype).eps:\n            rank = 0\n        else:\n            tol = np.abs(R[0, 0]) * max(m, n) * np.finfo(A.dtype).eps\n            rank = np.sum(np.abs(np.diag(R)) > tol)\n\n        # If rank is 0, the matrix is effectively a zero matrix.\n        if rank == 0:\n            # A zero vector is the only thing in the span. The only valid complex\n            # is the zero vector, and its coefficient vector would be empty as there's no basis.\n            return [[] for _ in complex_indices]\n\n        # Step 3: Select the basis matrix B using the first 'rank' pivot indices.\n        # The basis species are ordered according to the pivot order.\n        basis_indices = P[:rank]\n        basis_matrix = A[:, basis_indices]\n        \n        # Step 4: For each complex, solve for its coefficients in the chosen basis.\n        all_complex_coeffs = []\n        for idx in complex_indices:\n            complex_vector = A[:, idx]\n            \n            # Solve the linear system B * c = a_j using a robust least-squares solver.\n            # Since a_j is in the column space of B, the least-squares solution is exact.\n            # The first element returned by lstsq is the coefficient vector.\n            c, _, _, _ = linalg.lstsq(basis_matrix, complex_vector)\n            \n            # Round the coefficients to the specified precision\n            rounded_c = np.round(c, precision).tolist()\n            all_complex_coeffs.append(rounded_c)\n            \n        return all_complex_coeffs\n\n    # Test Case 1: Happy path; carbonate system\n    A1 = np.array([\n        [1, 1, 2, 1, 0, 0],\n        [0, 1, 1, 3, 3, 2],\n        [0, 0, 0, 1, 1, 1]\n    ])\n    complex_indices_1 = [2, 3, 4]\n\n    # Test Case 2: Boundary; duplicate composition\n    A2 = np.array([\n        [1, 1, 2, 2],\n        [0, 1, 1, 1],\n        [0, 0, 0, 0]\n    ])\n    complex_indices_2 = [3]\n\n    # Test Case 3: Edge case; numerical noise\n    A3 = np.array([\n        [1, 1, 0, 0, 2],\n        [0, 1, 2, 2 + 1e-12, 1],\n        [0, 0, 1, 1, 0]\n    ])\n    complex_indices_3 = [3]\n\n    test_cases = [\n        (A1, complex_indices_1),\n        (A2, complex_indices_2),\n        (A3, complex_indices_3)\n    ]\n\n    results = []\n    for A_case, indices_case in test_cases:\n        result = process_case(A_case, indices_case)\n        results.append(result)\n\n    # Format the final output string exactly as specified.\n    # Convert each test case's result (a list of lists) to its string representation,\n    # remove spaces, and join them with commas.\n    formatted_results = [str(r).replace(\" \", \"\") for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "With a well-defined mathematical basis, the chemical equilibrium problem reduces to solving a system of non-linear algebraic equations derived from the law of mass action. This practice  challenges you to solve these equations for simple, ideal systems using the powerful Newton-Raphson method. By first deriving the exact analytical solutions for these test cases, you will gain deep insight into the structure of the equilibrium problem and establish a definitive benchmark to verify the correctness and accuracy of your numerical solver—a fundamental skill in computational science.",
            "id": "4069193",
            "problem": "You are tasked to derive analytical solutions for two simple, ideal systems used in computational geochemistry, and to implement an algorithmic solver that verifies its numerical accuracy against the closed-form results for a small test suite. All calculations must be framed in terms of the chemical equilibrium conditions derived from fundamental thermodynamic laws and ideal solution theory, without relying on shortcut formulas provided in this statement. The systems are as follows.\n\nSystem A: Ideal binary isomerization, $\\mathrm{A} \\rightleftharpoons \\mathrm{B}$. Consider a closed, isothermal, isobaric, well-mixed system with total amount $N$ (in moles) containing species $\\mathrm{A}$ and $\\mathrm{B}$ undergoing $\\mathrm{A} \\rightleftharpoons \\mathrm{B}$. Assume ideal-solution thermodynamics with activities equal to mole fractions, and that the equilibrium constant $K$ is defined in the mole-fraction standard state (dimensionless). The system starts at $n_{\\mathrm{A}}(0) = N$ and $n_{\\mathrm{B}}(0) = 0$. From the equality of chemical potentials at equilibrium for the reaction extent, derive the analytical equilibrium mole amounts $n_{\\mathrm{A}}^\\star$ and $n_{\\mathrm{B}}^\\star$ based on the fundamental relations for chemical potentials $\\mu_i = \\mu_i^\\circ + RT \\ln a_i$, the stoichiometric reaction condition, and the law of mass action in ideal solutions. Then, implement a numerical solver using the Newton method for the reaction extent that enforces the appropriate equilibrium condition in terms of the reaction quotient and $K$, subject to nonnegativity constraints on mole amounts.\n\nSystem B: Ideal aqueous monoprotic acid dissociation, $\\mathrm{HA} \\rightleftharpoons \\mathrm{H}^+ + \\mathrm{A}^-$. Consider an aqueous solution at constant temperature and pressure, with a total analytical concentration $C$ (in $\\mathrm{mol}/\\mathrm{L}$) of a monoprotic acid $\\mathrm{HA}$. Assume ideal-solution activities equal to molar concentrations, and neglect autoionization of water and any other electrolytes. Using the mass balance for the acid, electroneutrality, and the equilibrium law based on $\\mu_i = \\mu_i^\\circ + RT \\ln a_i$, derive an analytical expression for the equilibrium concentration $[\\mathrm{H}^+]^\\star$ in $\\mathrm{mol}/\\mathrm{L}$ given the acid dissociation constant $K_a$ (dimensionless under the chosen concentration standard state). Then, implement a Newton solver for the nonnegative root of the equation implied by the mass balance and law-of-mass-action constraints, subject to the constraint $0 \\le [\\mathrm{H}^+] \\le C$.\n\nYour program must:\n- Implement a robust Newton method with clamping to physically admissible domains for each system and verify convergence.\n- Compute, for each test case, the absolute difference between the numerical solution produced by your solver and the derived closed-form analytical solution. For System A, compute the maximum of the absolute errors in the two species’ equilibrium mole amounts. For System B, compute the absolute error in $[\\mathrm{H}^+]$ in $\\mathrm{mol}/\\mathrm{L}$.\n- Express mole amounts in moles and concentrations in $\\mathrm{mol}/\\mathrm{L}$. The output of your program must be these absolute errors (unit-consistent with the quantity being compared) as floating-point numbers.\n\nUse the following test suite of parameter values:\n- System A (ideal binary isomerization):\n  - Case A1: $N = 1.0$ (moles), $K = 2.0$.\n  - Case A2: $N = 1.0$ (moles), $K = 10^{-12}$.\n  - Case A3: $N = 1.0$ (moles), $K = 10^{12}$.\n- System B (ideal aqueous monoprotic acid):\n  - Case B1: $C = 0.01$ ($\\mathrm{mol}/\\mathrm{L}$), $K_a = 1.8 \\times 10^{-5}$.\n  - Case B2: $C = 0.1$ ($\\mathrm{mol}/\\mathrm{L}$), $K_a = 10.0$.\n  - Case B3: $C = 1.0$ ($\\mathrm{mol}/\\mathrm{L}$), $K_a = 10^{-9}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[result1,result2,result3,result4,result5,result6]\"), where the elements appear in the same order as the test cases above: A1, A2, A3, B1, B2, B3. Each element must be a floating-point number. No other text should be printed.",
            "solution": "The problem is valid. It is scientifically grounded in the principles of chemical thermodynamics, mathematically well-posed, and free of ambiguity or contradiction. It presents a standard, verifiable problem in computational geochemistry.\n\nThe derivation of analytical solutions and the formulation of the numerical problem for each system are presented below.\n\n**System A: Ideal Binary Isomerization**\n\nThe system is defined by the reaction $\\mathrm{A} \\rightleftharpoons \\mathrm{B}$ in a closed system with a total of $N$ moles.\n\n1.  **Stoichiometry and Mass Balance**: Let $\\xi$ be the extent of reaction in moles, representing the number of moles of $\\mathrm{A}$ that have converted to $\\mathrm{B}$. Given the initial conditions $n_{\\mathrm{A}}(0) = N$ and $n_{\\mathrm{B}}(0) = 0$, the mole amounts at any extent $\\xi$ are:\n    $$n_{\\mathrm{A}}(\\xi) = n_{\\mathrm{A}}(0) - \\xi = N - \\xi$$\n    $$n_{\\mathrm{B}}(\\xi) = n_{\\mathrm{B}}(0) + \\xi = \\xi$$\n    The total moles in the system, $n_{\\mathrm{T}} = n_{\\mathrm{A}} + n_{\\mathrm{B}} = (N - \\xi) + \\xi = N$, remain constant. The physical constraints on mole amounts, $n_{\\mathrm{A}} \\ge 0$ and $n_{\\mathrm{B}} \\ge 0$, require that the reaction extent $\\xi$ be bounded: $0 \\le \\xi \\le N$.\n\n2.  **Thermodynamic Equilibrium Condition**: At equilibrium, the Gibbs free energy of the reaction is zero, which implies that the chemical potentials of the reactants and products are balanced according to the reaction stoichiometry:\n    $$\\sum_{i} \\nu_i \\mu_i = 0$$\n    For this reaction, the stoichiometric coefficients are $\\nu_{\\mathrm{A}} = -1$ and $\\nu_{\\mathrm{B}} = 1$. The equilibrium condition is therefore $\\mu_{\\mathrm{B}} - \\mu_{\\mathrm{A}} = 0$, or $\\mu_{\\mathrm{A}} = \\mu_{\\mathrm{B}}$.\n\n3.  **Law of Mass Action**: The chemical potential of a species $i$ in an ideal solution is given by $\\mu_i = \\mu_i^\\circ + RT \\ln a_i$, where $\\mu_i^\\circ$ is the standard state chemical potential, $R$ is the ideal gas constant, $T$ is the absolute temperature, and $a_i$ is the activity of species $i$. Substituting this into the equilibrium condition:\n    $$\\mu_{\\mathrm{A}}^\\circ + RT \\ln a_{\\mathrm{A}} = \\mu_{\\mathrm{B}}^\\circ + RT \\ln a_{\\mathrm{B}}$$\n    Rearranging gives $\\mu_{\\mathrm{B}}^\\circ - \\mu_{\\mathrm{A}}^\\circ = -RT \\ln(a_{\\mathrm{B}}/a_{\\mathrm{A}})$. The standard Gibbs free energy of reaction is $\\Delta G^\\circ = \\mu_{\\mathrm{B}}^\\circ - \\mu_{\\mathrm{A}}^\\circ$, and it is related to the equilibrium constant $K$ by $\\Delta G^\\circ = -RT \\ln K$. Equating these expressions yields the law of mass action:\n    $$K = \\frac{a_{\\mathrm{B}}}{a_{\\mathrm{A}}}$$\n\n4.  **Analytical Solution**: For an ideal solution, activities are equal to mole fractions, $a_i = x_i = n_i / n_{\\mathrm{T}}$. Substituting the expressions for mole amounts and $n_{\\mathrm{T}} = N$:\n    $$K = \\frac{x_{\\mathrm{B}}}{x_{\\mathrm{A}}} = \\frac{n_{\\mathrm{B}}/N}{n_{\\mathrm{A}}/N} = \\frac{n_{\\mathrm{B}}}{n_{\\mathrm{A}}} = \\frac{\\xi}{N - \\xi}$$\n    Solving for the equilibrium extent, $\\xi^\\star$:\n    $$K(N - \\xi^\\star) = \\xi^\\star \\implies KN - K\\xi^\\star = \\xi^\\star \\implies KN = \\xi^\\star(1 + K)$$\n    $$\\xi^\\star = \\frac{KN}{1 + K}$$\n    The equilibrium mole amounts, $n_{\\mathrm{A}}^\\star$ and $n_{\\mathrm{B}}^\\star$, are:\n    $$n_{\\mathrm{A}}^\\star = N - \\xi^\\star = N - \\frac{KN}{1 + K} = \\frac{N(1 + K) - KN}{1 + K} = \\frac{N}{1 + K}$$\n    $$n_{\\mathrm{B}}^\\star = \\xi^\\star = \\frac{KN}{1 + K}$$\n\n5.  **Numerical Solver Formulation**: The Newton-Raphson method is used to find the root of the residual function $f(\\xi) = 0$, where $f(\\xi)$ represents the equilibrium condition. We define $f(\\xi)$ based on the reaction quotient, $Q(\\xi) = \\xi/(N-\\xi)$:\n    $$f(\\xi) = \\frac{\\xi}{N-\\xi} - K = 0$$\n    The derivative with respect to $\\xi$ is:\n    $$f'(\\xi) = \\frac{d}{d\\xi} \\left( \\frac{\\xi}{N-\\xi} - K \\right) = \\frac{(1)(N-\\xi) - (\\xi)(-1)}{(N-\\xi)^2} = \\frac{N}{(N-\\xi)^2}$$\n    The Newton iteration is $\\xi_{k+1} = \\xi_k - f(\\xi_k)/f'(\\xi_k)$. Iterates must be clamped to the physical domain $(0, N)$ to prevent division by zero and maintain physical realism.\n\n**System B: Ideal Aqueous Monoprotic Acid Dissociation**\n\nThe system is defined by the reaction $\\mathrm{HA} \\rightleftharpoons \\mathrm{H}^+ + \\mathrm{A}^-$.\n\n1.  **Stoichiometry and Mass/Charge Balance**: Let $x$ be the equilibrium concentration of hydrogen ions, $x = [\\mathrm{H}^+]^\\star$.\n    -   **Charge Balance**: Neglecting water autoionization, the only ions are $\\mathrm{H}^+$ and $\\mathrm{A}^-$. Electroneutrality requires $[\\mathrm{H}^+] = [\\mathrm{A}^-]$. Therefore, $[\\mathrm{A}^-]^\\star = x$.\n    -   **Mass Balance**: The total concentration of the acid moiety, $C$, is distributed between the protonated form, $\\mathrm{HA}$, and the deprotonated form, $\\mathrm{A}^-$. Thus, $C = [\\mathrm{HA}] + [\\mathrm{A}^-]$.\n    -   From these relations, we find the equilibrium concentration of the undissociated acid: $[\\mathrm{HA}]^\\star = C - [\\mathrm{A}^-]^\\star = C - x$.\n    -   Physical constraints require all concentrations to be non-negative, which implies $0 \\le x \\le C$.\n\n2.  **Law of Mass Action**: The derivation is analogous to System A, leading to the expression for the acid dissociation constant, $K_a$:\n    $$K_a = \\frac{a_{\\mathrm{H}^+} a_{\\mathrm{A}^-}}{a_{\\mathrm{HA}}}$$\n\n3.  **Analytical Solution**: The problem states to assume activities are equal to molar concentrations, $a_i = [i]$. Substituting the expressions for equilibrium concentrations in terms of $x$:\n    $$K_a = \\frac{[\\mathrm{H}^+][\\mathrm{A}^-]}{[\\mathrm{HA}]} = \\frac{(x)(x)}{C - x} = \\frac{x^2}{C - x}$$\n    Rearranging this into a standard quadratic form $ax^2+bx+c=0$:\n    $$K_a(C-x) = x^2 \\implies K_aC - K_ax = x^2 \\implies x^2 + K_ax - K_aC = 0$$\n    Using the quadratic formula, $x = \\frac{-b \\pm \\sqrt{b^2-4ac}}{2a}$, with $a=1$, $b=K_a$, and $c=-K_aC$:\n    $$x = \\frac{-K_a \\pm \\sqrt{K_a^2 - 4(1)(-K_aC)}}{2} = \\frac{-K_a \\pm \\sqrt{K_a^2 + 4K_aC}}{2}$$\n    Since concentration $x$ must be positive, we take the positive root:\n    $$[\\mathrm{H}^+]^\\star = x = \\frac{-K_a + \\sqrt{K_a^2 + 4K_aC}}{2}$$\n\n4.  **Numerical Solver Formulation**: We seek the root of the residual function $f(x) = 0$ derived from the quadratic equation, which is numerically more stable than the fractional form.\n    $$f(x) = x^2 + K_ax - K_aC = 0$$\n    The derivative with respect to $x$ is:\n    $$f'(x) = 2x + K_a$$\n    The Newton iteration is $x_{k+1} = x_k - f(x_k)/f'(x_k)$. Iterates are clamped to the physical domain $[0, C]$. For $x \\ge 0$ and $K_a  0$, the derivative $f'(x)$ is always positive, and the function $f(x)$ is convex, ensuring robust convergence for the Newton method.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef newton_solver(f, f_prime, x0, tol=1e-15, max_iter=100, x_min=-np.inf, x_max=np.inf):\n    \"\"\"\n    A robust Newton-Raphson solver with clamping.\n    \"\"\"\n    x = float(x0)\n    for _ in range(max_iter):\n        fx = f(x)\n        if abs(fx)  tol:\n            return x\n\n        fpx = f_prime(x)\n        # Avoid division by zero or a very small number if derivative is flat\n        if abs(fpx)  1e-20:\n            return x\n        \n        step = fx / fpx\n        x_next = x - step\n        \n        # Clamp the next iterate to the physically valid domain\n        if x_next  x_min:\n            x_next = x_min\n        if x_next > x_max:\n            x_next = x_max\n\n        # Check for convergence based on step size, after the first iteration\n        if _ > 0 and abs(x_next - x)  tol:\n             return x_next\n\n        x = x_next\n    \n    return x\n\ndef calculate_error_A(N, K):\n    \"\"\"\n    Calculates the error for System A: Ideal binary isomerization.\n    \n    Args:\n        N (float): Total moles in the system.\n        K (float): Dimensionless equilibrium constant.\n        \n    Returns:\n        float: The maximum absolute error between analytical and numerical mole amounts.\n    \"\"\"\n    # 1. Analytical Solution\n    n_A_analytical = N / (1.0 + K)\n    n_B_analytical = K * N / (1.0 + K)\n\n    # 2. Numerical Solution using Newton's method for reaction extent xi\n    # The residual function is f(xi) = Q - K = xi / (N - xi) - K = 0\n    f = lambda xi: xi / (N - xi) - K if (N - xi) != 0 else np.inf\n    # The derivative is f'(xi) = N / (N - xi)^2\n    f_prime = lambda xi: N / (N - xi)**2 if (N - xi) != 0 else np.inf\n\n    # A small epsilon to keep xi away from the singular boundaries of the domain (0, N)\n    epsilon = 1e-15 \n    # Initial guess in the middle of the domain is robust\n    xi_0 = N / 2.0\n\n    xi_numerical = newton_solver(\n        f, f_prime, xi_0, x_min=epsilon, x_max=N - epsilon\n    )\n    \n    n_A_numerical = N - xi_numerical\n    n_B_numerical = xi_numerical\n\n    # 3. Compute error\n    error = max(abs(n_A_analytical - n_A_numerical), abs(n_B_analytical - n_B_numerical))\n    return error\n\ndef calculate_error_B(C, Ka):\n    \"\"\"\n    Calculates the error for System B: Ideal monoprotic acid dissociation.\n    \n    Args:\n        C (float): Total analytical concentration of the acid (mol/L).\n        Ka (float): Dimensionless acid dissociation constant.\n        \n    Returns:\n        float: The absolute error between analytical and numerical [H+].\n    \"\"\"\n    # 1. Analytical Solution\n    # From x^2 + Ka*x - Ka*C = 0, where x = [H+]\n    h_plus_analytical = (-Ka + np.sqrt(Ka**2 + 4.0 * Ka * C)) / 2.0\n\n    # 2. Numerical Solution using Newton's method for x = [H+]\n    # The residual function is f(x) = x^2 + Ka*x - Ka*C = 0\n    f = lambda x: x**2 + Ka * x - Ka * C\n    # The derivative is f'(x) = 2*x + Ka\n    f_prime = lambda x: 2.0 * x + Ka\n\n    # Initial guess can be 0, as f'(0)=Ka > 0, so it's a safe starting point.\n    x_0 = 0.0\n\n    h_plus_numerical = newton_solver(\n        f, f_prime, x_0, x_min=0.0, x_max=C\n    )\n\n    # 3. Compute error\n    error = abs(h_plus_analytical - h_plus_numerical)\n    return error\n\ndef solve():\n    \"\"\"\n    Main function to run test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # System A: (system_type, N, K)\n        ('A', 1.0, 2.0),\n        ('A', 1.0, 1.0e-12),\n        ('A', 1.0, 1.0e12),\n        # System B: (system_type, C, Ka)\n        ('B', 0.01, 1.8e-5),\n        ('B', 0.1, 10.0),\n        ('B', 1.0, 1.0e-9),\n    ]\n\n    results = []\n    for case in test_cases:\n        system_type = case[0]\n        if system_type == 'A':\n            N, K = case[1], case[2]\n            error = calculate_error_A(N, K)\n            results.append(error)\n        elif system_type == 'B':\n            C, Ka = case[1], case[2]\n            error = calculate_error_B(C, Ka)\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    # We use exponential notation to represent a floating point number with high precision.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Real geochemical systems often involve multiple phases, such as minerals precipitating from an aqueous solution. Unlike continuously present dissolved species, a mineral phase only appears when the solution becomes supersaturated. This \"on-off\" physical behavior is described not by simple equations, but by a set of inequality constraints. This practice  guides you through formulating these constraints using the saturation index ($SI$) and the principles of complementarity, where a mineral can only exist ($n_s \\gt 0$) if the solution is exactly saturated ($SI = 0$). You will then implement a sophisticated penalty method to solve this problem, a powerful technique essential for modeling systems with phase boundaries like mineral precipitation and dissolution.",
            "id": "4069227",
            "problem": "You are asked to formalize inequality constraints on mineral saturation indices and implement a penalty-based algorithm to enforce them within a chemically consistent equilibrium calculation. Consider a single, sparingly soluble mineral with the dissolution/precipitation reaction written in terms of aqueous ionic components. For concreteness, let the reaction be between a divalent cation and a divalent anion, with chemical formulae denoted as generic species without further acid-base speciation. The activities are taken equal to molalities, consistent with a low ionic strength approximation.\n\nUse the following base definitions, which must be treated as foundational facts:\n- The Ion Activity Product (IAP) is defined as $IAP = a_{\\mathrm{cat}} a_{\\mathrm{an}}$, which under the activity equal to molality approximation becomes $IAP = m_{\\mathrm{cat}} m_{\\mathrm{an}}$.\n- The equilibrium constant (solubility product) is $K$, with consistent units so that $IAP$ and $K$ are dimensionally comparable.\n- The saturation index is defined as $SI = \\log_{10}(IAP) - \\log_{10}(K)$.\n- Mass balance for the precipitation reaction is $m_{\\mathrm{cat}} + n_s = T_{\\mathrm{cat}}$ and $m_{\\mathrm{an}} + n_s = T_{\\mathrm{an}}$, where $n_s \\ge 0$ is the amount of precipitated solid per unit mass of solvent, and $T_{\\mathrm{cat}}$, $T_{\\mathrm{an}}$ are the total dissolved amounts supplied to the system.\n\nThe inequality and complementarity conditions for equilibrium between the aqueous solution and the precipitating mineral are:\n- $SI \\le 0$,\n- $n_s \\ge 0$,\n- $n_s \\cdot SI = 0$.\n\nThese encode the following physical logic: if $SI  0$ (supersaturation), precipitation proceeds so that $SI \\to 0$ with $n_s  0$, whereas if $SI  0$ (undersaturation), no precipitation occurs, so $n_s = 0$. Precisely at saturation, $SI = 0$, either $n_s = 0$ or $n_s  0$ is admissible depending on the pathway.\n\nTask:\n1. Starting from the mass balance relations and the definition of the saturation index, express $SI$ and the feasible domain of $n_s$ purely in terms of $T_{\\mathrm{cat}}$, $T_{\\mathrm{an}}$, and $K$. Show that the feasible interval is $n_s \\in [0, \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})]$ and that $SI(n_s) = \\log_{10}\\left((T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s)\\right) - \\log_{10}(K)$.\n2. Derive a penalty formulation that enforces the complementarity conditions $n_s \\ge 0$, $-SI \\ge 0$, and $n_s \\cdot (-SI) = 0$. Use the Fischer–Burmeister function, defined for nonnegative variables $a$ and $b$ as $\\phi_{\\mathrm{FB}}(a,b) = \\sqrt{a^2 + b^2} - (a + b)$. Propose the objective $\\Phi(n_s) = \\lambda \\, \\phi_{\\mathrm{FB}}(n_s, -SI(n_s))^2$ with a positive scaling parameter $\\lambda$, and argue why minimizing $\\Phi$ over the feasible interval drives the system to a state that satisfies the complementarity relations. Include a practical smoothing to avoid singularities at $IAP = 0$ by replacing $(T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s)$ with $\\max(\\varepsilon, (T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s))$ for a small $\\varepsilon  0$.\n3. Implement a single-variable bounded minimization algorithm over $n_s \\in [0, \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})]$ to compute $n_s^\\star$ that minimizes $\\Phi$. From $n_s^\\star$, compute $m_{\\mathrm{cat}}^\\star = T_{\\mathrm{cat}} - n_s^\\star$, $m_{\\mathrm{an}}^\\star = T_{\\mathrm{an}} - n_s^\\star$, and the final saturation index $SI^\\star$.\n4. For the numerical implementation, use base-$10$ logarithms. Concentrations must be treated in molality units (mol/kg), so $T_{\\mathrm{cat}}$, $T_{\\mathrm{an}}$, $m_{\\mathrm{cat}}$, $m_{\\mathrm{an}}$, and $n_s$ are all in $\\mathrm{mol}/\\mathrm{kg}$. The final outputs are dimensionless saturation indices.\n\nTest Suite:\nUse the following four test cases, each specified as a tuple $(T_{\\mathrm{cat}}, T_{\\mathrm{an}}, K)$, with $T_{\\mathrm{cat}}$ and $T_{\\mathrm{an}}$ in $\\mathrm{mol}/\\mathrm{kg}$ and $K$ in $(\\mathrm{mol}/\\mathrm{kg})^2$:\n- Case $1$ (moderate supersaturation): $(T_{\\mathrm{cat}}, T_{\\mathrm{an}}, K) = (2.0 \\times 10^{-3}, 1.5 \\times 10^{-3}, 1.0 \\times 10^{-6})$.\n- Case $2$ (undersaturation): $(T_{\\mathrm{cat}}, T_{\\mathrm{an}}, K) = (1.0 \\times 10^{-4}, 2.0 \\times 10^{-4}, 1.0 \\times 10^{-6})$.\n- Case $3$ (exact saturation at $n_s = 0$): $(T_{\\mathrm{cat}}, T_{\\mathrm{an}}, K) = (1.0 \\times 10^{-3}, 1.0 \\times 10^{-3}, 1.0 \\times 10^{-6})$.\n- Case $4$ (strong supersaturation with symmetric totals): $(T_{\\mathrm{cat}}, T_{\\mathrm{an}}, K) = (1.0 \\times 10^{-2}, 1.0 \\times 10^{-2}, 1.0 \\times 10^{-6})$.\n\nAnswer Specification:\n- For each test case, compute the final saturation index $SI^\\star$ as a floating-point number.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,result_3,result_4]$), where each $result_i$ is the $SI^\\star$ of the corresponding case.\n- The outputs are dimensionless (no units), computed with base-$10$ logarithms.\n\nImplement the program in Python, using a bounded scalar minimization routine. The algorithm must be robust to edge cases by using a small positive $\\varepsilon$ to avoid evaluating $\\log_{10}(0)$. Use a fixed $\\lambda$ penalty scaling, and report the $SI^\\star$ values without additional formatting beyond the required list representation.",
            "solution": "The user requires a solution to a computational geochemistry problem involving mineral precipitation equilibrium. The tasks are to formalize the problem, derive a penalty-based algorithm, and implement it.\n\n**1. Problem Formalization and Derivations**\n\nFirst, we formalize the problem by expressing the saturation index, $SI$, and its feasible domain in terms of the total component concentrations $T_{\\mathrm{cat}}$ and $T_{\\mathrm{an}}$, the solubility product $K$, and the amount of precipitate $n_s$.\n\nThe total concentrations $T_{\\mathrm{cat}}$ and $T_{\\mathrm{an}}$ are partitioned between the dissolved aqueous species ($m_{\\mathrm{cat}}$, $m_{\\mathrm{an}}$) and the solid precipitate ($n_s$). The mass balance equations are given as:\n$$m_{\\mathrm{cat}} + n_s = T_{\\mathrm{cat}}$$\n$$m_{\\mathrm{an}} + n_s = T_{\\mathrm{an}}$$\n\nFrom these, we can express the aqueous molalities as functions of $n_s$:\n$$m_{\\mathrm{cat}}(n_s) = T_{\\mathrm{cat}} - n_s$$\n$$m_{\\mathrm{an}}(n_s) = T_{\\mathrm{an}} - n_s$$\n\nPhysically, molalities cannot be negative, so $m_{\\mathrm{cat}} \\ge 0$ and $m_{\\mathrm{an}} \\ge 0$. This imposes constraints on $n_s$:\n$$T_{\\mathrm{cat}} - n_s \\ge 0 \\implies n_s \\le T_{\\mathrm{cat}}$$\n$$T_{\\mathrm{an}} - n_s \\ge 0 \\implies n_s \\le T_{\\mathrm{an}}$$\n\nAdditionally, the amount of precipitate cannot be negative, so $n_s \\ge 0$. Combining these constraints, we establish the feasible domain for $n_s$:\n$$0 \\le n_s \\le \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})$$\nThis confirms the first part of Task 1.\n\nNext, we derive the expression for the saturation index, $SI(n_s)$. The definition is $SI = \\log_{10}(IAP) - \\log_{10}(K)$. The Ion Activity Product, $IAP$, under the given approximation ($a_i = m_i$), is:\n$$IAP = m_{\\mathrm{cat}} m_{\\mathrm{an}}$$\nSubstituting the mass balance expressions for $m_{\\mathrm{cat}}$ and $m_{\\mathrm{an}}$:\n$$IAP(n_s) = (T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s)$$\nThus, the saturation index as a function of $n_s$ is:\n$$SI(n_s) = \\log_{10}\\left((T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s)\\right) - \\log_{10}(K)$$\nThis confirms the second part of Task 1.\n\n**2. Penalty Formulation for Complementarity Conditions**\n\nThe chemical equilibrium is governed by a set of complementarity conditions:\n1. $n_s \\ge 0$ (Feasibility: non-negative precipitate)\n2. $SI \\le 0$ (Thermodynamic stability: solution is not supersaturated)\n3. $n_s \\cdot SI = 0$ (Complementarity: if precipitate exists, $n_s  0$, the solution must be at saturation, $SI=0$; if the solution is undersaturated, $SI0$, no precipitate can exist, $n_s=0$).\n\nThese can be written in the standard form of a complementarity problem, $a \\ge 0, b \\ge 0, a \\cdot b = 0$, by defining $a = n_s$ and $b = -SI(n_s)$. The conditions become:\n$$n_s \\ge 0, \\quad -SI(n_s) \\ge 0, \\quad n_s \\cdot (-SI(n_s)) = 0$$\n\nThe Fischer-Burmeister (FB) function, $\\phi_{\\mathrm{FB}}(a, b) = \\sqrt{a^2 + b^2} - (a+b)$, is a key tool for solving such problems. It has the property that $\\phi_{\\mathrm{FB}}(a, b) = 0$ if and only if the complementarity conditions $a \\ge 0, b \\ge 0, a \\cdot b = 0$ are satisfied.\n\nWe can therefore reframe the equilibrium problem as finding an $n_s$ that solves the equation:\n$$\\phi_{\\mathrm{FB}}(n_s, -SI(n_s)) = 0$$\nA standard numerical method for solving an equation of the form $f(x) = 0$ where $f(x)$ is known to be non-negative is to find the minimum of $f(x)^2$. This leads to the proposed objective function:\n$$\\Phi(n_s) = \\lambda \\left[ \\phi_{\\mathrm{FB}}(n_s, -SI(n_s)) \\right]^2$$\nwhere $\\lambda  0$ is a scaling parameter. Since $\\Phi(n_s) \\ge 0$, its global minimum is $0$. Any value $n_s^\\star$ that minimizes $\\Phi(n_s)$ to $0$ is a solution to the original equilibrium problem. Minimizing this objective function over the feasible domain $n_s \\in [0, \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})]$ numerically drives the system towards a state that satisfies all equilibrium conditions.\n\nFor numerical robustness, the term $IAP(n_s) = (T_{\\mathrm{cat}} - n_s)(T_{\\mathrm{an}} - n_s)$ can approach $0$, causing $\\log_{10}(IAP(n_s))$ to diverge to $-\\infty$. This would cause numerical overflow in $-SI(n_s)$ and the objective function. To prevent this, we introduce a smoothing parameter $\\varepsilon  0$ and replace $IAP(n_s)$ with a regularized version, $IAP_{smooth} = \\max(\\varepsilon, IAP(n_s))$. This ensures the argument of the logarithm is always a small positive number, making the objective function well-behaved for a numerical optimizer.\n\n**3. Algorithmic Implementation**\n\nThe task is now reduced to a one-dimensional bounded minimization problem:\n$$\\text{find } n_s^\\star = \\arg \\min_{n_s \\in [0, \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})]} \\Phi(n_s)$$\nThis is solved using a numerical routine, such as the `bounded` method in `scipy.optimize.minimize_scalar`.\n\nThe algorithm proceeds as follows for each test case:\n1.  Define the parameters $T_{\\mathrm{cat}}$, $T_{\\mathrm{an}}$, $K$, and the numerical constants $\\lambda$ and $\\varepsilon$. A value of $\\lambda=1.0$ is sufficient, and $\\varepsilon=10^{-20}$ is a common choice for a small positive floor.\n2.  Define the search interval for $n_s$ as $[0, \\min(T_{\\mathrm{cat}}, T_{\\mathrm{an}})]$.\n3.  Define the objective function $\\Phi(n_s)$ using the smoothed expression for $SI(n_s)$.\n4.  Invoke a bounded scalar minimizer to find the optimal amount of precipitate, $n_s^\\star$.\n5.  Using $n_s^\\star$, calculate the final equilibrium state:\n    -   $m_{\\mathrm{cat}}^\\star = T_{\\mathrm{cat}} - n_s^\\star$\n    -   $m_{\\mathrm{an}}^\\star = T_{\\mathrm{an}} - n_s^\\star$\n    -   $IAP^\\star = \\max(\\varepsilon, m_{\\mathrm{cat}}^\\star m_{\\mathrm{an}}^\\star)$\n    -   $SI^\\star = \\log_{10}(IAP^\\star) - \\log_{10}(K)$\nThe final $SI^\\star$ is the desired output.",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Computes the equilibrium saturation index for mineral precipitation\n    using a penalty-based minimization algorithm.\n    \"\"\"\n    # Test cases: (T_cat, T_an, K)\n    # T_cat, T_an in mol/kg\n    # K in (mol/kg)^2\n    test_cases = [\n        # Case 1: Moderate supersaturation\n        (2.0e-3, 1.5e-3, 1.0e-6),\n        # Case 2: Undersaturation\n        (1.0e-4, 2.0e-4, 1.0e-6),\n        # Case 3: Exact saturation\n        (1.0e-3, 1.0e-3, 1.0e-6),\n        # Case 4: Strong supersaturation\n        (1.0e-2, 1.0e-2, 1.0e-6),\n    ]\n\n    # Algorithm parameters\n    LAMBDA_PENALTY = 1.0\n    EPSILON_SMOOTH = 1e-20\n\n    results = []\n\n    def objective_func(ns, T_cat, T_an, log_K, lam, eps):\n        \"\"\"\n        Penalty-based objective function using the Fischer-Burmeister formulation.\n        \n        Args:\n            ns (float): Amount of precipitated solid (mol/kg).\n            T_cat (float): Total cation concentration (mol/kg).\n            T_an (float): Total anion concentration (mol/kg).\n            log_K (float): log10 of the solubility product.\n            lam (float): Penalty parameter lambda.\n            eps (float): Smoothing parameter epsilon.\n            \n        Returns:\n            float: The value of the objective function.\n        \"\"\"\n        # Calculate Ion Activity Product (IAP)\n        iap = (T_cat - ns) * (T_an - ns)\n        \n        # Apply smoothing to prevent log(0)\n        iap_smooth = np.maximum(eps, iap)\n        \n        # Calculate Saturation Index (SI)\n        si = np.log10(iap_smooth) - log_K\n        \n        # Define variables for the complementarity problem: a >= 0, b >= 0, a*b = 0\n        a = ns\n        b = -si\n        \n        # Fischer-Burmeister function\n        phi_fb = np.sqrt(a**2 + b**2) - (a + b)\n        \n        # Objective function to be minimized\n        return lam * phi_fb**2\n\n    for T_cat, T_an, K in test_cases:\n        # Feasible domain for ns\n        bounds = (0.0, np.min([T_cat, T_an]))\n        \n        # Pre-compute log10(K) for efficiency\n        log_K = np.log10(K)\n        \n        # Arguments for the objective function\n        args = (T_cat, T_an, log_K, LAMBDA_PENALTY, EPSILON_SMOOTH)\n        \n        # Perform bounded minimization\n        res = minimize_scalar(\n            objective_func,\n            bounds=bounds,\n            args=args,\n            method='bounded'\n        )\n        \n        ns_star = res.x\n        \n        # Calculate the final saturation index from the optimal precipitate amount\n        iap_final = (T_cat - ns_star) * (T_an - ns_star)\n        iap_final_smooth = np.maximum(EPSILON_SMOOTH, iap_final)\n        si_star = np.log10(iap_final_smooth) - log_K\n        \n        # Ensure that for undersaturated cases, the result is not an artifact of smoothing\n        # If ns_star is effectively zero, the system is undersaturated and SI should not be zero.\n        # But if ns_star > 0, SI must be close to zero. The penalty function handles this.\n        # The minimizer might return a very small positive ns_star for cases 2 and 3 due to tolerance.\n        # If ns_star is very close to zero, it's better to report the SI for ns=0.\n        if np.isclose(ns_star, 0.0):\n            iap_initial = T_cat * T_an\n            si_initial = np.log10(iap_initial) - log_K\n            results.append(si_initial)\n        else:\n            results.append(si_star)\n\n    # Format the output as specified\n    formatted_results = [f\"{r:.15g}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```"
        }
    ]
}