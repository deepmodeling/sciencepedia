{
    "hands_on_practices": [
        {
            "introduction": "In computational analysis, a hydrogen bond is not an intrinsic property but a label assigned based on geometric rules. Different molecular dynamics software packages employ varying criteria, leading to potentially different conclusions about the same system. This first practice challenges you to implement several common geometric detection algorithms from scratch, allowing you to quantify how the choice of distance and angle cutoffs directly influences the calculated hydrogen bond occupancy.",
            "id": "3849667",
            "problem": "You are tasked with designing and implementing a principled comparison of hydrogen bond detection criteria inspired by common choices in Molecular Dynamics (MD) analysis tools, using a single synthetic trajectory and quantifying how detection varies with geometric thresholds and algorithmic rules. The scenario concerns a single donor–hydrogen–acceptor triad in a cubic periodic simulation box, and the objective is to compute per-algorithm hydrogen bond occupancy across frames and then compare occupancies between algorithms.\n\nFoundational base: Hydrogen bonds are commonly detected using geometric criteria involving heavy-atom distances and angular constraints. In a periodic orthorhombic simulation cell, displacements must be computed using the nearest-image convention. Use the following definitions and laws:\n\n- Periodic boundary condition with nearest-image displacement: For two positions with components $\\mathbf{r}_1 = (x_1,y_1,z_1)$ and $\\mathbf{r}_2 = (x_2,y_2,z_2)$ inside a cubic box of side length $L$, define the component-wise displacement as\n$$\n\\Delta_i = x_{2,i} - x_{1,i}, \\quad \\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i > L/2,\\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2,\\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\nand set the minimal-image displacement $\\Delta \\mathbf{r} = (\\Delta_x',\\Delta_y',\\Delta_z')$.\n- Euclidean distance: For any displacement vector $\\Delta \\mathbf{r}$, the heavy-atom or hydrogen-atom separation is $r = \\|\\Delta \\mathbf{r}\\| = \\sqrt{\\Delta_x'^2 + \\Delta_y'^2 + \\Delta_z'^2}$.\n- Angle at the hydrogen: For vectors $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ and $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$ both taken under the nearest-image convention, define the donor–hydrogen–acceptor angle as\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\,\\|\\mathbf{v}\\|}\\right) \\times \\frac{180}{\\pi},\n$$\nexpressed in degrees.\n\nHydrogen bond occupancy: For an algorithm that classifies hydrogen bonding as a boolean per frame, define occupancy over $N_f$ frames as\n$$\nO = \\frac{1}{N_f}\\sum_{t=1}^{N_f} \\mathbb{I}_t,\n$$\nwhere $\\mathbb{I}_t$ is the indicator function that equals $1$ if the hydrogen bond criterion is satisfied at frame $t$ and $0$ otherwise. Occupancy is unitless and should be reported as a decimal.\n\nAlgorithms to compare:\n- Algorithm A (heavy-atom distance and angle): A hydrogen bond exists at a frame if the nearest-image hydrogen–acceptor distance $r_\\mathrm{HA}$ satisfies $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ and the donor–hydrogen–acceptor angle satisfies $\\theta \\ge \\theta^{\\mathrm{cut}}$.\n- Algorithm B (heavy-atom distance only): A hydrogen bond exists at a frame if the nearest-image donor–acceptor distance $r_\\mathrm{DA}$ satisfies $r_\\mathrm{DA} \\le r_\\mathrm{DA}^{\\mathrm{cut}}$.\n- Algorithm C (donor–hydrogen bond presence plus Algorithm A): A hydrogen bond exists at a frame if the nearest-image donor–hydrogen distance $r_\\mathrm{DH}$ satisfies $r_\\mathrm{DH} \\le r_\\mathrm{DH}^{\\mathrm{cut}}$ and simultaneously Algorithm A’s conditions $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ and $\\theta \\ge \\theta^{\\mathrm{cut}}$ are satisfied.\n\nTrajectory specification:\n- Use a cubic periodic box with side length $L = 10\\,\\mathrm{\\AA}$.\n- The trajectory consists of $N_f = 6$ frames with donor $\\mathbf{r}_\\mathrm{D}(t)$, hydrogen $\\mathbf{r}_\\mathrm{H}(t)$, and acceptor $\\mathbf{r}_\\mathrm{A}(t)$ positions (in $\\mathrm{\\AA}$) as follows:\n  - Frame $1$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (4,1,1)$.\n  - Frame $2$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (4.6,0.4,1)$.\n  - Frame $3$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (3.4,1,1)$.\n  - Frame $4$: $\\mathbf{r}_\\mathrm{D} = (1,1,1)$, $\\mathbf{r}_\\mathrm{H} = (2,1,1)$, $\\mathbf{r}_\\mathrm{A} = (2.9,1,0)$.\n  - Frame $5$: $\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{A} = (2.5,0.5,0.5)$.\n  - Frame $6$: $\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$, $\\mathbf{r}_\\mathrm{A} = (1.914213562,1.914213562,0.5)$.\n\nAngle unit specification: All angles must be computed and compared in degrees. Distances must be computed and compared in $\\mathrm{\\AA}$.\n\nQuantification to output: For each threshold parameter set (test case), compute the three occupancies $O_A$, $O_B$, and $O_C$, and then report the absolute differences between occupancies as the list\n$$\n\\left[\\,|O_A - O_B|,\\; |O_A - O_C|,\\; |O_B - O_C|\\,\\right].\n$$\nRound each difference to three decimal places.\n\nTest suite:\n- Case $1$ (typical thresholds): $r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 150\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$.\n- Case $2$ (strict thresholds, boundary equalities included): $r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 165\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$.\n- Case $3$ (loose thresholds, angle-boundary included): $r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 135\\,\\mathrm{deg}$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$.\n\nFinal output format: Your program should produce a single line of output containing the results for the three test cases as a comma-separated list enclosed in square brackets, where each element is itself a list of the three rounded absolute differences for that case, with no spaces. For example: $[[d_{11},d_{12},d_{13}],[d_{21},d_{22},d_{23}],[d_{31},d_{32},d_{33}]]$, printed exactly as a single line like \"[[0.333,0.000,0.333],[...],[...]]\".",
            "solution": "The problem is valid. It is scientifically grounded in the principles of computational chemical biology, specifically the geometric analysis of hydrogen bonds in molecular dynamics trajectories. The definitions, data, and objectives are self-contained, consistent, and well-posed, permitting a unique and verifiable solution.\n\nThe solution proceeds in three main stages:\n1.  For each of the $N_f = 6$ frames in the synthetic trajectory, we calculate the essential geometric parameters: the donor-acceptor distance ($r_\\mathrm{DA}$), the hydrogen-acceptor distance ($r_\\mathrm{HA}$), the donor-hydrogen distance ($r_\\mathrm{DH}$), and the donor-hydrogen-acceptor angle ($\\theta$). These calculations must strictly adhere to the nearest-image convention for the specified periodic cubic box of side length $L = 10\\,\\mathrm{\\AA}$.\n2.  For each of the three test cases, which provide different sets of cutoff thresholds, we iterate through the pre-calculated geometric parameters for each frame. We apply the logical criteria for Algorithm A, B, and C to determine if a hydrogen bond exists in that frame according to each algorithm.\n3.  After classifying all frames for a given test case, we compute the occupancy $O$ for each algorithm as the fraction of frames where a hydrogen bond was detected. Finally, we calculate the required absolute differences between these occupancies, $|O_A - O_B|$, $|O_A - O_C|$, and $|O_B - O_C|$, and round them to three decimal places.\n\n**Step 1: Calculation of Geometric Parameters**\n\nWe define three helper functions based on the problem statement for computing minimum-image displacement, distance, and angle.\n\nThe minimum-image displacement $\\Delta \\mathbf{r}'$ between two position vectors $\\mathbf{r}_1$ and $\\mathbf{r}_2$ in a cubic box of side $L$ is calculated component-wise. For each component $i \\in \\{x, y, z\\}$:\n$$\n\\Delta_i = x_{2,i} - x_{1,i}\n$$\n$$\n\\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i > L/2 \\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2 \\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n\nThe distance $r$ is the Euclidean norm of the resulting displacement vector, $r = \\|\\Delta \\mathbf{r}'\\|$. The angle $\\theta$ between vectors $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ and $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$ (both computed using the nearest-image convention) is given by $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\|\\mathbf{v}\\|})$ and converted to degrees.\n\nApplying these definitions to the trajectory data ($L=10\\,\\mathrm{\\AA}$, $N_f=6$ frames) yields the following geometric parameters for each frame:\n\n| Frame | $r_\\mathrm{DA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{HA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{DH}$ ($\\mathrm{\\AA}$) | $\\theta$ (deg) |\n|---|---|---|---|---|\n| $1$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $2$ | $\\sqrt{13.32} \\approx 3.650$ | $\\sqrt{7.12} \\approx 2.668$ | $1.0$ | $166.99$ |\n| $3$ | $2.4$ | $1.4$ | $1.0$ | $180.0$ |\n| $4$ | $\\sqrt{4.61} \\approx 2.147$ | $\\sqrt{1.81} \\approx 1.345$ | $1.0$ | $132.01$ |\n| $5$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $6$ | $\\sqrt{5+2\\sqrt{2}} \\approx 2.798$ | $2.0$ | $1.0$ | $135.0$ |\n\nNote that for frames $5$ and $6$, the particle positions necessitate applying the nearest-image convention. For example, in Frame $5$, the direct displacement for D-A is $\\Delta\\mathbf{r} = (2.5-9.5, 0, 0) = (-7,0,0)$. Since $\\Delta_x = -7  -L/2 = -5$, the corrected displacement is $\\Delta\\mathbf{r}' = (-7+10, 0, 0) = (3,0,0)$, yielding $r_\\mathrm{DA}=3.0\\,\\mathrm{\\AA}$.\n\n**Step 2  3: Application of Algorithms and Calculation of Differences**\n\nWe now process each test case using the geometric data from the table above.\n\n**Test Case 1:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 150^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 2.5$ and $\\theta \\ge 150^\\circ$):** Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.2$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.05$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.05$). Thus, this is equivalent to Algorithm A. Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n\nOccupancies:\n- $O_A = 3/6 = 0.5$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 3/6 = 0.5$\n\nDifferences:\n- $|O_A - O_B| = |0.5 - 5/6| = 1/3 \\approx 0.333$\n- $|O_A - O_C| = |0.5 - 0.5| = 0.0$\n- $|O_B - O_C| = |5/6 - 0.5| = 1/3 \\approx 0.333$\nResult: $[0.333, 0.000, 0.333]$\n\n**Test Case 2:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 165^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 2.0$ and $\\theta \\ge 165^\\circ$):** Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.0$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.0$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.0$). This is equivalent to Algorithm A. Frames $1, 3, 5$ satisfy the criteria. Count = $3$.\n\nOccupancies and differences are identical to Case 1.\nResult: $[0.333, 0.000, 0.333]$\n\n**Test Case 3:** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$, $\\theta^{\\mathrm{cut}} = 135^\\circ$, $r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$, $r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$)\n\n- **Algorithm A ($r_\\mathrm{HA} \\le 3.0$ and $\\theta \\ge 135^\\circ$):** Frames $1, 2, 3, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm B ($r_\\mathrm{DA} \\le 3.5$):** Frames $1, 3, 4, 5, 6$ satisfy the criteria. Count = $5$.\n- **Algorithm C ($r_\\mathrm{DH} \\le 1.2$ and Algorithm A):** The condition on $r_\\mathrm{DH}$ is met for all frames ($1.0 \\le 1.2$). This is equivalent to Algorithm A. Frames $1, 2, 3, 5, 6$ satisfy the criteria. Count = $5$.\n\nOccupancies:\n- $O_A = 5/6 \\approx 0.8333$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 5/6 \\approx 0.8333$\n\nDifferences:\n- $|O_A - O_B| = |5/6 - 5/6| = 0.0$\n- $|O_A - O_C| = |5/6 - 5/6| = 0.0$\n- $|O_B - O_C| = |5/6 - 5/6| = 0.0$\nResult: $[0.000, 0.000, 0.000]$\n\nThese results will be formatted into a single line for the final output as per the problem specification.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, acos, degrees\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond analysis problem by calculating occupancies\n    for three different algorithms across a synthetic trajectory and\n    reporting the differences between them for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Trajectory data: (r_D, r_H, r_A) for each frame\n    trajectory = [\n        # Frame 1\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.0, 1.0, 1.0])),\n        # Frame 2\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.6, 0.4, 1.0])),\n        # Frame 3\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([3.4, 1.0, 1.0])),\n        # Frame 4\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([2.9, 1.0, 0.0])),\n        # Frame 5\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([2.5, 0.5, 0.5])),\n        # Frame 6\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([1.914213562, 1.914213562, 0.5])),\n    ]\n    L = 10.0  # Box side length in Angstrom\n    N_f = len(trajectory)\n\n    # Test cases: (r_HA_cut, theta_cut, r_DA_cut, r_DH_cut)\n    test_cases = [\n        # Case 1 (typical)\n        (2.5, 150.0, 3.2, 1.05),\n        # Case 2 (strict)\n        (2.0, 165.0, 3.0, 1.0),\n        # Case 3 (loose)\n        (3.0, 135.0, 3.5, 1.2),\n    ]\n\n    # --- Helper Functions ---\n\n    def nearest_image_displacement(r2, r1, box_L):\n        \"\"\"Calculates the minimum image displacement vector from r1 to r2.\"\"\"\n        delta = r2 - r1\n        half_L = box_L / 2.0\n        # This explicit loop correctly implements the problem's definition\n        for i in range(len(delta)):\n            if delta[i] > half_L:\n                delta[i] -= box_L\n            elif delta[i]  -half_L:\n                delta[i] += box_L\n        return delta\n\n    # --- Main Logic ---\n\n    all_results = []\n    \n    for case in test_cases:\n        r_HA_cut, theta_cut, r_DA_cut, r_DH_cut = case\n        \n        h_bond_count_A = 0\n        h_bond_count_B = 0\n        h_bond_count_C = 0\n\n        for frame_coords in trajectory:\n            r_D, r_H, r_A = frame_coords\n\n            # Calculate geometric quantities for the frame\n            # Distances\n            dr_DA = nearest_image_displacement(r_A, r_D, L)\n            r_DA = np.linalg.norm(dr_DA)\n\n            dr_HA = nearest_image_displacement(r_A, r_H, L)\n            r_HA = np.linalg.norm(dr_HA)\n\n            dr_DH = nearest_image_displacement(r_H, r_D, L)\n            r_DH = np.linalg.norm(dr_DH)\n            \n            # Angle D-H-A\n            # Vector u from H to D\n            u = nearest_image_displacement(r_D, r_H, L)\n            # Vector v from H to A\n            v = dr_HA # This is already r_A - r_H with PBC\n            \n            norm_u = np.linalg.norm(u)\n            norm_v = r_HA\n            \n            # Prevent division by zero if atoms overlap\n            if norm_u > 1e-9 and norm_v > 1e-9:\n                dot_product = np.dot(u, v)\n                cosine_angle = dot_product / (norm_u * norm_v)\n                # Clip to handle floating point inaccuracies\n                cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n                angle = degrees(acos(cosine_angle))\n            else:\n                angle = 0.0\n\n            # Apply algorithm criteria\n            # Algorithm A\n            is_hbond_A = (r_HA = r_HA_cut) and (angle >= theta_cut)\n            if is_hbond_A:\n                h_bond_count_A += 1\n            \n            # Algorithm B\n            if r_DA = r_DA_cut:\n                h_bond_count_B += 1\n            \n            # Algorithm C\n            if (r_DH = r_DH_cut) and is_hbond_A:\n                h_bond_count_C += 1\n\n        # Calculate occupancies\n        O_A = h_bond_count_A / N_f\n        O_B = h_bond_count_B / N_f\n        O_C = h_bond_count_C / N_f\n        \n        # Calculate and round absolute differences\n        diff_AB = abs(O_A - O_B)\n        diff_AC = abs(O_A - O_C)\n        diff_BC = abs(O_B - O_C)\n        \n        all_results.append([diff_AB, diff_AC, diff_BC])\n\n    # --- Final Output Formatting ---\n    # According to the specified format \"[[d1,d2,d3],[...]]\"\n    inner_results_str = []\n    for R in all_results:\n        # Format numbers to 3 decimal places\n        formatted_diffs = [f\"{d:.3f}\" for d in R]\n        inner_results_str.append(f\"[{','.join(formatted_diffs)}]\")\n    \n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "Simple, hard-cutoff criteria, like those explored previously , often struggle to capture the complexity of hydrogen bonding networks, particularly in cases of bifurcated bonds where one hydrogen interacts with multiple acceptors. This exercise moves beyond binary classification to a more nuanced approach involving a continuous scoring function and a principled conflict resolution scheme. By building this advanced detector, you will gain hands-on experience in developing robust methods for analyzing intricate and competitive bonding environments.",
            "id": "3849664",
            "problem": "You are to implement, from first principles, a robust computational detection scheme for hydrogen bonds that explicitly accounts for bifurcation at a single hydrogen donor by defining multiple competing geometric constraints and a principled conflict resolution. Work in three-dimensional Euclidean space, with all distances measured in ångström and angles measured in degrees. The scheme concerns a single donor atom $D$, its covalently bound hydrogen atom $H$, and a set of candidate acceptor atoms $A_i$ with index $i \\in \\{0,1,\\dots,n-1\\}$.\n\nStarting base and definitions that must be used:\n- Use the Euclidean norm to measure distances and the dot product to measure angles. Distances and angles are fundamental geometric quantities and must be derived from the positions of $D$, $H$, and $A_i$ in three-dimensional space.\n- The angle at the hydrogen, denoted $\\theta_{DHA,i}$, must be defined as the angle between the vectors $H \\rightarrow D$ and $H \\rightarrow A_i$, which captures the linearity preference of hydrogen bonds.\n- The distance from hydrogen to acceptor, denoted $r_{HA,i}$, and the distance from donor to acceptor, denoted $r_{DA,i}$, must both be computed from the positions of the atoms.\n\nHydrogen bond detection criteria to implement:\n1. Hard geometric feasibility for each acceptor $A_i$:\n   - The hydrogen–acceptor distance $r_{HA,i}$ must lie within a physically plausible range $[r_{\\text{min}}, r_{\\text{max}}]$, where $r_{\\text{min}} = 1.4$ and $r_{\\text{max}} = 2.5$ (in ångström).\n   - The donor–acceptor distance $r_{DA,i}$ must lie within a plausible range $[d_{\\text{min}}, d_{\\text{max}}]$, where $d_{\\text{min}} = 2.5$ and $d_{\\text{max}} = 3.5$ (in ångström).\n   - The angle $\\theta_{DHA,i}$ must be at least $\\theta_{\\text{min}} = 130$ (in degrees).\n   Any acceptor failing any of these hard conditions is not considered further.\n2. Bifurcation compatibility:\n   - A hydrogen may form at most two simultaneous hydrogen bonds. If two acceptors $A_i$ and $A_j$ are both chosen, the separation angle at the hydrogen between the vectors $H \\rightarrow A_i$ and $H \\rightarrow A_j$, denoted $\\phi_{ij}$, must be at least $\\phi_{\\text{min}} = 12$ (in degrees).\n3. Scoring for conflict resolution:\n   - Each geometrically feasible acceptor $A_i$ must receive a continuous score $S_i$ that decreases as $r_{HA,i}$ and $r_{DA,i}$ deviate from typical values and as $\\theta_{DHA,i}$ deviates from an ideal linear configuration. The score must be based on an exponential penalty constructed from squared deviations about physically reasonable targets, without introducing discontinuities. The targets to use are $r_0 = 1.8$ (in ångström), $d_0 = 3.0$ (in ångström), and $\\theta_0 = 180$ (in degrees). The standard deviations that set the scale of deviations must be $\\sigma_r = 0.2$ (in ångström), $\\sigma_d = 0.3$ (in ångström), and $\\sigma_\\theta = 10$ (in degrees). Additionally, include a penalty based on the donor–hydrogen covalent bond length $r_{DH}$ relative to a target $r_{DH,0} = 1.0$ (in ångström) with scale $\\sigma_{DH} = 0.05$ (in ångström), using the same exponential-squared-deviation principle. The donor–hydrogen covalent bond length must be computed once per case from $D$ and $H$.\n4. Conflict resolution:\n   - From the set of geometrically feasible acceptors, choose a subset of size at most two that maximizes the sum of scores $\\sum S_i$ subject to the separation angle constraint $\\phi_{ij} \\ge \\phi_{\\text{min}}$ for any chosen pair $(i,j)$. If no pair satisfies the separation constraint, choose the single acceptor with the highest score. In case of ties in the sum of scores, choose the subset whose sorted index list is lexicographically smallest.\n\nYour program must implement all of the above and apply it to the following test suite. Each test case is specified by the positions of $D$, $H$, and the list of acceptor positions $A_i$. All coordinates are given in ångström. For all cases, use the same parameter values specified above and the same angle unit (degrees):\n\nTest case 1 (happy path, two compatible acceptors):\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$\n\nTest case 2 (three acceptors, choose best bifurcated pair):\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$, $A_2 = (2.45, 0.8, 0.0)$\n\nTest case 3 (boundary angle and a failing distance):\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.157, 1.379, 0.0)$, $A_1 = (3.6, 0.0, 0.0)$\n\nTest case 4 (conflict by small separation, choose the single best):\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.7, 0.0, 0.0)$\n\nFinal output specification:\n- For each test case, output the list of indices of the selected acceptors in ascending order as a list of integers, with at most two elements per case. Aggregate the results of all test cases into a single line as a comma-separated list enclosed in square brackets, with each case’s list enclosed in its own square brackets. For example, an output for four cases might look like \"[[0,1],[2,3],[1],[0]]\". Your program must produce exactly one line in this format.",
            "solution": "The problem requires the implementation of a computational algorithm to identify hydrogen bonds, including bifurcated ones, for a single donor-hydrogen system ($D-H$) interacting with multiple potential acceptor atoms ($A_i$). The solution will be developed by following the specified criteria for geometric feasibility, scoring, and conflict resolution. All mathematical entities are rendered in LaTeX as required.\n\nFirst, we establish the necessary geometric formalism in three-dimensional Euclidean space. The positions of atoms $D$, $H$, and $A_i$ are given as vectors in $\\mathbb{R}^3$. Let these be $\\vec{p}_D$, $\\vec{p}_H$, and $\\vec{p}_{A,i}$ respectively.\n\nThe distance between two atoms, say $P_1$ and $P_2$, is the Euclidean norm of the vector connecting them:\n$$d(P_1, P_2) = \\| \\vec{p}_{P_2} - \\vec{p}_{P_1} \\| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2}$$\n\nThe angle formed by three atoms, for instance the angle $\\alpha$ at atom $P_2$ between atoms $P_1$ and $P_3$, is calculated from the dot product of the vectors originating from $P_2$: $\\vec{v}_1 = \\vec{p}_{P_1} - \\vec{p}_{P_2}$ and $\\vec{v}_2 = \\vec{p}_{P_3} - \\vec{p}_{P_2}$.\n$$\\alpha = \\arccos\\left( \\frac{\\vec{v}_1 \\cdot \\vec{v}_2}{\\|\\vec{v}_1\\| \\|\\vec{v}_2\\|} \\right)$$\nThe result of the $\\arccos$ function is in radians and must be converted to degrees for comparison with the given angle thresholds: $\\alpha_{\\text{deg}} = \\alpha_{\\text{rad}} \\times \\frac{180}{\\pi}$.\n\nThe algorithm proceeds in three main stages:\n\n**1. Feasibility Analysis**\n\nFor each candidate acceptor $A_i$, we evaluate a set of hard geometric constraints. An acceptor must satisfy all of the following conditions to be considered a feasible candidate for forming a hydrogen bond:\n\n*   **Hydrogen-Acceptor Distance ($r_{HA,i}$):** The distance between the hydrogen $H$ and the acceptor $A_i$ must be within the specified range.\n    $$ r_{HA,i} = d(H, A_i) \\quad \\text{s.t.} \\quad r_{\\text{min}} \\le r_{HA,i} \\le r_{\\text{max}} $$\n    where $r_{\\text{min}} = 1.4$ Å and $r_{\\text{max}} = 2.5$ Å.\n\n*   **Donor-Acceptor Distance ($r_{DA,i}$):** The distance between the donor $D$ and the acceptor $A_i$ must fall within its allowed range.\n    $$ r_{DA,i} = d(D, A_i) \\quad \\text{s.t.} \\quad d_{\\text{min}} \\le r_{DA,i} \\le d_{\\text{max}} $$\n    where $d_{\\text{min}} = 2.5$ Å and $d_{\\text{max}} = 3.5$ Å.\n\n*   **Hydrogen Bond Angle ($\\theta_{DHA,i}$):** The angle at the hydrogen atom must indicate a near-linear arrangement. This angle is defined between the vector from $H$ to $D$ ($\\vec{HD} = \\vec{p}_D - \\vec{p}_H$) and the vector from $H$ to $A_i$ ($\\vec{HA_i} = \\vec{p}_{A,i} - \\vec{p}_H$).\n    $$ \\theta_{DHA,i} = \\text{angle}(D, H, A_i) \\quad \\text{s.t.} \\quad \\theta_{DHA,i} \\ge \\theta_{\\text{min}} $$\n    where $\\theta_{\\text{min}} = 130$ degrees.\n\nAny acceptor $A_i$ failing to meet any of these three criteria is discarded and not considered further.\n\n**2. Scoring of Feasible Acceptors**\n\nEach feasible acceptor $A_i$ is assigned a score $S_i$ that quantifies the quality of the potential hydrogen bond. A higher score corresponds to a more ideal geometry. The score is defined as an exponential function of the sum of squared, scaled deviations from ideal target values.\n\nFirst, the donor-hydrogen covalent bond length $r_{DH} = d(D, H)$ is calculated once per test case.\n\nThe score $S_i$ for a feasible acceptor $A_i$ is then given by:\n$$ S_i = \\exp\\left( - \\left[ \\left(\\frac{r_{DH} - r_{DH,0}}{\\sigma_{DH}}\\right)^2 + \\left(\\frac{r_{HA,i} - r_0}{\\sigma_r}\\right)^2 + \\left(\\frac{r_{DA,i} - d_0}{\\sigma_d}\\right)^2 + \\left(\\frac{\\theta_{DHA,i} - \\theta_0}{\\sigma_\\theta}\\right)^2 \\right] \\right) $$\nThe parameters for the scoring function are:\n*   Ideal hydrogen-acceptor distance: $r_0 = 1.8$ Å, scale: $\\sigma_r = 0.2$ Å.\n*   Ideal donor-acceptor distance: $d_0 = 3.0$ Å, scale: $\\sigma_d = 0.3$ Å.\n*   Ideal hydrogen bond angle: $\\theta_0 = 180$ degrees, scale: $\\sigma_\\theta = 10$ degrees.\n*   Ideal donor-hydrogen distance: $r_{DH,0} = 1.0$ Å, scale: $\\sigma_{DH} = 0.05$ Å.\n\nThis formula produces a continuous score between $0$ and $1$, where a score of $1$ signifies a perfectly ideal geometry across all metrics.\n\n**3. Conflict Resolution and Selection**\n\nThe final step is to select the optimal set of hydrogen-bonded acceptors, with a maximum of two (a bifurcated bond). This is a maximization problem subject to a spatial constraint and a clear tie-breaking rule.\n\nThe overall strategy is to generate all possible valid solutions (subsets of acceptors), calculate their total scores, and then select the best one.\n\n*   **Candidate Generation:**\n    1.  **Single-acceptor candidates:** For each feasible acceptor $A_i$ with score $S_i$, the singleton set $\\{i\\}$ is a candidate solution. Its total score is simply $S_i$.\n    2.  **Two-acceptor candidates:** For each pair of distinct feasible acceptors $(A_i, A_j)$ where $i  j$, we must check for bifurcation compatibility. This requires the separation angle $\\phi_{ij}$ at the hydrogen atom to be sufficiently large. The angle $\\phi_{ij}$ is formed by the vectors $\\vec{HA_i}$ and $\\vec{HA_j}$.\n        $$ \\phi_{ij} = \\text{angle}(A_i, H, A_j) \\ge \\phi_{\\text{min}} $$\n        where $\\phi_{\\text{min}} = 12$ degrees. If this condition holds, the set $\\{i, j\\}$ is a valid candidate solution. Its total score is the sum of the individual scores, $S_i + S_j$.\n\n*   **Optimal Selection:**\n    From the collection of all valid single- and two-acceptor candidates, we must choose the one that maximizes the total score.\n    *   Let each candidate be represented by a tuple `(total_score, sorted_index_list)`. For example, a single-acceptor candidate is $(S_i, [i])$ and a two-acceptor candidate is $(S_i+S_j, [i, j])$.\n    *   The optimal solution is the one corresponding to the maximum tuple in this collection. Python's default tuple comparison is ideal for this: it first compares by the first element (`total_score`), and in case of a tie, it proceeds to the second element (`sorted_index_list`). Comparing lists lexicographically correctly implements the specified tie-breaking rule.\n    *   If no acceptors are deemed feasible in the first step, the resulting set is empty.\n\nThis systematic procedure guarantees a unique and optimal solution according to the problem's criteria.",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for hydrogen bond detection.\n    \"\"\"\n\n    # Define physical and geometric parameters as per the problem statement.\n    params = {\n        'r_min': 1.4, 'r_max': 2.5,  # Angstrom\n        'd_min': 2.5, 'd_max': 3.5,  # Angstrom\n        'theta_min': 130.0,         # Degrees\n        'phi_min': 12.0,            # Degrees\n        'r0': 1.8, 'sigma_r': 0.2,   # Angstrom\n        'd0': 3.0, 'sigma_d': 0.3,   # Angstrom\n        'theta0': 180.0, 'sigma_theta': 10.0, # Degrees\n        'r_dh0': 1.0, 'sigma_dh': 0.05 # Angstrom\n    }\n\n    # Define test cases. Each case is a tuple (D_pos, H_pos, A_pos_list).\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0]), np.array([2.45, 0.8, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.157, 1.379, 0.0]), np.array([3.6, 0.0, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.7, 0.0, 0.0])]),\n    ]\n    \n    final_results = []\n    for case in test_cases:\n        D, H, A_list = case\n        result = process_case(D, H, A_list, params)\n        final_results.append(result)\n\n    # Format the output as specified: \"[[0,1],[2],[0]]\"\n    output_str = f\"[{','.join([str(r).replace(' ', '') for r in final_results])}]\"\n    print(output_str)\n\ndef get_angle(p1, p2, p3):\n    \"\"\"Calculates the angle in degrees at p2 between vectors p2->p1 and p2->p3.\"\"\"\n    v1 = p1 - p2\n    v2 = p3 - p2\n    \n    v1_norm = np.linalg.norm(v1)\n    v2_norm = np.linalg.norm(v2)\n    \n    if v1_norm == 0 or v2_norm == 0:\n        return 0.0 # Or handle as an error, though not expected here.\n\n    # Clamp dot_product / (norms) to [-1, 1] to avoid floating point errors with arccos\n    cos_theta = np.dot(v1, v2) / (v1_norm * v2_norm)\n    cos_theta_clamped = np.clip(cos_theta, -1.0, 1.0)\n    \n    angle_rad = np.arccos(cos_theta_clamped)\n    return np.degrees(angle_rad)\n\ndef process_case(D, H, A_list, params):\n    \"\"\"\n    Processes a single test case for hydrogen bond detection.\n    \"\"\"\n    \n    # --- 1. Feasibility Analysis ---\n    feasible_acceptors = []\n    for i, A_i in enumerate(A_list):\n        r_da = np.linalg.norm(A_i - D)\n        r_ha = np.linalg.norm(A_i - H)\n        theta_dha = get_angle(D, H, A_i)\n        \n        if (params['d_min'] = r_da = params['d_max'] and\n            params['r_min'] = r_ha = params['r_max'] and\n            theta_dha >= params['theta_min']):\n            \n            feasible_acceptors.append({\n                'index': i,\n                'pos': A_i,\n                'r_da': r_da,\n                'r_ha': r_ha,\n                'theta_dha': theta_dha\n            })\n\n    if not feasible_acceptors:\n        return []\n\n    # --- 2. Scoring ---\n    r_dh = np.linalg.norm(H - D)\n    r_dh_term = ((r_dh - params['r_dh0']) / params['sigma_dh'])**2\n\n    for acc in feasible_acceptors:\n        r_ha_term = ((acc['r_ha'] - params['r0']) / params['sigma_r'])**2\n        r_da_term = ((acc['r_da'] - params['d0']) / params['sigma_d'])**2\n        theta_term = ((acc['theta_dha'] - params['theta0']) / params['sigma_theta'])**2\n        \n        total_penalty = r_dh_term + r_ha_term + r_da_term + theta_term\n        acc['score'] = np.exp(-total_penalty)\n    \n    # --- 3. Conflict Resolution and Selection ---\n    candidate_solutions = []\n\n    # Add single-acceptor candidates\n    for acc in feasible_acceptors:\n        candidate_solutions.append((acc['score'], [acc['index']]))\n        \n    # Add two-acceptor candidates\n    if len(feasible_acceptors) >= 2:\n        for i in range(len(feasible_acceptors)):\n            for j in range(i + 1, len(feasible_acceptors)):\n                acc1 = feasible_acceptors[i]\n                acc2 = feasible_acceptors[j]\n                \n                # Check separation angle constraint\n                phi_ij = get_angle(acc1['pos'], H, acc2['pos'])\n                \n                if phi_ij >= params['phi_min']:\n                    total_score = acc1['score'] + acc2['score']\n                    indices = sorted([acc1['index'], acc2['index']])\n                    candidate_solutions.append((total_score, indices))\n    \n    # Find the best candidate\n    # Python's max() on a list of tuples automatically handles the required logic:\n    # it sorts by the first element (score), and on ties, by the second (lexicographical list).\n    if not candidate_solutions:\n        return []\n    \n    best_solution = max(candidate_solutions)\n    return best_solution[1]\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "Ultimately, identifying hydrogen bonds is a means to understand their contribution to molecular stability and dynamics. This practice bridges the gap between abstract geometric detection and physical properties by asking you to model a bond's energy and lifetime. You will then perform a sensitivity analysis to see how small changes in your detection thresholds can propagate, altering these key physical descriptors and underscoring the importance of robust parameterization in your models.",
            "id": "3849643",
            "problem": "You are tasked with assessing the robustness of a computational hydrogen bond detection model to changes in geometric detection thresholds by performing a sensitivity analysis and reporting the impact on predicted energies and lifetimes. The context is hydrogen bond analysis within computational chemical biology, and you are to reason from first principles.\n\nBegin from the following foundational base, which is widely accepted in physical chemistry and chemical biology:\n- Hydrogen bonding strength increases as the donor–hydrogen–acceptor angle approaches linearity and decreases as donor–acceptor distance increases. This directionality can be represented by an orientation factor that depends on the donor–hydrogen–acceptor angle.\n- Orbital overlap relevant to hydrogen bonding decreases approximately exponentially with separation distance, which motivates an exponential dependence on distance for an effective interaction strength.\n- Thermal dissociation of a hydrogen bond can be modeled using an Arrhenius or Eyring-like expression, where the dissociation rate depends exponentially on an activation energy scaled by thermal energy.\n\nFrom these principles, derive an energy model for individual candidate interactions that depends on distance and angle, and then derive a corresponding lifetime model using an Arrhenius-type rate law. Your program should implement the derived models and perform the sensitivity analysis described below.\n\nData and constants to be used (all quantities must be used exactly as specified):\n- There are $N = 10$ candidate interactions with donor–acceptor distances (in Ångström) and donor–hydrogen–acceptor angles (in degrees):\n  - Distances: $\\{2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75\\}$.\n  - Angles: $\\{175, 160, 140, 130, 155, 145, 120, 178, 150, 165\\}$.\n- Physical constants and model parameters:\n  - Base energy scale in kilojoules per mole: $E_0 = 25.0$.\n  - Distance decay parameter in inverse Ångström: $b = 1.5$.\n  - Reference distance in Ångström: $r_0 = 2.8$.\n  - Attempt frequency in inverse seconds: $\\nu_0 = 1.0 \\times 10^{12}$.\n  - Barrier scaling factor (dimensionless): $\\alpha = 0.5$.\n  - Gas constant in kilojoules per mole per kelvin: $R = 0.008314$.\n  - Temperature in kelvin: $T = 300.0$.\n  - Numerical stabilizer for divisions (dimensionless): $\\varepsilon = 1.0 \\times 10^{-12}$.\n  - Robustness tolerance (dimensionless): $\\rho = 0.20$.\n\nDetection criterion:\n- An interaction $i$ with distance $r_i$ (in Ångström) and angle $\\theta_i$ (in degrees) is considered a detected hydrogen bond if and only if $r_i \\leq r_{\\mathrm{thr}}$ and $\\theta_i \\geq \\theta_{\\mathrm{thr}}$, where $r_{\\mathrm{thr}}$ is a distance threshold (in Ångström) and $\\theta_{\\mathrm{thr}}$ is an angle threshold (in degrees).\n\nEnergy and lifetime modeling to derive and implement:\n- Use the exponential decay of orbital overlap with distance and the directionality of hydrogen bonding to derive a physically motivated energy model $E_i(r_i, \\theta_i)$ in kilojoules per mole for each detected interaction. The model must:\n  - Decrease exponentially with increasing $r_i$ relative to $r_0$ through a factor that involves $b$ and $(r_i - r_0)$.\n  - Increase with increasing $\\theta_i$ toward linearity through a bounded orientation factor based on $\\theta_i$.\n  - Be negative for favorable interactions and have magnitude scaled by $E_0$.\n- Use an Arrhenius-type dissociation rate law to derive a lifetime model $\\tau_i$ in seconds, where the dissociation rate $k_{\\mathrm{off}, i}$ is given by $k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\alpha |E_i| / (R T)\\right)$ and $\\tau_i = 1 / k_{\\mathrm{off}, i}$.\n\nAggregation and sensitivity analysis:\n- For a given $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$, let $S$ be the set of indices that satisfy the detection criterion. Define the mean energy $\\bar{E}$ in kilojoules per mole as the arithmetic mean of $E_i$ over $i \\in S$ and the mean lifetime $\\bar{\\tau}$ in seconds as the arithmetic mean of $\\tau_i$ over $i \\in S$. If $S$ is empty, define $\\bar{E} = 0$ and $\\bar{\\tau} = 0$.\n- Perform a local sensitivity analysis by symmetric finite differences with respect to $r_{\\mathrm{thr}}$ and $\\theta_{\\mathrm{thr}}$. For a perturbation $\\Delta r$ (in Ångström), compute $\\bar{E}_0$ and $\\bar{\\tau}_0$ at $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$, then compute $\\bar{E}_+$ and $\\bar{E}_-$ at $(r_{\\mathrm{thr}} + \\Delta r, \\theta_{\\mathrm{thr}})$ and $(r_{\\mathrm{thr}} - \\Delta r, \\theta_{\\mathrm{thr}})$, respectively. Analogously, for a perturbation $\\Delta \\theta$ (in degrees), compute $\\bar{E}_+$ and $\\bar{E}_-$ at $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ and $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$. Use physical clipping where needed so that $r_{\\mathrm{thr}} - \\Delta r \\geq 0$ and $0 \\leq \\theta_{\\mathrm{thr}} \\pm \\Delta \\theta \\leq 180$.\n- Define the dimensionless relative changes:\n  $$\\delta_E^{(r)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_+ - \\bar{E}_-|}{\\max(|\\bar{E}_0|, \\varepsilon)},$$\n  $$\\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_+ - \\bar{\\tau}_-|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)}.$$\n- Define the robustness boolean as $\\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho)$.\n\nAngle unit specification:\n- All angles $\\theta$ and $\\theta_{\\mathrm{thr}}$ are in degrees; when computing any trigonometric function, convert degrees to radians.\n\nPhysical units:\n- Distances are in Ångström, energies are in kilojoules per mole, lifetimes are in seconds, temperature is in kelvin, and rates are in inverse seconds.\n\nTest suite:\n- Your program must evaluate the following four test cases, each specified as a tuple $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$, with angle thresholds and perturbations in degrees and distance thresholds and perturbations in Ångström. All tests use the constants above and temperature $T = 300.0$ kelvin.\n  1. $(3.20, 150.0, 0.10, 5.0)$.\n  2. $(2.80, 170.0, 0.05, 2.0)$.\n  3. $(4.00, 120.0, 0.20, 10.0)$.\n  4. $(2.50, 175.0, 0.10, 5.0)$.\n- These cases probe a general case, near-boundary selectivity, loose thresholds, and tight thresholds that may yield no detections.\n\nFinal output specification:\n- For each test case, your program must compute and return a list of seven values in the following order:\n  $[\\bar{E}, \\bar{\\tau}, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$,\n  where $\\bar{E}$ is in kilojoules per mole and $\\bar{\\tau}$ is in seconds, and the four $\\delta$ quantities are dimensionless decimals, and $\\mathrm{robust}$ is a boolean.\n- Your program should produce a single line of output containing the results for all four test cases as a comma-separated list enclosed in square brackets, with each test case’s seven-element list enclosed in square brackets. For example, the output must have the form $[[a_1,a_2,\\dots,a_7],[b_1,b_2,\\dots,b_7],[c_1,\\dots,c_7],[d_1,\\dots,d_7]]$, using the exact numeric values your program computes.",
            "solution": "The problem statement has been validated and is deemed to be scientifically grounded, well-posed, and complete. It presents a standard task in computational chemical biology: assessing the sensitivity of a model to its parameters. The provided physical principles, constants, and data are consistent and physically realistic. The task is to derive and implement a model for hydrogen bond energy and lifetime, and then perform a local sensitivity analysis. I will now proceed with the derivation and solution.\n\nFirst, we must formalize the energy and lifetime models based on the provided first principles.\n\n**1. Derivation of the Interaction Energy Model, $E_i(r_i, \\theta_i)$**\n\nThe energy of a hydrogen bond is a function of its geometry, primarily the donor-acceptor distance, $r_i$, and the donor-hydrogen-acceptor angle, $\\theta_i$. The problem requires a model, $E_i(r_i, \\theta_i)$, that incorporates principles of orbital overlap and directionality.\n\n*   **Distance Dependence:** The strength of the interaction is related to the overlap of molecular orbitals, which typically decays exponentially with distance. The problem specifies that the energy's magnitude should decrease exponentially as the distance $r_i$ increases relative to a reference distance $r_0$, governed by a decay parameter $b$. This is captured by a distance-dependent factor, $f_D(r_i)$. A standard form for this, which adheres to the directive, is:\n    $$f_D(r_i) = \\exp[-b(r_i - r_0)]$$\n    This factor is equal to $1$ when $r_i = r_0$ and decays for $r_i > r_0$.\n\n*   **Angular Dependence:** Hydrogen bonds are directional, with maximum strength at a linear geometry, i.e., when the donor-hydrogen-acceptor angle $\\theta_i$ is $180^\\circ$. This is modeled by a bounded orientation factor, $f_A(\\theta_i)$, that is maximal at $\\theta_i = 180^\\circ$ and decreases as the bond bends. A physically motivated and common functional form for this is a power of the cosine of the angle. We will use a squared cosine term, which is $1$ at $180^\\circ$ and $0$ at $90^\\circ$:\n    $$f_A(\\theta_i) = \\cos^2(\\theta_{i, \\text{rad}})$$\n    where $\\theta_{i, \\text{rad}}$ is the angle $\\theta_i$ converted from degrees to radians. This choice ensures the factor is bounded between $0$ and $1$ and correctly captures the preference for linearity.\n\n*   **Final Energy Expression:** Combining these factors with the base energy scale, $E_0$, and noting that a favorable interaction has negative energy, we arrive at the full energy model:\n    $$E_i(r_i, \\theta_i) = -E_0 \\cdot f_D(r_i) \\cdot f_A(\\theta_i) = -E_0 \\exp[-b(r_i - r_0)] \\cos^2(\\theta_{i, \\text{rad}})$$\n    All parameters ($E_0 = 25.0 \\text{ kJ/mol}$, $b = 1.5 \\text{ Å}^{-1}$, $r_0 = 2.8 \\text{ Å}$) are given. The angle $\\theta_i$ is provided in degrees and must be converted to radians for the cosine function.\n\n**2. Derivation of the Hydrogen Bond Lifetime Model, $\\tau_i$**\n\nThe dissociation of a hydrogen bond is a thermally activated process. Its kinetics can be modeled using an Arrhenius-type rate law.\n\n*   **Dissociation Rate ($k_{\\mathrm{off}, i}$):** The problem provides the expression for the dissociation rate constant:\n    $$k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{E_a}{RT}\\right)$$\n    where $\\nu_0$ is the attempt frequency, $R$ is the gas constant, $T$ is the temperature, and $E_a$ is the activation energy for dissociation. The activation energy is modeled as a fraction of the hydrogen bond's stabilization energy, $|E_i|$, scaled by a factor $\\alpha$. Thus, $E_a = \\alpha |E_i|$. Substituting this into the rate equation gives:\n    $$k_{\\mathrm{off}, i} = \\nu_0 \\exp\\left(-\\frac{\\alpha |E_i|}{RT}\\right)$$\n    Since $E_i$ is negative for a detected bond, $|E_i| = -E_i$.\n\n*   **Lifetime ($\\tau_i$):** The lifetime of the bond is the inverse of a first-order rate constant. Therefore, $\\tau_i$ is the reciprocal of $k_{\\mathrm{off}, i}$:\n    $$\\tau_i = \\frac{1}{k_{\\mathrm{off}, i}} = \\frac{1}{\\nu_0} \\exp\\left(\\frac{\\alpha |E_i|}{RT}\\right)$$\n    All parameters ($\\nu_0 = 1.0 \\times 10^{12} \\text{ s}^{-1}$, $\\alpha = 0.5$, $R=0.008314 \\text{ kJ/(mol·K)}$, $T = 300.0 \\text{ K}$) are specified. The units are consistent, yielding a lifetime $\\tau_i$ in seconds.\n\n**3. Algorithmic Procedure for Sensitivity Analysis**\n\nThe core of the task is to implement a computational procedure to perform the sensitivity analysis for each given test case $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}}, \\Delta r, \\Delta \\theta)$.\n\nThe central computational kernel is a function that calculates the mean energy and lifetime for a given pair of thresholds, $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$. This function proceeds as follows:\n1.  Identify the subset $S$ of the $N=10$ candidate interactions that satisfy the detection criterion: $r_i \\leq r_{\\mathrm{thr}}$ and $\\theta_i \\geq \\theta_{\\mathrm{thr}}$.\n2.  If the set $S$ is empty, the mean energy $\\bar{E}$ and mean lifetime $\\bar{\\tau}$ are both defined to be $0$.\n3.  If $S$ is not empty, calculate $E_i$ and $\\tau_i$ for each interaction $i \\in S$ using the models derived above.\n4.  Compute the arithmetic means: $\\bar{E} = \\frac{1}{|S|} \\sum_{i \\in S} E_i$ and $\\bar{\\tau} = \\frac{1}{|S|} \\sum_{i \\in S} \\tau_i$.\n\nFor each test case, the full analysis involves these steps:\n1.  **Central Values:** Compute $\\bar{E}_0$ and $\\bar{\\tau}_0$ using the central thresholds $(r_{\\mathrm{thr}}, \\theta_{\\mathrm{thr}})$.\n\n2.  **Distance Sensitivity:**\n    *   Define perturbed distance thresholds: $r_{thr,+} = r_{\\mathrm{thr}} + \\Delta r$ and $r_{thr,-} = \\max(0, r_{\\mathrm{thr}} - \\Delta r)$.\n    *   Compute $(\\bar{E}_{+}^{(r)}, \\bar{\\tau}_{+}^{(r)})$ using $(r_{thr,+}, \\theta_{\\mathrm{thr}})$.\n    *   Compute $(\\bar{E}_{-}^{(r)}, \\bar{\\tau}_{-}^{(r)})$ using $(r_{thr,-}, \\theta_{\\mathrm{thr}})$.\n    *   Calculate the dimensionless relative changes:\n        $$ \\delta_E^{(r)} = \\frac{|\\bar{E}_{+}^{(r)} - \\bar{E}_{-}^{(r)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(r)} = \\frac{|\\bar{\\tau}_{+}^{(r)} - \\bar{\\tau}_{-}^{(r)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n3.  **Angle Sensitivity:**\n    *   Define perturbed angle thresholds: $\\theta_{thr,+} = \\min(180, \\theta_{\\mathrm{thr}} + \\Delta \\theta)$ and $\\theta_{thr,-} = \\max(0, \\theta_{\\mathrm{thr}} - \\Delta \\theta)$.\n    *   Compute $(\\bar{E}_{+}^{(\\theta)}, \\bar{\\tau}_{+}^{(\\theta)})$ using $(r_{\\mathrm{thr}}, \\theta_{thr,+})$.\n    *   Compute $(\\bar{E}_{-}^{(\\theta)}, \\bar{\\tau}_{-}^{(\\theta)})$ using $(r_{\\mathrm{thr}}, \\theta_{thr,-})$.\n    *   Calculate the dimensionless relative changes:\n        $$ \\delta_E^{(\\theta)} = \\frac{|\\bar{E}_{+}^{(\\theta)} - \\bar{E}_{-}^{(\\theta)}|}{\\max(|\\bar{E}_0|, \\varepsilon)}, \\quad \\delta_{\\tau}^{(\\theta)} = \\frac{|\\bar{\\tau}_{+}^{(\\theta)} - \\bar{\\tau}_{-}^{(\\theta)}|}{\\max(|\\bar{\\tau}_0|, \\varepsilon)} $$\n\n4.  **Robustness Evaluation:**\n    *   Determine the boolean robustness flag by comparing all four sensitivity metrics against the tolerance $\\rho = 0.20$:\n        $$ \\mathrm{robust} = (\\delta_E^{(r)} \\leq \\rho) \\land (\\delta_E^{(\\theta)} \\leq \\rho) \\land (\\delta_{\\tau}^{(r)} \\leq \\rho) \\land (\\delta_{\\tau}^{(\\theta)} \\leq \\rho) $$\n\n5.  **Output Assembly:**\n    *   For each test case, the final result is an ordered list of $7$ values: $[\\bar{E}_0, \\bar{\\tau}_0, \\delta_E^{(r)}, \\delta_E^{(\\theta)}, \\delta_{\\tau}^{(r)}, \\delta_{\\tau}^{(\\theta)}, \\mathrm{robust}]$. The implementation will perform this calculation for all four test cases and format the output as specified.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond sensitivity analysis problem.\n    \"\"\"\n\n    # --- Givens: Candidate Interactions, Constants, and Parameters ---\n\n    # Candidate interactions\n    # N = 10\n    distances_A = np.array([2.70, 2.90, 3.10, 3.30, 2.80, 3.00, 3.40, 2.60, 3.20, 2.75])\n    angles_deg = np.array([175, 160, 140, 130, 155, 145, 120, 178, 150, 165])\n\n    # Physical constants and model parameters\n    E0 = 25.0        # kJ/mol\n    b = 1.5          # 1/Å\n    r0 = 2.8         # Å\n    nu0 = 1.0e12     # 1/s\n    alpha = 0.5      # dimensionless\n    R = 0.008314     # kJ/(mol·K)\n    T = 300.0        # K\n    epsilon = 1.0e-12# dimensionless stabilizer\n    rho = 0.20       # dimensionless robustness tolerance\n\n    # Pre-calculate RT for efficiency\n    RT = R * T\n\n    # Test suite\n    test_cases = [\n        (3.20, 150.0, 0.10, 5.0),\n        (2.80, 170.0, 0.05, 2.0),\n        (4.00, 120.0, 0.20, 10.0),\n        (2.50, 175.0, 0.10, 5.0),\n    ]\n\n    # --- Core Calculation Logic ---\n\n    def calculate_means(r_thr, theta_thr):\n        \"\"\"\n        Calculates mean energy and lifetime for a given set of thresholds.\n        \"\"\"\n        detected_energies = []\n        detected_lifetimes = []\n\n        for r_i, theta_i_deg in zip(distances_A, angles_deg):\n            if r_i = r_thr and theta_i_deg >= theta_thr:\n                # Convert angle to radians for trigonometric functions\n                theta_i_rad = np.deg2rad(theta_i_deg)\n\n                # Calculate energy E_i\n                E_i = -E0 * np.exp(-b * (r_i - r0)) * (np.cos(theta_i_rad)**2)\n\n                # Calculate lifetime tau_i\n                abs_Ei = abs(E_i)\n                tau_i = (1.0 / nu0) * np.exp((alpha * abs_Ei) / RT)\n\n                detected_energies.append(E_i)\n                detected_lifetimes.append(tau_i)\n\n        if not detected_energies:  # The set of detected bonds S is empty\n            return 0.0, 0.0\n        \n        mean_E = np.mean(detected_energies)\n        mean_tau = np.mean(detected_lifetimes)\n        return mean_E, mean_tau\n\n    # --- Main Analysis Loop ---\n\n    all_results = []\n    for r_thr, theta_thr, dr, dtheta in test_cases:\n        # 1. Central values\n        E0_bar, tau0_bar = calculate_means(r_thr, theta_thr)\n\n        # 2. Sensitivity to distance threshold r_thr\n        r_thr_plus = r_thr + dr\n        r_thr_minus = max(0.0, r_thr - dr)\n        E_plus_r, tau_plus_r = calculate_means(r_thr_plus, theta_thr)\n        E_minus_r, tau_minus_r = calculate_means(r_thr_minus, theta_thr)\n\n        delta_E_r = abs(E_plus_r - E_minus_r) / max(abs(E0_bar), epsilon)\n        delta_tau_r = abs(tau_plus_r - tau_minus_r) / max(abs(tau0_bar), epsilon)\n\n        # 3. Sensitivity to angle threshold theta_thr\n        theta_thr_plus = min(180.0, theta_thr + dtheta)\n        theta_thr_minus = max(0.0, theta_thr - dtheta)\n        E_plus_theta, tau_plus_theta = calculate_means(r_thr, theta_thr_plus)\n        E_minus_theta, tau_minus_theta = calculate_means(r_thr, theta_thr_minus)\n\n        delta_E_theta = abs(E_plus_theta - E_minus_theta) / max(abs(E0_bar), epsilon)\n        delta_tau_theta = abs(tau_plus_theta - tau_minus_theta) / max(abs(tau0_bar), epsilon)\n\n        # 4. Robustness evaluation\n        is_robust = (delta_E_r = rho and\n                     delta_E_theta = rho and\n                     delta_tau_r = rho and\n                     delta_tau_theta = rho)\n\n        # 5. Assemble results for the current test case\n        result_for_case = [\n            E0_bar, tau0_bar,\n            delta_E_r, delta_E_theta,\n            delta_tau_r, delta_tau_theta,\n            is_robust\n        ]\n        all_results.append(result_for_case)\n\n    # --- Final Output Formatting ---\n    # Manually construct the string to avoid spaces introduced by str(list)\n    # and to ensure the exact format requested.\n    \n    output_parts = []\n    for res_list in all_results:\n        inner_parts = []\n        for val in res_list:\n            if isinstance(val, bool):\n                inner_parts.append(str(val).lower())\n            else:\n                inner_parts.append(str(val))\n        output_parts.append('[' + ','.join(inner_parts) + ']')\n    \n    final_output_string = '[' + ','.join(output_parts) + ']'\n    print(final_output_string)\n\nsolve()\n```"
        }
    ]
}