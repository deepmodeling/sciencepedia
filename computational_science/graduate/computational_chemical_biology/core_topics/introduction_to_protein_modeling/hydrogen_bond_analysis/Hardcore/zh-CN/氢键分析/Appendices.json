{
    "hands_on_practices": [
        {
            "introduction": "氢键分析的第一步是根据明确的几何标准来定义和应用检测方法。这个练习提供了使用最常见的几何标准（距离和角度）的实践经验，并强调了算法及其参数的选择如何显著影响分析结果。对于解读分子动力学模拟而言，这是一项基础技能。",
            "id": "3849667",
            "problem": "您的任务是设计并实现一种对氢键检测标准的原则性比较，该比较的灵感来自于分子动力学 (MD) 分析工具中的常见选择。您需要使用单条合成轨迹，并量化检测结果如何随几何阈值和算法规则而变化。场景涉及一个立方周期性模拟盒子中的单个供体-氢-受体三原子组，目标是计算每个算法在所有帧上的氢键占有率，然后比较不同算法之间的占有率。\n\n基本原理：氢键通常使用涉及重原子距离和角度约束的几何标准来检测。在周期性正交模拟单元中，必须使用最近镜像约定来计算位移。请使用以下定义和定律：\n\n- 带最近镜像位移的周期性边界条件：对于边长为 $L$ 的立方盒子内的两个位置，其分量分别为 $\\mathbf{r}_1 = (x_1,y_1,z_1)$ 和 $\\mathbf{r}_2 = (x_2,y_2,z_2)$，定义逐分量位移为\n$$\n\\Delta_i = x_{2,i} - x_{1,i}, \\quad \\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2,\\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2,\\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n并设置最小镜像位移 $\\Delta \\mathbf{r} = (\\Delta_x',\\Delta_y',\\Delta_z')$。\n- 欧几里得距离：对于任何位移矢量 $\\Delta \\mathbf{r}$，重原子或氢原子的间距为 $r = \\|\\Delta \\mathbf{r}\\| = \\sqrt{\\Delta_x'^2 + \\Delta_y'^2 + \\Delta_z'^2}$。\n- 氢原子处的角度：对于矢量 $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ 和 $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$（两者均在最近镜像约定下计算），定义供体-氢-受体角为\n$$\n\\theta = \\arccos\\!\\left(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\,\\|\\mathbf{v}\\|}\\right) \\times \\frac{180}{\\pi},\n$$\n以度为单位表示。\n\n氢键占有率：对于一个将每一帧的氢键状态分类为布尔值的算法，定义在 $N_f$ 帧上的占有率为\n$$\nO = \\frac{1}{N_f}\\sum_{t=1}^{N_f} \\mathbb{I}_t,\n$$\n其中 $\\mathbb{I}_t$ 是指示函数，如果第 $t$ 帧满足氢键标准，则其值为 $1$，否则为 $0$。占有率是无单位的，应以小数形式报告。\n\n待比较的算法：\n- 算法 A（重原子距离和角度）：如果最近镜像氢-受体距离 $r_\\mathrm{HA}$ 满足 $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$，并且供体-氢-受体角 $\\theta$ 满足 $\\theta \\ge \\theta^{\\mathrm{cut}}$，则某一帧存在氢键。\n- 算法 B（仅重原子距离）：如果最近镜像供体-受体距离 $r_\\mathrm{DA}$ 满足 $r_\\mathrm{DA} \\le r_\\mathrm{DA}^{\\mathrm{cut}}$，则某一帧存在氢键。\n- 算法 C（供体-氢键存在性加算法 A）：如果最近镜像供体-氢距离 $r_\\mathrm{DH}$ 满足 $r_\\mathrm{DH} \\le r_\\mathrm{DH}^{\\mathrm{cut}}$，并且同时满足算法 A 的条件 $r_\\mathrm{HA} \\le r_\\mathrm{HA}^{\\mathrm{cut}}$ 和 $\\theta \\ge \\theta^{\\mathrm{cut}}$，则某一帧存在氢键。\n\n轨迹规格：\n- 使用一个边长为 $L = 10\\,\\mathrm{\\AA}$ 的立方周期性盒子。\n- 该轨迹包含 $N_f = 6$ 帧，各帧的供体 $\\mathbf{r}_\\mathrm{D}(t)$、氢 $\\mathbf{r}_\\mathrm{H}(t)$ 和受体 $\\mathbf{r}_\\mathrm{A}(t)$ 位置（单位为 $\\mathrm{\\AA}$）如下：\n  - 第 1 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (4,1,1)$。\n  - 第 2 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (4.6,0.4,1)$。\n  - 第 3 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (3.4,1,1)$。\n  - 第 4 帧：$\\mathbf{r}_\\mathrm{D} = (1,1,1)$，$\\mathbf{r}_\\mathrm{H} = (2,1,1)$，$\\mathbf{r}_\\mathrm{A} = (2.9,1,0)$。\n  - 第 5 帧：$\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{A} = (2.5,0.5,0.5)$。\n  - 第 6 帧：$\\mathbf{r}_\\mathrm{D} = (9.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{H} = (0.5,0.5,0.5)$，$\\mathbf{r}_\\mathrm{A} = (1.914213562,1.914213562,0.5)$。\n\n角度单位说明：所有角度必须以度为单位进行计算和比较。距离必须以 $\\mathrm{\\AA}$ 为单位进行计算和比较。\n\n输出的量化指标：对于每个阈值参数集（测试用例），计算三种占有率 $O_A$、$O_B$ 和 $O_C$，然后将占有率之间的绝对差值以下列列表形式报告\n$$\n\\left[\\,|O_A - O_B|,\\; |O_A - O_C|,\\; |O_B - O_C|\\,\\right].\n$$\n将每个差值四舍五入到三位小数。\n\n测试套件：\n- 用例 1（典型阈值）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 150\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$。\n- 用例 2（严格阈值，包含边界等式）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 165\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$。\n- 用例 3（宽松阈值，包含角度边界）：$r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 135\\,\\mathrm{deg}$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含三个测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素本身是该用例的三个四舍五入后的绝对差值列表，不含空格。例如：$[[d_{11},d_{12},d_{13}],[d_{21},d_{22},d_{23}],[d_{31},d_{32},d_{33}]]$，需精确打印为单行，如 \"[[0.333,0.000,0.333],[...],[...]]\"。",
            "solution": "该问题是有效的。其科学基础植根于计算化学生物学的原理，特别是分子动力学轨迹中氢键的几何分析。其定义、数据和目标是自洽、一致且适定的，可以得出一个唯一且可验证的解。\n\n求解过程分为三个主要阶段：\n1.  对于合成轨迹中的 $N_f = 6$ 帧中的每一帧，我们计算关键的几何参数：供体-受体距离 ($r_\\mathrm{DA}$)、氢-受体距离 ($r_\\mathrm{HA}$)、供体-氢距离 ($r_\\mathrm{DH}$) 以及供体-氢-受体角 ($\\theta$)。这些计算必须严格遵守边长为 $L = 10\\,\\mathrm{\\AA}$ 的指定周期性立方盒子的最近镜像约定。\n2.  对于三个测试用例（每个用例提供一组不同的截断阈值），我们遍历每一帧预先计算好的几何参数。我们应用算法 A、B 和 C 的逻辑标准来判断根据每种算法，该帧中是否存在氢键。\n3.  对给定测试用例的所有帧进行分类后，我们计算每种算法的占有率 $O$，即检测到氢键的帧数所占的比例。最后，我们计算这些占有率之间所需的绝对差值 $|O_A - O_B|$、 $|O_A - O_C|$ 和 $|O_B - O_C|$，并将它们四舍五入到三位小数。\n\n**步骤 1：几何参数的计算**\n\n我们根据问题陈述定义了三个辅助函数，用于计算最小镜像位移、距离和角度。\n\n在边长为 L 的立方盒子中，两个位置矢量 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$ 之间的最小镜像位移 $\\Delta \\mathbf{r}'$ 是逐分量计算的。对于每个分量 $i \\in \\{x, y, z\\}$：\n$$\n\\Delta_i = x_{2,i} - x_{1,i}\n$$\n$$\n\\Delta_i' =\n\\begin{cases}\n\\Delta_i - L,  \\text{if } \\Delta_i  L/2 \\\\\n\\Delta_i + L,  \\text{if } \\Delta_i  -L/2 \\\\\n\\Delta_i,  \\text{otherwise.}\n\\end{cases}\n$$\n\n距离 $r$ 是所得位移矢量的欧几里得范数，$r = \\|\\Delta \\mathbf{r}'\\|$。矢量 $\\mathbf{u} = \\mathbf{r}_\\mathrm{D} - \\mathbf{r}_\\mathrm{H}$ 和 $\\mathbf{v} = \\mathbf{r}_\\mathrm{A} - \\mathbf{r}_\\mathrm{H}$ （两者均使用最近镜像约定计算）之间的夹角 $\\theta$ 由 $\\theta = \\arccos(\\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\|\\|\\mathbf{v}\\|})$ 给出，并转换为度。\n\n将这些定义应用于轨迹数据（$L=10\\,\\mathrm{\\AA}$，$N_f=6$ 帧），可为每一帧得出以下几何参数：\n\n| 帧 | $r_\\mathrm{DA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{HA}$ ($\\mathrm{\\AA}$) | $r_\\mathrm{DH}$ ($\\mathrm{\\AA}$) | $\\theta$ (度) |\n|---|---|---|---|---|\n| $1$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $2$ | $\\sqrt{13.32} \\approx 3.650$ | $\\sqrt{7.12} \\approx 2.668$ | $1.0$ | $166.99$ |\n| $3$ | $2.4$ | $1.4$ | $1.0$ | $180.0$ |\n| $4$ | $\\sqrt{4.61} \\approx 2.147$ | $\\sqrt{1.81} \\approx 1.345$ | $1.0$ | $132.01$ |\n| $5$ | $3.0$ | $2.0$ | $1.0$ | $180.0$ |\n| $6$ | $\\sqrt{5+2\\sqrt{2}} \\approx 2.798$ | $2.0$ | $1.0$ | $135.0$ |\n\n请注意，对于第 5 帧和第 6 帧，粒子的位置需要应用最近镜像约定。例如，在第 5 帧中，D-A 的直接位移是 $\\Delta\\mathbf{r} = (2.5-9.5, 0, 0) = (-7,0,0)$。由于 $\\Delta_x = -7  -L/2 = -5$，校正后的位移是 $\\Delta\\mathbf{r}' = (-7+10, 0, 0) = (3,0,0)$，得出 $r_\\mathrm{DA}=3.0\\,\\mathrm{\\AA}$。\n\n**步骤 2  3：算法的应用与差值计算**\n\n现在我们使用上表中的几何数据来处理每个测试用例。\n\n**测试用例 1：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.5\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 150^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.2\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.05\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 2.5$ 且 $\\theta \\ge 150^\\circ$)：** 第 1、3、5 帧满足标准。计数 = $3$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.2$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.05$ 且满足算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件 ($1.0 \\le 1.05$)。因此，这等同于算法 A。第 1、3、5 帧满足标准。计数 = $3$。\n\n占有率：\n- $O_A = 3/6 = 0.5$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 3/6 = 0.5$\n\n差值：\n- $|O_A - O_B| = |0.5 - 5/6| = 1/3 \\approx 0.333$\n- $|O_A - O_C| = |0.5 - 0.5| = 0.0$\n- $|O_B - O_C| = |5/6 - 0.5| = 1/3 \\approx 0.333$\n结果：$[0.333, 0.000, 0.333]$\n\n**测试用例 2：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 2.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 165^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.0\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 2.0$ 且 $\\theta \\ge 165^\\circ$)：** 第 1、3、5 帧满足标准。计数 = $3$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.0$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.0$ 且满足算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件 ($1.0 \\le 1.0$)。这等同于算法 A。第 1、3、5 帧满足标准。计数 = $3$。\n\n占有率和差值与用例 1 相同。\n结果：$[0.333, 0.000, 0.333]$\n\n**测试用例 3：** ($r_\\mathrm{HA}^{\\mathrm{cut}} = 3.0\\,\\mathrm{\\AA}$，$\\theta^{\\mathrm{cut}} = 135^\\circ$，$r_\\mathrm{DA}^{\\mathrm{cut}} = 3.5\\,\\mathrm{\\AA}$，$r_\\mathrm{DH}^{\\mathrm{cut}} = 1.2\\,\\mathrm{\\AA}$)\n\n- **算法 A ($r_\\mathrm{HA} \\le 3.0$ 且 $\\theta \\ge 135^\\circ$)：** 第 1、2、3、5、6 帧满足标准。计数 = $5$。\n- **算法 B ($r_\\mathrm{DA} \\le 3.5$)：** 第 1、3、4、5、6 帧满足标准。计数 = $5$。\n- **算法 C ($r_\\mathrm{DH} \\le 1.2$ 且满足算法 A)：** 所有帧都满足 $r_\\mathrm{DH}$ 的条件 ($1.0 \\le 1.2$)。这等同于算法 A。第 1、2、3、5、6 帧满足标准。计数 = $5$。\n\n占有率：\n- $O_A = 5/6 \\approx 0.8333$\n- $O_B = 5/6 \\approx 0.8333$\n- $O_C = 5/6 \\approx 0.8333$\n\n差值：\n- $|O_A - O_B| = |5/6 - 5/6| = 0.0$\n- $|O_A - O_C| = |5/6 - 5/6| = 0.0$\n- $|O_B - O_C| = |5/6 - 5/6| = 0.0$\n结果：$[0.000, 0.000, 0.000]$\n\n根据问题说明，这些结果将被格式化为单行，作为最终输出。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import sqrt, acos, degrees\n\ndef solve():\n    \"\"\"\n    Solves the hydrogen bond analysis problem by calculating occupancies\n    for three different algorithms across a synthetic trajectory and\n    reporting the differences between them for three test cases.\n    \"\"\"\n\n    # --- Data Definition ---\n\n    # Trajectory data: (r_D, r_H, r_A) for each frame\n    trajectory = [\n        # Frame 1\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.0, 1.0, 1.0])),\n        # Frame 2\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([4.6, 0.4, 1.0])),\n        # Frame 3\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([3.4, 1.0, 1.0])),\n        # Frame 4\n        (np.array([1.0, 1.0, 1.0]), np.array([2.0, 1.0, 1.0]), np.array([2.9, 1.0, 0.0])),\n        # Frame 5\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([2.5, 0.5, 0.5])),\n        # Frame 6\n        (np.array([9.5, 0.5, 0.5]), np.array([0.5, 0.5, 0.5]), np.array([1.914213562, 1.914213562, 0.5])),\n    ]\n    L = 10.0  # Box side length in Angstrom\n    N_f = len(trajectory)\n\n    # Test cases: (r_HA_cut, theta_cut, r_DA_cut, r_DH_cut)\n    test_cases = [\n        # Case 1 (typical)\n        (2.5, 150.0, 3.2, 1.05),\n        # Case 2 (strict)\n        (2.0, 165.0, 3.0, 1.0),\n        # Case 3 (loose)\n        (3.0, 135.0, 3.5, 1.2),\n    ]\n\n    # --- Helper Functions ---\n\n    def nearest_image_displacement(r2, r1, box_L):\n        \"\"\"Calculates the minimum image displacement vector from r1 to r2.\"\"\"\n        delta = r2 - r1\n        half_L = box_L / 2.0\n        # This explicit loop correctly implements the problem's definition\n        for i in range(len(delta)):\n            if delta[i] > half_L:\n                delta[i] -= box_L\n            elif delta[i]  -half_L:\n                delta[i] += box_L\n        return delta\n\n    # --- Main Logic ---\n\n    all_results = []\n    \n    for case in test_cases:\n        r_HA_cut, theta_cut, r_DA_cut, r_DH_cut = case\n        \n        h_bond_count_A = 0\n        h_bond_count_B = 0\n        h_bond_count_C = 0\n\n        for frame_coords in trajectory:\n            r_D, r_H, r_A = frame_coords\n\n            # Calculate geometric quantities for the frame\n            # Distances\n            dr_DA = nearest_image_displacement(r_A, r_D, L)\n            r_DA = np.linalg.norm(dr_DA)\n\n            dr_HA = nearest_image_displacement(r_A, r_H, L)\n            r_HA = np.linalg.norm(dr_HA)\n\n            dr_DH = nearest_image_displacement(r_H, r_D, L)\n            r_DH = np.linalg.norm(dr_DH)\n            \n            # Angle D-H-A\n            # Vector u from H to D\n            u = nearest_image_displacement(r_D, r_H, L)\n            # Vector v from H to A\n            v = dr_HA # This is already r_A - r_H with PBC\n            \n            norm_u = np.linalg.norm(u)\n            norm_v = r_HA\n            \n            # Prevent division by zero if atoms overlap\n            if norm_u > 1e-9 and norm_v > 1e-9:\n                dot_product = np.dot(u, v)\n                cosine_angle = dot_product / (norm_u * norm_v)\n                # Clip to handle floating point inaccuracies\n                cosine_angle = np.clip(cosine_angle, -1.0, 1.0)\n                angle = degrees(acos(cosine_angle))\n            else:\n                angle = 0.0\n\n            # Apply algorithm criteria\n            # Algorithm A\n            is_hbond_A = (r_HA = r_HA_cut) and (angle >= theta_cut)\n            if is_hbond_A:\n                h_bond_count_A += 1\n            \n            # Algorithm B\n            if r_DA = r_DA_cut:\n                h_bond_count_B += 1\n            \n            # Algorithm C\n            if (r_DH = r_DH_cut) and is_hbond_A:\n                h_bond_count_C += 1\n\n        # Calculate occupancies\n        O_A = h_bond_count_A / N_f\n        O_B = h_bond_count_B / N_f\n        O_C = h_bond_count_C / N_f\n        \n        # Calculate and round absolute differences\n        diff_AB = abs(O_A - O_B)\n        diff_AC = abs(O_A - O_C)\n        diff_BC = abs(O_B - O_C)\n        \n        all_results.append([diff_AB, diff_AC, diff_BC])\n\n    # --- Final Output Formatting ---\n    # According to the specified format \"[[d1,d2,d3],[...]]\"\n    inner_results_str = []\n    for R in all_results:\n        # Format numbers to 3 decimal places\n        formatted_diffs = [f\"{d:.3f}\" for d in R]\n        inner_results_str.append(f\"[{','.join(formatted_diffs)}]\")\n    \n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```"
        },
        {
            "introduction": "超越简单的一对一氢键，本次实践将处理更复杂的分叉氢键情景，即一个氢原子与多个受体相互作用。它要求你设计一个评分函数和一个冲突解决协议，这反映了在高级结构分析中所需的精细决策过程。",
            "id": "3849664",
            "problem": "您需要从第一性原理出发，实现一个稳健的氢键计算检测方案，该方案通过定义多个相互竞争的几何约束和一种有原则的冲突解决方案，明确地处理了单个氢供体上的分叉情况。计算在三维欧几里得空间中进行，所有距离以埃（ångström）为单位，角度以度为单位。该方案涉及一个供体原子 $D$、一个与其共价键合的氢原子 $H$ 以及一组候选受体原子 $A_i$（索引 $i \\in \\{0,1,\\dots,n-1\\}$）。\n\n必须使用的基本出发点和定义：\n- 使用欧几里得范数测量距离，使用点积测量角度。距离和角度是基本的几何量，必须从 $D$、$H$ 和 $A_i$ 在三维空间中的位置导出。\n- 氢原子处的角度，记为 $\\theta_{DHA,i}$，必须定义为向量 $H \\rightarrow D$ 和 $H \\rightarrow A_i$ 之间的夹角，这反映了氢键的线性偏好。\n- 氢到受体的距离（记为 $r_{HA,i}$）和供体到受体的距离（记为 $r_{DA,i}$）都必须根据原子的位置计算。\n\n需要实现的氢键检测标准：\n1. 对每个受体 $A_i$ 的硬性几何可行性：\n   - 氢-受体距离 $r_{HA,i}$ 必须在物理上合理的范围 $[r_{\\text{min}}, r_{\\text{max}}]$ 内，其中 $r_{\\text{min}} = 1.4$ 且 $r_{\\text{max}} = 2.5$（单位：埃）。\n   - 供体-受体距离 $r_{DA,i}$ 必须在合理的范围 $[d_{\\text{min}}, d_{\\text{max}}]$ 内，其中 $d_{\\text{min}} = 2.5$ 且 $d_{\\text{max}} = 3.5$（单位：埃）。\n   - 角度 $\\theta_{DHA,i}$ 必须至少为 $\\theta_{\\text{min}} = 130$（单位：度）。\n   任何未能满足这些硬性条件中任意一个的受体将不被进一步考虑。\n2. 分叉兼容性：\n   - 一个氢原子最多可以同时形成两个氢键。如果同时选择了两个受体 $A_i$ 和 $A_j$，则在氢原子处，向量 $H \\rightarrow A_i$ 和 $H \\rightarrow A_j$ 之间的分离角（记为 $\\phi_{ij}$）必须至少为 $\\phi_{\\text{min}} = 12$（单位：度）。\n3. 用于冲突解决的评分机制：\n   - 每个几何上可行的受体 $A_i$ 必须获得一个连续分数 $S_i$。当 $r_{HA,i}$ 和 $r_{DA,i}$ 偏离典型值以及 $\\theta_{DHA,i}$ 偏离理想线性构型时，该分数会降低。分数必须基于根据与物理上合理的目标值的平方偏差构建的指数惩罚，且不引入不连续性。使用的目标值为 $r_0 = 1.8$（单位：埃）、$d_0 = 3.0$（单位：埃）和 $\\theta_0 = 180$（单位：度）。设定偏差尺度的标准差为 $\\sigma_r = 0.2$（单位：埃）、$\\sigma_d = 0.3$（单位：埃）和 $\\sigma_\\theta = 10$（单位：度）。此外，还需包含一个基于供体-氢共价键长 $r_{DH}$ 相对于目标值 $r_{DH,0} = 1.0$（单位：埃）和尺度 $\\sigma_{DH} = 0.05$（单位：埃）的惩罚项，使用相同的指数-平方偏差原理。供体-氢共价键长必须根据 $D$ 和 $H$ 为每个案例计算一次。\n4. 冲突解决：\n   - 从几何上可行的受体集合中，选择一个大小最多为2的子集，该子集在满足任意选定对 $(i,j)$ 的分离角约束 $\\phi_{ij} \\ge \\phi_{\\text{min}}$ 的前提下，使分数总和 $\\sum S_i$ 最大化。如果没有一对受体满足分离约束，则选择分数最高的单个受体。如果分数总和出现平局，则选择其排序后的索引列表在字典序上最小的子集。\n\n您的程序必须实现以上所有内容，并将其应用于以下测试套件。每个测试用例由 $D$、$H$ 的位置以及受体位置 $A_i$ 的列表指定。所有坐标均以埃为单位。对于所有案例，请使用上面指定的相同参数值和相同的角度单位（度）：\n\n测试用例1（理想情况，两个兼容的受体）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$\n\n测试用例2（三个受体，选择最佳分叉对）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.6, -0.2, 0.0)$, $A_2 = (2.45, 0.8, 0.0)$\n\n测试用例3（边界角度和一个不合格的距离）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.157, 1.379, 0.0)$, $A_1 = (3.6, 0.0, 0.0)$\n\n测试用例4（因分离角过小而冲突，选择单个最佳受体）：\n- $D = (0.0, 0.0, 0.0)$\n- $H = (1.0, 0.0, 0.0)$\n- $A_0 = (2.8, 0.2, 0.0)$, $A_1 = (2.7, 0.0, 0.0)$\n\n最终输出规范：\n- 对于每个测试用例，输出所选受体的索引列表，按升序排列，形式为整数列表，每个案例最多包含两个元素。将所有测试用例的结果聚合到单行中，形式为由方括号括起来的逗号分隔列表，每个案例的列表也由其自身的方括号括起来。例如，四个案例的输出可能看起来像 “[[0,1],[2,3],[1],[0]]”。您的程序必须严格按照此格式生成一行输出。",
            "solution": "该问题要求实现一个计算算法，用于识别单个供体-氢体系（$D-H$）与多个潜在受体原子（$A_i$）相互作用时形成的氢键，包括分叉氢键。该解决方案将遵循指定的几何可行性、评分和冲突解决标准来开发。所有数学实体均按要求使用 LaTeX 渲染。\n\n首先，我们在三维欧几里得空间中建立必要的几何形式体系。原子 $D$、$H$ 和 $A_i$ 的位置以 $\\mathbb{R}^3$ 中向量的形式给出。让它们分别为 $\\vec{p}_D$、$\\vec{p}_H$ 和 $\\vec{p}_{A,i}$。\n\n两个原子（例如 $P_1$ 和 $P_2$）之间的距离是连接它们的向量的欧几里得范数：\n$$ d(P_1, P_2) = \\| \\vec{p}_{P_2} - \\vec{p}_{P_1} \\| = \\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2} $$\n\n由三个原子形成的角，例如在原子 $P_2$ 处、介于原子 $P_1$ 和 $P_3$ 之间的角 $\\alpha$，是通过源自 $P_2$ 的向量的点积计算的：$\\vec{v}_1 = \\vec{p}_{P_1} - \\vec{p}_{P_2}$ 和 $\\vec{v}_2 = \\vec{p}_{P_3} - \\vec{p}_{P_2}$。\n$$ \\alpha = \\arccos\\left( \\frac{\\vec{v}_1 \\cdot \\vec{v}_2}{\\|\\vec{v}_1\\| \\|\\vec{v}_2\\|} \\right) $$\n$\\arccos$ 函数的结果以弧度为单位，必须转换为度才能与给定的角度阈值进行比较：$\\alpha_{\\text{deg}} = \\alpha_{\\text{rad}} \\times \\frac{180}{\\pi}$。\n\n该算法分三个主要阶段进行：\n\n**1. 可行性分析**\n\n对于每个候选受体 $A_i$，我们评估一组硬性几何约束。一个受体必须满足以下所有条件，才能被视为形成氢键的可行候选者：\n\n*   **氢-受体距离 ($r_{HA,i}$):** 氢 $H$ 和受体 $A_i$ 之间的距离必须在指定范围内。\n    $$ r_{HA,i} = d(H, A_i) \\quad | \\quad r_{\\text{min}} \\le r_{HA,i} \\le r_{\\text{max}} $$\n    其中 $r_{\\text{min}} = 1.4$ Å 且 $r_{\\text{max}} = 2.5$ Å。\n\n*   **供体-受体距离 ($r_{DA,i}$):** 供体 $D$ 和受体 $A_i$ 之间的距离必须在其允许范围内。\n    $$ r_{DA,i} = d(D, A_i) \\quad | \\quad d_{\\text{min}} \\le r_{DA,i} \\le d_{\\text{max}} $$\n    其中 $d_{\\text{min}} = 2.5$ Å 且 $d_{\\text{max}} = 3.5$ Å。\n\n*   **氢键角 ($\\theta_{DHA,i}$):** 氢原子处的角度必须表明接近线性的排列。该角度定义在从 $H$ 到 $D$ 的向量 ($\\vec{HD} = \\vec{p}_D - \\vec{p}_H$) 和从 $H$ 到 $A_i$ 的向量 ($\\vec{HA_i} = \\vec{p}_{A,i} - \\vec{p}_H$) 之间。\n    $$ \\theta_{DHA,i} = \\text{angle}(D, H, A_i) \\quad | \\quad \\theta_{DHA,i} \\ge \\theta_{\\text{min}} $$\n    其中 $\\theta_{\\text{min}} = 130$ 度。\n\n任何未能满足这三个标准中任意一个的受体 $A_i$ 都将被丢弃，不再进一步考虑。\n\n**2. 可行受体的评分**\n\n每个可行的受体 $A_i$ 都被赋予一个分数 $S_i$，用以量化潜在氢键的质量。分数越高，表示几何构型越理想。该分数定义为与理想目标值的平方、缩放偏差之和的指数函数。\n\n首先，为每个测试用例计算一次供体-氢共价键长 $r_{DH} = d(D, H)$。\n\n然后，一个可行受体 $A_i$ 的分数 $S_i$ 由下式给出：\n$$ S_i = \\exp\\left( - \\left[ \\left(\\frac{r_{DH} - r_{DH,0}}{\\sigma_{DH}}\\right)^2 + \\left(\\frac{r_{HA,i} - r_0}{\\sigma_r}\\right)^2 + \\left(\\frac{r_{DA,i} - d_0}{\\sigma_d}\\right)^2 + \\left(\\frac{\\theta_{DHA,i} - \\theta_0}{\\sigma_\\theta}\\right)^2 \\right] \\right) $$\n评分函数的参数为：\n*   理想氢-受体距离：$r_0 = 1.8$ Å，尺度：$\\sigma_r = 0.2$ Å。\n*   理想供体-受体距离：$d_0 = 3.0$ Å，尺度：$\\sigma_d = 0.3$ Å。\n*   理想氢键角：$\\theta_0 = 180$ 度，尺度：$\\sigma_\\theta = 10$ 度。\n*   理想供体-氢距离：$r_{DH,0} = 1.0$ Å，尺度：$\\sigma_{DH} = 0.05$ Å。\n\n此公式产生一个介于 $0$ 和 $1$ 之间的连续分数，其中分数为 $1$ 表示在所有度量标准上都达到了完全理想的几何构型。\n\n**3. 冲突解决与选择**\n\n最后一步是选择最佳的氢键受体集合，最多为两个（一个分叉键）。这是一个受空间约束和明确平局规则约束的最大化问题。\n\n总体策略是生成所有可能的有效解（受体子集），计算它们的总分，然后选择最佳的一个。\n\n*   **候选解的生成：**\n    1.  **单受体候选解：** 对于每个分数为 $S_i$ 的可行受体 $A_i$，单元素集合 $\\{i\\}$ 是一个候选解。其总分就是 $S_i$。\n    2.  **双受体候选解：** 对于每对不同的可行受体 $(A_i, A_j)$（其中 $i  j$），我们必须检查其分叉兼容性。这要求氢原子处的分离角 $\\phi_{ij}$ 足够大。角度 $\\phi_{ij}$ 由向量 $\\vec{HA_i}$ 和 $\\vec{HA_j}$ 形成。\n        $$ \\phi_{ij} = \\text{angle}(A_i, H, A_j) \\ge \\phi_{\\text{min}} $$\n        其中 $\\phi_{\\text{min}} = 12$ 度。如果此条件成立，集合 $\\{i, j\\}$ 是一个有效的候选解。其总分为各个分数之和，$S_i + S_j$。\n\n*   **最佳选择：**\n    从所有有效的单受体和双受体候选解的集合中，我们必须选择总分最高的那一个。\n    *   让每个候选解由一个元组 `(total_score, sorted_index_list)` 表示。例如，一个单受体候选解是 $(S_i, [i])$，一个双受体候选解是 $(S_i+S_j, [i, j])$。\n    *   最优解对应于此集合中的最大元组。Python 的默认元组比较非常适合此目的：它首先比较第一个元素（`total_score`），如果出现平局，则继续比较第二个元素（`sorted_index_list`）。按字典序比较列表正确地实现了指定的平局打破规则。\n    *   如果在第一步中没有受体被认为是可行的，则结果集为空。\n\n这个系统性的程序保证了根据问题标准得出一个唯一且最优的解。",
            "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases for hydrogen bond detection.\n    \"\"\"\n\n    # Define physical and geometric parameters as per the problem statement.\n    params = {\n        'r_min': 1.4, 'r_max': 2.5,  # Angstrom\n        'd_min': 2.5, 'd_max': 3.5,  # Angstrom\n        'theta_min': 130.0,         # Degrees\n        'phi_min': 12.0,            # Degrees\n        'r0': 1.8, 'sigma_r': 0.2,   # Angstrom\n        'd0': 3.0, 'sigma_d': 0.3,   # Angstrom\n        'theta0': 180.0, 'sigma_theta': 10.0, # Degrees\n        'r_dh0': 1.0, 'sigma_dh': 0.05 # Angstrom\n    }\n\n    # Define test cases. Each case is a tuple (D_pos, H_pos, A_pos_list).\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.6, -0.2, 0.0]), np.array([2.45, 0.8, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.157, 1.379, 0.0]), np.array([3.6, 0.0, 0.0])]),\n        (np.array([0.0, 0.0, 0.0]), np.array([1.0, 0.0, 0.0]), [np.array([2.8, 0.2, 0.0]), np.array([2.7, 0.0, 0.0])]),\n    ]\n    \n    final_results = []\n    for case in test_cases:\n        D, H, A_list = case\n        result = process_case(D, H, A_list, params)\n        final_results.append(result)\n\n    # Format the output as specified: \"[[0,1],[2],[0]]\"\n    output_str = f\"[{','.join([str(r).replace(' ', '') for r in final_results])}]\"\n    print(output_str)\n\ndef get_angle(p1, p2, p3):\n    \"\"\"Calculates the angle in degrees at p2 between vectors p2->p1 and p2->p3.\"\"\"\n    v1 = p1 - p2\n    v2 = p3 - p2\n    \n    v1_norm = np.linalg.norm(v1)\n    v2_norm = np.linalg.norm(v2)\n    \n    if v1_norm == 0 or v2_norm == 0:\n        return 0.0 # Or handle as an error, though not expected here.\n\n    # Clamp dot_product / (norms) to [-1, 1] to avoid floating point errors with arccos\n    cos_theta = np.dot(v1, v2) / (v1_norm * v2_norm)\n    cos_theta_clamped = np.clip(cos_theta, -1.0, 1.0)\n    \n    angle_rad = np.arccos(cos_theta_clamped)\n    return np.degrees(angle_rad)\n\ndef process_case(D, H, A_list, params):\n    \"\"\"\n    Processes a single test case for hydrogen bond detection.\n    \"\"\"\n    \n    # --- 1. Feasibility Analysis ---\n    feasible_acceptors = []\n    for i, A_i in enumerate(A_list):\n        r_da = np.linalg.norm(A_i - D)\n        r_ha = np.linalg.norm(A_i - H)\n        theta_dha = get_angle(D, H, A_i)\n        \n        if (params['d_min'] = r_da = params['d_max'] and\n            params['r_min'] = r_ha = params['r_max'] and\n            theta_dha >= params['theta_min']):\n            \n            feasible_acceptors.append({\n                'index': i,\n                'pos': A_i,\n                'r_da': r_da,\n                'r_ha': r_ha,\n                'theta_dha': theta_dha\n            })\n\n    if not feasible_acceptors:\n        return []\n\n    # --- 2. Scoring ---\n    r_dh = np.linalg.norm(H - D)\n    r_dh_term = ((r_dh - params['r_dh0']) / params['sigma_dh'])**2\n\n    for acc in feasible_acceptors:\n        r_ha_term = ((acc['r_ha'] - params['r0']) / params['sigma_r'])**2\n        r_da_term = ((acc['r_da'] - params['d0']) / params['sigma_d'])**2\n        theta_term = ((acc['theta_dha'] - params['theta0']) / params['sigma_theta'])**2\n        \n        total_penalty = r_dh_term + r_ha_term + r_da_term + theta_term\n        acc['score'] = np.exp(-total_penalty)\n    \n    # --- 3. Conflict Resolution and Selection ---\n    candidate_solutions = []\n\n    # Add single-acceptor candidates\n    for acc in feasible_acceptors:\n        candidate_solutions.append((acc['score'], [acc['index']]))\n        \n    # Add two-acceptor candidates\n    if len(feasible_acceptors) >= 2:\n        for i in range(len(feasible_acceptors)):\n            for j in range(i + 1, len(feasible_acceptors)):\n                acc1 = feasible_acceptors[i]\n                acc2 = feasible_acceptors[j]\n                \n                # Check separation angle constraint\n                phi_ij = get_angle(acc1['pos'], H, acc2['pos'])\n                \n                if phi_ij >= params['phi_min']:\n                    total_score = acc1['score'] + acc2['score']\n                    indices = sorted([acc1['index'], acc2['index']])\n                    candidate_solutions.append((total_score, indices))\n    \n    # Find the best candidate\n    # Python's max() on a list of tuples automatically handles the required logic:\n    # it sorts by the first element (score), and on ties, by the second (lexicographical list).\n    if not candidate_solutions:\n        return []\n    \n    best_solution = max(candidate_solutions)\n    return best_solution[1]\n\n# Execute the solver.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "本练习将焦点从静态识别转移到动态行为，它将氢键的逐帧检测与其潜在的动力学联系起来。通过分析间歇自相关函数，你将学习如何估算氢键的断裂和形成速率常数，从而深入了解其稳定性和寿命。",
            "id": "3849595",
            "problem": "一次蛋白质-配体复合物的分子动力学 (MD) 模拟监测一个特定的供体-受体氢键。设二元占据算符 $h(t)$ 在时间 $t$ 氢键存在时等于 $1$，否则等于 $0$。假设该氢键动力学可以很好地用一个连续时间双态马尔可夫过程来描述，该过程具有状态 $F$（氢键形成）和 $U$（氢键未形成），以及从 $F \\to U$ 的恒定速率常数 $k_{\\mathrm{break}}$ 和从 $U \\to F$ 的恒定速率常数 $k_{\\mathrm{form}}$。间歇性氢键自相关函数 $C_{\\mathrm{int}}(t)$ 定义为 $h(0) h(t)$ 的系综平均值与 $h$ 的平衡平均值的比值，因此 $C_{\\mathrm{int}}(t) = \\langle h(0) h(t) \\rangle / \\langle h \\rangle$。系统处于稳态。\n\n仅使用双态动力学的核心定义和 $C_{\\mathrm{int}}(t)$ 的定义，首先推导该双态模型中 $C_{\\mathrm{int}}(t)$ 与速率常数 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$ 之间的关系。然后，对时间范围 $t \\in [0, 10]$ 皮秒内的模拟间歇性相关函数进行经验拟合，得到\n$$\nC_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\!\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right).\n$$\n在计算中，将此拟合中的系数和时间常数视为精确值。估算 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$。\n\n将 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$ 均以 $\\mathrm{ps}^{-1}$ 为单位表示，并将每个值四舍五入到四位有效数字。最终答案必须以包含两个元素的行矩阵形式给出，顺序为 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$。",
            "solution": "该问题要求推导双态马尔可夫过程中间歇性氢键自相关函数 $C_{\\mathrm{int}}(t)$ 的表达式，然后使用该函数的经验拟合来确定潜在的动力学速率常数 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$。\n\n首先，我们验证问题陈述。\n\n### 步骤 1：提取已知条件\n-   二元占据算符：$h(t) = 1$ 如果氢键形成（状态 $F$），$h(t) = 0$ 如果未形成（状态 $U$）。\n-   动力学模型：连续时间双态马尔可夫过程，$F \\rightleftharpoons U$。\n-   速率常数：$F \\to U$ 跃迁的速率常数为 $k_{\\mathrm{break}}$，$U \\to F$ 跃迁的速率常数为 $k_{\\mathrm{form}}$。\n-   系统条件：系统处于稳态。\n-   间歇性自相关函数的定义：$C_{\\mathrm{int}}(t) = \\frac{\\langle h(0) h(t) \\rangle}{\\langle h \\rangle}$。\n-   模拟数据的经验拟合：$C_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right)$。\n-   指示：将数值系数（$0.57$, $0.43$）和时间常数（$0.83\\ \\mathrm{ps}$）视为精确值。\n-   目标：估算 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$，单位为 $\\mathrm{ps}^{-1}$，并四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n-   **科学依据：** 该问题基于标准且广泛使用的化学过程双态动力学模型，这是化学动力学和计算生物物理学的基石。使用自相关函数分析分子模拟的时间序列数据是一项基本技术。该模型在科学上是有效的。\n-   **良态问题：** 问题提供了一个清晰的理论框架、$C_{\\mathrm{int}}(t)$ 这个可观测量的一个具体定义，以及足够的经验数据来唯一确定模型参数（$k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$）。该问题是良态的。\n-   **客观性：** 问题以精确、无歧义的科学语言陈述，没有主观因素。\n\n### 步骤 3：结论和行动\n该问题是有效的，因为它在科学上是合理的、良态的、客观的，并且包含了所有必要的信息。我们继续进行求解。\n\n### $C_{\\mathrm{int}}(t)$ 理论表达式的推导\n\n间歇性自相关函数定义为 $C_{\\mathrm{int}}(t) = \\frac{\\langle h(0) h(t) \\rangle}{\\langle h \\rangle}$。设 $P_F$ 为氢键形成（状态 $F$）的平衡概率，$P_U$ 为氢键未形成（状态 $U$）的平衡概率。根据定义，$P_F + P_U = 1$。\n\n系综平均值 $\\langle h \\rangle$ 是氢键形成的平衡概率，因为在状态 $F$ 时 $h$ 为 $1$，在状态 $U$ 时为 $0$。\n$$\n\\langle h \\rangle = (1) \\cdot P_F + (0) \\cdot P_U = P_F\n$$\n项 $\\langle h(0) h(t) \\rangle$ 是在时间 $t=0$ 和时间 $t$ 都发现氢键形成的联合概率。由于系统处于稳态，该过程是平稳的。我们可以使用条件概率来写出这个联合概率：\n$$\n\\langle h(0) h(t) \\rangle = P(h(t)=1, h(0)=1) = P(h(t)=1 | h(0)=1) \\cdot P(h(0)=1)\n$$\n此处，$P(h(0)=1)$ 是平衡概率 $P_F$，而 $P(h(t)=1 | h(0)=1)$ 是在给定时间 $t=0$ 时氢键已形成的情况下，在时间 $t$ 氢键仍然形成的条件概率。我们将其表示为 $P_{F|F}(t)$。\n\n将这些代入 $C_{\\mathrm{int}}(t)$ 的定义中：\n$$\nC_{\\mathrm{int}}(t) = \\frac{P_{F|F}(t) \\cdot P_F}{P_F} = P_{F|F}(t)\n$$\n因此，$C_{\\mathrm{int}}(t)$ 是在给定 $t=0$ 时氢键形成的情况下，在时间 $t$ 氢键仍然形成的条件概率。\n\n现在，我们必须从双态过程的主方程中找到 $P_{F|F}(t)$ 的表达式。设 $P_F(t)$ 和 $P_U(t)$ 是在时间 $t$ 处于状态 $F$ 和 $U$ 的概率。速率方程为：\n$$\n\\frac{d P_F(t)}{dt} = k_{\\mathrm{form}} P_U(t) - k_{\\mathrm{break}} P_F(t)\n$$\n使用约束条件 $P_F(t) + P_U(t) = 1$，我们可以写出 $P_U(t) = 1 - P_F(t)$。将其代入速率方程，得到关于 $P_F(t)$ 的一阶线性常微分方程：\n$$\n\\frac{d P_F(t)}{dt} = k_{\\mathrm{form}} (1 - P_F(t)) - k_{\\mathrm{break}} P_F(t) = k_{\\mathrm{form}} - (k_{\\mathrm{form}} + k_{\\mathrm{break}}) P_F(t)\n$$\n这个常微分方程的通解形式为 $P_F(t) = P_{F,\\text{eq}} + (P_F(0) - P_{F,\\text{eq}}) \\exp(-k_{\\text{relax}} t)$，其中 $P_F(0)$ 是 $t=0$ 时的初始概率，$k_{\\text{relax}} = k_{\\mathrm{form}} + k_{\\mathrm{break}}$ 是弛豫速率，$P_{F,\\text{eq}}$ 是平衡概率。\n\n在平衡（稳态）时，$\\frac{d P_F}{dt} = 0$，这给出 $k_{\\mathrm{form}} P_{U,\\text{eq}} = k_{\\mathrm{break}} P_{F,\\text{eq}}$。\n使用 $P_{U,\\text{eq}} = 1 - P_{F,\\text{eq}}$，我们有 $k_{\\mathrm{form}}(1 - P_{F,\\text{eq}}) = k_{\\mathrm{break}} P_{F,\\text{eq}}$。\n解出 $P_{F,\\text{eq}}$ 得：\n$$\nP_{F,\\text{eq}} = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}}\n$$\n因此：\n$$\nP_{U,\\text{eq}} = 1 - P_{F,\\text{eq}} = \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}}\n$$\n为了求得 $C_{\\mathrm{int}}(t) = P_{F|F}(t)$，我们求解该常微分方程，初始条件为系统在 $t=0$ 时处于状态 $F$，即 $P_F(0)=1$。\n$$\nC_{\\mathrm{int}}(t) = P_F(t)|_{P_F(0)=1} = P_{F,\\text{eq}} + (1 - P_{F,\\text{eq}}) \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\n代入平衡概率的表达式：\n$$\nC_{\\mathrm{int}}(t) = P_{F,\\text{eq}} + P_{U,\\text{eq}} \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\n这就是该模型中间歇性自相关函数的理论表达式。\n\n### 速率常数的估算\n\n推导出的理论形式为：\n$$\nC_{\\mathrm{int}}(t) = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} + \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} \\exp \\left( -(k_{\\mathrm{form}} + k_{\\mathrm{break}})t \\right)\n$$\n问题提供的经验拟合为：\n$$\nC_{\\mathrm{int}}(t) = 0.57 + 0.43 \\exp\\left(-\\frac{t}{0.83\\ \\mathrm{ps}}\\right)\n$$\n通过比较理论表达式和经验拟合，我们可以令相应项相等。\n常数偏移项对应于平衡概率 $P_{F,\\text{eq}}$：\n$$\nP_{F,\\text{eq}} = \\frac{k_{\\mathrm{form}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} = 0.57\n$$\n指数前因子对应于平衡概率 $P_{U,\\text{eq}}$：\n$$\nP_{U,\\text{eq}} = \\frac{k_{\\mathrm{break}}}{k_{\\mathrm{form}} + k_{\\mathrm{break}}} = 0.43\n$$\n注意到 $P_{F,\\text{eq}} + P_{U,\\text{eq}} = 0.57 + 0.43 = 1.00$，这是自洽的。\n\n弛豫速率 $k_{\\text{relax}}$ 在指数部分：\n$$\nk_{\\text{relax}} = k_{\\mathrm{form}} + k_{\\mathrm{break}} = \\frac{1}{0.83\\ \\mathrm{ps}}\n$$\n我们现在有了一个方程组来求解 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$。\n从 $P_{U,\\text{eq}}$ 的方程中，我们可以写出：\n$$\nk_{\\mathrm{break}} = P_{U,\\text{eq}} \\cdot (k_{\\mathrm{form}} + k_{\\mathrm{break}})\n$$\n代入我们已确定的值：\n$$\nk_{\\mathrm{break}} = (0.43) \\cdot \\left( \\frac{1}{0.83\\ \\mathrm{ps}} \\right) = \\frac{0.43}{0.83}\\ \\mathrm{ps}^{-1}\n$$\n类似地，从 $P_{F,\\text{eq}}$ 的方程中：\n$$\nk_{\\mathrm{form}} = P_{F,\\text{eq}} \\cdot (k_{\\mathrm{form}} + k_{\\mathrm{break}})\n$$\n代入已确定的值：\n$$\nk_{\\mathrm{form}} = (0.57) \\cdot \\left( \\frac{1}{0.83\\ \\mathrm{ps}} \\right) = \\frac{0.57}{0.83}\\ \\mathrm{ps}^{-1}\n$$\n\n### 数值计算\n\n现在我们计算数值并按要求将其四舍五入到四位有效数字。\n$$\nk_{\\mathrm{break}} = \\frac{0.43}{0.83} \\ \\mathrm{ps}^{-1} \\approx 0.518072289... \\ \\mathrm{ps}^{-1}\n$$\n四舍五入到四位有效数字得到：\n$$\nk_{\\mathrm{break}} \\approx 0.5181 \\ \\mathrm{ps}^{-1}\n$$\n$$\nk_{\\mathrm{form}} = \\frac{0.57}{0.83} \\ \\mathrm{ps}^{-1} \\approx 0.686746988... \\ \\mathrm{ps}^{-1}\n$$\n四舍五入到四位有效数字得到：\n$$\nk_{\\mathrm{form}} \\approx 0.6867 \\ \\mathrm{ps}^{-1}\n$$\n最终答案应该是一个行矩阵，按顺序包含 $k_{\\mathrm{break}}$ 和 $k_{\\mathrm{form}}$。",
            "answer": "$$\n\\boxed{\\begin{pmatrix} 0.5181  0.6867 \\end{pmatrix}}\n$$"
        }
    ]
}