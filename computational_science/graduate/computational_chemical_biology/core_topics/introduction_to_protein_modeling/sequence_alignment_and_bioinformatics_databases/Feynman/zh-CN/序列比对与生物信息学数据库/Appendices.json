{
    "hands_on_practices": [
        {
            "introduction": "序列比对是生物信息学的核心任务之一，旨在识别序列间的相似区域，这些区域往往暗示着功能、结构或演化上的关联。此练习将引导您手动执行Smith-Waterman算法，这是一个用于局部序列比对的经典动态规划方法。通过计算一个具体的例子，您将深入理解得分矩阵的构建，并体会其“零重置”特性在从充满噪音的序列数据中发现有意义的局部匹配的关键作用。",
            "id": "3863057",
            "problem": "在计算化学生物学中，局部序列比对是生物信息学数据库（如美国国家生物技术信息中心(NCBI)和通用蛋白质资源库(UniProt)）中搜索和检索任务的基础。局部比对基于生物学信息的评分方案，识别出两个生物聚合物之间得分最高的子序列，其动态规划实现使用零重置来防止低分区域拉低其他有意义的局部匹配的得分。\n\n考虑两个编码为核苷酸的短脱氧核糖核酸(DNA)序列：\n$$\nX = (\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{G}, \\mathrm{T}),\n\\quad\nY = (\\mathrm{G}, \\mathrm{A}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{C}, \\mathrm{T}).\n$$\n使用基于核苷酸化学类别的生物学驱动的评分函数：腺嘌呤和鸟嘌呤是嘌呤，胞嘧啶和胸腺嘧啶是嘧啶。为任意 $\\alpha,\\beta \\in \\{\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}\\}$ 定义替换分数 $s(\\alpha,\\beta)$ 如下：\n- 相同核苷酸：$s(\\alpha,\\alpha) = +3$，\n- 转换 (嘌呤 $\\leftrightarrow$ 嘌呤, $\\mathrm{A} \\leftrightarrow \\mathrm{G}$; 嘧啶 $\\leftrightarrow$ 嘧啶, $\\mathrm{C} \\leftrightarrow \\mathrm{T}$)：对于 $\\alpha \\neq \\beta$，$s(\\alpha,\\beta) = -1$，\n- 颠换 (嘌呤 $\\leftrightarrow$ 嘧啶, 所有其他错配)：$s(\\alpha,\\beta) = -3$，\n并对插入或删除使用线性空位罚分 $d = -2$。\n\n应用局部比对、动态规划和零重置的原理，计算 $X$ 和 $Y$ 之间高分局部比对的一个具体示例，并解释零重置在计算中发生的位置和原因，以实现对那些否则会被低分侧翼区域所掩盖的高分子序列的检测。报告在此评分方案下的最大局部比对分数作为您的最终答案。无需四舍五-入。最终答案以无单位实数表示。",
            "solution": "该问题要求使用 Smith-Waterman 动态规划算法计算两个脱氧核糖核酸(DNA)序列 $X$ 和 $Y$ 之间的最大局部比对分数。该算法是生物信息学中寻找序列间相似性区域的基础。\n\n首先，我们确定给定的参数。两个序列是：\n$$\nX = (\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{G}, \\mathrm{T}) \\quad \\text{of length } m=7\n$$\n$$\nY = (\\mathrm{G}, \\mathrm{A}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A}, \\mathrm{C}, \\mathrm{T}) \\quad \\text{of length } n=7\n$$\n评分方案基于核苷酸的化学类别。腺嘌呤(A)和鸟嘌呤(G)是嘌呤。胞嘧啶(C)和胸腺嘧啶(T)是嘧啶。替换分数 $s(\\alpha, \\beta)$ 定义如下：\n- 相同核苷酸：$s(\\alpha, \\alpha) = +3$。\n- 转换 (嘌呤 $\\leftrightarrow$ 嘌呤, 嘧啶 $\\leftrightarrow$ 嘧啶)：对于 $\\alpha \\neq \\beta$，$s(\\alpha, \\beta) = -1$。\n- 颠换 (嘌呤 $\\leftrightarrow$ 嘧啶)：$s(\\alpha, \\beta) = -3$。\n线性空位罚分为 $d = -2$。\n\n基于这些规则，我们可以构建替换评分矩阵，我们将其表示为 $S$：\n$$\nS =\n\\bordermatrix{ & \\mathrm{A} & \\mathrm{C} & \\mathrm{G} & \\mathrm{T} \\cr\n\\mathrm{A} & +3 & -3 & -1 & -3 \\cr\n\\mathrm{C} & -3 & +3 & -3 & -1 \\cr\n\\mathrm{G} & -1 & -3 & +3 & -3 \\cr\n\\mathrm{T} & -3 & -1 & -3 & +3 \\cr\n}\n$$\n\nSmith-Waterman 算法使用一个大小为 $(n+1) \\times (m+1)$（在本例中为 $8 \\times 8$）的动态规划矩阵，我们称之为 $H$。矩阵项 $H_{i,j}$ 存储了结束于序列 $Y$ 的第 $i$ 个位置和序列 $X$ 的第 $j$ 个位置的任何比对的最大分数。该矩阵初始化为 $H_{i,0} = 0$ (对于 $i \\in [0, n]$) 和 $H_{0,j} = 0$ (对于 $j \\in [0, m]$)。\n\n对于 $i > 0$ 和 $j > 0$，每个单元格 $H_{i,j}$ 使用以下包含关键零重置的递推关系计算：\n$$\nH_{i,j} = \\max\n\\begin{cases}\n    0  \\text{(开始新的比对)} \\\\\n    H_{i-1, j-1} + s(Y_i, X_j)  \\text{(匹配/错配)} \\\\\n    H_{i-1, j} + d  \\text{(在Y中删除, X中出现空位)} \\\\\n    H_{i, j-1} + d  \\text{(在X中删除, Y中出现空位)}\n\\end{cases}\n$$\n其中 $X_j$ 是 $X$ 的第 $j$ 个核苷酸，$Y_i$ 是 $Y$ 的第 $i$ 个核苷酸。\n\n现在我们填充矩阵 $H$。列对应序列 $X$，行对应序列 $Y$。\n$$\nH =\n\\bordermatrix{\n& \\emptyset & \\mathrm{A}_{1} & \\mathrm{C}_{2} & \\mathrm{G}_{3} & \\mathrm{T}_{4} & \\mathrm{A}_{5} & \\mathrm{G}_{6} & \\mathrm{T}_{7} \\cr\n\\emptyset & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\cr\n\\mathrm{G}_{1} & 0 & 0 & 0 & 3 & 1 & 0 & 3 & 1 \\cr\n\\mathrm{A}_{2} & 0 & 3 & 1 & 1 & 0 & 4 & 2 & 0 \\cr\n\\mathrm{G}_{3} & 0 & 1 & 0 & 4 & 2 & 2 & 7 & 5 \\cr\n\\mathrm{T}_{4} & 0 & 0 & 0 & 2 & 7 & 5 & 5 & 10 \\cr\n\\mathrm{A}_{5} & 0 & 3 & 1 & 0 & 5 & 10 & 8 & 8 \\cr\n\\mathrm{C}_{6} & 0 & 1 & 6 & 4 & 3 & 8 & 7 & 7 \\cr\n\\mathrm{T}_{7} & 0 & 0 & 4 & 3 & 7 & 6 & 5 & 10 \\cr\n}\n$$\n矩阵 $H$ 中的最大分数即为最大局部比对分数。检查矩阵，我们发现最大值为 $10$。这个分数出现在三个位置：$H_{4,7}$、$H_{5,5}$ 和 $H_{7,7}$。这表明至少存在三个不同的局部比对达到了这个最大分数。\n\n问题要求一个高分局部比对的具体示例。我们可以通过从一个最高分单元格（例如 $H_{5,5} = 10$）进行回溯来找到一个。\n1.  从 $H_{5,5} = 10$ 开始。这个分数是从 $H_{4,4} + s(Y_5, X_5) = H_{4,4} + s(\\mathrm{A}, \\mathrm{A}) = 7 + 3 = 10$ 得到的。这对应于一个对角线移动，将 $Y_5=\\mathrm{A}$ 与 $X_5=\\mathrm{A}$ 进行比对。我们移动到 $H_{4,4}$。\n2.  从 $H_{4,4} = 7$ 开始。这个分数来自 $H_{3,3} + s(Y_4, X_4) = H_{3,3} + s(\\mathrm{T}, \\mathrm{T}) = 4 + 3 = 7$。这是一个对角线移动，将 $Y_4=\\mathrm{T}$ 与 $X_4=\\mathrm{T}$ 进行比对。我们移动到 $H_{3,3}$。\n3.  从 $H_{3,3} = 4$ 开始。这个分数来自 $H_{2,2} + s(Y_3, X_3) = H_{2,2} + s(\\mathrm{G}, \\mathrm{G}) = 1 + 3 = 4$。这是一个对角线移动，将 $Y_3=\\mathrm{G}$ 与 $X_3=\\mathrm{G}$ 进行比对。我们移动到 $H_{2,2}$。\n4.  从 $H_{2,2} = 1$ 开始。这个分数来自 $H_{2,1} + d = 3 - 2 = 1$。这是一个向左的移动，对应于将 $X_2=\\mathrm{C}$ 与序列 $Y$ 中的一个空位进行比对。我们移动到 $H_{2,1}$。\n5.  从 $H_{2,1} = 3$ 开始。这个分数来自 $H_{1,0} + s(Y_2, X_1) = H_{1,0} + s(\\mathrm{A}, \\mathrm{A}) = 0 + 3 = 3$。这是一个对角线移动，将 $Y_2=\\mathrm{A}$ 与 $X_1=\\mathrm{A}$ 进行比对。我们移动到 $H_{1,0}$。\n6.  回溯在 $H_{1,0} = 0$ 处终止。\n\n从回溯中重构比对（按逆序）：\n$$\n\\begin{array}{cccccc}\n\\text{X:} & \\mathrm{A} & \\mathrm{C} & \\mathrm{G} & \\mathrm{T} & \\mathrm{A} \\\\\n\\text{Y:} & \\mathrm{A} & - & \\mathrm{G} & \\mathrm{T} & \\mathrm{A}\n\\end{array}\n$$\n该比对的分数为 $s(\\mathrm{A},\\mathrm{A}) + d + s(\\mathrm{G},\\mathrm{G}) + s(\\mathrm{T},\\mathrm{T}) + s(\\mathrm{A},\\mathrm{A}) = 3 + (-2) + 3 + 3 + 3 = 10$，这证实了我们的计算。该比对涉及子序列 $X[1..5] = (\\mathrm{A}, \\mathrm{C}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A})$ 和 $Y[2..5] = (\\mathrm{A}, \\mathrm{G}, \\mathrm{T}, \\mathrm{A})$。\n\n零重置是区分局部比对和全局比对的关键特征。每当扩展先前比对（从对角线、上方或左方）的分数全为负时，就会发生零重置。在这种情况下，算法会“忘记”低分的扩展，并从该点以分数为 $0$ 开始一个新的潜在局部比对。\n\n在单元格 $H_{1,1}$ 可以观察到一个零重置的例子。\n$$\nH_{1,1} = \\max \\begin{cases}\n    0 \\\\\n    H_{0,0} + s(Y_1, X_1) = 0 + s(\\mathrm{G}, \\mathrm{A}) = -1 \\\\\n    H_{0,1} + d = 0 - 2 = -2 \\\\\n    H_{1,0} + d = 0 - 2 = -2\n\\end{cases}\n= \\max\\{0, -1, -2, -2\\} = 0\n$$\n在这里，比对前缀 $X[1]=\\mathrm{A}$ 和 $Y[1]=\\mathrm{G}$ 会得到一个负分 ($s(\\mathrm{A},\\mathrm{G}) = -1$)，以空位开始也是如此 ($d=-2$)。因为所有扩展到此单元格的比对的可能性都会导致负的累积分数，所以算法将分数重置为 $0$。这种机制防止了初始的低分区域（如序列开头的 A/G 错配）惩罚并因此掩盖了可能出现在序列后部的高分局部比对，这正是我们找到的从 $X_1$ 和 $Y_2$ 开始的比对。\n\n最大局部比对分数是在矩阵 $H$ 中找到的最高值。\n$$\nS_{\\text{max}} = \\max_{i,j} H_{i,j} = 10\n$$",
            "answer": "$$\n\\boxed{10}\n$$"
        },
        {
            "introduction": "真实的生物序列比对常常需要处理比简单匹配更复杂的生物学现象，例如基因剪接。本练习模拟了将成熟的信使RNA（以cDNA形式）比对回其包含内含子的基因组位点的过程。您需要运用一个精细的计分方案，它能区分代表正常生物过程的“内含子跳跃”和导致严重后果的“移码突变”，从而深刻体会如何将生物学原理转化为算法模型。",
            "id": "3863059",
            "problem": "将一条源自成熟信使RNA的互补DNA (cDNA) 序列与其基因组位点进行比对，该位点在两个外显子之间包含一个内含子。该比对应该反映出cDNA缺少内含子，而基因组区域含有内含子，并且编码序列中的单核苷酸插入或删除会导致移码，而移码现象远比典型的剪接罕见。从分子生物学的中心法则（DNA转录为RNA，并以长度为 $3$ 的密码子进行翻译）和剪接比对的定义（cDNA与基因组DNA的外显子片段比对，而内含子片段作为单个事件被跳过）出发，并利用这些原则来论证一个生物学上合理的、对内含子和移码区别对待的评分方案。然后，根据指定的方案计算最佳剪接比对得分。\n\n基因组区域 $G$（外显子-内含子-外显子，按 $5'$ 到 $3'$ 方向书写）：\n- 外显子 $1$：ATGGAA\n- 内含子：GTACCAAG\n- 外显子 $2$：CTTTAA\n\n因此 $G = \\text{ATGGAA}\\,\\text{GTACCAAG}\\,\\text{CTTTAA}$。\n\ncDNA序列 $C$（外显子 $1$ 后接外显子 $2$，且外显子 $2$ 中有一次单核苷酸插入）：\n- $C = \\text{ATGGAACCTTTAA}$\n\n对 $C$ 与 $G$ 的剪接比对采用以下评分规则：\n- 外显子区域的碱基-碱基比对：匹配 $+2$，错配 $-1$。\n- 外显子区域内的空位（相对于编码序列的插入或删除）：\n  - 如果空位长度 $L$ 满足 $L \\equiv 0 \\pmod{3}$（尊重密码子），罚分为：空位开放 $-5$ 加上每个空位核苷酸的空位延伸 $-2$。\n  - 如果 $L \\not\\equiv 0 \\pmod{3}$（移码），罚分为：空位开放 $-9$ 加上每个空位核苷酸的空位延伸 $-2$。\n- 内含子跳过（将cDNA中的一个空位与 $G$ 中一个连续的内含子进行比对）：内含子开放 $-3$，每个内含子核苷酸的内含子延伸 $0$，并且当且仅当内含子是典型的“GT…AG”（以GT开始并以AG结束）时，有剪接位点奖励 $+3$；否则奖励为 $0$。\n\n基于密码子结构和剪接的普遍性，简要论证为什么内含子跳过的罚分应低于移码的罚分。然后，使用上述方案计算 $C$ 和 $G$ 之间的最佳剪接比对得分。仅报告最佳总比对得分，以无单位的精确整数形式表示。",
            "solution": "该问题是有效的，因为它在科学上基于分子生物学和生物信息学的原理，问题陈述清晰，目标明确，规则完整，没有矛盾或含糊之处。\n\n解决方案包括两部分：评分方案的论证和最佳比对得分的计算。\n\n**评分方案的论证**\n\n分子生物学的中心法则指出，遗传信息从DNA流向RNA，再到蛋白质。在真核生物中，这个过程涉及与本问题相关的几个关键步骤。\n$1$。**转录**：基因组DNA中的一个基因，由外显子（编码区）和内含子（非编码区）组成，被转录成一个前体信使RNA（pre-mRNA）分子，它是整个基因的拷贝，包括内含子。\n$2$。**剪接**：pre-mRNA经历一个关键的加工步骤，称为剪接，其中内含子被精确切除，外显子连接在一起形成成熟的信使RNA（mRNA）。这个过程是真核生物基因表达中一个基本且非常普遍的部分。最终的mRNA包含一个连续的编码序列。\n$3$。**翻译**：成熟的mRNA随后被翻译成蛋白质。核糖体以连续、不重叠的三个核苷酸为一组（称为密码子）来读取mRNA序列。每个密码子指定一个特定的氨基酸。因此，密码子的序列决定了最终蛋白质中的氨基酸序列，这反过来又决定了蛋白质的结构和功能。\n\n将互补DNA（cDNA）序列（它是成熟mRNA的DNA拷贝）与其对应的基因组DNA位点进行比对时，必须考虑到内含子。比对模型通过允许在基因组序列中“跳过”内含子区域来实现这一点。这个跳过不是一个突变，而是对生物剪接事件的表示。因为剪接是产生功能性蛋白质的一个常见且必要的过程，一个生物学上合理的评分方案应该对这个事件赋予相对较低的罚分。给定的方案中，内含子开放罚分为 $-3$，内含子延伸罚分为 $0$，这反映了这一点。对于典型的“GT...AG”剪接位点给予 $+3$ 的奖励进一步完善了这个模型，因为这些信号序列是高度保守的，有助于正确的剪接。\n\n相比之下，移码突变是编码序列中插入或删除的核苷酸数量不能被三整除。这种突变会改变所有下游密码子的三联体阅读框。例如，如果序列 `AUG|GAA|CUU|...` 在第一个密码子后插入一个单核苷酸 `C`，它就变成了 `AUG|CGA|ACU|U...`。这会改变随后的每一个密码子，导致氨基酸序列发生巨大变化，并且通常会导致提前出现终止密码子，产生一个被截短且无功能的蛋白质。移码突变是罕见的随机事件，并且几乎总是对生物体极为有害。因此，评分方案应该对它们施以重罚，以反映其低生物学概率和严重的功能影响。给定的方案通过为移码插入/删除（其中长度 $L \\not\\equiv 0 \\pmod 3$）分配一个高达 $-9$ 的空位开放罚分来正确实现这一点，这比尊重密码子的插入/删除（$L \\equiv 0 \\pmod 3$）或内含子跳过的罚分要严厉得多。\n\n总而言之，对内含子跳过和移码进行区别性罚分是合理的，因为前者代表了一个常见、必要的生物过程（剪接），而后者代表了一个罕见、灾难性的突变事件。\n\n**最佳剪接比对得分的计算**\n\n比对是在基因组序列 $G$ 和 cDNA 序列 $C$ 之间进行的。\n$G = \\text{ATGGAA}\\,\\text{GTACCAAG}\\,\\text{CTTTAA}$\n$C = \\text{ATGGAACCTTTAA}$\n\n剪接比对的结构假设 $C$ 的外显子部分与 $G$ 的外显子部分比对，而 $G$ 中的内含子被跳过。我们计算遵循此外显子-内含子-外显子结构的最佳比对的得分。\n\n$1$。**外显子 1 的比对：**\n$C$ 的第一部分是 `ATGGAA`，而 $G$ 的外显子 $1$ 也是 `ATGGAA`。它们是相同的。\n比对是 $6$ 个核苷酸的完美匹配。\n`G: A T G G A A`\n`C: A T G G A A`\n这部分的得分：$6 \\text{ 次匹配} \\times (\\text{每次匹配 } +2) = +12$。\n\n$2$。**内含子跳过：**\n$G$ 中的内含子是 `GTACCAAG`。其长度为 $8$ 个核苷酸。cDNA源自成熟的mRNA，不包含此序列。因此，比对必须“跳过” $G$ 中的这个区域。\n内含子跳过的评分规则是：内含子开放罚分 $-3$，加上每个核苷酸的内含子延伸罚分 $0$。\n基础罚分 = $-3 + (8 \\times 0) = -3$。\n题目规定如果内含子是典型的，即以 `GT` 开始并以 `AG` 结束，则有 $+3$ 的奖励。内含子 `GTACCAAG` 满足这个条件。\n奖励 = $+3$。\n内含子跳过的总分 = (基础罚分) + (奖励) = $-3 + 3 = 0$。\n\n$3$。**外显子 2 的比对：**\n$C$ 的第二部分是 `CCTTTAA`，而 $G$ 的外显子 $2$ 是 `CTTTAA`。我们需要找到这两条序列之间的最佳比对。题目指出 $C$ 在外显子 $2$ 中包含一个单核苷酸插入，这与序列是一致的。因此，比对必须在基因组序列片段中包含一个长度为 $1$ 的空位。\n最佳比对是：\n`C: C C T T T A A`\n`G: - C T T T A A`\n这个比对包含一个空位和 $6$ 次匹配。我们来计算它的得分。\n- **空位得分**：空位长度为 $L=1$。因为 $1 \\not\\equiv 0 \\pmod 3$，这是一个移码插入/删除。\n罚分为：空位开放 $-9$ 加上每个核苷酸的空位延伸 $-2$。\n空位罚分 = $-9 + (-2 \\times 1) = -11$。\n- **匹配得分**：有 $6$ 次匹配（`C`-`C`, `T`-`T`, `T`-`T`, `T`-`T`, `A`-`A`, `A`-`A`）。\n匹配得分 = $6 \\times (+2) = +12$。\n外显子 $2$ 比对的总分 = (空位罚分) + (匹配得分) = $-11 + 12 = +1$。\n\n**最佳总比对得分：**\n总分是三部分得分的总和。\n总分 = (外显子 $1$ 得分) + (内含子跳过得分) + (外显子 $2$ 得分)\n总分 = $12 + 0 + 1 = 13$。",
            "answer": "$$\\boxed{13}$$"
        },
        {
            "introduction": "随着测序技术的发展，如何在海量数据库中快速执行序列搜索成为一项关键挑战。本练习将带您深入现代比对工具（如BWA和Bowtie）的“引擎室”，探索基于FM索引的高效近似匹配算法。通过实现一个带有分支定界剪枝策略的回溯搜索算法，您将掌握处理下一代测序数据所需的高性能计算核心思想。",
            "id": "3863004",
            "problem": "您需要使用 Ferragina–Manzini (FM) 索引在类 DNA 字符串上实现近似子串搜索。FM 索引是一种压缩全文索引，广泛用于生物信息学数据库（如经过整理的基因组存储库）中的大规模序列比对。目标是根据参考字符串搜索查询字符串，允许最多 $k$ 个错配（仅限汉明距离；无插入或删除），并通过累积比对分数阈值指导的分支定界剪枝进行优化。\n\n基础和约束条件：\n- 考虑一个有限字母表 $\\Sigma$ 和一个特殊的终止哨兵字符 `\"$\"`，该字符在字典序上小于 $\\Sigma$ 中的任何符号。参考字符串被增强为 $S = R \\Vert \"\\$\"$，其中 $R$ 是原始参考字符串，$\\Vert$ 表示串联。\n- 使用后缀数组和 Burrows–Wheeler 变换作为基础来构建 Ferragina–Manzini (FM) 索引。FM 索引支持后向搜索，即通过将当前后缀区间映射到给定前置字符后的下一个区间，而无需显式存储所有子串的集合。\n- 定义一个按位置的比对计分函数，使得匹配贡献 $m$，错配贡献 $-p$，其中 $m > 0$ 且 $p > 0$。查询的累积分数必须达到或超过阈值 $\\tau$ 才会被报告。\n- 通过分支定界实现剪枝，逻辑如下：假设搜索已消耗查询字符串（长度为 $L$）中的 $d$ 个符号，当前累积分数为 $s$。即使剩余的 $L - d$ 个符号全部匹配，可实现的最大最终分数为 $s + (L - d) \\cdot m$。如果 $s + (L - d) \\cdot m  \\tau$，则剪除该分支（不沿该路径继续搜索）。如果已使用的错配数超过 $k$，或者 FM 索引的后向步骤产生空区间，也进行剪枝。\n- 仅报告原始参考字符串 $R$ 中的 0-基起始位置，而不是增强字符串 $S$ 中的位置。会超出 $R$ 末尾的位置是无效的，应被排除。\n- 所有搜索都仅考虑错配（汉明距离）；不考虑插入或删除。\n\n程序要求：\n- 构建增强参考字符串 $S$ 的 FM 索引，并用它实现一个从右到左对查询字符串进行深度优先回溯搜索。在每个深度，对 $\\Sigma \\setminus \\{\"\\$\"\\}$ 中的所有字符进行分支，相应地计算错配并更新累积分数，并使用 FM 索引通过后向搜索更新后缀区间。\n- 根据上述累积分数阈值 $\\tau$ 以及错配预算 $k$ 和空区间剪枝，使用分支定界剪枝。\n- 对于每个测试用例，返回一个排序后的、不重复的、0-基的起始位置列表，这些位置是查询在 $R$ 中能够以最多 $k$ 个错配且累积分数至少为 $\\tau$ 进行比对的位置。\n\n测试套件：\n实现您的程序以处理以下固定的测试用例，每个用例指定为一个元组 $(R, Q, k, m, p, \\tau)$，其中 $R$ 是基于 $\\{A, C, G, T\\}$ 的参考字符串， $Q$ 是基于相同字母表的查询字符串， $k$ 是错配预算， $m$ 是匹配奖励， $p$ 是错配惩罚， $\\tau$ 是累积分数阈值。对于此问题，角度和物理单位不适用。所有数值答案必须表示为整数或浮点数。\n\n使用以下测试用例：\n1. $(R, Q, k, m, p, \\tau) = (\\text{\"ACGTCGACGTTACG\"}, \\text{\"CGACG\"}, 1, 1.0, 1.0, 4.0)$\n2. $(R, Q, k, m, p, \\tau) = (\\text{\"ACGACGACG\"}, \\text{\"ACG\"}, 0, 1.0, 1.0, 3.0)$\n3. $(R, Q, k, m, p, \\tau) = (\\text{\"ACGTACGT\"}, \\text{\"ACGT\"}, 2, 1.0, 1.0, 5.0)$\n4. $(R, Q, k, m, p, \\tau) = (\\text{\"GGGGACGTAC\"}, \\text{\"ACGT\"}, 2, 1.0, 2.0, 3.0)$\n5. $(R, Q, k, m, p, \\tau) = (\\text{\"AAAAAA\"}, \\text{\"AAA\"}, 10, 1.0, 1.0, 2.5)$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的、无空格的、逗号分隔的结果列表，其中每个元素对应一个测试用例，并且本身也是一个用方括号括起来的、逗号分隔的 0-基整数位置列表。例如，一个有效的输出看起来像 `[[x_1,x_2],[y_1],[],[z_1,z_2],[w_1,w_2,w_3]]`。\n\n每个测试用例的输出值必须是整数列表。程序必须完全自包含，不需要输入，并且不得访问外部文件或网络。",
            "solution": "该问题要求实现一个在 DNA 序列上的近似子串搜索算法。搜索必须识别查询字符串 $Q$ 在参考字符串 $R$ 中的出现，这些出现需满足两个条件：汉明距离最多为 $k$，且累积比对分数至少为 $\\tau$。该搜索需要使用 Ferragina–Manzini (FM) 索引（一种压缩全文数据结构）并结合分支定界剪枝策略来实现。\n\n解决方案的开发分为三个主要阶段：\n1.  为参考字符串构建 FM 索引。\n2.  实现一个使用 FM 索引的递归、深度优先回溯搜索算法。\n3.  集成一个基于错配计数和分数阈值的的分支定界剪枝机制。\n\n### 1. FM 索引构建\n\nFM 索引是基于 Burrows-Wheeler 变换（BWT）及相关数据结构构建的。构建过程从参考字符串 $R$ 开始。\n\n**字符串增强**：首先，用一个特殊的哨兵字符 `\"$\"` 来增强参考字符串 $R$，该字符在字典序上小于字母表 $\\Sigma = \\{A, C, G, T\\}$ 中的任何其他字符。增强后的字符串为 $S = R \\Vert \"\\$\"$，其中 $\\Vert$ 表示串联。令 $n = |S|$。\n\n**后缀数组 ($SA$)**：后缀数组 $SA$ 是一个长度为 $n$ 的整数数组。它存储了 $S$ 的所有后缀在按字典序排序后的起始位置。也就是说，后缀 $S[SA[0]..]$ 是字典序最小的后缀，$S[SA[1]..]$ 是第二小的，以此类推。\n\n**Burrows-Wheeler 变换 ($L$)**：$S$ 的 BWT 是一个长度为 $n$ 的字符串 $L$。对于每个 $i \\in [0, n-1]$，字符 $L[i]$ 是在原始字符串 $S$ 中位于以 $SA[i]$ 开头的后缀之前的那个字符。具体来说，$L[i] = S[SA[i] - 1]$。如果 $SA[i] = 0$，则前一个字符被视为 $S$ 的最后一个字符，即哨兵 `\"$\"`（即 $L[i] = S[n-1]$）。字符串 $L$ 有一个关键属性：给定字符 $c \\in \\Sigma \\cup \\{\"\\$\"\\}$ 的所有出现在 $L$ 中保持其在原始字符串 $S$ 中的相对顺序。这被称为后-前（Last-to-First, LF）映射属性。\n\n**辅助数据结构（`C` 和 `Occ`）**：为了实现高效搜索，还需要两个结构：\n-   **$C$ 表**：$C$ 表是一个数组或映射，对于每个字符 $c \\in \\Sigma \\cup \\{\"\\$\"\\}$，它存储了 $S$ 中字典序小于 $c$ 的字符的总数。\n-   **出现次数表 ($Occ$)**：$Occ(c, i)$ 函数返回字符 $c$ 在 BWT 字符串前缀 $L[0..i-1]$ 中出现的次数。这可以预先计算并存储在一个二维数组中以实现 $O(1)$ 的查找时间，其中一个维度对应字符，另一个维度对应 $L$ 中的位置。\n\n$L$、$C$ 和 $Occ$ 的组合构成了 FM 索引的核心。它支持一个非常高效的 `backward_search` 操作。给定一个字符 $c$ 和一个对应所有以前缀 $\\alpha$ 开始的后缀的后缀数组区间 $[sp, ep)$，此操作可以找到对应所有以前缀 $c\\alpha$ 开始的后缀的新区间。新的区间 $[sp', ep')$ 的计算方法如下：\n$sp' = C[c] + Occ(c, sp)$\n$ep' = C[c] + Occ(c, ep)$\n\n### 2. 回溯搜索算法\n\n近似匹配的搜索是通过一个递归的、深度优先的回溯算法来执行的。搜索过程是反向的，从查询字符串 $Q$ 的最后一个字符到第一个字符。\n\n递归的状态由元组 $(q_{idx}, sp, ep, \\text{mismatches}, s)$ 定义，其中：\n-   $q_{idx}$：当前正在处理的查询 $Q$ 中的索引（从 $|Q|-1$ 到 $0$）。\n-   $[sp, ep)$：FM 索引中当前的后缀数组区间。\n-   $\\text{mismatches}$：到目前为止累积的错配数。\n-   $s$：累积的比对分数。\n\n**递归步骤**：在查询的每个索引 $q_{idx}$ 处，算法进行分支，探索所有可能与查询字符 $Q[q_{idx}]$ 对齐的字符 $c \\in \\Sigma \\setminus \\{\"\\$\"\\}$。对于每个选择的 $c$：\n1.  更新错配计数和分数。如果 $c = Q[q_{idx}]$，则为匹配（分数增加 $m$）；否则为错配（分数减少 $p$，错配计数加一）。\n2.  算法检查新的错配计数是否超过预算 $k$。如果是，则剪除此路径。\n3.  使用 FM 索引的 `backward_search` 操作，根据字符 $c$ 计算下一个后缀数组区间 $[sp', ep')$。\n4.  如果新区间为空（$sp' \\ge ep'$），则剪除此路径。\n5.  如果没有被剪枝，算法以新状态 $(q_{idx}-1, sp', ep', \\text{new\\_mismatches}, \\text{new\\_score})$ 进行递归。\n\n**基本情况**：当 $q_{idx}  0$ 时，递归终止，表示整个查询字符串已处理完毕。此时，最终的后缀数组区间 $[sp, ep)$ 包含指向沿此路径找到的所有比对起始位置的指针。对于每个 $i \\in [sp, ep)$，位置 $pos = SA[i]$ 是一个有效的匹配，只要它不会导致比对超出原始参考字符串 $R$ 的范围（即 $pos + |Q| \\le |R|$）。所有这些有效位置都会被收集起来。\n\n### 3. 分支定界剪枝\n\n为了使搜索可行，采用分支定界策略来尽早剪除没有成果的搜索路径。除了基于错配限制 $k$ 和空后缀数组区间的剪枝外，还应用了一个强大的基于分数的剪枝规则。\n\n设查询长度为 $L = |Q|$。假设搜索已经从右到左处理了 $d$ 个字符，当前位于查询索引 $q_{idx} = L - 1 - d$。剩余待处理的字符数量为 $q_{idx} + 1$。如果当前累积分数为 $s$，那么最大可能的最终分数 $s_{max}$ 是在所有剩余字符都是完美匹配的情况下达到的。\n$s_{max} = s + (q_{idx} + 1) \\cdot m$\n如果这个最大可能分数小于所需阈值 $\\tau$（即 $s_{max}  \\tau$），那么这条路径就不可能产生有效的比对。因此，整个分支被剪除。这个检查在每次递归调用开始时执行。\n\n这种结合了用于快速区间更新的 FM 索引和积极的分支定界剪枝的策略，使得算法能够高效地搜索满足汉明距离和计分约束的近似匹配。对于每个测试用例，最终的、唯一的、排序的、0-基的 $R$ 中起始位置集合构成了结果。",
            "answer": "```\n[[4],[0,3,6],[],[4],[0,1,2,3]]\n```"
        }
    ]
}