{
    "hands_on_practices": [
        {
            "introduction": "在分析大型生物分子之前，从最简单的离散系统——双质点系统——入手是很有启发性的。这个练习  要求你直接从第一性原理出发，推导双质点系统的回转半径 $R_g$。通过这个解析推导，你将具体理解质量分布和粒子间距离如何在数学上定义系统的有效尺寸，为理解更复杂的系统奠定基础。",
            "id": "3864903",
            "problem": "在大分子的计算结构分析中，围绕质心的质量加权回转半径是一个关键的尺寸描述符，它与小角X射线散射（SAXS）中的散射可观测量直接相关。考虑一个双结构域生物分子复合物的刚性粗粒化模型，该模型由两个质点 $m_1$ 和 $m_2$ 表示，它们在三维欧几里得空间中相隔一个固定的中心距 $d$。设总质量为 $M$，两个质点的位置向量分别为 $\\mathbf{r}_1$ 和 $\\mathbf{r}_2$，质心位置向量为 $\\mathbf{r}_{\\mathrm{cm}}$。\n\n你只能假设以下基本定义：\n- 质心由 $\\mathbf{r}_{\\mathrm{cm}} = \\left(m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2\\right)/M$ 给出，其中 $M = m_1 + m_2$。\n- 回转半径的平方定义为 $R_g^2 = \\left(1/M\\right) \\sum_{i=1}^{2} m_i \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2$。\n\n严格地从这些定义和几何考虑出发，推导 $R_g^2$ 作为 $m_1$、$m_2$ 和 $d$ 的函数的精确解析表达式。然后分析在 $m_1 \\gg m_2$ 的渐近极限情况，并结合质量不均匀性如何影响刚性二聚体的 $R_g^2$ 这一背景对其进行物理解释。\n\n答案规格：\n- 以 $m_1$、$m_2$ 和 $d$ 的形式，给出 $R_g^2$ 的单一、封闭形式的解析表达式作为最终结果。\n- 不要在最终表达式中代入数值或包含单位。\n- 无需四舍五入。",
            "solution": "该问题被认为是有效的，因为它科学地基于经典力学原理，提法恰当且信息充分，可得出唯一解，并且陈述客观。我们将进行严格的推导。\n\n目标是为一个由两个质点 $m_1$ 和 $m_2$（相隔固定距离 $d$）组成的系统，推导其回转半径的平方 $R_g^2$ 作为这三个参数的函数的表达式。我们严格地从所提供的定义开始。\n\n系统的总质量是 $M = m_1 + m_2$。\n质心向量定义为：\n$$\n\\mathbf{r}_{\\mathrm{cm}} = \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{M}\n$$\n回转半径的平方定义为：\n$$\nR_g^2 = \\frac{1}{M} \\sum_{i=1}^{2} m_i |\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\frac{1}{M} \\left( m_1 |\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|^2 + m_2 |\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}|^2 \\right)\n$$\n我们的策略是用分隔两个质点的向量 $\\mathbf{r}_1 - \\mathbf{r}_2$ 来表示从质心到每个质点的向量 $\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}$。\n\n首先，我们求从质心到质点 $m_1$ 的向量：\n$$\n\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} = \\mathbf{r}_1 - \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{m_1 + m_2}\n$$\n将各项通分，使用公分母 $M = m_1 + m_2$：\n$$\n\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}} = \\frac{(m_1 + m_2)\\mathbf{r}_1 - (m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2)}{m_1 + m_2} = \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_1 - m_1 \\mathbf{r}_1 - m_2 \\mathbf{r}_2}{M} = \\frac{m_2 (\\mathbf{r}_1 - \\mathbf{r}_2)}{M}\n$$\n类似地，对于从质心到质点 $m_2$ 的向量：\n$$\n\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} = \\mathbf{r}_2 - \\frac{m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2}{m_1 + m_2}\n$$\n$$\n\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}} = \\frac{(m_1 + m_2)\\mathbf{r}_2 - (m_1 \\mathbf{r}_1 + m_2 \\mathbf{r}_2)}{m_1 + m_2} = \\frac{m_1 \\mathbf{r}_2 + m_2 \\mathbf{r}_2 - m_1 \\mathbf{r}_1 - m_2 \\mathbf{r}_2}{M} = \\frac{m_1 (\\mathbf{r}_2 - \\mathbf{r}_1)}{M}\n$$\n现在我们计算这些向量的模的平方。质点间的距离已知为 $d$，所以 $|\\mathbf{r}_1 - \\mathbf{r}_2| = |\\mathbf{r}_2 - \\mathbf{r}_1| = d$。\n$$\n|\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\left| \\frac{m_2 (\\mathbf{r}_1 - \\mathbf{r}_2)}{M} \\right|^2 = \\left(\\frac{m_2}{M}\\right)^2 |\\mathbf{r}_1 - \\mathbf{r}_2|^2 = \\frac{m_2^2}{M^2} d^2\n$$\n$$\n|\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}|^2 = \\left| \\frac{m_1 (\\mathbf{r}_2 - \\mathbf{r}_1)}{M} \\right|^2 = \\left(\\frac{m_1}{M}\\right)^2 |\\mathbf{r}_2 - \\mathbf{r}_1|^2 = \\frac{m_1^2}{M^2} d^2\n$$\n将这些结果代回 $R_g^2$ 的定义中：\n$$\nR_g^2 = \\frac{1}{M} \\left( m_1 \\left[ \\frac{m_2^2}{M^2} d^2 \\right] + m_2 \\left[ \\frac{m_1^2}{M^2} d^2 \\right] \\right)\n$$\n我们可以提取公因式 $\\frac{d^2}{M^2}$：\n$$\nR_g^2 = \\frac{d^2}{M^3} \\left( m_1 m_2^2 + m_2 m_1^2 \\right)\n$$\n从括号内的项中提取 $m_1 m_2$ 得：\n$$\nR_g^2 = \\frac{d^2}{M^3} \\left( m_1 m_2 (m_2 + m_1) \\right)\n$$\n根据定义，$M = m_1 + m_2$。将此代入表达式中得到：\n$$\nR_g^2 = \\frac{m_1 m_2 (M)}{M^3} d^2 = \\frac{m_1 m_2}{M^2} d^2\n$$\n最后，将 $M$ 替换为 $m_1 + m_2$，我们得到了 $R_g^2$ 作为 $m_1$、$m_2$ 和 $d$ 的函数的目标表达式：\n$$\nR_g^2 = \\frac{m_1 m_2}{(m_1 + m_2)^2} d^2\n$$\n此表达式等价于 $R_g^2 = \\frac{\\mu}{M}d^2$，其中 $\\mu = \\frac{m_1 m_2}{m_1+m_2}$ 是该两体系统的折合质量。\n\n接下来，我们分析一个质量远大于另一个质量的渐近极限，即 $m_1 \\gg m_2$。在此极限下，总质量 $M = m_1 + m_2 \\approx m_1$。\n我们可以通过从分母中提取 $m_1$ 来重写 $R_g^2$ 的表达式：\n$$\nR_g^2 = \\frac{m_1 m_2}{(m_1(1 + m_2/m_1))^2} d^2 = \\frac{m_1 m_2}{m_1^2 (1 + m_2/m_1)^2} d^2 = \\frac{m_2}{m_1} \\frac{1}{(1 + m_2/m_1)^2} d^2\n$$\n由于 $m_1 \\gg m_2$，比率 $\\frac{m_2}{m_1} \\to 0$。因此，项 $(1 + m_2/m_1)^2 \\to (1+0)^2 = 1$。\n因此，$R_g^2$ 的表达式趋近于：\n$$\n\\lim_{m_2/m_1 \\to 0} R_g^2 = \\frac{m_2}{m_1} d^2\n$$\n此结果的物理解释如下。当 $m_1 \\gg m_2$ 时，系统的质心 $\\mathbf{r}_{\\mathrm{cm}}$ 非常靠近大质量质点 $\\mathbf{r}_1$ 的位置。在极限情况下，$\\mathbf{r}_{\\mathrm{cm}} \\to \\mathbf{r}_1$。回转半径是所有质点到质心距离的平方的质量加权平均值。\n在此极限下：\n- 大质量质点 $m_1$ 对 $R_g^2$ 的贡献变得可以忽略不计，因为它到质心的距离 $|\\mathbf{r}_1 - \\mathbf{r}_{\\mathrm{cm}}|$ 趋近于0。\n- 小质量质点 $m_2$ 的贡献占主导地位。它到质心的距离约等于总分离距离 $d$，即 $|\\mathbf{r}_2 - \\mathbf{r}_{\\mathrm{cm}}| \\approx |\\mathbf{r}_2 - \\mathbf{r}_1| = d$。\n$R_g^2$ 的定义近似变为：\n$$\nR_g^2 \\approx \\frac{1}{M} \\left( m_1 (0)^2 + m_2 (d)^2 \\right) = \\frac{m_2}{M} d^2\n$$\n由于 $M \\approx m_1$，这简化为 $R_g^2 \\approx \\frac{m_2}{m_1} d^2$，这证实了我们的解析极限。这表明，对于质量分布高度不均匀的系统，回转半径不是简单几何范围（如 $d$）的度量，而是被质量比强烈抑制。由 $R_g$ 测量的系统有效尺寸变得远小于其物理维度 $d$，因为大部分质量集中在质心处。",
            "answer": "$$\n\\boxed{\\frac{m_1 m_2}{\\left(m_1 + m_2\\right)^{2}} d^{2}}\n$$"
        },
        {
            "introduction": "真实的生物分子是由许多不同质量的原子组成的非均质系统，这在结构分析中引入了一个微妙但重要的选择：我们应该根据其质量分布（质心，COM）还是其原子几何构型（几何中心，COG）来定义分子的中心？本计算练习  要求你通过为几个模型系统计算和比较质量加权与几何定义的回转半径来探究这个问题，从而揭示质量的非均匀性如何影响这一基本结构描述符。",
            "id": "3864836",
            "problem": "一个三维的原子坐标集和相应的原子质量定义了一个生物分子的离散质量分布。在牛顿力学中，基于质量的质心（COM）位置是唯一的点 $\\mathbf R_{\\mathrm{com}}$，当位置相对于该点测量时，它使得一阶质量矩为零，并且由位置的质量加权平均值给出。相比之下，几何中心（COG）是位置的简单平均值 $\\mathbf R_{\\mathrm{geom}} = \\frac{1}{N}\\sum_{i=1}^{N} \\mathbf r_i$，它平等地对待所有原子，而不管其质量如何。回转半径（$R_g$）根据第一性原理定义为原子到选定参考中心的均方距离的平方根，具体使用质量加权平均或等权重平均取决于采用哪个中心。在一个含有重原子和氢的非均质生物分子中，选择基于质量的中心还是等权重的中心会改变计算出的 $R_g$。\n\n您的任务是实现一个程序，对于每个提供的测试用例，从第一性原理出发执行以下操作：\n- 从原子位置 $\\{\\mathbf r_i\\}$ 和质量 $\\{m_i\\}$ 计算基于质量的质心 $\\mathbf R_{\\mathrm{com}}$。\n- 从相同的位置 $\\{\\mathbf r_i\\}$ 计算几何中心 $\\mathbf R_{\\mathrm{geom}}$。\n- 使用到 $\\mathbf R_{\\mathrm{com}}$ 的距离平方的质量加权平均，计算相对于 $\\mathbf R_{\\mathrm{com}}$ 的质量加权回转半径 $R_g^{\\mathrm{mass}}$。\n- 使用到 $\\mathbf R_{\\mathrm{geom}}$ 的距离平方的等权重平均，计算相对于 $\\mathbf R_{\\mathrm{geom}}$ 的等权重回转半径 $R_g^{\\mathrm{geom}}$。\n- 通过计算两个量来量化使用 $\\mathbf R_{\\mathrm{geom}}$ 而非 $\\mathbf R_{\\mathrm{com}}$ 对 $R_g$ 的影响：以埃（Angstrom）为单位的绝对差 $\\Delta R_g = \\left| R_g^{\\mathrm{mass}} - R_g^{\\mathrm{geom}} \\right|$ 和以小数表示的比率 $\\rho = \\frac{R_g^{\\mathrm{mass}}}{R_g^{\\mathrm{geom}}}$。如果 $R_g^{\\mathrm{geom}} = 0$，则按惯例定义 $\\rho = 1.0$，以表示在零展布时的相等性。\n\n所有位置均以埃（Angstrom）为单位提供，所有质量均以统一原子质量单位（Dalton）提供。请将 $\\Delta R_g$ 以埃表示，$\\rho$ 以不带百分号的小数表示。所有输出均四舍五入到六位小数。\n\n测试套件：\n- 案例1（非均质、对称的类甲烷簇）：位置为一个位于原点的碳原子和四个指向键长为 $1.09\\,\\mathrm{\\AA}$ 的正四面体顶点的氢原子。具体来说，令 $s = \\frac{1.09}{\\sqrt{3}}$ 并使用以下位置\n$$\n\\left[\n[0,0,0],\n[s,s,s],\n[s,-s,-s],\n[-s,s,-s],\n[-s,-s,s]\n\\right].\n$$\n质量为\n$$\n\\left[12.011,\\,1.008,\\,1.008,\\,1.008,\\,1.008\\right].\n$$\n- 案例2（案例1几何结构上的均匀质量）：使用与案例1相同的位置，并将质量设置为\n$$\n\\left[1.0,\\,1.0,\\,1.0,\\,1.0,\\,1.0\\right].\n$$\n- 案例3（边界情况，单个原子）：一个位于原点的氧原子，其位置为\n$$\n\\left[[0,0,0]\\right]\n$$\n质量为\n$$\n\\left[15.999\\right].\n$$\n- 案例4（非均质、强不对称簇）：两个碳原子和五个氢原子位于原点附近，一个硫原子沿 $x$ 轴位移。位置为\n$$\n\\left[\n[0.0,0.0,0.0],\\,\n[1.54,0.0,0.0],\\,\n[1.09,0.0,0.0],\\,\n[-1.09,0.0,0.0],\\,\n[0.0,1.09,0.0],\\,\n[0.0,-1.09,0.0],\\,\n[0.0,0.0,1.09],\\,\n[10.0,0.0,0.0]\n\\right],\n$$\n质量为\n$$\n\\left[12.011,\\,12.011,\\,1.008,\\,1.008,\\,1.008,\\,1.008,\\,1.008,\\,32.06\\right].\n$$\n\n覆盖性设计：\n- 案例1是一个具有现实重-轻原子组成的非均质“理想路径”案例。\n- 案例2是一个均匀质量的边缘案例，其中中心的选择不应改变 $R_g$。\n- 案例3是一个零展布（$R_g = 0$）的边界案例。\n- 案例4是一个非均质的非对称案例，它夸大了中心选择效应。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的浮点数列表，并用方括号括起来。该列表必须按顺序平铺每个案例的结果对：$\\left[\\Delta R_g^{(1)},\\rho^{(1)},\\Delta R_g^{(2)},\\rho^{(2)},\\Delta R_g^{(3)},\\rho^{(3)},\\Delta R_g^{(4)},\\rho^{(4)}\\right]$，其中上标表示案例索引。例如，打印的行应具有以下形式\n$$\n[\\Delta R_g^{(1)},\\rho^{(1)},\\Delta R_g^{(2)},\\rho^{(2)},\\Delta R_g^{(3)},\\rho^{(3)},\\Delta R_g^{(4)},\\rho^{(4)}].\n$$\n所有的 $\\Delta R_g^{(k)}$ 必须以 $\\mathrm{\\AA}$ 为单位，所有的 $\\rho^{(k)}$ 必须是小数，每个都四舍五入到六位小数。",
            "solution": "该问题要求对一组离散的原子坐标，计算并比较回转半径 $R_g$ 的两种不同定义。区别源于参考中心的选择——是基于质量的质心 $\\mathbf R_{\\mathrm{com}}$，还是等权重的几何中心 $\\mathbf R_{\\mathrm{geom}}$。我们将首先从第一性原理出发对定义进行形式化，然后概述其计算算法。\n\n设系统由 $N$ 个原子组成，其中第 $i$ 个原子的质量为 $m_i$，位置向量为 $\\mathbf r_i \\in \\mathbb{R}^3$。\n\n系统的总质量 $M_{\\mathrm{tot}}$ 是各个原子质量的总和：\n$$\nM_{\\mathrm{tot}} = \\sum_{i=1}^{N} m_i\n$$\n\n质心 $\\mathbf R_{\\mathrm{com}}$ 是原子位置的质量加权平均值。它代表了系统的一阶质量矩相对于该点为零的唯一那个点。其计算公式为：\n$$\n\\mathbf R_{\\mathrm{com}} = \\frac{\\sum_{i=1}^{N} m_i \\mathbf r_i}{\\sum_{i=1}^{N} m_i} = \\frac{1}{M_{\\mathrm{tot}}} \\sum_{i=1}^{N} m_i \\mathbf r_i\n$$\n计算是针对每个笛卡尔分量 $(x, y, z)$ 独立进行的。\n\n几何中心 $\\mathbf R_{\\mathrm{geom}}$ 是原子位置的简单算术平均值，它平等对待每个原子，而不管其质量如何：\n$$\n\\mathbf R_{\\mathrm{geom}} = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbf r_i\n$$\n对于一个质量均匀的系统，即所有 $i$ 的 $m_i = m$，$\\mathbf R_{\\mathrm{com}}$ 和 $\\mathbf R_{\\mathrm{geom}}$ 是重合的。然而，对于一个非均质系统，这两个中心通常会不同。\n\n回转半径 $R_g$ 是衡量点集空间范围的度量。其定义取决于参考中心和平均方案的选择。\n\n质量加权回转半径 $R_g^{\\mathrm{mass}}$ 定义为原子到质心的均方根距离，其中平均是按质量加权的：\n$$\nR_g^{\\mathrm{mass}} = \\sqrt{ \\frac{\\sum_{i=1}^{N} m_i \\| \\mathbf r_i - \\mathbf R_{\\mathrm{com}} \\|^2}{\\sum_{i=1}^{N} m_i} }\n$$\n这里，$\\| \\mathbf v \\|^2$ 表示向量 $\\mathbf v$ 的欧几里得范数的平方。这个量度量了质量分布的有效半径。\n\n等权重回转半径 $R_g^{\\mathrm{geom}}$，也称为几何回转半径，定义为原子到几何中心的均方根距离，每个原子的权重相等：\n$$\nR_g^{\\mathrm{geom}} = \\sqrt{ \\frac{\\sum_{i=1}^{N} \\| \\mathbf r_i - \\mathbf R_{\\mathrm{geom}} \\|^2}{N} }\n$$\n这个量度量了原子几何排列的有效半径。\n\n问题要求使用两个度量来量化这两种测量值之间的差异：绝对差 $\\Delta R_g$ 和比率 $\\rho$。\n\n绝对差由下式给出：\n$$\n\\Delta R_g = \\left| R_g^{\\mathrm{mass}} - R_g^{\\mathrm{geom}} \\right|\n$$\n这提供了与 $R_g$ 相同单位（埃，$\\mathrm{\\AA}$）的差异的直接度量。\n\n比率由下式给出：\n$$\n\\rho = \\frac{R_g^{\\mathrm{mass}}}{R_g^{\\mathrm{geom}}}\n$$\n这提供了一个无量纲的比较。当 $R_g^{\\mathrm{geom}} = 0$ 时会出现一个特殊情况，这发生于单个原子或多个原子位于完全相同位置的系统。在这种物理上无关紧要的零空间范围情况下，$R_g^{\\mathrm{mass}}$ 也必须为 $0$，问题规定了惯例 $\\rho = 1.0$ 以表示等价。\n\n将为每个测试用例实现的算法将按以下步骤进行：\n1.  将原子位置表示为一个 $N \\times 3$ 的浮点数矩阵，将质量表示为一个 $N$ 元素的向量。\n2.  计算原子总数 $N$ 和总质量 $M_{\\mathrm{tot}}$。\n3.  通过沿原子轴取位置矩阵的平均值来计算几何中心向量 $\\mathbf R_{\\mathrm{geom}}$。\n4.  通过执行位置向量的质量加权求和并除以 $M_{\\mathrm{tot}}$ 来计算质心向量 $\\mathbf R_{\\mathrm{com}}$。\n5.  计算每个原子到 $\\mathbf R_{\\mathrm{geom}}$ 的距离的平方，并计算它们的平均值以找到 $(R_g^{\\mathrm{geom}})^2$。然后，取平方根以获得 $R_g^{\\mathrm{geom}}$。\n6.  计算每个原子到 $\\mathbf R_{\\mathrm{com}}$ 的距离的平方，将每个距离的平方乘以其对应的质量，对结果求和，然后除以 $M_{\\mathrm{tot}}$ 以找到 $(R_g^{\\mathrm{mass}})^2$。然后，取平方根以获得 $R_g^{\\mathrm{mass}}$。\n7.  使用它们的定义计算 $\\Delta R_g$ 和 $\\rho$，如果 $R_g^{\\mathrm{geom}}$ 为零，则对 $\\rho$ 应用惯例。\n8.  将 $\\Delta R_g$ 和 $\\rho$ 的最终值四舍五入到六位小数。\n此过程将应用于四个指定的测试用例中的每一个，以生成最终输出。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares mass-weighted and equal-weight radii of gyration\n    for several test cases as defined in the problem statement.\n    \"\"\"\n\n    def calculate_metrics(positions: np.ndarray, masses: np.ndarray):\n        \"\"\"\n        Calculates the requested metrics for a single set of atoms.\n\n        Args:\n            positions: A numpy array of shape (N, 3) with atomic coordinates.\n            masses: A numpy array of shape (N,) with atomic masses.\n\n        Returns:\n            A tuple (delta_Rg, rho) containing the absolute difference and ratio,\n            rounded to six decimal places.\n        \"\"\"\n        # Ensure masses are treated as a column vector for broadcasting\n        masses_col = masses[:, np.newaxis]\n\n        num_atoms = positions.shape[0]\n        total_mass = np.sum(masses)\n\n        # Center of Mass (mass-weighted)\n        com = np.sum(positions * masses_col, axis=0) / total_mass\n\n        # Center of Geometry (equal-weight)\n        geom = np.mean(positions, axis=0)\n\n        # Mass-weighted Radius of Gyration (relative to COM)\n        sq_dist_from_com = np.sum((positions - com)**2, axis=1)\n        rg_mass_sq = np.sum(masses * sq_dist_from_com) / total_mass\n        rg_mass = np.sqrt(rg_mass_sq)\n\n        # Equal-weight Radius of Gyration (relative to COG)\n        sq_dist_from_geom = np.sum((positions - geom)**2, axis=1)\n        rg_geom_sq = np.mean(sq_dist_from_geom)\n        rg_geom = np.sqrt(rg_geom_sq)\n        \n        # Calculate final metrics: delta_Rg and rho\n        delta_rg = abs(rg_mass - rg_geom)\n\n        if rg_geom == 0.0:\n            rho = 1.0  # Convention for zero spread\n        else:\n            rho = rg_mass / rg_geom\n\n        return round(delta_rg, 6), round(rho, 6)\n\n    # Test Case 1: Heterogeneous, symmetric cluster (methane-like)\n    s1 = 1.09 / np.sqrt(3)\n    positions1 = np.array([\n        [0.0, 0.0, 0.0],\n        [s1, s1, s1],\n        [s1, -s1, -s1],\n        [-s1, s1, -s1],\n        [-s1, -s1, s1]\n    ])\n    masses1 = np.array([12.011, 1.008, 1.008, 1.008, 1.008])\n\n    # Test Case 2: Uniform masses on Case 1 geometry\n    positions2 = positions1\n    masses2 = np.array([1.0, 1.0, 1.0, 1.0, 1.0])\n\n    # Test Case 3: Single atom boundary case\n    positions3 = np.array([[0.0, 0.0, 0.0]])\n    masses3 = np.array([15.999])\n\n    # Test Case 4: Heterogeneous, strongly asymmetric cluster\n    positions4 = np.array([\n        [0.0, 0.0, 0.0],\n        [1.54, 0.0, 0.0],\n        [1.09, 0.0, 0.0],\n        [-1.09, 0.0, 0.0],\n        [0.0, 1.09, 0.0],\n        [0.0, -1.09, 0.0],\n        [0.0, 0.0, 1.09],\n        [10.0, 0.0, 0.0]\n    ])\n    masses4 = np.array([12.011, 12.011, 1.008, 1.008, 1.008, 1.008, 1.008, 32.06])\n    \n    test_cases = [\n        (positions1, masses1),\n        (positions2, masses2),\n        (positions3, masses3),\n        (positions4, masses4),\n    ]\n\n    results = []\n    for pos, mass in test_cases:\n        delta_rg, rho = calculate_metrics(pos, mass)\n        results.append(delta_rg)\n        results.append(rho)\n\n    # Format the results into the required single-line string\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "生物分子是动态的实体，其结构特性随时间波动。为了捕捉分子的平均尺寸和形状，我们通常分析来自分子动力学（MD）模拟的轨迹。这个高级实践  将让你扮演计算生物学家的角色，处理原始的 MD 轨迹，你将需要实现一个算法来处理周期性边界条件并计算时间平均的质量加权回转半径，这是一个在分析模拟数据时的标准流程。",
            "id": "3864854",
            "problem": "给定一段简短的、合成的分子动力学（MD）轨迹（遵循周期性边界条件，PBC），请您设计并实现一个算法，用以计算时间平均的、质量加权的回转半径。该算法必须显式地处理跨帧的坐标“解缠绕”，以恢复原子轨迹的连续性。您的程序必须为每个轨迹按顺序计算以下内容：PBC下的坐标解缠绕、每帧的质量加权质心、每帧的质量加权回转半径，以及所有帧的回转半径的时间平均值。所有距离都必须以纳米为单位处理，最终结果必须以纳米为单位报告，并四舍五入到六位小数。输出必须为一行，包含所有测试用例的结果，格式为方括号内以逗号分隔的列表。\n\n您应使用的科学基础是：\n- 点粒子的质量和位置的定义。\n- 一组点质量的质心定义。\n- 三维空间中的欧几里得范数。\n- 周期性边界条件（PBC）的概念，它将沿各轴相差盒子长度整数倍的位置视为等效位置，以及最小镜像约定。\n- 坐标解缠绕的概念，它通过考虑连续帧之间的边界穿越来重建连续轨迹。\n\n您不得从任何回转半径的捷径公式开始或引用它；相反，应从上述基础推导算法，包括质量加权质心和位置围绕该中心的离散度。\n\n单位和表示要求：\n- 位置以纳米为单位。\n- 盒子是正交的，各轴长度以纳米为单位给出。\n- 答案必须以纳米表示，并四舍五入到六位小数。\n- 此问题不使用角度。\n\n您的算法任务是：\n1. 给定帧 $t$ 和原子 $i$ 的位置为 $r_{t,i}$ 的轨迹，以及盒子长度 $\\ell_x$、$\\ell_y$、$\\ell_z$，重建一个在时间上连续的解缠绕轨迹 $\\tilde{r}_{t,i}$。在连续帧之间使用最小镜像逻辑，以便连续帧之间的每轴位移是考虑 PBC 后的最近位移。时间 $t$ 的解缠绕坐标应通过将校正后的位移加到时间 $t-1$ 的解缠绕坐标上获得。\n2. 对于每一帧 $t$，根据解缠绕的位置和给定的原子质量计算质量加权质心。\n3. 对于每一帧 $t$，计算点围绕质心的质量加权离散度，作为标量距离度量。\n4. 计算轨迹所有帧上的标量距离的时间平均值。\n5. 为每个轨迹报告一个浮点数，单位为纳米，四舍五入到六位小数。\n\n用于检验实现的测试套件：\n- 测试用例 1（包含多个原子、非均匀质量和边界穿越的正常路径）：\n  - 原子数 $N$：$3$。\n  - 帧数 $T$：$4$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0,\\,1.0,\\,16.0\\,]$。\n  - 每帧的位置（纳米），每行为 $[x,y,z]$：\n    - 第 0 帧：$[\\,9.8,\\,9.9,\\,0.1\\,]$，$[\\,0.2,\\,0.1,\\,0.2\\,]$，$[\\,0.0,\\,9.9,\\,9.8\\,]$。\n    - 第 1 帧：$[\\,0.1,\\,0.0,\\,0.2\\,]$，$[\\,0.4,\\,0.3,\\,0.3\\,]$，$[\\,9.9,\\,0.1,\\,9.9\\,]$。\n    - 第 2 帧：$[\\,0.3,\\,0.2,\\,0.3\\,]$，$[\\,9.9,\\,0.2,\\,0.4\\,]$，$[\\,9.8,\\,0.2,\\,0.0\\,]$。\n    - 第 3 帧：$[\\,0.4,\\,0.4,\\,0.5\\,]$，$[\\,9.7,\\,9.9,\\,0.6\\,]$，$[\\,9.7,\\,0.3,\\,0.2\\,]$。\n- 测试用例 2（单个原子的边界情况；无论如何运动，每一帧的回转半径都应为零）：\n  - 原子数 $N$：$1$。\n  - 帧数 $T$：$5$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0\\,]$。\n  - 每帧的位置（纳米）：\n    - 第 0 帧：$[\\,5.0,\\,5.0,\\,5.0\\,]$。\n    - 第 1 帧：$[\\,9.9,\\,0.1,\\,0.0\\,]$。\n    - 第 2 帧：$[\\,0.2,\\,0.3,\\,0.4\\,]$。\n    - 第 3 帧：$[\\,0.1,\\,9.8,\\,9.7\\,]$。\n    - 第 4 帧：$[\\,9.9,\\,9.9,\\,9.9\\,]$。\n- 测试用例 3（两个等质量原子在穿越边界时保持恒定间距的边缘情况）：\n  - 原子数 $N$：$2$。\n  - 帧数 $T$：$4$。\n  - 盒子长度：$[\\ell_x,\\ell_y,\\ell_z] = [\\,10.0,\\,10.0,\\,10.0\\,]$。\n  - 原子质量（原子质量单位）：$[\\,12.0,\\,12.0\\,]$。\n  - 每帧的位置（纳米），以原子 1 和原子 2 的 $[x,y,z]$ 对的形式给出：\n    - 第 0 帧：$[\\,9.0,\\,0.0,\\,0.0\\,]$，$[\\,5.0,\\,0.0,\\,0.0\\,]$。\n    - 第 1 帧：$[\\,0.5,\\,0.0,\\,0.0\\,]$，$[\\,6.5,\\,0.0,\\,0.0\\,]$。\n    - 第 2 帧：$[\\,1.7,\\,0.0,\\,0.0\\,]$，$[\\,7.7,\\,0.0,\\,0.0\\,]$。\n    - 第 3 帧：$[\\,8.9,\\,0.0,\\,0.0\\,]$，$[\\,4.9,\\,0.0,\\,0.0\\,]$。\n\n您的程序应生成单行输出，其中包含方括号内以逗号分隔的结果列表（例如，$[\\,r_1,\\,r_2,\\,r_3\\,]$），其中 $r_k$ 是测试用例 $k$ 的时间平均、质量加权的回转半径，单位为纳米，并四舍五入到六位小数。",
            "solution": "该问题是有效的，因为它在科学上基于经典力学和统计物理学的原理，是适定的（提供了所有必要信息），并以客观、正式的语言表达。我们将从第一性原理出发，推导并实现所需的算法。\n\n计算时间平均的、质量加权的回转半径 $R_g$ 的算法需要四个连续步骤：(1) 解缠绕原子坐标以确保轨迹连续性，(2) 计算每帧的质量加权质心，(3) 计算每帧的质量加权回转半径，(4) 对每帧的 $R_g$ 值进行时间平均。\n\n假设系统由 $N$ 个原子组成，其质量为 $m_i$，$i \\in \\{1, \\dots, N\\}$。轨迹在 $T$ 个帧中给出，其中原子 $i$ 在帧 $t \\in \\{0, \\dots, T-1\\}$ 的缠绕位置向量为 $\\boldsymbol{r}_{t,i} \\in \\mathbb{R}^3$。模拟盒子是正交的，其维度向量为 $\\boldsymbol{\\ell} = (\\ell_x, \\ell_y, \\ell_z)$。\n\n**1. 坐标解缠绕**\n\n所提供的坐标 $\\boldsymbol{r}_{t,i}$ 受周期性边界条件 (PBC) 的约束。为了计算像回转半径这样的全局结构属性，我们必须首先在空间中重建一个连续的轨迹。我们将解缠绕的坐标表示为 $\\tilde{\\boldsymbol{r}}_{t,i}$。\n\n解缠绕过程是迭代的。对于初始帧 $t=0$，我们假设缠绕坐标和解缠绕坐标是相同的：\n$$\n\\tilde{\\boldsymbol{r}}_{0,i} = \\boldsymbol{r}_{0,i} \\quad \\forall i \\in \\{1, \\dots, N\\}\n$$\n对于每个后续帧 $t > 0$，一个原子的解缠绕位置由其在前一帧的解缠绕位置 $\\tilde{\\boldsymbol{r}}_{t-1,i}$ 以及在帧 $t-1$ 和 $t$ 之间发生的真实物理位移决定。该位移使用最小镜像约定计算。\n\n表观位移向量是 $\\Delta\\boldsymbol{r}_{t,i} = \\boldsymbol{r}_{t,i} - \\boldsymbol{r}_{t-1,i}$。由于 PBC，如果穿越了边界，该向量的一个分量（例如 $\\Delta x_{t,i}$）可能不代表最短路径。最小镜像位移 $\\Delta\\tilde{\\boldsymbol{r}}_{t,i}$ 通过校正表观位移的每个分量来找到。对于每个轴 $k \\in \\{x, y, z\\}$：\n$$\n\\Delta\\tilde{r}_{t,i,k} = \\Delta r_{t,i,k} - \\ell_k \\cdot \\text{round}\\left( \\frac{\\Delta r_{t,i,k}}{\\ell_k} \\right)\n$$\n其中 `round` 是一个将其参数四舍五入到最近整数的函数。此操作确保校正后的位移向量的每个分量都位于区间 $[-\\ell_k/2, \\ell_k/2]$ 内。\n\n然后，通过将此校正后的位移加到前一个解缠绕位置，来计算原子 $i$ 在帧 $t$ 的解缠绕坐标：\n$$\n\\tilde{\\boldsymbol{r}}_{t,i} = \\tilde{\\boldsymbol{r}}_{t-1,i} + \\Delta\\tilde{\\boldsymbol{r}}_{t,i}\n$$\n对所有原子以及从 $t=1$ 到 $T-1$ 的所有帧重复此过程。\n\n**2. 每帧的质量加权质心**\n\n对于每一帧 $t$，我们使用解缠绕坐标 $\\tilde{\\boldsymbol{r}}_{t,i}$ 计算质量加权质心 $\\tilde{\\boldsymbol{R}}_t$。系统的总质量为 $M = \\sum_{i=1}^{N} m_i$。质心定义为：\n$$\n\\tilde{\\boldsymbol{R}}_t = \\frac{\\sum_{i=1}^{N} m_i \\tilde{\\boldsymbol{r}}_{t,i}}{\\sum_{i=1}^{N} m_i} = \\frac{1}{M} \\sum_{i=1}^{N} m_i \\tilde{\\boldsymbol{r}}_{t,i}\n$$\n\n**3. 每帧的质量加权回转半径**\n\n帧 $t$ 的回转半径 $R_{g,t}$ 是衡量原子空间延展性的一个度量。它被定义为原子到其质心的质量加权均方根距离。回转半径的平方 $R_{g,t}^2$ 是每个原子到质心的欧几里得距离平方的质量加权平均值：\n$$\nR_{g,t}^2 = \\frac{\\sum_{i=1}^{N} m_i ||\\tilde{\\boldsymbol{r}}_{t,i} - \\tilde{\\boldsymbol{R}}_t||^2}{\\sum_{i=1}^{N} m_i} = \\frac{1}{M} \\sum_{i=1}^{N} m_i ||\\tilde{\\boldsymbol{r}}_{t,i} - \\tilde{\\boldsymbol{R}}_t||^2\n$$\n其中 $||\\cdot||$ 表示欧几里得范数。所要求的“标量距离度量”就是回转半径本身，其单位是长度：\n$$\nR_{g,t} = \\sqrt{R_{g,t}^2}\n$$\n\n**4. 时间平均回转半径**\n\n最后，时间平均回转半径 $\\langle R_g \\rangle$ 是轨迹所有 $T$ 帧上每帧 $R_{g,t}$ 值的算术平均值：\n$$\n\\langle R_g \\rangle = \\frac{1}{T} \\sum_{t=0}^{T-1} R_{g,t}\n$$\n根据问题规范，所得结果以纳米为单位报告，并四舍五入到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_average_rg(masses: np.ndarray, positions: np.ndarray, box_lengths: np.ndarray) -> float:\n    \"\"\"\n    Computes the time-averaged, mass-weighted radius of gyration for a trajectory.\n\n    The algorithm performs three main steps:\n    1. Unwraps the trajectory coordinates to handle periodic boundary conditions (PBC).\n    2. For each frame, calculates the mass-weighted center of mass (COM) and then the\n       mass-weighted radius of gyration (Rg).\n    3. Averages the per-frame Rg values over the entire trajectory.\n\n    Args:\n        masses: A 1D numpy array of shape (N,) containing atomic masses.\n        positions: A 3D numpy array of shape (T, N, 3) containing wrapped atomic\n                   positions for T frames and N atoms.\n        box_lengths: A 1D numpy array of shape (3,) with the box dimensions [Lx, Ly, Lz].\n\n    Returns:\n        The time-averaged radius of gyration as a float.\n    \"\"\"\n    num_frames, num_atoms, _ = positions.shape\n\n    # 1. Coordinate Unwrapping\n    unwrapped_pos = np.zeros_like(positions)\n    unwrapped_pos[0] = positions[0]\n\n    for t in range(1, num_frames):\n        delta = positions[t] - positions[t-1]\n        # Apply minimum image convention\n        correction = box_lengths * np.round(delta / box_lengths)\n        unwrapped_delta = delta - correction\n        unwrapped_pos[t] = unwrapped_pos[t-1] + unwrapped_delta\n    \n    # 2. Per-Frame Rg Calculation\n    rg_per_frame = []\n    total_mass = np.sum(masses)\n    \n    if total_mass == 0:\n        return 0.0\n\n    # Reshape masses for broadcasting: from (N,) to (N, 1)\n    masses_reshaped = masses[:, np.newaxis]\n\n    for t in range(num_frames):\n        frame_pos = unwrapped_pos[t]\n        \n        # Calculate mass-weighted center of mass for the frame\n        com = np.sum(frame_pos * masses_reshaped, axis=0) / total_mass\n        \n        # Calculate squared distances from COM\n        dist_sq = np.sum((frame_pos - com)**2, axis=1)\n        \n        # Calculate mass-weighted squared Rg\n        rg_sq = np.sum(masses * dist_sq) / total_mass\n        \n        # Rg is the square root\n        rg = np.sqrt(rg_sq)\n        rg_per_frame.append(rg)\n        \n    # 3. Time-Averaging\n    average_rg = np.mean(rg_per_frame)\n    \n    return average_rg\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the average radius of gyration for each.\n    The final output is a single-line string of comma-separated results\n    rounded to six decimal places, enclosed in square brackets.\n    \"\"\"\n    test_cases = [\n        {\n            \"masses\": np.array([12.0, 1.0, 16.0]),\n            \"positions\": np.array([\n                [[9.8, 9.9, 0.1], [0.2, 0.1, 0.2], [0.0, 9.9, 9.8]],\n                [[0.1, 0.0, 0.2], [0.4, 0.3, 0.3], [9.9, 0.1, 9.9]],\n                [[0.3, 0.2, 0.3], [9.9, 0.2, 0.4], [9.8, 0.2, 0.0]],\n                [[0.4, 0.4, 0.5], [9.7, 9.9, 0.6], [9.7, 0.3, 0.2]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        },\n        {\n            \"masses\": np.array([12.0]),\n            \"positions\": np.array([\n                [[5.0, 5.0, 5.0]],\n                [[9.9, 0.1, 0.0]],\n                [[0.2, 0.3, 0.4]],\n                [[0.1, 9.8, 9.7]],\n                [[9.9, 9.9, 9.9]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        },\n        {\n            \"masses\": np.array([12.0, 12.0]),\n            \"positions\": np.array([\n                [[9.0, 0.0, 0.0], [5.0, 0.0, 0.0]],\n                [[0.5, 0.0, 0.0], [6.5, 0.0, 0.0]],\n                [[1.7, 0.0, 0.0], [7.7, 0.0, 0.0]],\n                [[8.9, 0.0, 0.0], [4.9, 0.0, 0.0]],\n            ]),\n            \"box_lengths\": np.array([10.0, 10.0, 10.0])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_average_rg(case[\"masses\"], case[\"positions\"], case[\"box_lengths\"])\n        results.append(result)\n\n    # Format the results to exactly six decimal places and join them.\n    formatted_results = ','.join(f\"{r:.6f}\" for r in results)\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```"
        }
    ]
}