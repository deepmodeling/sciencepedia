{
    "hands_on_practices": [
        {
            "introduction": "在进行任何复杂的轨迹分析之前，我们必须确保能够准确地从原始坐标数据计算出基本指标。本练习将指导您从第一性原理出发，亲手实现均方根偏差（RMSD）和均方根涨落（RMSF）的计算，并建立验证流程来处理常见的单位不一致问题，这是确保分析可靠性的关键第一步。",
            "id": "3868680",
            "problem": "您正在分析分子动力学轨迹，以计算一个小型合成系统的均方根偏差（RMSD）和均方根涨落（RMSF）。您的任务是设计一个程序，量化纳米和埃之间单位不一致性对 RMSD 和 RMSF 的影响，并执行验证检查以检测此类不一致性。计算必须基于第一性原理：欧几里得几何以及对原子和帧的统计聚合。不要使用预封装的公式；而是使用向量运算和平均值直接根据定义实现所有计算。\n\n使用的基本原理：\n- 欧几里得向量空间：使用三维空间中的欧几里得范数通过坐标差计算距离。\n- 统计聚合：使用算术平均值计算原子和帧的平均值。\n- 物理单位转换：使用经过充分检验的事实 $1\\ \\mathrm{\\AA} = 0.1\\ \\mathrm{nm}$。\n\n在代码中实现的定义，不引用任何目标公式：\n- 均方根偏差（RMSD）：通过聚合原子上的欧几里得位移平方，然后取其均值的主平方根，来量化轨迹帧相对于参考帧的结构偏差。\n- 均方根涨落（RMSF）：通过聚合每个原子位置与其时间平均位置的偏差平方，然后取其跨帧均值的主平方根，来量化每个原子跨帧的涨落；对于测试用例，报告所有原子的平均 RMSF，作为一个标量值。\n\n要实现的验证检查：\n- 元数据一致性检查：验证所有帧的单位标签是否一致。\n- 量级连续性检查：计算每帧的典型坐标量级（例如，每个原子欧几里得范数的中位数），并检查连续帧之间的比率；大的比率可能表示单位不匹配。使用一个严格的启发式阈值：如果任何连续帧的比率超过 $3$ 或低于 $1/3$，则标记为不连续。\n\n单位和输出要求：\n- 所有距离以纳米表示；使用 $1\\ \\mathrm{\\AA} = 0.1\\ \\mathrm{nm}$ 将埃转换为纳米。\n- 返回浮点数，四舍五入到六位小数。\n- 最终输出必须是单行，包含一个逗号分隔的列表，其中包含每个测试用例的结果列表，并用方括号括起来。每个测试用例列表必须按以下顺序包含五个条目：[以纳米为单位的朴素 RMSD，以纳米为单位的朴素平均 RMSF，以纳米为单位的校正后 RMSD，以纳米为单位的校正后平均 RMSF，验证标志布尔值]。例如，最后一行必须类似于 $[[$case1\\_r1$, $case1\\_r2$, $case1\\_r3$, $case1\\_r4$, $case1\\_b$],[$case2\\_r1$, $case2\\_r2$, $case2\\_r3$, $case2\\_r4$, $case2\\_b$],\\dots]$，其中每个浮点数四舍五入到六位小数，布尔值为 $True$ 或 $False$。\n\n测试套件：\n完全按照规定实现以下四个测试用例。为清晰起见，原子索引为 $0$ 到 $3$，帧索引从 $0$ 开始。\n\n- 测试用例 1（正常路径，单位一致）：\n  - 原子数：$N=4$。\n  - 帧数：$F=4$。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}]$。\n  - 原子 $0$ 到 $3$ 的基本坐标 $B$（单位：纳米）：\n    - 原子 $0$：$[0.0, 0.0, 0.0]$，\n    - 原子 $1$：$[0.3, 0.0, 0.0]$，\n    - 原子 $2$：$[0.0, 0.4, 0.0]$，\n    - 原子 $3$：$[0.0, 0.0, 0.5]$。\n  - 每个原子的偏移向量 $O$（单位：纳米）：\n    - 原子 $0$：$[0.01, -0.005, 0.0]$，\n    - 原子 $1$：$[0.0, 0.008, -0.004]$，\n    - 原子 $2$：$[-0.006, 0.0, 0.007]$，\n    - 原子 $3$：$[0.005, -0.003, 0.002]$。\n  - 帧 $k$ 的坐标为 $B + k\\cdot O$，其中 $k\\in\\{0,1,2,3\\}$。\n  - 参考帧索引：$0$。\n\n- 测试用例 2（跨帧混合单位，一帧为埃）：\n  - 使用与测试用例 $1$ 相同的 $B$ 和 $O$以及帧构造方法。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{\\AA}, \\mathrm{nm}]$。\n  - 通过将帧 $2$ 的坐标数值记录为埃（即，在数据中将帧 $2$ 的纳米坐标乘以 $10$）来模拟单位不匹配。其他帧的数值以纳米记录。\n  - 参考帧索引：$0$。\n\n- 测试用例 3（边界条件：无运动）：\n  - 原子数：$N=4$。\n  - 帧数：$F=3$。\n  - 每帧单位：$[\\mathrm{nm}, \\mathrm{nm}, \\mathrm{nm}]$。\n  - 所有帧均相同，且等于测试用例 $1$ 中的 $B$。\n  - 参考帧索引：$0$。\n\n- 测试用例 4（边缘情况：单原子，一致的埃单位）：\n  - 原子数：$N=1$。\n  - 帧数：$F=2$。\n  - 每帧单位：$[\\mathrm{\\AA}, \\mathrm{\\AA}]$。\n  - 坐标（单位：埃）：\n    - 帧 $0$：$[1.0, 0.0, 0.0]$，\n    - 帧 $1$：$[3.0, 0.0, 0.0]$。\n  - 参考帧索引：$0$。\n\n计算和报告细节：\n- 对于每个测试用例，计算最后一帧相对于参考帧的 RMSD 和所有原子的平均 RMSF，计算两次：\n  - 朴素计算：直接根据给定的数值坐标计算，不进行任何单位转换。\n  - 校正后计算：首先使用提供的单位元数据将每个帧转换为纳米，然后进行计算。\n- 执行上述验证检查，并为每个测试用例报告一个布尔值，指示是否检测到不一致。\n- 您的程序应生成单行输出，其中包含一个逗号分隔的列表，列表内是所有结果，并用方括号括起来。每个测试用例贡献一个包含五个元素的列表：$[[r_{1}, r_{2}, r_{3}, r_{4}, b_{1}], [\\dots], [\\dots], [\\dots]]$，所有距离均以纳米为单位，四舍五入到六位小数，布尔值为 $True$ 或 $False$。",
            "solution": "该问题要求实现算法，以基于欧几里得几何和统计力学的基本原理来计算分子动力学轨迹的均方根偏差（RMSD）和均方根涨落（RMSF）。实现还必须包括用于检测常见单位不一致性的验证检查。解决方案将首先建立数学形式体系，然后描述验证逻辑，最后详细说明计算策略。\n\n### 数学形式体系和算法设计\n\n一个包含 $N$ 个原子、跨越 $F$ 个帧的分子系统的轨迹可以表示为一组位置向量 $\\{\\vec{r}_i(t)\\}$，其中 $i \\in \\{1, \\dots, N\\}$ 是原子索引，$t \\in \\{1, \\dots, F\\}$ 是帧索引。每个 $\\vec{r}_i(t)$ 是三维欧几里得空间中的一个向量，即 $\\vec{r}_i(t) \\in \\mathbb{R}^3$。\n\n#### 单位转换\n一个关键的初始步骤是确保所有帧的单位统一。问题指定了两种可能的单位：纳米（$\\mathrm{nm}$）和埃（$\\mathrm{\\AA}$）。所有最终计算必须以纳米为单位。给定的转换因子是 $1\\ \\mathrm{\\AA} = 0.1\\ \\mathrm{nm}$。\n设 $C_t$ 为帧 $t$ 的坐标矩阵，设 $u_t$ 为该帧的单位标签。以纳米为单位的校正后坐标 $C'_t$ 按如下方式获得：\n$$\nC'_t = \\begin{cases}\n    C_t \\times 0.1  \\text{若 } u_t = \\mathrm{\\AA} \\\\\n    C_t  \\text{若 } u_t = \\mathrm{nm}\n\\end{cases}\n$$\n此转换应用于每个帧的坐标数据，以生成一个“校正后”的轨迹，其中所有位置均以纳米表示。“朴素”计算将使用给定的原始数值数据，而不进行此转换。\n\n#### 均方根偏差 (RMSD)\nRMSD 衡量特定帧 $t$ 的原子与参考帧 $t_{ref}$ 原子之间的平均距离。设 $\\vec{r}_i(t)$ 和 $\\vec{r}_i(t_{ref})$ 分别为原子 $i$ 在目标帧和参考帧中的位置向量。\n原子 $i$ 的这些位置之间的欧几里得距离的平方是 $||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2$。\n均方偏差（MSD）是这些平方距离在所有 $N$ 个原子上的平均值：\n$$\n\\text{MSD}(t) = \\frac{1}{N} \\sum_{i=1}^{N} ||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2\n$$\nRMSD 是 MSD 的主平方根：\n$$\n\\text{RMSD}(t) = \\sqrt{\\text{MSD}(t)} = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} ||\\vec{r}_i(t) - \\vec{r}_i(t_{ref})||^2}\n$$\n问题指定计算最后一帧（$t=F$）相对于参考帧（$t_{ref}$）的 RMSD。\n\n#### 均方根涨落 (RMSF)\nRMSF 衡量每个原子位置随时间相对于其平均位置的涨落。\n首先，对于每个原子 $i$，我们计算其在所有 $F$ 帧上的时间平均位置 $\\langle \\vec{r}_i \\rangle$：\n$$\n\\langle \\vec{r}_i \\rangle = \\frac{1}{F} \\sum_{t=1}^{F} \\vec{r}_i(t)\n$$\n接下来，我们计算每个原子 $i$ 的均方涨落（MSF），即其位置与其平均位置的偏差平方的时间平均值：\n$$\n\\text{MSF}_i = \\frac{1}{F} \\sum_{t=1}^{F} ||\\vec{r}_i(t) - \\langle \\vec{r}_i \\rangle||^2\n$$\n原子 $i$ 的 RMSF 是其 MSF 的平方根：\n$$\n\\text{RMSF}_i = \\sqrt{\\text{MSF}_i} = \\sqrt{\\frac{1}{F} \\sum_{t=1}^{F} ||\\vec{r}_i(t) - \\langle \\vec{r}_i \\rangle||^2}\n$$\n问题要求一个代表所有原子平均 RMSF 的标量值：\n$$\n\\langle \\text{RMSF} \\rangle = \\frac{1}{N} \\sum_{i=1}^{N} \\text{RMSF}_i\n$$\n\n### 验证检查\n对朴素（未转换）轨迹数据及其相关的单位元数据执行两个验证检查。`True` 标志表示检测到不一致。\n\n1.  **元数据一致性检查**：此检查验证为每个帧提供的单位标签是否统一。如果轨迹的单位列表中存在多个唯一的单位标签，则检查失败。设 $U = \\{u_1, u_2, \\dots, u_F\\}$ 为单位标签集合。如果 $| \\text{set}(U) | > 1$，则标记为不一致。\n\n2.  **量级连续性检查**：此检查识别连续帧之间坐标尺度的突然变化，这通常表示单位错误。\n    - 对于每个帧 $t$，我们计算一个特征量级 $M_t$。这被定义为该帧中所有原子位置向量的欧几里得范数的中位数：$M_t = \\text{median}(\\{||\\vec{r}_1(t)||, ||\\vec{r}_2(t)||, \\dots, ||\\vec{r}_N(t)||\\})$。\n    - 然后我们计算每对连续帧的量级比率：$R_t = M_{t+1} / M_t$，其中 $t \\in \\{1, \\dots, F-1\\}$。\n    - 如果任何比率 $R_t$ 超出指定的容差区间，则标记为不一致。问题将其定义为 $R_t > 3$ 或 $R_t < 1/3$。\n\n测试用例的最终验证标志是这两个检查结果的逻辑或。\n\n### 测试用例的实现策略\n一个主函数将处理四个测试用例中的每一个。对于每个用例，它将：\n1.  将朴素轨迹构建为形状为 $(F, N, 3)$ 的数值数组，以及每帧的单位列表。测试用例 1、2 和 3 是根据基本坐标 $B$ 和偏移向量 $O$ 生成的。\n2.  通过对标记为“Å”的帧应用 $1\\ \\mathrm{\\AA} = 0.1\\ \\mathrm{nm}$ 转换因子来构建校正后的轨迹。\n3.  使用朴素轨迹计算朴素 RMSD 和朴素平均 RMSF。\n4.  使用校正后的轨迹计算校正后 RMSD 和校正后平均 RMSF。\n5.  对朴素数据执行元数据和量级验证检查。\n6.  将五个结果——朴素 RMSD、朴素平均 RMSF、校正后 RMSD、校正后平均 RMSF 和验证标志——整理到一个列表中，确保所有浮点数都四舍五入到六位小数。\n然后将所有测试用例的结果汇总到一个最终列表中，并以所需格式打印。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trajectory analysis problem for all test cases.\n    It computes naive and corrected RMSD and mean RMSF, and performs validation checks\n    for unit inconsistencies.\n    \"\"\"\n\n    def calculate_rmsd(coords_final, coords_ref):\n        \"\"\"Calculates RMSD between two sets of atomic coordinates.\"\"\"\n        if coords_final.shape[0] == 0:\n            return 0.0\n        diffs = coords_final - coords_ref\n        squared_dists = np.sum(diffs**2, axis=1)\n        msd = np.mean(squared_dists)\n        return np.sqrt(msd)\n\n    def calculate_mean_rmsf(trajectory):\n        \"\"\"Calculates mean RMSF across all atoms in a trajectory.\"\"\"\n        num_frames, num_atoms, _ = trajectory.shape\n        if num_atoms == 0 or num_frames == 1:\n            return 0.0\n        \n        mean_coords = np.mean(trajectory, axis=0) # Shape (num_atoms, 3)\n        # Expand dims for broadcasting: trajectory - mean_coords\n        diffs = trajectory - mean_coords[np.newaxis, :, :] # Shape (F, N, 3)\n        squared_flucts = np.sum(diffs**2, axis=2) # Shape (F, N)\n        msf_per_atom = np.mean(squared_flucts, axis=0) # Shape (N)\n        rmsf_per_atom = np.sqrt(msf_per_atom)\n        mean_rmsf = np.mean(rmsf_per_atom)\n        return mean_rmsf\n\n    def run_validation(trajectory, units):\n        \"\"\"Performs metadata and magnitude continuity checks.\"\"\"\n        # 1. Metadata consistency check\n        metadata_inconsistent = len(set(units)) > 1\n\n        # 2. Magnitude continuity check\n        magnitude_inconsistent = False\n        num_frames = trajectory.shape[0]\n        if num_frames > 1:\n            magnitudes = []\n            for frame_coords in trajectory:\n                # Euclidean norms for all atoms in the frame\n                norms = np.linalg.norm(frame_coords, axis=1)\n                magnitudes.append(np.median(norms))\n            \n            for i in range(num_frames - 1):\n                m1, m2 = magnitudes[i], magnitudes[i+1]\n                if m1 == 0:  # Avoid division by zero; if m1 is 0, ratio is inf unless m2 is also 0.\n                    if m2 > 0:\n                        magnitude_inconsistent = True\n                        break\n                    else: # 0/0 -> ratio is undefined, but not a large discontinuity\n                        continue\n\n                ratio = m2 / m1\n                if ratio > 3.0 or ratio  1/3.0:\n                    magnitude_inconsistent = True\n                    break\n        \n        return metadata_inconsistent or magnitude_inconsistent\n\n\n    # Base data for Test Cases 1, 2, 3\n    B = np.array([\n        [0.0, 0.0, 0.0],\n        [0.3, 0.0, 0.0],\n        [0.0, 0.4, 0.0],\n        [0.0, 0.0, 0.5]\n    ])\n    O = np.array([\n        [0.01, -0.005, 0.0],\n        [0.0, 0.008, -0.004],\n        [-0.006, 0.0, 0.007],\n        [0.005, -0.003, 0.002]\n    ])\n    \n    # Define test cases\n    test_cases = [\n        {\n            \"id\": 1,\n            \"N\": 4, \"F\": 4, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"nm\", \"nm\"],\n            \"generator\": lambda: np.array([B + k * O for k in range(4)])\n        },\n        {\n            \"id\": 2,\n            \"N\": 4, \"F\": 4, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"Å\", \"nm\"],\n            \"generator\": lambda: np.array([B + k * O for k in range(4)])\n        },\n        {\n            \"id\": 3,\n            \"N\": 4, \"F\": 3, \"ref_idx\": 0,\n            \"units\": [\"nm\", \"nm\", \"nm\"],\n            \"generator\": lambda: np.array([B, B, B])\n        },\n        {\n            \"id\": 4,\n            \"N\": 1, \"F\": 2, \"ref_idx\": 0,\n            \"units\": [\"Å\", \"Å\"],\n            \"generator\": lambda: np.array([[[1.0, 0.0, 0.0]], [[3.0, 0.0, 0.0]]])\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        F = case[\"F\"]\n        ref_idx = case[\"ref_idx\"]\n        units = case[\"units\"]\n\n        # 1. Generate naive trajectory\n        naive_trajectory = case[\"generator\"]()\n        # Special handling for case 2 unit mismatch simulation\n        if case[\"id\"] == 2:\n            naive_trajectory[2] *= 10.0\n\n        # 2. Generate corrected trajectory\n        corrected_trajectory = np.copy(naive_trajectory)\n        for i in range(F):\n            if units[i] == \"Å\":\n                corrected_trajectory[i] *= 0.1\n\n        # 3. Perform calculations\n        # Naive calculations\n        naive_rmsd = calculate_rmsd(naive_trajectory[-1], naive_trajectory[ref_idx])\n        naive_mean_rmsf = calculate_mean_rmsf(naive_trajectory)\n\n        # Corrected calculations\n        corrected_rmsd = calculate_rmsd(corrected_trajectory[-1], corrected_trajectory[ref_idx])\n        corrected_mean_rmsf = calculate_mean_rmsf(corrected_trajectory)\n\n        # 4. Perform validation\n        validation_flag = run_validation(naive_trajectory, units)\n\n        # 5. Store results\n        all_results.append([\n            f\"{naive_rmsd:.6f}\",\n            f\"{naive_mean_rmsf:.6f}\",\n            f\"{corrected_rmsd:.6f}\",\n            f\"{corrected_mean_rmsf:.6f}\",\n            str(validation_flag)\n        ])\n    \n    # Final print statement in the exact required format.\n    # e.g., [[val,val,val,val,Bool],[...]]\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "分子动力学模拟通常在周期性边界条件（PBC）下进行，这会导致分子坐标被“卷绕”到主晶胞中，从而破坏分子的连续性。本练习旨在揭示为何必须在计算RMSD和RMSF之前对这些“卷绕”坐标进行校正，并指导您实现一个强大的坐标展开算法，以确保分析的物理意义。",
            "id": "3868658",
            "problem": "给定一个计算化学生物学场景，其中分子动力学轨迹在周期性边界条件下被记录。模拟系统是一个三维正交周期性盒子，记录的坐标被“卷回”到晶胞的主镜像中。您必须使用第一性原理来解释，为何在对齐坐标并计算均方根偏差 (RMSD) 和均方根涨落 (RMSF) 之前，周期性边界条件要求进行解卷绕或镜像校正，然后实现一个稳健的解卷绕算法。最后，您必须为一小组卷绕后的轨迹测试集计算 RMSD 和 RMSF，并展示解卷绕的效果。\n\n从以下基础概念开始：\n- 周期性盒子是一个由边长 $\\mathbf{L} = (L_x, L_y, L_z)$ （单位为纳米）定义的晶格；坐标遵循模 $\\mathbf{L}$ 等价，即对于整数 $n_x, n_y, n_z$，两个位置 $\\mathbf{r}$ 和 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 在周期性意义上代表同一个物理点。\n- 三维空间中的欧几里得距离定义为 $\\|\\mathbf{a} - \\mathbf{b}\\| = \\sqrt{(a_x - b_x)^2 + (a_y - b_y)^2 + (a_z - b_z)^2}$。\n- 两组点之间的最佳拟合刚性对齐（旋转和平移）通过最小化对应点之间欧几里得距离的平方和来实现，其约束条件是变换为特殊正交群 $\\mathrm{SO}(3)$ 中的一次旋转，然后进行一次平移。\n- 具有 $N$ 个原子的两种构象之间的均方根偏差 (RMSD) 是在最优对齐后，对应原子之间距离平方的均值的平方根。\n- 在一条轨迹上，单个原子的均方根涨落 (RMSF) 是指（通过对齐消除全局旋转和平移后）该原子与其时间平均位置之间距离平方的均值的平方根。\n\n您的任务：\n1. 从上述基础概念出发，解释为什么在计算 RMSD 和 RMSF 之前，如果不应用解卷绕或镜像校正，周期性边界条件下的卷绕坐标会导致错误的距离和对齐偏差。\n2. 提出并实现一种能够逐帧稳健地解卷绕坐标的算法，该算法需保留连续性和内部分子几何构型。该算法必须使用连接性（原子间的成键图）来在整个分子中传播镜像校正，并使用最小镜像约定来选择最近的周期性镜像以保证连续性。\n3. 使用通过最小化距离平方和推导出的最优刚性旋转和平移，将每个轨迹帧与第一帧对齐，并计算：\n   - 相对于参考帧 $t = 0$，帧 $t = 1,\\dots,T-1$ 的平均 RMSD。\n   - 基于所有帧 $t = 0,\\dots,T-1$ 的对齐坐标计算出的原子平均 RMSF。\n4. 使用原始卷绕坐标（未解卷绕）和使用您解卷绕后的坐标各执行一次上述计算。报告每种测试用例的两组结果。\n\n物理单位：\n- 所有坐标和盒子长度均以纳米为单位。RMSD 和 RMSF 必须以纳米为单位的浮点数形式报告。\n\n角度单位：\n- 您用于合成振动的任何周期性调制都必须在三角函数中使用弧度。\n\n测试集：\n实现您的程序以使用以下三个合成轨迹的测试用例。每个测试用例定义了原子数 $N$、帧数 $T$、盒子长度 $\\mathbf{L}$、原子索引 $i$ 的初始构型 $\\mathbf{r}_i(0)$、每帧的恒定漂移 $\\mathbf{d}$，以及微小的逐帧振动 $\\boldsymbol{\\epsilon}_{i}(t)$。解卷绕后的坐标定义为\n$$\n\\mathbf{r}_i(t) = \\mathbf{r}_i(0) + t\\,\\mathbf{d} + \\boldsymbol{\\epsilon}_{i}(t),\n$$\n记录的卷绕坐标为\n$$\n\\mathbf{w}_i(t) = \\mathbf{r}_i(t) \\bmod \\mathbf{L},\n$$\n其中取模操作是分量式地应用的，用以将位置映射到每个轴 $\\alpha \\in \\{x,y,z\\}$ 的区间 $[0,L_\\alpha)$ 中。\n\n逐帧振动定义为\n$$\n\\boldsymbol{\\epsilon}_{i}(t) = \\left(0,\\; 0.01 \\sin\\left(\\frac{2\\pi t}{T} + i\\right),\\; 0.005 \\cos\\left(\\frac{2\\pi t}{T} + \\frac{i}{2}\\right)\\right),\n$$\n所有量纲的单位均为纳米和弧度。\n\n对于每个测试，提供一个形成链的无向边列表作为成键连接性。\n\n- 测试用例 A（跨越 $x$ 边界的理想路径漂移）：\n  - $N = 3$, $T = 6$, $\\mathbf{L} = (3.0, 3.0, 3.0)$。\n  - 初始位置：$\\mathbf{r}_0(0) = (0.40, 0.40, 0.20)$, $\\mathbf{r}_1(0) = (0.52, 0.40, 0.20)$, $\\mathbf{r}_2(0) = (0.64, 0.40, 0.20)$。\n  - 每帧漂移：$\\mathbf{d} = (0.80, 0.00, 0.00)$。\n  - 连接性：边 $(0,1)$, $(1,2)$。\n\n- 测试用例 B（跨越 $y$ 边界且伴有轻微内部振动的漂移）：\n  - $N = 5$, $T = 8$, $\\mathbf{L} = (2.5, 2.5, 2.5)$。\n  - 初始位置：$\\mathbf{r}_0(0) = (0.30, 1.80, 0.30)$, $\\mathbf{r}_1(0) = (0.30, 1.90, 0.30)$, $\\mathbf{r}_2(0) = (0.30, 2.00, 0.30)$, $\\mathbf{r}_3(0) = (0.30, 2.10, 0.30)$, $\\mathbf{r}_4(0) = (0.30, 2.20, 0.30)$。\n  - 每帧漂移：$\\mathbf{d} = (0.00, -0.60, 0.00)$。\n  - 连接性：边 $(0,1)$, $(1,2)$, $(2,3)$, $(3,4)$。\n\n- 测试用例 C（在 $x$ 方向接近半盒子长度的跳跃以探测舍入稳健性）：\n  - $N = 4$, $T = 7$, $\\mathbf{L} = (3.0, 3.0, 3.0)$。\n  - 初始位置：$\\mathbf{r}_0(0) = (0.10, 0.50, 0.10)$, $\\mathbf{r}_1(0) = (0.23, 0.50, 0.10)$, $\\mathbf{r}_2(0) = (0.36, 0.50, 0.10)$, $\\mathbf{r}_3(0) = (0.49, 0.50, 0.10)$。\n  - 每帧漂移：$\\mathbf{d} = (1.49, 0.00, 0.00)$。\n  - 连接性：边 $(0,1)$, $(1,2)$, $(2,3)$。\n\n所需计算：\n- 对于每个测试用例，计算四个以纳米为单位的浮点数：\n  1. 使用卷绕坐标计算的平均 RMSD，与卷绕后的帧 $t=0$ 对齐。\n  2. 使用解卷绕坐标计算的平均 RMSD，与解卷绕后的帧 $t=0$ 对齐。\n  3. 使用对齐后的卷绕坐标计算的平均 RMSF（按原子平均）。\n  4. 使用对齐后的解卷绕坐标计算的平均 RMSF（按原子平均）。\n\n输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的结果，格式为方括号括起来的逗号分隔列表；每个内部列表必须按照上述四个浮点数的顺序排列。例如：\"[[a,b,c,d],[e,f,g,h],[i,j,k,l]]\"。所有值都必须是纳米单位的浮点数。\n\n无外部输入：\n- 您的程序必须是自包含的，按规定生成测试用例，并严格按照描述打印结果行，不得包含任何额外文本。对齐必须通过在 $\\mathrm{SO}(3)$ 中的旋转和平移下最小化距离平方和来执行，解卷绕必须使用连接性和最小镜像约定来强制实现连续性和内部几何构型。\n\n所有报告的量均以纳米为单位。不要包含百分号；任何比率（如果存在）必须以十进制数报告。",
            "solution": "所提出的问题是有效的，其科学基础植根于计算生物物理学原理，并且问题定义明确，提供了足够的信息以获得唯一解。我们将进行详细的、分步的解答。\n\n此问题的核心在于，像均方根偏差 (RMSD) 和均方根涨落 (RMSF) 这类结构比较度量指标的数学形式（其假设对象在欧几里得空间中是连续的）与模拟中周期性边界条件 (PBC) 的计算便利性之间存在脱节。PBC 会将坐标“卷回”到一个主盒子中，从而打破了这种连续性。\n\n### 1. 为何计算RMSD和RMSF必须进行解卷绕\n\n让我们从基本定义开始。RMSD 和 RMSF 分别是衡量结构相似性和原子迁移率的指标。两者都根本上依赖于原子位置之间的欧几里得距离 $\\|\\mathbf{a} - \\mathbf{b}\\|$。\n\n两种构象 A 和 B（各有 N 个原子）之间的 RMSD，是在找到一个最优刚体变换（旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $\\mathbf{v}$）以最小化对应原子间距离的平方和之后计算得出的。其 RMSD 为：\n$$\n\\text{RMSD}(A, B) = \\min_{R, \\mathbf{v}} \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\| (R\\mathbf{r}_{i,A} + \\mathbf{v}) - \\mathbf{r}_{i,B} \\|^2}\n$$\n在一个包含 T 帧的轨迹中，原子 i 的 RMSF 是其相对于平均位置的均方根位移，这是在整个轨迹对齐到一个公共参考系以移除全局平移和旋转之后计算的：\n$$\n\\text{RMSF}_i = \\sqrt{\\frac{1}{T} \\sum_{t=0}^{T-1} \\| \\mathbf{r}'_i(t) - \\langle \\mathbf{r}'_i \\rangle \\|^2}\n$$\n其中 $\\mathbf{r}'_i(t)$ 是对齐后第 t 帧中原子 i 的坐标，$\\langle\\mathbf{r}'_i\\rangle$ 是其时间平均位置。\n\n现在，考虑一个使用边长为 $\\mathbf{L} = (L_x, L_y, L_z)$ 的周期性盒子的分子动力学模拟。当一个原子穿过边界时，其坐标会被“卷回”到主盒子中，通常是每个轴 $\\alpha \\in \\{x, y, z\\}$ 上的区间 $[0, L_\\alpha)$。例如，一个原子从 $x=L_x - \\delta$ 移动到 $x=L_x + \\delta$（其中 $\\delta$ 很小），其记录的坐标将从 $L_x - \\delta$ 跳跃到 $\\delta$。\n\n如果不进行校正，这种卷绕过程对 RMSD 和 RMSF 的计算会产生两个灾难性后果：\n\n1.  **内部几何构型的扭曲**：考虑两个键合原子 i 和 j，它们的键长很小。如果分子漂移，使得原子 i 位于 $x_i \\approx 0$ 而原子 j 穿过边界到达 $x_j \\approx L_x$，它们之间的真实距离很小。然而，从它们卷绕后的坐标 $\\|\\mathbf{w}_i - \\mathbf{w}_j\\|$ 计算出的朴素欧几里得距离将会很大，接近 $L_x$。这会人为地破坏分子的表观结构。旨在最小化这些距离平方和的对齐算法，将面对一个看起来极其扭曲的结构。它将无法找到有意义的叠合，从而导致一个异常大且不正确的 RMSD 值，该值反映的是盒子的大小属性，而非真实的构象变化。\n\n2.  **时间平均值的破坏**：对于 RMSF，需要对一个原子在一段时间内的坐标进行平均。如果一个原子的真实轨迹是连续的但穿过了边界，其卷绕坐标将表现出巨大的瞬时跳跃（例如，从 $L_y-\\delta$ 到 $\\delta$）。这些跳跃坐标的平均值 $\\langle \\mathbf{w}_i \\rangle$ 将不代表一个有物理意义的中心位置。相反，它会偏向盒子的中心。因此，计算出的 $\\mathbf{w}_i(t)$ 围绕这个错误平均值的涨落 $\\|\\mathbf{w}_i(t) - \\langle \\mathbf{w}_i \\rangle\\|^2$ 将会非常巨大，并且主要由人为的卷绕事件主导，而不是由原子真实的物理振动主导。\n\n因此，在进行任何对齐、RMSD 或 RMSF 分析之前，“解卷绕”轨迹或至少应用镜像校正，以恢复分子在欧几里得空间中物理上连续的表示，是一个绝对的先决条件。\n\n### 2. 坐标解卷绕算法\n\n一个稳健的解卷绕算法必须实现两个目标：（1）保持分子结构的内部几何完整性，（2）保留分子整体运动的时间连续性。以下算法利用分子的成键连接性和最小镜像约定 (MIC) 来实现这一目标。\n\nMIC 指出，周期性盒子中两点 $\\mathbf{a}$ 和 $\\mathbf{b}$ 之间的真实矢量是连接 $\\mathbf{a}$ 与 $\\mathbf{b}$ 的最近周期性镜像的那个矢量。该矢量 $\\Delta\\mathbf{r}_{\\text{mic}}$ 计算如下：\n$$\n\\Delta\\mathbf{r}_{\\text{mic}}(\\mathbf{a}, \\mathbf{b}) = (\\mathbf{a} - \\mathbf{b}) - \\mathbf{L} \\odot \\text{round}\\left(\\frac{\\mathbf{a} - \\mathbf{b}}{\\mathbf{L}}\\right)\n$$\n其中 $\\odot$ 表示分量式乘法，除法和舍入操作也是分量式的。\n\n解卷绕过程逐帧进行，使用前一帧已解卷绕的坐标作为当前帧的参考。设 $\\mathbf{W}(t)$ 是卷绕后的轨迹，$\\mathbf{R}(t)$ 是待构建的解卷绕轨迹。\n\n**算法：逐帧解卷绕**\n1.  **初始化**：第一帧无需解卷绕。对所有原子 $i=0, \\dots, N-1$，设置 $\\mathbf{R}_i(0) = \\mathbf{W}_i(0)$。\n2.  **迭代**：对于每个后续帧 $t=1, \\dots, T-1$：\n    a.  设 $\\mathbf{R}_{\\text{prev}}$ 为第 $t-1$ 帧的解卷绕坐标，$\\mathbf{W}_{\\text{curr}}$ 为第 $t$ 帧的卷绕坐标。\n    b.  **种子原子的连续性**：选择一个“种子”原子（例如，原子0）。通过假设其从前一帧的运动是连续的，来确定其在新帧中的解卷绕位置。我们计算其位移矢量的最小镜像：\n        -   卷绕空间中的位移：$\\Delta\\mathbf{w}_0 = \\mathbf{W}_0(t) - \\mathbf{R}_0(t-1)$。\n        -   最小镜像位移：$\\Delta\\mathbf{r}'_0 = \\Delta\\mathbf{w}_0 - \\mathbf{L} \\odot \\text{round}(\\Delta\\mathbf{w}_0 / \\mathbf{L})$。\n        -   设置种子原子的新解卷绕位置：$\\mathbf{R}_0(t) = \\mathbf{R}_0(t-1) + \\Delta\\mathbf{r}'_0$。\n    c.  **通过连接性传播**：围绕新放置的种子原子重建分子的其余部分。这通过遍历成键连接图（例如，使用从种子原子开始的广度优先搜索或深度优先搜索）来完成。\n        -   用种子原子和已访问原子集合初始化一个遍历队列。\n        -   当队列不为空时，出队一个位置 $\\mathbf{R}_i(t)$ 已知的原子 $i$。\n        -   对于 $i$ 的每个尚未访问的键合邻居 $j$：\n            i.  计算当前卷绕帧中 $j$ 和 $i$ 之间的矢量：$\\Delta\\mathbf{w}_{ji} = \\mathbf{W}_j(t) - \\mathbf{W}_i(t)$。\n            ii. 应用 MIC 找到正确的键矢量，连接到原子 $j$ 的最近镜像：$\\Delta\\mathbf{r}'_{ji} = \\Delta\\mathbf{w}_{ji} - \\mathbf{L} \\odot \\text{round}(\\Delta\\mathbf{w}_{ji} / \\mathbf{L})$。\n            iii. 设置原子 $j$ 的解卷绕位置：$\\mathbf{R}_j(t) = \\mathbf{R}_i(t) + \\Delta\\mathbf{r}'_{ji}$。\n            iv. 将 $j$ 标记为已访问并将其加入队列。\n3.  得到的坐标序列 $\\mathbf{R}(t)$ 构成了完全解卷绕的轨迹，它代表了在无限欧几里得空间中的一条连续路径，并保留了所有内部共价几何构型。\n\n### 3. 对齐与分析流程\n\n有了一个有效（已解卷绕）的轨迹，我们就可以进行分析。\n\n**对齐**：最优刚体旋转使用基于奇异值分解 (SVD) 的 Kabsch 算法找到。要将一个“移动”坐标集 $A$ 对齐到一个“参考”坐标集 $B$：\n1.  将两组坐标平移至各自的质心：$A' = A - \\mathbf{c}_A$ 和 $B' = B - \\mathbf{c}_B$。\n2.  计算 $3 \\times 3$ 协方差矩阵 $H = (A')^T B'$。\n3.  对 $H$ 进行 SVD：$H = U S V^T$。\n4.  最优旋转矩阵为 $R = V U^T$。必须执行检查以确保 $R$ 是一个真旋转（$\\det(R)=+1$）而不是一个镜像反映。如果 $\\det(R)=-1$，则在重新计算 $R$ 之前，将 $V$ 中对应于最小奇异值的列的符号翻转。\n5.  然后旋转移动坐标：$A'' = A' R$。\n\n**RMSD 计算**：\n- 对于每个帧 $t \\in \\{1, \\dots, T-1\\}$，将坐标 $\\mathbf{X}(t)$ 对齐到参考帧 $\\mathbf{X}(0)$。\n- 计算中心化坐标：$\\mathbf{X}'(t) = \\mathbf{X}(t) - \\mathbf{c}(t)$ 和 $\\mathbf{X}'(0) = \\mathbf{X}(0) - \\mathbf{c}(0)$。\n- 通过 Kabsch 算法找到旋转矩阵 $R_t$。\n- 该帧的 RMSD 为 $\\text{RMSD}(t) = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} \\| (\\mathbf{X}'(t)R_t)_i - \\mathbf{X}'_i(0) \\|^2}$。\n- 最终报告的值是这些值的平均值：$\\langle \\text{RMSD} \\rangle = \\frac{1}{T-1}\\sum_{t=1}^{T-1}\\text{RMSD}(t)$。\n\n**RMSF 计算**：\n- 将整个轨迹 $\\mathbf{X}(0), \\dots, \\mathbf{X}(T-1)$ 对齐到单个参考帧 $\\mathbf{X}(0)$。这将产生一个对齐结构的轨迹 $\\mathbf{X}''(0), \\dots, \\mathbf{X}''(T-1)$，其中每一帧都已被中心化并最优旋转。\n- 对于每个原子 $i$，从这个对齐的轨迹计算其时间平均位置：$\\langle \\mathbf{x}''_i \\rangle = \\frac{1}{T}\\sum_{t=0}^{T-1} \\mathbf{x}''_i(t)$。\n- 原子 $i$ 的 RMSF 则为 $\\text{RMSF}_i = \\sqrt{\\frac{1}{T}\\sum_{t=0}^{T-1} \\| \\mathbf{x}''_i(t) - \\langle \\mathbf{x}''_i \\rangle \\|^2}$。\n- 最终报告的值是所有原子的平均 RMSF：$\\langle \\text{RMSF} \\rangle = \\frac{1}{N}\\sum_{i=0}^{N-1}\\text{RMSF}_i$。\n\n实现将对每个测试用例执行两次这些计算：一次使用原始的、卷绕后的坐标，另一次使用我们的解卷绕算法生成的坐标。正如假设的那样，结果将显示出巨大的差异，从而凸显了解卷绕步骤的至关重要性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"N\": 3, \"T\": 6, \"L\": np.array([3.0, 3.0, 3.0]),\n            \"r0\": np.array([\n                [0.40, 0.40, 0.20],\n                [0.52, 0.40, 0.20],\n                [0.64, 0.40, 0.20]\n            ]),\n            \"d\": np.array([0.80, 0.00, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2)],\n        },\n        {\n            \"N\": 5, \"T\": 8, \"L\": np.array([2.5, 2.5, 2.5]),\n            \"r0\": np.array([\n                [0.30, 1.80, 0.30],\n                [0.30, 1.90, 0.30],\n                [0.30, 2.00, 0.30],\n                [0.30, 2.10, 0.30],\n                [0.30, 2.20, 0.30]\n            ]),\n            \"d\": np.array([0.00, -0.60, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n        },\n        {\n            \"N\": 4, \"T\": 7, \"L\": np.array([3.0, 3.0, 3.0]),\n            \"r0\": np.array([\n                [0.10, 0.50, 0.10],\n                [0.23, 0.50, 0.10],\n                [0.36, 0.50, 0.10],\n                [0.49, 0.50, 0.10]\n            ]),\n            \"d\": np.array([1.49, 0.00, 0.00]),\n            \"connectivity\": [(0, 1), (1, 2), (2, 3)],\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        N, T, L, r0, d, conn_edges = case[\"N\"], case[\"T\"], case[\"L\"], case[\"r0\"], case[\"d\"], case[\"connectivity\"]\n\n        # 1. Generate trajectories\n        unwrapped_traj = np.zeros((T, N, 3))\n        wrapped_traj = np.zeros((T, N, 3))\n        \n        t_vals = np.arange(T)[:, np.newaxis]\n        i_vals = np.arange(N)[np.newaxis, :]\n        \n        eps_y = 0.01 * np.sin(2 * np.pi * t_vals / T + i_vals)\n        eps_z = 0.005 * np.cos(2 * np.pi * t_vals / T + i_vals / 2)\n        epsilon = np.stack([np.zeros((T, N)), eps_y, eps_z], axis=2)\n\n        unwrapped_traj = r0[np.newaxis, :, :] + t_vals[:, :, np.newaxis] * d[np.newaxis, np.newaxis, :] + epsilon\n        wrapped_traj = unwrapped_traj % L\n\n        # 2. Re-create unwrapped trajectory from wrapped one to test the algorithm\n        re_unwrapped_traj = unwrap_trajectory(wrapped_traj, L, conn_edges)\n\n        # 3. Analyze trajectories\n        mean_rmsd_w, mean_rmsf_w = analyze_trajectory(wrapped_traj)\n        mean_rmsd_u, mean_rmsf_u = analyze_trajectory(re_unwrapped_traj)\n\n        all_results.append([mean_rmsd_w, mean_rmsd_u, mean_rmsf_w, mean_rmsf_u])\n\n    # Final print statement in the exact required format.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\ndef kabsch_align(mobile_coords, ref_coords):\n    \"\"\"\n    Aligns mobile_coords to ref_coords using the Kabsch algorithm and returns the\n    rotated (but not translated) mobile coordinates.\n    \"\"\"\n    # Center coordinates\n    mobile_centroid = np.mean(mobile_coords, axis=0)\n    ref_centroid = np.mean(ref_coords, axis=0)\n    mobile_c = mobile_coords - mobile_centroid\n    ref_c = ref_coords - ref_centroid\n\n    # Covariance matrix\n    H = mobile_c.T @ ref_c\n\n    # SVD\n    U, S, Vt = np.linalg.svd(H)\n    V = Vt.T\n\n    # Calculate rotation matrix, checking for reflection\n    R = V @ U.T\n    if np.linalg.det(R)  0:\n        V[:, -1] *= -1\n        R = V @ U.T\n    \n    # Apply rotation\n    aligned_mobile_c = mobile_c @ R\n    \n    return aligned_mobile_c, ref_c\n\n\ndef analyze_trajectory(traj):\n    \"\"\"\n    Computes mean RMSD and mean RMSF for a given trajectory.\n    \"\"\"\n    T, N, _ = traj.shape\n    ref_frame = traj[0]\n\n    # Mean RMSD calculation (over frames t=1...T-1)\n    rmsd_values = []\n    if T > 1:\n        for t in range(1, T):\n            mobile_frame = traj[t]\n            aligned_mobile_c, ref_c = kabsch_align(mobile_frame, ref_frame)\n            \n            # Sum of squared distances\n            ssd = np.sum((aligned_mobile_c - ref_c)**2)\n            rmsd = np.sqrt(ssd / N)\n            rmsd_values.append(rmsd)\n        mean_rmsd = np.mean(rmsd_values) if rmsd_values else 0.0\n    else:\n        mean_rmsd = 0.0\n\n    # Mean RMSF calculation (over all atoms)\n    aligned_traj_c = np.zeros_like(traj)\n    _, ref_c_for_all = kabsch_align(ref_frame, ref_frame)\n    aligned_traj_c[0] = ref_c_for_all\n    \n    for t in range(1, T):\n        aligned_mobile_c, _ = kabsch_align(traj[t], ref_frame)\n        aligned_traj_c[t] = aligned_mobile_c\n        \n    avg_pos = np.mean(aligned_traj_c, axis=0)\n    sq_displacements = np.sum((aligned_traj_c - avg_pos)**2, axis=2) # Sum over x,y,z\n    msd_per_atom = np.mean(sq_displacements, axis=0) # Average over time\n    rmsf_values = np.sqrt(msd_per_atom)\n    mean_rmsf = np.mean(rmsf_values)\n\n    return mean_rmsd, mean_rmsf\n\n\ndef unwrap_trajectory(wrapped_traj, L, connectivity_edges):\n    \"\"\"\n    Unwraps a trajectory using connectivity and the minimum image convention.\n    \"\"\"\n    T, N, _ = wrapped_traj.shape\n    unwrapped_traj = np.zeros_like(wrapped_traj)\n    unwrapped_traj[0] = wrapped_traj[0]\n\n    # Build adjacency list for connectivity\n    adj = [[] for _ in range(N)]\n    for i, j in connectivity_edges:\n        adj[i].append(j)\n        adj[j].append(i)\n\n    for t in range(1, T):\n        prev_unwrapped = unwrapped_traj[t-1]\n        curr_wrapped = wrapped_traj[t]\n        curr_unwrapped = np.zeros_like(curr_wrapped)\n        \n        visited = [False] * N\n        q = deque()\n\n        # 1. Place seed atom (atom 0) based on temporal continuity\n        seed_atom = 0\n        delta = curr_wrapped[seed_atom] - prev_unwrapped[seed_atom]\n        shift = L * np.round(delta / L)\n        delta_mic = delta - shift\n        curr_unwrapped[seed_atom] = prev_unwrapped[seed_atom] + delta_mic\n        \n        visited[seed_atom] = True\n        q.append(seed_atom)\n\n        # 2. Propagate unwrapping through the molecule via BFS\n        while q:\n            i = q.popleft()\n            for j in adj[i]:\n                if not visited[j]:\n                    delta_ij = curr_wrapped[j] - curr_wrapped[i]\n                    shift_ij = L * np.round(delta_ij / L)\n                    delta_ij_mic = delta_ij - shift_ij\n                    curr_unwrapped[j] = curr_unwrapped[i] + delta_ij_mic\n                    \n                    visited[j] = True\n                    q.append(j)\n        \n        unwrapped_traj[t] = curr_unwrapped\n        \n    return unwrapped_traj\n\n\nif __name__ == \"__main__\":\n    solve()\n\n```"
        },
        {
            "introduction": "从分子动力学轨迹中获得的RMSD等时间序列数据并非相互独立的，这使得标准误差的简单计算会产生误导。本练习将引导您进入高级统计分析领域，通过实现块平均法来处理数据的时间相关性，从而为您的计算结果提供一个严谨且可靠的误差估计。",
            "id": "3868639",
            "problem": "给定一个时间序列，它代表某个大分子相对于一个固定参考结构在时间上均匀采样的均方根偏差 (RMSD) 值。将此 RMSD 序列视为一个平稳随机过程 $\\{r_t\\}_{t=1}^N$ 的一次实现，单位为埃（angstrom），其中 $t$ 是帧的索引，$N$ 是总帧数。目标是构建一个分块分析方法，以估计 RMSD 均值的标准误差，并使用积分自相关时间来选择块的大小。\n\n从平稳过程的核心定义出发：期望、方差、自协方差函数和自相关函数，并将这些作为您推导和算法的基础。您的程序必须：\n\n- 估计中心化的 RMSD 序列的归一化自相关函数，并用它来计算以帧为单位的积分自相关时间。\n- 通过将积分自相关时间乘以一个常数因子来选择以帧为单位的块大小，使得块的长度大于相关时间，同时确保至少存在两个块。\n- 将序列划分为等长的连续不重叠块，计算每个块的均值，并使用这些块均值来估计整体 RMSD 均值的标准误差。\n- 以科学上一致的方式处理边界情况，例如零方差序列和非常短的序列。\n\n具体要求：\n\n1. 给定一个实值时间序列 $\\{r_t\\}_{t=1}^N$：\n   - 通过减去其样本均值来中心化序列，形成 $\\{x_t\\}_{t=1}^N$，其中 $x_t = r_t - \\bar{r}$。\n   - 使用 $\\{x_t\\}$ 的归一化自协方差计算延迟 $k \\in \\{0,1,\\dots,N-1\\}$ 的样本自相关函数 $\\rho(k)$，根据定义 $\\rho(0) = 1$。\n   - 通过对正延迟自相关值求和来估计以帧为单位的积分自相关时间 $\\tau_{\\mathrm{int}}$，直到由第一个非正 $\\rho(k)$ 定义的截断点为止；如果在可用延迟内没有出现非正值，则继续求和，直到 $\\rho(k)$ 下降到阈值 $1/\\sqrt{N}$ 的延迟处，否则一直加到最大可用延迟。在形成积分自相关时间时，包括与零延迟贡献相关的常规 $\\frac{1}{2}$ 项。\n   - 如果 $\\{x_t\\}$ 的样本方差为零，则设置 $\\tau_{\\mathrm{int}} = 0$。\n\n2. 选择块大小 $B$（以帧为单位），使其为不小于 $c \\,\\tau_{\\mathrm{int}}$ 的最小整数，其中 $c = 5$，并受限于约束条件 $B \\ge 1$ 以及块数 $M = \\left\\lfloor \\frac{N}{B} \\right\\rfloor$ 满足 $M \\ge 2$。如果选择 $B = \\lceil c \\,\\tau_{\\mathrm{int}} \\rceil$ 导致 $M  2$，则设置 $B = \\left\\lfloor \\frac{N}{2} \\right\\rfloor$ 以保证至少有两个块。对于 $\\tau_{\\mathrm{int}} = 0$ 的情况，使用 $B = 1$。\n\n3. 通过截断任何不构成完整块的尾随帧，形成 $M$ 个长度为 $B$ 的连续不重叠块。计算每个块的均值，并使用这些块均值来估计 RMSD 均值的标准误差，该标准误差为块均值的无偏样本方差除以 $M$ 后的平方根。\n\n4. 以埃为单位表示标准误差。将所有最终报告的浮点数四舍五入到六位小数。\n\n5. 测试套件和数据生成：\n   在以下四个测试用例上实现您的方法。为了可复现性，请使用指定的伪随机种子。所有 RMSD 值均以埃为单位。对于自回归过程，使用由噪声幅度缩放的高斯新息 $\\epsilon_t \\sim \\mathcal{N}(0,1)$。\n\n   - 案例 1（近似不相关）：围绕一个均值 RMSD 的白噪声\n     - 参数：$N = 4096$，$\\mu = 2.0$，$\\sigma = 0.1$，seed $= 123$。\n     - 生成方式：$r_t = \\mu + \\sigma \\,\\epsilon_t$，其中 $\\epsilon_t$ 独立。\n   - 案例 2（强自相关）：一阶自回归过程\n     - 参数：$N = 4096$，$\\mu = 2.0$，$\\phi = 0.9$，$\\sigma = 0.05$，seed $= 456$。\n     - 生成方式：$r_1 = \\mu$，对于 $t \\ge 2$，$r_t = \\mu + \\phi \\,(r_{t-1} - \\mu) + \\sigma \\,\\epsilon_t$。\n   - 案例 3（中等自相关且较短）：一阶自回归过程\n     - 参数：$N = 1024$，$\\mu = 3.0$，$\\phi = 0.5$，$\\sigma = 0.2$，seed $= 789$。\n     - 生成方式：$r_1 = \\mu$，对于 $t \\ge 2$，$r_t = \\mu + \\phi \\,(r_{t-1} - \\mu) + \\sigma \\,\\epsilon_t$。\n   - 案例 4（退化）：常数序列\n     - 参数：$N = 128$，$\\mu = 1.5$。\n     - 生成方式：对于所有 $t$，$r_t = \\mu$。\n\n6. 要求的最终输出格式：\n   您的程序应生成单行输出，其中包含所有测试用例的结果，格式为用方括号括起来的逗号分隔列表。每个测试用例的结果必须是包含三个值的列表，顺序为 $[\\tau_{\\mathrm{int}} \\text{ (帧)}, B \\text{ (帧)}, \\text{标准误差 (埃)}]$。例如，使用占位符值的有效输出格式为：“[[$12.000000$,$64$,$0.004321$],[$8.500000$,$43$,$0.002100$],[$1.000000$,$5$,$0.010000$],[$0.000000$,$1$,$0.000000$]]”。您的程序必须完全按照规定实现四个测试用例的生成，并使用您的方法计算相应的输出。",
            "solution": "该问题要求实现一种分块平均法，用于估计相关时间序列（特别是来自分子模拟轨迹的均方根偏差 RMSD 序列）的均值标准误差。该方法的设计由时间序列分析的统计力学概念决定。\n\n从平稳随机过程抽取的时间序列 $\\{r_t\\}_{t=1}^N$ 的特征是其不随时间变化的均值 $\\mu = E[r_t]$ 和方差 $\\sigma^2 = E[(r_t - \\mu)^2]$。不同时间观测值之间的相关性由自协方差函数 $\\gamma(k) = E[(r_t - \\mu)(r_{t+k} - \\mu)]$ 及其归一化形式——自相关函数 (ACF) $\\rho(k) = \\gamma(k) / \\gamma(0)$ 来描述。根据定义，$\\rho(0) = 1$。\n\n主要目标是估计样本均值 $\\bar{r} = \\frac{1}{N}\\sum_{t=1}^N r_t$ 的标准误差。对于一个包含 $N$ 个独立观测值的序列，样本均值的方差为 $\\text{Var}(\\bar{r}) = \\sigma^2/N$。然而，当数据点相关时，此公式是不正确的，并且通常会低估真实方差。相关序列的正确方差由下式给出：\n$$\n\\text{Var}(\\bar{r}) = \\frac{\\sigma^2}{N} \\left( 1 + 2\\sum_{k=1}^{N-1} \\left(1 - \\frac{k}{N}\\right) \\rho(k) \\right)\n$$\n对于大的 $N$，这近似于 $\\text{Var}(\\bar{r}) \\approx \\frac{\\sigma^2}{N} g$，其中 $g$ 是统计非效率性（statistical inefficiency），定义为：\n$$\ng = 1 + 2\\sum_{k=1}^{\\infty} \\rho(k)\n$$\n量 $g$ 可以解释为与一个独立样本包含相同信息量的相关样本的数量。积分自相关时间 $\\tau_{\\mathrm{int}}$ 与 $g$ 相关，并提供了序列中相关时间的度量。问题为它的估计指定了一个特定的定义：\n$$\n\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^{k_{\\mathrm{max}}} \\rho(k)\n$$\n对于大的求和，这通过 $g \\approx 1 + 2\\tau_{\\mathrm{int}}$ 与统计非效率性相关，尽管这个特定公式也与其他约定有关。我们将严格遵循所提供的定义。\n\n分块平均法提供了一种无需显式计算完整 ACF 即可稳健估计 $\\text{Var}(\\bar{r})$ 的方法。其核心思想是将时间序列划分为长度为 $B$ 的块，其中 $B$ 远大于相关时间 $\\tau_{\\mathrm{int}}$。如果 $B \\gg \\tau_{\\mathrm{int}}$，这些块的均值可以被视为近似独立同分布的随机变量。然后，可以将适用于 i.i.d. 数据的标准统计公式应用于这个由块均值组成的新的、较小的样本。\n\n算法流程如下：\n\n**步骤 1：积分自相关时间 $\\tau_{\\mathrm{int}}$ 的估计**\n首先，通过减去样本均值 $\\bar{r} = \\frac{1}{N}\\sum_{t=1}^N r_t$ 来中心化输入时间序列 $\\{r_t\\}_{t=1}^N$，得到一个均值为零的新序列 $\\{x_t = r_t - \\bar{r}\\}_{t=1}^N$。\n\n接下来，计算样本自相关函数 $\\hat{\\rho}(k)$。一个常用（有偏）的自协方差估计量是 $\\hat{\\gamma}(k) = \\frac{1}{N} \\sum_{t=1}^{N-k} x_t x_{t+k}$。样本 ACF 则是 $\\hat{\\rho}(k) = \\hat{\\gamma}(k) / \\hat{\\gamma}(0)$。$\\hat{\\gamma}(0)$ 就是 $\\{x_t\\}$ 的样本方差。\n\n利用估计的 ACF $\\hat{\\rho}(k)$，根据规定的公式和求和截断程序计算积分自相关时间 $\\tau_{\\mathrm{int}}$：\n$$\n\\tau_{\\mathrm{int}} = \\frac{1}{2} + \\sum_{k=1}^{k_{\\mathrm{max}}} \\hat{\\rho}(k)\n$$\n求和上限 $k_{\\mathrm{max}}$ 是通过找到第一个使 $\\hat{\\rho}(k) \\le 0$ 的延迟 $k  0$ 来确定的。如果对于 $k0$ 的所有 $\\hat{\\rho}(k)$ 都是正的，则求和继续，直到 $\\hat{\\rho}(k)$ 首次低于噪声水平阈值 $1/\\sqrt{N}$。如果从未越过此阈值，则求和将包括所有可用延迟，直到 $N-1$。\n在序列方差为零（即常数序列）的特殊情况下，$\\tau_{\\mathrm{int}}$ 定义为 $0$。\n\n**步骤 2：块大小 $B$ 的选择**\n块大小 $B$ 必须足够大，以确保块均值近似不相关，即 $B$ 应显著大于 $\\tau_{\\mathrm{int}}$。为此引入一个比例因子 $c$。块大小 $B$ 选择为：\n$$\nB = \\lceil c \\cdot \\tau_{\\mathrm{int}} \\rceil\n$$\n其中 $c=5$。此外，必须满足两个约束条件：块大小必须至少为 1 帧（$B \\ge 1$），并且必须至少有两个块（$M \\ge 2$），其中 $M = \\lfloor N/B \\rfloor$ 是块的数量。如果初始选择的 $B$ 导致 $M  2$，则将块大小调整为 $B = \\lfloor N/2 \\rfloor$，以保证对于任何长度为 $N \\ge 2$ 的序列都有 $M \\ge 2$。对于 $\\tau_{\\mathrm{int}}=0$ 的情况，$B$ 设置为 $1$。\n\n**步骤 3：标准误差估计**\n将长度为 $N$ 的原始时间序列划分为 $M = \\lfloor N/B \\rfloor$ 个长度为 $B$ 的不重叠块。任何不构成完整块的尾部数据点都将被丢弃。\n对于每个块 $j \\in \\{1, \\dots, M\\}$，计算块均值 $\\bar{r}_{\\text{block}, j}$：\n$$\n\\bar{r}_{\\text{block}, j} = \\frac{1}{B} \\sum_{i=1}^{B} r_{(j-1)B + i}\n$$\n这将产生一个新的、较小的块均值时间序列 $\\{\\bar{r}_{\\text{block}, j}\\}_{j=1}^M$。由于这些块均值被假定为近似独立的，因此可以计算其均值的标准误差。块均值的无偏样本方差为：\n$$\n\\hat{\\sigma}^2_{\\text{blocks}} = \\frac{1}{M-1} \\sum_{j=1}^{M} (\\bar{r}_{\\text{block}, j} - \\bar{\\bar{r}}_{\\text{block}})^2\n$$\n其中 $\\bar{\\bar{r}}_{\\text{block}}$ 是块均值的均值。块均值的均值的方差的平方根给出了原始序列均值标准误差 (SEM) 的最终估计值：\n$$\n\\text{SEM} = \\sqrt{\\frac{\\hat{\\sigma}^2_{\\text{blocks}}}{M}}\n$$\n该程序应用于指定的四个测试用例，涉及从白噪声、自回归过程和常数序列生成合成的 RMSD 数据，以展示该方法在不同相关结构下的应用。所有最终的浮点值都报告到六位小数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the block analysis on specified test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1 (approximately uncorrelated): White noise\n        {'type': 'noise', 'N': 4096, 'mu': 2.0, 'sigma': 0.1, 'seed': 123},\n        # Case 2 (strongly autocorrelated): AR(1) process\n        {'type': 'ar1', 'N': 4096, 'mu': 2.0, 'phi': 0.9, 'sigma': 0.05, 'seed': 456},\n        # Case 3 (moderately autocorrelated and shorter): AR(1) process\n        {'type': 'ar1', 'N': 1024, 'mu': 3.0, 'phi': 0.5, 'sigma': 0.2, 'seed': 789},\n        # Case 4 (degenerate): Constant series\n        {'type': 'const', 'N': 128, 'mu': 1.5}\n    ]\n\n    results = []\n    for params in test_cases:\n        # Generate the time series data for the current case\n        N = params['N']\n        mu = params['mu']\n        rng = np.random.default_rng(params.get('seed'))\n\n        if params['type'] == 'noise':\n            sigma = params['sigma']\n            r = mu + sigma * rng.normal(size=N)\n        elif params['type'] == 'ar1':\n            phi = params['phi']\n            sigma = params['sigma']\n            r = np.zeros(N)\n            r[0] = mu\n            innovations = sigma * rng.normal(size=N)\n            for t in range(1, N):\n                r[t] = mu + phi * (r[t-1] - mu) + innovations[t]\n        elif params['type'] == 'const':\n            r = np.full(N, mu)\n        \n        # --- Start of analysis algorithm ---\n\n        # 1. Center the series and compute variance\n        r_mean = np.mean(r)\n        x = r - r_mean\n        r_var = np.var(x)\n\n        if r_var == 0:\n            tau_int = 0.0\n        else:\n            # Compute normalized autocorrelation function (ACF)\n            # np.correlate with 'full' gives unnormalized autocovariance sequence\n            # The second half (from N-1) corresponds to non-negative lags\n            autocov = np.correlate(x, x, mode='full')[N-1:]\n            acf = autocov / autocov[0]\n            \n            # Estimate integrated autocorrelation time (tau_int)\n            # Sum ACF until it becomes non-positive\n            positive_acf_indices = np.where(acf[1:] = 0)[0]\n            if positive_acf_indices.size > 0:\n                k_max = positive_acf_indices[0] + 1\n            else:\n                # If ACF is always positive, sum until it's below a threshold\n                threshold = 1 / np.sqrt(N)\n                threshold_indices = np.where(acf[1:]  threshold)[0]\n                if threshold_indices.size > 0:\n                    k_max = threshold_indices[0] + 1\n                else:\n                    # If still not found, sum over all available lags\n                    k_max = N - 1\n            \n            # The sum includes lags from 1 to k_max\n            tau_int = 0.5 + np.sum(acf[1:k_max + 1])\n\n        # 2. Choose the block size B\n        if tau_int == 0:\n            B = 1\n        else:\n            c = 5.0\n            B = int(np.ceil(c * tau_int))\n            B = max(1, B) # Ensure B is at least 1\n            \n            # Ensure at least two blocks exist\n            if N // B  2:\n                B = N // 2\n        \n        # 3. Compute block means and standard error\n        if N  2: # Cannot form blocks\n            M = 0\n            sem = np.nan\n        else:\n            M = N // B\n            \n        if M  2: # Handle cases that slip through, although logic for B should prevent this\n            sem = np.nan\n        else:\n            # Truncate series to fit an integer number of blocks\n            r_truncated = r[:M * B]\n            # Reshape into blocks and compute means\n            blocks = r_truncated.reshape((M, B))\n            block_means = np.mean(blocks, axis=1)\n            \n            # Compute SEM from block means\n            # Unbiased sample variance of block means (ddof=1)\n            if M > 1:\n                var_block_means = np.var(block_means, ddof=1)\n                sem = np.sqrt(var_block_means / M)\n            else: # Should not happen with M>=2 guarantee\n                sem = 0.0\n        \n        if r_var == 0:\n           sem = 0.0 # For constant series, SEM is exactly 0.\n\n        results.append([tau_int, B, sem])\n\n    # 4. Format and print the final output\n    case_strings = []\n    for res in results:\n        tau_str = f\"{res[0]:.6f}\"\n        b_str = str(res[1])\n        sem_str = f\"{res[2]:.6f}\"\n        case_strings.append(f\"[{tau_str},{b_str},{sem_str}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```"
        }
    ]
}