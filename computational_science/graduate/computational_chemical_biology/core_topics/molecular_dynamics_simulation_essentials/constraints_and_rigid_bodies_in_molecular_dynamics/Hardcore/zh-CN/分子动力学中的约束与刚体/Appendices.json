{
    "hands_on_practices": [
        {
            "introduction": "在分子动力学模拟中，为了使用更大的时间步长以探索更长的时间尺度，我们常常需要约束系统中最高频的运动，例如共价键的伸缩。SHAKE算法是一种经典且广泛应用的迭代方法，它在每个积分步骤之后校正原子位置，以精确满足这些几何约束。通过这个实践练习，你将从第一性原理出发，为双原子系统实现单次SHAKE迭代，从而深入理解约束算法的核心机制。",
            "id": "3840876",
            "problem": "考虑分子动力学 (MD) 中的一个双原子完整约束，其中在标记为 $i$ 和 $j$ 的原子之间施加了一个单键长约束。设期望键长为 $L_0$（单位为纳米，nm），无约束积分步后的当前位置为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$（单位为纳米，nm），原子质量为 $m_i$ 和 $m_j$（单位为道尔顿，Da）。该完整约束可写为 $g(\\mathbf{r}) = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 - L_0^2 = 0$。假设应用了通常称为 SHAKE 的迭代约束算法的单次迭代，该迭代使用关于当前位置的约束的一阶线性化以及沿键方向的质量加权校正。\n\n从适用于约束动力学的第一性原理出发，为单次 SHAKE 迭代推导沿瞬时键方向的质量加权位置校正 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$，该迭代试图满足一阶线性化约束。您的推导必须从牛顿第二定律和应用于完整约束的拉格朗日乘子法开始。不要使用任何预先给定的快捷公式；仅使用基本定律和核心定义来证明每一步。\n\n实现一个完整、可运行的程序，该程序：\n- 为每个测试用例计算单次 SHAKE 迭代的位置校正 $(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j)$。\n- 使用数值保护措施：如果 $\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 \\le \\tau$，其中 $\\tau$ 是一个小阈值，则返回零校正。使用 $\\tau = 1\\times 10^{-12}$ 平方纳米 (nm$^2$)。\n- 以纳米 (nm) 为单位返回校正值。\n\n您的程序必须评估以下测试套件，其中每个测试用例的位置和键长以纳米 (nm) 表示，质量以道尔顿 (Da) 表示：\n- 测试用例 1 (正常路径)：$\\mathbf{r}_i = (0.0, 0.0, 0.0)$，$\\mathbf{r}_j = (0.1, 0.0, 0.0)$，$L_0 = 0.12$，$m_i = 12.0$，$m_j = 1.0$。\n- 测试用例 2 (近简并键矢量)：$\\mathbf{r}_i = (0.0, 0.0, 0.0)$，$\\mathbf{r}_j = (1\\times 10^{-6}, 0.0, 0.0)$，$L_0 = 0.10$，$m_i = 16.0$，$m_j = 16.0$。\n- 测试用例 3 (平衡质量，离轴键)：$\\mathbf{r}_i = (0.0, 0.0, 0.0)$，$\\mathbf{r}_j = (0.15, 0.15, 0.0)$，$L_0 = 0.21$，$m_i = 12.0$，$m_j = 12.0$。\n- 测试用例 4 (高质量比)：$\\mathbf{r}_i = (0.2, -0.1, 0.05)$，$\\mathbf{r}_j = (0.25, -0.15, 0.05)$，$L_0 = 0.08$，$m_i = 200.0$，$m_j = 2.0$。\n- 测试用例 5 (已满足约束)：$\\mathbf{r}_i = (0.0, 0.0, 0.0)$，$\\mathbf{r}_j = (0.12, 0.0, 0.0)$，$L_0 = 0.12$，$m_i = 12.0$，$m_j = 1.0$。\n\n此问题不需要角度单位。所有输出必须以纳米 (nm) 表示。对于每个测试用例，输出与串联的校正向量 $[\\delta r_{i,x}, \\delta r_{i,y}, \\delta r_{i,z}, \\delta r_{j,x}, \\delta r_{j,y}, \\delta r_{j,z}]$ 相对应的六个浮点值。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个如上指定的包含六个浮点数的列表（例如：\"[[...六个浮点数...],[...六个浮点数...],...]\"）。",
            "solution": "该问题是有效的，因为它在经典力学中有科学依据，是适定的、客观的，并包含一个完整且一致的设置。它描述了计算化学生物学中的一个标准程序——SHAKE算法，并要求从第一性原理进行推导，然后进行具体实现。\n\n### SHAKE校正的推导\n\n我们从约束力学系统的拉格朗日表述开始。对于一组坐标为 $\\{\\mathbf{r}_k\\}$、质量为 $\\{m_k\\}$ 并受一组完整约束 $\\{g_\\alpha(\\mathbf{r}) = 0\\}$ 的粒子，其运动方程由第一类拉格朗日方程给出：\n$$\nm_k \\ddot{\\mathbf{r}}_k = \\mathbf{F}_k - \\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha(\\mathbf{r})\n$$\n其中 $\\mathbf{F}_k$ 是作用在粒子 $k$ 上的无约束力（例如，来自势能函数），$\\lambda_\\alpha$ 是与约束 $g_\\alpha$ 相关的拉格朗日乘子，$\\nabla_k$ 表示关于坐标 $\\mathbf{r}_k$ 的梯度。项 $-\\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha$ 是作用在粒子 $k$ 上的总约束力 $\\mathbf{F}'_k$。\n\n在像 Verlet 这样的算法的分子动力学模拟中，时间 $t+\\Delta t$ 时的位置是根据先前时间的位置计算的。令 $\\mathbf{r}'_k$ 表示粒子 $k$ 在无约束积分步后在时间 $t+\\Delta t$ 的位置。通常情况下，这些位置不满足约束。SHAKE 算法为每个原子计算一个校正 $\\delta \\mathbf{r}_k$，使得新的、校正后的位置 $\\mathbf{r}^{corr}_k = \\mathbf{r}'_k + \\delta \\mathbf{r}_k$ 确实满足约束。校正 $\\delta \\mathbf{r}_k$ 被假定源于在时间步长上积分的约束力，其形式为：\n$$\n\\delta \\mathbf{r}_k = \\frac{(\\Delta t)^2}{m_k} \\mathbf{F}'_k\n$$\n对于单个约束 $g(\\mathbf{r})=0$，约束力为 $\\mathbf{F}'_k = -\\lambda\\nabla_k g(\\mathbf{r})$。可以通过将常数和 $\\Delta t$ 吸收到一个新的乘子中来简化该公式，为简单起见，我们仍称其为 $\\lambda$。这引出了校正的标准拟设：\n$$\n\\delta \\mathbf{r}_k = \\lambda \\frac{1}{m_k} \\nabla_k g(\\mathbf{r})\n$$\n问题指定了原子 $i$ 和 $j$ 之间的单个键长约束，定义为：\n$$\ng(\\mathbf{r}_i, \\mathbf{r}_j) = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 - L_0^2 = 0\n$$\n其中 $L_0$ 是期望的键长。我们相对于无约束位置计算梯度，为与问题的符号匹配，我们将其记为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$。令连接原子的向量为 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。梯度为：\n$$\n\\nabla_i g = \\frac{\\partial}{\\partial \\mathbf{r}_i}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (-I) = -2\\mathbf{r}_{ij}\n$$\n$$\n\\nabla_j g = \\frac{\\partial}{\\partial \\mathbf{r}_j}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (I) = 2\\mathbf{r}_{ij}\n$$\n因此，位置校正为：\n$$\n\\delta \\mathbf{r}_i = \\lambda \\frac{1}{m_i} \\nabla_i g = -2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\n$$\n\\delta \\mathbf{r}_j = \\lambda \\frac{1}{m_j} \\nabla_j g = 2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\n未知的拉格朗日乘子 $\\lambda$ 是通过要求校正后的位置 $\\mathbf{r}^{corr}_i = \\mathbf{r}_i + \\delta\\mathbf{r}_i$ 和 $\\mathbf{r}^{corr}_j = \\mathbf{r}_j + \\delta\\mathbf{r}_j$ 满足约束来确定的。SHAKE 算法将此要求线性化。在校正后位置处求值的约束函数在无约束位置周围展开到一阶：\n$$\ng(\\mathbf{r}^{corr}) \\approx g(\\mathbf{r}) + (\\delta\\mathbf{r}_i \\cdot \\nabla_i g + \\delta\\mathbf{r}_j \\cdot \\nabla_j g) = 0\n$$\n代入梯度和校正的表达式：\n$$\ng(\\mathbf{r}) + \\left( (-2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}) \\cdot (-2\\mathbf{r}_{ij}) + (2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}) \\cdot (2\\mathbf{r}_{ij}) \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + \\lambda \\left( \\frac{4}{m_i} \\lVert \\mathbf{r}_{ij} \\rVert^2 + \\frac{4}{m_j} \\lVert \\mathbf{r}_{ij} \\rVert^2 \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + 4\\lambda \\lVert \\mathbf{r}_{ij} \\rVert^2 \\left( \\frac{1}{m_i} + \\frac{1}{m_j} \\right) = 0\n$$\n令 $d^2 = \\lVert \\mathbf{r}_{ij} \\rVert^2$。在无约束位置处的约束违背量是 $g(\\mathbf{r}) = d^2 - L_0^2$。我们现在可以解出 $\\lambda$：\n$$\n\\lambda = -\\frac{g(\\mathbf{r})}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = -\\frac{d^2 - L_0^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})}\n$$\n现在，将这个 $\\lambda$ 的表达式代回 $\\delta\\mathbf{r}_i$ 和 $\\delta\\mathbf{r}_j$ 的方程中：\n对于原子 $i$：\n$$\n\\delta\\mathbf{r}_i = -2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_i} \\mathbf{r}_{ij} = \\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\n项 $\\frac{1}{m_i (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{1}{m_i (\\frac{m_j+m_i}{m_i m_j})} = \\frac{m_j}{m_i+m_j}$。因此：\n$$\n\\delta\\mathbf{r}_i = \\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_j}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\n对于原子 $j$：\n$$\n\\delta\\mathbf{r}_j = 2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_j} \\mathbf{r}_{ij} = -\\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\n项 $\\frac{1}{m_j (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{m_i}{m_i+m_j}$。因此：\n$$\n\\delta\\mathbf{r}_j = -\\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_i}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\n这些是位置校正的最终表达式。它们是质量加权的（一个原子的校正与另一个原子的质量成正比）并且如要求的那样沿着原子间向量 $\\mathbf{r}_{ij}$ 的方向。为了便于实现，我们可以定义一个公共标量因子来简化计算：\n$$\nk = \\frac{d^2 - L_0^2}{2 d^2 (m_i + m_j)}\n$$\n那么校正变为：\n$$\n\\delta\\mathbf{r}_i = k \\cdot m_j \\cdot \\mathbf{r}_{ij}\n$$\n$$\n\\delta\\mathbf{r}_j = -k \\cdot m_i \\cdot \\mathbf{r}_{ij}\n$$\n这种形式计算效率高。当 $d^2$ 非常小时，需要采取数值保护措施，以防止除以零或浮点溢出。如果对于某个小阈值 $\\tau$ 有 $d^2 \\le \\tau$，则校正设为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a single SHAKE iteration position correction for a two-atom system.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each case: (r_i (nm), r_j (nm), L0 (nm), m_i (Da), m_j (Da))\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([0.1, 0.0, 0.0]), 0.12, 12.0, 1.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([1e-6, 0.0, 0.0]), 0.10, 16.0, 16.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.15, 0.15, 0.0]), 0.21, 12.0, 12.0),\n        (np.array([0.2, -0.1, 0.05]), np.array([0.25, -0.15, 0.05]), 0.08, 200.0, 2.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.12, 0.0, 0.0]), 0.12, 12.0, 1.0),\n    ]\n\n    # Numerical safeguard threshold in nm^2\n    tau = 1.0e-12\n\n    results = []\n\n    for case in test_cases:\n        r_i, r_j, L0, m_i, m_j = case\n\n        # Calculate the inter-atomic vector\n        r_ij = r_j - r_i\n\n        # Calculate the squared distance\n        d_sq = np.dot(r_ij, r_ij)\n\n        # Apply numerical safeguard\n        if d_sq = tau:\n            delta_ri = np.array([0.0, 0.0, 0.0])\n            delta_rj = np.array([0.0, 0.0, 0.0])\n        else:\n            # Calculate the constraint violation function, g = d^2 - L0^2\n            g_val = d_sq - L0**2\n\n            # If the constraint is already satisfied, corrections are zero.\n            if np.isclose(g_val, 0.0):\n                delta_ri = np.array([0.0, 0.0, 0.0])\n                delta_rj = np.array([0.0, 0.0, 0.0])\n            else:\n                # Calculate the common scalar factor k = (d^2 - L0^2) / (2 * d^2 * (m_i + m_j))\n                total_mass = m_i + m_j\n                scalar_k = g_val / (2.0 * d_sq * total_mass)\n\n                # Calculate the mass-weighted corrections\n                delta_ri = scalar_k * m_j * r_ij\n                delta_rj = -scalar_k * m_i * r_ij\n\n        # Concatenate corrections into a single vector and convert to list for output\n        full_correction = np.concatenate((delta_ri, delta_rj)).tolist()\n        results.append(full_correction)\n\n    # Format the final output string as specified\n    # Example: [[...six floats...],[...six floats...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "当系统包含多个相互关联的约束（如键长和键角）时，像SHAKE这样的简单迭代需要被推广。约束雅可比矩阵（constraint Jacobian）是这一推广过程中的核心数学工具，它不仅为计算约束力提供了理论基础，还能用于分析约束之间是否线性无关。在这个练习中，你将为一个包含混合约束的小分子构建雅可比矩阵，并通过计算其秩来判断约束在不同构象下的独立性，这对于保证约束求解过程的稳定性和唯一性至关重要。",
            "id": "3840917",
            "problem": "给定一个由原子 $0,1,2,3$ 索引的小型四原子分子，其笛卡尔坐标为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，其中 $i \\in \\{0,1,2,3\\}$。在约束分子动力学 (MD) 中，完整约束被写为广义坐标 $\\mathbf{q} \\in \\mathbb{R}^{3N}$ 的标量函数 $\\phi_k(\\mathbf{q}) = 0$，其中 $N$ 是原子数，且 $\\mathbf{q} = (\\mathbf{r}_0,\\mathbf{r}_1,\\ldots,\\mathbf{r}_{N-1})$。约束的雅可比矩阵是矩阵 $G(\\mathbf{q}) \\in \\mathbb{R}^{m \\times 3N}$，其元素为 $G_{k,\\alpha}(\\mathbf{q}) = \\frac{\\partial \\phi_k(\\mathbf{q})}{\\partial q_\\alpha}$，其中 $m$ 是约束的数量。在构型 $\\mathbf{q}$ 处，约束的独立性由 $G(\\mathbf{q})$ 的秩是否等于 $m$ 来确定。\n\n请为以下 $N=4$ 原子分子的 $m=5$ 个约束实现雅可比矩阵 $G$：\n- 键长（平方）约束：原子对 $(0,1)$、$(1,2)$ 和 $(2,3)$ 具有固定的键长平方。每个键长约束定义为 $\\phi_{\\text{bond}}(\\mathbf{r}_i,\\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2$，其中 $d_{ij}$ 是目标键长。使用目标键长 $d_{01} = d_{12} = d_{23} = 1.54$ 埃。输出不需要单位，但内都几何结构使用以埃为单位的坐标。\n- 键角约束：由原子 $(0,1,2)$ 在原子 $1$ 处形成的角，以及由原子 $(1,2,3)$ 在原子 $2$ 处形成的角。每个键角约束通过角的余弦定义，$\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^{0})$，其中 $\\theta_{ijk}$ 是在顶点 $j$ 处，向量 $\\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{r}_k - \\mathbf{r}_j$ 之间的夹角。使用目标角度 $\\theta_{012}^{0} = 1.911$ 和 $\\theta_{123}^{0} = 1.911$ 弧度。本问题中所有角度必须以弧度为单位。\n\n从上述定义以及经典力学（牛顿定律）和几何学的基本定律出发，计算每个给定构型的雅可比矩阵 $G(\\mathbf{q})$。除了基本的向量微积分恒等式和角的余弦定义外，您不能假设任何预先推导出的公式。约束的独立性通过 $G(\\mathbf{q})$ 的数值秩（使用奇异值分解 (SVD) 计算）来评估。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n1. 对于下面测试套件中的每个构型，构建所述约束的雅可比矩阵 $G(\\mathbf{q})$。\n2. 使用 SVD 计算每个构型下 $G(\\mathbf{q})$ 的数值秩。\n3. 生成一行输出，包含所有测试用例的秩，形式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,\\ldots,r_T]$，其中每个 $r_t$ 是测试用例 $t$ 的整数秩。\n\n使用以下测试构型套件（坐标单位为埃）：\n- 测试用例 1：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.50, 0.10, -0.20)$，$\\mathbf{r}_2 = (2.80, -0.30, 0.50)$，$\\mathbf{r}_3 = (4.00, 0.00, -0.40)$。\n- 测试用例 2：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.00, 0.00)$，$\\mathbf{r}_2 = (2.10, 0.05, 0.00)$，$\\mathbf{r}_3 = (3.20, -0.10, 0.00)$。\n- 测试用例 3：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.00, 0.00)$，$\\mathbf{r}_2 = (2.00, 0.00, 0.00)$，$\\mathbf{r}_3 = (3.00, 0.00, 0.00)$。\n- 测试用例 4：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.90, -0.30)$，$\\mathbf{r}_2 = (2.00, 2.00, 0.10)$，$\\mathbf{r}_3 = (3.00, 2.80, -0.20)$。\n- 测试用例 5：$\\mathbf{r}_0 = (0.10, -0.20, 0.00)$，$\\mathbf{r}_1 = (1.20, 0.30, -0.50)$，$\\mathbf{r}_2 = (2.40, 0.10, 0.40)$，$\\mathbf{r}_3 = (3.60, -0.20, 0.10)$。\n- 测试用例 6：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 1.00, 0.00)$，$\\mathbf{r}_2 = (1.50, 2.50, 0.00)$，$\\mathbf{r}_3 = (1.80, 4.00, 0.10)$。\n\n覆盖性设计：\n- 一般情况（1, 4, 5, 6）是非简并构象，如果约束是独立的，预计会表现出满秩。\n- 近共线情况（2）探测几乎相关的键角约束的数值稳定性。\n- 精确共线情况（3）是一个边界情况，其中键角约束可能变得奇异，测试秩亏。\n\n最终输出格式要求：\n- 您的程序应生成一行输出，包含六个测试用例的秩，格式为方括号内以逗号分隔的列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是一个整数。",
            "solution": "该问题是计算施加在一组 $N=4$ 个原子上的 $m=5$ 个几何约束的雅可比矩阵 $G(\\mathbf{q})$，然后确定其数值秩。广义坐标向量 $\\mathbf{q}$ 是所有原子笛卡尔坐标的串联：$\\mathbf{q} = (\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3) \\in \\mathbb{R}^{12}$。雅可比矩阵 $G(\\mathbf{q})$ 是一个 $m \\times 3N$ 的矩阵，此处为 $5 \\times 12$，其中每一行包含一个约束函数相对于 $\\mathbf{q}$ 的梯度。\n\n约束如下：\n$1$. 键 $(0,1)$: $\\phi_1 = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2 = 0$\n$2$. 键 $(1,2)$: $\\phi_2 = \\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - d_{12}^2 = 0$\n$3$. 键 $(2,3)$: $\\phi_3 = \\|\\mathbf{r}_2 - \\mathbf{r}_3\\|^2 - d_{23}^2 = 0$\n$4$. 角 $(0,1,2)$: $\\phi_4 = \\cos(\\theta_{012}) - \\cos(\\theta_{012}^{0}) = 0$\n$5$. 角 $(1,2,3)$: $\\phi_5 = \\cos(\\theta_{123}) - \\cos(\\theta_{123}^{0}) = 0$\n\n我们必须推导每个约束的梯度向量。梯度 $\\nabla_{\\mathbf{q}} \\phi_k$ 构成了雅可比矩阵 $G$ 的第 $k$ 行。这个梯度是一个12维向量，由相对于每个坐标分量的偏导数组成。我们可以更紧凑地将其表示为相对于每个原子位置向量 $\\mathbf{r}_i$ 的三维梯度集合 $\\nabla_{\\mathbf{r}_i} \\phi_k$。\n\n**1. 键长约束的雅可比矩阵**\n对于原子 $i$ 和 $j$ 之间的一般键长约束，$\\phi_{\\text{bond}}(\\mathbf{r}_i, \\mathbf{r}_j) = (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) - d_{ij}^2 = 0$。令 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。相对于原子位置的导数为：\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_i} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n$$\n\\nabla_{\\mathbf{r}_j} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_j} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} \\cdot \\frac{\\partial \\mathbf{r}_{ij}}{\\partial \\mathbf{r}_j} = 2(\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (-\\mathbf{I}) = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。对于任何未参与该键的原子 $k$ ($k \\neq i, j$)，梯度为零：$\\nabla_{\\mathbf{r}_k} \\phi_{\\text{bond}} = \\mathbf{0}$。\n雅可比矩阵 $G$ 的前三行分别由键 $(0,1)$、$(1,2)$ 和 $(2,3)$ 的这些梯度填充。例如，对于 $\\phi_1$（键0-1），梯度为 $\\nabla_{\\mathbf{r}_0} \\phi_1 = 2(\\mathbf{r}_0 - \\mathbf{r}_1)$，$\\nabla_{\\mathbf{r}_1} \\phi_1 = -2(\\mathbf{r}_0 - \\mathbf{r}_1)$，以及 $\\nabla_{\\mathbf{r}_2} \\phi_1 = \\nabla_{\\mathbf{r}_3} \\phi_1 = \\mathbf{0}$。\n\n**2. 键角约束的雅可比矩阵**\n对于一般的键角约束 $\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^0) = 0$，我们需要求 $\\cos(\\theta_{ijk})$ 相对于 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$ 的梯度。\n令 $\\mathbf{u} = \\mathbf{r}_i - \\mathbf{r}_j$ 且 $\\mathbf{v} = \\mathbf{r}_k - \\mathbf{r}_j$。角的余弦由单位向量的点积给出：\n$$\n\\cos(\\theta_{ijk}) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|} = \\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}}\n$$\n因为 $\\cos(\\theta_{ijk}^0)$ 是一个常数，其导数为零。我们计算 $\\cos(\\theta_{ijk})$ 相对于每个原子位置向量的梯度。\n\n相对于 $\\mathbf{r}_i$ 的梯度：\n只有向量 $\\mathbf{u}$ 依赖于 $\\mathbf{r}_i$。使用链式法则和单位向量导数的恒等式 $(\\nabla_{\\mathbf{x}} \\hat{\\mathbf{x}}) = \\frac{1}{\\|\\mathbf{x}\\|} (\\mathbf{I} - \\hat{\\mathbf{x}}\\hat{\\mathbf{x}}^T)$，我们发现：\n$$\n\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{u}})^T \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T) \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - (\\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}})\\hat{\\mathbf{u}}) = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{u}})\n$$\n\n相对于 $\\mathbf{r}_k$ 的梯度：\n通过对称性，交换 $i$ 和 $k$ 的角色（因此也交换 $\\mathbf{u}$ 和 $\\mathbf{v}$）：\n$$\n\\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}) = \\frac{1}{\\|\\mathbf{v}\\|} (\\hat{\\mathbf{u}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{v}})\n$$\n相对于 $\\mathbf{r}_j$ 的梯度：\n键角约束函数仅依赖于原子的相对位置。它对于所有三个原子进行统一平移 $\\mathbf{r}_l \\to \\mathbf{r}_l + \\mathbf{c}$ 是不变的。这意味着所有相关原子的梯度之和必须为零：\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_j} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_k} \\phi_{\\text{ang}} = \\mathbf{0}\n$$\n因此，中心原子 $j$ 上的梯度可以计算为：\n$$\n\\nabla_{\\mathbf{r}_j} \\cos(\\theta_{ijk}) = -(\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) + \\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}))\n$$\n这种关系简化了计算并确保了数值稳健性。\n\n对于任何未参与该角的原子 $l$ ($l \\neq i, j, k$)，梯度为零：$\\nabla_{\\mathbf{r}_l} \\phi_{\\text{ang}} = \\mathbf{0}$。\n这些梯度填充了雅可比矩阵的第 4 行和第 5 行，分别对应角 $(0,1,2)$ 和 $(1,2,3)$。\n\n当原子 $i,j,k$ 共线时，会出现一个关键的特殊情况。此时，$\\hat{\\mathbf{u}} = \\pm \\hat{\\mathbf{v}}$ 且 $\\cos(\\theta_{ijk}) = \\pm 1$。梯度表达式变为：\n$\\nabla_{\\mathbf{r}_i} = \\frac{1}{\\|\\mathbf{u}\\|}(\\pm \\hat{\\mathbf{u}} - (\\pm 1)\\hat{\\mathbf{u}}) = \\mathbf{0}$。类似地，$\\nabla_{\\mathbf{r}_k} = \\mathbf{0}$，因此 $\\nabla_{\\mathbf{r}_j} = \\mathbf{0}$。对应于共线角约束的雅可比矩阵的整行都将变为零，从而降低矩阵的秩。\n\n**3. 雅可比矩阵的构建和秩的计算**\n完整的雅可比矩阵 $G$ 是一个 $5 \\times 12$ 的矩阵。每一行 $k$ 是通过串联该约束的 $3D$ 梯度形成的：\n$$\nG_k = [\\nabla_{\\mathbf{r}_0} \\phi_k, \\nabla_{\\mathbf{r}_1} \\phi_k, \\nabla_{\\mathbf{r}_2} \\phi_k, \\nabla_{\\mathbf{r}_3} \\phi_k]\n$$\n约束的独立性由 $G$ 的数值秩决定。秩通过奇异值分解（SVD）计算。显著大于机器精度的奇异值的数量决定了秩。\n\n算法如下：\n1. 对于每个测试用例构型 $(\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3)$：\n2. 构建 $5 \\times 12$ 的雅可比矩阵 $G$。\n3. 对于 $m=3$ 个键长约束中的每一个，计算 $3D$ 梯度并将其放入 $G$ 的相应行和列中。\n4. 对于 $m=2$ 个键角约束中的每一个，计算 $3D$ 梯度并将其放入 $G$ 的相应行和列中。\n5. 计算得到的矩阵 $G$ 的数值秩。\n最终输出是所有测试用例的这些秩的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_jacobian_and_rank(positions):\n    \"\"\"\n    Computes the constraint Jacobian and its rank for a 4-atom molecule.\n\n    Args:\n        positions (list of np.ndarray): A list of 4 numpy arrays, where each\n                                        array is the 3D Cartesian coordinate\n                                        vector of an atom.\n\n    Returns:\n        int: The numerical rank of the 5x12 Jacobian matrix.\n    \"\"\"\n    num_atoms = 4\n    num_constraints = 5\n    \n    # The Jacobian G is an m x 3N matrix, here 5 x 12.\n    G = np.zeros((num_constraints, 3 * num_atoms))\n    \n    r = positions\n    \n    # 1. Bond (0,1) constraint: phi_1 = ||r0 - r1||^2 - d01^2\n    r01 = r[0] - r[1]\n    grad_r0_phi1 = 2 * r01\n    grad_r1_phi1 = -2 * r01\n    G[0, 0:3] = grad_r0_phi1\n    G[0, 3:6] = grad_r1_phi1\n    \n    # 2. Bond (1,2) constraint: phi_2 = ||r1 - r2||^2 - d12^2\n    r12 = r[1] - r[2]\n    grad_r1_phi2 = 2 * r12\n    grad_r2_phi2 = -2 * r12\n    G[1, 3:6] = grad_r1_phi2\n    G[1, 6:9] = grad_r2_phi2\n    \n    # 3. Bond (2,3) constraint: phi_3 = ||r2 - r3||^2 - d23^2\n    r23 = r[2] - r[3]\n    grad_r2_phi3 = 2 * r23\n    grad_r3_phi3 = -2 * r23\n    G[2, 6:9] = grad_r2_phi3\n    G[2, 9:12] = grad_r3_phi3\n\n    # 4. Angle (0,1,2) constraint: phi_4 = cos(theta_012) - cos(theta_012^0)\n    # Define vectors from central atom 1: u = r0-r1, v = r2-r1\n    u_012 = r[0] - r[1]\n    v_012 = r[2] - r[1]\n    \n    norm_u_012 = np.linalg.norm(u_012)\n    norm_v_012 = np.linalg.norm(v_012)\n    \n    # Check for collinearity/zero length vectors\n    if norm_u_012 > 1e-9 and norm_v_012 > 1e-9:\n        u_hat_012 = u_012 / norm_u_012\n        v_hat_012 = v_012 / norm_v_012\n        cos_theta_012 = np.dot(u_hat_012, v_hat_012)\n\n        grad_r0_phi4 = (1 / norm_u_012) * (v_hat_012 - cos_theta_012 * u_hat_012)\n        grad_r2_phi4 = (1 / norm_v_012) * (u_hat_012 - cos_theta_012 * v_hat_012)\n        grad_r1_phi4 = -(grad_r0_phi4 + grad_r2_phi4)\n\n        G[3, 0:3] = grad_r0_phi4\n        G[3, 3:6] = grad_r1_phi4\n        G[3, 6:9] = grad_r2_phi4\n    # If vectors are of zero length or collinear, the gradient is zero, and the row remains zero.\n\n    # 5. Angle (1,2,3) constraint: phi_5 = cos(theta_123) - cos(theta_123^0)\n    # Define vectors from central atom 2: u = r1-r2, v = r3-r2\n    u_123 = r[1] - r[2]\n    v_123 = r[3] - r[2]\n\n    norm_u_123 = np.linalg.norm(u_123)\n    norm_v_123 = np.linalg.norm(v_123)\n\n    if norm_u_123 > 1e-9 and norm_v_123 > 1e-9:\n        u_hat_123 = u_123 / norm_u_123\n        v_hat_123 = v_123 / norm_v_123\n        cos_theta_123 = np.dot(u_hat_123, v_hat_123)\n        \n        grad_r1_phi5 = (1 / norm_u_123) * (v_hat_123 - cos_theta_123 * u_hat_123)\n        grad_r3_phi5 = (1 / norm_v_123) * (u_hat_123 - cos_theta_123 * v_hat_123)\n        grad_r2_phi5 = -(grad_r1_phi5 + grad_r3_phi5)\n        \n        G[4, 3:6] = grad_r1_phi5\n        G[4, 6:9] = grad_r2_phi5\n        G[4, 9:12] = grad_r3_phi5\n\n    # Compute numerical rank using SVD\n    return np.linalg.matrix_rank(G)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [np.array([0.00, 0.00, 0.00]), np.array([1.50, 0.10, -0.20]), \n         np.array([2.80, -0.30, 0.50]), np.array([4.00, 0.00, -0.40])],\n        # Test case 2\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.10, 0.05, 0.00]), np.array([3.20, -0.10, 0.00])],\n        # Test case 3\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.00, 0.00, 0.00]), np.array([3.00, 0.00, 0.00])],\n        # Test case 4\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.90, -0.30]), \n         np.array([2.00, 2.00, 0.10]), np.array([3.00, 2.80, -0.20])],\n        # Test case 5\n        [np.array([0.10, -0.20, 0.00]), np.array([1.20, 0.30, -0.50]), \n         np.array([2.40, 0.10, 0.40]), np.array([3.60, -0.20, 0.10])],\n        # Test case 6\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 1.00, 0.00]), \n         np.array([1.50, 2.50, 0.00]), np.array([1.80, 4.00, 0.10])],\n    ]\n\n    results = []\n    for positions in test_cases:\n        rank = compute_jacobian_and_rank(positions)\n        results.append(rank)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "除了约束单个键长和键角，另一种提高计算效率的强大策略是将分子的特定部分（如芳香环）或整个小分子视为一个整体的刚体。这种处理方式消除了所有内部自由度，但要求我们用新的数学语言来描述物体的空间取向和旋转。四元数（Quaternions）提供了一种在计算上稳定且高效的方式来表示三维旋转，避免了欧拉角等表示法可能遇到的奇异性问题（万向锁）。这个练习将让你掌握如何将四元数表示转换为更直观的旋转矩阵，并用它来计算刚体上固定点在实验室坐标系中的位置。",
            "id": "3840920",
            "problem": "考虑一个用于分子动力学（MD）模拟的刚性三原子片段，其具有保持内部距离和角度固定的完整约束。该刚体的取向由单位四元数 $q = (q_{0}, q_{1}, q_{2}, q_{3})$ 表示，其中标量部分为 $q_{0}$，矢量部分为 $(q_{1}, q_{2}, q_{3})$。在某个 MD 步骤中，该片段的取向由 $q = \\left(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}\\right)$ 给出。一个标记原子相对于质心的体固定坐标为 $r_{\\text{body}} = (0.12, -0.08, 0.05)$，单位为纳米。\n\n从适用于刚体动力学的第一性原理出发，包括单位四元数作为旋转算子的定义以及刚体运动保持距离的要求，推导与给定四元数 $q$ 对应的 $3 \\times 3$ 旋转矩阵 $R(q)$。解释对于一个任意矢量，从体固定坐标到空间固定坐标的映射是如何从该推导中产生的。然后，使用推导出的 $R(q)$ 计算该标记原子位置的空间固定笛卡尔 $\\hat{x}$ 分量。以纳米为单位表示最终的 $\\hat{x}$ 分量，并将您的答案四舍五入到四位有效数字。在最后一步之前，不允许进行任何中间数值的四舍五入。",
            "solution": "该问题陈述清晰且科学上合理，提供了确定唯一解所需的所有信息。我将继续进行推导和计算。\n\n三维空间中一个矢量的旋转可以用单位四元数表示。一个矢量 $\\mathbf{v} \\in \\mathbb{R}^3$ 被表示为一个纯四元数 $p_v = (0, v_1, v_2, v_3)$，其中标量部分为零。一个单位四元数由 $q = (q_0, q_1, q_2, q_3) = (q_0, \\mathbf{q})$ 给出，其中 $q_0$ 是标量部分，$\\mathbf{q}$ 是矢量部分。对于单位四元数，其范数为1：$q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$。给定的四元数 $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$ 满足此条件，因为 $(\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 = 4 \\times \\frac{1}{4} = 1$。\n\n通过四元数 $q$ 将矢量 $\\mathbf{v}$ 旋转到新矢量 $\\mathbf{v}'$ 的操作由“三明治”乘积定义：\n$$p_{v'} = q p_v q^{-1}$$\n对于单位四元数，其逆 $q^{-1}$ 等于其共轭 $q^* = (q_0, -\\mathbf{q})$。因此，该操作为：\n$$p_{v'} = q p_v q^*$$\n设体固定矢量为 $\\mathbf{r}_{\\text{body}} = (x_b, y_b, z_b)$，表示为纯四元数 $p_b = (0, \\mathbf{r}_{\\text{body}})$。得到的空间固定矢量 $\\mathbf{r}_{\\text{space}}$ 是纯四元数 $p_s = (0, \\mathbf{r}_{\\text{space}})$ 的矢量部分。\n\n我们首先计算乘积 $q p_b$。两个四元数 $(a_0, \\mathbf{a})$ 和 $(b_0, \\mathbf{b})$ 的乘积由 $(a_0 b_0 - \\mathbf{a} \\cdot \\mathbf{b}, a_0 \\mathbf{b} + b_0 \\mathbf{a} + \\mathbf{a} \\times \\mathbf{b})$ 给出。\n此处，$(a_0, \\mathbf{a}) = (q_0, \\mathbf{q})$ 且 $(b_0, \\mathbf{b}) = (0, \\mathbf{r}_{\\text{body}})$。\n$$q p_b = (q_0 \\cdot 0 - \\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + 0 \\cdot \\mathbf{q} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\n接下来，我们将此结果乘以 $q^* = (q_0, -\\mathbf{q})$。设中间乘积为 $(c_0, \\mathbf{c}) = q p_b$。\n$$p_s = (c_0, \\mathbf{c}) q^* = (c_0 q_0 - \\mathbf{c} \\cdot (-\\mathbf{q}), c_0(-\\mathbf{q}) + q_0 \\mathbf{c} + \\mathbf{c} \\times (-\\mathbf{q}))$$\n$p_s$ 的标量部分必须为零，这是该变换保持矢量空间的一个关键属性。\n标量部分 = $c_0 q_0 + \\mathbf{c} \\cdot \\mathbf{q} = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})q_0 + (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q} = -q_0(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) + q_0(\\mathbf{r}_{\\text{body}} \\cdot \\mathbf{q}) + (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q}$。\n前两项相互抵消，最后一项是包含两个相同矢量的标量三重积，其值为零。因此标量部分确实为 $0$。\n\n$p_s$ 的矢量部分，即 $\\mathbf{r}_{\\text{space}}$，为：\n$$\\mathbf{r}_{\\text{space}} = -c_0\\mathbf{q} + q_0 \\mathbf{c} - (\\mathbf{c} \\times \\mathbf{q})$$\n$$\\mathbf{r}_{\\text{space}} = -(-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0(q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}$$\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - q_0(\\mathbf{r}_{\\text{body}} \\times \\mathbf{q}) - ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q})$$\n使用 $\\mathbf{a} \\times \\mathbf{b} = -\\mathbf{b} \\times \\mathbf{a}$ 和矢量三重积恒等式 $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b}(\\mathbf{a} \\cdot \\mathbf{c}) - \\mathbf{c}(\\mathbf{a} \\cdot \\mathbf{b})$：\n$$- ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}) = \\mathbf{q} \\times (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}(\\mathbf{q} \\cdot \\mathbf{q})$$\n将此代回 $\\mathbf{r}_{\\text{space}}$ 的表达式中：\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) + \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}\\|\\mathbf{q}\\|^2$$\n$$\\mathbf{r}_{\\text{space}} = (q_0^2 - \\|\\mathbf{q}\\|^2)\\mathbf{r}_{\\text{body}} + 2(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\n该方程定义了线性变换 $\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}}$。矩阵 $R(q)$ 可以从该关系构建。使用 $q_0^2 + \\|\\mathbf{q}\\|^2 = 1$，我们可以写出 $q_0^2 - \\|\\mathbf{q}\\|^2 = q_0^2 - (1 - q_0^2) = 2q_0^2 - 1$。\n旋转矩阵 $R(q)$ 的分量是：\n$$R(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2)  2(q_1q_2 - q_0q_3)  2(q_1q_3 + q_0q_2) \\\\\n2(q_1q_2 + q_0q_3)  1 - 2(q_1^2 + q_3^2)  2(q_2q_3 - q_0q_1) \\\\\n2(q_1q_3 - q_0q_2)  2(q_2q_3 + q_0q_1)  1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}$$\n这个矩阵 $R(q)$ 将一个矢量的坐标从体固定坐标系映射到空间固定坐标系。\n\n我们已知 $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$，所以 $q_0=q_1=q_2=q_3=\\frac{1}{2}$。我们将这些值代入矩阵公式：\n$q_i^2 = (\\frac{1}{2})^2 = \\frac{1}{4}$ for $i=0,1,2,3$。\n$q_i q_j = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$ for any $i,j$。\n$R_{11} = 1 - 2(q_2^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$。\n$R_{12} = 2(q_1q_2 - q_0q_3) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$。\n$R_{13} = 2(q_1q_3 + q_0q_2) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$。\n$R_{21} = 2(q_1q_2 + q_0q_3) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$。\n$R_{22} = 1 - 2(q_1^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$。\n$R_{23} = 2(q_2q_3 - q_0q_1) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$。\n$R_{31} = 2(q_1q_3 - q_0q_2) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$。\n$R_{32} = 2(q_2q_3 + q_0q_1) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$。\n$R_{33} = 1 - 2(q_1^2 + q_2^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$。\n\n因此，给定四元数的旋转矩阵为：\n$$R(q) = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix}$$\n标记原子的体固定坐标为 $\\mathbf{r}_{\\text{body}} = (0.12, -0.08, 0.05)$ 纳米。为了找到空间固定坐标 $\\mathbf{r}_{\\text{space}}$，我们应用旋转矩阵：\n$$\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}} = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 0.12 \\\\ -0.08 \\\\ 0.05 \\end{pmatrix}$$\n执行矩阵-矢量乘法：\n$$\\mathbf{r}_{\\text{space}} = \\begin{pmatrix} (0)(0.12) + (0)(-0.08) + (1)(0.05) \\\\ (1)(0.12) + (0)(-0.08) + (0)(0.05) \\\\ (0)(0.12) + (1)(-0.08) + (0)(0.05) \\end{pmatrix} = \\begin{pmatrix} 0.05 \\\\ 0.12 \\\\ -0.08 \\end{pmatrix}$$\n空间固定坐标为 $(0.05, 0.12, -0.08)$ 纳米。问题要求该位置的笛卡尔 $\\hat{x}$ 分量，即矢量的第一个分量。\n$\\hat{x}$ 分量是 $0.05$ nm。\n最终答案必须表示为四位有效数字。为了将精确值 $0.05$ 表示为四位有效数字，我们将其写为 $0.05000$。小数点前的零和紧随其后的零不是有效数字；数字 $5$ 和三个尾随的零是有效数字。",
            "answer": "$$\\boxed{0.05000}$$"
        }
    ]
}