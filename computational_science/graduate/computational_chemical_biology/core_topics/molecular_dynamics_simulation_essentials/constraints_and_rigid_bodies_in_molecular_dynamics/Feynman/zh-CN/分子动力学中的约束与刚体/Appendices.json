{
    "hands_on_practices": [
        {
            "introduction": "第一个实践将让您深入了解约束算法的核心，我们将聚焦于基础的SHAKE算法。通过推导并实现一个简单的双原子系统的位置校正，您将弥合拉格朗日力学理论基础与实用代码实现之间的关键鸿沟()。这项练习对于具体理解在分子动力学模拟中几何约束是如何通过数值方法强制执行的至关重要。",
            "id": "3840876",
            "problem": "考虑分子动力学 (MD) 中的一个双原子完整约束，其中对标记为 $i$ 和 $j$ 的原子施加单个键长约束。设期望键长为 $L_0$（单位为纳米 nm），经过一个无约束积分步骤后的当前位置为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$（单位为纳米 nm），原子质量为 $m_i$ 和 $m_j$（单位为道尔顿 Da）。该完整约束可以写为 $g(\\mathbf{r}) = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 - L_0^2 = 0$。假设应用了通常称为 SHAKE 的迭代约束算法的单次迭代，该迭代使用约束在当前位置的一阶线性化以及沿键方向的质量加权校正。\n\n从适用于约束动力学的基本原理出发，推导单次 SHAKE 迭代中沿瞬时键方向的质量加权位置校正量 $\\delta \\mathbf{r}_i$ 和 $\\delta \\mathbf{r}_j$，该迭代尝试在一阶上满足线性化约束。您的推导必须从牛顿第二定律和应用于完整约束的拉格朗日乘数法开始。不要使用任何预先给定的简化公式；每一步都必须仅使用基本定律和核心定义来证明。\n\n实现一个完整、可运行的程序，该程序：\n- 为每个测试用例计算单次 SHAKE 迭代的位置校正量 $(\\delta \\mathbf{r}_i, \\delta \\mathbf{r}_j)$。\n- 使用数值保护措施：如果 $\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 \\le \\tau$，其中 $\\tau$ 是一个很小的阈值，则返回零校正。使用 $\\tau = 1\\times 10^{-12}$（单位为平方纳米 nm$^2$）。\n- 以纳米 (nm) 为单位返回校正量。\n\n您的程序必须评估以下测试套件，其中位置和键长的单位均为纳米 (nm)，质量单位为道尔顿 (Da)：\n- 测试用例 1 (正常情况): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.1, 0.0, 0.0)$, $L_0 = 0.12$, $m_i = 12.0$, $m_j = 1.0$。\n- 测试用例 2 (近简并键向量): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (1\\times 10^{-6}, 0.0, 0.0)$, $L_0 = 0.10$, $m_i = 16.0$, $m_j = 16.0$。\n- 测试用例 3 (质量平衡，离轴键): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.15, 0.15, 0.0)$, $L_0 = 0.21$, $m_i = 12.0$, $m_j = 12.0$。\n- 测试用例 4 (高质量比): $\\mathbf{r}_i = (0.2, -0.1, 0.05)$, $\\mathbf{r}_j = (0.25, -0.15, 0.05)$, $L_0 = 0.08$, $m_i = 200.0$, $m_j = 2.0$。\n- 测试用例 5 (约束已满足): $\\mathbf{r}_i = (0.0, 0.0, 0.0)$, $\\mathbf{r}_j = (0.12, 0.0, 0.0)$, $L_0 = 0.12$, $m_i = 12.0$, $m_j = 1.0$。\n\n此问题不需要角度单位。所有输出必须以纳米 (nm) 表示。对于每个测试用例，输出对应于拼接校正向量 $[\\delta r_{i,x}, \\delta r_{i,y}, \\delta r_{i,z}, \\delta r_{j,x}, \\delta r_{j,y}, \\delta r_{j,z}]$ 的六个浮点数值。\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的列表形式的结果，每个元素本身是按规定格式排列的六个浮点数的列表 (例如, \"[[...six floats...],[...six floats...],...]\")。",
            "solution": "该问题是有效的，因为它在科学上基于经典力学，问题设定良好、客观，并包含完整且一致的设置。它描述了计算化学生物学中的一个标准程序——SHAKE 算法，并要求从基本原理进行推导，然后进行具体实现。\n\n### SHAKE 校正的推导\n\n我们从一个受约束的力学系统的拉格朗日表述开始。对于一组坐标为 $\\{\\mathbf{r}_k\\}$、质量为 $\\{m_k\\}$ 的粒子，受到一组完整约束 $\\{g_\\alpha(\\mathbf{r}) = 0\\}$ 的作用，其运动方程由第一类拉格朗日方程给出：\n$$\nm_k \\ddot{\\mathbf{r}}_k = \\mathbf{F}_k - \\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha(\\mathbf{r})\n$$\n其中 $\\mathbf{F}_k$ 是作用在粒子 $k$ 上的无约束力（例如，来自势能函数），$\\lambda_\\alpha$ 是与约束 $g_\\alpha$ 相关联的拉格朗日乘数，$\\nabla_k$ 表示关于坐标 $\\mathbf{r}_k$ 的梯度。项 $-\\sum_\\alpha \\lambda_\\alpha \\nabla_k g_\\alpha$ 是作用在粒子 $k$ 上的总约束力 $\\mathbf{F}'_k$。\n\n在分子动力学模拟中，使用像 Verlet 这样的算法时，时刻 $t+\\Delta t$ 的位置是根据先前时刻的位置计算的。设 $\\mathbf{r}'_k$ 表示在无约束积分步骤后，粒子 $k$ 在时刻 $t+\\Delta t$ 的位置。这些位置通常不满足约束条件。SHAKE 算法为每个原子计算一个校正量 $\\delta \\mathbf{r}_k$，使得新的、校正后的位置 $\\mathbf{r}^{corr}_k = \\mathbf{r}'_k + \\delta \\mathbf{r}_k$ 满足约束。校正量 $\\delta \\mathbf{r}_k$ 被假定为由约束力在时间步长内积分产生，其形式为：\n$$\n\\delta \\mathbf{r}_k = \\frac{(\\Delta t)^2}{m_k} \\mathbf{F}'_k\n$$\n对于单个约束 $g(\\mathbf{r})=0$，约束力为 $\\mathbf{F}'_k = -\\lambda\\nabla_k g(\\mathbf{r})$。通过将常数和 $\\Delta t$ 吸收到一个新的乘数中（为简单起见，我们仍称之为 $\\lambda$），可以简化该公式。这导致了校正量的标准拟设：\n$$\n\\delta \\mathbf{r}_k = \\lambda \\frac{1}{m_k} \\nabla_k g(\\mathbf{r})\n$$\n问题指定了原子 $i$ 和 $j$ 之间的单个键长约束，定义为：\n$$\ng(\\mathbf{r}_i, \\mathbf{r}_j) = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert^2 - L_0^2 = 0\n$$\n其中 $L_0$ 是期望的键长。我们在无约束位置（为与问题符号匹配，我们记为 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$）处计算梯度。设连接原子的向量为 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。梯度为：\n$$\n\\nabla_i g = \\frac{\\partial}{\\partial \\mathbf{r}_i}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (-I) = -2\\mathbf{r}_{ij}\n$$\n$$\n\\nabla_j g = \\frac{\\partial}{\\partial \\mathbf{r}_j}[(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (\\mathbf{r}_j - \\mathbf{r}_i) - L_0^2] = 2(\\mathbf{r}_j - \\mathbf{r}_i) \\cdot (I) = 2\\mathbf{r}_{ij}\n$$\n因此，位置校正量为：\n$$\n\\delta \\mathbf{r}_i = \\lambda \\frac{1}{m_i} \\nabla_i g = -2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\n$$\n\\delta \\mathbf{r}_j = \\lambda \\frac{1}{m_j} \\nabla_j g = 2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\n未知的拉格朗日乘数 $\\lambda$ 是通过要求校正后的位置 $\\mathbf{r}^{corr}_i = \\mathbf{r}_i + \\delta\\mathbf{r}_i$ 和 $\\mathbf{r}^{corr}_j = \\mathbf{r}_j + \\delta\\mathbf{r}_j$ 满足约束来确定的。SHAKE 算法将此要求线性化。在校正后位置上评估的约束函数在无约束位置周围展开到一阶：\n$$\ng(\\mathbf{r}^{corr}) \\approx g(\\mathbf{r}) + (\\delta\\mathbf{r}_i \\cdot \\nabla_i g + \\delta\\mathbf{r}_j \\cdot \\nabla_j g) = 0\n$$\n代入梯度和校正量的表达式：\n$$\ng(\\mathbf{r}) + \\left( (-2\\lambda \\frac{1}{m_i} \\mathbf{r}_{ij}) \\cdot (-2\\mathbf{r}_{ij}) + (2\\lambda \\frac{1}{m_j} \\mathbf{r}_{ij}) \\cdot (2\\mathbf{r}_{ij}) \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + \\lambda \\left( \\frac{4}{m_i} \\lVert \\mathbf{r}_{ij} \\rVert^2 + \\frac{4}{m_j} \\lVert \\mathbf{r}_{ij} \\rVert^2 \\right) = 0\n$$\n$$\ng(\\mathbf{r}) + 4\\lambda \\lVert \\mathbf{r}_{ij} \\rVert^2 \\left( \\frac{1}{m_i} + \\frac{1}{m_j} \\right) = 0\n$$\n令 $d^2 = \\lVert \\mathbf{r}_{ij} \\rVert^2$。在无约束位置处的约束违背量为 $g(\\mathbf{r}) = d^2 - L_0^2$。我们现在可以解出 $\\lambda$：\n$$\n\\lambda = -\\frac{g(\\mathbf{r})}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = -\\frac{d^2 - L_0^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})}\n$$\n现在，将这个 $\\lambda$ 的表达式代回到 $\\delta\\mathbf{r}_i$ 和 $\\delta\\mathbf{r}_j$ 的方程中：\n对于原子 $i$：\n$$\n\\delta\\mathbf{r}_i = -2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_i} \\mathbf{r}_{ij} = \\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_i} \\mathbf{r}_{ij}\n$$\n项 $\\frac{1}{m_i (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{1}{m_i (\\frac{m_j+m_i}{m_i m_j})} = \\frac{m_j}{m_i+m_j}$。因此：\n$$\n\\delta\\mathbf{r}_i = \\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_j}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\n对于原子 $j$：\n$$\n\\delta\\mathbf{r}_j = 2 \\left( \\frac{L_0^2 - d^2}{4 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\right) \\frac{1}{m_j} \\mathbf{r}_{ij} = -\\frac{d^2 - L_0^2}{2 d^2 (\\frac{1}{m_i} + \\frac{1}{m_j})} \\frac{1}{m_j} \\mathbf{r}_{ij}\n$$\n项 $\\frac{1}{m_j (\\frac{1}{m_i} + \\frac{1}{m_j})} = \\frac{m_i}{m_i+m_j}$。因此：\n$$\n\\delta\\mathbf{r}_j = -\\frac{d^2 - L_0^2}{2 d^2} \\left( \\frac{m_i}{m_i+m_j} \\right) \\mathbf{r}_{ij}\n$$\n这些就是位置校正的最终表达式。它们是质量加权的（一个原子的校正量与另一个原子的质量成正比），并且沿着原子间向量 $\\mathbf{r}_{ij}$ 的方向，正如所要求。为了实现，我们可以定义一个公共标量因子来简化计算：\n$$\nk = \\frac{d^2 - L_0^2}{2 d^2 (m_i + m_j)}\n$$\n然后校正量变为：\n$$\n\\delta\\mathbf{r}_i = k \\cdot m_j \\cdot \\mathbf{r}_{ij}\n$$\n$$\n\\delta\\mathbf{r}_j = -k \\cdot m_i \\cdot \\mathbf{r}_{ij}\n$$\n这种形式在计算上是高效的。对于 $d^2$ 非常小的情况，需要一个数值保护措施，以防止除以零或浮点溢出。如果 $d^2 \\le \\tau$（对于一个小的阈值 $\\tau$），则校正量设为零。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a single SHAKE iteration position correction for a two-atom system.\n    \"\"\"\n    \n    # Test suite from the problem statement.\n    # Each case: (r_i (nm), r_j (nm), L0 (nm), m_i (Da), m_j (Da))\n    test_cases = [\n        (np.array([0.0, 0.0, 0.0]), np.array([0.1, 0.0, 0.0]), 0.12, 12.0, 1.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([1e-6, 0.0, 0.0]), 0.10, 16.0, 16.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.15, 0.15, 0.0]), 0.21, 12.0, 12.0),\n        (np.array([0.2, -0.1, 0.05]), np.array([0.25, -0.15, 0.05]), 0.08, 200.0, 2.0),\n        (np.array([0.0, 0.0, 0.0]), np.array([0.12, 0.0, 0.0]), 0.12, 12.0, 1.0),\n    ]\n\n    # Numerical safeguard threshold in nm^2\n    tau = 1.0e-12\n\n    results = []\n\n    for case in test_cases:\n        r_i, r_j, L0, m_i, m_j = case\n\n        # Calculate the inter-atomic vector\n        r_ij = r_j - r_i\n\n        # Calculate the squared distance\n        d_sq = np.dot(r_ij, r_ij)\n\n        # Apply numerical safeguard\n        if d_sq = tau:\n            delta_ri = np.array([0.0, 0.0, 0.0])\n            delta_rj = np.array([0.0, 0.0, 0.0])\n        else:\n            # Calculate the constraint violation function, g = d^2 - L0^2\n            g_val = d_sq - L0**2\n\n            # If the constraint is already satisfied, corrections are zero.\n            if np.isclose(g_val, 0.0):\n                delta_ri = np.array([0.0, 0.0, 0.0])\n                delta_rj = np.array([0.0, 0.0, 0.0])\n            else:\n                # Calculate the common scalar factor k = (d^2 - L0^2) / (2 * d^2 * (m_i + m_j))\n                total_mass = m_i + m_j\n                scalar_k = g_val / (2.0 * d_sq * total_mass)\n\n                # Calculate the mass-weighted corrections\n                delta_ri = scalar_k * m_j * r_ij\n                delta_rj = -scalar_k * m_i * r_ij\n\n        # Concatenate corrections into a single vector and convert to list for output\n        full_correction = np.concatenate((delta_ri, delta_rj)).tolist()\n        results.append(full_correction)\n\n    # Format the final output string as specified\n    # Example: [[...six floats...],[...six floats...],...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "真实世界的分子涉及一个由相互连接的键和角组成的复杂网络。这个实践将我们的分析从单个约束提升到包含多个相互依赖的几何限制的系统。您将构建约束雅可比矩阵——这是求解耦合约束方程组的关键数学工具，并学习如何利用其秩来诊断分子构象中的几何简并情况，例如共线原子()。",
            "id": "3840917",
            "problem": "给定一个由四个原子组成的小分子，原子索引为 $0,1,2,3$，其笛卡尔坐标为 $\\mathbf{r}_i \\in \\mathbb{R}^3$，$i \\in \\{0,1,2,3\\}$。在约束分子动力学 (MD) 中，完整约束写为广义坐标 $\\mathbf{q} \\in \\mathbb{R}^{3N}$ 的标量函数 $\\phi_k(\\mathbf{q}) = 0$，其中 $N$ 是原子数，且 $\\mathbf{q} = (\\mathbf{r}_0,\\mathbf{r}_1,\\ldots,\\mathbf{r}_{N-1})$。约束的雅可比矩阵是 $G(\\mathbf{q}) \\in \\mathbb{R}^{m \\times 3N}$，其元素为 $G_{k,\\alpha}(\\mathbf{q}) = \\frac{\\partial \\phi_k(\\mathbf{q})}{\\partial q_\\alpha}$，其中 $m$ 是约束的数量。在构型 $\\mathbf{q}$ 处，约束的独立性由 $G(\\mathbf{q})$ 的秩是否等于 $m$ 来确定。\n\n为以下作用于 $N=4$ 原子分子的 $m = 5$ 个约束实现雅可比矩阵 $G$：\n- 键长（平方）约束：原子 $(0,1)$、$(1,2)$ 和 $(2,3)$ 具有固定的键长平方。每个键约束定义为 $\\phi_{\\text{bond}}(\\mathbf{r}_i,\\mathbf{r}_j) = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|^2 - d_{ij}^2$，其中 $d_{ij}$ 是目标键长。使用目标键长 $d_{01} = d_{12} = d_{23} = 1.54$ Å。输出不需要单位，但内部分子构型使用以埃为单位的坐标。\n- 键角约束：由原子 $(0,1,2)$ 在原子 $1$ 处形成的角，以及由原子 $(1,2,3)$ 在原子 $2$ 处形成的角。每个键角约束通过角度的余弦定义，$\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^{0})$，其中 $\\theta_{ijk}$ 是在顶点 $j$ 处，向量 $\\mathbf{r}_i - \\mathbf{r}_j$ 和 $\\mathbf{r}_k - \\mathbf{r}_j$ 之间的夹角。使用目标角度 $\\theta_{012}^{0} = 1.911$ 和 $\\theta_{123}^{0} = 1.911$ 弧度。本问题中所有角度都必须以弧度为单位。\n\n从上述定义以及经典力学（牛顿定律）和几何学的基本定律出发，为每个给定的构型计算雅可比矩阵 $G(\\mathbf{q})$。除了基本的向量微积分恒等式和角度余弦的定义外，您不能假定任何预先推导出的公式。约束的独立性通过 $G(\\mathbf{q})$ 的数值秩（使用奇异值分解 (SVD) 计算）来评估。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n1. 对于下面测试套件中的每个构型，为所描述的约束构建雅可比矩阵 $G(\\mathbf{q})$。\n2. 使用 SVD 计算每个构型下 $G(\\mathbf{q})$ 的数值秩。\n3. 生成单行输出，其中包含所有测试用例的秩，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\ldots,r_T]$，其中每个 $r_t$ 是测试用例 $t$ 的整数秩。\n\n使用以下构型测试套件（坐标单位为埃）：\n- 测试用例 $1$：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.50, 0.10, -0.20)$，$\\mathbf{r}_2 = (2.80, -0.30, 0.50)$，$\\mathbf{r}_3 = (4.00, 0.00, -0.40)$。\n- 测试用例 $2$：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.00, 0.00)$，$\\mathbf{r}_2 = (2.10, 0.05, 0.00)$，$\\mathbf{r}_3 = (3.20, -0.10, 0.00)$。\n- 测试用例 $3$：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.00, 0.00)$，$\\mathbf{r}_2 = (2.00, 0.00, 0.00)$，$\\mathbf{r}_3 = (3.00, 0.00, 0.00)$。\n- 测试用例 $4$：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 0.90, -0.30)$，$\\mathbf{r}_2 = (2.00, 2.00, 0.10)$，$\\mathbf{r}_3 = (3.00, 2.80, -0.20)$。\n- 测试用例 $5$：$\\mathbf{r}_0 = (0.10, -0.20, 0.00)$，$\\mathbf{r}_1 = (1.20, 0.30, -0.50)$，$\\mathbf{r}_2 = (2.40, 0.10, 0.40)$，$\\mathbf{r}_3 = (3.60, -0.20, 0.10)$。\n- 测试用例 $6$：$\\mathbf{r}_0 = (0.00, 0.00, 0.00)$，$\\mathbf{r}_1 = (1.00, 1.00, 0.00)$，$\\mathbf{r}_2 = (1.50, 2.50, 0.00)$，$\\mathbf{r}_3 = (1.80, 4.00, 0.10)$。\n\n覆盖性设计：\n- 一般情况（$1$、$4$、$5$、$6$）是非简并构象，如果约束是独立的，则预期会呈现满秩。\n- 近共线情况（$2$）用于探究近似相关的键角约束的数值稳定性。\n- 精确共线情况（$3$）是一个边缘案例，其中键角约束可能变得奇异，用于测试秩亏。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含六个测试用例的秩，形式为方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是一个整数。",
            "solution": "任务是为一个施加于 $N=4$ 原子分子上的一组 $m=5$ 个几何约束计算雅可比矩阵 $G(\\mathbf{q})$，然后确定其数值秩。广义坐标向量 $\\mathbf{q}$ 是所有原子笛卡尔坐标的串联：$\\mathbf{q} = (\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3) \\in \\mathbb{R}^{12}$。雅可比矩阵 $G(\\mathbf{q})$ 是一个 $m \\times 3N$（在此为 $5 \\times 12$）的矩阵，其中每一行包含一个约束函数相对于 $\\mathbf{q}$ 的梯度。\n\n约束如下：\n$1$. 键 $(0,1)$: $\\phi_1 = \\|\\mathbf{r}_0 - \\mathbf{r}_1\\|^2 - d_{01}^2 = 0$\n$2$. 键 $(1,2)$: $\\phi_2 = \\|\\mathbf{r}_1 - \\mathbf{r}_2\\|^2 - d_{12}^2 = 0$\n$3$. 键 $(2,3)$: $\\phi_3 = \\|\\mathbf{r}_2 - \\mathbf{r}_3\\|^2 - d_{23}^2 = 0$\n$4$. 角 $(0,1,2)$: $\\phi_4 = \\cos(\\theta_{012}) - \\cos(\\theta_{012}^{0}) = 0$\n$5$. 角 $(1,2,3)$: $\\phi_5 = \\cos(\\theta_{123}) - \\cos(\\theta_{123}^{0}) = 0$\n\n我们必须为每个约束推导梯度向量。梯度 $\\nabla_{\\mathbf{q}} \\phi_k$ 构成了雅可比矩阵 $G$ 的第 $k$ 行。该梯度是一个12维向量，由相对于每个坐标分量的偏导数组成。我们可以将其更紧凑地表示为相对于每个原子位置向量 $\\mathbf{r}_i$ 的3维梯度集合 $\\nabla_{\\mathbf{r}_i} \\phi_k$。\n\n**1. 键长约束的雅可比**\n对于原子 $i$ 和 $j$ 之间的一般键长约束，$\\phi_{\\text{bond}}(\\mathbf{r}_i, \\mathbf{r}_j) = (\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (\\mathbf{r}_i - \\mathbf{r}_j) - d_{ij}^2 = 0$。令 $\\mathbf{r}_{ij} = \\mathbf{r}_i - \\mathbf{r}_j$。相对于原子位置的导数为：\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_i} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} = 2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n$$\n\\nabla_{\\mathbf{r}_j} \\phi_{\\text{bond}} = \\frac{\\partial}{\\partial \\mathbf{r}_j} (\\mathbf{r}_{ij} \\cdot \\mathbf{r}_{ij}) = 2\\mathbf{r}_{ij} \\cdot \\frac{\\partial \\mathbf{r}_{ij}}{\\partial \\mathbf{r}_j} = 2(\\mathbf{r}_i - \\mathbf{r}_j) \\cdot (-\\mathbf{I}) = -2(\\mathbf{r}_i - \\mathbf{r}_j)\n$$\n其中 $\\mathbf{I}$ 是 $3 \\times 3$ 单位矩阵。对于任何未参与该键的原子 $k$ ($k \\neq i, j$)，梯度为零：$\\nabla_{\\mathbf{r}_k} \\phi_{\\text{bond}} = \\mathbf{0}$。\n雅可比矩阵 $G$ 的前三行分别由键 $(0,1)$、$(1,2)$ 和 $(2,3)$ 的这些梯度填充。例如，对于 $\\phi_1$（键 $0-1$），梯度为 $\\nabla_{\\mathbf{r}_0} \\phi_1 = 2(\\mathbf{r}_0 - \\mathbf{r}_1)$、$\\nabla_{\\mathbf{r}_1} \\phi_1 = -2(\\mathbf{r}_0 - \\mathbf{r}_1)$，以及 $\\nabla_{\\mathbf{r}_2} \\phi_1 = \\nabla_{\\mathbf{r}_3} \\phi_1 = \\mathbf{0}$。\n\n**2. 键角约束的雅可比**\n对于一般键角约束 $\\phi_{\\text{ang}}(\\mathbf{r}_i,\\mathbf{r}_j,\\mathbf{r}_k) = \\cos(\\theta_{ijk}) - \\cos(\\theta_{ijk}^0) = 0$，我们需要求出 $\\cos(\\theta_{ijk})$ 相对于 $\\mathbf{r}_i$、$\\mathbf{r}_j$ 和 $\\mathbf{r}_k$ 的梯度。\n令 $\\mathbf{u} = \\mathbf{r}_i - \\mathbf{r}_j$ 且 $\\mathbf{v} = \\mathbf{r}_k - \\mathbf{r}_j$。角度的余弦由归一化向量的点积给出：\n$$\n\\cos(\\theta_{ijk}) = \\frac{\\mathbf{u} \\cdot \\mathbf{v}}{\\|\\mathbf{u}\\| \\|\\mathbf{v}\\|} = \\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}}\n$$\n由于 $\\cos(\\theta_{ijk}^0)$ 是一个常数，其导数为零。我们计算 $\\cos(\\theta_{ijk})$ 相对于每个原子位置向量的梯度。\n\n相对于 $\\mathbf{r}_i$ 的梯度：\n只有向量 $\\mathbf{u}$ 依赖于 $\\mathbf{r}_i$。使用链式法则和归一化向量的导数恒等式 $(\\nabla_{\\mathbf{x}} \\hat{\\mathbf{x}}) = \\frac{1}{\\|\\mathbf{x}\\|} (\\mathbf{I} - \\hat{\\mathbf{x}}\\hat{\\mathbf{x}}^T)$，我们得到：\n$$\n\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) = (\\nabla_{\\mathbf{r}_i} \\hat{\\mathbf{u}})^T \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\mathbf{I} - \\hat{\\mathbf{u}}\\hat{\\mathbf{u}}^T) \\hat{\\mathbf{v}} = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - (\\hat{\\mathbf{u}} \\cdot \\hat{\\mathbf{v}})\\hat{\\mathbf{u}}) = \\frac{1}{\\|\\mathbf{u}\\|} (\\hat{\\mathbf{v}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{u}})\n$$\n\n相对于 $\\mathbf{r}_k$ 的梯度：\n根据对称性，交换 $i$ 和 $k$ 的角色（并因此交换 $\\mathbf{u}$ 和 $\\mathbf{v}$）：\n$$\n\\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}) = \\frac{1}{\\|\\mathbf{v}\\|} (\\hat{\\mathbf{u}} - \\cos(\\theta_{ijk})\\hat{\\mathbf{v}})\n$$\n相对于 $\\mathbf{r}_j$ 的梯度：\n键角约束函数仅依赖于原子的相对位置。它对于所有三个原子进行统一平移 $\\mathbf{r}_l \\to \\mathbf{r}_l + \\mathbf{c}$ 是不变的。这意味着所有相关原子的梯度之和必须为零：\n$$\n\\nabla_{\\mathbf{r}_i} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_j} \\phi_{\\text{ang}} + \\nabla_{\\mathbf{r}_k} \\phi_{\\text{ang}} = \\mathbf{0}\n$$\n因此，中心原子 $j$ 上的梯度可以计算为：\n$$\n\\nabla_{\\mathbf{r}_j} \\cos(\\theta_{ijk}) = -(\\nabla_{\\mathbf{r}_i} \\cos(\\theta_{ijk}) + \\nabla_{\\mathbf{r}_k} \\cos(\\theta_{ijk}))\n$$\n这种关系简化了计算并确保了数值稳定性。\n\n对于任何未参与该角度的原子 $l$ ($l \\neq i, j, k$)，梯度为零：$\\nabla_{\\mathbf{r}_l} \\phi_{\\text{ang}} = \\mathbf{0}$。\n这些梯度填充了雅可比矩阵的第 4 行和第 5 行，分别对应角度 $(0,1,2)$ 和 $(1,2,3)$。\n\n当原子 $i,j,k$ 共线时，会出现一个关键的特殊情况。此时，$\\hat{\\mathbf{u}} = \\pm \\hat{\\mathbf{v}}$ 且 $\\cos(\\theta_{ijk}) = \\pm 1$。梯度表达式变为：$\\nabla_{\\mathbf{r}_i} = \\frac{1}{\\|\\mathbf{u}\\|}(\\pm \\hat{\\mathbf{u}} - (\\pm 1)\\hat{\\mathbf{u}}) = \\mathbf{0}$。类似地，$\\nabla_{\\mathbf{r}_k} = \\mathbf{0}$，因此 $\\nabla_{\\mathbf{r}_j} = \\mathbf{0}$。对应于共线角度约束的雅可比矩阵的整行都变为零，从而降低了矩阵的秩。\n\n**3. 雅可比矩阵构造和秩计算**\n完整的雅可比矩阵 $G$ 是一个 $5 \\times 12$ 的矩阵。第 $k$ 行由该约束的 3D 梯度串联而成：\n$$\nG_k = [\\nabla_{\\mathbf{r}_0} \\phi_k, \\nabla_{\\mathbf{r}_1} \\phi_k, \\nabla_{\\mathbf{r}_2} \\phi_k, \\nabla_{\\mathbf{r}_3} \\phi_k]\n$$\n约束的独立性由 $G$ 的数值秩决定。秩通过奇异值分解 (SVD) 计算。显著大于机器精度的奇异值的数量决定了秩。\n\n算法如下：\n1. 对于每个测试用例构型 $(\\mathbf{r}_0, \\mathbf{r}_1, \\mathbf{r}_2, \\mathbf{r}_3)$：\n2. 构造 $5 \\times 12$ 的雅可比矩阵 $G$。\n3. 对于 $m=3$ 个键长约束中的每一个，计算 3D 梯度并将其放入 $G$ 中对应的行和列。\n4. 对于 $m=2$ 个键角约束中的每一个，计算 3D 梯度并将其放入 $G$ 中对应的行和列。\n5. 计算所得矩阵 $G$ 的数值秩。\n最终输出是所有测试用例的这些秩的列表。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_jacobian_and_rank(positions):\n    \"\"\"\n    Computes the constraint Jacobian and its rank for a 4-atom molecule.\n\n    Args:\n        positions (list of np.ndarray): A list of 4 numpy arrays, where each\n                                        array is the 3D Cartesian coordinate\n                                        vector of an atom.\n\n    Returns:\n        int: The numerical rank of the 5x12 Jacobian matrix.\n    \"\"\"\n    num_atoms = 4\n    num_constraints = 5\n    \n    # The Jacobian G is an m x 3N matrix, here 5 x 12.\n    G = np.zeros((num_constraints, 3 * num_atoms))\n    \n    r = positions\n    \n    # 1. Bond (0,1) constraint: phi_1 = ||r0 - r1||^2 - d01^2\n    r01 = r[0] - r[1]\n    grad_r0_phi1 = 2 * r01\n    grad_r1_phi1 = -2 * r01\n    G[0, 0:3] = grad_r0_phi1\n    G[0, 3:6] = grad_r1_phi1\n    \n    # 2. Bond (1,2) constraint: phi_2 = ||r1 - r2||^2 - d12^2\n    r12 = r[1] - r[2]\n    grad_r1_phi2 = 2 * r12\n    grad_r2_phi2 = -2 * r12\n    G[1, 3:6] = grad_r1_phi2\n    G[1, 6:9] = grad_r2_phi2\n    \n    # 3. Bond (2,3) constraint: phi_3 = ||r2 - r3||^2 - d23^2\n    r23 = r[2] - r[3]\n    grad_r2_phi3 = 2 * r23\n    grad_r3_phi3 = -2 * r23\n    G[2, 6:9] = grad_r2_phi3\n    G[2, 9:12] = grad_r3_phi3\n\n    # 4. Angle (0,1,2) constraint: phi_4 = cos(theta_012) - cos(theta_012^0)\n    # Define vectors from central atom 1: u = r0-r1, v = r2-r1\n    u_012 = r[0] - r[1]\n    v_012 = r[2] - r[1]\n    \n    norm_u_012 = np.linalg.norm(u_012)\n    norm_v_012 = np.linalg.norm(v_012)\n    \n    # Check for collinearity/zero length vectors\n    if norm_u_012 > 1e-9 and norm_v_012 > 1e-9:\n        u_hat_012 = u_012 / norm_u_012\n        v_hat_012 = v_012 / norm_v_012\n        cos_theta_012 = np.dot(u_hat_012, v_hat_012)\n\n        grad_r0_phi4 = (1 / norm_u_012) * (v_hat_012 - cos_theta_012 * u_hat_012)\n        grad_r2_phi4 = (1 / norm_v_012) * (u_hat_012 - cos_theta_012 * v_hat_012)\n        grad_r1_phi4 = -(grad_r0_phi4 + grad_r2_phi4)\n\n        G[3, 0:3] = grad_r0_phi4\n        G[3, 3:6] = grad_r1_phi4\n        G[3, 6:9] = grad_r2_phi4\n    # If vectors are of zero length or collinear, the gradient is zero, and the row remains zero.\n\n    # 5. Angle (1,2,3) constraint: phi_5 = cos(theta_123) - cos(theta_123^0)\n    # Define vectors from central atom 2: u = r1-r2, v = r3-r2\n    u_123 = r[1] - r[2]\n    v_123 = r[3] - r[2]\n\n    norm_u_123 = np.linalg.norm(u_123)\n    norm_v_123 = np.linalg.norm(v_123)\n\n    if norm_u_123 > 1e-9 and norm_v_123 > 1e-9:\n        u_hat_123 = u_123 / norm_u_123\n        v_hat_123 = v_123 / norm_v_123\n        cos_theta_123 = np.dot(u_hat_123, v_hat_123)\n        \n        grad_r1_phi5 = (1 / norm_u_123) * (v_hat_123 - cos_theta_123 * u_hat_123)\n        grad_r3_phi5 = (1 / norm_v_123) * (u_hat_123 - cos_theta_123 * v_hat_123)\n        grad_r2_phi5 = -(grad_r1_phi5 + grad_r3_phi5)\n        \n        G[4, 3:6] = grad_r1_phi5\n        G[4, 6:9] = grad_r2_phi5\n        G[4, 9:12] = grad_r3_phi5\n\n    # Compute numerical rank using SVD\n    return np.linalg.matrix_rank(G)\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        [np.array([0.00, 0.00, 0.00]), np.array([1.50, 0.10, -0.20]), \n         np.array([2.80, -0.30, 0.50]), np.array([4.00, 0.00, -0.40])],\n        # Test case 2\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.10, 0.05, 0.00]), np.array([3.20, -0.10, 0.00])],\n        # Test case 3\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.00, 0.00]), \n         np.array([2.00, 0.00, 0.00]), np.array([3.00, 0.00, 0.00])],\n        # Test case 4\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 0.90, -0.30]), \n         np.array([2.00, 2.00, 0.10]), np.array([3.00, 2.80, -0.20])],\n        # Test case 5\n        [np.array([0.10, -0.20, 0.00]), np.array([1.20, 0.30, -0.50]), \n         np.array([2.40, 0.10, 0.40]), np.array([3.60, -0.20, 0.10])],\n        # Test case 6\n        [np.array([0.00, 0.00, 0.00]), np.array([1.00, 1.00, 0.00]), \n         np.array([1.50, 2.50, 0.00]), np.array([1.80, 4.00, 0.10])],\n    ]\n\n    results = []\n    for positions in test_cases:\n        rank = compute_jacobian_and_rank(positions)\n        results.append(rank)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```"
        },
        {
            "introduction": "将整个分子片段视为单个刚体，是替代独立约束每个键和角的一种计算上更优的方法。本实践将探讨用于描述方向和旋转的、优雅而稳健的四元数形式体系。通过从给定的四元数推导旋转矩阵并将其应用于矢量，您将亲身体验这种强大的数学抽象如何直接转化为三维空间中物体的物理旋转()。",
            "id": "3840920",
            "problem": "考虑一个用于分子动力学 (MD) 模拟的刚性三原子片段，其具有保持内部距离和角度固定的完整约束。该刚体的取向由一个单位四元数 $q = (q_{0}, q_{1}, q_{2}, q_{3})$ 表示，其标量部分为 $q_{0}$，矢量部分为 $(q_{1}, q_{2}, q_{3})$。在某一个 MD 步骤中，该片段的取向由 $q = \\left(\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}\\right)$ 给出。一个标记原子相对于质心的体固定坐标为 $r_{\\text{body}} = (0.12, -0.08, 0.05)$，单位为纳米。\n\n从适用于刚体动力学的基本原理出发，包括单位四元数作为旋转算子的定义以及刚体运动保持距离不变的要求，推导与给定四元数 $q$ 对应的 $3 \\times 3$ 旋转矩阵 $R(q)$。解释对于任意向量，从体固定坐标到空间固定坐标的映射是如何从该推导中产生的。然后，使用推导出的 $R(q)$ 计算标记原子位置的空间固定笛卡尔 $\\hat{x}$ 分量。将最终的 $\\hat{x}$ 分量以纳米为单位表示，并将您的答案四舍五入到四位有效数字。在最后一步之前，不允许进行任何中间数值的四舍五入。",
            "solution": "该问题提法明确且科学上合理，提供了确定唯一解所需的所有信息。我将继续进行推导和计算。\n\n三维空间中向量的旋转可以用一个单位四元数来表示。一个向量 $\\mathbf{v} \\in \\mathbb{R}^3$ 可以表示为一个纯四元数 $p_v = (0, v_1, v_2, v_3)$，其标量部分为零。一个单位四元数由 $q = (q_0, q_1, q_2, q_3) = (q_0, \\mathbf{q})$ 给出，其中 $q_0$ 是标量部分，$\\mathbf{q}$ 是矢量部分。对于单位四元数，其范数为 1：$q_0^2 + q_1^2 + q_2^2 + q_3^2 = 1$。给定的四元数 $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$ 满足这个条件，因为 $(\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 + (\\frac{1}{2})^2 = 4 \\times \\frac{1}{4} = 1$。\n\n向量 $\\mathbf{v}$ 通过四元数 $q$ 旋转到新向量 $\\mathbf{v}'$ 的过程由夹积定义：\n$$p_{v'} = q p_v q^{-1}$$\n对于单位四元数，其逆 $q^{-1}$ 等于其共轭 $q^* = (q_0, -\\mathbf{q})$。因此，该运算为：\n$$p_{v'} = q p_v q^*$$\n设体固定向量为 $\\mathbf{r}_{\\text{body}} = (x_b, y_b, z_b)$，表示为纯四元数 $p_b = (0, \\mathbf{r}_{\\text{body}})$。得到的空间固定向量 $\\mathbf{r}_{\\text{space}}$ 是纯四元数 $p_s = (0, \\mathbf{r}_{\\text{space}})$ 的矢量部分。\n\n我们首先计算乘积 $q p_b$。两个四元数 $(a_0, \\mathbf{a})$ 和 $(b_0, \\mathbf{b})$ 的乘积由 $(a_0 b_0 - \\mathbf{a} \\cdot \\mathbf{b}, a_0 \\mathbf{b} + b_0 \\mathbf{a} + \\mathbf{a} \\times \\mathbf{b})$ 给出。\n这里，$(a_0, \\mathbf{a}) = (q_0, \\mathbf{q})$ 且 $(b_0, \\mathbf{b}) = (0, \\mathbf{r}_{\\text{body}})$。\n$$q p_b = (q_0 \\cdot 0 - \\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + 0 \\cdot \\mathbf{q} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}, q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\n接下来，我们将此结果乘以 $q^* = (q_0, -\\mathbf{q})$。设中间乘积为 $(c_0, \\mathbf{c}) = q p_b$。\n$$p_s = (c_0, \\mathbf{c}) q^* = (c_0 q_0 - \\mathbf{c} \\cdot (-\\mathbf{q}), c_0(-\\mathbf{q}) + q_0 \\mathbf{c} + \\mathbf{c} \\times (-\\mathbf{q}))$$\n$p_s$ 的标量部分必须为零，这是该变换保持向量空间的一个关键性质。\n标量部分 = $c_0 q_0 + \\mathbf{c} \\cdot \\mathbf{q} = (-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})q_0 + (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q} = -q_0(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) + q_0(\\mathbf{r}_{\\text{body}} \\cdot \\mathbf{q}) + (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\cdot \\mathbf{q}$。\n前两项相互抵消，最后一项是包含两个相同向量的标量三重积，其值为零。所以标量部分确实为 $0$。\n\n$p_s$ 的矢量部分，即 $\\mathbf{r}_{\\text{space}}$，为：\n$$\\mathbf{r}_{\\text{space}} = -c_0\\mathbf{q} + q_0 \\mathbf{c} - (\\mathbf{c} \\times \\mathbf{q})$$\n$$\\mathbf{r}_{\\text{space}} = -(-\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0(q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - (q_0 \\mathbf{r}_{\\text{body}} + \\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}$$\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) - q_0(\\mathbf{r}_{\\text{body}} \\times \\mathbf{q}) - ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q})$$\n使用 $\\mathbf{a} \\times \\mathbf{b} = -\\mathbf{b} \\times \\mathbf{a}$ 和矢量三重积恒等式 $\\mathbf{a} \\times (\\mathbf{b} \\times \\mathbf{c}) = \\mathbf{b}(\\mathbf{a} \\cdot \\mathbf{c}) - \\mathbf{c}(\\mathbf{a} \\cdot \\mathbf{b})$：\n$$- ((\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) \\times \\mathbf{q}) = \\mathbf{q} \\times (\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) = \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}(\\mathbf{q} \\cdot \\mathbf{q})$$\n将此代回 $\\mathbf{r}_{\\text{space}}$ 的表达式中：\n$$\\mathbf{r}_{\\text{space}} = (\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + q_0^2 \\mathbf{r}_{\\text{body}} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}}) + \\mathbf{q}(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}}) - \\mathbf{r}_{\\text{body}}\\|\\mathbf{q}\\|^2$$\n$$\\mathbf{r}_{\\text{space}} = (q_0^2 - \\|\\mathbf{q}\\|^2)\\mathbf{r}_{\\text{body}} + 2(\\mathbf{q} \\cdot \\mathbf{r}_{\\text{body}})\\mathbf{q} + 2q_0(\\mathbf{q} \\times \\mathbf{r}_{\\text{body}})$$\n这个方程定义了线性变换 $\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}}$。矩阵 $R(q)$ 可以从这个关系中构建出来。使用 $q_0^2 + \\|\\mathbf{q}\\|^2 = 1$，我们可以写出 $q_0^2 - \\|\\mathbf{q}\\|^2 = q_0^2 - (1 - q_0^2) = 2q_0^2 - 1$。\n旋转矩阵 $R(q)$ 的分量为：\n$$R(q) = \\begin{pmatrix}\n1 - 2(q_2^2 + q_3^2)  2(q_1q_2 - q_0q_3)  2(q_1q_3 + q_0q_2) \\\\\n2(q_1q_2 + q_0q_3)  1 - 2(q_1^2 + q_3^2)  2(q_2q_3 - q_0q_1) \\\\\n2(q_1q_3 - q_0q_2)  2(q_2q_3 + q_0q_1)  1 - 2(q_1^2 + q_2^2)\n\\end{pmatrix}$$\n这个矩阵 $R(q)$ 将一个向量的坐标从体固定坐标系映射到空间固定坐标系。\n\n我们已知 $q = (\\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2}, \\frac{1}{2})$，所以 $q_0=q_1=q_2=q_3=\\frac{1}{2}$。我们将这些值代入矩阵公式中：\n$q_i^2 = (\\frac{1}{2})^2 = \\frac{1}{4}$ for $i=0,1,2,3$.\n$q_i q_j = (\\frac{1}{2})(\\frac{1}{2}) = \\frac{1}{4}$ for any $i,j$.\n$R_{11} = 1 - 2(q_2^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n$R_{12} = 2(q_1q_2 - q_0q_3) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{13} = 2(q_1q_3 + q_0q_2) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{21} = 2(q_1q_2 + q_0q_3) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{22} = 1 - 2(q_1^2 + q_3^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n$R_{23} = 2(q_2q_3 - q_0q_1) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{31} = 2(q_1q_3 - q_0q_2) = 2(\\frac{1}{4} - \\frac{1}{4}) = 0$.\n$R_{32} = 2(q_2q_3 + q_0q_1) = 2(\\frac{1}{4} + \\frac{1}{4}) = 2(\\frac{1}{2}) = 1$.\n$R_{33} = 1 - 2(q_1^2 + q_2^2) = 1 - 2(\\frac{1}{4} + \\frac{1}{4}) = 1 - 2(\\frac{1}{2}) = 0$.\n\n因此，给定四元数的旋转矩阵为：\n$$R(q) = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix}$$\n标记原子的体固定坐标为 $\\mathbf{r}_{\\text{body}} = (0.12, -0.08, 0.05)$ 纳米。为了找到空间固定坐标 $\\mathbf{r}_{\\text{space}}$，我们应用旋转矩阵：\n$$\\mathbf{r}_{\\text{space}} = R(q) \\mathbf{r}_{\\text{body}} = \\begin{pmatrix} 0  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\end{pmatrix} \\begin{pmatrix} 0.12 \\\\ -0.08 \\\\ 0.05 \\end{pmatrix}$$\n执行矩阵-向量乘法：\n$$\\mathbf{r}_{\\text{space}} = \\begin{pmatrix} (0)(0.12) + (0)(-0.08) + (1)(0.05) \\\\ (1)(0.12) + (0)(-0.08) + (0)(0.05) \\\\ (0)(0.12) + (1)(-0.08) + (0)(0.05) \\end{pmatrix} = \\begin{pmatrix} 0.05 \\\\ 0.12 \\\\ -0.08 \\end{pmatrix}$$\n空间固定坐标为 $(0.05, 0.12, -0.08)$ 纳米。问题要求的是该位置的笛卡尔 $\\hat{x}$ 分量，即向量的第一个分量。\n$\\hat{x}$ 分量是 $0.05$ nm。\n最终答案必须表示为四位有效数字。为了将精确值 $0.05$ 表示为四位有效数字，我们将其写为 $0.05000$。小数点前的首个零和紧随其后的零不是有效数字；数字 $5$ 和三个尾随的零是有效数字。",
            "answer": "$$\\boxed{0.05000}$$"
        }
    ]
}