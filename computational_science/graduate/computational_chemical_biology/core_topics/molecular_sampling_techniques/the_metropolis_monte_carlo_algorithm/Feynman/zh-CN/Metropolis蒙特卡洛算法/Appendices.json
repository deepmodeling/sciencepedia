{
    "hands_on_practices": [
        {
            "introduction": "Metropolis蒙特卡洛算法的核心在于决定是接受还是拒绝一个提议的构象移动。这个决定取决于计算势能变化（$\\Delta U$）并根据Metropolis准则将其与热能 $k_B T$ 进行比较。本练习将让你亲手实践这一核心机制，从处理分子坐标和力场，到计算最终的接受概率，为所有MMC模拟打下基础。",
            "id": "3866338",
            "problem": "一个具有两个相互作用位点的小分子配体结合在含水环境中带电的受体口袋附近。考虑一个提议的配体绕 $z$ 轴的刚体旋转，角度为 $\\theta = \\pi/2$（右手系，配体坐标的主动旋转），而受体保持固定。势能由 Lennard–Jones (LJ) $12$–$6$ 项和屏蔽静电项之和来建模。从正则系综和 Metropolis Monte Carlo (MMC) 算法的定义出发，计算在指定力场下此提议移动的能量变化 $\\Delta U$，然后评估在温度 $T$ 下的 MMC 接受概率。\n\n使用以下科学一致的设置和常数：\n- 几何（所有位置单位为纳米）：受体原子位于 $\\mathbf{R}_1 = (0, 0, 0)$ 和 $\\mathbf{R}_2 = (1.0, 0, 0)$；配体原子初始位于 $\\mathbf{L}_1 = (0.5, 0.5, 0)$ 和 $\\mathbf{L}_2 = (0.5, -0.5, 0)$。提议的绕 $z$ 轴旋转 $\\theta = \\pi/2$ 的映射为 $(x, y, z) \\mapsto (-y, x, z)$，得到 $\\mathbf{L}_1' = (-0.5, 0.5, 0)$ 和 $\\mathbf{L}_2' = (0.5, 0.5, 0)$。\n- 部分电荷（单位为基本电荷 $e$）：$q_{\\mathrm{L}_1} = +0.20$, $q_{\\mathrm{L}_2} = -0.20$, $Q_{\\mathrm{R}_1} = -0.50$, $Q_{\\mathrm{R}_2} = -0.50$。\n- 非键参数：LJ 采用 Lorentz–Berthelot 混合规则，位点参数为 $\\sigma_{\\mathrm{L}} = 0.50$ 和 $\\epsilon_{\\mathrm{L}} = 0.25$（对配体原子），$\\sigma_{\\mathrm{R}} = 0.50$ 和 $\\epsilon_{\\mathrm{R}} = 0.25$（对受体原子），单位分别为纳米和千焦每摩尔。因此，对于任何配体-受体对，$\\sigma_{ij} = (\\sigma_{\\mathrm{L}} + \\sigma_{\\mathrm{R}})/2$ 且 $\\epsilon_{ij} = \\sqrt{\\epsilon_{\\mathrm{L}} \\epsilon_{\\mathrm{R}}}$。\n- 力场能量项，对于分离距离为 $r$ 的配体-受体对：LJ 能量 $U_{\\mathrm{LJ}}(r) = 4 \\epsilon_{ij} \\left[ \\left( \\frac{\\sigma_{ij}}{r} \\right)^{12} - \\left( \\frac{\\sigma_{ij}}{r} \\right)^6 \\right]$；屏蔽库仑能量 $U_{\\mathrm{coul}}(r) = \\frac{k_e}{\\varepsilon_r} \\frac{q_i q_j}{r}$，其中 $k_e = 138.935456$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}\\,e^{-2}$ 且相对介电常数 $\\varepsilon_r = 80$（水环境）。\n- 温度：$T = 300$ $\\mathrm{K}$；Boltzmann 常数 $k_B = 8.314462618 \\times 10^{-3}$ $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n\n假设只有配体-受体非键相互作用对此次移动的能量变化有贡献。计算旋转后的总能量变化 $\\Delta U$，并使用与正则系综和细致平衡条件一致的第一性原理，评估此移动的 Metropolis 接受概率。仅报告接受概率，以十进制数表示，四舍五入到四位有效数字，不带单位。",
            "solution": "该问题要求计算一个提议的配体分子在受体附近进行刚体旋转的 Metropolis Monte Carlo (MMC) 接受概率。解法必须从第一性原理推导，从正则系综和 MMC 算法的原则开始，并利用所提供的力场模型。\n\nMetropolis Monte Carlo 算法是一种从概率分布中抽样构象的方法。在正则 ($NVT$) 系综中，系统处于具有势能 $U_i$ 的微观状态 $i$ 的平衡概率 $\\pi_i$ 由 Boltzmann 分布给出：\n$$ \\pi_i = \\frac{1}{Z} \\exp\\left(-\\frac{U_i}{k_B T}\\right) $$\n其中 $Z$ 是正则配分函数，$k_B$ 是 Boltzmann 常数，$T$ 是绝对温度。MMC 算法生成一系列状态（一个马尔可夫链），其极限分布是这个 Boltzmann 分布。从旧状态 $o$ 到新状态 $n$ 的移动被接受的概率为 $P_{acc}$，该概率满足细致平衡条件，$\\pi_o P(o \\to n) = \\pi_n P(n \\to o)$。接受概率的标准选择是 Metropolis 准则：\n$$ P_{acc} = \\min\\left(1, \\frac{\\pi_n}{\\pi_o}\\right) = \\min\\left(1, \\exp\\left(-\\frac{U_n - U_o}{k_B T}\\right)\\right) = \\min\\left(1, \\exp\\left(-\\frac{\\Delta U}{k_B T}\\right)\\right) $$\n这里，$\\Delta U = U_n - U_o$ 是提议移动的势能变化。我们的任务是计算这个 $\\Delta U$ 并随后计算接受概率 $P_{acc}$。\n\n系统的总势能 $U$ 是配体和受体原子之间 Lennard-Jones ($U_{\\mathrm{LJ}}$) 和屏蔽静电 ($U_{\\mathrm{coul}}$) 相互作用的总和。按照规定，我们只考虑这些分子间相互作用。总共有四个这样的相互作用对：$(\\mathbf{R}_1, \\mathbf{L}_1)$、$(\\mathbf{R}_1, \\mathbf{L}_2)$、$(\\mathbf{R}_2, \\mathbf{L}_1)$ 和 $(\\mathbf{R}_2, \\mathbf{L}_2)$。给定构象的总能量为 $U = \\sum_{i=1}^2 \\sum_{j=1}^2 U(\\mathbf{R}_i, \\mathbf{L}_j)$，其中 $U(\\mathbf{A}, \\mathbf{B}) = U_{\\mathrm{LJ}}(r_{AB}) + U_{\\mathrm{coul}}(r_{AB})$ 且 $r_{AB} = \\|\\mathbf{A} - \\mathbf{B}\\|$。\n\n首先，我们使用 Lorentz–Berthelot 组合规则确定混合非键参数：\n配体参数：$\\sigma_{\\mathrm{L}} = 0.50\\,\\mathrm{nm}$，$\\epsilon_{\\mathrm{L}} = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n受体参数：$\\sigma_{\\mathrm{R}} = 0.50\\,\\mathrm{nm}$，$\\epsilon_{\\mathrm{R}} = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n对于任何配体-受体对 $(ij)$：\n$$ \\sigma_{ij} = \\frac{\\sigma_{\\mathrm{L}} + \\sigma_{\\mathrm{R}}}{2} = \\frac{0.50\\,\\mathrm{nm} + 0.50\\,\\mathrm{nm}}{2} = 0.50\\,\\mathrm{nm} $$\n$$ \\epsilon_{ij} = \\sqrt{\\epsilon_{\\mathrm{L}} \\epsilon_{\\mathrm{R}}} = \\sqrt{(0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}) \\times (0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1})} = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n因此，所有配体-受体对共享相同的 Lennard-Jones 参数 $\\sigma_{ij} = 0.50\\,\\mathrm{nm}$ 和 $\\epsilon_{ij} = 0.25\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n接下来，我们计算初始状态的能量 $U_o$。初始坐标为：$\\mathbf{R}_1=(0,0,0)$、$\\mathbf{R}_2=(1.0,0,0)$、$\\mathbf{L}_1=(0.5,0.5,0)$ 和 $\\mathbf{L}_2=(0.5,-0.5,0)$。距离为：\n$$ r_{R_1 L_1} = \\|(0.5, 0.5, 0) - (0, 0, 0)\\| = \\sqrt{0.5^2 + 0.5^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n$$ r_{R_1 L_2} = \\|(0.5, -0.5, 0) - (0, 0, 0)\\| = \\sqrt{0.5^2 + (-0.5)^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n$$ r_{R_2 L_1} = \\|(0.5, 0.5, 0) - (1.0, 0, 0)\\| = \\sqrt{(-0.5)^2 + 0.5^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n$$ r_{R_2 L_2} = \\|(0.5, -0.5, 0) - (1.0, 0, 0)\\| = \\sqrt{(-0.5)^2 + (-0.5)^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n所有初始距离都相同， $r_o = \\sqrt{0.5}\\,\\mathrm{nm}$。\n在距离 $r_o$ 处一对原子的 Lennard-Jones 能量为：\n$$ U_{\\mathrm{LJ}}(r_o) = 4 \\epsilon_{ij} \\left[ \\left(\\frac{\\sigma_{ij}}{r_o}\\right)^{12} - \\left(\\frac{\\sigma_{ij}}{r_o}\\right)^6 \\right] = 4(0.25) \\left[ \\left(\\frac{0.50}{\\sqrt{0.5}}\\right)^{12} - \\left(\\frac{0.50}{\\sqrt{0.5}}\\right)^6 \\right] $$\n$$ U_{\\mathrm{LJ}}(r_o) = 1.0 \\left[ \\left(\\frac{1}{\\sqrt{2}}\\right)^{12} - \\left(\\frac{1}{\\sqrt{2}}\\right)^6 \\right] = \\left(\\frac{1}{2^6} - \\frac{1}{2^3}\\right) = \\frac{1}{64} - \\frac{8}{64} = -\\frac{7}{64}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n总的初始 LJ 能量为 $U_{\\mathrm{LJ}, o} = 4 \\times U_{\\mathrm{LJ}}(r_o) = 4 \\times (-\\frac{7}{64}) = -\\frac{7}{16}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n总的初始库仑能量为：\n$$ U_{\\mathrm{coul}, o} = \\frac{k_e}{\\varepsilon_r r_o} \\sum_{i,j} q_{\\mathrm{L}_j} Q_{\\mathrm{R}_i} = \\frac{k_e}{\\varepsilon_r \\sqrt{0.5}} \\left[ (+0.2)(-0.5) + (-0.2)(-0.5) + (+0.2)(-0.5) + (-0.2)(-0.5) \\right] $$\n$$ U_{\\mathrm{coul}, o} = \\frac{k_e}{\\varepsilon_r \\sqrt{0.5}} \\left[ -0.10 + 0.10 - 0.10 + 0.10 \\right] = 0 $$\n因此，总的初始能量为 $U_o = U_{\\mathrm{LJ}, o} + U_{\\mathrm{coul}, o} = -\\frac{7}{16}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$。\n\n现在，我们计算最终状态的能量 $U_n$。提议的移动是绕 $z$ 轴旋转 $\\theta=\\pi/2$，映射为 $(x,y,z) \\to (-y,x,z)$。新的配体坐标为 $\\mathbf{L}_1' = (-0.5, 0.5, 0)$ 和 $\\mathbf{L}_2' = (0.5, 0.5, 0)$。新的距离为：\n$$ r'_{R_1 L_1} = \\|(-0.5, 0.5, 0) - (0, 0, 0)\\| = \\sqrt{(-0.5)^2 + 0.5^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n$$ r'_{R_1 L_2} = \\|(0.5, 0.5, 0) - (0, 0, 0)\\| = \\sqrt{0.5^2 + 0.5^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n$$ r'_{R_2 L_1} = \\|(-0.5, 0.5, 0) - (1.0, 0, 0)\\| = \\sqrt{(-1.5)^2 + 0.5^2} = \\sqrt{2.25 + 0.25} = \\sqrt{2.5}\\,\\mathrm{nm} $$\n$$ r'_{R_2 L_2} = \\|(0.5, 0.5, 0) - (1.0, 0, 0)\\| = \\sqrt{(-0.5)^2 + 0.5^2} = \\sqrt{0.5}\\,\\mathrm{nm} $$\n三对原子距离为 $r_1' = \\sqrt{0.5}\\,\\mathrm{nm}$，一对（R2-L1）距离为 $r_2' = \\sqrt{2.5}\\,\\mathrm{nm}$。\n总的最终 LJ 能量 $U_{\\mathrm{LJ}, n}$ 是这些对的贡献之和。对于距离为 $r_2'=\\sqrt{2.5}$ 的原子对：\n$$ U_{\\mathrm{LJ}}(r_2') = 1.0 \\left[ \\left(\\frac{0.50}{\\sqrt{2.5}}\\right)^{12} - \\left(\\frac{0.50}{\\sqrt{2.5}}\\right)^6 \\right] = \\left(\\frac{1}{\\sqrt{10}}\\right)^{12} - \\left(\\frac{1}{\\sqrt{10}}\\right)^6 = \\frac{1}{10^6} - \\frac{1}{10^3} = -\\frac{999}{10^6}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n总的最终 LJ 能量为：\n$$ U_{\\mathrm{LJ}, n} = 3 \\times U_{\\mathrm{LJ}}(r_1') + 1 \\times U_{\\mathrm{LJ}}(r_2') = 3 \\times \\left(-\\frac{7}{64}\\right) - \\frac{999}{10^6} = -\\frac{21}{64} - 0.000999\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n总的最终库仑能量为：\n$$ U_{\\mathrm{coul}, n} = \\frac{k_e}{\\varepsilon_r} \\left[ \\frac{q_{L_1}Q_{R_1}}{r'_{R_1 L_1}} + \\frac{q_{L_2}Q_{R_1}}{r'_{R_1 L_2}} + \\frac{q_{L_1}Q_{R_2}}{r'_{R_2 L_1}} + \\frac{q_{L_2}Q_{R_2}}{r'_{R_2 L_2}} \\right] $$\n$$ U_{\\mathrm{coul}, n} = \\frac{k_e}{\\varepsilon_r} \\left[ \\frac{(-0.10)}{\\sqrt{0.5}} + \\frac{(+0.10)}{\\sqrt{0.5}} + \\frac{(-0.10)}{\\sqrt{2.5}} + \\frac{(+0.10)}{\\sqrt{0.5}} \\right] = \\frac{k_e}{\\varepsilon_r} \\left[ \\frac{0.10}{\\sqrt{0.5}} - \\frac{0.10}{\\sqrt{2.5}} \\right] $$\n总的最终能量为 $U_n = U_{\\mathrm{LJ}, n} + U_{\\mathrm{coul}, n}$。\n\n能量变化为 $\\Delta U = U_n - U_o = (U_{\\mathrm{LJ}, n} - U_{\\mathrm{LJ}, o}) + (U_{\\mathrm{coul}, n} - U_{\\mathrm{coul}, o})$。\n$$ \\Delta U_{\\mathrm{LJ}} = \\left(-\\frac{21}{64} - 0.000999\\right) - \\left(-\\frac{7}{16}\\right) = -\\frac{21}{64} + \\frac{28}{64} - 0.000999 = \\frac{7}{64} - 0.000999\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ \\Delta U_{\\mathrm{coul}} = U_{\\mathrm{coul}, n} - 0 = 0.10 \\frac{k_e}{\\varepsilon_r} \\left( \\frac{1}{\\sqrt{0.5}} - \\frac{1}{\\sqrt{2.5}} \\right)\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n现在我们代入数值：\n$$ \\Delta U_{\\mathrm{LJ}} = 0.109375 - 0.000999 = 0.108376\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n$$ \\Delta U_{\\mathrm{coul}} = 0.10 \\times \\frac{138.935456}{80} \\left( \\frac{1}{\\sqrt{0.5}} - \\frac{1}{\\sqrt{2.5}} \\right) \\approx 0.173669 \\times (1.414214 - 0.632456) \\approx 0.135753\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n总能量变化：\n$$ \\Delta U = \\Delta U_{\\mathrm{LJ}} + \\Delta U_{\\mathrm{coul}} \\approx 0.108376 + 0.135753 = 0.244129\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n能量变化为正，表明新状态在能量上是不利的。\n\n最后，我们计算接受概率。热能为：\n$$ k_B T = (8.314462618 \\times 10^{-3}\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}) \\times (300\\,\\mathrm{K}) \\approx 2.494339\\,\\mathrm{kJ}\\,\\mathrm{mol}^{-1} $$\n由于 $\\Delta U > 0$，接受概率为：\n$$ P_{acc} = \\exp\\left(-\\frac{\\Delta U}{k_B T}\\right) = \\exp\\left(-\\frac{0.244129}{2.494339}\\right) \\approx \\exp(-0.097873) \\approx 0.90676 $$\n四舍五入到四位有效数字，接受概率为 $0.9068$。",
            "answer": "$$\\boxed{0.9068}$$"
        },
        {
            "introduction": "运行MMC模拟只是完成了一半的工作；确保模拟已经收敛到正确的平衡分布同样至关重要。Gelman-Rubin诊断方法（$\\hat{R}$统计量）通过比较多个并行模拟轨迹的内部方差和轨迹间方差，为评估收敛性提供了一种稳健的统计方法。本练习将指导你计算和解释 $\\hat{R}$ 统计量，这是验证MCMC模拟结果和确保科学结论可靠性的一项基本技能。",
            "id": "3866335",
            "problem": "您的任务是为与计算化学生物学相关的粗粒化聚合物模型设计并实现一个Metropolis蒙特卡洛 (MMC) 算法的接受决策模块，该模块使用针对能量分量的局部缓存策略。其目标是通过避免完整的能量重新计算来加速对小范围局部移动的接受决策，同时保持其精确的正确性。该系统是一个由$N$个珠子组成的二维链，其成对能量项可分解为相邻珠子之间的谐振键能，以及在距离截断值内的非相邻珠子对之间的截断-平移Lennard-Jones非键相互作用的总和。本问题中所有量均为无量纲；无需进行物理单位转换。\n\n基本原理：\n- Metropolis蒙特卡洛 (MMC) 算法以概率 $p_{\\mathrm{acc}} = \\min\\{1, \\exp(-\\beta \\Delta E)\\}$ 接受从当前构型 $\\mathbf{x}$ 到提议构型 $\\mathbf{x}'$ 的转变，其中 $\\Delta E = E(\\mathbf{x}') - E(\\mathbf{x})$，$\\beta$ 是逆温度。\n- 总能量是局部贡献之和。令 $\\mathbf{r}_i \\in \\mathbb{R}^2$ 表示珠子 $i$ 的位置。能量为\n$$\nE(\\mathbf{x}) = \\sum_{i=0}^{N-2} \\frac{1}{2} k_{\\mathrm{b}} \\left(\\lVert \\mathbf{r}_{i+1}-\\mathbf{r}_i \\rVert - r_0 \\right)^2 + \\sum_{i=0}^{N-3} \\sum_{j=i+2}^{N-1} U_{\\mathrm{LJ}}^{\\mathrm{TS}}\\left(\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert\\right),\n$$\n其中谐振键项使用弹簧常数 $k_{\\mathrm{b}}$ 和平衡长度 $r_0$，截断-平移Lennard-Jones势为\n$$\nU_{\\mathrm{LJ}}^{\\mathrm{TS}}(r) = \n\\begin{cases}\n4\\epsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right] - 4\\epsilon\\left[\\left(\\frac{\\sigma}{r_c}\\right)^{12} - \\left(\\frac{\\sigma}{r_c}\\right)^6\\right],  \\text{if } r  r_c, \\\\\n0,  \\text{if } r \\ge r_c,\n\\end{cases}\n$$\n参数为 $\\epsilon$、$\\sigma$ 和截断值 $r_c$；平移确保了连续性，即 $U_{\\mathrm{LJ}}^{\\mathrm{TS}}(r_c)=0$。\n\n任务：\n- 提出并实现一个局部缓存策略，用于存储能量分量，使得当珠子索引为 $k$ 的单个珠子发生局部移动时，只需重新计算受影响的能量项，而无需计算全部能量。具体而言：\n  1. 缓存所有相邻对 $(i, i+1)$ 的谐振键贡献。\n  2. 缓存所有满足 $|i-j|>1$ 且在截断距离 $r_c$ 内的当前对 $(i,j)$ 的非键截断-平移Lennard-Jones贡献。\n  3. 当珠子 $k$ 移动到新位置 $\\mathbf{r}_k'$ 时，仅更新涉及珠子 $k$ 的缓存键能项，并仅更新涉及珠子 $k$ 的缓存非键项（包括添加/删除跨越截断阈值的对）。仅使用这些更新后的项计算精确的能量变化 $\\Delta E$。\n  4. 使用MMC接受准则，根据 $\\Delta E$ 和一个给定的均匀随机变量 $u \\in (0,1)$ 来接受或拒绝该移动，决策规则为：如果 $u  \\min\\{1,\\exp(-\\beta \\Delta E)\\}$ 则接受，否则拒绝。\n  5. 如果接受，则提交缓存更新和新位置；否则，撤销更改。\n\n验证要求：\n- 对于测试套件中的每次提议移动，内部验证通过缓存计算出的 $\\Delta E$ 与完整能量重新计算得到的差值完全匹配，即确认在数值容差范围内 $\\Delta E_{\\mathrm{cache}} = E(\\mathbf{x}') - E(\\mathbf{x})$。\n\n测试套件：\n- 无量纲参数：$N=6$, $k_{\\mathrm{b}}=50.0$, $r_0=1.0$, $\\epsilon=0.2$, $\\sigma=1.0$, $r_c=2.5$, $\\beta=2.0$。\n- 初始位置：$\\mathbf{r}_i = (i\\cdot r_0, 0)$，其中 $i=0,1,\\dots,5$。\n- 依次应用的五个局部移动序列；每次移动指定珠子索引 $j$、位移 $(\\Delta x,\\Delta y)$ 以及用于接受决策的均匀随机变量 $u$：\n  1. 移动珠子 $j=2$，位移为 $(\\Delta x,\\Delta y)=(0.1, 0.05)$，使用 $u=0.1$。\n  2. 移动珠子 $j=0$，位移为 $(\\Delta x,\\Delta y)=(-0.2, 0.0)$，使用 $u=0.5$。\n  3. 移动珠子 $j=3$，位移为 $(\\Delta x,\\Delta y)=(1.0, 1.0)$，使用 $u=0.9$。\n  4. 移动珠子 $j=4$，位移为 $(\\Delta x,\\Delta y)=(0.0, 0.0)$，使用 $u=0.2$。\n  5. 移动珠子 $j=1$，位移为 $(\\Delta x,\\Delta y)=(0.0, 3.0)$，使用 $u=0.3$。\n\n覆盖性设计：\n- 该测试套件包括一个影响键和非键相互作用的小范围局部移动、一个边界珠子的移动、一个可能导致能量大幅增加的大范围移动、一个零位移移动，以及一个导致非键对跨越截断阈值的移动，从而确保缓存能够正确地添加或删除这些对。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含五次移动的接受决策，格式为一个用方括号括起来的逗号分隔列表，并采用标准Python布尔表示法，例如：“[True,False,True,True,False]”。",
            "solution": "问题陈述经评估是有效的。它以统计力学和计算化学的原理为科学基础，问题定义明确且具有唯一的确定性结果，并为获得完整解决方案提供了所有必要的参数和条件。该任务要求为一个粗粒化聚合物链实现Metropolis蒙特卡洛 (MMC) 接受决策模块，特别侧重于对局部单珠移动的能量变化进行高效的、基于缓存的计算。\n\nMetropolis蒙特卡洛算法的核心在于其对从构型 $\\mathbf{x}$ 到 $\\mathbf{x}'$ 的移动的接受准则。该移动被接受的概率为 $p_{\\mathrm{acc}} = \\min\\{1, \\exp(-\\beta \\Delta E)\\}$，其中 $\\Delta E = E(\\mathbf{x}') - E(\\mathbf{x})$ 是总能量的变化，$\\beta$ 是逆温度，在适当的单位下可解释为 $1/(k_B T)$。对于我们的无量纲系统，给定的 $\\beta$ 值为 $2.0$。如果一个均匀随机变量 $u \\in (0,1)$ 满足 $u  p_{\\mathrm{acc}}$，则该移动被接受。\n\n$N$个珠子组成的聚合物链的总能量 $E$ 由两种相互作用的总和给出：相邻珠子之间的谐振键势能，以及非相邻、非键合珠子对之间的截断-平移Lennard-Jones (LJ) 势。设珠子位置为 $\\mathbf{r}_i \\in \\mathbb{R}^2$，其中 $i \\in \\{0, 1, \\dots, N-1\\}$，并使用与测试用例一致的从零开始的索引，能量为：\n$$\nE(\\mathbf{x}) = \\sum_{i=0}^{N-2} U_{\\mathrm{bond}}(\\lVert \\mathbf{r}_{i+1}-\\mathbf{r}_i \\rVert) + \\sum_{i=0}^{N-3} \\sum_{j=i+2}^{N-1} U_{\\mathrm{LJ}}^{\\mathrm{TS}}(\\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert)\n$$\n谐振键势为 $U_{\\mathrm{bond}}(d) = \\frac{1}{2} k_{\\mathrm{b}} (d - r_0)^2$，其中弹簧常数 $k_{\\mathrm{b}}=50.0$，平衡长度 $r_0=1.0$，$d$ 是两个键合珠子之间的距离。\n截断-平移Lennard-Jones势定义为：\n$$\nU_{\\mathrm{LJ}}^{\\mathrm{TS}}(r) =\n\\begin{cases}\nU_{\\mathrm{LJ}}(r) - U_{\\mathrm{LJ}}(r_c),  \\text{if } r  r_c \\\\\n0,  \\text{if } r \\ge r_c\n\\end{cases}\n$$\n其中 $U_{\\mathrm{LJ}}(r) = 4\\epsilon [(\\sigma/r)^{12} - (\\sigma/r)^6]$，参数 $\\epsilon=0.2$, $\\sigma=1.0$，截断距离 $r_c=2.5$。通过 $U_{\\mathrm{LJ}}(r_c)$ 进行的平移确保了势能在截断处为零，从而防止了能量的不连续性。\n\n$\\Delta E$ 的一个朴素计算方法是计算新构型的总能量 $E(\\mathbf{x}')$ 并减去旧构型的总能量 $E(\\mathbf{x})$。对于仅移动单个珠子 $k$ 的局部移动而言，这种方法在计算上是浪费的，因为只有涉及珠子 $k$ 的相互作用项会发生变化。\n\n规定的缓存策略利用了这种局部性。我们预先计算并存储能量分量，当提议移动珠子 $k$ 时，通过仅对受影响分量的变化求和来计算 $\\Delta E$。\n1. **键能缓存**：使用一个大小为 $N-1$ 的一维数组 `bond_cache`，其中 `bond_cache[i]` 存储珠子 $i$ 和 $i+1$ 之间键的能量。\n2. **非键能量缓存**：使用一个字典（哈希映射）`nonbonded_cache`。它存储键值对，其中键是元组 `(i, j)` (其中 $i  j$)，值为对应的非键能量。\n当移动珠子 $k$ 时，$\\Delta E$ 的计算如下：\n*   **键能变化**：计算珠子 $k$ 涉及的两个键（即 $(k-1, k)$ 和 $(k, k+1)$，如果存在）的新能量。$\\Delta E$ 中累加这些新能量与从 `bond_cache` 中检索到的旧能量之间的差值。\n*   **非键能变化**：对于所有其他珠子 $i$（其中 $|i-k| > 1$），计算新的 $(i, k)$ 对的非键能量。$\\Delta E$ 中累加这个新能量与从 `nonbonded_cache` 中检索到的旧能量（如果存在）之间的差值。\n*   **更新**：如果移动被接受，则将所有计算出的新分量能量更新到相应的缓存中。如果一个非键对的能量变为零（例如，因为它跨越了截断距离），则应从缓存中删除该条目。如果移动被拒绝，则缓存保持不变。\n\n这种方法确保了 $\\Delta E$ 的计算复杂度为 $O(N)$，而不是朴素方法的 $O(N^2)$，这对于大型系统来说是一个显著的加速。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the polymer Metropolis Monte Carlo problem with a local caching strategy.\n    \"\"\"\n\n    class PolymerMC:\n        \"\"\"\n        Encapsulates the state and methods for a Metropolis Monte Carlo simulation\n        of a coarse-grained polymer chain using a caching strategy.\n        \"\"\"\n        def __init__(self, N, k_b, r_0, epsilon, sigma, r_c, beta, initial_positions):\n            # System parameters\n            self.N = int(N)\n            self.k_b = float(k_b)\n            self.r_0 = float(r_0)\n            self.epsilon = float(epsilon)\n            self.sigma = float(sigma)\n            self.r_c = float(r_c)\n            self.beta = float(beta)\n\n            # Pre-calculate the LJ shift value for efficiency\n            self.V_shift = 4.0 * self.epsilon * (\n                (self.sigma / self.r_c)**12 - (self.sigma / self.r_c)**6\n            )\n\n            # System state\n            self.positions = np.array(initial_positions, dtype=float)\n\n            # Energy caches\n            self.bond_cache = np.zeros(self.N - 1, dtype=float)\n            self.nonbonded_cache = {}  # Using a dictionary: (i, j) → energy\n\n            self._initialize_energy_caches()\n\n        def _U_bond(self, dist):\n            \"\"\"Calculates the harmonic bond potential energy.\"\"\"\n            return 0.5 * self.k_b * (dist - self.r_0)**2\n\n        def _U_ljts(self, dist):\n            \"\"\"Calculates the truncated-shifted Lennard-Jones potential energy.\"\"\"\n            if dist >= self.r_c or dist = 0:\n                return 0.0\n            \n            s_over_r_6 = (self.sigma / dist)**6\n            s_over_r_12 = s_over_r_6**2\n            \n            return 4.0 * self.epsilon * (s_over_r_12 - s_over_r_6) - self.V_shift\n\n        def _initialize_energy_caches(self):\n            \"\"\"Calculates initial energies and populates the caches.\"\"\"\n            # Bond energy cache\n            for i in range(self.N - 1):\n                dist = np.linalg.norm(self.positions[i+1] - self.positions[i])\n                self.bond_cache[i] = self._U_bond(dist)\n\n            # Non-bonded energy cache\n            self.nonbonded_cache.clear()\n            for i in range(self.N):\n                for j in range(i + 2, self.N):\n                    dist = np.linalg.norm(self.positions[j] - self.positions[i])\n                    if dist  self.r_c:\n                        self.nonbonded_cache[(i, j)] = self._U_ljts(dist)\n\n        def get_total_energy_from_scratch(self, positions):\n            \"\"\"Computes the total energy of the system from scratch for verification.\"\"\"\n            bond_energy = 0.0\n            for i in range(self.N - 1):\n                dist = np.linalg.norm(positions[i+1] - positions[i])\n                bond_energy += self._U_bond(dist)\n            \n            nonbonded_energy = 0.0\n            for i in range(self.N):\n                for j in range(i + 2, self.N):\n                    dist = np.linalg.norm(positions[j] - positions[i])\n                    nonbonded_energy += self._U_ljts(dist)\n            \n            return bond_energy + nonbonded_energy\n\n        def attempt_move(self, bead_idx, displacement, u):\n            \"\"\"\n            Proposes a move, calculates dE using caching, and applies the MMC rule.\n            \"\"\"\n            old_pos = self.positions[bead_idx]\n            new_pos = old_pos + displacement\n            delta_E_cache = 0.0\n\n            # --- Calculate delta E using cache ---\n            \n            # Bond energy changes\n            new_bond_energies = {}\n            # Left bond\n            if bead_idx > 0:\n                old_E_bond_left = self.bond_cache[bead_idx - 1]\n                dist_new = np.linalg.norm(new_pos - self.positions[bead_idx - 1])\n                new_E_bond_left = self._U_bond(dist_new)\n                delta_E_cache += new_E_bond_left - old_E_bond_left\n                new_bond_energies[bead_idx - 1] = new_E_bond_left\n            # Right bond\n            if bead_idx  self.N - 1:\n                old_E_bond_right = self.bond_cache[bead_idx]\n                dist_new = np.linalg.norm(self.positions[bead_idx + 1] - new_pos)\n                new_E_bond_right = self._U_bond(dist_new)\n                delta_E_cache += new_E_bond_right - old_E_bond_right\n                new_bond_energies[bead_idx] = new_E_bond_right\n\n            # Non-bonded energy changes\n            nb_updates = {}\n            for i in range(self.N):\n                if abs(i - bead_idx) = 1:\n                    continue\n                \n                pair = tuple(sorted((i, bead_idx)))\n                old_E_nb = self.nonbonded_cache.get(pair, 0.0)\n                \n                new_dist = np.linalg.norm(new_pos - self.positions[i])\n                new_E_nb = self._U_ljts(new_dist)\n                \n                delta_E_cache += new_E_nb - old_E_nb\n                nb_updates[pair] = new_E_nb\n\n            # --- Internal Verification ---\n            test_positions = self.positions.copy()\n            test_positions[bead_idx] = new_pos\n            E_old_full = self.get_total_energy_from_scratch(self.positions)\n            E_new_full = self.get_total_energy_from_scratch(test_positions)\n            delta_E_full = E_new_full - E_old_full\n            assert np.isclose(delta_E_cache, delta_E_full, atol=1e-9), \\\n                f\"Cache-based dE ({delta_E_cache}) != Full dE ({delta_E_full})\"\n\n            # --- Metropolis Acceptance Criterion ---\n            accept = False\n            if delta_E_cache = 0.0:\n                accept = True\n            else:\n                p_acc = np.exp(-self.beta * delta_E_cache)\n                if u  p_acc:\n                    accept = True\n            \n            # --- Update State if Accepted ---\n            if accept:\n                self.positions[bead_idx] = new_pos\n                # Commit bond cache updates\n                for i, energy in new_bond_energies.items():\n                    self.bond_cache[i] = energy\n                # Commit non-bonded cache updates\n                for pair, energy in nb_updates.items():\n                    if np.isclose(energy, 0.0):\n                        self.nonbonded_cache.pop(pair, None)\n                    else:\n                        self.nonbonded_cache[pair] = energy\n\n            return accept\n\n    # Define the test cases from the problem statement.\n    params = {\n        'N': 6, 'k_b': 50.0, 'r_0': 1.0, \n        'epsilon': 0.2, 'sigma': 1.0, 'r_c': 2.5, 'beta': 2.0\n    }\n    initial_positions = [(i * params['r_0'], 0.0) for i in range(params['N'])]\n    \n    moves = [\n        {'j': 2, 'disp': (0.1, 0.05), 'u': 0.1},\n        {'j': 0, 'disp': (-0.2, 0.0), 'u': 0.5},\n        {'j': 3, 'disp': (1.0, 1.0), 'u': 0.9},\n        {'j': 4, 'disp': (0.0, 0.0), 'u': 0.2},\n        {'j': 1, 'disp': (0.0, 3.0), 'u': 0.3},\n    ]\n\n    # Initialize the simulation\n    mc_system = PolymerMC(**params, initial_positions=initial_positions)\n    \n    results = []\n    for move in moves:\n        decision = mc_system.attempt_move(\n            bead_idx=move['j'],\n            displacement=np.array(move['disp']),\n            u=move['u']\n        )\n        results.append(decision)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "运行MMC模拟只是完成了一半的工作；确保模拟已经收敛到正确的平衡分布同样至关重要。Gelman-Rubin诊断方法（$\\hat{R}$统计量）通过比较多个并行模拟轨迹的内部方差和轨迹间方差，为评估收敛性提供了一种稳健的统计方法。本练习将指导你计算和解释 $\\hat{R}$ 统计量，这是验证MCMC模拟结果和确保科学结论可靠性的一项基本技能。",
            "id": "3866365",
            "problem": "一个结合在酶活性位点的小分子配体在恒定温度 $T$ 下使用 Metropolis 算法进行模拟，其目标分布为玻尔兹曼分布，概率密度正比于 $\\exp(-\\beta E(\\mathbf{x}))$，其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$E(\\mathbf{x})$ 是构象 $\\mathbf{x}$ 的势能，并且移动是从一个对称的提议分布中提出的。考虑一个标量可观测量 $h(\\mathbf{x})$，它报告了快照中蛋白质-配体氢键的瞬时数量。运行了四条独立的 Metropolis 轨迹，每条轨迹都从过分散的构象开始初始化，并从每条轨迹中收集了 $n = 50$ 个“老化期”后的样本。$h$ 的每条轨迹的样本均值为\n$$\\bar{h}_1 = 2.90,\\quad \\bar{h}_2 = 3.10,\\quad \\bar{h}_3 = 3.35,\\quad \\bar{h}_4 = 3.65,$$\n相应的每条轨迹的样本方差为\n$$s_1^2 = 0.50,\\quad s_2^2 = 0.55,\\quad s_3^2 = 0.65,\\quad s_4^2 = 0.70.$$\n从 Metropolis 蒙特卡洛的玻尔兹曼目标分布、马尔可夫链蒙特卡洛（MCMC）的平稳性收敛思想以及全方差定律的基本定义出发，推导出来自 $m$ 条独立 Metropolis 轨迹的标量可观测量的 Gelman-Rubin 势能标度缩减因子 $\\hat{R}$，然后根据给定的数据计算 $\\hat{R}$。解释计算出的值在计算化学生物学中收敛性评估方面的意义。将最终数值答案四舍五入至四位有效数字，并以无量纲数表示。",
            "solution": "该问题要求推导 Gelman-Rubin 势能标度缩减因子 $\\hat{R}$，根据给定的模拟数据进行计算，并解释结果。这个问题具有科学依据，提法明确且客观，并提供了所有必要的数据。因此，我们开始求解。\n\nGelman-Rubin 诊断是马尔可夫链蒙特卡洛（MCMC）模拟的一种收敛性诊断方法。它通过比较多个并行链的内部方差与这些链之间的方差来评估收敛性。其基本前提是，如果所有链都已收敛到目标平稳分布（此处为玻尔兹曼分布），那么它们各自的统计特性应彼此无法区分，也无法与它们混合后的特性区分。$\\hat{R}$ 的推导植根于这种比较，其概念源于全方差定律。\n\n设 $h$ 为我们感兴趣的标量可观测量，即蛋白质-配体氢键的数量。我们有 $m$ 条独立的 MCMC 轨迹（链），从每条链 $i$（其中 $i=1, \\dots, m$）中，我们收集 $n$ 个“老化期”后的样本，记为 $h_{ij}$，其中 $j=1, \\dots, n$。\n\n目标是估计可观测量在平稳分布下的真实方差 $\\sigma^2 = \\text{Var}(h)$。Gelman-Rubin 方法为 $\\sigma^2$ 构建了两个估计量。\n\n首先，我们估计每条链*内部*的方差。链 $i$ 的样本均值为：\n$$ \\bar{h}_i = \\frac{1}{n} \\sum_{j=1}^{n} h_{ij} $$\n链 $i$ 的样本方差为：\n$$ s_i^2 = \\frac{1}{n-1} \\sum_{j=1}^{n} (h_{ij} - \\bar{h}_i)^2 $$\n合并的链内方差 $W$ 是这些单个样本方差的平均值：\n$$ W = \\frac{1}{m} \\sum_{i=1}^{m} s_i^2 $$\n如果链尚未探索整个状态空间（即它们尚未完全收敛），那么每个 $s_i^2$ 都是平稳分布受限部分内部方差的估计。因此，$W$ 很可能是对真实总方差 $\\sigma^2$ 的*低估*。\n\n其次，我们估计链*之间*的方差。这通过链的样本均值的方差来捕捉。所有链的所有样本的总均值为：\n$$ \\bar{h} = \\frac{1}{m} \\sum_{i=1}^{m} \\bar{h}_i = \\frac{1}{mn} \\sum_{i=1}^{m} \\sum_{j=1}^{n} h_{ij} $$\n链间方差 $B$ 定义为链均值的缩放样本方差：\n$$ B = \\frac{n}{m-1} \\sum_{i=1}^{m} (\\bar{h}_i - \\bar{h})^2 $$\n缩放因子 $n$ 确保 $B$ 是 $\\sigma^2$ 的估计量，而不是 $\\sigma^2/n$ 的估计量。如果链从过分散的位置开始，那么链均值 $\\bar{h}_i$ 的分布会比从单一分布中纯粹抽样误差所预期的更广。这意味着 $B$ 提供了关于链之间已探索的状态空间部分的信息。\n\n全方差定律为组合这些方差分量提供了概念基础。对于一个随机变量 $Y$ 和一个分组变量 $X$，有 $\\text{Var}(Y) = E[\\text{Var}(Y|X)] + \\text{Var}(E[Y|X])$。在我们的情境中，$Y$ 是可观测量 $h$，$X$ 是链的索引 $i$。$W$ 是第一项 $E_i[\\text{Var}(h|\\text{chain } i)]$ 的基于样本的估计量。$B/n$ 是与第二项 $\\text{Var}_i(E[h|\\text{chain } i])$ 相关的基于样本的估计量。\n\nGelman 和 Rubin 提出了目标方差的合并估计量 $\\hat{\\sigma}^2_+$，它是 $W$ 和 $B$ 的加权平均值：\n$$ \\hat{\\sigma}^2_+ = \\frac{n-1}{n} W + \\frac{1}{n} B $$\n这个量代表了由所有 $m$ 条链合并形成的混合分布中可观测量方差的估计。如果链相对于目标分布是从过分散的起始点开始的，那么这个混合分布会比目标分布本身更宽，至少在链完全收敛之前是这样。因此，$\\hat{\\sigma}^2_+$ 预期会是真实方差 $\\sigma^2$ 的*高估*。\n\n势能标度缩减因子 $\\hat{R}$ 定义为高估的方差与低估的方差之比。它量化了如果模拟运行更长时间，当前分布的尺度（由 $\\sqrt{\\hat{\\sigma}^2_+}$ 估计）可能缩减的潜力。\n$$ \\hat{R} = \\sqrt{\\frac{\\hat{\\sigma}^2_+}{W}} $$\n代入 $\\hat{\\sigma}^2_+$ 的表达式：\n$$ \\hat{R} = \\sqrt{\\frac{\\frac{n-1}{n} W + \\frac{1}{n} B}{W}} = \\sqrt{\\frac{n-1}{n} + \\frac{B}{nW}} $$\n随着链的收敛，链均值 $\\bar{h}_i$ 都趋近于真实均值 $\\mu_h$，因此 $B$ 趋近于 $W$。在极限情况下，$B \\to W$，且 $\\hat{R} \\to \\sqrt{\\frac{n-1}{n} + \\frac{W}{nW}} = \\sqrt{\\frac{n-1}{n} + \\frac{1}{n}} = \\sqrt{1} = 1$。因此，接近 1 的 $\\hat{R}$ 值表示收敛。\n\n现在，我们根据给定的数据计算 $\\hat{R}$。\n已知：\n轨迹数 $m = 4$。\n每条轨迹的样本数 $n = 50$。\n每条轨迹的均值：$\\bar{h}_1 = 2.90$，$\\bar{h}_2 = 3.10$，$\\bar{h}_3 = 3.35$，$\\bar{h}_4 = 3.65$。\n每条轨迹的方差：$s_1^2 = 0.50$，$s_2^2 = 0.55$，$s_3^2 = 0.65$，$s_4^2 = 0.70$。\n\n首先，计算合并的链内方差 $W$：\n$$ W = \\frac{1}{m} \\sum_{i=1}^{m} s_i^2 = \\frac{1}{4} (0.50 + 0.55 + 0.65 + 0.70) = \\frac{2.40}{4} = 0.60 $$\n\n接下来，计算链间方差 $B$。我们首先需要总均值 $\\bar{h}$：\n$$ \\bar{h} = \\frac{1}{m} \\sum_{i=1}^{m} \\bar{h}_i = \\frac{1}{4} (2.90 + 3.10 + 3.35 + 3.65) = \\frac{13.00}{4} = 3.25 $$\n现在，我们计算 $B$：\n$$ B = \\frac{n}{m-1} \\sum_{i=1}^{m} (\\bar{h}_i - \\bar{h})^2 $$\n$$ B = \\frac{50}{4-1} \\left[ (2.90 - 3.25)^2 + (3.10 - 3.25)^2 + (3.35 - 3.25)^2 + (3.65 - 3.25)^2 \\right] $$\n$$ B = \\frac{50}{3} \\left[ (-0.35)^2 + (-0.15)^2 + (0.10)^2 + (0.40)^2 \\right] $$\n$$ B = \\frac{50}{3} \\left[ 0.1225 + 0.0225 + 0.0100 + 0.1600 \\right] $$\n$$ B = \\frac{50}{3} (0.3150) = 50 \\times 0.1050 = 5.25 $$\n\n最后，我们计算 $\\hat{R}$：\n$$ \\hat{R} = \\sqrt{\\frac{n-1}{n} + \\frac{B}{nW}} = \\sqrt{\\frac{50-1}{50} + \\frac{5.25}{50 \\times 0.60}} $$\n$$ \\hat{R} = \\sqrt{\\frac{49}{50} + \\frac{5.25}{30}} = \\sqrt{0.98 + 0.175} = \\sqrt{1.155} $$\n$$ \\hat{R} \\approx 1.07470926 \\dots $$\n四舍五入到四位有效数字，我们得到 $\\hat{R} = 1.075$。\n\n结果解释：\n$\\hat{R} \\approx 1.075$ 这个值是可观测量 $h(\\mathbf{x})$（氢键数量）收敛性的一个度量。理想值为 $\\hat{R}=1.0$，这表示链间方差与链内方差一致，表明所有链都在从同一个分布中采样。在实践中，通常使用一个阈值（例如 $\\hat{R}  1.1$）来判断是否收敛。\n计算出的值 $1.075$ 接近这个常用阈值，但仍然表明链之间存在显著差异。具体来说，这意味着所有链的混合方差大约是链内平均方差的 $1.155$ 倍 ($=\\hat{R}^2$)。这表明链尚未完全混合并忘记其过分散的起始点。四条轨迹的平均氢键数量的变化（从 $2.90$ 到 $3.65$）比所有链都从单个已收敛的平稳分布中抽样时所预期的要大。在计算化学生物学的严格分析中，这个值表明需要延长模拟时间（即收集更多样本），以提高对计算出的平均值 $\\bar{h}=3.25$ 及其他相关统计数据的置信度。采样可能不完整，在 $\\hat{R}$ 更接近 $1.0$ 之前，应谨慎地对氢键模式得出定量结论。",
            "answer": "$$\\boxed{1.075}$$"
        }
    ]
}