{
    "hands_on_practices": [
        {
            "introduction": "The heart of the simulated annealing algorithm is its decision-making engine: the Metropolis acceptance criterion. This rule allows the simulation to not only accept moves that decrease energy but also, with a certain probability, to accept \"uphill\" moves that increase it. This exercise provides a foundational, quantitative look at this crucial step, allowing you to calculate the acceptance probability for a specific energy change at a given temperature and see how thermal energy $k_B T$ directly modulates the algorithm's willingness to escape a local energy minimum. ",
            "id": "3863444",
            "problem": "In computational chemical biology, simulated annealing (SA) is often used to explore conformational states of biomolecular systems while approximately sampling from the canonical ensemble at temperature $T$. Consider a Metropolis-type update within Simulated Annealing (SA) viewed as a special case of Markov Chain Monte Carlo (MCMC), where trial moves are proposed from a symmetric generator (the probability of proposing $x \\to x'$ equals that of $x' \\to x$). Assume the equilibrium distribution over conformations is the Boltzmann distribution, proportional to $\\exp(-E/(k_B T))$, where $E$ is the potential energy, $k_B$ is the Boltzmann constant, and $T$ is the absolute temperature.\n\nA single proposed move changes the energy from $E=12.4$ kcal/mol to $E' = 13.1$ kcal/mol at $T = 600$ K. Use $k_B = 0.001987$ kcal/mol/K. Starting only from the canonical ensemble and the requirement of detailed balance, determine the correct acceptance probability for this uphill move. Express your final answer as a pure number (unitless), and round your answer to four significant figures.",
            "solution": "The fundamental base is the canonical ensemble and the detailed balance condition for Markov Chain Monte Carlo (MCMC). At fixed temperature $T$, the canonical distribution assigns to a microstate $x$ with energy $E(x)$ the probability\n$$\n\\pi(x) \\propto \\exp\\!\\left(-\\frac{E(x)}{k_B T}\\right).\n$$\nIn a Metropolis-type MCMC with a symmetric proposal kernel $q(x \\to x') = q(x' \\to x)$, the transition probability factorizes as $P(x \\to x') = q(x \\to x')\\, a(x \\to x')$, where $a(x \\to x')$ is the acceptance probability. Detailed balance requires\n$$\n\\pi(x)\\, P(x \\to x') = \\pi(x')\\, P(x' \\to x),\n$$\nwhich, with symmetry of $q$, reduces to\n$$\n\\pi(x)\\, a(x \\to x') = \\pi(x')\\, a(x' \\to x).\n$$\nTaking the ratio yields\n$$\n\\frac{a(x \\to x')}{a(x' \\to x)} = \\frac{\\pi(x')}{\\pi(x)} = \\exp\\!\\left(-\\frac{E(x') - E(x)}{k_B T}\\right).\n$$\nA standard choice that satisfies this ratio and keeps $0 \\leq a \\leq 1$ is the Metropolis acceptance rule\n$$\na(x \\to x') = \\min\\!\\left(1, \\exp\\!\\left(-\\frac{E(x') - E(x)}{k_B T}\\right)\\right).\n$$\nFor an uphill move, where $E' > E$, the acceptance probability becomes\n$$\na = \\exp\\!\\left(-\\frac{E' - E}{k_B T}\\right).\n$$\n\nFor the given move, compute the energy difference\n$$\n\\Delta E = E' - E = 13.1 - 12.4 = 0.7 \\text{ kcal/mol}.\n$$\nCompute the product $k_B T$:\n$$\nk_B T = (0.001987) \\times (600) = 1.1922 \\text{ kcal/mol}.\n$$\nThus the dimensionless exponent is\n$$\n\\frac{\\Delta E}{k_B T} = \\frac{0.7}{1.1922} = 0.58714978\\ldots\n$$\nand the acceptance probability is\n$$\na = \\exp\\!\\left(-0.58714978\\ldots\\right) \\approx 0.5559094928\\ldots\n$$\nRounded to four significant figures, the acceptance probability is\n$$\n0.5559.\n$$\nThis value is unitless, as required.",
            "answer": "$$\\boxed{0.5559}$$"
        },
        {
            "introduction": "Beyond the acceptance probability, the effectiveness of simulated annealing hinges on how it explores the solution space, which is defined by the \"neighborhood\" or move set. A well-designed neighborhood ensures that the algorithm can transition between all relevant configurations, a property known as ergodicity. This problem explores a scenario with a highly restricted neighborhood to demonstrate a critical principle: even with a perfect cooling schedule, a poorly connected search space can severely hinder the algorithm's ability to find the global minimum. ",
            "id": "2202527",
            "problem": "A system can exist in one of six possible configurations, labeled {A, B, C, D, E, F}. A physicist is using a Simulated Annealing (SA) algorithm to find the configuration with the minimum energy. The energy, $E$, for each configuration is given as:\n$E(A) = 10$, $E(B) = 2$, $E(C) = 8$, $E(D) = 0$, $E(E) = 12$, $E(F) = 15$.\n\nThe SA algorithm works in steps. At each step, starting from a current configuration, it proposes a move to a new configuration. The set of possible new configurations, called the neighborhood, is very restricted. The allowed transitions are only between adjacent configurations in the sequence F-E-D-C-B-A. Specifically:\n- From A, one can only move to B.\n- From B, one can move to A or C.\n- From C, one can move to B or D.\n- From D, one can move to C or E.\n- From E, one can move to D or F.\n- From F, one can only move to E.\n\nAt a particular point, the algorithm has found the configuration B, and the annealing temperature is fixed for this step at $T=3$ (in units where the Boltzmann constant $k_B=1$). In the next step of the algorithm, a neighboring configuration is chosen uniformly at random from the set of allowed transitions. This proposed move is then accepted or rejected based on the Metropolis criterion:\n- If the change in energy, $\\Delta E = E_{new} - E_{current}$, is less than or equal to zero, the move is always accepted.\n- If $\\Delta E > 0$, the move is accepted with a probability of $P_{accept} = \\exp(-\\Delta E / T)$.\nIf a proposed move is rejected, the system remains in its current configuration.\n\nGiven that the system is currently in configuration B, calculate the total probability that the algorithm will transition to a different configuration in this single step. Round your final answer to three significant figures.",
            "solution": "We are at configuration B with energy $E(B)=2$. From B, the allowed neighboring configurations are A and C, chosen uniformly, so each is proposed with probability $1/2$.\n\nFor a proposed move to A:\n- The energy change is $\\Delta E_{B\\to A} = E(A) - E(B) = 10 - 2 = 8 > 0$.\n- With $T=3$ and $k_{B}=1$, the Metropolis acceptance probability is $P_{\\text{acc}}(B\\to A) = \\exp\\!\\left(-\\frac{\\Delta E}{T}\\right) = \\exp\\!\\left(-\\frac{8}{3}\\right)$.\n\nFor a proposed move to C:\n- The energy change is $\\Delta E_{B\\to C} = E(C) - E(B) = 8 - 2 = 6 > 0$.\n- The acceptance probability is $P_{\\text{acc}}(B\\to C) = \\exp\\!\\left(-\\frac{6}{3}\\right) = \\exp(-2)$.\n\nThe total probability to transition away from B in this step equals the sum over neighbors of the proposal probability times the acceptance probability:\n$$\nP_{\\text{move}}=\\frac{1}{2}\\exp\\!\\left(-\\frac{8}{3}\\right)+\\frac{1}{2}\\exp(-2).\n$$\nEvaluating numerically,\n$$\n\\exp(-2)\\approx 0.135335283,\\quad \\exp\\!\\left(-\\frac{8}{3}\\right)\\approx 0.06948345,\n$$\nso\n$$\nP_{\\text{move}}\\approx \\frac{1}{2}\\left(0.06948345+0.135335283\\right)\\approx 0.102409\\;\\;\\to\\;\\;0.102\\text{ (three significant figures)}.\n$$",
            "answer": "$$\\boxed{0.102}$$"
        },
        {
            "introduction": "This capstone practice challenges you to synthesize all the core components of simulated annealing—a statistical energy function, a proposal generation scheme, the Metropolis criterion, and a cooling schedule—into a functional algorithm for a real-world scientific application. You will implement an SA-based docking simulation to compare two different solvent models, exploring how different physical assumptions encoded in the energy function affect the search for a ligand's optimal binding pose. This exercise bridges the gap from theoretical concepts to hands-on implementation and data analysis, a vital skill in computational chemical biology. ",
            "id": "3863491",
            "problem": "You are tasked with implementing and analyzing a Simulated Annealing (SA) algorithm to compare ligand docking using two solvent energy models within a simplified computational chemical biology framework. The comparison focuses on acceptance statistics and convergence of final binding energies for an identical ligand-receptor system. All relevant variables in this task must be treated rigorously in LaTeX.\n\nScientific foundation and modeling assumptions: Begin from the canonical ensemble principle, where a microstate with energy $E(\\mathbf{x})$ has probability proportional to $\\exp\\!\\left(-E(\\mathbf{x})/(k_{\\mathrm{B}}T)\\right)$, with Boltzmann constant $k_{\\mathrm{B}}$ and absolute temperature $T$. In the Metropolis criterion, a proposed move from $\\mathbf{x}$ to $\\mathbf{x}'$ with energy change $\\Delta E = E(\\mathbf{x}') - E(\\mathbf{x})$ is accepted with probability $p_{\\mathrm{acc}} = \\min\\!\\left(1, \\exp\\!\\left(-\\Delta E / (k_{\\mathrm{B}}T)\\right)\\right)$. For algorithmic convenience in simulated annealing, use the thermal energy $K = k_{\\mathrm{B}}T$ directly; $K$ is measured in kilocalories per mole ($\\mathrm{kcal/mol}$), ensuring dimensional consistency for $\\exp(-\\Delta E/K)$.\n\nSystem definition: Represent the ligand pose by a vector $\\mathbf{x} \\in \\mathbb{R}^d$. The receptor binding pocket is centered at $\\mathbf{x}^\\ast = \\mathbf{0}$. The baseline receptor-ligand interaction energy is defined by\n$$\nE_{\\mathrm{bind}}(\\mathbf{x}) = \\sum_{i=1}^{d} w_i x_i^2 + \\sum_{i=1}^{d} A \\cos(\\beta x_i),\n$$\nwhere $w_i = 1 + 0.1(i-1)$ induces anisotropy, $A = 0.2$ and $\\beta = 3.0$ are fixed ruggedness parameters. This represents a harmonic attraction to the pocket center plus soft periodic roughness to mimic steric corrugation.\n\nTwo solvent models must be implemented:\n\n1. Implicit solvent model based on Solvent Accessible Surface Area (SASA): Define\n$$\nE_{\\mathrm{imp}}(\\mathbf{x}) = E_{\\mathrm{bind}}(\\mathbf{x}) + \\gamma \\lVert \\mathbf{x} - \\mathbf{x}^\\ast \\rVert_2,\n$$\nwhere $\\gamma$ (in $\\mathrm{kcal/mol}$ per unit displacement) scales a desolvation-like penalty that increases with displacement from the pocket center.\n\n2. Explicit solvent occupancy model: Let $\\{\\mathbf{y}_k\\}_{k=1}^{N_w}$ be fixed water occupancy positions and $s_w$ be a characteristic length scale. Define\n$$\nE_{\\mathrm{exp}}(\\mathbf{x}) = E_{\\mathrm{bind}}(\\mathbf{x}) + \\delta \\sum_{k=1}^{N_w} \\exp\\!\\left(-\\frac{\\lVert \\mathbf{x} - \\mathbf{y}_k \\rVert_2^2}{2 s_w^2}\\right),\n$$\nwhere $\\delta$ (in $\\mathrm{kcal/mol}$) scales the strength of structured-water interactions localized near $\\mathbf{y}_k$; this term penalizes configurations that coincide with high water occupancy.\n\nSimulated Annealing protocol: Starting from $\\mathbf{x}_0$, iterate over a temperature schedule using thermal energy $K$:\n\n- Initialization: Set $\\mathbf{x} \\leftarrow \\mathbf{x}_0$, where $\\mathbf{x}_0$ has all components equal to $1.0$.\n\n- Proposal distribution: At each attempt, propose $\\mathbf{x}' = \\mathbf{x} + \\boldsymbol{\\eta}$, where $\\boldsymbol{\\eta} \\sim \\mathcal{N}\\!\\left(\\mathbf{0}, \\sigma^2(K) \\mathbf{I}\\right)$ with $\\sigma(K) = s_{\\mathrm{step}} \\sqrt{K}$ and $s_{\\mathrm{step}} = 0.25$.\n\n- Acceptance: Accept with probability $p_{\\mathrm{acc}} = \\min\\!\\left(1, \\exp\\!\\left(-\\Delta E / K\\right)\\right)$ computed using the appropriate $E(\\mathbf{x})$ for each solvent model.\n\n- Cooling schedule: Use a geometric cooling $K_{t+1} = \\alpha K_t$, starting from $K_0 = T_0$ (thermal energy) with $0 < \\alpha < 1$.\n\n- Randomness: Use a fixed seed of $42$ to ensure reproducibility of the Gaussian proposals, and apply the same proposals to both models at each iteration to enable direct comparability.\n\nOutputs to compute for each test case:\n\n- Overall acceptance fraction for the implicit solvent model, $a_{\\mathrm{imp}}$, computed as total accepted moves divided by total proposals.\n\n- Overall acceptance fraction for the explicit solvent model, $a_{\\mathrm{exp}}$.\n\n- Final binding energy for the implicit solvent, $E_{\\mathrm{imp,final}}$ in $\\mathrm{kcal/mol}$, reported as the energy of the final state at the end of annealing.\n\n- Final binding energy for the explicit solvent, $E_{\\mathrm{exp,final}}$ in $\\mathrm{kcal/mol}$.\n\n- Final energy difference $E_{\\mathrm{exp,final}} - E_{\\mathrm{imp,final}}$ in $\\mathrm{kcal/mol}$.\n\n- Convergence indicator for each model: Define convergence as the standard deviation of the last $K_{\\mathrm{tail}}$ sampled energies being strictly less than a threshold $\\tau$, i.e., \n$$\n\\mathrm{std}\\left(\\{E_t\\}_{t=T-L+1}^{T}\\right)  \\tau,\n$$\nwhere $L = \\min(50, N_{\\mathrm{iter}})$ is the tail length and $N_{\\mathrm{iter}}$ is the total number of proposals. Use $\\tau = 0.05$ $\\mathrm{kcal/mol}$.\n\nUnits: All energies must be handled and reported in $\\mathrm{kcal/mol}$; no angles are used.\n\nAlgorithmic parameters for all runs: The number of temperature levels is fixed to $N_T = 20$. At each level, perform a fixed number of proposals. The total number of proposals is $N_{\\mathrm{iter}} = N_T \\times \\text{steps\\_per\\_T}$.\n\nTest suite: Implement the following four test cases. Each test case is a tuple $(d, T_0, \\alpha, \\text{steps\\_per\\_T}, \\gamma, \\delta, s_w, \\{\\mathbf{y}_k\\})$ with all numbers in $\\mathrm{kcal/mol}$ for $T_0$, $\\gamma$, and $\\delta$.\n\n- Case $1$ (general scenario): $d = 3$, $T_0 = 5.0$, $\\alpha = 0.85$, $\\text{steps\\_per\\_T} = 200$, $\\gamma = 0.4$, $\\delta = 0.6$, $s_w = 0.35$, $\\{\\mathbf{y}_k\\} = \\{(0.3, 0.0, 0.0), (-0.2, 0.25, -0.1)\\}$.\n\n- Case $2$ (high implicit solvent penalty): $d = 2$, $T_0 = 3.5$, $\\alpha = 0.90$, $\\text{steps\\_per\\_T} = 180$, $\\gamma = 1.2$, $\\delta = 0.2$, $s_w = 0.30$, $\\{\\mathbf{y}_k\\} = \\{(0.1, -0.1), (0.5, 0.0)\\}$.\n\n- Case $3$ (low-temperature boundary): $d = 3$, $T_0 = 0.25$, $\\alpha = 0.90$, $\\text{steps\\_per\\_T} = 220$, $\\gamma = 0.8$, $\\delta = 0.8$, $s_w = 0.20$, $\\{\\mathbf{y}_k\\} = \\{(0.0, 0.0, 0.0)\\}$.\n\n- Case $4$ (no solvent effect baseline): $d = 2$, $T_0 = 4.0$, $\\alpha = 0.80$, $\\text{steps\\_per\\_T} = 100$, $\\gamma = 0.0$, $\\delta = 0.0$, $s_w = 0.30$, $\\{\\mathbf{y}_k\\} = \\emptyset$.\n\nAcronyms to be defined and then used: Simulated Annealing (SA), Monte Carlo (MC), Boltzmann constant ($k_{\\mathrm{B}}$), Solvent Accessible Surface Area (SASA).\n\nProgram requirements:\n\n- Implement SA as described, using the same Gaussian proposal vector at each iteration for both solvent models to ensure comparability.\n\n- Compute the six outputs per test case in the order $[a_{\\mathrm{imp}}, a_{\\mathrm{exp}}, E_{\\mathrm{imp,final}}, E_{\\mathrm{exp,final}}, E_{\\mathrm{exp,final}} - E_{\\mathrm{imp,final}}, \\mathrm{conv}_{\\mathrm{imp}}, \\mathrm{conv}_{\\mathrm{exp}}]$, where the last two are booleans.\n\n- Final output format: Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element is itself a comma-separated list for a test case. For example, the overall format must be $\\left[\\left[r_{11},r_{12},\\dots\\right],\\left[r_{21},r_{22},\\dots\\right],\\dots\\right]$. No spaces are permitted in the output string. All numeric outputs must be plain decimals (floats); do not include units in the output string.",
            "solution": "The problem is valid as it is scientifically grounded, well-posed, internally consistent, and provides all necessary information for a unique, verifiable solution. We will proceed with a detailed algorithmic description and implementation.\n\nThe task is to perform a comparative analysis of two solvent models in a ligand-receptor docking scenario using the Simulated Annealing (SA) algorithm. SA is a probabilistic optimization method inspired by the annealing process in metallurgy. It belongs to the class of Monte Carlo (MC) methods and is particularly effective for finding the global minimum of a high-dimensional function with many local minima.\n\nThe core principle of SA derives from statistical mechanics. In a system at thermal equilibrium, the probability of occupying a microstate $\\mathbf{x}$ with energy $E(\\mathbf{x})$ is given by the Boltzmann distribution, $p(\\mathbf{x}) \\propto \\exp(-E(\\mathbf{x})/K)$, where $K$ is the thermal energy, equivalent to the product of the Boltzmann constant $k_{\\mathrm{B}}$ and the absolute temperature $T$. SA simulates this by iteratively proposing new states and accepting them based on the Metropolis criterion. A move from a state with energy $E$ to a new state with energy $E'$ is accepted with probability $p_{\\mathrm{acc}} = \\min(1, \\exp(-\\Delta E/K))$, where $\\Delta E = E' - E$. By gradually decreasing the thermal energy $K$ (the \"temperature\"), the algorithm initially explores the energy landscape broadly (high $K$) and then focuses on finding the minimum in the most promising regions (low $K$).\n\nThe system is defined by a ligand pose vector $\\mathbf{x} \\in \\mathbb{R}^d$. The energy landscape is constructed from several components. The baseline receptor-ligand interaction, $E_{\\mathrm{bind}}(\\mathbf{x})$, is given by:\n$$\nE_{\\mathrm{bind}}(\\mathbf{x}) = \\sum_{i=1}^{d} w_i x_i^2 + \\sum_{i=1}^{d} A \\cos(\\beta x_i)\n$$\nThis function models two key physical effects:\n1.  A harmonic potential $\\sum_{i=1}^{d} w_i x_i^2$, which attracts the ligand towards the binding pocket center at $\\mathbf{x}^\\ast = \\mathbf{0}$. The weights $w_i = 1 + 0.1(i-1)$ introduce anisotropy, making the pocket's potential well non-spherical.\n2.  A periodic term $\\sum_{i=1}^{d} A \\cos(\\beta x_i)$ with fixed parameters $A=0.2$ and $\\beta=3.0$, which superimposes a rugged, corrugated texture onto the landscape, mimicking steric clashes or specific interactions.\n\nTwo different solvent models are added to this baseline energy, reflecting distinct approaches to modeling the effect of the aqueous environment:\n\n1.  **Implicit Solvent Model**: Based on a simplified Solvent Accessible Surface Area (SASA) concept. The energy is:\n    $$\n    E_{\\mathrm{imp}}(\\mathbf{x}) = E_{\\mathrm{bind}}(\\mathbf{x}) + \\gamma \\lVert \\mathbf{x} - \\mathbf{x}^\\ast \\rVert_2\n    $$\n    Here, $\\lVert \\mathbf{x} \\rVert_2$ (since $\\mathbf{x}^\\ast = \\mathbf{0}$) serves as a proxy for the exposed surface area of the ligand. The parameter $\\gamma$ penalizes configurations that are far from the buried pocket center, representing the energetic cost of desolvating the ligand and receptor upon binding.\n\n2.  **Explicit Solvent Occupancy Model**: This model accounts for the displacement of specific, structured water molecules. The energy is:\n    $$\n    E_{\\mathrm{exp}}(\\mathbf{x}) = E_{\\mathrm{bind}}(\\mathbf{x}) + \\delta \\sum_{k=1}^{N_w} \\exp\\!\\left(-\\frac{\\lVert \\mathbf{x} - \\mathbf{y}_k \\rVert_2^2}{2 s_w^2}\\right)\n    $$\n    This adds a penalty term consisting of a sum of Gaussian functions centered at fixed water positions $\\{\\mathbf{y}_k\\}_{k=1}^{N_w}$. The parameter $\\delta$ scales the energetic cost of the ligand clashing with these high-occupancy water sites, and $s_w$ defines the spatial extent of this penalty.\n\nThe SA algorithm will be implemented as follows:\n-   **Initialization**: For each model, the system starts at the initial configuration $\\mathbf{x}_0$, where all components are $1.0$. The initial thermal energy is $K_0=T_0$. A single pseudo-random number generator is seeded with $42$ to ensure reproducibility and direct comparability.\n-   **Iteration**: The algorithm proceeds for a total of $N_{\\mathrm{iter}} = N_T \\times \\text{steps\\_per\\_T}$ steps, where $N_T=20$ is the number of temperature levels.\n-   **Proposal Generation**: At each step, a single new candidate position is generated by adding a random displacement vector $\\boldsymbol{\\eta}$ to the current position. $\\boldsymbol{\\eta}$ is drawn from a multivariate normal distribution, $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2(K) \\mathbf{I})$, where the standard deviation $\\sigma(K) = s_{\\mathrm{step}} \\sqrt{K}$ with $s_{\\mathrm{step}} = 0.25$. This adaptive step size allows for larger exploratory moves at high $K$ and smaller, refining moves at low $K$. The same $\\boldsymbol{\\eta}$ is used for both solvent models to ensure a fair comparison.\n-   **Acceptance/Rejection**: For each model, the energy change $\\Delta E$ is calculated, and the move is accepted or rejected based on the Metropolis criterion. The two models evolve independently based on their respective energy landscapes.\n-   **Cooling**: After completing `steps_per_T` iterations at a given thermal energy $K_t$, the temperature is reduced according to the geometric cooling schedule $K_{t+1} = \\alpha K_t$.\n\nUpon completion of the annealing run for each test case, we will compute the aformentioned outputs:\n-   $a_{\\mathrm{imp}}$ and $a_{\\mathrm{exp}}$: The fraction of accepted moves for each model.\n-   $E_{\\mathrm{imp,final}}$ and $E_{\\mathrm{exp,final}}$: The energies of the final configurations for each model.\n-   The difference $E_{\\mathrm{exp,final}} - E_{\\mathrm{imp,final}}$.\n-   Convergence indicators $\\mathrm{conv}_{\\mathrm{imp}}$ and $\\mathrm{conv}_{\\mathrm{exp}}$: A boolean value indicating if the standard deviation of the recorded energies over the last $L = \\min(50, N_{\\mathrm{iter}})$ iterations is less than the threshold $\\tau=0.05 \\text{ kcal/mol}$. This will be reported as $1.0$ for true and $0.0$ for false.\nAll calculations will be performed and reported according to the specified test cases and output format.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# from scipy import ... # Not required\n\ndef solve():\n    \"\"\"\n    Main function to run the simulated annealing comparison for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: general scenario\n        {'d': 3, 'T0': 5.0, 'alpha': 0.85, 'steps_per_T': 200, 'gamma': 0.4, 'delta': 0.6, 's_w': 0.35, 'y_k': np.array([[0.3, 0.0, 0.0], [-0.2, 0.25, -0.1]])},\n        # Case 2: high implicit solvent penalty\n        {'d': 2, 'T0': 3.5, 'alpha': 0.90, 'steps_per_T': 180, 'gamma': 1.2, 'delta': 0.2, 's_w': 0.30, 'y_k': np.array([[0.1, -0.1], [0.5, 0.0]])},\n        # Case 3: low-temperature boundary\n        {'d': 3, 'T0': 0.25, 'alpha': 0.90, 'steps_per_T': 220, 'gamma': 0.8, 'delta': 0.8, 's_w': 0.20, 'y_k': np.array([[0.0, 0.0, 0.0]])},\n        # Case 4: no solvent effect baseline\n        {'d': 2, 'T0': 4.0, 'alpha': 0.80, 'steps_per_T': 100, 'gamma': 0.0, 'delta': 0.0, 's_w': 0.30, 'y_k': np.array([])},\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_list = run_sa_for_case(params)\n        all_results.append(result_list)\n\n    # Format the final output string as specified, with no spaces.\n    case_strings = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    final_output_string = f\"[{','.join(case_strings)}]\"\n    print(final_output_string)\n\ndef run_sa_for_case(params):\n    \"\"\"\n    Runs the full Simulated Annealing simulation for a single test case.\n    \"\"\"\n    # Unpack parameters\n    d = params['d']\n    T0 = params['T0']\n    alpha = params['alpha']\n    steps_per_T = params['steps_per_T']\n    gamma = params['gamma']\n    delta = params['delta']\n    s_w = params['s_w']\n    y_k = params['y_k']\n\n    # Fixed algorithmic parameters\n    A = 0.2\n    beta = 3.0\n    s_step = 0.25\n    N_T = 20\n    tau = 0.05\n    seed = 42\n\n    # Derived parameters\n    total_iterations = N_T * steps_per_T\n    w = 1.0 + 0.1 * np.arange(d) # 0-indexed version of w_i = 1+0.1(i-1)\n    x_star = np.zeros(d)\n    \n    # --- Helper energy functions ---\n    def calculate_E_bind(x):\n        term1 = np.sum(w * x**2)\n        term2 = A * np.sum(np.cos(beta * x))\n        return term1 + term2\n\n    def calculate_E_imp(x):\n        E_b = calculate_E_bind(x)\n        solv_term = gamma * np.linalg.norm(x - x_star)\n        return E_b + solv_term\n\n    def calculate_E_exp(x):\n        E_b = calculate_E_bind(x)\n        solv_term = 0.0\n        if y_k.size > 0:\n            dist_sq = np.sum((x - y_k)**2, axis=1)\n            solv_term = delta * np.sum(np.exp(-dist_sq / (2 * s_w**2)))\n        return E_b + solv_term\n\n    # --- SA Initialization ---\n    rng = np.random.default_rng(seed)\n    \n    x_imp = np.ones(d)\n    x_exp = np.ones(d)\n    \n    K = T0\n    \n    accepted_imp = 0\n    accepted_exp = 0\n    \n    E_hist_imp = []\n    E_hist_exp = []\n\n    # --- Main SA Loop ---\n    for _ in range(N_T):\n        for _ in range(steps_per_T):\n            E_current_imp = calculate_E_imp(x_imp)\n            E_current_exp = calculate_E_exp(x_exp)\n            E_hist_imp.append(E_current_imp)\n            E_hist_exp.append(E_current_exp)\n\n            # Generate a single proposal vector, shared by both models\n            step_sigma = s_step * np.sqrt(K)\n            eta = rng.normal(0, step_sigma, size=d)\n\n            # --- Implicit Model Step ---\n            x_prime_imp = x_imp + eta\n            E_prime_imp = calculate_E_imp(x_prime_imp)\n            delta_E_imp = E_prime_imp - E_current_imp\n            \n            if delta_E_imp  0 or rng.random()  np.exp(-delta_E_imp / K):\n                x_imp = x_prime_imp\n                accepted_imp += 1\n\n            # --- Explicit Model Step ---\n            x_prime_exp = x_exp + eta\n            E_prime_exp = calculate_E_exp(x_prime_exp)\n            delta_E_exp = E_prime_exp - E_current_exp\n\n            if delta_E_exp  0 or rng.random()  np.exp(-delta_E_exp / K):\n                x_exp = x_prime_exp\n                accepted_exp += 1\n        \n        # Geometric cooling\n        K *= alpha\n        \n    # --- Post-processing and Output Calculation ---\n    a_imp = accepted_imp / total_iterations\n    a_exp = accepted_exp / total_iterations\n    \n    E_final_imp = calculate_E_imp(x_imp)\n    E_final_exp = calculate_E_exp(x_exp)\n    \n    E_diff = E_final_exp - E_final_imp\n    \n    tail_length = min(50, total_iterations)\n    tail_energies_imp = E_hist_imp[-tail_length:]\n    tail_energies_exp = E_hist_exp[-tail_length:]\n    \n    conv_imp = float(np.std(tail_energies_imp)  tau)\n    conv_exp = float(np.std(tail_energies_exp)  tau)\n    \n    return [a_imp, a_exp, E_final_imp, E_final_exp, E_diff, conv_imp, conv_exp]\n\nif __name__ == '__main__':\n    solve()\n\n```"
        }
    ]
}