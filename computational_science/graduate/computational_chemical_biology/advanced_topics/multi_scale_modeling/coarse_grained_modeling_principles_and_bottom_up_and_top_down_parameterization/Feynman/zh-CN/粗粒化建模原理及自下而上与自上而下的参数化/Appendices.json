{
    "hands_on_practices": [
        {
            "introduction": "构建粗粒化模型的关键步骤是定义其有效的相互作用势。本练习将重点放在一个核心的自下而上参数化技术上：迭代玻尔兹曼反演（IBI）。该方法通过系统地迭代优化，使得粗粒化模型能够精确再现来自更高精度模拟（如全原子模拟）的目标结构分布，例如二面角分布。通过完成这项实践 ，您将获得实施核心参数化算法的实践经验，并理解在实际操作中如何选择分箱、平滑等关键参数。",
            "id": "3839139",
            "problem": "您正在使用一种基于平衡统计力学的自下而上策略，为一个残基水平的蛋白质模型参数化一个粗粒化扭转势。假设单个二面角 $\\phi \\in [-\\pi,\\pi)$ 由一维扭转势 $U(\\phi)$ 控制，该势在正则系综下产生平衡边际分布 $p(\\phi)$。在温度 $T$ 下，坐标 $\\phi$ 的正则概率密度满足 $p(\\phi) \\propto \\exp\\!\\left(-U(\\phi)/(k_{\\mathrm{B}} T)\\right)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数。在约化单位中，设 $k_{\\mathrm{B}} T = 1$。您的目标是应用迭代玻尔兹曼反演 (Iterative Boltzmann Inversion, IBI) 来推导一个离散化的扭转势 $U(\\phi)$，使其与目标原子级二面角分布 $p_{\\mathrm{target}}(\\phi)$ 相匹配，同时在分箱和平滑方面做出科学上合理的选择。\n\n从正则系综出发，推导 IBI 更新规则，并在一个程序中实现它，该程序在一个均匀的角度网格上迭代更新 $U(\\phi)$。实现必须遵循以下原则和约束：\n- 将角度 $\\phi$（以弧度为单位）在区间 $[-\\pi,\\pi)$ 上离散化为 $N_b$ 个宽度为 $\\Delta \\phi = 2\\pi/N_b$ 的均匀箱格，箱格中心置于中点。所有计算均使用弧度单位。\n- 使用约化单位约定 $k_{\\mathrm{B}} T = 1$，因此能量以 $k_{\\mathrm{B}} T$ 为单位表示。\n- 目标二面角分布 $p_{\\mathrm{target}}(\\phi)$ 以 von Mises 分量混合的形式解析给出。单个 von Mises 分量的密度为 $f(\\phi;\\mu,\\kappa) = \\exp\\!\\left(\\kappa \\cos(\\phi-\\mu)\\right) / \\left(2\\pi I_0(\\kappa)\\right)$，其中 $I_0$ 是零阶第一类修正贝塞尔函数，$\\mu$ 是平均角（以弧度为单位），$\\kappa$ 是集中度参数。具有 $M$ 个分量的混合分布满足 $p_{\\mathrm{target}}(\\phi) \\propto \\sum_{m=1}^M w_m f(\\phi;\\mu_m,\\kappa_m)$，权重 $w_m > 0$ 且总和为 1。通过在箱格中心评估混合分布，向每个箱格值添加一个小的伪计数 $\\varepsilon$，并进行归一化，使得 $\\sum_i p_{\\mathrm{target}}(\\phi_i) = 1$，从而在离散网格上构建 $p_{\\mathrm{target}}(\\phi)$。\n- 在所有箱格中心 $\\{\\phi_i\\}$ 处，将初始扭转势设置为 $U_0(\\phi_i) = 0$。\n- 在每次迭代 $n$ 中，通过 $p_n(\\phi_i) \\propto \\exp\\!\\left(-U_n(\\phi_i)\\right)$ 计算当前势所蕴含的模型分布 $p_n(\\phi_i)$，然后进行归一化，使得 $\\sum_i p_n(\\phi_i) = 1$。\n- 推导并应用 IBI 更新，从 $U_n(\\phi_i)$ 以及 $p_n(\\phi_i)$ 和 $p_{\\mathrm{target}}(\\phi_i)$ 之间的比率得到 $U_{n+1}(\\phi_i)$，然后对 $U_{n+1}(\\phi_i)$ 应用一个考虑 $\\phi$ 周期性（即在 $\\pm \\pi$ 处回绕）的平滑算子。使用一个各向同性高斯核，其标准差 $\\sigma$ 以“箱格”为单位（因此核宽度随箱格数量缩放）。平滑后，通过减去平均值来固定势的规范，使得 $\\frac{1}{N_b}\\sum_i U_{n+1}(\\phi_i) = 0$。\n- 重复更新 $N_{\\mathrm{iter}}$ 次迭代。\n\n设计分箱和平滑的选择以实现科学真实性：确保平滑的周期性边界条件，为避免 $\\log(0)$ 证明伪计数 $\\varepsilon$ 的合理性，并解释箱格宽度 $\\Delta \\phi$ 如何控制分辨率。角度使用弧度，能量以 $k_{\\mathrm{B}} T$ 为单位表示。报告最终模型分布与目标分布之间的定量不匹配度量。使用积分绝对差\n$$\nE = \\sum_{i=1}^{N_b} \\left| p_{\\mathrm{final}}(\\phi_i) - p_{\\mathrm{target}}(\\phi_i) \\right| \\Delta \\phi\n$$\n作为一个无量纲标量误差。\n\n实现该程序，并在以下测试套件上进行评估，该套件探索了一个一般情况、一个粗糙分箱情况和一个回绕边缘情况。在所有情况下，角度以弧度为单位，能量以 $k_{\\mathrm{B}} T$ 为单位，高斯平滑标准差 $\\sigma$ 以箱格为单位指定。\n\n测试用例 1（理想情况）：\n- $N_b = 72$，$\\sigma = 0.0$，$\\varepsilon = 10^{-6}$，$N_{\\mathrm{iter}} = 3$。\n- 目标混合分布：$M = 1$ 个分量，$(w_1,\\mu_1,\\kappa_1) = (1.0, 0.0, 5.0)$。\n\n测试用例 2（粗糙分箱和平滑）：\n- $N_b = 12$，$\\sigma = 1.5$，$\\varepsilon = 10^{-6}$，$N_{\\mathrm{iter}} = 5$。\n- 目标混合分布：$M = 2$ 个分量，$(w_1,\\mu_1,\\kappa_1) = (0.6, \\pi/3, 8.0)$ 和 $(w_2,\\mu_2,\\kappa_2) = (0.4, -\\pi/3, 4.0)$。\n\n测试用例 3（靠近周期性边界的边缘情况）：\n- $N_b = 36$，$\\sigma = 0.5$，$\\varepsilon = 10^{-8}$，$N_{\\mathrm{iter}} = 10$。\n- 目标混合分布：$M = 2$ 个分量，$(w_1,\\mu_1,\\kappa_1) = (0.5, \\pi - 0.01, 20.0)$ 和 $(w_2,\\mu_2,\\kappa_2) = (0.5, -\\pi + 0.01, 20.0)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须包含三个 $E$ 值，按测试用例 $(1,2,3)$ 的顺序排列，每个值四舍五入到 $6$ 位小数，例如 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$。",
            "solution": "我们从具有势 $U(\\phi)$ 和温度 $T$ 的一维扭转坐标 $\\phi$ 的正则系综开始。平衡边际概率密度为\n$$\np(\\phi) = \\frac{1}{Z} \\exp\\!\\left(-\\frac{U(\\phi)}{k_{\\mathrm{B}} T}\\right),\n$$\n其中 $Z = \\int_{-\\pi}^{\\pi} \\exp\\!\\left(-U(\\phi)/(k_{\\mathrm{B}} T)\\right)\\, d\\phi$ 是配分函数。在 $k_{\\mathrm{B}} T = 1$ 的约化单位中，这简化为 $p(\\phi) \\propto \\exp\\!\\left(-U(\\phi)\\right)$。\n\n在通过迭代玻尔兹曼反演 (IBI) 进行的自下而上参数化中，我们寻求一个能再现目标原子级分布 $p_{\\mathrm{target}}(\\phi)$ 的扭转势 $U(\\phi)$。设 $U_n(\\phi)$ 是第 $n$ 次迭代时的势，而 $p_n(\\phi)$ 是通过正则系综由 $U_n(\\phi)$ 蕴含的相应模型分布。根据构造，\n$$\np_n(\\phi) = \\frac{\\exp\\!\\left(-U_n(\\phi)\\right)}{\\int_{-\\pi}^{\\pi} \\exp\\!\\left(-U_n(\\phi')\\right) d\\phi'}.\n$$\nIBI 更新的推导源于修正 $U_n(\\phi)$ 以使 $p_{n+1}(\\phi)$ 接近 $p_{\\mathrm{target}}(\\phi)$ 的需求。考虑一个加性修正 $\\Delta U_n(\\phi)$，使得 $U_{n+1}(\\phi) = U_n(\\phi) + \\Delta U_n(\\phi)$。如果我们强制 $p_{n+1}(\\phi) = p_{\\mathrm{target}}(\\phi)$ 完全成立，那么\n$$\np_{\\mathrm{target}}(\\phi) \\propto \\exp\\!\\left(-U_{n+1}(\\phi)\\right) = \\exp\\!\\left(-U_n(\\phi) - \\Delta U_n(\\phi)\\right) = \\exp\\!\\left(-U_n(\\phi)\\right)\\exp\\!\\left(-\\Delta U_n(\\phi)\\right).\n$$\n取对数并利用比例关系（即忽略归一化常数），我们得到\n$$\n\\ln p_{\\mathrm{target}}(\\phi) = \\ln p_n(\\phi) - \\Delta U_n(\\phi) + \\text{constant}.\n$$\n选择规范（即加性常数）使修正的均值为零，则自然的更新是\n$$\n\\Delta U_n(\\phi) = \\ln \\frac{p_n(\\phi)}{p_{\\mathrm{target}}(\\phi)}.\n$$\n恢复 $k_{\\mathrm{B}} T$ 得到 $\\Delta U_n(\\phi) = k_{\\mathrm{B}} T \\ln\\!\\left(p_n(\\phi)/p_{\\mathrm{target}}(\\phi)\\right)$，在 $k_{\\mathrm{B}} T = 1$ 的约化单位中，这变为\n$$\nU_{n+1}(\\phi) = U_n(\\phi) + \\ln \\frac{p_n(\\phi)}{p_{\\mathrm{target}}(\\phi)}.\n$$\n如果在没有平滑和使用精确分布的情况下应用此更新，它会使 $p_{n+1}(\\phi)$ 等于 $p_{\\mathrm{target}}(\\phi)$。在实践中，为了实现稳定性和强制实现物理上的平滑性，我们对 $\\phi$ 进行离散化，对 $p_{\\mathrm{target}}$ 应用正则化，并对 $U_{n+1}$ 进行平滑。\n\n离散化和分箱：我们在 $[-\\pi,\\pi)$ 上选择 $N_b$ 个均匀箱格，箱格宽度为 $\\Delta \\phi = 2\\pi/N_b$，中心位于 $\\phi_i = -\\pi + (i+1/2)\\Delta \\phi$，其中 $i = 0,\\dots,N_b-1$。离散的 $p_{\\mathrm{target}}(\\phi_i)$ 从 von Mises 分量的混合中获得，\n$$\np_{\\mathrm{target}}(\\phi) \\propto \\sum_{m=1}^M w_m \\frac{\\exp\\!\\left(\\kappa_m \\cos(\\phi - \\mu_m)\\right)}{2\\pi I_0(\\kappa_m)}.\n$$\n为防止数值问题（如 $\\log(0)$），我们向每个箱格添加一个伪计数 $\\varepsilon > 0$ 并重新归一化，使得 $\\sum_i p_{\\mathrm{target}}(\\phi_i) = 1$。\n\n模型分布：给定一个离散势 $U_n(\\phi_i)$，我们计算\n$$\np_n(\\phi_i) = \\frac{\\exp\\!\\left(-U_n(\\phi_i)\\right)}{\\sum_{j=1}^{N_b} \\exp\\!\\left(-U_n(\\phi_j)\\right)}.\n$$\n\nIBI 更新和平滑：离散更新为\n$$\nU_{n+1}(\\phi_i) = U_n(\\phi_i) + \\ln \\frac{p_n(\\phi_i)}{p_{\\mathrm{target}}(\\phi_i)}.\n$$\n然后，我们用一个标准差为 $\\sigma$（以箱格为单位）的高斯核对 $U_{n+1}(\\phi_i)$ 进行平滑，使用周期性边界条件（回绕）以考虑角度的周期性。平滑势能而非概率，可以对能量景观施加物理上合理的正则化。由于势的定义只到相差一个加性常数，我们通过减去其平均值来固定其规范，使得 $\\frac{1}{N_b}\\sum_i U_{n+1}(\\phi_i) = 0$。\n\n误差度量：经过 $N_{\\mathrm{iter}}$ 次迭代后，我们从 $U_{N_{\\mathrm{iter}}}(\\phi_i)$ 生成 $p_{\\mathrm{final}}(\\phi_i)$，并计算积分绝对差\n$$\nE = \\sum_{i=1}^{N_b} \\left| p_{\\mathrm{final}}(\\phi_i) - p_{\\mathrm{target}}(\\phi_i) \\right| \\Delta \\phi,\n$$\n这是一个无量纲的量，用于量化不匹配程度。\n\n分箱和平滑的选择：箱格数 $N_b$ 设定了分辨率 $\\Delta \\phi$。较大的 $N_b$ 会产生更精细的分辨率，但如果涉及采样，则可能导致更嘈杂的估计；在这里，它有助于更好地捕捉 $p_{\\mathrm{target}}$ 中的尖锐特征。伪计数 $\\varepsilon$ 避免了未定义的对数和在概率极小的箱格中出现过大的更新。平滑参数 $\\sigma$（以箱格为单位）控制了正则性：$\\sigma = 0$ 使 $U$ 保持不变，而较大的 $\\sigma$ 会产生更平滑的扭转轮廓。因为 $\\phi$ 是周期性的，平滑必须使用回绕边界条件来执行，以避免在 $\\pm \\pi$ 附近产生失真。\n\n算法步骤与程序的映射：\n1. 在 $[-\\pi,\\pi)$ 上构建 $N_b$ 个箱格中心的网格。\n2. 从 von Mises 混合分布构建 $p_{\\mathrm{target}}(\\phi_i)$，添加 $\\varepsilon$，并归一化。\n3. 设置 $U_0(\\phi_i) = 0$。\n4. 对于 $n = 0,\\dots,N_{\\mathrm{iter}}-1$：\n   a. 从 $U_n(\\phi_i)$ 计算 $p_n(\\phi_i)$。\n   b. 形成更新 $\\Delta U_n(\\phi_i) = \\ln\\!\\left(p_n(\\phi_i)/p_{\\mathrm{target}}(\\phi_i)\\right)$。\n   c. 设置 $U_{n+1}(\\phi_i) = U_n(\\phi_i) + \\Delta U_n(\\phi_i)$。\n   d. 使用标准差为 $\\sigma$ 的高斯核，并采用回绕边界条件对 $U_{n+1}(\\phi_i)$ 进行平滑，然后减去其平均值以固定规范。\n5. 计算 $p_{\\mathrm{final}}(\\phi_i)$ 和 $E$。\n\n测试套件设计：\n- 测试用例 1 使用 $N_b = 72$ 和 $\\sigma = 0.0$ 来表明，在没有平滑的情况下，IBI 更新能够几乎精确地匹配单峰的 $p_{\\mathrm{target}}$。\n- 测试用例 2 使用粗糙分箱 $N_b = 12$ 和 $\\sigma = 1.5$ 来演示，对于双峰目标，平滑和粗糙分辨率会产生一个可控的不匹配。\n- 测试用例 3 在周期性边界附近放置尖锐的峰，使用 $N_b = 36$ 和 $\\sigma = 0.5$，展示了正确的环绕处理以及伪计数 $\\varepsilon = 10^{-8}$ 的作用。\n\n程序输出一行，包含三个按测试用例顺序排列的 $E$ 值，每个值四舍五入到 6 位小数，格式为 $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\nfrom scipy.ndimage import gaussian_filter1d\n\ndef von_mises_mixture(phi, components):\n    \"\"\"\n    Compute a mixture of von Mises densities at angles phi.\n    components: list of tuples (weight, mu, kappa)\n    Returns unnormalized mixture values evaluated at phi.\n    \"\"\"\n    # Each component: w * exp(kappa * cos(phi - mu)) / (2*pi*I0(kappa))\n    vals = np.zeros_like(phi, dtype=np.float64)\n    for w, mu, kappa in components:\n        vals += w * np.exp(kappa * np.cos(phi - mu)) / (2.0 * np.pi * i0(kappa))\n    return vals\n\ndef ibi_torsion(phi_centers, p_target, sigma_bins, n_iter):\n    \"\"\"\n    Perform Iterative Boltzmann Inversion on a discretized torsion.\n    phi_centers: array of bin centers in radians\n    p_target: normalized target distribution over bins (sum to 1)\n    sigma_bins: Gaussian smoothing standard deviation in bins\n    n_iter: number of IBI iterations\n    Returns final potential U (mean-zero) and final distribution p_final.\n    \"\"\"\n    nb = len(phi_centers)\n    # Initialize potential U0 = 0\n    U = np.zeros(nb, dtype=np.float64)\n    # Iterate IBI updates\n    for _ in range(n_iter):\n        # Model distribution from current potential\n        exp_neg_U = np.exp(-U)\n        p_model = exp_neg_U / np.sum(exp_neg_U)\n        # Update rule in reduced units (k_B T = 1): U_{n+1} = U_n + ln(p_model / p_target)\n        # Avoid division issues: p_target is strictly positive due to pseudocount\n        delta_U = np.log(p_model / p_target)\n        U = U + delta_U\n        # Smooth potential with Gaussian kernel, respecting periodicity\n        if sigma_bins > 0.0:\n            U = gaussian_filter1d(U, sigma=sigma_bins, mode='wrap')\n        # Fix gauge: subtract mean\n        U = U - np.mean(U)\n    # Final distribution from final potential\n    exp_neg_U = np.exp(-U)\n    p_final = exp_neg_U / np.sum(exp_neg_U)\n    return U, p_final\n\ndef build_target_distribution(phi_centers, components, epsilon):\n    \"\"\"\n    Build normalized discrete target distribution from von Mises mixture,\n    add pseudocount epsilon to each bin, and renormalize.\n    \"\"\"\n    p_raw = von_mises_mixture(phi_centers, components)\n    # Add pseudocount to all bins to avoid zeros\n    p_raw = p_raw + epsilon\n    # Normalize to sum 1\n    p_target = p_raw / np.sum(p_raw)\n    return p_target\n\ndef integrated_abs_difference(p_final, p_target, dphi):\n    \"\"\"\n    Compute E = sum |p_final - p_target| * dphi\n    \"\"\"\n    return float(np.sum(np.abs(p_final - p_target)) * dphi)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Angles in radians over [-pi, pi)\n    test_cases = [\n        # Test case 1: N_b=72, sigma=0.0, epsilon=1e-6, N_iter=3, unimodal von Mises\n        {\n            \"Nb\": 72,\n            \"sigma\": 0.0,\n            \"epsilon\": 1e-6,\n            \"n_iter\": 3,\n            \"components\": [(1.0, 0.0, 5.0)]\n        },\n        # Test case 2: N_b=12, sigma=1.5, epsilon=1e-6, N_iter=5, bimodal mixture\n        {\n            \"Nb\": 12,\n            \"sigma\": 1.5,\n            \"epsilon\": 1e-6,\n            \"n_iter\": 5,\n            \"components\": [(0.6, np.pi/3.0, 8.0), (0.4, -np.pi/3.0, 4.0)]\n        },\n        # Test case 3: N_b=36, sigma=0.5, epsilon=1e-8, N_iter=10, sharp peaks near boundaries\n        {\n            \"Nb\": 36,\n            \"sigma\": 0.5,\n            \"epsilon\": 1e-8,\n            \"n_iter\": 10,\n            \"components\": [(0.5, np.pi - 0.01, 20.0), (0.5, -np.pi + 0.01, 20.0)]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        sigma = case[\"sigma\"]\n        epsilon = case[\"epsilon\"]\n        n_iter = case[\"n_iter\"]\n        components = case[\"components\"]\n\n        # Discretize phi in [-pi, pi)\n        dphi = 2.0 * np.pi / Nb\n        phi_centers = -np.pi + (np.arange(Nb) + 0.5) * dphi\n\n        # Build target distribution with pseudocount\n        p_target = build_target_distribution(phi_centers, components, epsilon)\n\n        # Run IBI with periodic Gaussian smoothing\n        U_final, p_final = ibi_torsion(phi_centers, p_target, sigma_bins=sigma, n_iter=n_iter)\n\n        # Compute integrated absolute difference E\n        E = integrated_abs_difference(p_final, p_target, dphi)\n\n        # Round to 6 decimals for final output format\n        results.append(f\"{E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在粗粒化建模中，仅仅基于结构匹配（如IBI方法）得到的力场并不能保证所有热力学性质（例如压力）都能与参考系统保持一致，这是自下而上方法面临的普遍挑战。本练习聚焦于解决压力不匹配的问题，指导您运用统计力学中的维里定理来量化压力偏差，并设计一个简单而物理意义明确的对势修正项。通过这项实践 ，您将掌握一项确保粗粒化模型热力学一致性的关键技术，这对于进行准确的模拟至关重要。",
            "id": "3839161",
            "problem": "您的任务是实现一个计算程序，用于量化和校正一个通过迭代玻尔兹曼反演 (IBI) 方法参数化的粗粒化流体模型中的压力偏差。系统被假定为一种各向同性的流体，具有在有限截断半径处截断的对加性相互作用。所有量均以约化的无量纲单位表示，其中玻尔兹曼常数 $k_{\\mathrm{B}} = 1$，约化温度 $T$ 以相同的约化单位表示，压力以单位体积能量的约化单位度量。您必须使用维里路径，根据给定的径向分布函数和对势导数计算压力，然后基于维里恒等式设计一个压力校正项，以强制达到指定的目标压力。\n\n使用的基本原理：\n- 对于数密度为 $\\rho$、约化温度为 $T$、具有对加性势 $u(r)$ 的各向同性均匀流体，其压力的维里表达式为\n$$\nP(\\rho, T) = \\rho\\,T - \\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,u'(r)\\,g(r)\\,dr,\n$$\n其中 $g(r)$ 是径向分布函数，$u'(r)$ 是对势函数相对于 $r$ 的导数，$r_c$ 是截断半径。\n- 对势函数的一个加性校正项 $\\Delta u(r)$ 会使压力发生如下变化\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\Delta u'(r)\\,g(r)\\,dr.\n$$\n\n您的设计目标：\n- 定义一个关于 $r$ 的线性压力校正项\n$$\n\\Delta u(r) = a\\left(1 - \\frac{r}{r_c}\\right)\\,H(r_c - r),\n$$\n其中 $H(\\cdot)$ 是赫维赛德阶跃函数，$a$ 是一个待定振幅，其值需使得校正后的模型压力与给定的目标压力 $P^\\star$ 相匹配。使用上述基本原理和 $\\Delta u(r)$ 的定义，推导并实现一个关于 $a$ 的显式公式，该公式用压力偏差 $\\Delta P = P^\\star - P(\\rho,T)$ 和一个对 $g(r)$ 的径向积分来表示。\n\n数值设置：\n- 使用约化形式的 Lennard-Jones 对势，其中 $\\epsilon = 1$ 和 $\\sigma = 1$：\n$$\nu_{\\mathrm{LJ}}(r) = 4\\left[\\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6}\\right],\\quad\nu'_{\\mathrm{LJ}}(r) = 4\\left[-12\\,r^{-13} + 6\\,r^{-7}\\right].\n$$\n- 为避免在截断处出现力的不连续性，在截断半径内使用力移导数，\n$$\nu'_{\\mathrm{FS}}(r) = u'_{\\mathrm{LJ}}(r) - u'_{\\mathrm{LJ}}(r_c), \\quad \\text{for } r \\le r_c,\n$$\n且对于 $r > r_c$ 有 $u'_{\\mathrm{FS}}(r) = 0$。\n- 使用梯形法则在均匀径向网格 $r_i = r_{\\min} + i\\,\\Delta r$（其中 $i = 0,\\dots,N$，$r_{\\min} = 0.9$ 且 $\\Delta r = 0.001$）上近似所有积分。每个测试案例的上限是 $r_c$。构建网格，使得 $r_0 = r_{\\min}$ 和 $r_N = r_c$ 精确成立。\n\n每个测试案例所需的计算：\n1. 使用维里表达式，并利用 $u'_{\\mathrm{FS}}(r)$ 和指定的 $g(r)$，计算模型压力 $P(\\rho,T)$。\n2. 计算压力偏差 $\\Delta P = P^\\star - P(\\rho,T)$。\n3. 基于维里考虑和 $\\Delta u(r)$ 的定义，确定压力校正的振幅 $a$，该振幅在使用相同的 $g(r)$ 进行评估时能够强制实现压力 $P^\\star$。\n4. 报告浮点数三元组 $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$，其中 $P_{\\mathrm{corrected}} = P(\\rho,T) + \\Delta P$ 是使用您推导的 $\\Delta P$ 计算得出的；在数值积分误差范围内，该值应与 $P^\\star$ 相符。\n\n不涉及角度单位。不涉及百分比。所有输出均为无量纲的约化量。您的程序必须将每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n- 使用以下三个测试案例，每个案例都带有指定的参数。在所有案例中，均使用 $r_{\\min} = 0.9$ 和 $\\Delta r = 0.001$。\n- 测试案例 1（正常路径，结构化关联）：\n  - $\\rho = 0.8$, $T = 1.0$, $r_c = 2.5$, $P^\\star = 0.8$。\n  - 将 $g(r)$ 定义为 $g(r) = s(r)\\,h(r)$，其中\n    $$\n    s(r) = \\frac{1}{1 + \\exp\\left[-k\\,(r - r_s)\\right]},\\quad k = 20,\\ r_s = 1.0,\n    $$\n    $$\n    h(r) = 1 + A\\,\\exp\\!\\left(-\\frac{(r - r_m)^2}{w^2}\\right)\\cos\\!\\left(\\omega\\,(r - r_m)\\right),\n    $$\n    其中 $A = 0.25$，$r_m = 1.2$，$w = 0.4$ 且 $\\omega = 8$。\n- 测试案例 2（低密度极限，相同的结构代理）：\n  - $\\rho = 0.05$, $T = 1.0$, $r_c = 2.5$, $P^\\star = 0.05$。\n  - 使用与测试案例 1 中相同的 $g(r)$。\n- 测试案例 3（更短的截断半径，近理想结构）：\n  - $\\rho = 0.8$, $T = 1.0$, $r_c = 1.5$, $P^\\star = 1.2$。\n  - 定义 $g(r) = 1$ 对所有 $r \\in [r_{\\min}, r_c]$ 成立。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表包含三个浮点数 $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$，四舍五入到 $6$ 位小数，并按测试套件的顺序排列。例如，输出格式必须与下面完全一样\n$$\n[[P_1,a_1,P_{c,1}],[P_2,a_2,P_{c,2}],[P_3,a_3,P_{c,3}]].\n$$",
            "solution": "问题陈述已经过严格验证，并被认为是具有科学依据、适定、客观且自洽的。它提出了粗粒化分子建模领域中的一个标准计算任务，该任务基于统计力学的基本原理。所有提供的数据、定义和条件都是充分且连贯的，足以推导出唯一且有意义的解。\n\n主要目标是推导并实现一个用于线性压力校正势 $\\Delta u(r)$ 振幅 $a$ 的公式，使得粗粒化流体模型的压力与目标压力 $P^\\star$ 相匹配。该推导从压力的维里表达式出发。\n\n具有对相互作用的均匀、各向同性流体的总压力 $P$ 由维里定理给出：\n$$\nP(\\rho, T) = \\rho\\,T - \\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,u'(r)\\,g(r)\\,dr\n$$\n此处，$\\rho$ 是数密度，$T$ 是约化温度，$u'(r)$ 是对势的导数，$g(r)$ 是径向分布函数，$r_c$ 是截断半径。所有量都使用约化单位。\n\n对势的一个小的加性校正 $\\Delta u(r)$ 会引起相应的压力变化 $\\Delta P$：\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\Delta u'(r)\\,g(r)\\,dr\n$$\n我们要求这个压力变化将初始模型压力 $P_{\\text{model}} = P(\\rho, T)$ 校正到目标压力 $P^\\star$。因此，我们将期望的压力变化设定为 $\\Delta P_{\\text{target}} = P^\\star - P_{\\text{model}}$。\n\n问题指定了一种形式为线性的校正势：\n$$\n\\Delta u(r) = a\\left(1 - \\frac{r}{r_c}\\right)\\,H(r_c - r)\n$$\n其中 $H(\\cdot)$ 是赫维赛德阶跃函数，确保当 $r > r_c$ 时校正为零。对于 $r \\le r_c$，该校正势对 $r$ 的导数是一个常数：\n$$\n\\Delta u'(r) = \\frac{d}{dr}\\left[a\\left(1 - \\frac{r}{r_c}\\right)\\right] = -\\frac{a}{r_c}\n$$\n将此导数代入 $\\Delta P$ 的表达式中：\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\left(-\\frac{a}{r_c}\\right)\\,g(r)\\,dr\n$$\n由于 $a$ 和 $r_c$ 是常数，可以将它们从积分中提出：\n$$\n\\Delta P = \\frac{2\\pi a \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr\n$$\n为达到目标压力，我们令 $\\Delta P = \\Delta P_{\\text{target}} = P^\\star - P_{\\text{model}}$ 并求解振幅 $a$：\n$$\nP^\\star - P_{\\text{model}} = \\frac{2\\pi a \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr\n$$\n$$\na = \\frac{P^\\star - P_{\\text{model}}}{\\frac{2\\pi \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr}\n$$\n重新整理得到 $a$ 的最终显式公式：\n$$\na = \\frac{3r_c (P^\\star - P_{\\text{model}})}{2\\pi\\rho^{2} \\int_{0}^{r_c} r^{3}\\,g(r)\\,dr}\n$$\n计算步骤如下：\n1.  对于每个测试案例，构建一个从 $r_{\\min} = 0.9$ 到指定 $r_c$ 的均匀径向网格 $r_i$，步长为 $\\Delta r = 0.001$。使用梯形法则在该网格上对积分进行数值计算，这是一个有效的近似，因为当 $r  r_{\\min}$ 时，$g(r)$ 实际上为零。\n2.  在网格上计算力移 Lennard-Jones 导数 $u'_{\\mathrm{FS}}(r) = u'_{\\mathrm{LJ}}(r) - u'_{\\mathrm{LJ}}(r_c)$ 和给定的径向分布函数 $g(r)$。\n3.  通过数值计算维里积分 $\\int_{r_{\\min}}^{r_c} r^{3}\\,u'_{\\mathrm{FS}}(r)\\,g(r)\\,dr$ 并将其代入压力方程，计算初始模型压力 $P_{\\text{model}} \\equiv P(\\rho, T)$。\n4.  通过数值计算积分 $\\int_{r_{\\min}}^{r_c} r^{3}\\,g(r)\\,dr$ 来计算表达式 $a$ 的分母。\n5.  在已知 $P_{\\text{model}}$ 和所需积分的情况下，使用推导出的公式计算振幅 $a$。\n6.  校正后的压力 $P_{\\mathrm{corrected}}$ 计算为 $P_{\\text{model}} + \\Delta P$。根据构造，$\\Delta P = P^\\star - P_{\\text{model}}$，因此 $P_{\\mathrm{corrected}}$ 在数值精度范围内必须等于 $P^\\star$。这可作为一个一致性检查。\n7.  收集并格式化每个测试案例的最终结果 $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def u_lj_prime(r):\n        \"\"\"\n        Computes the derivative of the reduced Lennard-Jones potential.\n        sigma = 1, epsilon = 1.\n        \"\"\"\n        r_inv = 1.0 / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * (-12.0 * r_inv13 + 6.0 * r_inv7)\n\n    def get_g_case1_and_2(r):\n        \"\"\"\n        Computes the radial distribution function g(r) for test cases 1 and 2.\n        \"\"\"\n        k = 20.0\n        r_s = 1.0\n        s_r = 1.0 / (1.0 + np.exp(-k * (r - r_s)))\n\n        A = 0.25\n        r_m = 1.2\n        w = 0.4\n        omega = 8.0\n        h_r = 1.0 + A * np.exp(-((r - r_m) / w)**2) * np.cos(omega * (r - r_m))\n        return s_r * h_r\n\n    def get_g_case3(r):\n        \"\"\"\n        Computes the radial distribution function g(r) for test case 3.\n        \"\"\"\n        return np.ones_like(r)\n\n    def solve_case(params):\n        \"\"\"\n        Solves one case for P, a, and P_corrected.\n        \"\"\"\n        rho, T, r_c, P_star, g_func = params\n        r_min = 0.9\n        dr = 0.001\n\n        # 1. Construct the numerical grid\n        num_points = int(round((r_c - r_min) / dr)) + 1\n        r = np.linspace(r_min, r_c, num_points)\n\n        # 2. Evaluate functions on the grid\n        g_r = g_func(r)\n        u_lj_prime_rc = u_lj_prime(r_c)\n        u_fs_prime_r = u_lj_prime(r) - u_lj_prime_rc\n\n        # 3. Compute initial model pressure P\n        integrand_P = r**3 * u_fs_prime_r * g_r\n        I_P = np.trapz(integrand_P, r)\n        virial_term = (2.0 * np.pi * rho**2 / 3.0) * I_P\n        P_model = rho * T - virial_term\n\n        # 4. Compute the integral for the correction amplitude 'a'\n        integrand_a = r**3 * g_r\n        I_a = np.trapz(integrand_a, r)\n        \n        # 5. Compute 'a'\n        pressure_deviation = P_star - P_model\n        denominator_a = (2.0 * np.pi * rho**2 / (3.0 * r_c)) * I_a\n        \n        # Avoid division by zero, though not expected in this problem\n        if abs(denominator_a)  1e-15:\n            a = np.nan\n        else:\n            a = pressure_deviation / denominator_a\n\n        # 6. Compute the corrected pressure as a consistency check\n        # By construction, P_corrected = P_model + pressure_deviation = P_star\n        delta_P_calculated = a * denominator_a\n        P_corrected = P_model + delta_P_calculated\n\n        return [P_model, a, P_corrected]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.8, 1.0, 2.5, 0.8, get_g_case1_and_2),   # Case 1\n        (0.05, 1.0, 2.5, 0.05, get_g_case1_and_2), # Case 2\n        (0.8, 1.0, 1.5, 1.2, get_g_case3),          # Case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(case)\n        all_results.append(result)\n\n    # Format the results into the required string format.\n    formatted_results = []\n    for res_list in all_results:\n        # Each res_list is [P, a, P_corrected]\n        formatted_list_str = [f\"{val:.6f}\" for val in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "一个优秀的粗粒化模型的价值不仅在于描述其参数化时的状态，更在于其“可移植性”——即在不同条件下（如不同温度）依然能可靠地进行预测。本练习旨在评估模型的温度可移植性，引入了一种基于信息论的定量方法，即使用 Jensen-Shannon 散度（JSD）来衡量关键结构分布随温度的变化。完成这项实践  将使您掌握一种严谨的模型验证方法，从而理解模型的适用范围和局限性，这是计算建模者必备的一项核心技能。",
            "id": "3839217",
            "problem": "给你一个蛋白质的概念性粗粒度模型，其中键合二面角相互作用和非键对相互作用都由有效势表示。你需要通过量化二面角分布和径向分布函数的稳定性来评估该粗粒度模型在温度变化下的可移植性。你的任务是实现一个程序，对于每个给定的参数集，根据一个基于散度的准则，判断该模型在指定温度范围内是否可移植。\n\n基本原理：\n- 在正则系综中，坐标 $x$ 的概率密度与 $\\exp(-\\beta U(x))$ 成正比，其中 $\\beta = 1/(k_B T)$，$k_B$ 是玻尔兹曼常数，$T$ 是温度，$U(x)$ 是势能。\n- 对于粗粒度键的二面角 $\\phi$，假设其有效扭转势为 $U_{\\mathrm{torsion}}(\\phi) = k_{\\phi}\\left(1 - \\cos(n \\phi - \\delta)\\right)$，其中 $k_{\\phi}$ 是扭转振幅，$n$ 是周期性，$\\delta$ 是相位偏移。角度必须以弧度为单位处理。\n- 在低密度极限下（对于稀蛋白质溶液而言是物理上现实的），对相互作用的径向分布函数 $g(r)$ 近似为 $\\exp\\left(-\\beta U_{\\mathrm{LJ}}(r)\\right)$，其中 $U_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$ 是 Lennard-Jones 势，$\\varepsilon$ 是势阱深度，$\\sigma$ 是特征长度。距离必须以纳米为单位处理。\n- 为比较不同温度下的分布，请使用 Jensen–Shannon 散度。对于定义在相同支撑集上的两个归一化离散分布 $P$ 和 $Q$，其定义为 $\\mathrm{JSD}(P,Q) = \\frac{1}{2}\\mathrm{KL}\\left(P \\parallel M\\right) + \\frac{1}{2}\\mathrm{KL}\\left(Q \\parallel M\\right)$，其中 $M = \\frac{1}{2}(P+Q)$, $\\mathrm{KL}$ 表示 Kullback–Leibler 散度 $\\mathrm{KL}(P\\parallel Q) = \\sum_i P_i \\ln\\left(\\frac{P_i}{Q_i}\\right)$。请使用自然对数。\n\n你的程序必须为每个测试用例执行以下步骤：\n1. 使用正则系综和 $U_{\\mathrm{torsion}}(\\phi)$，构建每个指定温度下的离散、归一化的二面角分布 $p(\\phi)$。使用足够精细的网格将区间 $[-\\pi, \\pi]$ 上的 $\\phi$ 均匀离散化；角度以弧度为单位。\n2. 使用 $h(r) \\propto \\exp\\left(-\\beta U_{\\mathrm{LJ}}(r)\\right)$，构建一个从 $g(r)$ 的低密度近似导出的归一化“形状函数”$h(r)$，该函数限制在区间 $[r_{\\min}, r_{\\max}]$ 内，其中 $r_{\\min} = 0.8\\,\\sigma$ 和 $r_{\\max} = 3.0\\,\\sigma$，并在此区间上均匀离散化 $r$。距离以纳米为单位。将此区间上的 $h(r)$ 归一化，使其成为用于散度比較的概率分布。\n3. 对于测试用例中的每个温度列表，将第一个温度指定为参考温度 $T_{\\mathrm{ref}}$。计算每个非参考温度下 $p(\\phi)$ 的分布与参考分布之间的 Jensen–Shannon 散度。记录 $p(\\phi)$ 在所有温度下的最大散度。对 $h(r)$ 重复相同的计算。\n4. 如果两个最大值都小于或等于指定的阈值，则判定该模型在该测试用例中是可移植的。二面角分布的阈值使用 $\\tau_{\\phi} = 0.05$，径向分布形状的阈值使用 $\\tau_{r} = 0.10$。\n\n常量和单位：\n- 使用玻尔兹曼常数 $k_B = 0.00831446261815324$ 千焦耳每摩尔每开尔文 (kJ mol$^{-1}$ K$^{-1}$)。\n- 温度必须以开尔文 (K) 为单位处理。\n- 能量必须以千焦耳每摩尔 (kJ/mol) 为单位处理。\n- 角度必须以弧度为单位处理。\n- 距离必须以纳米 (nm) 为单位处理。\n\n测试套件：\n实现并评估以下三个测试用例。每个测试用例提供扭转参数 $(n, k_{\\phi}, \\delta)$、Lennard–Jones 参数 $(\\varepsilon, \\sigma)$ 以及一个开尔文为单位的温度列表 $[T_1, T_2, T_3]$。\n\n- 案例1（理想路径，温度变化适中）：\n  - $n = 3$, $k_{\\phi} = 1.0$ kJ/mol, $\\delta = 0.0$ 弧度。\n  - $\\varepsilon = 0.5$ kJ/mol, $\\sigma = 0.50$ nm。\n  - 温度： $[290.0, 300.0, 310.0]$ K。\n\n- 案例2（边界情况，更宽的温度范围和更强的相互作用）：\n  - $n = 3$, $k_{\\phi} = 2.0$ kJ/mol, $\\delta = \\pi/3$ 弧度。\n  - $\\varepsilon = 1.2$ kJ/mol, $\\sigma = 0.50$ nm。\n  - 温度： $[280.0, 320.0, 360.0]$ K。\n\n- 案例3（边缘情况，强相互作用和宽温度范围）：\n  - $n = 2$, $k_{\\phi} = 4.0$ kJ/mol, $\\delta = \\pi/2$ 弧度。\n  - $\\varepsilon = 3.0$ kJ/mol, $\\sigma = 0.45$ nm。\n  - 温度： $[260.0, 320.0, 380.0]$ K。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于每个测试用例，输出一个布尔值，表示在联合考虑 $p(\\phi)$ 和 $h(r)$ 的情况下，模型是否根据上述准则是可移植的（即，仅当两个最大值都在阈值内时才输出 true）。例如，一个可能的输出是“[True,False,False]”。不应打印任何额外文本，也不应从输入中读取任何内容。\n\n按要求以无单位的布尔值作答，角度以弧度处理，距离以纳米处理。程序必须是自包含且确定性的。",
            "solution": "该问题是良构的，且有充分的科学依据，它建立在统计力学和信息论的基本原理之上，并应用于计算化学中的粗粒度建模。所有必需的参数、常数和函数形式都已提供，使得该问题是自包含且可解的。因此，我将着手提供一个完整的解决方案。\n\n目标是评估一个粗粒度模型在不同温度下的可移植性。可移植性意味着在参考温度下推导出的模型参数在一系列温度范围内仍然有效。我们通过测量关键结构分布随温度的变化来量化这一点。问题指定了两种这样的分布：二面角分布 $p(\\phi)$ 和径向分布函数（RDF）形状 $h(r)$。Jensen-Shannon 散度 (JSD)被用作度量标准，以比较这些分布在不同温度下相对于参考温度的情况。\n\n首先，我们定义必要的物理和数学常数及函数。玻尔兹曼常数给定为 $k_B = 0.00831446261815324 \\, \\text{kJ mol}^{-1} \\text{K}^{-1}$。任何分布的温度依赖性都由玻尔兹曼因子 $\\exp(-\\beta U(x))$ 控制，其中 $\\beta = 1/(k_B T)$，$T$ 是绝对温度，$U(x)$ 是给定坐标 $x$ 的势能。\n\n**1. 二面角分布**\n\n扭转角 $\\phi$ 的有效势由下式给出\n$$\nU_{\\mathrm{torsion}}(\\phi) = k_{\\phi}\\left(1 - \\cos(n \\phi - \\delta)\\right)\n$$\n其中 $k_{\\phi}$ 是扭转振幅，$n$ 是周期性，$\\delta$ 是相位偏移。根据正则系综，在温度 $T$ 下二面角 $\\phi$ 的概率密度函数是\n$$\np(\\phi; T) = \\frac{1}{Z_{\\phi}(T)} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi)}{k_B T}\\right)\n$$\n其中 $Z_{\\phi}(T)$ 是配分函数，作为归一化常数：\n$$\nZ_{\\phi}(T) = \\int_{-\\pi}^{\\pi} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi')}{k_B T}\\right) d\\phi'\n$$\n为了计算 JSD，我们需要一个离散概率分布。我们将区间 $\\phi \\in [-\\pi, \\pi]$ 离散化为 $N_{\\phi}$ 个均匀网格点 $\\phi_i$。足够精细的网格，例如 $N_{\\phi} = 10000$ 个点，可确保数值稳定性。第 $i$ 个网格点的离散概率 $P_{\\phi, i}$ 为\n$$\nP_{\\phi, i}(T) = \\frac{\\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi_i)}{k_B T}\\right)}{\\sum_{j=1}^{N_{\\phi}} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi_j)}{k_B T}\\right)}\n$$\n这就为每个温度 $T$ 构成了一个归一化的离散分布 $\\{P_{\\phi, i}(T)\\}_{i=1}^{N_{\\phi}}$。\n\n**2. 径向分布形状函数**\n\nLennard-Jones 势描述了非键对相互作用：\n$$\nU_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\n$$\n其中 $\\varepsilon$ 是势阱深度，$\\sigma$ 是特征长度尺度。在低密度极限下，径向分布函数 $g(r)$ 近似为 $g(r) \\approx \\exp(-\\beta U_{\\mathrm{LJ}}(r))$。问题要求我们在区间 $[r_{\\min}, r_{\\max}]$ 上定义一个归一化的“形状函数”$h(r)$，其中 $r_{\\min} = 0.8\\sigma$，$r_{\\max} = 3.0\\sigma$。其概率密度为\n$$\nh(r; T) = \\frac{1}{Z_{r}(T)} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r)}{k_B T}\\right)\n$$\n归一化常数 $Z_{r}(T)$ 在指定范围内计算：\n$$\nZ_{r}(T) = \\int_{0.8\\sigma}^{3.0\\sigma} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r')}{k_B T}\\right) dr'\n$$\n与二面角情况类似，我们将径向区间离散化为 $N_{r}$ 个均匀网格点 $r_i$。使用 $N_{r} = 10000$ 个点可确保准确性。第 $i$ 个网格点的离散概率 $P_{r, i}$ 为\n$$\nP_{r, i}(T) = \\frac{\\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r_i)}{k_B T}\\right)}{\\sum_{j=1}^{N_{r}} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r_j)}{k_B T}\\right)}\n$$\n这就为每个温度 $T$ 得到了一个归一化的离散分布 $\\{P_{r, i}(T)\\}_{i=1}^{N_{r}}$。\n\n**3. Jensen-Shannon 散度与可移植性准则**\n\nJensen-Shannon 散度 (JSD) 衡量两个概率分布 $P$ 和 $Q$ 之间的相似性。其定义为\n$$\n\\mathrm{JSD}(P,Q) = \\frac{1}{2}\\mathrm{KL}\\left(P \\parallel M\\right) + \\frac{1}{2}\\mathrm{KL}\\left(Q \\parallel M\\right)\n$$\n其中 $M = \\frac{1}{2}(P+Q)$ 是混合分布，$\\mathrm{KL}(P \\parallel Q)$ 是 Kullback-Leibler 散度：\n$$\n\\mathrm{KL}(P\\parallel Q) = \\sum_i P_i \\ln\\left(\\frac{P_i}{Q_i}\\right)\n$$\n对于每个测试用例，列表中的第一个温度 $T_1$作为参考温度 $T_{\\mathrm{ref}}$。我们计算 $T_{\\mathrm{ref}}$ 的分布与列表中每个其他温度 $T_j$ 的分布之间的 JSD。我们找出二面角和径向分布的最大 JSD：\n$$\nD_{\\phi}^{\\max} = \\max_{j1} \\left\\{ \\mathrm{JSD}\\left(P_{\\phi}(T_j), P_{\\phi}(T_{\\mathrm{ref}})\\right) \\right\\}\n$$\n$$\nD_{r}^{\\max} = \\max_{j1} \\left\\{ \\mathrm{JSD}\\left(P_{r}(T_j), P_{r}(T_{\\mathrm{ref}})\\right) \\right\\}\n$$\n如果两个最大值都在各自的阈值内，则该模型被认为是可移植的：\n$$\nD_{\\phi}^{\\max} \\le \\tau_{\\phi} \\quad \\text{and} \\quad D_{r}^{\\max} \\le \\tau_{r}\n$$\n其中指定的阈值为 $\\tau_{\\phi} = 0.05$ 和 $\\tau_{r} = 0.10$。\n\n每个测试用例的算法如下：\n1.  解包参数 $(n, k_{\\phi}, \\delta)$、$(\\varepsilon, \\sigma)$ 和温度 $[T_1, T_2, \\dots]$。设置 $T_{\\mathrm{ref}} = T_1$。\n2.  生成 $\\phi$ 和 $r$ 的离散网格。\n3.  计算参考分布 $P_{\\phi}(T_{\\mathrm{ref}})$ 和 $P_{r}(T_{\\mathrm{ref}})$。\n4.  初始化 $D_{\\phi}^{\\max} = 0$ 和 $D_{r}^{\\max} = 0$。\n5.  对于每个 $j  1$ 的温度 $T_j$：\n    a. 计算分布 $P_{\\phi}(T_j)$ 和 $P_{r}(T_j)$。\n    b. 计算 $\\mathrm{JSD}_{\\phi, j} = \\mathrm{JSD}(P_{\\phi}(T_j), P_{\\phi}(T_{\\mathrm{ref}}))$ 和 $\\mathrm{JSD}_{r, j} = \\mathrm{JSD}(P_{r}(T_j), P_{r}(T_{\\mathrm{ref}}))$。\n    c. 更新 $D_{\\phi}^{\\max} = \\max(D_{\\phi}^{\\max}, \\mathrm{JSD}_{\\phi, j})$ 和 $D_{r}^{\\max} = \\max(D_{r}^{\\max}, \\mathrm{JSD}_{r, j})$。\n6.  将最终的 $D_{\\phi}^{\\max}$ 和 $D_{r}^{\\max}$ 与 $\\tau_{\\phi}$ 和 $\\tau_{r}$ 进行比较，以确定可移植性。\n此过程已为所提供的测试用例实现。",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import jensenshannon\n\ndef solve():\n    \"\"\"\n    Solves the model transferability problem for the given test cases.\n    \"\"\"\n    \n    # Constants and thresholds\n    KB = 0.00831446261815324  # kJ mol^-1 K^-1\n    TAU_PHI = 0.05\n    TAU_R = 0.10\n    N_POINTS = 10000 # Number of points for discretization\n\n    def get_dihedral_distribution(n, k_phi, delta, temp, n_points):\n        \"\"\"\n        Calculates the normalized discrete probability distribution for a dihedral angle.\n        \"\"\"\n        beta = 1.0 / (KB * temp)\n        phi = np.linspace(-np.pi, np.pi, n_points, endpoint=False)\n        u_torsion = k_phi * (1 - np.cos(n * phi - delta))\n        \n        # Using a numerically stable method for normalization\n        log_boltzmann = -beta * u_torsion\n        log_boltzmann -= np.max(log_boltzmann) # Subtract max for stability\n        dist = np.exp(log_boltzmann)\n        dist /= np.sum(dist)\n        return dist\n\n    def get_radial_distribution(epsilon, sigma, temp, n_points):\n        \"\"\"\n        Calculates the normalized discrete probability distribution for a radial shape function.\n        \"\"\"\n        beta = 1.0 / (KB * temp)\n        r_min = 0.8 * sigma\n        r_max = 3.0 * sigma\n        r = np.linspace(r_min, r_max, n_points)\n        \n        # Avoid division by zero if r contains 0, though a linspace from 0.8*sigma won't\n        r_safe = np.where(r == 0, 1e-9, r)\n        \n        term = sigma / r_safe\n        u_lj = 4 * epsilon * (np.power(term, 12) - np.power(term, 6))\n        \n        # Using a numerically stable method for normalization\n        log_boltzmann = -beta * u_lj\n        log_boltzmann -= np.max(log_boltzmann) # Subtract max for stability\n        dist = np.exp(log_boltzmann)\n        dist /= np.sum(dist)\n        return dist\n\n    test_cases = [\n        # Case 1: happy path, modest temperature variation\n        {\n            \"torsion\": (3, 1.0, 0.0), # n, k_phi, delta\n            \"lj\": (0.5, 0.50),        # epsilon, sigma\n            \"temps\": [290.0, 300.0, 310.0]\n        },\n        # Case 2: boundary case, wider temperature span and stronger interactions\n        {\n            \"torsion\": (3, 2.0, np.pi/3),\n            \"lj\": (1.2, 0.50),\n            \"temps\": [280.0, 320.0, 360.0]\n        },\n        # Case 3: edge case, strong interactions and wide temperature span\n        {\n            \"torsion\": (2, 4.0, np.pi/2),\n            \"lj\": (3.0, 0.45),\n            \"temps\": [260.0, 320.0, 380.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        torsion_params = case[\"torsion\"]\n        lj_params = case[\"lj\"]\n        temps = case[\"temps\"]\n        \n        t_ref = temps[0]\n        other_temps = temps[1:]\n        \n        # Calculate reference distributions\n        dist_phi_ref = get_dihedral_distribution(*torsion_params, t_ref, N_POINTS)\n        dist_r_ref = get_radial_distribution(*lj_params, t_ref, N_POINTS)\n        \n        max_jsd_phi = 0.0\n        max_jsd_r = 0.0\n        \n        for temp in other_temps:\n            dist_phi_current = get_dihedral_distribution(*torsion_params, temp, N_POINTS)\n            dist_r_current = get_radial_distribution(*lj_params, temp, N_POINTS)\n            \n            # Scipy's jensenshannon calculates the square root of the JSD. We need to square it.\n            # We must use base=np.e for the natural logarithm as specified.\n            js_distance_phi = jensenshannon(dist_phi_ref, dist_phi_current, base=np.e)\n            jsd_phi = js_distance_phi**2\n            max_jsd_phi = max(max_jsd_phi, jsd_phi)\n\n            js_distance_r = jensenshannon(dist_r_ref, dist_r_current, base=np.e)\n            jsd_r = js_distance_r**2\n            max_jsd_r = max(max_jsd_r, jsd_r)\n\n        is_transferable = (max_jsd_phi = TAU_PHI) and (max_jsd_r = TAU_R)\n        results.append(str(is_transferable))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}