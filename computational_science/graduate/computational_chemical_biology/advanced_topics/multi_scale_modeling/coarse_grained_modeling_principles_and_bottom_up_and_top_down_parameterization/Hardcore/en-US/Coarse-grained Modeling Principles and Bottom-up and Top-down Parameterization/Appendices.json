{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of bottom-up coarse-graining is the principle that effective potentials should reproduce the structural distributions observed in a higher-resolution reference system. For a given coordinate, such as a dihedral angle $\\phi$, its equilibrium probability distribution $p(\\phi)$ is related to the underlying potential of mean force $U(\\phi)$ by the Boltzmann inversion formula, $U(\\phi) = -k_{\\mathrm{B}} T \\ln p(\\phi)$. This practice  guides you through implementing the Iterative Boltzmann Inversion (IBI) method, a robust numerical technique to determine $U(\\phi)$ by iteratively refining the potential until the model's distribution matches a target distribution.",
            "id": "3839139",
            "problem": "You are parameterizing a coarse-grained torsional potential for a residue-level protein model using a bottom-up strategy grounded in equilibrium statistical mechanics. Assume a single dihedral angle $\\phi \\in [-\\pi,\\pi)$ is governed by a one-dimensional torsional potential $U(\\phi)$ that yields the equilibrium marginal distribution $p(\\phi)$ under the canonical ensemble. The canonical probability density for a coordinate $\\phi$ at temperature $T$ satisfies $p(\\phi) \\propto \\exp\\!\\left(-U(\\phi)/(k_{\\mathrm{B}} T)\\right)$, where $k_{\\mathrm{B}}$ is the Boltzmann constant. In reduced units, set $k_{\\mathrm{B}} T = 1$. Your goal is to apply Iterative Boltzmann Inversion (IBI) to derive a discretized torsional potential $U(\\phi)$ that matches a target atomistic dihedral distribution $p_{\\mathrm{target}}(\\phi)$, while making scientifically sound choices for binning and smoothing.\n\nDerive the IBI update rule starting from the canonical ensemble and implement it in a program that iteratively updates $U(\\phi)$ on a uniform angular grid. The implementation must adhere to the following principles and constraints:\n- Discretize the angle $\\phi$ in radians over the interval $[-\\pi,\\pi)$ into $N_b$ uniform bins of width $\\Delta \\phi = 2\\pi/N_b$, with bin centers placed at midpoints. Use angles in radians for all computations.\n- Use the reduced-unit convention $k_{\\mathrm{B}} T = 1$, so energies are expressed in units of $k_{\\mathrm{B}} T$.\n- The target dihedral distribution $p_{\\mathrm{target}}(\\phi)$ is provided analytically as a mixture of von Mises components. A single von Mises component has density $f(\\phi;\\mu,\\kappa) = \\exp\\!\\left(\\kappa \\cos(\\phi-\\mu)\\right) / \\left(2\\pi I_0(\\kappa)\\right)$, where $I_0$ is the modified Bessel function of the first kind of order zero, $\\mu$ is the mean angle (in radians), and $\\kappa$ is the concentration parameter. A mixture with $M$ components has $p_{\\mathrm{target}}(\\phi) \\propto \\sum_{m=1}^M w_m f(\\phi;\\mu_m,\\kappa_m)$ with weights $w_m > 0$ that sum to $1$. Construct $p_{\\mathrm{target}}(\\phi)$ on the discrete grid by evaluating the mixture at bin centers, adding a small pseudocount $\\varepsilon$ to each bin value, and normalizing so that $\\sum_i p_{\\mathrm{target}}(\\phi_i) = 1$.\n- Initialize the torsional potential to $U_0(\\phi_i) = 0$ at all bin centers $\\{\\phi_i\\}$.\n- At each iteration $n$, compute the model distribution $p_n(\\phi_i)$ implied by the current potential via $p_n(\\phi_i) \\propto \\exp\\!\\left(-U_n(\\phi_i)\\right)$ followed by normalization to $\\sum_i p_n(\\phi_i) = 1$.\n- Derive and apply an IBI update to obtain $U_{n+1}(\\phi_i)$ from $U_n(\\phi_i)$ and the ratio between $p_n(\\phi_i)$ and $p_{\\mathrm{target}}(\\phi_i)$, then apply a smoothing operator to $U_{n+1}(\\phi_i)$ that respects the periodicity of $\\phi$ (i.e., wrap-around at $\\pm \\pi$). Use an isotropic Gaussian kernel with standard deviation $\\sigma$ measured in \"bins\" (so the kernel width scales with bin count). After smoothing, fix the potential gauge by subtracting the mean so that $\\frac{1}{N_b}\\sum_i U_{n+1}(\\phi_i) = 0$.\n- Repeat updates for $N_{\\mathrm{iter}}$ iterations.\n\nDesign the binning and smoothing choices to achieve scientific realism: ensure periodic boundary conditions for smoothing, justify the pseudocount $\\varepsilon$ to avoid $\\log(0)$, and explain how the bin width $\\Delta \\phi$ controls resolution. Use radians for angles and express energies in $k_{\\mathrm{B}} T$ units. Report a quantitative mismatch metric between the final model distribution and the target distribution. Use the integrated absolute difference\n$$\nE = \\sum_{i=1}^{N_b} \\left| p_{\\mathrm{final}}(\\phi_i) - p_{\\mathrm{target}}(\\phi_i) \\right| \\Delta \\phi\n$$\nas a dimensionless scalar error.\n\nImplement the program and evaluate it on the following test suite, which explores a general case, a coarse-binning case, and a wrap-around edge case. In all cases, angles are in radians, energies are in $k_{\\mathrm{B}} T$ units, and the Gaussian smoothing standard deviation $\\sigma$ is specified in bins.\n\nTest case $1$ (happy path):\n- $N_b = 72$, $\\sigma = 0.0$, $\\varepsilon = 10^{-6}$, $N_{\\mathrm{iter}} = 3$.\n- Target mixture: $M = 1$ component with $(w_1,\\mu_1,\\kappa_1) = (1.0, 0.0, 5.0)$.\n\nTest case $2$ (coarse bins and smoothing):\n- $N_b = 12$, $\\sigma = 1.5$, $\\varepsilon = 10^{-6}$, $N_{\\mathrm{iter}} = 5$.\n- Target mixture: $M = 2$ components with $(w_1,\\mu_1,\\kappa_1) = (0.6, \\pi/3, 8.0)$ and $(w_2,\\mu_2,\\kappa_2) = (0.4, -\\pi/3, 4.0)$.\n\nTest case $3$ (edge case near periodic boundary):\n- $N_b = 36$, $\\sigma = 0.5$, $\\varepsilon = 10^{-8}$, $N_{\\mathrm{iter}} = 10$.\n- Target mixture: $M = 2$ components with $(w_1,\\mu_1,\\kappa_1) = (0.5, \\pi - 0.01, 20.0)$ and $(w_2,\\mu_2,\\kappa_2) = (0.5, -\\pi + 0.01, 20.0)$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list must contain the three $E$ values, in the order of the test cases $(1,2,3)$, each rounded to $6$ decimal places, for example, $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$.",
            "solution": "We begin from the canonical ensemble for a one-dimensional torsional coordinate $\\phi$ with potential $U(\\phi)$ at temperature $T$. The equilibrium marginal probability density is\n$$\np(\\phi) = \\frac{1}{Z} \\exp\\!\\left(-\\frac{U(\\phi)}{k_{\\mathrm{B}} T}\\right),\n$$\nwhere $Z = \\int_{-\\pi}^{\\pi} \\exp\\!\\left(-U(\\phi)/(k_{\\mathrm{B}} T)\\right)\\, d\\phi$ is the partition function. In reduced units with $k_{\\mathrm{B}} T = 1$, this simplifies to $p(\\phi) \\propto \\exp\\!\\left(-U(\\phi)\\right)$.\n\nIn a bottom-up parameterization by Iterative Boltzmann Inversion (IBI), we seek a torsional potential $U(\\phi)$ that reproduces a target atomistic distribution $p_{\\mathrm{target}}(\\phi)$. Let $U_n(\\phi)$ be the potential at iteration $n$, and $p_n(\\phi)$ the corresponding model distribution implied by $U_n(\\phi)$ via the canonical ensemble. By construction,\n$$\np_n(\\phi) = \\frac{\\exp\\!\\left(-U_n(\\phi)\\right)}{\\int_{-\\pi}^{\\pi} \\exp\\!\\left(-U_n(\\phi')\\right) d\\phi'}.\n$$\nThe IBI update can be derived from the desire to correct $U_n(\\phi)$ such that $p_{n+1}(\\phi)$ approaches $p_{\\mathrm{target}}(\\phi)$. Consider an additive correction $\\Delta U_n(\\phi)$ so that $U_{n+1}(\\phi) = U_n(\\phi) + \\Delta U_n(\\phi)$. If we enforce $p_{n+1}(\\phi) = p_{\\mathrm{target}}(\\phi)$ exactly, then\n$$\np_{\\mathrm{target}}(\\phi) \\propto \\exp\\!\\left(-U_{n+1}(\\phi)\\right) = \\exp\\!\\left(-U_n(\\phi) - \\Delta U_n(\\phi)\\right) = \\exp\\!\\left(-U_n(\\phi)\\right)\\exp\\!\\left(-\\Delta U_n(\\phi)\\right).\n$$\nTaking logarithms and using proportionality (i.e., ignoring normalization constants), we get\n$$\n\\ln p_{\\mathrm{target}}(\\phi) = \\ln p_n(\\phi) - \\Delta U_n(\\phi) + \\text{constant}.\n$$\nChoosing the gauge (i.e., additive constant) so that the correction has zero mean, the natural update is\n$$\n\\Delta U_n(\\phi) = \\ln \\frac{p_n(\\phi)}{p_{\\mathrm{target}}(\\phi)}.\n$$\nRestoring $k_{\\mathrm{B}} T$ yields $\\Delta U_n(\\phi) = k_{\\mathrm{B}} T \\ln\\!\\left(p_n(\\phi)/p_{\\mathrm{target}}(\\phi)\\right)$, and in reduced units $k_{\\mathrm{B}} T = 1$, this becomes\n$$\nU_{n+1}(\\phi) = U_n(\\phi) + \\ln \\frac{p_n(\\phi)}{p_{\\mathrm{target}}(\\phi)}.\n$$\nThis update equates $p_{n+1}(\\phi)$ to $p_{\\mathrm{target}}(\\phi)$ if applied without smoothing and with exact distributions. In practice, to achieve stability and enforce physical smoothness, we discretize $\\phi$, apply regularization to $p_{\\mathrm{target}}$, and smooth $U_{n+1}$.\n\nDiscretization and binning: We select $N_b$ uniform bins over $[-\\pi,\\pi)$ with bin width $\\Delta \\phi = 2\\pi/N_b$ and centers at $\\phi_i = -\\pi + (i+1/2)\\Delta \\phi$ for $i = 0,\\dots,N_b-1$. The discrete $p_{\\mathrm{target}}(\\phi_i)$ is obtained from a mixture of von Mises components,\n$$\np_{\\mathrm{target}}(\\phi) \\propto \\sum_{m=1}^M w_m \\frac{\\exp\\!\\left(\\kappa_m \\cos(\\phi - \\mu_m)\\right)}{2\\pi I_0(\\kappa_m)}.\n$$\nTo prevent numerical issues such as $\\log(0)$, we add a pseudocount $\\varepsilon > 0$ to each bin and renormalize so that $\\sum_i p_{\\mathrm{target}}(\\phi_i) = 1$.\n\nModel distribution: Given a discrete potential $U_n(\\phi_i)$, we compute\n$$\np_n(\\phi_i) = \\frac{\\exp\\!\\left(-U_n(\\phi_i)\\right)}{\\sum_{j=1}^{N_b} \\exp\\!\\left(-U_n(\\phi_j)\\right)}.\n$$\n\nIBI update and smoothing: The discrete update is\n$$\nU_{n+1}(\\phi_i) = U_n(\\phi_i) + \\ln \\frac{p_n(\\phi_i)}{p_{\\mathrm{target}}(\\phi_i)}.\n$$\nWe then smooth $U_{n+1}(\\phi_i)$ with a Gaussian kernel of standard deviation $\\sigma$ measured in bins, using periodic boundary conditions (wrap-around) to respect the angular periodicity. Smoothing the potential, rather than the probability, enforces a physically reasonable regularization on the energy landscape. Since the potential is defined up to an additive constant, we fix its gauge by subtracting the mean value so that $\\frac{1}{N_b}\\sum_i U_{n+1}(\\phi_i) = 0$.\n\nError metric: After $N_{\\mathrm{iter}}$ iterations, we form $p_{\\mathrm{final}}(\\phi_i)$ from $U_{N_{\\mathrm{iter}}}(\\phi_i)$ and compute the integrated absolute difference\n$$\nE = \\sum_{i=1}^{N_b} \\left| p_{\\mathrm{final}}(\\phi_i) - p_{\\mathrm{target}}(\\phi_i) \\right| \\Delta \\phi,\n$$\nwhich is dimensionless and quantifies the mismatch.\n\nBinning and smoothing choices: The bin count $N_b$ sets the resolution $\\Delta \\phi$. Larger $N_b$ yields finer resolution at the cost of potentially noisier estimates if sampling were involved; here it enables better capture of sharp features in $p_{\\mathrm{target}}$. The pseudocount $\\varepsilon$ avoids undefined logarithms and overly large updates in bins with tiny probabilities. The smoothing parameter $\\sigma$ (in bins) controls regularity: $\\sigma = 0$ leaves $U$ unchanged, while larger $\\sigma$ produces smoother torsional profiles. Because $\\phi$ is periodic, smoothing must be performed with wrap-around boundary conditions to avoid artifacts near $\\pm \\pi$.\n\nAlgorithmic steps mapped to the program:\n1. Construct the grid of $N_b$ bin centers over $[-\\pi,\\pi)$.\n2. Build $p_{\\mathrm{target}}(\\phi_i)$ from the von Mises mixture, add $\\varepsilon$, and normalize.\n3. Set $U_0(\\phi_i) = 0$.\n4. For $n = 0,\\dots,N_{\\mathrm{iter}}-1$:\n   a. Compute $p_n(\\phi_i)$ from $U_n(\\phi_i)$.\n   b. Form the update $\\Delta U_n(\\phi_i) = \\ln\\!\\left(p_n(\\phi_i)/p_{\\mathrm{target}}(\\phi_i)\\right)$.\n   c. Set $U_{n+1}(\\phi_i) = U_n(\\phi_i) + \\Delta U_n(\\phi_i)$.\n   d. Smooth $U_{n+1}(\\phi_i)$ with a Gaussian kernel of standard deviation $\\sigma$ using wrap-around boundary conditions, then subtract its mean to fix the gauge.\n5. Compute $p_{\\mathrm{final}}(\\phi_i)$ and $E$.\n\nTest suite design:\n- Test case $1$ uses $N_b = 72$ and $\\sigma = 0.0$ to show that, in the absence of smoothing, the IBI update achieves an almost exact match to a unimodal $p_{\\mathrm{target}}$.\n- Test case $2$ uses coarse bins $N_b = 12$ and $\\sigma = 1.5$ to demonstrate that smoothing and coarse resolution produce a controlled mismatch for a bimodal target.\n- Test case $3$ places sharp peaks near the periodic boundary with $N_b = 36$ and $\\sigma = 0.5$, showing correct wrap-around handling and the role of pseudocount $\\varepsilon = 10^{-8}$.\n\nThe program outputs a single line with the three $E$ values, in the order of the test cases, rounded to $6$ decimal places, formatted as $\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3\\right]$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0\nfrom scipy.ndimage import gaussian_filter1d\n\ndef von_mises_mixture(phi, components):\n    \"\"\"\n    Compute a mixture of von Mises densities at angles phi.\n    components: list of tuples (weight, mu, kappa)\n    Returns unnormalized mixture values evaluated at phi.\n    \"\"\"\n    # Each component: w * exp(kappa * cos(phi - mu)) / (2*pi*I0(kappa))\n    vals = np.zeros_like(phi, dtype=np.float64)\n    for w, mu, kappa in components:\n        vals += w * np.exp(kappa * np.cos(phi - mu)) / (2.0 * np.pi * i0(kappa))\n    return vals\n\ndef ibi_torsion(phi_centers, p_target, sigma_bins, n_iter):\n    \"\"\"\n    Perform Iterative Boltzmann Inversion on a discretized torsion.\n    phi_centers: array of bin centers in radians\n    p_target: normalized target distribution over bins (sum to 1)\n    sigma_bins: Gaussian smoothing standard deviation in bins\n    n_iter: number of IBI iterations\n    Returns final potential U (mean-zero) and final distribution p_final.\n    \"\"\"\n    nb = len(phi_centers)\n    # Initialize potential U0 = 0\n    U = np.zeros(nb, dtype=np.float64)\n    # Iterate IBI updates\n    for _ in range(n_iter):\n        # Model distribution from current potential\n        exp_neg_U = np.exp(-U)\n        p_model = exp_neg_U / np.sum(exp_neg_U)\n        # Update rule in reduced units (k_B T = 1): U_{n+1} = U_n + ln(p_model / p_target)\n        # Avoid division issues: p_target is strictly positive due to pseudocount\n        delta_U = np.log(p_model / p_target)\n        U = U + delta_U\n        # Smooth potential with Gaussian kernel, respecting periodicity\n        if sigma_bins > 0.0:\n            U = gaussian_filter1d(U, sigma=sigma_bins, mode='wrap')\n        # Fix gauge: subtract mean\n        U = U - np.mean(U)\n    # Final distribution from final potential\n    exp_neg_U = np.exp(-U)\n    p_final = exp_neg_U / np.sum(exp_neg_U)\n    return U, p_final\n\ndef build_target_distribution(phi_centers, components, epsilon):\n    \"\"\"\n    Build normalized discrete target distribution from von Mises mixture,\n    add pseudocount epsilon to each bin, and renormalize.\n    \"\"\"\n    p_raw = von_mises_mixture(phi_centers, components)\n    # Add pseudocount to all bins to avoid zeros\n    p_raw = p_raw + epsilon\n    # Normalize to sum 1\n    p_target = p_raw / np.sum(p_raw)\n    return p_target\n\ndef integrated_abs_difference(p_final, p_target, dphi):\n    \"\"\"\n    Compute E = sum |p_final - p_target| * dphi\n    \"\"\"\n    return float(np.sum(np.abs(p_final - p_target)) * dphi)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Angles in radians over [-pi, pi)\n    test_cases = [\n        # Test case 1: N_b=72, sigma=0.0, epsilon=1e-6, N_iter=3, unimodal von Mises\n        {\n            \"Nb\": 72,\n            \"sigma\": 0.0,\n            \"epsilon\": 1e-6,\n            \"n_iter\": 3,\n            \"components\": [(1.0, 0.0, 5.0)]\n        },\n        # Test case 2: N_b=12, sigma=1.5, epsilon=1e-6, N_iter=5, bimodal mixture\n        {\n            \"Nb\": 12,\n            \"sigma\": 1.5,\n            \"epsilon\": 1e-6,\n            \"n_iter\": 5,\n            \"components\": [(0.6, np.pi/3.0, 8.0), (0.4, -np.pi/3.0, 4.0)]\n        },\n        # Test case 3: N_b=36, sigma=0.5, epsilon=1e-8, N_iter=10, sharp peaks near boundaries\n        {\n            \"Nb\": 36,\n            \"sigma\": 0.5,\n            \"epsilon\": 1e-8,\n            \"n_iter\": 10,\n            \"components\": [(0.5, np.pi - 0.01, 20.0), (0.5, -np.pi + 0.01, 20.0)]\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        Nb = case[\"Nb\"]\n        sigma = case[\"sigma\"]\n        epsilon = case[\"epsilon\"]\n        n_iter = case[\"n_iter\"]\n        components = case[\"components\"]\n\n        # Discretize phi in [-pi, pi)\n        dphi = 2.0 * np.pi / Nb\n        phi_centers = -np.pi + (np.arange(Nb) + 0.5) * dphi\n\n        # Build target distribution with pseudocount\n        p_target = build_target_distribution(phi_centers, components, epsilon)\n\n        # Run IBI with periodic Gaussian smoothing\n        U_final, p_final = ibi_torsion(phi_centers, p_target, sigma_bins=sigma, n_iter=n_iter)\n\n        # Compute integrated absolute difference E\n        E = integrated_abs_difference(p_final, p_target, dphi)\n\n        # Round to 6 decimals for final output format\n        results.append(f\"{E:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While bottom-up methods excel at reproducing structural properties, they do not automatically guarantee correctness for thermodynamic observables like pressure. This discrepancy often necessitates a top-down refinement step to ensure the model is thermodynamically consistent. In this exercise , you will tackle this common challenge by designing a pressure correction potential based on the fundamental virial expression for pressure, thereby adjusting a coarse-grained model to match a specified target pressure.",
            "id": "3839161",
            "problem": "You are tasked with implementing a computational procedure to quantify and correct pressure deviations in a coarse-grained fluid model parameterized using Iterative Boltzmann Inversion (IBI). The system is assumed to be an isotropic fluid with pairwise-additive interactions truncated at a finite cutoff. All quantities are expressed in reduced, dimensionless units where the Boltzmann constant is $k_{\\mathrm{B}} = 1$, the reduced temperature $T$ is expressed in the same reduced units, and pressure is measured in the reduced unit of energy per unit volume. You must use the virial route to compute the pressure for a given radial distribution function and pair potential derivative, and then design a pressure correction term based on the virial identity to enforce a specified target pressure.\n\nFundamental base to use:\n- The virial expression for the pressure of an isotropic, homogeneous fluid with pairwise additive potential $u(r)$ at number density $\\rho$ and reduced temperature $T$ is\n$$\nP(\\rho, T) = \\rho\\,T - \\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,u'(r)\\,g(r)\\,dr,\n$$\nwhere $g(r)$ is the radial distribution function, $u'(r)$ is the derivative of the pair potential with respect to $r$, and $r_c$ is the cutoff radius.\n- An additive correction to the potential, $\\Delta u(r)$, changes the pressure by\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\Delta u'(r)\\,g(r)\\,dr.\n$$\n\nYour design objective:\n- Define a linear-in-$r$ pressure correction term\n$$\n\\Delta u(r) = a\\left(1 - \\frac{r}{r_c}\\right)\\,H(r_c - r),\n$$\nwhere $H(\\cdot)$ is the Heaviside step function and $a$ is an amplitude to be determined such that the corrected model pressure matches a given target pressure $P^\\star$. Using the fundamental base above and the definition of $\\Delta u(r)$, derive and implement an explicit formula for $a$ in terms of the pressure deviation $\\Delta P = P^\\star - P(\\rho,T)$ and a radial integral over $g(r)$.\n\nNumerical setup:\n- Use the Lennard–Jones pair potential in reduced form with $\\epsilon = 1$ and $\\sigma = 1$:\n$$\nu_{\\mathrm{LJ}}(r) = 4\\left[\\left(\\frac{1}{r}\\right)^{12} - \\left(\\frac{1}{r}\\right)^{6}\\right],\\quad\nu'_{\\mathrm{LJ}}(r) = 4\\left[-12\\,r^{-13} + 6\\,r^{-7}\\right].\n$$\n- To avoid force discontinuities at the cutoff, use the force-shifted derivative inside the cutoff,\n$$\nu'_{\\mathrm{FS}}(r) = u'_{\\mathrm{LJ}}(r) - u'_{\\mathrm{LJ}}(r_c), \\quad \\text{for } r \\le r_c,\n$$\nand $u'_{\\mathrm{FS}}(r) = 0$ for $r > r_c$.\n- Approximate all integrals by the trapezoidal rule over a uniform radial grid $r_i = r_{\\min} + i\\,\\Delta r$ with $i = 0,\\dots,N$, where $r_{\\min} = 0.9$ and $\\Delta r = 0.001$. The upper bound is $r_c$ for each test case. Construct the grid so that $r_0 = r_{\\min}$ and $r_N = r_c$ exactly.\n\nRequired computations for each test case:\n1. Compute the model pressure $P(\\rho,T)$ using the virial expression with $u'_{\\mathrm{FS}}(r)$ and the specified $g(r)$.\n2. Compute the pressure deviation $\\Delta P = P^\\star - P(\\rho,T)$.\n3. Using virial considerations and the definition of $\\Delta u(r)$, determine the amplitude $a$ of the pressure correction that would enforce $P^\\star$ when evaluated with the same $g(r)$.\n4. Report the triple of floats $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$, where $P_{\\mathrm{corrected}} = P(\\rho,T) + \\Delta P$ using your derived $\\Delta P$; this should match $P^\\star$ up to numerical quadrature error.\n\nAngle units are not involved. No percentages are involved. All outputs are unitless reduced quantities. Your program must round each float to $6$ decimal places.\n\nTest suite:\n- Use the following three test cases, each with the specified parameters. In all cases, use $r_{\\min} = 0.9$ and $\\Delta r = 0.001$.\n- Test case $1$ (happy path, structured correlations):\n  - $\\rho = 0.8$, $T = 1.0$, $r_c = 2.5$, $P^\\star = 0.8$.\n  - Define $g(r)$ as $g(r) = s(r)\\,h(r)$ with\n    $$\n    s(r) = \\frac{1}{1 + \\exp\\left[-k\\,(r - r_s)\\right]},\\quad k = 20,\\ r_s = 1.0,\n    $$\n    $$\n    h(r) = 1 + A\\,\\exp\\!\\left(-\\frac{(r - r_m)^2}{w^2}\\right)\\cos\\!\\left(\\omega\\,(r - r_m)\\right),\n    $$\n    with $A = 0.25$, $r_m = 1.2$, $w = 0.4$, and $\\omega = 8$.\n- Test case $2$ (low-density limit, same structure proxy):\n  - $\\rho = 0.05$, $T = 1.0$, $r_c = 2.5$, $P^\\star = 0.05$.\n  - Use the same $g(r)$ as in test case $1$.\n- Test case $3$ (shorter cutoff, near-ideal structure):\n  - $\\rho = 0.8$, $T = 1.0$, $r_c = 1.5$, $P^\\star = 1.2$.\n  - Define $g(r) = 1$ for all $r \\in [r_{\\min}, r_c]$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list of lists, each inner list containing the three floats $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$ rounded to $6$ decimal places, in the order of the test suite. For example, the output format must be exactly like\n$$\n[[P_1,a_1,P_{c,1}],[P_2,a_2,P_{c,2}],[P_3,a_3,P_{c,3}]].\n$$",
            "solution": "The problem statement has been critically validated and is deemed to be scientifically grounded, well-posed, objective, and self-consistent. It presents a standard computational task in the field of coarse-grained molecular modeling, based on fundamental principles of statistical mechanics. All provided data, definitions, and conditions are sufficient and coherent for deriving a unique and meaningful solution.\n\nThe primary objective is to derive and implement a formula for the amplitude $a$ of a linear pressure-correction potential, $\\Delta u(r)$, such that the pressure of a coarse-grained fluid model matches a target pressure $P^\\star$. The derivation proceeds from the virial expression for pressure.\n\nThe total pressure $P$ of a homogeneous, isotropic fluid with pairwise interactions is given by the virial theorem:\n$$\nP(\\rho, T) = \\rho\\,T - \\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,u'(r)\\,g(r)\\,dr\n$$\nHere, $\\rho$ is the number density, $T$ is the reduced temperature, $u'(r)$ is the derivative of the pair potential, $g(r)$ is the radial distribution function, and $r_c$ is the cutoff radius. All quantities are in reduced units.\n\nA small, additive correction to the potential, $\\Delta u(r)$, induces a corresponding change in pressure, $\\Delta P$:\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\Delta u'(r)\\,g(r)\\,dr\n$$\nWe require this pressure change to correct the initial model pressure, $P_{\\text{model}} = P(\\rho, T)$, to a target pressure, $P^\\star$. Thus, we set the desired pressure change to be $\\Delta P_{\\text{target}} = P^\\star - P_{\\text{model}}$.\n\nThe problem specifies a linear correction potential of the form:\n$$\n\\Delta u(r) = a\\left(1 - \\frac{r}{r_c}\\right)\\,H(r_c - r)\n$$\nwhere $H(\\cdot)$ is the Heaviside step function, ensuring the correction is zero for $r > r_c$. For $r \\le r_c$, the derivative of this correction potential with respect to $r$ is a constant:\n$$\n\\Delta u'(r) = \\frac{d}{dr}\\left[a\\left(1 - \\frac{r}{r_c}\\right)\\right] = -\\frac{a}{r_c}\n$$\nSubstituting this derivative into the expression for $\\Delta P$:\n$$\n\\Delta P = -\\frac{2\\pi \\rho^{2}}{3}\\int_{0}^{r_c} r^{3}\\,\\left(-\\frac{a}{r_c}\\right)\\,g(r)\\,dr\n$$\nSince $a$ and $r_c$ are constants, they can be factored out of the integral:\n$$\n\\Delta P = \\frac{2\\pi a \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr\n$$\nTo achieve the target pressure, we set $\\Delta P = \\Delta P_{\\text{target}} = P^\\star - P_{\\text{model}}$ and solve for the amplitude $a$:\n$$\nP^\\star - P_{\\text{model}} = \\frac{2\\pi a \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr\n$$\n$$\na = \\frac{P^\\star - P_{\\text{model}}}{\\frac{2\\pi \\rho^{2}}{3r_c}\\int_{0}^{r_c} r^{3}\\,g(r)\\,dr}\n$$\nRearranging gives the final explicit formula for $a$:\n$$\na = \\frac{3r_c (P^\\star - P_{\\text{model}})}{2\\pi\\rho^{2} \\int_{0}^{r_c} r^{3}\\,g(r)\\,dr}\n$$\nThe computational procedure is as follows:\n1.  For each test case, a uniform radial grid $r_i$ is constructed from $r_{\\min} = 0.9$ to the specified $r_c$ with spacing $\\Delta r = 0.001$. The integrals are numerically evaluated over this grid using the trapezoidal rule, which is a valid approximation as $g(r)$ is effectively zero for $r < r_{\\min}$.\n2.  The force-shifted Lennard-Jones derivative, $u'_{\\mathrm{FS}}(r) = u'_{\\mathrm{LJ}}(r) - u'_{\\mathrm{LJ}}(r_c)$, and the given radial distribution function $g(r)$ are evaluated on the grid.\n3.  The initial model pressure, $P_{\\text{model}} \\equiv P(\\rho, T)$, is computed by numerically evaluating the virial integral $\\int_{r_{\\min}}^{r_c} r^{3}\\,u'_{\\mathrm{FS}}(r)\\,g(r)\\,dr$ and substituting it into the pressure equation.\n4.  The denominator of the expression for $a$ is computed by numerically evaluating the integral $\\int_{r_{\\min}}^{r_c} r^{3}\\,g(r)\\,dr$.\n5.  With $P_{\\text{model}}$ and the required integral known, the amplitude $a$ is calculated using the derived formula.\n6.  The corrected pressure, $P_{\\mathrm{corrected}}$, is calculated as $P_{\\text{model}} + \\Delta P$. By construction, $\\Delta P = P^\\star - P_{\\text{model}}$, so $P_{\\mathrm{corrected}}$ must equal $P^\\star$, up to numerical precision. This serves as a consistency check.\n7.  The final results for each test case, $[P(\\rho,T), a, P_{\\mathrm{corrected}}]$, are collected and formatted.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def u_lj_prime(r):\n        \"\"\"\n        Computes the derivative of the reduced Lennard-Jones potential.\n        sigma = 1, epsilon = 1.\n        \"\"\"\n        r_inv = 1.0 / r\n        r_inv7 = r_inv**7\n        r_inv13 = r_inv**13\n        return 4.0 * (-12.0 * r_inv13 + 6.0 * r_inv7)\n\n    def get_g_case1_and_2(r):\n        \"\"\"\n        Computes the radial distribution function g(r) for test cases 1 and 2.\n        \"\"\"\n        k = 20.0\n        r_s = 1.0\n        s_r = 1.0 / (1.0 + np.exp(-k * (r - r_s)))\n\n        A = 0.25\n        r_m = 1.2\n        w = 0.4\n        omega = 8.0\n        h_r = 1.0 + A * np.exp(-((r - r_m) / w)**2) * np.cos(omega * (r - r_m))\n        return s_r * h_r\n\n    def get_g_case3(r):\n        \"\"\"\n        Computes the radial distribution function g(r) for test case 3.\n        \"\"\"\n        return np.ones_like(r)\n\n    def solve_case(params):\n        \"\"\"\n        Solves one case for P, a, and P_corrected.\n        \"\"\"\n        rho, T, r_c, P_star, g_func = params\n        r_min = 0.9\n        dr = 0.001\n\n        # 1. Construct the numerical grid\n        num_points = int(round((r_c - r_min) / dr)) + 1\n        r = np.linspace(r_min, r_c, num_points)\n\n        # 2. Evaluate functions on the grid\n        g_r = g_func(r)\n        u_lj_prime_rc = u_lj_prime(r_c)\n        u_fs_prime_r = u_lj_prime(r) - u_lj_prime_rc\n\n        # 3. Compute initial model pressure P\n        integrand_P = r**3 * u_fs_prime_r * g_r\n        I_P = np.trapz(integrand_P, r)\n        virial_term = (2.0 * np.pi * rho**2 / 3.0) * I_P\n        P_model = rho * T - virial_term\n\n        # 4. Compute the integral for the correction amplitude 'a'\n        integrand_a = r**3 * g_r\n        I_a = np.trapz(integrand_a, r)\n        \n        # 5. Compute 'a'\n        pressure_deviation = P_star - P_model\n        denominator_a = (2.0 * np.pi * rho**2 / (3.0 * r_c)) * I_a\n        \n        # Avoid division by zero, though not expected in this problem\n        if abs(denominator_a)  1e-15:\n            a = np.nan\n        else:\n            a = pressure_deviation / denominator_a\n\n        # 6. Compute the corrected pressure as a consistency check\n        # By construction, P_corrected = P_model + pressure_deviation = P_star\n        delta_P_calculated = a * denominator_a\n        P_corrected = P_model + delta_P_calculated\n\n        return [P_model, a, P_corrected]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.8, 1.0, 2.5, 0.8, get_g_case1_and_2),   # Case 1\n        (0.05, 1.0, 2.5, 0.05, get_g_case1_and_2), # Case 2\n        (0.8, 1.0, 1.5, 1.2, get_g_case3),          # Case 3\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = solve_case(case)\n        all_results.append(result)\n\n    # Format the results into the required string format.\n    formatted_results = []\n    for res_list in all_results:\n        # Each res_list is [P, a, P_corrected]\n        formatted_list_str = [f\"{val:.6f}\" for val in res_list]\n        formatted_results.append(f\"[{','.join(formatted_list_str)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "The ultimate test of a coarse-grained model is not just its accuracy at the reference state but its transferability to different conditions, which determines its predictive power. A robust model should yield stable structural predictions across a reasonable range of temperatures. This practice  provides a quantitative framework for assessing temperature transferability by comparing key structural distributions at different temperatures using the Jensen-Shannon divergence, allowing you to rigorously evaluate whether a model's parameters are valid beyond their initial fitting conditions.",
            "id": "3839217",
            "problem": "You are given a conceptual coarse-grained model for a protein, where both bonded dihedral interactions and nonbonded pair interactions are represented by effective potentials. Assess the transferability of this coarse-grained model across temperature changes by quantifying the stability of the dihedral angle distribution and the radial distribution function. Your task is to implement a program that, for each provided parameter set, determines whether the model is transferable across the specified temperatures according to a divergence-based criterion.\n\nFundamental base:\n- In the canonical ensemble, the probability density of a coordinate $x$ is proportional to $\\exp(-\\beta U(x))$, where $\\beta = 1/(k_{\\mathrm{B}} T)$, $k_B$ is the Boltzmann constant, $T$ is the temperature, and $U(x)$ is the potential energy.\n- For the dihedral angle $\\phi$ of a coarse-grained bond, assume an effective torsional potential $U_{\\mathrm{torsion}}(\\phi) = k_{\\phi}\\left(1 - \\cos(n \\phi - \\delta)\\right)$, where $k_{\\phi}$ is the torsional amplitude, $n$ is the periodicity, and $\\delta$ is the phase offset. Angles must be handled in radians.\n- In the low-density limit (physically realistic for dilute protein solutions), the radial distribution function $g(r)$ for a pair interaction approximates $\\exp\\left(-\\beta U_{\\mathrm{LJ}}(r)\\right)$, where $U_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]$ is the Lennard-Jones potential, with $\\varepsilon$ the well depth and $\\sigma$ the characteristic length. Distances must be handled in nanometers.\n- To compare distributions across temperatures, use the Jensen–Shannon divergence, defined for two normalized discrete distributions $P$ and $Q$ on the same support as $\\mathrm{JSD}(P,Q) = \\frac{1}{2}\\mathrm{KL}\\left(P \\parallel M\\right) + \\frac{1}{2}\\mathrm{KL}\\left(Q \\parallel M\\right)$, where $M = \\frac{1}{2}(P+Q)$ and $\\mathrm{KL}$ denotes the Kullback–Leibler divergence $\\mathrm{KL}(P\\parallel Q) = \\sum_i P_i \\ln\\left(\\frac{P_i}{Q_i}\\right)$. Use the natural logarithm.\n\nYour program must, for each test case, perform the following steps:\n1. Construct the discrete, normalized dihedral distribution $p(\\phi)$ at each specified temperature, using the canonical ensemble with $U_{\\mathrm{torsion}}(\\phi)$. Discretize $\\phi$ uniformly over the interval $[-\\pi, \\pi]$ using a sufficiently fine grid; angles are in radians.\n2. Construct a normalized “shape function” $h(r)$ derived from the low-density approximation to $g(r)$, using $h(r) \\propto \\exp\\left(-\\beta U_{\\mathrm{LJ}}(r)\\right)$, restricted to the interval $[r_{\\min}, r_{\\max}]$ with $r_{\\min} = 0.8\\,\\sigma$ and $r_{\\max} = 3.0\\,\\sigma$, and discretize $r$ uniformly over this interval. Distances are in nanometers. Normalize $h(r)$ on this interval to be a probability distribution for divergence comparison.\n3. For each temperature list in the test case, designate the first temperature as the reference temperature $T_{\\mathrm{ref}}$. Compute the Jensen–Shannon divergence for $p(\\phi)$ at each non-reference temperature versus the reference distribution. Record the maximum divergence across temperatures for $p(\\phi)$. Repeat the same calculation for $h(r)$.\n4. Decide that the model is transferable for that test case if both maxima are less than or equal to specified thresholds. Use $\\tau_{\\phi} = 0.05$ for the dihedral distribution and $\\tau_{r} = 0.10$ for the radial distribution shape.\n\nConstants and units:\n- Use the Boltzmann constant $k_B = 0.00831446261815324$ kilojoules per mole per kelvin (kJ mol$^{-1}$ K$^{-1}$).\n- Temperatures must be treated in kelvin (K).\n- Energies must be treated in kilojoules per mole (kJ/mol).\n- Angles must be handled in radians.\n- Distances must be handled in nanometers (nm).\n\nTest suite:\nImplement and evaluate the following three test cases. Each test case provides the torsion parameters $(n, k_{\\phi}, \\delta)$, the Lennard–Jones parameters $(\\varepsilon, \\sigma)$, and a list of temperatures $[T_1, T_2, T_3]$ in kelvin.\n\n- Case 1 (happy path, modest temperature variation):\n  - $n = 3$, $k_{\\phi} = 1.0$ kJ/mol, $\\delta = 0.0$ radians.\n  - $\\varepsilon = 0.5$ kJ/mol, $\\sigma = 0.50$ nm.\n  - Temperatures: $[290.0, 300.0, 310.0]$ K.\n\n- Case 2 (boundary case, wider temperature span and stronger interactions):\n  - $n = 3$, $k_{\\phi} = 2.0$ kJ/mol, $\\delta = \\pi/3$ radians.\n  - $\\varepsilon = 1.2$ kJ/mol, $\\sigma = 0.50$ nm.\n  - Temperatures: $[280.0, 320.0, 360.0]$ K.\n\n- Case 3 (edge case, strong interactions and wide temperature span):\n  - $n = 2$, $k_{\\phi} = 4.0$ kJ/mol, $\\delta = \\pi/2$ radians.\n  - $\\varepsilon = 3.0$ kJ/mol, $\\sigma = 0.45$ nm.\n  - Temperatures: $[260.0, 320.0, 380.0]$ K.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For each test case, output a boolean value indicating whether the model is transferable under the above criterion for both $p(\\phi)$ and $h(r)$ considered jointly (i.e., output true only if both maxima are within thresholds). For example, a possible output could be \"[True,False,False]\". No additional text should be printed, and nothing should be read from input.\n\nAnswer in unitless booleans as described, with angles treated in radians and distances treated in nanometers. The program must be self-contained and deterministic.",
            "solution": "The problem is well-posed and scientifically grounded, resting on fundamental principles of statistical mechanics and information theory as applied to coarse-grained modeling in computational chemistry. All necessary parameters, constants, and functional forms are provided, rendering the problem self-contained and solvable. I will therefore proceed with a full solution.\n\nThe objective is to assess the transferability of a coarse-grained model across different temperatures. Transferability implies that the model's parameters, derived at a reference temperature, remain valid over a range of temperatures. We quantify this by measuring the change in key structural distributions as a function of temperature. The problem specifies two such distributions: the dihedral angle distribution $p(\\phi)$ and the radial distribution function (RDF) shape $h(r)$. The Jensen-Shannon divergence (JSD) is used as a metric to compare these distributions at various temperatures against a reference temperature.\n\nFirst, we define the necessary physical and mathematical constants and functions. The Boltzmann constant is given as $k_B = 0.00831446261815324 \\, \\text{kJ mol}^{-1} \\text{K}^{-1}$. The temperature dependence of any distribution is governed by the Boltzmann factor $\\exp(-\\beta U(x))$, where $\\beta = 1/(k_B T)$, $T$ is the absolute temperature, and $U(x)$ is the potential energy for a given coordinate $x$.\n\n**1. Dihedral Angle Distribution**\n\nThe effective potential for the torsional angle $\\phi$ is given by\n$$\nU_{\\mathrm{torsion}}(\\phi) = k_{\\phi}\\left(1 - \\cos(n \\phi - \\delta)\\right)\n$$\nwhere $k_{\\phi}$ is the torsional amplitude, $n$ is the periodicity, and $\\delta$ is the phase offset. According to the canonical ensemble, the probability density function for the dihedral angle $\\phi$ at a temperature $T$ is\n$$\np(\\phi; T) = \\frac{1}{Z_{\\phi}(T)} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi)}{k_B T}\\right)\n$$\nwhere $Z_{\\phi}(T)$ is the partition function, which acts as a normalization constant:\n$$\nZ_{\\phi}(T) = \\int_{-\\pi}^{\\pi} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi')}{k_B T}\\right) d\\phi'\n$$\nTo compute the JSD, we require a discrete probability distribution. We discretize the interval $\\phi \\in [-\\pi, \\pi]$ into $N_{\\phi}$ uniform grid points $\\phi_i$. A sufficiently fine grid, for instance with $N_{\\phi} = 10000$ points, ensures numerical stability. The discrete probability $P_{\\phi, i}$ for the $i$-th grid point is\n$$\nP_{\\phi, i}(T) = \\frac{\\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi_i)}{k_B T}\\right)}{\\sum_{j=1}^{N_{\\phi}} \\exp\\left(-\\frac{U_{\\mathrm{torsion}}(\\phi_j)}{k_B T}\\right)}\n$$\nThis forms a normalized discrete distribution $\\{P_{\\phi, i}(T)\\}_{i=1}^{N_{\\phi}}$ for each temperature $T$.\n\n**2. Radial Distribution Shape Function**\n\nThe Lennard-Jones potential describes the nonbonded pair interaction:\n$$\nU_{\\mathrm{LJ}}(r) = 4\\varepsilon\\left[\\left(\\frac{\\sigma}{r}\\right)^{12} - \\left(\\frac{\\sigma}{r}\\right)^6\\right]\n$$\nwhere $\\varepsilon$ is the potential well depth and $\\sigma$ is the characteristic length scale. In the low-density limit, the radial distribution function $g(r)$ is approximated by $g(r) \\approx \\exp(-\\beta U_{\\mathrm{LJ}}(r))$. The problem asks us to define a normalized \"shape function\" $h(r)$ on the interval $[r_{\\min}, r_{\\max}]$, where $r_{\\min} = 0.8\\sigma$ and $r_{\\max} = 3.0\\sigma$. The probability density is\n$$\nh(r; T) = \\frac{1}{Z_{r}(T)} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r)}{k_B T}\\right)\n$$\nwith the normalization constant $Z_{r}(T)$ calculated over the specified range:\n$$\nZ_{r}(T) = \\int_{0.8\\sigma}^{3.0\\sigma} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r')}{k_B T}\\right) dr'\n$$\nSimilar to the dihedral case, we discretize the radial interval into $N_{r}$ uniform grid points $r_i$. Using $N_{r} = 10000$ points ensures accuracy. The discrete probability $P_{r, i}$ for the $i$-th grid point is\n$$\nP_{r, i}(T) = \\frac{\\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r_i)}{k_B T}\\right)}{\\sum_{j=1}^{N_{r}} \\exp\\left(-\\frac{U_{\\mathrm{LJ}}(r_j)}{k_B T}\\right)}\n$$\nThis gives a normalized discrete distribution $\\{P_{r, i}(T)\\}_{i=1}^{N_{r}}$ for each temperature $T$.\n\n**3. Jensen-Shannon Divergence and Transferability Criterion**\n\nThe Jensen-Shannon divergence (JSD) measures the similarity between two probability distributions, $P$ and $Q$. It is defined as\n$$\n\\mathrm{JSD}(P,Q) = \\frac{1}{2}\\mathrm{KL}\\left(P \\parallel M\\right) + \\frac{1}{2}\\mathrm{KL}\\left(Q \\parallel M\\right)\n$$\nwhere $M = \\frac{1}{2}(P+Q)$ is the mixture distribution, and $\\mathrm{KL}(P \\parallel Q)$ is the Kullback-Leibler divergence:\n$$\n\\mathrm{KL}(P\\parallel Q) = \\sum_i P_i \\ln\\left(\\frac{P_i}{Q_i}\\right)\n$$\nFor each test case, the first temperature in the list, $T_1$, serves as the reference temperature $T_{\\mathrm{ref}}$. We compute the JSD between the distribution at $T_{\\mathrm{ref}}$ and the distribution at each other temperature $T_j$ in the list. We find the maximum JSD for both the dihedral and radial distributions:\n$$\nD_{\\phi}^{\\max} = \\max_{j1} \\left\\{ \\mathrm{JSD}\\left(P_{\\phi}(T_j), P_{\\phi}(T_{\\mathrm{ref}})\\right) \\right\\}\n$$\n$$\nD_{r}^{\\max} = \\max_{j1} \\left\\{ \\mathrm{JSD}\\left(P_{r}(T_j), P_{r}(T_{\\mathrm{ref}})\\right) \\right\\}\n$$\nThe model is deemed transferable if both maxima are within their respective thresholds:\n$$\nD_{\\phi}^{\\max} \\le \\tau_{\\phi} \\quad \\text{and} \\quad D_{r}^{\\max} \\le \\tau_{r}\n$$\nwhere the specified thresholds are $\\tau_{\\phi} = 0.05$ and $\\tau_{r} = 0.10$.\n\nThe algorithm for each test case is as follows:\n1.  Unpack the parameters $(n, k_{\\phi}, \\delta)$, $(\\varepsilon, \\sigma)$, and temperatures $[T_1, T_2, \\dots]$. Set $T_{\\mathrm{ref}} = T_1$.\n2.  Generate the discrete grid for $\\phi$ and $r$.\n3.  Calculate the reference distributions $P_{\\phi}(T_{\\mathrm{ref}})$ and $P_{r}(T_{\\mathrm{ref}})$.\n4.  Initialize $D_{\\phi}^{\\max} = 0$ and $D_{r}^{\\max} = 0$.\n5.  For each temperature $T_j$ with $j  1$:\n    a. Calculate the distributions $P_{\\phi}(T_j)$ and $P_{r}(T_j)$.\n    b. Compute $\\mathrm{JSD}_{\\phi, j} = \\mathrm{JSD}(P_{\\phi}(T_j), P_{\\phi}(T_{\\mathrm{ref}}))$ and $\\mathrm{JSD}_{r, j} = \\mathrm{JSD}(P_{r}(T_j), P_{r}(T_{\\mathrm{ref}}))$.\n    c. Update $D_{\\phi}^{\\max} = \\max(D_{\\phi}^{\\max}, \\mathrm{JSD}_{\\phi, j})$ and $D_{r}^{\\max} = \\max(D_{r}^{\\max}, \\mathrm{JSD}_{r, j})$.\n6.  Compare the final $D_{\\phi}^{\\max}$ and $D_{r}^{\\max}$ to $\\tau_{\\phi}$ and $\\tau_{r}$ to determine transferability.\nThis procedure is implemented for the provided test cases.",
            "answer": "```python\nimport numpy as np\nfrom scipy.spatial.distance import jensenshannon\n\ndef solve():\n    \"\"\"\n    Solves the model transferability problem for the given test cases.\n    \"\"\"\n    \n    # Constants and thresholds\n    KB = 0.00831446261815324  # kJ mol^-1 K^-1\n    TAU_PHI = 0.05\n    TAU_R = 0.10\n    N_POINTS = 10000 # Number of points for discretization\n\n    def get_dihedral_distribution(n, k_phi, delta, temp, n_points):\n        \"\"\"\n        Calculates the normalized discrete probability distribution for a dihedral angle.\n        \"\"\"\n        beta = 1.0 / (KB * temp)\n        phi = np.linspace(-np.pi, np.pi, n_points, endpoint=False)\n        u_torsion = k_phi * (1 - np.cos(n * phi - delta))\n        \n        # Using a numerically stable method for normalization\n        log_boltzmann = -beta * u_torsion\n        log_boltzmann -= np.max(log_boltzmann) # Subtract max for stability\n        dist = np.exp(log_boltzmann)\n        dist /= np.sum(dist)\n        return dist\n\n    def get_radial_distribution(epsilon, sigma, temp, n_points):\n        \"\"\"\n        Calculates the normalized discrete probability distribution for a radial shape function.\n        \"\"\"\n        beta = 1.0 / (KB * temp)\n        r_min = 0.8 * sigma\n        r_max = 3.0 * sigma\n        r = np.linspace(r_min, r_max, n_points)\n        \n        # Avoid division by zero if r contains 0, though a linspace from 0.8*sigma won't\n        r_safe = np.where(r == 0, 1e-9, r)\n        \n        term = sigma / r_safe\n        u_lj = 4 * epsilon * (np.power(term, 12) - np.power(term, 6))\n        \n        # Using a numerically stable method for normalization\n        log_boltzmann = -beta * u_lj\n        log_boltzmann -= np.max(log_boltzmann) # Subtract max for stability\n        dist = np.exp(log_boltzmann)\n        dist /= np.sum(dist)\n        return dist\n\n    test_cases = [\n        # Case 1: happy path, modest temperature variation\n        {\n            \"torsion\": (3, 1.0, 0.0), # n, k_phi, delta\n            \"lj\": (0.5, 0.50),        # epsilon, sigma\n            \"temps\": [290.0, 300.0, 310.0]\n        },\n        # Case 2: boundary case, wider temperature span and stronger interactions\n        {\n            \"torsion\": (3, 2.0, np.pi/3),\n            \"lj\": (1.2, 0.50),\n            \"temps\": [280.0, 320.0, 360.0]\n        },\n        # Case 3: edge case, strong interactions and wide temperature span\n        {\n            \"torsion\": (2, 4.0, np.pi/2),\n            \"lj\": (3.0, 0.45),\n            \"temps\": [260.0, 320.0, 380.0]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        torsion_params = case[\"torsion\"]\n        lj_params = case[\"lj\"]\n        temps = case[\"temps\"]\n        \n        t_ref = temps[0]\n        other_temps = temps[1:]\n        \n        # Calculate reference distributions\n        dist_phi_ref = get_dihedral_distribution(*torsion_params, t_ref, N_POINTS)\n        dist_r_ref = get_radial_distribution(*lj_params, t_ref, N_POINTS)\n        \n        max_jsd_phi = 0.0\n        max_jsd_r = 0.0\n        \n        for temp in other_temps:\n            dist_phi_current = get_dihedral_distribution(*torsion_params, temp, N_POINTS)\n            dist_r_current = get_radial_distribution(*lj_params, temp, N_POINTS)\n            \n            # Scipy's jensenshannon calculates the square root of the JSD. We need to square it.\n            # We must use base=np.e for the natural logarithm as specified.\n            js_distance_phi = jensenshannon(dist_phi_ref, dist_phi_current, base=np.e)\n            jsd_phi = js_distance_phi**2\n            max_jsd_phi = max(max_jsd_phi, jsd_phi)\n\n            js_distance_r = jensenshannon(dist_r_ref, dist_r_current, base=np.e)\n            jsd_r = js_distance_r**2\n            max_jsd_r = max(max_jsd_r, jsd_r)\n\n        is_transferable = (max_jsd_phi = TAU_PHI) and (max_jsd_r = TAU_R)\n        results.append(str(is_transferable))\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        }
    ]
}