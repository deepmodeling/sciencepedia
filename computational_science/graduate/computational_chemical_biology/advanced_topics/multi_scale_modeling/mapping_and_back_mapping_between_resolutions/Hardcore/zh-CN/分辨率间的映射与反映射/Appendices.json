{
    "hands_on_practices": [
        {
            "introduction": "计算粗粒化珠子的位置，例如质心，是前向映射的基本步骤。然而，在使用周期性边界条件（PBC）的模拟中，如果分子跨越了模拟盒子的边界，天真地对坐标进行平均会导致灾难性的错误。本练习旨在揭示这种朴素坐标平均法的陷阱，并指导您学习基于分子连接性的稳健“解包”方法，以确保粗粒化模型的完整性。",
            "id": "3852041",
            "problem": "考虑一个分子动力学(MD)中在周期性边界条件(PBC)下的粗粒化映射，该映射应用于其原子可能跨越模拟盒子边界的分子。设三斜周期性晶胞由盒子矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 表示，其列向量等于三个晶格矢量。包裹后的原子坐标在初始晶胞中表示为 $r_i \\in \\mathbb{R}^3$，未包裹坐标表示为 $x_i \\in \\mathbb{R}^3$，它们通过 $x_i = r_i + H n_i$ 相关联，其中 $n_i \\in \\mathbb{Z}^3$ 是整数晶格偏移。一个粗粒化(CG)珠子的位置 $R_b \\in \\mathbb{R}^3$ 定义为其组分原子在未包裹空间中的质量加权质心(COM)：$R_b = \\left(\\sum_{i \\in b} m_i x_i\\right)\\big/\\left(\\sum_{i \\in b} m_i\\right)$，其中 $m_i$ 是原子质量。对于从珠子到原子的反向映射，使用局部内坐标（键长、键角、二面角）和一个以珠子为中心的局部参考系来重构相对于 $R_b$ 的原子位置。\n\n从PBC和COM的核心定义出发，推导使用包裹坐标 $r_i$ 代替未包裹坐标 $x_i$ 如何影响跨边界分子的 $R_b$ 计算，并解释为什么需要一致地选择晶格偏移 $n_i$ 以避免人为的碎裂或错误的珠子放置。使用以分数坐标 $s = H^{-1}(r)$ 表述的最小镜像原理：对于任意成键对 $(j,k)$，最近镜像位移为 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$，其中 $\\mathrm{round}(\\cdot)$ 逐分量作用以产生最近的整数向量。\n\n然后，将您的推导应用于以下正交示例：$H = \\mathrm{diag}(L_x, L_y, L_z)$，$L_x = L_y = L_z = 1\\,\\mathrm{nm}$，一个由单根共价键连接的双原子珠子，其质量相等 $m_1 = m_2 = m$，包裹后的位置为 $r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。计算在PBC下与化学键一致的未包裹位置 $x_1$、$x_2$ 以及在未包裹空间中的珠子质心 $R_b$，并说明其重新包裹回主晶胞后的值。\n\n最后，选择正确提出一个鲁棒的解包裹和反向映射策略的选项，该策略与您的推导一致，并为该示例得出正确的 $R_b$。\n\nA. 沿着分子键，在广度优先遍历中使用最近镜像位移 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$ 进行基于图的解包裹。对于一个参考原子 $j_0$，设置 $x_{j_0} = r_{j_0}$，然后对于每个访问到的键 $(j,k)$，设置 $x_k = x_j + d_{jk}$。在未包裹空间中计算 $R_b = \\left(\\sum_i m_i x_i\\right)\\big/\\left(\\sum_i m_i\\right)$，为了存储，通过映射到分数坐标并减去 $\\mathrm{round}(\\cdot)$ 来重新包裹 $R_b$。对于反向映射，在以未包裹的 $R_b$ 为中心的珠子局部参考系中使用内坐标放置原子，然后将所有位置包裹回主晶胞。对于该示例，$x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$，$R_b = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$，重新包裹后为 $(0.00, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nB. 直接使用主晶胞中的包裹坐标 $r_i$ 计算 $R_b$ 而不进行解包裹，即 $R_b = \\left(\\sum_i m_i r_i\\right)\\big/\\left(\\sum_i m_i\\right)$。对于反向映射，放置原子时确保每个原子沿轴 $\\alpha \\in \\{x,y,z\\}$ 与 $R_b$ 的距离在 $\\pm L_\\alpha/2$ 范围内，以确保与珠子的邻近性。对于该示例，$R_b = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nC. 从包裹坐标 $r_i$ 估计 $R_b$，然后通过对每个轴 $\\alpha$ 强制执行 $|x_{i,\\alpha} - R_{b,\\alpha}| \\le L_\\alpha/2$ 来迭代地解包裹每个原子；重复此过程直到收敛。使用从迭代调整后的 $x_i$ 计算出的最终 $R_b$。对于该示例，此过程得出 $R_b \\approx (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。\n\nD. 通过最小化到原点的平方距离之和 $\\sum_i \\|r_i + H n_i\\|^2$ 来为所有原子选择整数晶格偏移 $n_i \\in \\mathbb{Z}^3$ 以解包裹分子；然后从得到的 $x_i$ 计算 $R_b$。对于反向映射，通过最小化原子包裹后到 $R_b$ 的距离来放置原子。对于该示例，一种可能的选择给出 $x_1 = (-0.02, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$，质心为 $R_b = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$，但这种方法可能会扭曲支链或环状分子中的成键几何结构。",
            "solution": "首先对问题陈述进行严格的验证过程。\n\n**步骤1：提取已知条件**\n- 周期性晶胞表示：三斜盒子矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$，其列向量为晶格矢量。\n- 原子坐标：包裹后的坐标 $r_i \\in \\mathbb{R}^3$，未包裹坐标 $x_i \\in \\mathbb{R}^3$。\n- 坐标关系：$x_i = r_i + H n_i$，其中 $n_i \\in \\mathbb{Z}^3$ 是整数晶格偏移。\n- 粗粒化(CG)珠子位置：$R_b = \\left(\\sum_{i \\in b} m_i x_i\\right)\\big/\\left(\\sum_{i \\in b} m_i\\right)$，使用未包裹坐标 $x_i$ 定义。$m_i$ 是原子质量。\n- 反向映射：从 $R_b$ 使用内坐标和局部参考系重构原子位置。\n- 成键对 $(j,k)$ 的最小镜像位移：$d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$。$\\mathrm{round}(\\cdot)$ 函数逐分量应用。\n- 分数坐标：$s = H^{-1}(r)$。\n- 示例系统规格：\n    - 盒子矩阵：正交，$H = \\mathrm{diag}(L_x, L_y, L_z)$。\n    - 盒子尺寸：$L_x = L_y = L_z = 1\\,\\mathrm{nm}$。\n    - 珠子组成：双原子，原子1和2成键。\n    - 原子质量：$m_1 = m_2 = m$。\n    - 包裹后的位置：$r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题牢固地建立在分子动力学(MD)模拟的标准原理之上，包括周期性边界条件(PBC)、粗粒化、质心计算和最小镜像约定。所提供的方程是该领域的标准定义。\n- **良定性**：问题是良定的。它提供了执行所需推导和计算的所有必要定义和数据。目标明确：推导处理粗粒化中PBC的正确程序，并将其应用于特定示例，然后在选项中确定正确的策略。\n- **客观性**：问题陈述使用精确、技术性的语言表达，没有主观性或歧义。\n\n**缺陷检查清单**：\n1.  **科学/事实不准确**：无。物理和数学是标准且正确的。\n2.  **无法形式化/不相关**：无。该问题是计算化学生物学中一个形式化且相关的挑战。\n3.  **不完整/矛盾的设置**：无。信息是自洽且充分的。\n4.  **不切实际/不可行**：无。参数是原子模拟中的典型值。\n5.  **病态/结构不良**：无。术语定义明确，问题的结构旨在得到一个唯一的正确答案。\n6.  **琐碎/同义反复**：无。该问题解决的是MD模拟分析中一个非平凡且常见的问题，通常称为“包裹团簇的质心”问题，需要仔细推理。\n7.  **超出科学可验证性范围**：无。推导和计算是可验证的。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。开始进行解答推导。\n\n**理论推导与分析**\n\n粗粒化珠子的位置 $R_b$ 被定义为其组分原子在物理上连续的、未包裹的坐标系中的质心(COM)。定义为：\n$$R_b = \\frac{\\sum_{i \\in b} m_i x_i}{\\sum_{i \\in b} m_i}$$\n其中 $x_i$ 是未包裹坐标。使用关系式 $x_i = r_i + H n_i$，我们可以用包裹坐标 $r_i$ 和整数晶格偏移 $n_i$ 来表示 $R_b$：\n$$R_b = \\frac{\\sum_{i \\in b} m_i (r_i + H n_i)}{\\sum_{i \\in b} m_i} = \\frac{\\sum_{i \\in b} m_i r_i}{\\sum_{i \\in b} m_i} + H \\left( \\frac{\\sum_{i \\in b} m_i n_i}{\\sum_{i \\in b} m_i} \\right)$$\n令 $R_b^{\\text{wrapped}} = \\left(\\sum_{i \\in b} m_i r_i\\right) / \\left(\\sum_{i \\in b} m_i\\right)$ 为从包裹坐标朴素计算出的质心。方程变为：\n$$R_b = R_b^{\\text{wrapped}} + H \\cdot \\bar{n}_b$$\n其中 $\\bar{n}_b = \\left(\\sum_{i \\in b} m_i n_i\\right) / \\left(\\sum_{i \\in b} m_i\\right)$ 是整数晶格偏移向量的质量加权平均值。\n\n如果一个分子跨越周期性边界被分割，其组分原子将具有不同的整数偏移向量 $n_i$。例如，对于一个跨越 $x$ 边界的双原子分子，我们可能有 $n_1 = (0,0,0)^T$ 和 $n_2 = (1,0,0)^T$。在这种情况下，$\\bar{n}_b$ 不是一个整数向量，$R_b^{\\text{wrapped}}$ 也不代表任何物理对象的质心。它变成两个远距离点的一个无意义的平均值，导致CG珠子被错误地放置（例如，在盒子的中间，远离实际的分子）。\n\n要计算正确的 $R_b$，必须首先确定一组一致的 $n_i$ 向量，以便在未包裹空间中将分子重构为一个单一的、连续的实体。这相当于使分子“完整”。共价键结构提供了实现这一目标所需的信息。最小镜像位移向量 $d_{jk} = x_k - x_j$ 给出了两个成键原子 $j$ 和 $k$ 之间的真实向量。提供的公式 $d_{jk} = r_k - r_j - H\\,\\mathrm{round}\\!\\left(H^{-1}(r_k - r_j)\\right)$ 是从包裹坐标计算此向量的标准方法。\n\n因此，一个鲁棒的算法是遍历分子图（例如，通过广度优先搜索）。我们可以通过选择一个参考原子 $j_0$ 并将其未包裹位置设置为其包裹位置 $x_{j_0} = r_{j_0}$（有效地选择 $n_{j_0} = (0,0,0)^T$）来锚定分子。然后，对于已访问原子 $j$ 的每个成键邻居 $k$，其未包裹位置确定为 $x_k = x_j + d_{jk}$。这个过程迭代地在未包裹空间中重构整个分子，确保所有键向量都是正确的。一旦找到所有一致的 $x_i$，就可以计算出真实的质心 $R_b$。这个程序确保了内部几何结构和最终的 $R_b$ 是正确的，无论分子相对于镜像盒子边界的位置如何。对于反向映射，原子结构应该围绕这个正确的、未包裹的 $R_b$ 重建，之后才能对整个分子进行任何最终的包裹操作。\n\n**应用于示例**\n\n- 盒子：$H = \\mathrm{diag}(1, 1, 1)\\,\\mathrm{nm}$，所以 $H^{-1} = \\mathrm{diag}(1, 1, 1)\\,\\mathrm{nm}^{-1}$。\n- 质量：$m_1 = m_2 = m$。\n- 包裹后的位置：$r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$r_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n我们遵循鲁棒的解包裹程序：\n1.  选择原子1作为参考。将其未包裹位置设置为其包裹位置：\n    $$x_1 = r_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$$\n    这设置了 $n_1 = (0,0,0)^T$。\n\n2.  计算最小镜像位移向量 $d_{12}$ 以找到原子2相对于原子1的位置。\n    $$r_2 - r_1 = (0.02 - 0.98, 0.50 - 0.50, 0.50 - 0.50)\\,\\mathrm{nm} = (-0.96, 0.00, 0.00)\\,\\mathrm{nm}$$\n    在分数坐标中，这个位移是 $H^{-1}(r_2 - r_1) = (-0.96, 0.00, 0.00)$。\n    最近的整数向量是 $\\mathrm{round}(H^{-1}(r_2 - r_1)) = (\\mathrm{round}(-0.96), \\mathrm{round}(0.00), \\mathrm{round}(0.00)) = (-1, 0, 0)^T$。\n    最小镜像位移是：\n    $$d_{12} = (r_2 - r_1) - H \\cdot (-1, 0, 0)^T = (-0.96, 0.00, 0.00)\\,\\mathrm{nm} - (-1, 0, 0)\\,\\mathrm{nm} = (0.04, 0.00, 0.00)\\,\\mathrm{nm}$$\n\n3.  计算原子2的未包裹位置：\n    $$x_2 = x_1 + d_{12} = (0.98, 0.50, 0.50)\\,\\mathrm{nm} + (0.04, 0.00, 0.00)\\,\\mathrm{nm} = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$$\n    一致的未包裹坐标是 $x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$。\n\n4.  从未包裹坐标计算珠子质心 $R_b$。由于质量相等，它是几何平均值：\n    $$R_b = \\frac{x_1 + x_2}{2} = \\frac{(0.98, 0.50, 0.50) + (1.02, 0.50, 0.50)}{2}\\,\\mathrm{nm} = \\frac{(2.00, 1.00, 1.00)}{2}\\,\\mathrm{nm} = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$$\n\n5.  将 $R_b$ 重新包裹到主晶胞 $[0, 1) \\times [0, 1) \\times [0, 1)\\,\\mathrm{nm}$ 中。我们映射到分数坐标 $s_b = H^{-1}R_b = (1.00, 0.50, 0.50)$，找到整数镜像向量 $n = \\mathrm{floor}(s_b) = (1, 0, 0)^T$，并减去晶格向量：\n    $$R_{b, \\text{wrapped}} = R_b - Hn = (1.00, 0.50, 0.50)\\,\\mathrm{nm} - (1, 0, 0)\\,\\mathrm{nm} = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$$\n\n**逐项分析选项**\n\n**A. 进行基于图的解包裹...**\n此选项描述了上面推导的完全鲁棒的程序：基于连通性使用最小镜像位移解包裹分子，在这个未包裹空间中计算质心，然后处理相对于未包裹质心的反向映射。选项中提供的计算结果，$x_1 = (0.98, 0.50, 0.50)\\,\\mathrm{nm}$，$x_2 = (1.02, 0.50, 0.50)\\,\\mathrm{nm}$，$R_b = (1.00, 0.50, 0.50)\\,\\mathrm{nm}$，以及重新包裹后的 $R_b = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$，与我们的推导完全匹配。\n**结论：正确。**\n\n**B. 直接从包裹坐标计算 $R_b$...**\n这提出了朴素的、有缺陷的方法。计算结果是 $R_b = (r_1+r_2)/2 = ((0.98, 0.5, 0.5) + (0.02, 0.5, 0.5))/2\\,\\mathrm{nm} = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$。如推导所述，此方法在盒子中心产生一个物理上无意义的质心，远离聚集在 $x=0/x=1$ 边界附近的成键原子。该方法对于跨越周期性边界的分子是根本错误的。\n**结论：错误。**\n\n**C. 从包裹坐标估计 $R_b$，然后迭代地解包裹每个原子...**\n这描述了一种迭代聚类算法。它从选项B中不正确的朴素质心 $R_{b, \\text{init}} = (0.50, 0.50, 0.50)\\,\\mathrm{nm}$ 开始。然后检查是否应该解包裹任何原子以使其更接近此质心。对于原子1，$|x_{1,x} - R_{b,x}| = |0.98 - 0.50| = 0.48$，小于 $L_x/2 = 0.5$。对于原子2，$|x_{2,x} - R_{b,x}| = |0.02 - 0.50| = 0.48$，也小于 $L_x/2$。由于没有原子被移动，程序立即收敛到错误的结果 $R_b=(0.50, 0.50, 0.50)\\,\\mathrm{nm}$。该方法失败是因为它没有利用关于分子连通性的关键信息。\n**结论：错误。**\n\n**D. 通过最小化到原点的平方距离之和...选择整数晶格偏移 $n_i$...**\n该策略独立地解包裹每个原子，使其尽可能靠近原点，而忽略了分子连通性。对于 $r_1 = (0.98, \\dots)$，最接近原点的未包裹位置是 $x_1 = (-0.02, \\dots)$。对于 $r_2 = (0.02, \\dots)$，最接近原点的未包裹位置是 $x_2 = (0.02, \\dots)$。这得出 $x_1 = (-0.02, 0.50, 0.50)\\,\\mathrm{nm}$ 和 $x_2 = (0.02, 0.50, 0.50)\\,\\mathrm{nm}$。得到的质心是 $R_b = (x_1+x_2)/2 = (0.00, 0.50, 0.50)\\,\\mathrm{nm}$。虽然在这个简单、对称的示例中，这在数值上与正确的包裹后质心相匹配，但其基本原理是有缺陷的。正如选项本身指出的，这种方法可能会扭曲更复杂分子的几何结构（例如，通过打断一个跨越原点的长分子），因为它不强制分子的连续性。一个鲁棒的方法必须基于保持内部分子结构，而不是将分子移动到像原点这样的任意位置。\n**结论：错误。**",
            "answer": "$$\\boxed{A}$$"
        },
        {
            "introduction": "一旦我们有了目标粗粒化结构，我们如何重建一个化学上合理的全原子模型？这是反向映射的精髓。本练习将此任务构建为一个优化问题，即最小化一个惩罚函数，该函数平衡了对粗粒化目标的保真度和对局部原子几何（键、角等）的遵守。通过推导此函数的梯度和Hessian矩阵，您将理解基于物理的反向映射算法的数学基础，以及约束条件在确保化学合理性中的关键作用。",
            "id": "3852006",
            "problem": "计算化学生物学中的一种从粗粒度到原子级的反向映射，旨在寻找原子坐标 $x \\in \\mathbb{R}^{3N}$，使其映射的粗粒度可观测量与目标 $y \\in \\mathbb{R}^{m}$ 相匹配，其中 $m$ 是粗粒度维度（例如，珠子位置或其他低维描述符）。设 $M:\\mathbb{R}^{3N} \\to \\mathbb{R}^{m}$ 表示一个从原子坐标到粗粒度可观测量的可微映射。考虑罚函数\n$$\n\\Phi(x) \\;=\\; \\| y - M(x) \\|^{2} \\;+\\; \\lambda \\, C(x),\n$$\n其中 $C:\\mathbb{R}^{3N} \\to \\mathbb{R}$ 是一个可微的约束泛函，它惩罚偏离化学意义上合理结构的构型（例如，键长、键角或二面角与参考值的平方偏差之和），而 $\\lambda  0$ 是一个标量正则化权重。定义残差向量 $r(x) = y - M(x)$，雅可比矩阵 $J_{M}(x) = \\frac{\\partial M(x)}{\\partial x} \\in \\mathbb{R}^{m \\times 3N}$，并且对于每个分量 $M_{i}(x)$，令 $\\nabla M_{i}(x) \\in \\mathbb{R}^{3N}$ 和 $\\nabla^{2} M_{i}(x) \\in \\mathbb{R}^{3N \\times 3N}$ 为其梯度和海森矩阵。假设 $C(x)$ 是二阶连续可微的，其梯度为 $\\nabla C(x)$，海森矩阵为 $\\nabla^{2} C(x)$。\n\n仅使用基本的多变量微积分（向量值函数的链式法则和乘積法则）和标准的线性代数定义（雅可比矩阵、梯度和海森矩阵），推导梯度 $\\nabla \\Phi(x)$ 和海森矩阵 $\\nabla^{2} \\Phi(x)$ 关于 $r(x)$、$J_{M}(x)$、$\\nabla^{2} M_{i}(x)$、$\\nabla C(x)$ 和 $\\nabla^{2} C(x)$ 的表达式。然后，定义高斯-牛顿近似海森矩阵为 $H_{\\mathrm{GN}}(x) = 2 J_{M}(x)^{\\top} J_{M}(x) + \\lambda \\nabla^{2} C(x)$（通过忽略数据拟合部分中 $M$ 的二阶导数项得到），并分析应用牛顿法或高斯-牛顿法步骤最小化 $\\Phi(x)$ 时的数值稳定性条件。\n\n特别地，假设存在 $\\mu  0$ 使得 $\\nabla^{2} C(x) \\succeq \\mu I$（即，在勒夫纳偏序下，约束的海森矩阵有下界 $\\mu I$），并令 $\\sigma_{\\min}(x)$ 表示 $J_{M}(x)$ 的最小奇异值。对于一个给定的曲率下限 $\\alpha  0$，为确保 $H_{\\mathrm{GN}}(x)$ 的最小特征值至少为 $\\alpha$，确定能保证 $H_{\\mathrm{GN}}(x) \\succeq \\alpha I$ 的最小 $\\lambda$。\n\n你的最终答案必须是一个单一的复合解析表达式，包含如上推导出的梯度、海森矩阵和最小 $\\lambda$，并写成行矩阵的形式。不需要进行数值计算。",
            "solution": "该问题要求推导罚函数 $\\Phi(x)$ 的梯度和海森矩阵，并分析基于海森矩阵的高斯-牛顿近似的优化步骤的数值稳定性条件。罚函数由下式给出：\n$$\n\\Phi(x) = \\| y - M(x) \\|^{2} + \\lambda \\, C(x)\n$$\n其中 $x \\in \\mathbb{R}^{3N}$ 是原子坐标，$y \\in \\mathbb{R}^{m}$ 是目标粗粒度可观测量，$M: \\mathbb{R}^{3N} \\to \\mathbb{R}^{m}$ 是一个可微映射，$C(x)$ 是一个可微约束泛函，$\\lambda  0$ 是一个标量权重。我们定义残差向量 $r(x) = y - M(x)$。函数 $\\Phi(x)$可以写成：\n$$\n\\Phi(x) = r(x)^{\\top}r(x) + \\lambda \\, C(x)\n$$\n\n首先，我们推导 $\\Phi(x)$ 的梯度，记为 $\\nabla \\Phi(x) \\in \\mathbb{R}^{3N}$。梯度是偏导数向量，$[\\nabla \\Phi(x)]_k = \\frac{\\partial \\Phi}{\\partial x_k}$。我们应用微分的加法法则：\n$$\n\\nabla \\Phi(x) = \\nabla(r(x)^{\\top}r(x)) + \\nabla(\\lambda C(x))\n$$\n第二项的梯度很简单：\n$$\n\\nabla(\\lambda C(x)) = \\lambda \\nabla C(x)\n$$\n对于第一项，我们使用向量值函数的链式法则。设 $f(u) = u^{\\top}u$。$f$ 的梯度是 $\\nabla f(u) = 2u$。在这里，$u = r(x)$。$r(x) = y - M(x)$ 关于 $x$ 的雅可比矩阵是 $J_r(x) = \\frac{\\partial r(x)}{\\partial x} = -\\frac{\\partial M(x)}{\\partial x} = -J_M(x)$。链式法则表明 $\\nabla(f(r(x))) = J_r(x)^{\\top} (\\nabla f)(r(x))$。应用此法则，我们得到：\n$$\n\\nabla(r(x)^{\\top}r(x)) = (-J_M(x))^{\\top} (2r(x)) = -2 J_M(x)^{\\top} r(x)\n$$\n结合这两个部分，$\\Phi(x)$ 的梯度是：\n$$\n\\nabla \\Phi(x) = -2 J_M(x)^{\\top} r(x) + \\lambda \\nabla C(x)\n$$\n\n其次，我们推导 $\\Phi(x)$ 的海森矩阵，记为 $\\nabla^2 \\Phi(x) \\in \\mathbb{R}^{3N \\times 3N}$。海森矩阵是二阶偏导数矩阵，$[\\nabla^2 \\Phi(x)]_{jk} = \\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k}$。我们对梯度分量的表达式进行微分。梯度的第 $k$ 个分量是：\n$$\n[\\nabla \\Phi(x)]_k = -2 \\sum_{i=1}^{m} [J_M(x)^{\\top}]_{ki} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k} = -2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_k} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k}\n$$\n现在，我们对第一项使用乘积法则，关于 $x_j$ 进行微分：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k} = \\frac{\\partial}{\\partial x_j} \\left( -2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_k} r_i(x) + \\lambda \\frac{\\partial C}{\\partial x_k} \\right)\n$$\n$$\n= -2 \\sum_{i=1}^{m} \\left( \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} r_i(x) + \\frac{\\partial M_i}{\\partial x_k} \\frac{\\partial r_i}{\\partial x_j} \\right) + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n因为 $r_i(x) = y_i - M_i(x)$，我们有 $\\frac{\\partial r_i}{\\partial x_j} = -\\frac{\\partial M_i}{\\partial x_j}$。将此代入表达式中：\n$$\n\\frac{\\partial^2 \\Phi}{\\partial x_j \\partial x_k} = -2 \\sum_{i=1}^{m} \\left( \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} r_i(x) - \\frac{\\partial M_i}{\\partial x_k} \\frac{\\partial M_i}{\\partial x_j} \\right) + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n$$\n= 2 \\sum_{i=1}^{m} \\frac{\\partial M_i}{\\partial x_j} \\frac{\\partial M_i}{\\partial x_k} - 2 \\sum_{i=1}^{m} r_i(x) \\frac{\\partial^2 M_i}{\\partial x_j \\partial x_k} + \\lambda \\frac{\\partial^2 C}{\\partial x_j \\partial x_k}\n$$\n我们识别出这些项是矩阵的元素。第一项是 $2 J_M(x)^{\\top} J_M(x)$ 的第 $(j,k)$ 个元素。第二项是 $-2 \\sum_{i=1}^{m} r_i(x) \\nabla^2 M_i(x)$ 的第 $(j,k)$ 个元素，其中 $\\nabla^2 M_i(x)$ 是 $M(x)$ 的第 $i$ 个分量的海森矩阵。第三项是 $\\lambda \\nabla^2 C(x)$ 的第 $(j,k)$ 个元素。\n将这些组合成矩阵形式，得到完整的海森矩阵：\n$$\n\\nabla^2 \\Phi(x) = 2 J_M(x)^{\\top} J_M(x) - 2 \\sum_{i=1}^{m} r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x)\n$$\n\n第三，我们分析高斯-牛顿优化步骤的稳定性条件。高斯-牛顿近似海森矩阵 $H_{\\mathrm{GN}}(x)$ 是通过忽略涉及 $M_i(x)$ 的二阶导数项（即含 $\\sum r_i \\nabla^2 M_i$ 的项）而形成的，当残差 $r_i(x)$ 很小或 $M(x)$ 近似线性时，这种做法是合理的。问题定义为：\n$$\nH_{\\mathrm{GN}}(x) = 2 J_{M}(x)^{\\top} J_{M}(x) + \\lambda \\nabla^{2} C(x)\n$$\n为了获得稳定的下降步， $H_{\\mathrm{GN}}(x)$ 必须是正定的。问题要求一个更强的条件：找到最小的 $\\lambda  0$，使得 $H_{\\mathrm{GN}}(x)$ 的最小特征值至少为 $\\alpha  0$，即 $H_{\\mathrm{GN}}(x) \\succeq \\alpha I$。这能确保矩阵是良态的，并且搜索方向是一个强下降方向。\n\n令 $\\lambda_{\\min}(A)$ 表示对称矩阵 $A$ 的最小特征值。我们想要找到最小的 $\\lambda  0$，使得 $\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\alpha$。\n使用关于对称矩阵和的特征值的韦尔不等式 $\\lambda_{\\min}(A+B) \\ge \\lambda_{\\min}(A) + \\lambda_{\\min}(B)$，我们可以为 $H_{\\mathrm{GN}}(x)$ 的最小特征值建立一个下界：\n$$\n\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\lambda_{\\min}(2 J_{M}(x)^{\\top} J_{M}(x)) + \\lambda_{\\min}(\\lambda \\nabla^{2} C(x))\n$$\n我们分析右侧的每一项。$J_{M}(x)^{\\top} J_{M}(x)$ 的特征值是 $J_{M}(x)$ 的奇异值的平方。因此，其最小特征值是 $\\sigma_{\\min}(x)^2$，其中 $\\sigma_{\\min}(x)$ 是 $J_{M}(x)$ 的最小奇异值。\n$$\n\\lambda_{\\min}(2 J_{M}(x)^{\\top} J_{M}(x)) = 2 \\sigma_{\\min}(x)^2\n$$\n对于第二项，给定存在某个 $\\mu  0$ 使得 $\\nabla^{2} C(x) \\succeq \\mu I$。这意味着 $\\lambda_{\\min}(\\nabla^{2} C(x)) \\ge \\mu$。因为 $\\lambda  0$：\n$$\n\\lambda_{\\min}(\\lambda \\nabla^{2} C(x)) = \\lambda \\, \\lambda_{\\min}(\\nabla^{2} C(x)) \\ge \\lambda \\mu\n$$\n结合这些界限，我们得到满足我们要求的充分条件：\n$$\n\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge 2 \\sigma_{\\min}(x)^2 + \\lambda \\mu\n$$\n为保证 $\\lambda_{\\min}(H_{\\mathrm{GN}}(x)) \\ge \\alpha$，只需这个下界至少为 $\\alpha$：\n$$\n2 \\sigma_{\\min}(x)^2 + \\lambda \\mu \\ge \\alpha\n$$\n解出 $\\lambda$：\n$$\n\\lambda \\mu \\ge \\alpha - 2 \\sigma_{\\min}(x)^2 \\quad \\implies \\quad \\lambda \\ge \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}\n$$\n这个不等式为 $\\lambda$ 提供了一个值，对于任何满足前提的矩阵，该值足以保证所需的曲率。它代表了最坏情况下的要求（即两个矩阵的最小特征值对应的特征向量对齐）。\n问题还指定了 $\\lambda  0$。如果右侧的 $\\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}$ 是非正的，那么任何 $\\lambda  0$ 都满足推导出的不等式。为了给 $\\lambda$ 的最小值（或者更精确地，有效 $\\lambda$ 集合的下确界）提供一个单一表达式，我们必须取 $0$ 和推导出的下界中的最大值。因此，$\\lambda$ 的下确界是：\n$$\n\\max\\left(0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu}\\right)\n$$\n\n最终答案要求将三个推导出的表达式放在一个单一的行矩阵中。\n1.  梯度： $\\nabla \\Phi(x) = -2J_M(x)^\\top r(x) + \\lambda \\nabla C(x)$\n2.  海森矩阵： $\\nabla^2 \\Phi(x) = 2 J_M(x)^\\top J_M(x) - 2 \\sum_{i=1}^m r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x)$\n3.  最小的 $\\lambda$ (下确界)： $\\max \\left( 0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu} \\right)$",
            "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n-2J_M(x)^\\top r(x) + \\lambda \\nabla C(x)  2 J_M(x)^\\top J_M(x) - 2 \\sum_{i=1}^m r_i(x) \\nabla^2 M_i(x) + \\lambda \\nabla^2 C(x)  \\max \\left( 0, \\frac{\\alpha - 2 \\sigma_{\\min}(x)^2}{\\mu} \\right)\n\\end{pmatrix}\n}\n$$"
        },
        {
            "introduction": "一个单一的粗粒化表示可以对应于大量不同的全原子构象，理解这种多样性是多尺度建模的关键。本动手编程练习通过构建映射算符的零空间来探索这一概念。零空间中的扰动代表了粗粒化模型“不可见”的内部原子运动，这使我们能够从单个起点生成各种有效且物理上一致的反向映射结构。",
            "id": "3852043",
            "problem": "给定一个三肽的粗粒化珠子映射，该映射通过一个线性算子将全原子笛卡尔坐标映射到珠子坐标。令 $N$ 表示原子数，$B$ 表示珠子数。全原子坐标向量为 $x \\in \\mathbb{R}^{3N}$，珠子坐标向量为 $y \\in \\mathbb{R}^{3B}$。该映射是线性的，$y = M x$，其中 $M \\in \\mathbb{R}^{3B \\times 3N}$ 是由每个珠子的原子坐标的凸组合在三个笛卡尔分量上复制而构建的。具体来说，珠子 $b$ 由一组原子索引 $S_b \\subset \\{0,1,\\dots,N-1\\}$ 和非负权重 $\\{w_i\\}_{i \\in S_b}$ 定义，其中 $\\sum_{i \\in S_b} w_i  0$。映射矩阵 $M$ 的定义如下：对于每个珠子 $b \\in \\{0,1,\\dots,B-1\\}$ 和每个原子 $i \\in S_b$，其块为\n$$\nM[3b:3b+3,\\,3i:3i+3] \\;=\\; \\left(\\frac{w_i}{\\sum_{j \\in S_b} w_j}\\right) I_3 \\,,\n$$\n其中 $I_3$ 表示 $3 \\times 3$ 单位矩阵，其他位置为零。这使得珠子坐标成为指定原子位置的质量加权或权重加权平均值。一个反向映射扰动 $\\delta x \\in \\mathbb{R}^{3N}$ 能保持粗粒化坐标 $y$ 不变，当且仅当 $M \\,\\delta x = 0$，即 $\\delta x$ 位于 $M$ 的零空间中。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 根据给定的珠子定义构建 $M$。\n- 计算 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 通过采样系数 $\\alpha$ 并形成 $\\delta x = N_{\\mathrm{basis}} \\,\\alpha$ 来生成随机的反向映射扰动，其中 $N_{\\mathrm{basis}}$ 的列构成了 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 通过报告每个测试用例在一组固定的随机扰动下的最大欧几里得范数 $\\lVert M \\,\\delta x \\rVert_2$，来数值上验证这些扰动是否保持 $y$ 不变。\n\n推导的基本依据：\n- 在计算化学生物学中，粗粒化映射通常被建模为一个线性算子，它通过基于物理质量或其他粗粒化权重的加权平均，将全原子坐标映射到珠子坐标。这由 $y=Mx$ 捕获，其中 $M$ 的构建如上所述。\n- 所有保持 $y$ 不变的全原子扰动的集合恰好是 $M$ 的零空间，即 $\\{\\delta x \\in \\mathbb{R}^{3N} \\mid M \\,\\delta x = 0\\}$。\n- 零空间的一个标准正交基为所有此类扰动提供了一个方便的参数化方法，通过 $\\mathbb{R}^k$ 中的系数实现，其中 $k = \\dim \\mathrm{Null}(M)$。\n\n用于标准化输出的数值协议：\n- 对系数使用固定的高斯采样：对于每个测试用例，抽取 $K$ 个独立样本 $\\alpha^{(j)} \\sim \\mathcal{N}(0, \\sigma^2 I_k)$，其中 $K = 10$ 且 $\\sigma = 0.05$，并构建 $\\delta x^{(j)} = N_{\\mathrm{basis}} \\,\\alpha^{(j)}$。\n- 对于每个测试用例，报告单个标量值\n$$\n\\max_{1 \\le j \\le K} \\; \\lVert M \\,\\delta x^{(j)} \\rVert_2 \\,.\n$$\n- 使用固定的随机种子 $s = 42$ 以确保结果可复现。\n- 不需要物理单位；所有量均被视为无量纲。\n\n测试套件：\n- 所有测试用例都考虑一个包含 $B=3$ 个珠子和 $N=12$ 个原子（索引为 $0,1,\\dots,11$）的三肽。每个案例都指定了珠子索引集 $(S_0,S_1,S_2)$ 和相应的未归一化权重。\n\n$1.$ 案例 A（均匀权重，等大小分组）：\n$$\nS_0 = \\{0,1,2,3\\}, \\quad S_1 = \\{4,5,6,7\\}, \\quad S_2 = \\{8,9,10,11\\}.\n$$\n权重：\n$$\nw^{(0)} = [1,1,1,1], \\quad w^{(1)} = [1,1,1,1], \\quad w^{(2)} = [1,1,1,1].\n$$\n\n$2.$ 案例 B（质量加权，等大小分组）。重原子的大致原子质量：\n$$\nw^{(b)} = [14.007,\\,12.011,\\,12.011,\\,15.999] \\quad \\text{for each} \\quad b \\in \\{0,1,2\\},\n$$\n索引集与案例 A 相同。\n\n$3.$ 案例 C（均匀权重，不等大小分组）：\n$$\nS_0 = \\{0,1,2,3,4\\}, \\quad S_1 = \\{5,6,7,8\\}, \\quad S_2 = \\{9,10,11\\},\n$$\n且\n$$\nw^{(0)} = [1,1,1,1,1], \\quad w^{(1)} = [1,1,1,1], \\quad w^{(2)} = [1,1,1].\n$$\n\n$4.$ 案例 D（均匀权重，边界为单原子珠子）：\n$$\nS_0 = \\{0\\}, \\quad S_1 = \\{1,2,3,4,5\\}, \\quad S_2 = \\{6,7,8,9,10,11\\},\n$$\n且\n$$\nw^{(0)} = [1], \\quad w^{(1)} = [1,1,1,1,1], \\quad w^{(2)} = [1,1,1,1,1,1].\n$$\n\n程序要求：\n- 使用上述块-单位矩阵方案，根据提供的 $(S_b, w^{(b)})$ 定义实现 $M$ 的构建。\n- 计算 $\\mathrm{Null}(M)$ 的一个标准正交基。\n- 对每个测试用例，采样 $K = 10$ 个方差为 $\\sigma^2$ 的独立高斯系数向量，并形成 $\\delta x^{(j)}$。计算欧几里得范数 $\\lVert M \\,\\delta x^{(j)} \\rVert_2$，并将 $K$ 个样本中的最大值作为该测试用例的报告值。\n- 使用指定的随机种子 $s = 42$ 以保证可复现性。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按四个测试用例的顺序排列结果，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个浮点数。\n\n注意：不涉及角度，也不需要物理单位。唯一的输出是如上定义的实值浮点数，每个测试用例一个。",
            "solution": "该问题要求我们验证一个粗粒化分子模型的反向映射程序。其核心原理是，任何不改变粗粒化表示 $y$ 的原子扰动 $\\delta x$ 都必须属于线性映射算子 $M$ 的零空间，该算子由关系 $y=Mx$ 定义。我们必须通过构建此类扰动并测量它们经 $M$ 投影后的范数来验证这一点，由于数值精度的限制，该范数应接近于零。该过程包括四个主要步骤：构建矩阵 $M$，计算其零空间的基，从该基生成随机扰动，以及量化数值误差。\n\n首先，我们构建粗粒化矩阵 $M \\in \\mathbb{R}^{3B \\times 3N}$。这里，$N=12$ 是原子数，$B=3$ 是粗粒化珠子数。矩阵 $M$ 将全原子坐标向量 $x \\in \\mathbb{R}^{3N}$ 映射到珠子坐标向量 $y \\in \\mathbb{R}^{3B}$。对于每个珠子 $b \\in \\{0, 1, \\dots, B-1\\}$，其位置是集合 $S_b \\subset \\{0, 1, \\dots, N-1\\}$ 中原子位置的加权平均。权重由 $\\{w_i\\}_{i \\in S_b}$ 给出。该映射被构造为一系列 $3 \\times 3$ 的块。具体来说，对于每个原子 $i \\in S_b$，$M$ 中将原子 $i$ 的坐标映射到珠子 $b$ 的块由以下公式给出：\n$$\nM[3b:3b+3, 3i:3i+3] = c_i I_3\n$$\n其中 $I_3$ 是 $3 \\times 3$ 单位矩阵，$c_i$ 是归一化权重：\n$$\nc_i = \\frac{w_i}{\\sum_{j \\in S_b} w_j}\n$$\n$M$ 的所有其他块都是零矩阵。此构建通过初始化一个 $3B \\times 3N$（即 $9 \\times 36$）的零矩阵，并为测试用例中提供的每个珠子定义填充指定的块来实现。\n\n其次，我们确定保持粗粒化坐标不变的扰动 $\\delta x$ 的空间。如果一个扰动 $\\delta x$ 不改变珠子坐标，即 $y$ 的变化为零：$\\delta y = M \\delta x = 0$，则该扰动被认为是有效的反向映射。所有此类向量 $\\delta x$ 的集合构成了矩阵 $M$ 的零空间，记为 $\\mathrm{Null}(M)$。该空间的维度 $k$ 由秩-零化度定理给出：$k = \\dim(\\mathrm{Null}(M)) = 3N - \\mathrm{rank}(M)$。对于所提供的测试用例，珠子的原子集 $S_b$ 是不相交的，这确保了 $M$ 中对应于不同珠子的行是线性无关的。因此，$M$ 的秩是 $3B = 9$。因此，零空间的维度是 $k = 3 \\times 12 - 9 = 27$。我们使用标准的数值线性代数程序计算这个 27 维零空间的一个标准正交基。具体来说，我们使用奇异值分解 (SVD)，如 `scipy.linalg.null_space` 函数中所实现的，它返回一个矩阵 $N_{\\mathrm{basis}} \\in \\mathbb{R}^{3N \\times k}$，其列构成了 $\\mathrm{Null}(M)$ 的标准正交基向量 $\\{v_1, v_2, \\dots, v_k\\}$。\n\n第三，我们生成位于该零空间内的随机扰动。$\\mathrm{Null}(M)$ 中的任何向量都可以表示为其基向量的线性组合。一个随机扰动 $\\delta x$ 被构造为：\n$$\n\\delta x = \\sum_{j=1}^{k} \\alpha_j v_j = N_{\\mathrm{basis}} \\alpha\n$$\n其中 $\\alpha = [\\alpha_1, \\alpha_2, \\dots, \\alpha_k]^T$ 是一个系数向量。根据问题规范，这些系数从均值为 $0$、方差为 $\\sigma^2$ 的高斯分布中独立采样，即 $\\alpha_j \\sim \\mathcal{N}(0, \\sigma^2)$。标准差被指定为 $\\sigma = 0.05$。对于每个测试用例，我们生成 $K=10$ 个这样的随机系数向量 $\\alpha^{(j)}$ 并构建相应的扰动 $\\delta x^{(j)}$。固定的随机种子 $s=42$ 确保了这些样本的可复现性。\n\n第四，我们进行数值验证。在精确算术中，由于 $N_{\\mathrm{basis}}$ 的每一列都在 $\\mathrm{Null}(M)$ 中，因此 $M N_{\\mathrm{basis}} = \\boldsymbol{0}$ 成立，其中 $\\boldsymbol{0}$ 是一个零矩阵。因此，$M \\delta x = M (N_{\\mathrm{basis}} \\alpha) = (M N_{\\mathrm{basis}}) \\alpha = \\boldsymbol{0} \\alpha = 0$。然而，由于在计算零空间和后续矩阵乘法时存在有限浮点精度，我们预计计算结果 $M \\delta x$ 将是一个具有非常小但非零分量的向量。我们通过为 $K=10$ 个生成的扰动中的每一个计算欧几里得范数 $\\lVert M \\delta x^{(j)} \\rVert_2$ 来量化这个数值误差。每个测试用例的最终报告值是这些范数的最大值，即 $\\max_{1 \\le j \\le K} \\lVert M \\delta x^{(j)} \\rVert_2$。这个值可作为衡量整个过程数值稳定性和正确性的指标。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import null_space\n\ndef solve():\n    \"\"\"\n    Constructs a coarse-graining matrix M, finds its null space, generates\n    random perturbations within this space, and verifies that they preserve\n    the coarse-grained representation by checking if M * delta_x is close to zero.\n    \"\"\"\n\n    # Define constants from the problem statement.\n    N_ATOMS = 12\n    N_BEADS = 3\n    K_SAMPLES = 10\n    SIGMA = 0.05\n    RANDOM_SEED = 42\n\n    # Define the test cases.\n    # Each case is a tuple: (name, bead_definitions)\n    # bead_definitions is a list of tuples: (atom_indices, weights)\n    test_cases = [\n        # 1. Case A (uniform weights, equal group sizes)\n        (\n            [\n                (list(range(0, 4)), [1.0] * 4),\n                (list(range(4, 8)), [1.0] * 4),\n                (list(range(8, 12)), [1.0] * 4)\n            ]\n        ),\n        # 2. Case B (mass-weighted, equal group sizes)\n        (\n            [\n                (list(range(0, 4)), [14.007, 12.011, 12.011, 15.999]),\n                (list(range(4, 8)), [14.007, 12.011, 12.011, 15.999]),\n                (list(range(8, 12)), [14.007, 12.011, 12.011, 15.999])\n            ]\n        ),\n        # 3. Case C (uniform weights, unequal group sizes)\n        (\n            [\n                (list(range(0, 5)), [1.0] * 5),\n                (list(range(5, 9)), [1.0] * 4),\n                (list(range(9, 12)), [1.0] * 3)\n            ]\n        ),\n        # 4. Case D (uniform weights, boundary with a single-atom bead)\n        (\n            [\n                ([0], [1.0]),\n                (list(range(1, 6)), [1.0] * 5),\n                (list(range(6, 12)), [1.0] * 6)\n            ]\n        )\n    ]\n\n    results = []\n    \n    # Set the random seed for reproducibility across all test cases.\n    np.random.seed(RANDOM_SEED)\n\n    for bead_defs in test_cases:\n        # 1. Construct the mapping matrix M\n        dim_M_rows = 3 * N_BEADS\n        dim_M_cols = 3 * N_ATOMS\n        M = np.zeros((dim_M_rows, dim_M_cols))\n        \n        for b, (atom_indices, weights) in enumerate(bead_defs):\n            sum_weights = sum(weights)\n            if sum_weights == 0:\n                # This case is disallowed by the problem statement.\n                # It would lead to division by zero.\n                raise ValueError(\"Sum of weights for a bead cannot be zero or negative.\")\n\n            for local_idx, atom_idx in enumerate(atom_indices):\n                weight = weights[local_idx]\n                normalized_weight = weight / sum_weights\n                \n                # The block M[3b:3b+3, 3i:3i+3] is a scaled identity matrix.\n                row_start = 3 * b\n                col_start = 3 * atom_idx\n                M[row_start:row_start+3, col_start:col_start+3] = normalized_weight * np.identity(3)\n\n        # 2. Compute an orthonormal basis for the null space of M.\n        # The columns of N_basis form the basis vectors.\n        N_basis = null_space(M)\n        \n        # Dimension of the null space, k.\n        k = N_basis.shape[1]\n        \n        max_norm = 0.0\n\n        for _ in range(K_SAMPLES):\n            # 3. Generate random coefficients alpha.\n            # np.random.normal's 'scale' parameter is the standard deviation sigma.\n            alpha = np.random.normal(loc=0.0, scale=SIGMA, size=k)\n            \n            # Construct the perturbation delta_x in the null space.\n            delta_x = N_basis @ alpha\n            \n            # 4. Verify by projecting delta_x back with M and computing the norm.\n            # In theory, M @ delta_x should be a zero vector.\n            y_pert = M @ delta_x\n            \n            # Compute the Euclidean norm of the resulting vector.\n            # This norm quantifies the numerical error.\n            norm = np.linalg.norm(y_pert, ord=2)\n            \n            # Keep track of the maximum norm found over K samples.\n            if norm > max_norm:\n                max_norm = norm\n                \n        results.append(max_norm)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n\n```"
        }
    ]
}