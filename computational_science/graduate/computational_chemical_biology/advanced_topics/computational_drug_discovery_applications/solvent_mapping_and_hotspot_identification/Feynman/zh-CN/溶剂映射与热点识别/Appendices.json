{
    "hands_on_practices": [
        {
            "introduction": "热点识别的核心在于理解配体取代结合位点中水分子的热力学效应。一个水分子的置换是否对结合有利，取决于该水分子在位点中相对于在本体溶剂中的焓和熵。这个练习将通过一个基础的热力学计算，帮助我们量化地理解这一过程，揭示为何置换高焓、低熵（即“不愉快”）的水分子是药物设计中的一个关键策略。",
            "id": "3864100",
            "problem": "一个蛋白质口袋中的单个水合位点已使用网格非均匀溶剂化理论 (GIST) 进行了表征，得到相对于体相水，水的焓为-8千卡/摩尔，熵罚为-10卡/(摩尔·开尔文)。考虑一个计算作图实验，其中一个纯非极性片段被置于口袋中并精确置换一个水分子，并作出以下假设：该片段与口袋产生的直接焓相互作用可以忽略不计，并且在放置时引起的构型熵变也可以忽略不计；唯一的热力学效应是将水分子从口袋中移至体相。使用吉布斯自由能的定义和标准热力学符号约定，计算在温度$T=300$开尔文时置换过程的自由能变化。以千卡/摩尔为单位表示你的最终答案，并将答案四舍五入至四位有效数字。",
            "solution": "该问题要求计算在恒定温度下分子置換过程中的吉布斯自由能变化 $\\Delta G$。控制此过程的基本热力学关系是吉布斯-亥姆霍兹方程：\n$$\n\\Delta G = \\Delta H - T\\Delta S\n$$\n其中 $\\Delta H$ 是焓变，$T$ 是绝对温度，$\\Delta S$ 是熵变。\n\n所讨论的过程是一个非极性片段将一个水分子从蛋白质口袋内的水合位点置换到体相溶剂中。这可以用以下平衡表示：\n$$\n\\text{片段}_{\\text{体相}} + \\text{水}_{\\text{位点}} \\rightleftharpoons \\text{片段}_{\\text{位点}} + \\text{水}_{\\text{体相}}\n$$\n该置换过程的总自由能变化 $\\Delta G_{\\text{置换}}$ 是每个相关组分自由能变化的总和：\n$$\n\\Delta G_{\\text{置换}} = (G_{\\text{片段, 位点}} - G_{\\text{片段, 体相}}) + (G_{\\text{水, 体相}} - G_{\\text{水, 位点}})\n$$\n问题提供了一组关键的简化假设。首先，假设非极性片段的结合在热力学上是“沉默”的：“该片段与口袋产生的直接焓相互作用可以忽略不计，并且在放置时引起的构型熵变也可以忽略不计。” 这意味着将片段从体相移动到该位点相关的自由能变化近似为零：\n$$\nG_{\\text{片段, 位点}} - G_{\\text{片段, 体相}} \\approx 0\n$$\n其次，问题指出“唯一的热力学效应是将水分子从口袋中移至体相。” 这证实了我们可以忽略片段的贡献，只关注水分子的状态变化。因此，总的置换自由能等于水分子从位点移动到体相时的自由能变化：\n$$\n\\Delta G_{\\text{置换}} \\approx G_{\\text{水, 体相}} - G_{\\text{水, 位点}}\n$$\n让我们使用焓和熵的定义来展开这一项：\n$$\n\\Delta G_{\\text{置换}} = (H_{\\text{水, 体相}} - T S_{\\text{水, 体相}}) - (H_{\\text{水, 位点}} - T S_{\\text{水, 位点}})\n$$\n重新排列各项得到：\n$$\n\\Delta G_{\\text{置换}} = (H_{\\text{水, 体相}} - H_{\\text{水, 位点}}) - T(S_{\\text{水, 体相}} - S_{\\text{水, 位点}})\n$$\n问题提供了位点水相对于体相水的热力学性质。在网格非均匀溶剂化理论 (GIST) 的背景下，这些被称为过剩性质。\n“水的焓为-8千卡/摩尔”指的是过剩焓 $\\Delta H_{\\text{exc}}$：\n$$\n\\Delta H_{\\text{exc}} = H_{\\text{水, 位点}} - H_{\\text{水, 体相}} = -8 \\text{ kcal/mol}\n$$\n“熵罚为-10卡/(摩尔·开尔文)”指的是过剩熵 $\\Delta S_{\\text{exc}}$。“罚”这个词表示不利的贡献，$\\Delta S_{\\text{exc}}$ 的负值表明水在位点中比在体相中更有序。\n$$\n\\Delta S_{\\text{exc}} = S_{\\text{水, 位点}} - S_{\\text{水, 体相}} = -10 \\text{ cal mol}^{-1} \\text{ K}^{-1}\n$$\n我们 $\\Delta G_{\\text{置换}}$ 表达式中的项是这些过剩性质的负值：\n$$\nH_{\\text{水, 体相}} - H_{\\text{水, 位点}} = - \\Delta H_{\\text{exc}} = -(-8 \\text{ kcal/mol}) = +8 \\text{ kcal/mol}\n$$\n$$\nS_{\\text{水, 体相}} - S_{\\text{水, 位点}} = - \\Delta S_{\\text{exc}} = -(-10 \\text{ cal mol}^{-1} \\text{ K}^{-1}) = +10 \\text{ cal mol}^{-1} \\text{ K}^{-1}\n$$\n现在，我们可以将这些值代回到 $\\Delta G_{\\text{置换}}$ 的方程中：\n$$\n\\Delta G_{\\text{置换}} = (+8 \\text{ kcal/mol}) - T(+10 \\text{ cal mol}^{-1} \\text{ K}^{-1})\n$$\n给定温度为 $T = 300 \\text{ K}$。在进行减法运算之前，我们必须确保单位一致。我们将熵项的单位从卡路里转换为千卡。\n$$\n1 \\text{ kcal} = 1000 \\text{ cal}\n$$\n所以，熵变为：\n$$\n-\\Delta S_{\\text{exc}} = +10 \\text{ cal mol}^{-1} \\text{ K}^{-1} = +10 \\times 10^{-3} \\text{ kcal mol}^{-1} \\text{ K}^{-1} = 0.010 \\text{ kcal mol}^{-1} \\text{ K}^{-1}\n$$\n现在，我们计算对自由能的总熵贡献 $T(-\\Delta S_{\\text{exc}})$：\n$$\nT(-\\Delta S_{\\text{exc}}) = (300 \\text{ K}) \\times (0.010 \\text{ kcal mol}^{-1} \\text{ K}^{-1}) = 3.0 \\text{ kcal/mol}\n$$\n最后，我们计算置换过程的总自由能变化：\n$$\n\\Delta G_{\\text{置换}} = 8 \\text{ kcal/mol} - 3.0 \\text{ kcal/mol} = 5.0 \\text{ kcal/mol}\n$$\n$\\Delta G_{\\text{置換}}$ 的正号表明置换这个特定的水分子在热力学上是不利的。这是预料之中的，因为该水分子处于低焓、高度稳定的状态（一个“快乐”的水分子），将其释放到体相溶剂中获得的熵增不足以克服破坏其在口袋中有利相互作用所带来的巨大焓罚。\n\n问题要求答案四舍五入到四位有效数字。\n$$\n\\Delta G_{\\text{置换}} = 5.000 \\text{ kcal/mol}\n$$",
            "answer": "$$\n\\boxed{5.000}\n$$"
        },
        {
            "introduction": "像网格不均匀溶剂化理论（GIST）这样的计算方法，能为蛋白质表面的溶剂提供精细的三维热力学图谱，包括焓密度和熵密度。然而，原始的密度图谱数据非常庞大，为了得到对药物设计有指导意义的结论，我们必须将其转化为更简洁、可解释的物理量。这个练习将指导你如何通过数值积分，将一个特定口袋区域内的热力学密度场整合为单一的总自由能值，这是评估和比较不同结合口袋性质的关键一步。",
            "id": "3864113",
            "problem": "给定来自网格非均匀溶剂化理论 (GIST) 的溶剂体积热力学场，用于大分子表面周围的显式溶剂映射。这些场是焓密度 $h(\\mathbf{r})$ 和熵密度 $s(\\mathbf{r})$，每个都按单位体积定义。同时给定温度 $T$ 和一个由轴对齐边界定义的矩形口袋区域。假设一个均匀的笛卡尔网格，其间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$，原点位于 $(0,0,0)$。整数索引为 $(i,j,k)$ 的体素的中心位于 $\\left((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y, (k+\\tfrac{1}{2})\\Delta z\\right)$。一个体素被包含在口袋区域内的充分必要条件是其中心位于每个边界的闭区间内。所有焓密度值 $h$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，所有熵密度值 $s$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$，温度 $T$ 的单位为 $\\mathrm{K}$，所有网格间距的单位为 $\\mathrm{nm}$。您的任务是通过在网格上进行数值积分，计算与该口袋区域相关的净自由能。\n\n您的推理应基于恒温恒压下吉布斯自由能 $G$ 的定义、体积密度的含义以及黎曼和离散化。您的算法必须：\n- 使用基本热力学定义，推导将被积函数，该函数将给定的密度与局部自由能密度场联系起来，\n- 通过对所有中心落在指定区域内的体素的贡献求和，在该区域上执行离散数值积分，\n- 以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位返回总自由能。\n\n将每个最终结果表示为以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位的浮点数，四舍五入到六位小数。您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，`[`result1`,`result2`,`result3`]`）。\n\n测试套件：\n对于下面的每个测试用例，实现指定的网格、场、温度和区域。使用上面定义的包含规则。为简洁起见，当一个场是恒定的时，它适用于所有网格点；否则，值将按体素索引明确给出。\n\n- 测试用例 1 (正常路径，均匀场):\n  - 网格形状：$2 \\times 2 \\times 2$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h(\\mathbf{r}) \\equiv 2.0\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s(\\mathbf{r}) \\equiv 0.005\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 1.0]$ (单位均为 $\\mathrm{nm}$)。\n\n- 测试用例 2 (各向异性间距，非均匀场):\n  - 网格形状：$2 \\times 2 \\times 1$。\n  - 间距：$\\Delta x = 0.2\\ \\mathrm{nm}$，$\\Delta y = 0.25\\ \\mathrm{nm}$，$\\Delta z = 0.4\\ \\mathrm{nm}$。\n  - 温度：$T = 310\\ \\mathrm{K}$。\n  - 焓密度 $h_{i,j,k}$，单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$：\n    - $h_{0,0,0} = 1.0$, $h_{0,1,0} = 2.0$, $h_{1,0,0} = 3.0$, $h_{1,1,0} = 4.0$。\n  - 熵密度 $s_{i,j,k}$，单位 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$：\n    - $s_{0,0,0} = 0.002$, $s_{0,1,0} = 0.000$, $s_{1,0,0} = 0.004$, $s_{1,1,0} = 0.001$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 0.4]$。\n\n- 测试用例 3 (空区域边界条件):\n  - 网格形状：$2 \\times 2 \\times 2$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h(\\mathbf{r}) \\equiv 1.0\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s(\\mathbf{r}) \\equiv 0.001\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [10.0, 11.0]$，$y \\in [10.0, 11.0]$，$z \\in [10.0, 11.0]$。\n\n- 测试用例 4 (单一体素，强有利溶剂化，负自由能):\n  - 网格形状：$1 \\times 1 \\times 1$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h_{0,0,0} = 0.1\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s_{0,0,0} = 0.010\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 1.0]$。\n\n您的程序应计算每个测试用例的自由能，并以 `[`v1`,`v2`,`v3`,`v4`]` 的确切格式打印单行结果，其中每个 `v` 是如上所述以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位的四舍五入值。",
            "solution": "该问题要求计算在一个指定的矩形空间区域（称为“口袋”）内的总吉布斯自由能 $G_{pocket}$。我们在一个离散的笛卡尔网格上获得了焓的体积密度场 $h(\\mathbf{r})$ 和熵的体积密度场 $s(\\mathbf{r})$，以及一个恒定的温度 $T$。解决方案将从基本热力学原理推导得出，并实现为对落入该口袋区域内的网格体素的数值积分。\n\n首先，我们建立理论基础。吉布斯自由能 $G$ 与焓 $H$ 和熵 $S$ 在恒定温度 $T$ 下的关系由以下方程给出：\n$$G = H - TS$$\n此关系也适用于它们对应的体积密度。令 $g(\\mathbf{r})$、$h(\\mathbf{r})$ 和 $s(\\mathbf{r})$ 分别表示在空间位置 $\\mathbf{r}$ 处每单位体积的吉布斯自由能、焓和熵。因此，局部自由能密度由下式给出：\n$$g(\\mathbf{r}) = h(\\mathbf{r}) - T s(\\mathbf{r})$$\n所提供的单位对于此计算是一致的。焓密度 $h(\\mathbf{r})$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，熵密度 $s(\\mathbf{r})$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$，温度 $T$ 的单位是 $\\mathrm{K}$。因此，乘积 $T s(\\mathbf{r})$ 的单位是 $(\\mathrm{K}) \\times (\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}) = \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，与 $h(\\mathbf{r})$ 的单位相匹配。因此，自由能密度 $g(\\mathbf{r})$ 正确地以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$ 为单位表示。\n\n口袋体积 $V_p$ 内的总自由能是自由能密度在该体积上的积分：\n$$G_{pocket} = \\iiint_{V_p} g(\\mathbf{r}) \\, dV = \\iiint_{V_p} [h(\\mathbf{r}) - T s(\\mathbf{r})] \\, dV$$\n\n问题指定场是在离散网格上定义的。这个连续积分可以通过数值求和来近似，具体来说是黎曼和。积分域被划分为离散的体积元素，即体素。每个体素对总自由能的贡献是，在体素内一个代表点（本例中为其中心）处评估的自由能密度与该体素体积的乘积。\n\n设网格间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。每个体素的体积是恒定的：\n$$\\Delta V = \\Delta x \\Delta y \\Delta z$$\n整数索引为 $(i, j, k)$ 的体素中心位于坐标 $\\mathbf{r}_{i,j,k} = \\left((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y, (k+\\tfrac{1}{2})\\Delta z\\right)$ 处。该体素的焓密度和熵密度表示为 $h_{i,j,k}$ 和 $s_{i,j,k}$。\n\n总自由能是所有中心位于由 $x \\in [x_{min}, x_{max}]$，$y \\in [y_{min}, y_{max}]$ 和 $z \\in [z_{min}, z_{max}]$ 定义的口袋边界内的体素贡献之和。令 $\\mathcal{S}$ 为其中心位于口袋内的所有体素索引 $(i,j,k)$ 的集合。\n\n$$\n\\mathcal{S} = \\left\\{ (i,j,k) \\mid\n\\begin{array}{l}\nx_{min} \\le (i+\\tfrac{1}{2})\\Delta x \\le x_{max} \\\\\ny_{min} \\le (j+\\tfrac{1}{2})\\Delta y \\le y_{max} \\\\\nz_{min} \\le (k+\\tfrac{1}{2})\\Delta z \\le z_{max}\n\\end{array}\n\\right\\}\n$$\n\n然后，通过对集合 $\\mathcal{S}$ 中每个体素的贡献求和来计算总口袋自由能 $G_{pocket}$：\n$$G_{pocket} \\approx \\sum_{(i,j,k) \\in \\mathcal{S}} [h_{i,j,k} - T s_{i,j,k}] \\cdot \\Delta V$$\n其中 $G_{pocket}$ 的单位将是 $(\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}) \\times (\\mathrm{nm}^3) = \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，符合要求。\n\n要实现的算法如下：\n1. 对于给定的测试用例，定义网格维度 ($N_x, N_y, N_z$)、网格间距 ($\\Delta x, \\Delta y, \\Delta z$)、温度 ($T$)、口袋边界以及网格化的焓 ($h_{i,j,k}$) 和熵 ($s_{i,j,k}$) 场。\n2. 计算单个体素的体积 $\\Delta V = \\Delta x \\Delta y \\Delta z$。\n3. 初始化一个用于总自由能的变量 $G_{total}$ 为 $0.0$。\n4. 遍历所有体素索引，$i$ 从 $0$ 到 $N_x-1$，$j$ 从 $0$ 到 $N_y-1$，$k$ 从 $0$ 到 $N_z-1$。\n5. 对于每个体素 $(i,j,k)$，计算其中心的坐标：$x_c = (i+0.5)\\Delta x$，$y_c = (j+0.5)\\Delta y$，$z_c = (k+0.5)\\Delta z$。\n6. 检查中心 $(x_c, y_c, z_c)$ 是否落在口袋边界的闭区间内。\n7. 如果体素在口袋区域内，计算其对自由能的贡献：$\\Delta G_{i,j,k} = (h_{i,j,k} - T s_{i,j,k}) \\times \\Delta V$。\n8. 将此贡献加到累计总和中：$G_{total} = G_{total} + \\Delta G_{i,j,k}$。\n9. 遍历完所有体素后，$G_{total}$ 的最终值就是该测试用例的结果。然后将此值四舍五入到六位小数。\n此过程将应用于提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net free energy for several test cases based on GIST fields.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"grid_shape\": (2, 2, 2),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((2, 2, 2), 2.0),\n            \"s_field\": np.full((2, 2, 2), 0.005),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 1.0))\n        },\n        {\n            \"grid_shape\": (2, 2, 1),\n            \"spacings\": (0.2, 0.25, 0.4),\n            \"T\": 310.0,\n            \"h_field\": np.array([\n                [[1.0], [2.0]], # i=0, j=0,1 ; k=0\n                [[3.0], [4.0]]  # i=1, j=0,1 ; k=0\n            ]),\n            \"s_field\": np.array([\n                [[0.002], [0.000]],\n                [[0.004], [0.001]]\n            ]),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 0.4))\n        },\n        {\n            \"grid_shape\": (2, 2, 2),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((2, 2, 2), 1.0),\n            \"s_field\": np.full((2, 2, 2), 0.001),\n            \"pocket_bounds\": ((10.0, 11.0), (10.0, 11.0), (10.0, 11.0))\n        },\n        {\n            \"grid_shape\": (1, 1, 1),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((1, 1, 1), 0.1),\n            \"s_field\": np.full((1, 1, 1), 0.010),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 1.0))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_pocket_energy(\n            grid_shape=case[\"grid_shape\"],\n            spacings=case[\"spacings\"],\n            T=case[\"T\"],\n            h_field=case[\"h_field\"],\n            s_field=case[\"s_field\"],\n            pocket_bounds=case[\"pocket_bounds\"]\n        )\n        results.append(f\"{result:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_pocket_energy(grid_shape, spacings, T, h_field, s_field, pocket_bounds):\n    \"\"\"\n    Calculates the free energy of a pocket by integrating over GIST fields.\n\n    Args:\n        grid_shape (tuple): The dimensions (Nx, Ny, Nz) of the grid.\n        spacings (tuple): The grid spacings (dx, dy, dz) in nm.\n        T (float): The temperature in K.\n        h_field (np.ndarray): The 3D enthalpy density field in kJ/mol/nm^3.\n        s_field (np.ndarray): The 3D entropy density field in kJ/mol/K/nm^3.\n        pocket_bounds (tuple): The pocket region as ((xmin, xmax), (ymin, ymax), (zmin, zmax)).\n\n    Returns:\n        float: The total free energy of the pocket in kJ/mol.\n    \"\"\"\n    Nx, Ny, Nz = grid_shape\n    dx, dy, dz = spacings\n    (xmin, xmax), (ymin, ymax), (zmin, zmax) = pocket_bounds\n    \n    # Calculate the volume of a single voxel\n    dV = dx * dy * dz\n    \n    total_free_energy = 0.0\n    \n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # Calculate the center of the voxel (i, j, k)\n                xc = (i + 0.5) * dx\n                yc = (j + 0.5) * dy\n                zc = (k + 0.5) * dz\n                \n                # Check if the voxel center is within the pocket bounds\n                if (xmin = xc = xmax) and \\\n                   (ymin = yc = ymax) and \\\n                   (zmin = zc = zmax):\n                    \n                    # Retrieve the enthalpy and entropy densities for this voxel\n                    h_ijk = h_field[i, j, k]\n                    s_ijk = s_field[i, j, k]\n                    \n                    # Calculate the free energy density g = h - T*s\n                    g_ijk = h_ijk - T * s_ijk\n                    \n                    # Add this voxel's contribution to the total free energy\n                    total_free_energy += g_ijk * dV\n                    \n    return total_free_energy\n\nsolve()\n```"
        },
        {
            "introduction": "蛋白质本质上是动态的，其结合口袋会在多种构象状态之间进行转换，而每种构象都可能展现出不同的溶剂化特性和热点。因此，仅基于单一静态结构的溶剂图谱分析可能无法捕捉到真实的结合机会。这个高级练习将向你展示如何将蛋白质动力学（通过马尔可夫状态模型MSM描述）与溶剂图谱数据相结合，计算出考虑了构象系综的平衡加权热点强度，从而为动态口袋提供一个更完整、更真实的评估。",
            "id": "3864027",
            "problem": "给定一个关于口袋构象的离散时间马尔可夫状态模型 (MSM)，以及每个状态在网格上由溶剂映射派生的探针相互作用自由能。目标是计算特定于状态的热点强度及其平衡加权总和。设计必须从第一性原理出发，明确使用玻尔兹曼分布计算占据率和马尔可夫链的平稳分布。\n\n定义与基本原理：\n- 马尔可夫状态模型 (MSM) 由一个行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 定义，用于描述 $n$ 个亚稳态口袋构象状态。其中每个条目 $P_{ij}$ 是在一步时间内从状态 $i$ 转移到状态 $j$ 的概率，并且对于所有 $i$，$\\sum_{j=1}^{n} P_{ij} = 1$。\n- 马尔可夫链的平稳分布 $\\boldsymbol{\\pi} \\in \\mathbb{R}^{n}$ 满足 $\\boldsymbol{\\pi}^{\\top} = \\boldsymbol{\\pi}^{\\top} P$ 和 $\\sum_{i=1}^{n} \\pi_i = 1$，其中对于所有 $i$，$\\pi_i \\geq 0$。\n- 对于每个状态 $s \\in \\{1,\\dots,n\\}$，溶剂映射在 $m_s$ 个不同的网格点上提供一组探针相互作用自由能 $\\{\\Delta G_{s,i}\\}_{i=1}^{m_s}$。这些能量以千焦耳/摩尔 (kJ/mol) 为单位表示。\n- 玻尔兹曼分布给出在状态 $s$ 中，探针在网格点 $i$ 的相对占据率与 $\\exp(-\\beta \\Delta G_{s,i})$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$T$ 是以开尔文 (K) 为单位的绝对温度，$k_{\\mathrm{B}}$ 是以千焦耳/摩尔/开尔文 (kJ/mol/K) 表示的玻尔兹曼常数。\n- 在状态 $s$ 内的归一化占据概率为 $p_{s,i} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{\\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})}$，其满足 $\\sum_{i=1}^{m_s} p_{s,i} = 1$。\n- 对此问题，热点被操作性地定义为：在给定状态下，其占据概率超过阈值 $\\tau \\in (0,1)$ 的网格点集合。特定于状态的热点强度是超过阈值的累积占据质量：$H_s(\\tau) = \\sum_{i=1}^{m_s} p_{s,i} \\cdot \\mathbf{1}\\{p_{s,i} \\ge \\tau\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 平衡加权总热点强度为 $H_{\\mathrm{eq}}(\\tau) = \\sum_{s=1}^{n} \\pi_s \\, H_s(\\tau)$。\n\n任务：\n- 对于每个测试用例，计算所有状态 $s$ 的 $H_s(\\tau)$，然后使用给定转移矩阵 $P$ 的平稳分布 $\\boldsymbol{\\pi}$ 计算 $H_{\\mathrm{eq}}(\\tau)$。\n\n物理和数值单位：\n- 能量 $\\Delta G_{s,i}$ 以 kJ/mol 为单位。\n- 温度 $T$ 以开尔文 (K) 为单位。\n- 使用 $k_{\\mathrm{B}} = 0.008314462618\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n- 热点强度 $H_s(\\tau)$ 和 $H_{\\mathrm{eq}}(\\tau)$ 是无单位的（无量纲概率）。\n- 所有输出均表示为四舍五入到六位小数的浮点数（即小数点后有六位数字）。不涉及角度。任何地方都不要使用百分比；请使用小数。\n\n测试套件：\n对于每个测试用例，您将获得：\n- 一个行随机转移矩阵 $P$。\n- 一个能量数组列表，其中第 $s$ 个数组指定了 $\\{\\Delta G_{s,i}\\}_{i=1}^{m_s}$。\n- 一个以开尔文为单位的温度 $T$。\n- 一个阈值 $\\tau$。\n\n计算所有状态 $s$ 的每个状态的热点强度 $H_s(\\tau)$ 以及 $H_{\\mathrm{eq}}(\\tau)$。\n\n测试用例 1 (正常路径，三个亚稳态，异构能量)：\n- $P = \\begin{bmatrix}\n0.90  0.09  0.01 \\\\\n0.05  0.90  0.05 \\\\\n0.02  0.08  0.90\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{-4.0, -2.5, -1.0, 0.5, 3.0\\}$ kJ/mol\n  - 状态 2：$\\{-1.5, -1.0, -0.5, 0.0, 1.0\\}$ kJ/mol\n  - 状态 3：$\\{-5.0, -3.0, -2.0, -1.0, 2.0\\}$ kJ/mol\n- $T = 300$ K\n- $\\tau = 0.20$\n\n测试用例 2 (边缘情况，一个状态能量均一，近吸收动力学)：\n- $P = \\begin{bmatrix}\n0.98  0.02 \\\\\n0.03  0.97\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{0.0, 0.0, 0.0, 0.0\\}$ kJ/mol\n  - 状态 2：$\\{-2.0, -2.0, -2.0, -2.0\\}$ kJ/mol\n- $T = 310$ K\n- $\\tau = 0.25$\n\n测试用例 3 (边界覆盖，四个状态具有尖锐和弥散的热点)：\n- $P = \\begin{bmatrix}\n0.85  0.10  0.03  0.02 \\\\\n0.06  0.80  0.10  0.04 \\\\\n0.05  0.15  0.75  0.05 \\\\\n0.02  0.08  0.10  0.80\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{-6.0, -1.0, 2.0, 4.0, -0.5\\}$ kJ/mol\n  - 状态 2：$\\{-0.2, -0.1, 0.0, 0.1, 0.2\\}$ kJ/mol\n  - 状态 3：$\\{-3.0, -2.9, -2.8, 3.0, 4.0\\}$ kJ/mol\n  - 状态 4：$\\{-1.0, 1.0, 2.0, -0.5, -0.2\\}$ kJ/mol\n- $T = 290$ K\n- $\\tau = 0.30$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的串联结果，形式为用方括号括起来的逗号分隔列表。\n- 对于每个测试用例，按状态索引顺序输出所有状态 $s$ 的每个状态的热点强度 $H_s(\\tau)$，后跟平衡总和 $H_{\\mathrm{eq}}(\\tau)$，所有值均四舍五入到六位小数。\n- 具体来说，如果测试用例 1 有 $n_1$ 个状态，测试用例 2 有 $n_2$ 个状态，测试用例 3 有 $n_3$ 个状态，则输出格式为 $[H_{1,1}, \\dots, H_{1,n_1}, H_{1,\\mathrm{eq}}, H_{2,1}, \\dots, H_{2,n_2}, H_{2,\\mathrm{eq}}, H_{3,1}, \\dots, H_{3,n_3}, H_{3,\\mathrm{eq}}]$，其中第一个索引表示测试用例，第二个索引表示状态。",
            "solution": "该问题是有效的，因为它在科学上基于统计力学和马尔可夫链理论的原理，提供了所有必要信息使其成为一个适定的问题，并且其定义和目标是客观的。任务是基于蛋白质口袋构象的马尔可夫状态模型 (MSM) 及其相关的溶剂-探针相互作用能量，计算特定于状态和平衡加权的热点强度。\n\n对于每个测试用例，解决方案基于所提供的基本原理，按算法分为三个主要步骤进行。\n\n**第 1 步：计算平稳分布 ($\\boldsymbol{\\pi}$)**\n\nMSM 平衡分析的基础是其平稳分布 $\\boldsymbol{\\pi}$。该向量 $\\boldsymbol{\\pi} = (\\pi_1, \\pi_2, \\dots, \\pi_n)$ 列出了发现系统处于 $n$ 个构象状态中每个状态的平衡概率。它的定义属性是在转移矩阵 $P$ 的作用下保持不变。在数学上，这表示为左特征向量方程：\n$$ \\boldsymbol{\\pi}^{\\top} P = \\boldsymbol{\\pi}^{\\top} $$\n这个方程，连同归一化条件 $\\sum_{i=1}^{n} \\pi_i = 1$，对于一个不可约且非周期的马尔可夫链（给定的转移矩阵即属此类），唯一确定了 $\\boldsymbol{\\pi}$。\n\n为了求解 $\\boldsymbol{\\pi}$，我们可以将方程重写为 $\\boldsymbol{\\pi}^{\\top} (P - I) = \\mathbf{0}^{\\top}$，其中 $I$ 是单位矩阵，$\\mathbf{0}$ 是零向量。转置后得到 $(P^{\\top} - I) \\boldsymbol{\\pi} = \\mathbf{0}$。这意味着 $\\boldsymbol{\\pi}$ 是转置矩阵 $P^{\\top}$ 对应于特征值 $\\lambda=1$ 的右特征向量。在数值上，这是一个标准且可稳健求解的特征值问题。我们找到该特征向量，取其实部（因为平稳分布必须是实数），并将其归一化，使其元素之和为 $1$。\n\n**第 2 步：计算特定于状态的热点强度 ($H_s(\\tau)$)**\n\n对于每个构象状态 $s$，我们都有一组在不同网格点 $i$ 上的探针相互作用自由能 $\\{\\Delta G_{s,i}\\}$。探针在特定网格点的占据情况受玻尔兹曼统计原理的支配。在状态 $s$ 内，探针占据网格点 $i$ 的概率 $p_{s,i}$ 与其玻尔兹曼因子 $\\exp(-\\beta \\Delta G_{s,i})$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆热能。\n\n为了为每个状态获得一个有效的概率分布，我们通过将这些因子除以该状态内所有网格点的因子总和来进行归一化。总和 $Z_s = \\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})$ 是探针在状态 $s$ 口袋内的配分函数。因此，归一化占据概率为：\n$$ p_{s,i} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{Z_s} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{\\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})} $$\n在数值计算中，为了避免在计算大的负能量的指数时发生溢出，一种标准技术是使用对数-和-指数 (log-sum-exp) 稳定化技巧。我们计算 $L_{s,i} = -\\beta \\Delta G_{s,i}$，找到 $L_{s,\\max} = \\max_i L_{s,i}$，然后按如下方式计算概率：\n$$ p_{s,i} = \\frac{\\exp(L_{s,i} - L_{s,\\max})}{\\sum_{j=1}^{m_s} \\exp(L_{s,j} - L_{s,\\max})} $$\n这种变换可以防止数值溢出，同时得到相同的最终概率。\n\n根据问题的定义，热点由占据概率 $p_{s,i}$ 大于或等于给定阈值 $\\tau$ 的网格点组成。特定于状态的热点强度 $H_s(\\tau)$ 是这些热点网格点的总概率质量：\n$$ H_s(\\tau) = \\sum_{i=1}^{m_s} p_{s,i} \\cdot \\mathbf{1}\\{p_{s,i} \\ge \\tau\\} $$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果内部条件为真，则其值为 $1$，否则为 $0$。\n\n**第 3 步：计算平衡加权总热点强度 ($H_{\\mathrm{eq}}(\\tau)$)**\n\n系统的总体或平衡性质是所有状态的平均值，按其平衡布居数 $\\pi_s$ 进行加权。因此，总热点强度 $H_{\\mathrm{eq}}(\\tau)$ 是作为特定于状态的热点强度 $H_s(\\tau)$ 在平稳分布 $\\boldsymbol{\\pi}$ 上的期望来计算的：\n$$ H_{\\mathrm{eq}}(\\tau) = \\sum_{s=1}^{n} \\pi_s H_s(\\tau) $$\n这个最终值代表了在热平衡状态下，在构象系综上平均的总热点概率质量。\n\n通过为每个测试用例执行这三个步骤，我们可以计算出所需的量。该过程综合运用了线性代数、统计力学和概率论的原理，以模拟计算药物设计中的一个物理相关问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes state-specific and equilibrium-weighted hotspot strengths for\n    a series of Markov State Models and associated solvent-mapping energies.\n    \"\"\"\n    \n    # Define physical constants and test cases from the problem statement.\n    K_B = 0.008314462618  # Boltzmann constant in kJ/mol/K\n\n    test_cases = [\n        (\n            np.array([\n                [0.90, 0.09, 0.01],\n                [0.05, 0.90, 0.05],\n                [0.02, 0.08, 0.90]\n            ]),\n            [\n                np.array([-4.0, -2.5, -1.0, 0.5, 3.0]),\n                np.array([-1.5, -1.0, -0.5, 0.0, 1.0]),\n                np.array([-5.0, -3.0, -2.0, -1.0, 2.0])\n            ],\n            300.0,\n            0.20\n        ),\n        (\n            np.array([\n                [0.98, 0.02],\n                [0.03, 0.97]\n            ]),\n            [\n                np.array([0.0, 0.0, 0.0, 0.0]),\n                np.array([-2.0, -2.0, -2.0, -2.0])\n            ],\n            310.0,\n            0.25\n        ),\n        (\n            np.array([\n                [0.85, 0.10, 0.03, 0.02],\n                [0.06, 0.80, 0.10, 0.04],\n                [0.05, 0.15, 0.75, 0.05],\n                [0.02, 0.08, 0.10, 0.80]\n            ]),\n            [\n                np.array([-6.0, -1.0, 2.0, 4.0, -0.5]),\n                np.array([-0.2, -0.1, 0.0, 0.1, 0.2]),\n                np.array([-3.0, -2.9, -2.8, 3.0, 4.0]),\n                np.array([-1.0, 1.0, 2.0, -0.5, -0.2])\n            ],\n            290.0,\n            0.30\n        )\n    ]\n\n    all_results = []\n\n    def compute_stationary_distribution(p_matrix):\n        \"\"\"\n        Calculates the stationary distribution of a Markov chain.\n        The stationary distribution pi satisfies pi^T * P = pi^T.\n        This is equivalent to finding the right eigenvector of P^T\n        for the eigenvalue 1.\n        \"\"\"\n        eigenvalues, eigenvectors = linalg.eig(p_matrix.T)\n        # Find the index of the eigenvalue that is close to 1.0\n        # This handles potential floating point inaccuracies.\n        idx = np.where(np.isclose(eigenvalues, 1.0))[0][0]\n        # The eigenvector is complex, take the real part.\n        pi_unnormalized = eigenvectors[:, idx].real\n        # Normalize to ensure it's a probability distribution (sums to 1).\n        pi = pi_unnormalized / np.sum(pi_unnormalized)\n        return pi\n\n    for case in test_cases:\n        p_matrix, energies_list, temp, threshold = case\n        n_states = p_matrix.shape[0]\n\n        # Step 1: Calculate the stationary distribution\n        pi = compute_stationary_distribution(p_matrix)\n\n        # Step 2: Calculate state-specific hotspot strengths\n        h_s_list = []\n        beta = 1.0 / (K_B * temp)\n        \n        for s in range(n_states):\n            delta_g_s = energies_list[s]\n            \n            # Calculate Boltzmann factors and probabilities using a\n            # numerically stable method (log-sum-exp trick) to prevent overflow.\n            log_weights = -beta * delta_g_s\n            # Shift by the max value to keep exponents in a small range\n            log_weights_shifted = log_weights - np.max(log_weights)\n            weights = np.exp(log_weights_shifted)\n            probs = weights / np.sum(weights)\n\n            # A hotspot comprises points with occupancy probability >= threshold.\n            # The hotspot strength is the sum of these probabilities.\n            h_s = np.sum(probs[probs >= threshold])\n            h_s_list.append(h_s)\n\n        # Step 3: Calculate the equilibrium-weighted aggregate hotspot strength\n        h_eq = np.sum(pi * np.array(h_s_list))\n        \n        # Collect results for this case\n        all_results.extend(h_s_list)\n        all_results.append(h_eq)\n\n    # Format the final output string as required.\n    # Each value is a float rounded to six decimal places.\n    output_str = \",\".join([f\"{r:.6f}\" for r in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}