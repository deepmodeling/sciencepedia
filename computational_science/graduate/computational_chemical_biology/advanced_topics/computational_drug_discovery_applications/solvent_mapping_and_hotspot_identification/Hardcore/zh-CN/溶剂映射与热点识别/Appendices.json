{
    "hands_on_practices": [
        {
            "introduction": "置换结合位点中的水分子是配体结合过程中的一个关键热力学事件。此练习旨在通过一个基础计算，阐明溶剂热点的核心原理：一个“不稳定”的水分子（即具有高自由能的水分子）被配体片段置换后，会带来有利的自由能增益。通过使用单个水分子的焓（$H$）和熵（$S$）数据来直接计算置换过程的吉布斯自由能变化（$\\Delta G$），我们将把抽象的热力学概念与具体的药物设计策略联系起来。",
            "id": "3864100",
            "problem": "一个蛋白质口袋中的单个水合位点已通过网格非均匀溶剂化理论 (GIST) 进行了表征，得到其水的焓值为 $-8$ 千卡/摩尔，相对于本体水，其熵罚为 $-10$ 卡/(摩尔·开尔文)。考虑一个计算作图实验，其中一个纯粹的非极性片段被置于口袋中，并正好取代一个水分子，并作出以下假设：该片段与口袋产生的直接焓相互作用可忽略不计，并且在置入过程中产生的构象熵变也可忽略不计；唯一的热力学效应是将水分子从口袋中移到本体溶剂中。使用吉布斯自由能的定义和标准热力学符号约定，计算在温度 $T=300$ 开尔文时该置换过程的自由能变化。以千卡/摩尔为单位表示你的最终答案，并四舍五入到四位有效数字。",
            "solution": "问题要求计算在恒定温度下分子置换过程的吉布斯自由能变化 $\\Delta G$。控制此过程的基本热力学关系是吉布斯-亥姆霍兹方程：\n$$\n\\Delta G = \\Delta H - T\\Delta S\n$$\n其中 $\\Delta H$ 是焓变， $T$ 是绝对温度， $\\Delta S$ 是熵变。\n\n所讨论的过程是一个非极性片段将一个水分子从蛋白质口袋内的水合位点置换到本体溶剂中。这可以用以下平衡来表示：\n$$\n\\text{Fragment}_{\\text{bulk}} + \\text{Water}_{\\text{site}} \\rightleftharpoons \\text{Fragment}_{\\text{site}} + \\text{Water}_{\\text{bulk}}\n$$\n该置换的总自由能变化 $\\Delta G_{\\text{displacement}}$ 是所涉及的每个组分自由能变化的总和：\n$$\n\\Delta G_{\\text{displacement}} = (G_{\\text{Fragment, site}} - G_{\\text{Fragment, bulk}}) + (G_{\\text{Water, bulk}} - G_{\\text{Water, site}})\n$$\n问题提供了一组关键的简化假设。首先，假设非极性片段的结合在热力学上是“沉默”的：“该片段与口袋产生的直接焓相互作用可忽略不计，并且在置入过程中产生的构象熵变也可忽略不计。”这意味着将片段从本体溶剂移动到该位点相关的自由能变化约等于零：\n$$\nG_{\\text{Fragment, site}} - G_{\\text{Fragment, bulk}} \\approx 0\n$$\n其次，问题指出“唯一的热力学效应是将水分子从口袋中移到本体溶剂中。”这证实了我们可以忽略片段的贡献，只关注水分子状态的变化。因此，置换的总自由能等于水分子从位点移动到本体溶剂的自由能变化：\n$$\n\\Delta G_{\\text{displacement}} \\approx G_{\\text{Water, bulk}} - G_{\\text{Water, site}}\n$$\n让我们使用焓和熵的定义来展开这一项：\n$$\n\\Delta G_{\\text{displacement}} = (H_{\\text{Water, bulk}} - T S_{\\text{Water, bulk}}) - (H_{\\text{Water, site}} - T S_{\\text{Water, site}})\n$$\n重新整理各项可得：\n$$\n\\Delta G_{\\text{displacement}} = (H_{\\text{Water, bulk}} - H_{\\text{Water, site}}) - T(S_{\\text{Water, bulk}} - S_{\\text{Water, site}})\n$$\n问题提供了位点水相对于本体水的热力学性质。在网格非均匀溶剂化理论 (GIST) 的背景下，这些被称为过剩性质。\n“水的焓值为 $-8$ 千卡/摩尔”指的是过剩焓 $\\Delta H_{\\text{exc}}$：\n$$\n\\Delta H_{\\text{exc}} = H_{\\text{Water, site}} - H_{\\text{Water, bulk}} = -8 \\text{ kcal/mol}\n$$\n“熵罚为 $-10$ 卡/(摩尔·开尔文)”指的是过剩熵 $\\Delta S_{\\text{exc}}$。“罚”这一术语表示一个不利的贡献，而 $\\Delta S_{\\text{exc}}$ 的负值表明水在位点中比在本体溶剂中更有序。\n$$\n\\Delta S_{\\text{exc}} = S_{\\text{Water, site}} - S_{\\text{Water, bulk}} = -10 \\text{ cal mol}^{-1} \\text{ K}^{-1}\n$$\n我们表达式 $\\Delta G_{\\text{displacement}}$ 中的各项是这些过剩性质的负值：\n$$\nH_{\\text{Water, bulk}} - H_{\\text{Water, site}} = - \\Delta H_{\\text{exc}} = -(-8 \\text{ kcal/mol}) = +8 \\text{ kcal/mol}\n$$\n$$\nS_{\\text{Water, bulk}} - S_{\\text{Water, site}} = - \\Delta S_{\\text{exc}} = -(-10 \\text{ cal mol}^{-1} \\text{ K}^{-1}) = +10 \\text{ cal mol}^{-1} \\text{ K}^{-1}\n$$\n现在，我们可以将这些值代回到 $\\Delta G_{\\text{displacement}}$ 的方程中：\n$$\n\\Delta G_{\\text{displacement}} = (+8 \\text{ kcal/mol}) - T(+10 \\text{ cal mol}^{-1} \\text{ K}^{-1})\n$$\n给定的温度是 $T = 300 \\text{ K}$。在进行减法之前，我们必须确保单位一致。我们将熵项的单位从卡路里转换为千卡。\n$$\n1 \\text{ kcal} = 1000 \\text{ cal}\n$$\n所以，熵变为：\n$$\n-\\Delta S_{\\text{exc}} = +10 \\text{ cal mol}^{-1} \\text{ K}^{-1} = +10 \\times 10^{-3} \\text{ kcal mol}^{-1} \\text{ K}^{-1} = 0.010 \\text{ kcal mol}^{-1} \\text{ K}^{-1}\n$$\n现在，我们计算对自由能的全部熵贡献 $T(-\\Delta S_{\\text{exc}})$：\n$$\nT(-\\Delta S_{\\text{exc}}) = (300 \\text{ K}) \\times (0.010 \\text{ kcal mol}^{-1} \\text{ K}^{-1}) = 3.0 \\text{ kcal/mol}\n$$\n最后，我们计算置换过程的总自由能变化：\n$$\n\\Delta G_{\\text{displacement}} = 8 \\text{ kcal/mol} - 3.0 \\text{ kcal/mol} = 5.0 \\text{ kcal/mol}\n$$\n$\\Delta G_{\\text{displacement}}$ 的正号表明置换这个特定的水分子在热力学上是不利的。这是预料之中的，因为该水分子处于一个低焓、高度稳定的状态（一个“快乐”的水分子），并且将其释放到本体溶剂中所获得的熵增不足以克服破坏其在口袋中有利相互作用所带来的巨大焓罚。\n\n问题要求答案四舍五入到四位有效数字。\n$$\n\\Delta G_{\\text{displacement}} = 5.000 \\text{ kcal/mol}\n$$",
            "answer": "$$\n\\boxed{5.000}\n$$"
        },
        {
            "introduction": "在从单个水分子的视角扩展到整个结合口袋的分析后，下一个关键步骤是量化整个区域的溶剂化特性。本练习将教授一项核心的计算技能：如何处理来自网格非均匀溶剂化理论（GIST）的原始输出数据，通过数值积分计算一个指定口袋区域的总溶剂化自由能。掌握这项技能对于定量评估和优先排序潜在的药物结合位点至关重要。",
            "id": "3864113",
            "problem": "您将获得来自网格非均匀溶剂化理论 (GIST) 的溶剂体积热力学场，用于大分子表面的显式溶剂映射。这些场是焓密度 $h(\\mathbf{r})$ 和熵密度 $s(\\mathbf{r})$，均按单位体积定义。您还将获得一个温度 $T$ 和一个由轴对齐边界定义的矩形口袋区域。假设使用均匀的笛卡尔网格，其间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$，原点位于 $(0,0,0)$。整数索引为 $(i,j,k)$ 的体素的中心位于 $\\left((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y, (k+\\tfrac{1}{2})\\Delta z\\right)$。一个体素被包含在口袋区域内的充要条件是其中心位于每个边界的闭区间内。所有焓密度值 $h$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，所有熵密度值 $s$ 的单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$，温度 $T$ 的单位为 $\\mathrm{K}$，所有网格间距的单位为 $\\mathrm{nm}$。您的任务是通过在网格上进行数值积分，计算与口袋区域相关的净自由能。\n\n您的推理应基于恒温恒压下 Gibbs 自由能 $G$ 的定义、体积密度的含义以及 Riemann 和离散化。您的算法必须：\n- 使用基本热力学定义，推导出将被积函数，该函数将给定的密度与局部自由能密度场联系起来，\n- 通过对中心落在指定区域内的所有体素的贡献求和，在该区域上执行离散数值积分，\n- 以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位返回总自由能。\n\n将每个最终结果表示为一个浮点数，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，并四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表（例如，$[\\texttt{result1},\\texttt{result2},\\texttt{result3}]$）。\n\n测试套件：\n对于下方的每个测试用例，请实现指定的网格、场、温度和区域。使用上面定义的包含规则。为简洁起见，当一个场为常数时，它适用于所有网格点；否则，将按体素索引明确给出值。\n\n- 测试用例 1（正常路径，均匀场）：\n  - 网格形状：$2 \\times 2 \\times 2$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h(\\mathbf{r}) \\equiv 2.0\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s(\\mathbf{r}) \\equiv 0.005\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 1.0]$（单位均为 $\\mathrm{nm}$）。\n\n- 测试用例 2（各向异性间距，非均匀场）：\n  - 网格形状：$2 \\times 2 \\times 1$。\n  - 间距：$\\Delta x = 0.2\\ \\mathrm{nm}$，$\\Delta y = 0.25\\ \\mathrm{nm}$，$\\Delta z = 0.4\\ \\mathrm{nm}$。\n  - 温度：$T = 310\\ \\mathrm{K}$。\n  - 焓密度 $h_{i,j,k}$，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$：\n    - $h_{0,0,0} = 1.0$, $h_{0,1,0} = 2.0$, $h_{1,0,0} = 3.0$, $h_{1,1,0} = 4.0$。\n  - 熵密度 $s_{i,j,k}$，单位为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$：\n    - $s_{0,0,0} = 0.002$, $s_{0,1,0} = 0.000$, $s_{1,0,0} = 0.004$, $s_{1,1,0} = 0.001$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 0.4]$。\n\n- 测试用例 3（空区域边界条件）：\n  - 网格形状：$2 \\times 2 \\times 2$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h(\\mathbf{r}) \\equiv 1.0\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s(\\mathbf{r}) \\equiv 0.001\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [10.0, 11.0]$，$y \\in [10.0, 11.0]$，$z \\in [10.0, 11.0]$。\n\n- 测试用例 4（单体素，强有利溶剂化，负自由能）：\n  - 网格形状：$1 \\times 1 \\times 1$。\n  - 间距：$\\Delta x = \\Delta y = \\Delta z = 0.5\\ \\mathrm{nm}$。\n  - 温度：$T = 300\\ \\mathrm{K}$。\n  - 焓密度：$h_{0,0,0} = 0.1\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 熵密度：$s_{0,0,0} = 0.010\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$。\n  - 口袋边界：$x \\in [0.0, 1.0]$，$y \\in [0.0, 1.0]$，$z \\in [0.0, 1.0]$。\n\n您的程序应为每个测试用例计算自由能，并以 $[\\texttt{v1},\\texttt{v2},\\texttt{v3},\\texttt{v4}]$ 的精确格式打印单行输出，其中每个 $\\texttt{v}$ 是如上所述以 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}$ 为单位的四舍五入值。",
            "solution": "该问题要求计算在一个指定的矩形空间区域（称为“口袋”）内的总 Gibbs 自由能 $G_{pocket}$。我们在一个离散的笛卡尔网格上获得了焓 $h(\\mathbf{r})$ 和熵 $s(\\mathbf{r})$ 的体积密度场，以及一个恒定温度 $T$。解决方案将从基本热力学原理推导得出，并实现为对落入口袋区域内的网格体素进行的数值积分。\n\n首先，我们建立理论基础。在恒定温度 $T$ 下，Gibbs 自由能 $G$ 与焓 $H$ 和熵 $S$ 的关系由以下方程给出：\n$$G = H - TS$$\n这种关系也适用于它们相应的体积密度。令 $g(\\mathbf{r})$、$h(\\mathbf{r})$ 和 $s(\\mathbf{r})$ 分别表示在空间位置 $\\mathbf{r}$ 处每单位体积的 Gibbs 自由能、焓和熵。因此，局部自由能密度由下式给出：\n$$g(\\mathbf{r}) = h(\\mathbf{r}) - T s(\\mathbf{r})$$\n所提供的单位在此计算中是一致的。焓密度 $h(\\mathbf{r})$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，熵密度 $s(\\mathbf{r})$ 的单位是 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}$，温度 $T$ 的单位是 $\\mathrm{K}$。因此，乘积 $T s(\\mathbf{r})$ 的单位是 $(\\mathrm{K}) \\times (\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}\\,\\mathrm{nm}^{-3}) = \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$，这与 $h(\\mathbf{r})$ 的单位相匹配。所以，自由能密度 $g(\\mathbf{r})$ 的单位正确地表示为 $\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}$。\n\n口袋体积 $V_p$ 内的总自由能是自由能密度在该体积上的积分：\n$$G_{pocket} = \\iiint_{V_p} g(\\mathbf{r}) \\, dV = \\iiint_{V_p} [h(\\mathbf{r}) - T s(\\mathbf{r})] \\, dV$$\n\n问题指明场是在离散网格上定义的。这个连续积分可以通过数值求和来近似，具体来说是 Riemann 和。积分域被划分为离散的体积元，即体素。每个体素对总自由能的贡献是，在该体素内一个代表点（本例中为其中心）处计算的自由能密度与该体素体积的乘积。\n\n设网格间距为 $\\Delta x$、$\\Delta y$ 和 $\\Delta z$。每个体素的体积是恒定的：\n$$\\Delta V = \\Delta x \\Delta y \\Delta z$$\n具有整数索引 $(i, j, k)$ 的体素的中心位于坐标 $\\mathbf{r}_{i,j,k} = \\left((i+\\tfrac{1}{2})\\Delta x, (j+\\tfrac{1}{2})\\Delta y, (k+\\tfrac{1}{2})\\Delta z\\right)$ 处。该体素的焓密度和熵密度分别记为 $h_{i,j,k}$ 和 $s_{i,j,k}$。\n\n总自由能是所有其中心位于由 $x \\in [x_{min}, x_{max}]$、$y \\in [y_{min}, y_{max}]$ 和 $z \\in [z_{min}, z_{max}]$ 定义的口袋边界内的体素的贡献之和。令 $\\mathcal{S}$ 为所有其中心位于口袋区域内的体素索引 $(i,j,k)$ 的集合。\n\n$$\n\\mathcal{S} = \\left\\{ (i,j,k) \\mid\n\\begin{array}{l}\nx_{min} \\le (i+\\tfrac{1}{2})\\Delta x \\le x_{max} \\\\\ny_{min} \\le (j+\\tfrac{1}{2})\\Delta y \\le y_{max} \\\\\nz_{min} \\le (k+\\tfrac{1}{2})\\Delta z \\le z_{max}\n\\end{array}\n\\right\\}\n$$\n\n总口袋自由能 $G_{pocket}$ 随后通过对集合 $\\mathcal{S}$ 中的每个体素的贡献求和来计算：\n$$G_{pocket} \\approx \\sum_{(i,j,k) \\in \\mathcal{S}} [h_{i,j,k} - T s_{i,j,k}] \\cdot \\Delta V$$\n其中 $G_{pocket}$ 的单位将是 $(\\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{nm}^{-3}) \\times (\\mathrm{nm}^3) = \\mathrm{kJ}\\,\\mathrm{mol}^{-1}$，符合要求。\n\n要实现的算法如下：\n1. 对于给定的测试用例，定义网格维度（$N_x, N_y, N_z$）、网格间距（$\\Delta x, \\Delta y, \\Delta z$）、温度（$T$）、口袋边界以及网格化的焓（$h_{i,j,k}$）和熵（$s_{i,j,k}$）场。\n2. 计算单个体素的体积 $\\Delta V = \\Delta x \\Delta y \\Delta z$。\n3. 初始化总自由能变量 $G_{total}$ 为 $0.0$。\n4. 遍历所有体素索引，$i$ 从 $0$ 到 $N_x-1$，$j$ 从 $0$ 到 $N_y-1$，$k$ 从 $0$ 到 $N_z-1$。\n5. 对于每个体素 $(i,j,k)$，计算其中心的坐标：$x_c = (i+0.5)\\Delta x$，$y_c = (j+0.5)\\Delta y$，$z_c = (k+0.5)\\Delta z$。\n6. 检查中心 $(x_c, y_c, z_c)$ 是否落在口袋边界的闭区间内。\n7. 如果体素在口袋区域内，计算其对自由能的贡献：$\\Delta G_{i,j,k} = (h_{i,j,k} - T s_{i,j,k}) \\times \\Delta V$。\n8. 将此贡献加到运行总和中：$G_{total} = G_{total} + \\Delta G_{i,j,k}$。\n9. 遍历所有体素后，$G_{total}$ 的最终值即为该测试用例的结果。然后将此值四舍五入到六位小数。\n此过程将应用于所提供的每个测试用例。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the net free energy for several test cases based on GIST fields.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"grid_shape\": (2, 2, 2),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((2, 2, 2), 2.0),\n            \"s_field\": np.full((2, 2, 2), 0.005),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 1.0))\n        },\n        {\n            \"grid_shape\": (2, 2, 1),\n            \"spacings\": (0.2, 0.25, 0.4),\n            \"T\": 310.0,\n            \"h_field\": np.array([\n                [[1.0], [2.0]], # i=0, j=0,1 ; k=0\n                [[3.0], [4.0]]  # i=1, j=0,1 ; k=0\n            ]),\n            \"s_field\": np.array([\n                [[0.002], [0.000]],\n                [[0.004], [0.001]]\n            ]),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 0.4))\n        },\n        {\n            \"grid_shape\": (2, 2, 2),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((2, 2, 2), 1.0),\n            \"s_field\": np.full((2, 2, 2), 0.001),\n            \"pocket_bounds\": ((10.0, 11.0), (10.0, 11.0), (10.0, 11.0))\n        },\n        {\n            \"grid_shape\": (1, 1, 1),\n            \"spacings\": (0.5, 0.5, 0.5),\n            \"T\": 300.0,\n            \"h_field\": np.full((1, 1, 1), 0.1),\n            \"s_field\": np.full((1, 1, 1), 0.010),\n            \"pocket_bounds\": ((0.0, 1.0), (0.0, 1.0), (0.0, 1.0))\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = calculate_pocket_energy(\n            grid_shape=case[\"grid_shape\"],\n            spacings=case[\"spacings\"],\n            T=case[\"T\"],\n            h_field=case[\"h_field\"],\n            s_field=case[\"s_field\"],\n            pocket_bounds=case[\"pocket_bounds\"]\n        )\n        results.append(f\"{result:.6f}\")\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_pocket_energy(grid_shape, spacings, T, h_field, s_field, pocket_bounds):\n    \"\"\"\n    Calculates the free energy of a pocket by integrating over GIST fields.\n\n    Args:\n        grid_shape (tuple): The dimensions (Nx, Ny, Nz) of the grid.\n        spacings (tuple): The grid spacings (dx, dy, dz) in nm.\n        T (float): The temperature in K.\n        h_field (np.ndarray): The 3D enthalpy density field in kJ/mol/nm^3.\n        s_field (np.ndarray): The 3D entropy density field in kJ/mol/K/nm^3.\n        pocket_bounds (tuple): The pocket region as ((xmin, xmax), (ymin, ymax), (zmin, zmax)).\n\n    Returns:\n        float: The total free energy of the pocket in kJ/mol.\n    \"\"\"\n    Nx, Ny, Nz = grid_shape\n    dx, dy, dz = spacings\n    (xmin, xmax), (ymin, ymax), (zmin, zmax) = pocket_bounds\n    \n    # Calculate the volume of a single voxel\n    dV = dx * dy * dz\n    \n    total_free_energy = 0.0\n    \n    for i in range(Nx):\n        for j in range(Ny):\n            for k in range(Nz):\n                # Calculate the center of the voxel (i, j, k)\n                xc = (i + 0.5) * dx\n                yc = (j + 0.5) * dy\n                zc = (k + 0.5) * dz\n                \n                # Check if the voxel center is within the pocket bounds\n                if (xmin = xc = xmax) and \\\n                   (ymin = yc = ymax) and \\\n                   (zmin = zc = zmax):\n                    \n                    # Retrieve the enthalpy and entropy densities for this voxel\n                    h_ijk = h_field[i, j, k]\n                    s_ijk = s_field[i, j, k]\n                    \n                    # Calculate the free energy density g = h - T*s\n                    g_ijk = h_ijk - T * s_ijk\n                    \n                    # Add this voxel's contribution to the total free energy\n                    total_free_energy += g_ijk * dV\n                    \n    return total_free_energy\n\nsolve()\n```"
        },
        {
            "introduction": "蛋白质并非静止不变的实体，其动态特性深刻影响着结合位点的形状和化学环境。本项高级练习将静态的热点分析提升到动态的系综层面，展示了如何将描述蛋白质构象动力学的马尔可夫状态模型（MSM）与每个状态下的溶剂作图数据相结合。通过计算平衡系综平均下的热点强度，我们可以获得一个更真实、更强大的药物设计指导视图，这反映了分子识别过程的内在复杂性。",
            "id": "3864027",
            "problem": "给定一个口袋构象的离散时间马尔可夫状态模型 (MSM) 以及在每个状态的网格上由溶剂映射得出的探针相互作用自由能。目标是计算特定于状态的热点强度及其平衡加权聚合值。设计必须从第一性原理出发，明确使用玻尔兹曼分布计算占据率和马尔可夫链的平稳分布。\n\n定义和基本原理：\n- 一个马尔可夫状态模型 (MSM) 由一个行随机转移矩阵 $P \\in \\mathbb{R}^{n \\times n}$ 定义，该模型包含 $n$ 个亚稳态口袋构象状态。其中每个条目 $P_{ij}$ 是从状态 $i$ 转换到状态 $j$ 的单步概率，且对所有 $i$ 满足 $\\sum_{j=1}^{n} P_{ij} = 1$。\n- 马尔可夫链的平稳分布 $\\boldsymbol{\\pi} \\in \\mathbb{R}^{n}$ 满足 $\\boldsymbol{\\pi}^{\\top} = \\boldsymbol{\\pi}^{\\top} P$ 和 $\\sum_{i=1}^{n} \\pi_i = 1$，且对所有 $i$ 都有 $\\pi_i \\geq 0$。\n- 对于每个状态 $s \\in \\{1,\\dots,n\\}$，溶剂映射提供了一组在 $m_s$ 个不同网格点上的探针相互作用自由能 $\\{\\Delta G_{s,i}\\}_{i=1}^{m_s}$。这些能量以千焦/摩尔 (kJ/mol) 表示。\n- 玻尔兹曼分布给出了在状态 $s$ 中，探针在网格点 $i$ 的相对占据率，其与 $\\exp(-\\beta \\Delta G_{s,i})$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$，$T$ 是以开尔文 (K) 为单位的绝对温度，$k_{\\mathrm{B}}$ 是以千焦/摩尔/开尔文 (kJ/mol/K) 表示的玻尔兹曼常数。\n- 状态 $s$ 内的归一化占据概率为 $p_{s,i} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{\\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})}$，它们满足 $\\sum_{i=1}^{m_s} p_{s,i} = 1$。\n- 在本问题中，热点在操作上定义为在给定状态下，其占据概率超过阈值 $\\tau \\in (0,1)$ 的网格点集合。特定于状态的热点强度是超过阈值的累积占据概率质量：$H_s(\\tau) = \\sum_{i=1}^{m_s} p_{s,i} \\cdot \\mathbf{1}\\{p_{s,i} \\ge \\tau\\}$，其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。\n- 平衡加权聚合热点强度为 $H_{\\mathrm{eq}}(\\tau) = \\sum_{s=1}^{n} \\pi_s \\, H_s(\\tau)$。\n\n任务：\n- 对每个测试用例，计算所有状态 $s$ 的 $H_s(\\tau)$，然后使用给定转移矩阵 $P$ 的平稳分布 $\\boldsymbol{\\pi}$ 计算 $H_{\\mathrm{eq}}(\\tau)$。\n\n物理和数值单位：\n- 能量 $\\Delta G_{s,i}$ 以 kJ/mol 为单位。\n- 温度 $T$ 以开尔文 (K) 为单位。\n- 使用 $k_{\\mathrm{B}} = 0.008314462618\\ \\mathrm{kJ}\\,\\mathrm{mol}^{-1}\\,\\mathrm{K}^{-1}$。\n- 热点强度 $H_s(\\tau)$ 和 $H_{\\mathrm{eq}}(\\tau)$ 是无单位的（无量纲概率）。\n- 将所有输出表示为保留六位小数的浮点数（即小数点后有六位数字）。不涉及角度。任何地方都不要使用百分比；请使用小数。\n\n测试套件：\n对于每个测试用例，您将获得：\n- 一个行随机转移矩阵 $P$。\n- 一个能量数组列表，其中第 $s$ 个数组指定了 $\\{\\Delta G_{s,i}\\}_{i=1}^{m_s}$。\n- 一个以开尔文为单位的温度 $T$。\n- 一个阈值 $\\tau$。\n\n计算所有状态 $s$ 的每个状态的热点强度 $H_s(\\tau)$ 和 $H_{\\mathrm{eq}}(\\tau)$。\n\n测试用例 1（正常路径，三个亚稳态，异构能量）：\n- $P = \\begin{bmatrix}\n0.90  0.09  0.01 \\\\\n0.05  0.90  0.05 \\\\\n0.02  0.08  0.90\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{-4.0, -2.5, -1.0, 0.5, 3.0\\}$ kJ/mol\n  - 状态 2：$\\{-1.5, -1.0, -0.5, 0.0, 1.0\\}$ kJ/mol\n  - 状态 3：$\\{-5.0, -3.0, -2.0, -1.0, 2.0\\}$ kJ/mol\n- $T = 300$ K\n- $\\tau = 0.20$\n\n测试用例 2（边界情况，一个状态中能量均一，近吸收动力学）：\n- $P = \\begin{bmatrix}\n0.98  0.02 \\\\\n0.03  0.97\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{0.0, 0.0, 0.0, 0.0\\}$ kJ/mol\n  - 状态 2：$\\{-2.0, -2.0, -2.0, -2.0\\}$ kJ/mol\n- $T = 310$ K\n- $\\tau = 0.25$\n\n测试用例 3（边界覆盖，四个状态具有尖锐和弥散的热点）：\n- $P = \\begin{bmatrix}\n0.85  0.10  0.03  0.02 \\\\\n0.06  0.80  0.10  0.04 \\\\\n0.05  0.15  0.75  0.05 \\\\\n0.02  0.08  0.10  0.80\n\\end{bmatrix}$\n- 能量：\n  - 状态 1：$\\{-6.0, -1.0, 2.0, 4.0, -0.5\\}$ kJ/mol\n  - 状态 2：$\\{-0.2, -0.1, 0.0, 0.1, 0.2\\}$ kJ/mol\n  - 状态 3：$\\{-3.0, -2.9, -2.8, 3.0, 4.0\\}$ kJ/mol\n  - 状态 4：$\\{-1.0, 1.0, 2.0, -0.5, -0.2\\}$ kJ/mol\n- $T = 290$ K\n- $\\tau = 0.30$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含所有测试用例的连接结果，形式为方括号内的逗号分隔列表。\n- 对每个测试用例，按状态索引顺序输出每个状态的热点强度 $H_s(\\tau)$，然后是平衡聚合值 $H_{\\mathrm{eq}}(\\tau)$，所有值均保留六位小数。\n- 具体来说，如果测试用例 1 有 $n_1$ 个状态，测试用例 2 有 $n_2$ 个状态，测试用例 3 有 $n_3$ 个状态，则输出格式为 $[H_{1,1}, \\dots, H_{1,n_1}, H_{1,\\mathrm{eq}}, H_{2,1}, \\dots, H_{2,n_2}, H_{2,\\mathrm{eq}}, H_{3,1}, \\dots, H_{3,n_3}, H_{3,\\mathrm{eq}}]$，其中第一个索引表示测试用例，第二个索引表示状态。",
            "solution": "该问题是有效的，因为它在科学上基于统计力学和马尔可夫链理论的原理，定义明确，提供了所有必要信息，并且其定义和目标是客观的。任务是基于蛋白质口袋构象的马尔可夫状态模型 (MSM) 及相关的溶剂-探针相互作用能，计算特定于状态的热点强度和平衡加权热点强度。\n\n对于每个测试用例，该解决方案算法上分为三个主要步骤，这些步骤基于所提供的基本原理。\n\n**步骤 1：计算平稳分布 ($\\boldsymbol{\\pi}$)**\n\nMSM 平衡分析的基础是其平稳分布 $\\boldsymbol{\\pi}$。这个向量 $\\boldsymbol{\\pi} = (\\pi_1, \\pi_2, \\dots, \\pi_n)$ 列出了系统处于 $n$ 个构象状态中每一个的平衡概率。它的定义是，在转移矩阵 $P$ 的作用下它保持不变。在数学上，这表示为左特征向量方程：\n$$ \\boldsymbol{\\pi}^{\\top} P = \\boldsymbol{\\pi}^{\\top} $$\n这个方程，连同归一化条件 $\\sum_{i=1}^{n} \\pi_i = 1$，对于一个不可约且非周期的马尔可夫链（给定的转移矩阵即代表此类链），唯一地确定了 $\\boldsymbol{\\pi}$。\n\n为了求解 $\\boldsymbol{\\pi}$，我们可以将方程重写为 $\\boldsymbol{\\pi}^{\\top} (P - I) = \\mathbf{0}^{\\top}$，其中 $I$ 是单位矩阵，$\\mathbf{0}$ 是零向量。对其进行转置得到 $(P^{\\top} - I) \\boldsymbol{\\pi} = \\mathbf{0}$。这意味着 $\\boldsymbol{\\pi}$ 是转置矩阵 $P^{\\top}$ 对应于特征值 $\\lambda=1$ 的右特征向量。在数值上，这是一个标准且可以稳健求解的特征值问题。我们找到该特征向量，取其实部（因为平稳分布必须是实数），并将其归一化，使其元素之和为 1。\n\n**步骤 2：计算特定于状态的热点强度 ($H_s(\\tau)$)**\n\n对于每个构象状态 $s$，我们都有一组在不同网格点 $i$ 上的探针相互作用自由能 $\\{\\Delta G_{s,i}\\}$。探针在特定网格点上的占据情况受玻尔兹曼统计原理的支配。探针在状态 $s$ 内占据网格点 $i$ 的概率 $p_{s,i}$ 与其玻尔兹曼因子 $\\exp(-\\beta \\Delta G_{s,i})$ 成正比，其中 $\\beta = 1/(k_{\\mathrm{B}} T)$ 是逆热能。\n\n为了获得每个状态的有效概率分布，我们通过将这些因子除以该状态内所有网格点上的因子之和来进行归一化。这个和 $Z_s = \\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})$ 是探针在状态 $s$ 的口袋内的配分函数。因此，归一化的占据概率是：\n$$ p_{s,i} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{Z_s} = \\frac{\\exp(-\\beta \\Delta G_{s,i})}{\\sum_{j=1}^{m_s} \\exp(-\\beta \\Delta G_{s,j})} $$\n在数值计算上，为了在计算大的负能量的指数时避免溢出，一种标准技术是使用 log-sum-exp 稳定化。我们计算 $L_{s,i} = -\\beta \\Delta G_{s,i}$，找到 $L_{s,\\max} = \\max_i L_{s,i}$，然后按如下方式计算概率：\n$$ p_{s,i} = \\frac{\\exp(L_{s,i} - L_{s,\\max})}{\\sum_{j=1}^{m_s} \\exp(L_{s,j} - L_{s,\\max})} $$\n这种变换可以防止数值溢出，同时得到相同的最终概率。\n\n根据问题的定义，热点由占据概率 $p_{s,i}$ 达到或超过给定阈值 $\\tau$ 的网格点组成。特定于状态的热点强度 $H_s(\\tau)$ 是这些热点网格点的总概率质量：\n$$ H_s(\\tau) = \\sum_{i=1}^{m_s} p_{s,i} \\cdot \\mathbf{1}\\{p_{s,i} \\ge \\tau\\} $$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数，如果内部条件为真，则为 1，否则为 0。\n\n**步骤 3：计算平衡加权聚合热点强度 ($H_{\\mathrm{eq}}(\\tau)$)**\n\n系统的总体或平衡属性是所有状态的平均值，并按其平衡布居数 $\\pi_s$ 加权。因此，聚合热点强度 $H_{\\mathrm{eq}}(\\tau)$ 是通过对平稳分布 $\\boldsymbol{\\pi}$ 上的特定于状态的热点强度 $H_s(\\tau)$ 求期望来计算的：\n$$ H_{\\mathrm{eq}}(\\tau) = \\sum_{s=1}^{n} \\pi_s H_s(\\tau) $$\n这个最终值代表了在热平衡下，构象系综平均的总热点概率质量。\n\n通过为每个测试用例实施这三个步骤，我们可以计算出所需的量。该过程综合地结合了线性代数、统计力学和概率论的原理，以模拟计算药物设计中的一个物理相关问题。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Computes state-specific and equilibrium-weighted hotspot strengths for\n    a series of Markov State Models and associated solvent-mapping energies.\n    \"\"\"\n    \n    # Define physical constants and test cases from the problem statement.\n    K_B = 0.008314462618  # Boltzmann constant in kJ/mol/K\n\n    test_cases = [\n        (\n            np.array([\n                [0.90, 0.09, 0.01],\n                [0.05, 0.90, 0.05],\n                [0.02, 0.08, 0.90]\n            ]),\n            [\n                np.array([-4.0, -2.5, -1.0, 0.5, 3.0]),\n                np.array([-1.5, -1.0, -0.5, 0.0, 1.0]),\n                np.array([-5.0, -3.0, -2.0, -1.0, 2.0])\n            ],\n            300.0,\n            0.20\n        ),\n        (\n            np.array([\n                [0.98, 0.02],\n                [0.03, 0.97]\n            ]),\n            [\n                np.array([0.0, 0.0, 0.0, 0.0]),\n                np.array([-2.0, -2.0, -2.0, -2.0])\n            ],\n            310.0,\n            0.25\n        ),\n        (\n            np.array([\n                [0.85, 0.10, 0.03, 0.02],\n                [0.06, 0.80, 0.10, 0.04],\n                [0.05, 0.15, 0.75, 0.05],\n                [0.02, 0.08, 0.10, 0.80]\n            ]),\n            [\n                np.array([-6.0, -1.0, 2.0, 4.0, -0.5]),\n                np.array([-0.2, -0.1, 0.0, 0.1, 0.2]),\n                np.array([-3.0, -2.9, -2.8, 3.0, 4.0]),\n                np.array([-1.0, 1.0, 2.0, -0.5, -0.2])\n            ],\n            290.0,\n            0.30\n        )\n    ]\n\n    all_results = []\n\n    def compute_stationary_distribution(p_matrix):\n        \"\"\"\n        Calculates the stationary distribution of a Markov chain.\n        The stationary distribution pi satisfies pi^T * P = pi^T.\n        This is equivalent to finding the right eigenvector of P^T\n        for the eigenvalue 1.\n        \"\"\"\n        eigenvalues, eigenvectors = linalg.eig(p_matrix.T)\n        # Find the index of the eigenvalue that is close to 1.0\n        # This handles potential floating point inaccuracies.\n        idx = np.where(np.isclose(eigenvalues, 1.0))[0][0]\n        # The eigenvector is complex, take the real part.\n        pi_unnormalized = eigenvectors[:, idx].real\n        # Normalize to ensure it's a probability distribution (sums to 1).\n        pi = pi_unnormalized / np.sum(pi_unnormalized)\n        return pi\n\n    for case in test_cases:\n        p_matrix, energies_list, temp, threshold = case\n        n_states = p_matrix.shape[0]\n\n        # Step 1: Calculate the stationary distribution\n        pi = compute_stationary_distribution(p_matrix)\n\n        # Step 2: Calculate state-specific hotspot strengths\n        h_s_list = []\n        beta = 1.0 / (K_B * temp)\n        \n        for s in range(n_states):\n            delta_g_s = energies_list[s]\n            \n            # Calculate Boltzmann factors and probabilities using a\n            # numerically stable method (log-sum-exp trick) to prevent overflow.\n            log_weights = -beta * delta_g_s\n            # Shift by the max value to keep exponents in a small range\n            log_weights_shifted = log_weights - np.max(log_weights)\n            weights = np.exp(log_weights_shifted)\n            probs = weights / np.sum(weights)\n\n            # A hotspot comprises points with occupancy probability >= threshold.\n            # The hotspot strength is the sum of these probabilities.\n            h_s = np.sum(probs[probs >= threshold])\n            h_s_list.append(h_s)\n\n        # Step 3: Calculate the equilibrium-weighted aggregate hotspot strength\n        h_eq = np.sum(pi * np.array(h_s_list))\n        \n        # Collect results for this case\n        all_results.extend(h_s_list)\n        all_results.append(h_eq)\n\n    # Format the final output string as required.\n    # Each value is a float rounded to six decimal places.\n    output_str = \",\".join([f\"{r:.6f}\" for r in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```"
        }
    ]
}