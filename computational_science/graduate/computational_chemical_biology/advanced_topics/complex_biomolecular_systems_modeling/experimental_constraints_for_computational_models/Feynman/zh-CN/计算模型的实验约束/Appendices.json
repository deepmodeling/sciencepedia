{
    "hands_on_practices": [
        {
            "introduction": "在我们将实验数据用于约束或验证计算模型之前，首先必须确保数据本身是内部一致的。本练习将通过一个热力学循环来演示一个基本原则，其中赫斯定律 (Hess's Law) 指出，围绕一个闭合回路的净自由能变化必须为零 。通过应用这一定律和误差传播原理，您将学习如何检查多个独立测量值之间的统计一致性，以及如何推导出缺失测量值的最可能值。",
            "id": "3845656",
            "problem": "一种蛋白质 $P$ 在标准态 ($1\\,\\mathrm{M}$) 和 $T=298.15\\,\\mathrm{K}$ 的条件下，依次与两个配体 $L_{1}$ 和 $L_{2}$ 结合，形成复合物 $PL_{1}$、$PL_{2}$ 和 $PL_{1}L_{2}$。通过等温滴定热法（ITC）和表面等离子共振（SPR）测得的标准结合吉布斯自由能及其估计的标准不确定度（一个标准差）已给出，此外，一个额外的三组分量热实验提供了从 $P+L_{1}+L_{2}$ 直接形成 $PL_{1}L_{2}$ 的总标准自由能。测量结果如下：\n- $P + L_{1} \\rightarrow PL_{1}$：$\\Delta G_{A\\to B} = -35.4\\,\\mathrm{kJ\\, mol^{-1}}$，不确定度 $\\sigma_{AB} = 0.7\\,\\mathrm{kJ\\, mol^{-1}}$（ITC）。\n- $PL_{1} + L_{2} \\rightarrow PL_{1}L_{2}$：$\\Delta G_{B\\to D} = -18.6\\,\\mathrm{kJ\\, mol^{-1}}$，不确定度 $\\sigma_{BD} = 0.9\\,\\mathrm{kJ\\, mol^{-1}}$（ITC）。\n- $P + L_{2} \\rightarrow PL_{2}$：$\\Delta G_{A\\to C} = -14.2\\,\\mathrm{kJ\\, mol^{-1}}$，不确定度 $\\sigma_{AC} = 0.5\\,\\mathrm{kJ\\, mol^{-1}}$（SPR）。\n- $P + L_{1} + L_{2} \\rightarrow PL_{1}L_{2}$：$\\Delta G_{A\\to D} = -53.0\\,\\mathrm{kJ\\, mol^{-1}}$，不确定度 $\\sigma_{AD} = 1.4\\,\\mathrm{kJ\\, mol^{-1}}$（三组分量热法）。\n\n假设吉布斯自由能是一个状态函数，并且盖斯定律适用于由这些状态形成的任何热力学循环。将报告的不确定度视为独立的高斯分布，并使用反方差加权对结合网络的计算模型施加实验约束。\n\n首先，利用状态函数的性质评估直接测量值 $\\Delta G_{A\\to D}$ 是否与两步路径 $A\\to B\\to D$ 在统计上一致。然后，利用盖斯定律闭合路径 $A\\to C\\to D$，在一个强制 $A\\to B\\to D$ 与 $A\\to D$ 匹配的加权最小二乘调整下，推断出与所有测量值最一致的缺失的标准吉布斯自由能 $\\Delta G_{C\\to D}$。将最终推断的 $\\Delta G_{C\\to D}$ 以 $\\mathrm{kJ\\, mol^{-1}}$ 为单位表示，并将您的答案四舍五入到四位有效数字。",
            "solution": "该问题要求分析蛋白质-配体结合的热力学网络，并利用一组冗余、不确定的实验测量数据来推断一个缺失的热力学量。分析将按要求分两部分进行：首先，评估所提供数据的统计一致性；其次，使用加权最小二乘调整法，计算未知吉布斯自由能变化 $\\Delta G_{C\\to D}$ 的最一致值。\n\n该结合方案描述了一个连接四个状态的热力学循环：\n- 状态A：$P + L_{1} + L_{2}$\n- 状态B：$PL_{1} + L_{2}$\n- 状态C：$PL_{2} + L_{1}$\n- 状态D：$PL_{1}L_{2}$\n\n提供的标准吉布斯自由能变化（$\\Delta G^\\circ$）及其标准不确定度（$\\sigma$）如下：\n- $\\Delta G_{A\\to B} = -35.4\\,\\mathrm{kJ\\, mol^{-1}}$，$\\sigma_{AB} = 0.7\\,\\mathrm{kJ\\, mol^{-1}}$\n- $\\Delta G_{B\\to D} = -18.6\\,\\mathrm{kJ\\, mol^{-1}}$，$\\sigma_{BD} = 0.9\\,\\mathrm{kJ\\, mol^{-1}}$\n- $\\Delta G_{A\\to C} = -14.2\\,\\mathrm{kJ\\, mol^{-1}}$，$\\sigma_{AC} = 0.5\\,\\mathrm{kJ\\, mol^{-1}}$\n- $\\Delta G_{A\\to D} = -53.0\\,\\mathrm{kJ\\, mol^{-1}}$，$\\sigma_{AD} = 1.4\\,\\mathrm{kJ\\, mol^{-1}}$\n\n控制该系统的基本原理是盖斯定律，该定律指出，由于吉布斯自由能是状态函数，两个状态之间的总自由能变化与所走的路径无关。这意味着对于任何闭合循环，自由能的净变化必须为零。对于方形循环 $A \\to B \\to D \\to C \\to A$，这意味着真实（无误差）值必须满足 $\\Delta G_{A\\to B} + \\Delta G_{B\\to D} + \\Delta G_{D\\to C} + \\Delta G_{C\\to A} = 0$。由于 $\\Delta G_{D\\to C} = -\\Delta G_{C\\to D}$ 且 $\\Delta G_{C\\to A} = -\\Delta G_{A\\to C}$，这等价于路径无关条件：\n$$ \\Delta G_{A\\to B} + \\Delta G_{B\\to D} = \\Delta G_{A\\to C} + \\Delta G_{C\\to D} $$\n该方程还意味着从状态A到状态D的总自由能变化 $\\Delta G_{A\\to D}$ 必须与路径无关：\n$$ \\Delta G_{A\\to D} = \\Delta G_{A\\to B} + \\Delta G_{B\\to D} $$\n$$ \\Delta G_{A\\to D} = \\Delta G_{A\\to C} + \\Delta G_{C\\to D} $$\n我们的实验数据为确定同一量值提供了多条独立的途径，这种情况被称为超定。\n\n首先，我们评估 $\\Delta G_{A\\to D}$ 的直接测量值与从两步路径 $A \\to B \\to D$ 导出的值之间的统计一致性。\n间接路径的自由能变化是各步骤之和：\n$$ \\Delta G_{A\\to B\\to D} = \\Delta G_{A\\to B} + \\Delta G_{B\\to D} = -35.4\\,\\mathrm{kJ\\, mol^{-1}} + (-18.6\\,\\mathrm{kJ\\, mol^{-1}}) = -54.0\\,\\mathrm{kJ\\, mol^{-1}} $$\n由于测量是独立的，不确定度按平方和相加（即方差相加）。间接路径的方差为：\n$$ \\sigma_{A\\to B\\to D}^2 = \\sigma_{AB}^2 + \\sigma_{BD}^2 = (0.7\\,\\mathrm{kJ\\, mol^{-1}})^2 + (0.9\\,\\mathrm{kJ\\, mol^{-1}})^2 = 0.49\\,\\mathrm{kJ^2\\, mol^{-2}} + 0.81\\,\\mathrm{kJ^2\\, mol^{-2}} = 1.30\\,\\mathrm{kJ^2\\, mol^{-2}} $$\n我们将此结果 $\\Delta G_{A\\to B\\to D} = -54.0\\,\\mathrm{kJ\\, mol^{-1}}$ 与直接测量值 $\\Delta G_{A\\to D} = -53.0\\,\\mathrm{kJ\\, mol^{-1}}$ 进行比较。差值 $\\delta$ 为：\n$$ \\delta = \\Delta G_{A\\to B\\to D} - \\Delta G_{A\\to D} = -54.0\\,\\mathrm{kJ\\, mol^{-1}} - (-53.0\\,\\mathrm{kJ\\, mol^{-1}}) = -1.0\\,\\mathrm{kJ\\, mol^{-1}} $$\n这个差值的方差是这两个量的方差之和，因为它们来自独立的实验组：\n$$ \\sigma_{\\delta}^2 = \\sigma_{A\\to B\\to D}^2 + \\sigma_{AD}^2 = 1.30\\,\\mathrm{kJ^2\\, mol^{-2}} + (1.4\\,\\mathrm{kJ\\, mol^{-1}})^2 = 1.30\\,\\mathrm{kJ^2\\, mol^{-2}} + 1.96\\,\\mathrm{kJ^2\\, mol^{-2}} = 3.26\\,\\mathrm{kJ^2\\, mol^{-2}} $$\n差值的标准差为 $\\sigma_{\\delta} = \\sqrt{3.26}\\,\\mathrm{kJ\\, mol^{-1}} \\approx 1.806\\,\\mathrm{kJ\\, mol^{-1}}$。\n为了评估统计一致性，我们计算z-分数，它以其标准差为单位来衡量差异：\n$$ z = \\frac{|\\delta|}{\\sigma_{\\delta}} = \\frac{|-1.0\\,\\mathrm{kJ\\, mol^{-1}}|}{1.806\\,\\mathrm{kJ\\, mol^{-1}}} \\approx 0.55 $$\n由于 $z \\ll 2$，$\\Delta G_{A\\to D}$ 的直接测量值和间接测量值之间的差异不具有统计显著性。在报告的不确定度范围内，这些测量值是相互一致的。\n\n接下来，我们推断与所有测量值最一致的 $\\Delta G_{C\\to D}$ 值。这需要结合冗余信息以获得 $\\Delta G_{A\\to D}$ 的单一最佳估计值，我们将其表示为 $\\Delta G_{A\\to D}^*$。这就是“强制 $A\\to B\\to D$ 与 $A\\to D$ 匹配的加权最小二乘调整”。对于独立的高斯不确定度，最优组合是反方差加权平均，即最大似然估计量。\n\n我们有两个关于 $\\Delta G_{A\\to D}$ 的独立估计值：\n1. 来自路径 $A \\to B \\to D$：$x_1 = \\Delta G_{A\\to B\\to D} = -54.0\\,\\mathrm{kJ\\, mol^{-1}}$，方差为 $v_1 = \\sigma_{A\\to B\\to D}^2 = 1.30\\,\\mathrm{kJ^2\\, mol^{-2}}$。\n2. 来自直接测量：$x_2 = \\Delta G_{A\\to D} = -53.0\\,\\mathrm{kJ\\, mol^{-1}}$，方差为 $v_2 = \\sigma_{AD}^2 = 1.96\\,\\mathrm{kJ^2\\, mol^{-2}}$。\n\n反方差加权平均由下式给出：\n$$ \\Delta G_{A\\to D}^* = \\frac{\\frac{x_1}{v_1} + \\frac{x_2}{v_2}}{\\frac{1}{v_1} + \\frac{1}{v_2}} $$\n代入数值：\n$$ \\Delta G_{A\\to D}^* = \\frac{\\frac{-54.0}{1.30} + \\frac{-53.0}{1.96}}{\\frac{1}{1.30} + \\frac{1}{1.96}} = \\frac{-41.53846 - 27.04082}{0.76923 + 0.51020}\\,\\mathrm{kJ\\, mol^{-1}} = \\frac{-68.57928}{1.27943}\\,\\mathrm{kJ\\, mol^{-1}} \\approx -53.6014\\,\\mathrm{kJ\\, mol^{-1}} $$\n这个协调值 $\\Delta G_{A\\to D}^*$ 代表了在给定所有相关测量值的情况下，整个 $A \\to D$ 过程最可能为真的自由能变化。\n\n最后，我们对另一条路径 $A \\to C \\to D$ 使用这个协调值和盖斯定律，来推断 $\\Delta G_{C\\to D}$ 的值。其遵循的热力学关系是：\n$$ \\Delta G_{A\\to D}^* = \\Delta G_{A\\to C} + \\Delta G_{C\\to D} $$\n我们求解 $\\Delta G_{C\\to D}$，使用我们对 $\\Delta G_{A\\to D}^*$ 的最佳估计和 $\\Delta G_{A\\to C}$ 的实验测量值，因为这是该循环分支唯一可用的信息。\n$$ \\Delta G_{C\\to D, \\text{inf}} = \\Delta G_{A\\to D}^* - \\Delta G_{A\\to C} $$\n$$ \\Delta G_{C\\to D, \\text{inf}} = -53.6014\\,\\mathrm{kJ\\, mol^{-1}} - (-14.2\\,\\mathrm{kJ\\, mol^{-1}}) = -39.4014\\,\\mathrm{kJ\\, mol^{-1}} $$\n问题要求答案四舍五入到四位有效数字。\n$$ \\Delta G_{C\\to D, \\text{inf}} \\approx -39.40\\,\\mathrm{kJ\\, mol^{-1}} $$\n在有效热力学循环的假设下，该值是与整套所提供的实验数据最一致的反应 $PL_{2} + L_{1} \\to PL_{1}L_{2}$ 的吉布斯自由能变化。",
            "answer": "$$ \\boxed{-39.40} $$"
        },
        {
            "introduction": "计算建模的一项核心任务是定量评估模型的预测是否与实验现实相符。卡方 ($\\chi^2$) 拟合优度检验为此提供了一个严谨的统计框架，它将测量不确定性考虑在内 。在本次实践中，您将实现这一检验，计算标准化残差，并判断模型与实验之间的差异是否具有统计显著性，这是模型验证和比较的一项关键技能。",
            "id": "3845717",
            "problem": "给定多个独立的实验约束数据集，用于一个预测可测量量的固定计算化学生物学模型。每个数据集包括观测值、模型预测值和估计的测量不确定度。假设每个测量误差都是独立且服从正态分布的，并且某些数据集已经使用其数据调整了模型参数的一个子集。在这些假设下，标准化残差服从标准正态分布，其平方和服从卡方分布。您的任务是实现一个完整的程序，计算每个数据集的残差、卡方检验统计量和拟合优度决策，并将这些汇总为跨数据集的全局拟合优度。\n\n使用以下基础依据：\n- 在独立测量误差被建模为具有已知标准差的正态分布的情况下，如果模型预测了潜在均值，则标准化残差 $$r_i = \\frac{y_i - m_i}{\\sigma_i}$$ 近似为来自标准正态分布的独立抽样。\n- 根据中心极限定理 (Central Limit Theorem, CLT) 和正态分布的性质，和 $$X^2 = \\sum_{i=1}^{n} r_i^2$$ 服从卡方分布，其自由度 (degrees of freedom, DoF) 为 $$\\nu = n - k,$$ 其中 $$n$$ 是数据集中独立测量的数量，$$k$$ 是使用该数据集有效拟合的模型参数数量。\n- 对于一个卡方随机变量 $$X^2 \\sim \\chi^2_{\\nu}$$，其尾部概率（拟合优度 p 值）等于 $$p = 1 - F_{\\chi^2_{\\nu}}(X^2),$$ 其中 $$F_{\\chi^2_{\\nu}}$$ 表示卡方分布的累积分布函数 (cumulative distribution function, CDF)。\n\n程序要求：\n- 对每个数据集，计算残差向量 $$\\mathbf{r} = \\left[\\frac{y_1 - m_1}{\\sigma_1}, \\ldots, \\frac{y_n - m_n}{\\sigma_n}\\right],$$ 卡方统计量 $$X^2 = \\sum_{i=1}^{n} r_i^2,$$ 自由度 $$\\nu = n - k,$$ p 值 $$p = 1 - F_{\\chi^2_{\\nu}}(X^2),$$ 以及在显著性水平 $$\\alpha$$ 下的检验决策，定义为 $$\\text{pass} = (p \\ge \\alpha).$$\n- 跨数据集独立地，通过对卡方统计量和自由度求和来汇总全局拟合优度：$$X^2_{\\text{global}} = \\sum_{d} X^2_d,$$ $$\\nu_{\\text{global}} = \\sum_{d} \\nu_d,$$ 以及 $$p_{\\text{global}} = 1 - F_{\\chi^2_{\\nu_{\\text{global}}}}(X^2_{\\text{global}}),$$ 其中 $$\\text{pass}_{\\text{global}} = (p_{\\text{global}} \\ge \\alpha).$$\n- 将所有浮点输出（残差、卡方统计量和 p 值）四舍五入到六位小数。\n\n程序中嵌入的输入规范：\n- 没有外部输入。您的程序必须在内部定义以下测试用例套件，每个套件包含多个数据集。测量单位是一致的，输出（残差、卡方统计量和 p 值）是无量纲的。数组按 $[y_1, \\ldots, y_n]$、$[m_1, \\ldots, m_n]$ 和 $[\\sigma_1, \\ldots, \\sigma_n]$ 的顺序给出，其中 $k$ 表示从自由度中减去的拟合参数数量。\n\n测试套件：\n- 案例 1（普遍一致性，同质不确定度，中等残差）：\n  - 显著性水平：$$\\alpha = 0.05.$$\n  - 数据集 A：\n    - 观测值：$$\\mathbf{y}_A = [1.0, 0.8, 1.2, 0.9, 1.1].$$\n    - 预测值：$$\\mathbf{m}_A = [1.0, 0.75, 1.15, 0.95, 1.05].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_A = [0.1, 0.1, 0.1, 0.1, 0.1].$$\n    - 拟合参数：$$k_A = 1.$$\n  - 数据集 B：\n    - 观测值：$$\\mathbf{y}_B = [2.0, 1.8, 2.1, 1.9].$$\n    - 预测值：$$\\mathbf{m}_B = [2.05, 1.85, 2.05, 1.95].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_B = [0.1, 0.1, 0.1, 0.1].$$\n    - 拟合参数：$$k_B = 1.$$\n- 案例 2（异方差不确定度和混合残差量级）：\n  - 显著性水平：$$\\alpha = 0.05.$$\n  - 数据集 C：\n    - 观测值：$$\\mathbf{y}_C = [5.0, 5.3, 4.8, 5.2].$$\n    - 预测值：$$\\mathbf{m}_C = [5.1, 5.2, 5.0, 5.1].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_C = [0.2, 0.3, 0.2, 0.4].$$\n    - 拟合参数：$$k_C = 2.$$\n  - 数据集 D：\n    - 观测值：$$\\mathbf{y}_D = [3.0, 3.2, 2.9].$$\n    - 预测值：$$\\mathbf{m}_D = [3.1, 3.0, 3.0].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_D = [0.2, 0.2, 0.1].$$\n    - 拟合参数：$$k_D = 1.$$\n- 案例 3（强不一致性，导致大残差的小不确定度）：\n  - 显著性水平：$$\\alpha = 0.05.$$\n  - 数据集 E：\n    - 观测值：$$\\mathbf{y}_E = [0.9, 1.1, 0.95, 1.05, 1.0].$$\n    - 预测值：$$\\mathbf{m}_E = [1.2, 1.2, 1.2, 1.2, 1.2].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_E = [0.05, 0.05, 0.05, 0.05, 0.05].$$\n    - 拟合参数：$$k_E = 0.$$\n  - 数据集 F：\n    - 观测值：$$\\mathbf{y}_F = [10.0, 9.5, 10.5, 9.8].$$\n    - 预测值：$$\\mathbf{m}_F = [10.0, 10.0, 10.0, 10.0].$$\n    - 不确定度：$$\\boldsymbol{\\sigma}_F = [0.2, 0.2, 0.2, 0.2].$$\n    - 拟合参数：$$k_F = 0.$$\n\n输出规范：\n- 对于每个案例，输出一个列表，其中包含每个数据集的一个条目和一个最终的全局条目。每个数据集条目必须是一个列表 $$[\\mathbf{r}, X^2, p, \\text{pass}]$$，其中 $$\\mathbf{r}$$ 是四舍五入到六位小数的残差向量，$$X^2$$ 是四舍五入到六位小数的卡方统计量，$$p$$ 是四舍五入到六位小数的 p 值，$$\\text{pass}$$ 是一个布尔值。最终的全局条目必须是一个列表 $$[X^2_{\\text{global}}, p_{\\text{global}}, \\text{pass}_{\\text{global}}]$$，浮点值同样进行四舍五入。\n- 您的程序应生成单行输出，其中包含所有案例的结果，形式为一个用方括号括起来的逗号分隔列表，其中没有任何空格。也就是说，顶层输出的形式为 $$[\\text{case}_1,\\text{case}_2,\\text{case}_3]$$，其中每个 $$\\text{case}_i$$ 本身都是一个按上述规定构造的列表。",
            "solution": "出发点是具有固定参数化的计算化学生物学系统的实验约束概率模型。令 $$y_i$$ 表示观测测量值，$$m_i$$ 表示相同实验条件下对应的模型预测均值，$$\\sigma_i$$ 表示已知或估计的测量误差标准差。我们假设误差是独立且服从正态分布的，因此 $$y_i = m_i + \\varepsilon_i$$，其中 $$\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)$$，并且不同测量和数据集之间的误差是独立的。当测量方案独立且重复实验的变异性已得到良好表征时，这一假设是合理的，这是在计算化学生物学中整合正交分析时的常见情况。\n\n在此模型下，每个标准化残差 $$r_i = \\frac{y_i - m_i}{\\sigma_i}$$ 服从标准正态分布 $$\\mathcal{N}(0,1)$$，并且由于独立性，向量 $$\\mathbf{r}$$ 由独立的标准正态分量组成。一个核心的统计学事实是，独立标准正态变量的平方和服从卡方分布。具体来说，统计量\n$$\nX^2 = \\sum_{i=1}^{n} r_i^2\n$$\n服从卡方分布，自由度为 $$\\nu = n - k$$，其中 $$n$$ 是数据集中的测量次数，$$k$$ 是用于调整该数据集预测的有效拟合模型参数的数量。减去 $$k$$ 是为了解释参数估计所导致的自由度损失，这是拟合优度检验中的一个标准校正。\n\n为了评估拟合优度，我们将 p 值计算为卡方分布的上尾概率：\n$$\np = \\mathbb{P}\\left(\\chi^2_{\\nu} \\ge X^2\\right) = 1 - F_{\\chi^2_{\\nu}}(X^2),\n$$\n其中 $$F_{\\chi^2_{\\nu}}$$ 是自由度为 $$\\nu$$ 的卡方分布的累积分布函数 (CDF)。给定显著性水平 $$\\alpha$$，检验决策为\n$$\n\\text{pass} =\n\\begin{cases}\n\\text{True}, & \\text{if } p \\ge \\alpha \\\\\n\\text{False}, & \\text{if } p  \\alpha\n\\end{cases}\n$$\n\n当组合实验上独立的数据集时，全局拟合优度统计量是各个卡方统计量之和，全局自由度是各个自由度之和：\n$$\nX^2_{\\text{global}} = \\sum_{d} X^2_d, \\quad \\nu_{\\text{global}} = \\sum_{d} \\nu_d.\n$$\n根据由独立标准正态变量平方和导出的卡方变量的可加性，在模型假设下，$$X^2_{\\text{global}} \\sim \\chi^2_{\\nu_{\\text{global}}}$$。因此，\n$$\np_{\\text{global}} = 1 - F_{\\chi^2_{\\nu_{\\text{global}}}}(X^2_{\\text{global}})\n$$\n具有相同的决策规则 $$\\text{pass}_{\\text{global}} = (p_{\\text{global}} \\ge \\alpha)$$。\n\n算法设计：\n1. 对于每个数据集，读取 $$\\mathbf{y}, \\mathbf{m}, \\boldsymbol{\\sigma}, k$$ 和 $$\\alpha$$。计算残差向量为 $$\\mathbf{r} = (\\mathbf{y} - \\mathbf{m}) \\oslash \\boldsymbol{\\sigma}$$，其中 $$\\oslash$$ 表示逐元素除法。\n2. 计算 $$X^2 = \\sum r_i^2$$ 和 $$\\nu = n - k$$。检查 $$\\nu > 0$$ 以确保卡方拟合优度检验的有效性。\n3. 使用可靠的卡方生存函数数值例程计算 p 值 $$p = 1 - F_{\\chi^2_{\\nu}}(X^2)$$，该函数直接计算上尾概率以保持数值稳定性。\n4. 将 $$p$$ 与 $$\\alpha$$进行比较，并相应地设置 $$\\text{pass}$$。\n5. 通过对 $$X^2$$ 和 $$\\nu$$ 求和来跨数据集聚合，以获得 $$X^2_{\\text{global}}$$ 和 $$\\nu_{\\text{global}}$$，然后计算 $$p_{\\text{global}}$$ 和 $$\\text{pass}_{\\text{global}}$$。\n6. 按要求将所有浮点输出四舍五入到六位小数，并根据规范构建输出结构。\n\n应用于测试套件：\n- 案例 1 使用同质不确定度 $$\\boldsymbol{\\sigma}_A = [0.1, 0.1, 0.1, 0.1, 0.1]$$ 和 $$\\boldsymbol{\\sigma}_B = [0.1, 0.1, 0.1, 0.1]$$ 且残差适中，拟合参数为 $$k_A = 1$$, $$k_B = 1$$。计算出的 $$X^2$$ 值相对于各自的 $$\\nu$$ 较小，产生较大的 p 值，并在 $$\\alpha = 0.05$$ 水平下通过检验。\n- 案例 2 展示了异方差不确定度和混合残差，其中 $$k_C = 2$$, $$k_D = 1$$。每个数据集的 $$X^2$$ 适中，聚合的全局 $$X^2_{\\text{global}}$$ 与 $$\\nu_{\\text{global}}$$ 产生一个不小的 p 值，并在 $$\\alpha = 0.05$$ 水平下通过检验。\n- 案例 3 具有小的不确定度和大的差异，导致两个数据集的 $$X^2$$ 都很大，全局 p 值非常小；检验在 $$\\alpha = 0.05$$ 水平下失败。\n\n该程序实现了这些步骤，并打印一行包含所有案例结果的列表。每个数据集条目的形式为 $$[\\mathbf{r}, X^2, p, \\text{pass}]$$，每个全局条目的形式为 $$[X^2_{\\text{global}}, p_{\\text{global}}, \\text{pass}_{\\text{global}}]$$，所有数值都四舍五入到六位小数。顶层列表按顺序包含三个案例，用逗号和括号格式化，不含空格，以便于自动解析和验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef compute_dataset_metrics(y, m, s, k, alpha):\n    \"\"\"\n    Compute residuals, chi-square statistic, p-value, and pass/fail for one dataset.\n    y, m, s are numpy arrays of equal length; k is integer; alpha is float.\n    \"\"\"\n    # Standardized residuals\n    residuals = (y - m) / s\n    # Chi-square statistic\n    chi_sq = float(np.sum(residuals ** 2))\n    # Degrees of freedom\n    nu = int(len(y) - k)\n    if nu = 0:\n        raise ValueError(\"Degrees of freedom must be positive (n - k > 0).\")\n    # p-value (upper-tail probability)\n    p_value = float(chi2.sf(chi_sq, df=nu))\n    # Decision\n    passed = bool(p_value >= alpha)\n    return residuals, chi_sq, p_value, passed, nu\n\ndef round_float(x, ndigits=6):\n    return float(np.round(x, ndigits))\n\ndef round_list(lst, ndigits=6):\n    return [round_float(float(v), ndigits) for v in lst]\n\ndef format_element_no_space(el):\n    \"\"\"\n    Recursively format nested lists and primitive types into a string\n    without spaces, rounding floats to six decimals.\n    \"\"\"\n    if isinstance(el, list):\n        return \"[\" + \",\".join(format_element_no_space(x) for x in el) + \"]\"\n    elif isinstance(el, (float, np.floating)):\n        return f\"{float(el):.6f}\"\n    elif isinstance(el, (int, np.integer)):\n        return str(int(el))\n    elif isinstance(el, bool):\n        return str(el).lower()\n    else:\n        # Attempt to handle numpy arrays by converting to list\n        if isinstance(el, np.ndarray):\n            return format_element_no_space(el.tolist())\n        # Fallback: convert to string (should not occur in this problem)\n        return str(el)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"alpha\": 0.05,\n            \"datasets\": [\n                {\n                    \"y\": np.array([1.0, 0.8, 1.2, 0.9, 1.1]),\n                    \"m\": np.array([1.0, 0.75, 1.15, 0.95, 1.05]),\n                    \"s\": np.array([0.1, 0.1, 0.1, 0.1, 0.1]),\n                    \"k\": 1,\n                },\n                {\n                    \"y\": np.array([2.0, 1.8, 2.1, 1.9]),\n                    \"m\": np.array([2.05, 1.85, 2.05, 1.95]),\n                    \"s\": np.array([0.1, 0.1, 0.1, 0.1]),\n                    \"k\": 1,\n                },\n            ],\n        },\n        # Case 2\n        {\n            \"alpha\": 0.05,\n            \"datasets\": [\n                {\n                    \"y\": np.array([5.0, 5.3, 4.8, 5.2]),\n                    \"m\": np.array([5.1, 5.2, 5.0, 5.1]),\n                    \"s\": np.array([0.2, 0.3, 0.2, 0.4]),\n                    \"k\": 2,\n                },\n                {\n                    \"y\": np.array([3.0, 3.2, 2.9]),\n                    \"m\": np.array([3.1, 3.0, 3.0]),\n                    \"s\": np.array([0.2, 0.2, 0.1]),\n                    \"k\": 1,\n                },\n            ],\n        },\n        # Case 3\n        {\n            \"alpha\": 0.05,\n            \"datasets\": [\n                {\n                    \"y\": np.array([0.9, 1.1, 0.95, 1.05, 1.0]),\n                    \"m\": np.array([1.2, 1.2, 1.2, 1.2, 1.2]),\n                    \"s\": np.array([0.05, 0.05, 0.05, 0.05, 0.05]),\n                    \"k\": 0,\n                },\n                {\n                    \"y\": np.array([10.0, 9.5, 10.5, 9.8]),\n                    \"m\": np.array([10.0, 10.0, 10.0, 10.0]),\n                    \"s\": np.array([0.2, 0.2, 0.2, 0.2]),\n                    \"k\": 0,\n                },\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = case[\"alpha\"]\n        case_results = []\n        chi_sq_global = 0.0\n        nu_global = 0\n        for ds in case[\"datasets\"]:\n            y = ds[\"y\"]\n            m = ds[\"m\"]\n            s = ds[\"s\"]\n            k = ds[\"k\"]\n            residuals, chi_sq, p_value, passed, nu = compute_dataset_metrics(y, m, s, k, alpha)\n            chi_sq_global += chi_sq\n            nu_global += nu\n            # Round values\n            residuals_rounded = round_list(residuals.tolist(), ndigits=6)\n            chi_sq_rounded = round_float(chi_sq, ndigits=6)\n            p_value_rounded = round_float(p_value, ndigits=6)\n            case_results.append([residuals_rounded, chi_sq_rounded, p_value_rounded, passed])\n        # Global aggregation\n        p_global = float(chi2.sf(chi_sq_global, df=nu_global))\n        pass_global = bool(p_global >= alpha)\n        chi_sq_global_rounded = round_float(chi_sq_global, ndigits=6)\n        p_global_rounded = round_float(p_global, ndigits=6)\n        case_results.append([chi_sq_global_rounded, p_global_rounded, pass_global])\n        results.append(case_results)\n\n    # Final print statement in the exact required format: no spaces anywhere.\n    print(format_element_no_space(results))\n\nsolve()\n```"
        },
        {
            "introduction": "除了简单的验证，实验数据还可以被主动用于改进我们的计算模型。本练习介绍了一种强大的贝叶斯方法，通过推断不同分子状态的布居权重来精炼一个系综模型 。您将学习构建并求解一个约束优化问题，该问题在拟合实验数据（似然）和结合先验知识（熵正则化项）之间取得平衡，这项技术是现代整合结构生物学的核心。",
            "id": "3845696",
            "problem": "考虑一个计算化学生物学背景，其中一个由 $N$ 个离散分子态组成的系综的相对布居权重被收集到一个向量 $w \\in \\mathbb{R}^N$ 中，该向量受限于对所有 $i$ 都有 $w_i \\ge 0$ 且 $\\sum_{i=1}^N w_i = 1$。一组 $M$ 个实验可观测量被建模为一个带有矩阵 $A \\in \\mathbb{R}^{M \\times N}$ 的线性正向映射，因此预测的可观测量为 $A w$。测量的可观测量构成一个向量 $y \\in \\mathbb{R}^M$。测量噪声被建模为零均值多元高斯分布，其对角协方差为 $\\Sigma = \\mathrm{diag}(\\sigma_1^2,\\dots,\\sigma_M^2)$，其中已知的 $\\sigma_j  0$。关于权重的参考先验通过一个严格为正的参考向量 $w^{(0)} \\in \\mathbb{R}^N$（满足 $\\sum_{i=1}^N w^{(0)}_i = 1$）来编码先验知识或无信息基线。目标是在高斯似然和源自 Kullback-Leibler (KL) 散度（强度参数为 $\\lambda  0$）的凸熵正则化子下，获得 $w$ 的最大后验 (MAP) 估计，并受限于上述单纯形约束。您必须从由贝叶斯定理、多元高斯分布的性质和最大熵原理构成的基本基础出发，推导出凸优化目标，然后实现一个程序，通过解决由此产生的约束凸优化问题来计算几个测试用例的 MAP 估计。验证必须包括对输出权重的归一化和非负性的检查。\n\n推导要求：从贝叶斯定理和均值为 $A w$、协方差为 $\\Sigma$ 的多元高斯分布的对数似然出发，并使用最大熵原理来论证相对于 $w^{(0)}$ 的熵先验的合理性，推导出 $w$ 的 MAP 估计量所最小化的凸目标及其定义域约束，不引入任何额外的非基本假设。从第一性原理证明所得问题的凸性。不要在问题陈述中提供捷径公式。\n\n数值与算法要求：实现一个求解器，该求解器使用带线性等式和边界约束的凸优化，为每个测试用例计算 MAP 权重 $w$。使用适合光滑凸问题的数值方法，并向优化器提供梯度以确保可靠收敛。计算出 $w$ 后，验证归一化 $\\sum_{i=1}^N w_i = 1$ 在 $10^{-8}$ 的绝对容差内成立，以及 $w_i \\ge 0$ 在 $10^{-12}$ 的绝对容差内成立。对于每个测试用例，报告一个结果列表，该列表连接了优化后的权重，后跟两个布尔值，分别指示归一化和非负性检查是否通过。对于每个测试用例，报告一个结果列表，该列表连接了优化后的权重，后跟两个布尔值，分别指示归一化和非负性检查是否通过。将报告的每个权重四舍五入到 $6$ 位小数以便输出。将每个案例的列表聚合成一个顶级列表，顺序与案例顺序相同。程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，不含空格，例如：\n$$\n[\\,[w_{1,1},\\dots,w_{1,N_1},b_{1,\\mathrm{norm}},b_{1,\\mathrm{pos}}],\\,[w_{2,1},\\dots],\\,\\dots\\,]\n$$\n其中 $w_{k,i}$ 表示案例 $k$ 的第 $i$ 个权重，$b_{k,\\cdot}$ 是布尔值。\n\n角度单位不适用。不需要物理单位。所有输出必须是指定的数值浮点数或布尔值，并且所有列表必须遵循上述确切格式。",
            "solution": "所提出的问题是贝叶斯推断中的一个明确定义的任务，特别是最大后验 (MAP) 估计，应用于计算化学生物学中的一个常见场景。目标是确定分子态系综的最佳布居权重 $w$，使其能最好地解释一组实验可观测量 $y$，同时受到先验知识的正则化。我们首先验证问题陈述。该问题提供了所有必要组成部分：一个线性正向模型 ($A$)、带有指定不确定性 ($\\sigma$) 的实验数据 ($y$)、一个参考权重分布 ($w^{(0)}$) 和一个正则化参数 ($\\lambda$)。对权重的约束 $\\sum_{i=1}^N w_i = 1$ 和 $w_i \\ge 0$ 定义了标准单纯形，确保了物理上有意义的概率分布。使用高斯似然和熵先验 (Kullback-Leibler 散度) 是统计数据分析中标准的、有原则的选择。该问题具有科学依据、自洽且在数学上是适定的。因此，它被认为是有效的，我们可以进行完整的推导和求解。\n\n我们从贝叶斯定理开始推导目标函数，该定理指出给定数据 $y$ 的权重 $w$ 的后验概率与似然和先验概率的乘积成正比：\n$$\np(w | y) \\propto p(y | w) p(w)\n$$\n寻找 MAP 估计 $\\hat{w}_{\\mathrm{MAP}}$ 等同于最大化该后验概率，这又等同于最小化其负对数：\n$$\n\\hat{w}_{\\mathrm{MAP}} = \\arg\\max_{w} p(w | y) = \\arg\\min_{w} \\left( -\\log p(w | y) \\right)\n$$\n\n第一项 $p(y | w)$ 是给定权重 $w$ 观测到数据 $y$ 的似然。问题指定测量噪声是零均值多元高斯分布，其对角协方差矩阵为 $\\Sigma = \\mathrm{diag}(\\sigma_1^2, \\dots, \\sigma_M^2)$。该分布的均值由正向模型 $Aw$ 给出。此多元高斯分布的概率密度函数为：\n$$\np(y | w) = \\frac{1}{(2\\pi)^{M/2} |\\Sigma|^{1/2}} \\exp\\left(-\\frac{1}{2} (y - Aw)^T \\Sigma^{-1} (y - Aw)\\right)\n$$\n取似然的负对数，得到我们目标函数的数据拟合项。忽略不依赖于 $w$ 的常数项，我们得到：\n$$\n-\\log p(y | w) \\propto \\frac{1}{2} (Aw - y)^T \\Sigma^{-1} (Aw - y) = \\frac{1}{2} \\sum_{j=1}^{M} \\frac{((Aw)_j - y_j)^2}{\\sigma_j^2}\n$$\n该项是加权残差平方和，通常称为卡方 ($\\chi^2$) 统计量。\n\n第二项 $p(w)$ 是权重的先验概率。问题指导我们使用源自 Kullback-Leibler (KL) 散度的熵正则化子，其动机是最大熵原理。该原理建议选择一个在与观测数据一致的同时，尽可能接近参考（或先验）分布 $w^{(0)}$ 的分布。KL 散度或相对熵，衡量两个概率分布 $w$ 和 $w^{(0)}$ 之间的“距离”：\n$$\nD_{KL}(w || w^{(0)}) = \\sum_{i=1}^{N} w_i \\log\\left(\\frac{w_i}{w^{(0)}_i}\\right)\n$$\n熵先验的标准选择形式为 $p(w) \\propto \\exp(-\\alpha D_{KL}(w || w^{(0)}))$，其中 $\\alpha$ 是控制先验强度的参数。问题指定了一个正则化强度参数 $\\lambda  0$。在惩罚似然的背景下，此参数在对数后验空间中乘以正则化项。因此，负对数先验为：\n$$\n-\\log p(w) \\propto \\lambda D_{KL}(w || w^{(0)}) = \\lambda \\sum_{i=1}^{N} w_i \\log\\left(\\frac{w_i}{w^{(0)}_i}\\right)\n$$\n\n结合负对数似然和负对数先验，我们得到要最小化的最终目标函数 $F(w)$：\n$$\nF(w) = \\frac{1}{2} \\sum_{j=1}^{M} \\left(\\frac{(Aw)_j - y_j}{\\sigma_j}\\right)^2 + \\lambda \\sum_{i=1}^{N} w_i \\log\\left(\\frac{w_i}{w^{(0)}_i}\\right)\n$$\n该函数必须在单纯形约束条件下最小化：$\\sum_{i=1}^N w_i = 1$ 和对所有 $i \\in \\{1, \\dots, N\\}$ 都有 $w_i \\ge 0$。\n\n我们现在从第一性原理证明该优化问题的凸性。目标函数 $F(w)$ 是两个函数之和，$F(w) = F_1(w) + F_2(w)$。\n第一项是数据拟合项，$F_1(w) = \\frac{1}{2} \\sum_{j=1}^{M} \\left(\\frac{(Aw)_j - y_j}{\\sigma_j}\\right)^2$。这可以写成矩阵形式 $F_1(w) = \\frac{1}{2} (Aw-y)^T\\Sigma^{-1}(Aw-y)$。该项关于 $w$ 的梯度是 $\\nabla_w F_1(w) = A^T\\Sigma^{-1}(Aw-y)$。Hessian 矩阵是二阶导数，$\\nabla_w^2 F_1(w) = A^T\\Sigma^{-1}A$。由于 $\\Sigma^{-1}$ 是一个对角线上有严格正项 $1/\\sigma_j^2$ 的对角矩阵，它是正定的。对于任意向量 $z \\in \\mathbb{R}^N$，二次型 $z^T (A^T\\Sigma^{-1}A) z = (Az)^T \\Sigma^{-1} (Az) \\ge 0$。因此，Hessian 矩阵是半正定的，证明了 $F_1(w)$ 是一个凸函数。\n\n第二项是熵正则化子，$F_2(w) = \\lambda \\sum_{i=1}^{N} w_i \\log\\left(\\frac{w_i}{w^{(0)}_i}\\right) = \\lambda \\sum_{i=1}^{N} (w_i \\log w_i - w_i \\log w^{(0)}_i)$。其梯度为 $\\nabla_w F_2(w)_k = \\lambda (\\log(w_k/w^{(0)}_k) + 1)$。Hessian 矩阵是对角的，其对角项为 $(\\nabla_w^2 F_2(w))_{kk} = \\frac{\\partial^2 F_2}{\\partial w_k^2} = \\frac{\\lambda}{w_k}$。在问题的定义域内，$w_i  0$ 且 $\\lambda  0$，因此 Hessian 矩阵的所有对角项都是严格正的。这意味着 $F_2(w)$ 的 Hessian 矩阵是正定的，因此 $F_2(w)$ 是一个严格凸函数。\n\n总目标函数 $F(w)$ 是一个凸函数 ($F_1$) 和一个严格凸函数 ($F_2$) 的和，因此是严格凸的。由约束 $\\sum_{i=1}^N w_i = 1$ 和 $w_i \\ge 0$ 定义的可行域是一个标准单纯形，它是一个紧凸集。在非空、紧凸集上最小化一个严格凸函数，保证了唯一解的存在。\n\n对于数值求解，我们采用一种适用于约束非线性优化的拟牛顿法。具体来说，我们选择 `scipy.optimize.minimize` 中可用的序列最小二乘规划 (SLSQP) 算法。该算法可以处理等式和不等式（边界）约束。为确保稳健高效的收敛，我们必须向优化器提供目标函数的解析梯度，$\\nabla_w F(w) = \\nabla_w F_1(w) + \\nabla_w F_2(w)$：\n$$\n\\nabla_w F(w) = A^T\\Sigma^{-1}(Aw-y) + \\lambda \\left[ \\log\\left(\\frac{w_1}{w^{(0)}_1}\\right)+1, \\dots, \\log\\left(\\frac{w_N}{w^{(0)}_N}\\right)+1 \\right]^T\n$$\n约束被实现为一个线性等式约束 `{'type': 'eq', 'fun': lambda w: np.sum(w) - 1}` 和边界约束 $w_i \\ge 0$。参考权重 $w^{(0)}$ 为迭代优化过程提供了一个自然且表现良好的初始猜测。获得优化后的权重 $\\hat{w}$ 后，我们执行两次验证检查：归一化（$\\left|\\sum_i \\hat{w}_i - 1\\right| \\le 10^{-8}$）和非负性（对所有 $i$ 都有 $\\hat{w}_i \\ge -10^{-12}$）。对非负性检查设置轻微的负容差是为了考虑到在可行集边界附近的潜在浮点误差。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.special import rel_entr\n\ndef solve():\n    \"\"\"\n    Main function to solve the MAP estimation problem for all test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"A\": np.array([[1.0, 0.0, 0.5], [0.2, 0.8, 0.5]]),\n            \"y\": np.array([0.7, 0.5]),\n            \"sigma\": np.array([0.05, 0.05]),\n            \"lambda_\": 0.1,\n            \"w0\": np.array([1/3., 1/3., 1/3.]),\n        },\n        {\n            \"A\": np.array([[1.0, 0.2, 0.2, 0.0], [0.0, 0.7, 0.1, 0.9], [0.5, 0.1, 0.8, 0.3]]),\n            \"y\": np.array([0.2, 0.6, 0.4]),\n            \"sigma\": np.array([0.02, 0.02, 0.05]),\n            \"lambda_\": 0.05,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25]),\n        },\n        {\n            \"A\": np.array([[0.5, 0.49, 0.1], [0.5, 0.51, 0.9]]),\n            \"y\": np.array([0.5, 0.5]),\n            \"sigma\": np.array([0.1, 0.1]),\n            \"lambda_\": 1.0,\n            \"w0\": np.array([0.2, 0.2, 0.6]),\n        },\n        {\n            \"A\": np.array([[0.9, 0.1, 0.1], [0.8, 0.2, 0.2]]),\n            \"y\": np.array([0.9, 0.8]),\n            \"sigma\": np.array([0.01, 0.01]),\n            \"lambda_\": 0.01,\n            \"w0\": np.array([1/3., 1/3., 1/3.]),\n        }\n    ]\n\n    results_for_printing = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        y = case[\"y\"]\n        sigma = case[\"sigma\"]\n        lambda_ = case[\"lambda_\"]\n        w0 = case[\"w0\"]\n        N = A.shape[1]\n\n        # Use a more robust implementation for the objective function's log term\n        # to handle w_i -> 0 gracefully. scipy.special.rel_entr calculates w*log(w/w0).\n        def objective_func(w, A, y, sigma, lambda_, w0):\n            # Term 1: Chi-squared\n            chi2_term = 0.5 * np.sum(((A @ w - y) / sigma) ** 2)\n            # Term 2: KL-divergence regularizer\n            # rel_entr(w, w0) is element-wise w_i * log(w_i / w0_i)\n            kl_term = lambda_ * np.sum(rel_entr(w, w0))\n            return chi2_term + kl_term\n\n        # Gradient of the objective function\n        def gradient_func(w, A, y, sigma, lambda_, w0):\n            # Gradient of Chi-squared term\n            sigma_inv_sq = 1 / (sigma ** 2)\n            grad_chi2 = A.T @ (sigma_inv_sq * (A @ w - y))\n            # Gradient of KL-divergence term\n            # Add a small epsilon to avoid log(0) if optimizer queries boundary\n            # Although SLSQP should respect bounds, it's safer.\n            w_safe = np.maximum(w, 1e-150)\n            grad_kl = lambda_ * (np.log(w_safe / w0) + 1)\n            return grad_chi2 + grad_kl\n\n        # Constraints\n        # 1. Sum of weights must be 1 (equality constraint)\n        constraints = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n        # 2. Weights must be non-negative (bounds)\n        bounds = [(0, None) for _ in range(N)]\n\n        # Initial guess is the reference distribution\n        w_initial = np.copy(w0)\n\n        # Perform the optimization\n        result = minimize(\n            objective_func,\n            w_initial,\n            args=(A, y, sigma, lambda_, w0),\n            method='SLSQP',\n            jac=gradient_func,\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12,\n            options={'maxiter': 1000}\n        )\n        \n        w_opt = result.x\n\n        # Verification checks\n        norm_check_passed = np.abs(np.sum(w_opt) - 1.0) = 1e-8\n        positivity_check_passed = np.all(w_opt >= -1e-12)\n\n        # Format results for this case\n        w_strs = [f\"{val:.6f}\" for val in w_opt]\n        b_strs = [str(norm_check_passed).lower(), str(positivity_check_passed).lower()]\n        all_strs = w_strs + b_strs\n        results_for_printing.append(f\"[{','.join(all_strs)}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results_for_printing)}]\")\n\nsolve()\n```"
        }
    ]
}