{
    "hands_on_practices": [
        {
            "introduction": "在深入研究马尔可夫状态模型（MSM）复杂的验证技术之前，我们必须首先牢固掌握其核心的数学对象：转移矩阵 $T(\\tau)$。这个练习  提供了一个基于代码的实践方法来巩固这些基础知识。你将通过从第一性原理出发，实现平稳分布的计算，并验证其归一化、非负性和长期收敛性等核心性质，从而确保你对MSM的数学行为有透彻的理解。",
            "id": "3838051",
            "problem": "考虑一个为计算化学生物学中的构象动力学构建的有限态马尔可夫状态模型 (MSM)，其延迟时间 $\\tau$ 固定，由一个大小为 $n \\times n$ 且各项非负的行随机转移矩阵 $T(\\tau)$ 表示。根据定义，$T(\\tau)$ 的每一行之和为 1，所有项均为非负，且状态概率的演化由 $p(t+\\tau) = p(t) T(\\tau)$ 给出，其中 $p(t)$ 是一个行向量。稳态分布 $\\pi$ 是一个满足 $\\pi T(\\tau) = \\pi$ 和 $\\sum_{i=1}^{n} \\pi_i = 1$ 的行向量，且 $\\pi_i \\ge 0$。对于一个不可约且非周期的链（即 $T(\\tau)$ 是本原矩阵），Perron–Frobenius 定理保证了存在唯一的、各分量严格为正的稳态分布，并且存在收敛性\n$$\n\\lim_{k \\to \\infty} T(\\tau)^k = \\mathbf{1} \\, \\pi^\\top,\n$$\n其中 $\\mathbf{1}$ 是元素全为 1 的列向量。\n\n仅使用这些核心定义和事实，编写一个完整的程序，对下面的每个测试用例，从 $T(\\tau)$ 计算稳态分布 $\\pi$，并验证 (i) 行归一化，(ii) 逐项非负性（正性），(iii) 稳态性，以及 (iv) $T(\\tau)^k$ 对指定幂 $k$ 向 $\\mathbf{1}\\pi^\\top$ 的收敛性。你的程序必须从第一性原理出发实现以下步骤：\n- 通过求解线性系统 $(T(\\tau)^\\top - I)\\,x = 0$ 并附加归一化约束 $\\sum_i x_i = 1$ 来计算 $\\pi$。\n- 通过检查每行的和与 1 的最大绝对偏差是否在容差 $\\varepsilon_{\\text{norm}}$ 之内来验证行归一化。\n- 通过检查 $T(\\tau)$ 的最小项是否至少为 $-\\varepsilon_{\\text{pos}}$ 来验证正性。\n- 通过计算残差 $\\lVert \\pi T(\\tau) - \\pi \\rVert_{\\infty}$ 并与 $\\varepsilon_{\\text{stat}}$ 进行比较来验证稳态性。\n- 通过计算 $\\lVert T(\\tau)^k - \\mathbf{1}\\pi^\\top \\rVert_{\\infty}$ 并与特定于用例的收敛容差 $\\varepsilon_{\\text{conv}}$ 进行比较来验证收敛性。\n\n除非另有说明，否则所有用例均使用以下共享的数值容差：\n- 行归一化容差 $\\varepsilon_{\\text{norm}} = 10^{-12}$。\n- 正性容差 $\\varepsilon_{\\text{pos}} = 10^{-15}$。\n- 稳态性容差 $\\varepsilon_{\\text{stat}} = 10^{-10}$。\n- 收敛容差 $\\varepsilon_{\\text{conv}}$ 在每个测试用例中指定。\n\n测试套件（所有数字均为实数且无量纲）：\n1. 用例 A（一个具有强自持性的可逆 $3$ 态 MSM）：\n   - 矩阵\n     $$\n     T_A = \\begin{bmatrix}\n     0.86  0.10  0.04 \\\\\n     0.16666666666666666  0.7333333333333334  0.10 \\\\\n     0.10  0.15  0.75\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_A = 200$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},A} = 10^{-6}$。\n2. 用例 B（一个由于弱耦合导致混合缓慢的 $2$ 态 MSM）：\n   - 矩阵\n     $$\n     T_B = \\begin{bmatrix}\n     0.995  0.005 \\\\\n     0.02  0.98\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_B = 800$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},B} = 10^{-8}$。\n3. 用例 C（一个具有两个弱耦合盆地的 $4$ 态 MSM）：\n   - 矩阵\n     $$\n     T_C = \\begin{bmatrix}\n     0.94  0.05  0.01  0.0 \\\\\n     0.04  0.93  0.0  0.03 \\\\\n     0.005  0.0  0.985  0.01 \\\\\n     0.0  0.02  0.03  0.95\n     \\end{bmatrix}.\n     $$\n   - 幂 $k_C = 2000$。\n   - 收敛容差 $\\varepsilon_{\\text{conv},C} = 10^{-8}$。\n\n你的程序必须：\n- 对于每个用例，计算 $\\pi$，然后评估四个布尔检查：行归一化、正性、稳态性和收敛性，如果各自的标准在其容差范围内得到满足，则每个检查返回真。\n- 将三个用例的结果汇总成一个包含 $12$ 个布尔值的扁平列表，顺序如下：\n  $[\\text{norm}_A, \\text{pos}_A, \\text{stat}_A, \\text{conv}_A, \\text{norm}_B, \\text{pos}_B, \\text{stat}_B, \\text{conv}_B, \\text{norm}_C, \\text{pos}_C, \\text{stat}_C, \\text{conv}_C]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，使用编程语言的布尔字面量表示的 $[{\\rm true},{\\rm false},\\dots]$）。不应打印任何其他文本。",
            "solution": "该问题要求对几个由其转移矩阵 $T(\\tau)$ 表示的马尔可夫状态模型 (MSM) 的关键性质进行数值验证。验证过程包括计算稳态分布 $\\pi$，然后验证四个基本性质：行归一化、非负性、$\\pi$ 的稳态性，以及转移矩阵的高次幂向其理论极限的收敛性。整个过程需从第一性原理出发，实现为一个独立完整的程序。\n\n问题的核心在于不可约且非周期马尔可夫链的行随机转移矩阵 $T$ 的性质。Perron-Frobenius 定理保证了存在一个唯一的稳态分布 $\\pi$，它是一个各分量严格为正 ($\\pi_i > 0$) 且满足以下条件的行向量：\n1. 稳态性：$\\pi T = \\pi$\n2. 归一化：$\\sum_i \\pi_i = 1$\n\n该定理还保证了矩阵的幂 $T^k$ 会收敛到一个由稳态分布构成的秩一矩阵：$\\lim_{k \\to \\infty} T^k = \\mathbf{1}\\pi$，其中 $\\mathbf{1}$ 是一个元素全为 1 的列向量。我们的任务是数值验证这些性质。\n\n方法步骤如下：\n\n首先，我们计算稳态分布 $\\pi$。稳态特征值方程 $\\pi T = \\pi$ 可以转置为 $T^\\top \\pi^\\top = \\pi^\\top$。令 $x = \\pi^\\top$ 为稳态分布的列向量表示。方程变为 $T^\\top x = x$，整理后为 $(T^\\top - I)x = 0$，其中 $I$ 是单位矩阵。这是一个齐次线性系统。对于不可约的马尔可夫链，特征值 1 的几何重数为 1，这意味着 $(T^\\top - I)$ 的零空间是一维的。因此，系统 $(T^\\top - I)x = 0$ 有无穷多解，所有解都是单个特征向量的标量倍数。为了找到对应于稳态分布的唯一解，我们必须施加归一化约束 $\\sum_i x_i = \\sum_i \\pi_i = 1$。解决这个问题的一个标准数值技术是增广方程组。我们可以用归一化方程替换 $(T^\\top - I)x = 0$ 中的一个线性相关方程。设 $A = T^\\top - I$。我们通过将 $A$ 的最后一行替换为全为 1 的行来构造一个新矩阵 $A'$。我们还构造一个新的右端向量 $b'$，其除了最后一个位置为 1 外，其余位置均为零。由此产生的线性系统 $A'x=b'$ 是非奇异的，可以唯一求解出 $x = \\pi^\\top$。\n\n其次，我们对每个给定的转移矩阵 $T$、其对应的幂 $k$ 和一组数值容差，执行四个指定的验证检查。\n\n(i) 行归一化验证：如果一个矩阵 $T$ 的每行元素之和为 1，则该矩阵是行随机的。这反映了这样一个原理：从任何给定状态出发，系统必须转移到模型中的某个其他状态，因此从一个状态转移出去的总概率为 1。我们通过计算行和与 1 的最大绝对偏差来检查这一点：$\\max_i |\\sum_j T_{ij} - 1|$。该值必须小于或等于容差 $\\varepsilon_{\\text{norm}} = 10^{-12}$。\n\n(ii) 正性验证：转移矩阵的项 $T_{ij}$ 代表概率，因此必须是非负的。为了考虑潜在的浮点不精确性，我们通过检查矩阵中的最小项不是显著的负数来验证这一点。条件是 $\\min_{i,j} T_{ij} \\ge -\\varepsilon_{\\text{pos}}$，其中 $\\varepsilon_{\\text{pos}} = 10^{-15}$。\n\n(iii) 稳态性验证：此检查确认数值计算出的分布 $\\pi$ 确实是给定矩阵 $T$ 的一个稳态分布。我们计算残差向量 $\\pi T - \\pi$。一个完美的稳态分布将产生一个零向量。我们通过计算该残差的无穷范数 $\\lVert \\pi T - \\pi \\rVert_{\\infty} = \\max_i |(\\pi T)_i - \\pi_i|$ 来量化偏差，并检查它是否小于或等于稳态性容差 $\\varepsilon_{\\text{stat}} = 10^{-10}$。\n\n(iv) 收敛性验证：此测试验证长时间收敛性质。对于一个大的幂 $k$，矩阵 $T^k$ 应接近极限矩阵 $\\mathbf{1}\\pi$。我们计算矩阵的 $k$ 次幂 $T^k$ 与理论极限矩阵之间的差异。误差以两个矩阵元素之间的最大绝对差来衡量，即 $\\max_{i,j} |(T^k)_{ij} - (\\mathbf{1}\\pi)_{ij}|$。这是在逐元素收敛背景下对矩阵无穷范数的一种常见解释。此误差必须小于或等于特定于用例的收敛容差 $\\varepsilon_{\\textconv}$。\n\n这些步骤被系统地应用于每个测试用例，并且四个检查的布尔结果按照问题的要求汇总到一个单一列表中。",
            "answer": "```python\nimport numpy as np\n\ndef solve_case(T, k, eps_norm, eps_pos, eps_stat, eps_conv):\n    \"\"\"\n    Computes the stationary distribution of T and performs four validation checks.\n\n    Args:\n        T (np.ndarray): The n x n transition matrix.\n        k (int): The power to raise T to for the convergence check.\n        eps_norm (float): Tolerance for row normalization check.\n        eps_pos (float): Tolerance for positivity check.\n        eps_stat (float): Tolerance for stationarity check.\n        eps_conv (float): Tolerance for convergence check.\n\n    Returns:\n        tuple: A tuple of four booleans for (normalization, positivity, stationarity, convergence).\n    \"\"\"\n    n = T.shape[0]\n\n    # Step 1: Compute the stationary distribution pi\n    # We need to solve (T.T - I)x = 0 subject to sum(x) = 1.\n    # This is done by replacing the last row of (T.T - I) with a row of ones,\n    # and setting the corresponding element in the RHS vector to 1.\n    A = T.T - np.identity(n)\n    A[-1, :] = 1.0\n    b = np.zeros(n)\n    b[-1] = 1.0\n\n    try:\n        # pi_vec is a column vector, but numpy's 1-D array handles this flexibly.\n        pi_vec = np.linalg.solve(A, b)\n    except np.linalg.LinAlgError:\n        # Should not happen for a valid irreducible, aperiodic MSM\n        return (False, False, False, False)\n\n    # Step 2: Perform the four verification checks\n\n    # Check (i): Row normalization\n    row_sums = np.sum(T, axis=1)\n    norm_err = np.max(np.abs(row_sums - 1.0))\n    is_normalized = norm_err = eps_norm\n\n    # Check (ii): Entrywise nonnegativity (positivity)\n    min_val = np.min(T)\n    is_positive = min_val >= -eps_pos\n\n    # Check (iii): Stationarity\n    # pi_vec is broadcasted as a row vector in this operation\n    residual_vec = pi_vec @ T - pi_vec\n    stat_err = np.max(np.abs(residual_vec))\n    is_stationary = stat_err = eps_stat\n\n    # Check (iv): Convergence\n    T_k = np.linalg.matrix_power(T, k)\n    # limit_matrix is the outer product of a column vector of ones and the row vector pi\n    limit_matrix = np.ones((n, 1)) @ pi_vec.reshape(1, -1)\n    conv_err = np.max(np.abs(T_k - limit_matrix))\n    is_converged = conv_err = eps_conv\n\n    return (is_normalized, is_positive, is_stationary, is_converged)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Shared numerical tolerances\n    eps_norm = 1e-12\n    eps_pos = 1e-15\n    eps_stat = 1e-10\n\n    # Test suite\n    test_cases = [\n        {\n            \"T\": np.array([\n                [0.86, 0.10, 0.04],\n                [1/6, 11/15, 0.10], # Using fractions for precision\n                [0.10, 0.15, 0.75]\n            ]),\n            \"k\": 200,\n            \"eps_conv\": 1e-6\n        },\n        {\n            \"T\": np.array([\n                [0.995, 0.005],\n                [0.02, 0.98]\n            ]),\n            \"k\": 800,\n            \"eps_conv\": 1e-8\n        },\n        {\n            \"T\": np.array([\n                [0.94, 0.05, 0.01, 0.0],\n                [0.04, 0.93, 0.0, 0.03],\n                [0.005, 0.0, 0.985, 0.01],\n                [0.0, 0.02, 0.03, 0.95]\n            ]),\n            \"k\": 2000,\n            \"eps_conv\": 1e-8\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        T = case[\"T\"]\n        # The first case in the problem description used floating point approximations.\n        # Let's ensure the matrix matches the problem's floats exactly for reproducibility.\n        if T.shape[0] == 3:\n            T[1,0] = 0.16666666666666666\n            T[1,1] = 0.7333333333333334\n        \n        results = solve_case(T, case[\"k\"], eps_norm, eps_pos, eps_stat, case[\"eps_conv\"])\n        all_results.extend(results)\n\n    # Format the final output as a single-line string\n    print(f\"[{','.join(map(lambda x: str(x).lower(), all_results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "验证马尔可夫状态模型最关键的步骤之一是选择一个合适的延迟时间 $\\tau$，并确认模型是否捕捉到了系统的慢动力学过程，即马尔可夫性。隐含时间尺度图是进行此项评估的主要工具。在这个实践中 ，你将学习如何从模型中计算最慢的隐含时间尺度，并分析它们对 $\\tau$ 的依赖关系，这是判断模型是否具有物理意义的关键技能。",
            "id": "3838048",
            "problem": "您的任务是，在一个用于计算化学生物学中长时间尺度动力学的马尔可夫状态模型 (MSM) 的构建和验证背景下，计算一个示例转移概率矩阵的隐含时间尺度作为延迟时间的函数，并评估最慢的时间尺度是否已收敛。请从以下定义和事实开始。马尔可夫状态模型 (MSM) 通过一个转移概率矩阵 $T(\\tau)$ 来表示一个系统投影到一组有限离散状态上的动力学，该矩阵将状态概率推进一个延迟时间 $\\tau$。转移概率矩阵 $T(\\tau)$ 是一个行随机矩阵，其元素非负且行和等于 $1$；其最大特征值等于 $1$。在连续时间动力学中，一个速率矩阵（生成元）$K$ 的非对角元素 $K_{ij}$（对于 $i \\neq j$）为非负值，对角元素为 $K_{ii} = - \\sum_{j \\neq i} K_{ij}$。对于一个连续时间马尔可夫链 (CTMC)，相应的延迟转移概率矩阵是 $T(\\tau) = \\exp(\\tau K)$，其中 $\\exp$ 表示矩阵指数。$T(\\tau)$ 的隐含弛豫时间尺度 $t_i(\\tau)$ 是通过其特征值 $\\lambda_i(\\tau)$（按模降序排列）定义的，不包括平凡稳态特征值 $\\lambda_1(\\tau)=1$，其公式为 $t_i(\\tau) = - \\tau / \\ln |\\lambda_i(\\tau)|$。慢隐含时间尺度是与最大非平凡特征值模 $|\\lambda_2(\\tau)|$ 相关联的时间尺度。对于一个构建良好的 MSM，最慢隐含时间尺度应随着 $\\tau$ 的增加而收敛，这表明模型在这些延迟时间上捕捉到了近似的马尔可夫动力学。您的程序必须计算多个延迟时间下的 $t_2(\\tau)$，并通过一个相对范围准则评估在较大延迟时间子集上的收敛性。\n\n科学真实性要求：您将通过 $T(\\tau) = \\exp(\\tau K)$ 从物理上合理的连续时间速率矩阵 $K$ 构建 $T(\\tau)$ 矩阵，然后添加小的确定性扰动以模拟有限样本估计噪声。这些扰动必须通过将负条目裁剪为 $0$ 并将行重归一化使其和为 $1$ 来保持行随机性和非负性。\n\n单位：所有延迟时间 $\\tau$ 和隐含时间尺度 $t_i(\\tau)$ 都必须以微秒表示。您的程序的最终数值输出必须以微秒为单位。\n\n需要实现的算法：\n- 对于每个测试用例和每个延迟时间 $\\tau$，构建未扰动的矩阵 $T_0(\\tau) = \\exp(\\tau K)$。\n- 添加一个确定性扰动矩阵 $\\Delta(\\tau) = \\delta(\\tau) N$，其中 $N$ 是一个固定的非对角模式矩阵，其元素 $N_{ij} = 1$（对于 $i \\neq j$）且 $N_{ii} = 0$，$\\delta(\\tau)$ 是为每个测试用例提供的一个小的非负标量。\n- 设置 $\\tilde{T}(\\tau) = T_0(\\tau) + \\Delta(\\tau)$，然后通过逐元素裁剪至非负和行归一化，将 $\\tilde{T}(\\tau)$ 投影回行随机矩阵集合：对于每一行 $i$，设置 $\\tilde{T}_{ij}(\\tau) \\leftarrow \\max\\{ \\tilde{T}_{ij}(\\tau), 0 \\}$，然后将该行除以其和。\n- 计算 $\\tilde{T}(\\tau)$ 的所有特征值 $\\lambda_i(\\tau)$，按其模 $|\\lambda_i(\\tau)|$ 的降序排序，排除最接近 $1$ 的平凡特征值，并计算最慢隐含时间尺度 $t_2(\\tau) = - \\tau / \\ln |\\lambda_2(\\tau)|$。如果 $|\\lambda_2(\\tau)| = 0$，则定义 $t_2(\\tau) = 0$。\n- 收敛性评估：对于按 $\\tau_k$ 升序排列的所有延迟时间的最慢隐含时间尺度集合 $\\{ t_2(\\tau_k) \\}$，仅考虑由后半部分值组成的较大延迟时间子集（分割索引向下取整），计算该子集的平均值 $\\bar{t}$、最大值 $t_{\\max}$ 和最小值 $t_{\\min}$，如果 $(t_{\\max} - t_{\\min}) / \\bar{t} \\leq \\epsilon$，则宣布收敛，其中 $\\epsilon$ 是每个测试用例指定的容差。如果 $\\bar{t} = 0$，则当且仅当 $t_{\\max} = t_{\\min}$ 时宣布收敛。\n\n您的程序应生成单行输出，其中包含所有测试用例的聚合结果，格式为方括号括起来的逗号分隔列表。对于每个测试用例，输出一个包含两个元素的列表：第一个元素是按指定延迟时间计算的最慢隐含时间尺度列表 $[t_2(\\tau_1), t_2(\\tau_2), \\dots]$（单位为微秒，四舍五入到六位小数），第二个元素是该测试用例收敛性评估的布尔值。因此，最终输出行必须类似于 $[[[t_{21}, t_{22}, \\dots], b_1], [[t_{31}, t_{32}, \\dots], b_2], \\dots]$，其中每个 $t_{ij}$ 是一个以微秒为单位的浮点数，每个 $b_i$ 是一个布尔值。\n\n具有明确参数的测试套件规范：\n\n- 测试用例 $1$（正常路径，具有递减扰动的可逆对称簇）：\n  - 状态数：$4$。\n  - 速率矩阵 $K$ 由两个簇 $\\{0,1\\}$ 和 $\\{2,3\\}$ 定义，具有强簇内速率和弱簇间速率：对于 $i \\neq j$，如果 $i,j \\in \\{0,1\\}$ 或 $i,j \\in \\{2,3\\}$，则设置 $K_{ij} = 6.0$，否则设置 $K_{ij} = 0.2$。设置每个 $K_{ii} = - \\sum_{j \\neq i} K_{ij}$。\n  - 延迟时间 (微秒)：$\\tau \\in \\{ 1.0, 2.0, 5.0, 10.0 \\}$。\n  - 扰动幅度：$\\delta(\\tau)$ 分别为 $\\in \\{ 0.02, 0.01, 0.005, 0.002 \\}$。\n  - 收敛容差：$\\epsilon = 0.1$。\n\n- 测试用例 $2$（边缘情况，3 状态非对称环，具有非递减扰动，在严格容差下导致不收敛）：\n  - 状态数：$3$。\n  - 速率矩阵 $K$ 由一个非对称环定义：$K_{01} = 1.5$, $K_{12} = 1.5$, $K_{20} = 1.5$, $K_{10} = 1.2$, $K_{21} = 1.2$, $K_{02} = 0.8$，其中 $K_{ii} = - \\sum_{j \\neq i} K_{ij}$。\n  - 延迟时间 (微秒)：$\\tau \\in \\{ 0.5, 1.0, 2.0, 4.0 \\}$。\n  - 扰动幅度：$\\delta(\\tau) \\in \\{ 0.03, 0.03, 0.03, 0.03 \\}$。\n  - 收敛容差：$\\epsilon = 0.05$。\n\n- 测试用例 $3$（边界条件，5 状态，具有非常慢的簇间桥和包括非常小的 $\\tau$ 在内的小延迟）：\n  - 状态数：$5$。\n  - 速率矩阵 $K$ 由簇 $\\{0,1,2\\}$ 和 $\\{3,4\\}$ 定义，具有强簇内速率和非常弱的簇间速率：对于 $i \\neq j$，如果 $i,j \\in \\{0,1,2\\}$ 或 $i,j \\in \\{3,4\\}$，则设置 $K_{ij} = 4.0$，否则设置 $K_{ij} = 0.05$。设置每个 $K_{ii} = - \\sum_{j \\neq i} K_{ij}$。\n  - 延迟时间 (微秒)：$\\tau \\in \\{ 0.1, 0.5, 1.0, 2.0 \\}$。\n  - 扰动幅度：$\\delta(\\tau)$ 分别为 $\\in \\{ 0.02, 0.01, 0.005, 0.003 \\}$。\n  - 收敛容差：$\\epsilon = 0.15$。\n\n最终输出格式要求：您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表。此列表中的每个元素对应一个测试用例，并且必须是一个双元素列表，其第一个元素是指定延迟时间的最慢隐含时间尺度列表（单位为微秒，四舍五入到六位小数），第二个元素是表示最慢时间尺度是否根据上述标准收敛的布尔值。例如，输出应类似于 $[[[t_{11},t_{12},t_{13},t_{14}],b_1],[[t_{21},t_{22},t_{23},t_{24}],b_2],[[t_{31},t_{32},t_{33},t_{34}],b_3]]$，其中数值将替换 $t_{ij}$ 占位符。",
            "solution": "该问题要求计算和分析几个马尔可夫状态模型 (MSM) 的隐含时间尺度。该问题牢固地植根于连续时间马尔可夫链理论及其在构建马尔可夫状态模型中的应用，这是计算化学和生物物理学中一种标准且强大的技术。速率矩阵 $K$、转移矩阵 $T(\\tau)$、矩阵指数关系 $T(\\tau) = \\exp(\\tau K)$ 以及隐含时间尺度的公式的定义都是标准且正确的。隐含时间尺度收敛的概念是 MSM 验证的基石。该问题在科学上是健全的。\n\n该算法是确定性的，并且在给定输入的情况下，将产生唯一的、有意义的输出。定义清晰明确。零特征值的边缘情况已明确处理。该问题是适定的。\n\n解决方案需要实现指定的算法，以计算三个不同测试用例中一系列延迟时间 $\\tau$ 的最慢隐含时间尺度 $t_2(\\tau)$。每个测试用例由一个速率矩阵 $K$ 定义，该矩阵描述了底层的连续时间动力学。该过程涉及植根于马尔可夫过程理论的几个关键步骤。\n\n首先，对于每个测试用例，我们构建速率矩阵 $K$。对于 $i \\neq j$ 的元素 $K_{ij}$ 表示从状态 $i$ 转换到状态 $j$ 的速率。对角元素 $K_{ii}$ 由速率矩阵每行必须总和为零的条件确定，即 $K_{ii} = -\\sum_{j \\neq i} K_{ij}$。这确保了概率的守恒。\n\n接下来，对于每个指定的延迟时间 $\\tau$，我们计算“理想”的转移概率矩阵 $T_0(\\tau)$。对于由 $K$ 描述的连续时间马尔可夫过程，在时间间隔 $\\tau$ 内从状态 $i$ 转换到状态 $j$ 的概率由矩阵元素 $[T(\\tau)]_{ij}$ 给出。该矩阵通过矩阵指数计算，即 $T(\\tau) = \\exp(\\tau K)$。\n\n问题引入了一个现实的复杂性：噪声。在实践中，转移概率是从有限的模拟数据中估计的，并会受到统计误差的影响。为了模拟这一点，我们在理想矩阵 $T_0(\\tau)$ 上添加一个确定性扰动 $\\Delta(\\tau) = \\delta(\\tau) N$，其中 $N$ 是一个非对角线元素为 1、对角线元素为 0 的矩阵，而 $\\delta(\\tau)$ 是一个小的、依赖于延迟时间的幅度。这会产生一个扰动矩阵 $\\tilde{T}(\\tau) = T_0(\\tau) + \\Delta(\\tau)$。\n\n这个扰动矩阵 $\\tilde{T}(\\tau)$ 不保证是一个有效的行随机矩阵；其条目可能为负，并且其行和可能不为 $1$。因此，我们必须将其投影回有效随机矩阵的空间。这通过两个步骤实现：首先，所有负条目被裁剪为零，$\\tilde{T}_{ij}(\\tau) \\leftarrow \\max\\{\\tilde{T}_{ij}(\\tau), 0\\}$。其次，每行通过将其元素除以行和来进行归一化。这个两步过程确保了非负性和行和为一的属性。\n\n对于每个延迟时间，有了一个有效的、尽管有噪声的转移矩阵 $\\tilde{T}(\\tau)$，我们继续计算其隐含时间尺度。这涉及到计算 $\\tilde{T}(\\tau)$ 的特征值 $\\lambda_i(\\tau)$。随机矩阵的特征值模长小于或等于 $1$。最大特征值始终为 $\\lambda_1(\\tau) = 1$，对应于稳态分布。其他特征值 $|\\lambda_i(\\tau)|  1$（对于 $i > 1$）描述了向该稳态分布弛豫的时间尺度。与特征值 $\\lambda_i(\\tau)$ 相关的隐含时间尺度 $t_i(\\tau)$ 由基本关系 $t_i(\\tau) = -\\tau / \\ln|\\lambda_i(\\tau)|$ 给出。系统中除了达到稳态之外的最慢过程由最大的非单位特征值模 $|\\lambda_2(\\tau)|$ 捕获。因此，我们为每个 $\\tau$ 计算 $t_2(\\tau)$。根据问题要求，如果 $|\\lambda_2(\\tau)| = 0$，我们定义 $t_2(\\tau)=0$。\n\n最后，MSM 验证的一个关键部分是检查计算出的隐含时间尺度是否相对于延迟时间 $\\tau$ 的选择是恒定的。如果一个 MSM 是对底层动力学的良好近似（即，它是马尔可夫的），那么系统的物理弛豫时间尺度不应依赖于用于构建模型的延迟时间，前提是 $\\tau$ 足够大以解析慢过程，但又不能大到将它们平均掉。我们通过检查最慢时间尺度集合 $\\{ t_2(\\tau_k) \\}$ 来评估这种收敛性。我们关注这些值的后半部分，这对应于马尔可夫性更可能成立的较大延迟时间。我们计算该子集的相对范围 $(t_{\\max} - t_{\\min})/\\bar{t}$，并将其与给定的容差 $\\epsilon$ 进行比较。如果相对范围在容差之内，我们得出结论，最慢时间尺度已经收敛。还处理了平均时间尺度 $\\bar{t}$ 为零的特殊情况。\n\n将整个程序应用于三个测试用例中的每一个，并将结果编译成所需的输出格式。",
            "answer": "```python\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Computes and validates implied timescales for Markov state models.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (happy path, reversible symmetric clusters)\n        {\n            \"n_states\": 4,\n            \"k_rules\": lambda i, j: 6.0 if (i in {0, 1} and j in {0, 1}) or (i in {2, 3} and j in {2, 3}) else 0.2,\n            \"lag_times\": [1.0, 2.0, 5.0, 10.0],\n            \"perturbations\": [0.02, 0.01, 0.005, 0.002],\n            \"epsilon\": 0.1,\n        },\n        # Test case 2 (edge case, 3-state asymmetric ring)\n        {\n            \"n_states\": 3,\n            \"k_rules\": {\n                (0, 1): 1.5, (1, 2): 1.5, (2, 0): 1.5,\n                (1, 0): 1.2, (2, 1): 1.2, (0, 2): 0.8\n            },\n            \"lag_times\": [0.5, 1.0, 2.0, 4.0],\n            \"perturbations\": [0.03, 0.03, 0.03, 0.03],\n            \"epsilon\": 0.05,\n        },\n        # Test case 3 (boundary condition, 5-state with slow bridge)\n        {\n            \"n_states\": 5,\n            \"k_rules\": lambda i, j: 4.0 if (i in {0, 1, 2} and j in {0, 1, 2}) or (i in {3, 4} and j in {3, 4}) else 0.05,\n            \"lag_times\": [0.1, 0.5, 1.0, 2.0],\n            \"perturbations\": [0.02, 0.01, 0.005, 0.003],\n            \"epsilon\": 0.15,\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        n = case[\"n_states\"]\n        k_rules = case[\"k_rules\"]\n        lag_times = case[\"lag_times\"]\n        perturbations = case[\"perturbations\"]\n        epsilon = case[\"epsilon\"]\n        \n        # 1. Construct the rate matrix K\n        K = np.zeros((n, n), dtype=float)\n        if callable(k_rules):\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        K[i, j] = k_rules(i, j)\n        else: # Dictionary-based rules for Test Case 2\n            for (i, j), val in k_rules.items():\n                K[i, j] = val\n        \n        for i in range(n):\n            K[i, i] = -np.sum(K[i, :])\n\n        # Define the off-diagonal pattern matrix N\n        N = np.ones((n, n)) - np.eye(n)\n        \n        slowest_implied_timescales = []\n        \n        for i, tau in enumerate(lag_times):\n            delta_tau = perturbations[i]\n            \n            # 2. Form T0(tau) = exp(tau * K)\n            T0_tau = expm(tau * K)\n            \n            # 3. Add perturbation\n            Delta_tau = delta_tau * N\n            T_tilde_tau = T0_tau + Delta_tau\n            \n            # 4. Project back to row-stochastic\n            # a. Clip to non-negativity\n            T_tilde_tau = np.maximum(T_tilde_tau, 0)\n            # b. Row normalize\n            row_sums = T_tilde_tau.sum(axis=1)\n            # Avoid division by zero for rows that are all zero.\n            non_zero_rows = row_sums > 0\n            T_tilde_tau[non_zero_rows] /= row_sums[non_zero_rows, np.newaxis]\n\n            # 5. Compute eigenvalues and find |lambda_2(tau)|\n            eigenvalues = np.linalg.eigvals(T_tilde_tau)\n            # Sort by descending magnitude\n            sorted_magnitudes = sorted(np.abs(eigenvalues), reverse=True)\n            \n            # The second largest magnitude eigenvalue\n            lambda2_mag = sorted_magnitudes[1]\n            \n            # 6. Compute slowest implied timescale t_2(tau)\n            if lambda2_mag > 0 and np.log(lambda2_mag) != 0:\n                t2_tau = -tau / np.log(lambda2_mag)\n            else:\n                # As per problem spec, if |lambda_2| = 0, t_2 = 0.\n                t2_tau = 0.0\n            \n            slowest_implied_timescales.append(t2_tau)\n        \n        # 7. Assess convergence on the latter half of the timescales\n        split_index = len(slowest_implied_timescales) // 2\n        later_timescales = np.array(slowest_implied_timescales[split_index:])\n        \n        is_converged = False\n        if len(later_timescales) > 0:\n            t_mean = np.mean(later_timescales)\n            if t_mean > 1e-9: # Treat very small means as zero to avoid division by zero\n                t_max = np.max(later_timescales)\n                t_min = np.min(later_timescales)\n                relative_range = (t_max - t_min) / t_mean\n                if relative_range = epsilon:\n                    is_converged = True\n            else: # t_mean is effectively 0\n                # Convergence if and only if all values are identical (and thus 0)\n                if np.max(later_timescales) == np.min(later_timescales):\n                    is_converged = True\n\n        rounded_timescales = [round(t, 6) for t in slowest_implied_timescales]\n        all_results.append([rounded_timescales, is_converged])\n\n    # Final print statement in the exact required format.\n    final_string = str(all_results).replace(\"'\", '\"')\n    final_string = final_string.replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(final_string)\n\nsolve()\n```"
        },
        {
            "introduction": "隐含时间尺度提供了一种诊断视角，而查普曼-科尔莫戈罗夫（Chapman-Kolmogorov, C-K）检验则对MSM的预测能力提供了更严格的统计评估。该检验直接将模型的长期预测与从模拟轨迹中估计的经验数据进行比较。这个动手练习  将指导你实现C-K检验，包括使用后验可信区间来考虑有限采样不确定性的关键步骤，这对于处理真实的、含噪声的数据至关重要。",
            "id": "3838019",
            "problem": "要求您实现并应用Chapman–Kolmogorov检验，以评估一个根据合成的类分子动力学轨迹构建的马尔可夫状态模型（MSM）的有效性。您将以纯数学术语来形式化该检验，并量化该MSM在统计不确定性范围内是否与马尔可夫性质一致。该检验必须在多个延迟步长上应用，并应用于多个合成系统，以探测有效和无效两种情景。\n\n使用以下基本定义和事实。\n\n一个在有限状态空间上的离散时间马尔可夫链，在给定的延迟时间$\\tau$下，有一个行随机转移矩阵，记为$T(\\tau)$，其中每个元素$T(\\tau)_{ij}$满足$T(\\tau)_{ij} \\ge 0$且$\\sum_{j} T(\\tau)_{ij} = 1$。对于基本延迟$\\tau$的整数倍$k$，Chapman–Kolmogorov性质表述为\n$$\nT(k \\tau) = \\left(T(\\tau)\\right)^k,\n$$\n其中上标表示标准矩阵乘法。这一推论是MSM在更长时间尺度上有效性的基础。\n\n给定一个状态轨迹$\\{x_t\\}_{t=0}^{N-1}$，该轨迹是在基本延迟$\\tau$的均匀离散时间步长上采样的，定义延迟为$L$的转移计数矩阵$C^{(L)}$为\n$$\nC_{ij}^{(L)} = \\left|\\left\\{ t \\in \\{0,\\dots,N-L-1\\} : x_t = i,\\, x_{t+L} = j \\right\\}\\right|,\n$$\n其行和为$n_i^{(L)} = \\sum_{j} C_{ij}^{(L)}$。延迟为$L$的转移矩阵的最大似然估计是行归一化的计数，\n$$\n\\hat{T}_{ij}^{(L)} = \n\\begin{cases}\n\\dfrac{C_{ij}^{(L)}}{n_i^{(L)}},  n_i^{(L)}  0, \\\\\n0,  n_i^{(L)} = 0.\n\\end{cases}\n$$\n\n假设对每一行中的每个结果使用一个对称集中度参数为$\\alpha_0$的狄利克雷先验，对于第$i$行，这会导出一个狄利克雷后验$\\text{Dir}(\\alpha_0 + \\mathbf{n}_i)$，其中$\\mathbf{n}_i$表示行计数的向量。元素$p_{ij}^{(L)}$的边缘后验是一个Beta分布，\n$$\np_{ij}^{(L)} \\sim \\text{Beta}\\left(C_{ij}^{(L)} + \\alpha_0,\\, n_i^{(L)} - C_{ij}^{(L)} + (m-1)\\alpha_0\\right),\n$$\n其中$m$是状态数。$p_{ij}^{(L)}$的$100\\gamma\\%$可信区间通过Beta分布的$\\gamma$水平中心分位数获得。\n\n对于一组整数延迟乘子$\\{k\\}$，Chapman–Kolmogorov检验按以下步骤进行：\n1. 从$C^{(1)}$估计基本延迟矩阵$\\hat{T}^{(1)}$。\n2. 对每个$k$，计算Chapman–Kolmogorov预测$\\left(\\hat{T}^{(1)}\\right)^k$，并从$C^{(k)}$估计经验延迟$k$矩阵$\\hat{T}^{(k)}$。\n3. 对每个满足$n_i^{(k)} \\ge n_{\\min}$的行$i$和每个列$j$，使用Beta边缘后验计算$p_{ij}^{(k)}$的后验可信区间$[L_{ij}^{(k)}, U_{ij}^{(k)}]$，并检验预测条目$\\left(\\hat{T}^{(1)}\\right)^k_{ij}$是否位于此区间内。\n4. 将延迟$k$处的覆盖分数定义为\n$$\n\\text{cov}(k) = \\frac{\\text{被覆盖的条目数}}{\\text{被测试的条目数}},\n$$\n其中被测试的条目是指那些满足$n_i^{(k)} \\ge n_{\\min}$的条目。如果$\\text{cov}(k) \\ge \\theta$，则MSM在延迟$k$处通过检验，其中$\\theta$是与所选可信水平相匹配的覆盖阈值。如果MSM对集合中所有的$k$都通过了检验，则宣布该模型对该测试套件有效。\n\n您的任务是实现一个程序，该程序能够：\n- 从指定的真实转移矩阵生成合成轨迹。\n- 在一个基本延迟上构建MSM，对多个$k$执行Chapman–Kolmogorov预测，计算经验延迟$k$转移矩阵，在对称狄利克雷先验下构建后验可信区间，并评估覆盖率。\n\n您的程序必须处理以下参数化的测试用例套件。\n\n测试用例 A（有效MSM，长轨迹）：\n- 状态数 $m = 4$。\n- 真实基本延迟转移矩阵 $T^{\\text{true}}$ 为\n$$\n\\begin{bmatrix}\n0.90  0.07  0.02  0.01 \\\\\n0.06  0.88  0.05  0.01 \\\\\n0.03  0.05  0.88  0.04 \\\\\n0.01  0.02  0.06  0.91\n\\end{bmatrix}.\n$$\n- 轨迹长度 $N = 200000$ 步。\n- 延迟乘子 $\\{k\\} = \\{2,\\,5,\\,10\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$（Jeffreys先验）。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n测试用例 B（有效MSM，短轨迹）：\n- 状态数 $m = 4$。\n- 真实基本延迟转移矩阵 $T^{\\text{true}}$ 与测试用例A相同。\n- 轨迹长度 $N = 10000$ 步。\n- 延迟乘子 $\\{k\\} = \\{2,\\,10,\\,20\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n测试用例 C（投影下的无效MSM，非马尔可夫粗粒化）：\n- 底层微观状态数为 $m_{\\text{micro}} = 3$，标记为$A$、$B$、$C$。\n- 微观状态上的真实基本延迟转移矩阵为\n$$\n\\begin{bmatrix}\n0.75  0.25  0.00 \\\\\n0.10  0.80  0.10 \\\\\n0.00  0.005  0.995\n\\end{bmatrix}.\n$$\n- 观测到的粗粒化通过 $(A \\rightarrow X)$、$(B \\rightarrow Y)$、$(C \\rightarrow X)$ 将微观状态映射到两个宏观状态$X$和$Y$，产生一个观测到的$m = 2$状态过程，该过程由于$A$和$C$的不同逃逸倾向在$X$中产生记忆效应而不是马尔可夫的。\n- 在微观状态上生成长度为$N = 200000$步的轨迹，随后映射到观测到的宏观状态。\n- 延迟乘子 $\\{k\\} = \\{2,\\,5,\\,10\\}$。\n- 对称狄利克雷先验集中度 $\\alpha_0 = 0.5$。\n- 可信水平 $\\gamma = 0.95$。\n- 最小行计数阈值 $n_{\\min} = 50$。\n- 覆盖阈值 $\\theta = 0.95$。\n\n实现要求：\n- 使用固定的随机种子以保证可复现性。\n- 对于每个测试用例，在基本延迟为1时从指定的真实转移矩阵模拟轨迹，估计$\\hat{T}^{(1)}$，计算预测值$\\left(\\hat{T}^{(1)}\\right)^k$，计算经验$\\hat{T}^{(k)}$，基于$\\text{Beta}\\left(C_{ij}^{(k)} + \\alpha_0,\\, n_i^{(k)} - C_{ij}^{(k)} + (m-1)\\alpha_0\\right)$在水平$\\gamma$上构建后验可信区间，并对每个$k$评估$\\text{cov}(k)$。该测试用例返回一个布尔值，指示对于指定集合中的所有$k$，是否都满足$\\text{cov}(k) \\ge \\theta$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，结果为用方括号括起来的逗号分隔列表（例如，“[resultA,resultB,resultC]”），其中每个条目是对应于相应测试用例通过或失败结果的布尔值。",
            "solution": "该问题是有效的。它提出了一个定义明确的计算任务，该任务基于计算统计力学中马尔可夫状态模型（MSM）验证的标准理论。它在科学上是合理的、客观的且完整的。所有参数和程序都已明确指定。\n\n问题的核心是实现并应用Chapman–Kolmogorov（C-K）检验来进行MSM验证。如果底层动力学在所选状态空间上是马尔可夫的，那么MSM是一个有用的近似。C-K性质，$T(k\\tau) = [T(\\tau)]^k$，为这种马尔可夫性提供了一个必要条件。它断言，长延迟时间$k\\tau$的转移概率可以通过简单地传播短基本延迟时间$\\tau$的转移概率来预测。\n\n验证过程涉及将此预测与在较长延迟时间下转移矩阵的经验估计值进行比较。如果系统确实是马尔可夫的，则预测应在统计不确定性范围内与经验测量值一致。该过程如下：\n\n1.  **合成数据生成**：对每个测试用例，模拟一个离散时间的状态轨迹$\\{x_t\\}_{t=0}^{N-1}$。这是通过从一个随机状态（例如，状态0）开始，并根据真实转移矩阵$T^{\\text{true}}$的第$x_t$行定义的多项分布迭代地抽取下一个状态$x_{t+1}$来实现的。对于测试用例C，此模拟在底层的3状态微观状态空间上执行，然后根据指定的粗粒化规则（状态$A \\to X$，$B \\to Y$，$C \\to X$）将所得轨迹映射到观测到的2状态宏观状态空间。已知这种粗粒化会在观测过程中引入非马尔可夫动力学。\n\n2.  **转移矩阵的估计**：\n    -   首先，从生成的轨迹中，我们估计基本延迟转移矩阵$\\hat{T}^{(1)}$，其中延迟为$\\tau=1$个时间步。这通过首先计算转移计数矩阵$C^{(1)}$来完成，其中$C_{ij}^{(1)}$是在一个步骤中从状态$i$到状态$j$的观测转移次数。然后，最大似然估计（MLE）是行归一化的计数矩阵：$\\hat{T}_{ij}^{(1)} = C_{ij}^{(1)} / \\sum_k C_{ik}^{(1)}$。\n    -   对于测试集中的每个延迟乘子$k$，我们计算C-K预测，即基本延迟MLE矩阵的$k$次幂：$T^{\\text{pred}}(k) = (\\hat{T}^{(1)})^k$。\n    -   我们还通过直接计算轨迹中$k$步长的转移来形成$C^{(k)}$，然后进行行归一化，从而计算延迟$k$处的经验转移矩阵$\\hat{T}^{(k)}$。\n\n3.  **通过可信区间的统计比较**：关键步骤是确定预测$T^{\\text{pred}}(k)$和经验估计$\\hat{T}^{(k)}$之间的差异是否具有统计显著性。我们将经验估计不视为单个点，而是视为反映有限抽样不确定性的分布。\n    -   使用带有对称狄利克雷先验（由$\\alpha_0$参数化）的贝叶斯框架，每个转移概率$p_{ij}^{(k)}$的后验分布是Beta分布：$p_{ij}^{(k)} \\sim \\text{Beta}(C_{ij}^{(k)} + \\alpha_0, n_i^{(k)} - C_{ij}^{(k)} + (m-1)\\alpha_0)$，其中$n_i^{(k)} = \\sum_j C_{ij}^{(k)}$是从状态$i$开始在延迟$k$处的总转移数，$m$是状态数。\n    -   对于具有足够统计数据（$n_i^{(k)} \\ge n_{\\min}$）的行$i$中的每个元素$(i,j)$，我们计算一个$100\\gamma\\%$的可信区间$[L_{ij}^{(k)}, U_{ij}^{(k)}]$。该区间由Beta后验分布的下分位数和上分位数定义，具体是$(\\frac{1-\\gamma}{2})$和$(1 - \\frac{1-\\gamma}{2})$分位数。\n    -   然后我们检查预测值$(T^{\\text{pred}}(k))_{ij}$是否落在此区间内：$L_{ij}^{(k)} \\le (T^{\\text{pred}}(k))_{ij} \\le U_{ij}^{(k)}$。\n\n4.  **结论判定**：\n    -   延迟$k$处的覆盖分数$\\text{cov}(k)$计算为预测值落在可信区间内的被测矩阵元素的比例。\n    -   如果此覆盖分数大于或等于阈值$\\theta$，即$\\text{cov}(k) \\ge \\theta$，则认为MSM在延迟$k$处通过了测试。阈值$\\theta$通常设置得等于可信水平$\\gamma$，这反映了对于一个有效的模型，大约$100\\gamma\\%$的预测应该位于其对应的$100\\gamma\\%$可信区间内的期望。\n    -   对于给定的测试用例，最终结果是一个布尔值：如果MSM对所有指定的延迟乘子$\\{k\\}$都通过了测试，则为`True`，否则为`False`。\n\n-   **测试用例A（有效MSM，长轨迹）**：底层过程是马尔可夫的，长轨迹提供了良好的统计数据。我们预计C-K预测将是准确的，并且覆盖分数会很高（接近$\\gamma=0.95$），因此会通过测试。\n-   **测试用例B（有效MSM，短轨迹）**：过程仍然是马尔可夫的，但较短的轨迹导致更大的统计不确定性。这意味着$\\hat{T}^{(k)}$的可信区间会更宽，但初始估计$\\hat{T}^{(1)}$的精度也会降低，导致预测$(\\hat{T}^{(1)})^k$的误差更大。测试结果取决于这些效应中哪一个占主导地位。通常，可信区间的宽度增加足以保持高覆盖率。我们预计此用例会通过。\n-   **测试用例C（无效MSM，粗粒化）**：粗粒化在观测到的动力学中引入了记忆效应，违反了马尔可夫假设。例如，从宏观状态$X$转换到$Y$的概率取决于系统是处于微观状态$A$还是$C$。MSM对这些微观状态进行平均，无法捕捉到这一点。基于错误的马尔可夫假设的C-K预测将系统性地偏离真实的长时程动力学。我们预计覆盖分数将显著低于阈值$\\theta$，导致测试失败。",
            "answer": "```python\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Main function to run the Chapman-Kolmogorov test suite.\n    \"\"\"\n    # Set a fixed random seed for reproducibility.\n    np.random.seed(42)\n\n    # Define the test cases from the problem statement.\n    T_true_A_B = np.array([\n        [0.90, 0.07, 0.02, 0.01],\n        [0.06, 0.88, 0.05, 0.01],\n        [0.03, 0.05, 0.88, 0.04],\n        [0.01, 0.02, 0.06, 0.91]\n    ])\n\n    T_true_C_micro = np.array([\n        [0.75, 0.25, 0.00],\n        [0.10, 0.80, 0.10],\n        [0.00, 0.005, 0.995]\n    ])\n\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"m\": 4,\n            \"T_true\": T_true_A_B,\n            \"N\": 200000,\n            \"lags\": [2, 5, 10],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95\n        },\n        {\n            \"name\": \"B\",\n            \"m\": 4,\n            \"T_true\": T_true_A_B,\n            \"N\": 10000,\n            \"lags\": [2, 10, 20],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95\n        },\n        {\n            \"name\": \"C\",\n            \"m\": 2, # Number of macrostates\n            \"m_micro\": 3,\n            \"T_true\": T_true_C_micro,\n            \"N\": 200000,\n            \"lags\": [2, 5, 10],\n            \"alpha0\": 0.5,\n            \"gamma\": 0.95,\n            \"n_min\": 50,\n            \"theta\": 0.95,\n            \"coarse_grain_map\": np.array([0, 1, 0]) # A->X(0), B->Y(1), C->X(0)\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        case_result = run_ck_test(case)\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\n\ndef generate_trajectory(T_true, N, start_state=0):\n    \"\"\"\n    Generates a trajectory from a discrete-time Markov chain.\n    \"\"\"\n    num_states = T_true.shape[0]\n    traj = np.zeros(N, dtype=int)\n    traj[0] = start_state\n    for t in range(N - 1):\n        next_state_probs = T_true[traj[t], :]\n        traj[t+1] = np.random.choice(num_states, p=next_state_probs)\n    return traj\n\n\ndef get_count_matrix(trajectory, m, lag):\n    \"\"\"\n    Computes the transition count matrix for a given lag time.\n    \"\"\"\n    C = np.zeros((m, m), dtype=int)\n    for t in range(len(trajectory) - lag):\n        i = trajectory[t]\n        j = trajectory[t+lag]\n        C[i, j] += 1\n    return C\n\n\ndef get_mle_t_matrix(C):\n    \"\"\"\n    Computes the MLE transition matrix from a count matrix.\n    \"\"\"\n    m = C.shape[0]\n    T_mle = np.zeros((m, m))\n    row_sums = C.sum(axis=1)\n    # Using np.where to avoid division by zero\n    T_mle = np.where(row_sums[:, None] > 0, C / row_sums[:, None], 0)\n    return T_mle\n\n\ndef run_ck_test(params):\n    \"\"\"\n    Runs the full Chapman-Kolmogorov test for a single parameter set.\n    \"\"\"\n    m = params[\"m\"]\n    N = params[\"N\"]\n    T_true = params[\"T_true\"]\n    lags = params[\"lags\"]\n    alpha0 = params[\"alpha0\"]\n    gamma = params[\"gamma\"]\n    n_min = params[\"n_min\"]\n    theta = params[\"theta\"]\n\n    # --- 1. Generate Trajectory ---\n    if \"coarse_grain_map\" in params:\n        micro_traj = generate_trajectory(T_true, N)\n        trajectory = params[\"coarse_grain_map\"][micro_traj]\n    else:\n        trajectory = generate_trajectory(T_true, N)\n\n    # --- 2. Estimate Base-Lag Matrix ---\n    C1 = get_count_matrix(trajectory, m, lag=1)\n    T_hat_1 = get_mle_t_matrix(C1)\n\n    case_passes = True\n    for k in lags:\n        # --- 3. C-K Prediction ---\n        T_pred_k = np.linalg.matrix_power(T_hat_1, k)\n\n        # --- 4. Empirical Lag-k Matrix ---\n        Ck = get_count_matrix(trajectory, m, lag=k)\n        \n        # --- 5. Statistical Comparison ---\n        covered_entries = 0\n        tested_entries = 0\n        \n        row_sums_k = Ck.sum(axis=1)\n        \n        for i in range(m):\n            if row_sums_k[i]  n_min:\n                continue\n            \n            for j in range(m):\n                tested_entries += 1\n                \n                # Beta posterior parameters\n                alpha_post = Ck[i, j] + alpha0\n                beta_post = row_sums_k[i] - Ck[i, j] + (m - 1) * alpha0\n                \n                # Credible interval\n                q_low = (1.0 - gamma) / 2.0\n                q_high = 1.0 - q_low\n                \n                lower_bound = beta.ppf(q_low, alpha_post, beta_post)\n                upper_bound = beta.ppf(q_high, alpha_post, beta_post)\n\n                # Check if prediction is covered\n                prediction = T_pred_k[i, j]\n                if lower_bound = prediction = upper_bound:\n                    covered_entries += 1\n        \n        # --- 6. Verdict ---\n        if tested_entries > 0:\n            coverage_fraction = covered_entries / tested_entries\n        else: # No rows met n_min, technically passes as no violations found.\n            coverage_fraction = 1.0\n\n        if coverage_fraction  theta:\n            case_passes = False\n            break # Fail fast, no need to check other lags for this case\n\n    return case_passes\n\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}