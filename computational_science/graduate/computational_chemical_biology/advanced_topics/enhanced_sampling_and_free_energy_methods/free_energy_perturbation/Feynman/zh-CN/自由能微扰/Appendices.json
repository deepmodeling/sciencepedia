{
    "hands_on_practices": [
        {
            "introduction": "自由能微扰（FEP）的核心是 Zwanzig 方程，它将两个态之间的自由能差与系综平均值联系起来。本练习通过一个简单但极其重要的物理模型——谐振子，从第一性原理出发，推导此核心恒等式。通过分别从系综平均和配分函数比率两种途径进行推导，你将不仅能验证该公式的正确性，还能加深对其统计力学根源的理解。",
            "id": "3847564",
            "problem": "考虑一个经典的一维系统，在固定温度 $T$ 下，由单一坐标 $x$ 和两个谐波势能函数描述：$U_{A}(x)=\\tfrac{1}{2}k_{A}x^{2}$ 和 $U_{B}(x)=\\tfrac{1}{2}k_{B}x^{2}$，其中 $k_{A}>0$ 和 $k_{B}>0$ 是力常数。仅使用正则系综的定义和经典统计力学的基本事实，用两种方法推导状态 $B$ 和状态 $A$ 之间的自由能差 $\\Delta F \\equiv F_{B}-F_{A}$：\n1. 从 $U_{A}(x)$ 下的正则平均定义出发，计算系综平均 $\\langle \\exp(-\\beta\\Delta U)\\rangle_{A}$，其中 $\\Delta U(x)\\equiv U_{B}(x)-U_{A}(x)$ 且 $\\beta\\equiv 1/(k_{\\mathrm{B}}T)$，$k_{\\mathrm{B}}$ 是玻尔兹曼常数。使用此平均值获得 $\\Delta F$ 的解析表达式，除了正则定义外，不借助任何预先陈述的恒等式。\n2. 独立计算 $U_{B}$ 和 $U_{A}$ 的精确构型配分函数之比，并用它来获得 $\\Delta F$。证明两个结果一致。\n\n假设哈密顿量可分离为动能和势能部分，并注意，由于状态 $A$ 和 $B$ 中的动能相同，任何动量贡献在自由能差中都会抵消。请以 $k_{A}$、$k_{B}$、$k_{\\mathrm{B}}$ 和 $T$ 的单一闭合形式表达式给出 $\\Delta F$ 的最终答案。自由能以焦耳表示。不需要进行数值计算或四舍五入。",
            "solution": "该问题要求推导亥姆霍兹自由能差 $\\Delta F \\equiv F_{B}-F_{A}$，该差值存在于由谐波势能函数 $U_{A}(x)=\\tfrac{1}{2}k_{A}x^{2}$ 和 $U_{B}(x)=\\tfrac{1}{2}k_{B}x^{2}$ 描述的一维经典系统的两个状态之间。推导必须以两种不同的方式进行，以证明它们的等价性。我们已知逆温度 $\\beta \\equiv 1/(k_{\\mathrm{B}}T)$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是固定温度。\n\n首先，我们建立自由能和配分函数之间的基本关系。亥姆霍兹自由能 $F$ 由总正则配分函数 $Z$ 定义为：\n$$F = -k_{\\mathrm{B}}T \\ln Z = -\\frac{1}{\\beta} \\ln Z$$\n对于具有可分离哈密顿量 $H(p,x) = K(p) + U(x)$ 的一维系统，总配分函数 $Z$ 由对所有相空间坐标 $(p,x)$ 的积分给出：\n$$Z = \\frac{1}{h} \\int \\int \\exp(-\\beta H(p,x)) dp dx = \\left(\\frac{1}{h} \\int \\exp(-\\beta K(p)) dp\\right) \\left(\\int \\exp(-\\beta U(x)) dx\\right)$$\n其中 $h$ 是一个具有作用量单位的常数，以使 $Z$ 无量纲，通常是普朗克常数。我们可以将其写为 $Z = Z_{\\mathrm{kin}} Q$，其中 $Z_{\\mathrm{kin}}$ 是动能贡献，$Q$ 是构型配分函数，$Q = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U(x)) dx$。\n\n自由能差 $\\Delta F$ 为：\n$$\\Delta F = F_{B} - F_{A} = \\left(-\\frac{1}{\\beta} \\ln Z_{B}\\right) - \\left(-\\frac{1}{\\beta} \\ln Z_{A}\\right) = -\\frac{1}{\\beta} \\ln\\left(\\frac{Z_{B}}{Z_{A}}\\right)$$\n由于状态 $A$ 和 $B$ 的动能项 $K(p)$ 相同，它们的动能配分函数 $Z_{\\mathrm{kin},A}$ 和 $Z_{\\mathrm{kin},B}$ 是相同的。因此，总配分函数之比简化为构型配分函数之比：\n$$\\frac{Z_{B}}{Z_{A}} = \\frac{Z_{\\mathrm{kin}} Q_{B}}{Z_{\\mathrm{kin}} Q_{A}} = \\frac{Q_{B}}{Q_{A}}$$\n因此，自由能差与构型配分函数直接相关：\n$$\\Delta F = -\\frac{1}{\\beta} \\ln\\left(\\frac{Q_{B}}{Q_{A}}\\right)$$\n这个从正则定义推导出的关系，将是两种方法的核心。\n\n**方法一：使用系综平均进行推导**\n\n此方法要求我们计算系综平均 $\\langle \\exp(-\\beta\\Delta U)\\rangle_{A}$ 并将其与 $\\Delta F$ 联系起来。首先，我们必须按要求从基本定义推导出这种关系。\n\n在状态 $A$ 中，一个量 $O(x)$ 的正则系综平均定义为：\n$$\\langle O(x) \\rangle_{A} = \\frac{\\int_{-\\infty}^{\\infty} O(x) \\exp(-\\beta U_{A}(x)) dx}{\\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{A}(x)) dx} = \\frac{\\int_{-\\infty}^{\\infty} O(x) \\exp(-\\beta U_{A}(x)) dx}{Q_{A}}$$\n我们感兴趣的是 $O(x) = \\exp(-\\beta\\Delta U(x))$ 的特定平均值，其中 $\\Delta U(x) = U_{B}(x) - U_{A}(x)$。将其代入定义：\n$$\\langle \\exp(-\\beta\\Delta U) \\rangle_{A} = \\frac{\\int_{-\\infty}^{\\infty} \\exp(-\\beta(U_{B}(x) - U_{A}(x))) \\exp(-\\beta U_{A}(x)) dx}{Q_{A}}$$\n通过合并分子中的指数，我们发现：\n$$\\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{B}(x) + \\beta U_{A}(x) - \\beta U_{A}(x)) dx = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{B}(x)) dx = Q_{B}$$\n因此，系综平均恰好是构型配分函数之比：\n$$\\langle \\exp(-\\beta\\Delta U) \\rangle_{A} = \\frac{Q_{B}}{Q_{A}}$$\n将此结果与前面推导的 $\\Delta F$ 表达式结合，我们得到自由能微扰恒等式：\n$$\\Delta F = -k_{\\mathrm{B}}T \\ln \\langle \\exp(-\\beta\\Delta U) \\rangle_{A}$$\n现在，我们为给定的势能显式计算平均值。势能差为：\n$$\\Delta U(x) = U_{B}(x) - U_{A}(x) = \\frac{1}{2}k_{B}x^{2} - \\frac{1}{2}k_{A}x^{2} = \\frac{1}{2}(k_{B} - k_{A})x^{2}$$\n系综平均为：\n$$\\langle \\exp(-\\beta\\Delta U) \\rangle_{A} = \\frac{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\left(\\frac{1}{2}(k_{B}-k_{A})x^{2}\\right)\\right) \\exp\\left(-\\beta \\left(\\frac{1}{2}k_{A}x^{2}\\right)\\right) dx}{\\int_{-\\infty}^{\\infty} \\exp\\left(-\\beta \\left(\\frac{1}{2}k_{A}x^{2}\\right)\\right) dx}$$\n分子的积分为：\n$$I_{\\mathrm{num}} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta}{2}(k_{B}-k_{A}+k_{A})x^{2}\\right) dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_{B}}{2}x^{2}\\right) dx$$\n分母的积分为：\n$$I_{\\mathrm{den}} = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_{A}}{2}x^{2}\\right) dx$$\n这些是标准高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2})dx = \\sqrt{\\pi/a}$。\n对于分子，$a = \\frac{\\beta k_{B}}{2}$，所以 $I_{\\mathrm{num}} = \\sqrt{\\frac{2\\pi}{\\beta k_{B}}}$。\n对于分母，$a = \\frac{\\beta k_{A}}{2}$，所以 $I_{\\mathrm{den}} = \\sqrt{\\frac{2\\pi}{\\beta k_{A}}}$。\n系综平均是这两个结果的比值：\n$$\\langle \\exp(-\\beta\\Delta U) \\rangle_{A} = \\frac{\\sqrt{2\\pi/(\\beta k_{B})}}{\\sqrt{2\\pi/(\\beta k_{A})}} = \\sqrt{\\frac{2\\pi}{\\beta k_{B}} \\cdot \\frac{\\beta k_{A}}{2\\pi}} = \\sqrt{\\frac{k_{A}}{k_{B}}}$$\n最后，我们将其代入 $\\Delta F$ 的表达式中：\n$$\\Delta F = -k_{\\mathrm{B}}T \\ln\\left(\\sqrt{\\frac{k_{A}}{k_{B}}}\\right) = -k_{\\mathrm{B}}T \\ln\\left(\\left(\\frac{k_{A}}{k_{B}}\\right)^{1/2}\\right) = -\\frac{1}{2}k_{\\mathrm{B}}T \\ln\\left(\\frac{k_{A}}{k_{B}}\\right)$$\n使用对数性质 $\\ln(1/x) = -\\ln(x)$，这可以写成：\n$$\\Delta F = \\frac{1}{2}k_{\\mathrm{B}}T \\ln\\left(\\frac{k_{B}}{k_{A}}\\right)$$\n\n**方法二：使用配分函数之比进行推导**\n\n该方法直接从构型配分函数之比 $Q_{B}/Q_{A}$ 计算 $\\Delta F$。如引言中所述，$\\Delta F = -k_{\\mathrm{B}}T \\ln(Q_{B}/Q_{A})$。\n\n状态 $A$ 和 $B$ 的构型配分函数为：\n$$Q_{A} = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{A}(x)) dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_{A}}{2}x^{2}\\right) dx$$\n$$Q_{B} = \\int_{-\\infty}^{\\infty} \\exp(-\\beta U_{B}(x)) dx = \\int_{-\\infty}^{\\infty} \\exp\\left(-\\frac{\\beta k_{B}}{2}x^{2}\\right) dx$$\n使用高斯积分结果 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2})dx = \\sqrt{\\pi/a}$，我们计算每个配分函数：\n$$Q_{A} = \\sqrt{\\frac{\\pi}{(\\beta k_{A}/2)}} = \\sqrt{\\frac{2\\pi}{\\beta k_{A}}}$$\n$$Q_{B} = \\sqrt{\\frac{\\pi}{(\\beta k_{B}/2)}} = \\sqrt{\\frac{2\\pi}{\\beta k_{B}}}$$\n接下来，我们计算它们的比值：\n$$\\frac{Q_{B}}{Q_{A}} = \\frac{\\sqrt{2\\pi/(\\beta k_{B})}}{\\sqrt{2\\pi/(\\beta k_{A})}} = \\sqrt{\\frac{k_{A}}{k_{B}}}$$\n将此比值代入自由能差的方程中：\n$$\\Delta F = -k_{\\mathrm{B}}T \\ln\\left(\\frac{Q_{B}}{Q_{A}}\\right) = -k_{\\mathrm{B}}T \\ln\\left(\\sqrt{\\frac{k_{A}}{k_{B}}}\\right)$$\n这可以简化为：\n$$\\Delta F = -\\frac{1}{2}k_{\\mathrm{B}}T \\ln\\left(\\frac{k_{A}}{k_{B}}\\right) = \\frac{1}{2}k_{\\mathrm{B}}T \\ln\\left(\\frac{k_{B}}{k_{A}}\\right)$$\n\n**结论**\n\n两种方法都得出了相同的自由能差结果：$\\Delta F = \\frac{1}{2}k_{\\mathrm{B}}T \\ln(k_{B}/k_{A})$。这证实了两种方法的一致性，它们都是统计力学和计算自由能计算的基石。该表达式具有能量单位（国际单位制中为焦耳），因为乘积 $k_{\\mathrm{B}}T$ 具有能量单位，而对数项是无量纲的。",
            "answer": "$$\n\\boxed{\\frac{1}{2} k_{\\mathrm{B}}T \\ln\\left(\\frac{k_{B}}{k_{A}}\\right)}\n$$"
        },
        {
            "introduction": "虽然 FEP 的核心方程在理论上是精确的，但在实际应用中却面临着巨大挑战，尤其是在采样不足和相空间重叠度低的情况下。这个编码练习旨在让你亲身体验这些局限性。你将通过一个数值实验，探究对于一个简单的谐振子系统，当微扰（即两个态之间的差异）变得多大时，单步 FEP 估算器的误差会大到失去实际应用价值，从而直观地理解 FEP 方法的“断裂点”。",
            "id": "2455879",
            "problem": "您需要研究一个简单的、可解析处理的系统中的单步自由能微扰 (FEP) 估计量，并确定它在何种情况下会变得实际上不可用。此处“不可用”的定义是其产生的相对绝对误差严格大于 $1$（即大于 $100$ 百分比）。考虑一个经典的一维谐振子，其初始态 $0$ 的势能为 $U_0(x) = \\tfrac{1}{2} k_0 x^2$，微扰态 $1$ 的势能为 $U_1(x) = \\tfrac{1}{2} k_1 x^2$。在无量纲单位下进行计算，使得逆热能为 $\\beta = 1$，并选择 $k_0 = 1$，因此无量纲微扰比为 $r = k_1/k_0 = k_1$。精确的亥姆霍兹自由能差为\n$$\n\\Delta F_{\\text{true}} = \\tfrac{1}{2} \\ln r,\n$$\n该公式由谐振子的精确配分函数导出。基于从态 $0$ 的平衡分布（其密度为 $p_0(x) \\propto \\exp\\{-U_0(x)\\}$）中抽取的 $N$ 个独立同分布样本 $x_i$，单步 FEP 估计量为\n$$\n\\widehat{\\Delta F}_N = - \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} \\exp\\left[-\\left(U_1(x_i) - U_0(x_i)\\right)\\right] \\right).\n$$\n将相对绝对误差定义为\n$$\n\\varepsilon = \n\\begin{cases}\n\\frac{\\left|\\widehat{\\Delta F}_N - \\Delta F_{\\text{true}}\\right|}{\\left|\\Delta F_{\\text{true}}\\right|},  \\text{若 } \\Delta F_{\\text{true}} \\neq 0, \\\\\n0,  \\text{若 } \\Delta F_{\\text{true}} = 0 \\text{ 且 } \\widehat{\\Delta F}_N = 0, \\\\\n+\\infty,  \\text{若 } \\Delta F_{\\text{true}} = 0 \\text{ 且 } \\widehat{\\Delta F}_N \\neq 0.\n\\end{cases}\n$$\n对于一个给定的候选比率有限集 $r \\in \\mathcal{R}$，将微扰幅度定义为\n$$\nm(r) = \\max\\{r, 1/r\\},\n$$\n并将给定测试用例的阈值幅度定义为所有满足 $\\varepsilon > 1$ 的 $r \\in \\mathcal{R}$ 中最小的 $m(r)$。如果没有 $r \\in \\mathcal{R}$ 导致 $\\varepsilon > 1$，则输出 $-1.0$。\n\n您的任务是实现一个完整的程序，针对以下每个测试用例，计算上述定义的阈值幅度。所有计算都应在所述的无量纲化设置中进行，且最终输出必须是浮点数。\n\n测试套件：\n- 案例 A: $N = 8$, $\\mathcal{R} = \\{1.0, 2.0, 4.0, 8.0, 16.0\\}$。\n- 案例 B: $N = 64$, $\\mathcal{R} = \\{0.9, 0.7, 0.5, 0.3, 0.2, 2.0, 4.0, 8.0\\}$。\n- 案例 C: $N = 1024$, $\\mathcal{R} = \\{0.2, 0.1, 8.0, 16.0\\}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 A、B、C 各自的阈值幅度，形式为用方括号括起来的逗号分隔列表（例如，“[2.0,-1.0,8.0]”）。所有输出均为无量纲浮点数。",
            "solution": "该问题要求分析单步自由能微扰 (FEP) 估计量的实际可用性极限，该极限定义为相对绝对误差 $\\varepsilon$ 超过 $1$ 的点。所考虑的系统是一个从初始态 $0$ 过渡到微扰态 $1$ 的一维经典谐振子。\n\n各态的势能由 $U_0(x) = \\frac{1}{2} k_0 x^2$ 和 $U_1(x) = \\frac{1}{2} k_1 x^2$ 给出。问题在无量纲单位下进行操作，其中逆热能为 $\\beta = (k_B T)^{-1} = 1$，初始弹簧常数为 $k_0 = 1$。微扰由无量纲比率 $r = k_1/k_0 = k_1$ 来表征。\n\n初始态 $0$ 的平衡概率分布由玻尔兹曼分布给出，$p_0(x) \\propto \\exp(-\\beta U_0(x))$。使用指定的参数，该分布变为 $p_0(x) \\propto \\exp(-\\frac{1}{2}x^2)$。这是标准正态分布 $\\mathcal{N}(0, 1)$ 的概率密度函数。因此，从态 $0$ 的平衡分布中生成 $N$ 个独立同分布的样本 $\\{x_i\\}_{i=1}^N$，其正确实现方式是从 $\\mathcal{N}(0, 1)$ 中抽取 $N$ 个随机变量。\n\n亥姆霍兹自由能差 $\\Delta F = F_1 - F_0$ 的单步 FEP 估计量（也称为 Zwanzig 方程）由下式给出：\n$$\n\\widehat{\\Delta F}_N = - \\frac{1}{\\beta} \\ln\\left\\langle \\exp\\left[-\\beta\\left(U_1(x) - U_0(x)\\right)\\right] \\right\\rangle_0\n$$\n尖括号 $\\langle \\cdot \\rangle_0$ 表示对从态 $0$ 的分布中抽取的构型 $x$ 进行的系综平均。对于大小为 $N$ 的有限样本，这通过简单的算术平均来近似：\n$$\n\\widehat{\\Delta F}_N = - \\frac{1}{\\beta} \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} \\exp\\left[-\\beta\\left(U_1(x_i) - U_0(x_i)\\right)\\right] \\right)\n$$\n给定 $\\beta=1$，势能差为 $\\Delta U(x_i) = U_1(x_i) - U_0(x_i) = \\frac{1}{2}k_1 x_i^2 - \\frac{1}{2}k_0 x_i^2 = \\frac{1}{2}(r-1)x_i^2$。因此，该估计量的工作公式为：\n$$\n\\widehat{\\Delta F}_N = - \\ln\\left( \\frac{1}{N} \\sum_{i=1}^{N} \\exp\\left[-\\frac{1}{2}(r-1)x_i^2\\right] \\right)\n$$\n该系统自由能差的精确解析解为 $\\Delta F_{\\text{true}} = \\frac{1}{2\\beta} \\ln(k_1/k_0)$，简化后为 $\\Delta F_{\\text{true}} = \\frac{1}{2}\\ln r$。误差使用问题陈述中定义的相对绝对误差 $\\varepsilon$ 进行评估。\n\nFEP 估计量可靠性的一个关键考量是指数项 $W = \\exp(-\\beta \\Delta U)$ 的方差。估计量 $\\widehat{\\Delta F}_N$ 的方差与 $\\text{Var}(W) = \\langle W^2 \\rangle_0 - \\langle W \\rangle_0^2$ 有关。二阶矩 $\\langle W^2 \\rangle_0$ 由以下积分给出：\n$$\n\\langle W^2 \\rangle_0 = \\int_{-\\infty}^{\\infty} \\exp\\left[-2\\beta \\Delta U(x)\\right] p_0(x) dx = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{2\\pi}}\\exp\\left[-(r-1)x^2\\right] \\exp\\left[-\\frac{1}{2}x^2\\right] dx\n$$\n$$\n\\langle W^2 \\rangle_0 = \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\infty}^{\\infty} \\exp\\left[-\\left( (r-1) + \\frac{1}{2} \\right)x^2\\right] dx\n$$\n为使该高斯积分收敛，指数中的二次项必须为正：$(r-1) + \\frac{1}{2} > 0$，简化后为 $r > \\frac{1}{2}$。如果 $r \\le \\frac{1}{2}$，则 $W$ 的方差为无穷大。这表明 FEP 估计量在统计上是病态的；有限样本的平均值将被罕见的极端事件所主导，且无法可靠地收敛。因此，对于任何 $r \\le \\frac{1}{2}$ 的情况，都预期会产生巨大误差。\n\n此外，对于 $r \\gg 1$ 的情况，目标势能 $U_1$ 比采样势能 $U_0$ 窄得多（更陡峭）。采样分布 $p_0(x)$ 很宽，而被平均的项 $ W(x) = \\exp[-\\frac{1}{2}(r-1)x^2] $ 在 $x=0$ 处非常尖锐。这表示相空间交叠很差。大多数样本 $x_i$ 将从 $W(x_i)$ 几乎为零的区域中抽取，导致对真实平均值的系统性低估。这种欠采样也会导致高方差和巨大误差。\n\n因此，对于大的微扰比 ($r \\gg 1$) 和比率 $r \\le \\frac{1}{2}$，FEP 估计量都预期会失效（即产生 $\\varepsilon > 1$）。任务是找到在给定的比率集 $\\mathcal{R}$ 中，导致此失效发生的最小微扰幅度 $m(r) = \\max\\{r, 1/r\\}$。\n\n对于每个测试用例 $(N, \\mathcal{R})$，计算算法如下：\n$1$. 使用固定的随机种子以确保随机结果是可复现的。\n$2$. 对每个测试用例，初始化一个空列表，用于存储满足误差标准 $\\varepsilon > 1$ 的幅度 $m(r)$。\n$3$. 遍历 $\\mathcal{R}$ 中的每个比率 $r$：\n    a. 如果 $r=1$，则 $\\Delta F_{\\text{true}} = 0$ 且 $\\widehat{\\Delta F}_N = 0$，因此 $\\varepsilon=0$。不满足标准。\n    b. 如果 $r \\ne 1$，从 $\\mathcal{N}(0, 1)$ 生成 $N$ 个样本 $\\{x_i\\}$。\n    c. 计算 $\\Delta F_{\\text{true}} = \\frac{1}{2}\\ln r$。\n    d. 使用 FEP 公式计算估计值 $\\widehat{\\Delta F}_N$。\n    e. 计算相对绝对误差 $\\varepsilon = |\\widehat{\\Delta F}_N - \\Delta F_{\\text{true}}| / |\\Delta F_{\\text{true}}|$。\n    f. 如果 $\\varepsilon > 1$，计算微扰幅度 $m(r) = \\max\\{r, 1/r\\}$ 并将其添加到失效幅度列表中。\n$4$. 在评估完所有 $r \\in \\mathcal{R}$ 后，确定阈值幅度。如果失效幅度列表为空，则该测试用例的结果为 $-1.0$。否则，结果为该列表中的最小值。对所有测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the threshold perturbation magnitude for FEP estimator failure.\n    \"\"\"\n    \n    # Set a fixed random seed for reproducibility of the stochastic simulation.\n    np.random.seed(0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (N, R_set)\n        (8, [1.0, 2.0, 4.0, 8.0, 16.0]),\n        # Case B: (N, R_set)\n        (64, [0.9, 0.7, 0.5, 0.3, 0.2, 2.0, 4.0, 8.0]),\n        # Case C: (N, R_set)\n        (1024, [0.2, 0.1, 8.0, 16.0]),\n    ]\n\n    results = []\n    \n    for N, R_set in test_cases:\n        failing_magnitudes = []\n        \n        for r in R_set:\n            # Case r=1 is a special case.\n            # Delta_F_true is 0. Delta_U is 0, so exp(-Delta_U) is 1.\n            # The average is 1, and log(1) is 0. So F_est is 0.\n            # Per problem definition, error is 0.\n            if r == 1.0:\n                error = 0.0\n            else:\n                # 1. Generate N samples from the equilibrium distribution of state 0,\n                # which is a standard normal distribution N(0, 1).\n                # The parameters k0=1 and beta=1 lead to variance = (k0*beta)^-1 = 1.\n                x_samples = np.random.randn(N)\n                \n                # 2. Calculate the true free energy difference.\n                delta_F_true = 0.5 * np.log(r)\n                \n                # 3. Calculate the FEP estimate.\n                # Delta_U = 0.5 * (k1 - k0) * x^2, with k1=r, k0=1.\n                delta_U = 0.5 * (r - 1.0) * x_samples**2\n                \n                # The argument of the logarithm in the FEP formula\n                fep_average = np.mean(np.exp(-delta_U))\n                \n                # The FEP estimate\n                # The average is always > 0, so no domain error for log.\n                delta_F_est = -np.log(fep_average)\n                \n                # 4. Calculate the relative absolute error.\n                # The case delta_F_true == 0 is handled by r == 1.0 check.\n                error = np.abs(delta_F_est - delta_F_true) / np.abs(delta_F_true)\n\n            # 5. Check if the error exceeds the threshold.\n            if error > 1.0:\n                perturbation_magnitude = max(r, 1.0 / r)\n                failing_magnitudes.append(perturbation_magnitude)\n                \n        # 6. Determine the threshold magnitude for the test case.\n        if not failing_magnitudes:\n            threshold_magnitude = -1.0\n        else:\n            threshold_magnitude = min(failing_magnitudes)\n        \n        results.append(threshold_magnitude)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "为了克服单步 FEP 的局限性，研究人员发展了更稳健和高效的方法，其中多态贝内特接受率比（MBAR）方法是当前最先进的技术之一。MBAR 通过整合来自多个中间态的采样数据，能够极大地提高自由能估算的准确性和精度。这个综合性练习将指导你从基本原理出发，推导并实现 MBAR 的自洽方程及其误差估计算法，让你深入掌握这一现代自由能计算的核心工具。",
            "id": "3847551",
            "problem": "给定一个样本集合，这些样本是从多个热力学态中抽取的，并由 $k \\in \\{0,1,\\ldots,K-1\\}$ 索引，每个热力学态由一个约化势 $u_k(\\mathbf{x})$ 表征。约化势定义为 $u_k(\\mathbf{x}) = \\beta U_k(\\mathbf{x}) + \\text{在恒定热力学参数下的项}$，其中 $U_k(\\mathbf{x})$ 是势能。在下文中，您可以取 $\\beta = 1$（无量纲温度），并将所有约化势视为无量纲量。目标是使用称为多态贝内特接受率（Multi-state Bennett Acceptance Ratio, MBAR）的多态最大似然方法，从跨多个态合并的数据中估计无量纲自由能 $f_k$（允许相差一个加性常数）。您必须推导、实现并应用相关的自洽方程和一个数值稳定的迭代方案，以计算自由能及其不确定度。\n\n从平衡态统计力学和重要性抽样的基本原理出发，仅使用以下核心事实：\n- 配分函数为 $Z_k = \\int d\\mathbf{x}\\, e^{-u_k(\\mathbf{x})}$，无量纲自由能为 $f_k = -\\ln Z_k$（允许相差一个加性常数）。\n- 样本是从对应于状态 $k$ 的 $K$ 个平衡分布的混合中抽取的，已知每个状态的样本数 $N_k$ 和总样本数 $N = \\sum_{k=0}^{K-1} N_k$。\n- 对于已知抽样比例的混合模型，重要性抽样恒等式和最大似然估计可以导出用于使观测到的合并数据的似然最大化的参数的自洽估计方程。\n- 最大似然估计量的渐近协方差由观测到的费雪信息（对数似然函数的负海森矩阵）的逆矩阵给出，并投影以消除由 $f_k$ 的加性规范不变性引起的不可辨识性。\n\n您的任务是：\n- 推导 MBAR 自洽方程，这些方程根据所有状态 $k$ 和合并样本 $\\{\\mathbf{x}_n\\}_{n=1}^N$ 的约化势 $u_k(\\mathbf{x}_n)$ 以及已知的样本数 $N_k$，确定 $K$ 个未知的自由能 $f_k$（定义允许相差一个加性常数）。\n- 提出一个数值稳定的不动点迭代方案来求解这些方程。您的方案必须明确使用 log-sum-exp 技巧以确保数值稳定性，通过固定 $f_0 = 0$ 来施加参考规范，并包含一个基于 $f_k$ 的最大绝对变化小于用户指定容差的收敛判据。\n- 根据解所蕴含的状态责任权重，推导已估计的 $f_k$ 的观测费雪信息，解释如何通过将信息矩阵约化到一个满秩子空间（例如，通过锚定 $f_0 = 0$）来处理加性常数的不可辨识性，并获得自由能差 $\\Delta f_{k0} = f_k - f_0$ 的渐近标准误差。\n\n然后，实现一个完整的程序，该程序：\n- 使用 $\\beta = 1$ 的一维谐振子约化势构建合成测试数据。对于每个状态 $k$，定义一个谐振子约化势 $u_k(x) = \\tfrac{1}{2}\\,k_{\\text{spring}}\\,(x - \\mu_k)^2$，并从相应的平衡分布 $p_k(x) \\propto \\exp\\!\\left[-u_k(x)\\right]$（对于谐振子是均值为 $\\mu_k$、方差为 $1/k_{\\text{spring}}$ 的正态分布）中抽取 $N_k$ 个独立样本 $x$。\n- 从合并的样本集 $\\{x_n\\}_{n=1}^N$ 中，构建对于所有 $k \\in \\{0,\\ldots,K-1\\}$ 和 $n \\in \\{1,\\ldots,N\\}$ 的完整约化势矩阵 $[u_k(x_n)]$。\n- 通过您提出的迭代方案求解 $f_k$ 的 MBAR 自洽方程，通过设置 $f_0 = 0$ 固定参考态，计算 $k \\in \\{1,\\ldots,K-1\\}$ 的 $\\Delta f_{k0}$，并通过约化到可辨识子空间的观测费雪信息计算它们的渐近标准误差。\n\n科学真实性要求：\n- 假设所有样本都有效不相关，因此有效样本量因子为1。所有量均为无量纲；不需要物理单位。\n- 使用对近简并态具有鲁棒性的数值稳定实现。\n\n测试套件：\n您的程序必须运行以下三种情况，每种情况由状态数 $K$、每个状态的样本数 $\\{N_k\\}$、谐振子均值 $\\{\\mu_k\\}$、共同的弹簧常数 $k_{\\text{spring}}$ 和一个随机种子指定。对于每种情况，为每个状态 $k$ 从 $\\mathcal{N}(\\mu_k, 1/k_{\\text{spring}})$ 中独立抽取恰好 $N_k$ 个样本，然后将所有状态的样本合并。必须按指定的方式为随机数生成器设定种子，以确保确定性。\n- 情况1：$K = 2$，$\\{\\mu_k\\} = [-1.0, 1.0]$，$k_{\\text{spring}} = 5.0$，$\\{N_k\\} = [80, 80]$，种子 $= 246810$。\n- 情况2：$K = 3$，$\\{\\mu_k\\} = [-1.0, 0.0, 1.5]$，$k_{\\text{spring}} = 4.0$，$\\{N_k\\} = [100, 10, 5]$，种子 $= 13579$。\n- 情况3：$K = 2$，$\\{\\mu_k\\} = [0.0, 0.2]$，$k_{\\text{spring}} = 10.0$，$\\{N_k\\} = [50, 50]$，种子 $= 424242$。\n\n答案规范：\n- 对于每种情况，计算 $k \\in \\{1,\\ldots,K-1\\}$ 的自由能差 $\\Delta f_{k0}$ 及其从约化观测费雪信息中获得的渐近标准误差 $s_{k0}$。所有输出均为无量纲浮点数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。对于上述顺序的每种情况，将序列 $\\left[\\Delta f_{10}, s_{10}, \\Delta f_{20}, s_{20}, \\ldots, \\Delta f_{(K-1)0}, s_{(K-1)0}\\right]$ 追加到一个扁平化的列表中。在打印前，每个浮点数必须四舍五入到恰好 $6$ 位小数。例如，一个有效的输出可能看起来像 $[\\ldots]$，其中所有条目都有 $6$ 位小数。",
            "solution": "用户提供了一个有效的问题陈述。任务是推导并实现多态贝内特接受率（MBAR）方法，用于从模拟数据中估计自由能差。这涉及推导自由能的自洽方程，提出一个数值稳定的迭代解法，以及推导估计值的渐近误差公式。实现将在由谐振子生成的合成数据上进行测试。\n\n### 1. MBAR自洽方程的推导\n\n我们从统计力学的基础开始。热力学态 $k$ 的配分函数由 $Z_k = \\int e^{-u_k(\\mathbf{x})} d\\mathbf{x}$ 给出，其中 $u_k(\\mathbf{x})$ 是系统在构型 $\\mathbf{x}$ 下的约化势能。无量纲自由能为 $f_k = -\\ln Z_k$，其定义允许相差一个取决于参考体积选择的加性常数。\n\n给定一个包含 $N$ 个构型的集合 $\\{\\mathbf{x}_n\\}_{n=1}^N$，这些构型是从 $K$ 个不同的热力学态中抽取的。对于每个状态 $k \\in \\{0, \\ldots, K-1\\}$，我们有 $N_k$ 个样本，总样本数为 $N = \\sum_{k=0}^{K-1} N_k$。\n\nMBAR方程提供了自由能的最小方差无偏估计。它们可以从多个角度推导，包括最大似然估计。一个直接的推导源于最优重要性抽样原理。任何状态 $i$ 的配分函数 $Z_i$ 可以写成一个积分：\n$$\nZ_i = \\int e^{-u_i(\\mathbf{x})} d\\mathbf{x}\n$$\n我们可以通过对合并的样本 $\\{\\mathbf{x}_n\\}$进行重加权来估计这个积分。对来自所有状态的样本进行最优组合，可以得到以下 $Z_i$ 的自洽估计量：\n$$\n\\hat{Z}_i = \\sum_{n=1}^{N} \\frac{e^{-u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j \\hat{Z}_j^{-1} e^{-u_j(\\mathbf{x}_n)}}\n$$\n该方程表明，配分函数 $\\hat{Z}_i$ 的估计是所有 $N$ 个样本的平均值。每个样本 $\\mathbf{x}_n$ 都从其原生的“混合”系综被重加权到目标系综 $i$。权重分母 $\\sum_j N_j \\hat{Z}_j^{-1} e^{-u_j(\\mathbf{x}_n)}$ 表示在所有 $K$ 个系综的混合中观测到构型 $\\mathbf{x}_n$ 的未归一化概率密度。\n\n为了得到自由能 $f_k = -\\ln Z_k$ 的方程，我们将 $\\hat{Z}_k = e^{-\\hat{f}_k}$ 代入上述方程：\n$$\ne^{-\\hat{f}_i} = \\sum_{n=1}^{N} \\frac{e^{-u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j e^{\\hat{f}_j} e^{-u_j(\\mathbf{x}_n)}}\n$$\n整理后得到MBAR自洽方程的最终形式：\n$$\n\\hat{f}_i = -\\ln \\left( \\sum_{n=1}^{N} \\frac{e^{-u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j e^{\\hat{f}_j - u_j(\\mathbf{x}_n)}} \\right)\n$$\n这 $K$ 个耦合非线性方程必须求解，以得到 $K$ 个自由能 $\\hat{f}_0, \\ldots, \\hat{f}_{K-1}$。这些自由能仅能确定到一个任意的加性常数，因为将所有 $\\hat{f}_j$ 平移一个常数 $c$ 并不会改变方程。我们通过将一个自由能固定为参考值（通常为 $\\hat{f}_0 = 0$）来解决这个问题。\n\n### 2. 数值稳定的不动点迭代方案\n\n自洽方程可以通过不动点迭代求解：\n$$\nf_i^{\\text{new}} = -\\ln \\left( \\sum_{n=1}^{N} \\frac{e^{-u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j e^{f_j^{\\text{old}} - u_j(\\mathbf{x}_n)}} \\right)\n$$\n以这种形式直接计算指数函数在数值上是不稳定的，存在浮点数上溢或下溢的风险。我们可以使用 log-sum-exp (LSE) 技巧构建一个稳定的方案，其中 $\\text{LSE}(\\mathbf{v}) = \\ln(\\sum_i e^{v_i})$。$f_i$ 的迭代更新可以重写为：\n$$\nf_i^{\\text{new}} = -\\ln \\left( \\sum_{n=1}^{N} \\exp\\left[ -u_i(\\mathbf{x}_n) - \\ln\\left(\\sum_{j=0}^{K-1} \\exp\\left[ \\ln N_j + f_j^{\\text{old}} - u_j(\\mathbf{x}_n) \\right]\\right) \\right] \\right)\n$$\n这个表达式是LSE的嵌套应用。让我们为LSE函数定义参数：\n- 对于内部LSE（对每个样本 $n$ 遍历状态 $j$）：$A_{jn} = \\ln N_j + f_j^{\\text{old}} - u_j(\\mathbf{x}_n)$。\n- 内部LSE的结果是每个样本的对数分母：$L_n = \\text{LSE}_j(A_{jn}) = \\ln(\\sum_j e^{A_{jn}})$。\n- 对于外部LSE（对每个状态 $i$ 遍历样本 $n$）：$B_{in} = -u_i(\\mathbf{x}_n) - L_n$。\n- 未移位的更新自由能则为 $f'_i = -\\text{LSE}_n(B_{in}) = -\\ln(\\sum_n e^{B_{in}})$。\n\n计算出未移位的值 $f'_i$ 后，我们通过平移所有自由能来施加 $f_0=0$ 的规范条件：\n$$\nf_i^{\\text{new}} = f'_i - f'_0 \\quad \\text{对于 } i \\in \\{0, \\ldots, K-1\\}\n$$\n这确保了 $f_0^{\\text{new}} = 0$。迭代从一个初始猜测（例如，对所有 $i$ 都有 $f_i=0$）开始，并重复更新，直到连续迭代之间任何自由能值的最大绝对变化小于指定的容差 $\\epsilon$：\n$$\n\\max_{i} |f_i^{\\text{new}} - f_i^{\\text{old}}|  \\epsilon\n$$\n\n### 3. 渐近误差估计\n\n估计的自由能 $\\hat{\\mathbf{f}}$ 的渐近协方差矩阵由观测到的费雪信息矩阵 $\\mathbf{I}$ 的逆矩阵给出。费雪信息是在最大似然估计处评估的对数似然函数的负海森矩阵。相关的对数似然函数（在不考虑一个加性常数的情况下）是：\n$$\n\\ln \\mathcal{L}(\\mathbf{f}) = \\sum_{k=0}^{K-1} N_k f_k - \\sum_{n=1}^{N} \\ln\\left( \\sum_{j=0}^{K-1} N_j e^{f_j - u_j(\\mathbf{x}_n)} \\right)\n$$\n关于 $f_i$ 的一阶导数是：\n$$\n\\frac{\\partial \\ln \\mathcal{L}}{\\partial f_i} = N_i - \\sum_{n=1}^{N} \\frac{N_i e^{f_i - u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j e^{f_j - u_j(\\mathbf{x}_n)}} = N_i - \\sum_{n=1}^{N} W_{in}\n$$\n其中 $W_{in}$ 是样本 $n$（从任何状态抽取）在热力学上属于状态 $i$ 的概率：\n$$\nW_{in} = \\frac{N_i e^{f_i - u_i(\\mathbf{x}_n)}}{\\sum_{j=0}^{K-1} N_j e^{f_j - u_j(\\mathbf{x}_n)}}\n$$\n注意，对于任何样本 $n$，都有 $\\sum_{i=0}^{K-1} W_{in} = 1$。在最大似然解处，$\\frac{\\partial \\ln \\mathcal{L}}{\\partial f_i} = 0$，这意味着 $N_i = \\sum_{n=1}^N W_{in}$。\n\n海森矩阵元素 $H_{ij} = \\frac{\\partial^2 \\ln \\mathcal{L}}{\\partial f_i \\partial f_j}$ 为：\n$$\nH_{ij} = -\\sum_{n=1}^{N} \\frac{\\partial W_{in}}{\\partial f_j} = -\\sum_{n=1}^{N} (W_{in}\\delta_{ij} - W_{in}W_{jn})\n$$\n其中 $\\delta_{ij}$ 是克罗内克δ函数。观测到的费雪信息矩阵是 $\\mathbf{I} = -\\mathbf{H}$：\n$$\nI_{ij} = \\sum_{n=1}^{N} (W_{in}\\delta_{ij} - W_{in}W_{jn})\n$$\n这个 $K \\times K$ 矩阵是奇异的，反映了绝对自由能的不可辨识性。向量 $(1, 1, \\ldots, 1)^T$ 是一个零特征向量，因为 $\\sum_j I_{ij} = 0$。\n\n为了获得一个非奇异矩阵，我们在相对于状态0的自由能差所构成的约化空间中工作，即对 $k \\in \\{1, \\ldots, K-1\\}$ 的 $\\Delta f_{k0} = f_k - f_0$。这等价于设置 $f_0=0$ 并估计剩余的 $K-1$ 个自由能。这 $K-1$ 个参数的费雪信息矩阵是通过从 $\\mathbf{I}$ 中移除对应于状态0的行和列得到的 $(K-1) \\times (K-1)$ 子矩阵：\n$$\n\\mathbf{I}_{\\text{red}} = (I_{ij})_{i,j \\in \\{1,\\ldots,K-1\\}}\n$$\n这个约化矩阵是可逆的。自由能差 $(\\Delta f_{10}, \\ldots, \\Delta f_{(K-1)0})$ 的协方差矩阵由其逆矩阵给出：\n$$\n\\mathbf{C} = \\mathbf{I}_{\\text{red}}^{-1}\n$$\n$\\Delta f_{k0}$ 估计的渐近标准误差是 $\\mathbf{C}$ 对应对角元素的平方根：\n$$\ns_{k0} = \\sqrt{C_{k-1, k-1}} \\quad \\text{对于 } k \\in \\{1, \\ldots, K-1\\}\n$$\n（对矩阵 $\\mathbf{C}$ 使用基于0的索引）。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import logsumexp\n\ndef solve_mbar(u_kn, N_k, tol=1e-12, max_iter=10000):\n    \"\"\"\n    Solves the MBAR self-consistent equations for the free energies.\n\n    Args:\n        u_kn (np.ndarray): A KxN matrix of reduced potentials u_k(x_n).\n        N_k (np.ndarray): A K-element array of sample counts per state.\n        tol (float): The convergence tolerance.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        tuple: A tuple containing:\n            - f_k (np.ndarray): K-element array of estimated dimensionless free energies with f_0 = 0.\n            - df_k (np.ndarray): (K-1)-element array of standard errors for f_k - f_0.\n    \"\"\"\n    K, N = u_kn.shape\n    f_k = np.zeros(K, dtype=np.float64)\n    log_N_k = np.log(N_k)\n\n    for i in range(max_iter):\n        f_k_old = np.copy(f_k)\n\n        # Numerically stable calculation of new free energies\n        # A_kn = log(N_k) + f_k - u_kn\n        A_kn = log_N_k[:, np.newaxis] + f_k[:, np.newaxis] - u_kn\n        \n        # log_D_n = log(sum_k exp(A_kn))\n        log_D_n = logsumexp(A_kn, axis=0)\n        \n        # log [ exp(-u_kn) / D_n ] = -u_kn - log_D_n\n        log_term = -u_kn - log_D_n[np.newaxis, :]\n        \n        # f'_k = -log(sum_n exp(log_term))\n        f_k_new_unshifted = -logsumexp(log_term, axis=1)\n        \n        # Enforce gauge f_0 = 0\n        f_k = f_k_new_unshifted - f_k_new_unshifted[0]\n\n        if np.max(np.abs(f_k - f_k_old))  tol:\n            break\n    else:\n        raise RuntimeError(\"MBAR did not converge in {} iterations.\".format(max_iter))\n\n    # Calculate uncertainties\n    # A_kn = log(N_k) + f_k - u_kn for converged f_k\n    A_kn = log_N_k[:, np.newaxis] + f_k[:, np.newaxis] - u_kn\n    log_D_n = logsumexp(A_kn, axis=0)\n    \n    # W_kn = exp(A_kn) / D_n = exp(A_kn - log_D_n)\n    log_W_kn = A_kn - log_D_n[np.newaxis, :]\n    W_kn = np.exp(log_W_kn)\n\n    # Fisher information matrix I_ij = sum_n (W_in * delta_ij - W_in * W_jn)\n    # This can be written as I = diag(sum(W, axis=1)) - W @ W.T\n    I = np.diag(np.sum(W_kn, axis=1)) - W_kn @ W_kn.T\n\n    # Invert the reduced (K-1)x(K-1) Fisher information matrix\n    # for states 1..K-1 to get the covariance of (f_1-f_0, ..., f_{K-1}-f_0)\n    I_red = I[1:, 1:]\n    try:\n        C_red = np.linalg.inv(I_red)\n        df_k = np.sqrt(np.diag(C_red))\n    except np.linalg.LinAlgError:\n        # This can happen if states are not well-connected,\n        # but shouldn't for the given test cases.\n        df_k = np.full(K - 1, np.nan)\n\n    return f_k[1:], df_k\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'K': 2, 'mu_k': [-1.0, 1.0], 'k_spring': 5.0, 'N_k': [80, 80], 'seed': 246810},\n        {'K': 3, 'mu_k': [-1.0, 0.0, 1.5], 'k_spring': 4.0, 'N_k': [100, 10, 5], 'seed': 13579},\n        {'K': 2, 'mu_k': [0.0, 0.2], 'k_spring': 10.0, 'N_k': [50, 50], 'seed': 424242},\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        K = case['K']\n        mu_k = np.array(case['mu_k'])\n        k_spring = case['k_spring']\n        N_k = np.array(case['N_k'])\n        seed = case['seed']\n        \n        rng = np.random.default_rng(seed)\n\n        # 1. Generate synthetic data\n        samples_per_state = []\n        for k in range(K):\n            # Samples drawn from N(mu_k, sigma^2 = 1/k_spring)\n            std_dev = np.sqrt(1.0 / k_spring)\n            samples = rng.normal(loc=mu_k[k], scale=std_dev, size=N_k[k])\n            samples_per_state.append(samples)\n        \n        # Pool all samples\n        x_n = np.concatenate(samples_per_state)\n        N = x_n.shape[0]\n\n        # 2. Construct reduced potential matrix u_kn\n        # u_k(x_n) = 0.5 * k_spring * (x_n - mu_k)^2\n        u_kn = 0.5 * k_spring * (x_n[np.newaxis, :] - mu_k[:, np.newaxis])**2\n\n        # 3. Solve MBAR equations\n        f_k_diff, df_k_err = solve_mbar(u_kn, N_k)\n\n        # 4. Collect results for this case\n        case_results = []\n        for f, df in zip(f_k_diff, df_k_err):\n            case_results.extend([f, df])\n        all_results.extend(case_results)\n\n    # Format and print the final output\n    formatted_results = [f\"{x:.6f}\" for x in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}