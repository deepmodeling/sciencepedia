{
    "hands_on_practices": [
        {
            "introduction": "To truly understand the Ramachandran plot, we must first explore its physical origins. This exercise guides you through building a simplified peptide model from the ground up to calculate the sterically allowed conformational space based on a hard-sphere model (). By implementing this steric filter, you will gain a fundamental appreciation for how the size and arrangement of atoms constrain the protein backbone's flexibility and give rise to the characteristic allowed and disallowed regions.",
            "id": "3861074",
            "problem": "You are asked to implement a physically plausible hard-sphere steric filter to estimate the fraction of the $(\\phi,\\psi)$ plane that is sterically allowed for alanine in a standard peptide backbone model. Your program must construct a minimal alanine dipeptide-like fragment using fixed internal coordinates and determine, for each sampled pair of backbone dihedral angles $(\\phi,\\psi)$, whether the conformation is sterically allowed under a hard-sphere van der Waals (vdW) model. You will then estimate the allowed fraction on a uniform grid over $(\\phi,\\psi)$ and report how this fraction changes when radii are uniformly scaled by a factor of $0.95$.\n\nFundamental base and core definitions to be used:\n- A backbone dihedral angle is defined by four ordered atoms $(\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$ and equals the signed angle between the planes $(\\mathbf{r}_0,\\mathbf{r}_1,\\mathbf{r}_2)$ and $(\\mathbf{r}_1,\\mathbf{r}_2,\\mathbf{r}_3)$. The sign convention arises from the right-hand rule along the bond $\\mathbf{r}_1\\mathbf{r}_2$. The dihedral angle is computed from vectors and cross products: with $\\mathbf{b}_1=\\mathbf{r}_1-\\mathbf{r}_0$, $\\mathbf{b}_2=\\mathbf{r}_2-\\mathbf{r}_1$, $\\mathbf{b}_3=\\mathbf{r}_3-\\mathbf{r}_2$, the plane normals are $\\mathbf{n}_1=\\mathbf{b}_1\\times\\mathbf{b}_2$ and $\\mathbf{n}_2=\\mathbf{b}_2\\times\\mathbf{b}_3$, and the signed angle $\\omega$ satisfies $\\tan\\omega=\\dfrac{\\left(\\mathbf{n}_1\\times \\dfrac{\\mathbf{b}_2}{\\lVert \\mathbf{b}_2\\rVert}\\right)\\cdot \\mathbf{n}_2}{\\mathbf{n}_1\\cdot\\mathbf{n}_2}$.\n- A steric clash occurs under the hard-sphere model when the Euclidean distance $d_{ij}$ between two nonbonded atoms $i$ and $j$ is strictly less than the sum of their vdW radii $r_i+r_j$ (or $s\\,(r_i+r_j)$ when radii are scaled by a factor $s$). Distances are measured in ångström (Å).\n- Bonded pairs and atom pairs separated by two bonds (also called $1$–$3$ pairs) are excluded from the clash check. Only pairs separated by three or more bonds are considered for steric exclusion.\n- Rigid rotations around a bond axis $\\mathbf{u}$ by an angle $\\theta$ are performed using the Rodrigues rotation formula for any point $\\mathbf{x}$ rotated about an axis passing through a point $\\mathbf{p}$: $\\mathbf{x}'=\\mathbf{p}+\\cos\\theta(\\mathbf{x}-\\mathbf{p})+\\sin\\theta\\,(\\mathbf{u}\\times(\\mathbf{x}-\\mathbf{p}))+(1-\\cos\\theta)\\,\\mathbf{u}\\,(\\mathbf{u}\\cdot(\\mathbf{x}-\\mathbf{p}))$, with $\\mathbf{u}$ normalized.\n\nGeometry to construct (distances in ångström and angles in degrees):\n- Backbone of the central residue: place the backbone atoms $\\mathrm{N}$, $\\mathrm{C_\\alpha}$, and $\\mathrm{C}$ in a peptide plane with fixed bond lengths and angles: $\\lVert \\mathrm{N}-\\mathrm{C_\\alpha}\\rVert=1.458$, $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C}\\rVert=1.525$, and the angle $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}=110.1$. The initial peptide plane is the $x$–$y$ plane, with $\\mathrm{N}$ at the origin and $\\mathrm{C_\\alpha}$ placed on the $x$-axis.\n- Carbonyl oxygen of the central residue: $\\mathrm{O}$ bonded to $\\mathrm{C}$ with $\\lVert \\mathrm{C}-\\mathrm{O}\\rVert=1.229$ and planar geometry, with the angle $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{O}=120.0$.\n- Previous residue carbonyl: $\\mathrm{C_{-1}}$ bonded to $\\mathrm{N}$ with $\\lVert \\mathrm{N}-\\mathrm{C_{-1}}\\rVert=1.330$ and angle $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{N}\\!-\\!\\mathrm{C_{-1}}=121.7$; place $\\mathrm{O_{-1}}$ bonded to $\\mathrm{C_{-1}}$ with $\\lVert \\mathrm{C_{-1}}-\\mathrm{O_{-1}}\\rVert=1.229$ and angle $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_{-1}}\\!-\\!\\mathrm{O_{-1}}=120.0$, all in the same peptide plane (trans peptide bond).\n- Next residue amide nitrogen: $\\mathrm{N_{+1}}$ bonded to $\\mathrm{C}$ with $\\lVert \\mathrm{C}-\\mathrm{N_{+1}}\\rVert=1.330$ and angle $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{N_{+1}}=116.2$, in the peptide plane (trans).\n- Alanine sidechain: a united-atom methyl at $\\mathrm{C_\\beta}$ bonded to $\\mathrm{C_\\alpha}$ with $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C_\\beta}\\rVert=1.530$. To reflect tetrahedral preference, initially place $\\mathrm{C_\\beta}$ along the peptide plane normal, i.e., perpendicular to the backbone plane.\n\nBackbone dihedral control:\n- The Ramachandran dihedrals for the central residue are defined as $\\phi=\\angle(\\mathrm{C_{-1}},\\mathrm{N},\\mathrm{C_\\alpha},\\mathrm{C})$ and $\\psi=\\angle(\\mathrm{N},\\mathrm{C_\\alpha},\\mathrm{C},\\mathrm{N_{+1}})$, both in degrees. To set a target $(\\phi,\\psi)$, rotate the upstream group $\\{\\mathrm{C_{-1}},\\mathrm{O_{-1}}\\}$ as a rigid body around the bond axis $\\mathrm{N}$–$\\mathrm{C_\\alpha}$ by the increment needed to achieve the target $\\phi$, and rotate the downstream group $\\{\\mathrm{O},\\mathrm{N_{+1}}\\}$ as a rigid body around the bond axis $\\mathrm{C_\\alpha}$–$\\mathrm{C}$ by the increment needed to achieve the target $\\psi$.\n\nSteric model radii (Bondi radii):\n- $\\mathrm{N}$: $1.55$, $\\mathrm{C}$: $1.70$, $\\mathrm{O}$: $1.52$, unified methyl $\\mathrm{C_\\beta}$: $2.00$. Apply scaling by a factor $s$ to all radii when specified.\n\nConnectivity exclusions:\n- Exclude from clash checks any atom pairs that are directly bonded or separated by exactly two bonds. The connectivity edges are: $\\mathrm{N}$–$\\mathrm{C_\\alpha}$, $\\mathrm{C_\\alpha}$–$\\mathrm{C}$, $\\mathrm{C}$–$\\mathrm{O}$, $\\mathrm{N}$–$\\mathrm{C_{-1}}$, $\\mathrm{C_{-1}}$–$\\mathrm{O_{-1}}$, $\\mathrm{C}$–$\\mathrm{N_{+1}}$, and $\\mathrm{C_\\alpha}$–$\\mathrm{C_\\beta}$.\n\nGrid and units:\n- Sample $(\\phi,\\psi)$ on a uniform grid covering $[-180,180]$ inclusive in degrees. Distances are in ångström. Angles must be in degrees.\n\nAllowed fraction estimate:\n- The allowed fraction is computed as the number of grid points whose conformation has no steric clash among nonbonded pairs divided by the total number of grid points.\n\nTest suite:\n- Each test case is a pair $(\\Delta, s)$, where $\\Delta$ is the grid step in degrees and $s$ is the vdW scaling factor. Use the following test cases: $(60,1.0)$, $(60,0.95)$, $(20,1.0)$, $(20,0.95)$, $(10,1.0)$, $(10,0.95)$.\n- For each test case, output the allowed fraction as a float rounded to six decimal places.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., \"[f1,f2,f3,f4,f5,f6]\"). Each $f_k$ corresponds to the allowed fraction for the $k$-th test case in the order given above.",
            "solution": "The user requests a program to compute the sterically allowed fraction of the Ramachandran $(\\phi,\\psi)$ conformational space for an alanine dipeptide-like fragment. This problem falls within the domain of computational chemical biology and requires the implementation of a hard-sphere steric clash model based on geometric constructions.\n\n### Problem Validation\n\nFirst, I will rigorously validate the problem statement.\n\n#### Step 1: Extract Givens\n\n- **Model**: An alanine dipeptide fragment with a united-atom methyl group $(\\mathrm{C_\\beta})$ on the $\\mathrm{C_\\alpha}$. Steric interactions are evaluated using a hard-sphere model.\n- **Atoms**: The model comprises eight atomic centers: $\\mathrm{N, C_\\alpha, C, O}$ of the central residue, $\\mathrm{C_{-1}, O_{-1}}$ of the preceding residue, $\\mathrm{N_{+1}}$ of the succeeding residue, and $\\mathrm{C_\\beta}$ for the alanine sidechain.\n- **Geometric Parameters (Distances in Å, Angles in degrees)**:\n    - Bond Lengths: $\\lVert \\mathrm{N}-\\mathrm{C_\\alpha}\\rVert=1.458$, $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C}\\rVert=1.525$, $\\lVert \\mathrm{C}-\\mathrm{O}\\rVert=1.229$, $\\lVert \\mathrm{N}-\\mathrm{C_{-1}}\\rVert=1.330$, $\\lVert \\mathrm{C_{-1}}-\\mathrm{O_{-1}}\\rVert=1.229$, $\\lVert \\mathrm{C}-\\mathrm{N_{+1}}\\rVert=1.330$, $\\lVert \\mathrm{C_\\alpha}-\\mathrm{C_\\beta}\\rVert=1.530$.\n    - Bond Angles: $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}=110.1^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{O}=120.0^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{N}\\!-\\!\\mathrm{C_{-1}}=121.7^\\circ$, $\\angle \\mathrm{N}\\!-\\!\\mathrm{C_{-1}}\\!-\\!\\mathrm{O_{-1}}=120.0^\\circ$, $\\angle \\mathrm{C_\\alpha}\\!-\\!\\mathrm{C}\\!-\\!\\mathrm{N_{+1}}=116.2^\\circ$.\n- **Reference Geometry Construction**:\n    - The initial peptide plane is the $x$–$y$ plane.\n    - $\\mathrm{N}$ is at the origin $(0,0,0)$. $\\mathrm{C_\\alpha}$ is on the $x$-axis.\n    - The backbone $\\mathrm{N}-\\mathrm{C_\\alpha}-\\mathrm{C}$ is in the $x$–$y$ plane.\n    - The preceding group $(\\mathrm{C_{-1}}, \\mathrm{O_{-1}})$ and succeeding atom $(\\mathrm{N_{+1}})$ are also placed in this plane, with \"trans\" peptide bond character mentioned.\n    - $\\mathrm{C_\\beta}$ is initially placed along the peptide plane normal.\n- **Dihedral Angles and Rotations**:\n    - $\\phi = \\angle(\\mathrm{C_{-1}}, \\mathrm{N}, \\mathrm{C_\\alpha}, \\mathrm{C})$, $\\psi = \\angle(\\mathrm{N}, \\mathrm{C_\\alpha}, \\mathrm{C}, \\mathrm{N_{+1}})$.\n    - Target $(\\phi,\\psi)$ values are achieved by rotating rigid groups: $\\{\\mathrm{C_{-1}}, \\mathrm{O_{-1}}\\}$ around the $\\mathrm{N}-\\mathrm{C_\\alpha}$ axis for $\\phi$, and $\\{\\mathrm{O}, \\mathrm{N_{+1}}\\}$ around the $\\mathrm{C_\\alpha}-\\mathrm{C}$ axis for $\\psi$.\n    - Rotation is performed using the provided Rodrigues formula.\n- **Steric Clash Model**:\n    - A clash occurs if the distance $d_{ij}$ between two nonbonded atoms $i, j$ is less than $s(r_i+r_j)$, where $r_i, r_j$ are vdW radii and $s$ is a scaling factor.\n    - Exclusions: Pairs of atoms that are bonded (1–2 pairs) or separated by two bonds (1–3 pairs) are not checked for clashes.\n- **Van der Waals Radii (in Å)**: $\\mathrm{N}: 1.55$, $\\mathrm{C}: 1.70$, $\\mathrm{O}: 1.52$, unified methyl $\\mathrm{C_\\beta}: 2.00$. Other atoms are assigned radii based on their element type ($\\mathrm{C_\\alpha, C, C_{-1}}$ are carbons; $\\mathrm{N_{+1}}$ is a nitrogen; $\\mathrm{O_{-1}}$ is an oxygen).\n- **Computational Task**:\n    - Sample $(\\phi,\\psi)$ on a uniform grid from $[-180, 180]$ inclusive.\n    - Calculate the allowed fraction: (number of non-clashing conformations) / (total grid points).\n- **Test Cases**: Six pairs of $(\\Delta, s)$, where $\\Delta$ is the grid spacing in degrees and $s$ is the radius scaling factor: $(60,1.0), (60,0.95), (20,1.0), (20,0.95), (10,1.0), (10,0.95)$.\n- **Output**: A single-line list of six floating-point numbers rounded to six decimal places, `[f1,f2,f3,f4,f5,f6]`.\n\n#### Step 2: Validate Using Extracted Givens\nThe problem is scientifically grounded, well-posed, and objective. It describes a standard, simplified exercise in computational biophysics. The geometric parameters, physical model (hard-sphere), and mathematical definitions (dihedral angle, Rodrigues' rotation) are all standard and correct. The instructions for geometric construction are sufficiently detailed to create a well-defined initial molecular structure. While the phrase \"trans peptide bond\" might introduce a slight ambiguity in the context of other explicit planar construction rules, interpreting the explicit rules as primary results in a consistent, formalizable procedure. The problem is self-contained and free of scientific flaws, contradictions, or infeasible requirements.\n\n#### Step 3: Verdict and Action\nThe problem is **valid**. A solution will be constructed according to the validated specifications.\n\n### Solution Design\n\nThe solution will be implemented by following a clear, step-by-step procedure derived from the problem statement.\n\n1.  **Reference Geometry Construction**: First, we construct a reference conformation of the alanine dipeptide fragment based on the provided geometric parameters. All atoms are initially placed in the $x,y$-plane except for the $\\mathrm{C_\\beta}$ atom.\n    - Place $\\mathrm{N}$ at the origin $\\mathbf{r}_N = (0, 0, 0)$.\n    - Place $\\mathrm{C_\\alpha}$ on the positive $x$-axis at $\\mathbf{r}_{C\\alpha} = (1.458, 0, 0)$.\n    - Place $\\mathrm{C}$ in the $x,y$-plane to satisfy $\\lVert \\mathbf{r}_C - \\mathbf{r}_{C\\alpha} \\rVert = 1.525$ and $\\angle \\mathrm{N-C_\\alpha-C} = 110.1^\\circ$. We choose the solution with a positive $y$-coordinate.\n    - Other atoms ($\\mathrm{C_{-1}}, \\mathrm{O_{-1}}, \\mathrm{O}, \\mathrm{N_{+1}}$) are placed in the $x,y$-plane relative to the core backbone atoms according to their bond lengths and angles. The construction is chosen to create a reference state where the initial dihedral angles $\\phi_0$ and $\\psi_0$ are both $0^\\circ$ (a cis-cis conformation). This is a well-defined starting point.\n    - Place $\\mathrm{C_\\beta}$ perpendicular to this plane, at $\\mathbf{r}_{C\\beta} = \\mathbf{r}_{C\\alpha} + (0, 0, 1.530)$.\n\n2.  **Dihedral Angle Rotation**: To generate any conformation $(\\phi, \\psi)$, we start with the reference geometry and perform rigid-body rotations as specified.\n    - **$\\phi$ rotation**: The group of atoms $\\{\\mathrm{C_{-1}}, \\mathrm{O_{-1}}\\}$ is rotated by the angle $\\phi$ around the axis defined by the vector $\\mathbf{r}_{C\\alpha} - \\mathbf{r}_{N}$, passing through point $\\mathbf{r}_{N}$.\n    - **$\\psi$ rotation**: The group of atoms $\\{\\mathrm{O}, \\mathrm{N_{+1}}\\}$ is rotated by the angle $\\psi$ around the axis defined by the vector $\\mathbf{r}_{C} - \\mathbf{r}_{C\\alpha}$, passing through point $\\mathbf{r}_{C\\alpha}$.\n    - The rotations are implemented using the provided Rodrigues' rotation formula. All angles must be converted from degrees to radians for use in trigonometric functions.\n\n3.  **Steric Clash Detection**: For each generated conformation, we check for steric clashes.\n    - **Exclusion List**: We first identify all pairs of atoms that are exempt from clash detection. These are 1–2 pairs (covalently bonded) and 1–3 pairs (separated by two bonds). This can be determined by finding all atom pairs with a graph distance of $1$ or $2$ in the molecular connectivity graph.\n    - **Clash Check**: For all other pairs of atoms $(i, j)$, we calculate the Euclidean distance $d_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$. A clash occurs if $d_{ij}  s(r_i + r_j)$, where $r_i$ and $r_j$ are the respective van der Waals radii and $s$ is the given scaling factor.\n\n4.  **Grid Sampling and Fraction Calculation**: The conformational space is sampled on a uniform grid of $(\\phi, \\psi)$ values from $-180^\\circ$ to $180^\\circ$ inclusive, with a step size $\\Delta$.\n    - For each test case $(\\Delta, s)$, we iterate through all grid points.\n    - We count the number of grid points $N_{allowed}$ whose corresponding conformation is free of any steric clashes.\n    - The total number of grid points is $N_{total} = (360/\\Delta + 1)^2$.\n    - The allowed fraction is computed as $f = N_{allowed} / N_{total}$.\n\n5.  **Implementation**: The algorithm is implemented in Python using the `numpy` library for efficient vector and matrix operations, as required. The final program structure will incorporate all these steps to process the specified test cases and produce the output in the required format.",
            "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\n# No further imports, including scipy, are necessary for this problem.\n\ndef rodrigues_rotation(points, p_axis, axis_vec, angle_rad):\n    \"\"\"\n    Rotates a set of points around an axis using Rodrigues' formula.\n    \n    Args:\n        points (np.ndarray): Array of points to rotate (Nx3).\n        p_axis (np.ndarray): A point on the axis of rotation (3,).\n        axis_vec (np.ndarray): Direction vector of the axis of rotation (3,).\n        angle_rad (float): The angle of rotation in radians.\n    \n    Returns:\n        np.ndarray: The array of rotated points (Nx3).\n    \"\"\"\n    # Ensure axis vector is normalized\n    axis_vec = axis_vec / np.linalg.norm(axis_vec)\n    \n    # Use broadcasting for vector operations\n    v = points - p_axis\n    \n    cos_theta = np.cos(angle_rad)\n    sin_theta = np.sin(angle_rad)\n    \n    # Rodrigues' formula components\n    term1 = v * cos_theta\n    term2 = np.cross(axis_vec, v) * sin_theta\n    \n    # Handle dot product for multiple points in v\n    v_dot_axis = np.dot(v, axis_vec)\n    term3 = np.outer(v_dot_axis, axis_vec) * (1 - cos_theta)\n    \n    v_rot = term1 + term2 + term3\n    \n    return p_axis + v_rot\n\ndef build_reference_geometry():\n    \"\"\"\n    Constructs coordinates of the alanine fragment in a reference planar conformation\n    corresponding to phi=0, psi=0 degrees.\n    \"\"\"\n    rad = np.deg2rad\n    \n    # Geometric parameters\n    L_NCa, L_CaC, L_CO, L_NCm1, L_Cm1Om1, L_CNp1, L_CaCb = 1.458, 1.525, 1.229, 1.330, 1.229, 1.330, 1.530\n    A_NCaC, A_CaCO, A_CaNCm1, A_NCm1Om1, A_CaCNp1 = rad(110.1), rad(120.0), rad(121.7), rad(120.0), rad(116.2)\n\n    coords = {}\n    \n    # Central backbone N-Ca-C in xy-plane\n    coords['N'] = np.array([0., 0., 0.])\n    coords['Ca'] = np.array([L_NCa, 0., 0.])\n    \n    # Place C in xy-plane with y > 0\n    coords['C'] = np.array([\n        L_NCa + L_CaC * np.cos(np.pi - A_NCaC),\n        L_CaC * np.sin(np.pi - A_NCaC),\n        0.\n    ])\n\n    # Place upstream group {Cm1, Om1} for phi=0\n    coords['Cm1'] = np.array([\n        L_NCm1 * np.cos(A_CaNCm1),\n        L_NCm1 * np.sin(A_CaNCm1),\n        0.\n    ])\n    v_Cm1N = coords['N'] - coords['Cm1']\n    angle_Cm1N = np.arctan2(v_Cm1N[1], v_Cm1N[0])\n    angle_Cm1Om1 = angle_Cm1N - A_NCm1Om1\n    coords['Om1'] = coords['Cm1'] + np.array([\n        L_Cm1Om1 * np.cos(angle_Cm1Om1),\n        L_Cm1Om1 * np.sin(angle_Cm1Om1),\n        0.\n    ])\n    \n    # Place downstream group {O, Np1} for psi=0\n    v_CCa = coords['Ca'] - coords['C']\n    angle_CCa = np.arctan2(v_CCa[1], v_CCa[0])\n    \n    angle_CNp1 = angle_CCa + A_CaCNp1\n    coords['Np1'] = coords['C'] + np.array([\n        L_CNp1 * np.cos(angle_CNp1),\n        L_CNp1 * np.sin(angle_CNp1),\n        0.\n    ])\n    \n    angle_CO = angle_CCa - A_CaCO\n    coords['O'] = coords['C'] + np.array([\n        L_CO * np.cos(angle_CO),\n        L_CO * np.sin(angle_CO),\n        0.\n    ])\n    \n    # Place sidechain Cb perpendicular to plane\n    coords['Cb'] = coords['Ca'] + np.array([0., 0., L_CaCb])\n\n    return coords\n    \ndef get_nonbonded_pairs_to_check(atom_names):\n    \"\"\"\n    Determines atom pairs to be checked for steric clashes by excluding 1-2 and 1-3 pairs.\n    \"\"\"\n    connectivity = {\n        'N': ['Ca', 'Cm1'], 'Ca': ['N', 'C', 'Cb'], 'C': ['Ca', 'O', 'Np1'],\n        'O': ['C'], 'Cm1': ['N', 'Om1'], 'Om1': ['Cm1'], 'Np1': ['C'], 'Cb': ['Ca']\n    }\n    \n    name_to_idx = {name: i for i, name in enumerate(atom_names)}\n    idx_to_name = {i: name for i, name in enumerate(atom_names)}\n    \n    adj = defaultdict(list)\n    for u, neighbors in connectivity.items():\n        for v in neighbors:\n            adj[name_to_idx[u]].append(name_to_idx[v])\n\n    num_atoms = len(atom_names)\n    pairs_to_check = []\n    for i in range(num_atoms):\n        for j in range(i + 1, num_atoms):\n            # Check for path of length 1 or 2\n            # dist 1\n            if j in adj[i]:\n                continue\n            # dist 2\n            is_dist_2 = False\n            for neighbor in adj[i]:\n                if j in adj[neighbor]:\n                    is_dist_2 = True\n                    break\n            if is_dist_2:\n                continue\n            \n            pairs_to_check.append((i, j))\n            \n    return pairs_to_check\n\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        (60, 1.0), (60, 0.95), (20, 1.0), (20, 0.95), (10, 1.0), (10, 0.95)\n    ]\n    \n    atom_names = ['N', 'Ca', 'C', 'O', 'Cm1', 'Om1', 'Np1', 'Cb']\n    radii_map = {'N': 1.55, 'Ca': 1.70, 'C': 1.70, 'O': 1.52, 'Cm1': 1.70, 'Om1': 1.52, 'Np1': 1.55, 'Cb': 2.00}\n    radii = np.array([radii_map[name] for name in atom_names])\n\n    ref_coords_dict = build_reference_geometry()\n    ref_coords = np.array([ref_coords_dict[name] for name in atom_names])\n    \n    pairs_to_check = get_nonbonded_pairs_to_check(atom_names)\n\n    results = []\n    \n    for grid_step, scale_factor in test_cases:\n        angle_range = np.arange(-180, 180 + grid_step, grid_step)\n        \n        allowed_count = 0\n        total_points = len(angle_range)**2\n\n        # Pre-calculate clash thresholds\n        radii_sums = np.zeros((len(atom_names), len(atom_names)))\n        for i, j in pairs_to_check:\n            radii_sums[i, j] = scale_factor * (radii[i] + radii[j])\n        \n        for phi in angle_range:\n            for psi in angle_range:\n                current_coords = ref_coords.copy()\n                \n                # Apply phi rotation to {Cm1, Om1}\n                phi_rad = np.deg2rad(phi)\n                axis_phi = ref_coords[1] - ref_coords[0] # Ca - N\n                p_axis_phi = ref_coords[0] # N\n                indices_phi = [4, 5] # Cm1, Om1\n                current_coords[indices_phi] = rodrigues_rotation(current_coords[indices_phi], p_axis_phi, axis_phi, phi_rad)\n                \n                # Apply psi rotation to {O, Np1}\n                psi_rad = np.deg2rad(psi)\n                axis_psi = ref_coords[2] - ref_coords[1] # C - Ca\n                p_axis_psi = ref_coords[1] # Ca\n                indices_psi = [3, 6] # O, Np1\n                current_coords[indices_psi] = rodrigues_rotation(current_coords[indices_psi], p_axis_psi, axis_psi, psi_rad)\n                \n                # Check for steric clashes\n                has_clash = False\n                for i, j in pairs_to_check:\n                    dist_sq = np.sum((current_coords[i] - current_coords[j])**2)\n                    clash_dist_sq = radii_sums[i, j]**2\n                    if dist_sq  clash_dist_sq:\n                        has_clash = True\n                        break\n                \n                if not has_clash:\n                    allowed_count += 1\n        \n        fraction = allowed_count / total_points\n        results.append(round(fraction, 6))\n\n    # Format and print the final output\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "While the general Ramachandran plot provides a powerful map for most amino acids, glycine and proline are notable exceptions due to their unique structures. This practice shifts our focus from physical modeling to statistical analysis of conformational ensembles, using a hypothetical dataset to illustrate the distinct preferences of these special residues (). You will learn to construct and compare empirical probability distributions using techniques like histogramming, smoothing, and the Kullback-Leibler divergence to quantitatively measure how different these conformational landscapes truly are.",
            "id": "3861112",
            "problem": "You are to implement a program that formalizes the analysis of Ramachandran plots under the inclusion of glycine and proline by computing separate binned probability distributions of the backbone dihedral angles and quantifying shifts in the allowed regions via the Kullback–Leibler divergence. The computational basis must start from fundamental definitions in computational chemical biology and statistical inference. Use the following definitions as the foundational base: a Ramachandran plot maps the amino acid backbone torsion angles $\\phi$ and $\\psi$ to a two-dimensional angular space; glycine and proline have distinct conformational preferences due to side-chain constraints; a probability distribution over the angular space is estimated by binning angle observations; and the Kullback–Leibler divergence quantifies the information loss when approximating one distribution by another. All angles must be handled and reported in degrees; all logarithms must be natural logarithms; all probabilities must be dimensionless.\n\nYour task is to:\n- Construct separate empirical distributions for glycine and proline $\\phi$ and $\\psi$ angles using two-dimensional histograms over the domain $\\phi \\in [-180,180)$ and $\\psi \\in [-180,180)$ with a square bin width of $w$ degrees. Normalize each histogram to obtain a discrete probability distribution over bins.\n- Apply Dirichlet (additive) smoothing by adding a constant $\\alpha > 0$ to each bin count before normalization to avoid zero-probability bins.\n- Define the allowed region for each amino acid as the set of bins whose probability is at least a threshold $\\tau$. Let $\\mathcal{R}_{\\mathrm{gly}}$ be the allowed region for glycine and $\\mathcal{R}_{\\mathrm{pro}}$ be the allowed region for proline. Let $\\mathcal{U} = \\mathcal{R}_{\\mathrm{gly}} \\cup \\mathcal{R}_{\\mathrm{pro}}$ be their union. If $\\mathcal{U}$ is empty for a given test case, treat the allowed region as the entire grid.\n- Construct a combined “mixed” distribution $P_{\\mathrm{mix}}$ by pooling (i.e., concatenating) the glycine and proline observations, applying the same binning and smoothing, and normalizing.\n- Quantify the shift in the allowed regions using Kullback–Leibler divergence. For any two distributions $P$ and $Q$ defined over the same grid, with the union mask $\\mathcal{U}$, define the restricted and renormalized distributions:\n  $$P_{\\mathcal{U}}(i) = \\frac{P(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j P(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}, \\quad Q_{\\mathcal{U}}(i) = \\frac{Q(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j Q(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}.$$\n  Then compute\n  $$D_{\\mathrm{KL}}(P_{\\mathcal{U}} \\,\\|\\, Q_{\\mathcal{U}}) = \\sum_{i \\in \\mathcal{U}} P_{\\mathcal{U}}(i) \\, \\ln \\left( \\frac{P_{\\mathcal{U}}(i)}{Q_{\\mathcal{U}}(i)} \\right).$$\n  Use this to compute three quantities for each test case:\n  1. $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$,\n  2. $D_{\\mathrm{KL}}(P_{\\mathrm{pro},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$,\n  3. $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{pro},\\mathcal{U}})$.\n- All angle units are degrees. Express the final divergences as floats rounded to $6$ decimal places.\n\nUse the following datasets of $\\phi$ and $\\psi$ angles (in degrees). Each ordered pair is $(\\phi,\\psi)$ and all angles must be treated within $[-180,180)$ using modular wrapping where needed:\n- Glycine dataset $\\mathcal{D}_{\\mathrm{gly}}$:\n  $$\n  \\{(80,20),(85,15),(90,10),(75,25),(95,5),(100,0),(70,30),(85,5),(-60,-40),(-65,-35),(-55,-45),(-70,-30),(-50,-50),(-120,130),(-125,135),(-115,125),(-130,140),(-110,120)\\}.\n  $$\n- Proline dataset $\\mathcal{D}_{\\mathrm{pro}}$:\n  $$\n  \\{(-65,140),(-60,145),(-70,135),(-55,150),(-75,130),(-60,-35),(-65,-30),(-55,-25),(-70,-40),(-50,-20),(-120,130),(-115,125)\\}.\n  $$\n\nDesign the discrete grid with bin width $w$ degrees so that the number of bins per axis is $N = \\frac{360}{w}$, an integer. Bins should partition the domain $\\phi \\in [-180,180)$ and $\\psi \\in [-180,180)$ with left-inclusive and right-exclusive intervals.\n\nImplement the following test suite of parameter sets $(w,\\alpha,\\tau)$:\n- Test case $1$: $w=30$, $\\alpha=10^{-3}$, $\\tau=10^{-2}$.\n- Test case $2$: $w=90$, $\\alpha=10^{-6}$, $\\tau=3 \\times 10^{-2}$.\n- Test case $3$: $w=15$, $\\alpha=10^{-2}$, $\\tau=5 \\times 10^{-3}$.\n\nFor each test case, compute the three divergences listed above. Your program should produce a single line of output containing all $9$ results (three per test case in the order listed above for test cases $1$, $2$, and $3$) as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,\\dots,r_9]$), with each $r_k$ rounded to $6$ decimal places. All outputs are dimensionless floats.",
            "solution": "The user-provided problem is a well-defined computational task in the domain of chemical biology and statistical analysis. It requires the implementation of a pipeline to quantify differences between the conformational preferences of Glycine and Proline amino acids, as represented by their $(\\phi, \\psi)$ backbone dihedral angles on a Ramachandran plot. The problem is validated as sound, self-contained, and algorithmically specified.\n\nThe solution proceeds through the following steps for each given test case $(w, \\alpha, \\tau)$:\n\n1.  **Data Preparation**: The provided datasets for Glycine ($\\mathcal{D}_{\\mathrm{gly}}$) and Proline ($\\mathcal{D}_{\\mathrm{pro}}$) are parsed. A third, combined dataset ($\\mathcal{D}_{\\mathrm{mix}}$) is created by concatenating the first two. All angles are in degrees, within the range $[-180, 180)$.\n\n2.  **Grid Discretization**: The continuous two-dimensional angular space $(\\phi, \\psi) \\in [-180, 180) \\times [-180, 180)$ is discretized into a grid of square bins. The bin width, $w$, determines the number of bins per axis, $N = \\frac{360}{w}$. The bins partition the domain with left-inclusive and right-exclusive intervals, a standard convention handled by `numpy.histogram2d`.\n\n3.  **Empirical Distribution Estimation**: For each dataset ($\\mathcal{D}_{\\mathrm{gly}}, \\mathcal{D}_{\\mathrm{pro}}, \\mathcal{D}_{\\mathrm{mix}}$), a two-dimensional histogram is computed to count the number of data points falling into each bin of the grid. This yields a raw count matrix.\n\n4.  **Dirichlet Smoothing**: To prevent issues with zero probabilities, which would make the Kullback-Leibler divergence undefined, additive (Dirichlet) smoothing is applied. A small positive constant, $\\alpha$, is added to the count in every bin. This ensures that every bin in the resulting probability distribution will have a non-zero probability. The smoothed count for a bin $i$ is $C'_i = C_i + \\alpha$, where $C_i$ is the raw count.\n\n5.  **Normalization**: The smoothed count matrices are normalized to become discrete probability distributions ($P_{\\mathrm{gly}}$, $P_{\\mathrm{pro}}$, $P_{\\mathrm{mix}}$). This is achieved by dividing each smoothed bin count by the sum of all smoothed counts across the entire grid. For a distribution $P$, the probability of bin $i$ is $P(i) = \\frac{C'_i}{\\sum_j C'_j}$.\n\n6.  **Allowed Region Identification**: The \"allowed\" conformational space for Glycine and Proline is defined as the set of bins where the probability meets or exceeds a given threshold, $\\tau$. This creates two boolean masks, $\\mathcal{R}_{\\mathrm{gly}}$ and $\\mathcal{R}_{\\mathrm{pro}}$, where an element is `True` if the corresponding bin is allowed.\n\n7.  **Union Mask Construction**: A union mask, $\\mathcal{U} = \\mathcal{R}_{\\mathrm{gly}} \\cup \\mathcal{R}_{\\mathrm{pro}}$, is constructed by taking the element-wise logical OR of the two allowed region masks. This mask, $\\mathcal{U}$, represents the combined set of significantly populated bins for both amino acids. A special condition is handled: if $\\mathcal{U}$ is empty (i.e., no bin meets the threshold $\\tau$ for either amino acid), $\\mathcal{U}$ is redefined to encompass the entire grid, ensuring the subsequent renormalization step is well-defined.\n\n8.  **Restricted and Renormalized Distributions**: As per the problem's definition, for any pair of distributions $P$ and $Q$ to be compared, they are first restricted to the bins within the union mask $\\mathcal{U}$. The probabilities within this restricted set of bins are then renormalized to sum to $1$. This creates the distributions $P_{\\mathcal{U}}$ and $Q_{\\mathcal{U}}$, upon which the divergence is calculated. Formally, for each bin $i$:\n    $$P_{\\mathcal{U}}(i) = \\frac{P(i) \\cdot \\mathbf{1}_{\\mathcal{U}}(i)}{\\sum_j P(j) \\cdot \\mathbf{1}_{\\mathcal{U}}(j)}$$\n    where $\\mathbf{1}_{\\mathcal{U}}(i)$ is the indicator function for the mask $\\mathcal{U}$.\n\n9.  **Kullback-Leibler (KL) Divergence Calculation**: The KL divergence is computed to quantify the difference between two of these renormalized distributions. The formula used is:\n    $$D_{\\mathrm{KL}}(P_{\\mathcal{U}} \\,\\|\\, Q_{\\mathcal{U}}) = \\sum_{i \\in \\mathcal{U}} P_{\\mathcal{U}}(i) \\, \\ln \\left( \\frac{P_{\\mathcal{U}}(i)}{Q_{\\mathcal{U}}(i)} \\right)$$\n    Since smoothing ensures all probabilities are strictly positive, the logarithm is always well-defined. The sum is calculated over all elements in the renormalized probability vectors corresponding to the mask $\\mathcal{U}$. This process is repeated to obtain the three specified divergence values for each test case: $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$, $D_{\\mathrm{KL}}(P_{\\mathrm{pro},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{mix},\\mathcal{U}})$, and $D_{\\mathrm{KL}}(P_{\\mathrm{gly},\\mathcal{U}} \\,\\|\\, P_{\\mathrm{pro},\\mathcal{U}})$.\n\n10. **Final Output Formatting**: The computed divergence values from all test cases are collected, rounded to six decimal places, and formatted into a single comma-separated string enclosed in square brackets as per the problem specification.",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes Ramachandran plot-based KL divergences for Glycine and Proline.\n    \"\"\"\n\n    # --- Data Definitions ---\n    # Glycine dataset D_gly: (phi, psi) angles in degrees.\n    D_GLY = np.array([\n        (80, 20), (85, 15), (90, 10), (75, 25), (95, 5), (100, 0), (70, 30), (85, 5),\n        (-60, -40), (-65, -35), (-55, -45), (-70, -30), (-50, -50),\n        (-120, 130), (-125, 135), (-115, 125), (-130, 140), (-110, 120)\n    ], dtype=float)\n\n    # Proline dataset D_pro: (phi, psi) angles in degrees.\n    D_PRO = np.array([\n        (-65, 140), (-60, 145), (-70, 135), (-55, 150), (-75, 130),\n        (-60, -35), (-65, -30), (-55, -25), (-70, -40), (-50, -20),\n        (-120, 130), (-115, 125)\n    ], dtype=float)\n\n    # Combined dataset D_mix by pooling Glycine and Proline observations.\n    D_MIX = np.concatenate((D_GLY, D_PRO))\n\n    # --- Helper Functions ---\n    def create_distribution(dataset, w, alpha):\n        \"\"\"\n        Constructs a smoothed, normalized 2D probability distribution from a dataset.\n\n        Args:\n            dataset (np.ndarray): Array of (phi, psi) coordinates.\n            w (float): Bin width in degrees.\n            alpha (float): Additive smoothing parameter.\n\n        Returns:\n            np.ndarray: A 2D array representing the probability distribution.\n        \"\"\"\n        num_bins = int(360 / w)\n        bins = np.linspace(-180, 180, num_bins + 1)\n        \n        if dataset.shape[0] == 0:\n            counts = np.zeros((num_bins, num_bins), dtype=float)\n        else:\n            phi, psi = dataset[:, 0], dataset[:, 1]\n            counts, _, _ = np.histogram2d(phi, psi, bins=[bins, bins], range=[[-180, 180], [-180, 180]])\n\n        smoothed_counts = counts + alpha\n        total_pseudo_counts = smoothed_counts.sum()\n        \n        if total_pseudo_counts == 0:\n            # Fallback for empty smoothed counts, though won't occur with alpha > 0\n            return np.full((num_bins, num_bins), 1.0 / (num_bins**2), dtype=float)\n        \n        return smoothed_counts / total_pseudo_counts\n\n    def calculate_kl_divergence(P, Q, U):\n        \"\"\"\n        Computes the Kullback-Leibler divergence D_KL(P_U || Q_U).\n\n        Args:\n            P (np.ndarray): The first probability distribution.\n            Q (np.ndarray): The second probability distribution.\n            U (np.ndarray): The boolean mask for the union of allowed regions.\n\n        Returns:\n            float: The calculated KL divergence.\n        \"\"\"\n        # Restrict distributions to the union mask U\n        P_restricted = P[U]\n        Q_restricted = Q[U]\n        \n        # Renormalize the restricted distributions\n        P_U = P_restricted / P_restricted.sum()\n        Q_U = Q_restricted / Q_restricted.sum()\n        \n        # Calculate KL divergence. Additive smoothing ensures P_U and Q_U are > 0.\n        return np.sum(P_U * (np.log(P_U) - np.log(Q_U)))\n\n    def process_case(w, alpha, tau):\n        \"\"\"\n        Processes a single test case and returns the three required KL divergences.\n        \n        Args:\n            w (float): Bin width.\n            alpha (float): Smoothing parameter.\n            tau (float): Probability threshold for allowed regions.\n            \n        Returns:\n            list: A list of three computed divergence values.\n        \"\"\"\n        # Step 1: Create probability distributions\n        P_gly = create_distribution(D_GLY, w, alpha)\n        P_pro = create_distribution(D_PRO, w, alpha)\n        P_mix = create_distribution(D_MIX, w, alpha)\n        \n        # Step 2: Determine allowed regions and their union\n        R_gly = P_gly >= tau\n        R_pro = P_pro >= tau\n        U = np.logical_or(R_gly, R_pro)\n        \n        if not np.any(U):\n            U = np.full(P_gly.shape, True, dtype=bool)\n\n        # Step 3: Compute the three specified KL divergences\n        d1 = calculate_kl_divergence(P_gly, P_mix, U)\n        d2 = calculate_kl_divergence(P_pro, P_mix, U)\n        d3 = calculate_kl_divergence(P_gly, P_pro, U)\n        \n        return [d1, d2, d3]\n\n    # --- Main Execution ---\n    test_cases = [\n        # (w, alpha, tau)\n        (30, 1e-3, 1e-2),\n        (90, 1e-6, 3e-2),\n        (15, 1e-2, 5e-3),\n    ]\n\n    all_results = []\n    for w, alpha, tau in test_cases:\n        results_for_case = process_case(w, alpha, tau)\n        all_results.extend(results_for_case)\n\n    # Final formatting and printing\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "Building upon foundational principles, we now advance to a sophisticated, knowledge-based approach used in modern protein structure validation. This problem involves a probabilistic model where the $(\\phi, \\psi)$ distribution is described by a mixture of von Mises functions, representing the main secondary structure regions (). Your task is to implement this model to classify residue conformations into favored, allowed, and outlier regions, providing a powerful tool for assessing the quality and plausibility of a given protein structure.",
            "id": "3861147",
            "problem": "You are given a simplified, physically motivated, knowledge-based model of the backbone torsion angle distribution used to classify residues on a Ramachandran plot. The backbone torsion angles are the dihedral angles $\\phi$ and $\\psi$ defined by successive peptide plane geometry. Because $\\phi$ and $\\psi$ are angular variables on the circle, conformational preferences are periodic. We model the joint distribution of $(\\phi,\\psi)$ by a mixture of independent von Mises components on the two-torus, reflecting well-established canonical regions (right-handed $\\alpha$ helix, $\\beta$ sheet, polyproline II, left-handed $\\alpha$ helix). The model is specified by the following probability density function (Probability Density Function (PDF)) in radians:\n$$\np(\\phi,\\psi) \\;=\\; \\sum_{j=1}^{J} w_j\\, f_{\\mathrm{VM}}(\\phi;\\mu_{\\phi,j},\\kappa_{\\phi,j})\\, f_{\\mathrm{VM}}(\\psi;\\mu_{\\psi,j},\\kappa_{\\psi,j}),\n$$\nwhere $J$ is the number of mixture components, $w_j$ are nonnegative weights with $\\sum_{j=1}^{J} w_j = 1$, $\\mu_{\\phi,j}$ and $\\mu_{\\psi,j}$ are the component means in radians, and $\\kappa_{\\phi,j}$ and $\\kappa_{\\psi,j}$ are concentration parameters. The one-dimensional von Mises density (in radians) is\n$$\nf_{\\mathrm{VM}}(\\theta;\\mu,\\kappa) \\;=\\; \\frac{e^{\\kappa \\cos(\\theta-\\mu)}}{2\\pi I_0(\\kappa)},\n$$\nwith $I_0$ the modified Bessel function of the first kind of order $0$. The mixture parameters are:\n- $J = 4$,\n- $(w_1,w_2,w_3,w_4) = (0.55,\\,0.35,\\,0.07,\\,0.03)$,\n- Component $1$ (right-handed $\\alpha$ helix): $(\\mu_{\\phi,1},\\mu_{\\psi,1}) = (-60^\\circ,-45^\\circ)$, $(\\kappa_{\\phi,1},\\kappa_{\\psi,1}) = (25,\\,25)$,\n- Component $2$ ($\\beta$ sheet): $(\\mu_{\\phi,2},\\mu_{\\psi,2}) = (-135^\\circ,135^\\circ)$, $(\\kappa_{\\phi,2},\\kappa_{\\psi,2}) = (35,\\,20)$,\n- Component $3$ (polyproline II): $(\\mu_{\\phi,3},\\mu_{\\psi,3}) = (-75^\\circ,145^\\circ)$, $(\\kappa_{\\phi,3},\\kappa_{\\psi,3}) = (15,\\,15)$,\n- Component $4$ (left-handed $\\alpha$ helix): $(\\mu_{\\phi,4},\\mu_{\\psi,4}) = (60^\\circ,30^\\circ)$, $(\\kappa_{\\phi,4},\\kappa_{\\psi,4}) = (20,\\,20)$.\nFor computations, angles must be converted from degrees to radians using $\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}}\\times\\pi/180$.\n\nDefine the favored region $L_f$ as the upper-level set of the density that captures a specified high-probability mass $p_f$, that is\n$$\nL_f \\;=\\; \\{(\\phi,\\psi) \\;:\\; p(\\phi,\\psi) \\;\\ge\\; \\tau_f\\}, \\quad \\text{where } \\iint_{L_f} p(\\phi,\\psi)\\, d\\phi\\, d\\psi \\;=\\; p_f,\n$$\nwith $p_f = 0.98$. Define the allowed region $L_a$ analogously with $p_a = 0.999$ and threshold $\\tau_a$, that is\n$$\nL_a \\;=\\; \\{(\\phi,\\psi) \\;:\\; p(\\phi,\\psi) \\;\\ge\\; \\tau_a\\}, \\quad \\text{where } \\iint_{L_a} p(\\phi,\\psi)\\, d\\phi\\, d\\psi \\;=\\; p_a.\n$$\nA residue with angles $(\\phi_i,\\psi_i)$ is classified as favored if $(\\phi_i,\\psi_i)\\in L_f$, allowed-only if $(\\phi_i,\\psi_i)\\in L_a\\setminus L_f$, and outlier if $(\\phi_i,\\psi_i)\\notin L_a$. The fractions are defined as\n$$\nF_f \\;=\\; \\frac{N_f}{N},\\quad F_{ao} \\;=\\; \\frac{N_{ao}}{N},\\quad F_o \\;=\\; \\frac{N_o}{N},\n$$\nwhere $N$ is the total number of residues, $N_f$ is the count of favored residues, $N_{ao}$ is the count of allowed-only residues, and $N_o$ is the count of outliers. The inclusive allowed fraction is $F_{\\mathrm{inc}} = F_f + F_{ao}$.\n\nApproximate the thresholds $\\tau_f$ and $\\tau_a$ numerically by discretizing the $(\\phi,\\psi)$ domain uniformly on a grid in degrees over $[-180^\\circ,180^\\circ]\\times[-180^\\circ,180^\\circ]$ with step $\\Delta = 1^\\circ$, converting to radians for evaluation of $p(\\phi,\\psi)$ at each grid point, sorting the grid densities in descending order, and selecting the smallest density value whose cumulative Riemann sum first equals or exceeds $p_f$ (resp. $p_a$). Use the Riemann rectangle area $A_{\\mathrm{cell}} = (\\Delta\\pi/180)^2$.\n\nFinally, compare the computed fractions to standard validation thresholds, reporting three boolean tests per case:\n- favored fraction test: $F_f \\ge \\theta_f$ with $\\theta_f = 0.95$,\n- allowed fraction test (inclusive): $F_{\\mathrm{inc}} \\ge \\theta_a$ with $\\theta_a = 0.99$,\n- outliers fraction test: $F_o \\le \\theta_o$ with $\\theta_o = 0.01$.\n\nAngles are to be interpreted in degrees, and the program must output fractions as decimals rounded to three decimal places. Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets, where each element corresponds to one test case and is itself a list of six entries in the order $[F_f, F_{ao}, F_o, \\text{favored\\_pass}, \\text{allowed\\_pass}, \\text{outlier\\_pass}]$.\n\nUse the following test suite of residue angle sets (in degrees):\n- Test case $1$ ($N=10$ residues):\n  $[(-60,-45),\\,(-58,-47),\\,(-62,-50),\\,(-130,130),\\,(-135,135),\\,(-75,145),\\,(60,30),\\,(-120,120),\\,(0,0),\\,(-61,-44)]$.\n- Test case $2$ ($N=12$ residues):\n  $[(-179,179),\\,(179,-179),\\,(-180,180),\\,(-75,145),\\,(60,30),\\,(-60,130),\\,(-140,140),\\,(-65,-40),\\,(-135,120),\\,(62,28),\\,(170,-170),\\,(-170,170)]$.\n- Test case $3$ ($N=14$ residues):\n  $[(0,180),\\,(180,0),\\,(90,-90),\\,(-90,90),\\,(120,0),\\,(0,-120),\\,(-45,160),\\,(80,80),\\,(-80,-80),\\,(-130,130),\\,(-60,-45),\\,(-135,135),\\,(10,10),\\,(-10,-10)]$.\n\nYour task is to implement the program that:\n- computes $\\tau_f$ and $\\tau_a$ using the grid-based approximation above,\n- classifies each residue in each test case,\n- computes $F_f$, $F_{ao}$, $F_o$, and the three validation booleans, with fractions rounded to three decimal places,\n- outputs a single line in the exact format described above.",
            "solution": "The problem statement has been analyzed and is determined to be **valid**. It is scientifically grounded in the principles of computational structural biology, specifically the statistical analysis of protein backbone conformations. The problem is well-posed, providing a complete and consistent set of definitions, parameters, and numerical procedures. All terms are objectively and mathematically defined, allowing for a unique and verifiable solution.\n\nThe task is to classify protein residue backbone conformations, defined by dihedral angles $(\\phi, \\psi)$, based on a probabilistic model and then to perform a statistical validation of given sets of residues. The solution involves three main stages:\n1.  Determining probability density thresholds that define 'favored' and 'allowed' conformational regions.\n2.  Classifying individual residues based on these thresholds.\n3.  Calculating the fractions of residues in each category and comparing them against standard quality-control benchmarks.\n\n**1. Probabilistic Model of Backbone Conformation**\n\nThe conformational space of the protein backbone is described by the dihedral angles $(\\phi, \\psi)$. The problem provides a knowledge-based energy model in the form of a probability density function $p(\\phi,\\psi)$. This function is constructed as a mixture model, which is a sum of simpler distributions, each representing a canonical protein secondary structure element.\n$$\np(\\phi,\\psi) \\;=\\; \\sum_{j=1}^{J} w_j\\, f_{\\mathrm{VM}}(\\phi;\\mu_{\\phi,j},\\kappa_{\\phi,j})\\, f_{\\mathrm{VM}}(\\psi;\\mu_{\\psi,j},\\kappa_{\\psi,j})\n$$\nHere, $J=4$ components correspond to the right-handed $\\alpha$-helix, $\\beta$-sheet, polyproline II helix, and left-handed $\\alpha$-helix. Each component is weighted by $w_j$, representing its prevalence in a large database of protein structures. The angles $\\phi$ and $\\psi$ are periodic, so the appropriate probability distribution for each is the von Mises distribution, which is a circular analogue of the normal distribution. The von Mises PDF is given by:\n$$\nf_{\\mathrm{VM}}(\\theta;\\mu,\\kappa) \\;=\\; \\frac{e^{\\kappa \\cos(\\theta-\\mu)}}{2\\pi I_0(\\kappa)}\n$$\nThe parameters $\\mu$ and $\\kappa$ represent the mean angle and the concentration (inverse of variance), respectively. $I_0(\\kappa)$ is the modified Bessel function of the first kind of order $0$, which serves as the normalization constant ensuring the integral of the distribution over the circle $[-\\pi, \\pi]$ is unity. The full $p(\\phi, \\psi)$ is a distribution on the two-torus, and because the constituent $\\phi$ and $\\psi$ distributions for each component are independent, the joint PDF for a component is the product of two one-dimensional von Mises PDFs. All angle parameters $(\\mu_{\\phi,j}, \\mu_{\\psi,j})$ are provided in degrees and must be converted to radians for calculation, using the relation $\\theta_{\\mathrm{rad}} = \\theta_{\\mathrm{deg}} \\times \\pi / 180$.\n\n**2. Determination of Density Thresholds**\n\nThe problem defines 'favored' ($L_f$) and 'allowed' ($L_a$) regions of the Ramachandran plot as high-probability density level sets. Specifically, $L_f$ is a region $\\{(\\phi,\\psi) : p(\\phi,\\psi) \\ge \\tau_f\\}$ that contains $p_f = 98\\%$ of the total probability mass, and $L_a$ is a region $\\{(\\phi,\\psi) : p(\\phi,\\psi) \\ge \\tau_a\\}$ containing $p_a = 99.9\\%$ of the mass. The core of this task is to find the density thresholds $\\tau_f$ and $\\tau_a$.\n\nAn analytical solution for these thresholds is intractable. Therefore, a numerical approach is prescribed. The continuous $(\\phi, \\psi)$ space is discretized into a uniform grid. The problem specifies a grid over $[-180^\\circ, 180^\\circ]\\times[-180^\\circ, 180^\\circ]$ with a step size of $\\Delta = 1^\\circ$. To correctly handle the periodicity of the domain, we utilize a grid of $360 \\times 360$ points, for instance, covering the angles $[-180^\\circ, 179^\\circ]$ in each dimension. This corresponds to the periodic domain $[-\\pi, \\pi) \\times [-\\pi, \\pi)$ in radians.\n\nThe algorithm to find the thresholds is as follows:\n1.  Construct the $360 \\times 360$ grid of $(\\phi, \\psi)$ angle pairs in radians.\n2.  Evaluate the PDF $p(\\phi, \\psi)$ at each of the $360^2 = 129,600$ grid points.\n3.  Flatten the resulting 2D array of density values into a 1D list and sort it in descending order, yielding $p_{(1)} \\ge p_{(2)} \\ge \\dots \\ge p_{(N)}$, where $N=129600$.\n4.  The integral of the PDF over the domain is approximated by a Riemann sum: $\\iint p(\\phi,\\psi) d\\phi d\\psi \\approx \\sum_{k=1}^N p_{(k)} A_{\\mathrm{cell}}$, where $A_{\\mathrm{cell}} = (\\Delta \\cdot \\pi/180)^2$ is the area of a single grid cell in radians squared.\n5.  The cumulative probability for the $k$ most probable points is $C_k = A_{\\mathrm{cell}} \\sum_{i=1}^k p_{(i)}$.\n6.  The threshold $\\tau_f$ is the smallest density value $p_{(k_f)}$ for which the cumulative probability $C_{k_f}$ first meets or exceeds $p_f = 0.98$. Similarly, $\\tau_a$ is $p_{(k_a)}$ where $C_{k_a}$ first meets or exceeds $p_a = 0.999$. These indices $k_f$ and $k_a$ are found efficiently using a search algorithm on the cumulative probability array.\n\n**3. Residue Classification and Validation**\n\nWith the thresholds $\\tau_f$ and $\\tau_a$ determined, each residue from the test cases can be classified. For a given residue with angles $(\\phi_i, \\psi_i)$:\n1.  The angles, provided in degrees, are first converted to radians. To handle periodicity robustly, angles are mapped to the interval $[-180^\\circ, 180^\\circ)$ or $[-\\pi, \\pi)$ in radians.\n2.  The probability density $p_i = p(\\phi_i, \\psi_i)$ is calculated using the mixture model.\n3.  The residency is classified based on the following rules:\n    *   **Favored**: if $p_i \\ge \\tau_f$.\n    *   **Allowed-only**: if $\\tau_a \\le p_i  \\tau_f$.\n    *   **Outlier**: if $p_i  \\tau_a$.\n\nFor each test case (a set of residues), we count the number of residues in each category ($N_f, N_{ao}, N_o$). From these counts and the total number of residues $N$, we compute the fractions:\n$$\nF_f \\;=\\; \\frac{N_f}{N},\\quad F_{ao} \\;=\\; \\frac{N_{ao}}{N},\\quad F_o \\;=\\; \\frac{N_o}{N}\n$$\nThese fractions, which represent the quality of the given protein model, are compared against standard validation thresholds:\n*   Favored fraction test: $F_f \\ge 0.95$.\n*   Allowed fraction test (inclusive): $F_{\\mathrm{inc}} = F_f + F_{ao} \\ge 0.99$.\n*   Outliers fraction test: $F_o \\le 0.01$.\n\nThe final output for each test case is a list containing the computed fractions ($F_f, F_{ao}, F_o$), rounded to three decimal places, and the three boolean results of these tests.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import i0\n\ndef solve():\n    \"\"\"\n    Computes Ramachandran plot statistics based on a von Mises mixture model.\n    \"\"\"\n    # ------------------ MODEL PARAMETERS ------------------\n    # Conversion factor from degrees to radians\n    deg_to_rad = np.pi / 180.0\n\n    # Mixture model parameters\n    weights = np.array([0.55, 0.35, 0.07, 0.03])\n    means_deg = np.array([\n        [-60.0, -45.0],   # Component 1: right-handed alpha-helix\n        [-135.0, 135.0],  # Component 2: beta-sheet\n        [-75.0, 145.0],   # Component 3: polyproline II\n        [60.0, 30.0]      # Component 4: left-handed alpha-helix\n    ])\n    kappas = np.array([\n        [25.0, 25.0],\n        [35.0, 20.0],\n        [15.0, 15.0],\n        [20.0, 20.0]\n    ])\n    \n    # Convert mean angles to radians\n    means_rad = means_deg * deg_to_rad\n\n    # Target probability masses for regions\n    p_f = 0.98\n    p_a = 0.999\n\n    # Validation thresholds for fractions\n    theta_f = 0.95\n    theta_a = 0.99\n    theta_o = 0.01\n\n    # ------------------ HELPER FUNCTIONS ------------------\n    def f_vm(theta, mu, kappa):\n        \"\"\"Calculates the 1D von Mises PDF.\"\"\"\n        # The i0 function is vectorized.\n        norm_const = 2.0 * np.pi * i0(kappa)\n        return np.exp(kappa * np.cos(theta - mu)) / norm_const\n\n    def p_phi_psi(phi, psi, W, M, K):\n        \"\"\"Calculates the 2D mixture model PDF for scalar or array inputs.\"\"\"\n        total_p = np.zeros_like(phi, dtype=np.float64)\n        for j in range(len(W)):\n            f_phi = f_vm(phi, M[j, 0], K[j, 0])\n            f_psi = f_vm(psi, M[j, 1], K[j, 1])\n            total_p += W[j] * f_phi * f_psi\n        return total_p\n\n    def calculate_thresholds():\n        \"\"\"Numerically determines the density thresholds tau_f and tau_a.\"\"\"\n        delta_deg = 1.0\n        grid_angles_deg = np.arange(-180.0, 180.0, delta_deg)\n        phi_deg_grid, psi_deg_grid = np.meshgrid(grid_angles_deg, grid_angles_deg)\n\n        phi_rad_grid = phi_deg_grid * deg_to_rad\n        psi_rad_grid = psi_deg_grid * deg_to_rad\n\n        # Evaluate PDF on the grid\n        p_grid = p_phi_psi(phi_rad_grid, psi_rad_grid, weights, means_rad, kappas)\n\n        # Flatten and sort densities in descending order\n        p_flat_sorted = np.sort(p_grid.flatten())[::-1]\n\n        # Calculate cumulative probability using Riemann sum\n        delta_rad = delta_deg * deg_to_rad\n        A_cell = delta_rad ** 2\n        cum_prob = np.cumsum(p_flat_sorted) * A_cell\n\n        # Find indices where cumulative probability exceeds targets\n        idx_f = np.searchsorted(cum_prob, p_f)\n        idx_a = np.searchsorted(cum_prob, p_a)\n\n        # Thresholds are the density values at these indices\n        tau_f = p_flat_sorted[idx_f]\n        tau_a = p_flat_sorted[idx_a]\n        return tau_f, tau_a\n\n    # ------------------ MAIN LOGIC ------------------\n    # Calculate thresholds once\n    tau_f, tau_a = calculate_thresholds()\n    \n    # Test case data\n    test_cases_deg = [\n        [(-60, -45), (-58, -47), (-62, -50), (-130, 130), (-135, 135), (-75, 145), (60, 30), (-120, 120), (0, 0), (-61, -44)],\n        [(-179, 179), (179, -179), (-180, 180), (-75, 145), (60, 30), (-60, 130), (-140, 140), (-65, -40), (-135, 120), (62, 28), (170, -170), (-170, 170)],\n        [(0, 180), (180, 0), (90, -90), (-90, 90), (120, 0), (0, -120), (-45, 160), (80, 80), (-80, -80), (-130, 130), (-60, -45), (-135, 135), (10, 10), (-10, -10)]\n    ]\n\n    all_results = []\n    \n    for case_data_deg in test_cases_deg:\n        N = len(case_data_deg)\n        N_f, N_ao, N_o = 0, 0, 0\n\n        angles = np.array(case_data_deg, dtype=np.float64)\n        \n        # Convert all angles to radians for calculation\n        phi_rad_data = angles[:, 0] * deg_to_rad\n        psi_rad_data = angles[:, 1] * deg_to_rad\n\n        # Calculate PDF for all residues in the case\n        densities = p_phi_psi(phi_rad_data, psi_rad_data, weights, means_rad, kappas)\n\n        for p_val in densities:\n            if p_val >= tau_f:\n                N_f += 1\n            elif p_val >= tau_a:\n                N_ao += 1\n            else:\n                N_o += 1\n\n        # Calculate fractions\n        F_f = N_f / N\n        F_ao = N_ao / N\n        F_o = N_o / N\n        F_inc = F_f + F_ao\n\n        # Perform validation tests\n        favored_pass = F_f >= theta_f\n        allowed_pass = F_inc >= theta_a\n        outlier_pass = F_o = theta_o\n\n        # Assemble the result for the case as specified\n        case_result = [\n            f\"{F_f:.3f}\",\n            f\"{F_ao:.3f}\",\n            f\"{F_o:.3f}\",\n            favored_pass,\n            allowed_pass,\n            outlier_pass\n        ]\n        \n        # Format the list into a string\n        inner_list_str = f\"[{case_result[0]},{case_result[1]},{case_result[2]},{str(case_result[3]).lower()},{str(case_result[4]).lower()},{str(case_result[5]).lower()}]\"\n        all_results.append(inner_list_str)\n\n    # Print a single line with all results in the required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```"
        }
    ]
}