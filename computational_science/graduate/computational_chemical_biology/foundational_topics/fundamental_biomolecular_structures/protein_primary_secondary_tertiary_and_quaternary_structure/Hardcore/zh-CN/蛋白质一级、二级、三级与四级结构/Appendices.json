{
    "hands_on_practices": [
        {
            "introduction": "蛋白质的稳定三维结构是由多种力的微妙平衡所决定的，其中氢键在定义二级结构（如 $\\alpha$-螺旋和 $\\beta$-折叠）方面起着至关重要的作用。本练习将指导您使用一个简化的、但基于物理原理的静电模型来量化这些关键相互作用的强度。通过这个计算 ，您将亲身体验到几何参数（距离和角度）如何直接转化为能量上的稳定性，从而加深对稳定蛋白质二级结构所需精确几何排列的理解。",
            "id": "3859736",
            "problem": "一个形成反平行$\\beta$折叠的蛋白质片段在主链供体和受体之间呈现出一组链间氢键。在一个与分子力学一致的粗粒化静电模型中，氢键被处理为嵌入在具有有效相对介电常数的介质中的供体氢部分电荷和受体羰基氧部分电荷之间的相互作用。基本出发点是库仑定律以及一个观察结果，即氢键的方向性之所以产生，是因为只有供体$\\text{N}-\\text{H}$向量与$\\text{H}\\cdots\\text{O}$轴共线的组分才能有效稳定该相互作用。因此，稳定相互作用的强度与$\\text{N}-\\text{H}$键和$\\text{H}\\cdots\\text{O}$轴之间方向余弦的平方成正比，该方向余弦是从基本向量几何中的投影因子推导出来的。\n\n假设以下物理上合理的模型选择：\n- 库仑定律支配部分电荷的相互作用：供体氢$q_{\\text{H}}$和受体氧$q_{\\text{O}}$相距$r_{\\text{H}\\text{O}}$，由适用于蛋白质内部的有效相对介电常数$\\varepsilon_{r}$屏蔽。\n- 方向性由$\\text{N}-\\text{H}$向量与$\\text{H}\\cdots\\text{O}$向量之间余弦的平方引入。氢键角以供体-氢-受体角$\\theta$给出（在$\\theta = 180^\\circ$时为线性）。在计算三角函数时，使用投影因子$\\cos^{2}(\\theta)$，并将$\\theta$转换为弧度。\n- 使用生物分子库仑常数$k_{c}$，单位为千焦/摩尔、纳米和平方基本电荷。\n\n参数：\n- 部分电荷（以基本电荷为单位）：$q_{\\text{H}} = +0.33$ 和 $q_{\\text{O}} = -0.51$。\n- 有效相对介电常数：$\\varepsilon_{r} = 4$。\n- 库仑常数：$k_{c} = 138.935456$（千焦每摩尔纳米每平方基本电荷）。\n- 五个链间氢键，其氢-受体距离$r_{\\text{H}\\text{O}}$（单位为纳米）和供体-氢-受体角$\\theta$（单位为度）如下：\n  - 键 $1$：$r_{\\text{H}\\text{O}} = 0.193$，$\\theta = 171$。\n  - 键 $2$：$r_{\\text{H}\\text{O}} = 0.198$，$\\theta = 165$。\n  - 键 $3$：$r_{\\text{H}\\text{O}} = 0.205$，$\\theta = 160$。\n  - 键 $4$：$r_{\\text{H}\\text{O}} = 0.190$，$\\theta = 176$。\n  - 键 $5$：$r_{\\text{H}\\text{O}} = 0.202$，$\\theta = 168$。\n\n仅从库仑定律和上述方向投影原理出发，通过对五个键的贡献求和来计算总氢键能。在应用余弦函数之前，将每个$\\theta$从度数转换为弧度。以千焦/摩尔表示最终答案，并四舍五入到四位有效数字。",
            "solution": "该问题要求计算反平行$\\beta$折叠中一组五个链间氢键的总氢键能。计算需使用指定的粗粒化静电模型进行。\n\n该模型基于库仑定律定义了单个氢键$i$的势能$E_i$，并进行了修改以考虑蛋白质环境的介电屏蔽和氢键的几何方向性。单个氢键的能量公式由屏蔽后的库仑相互作用与方向性缩放因子的乘积给出。\n\n供体氢部分电荷$q_{\\text{H}}$与受体氧部分电荷$q_{\\text{O}}$（相距$r_{\\text{H}\\text{O}}$）之间的屏蔽库仑相互作用能由以下公式给出：\n$$U_{\\text{Coulomb}} = k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r} r_{\\text{H}\\text{O}}}$$\n其中$k_{c}$是生物分子库仑常数，$\\varepsilon_{r}$是介质的有效相对介电常数。\n\n问题指出，氢键的方向性由因子$\\cos^2(\\theta)$来解释，其中$\\theta$是供体-氢-受体角。该因子调节相互作用的强度，在几何形状为线性时（$\\theta = 180^\\circ$或$\\pi$弧度）强度最大。\n\n结合这些原理，单个氢键$i$的能量公式为：\n$$E_i = k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r} r_i} \\cos^2(\\theta_i)$$\n角度$\\theta_i$以度为单位给出，在计算余弦函数时必须转换为弧度，使用换算公式$\\theta_{\\text{rad}} = \\theta_{\\text{deg}} \\times \\frac{\\pi}{180}$。\n\n总氢键能$E_{\\text{total}}$是五个独立氢键能量的总和：\n$$E_{\\text{total}} = \\sum_{i=1}^{5} E_i = \\sum_{i=1}^{5} k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r} r_i} \\cos^2(\\theta_i)$$\n\n我们可以提出常数项：\n$$E_{\\text{total}} = k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r}} \\sum_{i=1}^{5} \\frac{\\cos^2(\\theta_i)}{r_i}$$\n\n给定的参数是：\n- $k_{c} = 138.935456 \\, \\text{kJ} \\cdot \\text{mol}^{-1} \\cdot \\text{nm} \\cdot e^{-2}$\n- $q_{\\text{H}} = +0.33 \\, e$\n- $q_{\\text{O}} = -0.51 \\, e$\n- $\\varepsilon_{r} = 4$\n\n首先，我们计算常数前置因子：\n$$k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r}} = 138.935456 \\frac{(0.33) \\times (-0.51)}{4} = 138.935456 \\frac{-0.1683}{4}$$\n$$k_{c} \\frac{q_{\\text{H}} q_{\\text{O}}}{\\varepsilon_{r}} = -5.8465063008 \\, \\text{kJ} \\cdot \\text{mol}^{-1} \\cdot \\text{nm}$$\n负号表示一个稳定（吸引）的相互作用，这对于氢键是预期的。\n\n接下来，我们为五个键中的每一个计算$\\frac{\\cos^2(\\theta_i)}{r_i}$项。角度必须从度转换为弧度。\n\n- **键 1**：$r_1 = 0.193$ nm, $\\theta_1 = 171^\\circ$\n  $$\\frac{\\cos^2(171^\\circ)}{0.193 \\, \\text{nm}} = \\frac{\\cos^2(171 \\times \\frac{\\pi}{180})}{0.193} \\approx \\frac{0.975528}{0.193} \\, \\text{nm}^{-1} \\approx 5.054549 \\, \\text{nm}^{-1}$$\n\n- **键 2**：$r_2 = 0.198$ nm, $\\theta_2 = 165^\\circ$\n  $$\\frac{\\cos^2(165^\\circ)}{0.198 \\, \\text{nm}} = \\frac{\\cos^2(165 \\times \\frac{\\pi}{180})}{0.198} \\approx \\frac{0.933013}{0.198} \\, \\text{nm}^{-1} \\approx 4.712185 \\, \\text{nm}^{-1}$$\n\n- **键 3**：$r_3 = 0.205$ nm, $\\theta_3 = 160^\\circ$\n  $$\\frac{\\cos^2(160^\\circ)}{0.205 \\, \\text{nm}} = \\frac{\\cos^2(160 \\times \\frac{\\pi}{180})}{0.205} \\approx \\frac{0.883022}{0.205} \\, \\text{nm}^{-1} \\approx 4.307425 \\, \\text{nm}^{-1}$$\n\n- **键 4**：$r_4 = 0.190$ nm, $\\theta_4 = 176^\\circ$\n  $$\\frac{\\cos^2(176^\\circ)}{0.190 \\, \\text{nm}} = \\frac{\\cos^2(176 \\times \\frac{\\pi}{180})}{0.190} \\approx \\frac{0.995134}{0.190} \\, \\text{nm}^{-1} \\approx 5.237546 \\, \\text{nm}^{-1}$$\n\n- **键 5**：$r_5 = 0.202$ nm, $\\theta_5 = 168^\\circ$\n  $$\\frac{\\cos^2(168^\\circ)}{0.202 \\, \\text{nm}} = \\frac{\\cos^2(168 \\times \\frac{\\pi}{180})}{0.202} \\approx \\frac{0.956773}{0.202} \\, \\text{nm}^{-1} \\approx 4.736501 \\, \\text{nm}^{-1}$$\n\n现在，我们对这些值求和：\n$$\\sum_{i=1}^{5} \\frac{\\cos^2(\\theta_i)}{r_i} \\approx (5.054549 + 4.712185 + 4.307425 + 5.237546 + 4.736501) \\, \\text{nm}^{-1}$$\n$$\\sum_{i=1}^{5} \\frac{\\cos^2(\\theta_i)}{r_i} \\approx 24.048206 \\, \\text{nm}^{-1}$$\n\n最后，我们将这个和乘以常数前置因子得到总能量：\n$$E_{\\text{total}} \\approx (-5.8465063008 \\, \\text{kJ} \\cdot \\text{mol}^{-1} \\cdot \\text{nm}) \\times (24.048206 \\, \\text{nm}^{-1})$$\n$$E_{\\text{total}} \\approx -140.5985 \\, \\text{kJ} \\cdot \\text{mol}^{-1}$$\n\n问题要求最终答案四舍五入到四位有效数字。\n$$E_{\\text{total}} \\approx -140.6 \\, \\text{kJ} \\cdot \\text{mol}^{-1}$$\n这表示反平行$\\beta$折叠结构中由五个指定的氢键贡献的总稳定能。",
            "answer": "$$\\boxed{-140.6}$$"
        },
        {
            "introduction": "在计算结构生物学中，我们常常需要比較实验测定的结构和计算预测的模型，或者追踪蛋白质在分子动力学模拟中的构象变化。本练习  介绍了两种用于量化结构相似性的基本指标：均方根偏差（RMSD）和模板建模得分（TM-score）。通过在精心设计的案例上实现和测试这两种指标，您将直观地理解它们对局部和全局结构偏差的不同敏感性，并学会在评估蛋白质模型质量时如何选择和解读它们。",
            "id": "3859702",
            "problem": "给定两个三维蛋白质结构，由相应残基的对齐笛卡尔坐标表示，单位为 $\\text{\\AA}$ (埃)。目标是计算两种结构相似性度量，并在计算化学生物学中蛋白质三级和四级结构的背景下，分析它们对局部与全局偏差的敏感性。您的实现必须遵循基于基本定义的数学规定程序。\n\n使用的基础原理：\n- 设对齐的结构为 $\\mathbb{R}^3$中的点序列 $\\{ \\mathbf{a}_i \\}_{i=1}^L$ 和 $\\{ \\mathbf{b}_i \\}_{i=1}^L$，其中 $L$ 是对齐的残基数，每个 $\\mathbf{a}_i = (x_i^{(a)}, y_i^{(a)}, z_i^{(a)})$ 和 $\\mathbf{b}_i = (x_i^{(b)}, y_i^{(b)}, z_i^{(b)})$ 的单位均为 $\\text{\\AA}$。\n- $\\mathbb{R}^3$ 中的欧几里得范数定义为 $\\lVert \\mathbf{x} \\rVert_2 = \\sqrt{x_1^2 + x_2^2 + x_3^2}$。对齐残基之间的欧几里得距离平方为 $d_i^2 = \\lVert \\mathbf{a}_i - \\mathbf{b}_i \\rVert_2^2$。\n- 均方根偏差 (RMSD) 定义为对齐残基上 $d_i^2$ 均值的平方根。\n- 模板建模得分 (TM-score) 定义为一个有界递减函数在所有对齐残基上的均值，该函数是残基间距离的函数，并包含一个长度依赖的归一化因子 $d_0(L)$。使用广泛接受的参数化 $d_0(L) = \\max\\left(0.5,\\ 1.24\\,(L - 15)^{1/3} - 1.8\\right)$，其中 $L$ 的单位是残基数，以及每个残基的贡献 $f(d_i) = \\dfrac{1}{1 + \\left(\\dfrac{d_i}{d_0(L)}\\right)^2}$。\n\n任务：\n1. 对于下方的每个测试用例，根据给定参数确定性地生成对齐的坐标集 $(\\mathbf{a}_i)_{i=1}^L$ 和 $(\\mathbf{b}_i)_{i=1}^L$，然后计算：\n   - 均方根偏差 (RMSD)，单位为 $\\text{\\AA}$。\n   - 模板建模得分 (TM-score)，无量纲。\n2. 将每个报告的浮点数结果四舍五入到 $6$ 位小数。\n3. 按照指定的最终输出格式汇总所有测试用例的结果。\n\n测试套件定义 (所有坐标单位均为 $\\text{\\AA}$):\n- 情况 $1$ (理想情况，相同结构): $L = 5$。设 $\\mathbf{a}_i = (i, 0, 0)$，其中 $i = 0, 1, 2, 3, 4$。对所有 $i$，设 $\\mathbf{b}_i = \\mathbf{a}_i$。\n- 情况 $2$ (局部偏差边缘情况): $L = 5$。设 $\\mathbf{a}_i = (i, 0, 0)$，其中 $i = 0, 1, 2, 3, 4$。对所有 $i \\neq 2$，设 $\\mathbf{b}_i = \\mathbf{a}_i$；对于 $i = 2$，设 $\\mathbf{b}_2 = (2, 0, 8)$。\n- 情况 $3$ (小长度的全局偏差): $L = 10$。设 $\\mathbf{a}_i = (i, 0, 0)$，其中 $i = 0, 1, \\dots, 9$。对所有 $i$，设 $\\mathbf{b}_i = \\mathbf{a}_i + (3, 0, 0)$。\n- 情况 $4$ (大长度的全局偏差): $L = 50$。设 $\\mathbf{a}_i = (i, 0, 0)$，其中 $i = 0, 1, \\dots, 49$。对所有 $i$，设 $\\mathbf{b}_i = \\mathbf{a}_i + (3, 0, 0)$。\n- 情况 $5$ (混合偏差): $L = 12$。设 $\\mathbf{a}_i = (i, 0, 0)$，其中 $i = 0, 1, \\dots, 11$。对 $i = 0, 1, \\dots, 5$，设 $\\mathbf{b}_i = \\mathbf{a}_i + (0, 0, 0.5)$；对 $i = 6, 7, \\dots, 11$，设 $\\mathbf{b}_i = \\mathbf{a}_i + (0, 0, 10)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。其中每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\text{RMSD}, \\text{TM}]$，两个条目均为四舍五入到 $6$ 位小数的浮点数。例如：$[[r_1, t_1],[r_2, t_2],\\dots]$。\n- RMSD 以 $\\text{\\AA}$ 为单位，TM-score 为无量纲数，两者都四舍五入到 $6$ 位小数。",
            "solution": "该问题要求为五个定义的测试用例计算两种标准的蛋白质结构相似性度量：均方根偏差 (RMSD) 和模板建模得分 (TM-score)。验证证实了该问题在科学上是合理的、定义明确的，并且所有定义和参数都与计算化学生物学中的既定惯例一致。我们现在开始进行正式求解。\n\n问题的核心在于比较三维空间中两组 $L$ 个对应的点集 $\\{ \\mathbf{a}_i \\}_{i=0}^{L-1}$ 和 $\\{ \\mathbf{b}_i \\}_{i=0}^{L-1}$，其中每个点代表蛋白质结构中的一个残基。为了与计算实现保持一致，我们采用从 $i=0$ 到 $L-1$ 的从零开始的索引。\n\n基本量是第 $i$ 对残基之间的欧几里得距离平方：\n$$d_i^2 = \\lVert \\mathbf{a}_i - \\mathbf{b}_i \\rVert_2^2$$\n其中 $\\mathbf{a}_i, \\mathbf{b}_i \\in \\mathbb{R}^3$。\n\n第一个度量 RMSD 定义为这些距离平方的算术平均值的平方根。它提供了对应原子间平均距离的度量。其公式为：\n$$\\text{RMSD} = \\sqrt{\\frac{1}{L} \\sum_{i=0}^{L-1} d_i^2}$$\nRMSD 的计量单位与坐标相同，在此问题中为埃 ($\\text{\\AA}$)。RMSD 的一个关键特性是它对大偏差的敏感性；单个大的 $d_i$ 会显著增大 RMSD 值，可能掩盖结构其余部分的良好相似性。\n\n第二个度量 TM-score 旨在成为一种更细致的相似性度量，对局部误差不那么敏感，更能反映全局拓扑相似性。其定义为：\n$$\\text{TM-score} = \\frac{1}{L} \\sum_{i=0}^{L-1} \\frac{1}{1 + \\left(\\frac{d_i}{d_0(L)}\\right)^2}$$\n该得分使用一个类似S型的函数将每个距离 $d_i = \\sqrt{d_i^2}$ 转换为一个介于 $0$ 和 $1$ 之间的值。项 $d_0(L)$ 是一个长度依赖的归一化因子，使得分的大小与蛋白质大小 $L$ 相对无关。$d_0(L)$ 的公式为：\n$$d_0(L) = \\max\\left(0.5,\\ 1.24\\sqrt[3]{L - 15} - 1.8\\right)$$\n远大于 $d_0(L)$ 的偏差对最终得分贡献很小，而小于 $d_0(L)$ 的偏差则贡献显著。TM-score 接近 $1$ 表示近乎完美的匹配，而低于 $0.2$ 的得分通常表示结构不相关。\n\n我们现在将为五个测试用例中的每一个计算这两个度量。\n\n**情况1：相同结构**\n$L = 5$。坐标为 $\\mathbf{a}_i = (i, 0, 0)$ 和 $\\mathbf{b}_i = \\mathbf{a}_i$，其中 $i \\in \\{0, 1, 2, 3, 4\\}$。\n距离向量 $\\mathbf{a}_i - \\mathbf{b}_i$ 对所有 $i$ 均为零向量。\n因此，对所有 $i$，$d_i^2 = 0$。\n距离平方和为 $\\sum_{i=0}^{4} d_i^2 = 0$。\n$\\text{RMSD} = \\sqrt{\\frac{0}{5}} = 0.0\\ \\text{\\AA}$。\n对于 TM-score，我们首先计算 $d_0(5)$。由于 $5  15$，项 $\\sqrt[3]{L-15}$ 为负。\n$d_0(5) = \\max(0.5, 1.24\\sqrt[3]{5 - 15} - 1.8) = \\max(0.5, 1.24\\sqrt[3]{-10} - 1.8) \\approx \\max(0.5, 1.24(-2.1544) - 1.8) = \\max(0.5, -4.4715) = 0.5\\ \\text{\\AA}$。\n因为所有 $d_i=0$，TM-score 为：\n$\\text{TM-score} = \\frac{1}{5} \\sum_{i=0}^{4} \\frac{1}{1 + \\left(\\frac{0}{0.5}\\right)^2} = \\frac{1}{5} \\sum_{i=0}^{4} 1 = 1.0$。\n结果：$[\\text{RMSD}, \\text{TM-score}] = [0.0, 1.0]$。\n\n**情况2：局部偏差**\n$L = 5$。坐标为 $\\mathbf{a}_i = (i, 0, 0)$。结构 $\\mathbf{b}$ 与其相同，除了残基 $i=2$，其中 $\\mathbf{b}_2 = \\mathbf{a}_2 + (0, 0, 8) = (2, 0, 8)$。\n唯一的非零距离出现在 $i=2$ 时：$d_2^2 = \\lVert(2,0,0) - (2,0,8)\\rVert_2^2 = \\lVert(0,0,-8)\\rVert_2^2 = 64\\ \\text{\\AA}^2$。\n所有其他 $d_i^2=0$。\n距离平方和为 $\\sum_{i=0}^{4} d_i^2 = 64$。\n$\\text{RMSD} = \\sqrt{\\frac{64}{5}} = \\sqrt{12.8} \\approx 3.577709\\ \\text{\\AA}$。\n归一化因子 $d_0(5)$ 与情况1中相同：$d_0(5) = 0.5\\ \\text{\\AA}$。\n对于 TM-score，我们有 $d_2 = \\sqrt{64} = 8\\ \\text{\\AA}$ 且对于 $i \\neq 2$ 有 $d_i=0$。\n$\\text{TM-score} = \\frac{1}{5} \\left( \\sum_{i \\in \\{0,1,3,4\\}} \\frac{1}{1 + \\left(\\frac{0}{0.5}\\right)^2} + \\frac{1}{1 + \\left(\\frac{8}{0.5}\\right)^2} \\right) = \\frac{1}{5} \\left( 4 \\times 1 + \\frac{1}{1 + 16^2} \\right) = \\frac{1}{5} \\left( 4 + \\frac{1}{257} \\right) \\approx \\frac{4.003891}{5} \\approx 0.800778$。\n结果：$[\\text{RMSD}, \\text{TM-score}] = [3.577709, 0.800778]$。\n\n**情况3：全局偏差，短链**\n$L = 10$。$\\mathbf{a}_i = (i, 0, 0)$ 且 $\\mathbf{b}_i = \\mathbf{a}_i + (3, 0, 0)$，其中 $i \\in \\{0, \\dots, 9\\}$。\n这是一个均匀平移。距离向量是恒定的：$\\mathbf{a}_i - \\mathbf{b}_i = (-3, 0, 0)$。\n对所有 $i$，$d_i^2 = \\lVert(-3,0,0)\\rVert_2^2 = 9\\ \\text{\\AA}^2$。\n距离平方和为 $\\sum_{i=0}^{9} d_i^2 = 10 \\times 9 = 90$。\n$\\text{RMSD} = \\sqrt{\\frac{90}{10}} = \\sqrt{9} = 3.0\\ \\text{\\AA}$。\n对于 TM-score，我们计算 $d_0(10)$：\n$d_0(10) = \\max(0.5, 1.24\\sqrt[3]{10 - 15} - 1.8) = \\max(0.5, 1.24\\sqrt[3]{-5} - 1.8) \\approx \\max(0.5, 1.24(-1.7100) - 1.8) = \\max(0.5, -3.9204) = 0.5\\ \\text{\\AA}$。\n对所有 $i$，距离 $d_i = \\sqrt{9} = 3\\ \\text{\\AA}$。\n$\\text{TM-score} = \\frac{1}{10} \\sum_{i=0}^{9} \\frac{1}{1 + \\left(\\frac{3}{0.5}\\right)^2} = \\frac{1}{10} \\sum_{i=0}^{9} \\frac{1}{1 + 6^2} = \\frac{1}{10} \\times 10 \\times \\frac{1}{37} = \\frac{1}{37} \\approx 0.027027$。\n结果：$[\\text{RMSD}, \\text{TM-score}] = [3.0, 0.027027]$。\n\n**情况4：全局偏差，长链**\n$L = 50$。$\\mathbf{a}_i = (i, 0, 0)$ 且 $\\mathbf{b}_i = \\mathbf{a}_i + (3, 0, 0)$，其中 $i \\in \\{0, \\dots, 49\\}$。\n偏差与情况3相同，是一个均匀平移。因此，对所有 $i$，$d_i^2 = 9\\ \\text{\\AA}^2$。\n$\\text{RMSD} = \\sqrt{\\frac{1}{50} \\sum_{i=0}^{49} 9} = \\sqrt{\\frac{50 \\times 9}{50}} = \\sqrt{9} = 3.0\\ \\text{\\AA}$。\n对于均匀偏差，RMSD对蛋白质长度不敏感。\n对于 TM-score，我们计算 $d_0(50)$：\n$d_0(50) = \\max(0.5, 1.24\\sqrt[3]{50 - 15} - 1.8) = \\max(0.5, 1.24\\sqrt[3]{35} - 1.8) \\approx \\max(0.5, 1.24(3.2711) - 1.8) = \\max(0.5, 2.2561) = 2.2561\\ \\text{\\AA}$。\n对所有 $i$，距离 $d_i = 3\\ \\text{\\AA}$。\n$\\text{TM-score} = \\frac{1}{50} \\sum_{i=0}^{49} \\frac{1}{1 + \\left(\\frac{3}{2.2561}\\right)^2} \\approx \\frac{1}{1 + (1.3297)^2} \\approx \\frac{1}{1 + 1.7681} = \\frac{1}{2.7681} \\approx 0.361254$。\n结果：$[\\text{RMSD}, \\text{TM-score}] = [3.0, 0.361254]$。这个结果突显了长度依赖的 $d_0(L)$ 如何使 TM-score 对较长蛋白质中相同的绝对偏差更具容忍度。\n\n**情况5：混合偏差**\n$L = 12$。$\\mathbf{a}_i = (i, 0, 0)$。结构 $\\mathbf{b}$ 有两段不同的偏差。\n对于 $i \\in \\{0, \\dots, 5\\}$ ($6$ 个残基)：$\\mathbf{b}_i = \\mathbf{a}_i + (0, 0, 0.5)$。所以 $\\mathbf{a}_i - \\mathbf{b}_i = (0, 0, -0.5)$，且 $d_i^2 = 0.25\\ \\text{\\AA}^2$。\n对于 $i \\in \\{6, \\dots, 11\\}$ ($6$ 个残基)：$\\mathbf{b}_i = \\mathbf{a}_i + (0, 0, 10)$。所以 $\\mathbf{a}_i - \\mathbf{b}_i = (0, 0, -10)$，且 $d_i^2 = 100\\ \\text{\\AA}^2$。\n距离平方和为 $\\sum d_i^2 = 6 \\times 0.25 + 6 \\times 100 = 1.5 + 600 = 601.5$。\n$\\text{RMSD} = \\sqrt{\\frac{601.5}{12}} = \\sqrt{50.125} \\approx 7.079900\\ \\text{\\AA}$。后半部分的大偏差主导了 RMSD 的值。\n对于 TM-score，我们计算 $d_0(12)$：\n$d_0(12) = \\max(0.5, 1.24\\sqrt[3]{12 - 15} - 1.8) = \\max(0.5, 1.24\\sqrt[3]{-3} - 1.8) \\approx \\max(0.5, -3.5884) = 0.5\\ \\text{\\AA}$。\n对于前半部分 ($i \\in \\{0, \\dots, 5\\}$)，$d_i = \\sqrt{0.25} = 0.5\\ \\text{\\AA}$。每个残基的得分为 $\\frac{1}{1 + (0.5/0.5)^2} = \\frac{1}{2}$。\n对于后半部分 ($i \\in \\{6, \\dots, 11\\}$)，$d_i = \\sqrt{100} = 10\\ \\text{\\AA}$。每个残基的得分为 $\\frac{1}{1 + (10/0.5)^2} = \\frac{1}{1+20^2} = \\frac{1}{401}$。\n最终的 TM-score 是这些得分的平均值：\n$\\text{TM-score} = \\frac{1}{12} \\left( 6 \\times \\frac{1}{2} + 6 \\times \\frac{1}{401} \\right) = \\frac{1}{12} \\left( 3 + \\frac{6}{401} \\right) \\approx \\frac{3.01496}{12} \\approx 0.251247$。\n结构的前半部分对 TM-score 贡献显著，而比对不佳的后半部分贡献很小，这表明该得分关注的是结构比对良好的区域。\n结果：$[\\text{RMSD}, \\text{TM-score}] = [7.079900, 0.251247]$。\n\n最终汇总的结果，四舍五入到 $6$ 位小数，如下：\n情况 1: $[0.0, 1.0]$\n情况 2: $[3.577709, 0.800778]$\n情况 3: $[3.0, 0.027027]$\n情况 4: $[3.0, 0.361254]$\n情况 5: $[7.079900, 0.251247]$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes RMSD and TM-score for five protein structure comparison test cases.\n    \"\"\"\n\n    test_cases = [\n        {'id': 1, 'L': 5, 'type': 'identical'},\n        {'id': 2, 'L': 5, 'type': 'local_dev'},\n        {'id': 3, 'L': 10, 'type': 'global_dev'},\n        {'id': 4, 'L': 50, 'type': 'global_dev'},\n        {'id': 5, 'L': 12, 'type': 'mixed_dev'}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        L = case['L']\n        \n        # Generate coordinates for structure 'a'\n        a_coords = np.array([[float(i), 0.0, 0.0] for i in range(L)])\n        \n        # Generate coordinates for structure 'b' based on the test case\n        if case['type'] == 'identical':\n            b_coords = np.copy(a_coords)\n            \n        elif case['type'] == 'local_dev':\n            b_coords = np.copy(a_coords)\n            # Apply deviation at specific residue i=2\n            b_coords[2] += np.array([0.0, 0.0, 8.0])\n            \n        elif case['type'] == 'global_dev':\n            deviation = np.array([3.0, 0.0, 0.0])\n            b_coords = a_coords + deviation\n            \n        elif case['type'] == 'mixed_dev':\n            b_coords = np.copy(a_coords)\n            # First half deviation\n            b_coords[0:6] += np.array([0.0, 0.0, 0.5])\n            # Second half deviation\n            b_coords[6:12] += np.array([0.0, 0.0, 10.0])\n        \n        # Calculate squared distances d_i^2\n        diff_sq = (a_coords - b_coords)**2\n        d_i_sq = np.sum(diff_sq, axis=1)\n        \n        # 1. Compute RMSD\n        rmsd = np.sqrt(np.mean(d_i_sq))\n        \n        # 2. Compute TM-score\n        # Calculate d0(L)\n        # np.cbrt handles negative arguments correctly, so no special case for L = 15 is needed.\n        d0_L_val = 1.24 * np.cbrt(L - 15) - 1.8\n        d0_L = max(0.5, d0_L_val)\n\n        # Calculate per-residue scores\n        d_i = np.sqrt(d_i_sq)\n        tm_terms = 1.0 / (1.0 + (d_i / d0_L)**2)\n        tm_score = np.mean(tm_terms)\n        \n        # Round results and append\n        rounded_rmsd = round(rmsd, 6)\n        rounded_tm_score = round(tm_score, 6)\n        results.append([rounded_rmsd, rounded_tm_score])\n\n    # Final print statement in the exact required format.\n    # Using str() and replace() to ensure format is exact without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```"
        },
        {
            "introduction": "从一级序列预测蛋白质的三维结构是计算生物学的核心挑战之一。这个综合性练习  将引导您构建一个简化的二级结构预测算法，从而跨越序列与结构之间的鸿沟。您将结合氨基酸残基的固有倾向性与氢键网络的可行性模型，来预测序列中的哪些部分可能形成 $\\alpha$-螺旋或 $\\beta$-折叠。这项实践不仅揭示了经典二级结构预测方法背后的逻辑，也强调了局部序列偏好与规则二级结构模式之间的相互作用。",
            "id": "3859701",
            "problem": "给定一个氨基酸一级序列，要求您从第一性原理出发，通过构建氢键可行性图并对连续模式进行评分，来模拟二级结构的形成。其基本原理是，多肽主链在其主链酰胺氮上提供一个氢键供体，在其主链羰基氧上提供一个氢键受体。脯氨酸由于其环状二级胺结构，缺少主链酰胺氢供体。α-螺旋的特征是残基 $i$ 和残基 $i+4$ 之间形成主链氢键，而β-折叠的特征是来自两条对齐链的残基之间形成链间氢键。您必须将所有得分表示为无量纲标量。\n\n将一级序列定义为 $S = (S[0], S[1], \\dots, S[n-1])$，长度为 $n$，其中每个 $S[i]$ 是使用单字母编码的20种标准氨基酸之一。对于每个位置 $i$，定义主链供体可行性 $D_i \\in \\{0,1\\}$，其中当且仅当 $S[i]$ 是脯氨酸时，$D_i = 0$，否则 $D_i = 1$。定义主链受体可行性 $A_i \\in \\{0,1\\}$，其中对于所有位置，$A_i = 1$（主链羰基氧始终存在）。\n\n构建α-螺旋的氢键可行性图，即二元序列 $F^\\alpha = (F^\\alpha_0, F^\\alpha_1, \\dots, F^\\alpha_{n-1})$，其中\n$$F^\\alpha_i = \\begin{cases}\n1  \\text{if } i+4 \\le n-1 \\text{ and } D_i = 1 \\text{ and } A_{i+4} = 1, \\\\\n0  \\text{otherwise}.\n\\end{cases}$$\n构建两个等长候选链之间β-折叠的氢键可行性度量。设候选β-链为一个窗口 $(p, L)$，起始位置为 $p$，长度为 $L$，满足 $0 \\le p \\le n-L$。考虑一对不重叠的链 $(p,L)$ 和 $(q,L)$，其最小间隔为 $g$，因此满足 $p+L \\le q-g$ 或 $q+L \\le p-g$。对于给定的排列（平行或反平行），定义跨链氢键可行性计数\n$$F^\\beta(p,q,L) = \\sum_{k=0}^{L-1} \\left[ \\mathbf{1}(D_{p+k} = 1 \\wedge A_{q+\\phi(k)} = 1) + \\mathbf{1}(D_{q+\\phi(k)} = 1 \\wedge A_{p+k} = 1) \\right],$$\n其中，对于平行排列，$\\phi(k) = k$；对于反平行排列，$\\phi(k) = L-1-k$；$\\mathbf{1}(\\cdot)$ 是指示函数。在这个简化的主链模型中，对于所有 $i$，$A_i = 1$，因此对齐位置间的氢键可行性由任一对齐残基上是否存在供体决定。\n\n为对模式进行评分，使用针对α-螺旋和β-折叠的残基特异性倾向值。定义螺旋倾向值 $P_\\alpha(a)$ 和β-折叠倾向值 $P_\\beta(a)$，其中 $a \\in \\mathcal{A}$，其值选用广泛应用的类Chou–Fasman倾向值，单位为无量纲对数几率，其中 $1$ 为中性值。使用：\n- 对于α-螺旋，\n$P_\\alpha(\\text{A})=1.45$, $P_\\alpha(\\text{C})=0.77$, $P_\\alpha(\\text{D})=1.01$, $P_\\alpha(\\text{E})=1.51$, $P_\\alpha(\\text{F})=1.13$, $P_\\alpha(\\text{G})=0.57$, $P_\\alpha(\\text{H})=1.00$, $P_\\alpha(\\text{I})=1.08$, $P_\\alpha(\\text{K})=1.16$, $P_\\alpha(\\text{L})=1.34$, $P_\\alpha(\\text{M})=1.20$, $P_\\alpha(\\text{N})=0.90$, $P_\\alpha(\\text{P})=0.57$, $P_\\alpha(\\text{Q})=1.11$, $P_\\alpha(\\text{R})=0.98$, $P_\\alpha(\\text{S})=0.79$, $P_\\alpha(\\text{T})=0.82$, $P_\\alpha(\\text{V})=1.06$, $P_\\alpha(\\text{W})=1.14$, $P_\\alpha(\\text{Y})=0.61$。\n- 对于β-折叠，\n$P_\\beta(\\text{A})=0.97$, $P_\\beta(\\text{C})=1.30$, $P_\\beta(\\text{D})=0.54$, $P_\\beta(\\text{E})=0.37$, $P_\\beta(\\text{F})=1.28$, $P_\\beta(\\text{G})=0.75$, $P_\\beta(\\text{H})=0.87$, $P_\\beta(\\text{I})=1.60$, $P_\\beta(\\text{K})=0.74$, $P_\\beta(\\text{L})=1.22$, $P_\\beta(\\text{M})=1.67$, $P_\\beta(\\text{N})=0.65$, $P_\\beta(\\text{P})=0.62$, $P_\\beta(\\text{Q})=1.10$, $P_\\beta(\\text{R})=0.93$, $P_\\beta(\\text{S})=0.72$, $P_\\beta(\\text{T})=1.20$, $P_\\beta(\\text{V})=1.70$, $P_\\beta(\\text{W})=1.19$, $P_\\beta(\\text{Y})=1.29$。\n\n将窗口 $(p,L)$ 的螺旋片段得分定义为窗口内螺旋倾向值的总和，加上一个与窗口内可行螺旋氢键数量成正比的奖励分数。具体来说，包含满足 $p \\le i \\le p+L-5$ 和 $i+4 \\le p+L-1$ 的索引 $i$ 的可行性贡献。设螺旋权重为 $w_\\alpha$；那么概念上，\n$$S_\\alpha(p,L) = \\left( \\sum_{i=p}^{p+L-1} P_\\alpha(S[i]) \\right) + w_\\alpha \\cdot \\left( \\sum_{i=p}^{p+L-5} F^\\alpha_i \\right).$$\n将两个不重叠链 $(p,L)$ 和 $(q,L)$ 的β-配对得分（考虑平行和反平行排列并取两者中的最大值）定义为两个窗口中β-倾向值的总和，加上一个与跨链氢键可行性计数成正比的奖励分数，β-权重为 $w_\\beta$：\n$$S_\\beta(p,q,L) = \\left( \\sum_{i=p}^{p+L-1} P_\\beta(S[i]) + \\sum_{j=q}^{q+L-1} P_\\beta(S[j]) \\right) + w_\\beta \\cdot \\max\\left( F^\\beta_{\\text{parallel}}(p,q,L), F^\\beta_{\\text{antiparallel}}(p,q,L) \\right).$$\n\n归一化局部偏好以获得每个残基的分配。对于残基 $i$，将其螺旋偏好定义为\n$$\\text{pref}_\\alpha(i) = \\max_{(p,L): i \\in [p, p+L-1]} \\frac{S_\\alpha(p,L)}{L},$$\n其β-偏好定义为\n$$\\text{pref}_\\beta(i) = \\max_{(p,q,L): i \\in [p, p+L-1] \\cup [q, q+L-1]} \\frac{S_\\beta(p,q,L)}{2L},$$\n其中最大化是在所有满足不重叠和间隔约束的窗口和配对上进行的。使用一个无规卷曲基线阈值 $T$；如果 $\\text{pref}_\\alpha(i) > \\max(\\text{pref}_\\beta(i), T)$，则将残基 $i$ 分配为α-螺旋；如果 $\\text{pref}_\\beta(i) > \\max(\\text{pref}_\\alpha(i), T)$，则分配为β-折叠；否则分配为无规卷曲。当得分高于阈值且出现平局时，优先选择α-螺旋。\n\n您的程序必须实现上述逻辑，并为每个序列生成整数编码：无规卷曲为 $0$，α-螺旋为 $1$，β-折叠为 $2$。\n\n在测试套件中使用以下参数值：\n- 情况1（理想情况，富含螺旋）：序列 $S = \\text{\"AAAAAAAKAAAAA\"}$，螺旋长度界限 $L_\\alpha^{\\min} = 6$，$L_\\alpha^{\\max} = 12$，β-折叠长度界限 $L_\\beta^{\\min} = 3$，$L_\\beta^{\\max} = 6$，间隔 $g = 2$，权重 $w_\\alpha = 0.8$，$w_\\beta = 0.6$，阈值 $T = 1.0$。\n- 情况2（富含β-折叠）：序列 $S = \\text{\"VVVIVVVVVIVV\"}$，相同的 $L_\\alpha^{\\min}$，$L_\\alpha^{\\max}$，$L_\\beta^{\\min}$，$L_\\beta^{\\max}$，$g = 2$，但权重 $w_\\alpha = 0.6$，$w_\\beta = 0.8$，阈值 $T = 1.0$。\n- 情况3（被脯氨酸和甘氨酸中断的螺旋）：序列 $S = \\text{\"AAAAPAAAAAAG\"}$，相同的长度界限，$g = 2$，权重 $w_\\alpha = 0.8$，$w_\\beta = 0.6$，阈值 $T = 1.1$。\n- 情况4（边界条件，序列非常短）：序列 $S = \\text{\"AGP\"}$，相同的长度界限，$g = 2$，权重 $w_\\alpha = 0.8$，$w_\\beta = 0.6$，阈值 $T = 1.0$。\n- 情况5（极端情况，全为脯氨酸）：序列 $S = \\text{\"PPPPPPPP\"}$，相同的长度界限，$g = 2$，权重 $w_\\alpha = 0.8$，$w_\\beta = 0.6$，阈值 $T = 1.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身都是一个整数列表，按顺序编码相应测试用例的预测二级结构，例如 `[[\\dots],[\\dots],\\dots]`。",
            "solution": "该问题要求实现一种算法，用于预测给定氨基酸序列的蛋白质二级结构（α-螺旋、β-折叠或无规卷曲）。该方法基于一个简化的第一性原理模型，该模型评估局部二级结构元件的可行性。这是通过计算每个残基的偏好得分来完成的，这些得分源自残基倾向值和简化的主链氢键模型。\n\n解决方案通过以下顺序步骤确定：\n\n1.  **模型初始化**：对于给定的长度为 $n$ 的一级序列 $S$ 和一组参数，我们首先建立必要的数据结构。\n    *   **倾向性表**：两个表，$P_\\alpha(a)$ 和 $P_\\beta(a)$，分别存储每种氨基酸 $a$ 形成α-螺旋或β-折叠的内在倾向值。这些值以无量纲对数几率分数的形式提供。\n    *   **主链供体可行性**：构建一个二元序列 $D = (D_0, D_1, \\dots, D_{n-1})$。如果氨基酸 $S[i]$ 是脯氨酸（'P'），则 $D_i=0$，否则 $D_i=1$。这反映了脯氨酸中缺少主链酰胺氢供体。\n    *   **主链受体可行性**：问题指出，主链羰基氧（氢键受体）始终存在。因此，对于所有残基 $i \\in \\{0, \\dots, n-1\\}$，受体可行性 $A_i = 1$。\n\n2.  **氢键可行性图**：\n    *   **α-螺旋**：α-螺旋的形成由残基 $i$ 的主链供体和残基 $i+4$ 的主链受体之间的氢键稳定。一个线性图 $F^\\alpha$ 捕捉了这种可能性。对于每个残基 $i \\in \\{0, \\dots, n-1\\}$，可行性 $F^\\alpha_i$ 定义如下：\n        $$F^\\alpha_i = \\begin{cases}\n        1  \\text{if } i+4 \\le n-1 \\text{ and } D_i = 1 \\text{ and } A_{i+4} = 1, \\\\\n        0  \\text{otherwise}.\n        \\end{cases}$$\n        由于 $A_{i+4}$ 始终为 $1$，这可以简化为：如果 $i+4 \\le n-1$ 且 $D_i = 1$，则 $F^\\alpha_i = 1$，否则为 $0$。\n    *   **β-折叠**：对于β-折叠，氢键在两条不同的、对齐的链之间形成。给定两个不重叠、长度均为 $L$、起始位置分别为 $p$ 和 $q$ 的链 $(p,L)$ 和 $(q,L)$，计算跨链氢键可行性计数 $F^\\beta(p,q,L)$。问题指定了链之间的最小间隔 $g$。该计数对平行和反平行排列的潜在氢键进行求和：\n        $$F^\\beta(p,q,L) = \\sum_{k=0}^{L-1} \\left[ \\mathbf{1}(D_{p+k} = 1 \\wedge A_{q+\\phi(k)} = 1) + \\mathbf{1}(D_{q+\\phi(k)} = 1 \\wedge A_{p+k} = 1) \\right]$$\n        这里，$\\mathbf{1}(\\cdot)$ 是指示函数，$\\phi(k)$ 定义了残基对齐方式：平行排列为 $\\phi(k) = k$，反平行排列为 $\\phi(k) = L-1-k$。鉴于对于所有 $i$，$A_i=1$，这可以简化为供体可行性的总和：\n        $$F^\\beta(p,q,L) = \\sum_{k=0}^{L-1} \\left( D_{p+k} + D_{q+\\phi(k)} \\right)$$\n\n3.  **片段和配对评分**：\n    *   **螺旋片段得分**：对于一个起始于 $p$、长度为 $L$ 的潜在螺旋片段，其得分 $S_\\alpha(p,L)$ 结合了残基倾向值的总和与内部氢键的奖励（由 $w_\\alpha$ 加权）：\n        $$S_\\alpha(p,L) = \\left( \\sum_{i=p}^{p+L-1} P_\\alpha(S[i]) \\right) + w_\\alpha \\cdot \\left( \\sum_{i=p}^{p+L-5} F^\\alpha_i \\right)$$\n        对 $F^\\alpha_i$ 的求和包括所有供体残基 $i$ 和受体残基 $i+4$ 都包含在片段 $[p, p+L-1]$ 内的氢键。\n    *   **β-配对得分**：对于一对β-链，其得分 $S_\\beta(p,q,L)$ 结合了两条链中所有残基的倾向值与潜在链间氢键最大数量的奖励（在平行和反平行排列中取最大值，由 $w_\\beta$ 加权）：\n        $$S_\\beta(p,q,L) = \\left( \\sum_{i=p}^{p+L-1} P_\\beta(S[i]) + \\sum_{j=q}^{q+L-1} P_\\beta(S[j]) \\right) + w_\\beta \\cdot \\max\\left( F^\\beta_{\\text{parallel}}(p,q,L), F^\\beta_{\\text{antiparallel}}(p,q,L) \\right)$$\n\n4.  **每残基偏好计算**：为了对每个残基进行最终分配，我们确定其处于螺旋或折叠中可能获得的最高归一化得分。\n    *   **螺旋偏好**：对于每个残基 $i$，其螺旋偏好 $\\text{pref}_\\alpha(i)$ 是在所有包含该残基的可能螺旋片段 $(p,L)$ 上的最大归一化得分。最大化是在所有长度 $L \\in [L_\\alpha^{\\min}, L_\\alpha^{\\max}]$ 和有效的起始位置 $p$ 上进行的。\n        $$\\text{pref}_\\alpha(i) = \\max_{(p,L): p \\le i  p+L-1} \\frac{S_\\alpha(p,L)}{L}$$\n    *   **β-偏好**：类似地，β-偏好 $\\text{pref}_\\beta(i)$ 是在所有有效的β-折叠配对 $((p,L), (q,L))$（其中残基 $i$ 是任一链的一部分）上的最大归一化得分。最大化是在所有长度 $L \\in [L_\\beta^{\\min}, L_\\beta^{\\max}]$ 和有效、不重叠、有间隔的链位置 $p$ 和 $q$ 上进行的。\n        $$\\text{pref}_\\beta(i) = \\max_{(p,q,L): i \\in [p, p+L-1] \\cup [q, q+L-1]} \\frac{S_\\beta(p,q,L)}{2L}$$\n    如果一个残基不能成为任何给定类型的有效片段的一部分，则其对该类型的偏好被视为 $-\\infty$。\n\n5.  **最终结构分配**：对于每个残基 $i$，通过比较其螺旋和β-偏好以及与基线无规卷曲阈值 $T$ 的关系来进行最终分配。问题描述为“如果 $\\text{pref}_\\alpha(i) > \\max(\\text{pref}_\\beta(i), T)$”分配为螺旋，“如果 $\\text{pref}_\\beta(i) > \\max(\\text{pref}_\\alpha(i), T)$”分配为β-折叠，还有一个平局处理规则：“当得分高于阈值且出现平局时，优先选择α-螺旋。” 公式中的严格不等式没有考虑平局情况。我们通过实现一种在平局时明确偏好α-螺旋的逻辑来解决这个模糊性，这与所述意图一致：\n    *   如果 $\\text{pref}_\\alpha(i) \\ge \\text{pref}_\\beta(i)$ 且 $\\text{pref}_\\alpha(i) > T$，则分配为**α-螺旋**（代码 $1$）。\n    *   如果 $\\text{pref}_\\beta(i) > \\text{pref}_\\alpha(i)$ 且 $\\text{pref}_\\beta(i) > T$，则分配为**β-折叠**（代码 $2$）。\n    *   否则，分配为**无规卷曲**（代码 $0$）。\n\n算法实现将系统地计算所有有效片段和配对的这些分数，更新每个残基的偏好数组，然后应用最终的分配规则。为优化窗口内倾向值总和和氢键计数的计算，使用了预计算的累积和数组，使得这些总和的查找时间复杂度为 $O(1)$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    P_ALPHA = {\n        'A': 1.45, 'C': 0.77, 'D': 1.01, 'E': 1.51, 'F': 1.13, 'G': 0.57, 'H': 1.00, 'I': 1.08,\n        'K': 1.16, 'L': 1.34, 'M': 1.20, 'N': 0.90, 'P': 0.57, 'Q': 1.11, 'R': 0.98, 'S': 0.79,\n        'T': 0.82, 'V': 1.06, 'W': 1.14, 'Y': 0.61\n    }\n    P_BETA = {\n        'A': 0.97, 'C': 1.30, 'D': 0.54, 'E': 0.37, 'F': 1.28, 'G': 0.75, 'H': 0.87, 'I': 1.60,\n        'K': 0.74, 'L': 1.22, 'M': 1.67, 'N': 0.65, 'P': 0.62, 'Q': 1.10, 'R': 0.93, 'S': 0.72,\n        'T': 1.20, 'V': 1.70, 'W': 1.19, 'Y': 1.29\n    }\n\n    test_cases = [\n        # S, L_alpha_min, L_alpha_max, L_beta_min, L_beta_max, g, w_alpha, w_beta, T\n        (\"AAAAAAAKAAAAA\", 6, 12, 3, 6, 2, 0.8, 0.6, 1.0),\n        (\"VVVIVVVVVIVV\", 6, 12, 3, 6, 2, 0.6, 0.8, 1.0),\n        (\"AAAAPAAAAAAG\", 6, 12, 3, 6, 2, 0.8, 0.6, 1.1),\n        (\"AGP\", 6, 12, 3, 6, 2, 0.8, 0.6, 1.0),\n        (\"PPPPPPPP\", 6, 12, 3, 6, 2, 0.8, 0.6, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _solve_case(P_ALPHA, P_BETA, *case)\n        results.append(result)\n\n    # Format the output string to match [[...], [...]] with no spaces\n    results_str = [str(r).replace(' ', '') for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\ndef _solve_case(P_ALPHA, P_BETA, S, l_alpha_min, l_alpha_max, l_beta_min, l_beta_max, g, w_alpha, w_beta, T):\n    \"\"\"\n    Solves a single secondary structure prediction case.\n    \"\"\"\n    n = len(S)\n\n    # 1. Pre-computation\n    D = np.array([0 if res == 'P' else 1 for res in S], dtype=int)\n    \n    F_alpha = np.zeros(n, dtype=int)\n    for i in range(n - 4):\n        if D[i] == 1: # A[i+4] is always 1\n            F_alpha[i] = 1\n\n    p_alpha_cumsum = np.cumsum([0.0] + [P_ALPHA[res] for res in S])\n    p_beta_cumsum = np.cumsum([0.0] + [P_BETA[res] for res in S])\n    f_alpha_cumsum = np.cumsum([0] + list(F_alpha))\n\n    # 2. Preference calculation\n    pref_alpha = np.full(n, -np.inf, dtype=float)\n    pref_beta = np.full(n, -np.inf, dtype=float)\n\n    # 2a. Helix preference\n    for L in range(l_alpha_min, min(n, l_alpha_max) + 1):\n        for p in range(n - L + 1):\n            propensity_sum = p_alpha_cumsum[p+L] - p_alpha_cumsum[p]\n            \n            h_bond_count = 0\n            # Bonds are from i to i+4. For a bond to be internal, i and i+4 must be in [p, p+L-1].\n            # This means p = i = p+L-5.\n            if L >= 5:\n                h_bond_count = f_alpha_cumsum[p+L-4] - f_alpha_cumsum[p]\n\n            score_alpha = propensity_sum + w_alpha * h_bond_count\n            norm_score = score_alpha / L\n            \n            pref_alpha[p:p+L] = np.maximum(pref_alpha[p:p+L], norm_score)\n\n    # 2b. Beta preference\n    for L in range(l_beta_min, l_beta_max + 1):\n        if 2 * L + g > n:\n            break\n        for p in range(n - (2 * L + g) + 2):\n            for q in range(p + L + g, n - L + 1):\n                f_beta_para = np.sum(D[p:p+L]) + np.sum(D[q:q+L])\n                \n                f_beta_anti = np.sum(D[p:p+L]) + np.sum(D[q+L-1:q-1:-1] if L > 0 else [])\n                \n                max_f_beta = max(f_beta_para, f_beta_anti)\n                \n                propensity_sum = (p_beta_cumsum[p+L] - p_beta_cumsum[p]) + \\\n                                 (p_beta_cumsum[q+L] - p_beta_cumsum[q])\n                \n                score_beta = propensity_sum + w_beta * max_f_beta\n                norm_score = score_beta / (2 * L)\n\n                pref_beta[p:p+L] = np.maximum(pref_beta[p:p+L], norm_score)\n                pref_beta[q:q+L] = np.maximum(pref_beta[q:q+L], norm_score)\n\n    # 3. Final assignment\n    result = np.zeros(n, dtype=int) # Default to coil (0)\n    \n    # Helix: pref_alpha >= pref_beta AND pref_alpha > T\n    # Beta: pref_beta > pref_alpha AND pref_beta > T\n    # This logic implements the tie-breaking rule stated in the problem.\n    helix_indices = np.where((pref_alpha >= pref_beta)  (pref_alpha > T))[0]\n    beta_indices = np.where((pref_beta > pref_alpha)  (pref_beta > T))[0]\n    \n    result[helix_indices] = 1\n    result[beta_indices] = 2\n\n    return result.tolist()\n\nif __name__ == '__main__':\n    solve()\n```"
        }
    ]
}