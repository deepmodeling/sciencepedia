{
    "hands_on_practices": [
        {
            "introduction": "在深入研究定量的能量计算之前，掌握控制碱基配对特异性的基本化学原理至关重要。本练习旨在挑战您分析核碱基的稀有互变异构形式如何改变其氢键模式。通过理解这些变化，您将能够预测潜在的错配，这是自发突变的一个基本机制，从而体会到遗传密码的化学精确性。",
            "id": "3857051",
            "problem": "在脱氧核糖核酸（DNA）中，碱基配对的特异性源于核碱基边缘上氢键供体和受体的分布，以及这些相互作用位点在配对几何结构中的几何相容性。考虑鸟嘌呤和胸腺嘧啶的规范酮式（内酰胺）形式，以及由酮-烯醇和氨基-亚氨基质子转移产生的稀有互变异构形式。\n\n使用以下基本事实和定义作为您的出发点：\n- 氢键供体是带有一个键合质子、能够形成氢键的原子；氢键受体是带有一对孤对电子、能够接受氢键的原子。典型的供体-受体距离约为 $2.8$–$3.0$ Å，供体-氢-受体角度接近 $180^\\circ$ 以实现最佳成键。\n- 在规范的酮式形式中，鸟嘌呤的 Watson–Crick (WC) 边呈现 $N1$ 作为氢键供体（$N1\\text{-}H$），$O6$ 作为氢键受体，以及 $N2$（环外氨基）作为氢键供体（$N2\\text{-}H$）；鸟嘌呤的 Hoogsteen 边呈现 $N7$ 作为氢键受体和 $O6$ 作为氢键受体。\n- 在规范的酮式形式中，胸腺嘧啶在其 Watson–Crick 边上呈现 $N3\\text{-}H$ 作为氢键供体，以及 $O2$ 和 $O4$ 作为氢键受体；其 Hoogsteen 面涉及 $N3\\text{-}H$（供体）和 $O4$（受体）。\n- Hoogsteen 配对通常需要一个处于顺式（syn）糖苷构象的嘌呤通过其 Hoogsteen 边与一个处于反式（anti）的嘧啶相互作用，其 $C1'\\text{–}C1'$ 距离约为 $8.6$ Å，相比之下 Watson–Crick 几何结构中约为 $10.5$ Å。嘌呤的 Hoogsteen 边将 $N7$ 和 $O6$ 置于大沟方向。\n- 质子化状态的改变会改变供体/受体状态。例如，胞嘧啶 $N3$ 位的质子化产生质子化的胞嘧啶（$C^+$），它可以作为来自 $N3\\text{-}H$ 的强氢键供体（在水溶液中胞嘧啶 $N3$ 的酸解离常数 $pK_a \\approx 4.2$）。\n\n假设互变异构局限于碱基，并且除了供体/受体身份的改变外，不会显著改变环的平面性或糖-碱基的几何结构。同时假设配对几何结构的空间位阻强制形成近线性的氢键，并且供体-受体匹配必须与配对界面上相互作用位点的空间顺序对齐，以避免供体-供体或受体-受体冲突。\n\n哪个选项正确地描述了在鸟嘌呤和胸腺嘧啶的互变异构下氢键供体和受体模式如何变化，并基于几何相容性合理解释了其对 Watson–Crick 与 Hoogsteen 配对的影响？\n\nA. 鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体；这通过将鸟嘌呤的 $O6\\text{-}H$ 与胞嘧啶的 $N4\\text{-}H$ 匹配，并将鸟嘌呤的 $N7$ 与胞嘧啶的 $N3$ 匹配，从而在没有胞嘧啶质子化的情况下稳定了鸟嘌呤-胞嘧啶的 Hoogsteen 配对。胸腺嘧啶的 $O4$ 烯醇互变异构体将 $O4$ 转化为供体，将 $N3$ 转化为受体，从而能够与鸟嘌呤形成三个类似 Watson–Crick 的氢键，并同时因为胸腺嘧啶获得了两个供体而增强了腺嘌呤-胸腺嘧啶的 Hoogsteen 配对。\n\nB. 两种互变异构都有利于与其规范配对伙伴形成 Hoogsteen 配对：鸟嘌呤的 $O6\\text{-}H$ 向胞嘧啶的 $N4$ 供氢键，鸟嘌呤的 $N7$ 从中性胞嘧啶的 $N3$ 接受氢键；胸腺嘧啶的 $O4\\text{-}H$ 向腺嘌呤的 $N7$ 供氢键，胸腺嘧啶的 $N3$ 从腺嘌呤的 $N6\\text{-}H$ 接受氢键。\n\nC. 鸟嘌呤的 $O6$ 烯醇互变异构体通过将 $O6$ 变为氢键供体来补充胞嘧啶的 $N4\\text{-}H$，从而加强了与胞嘧啶的 Watson–Crick 配对，而胸腺嘧啶的 $O4$ 烯醇互变异构体则因为 $N3$ 仍然是供体而破坏了在 Watson–Crick 几何结构中与鸟嘌呤的错配。\n\nD. 胸腺嘧啶的 $O4$ 烯醇互变异构体可以通过将 $O4$ 转化为供体、$N3$ 转化为受体，并保留 $O2$ 作为受体，在 Watson–Crick 几何结构中模拟胞嘧啶，从而允许与鸟嘌呤形成一个三氢键网络（$N1\\text{-}H$ 到 $N3$，$N2\\text{-}H$ 到 $O2$，以及 $O6$ 从 $O4\\text{-}H$ 接受氢键）。与此同时，鸟嘌呤的 $O6$ 烯醇互变异构体将 $O6$ 转化为供体，将 $N1$ 转化为受体，这会破坏鸟嘌呤-胞嘧啶的 Watson–Crick 配对和鸟嘌呤-胞嘧啶的 Hoogsteen 配对（后者依赖于 $N7$ 和 $O6$ 处的两个受体，并且只有当胞嘧啶在 $N3$ 位质子化时，即 $C^+$，才稳定），因此 $O6$ 烯醇形式不会增强与胞嘧啶的 Hoogsteen 相容性。\n\nE. 鸟嘌呤的 $O6$ 烯醇互变异构体改善了与腺嘌呤的 Hoogsteen 配对，因为 $O6\\text{-}H$ 可以向腺嘌呤的 $N7$ 供氢键，而 $N1$ 可以从腺嘌呤的 $N6\\text{-}H$ 接受氢键；胸腺嘧啶的 $O4$ 烯醇互变异构体减少了与鸟嘌呤的 Watson–Crick 错配，因为 $O4$ 仍然是受体，而 $N3$ 仍然是供体。\n\n选择一个选项。",
            "solution": "问题要求找出关于鸟嘌呤和胸腺嘧啶的互变异构对其氢键模式以及在 Watson-Crick 和 Hoogsteen 几何结构中配对潜力的影响的正确描述。\n\n为了解决这个问题，我们必须首先确定鸟嘌呤和胸腺嘧啶的规范形式和互变异构形式的氢键供体/受体模式。\n\n**1. 鸟嘌呤（G）及其 $O6$ 烯醇互变异构体（$G^*$）的分析：**\n\n*   **规范鸟嘌呤（酮式/氨基形式）：**\n    *   如题所述，Watson-Crick (WC) 边呈现以下氢键位点：$N1\\text{-}H$（供体，D）、$O6$（受体，A）和 $N2\\text{-}H_2$（供体，D）。这种 DAD 模式与胞嘧啶（C）的 ADA 模式互补，胞嘧啶具有 $N3$（A）、$N4\\text{-}H_2$（D）和 $O2$（A），从而允许在一个 G-C WC 配对中形成三个稳定的氢键：$G(N1\\text{-}H) \\cdots (N3)C$，$G(O6) \\cdots (H\\text{-}N4)C$ 和 $G(N2\\text{-}H) \\cdots (O2)C$。\n    *   规范鸟嘌呤的 Hoogsteen 边有 $N7$（A）和 $O6$（A）。这种 A/A 模式可以与一个处于 *syn* 构象的质子化胞嘧啶（$C^+$）配对，后者呈现两个供体，形成一个 G-$C^+$ Hoogsteen 配对。\n\n*   **鸟嘌呤 $O6$ 烯醇互变异构体（$G^*$）：**\n    *   该互变异构体是由质子从 $N1$ 转移到 $O6$ 产生的。\n    *   $N1\\text{-}H$ 基团变成带孤对电子的 $N1$，从供体（D）变为受体（A）。\n    *   $C6=O6$ 基团变成 $C6\\text{-}O6\\text{-}H$，使 $O6$ 原子从受体（A）变为供体（D）。\n    *   $N2\\text{-}H_2$ 基团仍然是供体（D）。\n    *   因此，$G^*$ 的 WC 边具有 A/D/D 模式（$N1$ 是 A，$O6$ 是 D，$N2$ 是 D）。\n\n**2. 胸腺嘧啶（T）及其 $O4$ 烯醇互变异构体（$T^*$）的分析：**\n\n*   **规范胸腺嘧啶（酮式）：**\n    *   如题所述，WC 边呈现 $O2$（A）、$N3\\text{-}H$（D）和 $O4$（A）。这种 A/D/A 模式与腺嘌呤（A）的 D/A/D 模式互补，允许在一个 A-T WC 配对中形成两个氢键：$A(N6\\text{-}H) \\cdots (O4)T$ 和 $A(N1) \\cdots (H\\text{-}N3)T$。\n\n*   **胸腺嘧啶 $O4$ 烯醇互变异构体（$T^*$）：**\n    *   该互变异构体是由质子从 $N3$ 转移到 $O4$ 产生的。\n    *   $N3\\text{-}H$ 基团变成带孤对电子的 $N3$，从供体（D）变为受体（A）。\n    *   $C4=O4$ 基团变成 $C4\\text{-}O4\\text{-}H$，使 $O4$ 原子从受体（A）变为供体（D）。\n    *   $O2$ 基团仍然是受体（A）。\n    *   因此，$T^*$ 的 WC 边具有 A/A/D 模式（$O2$ 是 A，$N3$ 是 A，$O4$ 是 D）。这种供体/受体模式在空间上类似于胞嘧啶（ADA 模式，其中 N3, O2 是受体，N4 是供体）。\n\n建立了这些模式后，我们可以评估每个选项。\n\n**逐项分析：**\n\n**A. 鸟嘌呤的 $O6$ 烯醇互变异构体...**\n*   关于互变异构的初始论断（$G^*$：$O6$ 变为 D，$N1$ 变为 A；$T^*$：$O4$ 变为 D，$N3$ 变为 A）是正确的。\n*   关于稳定 G-C Hoogsteen 配对的说法是不正确的。提出的配对是 $G^*(O6\\text{-}H)$ 与 $C(N4\\text{-}H)$，这是一个供体-供体冲突，以及 $G^*(N7)$ 与 $C(N3)$，这是一个受体-受体冲突。这将是高度不稳定的。\n*   $T^*$ 能够与 G 形成三个 WC 键的说法是正确的。\n*   A-T Hoogsteen 配对因胸腺嘧啶获得两个供体而增强的说法是不正确的。胸腺嘧啶的 $O4$ 烯醇互变异构体 ($T^*$) 在其 WC 面上有一个供体 ($O4\\text{-}H$) 和两个受体 ($N3$, $O2$)，而不是“两个供体”。\n*   结论：**不正确**。\n\n**B. 两种互变异构都有利于与其规范配对伙伴形成 Hoogsteen 配对...**\n*   G*-C Hoogsteen 配对的描述是不正确的。鸟嘌呤的 $O6\\text{-}H$ 是一个供体，胞嘧啶的 $N4\\text{-}H_2$ 基团也是一个供体，导致冲突。鸟嘌呤的 $N7$ 是一个受体，中性胞嘧啶的 $N3$ 也是一个受体，导致另一个冲突。\n*   $T^*$-A Hoogsteen 配对的描述在化学上是合理的。$T^*$ 在其面上呈现一个供体 ($O4\\text{-}H$) 和一个受体 ($N3$)。腺嘌呤的 Hoogsteen 边呈现一个受体 ($N7$) 和一个供体 ($N6\\text{-}H_2$)。所提出的配对，$T^*(O4\\text{-}H)\\cdots(N7)A$ (D-A) 和 $T^*(N3)\\cdots(H\\text{-}N6)A$ (A-D)，创建了两个有效的氢键。然而，由于该选项的第一部分是错误的，整个选项是无效的。\n*   结论：**不正确**。\n\n**C. 鸟嘌呤的 $O6$ 烯醇互变异构体加强了...**\n*   $G^*$ 加强与 C 的 WC 配对的说法是错误的。$G^*$ 的 $O6\\text{-}H$ 是一个供体，C 的 $N4\\text{-}H_2$ 也是一个供体。这在第三个氢键的位置产生了供体-供体排斥，破坏了配对。\n*   $T^*$ 破坏与 G 的错配的说法是错误的。正如我们最初的分析所示，$T^*$ 具有类似 C 的氢键模式，并*促成*了与 G 的稳定三键错配。\n*   给出的理由“因为 $N3$ 仍然是供体”在事实上是不正确的。在 $O4$ 烯醇互变异构体中，$N3$ 变成了受体。\n*   结论：**不正确**。\n\n**D. 胸腺嘧啶的 $O4$ 烯醇互变异构体可以模拟胞嘧啶...**\n*   第一部分的分析（关于 $T^*$）：对互变异构的描述（$O4$：A→D；$N3$：D→A）是正确的。由此产生的类似 C 的模拟是正确的。提出的与 G 的三氢键网络是正确的：$G(N1\\text{-}H)\\cdots(N3)T^*$ (D-A)，$G(N2\\text{-}H)\\cdots(O2)T^*$ (D-A)，和 $G(O6)\\cdots(H\\text{-}O4)T^*$ (A-D)。这部分完全准确。\n*   第二部分的分析（关于 $G^*$）：对互变异构的描述（$O6$：A→D；$N1$：D→A）是正确的。这破坏了 G-C WC 配对的结论是正确的，因为 $G^*$ 具有 A/D/D 模式，在两个位置上与 C 的 A/D/A 模式冲突（$G^*(N1)\\cdots C(N3)$ 是 A-A，$G^*(O6\\text{-}H)\\cdots C(N4\\text{-}H)$ 是 D-D）。对规范的 G-$C^+$ Hoogsteen 配对需要 G 上有两个受体（$N7, O6$）的描述是正确的。互变异构将此模式更改为 A/D（$N7, O6\\text{-}H$），这破坏了与 $C^+$ 上两个供体的必要互补性。$G^*$ 互变异构体不增强与胞嘧啶（无论是中性 C 还是 $C^+$）的 Hoogsteen 相容性的最终结论也是正确的。\n*   结论：**正确**。\n\n**E. 鸟嘌呤的 $O6$ 烯醇互变异构体改善了 Hoogsteen 配对...**\n*   关于 G*-A Hoogsteen 配对的推理在几何上是混乱的。它提出使用鸟嘌呤的 $O6$ 和 $N1$ 与腺嘌呤的 $N7$ 和 $N6$ 配对。这些位点在任何标准的配对几何结构中都不对齐；$N1$ 在 WC 边上，而 $O6$ 和 $N7$ 在 Hoogsteen 边上。\n*   关于 $T^*$ 互变异构体的说法在事实上是不正确的。它*增强*而非减少了与 G 的 WC 错配。进一步的说法，“$O4$ 仍然是受体，而 $N3$ 仍然是供体”与互变异构过程中发生的情况正好相反。\n*   结论：**不正确**。\n\n总结：只有选项 D 对两种互变异构的后果提供了化学上和几何上都合理的分析。",
            "answer": "$$\\boxed{D}$$"
        },
        {
            "introduction": "在对氢键有了定性理解的基础上，本练习将指导您使用简化的静电模型来量化其强度。您将推导出一个被建模为偶极-偶极相互作用的氢键的相互作用能，并探索周围的溶剂环境如何调节该能量。这种第一性原理方法为 G-C 这类规范碱基对的稳定性提供了物理基础。",
            "id": "3857048",
            "problem": "考虑一个鸟嘌呤–胞嘧啶碱基对，其中的三个碱基间氢键被近似为嵌入在均匀介电连续体中的独立偶极–偶极相互作用。将每个氢键建模为两个大小为 $\\,\\mu\\,$ 的相同点偶极子之间的相互作用，这两个偶极子沿着供体–受体轴共线排列，中心距为 $\\,r\\,$。溶剂被视为相对介电常数为 $\\,\\epsilon\\,$ 的线性、均匀电介质，真空介电常数为 $\\,\\varepsilon_{0}\\,$。假设偶极–偶极相互作用是氢键稳定化的唯一贡献者，并忽略氢键之间的任何耦合。将完整的鸟嘌呤–胞嘧啶碱基对视为具有 $\\,3\\,$ 个这样的相同偶极–偶极相互作用；当一个氢键断裂时，只剩下 $\\,2\\,$ 个，且剩余偶极子的几何形状和大小保持不变。\n\n仅使用基于库仑定律的静电学、点偶极子的定义以及连续介电屏蔽，推导在相对介电常数为 $\\,\\epsilon\\,$ 的介质中两个共线点偶极子的相互作用能，并用它来计算当碱基对断裂一个氢键时总氢键稳定能的变化。将能量变化定义为\n$$\n\\Delta E(\\epsilon) \\equiv E_{\\text{broken}} - E_{\\text{intact}},\n$$\n其中 $\\,E_{\\text{intact}}\\,$ 和 $\\,E_{\\text{broken}}\\,$ 分别是具有 $\\,3\\,$ 个和 $\\,2\\,$ 个氢键时的总偶极–偶极稳定能。以 $\\,\\mu\\,$, $\\,r\\,$, $\\,\\varepsilon_{0}\\,$ 和 $\\,\\epsilon\\,$ 表示 $\\,\\Delta E(\\epsilon)\\,$ 的单个闭合形式表达式来提供最终结果。能量以焦耳表示。不要代入数值。最终答案必须是单个解析表达式。",
            "solution": "对问题陈述进行有效性验证。\n\n**第1步：提取已知条件**\n- **系统：** 鸟嘌呤–胞嘧啶碱基对，具有三个碱基间氢键。\n- **模型：**\n    - 每个氢键被近似为独立的偶极-偶极相互作用。\n    - 每个相互作用是在两个相同的点偶极子之间。\n    - 偶极矩大小：$\\mu$。\n    - 偶极子方向：沿供体-受体轴共线。\n    - 偶极子间距（中心到中心）：$r$。\n- **环境：**\n    - 均匀介电连续体。\n    - 介质的相对介电常数：$\\epsilon$。\n    - 真空介电常数：$\\varepsilon_{0}$。\n- **假设：**\n    - 偶极-偶极相互作用是氢键稳定化的唯一贡献者。\n    - 氢键之间的耦合被忽略（能量是可加的）。\n    - 在键断裂时，剩余偶极子的几何形状和大小保持不变。\n- **状态：**\n    - 完整状态：3个相同的偶极-偶极相互作用。总能量为 $E_{\\text{intact}}$。\n    - 断裂状态：2个相同的偶极-偶极相互作用。总能量为 $E_{\\text{broken}}$。\n- **目标：**\n    - 推导两个共线点偶极子的相互作用能。\n    - 计算总氢键稳定能的变化：$\\Delta E(\\epsilon) \\equiv E_{\\text{broken}} - E_{\\text{intact}}$。\n    - 以 $\\mu$、 $r$、 $\\varepsilon_{0}$ 和 $\\epsilon$ 表示的单个闭合形式表达式提供结果。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，是适定的，并且是客观的。它采用了一个在生物物理学中常用的标准简化物理模型（介电连续体中的点偶极子），以近似静电相互作用。诸如可加性和几何形状不变等假设被明确陈述，以使问题易于处理。所有必需的参数都已定义，目标清晰明确。该问题没有科学缺陷、矛盾和不可形式化的元素。这是计算化学生物学领域内一个有效的理论物理问题。\n\n**第3步：结论与行动**\n问题有效。将提供完整解答。\n\n**解题推导**\n\n推导过程分为三个部分：首先，我们确定所建模的单个氢键的相互作用能；其次，我们计算完整状态和断裂状态的总能量；第三，我们计算指定的能量变化。\n\n**第1部分：两个共线点偶极子的相互作用能**\n\n在相对介电常数为 $\\epsilon$ 的线性、均匀电介质中，点偶极子 $\\vec{\\mu}_1$ 在位置 $\\vec{x}$ 处产生的静电势 $V_1$ 由下式给出：\n$$\nV_1(\\vec{x}) = \\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\frac{\\vec{\\mu}_1 \\cdot \\vec{x}}{|\\vec{x}|^3}\n$$\n电场 $\\vec{E}_1$ 是电势的负梯度：\n$$\n\\vec{E}_1(\\vec{x}) = -\\nabla V_1(\\vec{x}) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\nabla \\left( \\frac{\\vec{\\mu}_1 \\cdot \\vec{x}}{|\\vec{x}|^3} \\right)\n$$\n使用向量恒等式 $\\nabla(\\frac{\\vec{A}\\cdot\\vec{B}}{C}) = \\frac{C(\\nabla(\\vec{A}\\cdot\\vec{B})) - (\\vec{A}\\cdot\\vec{B})\\nabla C}{C^2}$ 和相关的梯度法则，偶极子的电场可表示为：\n$$\n\\vec{E}_1(\\vec{x}) = \\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\vec{\\mu}_1 \\cdot \\vec{x})\\vec{x}}{|\\vec{x}|^5} - \\frac{\\vec{\\mu}_1}{|\\vec{x}|^3} \\right)\n$$\n放置在该电场中位置 $\\vec{x}$ 处的第二个偶极子 $\\vec{\\mu}_2$ 的相互作用能 $U$ 为：\n$$\nU = -\\vec{\\mu}_2 \\cdot \\vec{E}_1(\\vec{x}) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\vec{\\mu}_1 \\cdot \\vec{x})(\\vec{\\mu}_2 \\cdot \\vec{x})}{|\\vec{x}|^5} - \\frac{\\vec{\\mu}_1 \\cdot \\vec{\\mu}_2}{|\\vec{x}|^3} \\right)\n$$\n现在我们应用问题的具体条件。设第一个偶极子 $\\vec{\\mu}_1$ 位于原点并沿 z 轴方向。第二个偶极子 $\\vec{\\mu}_2$ 沿同一轴线距离为 $r$。因此，我们有：\n- 第二个偶极子的位置向量：$\\vec{x} = r\\hat{k}$，其中 $\\hat{k}$ 是沿z轴的单位向量。其大小为 $|\\vec{x}|=r$。\n- 偶极子是相同的且共线的：$\\vec{\\mu}_1 = \\mu\\hat{k}$ 和 $\\vec{\\mu}_2 = \\mu\\hat{k}$。它们的大小为 $|\\vec{\\mu}_1| = |\\vec{\\mu}_2| = \\mu$。\n\n我们计算点积：\n- $\\vec{\\mu}_1 \\cdot \\vec{\\mu}_2 = (\\mu\\hat{k}) \\cdot (\\mu\\hat{k}) = \\mu^2$\n- $\\vec{\\mu}_1 \\cdot \\vec{x} = (\\mu\\hat{k}) \\cdot (r\\hat{k}) = \\mu r$\n- $\\vec{\\mu}_2 \\cdot \\vec{x} = (\\mu\\hat{k}) \\cdot (r\\hat{k}) = \\mu r$\n\n将这些代入通用能量表达式中：\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3(\\mu r)(\\mu r)}{r^5} - \\frac{\\mu^2}{r^3} \\right)\n$$\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3\\mu^2 r^2}{r^5} - \\frac{\\mu^2}{r^3} \\right) = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{3\\mu^2}{r^3} - \\frac{\\mu^2}{r^3} \\right)\n$$\n$$\nU = -\\frac{1}{4\\pi\\varepsilon_0\\epsilon} \\left( \\frac{2\\mu^2}{r^3} \\right) = -\\frac{2\\mu^2}{4\\pi\\varepsilon_0\\epsilon r^3}\n$$\n化简后，单个氢键的稳定能 $E_{\\text{H-bond}}$ 为：\n$$\nE_{\\text{H-bond}} = -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n该能量为负，表明这是一个稳定（吸引）的相互作用。\n\n**第2部分：完整状态和断裂状态的总能量**\n\n问题陈述氢键是独立的。因此，总稳定能是各个键能的总和。\n- 对于具有3个氢键的完整鸟嘌呤–胞嘧啶碱基对：\n$$\nE_{\\text{intact}} = 3 \\times E_{\\text{H-bond}} = 3 \\left( -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) = -\\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n- 对于一个键断裂，剩下2个氢键的状态：\n$$\nE_{\\text{broken}} = 2 \\times E_{\\text{H-bond}} = 2 \\left( -\\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) = -\\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n\n**第3部分：稳定能的变化**\n\n问题将能量变化定义为 $\\Delta E(\\epsilon) = E_{\\text{broken}} - E_{\\text{intact}}$。\n$$\n\\Delta E(\\epsilon) = \\left( -\\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right) - \\left( -\\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} \\right)\n$$\n$$\n\\Delta E(\\epsilon) = \\frac{3\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} - \\frac{2\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n$$\n\\Delta E(\\epsilon) = \\frac{(3-2)\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3} = \\frac{\\mu^2}{2\\pi\\varepsilon_0\\epsilon r^3}\n$$\n结果是正的能量变化，对应于断裂一个氢键所需的能量成本。这与物理直觉相符，因为断裂一个稳定的相互作用应该会增加系统的总能量。推导出的表达式是用指定的变量和基本常数表示的。如果所有量都用国际单位制（SI）表示，最终的能量单位将是焦耳。",
            "answer": "$$\n\\boxed{\\frac{\\mu^{2}}{2\\pi\\varepsilon_{0}\\epsilon r^{3}}}\n$$"
        },
        {
            "introduction": "碱基对并非静止不变；它们在动态过程中进行呼吸、打开和关闭，这对于复制和转录至关重要。这项高级计算练习将向您介绍加权直方图分析方法 (WHAM)，这是一种强大的工具，可用于从有偏的分子模拟中重建此类过程的自由能景观。通过实施 WHAM，您将计算碱基对打开过程的平均力势，从而揭示确保基因组稳定性同时又允许访问遗传信息的能垒。",
            "id": "3857041",
            "problem": "设计一个完整的程序，使用加权直方图分析方法 (Weighted Histogram Analysis Method) 沿一个集体坐标重建碱基对打开过程的平均力势。该重建需要从为一个物理上合理的无偏采样模型生成的合成伞形采样直方图来执行。其物理基础是玻尔兹曼分布 (Boltzmann distribution)，其中沿打开坐标 $q$ 的无偏概率密度与 $\\exp(-\\beta F_0(q))$ 成正比，这里 $\\beta = 1/(R T)$，$R$ 是摩尔气体常数。您必须从第一性原理出发，基于玻尔兹曼分布、谐波伞形偏置以及重叠窗口间的最大似然一致性的定义来推导重建过程。程序必须为指定的测试套件生成确定性的直方图，执行加权直方图分析方法重建以获得无偏概率的估计值，然后将该概率转换为平均力势。能量必须以千焦/摩尔 (kJ/mol) 为单位报告，角度以弧度为单位，距离以纳米 (nm) 为单位。所有对数均为自然对数。在所有情况下，使用 $R = 0.008314462618$ 千焦/摩尔/开尔文 和 $T = 298$ 开尔文，并以 kJ/mol 表示最终能量。程序不应依赖任何随机性、用户输入或外部文件。\n\n合成数据的基本定义和生成模型如下。设沿 $q$ 的无偏概率密度为代表闭合和打开构象的两个高斯分量的混合。定义 $p_0(q) \\propto w_1 \\exp\\left(-\\frac{(q - \\mu_1)^2}{2 \\sigma_1^2}\\right) + w_2 \\exp\\left(-\\frac{(q - \\mu_2)^2}{2 \\sigma_2^2}\\right)$，其中权重 $w_1$ 和 $w_2$ 为正。在具有谐波偏置 $U_i(q) = \\frac{1}{2} k_i (q - q_i)^2$ 的伞形窗口 $i$ 中，偏置采样密度为 $p_i(q) \\propto p_0(q) \\exp(-\\beta U_i(q))$。合成直方图是通过在均匀间隔的网格上离散化 $q$ 并根据归一化的 $p_i(q)$ 在各个区间 (bin) 中确定性地分配总样本数 $M_i$ 来生成的。这种确定性分配必须确保总计数恰好等于 $M_i$。从跨窗口的偏置直方图系综中，重建各个区间的无偏概率，并将其转换为平均力势 $W(q) = - \\frac{1}{\\beta} \\ln P(q) + C$，其中选择 $C$ 以使 $W(q)$ 的最小值为零。\n\n加权直方图分析方法必须通过求解一组自洽方程来实现，这组方程源于无偏概率 $P(q)$ 在各自偏置下与所有偏置直方图兼容，并满足每个窗口的归一化约束的要求。重建必须通过迭代直至收敛来完成。重建后，使用指定的区间识别对应于闭合和打开状态的两个势阱，并计算两个指标：势垒高度和势阱之间的自由能差。势垒高度定义为 $W(q^\\ddagger) - \\min\\{W(q_{\\text{closed}}^{\\ast}), W(q_{\\text{open}}^{\\ast})\\}$，其中 $q_{\\text{closed}}^{\\ast}$ 和 $q_{\\text{open}}^{\\ast}$ 分别是闭合和打开状态指定势阱区间内局部最小值的区间位置，$q^\\ddagger$ 是这些最小值之间的局部最大值的位置。自由能差定义为 $W(q_{\\text{open}}^{\\ast}) - W(q_{\\text{closed}}^{\\ast})$。以千焦/摩尔 (kJ/mol) 报告这两个指标，在程序中按全精度浮点数计算，无需显式取整。\n\n您的程序必须实现以下三个测试用例，它们共同测试了分离坐标和角度坐标的重建，包括一个具有大量窗口重叠的理想情况，以及一个重叠不良的挑战性边缘情况。对于所有测试用例，使用 $\\beta = 1/(R T)$，其中 $R = 0.008314462618$ 千焦/摩尔/开尔文，$T = 298$ 开尔文。网格离散化是均匀的，并且所有计算都应用相同的 $\\beta$。\n\n- 测试用例 1（分离坐标，理想情况）：\n    - 坐标：$q = x$，单位为纳米。\n    - 网格：$x \\in [0.24, 0.60]$ 纳米，区间宽度 $\\Delta x = 0.002$ 纳米。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.5$，$\\mu_1 = 0.30$ 纳米，$\\sigma_1 = 0.015$ 纳米，$\\mu_2 = 0.52$ 纳米，$\\sigma_2 = 0.020$ 纳米。\n    - 窗口数：$K = 7$，窗口中心 $q_i \\in \\{0.28, 0.32, 0.36, 0.42, 0.48, 0.52, 0.56\\}$ 纳米，所有 $i$ 的弹簧常数 $k_i = 1500$ 千焦/摩尔/纳米平方，每个窗口的样本数 $M_i = 5000$。\n    - 势阱区间：闭合势阱 $x \\in [0.27, 0.36]$ 纳米；打开势阱 $x \\in [0.47, 0.57]$ 纳米。\n\n- 测试用例 2（角度坐标，理想情况）：\n    - 坐标：$q = \\theta$，单位为弧度。\n    - 网格：$\\theta \\in [0.00, 0.90]$ 弧度，区间宽度 $\\Delta \\theta = 0.01$ 弧度。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.25$，$\\mu_1 = 0.00$ 弧度，$\\sigma_1 = 0.12$ 弧度，$\\mu_2 = 0.60$ 弧度，$\\sigma_2 = 0.12$ 弧度。\n    - 窗口数：$K = 5$，窗口中心 $q_i \\in \\{0.00, 0.20, 0.40, 0.60, 0.80\\}$ 弧度，所有 $i$ 的弹簧常数 $k_i = 60$ 千焦/摩尔/弧度平方，每个窗口的样本数 $M_i = 5000$。\n    - 势阱区间：闭合势阱 $\\theta \\in [0.00, 0.25]$ 弧度；打开势阱 $\\theta \\in [0.50, 0.80]$ 弧度。\n\n- 测试用例 3（分离坐标，重叠不良的边缘情况）：\n    - 坐标：$q = x$，单位为纳米。\n    - 网格：$x \\in [0.24, 0.60]$ 纳米，区间宽度 $\\Delta x = 0.002$ 纳米。\n    - 无偏混合参数：$w_1 = 1.0$，$w_2 = 0.5$，$\\mu_1 = 0.30$ 纳米，$\\sigma_1 = 0.015$ 纳米，$\\mu_2 = 0.52$ 纳米，$\\sigma_2 = 0.020$ 纳米。\n    - 窗口数：$K = 3$，窗口中心 $q_i \\in \\{0.30, 0.42, 0.54\\}$ 纳米，所有 $i$ 的弹簧常数 $k_i = 6000$ 千焦/摩尔/纳米平方，每个窗口的样本数 $M_i = 2000$。\n    - 势阱区间：闭合势阱 $x \\in [0.27, 0.36]$ 纳米；打开势阱 $x \\in [0.47, 0.57]$ 纳米。\n\n算法要求：\n- 对于每个测试用例，在网格上构建 $p_0(q)$（不考虑比例常数），并与谐波偏置结合以获得每个窗口中归一化的 $p_i(q)$。\n- 确定性地分配整数直方图计数 $n_i(q)$，使得 $\\sum_{q} n_i(q) = M_i$ 恰好成立，采用的方案是为每个区间分配 $\\lfloor M_i p_i(q) \\rfloor$ 个计数，然后按残差降序分配剩余的计数，直到所有 $M_i$ 个样本都被分配完毕。\n- 从第一性原理推导并实现迭代的加权直方图分析方法重建。不要使用任何预封装的 WHAM 函数。迭代方案必须收敛到一个自洽的 $P(q)$（在各区间上）和窗口自由能偏移量，以强制执行每个窗口的归一化约束。\n- 将重建的 $P(q)$ 转换为单位为千焦/摩尔的 $W(q)$，并进行归一化以使 $\\min_q W(q) = 0$。\n- 识别势阱最小值和其间的势垒，并计算势垒高度和势阱自由能差。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，本身是一个包含两个元素的列表，分别表示势垒高度和势阱自由能差（单位为千焦/摩尔）。例如，输出格式应精确为 $[[b_1,\\Delta_1],[b_2,\\Delta_2],[b_3,\\Delta_3]]$ 的形式，其中 $b_i$ 是势垒高度，$\\Delta_i$ 是测试用例 $i$ 的（打开态-闭合态）自由能差。",
            "solution": "问题陈述已经过严格验证，被认为是科学上合理、定义明确、客观且完整的。它描述了计算生物物理学中一个标准且重要的过程：使用加权直方图分析方法 (Weighted Histogram Analysis Method, WHAM) 从偏置模拟中重建平均力势 (potential of mean force, PMF)。提供的参数和测试用例在物理上是合理的，在计算上是可行的。因此，我们可以进行形式化的推导和求解。\n\n核心任务是从 $K$ 个独立模拟（窗口）生成的偏置直方图集合 $\\{n_i(q)\\}$ 中，重建沿集体坐标 $q$ 的无偏概率分布 $P(q)$。每个窗口 $i$ 都受到一个偏置势 $U_i(q)$ 的作用。\n\n基本原理是玻尔兹曼分布。系统处于坐标为 $q$ 的状态的无偏概率与其平均力势 $F_0(q)$ 相关，关系如下：\n$$\nP(q) \\propto \\exp(-\\beta F_0(q))\n$$\n其中 $\\beta = 1/(RT)$ 是逆温度，$R$ 是摩尔气体常数，$T$ 是绝对温度。因此，PMF 为 $F_0(q) = -\\frac{1}{\\beta} \\ln P(q) + C$，其中 $C$ 是一个任意常数。\n\n在伞形采样中，每个窗口 $i$ 都增加了一个偏置势 $U_i(q)$。由此产生的偏置概率分布 $p_i(q)$ 由下式给出：\n$$\np_i(q) \\propto P(q) \\exp(-\\beta U_i(q))\n$$\n在窗口 $i$ 中采样的总概率是归一化的。设 $f_i$ 是窗口 $i$ 相对于无偏系统的自由能偏移量。这个偏移量作为归一化常数的对数：\n$$\n\\exp(-\\beta f_i) = \\int P(q) \\exp(-\\beta U_i(q)) dq\n$$\n对于中心在 $q_j$ 的离散坐标网格，这变成一个求和：\n$$\n\\exp(-\\beta f_i) = \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j))\n$$\n因此，窗口 $i$ 中区间 $j$ 的归一化偏置概率为：\n$$\np_i(q_j) = \\frac{P(q_j) \\exp(-\\beta U_i(q_j))}{\\sum_k P(q_k) \\exp(-\\beta U_i(q_k))} = P(q_j) \\exp(-\\beta U_i(q_j)) \\exp(\\beta f_i)\n$$\n\nWHAM 方程是通过最大化观察到直方图集合 $\\{n_i(q_j)\\}$ 的似然性来推导的，其中 $n_i(q_j)$ 是窗口 $i$ 中区间 $j$ 的计数值。窗口 $i$ 中的总样本数为 $M_i = \\sum_j n_i(q_j)$。观察到完整数据集的对数似然函数 $\\ln \\mathcal{L}$（忽略常数项）为：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{K} \\sum_{j} n_i(q_j) \\ln p_i(q_j)\n$$\n代入 $p_i(q_j)$ 的表达式：\n$$\n\\ln \\mathcal{L} = \\sum_{i=1}^{K} \\sum_{j} n_i(q_j) \\left( \\ln P(q_j) - \\beta U_i(q_j) + \\beta f_i \\right)\n$$\n我们希望找到一组概率 $\\{P(q_j)\\}$ 和自由能 $\\{f_i\\}$，使得 $\\ln \\mathcal{L}$ 在约束条件 $\\sum_j P(q_j) = 1$ 和 $f_i$ 的定义下最大化。这个优化问题导出一组自洽方程。通过对相应的拉格朗日量关于每个 $P(q_j)$ 求偏导数并令其为零，我们得到 $P(q_j)$ 的最优估计：\n$$\nP(q_j) = \\frac{\\sum_{i=1}^{K} n_i(q_j)}{\\sum_{k=1}^{K} M_k \\exp(\\beta f_k - \\beta U_k(q_j))} \\quad \\text{(方程 1)}\n$$\n这个方程将区间 $j$ 中无偏概率的最佳估计表示为来自所有窗口观测值的加权平均。权重取决于窗口自由能 $f_k$。\n\n自由能 $f_i$ 本身由归一化条件决定，我们重述如下：\n$$\n\\exp(-\\beta f_i) = \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j)) \\quad \\text{(方程 2)}\n$$\n这可以重新排列以求解 $f_i$：\n$$\nf_i = -\\frac{1}{\\beta} \\ln \\left( \\sum_{j} P(q_j) \\exp(-\\beta U_i(q_j)) \\right)\n$$\n\n方程 1 和 2 构成一个耦合的非线性系统，必须通过迭代求解 $\\{P(q_j)\\}$ 和 $\\{f_i\\}$。对所有 $f_i$ 加上一个任意常数不会改变 $P(q_j)$ 的解，因此我们在整个迭代过程中固定一个值，例如 $f_1 = 0$。\n\n迭代算法如下：\n1. 初始化自由能，例如，对于所有 $i=1, \\dots, K$，令 $f_i = 0$。\n2. 开始迭代：\n   a. 使用当前的 $\\{f_i\\}$ 集合和直方图数据 $\\{n_i(q_j)\\}$ 通过方程 1 计算所有区间 $j$ 的无偏概率 $P(q_j)$。\n   b. 归一化得到的概率分布：$P(q_j) \\leftarrow P(q_j) / \\sum_k P(q_k)$。\n   c. 使用更新后的 $\\{P(q_j)\\}$ 通过方程 2 计算一组新的自由能 $\\{f_i^{\\text{new}}\\}$。\n   d. 通过平移新的自由能来固定任意常数，例如，$f_i^{\\text{new}} \\leftarrow f_i^{\\text{new}} - f_1^{\\text{new}}$。\n   e. 通过比较 $\\{f_i^{\\text{new}}\\}$ 和之前的 $\\{f_i\\}$ 来检查收敛性。如果最大绝对差低于定义的容差，则解已收敛。否则，设置 $f_i \\leftarrow f_i^{\\text{new}}$ 并从步骤 2a 重复。\n\n在应用 WHAM 之前，确定性地生成合成直方图。无偏概率密度 $p_0(q)$ 定义为高斯混合。对于每个窗口 $i$，在网格上计算偏置概率密度 $p_i(q) \\propto p_0(q)\\exp(-\\beta U_i(q))$ 并进行归一化。然后，将 $M_i$ 个总样本分配到各个区间。首先分配整数计数为 $n_i(q_j) = \\lfloor M_i p_i(q_j) \\rfloor$。剩余的 $M_i - \\sum_j n_i(q_j)$ 个样本逐一分配给具有最大残差 $r_j = M_i p_i(q_j) - n_i(q_j)$ 的区间，直到总计数与 $M_i$ 相符。\n\n一旦获得收敛的无偏概率分布 $P(q)$，PMF 就计算为 $W(q) = -\\frac{1}{\\beta} \\ln P(q)$。为防止数值错误，在取对数之前对 $P(q)$ 应用一个小的正数下限。通过减去其最小值来归一化 PMF，使得 $\\min(W(q)) = 0$。\n\n最后，计算所需的指标。在指定的势阱区间内找到局部最小值 $q_{\\text{closed}}^{\\ast}$ 和 $q_{\\text{open}}^{\\ast}$。在这两个最小值之间的 PMF 剖面上定位局部最大值 $q^{\\ddagger}$。势垒高度是 $W(q^\\ddagger) - \\min\\{W(q_{\\text{closed}}^{\\ast}), W(q_{\\text{open}}^{\\ast})\\}$，自由能差是 $\\Delta W = W(q_{\\text{open}}^{\\ast}) - W(q_{\\text{closed}}^{\\ast})$。",
            "answer": "```python\nimport numpy as np\n\nclass WHAMAnalysis:\n    \"\"\"\n    Encapsulates the logic for a single WHAM test case, from data generation\n    to PMF reconstruction and analysis.\n    \"\"\"\n    def __init__(self, test_case_params):\n        \"\"\"\n        Initializes the analysis with parameters for a specific test case.\n        \"\"\"\n        self.params = test_case_params\n        self.R = 0.008314462618  # kJ/mol/K\n        self.T = 298.0  # K\n        self.beta = 1.0 / (self.R * self.T)\n\n        grid_params = self.params['grid']\n        self.q = np.arange(\n            grid_params['range'][0],\n            grid_params['range'][1] + grid_params['width'] / 2.0,\n            grid_params['width']\n        )\n        self.num_bins = len(self.q)\n\n    def _generate_synthetic_data(self):\n        \"\"\"\n        Generates deterministic histograms based on the problem's generative model.\n        \"\"\"\n        # 1. Unbiased probability density (unnormalized)\n        p0_params = self.params['unbiased_mixture']\n        p0 = p0_params['w1'] * np.exp(-((self.q - p0_params['mu1'])**2) / (2 * p0_params['sigma1']**2)) + \\\n             p0_params['w2'] * np.exp(-((self.q - p0_params['mu2'])**2) / (2 * p0_params['sigma2']**2))\n\n        # 2. Biased histograms for each window\n        num_windows = self.params['num_windows']\n        window_centers = self.params['window_centers']\n        spring_constants = self.params['spring_constants']\n        samples_per_window = self.params['samples_per_window']\n\n        histograms = np.zeros((num_windows, self.num_bins), dtype=int)\n        biases = np.zeros((num_windows, self.num_bins))\n\n        for i in range(num_windows):\n            # Calculate bias potential U_i(q)\n            U_i = 0.5 * spring_constants[i] * (self.q - window_centers[i])**2\n            biases[i, :] = U_i\n\n            # Calculate biased probability density p_i(q)\n            p_i = p0 * np.exp(-self.beta * U_i)\n            \n            # Normalize p_i\n            p_i_normalized = p_i / np.sum(p_i)\n\n            # Deterministic histogram generation\n            M_i = samples_per_window[i]\n            expected_counts = M_i * p_i_normalized\n            \n            base_counts = np.floor(expected_counts).astype(int)\n            histograms[i, :] = base_counts\n            \n            remainder_count = M_i - np.sum(base_counts)\n            if remainder_count > 0:\n                residuals = expected_counts - base_counts\n                top_residual_indices = np.argsort(residuals)[-remainder_count:]\n                histograms[i, top_residual_indices] += 1\n        \n        return histograms, biases, np.array(samples_per_window, dtype=float)\n\n    def _run_wham(self, histograms, biases, M_i_vec, tol=1e-12, max_iter=10000):\n        \"\"\"\n        Solves the WHAM equations iteratively.\n        \"\"\"\n        num_windows = histograms.shape[0]\n        \n        # Initialize free energies\n        f = np.zeros(num_windows)\n        \n        N_j = np.sum(histograms, axis=0) # Total counts per bin\n\n        for iteration in range(max_iter):\n            f_old = np.copy(f)\n            \n            # Equation 1: Calculate P(q_j)\n            denominator = np.zeros(self.num_bins)\n            for k in range(num_windows):\n                denominator += M_i_vec[k] * np.exp(self.beta * (f[k] - biases[k, :]))\n            \n            P = np.zeros_like(denominator)\n            # Avoid division by zero where denominator might be zero (although unlikely)\n            # If N_j is zero, P_j is zero.\n            non_zero_N_j = N_j > 0\n            safe_denominator = np.where(denominator > 0, denominator, 1.0)\n            P[non_zero_N_j] = N_j[non_zero_N_j] / safe_denominator[non_zero_N_j]\n\n            # Normalize P\n            P /= np.sum(P)\n            \n            # Equation 2: Update f_i\n            f_new = np.zeros_like(f)\n            # Add a small epsilon to P to avoid log(0)\n            P_log_safe = P + 1e-300\n            for i in range(num_windows):\n                sum_term = np.sum(P_log_safe * np.exp(-self.beta * biases[i, :]))\n                f_new[i] = - (1.0 / self.beta) * np.log(sum_term)\n\n            # Shift f to set f_1 = 0\n            f = f_new - f_new[0]\n\n            # Check for convergence\n            if np.max(np.abs(f - f_old))  tol:\n                break\n        \n        return P\n\n    def _analyze_pmf(self, P, basin_intervals):\n        \"\"\"\n        Calculates the PMF and extracts the required metrics.\n        \"\"\"\n        # Calculate PMF W(q)\n        P_safe = np.maximum(P, 1e-300) # Prevent log(0)\n        W = - (1.0 / self.beta) * np.log(P_safe)\n        \n        # Normalize PMF so min(W) = 0\n        W -= np.min(W)\n\n        # Identify basin indices\n        basin_closed_indices = np.where(\n            (self.q >= basin_intervals['closed'][0])  (self.q = basin_intervals['closed'][1])\n        )[0]\n        basin_open_indices = np.where(\n            (self.q >= basin_intervals['open'][0])  (self.q = basin_intervals['open'][1])\n        )[0]\n\n        # Find minima in basins\n        idx_closed_min_local = np.argmin(W[basin_closed_indices])\n        idx_closed_min = basin_closed_indices[idx_closed_min_local]\n        w_closed_star = W[idx_closed_min]\n\n        idx_open_min_local = np.argmin(W[basin_open_indices])\n        idx_open_min = basin_open_indices[idx_open_min_local]\n        w_open_star = W[idx_open_min]\n        \n        # Find barrier between minima\n        start_idx = min(idx_closed_min, idx_open_min) + 1\n        end_idx = max(idx_closed_min, idx_open_min)\n        \n        if start_idx >= end_idx: # No points between minima\n            w_ddagger = max(w_closed_star, w_open_star)\n        else:\n            idx_barrier_local = np.argmax(W[start_idx:end_idx])\n            idx_barrier = start_idx + idx_barrier_local\n            w_ddagger = W[idx_barrier]\n\n        # Calculate metrics\n        barrier_height = w_ddagger - min(w_closed_star, w_open_star)\n        free_energy_diff = w_open_star - w_closed_star\n        \n        return [barrier_height, free_energy_diff]\n\n    def run(self):\n        \"\"\"\n        Executes the full analysis pipeline for the test case.\n        \"\"\"\n        histograms, biases, M_i_vec = self._generate_synthetic_data()\n        P = self._run_wham(histograms, biases, M_i_vec)\n        results = self._analyze_pmf(P, self.params['basin_intervals'])\n        return results\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the analysis, and print results.\n    \"\"\"\n    test_cases = [\n        # Test Case 1: separation coordinate, happy path\n        {\n            'grid': {'range': [0.24, 0.60], 'width': 0.002},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.5, 'mu1': 0.30, 'sigma1': 0.015, 'mu2': 0.52, 'sigma2': 0.020},\n            'num_windows': 7,\n            'window_centers': [0.28, 0.32, 0.36, 0.42, 0.48, 0.52, 0.56],\n            'spring_constants': [1500] * 7,\n            'samples_per_window': [5000] * 7,\n            'basin_intervals': {'closed': [0.27, 0.36], 'open': [0.47, 0.57]}\n        },\n        # Test Case 2: angular coordinate, happy path\n        {\n            'grid': {'range': [0.00, 0.90], 'width': 0.01},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.25, 'mu1': 0.00, 'sigma1': 0.12, 'mu2': 0.60, 'sigma2': 0.12},\n            'num_windows': 5,\n            'window_centers': [0.00, 0.20, 0.40, 0.60, 0.80],\n            'spring_constants': [60] * 5,\n            'samples_per_window': [5000] * 5,\n            'basin_intervals': {'closed': [0.00, 0.25], 'open': [0.50, 0.80]}\n        },\n        # Test Case 3: separation coordinate, poor overlap\n        {\n            'grid': {'range': [0.24, 0.60], 'width': 0.002},\n            'unbiased_mixture': {'w1': 1.0, 'w2': 0.5, 'mu1': 0.30, 'sigma1': 0.015, 'mu2': 0.52, 'sigma2': 0.020},\n            'num_windows': 3,\n            'window_centers': [0.30, 0.42, 0.54],\n            'spring_constants': [6000] * 3,\n            'samples_per_window': [2000] * 3,\n            'basin_intervals': {'closed': [0.27, 0.36], 'open': [0.47, 0.57]}\n        }\n    ]\n\n    all_results = []\n    for params in test_cases:\n        analyzer = WHAMAnalysis(params)\n        result = analyzer.run()\n        all_results.append(result)\n\n    # Format the results into the required string \"[[b_1,d_1],[b_2,d_2],[b_3,d_3]]\"\n    result_str = '[' + ','.join([f\"[{r[0]},{r[1]}]\" for r in all_results]) + ']'\n    print(result_str)\n\n# Execute the solver\nsolve()\n```"
        }
    ]
}