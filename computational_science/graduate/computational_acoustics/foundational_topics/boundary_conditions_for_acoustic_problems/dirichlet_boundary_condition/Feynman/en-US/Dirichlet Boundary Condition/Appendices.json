{
    "hands_on_practices": [
        {
            "introduction": "Before diving into numerical methods, it is crucial to understand the physical implications of a Dirichlet boundary condition. This exercise challenges you to connect the mathematical statement $p=0$ to the physical phenomenon of wave reflection at a sound-soft surface. By deriving the reflection coefficient from the fundamental equations of acoustics, you will gain a first-principles understanding of why a pressure-release boundary causes a perfect, phase-inverted reflection of an incident plane wave.",
            "id": "4120025",
            "problem": "Consider a homogeneous, inviscid, compressible fluid occupying the half-space $z>0$ with constant density $\\rho$ and sound speed $c$. A time-harmonic plane acoustic wave of angular frequency $\\omega$ is incident from within the fluid onto the planar boundary at $z=0$. The boundary is pressure-release (sound-soft), so the acoustic pressure satisfies the Dirichlet boundary condition $p(x,z=0,t)=0$ for all $x$ and $t$. Let the incident wavevector make an angle $\\theta \\in (0,\\pi/2)$ with the unit normal pointing from the fluid toward the boundary, and assume two-dimensional dependence in the $x$-$z$ plane.\n\nStarting from the linearized equations of acoustics and the equation of state, derive the scalar Helmholtz partial differential equation (PDE) satisfied by the complex pressure amplitude $p(x,z)$ under a time-harmonic ansatz. Then, using only the boundary condition, homogeneity of the medium, and translational invariance of the boundary, show from first principles that the component of the wavevector tangent to the boundary is preserved under reflection. Finally, determine the complex pressure reflection coefficient $R_p$ defined by $p_r = R_p\\,p_i$ at $z=0$, where $p_i$ and $p_r$ are the incident and reflected complex pressure fields, respectively.\n\nProvide as your final answer a single closed-form expression for $R_p$ (dimensionless). No numerical rounding is required. All angles, if needed, should be treated in radians.",
            "solution": "The problem asks for three distinct derivations related to the reflection of a plane acoustic wave from a pressure-release boundary. We will address each part in sequence, starting from the fundamental principles of linear acoustics.\n\nThe governing equations for acoustics in a homogeneous, inviscid, compressible fluid with equilibrium density $\\rho_0$ and pressure $p_0$ are the linearized Euler's equation (conservation of momentum) and the continuity equation (conservation of mass). For small perturbations in pressure $p$, density $\\rho'$, and fluid velocity $\\mathbf{u}$, these are:\n$$\n\\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\nabla p \\quad \\text{(Momentum)}\n$$\n$$\n\\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} = 0 \\quad \\text{(Continuity)}\n$$\nThe system is closed by the linearized equation of state, which relates pressure and density perturbations for an isentropic process:\n$$\np = c^2 \\rho'\n$$\nwhere $c = \\sqrt{(\\partial p/\\partial \\rho)_S}$ is the speed of sound, which is constant in this homogeneous medium.\n\n**Part 1: Derivation of the Helmholtz Equation**\n\nOur goal is to combine these three equations into a single partial differential equation (PDE) for the acoustic pressure $p$.\n\nFirst, we take the divergence of the momentum equation:\n$$\n\\nabla \\cdot \\left( \\rho_0 \\frac{\\partial \\mathbf{u}}{\\partial t} \\right) = -\\nabla \\cdot (\\nabla p)\n$$\nSince $\\rho_0$ is a constant and spatial and temporal derivatives commute, we get:\n$$\n\\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = -\\nabla^2 p\n$$\nNext, we take the time derivative of the continuity equation:\n$$\n\\frac{\\partial}{\\partial t} \\left( \\frac{\\partial \\rho'}{\\partial t} + \\rho_0 \\nabla \\cdot \\mathbf{u} \\right) = 0\n$$\n$$\n\\frac{\\partial^2 \\rho'}{\\partial t^2} + \\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = 0\n$$\nNow, substitute $\\rho' = p/c^2$ from the equation of state into this result:\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p}{\\partial t^2} + \\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = 0\n$$\nWe can isolate the term $\\rho_0 \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u})$ from the divergence of the momentum equation, which gives $\\rho_0 \\frac{\\partial}{\\partial t}(\\nabla \\cdot \\mathbf{u}) = -\\nabla^2 p$. Substituting this into the previous equation yields:\n$$\n\\frac{1}{c^2} \\frac{\\partial^2 p}{\\partial t^2} - \\nabla^2 p = 0\n$$\nThis is the homogeneous acoustic wave equation for the pressure field $p(x,z,t)$.\n\nThe problem specifies a time-harmonic wave of angular frequency $\\omega$. We thus employ a time-harmonic ansatz for the pressure, expressing the total pressure field as the real part of a complex quantity. Following standard convention in physics and engineering, we write the full time-dependent pressure as $p_{total}(x,z,t) = p(x,z)e^{-i\\omega t}$, where $p(x,z)$ is the complex pressure amplitude. Substituting this into the wave equation:\n$$\n\\nabla^2 (p(x,z)e^{-i\\omega t}) - \\frac{1}{c^2} \\frac{\\partial^2}{\\partial t^2} (p(x,z)e^{-i\\omega t}) = 0\n$$\nSince $p(x,z)$ does not depend on time $t$, we can perform the differentiation with respect to $t$: $\\frac{\\partial}{\\partial t} (e^{-i\\omega t}) = -i\\omega e^{-i\\omega t}$ and $\\frac{\\partial^2}{\\partial t^2} (e^{-i\\omega t}) = (-i\\omega)^2 e^{-i\\omega t} = -\\omega^2 e^{-i\\omega t}$. The equation becomes:\n$$\ne^{-i\\omega t} \\nabla^2 p(x,z) - \\frac{1}{c^2} p(x,z) (-\\omega^2 e^{-i\\omega t}) = 0\n$$\nWe can factor out the non-zero term $e^{-i\\omega t}$:\n$$\n\\nabla^2 p(x,z) + \\frac{\\omega^2}{c^2} p(x,z) = 0\n$$\nDefining the wavenumber as $k = \\omega/c$, we arrive at the scalar Helmholtz PDE for the complex pressure amplitude:\n$$\n\\nabla^2 p(x,z) + k^2 p(x,z) = 0\n$$\n\n**Part 2: Conservation of the Tangential Wavevector Component**\n\nThe total pressure field $p(x,z)$ in the fluid is the superposition of the incident wave $p_i(x,z)$ and the reflected wave $p_r(x,z)$:\n$$\np(x,z) = p_i(x,z) + p_r(x,z)\n$$\nAs plane waves satisfying the Helmholtz equation, the incident and reflected fields have the general form:\n$$\np_i(x,z) = P_i e^{i(k_{ix}x + k_{iz}z)}\n$$\n$$\np_r(x,z) = P_r e^{i(k_{rx}x + k_{rz}z)}\n$$\nwhere $P_i$ and $P_r$ are complex amplitudes, and $\\mathbf{k}_i = (k_{ix}, k_{iz})$ and $\\mathbf{k}_r = (k_{rx}, k_{rz})$ are the incident and reflected wavevectors, respectively. The homogeneity of the medium requires that both waves travel at the same speed $c$, so their wavenumbers must have the same magnitude: $|\\mathbf{k}_i| = |\\mathbf{k}_r| = k = \\omega/c$.\n\nThe boundary condition is that of a pressure-release surface at $z=0$, which means the total acoustic pressure is zero at all points on the boundary for all time. In terms of the complex amplitude, this is:\n$$\np(x,z=0) = 0 \\quad \\text{for all } x\n$$\nSubstituting the expressions for the incident and reflected waves into the boundary condition:\n$$\np_i(x,0) + p_r(x,0) = 0\n$$\n$$\nP_i e^{i(k_{ix}x + k_{iz} \\cdot 0)} + P_r e^{i(k_{rx}x + k_{rz} \\cdot 0)} = 0\n$$\n$$\nP_i e^{ik_{ix}x} + P_r e^{ik_{rx}x} = 0\n$$\nThis equation must hold for all values of $x$ along the boundary. This is the crucial consequence of the boundary's translational invariance. The functions $\\{e^{i\\lambda x} | \\lambda \\in \\mathbb{R}\\}$ form a set of linearly independent basis functions. For a linear combination of two such functions to be zero for all $x$, one of two conditions must be met:\n1. The coefficients are both zero ($P_i=0$ and $P_r=0$), which corresponds to the trivial case of no wave.\n2. The exponents are identical ($k_{ix} = k_{rx}$) and the sum of the coefficients is zero ($P_i + P_r = 0$).\n\nAssuming a non-trivial incident wave ($P_i \\neq 0$), the second condition must hold. Therefore, we must have:\n$$\nk_{ix} = k_{rx}\n$$\nThis proves from first principles (homogeneity, translational invariance, and the boundary condition) that the component of the wavevector tangent to the boundary is conserved upon reflection. This is the foundation of Snell's law of reflection.\n\n**Part 3: Determination of the Pressure Reflection Coefficient**\n\nThe complex pressure reflection coefficient $R_p$ is defined by the relation $p_r = R_p p_i$ evaluated at the boundary $z=0$.\n$$\nR_p = \\frac{p_r(x,z=0)}{p_i(x,z=0)}\n$$\nUsing the plane wave expressions at $z=0$:\n$$\nR_p = \\frac{P_r e^{ik_{rx}x}}{P_i e^{ik_{ix}x}}\n$$\nFrom the result of Part 2, we know $k_{ix} = k_{rx}$. The expression for $R_p$ simplifies to the ratio of the complex amplitudes:\n$$\nR_p = \\frac{P_r}{P_i}\n$$\nAlso from Part 2, the boundary condition requires that $P_i + P_r = 0$, which implies $P_r = -P_i$. Substituting this into the expression for $R_p$:\n$$\nR_p = \\frac{-P_i}{P_i} = -1\n$$\nThus, the complex pressure reflection coefficient for a plane wave incident on a pressure-release boundary is $-1$. This indicates that the reflected pressure wave has the same amplitude as the incident wave but is perfectly out of phase (a phase shift of $\\pi$ radians) at the boundary, ensuring their sum is always zero. This result is independent of the angle of incidence $\\theta$.",
            "answer": "$$\n\\boxed{-1}\n$$"
        },
        {
            "introduction": "Moving from analytical theory to computational practice, we immediately face the challenge of representing geometry on a discrete grid. This problem focuses on a classic issue in finite-difference methods: the 'staircasing' error that arises when approximating a curved Dirichlet boundary on a Cartesian mesh. By implementing a finite-difference solver for a circular domain, you will numerically quantify this geometric error, verify its theoretical scaling, and derive a practical mesh refinement strategy based on your findings.",
            "id": "4120000",
            "problem": "Consider time-harmonic acoustic pressure governed by the scalar Helmholtz equation in two spatial dimensions with a pressure-release (sound-soft) boundary, meaning the pressure satisfies a Dirichlet condition equal to zero on the boundary. A standard reduced formulation uses the Dirichlet Laplacian eigenproblem to characterize modal wavenumbers. Specifically, for a bounded domain with smooth boundary, the first mode is given by the smallest eigenpair of the operator $-\\Delta$ with Dirichlet boundary condition $p=0$ on the boundary, satisfying\n$$\n-\\Delta p = \\lambda p, \\quad p|_{\\partial \\Omega}=0.\n$$\nWhen the boundary is curved (for example, a circle) but discretized on a Cartesian grid, the boundary is approximated using a staircasing mask. This geometric approximation introduces errors in the computed eigenvalue and field, even if the interior finite-difference operator is nominally second-order. Your task is to quantify the staircasing error in the first Dirichlet eigenvalue for a disk and to propose a mesh refinement criterion based on first-principles scaling.\n\nStarting from fundamental laws and core definitions, formulate the computational procedure as follows:\n- The physical domain is a disk of radius $R$ (expressed in meters), centered at the origin, with the Dirichlet boundary condition $p=0$ at $r=R$.\n- The continuous first Dirichlet eigenvalue for a disk is given by\n$$\n\\lambda_{\\text{anal}} = \\frac{j_{0,1}^2}{R^2},\n$$\nwhere $j_{0,1}$ is the first positive zero of the Bessel function of the first kind of order zero.\n- Approximate the disk on a uniform Cartesian grid with spacing $h$ (expressed in meters). Construct a binary mask for grid nodes whose coordinates $(x,y)$ satisfy $x^2+y^2<R^2$; treat nodes outside the mask as the Dirichlet boundary with prescribed pressure equal to zero. Assemble the standard five-point finite-difference matrix for the operator $-\\Delta$ on masked interior nodes using the stencil\n$$\n(-\\Delta_h p)_{i,j} = \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2},\n$$\nwith neighbors outside the mask contributing zero due to the Dirichlet boundary.\n- Compute the smallest eigenvalue $\\lambda_{\\text{num}}$ of the discrete operator using a symmetric eigensolver, and quantify the relative staircasing error\n$$\n\\varepsilon = \\left|\\frac{\\lambda_{\\text{num}}-\\lambda_{\\text{anal}}}{\\lambda_{\\text{anal}}}\\right|.\n$$\n\nUsing domain perturbation reasoning, the leading-order contribution of geometric staircasing on a smooth boundary suggests the scaling\n$$\n\\varepsilon \\approx C \\frac{h}{R},\n$$\nfor some dimensionless constant $C$ that depends on the boundary enforcement strategy but is approximately constant across $R$ and $h$ for the same staircasing approach. Estimate $C$ empirically from the computed errors by fitting $\\varepsilon$ versus $h/R$ and then propose a mesh refinement criterion: for a specified error tolerance $\\varepsilon_{\\text{tol}}$ (dimensionless, expressed as a decimal), choose\n$$\nh_{\\max} \\approx \\frac{\\varepsilon_{\\text{tol}}\\,R}{C}.\n$$\n\nImplement a complete, runnable program that:\n1. Builds the masked finite-difference operator on a Cartesian grid for the disk and computes $\\lambda_{\\text{num}}$ for each test case using a symmetric sparse eigensolver.\n2. Computes $\\varepsilon$ for each test case.\n3. Estimates the constant $C$ using a robust one-parameter fit $C \\approx \\text{median}\\left(\\varepsilon \\, / \\, (h/R)\\right)$ over all test cases, and computes a recommended maximum mesh spacing $h_{\\max}$ for each case using the formula above.\n4. Reports, for each test case, whether the given $h$ meets the refinement criterion, i.e., whether $h \\le h_{\\max}$.\n\nScientific realism requirements:\n- Use the disk of radius $R$ and a grid spanning $[-R,R]\\times[-R,R]$ with uniform spacing $h$. The eigenvalue units are in inverse square meters ($\\text{m}^{-2}$). The relative error $\\varepsilon$ is dimensionless. The recommended mesh spacing $h_{\\max}$ is reported in meters.\n\nTest suite and answer specification:\n- Use the following test cases, each provided as a tuple $(R,h,\\varepsilon_{\\text{tol}})$ with $R$ and $h$ in meters and $\\varepsilon_{\\text{tol}}$ as a decimal:\n    1. $(1.0, 0.05, 0.02)$ representing a typical refinement target on a unit-radius disk.\n    2. $(1.0, 0.2, 0.05)$ representing a coarse grid on a unit-radius disk.\n    3. $(0.5, 0.025, 0.01)$ representing a smaller disk with comparatively fine grid.\n    4. $(1.0, 0.0125, 0.005)$ representing a fine grid on a unit-radius disk.\n- For each test case, compute and return the triple $[\\varepsilon, h_{\\max}, \\text{meets}]$, where $\\varepsilon$ and $h_{\\max}$ are floats and $\\text{meets}$ is a boolean indicating whether $h \\le h_{\\max}$.\n- Your program should produce a single line of output containing the results as a comma-separated list of case results enclosed in square brackets, for example,\n$$\n\\text{[}[\\varepsilon_1,h_{\\max,1},\\text{meets}_1],[\\varepsilon_2,h_{\\max,2},\\text{meets}_2],\\ldots\\text{]}.\n$$\n\nAll mathematical symbols must be presented in LaTeX, and all physical units must be faithfully adhered to as specified above. The final program must be self-contained and must not require any input. The final output format must strictly be a single line containing the list of per-case results.",
            "solution": "The task is to analyze the numerical error introduced by a staircase approximation of a circular boundary when computing the first eigenvalue of the Dirichlet Laplacian using a finite-difference method. We will formulate the computational procedure, implement it to analyze specific test cases, and derive a practical mesh refinement criterion based on the observed error scaling.\n\n**1. The Continuous Eigenproblem**\n\nThe physical problem concerns the time-harmonic acoustic pressure, $p$, in a two-dimensional domain, $\\Omega$. The pressure field is governed by the scalar Helmholtz equation. For modal analysis, this reduces to the eigenvalue problem for the negative Laplacian operator, $-\\Delta$. The domain $\\Omega$ is a disk of radius $R$ centered at the origin. The boundary condition is of the pressure-release or sound-soft type, which corresponds to a homogeneous Dirichlet condition, $p=0$, on the boundary $\\partial\\Omega$. The problem is thus stated as:\n$$\n-\\Delta p = \\lambda p \\quad \\text{in } \\Omega, \\qquad p|_{\\partial\\Omega} = 0.\n$$\nThe solutions to this problem are the eigenpairs $(\\lambda_k, p_k)$, where $\\lambda_k$ are the eigenvalues (related to modal wavenumbers) and $p_k$ are the corresponding eigenfunctions (modes).\n\nFor a disk of radius $R$, the eigenfunctions are separable in polar coordinates. The first, or fundamental, mode is radially symmetric. The analytical expression for the smallest eigenvalue, $\\lambda_{\\text{anal}}$, is known and given by:\n$$\n\\lambda_{\\text{anal}} = \\left(\\frac{j_{0,1}}{R}\\right)^2,\n$$\nwhere $j_{0,1}$ is the first positive root of the Bessel function of the first kind of order zero, $J_0(x)$. The value is approximately $j_{0,1} \\approx 2.4048255577$. The units of $\\lambda$ are inverse length squared, here $\\text{m}^{-2}$.\n\n**2. The Discrete Approximation**\n\nTo solve the problem numerically, we employ the finite-difference method. The continuous domain is replaced by a discrete set of points on a uniform Cartesian grid with spacing $h$. We define a computational grid that covers the square domain $[-R, R] \\times [-R, R]$. A grid point $(x_i, y_j)$ is considered an *interior* point if it lies inside the disk, i.e., $x_i^2 + y_j^2 < R^2$. All other points are considered part of the boundary where the pressure is fixed at $p=0$.\n\nThe negative Laplacian operator $-\\Delta$ is approximated at each interior grid point $(i, j)$ using the standard five-point stencil:\n$$\n(-\\Delta_h p)_{i,j} = \\frac{4p_{i,j} - p_{i+1,j} - p_{i-1,j} - p_{i,j+1} - p_{i,j-1}}{h^2}.\n$$\nApplying this approximation at every interior point results in a system of linear equations. Let $N_{\\text{int}}$ be the total number of interior grid points. We can represent the values of the pressure $p$ at these points as a vector $\\mathbf{p}$ of size $N_{\\text{int}}$. The discrete eigenproblem can then be written in matrix form:\n$$\nA \\mathbf{p} = \\lambda \\mathbf{p}.\n$$\nHere, $A$ is an $N_{\\text{int}} \\times N_{\\text{int}}$ sparse matrix representing the discrete operator $-\\Delta_h$. The entries of $A$ are constructed as follows:\n- For each interior point, map its $2$D grid coordinates $(i,j)$ to a unique $1$D index $k \\in \\{0, 1, \\dots, N_{\\text{int}}-1\\}$.\n- The diagonal entry corresponding to point $k$ is $A_{k,k} = 4/h^2$.\n- For each neighbor of point $k$ that is also an interior point (with index $k'$), an off-diagonal entry is set: $A_{k,k'} = -1/h^2$.\n- If a neighbor is on or outside the boundary, its pressure value is $0$ by the Dirichlet condition. This contribution is naturally incorporated into the stencil sum, so no specific matrix entry is needed for these boundary interactions.\n\nThe resulting matrix $A$ is real, symmetric, and positive definite. The smallest eigenvalue of this matrix, which we denote $\\lambda_{\\text{num}}$, is the numerical approximation of $\\lambda_{\\text{anal}}$. It can be computed efficiently using a sparse symmetric eigensolver.\n\n**3. Error Analysis and Scaling Law**\n\nThe discretization introduces errors. The primary source of error in this formulation is the \"staircase\" approximation of the smooth, curved boundary of the disk. While the five-point stencil is second-order accurate, $O(h^2)$, in the interior of the domain, the geometric error at the boundary is only first-order, $O(h)$. This lower-order error dominates the total error.\n\nWe quantify the relative error, $\\varepsilon$, in the computed eigenvalue as:\n$$\n\\varepsilon = \\left|\\frac{\\lambda_{\\text{num}}-\\lambda_{\\text{anal}}}{\\lambda_{\\text{anal}}}\\right|.\n$$\nBased on domain perturbation theory, the leading-order error is expected to scale linearly with the mesh spacing relative to the domain size:\n$$\n\\varepsilon \\approx C \\frac{h}{R},\n$$\nwhere $C$ is a dimensionless constant that depends on the geometry and the specific boundary implementation but is approximately independent of $h$ and $R$ for small $h/R$.\n\n**4. Mesh Refinement Criterion**\n\nThe goal is to determine a suitable mesh spacing $h$ to achieve a desired error tolerance $\\varepsilon_{\\text{tol}}$. First, we estimate the constant $C$ empirically. By running simulations for several combinations of $R$ and $h$ (the provided test cases), we compute the ratio $\\varepsilon / (h/R)$ for each case. A robust estimate for $C$ is obtained by taking the median of these values.\n\nOnce $C$ is known, we can invert the scaling law to determine the maximum permissible mesh spacing, $h_{\\max}$, for a given tolerance $\\varepsilon_{\\text{tol}}$:\n$$\n\\varepsilon_{\\text{tol}} \\approx C \\frac{h_{\\max}}{R} \\implies h_{\\max} \\approx \\frac{\\varepsilon_{\\text{tol}} R}{C}.\n$$\nA given mesh with spacing $h$ is considered sufficiently refined if it satisfies the criterion $h \\le h_{\\max}$.\n\nThe implemented program will execute these steps:\n1. For each test case $(R, h, \\varepsilon_{\\text{tol}})$, construct the matrix $A$ and compute $\\lambda_{\\text{num}}$.\n2. Calculate the corresponding relative error $\\varepsilon$.\n3. After processing all cases, estimate the scaling constant $C$ as the median of all computed $\\varepsilon / (h/R)$ ratios.\n4. For each test case, calculate the recommended $h_{\\max}$ using the estimated $C$ and the case-specific $\\varepsilon_{\\text{tol}}$ and $R$.\n5. Report the computed triple $[\\varepsilon, h_{\\max}, (h \\le h_{\\max})]$ for each case.",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import jn_zeros\nfrom scipy.sparse import coo_matrix\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Computes staircasing error for the Dirichlet-Laplacian eigenvalue on a disk,\n    estimates the error scaling constant, and proposes a mesh refinement criterion.\n    \"\"\"\n    # The first positive zero of the Bessel function of the first kind of order zero, J0(x).\n    j01 = jn_zeros(0, 1)[0]\n    \n    # Test cases: (R, h, eps_tol)\n    # R: radius in meters\n    # h: grid spacing in meters\n    # eps_tol: target relative error tolerance (dimensionless)\n    test_cases = [\n        (1.0, 0.05, 0.02),\n        (1.0, 0.2, 0.05),\n        (0.5, 0.025, 0.01),\n        (1.0, 0.0125, 0.005),\n    ]\n\n    # --- Pass 1: Compute numerical errors for all test cases ---\n    computed_data = []\n    ratios_for_C = []\n\n    for R, h, eps_tol in test_cases:\n        # 1. Grid and Mask Generation\n        # Create a centered Cartesian grid that encloses the disk.\n        # The number of points from center to edge is determined by floor(R/h).\n        lim = int(np.floor(R / h))\n        coords = np.arange(-lim, lim + 1) * h\n        grid_dim = len(coords)\n        xx, yy = np.meshgrid(coords, coords)\n        \n        # Create a boolean mask for grid points inside the disk.\n        mask = (xx**2 + yy**2) < R**2\n        \n        n_interior = np.sum(mask)\n        \n        # Map 2D grid indices of interior points to 1D linear indices.\n        idx_map = -np.ones((grid_dim, grid_dim), dtype=int)\n        idx_map[mask] = np.arange(n_interior)\n\n        # 2. Matrix Assembly using Coordinate (COO) format for efficiency\n        row_ind, col_ind, data = [], [], []\n        \n        # Iterate over all grid points to build the discrete operator matrix.\n        for i in range(grid_dim):\n            for j in range(grid_dim):\n                if mask[i, j]:\n                    k = idx_map[i, j]\n                    \n                    # Diagonal element from the 5-point stencil (4 * p_ij)\n                    row_ind.append(k)\n                    col_ind.append(k)\n                    data.append(4.0)\n\n                    # Off-diagonal elements for neighbors (-1 * p_neighbor)\n                    # For neighbors outside the mask, the pressure is 0 (Dirichlet BC),\n                    # so they don't contribute to the matrix for interior points.\n                    for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                        if 0 <= ni < grid_dim and 0 <= nj < grid_dim and mask[ni, nj]:\n                            k_neighbor = idx_map[ni, nj]\n                            row_ind.append(k)\n                            col_ind.append(k_neighbor)\n                            data.append(-1.0)\n        \n        # Scale matrix entries by 1/h^2.\n        mat_data = np.array(data) / (h**2)\n        \n        # Create the sparse matrix and convert to CSR format for fast arithmetic.\n        A = coo_matrix((mat_data, (row_ind, col_ind)), shape=(n_interior, n_interior)).tocsr()\n        \n        # 3. Eigenvalue Computation\n        # Use a sparse symmetric eigensolver to find the smallest magnitude eigenvalue.\n        eigenvalues, _ = eigsh(A, k=1, which='SM')\n        lambda_num = eigenvalues[0]\n        \n        # 4. Error Calculation\n        lambda_anal = (j01 / R)**2\n        epsilon = np.abs(lambda_num - lambda_anal) / lambda_anal\n        \n        # Store results for the second pass.\n        computed_data.append({'R': R, 'h': h, 'eps_tol': eps_tol, 'epsilon': epsilon})\n        ratios_for_C.append(epsilon / (h / R))\n\n    # --- Pass 2: Estimate C, compute h_max, and check criterion ---\n    \n    # Estimate the scaling constant C as the median of the observed ratios.\n    C = np.median(ratios_for_C)\n    \n    final_results = []\n    for data_point in computed_data:\n        R = data_point['R']\n        h = data_point['h']\n        eps_tol = data_point['eps_tol']\n        epsilon = data_point['epsilon']\n        \n        # Calculate the recommended maximum mesh spacing h_max based on the fitted C.\n        h_max = (eps_tol * R) / C\n        \n        # Check if the given mesh spacing h meets the refinement criterion.\n        meets_criterion = h <= h_max\n        \n        final_results.append([epsilon, h_max, meets_criterion])\n\n    # --- Format and Print Output ---\n    def format_case_result(res):\n        eps_val, hmax_val, meets_val = res\n        # Format booleans as lowercase 'true'/'false' for consistent output.\n        meets_str = str(meets_val).lower()\n        return f\"[{eps_val},{hmax_val},{meets_str}]\"\n\n    output_str = f\"[{','.join([format_case_result(res) for res in final_results])}]\"\n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "To overcome the limitations of simple grid-based methods, the Finite Element Method (FEM) offers a powerful framework for accurately modeling complex geometries. This practice delves into advanced FEM techniques for applying Dirichlet boundary conditions and improving overall simulation accuracy. You will implement a 1D FEM code to compare the effectiveness of 'strong' versus 'penalty' enforcement of the boundary condition and quantify the significant reduction in numerical dispersion error achieved by using higher-order elements.",
            "id": "4120047",
            "problem": "Consider the one-dimensional acoustic pressure field on the domain $[0,L]$ in the frequency domain. Under linear acoustics, the pressure $p(x)$ satisfies the scalar Helmholtz equation derived from conservation of mass and momentum,\n$$\\frac{d^2 p}{dx^2} + k^2 p = -s(x),$$\nwhere $k$ is the acoustic wavenumber and $s(x)$ is a source term. A pressure-release (sound-soft) boundary at $x=0$ is modeled by the Dirichlet boundary condition $p(0)=0$, and a rigid termination at $x=L$ is modeled by the Neumann boundary condition $\\frac{dp}{dx}(L)=0$.\n\nThe weak form corresponding to the Helmholtz operator and the Laplacian eigenproblem will be used as the fundamental base. For a test function $v(x)$, the weak form of the Laplacian eigenproblem is\n$$\\int_0^L \\frac{dp'}{dx}\\frac{dv'}{dx}\\,dx = \\lambda \\int_0^L p\\,v\\,dx,$$\nwith $p(0)=0$ and $\\frac{dp}{dx}(L)=0$, where $\\lambda = k^2$. For the forced Poisson problem (used to assess boundary enforcement via penalty),\n$$-\\frac{d^2 u}{dx^2} = s(x),$$\nwith $u(0)=0$ (pressure-release Dirichlet) and $\\frac{du}{dx}(L)=0$ (rigid Neumann), the weak form reads\n$$\\int_0^L \\frac{du'}{dx}\\frac{dv'}{dx}\\,dx = \\int_0^L s\\,v\\,dx.$$\nIn a penalty enforcement of the Dirichlet condition, one augments the weak form bilinear term by a boundary term $\\alpha\\,u(0)\\,v(0)$, where $\\alpha>0$ is the penalty coefficient. In one dimension on a nodal Lagrange finite element space, this reduces to a single diagonal addition at the degree of freedom associated with the boundary node at $x=0$.\n\nYou must implement a finite element method with Lagrange elements of polynomial degree $r$ on a uniform mesh of $N_e$ elements over $[0,L]$. Use the following standard facts to derive the algorithm:\n- The bilinear form for the Laplacian yields the global stiffness matrix $K$ assembled from element contributions $K_e = \\int \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx$, where $\\phi_i$ are Lagrange shape functions defined on each element.\n- The mass matrix $M$ is $M_e = \\int \\phi_i \\phi_j\\,dx$.\n- The generalized eigenvalue problem for the Laplacian is $K u = \\lambda M u$ subject to the Dirichlet boundary condition at $x=0$ enforced strongly (by eliminating the degree of freedom).\n- For the forced Poisson problem with penalty enforcement, solve $(K + \\alpha B) u = f$, where $B$ encodes the boundary term $u(0)v(0)$ and $f$ is the load vector $f_i = \\int s \\phi_i\\,dx$.\n- Use the Neumann boundary condition at $x=L$ as a natural boundary condition in the weak form (no explicit modification needed).\n\nDefine the following quantitative measures:\n1. Dirichlet boundary enforcement accuracy under penalty: compute the boundary mismatch ratio\n$$\\rho = \\frac{|u_h(0)|}{\\|u_h\\|_{L^2(0,L)}},\\quad \\|u_h\\|_{L^2(0,L)} = \\sqrt{u_h^\\top M u_h},$$\nwhere $u_h$ is the computed finite element solution to the forced Poisson problem with penalty enforcement of the Dirichlet boundary condition.\n2. Dispersion error for the fundamental mode: compute the relative eigenvalue error\n$$\\epsilon = \\frac{|\\lambda_h - \\lambda_{\\text{exact}}|}{\\lambda_{\\text{exact}}},\\quad \\lambda_{\\text{exact}} = \\left(\\frac{\\pi}{2L}\\right)^2,$$\nfor the smallest eigenvalue of the generalized eigenvalue problem for the Laplacian with Dirichlet at $x=0$ and Neumann at $x=L$.\n\nImplementation requirements:\n- Construct the Lagrange basis functions of degree $r$ on each element by solving a Vandermonde system for equidistant nodes on the reference element $[-1,1]$ and use Gaussâ€“Legendre quadrature of sufficient order to integrate exactly up to polynomial degree $2r$.\n- Assemble global stiffness and mass matrices using the mapping from the reference element to the physical element.\n- For the forced Poisson problem used to assess boundary enforcement, set $s(x) = \\exp\\!\\left(-\\left(\\frac{x - 0.7 L}{0.1 L}\\right)^2\\right)$, which is dimensionless, and add the penalty term with coefficient $\\alpha = \\sigma / h$, where $h = L/N_e$ is the element length and $\\sigma$ is a dimensionless penalty strength.\n- Enforce the Dirichlet boundary condition strongly for the eigenvalue problem by eliminating the boundary degree of freedom at $x=0$.\n\nUnits and constants:\n- Use $L = 1$ meter. All computed quantities for $\\rho$ and $\\epsilon$ are dimensionless, so no unit conversion is required in the final answers.\n\nTest suite:\nCompute the following six cases to evaluate the effect of higher-order Lagrange elements on Dirichlet boundary enforcement accuracy and dispersion errors.\n- Case A (boundary enforcement, happy path): $(r=1, N_e=32, \\sigma=10^3)$ compute $\\rho$.\n- Case B (boundary enforcement, higher-order): $(r=3, N_e=32, \\sigma=10^3)$ compute $\\rho$.\n- Case C (boundary enforcement, weak penalty edge case): $(r=2, N_e=32, \\sigma=50)$ compute $\\rho$.\n- Case D (dispersion error, low order): $(r=1, N_e=10)$ compute $\\epsilon$ for the smallest eigenvalue.\n- Case E (dispersion error, medium order): $(r=2, N_e=10)$ compute $\\epsilon$ for the smallest eigenvalue.\n- Case F (dispersion error, higher order): $(r=3, N_e=10)$ compute $\\epsilon$ for the smallest eigenvalue.\n\nFinal output format:\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets in the following order:\n$[\\rho_{A}, \\rho_{B}, \\rho_{C}, \\epsilon_{D}, \\epsilon_{E}, \\epsilon_{F}]$.\n\nNo input is provided at runtime; all parameters must be contained in the program. The program must be runnable as-is in any modern Python environment conforming to the specified execution environment.",
            "solution": "The problem addresses the numerical solution of the one-dimensional scalar Helmholtz equation on a domain $\\Omega = [0, L]$, given by\n$$ \\frac{d^2 p}{dx^2} + k^2 p = -s(x) $$\nwhere $p(x)$ is the acoustic pressure, $k$ is the wavenumber, and $s(x)$ is a source term. The boundary conditions are a pressure-release (sound-soft) Dirichlet condition at $x=0$, $p(0)=0$, and a rigid Neumann condition at $x=L$, $\\frac{dp}{dx}(L)=0$.\n\nThe finite element method (FEM) is predicated on the weak (variational) form of the governing partial differential equation. To derive the weak form, we multiply the equation by a test function $v(x)$ from a suitable function space and integrate over the domain $\\Omega$.\n\nFor the related Laplacian eigenvalue problem, $-\\frac{d^2 p}{dx^2} = \\lambda p$, the weak form is found by integrating by parts:\n$$ -\\int_0^L \\frac{d^2 p}{dx^2} v \\,dx = \\lambda \\int_0^L p v \\,dx $$\n$$ \\left[ -\\frac{dp}{dx} v \\right]_0^L + \\int_0^L \\frac{dp}{dx} \\frac{dv}{dx} \\,dx = \\lambda \\int_0^L p v \\,dx $$\nThe test function $v$ is chosen from the space of functions satisfying the homogeneous essential boundary condition, so $v(0)=0$. The Neumann condition $\\frac{dp}{dx}(L)=0$ makes the boundary term at $x=L$ vanish. The boundary term at $x=0$ also vanishes due to $v(0)=0$. This leads to the weak form provided in the problem: find $p$ such that for all valid $v$,\n$$ \\int_0^L \\frac{dp}{dx} \\frac{dv}{dx} \\,dx = \\lambda \\int_0^L p v \\,dx $$\nwhere $\\lambda = k^2$.\n\nSimilarly, for the forced Poisson problem, $-\\frac{d^2 u}{dx^2} = s(x)$, subject to the same boundary conditions, the weak form is: find $u$ such that for all valid $v$,\n$$ \\int_0^L \\frac{du}{dx} \\frac{dv}{dx} \\,dx = \\int_0^L s v \\,dx $$\nIn both cases, the Neumann condition at $x=L$ is a natural boundary condition, automatically satisfied by the weak formulation.\n\n### 2. Finite Element Discretization\nThe domain $[0, L]$ is discretized into $N_e$ elements of uniform length $h = L/N_e$. Within each element, the solution is approximated by a linear combination of Lagrange basis functions of polynomial degree $r$. The approximate solution $u_h(x)$ is written as:\n$$ u_h(x) = \\sum_{j=1}^{N_{dof}} u_j \\phi_j(x) $$\nwhere $u_j$ are the unknown nodal values (degrees of freedom) and $\\phi_j(x)$ are the global basis functions. These are constructed by piecing together local Lagrange polynomials defined on a reference element, typically $\\xi \\in [-1, 1]$. For a polynomial of degree $r$, there are $r+1$ nodes on the reference element. We use equidistant nodes at $\\xi_i = -1 + 2i/r$ for $i=0, 1, \\dots, r$. The $j$-th Lagrange basis polynomial $L_j(\\xi)$ has the property $L_j(\\xi_k) = \\delta_{jk}$, where $\\delta_{jk}$ is the Kronecker delta.\n\nSubstituting the finite element approximation for both the solution ($p_h$ or $u_h$) and the test function ($v_h$) into the weak forms transforms the integral equations into a system of linear algebraic equations. This results in the matrix forms $K u = \\lambda M u$ for the eigenvalue problem and $K u = f$ for the Poisson problem.\n\n### 3. Matrix Assembly\nThe global stiffness matrix $K$, mass matrix $M$, and load vector $f$ are assembled by summing contributions from each element. For a single element $e$ spanning $[x_e, x_{e+1}]$, the change of variables from the physical coordinate $x$ to the reference coordinate $\\xi$ is $x(\\xi) = x_e + \\frac{h}{2}(1+\\xi)$. The Jacobian of this transformation is $J = \\frac{dx}{d\\xi} = \\frac{h}{2}$. The derivative transforms as $\\frac{d}{dx} = \\frac{1}{J}\\frac{d}{d\\xi}$.\n\nThe element matrices and vector are calculated using numerical quadrature. Gauss-Legendre quadrature with $n_p = r+1$ points is used, which integrates polynomials of degree up to $2(r+1)-1 = 2r+1$ exactly, satisfying the requirement for degree $2r$.\n- **Element Stiffness Matrix $K_e$**:\n  $$ (K_e)_{ij} = \\int_{x_e}^{x_{e+1}} \\frac{d\\phi_i}{dx}\\frac{d\\phi_j}{dx}\\,dx = \\int_{-1}^1 \\left(\\frac{1}{J}\\frac{d\\phi_i}{d\\xi}\\right) \\left(\\frac{1}{J}\\frac{d\\phi_j}{d\\xi}\\right) J\\,d\\xi = \\frac{1}{J} \\sum_{k=1}^{n_p} w_k \\frac{d\\phi_i}{d\\xi}(\\xi_k) \\frac{d\\phi_j}{d\\xi}(\\xi_k) $$\n- **Element Mass Matrix $M_e$**:\n  $$ (M_e)_{ij} = \\int_{x_e}^{x_{e+1}} \\phi_i \\phi_j \\,dx = \\int_{-1}^1 \\phi_i(\\xi) \\phi_j(\\xi) J\\,d\\xi = J \\sum_{k=1}^{n_p} w_k \\phi_i(\\xi_k) \\phi_j(\\xi_k) $$\n- **Element Load Vector $f_e$**:\n  $$ (f_e)_i = \\int_{x_e}^{x_e+1} s(x)\\phi_i(x)\\,dx = \\int_{-1}^1 s(x(\\xi))\\phi_i(\\xi) J\\,d\\xi = J \\sum_{k=1}^{n_p} w_k s(x(\\xi_k)) \\phi_i(\\xi_k) $$\nHere, $w_k$ and $\\xi_k$ are the Gauss-Legendre weights and points. These element-level contributions are then mapped to their corresponding global degrees of freedom and summed to form the global system. The total number of degrees of freedom is $N_{dof} = N_e \\times r + 1$.\n\n### 4. Boundary Condition Enforcement and Solution\n\n**Eigenvalue Problem (Dispersion Error $\\epsilon$):**\nThe Dirichlet condition $p(0)=0$ is enforced strongly. Since the first degree of freedom, $u_0$, corresponds to the solution at $x=0$, this condition is imposed by removing the first row and first column from the global matrices $K$ and $M$. The resulting generalized eigenvalue problem is:\n$$ K_{\\text{mod}} u_{\\text{mod}} = \\lambda M_{\\text{mod}} u_{\\text{mod}} $$\nThis system is solved using a generalized eigensolver, such as `scipy.linalg.eigh`. The smallest resulting eigenvalue, $\\lambda_h$, is a numerical approximation of the fundamental eigenvalue of the continuous problem. The exact eigenvalue for the mixed boundary conditions on $[0, L]$ is $\\lambda_{\\text{exact}} = (\\frac{\\pi}{2L})^2$. The relative error $\\epsilon$ is then computed as:\n$$ \\epsilon = \\frac{|\\lambda_h - \\lambda_{\\text{exact}}|}{\\lambda_{\\text{exact}}} $$\n\n**Poisson Problem (Boundary Enforcement $\\rho$):**\nThe Dirichlet condition $u(0)=0$ is enforced weakly using the penalty method. This involves augmenting the bilinear form $\\int \\frac{du}{dx}\\frac{dv}{dx}dx$ with a term $\\alpha u(0) v(0)$, where $\\alpha = \\sigma/h$ is a large penalty parameter. In the matrix system, this corresponds to adding $\\alpha$ to the diagonal entry of the stiffness matrix associated with the degree of freedom at $x=0$. The modified system is:\n$$ (K + \\alpha B) u = f $$\nwhere $B$ is a matrix with a single non-zero entry, $B_{00}=1$. After solving this linear system for the coefficient vector $u_h$, the boundary mismatch ratio $\\rho$ is calculated. The value of the solution at the boundary is $u_h(0) = u_0$. The $L^2$-norm is $\\|u_h\\|_{L^2} = \\sqrt{u_h^\\top M u_h}$. The ratio is:\n$$ \\rho = \\frac{|u_h(0)|}{\\|u_h\\|_{L^2(0,L)}} = \\frac{|u_0|}{\\sqrt{u_h^\\top M u_h}} $$\nThis metric quantifies how well the Dirichlet condition is satisfied relative to the overall magnitude of the solution.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef get_lagrange_basis(r):\n    \"\"\"\n    Generates Lagrange basis polynomials and their derivatives of degree r\n    on the reference element [-1, 1] with equidistant nodes.\n    \n    This function uses Lagrange's formula for polynomial construction, which can be\n    more stable than inverting a Vandermonde matrix.\n    \n    Returns:\n        tuple: A list of np.poly1d objects for the basis functions and a list of\n               np.poly1d objects for their derivatives.\n    \"\"\"\n    nodes_ref = np.linspace(-1, 1, r + 1)\n    \n    basis_polys = []\n    for j in range(r + 1):\n        # Numerator is a polynomial that is zero at all nodes except nodes_ref[j]\n        num_poly = np.poly1d([1.0])\n        for k in range(r + 1):\n            if k == j:\n                continue\n            num_poly *= np.poly1d([1.0, -nodes_ref[k]])\n        \n        # Denominator is a normalizing constant\n        den_val = num_poly(nodes_ref[j])\n            \n        basis_polys.append(num_poly / den_val)\n        \n    basis_derivs = [np.polyder(p) for p in basis_polys]\n    \n    return basis_polys, basis_derivs\n\ndef assemble_matrices(r, Ne, L, basis_polys, basis_derivs):\n    \"\"\"\n    Assembles global stiffness (K) and mass (M) matrices for a 1D problem\n    on [0, L] with Ne elements of polynomial degree r.\n    \"\"\"\n    h = L / Ne\n    n_dof = r * Ne + 1\n    \n    K = np.zeros((n_dof, n_dof))\n    M = np.zeros((n_dof, n_dof))\n    \n    # Gauss-Legendre quadrature: n_gauss points integrates polynomials up to degree 2*n_gauss - 1.\n    # To integrate K (degree 2r-2) and M (degree 2r), we need 2*n_gauss - 1 >= 2r,\n    # so n_gauss >= (2r+1)/2. Choosing n_gauss = r + 1 is sufficient.\n    n_gauss = r + 1\n    gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_gauss)\n    \n    # Evaluate basis functions and derivatives at Gauss points on reference element\n    phi_vals = np.array([p(gauss_pts) for p in basis_polys])\n    dphi_dxi_vals = np.array([d(gauss_pts) for d in basis_derivs])\n    \n    # Calculate local (element) matrices on the reference element [-1, 1]\n    # Ke_ref_ij = integral(dphi_i/dxi * dphi_j/dxi dxi)\n    # Me_ref_ij = integral(phi_i * phi_j dxi)\n    Ke_ref = np.einsum('ik,jk,k->ij', dphi_dxi_vals, dphi_dxi_vals, gauss_wts)\n    Me_ref = np.einsum('ik,jk,k->ij', phi_vals, phi_vals, gauss_wts)\n    \n    # Jacobian of transformation: x(xi) = x_e + h/2 * (1 + xi) -> J = dx/dxi = h/2\n    J = h / 2.0\n    \n    # Scale reference matrices to physical element size\n    # Ke = (1/J) * Ke_ref, Me = J * Me_ref\n    Ke_elem = (1.0 / J) * Ke_ref\n    Me_elem = J * Me_ref\n    \n    # Assemble global matrices by looping over elements\n    for e in range(Ne):\n        # Global indices for DOFs in element e\n        indices = np.arange(e * r, e * r + r + 1)\n        ix = np.ix_(indices, indices)\n        K[ix] += Ke_elem\n        M[ix] += Me_elem\n        \n    return K, M\n\ndef compute_rho(r, Ne, sigma, L):\n    \"\"\"Computes the boundary mismatch ratio rho for the forced Poisson problem.\"\"\"\n    h = L / Ne\n    alpha = sigma / h\n    n_dof = r * Ne + 1\n    \n    basis_polys, basis_derivs = get_lagrange_basis(r)\n    K, M = assemble_matrices(r, Ne, L, basis_polys, basis_derivs)\n    \n    # Assemble load vector f\n    f = np.zeros(n_dof)\n    J = h / 2.0\n    \n    # Use quadrature order consistent with mass matrix for source term integration\n    n_gauss = r + 1\n    gauss_pts, gauss_wts = np.polynomial.legendre.leggauss(n_gauss)\n    phi_vals_at_gauss = np.array([p(gauss_pts) for p in basis_polys])\n\n    def source_func(x_phys):\n        return np.exp(-((x_phys - 0.7 * L) / (0.1 * L))**2)\n\n    for e in range(Ne):\n        x_e_start = e * h\n        x_phys_at_gauss = x_e_start + J * (1.0 + gauss_pts)\n        s_vals = source_func(x_phys_at_gauss)\n        \n        # fe_i = integral_e s(x) * phi_i(x) dx = J * integral(s(x(xi)) * phi_i(xi) dxi)\n        fe = J * np.einsum('ik,k,k->i', phi_vals_at_gauss, s_vals, gauss_wts)\n        \n        indices = np.arange(e * r, e * r + r + 1)\n        f[indices] += fe\n        \n    A = K.copy()\n    A[0, 0] += alpha\n    \n    u_h = linalg.solve(A, f)\n    \n    u_h_at_0 = u_h[0]\n    norm_L2_sq = u_h.T @ M @ u_h\n    \n    if norm_L2_sq <= 0:\n        return 0.0\n    \n    rho_val = np.abs(u_h_at_0) / np.sqrt(norm_L2_sq)\n    return rho_val\n\ndef compute_epsilon(r, Ne, L):\n    \"\"\"Computes the relative eigenvalue error epsilon for the fundamental mode.\"\"\"\n    basis_polys, basis_derivs = get_lagrange_basis(r)\n    K, M = assemble_matrices(r, Ne, L, basis_polys, basis_derivs)\n    \n    # Apply strong Dirichlet BC at x=0 by removing the first row and column\n    K_mod = K[1:, 1:]\n    M_mod = M[1:, 1:]\n    \n    # Solve the generalized eigenvalue problem. Use eigh for symmetric matrices.\n    eigenvalues = linalg.eigh(K_mod, M_mod, eigvals_only=True)\n    lambda_h = eigenvalues[0] # eigh returns sorted eigenvalues\n    \n    lambda_exact = (np.pi / (2 * L))**2\n    \n    epsilon_val = np.abs(lambda_h - lambda_exact) / lambda_exact\n    return epsilon_val\n\ndef solve():\n    \"\"\"Main solver function to run all test cases.\"\"\"\n    L = 1.0\n\n    test_cases = [\n        # type, r, Ne, sigma (for rho) or None (for epsilon)\n        ('rho', 1, 32, 1000.0),  # Case A\n        ('rho', 3, 32, 1000.0),  # Case B\n        ('rho', 2, 32, 50.0),    # Case C\n        ('epsilon', 1, 10, None),# Case D\n        ('epsilon', 2, 10, None),# Case E\n        ('epsilon', 3, 10, None),# Case F\n    ]\n\n    results = []\n    for case_type, r, Ne, sigma in test_cases:\n        if case_type == 'rho':\n            result = compute_rho(r=r, Ne=Ne, sigma=sigma, L=L)\n        elif case_type == 'epsilon':\n            result = compute_epsilon(r=r, Ne=Ne, L=L)\n        else:\n            raise ValueError(f\"Unknown case type: {case_type}\")\n        results.append(result)\n\n    print(f\"[{','.join(f'{res:.6e}' for res in results)}]\")\n\nsolve()\n```"
        }
    ]
}