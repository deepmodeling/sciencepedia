{
    "hands_on_practices": [
        {
            "introduction": "Before we can compute a Discrete Fourier Transform (DFT), we must first correctly acquire a discrete signal from a continuous, real-world phenomenon. This practice challenges you to think critically about the sampling process itself, moving beyond the simple Nyquist criterion. Starting from the fundamental principle of spectral replication, you will derive the precise condition on the sampling rate $f_s$ needed to ensure a target frequency band $[0, f_T]$ remains completely free of aliasing artifacts . This exercise builds a rigorous foundation, connecting the continuous-time world of acoustic signals to the discrete domain of computational analysis.",
            "id": "4140893",
            "problem": "An array microphone records a continuous-time acoustic pressure signal denoted by $p(t)$, with continuous-time Fourier transform $P_{c}(f)$. Prior to sampling, an ideal low-pass anti-aliasing filter is applied such that $P_{c}(f) = 0$ for all $f > B$, where $B$ is a known finite bandlimit satisfying $B > 0$. The filtered signal is then uniformly sampled at rate $f_{s}$, producing $p[n] = p(n/f_{s})$ for integers $n$. A length-$N$ discrete Fourier transform (DFT) is subsequently computed and evaluated via the fast Fourier transform (FFT) algorithm to obtain spectral estimates on the grid $f_{k} = k f_{s}/N$, for integers $k$.\n\nYou are tasked with ensuring that the magnitude of the DFT for frequencies in the interval $[0, f_{T}]$ is free from aliasing artifacts introduced by the sampling operation, where the target frequency $f_{T}$ satisfies $0  f_{T} \\le B$. Starting only from the sampling theorem and the corresponding frequency-domain replication property of uniform sampling, derive a condition that guarantees no spectral replicas introduced by sampling can fall into the frequency interval $[0, f_{T}]$. From this derivation, determine the minimum sampling rate, denoted $f_{s,\\min}$, that ensures alias-free DFT content up to $f_{T}$. \n\nAssume the time-windowing implicit in the finite-length DFT does not alter the aliasing condition (i.e., ignore leakage and window effects), and that the only source of spectral replication is the sampling process itself. Provide your final answer as a closed-form analytic expression for $f_{s,\\min}$ in terms of $f_{T}$ and $B$. Express your answer in $\\mathrm{Hz}$. No numerical approximation is required.",
            "solution": "The problem requires the derivation of the minimum sampling rate, $f_{s,\\min}$, that guarantees the frequency interval $[0, f_{T}]$ is free from aliasing artifacts. The derivation must originate from the fundamental principles of signal sampling.\n\nThe process of uniformly sampling a continuous-time signal $p(t)$ at a rate $f_{s}$ to produce a discrete sequence $p[n]$ has a well-defined effect in the frequency domain. The Fourier transform of the resulting discrete-time signal, known as the Discrete-Time Fourier Transform (DTFT), is a periodic summation of the original continuous-time signal's Fourier transform, $P_{c}(f)$. This relationship is given by the Poisson summation formula:\n$$\nP_{d}(f) = f_s \\sum_{m=-\\infty}^{\\infty} P_{c}(f - m f_{s})\n$$\nwhere $P_{d}(f)$ is the DTFT of the sequence $p[n]$, and $m$ is an integer index.\n\nThe term for $m=0$ is $f_s P_{c}(f)$, which is a scaled version of the original signal's spectrum. This is referred to as the baseband spectrum. According to the problem statement, an ideal anti-aliasing filter ensures that $P_{c}(f) = 0$ for all frequencies $f > B$. Since the acoustic pressure signal $p(t)$ is a real-valued physical quantity, its Fourier transform must exhibit conjugate symmetry, i.e., $P_{c}(f) = P_{c}^{*}(-f)$, which implies $|P_{c}(f)| = |P_{c}(-f)|$. Consequently, the condition $P_{c}(f) = 0$ for $f > B$ also implies that $P_{c}(f) = 0$ for $f  -B$. Therefore, the spectral support of the original signal is confined to the interval $[-B, B]$.\n\nThe terms in the summation for $m \\neq 0$ represent the spectral replicas, or aliases, created by the sampling process. The $m$-th replica, $f_s P_{c}(f - m f_{s})$, is a copy of the baseband spectrum shifted in frequency by an integer multiple of the sampling rate, $m f_{s}$. The spectral support of the $m$-th replica is the interval $[m f_{s} - B, m f_{s} + B]$.\n\nThe task is to ensure that the frequency interval of interest, $[0, f_{T}]$, contains contributions only from the baseband spectrum ($m=0$) and is free from any overlap with the spectral replicas ($m \\neq 0$). To achieve this, we must impose conditions on $f_{s}$ such that no replica's spectral support intersects with $[0, f_{T}]$. The replicas closest to the origin are the most critical, as they are the first to potentially cause aliasing in the low-frequency range. These correspond to $m=1$ and $m=-1$.\n\nLet us analyze the condition for each of these two replicas:\n\n1.  **Replica for $m = 1$:** This spectral replica is centered at $f = f_{s}$ and its support is the interval $[f_{s} - B, f_{s} + B]$. To prevent this replica from aliasing into the interval $[0, f_{T}]$, its lowest frequency component, $f_{s} - B$, must be greater than or equal to the highest frequency in the interval of interest, $f_{T}$. This gives the condition:\n    $$\n    f_{s} - B \\geq f_{T}\n    $$\n    which can be rewritten as:\n    $$\n    f_{s} \\geq B + f_{T}\n    $$\n\n2.  **Replica for $m = -1$:** This spectral replica is centered at $f = -f_{s}$ and its support is the interval $[-f_{s} - B, -f_{s} + B]$. To prevent this replica from aliasing into the interval $[0, f_{T}]$, its highest frequency component, $-f_{s} + B$, must be less than or equal to the lowest frequency in the interval of interest, which is $0$. This gives the condition:\n    $$\n    -f_{s} + B \\leq 0\n    $$\n    which can be rewritten as:\n    $$\n    f_{s} \\geq B\n    $$\n\nWe now have two conditions that must be simultaneously satisfied:\n$$\nf_{s} \\geq B + f_{T} \\quad \\text{and} \\quad f_{s} \\geq B\n$$\nThe problem statement specifies that $0  f_{T} \\leq B$. Since $f_{T}$ is strictly positive, the quantity $B + f_{T}$ is always strictly greater than $B$. Therefore, the condition $f_{s} \\geq B + f_{T}$ is more restrictive than $f_{s} \\geq B$. Any value of $f_{s}$ that satisfies $f_{s} \\geq B + f_{T}$ will automatically satisfy $f_{s} \\geq B$.\n\nThus, the single comprehensive condition to guarantee that the interval $[0, f_{T}]$ is free from aliasing artifacts from any replica is:\n$$\nf_{s} \\geq B + f_{T}\n$$\nThe problem asks for the minimum sampling rate, $f_{s,\\min}$, that satisfies this condition. The minimum value is achieved when equality holds:\n$$\nf_{s,\\min} = B + f_{T}\n$$\nThis expression represents the minimum sampling rate required to ensure that the DFT magnitude spectrum is free from aliasing in the frequency range $[0, f_{T}]$, under the stated ideal conditions.",
            "answer": "$$\\boxed{B + f_{T}}$$"
        },
        {
            "introduction": "The DFT provides a powerful but discretized view of a signal's spectrum. A crucial aspect of its practical use is understanding its inherent limitations, particularly when a signal's frequency does not align perfectly with the DFT's frequency bins. This exercise guides you through a first-principles derivation of this effect, known as spectral leakage, by analyzing a pure sinusoid viewed through a rectangular window . By calculating the worst-case amplitude reduction, or \"scalloping loss,\" you will gain a quantitative understanding of a fundamental trade-off in all forms of spectral analysis based on finite data records.",
            "id": "4140828",
            "problem": "An acoustic laboratory records a narrowband plane-wave pressure signal with sampling frequency sufficiently high to neglect aliasing. Over a finite observation of $N$ samples, the data are multiplied by a rectangular analysis window (equal to $1$ for $n=0,1,\\dots,N-1$ and $0$ otherwise), and the spectrum is computed via the Discrete Fourier Transform (DFT), implemented numerically by the Fast Fourier Transform (FFT). Consider the discrete-time complex sinusoid $x[n] = A \\exp\\!\\big(j 2 \\pi (k_{0}+\\delta) n / N\\big)$ captured by the sensor, where $A \\in \\mathbb{C}$ is the complex amplitude, $k_{0} \\in \\mathbb{Z}$ denotes an integer DFT bin index, and $\\delta \\in \\mathbb{R}$ is a fractional bin offset. Assume $|\\delta| \\le \\tfrac{1}{2}$ so that $k_{0}$ is the nearest bin.\n\nDefine the scalloping loss for a given window as the dimensionless amplitude ratio between the magnitude of the DFT at the nearest bin when the sinusoid’s frequency is at a half-bin offset ($\\delta = \\tfrac{1}{2}$) and the magnitude of the DFT at the bin center ($\\delta = 0$), both evaluated at bin $k_{0}$. Starting only from the DFT definition\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\!\\left(-j \\frac{2\\pi k n}{N}\\right),\n$$\nderive a closed-form analytic expression for the scalloping loss for the rectangular window as a function of $N$. Then determine its asymptotic value as $N \\to \\infty$. Express the final scalloping loss as a single exact, dimensionless number (no units). No rounding is required for the final reported value.",
            "solution": "The derivation begins with the definition of the DFT. The signal is a complex sinusoid $x[n] = A \\exp\\big(j 2 \\pi (k_{0}+\\delta) n / N\\big)$, captured over $N$ samples and multiplied by a rectangular window. This windowing means we only consider the signal for the discrete-time index $n$ from $0$ to $N-1$. The DFT, $X[k]$, is given by:\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi k n}{N}\\right)\n$$\nSubstituting the expression for $x[n]$:\n$$\nX[k] = \\sum_{n=0}^{N-1} A \\exp\\left(j \\frac{2\\pi (k_{0}+\\delta) n}{N}\\right) \\exp\\left(-j \\frac{2\\pi k n}{N}\\right)\n$$\nWe need to evaluate the spectrum at the nearest integer bin index, $k=k_0$.\n$$\nX[k_0] = \\sum_{n=0}^{N-1} A \\exp\\left(j \\frac{2\\pi (k_{0}+\\delta) n}{N}\\right) \\exp\\left(-j \\frac{2\\pi k_0 n}{N}\\right)\n$$\nCombining the exponents yields:\n$$\nX[k_0] = A \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (k_0 + \\delta - k_0) n}{N}\\right) = A \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi \\delta n}{N}\\right)\n$$\nThis is a geometric series of the form $\\sum_{n=0}^{N-1} r^n$ with common ratio $r = \\exp\\left(j \\frac{2\\pi \\delta}{N}\\right)$. Using the sum formula for a finite geometric series, $\\frac{1-r^N}{1-r}$, we get:\n$$\nX[k_0] = A \\frac{1 - \\left(\\exp\\left(j \\frac{2\\pi \\delta}{N}\\right)\\right)^N}{1 - \\exp\\left(j \\frac{2\\pi \\delta}{N}\\right)} = A \\frac{1 - \\exp(j 2\\pi \\delta)}{1 - \\exp\\left(j \\frac{2\\pi \\delta}{N}\\right)}\n$$\nTo find the magnitude $|X[k_0]|$, we use the identity $|1 - \\exp(j\\theta)| = | e^{j\\theta/2} (e^{-j\\theta/2} - e^{j\\theta/2}) | = |-2j e^{j\\theta/2} \\sin(\\frac{\\theta}{2})| = 2|\\sin(\\frac{\\theta}{2})|$. Applying this to the numerator and denominator:\n$$\n|X[k_0]| = |A| \\frac{\\left|2 \\sin\\left(\\frac{2\\pi\\delta}{2}\\right)\\right|}{\\left|2 \\sin\\left(\\frac{2\\pi\\delta}{2N}\\right)\\right|} = |A| \\frac{|\\sin(\\pi\\delta)|}{|\\sin(\\frac{\\pi\\delta}{N})|}\n$$\nThis is the general expression for the magnitude at bin $k_0$ as a function of the fractional bin offset $\\delta$.\n\nScalloping loss is defined as the ratio of the magnitude at $\\delta = \\frac{1}{2}$ to the magnitude at $\\delta=0$. We evaluate each case.\n\nCase 1: Bin-center frequency, $\\delta=0$.\nIn this case, the signal frequency aligns perfectly with a DFT bin. One could take the limit of the above expression as $\\delta \\to 0$, but it is more direct to return to the summation:\n$$\nX[k_0]|_{\\delta=0} = A \\sum_{n=0}^{N-1} \\exp\\left(j \\frac{2\\pi (0) n}{N}\\right) = A \\sum_{n=0}^{N-1} \\exp(0) = A \\sum_{n=0}^{N-1} 1 = AN\n$$\nThe magnitude is therefore:\n$$\n|X[k_0]|_{\\delta=0} = |A|N\n$$\n\nCase 2: Half-bin offset, $\\delta=\\frac{1}{2}$.\nThis represents the worst-case scenario for frequency mismatch. We substitute $\\delta=\\frac{1}{2}$ into the general magnitude expression. Given $|\\delta| \\leq \\frac{1}{2}$, this is the maximum offset.\n$$\n|X[k_0]|_{\\delta=1/2} = |A| \\frac{|\\sin(\\pi \\cdot \\frac{1}{2})|}{|\\sin(\\frac{\\pi \\cdot \\frac{1}{2}}{N})|} = |A| \\frac{|\\sin(\\frac{\\pi}{2})|}{|\\sin(\\frac{\\pi}{2N})|}\n$$\nSince $\\sin(\\frac{\\pi}{2}) = 1$ and for any $N \\geq 1$, $\\frac{\\pi}{2N} \\in (0, \\frac{\\pi}{2}]$, $\\sin(\\frac{\\pi}{2N})$ is positive. Thus, the absolute value bars can be removed.\n$$\n|X[k_0]|_{\\delta=1/2} = |A| \\frac{1}{\\sin(\\frac{\\pi}{2N})}\n$$\nThe scalloping loss, $S_L$, is the ratio of these two magnitudes:\n$$\nS_L(N) = \\frac{|X[k_0]|_{\\delta=1/2}}{|X[k_0]|_{\\delta=0}} = \\frac{|A| \\frac{1}{\\sin(\\frac{\\pi}{2N})}}{|A|N} = \\frac{1}{N \\sin(\\frac{\\pi}{2N})}\n$$\nThis is the closed-form expression for the scalloping loss for a rectangular window as a function of $N$.\n\nThe final step is to determine the asymptotic value as $N \\to \\infty$. We compute the limit:\n$$\nS_{L, \\infty} = \\lim_{N\\to\\infty} S_L(N) = \\lim_{N\\to\\infty} \\frac{1}{N \\sin(\\frac{\\pi}{2N})}\n$$\nAs $N \\to \\infty$, the argument of the sine function, $\\theta = \\frac{\\pi}{2N}$, approaches $0$. We use the fundamental trigonometric limit $\\lim_{\\theta\\to 0} \\frac{\\sin(\\theta)}{\\theta} = 1$. Let's rearrange our expression to use this limit.\n$$\nS_{L, \\infty} = \\lim_{N\\to\\infty} \\frac{1}{N \\sin(\\frac{\\pi}{2N})} = \\lim_{N\\to\\infty} \\frac{1}{N \\cdot \\frac{\\sin(\\pi/2N)}{\\pi/2N} \\cdot \\frac{\\pi}{2N}}\n$$\n$$\nS_{L, \\infty} = \\lim_{N\\to\\infty} \\frac{1}{\\frac{N\\pi}{2N} \\cdot \\frac{\\sin(\\pi/2N)}{\\pi/2N}} = \\lim_{N\\to\\infty} \\frac{1}{\\frac{\\pi}{2} \\cdot \\frac{\\sin(\\pi/2N)}{\\pi/2N}}\n$$\nSince $\\frac{\\pi}{2N} \\to 0$ as $N \\to \\infty$, the term $\\frac{\\sin(\\pi/2N)}{\\pi/2N}$ approaches $1$.\n$$\nS_{L, \\infty} = \\frac{1}{\\frac{\\pi}{2} \\cdot 1} = \\frac{2}{\\pi}\n$$\nThe asymptotic value of the scalloping loss for a rectangular window is $\\frac{2}{\\pi}$. This dimensionless value is approximately $0.6366$, which corresponds to a loss of about $3.92$ decibels.",
            "answer": "$$\n\\boxed{\\frac{2}{\\pi}}\n$$"
        },
        {
            "introduction": "Directly computing the DFT is an $O(N^2)$ operation, a complexity that is prohibitive for the large datasets common in computational acoustics and other scientific fields. This capstone practice moves from theory to implementation by having you build the revolutionary Fast Fourier Transform (FFT) algorithm from the ground up. You will implement the classic radix-2 decimation-in-time (DIT) version, translating its recursive structure, butterfly computations, and bit-reversal logic into working code . Completing this exercise provides an unshakeable, hands-on understanding of how this $O(N \\log N)$ algorithm achieves its remarkable and transformative efficiency.",
            "id": "4140841",
            "problem": "Consider the Discrete Fourier Transform (DFT) defined on a finite sequence as follows: for a sequence of complex-valued samples $\\{x[n]\\}_{n=0}^{N-1}$, the transform is given by $$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N},\\quad k=0,1,\\dots,N-1.$$ In computational acoustics, frequency-domain analysis of sampled acoustic pressure signals relies on efficiently evaluating this transform. Starting solely from the above definition, use a decimation-in-time approach to design an in-place algorithm that computes the DFT for lengths $N=2^m$, with input reordered into bit-reversed index order and output produced in natural order. Your design must:  \n- Explicitly specify the per-stage operations, including how partial results are combined via constant-coefficient multiplications and additions in each stage.  \n- Identify the index traversal order for each stage, the block size, and the rule for the constant factors used at each butterfly operation.  \n- State the exact count of nontrivial complex multiplications performed in each stage and the total across all stages. A nontrivial multiplication is defined as one where the complex constant differs from $1$.\n\nYou must implement the algorithm in a single program that performs the transform in-place on an array and produces natural-order output after initially reordering the input into bit-reversed order. The program must also verify numerical correctness by comparing the result to a baseline DFT evaluation and quantifying the discrepancy.\n\nUse the following test suite of sequences, all with $N=2^m$:\n- Test case A (boundary condition): $m=1$, $N=2$, $x[0]=1.0$, $x[1]=-1.0$. Treat the samples as acoustic pressure values measured in Pascals, but for the purposes of this numerical test, the output discrepancy has no physical unit.  \n- Test case B (structured nontrivial case): $m=2$, $N=4$, $x[n]$ is the discrete Kronecker sequence with $x[1]=1.0$ and $x[n]=0.0$ for $n\\neq 1$.  \n- Test case C (happy path and spectral localization): $m=3$, $N=8$, $x[n] = e^{i 2 \\pi \\cdot 3 \\cdot n / 8}$ for $n=0,1,\\dots,7$. Angles are in radians.\n\nFor each test case, your program must produce the following quantifiable results:\n- The maximum absolute discrepancy between your algorithm’s output and the reference DFT evaluation as a float (unitless).  \n- The total number of nontrivial complex multiplications counted across all stages as an integer.  \n- The per-stage nontrivial multiplication counts as integers for each stage in order from stage $0$ to stage $m-1$.\n\nFinal output format:\nYour program should produce a single line of output containing the results across the three test cases, as a comma-separated list enclosed in square brackets, where each element is itself a list structured as described above. For example, the format is $[[e_A,t_A,c_{A,0},\\dots],[e_B,t_B,c_{B,0},\\dots],[e_C,t_C,c_{C,0},\\dots]]$ where $e_\\cdot$ is the maximum absolute discrepancy (float), $t_\\cdot$ is the total nontrivial multiplication count (integer), and $c_{\\cdot,s}$ are the per-stage counts (integers).",
            "solution": "The design of the algorithm proceeds from the definition of the Discrete Fourier Transform (DFT). For a sequence $\\{x[n]\\}_{n=0}^{N-1}$, the DFT $\\{X[k]\\}_{k=0}^{N-1}$ is given by:\n$$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2 \\pi k n / N} = \\sum_{n=0}^{N-1} x[n] W_N^{kn}, \\quad k=0,1,\\dots,N-1$$\nwhere $W_N = e^{-i2\\pi/N}$ is the complex root of unity often referred to as the \"twiddle factor\". The problem requires an algorithm for lengths $N=2^m$, where $m$ is a positive integer.\n\nThe decimation-in-time approach partitions the input sequence $x[n]$ into even-indexed and odd-indexed subsequences. Let $n=2r$ for the even indices and $n=2r+1$ for the odd indices, where $r = 0, 1, \\dots, N/2-1$. The DFT sum can be split accordingly:\n$$X[k] = \\sum_{r=0}^{N/2-1} x[2r] W_N^{k(2r)} + \\sum_{r=0}^{N/2-1} x[2r+1] W_N^{k(2r+1)}$$\nUsing the property $W_N^{2kr} = (e^{-i2\\pi/N})^{2kr} = e^{-i2\\pi kr/(N/2)} = W_{N/2}^{kr}$, we can rewrite the expression:\n$$X[k] = \\sum_{r=0}^{N/2-1} x[2r] W_{N/2}^{kr} + W_N^k \\sum_{r=0}^{N/2-1} x[2r+1] W_{N/2}^{kr}$$\nLet $G[k]$ be the $N/2$-point DFT of the even-indexed part of $x[n]$, and $H[k]$ be the $N/2$-point DFT of the odd-indexed part:\n$$G[k] = \\sum_{r=0}^{N/2-1} x[2r] W_{N/2}^{kr}$$\n$$H[k] = \\sum_{r=0}^{N/2-1} x[2r+1] W_{N/2}^{kr}$$\nThe $N$-point DFT can then be expressed as:\n$$X[k] = G[k] + W_N^k H[k]$$\nThis formula holds for $k=0, 1, \\dots, N-1$. However, $G[k]$ and $H[k]$ are $N/2$-point DFTs and are therefore periodic with period $N/2$, i.e., $G[k+N/2] = G[k]$ and $H[k+N/2] = H[k]$. For the twiddle factor, we use the property $W_N^{k+N/2} = W_N^k W_N^{N/2} = W_N^k e^{-i\\pi} = -W_N^k$.\n\nThis allows us to compute the second half of the output spectrum ($k = N/2, \\dots, N-1$) using the same intermediate results. For an index $k' = k - N/2$ in the range $0, 1, \\dots, N/2-1$:\n$$X[k'+N/2] = G[k'+N/2] + W_N^{k'+N/2} H[k'+N/2] = G[k'] - W_N^{k'} H[k']$$\nCombining these two results for an index $k \\in \\{0, 1, \\dots, N/2-1\\}$ gives the fundamental \"butterfly\" computation:\n$$X[k] = G[k] + W_N^k H[k]$$\n$$X[k+N/2] = G[k] - W_N^k H[k]$$\nThis decomposition is recursive. An $N$-point DFT is computed from two $N/2$-point DFTs, which are in turn computed from four $N/4$-point DFTs, and so on, until we reach $1$-point DFTs. The $1$-point DFT of a sample $x[n]$ is simply $x[n]$ itself.\n\nFor an iterative, in-place algorithm, this recursive decomposition implies a specific ordering of the initial data. The first split separates even and odd indices. The second split separates based on even/odd indices within those halves, which corresponds to the second-to-last bit of the original index. Continuing this process for all $m = \\log_2 N$ levels of recursion shows that an input sample $x[n]$ must be placed at the index whose binary representation is the bit-reversal of the binary representation of $n$.\n\nThe algorithm proceeds as follows:\n1.  **Input Reordering**: The input array $x$ of length $N=2^m$ is reordered in-place according to the bit-reversal permutation of its indices.\n2.  **Iterative Butterfly Stages**: The algorithm performs $m=\\log_2 N$ stages of computation. Let the stages be indexed by $s=0, 1, \\dots, m-1$.\n    -   **Stage $s$**: This stage combines pairs of DFTs of size $L=2^s$ to form DFTs of size $2L=2^{s+1}$. The array is processed in blocks of size $2L$.\n    -   **Index Traversal**: The algorithm iterates through the data with the following structure:\n        -   Outer loop (stages): for $s = 0, \\dots, m-1$.\n        -   Let $L = 2^s$. The size of the sub-DFTs being combined is $L$.\n        -   Let $M = 2L = 2^{s+1}$. This is the size of the DFT being formed and the block size for this stage.\n        -   Middle loop (blocks): for $j = 0, 2L, 4L, \\dots, N-2L$. This loop iterates over the starting index of each block.\n        -   Inner loop (butterflies): for $k=0, 1, \\dots, L-1$. This loop iterates through the butterflies within a block.\n    -   **Per-Stage Operation**: For each $(s, j, k)$, a butterfly operation is performed on a pair of elements.\n        -   The indices of the two elements are `idx1 = j + k` and `idx2 = j + k + L`.\n        -   The twiddle factor is $W = W_M^k = e^{-i2\\pi k/M} = e^{-i\\pi k/L}$.\n        -   The butterfly computation, which updates the array in-place, is:\n            1.  `temp = W * x[idx2]`\n            2.  `x[idx2] = x[idx1] - temp`\n            3.  `x[idx1] = x[idx1] + temp`\nAfter $m$ stages, the array $x$ will contain the DFT output $X[k]$ in natural (sequential) order.\n\n**Nontrivial Complex Multiplication Count**:\nA multiplication is defined as nontrivial if the complex constant factor is not equal to $1+0i$.\nIn stage $s$, the twiddle factor is $W = e^{-i\\pi k/L}$, where $L=2^s$ and $k=0, 1, \\dots, L-1$.\nThe multiplication is trivial ($W=1$) only when the exponent is a multiple of $2\\pi$. Since $- \\pi k / L$ is the phase, this occurs only when $k=0$.\n-   **Total Butterflies per Stage**: For any stage $s$, there are $N/2$ butterfly computations in total. Each requires one complex multiplication.\n-   **Trivial Multiplications per Stage**: In stage $s$, the butterflies are grouped into $N/(2L) = N/2^{s+1}$ blocks. Within each block, the inner loop runs for $k=0, \\dots, L-1$. The multiplication is trivial only for $k=0$. Thus, there is exactly one trivial multiplication per block. The total number of trivial multiplications in stage $s$ is equal to the number of blocks, which is $N/2^{s+1}$.\n-   **Nontrivial Multiplications per Stage ($c_s$)**: The number of nontrivial multiplications in stage $s$ is the total minus the trivial ones:\n    $$c_s = \\frac{N}{2} - \\frac{N}{2^{s+1}}, \\quad s=0, 1, \\dots, m-1$$\n-   **Total Nontrivial Multiplications ($t$)**: The total count is the sum over all stages:\n    $$t = \\sum_{s=0}^{m-1} c_s = \\sum_{s=0}^{m-1} \\left( \\frac{N}{2} - \\frac{N}{2^{s+1}} \\right) = m \\frac{N}{2} - N \\sum_{s=0}^{m-1} \\left(\\frac{1}{2}\\right)^{s+1}$$\n    The geometric series sums to $\\sum_{j=1}^{m} (1/2)^j = 1 - (1/2)^m = 1-1/N$.\n    $$t = \\frac{N}{2} \\log_2(N) - N \\left(1 - \\frac{1}{N}\\right) = \\frac{N}{2} \\log_2(N) - (N-1)$$",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and testing a decimation-in-time FFT.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: m=1, N=2, x=[1.0, -1.0]\n        (1, np.array([1.0, -1.0], dtype=np.complex128)),\n        # Case B: m=2, N=4, x=[0.0, 1.0, 0.0, 0.0]\n        (2, np.array([0.0, 1.0, 0.0, 0.0], dtype=np.complex128)),\n        # Case C: m=3, N=8, x[n] = exp(i*2*pi*3*n/8)\n        (3, np.array([np.exp(1j * 2 * np.pi * 3 * n / 8) for n in range(8)], dtype=np.complex128)),\n    ]\n\n    results = []\n    for m, x_orig in test_cases:\n        N = 1  m\n        \n        # --- 1. Run the custom in-place FFT ---\n        x_fft = x_orig.copy()\n        dit_fft_inplace(x_fft)\n\n        # --- 2. Run the reference DFT ---\n        x_ref = dft_reference(x_orig)\n        \n        # --- 3. Calculate max absolute discrepancy ---\n        discrepancy = float(np.max(np.abs(x_fft - x_ref)))\n\n        # --- 4. Calculate nontrivial multiplication counts ---\n        stage_counts = []\n        for s in range(m):\n            # Nontrivial multiplications in stage s: N/2 - N/(2^(s+1))\n            count = (N // 2) - (N // (1  (s + 1)))\n            stage_counts.append(int(count))\n        \n        total_count = int(sum(stage_counts))\n\n        # --- 5. Assemble results for this test case ---\n        case_result = [discrepancy, total_count] + stage_counts\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # Custom formatting to match the required output style for list of lists\n    formatted_results = [\n        f\"[{res[0]},{','.join(map(str, res[1:]))}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef dft_reference(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the DFT of a sequence using the direct definition.\n    \"\"\"\n    N = len(x)\n    X = np.zeros(N, dtype=np.complex128)\n    for k in range(N):\n        for n in range(N):\n            X[k] += x[n] * np.exp(-2j * np.pi * k * n / N)\n    return X\n\ndef dit_fft_inplace(x: np.ndarray):\n    \"\"\"\n    Computes the DFT in-place using the decimation-in-time radix-2 FFT algorithm.\n    The input array 'x' is modified directly.\n    \"\"\"\n    N = len(x)\n    if N = 1:\n        return\n    \n    m = int(np.log2(N))\n\n    # --- 1. Bit-reversal permutation ---\n    # Calculates the bit-reversed index for each index and swaps elements.\n    for i in range(N):\n        j = 0\n        temp_i = i\n        for _ in range(m):\n            j = 1\n            j |= (temp_i  1)\n            temp_i >>= 1\n        \n        # Swap only if the new index is greater to avoid double swaps\n        if j > i:\n            x[i], x[j] = x[j], x[i]\n\n    # --- 2. Butterfly computation stages ---\n    # m = log2(N) stages\n    for s in range(m):\n        L = 1  s          # Size of sub-DFTs being combined (2^s)\n        block_size = 1  (s + 1) # Size of DFTs being formed, and block size (2*L)\n        \n        # Iterate over blocks\n        for j in range(0, N, block_size):\n            # Iterate over butterflies within a block\n            for k in range(L):\n                twiddle = np.exp(-1j * np.pi * k / L)\n                \n                idx1 = j + k\n                idx2 = j + k + L\n                \n                temp = twiddle * x[idx2]\n                x[idx2] = x[idx1] - temp\n                x[idx1] = x[idx1] + temp\n\nsolve()\n```"
        }
    ]
}