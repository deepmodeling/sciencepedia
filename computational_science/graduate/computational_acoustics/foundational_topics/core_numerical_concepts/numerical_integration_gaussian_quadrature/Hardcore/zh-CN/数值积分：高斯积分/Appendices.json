{
    "hands_on_practices": [
        {
            "introduction": "我们从一个实际的练习开始，亲身体验高斯-勒让德求积法的威力。这个练习将使用标准的数值库来获取求积节点和权重，使我们能专注于应用该法则，并观察其对光滑函数的高精度、对特定阶次多项式的精确性，以及在处理不同类型函数时的表现。通过这个练习，你将对高斯求积法的基本特性和适用范围有一个直观的认识。",
            "id": "4133056",
            "problem": "考虑使用高斯求积法在区间 $[-1,1]$ 上近似计算定积分的任务，这是一族通过在精心选择的节点上评估被积函数并赋予相应权重，从而能够精确积分特定次数以下多项式的公式。在计算声学中，此类积分出现在角度平均、辐射积分和平面波展开中，其中变量通常表示映射到 $[-1,1]$ 上的方向余弦。高斯-勒让德法则是专门针对 $[-1,1]$ 上单位权重函数 $w(x)=1$ 的高斯求积法。基于勒让德多项式在单位权重下于 $[-1,1]$ 上正交，以及一个具有 $n$ 个节点的高斯求积法可以被构造成对所有次数最高为 $2n-1$ 的多项式都精确这两个基本事实，设计并实现一个算法，该算法使用高斯-勒让德节点和权重来近似计算 $[-1,1]$ 上光滑函数的积分。\n\n你的程序必须实现一个针对给定节点数 $n$ 的高斯-勒让德法则，并用它来评估积分近似值\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\n其中 $(x_i,w_i)$ 是所选 $n$ 对应的高斯-勒让德节点和权重。对于每个测试用例，通过将求积值与积分的解析值进行比较来计算绝对误差。\n\n你必须使用以下测试套件，它考察了正确性、多项式次数边界上的精确性、区间的对称性，以及在与声学问题相关的振荡被积函数上的行为：\n\n- 用例 A（理想路径）：$n=6$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。输出求积近似值和绝对误差。\n- 用例 B（次数边界与对称性）：$n=6$， $f(x)=x^{11}$。这是一个对称区间上的奇函数多项式。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。仅输出绝对误差。\n- 用例 C（超出精确次数）：$n=6$， $f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。仅输出绝对误差。\n- 用例 D（关于 $n$ 的边界条件）：$n=1$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。仅输出绝对误差。\n- 用例 E（受声学启发的振荡函数测试）：$n=6$，$f(x)=\\cos(50 x)$。角度必须以弧度处理。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。仅输出绝对误差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序和数据类型如下：\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\n其中每个条目都是一个浮点数。不涉及物理单位，且在用例 E 中，余弦函数的角度必须以弧度处理。",
            "solution": "该问题是有效的。它在科学上基于数值积分的既定数学理论，特别是高斯-勒让德求积法。问题提法很明确，提供了计算出唯一数值结果所需的所有必要信息、函数和参数。该问题是客观的，并使用了标准的、无歧义的术语。因此，我们可以着手求解。\n\n核心任务是使用高斯-勒让德求积法则来近似计算函数 $f(x)$ 在对称区间 $[-1, 1]$ 上的定积分。该方法属于高斯求积法族，其设计目的是在给定函数求值次数的情况下，获得尽可能高的精度。一个 $n$ 点高斯求积法的一般形式是：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n此处，$w(x)$ 是一个非负权重函数，$[a, b]$ 是积分区间，$x_i$ 是 $n$ 个求积节点（或点），而 $w_i$ 是对应的 $n$ 个求积权重。\n\n对于高斯-勒让德求积法的具体情况，积分区间是 $[-1, 1]$，权重函数为 1，即 $w(x) = 1$。公式简化为：\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n该方法的卓越特性源于其对节点和权重的特殊选择。$n$ 个节点 $x_i$ 被选为 $n$ 次勒让德多项式 $P_n(x)$ 的根。勒让德多项式在区间 $[-1, 1]$ 上相对于权重函数 $w(x)=1$ 构成了一个正交多项式序列。通过如此选择节点，可以确定权重 $w_i$，使得该求积公式对所有次数最高为 $2n-1$（含）的多项式都精确。这种精度是其他常见法则（如牛顿-柯特斯公式，例如梯形法则、辛普森法则）的两倍，后者对于一个 $n$ 点法则，仅对次数最高为 $n-1$ 或 $n$ 的多项式精确。\n\n对每个测试用例求解该问题的算法如下：\n1. 对于给定的节点数 $n$，获取高斯-勒让德节点集 $\\{x_i\\}_{i=1}^n$ 和权重集 $\\{w_i\\}_{i=1}^n$。这些是预先计算好的值，可以按规定使用标准数值库（如 `scipy.special.roots_legendre`）来获取。\n2. 根据测试用例的规定，定义被积函数 $f(x)$。\n3. 在每个节点 $x_i$ 上计算函数 $f(x)$ 的值，得到 $f(x_i)$。\n4. 通过计算加权和来计算积分的求积近似值：$I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$。\n5. 计算绝对误差 $E_{abs} = |I_{approx} - I_{analytic}|$，其中 $I_{analytic}$ 是所提供的积分精确值。\n\n我们现在将此算法应用于每个指定的测试用例。\n\n- **用例 A**：$n=6$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。由于 $f(x)=e^x$ 是一个超越函数，而非多项式，高斯-勒让德法则不会是精确的。然而，由于 $e^x$ 是光滑的，并且在 $[-1, 1]$ 上能被其泰勒级数很好地近似，因此 6 点法则预期会提供高精度。\n\n- **用例 B**：$n=6$，$f(x)=x^{11}$。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。被积函数是一个 11 次多项式。对于 $n=6$，高斯-勒让德法则对所有次数最高为 $2n-1 = 2(6)-1 = 11$ 的多项式都是精确的。因此，求积必须得出精确结果。计算出的近似值应为 0，并且绝对误差预期为数值上为零（即，达到机器精度水平）。\n\n- **用例 C**：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。被积函数是一个 12 次多项式。该次数大于精确次数 $2n-1=11$。因此，该求积法则对此函数不再精确，我们预计会有一个非零但很小的近似误差。\n\n- **用例 D**：$n=1$，$f(x)=e^x$。解析值为 $e - e^{-1}$。对于 $n=1$，精确次数为 $2(1)-1=1$。单个节点是 $P_1(x)=x$ 的根，即 $x_1=0$。权重为 $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$。近似值就是 $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$。我们预期误差会比使用更精确的 6 点法则的用例 A 大得多。\n\n- **用例 E**：$n=6$，$f(x)=\\cos(50x)$。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。这个被积函数在区间 $[-1, 1]$ 上是高度振荡的。高斯求积法的效率依赖于函数能被低次多项式很好地近似。像 $\\cos(50x)$ 这样的函数需要一个非常高次的多项式才能得到良好近似，因此 6 点法则不足以捕捉其行为。我们预计会产生较大的近似误差，这说明了低阶求积法对此类函数的局限性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在了解了如何应用高斯求积之后，我们现在将深入探索其构造原理。本练习将指导你实现优雅的Golub-Welsch算法，该算法将高斯求积问题与一个对称三对角矩阵（雅可比矩阵）的特征值问题联系起来。通过从零开始构建求积法则并对照解析公式进行验证，你将对高斯求积的理论基础及其数值实现的细节有更深刻的理解。",
            "id": "4133076",
            "problem": "在计算声学中，对角度或方向变量进行精确的数值积分对于高频波建模和边界积分公式至关重要。一个核心工具是使用勒让德权重的高斯求积，它通过在特殊选择的节点上进行加权求和来近似区间 $[-1,1]$ 上的积分。本问题要求您使用 Golub–Welsch 算法，从勒让德多项式的基本正交性和三项递推性质出发，推导、实现并验证勒让德-高斯节点和权重的构造过程。您不得使用任何预先计算的节点或权重，也不得使用直接返回它们的专用函数。\n\n您的任务是：\n\n1) 构造与区间 $[-1,1]$ 上的勒让德权重 $w(x) = 1$ 相关联的 $n \\times n$ 对称三对角雅可比矩阵，仅使用标准正交多项式的三项递推作为基本依据。通过求解该雅可比矩阵的特征值问题来获得勒让德-高斯节点，并从相应的归一化特征向量的第一个分量中获得权重。使用 $n = 10$。\n\n2) 基于勒让德多项式的正交性以及 $n$ 次勒让德多项式导数的性质，推导勒让德-高斯权重的解析表达式，并使用它在第 1 部分得到的节点上计算第二组权重。请勿直接使用问题陈述中的任何公式；在代码中实现您的推导。\n\n3) 通过计算并报告以下量来验证您实现的正确性和准确性：\n   - 由 Golub–Welsch 特征向量公式计算的权重与从勒让德多项式性质推导的解析表达式计算的权重之间的最大相对差异。报告一个浮点数。\n   - 权重之和与权重函数在 $[-1,1]$ 上的精确积分（即 $2$）相比的绝对误差。报告一个浮点数。\n   - 在对单项式 $x^k$ 进行积分时（其中 $k$ 为从 $0$ 到 $2n-1$ 的所有整数），求积和与精确积分 $\\int_{-1}^{1} x^k \\, dx$（对于奇数 $k$ 等于 $0$，对于偶数 $k$ 等于 $2/(k+1)$）相比的最大绝对求积误差。报告一个浮点数。\n\n4) 为了与声学中的一个典型振荡积分联系起来，考虑积分\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx = \\frac{2 \\sin(\\alpha)}{\\alpha} \\quad \\text{对于 } \\alpha \\neq 0, \\quad I(0) = 2,\n$$\n其中 $\\alpha$ 以弧度为单位。使用第 1 部分中 $n=10$ 的节点和权重，对一组参数 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$（均以弧度为单位）近似计算 $I(\\alpha)$，并按给定顺序报告这些 $\\alpha$ 值对应的绝对误差 $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$ 的列表。\n\n重要的实现和输出要求：\n\n- 仅使用勒让德多项式的三项递推结构来构建雅可比矩阵，并使用特征值问题来获取节点和权重。问题禁止使用任何直接返回高斯节点或权重的快捷例程。\n- 角度必须以弧度为单位进行解释。\n- 所有输出必须是无量纲的实数。\n- 测试套件：使用 $n=10$ 和 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$。\n- 最终输出格式：您的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须采用以下形式：\n$\n[\\text{max\\_relative\\_weight\\_difference}, \\text{weight\\_sum\\_error}, \\text{max\\_moment\\_error}, [e_{\\alpha=0}, e_{\\alpha=0.1}, e_{\\alpha=1}, e_{\\alpha=10}, e_{\\alpha=50}]]\n$\n其中每个元素都是一个浮点数。例如，输出可能如下所示：\n$\n[1e-15,0.0,2.22e-16,[0.0,1e-15,1e-12,1e-6,1e-4]]。\n$ \n您的程序必须严格按照此格式打印一行，且不得读取任何输入。",
            "solution": "本问题要求使用 Golub–Welsch 算法，为 $n=10$ 个点构造、实现并验证勒让德-高斯求积法则。该算法在高斯求积与被称为雅可比矩阵的对称三对角矩阵的谱理论之间建立了深刻的联系。我们将首先根据标准正交勒让德多项式的三项递推关系构造雅可比矩阵。然后，我们将求解相应的特征值问题，以找到求积节点和权重。这些结果将与权重的解析公式进行比较验证，并通过测试求积方法对多项式的精确性来加以验证。最后，我们将此求积法则应用于声学中一个具有代表性的振荡积分。\n\n**步骤 1：构造雅可比矩阵（Golub–Welsch 算法）**\n\n高斯求积通过加权和 $\\sum_{j=1}^{n} w_j f(x_j)$ 来近似形式为 $\\int_a^b f(x) w(x) \\, dx$ 的积分。选择节点 $\\{x_j\\}$ 和权重 $\\{w_j\\}$ 以使此近似对所有次数最高为 $2n-1$ 的多项式都精确。对于在 $[a, b]$ 上关于权重函数 $w(x)$ 标准正交的多项式族 $\\{\\phi_k(x)\\}$，它们满足一个三项递推关系：\n$$\nx \\phi_k(x) = \\beta_k \\phi_{k-1}(x) + \\alpha_k \\phi_k(x) + \\beta_{k+1} \\phi_{k+1}(x)\n$$\n这些系数 $\\alpha_k$ 和 $\\beta_k$ 构成一个 $n \\times n$ 的对称三对角矩阵，即雅可比矩阵 $J_n$：\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0  \\beta_1  0  \\cdots  0 \\\\\n\\beta_1  \\alpha_1  \\beta_2  \\ddots  \\vdots \\\\\n0  \\beta_2  \\alpha_2  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\beta_{n-1} \\\\\n0  \\cdots  0  \\beta_{n-1}  \\alpha_{n-1}\n\\end{pmatrix}\n$$\nGolub–Welsch 算法指出，$n$ 个求积节点 $\\{x_j\\}$ 是该矩阵 $J_n$ 的特征值。相应的权重 $\\{w_j\\}$ 由归一化特征向量的第一个分量导出。具体来说，如果 $v_j$ 是对应于特征值 $x_j$ 的归一化特征向量，则权重为 $w_j = \\mu_0 (v_{j,0})^2$，其中 $v_{j,0}$ 是 $v_j$ 的第一个分量，而 $\\mu_0 = \\int_a^b w(x) \\, dx$。\n\n对于本问题，我们使用区间 $[-1, 1]$ 上的勒让德权重函数 $w(x) = 1$。\n权重函数的积分为 $\\mu_0 = \\int_{-1}^1 1 \\, dx = 2$。\n标准的勒让德多项式 $P_k(x)$ 是正交的但非标准正交。标准正交多项式是 $\\phi_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$。\n递推系数由 $\\alpha_k = \\int_{-1}^1 x (\\phi_k(x))^2 \\, dx$ 和 $\\beta_k = \\int_{-1}^1 x \\phi_k(x) \\phi_{k-1}(x) \\, dx$ 给出。\n由于区间 $[-1, 1]$ 和权重函数 $w(x)=1$ 的对称性，$\\alpha_k$ 的被积函数是奇函数，因此对于所有 $k$，$\\alpha_k = 0$。\n非对角项 $\\beta_k$ 可以从 $P_k(x)$ 的标准递推关系中导出：\n$$\n(k+1)P_{k+1}(x) = (2k+1)xP_k(x) - kP_{k-1}(x)\n$$\n对 $x P_k(x)$ 进行整理并代入 $\\phi_k(x)$ 的关系，我们找到标准正交多项式的递推关系，从而得到系数：\n$$\n\\beta_k = \\frac{k}{\\sqrt{(2k-1)(2k+1)}} = \\frac{k}{\\sqrt{4k^2 - 1}} \\quad \\text{对于 } k=1, \\dots, n-1\n$$\n对于 $n=10$，我们构造一个 $10 \\times 10$ 的矩阵 $J_{10}$，其对角线元素为零，次对角线和主对角线上方元素为 $k=1, \\dots, 9$ 的 $\\beta_k$ 值。求解特征值问题 $J_{10} V = V \\Lambda$（其中 $\\Lambda$ 是特征值（节点）的对角矩阵，V 是特征向量矩阵），即可得到节点和权重。\n\n**步骤 2：权重的解析公式**\n\n为了验证，我们使用另一种方法计算权重。勒让德-高斯求积的权重由以下公式给出：\n$$\nw_j = \\frac{2}{(1 - x_j^2) [P_n'(x_j)]^2}\n$$\n其中 $P_n'(x_j)$ 是 $n$ 次勒让德多项式在节点 $x_j$ 处的导数。要实现这一点，我们需要 $P_n'(x_j)$ 的表达式。勒让德多项式满足微分关系：\n$$\n(1 - x^2)P_n'(x) = nP_{n-1}(x) - nxP_n(x)\n$$\n在节点 $x_j$（即 $P_n(x)$ 的根）处，我们有 $P_n(x_j) = 0$。该关系简化为：\n$$\n(1 - x_j^2)P_n'(x_j) = nP_{n-1}(x_j)\n$$\n将此代入权重公式，得到一个更稳定的表达式，它避免了直接计算导数以及在 $1 - x_j^2$ 很小时可能出现的除零问题：\n$$\nw_j = \\frac{2(1 - x_j^2)}{n^2 [P_{n-1}(x_j)]^2}\n$$\n要使用此公式，我们首先通过 Golub-Welsch 方法找到节点 $x_j$，然后在这些节点上计算 $P_{n-1}(x)$。多项式 $P_{n-1}(x_j)$ 是使用其标准的三项递推关系从头开始实现的。\n\n**步骤 3：验证方案**\n\n我们执行三个定量检查来验证我们的实现：\n1.  **最大相对权重差异**：我们使用 Golub-Welsch 方法（$w_j^{\\text{GW}}$）和解析公式（$w_j^{\\text{analytic}}$）两种方法计算权重。计算最大相对差异 $\\max_j \\left| \\frac{w_j^{\\text{GW}} - w_j^{\\text{analytic}}}{w_j^{\\text{analytic}}} \\right|$。这个值应该在机器精度的量级。\n2.  **权重和误差**：权重之和必须等于权重函数的积分，即 $\\sum_{j=1}^n w_j = \\int_{-1}^1 1 \\, dx = 2$。我们报告绝对误差 $|\\sum_{j=1}^n w_j - 2|$。\n3.  **最大矩误差**：一个 $n$ 点高斯求积法则对所有次数最高为 $2n-1$ 的多项式都是精确的。我们通过对单项式 $x^k$（$k=0, 1, \\dots, 2n-1$）进行积分来测试这一点。精确积分为 $I_k = \\int_{-1}^1 x^k \\, dx$，对于偶数 $k$ 等于 $2/(k+1)$，对于奇数 $k$ 等于 $0$。我们计算在此 $k$ 范围内最大的绝对误差 $| \\sum_{j=1}^n w_j x_j^k - I_k |$。\n\n**步骤 4：应用于振荡积分**\n\n我们将开发的 $n=10$ 求积法则应用于近似计算振荡积分：\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx\n$$\n对于 $\\alpha \\neq 0$，精确解为 $I(\\alpha) = \\frac{2\\sin(\\alpha)}{\\alpha}$，对于 $\\alpha = 0$，精确解为 $I(0) = 2$。数值近似由 $I_{\\text{quad}}(\\alpha) = \\sum_{j=1}^{10} w_j e^{i \\alpha x_j}$ 给出。我们计算 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$ 时 的绝对误差 $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$。这个测试展示了该求积方法对于一个非多项式、振荡函数的性能，该函数是声学中波动现象的特征。随着频率参数 $\\alpha$ 的增加，被积函数振荡得更快，对于固定数量的求积点，近似误差预计会增大。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_poly_eval(k, x):\n    \"\"\"\n    Evaluates the Legendre polynomial P_k(x) at point(s) x using the\n    three-term recurrence relation.\n    \"\"\"\n    x = np.asarray(x)\n    if k == 0:\n        return np.ones_like(x)\n    if k == 1:\n        return x\n    \n    p_k_minus_2 = np.ones_like(x)\n    p_k_minus_1 = x\n    for i in range(2, k + 1):\n        p_k = ((2 * i - 1) * x * p_k_minus_1 - (i - 1) * p_k_minus_2) / i\n        p_k_minus_2 = p_k_minus_1\n        p_k_minus_1 = p_k\n    return p_k_minus_1\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates Legendre-Gauss quadrature.\n    \"\"\"\n    n = 10\n    alpha_values = [0.0, 0.1, 1.0, 10.0, 50.0]\n\n    # --- Part 1: Golub-Welsch Algorithm ---\n    # Construct the n x n symmetric tridiagonal Jacobi matrix.\n    # Diagonal elements (alpha_k) are 0.\n    # Off-diagonal elements (beta_k) are k / sqrt(4k^2 - 1).\n    J = np.zeros((n, n))\n    for k in range(1, n):\n        beta_k = k / np.sqrt(4 * k**2 - 1)\n        J[k, k-1] = beta_k\n        J[k-1, k] = beta_k\n        \n    # Solve the eigenvalue problem for the Jacobi matrix.\n    # Eigenvalues are the nodes, eigenvectors are used for weights.\n    # np.linalg.eigh is used for symmetric matrices and returns sorted eigenvalues.\n    nodes, eigenvectors = np.linalg.eigh(J)\n    \n    # Calculate weights from the first component of the normalized eigenvectors.\n    # w_j = mu_0 * (v_{j,0})^2, where mu_0 = integral of w(x)=1 from -1 to 1, which is 2.\n    # eigenvectors are stored as columns. eigenvectors[0,:] gives the first row.\n    weights_gw = 2.0 * (eigenvectors[0, :])**2\n    \n    # The nodes from eigh are already sorted, and weights correspond to them.\n    # No extra sorting is needed.\n\n    # --- Part 2: Analytic Weight Formula ---\n    # Compute weights for validation using the formula:\n    # w_j = 2*(1-x_j^2) / (n^2 * [P_{n-1}(x_j)]^2)\n    p_n_minus_1_at_nodes = legendre_poly_eval(n - 1, nodes)\n    weights_analytic = (2.0 * (1 - nodes**2)) / (n**2 * p_n_minus_1_at_nodes**2)\n    \n    # --- Part 3: Validation ---\n    # 3a: Maximum relative difference between Golub-Welsch and analytic weights.\n    # The denominator is non-zero for Legendre-Gauss weights.\n    rel_diffs = np.abs(weights_gw - weights_analytic) / np.abs(weights_analytic)\n    max_relative_weight_difference = np.max(rel_diffs)\n    \n    # 3b: Absolute error in the sum of weights (should sum to 2).\n    # Using the Golub-Welsch weights for all subsequent calculations as per problem statement.\n    weight_sum_error = np.abs(np.sum(weights_gw) - 2.0)\n    \n    # 3c: Maximum absolute quadrature error for monomials x^k up to degree 2n-1.\n    # The quadrature should be exact, so error should be near machine precision.\n    max_moment_error = 0.0\n    for k in range(2 * n):\n        # Exact integral of x^k from -1 to 1\n        exact_integral = 2.0 / (k + 1) if k % 2 == 0 else 0.0\n        \n        # Quadrature approximation\n        quadrature_sum = np.sum(weights_gw * (nodes**k))\n        \n        error = np.abs(quadrature_sum - exact_integral)\n        if error > max_moment_error:\n            max_moment_error = error\n\n    # --- Part 4: Application to Oscillatory Integral ---\n    # Approximate I(alpha) = integral from -1 to 1 of exp(i*alpha*x) dx.\n    acoustic_errors = []\n    for alpha in alpha_values:\n        # Exact integral: 2*sin(alpha)/alpha for alpha!=0, 2 for alpha=0.\n        if alpha == 0.0:\n            exact_val = 2.0\n        else:\n            exact_val = 2.0 * np.sin(alpha) / alpha\n            \n        # Quadrature approximation. np.exp handles complex numbers.\n        quad_val = np.sum(weights_gw * np.exp(1j * alpha * nodes))\n        \n        # Absolute error |I_quad - I_exact|\n        error = np.abs(quad_val - exact_val)\n        acoustic_errors.append(error)\n        \n    # --- Final Output Formatting ---\n    # The problem requires a specific format: [num, num, num, [num, num, ...]]\n    # This involves manually formatting the inner list.\n    acoustic_errors_str = f\"[{','.join(map(str, acoustic_errors))}]\"\n    \n    results = [\n        max_relative_weight_difference,\n        weight_sum_error,\n        max_moment_error,\n        acoustic_errors_str\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "计算声学中的一个常见挑战是高效地计算高振荡积分。最后一个练习将直面这个问题，它要求我们系统地比较标准高斯-勒让德求积法与一种专为振荡积分设计的Filon型求积法的性能。通过分析两种方法的精度如何随计算量和振荡频率变化，我们将学习到为特定问题选择合适数值工具的重要性，这是高级数值计算中的一个核心原则。",
            "id": "4133001",
            "problem": "考虑计算声学中的一个典型振荡积分，它用于描述一维等幅平面波在对称孔径上的传播，该积分定义为实值积分\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx,\n$$\n其中 $k$ 是一个非负角波数，所有角度均以弧度为单位。在数值传播和辐射模型中，精度取决于求积法则在 $k$ 增大时分辨振荡的能力。您将研究误差作为节点数或子区间数的函数，并将高斯求积（Gauss–Legendre 法则）与一种专为振荡积分设计的 Filon 型法则进行比较。\n\n从微积分和正交多项式的基本原理出发——特别是微积分基本定理、三角函数的性质以及 Gauss–Legendre 求积对于次数不超过 $2n-1$ 的多项式的精确性——推导并实现以下内容：\n\n1. 在 $[-1,1]$ 上使用 $n$ 个节点对 $I(k)$ 进行 Gauss–Legendre 求积近似。\n2. 在 $[-1,1]$ 上使用一种 Filon 型复合规则，该规则在每个子区间上精确积分振荡因子，同时将振幅视为分段常数（等于中点振幅）。对于本问题，物理振幅是精确的常数 1，且角度以弧度为单位。\n\n对每个给定的 $k$，计算 Gauss–Legendre 近似的绝对误差 $E_{\\mathrm{GL}}(k,n)$ 和 Filon 型近似的绝对误差 $E_{\\mathrm{F}}(k,m)$，其中 $n$ 是 Gauss–Legendre 节点的数量，$m$ 是 Filon 型复合规则中均匀子区间的数量。仅使用数学上有效的运算；不要假设超出基本原理的任何快捷公式。\n\n您的程序必须：\n- 对于测试集中的每个 $k$，评估 $n \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$ 时的 $E_{\\mathrm{GL}}(k,n)$ 以及 $m \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$ 时的 $E_{\\mathrm{F}}(k,m)$。\n- 使用 $10^{-12}$ 的绝对误差容差来确定满足 $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$ 的最小 $n$（记为 $n^\\star_{\\mathrm{GL}}(k)$），以及满足 $E_{\\mathrm{F}}(k,m) \\le 10^{-12}$ 的最小 $m$（记为 $m^\\star_{\\mathrm{F}}(k)$）。如果指定集合中没有值满足该容差，则该数量报告为 $-1$。\n- 对于每个 $k$，报告 Gauss–Legendre 方法在所有测试的 $n$ 中的最大绝对误差 $\\max_{n} E_{\\mathrm{GL}}(k,n)$，以及 Filon 型方法在所有测试的 $m$ 中的最大绝对误差 $\\max_{m} E_{\\mathrm{F}}(k,m)$。\n\n测试集（角度以弧度为单位）：\n- $k = 0$,\n- $k = \\pi$,\n- $k = 50$,\n- $k = 200$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须为测试集中的每个 $k$ 包含一个条目，顺序与上面列出的顺序相同。\n- 对于每个 $k$，输出列表 $[\\,n^\\star_{\\mathrm{GL}}(k),\\,m^\\star_{\\mathrm{F}}(k),\\,\\max_{n} E_{\\mathrm{GL}}(k,n),\\,\\max_{m} E_{\\mathrm{F}}(k,m)\\,]$。\n- 所有数值必须以纯小数（浮点数）或整数形式报告。不需要单位，因为所有量都是无量纲的，且角度以弧度为单位。\n- 所需输出结构的示例（使用占位符）：$[\\,[\\,n_1,m_1,e_{1,\\max}^{\\mathrm{GL}},e_{1,\\max}^{\\mathrm{F}}\\,],[\\,n_2,m_2,e_{2,\\max}^{\\mathrm{GL}},e_{2,\\max}^{\\mathrm{F}}\\,],\\dots]$。\n\n您的实现必须是一个完整的、可运行的程序，并且不得需要任何外部输入。",
            "solution": "该问题要求对两种数值求积方法——Gauss–Legendre 法则和一种零阶 Filon 型法则——在求解典型振荡积分 $I(k) = \\int_{-1}^{1} \\cos(k x)\\,dx$ 时进行比较分析。该分析涉及实现这两种方法，计算它们相对于不同波数 $k$ 的精确解析解的绝对误差，并确定达到指定精度所需的计算量（节点数或子区间数）。\n\n### 1. 解析解\n\n第一步是求出积分的精确值，它将作为误差计算的基准真值。我们使用微积分基本定理。\n\n对于非零角波数 $k > 0$：\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx = \\left[ \\frac{\\sin(k x)}{k} \\right]_{-1}^{1} = \\frac{\\sin(k \\cdot 1)}{k} - \\frac{\\sin(k \\cdot (-1))}{k}\n$$\n利用 $\\sin(-x) = -\\sin(x)$ 的性质，上式可简化为：\n$$\nI(k) = \\frac{\\sin(k) - (-\\sin(k))}{k} = \\frac{2\\sin(k)}{k}\n$$\n\n对于波数 $k=0$ 的特殊情况：\n$$\nI(0) = \\int_{-1}^{1} \\cos(0 \\cdot x)\\,dx = \\int_{-1}^{1} 1\\,dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\n值得注意的是，当 $k>0$ 时的解在 $k=0$ 处是连续的，因为 $\\lim_{k \\to 0} \\frac{2\\sin(k)}{k} = 2$，这与 $I(0)$ 的值相匹配。\n\n### 2. 方法一：Gauss–Legendre 求积\n\nGauss–Legendre 求积是一种在区间 $[-1, 1]$ 上近似积分的强大方法。其一般形式为：\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n这里，$n$ 是节点的数量。节点 $x_i$ 是 $n$ 次 Legendre 多项式 $P_n(x)$ 的根，而权重 $w_i$ 则由正交多项式理论导出。该法则的一个关键性质是，它对于次数最高为 $2n-1$ 的任何多项式都是精确的。\n\n对于我们特定的积分，被积函数是 $f(x) = \\cos(kx)$。Gauss–Legendre 近似值 $I_{\\mathrm{GL}}(k,n)$ 为：\n$$\nI_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)\n$$\n当 $k=0$ 时，被积函数是 $f(x) = \\cos(0) = 1$，这是一个 0 次多项式。$n=1$ 的 Gauss-Legendre 法则对于次数不超过 $2(1)-1=1$ 的多项式是精确的，因此它将精确地积分 $f(x)=1$。对于 $n \\ge 1$，该近似将是精确的。\n\n当 $k > 0$ 时，$\\cos(kx)$ 不是一个多项式。近似的精度取决于被积函数能被一个 $2n-1$ 次多项式表示得有多好。随着 $k$ 的增加，函数振荡得更快，需要更高次的多项式（因此需要更大的 $n$）才能达到给定的精度。绝对误差计算为 $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$。\n\n节点和权重将使用 `scipy` 库中的例程进行数值计算，这是一种标准做法。\n\n### 3. 方法二：Filon 型复合规则\n\nFilon 型方法是专门为形如 $\\int_{a}^{b} g(x) \\Omega(kx) dx$ 的振荡积分设计的，其中 $g(x)$ 是一个缓变振幅，而 $\\Omega(kx)$ 是一个快速振荡函数（例如 $\\cos(kx)$ 或 $\\sin(kx)$）。其核心思想是在子区间上用一个更简单的函数（如低次多项式）来近似 $g(x)$，然后精确地对得到的乘积 $p(x)\\Omega(kx)$ 进行积分。\n\n该问题指定了一种零阶复合规则：\n1. 将区间 $[-1, 1]$ 分成 $m$ 个均匀的子区间 $[x_j, x_{j+1}]$，每个子区间的长度为 $h = \\frac{2}{m}$，其中 $x_j = -1 + jh$。\n2. 在每个子区间上，用一个等于其在子区间中点处值的常数来近似振幅函数 $g(x)$——在我们的例子中是 $g(x)=1$。\n3. 在每个子区间上精确地对得到的近似进行积分。\n\n对于积分 $I(k) = \\int_{-1}^{1} 1 \\cdot \\cos(kx) dx$，振幅为 $g(x) = 1$。用其中点值来近似这个常数函数，结果仍是常数 $1$ 本身。因此，在每个子区间 $[x_j, x_{j+1}]$ 上，积分的近似为：\n$$\n\\int_{x_j}^{x_{j+1}} (g(x) \\text{ 的中点值}) \\cdot \\cos(kx)\\,dx = \\int_{x_j}^{x_{j+1}} 1 \\cdot \\cos(kx)\\,dx\n$$\nFilon 型近似 $I_{\\mathrm{F}}(k,m)$ 是这些积分在所有 $m$ 个子区间上的总和：\n$$\nI_{\\mathrm{F}}(k,m) = \\sum_{j=0}^{m-1} \\int_{x_j}^{x_{j+1}} \\cos(kx)\\,dx\n$$\n根据定积分的可加性，这个和可以收缩为在整个定义域上的原始积分：\n$$\nI_{\\mathrm{F}}(k,m) = \\int_{x_0}^{x_m} \\cos(kx)\\,dx = \\int_{-1}^{1} \\cos(kx)\\,dx = I(k)\n$$\n这证明了一个关键结果：对于这个振幅函数是精确常数的特定问题，所规定的 Filon 型法则是对于任何子区间数 $m \\ge 1$ 和所有 $k$ 值都是**解析精确**的。因此，绝对误差 $E_{\\mathrm{F}}(k,m) = |I(k) - I_{\\mathrm{F}}(k,m)|$ 将为零，或一个仅受浮点精度限制的非常小的数。这意味着对于任何 $k$，达到容差所需的最小子区间数是 $m^\\star_{\\mathrm{F}}(k) = 1$，并且在所有测试的 $m$ 中的最大误差将近似为 $0$。\n\n### 4. 计算流程\n\n程序将对测试集 $\\{0, \\pi, 50, 200\\}$ 中的每个 $k$ 执行以下步骤：\n\n1.  **计算精确值**：使用上面推导的解析公式计算 $I(k)$，并对 $k=0$ 进行特殊处理。\n2.  **评估 Gauss–Legendre 误差**：\n    *   初始化 $n^\\star_{\\mathrm{GL}} = -1$ 和 $\\max_{n} E_{\\mathrm{GL}} = 0$。\n    *   遍历 $n \\in \\{1, 2, 4, 8, 16, 32, 64, 128\\}$。\n    *   对于每个 $n$，获取 Gauss-Legendre 节点 $x_i$ 和权重 $w_i$。\n    *   计算近似值 $I_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)$。\n    *   计算绝对误差 $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$。\n    *   如果当前误差更大，则更新 $\\max_{n} E_{\\mathrm{GL}}$。\n    *   如果 $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$ 且 $n^\\star_{\\mathrm{GL}}$ 尚未设置，则赋值 $n^\\star_{\\mathrm{GL}} = n$。\n3.  **评估 Filon 型误差**：\n    *   根据我们的分析发现，$I_{\\mathrm{F}}(k,m)$ 与 $I(k)$ 完全相同。\n    *   因此，$m^\\star_{\\mathrm{F}}(k) = 1$（$m$ 集合中的第一个值）。\n    *   对于所有 $m$，误差 $E_{\\mathrm{F}}(k,m)$ 实际上为 $0$。最大误差 $\\max_{m} E_{\\mathrm{F}}$ 也为 $0$。\n4.  **整理并报告**：为当前的 $k$ 存储计算出的元组 $[n^\\star_{\\mathrm{GL}}, m^\\star_{\\mathrm{F}}, \\max_{n} E_{\\mathrm{GL}}, \\max_{m} E_{\\mathrm{F}}]$，然后处理测试集中的下一个值。最后，将收集到的结果格式化为单行文本。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of Gauss-Legendre and Filon-type\n    quadrature for a canonical oscillatory integral from computational acoustics.\n    \"\"\"\n    \n    # Define the problem parameters\n    test_suite_k = [0.0, np.pi, 50.0, 200.0]\n    n_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    m_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    tolerance = 1e-12\n\n    def exact_integral(k):\n        \"\"\"Computes the exact value of the integral I(k) = int_{-1}^{1} cos(kx) dx.\"\"\"\n        if k == 0.0:\n            return 2.0\n        else:\n            return 2.0 * np.sin(k) / k\n\n    def gauss_legendre_approx(k, n):\n        \"\"\"Computes the Gauss-Legendre quadrature approximation for I(k) with n nodes.\"\"\"\n        nodes, weights = roots_legendre(n)\n        integrand_values = np.cos(k * nodes)\n        return np.sum(weights * integrand_values)\n\n    def filon_type_approx(k, m):\n        \"\"\"\n        Computes the Filon-type quadrature approximation.\n        As derived in the solution, for f(x)=1, this method is analytically exact\n        for any m >= 1, and thus returns the exact integral value.\n        \"\"\"\n        return exact_integral(k)\n\n    all_results = []\n    for k in test_suite_k:\n        # Calculate the exact value for the current k\n        i_exact = exact_integral(k)\n\n        # --- Gauss-Legendre Analysis ---\n        n_star_gl = -1\n        max_err_gl = 0.0\n        for n in n_values:\n            i_gl = gauss_legendre_approx(k, n)\n            err_gl = np.abs(i_exact - i_gl)\n            \n            if err_gl > max_err_gl:\n                max_err_gl = err_gl\n            \n            if err_gl = tolerance and n_star_gl == -1:\n                n_star_gl = n\n\n        # --- Filon-type Analysis ---\n        m_star_f = -1\n        max_err_f = 0.0\n        for m in m_values:\n            # As derived, the Filon-type approximation for a constant amplitude of 1\n            # is identical to the exact integral. The error is thus 0 up to machine precision.\n            i_f = filon_type_approx(k, m)\n            err_f = np.abs(i_exact - i_f)\n\n            if err_f > max_err_f:\n                max_err_f = err_f\n\n            if err_f = tolerance and m_star_f == -1:\n                m_star_f = m\n        \n        # In the specific case for Filon method, m_star_f will always be the first\n        # element, 1, and max_err_f will be ~0 due to exactness.\n        # This explicit check handles the case where m_values might not start at 1.\n        if m_star_f == -1 and m_values:\n             # Fallback if no m met the tolerance, which shouldn't happen here.\n             pass\n\n        # Collect results for this k\n        all_results.append([n_star_gl, m_star_f, max_err_gl, max_err_f])\n\n    # Format the final output string exactly as required\n    # e.g., [[1, 1, 0.0, 0.0], [8, 1, 0.5103, 0.0], ...]\n    result_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}