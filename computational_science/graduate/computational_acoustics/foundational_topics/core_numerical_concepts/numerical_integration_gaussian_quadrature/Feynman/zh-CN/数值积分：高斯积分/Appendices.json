{
    "hands_on_practices": [
        {
            "introduction": "理解一个数值方法的最好方式就是付诸实践。本练习将引导你使用标准的高斯-勒让德求积法来探索其核心特性：它对光滑函数的高精度、其对多项式的精确度，以及在处理声学波动问题中常见的振荡函数时的性能。通过这个实践 ，你将在深入研究其背后理论之前，建立起对该方法直观的认识。",
            "id": "4133056",
            "problem": "考虑在区间 $[-1,1]$ 上使用高斯求积法近似计算定积分的任务。高斯求积法是一族通过在精心选择的节点上用相关的权重计算被积函数的值，从而能够精确积分最高达到特定次数的多项式的公式。在计算声学中，这类积分出现在角平均、辐射积分和平面波展开中，其中的变量通常表示映射到 $[-1,1]$ 上的方向余弦。高斯-勒让德法则是高斯求积法在区间 $[-1,1]$ 上针对单位权重函数 $w(x)=1$ 的特例。从勒让德多项式在单位权重下于区间 $[-1,1]$ 上正交，以及一个 n 点高斯求积法可以被构造成对所有次数最高为 $2n-1$ 的多项式都精确这两个基本事实出发，设计并实现一个算法，该算法使用高斯-勒让德节点和权重来近似计算光滑函数在 $[-1,1]$ 上的积分。\n\n你的程序必须为给定的节点数 $n$ 实现一个高斯-勒让德法则，并应用它来评估积分近似值\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i\\,f(x_i),\n$$\n其中 $(x_i,w_i)$ 是所选 $n$ 对应的高斯-勒让德节点和权重。对于每个测试用例，通过将求积值与积分的解析值进行比较来计算绝对误差。\n\n你必须使用以下测试套件，它考察了正确性、多项式次数边界上的精确性、区间的对称性，以及对声学问题相关的振荡被积函数的行为：\n\n- 案例 A (正常路径)：$n=6$， $f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。输出求积近似值和绝对误差。\n- 案例 B (次数边界和对称性)：$n=6$，$f(x)=x^{11}$。这是一个在对称区间上的奇函数多项式。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。仅输出绝对误差。\n- 案例 C (超出精确次数)：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。仅输出绝对误差。\n- 案例 D ($n$ 的边界条件)：$n=1$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。仅输出绝对误差。\n- 案例 E (受声学启发的振荡测试)：$n=6$，$f(x)=\\cos(50 x)$。角度必须以弧度处理。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。仅输出绝对误差。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序和数据类型如下：\n$$\n[\\text{A\\_approx},\\ \\text{A\\_err},\\ \\text{B\\_err},\\ \\text{C\\_err},\\ \\text{D\\_err},\\ \\text{E\\_err}],\n$$\n其中每个条目都是一个浮点数。不涉及物理单位，并且在案例 E 的余弦函数中，角度必须以弧度处理。",
            "solution": "该问题是有效的。它在科学上基于成熟的数值积分数学理论，特别是高斯-勒让德求积法。问题是适定的，提供了计算出唯一数值结果所需的所有必要信息、函数和参数。该问题是客观的，并使用了标准的、无歧义的术语。因此，我们可以着手解决。\n\n核心任务是使用高斯-勒让德求积法则来近似计算函数 $f(x)$ 在对称区间 $[-1, 1]$ 上的定积分。此方法属于高斯求积法族，其设计目的是在给定函数求值次数的情况下获得尽可能高的精度阶。n点高斯求积的一般形式是：\n$$\n\\int_{a}^{b} w(x) f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n此处，$w(x)$ 是一个非负权重函数，$[a, b]$ 是积分区间，$x_i$ 是 $n$ 个求积节点（或点），$w_i$ 是对应的 $n$ 个求积权重。\n\n对于高斯-勒让德求积的具体情况，区间是 $[-1, 1]$，权重函数为1，即 $w(x) = 1$。公式简化为：\n$$\n\\int_{-1}^{1} f(x) \\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n该方法的显著特性源于对节点和权重的特殊选择。$n$ 个节点 $x_i$ 被选为 $n$ 次勒让德多项式 $P_n(x)$ 的根。勒让德多项式构成一个在区间 $[-1, 1]$上关于权重函数 $w(x)=1$ 的正交多项式序列。通过这样选择节点，可以确定权重 $w_i$，使得该求积公式对所有次数最高（含）为 $2n-1$ 的多项式都精确。这个精度阶是其他常见法则（如牛顿-科特斯公式，例如梯形法则、辛普森法则）的两倍，后者对于n点法则仅对次数最高为 $n-1$ 或 $n$ 的多项式精确。\n\n解决每个测试用例的算法如下：\n1. 对于给定的节点数 $n$，获取高斯-勒让德节点集 $\\{x_i\\}_{i=1}^n$ 和权重集 $\\{w_i\\}_{i=1}^n$。这些是预先计算好的值，可以使用允许的标准数值库（例如 `scipy.special.roots_legendre`）来检索。\n2. 根据测试用例的规定，定义被积函数 $f(x)$。\n3. 在每个节点 $x_i$ 处计算函数 $f(x)$ 的值，得到 $f(x_i)$。\n4. 通过计算加权和来计算积分的求积近似值：$I_{approx} = \\sum_{i=1}^{n} w_i f(x_i)$。\n5. 计算绝对误差 $E_{abs} = |I_{approx} - I_{analytic}|$，其中 $I_{analytic}$ 是提供的积分精确值。\n\n我们现在将此算法应用于每个指定的测试用例。\n\n- **案例 A**：$n=6$，$f(x)=e^x$。解析值为 $\\int_{-1}^{1} e^x\\,dx = e - e^{-1}$。由于 $f(x)=e^x$ 是一个超越函数而非多项式，高斯-勒让德法则不会是精确的。然而，由于 $e^x$ 是光滑的，并且在 $[-1, 1]$ 上可以被其泰勒级数很好地近似，因此预期一个6点法则将提供高精度。\n\n- **案例 B**：$n=6$，$f(x)=x^{11}$。解析值为 $\\int_{-1}^{1} x^{11}\\,dx = 0$。被积函数是一个11次多项式。对于 $n=6$，高斯-勒让德法则对所有次数最高为 $2n-1 = 2(6)-1 = 11$ 的多项式都是精确的。因此，求积必须产生精确结果。计算出的近似值应为 $0$，绝对误差预期为数值上为零（即，达到机器精度水平）。\n\n- **案例 C**：$n=6$，$f(x)=x^{12}$。解析值为 $\\int_{-1}^{1} x^{12}\\,dx = \\frac{2}{13}$。被积函数是一个12次多项式。该次数大于精确次数 $2n-1=11$。因此，该求积法则对此函数不再精确，我们预计会有一个非零但很小的近似误差。\n\n- **案例 D**：$n=1$，$f(x)=e^x$。解析值为 $e - e^{-1}$。对于 $n=1$，精确次数为 $2(1)-1=1$。单个节点是 $P_1(x)=x$ 的根，即 $x_1=0$。权重为 $w_1 = \\int_{-1}^{1} 1 \\,dx = 2$。近似值就是 $I_{approx} = w_1 f(x_1) = 2 \\cdot f(0) = 2 \\cdot e^0 = 2$。我们预期其误差会比使用更精确的6点法则的案例A大得多。\n\n- **案例 E**：$n=6$，$f(x)=\\cos(50x)$。解析值为 $\\int_{-1}^{1} \\cos(50x)\\,dx = \\frac{2\\sin(50)}{50}$。这个被积函数在区间 $[-1, 1]$ 上是高度振荡的。高斯求积法的效率依赖于函数能被低次多项式很好地近似。像 $\\cos(50x)$ 这样的函数需要一个非常高次的多项式才能得到好的近似，因此6点法则不足以捕捉其行为。我们预期会有一个很大的近似误差，这说明了低阶求积法对此类函数的局限性。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Implements Gauss-Legendre quadrature to approximate definite integrals\n    and calculates the absolute error for a suite of test cases.\n    \"\"\"\n\n    results = []\n\n    # Case A: n=6, f(x) = e^x\n    n_A = 6\n    f_A = np.exp\n    analytic_A = np.exp(1) - np.exp(-1)\n    nodes_A, weights_A = roots_legendre(n_A)\n    approx_A = np.sum(weights_A * f_A(nodes_A))\n    err_A = np.abs(approx_A - analytic_A)\n    results.extend([approx_A, err_A])\n\n    # Case B: n=6, f(x) = x^11 (degree is 2n-1, should be exact)\n    n_B = 6\n    f_B = lambda x: x**11\n    analytic_B = 0.0\n    nodes_B, weights_B = roots_legendre(n_B)\n    approx_B = np.sum(weights_B * f_B(nodes_B))\n    err_B = np.abs(approx_B - analytic_B)\n    results.append(err_B)\n\n    # Case C: n=6, f(x) = x^12 (degree is 2n, should not be exact)\n    n_C = 6\n    f_C = lambda x: x**12\n    analytic_C = 2.0 / 13.0\n    nodes_C, weights_C = roots_legendre(n_C)\n    approx_C = np.sum(weights_C * f_C(nodes_C))\n    err_C = np.abs(approx_C - analytic_C)\n    results.append(err_C)\n\n    # Case D: n=1, f(x) = e^x\n    n_D = 1\n    f_D = np.exp\n    analytic_D = np.exp(1) - np.exp(-1)\n    nodes_D, weights_D = roots_legendre(n_D)\n    approx_D = np.sum(weights_D * f_D(nodes_D))\n    err_D = np.abs(approx_D - analytic_D)\n    results.append(err_D)\n\n    # Case E: n=6, f(x) = cos(50x) (oscillatory function)\n    n_E = 6\n    f_E = lambda x: np.cos(50 * x)\n    analytic_E = 2.0 * np.sin(50) / 50.0\n    nodes_E, weights_E = roots_legendre(n_E)\n    approx_E = np.sum(weights_E * f_E(nodes_E))\n    err_E = np.abs(approx_E - analytic_E)\n    results.append(err_E)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在见证了高斯求积法的威力之后，下一个自然而然的步骤是理解其构造原理。本练习将超越简单地使用预计算好的求积点和权重，要求你亲手实现著名的 Golub-Welsch 算法 。该算法巧妙地将求积问题与一个对称三对角雅可比矩阵的特征值问题联系在一起。通过从头开始构建求积法则并对其进行严格验证，你将对底层的数学机制有更深刻的理解。",
            "id": "4133076",
            "problem": "在计算声学中，对角度或方向变量进行精确的数值积分对于高频波建模和边界积分公式至关重要。一个核心工具是带有勒让德权重的高斯求积，它通过在特殊选择的节点上进行加权求和来近似区间 $[-1,1]$ 上的积分。本问题要求您使用 Golub–Welsch 算法，从勒让德多项式的基本正交性和三项递推性质出发，推导、实现并验证勒让德-高斯节点和权重的构造。您不得使用任何预先计算好的节点或权重，也不得使用直接返回它们的专用函数。\n\n您的任务是：\n\n1) 仅使用标准正交多项式的三项递推关系作为基本依据，构造与区间 $[-1,1]$ 上的勒让德权重 $w(x) = 1$ 相关联的 $n \\times n$ 对称三对角雅可比矩阵。通过求解该雅可比矩阵的特征值问题获得勒让德-高斯节点，并从相应归一化特征向量的第一个分量中获得权重。使用 $n = 10$。\n\n2) 基于勒让德多项式的正交性以及 $n$ 次勒让德多项式导数的性质，推导勒让德-高斯权重的解析表达式，并用它在第 1 部分得到的节点上计算第二组权重。不要直接使用问题陈述中的任何公式；在代码中实现您的推导。\n\n3) 通过计算并报告以下量来验证您实现的正确性和准确性：\n   - 通过 Golub–Welsch 特征向量公式计算的权重与从勒让德多项式性质推导的解析表达式计算的权重之间的最大相对差异。报告一个浮点数。\n   - 权重之和与权重函数在 $[-1,1]$ 上的精确积分（即 $2$）相比的绝对误差。报告一个浮点数。\n   - 在对从 $0$ 到 $2n-1$（含）的所有整数 $k$ 的单项式 $x^k$ 进行积分时，将求积和与精确积分 $\\int_{-1}^{1} x^k \\, dx$（对于奇数 $k$ 等于 $0$，对于偶数 $k$ 等于 $2/(k+1)$）进行比较，所得的最大绝对求积误差。报告一个浮点数。\n\n4) 为了与声学中的一个典型振荡积分联系起来，考虑积分\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx = \\frac{2 \\sin(\\alpha)}{\\alpha} \\quad \\text{for } \\alpha \\neq 0, \\quad I(0) = 2,\n$$\n其中 $\\alpha$ 以弧度为单位。使用第 1 部分中 $n=10$ 的节点和权重，对一组参数 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$（均以弧度为单位）近似计算 $I(\\alpha)$，并按给定顺序报告这些 $\\alpha$ 值对应的绝对误差 $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$ 列表。\n\n重要的实现和输出要求：\n\n- 仅使用勒让德多项式的三项递推结构来构建雅可比矩阵，并通过特征值问题获得节点和权重。问题禁止使用任何直接返回高斯节点或权重的快捷例程。\n- 角度必须以弧度为单位进行解释。\n- 所有输出必须是无量纲的实数。\n- 测试套件：使用 $n=10$ 和 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$。\n- 最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须具有以下形式\n$\n[\\text{max\\_relative\\_weight\\_difference}, \\text{weight\\_sum\\_error}, \\text{max\\_moment\\_error}, [e_{\\alpha=0}, e_{\\alpha=0.1}, e_{\\alpha=1}, e_{\\alpha=10}, e_{\\alpha=50}]]\n$\n其中每个元素都是一个浮点数。例如，输出可能如下所示\n$\n[1e-15,0.0,2.22e-16,[0.0,1e-15,1e-12,1e-6,1e-4]].\n$ \n您的程序必须严格按照此格式打印一行，并且不得读取任何输入。",
            "solution": "该问题要求使用 Golub–Welsch 算法，为 $n=10$ 个点构造、实现并验证勒让德-高斯求积法则。该算法在高斯求积与被称为雅可比矩阵的对称三对角矩阵的谱理论之间建立了深刻的联系。我们将首先从标准正交勒让德多项式的三项递推关系构造雅可比矩阵。然后，我们将求解相应的特征值问题以找到求积节点和权重。这些结果将通过与权重的解析公式进行对比以及测试求积对多项式的精确性来进行验证。最后，我们将该求积法则应用于声学中一个具有代表性的振荡积分。\n\n**第 1 步：构造雅可比矩阵 (Golub–Welsch 算法)**\n\n高斯求积通过加权和 $\\sum_{j=1}^{n} w_j f(x_j)$ 来近似形式为 $\\int_a^b f(x) w(x) \\, dx$ 的积分。选择节点 $\\{x_j\\}$ 和权重 $\\{w_j\\}$ 是为了使此近似对于所有次数最高为 $2n-1$ 的多项式都精确。对于在 $[a, b]$ 上关于权重函数 $w(x)$ 标准正交的多项式族 $\\{\\phi_k(x)\\}$，它们满足一个三项递推关系：\n$$\nx \\phi_k(x) = \\beta_k \\phi_{k-1}(x) + \\alpha_k \\phi_k(x) + \\beta_{k+1} \\phi_{k+1}(x)\n$$\n这些系数 $\\alpha_k$ 和 $\\beta_k$ 构成一个 $n \\times n$ 的对称三对角矩阵，即雅可比矩阵 $J_n$：\n$$\nJ_n = \\begin{pmatrix}\n\\alpha_0  \\beta_1  0  \\cdots  0 \\\\\n\\beta_1  \\alpha_1  \\beta_2  \\ddots  \\vdots \\\\\n0  \\beta_2  \\alpha_2  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\beta_{n-1} \\\\\n0  \\cdots  0  \\beta_{n-1}  \\alpha_{n-1}\n\\end{pmatrix}\n$$\nGolub–Welsch 算法指出，$n$ 个求积节点 $\\{x_j\\}$ 是该矩阵 $J_n$ 的特征值。相应的权重 $\\{w_j\\}$ 则由归一化特征向量的第一个分量导出。具体来说，如果 $v_j$ 是对应于特征值 $x_j$ 的归一化特征向量，则权重为 $w_j = \\mu_0 (v_{j,0})^2$，其中 $v_{j,0}$ 是 $v_j$ 的第一个分量，而 $\\mu_0 = \\int_a^b w(x) \\, dx$。\n\n对于本问题，我们在区间 $[-1, 1]$ 上使用勒让德权重函数 $w(x) = 1$。\n权重函数的积分为 $\\mu_0 = \\int_{-1}^1 1 \\, dx = 2$。\n标准的勒让德多项式 $P_k(x)$ 是正交的但非标准正交。标准正交多项式为 $\\phi_k(x) = \\sqrt{\\frac{2k+1}{2}} P_k(x)$。\n递推系数由 $\\alpha_k = \\int_{-1}^1 x (\\phi_k(x))^2 \\, dx$ 和 $\\beta_k = \\int_{-1}^1 x \\phi_k(x) \\phi_{k-1}(x) \\, dx$ 给出。\n由于区间 $[-1, 1]$ 和权重函数 $w(x)=1$ 的对称性，$\\alpha_k$ 的被积函数是奇函数，因此对于所有 $k$，$\\alpha_k = 0$。\n非对角项 $\\beta_k$ 可以从 $P_k(x)$ 的标准递推关系中导出：\n$$\n(k+1)P_{k+1}(x) = (2k+1)xP_k(x) - kP_{k-1}(x)\n$$\n整理出 $x P_k(x)$ 并代入 $\\phi_k(x)$ 的关系式，我们得到标准正交多项式的递推关系，从而得出系数：\n$$\n\\beta_k = \\frac{k}{\\sqrt{(2k-1)(2k+1)}} = \\frac{k}{\\sqrt{4k^2 - 1}} \\quad \\text{for } k=1, \\dots, n-1\n$$\n对于 $n=10$，我们构造一个 $10 \\times 10$ 的矩阵 $J_{10}$，其对角线上为零，主对角线上下两侧分别为 $k=1, \\dots, 9$ 时的 $\\beta_k$ 值。求解特征值问题 $J_{10} V = V \\Lambda$，其中 $\\Lambda$ 是特征值（节点）的对角矩阵，$V$ 是特征向量矩阵，即可提供节点和权重。\n\n**第 2 步：权重的解析公式**\n\n为了验证，我们使用另一种方法计算权重。勒让德-高斯求积的权重由以下公式给出：\n$$\nw_j = \\frac{2}{(1 - x_j^2) [P_n'(x_j)]^2}\n$$\n其中 $P_n'(x_j)$ 是 $n$ 次勒让德多项式在节点 $x_j$ 处的导数。要实现这一点，我们需要 $P_n'(x_j)$ 的表达式。勒让德多项式满足微分关系：\n$$\n(1 - x^2)P_n'(x) = nP_{n-1}(x) - nxP_n(x)\n$$\n在节点 $x_j$ 处，它们是 $P_n(x)$ 的根，因此有 $P_n(x_j) = 0$。该关系简化为：\n$$\n(1 - x_j^2)P_n'(x_j) = nP_{n-1}(x_j)\n$$\n将此代入权重公式，得到一个更稳定的表达式，它避免了直接计算导数，也避免了当 $1 - x_j^2$ 很小时可能出现的除零问题：\n$$\nw_j = \\frac{2(1 - x_j^2)}{n^2 [P_{n-1}(x_j)]^2}\n$$\n为使用此公式，我们首先通过 Golub-Welsch 方法找到节点 $x_j$，然后在这些节点上计算 $P_{n-1}(x)$ 的值。多项式 $P_{n-1}(x_j)$ 使用其标准的三项递推关系从头开始实现并计算。\n\n**第 3 步：验证方案**\n\n我们执行三个量化检查来验证我们的实现：\n1.  **最大相对权重差异**：我们使用 Golub-Welsch 方法 ($w_j^{\\text{GW}}$) 和解析公式 ($w_j^{\\text{analytic}}$) 计算权重。计算最大相对差异 $\\max_j \\left| \\frac{w_j^{\\text{GW}} - w_j^{\\text{analytic}}}{w_j^{\\text{analytic}}} \\right|$。这个值应该在机器精度级别。\n2.  **权重和误差**：权重之和必须等于权重函数的积分，即 $\\sum_{j=1}^n w_j = \\int_{-1}^1 1 \\, dx = 2$。我们报告绝对误差 $|\\sum_{j=1}^n w_j - 2|$。\n3.  **最大矩误差**：一个 $n$ 点高斯求积法则对于所有次数最高为 $2n-1$ 的多项式都是精确的。我们通过对 $k=0, 1, \\dots, 2n-1$ 的单项式 $x^k$ 进行积分来测试这一点。精确积分为 $I_k = \\int_{-1}^1 x^k \\, dx$，对于偶数 $k$ 为 $2/(k+1)$，对于奇数 $k$ 为 $0$。我们计算在此 $k$ 值范围内的最大绝对误差 $| \\sum_{j=1}^n w_j x_j^k - I_k |$。\n\n**第 4 步：应用于振荡积分**\n\n我们将已开发的 $n=10$ 求积法则应用于近似计算振荡积分：\n$$\nI(\\alpha) = \\int_{-1}^{1} e^{i \\alpha x} \\, dx\n$$\n对于 $\\alpha \\neq 0$，精确解为 $I(\\alpha) = \\frac{2\\sin(\\alpha)}{\\alpha}$，对于 $I(0) = 2$。数值近似由 $I_{\\text{quad}}(\\alpha) = \\sum_{j=1}^{10} w_j e^{i \\alpha x_j}$ 给出。我们计算 $\\alpha \\in \\{0, 0.1, 1, 10, 50\\}$ 时的绝对误差 $|I_{\\text{quad}}(\\alpha) - I(\\alpha)|$。这个测试展示了该求积方法对于一个非多项式的、具有声学中波现象特征的振荡函数的性能。随着频率参数 $\\alpha$ 的增加，被积函数振荡得更快，对于固定数量的求积点，近似误差预计会增大。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef legendre_poly_eval(k, x):\n    \"\"\"\n    Evaluates the Legendre polynomial P_k(x) at point(s) x using the\n    three-term recurrence relation.\n    \"\"\"\n    x = np.asarray(x)\n    if k == 0:\n        return np.ones_like(x)\n    if k == 1:\n        return x\n    \n    p_k_minus_2 = np.ones_like(x)\n    p_k_minus_1 = x\n    for i in range(2, k + 1):\n        p_k = ((2 * i - 1) * x * p_k_minus_1 - (i - 1) * p_k_minus_2) / i\n        p_k_minus_2 = p_k_minus_1\n        p_k_minus_1 = p_k\n    return p_k_minus_1\n\ndef solve():\n    \"\"\"\n    Derives, implements, and validates Legendre-Gauss quadrature.\n    \"\"\"\n    n = 10\n    alpha_values = [0.0, 0.1, 1.0, 10.0, 50.0]\n\n    # --- Part 1: Golub-Welsch Algorithm ---\n    # Construct the n x n symmetric tridiagonal Jacobi matrix.\n    # Diagonal elements (alpha_k) are 0.\n    # Off-diagonal elements (beta_k) are k / sqrt(4k^2 - 1).\n    J = np.zeros((n, n))\n    for k in range(1, n):\n        beta_k = k / np.sqrt(4 * k**2 - 1)\n        J[k, k-1] = beta_k\n        J[k-1, k] = beta_k\n        \n    # Solve the eigenvalue problem for the Jacobi matrix.\n    # Eigenvalues are the nodes, eigenvectors are used for weights.\n    # np.linalg.eigh is used for symmetric matrices and returns sorted eigenvalues.\n    nodes, eigenvectors = np.linalg.eigh(J)\n    \n    # Calculate weights from the first component of the normalized eigenvectors.\n    # w_j = mu_0 * (v_{j,0})^2, where mu_0 = integral of w(x)=1 from -1 to 1, which is 2.\n    # eigenvectors are stored as columns. eigenvectors[0,:] gives the first row.\n    weights_gw = 2.0 * (eigenvectors[0, :])**2\n    \n    # The nodes from eigh are already sorted, and weights correspond to them.\n    # No extra sorting is needed.\n\n    # --- Part 2: Analytic Weight Formula ---\n    # Compute weights for validation using the formula:\n    # w_j = 2*(1-x_j^2) / (n^2 * [P_{n-1}(x_j)]^2)\n    p_n_minus_1_at_nodes = legendre_poly_eval(n - 1, nodes)\n    weights_analytic = (2.0 * (1 - nodes**2)) / (n**2 * p_n_minus_1_at_nodes**2)\n    \n    # --- Part 3: Validation ---\n    # 3a: Maximum relative difference between Golub-Welsch and analytic weights.\n    # The denominator is non-zero for Legendre-Gauss weights.\n    rel_diffs = np.abs(weights_gw - weights_analytic) / np.abs(weights_analytic)\n    max_relative_weight_difference = np.max(rel_diffs)\n    \n    # 3b: Absolute error in the sum of weights (should sum to 2).\n    # Using the Golub-Welsch weights for all subsequent calculations as per problem statement.\n    weight_sum_error = np.abs(np.sum(weights_gw) - 2.0)\n    \n    # 3c: Maximum absolute quadrature error for monomials x^k up to degree 2n-1.\n    # The quadrature should be exact, so error should be near machine precision.\n    max_moment_error = 0.0\n    for k in range(2 * n):\n        # Exact integral of x^k from -1 to 1\n        exact_integral = 2.0 / (k + 1) if k % 2 == 0 else 0.0\n        \n        # Quadrature approximation\n        quadrature_sum = np.sum(weights_gw * (nodes**k))\n        \n        error = np.abs(quadrature_sum - exact_integral)\n        if error > max_moment_error:\n            max_moment_error = error\n\n    # --- Part 4: Application to Oscillatory Integral ---\n    # Approximate I(alpha) = integral from -1 to 1 of exp(i*alpha*x) dx.\n    acoustic_errors = []\n    for alpha in alpha_values:\n        # Exact integral: 2*sin(alpha)/alpha for alpha!=0, 2 for alpha=0.\n        if alpha == 0.0:\n            exact_val = 2.0\n        else:\n            exact_val = 2.0 * np.sin(alpha) / alpha\n            \n        # Quadrature approximation. np.exp handles complex numbers.\n        quad_val = np.sum(weights_gw * np.exp(1j * alpha * nodes))\n        \n        # Absolute error |I_quad - I_exact|\n        error = np.abs(quad_val - exact_val)\n        acoustic_errors.append(error)\n        \n    # --- Final Output Formatting ---\n    # The problem requires a specific format: [num, num, num, [num, num, ...]]\n    # This involves manually formatting the inner list.\n    acoustic_errors_str = f\"[{','.join(map(str, acoustic_errors))}]\"\n    \n    results = [\n        max_relative_weight_difference,\n        weight_sum_error,\n        max_moment_error,\n        acoustic_errors_str\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "尽管高斯求积法对许多函数都非常有效，但在处理计算声学中普遍存在的高度振荡积分时，其效率可能会很低。本练习直面这一挑战，通过比较标准高斯-勒让德求积法与专为此类积分设计的 Filon 型方法的性能 。通过这项对比分析，你将学会识别通用方法何时会失效，并理解为何需要针对特定问题的数值策略。",
            "id": "4133001",
            "problem": "考虑计算声学中的一个典型振荡积分，该积分代表一维恒定振幅平面波在对称孔径上的传播，定义为实值积分\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx,\n$$\n其中 $k$ 是一个非负角波数，所有角度均以弧度为单位。在数值传播和辐射模型中，准确性取决于求积法则在 $k$ 增大时解析振荡的能力。您将研究误差作为节点数或子区间数的函数，并比较高斯求积（Gauss–Legendre 法则）与一种专为振荡积分定制的 Filon 型法则。\n\n从微积分和正交多项式的基本原理出发——特别是微积分基本定理、三角函数的性质，以及 Gauss–Legendre 求积对于次数最高为 $2n-1$ 的多项式的精确性——推导并实现以下内容：\n\n1.  一个在 $[-1,1]$ 上使用 $n$ 个节点对 $I(k)$ 进行 Gauss–Legendre 求积近似。\n2.  一个在 $[-1,1]$ 上的 Filon 型复合规则，该规则通过在每个子区间上精确积分振荡因子，同时将振幅视为分段常数（等于中点振幅）来进行近似。对于本问题，物理振幅是精确的常数 1，且角度以弧度为单位。\n\n对每个给定的 $k$，计算 Gauss–Legendre 近似的绝对误差 $E_{\\mathrm{GL}}(k,n)$ 和 Filon 型近似的绝对误差 $E_{\\mathrm{F}}(k,m)$，其中 $n$ 是 Gauss–Legendre 节点的数量，$m$ 是 Filon 型复合规则中均匀子区间的数量。仅使用数学上有效的运算；不要假设超出基本原理的任何捷径公式。\n\n您的程序必须：\n- 对于测试套件中的每个 $k$，评估 $n \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$ 时的 $E_{\\mathrm{GL}}(k,n)$ 和 $m \\in \\{\\,1,2,4,8,16,32,64,128\\,\\}$ 时的 $E_{\\mathrm{F}}(k,m)$。\n- 使用 $10^{-12}$ 的绝对误差容限来确定最小的 $n$（记为 $n^\\star_{\\mathrm{GL}}(k)$），使得 $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$，同样地，确定最小的 $m$（记为 $m^\\star_{\\mathrm{F}}(k)$），使得 $E_{\\mathrm{F}}(k,m) \\le 10^{-12}$。如果指定集合中没有值满足该容限，则报告 $-1$。\n- 对每个 $k$，报告在测试的 $n$ 范围内 Gauss–Legendre 的最大绝对误差 $\\max_{n} E_{\\mathrm{GL}}(k,n)$，以及在测试的 $m$ 范围内 Filon 型方法的最大绝对误差 $\\max_{m} E_{\\mathrm{F}}(k,m)$。\n\n测试套件（角度以弧度为单位）：\n- $k = 0$,\n- $k = \\pi$,\n- $k = 50$,\n- $k = 200$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须为测试套件中的每个 $k$ 包含一个条目，顺序与上面列出的一致。\n- 对每个 $k$，输出列表 $[\\,n^\\star_{\\mathrm{GL}}(k),\\,m^\\star_{\\mathrm{F}}(k),\\,\\max_{n} E_{\\mathrm{GL}}(k,n),\\,\\max_{m} E_{\\mathrm{F}}(k,m)\\,]$。\n- 所有数值必须报告为纯小数（浮点数）或整数。不需要单位，因为所有量都是无量纲的，且角度以弧度为单位。\n- 所需输出结构的示例（使用占位符）：$[\\,[\\,n_1,m_1,e_{1,\\max}^{\\mathrm{GL}},e_{1,\\max}^{\\mathrm{F}}\\,],[\\,n_2,m_2,e_{2,\\max}^{\\mathrm{GL}},e_{2,\\max}^{\\mathrm{F}}\\,],\\dots]$。\n\n您的实现必须是一个完整的、可运行的程序，并且不得需要任何外部输入。",
            "solution": "该问题要求对两种数值求积方法——Gauss–Legendre 法和零阶 Filon 型法则——在求解典型振荡积分 $I(k) = \\int_{-1}^{1} \\cos(k x)\\,dx$ 时进行比较分析。该分析涉及实现这两种方法，计算它们相对于不同波数 $k$ 的精确解析解的绝对误差，并确定达到指定精度所需的计算量（节点数或子区间数）。\n\n### 1. 解析解\n\n第一步是求出积分的精确值，该值将作为误差计算的基准。我们使用微积分基本定理。\n\n对于非零角波数 $k > 0$：\n$$\nI(k) = \\int_{-1}^{1} \\cos(k x)\\,dx = \\left[ \\frac{\\sin(k x)}{k} \\right]_{-1}^{1} = \\frac{\\sin(k \\cdot 1)}{k} - \\frac{\\sin(k \\cdot (-1))}{k}\n$$\n利用性质 $\\sin(-x) = -\\sin(x)$，上式可简化为：\n$$\nI(k) = \\frac{\\sin(k) - (-\\sin(k))}{k} = \\frac{2\\sin(k)}{k}\n$$\n\n对于波数 $k=0$ 的特殊情况：\n$$\nI(0) = \\int_{-1}^{1} \\cos(0 \\cdot x)\\,dx = \\int_{-1}^{1} 1\\,dx = [x]_{-1}^{1} = 1 - (-1) = 2\n$$\n值得注意的是，$k>0$ 的解在 $k=0$ 处是连续的，因为 $\\lim_{k \\to 0} \\frac{2\\sin(k)}{k} = 2$，这与 $I(0)$ 相匹配。\n\n### 2. 方法一：Gauss–Legendre 求积\n\nGauss–Legendre 求积是一种在区间 $[-1, 1]$ 上近似积分的强大方法。其一般形式为：\n$$\n\\int_{-1}^{1} f(x)\\,dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n此处，$n$ 是节点数。节点 $x_i$ 是 $n$ 次 Legendre 多项式 $P_n(x)$ 的根，权重 $w_i$ 由正交多项式理论导出。该法则的一个关键性质是它对次数最高为 $2n-1$ 的任何多项式都是精确的。\n\n对于我们特定的积分，被积函数是 $f(x) = \\cos(kx)$。Gauss–Legendre 近似值 $I_{\\mathrm{GL}}(k,n)$ 为：\n$$\nI_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)\n$$\n当 $k=0$ 时，被积函数是 $f(x) = \\cos(0) = 1$，这是一个 0 次多项式。$n=1$ 的 Gauss-Legendre 法则对次数最高为 $2(1)-1=1$ 的多项式是精确的，因此它将精确地积分 $f(x)=1$。对于 $n \\ge 1$，该近似将是精确的。\n\n对于 $k > 0$，$\\cos(kx)$ 不是多项式。近似的精度取决于被积函数能被一个 $2n-1$ 次多项式表示得有多好。随着 $k$ 的增加，函数振荡得更快，需要更高次的多项式（因此需要更大的 $n$）才能达到给定的精度。绝对误差计算为 $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$。\n\n节点和权重将使用 `scipy` 库中的例程进行数值计算，这是标准做法。\n\n### 3. 方法二：Filon 型复合规则\n\nFilon 型方法专为形如 $\\int_{a}^{b} g(x) \\Omega(kx) dx$ 的振荡积分而设计，其中 $g(x)$ 是一个缓变振幅，而 $\\Omega(kx)$ 是一个快速振荡函数（例如 $\\cos(kx)$ 或 $\\sin(kx)$）。其核心思想是在子区间上用一个更简单的函数（如低次多项式）来近似 $g(x)$，然后精确地积分得到的乘积 $p(x)\\Omega(kx)$。\n\n问题指定了一个零阶复合规则：\n1. 将区间 $[-1, 1]$ 分成 $m$ 个均匀的子区间 $[x_j, x_{j+1}]$，每个子区间的长度为 $h = \\frac{2}{m}$，其中 $x_j = -1 + jh$。\n2. 在每个子区间上，将振幅函数 $g(x)$——在我们的例子中是 $g(x)=1$——近似为一个常数，该常数等于其在子区间中点处的值。\n3. 在每个子区间上精确地积分得到的近似值。\n\n对于积分 $I(k) = \\int_{-1}^{1} 1 \\cdot \\cos(kx) dx$，振幅是 $g(x) = 1$。用其中点值来近似这个常数函数，结果仍是常数 $1$ 本身。因此，在每个子区间 $[x_j, x_{j+1}]$ 上，积分的近似为：\n$$\n\\int_{x_j}^{x_{j+1}} (\\text{midpoint value of } g(x)) \\cdot \\cos(kx)\\,dx = \\int_{x_j}^{x_{j+1}} 1 \\cdot \\cos(kx)\\,dx\n$$\nFilon 型近似 $I_{\\mathrm{F}}(k,m)$ 是这些积分在所有 $m$ 个子区间上的总和：\n$$\nI_{\\mathrm{F}}(k,m) = \\sum_{j=0}^{m-1} \\int_{x_j}^{x_{j+1}} \\cos(kx)\\,dx\n$$\n根据定积分的可加性，这个和可以伸缩为整个定义域上的原始积分：\n$$\nI_{\\mathrm{F}}(k,m) = \\int_{x_0}^{x_m} \\cos(kx)\\,dx = \\int_{-1}^{1} \\cos(kx)\\,dx = I(k)\n$$\n这证明了一个关键结果：对于这个振幅函数是精确常数的特定问题，所规定的 Filon 型法则是对于任何子区间数 $m \\ge 1$ 和所有 $k$ 值都是**解析精确**的。因此，绝对误差 $E_{\\mathrm{F}}(k,m) = |I(k) - I_{\\mathrm{F}}(k,m)|$ 将为零，或一个仅受浮点精度限制的非常小的数。这意味着对于任何 $k$，达到容限所需的最小子区间数是 $m^\\star_{\\mathrm{F}}(k) = 1$，而在所有测试的 $m$ 值中的最大误差将约等于 $0$。\n\n### 4. 计算过程\n\n程序将为测试套件 $\\{0, \\pi, 50, 200\\}$ 中的每个 $k$ 执行以下步骤：\n\n1.  **计算精确值**：使用上面推导的解析公式计算 $I(k)$，并对 $k=0$ 进行特殊处理。\n2.  **评估 Gauss–Legendre 误差**：\n    *   初始化 $n^\\star_{\\mathrm{GL}} = -1$ 和 $\\max_{n} E_{\\mathrm{GL}} = 0$。\n    *   遍历 $n \\in \\{1, 2, 4, 8, 16, 32, 64, 128\\}$。\n    *   对于每个 $n$，获取 Gauss-Legendre 节点 $x_i$ 和权重 $w_i$。\n    *   计算近似值 $I_{\\mathrm{GL}}(k,n) = \\sum_{i=1}^{n} w_i \\cos(k x_i)$。\n    *   计算绝对误差 $E_{\\mathrm{GL}}(k,n) = |I(k) - I_{\\mathrm{GL}}(k,n)|$。\n    *   如果当前误差更大，则更新 $\\max_{n} E_{\\mathrm{GL}}$。\n    *   如果 $E_{\\mathrm{GL}}(k,n) \\le 10^{-12}$ 并且尚未设置 $n^\\star_{\\mathrm{GL}}$，则赋值 $n^\\star_{\\mathrm{GL}} = n$。\n3.  **评估 Filon 型误差**：\n    *   根据我们的分析发现，$I_{\\mathrm{F}}(k,m)$ 与 $I(k)$ 相同。\n    *   因此，$m^\\star_{\\mathrm{F}}(k) = 1$（$m$ 集合中的第一个值）。\n    *   对于所有的 $m$，误差 $E_{\\mathrm{F}}(k,m)$ 实际上是 $0$。最大误差 $\\max_{m} E_{\\mathrm{F}}$ 也为 $0$。\n4.  **整理和报告**：为当前的 $k$ 存储计算出的元组 $[n^\\star_{\\mathrm{GL}}, m^\\star_{\\mathrm{F}}, \\max_{n} E_{\\mathrm{GL}}, \\max_{m} E_{\\mathrm{F}}]$，然后继续处理测试套件中的下一个值。最后，将收集到的结果格式化为单行文本。",
            "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of Gauss-Legendre and Filon-type\n    quadrature for a canonical oscillatory integral from computational acoustics.\n    \"\"\"\n    \n    # Define the problem parameters\n    test_suite_k = [0.0, np.pi, 50.0, 200.0]\n    n_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    m_values = [1, 2, 4, 8, 16, 32, 64, 128]\n    tolerance = 1e-12\n\n    def exact_integral(k):\n        \"\"\"Computes the exact value of the integral I(k) = int_{-1}^{1} cos(kx) dx.\"\"\"\n        if k == 0.0:\n            return 2.0\n        else:\n            return 2.0 * np.sin(k) / k\n\n    def gauss_legendre_approx(k, n):\n        \"\"\"Computes the Gauss-Legendre quadrature approximation for I(k) with n nodes.\"\"\"\n        nodes, weights = roots_legendre(n)\n        integrand_values = np.cos(k * nodes)\n        return np.sum(weights * integrand_values)\n\n    def filon_type_approx(k, m):\n        \"\"\"\n        Computes the Filon-type quadrature approximation.\n        As derived in the solution, for f(x)=1, this method is analytically exact\n        for any m >= 1, and thus returns the exact integral value.\n        \"\"\"\n        return exact_integral(k)\n\n    all_results = []\n    for k in test_suite_k:\n        # Calculate the exact value for the current k\n        i_exact = exact_integral(k)\n\n        # --- Gauss-Legendre Analysis ---\n        n_star_gl = -1\n        max_err_gl = 0.0\n        for n in n_values:\n            i_gl = gauss_legendre_approx(k, n)\n            err_gl = np.abs(i_exact - i_gl)\n            \n            if err_gl > max_err_gl:\n                max_err_gl = err_gl\n            \n            if err_gl = tolerance and n_star_gl == -1:\n                n_star_gl = n\n\n        # --- Filon-type Analysis ---\n        m_star_f = -1\n        max_err_f = 0.0\n        for m in m_values:\n            # As derived, the Filon-type approximation for a constant amplitude of 1\n            # is identical to the exact integral. The error is thus 0 up to machine precision.\n            i_f = filon_type_approx(k, m)\n            err_f = np.abs(i_exact - i_f)\n\n            if err_f > max_err_f:\n                max_err_f = err_f\n\n            if err_f = tolerance and m_star_f == -1:\n                m_star_f = m\n        \n        # In the specific case for Filon method, m_star_f will always be the first\n        # element, 1, and max_err_f will be ~0 due to exactness.\n        # This explicit check handles the case where m_values might not start at 1.\n        if m_star_f == -1 and m_values:\n             # Fallback if no m met the tolerance, which shouldn't happen here.\n             pass\n\n        # Collect results for this k\n        all_results.append([n_star_gl, m_star_f, max_err_gl, max_err_f])\n\n    # Format the final output string exactly as required\n    # e.g., [[1, 1, 0.0, 0.0], [8, 1, 0.5103, 0.0], ...]\n    result_str = \"[\" + \",\".join([f\"[{res[0]},{res[1]},{res[2]},{res[3]}]\" for res in all_results]) + \"]\"\n    print(result_str)\n\nsolve()\n```"
        }
    ]
}