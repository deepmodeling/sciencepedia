{
    "hands_on_practices": [
        {
            "introduction": "为了掌握时间积分格式，我们首先从一个基本问题开始：数值稳定性。这个练习  将最简单的显式方法——前向欧拉法——应用于一个典型的标量衰减方程，通过这个过程，你将亲手推导出显式方法所固有的限制。理解这种条件稳定性是选择合适时间步长、确保计算不发散的第一步。",
            "id": "4024140",
            "problem": "在一个代表计算燃烧学中单步衰减过程的均匀、等温、充分混合的反应系统中，标量状态变量 $y(t)$（例如，自由基物质质量分数中的一个小扰动）的时间演化在局部由线性常微分方程（ODE）$y'(t) = \\lambda\\, y(t)$ 控制，其中 $\\lambda \\in \\mathbb{R}$ 且 $\\lambda  0$ 代表一个具有特征衰减时间尺度的化学汇。考虑使用显式前向欧拉（FE）方法对此 ODE 进行时间推进。从应用于线性测试方程的单步方法的绝对稳定性定义出发，并根据显式前向欧拉方法产生的离散更新，推导时间步长 $\\Delta t$ 需满足的条件，以保证当 $\\lambda$ 为实数且为负时，扰动幅值不会增长。然后，对于 $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$ 的特定情况，计算满足所推导的稳定性条件的最大时间步长 $\\Delta t$。将最终答案以秒为单位表示，并四舍五入至 $3$ 位有效数字。最终答案必须是一个实数。",
            "solution": "在尝试求解之前，对问题进行验证。\n\n### 第1步：提取已知条件\n- 控制性常微分方程（ODE）为 $y'(t) = \\lambda\\, y(t)$。\n- 参数 $\\lambda$ 是一个实数，满足 $\\lambda  0$。\n- 数值积分方案是显式前向欧拉（FE）方法。\n- 稳定性条件是扰动幅值不增长，即 $|y_{n+1}| \\leq |y_n|$。\n- 给定了一个特定情况 $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$。\n- 任务是推导时间步长 $\\Delta t$ 的稳定性条件，然后为给定的 $\\lambda$ 计算最大的 $\\Delta t$，并四舍五入至 $3$ 位有效数字。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学基础：** 该问题基于标准的线性测试方程 $y' = \\lambda y$，这是 ODE 数值方法稳定性分析的基石。显式前向欧拉方法是一种基本的数值方案。A-稳定性（或在本例中，其在实轴上的一个子集）的概念在数值分析领域，特别是对于计算燃烧学中出现的刚性方程，是核心概念。该问题在科学上是合理的。\n2.  **适定性：** 该问题是适定的。它要求一个标准的稳定性界限推导和随后的计算。推导过程得出一个唯一的不等式，计算得出一个唯一的、明确定义的数值答案。\n3.  **客观性：** 该问题使用来自数学和计算科学的精确、客观和标准的术语进行陈述。\n4.  **完整性和一致性：** 该问题提供了所有必要信息：控制方程、数值方法、参数 $\\lambda$ 的约束以及稳定性准则。没有矛盾之处。\n5.  **合理性：** $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$ 的值代表了 $10^{-6}\\ \\mathrm{s}$ 或 $1\\ \\mu\\mathrm{s}$ 的特征时间尺度，这对于燃烧过程中快速的化学反应（例如，自由基动力学）是物理上现实的。\n\n### 第3步：结论与行动\n该问题被认为是 **有效的**，因为它具有科学基础、适定且完整。将提供完整的解答。\n\n### 解答推导\n问题关注由线性常微分方程控制的标量 $y(t)$ 的时间演化：\n$$\ny'(t) = \\frac{dy}{dt} = \\lambda y(t)\n$$\n其中 $\\lambda$ 是一个实数负常数 ($\\lambda  0$)。我们希望使用显式前向欧拉（FE）方法对该方程进行数值求解。\n\n设 $y_n$ 是解 $y(t)$ 在离散时间 $t_n = n \\Delta t$ 处的数值近似，其中 $\\Delta t$ 是时间步长。FE 方法使用前向有限差分来近似导数 $y'(t_n)$：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} \\approx y'(t_n)\n$$\n将此代入在 $t_n$ 处取值的控制性 ODE，我们得到：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\lambda y_n\n$$\n重新整理此方程以求解 $y_{n+1}$，得到前向欧拉方法的离散更新规则：\n$$\ny_{n+1} = y_n + \\Delta t (\\lambda y_n)\n$$\n$$\ny_{n+1} = (1 + \\lambda \\Delta t) y_n\n$$\n此方程将下一时间步的解 $y_{n+1}$ 与当前时间步的解 $y_n$ 联系起来。项 $G = 1 + \\lambda \\Delta t$ 被称为放大因子，因为它决定了解的幅值如何从一步到下一步被放大（或衰减）。\n\n问题要求扰动幅值不增长。这转化为绝对稳定性条件，即数值解的幅值不能随时间增加。对于单步方法，这意味着：\n$$\n|y_{n+1}| \\le |y_n|\n$$\n将更新规则代入此不等式，我们得到：\n$$\n|(1 + \\lambda \\Delta t) y_n| \\le |y_n|\n$$\n假设 $y_n \\neq 0$，我们可以除以 $|y_n|$ 来得到关于放大因子 $G$ 的条件：\n$$\n|G| \\le 1 \\quad \\implies \\quad |1 + \\lambda \\Delta t| \\le 1\n$$\n这个绝对值不等式等价于下面这对不等式：\n$$\n-1 \\le 1 + \\lambda \\Delta t \\le 1\n$$\n为了找到关于 $\\Delta t$ 的条件，我们首先从不等式的所有部分减去 $1$：\n$$\n-2 \\le \\lambda \\Delta t \\le 0\n$$\n我们已知 $\\lambda  0$。时间步长 $\\Delta t$ 必须为正，所以 $\\Delta t > 0$。因此，乘积 $\\lambda \\Delta t$ 总是负的。这意味着不等式的右侧 $\\lambda \\Delta t \\le 0$ 自动满足。\n\n因此，方法的稳定性仅受不等式左侧的约束：\n$$\n-2 \\le \\lambda \\Delta t\n$$\n为了分离出 $\\Delta t$，我们除以 $\\lambda$。由于 $\\lambda$ 是负数，此操作会反转不等号的方向：\n$$\n\\frac{-2}{\\lambda} \\ge \\Delta t\n$$\n这可以更常规地写为：\n$$\n\\Delta t \\le -\\frac{2}{\\lambda}\n$$\n这就是推导出的，应用于给定 ODE（其中 $\\lambda$ 为实数负值）的前向欧拉方法保证稳定性的时间步长 $\\Delta t$ 的条件。\n\n现在，我们将此结果应用于 $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$ 的特定情况。满足稳定性条件的最大时间步长 $\\Delta t_{\\text{max}}$ 由等式给出：\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{\\lambda}\n$$\n代入给定的 $\\lambda$ 值：\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{-10^{6}\\ \\mathrm{s}^{-1}} = \\frac{2}{10^{6}}\\ \\mathrm{s} = 2 \\times 10^{-6}\\ \\mathrm{s}\n$$\n问题要求答案四舍五入至 $3$ 位有效数字。用科学记数法表示，即为 $2.00 \\times 10^{-6}$。",
            "answer": "$$\\boxed{2.00 \\times 10^{-6}}$$"
        },
        {
            "introduction": "虽然隐式格式（如 Crank-Nicolson 方法）通常具有无条件稳定性，但这并不意味着任何时间步长都能保证结果的准确性，尤其是在求解波动问题时。本练习  旨在揭示一个更微妙但至关重要的概念：数值色散，即数值波速与物理波速之间的差异。通过分析相位误差，你将学会如何为了保证波形传播的精度而选择时间步长，这是计算声学中的一项核心技能。",
            "id": "4122879",
            "problem": "考虑一维空间均匀介质中的线性声波方程，\n$$\n\\frac{\\partial^{2} p}{\\partial t^{2}} = c^{2} \\frac{\\partial^{2} p}{\\partial x^{2}},\n$$\n其中 $p$ 是声压，$c$ 是声速。在波数为 $k \\in \\mathbb{R}$ 的空间傅里叶变换下，每个傅里叶模态独立演化，并满足一个具有纯虚谱的线性常微分方程。等价地，对于任意固定的 $k$，复模态振幅 $y(t)$ 满足一阶线性常微分方程\n$$\n\\frac{d y}{d t} = i \\, \\omega \\, y, \\quad \\omega = c\\,|k|.\n$$\n你需要使用时间步长均匀（$\\Delta t  0$）的 Crank–Nicolson (梯形) 隐式时间积分器来对该模态进行时间推进。虽然该格式对于此类线性问题是无条件稳定的，但要准确捕捉波的传播需要足够的时间分辨率。\n\n仅从给定的控制方程和 Crank–Nicolson 方法作为常微分方程时间离散化的定义出发，推导容许的相对相速度误差与无量纲时间步长之间的前导阶小参数渐近关系。然后，在容许的相对相速度误差 $\\delta \\ll 1$ 很小的渐近区域内，确定每个物理周期所需的最小时间步数 $N_{\\min}(\\delta)$，以确保角频率为 $\\omega$ 的模态其相对相速度误差的绝对值不超过 $\\delta$。\n\n将你的最终答案表示为仅含 $\\delta$ 的单个闭式解析表达式。最终答案中不包含任何单位。如果引入了任何辅助量，请将其消去，以使最终表达式仅依赖于 $\\delta$。不需要进行数值四舍五入。",
            "solution": "问题陈述经过严格验证，确认有效。该问题具有科学依据，是适定的、客观的，并包含足够信息以推导出唯一且有意义的解。它代表了波现象数值分析中的一个标准问题。\n\n该问题要求分析当 Crank-Nicolson 时间积分格式应用于控制声波方程单个傅里叶模态演化的简谐振子方程时，所产生的数值相位误差。\n\n复模态振幅 $y(t)$ 的控制常微分方程如下：\n$$\n\\frac{d y}{d t} = i \\, \\omega \\, y\n$$\n其中 $i = \\sqrt{-1}$ 是虚数单位，$\\omega$ 是模态的实值角频率。\n\nCrank-Nicolson 方法，也称为梯形法则，用于对该方程进行时间离散化。设 $y_n$ 是 $y(n \\Delta t)$ 的数值近似，其中 $\\Delta t$ 是均匀的时间步长。该格式定义为：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\frac{1}{2} \\left( (i \\omega y_n) + (i \\omega y_{n+1}) \\right)\n$$\n这是一个关于 $y_{n+1}$ 的隐式格式。我们重新整理各项以求解 $y_{n+1}$：\n$$\ny_{n+1} - \\frac{i \\omega \\Delta t}{2} y_{n+1} = y_n + \\frac{i \\omega \\Delta t}{2} y_n\n$$\n$$\ny_{n+1} \\left( 1 - \\frac{i \\omega \\Delta t}{2} \\right) = y_n \\left( 1 + \\frac{i \\omega \\Delta t}{2} \\right)\n$$\n更新规则可以写成 $y_{n+1} = G_{num} y_n$，其中 $G_{num}$ 是数值放大因子：\n$$\nG_{num} = \\frac{1 + \\frac{i \\omega \\Delta t}{2}}{1 - \\frac{i \\omega \\Delta t}{2}}\n$$\n控制常微分方程的精确解在一个时间步长内的演化为 $y(t_{n+1}) = y(t_n) \\exp(i \\omega \\Delta t)$。因此，精确放大因子为 $G_{exact} = \\exp(i \\omega \\Delta t)$。\n\n数值格式引入了一个数值频率 $\\omega_{num}$，使得数值解根据有效放大因子 $G_{num} = \\exp(i \\omega_{num} \\Delta t)$ 进行演化。数值放大因子的相位是单个时间步长内的数值相位变化，即 $\\phi_{num} = \\omega_{num} \\Delta t$。精确放大因子的相位是 $\\phi_{exact} = \\omega \\Delta t$。\n\n数值放大因子 $G_{num}$ 是一个形式为 $(a+ib)/(a-ib)$ 的复数，其中 $a=1$，$b=\\omega \\Delta t / 2$。其模长为 $|G_{num}| = 1$，这证实了该格式是纯色散的，不引入数值耗散或放大。$G_{num}$ 的相位 $\\phi_{num}$ 由下式给出：\n$$\n\\phi_{num} = \\arg\\left(1 + \\frac{i \\omega \\Delta t}{2}\\right) - \\arg\\left(1 - \\frac{i \\omega \\Delta t}{2}\\right)\n$$\n使用关系式 $\\arg(x+iy) = \\arctan(y/x)$ 以及 $\\arctan(-z) = -\\arctan(z)$，我们得到：\n$$\n\\phi_{num} = \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right) - \\left(-\\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)\\right) = 2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)\n$$\n相对相速度误差，我们记为 $\\delta_{pv}$，定义为频率的相对误差：\n$$\n\\delta_{pv} = \\frac{\\omega_{num} - \\omega}{\\omega} = \\frac{\\omega_{num} \\Delta t - \\omega \\Delta t}{\\omega \\Delta t} = \\frac{\\phi_{num} - \\phi_{exact}}{\\phi_{exact}}\n$$\n代入相位的表达式，我们得到：\n$$\n\\delta_{pv} = \\frac{2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right) - \\omega \\Delta t}{\\omega \\Delta t} = \\frac{2 \\arctan\\left(\\frac{\\omega \\Delta t}{2}\\right)}{\\omega \\Delta t} - 1\n$$\n问题要求找到小误差下的前导阶渐近关系，这对应于小的无量纲时间步长 $\\omega \\Delta t \\ll 1$。令 $x = \\frac{\\omega \\Delta t}{2}$。条件 $\\omega \\Delta t \\ll 1$ 意味着 $x \\ll 1$。我们使用 $\\arctan(x)$ 在 $x=0$ 附近的泰勒级数展开：\n$$\n\\arctan(x) = x - \\frac{x^3}{3} + O(x^5)\n$$\n将此代入 $\\delta_{pv}$ 的表达式中：\n$$\n\\delta_{pv} = \\frac{2 \\left( x - \\frac{x^3}{3} + O(x^5) \\right)}{2x} - 1 = \\left( 1 - \\frac{x^2}{3} + O(x^4) \\right) - 1 = -\\frac{x^2}{3} + O(x^4)\n$$\n将 $x = \\frac{\\omega \\Delta t}{2}$ 代回：\n$$\n\\delta_{pv} \\approx -\\frac{1}{3} \\left(\\frac{\\omega \\Delta t}{2}\\right)^2 = -\\frac{(\\omega \\Delta t)^2}{12}\n$$\n这就是相对相速度误差和无量纲时间步长 $\\omega \\Delta t$ 之间的前导阶渐近关系。负号表示数值相速度小于物理相速度（相位滞后）。\n\n问题规定相对相速度误差的绝对值不得超过一个小的容许误差 $\\delta \\ll 1$。因此，我们要求 $|\\delta_{pv}| \\le \\delta$。使用渐近关系：\n$$\n\\frac{(\\omega \\Delta t)^2}{12} \\le \\delta\n$$\n这个不等式可以解出无量纲时间步长 $\\omega \\Delta t$：\n$$\n(\\omega \\Delta t)^2 \\le 12 \\delta \\implies \\omega \\Delta t \\le \\sqrt{12 \\delta} = 2 \\sqrt{3 \\delta}\n$$\n这个条件为给定模态 $\\omega$ 在满足误差容限 $\\delta$ 的情况下，对容许的时间步长 $\\Delta t$ 设定了上限。为了找到每个周期所需的最小时间步数，我们必须使用最大容许时间步长 $\\Delta t_{max}$。\n$$\n\\Delta t_{max} = \\frac{2 \\sqrt{3 \\delta}}{\\omega}\n$$\n波模态的物理周期是 $T = \\frac{2\\pi}{\\omega}$。每个周期的时间步数由 $N = \\frac{T}{\\Delta t}$ 给出。最小时间步数 $N_{min}$ 对应于最大时间步长 $\\Delta t_{max}$：\n$$\nN_{min}(\\delta) = \\frac{T}{\\Delta t_{max}} = \\frac{2\\pi / \\omega}{2 \\sqrt{3 \\delta} / \\omega}\n$$\n因子 $\\omega$ 被消去，我们得到 $N_{min}$ 仅作为 $\\delta$ 函数的最终表达式：\n$$\nN_{min}(\\delta) = \\frac{2\\pi}{2 \\sqrt{3 \\delta}} = \\frac{\\pi}{\\sqrt{3 \\delta}}\n$$\n在 $\\delta$ 很小的渐近极限下，该表达式给出了为确保相对相速度误差的绝对值不大于 $\\delta$ 所需的每个周期的最小时间步数。",
            "answer": "$$\\boxed{\\frac{\\pi}{\\sqrt{3 \\delta}}}$$"
        },
        {
            "introduction": "理论分析为我们提供了关于稳定性与准确性的深刻见解，但真正的理解来自于动手实践和验证。这个综合性练习  要求你编写代码，对多种时间积分格式（包括显式和隐式方法）进行数值实验。通过系统地减小时间步长并测量误差，你将能够凭经验验证这些格式的收敛阶，从而将理论知识与计算实践紧密联系起来。",
            "id": "4122854",
            "problem": "考虑在小扰动下的一维空间线性声学，其由质量和动量守恒定律支配，从而导出二阶波动方程。对于均匀介质中波数为 $k$、声速为 $c$（单位为 $\\mathrm{m/s}$）的单个傅里叶模式，位移幅值 $u(t)$ 满足常微分方程 $u''(t) + \\omega^2 u(t) = 0$，其中 $\\omega = c k$ 是角频率（单位为 $\\mathrm{rad/s}$）。这是因为空间傅里叶模式 $e^{\\mathrm{i} k x}$ 是空间部分的解，留下一个角频率为 $\\omega = c k$ 的时间振荡器。设初始条件为 $u(0) = u_0$ 和 $u'(0) = v_0$，其中 $u_0$ 和 $v_0$ 是无量纲幅值。精确解在所有时间内都是良定义且平滑的，您应将 $u(t)$ 视为无量纲量，时间 $t$ 的单位为秒（$\\mathrm{s}$）。\n\n您的任务是通过重复将时间步长 $\\Delta t$ 减半，来评估应用于此单模声学振荡器的多种时间积分方案的时间离散化误差收敛率。使用一种通过避免空间离散化来分离时间误差的公式。从振荡器 $u''(t) + \\omega^2 u(t) = 0$ 或其等效的一阶系统 $y'(t) = A y(t)$ 出发，根据第一性原理推导您的时间步进公式，其中 $y(t) = [u(t), v(t)]^\\top$ 且 $A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$，而 $v(t) = u'(t)$。\n\n实现以下时间积分方案：\n- 针对二阶方程 $u''(t) + \\omega^2 u(t) = 0$ 的显式二阶中心差分格式。\n- 针对一阶系统 $y'(t) = A y(t)$ 的隐式后向欧拉格式。\n- 针对一阶系统 $y'(t) = A y(t)$ 的隐式 Crank–Nicolson（隐式中点）格式。\n\n对于每个方案，通过将数值解与基于给定 $\\omega$、$u_0$ 和 $v_0$ 的精确解进行比较，计算在最终时间 $T$ 时 $u$ 的绝对误差。为评估观测到的时间精度阶数 $p$，对一系列减半的时间步长 $\\Delta t_i = \\Delta t_0 / 2^i$（其中 $i = 0, 1, \\dots, L-1$）及其对应的误差 $e(\\Delta t_i)$，进行 $\\log e(\\Delta t)$ 对 $\\log \\Delta t$ 的最小二乘拟合，并报告斜率 $p$。\n\n科学和数值细节：\n- 使用 $c$（单位为 $\\mathrm{m/s}$），$k$（单位为 $\\mathrm{rad/m}$），$\\omega$（单位为 $\\mathrm{rad/s}$），$t$（单位为 $\\mathrm{s}$），以及 $\\Delta t$（单位为 $\\mathrm{s}$）。幅值变量 $u$ 和 $v$ 是无量纲的。\n- 选择 $T$ 为 $T = N_0 \\Delta t_0$（对于给定的整数 $N_0$），这样对于每个减半级别 $i$，最终时间保持为 $T = (N_0 \\cdot 2^i) \\Delta t_i$。这确保了在不同减半级别上最终时间的一致对齐。\n- 对于显式中心差分格式，确保初始半步或等效的启动过程与底层振荡器一致地构建，以达到预期的二阶时间精度。\n\n您的程序必须实现以上内容，并为以下测试套件生成观测到的阶数 $p$。每个测试案例是一个参数元组 $(\\text{scheme}, c, f, u_0, v_0, \\Delta t_0 \\text{ rule}, N_0, L)$，其中 $\\text{scheme} \\in \\{\\text{SV}, \\text{BE}, \\text{CN}\\}$ 分别表示显式中心差分（Störmer–Verlet）格式 $\\text{SV}$、后向欧拉格式 $\\text{BE}$ 和 Crank–Nicolson 格式 $\\text{CN}$。角频率为 $\\omega = 2 \\pi f$（单位为 $\\mathrm{rad/s}$），波数为 $k = \\omega / c$（单位为 $\\mathrm{rad/m}$）。$\\Delta t_0 \\text{ rule}$ 指定了如何根据 $\\omega$ 设置 $\\Delta t_0$。\n\n测试套件：\n- 案例 $1$：$(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 案例 $2$：$(\\text{BE}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 案例 $3$：$(\\text{CN}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n- 案例 $4$：$(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1.9 / \\omega, N_0 = 80, L = 5)$，探测中心差分格式的显式稳定性边界附近，其稳定性条件为 $\\Delta t \\omega  2$。\n- 案例 $5$：$(\\text{CN}, c = 343, f = 8000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$。\n\n您的程序应使用对 $L$ 个层级的 $\\log e(\\Delta t)$ 对 $\\log \\Delta t$ 的最小二乘拟合，计算每个案例的观测阶数 $p$，然后生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result1},\\text{result2},\\text{result3}]$）。每个结果必须是对应于指定案例的估计阶数的浮点数（十进制形式），无单位。",
            "solution": "该问题要求评估应用于单模声学振荡器方程的三种不同时间积分方案的时间收敛率。分析过程包括实现这些方案，计算在一系列逐渐减小的时间步长 $\\Delta t$ 下，数值解在固定最终时间 $T$ 与精确解的误差，并通过对误差的对数与时间步长的对数进行最小二乘拟合来确定观测到的精度阶数 $p$。\n\n首先，我们建立控制常微分方程（ODE）的精确解析解，该解作为误差计算的基准。二阶ODE由下式给出：\n$$u''(t) + \\omega^2 u(t) = 0$$\n初始条件为 $u(0) = u_0$ 和 $u'(0) = v_0$。通解形式为 $u(t) = C_1 \\cos(\\omega t) + C_2 \\sin(\\omega t)$。应用初始条件：\n$u(0) = C_1 = u_0$\n$u'(t) = -\\omega C_1 \\sin(\\omega t) + \\omega C_2 \\cos(\\omega t) \\implies u'(0) = \\omega C_2 = v_0 \\implies C_2 = v_0/\\omega$。\n因此，位移 $u(t)$ 和速度 $v(t) = u'(t)$ 的精确解为：\n$$u(t) = u_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t)$$\n$$v(t) = -u_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$$\n这些将用于计算最终时间 $T$ 时的数值解误差。\n\n接下来，我们推导数值方案。时间被离散化为 $t_n = n \\Delta t$，其中 $u^n \\approx u(t_n)$。\n\n**1. 显式二阶中心差分（Störmer–Verlet）格式 (SV)**\n此方案直接离散化二阶ODE $u'' = -\\omega^2 u$。二阶导数 $u''(t_n)$ 使用二阶中心差分近似：\n$$\\frac{u^{n+1} - 2u^n + u^{n-1}}{(\\Delta t)^2} = -\\omega^2 u^n + O((\\Delta t)^2)$$\n整理以求解 $u^{n+1}$，得到显式时间步进公式：\n$$u^{n+1} = (2 - (\\omega \\Delta t)^2)u^n - u^{n-1}$$\n这是一个两步法，需要两个初始值 $u^0$ 和 $u^1$ 来启动迭代。\n$u^0 = u(0) = u_0$。\n为使方案具有全局二阶精度，$u^1$ 必须以至少二阶精度计算。我们使用在 $t=0$ 附近的泰勒展开：\n$$u(\\Delta t) = u(0) + \\Delta t u'(0) + \\frac{(\\Delta t)^2}{2} u''(0) + O((\\Delta t)^3)$$\n代入初始条件和来自ODE的 $u''(0) = -\\omega^2 u(0) = -\\omega^2 u_0$：\n$$u^1 = u_0 + v_0 \\Delta t - \\frac{(\\omega \\Delta t)^2}{2} u_0$$\n这个启动过程确保了整个方法达到其理论上的二阶精度。此方案是条件稳定的，要求 $|\\omega \\Delta t| \\le 2$。\n\n**2. 隐式后向欧拉格式 (BE)**\n此方案应用于等效的一阶系统 $y'(t) = Ay(t)$，其中 $y(t) = [u(t), v(t)]^\\top$，矩阵 $A$ 为：\n$$A = \\begin{bmatrix} 0  1 \\\\ -\\omega^2  0 \\end{bmatrix}$$\n后向欧拉方法由以下公式定义：\n$$y^{n+1} = y^n + \\Delta t A y^{n+1}$$\n这是一个隐式方案，需要我们求解 $y^{n+1}$：\n$$(I - \\Delta t A) y^{n+1} = y^n \\implies y^{n+1} = (I - \\Delta t A)^{-1} y^n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。我们计算矩阵 $(I - \\Delta t A)$ 的逆：\n$$I - \\Delta t A = \\begin{bmatrix} 1  -\\Delta t \\\\ \\omega^2 \\Delta t  1 \\end{bmatrix}$$\n其逆矩阵为：\n$$(I - \\Delta t A)^{-1} = \\frac{1}{1 + (\\omega \\Delta t)^2} \\begin{bmatrix} 1  \\Delta t \\\\ -\\omega^2 \\Delta t  1 \\end{bmatrix}$$\n状态向量 $y^n = [u^n, v^n]^\\top$ 使用 $y^0 = [u_0, v_0]^\\top$ 初始化并迭代更新。后向欧拉格式是无条件稳定的，但只有一阶精度，即 $p=1$。\n\n**3. 隐式 Crank–Nicolson 格式 (CN)**\nCrank-Nicolson 格式也是一种用于一阶系统的隐式方法，定义为：\n$$y^{n+1} = y^n + \\frac{\\Delta t}{2} (A y^n + A y^{n+1})$$\n它在中点 $t_{n+1/2}$ 处近似导数。求解 $y^{n+1}$：\n$$(I - \\frac{\\Delta t}{2} A) y^{n+1} = (I + \\frac{\\Delta t}{2} A) y^n \\implies y^{n+1} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) y^n$$\n放大矩阵 $G = (I - \\frac{\\Delta t}{2} A)^{-1} (I + \\frac{\\Delta t}{2} A)$ 是：\n$$G = \\frac{1}{1 + \\frac{(\\omega \\Delta t)^2}{4}} \\begin{bmatrix} 1 - \\frac{(\\omega \\Delta t)^2}{4}  \\Delta t \\\\ -\\omega^2 \\Delta t  1 - \\frac{(\\omega \\Delta t)^2}{4} \\end{bmatrix}$$\n更新规则为 $y^{n+1} = G y^n$。此方案是无条件稳定的，且具有二阶精度（$p=2$）。\n\n**收敛率分析**\n对于每个测试案例，我们为一系列 $L$ 个时间步长 $\\Delta t_i = \\Delta t_0 / 2^i$（其中 $i=0, 1, \\dots, L-1$）计算数值解及其误差。步数调整为 $N_i = N_0 \\cdot 2^i$，以保持最终时间 $T = N_i \\Delta t_i = N_0 \\Delta t_0$ 恒定。在时间 $T$ 的绝对误差为 $e(\\Delta t_i) = |u_{\\text{numerical}}(T) - u_{\\text{exact}}(T)|$。理论收敛关系为 $e(\\Delta t) \\approx C (\\Delta t)^p$，其中 $p$ 是精度阶数。取对数得：\n$$\\log(e) \\approx \\log(C) + p \\log(\\Delta t)$$\n这是 $\\log(e)$ 和 $\\log(\\Delta t)$ 之间的线性关系，斜率为 $p$。我们通过对数据点 $(\\log(\\Delta t_i), \\log(e_i))$（其中 $i=0, \\dots, L-1$）进行线性最小二乘拟合来计算斜率。所得斜率即为在指定测试条件下该方案的观测精度阶数。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_order(case_params):\n    \"\"\"\n    Calculates the observed order of accuracy for a given numerical scheme and parameters.\n    \n    Args:\n        case_params (tuple): A tuple containing the test case parameters:\n            (scheme, c, f, u0, v0, dt0_rule_val, N0, L).\n\n    Returns:\n        float: The observed order of accuracy 'p'.\n    \"\"\"\n    scheme, c, f, u0, v0, dt0_rule_val, N0, L = case_params\n\n    omega = 2.0 * np.pi * f\n    dt0 = dt0_rule_val / omega\n    T = N0 * dt0\n\n    log_dts = []\n    log_errors = []\n\n    # Calculate exact solution at time T for error comparison\n    if omega == 0:\n        u_exact = u0 + v0 * T\n    else:\n        u_exact = u0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n\n    # Loop over refinement levels\n    for i in range(L):\n        dt_i = dt0 / (2**i)\n        N_i = int(N0 * (2**i))\n\n        u_numerical = 0.0\n        if scheme == 'SV':\n            # Störmer-Verlet (Central Difference)\n            u_prev = u0\n            # Second-order accurate starting step\n            u_curr = u0 + v0 * dt_i - 0.5 * (omega**2) * u0 * (dt_i**2)\n            \n            if N_i == 0:\n                 u_numerical = u0\n            elif N_i == 1:\n                u_numerical = u_curr\n            else:\n                for _ in range(N_i - 1):\n                    u_next = (2.0 - (omega * dt_i)**2) * u_curr - u_prev\n                    u_prev = u_curr\n                    u_curr = u_next\n                u_numerical = u_curr\n\n        elif scheme == 'BE':\n            # Backward Euler\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            denom = 1.0 + (omega * dt_i)**2\n            update_matrix = np.array([\n                [1.0, dt_i],\n                [-omega2 * dt_i, 1.0]\n            ], dtype=np.float64) / denom\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        elif scheme == 'CN':\n            # Crank-Nicolson\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            term = (omega * dt_i)**2 / 4.0\n            denom = 1.0 + term\n            \n            m11_m22 = (1.0 - term) / denom\n            m12 = dt_i / denom\n            m21 = -omega2 * dt_i / denom\n            \n            update_matrix = np.array([\n                [m11_m22, m12],\n                [m21, m11_m22]\n            ], dtype=np.float64)\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        error = np.abs(u_numerical - u_exact)\n        \n        # Avoid log(0) issues for very small errors.\n        if error > np.finfo(float).tiny:\n            log_dts.append(np.log(dt_i))\n            log_errors.append(np.log(error))\n\n    # Perform linear regression if there are enough points for a fit.\n    if len(log_dts) > 1:\n        p, _ = np.polyfit(log_dts, log_errors, 1)\n        return p\n    else:\n        return np.nan # Return NaN if fit is not possible.\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (scheme, c, f, u0, v0, dt0_rule_val, N0, L)\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('BE', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('CN', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.9, 80, 5),\n        ('CN', 343.0, 8000.0, 1.0, 0.0, 1.0, 80, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = calculate_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}