{
    "hands_on_practices": [
        {
            "introduction": "To begin our practical exploration, we will analyze the stability of the most fundamental explicit time integration scheme: the Forward Euler method. By applying it to the scalar test equation $y' = \\lambda y$, which models simple exponential decay, you will derive the strict limitation on the time step $\\Delta t$ required to prevent the numerical solution from exploding. This exercise is foundational because it crystallizes the concept of *conditional stability* and reveals why explicit methods face challenges with 'stiff' problems, where physical phenomena occur on vastly different time scales. ",
            "id": "4024140",
            "problem": "In a homogeneous, isothermal, well-mixed reactive system representative of a single-step decay process in computational combustion, the temporal evolution of a scalar state variable $y(t)$ (for example, a small perturbation in a radical species mass fraction) is governed locally by the linear ordinary differential equation (ODE) $y'(t) = \\lambda\\, y(t)$, where $\\lambda \\in \\mathbb{R}$ and $\\lambda < 0$ represents a chemical sink with a characteristic decay time scale. Consider advancing this ODE in time using the explicit forward Euler (FE) method. Starting from the definition of absolute stability for one-step methods applied to the linear test equation and from the discrete update produced by explicit forward Euler, derive the condition on the time step $\\Delta t$ that guarantees that perturbations do not grow in magnitude when $\\lambda$ is real and negative. Then, for the specific case $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$, compute the largest $\\Delta t$ that satisfies the derived stability condition. Express your final answer in seconds and round your answer to 3 significant figures. The final answer must be a single real number.",
            "solution": "The problem is subjected to validation before a solution is attempted.\n\n### Step 1: Extract Givens\n- The governing ordinary differential equation (ODE) is $y'(t) = \\lambda\\, y(t)$.\n- The parameter $\\lambda$ is a real number such that $\\lambda < 0$.\n- The numerical integration scheme is the explicit forward Euler (FE) method.\n- The condition for stability is that perturbations do not grow in magnitude, which implies $|y_{n+1}| \\leq |y_n|$.\n- A specific case is given with $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$.\n- The task is to derive the stability condition on the time step $\\Delta t$ and then compute the largest $\\Delta t$ for the given $\\lambda$, rounded to 3 significant figures.\n\n### Step 2: Validate Using Extracted Givens\n1.  **Scientific Grounding:** The problem is based on the standard linear test equation $y' = \\lambda y$, which is a cornerstone for the stability analysis of numerical methods for ODEs. The explicit forward Euler method is a fundamental numerical scheme. The concept of A-stability (or in this case, a subset of it for the real line) is central to the field of numerical analysis, particularly for stiff equations as found in computational combustion. The problem is scientifically sound.\n2.  **Well-Posedness:** The problem is well-posed. It asks for a standard derivation of a stability bound and a subsequent calculation. The derivation leads to a unique inequality and the calculation yields a single, well-defined numerical answer.\n3.  **Objectivity:** The problem is stated using precise, objective, and standard terminology from mathematics and computational science.\n4.  **Completeness and Consistency:** The problem provides all necessary information: the governing equation, the numerical method, the constraints on the parameter $\\lambda$, and the stability criterion. There are no contradictions.\n5.  **Plausibility:** The value of $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$ represents a characteristic time scale of $10^{-6}\\ \\mathrm{s}$, or $1\\ \\mu\\mathrm{s}$, which is physically realistic for fast chemical reactions (e.g., radical kinetics) in combustion processes.\n\n### Step 3: Verdict and Action\nThe problem is deemed **valid** as it is scientifically grounded, well-posed, and complete. A full solution will be provided.\n\n### Solution Derivation\nThe problem concerns the temporal evolution of a scalar quantity $y(t)$ governed by the linear ordinary differential equation:\n$$\ny'(t) = \\frac{dy}{dt} = \\lambda y(t)\n$$\nwhere $\\lambda$ is a real, negative constant ($\\lambda < 0$). We wish to solve this equation numerically using the explicit forward Euler (FE) method.\n\nLet $y_n$ be the numerical approximation of the solution $y(t)$ at a discrete time $t_n = n \\Delta t$, where $\\Delta t$ is the time step. The FE method approximates the derivative $y'(t_n)$ using a forward finite difference:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} \\approx y'(t_n)\n$$\nSubstituting this into the governing ODE evaluated at $t_n$, we get:\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = \\lambda y_n\n$$\nRearranging this equation to solve for $y_{n+1}$ gives the discrete update rule for the forward Euler method:\n$$\ny_{n+1} = y_n + \\Delta t (\\lambda y_n)\n$$\n$$\ny_{n+1} = (1 + \\lambda \\Delta t) y_n\n$$\nThis equation relates the solution at the next time step, $y_{n+1}$, to the solution at the current time step, $y_n$. The term $G = 1 + \\lambda \\Delta t$ is known as the amplification factor, as it determines how the magnitude of the solution is amplified (or damped) from one step to the next.\n\nThe problem requires that perturbations do not grow in magnitude. This translates to the absolute stability condition, which states that the magnitude of the numerical solution must not increase over time. For a one-step method, this means:\n$$\n|y_{n+1}| \\le |y_n|\n$$\nSubstituting the update rule into this inequality, we have:\n$$\n|(1 + \\lambda \\Delta t) y_n| \\le |y_n|\n$$\nAssuming $y_n \\neq 0$, we can divide by $|y_n|$ to get the condition on the amplification factor $G$:\n$$\n|G| \\le 1 \\quad \\implies \\quad |1 + \\lambda \\Delta t| \\le 1\n$$\nThis absolute value inequality is equivalent to the following pair of inequalities:\n$$\n-1 \\le 1 + \\lambda \\Delta t \\le 1\n$$\nTo find the condition on $\\Delta t$, we first subtract $1$ from all parts of the inequality:\n$$\n-2 \\le \\lambda \\Delta t \\le 0\n$$\nWe are given that $\\lambda < 0$. The time step $\\Delta t$ must be positive, so $\\Delta t > 0$. Consequently, the product $\\lambda \\Delta t$ is always negative. This means the right-hand side of the inequality, $\\lambda \\Delta t \\le 0$, is automatically satisfied.\n\nThe stability of the method is therefore constrained only by the left-hand side of the inequality:\n$$\n-2 \\le \\lambda \\Delta t\n$$\nTo isolate $\\Delta t$, we divide by $\\lambda$. Since $\\lambda$ is negative, this operation reverses the direction of the inequality sign:\n$$\n\\frac{-2}{\\lambda} \\ge \\Delta t\n$$\nThis can be written more conventionally as:\n$$\n\\Delta t \\le -\\frac{2}{\\lambda}\n$$\nThis is the derived condition on the time step $\\Delta t$ that guarantees stability for the forward Euler method applied to the given ODE with real, negative $\\lambda$.\n\nNow, we apply this result to the specific case where $\\lambda = -10^{6}\\ \\mathrm{s}^{-1}$. The largest time step, $\\Delta t_{\\text{max}}$, that satisfies the stability condition is given by the equality:\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{\\lambda}\n$$\nSubstituting the given value of $\\lambda$:\n$$\n\\Delta t_{\\text{max}} = -\\frac{2}{-10^{6}\\ \\mathrm{s}^{-1}} = \\frac{2}{10^{6}}\\ \\mathrm{s} = 2 \\times 10^{-6}\\ \\mathrm{s}\n$$\nThe problem requires the answer to be rounded to 3 significant figures. In scientific notation, this is $2.00 \\times 10^{-6}$.",
            "answer": "$$\\boxed{2.00 \\times 10^{-6}}$$"
        },
        {
            "introduction": "Having seen the limitations of an explicit scheme, we now turn to its implicit counterpart, the Backward Euler method. This practice moves from a simple ODE to a partial differential equation—the heat equation—which is a prototype for dissipative processes in physics and engineering. You will employ the powerful technique of von Neumann stability analysis to prove that the Backward Euler scheme is *unconditionally stable* for this problem, meaning the time step $\\Delta t$ is not restricted by stability concerns.  This analysis directly contrasts with the previous exercise and demonstrates the primary motivation for using implicit methods, despite their increased computational cost per step.",
            "id": "3952009",
            "problem": "Consider homogeneous one-dimensional heat conduction on a ring of length $L$ with periodic boundary conditions, governed by the Partial Differential Equation (PDE) $ \\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^{2} T}{\\partial x^{2}} $, where $T$ is temperature and $\\alpha>0$ is thermal diffusivity. Discretize the spatial domain into $N$ uniformly spaced grid points with spacing $\\Delta x = \\frac{L}{N}$, and approximate the spatial second derivative at grid index $i$ by the standard second-order central difference. This yields a semi-discrete Ordinary Differential Equation (ODE) system of the form $ \\frac{\\mathrm{d} T_{i}}{\\mathrm{d} t} = \\frac{\\alpha}{\\Delta x^{2}}\\left(T_{i+1} - 2 T_{i} + T_{i-1}\\right) $. Advance this system in time using the Backward Euler (BE) scheme with time step $\\Delta t>0$, so that $T_{i}^{n+1}$ is obtained implicitly from $T_{i}^{n}$.\n\nPerform a von Neumann (vN) stability analysis by considering a single discrete Fourier mode of the form $T_{i}^{n} = \\hat{T}^{n} \\exp(\\mathrm{i}\\,\\theta i)$, where $\\mathrm{i}$ is the imaginary unit, $\\theta \\in [0,2\\pi)$ is the dimensionless grid frequency, and $\\hat{T}^{n}$ is the mode amplitude at time level $n$. Derive the amplification factor $G(\\theta)$ defined by $\\hat{T}^{n+1} = G(\\theta)\\,\\hat{T}^{n}$ as a function of $\\alpha$, $\\Delta t$, $\\Delta x$, and $\\theta$, and use this to determine the supremum of $|G(\\theta)|$ over all $\\theta \\in [0,2\\pi)$ and all $\\Delta t>0$.\n\nReport the supremum value as a single real number without units. No rounding is needed.",
            "solution": "The problem requires a von Neumann stability analysis for the one-dimensional heat equation discretized using a second-order central difference in space and the Backward Euler (BE) scheme in time. The objective is to derive the amplification factor $G(\\theta)$ and determine its supremum over the specified parameter space.\n\nThe semi-discrete form of the heat equation at grid point $i$ is given as:\n$$\n\\frac{\\mathrm{d} T_{i}}{\\mathrm{d} t} = \\frac{\\alpha}{\\Delta x^{2}}\\left(T_{i+1} - 2 T_{i} + T_{i-1}\\right)\n$$\nwhere $T_i(t)$ is the temperature at grid point $i$ and time $t$.\n\nThe Backward Euler scheme advances the solution from time level $n$ to $n+1$ by evaluating the spatial derivative term at the future time level, $n+1$. Applying this to the semi-discrete equation yields the fully discrete form:\n$$\n\\frac{T_{i}^{n+1} - T_{i}^{n}}{\\Delta t} = \\frac{\\alpha}{\\Delta x^{2}}\\left(T_{i+1}^{n+1} - 2 T_{i}^{n+1} + T_{i-1}^{n+1}\\right)\n$$\nHere, $T_i^n$ denotes the temperature at grid point $i$ and time level $n$.\n\nTo perform the von Neumann stability analysis, we substitute a single discrete Fourier mode, $T_{i}^{n} = \\hat{T}^{n} \\exp(\\mathrm{i}\\,\\theta i)$, into the fully discrete equation. The terms at different grid points and time levels become:\n- $T_{i}^{n} = \\hat{T}^{n} \\exp(\\mathrm{i}\\,\\theta i)$\n- $T_{i}^{n+1} = \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i)$\n- $T_{i+1}^{n+1} = \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta (i+1)) = \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) \\exp(\\mathrm{i}\\,\\theta)$\n- $T_{i-1}^{n+1} = \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta (i-1)) = \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) \\exp(-\\mathrm{i}\\,\\theta)$\n\nSubstituting these expressions into the BE discrete equation gives:\n$$\n\\frac{\\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) - \\hat{T}^{n} \\exp(\\mathrm{i}\\,\\theta i)}{\\Delta t} = \\frac{\\alpha}{\\Delta x^{2}}\\left( \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) \\exp(\\mathrm{i}\\,\\theta) - 2 \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) + \\hat{T}^{n+1} \\exp(\\mathrm{i}\\,\\theta i) \\exp(-\\mathrm{i}\\,\\theta) \\right)\n$$\nThe common factor $\\exp(\\mathrm{i}\\,\\theta i)$ can be canceled from all terms, which isolates the evolution of the mode amplitude $\\hat{T}$:\n$$\n\\frac{\\hat{T}^{n+1} - \\hat{T}^{n}}{\\Delta t} = \\frac{\\alpha}{\\Delta x^{2}} \\hat{T}^{n+1} \\left( \\exp(\\mathrm{i}\\,\\theta) - 2 + \\exp(-\\mathrm{i}\\,\\theta) \\right)\n$$\nUsing Euler's identity, $\\exp(\\mathrm{i}\\,\\theta) + \\exp(-\\mathrm{i}\\,\\theta) = 2\\cos(\\theta)$, the term in the parenthesis simplifies:\n$$\n\\exp(\\mathrm{i}\\,\\theta) - 2 + \\exp(-\\mathrm{i}\\,\\theta) = 2\\cos(\\theta) - 2 = -2(1-\\cos(\\theta))\n$$\nFurther using the half-angle trigonometric identity, $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$, we get:\n$$\n-2(1-\\cos(\\theta)) = -4\\sin^2\\left(\\frac{\\theta}{2}\\right)\n$$\nSubstituting this back into the equation for the amplitudes:\n$$\n\\frac{\\hat{T}^{n+1} - \\hat{T}^{n}}{\\Delta t} = - \\frac{4\\alpha}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right) \\hat{T}^{n+1}\n$$\nThe amplification factor $G(\\theta)$ is defined by the relation $\\hat{T}^{n+1} = G(\\theta)\\,\\hat{T}^{n}$. To find $G(\\theta)$, we rearrange the equation to solve for the ratio $\\hat{T}^{n+1}/\\hat{T}^{n}$:\n$$\n\\hat{T}^{n+1} - \\hat{T}^{n} = - \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right) \\hat{T}^{n+1}\n$$\n$$\n\\hat{T}^{n} = \\hat{T}^{n+1} \\left( 1 + \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right) \\right)\n$$\n$$\nG(\\theta) = \\frac{\\hat{T}^{n+1}}{\\hat{T}^{n}} = \\frac{1}{1 + \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right)}\n$$\nThis is the expression for the amplification factor as a function of $\\alpha$, $\\Delta t$, $\\Delta x$, and $\\theta$.\n\nThe problem asks for the supremum of the magnitude of $G(\\theta)$ over all $\\theta \\in [0, 2\\pi)$ and $\\Delta t > 0$. First, we analyze $|G(\\theta)|$.\nThe parameters $\\alpha$, $\\Delta t$, and $\\Delta x^2$ are all positive. The term $\\sin^2(\\theta/2)$ is non-negative. Therefore, the entire denominator is real and greater than or equal to $1$:\n$$\n1 + \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right) \\ge 1\n$$\nThis implies that $G(\\theta)$ is a real number satisfying $0 < G(\\theta) \\le 1$. Thus, $|G(\\theta)| = G(\\theta)$.\n\nWe want to find the supremum of the function:\n$$\nf(\\theta, \\Delta t) = |G(\\theta)| = \\frac{1}{1 + \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right)}\n$$\nover the domain $\\theta \\in [0, 2\\pi)$ and $\\Delta t > 0$.\nTo maximize $f(\\theta, \\Delta t)$, we must minimize its denominator. The denominator is minimized when the term $\\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right)$ is minimized. This term is a product of non-negative factors and is minimized when it equals $0$.\n\nThis minimum occurs under two conditions:\n1.  When $\\sin^2(\\theta/2) = 0$. In the domain $\\theta \\in [0, 2\\pi)$, this is true only for $\\theta = 0$. For this value, the amplification factor is:\n    $$\n    |G(0)| = \\frac{1}{1 + \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2(0)} = \\frac{1}{1 + 0} = 1\n    $$\n    This holds for any $\\Delta t > 0$.\n\n2.  For a fixed $\\theta \\in (0, 2\\pi)$, so that $\\sin^2(\\theta/2) > 0$, we consider the limit as $\\Delta t \\to 0^+$. The denominator term approaches $0$:\n    $$\n    \\lim_{\\Delta t \\to 0^+} \\frac{4\\alpha \\Delta t}{\\Delta x^{2}} \\sin^2\\left(\\frac{\\theta}{2}\\right) = 0\n    $$\n    Therefore, the limit of $|G(\\theta)|$ is:\n    $$\n    \\lim_{\\Delta t \\to 0^+} |G(\\theta)| = \\frac{1}{1 + 0} = 1\n    $$\n\nIn all cases, the value of $|G(\\theta)|$ is bounded above by $1$. This value, $1$, is actually achieved for all $\\Delta t > 0$ when $\\theta=0$. Therefore, the maximum value of $|G(\\theta)|$ over the given domain is $1$. The supremum of a set is the least upper bound, and since the value $1$ is attained, the supremum is also $1$.\n\nThis result demonstrates the unconditional stability of the Backward Euler scheme for the heat equation, as $|G(\\theta)| \\le 1$ for all valid parameters. The supremum of the amplification factor's magnitude is unity.",
            "answer": "$$\\boxed{1}$$"
        },
        {
            "introduction": "Theory is essential, but a computational scientist must also be able to translate it into practice. This final exercise bridges that gap by asking you to implement and test several time integration schemes for a model acoustic wave problem. By writing code to perform a numerical convergence study, you will empirically verify the theoretical order of accuracy for explicit and implicit methods.  This hands-on task develops critical programming and analysis skills, demonstrating that even for unconditionally stable schemes, the choice of time step remains crucial for achieving an accurate solution.",
            "id": "4122854",
            "problem": "Consider linear acoustics in one spatial dimension under small perturbations, governed by conservation of mass and momentum leading to the second-order wave equation. For a single Fourier mode with wavenumber $k$ in a homogeneous medium with speed of sound $c$ (in $\\mathrm{m/s}$), the displacement amplitude $u(t)$ satisfies the ordinary differential equation\n$$u''(t) + \\omega^2 u(t) = 0$$\nwhere $\\omega = c k$ is the angular frequency (in $\\mathrm{rad/s}$). This follows from the fact that a spatial Fourier mode $e^{\\mathrm{i} k x}$ solves the spatial part, leaving a temporal oscillator with $\\omega = c k$. Let the initial conditions be $u(0) = u_0$ and $u'(0) = v_0$, with $u_0$ and $v_0$ dimensionless amplitudes. The exact solution is well-defined and smooth for all time, and you should treat $u(t)$ as dimensionless and time $t$ in $\\mathrm{s}$.\n\nYour task is to assess time-discretization error convergence rates for multiple time integration schemes applied to this single-mode acoustic oscillator by halving the time step $\\Delta t$ repeatedly. Use a formulation that isolates temporal error by avoiding spatial discretization. Derive your time-stepping formulas from first principles starting with the oscillator $u''(t) + \\omega^2 u(t) = 0$ or its equivalent first-order system $y'(t) = A y(t)$ with $\\mathbf{y}(t) = [u(t), v(t)]^\\top$ and $$A = \\begin{bmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{bmatrix}$$, where $v(t) = u'(t)$.\n\nImplement the following time integration schemes:\n- An explicit second-order central-difference scheme for the second-order equation $u''(t) + \\omega^2 u(t) = 0$.\n- An implicit backward Euler scheme for the first-order system $y'(t) = A y(t)$.\n- An implicit Crank–Nicolson (implicit midpoint) scheme for the first-order system $y'(t) = A y(t)$.\n\nFor each scheme, compute the absolute error in $u$ at a final time $T$ by comparing the numerical solution to the exact solution based on the given $\\omega$, $u_0$, and $v_0$. To assess the observed order of accuracy $p$ in time, perform a least-squares fit of $\\log e(\\Delta t)$ against $\\log \\Delta t$ over a sequence of halved time steps $\\Delta t_i = \\Delta t_0 / 2^i$ for $i = 0, 1, \\dots, L-1$, with corresponding errors $e(\\Delta t_i)$, and report the slope $p$.\n\nScientific and numerical details:\n- Use $c$ in $\\mathrm{m/s}$, $k$ in $\\mathrm{rad/m}$, $\\omega$ in $\\mathrm{rad/s}$, $t$ in $\\mathrm{s}$, and $\\Delta t$ in $\\mathrm{s}$. The amplitude variables $u$ and $v$ are dimensionless.\n- Choose $T$ to be $T = N_0 \\Delta t_0$ for a given integer $N_0$, so that for each halving level $i$ the final time remains $T = (N_0 \\cdot 2^i) \\Delta t_i$ exactly. This ensures consistent final-time alignment across halving levels.\n- For the explicit central-difference scheme, ensure that the initial half-step or equivalent starting procedure is constructed consistently with the underlying oscillator to achieve the intended second-order accuracy in time.\n\nYour program must implement the above and produce the observed orders $p$ for the following test suite. Each test case is a tuple of parameters $(\\text{scheme}, c, f, u_0, v_0, \\Delta t_0 \\text{ rule}, N_0, L)$, where $\\text{scheme} \\in \\{\\text{SV}, \\text{BE}, \\text{CN}\\}$ denotes the explicit central-difference (Störmer–Verlet) scheme $\\text{SV}$, backward Euler $\\text{BE}$, and Crank–Nicolson $\\text{CN}$ respectively. The angular frequency is $\\omega = 2 \\pi f$ (in $\\mathrm{rad/s}$), and the wavenumber is $k = \\omega / c$ (in $\\mathrm{rad/m}$). The $\\Delta t_0 \\text{ rule}$ specifies how to set $\\Delta t_0$ in terms of $\\omega$.\n\nTest suite:\n- Case $1$: $(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$.\n- Case $2$: $(\\text{BE}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$.\n- Case $3$: $(\\text{CN}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$.\n- Case $4$: $(\\text{SV}, c = 343, f = 2000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1.9 / \\omega, N_0 = 80, L = 5)$, probing near the explicit stability boundary for the central-difference scheme where the stability condition is $\\Delta t \\omega < 2$.\n- Case $5$: $(\\text{CN}, c = 343, f = 8000, u_0 = 1, v_0 = 0, \\Delta t_0 = 1 / \\omega, N_0 = 80, L = 5)$.\n\nYour program should compute the observed order $p$ for each case using least-squares fitting of $\\log e(\\Delta t)$ versus $\\log \\Delta t$ across the $L$ levels and then produce a single line of output containing the results as a comma-separated list enclosed in square brackets (for example, $[\\text{result1},\\text{result2},\\text{result3}]$). Each result must be a floating-point number (in decimal form) corresponding to the estimated order for the specified case, with no units.",
            "solution": "The problem requires an assessment of the temporal convergence rates for three different time integration schemes applied to the single-mode acoustic oscillator equation. The analysis involves implementing the schemes, computing the numerical solution error against the exact solution at a fixed final time $T$ for a sequence of progressively smaller time steps $\\Delta t$, and determining the observed order of accuracy $p$ by a least-squares fit on the logarithm of the error versus the logarithm of the time step.\n\nFirst, we establish the exact analytical solution to the governing ordinary differential equation (ODE), which serves as the ground truth for error computation. The second-order ODE is given by:\n$$u''(t) + \\omega^2 u(t) = 0$$\nwith initial conditions $u(0) = u_0$ and $u'(0) = v_0$. The general solution is of the form $u(t) = C_1 \\cos(\\omega t) + C_2 \\sin(\\omega t)$. Applying the initial conditions:\n$u(0) = C_1 = u_0$\n$u'(t) = -\\omega C_1 \\sin(\\omega t) + \\omega C_2 \\cos(\\omega t) \\implies u'(0) = \\omega C_2 = v_0 \\implies C_2 = v_0/\\omega$.\nThus, the exact solution for the displacement $u(t)$ and velocity $v(t) = u'(t)$ is:\n$$u(t) = u_0 \\cos(\\omega t) + \\frac{v_0}{\\omega} \\sin(\\omega t)$$\n$$v(t) = -u_0 \\omega \\sin(\\omega t) + v_0 \\cos(\\omega t)$$\nThese will be used to compute the error of the numerical solutions at the final time $T$.\n\nNext, we derive the numerical schemes. Time is discretized as $t_n = n \\Delta t$, with $u^n \\approx u(t_n)$.\n\n**1. Explicit Second-Order Central Difference (Störmer–Verlet) Scheme (SV)**\nThis scheme directly discretizes the second-order ODE $u'' = -\\omega^2 u$. The second derivative $u''(t_n)$ is approximated using a second-order central difference:\n$$\\frac{u^{n+1} - 2u^n + u^{n-1}}{(\\Delta t)^2} = -\\omega^2 u^n + O((\\Delta t)^2)$$\nRearranging to solve for $u^{n+1}$ gives the explicit time-stepping formula:\n$$u^{n+1} = (2 - (\\omega \\Delta t)^2)u^n - u^{n-1}$$\nThis is a two-step method, requiring two initial values, $u^0$ and $u^1$, to start the iteration.\n$u^0 = u(0) = u_0$.\nFor the scheme to be globally second-order accurate, $u^1$ must be computed with at least second-order accuracy. We use a Taylor expansion around $t=0$:\n$$u(\\Delta t) = u(0) + \\Delta t u'(0) + \\frac{(\\Delta t)^2}{2} u''(0) + O((\\Delta t)^3)$$\nSubstituting the initial conditions and $u''(0) = -\\omega^2 u(0) = -\\omega^2 u_0$ from the ODE:\n$$u^1 = u_0 + v_0 \\Delta t - \\frac{(\\omega \\Delta t)^2}{2} u_0$$\nThis starting procedure ensures the overall method achieves its theoretical second-order accuracy. This scheme is conditionally stable, requiring $|\\omega \\Delta t| \\le 2$.\n\n**2. Implicit Backward Euler Scheme (BE)**\nThis scheme is applied to the equivalent first-order system $y'(t) = Ay(t)$, where $y(t) = [u(t), v(t)]^\\top$ and the matrix $A$ is:\n$$A = \\begin{bmatrix} 0 & 1 \\\\ -\\omega^2 & 0 \\end{bmatrix}$$\nThe Backward Euler method is defined by the formula:\n$$y^{n+1} = y^n + \\Delta t A y^{n+1}$$\nThis is an implicit scheme, requiring us to solve for $y^{n+1}$:\n$$(I - \\Delta t A) y^{n+1} = y^n \\implies y^{n+1} = (I - \\Delta t A)^{-1} y^n$$\nwhere $I$ is the $2 \\times 2$ identity matrix. We compute the inverse of the matrix $(I - \\Delta t A)$:\n$$I - \\Delta t A = \\begin{bmatrix} 1 & -\\Delta t \\\\ \\omega^2 \\Delta t & 1 \\end{bmatrix}$$\nThe inverse is:\n$$(I - \\Delta t A)^{-1} = \\frac{1}{1 + (\\omega \\Delta t)^2} \\begin{bmatrix} 1 & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 \\end{bmatrix}$$\nThe state vector $y^n = [u^n, v^n]^\\top$ is initialized with $y^0 = [u_0, v_0]^\\top$ and updated iteratively. The Backward Euler scheme is unconditionally stable but is only first-order accurate, i.e., $p=1$.\n\n**3. Implicit Crank–Nicolson Scheme (CN)**\nThe Crank-Nicolson scheme, also an implicit method for the first-order system, is defined as:\n$$y^{n+1} = y^n + \\frac{\\Delta t}{2} (A y^n + A y^{n+1})$$\nIt approximates the derivative at the midpoint $t_{n+1/2}$. Solving for $y^{n+1}$:\n$$(I - \\frac{\\Delta t}{2} A) y^{n+1} = (I + \\frac{\\Delta t}{2} A) y^n \\implies y^{n+1} = \\left(I - \\frac{\\Delta t}{2} A\\right)^{-1} \\left(I + \\frac{\\Delta t}{2} A\\right) y^n$$\nThe amplification matrix $G = (I - \\frac{\\Delta t}{2} A)^{-1} (I + \\frac{\\Delta t}{2} A)$ is:\n$$G = \\frac{1}{1 + \\frac{(\\omega \\Delta t)^2}{4}} \\begin{bmatrix} 1 - \\frac{(\\omega \\Delta t)^2}{4} & \\Delta t \\\\ -\\omega^2 \\Delta t & 1 - \\frac{(\\omega \\Delta t)^2}{4} \\end{bmatrix}$$\nThe update rule is $y^{n+1} = G y^n$. This scheme is unconditionally stable and second-order accurate ($p=2$).\n\n**Convergence Rate Analysis**\nFor each test case, we compute the numerical solution and its error for a series of $L$ time steps, $\\Delta t_i = \\Delta t_0 / 2^i$ for $i=0, 1, \\dots, L-1$. The number of steps is adjusted to $N_i = N_0 \\cdot 2^i$ to keep the final time $T = N_i \\Delta t_i = N_0 \\Delta t_0$ constant. The absolute error at time $T$ is $e(\\Delta t_i) = |u_{\\text{numerical}}(T) - u_{\\text{exact}}(T)|$. The theoretical convergence relationship is $e(\\Delta t) \\approx C (\\Delta t)^p$, where $p$ is the order of accuracy. Taking the logarithm gives:\n$$\\log(e) \\approx \\log(C) + p \\log(\\Delta t)$$\nThis is a linear relationship between $\\log(e)$ and $\\log(\\Delta t)$ with slope $p$. We compute the slope by performing a linear least-squares fit to the data points $(\\log(\\Delta t_i), \\log(e_i))$ for $i=0, \\dots, L-1$. The resulting slope is the observed order of accuracy for the scheme under the specified test conditions.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_order(case_params):\n    \"\"\"\n    Calculates the observed order of accuracy for a given numerical scheme and parameters.\n    \n    Args:\n        case_params (tuple): A tuple containing the test case parameters:\n            (scheme, c, f, u0, v0, dt0_rule_val, N0, L).\n\n    Returns:\n        float: The observed order of accuracy 'p'.\n    \"\"\"\n    scheme, c, f, u0, v0, dt0_rule_val, N0, L = case_params\n\n    omega = 2.0 * np.pi * f\n    dt0 = dt0_rule_val / omega\n    T = N0 * dt0\n\n    log_dts = []\n    log_errors = []\n\n    # Calculate exact solution at time T for error comparison\n    if omega == 0:\n        u_exact = u0 + v0 * T\n    else:\n        u_exact = u0 * np.cos(omega * T) + (v0 / omega) * np.sin(omega * T)\n\n    # Loop over refinement levels\n    for i in range(L):\n        dt_i = dt0 / (2**i)\n        N_i = int(N0 * (2**i))\n\n        u_numerical = 0.0\n        if scheme == 'SV':\n            # Störmer-Verlet (Central Difference)\n            u_prev = u0\n            # Second-order accurate starting step\n            u_curr = u0 + v0 * dt_i - 0.5 * (omega**2) * u0 * (dt_i**2)\n            \n            if N_i == 0:\n                 u_numerical = u0\n            elif N_i == 1:\n                u_numerical = u_curr\n            else:\n                for _ in range(N_i - 1):\n                    u_next = (2.0 - (omega * dt_i)**2) * u_curr - u_prev\n                    u_prev = u_curr\n                    u_curr = u_next\n                u_numerical = u_curr\n\n        elif scheme == 'BE':\n            # Backward Euler\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            denom = 1.0 + (omega * dt_i)**2\n            update_matrix = np.array([\n                [1.0, dt_i],\n                [-omega2 * dt_i, 1.0]\n            ], dtype=np.float64) / denom\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        elif scheme == 'CN':\n            # Crank-Nicolson\n            y = np.array([u0, v0], dtype=np.float64)\n            omega2 = omega**2\n            term = (omega * dt_i)**2 / 4.0\n            denom = 1.0 + term\n            \n            m11_m22 = (1.0 - term) / denom\n            m12 = dt_i / denom\n            m21 = -omega2 * dt_i / denom\n            \n            update_matrix = np.array([\n                [m11_m22, m12],\n                [m21, m11_m22]\n            ], dtype=np.float64)\n            \n            for _ in range(N_i):\n                y = update_matrix @ y\n            u_numerical = y[0]\n\n        error = np.abs(u_numerical - u_exact)\n        \n        # Avoid log(0) issues for very small errors.\n        if error > np.finfo(float).tiny:\n            log_dts.append(np.log(dt_i))\n            log_errors.append(np.log(error))\n\n    # Perform linear regression if there are enough points for a fit.\n    if len(log_dts) > 1:\n        p, _ = np.polyfit(log_dts, log_errors, 1)\n        return p\n    else:\n        return np.nan # Return NaN if fit is not possible.\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (scheme, c, f, u0, v0, dt0_rule_val, N0, L)\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('BE', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('CN', 343.0, 2000.0, 1.0, 0.0, 1.0, 80, 5),\n        ('SV', 343.0, 2000.0, 1.0, 0.0, 1.9, 80, 5),\n        ('CN', 343.0, 8000.0, 1.0, 0.0, 1.0, 80, 5),\n    ]\n\n    results = []\n    for case in test_cases:\n        order = calculate_order(case)\n        results.append(order)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        }
    ]
}