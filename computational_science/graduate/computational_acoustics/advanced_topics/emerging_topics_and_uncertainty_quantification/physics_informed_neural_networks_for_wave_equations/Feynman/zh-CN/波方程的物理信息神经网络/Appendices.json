{
    "hands_on_practices": [
        {
            "introduction": "物理信息神经网络（PINN）的核心在于将控制方程的残差编码到损失函数中。在着手训练一个完整的PINN模型之前，至关重要的是要掌握其基本构建模块的实现。本练习将指导您为一维波动方程构建PINN的各个残差项，包括偏微分方程（PDE）残差、初始条件（IC）残差和边界条件（BC）残差。通过为给定的网络参数计算这些残差，您将亲手实践PINN求解器的“骨架”部分，为后续的训练和应用奠定坚实的基础 ()。",
            "id": "4134325",
            "problem": "考虑一个由齐次波动方程控制的一维声压场，其定义在归一化的空间域和时间间隔上。设空间域为 $\\Omega=[0,1]$，时间间隔为 $[0,1]$，无量纲波速为 $c=1$。控制偏微分方程为齐次波动方程\n$$\n\\partial_{tt}p(x,t)-\\partial_{xx}p(x,t)=0,\n$$\n其中 $p(x,t)$ 是声压。物理信息神经网络 (PINNs) 使用神经网络拟设来表示 $p(x,t)$，并通过最小化控制方程和约束条件的逐点残差来施加物理约束。\n\n从波动方程的基本原理、链式法则以及前馈神经网络的标准定义出发，为该偏微分方程和约束条件构建逐点PINN残差。使用一个具有双曲正切激活函数的单隐藏层前馈神经网络，其定义为\n$$\np_{\\theta}(x,t)=\\sum_{i=1}^{W}w_i\\,\\tanh\\!\\big(a_i\\,x+b_i\\,t+d_i\\big)+e\\,x+f\\,t+g,\n$$\n其中 $W$ 是隐藏层宽度，$\\theta=\\{(w_i,a_i,b_i,d_i)_{i=1}^{W},e,f,g\\}$ 是可训练参数。物理残差是函数\n$$\nR_{\\mathrm{PDE}}(x,t;\\theta)=\\partial_{tt}p_{\\theta}(x,t)-\\partial_{xx}p_{\\theta}(x,t),\n$$\n而约束残差为\n$$\nR_{\\mathrm{IC},p}(x;\\theta)=p_{\\theta}(x,0)-\\sin(\\pi x),\\quad R_{\\mathrm{IC},v}(x;\\theta)=\\partial_t p_{\\theta}(x,0)-0,\n$$\n$$\nR_{\\mathrm{BC},L}(t;\\theta)=p_{\\theta}(0,t)-0,\\quad R_{\\mathrm{BC},R}(t;\\theta)=p_{\\theta}(1,t)-0,\n$$\n分别对应于初始位移、初始速度以及在 $x=0$ 和 $x=1$ 处的狄利克雷边界条件。所有量均为无量纲量，并在整个过程中应作为无量纲处理。\n\n您必须指定三个用于评估PINN残差分量的不相交配置点集：\n- 一个偏微分方程内部集 $\\mathcal{X}_{\\mathrm{PDE}}=\\{(x_j,t_j)\\}_{j=1}^{N_{\\mathrm{PDE}}}$，其中 $x_j\\in(0,1)$ 且 $t_j\\in(0,1)$，\n- 一个用于位移的初始条件集 $\\mathcal{X}_{\\mathrm{IC},p}=\\{x_k\\}_{k=1}^{N_{\\mathrm{IC},p}}$，位于 $t=0$ 处，\n- 一个用于速度的初始条件集 $\\mathcal{X}_{\\mathrm{IC},v}=\\{x_\\ell\\}_{\\ell=1}^{N_{\\mathrm{IC},v}}$，位于 $t=0$ 处，\n- 一个边界条件集 $\\mathcal{X}_{\\mathrm{BC}}=\\{(x_m,t_m)\\}_{m=1}^{N_{\\mathrm{BC}}}$，其中 $x_m\\in\\{0,1\\}$ 且 $t_m\\in[0,1]$。\n\n按如下方式通过均匀采样确定性地构建这些配置点集：\n- 选择内部网格点数 $N_x^{\\mathrm{int}}=20$ 和 $N_t^{\\mathrm{int}}=20$，并设置 $N_{\\mathrm{PDE}}=N_x^{\\mathrm{int}}\\cdot N_t^{\\mathrm{int}}=400$。通过 $x_i=\\frac{i}{N_x^{\\mathrm{int}}+1}$ (对于 $i=1,2,\\dots,20$) 定义 $x$ 坐标，通过 $t_j=\\frac{j}{N_t^{\\mathrm{int}}+1}$ (对于 $j=1,2,\\dots,20$) 定义 $t$ 坐标。内部集 $\\mathcal{X}_{\\mathrm{PDE}}$ 是所有点对 $(x_i,t_j)$。\n- 选择 $N_{\\mathrm{IC},p}=50$，并通过 $x_k=\\frac{k}{N_{\\mathrm{IC},p}-1}$ (对于 $k=0,1,2,\\dots,49$) 在 $t=0$ 处定义点以构成 $\\mathcal{X}_{\\mathrm{IC},p}$。\n- 选择 $N_{\\mathrm{IC},v}=50$，并通过 $x_\\ell=\\frac{\\ell}{N_{\\mathrm{IC},v}-1}$ (对于 $\\ell=0,1,2,\\dots,49$) 在 $t=0$ 处定义点以构成 $\\mathcal{X}_{\\mathrm{IC},v}$。\n- 选择 $N_t^{\\mathrm{bc}}=80$，并通过 $t_m=\\frac{m}{N_t^{\\mathrm{bc}}-1}$ (对于 $m=0,1,2,\\dots,79$) 在 $x=0$ 和 $x=1$ 处定义点以构成 $\\mathcal{X}_{\\mathrm{BC}}$，因此 $N_{\\mathrm{BC}}=2\\cdot N_t^{\\mathrm{bc}}=160$。\n\n对于下面定义的每个测试用例，计算这些集合上的均方残差：\n$$\nE_{\\mathrm{PDE}}(\\theta)=\\frac{1}{N_{\\mathrm{PDE}}}\\sum_{(x,t)\\in\\mathcal{X}_{\\mathrm{PDE}}} \\big(R_{\\mathrm{PDE}}(x,t;\\theta)\\big)^2,\n$$\n$$\nE_{\\mathrm{IC},p}(\\theta)=\\frac{1}{N_{\\mathrm{IC},p}}\\sum_{x\\in\\mathcal{X}_{\\mathrm{IC},p}} \\big(R_{\\mathrm{IC},p}(x;\\theta)\\big)^2,\\quad\nE_{\\mathrm{IC},v}(\\theta)=\\frac{1}{N_{\\mathrm{IC},v}}\\sum_{x\\in\\mathcal{X}_{\\mathrm{IC},v}} \\big(R_{\\mathrm{IC},v}(x;\\theta)\\big)^2,\n$$\n$$\nE_{\\mathrm{BC}}(\\theta)=\\frac{1}{N_{\\mathrm{BC}}}\\sum_{(x,t)\\in\\mathcal{X}_{\\mathrm{BC}}} \\big(p_{\\theta}(x,t)\\big)^2.\n$$\n您的程序必须为下面的每个参数集计算并报告这四个均方残差，无需执行任何训练。\n\n测试套件。使用以下三个参数集，每个参数集由隐藏层宽度 $W$ 和参数数组给出。所有数组都排列为 $[\\,\\cdot\\,]$ 的形式，并明确写出每个条目：\n- 测试用例 1：\n  - $W=3$\n  - $\\mathbf{a}=[\\,1.0,\\,-2.0,\\,0.5\\,]$\n  - $\\mathbf{b}=[\\,1.5,\\,0.5,\\,-1.0\\,]$\n  - $\\mathbf{d}=[\\,0.1,\\,-0.2,\\,0.3\\,]$\n  - $\\mathbf{w}=[\\,0.7,\\,-1.0,\\,0.3\\,]$\n  - $e=0.0$, $f=0.0$, $g=0.0$\n- 测试用例 2：\n  - $W=0$\n  - $\\mathbf{a}=[\\,\\,]$\n  - $\\mathbf{b}=[\\,\\,]$\n  - $\\mathbf{d}=[\\,\\,]$\n  - $\\mathbf{w}=[\\,\\,]$\n  - $e=0.0$, $f=0.0$, $g=0.0$\n- 测试用例 3：\n  - $W=3$\n  - $\\mathbf{a}=[\\,3.0,\\,-3.0,\\,1.0\\,]$\n  - $\\mathbf{b}=[\\,3.0,\\,3.0,\\,-1.0\\,]$\n  - $\\mathbf{d}=[\\,-0.5,\\,0.25,\\,0.0\\,]$\n  - $\\mathbf{w}=[\\,0.2,\\,-0.2,\\,0.1\\,]$\n  - $e=0.0$, $f=0.0$, $g=0.0$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。列表中的每个元素对应一个测试用例，其本身是一个包含四个浮点数 $[\\,E_{\\mathrm{PDE}},E_{\\mathrm{IC},p},E_{\\mathrm{IC},v},E_{\\mathrm{BC}}\\,]$ 的列表。例如，总体结构必须是\n$$\n[\\,[\\,E_{\\mathrm{PDE}}^{(1)},E_{\\mathrm{IC},p}^{(1)},E_{\\mathrm{IC},v}^{(1)},E_{\\mathrm{BC}}^{(1)}\\,],\\,[\\,E_{\\mathrm{PDE}}^{(2)},E_{\\mathrm{IC},p}^{(2)},E_{\\mathrm{IC},v}^{(2)},E_{\\mathrm{BC}}^{(2)}\\,],\\,[\\,E_{\\mathrm{PDE}}^{(3)},E_{\\mathrm{IC},p}^{(3)},E_{\\mathrm{IC},v}^{(3)},E_{\\mathrm{BC}}^{(3)}\\,]\\,].\n$$\n所有量都是无量纲浮点数，应以不带单位的原始小数形式打印。",
            "solution": "该问题要求计算应用于一维声学波动方程的物理信息神经网络 (PINN) 的均方残差。这个问题是有效的，因为它在科学上基于波动物理学和计算数学的既定原理，是适定的（提供了所有必要信息），并且是客观表述的。任务是评估一个给定的神经网络模型，而不是训练它，这是一个直接且明确的计算过程。\n\n我们将首先推导PINN残差的解析表达式，然后描述配置点集的构建，最后详细说明每个测试用例的均方误差计算。\n\n控制偏微分方程 (PDE) 是齐次一维波动方程：\n$$\n\\partial_{tt}p(x,t) - c^2\\partial_{xx}p(x,t) = \\partial_{tt}p - \\partial_{xx}p = 0\n$$\n其中 $p(x,t)$ 是声压，$x \\in [0,1]$, $t \\in [0,1]$，波速为 $c=1$。\n\n该问题为 $p(x,t)$ 提出了以下神经网络拟设：\n$$\np_{\\theta}(x,t) = \\sum_{i=1}^{W} w_i \\tanh(\\phi_i(x,t)) + e x + f t + g\n$$\n其中 $\\phi_i(x,t) = a_i x + b_i t + d_i$。可训练参数集为 $\\theta = \\{(w_i, a_i, b_i, d_i)_{i=1}^{W}, e, f, g\\}$。\n\n为了计算PINN残差，我们必须计算 $p_{\\theta}(x,t)$ 的必要偏导数。我们使用链式法则和恒等式 $\\frac{d}{dz}\\tanh(z) = \\text{sech}^2(z) = 1 - \\tanh^2(z)$。\n\n关于时间 $t$ 的一阶偏导数：\n$$\n\\partial_t p_{\\theta}(x,t) = \\frac{\\partial}{\\partial t} \\left( \\sum_{i=1}^{W} w_i \\tanh(\\phi_i) + e x + f t + g \\right) = \\sum_{i=1}^{W} w_i \\frac{d}{d\\phi_i}(\\tanh(\\phi_i)) \\frac{\\partial \\phi_i}{\\partial t} + f\n$$\n由于 $\\frac{\\partial \\phi_i}{\\partial t} = b_i$，上式变为：\n$$\n\\partial_t p_{\\theta}(x,t) = \\sum_{i=1}^{W} w_i b_i \\text{sech}^2(\\phi_i) + f\n$$\n\n关于时间 $t$ 的二阶偏导数：\n使用恒等式 $\\frac{d}{dz}\\text{sech}^2(z) = -2\\text{sech}^2(z)\\tanh(z)$，我们有：\n$$\n\\partial_{tt} p_{\\theta}(x,t) = \\frac{\\partial}{\\partial t} \\left( \\sum_{i=1}^{W} w_i b_i \\text{sech}^2(\\phi_i) + f \\right) = \\sum_{i=1}^{W} w_i b_i \\frac{d}{d\\phi_i}(\\text{sech}^2(\\phi_i)) \\frac{\\partial \\phi_i}{\\partial t}\n$$\n$$\n\\partial_{tt} p_{\\theta}(x,t) = \\sum_{i=1}^{W} w_i b_i \\left( -2 \\text{sech}^2(\\phi_i) \\tanh(\\phi_i) \\right) b_i = -2 \\sum_{i=1}^{W} w_i b_i^2 \\text{sech}^2(\\phi_i) \\tanh(\\phi_i)\n$$\n\n关于空间 $x$ 的二阶偏导数：\n根据对称性，其推导过程类似于时间导数，只需将 $t$ 替换为 $x$，$f$ 替换为 $e$，$b_i$ 替换为 $a_i$。\n$$\n\\partial_x p_{\\theta}(x,t) = \\sum_{i=1}^{W} w_i a_i \\text{sech}^2(\\phi_i) + e\n$$\n$$\n\\partial_{xx} p_{\\theta}(x,t) = -2 \\sum_{i=1}^{W} w_i a_i^2 \\text{sech}^2(\\phi_i) \\tanh(\\phi_i)\n$$\n\n现在我们可以写出残差的显式形式。\n1. PDE残差，$R_{\\mathrm{PDE}}(x,t;\\theta) = \\partial_{tt}p_{\\theta} - \\partial_{xx}p_{\\theta}$：\n$$\nR_{\\mathrm{PDE}}(x,t;\\theta) = -2 \\sum_{i=1}^{W} w_i b_i^2 \\text{sech}^2(\\phi_i) \\tanh(\\phi_i) - \\left( -2 \\sum_{i=1}^{W} w_i a_i^2 \\text{sech}^2(\\phi_i) \\tanh(\\phi_i) \\right)\n$$\n$$\nR_{\\mathrm{PDE}}(x,t;\\theta) = 2 \\sum_{i=1}^{W} w_i (a_i^2 - b_i^2) \\text{sech}^2(\\phi_i) \\tanh(\\phi_i)\n$$\n\n2. 压力（位移）的初始条件残差，$R_{\\mathrm{IC},p}(x;\\theta) = p_{\\theta}(x,0) - \\sin(\\pi x)$：\n$$\nR_{\\mathrm{IC},p}(x;\\theta) = \\left( \\sum_{i=1}^{W} w_i \\tanh(a_i x + d_i) + e x + g \\right) - \\sin(\\pi x)\n$$\n\n3. 速度的初始条件残差，$R_{\\mathrm{IC},v}(x;\\theta) = \\partial_t p_{\\theta}(x,0) - 0$：\n$$\nR_{\\mathrm{IC},v}(x;\\theta) = \\sum_{i=1}^{W} w_i b_i \\text{sech}^2(a_i x + d_i) + f\n$$\n\n4. 边界条件残差，$R_{\\mathrm{BC},L}(t;\\theta)=p_{\\theta}(0,t) - 0$ 和 $R_{\\mathrm{BC},R}(t;\\theta)=p_{\\theta}(1,t) - 0$。用于计算边界误差 $E_{\\mathrm{BC}}$ 的平方和平均值就是 $p_{\\theta}(x,t)$ 在边界点上的取值。对于 $x=0$：\n$$\np_{\\theta}(0,t) = \\sum_{i=1}^{W} w_i \\tanh(b_i t + d_i) + f t + g\n$$\n对于 $x=1$：\n$$\np_{\\theta}(1,t) = \\sum_{i=1}^{W} w_i \\tanh(a_i + b_i t + d_i) + e + f t + g\n$$\n\n残差在四个按规定构建的不同配置点集上进行计算：\n-   $\\mathcal{X}_{\\mathrm{PDE}}$: 在 $(0,1) \\times (0,1)$ 上的一个 $N_x^{\\mathrm{int}} \\times N_t^{\\mathrm{int}} = 20 \\times 20 = 400$ 点网格，其中 $x_i=\\frac{i}{21}$ (对于 $i=1,\\dots,20$) 且 $t_j=\\frac{j}{21}$ (对于 $j=1,\\dots,20$)。\n-   $\\mathcal{X}_{\\mathrm{IC},p}$: 在 $t=0$ 时位于 $[0,1]$ 上的 $N_{\\mathrm{IC},p}=50$ 个点，其中 $x_k=\\frac{k}{49}$ (对于 $k=0,\\dots,49$)。\n-   $\\mathcal{X}_{\\mathrm{IC},v}$: 在 $t=0$ 时位于 $[0,1]$ 上的 $N_{\\mathrm{IC},v}=50$ 个点，其中 $x_\\ell=\\frac{\\ell}{49}$ (对于 $\\ell=0,\\dots,49$)。\n-   $\\mathcal{X}_{\\mathrm{BC}}$: 边界上的 $N_{\\mathrm{BC}} = 2 \\cdot N_t^{\\mathrm{bc}} = 160$ 个点，其中时间点为 $t_m=\\frac{m}{79}$ (对于 $m=0,\\dots,79$) 的 $N_t^{\\mathrm{bc}}=80$ 个点，分布在 $x=0$ 和 $x=1$ 两个边界上。\n\n均方误差 (MSE) 是通过在各自的配置点集上对相应残差的平方求平均值来计算的：\n$$\nE_{\\mathrm{PDE}}(\\theta) = \\frac{1}{400} \\sum_{(x,t)\\in\\mathcal{X}_{\\mathrm{PDE}}} \\big(R_{\\mathrm{PDE}}(x,t;\\theta)\\big)^2\n$$\n$$\nE_{\\mathrm{IC},p}(\\theta) = \\frac{1}{50} \\sum_{x\\in\\mathcal{X}_{\\mathrm{IC},p}} \\big(R_{\\mathrm{IC},p}(x;\\theta)\\big)^2\n$$\n$$\nE_{\\mathrm{IC},v}(\\theta) = \\frac{1}{50} \\sum_{x\\in\\mathcal{X}_{\\mathrm{IC},v}} \\big(R_{\\mathrm{IC},v}(x;\\theta)\\big)^2\n$$\n$$\nE_{\\mathrm{BC}}(\\theta) = \\frac{1}{160} \\sum_{(x,t)\\in\\mathcal{X}_{\\mathrm{BC}}} \\big(p_{\\theta}(x,t)\\big)^2\n$$\n求解过程包括为三个测试用例中的每一个实现这些公式，计算四个MSE值，并以指定格式报告它们。为提高效率，计算将使用向量化操作执行。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Computes the mean-squared residuals for a PINN applied to the 1D wave equation\n    for three given sets of network parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"W\": 3,\n            \"a\": [1.0, -2.0, 0.5],\n            \"b\": [1.5, 0.5, -1.0],\n            \"d\": [0.1, -0.2, 0.3],\n            \"w\": [0.7, -1.0, 0.3],\n            \"e\": 0.0, \"f\": 0.0, \"g\": 0.0\n        },\n        {\n            \"W\": 0,\n            \"a\": [], \"b\": [], \"d\": [], \"w\": [],\n            \"e\": 0.0, \"f\": 0.0, \"g\": 0.0\n        },\n        {\n            \"W\": 3,\n            \"a\": [3.0, -3.0, 1.0],\n            \"b\": [3.0, 3.0, -1.0],\n            \"d\": [-0.5, 0.25, 0.0],\n            \"w\": [0.2, -0.2, 0.1],\n            \"e\": 0.0, \"f\": 0.0, \"g\": 0.0\n        },\n    ]\n\n    # Generate collocation points\n    # PDE interior set\n    N_x_int, N_t_int = 20, 20\n    x_pde_coords = np.arange(1, N_x_int + 1) / (N_x_int + 1)\n    t_pde_coords = np.arange(1, N_t_int + 1) / (N_t_int + 1)\n    X_pde_grid, T_pde_grid = np.meshgrid(x_pde_coords, t_pde_coords)\n    x_pde = X_pde_grid.flatten()\n    t_pde = T_pde_grid.flatten()\n    N_PDE = len(x_pde)\n\n    # Initial condition sets\n    N_IC_p = 50\n    x_icp = np.linspace(0, 1, N_IC_p)\n    t_icp = np.zeros_like(x_icp)\n\n    N_IC_v = 50\n    x_icv = np.linspace(0, 1, N_IC_v)\n    t_icv = np.zeros_like(x_icv)\n\n    # Boundary condition set\n    N_t_bc = 80\n    t_bc_coords = np.linspace(0, 1, N_t_bc)\n    x_bc = np.concatenate([np.zeros(N_t_bc), np.ones(N_t_bc)])\n    t_bc = np.concatenate([t_bc_coords, t_bc_coords])\n    N_BC = len(x_bc)\n    \n    results = []\n    for case in test_cases:\n        W = case[\"W\"]\n        a = np.array(case[\"a\"])\n        b = np.array(case[\"b\"])\n        d = np.array(case[\"d\"])\n        w = np.array(case[\"w\"])\n        e = case[\"e\"]\n        f = case[\"f\"]\n        g = case[\"g\"]\n\n        # If W=0, the sum part of all expressions is zero.\n        # The vectorized implementation handles this naturally.\n        \n        # 1. E_PDE calculation\n        # Shape of x_pde and t_pde is (N_PDE,)\n        # Shapes of a,b,d,w are (W,)\n        # We need to broadcast them to (N_PDE, W)\n        phi_pde = x_pde[:, np.newaxis] * a[np.newaxis, :] + \\\n                  t_pde[:, np.newaxis] * b[np.newaxis, :] + \\\n                  d[np.newaxis, :]\n        tanh_phi_pde = np.tanh(phi_pde)\n        sech_phi_pde = 1.0 / np.cosh(phi_pde)\n        sech2_phi_pde = sech_phi_pde**2\n        \n        R_pde_sum_part = 2 * w[np.newaxis, :] * (a[np.newaxis, :]**2 - b[np.newaxis, :]**2) * \\\n                         sech2_phi_pde * tanh_phi_pde\n        R_pde = np.sum(R_pde_sum_part, axis=1)\n        E_pde = np.mean(R_pde**2)\n\n        # 2. E_IC,p calculation\n        phi_icp = x_icp[:, np.newaxis] * a[np.newaxis, :] + d[np.newaxis, :]\n        p_theta_icp_sum_part = w[np.newaxis, :] * np.tanh(phi_icp)\n        p_theta_icp = np.sum(p_theta_icp_sum_part, axis=1) + e * x_icp + f * t_icp + g\n        R_icp = p_theta_icp - np.sin(np.pi * x_icp)\n        E_icp = np.mean(R_icp**2)\n\n        # 3. E_IC,v calculation\n        phi_icv = x_icv[:, np.newaxis] * a[np.newaxis, :] + d[np.newaxis, :]\n        sech_phi_icv = 1.0 / np.cosh(phi_icv)\n        sech2_phi_icv = sech_phi_icv**2\n        \n        dt_p_theta_icv_sum_part = w[np.newaxis, :] * b[np.newaxis, :] * sech2_phi_icv\n        dt_p_theta_icv = np.sum(dt_p_theta_icv_sum_part, axis=1) + f\n        R_icv = dt_p_theta_icv # Target is 0\n        E_icv = np.mean(R_icv**2)\n\n        # 4. E_BC calculation\n        phi_bc = x_bc[:, np.newaxis] * a[np.newaxis, :] + \\\n                 t_bc[:, np.newaxis] * b[np.newaxis, :] + \\\n                 d[np.newaxis, :]\n        p_theta_bc_sum_part = w[np.newaxis, :] * np.tanh(phi_bc)\n        p_theta_bc = np.sum(p_theta_bc_sum_part, axis=1) + e * x_bc + f * t_bc + g\n        # Residual is p_theta_bc - 0\n        E_bc = np.mean(p_theta_bc**2)\n\n        results.append([E_pde, E_icp, E_icv, E_bc])\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list matches the required format '[item1, item2, ...]'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "在科学计算中，任何数值方法的开发都离不开严格的验证与确认环节。对于PINN这种新兴的求解器而言，检验其解的准确性尤为重要。本练习将引导您将PINN的预测结果与经典的d'Alembert公式得到的精确解进行对比。通过设计并实现一个量化的验证测试来计算$L^2$范数下的误差，您将掌握评估PINN模型性能的关键技能，这是确保数值模拟可靠性的标准流程 ()。",
            "id": "4134276",
            "problem": "考虑在一个无损耗、均匀介质中的小振幅一维声学问题，其中声压场 $p(x,t)$ 满足由线性化动量方程和连续性方程导出的标量波动方程。具体而言，设压力场满足偏微分方程 (PDE) $ \\partial_t^2 p(x,t) - c^2 \\partial_x^2 p(x,t) = 0 $，其中位置 $x \\in \\mathbb{R}$，时间 $t \\ge 0$，$c$ 是介质中恒定的声速，单位为米/秒。初始条件由 $p(x,0) = f(x)$ 和 $\\partial_t p(x,0) = g(x)$ 给出，其中 $f$ 和 $g$ 是给定函数。\n\n任务1（推导）：从波动方程 $ \\partial_t^2 p(x,t) - c^2 \\partial_x^2 p(x,t) = 0 $ 及初始条件 $p(x,0) = f(x)$ 和 $\\partial_t p(x,0) = g(x)$ 出发，使用特征坐标和变量替换法推导 $p(x,t)$ 的精确解。您的推导必须从这些基本声学方程和定义开始，而非直接使用已知的解公式。推导过程必须符合原理，且不得依赖捷径或背诵的公式。清晰地写出通过此推导获得的 $p(x,t)$ 的最终表达式。\n\n任务2（物理信息神经网络 (PINN) 验证设计）：设计一个定量测试，用于在一个有限空间区间上，在 $L^2$ 范数下验证一个已训练的物理信息神经网络 (PINN) 近似解 $p_{\\mathrm{PINN}}(x,t)$ 相对于精确解的准确性。定义在空间区间 $\\Omega = [0,L]$ 和一个有限时间集合 $\\{t_j\\}_{j=1}^M$ 上的归一化 $L^2$ 失配为\n$$\n\\left\\| e \\right\\|_{L^2(\\Omega \\times \\{t_j\\})} \\equiv \\left( \\frac{1}{L M} \\sum_{j=1}^M \\int_0^L \\left( p_{\\mathrm{PINN}}(x,t_j) - p_{\\mathrm{exact}}(x,t_j) \\right)^2 \\, dx \\right)^{1/2},\n$$\n其中 $p_{\\mathrm{exact}}(x,t)$ 是您在任务1中推导出的精确解。该失配的单位必须是帕斯卡（Pa）。所使用的任何三角函数的角度单位必须是弧度。\n\n任务3（实现）：实现一个程序，通过您在任务1中推导的表达式计算精确解，并为一组测试用例评估归一化的 $L^2$ 失配（单位为帕斯卡）。为确保科学真实性，请使用物理上合理的参数。您在 $x$ 上的数值积分应在均匀空间网格上使用梯形法则进行收敛求积，并且您的精确表达式所需的任何线积分都必须精确评估（在可能的情况下进行解析评估，否则通过数值求积法评估）。\n\n测试套件规范：\n- 使用以下四个测试用例，每个用例指定空间区间长度 $L$（米）、声速 $c$（米/秒）、初始条件 $f$ 和 $g$、评估时间 $\\{t_j\\}$（秒），以及一个合成扰动振幅 $\\varepsilon$ 以模拟已训练 PINN 的残差近似误差。所有角度均以弧度为单位。对于任何使用正弦或余弦的测试用例，波数 $k$ 为 $2\\pi/L$。\n\n1. 理想情况（平滑的 $f$，零 $g$）：\n    - $L = 1.0$ (米)，$c = 343.0$ (米/秒)。\n    - $f(x) = A \\exp\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)$，其中 $A = 2.0$ (帕斯卡)，$x_0 = L/2$，$\\sigma = 0.10$ (米)。\n    - $g(x) \\equiv 0$ (帕斯卡/秒)。\n    - 时间 $\\{t_j\\} = \\{0.0, 0.0005, 0.0010\\}$ (秒)。\n    - 合成扰动振幅 $\\varepsilon = 0.0$。\n\n2. 与案例1相同，但带有小的合成扰动：\n    - $L = 1.0$，$c = 343.0$。\n    - $f$ 和 $g$ 如案例1所示。\n    - 时间 $\\{t_j\\} = \\{0.0, 0.0005, 0.0010\\}$。\n    - $\\varepsilon = 1.0 \\times 10^{-4}$。\n\n3. 混合三角函数 $f$ 和 $g$：\n    - $L = 2.0$ (米)，$c = 343.0$ (米/秒)，$k = 2\\pi/L$。\n    - $f(x) = A \\sin(k x + \\phi)$，其中 $A = 1.0$ (帕斯卡)，$\\phi = \\pi/4$ (弧度)。\n    - $g(x) = B \\sin(k x + \\phi_g)$，其中 $B = 0.5$ (帕斯卡/秒)，$\\phi_g = 0.0$ (弧度)。\n    - 时间 $\\{t_j\\} = \\{0.0, 0.0015\\}$ (秒)。\n    - $\\varepsilon = 5.0 \\times 10^{-5}$。\n\n4. 脉冲速度（高斯 $g$），零位移：\n    - $L = 1.0$ (米)，$c = 343.0$ (米/秒)。\n    - $f(x) \\equiv 0$ (帕斯卡)。\n    - $g(x) = B \\exp\\left( -\\frac{(x - x_0)^2}{2\\sigma^2} \\right)$，其中 $B = 1.0$ (帕斯卡/秒)，$x_0 = 0.60$ (米)，$\\sigma = 0.05$ (米)。\n    - 时间 $\\{t_j\\} = \\{0.0005\\}$ (秒)。\n    - $\\varepsilon = 5.0 \\times 10^{-4}$。\n\n合成 PINN 近似模型：\n- 对于每个测试用例，定义 $p_{\\mathrm{PINN}}(x,t) = p_{\\mathrm{exact}}(x,t) + \\varepsilon \\, \\eta(x,t)$，其中 $\\eta(x,t)$ 是一个平滑、零均值、空间结构化的扰动，由下式给出：\n$$\n\\eta(x,t) = \\left( \\sin\\left( \\frac{7\\pi x}{L} \\right) + \\frac{1}{2}\\sin\\left( \\frac{13\\pi x}{L} \\right) \\right) \\cos\\left( \\frac{2\\pi t}{T_\\star} \\right),\n$$\n其中 $T_\\star$ 设置为该用例中的最大时间。这模拟了一个已训练的物理信息神经网络 (PINN) 产生的典型的平滑类残差场。\n\n数值细节：\n- 在 $[0,L]$ 上使用 $N_x = 200$ 个点的均匀网格进行空间积分。\n- 对空间积分 $\\int_0^L (\\cdot)\\,dx$ 使用梯形法则。\n- 精确解中出现的线积分，当 $g$ 是正弦函数时通过反导数进行解析评估，否则通过高精度数值求积法进行评估。\n- 生成最终的归一化 $L^2$ 失配值，单位为帕斯卡。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，结果按四个测试用例的顺序列出，每个浮点数采用科学记数法格式，小数点后保留八位数字（例如，$[1.23456789e-03,0.00000000e+00, \\dots]$）。输出中不得有空格。输出中的数值是四个测试用例的归一化 $L^2$ 失配，单位为帕斯卡，顺序与上文列表一致。",
            "solution": "该问题陈述已经过严格验证并被认为是有效的。它在科学上基于线性声学原理，在数学上是波动方程的适定初值问题，并为所有任务提供了一套完整、一致且客观的规范。\n\n### 任务1：精确解的推导\n\n声压场 $p(x,t)$ 的控制偏微分方程 (PDE) 是一维标量波动方程：\n$$\n\\partial_t^2 p(x,t) - c^2 \\partial_x^2 p(x,t) = 0\n$$\n初始条件由 $p(x,0) = f(x)$ 和 $\\partial_t p(x,0) = g(x)$ 给出。\n\n为了求解此方程，我们采用特征线法。我们引入变量替换，切换到特征坐标 $\\xi$ 和 $\\eta$：\n$$\n\\xi = x - ct\n$$\n$$\n\\eta = x + ct\n$$\n使用链式法则，我们将关于 $x$ 和 $t$ 的偏导数用关于 $\\xi$ 和 $\\eta$ 的导数表示。\n一阶导数为：\n$$\n\\frac{\\partial}{\\partial x} = \\frac{\\partial\\xi}{\\partial x}\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial\\eta}{\\partial x}\\frac{\\partial}{\\partial\\eta} = 1 \\cdot \\frac{\\partial}{\\partial\\xi} + 1 \\cdot \\frac{\\partial}{\\partial\\eta} = \\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\n$$\n$$\n\\frac{\\partial}{\\partial t} = \\frac{\\partial\\xi}{\\partial t}\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial\\eta}{\\partial t}\\frac{\\partial}{\\partial\\eta} = (-c) \\cdot \\frac{\\partial}{\\partial\\xi} + (c) \\cdot \\frac{\\partial}{\\partial\\eta} = c\\left(-\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\\right)\n$$\n二阶导数为：\n$$\n\\frac{\\partial^2}{\\partial x^2} = \\left(\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\\right)\\left(\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\\right) = \\frac{\\partial^2}{\\partial\\xi^2} + 2\\frac{\\partial^2}{\\partial\\xi\\partial\\eta} + \\frac{\\partial^2}{\\partial\\eta^2}\n$$\n$$\n\\frac{\\partial^2}{\\partial t^2} = c^2\\left(-\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\\right)\\left(-\\frac{\\partial}{\\partial\\xi} + \\frac{\\partial}{\\partial\\eta}\\right) = c^2\\left(\\frac{\\partial^2}{\\partial\\xi^2} - 2\\frac{\\partial^2}{\\partial\\xi\\partial\\eta} + \\frac{\\partial^2}{\\partial\\eta^2}\\right)\n$$\n将这些二阶导数的表达式代入波动方程，得到：\n$$\nc^2\\left(\\frac{\\partial^2 p}{\\partial\\xi^2} - 2\\frac{\\partial^2 p}{\\partial\\xi\\partial\\eta} + \\frac{\\partial^2 p}{\\partial\\eta^2}\\right) - c^2\\left(\\frac{\\partial^2 p}{\\partial\\xi^2} + 2\\frac{\\partial^2 p}{\\partial\\xi\\partial\\eta} + \\frac{\\partial^2 p}{\\partial\\eta^2}\\right) = 0\n$$\n简化此表达式，我们得到：\n$$\n-4c^2 \\frac{\\partial^2 p}{\\partial\\xi\\partial\\eta} = 0\n$$\n这简化为典范形式：\n$$\n\\frac{\\partial^2 p}{\\partial\\xi\\partial\\eta} = 0\n$$\n我们依次对该方程积分。首先，对 $\\xi$ 积分：\n$$\n\\frac{\\partial p}{\\partial\\eta} = h(\\eta)\n$$\n其中 $h(\\eta)$ 是一个关于 $\\eta$ 的任意函数。接下来，我们对 $\\eta$ 积分：\n$$\np(\\xi, \\eta) = \\int h(\\eta) \\, d\\eta + F(\\xi)\n$$\n令 $G(\\eta) = \\int h(\\eta) \\, d\\eta$，这是另一个任意函数，则 $p$ 在特征坐标下的通解为：\n$$\np(\\xi, \\eta) = F(\\xi) + G(\\eta)\n$$\n变换回原始坐标 $(x,t)$，波动方程的通解为：\n$$\np(x,t) = F(x-ct) + G(x+ct)\n$$\n这表示一个右行波 $F$ 和一个左行波 $G$ 的叠加。\n\n现在，我们应用初始条件来确定 $F$ 和 $G$ 的具体形式。\n在 $t=0$ 时，我们有 $p(x,0) = f(x)$：\n$$\nF(x) + G(x) = f(x) \\quad \\text{(1)}\n$$\n对于第二个初始条件，我们首先求出 $\\partial_t p(x,t)$：\n$$\n\\partial_t p(x,t) = \\frac{dF}{d(x-ct)}\\frac{\\partial(x-ct)}{\\partial t} + \\frac{dG}{d(x+ct)}\\frac{\\partial(x+ct)}{\\partial t} = -c F'(x-ct) + c G'(x+ct)\n$$\n在 $t=0$ 时，我们有 $\\partial_t p(x,0) = g(x)$：\n$$\n-c F'(x) + c G'(x) = g(x) \\implies -F'(x) + G'(x) = \\frac{1}{c}g(x) \\quad \\text{(2)}\n$$\n对方程 (2) 从某个任意点 $x_0$到 $x$ 进行积分：\n$$\n\\int_{x_0}^x (-F'(s) + G'(s)) \\, ds = \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds\n$$\n$$\n[-F(s) + G(s)]_{x_0}^x = \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds\n$$\n$$\n-F(x) + G(x) - (-F(x_0) + G(x_0)) = \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds\n$$\n令常数项为 $K = F(x_0) - G(x_0)$，我们有：\n$$\n-F(x) + G(x) = \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds - K \\quad \\text{(3)}\n$$\n我们现在求解线性方程组 (1) 和 (3) 以得到 $F(x)$ 和 $G(x)$。\n将 (1) 和 (3) 相加：\n$$\n2G(x) = f(x) + \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds - K \\implies G(x) = \\frac{1}{2}f(x) + \\frac{1}{2c} \\int_{x_0}^x g(s) \\, ds - \\frac{K}{2}\n$$\n从 (1) 中减去 (3)：\n$$\n2F(x) = f(x) - \\frac{1}{c} \\int_{x_0}^x g(s) \\, ds + K \\implies F(x) = \\frac{1}{2}f(x) - \\frac{1}{2c} \\int_{x_0}^x g(s) \\, ds + \\frac{K}{2}\n$$\n现在我们将这些形式代入通解 $p(x,t) = F(x-ct) + G(x+ct)$：\n\\begin{align*}\np(x,t) = \\left( \\frac{1}{2}f(x-ct) - \\frac{1}{2c} \\int_{x_0}^{x-ct} g(s) \\, ds + \\frac{K}{2} \\right) + \\left( \\frac{1}{2}f(x+ct) + \\frac{1}{2c} \\int_{x_0}^{x+ct} g(s) \\, ds - \\frac{K}{2} \\right) \\\\\n= \\frac{1}{2}(f(x-ct) + f(x+ct)) + \\frac{1}{2c} \\left( \\int_{x_0}^{x+ct} g(s) \\, ds - \\int_{x_0}^{x-ct} g(s) \\, ds \\right)\n\\end{align*}\n常数 $K$ 被消掉。积分可以合并：\n$$\n\\int_{x_0}^{x+ct} g(s) \\, ds - \\int_{x_0}^{x-ct} g(s) \\, ds = \\int_{x_0}^{x+ct} g(s) \\, ds + \\int_{x-ct}^{x_0} g(s) \\, ds = \\int_{x-ct}^{x+ct} g(s) \\, ds\n$$\n精确解的最终表达式，即著名的 d'Alembert 公式，是：\n$$\np_{\\mathrm{exact}}(x,t) = \\frac{f(x-ct) + f(x+ct)}{2} + \\frac{1}{2c} \\int_{x-ct}^{x+ct} g(s) \\, ds\n$$\n任务1的推导到此结束。\n\n### 任务2：物理信息神经网络 (PINN) 验证设计\n\n目标是定量评估 PINN 近似解 $p_{\\mathrm{PINN}}(x,t)$ 相对于推导出的精确解 $p_{\\mathrm{exact}}(x,t)$ 的准确性。一个合适的度量标准是归一化的 $L^2$ 失配，它测量在指定时空域上的均方根误差。\n\n根据问题中的定义，在空间区间 $\\Omega = [0,L]$ 和一个离散时间集合 $\\{t_j\\}_{j=1}^M$ 上的归一化 $L^2$ 失配为：\n$$\n\\left\\| e \\right\\|_{L^2(\\Omega \\times \\{t_j\\})} \\equiv \\left( \\frac{1}{L M} \\sum_{j=1}^M \\int_0^L \\left( p_{\\mathrm{PINN}}(x,t_j) - p_{\\mathrm{exact}}(x,t_j) \\right)^2 \\, dx \\right)^{1/2}\n$$\n问题为 PINN 近似提供了一个合成模型以模拟验证场景：\n$$\np_{\\mathrm{PINN}}(x,t) = p_{\\mathrm{exact}}(x,t) + \\varepsilon \\, \\eta(x,t)\n$$\n这里，$\\varepsilon$ 是一个小振幅，$\\eta(x,t)$ 是一个平滑、结构化的扰动函数，代表已训练 PINN 的残差。将此模型代入失配定义，差分项变为：\n$$\np_{\\mathrm{PINN}}(x,t_j) - p_{\\mathrm{exact}}(x,t_j) = \\left( p_{\\mathrm{exact}}(x,t_j) + \\varepsilon \\, \\eta(x,t_j) \\right) - p_{\\mathrm{exact}}(x,t_j) = \\varepsilon \\, \\eta(x,t_j)\n$$\n因此，失配计算简化为：\n$$\n\\left\\| e \\right\\| = \\left( \\frac{1}{L M} \\sum_{j=1}^M \\int_0^L \\left( \\varepsilon \\, \\eta(x,t_j) \\right)^2 \\, dx \\right)^{1/2} = |\\varepsilon| \\left( \\frac{1}{L M} \\sum_{j=1}^M \\int_0^L \\eta(x,t_j)^2 \\, dx \\right)^{1/2}\n$$\n单位是一致的：$p$ 的单位是帕斯卡 (Pa)，所以 $(p_{\\mathrm{PINN}} - p_{\\mathrm{exact}})^2$ 的单位是 $\\text{Pa}^2$。积分 $\\int (\\cdot)^2 \\, dx$ 的单位是 $\\text{Pa}^2 \\cdot \\text{m}$。通过长度 $L$ (单位 m) 进行归一化后，单位变为 $\\text{Pa}^2$。最终开方得到单位 Pa，符合要求。\n\n### 任务3：实现策略\n\n程序将为指定的测试套件实现简化的失配计算。对于每个案例：\n1.  **离散化**：在区间 $[0,L]$ 上创建一个包含 $N_x=200$ 个点的均匀空间网格。\n2.  **扰动函数**：对于每个指定的时间 $t_j$，在网格上评估函数 $\\eta(x,t)$。\n3.  **空间积分**：对于每个 $t_j$，使用梯形法则 (`numpy.trapz`) 在离散网格上数值计算积分 $\\int_0^L \\eta(x,t_j)^2 \\, dx$。\n4.  **平均**：将积分值在所有 $M$ 个时间实例上求和，然后用乘积 $L M$ 进行归一化。\n5.  **最终失配**：通过取平均值的平方根并乘以扰动振幅 $\\varepsilon$ 的绝对值来计算最终失配。\n\n尽管简化的公式不需要为最终数值结果显式计算 $p_{\\mathrm{exact}}(x,t)$，但将数值近似与精确解析解进行比较的概念框架是核心。任务1中的推导提供了必要的 $p_{\\mathrm{exact}}(x,t)$，这将在对黑盒 PINN 模型进行真实世界验证时使用。该实现使用了简化公式，这是所提供的特定合成误差模型的直接结果。对于涉及非零初始速度 $g(x)$ 的情况，d'Alembert 公式中的积分项将按如下方式处理：\n-   对于 $g(x) = B \\sin(k x + \\phi_g)$，积分 $\\int g(s) ds$ 可以解析地计算为 $-\\frac{B}{k}\\cos(ks+\\phi_g)$。\n-   对于高斯函数 $g(x)$，积分使用 `scipy.special` 中可用的误差函数 `erf` 进行评估。具体来说，$\\int e^{-u^2}du = \\frac{\\sqrt{\\pi}}{2}\\text{erf}(u)$，这允许对高斯函数的定积分给出解析表达式。\n`final_answer` 中的代码将直接实现简化的计算。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Computes the normalized L2 misfit for four test cases involving the 1D wave equation,\n    simulating the verification of a Physics-Informed Neural Network (PINN).\n    \"\"\"\n\n    # --- Test Suite Specification ---\n    test_cases = [\n        # Case 1: Happy path (smooth f, zero g)\n        {\n            \"L\": 1.0, \"c\": 343.0,\n            \"f_func_params\": {\"A\": 2.0, \"x0\": 0.5, \"sigma\": 0.10},\n            \"g_func_params\": {\"B\": 0.0},\n            \"times\": [0.0, 0.0005, 0.0010],\n            \"epsilon\": 0.0,\n            \"case_id\": 1\n        },\n        # Case 2: Same as Case 1, but with a small synthetic perturbation\n        {\n            \"L\": 1.0, \"c\": 343.0,\n            \"f_func_params\": {\"A\": 2.0, \"x0\": 0.5, \"sigma\": 0.10},\n            \"g_func_params\": {\"B\": 0.0},\n            \"times\": [0.0, 0.0005, 0.0010],\n            \"epsilon\": 1.0e-4,\n            \"case_id\": 2\n        },\n        # Case 3: Mixed trigonometric f and g\n        {\n            \"L\": 2.0, \"c\": 343.0,\n            \"f_func_params\": {\"A\": 1.0, \"phi\": np.pi / 4.0},\n            \"g_func_params\": {\"B\": 0.5, \"phi_g\": 0.0},\n            \"times\": [0.0, 0.0015],\n            \"epsilon\": 5.0e-5,\n            \"case_id\": 3\n        },\n        # Case 4: Impulsive velocity (Gaussian g), zero displacement\n        {\n            \"L\": 1.0, \"c\": 343.0,\n            \"f_func_params\": {\"A\": 0.0},\n            \"g_func_params\": {\"B\": 1.0, \"x0\": 0.60, \"sigma\": 0.05},\n            \"times\": [0.0005],\n            \"epsilon\": 5.0e-4,\n            \"case_id\": 4\n        }\n    ]\n\n    results = []\n    \n    # Numerical details\n    N_x = 200\n\n    for case in test_cases:\n        L = case[\"L\"]\n        epsilon = case[\"epsilon\"]\n        times = case[\"times\"]\n        \n        if epsilon == 0.0:\n            results.append(0.0)\n            continue\n            \n        x = np.linspace(0, L, N_x)\n        M = len(times)\n        \n        T_star = max(times) if times else 1.0\n        if T_star == 0.0: T_star = 1.0 # Avoid division by zero if only t=0 is given\n\n        sum_of_integrals = 0.0\n        \n        for tj in times:\n            # Define the perturbation function eta(x, t)\n            # eta(x,t) = (sin(7*pi*x/L) + 0.5*sin(13*pi*x/L)) * cos(2*pi*t/T_star)\n            \n            spatial_part = np.sin(7 * np.pi * x / L) + 0.5 * np.sin(13 * np.pi * x / L)\n            temporal_part = np.cos(2 * np.pi * tj / T_star)\n            \n            eta_values = spatial_part * temporal_part\n            \n            # The integrand for the misfit is (p_pinn - p_exact)^2 = (epsilon * eta)^2\n            # The epsilon^2 will be multiplied at the end. Here we integrate eta^2.\n            integrand = eta_values**2\n            \n            # Integrate using the trapezoidal rule\n            integral_val = np.trapz(integrand, x)\n            sum_of_integrals += integral_val\n\n        # Misfit = |epsilon| * sqrt( (1/(L*M)) * sum(integral(eta^2 dx)) )\n        misfit = abs(epsilon) * np.sqrt(sum_of_integrals / (L * M))\n        results.append(misfit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "PINN的性能在很大程度上取决于配置点（collocation points）的分布。静态的均匀网格在处理具有局部复杂特征（如激波或高频振荡）的解时可能效率低下。本练习将向您介绍一种更高级的自适应策略，以提高求解器的准确性和效率。您将推导一个基于物理残差梯度的误差指标，并实现一个算法，在误差较大的区域自动加密配置点，从而将计算资源集中在最需要的地方 ()。",
            "id": "4134321",
            "problem": "考虑由物理信息神经网络（PINN）代理模型 $p_{\\theta}(x,t)$ 建模的一维声压场，其定义在无量纲时空域 $x \\in [0,1]$ 和 $t \\in [0,1]$ 上。一维小振幅声学的控制方程是齐次线性波动方程\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) - c^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t) = 0,\n$$\n其中 $c$ 是无量纲声速。PINN 通过在配置点上最小化物理残差来强制执行该方程。将代理模型 $p_{\\theta}$ 的物理残差定义为\n$$\nR(x,t) = \\frac{\\partial^2 p_{\\theta}}{\\partial t^2}(x,t) - c^2 \\frac{\\partial^2 p_{\\theta}}{\\partial x^2}(x,t).\n$$\n\n从波动方程的第一性原理和标准微分学出发，推导一个基于梯度的误差指标，用于量化物理残差的快速时空变化。该指标必须由 $R$ 在时空中的梯度构建，并且不得依赖于非物理的启发式方法。然后，提出一种自适应加密算法，通过在 $p_{\\theta}$ 的陡峭梯度附近添加点来加密配置点集，这些点通过 $R$ 的梯度来识别。该算法的表述方式必须能在任何现代编程平台上实现。推导必须从残差和波动方程的定义开始，并在必要时使用合法的微积分步骤和标准的数值近似概念。\n\n为确保具体性和可测试性，设代理模型为可微的行进高斯函数\n$$\np_{\\theta}(x,t) = A \\exp\\left(-\\frac{(x - v t)^2}{2 w^2}\\right),\n$$\n其振幅为 $A$，波速参数为 $v$（不一定等于 $c$），宽度为 $w$。所有量均为无量纲。展示如何求得 $\\frac{\\partial^2 p_{\\theta}}{\\partial t^2}$ 和 $\\frac{\\partial^2 p_{\\theta}}{\\partial x^2}$，然后推导 $R(x,t)$ 及其梯度分量 $\\frac{\\partial R}{\\partial x}(x,t)$ 和 $\\frac{\\partial R}{\\partial t}(x,t)$。将配置点 $(x,t)$ 处的误差指标定义为欧几里得范数\n$$\n\\mathcal{E}(x,t) = \\left\\| \\nabla R(x,t) \\right\\|_2 = \\sqrt{\\left(\\frac{\\partial R}{\\partial x}(x,t)\\right)^2 + \\left(\\frac{\\partial R}{\\partial t}(x,t)\\right)^2}.\n$$\n\n设计一个自适应加密算法，该算法：\n- 在 $[0,1]\\times[0,1]$ 上初始化一个均匀的笛卡尔配置点集 $\\{(x_i,t_j)\\}$。\n- 在所有点上计算 $\\mathcal{E}(x_i,t_j)$。\n- 识别出具有最大 $\\mathcal{E}$ 值的一部分点。\n- 在每个识别出的点附近添加新点，其偏移量在每次加密迭代中缩小为原来的一半，并确保所有新点都保持在 $[0,1]\\times[0,1]$ 内部。\n- 重复指定的加密迭代次数。\n- 报告最终最大指标与初始最大指标之比，\n$$\n\\rho = \\frac{\\max \\mathcal{E}_{\\text{final}}}{\\max \\mathcal{E}_{\\text{initial}}},\n$$\n该比值是一个无量纲浮点数。\n\n您的程序必须使用上面指定的 $p_{\\theta}$ 的精确解析导数来实现所推导的公式和自适应算法。所有量均使用无量纲单位。不使用角度。每个测试用例的最终答案必须是单个浮点数 $\\rho$。\n\n测试套件：\n使用以下四个参数集来测试算法的不同方面（正常路径、陡峭梯度、平滑场和无加密边界情况）。每个测试用例以元组 $(A,c,v,w,N_x,N_t,f,I)$ 的形式给出，其中 $N_x$ 和 $N_t$ 分别是沿 $x$ 和 $t$ 轴的初始点数，$f$ 是每次迭代中选择用于加密的点的比例，$I$ 是加密迭代的次数：\n1. 情况 $1$：$(A,c,v,w,N_x,N_t,f,I) = (1.0, 1.0, 0.9, 0.12, 25, 25, 0.2, 2)$。\n2. 情况 $2$：$(A,c,v,w,N_x,N_t,f,I) = (1.0, 1.0, 0.7, 0.05, 25, 25, 0.3, 3)$。\n3. 情况 $3$：$(A,c,v,w,N_x,N_t,f,I) = (1.0, 1.0, 1.1, 0.30, 25, 25, 0.2, 2)$。\n4. 情况 $4$：$(A,c,v,w,N_x,N_t,f,I) = (1.0, 1.0, 0.8, 0.10, 25, 25, 0.0, 3)$。\n\n答案规格：\n- 对每个测试用例，计算如上定义的浮点数 $\\rho$。\n- 您的程序应生成单行输出，其中包含按测试套件顺序排列的结果，形式为逗号分隔的列表，并用方括号括起来，保留 $6$ 位小数（例如，$[0.123456,0.654321,0.000001,1.000000]$）。",
            "solution": "该问题陈述具有科学依据，提法恰当，客观，并为计算任务提供了完整且一致的设置。它基于基本的线性波动方程以及微分学和数值方法的标准原理。任务是为物理信息神经网络（PINN）代理模型推导一个误差指标，然后基于该指标实现一个自适应加密算法。该问题被认定为有效。\n\n解决方案分两个阶段进行：首先，对所需的数学量进行解析推导；其次，制定并实现自适应加密算法。\n\n**1. 解析推导**\n\n任务的核心是推导误差指标 $\\mathcal{E}(x,t)$，它被定义为物理残差 $R(x,t)$ 梯度的欧几里得范数。\n\n控制方程是一维齐次波动方程：\n$$\n\\frac{\\partial^2 p}{\\partial t^2}(x,t) - c^2 \\frac{\\partial^2 p}{\\partial x^2}(x,t) = 0\n$$\nPINN 代理函数以行进高斯波包的形式给出：\n$$\np_{\\theta}(x,t) = A \\exp\\left(-\\frac{(x - v t)^2}{2 w^2}\\right)\n$$\n为简化微分，令 $\\xi(x,t) = x - v t$。代理函数变为 $p_{\\theta}(\\xi) = A \\exp\\left(-\\frac{\\xi^2}{2 w^2}\\right)$。使用链式法则，关于 $x$ 和 $t$ 的偏导数可以用关于 $\\xi$ 的全导数来表示：\n$$\n\\frac{\\partial}{\\partial x} = \\frac{\\partial \\xi}{\\partial x} \\frac{d}{d \\xi} = (1) \\frac{d}{d \\xi} = \\frac{d}{d \\xi}\n$$\n$$\n\\frac{\\partial}{\\partial t} = \\frac{\\partial \\xi}{\\partial t} \\frac{d}{d \\xi} = (-v) \\frac{d}{d \\xi} = -v \\frac{d}{d \\xi}\n$$\n这个关系式 $\\frac{\\partial}{\\partial t} = -v \\frac{\\partial}{\\partial x}$ 对任何形式为 $f(x-vt)$ 的函数都成立。\n\n首先，我们计算物理残差所需的 $p_{\\theta}$ 的二阶偏导数。\n关于 $x$ 的一阶导数是：\n$$\n\\frac{\\partial p_{\\theta}}{\\partial x} = \\frac{d p_{\\theta}}{d \\xi} = A \\exp\\left(-\\frac{\\xi^2}{2 w^2}\\right) \\left(-\\frac{2\\xi}{2w^2}\\right) = -p_{\\theta} \\frac{\\xi}{w^2}\n$$\n使用乘法法则求得关于 $x$ 的二阶导数：\n$$\n\\frac{\\partial^2 p_{\\theta}}{\\partial x^2} = \\frac{d}{d \\xi} \\left(-p_{\\theta} \\frac{\\xi}{w^2}\\right) = -\\frac{d p_{\\theta}}{d \\xi} \\frac{\\xi}{w^2} - p_{\\theta} \\frac{1}{w^2} = - \\left(-p_{\\theta} \\frac{\\xi}{w^2}\\right) \\frac{\\xi}{w^2} - \\frac{p_{\\theta}}{w^2} = p_{\\theta} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right)\n$$\n使用链式法则关系，关于 $t$ 的二阶导数是：\n$$\n\\frac{\\partial^2 p_{\\theta}}{\\partial t^2} = (-v)^2 \\frac{\\partial^2 p_{\\theta}}{\\partial x^2} = v^2 p_{\\theta} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right)\n$$\n\n现在，我们可以构建物理残差 $R(x,t)$：\n$$\nR(x,t) = \\frac{\\partial^2 p_{\\theta}}{\\partial t^2} - c^2 \\frac{\\partial^2 p_{\\theta}}{\\partial x^2} = v^2 p_{\\theta} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) - c^2 p_{\\theta} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right)\n$$\n$$\nR(x,t) = (v^2 - c^2) p_{\\theta} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right)\n$$\n如果代理模型的速度参数 $v$ 等于介质的声速 $c$，则 $R(x,t)=0$，并且该代理模型是精确解。\n\n接下来，我们推导残差的梯度 $\\nabla R(x,t) = \\left(\\frac{\\partial R}{\\partial x}, \\frac{\\partial R}{\\partial t}\\right)$。我们再次利用链式法则：$\\frac{\\partial R}{\\partial t} = -v \\frac{\\partial R}{\\partial x}$。我们只需要求出 $\\frac{\\partial R}{\\partial x} = \\frac{dR}{d\\xi}$。令 $K = v^2-c^2$。\n$$\n\\frac{\\partial R}{\\partial x} = \\frac{d}{d\\xi} \\left[ K \\cdot p_{\\theta}(\\xi) \\cdot \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) \\right]\n$$\n应用乘法法则：\n$$\n\\frac{\\partial R}{\\partial x} = K \\left[ \\frac{d p_{\\theta}}{d \\xi} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) + p_{\\theta} \\frac{d}{d \\xi} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) \\right]\n$$\n代入已知的导数 $\\frac{d p_{\\theta}}{d \\xi} = -p_{\\theta} \\frac{\\xi}{w^2}$ 和 $\\frac{d}{d\\xi} \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) = \\frac{2\\xi}{w^4}$：\n$$\n\\frac{\\partial R}{\\partial x} = K \\left[ \\left(-p_{\\theta} \\frac{\\xi}{w^2}\\right) \\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) + p_{\\theta} \\left(\\frac{2\\xi}{w^4}\\right) \\right]\n$$\n提取公因式 $K$、$p_{\\theta}$ 和 $\\xi$：\n$$\n\\frac{\\partial R}{\\partial x} = K p_{\\theta} \\xi \\left[ -\\frac{1}{w^2}\\left(\\frac{\\xi^2}{w^4} - \\frac{1}{w^2}\\right) + \\frac{2}{w^4} \\right] = K p_{\\theta} \\xi \\left[ -\\frac{\\xi^2}{w^6} + \\frac{1}{w^4} + \\frac{2}{w^4} \\right]\n$$\n$$\n\\frac{\\partial R}{\\partial x} = K p_{\\theta} \\xi \\left( \\frac{3}{w^4} - \\frac{\\xi^2}{w^6} \\right) = K \\frac{p_{\\theta} \\xi}{w^4} \\left( 3 - \\frac{\\xi^2}{w^2} \\right)\n$$\n代回 $K = v^2 - c^2$ 和 $\\xi = x-vt$：\n$$\n\\frac{\\partial R}{\\partial x}(x,t) = (v^2-c^2) A \\exp\\left(-\\frac{(x - v t)^2}{2 w^2}\\right) \\frac{x-vt}{w^4} \\left(3 - \\frac{(x-vt)^2}{w^2}\\right)\n$$\n时间偏导数为：\n$$\n\\frac{\\partial R}{\\partial t}(x,t) = -v \\frac{\\partial R}{\\partial x}(x,t)\n$$\n\n最后，我们构建误差指标 $\\mathcal{E}(x,t)$：\n$$\n\\mathcal{E}(x,t) = \\sqrt{\\left(\\frac{\\partial R}{\\partial x}\\right)^2 + \\left(\\frac{\\partial R}{\\partial t}\\right)^2} = \\sqrt{\\left(\\frac{\\partial R}{\\partial x}\\right)^2 + \\left(-v\\frac{\\partial R}{\\partial x}\\right)^2} = \\sqrt{\\left(\\frac{\\partial R}{\\partial x}\\right)^2 (1+v^2)}\n$$\n$$\n\\mathcal{E}(x,t) = \\left| \\frac{\\partial R}{\\partial x}(x,t) \\right| \\sqrt{1+v^2}\n$$\n该表达式是算法中使用的解析公式。\n\n**2. 自适应加密算法**\n\n该算法在误差指标 $\\mathcal{E}(x,t)$ 较大的区域自适应地添加配置点，这些区域表示物理残差存在快速的时空变化。\n\n算法流程如下：\n1.  **初始化**：创建一个初始配置点集 $P_0$，它是一个覆盖域 $[0,1] \\times [0,1]$ 的大小为 $N_x \\times N_t$ 的均匀笛卡尔网格。\n2.  **初始评估**：使用推导的解析公式计算 $P_0$ 中所有点的误差指标 $\\mathcal{E}(x,t)$。存储其最大值 $\\max \\mathcal{E}_{\\text{initial}}$。\n3.  **迭代加密**：对总共 $I$ 次迭代重复以下步骤。设 $P_k$ 为第 $k$ 次迭代的点集。\n    a.  **选择**：评估 $P_k$ 中所有点的误差指标 $\\mathcal{E}(x,t)$。确定要加密的点的数量为 $N_{\\text{refine}} = \\lfloor f \\cdot |P_k| \\rfloor$，其中 $f$ 是加密比例，而 $|P_k|$ 是当前集合中的点数。选择具有最大 $\\mathcal{E}$ 值的 $N_{\\text{refine}}$ 个点。\n    b.  **加密**：对于每个选定的点 $(x_p, t_p)$，在其附近添加新点。添加新点的偏移距离随每次迭代而缩小。我们定义一个与初始网格间距相关的基本偏移量，$d_0 = \\frac{1}{2(\\max(N_x, N_t)-1)}$。在第 $i$ 次迭代（$i=1, \\dots, I$）时，偏移距离为 $d_i = d_0 / 2^{i-1}$。在 $(x_p \\pm d_i, t_p)$ 和 $(x_p, t_p \\pm d_i)$ 处生成四个新的候选点。\n    c.  **域内约束与唯一化**：任何落在域 $[0,1] \\times [0,1]$ 外的新点的坐标都被限制在边界值 $0$ 或 $1$。所有新点的集合与现有集合 $P_k$ 合并，并移除重复点以形成新的集合 $P_{k+1}$。\n4.  **最终评估**：经过 $I$ 次迭代后，最终的点集为 $P_{\\text{final}}$。对 $P_{\\text{final}}$ 中的所有点评估误差指标 $\\mathcal{E}(x,t)$，并确定其最大值 $\\max \\mathcal{E}_{\\text{final}}$。\n5.  **度量计算**：最终结果是比率 $\\rho = \\frac{\\max \\mathcal{E}_{\\text{final}}}{\\max \\mathcal{E}_{\\text{initial}}}$。该度量量化了自适应加密过程导致的最大观测误差指标的变化。如果没有发生加密（例如，$f=0$），则 $P_{\\text{final}} = P_0$，且 $\\rho=1$。\n\n此过程为基于物理信息神经网络（PINN）物理残差的梯度自适应加密配置点集提供了一种确定性且可实现的方法。",
            "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to execute the adaptive refinement algorithm for all test cases.\n    \"\"\"\n    test_cases = [\n        # (A, c, v, w, Nx, Nt, f, I)\n        (1.0, 1.0, 0.9, 0.12, 25, 25, 0.2, 2),\n        (1.0, 1.0, 0.7, 0.05, 25, 25, 0.3, 3),\n        (1.0, 1.0, 1.1, 0.30, 25, 25, 0.2, 2),\n        (1.0, 1.0, 0.8, 0.10, 25, 25, 0.0, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho = run_simulation(*case)\n        results.append(rho)\n\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\ndef error_indicator(points, A, c, v, w):\n    \"\"\"\n    Calculates the error indicator E(x,t) for an array of (x,t) points.\n    \n    Args:\n        points (np.ndarray): An (N, 2) array of (x, t) coordinates.\n        A, c, v, w (float): Parameters of the surrogate and wave equation.\n        \n    Returns:\n        np.ndarray: An (N,) array of error indicator values.\n    \"\"\"\n    x = points[:, 0]\n    t = points[:, 1]\n    \n    if w == 0:\n        return np.zeros_like(x)\n\n    xi = x - v * t\n    w_sq = w**2\n    \n    # Calculate dR/dx = (v^2-c^2) * A * exp(...) * ( (x-vt)/w^4 ) * (3 - (x-vt)^2/w^2)\n    # This is the spatial gradient of the physics residual.\n    \n    # This term is zero if v=c, making E zero everywhere.\n    term1 = v**2 - c**2\n    if term1 == 0:\n        return np.zeros_like(x)\n        \n    p_theta_no_A = np.exp(-xi**2 / (2 * w_sq))\n    \n    term2 = xi / w_sq**2\n    term3 = 3 - xi**2 / w_sq\n    \n    dR_dx = term1 * A * p_theta_no_A * term2 * term3\n    \n    # E = |dR/dx| * sqrt(1 + v^2)\n    E = np.abs(dR_dx) * np.sqrt(1 + v**2)\n    \n    return E\n\ndef run_simulation(A, c, v, w, Nx, Nt, f, I):\n    \"\"\"\n    Runs one instance of the adaptive refinement simulation.\n    \n    Args:\n        A, c, v, w (float): Parameters.\n        Nx, Nt (int): Initial grid dimensions.\n        f (float): Fraction of points to refine.\n        I (int): Number of refinement iterations.\n        \n    Returns:\n        float: The ratio rho = max(E_final) / max(E_initial).\n    \"\"\"\n    # 1. Initialization\n    x_coords = np.linspace(0, 1, Nx)\n    t_coords = np.linspace(0, 1, Nt)\n    xx, tt = np.meshgrid(x_coords, t_coords)\n    current_points = np.vstack([xx.ravel(), tt.ravel()]).T\n\n    # 2. Initial Evaluation\n    initial_E = error_indicator(current_points, A, c, v, w)\n    max_E_initial = np.max(initial_E)\n\n    if max_E_initial == 0:\n        # If the initial error is 0, it will remain 0. The ratio is 1 (no change).\n        return 1.0\n\n    # 3. Iterative Refinement\n    if I > 0 and f > 0.0:\n        # Base offset distance, related to initial grid resolution.\n        # N-1 intervals for N points.\n        base_offset = 0.5 / (max(Nx, Nt) - 1 if max(Nx, Nt) > 1 else 1)\n\n        for i in range(1, I + 1):\n            num_points = len(current_points)\n            num_refine = int(np.floor(f * num_points))\n\n            if num_refine == 0:\n                break\n            \n            # a. Selection\n            E_values = error_indicator(current_points, A, c, v, w)\n            # Get indices of the top `num_refine` points with largest E values.\n            refine_indices = np.argsort(E_values)[-num_refine:]\n            points_to_refine = current_points[refine_indices]\n\n            # b. Refinement\n            # Offset shrinks by a factor of 2 each iteration.\n            offset = base_offset / (2**(i - 1))\n            new_points_list = []\n            for p in points_to_refine:\n                px, pt = p[0], p[1]\n                new_points_list.append([px + offset, pt])\n                new_points_list.append([px - offset, pt])\n                new_points_list.append([px, pt + offset])\n                new_points_list.append([px, pt - offset])\n            \n            new_points = np.array(new_points_list)\n\n            # c. Domain Clamping and Uniqueness\n            # Ensure new points are within the [0, 1] x [0, 1] domain.\n            new_points = np.clip(new_points, 0, 1)\n\n            # Add new points to the existing set and remove duplicates.\n            current_points = np.vstack([current_points, new_points])\n            current_points = np.unique(current_points, axis=0)\n\n    # 4. Final Evaluation\n    final_points = current_points\n    final_E = error_indicator(final_points, A, c, v, w)\n    max_E_final = np.max(final_E)\n    \n    # 5. Metric Calculation\n    rho = max_E_final / max_E_initial\n    return rho\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}