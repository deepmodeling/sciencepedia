{
    "hands_on_practices": [
        {
            "introduction": "在投入复杂的数值模拟之前，关键的第一步是分析物理系统。通过计算控制方程中的关键无量纲参数，我们可以预测波的行为——特别是，非线性陡峭是否会主导粘性耗散，从而导致激波的形成。这项练习旨在培养将复杂物理问题提炼为指导模拟策略的基本参数的能力。",
            "id": "4147004",
            "problem": "考虑一个角频率为 $\\omega$、峰值压力幅值为 $p_{a}$ 的一维行进平面声波，该声波在一种粘性的、热学上近乎等熵的液体中传播。该液体的环境密度为 $\\rho_{0}$，小信号声速为 $c_{0}$。该液体具有剪切粘度 $\\mu$ 和体积粘度 $\\zeta$。材料的非线性由标准系数 $\\beta$ 来表征（该系数由状态方程的二阶等熵展开定义）。假设在该考虑的频率范围内，对于这种液体，热效应与粘性效应相比可以忽略不计。\n\n从可压缩粘性流体的质量守恒和动量守恒出发，结合一个二阶等熵状态方程，推导弱非线性、弱衰减平面波在推迟时间坐标系下的一维规范演化方程。找出乘以非线性陡峭项和代表粘性衰减的耗散项的自然无量纲群。用有量纲参数 $\\{\\rho_{0}, c_{0}, \\beta, \\mu, \\zeta, p_{a}, \\omega\\}$ 和波数 $k=\\omega/c_{0}$ 来表示这些群。从此演化方程的无粘性极限，求出正弦波的激波形成距离 $x_{s}$，并将 Gol'dberg 数 $\\Gamma$ 定义为激波形成距离与线性吸收长度之比。\n\n使用以下对于室温液体而言科学上符合实际的参数值：\n- $\\rho_{0}=1000\\,\\mathrm{kg/m^{3}}$，\n- $c_{0}=1500\\,\\mathrm{m/s}$，\n- $\\beta=3.5$，\n- $\\mu=1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，\n- $\\zeta=2.5\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$，\n- $p_{a}=1.5\\times 10^{6}\\,\\mathrm{Pa}$，\n- $f=2.0\\,\\mathrm{MHz}$（因此 $\\omega=2\\pi f$），\n\n计算以下四个无量纲群：\n1. 基于峰值幅度的声学马赫数 $M$。\n2. 非线性耦合强度 $\\epsilon$。\n3. 出现在粘性液体中平面波的推迟时间伯格斯型演化方程中的无量纲耗散参数 $\\delta$。\n4. Gol'dberg 数 $\\Gamma$。\n\n将你的四个数值答案四舍五入到三位有效数字，并以无量纲数的形式报告。然后，根据它们的大小，论证哪些项在导致激波形成的动力学中占主导地位，以及在这种情景下的时域仿真框架中哪些项可以忽略。就本题而言，你必须将四个无量纲值作为你的最终答案。任何定性论证只应出现在你的解答中。",
            "solution": "该问题陈述具有科学依据、提法明确，并包含足够的信息来推导所要求的量并计算其数值。该物理情景描述了耗散流体中的弱非线性声传播，这是非线性声学中的一个经典课题，由诸如伯格斯方程之类的方程所支配。所提供的参数对于高强度超声条件下的水是符合实际的。因此，该问题被认为是有效的。\n\n推导始于可压缩粘性流体的一维质量和动量守恒方程，以及一个二阶等熵状态方程。\n\n质量守恒方程为：\n$$ \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial (\\rho u)}{\\partial x} = 0 $$\n动量守恒方程，包括纵向平面波的粘性应力，为：\n$$ \\rho \\left( \\frac{\\partial u}{\\partial t} + u \\frac{\\partial u}{\\partial x} \\right) = -\\frac{\\partial p}{\\partial x} + \\left(\\zeta + \\frac{4}{3}\\mu\\right) \\frac{\\partial^2 u}{\\partial x^2} $$\n其中 $\\rho$ 是密度， $u$ 是质点速度， $p$ 是压力， $\\mu$ 是剪切粘度， $\\zeta$ 是体积粘度。\n\n状态方程关联了压力和密度。对于等熵过程，我们可以在环境状态 $(p_0, \\rho_0)$ 附近将 $p(\\rho)$ 展开为泰勒级数：\n$$ p - p_0 = A \\left(\\frac{\\rho - \\rho_0}{\\rho_0}\\right) + \\frac{B}{2} \\left(\\frac{\\rho - \\rho_0}{\\rho_0}\\right)^2 + \\mathcal{O}\\left(\\left(\\frac{\\rho - \\rho_0}{\\rho_0}\\right)^3\\right) $$\n小信号声速 $c_0$ 由 $c_0^2 = (\\partial p/\\partial \\rho)_S |_{\\rho_0} = A/\\rho_0$ 定义。非线性系数 $\\beta$ 定义为 $\\beta = 1 + \\frac{B}{2A}$。\n\n对弱非线性（$p'/\\rho_0 c_0^2 \\ll 1$）和弱耗散波使用微扰分析，这些方程可以组合成一个单一的演化方程。这是非线性声学中的一个标准程序。对于沿 $+x$ 方向传播的行波，使用推迟时间坐标 $\\tau = t - x/c_0$ 很方便。得到的演化方程，通常是伯格斯方程或韦斯特维尔特方程对于平面波的一种形式，是：\n$$ \\frac{\\partial p'}{\\partial x} - \\frac{\\beta}{\\rho_0 c_0^3} p' \\frac{\\partial p'}{\\partial \\tau} = \\frac{b}{2\\rho_0 c_0^3} \\frac{\\partial^2 p'}{\\partial \\tau^2} $$\n其中 $p' = p-p_0$ 是声压， $b = \\zeta + \\frac{4}{3}\\mu$ 是有效粘度系数。\n\n该方程描述了波形 $p'(\\tau)$ 沿 $x$ 传播时的变化。左边的第二项是非线性陡峭项，右边的项是由于粘性引起的耗散项。\n\n我们现在来确定自然的无量纲群。\n1.  **声学马赫数 $M$**：这是峰值质点速度 $u_a$ 与声速 $c_0$ 之比。使用平面波声阻抗关系 $p_a = \\rho_0 c_0 u_a$，我们有：\n    $$ M = \\frac{u_a}{c_0} = \\frac{p_a}{\\rho_0 c_0^2} $$\n    这个参数量化了波的幅度。\n\n2.  **非线性耦合强度 $\\epsilon$**：虽然有时与 $M$ 互换使用，但本题要求分开计算。演化方程中非线性项强度的一个逻辑定义是组合 $\\beta M$。该参数 $\\epsilon = \\beta M$ 通过将材料特性 $\\beta$ 与波幅 $M$ 相结合来表示有效非线性。\n    $$ \\epsilon = \\beta M = \\frac{\\beta p_a}{\\rho_0 c_0^2} $$\n\n3.  **无量纲耗散参数 $\\delta$**：一个自然的耗散无量纲参数是声学雷诺数的倒数，它比较了在特征频率 $\\omega$ 下的粘性力与惯性力。\n    $$ \\delta = \\frac{b\\omega}{\\rho_0 c_0^2} = \\frac{(\\zeta + \\frac{4}{3}\\mu)\\omega}{\\rho_0 c_0^2} $$\n\n4.  **Gol'dberg 数 $\\Gamma$**：本题将其定义为激波形成距离 $x_s$ 与线性吸收长度 $L_a$ 之比。\n    在无粘性极限（$b=0$）下，演化方程预测，一个初始为正弦的波 $p'(x=0,t) = p_a \\sin(\\omega t)$ 将会变陡并在距离 $x_s$ 处形成一个不连续面（激波）：\n    $$ x_s = \\frac{\\rho_0 c_0^3}{\\beta \\omega p_a} $$\n    线性吸收长度 $L_a$ 是波幅仅因粘性损失而衰减到 $1/e$ 倍的距离。它是振幅衰减系数 $\\alpha$ 的倒数。从演化方程的线性部分，可以求得 $\\alpha$ 为：\n    $$ \\alpha = \\frac{b\\omega^2}{2\\rho_0 c_0^3} $$\n    因此， $L_a = 1/\\alpha = \\frac{2\\rho_0 c_0^3}{b\\omega^2}$。\n    那么 Gol'dberg 数 $\\Gamma$ 为：\n    $$ \\Gamma = \\frac{x_s}{L_a} = x_s \\alpha = \\left(\\frac{\\rho_0 c_0^3}{\\beta \\omega p_a}\\right) \\left(\\frac{b\\omega^2}{2\\rho_0 c_0^3}\\right) = \\frac{b\\omega}{2\\beta p_a} $$\n    注意所定义参数之间的关系： $\\Gamma = \\frac{1}{2}\\frac{\\delta}{\\epsilon}$。\n\n现在，我们使用所提供的数据计算这四个群的数值：\n- $\\rho_{0}=1000\\,\\mathrm{kg/m^{3}}$\n- $c_{0}=1500\\,\\mathrm{m/s}$\n- $\\beta=3.5$\n- $\\mu=1.0\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$\n- $\\zeta=2.5\\times 10^{-3}\\,\\mathrm{Pa\\cdot s}$\n- $p_{a}=1.5\\times 10^{6}\\,\\mathrm{Pa}$\n- $f=2.0\\,\\mathrm{MHz} = 2.0 \\times 10^6 \\, \\mathrm{Hz}$\n\n首先，我们计算一些中间量：\n- 角频率： $\\omega = 2\\pi f = 2\\pi (2.0 \\times 10^6) = 4\\pi \\times 10^6 \\, \\mathrm{rad/s} \\approx 1.2566 \\times 10^7 \\, \\mathrm{rad/s}$。\n- 有效粘度： $b = \\zeta + \\frac{4}{3}\\mu = (2.5 \\times 10^{-3}) + \\frac{4}{3}(1.0 \\times 10^{-3}) = (\\frac{7.5}{3} + \\frac{4}{3}) \\times 10^{-3} = \\frac{11.5}{3} \\times 10^{-3} \\, \\mathrm{Pa\\cdot s} \\approx 3.833 \\times 10^{-3} \\, \\mathrm{Pa\\cdot s}$。\n- $\\rho_0 c_0^2$ 的值： $\\rho_0 c_0^2 = 1000 \\, (1500)^2 = 10^3 \\times 2.25 \\times 10^6 = 2.25 \\times 10^9 \\, \\mathrm{Pa}$。\n\n1.  **声学马赫数 $M$**：\n    $$ M = \\frac{p_a}{\\rho_0 c_0^2} = \\frac{1.5 \\times 10^6}{2.25 \\times 10^9} = \\frac{1.5}{2.25} \\times 10^{-3} = \\frac{2}{3} \\times 10^{-3} \\approx 6.667 \\times 10^{-4} $$\n    保留三位有效数字， $M = 6.67 \\times 10^{-4}$。\n\n2.  **非线性耦合强度 $\\epsilon$**：\n    $$ \\epsilon = \\frac{\\beta p_a}{\\rho_0 c_0^2} = \\beta M = 3.5 \\times \\left(\\frac{2}{3} \\times 10^{-3}\\right) = \\frac{7}{3} \\times 10^{-3} \\approx 2.333 \\times 10^{-3} $$\n    保留三位有效数字， $\\epsilon = 2.33 \\times 10^{-3}$。\n\n3.  **无量纲耗散参数 $\\delta$**：\n    $$ \\delta = \\frac{b\\omega}{\\rho_0 c_0^2} = \\frac{(\\frac{11.5}{3} \\times 10^{-3}) \\times (4\\pi \\times 10^6)}{2.25 \\times 10^9} = \\frac{46\\pi \\times 10^3}{3 \\times 2.25 \\times 10^9} \\approx 2.141 \\times 10^{-5} $$\n    保留三位有效数字， $\\delta = 2.14 \\times 10^{-5}$。\n\n4.  **Gol'dberg 数 $\\Gamma$**：\n    $$ \\Gamma = \\frac{b\\omega}{2\\beta p_a} = \\frac{(\\frac{11.5}{3} \\times 10^{-3}) \\times (4\\pi \\times 10^6)}{2 \\times 3.5 \\times (1.5 \\times 10^6)} = \\frac{46\\pi \\times 10^3}{3 \\times 10.5 \\times 10^6} \\approx 4.587 \\times 10^{-3} $$\n    保留三位有效数字， $\\Gamma = 4.59 \\times 10^{-3}$。\n\n基于这些数值，Gol'dberg 数 $\\Gamma \\approx 4.59 \\times 10^{-3}$，远小于 $1$。由于 $\\Gamma = x_s/L_a$，这意味着激波形成距离 $x_s$ 远小于吸收长度 $L_a$。因此，非线性波形陡峭是主导的物理效应。声波将在粘性力能够显著衰减整个波之前迅速畸变并形成一个类激波波前。在时域仿真中，非线性项是至关重要的，并将驱动动力学过程，而耗散项虽然总体效应较小，但对于使激波波前正则化并确定其有限厚度是必不可少的。",
            "answer": "$$ \\boxed{\n\\begin{pmatrix}\n6.67 \\times 10^{-4} & 2.33 \\times 10^{-3} & 2.14 \\times 10^{-5} & 4.59 \\times 10^{-3}\n\\end{pmatrix}\n} $$"
        },
        {
            "introduction": "构建一个稳健的激波捕捉格式需要仔细关注其数值通量的构造，以确保解的物理正确性。一个众所周知的问题是某些格式会产生违反熵条件的激波。本练习将通过对伯格斯方程(Burgers' equation)比较不同的通量函数，让您亲身体验这一问题，并展示一个简单的“熵修正”如何强制实现正确的物理行为。",
            "id": "4147034",
            "problem": "考虑由无粘性标量守恒律（即 Burgers 方程）建模的一维非线性声波陡峭化问题。Burgers 方程在计算声学中被广泛用于近似模拟单向传播下有限振幅波中激波的形成：\n$$\n\\partial_t u(x,t) + \\partial_x f\\big(u(x,t)\\big) = 0,\n$$\n其中通量为 $$f(u) = \\tfrac{1}{2} u^2$$，特征速度为 $$a(u) = f'(u) = u$$。对于形成激波的波场，物理相关解是熵解，它满足凸熵对 $$\\eta(u) = \\tfrac{1}{2}u^2$$ 和 $$q(u) = \\tfrac{1}{3}u^3$$ 的熵不等式：\n$$\n\\partial_t \\eta(u) + \\partial_x q(u) \\le 0,\n$$\n在激波处为严格不等式。这意味着，当激波形成时，$$\\eta$$ 在周期性闭合域上的空间积分 $$S(t) = \\int_0^L \\eta\\big(u(x,t)\\big) \\, dx,$$ 不应随时间增加；而在没有激波的光滑稀疏波情况下，该积分应保持恒定。\n\n要求您在一个周期性域 $$x \\in [0,L]$$（$$L=1$$）上实现一个有限体积法时域模拟器，以比较将不同数值格式应用于 Burgers 方程时的熵行为：\n-   一种使用简单算术平均界面通量的中心格式，\n-   一种基于 Roe 线性化且不带熵修正的迎风格式，\n-   一种在声速点附近增加了 Harten 熵修正的相同 Roe 迎风格式。\n\n在具有 $$N$$ 个单元（尺寸为 $$\\Delta x = L/N$$）的均匀网格上，单元平均值 $$u_i(t)$$ 的半离散有限体积更新公式为\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n其中 $$F_{i+\\frac{1}{2}}$$ 是界面 $$x_{i+\\frac{1}{2}}$$ 处的数值通量。使用周期性索引，使得 $$u_{-1} \\equiv u_{N-1}$$ 和 $$u_{N} \\equiv u_{0}$$。\n\n定义以下通量：\n-   中心平均通量：\n$$\nF_{i+\\frac{1}{2}}^{\\mathrm{central}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right).\n$$\n-   不带熵修正的 Roe 迎风通量：\n$$\na_{i+\\frac{1}{2}}^{\\mathrm{Roe}} = \\frac{u_i + u_{i+1}}{2}, \\quad\nF_{i+\\frac{1}{2}}^{\\mathrm{Roe}} = \\frac{1}{2} \\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{1}{2} \\left| a_{i+\\frac{1}{2}}^{\\mathrm{Roe}} \\right| \\left( u_{i+1} - u_i \\right).\n$$\n-   带 Harten 熵修正（在声速点附近）的 Roe 迎风通量：\n引入一个平滑阈值 $$\\delta_{i+\\frac{1}{2}} = \\varepsilon \\, \\max_j \\left| a_{j+\\frac{1}{2}}^{\\mathrm{Roe}} \\right|$$，其中 $$\\varepsilon \\in (0,1)$$ 是一个小值，并将 $$\\left| a_{i+\\frac{1}{2}}^{\\mathrm{Roe}} \\right|$$ 替换为\n$$\n\\phi\\!\\left(a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}\\right) =\n\\begin{cases}\n\\frac{1}{2}\\left(\\frac{a^2}{\\delta} + \\delta\\right), & \\text{if } |a| < \\delta, \\\\\n|a|, & \\text{otherwise,}\n\\end{cases}\n$$\n其中 $$a \\equiv a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}$$ 且 $$\\delta \\equiv \\delta_{i+\\frac{1}{2}}$$. 然后定义\n$$\nF_{i+\\frac{1}{2}}^{\\mathrm{Roe\\text{-}fix}} = \\frac{1}{2} \\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{1}{2} \\, \\phi\\!\\left(a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}\\right) \\left( u_{i+1} - u_i \\right).\n$$\n\n使用基于 $$\\max_i |u_i|$$ 的 Courant–Friedrichs–Lewy (CFL) 准则的标准显式时间步进：\n$$\n\\Delta t = \\mathrm{CFL} \\, \\frac{\\Delta x}{\\max_i |u_i| + 10^{-12}},\n$$\n其中中心格式的 $$\\mathrm{CFL}=0.2$$，Roe 变体格式的 $$\\mathrm{CFL}=0.5$$。初始化熵\n$$\nS(t) = \\sum_{i=0}^{N-1} \\frac{1}{2} u_i(t)^2 \\, \\Delta x,\n$$\n并监测其变化 $$\\Delta S = S(t_{\\mathrm{end}}) - S(0)$$。\n\n对于下面的测试套件，在 $$N$$ 个均匀单元上定义指定的初始条件，并演化至 $$t_{\\mathrm{end}}$$. 全程使用指定的周期性边界和无量纲单位。对于每个测试用例，根据以下准则计算三个布尔值，以指示相应格式是否表现出熵违背：\n-   对于激波形成的情况：若 $$\\Delta S > 10^{-6}$$ 则发生违背（当激波形成时，熵不应增加）。\n-   对于光滑稀疏波的情况：若 $$|\\Delta S| > 10^{-6}$$ 则发生违背（在没有激波的情况下，熵应保持恒定）。\n\n测试套件：\n1. 形成激波的正弦波：\n   - $$N = 400$$，初始条件 $$u(x,0) = A \\sin(2\\pi x)$$，其中 $$A=1.0$$，演化至 $$t_{\\mathrm{end}} = 0.20$$。\n2. 跨音速稀疏阶跃：\n   - $$N = 400$$，当 $$x  0.5$$ 时初始条件为 $$u(x,0) = u_L$$，当 $$x \\ge 0.5$$ 时为 $$u(x,0) = u_R$$，其中 $$u_L = -0.2$$ 且 $$u_R = 0.2$$，演化至 $$t_{\\mathrm{end}} = 0.10$$。\n3. 强稀疏阶跃：\n   - $$N = 400$$，当 $$x  0.5$$ 时初始条件为 $$u(x,0) = u_L$$，当 $$x \\ge 0.5$$ 时为 $$u(x,0) = u_R$$，其中 $$u_L = -1.0$$ 且 $$u_R = 1.0$$，演化至 $$t_{\\mathrm{end}} = 0.05$$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个按 [central,roe,roe_fix] 顺序排列的、包含三个布尔值的列表。例如：\n\"[ [False,True,False] , [False,False,False] , [True,False,False] ]\"",
            "solution": "用户提供了一个来自计算声学领域的有效且良构的问题陈述。该问题具有科学依据、内容自洽，要求实现并比较求解双曲守恒律的标准数值方法。所有提供的数据、方程和条件都是一致且足以用于开发解决方案的。\n\n该问题要求模拟一维无粘性 Burgers 方程，这是一个原型标量守恒律，其形式如下：\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0\n$$\n其中状态变量为 $$u(x,t)$$，非线性通量为 $$f(u) = \\frac{1}{2} u^2$$。特征速度为 $$a(u) = f'(u) = u$$。我们需要使用有限体积法在周期性域 $$x \\in [0,L]$$（$$L=1$$）上求解此方程。目标是研究不同的数值通量函数如何影响离散形式总熵 $$S(t) = \\int_0^L \\eta(u) \\, dx$$ 的守恒性，其中熵函数为 $$\\eta(u) = \\frac{1}{2}u^2$$。对于物理上正确的（熵）解，当 $$t_2 > t_1$$ 时，该量必须不随时间增加，即 $$S(t_2) \\le S(t_1)$$。\n\n数值框架是在一个包含 $$N$$ 个单元（每个宽度为 $$\\Delta x = L/N$$）的均匀网格上的半离散有限体积法。单元平均状态 $$u_i$$ 的更新方程为：\n$$\nu_i^{n+1} = u_i^n - \\frac{\\Delta t}{\\Delta x} \\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n这里，$$F_{i+\\frac{1}{2}}$$ 是单元 $$i$$ 和单元 $$i+1$$ 之间界面上的数值通量。施加周期性边界条件。时间积分使用显式前向欧拉法进行，时间步长 $$\\Delta t$$ 由 Courant–Friedrichs–Lewy (CFL) 条件确定：\n$$\n\\Delta t = \\mathrm{CFL} \\, \\frac{\\Delta x}{\\max_i |u_i| + 10^{-12}}\n$$\n为了数值稳定性，在分母上增加了一个小常数 $$10^{-12}$$。\n\n我们将实现并比较三种不同的数值通量公式：\n\n1.  **中心平均通量**：\n    $$\n    F_{i+\\frac{1}{2}}^{\\mathrm{central}} = \\frac{1}{2}\\left(f(u_i) + f(u_{i+1})\\right)\n    $$\n    这是最简单的通量。它是非耗散的，这意味着它不抑制数值振荡。对于双曲问题，这种缺乏耗散的特性常会导致不稳定性，尤其是在激波附近，可能引起总熵的非物理增加。\n\n2.  **Roe 迎风通量**：\n    $$\n    F_{i+\\frac{1}{2}}^{\\mathrm{Roe}} = \\frac{1}{2} \\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{1}{2} \\left| a_{i+\\frac{1}{2}}^{\\mathrm{Roe}} \\right| \\left( u_{i+1} - u_i \\right)\n    $$\n    其中 $$a_{i+\\frac{1}{2}}^{\\mathrm{Roe}} = \\frac{u_i + u_{i+1}}{2}$$ 是 Roe 平均特征速度。第二项与 $$|a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}|$$ 成正比，引入了依赖于波速的数值耗散，使格式具有“迎风”特性。该格式对间断点具有高精度。然而，它在声速点（即特征速度穿过零点，例如 $$u_i  0$$ 且 $$u_{i+1} > 0$$）处存在一个众所周知的缺陷。在此处，$$a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}$$ 可能接近于零，导致耗散不足。这会允许形成违背熵条件的稀疏激波。\n\n3.  **带 Harten 熵修正的 Roe 迎风通量**：\n    为了修正 Roe 通量的缺陷，我们修改耗散项。我们将 $$\\left| a_{i+\\frac{1}{2}}^{\\mathrm{Roe}} \\right|$$ 替换为一个函数 $$\\phi(a_{i+\\frac{1}{2}}^{\\mathrm{Roe}})$$，该函数在声速点附近增加数值粘性。修正后的绝对值函数为：\n    $$\n    \\phi(a) =\n    \\begin{cases}\n    \\frac{1}{2}\\left(\\frac{a^2}{\\delta} + \\delta\\right),  \\text{if } |a|  \\delta \\\\\n    |a|,  \\text{otherwise}\n    \\end{cases}\n    $$\n    阈值 $$\\delta$$ 基于域中的最大波速，$$\\delta = \\varepsilon \\, \\max_j \\left| a_{j+\\frac{1}{2}}^{\\mathrm{Roe}} \\right|$$，其中我们选择一个小参数 $$\\varepsilon = 0.1$$。这种“熵修正”确保有足够的数值耗散来防止在跨音速稀疏波中形成非物理激波，从而强制满足熵条件。通量变为：\n    $$\n    F_{i+\\frac{1}{2}}^{\\mathrm{Roe\\text{-}fix}} = \\frac{1}{2} \\left( f(u_i) + f(u_{i+1}) \\right) - \\frac{1}{2} \\, \\phi\\left(a_{i+\\frac{1}{2}}^{\\mathrm{Roe}}\\right) \\left( u_{i+1} - u_i \\right)\n    $$\n\n算法流程如下：首先根据给定的测试用例在 $$N$$ 个单元上初始化状态向量 $$u_0$$。计算并存储初始离散熵 $$S(0) = \\sum_{i=0}^{N-1} \\frac{1}{2} u_i(0)^2 \\, \\Delta x$$。然后，将解随时间演化至 $$t_{\\mathrm{end}}$$. 在每个时间步长中，在所有单元界面上计算合适的数值通量，并更新状态向量 $$u$$。在最后一个时间步长之后，计算最终熵 $$S(t_{\\mathrm{end}})$$，并确定其变化量 $$\\Delta S = S(t_{\\mathrm{end}}) - S(0)$$。\n\n最后，我们根据提供的准则判断是否发生了熵违背：\n-   对于激波形成问题（预期会发生一些物理耗散），如果 $$\\Delta S > 10^{-6}$$，则标记为一次违背。\n-   对于光滑稀疏波问题（其中精确解的熵是守恒的），如果 $$|\\Delta S| > 10^{-6}$$，则标记为一次违背。\n\n对三个测试用例中的每一个和三种数值格式中的每一种重复此过程，以生成所需的结果布尔矩阵。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef flux_function(u):\n    \"\"\"Computes the Burgers' flux F(u) = 0.5 * u^2.\"\"\"\n    return 0.5 * u**2\n\ndef get_flux_central(u):\n    \"\"\"Computes the central average flux F_{i+1/2}.\"\"\"\n    f_u = flux_function(u)\n    f_u_ip1 = np.roll(f_u, -1)\n    flux_interface = 0.5 * (f_u + f_u_ip1)\n    return flux_interface\n\ndef get_flux_roe(u):\n    \"\"\"Computes the Roe upwind flux F_{i+1/2} without entropy fix.\"\"\"\n    f_u = flux_function(u)\n    u_ip1 = np.roll(u, -1)\n    f_u_ip1 = flux_function(u_ip1)\n\n    a_roe = 0.5 * (u + u_ip1)\n    dissipation = np.abs(a_roe) * (u_ip1 - u)\n\n    flux_interface = 0.5 * (f_u + f_u_ip1) - 0.5 * dissipation\n    return flux_interface\n\ndef get_flux_roe_fix(u, epsilon):\n    \"\"\"Computes the Roe upwind flux F_{i+1/2} with Harten entropy fix.\"\"\"\n    f_u = flux_function(u)\n    u_ip1 = np.roll(u, -1)\n    f_u_ip1 = flux_function(u_ip1)\n\n    a_roe = 0.5 * (u + u_ip1)\n\n    max_abs_a_roe = np.max(np.abs(a_roe))\n    delta = epsilon * max_abs_a_roe\n    \n    phi_a = np.abs(a_roe)\n    # The check for delta > 0 avoids division by zero if all a_roe are zero\n    if delta > 1e-12:\n        sonic_points = np.abs(a_roe)  delta\n        a_sonic = a_roe[sonic_points]\n        phi_a[sonic_points] = 0.5 * (a_sonic**2 / delta + delta)\n\n    dissipation = phi_a * (u_ip1 - u)\n    flux_interface = 0.5 * (f_u + f_u_ip1) - 0.5 * dissipation\n    return flux_interface\n\ndef simulate(u0, N, L, t_end, scheme, cfl, epsilon=0.1):\n    \"\"\"Runs a single finite-volume simulation.\"\"\"\n    dx = L / N\n    u = u0.copy()\n    \n    # Calculate initial entropy: S(t) = sum(eta(u_i) * dx)\n    S0 = 0.5 * np.sum(u**2) * dx\n    \n    t = 0.0\n    while t  t_end:\n        max_u = np.max(np.abs(u))\n        dt = cfl * dx / (max_u + 1e-12)\n        \n        # Ensure the final time step does not overshoot t_end\n        if t + dt > t_end:\n            dt = t_end - t\n            \n        # Select flux calculation based on scheme type\n        if scheme == 'central':\n            flux = get_flux_central(u)\n        elif scheme == 'roe':\n            flux = get_flux_roe(u)\n        elif scheme == 'roe_fix':\n            flux = get_flux_roe_fix(u, epsilon)\n        \n        # Flux at interface i-1/2 is np.roll(flux, 1)\n        flux_im12 = np.roll(flux, 1)\n        \n        # Update cell averages using FV formaula\n        u = u - (dt / dx) * (flux - flux_im12)\n        \n        t += dt\n\n    # Calculate final entropy and the change\n    S_final = 0.5 * np.sum(u**2) * dx\n    delta_S = S_final - S0\n    return delta_S\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # 1. Shock-forming sinusoid\n        {\n            \"N\": 400, \"L\": 1.0, \n            \"u0_func\": lambda x: 1.0 * np.sin(2 * np.pi * x),\n            \"t_end\": 0.20, \"type\": \"shock\",\n        },\n        # 2. Transonic rarefaction step\n        {\n            \"N\": 400, \"L\": 1.0, \n            \"u0_func\": lambda x: np.where(x  0.5, -0.2, 0.2),\n            \"t_end\": 0.10, \"type\": \"rarefaction\",\n        },\n        # 3. Strong rarefaction step\n        {\n            \"N\": 400, \"L\": 1.0,\n            \"u0_func\": lambda x: np.where(x  0.5, -1.0, 1.0),\n            \"t_end\": 0.05, \"type\": \"rarefaction\",\n        }\n    ]\n\n    all_results = []\n    # Epsilon for Harten's entropy fix\n    epsilon_fix = 0.1\n    tolerance = 1e-6\n\n    for case in test_cases:\n        N = case[\"N\"]\n        L = case[\"L\"]\n        dx = L / N\n        # Define cell-centered grid\n        x = (np.arange(N) + 0.5) * dx\n\n        u0 = case[\"u0_func\"](x)\n\n        # CFL numbers for each scheme\n        cfl_central = 0.2\n        cfl_roe = 0.5\n\n        # Run simulations\n        delta_S_central = simulate(u0, N, L, case[\"t_end\"], 'central', cfl=cfl_central)\n        delta_S_roe = simulate(u0, N, L, case[\"t_end\"], 'roe', cfl=cfl_roe)\n        delta_S_roe_fix = simulate(u0, N, L, case[\"t_end\"], 'roe_fix', cfl=cfl_roe, epsilon=epsilon_fix)\n\n        delta_S_values = [delta_S_central, delta_S_roe, delta_S_roe_fix]\n        \n        case_violations = []\n        for ds in delta_S_values:\n            violation = False\n            if case[\"type\"] == \"shock\":\n                if ds > tolerance:\n                    violation = True\n            elif case[\"type\"] == \"rarefaction\":\n                if abs(ds) > tolerance:\n                    violation = True\n            case_violations.append(violation)\n        \n        all_results.append(case_violations)\n\n    # Format the final output string to match the specified format\n    # Example: \"[ [False,True,False] , [False,False,False] ]\"\n    inner_strings = [str(r).replace(\" \", \"\") for r in all_results]\n    final_output_string = f\"[{' , '.join(inner_strings)}]\"\n    print(final_output_string)\n\nsolve()\n```"
        },
        {
            "introduction": "这是本章的综合性实践，将理论概念应用于构建和验证一个完整的求解器。与已知解进行对比验证是计算科学的基石，它为代码的准确性提供了信心。本练习涉及为完整的欧拉方程组实现一个有限体积求解器，并使用经典的激波管问题来对照精确解来衡量其性能，这是任何计算声学专家都应具备的基本技能。",
            "id": "4147041",
            "problem": "您的任务是为可压缩欧拉方程实现一个一维时域有限体积法求解器，以模拟声学激波管中的激波形成与传播。该求解器必须针对代表声学配置的选定初始状态，通过与精确黎曼解进行比对来验证。您的程序必须为固定的测试套件生成单行输出，其中包含所要求的精度指标。问题中的所有量都必须使用指定的物理单位进行处理。\n\n从以下基本依据开始：\n- 一维无粘性可压缩流体的质量、动量和能量守恒：\n$$\n\\frac{\\partial}{\\partial t}\n\\begin{bmatrix}\n\\rho \\\\\n\\rho u \\\\\nE\n\\end{bmatrix}\n+\n\\frac{\\partial}{\\partial x}\n\\begin{bmatrix}\n\\rho u \\\\\n\\rho u^2 + p \\\\\nu(E + p)\n\\end{bmatrix}\n=\n\\mathbf{0},\n$$\n其中，$ \\rho $ 是质量密度（单位为 $\\mathrm{kg/m^3}$），$ u $ 是速度（单位为 $\\mathrm{m/s}$），$ E $ 是总能量密度（单位为 $\\mathrm{J/m^3}$），$ p $ 是压力（单位为 $\\mathrm{Pa}$）。\n- 将空气建模为完美气体的理想气体状态方程：$ p = (\\gamma - 1)\\left(E - \\frac{1}{2}\\rho u^2\\right) $，其中 $ \\gamma = 1.4 $。\n- 声速定义：$ a = \\sqrt{\\gamma p / \\rho} $。\n- 基于与局部Lax-Friedrichs（也称为Rusanov）通量一致的单调格式的数值通量。\n\n您的求解器必须：\n- 将长度为 $ L $（单位为 $\\mathrm{m}$）的空间域离散为 $ N $ 个均匀单元，并采用透射（零梯度）边界条件。\n- 使用显式时间推进格式，其Courant-Friedrichs-Lewy (CFL) 条件根据全域最大信号速度 $ |u| + a $ 计算。\n- 通过在时间 $ t = 0 $ 时，在中点 $ x_0 = L/2 $ 处设置均匀的左右状态来初始化激波管。\n- 演化至指定的最终时间 $ t_{\\mathrm{end}} $（单位为 $\\mathrm{s}$）。\n\n为进行验证，请针对相同的初始状态和理想气体，计算在时间 $ t_{\\mathrm{end}} $ 时激波管问题的精确自相似黎曼解。通过全域积分的 $ L^1 $ 误差，比较数值密度场 $ \\rho_{\\mathrm{num}}(x) $ 与精确密度 $ \\rho_{\\mathrm{exact}}(x) $：\n$$\n\\varepsilon_{L^1} = \\int_0^L \\left| \\rho_{\\mathrm{num}}(x) - \\rho_{\\mathrm{exact}}(x) \\right| \\, dx,\n$$\n在离散均匀网格上，这简化为黎曼和 $ \\varepsilon_{L^1} \\approx \\sum_{i=1}^{N} \\left| \\rho_{\\mathrm{num},i} - \\rho_{\\mathrm{exact},i} \\right| \\Delta x $，其中 $ \\Delta x = L / N $。由于 $ \\varepsilon_{L^1} $ 是密度差对长度的积分，请以 $\\mathrm{kg/m^2}$ 为单位表示。\n\n实现您的程序以运行以下测试套件，该套件涵盖一个典型的声学激波管、一个小振幅声学跳跃以及一个边界条件健全性检验案例：\n- 测试案例 1（声学激波管，类Sod问题）：\n  - $ \\gamma = 1.4 $,\n  - $ L = 1.0 \\, \\mathrm{m} $,\n  - $ N = 400 $,\n  - $ t_{\\mathrm{end}} = 0.001 \\, \\mathrm{s} $,\n  - 左侧状态 $ (\\rho_L, u_L, p_L) = (1.0 \\, \\mathrm{kg/m^3}, 0.0 \\, \\mathrm{m/s}, 1.0 \\times 10^5 \\, \\mathrm{Pa}) $,\n  - 右侧状态 $ (\\rho_R, u_R, p_R) = (0.125 \\, \\mathrm{kg/m^3}, 0.0 \\, \\mathrm{m/s}, 1.0 \\times 10^4 \\, \\mathrm{Pa}) $.\n- 测试案例 2（小振幅声学跳跃）：\n  - $ \\gamma = 1.4 $,\n  - $ L = 1.0 \\, \\mathrm{m} $,\n  - $ N = 400 $,\n  - $ t_{\\mathrm{end}} = 0.001 \\, \\mathrm{s} $,\n  - 左侧状态 $ (\\rho_L, u_L, p_L) = (1.05 \\, \\mathrm{kg/m^3}, 0.0 \\, \\mathrm{m/s}, 1.05 \\times 10^5 \\, \\mathrm{Pa}) $,\n  - 右侧状态 $ (\\rho_R, u_R, p_R) = (1.0 \\, \\mathrm{kg/m^3}, 0.0 \\, \\mathrm{m/s}, 1.0 \\times 10^5 \\, \\mathrm{Pa}) $.\n- 测试案例 3（均匀状态，边界条件健全性检验）：\n  - $ \\gamma = 1.4 $,\n  - $ L = 1.0 \\, \\mathrm{m} $,\n  - $ N = 200 $,\n  - $ t_{\\mathrm{end}} = 0.001 \\, \\mathrm{s} $,\n  - 左侧状态 $ (\\rho_L, u_L, p_L) = (1.0 \\, \\mathrm{kg/m^3}, 0.0 \\, \\mathrm{m/s}, 1.0 \\times 10^5 \\, \\mathrm{Pa}) $,\n  - 右侧状态与左侧相同。\n\n您的程序应生成单行输出，其中包含三个测试案例的 $ L^1 $ 密度误差，格式为用方括号括起来的逗号分隔的Python列表。例如，输出形式为 $ [e_1,e_2,e_3] $，其中每个 $ e_k $ 是一个以 $\\mathrm{kg/m^2}$ 为单位的浮点数，且不含任何附加文本。输出必须采用精确指定的格式，并且数值必须通过您的模拟和精确解验证计算得出。\n\n您不得依赖任何外部输入，并必须确保所有计算均使用指定的物理单位。本问题不涉及角度。本问题不涉及百分比。\n\n注意：本问题要求谨慎使用守恒律和理想气体关系来推导数值格式和精确解。数值通量和时间步进必须是稳定且能够捕捉激波的。计算流体动力学 (CFD) 是专门研究此类守恒律数值求解的学科，而Courant-Friedrichs-Lewy (CFL) 条件控制着显式时间步长的稳定性。",
            "solution": "所提出的问题是为可压缩欧拉方程开发并验证一个一维有限体积法求解器，以模拟声学激波管中的激波形成。这是计算流体动力学 (CFD) 中的一个标准问题，并且在数学和物理上是良定的。该问题陈述是有效的，因为它以流体力学原理为科学基础，数学上是适定的，并为其求解提供了一套完整且一致的数据和约束。\n\n我们将首先概述控制方程，然后是用于其离散化的数值方法，最后是与精确解进行比对的验证程序。\n\n### 1. 控制方程\n\n一维、无粘性、可压缩的欧拉方程表达了质量、动量和总能量的守恒。其守恒形式如下：\n$$ \\frac{\\partial \\mathbf{U}}{\\partial t} + \\frac{\\partial \\mathbf{F}(\\mathbf{U})}{\\partial x} = \\mathbf{0} $$\n其中 $\\mathbf{U}$ 是守恒状态变量的向量，$\\mathbf{F}(\\mathbf{U})$ 是相应通量的向量：\n$$\n\\mathbf{U} = \\begin{bmatrix} \\rho \\\\ \\rho u \\\\ E \\end{bmatrix}, \\quad\n\\mathbf{F}(\\mathbf{U}) = \\begin{bmatrix} \\rho u \\\\ \\rho u^2 + p \\\\ u(E + p) \\end{bmatrix}\n$$\n此处，$\\rho$ 是流体密度，$u$ 是速度，$E$ 是单位体积的总能量，$p$ 是压力。该方程组由一个状态方程封闭。对于完美气体，状态方程为：\n$$ p = (\\gamma - 1) \\left( E - \\frac{1}{2}\\rho u^2 \\right) $$\n其中 $\\gamma$ 是比热比，对于空气取 $\\gamma=1.4$。声速 $a$ 定义为 $a = \\sqrt{\\gamma p / \\rho}$。\n\n### 2. 数值方法：有限体积格式\n\n我们将长度为 $L$ 的空间域离散为 $N$ 个宽度为 $\\Delta x = L/N$ 的均匀单元。单元中心位于 $x_i = (i-1/2)\\Delta x$，其中 $i=1, \\dots, N$。令 $\\mathbf{U}_i(t)$ 为在时间 $t$ 时，单元 $i$ 中守恒变量的单元平均值。\n\n将守恒律在单元 $i$（从 $x_{i-1/2}$ 到 $x_{i+1/2}$）上积分，并应用散度定理，得到半离散有限体积公式：\n$$ \\frac{d\\mathbf{U}_i}{dt} = -\\frac{1}{\\Delta x} \\left( \\mathbf{F}^*_{i+1/2} - \\mathbf{F}^*_{i-1/2} \\right) $$\n其中 $\\mathbf{F}^*_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。\n\n对于时间积分，我们使用显式一阶欧拉方法：\n$$ \\mathbf{U}_i^{n+1} = \\mathbf{U}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( \\mathbf{F}^*_{i+1/2} - \\mathbf{F}^*_{i-1/2} \\right) $$\n其中上标 $n$ 表示时间层 $t^n$。\n\n### 3. 数值通量：局部Lax-Friedrichs (Rusanov)\n\n问题指定了一个与局部Lax-Friedrichs（或Rusanov）通量一致的单调格式。该通量在左状态 $\\mathbf{U}_L$ 和右状态 $\\mathbf{U}_R$ 之间的界面上定义为：\n$$ \\mathbf{F}^*(\\mathbf{U}_L, \\mathbf{U}_R) = \\frac{1}{2} \\left[ \\mathbf{F}(\\mathbf{U}_L) + \\mathbf{F}(\\mathbf{U}_R) - S_{\\max} (\\mathbf{U}_R - \\mathbf{U}_L) \\right] $$\n项 $S_{\\max}$ 表示界面处的局部最大信号速度（波速），并为保证稳定性提供必要的数值耗散。其计算方式如下：\n$$ S_{\\max} = \\max(|u_L| + a_L, |u_R| + a_R) $$\n对于通量 $\\mathbf{F}^*_{i+1/2}$，左、右状态分别是单元平均值 $\\mathbf{U}_i^n$ 和 $\\mathbf{U}_{i+1}^n$。\n\n### 4. 时间步长和边界条件\n\n这种显式格式的稳定性由Courant-Friedrichs-Lewy (CFL) 条件决定。时间步长 $\\Delta t$ 必须满足：\n$$ \\Delta t \\le \\text{CFL} \\frac{\\Delta x}{\\max_i(|u_i| + a_i)} $$\n其中最大值取自整个计算域。为了保证鲁棒性，我们将使用 $0.5$ 的CFL数。\n\n透射（零梯度）边界条件通过使用虚拟单元来实现。在域的每一端添加一个虚拟单元。左侧虚拟单元（$i=0$）的状态设置为与第一个内部单元（$i=1$）的状态相等，右侧虚拟单元（$i=N+1$）的状态设置为与最后一个内部单元（$i=N$）的状态相等。\n\n### 5. 验证：精确黎曼解\n\n初始条件指定了一个黎曼问题：两个恒定状态在 $x_0 = L/2$ 处被一个膜隔开。该问题的解是自相似的，仅依赖于变量 $\\xi = (x - x_0) / t$。解的结构由三个波（一个左行波、一个接触间断和一个右行波）组成，它们分隔了四个常数状态区。这些波可以是激波或稀疏扇。\n\n精确解的核心是求解左、右波之间区域（“星区”）的压力 $p_*$ 和速度 $u_*$。这通过求解非线性代数方程来实现：\n$$ f_L(p_*, \\mathbf{W}_L) + f_R(p_*, \\mathbf{W}_R) + (u_R - u_L) = 0 $$\n其中 $\\mathbf{W}_K = (\\rho_K, u_K, p_K)$，对于 $K \\in \\{L, R\\}$。函数 $f_K$ 取决于波是激波（$p_* > p_K$）还是稀疏波（$p_* \\le p_K$）：\n- 激波: $ f_K(p_*) = (p_* - p_K) \\sqrt{\\frac{2 / ((\\gamma+1)\\rho_K)}{p_* + (\\gamma-1)/(\\gamma+1) p_K}} $\n- 稀疏波: $ f_K(p_*) = \\frac{2a_K}{\\gamma-1} \\left[ \\left(\\frac{p_*}{p_K}\\right)^{\\frac{\\gamma-1}{2\\gamma}} - 1 \\right] $\n\n此方程使用数值求根算法（例如 Brent 方法）求解 $p_*$。一旦 $p_*$ 已知，就可以确定 $u_*$ 以及星区的密度 $\\rho_{*L}$ 和 $\\rho_{*R}$。然后波系结构（波速和区域）就完全确定了。为了在最终时间 $t_{\\mathrm{end}}$ 获得精确密度剖面 $\\rho_{\\mathrm{exact}}(x_i)$，我们通过计算 $\\xi_i = (x_i - L/2) / t_{\\mathrm{end}}$ 并确定 $\\xi_i$ 落入哪个区域，来对每个单元中心坐标 $x_i$ 处的解进行求值。\n\n然后，数值密度 $\\rho_{\\mathrm{num}, i}$ 与精确密度 $\\rho_{\\mathrm{exact}}(x_i)$ 之间的 $L^1$ 误差计算为离散和：\n$$ \\varepsilon_{L^1} = \\sum_{i=1}^{N} \\left| \\rho_{\\mathrm{num},i} - \\rho_{\\mathrm{exact},i} \\right| \\Delta x $$\n\n### 6. 测试套件的实现\n\n上述方法论在一个Python程序中实现。该程序将顺序执行所提供的三个测试案例。对于每个案例，它会初始化状态，运行时间步进循环直到 $t_{\\mathrm{end}}$，计算用于验证的精确黎曼解，计算密度的 $L^1$ 误差，并将结果附加到一个列表中。最后，它以指定格式打印误差列表。第三个测试案例具有均匀的初始状态，是一个关键的健全性检查；其精确解是平凡的（无变化），因此任何显著的误差都将指向数值格式或边界条件中的缺陷。对于一个性能良好的格式，这个误差应接近于机器精度。",
            "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"gamma\": 1.4, \"L\": 1.0, \"N\": 400, \"t_end\": 0.001,\n            \"left_state\": (1.0, 0.0, 1.0e5),\n            \"right_state\": (0.125, 0.0, 1.0e4)\n        },\n        {\n            \"gamma\": 1.4, \"L\": 1.0, \"N\": 400, \"t_end\": 0.001,\n            \"left_state\": (1.05, 0.0, 1.05e5),\n            \"right_state\": (1.0, 0.0, 1.0e5)\n        },\n        {\n            \"gamma\": 1.4, \"L\": 1.0, \"N\": 200, \"t_end\": 0.001,\n            \"left_state\": (1.0, 0.0, 1.0e5),\n            \"right_state\": (1.0, 0.0, 1.0e5)\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        error = run_simulation_case(**params)\n        results.append(error)\n\n    print(f\"[{','.join(f'{r:.6g}' for r in results)}]\")\n\ndef run_simulation_case(gamma, L, N, t_end, left_state, right_state):\n    \"\"\"\n    Runs a single shock tube simulation case and returns the L1 error.\n    \"\"\"\n    CFL = 0.5\n    dx = L / N\n    x_centers = np.linspace(dx / 2, L - dx / 2, N)\n    x0 = L / 2\n\n    # Helper functions for state conversion\n    def primitive_to_conserved(rho, u, p, g):\n        E = p / (g - 1) + 0.5 * rho * u**2\n        return np.array([rho, rho * u, E])\n\n    def conserved_to_primitive(U, g):\n        rho = U[0, :]\n        u = U[1, :] / rho\n        E = U[2, :]\n        p = (g - 1) * (E - 0.5 * rho * u**2)\n        return rho, u, p\n    \n    def get_flux(U, g):\n        rho, u, p = conserved_to_primitive(U.reshape(3, 1), g)\n        E = U[2]\n        F = np.zeros(3)\n        F[0] = rho * u\n        F[1] = rho * u**2 + p\n        F[2] = u * (E + p)\n        return F\n\n    # --- Initialization ---\n    rho_L, u_L, p_L = left_state\n    rho_R, u_R, p_R = right_state\n    \n    # N+2 cells to accommodate two ghost cells\n    U = np.zeros((3, N + 2))\n    initial_split = np.where(x_centers  x0, 1, 0)\n    \n    U[0, 1:N+1] = initial_split * rho_L + (1 - initial_split) * rho_R\n    U[1, 1:N+1] = initial_split * (rho_L * u_L) + (1 - initial_split) * (rho_R * u_R)\n    U[2, 1:N+1] = initial_split * (p_L / (gamma-1) + 0.5 * rho_L * u_L**2) + \\\n                  (1 - initial_split) * (p_R / (gamma-1) + 0.5 * rho_R * u_R**2)\n\n    # --- Time Marching Loop ---\n    t = 0.0\n    while t  t_end:\n        # Boundary conditions (zero-gradient)\n        U[:, 0] = U[:, 1]\n        U[:, N+1] = U[:, N]\n\n        # Decode primitive variables\n        rho, u, p = conserved_to_primitive(U, gamma)\n        # Ensure positivity of pressure and density\n        rho = np.maximum(rho, 1e-9)\n        p = np.maximum(p, 1e-9)\n        a = np.sqrt(gamma * p / rho)\n\n        # CFL condition for time step\n        max_signal_speed = np.max(np.abs(u) + a)\n        dt = CFL * dx / max_signal_speed\n        if t + dt > t_end:\n            dt = t_end - t\n\n        # Compute numerical fluxes (Rusanov)\n        F_num = np.zeros((3, N + 1))\n        for i in range(N + 1):\n            U_l, U_r = U[:, i], U[:, i+1]\n            rho_l, u_l, p_l = conserved_to_primitive(U_l.reshape(3, 1), gamma)\n            rho_r, u_r, p_r = conserved_to_primitive(U_r.reshape(3, 1), gamma)\n\n            a_l = np.sqrt(gamma * p_l / rho_l)\n            a_r = np.sqrt(gamma * p_r / rho_r)\n            \n            s_max_local = np.max([np.abs(u_l) + a_l, np.abs(u_r) + a_r])\n            \n            F_l = get_flux(U_l, gamma)\n            F_r = get_flux(U_r, gamma)\n            \n            F_num[:, i] = 0.5 * (F_l + F_r - s_max_local * (U_r - U_l))\n            \n        # Update state vectors\n        U[:, 1:N+1] -= (dt/dx) * (F_num[:, 1:] - F_num[:, :-1])\n        t += dt\n\n    # --- Verification ---\n    rho_num = U[0, 1:N+1]\n    rho_exact = exact_riemann_solver(left_state, right_state, gamma, x_centers - x0, t_end)\n    l1_error = np.sum(np.abs(rho_num - rho_exact)) * dx\n    \n    return l1_error\n\ndef exact_riemann_solver(left_state, right_state, gamma, x, t):\n    \"\"\"\n    Computes the exact solution to the Riemann problem.\n    \"\"\"\n    rho_L, u_L, p_L = left_state\n    rho_R, u_R, p_R = right_state\n    a_L = np.sqrt(gamma * p_L / rho_L)\n    a_R = np.sqrt(gamma * p_R / rho_R)\n\n    def pressure_func(p_star, p_K, rho_K, a_K):\n        if p_star > p_K:  # Shock\n            A = 2 / ((gamma + 1) * rho_K)\n            B = (gamma - 1) / (gamma + 1) * p_K\n            return (p_star - p_K) * np.sqrt(A / (p_star + B))\n        else:  # Rarefaction\n            return (2 * a_K / (gamma - 1)) * ((p_star / p_K)**((gamma - 1) / (2 * gamma)) - 1)\n\n    def total_pressure_func(p_star):\n        return pressure_func(p_star, p_L, rho_L, a_L) + pressure_func(p_star, p_R, rho_R, a_R) + (u_R - u_L)\n\n    # Check for trivial case\n    if np.allclose(left_state, right_state):\n        return np.full_like(x, rho_L)\n\n    try:\n        p_star = brentq(total_pressure_func, 1e-6, 1e7)\n    except ValueError: # Handle no zero in interval, often for vacuum states not in test suite\n        p_star = 1e-6 \n    \n    u_star = 0.5 * (u_L + u_R) + 0.5 * (pressure_func(p_star, p_R, rho_R, a_R) - pressure_func(p_star, p_L, rho_L, a_L))\n    \n    # Solution sampling at xi = x/t\n    xi = x / t if t > 0 else np.zeros_like(x)\n    rho_sol = np.zeros_like(xi)\n\n    # Left wave\n    if p_star > p_L: # Left Shock\n        rho_star_L = rho_L * ((p_star/p_L + (gamma-1)/(gamma+1)) / ((gamma-1)/(gamma+1) * p_star/p_L + 1))\n        S_L = u_L - a_L * np.sqrt((gamma+1)/(2*gamma) * (p_star/p_L) + (gamma-1)/(2*gamma))\n        rho_sol[xi  S_L] = rho_L\n        rho_sol[(xi >= S_L)  (xi  u_star)] = rho_star_L\n    else: # Left Rarefaction\n        rho_star_L = rho_L * (p_star/p_L)**(1/gamma)\n        a_star_L = np.sqrt(gamma*p_star/rho_star_L)\n        S_HL = u_L - a_L\n        S_TL = u_star - a_star_L\n        rho_sol[xi  S_HL] = rho_L\n        rarefaction_region_L = (xi >= S_HL)  (xi  S_TL)\n        rho_sol[rarefaction_region_L] = rho_L * (2/(gamma+1) + (gamma-1)/((gamma+1)*a_L)*(u_L-xi[rarefaction_region_L]))**(2/(gamma-1))\n        rho_sol[(xi >= S_TL)  (xi  u_star)] = rho_star_L\n\n    # Right wave\n    if p_star > p_R: # Right Shock\n        rho_star_R = rho_R * ((p_star/p_R + (gamma-1)/(gamma+1)) / ((gamma-1)/(gamma+1) * p_star/p_R + 1))\n        S_R = u_R + a_R * np.sqrt((gamma+1)/(2*gamma) * (p_star/p_R) + (gamma-1)/(2*gamma))\n        rho_sol[xi > S_R] = rho_R\n        rho_sol[(xi >= u_star)  (xi = S_R)] = rho_star_R\n    else: # Right Rarefaction\n        rho_star_R = rho_R * (p_star/p_R)**(1/gamma)\n        a_star_R = np.sqrt(gamma*p_star/rho_star_R)\n        S_HR = u_R + a_R\n        S_TR = u_star + a_star_R\n        rho_sol[xi > S_HR] = rho_R\n        rarefaction_region_R = (xi > S_TR)  (xi = S_HR)\n        rho_sol[rarefaction_region_R] = rho_R * (2/(gamma+1) - (gamma-1)/((gamma+1)*a_R)*(u_R-xi[rarefaction_region_R]))**(2/(gamma-1))\n        rho_sol[(xi >= u_star)  (xi = S_TR)] = rho_star_R\n        \n    return rho_sol\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}