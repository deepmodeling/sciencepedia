{
    "hands_on_practices": [
        {
            "introduction": "A cornerstone of computational acoustics is the ability to predict the sound field in the far-field from measurements taken in the near-field. This practice lays the theoretical and numerical groundwork for this process using a modal approach based on spherical wave functions. By synthesizing a known acoustic field and then applying a numerical projection onto spherical harmonics, you will extract the coefficients that uniquely define the far-field radiation pattern, validating the entire chain from theory to computation . This exercise is fundamental to understanding techniques like Near-field Acoustic Holography (NAH).",
            "id": "4131134",
            "problem": "You are asked to design and implement a numerical experiment to validate far-field extraction in computational acoustics by measuring the acoustic pressure $p$ on a closed spherical surface and comparing the numerically extracted far-field with the analytical asymptotic behavior $p(\\mathbf{x}) \\sim \\dfrac{e^{i k r}}{r} f(\\hat{\\mathbf{x}})$ in the limit $r \\to \\infty$, where $\\hat{\\mathbf{x}}$ is the unit observation direction.\n\nStart from a fundamental base: the exterior acoustic field $p$ satisfies the homogeneous Helmholtz equation $\\nabla^2 p + k^2 p = 0$ in the region outside a compact source and obeys the Sommerfeld radiation condition. On any sphere of radius $r$ centered at the origin that encloses the source region, the solution admits a spherical harmonic expansion. The angular dependence can be represented by spherical harmonics, and the radial dependence by spherical Bessel functions and spherical Hankel functions. Use these facts and the orthogonality of spherical harmonics to derive an algorithm for extracting the far-field amplitude $f(\\hat{\\mathbf{x}})$ from near-field measurements $p$ on a spherical measurement surface.\n\nIn this numerical experiment, the “measured” near-field data is synthesized from a single outgoing spherical harmonic mode so that the exact far-field is known. For a chosen nonnegative integer degree $l$ and integer order $m$ with $-l \\le m \\le l$, define the exterior field to be\n$$\np(r,\\theta,\\phi) = A\\, h_l^{(1)}(k r)\\, Y_l^m(\\theta,\\phi),\n$$\nwhere $A$ is a complex amplitude, $h_l^{(1)}$ is the spherical Hankel function of the first kind, $Y_l^m$ is the orthonormal spherical harmonic with Condon-Shortley phase, $r$ is the radius, $\\theta$ is the polar angle, and $\\phi$ is the azimuthal angle. Angles must be handled in radians.\n\nYour tasks:\n- Derive, from the fundamental base described, a mathematically sound procedure that:\n  1. Uses surface samples of $p$ on a sphere of radius $r_0$ to compute the modal coefficient associated with the $(l,m)$ spherical harmonic via projection using the orthogonality relation on the unit sphere, implemented numerically using quadrature.\n  2. Uses the large-$r$ asymptotic behavior of $h_l^{(1)}(k r)$ to obtain $f(\\hat{\\mathbf{x}})$ for general directions $\\hat{\\mathbf{x}}$ on the unit sphere.\n- Implement the procedure with a numerically stable spherical quadrature that respects the weighting factor $\\sin\\theta$ in the surface element $d\\Omega = \\sin\\theta\\, d\\theta\\, d\\phi$. Use Gauss-Legendre quadrature in $\\mu = \\cos\\theta$ and a uniform trapezoidal rule in $\\phi$.\n- Validate the far-field extraction by computing the relative error between the numerically extracted far-field amplitude and the analytical far-field amplitude over a set of observation directions on the unit sphere. Use the following error metric:\n$$\n\\varepsilon = \\frac{\\left\\| f_{\\mathrm{num}}(\\hat{\\mathbf{x}}_j) - f_{\\mathrm{ana}}(\\hat{\\mathbf{x}}_j) \\right\\|_{2}}{\\left\\| f_{\\mathrm{ana}}(\\hat{\\mathbf{x}}_j) \\right\\|_{2}},\n$$\nwhere the discrete $\\ell^2$ norm aggregates over all observation directions $\\hat{\\mathbf{x}}_j$, and $f_{\\mathrm{num}}$ and $f_{\\mathrm{ana}}$ are the numerically extracted and analytical far-field amplitudes respectively.\n- Angles must be in radians throughout. No physical unit conversion is required since $A$ is dimensionless and the error $\\varepsilon$ is dimensionless.\n\nTest suite:\nCompute the error $\\varepsilon$ for the following parameter sets, each expressed as a tuple $(k, r_0, l, m, A)$, where $k$ is the wavenumber in $\\mathrm{rad}/\\mathrm{m}$, $r_0$ is the measurement sphere radius in $\\mathrm{m}$, $l$ and $m$ specify the spherical harmonic mode, and $A$ is the complex amplitude:\n- Case $1$: $(k, r_0, l, m, A) = (10.0, 0.75, 0, 0, 1.0)$.\n- Case $2$: $(k, r_0, l, m, A) = (20.0, 1.10, 1, 0, 0.7)$.\n- Case $3$: $(k, r_0, l, m, A) = (35.0, 1.30, 5, 3, 1.2)$.\n\nObservation directions:\nUse a set of directions $(\\theta_j,\\phi_j)$ defined by $\\theta_j \\in \\{\\pi/8, 3\\pi/8, 5\\pi/8\\}$ and $\\phi_j \\in \\{ 2\\pi n / 10 \\mid n = 0,1,\\dots,9 \\}$, forming $30$ directions. Angles must be in radians.\n\nImplementation details to respect:\n- Spherical harmonics must be orthonormal in the sense $\\int_{0}^{2\\pi}\\int_{0}^{\\pi} Y_l^m(\\theta,\\phi)\\, Y_{l'}^{m'}(\\theta,\\phi)^{*}\\, \\sin\\theta\\, d\\theta\\, d\\phi = \\delta_{l l'} \\delta_{m m'}$.\n- Use sufficiently fine quadrature to numerically approximate the surface inner product. A recommended configuration is $N_\\theta = 64$ Gauss-Legendre nodes in $\\mu = \\cos\\theta$ and $N_\\phi = 128$ uniformly spaced nodes in $\\phi$.\n- Express all angles in radians.\n- The final program must not read any input. It must compute the errors for the three test cases and produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For example: $[e_1,e_2,e_3]$, where each $e_i$ is a float.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[e_1,e_2,e_3]$).",
            "solution": "The problem requires the design and implementation of a numerical experiment to validate a far-field extraction procedure in computational acoustics. The process involves synthesizing a near-field pressure distribution, using it to compute modal coefficients via numerical integration, reconstructing the far-field amplitude, and comparing it to the known analytical solution to compute the error.\n\n### Mathematical Derivation of the Far-Field Extraction Procedure\n\nAn acoustic pressure field $p(\\mathbf{x})$ in the exterior of a compact source region, satisfying the Helmholtz equation $\\nabla^2 p + k^2 p = 0$ and the Sommerfeld radiation condition, can be represented as a series of outgoing spherical waves. In spherical coordinates $(r, \\theta, \\phi)$, this expansion is:\n$$\np(r, \\theta, \\phi) = \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} h_l^{(1)}(k r) Y_l^m(\\theta, \\phi)\n$$\nwhere $a_{lm}$ are the complex modal coefficients, $h_l^{(1)}$ is the spherical Hankel function of the first kind (representing outgoing waves), and $Y_l^m$ are the orthonormal spherical harmonics.\n\nThe far-field behavior is defined by the asymptotic relation $p(\\mathbf{x}) \\sim \\frac{e^{ikr}}{r} f(\\hat{\\mathbf{x}})$ as $r \\to \\infty$. To find the far-field amplitude $f(\\hat{\\mathbf{x}})$, we use the large-argument asymptotic form of the spherical Hankel function:\n$$\nh_l^{(1)}(z) \\sim \\frac{1}{z} e^{i(z - (l+1)\\pi/2)} = \\frac{(-i)^{l+1}}{z} e^{iz} \\quad \\text{for } z \\to \\infty\n$$\nSubstituting $z=kr$ into the pressure expansion:\n$$\np(r, \\theta, \\phi) \\sim \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} \\left( \\frac{(-i)^{l+1}}{kr} e^{ikr} \\right) Y_l^m(\\theta, \\phi) = \\frac{e^{ikr}}{r} \\left( \\frac{1}{k} \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} (-i)^{l+1} Y_l^m(\\theta, \\phi) \\right)\n$$\nBy comparing this with the definition of $f(\\hat{\\mathbf{x}})$, we identify the far-field amplitude as:\n$$\nf(\\hat{\\mathbf{x}}) = f(\\theta, \\phi) = \\frac{1}{k} \\sum_{l=0}^{\\infty} \\sum_{m=-l}^{l} a_{lm} (-i)^{l+1} Y_l^m(\\theta, \\phi)\n$$\nThe core task is to determine the coefficients $a_{lm}$ from near-field data. Given the pressure $p(r_0, \\theta, \\phi)$ on a measurement sphere of radius $r_0$, we can exploit the orthonormality of the spherical harmonics, $\\int_{S^2} Y_l^m(\\theta, \\phi) (Y_{l'}^{m'}(\\theta, \\phi))^* d\\Omega = \\delta_{ll'} \\delta_{mm'}$, where $d\\Omega = \\sin\\theta d\\theta d\\phi$.\n\nMultiplying the pressure expansion at $r=r_0$ by $(Y_l^m)^*$ and integrating over the unit sphere yields:\n$$\n\\int_{S^2} p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega = \\sum_{l'=0}^{\\infty} \\sum_{m'=-l'}^{l'} a_{l'm'} h_{l'}^{(1)}(kr_0) \\int_{S^2} Y_{l'}^{m'}(\\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega\n$$\nDue to orthogonality, all terms in the sum vanish except for $(l', m')=(l, m)$, leading to:\n$$\n\\int_{S^2} p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* d\\Omega = a_{lm} h_l^{(1)}(kr_0)\n$$\nThus, the modal coefficient $a_{lm}$ can be extracted using the formula:\n$$\na_{lm} = \\frac{1}{h_l^{(1)}(kr_0)} \\int_0^{2\\pi} \\int_0^\\pi p(r_0, \\theta, \\phi) (Y_l^m(\\theta, \\phi))^* \\sin\\theta d\\theta d\\phi\n$$\n\n### Numerical Implementation\n\nThe problem provides a synthesized field consisting of a single mode $(l,m)$:\n$$\np(r, \\theta, \\phi) = A h_l^{(1)}(kr) Y_l^m(\\theta, \\phi)\n$$\nFor this field, the analytical coefficient is simply $a_{lm} = A$, and all other coefficients are zero. The analytical far-field amplitude is therefore:\n$$\nf_{\\mathrm{ana}}(\\theta, \\phi) = \\frac{A}{k} (-i)^{l+1} Y_l^m(\\theta, \\phi)\n$$\n\nThe numerical procedure is as follows:\n1.  **Synthesize Data**: Evaluate $p(r_0, \\theta, \\phi)$ on a spherical quadrature grid.\n2.  **Numerical Integration**: Approximate the integral for $a_{lm}$ using numerical quadrature. The integral over the sphere is handled by a change of variables to $\\mu = \\cos\\theta$, so that $\\sin\\theta d\\theta d\\phi$ becomes $d\\mu d\\phi$. We use Gauss-Legendre quadrature for the $\\mu$ integral (from $-1$ to $1$) and the trapezoidal rule for the $\\phi$ integral (from $0$ to $2\\pi$). For $N_\\theta$ points in $\\theta$ and $N_\\phi$ points in $\\phi$, the integral of a function $G(\\theta, \\phi)$ is approximated as:\n    $$\n    \\int_{S^2} G(\\theta, \\phi) d\\Omega \\approx \\sum_{i=1}^{N_\\theta} w_i \\left( \\frac{2\\pi}{N_\\phi} \\sum_{j=0}^{N_\\phi-1} G(\\theta_i, \\phi_j) \\right)\n    $$\n    where $(\\mu_i, w_i)$ are the Gauss-Legendre nodes and weights, $\\theta_i = \\arccos(\\mu_i)$, and $\\phi_j = 2\\pi j / N_\\phi$.\n3.  **Compute Coefficient**: Calculate the numerical coefficient $a_{lm, \\text{num}}$ using the formula for $a_{lm}$ with the numerically computed integral.\n4.  **Construct Numerical Far-Field**: The numerically extracted far-field is $f_{\\mathrm{num}}(\\theta, \\phi) = \\frac{a_{lm, \\text{num}}}{k} (-i)^{l+1} Y_l^m(\\theta, \\phi)$.\n5.  **Compute Error**: The relative error $\\varepsilon$ is calculated. Due to the single-mode nature of the problem, the error metric simplifies:\n    $$\n    \\varepsilon = \\frac{\\left\\| f_{\\mathrm{num}} - f_{\\mathrm{ana}} \\right\\|_{2}}{\\left\\| f_{\\mathrm{ana}} \\right\\|_{2}} = \\frac{\\left\\| \\frac{(a_{lm, \\text{num}} - A)}{k}(-i)^{l+1} Y_l^m \\right\\|_{2}}{\\left\\| \\frac{A}{k}(-i)^{l+1} Y_l^m \\right\\|_{2}}\n    $$\n    The terms involving $Y_l^m$, $k$, and $(-i)^{l+1}$ cancel out from the norm, simplifying the error to the relative error in the extracted coefficient:\n    $$\n    \\varepsilon = \\frac{|a_{lm, \\text{num}} - A|}{|A|}\n    $$\n    This simplification shows that the set of observation directions is not needed for the error calculation in this specific problem, as the error is independent of the observation direction and determined solely by the accuracy of the numerical quadrature used to extract the coefficient. The core of the validation lies in a single numerical integration.\n\nThe implementation will follow this derived procedure directly: synthesize the field on the quadrature grid, project it back onto the known mode to get $a_{lm, \\text{num}}$, and then compute the relative error against the known coefficient $A$.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import sph_harm, spherical_jn, spherical_yn\nfrom numpy.polynomial.legendre import leggauss\n\ndef solve():\n    \"\"\"\n    Solves the computational acoustics problem for the given test cases.\n    \"\"\"\n    \n    def h_l_1(l_val, x):\n        \"\"\"\n        Computes the spherical Hankel function of the first kind h_l^(1)(x).\n        Args:\n            l_val: int, the order of the function.\n            x: float or array-like, the argument(s).\n        Returns:\n            Complex value(s) of the Hankel function.\n        \"\"\"\n        # scipy functions for spherical Bessel functions j_n(x) and y_n(x)\n        return spherical_jn(l_val, x) + 1j * spherical_yn(l_val, x)\n\n    def calculate_error(k, r0, l_mode, m_mode, A_amp):\n        \"\"\"\n        Calculates the relative error for a single test case.\n        Args:\n            k: Wavenumber.\n            r0: Measurement sphere radius.\n            l_mode: Degree of the spherical harmonic.\n            m_mode: Order of the spherical harmonic.\n            A_amp: Complex amplitude of the mode.\n        Returns:\n            The relative error epsilon.\n        \"\"\"\n        N_theta = 64\n        N_phi = 128\n\n        # 1. Setup quadrature grid\n        # Gauss-Legendre quadrature for theta integration (via mu=cos(theta))\n        mu_nodes, weights = leggauss(N_theta)  # mu is in [-1, 1]\n        theta_nodes = np.arccos(mu_nodes)     # theta is in [pi, 0]\n\n        # Uniform trapezoidal rule for phi integration\n        phi_nodes = np.linspace(0, 2 * np.pi, N_phi, endpoint=False)\n        \n        # Create a meshgrid for vectorized calculations.\n        # 'ij' indexing ensures theta corresponds to the first axis.\n        theta_grid, phi_grid = np.meshgrid(theta_nodes, phi_nodes, indexing='ij')\n        \n        # 2. Synthesize \"measured\" field p(r0, theta, phi) on the quadrature grid.\n        # Note: scipy.special.sph_harm expects arguments (m, l, phi, theta).\n        ylm_values = sph_harm(m_mode, l_mode, phi_grid, theta_grid)\n        \n        # Calculate the Hankel function value (it's a scalar constant for the grid)\n        h_val = h_l_1(l_mode, k * r0)\n        \n        p_values = A_amp * h_val * ylm_values\n\n        # 3. Compute the modal coefficient via numerical projection.\n        # The integrand for the projection is p * conj(Y_l^m).\n        integrand = p_values * np.conj(ylm_values)\n        \n        # Perform quadrature: Sum_i(w_i * Sum_j(integrand_ij * d_phi) )\n        # where d_phi = 2*pi/N_phi.\n        # NumPy broadcasting is used for efficiency: weights is (N_theta,), integrand is (N_theta, N_phi).\n        # weights[:, np.newaxis] has shape (N_theta, 1), which broadcasts over the phi dimension.\n        integral_val = (2 * np.pi / N_phi) * np.sum(weights[:, np.newaxis] * integrand)\n        \n        # 4. Extract the numerical coefficient from the integral.\n        a_lm_num = integral_val / h_val\n\n        # 5. Calculate the relative error.\n        # As derived, this simplifies to the relative error of the coefficient.\n        error = np.abs(a_lm_num - A_amp) / np.abs(A_amp)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (k, r0, l, m, A)\n        (10.0, 0.75, 0, 0, 1.0),\n        (20.0, 1.10, 1, 0, 0.7),\n        (35.0, 1.30, 5, 3, 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        k_val, r0_val, l_val, m_val, A_val = case\n        err = calculate_error(k_val, r0_val, l_val, m_val, A_val)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    # Using high precision floating point format for clear results.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "In practice, near-field data is always collected over a finite spatial aperture, which introduces a significant challenge: spectral leakage. This phenomenon, which arises from the abrupt truncation of the data at the measurement boundaries, can distort the calculated far-field pattern by smearing energy from the main radiation lobe into the side lobes. This hands-on exercise explores the use of windowing functions—a critical signal processing technique—to mitigate these artifacts, allowing you to quantitatively analyze the inherent trade-off between reducing side-lobe levels and preserving the main-lobe resolution .",
            "id": "4123377",
            "problem": "Consider a time-harmonic acoustic field in a homogeneous, lossless medium of sound speed $c$ and density $\\rho$, with time dependence $e^{j\\omega t}$ suppressed. The acoustic pressure $p(x,y,z)$ satisfies the Helmholtz equation derived from the linearized wave equation. On the measurement plane $z=0$, let the near-field pressure be sampled over a finite rectangular measurement aperture of size $L_x \\times L_y$ and discretized on a uniform grid with $N_x \\times N_y$ points and spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The acoustic wavenumber is $k = \\omega/c = 2\\pi f/c$, where $f$ is the frequency. Define the two-dimensional spatial Fourier transform of $p(x,y,0)$ as $P(k_x,k_y)$, where $k_x$ and $k_y$ are spatial angular frequencies (in $\\mathrm{rad/m}$). Assume a monochromatic field with $f$ given.\n\nStarting from fundamental laws and definitions (the linearized acoustic wave equation, the Helmholtz equation, and the angular spectrum representation), derive and implement a computational procedure that:\n- Computes $P(k_x,k_y)$ from discretized near-field data $p(x,y,0)$ measured over $L_x \\times L_y$.\n- Shows how multiplying $p(x,y,0)$ by a smooth taper (window) $w(x,y)$ reduces spectral leakage in $P(k_x,k_y)$ and alters the far-field pattern along the $k_x$ axis (with $k_y=0$).\n- Quantifies the trade-off between main-lobe broadening and side-lobe suppression in the far-field.\n\nAssume a synthetic near-field consisting of a uniform rectangular piston of size $A_x \\times A_y$ centered on the origin: $p(x,y,0)=1$ for $|x|\\le A_x/2$ and $|y|\\le A_y/2$, and $p(x,y,0)=0$ otherwise. Apply separable, unit-amplitude windows $w(x,y)=w_x(x)w_y(y)$ formed from one-dimensional tapers along $x$ and $y$.\n\nDefine the following quantitative metrics:\n1. Spectral leakage fraction $L$ in the angular spectrum as\n$$\nL = \\frac{\\displaystyle \\iint_{\\mathcal{D}_\\text{prop}\\setminus\\mathcal{R}_\\text{ML}} |P(k_x,k_y)|^2 \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y}{\\displaystyle \\iint_{\\mathcal{D}_\\text{prop}} |P(k_x,k_y)|^2 \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y},\n$$\nwhere $\\mathcal{D}_\\text{prop}=\\{(k_x,k_y): |k_x|\\le k, |k_y|\\le k\\}$ is the set of propagating components and $\\mathcal{R}_\\text{ML}=\\{(k_x,k_y): |k_x|\\le k_{x,\\text{ROI}}, |k_y|\\le k_{y,\\text{ROI}}\\}$ is the rectangular region representing the main-lobe region with bounds $k_{x,\\text{ROI}}=2\\pi/A_x$ and $k_{y,\\text{ROI}}=2\\pi/A_y$. Express $L$ as a decimal.\n2. Far-field main-lobe full width at half maximum (FWHM) along the $k_x$ axis at $k_y=0$, defined by the width between the two points where the magnitude of the one-dimensional slice $|P(k_x,0)|$ equals $\\sqrt{0.5}$ times its peak value. Express this width in $\\mathrm{rad/m}$.\n3. Peak side-lobe level ratio $S$ along the $k_x$ axis at $k_y=0$, defined as the maximum of $|P(k_x,0)|$ for $|k_x|>k_{x,\\text{ROI}}$ within the propagating region $|k_x|\\le k$, normalized by the main-lobe peak. Express $S$ as a decimal.\n\nYour task is to implement a complete program that:\n- Constructs the near-field $p(x,y,0)$ on the specified grid and applies each window $w(x,y)$.\n- Computes $P(k_x,k_y)$ via a discrete two-dimensional Fourier transform using the sampling spacings $\\Delta x$ and $\\Delta y$.\n- Evaluates $L$, the FWHM, and $S$ as defined above for each window case.\n\nUse the following physical and numerical parameters (all numbers are given in standard SI units):\n- Sound speed $c = 343\\,\\mathrm{m/s}$, frequency $f = 40000\\,\\mathrm{Hz}$ so that $k = 2\\pi f / c$.\n- Measurement aperture sizes $L_x = 0.3\\,\\mathrm{m}$ and $L_y = 0.3\\,\\mathrm{m}$.\n- Grid sizes $N_x = 512$ and $N_y = 512$.\n- Rectangular piston sizes $A_x = 0.1\\,\\mathrm{m}$ and $A_y = 0.08\\,\\mathrm{m}$.\n\nWindows to be evaluated:\n- Case $1$: Rectangular window (no taper).\n- Case $2$: Hann window.\n- Case $3$: Tukey window with parameter $\\alpha = 0.25$ (dimensionless).\n- Case $4$: Blackman window.\n\nAngle units are not used; spatial spectral quantities must be expressed in $\\mathrm{rad/m}$. Ratios must be expressed as decimals.\n\nTest Suite:\nEvaluate the metrics for the four cases listed above. The final output for the program must be a single line containing a list of lists, each sublist corresponding to one case and containing the three results in the order $[L,\\text{FWHM},S]$. The format must be exactly\n$$\n\\text{[}[L_1,\\text{FWHM}_1,S_1],[L_2,\\text{FWHM}_2,S_2],[L_3,\\text{FWHM}_3,S_3],[L_4,\\text{FWHM}_4,S_4]\\text{]}\n$$\nwith numeric values in plain decimal representation and FWHM in $\\mathrm{rad/m}$.",
            "solution": "The problem requires the analysis of far-field acoustic properties derived from a windowed, finite-aperture measurement of a near-field pressure distribution. This analysis rests on the principles of linear acoustics, Fourier optics, and digital signal processing.\n\nThe propagation of time-harmonic acoustic waves in a homogeneous, lossless medium is governed by the Helmholtz equation, which is the frequency-domain representation of the linearized acoustic wave equation:\n$$ \\nabla^2 p(\\mathbf{r}) + k^2 p(\\mathbf{r}) = 0 $$\nwhere $p(\\mathbf{r})$ is the complex acoustic pressure at position $\\mathbf{r}=(x,y,z)$, $k = \\omega/c = 2\\pi f/c$ is the acoustic wavenumber, $\\omega$ is the angular frequency, $c$ is the speed of sound, and the time dependency $e^{j\\omega t}$ is suppressed.\n\nA powerful method for solving this equation is the angular spectrum representation. This method expresses the pressure field at any plane $z$ as a superposition of plane waves with varying propagation directions. The field $p(x,y,z)$ can be written as the inverse Fourier transform of its angular spectrum $P(k_x, k_y)$:\n$$ p(x,y,z) = \\frac{1}{(2\\pi)^2} \\iint_{-\\infty}^{\\infty} P(k_x,k_y) e^{j(k_x x + k_y y + k_z z)} \\,\\mathrm{d}k_x\\,\\mathrm{d}k_y $$\nHere, $P(k_x,k_y)$ is the two-dimensional spatial Fourier transform of the pressure distribution on the plane $z=0$:\n$$ P(k_x,k_y) = \\iint_{-\\infty}^{\\infty} p(x,y,0) e^{-j(k_x x + k_y y)} \\,\\mathrm{d}x\\,\\mathrm{d}y $$\nThe component $k_z$ is determined by the dispersion relation $k_x^2 + k_y^2 + k_z^2 = k^2$, which gives $k_z = \\sqrt{k^2 - k_x^2 - k_y^2}$. For real values of $k_z$ (i.e., when $k_x^2 + k_y^2 \\le k^2$), the plane waves propagate away from the source plane. For imaginary $k_z$, the waves are evanescent and decay exponentially with $z$. The angular spectrum $P(k_x, k_y)$ for the propagating components is directly proportional to the far-field radiation pattern.\n\nIn practice, the near-field pressure $p(x,y,0)$ is sampled over a finite aperture of size $L_x \\times L_y$ on a discrete grid of $N_x \\times N_y$ points with spacings $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The continuous Fourier transform is therefore approximated by a discrete Fourier transform (DFT), typically computed using the Fast Fourier Transform (FFT) algorithm. The relationship between the continuous angular spectrum and the 2D DFT result is:\n$$ P(k_x, k_y) \\approx \\Delta x \\Delta y \\cdot \\text{DFT}\\{p(n\\Delta x, m\\Delta y, 0)\\} $$\nwhere the discrete spatial frequencies $(k_x, k_y)$ correspond to the indices of the DFT matrix.\n\nThe truncation of the field to a finite aperture is equivalent to multiplying the true near-field by a rectangular window function. In the frequency domain, this corresponds to convolving the true angular spectrum with a 2D sinc function, which introduces spectral leakage—energy from the main lobe \"leaks\" into the side lobes, obscuring weaker features and distorting the spectrum. To mitigate this effect, the measured data can be multiplied by a smooth window function $w(x,y)$ that tapers towards zero at the boundaries of the aperture. This process, known as apodization or windowing, reduces the amplitude of the side lobes in the resulting spectrum at the cost of broadening the main lobe. This trade-off between side-lobe suppression and main-lobe width (resolution) is a fundamental aspect of spectral analysis.\n\nThe computational procedure is as follows:\n1.  **Grid and Parameter Definition**: We define the physical and numerical parameters provided. The spatial coordinates $(x,y)$ are discretized over the aperture $L_x \\times L_y$. The corresponding spatial frequency coordinates $(k_x, k_y)$ are determined by the sampling properties via $k_x[u] = \\frac{2\\pi u}{N_x \\Delta x}$ and $k_y[v] = \\frac{2\\pi v}{N_y \\Delta y}$, where $u$ and $v$ are frequency indices.\n2.  **Near-Field and Window Synthesis**: The synthetic near-field for the uniform piston source is constructed on the grid. For each case, a separable 2D window $w(x,y) = w_x(x)w_y(y)$ is generated and multiplied element-wise with the near-field data to produce the windowed field $p_w(x,y,0)$.\n3.  **Angular Spectrum Calculation**: The 2D FFT of $p_w(x,y,0)$ is computed and appropriately scaled by $\\Delta x \\Delta y$ to approximate $P(k_x, k_y)$.\n4.  **Metric Evaluation**: For each resulting angular spectrum, the three specified metrics are calculated.\n    *   **Spectral Leakage Fraction ($L$):** This metric quantifies the portion of propagated power that lies outside a defined main-lobe region. The integrals are approximated by summing the squared magnitude of $P(k_x, k_y)$ over the discrete grid points within the specified regions $\\mathcal{D}_\\text{prop}$ and $\\mathcal{R}_\\text{ML}$. The problem defines $\\mathcal{D}_\\text{prop}$ as a square region, which is a simplification of the physical circular region $k_x^2 + k_y^2 \\le k^2$, but this definition is adhered to for the calculation.\n    *   **Far-Field FWHM**: The full width at half maximum of the main lobe along the $k_x$-axis (at $k_y=0$) is determined. This requires finding the peak of the 1D spectral slice $|P(k_x, 0)|$ and then finding the width of the lobe at a magnitude of $\\text{peak}/\\sqrt{2}$. Since the target value may not fall on a discrete frequency bin, linear interpolation is used to accurately locate the half-power points.\n    *   **Peak Side-lobe Ratio ($S$):** Using the same 1D spectral slice, the maximum magnitude within the side-lobe region (defined as $|k_x| > k_{x,\\text{ROI}}$ and within the propagating domain $|k_x| \\le k$) is found and normalized by the main-lobe peak magnitude.\n\nThis procedure allows a quantitative comparison of the effects of different window functions on the far-field radiation characteristics, illustrating the fundamental trade-off between spectral resolution and dynamic range in Fourier analysis of finite-aperture data.",
            "answer": "```python\nimport numpy as np\nfrom scipy.signal.windows import tukey\n\ndef solve():\n    \"\"\"\n    Computes and analyzes the angular spectrum of a windowed acoustic near-field.\n    \"\"\"\n    # Physical and Numerical Parameters\n    c = 343.0  # Speed of sound in m/s\n    f = 40000.0  # Frequency in Hz\n    Lx = 0.3  # Aperture size in x in m\n    Ly = 0.3  # Aperture size in y in m\n    Nx = 512  # Number of grid points in x\n    Ny = 512  # Number of grid points in y\n    Ax = 0.1  # Piston size in x in m\n    Ay = 0.08  # Piston size in y in m\n\n    # Derived Parameters\n    k = 2 * np.pi * f / c  # Wavenumber in rad/m\n    dx = Lx / Nx  # Grid spacing in x in m\n    dy = Ly / Ny  # Grid spacing in y in m\n    kx_roi = 2 * np.pi / Ax  # Main-lobe region boundary in kx\n    ky_roi = 2 * np.pi / Ay  # Main-lobe region boundary in ky\n\n    # Create spatial grids\n    x = np.linspace(-Lx / 2, Lx / 2 - dx, Nx)\n    y = np.linspace(-Ly / 2, Ly / 2 - dy, Ny)\n    xx, yy = np.meshgrid(x, y)\n\n    # Create spatial frequency grids\n    kx_vals = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Nx, d=dx))\n    ky_vals = 2 * np.pi * np.fft.fftshift(np.fft.fftfreq(Ny, d=dy))\n    kx_grid, ky_grid = np.meshgrid(kx_vals, ky_vals)\n    \n    # Create the near-field pressure for the piston source\n    p_near_field = np.zeros((Ny, Nx))\n    p_near_field[(np.abs(yy) <= Ay / 2) & (np.abs(xx) <= Ax / 2)] = 1.0\n\n    window_cases = {\n        'rect': (np.ones(Nx), np.ones(Ny)),\n        'hann': (np.hanning(Nx), np.hanning(Ny)),\n        'tukey': (tukey(Nx, alpha=0.25), tukey(Ny, alpha=0.25)),\n        'blackman': (np.blackman(Nx), np.blackman(Ny))\n    }\n    \n    results = []\n\n    for name, (wx, wy) in window_cases.items():\n        # --- Window Application ---\n        w = np.outer(wy, wx)\n        p_windowed = p_near_field * w\n\n        # --- Angular Spectrum Calculation (FFT) ---\n        P_w_unscaled = np.fft.fftshift(np.fft.fft2(p_windowed))\n        P_w = P_w_unscaled * dx * dy\n        \n        # --- Metric 1: Spectral Leakage Fraction (L) ---\n        power_spectrum = np.abs(P_w)**2\n        \n        mask_prop = (np.abs(kx_grid) <= k) & (np.abs(ky_grid) <= k)\n        mask_ml = (np.abs(kx_grid) <= kx_roi) & (np.abs(ky_grid) <= ky_roi)\n        mask_leakage = mask_prop & ~mask_ml\n        \n        total_prop_power = np.sum(power_spectrum[mask_prop])\n        leakage_power = np.sum(power_spectrum[mask_leakage])\n        \n        L = leakage_power / total_prop_power if total_prop_power > 0 else 0.0\n\n        # --- Metrics 2 & 3: FWHM and Side-lobe Ratio (S) ---\n        p_kx_slice = P_w[Ny // 2, :]\n        mag_slice = np.abs(p_kx_slice)\n        \n        peak_mag = np.max(mag_slice)\n        peak_idx = np.argmax(mag_slice)\n        \n        # Metric 2: FWHM\n        target_mag = peak_mag / np.sqrt(2.0)\n        \n        # Interpolate to find k_right\n        idx_right_search_range = np.arange(peak_idx, Nx)\n        mag_right = mag_slice[idx_right_search_range]\n        kx_right = kx_vals[idx_right_search_range]\n        k_right_interp = np.interp(target_mag, mag_right[::-1], kx_right[::-1])\n        \n        # Interpolate to find k_left\n        idx_left_search_range = np.arange(0, peak_idx + 1)\n        mag_left = mag_slice[idx_left_search_range]\n        kx_left = kx_vals[idx_left_search_range]\n        k_left_interp = np.interp(target_mag, mag_left, kx_left)\n\n        FWHM = k_right_interp - k_left_interp\n\n        # Metric 3: Peak Side-lobe Ratio (S)\n        mask_sidelobe = (np.abs(kx_vals) > kx_roi) & (np.abs(kx_vals) <= k)\n        \n        if np.any(mask_sidelobe):\n            peak_sidelobe_mag = np.max(mag_slice[mask_sidelobe])\n            S = peak_sidelobe_mag / peak_mag if peak_mag > 0 else 0.0\n        else:\n            S = 0.0\n            \n        results.append([L, FWHM, S])\n\n    # Format the final output string\n    output_str = \"[\"\n    for i, res in enumerate(results):\n        output_str += f\"[{res[0]},{res[1]},{res[2]}]\"\n        if i < len(results) - 1:\n            output_str += \",\"\n    output_str += \"]\"\n    \n    print(output_str)\n\nsolve()\n```"
        },
        {
            "introduction": "Beyond the computational artifacts of finite apertures, the physical limitations of measurement hardware introduce another layer of uncertainty. Real-world sensors are never perfect, exhibiting small, random errors in both amplitude calibration and phase response. This practice delves into the practical impact of such imperfections on the reconstructed far-field, using a statistical model to connect sensor error standard deviations to the resulting error in the acoustic pattern. This analysis provides a powerful framework for setting realistic hardware tolerances required to meet a specified accuracy threshold for the far-field prediction .",
            "id": "4123308",
            "problem": "You are given a one-dimensional measurement line of $N$ acoustic sensors located along the $x$-axis in a homogeneous, lossless medium with sound speed $c$. The sensors record complex acoustic pressure at a single angular frequency $\\omega=2\\pi f$, where $f$ is the frequency in Hertz. The far-field pressure pattern at observation angle $\\theta$ (in radians) is to be reconstructed from the near-field sensor data. The objective is to evaluate the influence of sensor phase noise and amplitude calibration error on the reconstructed far-field pattern and to derive tolerances required to keep the relative root-mean-square error below a defined threshold in a specified angular region of interest.\n\nStart from the following fundamental base:\n- The acoustic pressure $p(\\mathbf{r})$ in a homogeneous medium satisfies the Helmholtz equation $\\nabla^2 p + k^2 p = 0$, where $k=\\omega/c$ is the wavenumber.\n- The field in the far-field can be expressed under the Fraunhofer approximation as a Fourier-type projection of the pressure on a plane. For a one-dimensional aperture along $x$ at $y=0$, the far-field pressure at an angle $\\theta$ is proportional to the integral of $p(x,0)$ multiplied by a phase factor depending on $\\theta$, which reduces to a discrete sum for sampled data.\n\nAssume the near-field pressure measured by sensor $n$ at position $x_n$ is $p_n$ without error, and the far-field at angle $\\theta$ is reconstructed via a discrete sum with spacing $\\Delta x$:\n$$\nS(\\theta) = \\sum_{n=1}^{N} w_n(\\theta)\\, p_n,\n$$\nwhere $w_n(\\theta)$ is a known complex weight with unit magnitude and includes the propagation phase factor dependent on $k$, $x_n$, and $\\theta$. Let the measured near-field pressure include small amplitude and phase errors per sensor:\n$$\n\\tilde{p}_n = p_n \\left(1 + a_n\\right) e^{i \\phi_n},\n$$\nwhere $a_n$ are zero-mean, independent amplitude calibration errors (dimensionless fractions) with standard deviation $\\sigma_a$, and $\\phi_n$ are zero-mean, independent phase errors (in radians) with standard deviation $\\sigma_\\phi$. Assume $a_n$ and $\\phi_n$ are independent across sensors and mutually independent.\n\nDefine the reconstructed far-field with errors as\n$$\n\\tilde{S}(\\theta) = \\sum_{n=1}^{N} w_n(\\theta)\\, \\tilde{p}_n.\n$$\nLet the relative mean-square error at angle $\\theta$ be\n$$\n\\varepsilon^2(\\theta) = \\frac{\\mathbb{E}\\left[\\,\\left|\\tilde{S}(\\theta) - S(\\theta)\\right|^2\\,\\right]}{\\left|S(\\theta)\\right|^2}.\n$$\n\nYour tasks:\n1. Derive, from first principles, an expression for $\\varepsilon^2(\\theta)$ in terms of $\\sigma_a$, $\\sigma_\\phi$, $p_n$, $w_n(\\theta)$, and $S(\\theta)$, using first-order linearization for small $\\phi_n$.\n2. Based on your expression, derive tolerances for $(\\sigma_a, \\sigma_\\phi)$ such that the maximum of $\\varepsilon(\\theta)$ over an angular region of interest is bounded by a prescribed threshold $\\varepsilon_{\\mathrm{th}}$. The region of interest is defined as the set of angles where the reference far-field magnitude $\\left|S(\\theta)\\right|$ is at least a fraction $g_{\\min}$ of its peak value, i.e., $\\left|S(\\theta)\\right| \\ge g_{\\min}\\,\\max_{\\theta} \\left|S(\\theta)\\right|$.\n3. Implement a program that:\n   - Constructs a synthetic near-field $p_n$ as a coherent superposition of two plane waves impinging on the sensor line:\n     $$\n     p_n = e^{i k \\sin(\\theta_0) x_n} + \\beta\\, e^{i k \\sin(\\theta_1) x_n},\n     $$\n     where $\\theta_0$ and $\\theta_1$ are incidence angles (in radians), and $\\beta$ is a real amplitude scaling factor.\n   - Uses the discrete Fraunhofer-type sum with weights $w_n(\\theta) = \\Delta x\\, e^{-i k x_n \\sin(\\theta)}$ to compute $S(\\theta)$ on a grid of angles $\\theta \\in [-\\pi/3,\\pi/3]$ (in radians).\n   - Computes $\\Gamma(\\theta)$ defined by\n     $$\n     \\Gamma(\\theta) = \\frac{\\sum_{n=1}^{N} \\left|w_n(\\theta) p_n\\right|^2}{\\left|S(\\theta)\\right|^2},\n     $$\n     and uses it to obtain tolerances for $(\\sigma_a, \\sigma_\\phi)$ that guarantee $\\max_{\\theta \\in \\mathcal{R}} \\varepsilon(\\theta) \\le \\varepsilon_{\\mathrm{th}}$, where $\\mathcal{R}$ is the region of interest.\n   - Allocates the combined tolerance budget between amplitude and phase via a specified allocation parameter $\\alpha \\in [0,1]$ such that\n     $$\n     \\sigma_a = \\alpha\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}},\\quad\n     \\sigma_{\\phi} = \\sqrt{1 - \\alpha^2}\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}}.\n     $$\n4. The program must produce the final output containing the tolerances $(\\sigma_a, \\sigma_\\phi)$ for each of the provided test cases, concatenated in a single list of floats.\n\nUse the following test suite of parameter values:\n- Test case 1 (happy path):\n  - $N=64$, $L=0.512$ meters (uniform spacing), $f=6000$ Hertz, $c=343$ meters per second, $\\theta_0 = 0$ radians, $\\theta_1 = 0.34906585$ radians, $\\beta=0.6$, $\\varepsilon_{\\mathrm{th}}=0.05$, $g_{\\min}=0.2$, $\\alpha=0.7$.\n- Test case 2 (near-aliasing, higher frequency):\n  - $N=32$, $L=0.256$ meters (uniform spacing), $f=12000$ Hertz, $c=343$ meters per second, $\\theta_0 = 0.26179939$ radians, $\\theta_1 = -0.34906585$ radians, $\\beta=0.4$, $\\varepsilon_{\\mathrm{th}}=0.1$, $g_{\\min}=0.1$, $\\alpha=0.5$.\n- Test case 3 (narrow aperture, broad beam):\n  - $N=128$, $L=0.128$ meters (uniform spacing), $f=4000$ Hertz, $c=343$ meters per second, $\\theta_0 = 0$ radians, $\\theta_1 = 0.52359878$ radians, $\\beta=0.3$, $\\varepsilon_{\\mathrm{th}}=0.02$, $g_{\\min}=0.3$, $\\alpha=0.8$.\n\nImportant implementation details:\n- The sensor positions $x_n$ are uniformly distributed on $[-L/2, L/2]$ with spacing $\\Delta x = L/(N-1)$.\n- Compute angles on an evenly spaced grid of $181$ samples over $[-\\pi/3,\\pi/3]$ radians.\n- Amplitude errors $\\sigma_a$ must be reported as dimensionless fractions. Phase errors $\\sigma_\\phi$ must be reported in radians.\n- All angles must be treated and reported in radians.\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. The list order must be $[\\sigma_{a,1},\\sigma_{\\phi,1},\\sigma_{a,2},\\sigma_{\\phi,2},\\sigma_{a,3},\\sigma_{\\phi,3}]$ with each entry a float.\n\nNo shortcut formulas are to be given in the problem statement. Justify your derivations clearly from the fundamental base and implement the resulting algorithm.",
            "solution": "The solution proceeds in two main parts: first, a theoretical derivation of the formulas governing the error, and second, a description of the algorithm to compute the required tolerances.\n\n### Part 1: Derivation of the Relative Mean-Square Error, $\\varepsilon^2(\\theta)$\n\nThe objective is to find an expression for the relative mean-square error, defined as:\n$$\n\\varepsilon^2(\\theta) = \\frac{\\mathbb{E}\\left[\\,\\left|\\tilde{S}(\\theta) - S(\\theta)\\right|^2\\,\\right]}{\\left|S(\\theta)\\right|^2}\n$$\nThe error in the reconstructed far-field, $\\Delta S(\\theta)$, is the difference between the reconstruction with errors, $\\tilde{S}(\\theta)$, and the ideal reconstruction, $S(\\theta)$:\n$$\n\\Delta S(\\theta) = \\tilde{S}(\\theta) - S(\\theta) = \\sum_{n=1}^{N} w_n(\\theta)\\, \\tilde{p}_n - \\sum_{n=1}^{N} w_n(\\theta)\\, p_n = \\sum_{n=1}^{N} w_n(\\theta) (\\tilde{p}_n - p_n)\n$$\nThe noisy pressure measurement $\\tilde{p}_n$ is given by $\\tilde{p}_n = p_n (1 + a_n) e^{i \\phi_n}$. For small phase errors $\\phi_n$, we use the first-order Taylor expansion $e^{i \\phi_n} \\approx 1 + i \\phi_n$. Substituting this into the expression for $\\tilde{p}_n$:\n$$\n\\tilde{p}_n \\approx p_n (1 + a_n) (1 + i \\phi_n) = p_n (1 + a_n + i \\phi_n + i a_n \\phi_n)\n$$\nSince both $a_n$ and $\\phi_n$ represent small error terms, their product $a_n \\phi_n$ is a second-order small term and is neglected. This linearization yields:\n$$\n\\tilde{p}_n - p_n \\approx p_n (1 + a_n + i \\phi_n) - p_n = p_n (a_n + i \\phi_n)\n$$\nSubstituting this into the expression for $\\Delta S(\\theta)$:\n$$\n\\Delta S(\\theta) \\approx \\sum_{n=1}^{N} w_n(\\theta) p_n (a_n + i \\phi_n)\n$$\nNow, we compute the expected value of the squared magnitude of this error, $\\mathbb{E}[|\\Delta S(\\theta)|^2]$.\n$$\n|\\Delta S(\\theta)|^2 = \\Delta S(\\theta) \\Delta S(\\theta)^* = \\left(\\sum_{n=1}^{N} w_n(\\theta) p_n (a_n + i \\phi_n)\\right) \\left(\\sum_{m=1}^{N} w_m(\\theta)^* p_m^* (a_m - i \\phi_m)\\right)\n$$\n$$\n|\\Delta S(\\theta)|^2 = \\sum_{n=1}^{N} \\sum_{m=1}^{N} w_n(\\theta) p_n w_m(\\theta)^* p_m^* (a_n + i \\phi_n)(a_m - i \\phi_m)\n$$\nTaking the expectation $\\mathbb{E}[\\cdot]$:\n$$\n\\mathbb{E}[|\\Delta S(\\theta)|^2] = \\sum_{n=1}^{N} \\sum_{m=1}^{N} w_n(\\theta) p_n w_m(\\theta)^* p_m^* \\, \\mathbb{E}[(a_n + i \\phi_n)(a_m - i \\phi_m)]\n$$\nThe expectation of the error term product is:\n$$\n\\mathbb{E}[(a_n + i \\phi_n)(a_m - i \\phi_m)] = \\mathbb{E}[a_n a_m] - i\\mathbb{E}[a_n \\phi_m] + i\\mathbb{E}[\\phi_n a_m] + \\mathbb{E}[\\phi_n \\phi_m]\n$$\nGiven that $a_n$ and $\\phi_n$ are zero-mean, mutually independent, and independent across sensors, we have:\n- $\\mathbb{E}[a_n a_m] = \\sigma_a^2 \\delta_{nm}$\n- $\\mathbb{E}[\\phi_n \\phi_m] = \\sigma_\\phi^2 \\delta_{nm}$\n- $\\mathbb{E}[a_n \\phi_m] = \\mathbb{E}[a_n] \\mathbb{E}[\\phi_m] = 0$ for all $n, m$.\nHere, $\\delta_{nm}$ is the Kronecker delta. Thus, the expectation simplifies to:\n$$\n\\mathbb{E}[(a_n + i \\phi_n)(a_m - i \\phi_m)] = (\\sigma_a^2 + \\sigma_\\phi^2) \\delta_{nm}\n$$\nSubstituting this back into the expression for $\\mathbb{E}[|\\Delta S(\\theta)|^2]$, the double summation collapses to a single sum due to $\\delta_{nm}$:\n$$\n\\mathbb{E}[|\\Delta S(\\theta)|^2] = \\sum_{n=1}^{N} w_n(\\theta) p_n w_n(\\theta)^* p_n^* (\\sigma_a^2 + \\sigma_\\phi^2) = (\\sigma_a^2 + \\sigma_\\phi^2) \\sum_{n=1}^{N} |w_n(\\theta) p_n|^2\n$$\nFinally, dividing by $|S(\\theta)|^2$ gives the desired expression for the relative mean-square error:\n$$\n\\varepsilon^2(\\theta) = (\\sigma_a^2 + \\sigma_\\phi^2) \\frac{\\sum_{n=1}^{N} |w_n(\\theta) p_n|^2}{|S(\\theta)|^2}\n$$\nThis is the required expression from Task 1.\n\n### Part 2: Derivation of Error Tolerances\n\nThe task is to find tolerances $(\\sigma_a, \\sigma_\\phi)$ such that the maximum relative RMS error $\\varepsilon(\\theta)$ within the region of interest $\\mathcal{R}$ is bounded by a threshold $\\varepsilon_{\\mathrm{th}}$:\n$$\n\\max_{\\theta \\in \\mathcal{R}} \\varepsilon(\\theta) \\le \\varepsilon_{\\mathrm{th}}\n$$\nThis is equivalent to:\n$$\n\\max_{\\theta \\in \\mathcal{R}} \\varepsilon^2(\\theta) \\le \\varepsilon_{\\mathrm{th}}^2\n$$\nUsing the expression for $\\varepsilon^2(\\theta)$ derived in Part 1 and the problem's definition of $\\Gamma(\\theta)$:\n$$\n\\varepsilon^2(\\theta) = (\\sigma_a^2 + \\sigma_\\phi^2) \\Gamma(\\theta), \\quad \\text{where} \\quad \\Gamma(\\theta) = \\frac{\\sum_{n=1}^{N} |w_n(\\theta) p_n|^2}{|S(\\theta)|^2}\n$$\nThe inequality becomes:\n$$\n\\max_{\\theta \\in \\mathcal{R}} \\left[ (\\sigma_a^2 + \\sigma_\\phi^2) \\Gamma(\\theta) \\right] \\le \\varepsilon_{\\mathrm{th}}^2\n$$\nSince the error standard deviations $\\sigma_a$ and $\\sigma_\\phi$ are constant with respect to the angle $\\theta$, the term $(\\sigma_a^2 + \\sigma_\\phi^2)$ can be factored out of the maximization:\n$$\n(\\sigma_a^2 + \\sigma_\\phi^2) \\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta) \\le \\varepsilon_{\\mathrm{th}}^2\n$$\nThis establishes an error budget. The tolerances are determined by choosing the case of equality, which represents the maximum allowable error:\n$$\n\\sigma_a^2 + \\sigma_\\phi^2 = \\frac{\\varepsilon_{\\mathrm{th}}^2}{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}\n$$\nThe problem specifies how to allocate this total error budget between amplitude and phase errors using a parameter $\\alpha \\in [0, 1]$:\n$$\n\\sigma_a = \\alpha\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}}\n$$\n$$\n\\sigma_{\\phi} = \\sqrt{1 - \\alpha^2}\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\max_{\\theta \\in \\mathcal{R}} \\Gamma(\\theta)}}\n$$\nThese definitions are consistent, as $\\sigma_a^2 + \\sigma_\\phi^2 = \\alpha^2 (\\dots) + (1-\\alpha^2)(\\dots) = (\\dots)$, satisfying the budget.\n\n### Part 3: Algorithmic Design for Implementation\n\nThe algorithm to compute the tolerances $(\\sigma_a, \\sigma_\\phi)$ for a given set of parameters $(N, L, f, c, \\theta_0, \\theta_1, \\beta, \\varepsilon_{\\mathrm{th}}, g_{\\min}, \\alpha)$ is as follows:\n\n1.  **Initialize Parameters**: Calculate constants and grids.\n    - Wavenumber: $k = 2\\pi f / c$.\n    - Sensor spacing: $\\Delta x = L / (N-1)$.\n    - Sensor positions: $x_n$ for $n=1,\\ldots,N$, as an array from $-L/2$ to $L/2$.\n    - Angle grid: $\\theta_j$ for $j=1,\\ldots,181$, as an array from $-\\pi/3$ to $\\pi/3$.\n\n2.  **Compute Near-Field Pressure**: Calculate the complex pressure $p_n$ at each sensor using the given model:\n    $$\n    p_n = e^{i k x_n \\sin(\\theta_0)} + \\beta\\, e^{i k x_n \\sin(\\theta_1)}\n    $$\n\n3.  **Compute Ideal Far-Field Pattern**: Calculate the ideal far-field pressure $S(\\theta_j)$ for each angle in the grid using the discrete sum:\n    $$\n    S(\\theta_j) = \\sum_{n=1}^{N} w_n(\\theta_j) p_n = \\Delta x \\sum_{n=1}^{N} p_n e^{-i k x_n \\sin(\\theta_j)}\n    $$\n\n4.  **Compute $\\Gamma(\\theta)$**:\n    - First, calculate the numerator, which is constant with respect to $\\theta$:\n      $C_{num} = \\sum_{n=1}^{N} |w_n(\\theta) p_n|^2 = \\sum_{n=1}^{N} (\\Delta x)^2 |p_n|^2 = (\\Delta x)^2 \\sum_{n=1}^{N} |p_n|^2$.\n    - Then, calculate $\\Gamma(\\theta_j)$ for each angle by dividing by the squared magnitude of the far-field pattern:\n      $$\n      \\Gamma(\\theta_j) = \\frac{C_{num}}{|S(\\theta_j)|^2}\n      $$\n      Care must be taken for angles where $|S(\\theta_j)|$ is close to zero, although the definition of the region of interest will exclude these nulls.\n\n5.  **Identify Region of Interest $\\mathcal{R}$**:\n    - Find the maximum magnitude of the far-field pattern: $S_{\\max} = \\max_j |S(\\theta_j)|$.\n    - Determine the threshold for inclusion in $\\mathcal{R}$: $S_{thresh} = g_{\\min} S_{\\max}$.\n    - Identify the set of angles (or their indices) for which $|S(\\theta_j)| \\ge S_{thresh}$.\n\n6.  **Find Maximum of $\\Gamma(\\theta)$ in $\\mathcal{R}$**:\n    - From the values of $\\Gamma(\\theta_j)$ computed in step 4, select those corresponding to the angles in $\\mathcal{R}$.\n    - Find the maximum value among this subset: $\\Gamma_{\\max, \\mathcal{R}} = \\max_{\\theta_j \\in \\mathcal{R}} \\Gamma(\\theta_j)$.\n\n7.  **Calculate Tolerances**: Use the formulas from Part 2 to compute the final tolerances:\n    - $\\sigma_a = \\alpha\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\Gamma_{\\max, \\mathcal{R}}}}$\n    - $\\sigma_{\\phi} = \\sqrt{1 - \\alpha^2}\\, \\frac{\\varepsilon_{\\mathrm{th}}}{\\sqrt{\\Gamma_{\\max, \\mathcal{R}}}}$\n\nThese steps will be implemented for each test case provided in the problem statement.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"L\": 0.512, \"f\": 6000, \"c\": 343, \n            \"theta0\": 0, \"theta1\": 0.34906585, \"beta\": 0.6,\n            \"eps_th\": 0.05, \"g_min\": 0.2, \"alpha\": 0.7\n        },\n        {\n            \"N\": 32, \"L\": 0.256, \"f\": 12000, \"c\": 343,\n            \"theta0\": 0.26179939, \"theta1\": -0.34906585, \"beta\": 0.4,\n            \"eps_th\": 0.1, \"g_min\": 0.1, \"alpha\": 0.5\n        },\n        {\n            \"N\": 128, \"L\": 0.128, \"f\": 4000, \"c\": 343,\n            \"theta0\": 0, \"theta1\": 0.52359878, \"beta\": 0.3,\n            \"eps_th\": 0.02, \"g_min\": 0.3, \"alpha\": 0.8\n        }\n    ]\n\n    results = []\n    for params in test_cases:\n        sigma_a, sigma_phi = calculate_tolerances(**params)\n        results.extend([sigma_a, sigma_phi])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_tolerances(N, L, f, c, theta0, theta1, beta, eps_th, g_min, alpha):\n    \"\"\"\n    Calculates the amplitude and phase error tolerances for a single test case.\n\n    Args:\n        N (int): Number of sensors.\n        L (float): Length of the sensor line in meters.\n        f (float): Frequency in Hertz.\n        c (float): Speed of sound in meters per second.\n        theta0 (float): Incidence angle of the first plane wave in radians.\n        theta1 (float): Incidence angle of the second plane wave in radians.\n        beta (float): Amplitude scaling factor for the second plane wave.\n        eps_th (float): Relative RMS error threshold.\n        g_min (float): Fraction of peak magnitude for region of interest.\n        alpha (float): Tolerance allocation parameter.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated tolerances \n                             (sigma_a, sigma_phi).\n    \"\"\"\n\n    # Step 1: Initialize Parameters\n    # Wavenumber\n    k = 2 * np.pi * f / c\n    \n    # Sensor positions\n    # If N=1, spacing is undefined. Problem assumes N > 1.\n    if N > 1:\n        delta_x = L / (N - 1)\n        x_n = np.linspace(-L / 2, L / 2, N)\n    else: # Edge case for N=1\n        delta_x = 0\n        x_n = np.array([0.0])\n\n    # Angle grid\n    num_angles = 181\n    theta_grid = np.linspace(-np.pi / 3, np.pi / 3, num_angles)\n\n    # Step 2: Compute Near-Field Pressure\n    p_n = np.exp(1j * k * np.sin(theta0) * x_n) + \\\n          beta * np.exp(1j * k * np.sin(theta1) * x_n)\n\n    # Step 3: Compute Ideal Far-Field Pattern S(theta)\n    # S(theta_j) = sum_n { delta_x * exp(-1j*k*x_n*sin(theta_j)) * p_n }\n    # This can be computed efficiently using matrix operations.\n    sin_theta = np.sin(theta_grid)\n    # Outer product of x_n and sin_theta gives the exponent matrix\n    exp_matrix = np.exp(-1j * k * np.outer(x_n, sin_theta))\n    # S(theta) is the dot product of p_n with columns of the weight matrix\n    S_theta = delta_x * (p_n @ exp_matrix)\n\n    # Step 4: Compute Gamma(theta)\n    # Numerator of Gamma: sum_n |w_n(theta) * p_n|^2\n    # Since |w_n(theta)| = delta_x, this is (delta_x^2) * sum_n |p_n|^2\n    numerator_gamma = (delta_x**2) * np.sum(np.abs(p_n)**2)\n    \n    # Denominator of Gamma: |S(theta)|^2\n    # Add a small epsilon to avoid division by zero at pattern nulls\n    # These nulls will be excluded by the region of interest definition anyway.\n    S_theta_mag_sq = np.abs(S_theta)**2\n    # Protect against division by zero in case of an all-zero pattern\n    S_theta_mag_sq[S_theta_mag_sq < 1e-30] = 1e-30\n    Gamma_theta = numerator_gamma / S_theta_mag_sq\n\n    # Step 5: Identify Region of Interest (ROI)\n    S_theta_mag = np.abs(S_theta)\n    S_max = np.max(S_theta_mag)\n    \n    # If the pattern is zero everywhere, the ROI is empty. Handle this case.\n    if S_max < 1e-15:\n      # This case implies Gamma is infinite, making tolerances zero.\n      return 0.0, 0.0\n      \n    S_min_roi = g_min * S_max\n    \n    # Create a boolean mask for the angles in the ROI\n    roi_mask = S_theta_mag >= S_min_roi\n    \n    # If the ROI is empty (e.g., g_min > 1), we cannot proceed.\n    # The max of an empty set is undefined. We assume this won't happen \n    # with valid problem parameters.\n    if not np.any(roi_mask):\n        # This implies all signal is below g_min*S_max.\n        # This can happen if g_min is large. In this scenario, there's no\n        # region to enforce the tolerance. We could interpret this as\n        # requiring infinite precision (zero tolerance).\n        return 0.0, 0.0\n\n    # Step 6: Find Maximum of Gamma(theta) in ROI\n    Gamma_in_roi = Gamma_theta[roi_mask]\n    max_Gamma_in_roi = np.max(Gamma_in_roi)\n\n    # Step 7: Calculate Tolerances\n    # Common factor for both tolerances\n    common_factor = eps_th / np.sqrt(max_Gamma_in_roi)\n    \n    sigma_a = alpha * common_factor\n    sigma_phi = np.sqrt(1 - alpha**2) * common_factor\n    \n    return sigma_a, sigma_phi\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```"
        }
    ]
}