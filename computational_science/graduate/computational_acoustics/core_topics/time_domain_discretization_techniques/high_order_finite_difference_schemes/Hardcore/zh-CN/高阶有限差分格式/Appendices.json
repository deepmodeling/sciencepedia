{
    "hands_on_practices": [
        {
            "introduction": "任何有限差分法的基础都源于其系数，这些系数决定了如何利用离散点上的函数值来逼近导数。第一个动手实践将引导您完成推导这些系数的基础过程，即利用泰勒级数展开。掌握这项基本技能有助于揭开那些看似复杂的差分格式的神秘面纱，并理解其构造的根本原理 。",
            "id": "2401286",
            "problem": "考虑一个定义在包含均匀网格节点 $x_i, x_{i+1}, x_{i+2}, x_{i+3}, x_{i+4}$ 的区间上的足够光滑的函数 $f$，该网格的步长为 $h>0$，其中 $x_{j} = x_{0} + j h$。假设 $f$ 在 $[x_i, x_{i+4}]$ 上至少有5阶连续导数。仅使用 $f(x_i)$、$f(x_{i+1})$、$f(x_{i+2})$、$f(x_{i+3})$ 和 $f(x_{i+4})$ 的值，构造一个对一阶导数 $f'(x_i)$ 的向前差分近似，其精度达到 $h^{4}$ 阶（即，截断误差为 $\\mathcal{O}(h^{4})$ 阶）。\n\n确定唯一的系数 $a_0, a_1, a_2, a_3, a_4 \\in \\mathbb{R}$，使得\n$$\nf'(x_i) \\approx \\frac{1}{h}\\sum_{k=0}^{4} a_k\\, f(x_{i+k})\n$$\n达到四阶精度，并以单个解析表达式的形式给出最终的闭式近似。\n\n答案规格：\n- 以单个闭式解析表达式的形式，给出用 $f(x_{i+k})$ 和 $h$ 表示的 $f'(x_i)$ 的近似结果。\n- 无需四舍五入。",
            "solution": "我们的目标是找到近似公式\n$$\nf'(x_i) \\approx \\frac{1}{h}\\sum_{k=0}^{4} a_k f(x_{i+k})\n$$\n的系数 $a_0, a_1, a_2, a_3, a_4$，使得截断误差为 $\\mathcal{O}(h^4)$ 阶。这是待定系数法的直接应用，该方法利用泰勒级数展开。\n\n函数 $f$ 假定为足够光滑，这使我们能够将每一项 $f(x_{i+k})$ 在点 $x_i$ 附近展开成泰勒级数。展开式由下式给出：\n$$\nf(x_{i+k}) = f(x_i + kh) = \\sum_{j=0}^{\\infty} \\frac{(kh)^j}{j!} f^{(j)}(x_i)\n$$\n其中 $f^{(j)}(x_i)$ 表示 $f$ 在 $x_i$ 处的 $j$ 阶导数。\n\n将此展开式代入有限差分公式，我们得到：\n$$\n\\frac{1}{h}\\sum_{k=0}^{4} a_k f(x_{i+k}) = \\frac{1}{h}\\sum_{k=0}^{4} a_k \\left( \\sum_{j=0}^{\\infty} \\frac{(kh)^j}{j!} f^{(j)}(x_i) \\right)\n$$\n通过交换求和顺序（在此处是允许的），我们得到：\n$$\n\\frac{1}{h}\\sum_{j=0}^{\\infty} \\frac{h^j f^{(j)}(x_i)}{j!} \\left( \\sum_{k=0}^{4} k^j a_k \\right)\n$$\n我们希望这个表达式能以 $\\mathcal{O}(h^4)$ 阶的截断误差来近似 $f'(x_i)$。这意味着当我们将表达式按 $h$ 的幂次展开时，$f'(x_i)$ 的系数必须为 $1$，而 $f(x_i)$、$f''(x_i)$、$f'''(x_i)$ 和 $f^{(4)}(x_i)$ 的系数必须为 $0$。\n\n让我们考察 $j=0, 1, 2, 3, 4$ 时的各项：\n\\begin{itemize}\n    \\item 对于 $j=0$：该项为 $\\frac{1}{h} \\frac{h^0 f^{(0)}(x_i)}{0!} \\left( \\sum_{k=0}^{4} a_k \\right) = \\frac{f(x_i)}{h} \\sum_{k=0}^{4} a_k$。为了消去此项，我们必须有：\n    $$ \\sum_{k=0}^{4} a_k = 0 $$\n    \\item 对于 $j=1$：该项为 $\\frac{1}{h} \\frac{h^1 f^{(1)}(x_i)}{1!} \\left( \\sum_{k=0}^{4} k a_k \\right) = f'(x_i) \\sum_{k=0}^{4} k a_k$。为了使它等于 $f'(x_i)$，我们需要：\n    $$ \\sum_{k=0}^{4} k a_k = 1 $$\n    \\item 对于 $j=2$：该项为 $\\frac{1}{h} \\frac{h^2 f^{(2)}(x_i)}{2!} \\left( \\sum_{k=0}^{4} k^2 a_k \\right) = \\frac{h f''(x_i)}{2} \\sum_{k=0}^{4} k^2 a_k$。为了消去 $\\mathcal{O}(h)$ 阶误差项，我们必须有：\n    $$ \\sum_{k=0}^{4} k^2 a_k = 0 $$\n    \\item 对于 $j=3$：该项为 $\\frac{1}{h} \\frac{h^3 f^{(3)}(x_i)}{3!} \\left( \\sum_{k=0}^{4} k^3 a_k \\right) = \\frac{h^2 f'''(x_i)}{6} \\sum_{k=0}^{4} k^3 a_k$。为了消去 $\\mathcal{O}(h^2)$ 阶误差项：\n    $$ \\sum_{k=0}^{4} k^3 a_k = 0 $$\n    \\item 对于 $j=4$：该项为 $\\frac{1}{h} \\frac{h^4 f^{(4)}(x_i)}{4!} \\left( \\sum_{k=0}^{4} k^4 a_k \\right) = \\frac{h^3 f^{(4)}(x_i)}{24} \\sum_{k=0}^{4} k^4 a_k$。为了消去 $\\mathcal{O}(h^3)$ 阶误差项：\n    $$ \\sum_{k=0}^{4} k^4 a_k = 0 $$\n\\end{itemize}\n这样，截断误差的首项将是 $j=5$ 对应的项，其阶数为 $\\mathcal{O}(h^4)$，这符合题目的要求。\n\n这五个条件为五个未知系数 $a_0, a_1, a_2, a_3, a_4$ 导出一个由五个线性方程组成的方程组：\n\\begin{align*}\n    a_0 + a_1 + a_2 + a_3 + a_4 = 0 \\\\\n    0 \\cdot a_0 + 1 \\cdot a_1 + 2 \\cdot a_2 + 3 \\cdot a_3 + 4 \\cdot a_4 = 1 \\\\\n    0^2 a_0 + 1^2 a_1 + 2^2 a_2 + 3^2 a_3 + 4^2 a_4 = 0 \\\\\n    0^3 a_0 + 1^3 a_1 + 2^3 a_2 + 3^3 a_3 + 4^3 a_4 = 0 \\\\\n    0^4 a_0 + 1^4 a_1 + 2^4 a_2 + 3^4 a_3 + 4^4 a_4 = 0\n\\end{align*}\n该方程组可以写成矩阵形式：\n$$\n\\begin{pmatrix}\n1 & 1 & 1 & 1 & 1 \\\\\n0 & 1 & 2 & 3 & 4 \\\\\n0 & 1 & 4 & 9 & 16 \\\\\n0 & 1 & 8 & 27 & 64 \\\\\n0 & 1 & 16 & 81 & 256\n\\end{pmatrix}\n\\begin{pmatrix} a_0 \\\\ a_1 \\\\ a_2 \\\\ a_3 \\\\ a_4 \\end{pmatrix}\n=\n\\begin{pmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\n$$\n关于 $a_1, a_2, a_3, a_4$ 的子系统涉及一个范德蒙型矩阵。解这个 $4 \\times 4$ 方程组，然后利用第一个方程求出 $a_0$，这是一个直接但略显繁琐的过程。该方程组的唯一解是：\n$$ a_0 = -\\frac{25}{12}, \\quad a_1 = 4, \\quad a_2 = -3, \\quad a_3 = \\frac{4}{3}, \\quad a_4 = -\\frac{1}{4} $$\n为了得到一个更简洁的最终表达式，我们可以将这些系数写成以12为公分母的形式：\n$$ a_0 = -\\frac{25}{12}, \\quad a_1 = \\frac{48}{12}, \\quad a_2 = -\\frac{36}{12}, \\quad a_3 = \\frac{16}{12}, \\quad a_4 = -\\frac{3}{12} $$\n将这些系数代入近似公式：\n$$\nf'(x_i) \\approx \\frac{1}{h} \\left( -\\frac{25}{12}f(x_i) + \\frac{48}{12}f(x_{i+1}) - \\frac{36}{12}f(x_{i+2}) + \\frac{16}{12}f(x_{i+3}) - \\frac{3}{12}f(x_{i+4}) \\right)\n$$\n提出公分母12，得到一阶导数的四阶精度向前差分近似的最终闭式表达式：\n$$\nf'(x_i) \\approx \\frac{1}{12h} \\left( -25f(x_i) + 48f(x_{i+1}) - 36f(x_{i+2}) + 16f(x_{i+3}) - 3f(x_{i+4}) \\right)\n$$\n推导至此完成。",
            "answer": "$$\\boxed{\\frac{1}{12h} \\left( -25f(x_i) + 48f(x_{i+1}) - 36f(x_{i+2}) + 16f(x_{i+3}) - 3f(x_{i+4}) \\right)}$$"
        },
        {
            "introduction": "在掌握了如何构建单个差分格式之后，一个自然的进阶是将其应用于更宏大的背景中。在计算物理学中，我们通常使用这些格式来求解偏微分方程。本练习  探讨了用于扩散方程的高阶空间离散格式如何直接影响时间步进方法的稳定性——这是连接精度与计算可行性的关键环节。通过这个实践，您将学会如何通过分析离散算子的谱特性来确定显式时间积分的稳定时间步长。",
            "id": "2401265",
            "problem": "考虑在一维空间域 $[0,L)$ 上的具有周期性边界条件的一维线性扩散方程，其空间离散化系统由以下公式给出：\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\mathbf{u}(t) = A\\,\\mathbf{u}(t),\n$$\n其中 $A = \\kappa D^{(2)}$，$D^{(2)}\\in\\mathbb{R}^{N\\times N}$ 是在具有 $N$ 个点、网格间距为 $h=L/N$ 的均匀网格上，对二阶导数算子 $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 的四阶精度、中心、周期性有限差分近似的矩阵表示。网格点位于 $x_j = jh$，其中 $j=0,1,\\dots,N-1$，并且周期性边界条件将 $x_0$ 与 $x_N$ 等同。显式前向欧拉时间离散化定义为：\n$$\n\\mathbf{u}^{n+1} = \\mathbf{u}^{n} + \\Delta t \\, A\\, \\mathbf{u}^{n}.\n$$\n将最大稳定时间步长 $\\Delta t_{\\max}$ 定义为所有满足以下条件的 $\\Delta t > 0$ 的上确界：对于 $A$ 的每个特征值 $\\lambda$，放大因子满足 $\\left|1+\\Delta t\\,\\lambda\\right|\\le 1$。\n\n你的任务是：\n- 构造 $D^{(2)}$ 作为在上述均匀周期性网格上近似 $\\frac{\\mathrm{d}^2}{\\mathrm{d}x^2}$ 的四阶精度、中心、周期性有限差分矩阵。\n- 计算 $A=\\kappa D^{(2)}$ 的所有特征值。\n- 使用 $A$ 的特征值和上述定义，确定显式前向欧拉方法的 $\\Delta t_{\\max}$。\n\n测试套件和所需输出：\n使用以下参数集 $(L,N,\\kappa)$，每个参数集定义一个独立的测试用例：\n- 测试用例 1：$(L,N,\\kappa)=\\left(1,\\,64,\\,1\\right)$。\n- 测试用例 2：$(L,N,\\kappa)=\\left(2,\\,32,\\,\\frac{1}{2}\\right)$。\n- 测试用例 3：$(L,N,\\kappa)=\\left(1,\\,5,\\,1\\right)$。\n- 测试用例 4：$(L,N,\\kappa)=\\left(\\pi,\\,100,\\,2\\right)$，其中 $\\pi$ 是圆周率。\n\n对于每个测试用例，计算 $\\Delta t_{\\max}$ 并将其表示为精确到10位小数的十进制数，不带单位。\n\n最终输出格式：\n你的程序应产生单行输出，其中包含四个测试用例的结果，按上面列出的相同顺序排列，形式为用方括号括起来的逗号分隔列表，例如 $\\left[\\Delta t_{\\max}^{(1)},\\Delta t_{\\max}^{(2)},\\Delta t_{\\max}^{(3)},\\Delta t_{\\max}^{(4)}\\right]$，每个条目都精确到10位小数并以标准十进制表示法打印。",
            "solution": "该问题是有效的，我们将分四个阶段展开解决方案：\n1.  构造四阶有限差分算子矩阵 $D^{(2)}$。\n2.  确定系统矩阵 $A = \\kappa D^{(2)}$ 的特征值。\n3.  对前向欧拉方法进行稳定性分析，以推导 $\\Delta t_{\\max}$ 的表达式。\n4.  将推导出的公式应用于指定的测试用例。\n\n在网格点 $x_j$ 处，二阶导数 $\\frac{\\mathrm{d}^2 u}{\\mathrm{d} x^2}$ 的一个四阶精度中心有限差分近似由以下五点格式给出：\n$$\n\\frac{\\mathrm{d}^2 u}{\\mathrm{d} x^2}\\bigg|_{x_j} \\approx \\frac{1}{h^2} \\left( -\\frac{1}{12}u_{j-2} + \\frac{4}{3}u_{j-1} - \\frac{5}{2}u_j + \\frac{4}{3}u_{j+1} - \\frac{1}{12}u_{j+2} \\right)\n$$\n其中 $u_j = u(x_j)$，$h$ 是均匀网格间距。对于一个有 $N$ 个点的周期性区域，下标按模 $N$ 进行解释。这种结构产生了一个循环矩阵 $D^{(2)} \\in \\mathbb{R}^{N\\times N}$。循环矩阵由其第一行定义。矩阵 $h^2 D^{(2)}$ 的第一行是 $(c_0, c_1, c_2, 0, \\dots, 0, c_{N-2}, c_{N-1})$，但由于对称性，它也可以写成 $(c_0, c_1, c_2, 0, \\dots, 0, c_2, c_1)$，其中系数为 $c_0 = -5/2$，$c_1 = 4/3$ 和 $c_2 = -1/12$。\n\n一个第一行为 $(r_0, r_1, \\dots, r_{N-1})$ 的 $N \\times N$ 循环矩阵的特征值由公式 $\\nu_k = \\sum_{j=0}^{N-1} r_j e^{i 2\\pi kj/N}$ 给出，其中 $k=0, 1, \\dots, N-1$。对于我们的矩阵 $h^2 D^{(2)}$，其特征值记为 $\\mu_k$。令 $\\theta_k = 2\\pi k/N$，我们得到：\n$$\n\\mu_k = c_0 + c_1(e^{i\\theta_k} + e^{-i\\theta_k}) + c_2(e^{i2\\theta_k} + e^{-i2\\theta_k}) = c_0 + 2c_1\\cos(\\theta_k) + 2c_2\\cos(2\\theta_k)\n$$\n代入系数 $c_0 = -5/2$, $c_1 = 4/3$, $c_2 = -1/12$ 并使用恒等式 $\\cos(2\\theta) = 2\\cos^2(\\theta) - 1$：\n$$\n\\mu_k = -\\frac{5}{2} + \\frac{8}{3}\\cos(\\theta_k) - \\frac{1}{6}\\cos(2\\theta_k) = -\\frac{5}{2} + \\frac{8}{3}\\cos(\\theta_k) - \\frac{1}{6}(2\\cos^2(\\theta_k) - 1) = -\\frac{1}{3}\\cos^2(\\theta_k) + \\frac{8}{3}\\cos(\\theta_k) - \\frac{7}{3}\n$$\n$D^{(2)}$ 的特征值是 $\\lambda_{D^{(2)},k} = \\mu_k / h^2$，而 $A = \\kappa D^{(2)}$ 的特征值是 $\\lambda_k = \\kappa \\mu_k / h^2$。所有的 $\\lambda_k$ 都是实数且非正的，这符合扩散算子的要求。\n\n前向欧拉格式的稳定性要求对于所有特征值 $\\lambda_k$ 都满足 $|1 + \\Delta t \\lambda_k| \\le 1$。由于 $\\lambda_k \\in \\mathbb{R}$ 且 $\\lambda_k \\le 0$，该条件等价于 $-1 \\le 1 + \\Delta t \\lambda_k \\le 1$。对于 $\\Delta t > 0$，右侧的不等式总是成立。左侧的不等式给出 $\\Delta t \\lambda_k \\ge -2$，这意味着 $\\Delta t \\le -2/\\lambda_k$（因为 $\\lambda_k < 0$，不等号反向）。为了对所有 $k$ 满足此条件，我们必须有：\n$$\n\\Delta t \\le \\min_{k, \\lambda_k \\ne 0} \\left( \\frac{-2}{\\lambda_k} \\right) = \\frac{-2}{\\lambda_{\\min}}\n$$\n其中 $\\lambda_{\\min}$ 是 $A$ 的最负（最小）特征值。因此，$\\Delta t_{\\max} = -2 / \\lambda_{\\min}$。\n\n最小特征值 $\\lambda_{\\min}$ 对应于 $\\mu_k$ 的最小值。令 $c = \\cos(\\theta_k)$。函数 $f(c) = -\\frac{1}{3}c^2 + \\frac{8}{3}c - \\frac{7}{3}$ 的顶点在 $c = -(\\frac{8}{3}) / (2(-\\frac{1}{3})) = 4$，这超出了 $c \\in [-1, 1]$ 的范围。在区间 $[-1, 1]$ 上，$f(c)$ 是单调递增的。因此，当 $\\cos(\\theta_k)$ 取最小值时，$\\mu_k$ 也取最小值。$k$ 的范围是 $0, 1, \\dots, N-1$。$\\cos(2\\pi k/N)$ 的最小值在 $k_{\\text{ext}} = \\lfloor N/2 \\rfloor$ 时取得。\n因此，$h^2 D^{(2)}$ 的最负特征值为：\n$$\n\\mu_{\\min} = \\mu_{k_{\\text{ext}}} = \\frac{1}{3}\\left( -\\cos^2(\\theta_{\\text{ext}}) + 8\\cos(\\theta_{\\text{ext}}) - 7 \\right), \\quad \\text{其中} \\quad \\theta_{\\text{ext}} = \\frac{2\\pi \\lfloor N/2 \\rfloor}{N}\n$$\n$A$ 的最小特征值是 $\\lambda_{\\min} = \\kappa \\mu_{\\min} / h^2$。最大稳定时间步长是：\n$$\n\\Delta t_{\\max} = \\frac{-2}{\\lambda_{\\min}} = \\frac{-2h^2}{\\kappa \\mu_{\\min}} = \\frac{-6h^2}{\\kappa \\left( -\\cos^2(\\theta_{\\text{ext}}) + 8\\cos(\\theta_{\\text{ext}}) - 7 \\right)}\n$$\n对于偶数 $N$ 会出现一个特殊情况。此时，$k_{\\text{ext}} = N/2$，所以 $\\theta_{\\text{ext}} = \\pi$ 且 $\\cos(\\theta_{\\text{ext}}) = -1$。括号中的项变为 $-(-1)^2 + 8(-1) - 7 = -1 - 8 - 7 = -16$。\n对于偶数 $N$，公式简化为：\n$$\n\\Delta t_{\\max} = \\frac{-6h^2}{\\kappa(-16)} = \\frac{3h^2}{8\\kappa} = \\frac{3(L/N)^2}{8\\kappa} = \\frac{3L^2}{8\\kappa N^2}\n$$\n\n每个测试用例的计算如下：\n\n- **测试用例 1**：$(L,N,\\kappa)=(1,64,1)$。$N=64$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(1)^2}{8(1)(64)^2} = \\frac{3}{32768} = 0.000091552734375$。\n  保留10位小数：$0.0000915527$。\n\n- **测试用例 2**：$(L,N,\\kappa)=(2,32,1/2)$。$N=32$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(2)^2}{8(1/2)(32)^2} = \\frac{12}{4(1024)} = \\frac{3}{1024} = 0.0029296875$。\n  保留10位小数：$0.0029296875$。\n\n- **测试用例 3**：$(L,N,\\kappa)=(1,5,1)$。$N=5$ 是奇数。\n  $h = 1/5$。$k_{\\text{ext}} = \\lfloor 5/2 \\rfloor = 2$。\n  $\\theta_{\\text{ext}} = 2\\pi(2)/5 = 4\\pi/5$。\n  令 $c = \\cos(4\\pi/5)$。$\\mu_{\\min} = \\frac{1}{3}(-c^2 + 8c - 7)$。\n  $\\Delta t_{\\max} = \\frac{-2(1/5)^2}{(1) \\cdot \\mu_{\\min}} = \\frac{-2/25}{\\mu_{\\min}} = \\frac{-6}{25(-c^2 + 8c - 7)}$。\n  数值上，$c \\approx -0.8090169944$，$\\mu_{\\min} \\approx -4.708881224$。\n  $\\Delta t_{\\max} \\approx \\frac{-0.08}{-4.708881224} \\approx 0.016989437820$。\n  保留10位小数：$0.0169894378$。\n\n- **测试用例 4**：$(L,N,\\kappa)=(\\pi,100,2)$。$N=100$ 是偶数。\n  $\\Delta t_{\\max} = \\frac{3(\\pi)^2}{8(2)(100)^2} = \\frac{3\\pi^2}{160000}$。\n  $\\Delta t_{\\max} \\approx \\frac{3(9.8696044011)}{160000} \\approx 0.000185055146$。\n  保留10位小数：$0.0001850551$。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest stable time step for the forward Euler method\n    applied to the 1D diffusion equation with a fourth-order finite difference\n    spatial discretization on a periodic domain.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 64, 1.0),\n        (2.0, 32, 0.5),\n        (1.0, 5, 1.0),\n        (np.pi, 100, 2.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        L, N, kappa = case\n        h = L / N\n\n        # The stability limit depends on whether N is even or odd.\n        if N % 2 == 0:\n            # For even N, the Nyquist mode k=N/2 exists, and cos(2*pi*k/N) = -1.\n            # This leads to a simplified formula for dt_max.\n            # dt_max = (3 * h**2) / (8 * kappa)\n            dt_max = (3 * L**2) / (8 * kappa * N**2)\n        else:\n            # For odd N, the most negative eigenvalue corresponds to k = floor(N/2).\n            # We must use the general formula.\n            k_ext = np.floor(N / 2)\n            theta_ext = 2 * np.pi * k_ext / N\n            cos_theta = np.cos(theta_ext)\n            \n            # The minimum eigenvalue of the scaled (h^2 * D^(2)) operator.\n            # This is derived from the symbol of the FD scheme.\n            mu_min = (1/3) * (-cos_theta**2 + 8 * cos_theta - 7)\n            \n            # The minimum eigenvalue of the system matrix A = kappa * D^(2).\n            lambda_min = kappa * mu_min / h**2\n            \n            # The stability limit is dt_max = -2 / lambda_min.\n            dt_max = -2.0 / lambda_min\n\n        results.append(f\"{dt_max:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "最后，我们将探索高阶方法适用性的边界。高阶格式的强大能力，建立在待微分函数足够光滑的假设之上。本练习  是一个数值实验，旨在探究当这一核心假设被破坏时会发生什么。通过将高阶格式应用于一个带有尖点的函数，您将亲眼观察到精度降阶现象，并深刻理解在选择数值方法之前分析问题本身特性的重要性。",
            "id": "3227834",
            "problem": "您需要研究一阶导数的高阶有限差分近似在应用于具有不可微点的函数时的行为。其理论基础是足够光滑的函数在某点周围的泰勒级数展开。从以下定义出发：对于一个在点 $x$ 附近至少五次连续可微的函数 $f$，其在 $f(x \\pm h)$ 和 $f(x \\pm 2h)$ 处的值允许在 $x$ 点进行泰勒级数展开。利用这些展开式，推导一个中心有限差分近似，该近似使用 $x - 2h$、$x - h$、$x + h$ 和 $x + 2h$ 处的值来近似 $f'(x)$，对于足够光滑的函数，其截断误差与 $h^4$ 成正比。\n\n推导出高阶格式后，请实现它并测试其在函数 $f(x) = |x - 0.5|$ 在区间 $[0,1]$ 上的性能。使用一个包含 $n$ 个点的均匀网格，因此网格间距为 $h = \\frac{1}{n - 1}$，网格点为 $x_i = i h$，$i = 0, 1, \\dots, n - 1$。$f$ 的精确导数由 $f'(x) = -1$（对于 $x  0.5$）和 $f'(x) = +1$（对于 $x > 0.5$）给出，并且在 $x = 0.5$ 处无定义。为确保科学真实性，将点 $x = 0.5$ 排除在任何误差度量之外，因为 $f'(0.5)$ 是未定义的。\n\n仅在内部点 $x_i$（$i = 2, 3, \\dots, n - 3$）上定义导数近似，以使四点中心模板能完整地落在区间内。将每个内部模板分类为“平滑区域”或“跨角点”，规则如下：\n- 如果 $x_{i-2}$ 和 $x_{i+2}$ 都严格位于 $0.5$ 的同一侧，即 $x_{i+2} \\le 0.5$ 或 $x_{i-2} \\ge 0.5$，则以 $x_i$ 为中心的模板是“平滑区域”。\n- 如果模板跨越了角点，即 $x_{i-2}  0.5  x_{i+2}$，则以 $x_i$ 为中心的模板是“跨角点”。\n\n对于所提供测试套件中的每个 $n$ 值，计算以下三个误差度量，以实数（浮点数）表示：\n- $E_{\\text{all}}$：在所有内部点 $x_i$ 上的最大绝对误差，不包括任何 $x_i = 0.5$ 的点。\n- $E_{\\text{smooth}}$：仅限于具有“平滑区域”模板的内部点上的最大绝对误差。\n- $E_{\\text{cross}}$：仅限于具有“跨角点”模板的内部点上的最大绝对误差。如果对于给定的 $n$ 没有跨角点模板，则定义 $E_{\\text{cross}} = 0$。\n\n使用以下网格尺寸的测试套件：\n- $n = 11$（粗网格，其中 $0.5$ 是一个网格点），\n- $n = 12$（粗网格，其中 $0.5$ 不是网格点），\n- $n = 101$（细网格，其中 $0.5$ 是一个网格点），\n- $n = 102$（细网格，其中 $0.5$ 不是网格点）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例生成一个列表 $[E_{\\text{all}}, E_{\\text{smooth}}, E_{\\text{cross}}]$，整体输出是这些列表的列表，顺序与测试套件相同。例如，要求的输出格式为 $[[E_{\\text{all}}^{(11)}, E_{\\text{smooth}}^{(11)}, E_{\\text{cross}}^{(11)}],[E_{\\text{all}}^{(12)}, E_{\\text{smooth}}^{(12)}, E_{\\text{cross}}^{(12)}],[E_{\\text{all}}^{(101)}, E_{\\text{smooth}}^{(101)}, E_{\\text{cross}}^{(101)}],[E_{\\text{all}}^{(102)}, E_{\\text{smooth}}^{(102)}, E_{\\text{cross}}^{(102)}]]$。\n\n所有答案都是没有物理单位的纯数字，也不涉及角度单位。",
            "solution": "### 四阶中心差分公式的推导\n\n我们的目标是推导一个使用点 $x-2h$、$x-h$、$x+h$ 和 $x+2h$ 来逼近一阶导数 $f'(x)$ 的有限差分公式。我们寻求一种中心差分格式，其形式为：\n$$\nf'(x) \\approx \\frac{c_1(f(x+h) - f(x-h)) + c_2(f(x+2h) - f(x-2h))}{h}\n$$\n我们利用泰勒级数展开来确定系数 $c_1$ 和 $c_2$。首先，计算两个差分项的展开：\n$$\nf(x+h) - f(x-h) = 2hf'(x) + \\frac{h^3}{3}f'''(x) + \\frac{h^5}{60}f^{(5)}(x) + O(h^7)\n$$\n$$\nf(x+2h) - f(x-2h) = 4hf'(x) + \\frac{8h^3}{3}f'''(x) + \\frac{8h^5}{15}f^{(5)}(x) + O(h^7)\n$$\n将这两个展开式除以 $2h$ 和 $4h$（这是一种理查森外推法的思想），我们得到两个对 $f'(x)$ 的二阶近似：\n$$\nD_1 = \\frac{f(x+h) - f(x-h)}{2h} = f'(x) + \\frac{h^2}{6}f'''(x) + \\frac{h^4}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nD_2 = \\frac{f(x+2h) - f(x-2h)}{4h} = f'(x) + \\frac{4h^2}{6}f'''(x) + \\frac{16h^4}{120}f^{(5)}(x) + O(h^6)\n$$\n为了消除 $O(h^2)$ 误差项，我们构造 $D_1$ 和 $D_2$ 的线性组合 $\\alpha D_1 + \\beta D_2$。为了使组合后的结果仍是 $f'(x)$ 的一致近似，我们要求 $\\alpha + \\beta = 1$。为了消除 $h^2$ 项，我们要求：\n$$\n\\alpha \\left(\\frac{h^2}{6}\\right) + \\beta \\left(\\frac{4h^2}{6}\\right) = 0 \\implies \\alpha + 4\\beta = 0\n$$\n解这个线性方程组：\n$$\n\\begin{cases} \\alpha + \\beta = 1 \\\\ \\alpha + 4\\beta = 0 \\end{cases}\n$$\n我们得到 $\\beta = -1/3$ 和 $\\alpha = 4/3$。因此，更高阶的近似是：\n$$\nf'(x) \\approx \\frac{4}{3}D_1 - \\frac{1}{3}D_2 = \\frac{4}{3} \\frac{f(x+h) - f(x-h)}{2h} - \\frac{1}{3} \\frac{f(x+2h) - f(x-2h)}{4h}\n$$\n整理后得到最终的四阶中心差分公式：\n$$\nf'(x) \\approx \\frac{-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)}{12h}\n$$\n该公式的截断误差为 $O(h^4)$。\n\n### 实现与分析\n\n我们将使用推导出的公式来计算函数 $f(x) = |x - 0.5|$ 在区间 $[0,1]$ 上的导数。对于测试套件中的每个网格尺寸 $n$，执行以下步骤：\n1. 构建一个包含 $n$ 个点的均匀网格，其中 $h = 1/(n-1)$ 且 $x_i = ih$，$i=0, \\dots, n-1$。\n2. 计算所有网格点上的函数值 $f(x_i)$ 及其精确导数 $f'(x_i) = \\text{sign}(x_i - 0.5)$。注意，在 $x_i = 0.5$ 处，精确导数未定义。\n3. 使用推导出的公式在所有内部点 $x_i$（其中 $i \\in [2, n-3]$）上计算近似值。\n4. 对于每个这样的点 $x_i$，如果 $x_i \\neq 0.5$，则计算近似导数和精确导数之间的绝对误差。\n5. 以 $x_i$ 为中心的模板被分类为“平滑区域”（如果 $x_{i+2} \\le 0.5$ 或 $x_{i-2} \\ge 0.5$）或“跨角点”（如果 $x_{i-2}  0.5  x_{i+2}$）。\n6. 收集三组误差：来自所有有效模板的误差、来自平滑区域模板的误差和来自跨角点模板的误差。\n7. 计算每组的最大绝对误差（$E_{\\text{all}}$、$E_{\\text{smooth}}$、$E_{\\text{cross}}$）。如果一个集合为空，其最大误差定义为 $0$。\n\n对测试套件 $\\{11, 12, 101, 102\\}$ 中的每个 $n$ 重复此过程。函数 $f(x)$ 是分段线性的，因此在任何不包含 $x=0.5$ 处角点的区域内，其所有高于一阶的导数均为零。因此，对于“平滑区域”模板，高阶误差项消失，我们期望该近似在浮点精度范围内是精确的。对于“跨角点”模板，光滑性假设被违反，导致一个量级为 $O(1)$ 的大误差，该误差不会随着 $h \\to 0$ 而减小，从而展示了精度的降阶现象。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and tests a high-order finite difference scheme on a function with a corner.\n    \"\"\"\n    # The problem specifies a test suite of grid sizes n.\n    test_cases = [11, 12, 101, 102]\n    \n    all_results = []\n\n    for n in test_cases:\n        # 1. Set up grid, function, and exact derivative\n        h = 1.0 / (n - 1)\n        x = np.linspace(0.0, 1.0, n)\n        \n        # Function f(x) = |x - 0.5|\n        f_x = np.abs(x - 0.5)\n        \n        # Exact derivative f'(x) = sign(x - 0.5)\n        # f'(x) = -1 for x  0.5, +1 for x > 0.5, undefined at x = 0.5\n        f_prime_exact = np.sign(x - 0.5)\n        \n        # Lists to store errors for different stencil types\n        errors_all = []\n        errors_smooth = []\n        errors_cross = []\n        \n        # 2. Loop over interior points where the 5-point stencil is valid\n        # The stencil at i uses points from i-2 to i+2.\n        # It's centered at x_i and defined for i from 2 to n-3.\n        # Python's range(start, stop) goes up to stop-1.\n        for i in range(2, n-2):\n            # Check edge case if i+2 is out of bounds due to loop definition\n            if i + 2 >= n:\n                continue\n\n            # The point where the derivative is being approximated\n            x_i = x[i]\n            \n            # Exclude the point x = 0.5 from any error metric, as f'(0.5) is undefined.\n            if np.isclose(x_i, 0.5):\n                continue\n                \n            # 3. Apply the fourth-order central difference formula\n            # f'(x) ≈ (-f(x+2h) + 8f(x+h) - 8f(x-h) + f(x-2h)) / (12h)\n            f_prime_approx = (\n                -f_x[i+2] + 8 * f_x[i+1] - 8 * f_x[i-1] + f_x[i-2]\n            ) / (12.0 * h)\n            \n            # 4. Calculate error\n            error = np.abs(f_prime_approx - f_prime_exact[i])\n            errors_all.append(error)\n            \n            # 5. Classify the stencil and categorize the error\n            x_stencil_min = x[i-2]\n            x_stencil_max = x[i+2]\n            \n            # Smooth-region stencil: entirely on one side of 0.5\n            if x_stencil_max = 0.5 or x_stencil_min >= 0.5:\n                errors_smooth.append(error)\n            # Corner-crossing stencil: straddles 0.5\n            elif x_stencil_min  0.5 and x_stencil_max > 0.5:\n                errors_cross.append(error)\n            # The classification is exhaustive for this problem's setup.\n\n        # 6. Compute the required error metrics (maximums)\n        # If a list is empty, the max error is 0.\n        E_all = max(errors_all) if errors_all else 0.0\n        E_smooth = max(errors_smooth) if errors_smooth else 0.0\n        E_cross = max(errors_cross) if errors_cross else 0.0\n        \n        all_results.append([E_all, E_smooth, E_cross])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists of floats.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n\n```"
        }
    ]
}