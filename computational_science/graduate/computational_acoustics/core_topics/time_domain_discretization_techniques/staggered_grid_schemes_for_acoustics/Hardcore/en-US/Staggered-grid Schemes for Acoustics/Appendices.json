{
    "hands_on_practices": [
        {
            "introduction": "Mastery of computational acoustics begins with building a solver from the ground up. This practice guides you through the process of implementing a three-dimensional finite-difference time-domain (FDTD) scheme on a staggered grid . By translating the first-order acoustic equations into explicit code, you will gain firsthand experience with the crucial details of leapfrog time-stepping, spatial staggering, and the implementation of boundary conditions using ghost cells.",
            "id": "4138270",
            "problem": "You are asked to construct and implement a three-dimensional staggered-grid explicit time-marching scheme for linear acoustics using a leapfrog update with ghost layers that enforce physically consistent boundary conditions. Start from a fundamental base and derive the discrete updates and explicit array index ranges. Then implement the derived indexing in a complete, runnable program that performs a single pair of updates on a small set of prescribed test cases, and outputs quantifiable results as specified.\n\nFundamental base for linear acoustics:\n- The linearized momentum equation: $$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p,$$ where $p$ is acoustic pressure, $\\mathbf{u} = (u_x,u_y,u_z)$ is acoustic particle velocity, and $\\rho$ is mass density.\n- The linearized continuity equation: $$\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u},$$ where $K$ is bulk modulus and $\\nabla\\cdot \\mathbf{u}$ is the divergence of velocity.\n\nStaggered-grid arrangement:\n- Pressure $p$ is stored at cell centers indexed by $(i,j,k)$.\n- Velocities are stored on faces:\n  - $u_x$ on faces normal to $x$ at indices $(i+\\tfrac{1}{2},j,k)$,\n  - $u_y$ on faces normal to $y$ at indices $(i,j+\\tfrac{1}{2},k)$,\n  - $u_z$ on faces normal to $z$ at indices $(i,j,k+\\tfrac{1}{2})$.\n- Uniform spacings $dx$, $dy$, $dz$ along $x$, $y$, $z$.\n\nTime staggering:\n- Pressure $p$ is evaluated at integer times $t^n$.\n- Velocity components are evaluated at half-integer times $t^{n\\pm 1/2}$.\n- The leapfrog updates are to be implemented as:\n  1. Update $\\mathbf{u}^{n+1/2}$ from $p^n$.\n  2. Update $p^{n+1}$ from $\\mathbf{u}^{n+1/2}$.\n\nGhost layers and boundary handling:\n- Use one ghost layer on every array dimension surrounding the interior domain for pressure and velocities. The ghost layers on $p$ must enforce homogeneous Neumann boundary conditions (zero normal derivative), i.e., copy interior values into ghost cells along each boundary so that the discrete normal gradient at boundaries is zero.\n- The ghost layers for velocity arrays should be allocated to support indexing and divergence operations; the normal velocity at physical boundaries must remain zero after the velocity update as a consequence of the Neumann boundary on pressure.\n\nDiscretization requirements:\n- Derive from the fundamental base the second-order centered, uniform-grid finite difference approximations for the gradient and divergence consistent with the staggered layout and time staggering. Carefully write the explicit index ranges for each velocity component and for pressure so that updates use only valid interior and ghost values.\n- Denote interior pressure indices as $i \\in \\{1,\\dots,N_x\\}$, $j \\in \\{1,\\dots,N_y\\}$, $k \\in \\{1,\\dots,N_z\\}$ for an interior grid of $N_x \\times N_y \\times N_z$ cells. Pressure arrays must include ghost layers at indices $i=0$ and $i=N_x+1$, $j=0$ and $j=N_y+1$, $k=0$ and $k=N_z+1$ to enforce the Neumann conditions.\n- Denote velocity face-index ranges consistent with the staggered positions and ghost layers so that differences align with pressure indices for divergence.\n\nProgram requirements:\n- Implement functions that:\n  1. Construct arrays for $p$, $u_x$, $u_y$, $u_z$ with ghost layers.\n  2. Initialize $p^n$ with a single-cell delta of amplitude $1$ at the interior center cell, and initialize $\\mathbf{u}^{n-1/2}$ to zero everywhere.\n  3. Fill pressure ghost layers to enforce homogeneous Neumann boundary conditions by copying adjacent interior cell values to the ghost cells.\n  4. Update $\\mathbf{u}^{n+1/2}$ from $p^n$ using the explicit staggered centered differences.\n  5. Update $p^{n+1}$ from $\\mathbf{u}^{n+1/2}$ using the explicit divergence centered differences.\n- Use $dt$ chosen for numerical stability as $$dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c},\\quad c=\\sqrt{\\frac{K}{\\rho}},$$ where $c$ is the speed of sound. This value is to be computed per test case.\n- Ensure all array updates use explicit indexing that honors ghost layers and does not access out-of-range indices.\n\nTest suite:\nFor each test case, construct arrays, perform one velocity update and one pressure update, and then compute the following three quantities:\n\n1. The maximum absolute boundary-normal velocity magnitude after the velocity update (in meters per second). This is the maximum over all physical boundary faces of $|u_x|$ at $i=0$ and $i=N_x$, $|u_y|$ at $j=0$ and $j=N_y$, and $|u_z|$ at $k=0$ and $k=N_z$.\n2. The integer count of interior face locations used in the pressure divergence where the magnitude of the updated velocity exceeds a tolerance of $10^{-14}$.\n3. The sum of the interior pressure values after the pressure update (in Pascals).\n\nTest cases to implement:\n- Case A: $N_x=1$, $N_y=1$, $N_z=1$, $dx=0.1$, $dy=0.1$, $dz=0.1$, $\\rho=1.2$, $K=1.4\\times 10^5$.\n- Case B: $N_x=3$, $N_y=2$, $N_z=1$, $dx=0.05$, $dy=0.1$, $dz=0.2$, $\\rho=1.2$, $K=1.01\\times 10^5$.\n- Case C: $N_x=4$, $N_y=3$, $N_z=2$, $dx=0.02$, $dy=0.03$, $dz=0.04$, $\\rho=1.2$, $K=1.5\\times 10^5$.\n\nFinal output format:\n- Your program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets. For the three test cases, aggregate the nine values in the order: boundary-normal velocity magnitude (in m/s), nonzero interior velocity count (integer), interior pressure sum (in Pa) for Case A, then the same triple for Case B, then Case C. For example: \"[vA,countA,sumA,vB,countB,sumB,vC,countC,sumC]\". All angles, if any, must be in radians, but no angles are used here. Ensure the units for velocities are meters per second and the units for pressure sums are Pascals. The counts are integers without units.",
            "solution": "The problem requires the derivation and implementation of a three-dimensional staggered-grid finite-difference time-domain (FDTD) scheme for the linearized acoustic equations. The solution will first be derived from fundamental principles, followed by an implementation that numerically solves the specified test cases.\n\n### 1. Problem Validation\nThe provided problem statement is a well-posed, scientifically grounded task in computational acoustics.\n- **Givens**:\n    - Momentum Equation: $\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p$\n    - Continuity Equation: $\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u}$\n    - Variables: acoustic pressure $p$, particle velocity $\\mathbf{u}=(u_x, u_y, u_z)$, mass density $\\rho$, bulk modulus $K$.\n    - Grid: Staggered, with $p$ at cell centers $(i,j,k)$, $u_x$ at $(i+\\tfrac{1}{2},j,k)$, $u_y$ at $(i,j+\\tfrac{1}{2},k)$, $u_z$ at $(i,j,k+\\tfrac{1}{2})$. Grid spacings are $dx, dy, dz$.\n    - Time Stepping: Leapfrog scheme, with $p$ at integer times $t^n$ and $\\mathbf{u}$ at half-integer times $t^{n \\pm 1/2}$.\n    - Boundary Conditions: Homogeneous Neumann for pressure $p$ ($\\frac{\\partial p}{\\partial n}=0$) enforced using one ghost layer.\n    - Domain: Interior grid of $N_x \\times N_y \\times N_z$ cells, with pressure indices $i \\in \\{1,\\dots,N_x\\}$, $j \\in \\{1,\\dots,N_y\\}$, $k \\in \\{1,\\dots,N_z\\}$.\n    - Initial Conditions: $p^n$ has a single-cell delta of amplitude $1$ at the interior center; $\\mathbf{u}^{n-1/2} = \\mathbf{0}$.\n    - Time Step: $dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c}$, with $c=\\sqrt{K/\\rho}$.\n    - Test Cases and Output Requirements are specified.\n\n- **Validation**: The problem is valid. It is based on the fundamental equations of linear acoustics and employs a standard, stable numerical method (staggered-grid FDTD). The setup is self-contained, with all necessary parameters and conditions provided. It does not violate any scientific principles and is objective and formalizable.\n\n### 2. Derivation of the Discrete Scheme\n\n#### 2.1. Time Discretization (Leapfrog)\nThe leapfrog scheme involves evaluating pressure and velocity at staggered time steps. The time derivatives are approximated by second-order centered finite differences:\n\n- For the velocity update from $t^{n-1/2}$ to $t^{n+1/2}$, centered at $t^n$:\n$$ \\frac{\\mathbf{u}^{n+1/2} - \\mathbf{u}^{n-1/2}}{\\Delta t} = -\\frac{1}{\\rho} (\\nabla p)^n $$\n- For the pressure update from $t^n$ to $t^{n+1}$, centered at $t^{n+1/2}$:\n$$ \\frac{p^{n+1} - p^n}{\\Delta t} = -K (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\nThese lead to the following update rules:\n$$ \\mathbf{u}^{n+1/2} = \\mathbf{u}^{n-1/2} - \\frac{\\Delta t}{\\rho} (\\nabla p)^n $$\n$$ p^{n+1} = p^n - K \\Delta t (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\n#### 2.2. Spatial Discretization (Staggered Grid)\nThe spatial derivatives (gradient $\\nabla$ and divergence $\\nabla \\cdot$) are also approximated by second-order centered finite differences, evaluated at the appropriate staggered locations.\n\n- **Velocity Update (Gradient of Pressure)**: The gradient of pressure, $\\nabla p$, is needed at the locations of the velocity components.\n    - For $u_x$ at $(i+\\tfrac{1}{2},j,k)$, the partial derivative $\\frac{\\partial p}{\\partial x}$ is approximated using pressure values at adjacent cell centers $(i,j,k)$ and $(i+1,j,k)$:\n    $$ \\left. \\frac{\\partial p}{\\partial x} \\right|_{(i+1/2,j,k)} \\approx \\frac{p(i+1,j,k) - p(i,j,k)}{dx} $$\n    The update for the $x$-component of velocity is:\n    $$ u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) = u_x^{n-1/2}(i+\\tfrac{1}{2},j,k) - \\frac{\\Delta t}{\\rho \\, dx} \\left( p^n(i+1,j,k) - p^n(i,j,k) \\right) $$\n    By analogy, the updates for $u_y$ and $u_z$ are:\n    $$ u_y^{n+1/2}(i,j+\\tfrac{1}{2},k) = u_y^{n-1/2}(i,j+\\tfrac{1}{2},k) - \\frac{\\Delta t}{\\rho \\, dy} \\left( p^n(i,j+1,k) - p^n(i,j,k) \\right) $$\n    $$ u_z^{n+1/2}(i,j,k+\\tfrac{1}{2}) = u_z^{n-1/2}(i,j,k+\\tfrac{1}{2}) - \\frac{\\Delta t}{\\rho \\, dz} \\left( p^n(i,j,k+1) - p^n(i,j,k) \\right) $$\n\n- **Pressure Update (Divergence of Velocity)**: The divergence of velocity, $\\nabla \\cdot \\mathbf{u}$, is needed at the pressure locations (cell centers, $(i,j,k)$).\n    $$ \\nabla \\cdot \\mathbf{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial u_z}{\\partial z} $$\n    Each term is approximated by a centered difference:\n    $$ \\left. \\frac{\\partial u_x}{\\partial x} \\right|_{(i,j,k)} \\approx \\frac{u_x(i+\\tfrac{1}{2},j,k) - u_x(i-\\tfrac{1}{2},j,k)}{dx} $$\n    $$ \\left. \\frac{\\partial u_y}{\\partial y} \\right|_{(i,j,k)} \\approx \\frac{u_y(i,j+\\tfrac{1}{2},k) - u_y(i,j-\\tfrac{1}{2},k)}{dy} $$\n    $$ \\left. \\frac{\\partial u_z}{\\partial z} \\right|_{(i,j,k)} \\approx \\frac{u_z(i,j,k+\\tfrac{1}{2}) - u_z(i,j,k-\\tfrac{1}{2})}{dz} $$\n    The pressure update is thus:\n    $$ p^{n+1}(i,j,k) = p^n(i,j,k) - K \\Delta t \\left( \\frac{u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) - u_x^{n+1/2}(i-\\tfrac{1}{2},j,k)}{dx} + \\dots \\right) $$\n\n#### 2.3. Array Indexing and Ghost Layers\nWe use NumPy arrays and map the grid indices to array indices. A single ghost layer is added to each dimension.\n- `p` array: size $(N_x+2, N_y+2, N_z+2)$. Interior indices are `1..Nx`, `1..Ny`, `1..Nz`. Ghost layers are at index `0` and `N_x+1` (and similarly for `y` and `z`). `p[i,j,k]` stores $p(i,j,k)$.\n- `ux` array: size $(N_x+1, N_y+2, N_z+2)$. `ux[i,j,k]` stores $u_x(i+\\tfrac{1}{2},j,k)$. `i` runs from `0` to $N_x$.\n- `uy` array: size $(N_x+2, N_y+1, N_z+2)$. `uy[i,j,k]` stores $u_y(i,j+\\tfrac{1}{2},k)$. `j` runs from `0` to $N_y$.\n- `uz` array: size $(N_x+2, N_y+2, N_z+1)$. `uz[i,j,k]` stores $u_z(i,j,k+\\tfrac{1}{2})$. `k` runs from `0` to $N_z$.\n\nWith this indexing, the updates can be expressed in vectorized form:\n- **Velocity Update**:\n  - `ux_np12 = ux_nm12 - (dt/rho) * (p_n[1:,:,:] - p_n[:-1,:,:]) / dx`\n  - `uy_np12 = uy_nm12 - (dt/rho) * (p_n[:,1:,:] - p_n[:,:-1,:]) / dy`\n  - `uz_np12 = uz_nm12 - (dt/rho) * (p_n[:,:,1:] - p_n[:,:,:-1]) / dz`\n- **Pressure Update** (for interior points `1..N_x`, `1..N_y`, `1..N_z`):\n  - `div_u_x = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx`\n  - `div_u_y = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy`\n  - `div_u_z = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz`\n  - `p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] = p_n[1:Nx+1, 1:Ny+1, 1:Nz+1] - K*dt*(div_u_x + div_u_y + div_u_z)`\n\n#### 2.4. Boundary Conditions and Analysis of Expected Results\n- **Homogeneous Neumann BC**: $\\frac{\\partial p}{\\partial n}=0$ is enforced by copying values from the first interior layer to the adjacent ghost layer. For example, `p[0,:,:] = p[1,:,:]` and `p[Nx+1,:,:] = p[Nx,:,:]`.\n- **Maximum Boundary-Normal Velocity**: The normal velocity at a physical boundary is determined by the pressure gradient across that boundary. For the boundary at $i=1/2$, the update for $u_x(1/2,j,k)$ (i.e., `ux[0,j,k]`) depends on $p(1,j,k) - p(0,j,k)$. The Neumann BC forces $p(0,j,k) = p(1,j,k)$, making the discrete gradient zero. Since the initial velocity is zero, the normal velocities at all physical boundaries must remain zero. Thus, this value is expected to be $0.0$.\n- **Count of Non-Zero Velocities**: The initial pressure $p^n$ is a single point delta function. The velocity update `u^{n+1/2}` will be non-zero only where the gradient of $p^n$ is non-zero. This occurs only on the faces immediately adjacent to the cell with the pressure pulse. For a central pulse not adjacent to a boundary, this yields $6$ non-zero velocity components ($2$ for each dimension). If the pulse is next to a boundary, the Neumann BC will nullify the gradient in that direction, reducing the count.\n    - Case A ($1 \\times 1 \\times 1$): The single cell is adjacent to boundaries in all directions. The count is $0$.\n    - Case B ($3 \\times 2 \\times 1$): Center is $(2,2,1)$. It is interior in $x$, but on the boundary of the interior domain in $y$ and $z$. The count is $2$ ($x$) + $1$ ($y$) + $0$ ($z$) = $3$.\n    - Case C ($4 \\times 3 \\times 2$): Center is $(3,2,2)$. It is interior in $x$ and $y$, but on the boundary in $z$. The count is $2$ ($x$) + $2$ ($y$) + $1$ ($z$) = $5$.\n- **Sum of Interior Pressure**: The FDTD scheme on a staggered grid with these boundary conditions conserves a discrete analogue of total acoustic mass, $\\int p \\, dV$. The sum of the divergence terms over the entire interior volume telescopes to a sum of normal velocities at the boundary. Since these are zero, the total change in the sum of pressure values is zero. Therefore, the sum of interior pressure after the update should equal the initial sum, which is $1.0$.\n\nThese theoretical predictions serve as a robust verification for the correctness of the implementation.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(Nx, Ny, Nz, dx, dy, dz, rho, K):\n    \"\"\"\n    Performs one full leapfrog update cycle for the 3D acoustic equations.\n    \"\"\"\n    # 1. Calculate derived parameters\n    c = np.sqrt(K / rho)\n    dt = 0.5 * min(dx, dy, dz) / c\n\n    # 2. Initialize arrays with ghost layers\n    p_shape = (Nx + 2, Ny + 2, Nz + 2)\n    ux_shape = (Nx + 1, Ny + 2, Nz + 2)\n    uy_shape = (Nx + 2, Ny + 1, Nz + 2)\n    uz_shape = (Nx + 2, Ny + 2, Nz + 1)\n\n    p_n = np.zeros(p_shape)\n    ux_nm12 = np.zeros(ux_shape)\n    uy_nm12 = np.zeros(uy_shape)\n    uz_nm12 = np.zeros(uz_shape)\n    \n    # Set initial pressure a delta function at the interior center\n    ic = Nx // 2 + 1\n    jc = Ny // 2 + 1\n    kc = Nz // 2 + 1\n    p_n[ic, jc, kc] = 1.0\n\n    # 3. Apply homogeneous Neumann boundary conditions on pressure\n    def apply_p_boundary_conditions(p):\n        p[0, :, :] = p[1, :, :]\n        p[Nx + 1, :, :] = p[Nx, :, :]\n        p[:, 0, :] = p[:, 1, :]\n        p[:, Ny + 1, :] = p[:, Ny, :]\n        p[:, :, 0] = p[:, :, 1]\n        p[:, :, Nz + 1] = p[:, :, Nz]\n        return p\n\n    p_n = apply_p_boundary_conditions(p_n)\n\n    # 4. Update velocity components to time n+1/2\n    ux_np12 = ux_nm12 - (dt / rho) * (p_n[1:, :, :] - p_n[:-1, :, :]) / dx\n    uy_np12 = uy_nm12 - (dt / rho) * (p_n[:, 1:, :] - p_n[:, :-1, :]) / dy\n    uz_np12 = uz_nm12 - (dt / rho) * (p_n[:, :, 1:] - p_n[:, :, :-1]) / dz\n\n    # 5. Update pressure to time n+1\n    p_np1 = np.copy(p_n)\n    \n    # Divergence terms are calculated over the volume that affects interior pressure cells\n    # The slices are constructed to produce a result of shape (Nx, Ny, Nz)\n    div_ux = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx\n    div_uy = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy\n    div_uz = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz\n\n    divergence = div_ux + div_uy + div_uz\n    \n    # Update only the interior pressure cells\n    p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] -= K * dt * divergence\n\n    # 6. Compute required output quantities\n    \n    # 6.1. Max absolute boundary-normal velocity\n    # Normal velocities are on faces at i=0, Nx; j=0, Ny; k=0, Nz\n    max_vx_boundary = np.max(np.abs(np.concatenate([ux_np12[0, :, :].ravel(), ux_np12[Nx, :, :].ravel()])))\n    max_vy_boundary = np.max(np.abs(np.concatenate([uy_np12[:, 0, :].ravel(), uy_np12[:, Ny, :].ravel()])))\n    max_vz_boundary = np.max(np.abs(np.concatenate([uz_np12[:, :, 0].ravel(), uz_np12[:, :, Nz].ravel()])))\n    \n    max_boundary_v = max(max_vx_boundary, max_vy_boundary, max_vz_boundary)\n\n    # 6.2. Count of interior face velocities exceeding tolerance\n    tol = 1e-14\n    \n    # Interior faces are those used in the divergence calculation for interior pressure points\n    # ux faces: i in [0,Nx], j in [1,Ny], k in [1,Nz]\n    # uy faces: i in [1,Nx], j in [0,Ny], k in [1,Nz]\n    # uz faces: i in [1,Nx], j in [1,Ny], k in [0,Nz]\n    \n    # Slicing corresponds to array indices. uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1] means\n    # indices i from 1 to Nx, j from 0 to Ny, k from 1 to Nz.\n    count_ux = np.sum(np.abs(ux_np12[0:Nx+1, 1:Ny+1, 1:Nz+1]) > tol)\n    count_uy = np.sum(np.abs(uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1]) > tol)\n    count_uz = np.sum(np.abs(uz_np12[1:Nx+1, 1:Ny+1, 0:Nz+1]) > tol)\n    \n    nonzero_v_count = int(count_ux + count_uy + count_uz)\n\n    # 6.3. Sum of interior pressure values after update\n    interior_p_sum = np.sum(p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1])\n\n    return max_boundary_v, nonzero_v_count, interior_p_sum\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'Nx': 1, 'Ny': 1, 'Nz': 1, 'dx': 0.1, 'dy': 0.1, 'dz': 0.1, 'rho': 1.2, 'K': 1.4e5},\n        # Case B\n        {'Nx': 3, 'Ny': 2, 'Nz': 1, 'dx': 0.05, 'dy': 0.1, 'dz': 0.2, 'rho': 1.2, 'K': 1.01e5},\n        # Case C\n        {'Nx': 4, 'Ny': 3, 'Nz': 2, 'dx': 0.02, 'dy': 0.03, 'dz': 0.04, 'rho': 1.2, 'K': 1.5e5},\n    ]\n\n    results = []\n    for case in test_cases:\n        v_bound, v_count, p_sum = run_simulation(**case)\n        results.extend([v_bound, v_count, p_sum])\n\n    # Format the final output string exactly as required.\n    # The output values are formatted to avoid excessive precision.\n    formatted_results = []\n    for i, res in enumerate(results):\n        if (i % 3) == 0:  # Boundary velocity\n            formatted_results.append(f\"{res:.1g}\")\n        elif (i % 3) == 1:  # Count\n            formatted_results.append(str(res))\n        else:  # Pressure sum\n            formatted_results.append(f\"{res:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        },
        {
            "introduction": "A numerical solver is only as good as its verification. This exercise moves from implementation to validation by simulating standing waves in a two-dimensional acoustic cavity and comparing the results to known analytical solutions . You will implement both rigid (Neumann) and pressure-release (Dirichlet) boundary conditions and use spectral analysis to extract the numerical eigenfrequencies, providing a powerful method to quantify the accuracy of your staggered-grid scheme.",
            "id": "4138364",
            "problem": "Consider the linearized first-order acoustic equations in two spatial dimensions for small perturbations about a quiescent fluid state, given by the system\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right), \\quad\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}, \\quad\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y},\n$$\nwhere $p$ is acoustic pressure, $v_x$ and $v_y$ are the components of acoustic particle velocity, $K$ is bulk modulus, and $\\rho_0$ is equilibrium density. Assume a rectangular cavity of dimensions $L_x$ by $L_y$ with walls that are either rigid or pressure-release. A rigid wall enforces $v_n=0$, i.e., zero normal velocity at the boundary, which corresponds to a homogeneous Neumann condition on $p$. A pressure-release wall enforces $p=0$ (Dirichlet condition). For a rectangular cavity, the continuous eigenfrequencies are\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\nwith $c$ the sound speed. For pressure-release walls, $m,n \\in \\mathbb{N}$, and for rigid walls, $m,n \\in \\mathbb{N}_0$ with the trivial case $m=n=0$ excluded.\n\nYou must implement an explicit two-dimensional staggered-grid scheme (pressure at cell centers and velocity components at cell faces) for this system. The discrete update must be derived from the above equations using finite differences consistent with the staggered arrangement:\n- Pressure $p[i,j]$ at cell centers located at positions $x_i = (i+\\tfrac{1}{2})\\Delta x$, $y_j = (j+\\tfrac{1}{2})\\Delta y$, for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y-1$.\n- Velocity $v_x[i,j]$ on vertical faces at $x = i \\Delta x$, $y = (j+\\tfrac{1}{2})\\Delta y$, for $i=0,\\dots,N_x$, $j=0,\\dots,N_y-1$.\n- Velocity $v_y[i,j]$ on horizontal faces at $x = (i+\\tfrac{1}{2})\\Delta x$, $y = j \\Delta y$, for $i=0,\\dots,N_x-1$, $j=0,\\dots,N_y$.\n\nUse a leapfrog-in-time approach where velocity is advanced from time $t^n$ to $t^{n+1/2}$ using pressure gradients, and pressure is advanced from $t^n$ to $t^{n+1}$ using the divergence of velocity at $t^{n+1/2}$. Boundary conditions must be enforced as follows:\n- For rigid walls, set the normal velocity components to zero on the domain boundary (i.e., $v_x[0,\\cdot]=0$, $v_x[N_x,\\cdot]=0$, $v_y[\\cdot,0]=0$, $v_y[\\cdot,N_y]=0$), and use symmetric ghost pressure values to produce zero-normal pressure gradients in the velocity update (i.e., $p_{\\text{ghost,left}}=p[0,\\cdot]$, $p_{\\text{ghost,right}}=p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=p[\\cdot,0]$, $p_{\\text{ghost,top}}=p[\\cdot,N_y-1]$).\n- For pressure-release walls, enforce $p=0$ at the wall via antisymmetric ghost pressure values (i.e., $p_{\\text{ghost,left}}=-p[0,\\cdot]$, $p_{\\text{ghost,right}}=-p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=-p[\\cdot,0]$, $p_{\\text{ghost,top}}=-p[\\cdot,N_y-1]$), and let velocity evolve freely.\n\nInitialize a standing wave by setting the initial pressure field to the appropriate continuous mode shape with unit amplitude and zero initial velocities:\n- For rigid walls (Neumann boundary condition), use $p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$.\n- For pressure-release walls (Dirichlet boundary condition), use $p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$.\n\nChoose the time step $\\Delta t$ from the Courant-Friedrichs-Lewy safety condition for the staggered scheme,\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}},\n$$\nwith $\\text{CFL} \\in (0,1)$. Simulate for a finite duration $T$ sufficient to resolve the dominant frequency of the standing wave. Extract the dominant discrete frequency $f_{\\text{FD}}$ from the pressure time history at a non-nodal interior point using a Discrete Fourier Transform and compute the relative error\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}},\n$$\nwhich must be reported as a dimensionless decimal (not using a percent symbol).\n\nImplement the above in a complete program and run the following test suite. Use consistent physical and numerical units: $L_x$ and $L_y$ in meters, $c$ in meters per second, $\\rho_0$ in kilograms per cubic meter, $\\Delta t$ in seconds, and $f$ in Hertz. The final outputs must be the relative errors $\\delta$ for each case, rounded to six decimal places.\n\nTest Suite:\n- Case $1$ (happy path, rigid walls): $L_x=1.2$ $\\mathrm{m}$, $L_y=0.8$ $\\mathrm{m}$, $N_x=64$, $N_y=48$, $m=1$, $n=0$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.95$, $T=0.25$ $\\mathrm{s}$.\n- Case $2$ (happy path, pressure-release walls): $L_x=1.2$ $\\mathrm{m}$, $L_y=0.8$ $\\mathrm{m}$, $N_x=64$, $N_y=48$, $m=1$, $n=1$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.95$, $T=0.25$ $\\mathrm{s}$.\n- Case $3$ (edge case: one zero index mode and near-CFL limit, rigid walls): $L_x=1.0$ $\\mathrm{m}$, $L_y=1.5$ $\\mathrm{m}$, $N_x=60$, $N_y=50$, $m=0$, $n=2$, $c=343$ $\\mathrm{m/s}$, $\\rho_0=1.21$ $\\mathrm{kg/m^3}$, $\\text{CFL}=0.99$, $T=0.30$ $\\mathrm{s}$.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[r_1,r_2,r_3]$) where $r_k$ are the three relative errors for the above cases, rounded to six decimal places.",
            "solution": "The user wants to solve the 2D linearized acoustic equations on a staggered grid using a finite-difference time-domain (FDTD) scheme and validate the numerical results against analytical eigenfrequencies. I have validated the problem statement and found it to be scientifically sound, well-posed, and complete. I will now provide the full solution.\n\n### **1. Governing Equations and Discretization**\n\nThe problem concerns the linearized first-order acoustic equations in two spatial dimensions:\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right)\n$$\n$$\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}\n$$\n$$\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y}\n$$\nHere, $p$ is the acoustic pressure, $\\vec{v} = (v_x, v_y)$ is the particle velocity, $K$ is the bulk modulus, and $\\rho_0$ is the equilibrium density of the fluid. The sound speed is given by $c = \\sqrt{K/\\rho_0}$.\n\nWe employ a staggered-grid finite-difference scheme. The pressure $p$ is defined at cell centers, while the velocity components $v_x$ and $v_y$ are defined on the cell faces normal to their respective directions. Let the domain of size $L_x \\times L_y$ be discretized into $N_x \\times N_y$ cells, with spatial step sizes $\\Delta x = L_x/N_x$ and $\\Delta y = L_y/N_y$. The discrete fields are denoted as:\n- $p_{i,j}^n \\approx p((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y, n\\Delta t)$\n- $v_{x, i,j}^{n+1/2} \\approx v_x(i\\Delta x, (j+\\frac{1}{2})\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n- $v_{y, i,j}^{n+1/2} \\approx v_y((i+\\frac{1}{2})\\Delta x, j\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n\nThe indices run $i=0, \\dots, N_x-1$ and $j=0, \\dots, N_y-1$ for pressure $p$. For velocities, the indices extend to the domain boundaries: $i=0, \\dots, N_x$ for $v_x$, and $j=0, \\dots, N_y$ for $v_y$.\n\nA leapfrog time-stepping scheme is used, where pressure is evaluated at integer time steps $n\\Delta t$ and velocities at half-integer time steps $(n+\\frac{1}{2})\\Delta t$. The partial derivatives are approximated using second-order central differences, which are naturally staggered in both space and time:\n\nThe velocity update equations are derived from the momentum equations:\n$$\nv_{x, i,j}^{n+1/2} = v_{x, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{i,j}^n - p_{i-1,j}^n)\n$$\n$$\nv_{y, i,j}^{n+1/2} = v_{y, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta y} (p_{i,j}^n - p_{i,j-1}^n)\n$$\n\nThe pressure update equation is derived from the continuity equation:\n$$\np_{i,j}^{n+1} = p_{i,j}^n - K \\Delta t \\left( \\frac{v_{x, i+1,j}^{n+1/2} - v_{x, i,j}^{n+1/2}}{\\Delta x} + \\frac{v_{y, i,j+1}^{n+1/2} - v_{y, i,j}^{n+1/2}}{\\Delta y} \\right)\n$$\nThese equations form the core of the FDTD simulation loop.\n\n### **2. Initial and Boundary Conditions**\n\n**Initial Conditions**: The simulation is initialized with a standing wave pattern for pressure, corresponding to a specific mode $(m, n)$, and zero initial velocity. For the leapfrog scheme, we set $p^0$ according to the specified functions and assume the velocities at time $t=-\\Delta t/2$ are zero.\n- For rigid walls (Neumann BCs): $p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$. The discrete pressure field $p_{i,j}^0$ is initialized by evaluating this function at the pressure grid coordinates $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$.\n- For pressure-release walls (Dirichlet BCs): $p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$.\n\n**Boundary Conditions**:\n- **Rigid Walls**: This condition imposes zero normal velocity ($v_n=0$) at the boundaries, which corresponds to a homogeneous Neumann condition on pressure ($\\partial p/\\partial n = 0$). In the discrete scheme, this is enforced by explicitly setting the normal velocity components on the boundary grid points to zero at every time step:\n$v_{x,0,j} = 0$, $v_{x,N_x,j} = 0$, $v_{y,i,0} = 0$, and $v_{y,i,N_y} = 0$. This method correctly models a zero pressure gradient at the wall within the FDTD framework.\n\n- **Pressure-Release Walls**: This condition imposes zero pressure ($p=0$) at the boundaries. This is a Dirichlet condition. We implement it using anti-symmetric ghost pressure values just outside the domain. For example, to update the velocity $v_{x,0,j}$ at the left boundary ($x=0$), the required pressure gradient involves a ghost pressure value $p_{-1,j}$. We set this ghost value to $p_{-1,j} = -p_{0,j}$. This effectively models the $p=0$ condition to second-order accuracy. The velocity update at the four boundaries becomes:\n$$\nv_{x, 0,j}^{n+1/2} = v_{x, 0,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{0,j}^n - (-p_{0,j}^n)) = v_{x, 0,j}^{n-1/2} - \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{0,j}^n\n$$\n$$\nv_{x, N_x,j}^{n+1/2} = v_{x, N_x,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} ((-p_{N_x-1,j}^n) - p_{N_x-1,j}^n) = v_{x, N_x,j}^{n-1/2} + \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{N_x-1,j}^n\n$$\nAnalogous updates apply to $v_{y,i,0}$ and $v_{y,i,N_y}$.\n\n### **3. Stability, Frequency Analysis, and Error Calculation**\n\n**Stability**: The explicit FDTD scheme is conditionally stable. The time step $\\Delta t$ must satisfy the Courant-Friedrichs-Lewy (CFL) condition. For the 2D staggered grid, this is:\n$$\n\\Delta t \\le \\frac{1}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\nWe use a safety factor $\\text{CFL} < 1$ to set the time step:\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\n\n**Frequency Analysis**: The simulation is run for a total time $T$. The pressure at a fixed, non-nodal interior point is recorded at each time step, forming a discrete time signal. A Discrete Fourier Transform (DFT) is then applied to this signal using a Fast Fourier Transform (FFT) algorithm. The frequency corresponding to the largest-magnitude component (excluding the DC component) is identified as the dominant discrete frequency, $f_{\\text{FD}}$.\n\n**Error Calculation**: The numerical dispersion of the grid causes the numerical frequency $f_{\\text{FD}}$ to deviate from the analytical eigenfrequency $f_{m,n}$ for the continuous system. We quantify this deviation using the relative error $\\delta$:\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}}\n$$\nwhere the analytical frequency is given by\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\nThe value of $\\delta$ serves as a measure of the accuracy of the FDTD simulation for the given discretization.",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (happy path, rigid walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 0, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'rigid'},\n        # Case 2: (happy path, pressure-release walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 1, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'pressure-release'},\n        # Case 3: (edge case: one zero index mode and near-CFL limit, rigid walls)\n        {'Lx': 1.0, 'Ly': 1.5, 'Nx': 60, 'Ny': 50, 'm': 0, 'n': 2, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.99, 'T': 0.30, 'bc_type': 'rigid'}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_fdtd_simulation(**case)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_fdtd_simulation(Lx, Ly, Nx, Ny, m, n, c, rho0, CFL, T, bc_type):\n    \"\"\"\n    Performs a 2D acoustic FDTD simulation for a single test case.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = Lx / Nx\n    dy = Ly / Ny\n    K = c**2 * rho0  # Bulk modulus\n\n    # Stability condition (CFL)\n    dt = CFL / (c * np.sqrt(1/dx**2 + 1/dy**2))\n    n_steps = int(T / dt)\n\n    # 2. Field Initialization\n    p = np.zeros((Nx, Ny))\n    vx = np.zeros((Nx + 1, Ny))\n    vy = np.zeros((Nx, Ny + 1))\n    \n    # Pressure grid coordinates (cell centers)\n    p_x_coords = (np.arange(Nx) + 0.5) * dx\n    p_y_coords = (np.arange(Ny) + 0.5) * dy\n    xx, yy = np.meshgrid(p_x_coords, p_y_coords, indexing='ij')\n\n    # Initial pressure field\n    if bc_type == 'rigid':\n        p = np.cos(m * np.pi * xx / Lx) * np.cos(n * np.pi * yy / Ly)\n    elif bc_type == 'pressure-release':\n        # For pressure-release, m and n must be >= 1. The problem ensures this.\n        p = np.sin(m * np.pi * xx / Lx) * np.sin(n * np.pi * yy / Ly)\n\n    # 3. Main FDTD Loop\n    pressure_history = np.zeros(n_steps)\n    probe_x, probe_y = Nx // 3, Ny // 3 # A non-nodal point for all cases\n    \n    # Update coefficients\n    C_vx = dt / (rho0 * dx)\n    C_vy = dt / (rho0 * dy)\n    C_px = K * dt / dx\n    C_py = K * dt / dy\n\n    for t_step in range(n_steps):\n        # --- (1) Update Velocity Fields (from n-1/2 to n+1/2) ---\n        # Interior points\n        vx[1:Nx, :] -= C_vx * (p[1:Nx, :] - p[0:Nx-1, :])\n        vy[:, 1:Ny] -= C_vy * (p[:, 1:Ny] - p[:, 0:Ny-1])\n        \n        # --- (2) Apply Velocity Boundary Conditions ---\n        if bc_type == 'rigid':\n            vx[0, :] = 0.0\n            vx[Nx, :] = 0.0\n            vy[:, 0] = 0.0\n            vy[:, Ny] = 0.0\n        elif bc_type == 'pressure-release':\n            # Use anti-symmetric ghost cells for p to update boundary velocities\n            vx[0, :] -= 2.0 * C_vx * p[0, :]\n            vx[Nx, :] += 2.0 * C_vx * p[Nx-1, :]\n            vy[:, 0] -= 2.0 * C_vy * p[:, 0]\n            vy[:, Ny] += 2.0 * C_vy * p[:, Ny-1]\n\n        # --- (3) Update Pressure Field (from n to n+1) ---\n        p[:, :] -= C_px * (vx[1:Nx+1, :] - vx[0:Nx, :])\n        p[:, :] -= C_py * (vy[:, 1:Ny+1] - vy[:, 0:Ny])\n\n        # --- (4) Store pressure at probe location ---\n        pressure_history[t_step] = p[probe_x, probe_y]\n\n    # 4. Frequency Analysis\n    # Analytical frequency\n    # For rigid BCs, m,n=0,0 is excluded. For p-release, m,n>=1.\n    if (m == 0 and n == 0):\n        f_mn = 0.0\n    else:\n        f_mn = (c / 2.0) * np.sqrt((m / Lx)**2 + (n / Ly)**2)\n\n    # Numerical frequency from FFT\n    fft_result = np.fft.fft(pressure_history)\n    fft_freqs = np.fft.fftfreq(n_steps, d=dt)\n    \n    # Find peak frequency in the positive spectrum\n    positive_freq_mask = fft_freqs > 0\n    if not np.any(positive_freq_mask):\n        return np.nan # Avoid error if no positive frequencies (e.g., T is too short)\n        \n    peak_idx = np.argmax(np.abs(fft_result[positive_freq_mask]))\n    f_fd = fft_freqs[positive_freq_mask][peak_idx]\n\n    # 5. Calculate Relative Error\n    if f_mn == 0:\n        # Avoid division by zero if analytical frequency is zero.\n        # This case should not be hit with the provided test suite.\n        return np.abs(f_fd)\n    \n    relative_error = np.abs(f_fd - f_mn) / f_mn\n    \n    return relative_error\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "Real-world acoustic problems often involve multiple materials with different properties. This practice addresses the challenge of modeling wave phenomena in heterogeneous media, focusing on the critical step of defining material coefficients at interfaces on a staggered grid . By deriving the effective interface coefficient from first principles of flux continuity, you will understand how to ensure your numerical scheme remains physically consistent even when properties like density $\\rho(x)$ are discontinuous.",
            "id": "4138369",
            "problem": "Consider the one-dimensional, first-order, linear acoustic system with heterogeneous material properties in the spatial variable $x$. Let the pressure field be $p(x,t)$ and the particle velocity field be $u(x,t)$. The governing equations (in the absence of sources) are the momentum equation and the compressibility equation: $$\\frac{\\partial u}{\\partial t} = -\\frac{1}{\\rho(x)}\\frac{\\partial p}{\\partial x}, \\qquad \\frac{\\partial p}{\\partial t} = -K(x)\\frac{\\partial u}{\\partial x},$$ where $\\rho(x)$ is the mass density in $\\mathrm{kg}\\,\\mathrm{m}^{-3}$ and $K(x)$ is the bulk modulus in $\\mathrm{Pa}$, both possibly discontinuous in space. In a standard staggered-grid finite-difference time-domain arrangement for acoustics, pressure $p$ is stored at cell centers and velocity $u$ is stored at cell faces. Consequently, the coefficient $1/\\rho(x)$ must be represented at faces to multiply the discrete pressure gradient and produce a face-centered velocity update. When $\\rho(x)$ is heterogeneous and discontinuous, this requires an interface treatment that is numerically consistent with the continuum physics.\n\nStarting from first principles, namely the governing equations above and the requirement that a face flux be consistent with integrating the coefficient over the path of the discrete gradient, derive the analytical expectation for the face-centered flux when $p(x)$ has a constant spatial gradient. Specifically, for a uniform grid with spacing $\\Delta x$ and a face located midway between two adjacent cell centers, assume $\\rho(x)$ is piecewise constant in each half-cell (taking the left cell value in the left half and the right cell value in the right half). Let $k(x) = 1/\\rho(x)$. Consider the face update under a static configuration with $p(x,t) = a x + b$ for constants $a$ and $b$, so that the continuous and discrete pressure gradients both equal $a$ in $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$. The physically consistent face flux (with units of $\\mathrm{m}\\,\\mathrm{s}^{-2}$) is obtained by combining the two half-cell segments in series, yielding an effective interface coefficient derived from integrating $1/k(x)$ over the path of the discrete gradient across the face.\n\nYour task is to implement a program that, for a set of prescribed test cases, computes the discrete face flux using the staggered-grid placement (face-centered $1/\\rho$ obtained from adjacent cell-centered values) and compares it to the analytical expectation derived by the series combination of the two half-cell segments. Use the following test suite, where each test defines material properties and a constant pressure gradient. All fluxes must be interpreted and compared in $\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n\n- Test A (happy path, strong contrast): Left density $\\rho_L = $ $1.21$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, right density $\\rho_R = $ $1000.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, grid spacing $\\Delta x = $ $0.01$ $\\mathrm{m}$, gradient $a = $ $2.0$ $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$.\n- Test B (moderate contrast): Left density $\\rho_L = $ $2.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, right density $\\rho_R = $ $8.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, grid spacing $\\Delta x = $ $0.1$ $\\mathrm{m}$, gradient $a = $ $3.0$ $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$.\n- Test C (extreme contrast, near-rigid right): Left density $\\rho_L = $ $1.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, right density $\\rho_R = $ $10^{9}$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, grid spacing $\\Delta x = $ $1.0$ $\\mathrm{m}$, gradient $a = $ $5.0$ $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$.\n- Test D (zero gradient boundary case): Left density $\\rho_L = $ $3.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, right density $\\rho_R = $ $7.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, grid spacing $\\Delta x = $ $0.2$ $\\mathrm{m}$, gradient $a = $ $0.0$ $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$.\n- Test E (placement verification across two faces in a three-cell block): Densities $\\rho_1 = $ $2.5$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_2 = $ $5.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, $\\rho_3 = $ $10.0$ $\\mathrm{kg}\\,\\mathrm{m}^{-3}$, grid spacing $\\Delta x = $ $0.05$ $\\mathrm{m}$, gradient $a = $ $1.0$ $\\mathrm{Pa}\\,\\mathrm{m}^{-1}$. This test evaluates two faces: the flux at the face between cells $1$ and $2$, and the flux at the face between cells $2$ and $3$, each compared against the analytical expectation derived from the adjacent pair.\n\nIn all tests, compute the discrete face flux by using the staggered-grid placement at the face and an appropriate average of the heterogeneous coefficients consistent with the continuum derivation. For each test, return a boolean indicating whether the discrete flux matches the analytical expectation within a tolerance of $\\varepsilon = $ $10^{-12}$ in absolute difference. For Test E, return two booleans, one per face.\n\nYour program should produce a single line of output containing the results as a comma-separated list enclosed in square brackets (e.g., $[result_1,result_2,\\dots]$), where each $result_i$ is a boolean value. The list must aggregate the results for Tests A through D and the two face checks in Test E, in that order, for a total of $6$ boolean entries.",
            "solution": "The problem requires the derivation and comparison of the face-centered flux term in a staggered-grid discretization of the 1D linear acoustic momentum equation with heterogeneous density $\\rho(x)$. The governing equation is:\n$$ \\frac{\\partial u}{\\partial t} = -\\frac{1}{\\rho(x)}\\frac{\\partial p}{\\partial x} $$\nHere, $u(x,t)$ is the particle velocity, $p(x,t)$ is the pressure, and $\\rho(x)$ is the spatially varying mass density. On a standard staggered grid, pressure $p$ is located at cell centers, $x_i = i \\Delta x$, while velocity $u$ is at cell faces, $x_{i+1/2} = (i+1/2)\\Delta x$. The discrete form of the momentum equation for the velocity update at face $x_{i+1/2}$ is:\n$$ \\frac{\\partial u_{i+1/2}}{\\partial t} = -k_{i+1/2} \\left( \\frac{p_{i+1} - p_i}{\\Delta x} \\right) $$\nwhere $k_{i+1/2}$ is the effective value of the coefficient $k(x) = 1/\\rho(x)$ at the face, and $p_i$ and $p_{i+1}$ are the pressures at the adjacent cell centers $x_i$ and $x_{i+1}$, respectively. The term $\\frac{\\partial u_{i+1/2}}{\\partial t}$ represents the face flux whose units are $\\mathrm{m}\\,\\mathrm{s}^{-2}$.\n\nThe problem specifies a static pressure field $p(x) = ax + b$, for which the continuous pressure gradient $\\frac{\\partial p}{\\partial x}$ is the constant $a$. The corresponding discrete gradient is also $a$:\n$$ \\frac{p_{i+1} - p_i}{\\Delta x} = \\frac{p(x_{i+1}) - p(x_i)}{x_{i+1} - x_i} = \\frac{(ax_{i+1} + b) - (ax_i + b)}{x_{i+1} - x_i} = \\frac{a(x_{i+1} - x_i)}{x_{i+1} - x_i} = a $$\nThus, the discrete momentum equation simplifies to:\n$$ \\frac{\\partial u_{i+1/2}}{\\partial t} = -k_{i+1/2} \\cdot a $$\nThe central task is to find the physically consistent expression for the effective coefficient $k_{i+1/2}$ when the density is piecewise constant, taking value $\\rho_L$ in the cell to the left of the face and $\\rho_R$ in the cell to the right. The material is modeled as $\\rho(x) = \\rho_L$ for $x \\in [x_i, x_{i+1/2})$ and $\\rho(x) = \\rho_R$ for $x \\in [x_{i+1/2}, x_{i+1}]$.\n\nTo derive $k_{i+1/2}$, we invoke first principles. We rewrite the momentum equation as $\\frac{\\partial p}{\\partial x} = -\\rho(x) \\frac{\\partial u}{\\partial t}$. At the interface, physical continuity requires the flux term $\\frac{\\partial u}{\\partial t}$ to be constant. Let's denote this constant flux by $J$. The equation becomes $\\frac{dp}{dx} = -\\rho(x) J$. To connect the pressures at the adjacent cell centers, we integrate this expression over the interval $[x_i, x_{i+1}]$:\n$$ p(x_{i+1}) - p(x_i) = \\int_{x_i}^{x_{i+1}} \\frac{dp}{dx} \\, dx = - J \\int_{x_i}^{x_{i+1}} \\rho(x) \\, dx $$\nThe integral of the piecewise constant density is:\n$$ \\int_{x_i}^{x_{i+1}} \\rho(x) \\, dx = \\int_{x_i}^{x_{i+1/2}} \\rho_L \\, dx + \\int_{x_{i+1/2}}^{x_{i+1}} \\rho_R \\, dx = \\rho_L \\left(\\frac{\\Delta x}{2}\\right) + \\rho_R \\left(\\frac{\\Delta x}{2}\\right) = \\frac{\\rho_L + \\rho_R}{2} \\Delta x $$\nSubstituting this result into the integrated pressure equation gives:\n$$ p_{i+1} - p_i = -J \\left( \\frac{\\rho_L + \\rho_R}{2} \\right) \\Delta x $$\nSolving for the flux $J = \\frac{\\partial u_{i+1/2}}{\\partial t}$ yields the \"analytical expectation\" for the flux:\n$$ J = -\\left( \\frac{p_{i+1} - p_i}{\\Delta x} \\right) \\frac{1}{\\frac{\\rho_L + \\rho_R}{2}} = -a \\cdot \\frac{2}{\\rho_L + \\rho_R} $$\nThis derivation is equivalent to treating the two half-cell segments as flow impedances in series, where the impedance is proportional to density.\n\nThe \"discrete face flux\" is computed from the formula $\\frac{\\partial u_{i+1/2}}{\\partial t} = -k_{i+1/2} \\cdot a$. The \"appropriate average consistent with the continuum derivation\" requires us to identify $k_{i+1/2}$ by comparing this formula with the analytical expression for $J$. This comparison immediately yields:\n$$ k_{i+1/2} = \\frac{2}{\\rho_L + \\rho_R} $$\nThis shows that the effective coefficient $k_{i+1/2}$ is the reciprocal of the arithmetic mean of the adjacent densities. The effective density at the interface is $\\rho_{eff} = (\\rho_L + \\rho_R)/2$.\n\nTherefore, the discrete flux is computed as:\n$$ F_{discrete} = -k_{i+1/2} \\cdot a = - \\frac{2a}{\\rho_L + \\rho_R} $$\nThe analytical expectation for the flux is:\n$$ F_{analytical} = - \\frac{2a}{\\rho_L + \\rho_R} $$\nThe problem asks for a comparison between these two quantities. As they are derived from the same physical principle, they are represented by the identical mathematical expression. Thus, their calculated values will be equal, and the comparison $|F_{discrete} - F_{analytical}| \\le \\varepsilon$ for $\\varepsilon = 10^{-12}$ will always evaluate to true, assuming no floating-point representation errors interfere. The program will implement this formula for each test case and perform the self-consistency check.\n\nFor a given test case with left density $\\rho_L$, right density $\\rho_R$, and pressure gradient $a$, the flux is calculated as $F = -2a / (\\rho_L + \\rho_R)$. The comparison `abs(F - F) <= 1e-12` is trivially true. This procedure is applied to all specified test cases. For Test E, the calculation is performed twice: once for the face between cells $1$ and $2$ ($\\rho_L=\\rho_1, \\rho_R=\\rho_2$), and once for the face between cells $2$ and $3$ ($\\rho_L=\\rho_2, \\rho_R=\\rho_3$).",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing discrete and analytical acoustic flux\n    at a material interface on a staggered grid.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Format: (rho_L, rho_R, a) for Tests A-D\n    # For Test E, it's ((rho_1, rho_2, rho_3), a)\n    test_cases = [\n        # Test A: Happy path, strong contrast\n        {'type': 'single_face', 'rho_L': 1.21, 'rho_R': 1000.0, 'a': 2.0, 'label': 'A'},\n        # Test B: Moderate contrast\n        {'type': 'single_face', 'rho_L': 2.0, 'rho_R': 8.0, 'a': 3.0, 'label': 'B'},\n        # Test C: Extreme contrast, near-rigid right\n        {'type': 'single_face', 'rho_L': 1.0, 'rho_R': 1e9, 'a': 5.0, 'label': 'C'},\n        # Test D: Zero gradient boundary case\n        {'type': 'single_face', 'rho_L': 3.0, 'rho_R': 7.0, 'a': 0.0, 'label': 'D'},\n        # Test E: Two faces in a three-cell block\n        {'type': 'multi_face', 'rhos': [2.5, 5.0, 10.0], 'a': 1.0, 'label': 'E'},\n    ]\n\n    tolerance = 1e-12\n    results = []\n\n    def calculate_flux(rho_L, rho_R, a):\n        \"\"\"\n        Calculates the face flux based on the derived formula.\n        \n        The formula for the flux (du/dt) is -k_eff * a, where k_eff is the\n        effective coefficient at the face. Based on first principles (continuity\n        of flux), the effective density is the arithmetic mean of the neighboring\n        densities: rho_eff = (rho_L + rho_R) / 2.\n        Therefore, k_eff = 1 / rho_eff = 2 / (rho_L + rho_R).\n        The flux is then -2 * a / (rho_L + rho_R).\n        \"\"\"\n        if rho_L + rho_R == 0:\n            # Avoid division by zero, although not expected with physical densities.\n            return 0.0 if a == 0 else np.inf\n        \n        flux = -2.0 * a / (rho_L + rho_R)\n        return flux\n\n    for case in test_cases:\n        if case['type'] == 'single_face':\n            rho_L = case['rho_L']\n            rho_R = case['rho_R']\n            a = case['a']\n            \n            # The problem asks to compare the \"discrete flux\" with the \"analytical\n            # expectation\". As derived from first principles, both are calculated\n            # using the same formula.\n            discrete_flux = calculate_flux(rho_L, rho_R, a)\n            analytical_flux = calculate_flux(rho_L, rho_R, a)\n            \n            match = abs(discrete_flux - analytical_flux) = tolerance\n            results.append(match)\n            \n        elif case['type'] == 'multi_face':\n            rhos = case['rhos']\n            a = case['a']\n            \n            # Face 1: between cell 1 and cell 2\n            rho_L1, rho_R1 = rhos[0], rhos[1]\n            discrete_flux1 = calculate_flux(rho_L1, rho_R1, a)\n            analytical_flux1 = calculate_flux(rho_L1, rho_R1, a)\n            match1 = abs(discrete_flux1 - analytical_flux1) = tolerance\n            results.append(match1)\n            \n            # Face 2: between cell 2 and cell 3\n            rho_L2, rho_R2 = rhos[1], rhos[2]\n            discrete_flux2 = calculate_flux(rho_L2, rho_R2, a)\n            analytical_flux2 = calculate_flux(rho_L2, rho_R2, a)\n            match2 = abs(discrete_flux2 - analytical_flux2) = tolerance\n            results.append(match2)\n\n    # Final print statement in the exact required format.\n    # Note: str(True) -> \"True\", str(False) -> \"False\". The problem example\n    # shows boolean values, but doesn't specify case. Python's default is fine.\n    # The example [result_1, result_2] might imply a non-string representation\n    # in the list, but the output format requires string joining anyway.\n    # Let's output lowercase \"true\"/\"false\" to be safe.\n    print(f\"[{','.join(str(r).lower() for r in results)}]\")\n\nsolve()\n```"
        }
    ]
}