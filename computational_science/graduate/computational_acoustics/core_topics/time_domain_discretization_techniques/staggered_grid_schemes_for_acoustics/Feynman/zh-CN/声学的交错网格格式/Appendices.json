{
    "hands_on_practices": [
        {
            "introduction": "在投入复杂的物理模拟之前，验证我们数值方法的基本构建模块至关重要。本实践旨在通过执行收敛性分析，来检验离散算子的准确性。通过在周期性一维声学问题中计算交错网格有限差分算子的观测收敛阶 ()，您将验证这些算子是否能以理论预期的精度逼近其连续的对应物，从而为更复杂的模拟建立坚实的基础。",
            "id": "4138382",
            "problem": "考虑一个长度为 $L$ 的周期性域上的一维线性声学一阶形式，写作耦合系统\n$$\n\\partial_t p(x,t) + \\kappa \\,\\partial_x u(x,t) = 0,\\qquad\n\\partial_t u(x,t) + \\frac{1}{\\rho}\\,\\partial_x p(x,t) = 0,\n$$\n其中 $p$ 是声压，$u$ 是质点速度，$\\rho$ 是密度，$\\kappa$ 是体积模量，均为严格正常数。空间域为 $\\Omega = [0,L]$，具有周期性边界条件。我们旨在均匀交错网格上定义离散范数和半范数，并计算在网格细化下空间导数的交错有限差分近似的观测收敛率。\n\n在 $\\Omega$ 上定义一个具有 $N$ 个单元的均匀交错网格，网格间距为 $h = L/N$，单元中心位于 $x_i = (i+\\tfrac{1}{2})h$（其中 $i \\in \\{0,1,\\dots,N-1\\}$），单元面位于 $x_{i+\\tfrac{1}{2}} = ih$（其中 $i \\in \\{0,1,\\dots,N-1\\}$）；为施加周期性，将索引作模 $N$ 处理。设定义在中心上的离散标量场表示为 $\\{v_i\\}_{i=0}^{N-1}$，定义在面上的离散标量场表示为 $\\{w_{i+\\tfrac{1}{2}}\\}_{i=0}^{N-1}$。\n\n1. 定义在单元中心和单元面上的离散内积和 $\\mathsf{L}^2$ 范数如下：\n$$\n\\langle v, \\tilde v\\rangle_{h,c} = \\sum_{i=0}^{N-1} h\\, v_i \\tilde v_i,\\quad \\|v\\|_{h,c} = \\sqrt{\\langle v, v\\rangle_{h,c}},\\qquad\n\\langle w, \\tilde w\\rangle_{h,f} = \\sum_{i=0}^{N-1} h\\, w_{i+\\tfrac{1}{2}} \\tilde w_{i+\\tfrac{1}{2}},\\quad \\|w\\|_{h,f} = \\sqrt{\\langle w, w\\rangle_{h,f}}.\n$$\n\n2. 定义具有周期性环绕的交错向前和向后差分算子，\n$$\n(D^+ v)_{i+\\tfrac{1}{2}} = \\frac{v_i - v_{i-1}}{h},\\qquad (D^- w)_i = \\frac{w_{i+\\tfrac{1}{2}} - w_{i-\\tfrac{1}{2}}}{h},\n$$\n对于 $i \\in \\{0,1,\\dots,N-1\\}$，其中索引作模 $N$ 处理。它们分别近似了在面上的 $\\partial_x v$ 和在中心上的 $\\partial_x w$。\n\n3. 在交错网格上定义类 $\\mathsf{H}^1$ 半范数如下：\n$$\n|v|_{h,c,1} = \\|D^+ v\\|_{h,f},\\qquad |w|_{h,f,1} = \\|D^- w\\|_{h,c}.\n$$\n\n4. 定义在交错网格上采样的声学状态 $(p,u)$（$p$ 在中心，$u$ 在面）的基于能量的离散范数如下：\n$$\n\\|(p,u)\\|_{E,h} = \\sqrt{ \\frac{1}{2} \\sum_{i=0}^{N-1} h\\left( \\frac{1}{\\kappa} p_i^2 + \\rho\\, u_{i+\\tfrac{1}{2}}^2 \\right)}.\n$$\n这是连续声能范数的离散模拟。下面要求的输出无需物理单位，因为报告的量是无量纲的收敛率。\n\n设 $L = 2\\pi$。对于 $2\\pi$ 周期的光滑测试函数 $\\phi$ 和 $u$，通过 $v_i = \\phi(x_i)$、$w_{i+\\tfrac{1}{2}} = u(x_{i+\\tfrac{1}{2}})$ 定义在中心和面上的逐点采样，并用 $\\partial_x \\phi$ 和 $\\partial_x u$ 表示精确空间导数。对于在一个选定的离散范数 $\\|\\cdot\\|_h$ 中测量的算子近似误差 $e_h$，将在网格尺寸 $h$ 和 $h/2$ 之间的基于细化的观测收敛率定义为\n$$\nr = \\frac{\\log\\left(\\|e_h\\|_h / \\|e_{h/2}\\|_{h/2}\\right)}{\\log(2)}.\n$$\n\n您的程序必须实现这些定义，并为以下测试套件计算观测收敛率。对于每个测试，分别使用具有 $N_0$、$2N_0$ 和 $4N_0$ 个单元的连续细化的三个网格。对于每个测试，报告在两个最精细级别之间计算的单个观测率，即 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 1 (交错梯度的能量加权误差)：设 $\\rho = 1.3$，$\\kappa = 2.6$，$\\phi(x) = \\exp(\\sin x)$。对于每个网格，从中心采样计算面上的 $D^+\\phi$ 和面上的精确 $\\partial_x \\phi$。构造一个对 $(p,u)$，其中 $p \\equiv 0$ 在中心上，而 $u$ 等于面上的误差 $D^+\\phi - \\partial_x \\phi$。计算基于能量的范数 $\\|(p,u)\\|_{E,h}$ 和当 $N_0 = 32$ 时的观测率 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 2 (交错散度的中心 $\\mathsf{L}^2$ 误差)：设 $u(x) = \\exp(\\cos x)$。对于每个网格，在面上采样 $u$，在中心计算 $D^- u$，在中心计算精确的 $\\partial_x u$，计算中心 $\\mathsf{L}^2$ 范数 $\\|D^- u - \\partial_x u\\|_{h,c}$，并报告当 $N_0 = 32$ 时的观测率 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 3 (更高波数梯度的面上 $\\mathsf{L}^2$ 误差)：设 $\\phi(x) = \\sin(10 x)$。对于每个网格，从中心采样计算面上的 $D^+\\phi$，并使用面上 $\\mathsf{L}^2$ 范数 $\\|\\cdot\\|_{h,f}$ 将其与面上的精确 $\\partial_x \\phi$ 进行比较，然后报告当 $N_0 = 64$ 时的观测率 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 4 (更高波数散度的中心 $\\mathsf{L}^2$ 误差)：设 $u(x) = \\sin(11 x)$。对于每个网格，从面采样计算中心上的 $D^- u$，并使用中心 $\\mathsf{L}^2$ 范数 $\\|\\cdot\\|_{h,c}$ 将其与中心上的精确 $\\partial_x u$ 进行比较，然后报告当 $N_0 = 64$ 时的观测率 $r_{(2N_0\\to 4N_0)}$。\n\n所有函数在 $[0,2\\pi]$ 上都是实值和光滑的，角度以弧度为单位。输出无需物理单位，因为报告的速率是无量纲实数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\text{测试 1 速率}, \\text{测试 2 速率}, \\text{测试 3 速率}, \\text{测试 4 速率}]$。输出必须是浮点数。示例格式：$[r_1,r_2,r_3,r_4]$。",
            "solution": "我们从连续一阶声学方程开始。在周期域 $\\Omega=[0,L]$ 上一个状态 $(p,u)$ 的总声能是\n$$\n\\mathcal{E}(t) = \\frac{1}{2}\\int_0^L \\left(\\frac{1}{\\kappa}p(x,t)^2 + \\rho\\, u(x,t)^2\\right)\\,dx,\n$$\n对于具有周期性边界条件的光滑解，该能量随时间守恒。这种连续能量为衡量离散化声学状态的误差提供了一个自然的内积和范数。\n\n在一个具有 $N$ 个单元、网格间距为 $h=L/N$ 的均匀交错网格上，我们将压力 $p$ 置于单元中心 $x_i=(i+\\tfrac{1}{2})h$ 处，将速度 $u$ 置于单元面 $x_{i+\\tfrac{1}{2}}=ih$ 处。离散内积\n$$\n\\langle v, \\tilde v\\rangle_{h,c} = \\sum_{i=0}^{N-1} h\\, v_i \\tilde v_i,\\qquad\n\\langle w, \\tilde w\\rangle_{h,f} = \\sum_{i=0}^{N-1} h\\, w_{i+\\tfrac{1}{2}} \\tilde w_{i+\\tfrac{1}{2}}\n$$\n分别是在中心和面上表示的函数的连续 $\\mathsf{L}^2$ 内积的一致黎曼和近似。相关的离散 $\\mathsf{L}^2$ 范数 $\\|v\\|_{h,c}$ 和 $\\|w\\|_{h,f}$ 是通过对向量与其自身的内积取平方根得到的。\n\n交错有限差分算子 $D^+$ 和 $D^-$ 定义为\n$$\n(D^+ v)_{i+\\tfrac{1}{2}} = \\frac{v_i - v_{i-1}}{h},\\qquad (D^- w)_i = \\frac{w_{i+\\tfrac{1}{2}} - w_{i-\\tfrac{1}{2}}}{h},\n$$\n索引具有周期性环绕。它们近似了在交错位置的空间导数。泰勒展开表明其具有二阶精度。例如，对于一个光滑函数 $\\phi$，在 $x_{i+1/2}=ih$ 处展开：\n$$\n\\phi(x_i) = \\phi(ih + h/2) = \\phi(ih) + \\frac{h}{2}\\phi'(ih) + \\frac{h^2}{8}\\phi''(ih) + \\mathcal{O}(h^3),\n$$\n$$\n\\phi(x_{i-1}) = \\phi(ih - h/2) = \\phi(ih) - \\frac{h}{2}\\phi'(ih) + \\frac{h^2}{8}\\phi''(ih) + \\mathcal{O}(h^3).\n$$\n两式相减再除以 $h$ 得到\n$$\n(D^+\\phi)_{i+\\tfrac{1}{2}} = \\frac{\\phi(x_i)-\\phi(x_{i-1})}{h} = \\phi'(ih) + \\mathcal{O}(h^2) = \\phi'(x_{i+1/2}) + \\mathcal{O}(h^2),\n$$\n这表明截断误差为 $\\mathcal{O}(h^2)$ 阶。类似的展开表明， `(D^- u)_i` 以 $\\mathcal{O}(h^2)$ 的误差近似于在面 `i+1/2` 和 `i-1/2` 之间的中点处的 `∂_x u`，即 `x_{i-1}=(i-1/2)h`。这些结果意味着，对于足够光滑的函数，误差的离散 $\\mathsf{L}^2$ 范数会以 $\\mathcal{O}(h^2)$ 的速度减小，因此在均匀细化下，观测到的收敛率应趋近于 2。\n\n对于离散索博列夫型度量，为中心场定义类 $\\mathsf{H}^1$ 半范数 $|v|_{h,c,1} = \\|D^+ v\\|_{h,f}$，为面场定义 $|w|_{h,f,1} = \\|D^- w\\|_{h,c}$。这些是连续 $\\mathsf{H}^1$ 半范数 $|f|_{H^1}=\\|\\partial_x f\\|_{L^2}$ 的离散模拟，并遵循了导数的交错布局。\n\n一个状态 $(p,u)$ 的基于能量的离散范数是\n$$\n\\|(p,u)\\|_{E,h} = \\sqrt{\\frac{1}{2}\\sum_{i=0}^{N-1} h\\left(\\frac{1}{\\kappa}p_i^2 + \\rho\\, u_{i+\\tfrac{1}{2}}^2\\right)}.\n$$\n这反映了连续能量。它也可以用来度量一对误差 $(e_p,e_u)$；例如，取 $e_p\\equiv 0$ 和 $e_u=D^+\\phi - \\partial_x\\phi$ 可得\n$$\n\\|(e_p,e_u)\\|_{E,h} = \\sqrt{\\frac{\\rho}{2}}\\;\\|D^+\\phi - \\partial_x\\phi\\|_{h,f},\n$$\n因此，基于能量的误差与 $D^+\\phi$ 的面上 $\\mathsf{L}^2$ 误差以相同的速率收敛。\n\n为计算观测收敛率，考虑一个包含 $N_0$、$2N_0$ 和 $4N_0$ 个单元的网格序列。对于每个网格，构建交错位置 $x_i$ 和 $x_{i+\\tfrac{1}{2}}$，对精确函数及其精确导数进行采样，应用离散算子（$D^+$ 或 $D^-$），并计算误差的离散范数。用 $\\|e_{h}\\|$ 表示在间距为 $h$ 的网格上的误差范数。将较精细级别之间的速率定义为\n$$\nr_{(2N_0\\to 4N_0)} = \\frac{\\log\\left(\\|e_{h/2}\\| / \\|e_{h/4}\\|\\right)}{\\log(2)}.\n$$\n对于光滑周期函数，这个观测速率应接近于 2，这反映了 $D^+$ 和 $D^-$ 的二阶相容性。\n\n我们现在详细说明测试：\n\n- 测试 1：选择 $\\rho=1.3$，$\\kappa=2.6$，$\\phi(x)=\\exp(\\sin x)$，$N_0=32$，$L=2\\pi$。对于每个 $N\\in\\{N_0,2N_0,4N_0\\}$，计算中心采样 $v_i=\\phi(x_i)$、面上的 $D^+v$、在面上的精确导数 $\\partial_x\\phi(x)=\\cos(x)\\exp(\\sin x)$、面上的误差 $e_u=D^+v-\\partial_x\\phi$、以及 $p\\equiv 0$ 时的能量范数，然后计算 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 2：选择 $u(x)=\\exp(\\cos x)$，$N_0=32$，$L=2\\pi$。对于每个 $N$，计算面采样 $w_{i+\\tfrac{1}{2}}=u(x_{i+\\tfrac{1}{2}})$、中心上的 $D^-w$、在中心上的精确导数 $\\partial_x u(x)=-\\sin(x)\\exp(\\cos x)$，计算 $\\|D^-w-\\partial_x u\\|_{h,c}$，然后计算 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 3：选择 $\\phi(x)=\\sin(10x)$，$N_0=64$，$L=2\\pi$。对于每个 $N$，从中心采样计算面上的 $D^+\\phi$，计算面上的精确导数 $\\partial_x\\phi(x)=10\\cos(10x)$，计算面上 $\\mathsf{L}^2$ 误差，然后计算 $r_{(2N_0\\to 4N_0)}$。\n\n- 测试 4：选择 $u(x)=\\sin(11x)$，$N_0=64$，$L=2\\pi$。对于每个 $N$，从面采样计算中心上的 $D^-u$，计算中心上的精确导数 $\\partial_x u(x)=11\\cos(11x)$，计算中心 $\\mathsf{L}^2$ 误差，然后计算 $r_{(2N_0\\to 4N_0)}$。\n\n从算法上讲，对于每个测试和细化级别：\n\n- 对于 $i\\in\\{0,\\dots,N-1\\}$ 和 $h=L/N$，构造 $x_i=(i+\\tfrac{1}{2})h$ 和 $x_{i+\\tfrac{1}{2}}=ih$。\n\n- 在所需位置计算相关精确函数及其导数的值。\n\n- 使用周期性环绕的索引应用 $D^+$ 或 $D^-$。\n\n- 酌情计算误差的离散 $\\mathsf{L}^2$ 范数或能量范数。\n\n- 累积在 $N_0$、$2N_0$ 和 $4N_0$ 时的误差；使用上述公式计算 $r_{(2N_0\\to 4N_0)}$。\n\n最后，以指定格式单行输出四个速率。对于所有测试，预期速率都接近 2，但由于前渐近效应和测试函数的特定振荡内容，可能会有小的偏差。",
            "answer": "```python\nimport numpy as np\n\ndef make_grid(N, L):\n    h = L / N\n    x_centers = (np.arange(N) + 0.5) * h\n    x_faces = np.arange(N) * h\n    return h, x_centers, x_faces\n\ndef D_plus_center_to_face(phi_center, h):\n    # (D^+ v)_{i+1/2} = (v_i - v_{i-1})/h with periodic wrap\n    return (phi_center - np.roll(phi_center, 1)) / h\n\ndef D_minus_face_to_center(u_face, h):\n    # (D^- w)_i = (w_{i+1/2} - w_{i-1/2})/h with periodic wrap\n    return (u_face - np.roll(u_face, 1)) / h\n\ndef L2_norm_center(arr_center, h):\n    return np.sqrt(h * np.sum(arr_center**2))\n\ndef L2_norm_face(arr_face, h):\n    return np.sqrt(h * np.sum(arr_face**2))\n\ndef energy_norm(p_center, u_face, h, rho, kappa):\n    return np.sqrt(0.5 * h * (np.sum((1.0/kappa) * p_center**2) + np.sum(rho * u_face**2)))\n\n# Test functions and derivatives\ndef phi_exp_sin(x):\n    return np.exp(np.sin(x))\n\ndef dphi_exp_sin(x):\n    return np.cos(x) * np.exp(np.sin(x))\n\ndef phi_sin_k(x, k):\n    return np.sin(k * x)\n\ndef dphi_sin_k(x, k):\n    return k * np.cos(k * x)\n\ndef u_exp_cos(x):\n    return np.exp(np.cos(x))\n\ndef du_exp_cos(x):\n    return -np.sin(x) * np.exp(np.cos(x))\n\ndef u_sin_k(x, k):\n    return np.sin(k * x)\n\ndef du_sin_k(x, k):\n    return k * np.cos(k * x)\n\ndef rate_from_errors(e_h, e_h2):\n    return np.log(e_h / e_h2) / np.log(2.0)\n\ndef observed_rate_grad_energy(phi_func, dphi_func, L, N0, rho, kappa):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        phi_c = phi_func(xc)\n        dphi_exact_f = dphi_func(xf)\n        dplus_phi = D_plus_center_to_face(phi_c, h)\n        e_face = dplus_phi - dphi_exact_f\n        # Energy norm with p=0 and u = error\n        p_zero = np.zeros_like(phi_c)\n        en = energy_norm(p_zero, e_face, h, rho, kappa)\n        errs.append(en)\n    # Use the rate between the two finest levels\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef observed_rate_div_L2(u_func, du_func, L, N0):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        u_f = u_func(xf)\n        du_exact_c = du_func(xc)\n        dminus_u = D_minus_face_to_center(u_f, h)\n        # The numerical derivative dminus_u[i] is at center x_{i-1}, while\n        # du_exact_c[i] is at center x_i. We must align them for correct error calculation.\n        e_center = dminus_u - np.roll(du_exact_c, 1)\n        l2 = L2_norm_center(e_center, h)\n        errs.append(l2)\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef observed_rate_grad_L2(phi_func, dphi_func, L, N0):\n    Ns = [N0, 2*N0, 4*N0]\n    errs = []\n    for N in Ns:\n        h, xc, xf = make_grid(N, L)\n        phi_c = phi_func(xc)\n        dphi_exact_f = dphi_func(xf)\n        dplus_phi = D_plus_center_to_face(phi_c, h)\n        e_face = dplus_phi - dphi_exact_f\n        l2 = L2_norm_face(e_face, h)\n        errs.append(l2)\n    r = rate_from_errors(errs[1], errs[2])\n    return r\n\ndef solve():\n    L = 2.0 * np.pi\n\n    test_cases = [\n        # Test 1: gradient energy norm with phi = exp(sin x), rho=1.3, kappa=2.6, N0=32\n        (\"grad_energy_exp_sin\", 32, 1.3, 2.6),\n        # Test 2: divergence L2 with u = exp(cos x), N0=32\n        (\"div_l2_exp_cos\", 32, None, None),\n        # Test 3: gradient L2 with phi = sin(10x), N0=64\n        (\"grad_l2_sin10\", 64, None, None),\n        # Test 4: divergence L2 with u = sin(11x), N0=64\n        (\"div_l2_sin11\", 64, None, None),\n    ]\n\n    results = []\n    for case in test_cases:\n        name, N0, rho, kappa = case\n        if name == \"grad_energy_exp_sin\":\n            r = observed_rate_grad_energy(phi_exp_sin, dphi_exp_sin, L, N0, rho, kappa)\n            results.append(r)\n        elif name == \"div_l2_exp_cos\":\n            r = observed_rate_div_L2(u_exp_cos, du_exp_cos, L, N0)\n            results.append(r)\n        elif name == \"grad_l2_sin10\":\n            r = observed_rate_grad_L2(lambda x: phi_sin_k(x, 10.0),\n                                      lambda x: dphi_sin_k(x, 10.0), L, N0)\n            results.append(r)\n        elif name == \"div_l2_sin11\":\n            r = observed_rate_div_L2(lambda x: u_sin_k(x, 11.0),\n                                     lambda x: du_sin_k(x, 11.0), L, N0)\n            results.append(r)\n        else:\n            results.append(float('nan'))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "确认了离散算子的数学准确性后，下一步是将其组装成一个完整的模拟器并验证其物理行为。本实践将指导您构建一个用于二维矩形谐振腔的 FDTD 求解器 ()。通过将模拟得到的谐振频率与刚性（Neumann）和压力释放（Dirichlet）边界条件下的解析解进行比较，您可以验证您的代码是否正确地模拟了驻波和声学共振等基本物理现象。",
            "id": "4138364",
            "problem": "考虑关于静态流体状态的小扰动的二维空间线性化一阶声学方程组：\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right), \\quad\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}, \\quad\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y},\n$$\n其中 $p$ 是声压，$v_x$ 和 $v_y$ 是声学质点速度的分量，$K$ 是体积模量，$\\rho_0$ 是平衡密度。假设一个尺寸为 $L_x \\times L_y$ 的矩形腔体，其壁面为刚性壁或压力释放壁。刚性壁强制 $v_n=0$，即边界处的法向速度为零，这对应于 $p$ 上的齐次 Neumann 条件。压力释放壁强制 $p=0$（Dirichlet 条件）。对于矩形腔体，连续本征频率为\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\n其中 $c$ 为声速。对于压力释放壁，$m,n \\in \\mathbb{N}$；对于刚性壁，$m,n \\in \\mathbb{N}_0$，且排除 $m=n=0$ 的平凡情况。\n\n您必须为此系统实现一个显式二维交错网格格式（压力位于单元中心，速度分量位于单元面）。离散更新必须使用与交错排列一致的有限差分从上述方程导出：\n- 压力 $p[i,j]$ 位于单元中心，其位置为 $x_i = (i+\\tfrac{1}{2})\\Delta x$，$y_j = (j+\\tfrac{1}{2})\\Delta y$，其中 $i=0,\\dots,N_x-1$，$j=0,\\dots,N_y-1$。\n- 速度 $v_x[i,j]$ 位于垂直面，其位置为 $x = i \\Delta x$，$y = (j+\\tfrac{1}{2})\\Delta y$，其中 $i=0,\\dots,N_x$，$j=0,\\dots,N_y-1$。\n- 速度 $v_y[i,j]$ 位于水平面，其位置为 $x = (i+\\tfrac{1}{2})\\Delta x$，$y = j \\Delta y$，其中 $i=0,\\dots,N_x-1$，$j=0,\\dots,N_y$。\n\n使用时间上蛙跳法，其中速度使用压力梯度从时间 $t^n$ 推进到 $t^{n+1/2}$，压力使用 $t^{n+1/2}$ 时的速度散度从时间 $t^n$ 推进到 $t^{n+1}$。边界条件必须按如下方式施加：\n- 对于刚性壁，将区域边界上的法向速度分量设置为零（即，$v_x[0,\\cdot]=0$, $v_x[N_x,\\cdot]=0$, $v_y[\\cdot,0]=0$, $v_y[\\cdot,N_y]=0$），并使用对称的虚拟压力值在速度更新中产生零法向压力梯度（即，$p_{\\text{ghost,left}}=p[0,\\cdot]$, $p_{\\text{ghost,right}}=p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=p[\\cdot,0]$, $p_{\\text{ghost,top}}=p[\\cdot,N_y-1]$）。\n- 对于压力释放壁，通过反对称的虚拟压力值在壁面处强制 $p=0$（即，$p_{\\text{ghost,left}}=-p[0,\\cdot]$, $p_{\\text{ghost,right}}=-p[N_x-1,\\cdot]$, $p_{\\text{ghost,bottom}}=-p[\\cdot,0]$, $p_{\\text{ghost,top}}=-p[\\cdot,N_y-1]$），并让速度自由演化。\n\n通过将初始压力场设置为具有单位振幅和零初始速度的相应连续模态形状来初始化驻波：\n- 对于刚性壁（Neumann 边界条件），使用 $p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$。\n- 对于压力释放壁（Dirichlet 边界条件），使用 $p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$。\n\n根据交错格式的 Courant-Friedrichs-Lewy 安全条件选择时间步长 $\\Delta t$，\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}},\n$$\n其中 $\\text{CFL} \\in (0,1)$。模拟持续一个有限的时长 $T$，该时长应足以解析驻波的主导频率。使用离散傅里叶变换从一个非节点内部点的压力时间历史中提取主导离散频率 $f_{\\text{FD}}$，并计算相对误差\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}},\n$$\n该误差必须以无量纲小数形式报告（不使用百分号）。\n\n在一个完整的程序中实现上述内容，并运行以下测试套件。使用一致的物理和数值单位：$L_x$ 和 $L_y$ 单位为米，$c$ 单位为米/秒，$\\rho_0$ 单位为千克/立方米，$\\Delta t$ 单位为秒，$f$ 单位为赫兹。最终输出必须是每种情况下的相对误差 $\\delta$，四舍五入到六位小数。\n\n测试套件：\n- 情况 1（正常路径，刚性壁）：$L_x=1.2$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$N_x=64$，$N_y=48$，$m=1$，$n=0$，$c=343$ $\\mathrm{m/s}$，$\\rho_0=1.21$ $\\mathrm{kg/m^3}$，$\\text{CFL}=0.95$，$T=0.25$ $\\mathrm{s}$。\n- 情况 2（正常路径，压力释放壁）：$L_x=1.2$ $\\mathrm{m}$，$L_y=0.8$ $\\mathrm{m}$，$N_x=64$，$N_y=48$，$m=1$，$n=1$，$c=343$ $\\mathrm{m/s}$，$\\rho_0=1.21$ $\\mathrm{kg/m^3}$，$\\text{CFL}=0.95$，$T=0.25$ $\\mathrm{s}$。\n- 情况 3（边缘情况：一个零索引模态且接近 CFL 极限，刚性壁）：$L_x=1.0$ $\\mathrm{m}$，$L_y=1.5$ $\\mathrm{m}$，$N_x=60$，$N_y=50$，$m=0$，$n=2$，$c=343$ $\\mathrm{m/s}$，$\\rho_0=1.21$ $\\mathrm{kg/m^3}$，$\\text{CFL}=0.99$，$T=0.30$ $\\mathrm{s}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3]$），其中 $r_k$ 是上述三种情况的相对误差，四舍五入到六位小数。",
            "solution": "用户希望使用时域有限差分 (FDTD) 格式在交错网格上求解二维线性化声学方程，并对照解析本征频率来验证数值结果。我已经验证了问题陈述，并发现其在科学上是合理的、适定的和完整的。现在我将提供完整的解决方案。\n\n### **1. 控制方程与离散化**\n\n该问题涉及二维空间中的线性化一阶声学方程：\n$$\n\\frac{\\partial p}{\\partial t} = -K \\left( \\frac{\\partial v_x}{\\partial x} + \\frac{\\partial v_y}{\\partial y} \\right)\n$$\n$$\n\\rho_0 \\frac{\\partial v_x}{\\partial t} = -\\frac{\\partial p}{\\partial x}\n$$\n$$\n\\rho_0 \\frac{\\partial v_y}{\\partial t} = -\\frac{\\partial p}{\\partial y}\n$$\n此处，$p$ 是声压，$\\vec{v} = (v_x, v_y)$ 是质点速度，$K$ 是体积模量，$\\rho_0$ 是流体的平衡密度。声速由 $c = \\sqrt{K/\\rho_0}$ 给出。\n\n我们采用交错网格有限差分格式。压力 $p$ 定义在单元中心，而速度分量 $v_x$ 和 $v_y$ 定义在垂直于其各自方向的单元面上。设尺寸为 $L_x \\times L_y$ 的区域被离散为 $N_x \\times N_y$ 个单元，空间步长为 $\\Delta x = L_x/N_x$ 和 $\\Delta y = L_y/N_y$。离散场表示如下：\n- $p_{i,j}^n \\approx p((i+\\frac{1}{2})\\Delta x, (j+\\frac{1}{2})\\Delta y, n\\Delta t)$\n- $v_{x, i,j}^{n+1/2} \\approx v_x(i\\Delta x, (j+\\frac{1}{2})\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n- $v_{y, i,j}^{n+1/2} \\approx v_y((i+\\frac{1}{2})\\Delta x, j\\Delta y, (n+\\frac{1}{2})\\Delta t)$\n\n对于压力 $p$，指数 $i$ 的范围是 $0, \\dots, N_x-1$，$j$ 的范围是 $0, \\dots, N_y-1$。对于速度，指数延伸到区域边界：$v_x$ 的 $i$ 范围是 $0, \\dots, N_x$，$v_y$ 的 $j$ 范围是 $0, \\dots, N_y$。\n\n使用蛙跳时间步进格式，其中压力在整数时间步 $n\\Delta t$ 计算，速度在半整数时间步 $(n+\\frac{1}{2})\\Delta t$ 计算。偏导数使用二阶中心差分进行近似，这在空间和时间上都是自然交错的：\n\n速度更新方程由动量方程导出：\n$$\nv_{x, i,j}^{n+1/2} = v_{x, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{i,j}^n - p_{i-1,j}^n)\n$$\n$$\nv_{y, i,j}^{n+1/2} = v_{y, i,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta y} (p_{i,j}^n - p_{i,j-1}^n)\n$$\n\n压力更新方程由连续性方程导出：\n$$\np_{i,j}^{n+1} = p_{i,j}^n - K \\Delta t \\left( \\frac{v_{x, i+1,j}^{n+1/2} - v_{x, i,j}^{n+1/2}}{\\Delta x} + \\frac{v_{y, i,j+1}^{n+1/2} - v_{y, i,j}^{n+1/2}}{\\Delta y} \\right)\n$$\n这些方程构成了 FDTD 模拟循环的核心。\n\n### **2. 初始条件和边界条件**\n\n**初始条件**：模拟以对应于特定模态 $(m, n)$ 的压力驻波模式和零初始速度进行初始化。对于蛙跳格式，我们根据指定的函数设置 $p^0$，并假设在时间 $t=-\\Delta t/2$ 时的速度为零。\n- 对于刚性壁（Neumann 边界条件）：$p(x,y,0) = \\cos\\left(\\frac{m \\pi x}{L_x}\\right)\\cos\\left(\\frac{n \\pi y}{L_y}\\right)$。通过在压力网格坐标 $(x_i, y_j) = ((i+0.5)\\Delta x, (j+0.5)\\Delta y)$ 处评估此函数来初始化离散压力场 $p_{i,j}^0$。\n- 对于压力释放壁（Dirichlet 边界条件）：$p(x,y,0) = \\sin\\left(\\frac{m \\pi x}{L_x}\\right)\\sin\\left(\\frac{n \\pi y}{L_y}\\right)$。\n\n**边界条件**：\n- **刚性壁**：此条件在边界上施加零法向速度 ($v_n=0$)，这对应于压力上的齐次 Neumann 条件 ($\\partial p/\\partial n = 0$)。在离散格式中，这是通过在每个时间步将边界网格点上的法向速度分量显式设置为零来实现的：$v_{x,0,j} = 0$，$v_{x,N_x,j} = 0$，$v_{y,i,0} = 0$ 和 $v_{y,i,N_y} = 0$。此方法在 FDTD 框架内正确地模拟了壁面处的零压力梯度。\n\n- **压力释放壁**：此条件在边界上施加零压力 ($p=0$)。这是一个 Dirichlet 条件。我们使用紧邻区域外部的反对称虚拟压力值来实现它。例如，为了更新左边界 ($x=0$) 处的速度 $v_{x,0,j}$，所需的压力梯度涉及一个虚拟压力值 $p_{-1,j}$。我们将此虚拟值设置为 $p_{-1,j} = -p_{0,j}$。这以二阶精度有效地模拟了 $p=0$ 条件。四个边界上的速度更新变为：\n$$\nv_{x, 0,j}^{n+1/2} = v_{x, 0,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} (p_{0,j}^n - (-p_{0,j}^n)) = v_{x, 0,j}^{n-1/2} - \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{0,j}^n\n$$\n$$\nv_{x, N_x,j}^{n+1/2} = v_{x, N_x,j}^{n-1/2} - \\frac{\\Delta t}{\\rho_0 \\Delta x} ((-p_{N_x-1,j}^n) - p_{N_x-1,j}^n) = v_{x, N_x,j}^{n-1/2} + \\frac{2\\Delta t}{\\rho_0 \\Delta x} p_{N_x-1,j}^n\n$$\n类似的更新适用于 $v_{y,i,0}$ 和 $v_{y,i,N_y}$。\n\n### **3. 稳定性、频率分析与误差计算**\n\n**稳定性**：显式 FDTD 格式是条件稳定的。时间步长 $\\Delta t$ 必须满足 Courant-Friedrichs-Lewy (CFL) 条件。对于二维交错网格，该条件为：\n$$\n\\Delta t \\le \\frac{1}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\n我们使用一个安全因子 $\\text{CFL}  1$ 来设置时间步长：\n$$\n\\Delta t = \\frac{\\text{CFL}}{c \\sqrt{\\left(\\frac{1}{\\Delta x}\\right)^2 + \\left(\\frac{1}{\\Delta y}\\right)^2}}\n$$\n\n**频率分析**：模拟运行总时间 $T$。在每个时间步记录一个固定的非节点内部点的压力，形成一个离散时间信号。然后使用快速傅里叶变换 (FFT) 算法对该信号应用离散傅里叶变换 (DFT)。对应于最大幅值分量（不包括直流分量）的频率被确定为主导离散频率 $f_{\\text{FD}}$。\n\n**误差计算**：网格的数值色散导致数值频率 $f_{\\text{FD}}$ 偏离连续系统的解析本征频率 $f_{m,n}$。我们使用相对误差 $\\delta$ 来量化此偏差：\n$$\n\\delta = \\frac{|f_{\\text{FD}} - f_{m,n}|}{f_{m,n}}\n$$\n其中解析频率由下式给出\n$$\nf_{m,n} = \\frac{c}{2} \\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\n$\\delta$ 的值可作为给定离散化下 FDTD 模拟精度的度量。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # Case 1: (happy path, rigid walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 0, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'rigid'},\n        # Case 2: (happy path, pressure-release walls)\n        {'Lx': 1.2, 'Ly': 0.8, 'Nx': 64, 'Ny': 48, 'm': 1, 'n': 1, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.95, 'T': 0.25, 'bc_type': 'pressure-release'},\n        # Case 3: (edge case: one zero index mode and near-CFL limit, rigid walls)\n        {'Lx': 1.0, 'Ly': 1.5, 'Nx': 60, 'Ny': 50, 'm': 0, 'n': 2, 'c': 343.0,\n         'rho0': 1.21, 'CFL': 0.99, 'T': 0.30, 'bc_type': 'rigid'}\n    ]\n\n    results = []\n    for case in test_cases:\n        error = run_fdtd_simulation(**case)\n        results.append(f\"{error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef run_fdtd_simulation(Lx, Ly, Nx, Ny, m, n, c, rho0, CFL, T, bc_type):\n    \"\"\"\n    Performs a 2D acoustic FDTD simulation for a single test case.\n    \"\"\"\n    # 1. Grid and Simulation Parameters\n    dx = Lx / Nx\n    dy = Ly / Ny\n    K = c**2 * rho0  # Bulk modulus\n\n    # Stability condition (CFL)\n    dt = CFL / (c * np.sqrt(1/dx**2 + 1/dy**2))\n    n_steps = int(T / dt)\n\n    # 2. Field Initialization\n    p = np.zeros((Nx, Ny))\n    vx = np.zeros((Nx + 1, Ny))\n    vy = np.zeros((Nx, Ny + 1))\n    \n    # Pressure grid coordinates (cell centers)\n    p_x_coords = (np.arange(Nx) + 0.5) * dx\n    p_y_coords = (np.arange(Ny) + 0.5) * dy\n    xx, yy = np.meshgrid(p_x_coords, p_y_coords, indexing='ij')\n\n    # Initial pressure field\n    if bc_type == 'rigid':\n        p = np.cos(m * np.pi * xx / Lx) * np.cos(n * np.pi * yy / Ly)\n    elif bc_type == 'pressure-release':\n        # For pressure-release, m and n must be >= 1. The problem ensures this.\n        p = np.sin(m * np.pi * xx / Lx) * np.sin(n * np.pi * yy / Ly)\n\n    # 3. Main FDTD Loop\n    pressure_history = np.zeros(n_steps)\n    probe_x, probe_y = Nx // 3, Ny // 3 # A non-nodal point for all cases\n    \n    # Update coefficients\n    C_vx = dt / (rho0 * dx)\n    C_vy = dt / (rho0 * dy)\n    C_px = K * dt / dx\n    C_py = K * dt / dy\n\n    for t_step in range(n_steps):\n        # --- (1) Update Velocity Fields (from n-1/2 to n+1/2) ---\n        # Interior points\n        vx[1:Nx, :] -= C_vx * (p[1:Nx, :] - p[0:Nx-1, :])\n        vy[:, 1:Ny] -= C_vy * (p[:, 1:Ny] - p[:, 0:Ny-1])\n        \n        # --- (2) Apply Velocity Boundary Conditions ---\n        if bc_type == 'rigid':\n            vx[0, :] = 0.0\n            vx[Nx, :] = 0.0\n            vy[:, 0] = 0.0\n            vy[:, Ny] = 0.0\n        elif bc_type == 'pressure-release':\n            # Use anti-symmetric ghost cells for p to update boundary velocities\n            vx[0, :] -= 2.0 * C_vx * p[0, :]\n            vx[Nx, :] += 2.0 * C_vx * p[Nx-1, :]\n            vy[:, 0] -= 2.0 * C_vy * p[:, 0]\n            vy[:, Ny] += 2.0 * C_vy * p[:, Ny-1]\n\n        # --- (3) Update Pressure Field (from n to n+1) ---\n        p[:, :] -= C_px * (vx[1:Nx+1, :] - vx[0:Nx, :])\n        p[:, :] -= C_py * (vy[:, 1:Ny+1] - vy[:, 0:Ny])\n\n        # --- (4) Store pressure at probe location ---\n        pressure_history[t_step] = p[probe_x, probe_y]\n\n    # 4. Frequency Analysis\n    # Analytical frequency\n    # For rigid BCs, m,n=0,0 is excluded. For p-release, m,n>=1.\n    if (m == 0 and n == 0):\n        f_mn = 0.0\n    else:\n        f_mn = (c / 2.0) * np.sqrt((m / Lx)**2 + (n / Ly)**2)\n\n    # Numerical frequency from FFT\n    fft_result = np.fft.fft(pressure_history)\n    fft_freqs = np.fft.fftfreq(n_steps, d=dt)\n    \n    # Find peak frequency in the positive spectrum\n    positive_freq_mask = fft_freqs > 0\n    if not np.any(positive_freq_mask):\n        return np.nan # Avoid error if no positive frequencies (e.g., T is too short)\n        \n    peak_idx = np.argmax(np.abs(fft_result[positive_freq_mask]))\n    f_fd = fft_freqs[positive_freq_mask][peak_idx]\n\n    # 5. Calculate Relative Error\n    if f_mn == 0:\n        # Avoid division by zero if analytical frequency is zero.\n        # This case should not be hit with the provided test suite.\n        return np.abs(f_fd)\n    \n    relative_error = np.abs(f_fd - f_mn) / f_mn\n    \n    return relative_error\n\nif __name__ == '__main__':\n    solve()\n```"
        },
        {
            "introduction": "在一维和二维中验证了我们的方法之后，我们将把模拟扩展到完整的三维空间，这代表了许多现实世界中的计算声学问题。本练习侧重于三维 FDTD 方案的实际实现细节，包括为交错场管理复杂的三维数组索引，并使用“幽灵层”正确施加边界条件 ()。完成此实践将为您处理大规模声学建模任务打下坚实的基础。",
            "id": "4138270",
            "problem": "要求您构建并实现一个用于线性声学的三维交错网格显式时间推进格式，该格式使用蛙跳格式更新，并通过鬼点层施加物理上一致的边界条件。从基本方程出发，推导离散更新公式和显式的数组索引范围。然后，在一个完整的、可运行的程序中实现推导出的索引，该程序对一小组规定的测试用例执行单次更新对，并按规定输出可量化的结果。\n\n线性声学的基本方程：\n- 线性化动量方程：$$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p,$$ 其中 $p$ 是声压，$\\mathbf{u} = (u_x,u_y,u_z)$ 是声学质点速度，$\\rho$ 是质量密度。\n- 线性化连续性方程：$$\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u},$$ 其中 $K$ 是体积模量，$\\nabla\\cdot \\mathbf{u}$ 是速度散度。\n\n交错网格布局：\n- 压力 $p$ 存储在由 $(i,j,k)$ 索引的网格中心。\n- 速度存储在面上：\n  - $u_x$ 在垂直于 $x$ 轴、索引为 $(i+\\tfrac{1}{2},j,k)$ 的面上，\n  - $u_y$ 在垂直于 $y$ 轴、索引为 $(i,j+\\tfrac{1}{2},k)$ 的面上，\n  - $u_z$ 在垂直于 $z$ 轴、索引为 $(i,j,k+\\tfrac{1}{2})$ 的面上。\n- 沿 $x, y, z$ 轴的均匀间距为 $dx, dy, dz$。\n\n时间交错：\n- 压力 $p$ 在整数时间 $t^n$ 进行计算。\n- 速度分量在半整数时间 $t^{n\\pm 1/2}$ 进行计算。\n- 蛙跳格式更新应实现为：\n  1. 从 $p^n$ 更新 $\\mathbf{u}^{n+1/2}$。\n  2. 从 $\\mathbf{u}^{n+1/2}$ 更新 $p^{n+1}$。\n\n鬼点层与边界处理：\n- 在压力和速度数组的每个维度上，围绕内部域使用一层鬼点层。$p$ 的鬼点层必须施加齐次诺伊曼边界条件（法向导数为零），即，将内部值复制到每个边界的鬼点网格中，以使边界处的离散法向梯度为零。\n- 速度数组的鬼点层应被分配以支持索引和散度运算；压力上的诺伊曼边界条件的结果是，在速度更新后，物理边界处的法向速度必须保持为零。\n\n离散化要求：\n- 从基本方程出发，推导与交错布局和时间交错一致的梯度和散度的二阶中心、均匀网格有限差分近似。仔细写出每个速度分量和压力的显式索引范围，以确保更新仅使用有效的内部值和鬼点值。\n- 将内部压力的索引表示为 $i \\in \\{1,\\dots,N_x\\}$，$j \\in \\{1,\\dots,N_y\\}$，$k \\in \\{1,\\dots,N_z\\}$，对应于 $N_x \\times N_y \\times N_z$ 的内部网格。压力数组必须在索引 $i=0$ 和 $i=N_x+1$，$j=0$ 和 $j=N_y+1$，$k=0$ 和 $k=N_z+1$ 处包含鬼点层，以施加诺伊曼条件。\n- 表示速度面索引范围时，需与交错位置和鬼点层保持一致，以使差分与压力的散度索引对齐。\n\n程序要求：\n- 实现以下功能的函数：\n  1. 为 $p$, $u_x$, $u_y$, $u_z$ 构建带鬼点层的数组。\n  2. 用一个位于内部中心网格、振幅为 $1$ 的单网格脉冲来初始化 $p^n$，并将 $\\mathbf{u}^{n-1/2}$ 初始化为处处为零。\n  3. 通过将相邻内部网格的值复制到鬼点网格来填充压力鬼点层，以施加齐次诺伊曼边界条件。\n  4. 使用显式交错中心差分从 $p^n$ 更新 $\\mathbf{u}^{n+1/2}$。\n  5. 使用显式散度中心差分从 $\\mathbf{u}^{n+1/2}$ 更新 $p^{n+1}$。\n- 使用为保证数值稳定性而选择的 $dt$：$$dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c},\\quad c=\\sqrt{\\frac{K}{\\rho}},$$ 其中 $c$ 是声速。此值需对每个测试用例进行计算。\n- 确保所有数组更新都使用显式索引，尊重鬼点层，并且不访问超出范围的索引。\n\n测试套件：\n对于每个测试用例，构建数组，执行一次速度更新和一次压力更新，然后计算以下三个量：\n\n1. 速度更新后边界法向速度绝对值的最大值（单位：米/秒）。这是在所有物理边界平面上 $|u_x|$（在 $i=0$ 和 $i=N_x$ 处）、$|u_y|$（在 $j=0$ 和 $j=N_y$ 处）以及 $|u_z|$（在 $k=0$ 和 $k=N_z$ 处）的最大值。\n2. 在用于计算压力散度的内部面位置中，更新后速度的绝对值超过 $10^{-14}$ 容差的整数计数。\n3. 压力更新后内部压力值的总和（单位：帕斯卡）。\n\n要实现的测试用例：\n- 用例 A：$N_x=1$, $N_y=1$, $N_z=1$, $dx=0.1$, $dy=0.1$, $dz=0.1$, $\\rho=1.2$, $K=1.4\\times 10^5$。\n- 用例 B：$N_x=3$, $N_y=2$, $N_z=1$, $dx=0.05$, $dy=0.1$, $dz=0.2$, $\\rho=1.2$, $K=1.01\\times 10^5$。\n- 用例 C：$N_x=4$, $N_y=3$, $N_z=2$, $dx=0.02$, $dy=0.03$, $dz=0.04$, $\\rho=1.2$, $K=1.5\\times 10^5$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于这三个测试用例，按以下顺序汇总九个值：用例 A 的边界法向速度大小（单位 m/s）、非零内部速度计数（整数）、内部压力总和（单位 Pa），然后是用例 B 的相同三元组，再然后是用例 C。例如：“[vA,countA,sumA,vB,countB,sumB,vC,countC,sumC]”。所有角度（如果有）必须以弧度为单位，但此处未使用角度。确保速度单位为米/秒，压力总和单位为帕斯卡。计数是无单位的整数。",
            "solution": "该问题要求推导并实现一个用于线性化声学方程的三维交错网格时域有限差分（FDTD）格式。首先将从基本原理出发推导解决方案，然后通过实现该方案来数值求解指定的测试用例。\n\n### 1. 问题验证\n所提供的问题陈述是计算声学中一个适定的、有科学依据的任务。\n- **给定条件**：\n    - 动量方程：$\\frac{\\partial \\mathbf{u}}{\\partial t} = -\\frac{1}{\\rho}\\nabla p$\n    - 连续性方程：$\\frac{\\partial p}{\\partial t} = -K \\nabla\\cdot \\mathbf{u}$\n    - 变量：声压 $p$，质点速度 $\\mathbf{u}=(u_x, u_y, u_z)$，质量密度 $\\rho$，体积模量 $K$。\n    - 网格：交错网格，其中 $p$ 位于网格中心 $(i,j,k)$，$u_x$ 位于 $(i+\\tfrac{1}{2},j,k)$，$u_y$ 位于 $(i,j+\\tfrac{1}{2},k)$，$u_z$ 位于 $(i,j,k+\\tfrac{1}{2})$。网格间距为 $dx, dy, dz$。\n    - 时间步进：蛙跳格式，其中 $p$ 在整数时间 $t^n$ 计算，$\\mathbf{u}$ 在半整数时间 $t^{n \\pm 1/2}$ 计算。\n    - 边界条件：对压力 $p$ 施加齐次诺伊曼边界条件（$\\frac{\\partial p}{\\partial n}=0$），使用一层鬼点层实现。\n    - 域：内部网格为 $N_x \\times N_y \\times N_z$ 个单元，压力索引为 $i \\in \\{1,\\dots,N_x\\}$, $j \\in \\{1,\\dots,N_y\\}$, $k \\in \\{1,\\dots,N_z\\}$。\n    - 初始条件：$p^n$ 在内部中心有一个振幅为 $1$ 的单网格脉冲；$\\mathbf{u}^{n-1/2} = \\mathbf{0}$。\n    - 时间步长：$dt = \\frac{1}{2}\\frac{\\min(dx,dy,dz)}{c}$，其中 $c=\\sqrt{K/\\rho}$。\n    - 指定了测试用例和输出要求。\n\n- **验证**：该问题是有效的。它基于线性声学的基本方程，并采用了一种标准的、稳定的数值方法（交错网格FDTD）。其设置是自洽的，提供了所有必要的参数和条件。它没有违反任何科学原理，并且是客观和可形式化的。\n\n### 2. 离散格式的推导\n\n#### 2.1. 时间离散化（蛙跳格式）\n蛙跳格式涉及在交错的时间步长上计算压力和速度。时间导数通过二阶中心有限差分来近似：\n\n- 对于从 $t^{n-1/2}$ 到 $t^{n+1/2}$ 的速度更新，中心在 $t^n$：\n$$ \\frac{\\mathbf{u}^{n+1/2} - \\mathbf{u}^{n-1/2}}{\\Delta t} = -\\frac{1}{\\rho} (\\nabla p)^n $$\n- 对于从 $t^n$ 到 $t^{n+1}$ 的压力更新，中心在 $t^{n+1/2}$：\n$$ \\frac{p^{n+1} - p^n}{\\Delta t} = -K (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\n这导出了以下更新规则：\n$$ \\mathbf{u}^{n+1/2} = \\mathbf{u}^{n-1/2} - \\frac{\\Delta t}{\\rho} (\\nabla p)^n $$\n$$ p^{n+1} = p^n - K \\Delta t (\\nabla \\cdot \\mathbf{u})^{n+1/2} $$\n\n#### 2.2. 空间离散化（交错网格）\n空间导数（梯度 $\\nabla$ 和散度 $\\nabla \\cdot$）也通过二阶中心有限差分进行近似，并在适当的交错位置进行计算。\n\n- **速度更新（压力梯度）**：速度分量的位置需要压力梯度 $\\nabla p$。\n    - 对于位于 $(i+\\tfrac{1}{2},j,k)$ 的 $u_x$，偏导数 $\\frac{\\partial p}{\\partial x}$ 使用相邻网格中心 $(i,j,k)$ 和 $(i+1,j,k)$ 的压力值来近似：\n    $$ \\left. \\frac{\\partial p}{\\partial x} \\right|_{(i+1/2,j,k)} \\approx \\frac{p(i+1,j,k) - p(i,j,k)}{dx} $$\n    速度的 $x$ 分量的更新公式为：\n    $$ u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) = u_x^{n-1/2}(i+\\tfrac{1}{2},j,k) - \\frac{\\Delta t}{\\rho \\, dx} \\left( p^n(i+1,j,k) - p^n(i,j,k) \\right) $$\n    通过类比，$u_y$ 和 $u_z$ 的更新公式为：\n    $$ u_y^{n+1/2}(i,j+\\tfrac{1}{2},k) = u_y^{n-1/2}(i,j+\\tfrac{1}{2},k) - \\frac{\\Delta t}{\\rho \\, dy} \\left( p^n(i,j+1,k) - p^n(i,j,k) \\right) $$\n    $$ u_z^{n+1/2}(i,j,k+\\tfrac{1}{2}) = u_z^{n-1/2}(i,j,k+\\tfrac{1}{2}) - \\frac{\\Delta t}{\\rho \\, dz} \\left( p^n(i,j,k+1) - p^n(i,j,k) \\right) $$\n\n- **压力更新（速度散度）**：压力的位置（网格中心，$(i,j,k)$）需要速度散度 $\\nabla \\cdot \\mathbf{u}$。\n    $$ \\nabla \\cdot \\mathbf{u} = \\frac{\\partial u_x}{\\partial x} + \\frac{\\partial u_y}{\\partial y} + \\frac{\\partial u_z}{\\partial z} $$\n    每一项都由中心差分近似：\n    $$ \\left. \\frac{\\partial u_x}{\\partial x} \\right|_{(i,j,k)} \\approx \\frac{u_x(i+\\tfrac{1}{2},j,k) - u_x(i-\\tfrac{1}{2},j,k)}{dx} $$\n    $$ \\left. \\frac{\\partial u_y}{\\partial y} \\right|_{(i,j,k)} \\approx \\frac{u_y(i,j+\\tfrac{1}{2},k) - u_y(i,j-\\tfrac{1}{2},k)}{dy} $$\n    $$ \\left. \\frac{\\partial u_z}{\\partial z} \\right|_{(i,j,k)} \\approx \\frac{u_z(i,j,k+\\tfrac{1}{2}) - u_z(i,j,k-\\tfrac{1}{2})}{dz} $$\n    因此，压力的更新公式为：\n    $$ p^{n+1}(i,j,k) = p^n(i,j,k) - K \\Delta t \\left( \\frac{u_x^{n+1/2}(i+\\tfrac{1}{2},j,k) - u_x^{n+1/2}(i-\\tfrac{1}{2},j,k)}{dx} + \\dots \\right) $$\n\n#### 2.3. 数组索引与鬼点层\n我们使用NumPy数组并将网格索引映射到数组索引。每个维度都添加一个鬼点层。\n- `p` 数组：大小为 $(N_x+2, N_y+2, N_z+2)$。内部索引为 `1..Nx`、`1..Ny`、`1..Nz`。鬼点层位于索引 `0` 和 `N_x+1` 处（`y` 和 `z` 轴类似）。`p[i,j,k]` 存储 $p(i,j,k)$。\n- `ux` 数组：大小为 $(N_x+1, N_y+2, N_z+2)$。`ux[i,j,k]` 存储 $u_x(i+\\tfrac{1}{2},j,k)$。`i` 的范围从 `0` 到 $N_x$。\n- `uy` 数组：大小为 $(N_x+2, N_y+1, N_z+2)$。`uy[i,j,k]` 存储 $u_y(i,j+\\tfrac{1}{2},k)$。`j` 的范围从 `0` 到 $N_y$。\n- `uz` 数组：大小为 $(N_x+2, N_y+2, N_z+1)$。`uz[i,j,k]` 存储 $u_z(i,j,k+\\tfrac{1}{2})$。`k` 的范围从 `0` 到 $N_z$。\n\n使用这种索引，更新可以用向量化的形式表示：\n- **速度更新**：\n  - `ux_np12 = ux_nm12 - (dt/rho) * (p_n[1:,:,:] - p_n[:-1,:,:]) / dx`\n  - `uy_np12 = uy_nm12 - (dt/rho) * (p_n[:,1:,:] - p_n[:,:-1,:]) / dy`\n  - `uz_np12 = uz_nm12 - (dt/rho) * (p_n[:,:,1:] - p_n[:,:,:-1]) / dz`\n- **压力更新**（对于内部点 `1..N_x`, `1..N_y`, `1..N_z`）：\n  - `div_u_x = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx`\n  - `div_u_y = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy`\n  - `div_u_z = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz`\n  - `p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] = p_n[1:Nx+1, 1:Ny+1, 1:Nz+1] - K*dt*(div_u_x + div_u_y + div_u_z)`\n\n#### 2.4. 边界条件与预期结果分析\n- **齐次诺伊曼边界条件**：通过将第一层内部网格的值复制到相邻的鬼点层来施加 $\\frac{\\partial p}{\\partial n}=0$。例如，`p[0,:,:] = p[1,:,:]` 和 `p[Nx+1,:,:] = p[Nx,:,:]`。\n- **最大边界法向速度**：物理边界上的法向速度由跨越该边界的压力梯度决定。对于 $i=1/2$ 处的边界，$u_x(1/2,j,k)$（即 `ux[0,j,k]`）的更新取决于 $p(1,j,k) - p(0,j,k)$。诺伊曼边界条件强制 $p(0,j,k) = p(1,j,k)$，使得离散梯度为零。由于初始速度为零，所有物理边界上的法向速度必须保持为零。因此，该值预期为 $0.0$。\n- **非零速度计数**：初始压力 $p^n$ 是一个单点delta函数。速度更新 `u^{n+1/2}` 仅在 $p^n$ 梯度非零的地方非零。这只发生在与压力脉冲所在网格直接相邻的面上。对于不与边界相邻的中心脉冲，这将产生 $6$ 个非零速度分量（每个维度 $2$ 个）。如果脉冲紧邻边界，诺伊曼边界条件将使该方向的梯度无效，从而减少计数。\n    - 用例 A ($1 \\times 1 \\times 1$)：单个网格在所有方向上都与边界相邻。计数为 $0$。\n    - 用例 B ($3 \\times 2 \\times 1$)：中心是 $(2,2,1)$。它在 $x$ 方向上是内部的，但在 $y$ 和 $z$ 方向上位于内部域的边界。计数为 $2$ ($x$) + $1$ ($y$) + $0$ ($z$) = $3$。\n    - 用例 C ($4 \\times 3 \\times 2$)：中心是 $(3,2,2)$。它在 $x$ 和 $y$ 方向上是内部的，但在 $z$ 方向上位于边界。计数为 $2$ ($x$) + $2$ ($y$) + $1$ ($z$) = $5$。\n- **内部压力总和**：在交错网格上使用这些边界条件的FDTD格式会守恒一个离散的模拟量，即总声学质量 $\\int p \\, dV$。在整个内部体积上对散度项求和，可通过消项简化为边界上法向速度的和。由于这些法向速度为零，压力值总和的总变化量为零。因此，更新后的内部压力总和应等于初始总和，即 $1.0$。\n\n这些理论预测为实现的正确性提供了有力的验证。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(Nx, Ny, Nz, dx, dy, dz, rho, K):\n    \"\"\"\n    Performs one full leapfrog update cycle for the 3D acoustic equations.\n    \"\"\"\n    # 1. Calculate derived parameters\n    c = np.sqrt(K / rho)\n    dt = 0.5 * min(dx, dy, dz) / c\n\n    # 2. Initialize arrays with ghost layers\n    p_shape = (Nx + 2, Ny + 2, Nz + 2)\n    ux_shape = (Nx + 1, Ny + 2, Nz + 2)\n    uy_shape = (Nx + 2, Ny + 1, Nz + 2)\n    uz_shape = (Nx + 2, Ny + 2, Nz + 1)\n\n    p_n = np.zeros(p_shape)\n    ux_nm12 = np.zeros(ux_shape)\n    uy_nm12 = np.zeros(uy_shape)\n    uz_nm12 = np.zeros(uz_shape)\n    \n    # Set initial pressure a delta function at the interior center\n    ic = Nx // 2 + 1\n    jc = Ny // 2 + 1\n    kc = Nz // 2 + 1\n    p_n[ic, jc, kc] = 1.0\n\n    # 3. Apply homogeneous Neumann boundary conditions on pressure\n    def apply_p_boundary_conditions(p):\n        p[0, :, :] = p[1, :, :]\n        p[Nx + 1, :, :] = p[Nx, :, :]\n        p[:, 0, :] = p[:, 1, :]\n        p[:, Ny + 1, :] = p[:, Ny, :]\n        p[:, :, 0] = p[:, :, 1]\n        p[:, :, Nz + 1] = p[:, :, Nz]\n        return p\n\n    p_n = apply_p_boundary_conditions(p_n)\n\n    # 4. Update velocity components to time n+1/2\n    ux_np12 = ux_nm12 - (dt / rho) * (p_n[1:, :, :] - p_n[:-1, :, :]) / dx\n    uy_np12 = uy_nm12 - (dt / rho) * (p_n[:, 1:, :] - p_n[:, :-1, :]) / dy\n    uz_np12 = uz_nm12 - (dt / rho) * (p_n[:, :, 1:] - p_n[:, :, :-1]) / dz\n\n    # 5. Update pressure to time n+1\n    p_np1 = np.copy(p_n)\n    \n    # Divergence terms are calculated over the volume that affects interior pressure cells\n    # The slices are constructed to produce a result of shape (Nx, Ny, Nz)\n    div_ux = (ux_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - ux_np12[0:Nx, 1:Ny+1, 1:Nz+1]) / dx\n    div_uy = (uy_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uy_np12[1:Nx+1, 0:Ny, 1:Nz+1]) / dy\n    div_uz = (uz_np12[1:Nx+1, 1:Ny+1, 1:Nz+1] - uz_np12[1:Nx+1, 1:Ny+1, 0:Nz]) / dz\n\n    divergence = div_ux + div_uy + div_uz\n    \n    # Update only the interior pressure cells\n    p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1] -= K * dt * divergence\n\n    # 6. Compute required output quantities\n    \n    # 6.1. Max absolute boundary-normal velocity\n    # Normal velocities are on faces at i=0, Nx; j=0, Ny; k=0, Nz\n    max_vx_boundary = np.max(np.abs(np.concatenate([ux_np12[0, :, :].ravel(), ux_np12[Nx, :, :].ravel()])))\n    max_vy_boundary = np.max(np.abs(np.concatenate([uy_np12[:, 0, :].ravel(), uy_np12[:, Ny, :].ravel()])))\n    max_vz_boundary = np.max(np.abs(np.concatenate([uz_np12[:, :, 0].ravel(), uz_np12[:, :, Nz].ravel()])))\n    \n    max_boundary_v = max(max_vx_boundary, max_vy_boundary, max_vz_boundary)\n\n    # 6.2. Count of interior face velocities exceeding tolerance\n    tol = 1e-14\n    \n    # Interior faces are those used in the divergence calculation for interior pressure points\n    # ux faces: i in [0,Nx], j in [1,Ny], k in [1,Nz]\n    # uy faces: i in [1,Nx], j in [0,Ny], k in [1,Nz]\n    # uz faces: i in [1,Nx], j in [1,Ny], k in [0,Nz]\n    \n    # Slicing corresponds to array indices. uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1] means\n    # indices i from 1 to Nx, j from 0 to Ny, k from 1 to Nz.\n    count_ux = np.sum(np.abs(ux_np12[0:Nx+1, 1:Ny+1, 1:Nz+1]) > tol)\n    count_uy = np.sum(np.abs(uy_np12[1:Nx+1, 0:Ny+1, 1:Nz+1]) > tol)\n    count_uz = np.sum(np.abs(uz_np12[1:Nx+1, 1:Ny+1, 0:Nz+1]) > tol)\n    \n    nonzero_v_count = int(count_ux + count_uy + count_uz)\n\n    # 6.3. Sum of interior pressure values after update\n    interior_p_sum = np.sum(p_np1[1:Nx+1, 1:Ny+1, 1:Nz+1])\n\n    return max_boundary_v, nonzero_v_count, interior_p_sum\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite and prints the final result.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'Nx': 1, 'Ny': 1, 'Nz': 1, 'dx': 0.1, 'dy': 0.1, 'dz': 0.1, 'rho': 1.2, 'K': 1.4e5},\n        # Case B\n        {'Nx': 3, 'Ny': 2, 'Nz': 1, 'dx': 0.05, 'dy': 0.1, 'dz': 0.2, 'rho': 1.2, 'K': 1.01e5},\n        # Case C\n        {'Nx': 4, 'Ny': 3, 'Nz': 2, 'dx': 0.02, 'dy': 0.03, 'dz': 0.04, 'rho': 1.2, 'K': 1.5e5},\n    ]\n\n    results = []\n    for case in test_cases:\n        v_bound, v_count, p_sum = run_simulation(**case)\n        results.extend([v_bound, v_count, p_sum])\n\n    # Format the final output string exactly as required.\n    # The output values are formatted to avoid excessive precision.\n    formatted_results = []\n    for i, res in enumerate(results):\n        if (i % 3) == 0:  # Boundary velocity\n            formatted_results.append(f\"{res:.1g}\")\n        elif (i % 3) == 1:  # Count\n            formatted_results.append(str(res))\n        else:  # Pressure sum\n            formatted_results.append(f\"{res:.1f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```"
        }
    ]
}