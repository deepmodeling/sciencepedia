{
    "hands_on_practices": [
        {
            "introduction": "边界积分方程构建于基本解（即格林函数）之上。第一个动手实践将引导你推导二维亥姆霍兹格林函数在源点与场点相互靠近时的奇异行为。掌握这项解析技巧 ，对于理解为何需要以及如何开发特殊的数值处理技术至关重要。",
            "id": "4119646",
            "problem": "考虑在无界、均匀的二维介质中的时谐声传播。波数为 $k>0$ 的亥姆霍兹算子的自由空间格林函数（也称为基本解）是分布 $G(\\mathbf{x},\\mathbf{y})$，它在 $\\mathbb{R}^{2}$ 中满足偏微分方程（PDE）$(\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y})=-\\delta(\\mathbf{x}-\\mathbf{y})$ 以及出射 Sommerfeld 辐射条件。在直接和间接边界积分方程（BIE）的构建中，$G(\\mathbf{x},\\mathbf{y})$ 作为单层势和双层势的核函数出现。令 $r=|\\mathbf{x}-\\mathbf{y}|$。\n\na) 用零阶第一类 Hankel 函数显式地表示 $G(\\mathbf{x},\\mathbf{y})$。\n\nb) 仅使用经过充分检验的 Bessel 函数和 Hankel 函数的小宗量展开，推导当 $r\\to 0^{+}$ 时 $G(\\mathbf{x},\\mathbf{y})$ 的主阶渐近式，以揭示其对数奇异性。定义有限部分常数\n$$\nC(k)\\equiv \\lim_{r\\to 0^{+}}\\left[G(\\mathbf{x},\\mathbf{y})+\\frac{1}{2\\pi}\\ln r\\right],\n$$\n并计算 $C(k)$ 的闭式解，其中 $\\gamma$ 表示 Euler–Mascheroni 常数。将您的最终答案表示为 $C(k)$ 的单个解析表达式。",
            "solution": "该问题要求分析在 $\\mathbb{R}^{2}$ 中二维亥姆霍兹方程 $(\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y})=-\\delta(\\mathbf{x}-\\mathbf{y})$ 的自由空间格林函数。这个函数，也称为基本解，必须满足 Sommerfeld 辐射条件，以确保波在无穷远处是纯出射的。令 $r=|\\mathbf{x}-\\mathbf{y}|$ 为源点 $\\mathbf{y}$ 和观测点 $\\mathbf{x}$ 之间的距离。\n\na) 满足出射辐射条件的二维亥姆霍兹方程的基本解在偏微分方程和波传播理论中是公认的。它由零阶第一类 Hankel 函数（记作 $H_0^{(1)}$）给出。具体形式为：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(kr)\n$$\n常数前置因子 $\\frac{i}{4}$ 是一个归一化常数，它确保该函数满足定义的偏微分方程 $(\\Delta + k^2)G = -\\delta$。为验证此常数，可以在一个以 $\\mathbf{y}$ 为中心、半径为 $\\epsilon$ 的小圆盘 $B_{\\epsilon}$ 上对该偏微分方程进行积分，然后取 $\\epsilon \\to 0$ 的极限。使用散度定理，我们有：\n$$\n\\int_{B_{\\epsilon}} (\\Delta_{\\mathbf{x}}+k^{2})\\,G(\\mathbf{x},\\mathbf{y}) \\, d\\mathbf{x} = \\int_{\\partial B_{\\epsilon}} \\nabla_{\\mathbf{x}} G \\cdot \\mathbf{n} \\, dS + k^2 \\int_{B_{\\epsilon}} G \\, d\\mathbf{x}\n$$\n其中 $\\mathbf{n}$ 是边界 $\\partial B_{\\epsilon}$ 的外向单位法向量。该积分必须等于 $-\\int_{B_{\\epsilon}} \\delta(\\mathbf{x}-\\mathbf{y}) \\, d\\mathbf{x} = -1$。使用已知的 Hankel 函数的小宗量渐近式，可以证明当 $\\epsilon \\to 0$ 时，右边的第一项趋近于 $-1$，而第二项消失，这证实了前置因子 $\\frac{i}{4}$ 的选择是正确的。\n\nb) 为了确定有限部分常数 $C(k)$，我们必须首先找到当 $r \\to 0^{+}$ 时 $G(\\mathbf{x},\\mathbf{y})$ 的主阶渐近式。这需要构成 Hankel 函数的 Bessel 函数的小宗量展开式。Hankel 函数 $H_0^{(1)}(z)$ 定义为 $H_0^{(1)}(z) = J_0(z) + iY_0(z)$，其中 $J_0(z)$ 是零阶第一类 Bessel 函数，$Y_0(z)$ 是零阶第二类 Bessel 函数。\n\n对于小宗量 $z \\to 0$，它们的标准渐近展开式为：\n$$\nJ_0(z) = 1 - \\frac{z^2}{4} + O(z^4)\n$$\n$$\nY_0(z) = \\frac{2}{\\pi} \\left[ \\left(\\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) J_0(z) + \\frac{z^2}{4} - \\dots \\right]\n$$\n其中 $\\gamma \\approx 0.5772$ 是 Euler–Mascheroni 常数。\n\n对于 $z \\to 0$ 的主阶行为，我们可以近似 $J_0(z) \\approx 1$。因此，$Y_0(z)$ 的展开式简化为：\n$$\nY_0(z) = \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) + O(z^2 \\ln z)\n$$\n结合这些结果，$H_0^{(1)}(z)$ 的小宗量展开式为：\n$$\nH_0^{(1)}(z) = J_0(z) + iY_0(z) = 1 + i \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{z}{2}\\right) + \\gamma \\right) + O(z^2 \\ln z)\n$$\n现在，我们将 $z=kr$ 代入此展开式，以找到当 r 很小时 $G(\\mathbf{x},\\mathbf{y})$ 的行为：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} H_0^{(1)}(kr) = \\frac{i}{4} \\left[ 1 + i \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O((kr)^2 \\ln(kr)) \\right]\n$$\n将因子 $\\frac{i}{4}$ 乘进去：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} + \\frac{i^2}{4} \\frac{2}{\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n由于 $i^2 = -1$：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{kr}{2}\\right) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n我们可以使用对数的性质 $\\ln(a/b) = \\ln(a) - \\ln(b)$ 和 $\\ln(ab) = \\ln(a) + \\ln(b)$ 来分离含 r 的项：\n$$\nG(\\mathbf{x},\\mathbf{y}) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln(r) + \\ln(k) - \\ln(2) + \\gamma \\right) + O(r^2 \\ln r)\n$$\n$$\nG(\\mathbf{x},\\mathbf{y}) = -\\frac{1}{2\\pi} \\ln r + \\left[ \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) \\right] + O(r^2 \\ln r)\n$$\n这个表达式明确地揭示了当 $r \\to 0^{+}$ 时格林函数的对数奇异性。其主阶渐近行为是 $G(\\mathbf{x},\\mathbf{y}) \\sim -\\frac{1}{2\\pi}\\ln r$。\n\n有限部分常数 $C(k)$ 由以下极限定义：\n$$\nC(k) \\equiv \\lim_{r\\to 0^{+}}\\left[G(\\mathbf{x},\\mathbf{y})+\\frac{1}{2\\pi}\\ln r\\right]\n$$\n将我们得到的 $G(\\mathbf{x},\\mathbf{y})$ 的渐近表达式代入此定义中：\n$$\nC(k) = \\lim_{r\\to 0^{+}}\\left[ \\left(-\\frac{1}{2\\pi} \\ln r + \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) + O(r^2 \\ln r) \\right) + \\frac{1}{2\\pi}\\ln r \\right]\n$$\n对数奇异项相互抵消：\n$$\nC(k) = \\lim_{r\\to 0^{+}}\\left[ \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma) + O(r^2 \\ln r) \\right]\n$$\n当 $r \\to 0^{+}$ 时，$O(r^2 \\ln r)$ 项趋于零。因此，极限为：\n$$\nC(k) = \\frac{i}{4} - \\frac{1}{2\\pi} (\\ln(k) - \\ln(2) + \\gamma)\n$$\n这个表达式可以通过合并对数项来重写：\n$$\nC(k) = \\frac{i}{4} - \\frac{1}{2\\pi} \\left( \\ln\\left(\\frac{k}{2}\\right) + \\gamma \\right)\n$$\n这就是有限部分常数 $C(k)$ 的闭式表达式。",
            "answer": "$$\n\\boxed{\\frac{i}{4} - \\frac{1}{2\\pi}\\left(\\ln\\left(\\frac{k}{2}\\right) + \\gamma\\right)}\n$$"
        },
        {
            "introduction": "在理解了积分核的奇异性之后，下一个实践挑战是如何精确地计算这些边界积分。这项练习  从解析过渡到计算，要求你首先推导出单层算子“自影响”积分项的精确值，然后实现并评估几种专门用于处理弱奇异性的数值积分策略。这将为你提供处理边界元法核心挑战的直接经验。",
            "id": "4119598",
            "problem": "考虑由标量亥姆霍兹方程及其边界积分公式所描述的三维声散射问题。对于外问题，在直接边界积分方程 (BIE) 和间接边界积分方程 (BIE) 方法中，单层边界积分算子是通过将声压场表示为基本解与边界上未知密度的表面卷积而产生的。在声波数为零的静态极限下，该问题简化为拉普拉斯情形。三维拉普拉斯基本解由 $G(\\mathbf{x},\\mathbf{y}) = \\frac{1}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert}$ 给出，其中 $\\mathbf{x}$ 是场点，$\\mathbf{y}$ 是边界上的源点。对于边界元上的常数基函数，单层矩阵的对角自作用项对应一个弱奇异曲面积分，其中场点位于同一曲面元上。\n\n您的任务是，对于单位球面上的一个配置点 $\\mathbf{x}_0$，从第一性原理出发，推导拉普拉斯情形（$k=0$）下单位球面上单层算子对角自作用项的解析值。从整个单位球面 $S^2$ 上常数基的积分定义出发，自作用项可以写为\n$$\nI = \\int_{S^2} G(\\mathbf{x}_0,\\mathbf{y}) \\,\\mathrm{d}S_{\\mathbf{y}} = \\frac{1}{4\\pi}\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0-\\mathbf{y}\\rVert} \\,\\mathrm{d}S_{\\mathbf{y}}.\n$$\n使用单位球面上的几何关系，令极轴穿过 $\\mathbf{x}_0$，记极角为 $\\theta \\in [0,\\pi]$，方位角为 $\\phi \\in [0,2\\pi]$（角度以弧度为单位）。证明该积分是良定义的，并解析地计算其值。\n\n然后，实现一个程序，对同一积分进行数值近似，并用您推导出的解析值对三种奇异性感知的求积策略进行基准测试：\n\n- 策略 A（普通球面求积）：计算\n$$\nI_{\\mathrm{num}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n在 $\\theta$ 上使用高斯-勒让德求积，在 $\\phi$ 上使用均匀梯形法则。在 $\\theta=0$ 附近，实现对因子 $\\frac{\\sin\\theta}{2\\sin(\\theta/2)}$ 的数值稳定计算。\n\n- 策略 B（解析近场分离）：在一个小的极角截断值 $\\theta_c \\in (0,\\pi)$ 处将积分分割为\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\theta_c} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi + \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{\\theta_c}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\big(\\frac{\\theta}{2}\\big)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi,\n$$\n解析地计算近场部分，并使用高斯-勒让德求积（对 $\\theta$）和均匀梯形法则（对 $\\phi$）数值计算远场部分。\n\n- 策略 C（二次Duffy型映射）：通过二次变量替换 $\\theta = u^2$（其中 $u \\in [0,\\sqrt{\\pi}]$），将分辨率集中在弱奇异点附近，从而\n$$\nI_{\\mathrm{num}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\sqrt{\\pi}} \\frac{\\sin(u^2)}{2\\sin\\big(\\frac{u^2}{2}\\big)}\\cdot 2u \\,\\mathrm{d}u\\,\\mathrm{d}\\phi,\n$$\n并使用高斯-勒让德求积（对 $u$）和均匀梯形法则（对 $\\phi$）进行计算。\n\n所有角度都必须以弧度处理。您的程序必须计算每个数值近似值与您推导出的解析值之间的绝对误差。\n\n设计一个测试套件，涵盖不同的求积分辨率和近场截断值：\n- 对于策略 A：$(N_\\theta,N_\\phi) \\in \\{(4,8),(16,32),(64,128)\\}$。\n- 对于策略 B：$(N_\\theta,N_\\phi,\\theta_c) \\in \\{(16,32,0.1),(16,32,0.5),(16,32,1.0)\\}$。\n- 对于策略 C：$(N_u,N_\\phi) \\in \\{(16,32),(64,128)\\}$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，按上述测试套件指定的顺序排列，并表示为浮点数。例如，最后一行必须采用以下格式\n$$\n[\\text{error}_{A1},\\text{error}_{A2},\\text{error}_{A3},\\text{error}_{B1},\\text{error}_{B2},\\text{error}_{B3},\\text{error}_{C1},\\text{error}_{C2}].\n$$",
            "solution": "三维空间中时谐波的声散射问题由亥姆霍兹方程描述。在边界积分方程 (BIE) 公式中，直接和间接方法都使用基本解与边界上未知密度的曲面积分来表示解。拉普拉斯极限下的单层算子是核心：对于拉普拉斯方程，基本解为 $G(\\mathbf{x},\\mathbf{y}) = \\frac{1}{4\\pi\\lVert \\mathbf{x}-\\mathbf{y}\\rVert}$，当观察点位于边界元上时，这会产生一个弱奇异的被积函数。\n\n我们考虑单位球面 $S^2$，其整个表面上具有常数基，并且球面上有一个配置点 $\\mathbf{x}_0$。对于拉普拉斯情形，单层矩阵的对角自作用项为\n$$\nI = \\frac{1}{4\\pi}\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0 - \\mathbf{y}\\rVert}\\,\\mathrm{d}S_{\\mathbf{y}}.\n$$\n为了解析地计算它，我们选择一个球坐标系，使其极轴穿过 $\\mathbf{x}_0$。设 $\\theta$ 为极角，$\\phi$ 为方位角，其中 $\\theta \\in [0,\\pi]$，$\\phi \\in [0,2\\pi]$（角度以弧度为单位）。对于单位球面上的点，$\\mathbf{x}_0$ 和 $\\mathbf{y}$ 之间的欧几里得距离仅通过以下关系取决于极角 $\\theta$\n$$\n\\lVert \\mathbf{x}_0 - \\mathbf{y} \\rVert = \\sqrt{2-2\\cos\\theta} = 2\\sin\\left(\\frac{\\theta}{2}\\right).\n$$\n单位球面上的曲面元为\n$$\n\\mathrm{d}S = \\sin\\theta \\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi.\n$$\n因此，积分变为\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\frac{\\sin\\theta}{2\\sin\\left(\\frac{\\theta}{2}\\right)}\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi.\n$$\n请注意，在 $\\theta = 0$ 处的表观奇异性是可积的，因为曲面元中的因子 $\\sin\\theta$ 消除了核函数中 $1/\\sin(\\theta/2)$ 的行为。使用恒等式 $\\sin\\theta = 2\\sin(\\theta/2)\\cos(\\theta/2)$，被积函数简化为\n$$\n\\frac{\\sin\\theta}{2\\sin\\left(\\frac{\\theta}{2}\\right)} = \\cos\\left(\\frac{\\theta}{2}\\right),\n$$\n它在 $[0,\\pi]$ 上是光滑的。因此，\n$$\nI = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot \\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta.\n$$\n计算内层积分：\n$$\n\\int_{0}^{\\pi} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta = 2\\left[\\sin\\left(\\frac{\\theta}{2}\\right)\\right]_{0}^{\\pi} = 2.\n$$\n因此，\n$$\nI = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot 2 = 1.\n$$\n这个解析值与经典的位势理论结果一致：半径为 $a$ 的均匀带电球壳在壳上一点的牛顿位势为 $\\int_{S^2} \\frac{1}{\\lVert \\mathbf{x}_0 - \\mathbf{y}\\rVert}\\,\\mathrm{d}S_{\\mathbf{y}} = 4\\pi a$，对于 $a=1$ 和因子 $\\frac{1}{4\\pi}$，可得 $I=1$。\n\n用于数值基准测试的算法设计如下：\n\n- 对于策略A，我们使用具有 $N_\\theta$ 个节点的高斯-勒让德求积来近似 $[0,\\pi]$ 上的 $\\theta$ 积分，并使用具有 $N_\\phi$ 个点的均匀梯形法则来近似 $[0,2\\pi]$ 上的 $\\phi$ 积分。被积函数计算为 $\\frac{\\sin\\theta}{2\\sin(\\theta/2)}$，当 $\\sin(\\theta/2)$ 低于一个很小的阈值时，为了避免除以一个极小的数，会进行数值稳定的替换，改用 $\\cos(\\theta/2)$。\n\n- 对于策略 B，我们在截断值 $\\theta_c$ 处分割积分。近场部分解析计算如下：\n$$\nI_{\\mathrm{near}} = \\frac{1}{4\\pi}\\int_{0}^{2\\pi}\\int_{0}^{\\theta_c} \\cos\\left(\\frac{\\theta}{2}\\right)\\,\\mathrm{d}\\theta\\,\\mathrm{d}\\phi = \\frac{1}{4\\pi}\\cdot 2\\pi \\cdot 2\\sin\\left(\\frac{\\theta_c}{2}\\right) = \\sin\\left(\\frac{\\theta_c}{2}\\right).\n$$\n远场部分在 $[\\theta_c,\\pi]$ 上通过对 $\\theta$ 使用高斯-勒让德求积和对 $\\phi$ 使用梯形法则进行数值计算。总近似值为 $I_{\\mathrm{near}} + I_{\\mathrm{far}}$。\n\n- 对于策略 C，我们应用二次变量替换 $\\theta = u^2$，$u \\in [0,\\sqrt{\\pi}]$。变量替换的微分关系为 $\\mathrm{d}\\theta = 2u\\,\\mathrm{d}u$。被积函数变为 $\\frac{\\sin(u^2)}{2\\sin(u^2/2)}\\cdot 2u$，在 $u=0$ 附近，当分母很小时，通过切换到 $\\cos(u^2/2)\\cdot 2u$ 来进行稳定计算。我们在 $[0,\\sqrt{\\pi}]$ 上使用具有 $N_u$ 个节点的高斯-勒让德求积，并对 $\\phi$ 使用梯形法则。\n\n对于每个测试用例，程序计算数值估计值 $I_{\\mathrm{num}}$ 和绝对误差 $\\lvert I_{\\mathrm{num}} - 1\\rvert$，其中 $1$ 是上面推导出的解析值。结果在单行中生成，以方括号括起来的逗号分隔列表形式，并按测试套件的顺序排列。该设计测试了分辨率效应（通过 $N_\\theta$、$N_\\phi$、$N_u$）、弱奇异性的处理以及不同 $\\theta_c$ 下近场分离的影响。\n\n所有角度都必须以弧度处理，输出值为无量纲的浮点数。不需要物理单位，因为单位球面和拉普拉斯核的归一化因子 $\\frac{1}{4\\pi}$ 使得目标量无量纲。",
            "answer": "```python\nimport numpy as np\n\ndef gauss_legendre_interval(n, a, b):\n    # Nodes and weights on [a,b] from Legendre polynomial on [-1,1]\n    xi, wi = np.polynomial.legendre.leggauss(n)\n    # Affine map\n    x = 0.5*(b - a)*xi + 0.5*(b + a)\n    w = 0.5*(b - a)*wi\n    return x, w\n\ndef stable_sin_over_2sin_half(theta, eps=1e-14):\n    # Evaluate sin(theta)/(2*sin(theta/2)) stably near theta=0\n    half = 0.5 * theta\n    denom = np.sin(half)\n    # Where denom is small, use cos(theta/2)\n    out = np.empty_like(theta, dtype=np.float64)\n    mask = np.abs(denom) > eps\n    out[mask] = np.sin(theta[mask]) / (2.0 * denom[mask])\n    out[~mask] = np.cos(half[~mask])\n    return out\n\ndef strategy_plain(N_theta, N_phi):\n    # Integrate over theta in [0, pi] and phi in [0, 2pi]\n    theta, w_theta = gauss_legendre_interval(N_theta, 0.0, np.pi)\n    # Uniform trapezoidal rule for phi\n    phi_w = (2.0 * np.pi) / N_phi\n    # Integrand does not depend on phi; phi integration gives exactly 2*pi by trapezoid on constant function\n    f_theta = stable_sin_over_2sin_half(theta)\n    integral_theta = np.sum(w_theta * f_theta)\n    I_num = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_theta\n    return I_num\n\ndef strategy_near_analytic(N_theta, N_phi, theta_c):\n    # Near-field analytic part\n    I_near = np.sin(0.5 * theta_c)\n    # Far-field numerical part over theta in [theta_c, pi]\n    theta, w_theta = gauss_legendre_interval(N_theta, theta_c, np.pi)\n    phi_w = (2.0 * np.pi) / N_phi\n    f_theta = stable_sin_over_2sin_half(theta)\n    integral_theta = np.sum(w_theta * f_theta)\n    I_far = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_theta\n    return I_near + I_far\n\ndef strategy_u2(N_u, N_phi):\n    # Quadratic mapping theta = u^2, u in [0, sqrt(pi)]\n    u, w_u = gauss_legendre_interval(N_u, 0.0, np.sqrt(np.pi))\n    theta = u**2\n    # Integrand with Jacobian: sin(theta)/(2*sin(theta/2))*2u\n    core = stable_sin_over_2sin_half(theta)\n    f_u = core * (2.0 * u)\n    integral_u = np.sum(w_u * f_u)\n    phi_w = (2.0 * np.pi) / N_phi\n    I_num = (1.0 / (4.0 * np.pi)) * (N_phi * phi_w) * integral_u\n    return I_num\n\ndef solve():\n    # Analytic value from derivation\n    I_analytic = 1.0\n\n    # Define the test cases (ordered as specified)\n    test_cases = [\n        ('plain', 4, 8),\n        ('plain', 16, 32),\n        ('plain', 64, 128),\n        ('near_analytic', 16, 32, 0.1),\n        ('near_analytic', 16, 32, 0.5),\n        ('near_analytic', 16, 32, 1.0),\n        ('u2', 16, 32),\n        ('u2', 64, 128),\n    ]\n\n    results = []\n    for case in test_cases:\n        if case[0] == 'plain':\n            _, N_theta, N_phi = case\n            I_num = strategy_plain(N_theta, N_phi)\n        elif case[0] == 'near_analytic':\n            _, N_theta, N_phi, theta_c = case\n            I_num = strategy_near_analytic(N_theta, N_phi, theta_c)\n        elif case[0] == 'u2':\n            _, N_u, N_phi = case\n            I_num = strategy_u2(N_u, N_phi)\n        else:\n            I_num = np.nan\n        error = abs(I_num - I_analytic)\n        results.append(error)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```"
        },
        {
            "introduction": "除了单层势，双层势是边界积分方程的另一个基石，它引出了第二类积分方程。这项实践  聚焦于双层势在场点穿过边界时所表现出的著名跳跃性质。你将通过实现一个配置方案来数值化地捕捉这一跳跃，从而深入理解第二类边界积分方程的结构及其离散化方法。",
            "id": "4119643",
            "problem": "考虑由亥姆霍兹方程控制的时谐波的计算声学问题。设声压场用 $u(\\mathbf{x})$ 表示，它在二维空间中满足齐次亥姆霍兹偏微分方程，\n$$\n(\\nabla^2 + k^2) u(\\mathbf{x}) = 0,\n$$\n其中 $k > 0$ 是波数。二维亥姆霍兹方程的自由空间格林函数 $G(\\mathbf{x}, \\mathbf{y})$ 定义为\n$$\nG(\\mathbf{x}, \\mathbf{y}) = \\frac{\\mathrm{i}}{4} H_0^{(1)}\\left(k \\lvert \\mathbf{x} - \\mathbf{y} \\rvert \\right),\n$$\n其中 $H_0^{(1)}$ 是零阶第一类汉克尔函数，$\\mathrm{i}$ 是虚数单位。在光滑闭合边界 $\\Gamma$ 上分布的密度为 $\\varphi$ 的双层势 $\\mathcal{D}[\\varphi](\\mathbf{x})$ 由下式给出\n$$\n\\mathcal{D}[\\varphi](\\mathbf{x}) = \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n其中 $\\partial/\\partial n_{\\mathbf{y}}$ 表示在 $\\Gamma$ 上沿单位法向量 $\\mathbf{n}_{\\mathbf{y}}$ 对源点 $\\mathbf{y}$ 的法向导数。\n\n已知双层势的边界极限会表现出由 Plemelj-Sokhotski 公式描述的跳跃间断性。当从区域外部（法向朝外）趋近边界 $\\Gamma$ 时，双层势的极限满足\n$$\n\\lim_{\\mathbf{x} \\to \\Gamma^{+}} \\mathcal{D}[\\varphi](\\mathbf{x}) = \\frac{1}{2} \\varphi(\\mathbf{x}) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n而当从内部趋近时，\n$$\n\\lim_{\\mathbf{x} \\to \\Gamma^{-}} \\mathcal{D}[\\varphi](\\mathbf{x}) = -\\frac{1}{2} \\varphi(\\mathbf{x}) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y}),\n$$\n其中 $\\operatorname{P.V.}$ 表示柯西主值积分。这种带有 $\\pm \\frac{1}{2}$ 跳跃的边界极限在直接和间接边界积分方程格式中都至关重要：在直接格式中，将边界条件施加在 $\\Gamma$ 上 $u(\\mathbf{x})$ 的物理迹上，并使用位势理论来获得包含 $\\frac{1}{2}$ 单位项的第二类边界积分方程；在间接格式中，用一个带有未知密度的位势拟设来表示场，并再次施加边界条件，从而产生相同的跳跃结构。\n\n你的任务是在一条光滑闭合曲线上实现一个配置格式，通过在每个配置点显式地计算主值积分并加上单位项，从而数值上实现带 $\\frac{1}{2}$ 跳跃的边界极限。使用半径 $a = 1$ 的单位圆 $\\Gamma = \\{\\mathbf{y}(\\theta) = (a \\cos \\theta, a \\sin \\theta) : \\theta \\in [0, 2\\pi)\\}$，其向外单位法向量为 $\\mathbf{n}_{\\mathbf{y}}(\\theta) = (\\cos \\theta, \\sin \\theta)$。用角度 $\\theta$（单位为弧度）对边界进行参数化。弧长元为 $\\mathrm{d}\\Gamma(\\mathbf{y}) = a \\, \\mathrm{d}\\theta$。\n\n对于配置点 $\\theta_i = 2\\pi i / N$（$i = 0, 1, \\dots, N-1$），定义离散算子矩阵 $\\mathbf{A} \\in \\mathbb{C}^{N \\times N}$，它近似于\n$$\n\\left( s \\, \\mathbf{I} + \\mathcal{K} \\right) \\varphi(\\theta_i) \\approx s \\, \\varphi(\\theta_i) + \\sum_{j \\neq i} w \\, K(\\theta_i, \\theta_j) \\, \\varphi(\\theta_j),\n$$\n其中 $s \\in \\{+1/2, -1/2\\}$ 表示外部或内部边界极限，$\\mathbf{I}$ 是单位矩阵，$w = \\frac{2\\pi a}{N}$ 是梯形法则的权重，以及\n$$\nK(\\theta_i, \\theta_j) = \\frac{\\partial G(\\mathbf{x}(\\theta_i), \\mathbf{y}(\\theta_j))}{\\partial n_{\\mathbf{y}}} = \\frac{\\mathrm{i} k}{4} H_1^{(1)}\\left(k r_{ij}\\right) \\frac{(\\mathbf{x}(\\theta_i) - \\mathbf{y}(\\theta_j)) \\cdot \\mathbf{n}_{\\mathbf{y}}(\\theta_j)}{r_{ij}},\n$$\n其中 $r_{ij} = \\lvert \\mathbf{x}(\\theta_i) - \\mathbf{y}(\\theta_j) \\rvert$ 且 $H_1^{(1)}$ 为一阶第一类汉克尔函数。通过在求和中省略 $j = i$ 项，并在对角线元素上加上单位项 $s$ 来实现主值，即设置 $A_{ii} = s$ 以及当 $i \\neq j$ 时 $A_{ij} = w \\, K(\\theta_i, \\theta_j)$。\n\n为了使问题在无需预先假设解析特征结构的情况下可进行数值测试，请使用一个人为构造的密度函数 $\\varphi(\\theta)$，并通过过采样求积法计算右端项 $g(\\theta_i)$。该方法以更高的分辨率近似主值积分，以模拟“连续”积分。具体而言，对于每个配置点 $\\theta_i$，定义一个过采样网格 $\\theta'_m = 2\\pi (m + 1/2)/M$（$m = 0, 1, \\dots, M-1$）以避免点重合，设置 $w' = 2\\pi a / M$，并近似计算\n$$\ng(\\theta_i) \\approx s \\, \\varphi(\\theta_i) + \\sum_{m=0}^{M-1} w' \\, K(\\theta_i, \\theta'_m) \\, \\varphi(\\theta'_m),\n$$\n其中 $K(\\theta_i, \\theta'_m)$ 使用 $\\mathbf{y}(\\theta'_m)$ 和 $\\mathbf{n}_{\\mathbf{y}}(\\theta'_m)$ 进行类似计算。\n\n将密度函数构造为\n$$\n\\varphi(\\theta) = e^{\\mathrm{i} 3 \\theta} + \\frac{1}{2} e^{-\\mathrm{i} 2 \\theta}.\n$$\n\n你的程序必须：\n- 使用上述配置格式为给定参数 $(k, N, s, a)$ 构建矩阵 $\\mathbf{A}$。\n- 使用具有 $(M = \\alpha N)$ 个点且在 $\\theta$ 上有半步平移的过采样主值积分来计算 $g(\\theta_i)$。\n- 求解离散线性系统 $\\mathbf{A} \\, \\hat{\\varphi} = \\mathbf{g}$ 以恢复对所构造的 $\\varphi(\\theta_i)$ 的近似解 $\\hat{\\varphi}$。\n- 报告相对加权 $\\ell^2$ 误差\n$$\nE = \\frac{\\left( \\sum_{i=0}^{N-1} \\lvert \\hat{\\varphi}_i - \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}{\\left( \\sum_{i=0}^{N-1} \\lvert \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}.\n$$\n\n角度单位必须是弧度。输出不需要物理单位。\n\n为以下参数集测试套件实现此过程 $(k, N, s, a, \\alpha)$：\n1. $(k = 2.0, N = 128, s = +\\frac{1}{2}, a = 1.0, \\alpha = 4)$。\n2. $(k = 2.0, N = 64, s = -\\frac{1}{2}, a = 1.0, \\alpha = 4)$。\n3. $(k = 0.1, N = 128, s = +\\frac{1}{2}, a = 1.0, \\alpha = 8)$。\n4. $(k = 20.0, N = 256, s = +\\frac{1}{2}, a = 1.0, \\alpha = 8)$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，例如，“[result1,result2,result3,result4]”。每个结果必须是一个浮点数，表示相应测试用例的相对误差 $E$。请使用指定的波数，并确保整个过程中角度变量 $\\theta$ 的单位是弧度。",
            "solution": "用户提供的问题已经过分析，并被认为是有效的。它在科学上基于计算声学和边界元法的原理，是适定的，并为数值验证任务提供了一套完整、无歧义的指令。该问题要求实现一种配置边界元法，以在圆形域上求解亥姆霍兹方程，特别是为了验证双层势跳跃条件的数值表示。\n\n解决方案的步骤是：首先离散化边界积分算子，然后使用人工解法构造右端向量，接着求解所得的线性系统，最后计算数值解的误差。\n\n### 1. 基于原理的数值格式设计\n\n问题的核心在于对边界积分方程的数值近似，该方程源于使用位势理论表示声场 $u(\\mathbf{x})$。对于边界 $\\Gamma$ 上的密度函数 $\\varphi$，双层势算子 $\\mathcal{D}[\\varphi]$ 的边界极限得到算子 $s\\mathbf{I} + \\mathcal{K}$，其中 $\\mathcal{K}$ 是柯西主值积分部分， $s\\mathbf{I}$ 是跳跃项，而 $s = \\pm 1/2$ 取决于极限的方向（外部/内部）。我们将构造该算子的离散版本并进行测试。\n\n#### 1.1. 边界离散化与求积\n\n边界 $\\Gamma$ 是一个半径为 $a$ 的圆，通过角度 $\\theta \\in [0, 2\\pi)$ 参数化为 $\\mathbf{y}(\\theta) = (a \\cos \\theta, a \\sin \\theta)$。我们使用一组均匀分布的配置点将此边界离散为 $N$ 个分段。配置点 $\\mathbf{x}_i$ 对应于角度 $\\theta_i = 2\\pi i / N$，$i = 0, 1, \\dots, N-1$。\n\n积分算子 $\\mathcal{K}$ 涉及在 $\\Gamma$ 上的一个积分。我们使用梯形法则来近似该积分。来自以源点 $\\mathbf{y}_j$ 为中心的每个分段的贡献，由该分段的弧长加权，弧长近似为 $w = 2\\pi a / N$。\n\n#### 1.2. 边界积分算子的离散化\n\n我们构造一个 $N \\times N$ 的复矩阵 $\\mathbf{A}$，它表示算子 $s\\mathbf{I} + \\mathcal{K}$ 的离散形式。\n\n对于 $i \\neq j$，非对角元素 $A_{ij}$ 近似积分算子 $\\mathcal{K}$ 的作用。这是通过配置法实现的，我们在每一对配置点 $\\mathbf{x}_i$ 和源点 $\\mathbf{y}_j$ 之间计算积分核。\n$$\nA_{ij} = w \\, K(\\theta_i, \\theta_j) \\quad \\text{for } i \\neq j\n$$\n这里，$K(\\theta_i, \\theta_j)$ 是双层势算子的核：\n$$\nK(\\theta_i, \\theta_j) = \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y}_j)}{\\partial n_{\\mathbf{y}_j}} = \\frac{\\mathrm{i} k}{4} H_1^{(1)}\\left(k r_{ij}\\right) \\frac{(\\mathbf{x}_i - \\mathbf{y}_j) \\cdot \\mathbf{n}_{\\mathbf{y}_j}}{r_{ij}}\n$$\n其中 $\\mathbf{x}_i = \\mathbf{y}(\\theta_i)$，$\\mathbf{y}_j = \\mathbf{y}(\\theta_j)$，$r_{ij} = \\lvert \\mathbf{x}_i - \\mathbf{y}_j \\rvert$，$\\mathbf{n}_{\\mathbf{y}_j}$ 是在 $\\mathbf{y}_j$ 处的向外单位法向量，对于圆来说，它就是 $\\mathbf{y}_j/a$。汉克尔函数 $H_1^{(1)}$ 是一阶第一类汉克尔函数。\n\n对角元素 $A_{ii}$ 直接包含了 Plemelj-Sokhotski 公式中的跳跃项 $s$。主值积分的公式涉及移除在 $\\mathbf{y}=\\mathbf{x}$ 处的奇点。在这种简单的配置格式中，这是通过从求和中省略奇异项 $j=i$ 来实现的，并且来自单位算子 $\\mathbf{I}$ 的跳跃项被加到对角线上。\n$$\nA_{ii} = s\n$$\n这个组装规则产生了近似 $s\\mathbf{I} + \\mathcal{K}$ 的离散矩阵算子 $\\mathbf{A}$。\n\n#### 1.3. 人工解法\n\n为了验证我们离散算子 $\\mathbf{A}$ 的正确性，我们使用人工解法。我们构造一个光滑的密度函数 $\\varphi(\\theta)$，对于这个函数，我们可以计算出算子 $(s\\mathbf{I} + \\mathcal{K})\\varphi$ 作用下的“真实”结果。这个真实结果将作为我们线性系统中的右端向量 $\\mathbf{g}$。\n\n人工构造的密度由 $\\varphi(\\theta) = e^{\\mathrm{i} 3 \\theta} + \\frac{1}{2} e^{-\\mathrm{i} 2 \\theta}$ 给出。\n\n向量 $\\mathbf{g}$ 是通过高精度地近似连续积分来构造的。对于每个配置点 $\\theta_i$，我们如下计算 $g_i$：\n$$\ng_i = s \\, \\varphi(\\theta_i) + \\operatorname{P.V.} \\int_{\\Gamma} \\frac{\\partial G(\\mathbf{x}_i, \\mathbf{y})}{\\partial n_{\\mathbf{y}}} \\, \\varphi(\\mathbf{y}) \\, \\mathrm{d}\\Gamma(\\mathbf{y})\n$$\n该积分使用一个更精细的、具有 $M = \\alpha N$ 个点的过采样求积法则来计算。为了在此参考计算中避免任何奇点，过采样网格点被平移了半步：$\\theta'_m = 2\\pi (m + 1/2)/M$，$m=0, 1, \\dots, M-1$。相应的求积权重为 $w' = 2\\pi a / M$。然后，向量 $\\mathbf{g}$ 的第 $i$ 个分量计算如下：\n$$\ng_i \\approx s \\, \\varphi(\\theta_i) + \\sum_{m=0}^{M-1} w' \\, K(\\theta_i, \\theta'_m) \\, \\varphi(\\theta'_m)\n$$\n\n#### 1.4. 系统求解与误差计算\n\n在构造好矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{g}$ 后，我们求解线性系统 $\\mathbf{A} \\hat{\\mathbf{\\varphi}} = \\mathbf{g}$ 以得到向量 $\\hat{\\mathbf{\\varphi}}$。向量 $\\hat{\\mathbf{\\varphi}}$ 包含了在配置点上对精确密度值 $\\varphi(\\theta_i)$ 的数值近似解 $\\hat{\\varphi}_i$。\n\n最后，我们通过计算相对加权 $\\ell^2$ 误差 $E$ 来量化数值解的精度：\n$$\nE = \\frac{\\left( \\sum_{i=0}^{N-1} \\lvert \\hat{\\varphi}_i - \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}{\\left( \\sum_{i=0}^{N-1} \\lvert \\varphi(\\theta_i) \\rvert^2 \\, w \\right)^{1/2}}\n$$\n由于梯形权重 $w$ 对于均匀网格是常数，它在分子和分母中被消去。误差度量简化为误差向量的标准相对欧几里得范数：\n$$\nE = \\frac{\\|\\hat{\\mathbf{\\varphi}} - \\mathbf{\\varphi}_{\\text{exact}}\\|_2}{\\|\\mathbf{\\varphi}_{\\text{exact}}\\|_2}\n$$\n其中 $(\\mathbf{\\varphi}_{\\text{exact}})_i = \\varphi(\\theta_i)$。一个小的误差 $E$ 表明离散算子 $\\mathbf{A}$ 正确地表示了连续算子 $s\\mathbf{I} + \\mathcal{K}$。对每个指定的测试用例重复此过程。",
            "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import hankel1\n\ndef solve():\n    \"\"\"\n    Main function to run the boundary element method verification for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (k, N, s, a, alpha)\n        (2.0, 128, +0.5, 1.0, 4),\n        (2.0, 64,  -0.5, 1.0, 4),\n        (0.1, 128, +0.5, 1.0, 8),\n        (20.0, 256, +0.5, 1.0, 8),\n    ]\n\n    results = []\n    for params in test_cases:\n        error = compute_bem_error(*params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef compute_bem_error(k, N, s, a, alpha):\n    \"\"\"\n    Computes the relative error for a single BEM test case.\n\n    Args:\n        k (float): Wavenumber.\n        N (int): Number of collocation points.\n        s (float): Jump term (+0.5 for exterior, -0.5 for interior).\n        a (float): Radius of the circular boundary.\n        alpha (int): Oversampling factor for RHS calculation.\n\n    Returns:\n        float: The relative weighted l2 error.\n    \"\"\"\n    # 1. Discretization and manufactured solution\n    theta = 2 * np.pi * np.arange(N) / N\n    w = 2 * np.pi * a / N\n    \n    # Manufactured density evaluated at collocation points\n    phi_exact_at_theta = np.exp(1j * 3 * theta) + 0.5 * np.exp(-1j * 2 * theta)\n    x_pts = a * np.stack((np.cos(theta), np.sin(theta)), axis=1)\n\n    # 2. Assemble matrix A\n    # Use broadcasting for vectorized computation of all pairs (i, j)\n    # xi_b: (N, 1, 2), yj_b: (1, N, 2)\n    xi_b = x_pts[:, np.newaxis, :]\n    yj_b = x_pts[np.newaxis, :, :]\n    \n    # Vector from source yj to target xi, shape: (N, N, 2)\n    diff_vec = xi_b - yj_b\n    \n    # Distance matrix r_ij, shape: (N, N)\n    r_ij = np.linalg.norm(diff_vec, axis=2)\n    \n    # Normal vectors n_y at yj, shape: (1, N, 2)\n    ny_j_b = yj_b / a\n    \n    # Dot product (xi - yj) . n_yj, shape: (N, N)\n    dot_prod = np.sum(diff_vec * ny_j_b, axis=2)\n    \n    # Kernel K(theta_i, theta_j) for i != j\n    # Suppress warnings for division by zero on the diagonal (r_ij=0)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel_val = (1j * k / 4) * hankel1(1, k * r_ij) * (dot_prod / r_ij)\n    \n    # Construct matrix A\n    A = w * kernel_val\n    np.fill_diagonal(A, s) # A_ii = s\n\n    # 3. Assemble RHS vector g using oversampling (vectorized)\n    M = alpha * N\n    theta_prime = 2 * np.pi * (np.arange(M) + 0.5) / M\n    w_prime = 2 * np.pi * a / M\n\n    # Oversampled source points y' and normals n'\n    y_prime_pts = a * np.stack((np.cos(theta_prime), np.sin(theta_prime)), axis=1)\n    n_prime_pts = y_prime_pts / a\n\n    # Manufactured density at oversampled points\n    phi_prime = np.exp(1j * 3 * theta_prime) + 0.5 * np.exp(-1j * 2 * theta_prime)\n\n    # Vectorize computation over all (i, m) pairs\n    # xi_g_b: (N, 1, 2), y_prime_b: (1, M, 2)\n    y_prime_b = y_prime_pts[np.newaxis, :, :]\n    n_prime_b = n_prime_pts[np.newaxis, :, :]\n    \n    # Vector from source y' to target x, shape: (N, M, 2)\n    diff_vec_g = xi_b - y_prime_b\n    # Distances r_im, shape: (N, M)\n    r_im = np.linalg.norm(diff_vec_g, axis=2)\n    # Dot product, shape: (N, M)\n    dot_prod_g = np.sum(diff_vec_g * n_prime_b, axis=2)\n    \n    # Kernel matrix K(theta_i, theta'_m), shape: (N, M)\n    kernel_g_mat = (1j * k / 4) * hankel1(1, k * r_im) * (dot_prod_g / r_im)\n    \n    # Integral part by summing over m for each i, shape: (N,)\n    integral_part = np.sum(w_prime * kernel_g_mat * phi_prime, axis=1)\n    \n    # Assemble g\n    g = s * phi_exact_at_theta + integral_part\n        \n    # 4. Solve the linear system\n    phi_hat = np.linalg.solve(A, g)\n    \n    # 5. Compute the relative l2 error\n    # The weight w cancels in the relative error formula.\n    error_num = np.linalg.norm(phi_hat - phi_exact_at_theta)\n    error_den = np.linalg.norm(phi_exact_at_theta)\n    \n    if error_den == 0:\n        return 0.0 if error_num == 0 else np.inf\n        \n    return error_num / error_den\n\nif __name__ == \"__main__\":\n    solve()\n```"
        }
    ]
}